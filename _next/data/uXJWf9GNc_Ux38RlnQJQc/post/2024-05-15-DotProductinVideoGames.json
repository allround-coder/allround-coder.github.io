{"pageProps":{"post":{"title":"비디오 게임에서의 내적곱","description":"","date":"2024-05-15 03:26","slug":"2024-05-15-DotProductinVideoGames","content":"\n\n## 내적이란 무엇인가요?\n\n내적은 두 벡터 사이에서 수행할 수 있는 가장 중요한 연산 중 하나입니다.\n\n![image](/assets/img/2024-05-15-DotProductinVideoGames_0.png)\n\n우리는 각 벡터의 해당 구성 요소를 곱하고 모두 합하여 내적을 계산할 수 있습니다.\n\n\n\n\n![image1](/assets/img/2024-05-15-DotProductinVideoGames_1.png)\n\nor by multiplying the length of the two vectors by the cosine of the angle between them\n\n![image2](/assets/img/2024-05-15-DotProductinVideoGames_2.png)\n\nThe result is a scalar that represents the projection of one vector onto another.\n\n\n\n\n\n![image](/assets/img/2024-05-15-DotProductinVideoGames_3.png)\n\nBut things become more interesting if the vectors are both normalized.\nA normalized vector has a length of one.\n\n![image](/assets/img/2024-05-15-DotProductinVideoGames_4.png)\n\nWe can normalize a vector by dividing each component by its length.\n\n\n\n\n\n![image](/assets/img/2024-05-15-DotProductinVideoGames_5.png)\n\nNow we can replace both lengths in our formula with one, and since multiplying by one doesn’t change anything, we are left with the cosine of the angle between the two vectors.\n\n![image](/assets/img/2024-05-15-DotProductinVideoGames_6.png)\n\nIf the vectors are pointing in the same direction, the angle between them is zero, the cosine of zero is one\n\n\n\n\n![](/assets/img/2024-05-15-DotProductinVideoGames_7.png)\n\n만약 두 벡터가 서로 수직이면, 그들 사이의 각은 90도 입니다. 90도의 코사인 값은 0입니다.\n\n![](/assets/img/2024-05-15-DotProductinVideoGames_8.png)\n\n만약 두 벡터가 서로 반대 방향을 가리키면, 그들 사이의 각은 180도 입니다. 180도의 코사인 값은 -1입니다.\n\n\n\n\n![Dot Product in Video Games](/assets/img/2024-05-15-DotProductinVideoGames_9.png)\n\nAnd any other angle will give us a value between 1 and -1\n\n## Dot Product Use Cases\n\n- checking the relativity between two objects\n\n\n\n\n\n<img src=\"/assets/img/2024-05-15-DotProductinVideoGames_10.png\" />\n\n두 캐릭터, 플레이어와 적이 있다고 가정해 봅시다. 플레이어가 적의 앞에 있는지 뒤에 있는지 알고 싶습니다.\n\n<img src=\"/assets/img/2024-05-15-DotProductinVideoGames_11.png\" />\n\n첫 번째로 할 일은 적에서 플레이어로 향하는 방향을 계산하는 것입니다.\n이를 위해 적의 위치에서 플레이어의 위치를 빼면 됩니다. \n이렇게 하면 적에서 플레이어로 향하는 벡터가 생성되며, 그 길이는 적과 플레이어 사이의 거리와 같습니다.\n\n\n\n\n아래는 Markdown 형식으로 표현했습니다.\n\n\n![이미지1](/assets/img/2024-05-15-DotProductinVideoGames_12.png)\n\n그런 다음, 우리는 방향 벡터를 정규화합니다. 다시 말해, 길이를 1로 만듭니다.\n\n![이미지2](/assets/img/2024-05-15-DotProductinVideoGames_13.png)\n\n그런 다음, 방향 벡터와 적의 전진 벡터 사이의 점곱을 계산합니다.\n\n\n\n\n![이미지](/assets/img/2024-05-15-DotProductinVideoGames_14.png)\n\n여기서는 임계값 간격을 설정할 수 있어요. 이 경우 0.85입니다.\n\n![이미지](/assets/img/2024-05-15-DotProductinVideoGames_15.png)\n\n만약 내적 값이 임계값 이상이라면, 플레이어가 적 앞에 있다는 것을 알 수 있고, 적이 플레이어를 따라다니는 등의 행동을 할 수 있어요.\n\n\n\n\n![이미지](/assets/img/2024-05-15-DotProductinVideoGames_16.png)\n\n우리는 임계값을 -0.85로 설정할 수도 있고, 그러면 닷 프로덕트가 임계값보다 작거나 같은지 확인하여 반대로 처리하고, 플레이어가 뒤쪽에 있는지 확인하여 스니크 어택과 같은 특정 행동을 수행할 수 있습니다.\n\n- 조명 시뮬레이션\n\n우리는 닷 프로덕트를 사용하여 물체를 조명(빛의 영향을 받는)할 수 있습니다.\n\n\n\n\n\n![Image](/assets/img/2024-05-15-DotProductinVideoGames_17.png)\n\nTo achieve this, we require a 3D object and a light source.\n\n![Image](/assets/img/2024-05-15-DotProductinVideoGames_18.png)\n\nThe initial step is to calculate the direction from the 3D object to the light source.\n\n\n\n\n\n![이미지](/assets/img/2024-05-15-DotProductinVideoGames_19.png)\n\n그런 다음 빛 벡터를 정규화합니다.\n\n![이미지](/assets/img/2024-05-15-DotProductinVideoGames_20.png)\n\n그런 다음 빛 벡터와 3D 객체의 법선 벡터 간의 내적을 계산하세요.\n\n\n\n\n\n![영상게임에서의 내적](/assets/img/2024-05-15-DotProductinVideoGames_21.png)\n\n그리고 불을 켜주세요.\n","ogImage":{"url":"/assets/img/2024-05-15-DotProductinVideoGames_0.png"},"coverImage":"/assets/img/2024-05-15-DotProductinVideoGames_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"내적이란 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"내적은 두 벡터 사이에서 수행할 수 있는 가장 중요한 연산 중 하나입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_0.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 각 벡터의 해당 구성 요소를 곱하고 모두 합하여 내적을 계산할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_1.png\",\n        alt: \"image1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"or by multiplying the length of the two vectors by the cosine of the angle between them\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_2.png\",\n        alt: \"image2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The result is a scalar that represents the projection of one vector onto another.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_3.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But things become more interesting if the vectors are both normalized.\\nA normalized vector has a length of one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_4.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can normalize a vector by dividing each component by its length.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_5.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we can replace both lengths in our formula with one, and since multiplying by one doesn’t change anything, we are left with the cosine of the angle between the two vectors.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_6.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If the vectors are pointing in the same direction, the angle between them is zero, the cosine of zero is one\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_7.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 두 벡터가 서로 수직이면, 그들 사이의 각은 90도 입니다. 90도의 코사인 값은 0입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_8.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 두 벡터가 서로 반대 방향을 가리키면, 그들 사이의 각은 180도 입니다. 180도의 코사인 값은 -1입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_9.png\",\n        alt: \"Dot Product in Video Games\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And any other angle will give us a value between 1 and -1\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Dot Product Use Cases\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"checking the relativity between two objects\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-15-DotProductinVideoGames_10.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"두 캐릭터, 플레이어와 적이 있다고 가정해 봅시다. 플레이어가 적의 앞에 있는지 뒤에 있는지 알고 싶습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-15-DotProductinVideoGames_11.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫 번째로 할 일은 적에서 플레이어로 향하는 방향을 계산하는 것입니다.\\n이를 위해 적의 위치에서 플레이어의 위치를 빼면 됩니다.\\n이렇게 하면 적에서 플레이어로 향하는 벡터가 생성되며, 그 길이는 적과 플레이어 사이의 거리와 같습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 Markdown 형식으로 표현했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_12.png\",\n        alt: \"이미지1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음, 우리는 방향 벡터를 정규화합니다. 다시 말해, 길이를 1로 만듭니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_13.png\",\n        alt: \"이미지2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음, 방향 벡터와 적의 전진 벡터 사이의 점곱을 계산합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_14.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서는 임계값 간격을 설정할 수 있어요. 이 경우 0.85입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_15.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 내적 값이 임계값 이상이라면, 플레이어가 적 앞에 있다는 것을 알 수 있고, 적이 플레이어를 따라다니는 등의 행동을 할 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_16.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 임계값을 -0.85로 설정할 수도 있고, 그러면 닷 프로덕트가 임계값보다 작거나 같은지 확인하여 반대로 처리하고, 플레이어가 뒤쪽에 있는지 확인하여 스니크 어택과 같은 특정 행동을 수행할 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"조명 시뮬레이션\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 닷 프로덕트를 사용하여 물체를 조명(빛의 영향을 받는)할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_17.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To achieve this, we require a 3D object and a light source.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_18.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The initial step is to calculate the direction from the 3D object to the light source.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_19.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 빛 벡터를 정규화합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_20.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 빛 벡터와 3D 객체의 법선 벡터 간의 내적을 계산하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-DotProductinVideoGames_21.png\",\n        alt: \"영상게임에서의 내적\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 불을 켜주세요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}