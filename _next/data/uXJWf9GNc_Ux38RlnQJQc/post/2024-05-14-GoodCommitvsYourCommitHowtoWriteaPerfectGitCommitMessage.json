{"pageProps":{"post":{"title":"좋은 커밋 대 나의 커밋 완벽한 Git 커밋 메시지 작성법","description":"","date":"2024-05-14 13:53","slug":"2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage","content":"\n\n수 년 전, 궁금증 때문에 커밋 메시지 작성에 대한 구체적인 규칙이 있다는 것을 알지 못했어요. 예전엔 \"기능 2 추가\", \"메인 네비게이션 바 버그 수정\", 혹은 \"foo\"와 같이 간단한 메시지가 충분하다고 생각했어요. 하지만 커밋 메시지가 대부분 무시당한다고 생각했던 것은 잘못된 생각이었어요. 실제로, 신중하고 세심하게 작성된 커밋 메시지는 우리 미래의 자신이 우리의 성실함과 세심함에서 이익을 얻게끔 해주는 필수적인 역할을 합니다.\n\n목차: 왜 깨끗한 커밋 메시지 작성에 신경을 써야 할까? | 흔한 실수들 | 7가지 규칙 | 사례 연구 | 팁.\n\n# 왜 깨끗한 커밋 메시지 작성이 중요할까요?\n\n\n\n커밋은 프로그래머의 기술의 구체적인 구성 요소로 작용합니다. 코드의 완성을 나타내며, 올바르게 작성되면 상당한 가치를 제공합니다. 잘 쓰여진 커밋 메시지는 필수불가결합니다. 왜냐하면 컨텍스트를 제공하기 때문입니다. 그렇지 않으면 커밋 메시지는 처음부터 필요하지 않을 것입니다.\n\n개발자들 사이의 일반적인 실수 중 하나는 Git 저장소를 백업 시스템으로 취급하는 것입니다. 현재 코드 상태를 캡처하기 위해 무작위로 커밋하는 것은 미래에 코드베이스를 확인할 때 과거 변경 사항을 이해하는 능력을 방해할 수 있습니다. \"WIP\", \"Off for lunch\", \"End of code for today\", \"I am tired AF\", \"Happy Weekend Team\", \"First to commit\"과 같은 커밋 메시지는 추가적인 가치가 전혀 없기 때문에 Git 로그를 혼란스럽게 만들며, 본질적인 커밋 내용을 파악하기 어렵게 만들 수 있습니다.\n\n# 원격 저장소에 커밋할 때 피해야 할 몇 가지 주요 실수가 여기 있습니다.\n\n## 서로 다른 파일에 대한 변경 사항을 분리하여 커밋하지 마세요.\n\n\n\n다른 팀원들과 협업하거나 커밋 기록을 검토할 때 각 파일을 따로 커밋하는 것은 문제를 야기할 수 있습니다. 변경 사항의 전체 맥락을 이해하고 서로 간의 관계를 파악하는 데 어려움을 겪을 수 있어요.\n\n예를 들어, 온라인 상점을 만들고 있다고 가정해봅시다. 아래와 같이 하면 안 되죠:\n\n```js\n# header.js에 대한 변경 사항을 따로 커밋\ngit add header.js\ngit commit -m \"헤더 레이아웃 개선\"\n\n# footer.js에 대한 변경 사항을 따로 커밋\ngit add footer.js\ngit commit -m \"푸터 디자인 최적화\"\n```\n\n커밋 구조가 이러한 형태인 경우, 커밋 기록이 증가함에 따라 일관되지 못할 수 있어요.\n\n\n\n커밋은 명확하고 간결하며 논리적인 단위로 구성되어야 합니다. 예를 들어, 코드 레이아웃 섹션을 완료한 후 헤더와 푸터 섹션을 작업한 경우, 이러한 변경 사항을 커밋하기 전에 변경 사항들을 결합하는 것이 깔끔합니다:\n\n```js\n# header.js 및 footer.js의 Staging 변경 사항\ngit add header.js footer.js\n\n# 관련 변경 사항 함께 커밋\ngit commit -m \"UI 개선: 헤더 및 푸터 개선\"\n```\n\n이론적으로는 쉽게 들릴 수 있지만 실천하기는 쉽지 않을 수 있습니다. 그래서 변경 사항들을 메인 브랜치로 통합하기 전에 개인 브랜치를 유지하여 합병하기 전에 변경 사항을 커밋하는 것이 좋은 실천법입니다.\n\n## 개인 커밋용 전용 브랜치 만들기\n\n\n\n코드를 커밋한다고 해서 꼭 당신의 git 로그의 끝없는 영역에 영원히 남아 있어야 하는 것은 아닙니다. 개인 브랜치를 당신의 개인 프로그래머 스케치패드로 생각해보세요. 여기서는 다른 사람이 당신의 작업을 세심하게 조사할 필요 없이 자유롭게 실험할 수 있습니다.\n\n상황을 상상해보세요: 코딩 중이지만 잠시 쉬어야 하는 때가 오거나 저녁식사를 앞두고 있을 때. 현재 진행 중인 작업을 잃을까봐 두려워서 변경 사항을 커밋하기로 했습니다. 이런 경우에는 개인 브랜치가 완벽하게 활용될 수 있는 상황입니다. 당신의 코딩 세션을 마무리하거나 갑작스럽게 커밋을 하고 싶은 날에도 이러한 변경 사항은 개인 브랜치에 보관됩니다.\n\n```js\ncommit [커밋 해시]\nAuthor: Your Name <your.email@example.com>\nDate:   [타임스탬프]\n    작업 중\n\ncommit [커밋 해시]\nAuthor: Your Name <your.email@example.com>\nDate:   [타임스탬프]\n\n    파일을 최종적으로 잃기 전에 커밋합니다.\n\ncommit [커밋 해시]\nAuthor: Your Name <your.email@example.com>\nDate:   [타임스탬프]\n\n    저녁식사 준비 중\n\ncommit [커밋 해시]\nAuthor: Your Name <your.email@example.com>\nDate:   [타임스탬프]\n\n    화장실 가는 시간!\n```\n\n협업 환경에서는 개인 브랜치의 명칭을 명확하게 지어야 합니다. 이러한 종류의 커밋 메시지는 퍼블릭 브랜치에 나타나서는 안 되기 때문입니다.\n\n\n\n명시적인 브랜치 네이밍이나 동료들과 직접 의사 소통을 통해, 현재 브랜치의 내용이 지속적인 작업의 기반으로 사용되지 않음을 분명히 해주세요. 개인 브랜치에 적합한 좋은 네이밍은 `private/do-not-use-this` 같은 것입니다.\n\n당신의 퍼블릭 브랜치에 포함되는 모든 커밋은 잘 다듬어진, 독립적인, 되돌릴 수 있고 명확히 설명된 작업 단위여야 합니다.\n\n# 사례 연구: 온라인 스토어의 장바구니 기능 개발\n\n지금까지 진행해온 온라인 스토어 프로젝트를 살펴보겠습니다. 이 문맥에서, 여러분은 스토어에 장바구니 기능을 추가하는 것을 책임지는 프론트엔드 개발자로 활동하게 됩니다. 여러분의 여정은 다음과 같이 펼쳐집니다:\n\n\n\n이제 Git 로그를 살펴보겠습니다:\n\n```js\ncommit [commit-hash-1]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    장바구니 섹션의 CSS 디자인 향상\n\ncommit [commit-hash-2]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    장바구니에 Javascript 기능 추가\n\ncommit [commit-hash-3]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    텍스트 정렬 문제 해결을 위한 CSS 수정\n\ncommit [commit-hash-4]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    장바구니 동작과 관련된 카운터 버그 수정\n\ncommit [commit-hash-5]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    결제 버튼에 로딩 애니메이션 통합\n```\n\n이러한 변경 사항이 온라인 상점과 관련된 다른 커밋들과 함께 주요 기능 브랜치에 통합되어야 한다면, 리뷰 프로세스가 어려워질 수 있습니다.\n\n## 이런 커밋 로그들을 수정하는 방법은 다음과 같습니다\n\n\n\n우선 기능 브랜치로 전환해주세요:\n\n```js\n# feature/cart-section이라는 기능 브랜치로 전환\ngit checkout feature/cart-section\n```\n\n그런 다음 private/do-not-use-this 브랜치에서 모든 커밋을 하나의 커밋 메시지로 feature/cart-section에 통합해주세요:\n\n```js\n# private 브랜치의 모든 커밋을 하나의 커밋으로 feature 브랜치에 병합 및 통합\ngit merge --squash private/do-not-use-this\n```\n\n\n\n병합 및 squash 작업을 완료한 후에는 명확하고 설명적인 커밋 메시지를 작성해야 합니다:\n\n```js\n# 자세한 커밋 메시지를 작성하세요\ngit commit -v -m \"Feat: 멋진 애니메이션으로 장바구니 기능 만들기\n\n장바구니 섹션의 CSS 레이아웃을 개선하여 텍스트 정렬 문제를 해결하고 레이아웃을 재미있게 향상하여 가독성을 높였습니다.\"\n\"\n```\n\n# 완벽한 커밋 메시지 작성을 위한 7가지 표준 규칙\n\n이 규칙은 커밋 메시지가 올바르게 서식이 지정되고 명확한 정보를 전달하도록 보장하기 위한 지침과 모범 사례를 제공합니다. 특정 규칙은 다른 소스에 따라 다를 수 있지만, 일반적인 목표는 Git 버전 관리 시스템 내에서 커밋 메시지의 가독성과 이해를 높이는 것입니다.\n\n\n\n## 규칙 1: 제목은 50자로 제한하세요.\n\n커밋 메시지의 제목을 작성할 때는 간결하고 목적을 집중시키는 것이 좋습니다. 제목은 커밋의 목적을 간단히 요약한 것으로, 이상적으로 50자를 넘지 않도록 하는 것이 좋습니다.\n\n50자로 제한하는 것이 힘들다면, 커밋의 의도에 대한 명확성이 부족할 수 있습니다. 커밋 메시지는 명확하고 간결하며 독립적으로 설명할 수 있어야 합니다. 이 글자 수 제한을 준수함으로써, 가장 중요한 정보에 우선순위를 두어 팀원들과 미래의 본인이 변경 내용의 본질을 한눈에 파악하기 쉽게 할 수 있습니다.\n\n## 규칙 2: 제목의 첫 글자만 대문자로 쓰세요.\n\n\n\n커밋 메시지를 작성할 때 제목 라인의 첫 글자를 대문자로 쓰면 됩니다. 이는 간결한 문장을 쓰는 것과 마찬가지로 타이틀 케이스를 사용하는 것입니다. 추가로 메시지의 나머지 부분은 소문자로 작성해주세요.\n\n## Rule 3: 제목 라인 끝에 온점을 찍지 말아주세요\n\n제목 라인을 온점으로 끝내지 않는 이유는 부분적으로는 역사적이며 일부는 일관된 스타일을 유지하기 위함입니다. 제목 라인을 명령문이나 명령처럼 취급하여 작성하는 관례에 따라 마침표를 생략합니다. 이를 통해 이 관례를 강화하고 제목 라인을 간결하게 유지할 수 있습니다.\n\n```js\ngit commit -v -m \"Create the Cart Feature with a Nice Animation\"\n```\n\n\n\n## 규칙 4: 제목과 본문 사이에 빈 줄을 넣으세요\n\n이 가이드라인은 조금 이상하게 보일지 모르지만, 실용성에 근간을 두고 있습니다. 많은 개발자들이 Git을 위한 명령줄 인터페이스를 사용하는데, 이들은 자동 줄 바꿈을 지원하지 않는 경우가 많습니다. 그래서 의도적인 형식 규칙이 도입되었으며 일관적이고 가독성 있는 커밋 메시지를 보장합니다.\n\n```js\ngit commit -v -m \"친절한 애니메이션을 가진 카트 기능 만들기\n\n본문...\n\"\n```\n\n## 규칙 5: 커밋 본문의 줄을 72자로 래핑하세요\n\n\n\n줄 바꿈 규칙은 전통적인 단어 줄 바꿈을 의미하는 것이 아니라, 명령줄 사용자가 72자를 초과하는 커밋 본문을 겪을 수 있다는 고려에서 비롯된 것임을 명확히 하는 것이 중요합니다.\n\n대부분의 경우, 메시지는 72자를 초과할 것입니다. 이러한 경우에는 아래의 커밋 메시지에서 보여주는 바와 같이 텍스트를 줄 바꿈하고 다음 줄에서 문장을 계속하는 것이 좋습니다:\n\n```js\ngit commit -v -m \"Create the Cart Feature with a Nice Animation\n\nEnhanced the CSS layout of the cart section, addressing text\nalignment issues and refining the layout for improved aesthetics\nand readability.\"\n```\n\n요약하자면, 점 목록을 표시하는 표준 방법은 하이픈이나 별표 뒤에 공백 하나를 두고 사용하는 것입니다. 더불어 조직적 가독성을 높이기 위해 들여쓰기를 유지하는 것이 중요합니다.\n\n\n\n## 규칙 6: 명령형 문법 사용하기\n\n가치 있는 실천 방법 중 하나는 커밋 메시지를 작성할 때 해당 커밋이 구현되면 정확한 작업을 수행할 것이라는 기본적인 이해를 갖는 것입니다. 커밋 메시지를 작성할 때 ‘만일 적용된다면, 이 커밋은…’이라는 문장을 논리적으로 완성하는 방식으로 만드세요. 예를 들어, `git commit -m \"Fixed the bug on the layout page\"` ❌ 대신에 `git commit -m \"Fix the bug on the layout page\"` ✔ 를 사용하세요.\n\n다시 말해, 만일 이 커밋이 적용된다면, 실제로 레이아웃 페이지에서 버그가 해결될 것입니다.\n\n## 규칙 7: “무엇\"과 “왜\"를 설명하되, “어떻게\"에 대해서는 제외하세요.\n\n\n\n커밋 메시지를 “무엇\"과 “왜\"로 제한하면 각 변경 사항에 대해 간결하면서도 정보를 제공하는 설명이 생성됩니다. 코드가 어떻게 구현되었는지 알고 싶은 개발자는 직접 코드베이스를 참조할 수 있습니다. 대신, 변경된 내용과 변경의 이유, 영향을 받은 구성 요소나 영역을 강조해주세요.\n\n## 사례 연구: Angular의 커밋 메시지 관행\n\nAngular는 효과적인 커밋 메시지 관행의 저변적인 예로 자리 잡고 있습니다. Angular 팀은 커밋 메시지를 작성할 때 특정 접두사의 사용을 지지합니다. 이러한 접두사에는 “chore: ,\" “docs: ,\" “style: ,\" “feat: ,\" “fix: ,\" “refactor: ,\" 그리고 “test: .\"가 포함됩니다. 이러한 접두사를 통합함으로써 커밋 이력은 각 커밋의 성격을 이해하는 데 유용한 자원이 됩니다.\n\n# 팁\n\n\n\n커밋 메시지를 통해 명확하고 의미 있는 커뮤니케이션을 우선시하는 것을 기억해 주세요. 정성스럽게 작성된 커밋 메시지는 ‘무엇을,’ ‘왜’에 대한 설명을 담고 있어야 합니다. 하지만 ‘어떻게’까지는 너무 자세히 설명하지 않아도 됩니다. 커밋 기록은 미래의 여러분과 팀원들이 의지할 중요한 자원이 되므로, 정보를 제공하고 간결하며 일관된 내용으로 커밋 메시지를 작성하는 습관을 들어보세요.\n\nGit을 깊게 이해하고 숙련된 \"버전 컨트롤러\"로 성장하고 싶다면, 이 훌륭한 자료들을 살펴보세요:","ogImage":{"url":"/assets/img/2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage_0.png"},"coverImage":"/assets/img/2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage_0.png","tag":["Tech"],"readingTime":7},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"수 년 전, 궁금증 때문에 커밋 메시지 작성에 대한 구체적인 규칙이 있다는 것을 알지 못했어요. 예전엔 \\\"기능 2 추가\\\", \\\"메인 네비게이션 바 버그 수정\\\", 혹은 \\\"foo\\\"와 같이 간단한 메시지가 충분하다고 생각했어요. 하지만 커밋 메시지가 대부분 무시당한다고 생각했던 것은 잘못된 생각이었어요. 실제로, 신중하고 세심하게 작성된 커밋 메시지는 우리 미래의 자신이 우리의 성실함과 세심함에서 이익을 얻게끔 해주는 필수적인 역할을 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"목차: 왜 깨끗한 커밋 메시지 작성에 신경을 써야 할까? | 흔한 실수들 | 7가지 규칙 | 사례 연구 | 팁.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"왜 깨끗한 커밋 메시지 작성이 중요할까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커밋은 프로그래머의 기술의 구체적인 구성 요소로 작용합니다. 코드의 완성을 나타내며, 올바르게 작성되면 상당한 가치를 제공합니다. 잘 쓰여진 커밋 메시지는 필수불가결합니다. 왜냐하면 컨텍스트를 제공하기 때문입니다. 그렇지 않으면 커밋 메시지는 처음부터 필요하지 않을 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개발자들 사이의 일반적인 실수 중 하나는 Git 저장소를 백업 시스템으로 취급하는 것입니다. 현재 코드 상태를 캡처하기 위해 무작위로 커밋하는 것은 미래에 코드베이스를 확인할 때 과거 변경 사항을 이해하는 능력을 방해할 수 있습니다. \\\"WIP\\\", \\\"Off for lunch\\\", \\\"End of code for today\\\", \\\"I am tired AF\\\", \\\"Happy Weekend Team\\\", \\\"First to commit\\\"과 같은 커밋 메시지는 추가적인 가치가 전혀 없기 때문에 Git 로그를 혼란스럽게 만들며, 본질적인 커밋 내용을 파악하기 어렵게 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"원격 저장소에 커밋할 때 피해야 할 몇 가지 주요 실수가 여기 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"서로 다른 파일에 대한 변경 사항을 분리하여 커밋하지 마세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다른 팀원들과 협업하거나 커밋 기록을 검토할 때 각 파일을 따로 커밋하는 것은 문제를 야기할 수 있습니다. 변경 사항의 전체 맥락을 이해하고 서로 간의 관계를 파악하는 데 어려움을 겪을 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, 온라인 상점을 만들고 있다고 가정해봅시다. 아래와 같이 하면 안 되죠:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# header.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"js\"\n        }), \"에 대한 변경 사항을 따로 커밋\\ngit add header.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"js\"\n        }), \"\\ngit commit -m \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"헤더 레이아웃 개선\\\"\"\n        }), \"\\n\\n# footer.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"js\"\n        }), \"에 대한 변경 사항을 따로 커밋\\ngit add footer.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"js\"\n        }), \"\\ngit commit -m \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"푸터 디자인 최적화\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커밋 구조가 이러한 형태인 경우, 커밋 기록이 증가함에 따라 일관되지 못할 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커밋은 명확하고 간결하며 논리적인 단위로 구성되어야 합니다. 예를 들어, 코드 레이아웃 섹션을 완료한 후 헤더와 푸터 섹션을 작업한 경우, 이러한 변경 사항을 커밋하기 전에 변경 사항들을 결합하는 것이 깔끔합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# header.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"js\"\n        }), \" 및 footer.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"js\"\n        }), \"의 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Staging\"\n        }), \" 변경 사항\\ngit add header.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"js\"\n        }), \" footer.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"js\"\n        }), \"\\n\\n# 관련 변경 사항 함께 커밋\\ngit commit -m \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"UI 개선: 헤더 및 푸터 개선\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이론적으로는 쉽게 들릴 수 있지만 실천하기는 쉽지 않을 수 있습니다. 그래서 변경 사항들을 메인 브랜치로 통합하기 전에 개인 브랜치를 유지하여 합병하기 전에 변경 사항을 커밋하는 것이 좋은 실천법입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"개인 커밋용 전용 브랜치 만들기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드를 커밋한다고 해서 꼭 당신의 git 로그의 끝없는 영역에 영원히 남아 있어야 하는 것은 아닙니다. 개인 브랜치를 당신의 개인 프로그래머 스케치패드로 생각해보세요. 여기서는 다른 사람이 당신의 작업을 세심하게 조사할 필요 없이 자유롭게 실험할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상황을 상상해보세요: 코딩 중이지만 잠시 쉬어야 하는 때가 오거나 저녁식사를 앞두고 있을 때. 현재 진행 중인 작업을 잃을까봐 두려워서 변경 사항을 커밋하기로 했습니다. 이런 경우에는 개인 브랜치가 완벽하게 활용될 수 있는 상황입니다. 당신의 코딩 세션을 마무리하거나 갑작스럽게 커밋을 하고 싶은 날에도 이러한 변경 사항은 개인 브랜치에 보관됩니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"commit [커밋 해시]\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Author\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Your\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \" <your.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"email\"\n        }), \"@example.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \">\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \":   [타임스탬프]\\n    작업 중\\n\\ncommit [커밋 해시]\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Author\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Your\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \" <your.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"email\"\n        }), \"@example.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \">\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \":   [타임스탬프]\\n\\n    파일을 최종적으로 잃기 전에 커밋합니다.\\n\\ncommit [커밋 해시]\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Author\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Your\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \" <your.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"email\"\n        }), \"@example.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \">\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \":   [타임스탬프]\\n\\n    저녁식사 준비 중\\n\\ncommit [커밋 해시]\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Author\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Your\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \" <your.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"email\"\n        }), \"@example.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \">\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \":   [타임스탬프]\\n\\n    화장실 가는 시간!\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"협업 환경에서는 개인 브랜치의 명칭을 명확하게 지어야 합니다. 이러한 종류의 커밋 메시지는 퍼블릭 브랜치에 나타나서는 안 되기 때문입니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"명시적인 브랜치 네이밍이나 동료들과 직접 의사 소통을 통해, 현재 브랜치의 내용이 지속적인 작업의 기반으로 사용되지 않음을 분명히 해주세요. 개인 브랜치에 적합한 좋은 네이밍은 \", _jsx(_components.code, {\n        children: \"private/do-not-use-this\"\n      }), \" 같은 것입니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"당신의 퍼블릭 브랜치에 포함되는 모든 커밋은 잘 다듬어진, 독립적인, 되돌릴 수 있고 명확히 설명된 작업 단위여야 합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"사례 연구: 온라인 스토어의 장바구니 기능 개발\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지 진행해온 온라인 스토어 프로젝트를 살펴보겠습니다. 이 문맥에서, 여러분은 스토어에 장바구니 기능을 추가하는 것을 책임지는 프론트엔드 개발자로 활동하게 됩니다. 여러분의 여정은 다음과 같이 펼쳐집니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 Git 로그를 살펴보겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"commit [commit-hash-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Author\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Your\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \" <your.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"email\"\n        }), \"@example.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \">\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Timestamp\"\n        }), \"]\\n\\n    장바구니 섹션의 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"CSS\"\n        }), \" 디자인 향상\\n\\ncommit [commit-hash-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"]\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Author\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Your\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \" <your.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"email\"\n        }), \"@example.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \">\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Timestamp\"\n        }), \"]\\n\\n    장바구니에 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Javascript\"\n        }), \" 기능 추가\\n\\ncommit [commit-hash-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"]\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Author\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Your\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \" <your.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"email\"\n        }), \"@example.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \">\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Timestamp\"\n        }), \"]\\n\\n    텍스트 정렬 문제 해결을 위한 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"CSS\"\n        }), \" 수정\\n\\ncommit [commit-hash-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"]\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Author\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Your\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \" <your.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"email\"\n        }), \"@example.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \">\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Timestamp\"\n        }), \"]\\n\\n    장바구니 동작과 관련된 카운터 버그 수정\\n\\ncommit [commit-hash-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"]\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Author\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Your\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \" <your.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"email\"\n        }), \"@example.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \">\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Timestamp\"\n        }), \"]\\n\\n    결제 버튼에 로딩 애니메이션 통합\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 변경 사항이 온라인 상점과 관련된 다른 커밋들과 함께 주요 기능 브랜치에 통합되어야 한다면, 리뷰 프로세스가 어려워질 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"이런 커밋 로그들을 수정하는 방법은 다음과 같습니다\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우선 기능 브랜치로 전환해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"# feature/cart-section이라는 기능 브랜치로 전환\\ngit checkout feature/cart-section\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 private/do-not-use-this 브랜치에서 모든 커밋을 하나의 커밋 메시지로 feature/cart-section에 통합해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# private 브랜치의 모든 커밋을 하나의 커밋으로 feature 브랜치에 병합 및 통합\\ngit merge --squash private/\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \"-not-use-\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"병합 및 squash 작업을 완료한 후에는 명확하고 설명적인 커밋 메시지를 작성해야 합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 자세한 커밋 메시지를 작성하세요\\ngit commit -v -m \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Feat: 멋진 애니메이션으로 장바구니 기능 만들기\\n\\n장바구니 섹션의 CSS 레이아웃을 개선하여 텍스트 정렬 문제를 해결하고 레이아웃을 재미있게 향상하여 가독성을 높였습니다.\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"완벽한 커밋 메시지 작성을 위한 7가지 표준 규칙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 규칙은 커밋 메시지가 올바르게 서식이 지정되고 명확한 정보를 전달하도록 보장하기 위한 지침과 모범 사례를 제공합니다. 특정 규칙은 다른 소스에 따라 다를 수 있지만, 일반적인 목표는 Git 버전 관리 시스템 내에서 커밋 메시지의 가독성과 이해를 높이는 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"규칙 1: 제목은 50자로 제한하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커밋 메시지의 제목을 작성할 때는 간결하고 목적을 집중시키는 것이 좋습니다. 제목은 커밋의 목적을 간단히 요약한 것으로, 이상적으로 50자를 넘지 않도록 하는 것이 좋습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"50자로 제한하는 것이 힘들다면, 커밋의 의도에 대한 명확성이 부족할 수 있습니다. 커밋 메시지는 명확하고 간결하며 독립적으로 설명할 수 있어야 합니다. 이 글자 수 제한을 준수함으로써, 가장 중요한 정보에 우선순위를 두어 팀원들과 미래의 본인이 변경 내용의 본질을 한눈에 파악하기 쉽게 할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"규칙 2: 제목의 첫 글자만 대문자로 쓰세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커밋 메시지를 작성할 때 제목 라인의 첫 글자를 대문자로 쓰면 됩니다. 이는 간결한 문장을 쓰는 것과 마찬가지로 타이틀 케이스를 사용하는 것입니다. 추가로 메시지의 나머지 부분은 소문자로 작성해주세요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Rule 3: 제목 라인 끝에 온점을 찍지 말아주세요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제목 라인을 온점으로 끝내지 않는 이유는 부분적으로는 역사적이며 일부는 일관된 스타일을 유지하기 위함입니다. 제목 라인을 명령문이나 명령처럼 취급하여 작성하는 관례에 따라 마침표를 생략합니다. 이를 통해 이 관례를 강화하고 제목 라인을 간결하게 유지할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"git commit -v -m \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Create the Cart Feature with a Nice Animation\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"규칙 4: 제목과 본문 사이에 빈 줄을 넣으세요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 가이드라인은 조금 이상하게 보일지 모르지만, 실용성에 근간을 두고 있습니다. 많은 개발자들이 Git을 위한 명령줄 인터페이스를 사용하는데, 이들은 자동 줄 바꿈을 지원하지 않는 경우가 많습니다. 그래서 의도적인 형식 규칙이 도입되었으며 일관적이고 가독성 있는 커밋 메시지를 보장합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"git commit -v -m \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"친절한 애니메이션을 가진 카트 기능 만들기\\n\\n본문...\\n\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"규칙 5: 커밋 본문의 줄을 72자로 래핑하세요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"줄 바꿈 규칙은 전통적인 단어 줄 바꿈을 의미하는 것이 아니라, 명령줄 사용자가 72자를 초과하는 커밋 본문을 겪을 수 있다는 고려에서 비롯된 것임을 명확히 하는 것이 중요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"대부분의 경우, 메시지는 72자를 초과할 것입니다. 이러한 경우에는 아래의 커밋 메시지에서 보여주는 바와 같이 텍스트를 줄 바꿈하고 다음 줄에서 문장을 계속하는 것이 좋습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"git commit -v -m \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Create the Cart Feature with a Nice Animation\\n\\nEnhanced the CSS layout of the cart section, addressing text\\nalignment issues and refining the layout for improved aesthetics\\nand readability.\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"요약하자면, 점 목록을 표시하는 표준 방법은 하이픈이나 별표 뒤에 공백 하나를 두고 사용하는 것입니다. 더불어 조직적 가독성을 높이기 위해 들여쓰기를 유지하는 것이 중요합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"규칙 6: 명령형 문법 사용하기\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"가치 있는 실천 방법 중 하나는 커밋 메시지를 작성할 때 해당 커밋이 구현되면 정확한 작업을 수행할 것이라는 기본적인 이해를 갖는 것입니다. 커밋 메시지를 작성할 때 ‘만일 적용된다면, 이 커밋은…’이라는 문장을 논리적으로 완성하는 방식으로 만드세요. 예를 들어, \", _jsx(_components.code, {\n        children: \"git commit -m \\\"Fixed the bug on the layout page\\\"\"\n      }), \" ❌ 대신에 \", _jsx(_components.code, {\n        children: \"git commit -m \\\"Fix the bug on the layout page\\\"\"\n      }), \" ✔ 를 사용하세요.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다시 말해, 만일 이 커밋이 적용된다면, 실제로 레이아웃 페이지에서 버그가 해결될 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"규칙 7: “무엇\\\"과 “왜\\\"를 설명하되, “어떻게\\\"에 대해서는 제외하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커밋 메시지를 “무엇\\\"과 “왜\\\"로 제한하면 각 변경 사항에 대해 간결하면서도 정보를 제공하는 설명이 생성됩니다. 코드가 어떻게 구현되었는지 알고 싶은 개발자는 직접 코드베이스를 참조할 수 있습니다. 대신, 변경된 내용과 변경의 이유, 영향을 받은 구성 요소나 영역을 강조해주세요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"사례 연구: Angular의 커밋 메시지 관행\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Angular는 효과적인 커밋 메시지 관행의 저변적인 예로 자리 잡고 있습니다. Angular 팀은 커밋 메시지를 작성할 때 특정 접두사의 사용을 지지합니다. 이러한 접두사에는 “chore: ,\\\" “docs: ,\\\" “style: ,\\\" “feat: ,\\\" “fix: ,\\\" “refactor: ,\\\" 그리고 “test: .\\\"가 포함됩니다. 이러한 접두사를 통합함으로써 커밋 이력은 각 커밋의 성격을 이해하는 데 유용한 자원이 됩니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"팁\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커밋 메시지를 통해 명확하고 의미 있는 커뮤니케이션을 우선시하는 것을 기억해 주세요. 정성스럽게 작성된 커밋 메시지는 ‘무엇을,’ ‘왜’에 대한 설명을 담고 있어야 합니다. 하지만 ‘어떻게’까지는 너무 자세히 설명하지 않아도 됩니다. 커밋 기록은 미래의 여러분과 팀원들이 의지할 중요한 자원이 되므로, 정보를 제공하고 간결하며 일관된 내용으로 커밋 메시지를 작성하는 습관을 들어보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Git을 깊게 이해하고 숙련된 \\\"버전 컨트롤러\\\"로 성장하고 싶다면, 이 훌륭한 자료들을 살펴보세요:\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}