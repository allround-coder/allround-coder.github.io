{"pageProps":{"post":{"title":"파이썬으로 GenAI 개발하기 최신 LLM과 RAG 완벽 튜토리얼","description":"","date":"2024-06-30 18:30","slug":"2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial","content":"\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png\" />\n\n이 기사에서는 개인 문서에서 지식을 효과적으로 학습하고 질문에 대답할 수 있는 간단한 AI를 구축하는 방법을 보여드리겠습니다.\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_1.png\" />\n\n## 소개\n\n<div class=\"content-ad\"></div>\n\n자연어 처리(NLP)는 기계와 인간 언어 간의 상호작용을 연구하는 인공 지능 분야입니다. 지금까지 NLP의 정점은 거대한 양의 텍스트 데이터로 훈련된 대형 언어 모델(LLM)의 등장이었습니다. LLM은 언어 패턴과 변형을 학습할 수 있는 능력을 갖추고 있습니다. \"언어 모델\"이라는 용어는 딥 러닝과 신경망의 발전과 함께 흔해졌습니다. 특히 2018년 구글이 Transformer 기반 아키텍처를 소개한 후에는 NLP 모델의 성능이 크게 향상되었습니다.(구글의 BERT 및 OpenAI의 GPT).\n\n오늘날 LLM은 일반적으로 텍스트 간 작업 또는 \"텍스트 생성\"(즉, 번역, 요약, 챗봇 및 가상 비서, 심지어 전체 책 작성)에 사용됩니다. 이를 통해 우리는 새로운 콘텐츠(텍스트, 이미지, 오디오, 비디오 등) 작성에 초점을 맞춘 산업 분야인 생성적 인공지능(GenAI)의 부상을 목격하고 있습니다.\n\n최신 LLM 풍경:\n\n- OpenAI의 ChatGPT, 가장 많이 사용됨 (여기서 시도해보기)\n- Anthropic의 Claude(여기서 시도해보기)\n- Google의 Gemini(여기서 시도해보기)\n- Meta의 Llama(여기서 시도해보기)\n- Microsoft의 Phi, 사용 가능한 모델 중 가장 작은 모델로 GPU 없이도 노트북에서 실행 가능(여기서 시도해보기)\n- StabilityAI의 StableLM\n- Cohere의 CommandR(여기서 시도해보기)\n- Snowflake의 Arctic(여기서 시도해보기)\n- Alibaba의 Qwen(여기서 시도해보기)\n- 01AI의 Yi\n- X의 Grok\n- NVIDIA의 Megatron\n- 아마존의 Olympus(아직 출시 예정)\n- Apple의 MM1(아직 출시 예정)\n\n<div class=\"content-ad\"></div>\n\nChatGPT은 가장 일반적으로 사용되는 LLM입니다. 그러나 회사들은 그것으로 업로드하기 어려운 문제가 있습니다. (대부분은 개인 정보 및 보안 상의 이유로) OpenAI에 민감한 데이터를 업로드할 수 없습니다. 따라서 회사들은 비공개 지식베이스에서 LLM의 파워를 활용하기 위해 내부 AI 서비스를 개발하고 있습니다. 이러한 종류의 작업을 검색 증강 생성(RAG)이라고 합니다. 이 기술은 외부 소스에서 가져온 지식 사실을 LLM에 추가하여 검색 및 생성 모델을 결합하는 방법입니다.\n\n조직 내에서, 지식 베이스는 일반적으로 다중 모달 콘텐츠(예: 텍스트, 이미지, 스프레드시트)를 포함한 문서로 구성되어 있으므로, 기계가 이해할 수 있도록 모든 것들을 처리하는 것이 가장 큰 도전입니다. 간단히 말해서, 먼저 모든 문서를 임베딩으로 변환한 다음 사용자 쿼리를 동일한 벡터 공간으로 변환하여 코사인 유사도 검색을 수행합니다.\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_2.png)\n\n이 자습서에서는 GPU 없이 일반 노트북에서 실행 가능한 LLMs 및 다중 모달 데이터를 사용하여 RAG 앱을 만들 것입니다. 다른 유사한 경우에 쉽게 적용할 수 있는 유용한 Python 코드 몇 가지를 제시하고 있으며 (그저 복사하여 붙여넣기하고 실행하면 됩니다), 각 코드 라인에 대한 설명을 포함하여 이 예제를 복제할 수 있도록 안내할 것입니다 (전체 코드에 대한 링크는 아래에 있습니다).\n\n<div class=\"content-ad\"></div>\n\n특히 다음을 살펴볼 것입니다:\n\n- 설정: Pdf2image로 데이터 가져오기, PyTesseract로 OCR 처리하기.\n- 전처리: Ollama를 사용하여 LLM으로 데이터를 보강하기.\n- 데이터베이스: ChromaDB로 데이터를 벡터로 저장하고 쿼리하기.\n- 백엔드: Ollama를 사용하여답변 생성하기.\n- 프론트엔드: Streamlit으로 사용자가 AI와 상호작용할 수 있는 인터페이스 구축하기.\n\n## 설정\n\n현실 세계에서 회사들은 대부분의 문서를 공유하기 전에 해당 형식으로 변환하는 PDF를 광범위하게 사용합니다. 또한 이미지, 테이블, 텍스트가 포함된 문서들이 많이 있어 좋은 사용 사례를 나타냅니다. 따라서 이 예제에서는 PDF 형식의 공개 회사의 재무 보고서를 데이터셋으로 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_3.png)\n\nPDF 문서를 처리하는 두 가지 대안적 방법이 있습니다: 텍스트로 읽거나 이미지로 구문 분석합니다. 둘 다 사용 사례에 따라 다르기 때문에 완벽하지는 않지만, OCR (광학 문자 인식) 기능이 더 잘 작동하는 경향이 있으므로 이를 사용하겠습니다.\n\n이 기사의 초점이 OCR에 있지는 않으며, 작동 방식에 대해 자세히 설명하는 데 너무 많은 시간을 할애하지는 않을 것입니다. 만약 해당 주제를 깊이 파고들고 싶다면, 이 기사를 확인하고 LayoutParser와 Unstructured 같은 고급 OCR 라이브러리를 사용해 보세요.\n\n우선 문서를 이미지로 변환해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n# conda install -c conda-forge poppler\nimport pdf2image #1.17.0\n\ndoc_img = pdf2image.convert_from_path(\"data/doc_nvidia.pdf\", dpi=300)\n\n# 예시로 한 페이지 출력\ndoc_img[35]\r\n\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_4.png\" />\n\n그런 다음, 페이지(이미지)에서 텍스트를 인식하겠습니다. 이를 위해 HP에서 1985년에 만들어진 주요 OCR 시스템 Tesseract를 사용하고 있으며 현재 Google에서 개발 중에 있습니다.\n\n\nimport pytesseract #0.3.10\n\ndoc_txt = []\nfor page in doc_img:\n    text = pytesseract.image_to_string(page)\n    doc_txt.append(text)\n\ndoc_txt[35]\r\n\n\n<div class=\"content-ad\"></div>\n\n![2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png)\n\n이제 우리는 생 텍스트를 가지고 있으니, 무엇보다 처리를 해야 할 것입니다. 우리는 언어 모델을 사용할 것입니다. 현재 여러 가지 대체 라이브러리들이 있어서 LLM의 힘을 활용할 수 있습니다: Ollama, HuggingFace, DSPy, LangChain. 제가 사용하는 Ollama는 강력하면서 사용하기 쉽습니다.\n\n먼저, 웹사이트에서 프로그램을 다운로드해야 합니다. 그런 다음, 명령 프롬프트에서 아래 명령을 입력하여 노트북에서 LLM을 실행합니다 (저는 Phi3와 LLaVa를 사용하고 있습니다):\n\n![2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png)\n\n<div class=\"content-ad\"></div>\n\n마지막으로, Python 라이브러리를 설치하면 끝입니다 (pip install ollama).\n\n## 전처리\n\n어떤 데이터 과학 프로젝트든 마찬가지로, 언제나 가장 어려운 부분은 데이터셋입니다. 머신러닝을 얼마나 많이 사용하더라도 데이터가 좋지 않다면 AI가 제대로 작동하지 않을 것입니다.\n\nLLM(대형 언어 모델)의 경우, 임베딩이 포함되어 있기 때문에 표준 플랙티스는 모든 것을 텍스트로 변환하는 것입니다. 가장 일반적인 다중모달 콘텐츠 (텍스트, 테이블, 이미지, 플롯)의 처리 방법을 보여드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n텍스트 — 문서는 서로 다른 구조와 레이아웃을 가질 수 있기 때문에 데이터 세트를 단락으로 분할해야 합니다. 원시 텍스트 외에도 제목, 태그, 링크와 같은 추가 정보를 활용하여 데이터를 보강할 수 있습니다. 이를 메타데이터 보강이라고 합니다.\n\n```js\n# 목차를 사용하여 단락에 태그 지정하기\ntitle_map = {\n    \"4-12\":\"비즈니스\",\n    \"13-33\":\"위험 요인\",\n    \"34-44\":\"재무\",\n    \"45-46\":\"이사\",\n    \"47-83\":\"데이터\"\n}\n\nlst_docs, lst_ids, lst_metadata = [], [], []\nfor n,page in enumerate(doc_txt):\n    try:\n        ## 제목 가져오기\n        title = [v for k,v in title_map.items() \n                 if n in range(int(k.split(\"-\")[0]), \n                               int(k.split(\"-\")[1])+1)][0]\n        ## 페이지 정리\n        page = page.replace(\"Table of Contents\",\"\")\n        ## 단락 가져오기\n        for i,p in enumerate(page.split('\\n\\n')):\n            if len(p.strip())>5:  ##<--단락 정리\n                lst_docs.append(p.strip())\n                lst_ids.append(str(n)+\"_\"+str(i))\n                lst_metadata.append({\"title\":title})\n    except:\n        continue\n\n\n## 예시 출력\nfor id,doc,meta in zip(lst_ids[375:378], \n                       lst_docs[375:378], \n                       lst_metadata[375:378]):\n    print(id, \"-\", meta, \"\\n\", doc, \"\\n\")\r\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_7.png\" />\n\n언어 모델을 사용한 메타데이터 보강은 문서 검색을 크게 향상시킬 수 있습니다. 예를 들어, 각 단락을 몇 가지 키워드로 요약하는 데 Phi3를 사용할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport ollama #0.2.1\n\ndef keyword_generator(p, top=3):\n    prompt = \"다음 단락을 3개의 키워드로 요약해주세요, 각각 ,로 구분: \"+p\n    res = ollama.generate(model=\"phi3\", prompt=prompt)[\"response\"]\n    return res.replace(\"\\n\",\" \").strip()\n\n\n## test\np = '''Professional artists, architects and designers use NVIDIA partner products accelerated with our GPUs and software platform for a range of creative and design\nuse cases, such as creating visual effects in movies or designing buildings and products. In addition, generative Al is expanding the market for our workstation-\nclass GPUs, as more enterprise customers develop and deploy Al applications with their data on-premises.'''\nprint(keyword_generator(p))\n```\n\n결과: “창의적 디자인, NVIDIA 파트너십, AI 확장”. 위와 같이 모든 단락에 적용하겠습니다:\n\n```js\nfrom tqdm.notebook import tqdm\n\nfor i,doc in tqdm(enumerate(lst_docs)):\n    lst_metadata[i][\"keywords\"] = keyword_generator(doc)\n\n## 예시 출력\nfor id,doc,meta in zip(lst_ids[375:378], \n                       lst_docs[375:378], \n                       lst_metadata[375:378]):\n    print(id, \"-\", meta, \"\\n\", doc, \"\\n\")\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_8.png\" />\n\n<div class=\"content-ad\"></div>\n\nTABLES - LLM(Large Language Model)는 순차 텍스트를 현저한 정확도로 처리할 수 있는 것으로 잘 알려져 있습니다. 그러나 이제 구조화된 데이터도 이해하기 시작했기 때문에 테이블은 일반 텍스트로 전달될 수 있습니다. 이를 다시 한번 확인해보겠습니다:\n\n```js\ntable = lst_docs[376]\nprint(\"테이블:\\n\", table)\n\nprompt = f\"다음 테이블을 요약해주세요: {table}\"\nres = ollama.generate(model=\"phi3\", prompt=prompt)[\"response\"]\n\nprint(\"\\n요약:\\n\", res)\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_9.png)\n\n이미지 - 이미지의 임베딩은 상당히 까다로울 수 있습니다(3D 배열의 차원을 벡터로 축소해야 함). 따라서 일반적인 실천 방법은 이미지를 설명하는 캡션을 생성하기 위해 AI를 사용하고 가능한 경우 정보를 텍스트로 처리하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom matplotlib import image, pyplot\n\nimage_file = \"data/image.jpeg\"\n\npyplot.imshow(image.imread(image_file))\npyplot.show()\n```\n\n![image](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_10.png)\n\nLLM을 위해 이미지를 문자열로 변환해야 합니다:\n\n```python\n## 이미지를 base64 문자열로 인코딩\nimport base64\n\ndef encode_image(path):\n    with open(path, \"rb\") as file:\n        return base64.b64encode(file.read()).decode('utf-8')\n\nimg = encode_image(image_file)\nimg[:1000]\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 테이블 태그를 Markdown 형식으로 변경한 예시입니다.\n\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_11.png\" />\n\n모델에 이미지 설명을 요청하는 문자열을 전달할 수 있습니다. 안타깝게도 Phi3은 시각 모델이 아니기 때문에 이 작업에 적합하지 않습니다:\n\n```js\nprompt = \"이미지를 설명해주세요\"\nres = ollama.generate(model=\"phi3\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_12.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n따라서 적절한 시각 모델을 구해야 합니다. Microsoft의 LLaVa는 GPU 없이도 실행할 수 있어 효율적인 선택입니다 (여기에서 시도해 보세요).\n\n```js\n## LLaVA\nprompt = \"이미지를 설명해주세요\"\nres = ollama.generate(model=\"llava\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_13.png\" />\n\nPLOTS — 이미지와 마찬가지로, 시각 모델은 플롯/차트를 읽고 요약할 수 있지만 결과가 정확하지는 않습니다. 예를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n이미지_파일 = \"data/plot.png\"\n\npyplot.imshow(image.imread(image_file))\npyplot.show()\n\nimg = encode_image(image_file)\n\nprompt = \"그래프와 같은 그림에 대해 구체적으로 설명해주세요.\"\nres = ollama.generate(model=\"llava\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_14.png\" />\n\n## 데이터베이스\n\n우리는 데이터를 벡터 데이터베이스에 저장할 수 있습니다. 이는 비구조적 데이터를 효율적으로 저장하고 색인화하고 검색하는 가장 좋은 해결책입니다. 요즘 가장 많이 사용되는 벡터 데이터베이스는 Microsoft의 AISearch입니다. 최고의 오픈 소스 도구는 유용하고 쉽고 무료인 ChromaDB입니다.\n\n<div class=\"content-ad\"></div>\n\n빠르게 \"pip install chromadb\"를 입력하면 Python을 사용하여 세 가지 다른 방법으로 db와 상호 작용할 수 있습니다:\n\n- chromadb.Client()는 디스크 공간을 차지하지 않고 메모리에 일시적으로 유지되는 db를 만듭니다.\n- chromadb.PersistentClient(path)는 로컬 기계에서 db를 저장하고 로드합니다.\n- chromadb.HttpClient(host='localhost', port=8000)는 브라우저에서 클라이언트-서버 모드를 사용할 수 있습니다.\n\nChromaDB에 문서를 저장할 때 데이터는 벡터로 저장되어 일치하는 레코드를 검색할 때 쿼리 벡터를 사용할 수 있습니다. 참고로, 그렇게 명시하지 않으면 기본 임베딩 방법은 문장 변환 모델 (all-MiniLM-L6-v2)입니다.\n\n```js\nimport chromadb #0.5.0\n\ndb = chromadb.PersistentClient()\n\ncollection_name = \"nvidia\"\ncollection = db.get_or_create_collection(name=collection_name, \n               embedding_function=chromadb.utils.embedding_functions.DefaultEmbeddingFunction())\n\ncollection.add(documents=lst_docs, ids=lst_ids, metadatas=lst_metadata, \n               images=None, embeddings=None)\ncollection.peek(1)\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_15.png\" />\n\n어떤 것을 쿼리해보세요:\n\n```js\nquery = \"수익은 얼마인가요?\"\ncollection.query(query_texts=[query])\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_16.png\" />\n\n<div class=\"content-ad\"></div>\n\n쿼리가 동일한 벡터 공간에 포함되어 있고 ChromaDB가 가장 가까운 문서를 검색했습니다. 그들을 결합해서 db에서 최종 응답을 얻을 수 있습니다:\n\n```js\nres_db = collection.query(query_texts=[query])[\"documents\"][0][0:10]\ncontext = ' '.join(res_db).replace(\"\\n\", \" \")\ncontext\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_17.png)\n\ndb 응답은 컨텍스트로 사용될 수 있으며, 이는 LLM이 저장하고 액세스할 수 있는 소량의 정보 세트입니다. 프롬프트를 사용하여 모델이 컨텍스트 내 정보만 사용할지 훈련 중에 학습한 지식도 사용해야 하는지 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# Context만으로 대화하기\nres = ollama.chat(model=\"phi3\", \n                  messages=[{\"role\":\"system\", \"content\":\"다음 정보만을 사용하여 가장 정확한 답변을 제공하세요: \\n\"+context},\n                            {\"role\":\"user\", \"content\":query}])\nprint(res[\"message\"][\"content\"])\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_18.png)\n\n또는 모델의 지식을 추가하여:\n\n```js\n# 지식 및 Context로 대화하기\nres = ollama.chat(model=\"phi3\", \n                  messages=[{\"role\":\"system\", \"content\":\"귀하의 지식과 다음 추가 정보를 사용하여 가장 정확한 답변을 제공하세요: \\n\"+context},\n                            {\"role\":\"user\", \"content\":query}])\nprint(res[\"message\"][\"content\"])\n``` \n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_19.png)\n\n데이터베이스가 설정되어 정상적으로 작동 중입니다. 다음 단계로 진행하여 문서에 관한 질문을 할 수 있는 챗봇 앱을 만들 수 있습니다.\n\n## 프론트엔드\n\n요즘 가장 많이 사용되는 Python 라이브러리인 Streamlit은 NLP 애플리케이션 개발을 간편하게 만들어주는 스트리밍 기능으로 알려져 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 먼저 레이아웃을 정의해 봅시다: 화면에는 사용자가 채팅 기록을 볼 수 있는 사이드바가 있기를 원합니다.\n\n```python\nimport streamlit as st #1.35.0\n\n## 레이아웃\nst.title('💬 궁금한 점을 적어주세요')\nst.sidebar.title(\"채팅 기록\")\napp = st.session_state\n\nif \"messages\" not in app:\n    app[\"messages\"] = [{\"role\":\"assistant\", \"content\":\"정보를 검색할 준비가 되어 있습니다.\"}]\n\nif 'history' not in app:\n    app['history'] = []\n\nif 'full_response' not in app:\n    app['full_response'] = '' \n```\n\n앱 객체(또는 session_state)는 다음과 같은 구조를 갖는 딕셔너리입니다:\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_20.png)\n\n<div class=\"content-ad\"></div>\n\n만약 채팅에서 메시지가 사라지는 것을 원하지 않는다면, 다음 코드를 추가하세요:\n\n```js\n## 채팅 메시지 유지\nfor msg in app[\"messages\"]:\n    if msg[\"role\"] == \"user\":\n        st.chat_message(msg[\"role\"], avatar=\"😎\").write(msg[\"content\"])\n    elif msg[\"role\"] == \"assistant\":\n        st.chat_message(msg[\"role\"], avatar=\"👾\").write(msg[\"content\"])\n```\n\n이제 채팅 코어를 코드화해야 합니다: 사용자의 질문은 메시지 목록에 추가되어 AI로 전달되고, 앱은 응답을 스트리밍할 것입니다.\n\n```js\n## 채팅\nif txt := st.chat_input():\n    ### 사용자 입력\n    app[\"messages\"].append({\"role\":\"user\", \"content\":txt})\n    st.chat_message(\"user\", avatar=\"😎\").write(txt)\n\n    ### AI가 채팅 스트림으로 응답\n    app[\"full_response\"] = \"\"\n    st.chat_message(\"assistant\", avatar=\"👾\").write_stream( xxx ) )\n    app[\"messages\"].append({\"role\":\"assistant\", \"content\":app[\"full_response\"]})\n    \n    ### 사이드바 히스토리 보여주기\n    app['history'].append(\"😎: \"+txt)\n    app['history'].append(\"👾: \"+app[\"full_response\"])\n    st.sidebar.markdown(\"<br />\".join(app['history'])+\"<br /><br />\", unsafe_allow_html=True)\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 사용자 질문에 응답하는 기능을 완성한 후 \"xxx\"로 대체할 자리 표시자를 삽입했습니다. 앱을 실행하면 다음과 같이 보입니다:\n\n![앱 실행 화면](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_21.png)\n\n## 백엔드\n\n우리는 이미 이 부분에 익숙합니다. 이것을 클래스 내에 넣기만 하면 됩니다. 강조할 몇 가지 포인트가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- ChromaDB에서 컬렉션 이름을 호출하면, 이미 존재하는 경우 db는 새로 만들지 않고 \"가져오게\" 됩니다.\n- Ollama 채팅 기능의 스트리밍 매개변수는 (stream=True)로 전환하여 완전한 응답 대신 텍스트 청크를 반환합니다.\n- LLM을 호출할 때마다 이전 메시지에 대한 참조를 이해할 수 있도록 전체 채팅 기록을 입력으로 전달합니다.\n\n```js\nimport chromadb #0.5.0\nimport ollama  #0.5.0\n\nclass AI():\n def __init__(self):\n  db = chromadb.PersistentClient()\n  self.collection = db.get_or_create_collection(\"nvidia\")\n\n def query(self, q, top=10):\n  res_db = self.collection.query(query_texts=[q])[\"documents\"][0][0:top]\n  context = ' '.join(res_db).replace(\"\\n\", \" \")\n  return context\n\n def respond(self, lst_messages, model=\"phi3\", use_knowledge=False):\n  q = lst_messages[-1][\"content\"]\n  context = self.query(q)\n\n  if use_knowledge:\n   prompt = \"Give the most accurate answer using your knowledge and the folling additional information: \\n\"+context\n  else:\n   prompt = \"Give the most accurate answer using only the folling information: \\n\"+context\n\n  res_ai = ollama.chat(model=model, \n        messages=[{\"role\":\"system\", \"content\":prompt}]+lst_messages,\n                      stream=True)\n  for res in res_ai:\n   chunk = res[\"message\"][\"content\"]\n   app[\"full_response\"] += chunk\n   yield chunk\n\nai = AI()\n```\n\nStreamlit 앱을 실행하려면 다음 명령을 사용해야 합니다: streamlit run rag_app.py\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*C722wXvi4JCn3OrN8TbLLA.gif\" />\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n본 글은 Python과 LLMs를 사용하여 RAG 앱을 만드는 방법을 보여주는 튜토리얼이었습니다. 우리는 언어 모델을 사용하여 멀티모달 콘텐츠를 처리하고, 그 데이터를 벡터 데이터베이스에 저장했습니다. ChatGPT와 비슷한 AI가 우리의 질문에 답변할 때 사용하는 데이터베이스입니다. 마지막으로 모델과 채팅할 수 있는 사용자 친화적인 인터페이스를 만들었습니다.\n\n즐겁게 즐겼으면 좋겠습니다! 질문이나 피드백이 있으시면 언제든지 저에게 연락해 주시거나 귀하의 흥미로운 프로젝트를 공유해 주세요.","ogImage":{"url":"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png"},"coverImage":"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png\">\n<p>이 기사에서는 개인 문서에서 지식을 효과적으로 학습하고 질문에 대답할 수 있는 간단한 AI를 구축하는 방법을 보여드리겠습니다.</p>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_1.png\">\n<h2>소개</h2>\n<div class=\"content-ad\"></div>\n<p>자연어 처리(NLP)는 기계와 인간 언어 간의 상호작용을 연구하는 인공 지능 분야입니다. 지금까지 NLP의 정점은 거대한 양의 텍스트 데이터로 훈련된 대형 언어 모델(LLM)의 등장이었습니다. LLM은 언어 패턴과 변형을 학습할 수 있는 능력을 갖추고 있습니다. \"언어 모델\"이라는 용어는 딥 러닝과 신경망의 발전과 함께 흔해졌습니다. 특히 2018년 구글이 Transformer 기반 아키텍처를 소개한 후에는 NLP 모델의 성능이 크게 향상되었습니다.(구글의 BERT 및 OpenAI의 GPT).</p>\n<p>오늘날 LLM은 일반적으로 텍스트 간 작업 또는 \"텍스트 생성\"(즉, 번역, 요약, 챗봇 및 가상 비서, 심지어 전체 책 작성)에 사용됩니다. 이를 통해 우리는 새로운 콘텐츠(텍스트, 이미지, 오디오, 비디오 등) 작성에 초점을 맞춘 산업 분야인 생성적 인공지능(GenAI)의 부상을 목격하고 있습니다.</p>\n<p>최신 LLM 풍경:</p>\n<ul>\n<li>OpenAI의 ChatGPT, 가장 많이 사용됨 (여기서 시도해보기)</li>\n<li>Anthropic의 Claude(여기서 시도해보기)</li>\n<li>Google의 Gemini(여기서 시도해보기)</li>\n<li>Meta의 Llama(여기서 시도해보기)</li>\n<li>Microsoft의 Phi, 사용 가능한 모델 중 가장 작은 모델로 GPU 없이도 노트북에서 실행 가능(여기서 시도해보기)</li>\n<li>StabilityAI의 StableLM</li>\n<li>Cohere의 CommandR(여기서 시도해보기)</li>\n<li>Snowflake의 Arctic(여기서 시도해보기)</li>\n<li>Alibaba의 Qwen(여기서 시도해보기)</li>\n<li>01AI의 Yi</li>\n<li>X의 Grok</li>\n<li>NVIDIA의 Megatron</li>\n<li>아마존의 Olympus(아직 출시 예정)</li>\n<li>Apple의 MM1(아직 출시 예정)</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>ChatGPT은 가장 일반적으로 사용되는 LLM입니다. 그러나 회사들은 그것으로 업로드하기 어려운 문제가 있습니다. (대부분은 개인 정보 및 보안 상의 이유로) OpenAI에 민감한 데이터를 업로드할 수 없습니다. 따라서 회사들은 비공개 지식베이스에서 LLM의 파워를 활용하기 위해 내부 AI 서비스를 개발하고 있습니다. 이러한 종류의 작업을 검색 증강 생성(RAG)이라고 합니다. 이 기술은 외부 소스에서 가져온 지식 사실을 LLM에 추가하여 검색 및 생성 모델을 결합하는 방법입니다.</p>\n<p>조직 내에서, 지식 베이스는 일반적으로 다중 모달 콘텐츠(예: 텍스트, 이미지, 스프레드시트)를 포함한 문서로 구성되어 있으므로, 기계가 이해할 수 있도록 모든 것들을 처리하는 것이 가장 큰 도전입니다. 간단히 말해서, 먼저 모든 문서를 임베딩으로 변환한 다음 사용자 쿼리를 동일한 벡터 공간으로 변환하여 코사인 유사도 검색을 수행합니다.</p>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_2.png\" alt=\"이미지\"></p>\n<p>이 자습서에서는 GPU 없이 일반 노트북에서 실행 가능한 LLMs 및 다중 모달 데이터를 사용하여 RAG 앱을 만들 것입니다. 다른 유사한 경우에 쉽게 적용할 수 있는 유용한 Python 코드 몇 가지를 제시하고 있으며 (그저 복사하여 붙여넣기하고 실행하면 됩니다), 각 코드 라인에 대한 설명을 포함하여 이 예제를 복제할 수 있도록 안내할 것입니다 (전체 코드에 대한 링크는 아래에 있습니다).</p>\n<div class=\"content-ad\"></div>\n<p>특히 다음을 살펴볼 것입니다:</p>\n<ul>\n<li>설정: Pdf2image로 데이터 가져오기, PyTesseract로 OCR 처리하기.</li>\n<li>전처리: Ollama를 사용하여 LLM으로 데이터를 보강하기.</li>\n<li>데이터베이스: ChromaDB로 데이터를 벡터로 저장하고 쿼리하기.</li>\n<li>백엔드: Ollama를 사용하여답변 생성하기.</li>\n<li>프론트엔드: Streamlit으로 사용자가 AI와 상호작용할 수 있는 인터페이스 구축하기.</li>\n</ul>\n<h2>설정</h2>\n<p>현실 세계에서 회사들은 대부분의 문서를 공유하기 전에 해당 형식으로 변환하는 PDF를 광범위하게 사용합니다. 또한 이미지, 테이블, 텍스트가 포함된 문서들이 많이 있어 좋은 사용 사례를 나타냅니다. 따라서 이 예제에서는 PDF 형식의 공개 회사의 재무 보고서를 데이터셋으로 사용할 것입니다.</p>\n<div class=\"content-ad\"></div>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_3.png\" alt=\"이미지\"></p>\n<p>PDF 문서를 처리하는 두 가지 대안적 방법이 있습니다: 텍스트로 읽거나 이미지로 구문 분석합니다. 둘 다 사용 사례에 따라 다르기 때문에 완벽하지는 않지만, OCR (광학 문자 인식) 기능이 더 잘 작동하는 경향이 있으므로 이를 사용하겠습니다.</p>\n<p>이 기사의 초점이 OCR에 있지는 않으며, 작동 방식에 대해 자세히 설명하는 데 너무 많은 시간을 할애하지는 않을 것입니다. 만약 해당 주제를 깊이 파고들고 싶다면, 이 기사를 확인하고 LayoutParser와 Unstructured 같은 고급 OCR 라이브러리를 사용해 보세요.</p>\n<p>우선 문서를 이미지로 변환해야 합니다:</p>\n<div class=\"content-ad\"></div>\n<h1>conda install -c conda-forge poppler</h1>\n<p>import pdf2image #1.17.0</p>\n<p>doc_img = pdf2image.convert_from_path(\"data/doc_nvidia.pdf\", dpi=300)</p>\n<h1>예시로 한 페이지 출력</h1>\n<p>doc_img[35]</p>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_4.png\">\n<p>그런 다음, 페이지(이미지)에서 텍스트를 인식하겠습니다. 이를 위해 HP에서 1985년에 만들어진 주요 OCR 시스템 Tesseract를 사용하고 있으며 현재 Google에서 개발 중에 있습니다.</p>\n<p>import pytesseract #0.3.10</p>\n<p>doc_txt = []\nfor page in doc_img:\ntext = pytesseract.image_to_string(page)\ndoc_txt.append(text)</p>\n<p>doc_txt[35]</p>\n<div class=\"content-ad\"></div>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png\" alt=\"2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png\"></p>\n<p>이제 우리는 생 텍스트를 가지고 있으니, 무엇보다 처리를 해야 할 것입니다. 우리는 언어 모델을 사용할 것입니다. 현재 여러 가지 대체 라이브러리들이 있어서 LLM의 힘을 활용할 수 있습니다: Ollama, HuggingFace, DSPy, LangChain. 제가 사용하는 Ollama는 강력하면서 사용하기 쉽습니다.</p>\n<p>먼저, 웹사이트에서 프로그램을 다운로드해야 합니다. 그런 다음, 명령 프롬프트에서 아래 명령을 입력하여 노트북에서 LLM을 실행합니다 (저는 Phi3와 LLaVa를 사용하고 있습니다):</p>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png\" alt=\"2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png\"></p>\n<div class=\"content-ad\"></div>\n<p>마지막으로, Python 라이브러리를 설치하면 끝입니다 (pip install ollama).</p>\n<h2>전처리</h2>\n<p>어떤 데이터 과학 프로젝트든 마찬가지로, 언제나 가장 어려운 부분은 데이터셋입니다. 머신러닝을 얼마나 많이 사용하더라도 데이터가 좋지 않다면 AI가 제대로 작동하지 않을 것입니다.</p>\n<p>LLM(대형 언어 모델)의 경우, 임베딩이 포함되어 있기 때문에 표준 플랙티스는 모든 것을 텍스트로 변환하는 것입니다. 가장 일반적인 다중모달 콘텐츠 (텍스트, 테이블, 이미지, 플롯)의 처리 방법을 보여드리겠습니다.</p>\n<div class=\"content-ad\"></div>\n<p>텍스트 — 문서는 서로 다른 구조와 레이아웃을 가질 수 있기 때문에 데이터 세트를 단락으로 분할해야 합니다. 원시 텍스트 외에도 제목, 태그, 링크와 같은 추가 정보를 활용하여 데이터를 보강할 수 있습니다. 이를 메타데이터 보강이라고 합니다.</p>\n<pre><code class=\"hljs language-js\"># 목차를 사용하여 단락에 태그 지정하기\ntitle_map = {\n    <span class=\"hljs-string\">\"4-12\"</span>:<span class=\"hljs-string\">\"비즈니스\"</span>,\n    <span class=\"hljs-string\">\"13-33\"</span>:<span class=\"hljs-string\">\"위험 요인\"</span>,\n    <span class=\"hljs-string\">\"34-44\"</span>:<span class=\"hljs-string\">\"재무\"</span>,\n    <span class=\"hljs-string\">\"45-46\"</span>:<span class=\"hljs-string\">\"이사\"</span>,\n    <span class=\"hljs-string\">\"47-83\"</span>:<span class=\"hljs-string\">\"데이터\"</span>\n}\n\nlst_docs, lst_ids, lst_metadata = [], [], []\n<span class=\"hljs-keyword\">for</span> n,page <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">enumerate</span>(doc_txt):\n    <span class=\"hljs-attr\">try</span>:\n        ## 제목 가져오기\n        title = [v <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> title_map.<span class=\"hljs-title function_\">items</span>() \n                 <span class=\"hljs-keyword\">if</span> n <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">int</span>(k.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">\"-\"</span>)[<span class=\"hljs-number\">0</span>]), \n                               <span class=\"hljs-title function_\">int</span>(k.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">\"-\"</span>)[<span class=\"hljs-number\">1</span>])+<span class=\"hljs-number\">1</span>)][<span class=\"hljs-number\">0</span>]\n        ## 페이지 정리\n        page = page.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">\"Table of Contents\"</span>,<span class=\"hljs-string\">\"\"</span>)\n        ## 단락 가져오기\n        <span class=\"hljs-keyword\">for</span> i,p <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">enumerate</span>(page.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">'\\n\\n'</span>)):\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-title function_\">len</span>(p.<span class=\"hljs-title function_\">strip</span>())><span class=\"hljs-number\">5</span>:  ##&#x3C;--단락 정리\n                lst_docs.<span class=\"hljs-title function_\">append</span>(p.<span class=\"hljs-title function_\">strip</span>())\n                lst_ids.<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-title function_\">str</span>(n)+<span class=\"hljs-string\">\"_\"</span>+<span class=\"hljs-title function_\">str</span>(i))\n                lst_metadata.<span class=\"hljs-title function_\">append</span>({<span class=\"hljs-string\">\"title\"</span>:title})\n    <span class=\"hljs-attr\">except</span>:\n        <span class=\"hljs-keyword\">continue</span>\n\n\n## 예시 출력\n<span class=\"hljs-keyword\">for</span> id,doc,meta <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">zip</span>(lst_ids[<span class=\"hljs-number\">375</span>:<span class=\"hljs-number\">378</span>], \n                       lst_docs[<span class=\"hljs-number\">375</span>:<span class=\"hljs-number\">378</span>], \n                       lst_metadata[<span class=\"hljs-number\">375</span>:<span class=\"hljs-number\">378</span>]):\n    <span class=\"hljs-title function_\">print</span>(id, <span class=\"hljs-string\">\"-\"</span>, meta, <span class=\"hljs-string\">\"\\n\"</span>, doc, <span class=\"hljs-string\">\"\\n\"</span>)\n</code></pre>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_7.png\">\n<p>언어 모델을 사용한 메타데이터 보강은 문서 검색을 크게 향상시킬 수 있습니다. 예를 들어, 각 단락을 몇 가지 키워드로 요약하는 데 Phi3를 사용할 예정입니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> ollama #<span class=\"hljs-number\">0.2</span><span class=\"hljs-number\">.1</span>\n\ndef <span class=\"hljs-title function_\">keyword_generator</span>(p, top=<span class=\"hljs-number\">3</span>):\n    prompt = <span class=\"hljs-string\">\"다음 단락을 3개의 키워드로 요약해주세요, 각각 ,로 구분: \"</span>+p\n    res = ollama.<span class=\"hljs-title function_\">generate</span>(model=<span class=\"hljs-string\">\"phi3\"</span>, prompt=prompt)[<span class=\"hljs-string\">\"response\"</span>]\n    <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">\"\\n\"</span>,<span class=\"hljs-string\">\" \"</span>).<span class=\"hljs-title function_\">strip</span>()\n\n\n## test\np = <span class=\"hljs-string\">''</span><span class=\"hljs-string\">'Professional artists, architects and designers use NVIDIA partner products accelerated with our GPUs and software platform for a range of creative and design\nuse cases, such as creating visual effects in movies or designing buildings and products. In addition, generative Al is expanding the market for our workstation-\nclass GPUs, as more enterprise customers develop and deploy Al applications with their data on-premises.'</span><span class=\"hljs-string\">''</span>\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-title function_\">keyword_generator</span>(p))\n</code></pre>\n<p>결과: “창의적 디자인, NVIDIA 파트너십, AI 확장”. 위와 같이 모든 단락에 적용하겠습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> tqdm.<span class=\"hljs-property\">notebook</span> <span class=\"hljs-keyword\">import</span> tqdm\n\n<span class=\"hljs-keyword\">for</span> i,doc <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">tqdm</span>(<span class=\"hljs-title function_\">enumerate</span>(lst_docs)):\n    lst_metadata[i][<span class=\"hljs-string\">\"keywords\"</span>] = <span class=\"hljs-title function_\">keyword_generator</span>(doc)\n\n## 예시 출력\n<span class=\"hljs-keyword\">for</span> id,doc,meta <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">zip</span>(lst_ids[<span class=\"hljs-number\">375</span>:<span class=\"hljs-number\">378</span>], \n                       lst_docs[<span class=\"hljs-number\">375</span>:<span class=\"hljs-number\">378</span>], \n                       lst_metadata[<span class=\"hljs-number\">375</span>:<span class=\"hljs-number\">378</span>]):\n    <span class=\"hljs-title function_\">print</span>(id, <span class=\"hljs-string\">\"-\"</span>, meta, <span class=\"hljs-string\">\"\\n\"</span>, doc, <span class=\"hljs-string\">\"\\n\"</span>)\n</code></pre>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_8.png\">\n<div class=\"content-ad\"></div>\n<p>TABLES - LLM(Large Language Model)는 순차 텍스트를 현저한 정확도로 처리할 수 있는 것으로 잘 알려져 있습니다. 그러나 이제 구조화된 데이터도 이해하기 시작했기 때문에 테이블은 일반 텍스트로 전달될 수 있습니다. 이를 다시 한번 확인해보겠습니다:</p>\n<pre><code class=\"hljs language-js\">table = lst_docs[<span class=\"hljs-number\">376</span>]\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"테이블:\\n\"</span>, table)\n\nprompt = f<span class=\"hljs-string\">\"다음 테이블을 요약해주세요: {table}\"</span>\nres = ollama.<span class=\"hljs-title function_\">generate</span>(model=<span class=\"hljs-string\">\"phi3\"</span>, prompt=prompt)[<span class=\"hljs-string\">\"response\"</span>]\n\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"\\n요약:\\n\"</span>, res)\n</code></pre>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_9.png\" alt=\"이미지\"></p>\n<p>이미지 - 이미지의 임베딩은 상당히 까다로울 수 있습니다(3D 배열의 차원을 벡터로 축소해야 함). 따라서 일반적인 실천 방법은 이미지를 설명하는 캡션을 생성하기 위해 AI를 사용하고 가능한 경우 정보를 텍스트로 처리하는 것입니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> matplotlib <span class=\"hljs-keyword\">import</span> image, pyplot\n\nimage_file = <span class=\"hljs-string\">\"data/image.jpeg\"</span>\n\npyplot.imshow(image.imread(image_file))\npyplot.show()\n</code></pre>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_10.png\" alt=\"image\"></p>\n<p>LLM을 위해 이미지를 문자열로 변환해야 합니다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-comment\">## 이미지를 base64 문자열로 인코딩</span>\n<span class=\"hljs-keyword\">import</span> base64\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">encode_image</span>(<span class=\"hljs-params\">path</span>):\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(path, <span class=\"hljs-string\">\"rb\"</span>) <span class=\"hljs-keyword\">as</span> file:\n        <span class=\"hljs-keyword\">return</span> base64.b64encode(file.read()).decode(<span class=\"hljs-string\">'utf-8'</span>)\n\nimg = encode_image(image_file)\nimg[:<span class=\"hljs-number\">1000</span>]\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>아래는 테이블 태그를 Markdown 형식으로 변경한 예시입니다.</p>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_11.png\">\n<p>모델에 이미지 설명을 요청하는 문자열을 전달할 수 있습니다. 안타깝게도 Phi3은 시각 모델이 아니기 때문에 이 작업에 적합하지 않습니다:</p>\n<pre><code class=\"hljs language-js\">prompt = <span class=\"hljs-string\">\"이미지를 설명해주세요\"</span>\nres = ollama.<span class=\"hljs-title function_\">generate</span>(model=<span class=\"hljs-string\">\"phi3\"</span>, prompt=prompt, images=[img])[<span class=\"hljs-string\">\"response\"</span>]\n<span class=\"hljs-title function_\">print</span>(res)\n</code></pre>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_12.png\">\n<div class=\"content-ad\"></div>\n<p>따라서 적절한 시각 모델을 구해야 합니다. Microsoft의 LLaVa는 GPU 없이도 실행할 수 있어 효율적인 선택입니다 (여기에서 시도해 보세요).</p>\n<pre><code class=\"hljs language-js\">## <span class=\"hljs-title class_\">LLaVA</span>\nprompt = <span class=\"hljs-string\">\"이미지를 설명해주세요\"</span>\nres = ollama.<span class=\"hljs-title function_\">generate</span>(model=<span class=\"hljs-string\">\"llava\"</span>, prompt=prompt, images=[img])[<span class=\"hljs-string\">\"response\"</span>]\n<span class=\"hljs-title function_\">print</span>(res)\n</code></pre>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_13.png\">\n<p>PLOTS — 이미지와 마찬가지로, 시각 모델은 플롯/차트를 읽고 요약할 수 있지만 결과가 정확하지는 않습니다. 예를 살펴보겠습니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">이미지_파일 = <span class=\"hljs-string\">\"data/plot.png\"</span>\n\npyplot.<span class=\"hljs-title function_\">imshow</span>(image.<span class=\"hljs-title function_\">imread</span>(image_file))\npyplot.<span class=\"hljs-title function_\">show</span>()\n\nimg = <span class=\"hljs-title function_\">encode_image</span>(image_file)\n\nprompt = <span class=\"hljs-string\">\"그래프와 같은 그림에 대해 구체적으로 설명해주세요.\"</span>\nres = ollama.<span class=\"hljs-title function_\">generate</span>(model=<span class=\"hljs-string\">\"llava\"</span>, prompt=prompt, images=[img])[<span class=\"hljs-string\">\"response\"</span>]\n<span class=\"hljs-title function_\">print</span>(res)\n</code></pre>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_14.png\">\n<h2>데이터베이스</h2>\n<p>우리는 데이터를 벡터 데이터베이스에 저장할 수 있습니다. 이는 비구조적 데이터를 효율적으로 저장하고 색인화하고 검색하는 가장 좋은 해결책입니다. 요즘 가장 많이 사용되는 벡터 데이터베이스는 Microsoft의 AISearch입니다. 최고의 오픈 소스 도구는 유용하고 쉽고 무료인 ChromaDB입니다.</p>\n<div class=\"content-ad\"></div>\n<p>빠르게 \"pip install chromadb\"를 입력하면 Python을 사용하여 세 가지 다른 방법으로 db와 상호 작용할 수 있습니다:</p>\n<ul>\n<li>chromadb.Client()는 디스크 공간을 차지하지 않고 메모리에 일시적으로 유지되는 db를 만듭니다.</li>\n<li>chromadb.PersistentClient(path)는 로컬 기계에서 db를 저장하고 로드합니다.</li>\n<li>chromadb.HttpClient(host='localhost', port=8000)는 브라우저에서 클라이언트-서버 모드를 사용할 수 있습니다.</li>\n</ul>\n<p>ChromaDB에 문서를 저장할 때 데이터는 벡터로 저장되어 일치하는 레코드를 검색할 때 쿼리 벡터를 사용할 수 있습니다. 참고로, 그렇게 명시하지 않으면 기본 임베딩 방법은 문장 변환 모델 (all-MiniLM-L6-v2)입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> chromadb #<span class=\"hljs-number\">0.5</span><span class=\"hljs-number\">.0</span>\n\ndb = chromadb.<span class=\"hljs-title class_\">PersistentClient</span>()\n\ncollection_name = <span class=\"hljs-string\">\"nvidia\"</span>\ncollection = db.<span class=\"hljs-title function_\">get_or_create_collection</span>(name=collection_name, \n               embedding_function=chromadb.<span class=\"hljs-property\">utils</span>.<span class=\"hljs-property\">embedding_functions</span>.<span class=\"hljs-title class_\">DefaultEmbeddingFunction</span>())\n\ncollection.<span class=\"hljs-title function_\">add</span>(documents=lst_docs, ids=lst_ids, metadatas=lst_metadata, \n               images=<span class=\"hljs-title class_\">None</span>, embeddings=<span class=\"hljs-title class_\">None</span>)\ncollection.<span class=\"hljs-title function_\">peek</span>(<span class=\"hljs-number\">1</span>)\n</code></pre>\n<div class=\"content-ad\"></div>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_15.png\">\n<p>어떤 것을 쿼리해보세요:</p>\n<pre><code class=\"hljs language-js\">query = <span class=\"hljs-string\">\"수익은 얼마인가요?\"</span>\ncollection.<span class=\"hljs-title function_\">query</span>(query_texts=[query])\n</code></pre>\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_16.png\">\n<div class=\"content-ad\"></div>\n<p>쿼리가 동일한 벡터 공간에 포함되어 있고 ChromaDB가 가장 가까운 문서를 검색했습니다. 그들을 결합해서 db에서 최종 응답을 얻을 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">res_db = collection.<span class=\"hljs-title function_\">query</span>(query_texts=[query])[<span class=\"hljs-string\">\"documents\"</span>][<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">10</span>]\ncontext = <span class=\"hljs-string\">' '</span>.<span class=\"hljs-title function_\">join</span>(res_db).<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">\"\\n\"</span>, <span class=\"hljs-string\">\" \"</span>)\ncontext\n</code></pre>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_17.png\" alt=\"이미지\"></p>\n<p>db 응답은 컨텍스트로 사용될 수 있으며, 이는 LLM이 저장하고 액세스할 수 있는 소량의 정보 세트입니다. 프롬프트를 사용하여 모델이 컨텍스트 내 정보만 사용할지 훈련 중에 학습한 지식도 사용해야 하는지 지정할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">Context</span>만으로 대화하기\nres = ollama.<span class=\"hljs-title function_\">chat</span>(model=<span class=\"hljs-string\">\"phi3\"</span>, \n                  messages=[{<span class=\"hljs-string\">\"role\"</span>:<span class=\"hljs-string\">\"system\"</span>, <span class=\"hljs-string\">\"content\"</span>:<span class=\"hljs-string\">\"다음 정보만을 사용하여 가장 정확한 답변을 제공하세요: \\n\"</span>+context},\n                            {<span class=\"hljs-string\">\"role\"</span>:<span class=\"hljs-string\">\"user\"</span>, <span class=\"hljs-string\">\"content\"</span>:query}])\n<span class=\"hljs-title function_\">print</span>(res[<span class=\"hljs-string\">\"message\"</span>][<span class=\"hljs-string\">\"content\"</span>])\n</code></pre>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_18.png\" alt=\"이미지\"></p>\n<p>또는 모델의 지식을 추가하여:</p>\n<pre><code class=\"hljs language-js\"># 지식 및 <span class=\"hljs-title class_\">Context</span>로 대화하기\nres = ollama.<span class=\"hljs-title function_\">chat</span>(model=<span class=\"hljs-string\">\"phi3\"</span>, \n                  messages=[{<span class=\"hljs-string\">\"role\"</span>:<span class=\"hljs-string\">\"system\"</span>, <span class=\"hljs-string\">\"content\"</span>:<span class=\"hljs-string\">\"귀하의 지식과 다음 추가 정보를 사용하여 가장 정확한 답변을 제공하세요: \\n\"</span>+context},\n                            {<span class=\"hljs-string\">\"role\"</span>:<span class=\"hljs-string\">\"user\"</span>, <span class=\"hljs-string\">\"content\"</span>:query}])\n<span class=\"hljs-title function_\">print</span>(res[<span class=\"hljs-string\">\"message\"</span>][<span class=\"hljs-string\">\"content\"</span>])\n</code></pre>\n<div class=\"content-ad\"></div>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_19.png\" alt=\"Image\"></p>\n<p>데이터베이스가 설정되어 정상적으로 작동 중입니다. 다음 단계로 진행하여 문서에 관한 질문을 할 수 있는 챗봇 앱을 만들 수 있습니다.</p>\n<h2>프론트엔드</h2>\n<p>요즘 가장 많이 사용되는 Python 라이브러리인 Streamlit은 NLP 애플리케이션 개발을 간편하게 만들어주는 스트리밍 기능으로 알려져 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>시작하기 전에 먼저 레이아웃을 정의해 봅시다: 화면에는 사용자가 채팅 기록을 볼 수 있는 사이드바가 있기를 원합니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> streamlit <span class=\"hljs-keyword\">as</span> st <span class=\"hljs-comment\">#1.35.0</span>\n\n<span class=\"hljs-comment\">## 레이아웃</span>\nst.title(<span class=\"hljs-string\">'💬 궁금한 점을 적어주세요'</span>)\nst.sidebar.title(<span class=\"hljs-string\">\"채팅 기록\"</span>)\napp = st.session_state\n\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">\"messages\"</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> app:\n    app[<span class=\"hljs-string\">\"messages\"</span>] = [{<span class=\"hljs-string\">\"role\"</span>:<span class=\"hljs-string\">\"assistant\"</span>, <span class=\"hljs-string\">\"content\"</span>:<span class=\"hljs-string\">\"정보를 검색할 준비가 되어 있습니다.\"</span>}]\n\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">'history'</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> app:\n    app[<span class=\"hljs-string\">'history'</span>] = []\n\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">'full_response'</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> app:\n    app[<span class=\"hljs-string\">'full_response'</span>] = <span class=\"hljs-string\">''</span> \n</code></pre>\n<p>앱 객체(또는 session_state)는 다음과 같은 구조를 갖는 딕셔너리입니다:</p>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_20.png\" alt=\"이미지\"></p>\n<div class=\"content-ad\"></div>\n<p>만약 채팅에서 메시지가 사라지는 것을 원하지 않는다면, 다음 코드를 추가하세요:</p>\n<pre><code class=\"hljs language-js\">## 채팅 메시지 유지\n<span class=\"hljs-keyword\">for</span> msg <span class=\"hljs-keyword\">in</span> app[<span class=\"hljs-string\">\"messages\"</span>]:\n    <span class=\"hljs-keyword\">if</span> msg[<span class=\"hljs-string\">\"role\"</span>] == <span class=\"hljs-string\">\"user\"</span>:\n        st.<span class=\"hljs-title function_\">chat_message</span>(msg[<span class=\"hljs-string\">\"role\"</span>], avatar=<span class=\"hljs-string\">\"😎\"</span>).<span class=\"hljs-title function_\">write</span>(msg[<span class=\"hljs-string\">\"content\"</span>])\n    elif msg[<span class=\"hljs-string\">\"role\"</span>] == <span class=\"hljs-string\">\"assistant\"</span>:\n        st.<span class=\"hljs-title function_\">chat_message</span>(msg[<span class=\"hljs-string\">\"role\"</span>], avatar=<span class=\"hljs-string\">\"👾\"</span>).<span class=\"hljs-title function_\">write</span>(msg[<span class=\"hljs-string\">\"content\"</span>])\n</code></pre>\n<p>이제 채팅 코어를 코드화해야 합니다: 사용자의 질문은 메시지 목록에 추가되어 AI로 전달되고, 앱은 응답을 스트리밍할 것입니다.</p>\n<pre><code class=\"hljs language-js\">## 채팅\n<span class=\"hljs-keyword\">if</span> txt := st.<span class=\"hljs-title function_\">chat_input</span>():\n    ### 사용자 입력\n    app[<span class=\"hljs-string\">\"messages\"</span>].<span class=\"hljs-title function_\">append</span>({<span class=\"hljs-string\">\"role\"</span>:<span class=\"hljs-string\">\"user\"</span>, <span class=\"hljs-string\">\"content\"</span>:txt})\n    st.<span class=\"hljs-title function_\">chat_message</span>(<span class=\"hljs-string\">\"user\"</span>, avatar=<span class=\"hljs-string\">\"😎\"</span>).<span class=\"hljs-title function_\">write</span>(txt)\n\n    ### <span class=\"hljs-variable constant_\">AI</span>가 채팅 스트림으로 응답\n    app[<span class=\"hljs-string\">\"full_response\"</span>] = <span class=\"hljs-string\">\"\"</span>\n    st.<span class=\"hljs-title function_\">chat_message</span>(<span class=\"hljs-string\">\"assistant\"</span>, avatar=<span class=\"hljs-string\">\"👾\"</span>).<span class=\"hljs-title function_\">write_stream</span>( xxx ) )\n    app[<span class=\"hljs-string\">\"messages\"</span>].<span class=\"hljs-title function_\">append</span>({<span class=\"hljs-string\">\"role\"</span>:<span class=\"hljs-string\">\"assistant\"</span>, <span class=\"hljs-string\">\"content\"</span>:app[<span class=\"hljs-string\">\"full_response\"</span>]})\n    \n    ### 사이드바 히스토리 보여주기\n    app[<span class=\"hljs-string\">'history'</span>].<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">\"😎: \"</span>+txt)\n    app[<span class=\"hljs-string\">'history'</span>].<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">\"👾: \"</span>+app[<span class=\"hljs-string\">\"full_response\"</span>])\n    st.<span class=\"hljs-property\">sidebar</span>.<span class=\"hljs-title function_\">markdown</span>(<span class=\"hljs-string\">\"&#x3C;br />\"</span>.<span class=\"hljs-title function_\">join</span>(app[<span class=\"hljs-string\">'history'</span>])+<span class=\"hljs-string\">\"&#x3C;br />&#x3C;br />\"</span>, unsafe_allow_html=<span class=\"hljs-title class_\">True</span>)\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>우리는 사용자 질문에 응답하는 기능을 완성한 후 \"xxx\"로 대체할 자리 표시자를 삽입했습니다. 앱을 실행하면 다음과 같이 보입니다:</p>\n<p><img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_21.png\" alt=\"앱 실행 화면\"></p>\n<h2>백엔드</h2>\n<p>우리는 이미 이 부분에 익숙합니다. 이것을 클래스 내에 넣기만 하면 됩니다. 강조할 몇 가지 포인트가 있습니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>ChromaDB에서 컬렉션 이름을 호출하면, 이미 존재하는 경우 db는 새로 만들지 않고 \"가져오게\" 됩니다.</li>\n<li>Ollama 채팅 기능의 스트리밍 매개변수는 (stream=True)로 전환하여 완전한 응답 대신 텍스트 청크를 반환합니다.</li>\n<li>LLM을 호출할 때마다 이전 메시지에 대한 참조를 이해할 수 있도록 전체 채팅 기록을 입력으로 전달합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> chromadb #<span class=\"hljs-number\">0.5</span><span class=\"hljs-number\">.0</span>\n<span class=\"hljs-keyword\">import</span> ollama  #<span class=\"hljs-number\">0.5</span><span class=\"hljs-number\">.0</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AI</span>():\n def <span class=\"hljs-title function_\">__init__</span>(self):\n  db = chromadb.<span class=\"hljs-title class_\">PersistentClient</span>()\n  self.<span class=\"hljs-property\">collection</span> = db.<span class=\"hljs-title function_\">get_or_create_collection</span>(<span class=\"hljs-string\">\"nvidia\"</span>)\n\n def <span class=\"hljs-title function_\">query</span>(self, q, top=<span class=\"hljs-number\">10</span>):\n  res_db = self.<span class=\"hljs-property\">collection</span>.<span class=\"hljs-title function_\">query</span>(query_texts=[q])[<span class=\"hljs-string\">\"documents\"</span>][<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>:top]\n  context = <span class=\"hljs-string\">' '</span>.<span class=\"hljs-title function_\">join</span>(res_db).<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">\"\\n\"</span>, <span class=\"hljs-string\">\" \"</span>)\n  <span class=\"hljs-keyword\">return</span> context\n\n def <span class=\"hljs-title function_\">respond</span>(self, lst_messages, model=<span class=\"hljs-string\">\"phi3\"</span>, use_knowledge=<span class=\"hljs-title class_\">False</span>):\n  q = lst_messages[-<span class=\"hljs-number\">1</span>][<span class=\"hljs-string\">\"content\"</span>]\n  context = self.<span class=\"hljs-title function_\">query</span>(q)\n\n  <span class=\"hljs-keyword\">if</span> <span class=\"hljs-attr\">use_knowledge</span>:\n   prompt = <span class=\"hljs-string\">\"Give the most accurate answer using your knowledge and the folling additional information: \\n\"</span>+context\n  <span class=\"hljs-attr\">else</span>:\n   prompt = <span class=\"hljs-string\">\"Give the most accurate answer using only the folling information: \\n\"</span>+context\n\n  res_ai = ollama.<span class=\"hljs-title function_\">chat</span>(model=model, \n        messages=[{<span class=\"hljs-string\">\"role\"</span>:<span class=\"hljs-string\">\"system\"</span>, <span class=\"hljs-string\">\"content\"</span>:prompt}]+lst_messages,\n                      stream=<span class=\"hljs-title class_\">True</span>)\n  <span class=\"hljs-keyword\">for</span> res <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">res_ai</span>:\n   chunk = res[<span class=\"hljs-string\">\"message\"</span>][<span class=\"hljs-string\">\"content\"</span>]\n   app[<span class=\"hljs-string\">\"full_response\"</span>] += chunk\n   <span class=\"hljs-keyword\">yield</span> chunk\n\nai = <span class=\"hljs-title function_\">AI</span>()\n</code></pre>\n<p>Streamlit 앱을 실행하려면 다음 명령을 사용해야 합니다: streamlit run rag_app.py</p>\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*C722wXvi4JCn3OrN8TbLLA.gif\">\n<div class=\"content-ad\"></div>\n<h2>결론</h2>\n<p>본 글은 Python과 LLMs를 사용하여 RAG 앱을 만드는 방법을 보여주는 튜토리얼이었습니다. 우리는 언어 모델을 사용하여 멀티모달 콘텐츠를 처리하고, 그 데이터를 벡터 데이터베이스에 저장했습니다. ChatGPT와 비슷한 AI가 우리의 질문에 답변할 때 사용하는 데이터베이스입니다. 마지막으로 모델과 채팅할 수 있는 사용자 친화적인 인터페이스를 만들었습니다.</p>\n<p>즐겁게 즐겼으면 좋겠습니다! 질문이나 피드백이 있으시면 언제든지 저에게 연락해 주시거나 귀하의 흥미로운 프로젝트를 공유해 주세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}