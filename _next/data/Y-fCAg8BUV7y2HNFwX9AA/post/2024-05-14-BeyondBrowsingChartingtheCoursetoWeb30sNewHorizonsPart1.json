{"pageProps":{"post":{"title":"웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1","description":"","date":"2024-05-14 14:09","slug":"2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1","content":"\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png)\n\n웹 3.0의 개념은 2000년대 초반에 나타나기 시작했으며, 웹 2.0의 잠재적인 후속자로 손에 잡히는 관심을 끌었습니다. 그 시작 시기는 정확히 정해져 있지 않지만, \"웹 3.0\"이라는 용어는 2000년대 중반쯤에 기술자들과 사고 선도자들이 인터넷 진화의 다음 단계를 상상하기 시작함에 따라 널리 통용되었습니다.\n\n웹 3.0은 인터넷 진화의 혁명적인 단계로 생겨나며, 분산된 신뢰성 없는 프레임워크로 전통적인 표준을 깰 준비를 하고 있습니다. 이 개혁적인 패러다임 변화는 중앙화된 권한으로부터 벗어나 개인 이해관계자 간에 권력이 민주화된 시대를 예고하고 있습니다. 블록체인, 분산저장 및 스마트 계약과 같은 최첨단 기술을 활용하여, 웹 3.0은 조직이 운영에서 향상된 보안, 투명성 및 효율성을 추구하는 동력적 제안을 제시하고 있습니다. 이 대대적인 변화는 거래의 모습을 재정립 뿐만 아니라, 점차적으로 디지턀 배경에서 혁신을 받아들여 번영하기 위한 필요성을 강조합니다. 조직이 웹 3.0의 모습을 탐색하는 동안, 그들은 새로운 기회의 가능성을 풀고 산업의 궤도를 형성할 수 있는 변형적인 여정에 나서며, 보다 분산된, 유연한 및 포용적인 생태계로 향하는 전환적인 여정을 시작합니다.\n\n# 웹 2.0의 문제점과 웹 3.0의 발명을 이끈 문제들\n\n\n\n웹 2.0는 여러 측면에서 혁명적이었지만 몇 가지 문제와 제약도 함께 가져왔습니다. 이 기사에서 몇 가지를 강조하고 싶습니다:\n\n## 권력의 중앙화\n\n웹 2.0 플랫폼은 대부분 중앙 집중화되어 있어서 소수의 대형 기업이 사용자 데이터, 콘텐츠 배포, 플랫폼 운영에 상당한 통제력을 갖고 있습니다. 이 중앙 집중화는 검열, 데이터 유출, 그리고 통제된 상업 관행과 같은 문제로 이어질 수 있습니다.\n\n## 프라이버시 부재\n\n\n\n웹 2.0 기반 애플리케이션은 일반적으로 명확한 동의나 적절한 개인정보 보호 없이도 사용자 데이터를 대상으로 한 광고 및 기타 목적을 위해 방대한 양을 수집합니다. 이러한 프라이버시의 부족은 사용자 신뢰를 약화시키고 데이터 남용과 감시에 대한 우려를 야기할 수 있습니다.\n\n## 상호 운용성 도전\n\n현재의 애플리케이션은 종종 재고를 축적하여 사용자가 서로 다른 서비스와 애플리케이션 간의 데이터와 정보를 원할하게 전송하는 것을 어렵게 만듭니다. 이러한 상호 운용성의 부족은 혁신을 억제하고 사용자 선택을 제한하며 새로운 경쟁 업체에 대한 진입 장벽을 만들 수 있습니다.\n\n## 보안 취약점\n\n\n\n오늘날의 웹 2.0 기반 구현은 때로 보안 취약점과 데이터 유출에 노출될 수 있어서 사용자 정보를 위험에 빠뜨릴 수 있습니다. 데이터의 중앙 집중 저장 및 단일 장애 지점에 의존하면 사이버 공격 및 민감한 정보에 대한 무단 액세스 가능성이 증가합니다.\n\n![그림](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_1.png)\n\n## 이용자 제어의 제한\n\n웹 2.0에서 사용자는 자신의 데이터, 신원 및 디지털 자산에 대해 제한된 제어권을 갖고 있습니다. 플랫폼은 종종 서비스 약관을 지시하고 컨텐츠를 검열하거나 액세스를 제한하거나 사용자에게 별다른 대응 기회 없이 계정을 해지할 권한을 갖고 있습니다.\n\n\n\n## 수익 모델\n\n애플리케이션은 주로 광고 수익과 사용자 데이터 활용을 통해 수익을 창출합니다. 이는 플랫폼이 사용자의 복지보다는 사용자 참여 지표를 우선시하도록 장려하며, 부정한 행위와 관심 조작으로 이어질 수 있습니다.\n\n## 신뢰 문제\n\n플랫폼은 불투명한 알고리즘, 편향적인 콘텐츠 관리, 그리고 의사결정 프로세스의 투명성 부족으로 인해 신뢰 문제를 겪을 수 있습니다. 이는 온라인 정보와 상호 작용의 정직성과 신뢰성에 대한 사용자의 신뢰를 약화시킬 수 있습니다.\n\n\n\n# 웹 3.0의 핵심 원칙\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_2.png)\n\n## 분산화\n\n웹 3.0은 통제를 분산화하고 중앙 당국 또는 중개인에 의존성을 제거하려고 합니다. 소수 기업이나 개체의 손에 집중시키는 대신 사용자 네트워크 사이에서 권력을 분산시켜 더 견고하고 포용적이며 검열 방지혁 인터넷 생태계를 만들려고 합니다. 이더리움 블록체인에 배포된 탈중앙화 애플리케이션(DApp)과 상호 작용하기 위해 web3.js 라이브러리를 사용하는 다음 예제를 확인해보세요.\n\n\n\n```js\n// Web3.js 라이브러리를 가져옵니다\nimport Web3 from 'web3';\n\n// 이더리움 네트워크에 연결합니다 ('http://localhost:8545'를 자신의 이더리움 노드 URL로 바꿉니다)\nconst web3 = new Web3('http://localhost:8545');\n\n// 스마트 계약의 주소와 ABI (Application Binary Interface)를 정의합니다\nconst contractAddress = '0x1234567890123456789012345678901234567890'; // 귀하의 계약 주소로 대체합니다\nconst contractABI: any[] = [\n  // 귀하의 스마트 계약 메서드의 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getData\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n];\n\n// 계약 인스턴스를 생성합니다\nconst contract = new web3.eth.Contract(contractABI, contractAddress);\n\n// 스마트 계약에서 데이터를 가져오는 함수\nasync function fetchData(): Promise<void> {\n  try {\n    // 스마트 계약의 getData 함수 호출\n    const data: number = await contract.methods.getData().call();\n    console.log('스마트 계약에서 검색된 데이터:', data);\n  } catch (error) {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  }\n}\n\n// fetchData 함수 호출합니다\nfetchData();\n```\n\n## 상호 운용성\n\n웹 3.0의 개념은 서로 다른 플랫폼, 응용 프로그램 및 프로토콜간의 상호 운용성을 촉진합니다. 이는 다양한 생태계 간의 원활한 데이터 교환과 협력을 가능케 하며, 혁신을 촉진하고 사용자가 사일로된 데이터나 닫힌 시스템으로 제약받지 않고 웹을 더 유연하게 탐색할 수 있도록 합니다.\n\n다음은 서로 다른 네트워크에 배포된 두 개의 이더리움 기반 스마트 계약 간의 상호 운용성을 보여주는 TypeScript의 기본 예제입니다.\n\n\n\n```js\n// Web3.js 라이브러리를 가져와서 사용합니다\nimport Web3 from 'web3';\n\n// 이더리움 네트워크에 연결합니다 (이더리움 노드 URL과 네트워크 ID를 교체해주세요)\nconst web3NetworkA = new Web3('http://networkA:8545');\nconst web3NetworkB = new Web3('http://networkB:8545');\n\n// 네트워크 A에 배포된 첫 번째 스마트 계약의 주소와 ABI를 정의합니다\nconst contractAddressA = '0x1234567890123456789012345678901234567890'; // 네트워크 A의 계약 주소로 교체해주세요\nconst contractABIA: any[] = [\n  // 네트워크 A에 배포된 스마트 계약의 ABI\n  // 네트워크 A의 계약과 상호작용할 메서드를 정의합니다\n];\n\n// 네트워크 B에 배포된 두 번째 스마트 계약의 주소와 ABI를 정의합니다\nconst contractAddressB = '0x0987654321098765432109876543210987654321'; // 네트워크 B의 계약 주소로 교체해주세요\nconst contractABIB: any[] = [\n  // 네트워크 B에 배포된 스마트 계약의 ABI\n  // 네트워크 B의 계약과 상호작용할 메서드를 정의합니다\n];\n\n// 두 계약의 인스턴스를 생성합니다\nconst contractA = new web3NetworkA.eth.Contract(contractABIA, contractAddressA);\nconst contractB = new web3NetworkB.eth.Contract(contractABIB, contractAddressB);\n\n// 두 계약 간 데이터 전송하는 함수를 정의합니다\nasync function transferData(): Promise<void> {\n  try {\n    // 계약 A에서 데이터를 검색하는 메서드 호출\n    const data = await contractA.methods.getData().call();\n\n    // 계약 B에서 데이터를 설정하는 메서드 호출\n    await contractB.methods.setData(data).send({ from: '0x당신의주소', gas: 500000 });\n    \n    console.log('계약 A에서 계약 B로 데이터 전송 성공:', data);\n  } catch (error) {\n    console.error('데이터 전송 중 오류 발생:', error);\n  }\n}\n\n// 상호운용성을 보여주기 위해 transferData 함수 호출\ntransferData();\n```\n\n## 개인정보\n\n개인정보 보호는 Web 3.0의 핵심 원칙으로, 사용자가 개인 데이터를 제어하고 소유하는 것을 강조합니다. 사용자 데이터가 수집되고 이익을 위해 활용되며 침해를 받는 Web 2.0과는 달리, Web 3.0은 사용자의 개인 정보를 보호하는 메커니즘을 우선시합니다. 이는 분산 저장, 암호화, 자기 주권 식별 솔루션 등을 포함합니다.\n\n다음은 TypeScript를 사용한 간단한 예제로, 암호 기술과 분산 인증 메커니즘을 활용하여 사용자의 개인 정보 보호를 강화하는 웹3-react 라이브러리를 이용한 탈중앙화 애플리케이션(DApp)과 상호 작용하는 방법을 보여줍니다.\n\n\n\n```js\nimport { ethers } from 'ethers';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { InjectedConnector } from '@web3-react/injected-connector';\nimport { useWeb3React } from '@web3-react/core';\n\n// 주입된 커넥터를 초기화합니다.\nconst injectedConnector = new InjectedConnector({ supportedChainIds: [1, 3, 4, 5, 42] });\n\n// 이더리움 프로바이더를 초기화합니다.\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\n\n// 계정 세부 정보를 가져오는 함수\nasync function fetchAccountDetails(): Promise<void> {\n  try {\n    // 사용자의 이더리움 계정에 접근 권한을 요청합니다.\n    await provider.send('eth_requestAccounts', []);\n\n    // 서명자를 가져옵니다.\n    const signer = provider.getSigner();\n\n    // 사용자의 이더리움 주소를 가져옵니다.\n    const address = await signer.getAddress();\n\n    // 주소 출력\n    console.log('사용자 주소:', address);\n  } catch (error) {\n    console.error('계정 세부 정보 가져오기 오류:', error);\n  }\n}\n\n// 주요 함수\nasync function main(): Promise<void> {\n  // 계정 세부 정보 가져오기\n  await fetchAccountDetails();\n}\n\n// 주요 함수 실행\nmain();\n```\n\n## 사용자 권한 부여\n\n또한 사용자에게 온라인 경험, 아이덴티티 및 디지털 자산에 대한 더 큰 통제력을 제공하여 사용자들을 권한 부여하는 것을 목표로 합니다. Web 3.0에서 탈중앙화된 거버넌스, 자체 실행 스마트 계약 및 토큰화와 같은 기능을 통해 사용자들은 의사 결정 과정에 더 적극적으로 참여하고 새로운 경제적 기회에 접근하며 디지털 삶 소유권을 주장할 수 있습니다.\n\nTypeScript를 사용한 Web 3.0에서 사용자 권한 부여를 보여주는 간단한 예제로 탈중앙화된 아이덴티티(DID) 솔루션을 사용합니다. 이 예제에서는 이더리움에서 탈중앙화된 아이덴티티 관리의 인기 있는 선택인 uPort 라이브러리를 사용할 것입니다.\n\n\n\n\n```js\nimport { Connect, SimpleSigner } from 'uport-connect';\n\n// uPort 인스턴스 생성\nconst uport = new Connect('당신의앱이름', {\n  clientId: '당신의클라이언트아이디', // 여러분의 uPort 클라이언트 ID로 대체해주세요\n  signer: SimpleSigner('당신의개인키') // 여러분의 개인 키로 대체해주세요\n});\n\n// 사용자를 위한 탈중앙화 식별자(DID) 생성하는 함수\nasync function createDID(): Promise<void> {\n  try {\n    // 사용자에게 탈중앙화 식별자를 만들기 위한 동의를 요청함\n    const credentials = await uport.requestCredentials({\n      requested: ['name', 'avatar'], // 요청된 사용자 속성\n      notifications: true // 크리덴셜 요청을 위한 푸시 알림 활성화\n    });\n\n    // 사용자의 탈중앙화 식별자를 기록함\n    console.log('탈중앙화 식별자(DID):', credentials);\n  } catch (error) {\n    console.error('탈중앙화 식별자 생성 중 오류 발생:', error);\n  }\n}\n\n// 사용자를 위해 탈중앙화 식별자를 만들기 위해 createDID 함수 호출\ncreateDID();\n```\n\n# 웹 3.0에 대해 더 알아보기\n\n위의 기사에서 몇 가지 용어를 언급했는데, 분명 일부 용어가 블록체인과 관련이 있다는 걸 알아챘을 거예요. 그래서 우리는 블록체인이 웹 3.0을 위한 기술적 기반으로 작용한다고 할 수 있어요. 이제 웹 3.0 관련 용어 몇 가지 더 살펴봅시다.\n\n## 탈중앙화 애플리케이션 (DApp)\n\n\n\n분산 애플리케이션(DApp)은 블록체인 기술을 활용하는 분산 네트워크에서 작동하는 소프트웨어 응용 프로그램 유형입니다. 일반적으로 중앙화된 서버에 호스팅되고 단일 엔티티에 의해 제어되는 전통적인 애플리케이션과는 달리, DApp은 컴퓨터(노드)들의 동등 네트워크에서 실행되며 데이터와 작업이 네트워크 상으로 분산됩니다. DApp의 주요 특징으로는 분산화, 오픈 소스, 토큰화, 스마트 계약, 변경할 수 없는 데이터와 상호 운용성이 있습니다.\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_3.png)\n\n분산화 응용 프로그램의 몇 가지 예시로는 분산 재무(DeFi) 플랫폼, 분산 거래소 (DEX), 블록체인 기반 게임, 소셜 네트워크 및 공급망 관리 시스템 등이 있습니다.\n\n## 스마트 계약 및 ABI\n\n\n\n스마트 계약은 합의 조건이 직접 코드로 작성된 자체 실행 계약입니다. 이러한 계약은 이더리움과 같은 블록체인 네트워크에 저장되고 실행되며 중개인 없이 당사자 간의 합의 조건을 자동으로 시행합니다. 스마트 계약의 주요 특징으로는 자치성, 신뢰 없음, 보안, 투명성, 효율성 및 분산화가 있습니다.\n\n위 예제에서 스마트 계약인 다음 코드를 주목했을 것입니다:\n\n```js\nconst contractABI: any[] = [\n  // 스마트 계약 메서드의 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getData\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n];\n```\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_4.png)\n\n\n\nABI는 \"Application Binary Interface\"의 약자입니다. ABI는 이더리움 블록체인에 배포된 스마트 계약의 인터페이스를 JSON으로 나타낸 것입니다. 스마트 계약의 메서드와 속성을 정의하며, 해당 메서드와 속성의 이름, 매개변수, 반환 유형 및 가시성을 포함합니다.\n\nABI는 탈중앙화된 응용프로그램(DApps)이나 스크립트와 같은 외부 응용프로그램에서 스마트 계약과 상호작용하는 데 중요합니다. ABI는 이더리움 가상 머신(EVM)과 외부 응용프로그램 사이의 다리 역할을 하며, 배포된 스마트 계약에서 함수를 호출하고 상호작용할 수 있게 합니다.\n\nAPI와는 다른 ABI에 대한 내용을 자세히 다룬 좋은 기사가 있습니다.\n\n## 검열 저항력\n\n\n\nWeb 3.0 아키텍처는 검열에 강하게 설계되어 시각과 표현의 자유를 지킵니다. 탈중앙화된 네트워크와 프로토콜을 통해 어떠한 단일 엔티티도 콘텐츠를 통제하거나 검열하는 것이 어렵게 되어, 정보가 모든 이에게 접근 가능하도록 보장됩니다.\n\n다음은 IPFS Helia를 사용한 간단한 TypeScript 예제로, 탈중앙화된 저장소가 검열에 대항하는 데 어떻게 기여할 수 있는지 보여줍니다:\n\n```js\n// IPFS Helia 불러오기\nimport IPFSHelia from 'ipfs-helia';\n\n// IPFS Helia 노드에 연결하기 ('localhost'를 IPFS Helia 노드 주소로 대체)\nconst ipfsHelia = new IPFSHelia({ host: 'localhost', port: '5002', protocol: 'http' });\n\n// IPFS Helia에 파일을 업로드하는 함수\nasync function uploadFile(): Promise<string> {\n  try {\n    const fileContent = Buffer.from('Hello, world!', 'utf-8');\n\n    // 파일을 IPFS Helia에 업로드\n    const result = await ipfsHelia.add(fileContent);\n    const ipfsHash = result.cid.toString();\n\n    console.log('해시 값으로 IPFS Helia에 파일 업로드 완료:', ipfsHash);\n    return ipfsHash;\n  } catch (error) {\n    console.error('IPFS Helia에 파일을 업로드하는 중 오류 발생:', error);\n    throw error;\n  }\n}\n\n// 해시 값을 사용하여 IPFS Helia에서 파일을 검색하는 함수\nasync function retrieveFile(ipfsHash: string): Promise<void> {\n  try {\n    // IPFS Helia에서 파일을 검색\n    const fileBuffer = await ipfsHelia.cat(ipfsHash);\n    const fileContent = fileBuffer.toString();\n\n    console.log('IPFS Helia로부터 검색된 파일 내용:', fileContent);\n  } catch (error) {\n    console.error('IPFS Helia로부터 파일을 검색하는 중 오류 발생:', error);\n  }\n}\n\n// 파일을 IPFS Helia에 업로드\nuploadFile()\n  .then((ipfsHash) => {\n    // IPFS Helia로부터 업로드된 파일 검색\n    retrieveFile(ipfsHash);\n  })\n  .catch((error) => {\n    console.error('오류:', error);\n  });\n```\n\n## 향상된 확장성과 성능\n\n\n\n웹 3.0은 이전 웹의 확장성과 성능 문제에 대응하기 위해 노력합니다. 샤딩, 레이어 2 솔루션 및 개선된 합의 메커니즘과 같은 혁신들은 웹 3.0 플랫폼이 더 높은 거래 및 상호 작용의 부하를 더 효율적으로 처리할 수 있도록 합니다.\n\n## 토큰화와 디지털 자산\n\n웹 3.0은 자산과 서비스를 블록체인 네트워크 상의 디지털 토큰으로 표현하는 토큰화 개념을 소개합니다. 이로써 부분 소유권을 용이하게 만들고 유동성을 향상시키며 새로운 형태의 가치 교환과 통화화를 가능하게 합니다. 다음은 이더리움 블록체인에서 ERC-20 표준을 사용하여 토큰화와 디지털 자산을 설명하는 간단한 예시입니다.\n\n```js\nimport Web3 from 'web3';\nimport { Contract, ContractFactory } from 'ethers';\nimport { ethers } from 'hardhat';\n\n// 이더리움 네트워크에 연결하기 ('http://localhost:8545'를 사용 중인 이더리움 노드 URL로 대체하세요)\nconst web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));\n\n// ERC-20 토큰 컨트랙트 ABI\nconst tokenABI: any[] = [\n  // ERC-20 표준 메소드 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  // 다른 메소드들...\n];\n\n// ERC-20 토큰 컨트랙트를 배포하는 함수\nasync function deployTokenContract(name: string, symbol: string, initialSupply: number): Promise<void> {\n  try {\n    // 서명자 얻기\n    const signer = ethers.provider.getSigner();\n\n    // ERC-20 토큰 컨트랙트 배포\n    const tokenFactory = new ContractFactory(tokenABI, ERC20Token.bytecode, signer);\n    const tokenContract = await tokenFactory.deploy(name, symbol, initialSupply);\n\n    console.log('ERC-20 토큰 컨트랙트 배포됨:', tokenContract.address);\n  } catch (error) {\n    console.error('ERC-20 토큰 컨트랙트 배포 중 오류 발생:', error);\n  }\n}\n\n// deployTokenContract 함수를 호출하여 ERC-20 토큰 컨트랙트를 배포합니다.\ndeployTokenContract('MyToken', 'MTK', 1000000);\n```\n\n\n\n여기까지 도착했다면, 이 글의 제2부를 계속 읽고 싶은 것 같네요. 아래 링크에서 제2부를 확인해보세요. \n\n[https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220](https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220)","ogImage":{"url":"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png"},"coverImage":"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png","tag":["Tech"],"readingTime":13},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png\" alt=\"이미지\"></p>\n<p>웹 3.0의 개념은 2000년대 초반에 나타나기 시작했으며, 웹 2.0의 잠재적인 후속자로 손에 잡히는 관심을 끌었습니다. 그 시작 시기는 정확히 정해져 있지 않지만, \"웹 3.0\"이라는 용어는 2000년대 중반쯤에 기술자들과 사고 선도자들이 인터넷 진화의 다음 단계를 상상하기 시작함에 따라 널리 통용되었습니다.</p>\n<p>웹 3.0은 인터넷 진화의 혁명적인 단계로 생겨나며, 분산된 신뢰성 없는 프레임워크로 전통적인 표준을 깰 준비를 하고 있습니다. 이 개혁적인 패러다임 변화는 중앙화된 권한으로부터 벗어나 개인 이해관계자 간에 권력이 민주화된 시대를 예고하고 있습니다. 블록체인, 분산저장 및 스마트 계약과 같은 최첨단 기술을 활용하여, 웹 3.0은 조직이 운영에서 향상된 보안, 투명성 및 효율성을 추구하는 동력적 제안을 제시하고 있습니다. 이 대대적인 변화는 거래의 모습을 재정립 뿐만 아니라, 점차적으로 디지턀 배경에서 혁신을 받아들여 번영하기 위한 필요성을 강조합니다. 조직이 웹 3.0의 모습을 탐색하는 동안, 그들은 새로운 기회의 가능성을 풀고 산업의 궤도를 형성할 수 있는 변형적인 여정에 나서며, 보다 분산된, 유연한 및 포용적인 생태계로 향하는 전환적인 여정을 시작합니다.</p>\n<h1>웹 2.0의 문제점과 웹 3.0의 발명을 이끈 문제들</h1>\n<p>웹 2.0는 여러 측면에서 혁명적이었지만 몇 가지 문제와 제약도 함께 가져왔습니다. 이 기사에서 몇 가지를 강조하고 싶습니다:</p>\n<h2>권력의 중앙화</h2>\n<p>웹 2.0 플랫폼은 대부분 중앙 집중화되어 있어서 소수의 대형 기업이 사용자 데이터, 콘텐츠 배포, 플랫폼 운영에 상당한 통제력을 갖고 있습니다. 이 중앙 집중화는 검열, 데이터 유출, 그리고 통제된 상업 관행과 같은 문제로 이어질 수 있습니다.</p>\n<h2>프라이버시 부재</h2>\n<p>웹 2.0 기반 애플리케이션은 일반적으로 명확한 동의나 적절한 개인정보 보호 없이도 사용자 데이터를 대상으로 한 광고 및 기타 목적을 위해 방대한 양을 수집합니다. 이러한 프라이버시의 부족은 사용자 신뢰를 약화시키고 데이터 남용과 감시에 대한 우려를 야기할 수 있습니다.</p>\n<h2>상호 운용성 도전</h2>\n<p>현재의 애플리케이션은 종종 재고를 축적하여 사용자가 서로 다른 서비스와 애플리케이션 간의 데이터와 정보를 원할하게 전송하는 것을 어렵게 만듭니다. 이러한 상호 운용성의 부족은 혁신을 억제하고 사용자 선택을 제한하며 새로운 경쟁 업체에 대한 진입 장벽을 만들 수 있습니다.</p>\n<h2>보안 취약점</h2>\n<p>오늘날의 웹 2.0 기반 구현은 때로 보안 취약점과 데이터 유출에 노출될 수 있어서 사용자 정보를 위험에 빠뜨릴 수 있습니다. 데이터의 중앙 집중 저장 및 단일 장애 지점에 의존하면 사이버 공격 및 민감한 정보에 대한 무단 액세스 가능성이 증가합니다.</p>\n<p><img src=\"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_1.png\" alt=\"그림\"></p>\n<h2>이용자 제어의 제한</h2>\n<p>웹 2.0에서 사용자는 자신의 데이터, 신원 및 디지털 자산에 대해 제한된 제어권을 갖고 있습니다. 플랫폼은 종종 서비스 약관을 지시하고 컨텐츠를 검열하거나 액세스를 제한하거나 사용자에게 별다른 대응 기회 없이 계정을 해지할 권한을 갖고 있습니다.</p>\n<h2>수익 모델</h2>\n<p>애플리케이션은 주로 광고 수익과 사용자 데이터 활용을 통해 수익을 창출합니다. 이는 플랫폼이 사용자의 복지보다는 사용자 참여 지표를 우선시하도록 장려하며, 부정한 행위와 관심 조작으로 이어질 수 있습니다.</p>\n<h2>신뢰 문제</h2>\n<p>플랫폼은 불투명한 알고리즘, 편향적인 콘텐츠 관리, 그리고 의사결정 프로세스의 투명성 부족으로 인해 신뢰 문제를 겪을 수 있습니다. 이는 온라인 정보와 상호 작용의 정직성과 신뢰성에 대한 사용자의 신뢰를 약화시킬 수 있습니다.</p>\n<h1>웹 3.0의 핵심 원칙</h1>\n<p><img src=\"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_2.png\" alt=\"이미지\"></p>\n<h2>분산화</h2>\n<p>웹 3.0은 통제를 분산화하고 중앙 당국 또는 중개인에 의존성을 제거하려고 합니다. 소수 기업이나 개체의 손에 집중시키는 대신 사용자 네트워크 사이에서 권력을 분산시켜 더 견고하고 포용적이며 검열 방지혁 인터넷 생태계를 만들려고 합니다. 이더리움 블록체인에 배포된 탈중앙화 애플리케이션(DApp)과 상호 작용하기 위해 web3.js 라이브러리를 사용하는 다음 예제를 확인해보세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Web3.js 라이브러리를 가져옵니다</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Web3</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'web3'</span>;\n\n<span class=\"hljs-comment\">// 이더리움 네트워크에 연결합니다 ('http://localhost:8545'를 자신의 이더리움 노드 URL로 바꿉니다)</span>\n<span class=\"hljs-keyword\">const</span> web3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Web3</span>(<span class=\"hljs-string\">'http://localhost:8545'</span>);\n\n<span class=\"hljs-comment\">// 스마트 계약의 주소와 ABI (Application Binary Interface)를 정의합니다</span>\n<span class=\"hljs-keyword\">const</span> contractAddress = <span class=\"hljs-string\">'0x1234567890123456789012345678901234567890'</span>; <span class=\"hljs-comment\">// 귀하의 계약 주소로 대체합니다</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">contractABI</span>: any[] = [\n  <span class=\"hljs-comment\">// 귀하의 스마트 계약 메서드의 ABI</span>\n  {\n    <span class=\"hljs-string\">\"constant\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">\"inputs\"</span>: [],\n    <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"getData\"</span>,\n    <span class=\"hljs-string\">\"outputs\"</span>: [\n      {\n        <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"\"</span>,\n        <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"uint256\"</span>\n      }\n    ],\n    <span class=\"hljs-string\">\"payable\"</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-string\">\"stateMutability\"</span>: <span class=\"hljs-string\">\"view\"</span>,\n    <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"function\"</span>\n  }\n];\n\n<span class=\"hljs-comment\">// 계약 인스턴스를 생성합니다</span>\n<span class=\"hljs-keyword\">const</span> contract = <span class=\"hljs-keyword\">new</span> web3.<span class=\"hljs-property\">eth</span>.<span class=\"hljs-title class_\">Contract</span>(contractABI, contractAddress);\n\n<span class=\"hljs-comment\">// 스마트 계약에서 데이터를 가져오는 함수</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 스마트 계약의 getData 함수 호출</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">data</span>: number = <span class=\"hljs-keyword\">await</span> contract.<span class=\"hljs-property\">methods</span>.<span class=\"hljs-title function_\">getData</span>().<span class=\"hljs-title function_\">call</span>();\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'스마트 계약에서 검색된 데이터:'</span>, data);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'데이터를 가져오는 중 오류 발생:'</span>, error);\n  }\n}\n\n<span class=\"hljs-comment\">// fetchData 함수 호출합니다</span>\n<span class=\"hljs-title function_\">fetchData</span>();\n</code></pre>\n<h2>상호 운용성</h2>\n<p>웹 3.0의 개념은 서로 다른 플랫폼, 응용 프로그램 및 프로토콜간의 상호 운용성을 촉진합니다. 이는 다양한 생태계 간의 원활한 데이터 교환과 협력을 가능케 하며, 혁신을 촉진하고 사용자가 사일로된 데이터나 닫힌 시스템으로 제약받지 않고 웹을 더 유연하게 탐색할 수 있도록 합니다.</p>\n<p>다음은 서로 다른 네트워크에 배포된 두 개의 이더리움 기반 스마트 계약 간의 상호 운용성을 보여주는 TypeScript의 기본 예제입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Web3.js 라이브러리를 가져와서 사용합니다</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Web3</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'web3'</span>;\n\n<span class=\"hljs-comment\">// 이더리움 네트워크에 연결합니다 (이더리움 노드 URL과 네트워크 ID를 교체해주세요)</span>\n<span class=\"hljs-keyword\">const</span> web3NetworkA = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Web3</span>(<span class=\"hljs-string\">'http://networkA:8545'</span>);\n<span class=\"hljs-keyword\">const</span> web3NetworkB = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Web3</span>(<span class=\"hljs-string\">'http://networkB:8545'</span>);\n\n<span class=\"hljs-comment\">// 네트워크 A에 배포된 첫 번째 스마트 계약의 주소와 ABI를 정의합니다</span>\n<span class=\"hljs-keyword\">const</span> contractAddressA = <span class=\"hljs-string\">'0x1234567890123456789012345678901234567890'</span>; <span class=\"hljs-comment\">// 네트워크 A의 계약 주소로 교체해주세요</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">contractABIA</span>: any[] = [\n  <span class=\"hljs-comment\">// 네트워크 A에 배포된 스마트 계약의 ABI</span>\n  <span class=\"hljs-comment\">// 네트워크 A의 계약과 상호작용할 메서드를 정의합니다</span>\n];\n\n<span class=\"hljs-comment\">// 네트워크 B에 배포된 두 번째 스마트 계약의 주소와 ABI를 정의합니다</span>\n<span class=\"hljs-keyword\">const</span> contractAddressB = <span class=\"hljs-string\">'0x0987654321098765432109876543210987654321'</span>; <span class=\"hljs-comment\">// 네트워크 B의 계약 주소로 교체해주세요</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">contractABIB</span>: any[] = [\n  <span class=\"hljs-comment\">// 네트워크 B에 배포된 스마트 계약의 ABI</span>\n  <span class=\"hljs-comment\">// 네트워크 B의 계약과 상호작용할 메서드를 정의합니다</span>\n];\n\n<span class=\"hljs-comment\">// 두 계약의 인스턴스를 생성합니다</span>\n<span class=\"hljs-keyword\">const</span> contractA = <span class=\"hljs-keyword\">new</span> web3NetworkA.<span class=\"hljs-property\">eth</span>.<span class=\"hljs-title class_\">Contract</span>(contractABIA, contractAddressA);\n<span class=\"hljs-keyword\">const</span> contractB = <span class=\"hljs-keyword\">new</span> web3NetworkB.<span class=\"hljs-property\">eth</span>.<span class=\"hljs-title class_\">Contract</span>(contractABIB, contractAddressB);\n\n<span class=\"hljs-comment\">// 두 계약 간 데이터 전송하는 함수를 정의합니다</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">transferData</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 계약 A에서 데이터를 검색하는 메서드 호출</span>\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> contractA.<span class=\"hljs-property\">methods</span>.<span class=\"hljs-title function_\">getData</span>().<span class=\"hljs-title function_\">call</span>();\n\n    <span class=\"hljs-comment\">// 계약 B에서 데이터를 설정하는 메서드 호출</span>\n    <span class=\"hljs-keyword\">await</span> contractB.<span class=\"hljs-property\">methods</span>.<span class=\"hljs-title function_\">setData</span>(data).<span class=\"hljs-title function_\">send</span>({ <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">'0x당신의주소'</span>, <span class=\"hljs-attr\">gas</span>: <span class=\"hljs-number\">500000</span> });\n    \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'계약 A에서 계약 B로 데이터 전송 성공:'</span>, data);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'데이터 전송 중 오류 발생:'</span>, error);\n  }\n}\n\n<span class=\"hljs-comment\">// 상호운용성을 보여주기 위해 transferData 함수 호출</span>\n<span class=\"hljs-title function_\">transferData</span>();\n</code></pre>\n<h2>개인정보</h2>\n<p>개인정보 보호는 Web 3.0의 핵심 원칙으로, 사용자가 개인 데이터를 제어하고 소유하는 것을 강조합니다. 사용자 데이터가 수집되고 이익을 위해 활용되며 침해를 받는 Web 2.0과는 달리, Web 3.0은 사용자의 개인 정보를 보호하는 메커니즘을 우선시합니다. 이는 분산 저장, 암호화, 자기 주권 식별 솔루션 등을 포함합니다.</p>\n<p>다음은 TypeScript를 사용한 간단한 예제로, 암호 기술과 분산 인증 메커니즘을 활용하여 사용자의 개인 정보 보호를 강화하는 웹3-react 라이브러리를 이용한 탈중앙화 애플리케이션(DApp)과 상호 작용하는 방법을 보여줍니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { ethers } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'ethers'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Web3Provider</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ethersproject/providers'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">InjectedConnector</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@web3-react/injected-connector'</span>;\n<span class=\"hljs-keyword\">import</span> { useWeb3React } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@web3-react/core'</span>;\n\n<span class=\"hljs-comment\">// 주입된 커넥터를 초기화합니다.</span>\n<span class=\"hljs-keyword\">const</span> injectedConnector = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InjectedConnector</span>({ <span class=\"hljs-attr\">supportedChainIds</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">42</span>] });\n\n<span class=\"hljs-comment\">// 이더리움 프로바이더를 초기화합니다.</span>\n<span class=\"hljs-keyword\">const</span> provider = <span class=\"hljs-keyword\">new</span> ethers.<span class=\"hljs-property\">providers</span>.<span class=\"hljs-title class_\">Web3Provider</span>(<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">ethereum</span>);\n\n<span class=\"hljs-comment\">// 계정 세부 정보를 가져오는 함수</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchAccountDetails</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 사용자의 이더리움 계정에 접근 권한을 요청합니다.</span>\n    <span class=\"hljs-keyword\">await</span> provider.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">'eth_requestAccounts'</span>, []);\n\n    <span class=\"hljs-comment\">// 서명자를 가져옵니다.</span>\n    <span class=\"hljs-keyword\">const</span> signer = provider.<span class=\"hljs-title function_\">getSigner</span>();\n\n    <span class=\"hljs-comment\">// 사용자의 이더리움 주소를 가져옵니다.</span>\n    <span class=\"hljs-keyword\">const</span> address = <span class=\"hljs-keyword\">await</span> signer.<span class=\"hljs-title function_\">getAddress</span>();\n\n    <span class=\"hljs-comment\">// 주소 출력</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'사용자 주소:'</span>, address);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'계정 세부 정보 가져오기 오류:'</span>, error);\n  }\n}\n\n<span class=\"hljs-comment\">// 주요 함수</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>> {\n  <span class=\"hljs-comment\">// 계정 세부 정보 가져오기</span>\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetchAccountDetails</span>();\n}\n\n<span class=\"hljs-comment\">// 주요 함수 실행</span>\n<span class=\"hljs-title function_\">main</span>();\n</code></pre>\n<h2>사용자 권한 부여</h2>\n<p>또한 사용자에게 온라인 경험, 아이덴티티 및 디지털 자산에 대한 더 큰 통제력을 제공하여 사용자들을 권한 부여하는 것을 목표로 합니다. Web 3.0에서 탈중앙화된 거버넌스, 자체 실행 스마트 계약 및 토큰화와 같은 기능을 통해 사용자들은 의사 결정 과정에 더 적극적으로 참여하고 새로운 경제적 기회에 접근하며 디지털 삶 소유권을 주장할 수 있습니다.</p>\n<p>TypeScript를 사용한 Web 3.0에서 사용자 권한 부여를 보여주는 간단한 예제로 탈중앙화된 아이덴티티(DID) 솔루션을 사용합니다. 이 예제에서는 이더리움에서 탈중앙화된 아이덴티티 관리의 인기 있는 선택인 uPort 라이브러리를 사용할 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Connect</span>, <span class=\"hljs-title class_\">SimpleSigner</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'uport-connect'</span>;\n\n<span class=\"hljs-comment\">// uPort 인스턴스 생성</span>\n<span class=\"hljs-keyword\">const</span> uport = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Connect</span>(<span class=\"hljs-string\">'당신의앱이름'</span>, {\n  <span class=\"hljs-attr\">clientId</span>: <span class=\"hljs-string\">'당신의클라이언트아이디'</span>, <span class=\"hljs-comment\">// 여러분의 uPort 클라이언트 ID로 대체해주세요</span>\n  <span class=\"hljs-attr\">signer</span>: <span class=\"hljs-title class_\">SimpleSigner</span>(<span class=\"hljs-string\">'당신의개인키'</span>) <span class=\"hljs-comment\">// 여러분의 개인 키로 대체해주세요</span>\n});\n\n<span class=\"hljs-comment\">// 사용자를 위한 탈중앙화 식별자(DID) 생성하는 함수</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createDID</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 사용자에게 탈중앙화 식별자를 만들기 위한 동의를 요청함</span>\n    <span class=\"hljs-keyword\">const</span> credentials = <span class=\"hljs-keyword\">await</span> uport.<span class=\"hljs-title function_\">requestCredentials</span>({\n      <span class=\"hljs-attr\">requested</span>: [<span class=\"hljs-string\">'name'</span>, <span class=\"hljs-string\">'avatar'</span>], <span class=\"hljs-comment\">// 요청된 사용자 속성</span>\n      <span class=\"hljs-attr\">notifications</span>: <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// 크리덴셜 요청을 위한 푸시 알림 활성화</span>\n    });\n\n    <span class=\"hljs-comment\">// 사용자의 탈중앙화 식별자를 기록함</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'탈중앙화 식별자(DID):'</span>, credentials);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'탈중앙화 식별자 생성 중 오류 발생:'</span>, error);\n  }\n}\n\n<span class=\"hljs-comment\">// 사용자를 위해 탈중앙화 식별자를 만들기 위해 createDID 함수 호출</span>\n<span class=\"hljs-title function_\">createDID</span>();\n</code></pre>\n<h1>웹 3.0에 대해 더 알아보기</h1>\n<p>위의 기사에서 몇 가지 용어를 언급했는데, 분명 일부 용어가 블록체인과 관련이 있다는 걸 알아챘을 거예요. 그래서 우리는 블록체인이 웹 3.0을 위한 기술적 기반으로 작용한다고 할 수 있어요. 이제 웹 3.0 관련 용어 몇 가지 더 살펴봅시다.</p>\n<h2>탈중앙화 애플리케이션 (DApp)</h2>\n<p>분산 애플리케이션(DApp)은 블록체인 기술을 활용하는 분산 네트워크에서 작동하는 소프트웨어 응용 프로그램 유형입니다. 일반적으로 중앙화된 서버에 호스팅되고 단일 엔티티에 의해 제어되는 전통적인 애플리케이션과는 달리, DApp은 컴퓨터(노드)들의 동등 네트워크에서 실행되며 데이터와 작업이 네트워크 상으로 분산됩니다. DApp의 주요 특징으로는 분산화, 오픈 소스, 토큰화, 스마트 계약, 변경할 수 없는 데이터와 상호 운용성이 있습니다.</p>\n<p><img src=\"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_3.png\" alt=\"이미지\"></p>\n<p>분산화 응용 프로그램의 몇 가지 예시로는 분산 재무(DeFi) 플랫폼, 분산 거래소 (DEX), 블록체인 기반 게임, 소셜 네트워크 및 공급망 관리 시스템 등이 있습니다.</p>\n<h2>스마트 계약 및 ABI</h2>\n<p>스마트 계약은 합의 조건이 직접 코드로 작성된 자체 실행 계약입니다. 이러한 계약은 이더리움과 같은 블록체인 네트워크에 저장되고 실행되며 중개인 없이 당사자 간의 합의 조건을 자동으로 시행합니다. 스마트 계약의 주요 특징으로는 자치성, 신뢰 없음, 보안, 투명성, 효율성 및 분산화가 있습니다.</p>\n<p>위 예제에서 스마트 계약인 다음 코드를 주목했을 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">contractABI</span>: any[] = [\n  <span class=\"hljs-comment\">// 스마트 계약 메서드의 ABI</span>\n  {\n    <span class=\"hljs-string\">\"constant\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">\"inputs\"</span>: [],\n    <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"getData\"</span>,\n    <span class=\"hljs-string\">\"outputs\"</span>: [\n      {\n        <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"\"</span>,\n        <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"uint256\"</span>\n      }\n    ],\n    <span class=\"hljs-string\">\"payable\"</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-string\">\"stateMutability\"</span>: <span class=\"hljs-string\">\"view\"</span>,\n    <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"function\"</span>\n  }\n];\n</code></pre>\n<p><img src=\"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_4.png\" alt=\"이미지\"></p>\n<p>ABI는 \"Application Binary Interface\"의 약자입니다. ABI는 이더리움 블록체인에 배포된 스마트 계약의 인터페이스를 JSON으로 나타낸 것입니다. 스마트 계약의 메서드와 속성을 정의하며, 해당 메서드와 속성의 이름, 매개변수, 반환 유형 및 가시성을 포함합니다.</p>\n<p>ABI는 탈중앙화된 응용프로그램(DApps)이나 스크립트와 같은 외부 응용프로그램에서 스마트 계약과 상호작용하는 데 중요합니다. ABI는 이더리움 가상 머신(EVM)과 외부 응용프로그램 사이의 다리 역할을 하며, 배포된 스마트 계약에서 함수를 호출하고 상호작용할 수 있게 합니다.</p>\n<p>API와는 다른 ABI에 대한 내용을 자세히 다룬 좋은 기사가 있습니다.</p>\n<h2>검열 저항력</h2>\n<p>Web 3.0 아키텍처는 검열에 강하게 설계되어 시각과 표현의 자유를 지킵니다. 탈중앙화된 네트워크와 프로토콜을 통해 어떠한 단일 엔티티도 콘텐츠를 통제하거나 검열하는 것이 어렵게 되어, 정보가 모든 이에게 접근 가능하도록 보장됩니다.</p>\n<p>다음은 IPFS Helia를 사용한 간단한 TypeScript 예제로, 탈중앙화된 저장소가 검열에 대항하는 데 어떻게 기여할 수 있는지 보여줍니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// IPFS Helia 불러오기</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">IPFSHelia</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'ipfs-helia'</span>;\n\n<span class=\"hljs-comment\">// IPFS Helia 노드에 연결하기 ('localhost'를 IPFS Helia 노드 주소로 대체)</span>\n<span class=\"hljs-keyword\">const</span> ipfsHelia = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IPFSHelia</span>({ <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">'localhost'</span>, <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">'5002'</span>, <span class=\"hljs-attr\">protocol</span>: <span class=\"hljs-string\">'http'</span> });\n\n<span class=\"hljs-comment\">// IPFS Helia에 파일을 업로드하는 함수</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">uploadFile</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;string> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> fileContent = <span class=\"hljs-title class_\">Buffer</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-string\">'Hello, world!'</span>, <span class=\"hljs-string\">'utf-8'</span>);\n\n    <span class=\"hljs-comment\">// 파일을 IPFS Helia에 업로드</span>\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> ipfsHelia.<span class=\"hljs-title function_\">add</span>(fileContent);\n    <span class=\"hljs-keyword\">const</span> ipfsHash = result.<span class=\"hljs-property\">cid</span>.<span class=\"hljs-title function_\">toString</span>();\n\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'해시 값으로 IPFS Helia에 파일 업로드 완료:'</span>, ipfsHash);\n    <span class=\"hljs-keyword\">return</span> ipfsHash;\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'IPFS Helia에 파일을 업로드하는 중 오류 발생:'</span>, error);\n    <span class=\"hljs-keyword\">throw</span> error;\n  }\n}\n\n<span class=\"hljs-comment\">// 해시 값을 사용하여 IPFS Helia에서 파일을 검색하는 함수</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">retrieveFile</span>(<span class=\"hljs-params\">ipfsHash: string</span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// IPFS Helia에서 파일을 검색</span>\n    <span class=\"hljs-keyword\">const</span> fileBuffer = <span class=\"hljs-keyword\">await</span> ipfsHelia.<span class=\"hljs-title function_\">cat</span>(ipfsHash);\n    <span class=\"hljs-keyword\">const</span> fileContent = fileBuffer.<span class=\"hljs-title function_\">toString</span>();\n\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'IPFS Helia로부터 검색된 파일 내용:'</span>, fileContent);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'IPFS Helia로부터 파일을 검색하는 중 오류 발생:'</span>, error);\n  }\n}\n\n<span class=\"hljs-comment\">// 파일을 IPFS Helia에 업로드</span>\n<span class=\"hljs-title function_\">uploadFile</span>()\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">ipfsHash</span>) =></span> {\n    <span class=\"hljs-comment\">// IPFS Helia로부터 업로드된 파일 검색</span>\n    <span class=\"hljs-title function_\">retrieveFile</span>(ipfsHash);\n  })\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'오류:'</span>, error);\n  });\n</code></pre>\n<h2>향상된 확장성과 성능</h2>\n<p>웹 3.0은 이전 웹의 확장성과 성능 문제에 대응하기 위해 노력합니다. 샤딩, 레이어 2 솔루션 및 개선된 합의 메커니즘과 같은 혁신들은 웹 3.0 플랫폼이 더 높은 거래 및 상호 작용의 부하를 더 효율적으로 처리할 수 있도록 합니다.</p>\n<h2>토큰화와 디지털 자산</h2>\n<p>웹 3.0은 자산과 서비스를 블록체인 네트워크 상의 디지털 토큰으로 표현하는 토큰화 개념을 소개합니다. 이로써 부분 소유권을 용이하게 만들고 유동성을 향상시키며 새로운 형태의 가치 교환과 통화화를 가능하게 합니다. 다음은 이더리움 블록체인에서 ERC-20 표준을 사용하여 토큰화와 디지털 자산을 설명하는 간단한 예시입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Web3</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'web3'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Contract</span>, <span class=\"hljs-title class_\">ContractFactory</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'ethers'</span>;\n<span class=\"hljs-keyword\">import</span> { ethers } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'hardhat'</span>;\n\n<span class=\"hljs-comment\">// 이더리움 네트워크에 연결하기 ('http://localhost:8545'를 사용 중인 이더리움 노드 URL로 대체하세요)</span>\n<span class=\"hljs-keyword\">const</span> web3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Web3</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Web3</span>.<span class=\"hljs-property\">providers</span>.<span class=\"hljs-title class_\">HttpProvider</span>(<span class=\"hljs-string\">'http://localhost:8545'</span>));\n\n<span class=\"hljs-comment\">// ERC-20 토큰 컨트랙트 ABI</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">tokenABI</span>: any[] = [\n  <span class=\"hljs-comment\">// ERC-20 표준 메소드 ABI</span>\n  {\n    <span class=\"hljs-string\">\"constant\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">\"inputs\"</span>: [],\n    <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"name\"</span>,\n    <span class=\"hljs-string\">\"outputs\"</span>: [\n      {\n        <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"\"</span>,\n        <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>\n      }\n    ],\n    <span class=\"hljs-string\">\"payable\"</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-string\">\"stateMutability\"</span>: <span class=\"hljs-string\">\"view\"</span>,\n    <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"function\"</span>\n  },\n  <span class=\"hljs-comment\">// 다른 메소드들...</span>\n];\n\n<span class=\"hljs-comment\">// ERC-20 토큰 컨트랙트를 배포하는 함수</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">deployTokenContract</span>(<span class=\"hljs-params\">name: string, symbol: string, initialSupply: number</span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 서명자 얻기</span>\n    <span class=\"hljs-keyword\">const</span> signer = ethers.<span class=\"hljs-property\">provider</span>.<span class=\"hljs-title function_\">getSigner</span>();\n\n    <span class=\"hljs-comment\">// ERC-20 토큰 컨트랙트 배포</span>\n    <span class=\"hljs-keyword\">const</span> tokenFactory = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ContractFactory</span>(tokenABI, <span class=\"hljs-title class_\">ERC20Token</span>.<span class=\"hljs-property\">bytecode</span>, signer);\n    <span class=\"hljs-keyword\">const</span> tokenContract = <span class=\"hljs-keyword\">await</span> tokenFactory.<span class=\"hljs-title function_\">deploy</span>(name, symbol, initialSupply);\n\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'ERC-20 토큰 컨트랙트 배포됨:'</span>, tokenContract.<span class=\"hljs-property\">address</span>);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'ERC-20 토큰 컨트랙트 배포 중 오류 발생:'</span>, error);\n  }\n}\n\n<span class=\"hljs-comment\">// deployTokenContract 함수를 호출하여 ERC-20 토큰 컨트랙트를 배포합니다.</span>\n<span class=\"hljs-title function_\">deployTokenContract</span>(<span class=\"hljs-string\">'MyToken'</span>, <span class=\"hljs-string\">'MTK'</span>, <span class=\"hljs-number\">1000000</span>);\n</code></pre>\n<p>여기까지 도착했다면, 이 글의 제2부를 계속 읽고 싶은 것 같네요. 아래 링크에서 제2부를 확인해보세요.</p>\n<p><a href=\"https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220\" rel=\"nofollow\" target=\"_blank\">https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220</a></p>\n</body>\n</html>\n"},"__N_SSG":true}