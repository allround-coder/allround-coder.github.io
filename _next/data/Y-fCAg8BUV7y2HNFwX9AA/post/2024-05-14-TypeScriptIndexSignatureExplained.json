{"pageProps":{"post":{"title":"TypeScript 인덱스 시그니처에 대한 설명","description":"","date":"2024-05-14 12:59","slug":"2024-05-14-TypeScriptIndexSignatureExplained","content":"\n\n<img src=\"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png\" />\n\nTypeScript의 인덱스 시그니처는 객체의 속성이 미리 알려지지 않았지만 속성의 유형이 알려진 경우 동적 데이터 구조를 정의하는 방법을 제공합니다. 이들은 동적 속성 액세스를 허용하며 키의 변수 집합을 가진 객체와 작업할 때 특히 유용합니다.\n\n이 게시물에서는 인덱스 시그니처에 대해 자세히 알아보고, TypeScript에서 사용하는 방법 및 사용 시기에 대해 설명할 것입니다.\n\n## 인덱스 시그니처란 무엇인가요?\n\n\n\n인덱스 시그니처는 대괄호 []와 키에 대한 유형, 콜론 및 해당 값에 대한 유형을 사용하여 정의됩니다. 이를 통해 TypeScript는 객체의 예상 구조를 이해하고 강제할 수 있게 됩니다.\n\n```js\ninterface MyStats {\n  [key: string]: number;\n}\nconst scores: MyStats = {\n  total: 50,\n  average:80\n}\n// 인덱스 시그니처는 유형 제약을 강제합니다\n// 여기서 값은 반드시 숫자여야 합니다\nconst scores2: MyStats = {\n  total: \"50\", // 'string' 유형은 'number' 유형에 할당할 수 없습니다.(2322)\n  average: 80\n}\n```\n\n이 예에서 MyStats는 어떤 문자열 키도 가질 수 있고, 해당 키와 연관된 값은 반드시 숫자형이어야 합니다.\n\n인덱스 시그니처의 구문은 인터페이스나 유형 선언 내에서 [] 표기법을 사용하는 것을 포함합니다. 아래 예시는 인터페이스와 유형에 대한 동일한 인덱스 시그니처를 보여줍니다.\n\n\n\n\n인덱스 시그니처는 다양한 키 유형을 사용할 수 있으며 연관 값 유형은 유효한 TypeScript 유형일 수 있음에 유의하세요.\n\n## 인덱스 시그니처를 명시적 멤버와 섞어 사용하기\n\nTypeScript에서 인덱스 시그니처를 명시적 멤버 선언과 혼합할 수 있습니다. 알려진 및 동적 속성을 조합해야 하는 경우에 유용합니다.\n\n\n\n\n```js\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자;\n  가격: 숫자;\n}\n```\n\n인덱스 시그니처와 명시적 멤버를 섞을 때는 모든 명시적 멤버가 인덱스 시그니처 유형을 준수해야 합니다.\n\n```js\n// 유효하지 않은 경우\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자;\n  가격: 숫자;\n  모델: 문자열; // 오류: '모델' 속성의 '문자열' 유형은 '숫자' 인덱스 유형에 할당할 수 없습니다.\n}\n\n// 유효한 경우\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자 | 문자열;\n  가격: 숫자;\n  모델: 문자열;\n}\n```\n\n## 읽기 전용 인덱스 시그니처\n\n\n\n인덱스 시그니처는 읽기 전용 수정자를 지원합니다. 읽기 전용 수정자를 적용하면 객체 내의 속성이 변경 불가능해집니다.\n\n```js\ninterface Car {\n  readonly [key: string]: boolean;\n}\n\nconst toyota: Car = {hybrid: true, luxury: false};\ntoyota.hybrid = false; //에러: 'Car' 타입의 인덱스 시그니처는 오직 읽기만 허용됩니다.(2542)\n```\n\n위 예시에서 'hybrid' 속성을 수정하려고 하면 오류가 발생합니다. 왜냐하면 인터페이스가 읽기만 허용하기 때문이죠.\n\n## 인덱스 시그니처 사용 방법\n\n\n\n실제로 인덱스 시그니처가 어떻게 사용될 수 있는지에 대한 실제 예시를 살펴봅시다. 여러 기능을 포함하는 웹 애플리케이션을 개발하고 있다고 상상해보세요. 각 기능은 해당하는 설정을 가지고 있으며, 이를 활성화하거나 비활성화할 수도 있습니다.\n\n```js\ninterface FeatureConfig {\n  [feature: string]: {\n    enabled: boolean;\n    settings: Record<string, boolean>;\n  }\n}\n```\n\n이 예시에서는 FeatureConfig라는 인터페이스를 정의합니다. 이 인터페이스는 문자열 타입의 동적 속성 이름을 허용하도록 인덱스 시그니처를 사용하며, 해당 속성과 설정 객체와 연결된 enabled 불리언 속성이 포함되어 있습니다. 동적 기능 이름과 관련된 설정을 나타내는 데 유용합니다. 예를 들어, 다음과 같은 객체에 이 인터페이스를 적용할 수 있습니다.\n\n```js\nconst features: FeatureConfig = {\n  profile: {\n    enabled: true,\n    settings: {\n      showPhoto: true,\n      allowEdit: false,\n    },\n  },\n  notification: {\n    enabled: false,\n    settings: {\n      richText: true,\n      batchMode: true\n    },\n  }\n};\n```\n\n\n\n기능 객체에서는 기능 이름이 달라질 수 있지만, 각 기능의 구조는 일관적으로 유지됩니다. 각 기능은 활성화된 부울 값과 설정 객체가 있어야 합니다.\n\n위 인터페이스에서 기능 이름에 유니언 타입 제약을 적용할 수 있을까요?\n\n만약 애플리케이션에서 사용하는 기능 집합이 알려져 있다면, 문자열 리터럴의 유니언인 FeatureType을 정의할 수 있습니다.\n\n```js\ntype FeatureType = '프로필' | '알림' | '리포팅';\n```\n\n\n\n색인 시그니처 키는 유니언 타입을 지원하지 않지만, 맵드 타입을 사용하여 해결할 수 있습니다.\n\n```js\ntype FeatureConfig2 = {\n  [feature in FeatureType]: {\n    enabled: boolean;\n    settings: Record<string, boolean>;\n  }\n}\n```\n\n[feature in FeatureType]는 유니온 타입 FeatureType(프로필, 알림 및 보고서를 포함)의 각 문자열 리터럴을 반복하는 맵드 타입이며, 각 값을 결과 타입의 속성 이름으로 사용합니다.\n\n다음은 사용 예시입니다:\n\n\n\n```js\nconst allFeatures: FeatureConfig2 = {\n   profile: {\n      enabled: true,\n      settings: {\n         showPhoto: true,\n         allowEdit: false,\n      },\n   },\n   notification: {\n      enabled: false,\n      settings: {\n         richText: true,\n         batchMode: true\n      },\n   },\n   reporting: {\n      enabled: true,\n      settings: {\n         template: false,\n         advanceExport: true\n      },\n   },\n};\n```\n\n모든 기능이 FeatureType에 정의된 모든 기능과 일치해야 합니다.\n\n만약 일부 기능을 허용하려면 색인 서명 유형을 \"?\"를 선택적 플래그로 하는 형태로 수정해야 합니다. 그런 다음, FeatureConfig2 유형을 사용하여 일부 기능만 포함하는 객체를 만들 수 있습니다.\n\n```js\ntype FeatureType = 'profile' | 'notification' | 'reporting';\n\ntype FeatureConfig2 = {\n  [feature in FeatureType]?: {\n    enabled: boolean;\n    settings: Record<string, boolean>;\n  }\n}\n\nconst subsetFeatures: FeatureConfig2 = {\n   profile: {\n      enabled: true,\n      settings: {\n         showPhoto: true,\n         allowEdit: false\n      },\n   }\n};\n```\n\n\n\n## 인덱스 시그니처를 효과적으로 사용하는 방법\n\n일반적으로 사용되는 시나리오에는 다음이 포함됩니다:\n\n- 설정 객체: 위 예제에서 보듯, 인덱스 시그니처는 설정 객체가 동적 키와 관련 값이 있을 수 있는 시나리오에서 뛰어난 성능을 발휘합니다.\n- 데이터 변환: 데이터 변환이나 구문 분석을 다룰 때 인덱스 시그니처는 유용할 수 있습니다. 입력 데이터의 구조가 다양한 경우 유연하게 처리할 수 있습니다.\n- 확장성: 플러그인 아키텍처나 모듈식 시스템과 같이 확장성이 중요한 프로젝트에서는 새 구성 요소를 추가할 때 기존 코드를 수정하지 않고 인덱스 시그니처를 이용할 수 있습니다.\n\n인덱스 시그니처는 강력하지만 남용해서는 안 됩니다. 인덱스 시그니처를 구현하기 전에 데이터 구조를 더 명시적인 인터페이스나 타입 정의로 대체할 수 있는지 고려해야 합니다, 특히 키가 특정 의미를 가질 때입니다.\n\n\n\n다른 고려 사항은 인덱스 시그니처를 엄격하게 테스트하는 것입니다. 이는 동적 구조의 특성이 예기치 못한 문제를 발생시키지 않도록 다양한 키-값 조합을 테스트하여 확인하는 것을 포함합니다.\n\n흔한 실수를 피하고 최선의 방법을 따르면 TypeScript 코드를 더 유연하고 탄력적으로 만드는 데 인덱스 시그니처를 사용할 수 있습니다.\n\n즐거운 프로그래밍 되세요!","ogImage":{"url":"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png"},"coverImage":"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png\">\n<p>TypeScript의 인덱스 시그니처는 객체의 속성이 미리 알려지지 않았지만 속성의 유형이 알려진 경우 동적 데이터 구조를 정의하는 방법을 제공합니다. 이들은 동적 속성 액세스를 허용하며 키의 변수 집합을 가진 객체와 작업할 때 특히 유용합니다.</p>\n<p>이 게시물에서는 인덱스 시그니처에 대해 자세히 알아보고, TypeScript에서 사용하는 방법 및 사용 시기에 대해 설명할 것입니다.</p>\n<h2>인덱스 시그니처란 무엇인가요?</h2>\n<p>인덱스 시그니처는 대괄호 []와 키에 대한 유형, 콜론 및 해당 값에 대한 유형을 사용하여 정의됩니다. 이를 통해 TypeScript는 객체의 예상 구조를 이해하고 강제할 수 있게 됩니다.</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">MyStats</span> {\n  [<span class=\"hljs-attr\">key</span>: string]: number;\n}\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">scores</span>: <span class=\"hljs-title class_\">MyStats</span> = {\n  <span class=\"hljs-attr\">total</span>: <span class=\"hljs-number\">50</span>,\n  <span class=\"hljs-attr\">average</span>:<span class=\"hljs-number\">80</span>\n}\n<span class=\"hljs-comment\">// 인덱스 시그니처는 유형 제약을 강제합니다</span>\n<span class=\"hljs-comment\">// 여기서 값은 반드시 숫자여야 합니다</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">scores2</span>: <span class=\"hljs-title class_\">MyStats</span> = {\n  <span class=\"hljs-attr\">total</span>: <span class=\"hljs-string\">\"50\"</span>, <span class=\"hljs-comment\">// 'string' 유형은 'number' 유형에 할당할 수 없습니다.(2322)</span>\n  <span class=\"hljs-attr\">average</span>: <span class=\"hljs-number\">80</span>\n}\n</code></pre>\n<p>이 예에서 MyStats는 어떤 문자열 키도 가질 수 있고, 해당 키와 연관된 값은 반드시 숫자형이어야 합니다.</p>\n<p>인덱스 시그니처의 구문은 인터페이스나 유형 선언 내에서 [] 표기법을 사용하는 것을 포함합니다. 아래 예시는 인터페이스와 유형에 대한 동일한 인덱스 시그니처를 보여줍니다.</p>\n<p>인덱스 시그니처는 다양한 키 유형을 사용할 수 있으며 연관 값 유형은 유효한 TypeScript 유형일 수 있음에 유의하세요.</p>\n<h2>인덱스 시그니처를 명시적 멤버와 섞어 사용하기</h2>\n<p>TypeScript에서 인덱스 시그니처를 명시적 멤버 선언과 혼합할 수 있습니다. 알려진 및 동적 속성을 조합해야 하는 경우에 유용합니다.</p>\n<pre><code class=\"hljs language-js\">인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자;\n  가격: 숫자;\n}\n</code></pre>\n<p>인덱스 시그니처와 명시적 멤버를 섞을 때는 모든 명시적 멤버가 인덱스 시그니처 유형을 준수해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 유효하지 않은 경우</span>\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자;\n  가격: 숫자;\n  모델: 문자열; <span class=\"hljs-comment\">// 오류: '모델' 속성의 '문자열' 유형은 '숫자' 인덱스 유형에 할당할 수 없습니다.</span>\n}\n\n<span class=\"hljs-comment\">// 유효한 경우</span>\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자 | 문자열;\n  가격: 숫자;\n  모델: 문자열;\n}\n</code></pre>\n<h2>읽기 전용 인덱스 시그니처</h2>\n<p>인덱스 시그니처는 읽기 전용 수정자를 지원합니다. 읽기 전용 수정자를 적용하면 객체 내의 속성이 변경 불가능해집니다.</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">Car</span> {\n  readonly [<span class=\"hljs-attr\">key</span>: string]: boolean;\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">toyota</span>: <span class=\"hljs-title class_\">Car</span> = {<span class=\"hljs-attr\">hybrid</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">luxury</span>: <span class=\"hljs-literal\">false</span>};\ntoyota.<span class=\"hljs-property\">hybrid</span> = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//에러: 'Car' 타입의 인덱스 시그니처는 오직 읽기만 허용됩니다.(2542)</span>\n</code></pre>\n<p>위 예시에서 'hybrid' 속성을 수정하려고 하면 오류가 발생합니다. 왜냐하면 인터페이스가 읽기만 허용하기 때문이죠.</p>\n<h2>인덱스 시그니처 사용 방법</h2>\n<p>실제로 인덱스 시그니처가 어떻게 사용될 수 있는지에 대한 실제 예시를 살펴봅시다. 여러 기능을 포함하는 웹 애플리케이션을 개발하고 있다고 상상해보세요. 각 기능은 해당하는 설정을 가지고 있으며, 이를 활성화하거나 비활성화할 수도 있습니다.</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">FeatureConfig</span> {\n  [<span class=\"hljs-attr\">feature</span>: string]: {\n    <span class=\"hljs-attr\">enabled</span>: boolean;\n    <span class=\"hljs-attr\">settings</span>: <span class=\"hljs-title class_\">Record</span>&#x3C;string, boolean>;\n  }\n}\n</code></pre>\n<p>이 예시에서는 FeatureConfig라는 인터페이스를 정의합니다. 이 인터페이스는 문자열 타입의 동적 속성 이름을 허용하도록 인덱스 시그니처를 사용하며, 해당 속성과 설정 객체와 연결된 enabled 불리언 속성이 포함되어 있습니다. 동적 기능 이름과 관련된 설정을 나타내는 데 유용합니다. 예를 들어, 다음과 같은 객체에 이 인터페이스를 적용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">features</span>: <span class=\"hljs-title class_\">FeatureConfig</span> = {\n  <span class=\"hljs-attr\">profile</span>: {\n    <span class=\"hljs-attr\">enabled</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">settings</span>: {\n      <span class=\"hljs-attr\">showPhoto</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">allowEdit</span>: <span class=\"hljs-literal\">false</span>,\n    },\n  },\n  <span class=\"hljs-attr\">notification</span>: {\n    <span class=\"hljs-attr\">enabled</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">settings</span>: {\n      <span class=\"hljs-attr\">richText</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">batchMode</span>: <span class=\"hljs-literal\">true</span>\n    },\n  }\n};\n</code></pre>\n<p>기능 객체에서는 기능 이름이 달라질 수 있지만, 각 기능의 구조는 일관적으로 유지됩니다. 각 기능은 활성화된 부울 값과 설정 객체가 있어야 합니다.</p>\n<p>위 인터페이스에서 기능 이름에 유니언 타입 제약을 적용할 수 있을까요?</p>\n<p>만약 애플리케이션에서 사용하는 기능 집합이 알려져 있다면, 문자열 리터럴의 유니언인 FeatureType을 정의할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">FeatureType</span> = <span class=\"hljs-string\">'프로필'</span> | <span class=\"hljs-string\">'알림'</span> | <span class=\"hljs-string\">'리포팅'</span>;\n</code></pre>\n<p>색인 시그니처 키는 유니언 타입을 지원하지 않지만, 맵드 타입을 사용하여 해결할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">FeatureConfig2</span> = {\n  [feature <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title class_\">FeatureType</span>]: {\n    <span class=\"hljs-attr\">enabled</span>: boolean;\n    <span class=\"hljs-attr\">settings</span>: <span class=\"hljs-title class_\">Record</span>&#x3C;string, boolean>;\n  }\n}\n</code></pre>\n<p>[feature in FeatureType]는 유니온 타입 FeatureType(프로필, 알림 및 보고서를 포함)의 각 문자열 리터럴을 반복하는 맵드 타입이며, 각 값을 결과 타입의 속성 이름으로 사용합니다.</p>\n<p>다음은 사용 예시입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">allFeatures</span>: <span class=\"hljs-title class_\">FeatureConfig2</span> = {\n   <span class=\"hljs-attr\">profile</span>: {\n      <span class=\"hljs-attr\">enabled</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">settings</span>: {\n         <span class=\"hljs-attr\">showPhoto</span>: <span class=\"hljs-literal\">true</span>,\n         <span class=\"hljs-attr\">allowEdit</span>: <span class=\"hljs-literal\">false</span>,\n      },\n   },\n   <span class=\"hljs-attr\">notification</span>: {\n      <span class=\"hljs-attr\">enabled</span>: <span class=\"hljs-literal\">false</span>,\n      <span class=\"hljs-attr\">settings</span>: {\n         <span class=\"hljs-attr\">richText</span>: <span class=\"hljs-literal\">true</span>,\n         <span class=\"hljs-attr\">batchMode</span>: <span class=\"hljs-literal\">true</span>\n      },\n   },\n   <span class=\"hljs-attr\">reporting</span>: {\n      <span class=\"hljs-attr\">enabled</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">settings</span>: {\n         <span class=\"hljs-attr\">template</span>: <span class=\"hljs-literal\">false</span>,\n         <span class=\"hljs-attr\">advanceExport</span>: <span class=\"hljs-literal\">true</span>\n      },\n   },\n};\n</code></pre>\n<p>모든 기능이 FeatureType에 정의된 모든 기능과 일치해야 합니다.</p>\n<p>만약 일부 기능을 허용하려면 색인 서명 유형을 \"?\"를 선택적 플래그로 하는 형태로 수정해야 합니다. 그런 다음, FeatureConfig2 유형을 사용하여 일부 기능만 포함하는 객체를 만들 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">FeatureType</span> = <span class=\"hljs-string\">'profile'</span> | <span class=\"hljs-string\">'notification'</span> | <span class=\"hljs-string\">'reporting'</span>;\n\ntype <span class=\"hljs-title class_\">FeatureConfig2</span> = {\n  [feature <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title class_\">FeatureType</span>]?: {\n    <span class=\"hljs-attr\">enabled</span>: boolean;\n    <span class=\"hljs-attr\">settings</span>: <span class=\"hljs-title class_\">Record</span>&#x3C;string, boolean>;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">subsetFeatures</span>: <span class=\"hljs-title class_\">FeatureConfig2</span> = {\n   <span class=\"hljs-attr\">profile</span>: {\n      <span class=\"hljs-attr\">enabled</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">settings</span>: {\n         <span class=\"hljs-attr\">showPhoto</span>: <span class=\"hljs-literal\">true</span>,\n         <span class=\"hljs-attr\">allowEdit</span>: <span class=\"hljs-literal\">false</span>\n      },\n   }\n};\n</code></pre>\n<h2>인덱스 시그니처를 효과적으로 사용하는 방법</h2>\n<p>일반적으로 사용되는 시나리오에는 다음이 포함됩니다:</p>\n<ul>\n<li>설정 객체: 위 예제에서 보듯, 인덱스 시그니처는 설정 객체가 동적 키와 관련 값이 있을 수 있는 시나리오에서 뛰어난 성능을 발휘합니다.</li>\n<li>데이터 변환: 데이터 변환이나 구문 분석을 다룰 때 인덱스 시그니처는 유용할 수 있습니다. 입력 데이터의 구조가 다양한 경우 유연하게 처리할 수 있습니다.</li>\n<li>확장성: 플러그인 아키텍처나 모듈식 시스템과 같이 확장성이 중요한 프로젝트에서는 새 구성 요소를 추가할 때 기존 코드를 수정하지 않고 인덱스 시그니처를 이용할 수 있습니다.</li>\n</ul>\n<p>인덱스 시그니처는 강력하지만 남용해서는 안 됩니다. 인덱스 시그니처를 구현하기 전에 데이터 구조를 더 명시적인 인터페이스나 타입 정의로 대체할 수 있는지 고려해야 합니다, 특히 키가 특정 의미를 가질 때입니다.</p>\n<p>다른 고려 사항은 인덱스 시그니처를 엄격하게 테스트하는 것입니다. 이는 동적 구조의 특성이 예기치 못한 문제를 발생시키지 않도록 다양한 키-값 조합을 테스트하여 확인하는 것을 포함합니다.</p>\n<p>흔한 실수를 피하고 최선의 방법을 따르면 TypeScript 코드를 더 유연하고 탄력적으로 만드는 데 인덱스 시그니처를 사용할 수 있습니다.</p>\n<p>즐거운 프로그래밍 되세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}