{"pageProps":{"post":{"title":"Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내","description":"","date":"2024-06-23 13:45","slug":"2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs","content":"\n\n![OptimizingNext.jsdatarefreshAGuidetoRevalidationwithMedusajs_0](/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png)\n\n안녕하세요! 내부 서버를 사용하여 Next.js 애플리케이션에서 다시 유효성을 설정하는 가이드에 오신 것을 환영합니다. 이 자습서에서는 다양한 다시 유효성 유형을 탐색하고 그들의 보안을 향상하는 방법을 살펴볼 것입니다.\n\n# 왜 다시 유효성 검사가 중요한가요?\n\n다시 유효성 검사는 매 요청마다 소스에서 데이터를 가져오는 것을 피하고 웹 응용 프로그램의 성능을 향상시키기 위해 중요합니다. 기본적으로 Next.js는 fetch를 사용하여 요청을 캐시하며, POST 요청도 포함됩니다. 다시 유효성 검사를 하지 않거나 데이터 캐시를 선택적으로 사용하지 않는 경우, 애플리케이션이 사실상 정적으로 변할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n### 재확인의 두 가지 유형:\n\n- 시간 기반 재확인\n- 요청에 따른 재확인\n\n### 1. 시간 기반 재확인\n\n시간 기반 재확인은 Next.js 애플리케이션의 데이터에 대한 캐시 유효 기간을 설정하는 간단한 방법입니다. 밀리초(millisecond)로 간격을 지정함으로써 데이터가 캐시에서 유효한 기간을 정의할 수 있습니다. 다음은 이를 구현하는 방법입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfetch('https://example.pl/api/products', { next: { revalidate: 3600 } })\n```\n\n이 예제에서 revalidate 옵션이 3600초(1시간)로 설정되어 있습니다. 이는 지정된 API 엔드포인트에서 가져온 데이터가 최대 1시간 동안 신선하다고 간주됨을 의미합니다. 이 기간이 지나면 데이터를 새로 고칠 요청이 이루어집니다.\n\n대안으로 페이지나 구성 요소 파일 자체에서 revalidate 속성을 사용할 수도 있습니다:\n\n```js\n// app/products/page.tsx\n\nexport const revalidate = 3600 // 최대 1시간마다 재검증\n```\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식은 캐시를 주기적으로 업데이트하고 애플리케이션이 지속적인 요청으로 서버를 과부하시키지 않고 최신 데이터를 제공하는 데 특히 유용합니다.\n\n## 2. 요청에 의한 재유효화\n\n요청에 의한 재유효화는 필요할 때만 데이터를 새로 고쳐야 하는 유연성을 제공하며, 이를 캐시 태그나 서버 액션 또는 라우트 핸들러 내에서 특정 경로를 사용하여 달성할 수 있습니다. 아래는 설정 방법입니다:\n\n```js\nexport default async function Page() {\n  const res = await fetch(\n    'https://example.pl/api/products', \n    { next: { tags: ['products'] } } // 이 부분이 마법이 일어나는 곳입니다\n  ) \n  const data = await res.json()\n\n  return (\n  ...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드를 한국어로 번역하면 다음과 같습니다.\n\nNext.js에서 라우트 핸들러를 만들어보겠습니다\n\n```js\n// app/api/revalidate/[tag]/route.ts\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n) {\n  const tag = params.tag\n\n  revalidateTag(tag);\n\n  return NextResponse.json({ revalidated: tag });\n}\n```\n\n이 라우트에 접근할 때 URL http://localhost:3000/api/revalidate/products를 사용하면 캐시를 삭제하고 최신 데이터로 다시 가져옵니다.\n\n내부 서버에서 다시 유효성을 검증하는 방법\n\n<div class=\"content-ad\"></div>\n\n우리의 라우트 핸들러를 개선하여 쿼리 매개변수에 비밀 키를 포함시키는 것이 좋겠어요. 이렇게 하면 권한이 있는 사용자만 재확인 프로세스를 수동으로 트리거할 수 있습니다.\n\n```js\n// app/api/revalidate/[tag]/route.ts\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n) {\n  const tag = params.tag\n  // 검색 매개변수에서 비밀 키 가져오기\n  const secret = request.nextUrl.searchParams.get('secret');\n\n  // 비밀 키 확인\n  if (secret !== process.env.REVALIDATE_SECRET) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  revalidateTag(tag);\n\n  return NextResponse.json({ revalidated: tag });\n}\n```\n\n환경 변수에 REVALIDATE_SECRET도 추가해주세요:\n\n```js\n// .env\nREVALIDATE_SECRET=supersecret_revalidate_key\n```\n\n<div class=\"content-ad\"></div>\n\n이제 Medusa.js를 사용하고 있다고 가정하고 서버로 이동하여 각 제품 업데이트마다 구독자를 구현해 봅시다.\n\n```js\n// src/subscribers/product.ts\nimport axios from \"axios\";\n\nclass ProductSubscriber {\n  constructor({ eventBusService }) {\n    eventBusService.subscribe(\n      \"product.created\",\n      this.revalidateOnDemand\n    );\n    eventBusService.subscribe(\n      \"product.updated\",\n      this.revalidateOnDemand\n    );\n    eventBusService.subscribe(\n      \"product.deleted\",\n      this.revalidateOnDemand\n    );\n  }\n\n  revalidateOnDemand = async () => {\n    await axios.post(process.env.FRONTEND_REVALIDATE_URL/products, {\n      params: {\n        secret: process.env.FRONTEND_REVALIDATE_SECRET\n      },\n    });\n  };\n}\n\nexport default ProductSubscriber;\n```\n\n`.env` 파일에 다음 변수들을 포함시키세요.\n\n```js\n// .env\nREVALIDATE_SECRET=supersecret_revalidate_key\nFRONTEND_REVALIDATE_URL=http://localhost.3000/api/revalidate\n```\n\n<div class=\"content-ad\"></div>\n\n# 마무리\n\n이러한 전략을 활용하여 성능 최적화와 데이터 신선도 사이의 균형을 유지할 수 있습니다. URL 매개변수에 비밀 키를 추가하여 권한이 있는 사용자만 수동 재확인을 트리거할 수 있도록하는 것은 귀하의 애플리케이션의 보안을 강화합니다.\n\n본 문서가 도움이 되었기를 바랍니다.\n\n읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png"},"coverImage":"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png\" alt=\"OptimizingNext.jsdatarefreshAGuidetoRevalidationwithMedusajs_0\"></p>\n<p>안녕하세요! 내부 서버를 사용하여 Next.js 애플리케이션에서 다시 유효성을 설정하는 가이드에 오신 것을 환영합니다. 이 자습서에서는 다양한 다시 유효성 유형을 탐색하고 그들의 보안을 향상하는 방법을 살펴볼 것입니다.</p>\n<h1>왜 다시 유효성 검사가 중요한가요?</h1>\n<p>다시 유효성 검사는 매 요청마다 소스에서 데이터를 가져오는 것을 피하고 웹 응용 프로그램의 성능을 향상시키기 위해 중요합니다. 기본적으로 Next.js는 fetch를 사용하여 요청을 캐시하며, POST 요청도 포함됩니다. 다시 유효성 검사를 하지 않거나 데이터 캐시를 선택적으로 사용하지 않는 경우, 애플리케이션이 사실상 정적으로 변할 것입니다.</p>\n<div class=\"content-ad\"></div>\n<h3>재확인의 두 가지 유형:</h3>\n<ul>\n<li>시간 기반 재확인</li>\n<li>요청에 따른 재확인</li>\n</ul>\n<h3>1. 시간 기반 재확인</h3>\n<p>시간 기반 재확인은 Next.js 애플리케이션의 데이터에 대한 캐시 유효 기간을 설정하는 간단한 방법입니다. 밀리초(millisecond)로 간격을 지정함으로써 데이터가 캐시에서 유효한 기간을 정의할 수 있습니다. 다음은 이를 구현하는 방법입니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://example.pl/api/products'</span>, { <span class=\"hljs-attr\">next</span>: { <span class=\"hljs-attr\">revalidate</span>: <span class=\"hljs-number\">3600</span> } })\n</code></pre>\n<p>이 예제에서 revalidate 옵션이 3600초(1시간)로 설정되어 있습니다. 이는 지정된 API 엔드포인트에서 가져온 데이터가 최대 1시간 동안 신선하다고 간주됨을 의미합니다. 이 기간이 지나면 데이터를 새로 고칠 요청이 이루어집니다.</p>\n<p>대안으로 페이지나 구성 요소 파일 자체에서 revalidate 속성을 사용할 수도 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// app/products/page.tsx</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> revalidate = <span class=\"hljs-number\">3600</span> <span class=\"hljs-comment\">// 최대 1시간마다 재검증</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 접근 방식은 캐시를 주기적으로 업데이트하고 애플리케이션이 지속적인 요청으로 서버를 과부하시키지 않고 최신 데이터를 제공하는 데 특히 유용합니다.</p>\n<h2>2. 요청에 의한 재유효화</h2>\n<p>요청에 의한 재유효화는 필요할 때만 데이터를 새로 고쳐야 하는 유연성을 제공하며, 이를 캐시 태그나 서버 액션 또는 라우트 핸들러 내에서 특정 경로를 사용하여 달성할 수 있습니다. 아래는 설정 방법입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Page</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n    <span class=\"hljs-string\">'https://example.pl/api/products'</span>, \n    { <span class=\"hljs-attr\">next</span>: { <span class=\"hljs-attr\">tags</span>: [<span class=\"hljs-string\">'products'</span>] } } <span class=\"hljs-comment\">// 이 부분이 마법이 일어나는 곳입니다</span>\n  ) \n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> res.<span class=\"hljs-title function_\">json</span>()\n\n  <span class=\"hljs-keyword\">return</span> (\n  ...\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>위의 코드를 한국어로 번역하면 다음과 같습니다.</p>\n<p>Next.js에서 라우트 핸들러를 만들어보겠습니다</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// app/api/revalidate/[tag]/route.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">POST</span>(<span class=\"hljs-params\">\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n</span>) {\n  <span class=\"hljs-keyword\">const</span> tag = params.<span class=\"hljs-property\">tag</span>\n\n  <span class=\"hljs-title function_\">revalidateTag</span>(tag);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">revalidated</span>: tag });\n}\n</code></pre>\n<p>이 라우트에 접근할 때 URL <a href=\"http://localhost:3000/api/revalidate/products%EB%A5%BC\" rel=\"nofollow\" target=\"_blank\">http://localhost:3000/api/revalidate/products를</a> 사용하면 캐시를 삭제하고 최신 데이터로 다시 가져옵니다.</p>\n<p>내부 서버에서 다시 유효성을 검증하는 방법</p>\n<div class=\"content-ad\"></div>\n<p>우리의 라우트 핸들러를 개선하여 쿼리 매개변수에 비밀 키를 포함시키는 것이 좋겠어요. 이렇게 하면 권한이 있는 사용자만 재확인 프로세스를 수동으로 트리거할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// app/api/revalidate/[tag]/route.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">POST</span>(<span class=\"hljs-params\">\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n</span>) {\n  <span class=\"hljs-keyword\">const</span> tag = params.<span class=\"hljs-property\">tag</span>\n  <span class=\"hljs-comment\">// 검색 매개변수에서 비밀 키 가져오기</span>\n  <span class=\"hljs-keyword\">const</span> secret = request.<span class=\"hljs-property\">nextUrl</span>.<span class=\"hljs-property\">searchParams</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'secret'</span>);\n\n  <span class=\"hljs-comment\">// 비밀 키 확인</span>\n  <span class=\"hljs-keyword\">if</span> (secret !== process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">REVALIDATE_SECRET</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">'Unauthorized'</span> }, { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-number\">401</span> })\n  }\n\n  <span class=\"hljs-title function_\">revalidateTag</span>(tag);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">revalidated</span>: tag });\n}\n</code></pre>\n<p>환경 변수에 REVALIDATE_SECRET도 추가해주세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// .env</span>\n<span class=\"hljs-variable constant_\">REVALIDATE_SECRET</span>=supersecret_revalidate_key\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이제 Medusa.js를 사용하고 있다고 가정하고 서버로 이동하여 각 제품 업데이트마다 구독자를 구현해 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/subscribers/product.ts</span>\n<span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"axios\"</span>;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProductSubscriber</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">{ eventBusService }</span>) {\n    eventBusService.<span class=\"hljs-title function_\">subscribe</span>(\n      <span class=\"hljs-string\">\"product.created\"</span>,\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">revalidateOnDemand</span>\n    );\n    eventBusService.<span class=\"hljs-title function_\">subscribe</span>(\n      <span class=\"hljs-string\">\"product.updated\"</span>,\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">revalidateOnDemand</span>\n    );\n    eventBusService.<span class=\"hljs-title function_\">subscribe</span>(\n      <span class=\"hljs-string\">\"product.deleted\"</span>,\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">revalidateOnDemand</span>\n    );\n  }\n\n  revalidateOnDemand = <span class=\"hljs-keyword\">async</span> () => {\n    <span class=\"hljs-keyword\">await</span> axios.<span class=\"hljs-title function_\">post</span>(process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">FRONTEND_REVALIDATE_URL</span>/products, {\n      <span class=\"hljs-attr\">params</span>: {\n        <span class=\"hljs-attr\">secret</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">FRONTEND_REVALIDATE_SECRET</span>\n      },\n    });\n  };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ProductSubscriber</span>;\n</code></pre>\n<p><code>.env</code> 파일에 다음 변수들을 포함시키세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// .env</span>\n<span class=\"hljs-variable constant_\">REVALIDATE_SECRET</span>=supersecret_revalidate_key\n<span class=\"hljs-variable constant_\">FRONTEND_REVALIDATE_URL</span>=<span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//localhost.3000/api/revalidate</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<h1>마무리</h1>\n<p>이러한 전략을 활용하여 성능 최적화와 데이터 신선도 사이의 균형을 유지할 수 있습니다. URL 매개변수에 비밀 키를 추가하여 권한이 있는 사용자만 수동 재확인을 트리거할 수 있도록하는 것은 귀하의 애플리케이션의 보안을 강화합니다.</p>\n<p>본 문서가 도움이 되었기를 바랍니다.</p>\n<p>읽어 주셔서 감사합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}