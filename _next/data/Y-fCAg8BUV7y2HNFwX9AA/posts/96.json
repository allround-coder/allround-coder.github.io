{"pageProps":{"posts":[{"title":"당신의 iOS 앱의 비밀을 보호하는 중요한 단계","description":"","date":"2024-05-15 10:52","slug":"2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets","content":"\n\n암호화와 적절한 솔루션 선택\n\n앱에 하드코딩된 문자열로 저장된 비밀 또는 암호화 키가 있나요? 또는 Info.plist와 같은 파일에 저장되어 있나요?\n\n그렇다면, 그것들은 매우 쉽게 발견될 수 있습니다.\n\n먼저, 우리가 방지하려는 것을 이해하기 위해 공격자가 어떻게 하드코딩된 문자열을 볼 수 있는지 살펴봅시다.\n\n\n\n# 해커가 하드코딩된 문자열을 어떻게 볼 수 있을까요?\n\n당신의 애플리케이션(예: iOS의 경우 IPA 파일)을 정적 분석 도구에 전달하면 그 문자열들이 이렇게 나타날 것입니다:\n\n![이미지](/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png)\n\nInfo.plist 파일에 저장한다면 어떨까요?\n\n\n\n이 방법도 안전하지 않습니다. 파일은 정적 분석기를 통해 쉽게 볼 수 있습니다.\n\n![image](/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_1.png)\n\n## 그래서, 하드코딩된 문자열을 어떻게 보호할까요?\n\n이상적으로는 보안 정보(API 키, 엔드포인트, API 토큰 등 민감한 데이터)는 클라이언트 측에 저장되어서는 안 됩니다. 이는 피해야 할 패턴입니다.\n\n\n\n하지만 거의 모든 앱에는 일부 정보가 저장되어 있고, 당신이 이러한 상황에 처할 수도 있습니다. 이 경우에는 정보가 올바르게 보호되었는지 확인해야 합니다.\n\nAPI 키와 기타 비밀 정보를 간단히 암호화할 수 있을까요?\n\n좋은 시작입니다. 하지만 클라이언트에 암호화 키를 저장해야 하는 경우 어떻게 그것을 안전하게 보호할 수 있을까요?\n\n어떤 정보든 클라이언트에 두는 보안 계층은 100% 안전하지 않다는 것을 강조하고 싶습니다. 그러나 공격자가 이러한 정보를 획득하는 것을 매우 어렵게 만들 수는 있습니다.\n\n\n\n주기적으로 비밀을 업데이트하는 것은 역공학 공격을 무력화시킬 수 있습니다. 정기적인 업데이트로, 역공학자가 시간을 쏟아서 비밀을 얻으려고 노력한 모든 시간이 무익해질 수 있기 때문이죠.\n\n# 코드 난독화\n\n위에서 설명한 것처럼 일반적으로 정보를 업데이트하여 구조를 변경함으로써 역공학 공격을 무력화할 수 있습니다.\n\n난독화는 정보나 코드를 이해하기 어렵게 만드는 행위입니다. 이는 인간뿐만 아니라 컴퓨터도 이해하기 힘들게 만드는 것을 의미합니다.\n\n\n\n추가적인 보안층으로, hardcoded된 비밀을 암호화한 다음 암호화 키를 난독화 하는 것을 권장합니다. 이렇게 하면 모든 비밀을 난독화 해야 하는 대신 암호화 키만 난독화하면 되므로 알고리즘에 따라 발생할 수 있는 성능 오버헤드를 피할 수 있습니다.\n\niOS를 사용 중이라면 Apple의 CryptoKit을 사용하는 것을 추천하며, AES와 같은 강력한 산업 표준 알고리즘을 선택하는 것이 좋습니다.\n\n# 결과\n\n비밀 hardcoded된 문자열을 난독화한 후 정적 분석기가 그들을 직접적으로 사용할 수 없는 변형 형태로 캐치할 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_2.png\" />\n\n# 당신의 난독화 솔루션을 선택하기\n\n어떤 난독화 라이브러리를 선택해야 할까요?\n\n비록 당신이 선택한 어떤 난독화 알고리즘이라도 단순히 앱 내에 하드코딩된 보안 정보를 그대로 둘 것보다 낫다는 것은 사실이지만, 해독자에게 더 어렵게 만드는 솔루션도 있습니다.\n\n\n\n# 찾아야 할 난독화 기술\n\n비밀 정보를 안전하게 유지하기 위해 난독화 라이브러리를 찾고 있다면 다음의 기본 아이디어를 살펴보세요.\n\n1. 데이터 변환\n\n비밀 정보 숨김에 관련된 코드 난독화의 중요한 요소는 데이터(문자열)를 다른 형태로 변환하는 것입니다. 이는 코드의 성능에 미치는 영향을 최소화하면서도 해커들이 이해하기 어렵게 만들어야 합니다.\n\n\n\n이것은 하드코딩된 문자열을 특히 난독화하는 솔루션이 필요하다는 것을 의미합니다 (또는 문자열을 매개변수로 사용할 수 있는 것), 애플리케이션의 클래스 이름 및 소스 코드를 난독화하려는 것이 아니라는 것을 명심해주세요. 왜냐하면 그것은 다른 목적을 위한 것이기 때문입니다.\n\n데이터 변환은 문자열 암호화, 키 분할, 사용자 지정 인코딩 등 다양한 형태를 가질 수 있습니다.\n\n다중 레이어\n\n난독화 알고리즘이 여러 변환을 수행하면 스크립트에 덜 취약할 가능성이 높으며, 따라서 데이터를 이해하려는 시도가 더 시간이 걸릴 수 있으며 코드를 다시 난독화하려면 수동 개입 (동적 분석)이 필요할 수도 있습니다.\n\n\n\n# 결론\n\n요약하자면, 자동화된 스크립트에 취약하지 않은 알고리즘을 찾는 것이 이상적입니다. 공격자가 키를 복호화하는 것을 어렵게 만들어야 하며, 시간이 많이 걸리는 기술을 사용해 애플리케이션을 공격자에겐 덜 유혹적으로 만들어야 합니다.\n\n또한 비밀 정보의 중요성을 고려하고, API 키를 숨기는 경우에는 API 키 사용을 제한하는 등의 회전하는 보안 방법을 고려해야 합니다.\n\n원하는 보안 수준에 따라 소유권 기반의 난독화 솔루션을 선택할 수도 있습니다. 이러한 솔루션의 장점 중 하나는 비공개로 유지되어 자동화 스크립트에 취약할 가능성이 낮다는 것입니다.\n\n\n\n# iOS 개인 추천 사항\n\n이 추천 사항은 작성 시점에 작성되었음을 유의해 주세요.\n\n다음은 이러한 아이디어를 일부 이용한 라이브러리 목록입니다:\n\n- Swift confidentials — https://github.com/securevale/swift-confidential\n- ObfuscateMacro — https://github.com/p-x9/ObfuscateMacro\n\n\n\n이 기사는 iOS에 초점을 맞추었지만 일반적인 원칙은 모든 클라이언트 측 코드에 적용할 수 있습니다.\n\n사용하는 난독화 알고리즘은 앞으로 다룰 다른 보호층과 함께 사용해야 합니다.\n\n애플리케이션을 더 안전하게 만드는 방법에 대해 더 많은 통찰력을 얻고 싶으신가요?\n\n향후 게시물을 최신 상태로 유지하려면 아래 무료 뉴스레터를 구독해주세요:\n\n\n\nhttps://substack.com/@alexlotsu?utm_source=profile-page","ogImage":{"url":"/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png"},"coverImage":"/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터 322에서 새로운 기능을 소개합니다","description":"","date":"2024-05-15 10:49","slug":"2024-05-15-WhatsnewinFlutter322","content":"\n\n안녕하세요! 새로운 Flutter 안정 버전으로 다시 돌아왔습니다! 이번에는 Flutter 3.22를 소개해 드리게 되어 매우 기쁘게 생각합니다. 안정 채널에 WebAssembly를 도입하고, Android에서 Impeller용으로 완전히 강화된 Vulkan 백엔드를 제공하여 그래픽이 좀 더 부드럽고 성능이 크게 향상되었습니다. 또한, 새로운 위젯 상태 속성, 동적 뷰 크기 조정, 개선된 폼 유효성 검사를 통해 간편화된 작업 흐름을 소개하고 있습니다. 그 외에도, 플레이버 조건부 자산 번들링, Dart에서 Firebase의 Vertex AI 미리보기, 개선된 DevTools 등 다양한 업데이트가 있어 여러분의 개발 생활을 더욱 편리하게 만들어 줄 것입니다.\n\n지난 업데이트 이후 몇 달 만에, Flutter 커뮤니티로부터 인상적인 1595개의 풀 리퀘스트가 병합되었으며, 37명의 새로운 커뮤니티 멤버가 처음으로 Flutter에 기여했습니다!\n\n그래서 지금 바로 확인해 보세요. Flutter 커뮤니티가 이번 최신 릴리스에 기여한 모든 새로운 기능과 개선 사항을 발견해 보세요!\n\n\n# WebAssembly\n\n\n\n\n플러터 3.22가 출시되었습니다. Wasm은 이제 안정 채널에서 사용할 수 있어서 상당한 성능 향상을 제공합니다. 저희는 M1 맥북에서 Chrome을 사용하여 내부 벤치마크를 수행한 결과, Wonderous 앱의 프레임 렌더링 시간이 평균 2배 이상, 최악의 경우에는 3배까지 개선되었습니다.\n\n![이미지](/assets/img/2024-05-15-WhatsnewinFlutter322_0.png)\n\n이러한 향상 사항은 애니메이션과 풍부한 전환 효과가 있는 앱에 중요하며, 부드러운 프레임 속도를 유지하는 데 필수적입니다. Wasm은 성능 병목 현상을 줄이고, 이로 인해 부드러운 애니메이션과 전환 효과를 구현하는 데 도움이 됩니다. 플러터 웹 앱에서 Wasm을 사용하려면 Dart Wasm 문서와 Flutter Wasm 문서를 확인해보세요. 자세한 내용은 Google I/O 블로그의 Flutter 공지를 참조하세요.\n\n# 엔진\n\n\n\nFlutter 3.22에서는 Flutter 애플리케이션을 구동하는 렌더링 엔진 Impeller에 중요한 업데이트가 있습니다. 주요 업데이트 내용으로는 안드로이드에서 Vulkan 백엔드가 완료되어 그래픽이 더 부드럽고 성능이 향상되었으며, 흐릿한 효과 및 복잡한 경로 렌더링을 위한 계속되는 최적화와 Impeller를 테스트하기 위한 새로운 실험적 API가 포함됩니다. 저희의 로드맵에 따라 Impeller의 품질과 성능을 향상시키기 위해 iOS 이주를 완료하고 Android 지원을 확대하는 것을 포함하여 노력할 것입니다.\n\n## Impeller\n\n## Vulkan 백엔드 안드로이드에서 기능 완료\n\n이 릴리스에서 Impeller의 안드로이드용 Vulkan 백엔드가 기능 완료되었습니다. 특히 이전 몇 달 동안 팀은 빠른 고급 블렌드의 구현, FragmentProgram API를 사용한 사용자 지정 프래그먼트 쉐이더 지원, PlatformView 지원 (다소 API 이주가 필요함) 및 모든 흐림 스타일을 완전히 구현하는 데 열심히 일했습니다.\n\n\n\n## 안드로이드 미리보기\n\n3.19 안정 버전에서는 Impeller의 OpenGL 백엔드 개선을 통해 안드로이드 기기에서 Vulkan 지원 유무에 상관없이 Impeller를 시도해 볼 수 있도록 사용자를 초대했습니다. 지난 몇 달 동안 OpenGL 백엔드의 성능을 평가하고 Vulkan 백엔드의 남은 작업을 추정한 결과, Vulkan 백엔드를 먼저 제품으로 출시할 것으로 결정했습니다.\n\nImpeller는 셰이더 컴파일레이션 지연 문제를 해결합니다. 또한 벤치마크 결과, 평균적으로 레거시 렌더러보다 90백분위 및 99백분위 프레임 시간에서 더 뛰어난 성능을 보여줍니다. 따라서 안드로이드에서의 Vulkan 백엔드 성능은 받을 만하다고 믿습니다. 이번 릴리스(3.22)에서 Impeller를 선택하는 앱은 가능한 경우 Vulkan 백엔드를 사용합니다. 향후 릴리스에서는 이것이 기본 설정이 될 것입니다. Impeller를 선택하는 앱이 Vulkan을 지원하지 않는 기기에서 실행될 때, Flutter는 자동으로 OpenGL ES와 Skia를 사용하도록 자연스럽게 대체합니다. 여러분은 별도의 조치를 취할 필요가 없습니다. 미래에 우리가 OpenGL ES Impeller 백엔드를 제품으로 출시할 준비가 되었을 때, 이 대체 방법 또한 Impeller를 사용할 것입니다.\n\n이 3.22 안정 주기를 통해 안드로이드에서의 Impeller 미리보기가 계속될 동안, Flutter 개발자들이 최신 안정 버전으로 업그레이드하고 Impeller를 활성화할 때 발견된 어떤 결점에 대해 이슈를 제기하기를 요청합니다. 이 단계에서의 피드백은 Impeller가 안드로이드에서 성공적이 되도록 보장하고, 올해 후반 릴리스에서 확신을 가지고 기본 렌더러로 만들 수 있도록 하는 데 중요합니다. 안드로이드 하드웨어 생태계는 매우 다양합니다. 이에 따라 Impeller에 대한 가장 유익한 피드백은 문제가 발생한 특정 기기 및 안드로이드 버전에 대한 상세한 정보를 포함해야 합니다.\n\n\n\n## 블러 성능 향상\n\niOS와 Android 모두 Impeller에서 Blur가 재구현되었습니다. 새로운 방식은 Skia의 것과 유사하며, 벤치마크에서 블러의 CPU 및 GPU 시간을 거의 절반으로 줄였습니다.\n\n아래 차트는 iPhone 11 기기에서 경로학적 벤치마크에서 frame 래스터화 시간(ms)과 GPU frame 시간을 나타냅니다. Impeller의 blur를 재작성한 후, 배경 필터 블러의 CPU 및 GPU 비용이 거의 반으로 줄었습니다. 이런 개선은 일반적인 앱에서 나타나는 경우와 같이 병적인 상황에서 발생하는 경우에도 적용됩니다.\n\n![image](/assets/img/2024-05-15-WhatsnewinFlutter322_1.png)\n\n\n\n## 스텐실 후 커버\n\niOS 및 Android에서의 임펠러는 OpenGL 레드북의 \"스텐실 버퍼를 사용하여 채우고 오목한 다각형 그리기\" 장에서 설명된 스텐실-커버 방식을 기반으로 한 새로운 렌더링 전략으로 전환했습니다. 팀 구성원들은 이 기술이 Flutter에 적용된다는 점에 대해 GitHub 이슈 #123671에서 더 많이 논의했습니다.\n\n이 접근 방식은 래스터 스레드가 예를 들어 SVG 및 Lottie 애니메이션과 같은 복잡한 경로의 테셀레이션을 CPU에서 계산하는 데 너무 많은 시간을 소비하던 문제를 해결합니다. 변경 후, 복잡한 경로가 포함된 프레임의 총 프레임 시간(컴퓨터의 UI 스레드 + 래스터 스레드 + GPU 작업)이 상당히 낮아집니다. 사용자는 Lottie 애니메이션 및 기타 복잡한 경로가 더 부드럽게 렌더링되고, CPU 사용률이 낮아지고 약간 높은 GPU 사용률을 확인할 수 있을 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*1lCd7dBwJ0ab_sieDlQNFw.gif)\n\n\n\n이러한 개선 사항에 만족해하면서도, 할 일이 더 많이 남아 있습니다. 다른 기회들 중에, CPU 프로파일에서 polyline 생성이 여전히 중요한 역할을 하는 것을 인지하고 있으며, 이 작업을 GPU로 전환하는 것에 대해 조사할 계획입니다.\n\n## 새로운 API\n\n아직 실험적이지만, flutter test는 이제 --enable-impeller 플래그를 허용하며, Vulkan 백엔드를 이용하여 Impeller를 사용합니다.\n\n# 프레임워크\n\n\n\n## 위젯 상태 속성\n\nMaterialState는 Material 라이브러리 외부로 이동되었으며 WidgetState로 이름이 변경되어 Cupertino, 기본 Flutter 프레임워크 및 패키지 작성자에게 이용 가능하게 되었습니다. 새로운 WidgetState로의 이관에 대한 자세한 정보는 마이그레이션 가이드를 참조해주세요.\n\n## 동적 뷰 크기 조정\n\n동적 뷰 크기 조정의 개선으로, 반응형 레이아웃을 구축하는 개발자들이 더 나은 UI 적응성을 확보할 수 있게 되었으며, 다양한 디바이스 화면에 대해 더 나은 UI 적응성을 제공합니다.\n\n\n\n## 개선된 양식 유효성 검사\n\n플러터 커뮤니티 구성원인 SharbelOkzan의 기여 덕분에, 플러터 3.22 버전부터는 더 유연한 양식 유효성 검사 방법이 제공되어 개발자들이 더 견고한 사용자 입력 처리를 만들 수 있게 되었습니다. 이로써 사용성과 보안이 모두 강화되었습니다.\n\n## 2D API의 공변형\n\n2D 그래픽 API에서 형 변환 필요성을 줄임으로써 개발 워크플로우를 간소화하고, 게임 및 복잡한 애니메이션에 중요한 성능을 향상시킬 수 있습니다.\n\n\n\n## 플레이버별 자산 번들링\n\n플레이버 기능을 사용하는 개발자들은 이제 특정 플레이버를 빌드할 때만 특정 자산이 번들되도록 구성할 수 있습니다. 자세한 정보는 '플레이버에 기반한 조건부 자산 번들링'을 확인해보세요.\n\n## Dart 패키지를 사용한 자산 변환\n\n사용자들은 이제 Dart 패키지를 구성하여 앱의 자산이 번들될 때 변환되도록 설정할 수 있습니다. 자세한 정보는 '빌드 시간에 자산 변환하기'를 확인해보세요.\n\n\n\n# 안드로이드\n\n## 딥 링크\n\n딥 링크를 사용하면 플러터 앱의 사용자 경험을 크게 향상시킬 수 있습니다. 사용자를 앱 내의 특정 콘텐츠로 원활하게 안내하는 바로 가기 역할을 하므로, 참여율을 높이고 판매를 촉진할 수 있습니다. iOS용 Universal Links 및 Android용 App Links를 사용하면 보안 및 사용자 친화성이 우수하다는 점에서 매우 권장되지만, 설정하는 데는 조금 까다로울 수 있습니다.\n\n최신 플러터 안정 버전에서는 DevTools 내에 안드로이드 앱의 웹 구성을 확인하는 딥 링크 유효성 검사 도구를 소개했습니다. 이 버전에서는 Android 매니페스트 파일 내 설정을 확인하는 데 도움이 되는 새로운 기능 세트를 추가했습니다.\n\n\n\n이 도구를 사용하는 방법에 대한 자세한 정보는 딥링크 유효성을 확인하십시오.\n\n## 예측 제스처 뒤로가기\n\n플러터는 이제 Android의 예상 제스처 뒤로가기 기능에 대한 더 많은 지원을 추가했습니다. 사용자는 백 제스처 중에 이전 경로나 이전 앱을 엿볼 수 있습니다. 이 기능은 아직 Android 기기에서 기능 플래그 뒤에 숨겨져 있지만, GitHub에서 직접 시도해 볼 수 있는 세부 정보를 찾을 수 있습니다.\n\n## Flutter 도구는 Gradle, AGP, Java 및 Kotlin에 대한 버전 요구 사항을 강제합니다.\n\n\n\n이번 릴리스에서 Flutter 도구는 Gradle, Android Gradle 플러그인 (AGP), Java 및 Kotlin의 지원 버전에 대한 정책을 강화합니다. 초기에는 도구가 경고만 제공합니다.\n\n현재 지원되는 버전 범위는 다음과 같습니다:\n\n- Gradle — Fully supported 7.0.2 to current, warn otherwise\n- AGP — Fully supported 7.0.0 to current, warn otherwise\n- Java — Fully supported Java 11 to current, warn otherwise\n- Kotlin — Fully supported 1.5.0 to current, warn otherwise\n\n다음 주요 릴리스에서는 이러한 경고가 오류로 전환되며, --android-skip-build-dependency-validation 플래그로 재정의할 수 있습니다. 보다 일반적으로 말하면, 도구는 이러한 종속성 버전의 완전한 지원을 중단하기 전에 적어도 한 릴리스에 대한 경고를 제공합니다.\n\n\n\n이 정책은 관련된 디자인 사양에서 논의되었습니다. 의견과 피드백은 언제나 환영합니다.\n\n## 안드로이드에서 Gradle 빌드 스크립트에서 Gradle Kotlin DSL 사용 지원\n\nGradle Kotlin DSL은 이제 플러터에서 지원되며 전통적인 Gradle Groovy DSL 대안을 제공합니다. 이 지원을 통해 더 나은 코드 편집 환경을 제공하여 자동 완성, 문서 빠른 액세스, 소스 탐색 및 컨텍스트 인식 리팩터링이 가능합니다.\n\n이 초기 지원은 GitHub 사용자 bartekpacia가 공헌했습니다. 개발자들은 이제 Gradle 빌드 스크립트를 코틀린으로 다시 작성하여 이러한 혜택을 누릴 수 있지만, 플러터 도구는 아직 flutter create를 사용할 때 코틀린을 그루비 대신 선택할 수는 없습니다.\n\n\n\n자세한 내용은 bartekpacia가 제출한 PR 140744을 확인해보세요.\n\n## 플랫폼 뷰 개선 사항\n\n플러터 앱 개발자 여러분, 주목하세요! Flutter를 사용하여 맵, 웹 뷰 또는 특정 UI 요소와 같은 네이티브 Android 구성 요소에 의존하는 앱을 개발 중이라면 중요한 소식이 있습니다.\n\nAndroid 14에서 발생하는 버그로 인해 이전 버전의 Flutter로 빌드된 앱은 이 새로운 Android 버전을 실행하는 기기에서 제대로 작동하지 않을 수 있습니다.\n\n\n\nFlutter 3.22은이 문제를 해결하고 안드로이드 앱의 네이티브 구성 요소의 전반적인 성능을 향상시킵니다. 따라서 모든 안드로이드 기기에서 앱이 원활하게 실행되도록하려면 Flutter 3.22로 앱을 다시 빌드하고 릴리스하십시오.\n\n이 업데이트에는 안드로이드에서 플랫폼 뷰를 더 신뢰할 수 있고 성능이 더 향상되도록하는 뒷면 개선사항도 포함되어 있습니다.\n\n## KitKat에 대한 지원 종료\n\nFlutter의 최소 지원 안드로이드 버전은 이제 Lollipop (API 21)입니다. Flutter의 3.22 안정 릴리스부터는 Android KitKat (API 19)를 실행하는 기기에서 더 이상 작동하지 않습니다. 자세한 내용은 당사의 폐기 안내서를 참조하십시오.\n\n\n\n# iOS\n\n## 플랫폼 뷰 성능\n\n우리는 iOS에서 플랫폼 뷰 성능이 많은 Flutter 개발자들에게 골칫거리였음을 이해합니다. 이는 특히 플랫폼 뷰를 사용할 때 스크롤 뷰 내에서 특히 두드러졌습니다.\n\n최근 업데이트는 이러한 우려사항에 직접 대응하여, 특히 기사 내에서 여러 인라인 광고를 포함하는 시나리오에서 상당한 향상을 이끌어냈습니다. 우리의 벤치마크에서 주요 향상점은 다음과 같습니다:\n\n\n\n- GPU 사용량 감소: GPU 사용량이 50% 감소하여 전력 소비가 줄어들고 사용자 경험이 원활해질 수 있습니다.\n- 프레임 렌더링 개선: 평균 프레임 렌더링 시간이 1.66ms(33%) 감소했습니다.\n- 지연 최소화: 최악의 경우 프레임 렌더링 시간이 3.8ms(21%) 줄었습니다.\n\n이전에 여러 플랫폼 뷰(광고, 지도 등)를 스크롤 뷰 내에서 사용할 때 성능에 도전이 있었다면, 이러한 최적화로 스르르르륵 하고 더 반응이 빠른 스크롤링 경험을 기대할 수 있습니다. 한 번 시도해보고 어떻게 생각하는지 알려주세요.\n\n<img src=\"/assets/img/2024-05-15-WhatsnewinFlutter322_2.png\" />\n\n<img src=\"/assets/img/2024-05-15-WhatsnewinFlutter322_3.png\" />\n\n\n\n# 생태계\n\n## Vertex AI for Firebase Dart SDK 미리보기 릴리스\n\nVertex AI for Firebase 제품이 공개 미리보기로 출시되었으며 Dart SDK를 포함하고 있습니다. 이를 통해 Gemini API를 활용하여 Dart 또는 Flutter 앱에 대한 생성적 AI 기능을 구축할 수 있습니다. 제작, 성능 및 기업 규모를 염두에 두었습니다. SDK는 Firebase App Check과 통합되어 API 호출을 보호하고 청구 사기, 피싱 및 앱 가장자리와 같은 심각한 위협으로부터 백엔드 인프라를 안전하게 보호합니다. Dart를 위한 시작하기 페이지로 이동하여 프로모션 코드를 사용하여 무료로 사용해 보세요.\n\n![](/assets/img/2024-05-15-WhatsnewinFlutter322_4.png)\n\n\n\nGoogle AI Dart SDK은 여전히 사용 가능하며, 프로토타입에 권장됩니다. Google AI는 무료로 액세스할 수 있으며(한계가 있을 수 있음), 과금 방식도 있습니다. Google AI Dart SDK로 프로토타입을 진행하고 있으며, Firebase용 Vertex AI로 마이그레이션 준비가 된 경우, 마이그레이션 가이드를 확인해보세요.\n\n## DevTools 업데이트\n\n우리는 Dart와 Flutter용 성능 및 디버깅 도구 모음인 DevTools를 계속 개선하고 있습니다. 이 릴리스에는 성능 향상, 일반적인 더 완만함, CPU 샘플을 타임란에 포함시키는 새로운 기능, 고급 필터링, 그리고 메모리 스냅샷 가져오기 및 내보내기 지원이 포함되어 있습니다.\n\n기타 주목할만한 개선점은 DevTools 확장 패키지와 DevTools 앱 공유 패키지에 포함되어 있으며, DevTools 확장 개발자를 지원합니다. 우리는 새로운 Dart Tooling Daemon(DTD)에 확장을 연결할 수 있는 지원을 추가했습니다. 이를 통해 DevTools 확장은 IDE와 같은 다른 DTD 클라이언트가 등록하는 공개 메서드에 액세스할 수 있으며, 개발 프로젝트와 상호 작용하기 위한 최소 파일 시스템 API에도 액세스할 수 있습니다.\n\n\n\n플러터 3.22에 포함된 모든 업데이트에 대해 알아보려면 DevTools 2.32.0, 2.33.0 및 2.34.1의 릴리스 노트를 확인해보세요.\n\n## 플러터용 Google Mobile Ads SDK\n\nFlutter 앱을 광고로 수익화하고 있는 경우, 좋은 소식이 있어요! Google Mobile Ads for Flutter가 버전 5.0.1로 주요 업데이트를 배포했습니다.\n\n사용자 메시지 플랫폼 (UMP) SDK 지원 강화: 이 업데이트는 안드로이드 UMP SDK 버전 2.2.0 및 iOS UMP SDK 버전 2.4.0의 최신 API를 지원합니다. UMP SDK는 개인정보 규정을 준수하는 데 중요하며, 사용자 동의를 얻는 것을 더 쉽게 할 수 있습니다. 이 새로운 버전은 동의 수집 프로세스를 간소화하는 몇 가지 새로운 API를 소개합니다.\n\n\n\n확장된 중재 파트너: 인기 있는 광고 파트너들과의 통합을 통해 여러분의 광고 수익 창출 가능성을 확장하였습니다. 이제 Unity, Meta, AppLovin, Iron Source, Mintegral, Pangle, DT Exchange, InMobi 및 Liftoff와의 통합을 통해 앱 수익을 극대화할 수 있습니다. 확장된 중재 옵션과 간소화된 구현으로 앱 수익을 극대화하세요.\n\n새로운 기능을 플러터 앱에서 시도해 보고, 어떤 중재 파트너를 지원했으면 하는지 알려주시기 바랍니다. 여러분의 피드백은 Google Mobile Ads SDK for Flutter를 개선하는 데 귀중합니다.\n\n# 변경 사항 및 폐기 사항\n\n## ColorScheme.fromSeed\n\n\n\n만약 ColorScheme.fromSeed에서 사용된 seedColor의 색감 값이 높다면, 생성된 ColorScheme은 생기발랄함이 부족한 파스텔 팔레트를 제공할 수 있습니다. 원하는 시드 색상의 느낌과 가장 일치하도록 출력 색상을 보장하려면 dynamicSchemeVariant를 DynamicSchemeVariant.fidelity 또는 DynamicSchemeVariant.content로 설정하는 것을 고려해보세요. 이러한 옵션은 원래 시드 색상과 더 가깝게 맞는 팔레트를 생성합니다.\n\n## v1 Android 임베딩 제거\n\n안드로이드 임베딩의 버전 1 삭제가 진행 중입니다. 대부분의 앱에는 아무런 영향을 미치지 않을 것으로 예상됩니다.\n\n- 버전 2가 많은 해 default 였습니다.\n- Flutter 도구는 이미 --ignore-deprecation 플래그로 명시적으로 무시하지 않은 한 버전 1 앱을 빌드하는 것을 막았을 것입니다.\n\n\n\n이 릴리스로 인해 v1 앱의 Flutter 도구 지원이 완전히 중단되었습니다. 더 이상 재정의할 수 없습니다.\n\n플러그인 작성자 여러분, 알려드립니다: 초기에 v1 안드로이드 삽입이 폐기되었을 때 플러그인 작성자를 위해 이주 문서가 작성되었습니다. 해당 문서는 https://docs.flutter.dev/release/breaking-changes/plugin-api-migration에서 확인할 수 있습니다. 이주 과정에서 v1 삽입을 사용하는 앱을 지원하는 것이 권장되었으며, 이를 위해 *Plugin.java에 다음과 같은 시그니처를 가진 메소드를 포함하는 것이 추천되었습니다.\n\npublic static void registerWith(@NonNull io.flutter.plugin.common.PluginRegistry.Registrar registrar)\n\n다음 릴리스에서 v1 Android 삽입을 완전히 삭제할 계획입니다. 그 시점에 이 시그니처를 포함하는 플러그인은 더 이상 컴파일되지 않을 것입니다(이는 v1 android 삽입에서의 타입을 참조하고 있기 때문입니다).\n\n\n\n현재 이 표는 아무 목적도 없습니다. 왜냐하면 이 릴리스로 인해 v1 임베딩을 사용하는 앱들이 작동하지 않게 되었습니다. 우리는 플러그인 저자들에게 가능한 빨리 업데이트된 플러그인 버전을 릴리스하여 v1 코드를 제거하기를 권장합니다. 이렇게 하면 향후 Flutter 버전에서의 문제를 피할 수 있습니다. 예를 들어, Flutter 팀이 유지보수하는 플러그인들을 제거한 PR 6494를 확인해보세요.\n\n## 3.22에서 제거된 사용 폐기사항들\n\n이번 릴리스에서의 중단 변경 사항에는 v3.19 이후 만료된 사용 폐기 API가 포함되어 있습니다. 영향을 받는 모든 API와 추가적인 맥락 및 이주 지침은 이번 릴리스의 폐기 안내서에서 확인할 수 있습니다. 이 중 많은 것들은 Flutter fix에 의해 지원되며, IDE에서 빠른 수정도 가능합니다. 대량 수정은 dart fix 커맨드 라인 도구를 사용하여 평가하고 적용할 수 있습니다.\n\n이러한 중단 변경 사항을 식별하는 데 도움을 주신 커뮤니티에게 항상 감사드립니다. 자세한 내용은 Flutter의 중단 변경 정책을 확인해보세요.\n\n\n\n# 결론\n\n플러터의 성공의 핵심은 여러분 - 우리 놀라운 커뮤니티입니다. 여러분의 끊임없는 기여와 열정이 없었다면 이번 릴리즈는 불가능했을 것입니다. 우리 마음속 깊은 곳에서 감사드립니다.\n\nFlutter 3.22를 탐험할 준비가 되셨나요? 전체 릴리스 노트와 변경 로그를 확인하고, 터미널을 켜고 flutter upgrade를 실행해보세요. 여러분이 어떤 것을 만들어내는지 기대됩니다!","ogImage":{"url":"/assets/img/2024-05-15-WhatsnewinFlutter322_0.png"},"coverImage":"/assets/img/2024-05-15-WhatsnewinFlutter322_0.png","tag":["Tech"],"readingTime":12},{"title":"잠금된 유동성 스테이킹","description":"","date":"2024-05-15 10:48","slug":"2024-05-15-LockedliquidityStaking","content":"\n\n\n![Locked Liquidity Staking](/assets/img/2024-05-15-LockedliquidityStaking_0.png)\n\n## 소개:\n\n토큰이 소각되거나 스테이킹되면 가격이 대부분 상승합니다. 문제는 USTC 홀더들이 토큰을 소각하도록 어떻게 인센티브를 제공할지입니다. 아마도 소각의 명백하고 돌이킬 수 없는 특성을 없애면서도 생태계 전반에 이익을 주는 대안 솔루션을 찾아야 할 것입니다. LUNC와 USTC가 커뮤니티 토큰이라면, 우리는 모두가 성공할 수 있도록 공동으로 행동할 수 있는 기회가 있습니다.\n\n# 잠긴 유동성 스테이킹:\n\n\n\n\nUSTC를 위탁/잠그면 순환 공급에서 제외됩니다. USTC 토큰은 가격이 설정된 페그보다 높을 때만 점차 잠금이 해제됩니다. 먼저 USTC를 위탁하시면 페그를 초과할 때 잠금이 해제된 다음 홀딩이 방출됩니다. 거래는 처음부터 순서대로 점진적으로 처리되므로 처음으로 위탁한 사람이 자동화된 프로세스에서 처음으로 잠금 해제됩니다. 여기서는 1달러의 예시를 들겠습니다. 가격이 1달러 이상으로 올라간다면, 먼저 USTC를 위탁한 사람이 자신의 잠금 홀딩이 페그를 안정화하고 1달러 가격을 유지하기 위해 점진적으로 방출/처리되는 첫 번째 대상이 됩니다. 가격이 1달러 이상으로 올라가면, USTC는 소액 이익을 위해 자동으로 잠금 해제되어 달러 가격을 다시 내리는 노력을 합니다. 자산을 잠그면 가격이 올라가는데, 페그를 넘으면 USTC가 해제되어 다음으로 USTC를 받을 대상에게 할당됩니다. 사용자들이 자산을 위탁/잠그도록 독려하기 위해, 위탁자들은 오라클 보상 풀에서 USTC로 보상받게 되며 이는 언제든지 사용 가능합니다. 이 노력을 통해 순환 공급을 낮추는 사람에게 보상이 주어지며, 보상/연간 이자율은 USTC가 페그 아래일 때 위탁하고 잠그도록 사용자들을 독려하는 방향으로 조정됩니다.\n\n다른 커뮤니티 회원의 제안에 따라 프로토콜을 보완하기 위해, 해제될 때 일부 USTC의 비율에 대한 소각이 설정됩니다. 하지만 이는 얻을 수 있는 이익에 기반합니다. 예를 들어, 페그가 1달러이고 가격이 1.20달러로 올라간 경우, 20%의 이익 중 10% 비율로 설정된 0.02달러가 소각됩니다. 이 투자자는 CEX 또는 DEX에서 판매하면 0.18달러의 이익을 얻게 됩니다. 상황에 따라 출금 지수를 더 높일 수도 있습니다.\n\n균형은 중요하며 유동성을 잠그는 것이 자산 가격을 안정시키는 데 도움이 될 수 있습니다. 토큰에 대한 신뢰가 높아진다면, 우리 생태계로 새로운 유동성이 들어오면 빠르게 새로운 수준을 달성할 수 있습니다. 훌륭한 커뮤니티 노력으로 USTC는 궁극적으로 유틸리티, 지위 및 신뢰를 되찾을 수 있습니다.\n\n\n\n\n![이미지](/assets/img/2024-05-15-LockedliquidityStaking_2.png)\n\n# USTC Staking 활성화:\n\nUSTC 스테이킹은 프로토콜의 주요 구성 요소 중 하나이므로 구현해야 합니다. 오라클 풀 내의 USTC는 USTC 스테이커들에게 전용되어야 하므로 USTC 스테이킹은 USTC 스테이커들에게만 USTC 보상을 제공할 것입니다. 따라서 USTC는 더 이상 Lunc 스테이커들에게 보상으로 제공되지 않을 것입니다. 이것은 일시적인 조치로 USTC를 재고정하기 위한 노력입니다.\n\n![이미지](/assets/img/2024-05-15-LockedliquidityStaking_3.png)\n\n\n\n\n이것은 초안임을 안내드립니다. 모든 것이 여전히 변동 사항이 많습니다. 이 제안서와 다음 부분은 커뮤니티에서 논의되어야 합니다.\n\n## 조기 언스테이킹을 허용하는 옵션:\n\n이겪에 대해 여전히 논의 중이지만, 락인된 USTC를 비정상적으로 언스테이킹할 수 있는 방법을 고려해왔습니다. 예를 들어, 스테이커들이 자동 언스테이킹 이전에 원한다면 언스테이킹할 수 있는 옵션을 제공할 수 있습니다. 그러나 이 경우 비용이 발생합니다. 이를 위해 20%의 세금이 부과됩니다. 10%는 소각되며, 10%는 오라클 보상 풀에 할당됩니다. 나머지 80%는 21일 후에 언스테이킹됩니다. 소각 및 오라클 보상 풀의 보충은 가격과 스테이킹 보상에 긍정적인 영향을 미칠 수 있습니다.\n\n## 프로토콜이 성공하지 못할 경우:\n\n\n\n현재 상태로 다시 돌아갑니다.\n\n모든 스테이크된 Ustc는 언스테이크되며 보유자들이 자산을 회수합니다.","ogImage":{"url":"/assets/img/2024-05-15-LockedliquidityStaking_0.png"},"coverImage":"/assets/img/2024-05-15-LockedliquidityStaking_0.png","tag":["Tech"],"readingTime":3},{"title":"코틀린에서의 DRY 원칙 코드 품질과 유지보수성 향상","description":"","date":"2024-05-15 10:46","slug":"2024-05-15-TheDRYPrincipleinKotlinEnhancingCodeQualityandMaintainability","content":"\n\n![image](/assets/img/2024-05-15-TheDRYPrincipleinKotlinEnhancingCodeQualityandMaintainability_0.png)\n\nDRY(반복하지 말 것) 원칙은 코드 중복을 피하고 코드 재사용을 촉진하는 소프트웨어 개발의 기본 개념입니다. 이 원칙은 시스템 내의 모든 지식 요소가 단일하고 명확한 표현을 가져야 한다고 주장합니다. 간단히 말하면, 동일한 논리 또는 정보가 코드베이스의 여러 위치에 중복되어 나타나지 않아야 한다는 것을 의미합니다.\n\nDRY 원칙은 공통 기능을 함수, 클래스 또는 모듈과 같은 재사용 가능한 구성 요소로 추상화하는 것을 개발자에게 권장합니다. 이렇게 함으로써, 개발자는 변경이나 업데이트를 한 곳에서만 수행하면 되므로 유지보수가 쉬운 코드를 작성할 수 있습니다. 이는 일관성과 오류 발생 가능성을 감소시키면서 코드의 가독성과 이해도를 향상시킵니다.\n\nDRY 원칙을 준수하면 모듈성, 캡슐화, 추상화와 같은 더 나은 소프트웨어 디자인 관행을 촉진합니다. 이는 유지보수와 확장, 디버그 및 협업이 쉬운 더 깔끔하고 관리하기 쉬운 코드베이스를 만드는 데 도움이 됩니다.\n\n\n\n## DRY 원칙이 필요한 이유는 무엇인가요?\n\n- 코드 유지보수성: 코드 중복은 유지보수 부담을 증가시킵니다. 동일한 코드 논리가 여러 곳에 복사되면 해당 논리를 수정하거나 업데이트해야 하는 경우 여러 위치에서 변경이 필요하며, 일관성 및 오류 발생 위험이 증가합니다. Kotlin에서 DRY 원칙을 준수하면 변경 사항을 하나의 위치에서만 수행해야 하므로 코드 유지보수가 더 쉬워집니다.\n- 버그와 오류 감소: 중복된 코드는 버그와 오류 발생 가능성을 증가시킵니다. 중복된 코드의 한 부분에서 버그가 수정되지만 다른 곳에서는 수정되지 않으면 일관성 문제가 발생하여 예기치 않은 동작을 야기할 수 있습니다. Kotlin 코드에서 DRY 원칙을 준수하면 코드 논리를 중앙 집중화하여 일관성 문제로 인한 버그 발생 가능성을 최소화합니다.\n- 가독성 및 이해도 향상: 중복된 코드는 코드의 가독성과 이해도를 저해합니다. 동일한 논리가 코드베이스 전체에 흩어져 있으면 시스템의 전반적인 기능과 목적을 파악하기가 어려워집니다. DRY 원칙을 따르고 논리를 통합함으로써 Kotlin 코드를 더 읽기 쉽고 이해하기 쉽게 만듭니다.\n- 모듈성과 재사용성 촉진: DRY 원칙을 준수하면 모듈화되고 재사용 가능한 구성 요소를 생성하는 것을 촉진합니다. 동일한 논리를 여러 곳에 반복하는 대신 Kotlin 개발자들은 공통 기능을 별도의 모듈, 함수 또는 클래스로 추출하도록 권장받습니다. 이는 구성 요소가 코드베이스 전반에서 재사용될 수 있는 모듈화 아키텍처를 촉진합니다.\n\n## Kotlin에서 DRY 원칙 적용 예:\n\n1. 공통 기능을 함수나 확장 함수로 추출하기\n\n\n\n```kotlin\n// DRY 원칙 없이: 특정 모양에 대한 함수\nfun calculateCircleArea(radius: Double): Double {\n    return Math.PI * radius * radius\n}\n\nfun calculateRectangleArea(width: Double, height: Double): Double {\n    return width * height\n}\n\n// DRY 원칙을 적용한 경우: 면적을 계산하는 일반적인 함수\nfun calculateArea(shape: Shape): Double {\n    return when (shape) {\n        is Circle -> Math.PI * shape.radius * shape.radius\n        is Rectangle -> shape.width * shape.height\n    }\n}\n```\n\n서로 다른 모양의 면적을 계산하기 위해 별도의 함수를 갖는 대신, 입력으로 Shape 객체를 받아 해당 형태의 면적을 계산하는 calculateArea라는 단일 함수를 생성합니다. 이 접근 방식은 코드 중복을 제거하고 재사용성을 증진시킵니다.\n\n2. 고차 함수 활용:\n\n```kotlin\n// DRY 원칙 없이\nfun applyOperationTwice(value: Int, operation: (Int) -> Int): Int {\n    return operation(operation(value))\n}\n\n// DRY 원칙을 적용한 경우\nfun applyOperationTwice(value: Int, operation: (Int) -> Int): Int {\n    return operation(value).let(operation)\n}\n```\n\n\n\napplyOperationTwice 함수에서는 DRY 원칙을 사용하여 let 함수를 사용하여 처음 호출 결과에 작업을 호출합니다. 이 접근법은 가독성을 향상시키고 작업이 적용되는 방식을 일관성있게 유지합니다.\n\n3. 상수 공유:\n\n```js\n// DRY 원칙 미적용: 전역으로 상수 선언\nconst val MAX_RETRIES = 3\nconst val TIMEOUT = 5000\n\n// DRY 원칙 적용: 상수를 객체에 그룹화\nobject Constants {\n    const val MAX_RETRIES = 3\n    const val TIMEOUT = 5000\n}\n```\n\n전역으로 상수를 선언하는 대신, 관련 있는 상수를 객체 내에 그룹화하여 DRY 원칙을 적용합니다. 이 접근법은 상수를 논리적으로 구성하고 네임스페이스 오염을 방지합니다.\n\n\n\n4. 재사용 가능한 데이터 구조:\n\n```js\n// DRY 원칙 없이: 각 모양에 대한 별도의 클래스\nclass Rectangle(val width: Double, val height: Double)\n\nclass Circle(val radius: Double)\n\n// DRY 원칙을 적용한 경우: 공유된 베이스 클래스와 데이터 클래스\nsealed class Shape\n\ndata class Rectangle(val width: Double, val height: Double) : Shape()\n\ndata class Circle(val radius: Double) : Shape()\n```\n\n공유된 베이스 클래스 Shape를 정의하고 이를 기반으로 Rectangle 및 Circle과 같은 특정 모양을 파생시킴으로써 DRY 원칙이 적용됩니다. 이 접근 방식은 코드 재사용을 촉진하고 모양이 어떻게 표현되는지에 일관성을 유지합니다.\n\n5. 비즈니스 로직 공유:\n\n\n\n```js\n// DRY 원칙을 적용한 예시: 공통 구현 로직을 캡슐화한 베이스 매니저 클래스\nclass BaseManager<T>(private val repository: BaseRepository<T>) {\n    fun addItem(item: T) {\n        if (repository.getItemById(item.id) == null) {\n            repository.addItem(item)\n        }\n    }\n}\n\n// UserManager과 ProductService와 같은 특정 매니저 클래스들은 BaseManager를 상속하여 이 공통 로직을 재사용하며, 코드 중복을 줄이고 일관성을 유지합니다.\n\n# DRY 사용 시 고려할 점:\n\n- 너르 도구 되기 전에: 코드 중복과 추상화 사이의 균형을 맞추는 것이 중요합니다. 때때로 일반 로직을 너무 이르게 추출하면 이해하기 어렵고 유지보수하기 어려운 지나치게 복잡한 추상화로 이어질 수 있습니다. 진정으로 재사용 가능한 경우에만 코드를 추상화해야 합니다.\n- 의미 있는 명명: 재사용 가능한 구성요소로 코드를 추출할 때, 함수, 클래스 또는 모듈에 서술적이고 의미 있는 이름을 선택해야 합니다. 명확한 명명은 다른 개발자가 코드의 의도와 목적을 이해하기 쉽도록 도와줍니다.\n- 함수 일관성 유지: 재사용 가능한 함수 또는 클래스를 작성할 때, 단일 책임을 갖고 명확한 작업을 수행하는지 확인해야 합니다. 하나의 함수 또는 클래스에 관련 없는 기능을 섞는 것은 혼란을 초래하고 단일 책임 원칙(SRP)을 위반할 수 있습니다.\n- 트레이드오프 고려: 중복을 줄이는 것은 일반적으로 유익하지만, 때로는 더 명확하고 유지보수가 쉬운 코드를 만들기 위해 약간의 중복이 허용될 수 있습니다. DRY성과 단순성 및 명료성과 같은 다른 소프트웨어 설계 원칙 간의 트레이드오프를 고려해야 합니다.\n- 문서화와 주석: 재사용 가능한 구성 요소의 목적과 사용법을 문서화하여 다른 개발자가 올바르게 사용하는 데 도움을 줄 수 있습니다. 또한 코드 내 복잡하거나 명확하지 않은 로직을 설명하는 주석을 제공해야 합니다.\n```\n\n\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해주시면 좋겠어요! 👏\n- 저희를 팔로우해주세요 X | 링크드인 | 유튜브 | 디스코드\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘적 콘텐츠를 다루어야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-15-TheDRYPrincipleinKotlinEnhancingCodeQualityandMaintainability_0.png"},"coverImage":"/assets/img/2024-05-15-TheDRYPrincipleinKotlinEnhancingCodeQualityandMaintainability_0.png","tag":["Tech"],"readingTime":5},{"title":"안녕하세요 HTML 안녕하세요","description":"","date":"2024-05-15 10:45","slug":"2024-05-15-ripHTMLrip","content":"\n\n## JavaScriptUI — DevBlog #2\n\n얼마 전에 미친 아이디어가 떠올랐어요: HTML 없이 웹사이트를 만들 수 있을까?\n\n아니요, 제가 말하는 것은 새로운 브라우저 엔진을 만드는 것이나 캔버스를 사용하여 콘텐츠를 표시하는 것이 아닙니다. 또한 WebAssembly나 HTML로 컴파일된 새 언어를 사용하는 것이 아닙니다. 제가 말하는 것은 오늘날 어떤 브라우저에서도 즉시 실행되는 완전히 기능적인 웹사이트를 작성하는 방법입니다. 그것도 HTML 한 줄을 작성하지 않고요.\n\n실은 가능합니다. 그리고 지금 바로 수행하기 까다롭지도 않아요. 우리는 그저 JavaScript의 DOM API를 맹공하면 되는 것 뿐입니다. 확실히 여전히 브라우저 안에서 약간의 HTML을 생성하지만 그건 당장 무시해도 되는 구현 세부사항입니다. 필요한 건 DOM 뿐이에요. 그러니 JavaScript로 생성된 웹사이트의 세계로 뛰어들어 모든 최선의 방법을 위반해 보죠.\n\n\n\n## Views 및 View 트리\n\n어떤 것을 만들기 위해서는 객체가 필요합니다. 기본 옵션은 document.createElement()을 사용하여 HTML 요소를 만들고, Element.prototype.append() 또는 Node.prototype.appendChild()를 사용하여 이후에 DOM에 추가하는 것입니다. 꽤 기본적인 방법이지만 불편하고 지저분하며 혼란스럽습니다. 더 나은 방법이 있습니다.\n\n그 대신, Image, Text 및 Stack과 같은 선언적 생성자를 정의하고 이를 Views(뷰)라고 부르겠습니다. 이들은 여전히 DOM API에 의존하지만 더 나은 선언적 구문을 제공할 수 있습니다. 예를 살펴보세요:\n\n```js\nStack(\n  Text(\"Hello World!\"),\n  Stack(\n    Text(\"Everyone has a plumbus in their home.\"),\n    Image(\"plumbus.jpeg\")\n  )\n);\n```\n\n\n\n이 점이 아름다운 이유입니다. 이는 유효한 JavaScript입니다. 우리는 단순히 일부 View 생성자를 호출하고 그들의 자식들을 인수로 제공합니다. 결국 어떤 View 트리도 우리가 사용하는 언어와는 무관하게 중첩된 목록일 뿐입니다.\n\n다른 이점은 사용자 정의 된 Views를 생성할 수 있으므로 Safari가 사용자 지정 내장 요소를 구현하기 위해 또 하나의 10년을 기다릴 필요가 없습니다. 또는 의미를 잃어버린 것에 분개하고 있다면, 적절한 HTML 요소에 매핑되는 Views를 생성할 수도 있습니다:\n\n```js\nDiv(\n  Div(\n    Div(\n      Div(),\n      Div(),\n      Div()\n    )\n  )\n);\n```\n\n## 절대 \"new(er)\" 라고 말하지 마세요\n\n\n\n새로운 키워드를 View 생성자 앞에 사용하지 않은 이유는 두 가지 있어요. 첫째, 나무들이 아주 빠르게 아주 커질 수 있기 때문에, 더 짧은 구문을 사용하면 가독성이 향상됩니다. 둘째, JavaScript에는 이미 Image나 Text와 같은 생성자들이 있어서, 이러한 이름들이 필요합니다. 다행히도, 대부분의 내장 생성자들은 new 키워드와 함께만 작동하므로, 이론적으로 자체 작성한 기능을 추가하면서도 이 기능을 유지할 수 있습니다.\n\n```js\nnew Image(width, height); // HTMLImageElement을 생성합니다 (기본 동작)\nImage(url); // Image View를 생성합니다 (JavaScriptUI)\n```\n\n## 논리의 마법\n\n이제 진정한 재미가 시작되는 부분이죠. 우리는 JavaScript에서 HTML을 그대로 따르는 것이 아니라, 그 이상의 기능을 구현할 수 있어요. 이제 우리는 진정한 프로그래밍 언어의 영역에 들어왔으니 변수, 연산자, 조건문, 반복문, 일급 함수 등을 활용하여 원하는 것을 무엇이든 만들 수 있습니다. 심지어 조건적 할당처럼 간단한 기능조차 HTML의 능력을 크게 뛰어넘는 것이죠:\n\n\n\n```js\nStack(\n  yourChoice ? Text(\"red pill\") : Text(\"blue pill\")\n);\n```\n\n이제, FizzBuzz가 일부 불행한 CSS 애호가들에게 상처를 줄 수 있다는 것을 이해했어요. 하지만 함수, 연산자, 반복문 및 조건문은 매우 간단하고 범용적이며 강력한 빌딩 블록으로, 더 나아가게 하는 데 도움이 되는 것들이에요. 간단한 콜백 함수로 다음과 같은 작업들을 수행할 수 있어요:\n\n```js\nStack(function* () {\n\n  let i = 1;\n  while (i <= 100) {\n\n    if ((i % 15) === 0) {\n      yield Text(\"FizzBuzz\");\n\n    } else if ((i % 3) === 0) {\n      yield Text(\"Fizz\");\n\n    } else if ((i % 5) === 0) {\n      yield Text(\"Buzz\");\n\n    } else {\n      yield Text(i);\n    }\n\n    i += 1;\n  }\n});\n```\n\n제너레이터 구문에 대해 걱정하지 마세요. 여기서는 함수에서 여러 값을 선언적으로 반환하기 위해 사용했어요. View 생성자에서 약간의 속임수를 사용하여 일반 함수로도 동일한 작업을 수행할 수 있지만, 이제 이 콜백이 바닐라 JavaScript에서 기대하는 것과 약간 다르게 작동한다는 점에 주의해야 해요:\n\n\n\n```js\nStack(() => {\n\n  let i = 1;\n  while (i <= 100) {\n\n    if ((i % 15) === 0) {\n      Text(\"FizzBuzz\"); // Stack에 추가\n\n    } else if ((i % 3) === 0) {\n      Text(\"Fizz\"); // Stack에 추가\n\n    } else if ((i % 5) === 0) {\n      Text(\"Buzz\"); // Stack에 추가\n\n    } else {\n      Text(i); // Stack에 추가\n    }\n\n    i += 1;\n  }\n});\n```\n\n또는 블록 없이 조건문을 사용하기를 원하신다면, 이렇게 써도 돼요:\n\n```js\nStack(() => {\n\n  let i = 1;\n  while (i <= 100) {\n\n    if (i % 15 === 0) Text(\"FizzBuzz\");\n    else if (i % 3 === 0) Text(\"Fizz\");\n    else if (i % 5 === 0) Text(\"Buzz\");\n    else Text(i);\n\n    i += 1;\n  }\n});\n```\n\n더 이상 선언적으로 할 수 있는 게 없네요.\n\n\n\n\n하지만 더 나아가면 더 나아갑니다. View 생성자는 콜백에 인수를 제공하거나 this 컨텍스트를 자체로 설정하거나 UI 구축의 여러 불편한 측면을 추상화하기 위해 반응 시스템을 구현할 수도 있습니다. 현재 가능한 것과 불가능한 것에 대한 간단한 개요입니다.\n\n```js\nStack((argument) => {\n\n  this; //상위 항목에 접근 가능\n\n  argument; //인수 작동(View 생성자 내에서 미리 정의됨)\n  \n  //myView; //뷰 참조는 작동하지 않음\n  \n  Text(\"foo\"); //일반적인 자식 추가는 작동함\n  \n  let view = Text(\"temp\"); //변수 할당은 작동하지만 새로 생성된 뷰는 자동으로 부모에 추가됨\n  \n  evaluate ? Text(\"foo\") : Text(\"bar\"); //삼항 연산자는 작동함\n  \n  if (\n      evaluate //조건문도 작동\n  ) {\n      Text(\"foo\");\n  } else {\n      Text(\"bar\");\n  }\n  \n  let i = 0;\n  while (i < 5) {\n      Text(\"foo\"); //루프 작동\n      i += 1;\n  }\n});\n```\n\n## 이것이 JavaScriptUI입니다.\n\n이것이 JavaScriptUI의 기초입니다. 내 목표는 HTML 및 CSS의 모든 기능을 직접 JavaScript로 이관하여 기본 브라우저 API 및 일반 목적 프로그래밍 언어의 방대한 기능을 활용하는 것입니다.\n\n\n\n매주 새로운 글을 게시해 여러분을 최신 정보로 업데이트하고 제 진전을 공유하려 합니다 (아무도 안 읽어준다면 제 자신을 위로하기 위한 글이겠지요 😄). 곧 여러분께 작동하는 코드 몇 줄을 보여드릴 수 있기를 희망하며, 여러분도 관심이 있으시다면 함께 즐기시길 바랍니다.\n\n그동안 제 글을 즐겨주신다면 박수쳐 주시고, 의견을 남기고 DevBlog를 관심 있는 사람들과 공유해 주세요.\n\n감사합니다! 그리고 계속해서 기대해 주세요.\n\n⬅️ 자바스크립트UI — DevBlog #1, HTML과 CSS 없이 새로운 웹 페이지","ogImage":{"url":"/assets/img/2024-05-15-ripHTMLrip_0.png"},"coverImage":"/assets/img/2024-05-15-ripHTMLrip_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트 UI - HTML 및 CSS 없이 새 웹을 만나보세요","description":"","date":"2024-05-15 10:44","slug":"2024-05-15-JavaScriptUIanewwebwithoutHTMLandCSS","content":"\n\n## 자바스크립트 UI — 개발 블로그 #1\n\n👋 안녕하세요, 웹 열정가 여러분!\n\n새로운 웹에 대한 개념에 대해 쓴 지 꽤 오래됐죠. 그러나 약속했던 대로, 저는 여러분을 새로운 개발 블로그에 초대하고 싶어요. 여기서는 제가 지난 6년 동안 언급해 온 것을 실제로 구축하는 여정을 문서화할 거에요.\n\n그래서 정확히 무엇일까요?\n\n\n\n웹, 특히 프론트 엔드가 점점 더 번잡해져서 웹 개발에 입문하는 많은 사람들을 두렵게 만들고 있다고 느껴요. 백 엔드 프로그래머, 그래픽 디자이너 또는 새로운 입문자들이 수많은 프레임워크, 도구, 라이브러리, 심지어 기본적인 HTML과 CSS조차 혼란스럽고 어설퍼 느껴 이를 포기하는 이야기를 많이 들었어요. 그렇다고 해서 포기하지 마세요. 제가 해결책이 있다고 믿어요.\n\n그렇다면 당신의 해결책은 뭐에요, 똑똑이?\n\n음, 그렇고 말고요.\n\n가장 좋은 해결책은 쓰레기를 처리하고 핵심 웹 언어가 어떻게 작동하는지 재설계하는 것이겠지만, 이미 얼마나 복잡하고 중요한지 알려져 있기 때문에 이를 제안하는 사람이 없을 거예요. 그래서 다음으로 좋은 방법을 선택하겠어요: 작은 JavaScript 라이브러리(원할 경우 폴리필로도 사용 가능)를 작성해서 프론트 엔드 개발이 얼마나 더 효율적일 수 있는지 보여줄 거에요. 이 라이브러리를 사용하면 누구나, 심지어 초보자도 HTML 또는 CSS 지식 없이도 웹사이트를 완전히 사용자 정의하여 구축할 수 있습니다. 또한 추가 도구, 프레임워크, 컴파일러, 트랜스파일러, 번들러 또는 어떠한 종속성도 없이 진행될 거에요. 딱 한 가지 라이브러리와 순수한 JavaScript만으로 가능합니다.\n\n\n\n매주 다른 프론트엔드 개념을 분석하고, 현재 구현의 문제점을 설명하며, 인간의 직관과 이미 잘 알려진 문제 해결을 기반으로 더 나은 해결책을 시범하는 것이 목표입니다. 제가 뭔가를 추가한다면 이미 넘치는 혼돈의 더미 위에 또 다른 추상화 층이 쌓이는 것을 피하기 위해 뭔가를 제거합니다.\n\n이 라이브러리는 이미 존재하는 많은 프론트엔드 개발자들에게 엄청난 가치를 제공할 수 있다고 생각하지만, 이를 구축하는 것 또한 방대한 작업이 될 것입니다. 제 작품에 흥미를 느끼셨다면, 박수를 보내주시고, 댓글을 달아주시고, 관심 있는 사람들과 함께 내 DevBlog를 공유해주시면 정말 고맙겠습니다.\n\n아 그리고 한 가지 더, 이것은 소개일 뿐이니까 두 번째 기사도 올려두었습니다. 이번에는 좀 더 기술적인 내용이 담겨 있습니다. 여기서 읽을 수 있습니다.\n\n감사합니다. 즐겁게 읽으시길 바랍니다.\n\n\n\nJavaScriptUI — DevBlog #2, HTML 태그 ➡️","ogImage":{"url":"/assets/img/2024-05-15-JavaScriptUIanewwebwithoutHTMLandCSS_0.png"},"coverImage":"/assets/img/2024-05-15-JavaScriptUIanewwebwithoutHTMLandCSS_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular 18  새로운 주요 기능 및 개선사항TOP","description":"","date":"2024-05-15 10:42","slug":"2024-05-15-Angular18Topnewfeaturesandimprovements","content":"\n\n<img src=\"/assets/img/2024-05-15-Angular18Topnewfeaturesandimprovements_0.png\" />\n\n앵귤러 18의 릴리스 날짜가 금방 오다가 예상 데뷔일인 2024년 5월 20일에 기대감이 커지고 있습니다. 새로운 기능과 개선 사항이 무엇을 가져올지 기대되는 가운데, 앵귤러는 지속적으로 발전하여 개발자들의 요구 사항과 문제를 해결하고 각 업데이트마다 혁신, 최적화 및 개선을 제공합니다. 앵귤러 18에서 기대되는 새로운 기능들을 알아보겠습니다:\n\n# 함수를 사용한 라우트 리다이렉트\n\n앵귤러 18에서는 문자열 대신 함수를 사용하여 리디렉트를 관리할 수 있는 새로운 기능이 소개됩니다. 이 개선으로 라우팅에서 더 많은 유연성을 제공하고 새로운 가능성을 엽니다. 예를 들면:\n\n\n\n테이블 태그를 Markdown 형식으로 변경하면 다음과 같습니다.\n\n\nThe function can access an object with information about the URL, allowing for more dynamic redirection.\n\n## Default Content in ng-content\n\nDefault content is now allowed within the ng-content tag. This logical extension will enable developers to include default content directly in the tag itself:\n\n## New RedirectCommand class\n\n\n\n\n리다이렉트 명령 클래스인 RedirectCommand클래스를 도입하기 전에, Guards 및 Resolvers는 새로운 경로를 나타내는 UrlTree를 반환하여 네비게이션을 리다이렉트할 수 있었습니다. 그러나 이 방법은 NavigationExtras를 사용한 네비게이션 리다이렉션을 허용하지 않습니다. 예를 들어:\n\n이 문제를 해결하기 위해 Angular 18에서는 가드 및 리졸버에서 네비게이션 리다이렉션을 처리하는 NavigationExtras를 허용하는 새 RedirectCommand클래스를 소개했습니다.\n\n이 개선으로 Angular 애플리케이션에서 복잡한 네비게이션 패턴을 다루는 것이 더 쉬워지며 유지보수성과 유연성이 향상됩니다.\n\n# 새 ng-template API\n\n\n\nAngular 18은 ng-template API를 더 강력하고 유연하게 만들 수 있는 기능을 도입할 수도 있습니다.\n\n# 향상된 Forms API\n\nForms API는 몇 가지 향상을 받아서 더 강력하고 개발자 친화적입니다:\n\n- 좀 더 쉬운 Form 객체 정의: 이를 통해 폼 모델을 더 적은 보일러플레이트 코드로 작성할 수 있어 가독성과 유지 보수성을 향상시킵니다.\n- 간단한 유효성 검사 규칙: API는 대부분의 유효성 검사 시나리오에 대한 더 나은 추상화를 제공하여 필수 필드, 최소/최대 값, 패턴 및 사용자 정의 유효성 검사를 더 쉽게 관리할 수 있습니다.\n- 복잡한 유효성 검사 시나리오 관리: 교차 필드 유효성 검사나 동적 유효성 규칙 등에 대한 Angular 18의 기능을 통해 복잡한 경우를 더 잘 관리할 수 있습니다.\n- 세밀한 제어: 폼 유효성 검사에 대해 더 많은 제어를 제공하여 오류 메시지를 사용자 정의하고 비동기적 유효성 검사를 처리하며 사용자 입력에 효과적으로 반응할 수 있습니다.\n\n\n\n# Zoneless Applications\n\nAngular 18은 응용 프로그램에 신호를 통합하여 zone.js에 의존하지 않고 작동하도록 합니다. 이 최적화는 성능과 응답 시간을 향상시킵니다.\n\nMatthieu Riegler와 Enea Jahollari는 각각이 주제에 관한 기사를 게시했습니다.\n\nMatthieu의 기사는 새로운 하이브리드 변경 감지 시스템에 깊이 들어가며 Signal 변경 또는 markForCheck를 호출하는 비동기(pipe)와 같은 작업이 zone.js 외부에서도 자동으로 변경 감지를 트리거할 수 있다는 것을 강조합니다.\n\n\n\n한편, Enea의 기사는 zone.js를 완전히 비활성화하고 이러한 새로운 트리거 메커니즘에 완전히 의존하여 애플리케이션 상태 변경을 관리하는 데 초점을 맞추고 있습니다.\n\n# TypeScript 4.7 지원\n\nAngular 18은 TypeScript 4.7의 기능을 최대한 활용합니다. 이 강력한 JavaScript의 슈퍼셋은 빠른 컴파일 시간과 간소화된 빌드 절차, 향상된 Readonly 지원, 새로운 import 유형 및 템플릿 리터럴 유형과 같은 다양한 성능 향상을 소개합니다. 이러한 개선 사항으로 더 원활한 개발 경험과 잠재적으로 더 빠른 애플리케이션 실행이 가능해집니다.\n\n중요한 점은 Angular 18에서 TypeScript 5.4 이전 버전의 지원을 중단한다는 것입니다. 따라서 TypeScript 버전을 업데이트하면 이러한 진보를 활용할 수 있습니다.\n\n\n\n# Ivy를 통한 성능 개선\n\nAngular의 새로운 렌더링 엔진 인 Ivy는 Angular 18에서 성능을 향상시키고 번들 크기를 줄이며 트리 쉐이킹 능력을 향상시킴으로써 계속 발전하고 있습니다.\n\n# 개선된 디버깅 도구\n\nAngular 18에서는 디버깅 도구에 여러 가지 개선 사항이 도입될 예정입니다. 이러한 개선 사항은 Angular 애플리케이션의 디버깅 과정을 단순화하고 응용 프로그램 상태에 대한 더 깊은 통찰을 제공하기 위해 목표로 합니다.\n\n\n\n- 디버깅 시 소스 맵 활용\n- 컴포넌트 트리 및 데이터 바인딩 시각화\n\n# Angular 18: 반응성을 위한 새 시대\n\nAngular 18이 다가오고 있습니다. 개발자들을 위한 흥미로운 변화를 약속하며, 단순함, 개선된 컴포넌트 및 향상된 도구에 초점을 맞춰 이번 버전은 개발 경험을 더욱 높이고 있습니다. 릴리즈를 열망하며 우리의 개발 경험이 어떻게 진화되는지 기대하고 있습니다.\n\n# 읽어 주셔서 감사합니다!\n\n\n\n만약 이 내용이 유익했다면, 댓글을 남기거나 박수를 보내주시거나 제 팔로우를 눌러주세요. 공유는 사랑입니다, 따라서 여러분의 기술 열정이 넘치는 친구들과 커뮤니티에 전달해 보세요. 그리고 LinkedIn에서 저와 연락을 유지해주시는 걸 잊지 마세요 — 언제나 열정을 가진 열광적인 분들과 소통하는 것을 기대하고 있습니다! 👏\n\n기억해 주세요, 우리의 기술 커뮤니티는 협력과 지식 공유에 의해 번영합니다. 대화를 이어나가 봅시다! 😊🚀","ogImage":{"url":"/assets/img/2024-05-15-Angular18Topnewfeaturesandimprovements_0.png"},"coverImage":"/assets/img/2024-05-15-Angular18Topnewfeaturesandimprovements_0.png","tag":["Tech"],"readingTime":4},{"title":"빠른 BDD UI 테스트 프레임워크 with Playwright","description":"","date":"2024-05-15 10:41","slug":"2024-05-15-QuickBDDUITestFrameworkwithPlaywright","content":"\n\n<img src=\"/assets/img/2024-05-15-QuickBDDUITestFrameworkwithPlaywright_0.png\" />\n\n```javascript\n// Playwright에서 Type Script와 Cucumber로 UI 테스트 프레임워크를 시작하는 빠른 가이드입니다.\n\n// 주의 사항:-\n// 이것은 테스트 자동화를 시작하기 위해 의도적으로 매우 기본적인 프레임워크 설정입니다.\n// 요구 사항에 맞게 향상시킬 수 있습니다.\n```\n\n# 필요한 것\n\n- Node 및 NPM 설치가 되어 있어야 합니다.\n- Visual Studio Code\n- Cucumber 익스텐션\n\n\n\n# 프로젝트 설정하기\n\n명령줄로 이동하여 다음을 실행하세요 (프로젝트 설정 및 종속성 설치):\n\n```js\n> mkdir playwright-bdd-project\n> cd playwright-bdd-project\n> npm init // 모든 기본 값 선택, 이렇게 하면 새 노드 프로젝트가 초기화되고 package.json이 생성됩니다\n> npm i @cucumber/cucumber -D // cucumber // -D 플래그는 이 설치를 package.json의 개발용 종속성으로 추가합니다\n> npm i @playwright/test -D // Playwright\n> npm i @types/node -D // Node용 Type Script\n> npm i ts-node -D // Node 실행 환경에서 Type Script 파일을 실행하기 위함\n> code . // 이 새롭게 설정한 프로젝트를 Visual Studio Code로 엽니다\n```\n\n<img src=\"/assets/img/2024-05-15-QuickBDDUITestFrameworkwithPlaywright_1.png\" />\n\n\n\n# 프로젝트 구조\n\n다음과 같이 프로젝트에서 디렉터리 구조를 설정해주세요:\n\n```js\nroot \\ src \\ test \\ features // 여기에는 피쳐 파일이 위치합니다\nroot \\src \\ test \\steps // 여기에는 스텝 정의 파일이 위치합니다\nroot \\ reports // 여기에는 테스트 보고서가 생성됩니다\nroot \\ src \\ test \\ utils // 여기에는 유틸리티 코드를 유지합니다\n```\n\n![예시 이미지](/assets/img/2024-05-15-QuickBDDUITestFrameworkwithPlaywright_2.png)\n\n\n\n# 이 프레임워크의 핵심 — cucumber.json\n\n프로젝트 루트에 cucumber.json 파일을 생성하세요.\n\n루트 `cucumber.json\n\n```js\n{\n    \"default\": {\n        \"paths\": [\n            \"src/test/features/*.feature\" // 피처 파일의 위치\n        ],\n        \"dryRun\": false,\n        \"formatOptions\": {\n            \"snippetInterface\": \"async-await\" // async-await 형식으로 스텝 정의를 자동 생성하기 위함\n        },\n        \"require\": [\n            \"src/test/steps/*.ts\" // 피처 파일의 위치\n        ],\n        \"requireModule\": [\n            \"ts-node/register\" // 타입스크립트 파일에서 import를 사용할 수 있도록, node 실행 환경에서 이를 인식할 수 있게 함\n        ],\n        \"format\": [\n            [\"html\", \"reports/cucumber-report.html\"] // 테스트 실행 보고서가 여기에 생성됩니다\n        ]\n    }\n}\n```\n\n\n\n# Cucumber Extension 설정.json 파일에 Feature 파일 및 Step Definitions 경로 업데이트\n\n이를 통해 Cucumber 확장 프로그램이 Feature 및 해당하는 Step Definitions 파일을 매핑하는 데 도움이 됩니다.\n\n```json\n// 참고:-\n// 아래에 표시된 것과 다를 수 있는 경우가 있습니다.\n\n{\n    \"workbench.colorTheme\": \"Quiet Light\",\n    \"files.autoSave\": \"afterDelay\",\n    \"workbench.iconTheme\": \"vscode-icons\",\n    \"playwright.reuseBrowser\": false,\n    \"playwright.showTrace\": false,\n    \"cucumber.features\": [\n        \"src/test/features/*.feature\" // Feature 파일의 위치\n    ],\n    \"cucumber.glue\": [\n        \"src/test/steps/*.ts\" // Step Definition 파일의 위치\n    ],\n    \"aws.telemetry\": false,\n    \"amazonQ.telemetry\": false,\n    \"explorer.confirmDelete\": false,\n    \"javascript.updateImportsOnFileMove.enabled\": \"always\"\n}\n```\n\n# Feature 파일\n\n\n\n\"root \\ src \\ test \\ features \\ search.feature\" 경로에 다음 기능 파일을 추가해 주세요.\n\n```js\nFeature: Basic search using google engine\n\n  Scenario: Search for a term\n    Given I am on the google search page\n    When I search for \"cucumber\"\n    Then the search results page should contain \"cucumber\"\n```\n\n# 단계 정의\n\n\"root \\ src \\ test \\ steps \\ search.ts\" 경로에 다음 단계 정의 파일을 추가해 주세요.\n\n\n\n\n```js\nimport { Given, When, Then } from '@cucumber/cucumber';\nimport { expect } from '@playwright/test';\nimport { page } from './hooks';\n\nGiven('I am on the google search page', async function () {\n    console.log('I am on the google search page');\n});\n\nWhen('I search for {string}', async function (string) {\n    console.log('I search for ' + string);\n    await page.getByLabel('Search', { exact: true }).click();\n    await page.getByLabel('Search', { exact: true }).fill(string);\n    await page.getByLabel('Google Search').first().click();\n\n});\n\nThen('the search results page should contain {string}', async function (string) {\n    console.log('the search results page should contain ' + string);\n    await page.getByRole('link', { name: 'Cucumber: BDD Testing &' }).click();\n    expect(page.url()).toContain('cucumber.io');\n});\n``` \n\n## Hooks\n\nAdd the following hooks file under: root \\ src \\ test \\ steps \\ hooks.ts\n\n```js\nimport { Before, After, AfterStep, BeforeStep, World } from \"@cucumber/cucumber\";\nimport { chromium, Page, Browser } from '@playwright/test';\nimport { addCommentToReport, addScreenshotToReport } from \"../utils/reporting\";\n\nlet browser : Browser;\nlet page : Page;\n\nBefore(async function () { // SETUP (Runs Before Every Test Scenario) \n    console.log('Before hook');\n    browser = await chromium.launch({headless: false});\n    page = await browser.newPage();\n    await page.goto('https://www.google.com');\n});\n\nAfter(async function () { // TEARDOWN (Runs After Every Test Scenario)\n    console.log('After hook');\n    await browser.close();\n});\n\n// RUNS BEFORE EVERY STEP\n// We are taking screenshop before every step and adding it to the test report\nBeforeStep(async function({pickle, pickleStep, gherkinDocument, testCaseStartedId, testStepId}) {\n    await addScreenshotToReport.call(this);\n    await addCommentToReport.call(this, 'BeforeStep hook: ' + pickleStep.text);\n})\n\n// RUNS AFTER EVERY STEP\n// We are taking screenshop after every step and adding it to the test report\nAfterStep(async function({pickle, pickleStep, gherkinDocument, result, testCaseStartedId, testStepId}) {\n    await addScreenshotToReport.call(this);\n    await addCommentToReport.call(this, 'AfterStep hook: ' + pickleStep.text + ' - ' + result.status);\n})\n\nexport { browser, page };\n```   \n  \n\n\n\n# 유틸리티\n\n아래의 유틸리티 파일을 다음 경로에 추가하세요: root \\ src \\ test \\ utils\\ reporting.ts\n\n```js\nimport { World } from \"@cucumber/cucumber\";\nimport { page } from \"../steps/hooks\";\n\n// 테스트 리포트에 스크린샷을 추가하는 함수\nexport async function addScreenshotToReport(this: World) {\n    this.attach(await page.screenshot({ fullPage: true }), 'image/png');\n}\n\n// 테스트 리포트에 코멘트를 추가하는 함수\nexport async function addCommentToReport(this: World, comment: string) {\n    this.attach(comment, 'text/plain');\n}\n```\n\n# 최종 설정은 이렇게 될 것입니다:\n\n\n\n\n![이미지](/assets/img/2024-05-15-QuickBDDUITestFrameworkwithPlaywright_3.png)\n\n# 테스트 실행\n\npackage.json에서 test 필드 값을 \"cucumber-js test\"로 설정하세요.\n\n```js\n \"scripts\": {\n    \"test\": \"cucumber-js test\"\n  },\n```\n\n\n\n터미널을 열고 (CTRL + J) `npm test`를 실행해주세요.\n\n이 명령을 통해 테스트가 실행됩니다.\n\n![이미지](/assets/img/2024-05-15-QuickBDDUITestFrameworkwithPlaywright_4.png)\n\n# 실행 보고서 유효성 검사\n\n\n\n루트 / 보고서 / 로 이동하셔서\n\n여기에서 최신 테스트 실행 보고서를 찾으실 수 있습니다.\n\n![보고서 이미지](/assets/img/2024-05-15-QuickBDDUITestFrameworkwithPlaywright_5.png)","ogImage":{"url":"/assets/img/2024-05-15-QuickBDDUITestFrameworkwithPlaywright_0.png"},"coverImage":"/assets/img/2024-05-15-QuickBDDUITestFrameworkwithPlaywright_0.png","tag":["Tech"],"readingTime":7},{"title":"루비 온 레일즈 앱을 커피스트라노Capistrano를 사용하여 로컬로동일 PC에서 다른 사용자에게 배포하기","description":"","date":"2024-05-15 10:39","slug":"2024-05-15-DeploymentofRubyonRailsappusingCapistranoLocallyFromoneusertoanotheronthesamePC","content":"\n\n<img src=\"/assets/img/2024-05-15-DeploymentofRubyonRailsappusingCapistranoLocallyFromoneusertoanotheronthesamePC_0.png\" />\n\n# 소개\n\n소프트웨어 개발에서 애플리케이션을 배포하는 것은 사용자가 이용할 수 있도록 하는 중요한 단계입니다. Capistrano는 배포 프로세스를 자동화하여 효율적이고 신뢰성있게 만드는 인기 있는 도구입니다.\n\n이 안내서에서는 Capistrano를 사용하여 로컬에서 Ruby on Rails 애플리케이션을 배포하는 단계를 안내합니다. 레일즈 앱 배포 방법을 배우면서 수행한 내용이며, 이런 단계를 따랐습니다.\n\n\n\n# 전제 조건\n\n시작하기 전에 다음 전제 조건을 확인하세요:\n\n- Ubuntu 터미널과 Capistrano 파일 구조에 대한 기본 지식.\n- Ruby on Rails가 PC에 올바르게 설정되어 있어야 합니다.\n- 두 사용자가 Rails 앱 디렉토리에 액세스하고 명령을 실행할 필요한 권한을 갖고 있어야 합니다.\n- SSH 키가 올바르게 설정되어 있어야 합니다.\n- Ubuntu에서 사용자 및 SSH 키 설정에 익숙해야 합니다.\n\n# 사용자 생성 및 SSH 설정\n\n\n\n- 새 사용자를 만드세요:\n\n```js\nsudo adduser newuser\n```\n\n- 사용자를 만든 후, 해당 사용자로 전환하세요\n\n```js\nsudo su - newuser\n```\n\n\n\n새 사용자에게 .ssh 디렉토리를 만들어야 합니다. Rails 앱을 배포하기 위해 ssh 키가 필요합니다.\n\n```js\n mkdir -p ~/.ssh\n```\n\n- 기존 사용자의 SSH 인증 키를 새 사용자의 .ssh 디렉토리로 복사해야 합니다. 여기서 ssh는 두 사용자 간 통신에 사용됩니다.\n\n```js\nsudo cp /home/existing-user/.ssh/authorized_keys /home/newuser/.ssh\n```\n\n\n\n- 또한, 새 사용자에게 소유권을 부여해 주세요\n\n```js\nsudo chown -R newuser:newuser /home/newuser/.ssh\n```\n\n- 새로운 사용자에게 sudo 권한을 부여하세요(관리자 권한을 가진 사용자로 로그인해야 함)\n\n```js\nsudo usermod -aG sudo newuser\n```\n\n\n\n- 이제 새 사용자로 전환할 수 있어요\n\n```js\nsu - newuser\n```\n\n- 이제 새 사용자의 SSH 구성 여부를 확인할 수 있어요\n\n```js\nssh localhost\n```\n\n\n\n- 만약 ssh가 연결되어 있다면 이제 다음과 같이 표시됩니다 :\n\n![Deployment of Ruby on Rails app using Capistrano Locally From one user to another on the same PC](/assets/img/2024-05-15-DeploymentofRubyonRailsappusingCapistranoLocallyFromoneusertoanotheronthesamePC_1.png)\n\n- 이제 배포 프로세스를 시작해봅시다. 레일즈 앱을 배포하려는 사용자를 엽니다 :\n\n# Gemfile 설정\n\n\n\n- 먼저 레일즈에서 Capistrano 젬을 설정하는 것이 첫 번째 단계입니다.\n\n다음을 개발 그룹 아래 Gemfile에 추가하십시오.\n\n```js\ngem \"capistrano\", \"~> 3.10\", require: false\ngem \"capistrano-rails\", \"~> 1.6\", require: false \ngem 'capistrano-rbenv', require: false   \ngem 'capistrano-puma', require: false\n```\n\n- 이제 다음 명령을 명령 줄에서 실행하여 추가 번들을 설치하십시오\n\n\n\n```js\n번들 설치\n```\n\n- 생성기를 실행하여 기본 구성 파일 세트를 만듭니다.\n\n```js\n번들 실행 cap 설치\n```\n\n# Capfile 구성\n\n\n\n- 루트 디렉토리에 있는 Capfile에서 다음 플러그인들을 주석처리 해제하세요.\n\n```js\nrequire \"capistrano/rbenv\" \nrequire \"capistrano/bundler\"\nrequire \"capistrano/rails/assets\"\nrequire \"capistrano/rails/migrations\" \nrequire \"capistrano/rails\" \nrequire \"capistrano/bundler\"\nrequire \"capistrano/puma\"\n```\n\n- 참고: 위의 플러그인은 앱의 요구 사항에 따라 다를 수 있습니다. 예를 들어, 여기서 패신저를 사용하는 경우 require \"capistrano/passenger\"를 추가해야합니다. 저는 사용하지 않기 때문에 추가하지 않아도 됩니다.\n\n# 설정 파일\n\n\n\n- `config/deploy.rb` 파일을 적절한 값으로 업데이트해주세요. 여기서는 cap loc 버전 3.18.0을 사용하며 `staging.rb`를 사용하여 배포하고 있습니다.\n- 프로젝트 요구 사항에 따라 구성을 사용자 정의해주시기 바랍니다.\n\n```js\nlock \"~> 3.18.0\"\nset :stage, :staging \nset :rails_env, 'test' \nset :application, '{앱 이름}' \nset :repo_url, 'git@github.com:당신의/github/url.git' \nset :deploy_to, '/home/{로컬 사용자명}/{배포할 애플리케이션 이름}' \nset :branch, '{배포하려는 브랜치}' \nset :rbenv_ruby, '2.7.7' \nset :default_env, { 'PATH' => \"#{fetch(:rbenv_path)}/shims:#{fetch(:rbenv_path)}/bin:$PATH\", 'RBENV_VERSION' => fetch(:rbenv_ruby) }\n```\n\n# 배포\n\n- `staging.rb` 파일에 로컬 호스트 IP를 추가하세요.\n\n\n\n```js\n서버 'localhost', 사용자: '{귀하의 로컬 사용자 이름}', 역할: %w{app db web}\n```\n\n- 이제 다음 명령을 사용하여 API를 로컬로 배포할 수 있습니다.\n\n```js\ncap staging deploy\n```\n\n- 이제 루비 온 레일 API가 로컬로 배포되었고 앱 폴더로 이동하여 버전을 확인할 수 있습니다. 현재 디렉토리로 이동한 후에 아래 명령을 실행할 수 있습니다.\n\n\n\n```js\nbin/rails s\n```\n\n- 특정 젬 설치 오류가 발생하면 ruby와 rails 간 버전 간의 충돌이 없는지 확인해보세요.\n\n이제 파일 구조가 다음과 같이 보일 것입니다 :\n\n![image](/assets/img/2024-05-15-DeploymentofRubyonRailsappusingCapistranoLocallyFromoneusertoanotheronthesamePC_2.png)\n\n\n\n\n# 결론\n\n축하합니다! Capistrano를 사용하여 로컬에 Ruby on Rails 애플리케이션을 성공적으로 배포했습니다. 이제 Rails 서버를 실행하고 애플리케이션에 액세스할 수 있습니다.\n\n# 팁\n\n- 배포 명령을 실행하기 전에 배포 구성을 항상 확인해보세요.\n- 배포 중 발생하는 오류를 해결하려면 로그와 구성을 확인하세요.\n- 프로젝트의 요구에 맞게 Capistrano 구성을 사용자 정의하세요.","ogImage":{"url":"/assets/img/2024-05-15-DeploymentofRubyonRailsappusingCapistranoLocallyFromoneusertoanotheronthesamePC_0.png"},"coverImage":"/assets/img/2024-05-15-DeploymentofRubyonRailsappusingCapistranoLocallyFromoneusertoanotheronthesamePC_0.png","tag":["Tech"],"readingTime":4},{"title":"Vite와 함께 하는 동적 모듈 연맹","description":"","date":"2024-05-15 10:38","slug":"2024-05-15-DynamicModuleFederationwithVite","content":"\n\n<img src=\"/assets/img/2024-05-15-DynamicModuleFederationwithVite_0.png\" />\n\n요즘은 Vite를 통해 React 마이크로 프론트엔드를 빌드하는 작업을 맡게 되었어요. 이 솔루션은 런타임에서 원격 모듈 URL을 동적으로 결정해야 했어요. 컴파일 시간이 아니라요.\n\n동적 모듈 연합은 새로운 도전이 아니에요. 웹팩으로 여러 번 구현되어 왔기 때문에 Vite로도 이를 하는 것이 더 쉬울 것이라고 생각했어요. 그러나 이 기능이 지원되지 않거나 문서화되지 않았다는 것에 놀랐어요.\n\n몇 일 동안 검색한 끝에 좋은 긴 GitHub 토론을 발견했는데 막다른 곳처럼 보였어요. 그렇지만 흥미로워서 계속 읽다가 어쩌면 해결책이 있어요.\n\n\n\n다이내믹 모듈 연합이 도움이 되는 여러 시나리오가 있습니다. 예를 들어, A/B 테스팅입니다. 집단에 영향을 주지 않고 일부 사용자를 위한 새 레이아웃을 테스트하고 싶은 경우를 상상해보세요. 이 작업을 수행하는 React 앱을 만들어 봅시다. 앞서 진행하고 싶은 사람들을 위해 작동하는 예제가 여기 있어요. https://github.com/lestersconyers/react-apps/tree/main/dynamic-module-federation\n\n## 설정\n\n이 예제에서는 호스트 앱과 A와 B의 2개의 원격 앱을 갖게 됩니다. 사용자가 사이트를 방문할 때, 어떤 원격 앱 콘텐츠를 표시할지 결정하기 위해 일부 최상급 로직을 사용할 것입니다.\n\n- 보통처럼 원격 앱 모듈 연합을 설정합니다. Vite와 함께의 표준 모듈 연합은 상당히 잘 문서화되어 있으므로 인터넷을 중복하지는 않겠습니다. 다만 여기에 설정 파일이 있어요.\n\n\n\n2. 호스트 앱의 App.tsx 파일에서 __federation__ 모듈에서 함수를 가져와주세요. 여기에서 마법이 일어납니다!\n\n3. setRemote를 사용하여 url을 반환하는 프로미스를 만들고, getRemote를 사용하여 해당 프로미스를 반환하세요. 이 프로미스는 런타임 시에 해결됩니다.\n\n4. 동적 원격 앱을 사용하세요.\n\n5. 마지막으로 호스트 앱의 vite.config.ts 파일에 더미 원격 항목을 추가하여 런타임 오류를 피하세요.\n\n\n\n모두 완료했습니다!","ogImage":{"url":"/assets/img/2024-05-15-DynamicModuleFederationwithVite_0.png"},"coverImage":"/assets/img/2024-05-15-DynamicModuleFederationwithVite_0.png","tag":["Tech"],"readingTime":2}],"page":"96","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}