{"pageProps":{"posts":[{"title":"오프라인 사용 가능한 웹 애플리케이션 개발하기","description":"","date":"2024-05-14 12:54","slug":"2024-05-14-DevelopingOffline-ReadyWebApplications","content":"\n\n![IMG](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png)\n\n네, 제목을 제대로 읽으셨어요. 대부분의 웹 애플리케이션에서는 네트워크 접근이 가능할 것이라는 내제적인 가정이 있습니다. 사이트가 서버 측 렌더링, 정적 생성 또는 브라우저를 통해 완전히 작성되었는지에 상관없이 HTML, CSS 및 JS는 네트워크를 통해 HTTP 요청을 통해 가져옵니다. 각 페이지가 로드될 때 추가 리소스를 가져오거나 타사 API와 통신할 수 있습니다. 네트워크 탭을 빠르게 살펴보면 사이트가 대화형임을 알 수 있습니다. Google Analytics 이벤트부터 Stripe 위젯, 버그 추적 소프트웨어까지, 단일 페이지가 사용자 입력 없이도 계속 네트워크에 액세스할 수 있습니다. 기본적인 가정에 도전했을 때 어떻게 해야 할까요? 네트워크가 사용할 수 없을 때 웹 개발자로서 사용자에게 어떻게 서비스를 제공할 수 있을까요?\n\n# Service Workers - 오프라인 문제에 대한 해답\n\n이 문제를 해결하기 위해 Google, Samsung, Mozilla 및 기타 회사들이 협력하여 2014년 5월에 서비스 워커의 W3C 초안을 처음 소개했습니다. 그 전에 기본적인 웹 워커를 살펴보겠습니다 - 주 프로그램의 “백그라운드\"에서 실행되는 JavaScript 파일입니다. 웹 워커는 자체 스레드를 가지고 있지만 주 JavaScript 스레드와 계속 통신할 수 있습니다. 이 별도의 스레드를 통해 주 프로그램의 코드 실행을 차단하지 않으면서 백그라운드에서 계산적으로 비용이 많이 드는 작업을 수행할 수 있으므로 사용자 경험을 방해하지 않습니다. 웹 워커는 현재 창과는 별개의 컨텍스트에서 실행되며 DOM이나 창 객체에 액세스할 수 없습니다.\n\n\n\n## 서비스 워커란\n\n서비스 워커는 귀하의 사이트와 제삼자 간에 프록시처럼 작동하는 전문화된 웹 워커입니다. 요청이 서비스 워커에 의해 가로채지며 응답은 그를 통해 라우팅됩니다. 서비스 워커는 원본과 경로 또는 패턴(URL의)에 바인딩되어 해당 원본에서 발생하는 이벤트(예: fetch)에 응답합니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_1.png)\n\n이 경로 또는 패턴은 서비스 워커의 범위와 관련이 있으며 등록된 경로 및 해당 경로 내의 모든 중첩된 경로를 포함합니다. 서비스 워커가 mysite.com/puppies/sw.js에서 등록된 경우 mysite.com/puppies/labs 및 mysite.com/puppies/boxers에 대해 작동합니다. 이는 서비스 워커가 실행되는 범위이며 한 범위에는 하나의 서비스 워커만 등록될 수 있습니다. 그러나 선택적으로 이 기본 범위를 좁힐 수 있습니다.\n\n\n\n웹 워커들과는 다르게, 서비스 워커들은 시간 제한이 있어서 밀리초 단위로 생성되어 작업을 수행한 뒤 소멸될 수 있습니다. 이러한 의도적으로 짧은 수명은 스크립트 내에서 전역 상태에 의존하는 것을 불가능하게 만듭니다. 대신, 이들은 브라우저의 IndexedDB나 캐시 API에 기본 액세스 권한을 부여받아 데이터를 저장하고 검색할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_2.png)\n\n서비스 워커는 보완 기능으로서, 비공식 브라우저에서도 여전히 사이트의 모든 콘텐츠에 액세스할 수 있습니다. 그리고 그 보완 기능은 광범위합니다 — 캐싱, 백그라운드 동기화, 푸시 알림 및 오프라인 기능을 포함합니다.\n\n## 서비스 워커 생명 주기\n\n\n\n서비스 워커에는 라이프사이클이 있어 엔드 사용자의 브라우저와 상호작용하는 방식을 규정합니다. 서비스 워커가 등록되고 설치될 때까지 클라이언트로의 네트워크 흐름을 제어하지 않습니다. 심지어 서비스 워커도 해당 범위로의 다음 탐색으로 들어가기 전까지 요청을 프록시로 전달하지 않습니다.\n\n- 등록 — 이 첫 번째 단계는 사용자가 서비스 워커의 범위 내에서 URL을 입력할 때 발생합니다. 서비스 워커는 브라우저가 지원되는지 확인하고, 그렇다면 등록 함수가 호출되어 스크립트의 URL을 범위에 연결합니다. 대부분의 모던 브라우저에서 애플리케이션 탭의 개발자 도구에서 서비스 워커 등록을 확인할 수 있습니다. 주어진 서비스 워커에 대해 최대 한 번만 발생할 수 있는 단계입니다.\n- 다운로드 — 등록이 성공하면 서비스 워커가 클라이언트 브라우저로 다운로드됩니다. 사용자로부터 권한을 요청하지 않고 백그라운드에서 조용히 진행됩니다. 업데이트 후 다운로드가 진행되면 이전 서비스 워커 코드와 최신으로 다운로드된 코드 간의 바이트 단위 비교가 이루어집니다. 다른 경우 설치가 진행됩니다.\n- 설치 — 새로 다운로드된 서비스 워커 파일이 있으면 설치가 시작됩니다. 범위로 처음으로 서비스 워커가 다운로드된 경우 즉시 활성화됩니다. 업데이트 이후 설치가 발생하면 즉시 활성화되지 않고 대기합니다.\n- 대기 — 이는 업데이트 중에만 발생합니다. 이전 서비스 워커는 클라이언트의 프록시로 계속 작동하며 현재 서비스 워커를 사용하는 웹 페이지가 더 이상 없을 때까지 기다립니다. 그러나 대기 기간을 건너뛰기 위해 특정 함수를 호출함으로써 대기를 우회할 수도 있습니다.\n- 활성화 — 대기 또는 설치 직후에 활성화 이벤트가 발생하며 그 순간 캐시를 정리하거나 다른 작업을 실행할 수 있습니다.\n- 업데이트 — 사용자가 서비스 워커의 범위 내 페이지로 돌아가거나 등록 함수가 호출되거나 이벤트가 발생하지만 지난 24시간 동안 업데이트가 발생하지 않은 경우 업데이트가 발생합니다. 업데이트 중에 단계 2~5가 반복됩니다 (단계 2, 3은 기울임꼴로 표시됨).\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_3.png)\n\n## 서비스 워커가 오프라인 웹 사이트를 가능하게 하는 방법\n\n\n\n서비스 워커는 프록시로 작동합니다. 이 서비스 워커는 fetch 이벤트에 접근을 제공하여 다양한 조건에 따라 애플리케이션의 동작을 변경할 수 있게 해줍니다. 또한 강력한 캐싱 API를 가지고 있습니다.\n\n뉴욕시에 사는 사용자라고 상상해봅시다. 지역 유기농 식품을 판매하는 웹사이트를 둘러보고 지하철에 올라탔더니 신호가 끊겼습니다. 갑자기 고장난 웹페이지가 보입니다. 사이트를 새로고침해봐도 고장나 있습니다. 뒤로 가기 버튼을 눌러봐도 여전히 고장났습니다. 서비스가 없다면 브라우저의 HTTP 요청은 어떤 API에도 전달되지 않습니다. 페이지가 로드되지 않고, 양식이 전송되지 않습니다 — 오프라인 상태입니다. 이런 상황을 우리는 모두가 사용자로서 경험해봤습니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_4.png)\n\n이제 이 웹사이트가 서비스 워커를 활용한다고 상상해봅시다. 이제 지하철에 들어가서도 웹사이트를 계속해서 둘러볼 수 있습니다. 경험은 매끄럽습니다 — 하지만 숨긴 데이터 불일치가 있을 수 있습니다. 양식을 제출해보려고 하면 오프라인임을 알려주고 나중에 다시 시도하라는 메시지가 표시됩니다 (PWA를 통해 연결이 다시 활성화되면 이 양식이 전송될 수 있습니다, 아래 참조). 바 현황을 한번 봐보시면, 맞습니다 — 오프라인입니다. 언제 그런 일이 발생했을까요?\n\n\n\n사용자에게 완벽한 경험이 아니더라도, 고장난 웹페이지보다 훨씬 나은 것입니다. 특히 이는 블로그와 같이 다양한 상호작용이 불필요한 사이트에 이상적입니다. 이는 서비스 워커 캐시를 활용하여 구현됩니다. 네트워크 요청이 전송되면 서비스 워커가 데이터나 페이지를 캐시할 수 있습니다. 네트워크 연결이 끊어진 경우, 캐시로부터 해당 페이지를 제공하여 사용자에게 더욱 편리한 경험을 제공할 수 있습니다.\n\n# 서비스 워커와 PWA\n\n우리는 이미 서비스 워커가 최종 사용자에게 오프라인 접근성을 제공하는 방법을 명확히 알아보았습니다. 그런데, 그 외에도 어떤 일을 할 수 있을까요? 이것은 관련 개념인 점진적 웹 애플리케이션(Progressive Web Applications, PWAs)로 이어집니다.\n\nPWA는 웹 기반 앱이지만 기기에서 네이티브 애플리케이션과 유사한 경험을 제공합니다. 다른 웹사이트와 마찬가지로 기본적인 HTML, CSS, JS로 작성되어 창에 액세스할 수 있고 API에 네트워크 요청을 보낼 수 있습니다. 그러나 다른 웹사이트에는 없는 강력한 기능이 여러 가지 있습니다.\n\n\n\n## PWA를 설치할 수 있습니다\n\n일반 웹사이트와는 달리 PWA는 웹 앱 매니페스트의 명세에 따라 설치할 수 있습니다. 이를 통해 브라우저에 설치할 방법을 알려줍니다. 매니페스트에는 설치된 PWA의 경험을 사용자 정의하는 데 많은 특성을 포함할 수 있습니다.\n\n또한, 설치된 PWA는 앱과 같이 기기에 아이콘이 표시됩니다. 브라우저에 액세스하지 않고도 실행할 수 있으며 독립적인 애플리케이션으로 작동합니다. 어떤 경우에는 앱 스토어에서 직접 설치할 수도 있습니다.\n\n## Service Workers가 PWA와 통합되는 방법\n\n\n\nPWA의 많은 기능은 서비스 워커 덕분입니다. 서비스 워커는 PWA에서의 외부 요청을 위한 프록시 역할을 계속하며, 브라우저에 의해 활성화되어 사용자가 PWA와 상호 작용하지 않아도 백그라운드에서 실행될 수도 있습니다.\n\n서비스 워커의 양방향 통신과 프록시 기능의 존재는 다양한 유용한 기능을 제공합니다.\n\n- 브라우저를 통해 구독한 사용자에게 푸시 알림을 보내고, 이를 서비스 워커를 통해 클라이언트 장치에 표시할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_5.png)\n\n\n\n- 사용자가 응용 프로그램과 상호 작용하지 않을 때 배경에서 사이트 상태를 업데이트합니다. 예를 들어, 사용자가 응용 프로그램을 열 준비 중인 경우에 계산이 많이 필요한 엔드포인트를 호출하여 수분이 끊김없이 이루어지도록 합니다.\n- 연결 가능 상태가 되면 보낼 메시지를 저장합니다.\n- 연결이 실패할 때 표시할 정적 웹페이지의 캐시된 버전을 보관합니다.\n- 연결 상태에 따라 UI의 수분을 변경합니다. 예를 들어, 동적 전자 상거래 사이트를 구축 중이라면, 장바구니의 마지막 알려진 버전, 사용자의 기본 프로필 및 기타 쉽게 저장할 수 있는 정보를 표시합니다.\n\n이러한 예들은 PWA가 기본 웹 애플리케이션보다 신뢰성이 높고 성능이 우수한 것을 보여줍니다. 캐싱 API와 서비스 워커를 통해 제공되는 양방향 통신은 많은 개선을 제공하기 때문에 PWA가 왜 더 보급되지 않는지 궁금할 정도입니다...\n\n## 아니면 그렇지 않나요?\n\n이 기사를 통해 PWA에 대해 처음 들었거나 기기에 PWA가 하나도 설치되지 않았다면, 모든 브라우저에서 지원되지 않고 모든 기기에서 풀 네이티브 기능을 갖추고 있지 않기 때문일 것입니다 (Apple씨, 여기서 얘기하는 건 당신입니다). 이것은 새로운 개념이 아닙니다. 2007년에는 스티브 잡스가 처음으로 \"웹 2.0 앱\"을 대중화하고 첫 번째 iPhone을 출시하면서 네이티브 앱을 쉽게 지원하지 않았습니다. Forbes가 후에 그것을 그의 가장 큰 실수라고 표현하기도 했습니다. 그 당시 이러한 웹 애플리케이션은 Facebook 및 기타 회사에 의해 개발되었지만, 그들의 성능은 단순히 네이티브 앱과 비교할 수 없을 정도로 좋지 않았습니다. 이것은 대부분 현재 서비스 워커가 제공하는 능력 부족 때문이었습니다.\n\n\n\n![개발 중인 오프라인 준비 웹 애플리케이션](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_6.png)\n\n애플은 빠르게 방향을 바꿨어요. 오늘날, 그들이 애플 스토어에서 누적된 수익을 보호하기 위해 PWA에 대한 완전한 네이티브 지원을 제공하는 데 느리게 움직인 것으로 추정됩니다. 애플 제품을 사용해본 적이 있다면, 하나의 기기를 구입한 후 애플 제품이 바이러스처럼 자동으로 늘어난 것을 알 수 있을 거에요 — 헤드폰, 컴퓨터, 코드, 시계, 아쉽게도 앱까지. 제가 사용하는 것도 정말 그랬어요. 모두가 매끄럽게 함께 작동하기 때문에 더 편리하죠. 그러나 이에는 PWAs를 완전히 활용할 기회를 놓치는 것과 같은 단점이 따릅니다.\n\n애플과 사파리를 제외하고 파이어폭스도 PWAs에 대한 완전한 지원을 채택하는 데 더 느렸어요. 실제로 오늘날까지도 iOS에서 PWA에 대한 지원이 없습니다. 크로미엄 기반 브라우저는 다른 어떤 브라우저보다 빨리 PWA를 지원했어요. 이는 구글 엔지니어들이 2015년에 처음으로 'Progressive Web Application'이라는 용어를 만든 것이기 때문에 놀라운 일이 아니에요.\n\n지난 시간 동안 완전한 채택이 느리게 진행되어 왔지만, 상황이 빠르게 변화하고 있습니다. 올해 초 애플은 일부 기기에서 푸시 알림을 허용하기 시작했어요. 게다가 서비스 워커가 지속적으로 개선되고 새로운 기능들이 계속해서 제공되고 있어요.\n\n\n\n이것이 미래의 방향이 될 수 있을까요? 결국, 네이티브 응용 프로그램을 웹사이트와 연결할 때 전용 프로그래밍 언어와 생태계를 왜 굳이 사용해야 할까요? 기본 웹 도구를 사용하고 사용자에게 향상된, 거의 네이티브 경험을 제공할 수 있기 때문에요. 단점과 위험도 있고, 네이티브 앱은 여러 면에서 우위를 지니고 있지만요. 그러나 웹 기술과 속도가 계속 발전함에 따라, 근시일안에 많은 프로그레시브 웹 앱을 더 많이 보게 될 것이라 예상합니다.\n\n# Stackademic\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 박수를 보내주시고 저자를 팔로우해주시길 바랍니다! 👏\n- 트위터(X), 링크드인, 유튜브에서 팔로우해주세요.\n- Stackademic.com 방문하여 전 세계에서 무료 프로그래밍 교육을 민주화하는 방법에 대해 더 많은 정보를 얻으세요.","ogImage":{"url":"/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png"},"coverImage":"/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png","tag":["Tech"],"readingTime":7},{"title":"자바스크립트에서 간단한 반환과 프로미스 반환의 차이","description":"","date":"2024-05-14 12:53","slug":"2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS","content":"\n\n자바스크립트에서 단순 반환과 프로미스 반환은 서로 다른 목적을 가지고 있어요.\n\n## 단순 반환:\n\n함수에서 값을 직접 반환할 때, 이는 동기 작업입니다. 함수가 실행되고 결과를 즉시 반환해요.\n\n![이미지](/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png)\n\n\n\n## 아래는 코드 분석입니다:\n\n1. 함수 정의: 두 개의 매개변수 a와 b를 받는 add라는 함수를 정의합니다.\n\n2. 반환문: add 함수 내에서 a와 b의 합을 반환하는 return a + b;를 사용합니다.\n\n3. 함수 호출: 그런 다음 매개변수 10과 20을 사용하여 add 함수를 호출합니다.\n\n\n\n4. 결과 저장: 반환된 값(10과 20의 합인 30)이 result 변수에 저장됩니다.\n\n5. 출력: 마지막으로, 우리는 결과값 30을 콘솔에 출력합니다.\n\n단순하고 동기적입니다. 함수는 값을 즉시 반환합니다.\n\n# Promise Return:\n\n\n\nPromise는 비동기 작업에 사용됩니다. 지금이나 미래에 사용할 수 있는 값이나 결코 사용할 수 없는 값을 나타냅니다. 함수가 Promise를 반환하면 비동기 작업을 수행하고 그 작업의 결과에 따라 Promise를 해결하거나 거부할 수 있습니다.\n\n![Promise Image](/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_1.png)\n\n이 코드에서:\n\n- reject()에 new Error(\"Strings are not equal\")를 인수로 추가하여 오류에 대한 자세한 정보를 제공했습니다.\n- catch 블록에서 (error)를 콜백 함수의 인수로 추가하여 오류 객체를 캐치하고 해당 메시지를 기록했습니다.\n\n\n\n이제 코드가 오류 없이 실행되고 적절한 출력을 제공해야 합니다. str1과 str2가 동일한 경우 \"Success message. Both names are equal.\"을 출력합니다. 그 외에는 \"Error: Strings are not equal\"을 출력합니다.\n\n## 차이점:\n\n실행 컨텍스트:\n\n- 간단한 반환: 동기적으로 실행됨.\n- Promise 반환: 비동기 실행을 허용함.\n\n\n\n비동기 작업 다루기:\n\n- Simple return: 비동기 작업을 처리할 수 없습니다.\n- Promise return: 특별히 비동기 작업을 처리하기 위해 설계되었습니다.\n\n사용 방법:\n\n- Simple return: 동기 작업에 사용됩니다.\n- Promise return: 비동기 작업에 사용됩니다.","ogImage":{"url":"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png"},"coverImage":"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png","tag":["Tech"],"readingTime":2},{"title":"부적합한 프로그래머일지도 모르는 5가지 신호","description":"","date":"2024-05-14 12:51","slug":"2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer","content":"\n\n## 프로그래밍 의견\n\n![프로그래밍](/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png)\n\n아무도 완벽하지 않으며 아래 목록 중 하나 또는 두 개의 항목이 모두 해당될 것입니다. 그러나 그 중 세 가지 이상이 해당된다면, 스스로를 비판하거나 다른 일을 찾아보는 것이 좋을 수도 있습니다.\n\n프로그래밍은 오랜 시간 약한 조건과 많은 스트레스 아래에서 가끔 열심히 할 필요가 있으므로 그것을 즐기지 않는다면 의미가 없습니다. 거기에 이르기까지의 교육 과정은 김이며, 실제로 좋아지려면 십 년의 경험이 필요합니다. 처음부터 그런 감정이 느껴지지 않는다면, 다른 것을 찾아보는 것이 좋은 이유가 될 수 있습니다.\n\n\n\n우리는 더 많은 우수한 프로그래머가 필요해요. 프로그래밍은 인지적 프로세스를 자동화하며, 이러한 합리화는 현재 세상에서 진보의 주요 원동력이자 번영의 주된 요인이에요. 제 시선에서 모든 프로그래머는 우리의 존경을 받을 만한 영웅이에요.\n\n당신이 하는 일에 대한 오피서, 신사, 데이터 전사가 되어주세요.\n\n프로그래밍은 일자리가 아니에요. 이는 일종의 사명이에요. 빠르게 돈을 벌 수 있는 다른 방법이 있지만, 프로그래밍은 오늘날 일의 가장 높은 가치 중 하나로 사회에 봉사하는 것이기도 해요.\n\n그러니 당신이 프로그래머라 자부심을 갖지만 오만해지지 마세요. 당신은 사회의 종복이며, 기계가 읽을 수 있는 책을 쓰고, 스크롤을 통해 작동되는 로프의 골렘을 프로그래밍하는 현대적 수도사이기도 해요.\n\n\n\n당신이 되어야 하는 사이버 수도승은 겸손과 자발성, 자신의 한계를 이해하는 것뿐만 아니라 프로그래밍보다는 예술과 철학, 윤리와 정치를 필요로 합니다. 또한 개인으로서와 창조적인 힘으로서 사회에서의 역할에 대한 인식도 필요합니다.\n\n이것과 자아가 충돌하지 않을 수도 있습니다. 자아는 자신의 가치를 알아야 하며, 당신의 의견에서 벗어나는 것에 확신을 가져야 합니다. 하지만 납득할 수 있고 생각을 바꿀 수 있는 능력 또한 이 중요합니다. 당신이 소왈되지 않은 자아를 가지고 있을 때만 이 위대함을 얻을 수 있습니다.\n\n만약 이 이상적인 것을 달성한다면, 당신은 좋은 프로그래머입니다. 목표는 이를 달성하기 위한 길입니다.\n\n그래서 여기 목록입니다:\n\n\n\n- 프로그래밍을 즐기지 않아요.\n- 참고 자료, 라이브러리 및 설명서를 읽지 않고, 그냥 주물러버려요.\n- 자기를 돌아보지 않고, 자신이나 자신의 프로그램, 사용 가능한 도구에 대해 자기비판이 없어요.\n- 듣는 모든 말을 믿어요. 스스로 생각하지 않고 해결책을 찾지 않아요.\n- \"그렇다고?\" 라는 질문을 하지 않아요. 과학적인 작업을 하지 않아요.\n- 자신의 프로그램을 오류로 테스트해보지 않아요.\n- 해결하려는 것이 이미 존재하는지 확인하려고 하지 않아요.\n- 기능의 작은 부분만 사용하려 할 때도 프레임워크를 사용해요.\n- 유행과 이데올로기에 영향을 받아요 - \"이달의 패러다임\".\n- 다른 사람의 코드를 테스트하지 않고 신뢰해요.\n- 필요하지 않은 자원인 CPU 및 처리 시간을 낭비해요.\n- 문제에 합리적인 알고리즘을 찾지 않아요.\n- 시스템의 하드웨어를 무시하고, 다른 방법으로 쉽게 할 수 있는 것도 있음에도 특히 취약한 작업을 해요.\n- 어떤 컴퓨터 아키텍처에서 작업하는지에 대한 이해가 없으며, 자부심을 갖고 있어요 (\"HLL 무지\").\n- 문제 해결에 집중하는 대신 힙 이데올로기를 사용해요 (\"OOP Mad Cow Disease\").\n- 형태의 중요성을 높이는 태도\n- 시스템을 이해하지 못하고 스스로 시스템 기능을 구현하려 하면 대개 실패합니다.\n- \"최적화\"를 무시해요.\n- 어셈블리에 관심을 둬요.\n- 디버거를 사용하는 방법을 모르겠어요.\n- 프로그램을 역공학적으로 분석해본 적이 없고, 그에 대한 호기심이 없어요.\n- 그냥 그 때 표준으로 인해 일을 하지만 그것에 대해 비판적으로 생각하거나 다른 사람과 의견을 교환하지 않아요. 요약하자면, 반성이 부족해요.\n- 자신의 도구의 한계 및 사용된 언어, 알고리즘, 시스템의 강점과 약점에 대한 지식이 전혀 없어요.\n- 목적지에 빨리 도착한다고 생각해서 항상 최적의 경로를 선택해요.\n- 세심하고 철저하게 일하지 않고, 어질어질하게 일해요.\n- 새로운 사람들이나 유지보수 담당자 앞에서 오만하게 행동하며 도우려 하지 않아요. 의자를 통해서 음해하고 협조적이지 않은 경력의 사고방식도 포함돼요. 안타깝게도 일반적이에요. 하지만 그렇게 일할 수 없어요. 누구든 그런 사람과 일할 수 없어요.\n- 일을 마음대로 처리하지 않고, 의도적으로 암호화된 코드로 직업을 안전하게 만들어요. 만약 필요하거나 아프다면 더 나은 사람으로 대체할 기회나 자리를 주지 않습니다. 이를 간단히 아 불효한 행동이라고 부릅니다. 질질짜는 질질짜기 대신에 실질적인 안전이 품질을 통해 실현돼요.\n- 일을 속이고, 자립적으로 결점을 드러내거나 인정하지 않아요. 스스로에게 대안을 제시하지 않아요.\n- 엔지니어로서의 자질이 당신에게 말하지만, 관리부와의 대면에서 등을 빼지 못할 때가 있어요. 이것은 종종 프로젝트의 파괴적 결과나 더 나쁜 일로 이어지곤 해요. 챌린저의 엔지니어들은 발사를 거부해야 했어요. 그 추운 날, 그들의 거부로 인해 일곱 명이 불필요하게 사망하게 됐어요. 나쁜 프로그래머들은 용기가 없고 직장에 대한 두려움이 있어요.\n- 경우에 따라 결론을 내릴 대신, 자격 없는 사람들이 무엇을 해야 하는지 지시하는 것을 허용해요. 프로그래머와 엔지니어로서, 살아가야 하는 엄청난 책임이 있어요. 혹은 그 분야에 위치할 자격이 없는 경우도 있어요.\n- 저지른 실수를 인정하지 않고, 오히려 숨기고 감추려 해요. (BOfH 현상)\n- 교육을 이어가지 않고, 새로운 것을 배우거나 시도할 의지가 없어요. 또한 능동적인 태도를 나타내지 않아요. 상투적인 길을 시도해보지 않아요.\n- 두려움.\n\n위 목록에 속하지 않는 것은 여러분의 프로그램 중 하나에 오류가 있다는 것이 아니에요. 모든 프로그램에는 오류가 있어요. 또한 예상보다 더 오랜 시간이 걸리는 것 역시 정상적이에요.\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n\n\n- 작가에게 박수를 보내 주시고 팔로우도 부탁드립니다! 👏\n- 팔로우하기 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png"},"coverImage":"/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 GraphQL 대 REST API 포괄적 가이드","description":"","date":"2024-05-14 12:50","slug":"2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide","content":"\n\n\n![그래픽](/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png)\n\nGraphQL 또는 REST API를 React 기반 애플리케이션에 사용할지 결정하는 것은 매우 중요합니다. 이 결정은 앱의 성능, 확장 가능성, 데이터 처리 효율성 및 개발 수명주기에 도입되는 복잡성 수준에 심각한 영향을 미칩니다. 이 포괄적인 가이드는 두 가지의 차이점을 명확히하고 정보를 얻을 수 있는 선택을 도와줄 것으로 기대됩니다!\n\n# REST API란 무엇인가요?\n\nREST (Representational State Transfer)는 웹 개발에 사용되는 아키텍처 스타일로, 클라이언트-서버 접근 방식을 사용합니다. 서버는 클라이언트가 요청한 리소스의 표현을 제공합니다. 리소스는 URL로 식별되며 이러한 리소스는 POST, GET, PUT, DELETE와 같은 HTTP 방식으로 표시되는 CRUD 작업을 사용하여 조작할 수 있습니다. 최근 몇 년간 REST API의 활용이 많이 증가했습니다.\n\n\n\n\n```js\n// REST API를 사용하여 데이터 가져오기\nfetch(\"https://api.example.com/items\") \n  .then(res => res.json())\n  .then(data => console.log(data));\n```\n\n위 예시에서는 REST API 엔드포인트 /items에 대한 호출이 해당 항목들을 JSON 형식으로 반환합니다.\n\n# GraphQL이란?\n\n2015년 Facebook에서 개발된 GraphQL은 REST API에 대안으로 효율적이고 선언적이며 유연한 데이터 쿼리 언어입니다. 이를 통해 클라이언트는 서버에서 어떤 데이터가 필요한지 정확히 지정하고 원하는 방식으로 가져올 수 있어, REST API와 관련된 오버-패칭 또는 언더-패칭 문제를 제거합니다.\n\n\n\n```js\n// GraphQL을 사용하여 데이터를 가져옵니다\nfetch('/graphql', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    query: `{ \n      items { \n        id, \n        name \n      } \n    }`\n  })\n})\n.then(res => res.json())\n.then(data => console.log(data.data));\n```\n\n위의 예제에서 요청의 query 속성은 GraphQL 서버에서 각 항목의 id와 이름을 가져옵니다.\n\n# GraphQL과 REST API의 차이\n\n## 1. 데이터 가져오기\n\n\n\nREST API\n\nREST 기반 아키텍처에서는 귀하의 앱이 관련 데이터를 가져 오기 위해 다양한 엔드포인트로 여러 요청을 해야합니다.\n\n```js\nfetch(\"https://api.example.com/users/1\") // ID가 1인 사용자 가져 오기\n.then(/* */)\n\nfetch(\"https://api.example.com/users/1/posts\") // ID가 1인 사용자의 게시물 가져 오기\n.then(/* */)\n```\n\n위의 예시처럼 특정 사용자가 만든 데이터(게시물)를 가져 오는 것은 REST API에서 여러 네트워크 요청이 필요합니다.\n\n\n\nGraphQL\n\nGraphQL을 사용하면 관련 데이터를 하나의 요청으로 모아 가져올 수 있으며, 정확히 필요한 데이터만 가져와서 과다 또는 미비한 데이터 문제를 줄일 수 있어요.\n\n```js\nfetch('/graphql', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    query: `{\n      user(id: 1) {\n        name,\n        posts {\n          title,\n          body\n        }\n      }\n    }`\n  })\n})\n.then(/* */)\n```\n\n위 코드는 한 요청으로 사용자와 해당 사용자의 게시물을 가져오는 거에요.\n\n\n\n## 2. Over-fetching and Under-fetching\n\nREST API\n\nRESTful 서비스에서 응답의 모양과 크기는 서버에 의해 결정됩니다. 종종 endpoint가 충분한 정보를 제공하지 않아 추가 요청이 필요한 under-fetching이 발생하거나, 필요 이상의 정보가 전송되어 over-fetching이 발생할 수 있습니다.\n\nGraphQL\n\n\n\nGraphQL의 주요 이점 중 하나는 클라이언트가 필요한 데이터를 정확히 지정하여 over-fetching 또는 under-fetching을 피할 수 있다는 것입니다. 서버는 요청의 형태를 따르는 응답을 반환합니다.\n\n## 3. 버전 관리\n\nREST API\n\n버전 관리는 REST 기반 서비스에서 일반적입니다. 이는 API를 발전시키는 것이 어려워 새로운 API 버전이 처리할 필요가 있는 파괴적인 변경을 피하기 위함입니다.\n\n\n\nGraphQL\n\nGraphQL을 사용하면 서버는 자신의 기능을 공개하고 클라이언트는 필요한 요청을 구성하며, 이로 인해 버전 관리가 필요 없어집니다.\n\n## REST API와 GraphQL을 언제 사용해야 할까요?\n\nREST API를 사용해야 하는 경우:\n\n\n\n- 당신의 앱이 간단하거나 데이터 요구 사항이 복잡하지 않다면 REST API 설계에 더 익숙한 팀이 있다면 REST를 사용하세요.\n- 데이터가 자주 변경되지 않고 중첩된 엔티티를 포함하지 않는다면 REST를 사용하세요.\n\nGraphQL을 사용해야 하는 경우:\n\n- 애플리케이션이 중첩된 엔티티를 포함하거나 그들 사이에 복잡한 관계가 있는 경우.\n- 네트워크를 통해 로드되는 데이터를 줄이고 싶은 경우.\n- 앱이 애플리케이션 부하 및 코드베이스 크기 측면에서 확장될 것으로 예상되는 경우.\n\n마지막으로, GraphQL과 REST 중 어느 것을 선택할지는 프로젝트 요구 사항, 팀의 기술 수준, 데이터의 성격 등 여러 가지 요인에 달려 있습니다. 두 가지 방식에는 각각의 장점이 있으며 상황에 따라 어느 쪽이든 완벽하게 어울릴 수 있습니다. 이러한 주요 차이를 이해하면 프로젝트 성공에 중요한 결정을 내릴 수 있게 될 것입니다.\n\n\n\n# 만약 즐거우셨다면 박수와 구독을 잊지 마세요! 👏\n\n열정적인 건축가들의 디스코드 커뮤니티에 가입해보세요: [https://discord.gg/QyXEsb4C](https://discord.gg/QyXEsb4C)","ogImage":{"url":"/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기","description":"","date":"2024-05-14 12:49","slug":"2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues","content":"\n\n\n<img src=\"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png\" />\n\nJavaScript 코드 실행 방식에 대해 궁금했던 적이 있나요? 웹 브라우저 내에서 JavaScript 코드 실행은 단일 스레드로 이루어지며 비동기 작업들이 어떻게 조율되는지 흥미로운 여정을 안내합니다.\n\nJavaScript는 단일 스레드 내에서 작동합니다. 이는 한 번에 한 가지 작업만 수행할 수 있다는 것을 의미합니다. 그러나 재미있는 점은, 이 제약에도 불구하고 JavaScript가 네트워크 요청이나 setTimeout() 함수 호출과 같은 비동기 작업을 원할하게 다룰 수 있고 사용자 인터페이스가 멈추지 않는다는 것입니다.\n\n그렇다면, JavaScript는 이를 어떻게 성취할까요?\n\n\n\n\n자바스크립트는 사용자 인터페이스가 반응성을 유지하는 동안 비동기 작업을 관리하기 위한 병렬처리 방식을 채용합니다. setTimeout()을 사용하여 네트워크 요청 또는 타임아웃과 같은 비동기 작업을 시작할 때, 자바스크립트는 이러한 작업이 완료될 때까지 기다리지 않습니다. 대신에 브라우저의 비동기 작업 처리를 담당하는 기본 메커니즘으로 위임합니다.\n\n이제 깊게 들어가 봅시다.\n\n자바스크립트 병렬처리 모델의 핵심은 이벤트 루프입니다. 이벤트 루프는 작업의 실행을 감독합니다. 이벤트 루프는 실행 스택과 작업 대기열(작업/콜백 및 마이크로 작업 대기열)을 지속적으로 모니터링하여 올바른 순서로 작업이 실행되고 주 스레드가 차단되지 않도록 합니다.\n\n작업 대기열은 비동기 이벤트에 응답하여 실행되도록 예약된 작업을 보관하는 곳입니다. 예를 들어 사용자가 버튼을 클릭하거나 setTimeout()으로 설정된 타이머가 만료될 때, 자바스크립트는 관련 작업을 작업 대기열에 추가합니다. 자바스크립트 병렬처리 모델의 중심 요소인 이벤트 루프는 실행 스택과 작업 대기열을 지속적으로 모니터링합니다. 실행 스택이 비어 있고 작업 대기열에 작업이 있는 경우, 이벤트 루프는 다음 작업을 선택하여 실행하고 해당 콜백 함수를 호출합니다. 이 과정은 계속 반복되며, 작업이 콜백 대기열에 추가되어 큐에 정렬된 순서대로 실행됩니다.\n\n\n\n자바스크립트는 작업 대기열 외에도 고우선 순위 작업을 처리하기 위한 마이크로태스크 대기열을 유지합니다. 마이크로태스크는 일반적으로 사용자 인터페이스를 업데이트하는 시간이 중요한 작업과 같은 작업에 사용됩니다. 마이크로태스크가 생성되면 마이크로태스크 대기열에 넣어집니다. 작업 대기열의 작업과 달리 마이크로태스크는 현재 실행 컨텍스트(예: 현재 함수)가 완료된 후 즉시 실행되며, 그 후에 제어가 이벤트 루프로 돌아갑니다. 이벤트 루프는 마이크로태스크를 작업 대기열의 작업보다 우선 처리하여 신속하게 처리합니다. 마이크로태스크 대기열의 모든 마이크로태스크가 실행된 후, 이벤트 루프는 나머지 작업을 처리하기 위해 작업 대기열로 돌아가며 동기적 및 비동기적 작업 사이의 균형을 유지합니다.","ogImage":{"url":"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png"},"coverImage":"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png","tag":["Tech"],"readingTime":2},{"title":"라이프사이클 후크Lifecycle Hooks에 대한 LWC","description":"","date":"2024-05-14 12:48","slug":"2024-05-14-LifecycleHooksinLWC","content":"\n\n\n![Lifecycle Hooks in LWC](/assets/img/2024-05-14-LifecycleHooksinLWC_0.png)\n\n라이프사이클 훅은 라이트닝 웹 컴포넌트(LWC)를 개발하는 여정에서 굉장히 중요한 부분입니다. 이들은 컴포넌트의 라이프사이클의 다양한 단계를 제어하고 응답하는 능력을 제공하여 Salesforce 생태계에서 웹 컴포넌트를 구축하는데 더 효율적이고 세밀한 접근법을 가능하게 합니다.\n\n이 블로그에서는 LWC 라이프사이클 훅의 세계에 대해 자세히 살펴보겠습니다. 이 훅이 무엇이고 왜 중요한지, 그리고 동적이고 반응성 있는 컴포넌트를 만들기 위해 효과적으로 활용하는 방법에 대해 탐구할 것입니다. LWC 여정을 시작한 지 얼마 안 된 분들이거나 기술을 향상하려는 분들, 이러한 훅을 이해하는 것이 강력하고 효율적인 라이트닝 웹 컴포넌트를 만드는 데 중요합니다.\n\n이 블로그를 통해 LWC에서 사용 가능한 다양한 라이프사이클 훅을 자세히 살펴보고, 이들의 구체적인 사용 사례를 논의하며, 실용적인 예제를 제공하여 실제 응용 가능한 내용을 파악하는 데 도움을 드리겠습니다. 이 여정의 끝에는 컴포넌트 라이프사이클 관리의 기술을 숙달하여 LWC의 전체 잠재력을 활용할 수 있는 지식을 갖추게 될 것입니다.\n\n\n\nLifecycle Hooks in LWC: Managing the Journey of a Lightning Web Component\n\n라이트닝 웹 컴포넌트(LWC)의 라이프사이클 훅\n\n라이트닝 웹 컴포넌트(LWC)는 Salesforce 플랫폼 내에서 동적이고 인터랙티브한 사용자 인터페이스의 구성 요소입니다. 그들의 잠재력을 완벽하게 활용하려면, 개발자들은 이러한 구성 요소들이 라이프사이클 동안 거치는 복잡한 단계를 이해해야 합니다. 이것이 바로 \"라이프사이클 훅(Lifecycle Hooks)\"의 세계입니다.\n\n# 라이프사이클 훅이란?\n\nLWC의 라이프사이클 훅은 개발자들이 컴포넌트의 여정의 다른 단계에서 개입할 수 있는 미리 정의된 메소드들입니다. 이러한 훅들은 컴포넌트의 라이프사이클에서 발생하는 특정 이벤트와 전환에 대응하고 제어하고 최적화할 수 있는 능력을 제공합니다. 이러한 훅들을 이해하고 효과적으로 사용하는 것이 견고하고 반응적인 컴포넌트를 만드는 핵심입니다.\n\n\n\n여기 몇 가지 중요한 라이프사이클 후크에 대한 간단한 개요입니다:\n\n- constructor(): 컴포넌트가 초기화되는 곳입니다. 기본값을 설정하고 일회성 설정을 수행할 수 있습니다.\n- connectedCallback(): 컴포넌트가 DOM에 추가된 후에 실행되는 후크입니다. DOM 조작 및 데이터 검색에 좋은 장소입니다.\n- renderedCallback(): 렌더링 후에 트리거되는 후크입니다. 렌더링된 DOM에 대한 지식이 필요한 작업에 이상적입니다.\n- disconnectedCallback(): 컴포넌트가 DOM에서 제거될 때 호출되는 후크입니다. 정리 작업 및 리소스 해제에 사용하세요.\n- errorCallback(): 렌더링 중에 오류가 발생하면 호출되는 후크입니다. 오류를 우아하게 처리할 기회입니다.\n\n# 라이프사이클 후크 흐름\n\n먼저 부모 constructor가 호출되고, 부모 connectedCallBack가 실행된 후, 자식 컴포넌트가 있으면 자식 constructor → connectedCallback → renderedCallback 순으로 진행되고 다시 부모 renderedCallback로 이동합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-LifecycleHooksinLWC_1.png)\n\n1. 생성:\n\n- `constructor()`: 컴포넌트 인스턴스가 생성될 때 실행되는 첫 번째 후크입니다. 변수를 초기화하고 기본 값 설정하는 곳입니다.\n\n주의하세요!\n\n\n\n생성자()\n\n- 컴포넌트의 인스턴스가 생성될 때 호출됩니다(init()와 비슷합니다).\n- 부모 컴포넌트에서 먼저 발생하며 부모에서 자식으로 흘러갑니다.\n- 부모 클래스 생성자인 LightningElement를 호출하려면 먼저 super()를 호출해야 합니다.\n- 컴포넌트 템플릿에서 요소에 액세스하려면 this.template을 사용하세요.\n\n```js\nimport { LightningElement } from 'lwc';\n \nexport default class LifeCycleHookParent extends LightningElement {\n  constructor() {\n    super(); // LightningElement 클래스 생성자를 호출합니다. console.log('Parent Constructor Called');\n    let con = this.template // 호스트 요소에 액세스합니다.\n    console.log(con);\n  }\n}\n```\n\n2. 초기화:\n\n\n\n- `connectedCallback()`: 컴포넌트가 초기화된 후에 이 훅이 호출됩니다. DOM 조작 및 데이터 검색에 이상적인 위치입니다.\n\n주의!\n\nconnectedCallback()\n\n- 컴포넌트가 DOM에 삽입될 때 호출됩니다.\n- 부모에서 자식으로 흐릅니다.\n- 데이터를 가져오고 캐시를 설정하며 이벤트를 수신하는 초기화 작업을 수행하는 데 사용됩니다.\n- 컴포넌트가 DOM에 연결되어 있는지 확인하려면 isConnected 메서드를 사용하세요.\n\n\n\n```js\nconnectedCallback(){\n  console.log('Parent Connected Call Back called');\n  let cb = this.template\n  console.log('is connected=> ' + cb.isConnected);\n}\n```\n\n3. 렌더링:\n\n- `renderedCallback()`: 이 훅은 컴포넌트의 초기 렌더링 후에 트리거됩니다. 요소와 상호 작용하는 것과 같은 렌더링된 DOM에 대한 지식이 필요한 작업에 적합합니다.\n\n주의하세요!\n\n\n\n\nrenderedCallback()\n\n- 컴포넌트가 렌더링 프레임워크를 완료한 후에 로직을 수행할 때 사용합니다. 이는 컴포넌트가 UI에 완전히 렌더링된 후에 호출됩니다.\n- 자식 컴포넌트에서 부모 컴포넌트로 흐름이 됩니다.\n- 컴포넌트는 여러 번 렌더링되어 렌더링 콜백을 추적하려면 isRendered 불리언 필드를 사용하세요.\n- 렌더링된 콜백 내에서 무한 루프로 이어지는 속성을 조심하세요.\n\n```js\nimport { LightningElement } from 'lwc';\nexport default class LifeCycleHookParent extends LightningElement {\n  isRendered = true // 컴포넌트가 렌더링되었는지 확인하기 위한 변수\n  renderedCallback() {\n    if (this.isRendered) {\n      console.log('부모 컴포넌트의 렌더링 콜백이 호출되었습니다');\n      this.isRendered = false\n    }\n  ?\n }\n```\n\n4. Reactivity:\n\n\n\n- 컴포넌트 내의 속성 또는 변수가 변경될 때마다 반응성 주기가 트리거될 수 있습니다. 이 주기 중에는 컴포넌트가 속성 변화를 확인하며, 변화가 감지되면 다시 렌더링되고 `renderedCallback`을 다시 호출합니다.\n\n5. 소멸:\n\n- `disconnectedCallback()`: 컴포넌트가 DOM에서 제거될 때 이 후크가 호출됩니다. 정리 작업이나 이벤트 리스너와 같은 리소스 해제에 뛰어난 장소입니다.\n\n주의하세요!\n\n\n\n\ndisconnectedCallback()\n\n- 문서에서 요소가 제거될 때 호출됩니다 (이벤트 리스너 제거, 시간 간격 제거 등).\n- Parent에서 Child로 이어집니다.\n- connectedCallback()에서 수행한 작업 정리에 disconnectedCallback()을 사용하십시오. 예를 들어, 이벤트 리스너 제거 등.\n- 메시지 채널 구독 취소 등에도 이 후크를 사용할 수 있습니다.\n\n6. 오류 처리:\n\n- `errorCallback()`: 렌더링 중 오류가 발생하면 이 후크가 호출됩니다. 오류를 우아하게 처리하고 적절한 메시지를 표시할 수 있는 기회를 제공합니다.\n\n\n\n\n알아두세요!\n\nerrorCallback()\n\n이것을 구현하여 하위 컴포넌트의 모든 오류를 캡처하는 오류 경계 컴포넌트를 만드세요.\n\n하위 컴포넌트의 라이프사이클 훅 또는 HTML 템플릿에서 선언된 이벤트 핸들러 중 발생한 오류를 캡처합니다.\n\n\n\n- 자식(하위) 컴포넌트에서 오류가 발생했을 때 호출됩니다.\n- errorCallback(error, stack) 함수에 두 가지 아규먼트가 전달됩니다. error 아규먼트는 JavaScript 네이티브 오류 객체이며, stack 아규먼트는 문자열입니다.\n\n```js\n//Child Component\nconnectedCallback(){\n  console.log('Child Connected Call Back called');\n  throw new Error('problem in child component connectedCallback')\n  }\n```\n\n```js\n//Parent component\nerrorCallback(error, stack){\n  console.log(error 메시지);\n  console.log('Stack: - ' + stack);\n}\n```\n\n이 플로우를 이해하고 각 후크의 사용법을 파악하는 것은 Salesforce 생태계에서 반응형, 효율적이고 인터랙티브 웹 컴포넌트를 효과적으로 관리하고 최적화하는 데 중요합니다.\n\n\n\n# 라이프사이클 훅이 왜 중요한가요?\n\n라이프사이클 훅은 여러 이점을 제공합니다:\n\n- 최적화: 적절한 시간에 개입하여 컴포넌트 렌더링을 최적화함으로써 성능과 응답성을 향상시킬 수 있습니다.\n- 상호작용: 적절한 라이프사이클 단계에서 사용자 작업에 응답함으로써 상호작용형 컴포넌트를 만들 수 있습니다.\n- 자원 관리: 라이프사이클 훅을 사용하여 효율적인 자원 관리가 가능해지며, 컴포넌트가 더 이상 필요하지 않을 때 이벤트 리스너를 해제하고 타이머를 정리할 수 있습니다.\n\n예시: 실용적인 사용 사례\n\n\n\n간단한 예제로 라이프사이클 훅의 중요성을 설명해보겠습니다. 카운트다운 타이머 컴포넌트를 구축 중이라고 상상해보세요. 라이프사이클 훅을 사용하는 방법은 다음과 같습니다:\n\n```js\nexport default class CountdownTimer extends LightningElement {\n    seconds = 10;\n\n    connectedCallback() {\n        this.timer = setInterval(() => {\n            if (this.seconds > 0) {\n                this.seconds--;\n            }\n        }, 1000);\n    }\n\n    renderedCallback() {\n        if (this.seconds === 0) {\n            clearInterval(this.timer);\n        }\n    }\n\n    disconnectedCallback() {\n        clearInterval(this.timer);\n    }\n}\n```\n\n이 예시에서 `connectedCallback`은 타이머를 설정하고, `renderedCallback`은 타이머가 0에 도달했을 때 UI를 업데이트하며, `disconnectedCallback`은 컴포넌트가 제거될 때 타이머가 중지되도록 보장합니다.\n\n자세한 내용은 아래 링크를 참조해주세요:\n\n\n\n읽어 주셔서 감사합니다 ☺️","ogImage":{"url":"/assets/img/2024-05-14-LifecycleHooksinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-LifecycleHooksinLWC_0.png","tag":["Tech"],"readingTime":6},{"title":"피해야 할 5가지 실수 웹 개발자로서","description":"","date":"2024-05-14 12:46","slug":"2024-05-14-AvoidThese5MistakesasaWebDeveloper","content":"\n\n\n![Avoid These 5 Mistakes as a Web Developer](/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png)\n\n우리는 모두 실수를 합니다. 배우고成長하며、경험을 쌓는 가장 효율적인 방법입니다. 실수를 돌아보고 그로부터 배우면 스스로를 향상시킬 수 있습니다.\n\n대부분의 사람들은 자신의 실수를 돌아보지 않습니다. 그들은 그 실수를 저지르지 않았어야 한다고 자책합니다. 다른 사람이 그들을 비난할 필요는 없습니다; 그들 스스로 힘을 줍니다.\n\n웹 개발자 경력 중에 백엔드 엔지니어가 범하는 십 가지 오류를 나열하겠습니다. 실수를 범하는 데는 현재 위치가 중요하지 않습니다. 우리는 경력 어디서든지 언제든지 실수를 합니다.\n\n\n\n\n# 실수 #1\n\n기술 부채. 지나친 공학. 종소리가 울리나요? 종종, 개발자들은 사용자가 응용 프로그램을 활용하는 방식을 이해하는 대신 기술적인 측면에 초점을 맞춥니다. 해당 요구 사항에 따라 코드를 작성하지 않습니다. 백엔드 엔지니어가 요구 사항을 기반으로 기술을 사용하면 필요한 노력과 비용을 크게 줄일 수 있습니다.\n\n대부분의 경우, 초보자들이 이 실수에 빠집니다. 분야에 새로 온 사람들은 사용자에게 효율적으로 제공되는 기술을 알지 못하기 때문에 기술적 부담을 줄이는 기술을 사용하지 않는 것입니다. 더 많은 기술과 처리가 필요할 때 응용 프로그램은 최종 사용자에게 느리게 나타납니다.\n\n어떤 분야, 취미 또는 습관에 새로 온 사람들은 프로세스를 지나치게 복잡하게 만들기 쉽습니다. 그러나 경력자들은 더 적은 기술을 사용하여 개발 및 사용자 시간을 절약하면서 노력과 비용을 줄입니다.\n\n\n\n더불어, 기술 부채는 읽기 어려운 코드를 나타냅니다. 다른 엔지니어들이 이해할 수 있는 로직을 작성하는 것이 개발의 첫 번째 규칙입니다. 이는 이러한 산업 표준 기술과 코딩 표준을 사용하거나 변수를 CamalCase 규칙으로 작성하는 것을 의미합니다.\n\n초보자들은 가능한 모든 것을 사용할 때 자부심을 느낍니다. 나중에는 동일한 선택이 응용 프로그램을 느리게 만들 때 머리가 아플 수 있습니다. 이로 인해 시니어들이 코드를 리팩토링해야 하며, 이는 시간 낭비입니다. 코드가 많아질수록 테스트 요구 사항과 버그 발생 확률이 증가합니다. 코드를 적게 작성하세요.\n\n자존심을 한쪽에 두고 필요한 기술만 선택하고 최고의 산업 표준을 준수함으로써 이러한 실수를 피할 수 있습니다. 프론트엔드 프레임워크와 라이브러리를 배울 때 이 실수를 저질렀습니다. 이에 따라 더 많은 코드, 더 많은 버그 및 대규모 리팩토링 비용이 발생했습니다. DRY, KISS 또는 YAGNI 표준을 따르세요.\n\n# 실수 #2\n\n\n\n내가 Udemy에서 React를 배우는 데 돈을 썼어. 그 스킬을 활용해서 모든 애플리케이션을 React로 만들어야겠지? 아니야. 모든 작업에 같은 기술, 라이브러리 또는 프레임워크를 사용하지 말아야 해. 이 프레임워크의 선택은 해결해야 하는 문제에 따라 다르니까.\n\nReact + Vite는 중급 웹 애플리케이션에 적합할 수도 있어. 그러나 성능 중심의 애플리케이션에는 적합하지 않아. 그럴 때는 성능을 향상시키기 위해 SolidJS, NextJS 또는 다른 프레임워크를 선택해야 해.\n\n주어진 작업에 따라 사용하는 기술을 바꿔. 선택한 언어인 JavaScript 같은 기본기는 튼튼히 갖추고 있고, 기술을 바꿔가며 학습해.\n\n하나의 기술에만 고수하지 마. 그것은 학습 능력을 제한하고 애플리케이션이 문제를 겪게 만들어. 나중에 그 기술을 바꿔야 하게 될 텐데, 처음부터 그렇게 할 수 있었을 텐데.\n\n\n\n# 실수 #3\n\n나쁜 의도를 가진 사람들은 데이터베이스를 공격하고 자격 증명을 도용하기 위한 엄청난 기술을 가지고 있습니다. SQL 인젝션은 흔한 기술 중 하나입니다. 그것이 빈번하다면, 사람들은 그럼에도 불구하고 여전히 그에 빠질까요? 네, 그렇습니다!\n\n이것은 시니어들이 데이터베이스를 수정하는 쿼리를 주입하는 것을 방지하는 코드를 작성할 수 있지만, 주니어들은 이 분야의 복잡함을 알지 못할 수 있기 때문입니다.\n\n![이미지](/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_1.png)\n\n\n\n2022년을 기준으로 웹 응용프로그램에서 발생한 전체 취약점 중 33%가 SQL Injection 공격으로 인한 것입니다. 원치 않는 문자열을 표준 쿼리와 연결함으로써 개인들이 DB에 액세스하고 일반적으로 DML 명령을 실행합니다.\n\n이러한 실수를 피하기 위해 일반화된 쿼리를 사용하는 대신 쿼리 내에 구체적으로 필요한 매개변수를 전달하세요. 모든 작업에 대해 표준 쿼리를 만들지 마세요. 그렇게 하면 새벽 2시 30분에 전화를 받을 수도 있습니다. 여러 개의 데이터베이스를 사용하고 모든 과일을 한 바구니에 넣지 마세요.\n\n다양성이 중요합니다. 코드 리뷰를 수행하세요. 특히 실행 중인 쿼리에 대해 연결된 문자열을 검증하세요. 제품 DB를 백업하면서 유지하세요.\n\n# 실수 #4\n\n\n\n미적인 면에 초점을 맞추는 사람이신가요? 사용성보다는 미학에 더 집중하는 것은 일반적인 초보 실수입니다. 초보 개발자는 사용자가 응용 프로그램을 어떻게 활용하는지에 대해 덜 주의를 기울이고 디자인을 지나치게 복잡하게 만들곤 합니다. UI/UX는 테스트 단계까지 아름답게 보일 수 있어요.\n\n사용자들이 귀하는 응용 프로그램을 이용하게 될 때 비즈니스 매출이 감소합니다. 왜냐하면 그 중 95%는 사용하지 못하기 때문이죠. 복잡성 때문이라고 해야겠어요. 사용자들은 간단한 디자인을 선호합니다. 이미 본 적 있는 인터페이스가 원하는 것이죠. 사람들은 습관에 집중합니다. 어떤 작업에도 덜 노력을 기울이고 싶어해요.\n\n사용자들은 새로운 패턴을 배우도록 강요하면 응용 프로그램을 사용하지 않을 거예요. 이전 디자이너 세대에 의해 시작된 특정 패턴에 익숙해진 인간들이 존재합니다. 젊은 사람들은 습관을 변경할 수 있지만, 대부분의 사용자는 그렇지 않을 겁니다.\n\n대중을 대상으로 디자인하고 구축하세요. 기존 표준과 사용자 패턴이나 행동을 활용해 인터페이스를 작성함으로써 이러한 실수를 피해보세요. 사용자가 최소한의 노력으로 제품을 구매할 수 있도록 해주세요. 소셜 미디어는 이러한 실수에 대한 해결책을 제시했습니다. 그것이 중독성이 있는 이유가 있지요. 더 적은 노력, 더 큰 보상.\n\n\n\n# 실수 #5\n\n일단 해결책을 만들고 코드를 작성해 보세요. 나중에 어떻게 될지는 확인해 볼 거에요. 변경 사항은 나중에 하기로 했잖아요? 그렇지 않아요. 처음부터 확장 가능성을 고려하세요. 버그와 오류를 수정하는 데 필요한 리팩토링과 개발 시간은 이상적이지 않아요.\n\n시작부터 문제를 해결하는 데 특정 기술을 선택하고, 가능한 미래 지표에 기반해 확장 가능한지 파악하세요. 예를 들어, 우리가 다양화하기로 결정한 후 React 성능 특정 작업을 사용할 수 있을까요? 아니에요. 그러면 사용해야 할까요? 아니요. 다른 기술을 선택하세요.\n\n대부분의 백엔드 엔지니어는 모든 문제에 같은 기술 세트를 사용해요. 개발자들은 가능한 트래픽과 데이터 거래를 고려하지 않아요. 2013년, 해커들이 Snapchat의 확장 가능성이 없는 코드베이스를 악용하여 수백만 명의 사용자 데이터에 접근했어요. 그런 일이 발생하지 않길 바라지 않겠죠.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png"},"coverImage":"/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png","tag":["Tech"],"readingTime":4},{"title":"대용량 JSON 객체를 효율적으로 업데이트하는 방법","description":"","date":"2024-05-14 12:45","slug":"2024-05-14-HowToUpdateLargeJSONObjectsEfficiently","content":"\n\n\n![JSON Patch](/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png)\n\nJSON Patch는 JSON 문서를 변경하는 방법을 설명하는 형식으로, JSON 데이터를 수정하는 방법을 보여주는 간결한 작업 지침의 시리즈를 사용합니다. 이 작업에는 새 데이터 추가, 이전 데이터 삭제, 기존 데이터 교체 또는 데이터 이동이 포함됩니다.\n\n## JSON Patch를 사용하는 이유\n\n대규모 웹 애플리케이션에서 클라이언트는 최신 데이터를 가져오거나 수정된 데이터를 서버에 제출하기 위해 서버와 자주 통신해야 합니다. 기존 방식은 모든 업데이트마다 전체 JSON 문서를 보내는 것이며, 실제 데이터의 일부분만 변경되었더라도 전송됩니다. 이는 네트워크 트래픽 증가, 네트워크 지연 증가, 서버 및 클라이언트 부하 증가로 이어집니다.\n\n\n\n\nJSON Patch는 네트워크 전송 양을 줄이고 데이터 업데이트 효율성을 향상시키는 효율적인 솔루션을 제공합니다. JSON Patch를 사용하면 클라이언트는 전체 JSON 문서가 아닌 수정이 필요한 데이터 부분만 전송할 수 있습니다. 서버가 JSON Patch를 수신한 후에는 해당 지침에 따라 해당 작업을 수행하여 데이터의 점진적 업데이트를 달성할 수 있습니다. 이는 네트워크 전송 양을 줄이고 네트워크 효율성을 향상시키며 서버와 클라이언트에 가하는 부하를 줄이는데 도움이 됩니다.\n\n## JSON Patch의 혜택은 무엇인가요?\n\n- 전송 양 감소: JSON Patch는 JSON 문서에 대해 수행할 구체적인 변경 사항만 전송하며 전체 JSON 문서를 전송하지 않습니다. 이는 특히 대규모 데이터 세트나 저속 네트워크 환경에서 네트워크 대역폭을 절약할 수 있습니다.\n- 점진적 업데이트: JSON Patch는 JSON 문서에 대한 점진적 업데이트를 지원합니다. 이는 전체 문서가 아닌 변경해야 하는 부분만 보낼 수 있기 때문에 실시간 애플리케이션 및 빈번한 업데이트가 필요한 상황에 유용합니다.\n- 유연성과 확장성: JSON Patch는 JSON 문서에서 수행할 수 있는 작업을 제한하지 않습니다. 필요에 따라 추가, 삭제, 교체, 이동 및 기타 작업을 수행할 수 있으며 필요에 따라 새 작업을 추가할 수도 있습니다.\n\n## JSON Patch는 어떤 작업을 지원하나요?\n\n\n\n1. 추가\n\nJSON 문서에 새로운 값을 추가하려면 경로와 추가할 값이 필요합니다.\n\n```js\n{ \"op\": \"add\", \"path\": \"/path\", \"value\": \"new value\" }\n```\n\n2. 제거\n\n\n\nJSON 문서에서 값을 제거하려면 제거할 값을 가리키는 경로를 지정해야 합니다.\n\n```js\n{ \"op\": \"remove\", \"path\": \"/path\" }\n```\n\n3. 대체\n\nJSON 문서의 값을 교체하려면 대체할 값을 가리키는 경로와 새 값이 필요합니다.\n\n\n\n```js\n{ \"op\": \"replace\", \"path\": \"/path\", \"value\": \"new value\" }\n```\n\n4. 이동\n\nJSON 문서에서 값을 다른 위치로 이동하려면 이동할 값의 경로와 대상 경로를 지정해야 합니다.\n\n```js\n{ \"op\": \"move\", \"from\": \"/oldpath\", \"path\": \"/newpath\" }\n```\n\n\n\n5. 복사\n\nJSON 문서에서의 값을 다른 위치로 복사하려면 복사할 값의 경로와 대상 경로를 지정해야 합니다.\n\n```js\n{ \"op\": \"copy\", \"from\": \"/oldpath\", \"path\": \"/newpath\" }\n```\n\n6. 테스트\n\n\n\nJSON 문서에서 값이 특정 값과 동일한지 확인하는 테스트를 수행하며, 이는 주로 작업이 성공적으로 실행될 수 있는지 확인하는 데 사용됩니다. 테스트할 값이 들어 있는 경로와 예상 값이 명시되어야 합니다.\n\n```js\n{ \"op\": \"test\", \"path\": \"/경로\", \"value\": \"예상 값\" }\n```\n\n## JSON 패치 사용 방법\n\n많은 개발 언어에서 JSON 패치 사양을 구현했습니다. JS 환경에서는 fast-json-patch 라이브러리를 사용할 수 있습니다.\n\n\n\n첫째로, npm 또는 pnpm을 사용하여 fast-json-patch를 설치해주세요:\n\n```js\nnpm install fast-json-patch\n또는 \npnpm add fast-json-patch\n```\n\nfast-json-patch 라이브러리를 성공적으로 설치한 후에는 제공되는 API를 활용하여 다음 기능을 수행할 수 있습니다:\n\n- 두 개의 객체를 비교하여 패치를 가져오기\n- 객체 변경을 관찰하고 변경사항을 감지할 때 패치를 생성하기\n- JS 객체에 단일 또는 여러 패치 적용하기\n- 패치 시퀀스를 유효성 검사하기\n\n\n\n- 두 객체를 비교하여 패치를 가져오기\n\n```js\nimport { compare } from \"fast-json-patch/index.mjs\";\n\nconst documentA = { user: { firstName: \"Albert\", lastName: \"Einstein\" } };\nconst documentB = { user: { firstName: \"Albert\", lastName: \"Collins\" } };\n\nconst diff = compare(documentA, documentB);\n\n/**\n * diff: \n * [ { op: 'replace', path: '/user/lastName', value: 'Collins' } ]\n */\n```\n\n2. 객체 변경 사항을 관찰하고 변경이 감지되면 패치를 생성합니다.\n\n```js\nimport { generate, observe } from \"fast-json-patch/index.mjs\";\n\nconst document = {\n  firstName: \"Joachim\",\n  lastName: \"Wester\",\n  contactDetails: { phoneNumbers: [{ number: \"555-123\" }] },\n};\nconst observer = observe(document);\ndocument.firstName = \"Albert\";\ndocument.contactDetails.phoneNumbers[0].number = \"123\";\ndocument.contactDetails.phoneNumbers.push({ number: \"456\" });\nconst patch = generate(observer);\n\n/**\n * patch：\n * [\n *  {\n *    op: 'replace',\n *    path: '/contactDetails/phoneNumbers/0/number',\n *    value: '123'\n *  },\n *  {\n *   op: 'add',\n *   path: '/contactDetails/phoneNumbers/1',\n *   value: { number: '456' }\n *  },\n *  { op: 'replace', path: '/firstName', value: 'Albert' }\n * ]\n */\n```\n\n\n\n3. JS 객체에 단일 또는 여러 패치 적용하기\n\n단일 패치 적용\n\n```js\nimport { applyPatch } from \"fast-json-patch/index.mjs\";\n\nconst documentA = { user: { firstName: \"Albert\", lastName: \"Einstein\" } };\nconst patchedResult = applyPatch(documentA, [\n  { op: \"replace\", path: \"/user/lastName\", value: \"Collins\" },\n]);\n\n/**\n * patchedResult[0]:\n * {\n *   newDocument: { user: { firstName: 'Albert', lastName: 'Collins' } },\n *   removed: 'Einstein'\n * }\n */\n```\n\n다중 패치 적용\n\n\n\n```js\nimport { applyPatch } from \"fast-json-patch/index.mjs\";\n\nconst document = {\n  firstName: \"Joachim\",\n  lastName: \"Wester\",\n  contactDetails: { phoneNumbers: [{ number: \"555-123\" }] },\n};\n\nconst patchedResult = applyPatch(document, [\n  {\n    op: \"replace\",\n    path: \"/contactDetails/phoneNumbers/0/number\",\n    value: \"123\",\n  },\n  {\n    op: \"add\",\n    path: \"/contactDetails/phoneNumbers/1\",\n    value: { number: \"456\" },\n  },\n  { op: \"replace\", path: \"/firstName\", value: \"Albert\" },\n]);\n\n/**\n * patchedResult[0]: \n * {\n *  newDocument: {\n *    firstName: \"Albert\",\n *    lastName: \"Wester\",\n *    contactDetails: { phoneNumbers: [{ number: \"123\" }, { number: \"456\" }] },\n *  },\n *  removed: \"555-123\",\n * }\n */\n```\n\n4. 패치 시퀀스 유효성 검사\n\n```js\nimport { validate } from \"fast-json-patch/index.mjs\";\n\nconst documentA = { user: { firstName: \"Albert\", lastName: \"Einstein\" } };\nconst validatedResult = validate(\n  [{ op: \"replace\", path: \"/user/lastName\", value: \"Collins\" }],\n  documentA\n);\n```\n\n만약 패치 시퀀스가 JSON Patch 사양을 충족하지 않으면, 검증 중에 JsonPatchError 예외 객체가 발생합니다.\n\n\n\nJSON Patch와 fast-json-patch가 소개되었어요! 관심이 있다면 JSON Patch를 직접 경험해보세요. 다른 해결책이 있으면 메시지를 남겨주세요.\n\nTypeScript는 멋지고 배울 가치가 있어요. TypeScript를 배우고 싶다면, 저를 팔로우해서 더 많은 TS와 JS 정보를 읽어보세요!","ogImage":{"url":"/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png"},"coverImage":"/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png","tag":["Tech"],"readingTime":6},{"title":"Next JS 렌더링 패턴 - 포괄적인 안내","description":"","date":"2024-05-14 12:43","slug":"2024-05-14-NextJSRenderingPatternsaComprehensiveGuide","content":"\n\n렌더링 패턴에 대한 정보는 문서, 자습서 또는 블로그 게시물 등이 끊임없이 있습니다. 그러나 시작하고 무언가를 구축하기 위해 얼마나 많은 지식이 필요할까요? 이 게시물에서는 무엇이 무엇인지 이해하고 렌더링이 Next.js에서 어떻게 작동하는지를 굳게 이해하는 데 도움이 되는 각기 다른 렌더링 패턴의 기본 내용을 요약하겠습니다.\n\n![image](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png)\n\n- 두 가지 주요 렌더링 패턴\n  - 클라이언트 측 렌더링\n    - 어떻게 작동합니까?\n    - 브라우저에서 구성 요소를 렌더링하는 방법?\n    - 데이터 가져오기:\n    - 이점:\n    - 제한 사항:\n  - SSG — 정적 사이트 생성\n    - 어떻게 작동합니까?\n    - 언제 사용해야 하나요?\n    - Next 13부터 페이지를 완전 정적으로 만들기:\n    - 동적 경로 생성 및 빌드 시간에 데이터 가져오기:\n    - 이점:\n    - 제한 사항:\n  - SSR — 서버 측 렌더링\n    - 어떻게 작동합니까?\n    - 유의할 사항:\n    - 페이지를 완전히 동적으로 만드는 방법:\n    - 이점:\n    - 제한 사항:\n  - ISR — 점진적 사이트 재생\n    - 어떻게 작동합니까?\n    - 이점:\n  - PPR — 부분 사전 렌더링:\n    - 부분 사전 렌더링 활성화:\n    - 필요성:\n    - 어떻게 작동합니까?\n- 기본 Next.js 렌더링 동작\n- 렌더링 위치 결정 방식\n\n# 두 가지 주요 렌더링 패턴\n\n\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해 드립니다.\n\n다음과 같이 렌더링 패턴을 넓게 분류할 수 있어요:\n\n- 클라이언트 측 렌더링\n- 사전 렌더링\n\n이름에서 알 수 있듯이 클라이언트 측 렌더링은 브라우저에서 구성 요소를 렌더링하는 것을 말해요.\n\n사전 렌더링은 다양한 방법으로 수행될 수 있어요.\n\n\n\n- SSG 또는 정적 사이트 재생성\n- SSR 또는 서버 사이드 렌더링\n- ISR 또는 증분 사이트 재생성\n- PPR 또는 부분 사전 렌더링 (Next 14에서 실험적 기능으로 제공됨)\n\n우리는 클라이언트 측 렌더링부터 시작해서 다양한 사전 렌더링 접근법으로 넘어갈 것입니다.\n\n# 클라이언트 측 렌더링\n\n## 어떻게 작동하나요?\n\n\n\nNext JS에서 클라이언트 구성 요소는 초기에 서버에서 사전 렌더링되고 DOM이 클라이언트로 전송되어 사용자가 볼 수 있는 내용이 제공됩니다. 그런 다음 JS 코드가 브라우저로 전송되어 DOM에 상호 작용을 추가합니다. DOM이 표시된 후 상호 작용을 천천히 추가하는 이 프로세스를 수분화(hydration)라고 합니다.\n\n## 브라우저에서 구성 요소를 렌더링하는 방법은 무엇인가요?\n\n파일의 시작 부분에 \"use client\" 지시문을 추가하면 됩니다.\n\n## 데이터 가져오기:\n\n\n\nNext JS 백엔드로 API 호출하거나 필요한 데이터를 가져오기 위해 외부 엔드포인트로 API 호출할 수 있어요.\n\n또는 Next JS 서버 컴포넌트에 정규 함수 호출을 할 수도 있어요.\n\n만약 백엔드도 Next JS로 작성되었다면 데이터베이스 액세스를 그 자체에서 수행할 수 있어요.\n\n## 혜택:\n\n\n\n- 페이지에 상호 작용성을 제공하기 위해 코드에 이벤트 리스너를 추가할 수 있어요.\n- 상태를 유지하고 라이프사이클의 다른 단계에서 특정 작업을 수행하거나 상태를 위한 중앙 저장소를 사용하는 훅을 사용할 수 있어요.\n\n## 제한 사항:\n\n- 콘텐츠 표시에 지연이 있을 수 있어요. JavaScript를 구문 분석한 후 HTML을 얻기 전에 사용자가 보여지는 내용에 대한 지연 때문이에요. 브라우저에서 렌더링 작업을 수행하는 동안 사용자가 빈 페이지를 보거나 상호 작용할 수 없는 페이지를 보게 될 수 있어요. 이는 JS 크기, 코드 내 존재하는 차단 작업(있는 경우), 사용자 디바이스의 제약 사항(인터넷 연결, 메모리 가용성)에 따라 다양합니다.\n- SEO 크롤러는 DOM 탐색을 통해 콘텐츠를 사용해 페이지를 색인화해요. JS가 로드되기를 기다려야 할 때 그들은 DOM을 스캔하기 전에 효과적으로 페이지를 색인화할 수 없어요.\n\n# SSG — 정적 사이트 생성\n\n\n\n## 어떻게 작동하나요?\n\n이 경우의 HTML은 빌드 시간에 생성되어 CDN(콘텐츠 전송 네트워크)에 저장되며, 사용자가 웹사이트/특정 경로에 접속할 때 캐시된 페이지의 버전을 제공합니다.\n\n## 언제 사용해야 하나요?\n\n만약 귀하의 웹사이트에 내용이 거의 변경되지 않고 한 번 오랜 기간에 한 번 변경을 계획하고 예약할 수 있다면, 빌드 시간에 해당 내용을 생성하는 것이 가장 좋습니다(서버에서 생성하지 않습니다).\n\n\n\nFAQ 페이지는 정적으로 생성될 수 있습니다. 회사 소개 페이지, 문서 페이지도 자주 다시 생성할 필요가 없으며 빌드 시간에 생성할 수 있습니다.\n\n## Next 13부터 페이지를 완전 정적으로 만드는 방법:\n\n페이지를 완전 정적으로 만들려면 (다시 말해, Next가 서버에서 렌더링할지 빌드 시간에 렌더링할지 결정하지 않고 우리가 스스로 결정하는 것), 관련 파일에서 동적 구성을 값이 force-static으로 내보냅니다:\n\n```js\nexport const dynamic = 'force-static';\n```\n\n\n\n## 동적 경로 생성 및 데이터 빌드 시간에 가져오기:\n\n이를 위해 generateStaticParams 메서드를 사용할 수 있습니다.\n\n이 블로그에서는 앱 라우터의 generateStaticParams가 페이지 라우터의 getStaticProps 및 getStaticPaths의 기능을 대체하는 방법에 대한 깔끔한 설명을 제공합니다.\n\n## 혜택:\n\n\n\n- 페이지의 내용이 자주 변경되지 않는 많은 페이지가 있다면, 서버에서 매번 미리 렌더링하는 것은 서버 부하를 늘립니다. 정적으로 생성하고 CDN에 저장하면 서버로부터 이 부하를 덜 수행할 수 있습니다.\n- 페이지 로드 시 콘텐츠가 즉시 제공되면 SEO 순위가 높아질 가능성이 높아집니다.\n\n## 제한 사항:\n\n- 데이터가 자주 업데이트되는 정적으로 생성된 페이지가 필요한 경우, 사용자에게 제공될 때 데이터가 오래되어 버릴 가능성이 있습니다.\n- 대량의 정적으로 생성된 페이지의 경우, 빌드 시간이 더 오래 걸릴 수 있습니다.\n\n# SSR — 서버 측 렌더링\n\n\n\n이를 동적 렌더링이라고도 합니다.\n\n지시문이나 \"서버 사용\" 지시문이 없는 파일에서, 서버에서 초기 페이지 로드 후에는 클라이언트가 서버에 요청을 보낼 때 연속적으로 서버 측 렌더링이 발생합니다. 이 요청은 캐싱을 비활성화하거나 재검증된 데이터를 가져오는 형태로 발생할 수 있습니다. 페이지가 사용자나 클라이언트 측의 특정 변경 사항에 기반하여 다시 생성되어야 하기 때문에 이를 동적이라고 합니다.\n\n## 작동 방식은?\n\nHTML이 서버에 로드되고, JS 기능도 서버에 남아 있습니다. 그런 다음 HTML이 클라이언트로 전송되어 표시됩니다.\n\n\n\n## 알림:\n\n- 서버 구성 요소의 JavaScript는 서버에서 실행되며 클라이언트로 전달되지 않습니다. 이러한 구성 요소에 대해서는 브라우저에서 하이드레이션이 없습니다.\n- 서버 구성 요소 내에서는 개인 API 키를 안전하게 사용할 수 있습니다. 클라이언트에 노출되지 않기 때문입니다.\n- 서버 구성 요소 내에서 Node.js 코드를 작성할 수 있습니다. 예시: 파일 읽기/쓰기 코드.\n\n## 페이지를 완전히 동적으로 만들려면:\n\n```js\nexport const dynamic = \"force-dynamic\";\n```\n\n\n\n## 장점:\n\n- 사전 렌더링된 DOM은 검색 엔진에서 크롤링 및 색인화하기 쉽습니다.\n- 데이터 액세스를 할 수 있으며, 가져온 데이터는 즉시 사용하여 DOM을 작성할 수 있습니다 (사용자 세부정보 표시) 브라우저로 HTML을 전송하기 전에. 백엔드에 대한 api 호출을 하는 데 추가적인 시간이 필요하지 않습니다.\n- 데이터는 일정 간격으로 재유효성 검사될 수 있어 항상 최신 상태로 유지할 수 있습니다.\n- 브라우저는 컴포넌트를 렌더링하는 데 일을 하지 않아 클라이언트 측의 제약 사항인 네트워크 연결 부실, 메모리 부족 등이 페이지로드를 방해하지 않습니다.\n\n## 한계:\n\n- 서버 렌더링된 컴포넌트는 대화형이 아니며, 대화형은 이벤트 핸들러의 사용을 필요로 하며 이것은 브라우저에서만 가능합니다. 해결책으로는: 서버에서 정적 내용을 렌더링하고 대화형 내용을 클라이언트에 리프 컴포넌트로 렌더링할 수 있습니다. 예를 들어, 서버에서 렌더링된 내용이 풍부한 페이지 내에 클라이언트에서 렌더링된 양식 또는 버튼이 있는 것과 같습니다.\n- 서버 컴포넌트에는 마운팅/언마운팅 애니메이션을 사용할 수 없습니다. 이러한 애니메이션에 대해 React 훅을 사용하려면 컴포넌트가 마운트된 시점과 React 훅을 알아야 하는데 서버에서는 React 훅을 사용할 수 없습니다.\n- 서버 컴포넌트에서 브라우저 API인 웹 저장소 API (로컬저장소 및 세션저장소), WebRTC (웹 실시간 통신 API), Geolocation API (사용자의 위도 및 경도 가져오기)와 같은 브라우저 API를 사용할 수 없습니다.\n\n\n\n# ISR — 증분 사이트 재생성\n\n## 어떻게 작동하나요?\n\n페이지는 빌드 시에 데이터베이스에서 가져온 데이터로 정적으로 생성됩니다. 그러나 fetch 메서드 자체에서 페이지가 다시 생성될 시간 간격을 지정하고 최신 데이터를 가져와 재확인할 수 있습니다. 이 재확인은 서버에서 동적으로 발생합니다.\n\n```js\n// `app` 디렉토리\nasync function getPosts() {\n  const res = await fetch(`https://.../posts`, \n  { next: { revalidate: 60 } });\n  const data = await res.json();\n \n  return data.posts;\n}\n \nexport default async function PostList() {\n  const posts = await getPosts();\n \n  return posts.map((post) => <div>{post.name}</div>);\n}\n```\n\n\n\nfetch 메서드는 값으로 60을 갖는 revalidate 속성을 지정합니다. 따라서 페이지는 매 60초마다 데이터를 다시 가져와 새 데이터로 다시 생성됩니다.\n\nfetch를 사용하지 않을 때 revalidate하는 방법: axios나 Prisma와 같은 ORM을 사용하는 경우 원하는 시간 간격으로 revalidate 구성을 내보내세요:\n\n```js\nexport const revalidate = 3600 // 최대 1시간마다 revalidate\n```\n\n## 혜택:\n\n\n\n더 빠른 로드 시간과 업데이트된 데이터로 정적 생성의 SEO 성능을 얻을 수 있어요. \n\n# PPR — 부분 사전 렌더링:\n\n이건 실험적인 기능이에요.\n\n## 부분 사전 렌더링 ( PPR )을 활성화하려면:\n\n\n\n최신 Next canary 버전을 설치해보세요:\n\n```js\nnpm install next@cannary\n```\n\n혹은,\n\n```js\nnpx create-next-app@latest .\n```\n\n\n\n프로젝트를 시작한 후, next.config.js 파일로 이동해서 다음과 같이 추가해주세요:\n\n```js\nexperimental: {\n ppr: true\n}\n```\n\n## 이것이 필요한 이유:\n\nNext 14 이전에는 전체 경로가 정적 또는 동적 중 하나여야 했습니다. 그러나 실제 요구사항은 몇 가지 요소가 동적으로 업데이트되어야 하는 정적 페이지일 수 있습니다.\n예를들어, 제품 상세 페이지의 경우 다음이 빌드 시간에 생성된 정적 컨텐츠로 문제없이 표시될 수 있습니다:\n1. 제품 이름\n2. 제품 설명\n3. 제품 가격 (가격이 업데이트될 수 있도록 재검증)\n4. 기타 제품 정보\n\n\n\n그리고 일부 내용들은 동적으로 생성되어야 합니다 (사용자 요청에 기반하여 서버에서 생성됨):\n1. 총 평가 및 리뷰 수\n2. 제품 평점\n3. 리뷰 섹션\n\n## 작동 방식은?\n\n따라서 정적 로딩 셸에 전체 제품 세부 정보 경로를 렌더링하고 그 안에 평가 수, 리뷰 수, 리뷰 섹션을 동적으로 만들 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_1.png)\n\n\n\n동적 콘텐츠는 비동기로 병렬로 스트림 처리되어 서로의 로딩 시간을 차단하지 않습니다.\n\nPPR이 활성화되면 사용자 지정 클라이언트 지시문이 표시되지 않은 모든 사전 렌더링된 페이지 (예:, 허용될 것입니다. 즉, 컴포넌트는 정적으로 생성된 로딩 쉘 내에서 렌더링될 것입니다.\n그런 다음 동적 컴포넌트를 React Suspense 경계 내로 래핑할 수 있습니다.\n그래서 중첩된 제품 세부 정보 라우트는 제품 이미지, 제품 설명, 제품 이름, 가격과 같이 모든 것이 정적으로 생성되고 리뷰, 리뷰 수, 평점 등은 적절한 후행 컴포넌트와 함께 Suspense로 래핑될 것입니다.\n코드가 이러한 Suspense로 래핑된 컴포넌트를 만나면 제공된 후행 컴포넌트를 가져와 그것들을 정적으로 생성하고 해당 컴포넌트의 데이터가 사용 가능할 때까지 래핑된 컴포넌트의 생성을 일시 중단할 것입니다.\n이러한 모든 Suspense로 래핑된 컴포넌트는 비동기로 되어 있으며 데이터를 병렬로 가져오며 한 컴포넌트의 데이터가 사용 가능해지면 렌더링될 것입니다.\n\n```js\nreturn (\n <div>\n  <A/>\n  <B/>\n  <Suspense fallback={<FallbackC/>}>\n   <C data={fetch async data}/>\n  </Suspense>\n  <D/>\n  <Suspense fallback={<FallbackE/>}>\n   <E data={fetch async data}/>\n  </Suspense>\n  <F/>\n </div>\n)\n```\n\n여기서 A, B, FallbackC, D, FallbackE 및 F 컴포넌트는 빌드 시 정적으로 생성됩니다.\n사용자가 라우트를 요청하면 정적 컴포넌트가 즉시 사용 가능합니다. 동시에 C 및 E에 대한 데이터 가져오기가 병렬로 시작됩니다. 먼저 데이터를 받는 컴포넌트가 먼저 나타납니다.\n\n\n\nPPR에 대한 자세한 이해를 위해 이 블로그를 읽어보세요.\n\n## Next.js 기본 렌더링 동작\n\n기본적으로 Next JS는 정적 사이트 생성을 선택하려고 노력합니다. 따라서 동적 변수의 값은 자동으로 설정됩니다. 여 less 향을 변경하지 않는 한 Next는 모든 것을 캐시하려고 할 것입니다.\n\n의도적으로 동적 렌더링(서버 상에서)을 선택하기 위해 다음 중 하나를 수행해야 합니다:\n\n\n\n- 값이 'force-dynamic'인 동적 변수를 내보내세요.\n- 'generateStaticParams'를 사용하지 않고 '[id]'와 같은 동적 경로 이름을 사용하세요.\n- 값이 0으로 설정된 revalidate 구성을 내보내세요.\n\n```js\nexport const revalidate = 0;\n```\n\n4. cookies() 또는 header()와 같은 동적 함수를 사용하세요.\n\n5. fetch 요청을 생성하고 'cache: ‘no-store’ ' 또는 'next: 'revalidate: 0'을 전달하세요.\n\n\n\n# 렌더링 위치는 어떻게 결정되나요\n\n이미 \"use client\" 및 \"use server\" 지시문이 구성 요소를 각각 클라이언트와 서버에 렌더링하도록 표시하는 데 사용된다는 것을 알고 계실 것입니다. 그러나 이러한 지시문들이 실제로 어떻게 해석되는지 궁금하시죠?\n\n파일 상단에 \"use client\"를 추가하면 이 파일에 만들어진 구성 요소뿐만 아니라 해당 파일이 의존하는 모든 구성 요소가 브라우저에서 렌더링됩니다. \"use client\"로 표시된 파일의 종속성은 해당 파일의 모든 import 문을 확인하여 해결됩니다.\n\n![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_2.png)\n\n\n\n상기 시나리오를 고려해보세요. 당신은 \"home\"이 브라우저에 렌더링되며, \"testimonials\"은 서버에 렌더링되도록 지정했습니다. 그러나 서버 구성 요소가 먼저 로드되고, 그 다음 클라이언트 구성 요소가 로드됩니다. 당신은 Next.js에게 Home 구성 요소가 클라이언트 측에 로드되기 전에 Testimonials를 서버에 렌더링하기 전에 기다리도록 요청했습니다. 하지만 Testimonials 구성 요소 중 하나인 의존성이 아직 렌더링되지 않았을 때 Next.js가 어떻게 Home 구성 요소를 클라이언트 측에 렌더링할 수 있을까요?\n\n이 문제를 해결하기 위해, 서버 구성 요소로 지정되었음에도 불구하고 Testimonials 구성 요소는 클라이언트 측에서 로드될 것입니다.\n\n다음을 해결하기 위해:\n\nHome 구성 요소에서 렌더링하는 동안 서버에서 여전히 Testimonials를 로드하려면 Testimonials 구성 요소를 부모 서버 구성 요소로 전달하여 Home 구성 요소에 자식 속성으로 전달하고 자식으로 렌더링하십시오:\n\n\n\n\n![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_3.png)\n\n홈페이지(home.js)에서 Testimonials에 대한 의존성이 페이지(page.js)로 전환되었습니다. 페이지(page.js)는 또한 서버 컴포넌트입니다.\n\n# 쉽게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n\n- 글을 박수로 환영하고 작가를 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기","description":"","date":"2024-05-14 12:40","slug":"2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD","content":"\n\n## Feature-Sliced Design과 Bit를 활용한 현대 프런트엔드 구축\n\n대규모 프런트엔드 앱을 작업해보셨다면, 프로젝트를 이해하기 어려운 상황에 직면했을 가능성이 높습니다.\n\n프로젝트 전체에 흩어진 파일 및 컴포넌트들이 서로 의존하는 상황이 발생하여 유지보수가 매우 복잡해지곤 했을 것입니다!\n\n따라서 이러한 문제를 방지하기 위해 프런트엔드 앱을 구성하는 최상의 방법을 보여주는 규칙과 규칙의 집합이 필요할 것입니다. 그리고 그것이 바로 Feature-Sliced Design이 하는 역할입니다.\n\n\n\n# 피처 슬라이스 디자인이란 무엇인가요?\n\n피처 슬라이스 디자인은 프론트엔드 아키텍처 패턴으로, 프론트엔드 앱을 구축하는 데 사용됩니다. 간단히 말해, 코드를 구성하는 규칙과 관례의 컴필레이션이라고 할 수 있습니다.\n\n프론트엔드 애플리케이션을 세 가지 구성 요소로 분해하여 이 작업을 수행합니다:\n\n피처 슬라이스 디자인으로 개발 중이라면, 당신의 앱은 이 세 가지 구성 요소, 즉 레이어(Layers), 슬라이스(Slices), 그리고 세그먼트(Segments)로 구성될 것입니다.\n\n\n\n- 레이어: 모든 프로젝트에서 표준화된 레이어는 수직으로 배치됩니다. 이는 통신이 위에서 아래로 이루어질 수 있음을 의미합니다. 예를 들어, Pages 레이어는 Widgets 레이어와 통신할 수 있지만 그 반대는 불가능합니다. 또한, 앱은 최대 6개의 레이어를 가질 수 있습니다:\n- shared — 프로젝트/비즈니스의 특정 내용에서 분리되어 재사용 가능한 기능입니다. (예: UIKit, 라이브러리, API)\n- entities — 비즈니스 엔티티입니다. (예: 사용자, 제품, 주문)\n- features — 사용자 상호작용, 사용자에게 비즈니스 가치를 제공하는 작업입니다. (예: SendComment, AddToCart, UsersSearch)\n- widgets — 엔티티와 기능을 의미 있는 블록으로 결합하는 구성 레이어입니다. (예: IssuesList, UserProfile)\n- pages — 엔티티, 기능 및 위젯을 사용하여 전체 페이지를 구성하는 구성 레이어입니다.\n- app — 앱 전체의 설정, 스타일 및 제공자입니다.\n- Slices: 각 레이어는 슬라이스로 구성됩니다. 이러한 슬라이스는 비즈니스 도메인을 기반으로 코드를 분할합니다. 이는 코드를 탐색하기 쉽도록 만들고 논리적으로 관련된 모듈을 가깝게 유지합니다. 그러나 기억해야 할 중요한 점은 슬라이스는 동일한 레이어 내의 슬라이스와 통신할 수 없으며 아래 레이어만 통신할 수 있다는 것입니다.\n- Segments: 각 슬라이스는 세그먼트로 구성됩니다. 세그먼트는 기술적 용도를 기준으로 슬라이스 내에서 코드를 분리하는 작은 모듈입니다. 예를 들어, UI, API, lib과 같은 다른 기술적 용도로 다른 세그먼트를 가질 수 있습니다.\n\n이러한 방식으로 코드를 구조화하면 다음과 같은 요소를 소개할 수 있습니다:\n\n- 통일성: 프론트엔드 앱은 이제 레이어, 슬라이스 및 세그먼트에 따라 준수해야 하는 정의된 표준 규칙을 갖게 됩니다.\n- 도메인 주도: 앱은 기술 중심보다 비즈니스 중심으로 구성됩니다. 이를 통해 프로젝트를 더 쉽게 탐색하고 기능을 더 깊이 이해할 수 있습니다.\n- 유지보수성 향상: 모듈이 동일한 레이어 내의 모듈이나 상위 레이어와 통신할 수 없기 때문에 리팩토링 후 앱이 쉽게 고장나지 않습니다.\n\n# 기능 구분 디자인을 사용해야 할까요?\n\n\n\n지금 보면, 특성 슬라이스 디자인을 프론트앤드 앱에 구현하는 데 상당한 노력이 필요하다는 것이 분명하게 드러납니다. 이것은 처음부터 시작하던지, 이전으로 마이그레이션하던지 관계없이 해당됩니다.\n\n따라서 특성 슬라이스 디자인이 모두에게 적합한 것은 아니라는 것을 이해하는 것이 중요합니다. 사실, 저는 다음과 같은 상황에서 특성 슬라이스 디자인을 사용하길 권장합니다:\n\n- 프론트엔드 앱을 구축 중이십니다. 백엔드 응용 프로그램을 특성 슬라이스 디자인으로 모델링하려고 하지 마십시오.\n- 사용자를 위한 애플리케이션을 구축 중이며 UI 라이브러리가 아닙니다. UI 라이브러리에는 비즈니스 도메인도 API 호출도 다루지 않습니다. 사용자를 위한 애플리케이션만이 도메인으로 분리될 수 있습니다.\n- 대규모 프로젝트를 구축 중이며 간단한 앱이 아닙니다. 간단한 할 일 애플리케이션을 만드는 경우에는 FSD의 장점을 알 수 없을 수도 있습니다. 그러나 WriterGate나 Medium과 같은 애플리케이션을 구축하는 경우, FSD가 유용할 수 있습니다.\n\n만약 이 세 가지 요구 사항을 충족하는 프론트엔드 앱이라면, FSD를 사용해 보세요!\n\n\n\n# Feature Sliced Design과 Bit를 사용하여 앱을 만드는 방법\n\n이렇게까지 오셨다면, 귀하의 앱은 Feature Sliced Design (FSD)의 강력한 후보일 가능성이 높습니다. 그러니, FSD를 사용하여 앱을 어떻게 만들 수 있는지 살펴보겠습니다!\n\n저는 Bit를 사용하여 FSD를 활용한 애플리케이션을 빌드할 것입니다. Bit는 조립 가능한 소프트웨어를 위한 혁신적인 빌드 시스템입니다.\n\nBit를 사용하면 독립적인 구성 요소를 빌드할 수 있습니다. 이러한 구성 요소는 격리된 공간에서 설계, 개발, 버전 관리되며 원격 범위에 호스팅됩니다. 이러한 범위는 컴포넌트를 더 잘 시각화하고 유지보수하기 쉽게 해주는 네임 스페이스를 통해 컴포넌트를 논리적으로 구조화하도록 장려합니다.\n\n\n\n위에서 보듯이, 브랜드, 요소, 폰트라는 다른 네임스페이스에서 구성 요소를 논리적으로 정렬했습니다. 이러한 네임스페이스를 활용하여 Bit를 사용하여 FSD를 쉽게 처리할 수 있습니다!\n\n# 단계 01: 필수 조건\n\n먼저 Bit의 버전 관리자(BVMM)를 사용하여 Bit을 전역적으로 설치한 다음 React로 워크스페이스를 초기화하십시오. 이를 통해 React 공간에서 FSD에 작업할 수 있습니다.\n\n```js\n# bit 설치\nnpx @teambit/bvm install \n\n# 워크스페이스 초기화\nbit new react workspace --default-scope dummyorg.fsd --aspect teambit.react/react-env\n```\n\n\n\n더미org.fsd를 본인의 비트 사용자 이름 및 범위 이름으로 교체하세요.\n\n작업 공간을 성공적으로 생성했다면 아래의 출력이 표시됩니다:\n\n<img src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png\" />\n\n다음으로 로컬 서버를 시작하려면 bit start를 실행하세요. 아래의 출력이 나타날 것입니다:\n\n\n\n# 단계 02: Feature Sliced Design을 사용한 React 앱 정의하기\n\n이제 Bit Components를 사용하여 Feature Sliced Design을 기반으로 한 React 앱을 구축해보겠습니다. 이 데모에서는 블로그 목록을 가져오는 React 앱을 구축해보겠습니다.\n\n그래서, 우리 앱에서는 다음이 있을 것입니다:\n\n- 앱 전체를 유지하는 React 앱\n- 블로그 항목을 렌더링하는 Blog 페이지\n- 단일 블로그 항목을 렌더링하는 Card 컴포넌트\n- 블로그를 나타내는 엔티티\n- 블로그 목록을 가져오는 API 호출\n\n\n\n만약 이것을 FSD로 구조화한다면, 다음과 같이 논리적인 매핑이 있어야 합니다:\n\n- app: 이 디렉토리는 블로그 목록을 위한 React 앱 컴포넌트를 보관할 것입니다.\n- pages: 이 디렉토리는 블로그 목록 페이지를 위한 컴포넌트를 보관할 것입니다.\n- widgets: 블로그 목록을 정의하는 단일 슬라이스가 생성될 것입니다.\n- features: 첫 번째 기능으로 get-blog-posts 라는 슬라이스를 정의할 것입니다. 이 슬라이스에서는 기능이 작동하기 위한 데이터 가져오기 메커니즘을 정의하는 모델 세그먼트를 정의할 것입니다.\n- entities: blog 라는 슬라이스를 정의할 것입니다. 블로그 슬라이스 내에서는 모델과 ui 두 세그먼트가 있을 것입니다. 모델에서는 블로그 항목의 데이터 모양을 정의하고, ui에서는 블로그 포스트 카드를 정의하는 React 컴포넌트인 blog-card를 가질 것입니다.\n\n# 단계 03: Bit를 사용하여 컴포넌트 생성하기\n\n다음으로, Bit를 사용하여 모든 필요한 컴포넌트를 생성해보겠습니다.\n\n\n\n## 1: 엔티티 레이어 구축하기\n\n먼저, 엔티티 레이어를 구축해 봅시다. 이를 위해 다음 명령을 사용하여 블로그 슬라이스를 생성해 보세요:\n\n```js\nbit create react-hook entities/blog/model && bit create react entities/blog/ui/blog-item\n```\n\n아래와 같이 새 디렉토리가 생성된 것을 확인할 수 있어요:\n\n\n\n\n<img src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_1.png\" />\n\n<img src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_2.png\" />\n\n비트(Bit)를 사용하면 spec.tsx 파일과 composition.tsx 파일을 얻을 수 있다는 것을 이미 알아채셨을 것입니다. 단일 컴포넌트에 대한 테스트 케이스를 만들어 테스트 주도 개발(Test Driven Development)로 빌드할 수 있습니다. 또한 compositions 파일을 사용하여 소비자들에게 컴포넌트가 어떻게 사용될 수 있는지 보여주기 위해 컴포넌트의 다른 출력물을 생성할 수 있습니다.\n\n그 다음, 블로그 모델과 블로그 카드 UI를 모델.ts와 blog-item.tsx 파일을 아래와 같이 업데이트하여 정의해 보겠습니다:\n\n\n\n\n```js\n// blog-item.tsx\n\nimport type { ReactNode } from 'react';\nexport type BlogItemProps = {\n  id: string,\n  title: string,\n  description: string\n  tags: string[]\n};\nconst cardStyle: React.CSSProperties = {\n  border: '1px solid #ddd',\n  borderRadius: '8px',\n  padding: '16px',\n  margin: '16px',\n  boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',\n  backgroundColor: '#fff',\n};\nconst titleStyle: React.CSSProperties = {\n  fontSize: '1.5rem',\n  marginBottom: '8px',\n};\nconst tagsStyle: React.CSSProperties = {\n  marginTop: '8px',\n  color: '#555',\n};\nexport function BlogItem({ description, id, title, tags }: BlogItemProps) {\n  return (\n    <div className=\"blog-card\"\n      key={id}\n      style={cardStyle}>\n      <h2 style={titleStyle}>{title}</h2>\n      <p>{description}</p>\n      <div className=\"tags\" style={tagsStyle}>\n        <strong>Tags:</strong> {tags.join(', ')}\n      </div>\n    </div>\n  );\n}\n```\n\n위에서 보듯이, 블로그 엔티티 및 블로그 카드를 정의하여 블로그를 볼 수 있는 기능을 구현할 수 있습니다. 전체 구현을 보려면 Bit Cloud에서 이 컴포넌트를 확인하세요.\n\n하지만 로컬 서버는 이후 이렇게 보여야 합니다:\n\n## 2: 기능 레이어 구축하기\n\n\n\n다음으로, get-blog-posts 기능을 구축해 봅시다. 이를 위해 하나의 세그먼트가 필요합니다:\n\n- model: 데이터를 가져오는 훅을 정의합시다.\n\n이를 위해 React 컴포넌트를 생성해 봅시다:\n\n```js\nbit create react-hook features/get-blog-posts/model\n```\n\n\n\n그런 다음 아래와 같이 표시된 결과물을 보게 될 거에요:\n\n<img src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_3.png\" />\n\n<img src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_4.png\" />\n\nmodel.ts 파일을 열어서 아래 코드를 포함시켜서 블로그를 가져와보세요:\n\n\n\n```js\nimport { useBlogStore } from '@dummyorg/fsd.entities.blog.model';\nimport { useEffect } from 'react';\n\nexport function useGetBlogs() {\n  const { blogs, getBlogs, loading } = useBlogStore();\n  useEffect(() => {\n    getBlogs();\n  });\n  return { blogs, loading };\n}\n```\n\n# 3: 위젯 레이어 구축하기\n\n이제 위젯인 블로그 목록을 만들어봅시다. 이를 위해 블로그 목록이라는 슬라이스와 슬라이스 내에 ui라는 세그먼트를 생성합시다. 다음 명령어를 사용하여 이 작업을 수행할 수 있습니다:\n\n```js\nbit create react widgets/blog-list/ui\n```\n\n\n\n새로운 디렉토리가 추가된 것을 확인해야 합니다:\n\n![새 디렉토리 추가 사진](/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_5.png)\n\nui.tsx 파일을 열고 아래 코드를 추가해주세요:\n\n```js\nimport React from 'react';\nimport { Blog } from '@dummyorg/fsd.entities.blog.model';\nimport { BlogItem } from '@dummyorg/fsd.entities.blog.ui.blog-item';\n\nexport type UiProps = {\n  blogs: Blog[]\n};\nexport function Ui({ blogs = [] }: UiProps) {\n  return blogs.map((blog) => (<BlogItem\n    key={blog.id}\n    description={blog.description}\n    id={blog.id}\n    tags={blog.tags}\n    title={blog.title}\n  />))\n}\n```\n\n\n\n지역 서버로 이동하여 다음을 볼 수 있어요:\n\n![Developing Scalable Frontends with Feature-Sliced Design](/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_6.png)\n\nBit Cloud에서 해당 구성 요소의 전체 구현을 살펴볼 수 있어요.\n\n# 4: 페이지 레이어 구축\n\n\n\n다음으로, 블로그 목록을 나타내는 페이지를 만들어 보겠습니다. 이를 위해 슬라이스인  blog-list와 세그먼트인 ui를 생성해봅시다. 다음 명령어를 실행하세요:\n\n```js\nbit create react pages/blog-list/ui\n```\n\n이 명령을 실행하면 다음과 같이 출력됩니다:\n\n<img src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_7.png\" />\n\n\n\n다음으로 ui.tsx 파일을 열고 다음 스니펫을 포함하세요:\n\n```js\nimport React from 'react';\nimport { useGetBlogs } from '@dummyorg/fsd.features.get-blog-posts.model';\nimport { BlogList } from '@dummyorg/fsd.widgets.blog-list.ui';\n\nexport function Ui() {\n  const { blogs, loading } = useGetBlogs();\n  if (loading) {\n    return <p>\n      Posts are loading...\n    </p>\n  }\n  return (\n    <BlogList\n      blogs={blogs}\n    />\n  );\n}\n```\n\n로컬 서버에서 아래와 같은 출력이 표시됩니다:\n\n\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해드리겠습니다.\n\n\n<img src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_9.png\" />\n\n<img src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_10.png\" />\n\n우리는 이렇게 페이지를 설정했어요! 자세히 알아보려면 Bit Cloud에서 확인해보세요.\n\n# 5: 앱 레이어 구축\n\n\n\n\n마지막으로, 이 모든 것을 사용하는 앱을 만들어봅시다. 다음 명령을 실행하세요:\n\n```js\nbit create react-app app\n```\n\n이렇게 하면 앱 컴포넌트가 생성되며 아래와 같이 결과가 생성됩니다:\n\n![Output](/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_11.png)\n\n\n\n이 앱을 Bit 서버 외부에서 로드할 수 있도록하려면 다음 몤령을 실행하십시오:\n\n```js\nbit use app\n```\n\n앱이 로드 가능한지 확인하려면 다음 몤령을 실행하십시오:\n\n```js\nbit app list\n```\n\n\n\n만약 당신의 앱이 로드될 수 있다면, 아래 출력을 확인할 수 있어야 합니다:\n\n<img src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_12.png\" />\n\n다음으로, 파일인 — app.tsx을 열고 다음 단락을 포함하세요:\n\n```js\nimport React from \"react\";\nimport { BlogListPage } from \"@dummyorg/fsd.pages.blog-list.ui\";\n\nexport function App() {\n  return <BlogListPage />\n}\n```\n\n\n\n다음으로, 명령어를 실행하여 앱을 시작해보세요:\n\n```js\nbit run app\n```\n\n로컬호스트에서 앱이 시작되는 것을 확인할 수 있어요.\n\n앱의 전체 구현을 보려면 Bit Cloud에서 확인해보세요.\n\n\n\n# 마무리\n\n보셨듯이, Feature Sliced Design은 응용 프로그램을 명확하고 구조화된 방식으로 구성할 때 매우 유용합니다. 팀원들이 프로젝트를 빠르게 탐색하고 기능을 더 잘 이해할 수 있도록 돕습니다.\n\n만약 우리가 만든 앱을 살펴보고 싶다면, Bit Cloud에서 확인해보세요.\n\n본문이 도움이 되었기를 바랍니다. FSD를 직접 시도해보고, 이 패턴에 대한 생각을 저에게 알려주세요!\n\n\n\n감사합니다.\n\n## 더 알아보기","ogImage":{"url":"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png"},"coverImage":"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png","tag":["Tech"],"readingTime":10}],"page":"112","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}