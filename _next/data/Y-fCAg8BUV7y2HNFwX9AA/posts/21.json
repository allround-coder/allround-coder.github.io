{"pageProps":{"posts":[{"title":"개발자들이 잘 모르는 자바스크립트 기능 10가지","description":"","date":"2024-06-22 05:22","slug":"2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow","content":"\n\n\n![Image](/assets/img/2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow_0.png)\n\n현대의 대부분의 프로그래밍 언어는 일반적으로 두 가지 주요 부분을 갖추고 있습니다: 렉시컬 문법과 표준 라이브러리. 프로그래밍 언어 문법은 프로그래머들을 위해 예약된 키워드와 특별한 ASCII 문자를 사용하여 독특한 프로그래밍 구문을 구축합니다.\n","ogImage":{"url":"/assets/img/2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow_0.png"},"coverImage":"/assets/img/2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow_0.png","tag":["Tech"],"readingTime":1},{"title":"우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석","description":"","date":"2024-06-22 05:20","slug":"2024-06-22-TheFront-EndDevelopmentwereusedtoisdying","content":"\n\n\n![image](/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png)\n\n# 소개\n\nSPA가 등장하기 전에 웹 애플리케이션은 일반적으로 다중 페이지로 이루어져 있었습니다. 사용자가 애플리케이션과 상호 작용할 때마다 서버가 새로운 전체 페이지를 보내고 브라우저가 다시로드하는 방식이었습니다. 사용자가 페이지 간을 이동할 때마다 완전한 페이지 재로드가 발생했고, 이로 인해 속도가 느려지고 부자연스러운 사용자 경험이 발생할 수 있었습니다. 비슷한 애플리케이션들은 주로 PHP, Ruby on Rails, ASP.NET 등과 같은 서버 측 기술을 사용하여 구축되었는데, 이들은 서버 측에서 HTML 코드를 생성하여 브라우저로 보냈습니다.\n\n![image](/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n웹 개발자들은 만능 전문가였어요. 그들은 프론트엔드와 백엔드 부분을 동시에 책임지고 있었어요. 웹 기술의 발전과 사용자의 요구에 따라, 문제없이 상호작용 인터페이스로 작업할 수 있는 새로운 솔루션이 필요했죠.\n\n그래서 BackboneJs나 AngularJs를 사용한 SPA의 최초 솔루션이 나타났어요. 그것들은 서버 부하를 줄이고 상호작용을 제공함으로써 서버의 제한된 자원을 고려한 적이 없는 웹 페이지와 함께 새로운 페이지를 기다리지 않아도 됐답니다.\n\n이렇게 프론트엔드와 백엔드 부분으로의 분리가 나타났어요. 순수한 프론트엔드 개발자의 역할은 더욱 필요하고 다양해졌어요. 그들은 사용자 인터페이스 생성, HTML, CSS, JavaScript와 상호작용하는 API 및 서버와 작업하는 기술을 전문화하기 시작했어요. 그 반대로 백엔드 개발자들은 데이터 처리, 응용 프로그램 비즈니스 로직, 데이터베이스와 서버 API 생성에 더 집중했어요.\n\n그래서 React, Angular2, Vue 및 기타 웹 애플리케이션 개발 도구 시대로 진입했어요. 단순한 양식과 목록을 만드는 대신, js-routing, 상태 관리, 브라우저 API, 요청에 권한 토큰 바인딩, 데이터 매핑 등의 작업이 가능해졌어요.\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식의 결과로 문제점이 발생했습니다:\n\n- 커뮤니케이션과 조정에 대한 어려움. Api 계약 및 통신 방법 — HTTP 1.1, Websocket, GraphQL. JSON 파싱과 유효성 검사.\n- 이해와 지식의 차이. 예를 들어, 여러 쿼리를 생성하는 프론트엔드 애플리케이션을 개발하고 일반적 및 최적화된 SPA로 간주할 수 있습니다. 그러나 백엔드에서는 데이터베이스 액세스가 많이 필요하고 이 데이터의 적절한 집계가 필요하므로 성능 및 유지 관리에 영향을 줄 수 있습니다.\n- 작업의 중복. 대부분의 CRUD 작업은 프론트엔드에서 동일한 동작을 가졌습니다. 이제 단순히 서버에서 목록을 가져오는 것이 아니라 store()에 넣었습니다. 각 사용자 작업은 dispatch()를 통해 처리되고 요청이 실행되기를 기다리며, 그 후에 결과에 따라 reducer()를 통해 store를 업데이트합니다. — 데이터베이스에서 백엔드가 수행하는 모든 작업을 프론트엔드에서 반복합니다. (페이지 다시로드 및 서버에서 현재 상태로 SPA를 복원하는 것도 언급할 가치가 있습니다 — 현재 별도의 고통입니다)\n- 디버깅 및 테스트의 어려움. 이제 가능한 통합 문제를 고려하고 응용 프로그램의 양쪽 컨텍스트에서 테스트해야 합니다. 네, 프론트엔드 애플리케이션에 대해 격리된 e2e-tests을 만들 수 있지만 제품 생산성을 보장할 수 없습니다. 네, ZoD가 서버 응답을 유효성 검사하기 위한 것이 있지만, 그 사용 비율은 얼마나 되는지요?\n- 개발 시간 및 비용 증가. API 계약에 대한 변경 사항은 동시에 두 명의 사람이 필요합니다. 서버로 직접 템플릿을 변경할 수 없습니다. 변경을 원활히 수행하려면 럴리를 필요로하고, 개별 작업으로 분할되며, 비즈니스 분석 전문가 등등이 필요합니다.\n- SEO. 우리 앱은 JS를 통해 완전히 형성되므로 검색 엔진은 앱 콘텐츠와 적절히 인덱싱 및 내비게이션 할 수 없기 때문에 SSR 및 SSG 솔루션이 필요했습니다.\n- 보안. 페이지에 입력된 모든 중요 데이터는 서버로 전달되기 전에 숨겨야 합니다. 또한 애플리케이션을 위해 서버로부터 많은 개인 정보를 요청해야하므로 액세스 토큰이 공개됩니다.\n\n# 그래서, 왜 보통의 프론트엔드가 사라지고 있는 걸까요?\n\n어떤 리소스로 가든 공고가 얼마나 많이 열려 있는지 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- Python + Django\n- PHP + Laravel\n- NextJs + React\n- Nuxt + Vue\n\n이것들은 모두 서버 기반 웹 애플리케이션 개발을 위한 번들입니다. 수분화와 재개성 접근 방식 덕분에 서버는 페이지를 다시로드하지 않고 인터페이스의 수정된 부분만 렌더링할 수 있습니다.\n\n그들이 제공하는 것들:\n\n- 이제 서버 애플리케이션은 복잡한 HTTP 또는 WS 계약이 필요하지 않으며 양쪽에서 지원해야 하는 것들을 사용하지 않아도 됩니다. gRPC와 같은 다른 서비스와의 정보 교환에 대해 더 나은 방법을 사용할 수 있게 됩니다.\n- 변경 사항을 만드는 과정이 중간 승인 없이 빨라져 1명의 사람이 사용자가 바로 변화를 볼 수 있습니다.\n- 테스트를 통해 애플리케이션을 종합적으로 확인할 수 있어 통합 테스트를 없애고 오류를 줄일 수 있습니다.\n- HTML 마크업만 교환하므로 모든 \"요청-응답\" 로직이 사용자에게 숨겨집니다.\n- SPA를 올바른 상태로 복원하기 위해 JSON으로 많은 데이터를 전달할 필요가 없습니다. 이미 준비된 템플릿을 전달할 수 있습니다.\n- 페이지의 JS 코드가 최소화되므로 babel 및 기타 도구를 사용하여 브라우저 호환성에 대해 걱정할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n노코드 솔루션의 등장, 인공지능을 활용한 템플릿 생성, 거대한 서버 자원, 그리고 SEO 요구사항으로 인해 현재는 프론트엔드 개발자 수와 도구들이 전체 애플리케이션을 개발하는 데 필요하지 않은 상황입니다.\n\n사업주들은 타당한 질문을 하고 있습니다. \"왜 단순한 애플리케이션을 개발하려면 순수한 프론트엔드 개발자와 백엔드 개발자를 고용해야 하죠?\"\n\n풀스택 개발자는 인력 비용을 절약하는 관리 쇼파로 여겨질 수 없습니다. 지금은 필수적인 존재입니다. 순수한 프론트엔드 개발자가 아니라, 데이터베이스에서 직접 간단한 작업을 수행하고 결과를 표시할 수 있는 개발자가 필요합니다.\n\n그렇습니다, 복잡하거나 헤드리스 애플리케이션은 프론트엔드와 백엔드를 분리해서 사용해야 할 것입니다. 그러나 대부분의 애플리케이션은 SPA에서 멀어져가고 이미 존재했던 방식으로 나아가게 될 것입니다. 지금은 그러한 문제들에 대한 해결책이 있습니다. HTMX의 등장으로 어떤 백엔드 개발자도 기본 지식만 있으면 웹 애플리케이션을 만들 수 있습니다. 이제는 조금의 논리를 사용하여 싱글 페이지 앱을 만들 때 심지어 JS를 알 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n앞단 개발자는 JS 로직 뿐만 아니라 CSS 및 적절한 선택자, HTML 및 그 의미론에도 책임이 있었는데, 이제 백엔드 개발자가 그것을 알아야 할까요? — 아니요, 이제는 인공지능 또는 \"HTML 레이아웃 디자이너\"가 Figma 레이아웃을 기반으로 템플릿 생성을 처리할 수 있습니다. HTML 템플릿의 로직과 상호작용은 이제 서버에서 정의됩니다.\n\n# 결론\n\n지금은 모든 이러한 정교한 프론트엔드 개발 도구가 실제로 필요한지, 순수한 프론트엔드 개발자로 남아야 할지를 고민할 때입니다.\n\n현재의 프론트엔드 개발자들이 60% 프론트엔드, 40% 백엔드로 분할된 풀스택 자격으로 이동해야 하는 것이 바람직합니다. HTMX는 시작에 불과하며, NextJs 또는 Nuxt 도구를 향한 벡터가 성장할 것이며, Angular 유형의 프레임워크는 새로운 구현에 적응할 수 없다면 죽을 것입니다. 물론 Angular 생태계에는 이미 AnalogJs에서 프로토타입이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 자원\n\n\"프론트 엔드 개발자\" 역할로 취업 정보 검색\n\n\"풀 스택 개발자\" 역할로 취업 정보 검색","ogImage":{"url":"/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png"},"coverImage":"/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png","tag":["Tech"],"readingTime":5},{"title":"이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다","description":"","date":"2024-06-22 05:20","slug":"2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode","content":"\n\n\n![image](/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png)\n\nHow common is this?\n\n![image](/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_1.png)\n\nIt’s yet another instance where we want a value that depends on whether or not there’s an exception.\n","ogImage":{"url":"/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png"},"coverImage":"/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png","tag":["Tech"],"readingTime":1},{"title":"ES8에서 가장 혁신적인 자바스크립트 기능 5가지","description":"","date":"2024-06-22 05:19","slug":"2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8","content":"\n\n\n![ES8](/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png)\n\nES8는 우리가 JavaScript를 작성하는 방식을 변화시키는 귀중한 기능으로 가득 찼습니다.\n\n코드가 더 깔끔해지고 작성하기 쉬워지며 새로운 기능이 추가되었습니다.\n\n지금 그것들을 확인해보고 놓친 것들을 확인해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n# 1. 트레일링 쉼표","ogImage":{"url":"/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png"},"coverImage":"/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png","tag":["Tech"],"readingTime":1},{"title":"모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술","description":"","date":"2024-06-22 05:16","slug":"2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow","content":"\n\n<img src=\"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png\" />\n\n자바스크립트는 현대 웹 개발에서 필수적인 다목적 강력한 언어입니다. 이 글에서는 여러분을 더 효율적이고 효과적인 자바스크립트 개발자로 만들어 줄 수 있는 슈퍼 해킹 기술들을 소개하고 각각에 대한 상세한 설명과 예제를 제공합니다.\n\n## 1. `var` 대신 `let` 및 `const` 사용하기\n\n문제: `var`은 함수 범위를 가지고 있어서 버그와 예상치 못한 동작을 유발할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: 블록 스코프를 갖는 `let`과 `const`를 사용하세요.\n\n```js\nlet count = 0;\nconst PI = 3.14;\n```\n\n`let`과 `const`를 사용하면 변수를 정의된 블록 내에서만 접근할 수 있도록 하여 스코프 관련 버그를 방지할 수 있습니다.\n\n## 2. 기본 매개변수\n\n<div class=\"content-ad\"></div>\n\n문제: 인수가 제공되지 않으면 함수가 실패할 수 있습니다.\n\n해결책: 기본 매개변수를 사용하여 대안 값 설정.\n\n```js\nfunction greet(name = '방문자') {\nreturn `안녕하세요, ${name}님!`;\n}\nconsole.log(greet()); // \"안녕하세요, 방문자님!\"\n```\n\n기본 매개변수를 사용하면 함수가 합리적인 기본값을 갖도록되어 오류를 방지하고 코드를 더 견고하게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. 템플릿 리터럴\n\n문제: 문자열 연결은 번거로우며 오류가 발생하기 쉽습니다.\n\n해결책: 더 깔끔하고 가독성이 좋은 문자열 보간을 위해 템플릿 리터럴을 사용하세요.\n\n```js\nconst name = 'John';\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting); // \"Hello, John!\"\n```\n\n<div class=\"content-ad\"></div>\n\n템플릿 리터럴을 사용하면 포함된 표현식과 여러 줄의 문자열을 쉽게 만들 수 있어요.\n\n## 4. 비구조화 할당\n\n문제: 객체와 배열에서 값 추출하는 과정이 장황할 수 있어요.\n\n해결책: 비구조화 할당을 사용해서 값을 더 간결하게 추출하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst user = { name: 'Jane', age: 25 };\nconst { name, age } = user;\nconsole.log(name, age); // \"Jane\" 25\n```\n\n구조 분해 할당을 사용하면 객체에서 속성을 추출하고 배열에서 요소를 쉽게 각각의 변수로 추출할 수 있습니다.\n\n## 5. 화살표 함수\n\n문제: 기존 함수 표현식은 장황할 수 있고 `this`를 렉시컬하게 바인딩하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 더 짧은 구문을 위해 화살표 함수를 사용하고 렉시컬 `this`를 활용하세요.\n\n```js\nconst add = (a, b) => a + b;\nconsole.log(add(2, 3)); // 5\n```\n\n화살표 함수는 함수 표현식에 대해 간결한 구문을 제공하며 `this`가 렉시컬하게 바인딩되어 있는지 보장합니다.\n\n## 6. 전개 연산자\n\n<div class=\"content-ad\"></div>\n\n문제: 배열이나 객체를 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 전개 연산자를 사용하여 배열과 객체를 쉽게 결합하세요.\n\n```js\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = […arr1, …arr2];\nconsole.log(combined); // [1, 2, 3, 4, 5, 6]\n```\n\n전개 연산자를 사용하면 배열이나 객체의 요소를 다른 배열이나 객체로 전개할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 7. 나머지 매개변수\n\n문제: 함수에 변수 수의 인수를 처리하는 것은 까다로울 수 있습니다.\n\n해결책: 모든 인수를 배열에 캡처하기 위해 나머지 매개변수를 사용합니다.\n\n```js\nfunction sum(…args) {\nreturn args.reduce((total, num) => total + num, 0);\n}\nconsole.log(sum(1, 2, 3, 4)); // 10\n```\n\n<div class=\"content-ad\"></div>\n\n레스트 매개변수를 사용하면 매개변수의 개수에 상관없이 배열로 처리할 수 있어 함수를 보다 유연하게 만들 수 있어요.\n\n## 8. 단락 평가\n\n문제: 조건문을 작성하는 것은 매우 번거로울 수 있어요.\n\n해결책: 간결한 조건을 작성하기 위해 단락 평가를 활용해보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst isLoggedIn = true;\nconst user = isLoggedIn && { name: 'Jane', age: 25 };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n단축 평가는 논리적 `&&` 및 `||` 연산자를 사용하여 조건식을 간단하게 만듭니다.\n\n## 9. 선택적 체이닝\n\n문제: 깊게 중첩된 속성에 액세스하는 것은 체인의 일부가 `null` 또는 `undefined`인 경우 오류를 발생시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: 중첩된 속성에 안전하게 접근하기 위해 선택적 체이닝을 사용하세요.\n\n```js\nconst user = { profile: { name: 'Jane' } };\nconst userName = user?.profile?.name;\nconsole.log(userName); // \"Jane\"\n```\n\n선택적 체이닝을 사용하면 `null` 또는 `undefined`인지 명시적으로 확인하지 않고도 중첩된 속성에 안전하게 접근할 수 있습니다.\n\n## 10. 널리쉬 콜리싱\n\n<div class=\"content-ad\"></div>\n\n문제: `||`를 사용하여 기본 값을 제공하는 경우, 값이 `0` 또는 `\"\"`이면 예상치 못한 결과가 발생할 수 있습니다.\n\n해결책: `nullish coalescing` (`??`)을 사용하여 `null` 또는 `undefined`일 때만 기본 값을 제공합니다.\n\n```js\nconst user = { name: '', age: 0 };\nconst userName = user.name ?? '익명';\nconst userAge = user.age ?? 18;\nconsole.log(userName); // \"\"\nconsole.log(userAge); // 0\n```\n\n`Nullish coalescing`은 왼쪽 피연산자가 `null` 또는 `undefined`일 때에만 기본 값을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 11. 객체 속성 축약\n\n문제: 객체 속성에 변수를 할당하는 작업이 반복적 일 수 있습니다.\n\n해결책: 속성 축약을 사용하여 객체 생성을 간단하게 만듭니다.\n\n```js\nconst name = 'Jane';\nconst age = 25;\nconst user = { name, age };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n<div class=\"content-ad\"></div>\n\n프로퍼티 축약형을 사용하면 변수 이름과 일치할 때 프로퍼티 이름을 생략할 수 있어서 코드가 더 깔끔해집니다.\n\n## 12. 동적 프로퍼티 이름\n\n문제: 동적 프로퍼티 이름으로 객체를 생성하는 것은 다소 장황할 수 있습니다.\n\n해결책: 계산된 프로퍼티 이름을 사용하여 동적으로 객체 프로퍼티를 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst propName = '나이';\nconst user = { 이름: '제인', [propName]: 25 };\nconsole.log(user); // { 이름: '제인', 나이: 25 }\n```\n\n계산된 속성 이름을 사용하면 식의 값으로 속성 이름을 동적으로 만들 수 있습니다.\n\n## 13. 배열 `map()`, `filter()`, 및 `reduce()`\n\n문제: 배열을 변환, 필터링 또는 값 누적하기 위해 배열을 반복하는 작업은 반복적일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 일반적인 배열 작업에 `map()`, `filter()`, 및 `reduce()`를 사용하세요.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\nconst evens = numbers.filter(num => num % 2 === 0);\nconsole.log(evens); // [2, 4]\nconst sum = numbers.reduce((total, num) => total + num, 0);\nconsole.log(sum); // 15\n```\n\n이러한 배열 메서드들은 배열을 변환하고 필터링하며 줄이는 함수적인 방식을 제공하여, 코드를 더 표현적이고 간결하게 만듭니다.\n\n## 14. 문자열 `includes()`, `startsWith()`, 및 `endsWith()`\n\n<div class=\"content-ad\"></div>\n\n문제: 문자열에 특정 부분 문자열이 포함되어 있는지, 시작하는지 또는 끝나는지를 확인하는 작업은 장황할 수 있습니다.\n\n해결책: 더 간단한 문자열 확인을 위해 `includes()`, `startsWith()`, `endsWith()`를 사용하세요.\n\n```js\nconst str = 'Hello, world!';\nconsole.log(str.includes('world')); // true\nconsole.log(str.startsWith('Hello')); // true\nconsole.log(str.endsWith('!')); // true\n```\n\n이러한 문자열 메소드들은 부분 문자열의 존재, 시작 또는 끝을 확인하는 간단하고 가독성 있는 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 15. 함수 매개변수에서 배열 및 객체 비구조화\n\n문제: 함수 매개변수로 전달된 배열 또는 객체에서 값을 추출하는 것은 장황할 수 있습니다.\n\n해결책: 함수 매개변수에서 비구조화를 사용하여 값을 직접 추출하세요.\n\n```js\nconst user = { name: 'Jane', age: 25 };\nfunction greet({ name, age }) {\n    return `안녕, ${name}! 당신은 ${age}살 입니다.`;\n}\nconsole.log(greet(user)); // \"안녕, Jane! 당신은 25살 입니다.\"\n```\n\n<div class=\"content-ad\"></div>\n\n함수 매개변수의 구조 분해를 사용하면 함수에 전달된 객체나 배열에서 값을 직접 추출하여 코드를 더 간결하고 가독성 있게 만들 수 있어요.\n\n## 16. 구조 분해에서 기본값 활용\n\n문제: 객체의 구조 분해 시 누락된 속성을 다루는 것은 복잡할 수 있어요.\n\n해결책: 구조 분해에서 기본값을 사용하여 대체 값을 제공해요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst user = { name: 'Jane' };\nconst { name, age = 18 } = user;\nconsole.log(name); // \"Jane\"\nconsole.log(age); // 18\n```\n\n구조 분해 안에 기본 값(default values)을 설정하면 누락될 수 있는 속성에 대한 대체 값을 제공할 수 있어 코드를 보다 견고하게 만들어줍니다.\n\n## 17. Object `assign()`\n\n문제: 객체를 복제하거나 병합하는 것은 번거롭고 실수하기 쉽습니다.\n\n<div class=\"content-ad\"></div>\n\n해결 방법: `Object.assign()`을 사용하여 객체를 복제하거나 병합할 수 있습니다.\n\n```js\nconst target = { a: 1 };\nconst source = { b: 2 };\nconst merged = Object.assign(target, source);\nconsole.log(merged); // { a: 1, b: 2 }\n```\n\n`Object.assign()`을 사용하면 객체를 효율적으로 복제하거나 병합할 수 있어서 수동 복사가 필요한 경우를 줄일 수 있습니다.\n\n## 18. Array `find()` 및 `findIndex()`\n\n<div class=\"content-ad\"></div>\n\n문제: 배열에서 요소나 인덱스를 찾는 것은 루프를 사용하면 번거로울 수 있습니다.\n\n해결책: 더 가독성있는 코드를 위해 `find()`와 `findIndex()`를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nconst user = users.find(u => u.id === 1);\nconsole.log(user); // { id: 1, name: 'Jane' }\nconst index = users.findIndex(u => u.id === 1);\nconsole.log(index); // 0\n```\n\n<div class=\"content-ad\"></div>\n\n이러한 배열 메소드는 조건에 따라 요소를 찾거나 인덱스를 찾는 간단한 방법을 제공하여 코드의 가독성을 향상시킵니다.\n\n## 19. 배열 `some()` 및 `every()`\n\n문제: 배열 중 일부 또는 모든 요소가 특정 조건을 충족하는지 확인하는 것이 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `some()` 및 `every()`를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst hasEven = numbers.some(num => num % 2 === 0);\nconsole.log(hasEven); // true\nconst allEven = numbers.every(num => num % 2 === 0);\nconsole.log(allEven); // false\n```\n\n이러한 배열 메소드를 사용하면 배열 내 일부 또는 모든 요소가 특정 조건을 충족하는지 간결하게 확인할 수 있습니다.\n\n## 20. 배열 `flat()` 및 `flatMap()`\n\n문제: 중첩된 배열을 평탄화하거나 배열을 매핑하고 평탄화하는 것은 번거로울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결 방법: 더 읽기 쉬운 코드를 위해 `flat()` 및 `flatMap()`을 사용하세요.\n\n```js\nconst nested = [1, [2, [3, [4]]]];\nconst flat = nested.flat(2);\nconsole.log(flat); // [1, 2, 3, [4]]\nconst mapped = [1, 2, 3].flatMap(x => [x, x * 2]);\nconsole.log(mapped); // [1, 2, 2, 4, 3, 6]\n```\n\n이러한 배열 메서드를 사용하면 중첩된 배열을 쉽게 평탄화하고 한 번에 매핑 및 평탄화할 수 있는 간단한 방법을 제공합니다.\n\n## 21. Array `from()` and `of()`\n\n<div class=\"content-ad\"></div>\n\n문제: 이터러블 객체나 인수에서 배열을 만드는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `Array.from()` 및 `Array.of()`를 사용하세요.\n\n```js\nconst set = new Set([1, 2, 3]);\nconst arrFromSet = Array.from(set);\nconsole.log(arrFromSet); // [1, 2, 3]\nconst arrOfNumbers = Array.of(1, 2, 3);\nconsole.log(arrOfNumbers); // [1, 2, 3]\n```\n\n`Array.from()`은 이터러블 객체에서 배열을 만들 수 있고, `Array.of()`은 인수 목록에서 배열을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 22. 콜백에서 파라미터 구조 분해\n\n문제점: 콜백에 전달된 객체의 속성에 접근하는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 콜백 파라미터에서 구조 분해를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nusers.forEach(({ id, name }) => {\nconsole.log(`User ID: ${id}, User Name: ${name}`);\n};\n```\n\n<div class=\"content-ad\"></div>\n\n콜백 매개변수의 구조 분해를 사용하면 콜백에 전달된 객체의 속성에 직접 액세스하여 코드를 더 간결하게 만들 수 있어요.\n\n## 23. 선택적 콜백 함수\n\n문제: 선택적 콜백 함수를 처리하는 것은 다소 까다로울 수 있어요.\n\n해결책: 선택적 콜백을 호출하기 위해 단락 평가(short-circuit evaluation)를 사용해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction fetchData(url, callback) {\n    fetch(url)\n    .then(response => response.json())\n    .then(data => {\n        callback && callback(data);\n    });\n}\n```\n\n단락평가는 제공된 경우에만 선택적 콜백 함수를 호출할 수 있게 해서 코드를 보다 견고하게 만들어줍니다.\n\n## 24. 콜백을 프로미스로 변환하기\n\n문제: 콜백을 기반으로 하는 함수를 프로미스로 변환하는 것은 어려울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 유틸리티 함수를 사용하여 콜백을 Promisify합니다.\n\n```js\nfunction promisify(fn) {\nreturn function (…args) {\nreturn new Promise((resolve, reject) => {\nfn(…args, (err, result) => {\nif (err) reject(err);\nelse resolve(result);\n});\n});\n};\n}\nconst readFile = promisify(require('fs').readFile);\nreadFile('path/to/file.txt', 'utf8')\n.then(data => console.log(data))\n.catch(err => console.error(err));\n```\n\n프로미스화를 통해 콜백 기반 함수를 프로미스로 변환하여 비동기/대기 문법과 함께 사용할 수 있게 만들어줍니다.\n\n## 25. 동기적인 코드를 위한 Async/Await\n\n<div class=\"content-ad\"></div>\n\n문제점: Promise를 사용한 비동기 코드 작성은 길고 읽기 어렵습니다.\n\n해결책: async/await를 사용하여 동기적인 스타일로 비동기 코드를 작성하세요.\n\n```js\nasync function fetchData(url) {\ntry {\nconst response = await fetch(url);\nconst data = await response.json();\nconsole.log(data);\n} catch (error) {\nconsole.error('데이터를 불러오는 중 오류가 발생했습니다:', error);\n}\n}\nfetchData('https://api.example.com/data');\n```\n\nAsync/await는 비동기 코드를 동기 코드처럼 작성하고 동작하도록 하는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## 26. Promises 연쇄하기\n\n문제 : 여러 비동기 작업을 순차적으로 처리하는 것은 번거로울 수 있습니다.\n\n해결책 : Promises를 연쇄하여 여러 비동기 작업을 처리하세요.\n\n```js\nfetch('https://api.example.com/data')\n.then(response => response.json())\n.then(data => {\n    console.log('데이터:', data);\n    return fetch('https://api.example.com/more-data');\n})\n.then(response => response.json())\n.then(moreData => {\n    console.log('더 많은 데이터:', moreData);\n})\n.catch(error => {\n    console.error('에러:', error);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n**Promise를 연결하는 것은 여러 비동기 작업을 순차적으로 처리할 수 있어 가독성과 유지 보수성을 향상시킬 수 있습니다.**\n\n## 27. 동시 실행을 위한 Promise.all\n\n문제: 여러 비동기 작업을 동시에 처리하는 것은 어려울 수 있습니다.\n\n해결책: `Promise.all`을 사용하여 동시에 비동기 작업을 처리하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst fetchData1 = fetch('https://api.example.com/data1').then(response => response.json());\nconst fetchData2 = fetch('https://api.example.com/data2').then(response => response.json());\nPromise.all([fetchData1, fetchData2])\n.then(([data1, data2]) => {\nconsole.log('Data 1:', data1);\nconsole.log('Data 2:', data2);\n})\n.catch(error => {\nconsole.error('Error:', error);\n});\n```\n\n`Promise.all`을 사용하면 여러 비동기 작업을 동시에 처리하고 모두 완료될 때 진행할 수 있습니다.\n\n## 28. 디바운스 함수\n\n문제: 창 크기 조절과 같은 빈번한 함수 호출은 성능을 저하시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: debounce 함수를 사용하여 함수가 실행되는 속도를 제한합니다.\n\n```js\nfunction debounce(func, wait) {\n  let timeout;\n  return function (...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n}\nwindow.addEventListener('resize', debounce(() => {\n  console.log('창 크기 조정됨');\n}, 200));\n```\n\ndebounce 함수는 일정 시간 동안 활동이 없을 때에만 함수가 호출되도록 보장하여 성능을 개선합니다.\n\n## 29. 스로틀 함수\n\n<div class=\"content-ad\"></div>\n\n문제: 스크롤 또는 크기 조정과 같이 빈번하게 발생하는 이벤트의 함수 실행 속도 제한.\n\n해결책: 함수 실행 속도 제한을 위해 스로틀(throttle) 함수를 사용합니다.\n\n```js\nfunction throttle(func, limit) {\n  let lastFunc;\n  let lastRan;\n  return function (...args) {\n    if (!lastRan) {\n      func.apply(this, args);\n      lastRan = Date.now();\n    } else {\n      clearTimeout(lastFunc);\n      lastFunc = setTimeout(() => {\n        if (Date.now() - lastRan >= limit) {\n          func.apply(this, args);\n          lastRan = Date.now();\n        }\n      }, limit - (Date.now() - lastRan));\n    }\n  };\n}\n\nwindow.addEventListener('scroll', throttle(() => {\n  console.log('창 스크롤됨');\n}, 200));\n```\n\n스로틀 함수를 사용하면 주어진 기간에 함수가 최대 한 번 호출되도록 보장하여 빈번히 발생하는 이벤트에 대한 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 30. 객체의 깊은 복제\n\n문제: 중첩된 객체를 복제하는 것은 까다롭고 오류가 발생하기 쉽습니다.\n\n해결책: 구조화된 복제 또는 Lodash와 같은 라이브러리를 사용하여 객체를 깊게 복제하세요.\n\n```js\nconst obj = { a: 1, b: { c: 2 } };\nconst deepClone = JSON.parse(JSON.stringify(obj));\nconsole.log(deepClone); // { a: 1, b: { c: 2 } }\n```\n\n<div class=\"content-ad\"></div>\n\n깊은 복제는 중첩된 객체가 참조가 아닌 값으로 복사되어 원본 객체가 의도하지 않은 수정을 방지합니다.\n\n## 31. 메모이제이션\n\n문제: 비싼 함수를 반복 호출하면 성능이 저하될 수 있습니다.\n\n해결책: 메모이제이션을 사용하여 비싼 함수 호출의 결과를 캐시합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction memoize(func) {\nconst cache = new Map();\nreturn function (...args) {\nconst key = JSON.stringify(args);\nif (cache.has(key)) {\nreturn cache.get(key);\n}\nconst result = func.apply(this, args);\ncache.set(key, result);\nreturn result;\n};\n}\nconst expensiveFunction = memoize((num) => {\nconsole.log('계산 중…');\nreturn num * 2;\n});\nconsole.log(expensiveFunction(2)); // \"계산 중…\" 4\nconsole.log(expensiveFunction(2)); // 4\n```\n\n메모이제이션은 비용이 많이 드는 함수 호출의 결과를 캐싱하여 동일한 인수로의 후속 호출에 대해 캐시된 결과를 반환함으로써 성능을 향상시킵니다.\n\n## 32. 함수 커링\n\n문제: 여러 개의 매개변수를 가진 함수를 생성하는 것은 번거로울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 커링을 사용하여 부분적으로 적용된 매개변수를 가진 함수를 만드세요.\n\n```js\nfunction curry(func) {\nreturn function curried(…args) {\nif (args.length >= func.length) {\nreturn func.apply(this, args);\n}\nreturn function (…nextArgs) {\nreturn curried.apply(this, args.concat(nextArgs));\n};\n};\n}\nconst sum = (a, b, c) => a + b + c;\nconst curriedSum = curry(sum);\nconsole.log(curriedSum(1)(2)(3)); // 6\nconsole.log(curriedSum(1, 2)(3)); // 6\n```\n\n커링을 사용하면 더 적은 매개변수로 호출할 수 있는 함수를 생성하여 나머지 매개변수를 받는 새 함수를 반환할 수 있습니다.\n\n## 33. 부분 적용\n\n<div class=\"content-ad\"></div>\n\n문제: 반복적인 인자로 함수를 호출하는 것은 귀찮을 수 있습니다.\n\n해결책: 일부 인자를 함수에 미리 적용하기 위해 부분 적용을 사용하십시오.\n\n```js\nfunction partial(func, ...presetArgs) {\nreturn function (...laterArgs) {\nreturn func(...presetArgs, ...laterArgs);\n};\n}\nconst multiply = (a, b, c) => a * b * c;\nconst double = partial(multiply, 2);\nconsole.log(double(3, 4)); // 24\n```\n\n부분 적용을 사용하면 일부 인자를 미리 적용하여 새로운 함수를 만들 수 있어 코드를 더 유연하고 재사용 가능하게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n34. 함수 합성\n\n문제: 여러 함수를 단일 작업으로 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 여러 함수를 결합하기 위해 함수 합성을 사용하세요.\n\n```js\nconst compose = (…funcs) => (arg) =>\nfuncs.reduceRight((prev, fn) => fn(prev), arg);\nconst add = (x) => x + 1;\nconst multiply = (x) => x * 2;\nconst addThenMultiply = compose(multiply, add);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n<div class=\"content-ad\"></div>\n\n함수 합성을 사용하면 여러 함수를 결합하여 새로운 함수를 만들어 코드를 더 모듈식으로 만들고 재사용할 수 있습니다.\n\n## 35. 함수 파이프라이닝\n\n문제: 값에 일련의 함수를 적용하는 것이 장황할 수 있습니다.\n\n해결책: 함수 파이프라이닝을 사용하여 일련의 함수를 순차적으로 적용하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst pipe = (...funcs) => (arg) =>\nfuncs.reduce((prev, fn) => fn(prev), arg);\nconst add = (x) => x + 1;\nconst multiply = (x) => x * 2;\nconst addThenMultiply = pipe(add, multiply);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n함수 파이프 라이닝을 사용하면 코드의 가독성과 유지 관리성을 높일 수 있습니다.\n\n## 36. 스스로 호출하는 함수\n\n문제: 정의할 때 즉시 함수를 실행하는 것은 번거로울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 즉시 실행 함수 표현식(IIFE)을 사용하세요.\n\n```js\n(function () {\nconsole.log('즉시 실행됩니다!');\n})();\n```\nIIFE를 사용하면 함수를 정의하는 즉시 실행할 수 있어서, 격리된 스코프를 만들고 전역 네임스페이스를 오염시키는 것을 피할 수 있습니다.\n\n## 37. 전역 변수 사용을 피하세요\n\n<div class=\"content-ad\"></div>\n\n문제: 전역 변수는 충돌과 의도치 않은 부작용을 일으킬 수 있습니다.\n\n해결책: 전역 이름 공간을 오염시키지 않도록 지역 변수와 모듈을 사용하세요.\n\n```js\n// 지역 변수 사용\nfunction doSomething() {\n    let localVariable = '지역 변수입니다';\n    console.log(localVariable);\n}\n// 모듈 사용\nconst myModule = (function () {\n    let privateVariable = '비공개 변수입니다';\n    return {\n        publicMethod() {\n            console.log(privateVariable);\n        },\n    };\n})();\nmyModule.publicMethod(); // \"비공개 변수입니다\"\n```\n\n전역 변수를 피함으로써 충돌과 의도하지 않은 부작용을 방지하고, 코드를 모듈화하고 유지보수하기 쉽도록 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 38. 클로저를 사용한 캡슐화\n\n문제: 함수의 내부 세부 정보를 노출하면 남용될 수 있습니다.\n\n해결책: 클로저를 사용하여 내부 세부 정보를 캡슐화합니다.\n\n```js\nfunction createCounter() {\nlet count = 0;\nreturn {\nincrement() {\ncount++;\nreturn count;\n},\ndecrement() {\ncount--;\nreturn count;\n},\n};\n}\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1\nconsole.log(counter.increment()); // 2\nconsole.log(counter.decrement()); // 1\n```\n\n<div class=\"content-ad\"></div>\n\n클로저를 사용하면 내부 세부 정보를 캡슐화하고 필요한 기능만 노출하여 코드 보안 및 유지 보수성을 향상시킬 수 있어요.\n\n## 39. 모듈 패턴\n\n문제: 코드를 재사용 가능한 모듈로 구성하는 것은 challenging할 수 있어요.\n\n해결책: 모듈 패턴을 사용하여 재사용 가능하고 캡슐화된 코드를 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst myModule = (function () {\nlet privateVariable = 'This is private';\nfunction privateMethod() {\nconsole.log(privateVariable);\n}\nreturn {\npublicMethod() {\nprivateMethod();\n},\n};\n})();\nmyModule.publicMethod(); // \"This is private\"\n```\n\n모듈 패턴을 사용하면 재사용 가능하고 캡슐화된 코드를 작성할 수 있어 코드 구성과 유지보수를 개선할 수 있어요.\n\n## 40. 싱글톤 패턴\n\n문제: 클래스의 인스턴스가 하나만 생성되도록 보장하는 것은 도전적일 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n해결책: 싱글톤 패턴을 사용하여 단일 인스턴스를 생성하세요.\n\n```js\nconst singleton = (function () {\nlet instance;\nfunction createInstance() {\nreturn {\nname: '싱글톤 인스턴스',\n};\n}\nreturn {\ngetInstance() {\nif (!instance) {\ninstance = createInstance();\n}\nreturn instance;\n},\n};\n})();\nconst instance1 = singleton.getInstance();\nconst instance2 = singleton.getInstance();\nconsole.log(instance1 === instance2); // true\n```\n\n싱글톤 패턴은 클래스의 단일 인스턴스만 생성되도록 보장하며, 공유 리소스 또는 구성을 관리하는 데 유용합니다.\n\n## 41. 팩토리 패턴\n\n<div class=\"content-ad\"></div>\n\n문제: 복잡한 초기화가 필요한 객체를 생성하는 것은 귀찮을 수 있습니다.\n\n해결책: 팩토리 패턴을 사용하여 객체를 생성하세요.\n\n```js\nfunction createUser(name, role) {\nreturn {\nname,\nrole,\nsayHello() {\nconsole.log(`안녕하세요, 제 이름은 ${this.name}이고 ${this.role}입니다.`);\n},\n};\n}\nconst admin = createUser('Alice', 'admin');\nconst user = createUser('Bob', 'user');\nadmin.sayHello(); // \"안녕하세요, 제 이름은 Alice이고 admin입니다.\"\nuser.sayHello(); // \"안녕하세요, 제 이름은 Bob이고 user입니다.\"\n```\n\n팩토리 패턴을 사용하면 유연하고 재사용 가능한 방식으로 복잡한 초기화가 필요한 객체를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 42. 관찰자 패턴\n\n문제: 상태 변경을 관리하고 여러 구성 요소에 알릴 때 어려울 수 있습니다.\n\n해결책: 관찰자 패턴을 사용하여 상태 변경을 관리하고 관찰자에게 알립니다.\n\n```js\nfunction Subject() {\nthis.observers = [];\n}\nSubject.prototype = {\nsubscribe(observer) {\nthis.observers.push(observer);\n},\nunsubscribe(observer) {\nthis.observers = this.observers.filter((obs) => obs !== observer);\n},\nnotify(data) {\nthis.observers.forEach((observer) => observer.update(data));\n},\n};\nfunction Observer(name) {\nthis.name = name;\n}\nObserver.prototype.update = function (data) {\nconsole.log(`${this.name} received data: ${data}`);\n};\nconst subject = new Subject();\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\nsubject.notify('새로운 데이터 이용 가능'); // \"Observer 1 received data: 새로운 데이터 이용 가능\" \"Observer 2 received data: 새로운 데이터 이용 가능\"\n```\n\n<div class=\"content-ad\"></div>\n\n옵저버 패턴을 사용하면 상태 변경을 관리하고 여러 옵저버에게 알림을 보내어 코드 구성 및 유지 관리를 개선할 수 있어요.\n\n## 43. 이벤트 위임\n\n문제: 여러 요소에 이벤트 리스너를 추가하면 성능이 저하될 수 있어요.\n\n해결책: 이벤트 위임을 사용하여 이벤트를 효율적으로 관리하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\ndocument.getElementById('parent').addEventListener('click', (event) => {\nif (event.target && event.target.matches('button.className')) {\nconsole.log('Button clicked:', event.target.textContent);\n}\n});\n```\n\n이벤트 위임을 사용하면 공통 상위 요소에 하나의 이벤트 리스너를 추가하여 여러 하위 요소의 이벤트를 효율적으로 처리할 수 있습니다.\n\n## 44. `eval()` 사용 피하기\n\n문제: `eval()` 사용은 보안 취약점과 성능 문제를 야기할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결 방법: `eval()`을 사용하지 말고 더 안전한 대안을 사용하세요.\n\n```js\n// 피하십시오\nconst code = 'console.log(\"Hello, world!\")';\neval(code); // \"Hello, world!\"\n// 더 안전한 대안 사용\nconst func = new Function('console.log(\"Hello, world!\")');\nfunc(); // \"Hello, world!\"\n```\n\n`eval()`을 피함으로써 보안 취약성과 성능 문제를 방지하고 코드를 더 안전하고 효율적으로 만들 수 있습니다.\n\n## 45. `for…of`를 사용하여 반복하기\n\n<div class=\"content-ad\"></div>\n\n문제: 'for...in'을 사용하여 배열을 반복하는 것은 오류가 발생할 수 있습니다.\n\n해결책: 배열 및 기타 반복 가능한 객체를 반복하는 데는 'for...of'를 사용하십시오.\n\n```js\nconst arr = [1, 2, 3, 4, 5];\nfor (const value of arr) {\nconsole.log(value);\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n`for...of`는 간단하고 안전한 방법을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":21},{"title":"React와 TailwindCSS로 반응형 NavBar 만드는 방법","description":"","date":"2024-06-22 05:04","slug":"2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS","content":"\n\n현재의 모바일 중심 세상에서는 반응형 디자인을 만들고 이를 구현하는 것이 모든 기기에서 원활한 사용자 경험을 제공하는 데 필수적입니다. \n오늘은 내비게이션 바에 반응 형성을 어떻게 구현할 수 있는지에 대해 이야기하겠습니다.\n\n1- NavBar.tsx 라는 컴포넌트를 생성하세요 (이 튜토리얼에서 TypeScript를 사용할 것입니다).\n\n2- 더 큰 화면에 대한 NavBar 세부 정보를 구현하십시오. 간단하게 말해서, 이것들은 nav를 플렉스 컨테이너로 만들고 그 안에 웹 사이트 로고, 정렬되지 않은 목록 및 오른쪽에 버튼이 있을 것입니다.\n\n```jsx\n  <nav className=\"flexBetween max-container padding-container relative z-30 py-5\">\n      <Link href=\"/\">\n        <Image src=\"/hilink-logo.svg\" alt=\"logo\" width={74} height={29} />\n      </Link>\n      <ul className=\"hidden h-full gap-12 lg:flex\">\n        {NAV_LINKS.map((link) => (\n          <Link\n            href={link.href}\n            key={link.key}\n            className=\"regular-16 text-gray-500 flexCenter cursor-pointer pb-1.5 transition-all hover:font-bold\"\n          >\n            {link.label}\n          </Link>\n        ))}\n      </ul>\n\n      <div className=\"lg:flexCenter hidden\">\n        <Button\n          type=\"button\"\n          title=\"Login\"\n          icon=\"/user.svg\"\n          variant=\"btn_dark_green\"\n        />\n      </div>\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드에서, nav 태그에는 단순히 (flex items-center justify-between)인 flexBetween 특수 css 클래스가 있습니다. 이 컨테이너의 첫 번째 아이템은 로고이고, 그 다음은 웹 사이트 루트로의 내비게이션 링크가 있는 비순서 목록이며, 마지막으로 버튼이 있습니다.\n\n3- 작은 화면을 위한 내비게이션 구현하기.\n이제, 1024px보다 작은 화면에는 내비게이션이 없을 것임을 알았습니다 (lg:는 콜론 뒤에 넣은 클래스명이 대형 화면 및 이상에서만 사용된다는 의미입니다).\n\n작은 화면에는 햄버거 아이콘을 넣을 것입니다.\n\n![해당 이미지](/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png)\n\n<div class=\"content-ad\"></div>\n\n그러면 작은 화면용 내비게이션을 넣기 위해 이 버튼이 클릭될 때 언제 체크해야 합니다.\n그를 위해:\n\n```js\nconst [isOpen, setIsOpen] = useState(false);\nconst changeIsOpen = () => {\n setIsOpen(!isOpen);\n};\nuseEffect(() => {\n console.log(isOpen);\n}, [isOpen]);\n```\n\n또한 isOpen 상태 변화를 모니터링하기 위해 useEffect 훅을 사용할 수 있습니다:\n\n```js\nuseEffect(() => {\n console.log(isOpen);\n}, [isOpen]);\n```\n\n<div class=\"content-ad\"></div>\n\n4- IsOpen 변수 및 changeIsOpen 함수 사용하기\n\n```js\n{isOpen && <NavSmallScreen changeIsOpen={changeIsOpen}/>}\n\n<Image\n    src=\"menu.svg\"\n    alt=\"menu\"\n    width={32}\n    height={32}\n    className=\"inline-block cursor-pointer lg:hidden\"\n    onClick={changeIsOpen}\n```\n\n5- NavSmallScreen 컴포넌트 구현하기\n\n그다음으로 NavSmallScreen 컴포넌트를 만들겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {NAV_LINKS} from \"@/constants\";\nimport Link from \"next/link\";\nimport Image from \"next/image\";\n\nfunction NavSmallScreen({changeIsOpen}: {changeIsOpen: () => void}) {\n  return (\n    <div\n      className=\"flex flex-col items-center min-w-[70vw] z-[105] p-10 h-full w-full fixed left-0 top-0 opacity-90 bg-black  backdrop-blur-md rounded-lg\">\n      <ul\n        className=\"flex flex-col items-center justify-center gap-10 text-xl h-full \">\n        {NAV_LINKS.map((link) => (\n          <Link\n            href={link.href}\n            key={link.key}\n            className=\"regular-16 text-gray-500 flexCenter cursor-pointer pb-1.5 transition-all hover:font-bold\"\n          >\n            {link.label}\n          </Link>\n        ))}\n\n        <Image\n          src=\"close.svg\"\n          alt=\"menu\"\n          width={32}\n          height={32}\n          className=\"inline-block cursor-pointer lg:hidden\"\n          onClick={changeIsOpen}\n        />\n      </ul>\n    </div>\n  );\n}\n\nexport default NavSmallScreen;\r\n```\n\n![Responsive Navbar](/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_1.png)\n\n저희는 부모 컴포넌트에서 changeIsOpen 함수를 자식 컴포넌트로 전달하고, 이 함수를 클릭시 닫기 아이콘(X)에 사용합니다. 그래서 메뉴가 닫힙니다.\n\n이 게시물을 읽어 주셔서 감사합니다. 여러분의 반응형 목표를 달성하는데 도움이 되었으면 좋겠습니다! 즐거운 하루 되세요!\n\n<div class=\"content-ad\"></div>\n\nGitHub repository 에서 소스 코드를 확인할 수 있습니다.\n[이 곳](https://github.com/egemenc21/camptraveler/blob/main/components/Navbar.tsx)에서 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png"},"coverImage":"/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular v17이 해결한 이전에는 해결 불가능했던 문제","description":"","date":"2024-06-22 05:02","slug":"2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem","content":"\n## 도커 빌드에 간단한 유니코드 문자가 문제를 일으킨 방법\n\n# 소개\n\n소프트웨어 엔지니어로서, 소프트웨어 문제가 발생할 때, 그 원인을 파악하는 것을 좋아합니다. 따라서, 우리가 실행 중인 시스템을 소유하거나 제어하지 못하여 충분히 파고들기 어렵다면, 해결할 수 없는 문제나 설명할 수 없는 문제는 없다고 말할 수 있습니다.\n\n이 기사에서는 간단한 유니코드 문자가 문제를 일으킨 방법을 분석하겠습니다. 이 문제는 해결하기 위해 많은 시간을 투자했지만, 해결할 수 없었던 것처럼 보였습니다. 걱정하지 마세요, 여전히 해결책을 찾아가겠지만, 다른 문제를 일으킬 수 있다는 주의를 요청드립니다.\n\n<div class=\"content-ad\"></div>\n\n문제에 직면하기 전에, Angular, Azure Container Registry 및 Azure Pipelines Windows 에이전트가 어떻게 연관되는지 이해해야 합니다.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png)\n\n## Azure 파이프라인 에이전트\n\nAzure 파이프라인은 마이크로소프트에서 제공하는 솔루션이며, 코드 프로젝트를 자동으로 빌드하고 테스트합니다. 지속적 통합 및 지속적 전달 (CI/CD) 관행을 결합하여 응용 프로그램을 어떠한 대상에도 빌드, 테스트 및 릴리스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nAzure 파이프라인 에이전트는 한 번에 하나의 작업을 실행하는 에이전트 소프트웨어가 설치된 컴퓨팅 인프라(컴퓨터)입니다. CI/CD 작업은 이러한 작업 내에서 수행됩니다.\n\nAzure 파이프라인은 두 가지 주요 유형의 에이전트를 제공합니다:\n\n- Microsoft 호스팅 에이전트(마이크로소프트에 의해 클라우드에서 호스팅되고 완전히 관리됨)\n- 자체 호스팅 에이전트(온프레미스 인프라에서 호스팅됨)\n\nAzure 파이프라인 에이전트는 여러 유형의 기계에 설치할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- macOS 에이전트\n- Linux 에이전트\n- Windows 에이전트\n- Docker 에이전트\n\n이게 왜 중요한지 조금 뒤에 알아보겠습니다.\n\n## az acr build 명령어란?\n\n익숙한 docker build 형식을 사용하여 Azure CLI의 az acr build 명령은 프로젝트를 압축하고 임시 blob 저장소로 업로드한 다음 Microsoft 호스팅 에이전트 중 하나가 이를 가져와 docker build를 수행합니다.\n\n<div class=\"content-ad\"></div>\n\n빌드 과정 중에 빌드 에이전트는 로그를 우리에게 스트리밍합니다 (나중에 이것이 왜 중요한지 알게됩니다). 작업이 완료되면 빌드된 이미지가 Microsoft Azure 클라우드에 호스팅된 관리형 Docker 레지스트리 서비스인 Azure Container Registry에 푸시됩니다.\n\n## Angular에 대하여\n\nAngular는 인기있는 오픈 소스 프론트엔드 웹 애플리케이션 프레임워크로, 동적인 단일 페이지 웹 애플리케이션(SPA) 및 점진적 웹 애플리케이션(PWA)을 구축하는 데 사용됩니다.\n\n# Angular이 책임을 집니까?\n\n<div class=\"content-ad\"></div>\n\n저희 Angular 애플리케이션의 Dockerfile을 살펴봅시다.\n\nAngular 프로젝트는 ng build 명령어를 사용하여 빌드됩니다. 이 명령어는 npm run build명령어에 의해 백그라운드에서 호출됩니다.\n\n버전 17 이전의 모든 Angular 버전에서는 완료 후에 npm run build명령에 대한 출력으로 다음 텍스트가 표시됩니다:\n\n![Angular output](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_1.png)\n\n<div class=\"content-ad\"></div>\n\n녹색 체크 표시는 \"✔\"가 유니코드 문자 (코드 U+2714)인 것이 문제를 만드는 원인이 됩니다.\n\n# Azure DevOps 에이전트가 잘못되었다\n\n다음과 같은 YAML 파이프라인 정의를 사용하여 Azure 파이프라인에서 az acr 빌드 명령을 Windows 에이전트에서 실행해 봅시다 (Windows OS가 중요한 이유를 조금 후에 알게 될 것입니다):\n\nPython을 사용하여 Windows OS 기계에서 다음 명령을 실행함으로써 동일한 오류를 재현할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n(파이썬 -c \"print('\\u2714')\") >> output.txt\n```\n\n# 발생하는 위치와 이유\n\n만약 자체 호스팅된 에이전트를 사용한다면, 파이프라인 로그 중에 하나도 에이전트의 컴퓨터에 저장되지 않음을 알 수 있습니다. 대신, 저희가 사용하는 파이프라인 에이전트는 모든 로그를 Azure DevOps 서버로 보내어 저장합니다.\n\n문제는 '체크 마크'로 알려진 '\\u2714' 문자가 파이프라인 에이전트에서 디코딩을 시도할 때 발생합니다. 이는 colorama/ansitowin32.py 스크립트 파일 내에서 다음과 같은 에러 로그 부분에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nD:\\a\\_work\\1\\s\\build_scripts\\windows\\artifacts\\cli\\Lib\\site-packages\\colorama/ansitowin32.py\n```\n\n플로우 다이어그램을 살펴보고 모든 구성 요소가 서로 어떻게 대화하는지 살펴봅시다.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_2.png)\n\n기술적으로, 2단계와 3단계의 경우 우리의 압축된 프로젝트는 Azure Blog 스토리지에 업로드되며, ACR 빌드 에이전트에 의해 가져옵니다. 마찬가지로 ACR 빌드 에이전트는 Azure Blog 스토리지에 로그를 저장한 후 az acr 명령어의 일부로 스트리밍됩니다.\n\n<div class=\"content-ad\"></div>\n\nAzure 파이프라인 빌드 에이전트에서 오류가 발생했습니다. 단계 3과 4 사이에서 발생한 오르로, Azure 블로그 스토리지에서 로그를 스트리밍하고 stdout로 출력하는 과정 중에 발생했습니다.\n\nAzure CLI 서버는 터미널에 색상이 있는 텍스트를 생성하기 위해 colorama(파이썬 패키지)를 사용합니다. 이를 위해 stdout을 래핑하여 찾은 ANSI 시퀀스를 제거하고(결과물로 나타나는 의미없는 문자열을) 해당 시퀀스를 수정하는 적절한 Win32 API 호출로 변환합니다.\n\n## Azure CLI 소스 코드 심층 분석\n\nAzure CLI에서 발생한 오류는 command_modules/acr/\\_stream_utils.py 파일의 143번째 줄에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport colorama\n.\n.\ncolorama.init()\n.\n.\nprint(flush.decode('utf-8', errors='ignore'))\n```\n\n이 줄은 단순히 UTF-8 디코딩된 바이트 스트링을 출력합니다 (블롭 스토리지에서 검색된 로그 데이터). 그러나 colorama 패키지가 가져와서 초기화되었으므로 다음 print 명령은 텍스트에 색상 또는 스타일을 추가하는 colorama의 기능을 활용할 것입니다.\n\nColorama는 Win32 API 호출을 사용하여 터미널 상태를 수정하며, Win32 API는 기본적으로 Unicode-특정 문자를 지원하지 않는 ANSI 코드 페이지를 사용합니다. 이는 Unicode 문자열을 표시하려고 시도하는 동안 Unicode 코드 페이지를 지원하지 않는 API를 사용하려는 것이 우리 문제의 근본 원인입니다.\n\n이제 우리는 백그라운드에서 무슨 일이 일어나는지 이해하기 시작합니다. 그러나 실제 솔루션을 살펴보기 전에 다른 가능한 어정쩡한 솔루션을 확인해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 로그 없이도 문제 없을까요?\n\n로그를 비활성화하면 문제가 해결될 것으로 생각할 수 있습니다. 비록 그게 맞긴 하지만, 더 나은 방법이 있습니다. 로그를 비활성화하는 방법은 두 가지가 있습니다:\n\n- -- no-logs 인수를 추가하여 az acr build 명령에서 로그 스트리밍을 완전히 비활성화합니다. 이것은 빌드 로그를 완전히 잃어버리기 때문에 이 방법은 최악의 해결책입니다.\n\n```js\naz acr build --no-logs --registry $(Registry) --image \"$(image):$(tag)\" .\n```\n\n<div class=\"content-ad\"></div>\n\n- `ng build` 명령어의 진행 로그를 `--progress=false` 인수로 비활성화하세요. 진행과 관련된 로그의 일부를 여전히 잃게 되어 이는 이상적인 해결책은 아닙니다.\n\n```js\nRUN npm run build -- --progress=false\n```\n\n# 진짜 해결책\n\n해결책을 살펴보기 전에, 인코딩과 문자 집합(코드 페이지)이 어떻게 작동하는지에 대해 이해해야 합니다. Unicode와 문자 집합에 관해 꼭 알아야 할 절대 최소한의 정보 - 모든 소프트웨어 개발자가 반드시 알아야 할 것 (변명 금지!) -이라는 글을 읽는 것을 강력히 권장합니다.\n\n<div class=\"content-ad\"></div>\n\n- ACP은 ANSI (American National Standards Institute) 코드 페이지를 나타내며, 미국 및 서유럽 지역의 기본값은 Windows-1252 문자 세트로 설정됩니다. 이는 레거시 GUI 애플리케이션에서 사용됩니다.\n- OEMCP는 제조업체 코드 페이지를 의미하며, 기본값은 437 (원래 IBM PC의 문자 세트)로 설정됩니다. 이는 레거시 콘솔 애플리케이션에서 사용됩니다.\n\nPowerShell을 통해 다음 레지스트리 경로를 확인하여 Windows 레지스트리에서 현재 정의된 ANSI 코드 페이지와 OEM 코드 페이지를 확인할 수 있습니다:\n\n```shell\nGet-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage `\n  | Select-Object OEMCP, ACP\n```\n\n<img src=\"/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_3.png\" />\n\n<div class=\"content-ad\"></div>\n\n지역 설정에 따라이 값은 코드 페이지 식별자 목록에서 어느 것이든 취할 수 있습니다. 가장 일반적인 것은 다음과 같습니다:\n\n- 874-태국어\n- 932-ShiftJIS — 일본어\n- 936-GBK — 중국어 (중국 본토, 싱가포르)\n- 949-한국 통합 한글\n- 950-Big5 Extended — 중국어 (대만, 홍콩)\n- 1250-중앙 유럽\n- 1251-키릴 자모\n- 1252-미국 (ANSI)\n- 1253-그리스어\n- 1254-터키어\n- 1255-히브리어\n- 1256-아랍어\n- 1257-발트 어\n\ncmd.exe 및 powershell.exe에서 텍스트는 현재 지정된 ANSI 코드 페이지를 사용하여 작성하고 읽습니다.\n\n유니코드 특수 문자 인코딩을 지원하기 위해 Windows 레지스트리 항목을 변경하여 Windows가 UTF-8 인코딩 (코드 페이지 65001)을 사용하도록 설정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\nNew-ItemProperty -LiteralPath 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage' -Name 'ACP' -Value '65001' -PropertyType String -Force;\n\n\n전 세계 언어 지원을 위해 유니코드 UTF-8 사용 베타 기능을 활성화함으로써 비슷한 결과를 얻을 수 있습니다.\n\n- intl.cpl을 실행합니다.\n- \"관리자\" 탭을 엽니다.\n- \"시스템 로캘 변경\"을 엽니다.\n- \"베타: 전 세계 언어 지원을 위한 유니코드 UTF-8 사용\"을 활성화합니다.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 이 솔루션으로 다른 문제가 발생하는 방법\n\n그러나 이것은 오래된 Windows 버전에서 부팅 문제를 일으키며, PowerShell을 작은 글꼴 크기로 고정시키고 텍스트가 올바르게 표시되지 않는 등의 문제를 일으킵니다. 따라서 이 문제를 해결함으로써 다른 문제가 발생할 수 있습니다.\n\n그래서 우리는 여기서 덜 나쁜 것을 선택하는 것 뿐입니다.\n\n## Linux 에이전트\n\n<div class=\"content-ad\"></div>\n\n이제 질문이 생깁니다. Linux 기반 Azure DevOps 에이전트에서도 동일한 오류가 발생하는가요? 답은 아니오, 왜냐하면 colorama가 터미널 출력을 변경하기 위해 Win32 API 호출을 하지 않기 때문입니다.\n\n# Angular 버전 17.x가 이 문제를 어떻게 해결했는지\n\n실은 매우 간단합니다. Angular 버전 17부터는 'ng build' 명령어의 빌드 출력에 '✔' (유니코드 문자)는 더 이상 표시되지 않으며, 따라서 Win32 API와의 인코딩 문제를 일으키지 않게 되었습니다. 그게 다에요.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_5.png)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n처음에 해결할 수 없는 것 같은 코딩 문제는 먼저는 좀 짜증이 나겠지만, 이를 해결해내는 것이 우리 소프트웨어 엔지니어들이 하는 일입니다. 우리의 인내와 끈기를 시험하며, 해결되면 귀중한 경험을 안겨주고 배경에서 어떻게 작동하는지에 대한 자세한 통찰력을 제공합니다.\n\n명확한 해결책이 없는 도로 봉쇄물에 부딪힌 것은 좌절스러울 수 있지만, 그러한 도로 봉쇄물이 우리에게 성장과 학습 기회를 제공하는 것을 기억하는 것이 중요합니다. 궁극적으로, 이들은 우리를 다른 소프트웨어 엔지니어들과 깊이 이해차로 만들어 줍니다.\n\n그러니 이것이 지나가고 과거에 겪었던 해결이 어렵다고 여겼던 코딩 문제를 다시 시도해 보는 동기가 되길 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n이 글에서 사용된 모든 소스 코드는 제 GitHub 저장소에 있습니다.\n\n# 쉽게 이해할 수 있는 용어로 🚀\n\nIn Plain English 커뮤니티에 함께 해주셔서 감사합니다! 떠나시기 전에:\n\n- 작성자를 박수로 격려하고 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기\n","ogImage":{"url":"/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png"},"coverImage":"/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png","tag":["Tech"],"readingTime":8},{"title":"애플리케이션 성능을 높이는 Angular Signals, Reactive Context, 그리고 동적 의존성 추적 방법","description":"","date":"2024-06-22 05:00","slug":"2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking","content":"\n\nAngular Signals를 효과적으로 사용하려면 \"반응형 컨텍스트\" 개념과 의존성 추적 방법을 이해하는 것이 중요합니다. 이 글에서는 이 두 가지를 설명하고 관련 버그를 피하는 방법을 보여 드리겠습니다.\n\n## 의존성 추적\n\nAngular Signals를 사용할 때 구독하고 구독 해제에 대해 걱정할 필요가 없습니다. 작동 방식을 이해하려면 몇 가지 용어가 필요합니다:\n\n- 의존 그래프: 노드의 그래프, 각 노드는 ReactiveNode 인터페이스를 구현합니다.\n- 생산자: 값을 포함하고 새 값에 대해 알림을 보내는 노드(반응성을 \"생산\"함).\n- 소비자: 생성된 값들을 읽는 노드(반응성을 \"소비\"함).\n\n<div class=\"content-ad\"></div>\n\n신호는 생산자이며, computed()는 생산자이자 소비자이며, effect()는 소비자이며, 템플릿은 소비자입니다.\n\n자동 의존성 추적이 작동하는 방식: 모든 반응 노드에 대한 전역 변수인 activeConsumer가 있고, computed()가 계산 함수를 실행할 때마다, effect()가 부수 효과 함수를 실행할 때마다, 또는 변경 사항을 확인할 때마다 실행할 때마다, 다음을 수행합니다:\n\n- activeConsumer의 값을 읽어 이전 소비자를 기억합니다.\n- 자신을 activeConsumer로 등록합니다.\n- 함수를 실행하거나 템플릿을 실행합니다 (일부 신호는이 단계에서 읽힐 수 있음).\n- 이전 소비자 (단계 1에서)를 activeConsumer로 등록합니다.\n\n어떤 생산자도 읽힐 때는 activeConsumer의 값을 검색하고이 활성 소비자를 신호에 종속된 소비자 목록에 포함합니다. 신호가 업데이트되면 목록에서 각 소비자로 알림을 전송합니다.\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 단계별로 어떻게 일이 진행되는지 살펴봅시다.\n\n```js\n@Component({\n  template: `\n   Items count: { $items().length }\n   Active items count: { $activeItemsCount() }\n`   \n})\nclass ExampleComponent {\n  protected readonly $items = signal([{id: 1, $isActive: signal(true) }]);\n\n  protected readonly $activeItemsCount = computed(() => {\n    return this.getActiveItems().length;\n  });\n\n  private getActiveItems() {\n    return this.$items().filter(i => i.$isActive());\n  }\n}\n```\n\n- 템플릿은 activeConsumer의 값을 읽고 이를 prevConsumer 변수에 저장합니다. (이 변수는 템플릿 내에서만 사용 가능함);\n- 템플릿은 자신을 activeConsumer로 설정합니다;\n- $items() 신호를 호출하여 값을 가져옵니다;\n- $items 신호는 activeConsumer의 값을 검색합니다;\n- 받은 값이 비어 있지 않으므로 (이는 템플릿에 대한 링크를 포함하고 있음), $items 신호는 이 값(우리 템플릿에 대한 링크)을 소비자 목록에 넣습니다. 이후 $items가 업데이트될 때마다 템플릿에 통지됩니다 — 종속성 그래프에 새 링크가 만들어집니다;\n- $items는 값으로 반환되어 템플릿에 전달됩니다;\n- 템플릿은 $activeItemsCount 신호의 값을 읽습니다. 값을 반환하려면 $activeItemsCount는 계산 함수를 실행해야 합니다(computed 함수에 전달한 함수);\n- 계산 함수를 실행하기 전에 $activeItemsCount는 activeConsumer의 값을 읽고 이를 로컬 변수 prevConsumer에 저장합니다. $activeItemsCount도 소비자이므로 activeConsumer 변수에 자체를 가리키는 링크를 추가합니다;\n- 계산 함수는 getActiveItems() 함수를 호출합니다;\n- 이 함수 내에서는 $items의 값을 읽습니다 — 3에서 6단계를 반복하지만, 템플릿이 이미 $items에 의존하고 있기 때문에, 5단계는 새 소비자를 목록에 추가하지 않습니다;\n- 반환된 값(아이템 배열)을 획득하면 getActiveItems()는이 배열의 각 요소를 읽고 $isActive의 값을 읽습니다;\n- $isActive는 신호입니다. 값으로 반환하기 전에 3에서 6까지 단계를 다시 반복합니다. 4단계에서 $isActive는 activeConsumer의 값을 검색합니다. 이때 activeConsumer에는 $activeItemsCount에 대한 링크가 포함되어 있으므로 5단계에서 $isActive (배열의 각 요소마다)는 $activeItemsCount를 종속 소비자 목록에 추가합니다. $isActive가 업데이트될 때마다 $activeItemsCount에 통지됩니다. $activeItemsCount는 템플릿에 값을 갱신해야 함을 통지하며 계산해야 함을 알립니다. 그 후, 템플릿에서 마침내 (통지 바로 다음이 아니라) $activeItemsCount에게 새로운 값을 물어봅니다. 그리고 7단계부터 14단계가 반복됩니다;\n- getActiveItems()가 값을 반환합니다. $activeItemsCount는이 값을 계산에 사용하고 반환하기 전에 로컬 변수 prevConsumer의 값을 activeConsumer 변수에 넣습니다;\n- $activeItemsCount가 값을 반환합니다;\n- 템플릿은 이전에 저장한 prevConsumer 값을 activeConsumer에 넣습니다.\n\n리스트가 길지만 꼼꼼히 읽어주시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n가장 중요한 것은 여기서 소비자들 (computed(), effect(), templates)가 읽은 신호를 종속성 목록에 추가하는 걱정을 할 필요가 없다는 것입니다. 신호들은 자체적으로 activeConsumer 변수를 사용하여 이 작업을 수행합니다. 이 변수는 모든 반응성 노드에서 접근할 수 있으므로, 어떤 신호가 함수 체인의 어느 정도 깊은 곳에서 읽히든 상관없이 모든 신호는 activeConsumer의 값을 얻고 이를 소비자 목록에 추가할 것입니다.\n\n기억하세요: 템플릿, computed() 또는 effect() (소비자)에서 함수를 호출하고, 그 함수가 다른 함수를 읽고, 다른 함수가 다시 다른 함수를 읽는 경우에... 마침내 어떤 수준에서 함수가 신호를 읽고, 그 신호가 해당 소비자를 목록에 추가하고 업데이트에 대해 알릴 것입니다.\n\n디버깅과 같이 읽는 것은 지루할 수 있으므로, 이 작은 앱으로 당신을 즐겁게 해드리겠습니다:\n\n이 앱에서 다음을 수행해주십시오:\n\n<div class=\"content-ad\"></div>\n\n- 버튼 “2”를 눌러 활성화하고 다시 한 번 클릭하세요. 버튼 위의 “Active items” 텍스트가 변경되는 것을 확인하세요;\n- “Add Item” 버튼을 클릭하세요;\n- 버튼 “4”를 클릭하세요. “Active items” 텍스트가 변경되지 않는 것을 확인하세요;\n- 버튼 “2”를 클릭하세요;\n- 이제 버튼 “4”를 여러 번 클릭하고 “Active items” 텍스트가 예상대로 변경되는 것을 확인하세요.\n\n하지만 왜 그럴까요? 코드를 확인해보겠습니다:\n\n```js\nexport type Item = {\n  id: number;\n  $isActive: WritableSignal<boolean>;\n};\n\n@Component({\n  selector: 'my-app',\n  template: `\n    <div>Active items: { $activeItems() }</div>\n    <div>\n      <span>Click to to toggle:</span>\n      @for(item of items; track item.id) {\n        <button (click)=\"item.$isActive.set(!item.$isActive())\" \n                [class.active]=\"item.$isActive()\">\n          { item.id }\n       </button>\n      }\n    </div>\n    <div>\n      <button (click)=\"addItem()\">Add Item</button>\n    </div>\n  `,\n})\nexport class App {\n  protected readonly items: Item[] = [\n    { id: 1, $isActive: signal(true) },\n    { id: 2, $isActive: signal(false) },\n    { id: 3, $isActive: signal(true) },\n  ];\n\n  protected readonly $activeItems = computed(() => {\n    const ids = [];\n    for (const item of this.items) {\n      if (item.$isActive()) {\n        ids.push(item.id);\n      }\n    }\n    return ids.join(', ');\n  });\n\n  protected addItem() {\n    this.items.push({\n      id: this.items.length + 1,\n      $isActive: signal(false),\n    });\n  }\n}\n```\n\n이제 “Active items” 라인이 정확하게 업데이트되지 않는 이유를 분석해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 템플릿에서 바인딩:\n\n```js\n<div>활성 항목: { $activeItems() }</div>\n```\n\n$activeItems은 computed()에 의해 제공되는 시그널입니다:\n\n```js\nprotected readonly $activeItems = computed(() => {\n  const ids = [];\n  for (const item of this.items) {\n    if (item.$isActive()) {\n      ids.push(item.id);\n    }\n  }\n  return ids.join(', ');\n});\n```\n\n<div class=\"content-ad\"></div>\n\ncomputed() 함수에 전달하는 함수는 읽는 신호 중 하나라도 업데이트될 때마다 다시 실행됩니다. 그 곳에서는 어떤 신호를 읽을까요?\n\n이는 this.items 배열의 각 항목의 $isActive 신호입니다.\n\n그렇다면 왜 단계 2와 3 이후에 $activeItems이 업데이트되지 않았을까요?\n\n계산 함수는 의존하는 신호 중 하나가 업데이트될 때에만 다시 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n\"Add Item\"을 클릭하면 이.items를 수정하고 새 항목 내에 새 신호를 생성합니다. 그러나 이 순간 이전에 computed() 함수가 해당 신호를 읽어본 적이 없기 때문에 의존 목록에 없습니다.\n\n\"Add Item\"을 클릭하기 전과 후에도 $activeItems가 의존하는 신호 목록은 바뀌지 않습니다: this.items의 세 항목에서 나오는 세 $isActive 신호입니다.\n\n\"Add Item\"을 클릭할 때 이러한 신호 중 어느 것도 수정되지 않기 때문에 computed() 함수에 알림이 전달되지 않고 계산 함수가 다시 실행되지 않습니다.\n\n우리는 새 항목을 버튼 목록에서 여러 번 토글할 수 있지만, 처음 세 항목의 신호만 $activeItems에 알림을 보내고 우리가 전송한 함수가 다시 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 우리가 계산 함수를 다시 실행하면, 이.items에서 모든 항목을 다시 읽고 새로운 시그널을 읽게 될 것입니다. 새로운 시그널은 $activeItems 노드의 새로운 종속성이 되며, 그중 하나가 변경될 때마다 알림을 받게 될 것입니다.\n\n이를 위해 기존 종속성 중 하나를 수정해야 합니다: 이것이 step 4에서 \"2\" 버튼을 클릭하는 이유입니다.\n\n이 예시는 computed()와 effect()에 전달하는 함수가 업데이트된 생산자 중 하나가 있을 때에만 다시 실행되는 것을 상기시키기 위해 만들어졌습니다.\n\n이것이 computed()가 어떤 종속성을 가지고 있고 그 중 어떤 것이 다시 계산을 유발해야 하는지 재확인하는 것이 언제나 유용한 이유입니다. 그 중 몇 가지는 유배제용()을 사용해야 할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\ncomputed() 또는 effect()에 전달하는 일부 함수는 신호를 읽을 수 있습니다 (또는 호출된 함수가 신호를 읽을 수 있습니다).\n\n```js\nthis.$petWalkingIsAllowed = computed(() => {\n  return this.$isFreeTime() && this.isItGoodWeatherOutside();\n});\n\nisItGoodWeatherOutside() {\n  return $isSunny() && $isWarm() && !$isStormy();\n}\n```\n\n원하지 않는 다시 계산을 피하기 위해 해당 호출을 untracked()로 감싸야 할지 여부를 이해하기 위해 이러한 논리를 사용할 수 있습니다:\n\n- 만약 우리가 computed()가 새로운 값을 계산하지 말아야 하는 경우, 그 함수(isItGoodWeatherOutside())가 새로운 값을 반환할 때 untracked()로 감싸주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nthis.$petWalkingIsAllowed = computed(() => {\n  return this.$isFreeTime() && untracked(() => this.isItGoodWeatherOutside());\n});\n\nisItGoodWeatherOutside() {\n  return $isSunny() && $isWarm() && !$isStormy();\n}\n```\n\n- 만약 해당 함수로부터의 모든 새 값에 대해 계산을 다시 실행하길 원한다면 untracked()으로 감싸지 마세요.\n\n보시다시피, untracked()은 우리가 추적하고 싶은 종속성을 제어하는 데 도움이 됩니다. 또한 또 다른 중요한 측면을 관리하는 데 도움이 됩니다:\n\n## 반응형 컨텍스트\n\n\n<div class=\"content-ad\"></div>\n\n위의 \"자동 종속성 추적 방법\"에서는 activeConsumer라는 변수에 대해 언급했어요.\n\nactiveConsumer가 null이 아닌 경우, 우리가 읽는 시그널은 activeConsumer를 소비자 목록에 추가하여 나중에 이 목록의 멤버들에게 시그널의 변경 사항에 대한 알림을 보내게 됩니다. 반응 노드가 읽힐 때 activeConsumer가 비어 있는 상태라면, 반응 노드의 종속성 그래프에 새로운 링크가 생성되지 않을 거에요.\n\n다시 말해, activeConsumer가 설정되어 있을 때는 반응적인 컨텍스트 내에서 시그널을 읽고 있는 것이에요.\n\n대부분의 경우에는 반응적인 컨텍스트가 자동으로 처리되며, 의도한 링크와 종속성만이 생성되고 제거될 거예요.\n\n<div class=\"content-ad\"></div>\n\n하지만 때로는 반응적인 컨텍스트를 무의식적으로 노출시키기도 합니다.\n\n다음 앱을 시험해 봅시다:\n\n사용해 보면 다음을 알 수 있을 거에요:\n\n- \"항목 추가\"를 클릭하면 모든 상태가 완전히 재설정됩니다.\n- 상태를 토글하면 무작위로 변경되어 한 가지 버튼 이상에 영향을 줍니다.\n\n<div class=\"content-ad\"></div>\n\n빠르게 버그를 발견하실 수 있나요?\n\n```js\n@Component({\n  template: `\n    <div>Active items: { $activeItems() }</div>\n    <div class=\"flex-row\">\n      <span>Click to to toggle:</span>\n      @for(item of $items(); track item.id) {\n      <button (click)=\"item.$isActive.set(!item.$isActive())\" [class.active]=\"item.$isActive()\" [style.transform]=\"'scale('+item.$scale()+')'\">\n        { item.id }\n      </button>\n      }\n    </div>\n    <div>\n      <button (click)=\"addItem()\">Add Item</button>\n    </div>\n  `,\n})\nexport class App {\n  private readonly $itemsCount = signal(3);\n\n  protected readonly $items: Signal<Item[]> = computed(() => {\n    console.warn('Generating items!');\n   \n    const items: Item[] = [];\n    for (let id = 0; id < this.$itemsCount(); id++) {\n      const $isActive = signal(Math.random() > 0.5);\n      const $scale = signal($isActive() ? 1.2 : 1);\n      items.push({ id, $isActive, $scale });\n    }\n    return items;\n  });\n\n  protected readonly $activeItems = computed(() => {\n    const ids = [];\n    for (const item of this.$items()) {\n      if (item.$isActive()) {\n        ids.push(item.id);\n      }\n    }\n    return ids.join(', ');\n  });\n\n  protected addItem() {\n    this.$itemsCount.update(c => c + 1);\n  }\n}\n```\n\n여기서 알 수 있는 것:\n\n- 우리는 $items에서 아이템 목록을 렌더링합니다. 이는 computed()로 구성되어 있습니다.\n- $items는 새로운 아이템 배열을 생성하며, 그 수는 $itemsCount 시그널에 의해 제어됩니다. $itemsCount를 수정할 때마다 아이템이 재생성됩니다.\n- addItem()은 단순히 $itemsCount를 증가시키고, $items의 재계산을 유도합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 \"Add Item\"이 이렇게 작동하는 이유를 알 수 있습니다. 이제 상태 토글이 이상하게 동작하는 이유를 알아보겠습니다.\n\n콘솔을 열면 버튼을 클릭할 때마다 \"Generating items!\" 경고가 기록된다는 것을 알 수 있습니다. 하지만 왜 그럴까요? $itemsCount를 수정하지 않았는데 $items가 다시 계산되는 이유는 무엇일까요?\n\n아마도 이미 주목했을지도 모르지만, $items의 계산 함수가 또 하나의 반응 소스를 읽고 있는 것을 알 수 있습니다: 신호 $isActive:\n\n```js\nconst $scale = signal($isActive() ? 1.2 : 1);\n```\n\n<div class=\"content-ad\"></div>\n\n이 신호 ($isActive)은 반응적인 컨텍스트에서 읽힙니다: activeConsumer에는 $items이 포함되어 있으므로 $isActive은 모든 변경 사항에 대해 $items에 통지합니다. 따라서이 상태를 전환하려고 $isActive을 수정할 때 우리는 $items의 재계산을 발생시킵니다.\n\n이 버그를 수정하는 여러 가지 방법이 있지만, 이 접근 방식은 반응적 컨텍스트의 누출을 방지합니다:\n\n```js\nconst $scale = signal(untracked($isActive) ? 1.2 : 1);\n```\n\nuntracked()가 하는 일은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n```js\n/**\n * https://github.com/angular/angular/blob/75a186e321cb417685b2f13e9961906fc0aed36c/packages/core/src/render3/reactivity/untracked.ts#L15\n *\n * packages/core/src/render3/reactivity/untracked.ts\n *\n **/\nexport function untracked<T>(nonReactiveReadsFn: () => T): T {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n```\n\n- activeConsumer을 null로 설정하고 반환 값을 지역 변수 prevConsumer에 저장합니다.\n- 주어진 함수를 실행합니다.\n- prevConsumer에서 activeConsumer을 복원합니다.\n\n이 함수는 반응적인 컨텍스트를 일시적으로 해제하고 우리 함수를 실행한 후 반응적인 컨텍스트를 복원합니다.\n\n따라서 우리 함수가 실행되는 동안, 시그널이 읽혀지는 경우 activeConsumer에 null을 읽고 이를 소비자 목록에 추가하지 않습니다. 즉, 새로운 종속성이 생성되지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 예에서 콘솔에는 \"힌트\"가 있고, 우리의 코드는 매우 작고 간단합니다. 실제 앱에서는 신호 읽기가 함수 호출 체인 내에 깊이 숨겨져 있고, 코드가 훨씬 더 크고 복잡할 수 있습니다. 이러한 버그는 실제 앱에서 디버깅하기 어려울 수 있으므로 리액티브 컨텍스트를 누출하고 싶지 않을 때는 항상 untracked()을 사용하여 미리 방지하는 것을 권장합니다.\n\n리액티브 컨텍스트를 누락시킬 수 있는 흥미로운 예상치 못한 방법이 있습니다:\n\n- 신호를 읽는 클래스의 인스턴스를 만들기;\n- 신호를 읽는 함수를 호출하는 함수 호출하기;\n- effect() 내에서 컴포넌트 생성하기;\n- observable에 새 값을 발행하기.\n\ncomputed()와 effect()를 사용할 때,\n\n<div class=\"content-ad\"></div>\n\n- 다른 신호를 읽을 때 주의하세요. 다른 함수가 변경될 때마다 전체 함수를 다시 실행하며 다른 함수에 의해 트리거됩니다.\n- 이러한 기능들을 읽고 이해하기 쉽게 만드세요;\n- 함수 소비의 반응 소스를 모두 다시 확인하세요.\n\n자주 있듯이 암시적 의존성 추적은 혜택만 가져오는 것이 아니라 어떤 점에서는 희생을 갖고 올 수도 있습니다. 하지만 숙련된 기술과 주의를 기울여 사용할 때 Angular Signals를 사용하여 멋진 앱을 만들 수 있습니다!\n\n작성된 이 문서의 다듬어짐에 많은 기여를 한 리뷰어분들께 깊은 감사를 표합니다:\n\n- Rainer Hahnekamp\n- Josh Morony","ogImage":{"url":"/assets/img/2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking_0.png"},"coverImage":"/assets/img/2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking_0.png","tag":["Tech"],"readingTime":12},{"title":"Angular v18 출시 최신 기능 알아보기","description":"","date":"2024-06-22 04:58","slug":"2024-06-22-Angularv18isnowavailable","content":"\n\n오늘은 Angular 진화의 다음 단계를 공유하게 되어 흥분됩니다! 지난 세 번의 릴리스 동안 새로운 기능과 개선사항을 많이 소개했습니다. 이번에는 새로운 API 중 많은 부분을 안정 버전으로 승격하고, 개발자의 요청에 맞는 기능을 해결하며, 열망했던 로드맵 프로젝트 중 하나인 zoneless change detection을 실험적으로 출시했습니다.\n\n![Angularv18isnowavailable_0.png](/assets/img/2024-06-22-Angularv18isnowavailable_0.png)\n\n이번 릴리스의 하이라이트는 다음과 같습니다:\n\n- zoneless change detection에 대한 실험적 지원\n- Angular 개발자를 위한 새로운 홈페이지인 Angular.dev\n- Material 3, deferrable views, 내장 제어 흐름이 안정화되었으며 여러 개선사항이 포함되어 있습니다\n- i18n 수분화 지원, 더 나은 디버깅, Angular Material의 수분화 지원, Google 검색과 동일한 라이브러리를 통해 구동되는 이벤트 재생을 통한 서버사이드 렌더링 개선내용\n\n<div class=\"content-ad\"></div>\n\n시각적 개요를 위해 릴리스 이벤트에서 비디오를 확인해보세요:\n\n# 진화하는 변경 감지\n\n과거에는 zone.js라는 라이브러리가 Angular의 변경 감지를 트리거하는 역할을 했습니다. 이 라이브러리는 개발자 경험과 성능 면에서 몇 가지 단점이 있었습니다. 몇 년 동안 zone.js에 의존하지 않고 Angular를 사용하는 방법을 찾고 있었으며, 우리는 zoneless의 첫 실험적 API를 공유할 수 있어 매우 흥분합니다!\n\n오늘부터 Angular에서 실험적인 zoneless 지원을 시도해 볼 수 있습니다! 애플리케이션 부트스트랩에 provideExperimentalZonelessChangeDetection을 추가해 보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideExperimentalZonelessChangeDetection()\n  ]\n});\n```\n\n위와 같은 프로바이더를 추가한 후에는 angular.json 파일에서 폴리필에 있는 zone.js를 제거해주세요.\n\n앞으로 나아가 zoneless는 개발자들에게 많은 가능성을 제공합니다:\n\n- 마이크로 프론트엔드 및 다른 프레임워크와의 상호 운용성을 향상시킴\n- 더 빠른 초기 렌더링 및 실행\n- 더 작은 번들 크기 및 빠른 페이지 로딩\n- 더 가독성이 좋은 스택 트레이스\n- 더 간단한 디버깅\n\n<div class=\"content-ad\"></div>\n\n컴포넌트에서 zoneless를 사용하는 가장 좋은 방법은 signals로 처리하는 것입니다:\n\n```js\n@Component({\n  ...\n  template: `\n    <h1>Hello from { name() }!</h1>\n    <button (click)=\"handleClick()\">Go Zoneless</button>\n  `,\n})\nexport class App {\n  protected name = signal('Angular');\n\n  handleClick() {\n    this.name.set('Zoneless Angular');\n  }\n}\n```\n\n위 예시에서 버튼을 클릭하면 handleClick 메소드가 호출되어 신호 값이 업데이트되고 UI도 갱신됩니다. 이는 zone.js를 사용하는 응용 프로그램과 유사하게 작동하지만 몇 가지 차이점이 있습니다. zone.js를 사용하면 Angular은 응용 프로그램 상태가 변경될 때마다 변경 감지를 수행했습니다. 그러나 zone 없이는 Angular이 신호 업데이트와 같은 적은 트리거에 대해서만 변경 감지를 제한합니다. 이 변경에는 변경을 여러 번 연속으로 확인하는 것을 피하기 위한 코얼리싱을 포함한 새로운 스케줄러도 포함되어 있습니다.\n\n위의 버튼을 클릭하면 Angular이 코얼리싱을 통해 변경 감지를 한 번만 실행합니다. 더 많은 정보는 당사의 문서에서 zoneless를 배우세요.\n\n<div class=\"content-ad\"></div>\n\n# 존리스로 업데이트 중\n\n요즘 Angular는 흥미로운 진화를 거치고 있는데, 존리스는 그 핵심 요소 중 하나입니다. 프레임워크를 발전시키면서 모든 기존 API가 예상대로 작동하고 Angular에 도입하는 새로운 기능과의 호환성이 잘 유지되도록 하고 있습니다.\n\n존리스는 우리의 호환성 접근 방식의 또 다른 예입니다. 게다가, 기존 애플리케이션을 존리스로 이전하는 과정이 가능한 간단해지도록 하고자 했습니다. Angular의 ChangeDetectionStrategy.OnPush 변경 감지 전략과 호환되는 경우, 구성 요소는 존리스와 대부분 호환되어 변환이 매끄럽게 진행될 것입니다!\n\n# 기본값으로 병합하기\n\n<div class=\"content-ad\"></div>\n\nv18부터는 존이 없는 앱과 zone.js를 사용하며 coalescing이 활성화된 앱에 대해 동일한 스케줄러를 사용하고 있습니다. 새로운 zone.js 앱의 변경 감지 주기 수를 줄이기 위해 우리는 기본적으로 zone coalescing을 활성화했습니다.\n\n이 동작은 이전 변경 감지 동작에 의존하는 앱에서 버그를 발생시킬 수 있기 때문에 새로운 애플리케이션에 대해서만 활성화됩니다. Coalescing은 불필요한 변경 감지 주기를 줄이고 일부 애플리케이션의 성능을 크게 향상시킵니다.\n\n기존 프로젝트에 이벤트 coalescing을 적용하려면, bootstrapApplication에서 NgZone 프로바이더를 구성하세요:\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideZoneChangeDetection({ eventCoalescing: true })\n  ]\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 네이티브 await을 사용하여 Zone이 필요 없는 앱\n\nZone.js는 Angular의 변경 감지를 위해 많은 브라우저 호출을 가로챕니다. 그러나 async/await은 zone.js가 monkey patch할 수 없는 API 중 하나이기 때문에 Angular CLI를 통해 promises로 다운레벨해야 합니다. 이것은 모든 최신 브라우저가 지원하는 비동기/대기(async/await)를 promises보다 더 표현력이 있고 JavaScript 런타임에서 최적화되었다는 점에서 최적이 아닙니다.\n\n오늘날, 실험적인 zoneless change detection을 사용하는 앱을 만들면 Angular CLI는 네이티브 async/await을 사용하여 promises로 다운레벨링하지 않습니다. 이것은 디버깅을 개선하고 번들 크기를 줄일 것입니다.\n\n# 컴포넌트들은 Zone을 지원합니다\n\n<div class=\"content-ad\"></div>\n\nAngular CDK와 Angular Material에서 Zoneless 지원을 활성화했습니다. 이로 인해 Zoneless 모델의 일부 문제점을 발견하고 개선할 수 있었습니다.\n\n# Angular 개발자를 위한 새로운 홈\n\n지난 18개월 동안 우리는 angular.dev에서 직관적이고 실용적인 시작하는 과정을 제공하고 깊이 있는 안내서를 개선하기 위해 많은 노력을 기울였습니다. 오늘, 우리는 angular.dev이 Angular의 공식 문서 웹사이트로 지정되었음을 기쁘게 알려드립니다!\n\n새롭고 현대적인 느낌뿐만 아니라 WebContainers를 기반으로 한 대화형 실습 튜토리얼, 예제와 함께 제공되는 대화형 플레이그라운드, Algolia를 통해 구동되는 개선된 검색, 업데이트된 안내서, 간소화된 내비게이션 등이 추가되었습니다!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_1.png\" />\n\nangular.io의 모든 요청이 이제 자동으로 angular.dev로 리디렉션됩니다. 모든 기존 링크가 계속 작동하도록 하기 위해 개발자를 v17.angular.io로 리디렉션합니다.\n\nangular.dev로 가서 확인해보세요!\n\n# Material 3이 이제 안정화되었습니다!\n\n<div class=\"content-ad\"></div>\n\n몇 달 전에 저희는 Material 3에 대한 실험적인 지원을 소개했어요. 개발자들의 피드백을 고려하고 Material 3 컴포넌트를 다듬은 후, 안정 버전으로 업데이트했어요!\n\n이와 함께, material.angular.io도 새로운 Material 3 테마와 문서로 새롭게 업데이트되었어요.\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_2.png\" />\n\n이제 우리의 안내서에서 어떻게 Angular Material 3를 앱에서 사용할 수 있는지 찾아보세요!\n\n<div class=\"content-ad\"></div>\n\n# 개발자 미리보기에서의 Signal API\n\nAngular 버전 17.1과 17.2에서 새로운 signal 입력, signal 기반 쿼리, 그리고 새로운 출력 구문이 발표되었습니다.\n\n시그널 가이드에서 APIs를 어떻게 사용할지 알아보세요. 앞으로 몇 달 동안 여러분의 피드백을 기반으로 구현을 계속 개선하고, 안정 버전으로 승격할 것입니다.\n\n# 지연 로드 뷰가 이제 안정화되었습니다\n\n<div class=\"content-ad\"></div>\n\n지난 6개월 동안, 우리는 deferrable views에 대한 많은 관심을 받았습니다. 이를 통해 개발자들이 앱의 핵심 웹 가치를 쉽게 향상시킬 수 있다는 것을 알게되었습니다. 예를 들어, Bill.com은 @defer를 사용하여 한 앱의 번들 크기를 50% 줄였다고 나누었습니다. 오늘, deferrable views가 이제 안정화되었습니다! 여러분은 여러분의 응용 프로그램과 라이브러리에서 이를 사용할 수 있습니다.\n\n# 내장 제어 흐름이 이제 안정화되었습니다\n\nv17에서 deferrable views와 함께, 성능을 개선한 새로운 내장 제어 흐름을 발표했습니다. 이 새로운 문법이 크게 채택되었고, 커뮤니티 피드백에 대응한 후, 우리는 이 API를 안정화했다는 것을 기쁘게 발표합니다!\n\n미리보기 단계에서는 제어 흐름의 타입 체크를 추가로 개선했고, 더 많은 효율적인 암시적 변수 별칭을 활성화하고, 특정 성능 관련 안티 패턴에 대한 가드레일을 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 서버 측 렌더링 개선사항\n\n1년 전에 우리는 하이드레이션을 소개했고 v17에서 안정 버전으로 출시했습니다. 공개 HTTPArchive 데이터셋을 기반으로 하면, 프리랜더링이나 서버 측 렌더링을 사용하는 Angular v17 앱 중 76%가 이미 하이드레이션을 사용하고 있습니다.\n\n더 많은 사람들이 하이드레이션을 활용할 수 있도록 하는 데 있어 한 가지 큰 걸림돌이 있었습니다 — i18n 지원 부족이었습니다. Chrome Aurora 팀과 협력한 끝에, 우리는 i18n 블록의 하이드레이션을 개발자 미리보기 모드로 제공하는 것을 기쁘게 생겨 v18에서 사용 가능합니다!\n\n# 이벤트 재생\n\n<div class=\"content-ad\"></div>\n\n두 달 가량 전에, 우리는 Angular과 Google의 내부 프레임워크 Wiz를 융합하는 장기 진행 중인 프로젝트를 발표했어요. Angular과 Wiz는 과거에 서로 다른 앱 세그먼트를 제공했었죠 — Wiz는 소비자를 주 타깃으로 한 앱에서 주로 사용되며 성능에 초점을 맞추었고, Angular은 생산성과 개발자 경험에 중점을 둔 것이었어요.\n\n융합 노력의 결과로, Wiz는 Angular Signls를 그들의 렌더링 모델에 깊게 통합시켰어요. 우리는 ng-conf에서 YouTube가 이제 Angular Signls를 사용하고 있다는 사실을 공유했었죠. 비슷하게, Angular은 이제 부분 수분화와 같은 성능 중심의 기능을 더 많이 가져오고 있어요. 조금 후에 더 자세히 소개할게요.\n\n두 경우 모두, 우리는 여러분의 기능 요청 및 다른 요구 사항을 모티브로 두 프레임워크의 중요한 기능을 융합하고 있어요.\n\n![이미지](/assets/img/2024-06-22-Angularv18isnowavailable_3.png)\n\n<div class=\"content-ad\"></div>\n\n오늘은 Google.com에서 실행 중인 핵심 라이브러리 중 하나인 이벤트 디스패치(event dispatch)가 Angular 모노레포에 추가되었다는 좋은 소식을 전해드립니다. 이벤트 디스패치는 이제 하이브리드 렌더링을 사용할 때 이벤트 재생을 담당하며, v18부터 제공됩니다.\n\n대부분의 개발자들은 이벤트 디스패치와 직접 상호 작용하지 않을 것이므로, 왜 이벤트 재생이 유용한지 살펴보겠습니다. 아래에 간단한 전자 상거래 웹사이트의 모형을 찾을 수 있습니다. 매우 느린 네트워크 연결을 시뮬레이션하기 위해 인위적인로딩 지연을 도입했습니다. 페이지가 아직 로딩 중이고 아직 수화되지 않은 상태에서 사용자가 카트에 여러 개의 헤드폰을 추가하려고 한다고 상상해보십시오. 페이지가 아직 수화되지 않았기 때문에 상호작용할 수 없으므로 모든 사용자 이벤트가 손실됩니다. v18에서 이벤트 디스패치를 사용하여 시작하면 Angular가 사용자 이벤트를 기록하기 시작합니다. 애플리케이션이 수화되면 이벤트 디스패치가 그것들을 재생하고 카트에 여섯 개의 항목이 생기게 됩니다.\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_4.png\" />\n\n이벤트 재생 기능은 개발자 미리보기로 v18에서 사용할 수 있습니다. withEventReplay()를 사용하여 기능을 활성화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideClientHydration(withEventReplay())\n  ]\n});\n```\n\n# 디버깅 경험을 개선했습니다\n\nAngular DevTools를 업데이트하여 Angular의 수화 프로세스를 시각화했습니다. 각 구성 요소 옆에는 구성 요소의 수화 상태를 나타내는 아이콘이 있습니다. 페이지에서 Angular가 수화한 구성 요소를 미리 볼 수 있도록 오버레이 모드도 활성화할 수 있습니다. 앱에 수화 오류가 있는 경우 Angular DevTools가 구성 요소 탐색기에 시각화해줍니다.\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_5.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n우리 커뮤니티 기여자 Matthieu Riegler에게 이 기능을 추가해 준 것에 대해 큰 감사를 전합니다!\n\n## CDK 및 Material의 수분 보충 지원 \n\nv17에서 일부 Angular Material 및 CDK 구성 요소가 수분 보충에서 제외되어 다시 렌더링되는 문제가 있었습니다. v18부터 모든 구성 요소 및 기본 구성 요소가 완전한 수분 보충 호환성을 갖추었습니다.\n\n## 우리의 부분적 수분 보충 계획\n\n<div class=\"content-ad\"></div>\n\nng-conf와 Google I/O에서 부분 수분화를 발표했어요. 이 기술은 서버 사이드 렌더링 후 앱을 점진적으로 수분화할 수 있게 해줘요. 앱의 점진적 수분화는 처음에 적은 양의 JavaScript를 로드하고 앱의 성능을 향상시키는데 도움을 줘요.\n\n부분 수분화는 지연 뷰와 동일한 기반 위에 구축돼요. 오늘과 같이 서버에서 @placeholder 블록을 렌더링하는 대신, Angular가 서버에서 @defer 블록의 주요 콘텐츠를 렌더링할 수 있는 모드를 활성화할 수 있게 될 거예요. 클라이언트에서는 Angular가 템플릿에서 지정된 트리거 조건이 충족될 때에만 연기된 블록을 다운로드하고 수분화할 거에요. 예를 들어, 다음은 가상의 API 예시에요:\n\n```js\n@defer (서버에서 렌더링; 뷰포트 진입 시) {\n  <app-calendar/>\n}\n```\n\n위의 블록은 캘린더 컴포넌트를 서버에서 렌더링할 거예요. 클라이언트로 도달하면 Angular가 해당 JavaScript를 다운로드하고, 뷰포트에 들어간 후에만 상호작용 가능한 캘린더를 수분화할 거에요.\n\n<div class=\"content-ad\"></div>\n\n지금까지 부분 수분 유화에 대해 노력하고 있습니다. 이미 상호 작용 트리거와 함께 사용할 수 있는 상태에 있습니다. 우리는 현재 파트너와 함께 작업하여 구성 요소가 속성을 수신하거나 바인딩 값을 변경하는 데이터 트리거의 중요성을 평가하고 있습니다.\n\n대규모의 중요한 성능을 필요로 하는 애플리케이션을 개발하고 있고, 부분 수분 유화의 미래를 형성하는 초기 액세스 프로그램에 참여하고 싶다면 devrel@angular.io로 이메일을 보내주세요.\n\n# Firebase 앱 호스팅으로 앱에 강력한 호스팅\n\n웹 플랫폼의 점점 더 복잡해지면서 응용 프로그램의 호스팅은 성능, 신뢰성, 생산성 및 확장성 측면에서 중요한 역할을 합니다. 하이브리드 렌더링을 사용하는 앱은 서버 측 렌더링, 사전 렌더링 및 클라이언트 측 렌더링을 위한 다른 호스팅 요구 사항이 있습니다. 이 복잡성을 수동으로 관리하는 것은 부담스러울 수 있습니다. Firebase 앱 호스팅은 개발자를 위해 이 모든 것을 투명하게 처리하고 있습니다!\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_6.png\" />\n\n올해 구글 I/O에서 Firebase가 앱 호스팅을 발표했습니다. 앱 호스팅은 동적 Angular 애플리케이션의 개발 및 배포를 간소화하며 기본 프레임워크 지원, GitHub 통합 및 인증, 클라우드 Firestore, Firebase의 Vertex AI와의 통합 등을 제공합니다.\n\nAngular와 함께 Firebase 작업을 하면서 개발자 경험을 보다 원할하게 만들도록 노력해 왔습니다. 오늘 앱 호스팅을 시작하는 것에 관한 속기 보세요!\n\n# 그리고 추가로... \n\n\n<div class=\"content-ad\"></div>\n\n우리가 계속 나아가는 대규모 프로젝트들과 함께, 항상 개발자들의 일반적인 요구를 해결하기 위해 시간을 보내고 있어요. v18의 하이라이트 중 일부는 다음과 같아요:\n\n# ng-content에 대한 폴백 콘텐츠 지정\n\n가장 많은 추천을 받은 문제 중 하나는 ng-content에 대한 기본 콘텐츠를 지정하는 것이었어요. v18에서 그것이 이제 가능해졌어요! 여기에 간단한 예시가 있어요:\n\n```js\n@Component({\n  selector: 'app-profile',\n  template: `\n    <ng-content select=\".greeting\">Hello </ng-content>\n\n    <ng-content>Unknown user</ng-content>\n  `,\n})\nexport class Profile {}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 컴포넌트를 사용할 수 있습니다:\n\n```js\n<app-profile>\n  <span class=\"greeting\">좋은 아침 </span>\n</app-profile>\n```\n\n결과는 다음과 같습니다:\n\n```js\n<span class=\"greeting\">좋은 아침 </span>\n알 수 없는 사용자\n```\n\n<div class=\"content-ad\"></div>\n\n# 통합된 제어 상태 변경 이벤트\n\nAngular Forms에서 FormControl, FormGroup 및 FormArray 클래스는 이제 events라는 속성을 노출시켜 이 폼 컨트롤의 이벤트 스트림에 구독할 수 있게 했습니다. 이를 사용하여 값 변경, 터치 상태, 원시 상태 및 제어 상태의 변경을 계속 추적할 수 있습니다.\n\n이제 다음과 같이 사용할 수 있습니다:\n\n```js\nconst nameControl = new FormControl<string|null>('name', Validators.required);\nnameControl.events.subscribe(event => {\n  // 개별 이벤트 처리\n});\n```\n\n<div class=\"content-ad\"></div>\n\n이 기능 요청은 GitHub에서 440개 이상의 좋아요를 받았습니다. 저희 커뮤니티 기여자 Matthieu Riegler님 덕분에 모든 사람들에게 이용할 수 있게 되었습니다!\n\n# 응용 프로그램 빌더로의 마이그레이션 자동화\n\nAngular v17에서 우리는 \"응용 프로그램 빌더\"를 안정적인 상태로 발표하고 새로운 프로젝트에 대해 기본으로 활성화했습니다. 내부적으로는 Vite와 esbuild를 사용하여 이전 webpack 경험을 대체했습니다.\n\n대부분의 앱들에 대해, 개발자들은 angular.json을 업데이트함으로써 새로운 빌드 시스템으로 업데이트할 수 있었습니다. 지난 6개월 동안 우리는 사용자로부터 더 많은 피드백을 수집하고, 업데이트 경험을 개선하여 모두가 새로운 빌드 경험으로 이동하고 편집/새로 고침 효과를 받을 수 있도록 했습니다.\n\n<div class=\"content-ad\"></div>\n\n당사의 업데이트 가이드에서 업데이트 경험을 자동화하기 위해 개발한 도구를 찾을 수 있습니다.\n\n새로운 빌드 시스템의 핵심 경로에 웹팩이 없기 때문에 웹팩에 대한 의존성을 선택 사항으로 만들었고, 이로 인해 Angular CLI의 총 종속성 수를 50% 이상 줄일 수 있었습니다! 이 변경으로 Angular CLI 설치 시간이 더 빨라집니다.\n\n# 함수로 된 경로 리디렉션\n\n리디렉션 처리 시 더 높은 유연성을 제공하기 위해 Angular v18에서 redirectTo는 이제 문자열을 반환하는 함수를 허용합니다. 예를 들어 런타임 상태에 따라 라우트로 리디렉션하고 싶은 경우 함수에서 더 복잡한 로직을 구현할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\nconst routes: Routes = [\n{ path: \"first-component\", component: FirstComponent },\n{\npath: \"old-user-page\",\nredirectTo: ({ queryParams }) => {\nconst errorHandler = inject(ErrorHandler);\nconst userIdParam = queryParams['userId'];\nif (userIdParam !== undefined) {\nreturn `/user/${userIdParam}`;\n} else {\nerrorHandler.handleError(new Error('Attempted navigation to user page without user ID.'));\nreturn `/not-found`;\n}\n},\n},\n{ path: \"user/:userId\", component: OtherComponent },\n];\n\n\n### TypeScript 5.4\n\n마지막으로 TypeScript의 종속성이 업데이트되어 최신 TypeScript 5.4 기능을 모두 활용할 수 있게 되었습니다!\n\n### 커뮤니티 하이라이트\n\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서 일어나는 혁신은 커뮤니티에서 많은 발전을 보게 되었어요!\n\nngrx, ngxs, rxAngular와 같은 인기 있는 상태 관리 라이브러리들은 이미 앵귤러 신호를 채택하고 컴포넌트에서 세밀한 반응성을 활성화하고 있어요.\n\n두 달 전에 앵귤러 GDE인 Brandon Roberts는 Analog.js 버전 1.0을 발표했어요. 이는 앵귤러를 위한 커뮤니티 주도의 메타 프레임워크로, 파일 기반 라우팅, API 라우트, 일급 마크다운 지원 등의 멋진 기능을 제공해요. Analog.js 팀은 커뮤니티가 좋아하는 단일 파일 컴포넌트 형식을 실험하고 있어요!\n\n또 다른 생태계의 인기 라이브러리가 앵귤러 어댑터를 개발하고 있는 것도 흥미롭게 보여요. Chau Tran, Arnoud de Vries, 그리고 Corbin Crutchley가 TanStack Store, TanStack Query, TanStack Forms 지원을 앵귤러로 출시했어요!\n\n<div class=\"content-ad\"></div>\n\n세계 각지의 Angular 커뮤니티 컨퍼런스에 참여할 수 있어 기뻐요. 올해 남은 행사들도 기대되네요. 수백 명의 참가자와 수십 명의 연사를 대상으로 컨퍼런스를 기획하는 것은 쉬운 일이 아니에요. 올해 이 힘든 과제를 현실로 만들어준 모든 분들께 감사의 말씀을 전합니다. 이들에는 ng-conf, Angular Belgrade, ng-de, ng-be, NGPoland, ngRome, NG Kenya, ngIndia, Angular TLV 등이 포함돼요! 만약 빠뜨린 컨퍼런스가 있다면 댓글에서 공유해주세요.\n\n뿐만 아니라, v16 이후로 290명 이상의 사람들로부터 기여를 받았어요! 코드, 이슈, 컨텐츠, 커뮤니티 조직 또는 가능한 방법으로 도와준 모든 분들께 감사드립니다 🙏\n\n# 우리의 진전을 되돌아보며\n\nAngular 부흥의 일환으로 지난 2년 동안 많은 것을 선보였고 앞으로도 더 많은 혁신이 예정돼 있어요. 이 부분에서 현재를 살펴보고 어디에 있는지 축하하고 싶었어요.\n\n<div class=\"content-ad\"></div>\n\nAngular을 신호 및 고급 혼합 렌더링 기능으로 진화시키면서, 우리는 항상 개발자들이 자신감을 가지고 웹 애플리케이션을 제공할 수 있도록 하는 우리의 미션을 충실하게 이행해왔습니다. 현재 세계에서 두 번째로 큰 웹사이트인 YouTube가 Angular의 반응성 기본 요소를 사용하고 있어, 우리는 더 큰 작업 그룹의 일부로 신호를 웹 플랫폼에 추가하기 위해 협업하고 있습니다.\n\n또한, Vite, Nx, Cypress, Puppeteer, Storybook 등의 도구 개발자들과 긴밀히 협력하여 모든 사람을 위한 개발자 경험을 향상시키고 있습니다. 동시에, Angular로 어떤 것이 가능한지 확장하는 열정적인 개발자, 커뮤니티 조직자, 저자, 연설자들로 이루어진 커뮤니티가 있어 우리는 행운이라고 생각합니다.\n\nAngular 부흥 과정에 함께해준 여러분께 감사드립니다!","ogImage":{"url":"/assets/img/2024-06-22-Angularv18isnowavailable_0.png"},"coverImage":"/assets/img/2024-06-22-Angularv18isnowavailable_0.png","tag":["Tech"],"readingTime":14},{"title":"가디언이 Deno를 사용해 270만 개 기사에서 접근성과 성능을 감사하는 방법","description":"","date":"2024-06-22 04:56","slug":"2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles","content":"\n\n\n![Image](/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png)\n\n(원래 deno.com/blog에 게시됨.)\n\n독립 매체인 가디언은 자사의 기사의 성능과 접근성을 감사하기 위한 가벼운 유지보수 솔루션이 필요했습니다. 가디언이 Deno를 핵심 인프라에서 이용하여 270만 개의 기사 전반에 걸쳐 접근성과 성능을 감사하는 방법을 알아보세요.\n\n# 과제\n\n\n<div class=\"content-ad\"></div>\n\n가디언 웹사이트는 매달 3억 5천만 개 이상의 고유 페이지 조회수를 기록합니다. 독자들의 기대를 충족하기 위해서는 웹사이트가 성능에 최적화되어 있고 콘텐츠를 최대한 빨리 제공할 뿐만 아니라 다양한 웹 접근성 요구사항을 지원해야 합니다.\n\n대형 매체 사이트로서 각 밀리초가 중요합니다. BBC에 따르면 페이지 로딩에 추가된 1초가 사용자의 10%를 이탈시킨다고 합니다. 웹사이트의 고객 소프트웨어 엔지니어인 맥스 듀발은 \"웹사이트에 발행된 자산이 최적화되었는지를 보장하기 위한 방법이 필요했습니다\"라고 말합니다.\n\n성능 이외에도 엔지니어들은 독자들이 웹사이트에서 콘텐츠를 소비할 때 다양한 보조 기술을 사용하는 사실을 인지하고 있습니다. 자신들의 이야기가 널리 읽히도록 하려면 웹 접근성 요구사항을 준수해야 합니다. 맥스는 \"수동 감사를 통해 일부 기사에 중요 속성이 누락된 HTML 요소가 포함되어 있는 것이 밝혀졌습니다. 새로운 기사는 최상의 접근성 규칙을 준수하도록 하고 싶었으나, 이러한 불일치 사항을 대규모로 발견하는 시스템화된 자동 접근 방법이 없었습니다\"라고 말합니다.\n\n# 해결책\n\n<div class=\"content-ad\"></div>\n\n팀은 접근성 및 성능 불일치를 평가하기 위한 자동화 시스템을 구축해야 한다는 것을 알았습니다. 먼저 Node를 시도했지만 복잡성 문제에 직면했습니다. Max는 \"페이지를 다운로드하고 살펴보는 것과 같이 간단한 작업에 Node를 사용하는 것은 매우 복잡했다\"고 말합니다. \"GET 요청 수행, URL 구문 분석, 리다이렉션 해결은 모두 라이브러리를 평가하고 설치하는 것이 필요했습니다.\" 그러나 웹 표준 API를 네이티브로 지원하는 Deno를 사용하면 동일한 스크립트가 훨씬 간단해집니다. Max는 \"Deno에는 의존성 부풀림 위험이 없으므로 Node 및 npm에서 발생하는 문제가 없습니다.\"\n\n또한 Deno를 사용해 네이티브 TypeScript 지원을 즐겼습니다. Max는 \"가디언은 서버 코드의 대부분을 전통적으로 스칼라로 사용해왔는데 강한 유형화가 되어 있습니다. TypeScript는 꾸준히 인기를 얻고 있지만 번들되지 않은 애플리케이션에 사용하기 어려웠습니다. 설정 없이 TypeScript를 작성하고 실행할 수 있는 것은 우리 팀이 빠르게 움직이는 데 도움이 되었습니다,\"라고 말합니다.\n\n자동화된 시스템은 GitHub Actions에서 매일 Deno 스크립트를 실행하여 누락된 HTML 속성 및 이미지, 폰트, 기타 미디어와 같은 에셋 크기를 확인하여 접근성 및 성능을 평가합니다. 작업에 의해 나타난 어떤 차이점이라도 팀이 조사할 수 있도록 GitHub 이슈를 업데이트합니다.\n\n\"우리의 이야기들이 가능한 많은 독자들에 의해 소비될 수 있도록 하는 것에 도움이 되도록 기반을 설치하는 것이 우리에게 쉬웠다,\"고 Max는 말합니다.","ogImage":{"url":"/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png"},"coverImage":"/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png","tag":["Tech"],"readingTime":2}],"page":"21","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}