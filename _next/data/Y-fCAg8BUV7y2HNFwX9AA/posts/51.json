{"pageProps":{"posts":[{"title":"Angular 접근성 모든 사용자를 위해 만드는 방법","description":"","date":"2024-06-20 00:30","slug":"2024-06-20-AccessibleAngularBuildingforEveryUser","content":"\n\n<img src=\"/assets/img/2024-06-20-AccessibleAngularBuildingforEveryUser_0.png\" />\n\n모든 사용자의 능력에 관계없이 웹 애플리케이션을 만드는 것은 도덕적인 의무뿐만 아니라 실용적인 필요성도 있습니다. Angular는 강력한 기능과 모듈식 구조로 장애를 가진 사람들을 포함한 모든 사용자를 대상으로 하는 접근성과 포괄성 있는 웹 애플리케이션을 구축하기에 적합합니다. 본 문서에서는 Angular 애플리케이션이 모든 사람에게 접근 가능하도록 하는 데 필요한 모범 사례와 기술을 탐구합니다. 이 문서는 어느 한 형태에 국한되지 않고 개개인들이 포용을 필수적인 애플리케이션을 구축하는 데 필요한 구성 요소로 간주하도록 독려합니다.\n\n## 접근성의 필요성\n\n접근성은 장애를 가진 사람들을 포함한 모든 사용자가 웹 콘텐츠를 인지, 이해, 탐색 및 상호 작용할 수 있도록 보장합니다. 이는 포용성, 사용성 및 종종 법적 준수에 관한 문제입니다. 접근성이 있는 웹 애플리케이션은 사용자 경험을 개선하고 대중의 범위를 확대하며 사회적 책임을 실천함을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n## 웹 접근성의 주요 원칙\n\n## 인지할 수 있는\n\n모든 사용자가 인지할 수 있는 방식으로 콘텐츠를 제공해야 합니다. 이에는 비텍스트 콘텐츠에 대한 텍스트 대체물을 제공하고 정보가 다양한 방식(예: 소리와 시각)으로 제공되도록 하는 것이 포함됩니다.\n\n## 조작할 수 있는\n\n<div class=\"content-ad\"></div>\n\n인터페이스 요소들은 작동 가능해야 합니다. 사용자들은 키보드, 마우스, 터치 등 다양한 입력 방법을 사용하여 콘텐츠를 탐색하고 상호 작용할 수 있어야 합니다.\n\n## 이해하기 쉬움\n\n콘텐츠는 이해하기 쉬워야 합니다. 사용자들은 사용자 인터페이스의 정보와 작동을 이해할 수 있어야 합니다.\n\n## 견고함\n\n<div class=\"content-ad\"></div>\n\n넓은 범위의 사용자 에이전트 및 보조 기술을 신뢰할 수 있는 방식으로 해석할 수 있도록 콘텐츠가 강화되어야 합니다.\n\n## 접근 가능한 Angular 애플리케이션 구축을 위한 모범 사례\n\n## 1. 의미 있는 HTML 사용\n\n의미 있는 HTML은 웹 콘텐츠에 의미를 부여하여 접근성을 높입니다. ``header``, ``nav``, ``main``, 그리고 ``footer``와 같은 태그는 응용 프로그램에 구조를 제공하고 보조 기술이 콘텐츠를 올바르게 해석하는 데 도움을 줍니다.\n\n<div class=\"content-ad\"></div>\n\n\nhtml\n<header>\n  <nav>\n    <a routerLink=\"/\" aria-current=\"page\">Home</a>\n    <a routerLink=\"/me\">Me</a>\n    <a routerLink=\"/blog\">Blogs</a>\n  </nav>\n</header>\n<main>\n  <h1>Welcome to my Page</h1>\n  <p>Subscribe to my YouTube Channel! @babatundelmd</p>\n</main>\n<footer>\n  <p>© 2024 Babatunde Lamidi</p>\n</footer>\n\n\n## 2. Implement ARIA (Accessible Rich Internet Applications)\n\nARIA 속성은 웹 콘텐츠의 의미를 향상시켜 보조 기술에 대한 추가 정보를 제공하여 응용 프로그램을 보다 접근성이 높게 만들어줍니다. ARIA 역할, 상태 및 속성을 사용하여 응용 프로그램을 더 쉽게 접근할 수 있도록 만들어보세요.\n\n\n<button aria-label=\"close\" role=\"button\">X</button>\n\n\n<div class=\"content-ad\"></div>\n\n## 3. 키보드 탐색 보장하기\n\n모든 상호작용 요소가 키보드로 접근할 수 있도록 보장하세요. 이는 `tabindex` 속성과 Angular의 기본 포커스 관리를 사용하는 것을 포함합니다.\n\n```js\nimport { Component, AfterViewInit, ViewChild, ElementRef } from '@angular/core';\n@Component({\n selector: 'app-example',\n template: `<button #myButton>Click Me</button>`,\n})\nexport class ExampleComponent implements AfterViewInit {\n @ViewChild('myButton') myButton: ElementRef;\nngAfterViewInit() {\n this.myButton.nativeElement.focus();\n }\n}\n```\n\n## 4. 포커스 프로그래밍 방식으로 관리하기\n\n<div class=\"content-ad\"></div>\n\nAngular의 FocusMonitor를 사용하여 포커스를 동적으로 관리하여 사용자가 항상 애플리케이션 내에서 자신의 위치를 인식할 수 있도록합니다.\n\n```js\nimport { Component, OnInit, ElementRef, ViewChild } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\n\n@Component({\n selector: 'app-focus-example',\n template: `<input #inputField type=\"text\" />`,\n})\nexport class FocusExampleComponent implements OnInit {\n @ViewChild('inputField') inputField: ElementRef;\n private focusMonitor = inject(FocusMonitor)\n\n ngOnInit() {\n  this.focusMonitor.monitor(this.inputField.nativeElement).subscribe(origin => {\n   if (origin) {\n    console.log('Focused from', origin);\n   } else {\n    console.log('Blurred');\n   }\n  });\n }\n}\n```\n\n## 5. 양식 접근성 확보\n\n양식 컨트롤에 레이블을 올바르게 지정하고 적절한 ARIA 속성을 사용하십시오. 키보드를 사용하여 양식을 탐색하고 제출할 수 있도록 보장하세요.\n\n<div class=\"content-ad\"></div>\n\n\n<label for=\"username\">사용자 이름</label>\n<input type=\"text\" id=\"username\" name=\"username\" />\n<label for=\"email\">이메일</label>\n<input type=\"email\" id=\"email\" name=\"email\" />\n<button type=\"submit\" role=\"button\">제출</button>\n\n\n## 6. 충분한 색 대비 보장\n\n시각 장애가 있는 사용자를 위해 텍스트와 배경 간의 높은 대비는 가독성을 향상시킵니다. WebAIM의 색 대비 점검기와 같은 도구를 사용하여 접근성 표준을 준수하는지 확인해보세요.\n\n## 7. 비 텍스트 콘텐츠를 위한 텍스트 대체 제공하기\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<img src=\"image.jpg\" alt=\"이미지 설명\" aria-label=\"프로필 사진\">\n<video controls>\n  <source src=\"intro.mp4\" type=\"video/mp4\" />\n  <track kind=\"captions\" src=\"intro_captions.vtt\" srclang=\"en\" label=\"영어\">\n</video>\n```\n\n## Angular CDK를 활용한 접근성 강화\n\nAngular Component Dev Kit (CDK)은 접근성이 뛰어난 애플리케이션 구축을 더 쉽게 해주는 도구를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## A11yModule\n\n이 모듈은 포커스 관리 및 실시간 공지를 포함한 다양한 접근성 유틸리티를 제공합니다.\n\n```js\nimport { A11yModule } from '@angular/cdk/a11y';\n@NgModule({\n imports: [A11yModule],\n})\nexport class AppModule {}\n```\n\n## FocusTrap\n\n<div class=\"content-ad\"></div>\n\n특정 요소 내에서 포커스를 잡아두어, 모달과 대화 상자 등에 유용합니다.\n\n```js\nimport { FocusTrapFactory } from '@angular/cdk/a11y';\nimport { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';\n\n@Component({\n selector: 'app-modal',\n template: `<div #modalContent><button>Close</button></div>`,\n})\nexport class ModalComponent implements AfterViewInit {\n @ViewChild('modalContent') modalContent: ElementRef;\n private focusTrap;\n\n constructor(private focusTrapFactory: FocusTrapFactory) {}\n\n ngAfterViewInit() {\n this.focusTrap = this.focusTrapFactory.create(this.modalContent.nativeElement);\n this.focusTrap.focusInitialElement();\n }\n}\n```\n\n## 웹 접근성을 고려한 Angular Material\n\nAngular Material은 웹 접근성을 고려하여 설계되었습니다. 해당 컴포넌트는 WCAG(`Web Content Accessibility Guidelines` 표준)을 준수하는 데 사용되어, 애플리케이션이 강력한 접근성 기반으로 시작될 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { MatInputModule, MatButtonModule } from '@angular/material';\n@NgModule({\n imports: [MatInputModule, MatButtonModule],\n})\nexport class AppModule {}\n```\n\n웹 접근성이란 모든 사용자에게 포용되고 사용하기 쉬운 웹 환경을 만드는 데 준수만큼 중요합니다. Angular의 도구와 기능을 활용하고 최상의 모범 사례를 따르며 애플리케이션을 지속적으로 테스트하고 개선함으로써 모든 사용자가 웹 애플리케이션에 접근하고 혜택을 받을 수 있도록 보장할 수 있습니다. 개발 프로세스에서 웹 접근성을 핵심 원칙으로 받아들이면 포괄적이고 사용자 친화적인 애플리케이션을 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-AccessibleAngularBuildingforEveryUser_0.png"},"coverImage":"/assets/img/2024-06-20-AccessibleAngularBuildingforEveryUser_0.png","tag":["Tech"],"readingTime":6},{"title":"제목 Angular 프로젝트를 처음부터 만드는 방법DidLoad 어드바이저, 당신의 열정과 프로그래밍 기술이 빛을 발하는 시간입니다 오늘은 Angular 프로젝트를 처음부터 만들어보는 방법에 대해 알아볼 거에요 함께 시작해볼까요 ","description":"","date":"2024-06-20 00:29","slug":"2024-06-20-HowtoCreateanAngularProjectfromScratch","content":"\n\n\n![Angular Project](/assets/img/2024-06-20-HowtoCreateanAngularProjectfromScratch_0.png)\n\nAngular은 강력하고 확장 가능한 웹 애플리케이션을 구축할 수 있는 널리 사용되는 웹 개발 프레임워크입니다. Angular에 처음이신 분들을 위해 스크래치에서 자체 프로젝트를 개발하기 시작하고 싶다면, 이 기사가 필요한 단계를 안내해 드립니다. 새 프로젝트를 설정하고, 컴포넌트를 생성하고, 라우트를 구현하는 방법 등을 배우게 될 것입니다. 시작해 봅시다!\n\nRead this article in Spanish: Crear un proyecto en Angular | Medium\n\n# Prerequisites\n\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에, 당신의 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요. Node.js는 공식 Node.js 웹사이트(https://nodejs.org)에서 다운로드하여 설치할 수 있습니다. Angular는 Node.js와 npm(Node Package Manager)을 사용하여 종속성 및 개발 환경을 관리합니다.\n\n# 단계 1: Angular CLI 설치\n\nAngular CLI(Command Line Interface)는 Angular 프로젝트를 쉽게 생성하고 관리할 수 있도록 도와주는 명령줄 도구입니다. 터미널을 열고 다음 몤령어를 실행하여 Angular CLI를 전역으로 설치해보세요:\n\n```js\nnpm install -g @angular/cli\n```\n\n<div class=\"content-ad\"></div>\n\n설치가 완료되었으면 다음 명령을 실행하여 Angular CLI가 성공적으로 설치되었는지 확인하세요:\n\n```js\nng version\n```\n\n# 단계 2: 새 프로젝트 생성\n\n이제 Angular CLI를 설치했으므로 새 Angular 프로젝트를 생성할 수 있습니다. 터미널에서 다음 명령을 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nng new my-angular-project\n```\n\n이 명령은 \"my-angular-project\"라는 새 디렉토리를 만들고 초기 프로젝트 구조를 생성합니다.\n\n# 단계 3: 프로젝트 디렉토리로 이동\n\n다음 명령을 사용하여 새로 생성된 프로젝트 디렉토리로 이동하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\ncd my-angular-project\n```\n\n# 단계 4: 개발 서버 시작하기\n\n프로젝트 디렉토리에 들어간 후, 아래 명령을 실행하여 Angular 개발 서버를 시작하세요:\n\n```js\nng serve\n```\n\n<div class=\"content-ad\"></div>\n\n프로젝트를 컴파일하고 로컬 서버에서 실행합니다. 웹 브라우저를 열고 http://localhost:4200으로 이동하세요. Angular 애플리케이션이 정상적으로 작동하는 것을 확인할 수 있습니다.\n\n# 단계 5: 컴포넌트 생성하기\n\n컴포넌트는 Angular에서의 기본적인 구성 요소입니다. 다음 명령어를 사용하여 컴포넌트를 생성할 수 있습니다:\n\n```js\nng generate component 컴포넌트명\n```\n\n<div class=\"content-ad\"></div>\n\n이렇게 하면 새로운 컴포넌트를 위해 필요한 TypeScript 파일, HTML 템플릿 및 CSS 스타일링 파일이 자동으로 생성됩니다.\n\n# 단계 6: 라우트 구성\n\n라우트를 설정하면 애플리케이션 내의 여러 컴포넌트 간을 이동할 수 있습니다. 라우트를 구성하려면 app-routing.module.ts 파일을 열고 다음 코드를 추가하세요:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { AboutComponent } from './about/about.component';\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n];\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n위 코드는 \"HomeComponent\"와 \"AboutComponent\" 두 개의 컴포넌트를 위한 라우트를 구성합니다. 이에 따라 이러한 컴포넌트와 해당하는 템플릿을 만들어주세요.\n\n# 단계 7: 컴포넌트에 내용 추가하기\n\n이제 새롭게 생성한 컴포넌트에 내용을 추가할 수 있습니다. 컴포넌트 파일 (component-name.component.ts, component-name.component.html, 그리고 component-name.component.css)을 열고 필요에 맞게 사용자 정의하세요. 텍스트, 이미지, 링크 등을 추가할 수 있습니다.  \n\n<div class=\"content-ad\"></div>\n\n# 단계 8: 애플리케이션 실행\n\n컴포넌트에 내용을 추가한 후 파일을 저장하고 터미널로 돌아가세요. Angular 개발 서버가 여전히 실행 중인지 확인해주세요. 그렇지 않은 경우 다음 명령을 다시 실행하세요:\n\n```js\nng serve\n```\n\n그런 다음 브라우저를 열고 http://localhost:4200 으로 이동하세요. 여태까지 생성한 Angular 애플리케이션과 컴포넌트 및 라우트가 표시되어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n축하합니다! 처음으로 Angular 프로젝트를 처음부터 만드셨군요. 이제 더 많은 것을 탐험하고 배우실 수 있을 거에요.\n\n# 요약 및 권장 사항\n\n이 글에서는 처음부터 Angular 프로젝트를 만드는 방법을 배우셨습니다. Angular CLI 설치부터 라우트 구성, 컴포넌트 생성까지 기본 단계를 다뤘습니다. 몇 가지 최종 권장 사항을 안내해드리겠습니다:\n\n- Angular CLI에 의해 생성된 파일 구조에 익숙해지세요. 프로젝트를 효율적으로 구성하는 데 도움이 될 거에요.\n- Angular 공식 문서(https://angular.io)를 살펴보세요. 프레임워크의 기능과 능력에 대해 더 알 수 있을 거에요.\n- 다양한 컴포넌트를 구축하고 Angular 기능들을 실험해보세요.\n- Angular 커뮤니티에 가입하고 포럼과 토론 그룹에 참여하세요. 다른 개발자들로부터 배우고 교류하는 좋은 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n이제 자신의 프로젝트를 Angular로 만들 준비가 되셨군요! 즐거운 여정을 즐기시고 계속해서 배워 나가세요.\n\n이 게시물을 좋아하신다면 제 팔로우를 눌러주시거나 이야기에 박수를 보내주시거나 내가 준비 중인 다음 이야기를 구독해주시면 감사하겠습니다.","ogImage":{"url":"/assets/img/2024-06-20-HowtoCreateanAngularProjectfromScratch_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoCreateanAngularProjectfromScratch_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular afterRender, afterNextRender 새로운 phases API","description":"","date":"2024-06-20 00:28","slug":"2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI","content":"\n\n앵귤러는 컴포넌트 상호 작용을위한 강력한 라이프사이클 후크를 제공하지만 때로는 렌더링 후에 DOM과 직접 작업해야 하는 경우가 있습니다. 이때 afterRender 및 afterNextRender가 유용합니다.\n\n## 필요성 이해하기\n\nDOM 요소를 시각화하는 데 DOM을 사용하는 타사 차트 라이브러리를 통합하려고 상상해보십시오. 표준 라이프사이클 후크는 이러한 시나리오에 이상적이지 않을 수 있으며 라이브러리가 초기화되기 전에 DOM이 완전히 준비되어 있어야 할 수도 있습니다. 이러한 경우에 afterRender 및 afterNextRender가 해결책을 제공합니다.\n\n## 주요 차이점\n\n<div class=\"content-ad\"></div>\n\n두 후크가 후처리 작업을 다루지만 중요한 차이점이 있습니다:\n\n- afterRender: 각 렌더 사이클 다음에 실행되는 콜백을 등록할 수 있습니다.\n- afterNextRender: DOM이 로드될 때마다 한 번만 실행되는 콜백을 등록합니다.\n\n![이미지](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_0.png)\n\n# 적절한 후크 선택하기\n\n<div class=\"content-ad\"></div>\n\n- `afterNextRender`은 초기화 되어야 하는 타사 라이브러리를 설정하거나 엘리먼트 관찰자를 설정하는 것과 같은 일회성 DOM 조작에 사용합니다.\n- `afterRender`은 동적으로 콘텐츠에 기반하여 엘리먼트 크기를 동적으로 조정하는 것과 같이 빈번한 DOM 변경에 반응해야 할 때 사용합니다.\n\n기억해주세요: `afterRender`을 자주 사용하면 성능에 영향을 줄 수 있으므로 신중하게 사용해야 합니다. 그리고 이 두 가지는 모두 삽입 컨텍스트 내에서 사용되어야 합니다. 이 후크들은 SSR 또는 사전 렌더링에서 작동하지 않습니다.\n\n# 단계의 순서\n\n![Order of Phases](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_1.png)\n\n<div class=\"content-ad\"></div>\n\nAngular은 렌더링 중에 제어된 DOM 액세스를 위한 구분된 단계를 정의합니다:\n\n- EarlyRead: 후속 쓰기 작업 전에 DOM에서 데이터를 읽을 수 있습니다.\n- Write: DOM에 데이터를 쓰는 것을 허용합니다 (이 단계에서 읽기는 피하십시오).\n- MixedReadWrite: 읽기와 쓰기가 모두 가능하지만 성능 저하 가능성으로 신중하게 사용해야 합니다.\n- Read: DOM에서 데이터를 읽는 것을 허용합니다 (이 단계에서 쓰기는 피하십시오).\n\n# 콜백 실행 순서 ➡️\n\n동일한 단계 내에서 등록된 콜백은 등록된 순서대로 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n각 렌더 주기가 끝난 후에는 콜백이 실행됩니다. 그리고 다음과 같은 특정 단계 순서를 따릅니다:\n\n- earlyRead\n- write\n- mixedReadWrite\n- read\n\n# 초기화 과정 중 (angular.dev 기준)\n\n![Angular Initialization](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 이후의 업데이트 (angular.dev에서)\n\n![이미지](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_3.png)\n\n# 단계 간 매개변수 전달\n\n첫 번째 단계 콜백(earlyRead)은 매개변수를 전달받지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n각 후속 단계 콜백은 이전에 실행된 단계 콜백의 반환 값을 매개변수로 받습니다. 이를 통해 여러 단계에 걸쳐 작업을 조정할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_4.png)\n\n# 수익성 있는 예시\n\n다음은 이러한 후크를 사용하는 몇 가지 실용적인 사례들입니다:\n\n<div class=\"content-ad\"></div>\n\n- 써드파티 라이브러리 초기화: DOM이 준비되기 전에 Chart.js와 같은 라이브러리를 초기화하기 전에 afterNextRender를 사용해주세요.\n- 엘리먼트 감시 설정: afterNextRender를 활용하여 IntersectionObserver 또는 ResizeObserver를 설정하십시오. 이들 API는 엘리먼트가 DOM에 존재해야만 작동합니다.\n- 동적 콘텐츠 사이즈 조정: 동적으로 로드된 콘텐츠에 기반하여 엘리먼트 차원을 조정하기 위해 Read 단계와 함께 afterRender를 구현하십시오.\n- 임시 엘리먼트 분리: 렌더링 프로세스 중에 추가한 임시 엘리먼트를 제거하기 위해 afterNextRender를 사용하십시오(모달을 닫은 후 정리하는 등).\n\n# 중요 고려 사항 ⚠️\n\n- afterRender와 afterNextRender는 브라우저별 작업에 사용되며 서버 측 렌더링 중에는 작동하지 않습니다.\n- 가능한 경우 Angular의 내장 기능 인 ngAfterViewInit을 사용하여 컴포넌트 초기화 작업을 수행할 수 있습니다.\n- afterRender는 DOM을 읽는 것을 가능하게 하지만, 서버와 클라이언트 렌더링 간의 수분화 불일치로 인해 주의해야 합니다.\n- 이들은 주입 컨텍스트에서만 선언할 수 있습니다.\n\n이러한 개념을 이해함으로써 Angular 애플리케이션과 DOM 간에 원활한 상호 작용을 만들기 위해 afterRender 및 afterNextRender를 효과적으로 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 사용자 지정 Inject 함수\n\nOnInit 로그인을 사용자 정의 inject 함수로 캡슐화할 수 있습니다. 이 기능을 제공해준 Chau Tran에게 감사드립니다.\n\n<img src=\"/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_5.png\" />\n\n여기서 코드를 실험해볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nhttps://stackblitz.com/edit/stackblitz-starters-a39kev?file=package.json\n\n# 지금까지 읽어 주셔서 감사합니다 🙏\n\n피드백을 주시면 감사하겠습니다. 댓글이나 박수, 팔로우 부탁드려요. 👏\n\n좋았다면 꼭 여러분의 커뮤니티, 기술 동료 또는 원하는 누군가와 공유해주세요. 그리고 LinkedIn, YouTube 또는 Substack에서도 팔로우 부탁드립니다. 👋😁","ogImage":{"url":"/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_0.png"},"coverImage":"/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_0.png","tag":["Tech"],"readingTime":4},{"title":"TypeScript로 쉽게 시작하는 방법","description":"","date":"2024-06-20 00:27","slug":"2024-06-20-MakingItEasierToGetStartedWithTypeScript","content":"\n\n\n<img src=\"/assets/img/2024-06-20-MakingItEasierToGetStartedWithTypeScript_0.png\" />\n\n# 함수 정의\n\nTypeScript에서 함수를 정의하는 여러 가지 방법을 설명하기 위해 몇 가지 쉽게 이해할 수 있는 예제로 시작해봅시다.\n\n- 함수 선언 방법\n\n\n<div class=\"content-ad\"></div>\n\n2. 익명 함수 방법\n\n3. 매개변수를 전달하도록 방법을 정의하고, 매개변수와 메서드 이름의 유형을 선언합니다.\n\n4. 선언된 유형의 매개변수 및 메서드 이름으로 매개변수를 전달하는 익명 함수\n\n5. 반환 값을 갖지 않는 메서드.\n\n<div class=\"content-ad\"></div>\n\n6. TypeScript에서는 형식 매개변수와 실 매개변수가 동일해야 하며, 그렇지 않으면 옵션 매개변수를 구성하여 ? 기호를 추가해야 합니다.\n\n7. TypeScript에서 기본 매개변수 설정하기.\n\n8. TypeScript에서 ES6 나머지 매개변수 사용법.\n\n9. TypeScript에서 함수 오버로딩 사용하기. 함수 오버로딩이란 동일한 이름을 가진 두 개 이상의 함수가 있고 그 중 하나가 인수의 수나 유형에 따라 선택적으로 실행되어 결과가 다른 경우를 말합니다.\n\n<div class=\"content-ad\"></div>\n\nES5에서 동일한 이름의 함수가 있는 경우, 나중에 선언된 함수가 먼저 선언된 함수를 덮어쓸 것이며, TS에서는 다음과 같이 작성됩니다.\n\n위 방법의 변형은 다음과 같이 작성할 수도 있습니다.\n\n# 클래스와 상속\n\nTypeScript의 클래스와 상속 방법은 기본적으로 ES6와 동일하며 다음과 같이 작성됩니다.\n\n<div class=\"content-ad\"></div>\n\n- 정의 클래스\n\n2. 상속 클래스\n\n3. TypeScript에서 클래스의 수정자는 C++과 주로 다음과 같습니다.\n\n(1) public\n\n<div class=\"content-ad\"></div>\n\n클래스 내부에서, 서브클래스 내부에서, 그리고 클래스 외부에서 접근할 수 있습니다. 어떤 수정자도 추가되지 않으면 프로퍼티는 기본적으로 공개(public)입니다.\n\n(2) protected\n\n클래스 및 서브클래스 내부에서 접근할 수 있지만 클래스 외부에서는 접근할 수 없습니다.\n\n(3) private\n\n<div class=\"content-ad\"></div>\n\n클래스 내부에서 접근할 수 있지만 하위 클래스나 외부에서는 접근할 수 없습니다.\n\n이 시리즈의 기사들은 TypeScript를 간단한 예제와 함께 시작하는 데 도움을 줄 수 있도록 전념되어 있습니다. 제 기사에 관심이 있다면, Medium이나 Twitter에서 저를 팔로우할 수 있습니다.\n\n# Level Up Coding\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n<div class=\"content-ad\"></div>\n\n- 이야기에 👏 박수를 보내고 저자를 팔로우하세요 👉\n- Level Up Coding 출판물에서 더 많은 컨텐츠 확인하기 📰\n- 🔔 팔로우하기: 트위터 | 링크드인 | 뉴스레터\n\n🚀👉 Level Up 인재 컬렉티브에 참여하고 놀라운 채용 정보를 찾아보세요","ogImage":{"url":"/assets/img/2024-06-20-MakingItEasierToGetStartedWithTypeScript_0.png"},"coverImage":"/assets/img/2024-06-20-MakingItEasierToGetStartedWithTypeScript_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular 구독해야 할까요, 구독하지 말아야 할까요","description":"","date":"2024-06-20 00:24","slug":"2024-06-20-AngularToSubscribeorNotSubscribe","content":"\n\n\n![이미지](/assets/img/2024-06-20-AngularToSubscribeorNotSubscribe_0.png)\n\nAngular에서의 구독(Subscriptions). 이 주제는 프레임워크를 처음 탐색하는 동안 매우 까다로워질 수 있습니다. Angular는 여전히 가장 의견이 분분한 프레임워크 중 하나이지만 Observable 및 구독에 대한 다양한 방법이 있습니다.\n\n## subscribe()란 무엇인가요?\n\nAngular에서 subscribe() 메서드는 Observable을 구독하는 데 사용됩니다. Observable은 Angular의 핵심 개념이며 이벤트, HTTP 요청과 같은 비동기 작업을 처리하는 데 사용됩니다. 거의 모든 것을 Observable로 변환할 수 있습니다. Observable을 구독하면 Observable이 새 값을 방출하거나 오류가 발생할 때 알림을 받고 싶습니다.\n\n\n<div class=\"content-ad\"></div>\n\nsubscribe 함수는 세 가지 콜백을 제공합니다: next, error, 그리고 complete.\n\nnext 콜백은 Observable이 방출하는 값을 처리하는 데 사용됩니다. Observable이 새 값을 생성할 때마다 호출됩니다. Observable이 방출하는 데이터를 처리할 수 있습니다.\n\nerror 콜백은 Observable의 실행 중에 발생할 수 있는 오류를 처리하는 데 사용됩니다. Observable에서 오류가 발생하면 Observable은 완료된 것으로 간주되며 구독이 자동으로 해지됩니다.\n\nObservable이 완료되면 complete 콜백이 실행되고 자동으로 구독이 해지됩니다. 이는 구독이 종료되고 더 이상 값을 방출하지 않을 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시 1 (명령형 구독)\n\n매우 기본적인 예시를 시연해보겠습니다. 코드는 ngOnInit 훅(component 초기화)에서 bookService를 통해 백엔드 서버로 HTTP 호출을 트리거합니다. 컴포넌트는 라이프사이클 동안 단 한 번만 ngOnInit를 수행하므로bookService가 한 번만 호출된다는 것을 확신할 수 있습니다 (동일한 컴포넌트를 여러 번 사용하지 않는 한).\n\n이 경우 구독을 처리해야 할 필요가 있을까요? 아니요.\n\nHTTP 호출은 \"cold observables\"로 인식됩니다. Observable(HTTP 이벤트)는 새 값을 한 번만 방출하고 완료됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*sjTC0Kw8kLgzFwvnHelfmw.gif)\n\n우리의 이론은 콘솔 로그를 확인함으로써 확인되었습니다. next와 complete에 대한 subscribe() 콜백이 모두 실행되었고 Observable이 자동으로 구독 해제되었습니다.\n\n하지만 Observable이 새로운 값들을 발행하는 빈도에 대해 확실하지 않을 때는 어떻게 해야 할까요?\n\n# 구독 관리\n\n\n<div class=\"content-ad\"></div>\n\n\"핫 옵저버블\"은 차가운 옵저버블과는 반대되는 다른 유형의 옵저버블입니다. 이는 얼마나 자주 새 값이 방출될지 예측할 수 없는 이벤트에 사용됩니다. 예시로는 마우스 이벤트, 폼 값 변경, 심지어 로컬 스토리지 업데이트 등이 있습니다.\n\n이 범주 내에서 생성된 각 구독을 적절히 관리하는 것이 중요합니다. 효과적으로 구독 취소하는 여러 방법을 알아봅시다.\n\n이 데모에서, 우리는 구독에 적절히 관리하지 않았을 때 발생할 수 있는 잠재적인 문제점을 쉽게 알 수 있습니다.\n\n- '시작' 버튼을 누르면 handleKeyboardEvent() 함수가 트리거됩니다.\n- handleKeyboardEvent() 내에서 컴포넌트는 키보드 입력에 구독합니다.\n- 각 키 입력이 문자열 변수에 추가됩니다.\n- 구독 관리가 부적절하여 여러 구독이 생성됩니다.\n- 각 키 입력이 여러 번 옵저버블을 트리거하게 되어 여러 번 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*5B8aXGdi_KtczL2Bj7XYFA.gif)\n\n## 수동으로 구독 취소하기\n\n간단하지만 효과적인 방법은 모든 구독 객체에서 사용 가능한 unsubscribe() 함수를 활용하는 것입니다. 이 기술을 통해 접근 방식을 최적화해 봅시다.\n\n- 우리는 fromEvent에서 구독을 subscription이라는 변수에 저장했습니다.\n- '중지'를 클릭하면 기존 구독을 제거하고 새로운 구독을 생성하지 않습니다.\n- 시작/중지 버튼을 클릭하여 이전 데모에서 발생했던 여러 구독 문제를 다시 만들어 보았지만 성공하지 못했습니다.\n- 이제 애플리케이션이 의도한대로 작동합니다.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*HzcA5K_m8RveTyYgvKixZw.gif\" />\n\n여러 개의 구독을 할당할 때 주의하세요. 코드가 빨리 복잡해질 수 있습니다. (조금) 더 깔끔한 해결책은 구독을 효과적으로 관리하기 위해 Subscription 배열을 생성하는 것일 수 있습니다.\n\n```js\n// 다수의 구독 생성 예시\nsubscription1 = of(null).subscribe();\nsubscription2 = of(null).subscribe();\nsubscription3 = of(null).subscribe();\nsubscription4 = of(null).subscribe();\nsubscription5 = of(null).subscribe();\nsubscription6 = of(null).subscribe();\n\n// 대신 Subscription 배열 생성\nprivate subscriptions: Subscription[] = [];\nthis.subscriptions.push(\n  of(null).subscribe()\n);\n\n// 컴포넌트 소멸 시 모든 구독 해제\nngOnDestroy(): void {\n  this.subscriptions.forEach(subscription => subscription.unsubscribe());\n}\n```\n\n그래도 모든 것을 배열에 넣는 것은 조금 이상하게 느껴질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-AngularToSubscribeorNotSubscribe_1.png\" />\n\n보다 원활한 해결책을 상상해보세요: 수동으로 구독을 해지하는 대신 Angular가 자동으로 처리하는 것은 어떨까요?\n\n- 우리는 fromEvent에서 생성된 Observable을 변수 string$에 할당하고 있습니다.\n- 우리의 템플릿에서는 async 파이프를 사용하여 string$에 구독하고 렌더링합니다.\n- 시작을 false로 토글할 때, 우리의 Observable은 자동으로 구독 해지됩니다.\n- 우리의 Observable은 이전 값에 현재 눌린 키를 연결하는 데 scan 연산자를 활용합니다.\n- finalize 연산자는 Observable이 소멸될 때 콘솔에 확인 메시지를 로깅하여 Observable 구독을 보장합니다.\n\nAngular에서 Observable과 함께 async 파이프를 사용하는 것은 일반적으로 템플릿에서 비동기 데이터를 관리하는 데 가장 좋은 방법으로 여겨집니다. async 파이프는 Observable에 자동으로 구독하고 값을 가져와보여주면서 뷰를 업데이트합니다. 이렇게 함으로써 코드를 단순화하고 구성 요소가 소멸될 때 자동으로 구독을 해지하여 잠재적인 메모리 누수를 방지합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*56m_2d_sldWVyBmbl5T6ZA.gif)\n\n## RxJS take() 연산자 소개\n\n테이블에서 행 위로 마우스를 올렸을 때 추가 세부 정보를 로드하려는 시나리오에서 RxJS take() 연산자는 가치 있는 도구로 입증됩니다. 이 연산자를 사용하면 Observable에서 발행되는 값의 수를 제한할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*ezlcTQirocW_SCwwTTXj4w.gif)\n\n\n<div class=\"content-ad\"></div>\n\n수많은 구독이 생성되어 불필요한 HTTP 호출이 발생했습니다. 우리의 목표는 각 행의 세부 정보를 한 번만 호출한 후 구독을 해지하는 것이어야 합니다.\n\nRxJs의 take 연산자를 실제로 살펴보겠습니다.\n\n![RxJs take operator in action](https://miro.medium.com/v2/resize:fit:1400/1*vw1g8r3h31qfJWlbcIGoxA.gif)\n\n의도한 대로 문제가 해결되었습니다. 여기서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- `take(1)`을 추가하면 발행된 항목이 하나로 제한됩니다.\n- 테이블의 각 행에 구독합니다.\n- `hoverevent`에서 새로운 값이 발행됩니다.\n- 다음 콜백이 트리거됩니다.\n- 완료 콜백이 호출되어 Observable의 완료 및 자동 구독 해제가 이뤄집니다.\n- 이전에 호버된 행에서 추가 값이 발행되지 않습니다.\n\n우리는 결과를 저장하고 다시 호버할 때 즉시 사용할 수 있습니다. 새로운 HTTP 호출을 하지 않고 매우 빠르게 처리할 수 있습니다. 또는 RxJS `first()` 연산자를 선택할 수 있습니다.\n\n## RxJs `takeUntil()` 연산자\n\n구독을 관리하는 또 다른 널리 사용되는 접근 방법은 인기 있는 RxJS `takeUntil` 연산자입니다. 이 연산자는 Observable이 특정 조건이 충족될 때까지 새로운 값을 발행하도록 허용합니다. 충분한 이론, 이제 코드를 작성해 봅시다. 먼저 문제를 해결해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n자주 간과되는 문제: FormGroup의 valueChanges를 구독 해제하는 것을 잊는 것입니다. 이 시나리오에서는 간단한 양식을 만들었습니다. 이메일 양식 컨트롤의 값을 템플릿 문자열을 사용하여 동적으로 설정합니다. 이는 이름과 성의 소문자 버전을 점으로 구분하여 @gmail.com을 붙인 문자열을 결합합니다.\n\n- combineLatest는 이름과 성 양식 컨트롤에서 생성된 옵저버블에 의해 발생한 최신 값을 결합하는 데 사용됩니다. startWith(``)는 옵저버블이 빈 문자열의 초기 값을 발행하도록 보장합니다.\n- takeUntil(this.destroy$)는 destroy$ 옵저버블이 값을 발행할 때 구독이 자동으로 해제되도록 보장합니다. 이는 구성 요소 소멸 또는 정리 시 메모리 누수를 피하는 일반적인 패턴입니다.\n- finalize(() =&gt; console.log(`UNSUBSCRIBED`))는 구독이 해제될 때 콘솔에 `UNSUBSCRIBED`를 로그하는 부수 효과입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*kGUmkeauwpTqH25yITi7Sw.gif)\n\n## takeUntilDestroy (v16부터)\n\n<div class=\"content-ad\"></div>\n\nAngular v16부터는 새로운 takeUntilDestroy() 연산자를 활용할 수 있습니다. 이전 예제의 takeUntil(this.destroy$)와 동일한 작업을 수행하며, destroy$ subject를 만들지 않고 수동으로 호출할 필요가 없어집니다.\n\n코드를 리팩토링해봅시다.\n\n- takeUntil(this.destroy$)를 takeUntilDestroyed()로 대체했습니다.\n- destroy$ Subject와 ngOnDestroyhook를 모두 제거했습니다.\n\n결과를 확인해보겠습니다...\n\n<div class=\"content-ad\"></div>\n\n아래와 같은 결과를 얻지는 못했지만, 우리가 어떻게 개선할 수 있는지 살펴보겠습니다.\n\ndestroyRef를 주입하고 takeUntilDestroyed()에 매개변수로 전달한 후, 이제 작동합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n오늘은 여기까지입니다! 이 기사를 통해 다양한 Observable을 활용한 다양한 시나리오를 탐구했습니다. 이를 처리하는 다양한 접근 방식을 공유했습니다. 개발자들에게는 자신의 코딩 취향과 구체적인 코드베이스에 가장 적합한 방법을 찾는 것을 권장합니다. 여러분의 코드베이스가 최신 트렌드와 부합한다든지 그렇지 않다든지, 이 기사에서의 중요한 결론은 수동 구독 관리를 두려워할 필요가 없다는 것입니다. 핵심은 신중함을 유지하고 구독 취소를 처리할 때 적절히 주의를 기울이는 것입니다. 이러한 관행을 수용하면 장기적으로 더 견고하고 유지보수 가능한 코드베이스를 보장할 수 있습니다.\n\n# Stackademic\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 박수를 치고 작가를 팔로우해주세요! 👏\n- 저희를 팔로우해주세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼들을 방문해주세요: In Plain English | CoFeed | Venture","ogImage":{"url":"/assets/img/2024-06-20-AngularToSubscribeorNotSubscribe_0.png"},"coverImage":"/assets/img/2024-06-20-AngularToSubscribeorNotSubscribe_0.png","tag":["Tech"],"readingTime":7},{"title":"타입스크립트에서 any 타입 사용을 그만하세요","description":"","date":"2024-06-20 00:22","slug":"2024-06-20-StopUsinganyTypeinTypeScript","content":"\n\n## 더 나은 TS 타입과 인터페이스가 있습니다. TypeScript에서 \"any\" 타입을 사용하지 말아야 하는 이유\n\n![이미지](/assets/img/2024-06-20-StopUsinganyTypeinTypeScript_0.png)\n\nTypeScript는 웹 개발자들 사이에서 가장 많이 사용되는 프로그래밍 언어 중 하나입니다. 훌륭한 언어 기능을 갖추고 있어 확장 가능한 애플리케이션을 쉽게 설계할 수 있습니다. 그래서 개발자들은 프로젝트에 JavaScript 대신 TypeScript를 선택하는 경향이 있습니다.\n\n하지만 TypeScript를 사용할 때 지켜야 할 몇 가지 일반적인 실수가 있습니다. 예를 들어, any 타입을 과용하는 것은 우리가 종종하는 일반적인 실수입니다. 간단해 보이지만, any 타입을 과용하면 TypeScript의 기본 원칙을 완전히 어기게 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 이 기사에서는 어떤 종류의 남용 문제, 어떤 종류의 대안, 그리고 언제 어떤 종류를 사용해야 하는지, 그리고 사용해서는 안 되는지에 대해 논의할 것입니다.\n\n# TypeScript에서 any Type이란 무엇인가요?\n\nTypeScript에서 변수를 정의할 때 변수의 유형을 명시적으로 알려주어야 합니다. 예를 들어, 데이터 유형으로 문자열을 사용하면 TypeScript는 변수가 문자열 값만 가질 수 있다는 것을 이해합니다. 변수에 다른 유형의 값이 할당되려고 하면 TypeScript가 오류를 표시합니다.\n\n예를 들어, 아래 코드 조각은 'number' 유형이 'string' 유형에 할당할 수 없다는 오류를 표시할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nlet myVariable: string = '';\nmyVariable = 20;\n\n// error - Type 'number' is not assignable to type 'string'.(2322)\n```\n\n<img src=\"/assets/img/2024-06-20-StopUsinganyTypeinTypeScript_1.png\" />\n\n비슷하게, TypeScript에서 제공하는 또 다른 데이터 유형은 `any`입니다. 그러나 `any`는 나머지와 다르게 유니크합니다. `any`를 사용하면 해당 변수에 어떤 값이든 할당할 수 있다는 것을 TypeScript에 알려줍니다. 예를 들어, `any` 유형을 사용하여 변수를 정의하면 숫자, 문자열, 부울 또는 객체를 변수에 오류없이 할당할 수 있습니다.\n\n```js\nlet myVariable: any = '문자열 값';\nconsole.log('myVariable의 값: ' + myVariable);\n\nmyVariable = 20;\nconsole.log('myVariable의 값: ' + myVariable);\n\nmyVariable = false;\nconsole.log('myVariable의 값: ' + myVariable);\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-StopUsinganyTypeinTypeScript_2.png)\n\n어떤 사람들은 프로젝트에서 모든 변수를 정의하는 좋은 방법이라고 생각할 수 있습니다. 그러나 any 타입을 사용하는 것에는 상당한 단점이 있으며, TypeScript 프로젝트가 일반적인 JavaScript 프로젝트와 유사해질 수 있습니다. 그래서 TypeScript에서 변수를 정의할 때 any 타입을 사용하지 말아야 하는 이유에 대해 이야기해 봅시다.\n\n# 왜 any 타입을 사용해서는 안 되는가?\n\n타입 체킹은 TypeScript의 가장 중요한 기능 중 하나입니다. 데이터 할당과 타입 변환을 체크함으로써 응용 프로그램에서 예기치 않은 문제를 피하는 데 도움을 줍니다.\n\n\n<div class=\"content-ad\"></div>\n\n어떤 유형을 사용하면 변수에 특정 데이터 유형이 없게 되며, 동일한 변수에 여러 유형의 값을 할당할 수 있습니다. 또한, 어떤 유형으로 정의된 변수에 대한 유형 검사를 컴파일러가 수행하지 않습니다. 이로 인해 프로젝트는 일반 자바스크립트 프로젝트처럼 보일 수 있습니다.\n\n그렇다면 TypeScript가 그렇게 좋지 않다면, 왜 `any`라는 데이터 유형을 제공할까요? 어떤 유형이 생명 구원자가 될 수 있는 몇 가지 특정 시나리오가 있습니다. 개발자로서, 그러한 상황을 식별하고 `any` 유형을 적절하게 적용할 수 있어야 합니다.\n\n# 언제 `any` 유형을 사용해야 할까요?\n\n이미 언급했듯이, `any` 유형은 특정 이유로 도입되었습니다. `any` 유형을 반드시 사용해야 하는 가장 일반적이고 중요한 상황 중 일부는 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n## 1. 마이그레이션 시\n\n`any` 타입은 JavaScript 프로젝트를 TypeScript로 처음 마이그레이션할 때 유용한 옵션입니다. 예를 들어, AngularJS 프로젝트를 새로운 Angular 버전으로 마이그레이션할 때, 아직 마이그레이션되지 않은 변수들의 타입을 처리하기 위해 `any` 타입을 사용할 수 있습니다.\n\n## 2. 서드파티 라이브러리 작업 시\n\n가끔씩 `any` 타입을 사용하는 서드파티 라이브러리를 만날 수 있습니다. 이런 경우에는 해당 라이브러리와 작업하기 위해 프로젝트에서 `any` 타입을 사용해야 합니다. 하지만 가능한 빨리 올바른 타입으로 변환하도록 노력해주세요.\n\n<div class=\"content-ad\"></div>\n\n## 3. 타입 버그 처리하기\n\nTypeScript 타입 버그를 처리하는 것은 필요한 경우가될 수 있는 또 다른 상황입니다. 다른 해결책을 찾을 수 없는 경우에는 어떤 타입(type)을 사용하여 문제를 해결하고 나중에 적절한 타입으로 변환 할 수 있습니다.\n\n# 대안은 무엇인가요?\n\n앞서 설명했듯이, 어떤 타입(any type)의 주요 목적은 TypeScript를 사용할 때 개발자가 직면할 수있는 일부 특정 시나리오를 다루는 것입니다. 그러나 개발자들은 종종 특정 변수에 대해 특정 타입을 결정할 수 없는 상황에 직면 할 수 있습니다. 따라서, 어떤 타입을 사용하지 않고도 해당 경우에 사용할 수있는 대안적 접근 방식에 대해 논의해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## 1. Unknown 사용\n\n변수의 유형을 모르는 경우 unknown을 사용하는 것이 가장 좋습니다. any와 달리 unknown은 변수의 유형 안전성을 보장하면서 변수에 여러 유형을 할당할 수 있게 합니다.\n\n예를 들어, 아래와 같이 unknown 유형을 가진 변수를 정의하고 나중에 어떤 유형의 값이든 할당할 수 있습니다:\n\n```js\nlet myVariable: unknown = 'unknown type variable';\nconsole.log('Value of myVariable : ' + myVariable);\n\nmyVariable = 20;\nconsole.log('Value of myVariable : ' + myVariable);\n\nmyVariable = false;\nconsole.log('Value of myVariable : ' + myVariable);\n```\n\n<div class=\"content-ad\"></div>\n\n\n![StopUsinganyTypeinTypeScript_3](/assets/img/2024-06-20-StopUsinganyTypeinTypeScript_3.png)\n\n알 수 있듯이, unknown 타입 변수는 any 타입 변수와 동일하게 작동합니다. 그러나 두 변수를 다른 변수에 할당하려고 할 때 any와 unknown 사이에 차이가 있습니다. 변수가 any 타입이면 오류 없이 다른 변수에 할당할 수 있습니다. 그러나 올바른 타입을 가진 변수에 unknown 타입 변수를 할당하려고하면 오류가 발생합니다.\n\n```js\n// any type\nlet myVariable1: any = 'any 타입 변수';\nconsole.log('myVariable1의 값: ' + myVariable1);\n\nlet myVariable2: string =  myVariable1;\nconsole.log('myVariable2의 값: ' + myVariable2);\n```\n\n![StopUsinganyTypeinTypeScript_4](/assets/img/2024-06-20-StopUsinganyTypeinTypeScript_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 알 수 없는 타입\nlet myVariable1: unknown = '알 수 없는 타입 변수';\nconsole.log('myVariable1의 값 : ' + myVariable1);\n\nlet myVariable2: string = myVariable1;\nconsole.log('myVariable2의 값 : ' + myVariable2);\n```\n\n![2024-06-20-StopUsinganyTypeinTypeScript_5](/assets/img/2024-06-20-StopUsinganyTypeinTypeScript_5.png)\n\n## 2. 인터페이스 사용\n\n객체를 정의할 때도 추가 작업이 필요없기 때문에 개발자들이 어떤 타입을 사용하는 경우가 많습니다. 그러나 TypeScript에서 객체 타입을 다루는 가장 적합한 방법은 인터페이스를 사용하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, article이라는 객체를 정의해야 한다고 가정해보세요. 이 객체에는 title, writer, views 라는 두 개의 속성이 필요합니다. 만약 어떠한 형식이라도 사용한다면, 다음과 같이 객체를 쉽게 정의할 수 있습니다:\n\n```js\nconst article: any = {\n    title: 'TypeScript',\n    writer: 'Chameera',\n    views: 10000\n}\n```\n\n하지만, 이 방식은 타입 안전성이 보장되지 않습니다. 따라서, 먼저 객체를 정의하기 위해 인터페이스를 생성하고 그 인터페이스를 사용해야 합니다.\n\n```js\n// 인터페이스\ninterface Article {\n    title: string;\n    writer: string;\n    views: number;\n}\n\n// 객체\nconst article: Article = {\n    title: 'TypeScript',\n    writer: 'Chameera',\n    views: 10000\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그렇지 않으면 아래와 같이 객체를 정의하는 동시에 인터페이스를 생성할 수도 있습니다:\n\n```js\nconst article: {title: string; writer: string; views: number;\n} = {\n    title: 'TypeScript', writer: 'Chameera', views: 10000\n}\n```\n\n인터페이스와 유사하게 객체 유형을 생성하기 위해 타입 주석을 사용할 수도 있습니다:\n\n```js\ntype Article {\n    title: string;\n    writer: string;\n    views: number;\n}\n\nconst article: Article = {\n    title: 'TypeScript',\n    writer: 'Chameera',\n    views: 10000\n}\n```\n\n<div class=\"content-ad\"></div>\n\n알 수 없는 타입 및 인터페이스를 사용하는 것은 any 타입 대신 사용할 수 있는 최상의 대안입니다. 이 두 가지 방법은 타입 안전하며 TypeScript의 장점이 유지되도록 보장합니다.\n\n# 결론\n\nany는 TypeScript에서 사용할 수 있는 고유한 데이터 타입입니다. JavaScript에서 TypeScript로의 이주와 같은 특수한 시나리오를 처리하기 위해 도입되었습니다. 그러나 any 타입을 사용하기 전에는 항상 두 번 생각해야 합니다. 왜냐하면 any 타입은 변수 및 개체에 대한 타입 확인을 비활성화하기 때문입니다.\n\n본 문서는 any 타입을 사용해야 할 때와 그렇지 않을 때를 예제를 통해 설명하였습니다. 이를 통해 TypeScript 프로젝트를 더 나은 방향으로 이끌 수 있기를 바랍니다. 읽어 주셔서 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n# 레고처럼 재사용 가능한 구성 요소로 앱을 만들어보세요\n\n![이미지](/assets/img/2024-06-20-StopUsinganyTypeinTypeScript_6.png)\n\nBit의 오픈 소스 도구는 25만 명 이상의 개발자들이 구성 요소를 사용하여 앱을 만드는 데 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든지 재사용 가능한 구성 요소로 변환하고 여러 애플리케이션 간에 공유하세요. 협업과 빠른 개발이 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n➡️ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 쉽게하고 싶나요? 원하는 작업 흐름에 최적의 경험을 누릴 수 있습니다:\n\n## ➡️ 마이크로 프론트엔드\n\n## ➡️ 디자인 시스템\n\n<div class=\"content-ad\"></div>\n\n## → 코드 공유 및 재사용\n\n## → Monorepo\n\n# 자세히 알아보기","ogImage":{"url":"/assets/img/2024-06-20-StopUsinganyTypeinTypeScript_0.png"},"coverImage":"/assets/img/2024-06-20-StopUsinganyTypeinTypeScript_0.png","tag":["Tech"],"readingTime":7},{"title":"ApolloClient와 함께 Fragment Colocation","description":"","date":"2024-06-20 00:20","slug":"2024-06-20-FragmentColocationwithApolloClient","content":"\n\n\n<img src=\"/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png\" />\n\n# Fragment이란 무엇인가요?\n\nFragment Colocation에 대해 논의하기 전에, 먼저 Fragment가 무엇인지 간단히 설명하겠습니다.\n\nGraphQL에서 Fragment는 쿼리의 재사용 가능한 조각입니다. Fragment를 사용하면 코드 중복을 피하고 쿼리를 구성할 때 특히 여러 쿼리에서 같은 데이터 조각을 검색할 때 쿼리를 조직화할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nfragment UserDetails on User {\n  id\n  name\n  email\n}\n\nquery GetUser {\n  user(id: 1) {\n    ...UserDetails\n  }\n}\n\nquery GetAllUsers {\n  users {\n    ...UserDetails\n  }\n}\n```\n\n이 예제에서는 UserDetails라는 fragment가 정의되었고 GetUser 및 GetAllUsers 쿼리 내에서 재사용됩니다. 이렇게 하면 동일한 데이터 부분을 여러 번 작성할 필요가 없어집니다. (이 코드는 ChatGPT에 의해 생성됨.)\n\n# Fragment Colocation이란\n\n일본에서는 Fragment Colocation(apollo Client에서 fragment 일치)라고도 합니다.\n\n\n<div class=\"content-ad\"></div>\n\nFragment Colocation은 GraphQL fragments가 해당 컴포넌트와 함께 배치되는 디자인 접근 방식입니다. 이 방식은 어떤 컴포넌트가 어떤 데이터를 필요로 하는지 명확히 알려주어 데이터 의존성을 관리하기 쉽게 만들어줍니다.\n\n현대 프런트엔드 개발에서 데이터 가져오기와 표시는 밀접한 관련이 있습니다. 전통적인 방법은 종종 데이터 가져오기 로직을 여러 곳에 분산시켜 유지보수성과 재사용성이 감소하게 됩니다. Fragment Colocation은 이러한 문제를 중앙화하고 효율적으로 데이터 의존성을 조직화함으로써 해결합니다.\n\n# Shippio의 문제점 ⛴\n\nShippio에서는 Apollo Client를 GraphQL 클라이언트 라이브러리로 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 몇 가지 문제가 발생했습니다:\n\n- 자식 컴포넌트가 의존하지 않는 필드를 포함하여 불필요한 props가 전달됩니다.\n- 필요한 필드를 추가하려면 부모 컴포넌트의 쿼리 필드를 수정해야 했는데, 이는 상당한 영향을 미쳤습니다.\n- props를 통해 전달된 값이 서버에서 가져온 것인지 클라이언트에서 생성된 것인지 명확하지 않았습니다.\n- 위 문제를 해결하기 위해 여러 자식 컴포넌트에서 useQuery를 사용하여 필요한 값만 가져오도록 했지만, 이는 GraphQL 같지 않았고 요청 수가 증가했습니다.\n- 모든 쿼리를 단일 gql 디렉토리에 중앙 집중시키면 의존하는 컴포넌트를 식별하기 어려워졌습니다.\n\n## 코드 샘플 (실제 코드가 아닙니다)\n\n```js\n// 파일 트리\n\nsrc\n├── App.tsx\n├── components\n│   ├── ShipmentList.tsx\n│   ├── ShipmentListHeader.tsx (ShipmentList.tsx의 자식 컴포넌트)\n│   ├── ShipmentListItem.tsx (ShipmentList.tsx의 자식 컴포넌트)\n└── gql\n    ├── ShipmentListQuery.ts (쿼리)\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\n// gql 폴더의 ShipmentListQuery\n\nimport { graphql } from '@/__codegen__';\n\nexport const ShipmentListQuery = graphql(`\n  query ShipmentListQuery(\n    $shipmentId: ID\n    ...\n  ) {\n    shipmentSearch(\n      shipmentId: $shipmentId\n      ...\n    ) {\n      team {\n       name\n      }\n      milestones {\n        id\n        milestoneType\n        status\n        completionDoneAt\n      }\n    }\n  }\n`);\n\nexport type ShipmentListQueryItem = ArrayType<Query['shipmentSearch']>;\n```\n\n```javascript\n// ShipmentList.tsx (루트 컴포넌트)\n\nexport const ShipmentList = () => {\n  \n   const { data } = useQuery(ShipmentListQuery, \n    { variables: { ... } }\n  )\n  \n  return (\n   <Stack>\n     <ShipmentListHeader shipment={data.shipment} />\n     <ShipmentListItem shipment={data.shipment} />\n   </Stack>\n}\n```\n\n```javascript\n// ShipmentListItem.tsx (ShipmentList.tsx의 하위 컴포넌트)\n\ntype Props = {\n shipment: ShipmentListQueryItem;\n}\nexport const ShipmentListItems = ({ shipment }: Props) => { \n  return (\n   <Stack>\n     {shipment.milestones.map((milestone) => (\n       <Box key={milestone.id}>\n         <Text>{milestone.milestoneType}</Text>\n           <Text>{milestone.status}</Text>\n           <Text>{milestone.completionDoneAt}</Text>\n         </Box>\n     )}\n   </Stack\n}\n```\n\n```javascript\n// ShipmentListHeader.tsx (ShipmentList.tsx의 하위 컴포넌트)\n\ntype Props = {\n shipment: ShipmentListQueryItem;\n}\n\nexport const ShipmentListHeader = ({ shipment }: Props) => { \n  return (\n   <Stack>\n     <Text>{shipment.team.name}</Text>\n   </Stack>\n}\n```\n\n<div class=\"content-ad\"></div>\n\n처음에는 이 접근 방식이 좋아 보입니다. 하지만 컴포넌트가 더 복잡해지고 구조가 더 중첩되면 위에서 언급한 문제가 발생할 수 있습니다.\n\n## 이슈 예시\n\n- ShipmentListHeader에서 팀 ID를 표시하려면 부모인 ShipmentList 컴포넌트의 쿼리를 수정해야 합니다. (자식 컴포넌트의 변경 사항이 부모 컴포넌트에 영향을 미칩니다.)\n- 전체 data.shipment 객체를 전달하는 것은 의도하지 않은 처리로 이어질 수 있습니다.\n- ShipmentListItem은 마일스톤만 필요하지만 팀 정보도 받습니다.\n- ShipmentListHeader는 팀 정보만 필요하지만 마일스톤도 받습니다.\n\n# Apollo Client를 사용한 Fragment Colocation 연습\n\n<div class=\"content-ad\"></div>\n\n위의 코드를 Fragment Colocation을 활용하여 개선해 봅시다.\n\n이 글을 사용하기 위해 다음 패키지들이 필요합니다.\n\n```js\n@apollo/client\n@graphql-codegen/cli\n@graphql-codegen/client-preset\n```\n\ncodegen.ts 파일의 설정은 아래와 같습니다. preset을 client로 설정하여 client-preset의 대부분 기능을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n// codegen.ts\n\nimport { CodegenConfig } from '@graphql-codegen/cli'\n \nconst config: CodegenConfig = {\n  schema: '<schema 경로>',\n  documents: ['src/**/*.tsx'],\n  ignoreNoDocuments: true,\n  generates: {\n    './src/__codegen__/': {\n      preset: 'client'\n    }\n  }\n}\n \nexport default config\r\n```\n\n참고 링크: https://the-guild.dev/graphql/codegen/docs/guides/react-vue\n\n## Fragment Colocation을 사용한 코드 재작성\n\n```js\r\nimport { graphql } from '@/__codegen__';\n\nexport const ShipmentListQuery = graphql(`\n  query ShipmentListQuery(\n    $shipmentId: ID\n    ...\n  ) {\n    shipmentSearch(\n      shipmentId: $shipmentId\n      ...\n    ) {\n      ...ShipmentListHeaderFragment\n      ...ShipmentListItemFragment\n    }\n  }\n`);\n\nexport const ShipmentList = () => {\n  \n   const { data } = useQuery(ShipmentListQuery, \n    { variables: { ... } }\n  )\n  \n  return (\n   <Stack>\n     <ShipmentListHeader shipment={data.shipment} />\n     <ShipmentListItem shipment={data.shipment} />\n   </Stack>\n}\r\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { FragmentType, graphql, useFragment } from \"@/__codegen__/\"\n\nconst fragment = graphql(`\n  fragment ShipmentListItemFragment on Milestone {\n      milestones {\n        id\n        milestoneType\n        status\n        completionDoneAt\n      }\n  }\n`)\n\ntype Props = {\n shipmentListItems: FragmentType<typeof fragment>\n}\n\nexport const ShipmentListItems = ({ shipmentListItems }: Props) => { \n   const fragmentData = useFragment(fragment, shipmentListItems)\n   \n  return (\n   <Stack>\n     {fragmentData.map((milestone) => (\n       <Box key={milestone.id}>\n         <Text>{milestone.milestoneType}</Text>\n           <Text>{milestone.status}</Text>\n           <Text>{milestone.completionDoneAt}</Text>\n         </Box>\n     )}\n   </Stack>\n}\n```\n\n```js\nimport { FragmentType, graphql, useFragment } from \"@/__codegen__/\"\n\nconst fragment = graphql(`\n  fragment ShipmentListHeaderFragment on Shipment {\n      team {\n       name\n      }\n  }\n`)\n\ntype Props = {\n shipmentHeader: ShipmentListQueryItem;\n}\n\nexport const ShipmentListHeader = ({ shipmentHeader }: Props) => { \n   const fragmentData = useFragment(fragment, shipmentHeader)\n   \n  return (\n   <Stack>\n     <Text>{fragmentData.team.name}</Text>\n   </Stack>\n}\n```\n\n위 코드에서 다음과 같은 이점을 얻을 수 있습니다:\n\n- 명확한 데이터 종속성: 각 컴포넌트는 필요한 데이터를 명시적으로 정의하여 종속성이 명확해집니다. 자식 컴포넌트에서 GraphQL 서버에서 가져오는 값을 조사하는 것이 더 쉬워집니다.\n- 재사용성 향상: Fragment 사용은 코드 재사용을 촉진합니다. Fragment 유형도 생성되므로 타입 재사용이 가능합니다.\n- 유지보수성 향상: 쿼리에 대한 변경 사항이 지역화되어 유지보수가 쉬워집니다. 상위 컴포넌트의 쿼리를 수정할 필요가 없습니다.\n- 1 기능 컴포넌트에 1 루트 쿼리\n- 데이터 캡슐화: Fragment 마스킹을 사용하여 종속성이 없는 컴포넌트에서 의도하지 않은 필드 사용을 차단할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 보충: Fragment Masking\n\nFragment Masking을 사용하면 Fragment 데이터의 속성을 상위 수준 구성 요소에서 숨기고 데이터 가시성을 제어할 수 있습니다. 다시 말해, 캡슐화를 강제합니다.\n\n![이미지](/assets/img/2024-06-20-FragmentColocationwithApolloClient_1.png)\n\n참고: [https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen](https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nFragment Colocation은 React와 GraphQL을 사용하는 현대 프론트엔드 개발에서 매우 유용한 패턴입니다. 데이터 종속성을 명확히하고 재사용성과 유지보수성을 향상시킴으로써, 개발자는 더 효율적으로 고품질의 코드를 작성할 수 있습니다. 여러분의 프로젝트에서 이 접근 방식을 채택해보고 직접 이점을 경험해보는 것도 좋을 것입니다.\n\n- - - - -\n만약 이 글이 여러분의 흥미를 자극했고, 이 지식을 활용하고 싶다면, 우리가 채용 중이니 확인해보세요!\n\n아래 링크를 확인해보세요.\n▼ 직업 기회\n\n<div class=\"content-ad\"></div>\n\n**▼ 연락처**\nLinkedIn: [Shippio Inc.](https://www.linkedin.com/company/shippioinc/)\nShippio 인사팀 이메일 주소: shippiohr@shippio.io","ogImage":{"url":"/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png"},"coverImage":"/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png","tag":["Tech"],"readingTime":8},{"title":"앵귤러 최고의 권장사항","description":"","date":"2024-06-20 00:18","slug":"2024-06-20-AngularBestPractices","content":"\n\n![Angular Best Practices](/assets/img/2024-06-20-AngularBestPractices_0.png)\n\n안녕하세요, 개발자 여러분! Angular 개발에서 더 일관된 코딩 스타일을 찾고 계신가요? Angular 애플리케이션의 성능을 향상시키고 싶으신가요? 그렇다면 이 문서가 여러분을 위한 것입니다! 여기에서 Angular 개발자를 위한 스타일 가이드, 최고의 실천 방법 및 팁을 공유하겠습니다. 이를 통해 여러분의 Angular 프로젝트를 성능적이고 깔끔하게 유지할 수 있습니다.\n\n- 모듈화 아키텍처:\n확장성에 있어서 모듈화는 매우 중요합니다. 코드를 기능 모듈로 구성하고 각 모듈에 명확한 책임과 정의된 인터페이스를 부여하세요. 이는 코드 재사용, 관리 가능성 및 확장성을 촉진합니다.\n\n- 일관된 폴더 구조:\n표준화된 폴더 구조는 코드 조직화를 더 잘 할 수 있게 하며 팀원들 간의 원활한 협업을 촉진합니다. 파일을 논리적으로 분류하고 컴포넌트, 서비스, 모듈 및 기타 리소스에 특정 디렉토리를 할당함으로써, 개발자가 응용 프로그램의 아키텍처를 효율적으로 탐색할 수 있는 명확한 지도를 만듭니다. 이러한 조직화된 접근 방식은 관련 코드 세그먼트에 신속하게 액세스할 수 있게 하며 응용 프로그램 구조를 쉽게 이해할 수 있도록 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nsrc\n  |data-access\n    |auth\n       |facade\n          auth.facade.ts\n       |gateway\n          auth.gateway.ts\n  |feature\n     |auth\n        |login\n          login.component.ts\n          login.component.html\n          login.component.scss\n      auth.module.ts\n```\n\n3. 반응형 프로그래밍:\nRxJS 및 Angular Forms API와 같은 도구를 활용하여 데이터 및 이벤트 스트림을 효율적으로 처리하십시오. 이를 통해 코드의 간결성, 반응성 및 유지 관리성이 향상됩니다.\n\n```js\n// search.component.ts\nthis.search.valueChanges.pipe(\n debounceTime(300),\n distinctUntilChanged(),\n switchMap((query: string) => this.apiService.search(query))\n).subscribe((result: string[]) => {\n this.items = result;\n});\n```\n\n4. 지연 로딩:\n필요할 때에만 모듈을 지연로딩하여 성능을 향상시키십시오. 이는 초기 로드 시간을 줄이고 사용자 경험을 향상시킵니다.\n\n\n<div class=\"content-ad\"></div>\n\n```typescript\n// app-routing.module.ts\nconst routes: Routes = [\n { path: '', component: HomeComponent },\n { path: 'about', loadChildren: () => import('./about/about.module').then(m => m.AboutModule) }\n];\n```\n\n5. Ahead-of-Time Compilation (AOT):\n애헤드 오브 타임(AOT) 컴파일:\n빌드 프로세스 중에 AOT 컴파일을 활성화하여 애플리케이션 성능과 보안을 향상시킵니다.\n\n```bash\nng build --prod --aot\n```\n\n6. Change Detection Strategy OnPush:\n변경 감지 전략 OnPush:\n변경 감지는 Angular에서 근본적인 메커니즘으로, 애플리케이션 성능에 깊은 영향을 미칩니다. 이는 애플리케이션 데이터의 변화를 감지하고 이후에 뷰를 업데이트하는 것을 포함합니다. 기본적으로 Angular는 'Default' 변경 감지 전략을 사용하며, 이는 상당한 자원 소모를 요구할 수 있습니다. 그러나 'OnPush' 변경 감지 전략을 채택하여 성능을 최적화하는 것이 가능합니다. 'OnPush'를 사용하면 변경 사항이 컴포넌트의 입력 속성이 수정될 때나 이벤트가 트리거될 때에만 감지됩니다. 아래는 'OnPush' 전략의 구현을 보여줍니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-item',\n  template: `\n    <div>{ item.name }</div>\n    <div>{ item.price | currency }</div>\n    <button (click)=\"addToCart()\">Add to Cart</button>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ItemComponent {\n  @Input() item: Item;\n\n  constructor(private cartService: CartService) {}\n\n  addToCart() {\n    this.cartService.addItem(this.item);\n  }\n}\n```\n\n7. 반응형 폼:\nAngular 반응형 폼은 Angular 애플리케이션에서 동적이고 인터랙티브한 폼을 만들기 위한 견고한 매커니즘을 제공합니다. 템플릿 기반 폼과 달리 반응형 폼은 프로그래밍적으로 생성되어 폼 동작 및 유효성 검사에 대한 더 큰 유연성과 제어를 제공합니다. 반응형 폼을 사용하면 개발자들은 유지 보수성과 확장성을 보장하면서 쉽게 복잡한 폼을 생성할 수 있습니다.\n\n```js\n// contact.component.ts\nthis.contactForm = this.formBuilder.group({\n name: ['', Validators.required],\n email: ['', [Validators.required, Validators.email]],\n message: ['', Validators.required]\n});\n```\n\n8. 스마트 및 덤 컴포넌트:\n스마트 및 덤 컴포넌트 패턴을 채택하여 역할을 분리하세요. 스마트 컴포넌트는 애플리케이션 상태를 관리하고, 덤 컴포넌트는 표현에 집중합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// todo-list-container.component.ts\nexport class TodoListContainerComponent {\n todos$: Observable<Todo[]>;\n constructor(private todoService: TodoService) { … }\n}\n// todo-list.component.ts\nexport class TodoListComponent {\n @Input() todos: Todo[];\n}\n```\n\n9. Angular Material을 사용하여 UI 구성 요소:\nMaterial Design 가이드라인을 기반으로 사전 제작 및 사용자 정의 가능한 UI 구성 요소에 Angular Material을 사용하십시오. 이는 현대적이고 일관된 UI를 보장합니다.\n\n```js\nng add @angular/material\n```\n\n10. 단위 테스트 작성:\n컴포넌트, 서비스 및 응용 프로그램의 다른 부분에 대한 단위 테스트를 작성하여 코드 품질과 유지 관리를 보장하십시오.\n\n<div class=\"content-ad\"></div>\n\n```js\n// my.component.spec.ts\ndescribe('MyComponent', () => {\n  ...\n});\n```\n\n11. Angular CLI 사용법:\nAngular CLI를 활용하여 Angular 애플리케이션을 생성, 관리 및 빌드할 수 있습니다. 이를 통해 개발 작업을 간편화하고 최적의 관행을 준수할 수 있습니다.\n\n```js\nng generate component my-component\nng test\nng build\n```\n\n결론:\n이 11가지 모범 사례를 준수함으로써 확장 가능하고 유지보수가 용이하며 성능이 우수한 Angular 애플리케이션을 개발할 수 있습니다. 이러한 모범 사례에 더불어 Git과 같은 버전 관리 시스템을 사용해야 합니다. 계속해서 개발 관행을 검토하고 업데이트하여 발전하는 표준을 수용하고 애플리케이션 성능을 최적화해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n더 읽을 거리:\n\n피드백:\n만약 이 안내서가 도움이 되었다면, 공유해주시고 향후 개선을 위한 피드백을 제공해주십시오. 읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-AngularBestPractices_0.png"},"coverImage":"/assets/img/2024-06-20-AngularBestPractices_0.png","tag":["Tech"],"readingTime":5},{"title":"제스트 테스트 스위트가 왜 느릴까요","description":"","date":"2024-06-20 00:16","slug":"2024-06-20-WhyIsMyJestTestSuiteSoSlow","content":"\n\n우리 팀은 새 애플리케이션을 개발하고 있습니다. 현재 유닛 테스트 240개를 수행하는데 46초가 소요됩니다. 아직까지는 이 시간이 과도하지는 않지만 테스트의 개수에 비례해 증가하고 있습니다. 몇 달 뒤면 테스트 실행에 몇 분이 걸릴 것으로 예상됩니다.\n\n저희는 Jest가 빠른 성능으로 유명하다는 이유로 놀랐습니다. 그러나 Jest는 각 테스트가 40ms로 보고되었지만, 실제 각 테스트의 전체 실행 시간은 6초에 가깝다고 보고했습니다.\n\n우리의 레거시 응용 프로그램 중 하나에 대한 통합 테스트는 더 나쁘게 나타난다. 단일 테스트에 약 35초가 소요됩니다. 이 시간은 집중력을 잃기 시작하는 구간을 넘어서고, 테스트를 개발하는 데 집중하기 어렵습니다. 각 실제 테스트는 약 1초가 소요되는데, 추가 시간이 어디로 가는지 궁금합니다.\n\n<div class=\"content-ad\"></div>\n\n지난 몇 주 동안 우리의 테스트 스위트가 왜 느린지 알아내기 위해 꽤 많은 시간을 삽질했었습니다. 불행히도 많은 아이디어들이 있었지만 거의 영향을 미치지 못했습니다. 게다가 우리의 테스트가 얼마나 빨라야 하는지에 대한 공감대조차 없는 것 같았습니다.\n\n이 조사 결과로 단위 테스트의 소요 시간이 46초에서 13초로 줄었습니다. 통합 테스트도 유사한 개선을 보였는데, 그들의 시간은 35초에서 15초로 감소했습니다. 더욱 중요한 것은 저는 별도의 글에서 다루는 파이프라인의 개선을 보았습니다.\n\n본 글에서는 가장 큰 차이를 만들어낸 개선 사항들을 공유하고, Jest의 성능을 저해하는 가능성 있는 잘못된 구성 및 남용에 대해 살펴보고자 합니다.\n\n다음 예시는 간단해 보여서 빠르게 실행될 것 같지만, 우리의 테스트를 지연시키는 의외로 매우 흔한 구성이 숨어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n// TestComponent.tsx\nimport {Button} from \"@mui/material\";\n\nexport const TestComponent = () => {\n  return <Button>Hello World!</Button>;\n}\n\n// ComponentB.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport { TestComponent } from \"./TestComponent\";\n\ntest('TestComponent', () => {\n  render(<TestComponent />);\n  expect(screen.getByText(\"Hello World!\")).toBeInTheDocument();\n});\n```\n\n그리고 테스트를 실행하면 다음과 같은 결과가 나옵니다:\n\n```js\nPASS src/components/testComponent/TestComponent.test.tsx\n√ TestComponent - 1 (34 ms)\n테스트 스위트: 통과 1, 총 1\n테스트: 통과 1, 총 1\n시간: 3.497 s\n```\n\n성능을 향상시키기 전에 Jest가 시간을 어디에 쓰고 있는지 이해해야 합니다. 테스트를 실행하는 데 34ms가 소요되는 것은 합리적이지만, 나머지 3.463초가 어디로 가는지 명확하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\nJest가 하는 일을 이해하지 않으면 잘못된 것을 최적화하려는 데 시간을 낭비할 수 있습니다. 예를 들어, TypeScript 컴파일 시간을 개선하기 위해 ts-jest나 babel-jest를 빠른 컴파일러로 교체하는 것이 일반적인 제안입니다.\n\n그러나 Jest는 캐싱을 많이 활용하므로 첫 번째 실행 후에는 TypeScript 컴파일의 영향이 미미합니다.\n\n## 1. Jest 시작 시간\n\n테스트 실행을 시작할 때 Jest는 자체를 로드하고 테스트 환경(jest-environment-jsdom과 같은)을 로드해야 합니다. Jest는 파일 간 종속성 맵을 빌드하고 테스트 순서에 대한 일부 결정을 내리며 플러그인을 로드하고 추가 스레드를 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n이 모든 작업은 대략 1초 정도 소요되지만, Jest에 완전히 달려있고 우리 애플리케이션과 크게 독립적이기 때문에 우리가 할 수 있는 것은 별로 없습니다. 또한, 이 설정은 쓰레드 당 한 번 발생하기 때문에 테스트와 테스트 파일 수가 증가함에 따라 확장되지 않습니다.\n\nJest가 시작될 때 무슨 작업을 하는지 궁금한 사람을 위해 해당 주제에 대한 자세한 비디오가 있습니다.\n\n## 2. 캐시 채우기\n\n애플리케이션에서 테스트를 처음 실행할 때, Jest는 캐시된 데이터를 활용할 수 없기 때문에 처음 실행할 때는 조금 더 오랜 시간이 걸릴 수 있습니다. Jest는 처음 실행할 때 대부분 시간을 TypeScript를 변환하는 데 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n처음 실행 후 TypeScript 파일을 다시 변환해야 하는 파일이 소수 있을 수 있지만, 그 외에는 Jest는 주로 캐시된 값만 사용합니다. 캐시되지 않은 시나리오는 드물며 성능 최적화에 중요한 영향을 미치지 않습니다.\n\n## 3. 테스트 파일 로드하기\n\nJest가 테스트 파일을 실행하기 전에 테스트 파일과 setupTests.ts에서 참조하는 모든 종속 항목을 로드하거나 모의(mock)해야 합니다. 이 단계는 테스트 실행 시간에 상당한 부하를 추가할 수 있으며, 테스트 성능을 크게 향상시킬 수 있는 부분입니다.\n\n## 4. 실제 테스트 성능\n\n<div class=\"content-ad\"></div>\n\n테스트가 단 34밀리초만에 완료되었고, 여기서 더 최적화할 부분은 거의 없습니다.\n\n다행히도, 위 작업 각각에 테스트하는 데 Jest가 얼마나 시간을 소요하는지 추측할 필요가 없습니다. Chrome의 DevTools를 사용하여 테스트 실행을 프로파일링할 수 있으며, 각 실행이 무엇을 하는지 확인할 수 있습니다.\n\n먼저, 브라우저에서 chrome:inspect로 이동한 다음 \"Node를 위한 전용 DevTools 열기\"를 클릭하여 DevTools를 엽니다.\n\n그런 다음, 터미널에서 다음 명령을 실행하세요: node --inspect-brk ./node_modules/jest/bin/jest.js src/components/testComponent/TestComponent.test.tsx --runInBand. Chrome에서 DevTools의 기본 중단점에 도달하면, 프로파일링 탭으로 이동하고 녹화를 시작하세요. 테스트가 완료되면, 프로파일러를 중지하고 녹화를 보고 \"차트\" 보기를 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-20-WhyIsMyJestTestSuiteSoSlow_1](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_1.png)\n\n이 차트를 해석할 때 몇 가지 주의할 점이 있습니다:\n- 프로파일러의 존재로 인해 테스트의 성능이 약 30% 감소할 수 있습니다. 그러나 여전히 시간이 어디에 소비되는지를 비례적으로 잘 알 수 있습니다.\n- 의존성에 처음 접속하는 첫 번째 파일은 항상 가장 나쁜 성능을 보일 것입니다. 왜냐하면 Jest가 해당 의존성을 캐시하기 때문에 같은 스레드에서 같은 실행 동안 다른 테스트에 대해서도 사용합니다. (다른 실행 간에는 캐시되지 않음). 만약 TestComponent를 포함한 두 번째 테스트 파일을 포함한다면 해당 의존성을 로드하는 시간이 절반 정도 소요됩니다. 그러나 여전히 줄일 수 있는 시간이며, 물론 개발 중에 한 번에 하나의 파일만 실행하는 흔한 시나리오에서 첫 실행 성능이 매우 중요합니다.\n\n![2024-06-20-WhyIsMyJestTestSuiteSoSlow_2](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_2.png)\n\n<div class=\"content-ad\"></div>\n\n## Barrel 파일\n\n지금 검사 자가 연결되어 있기 때문에, 우리는 문제를 즉시 볼 수 있습니다 — 테스트 파일을 로드하는 대부분의 시간이 @mui/material 라이브러리를 로드하는 데 걸립니다. 우리가 필요로 하는 버튼 구성 요소만 로드하는 대신에 Jest는 전체 라이브러리를 처리하고 있습니다.\n\n![이미지](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_3.png)\n\n왜 이게 문제인지 이해하려면 Barrel 파일에 대해 좀 더 알아야 합니다. Barrel 파일은 여러 내보내기를 한 파일에 모아둔 접근 방식으로, 보통 index.ts라고 불립니다.\n\n<div class=\"content-ad\"></div>\n\n컴포넌트의 외부 인터페이스를 제어하고 모듈의 내부 구조와 구현에 대해 걱정할 필요 없도록 barrel 파일을 사용합니다. 대부분의 라이브러리는 일반적으로 내보내는 모든 것을 포함한 루트 디렉토리에 있는 barrel 파일을 가지고 있습니다.\n\n```js\n// @mui-material/index.ts\nexport * from './Accordion';\nexport * from './Alert';\nexport * from './AppBar';\n...\n```\n\n문제는 Jest가 우리가 가져오는 컴포넌트가 어디에 위치해 있는지 모르는 것입니다. barrel 파일은 그 사실을 의도적으로 숨겼습니다. 그래서 Jest가 barrel 파일에 도달하면 그 안에 참조된 모든 내보내기를 로드해야 합니다. 이 동작은 주로 @mui/material과 같은 대규모 라이브러리에 대해 신속하게 처리할 수 없습니다.\n\n우리는 단순히 하나의 버튼을 찾으려고 하는데 수백 개의 추가적인 파일을 로드하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n다행히도, Jest가 Button 컴포넌트를 정확히 어디에서 찾아야 하는지 알 수 있도록 임포트 구조를 업데이트하여이 문제를 쉽게 해결할 수 있습니다.\n\n```js\n// 이전\nimport { Button } from '@mui/material';\n// 이후\nimport Button from '@mui/material/Button';\n```\n\n![Jest 테스트 스위트가 왜 느린가요?](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_4.png)\n\neslint를 사용하여 미래에 더 이상 이러한 임포트가 추가되는 것을 막기 위해 구성 파일에 다음 규칙을 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nrules: {\n    \"no-restricted-imports\": [\n        \"error\",\n        {\n            \"name\": \"@mui/material\",\n            \"message\": \"대신 \\\"import foo from '@mui/material/foo'\\\"를 사용해주세요.\"\n        }\n    ]\n}\n```\n\n여기서는 주로 @mui/material을 타겟으로 잡았어요. 인기 있는 대형 라이브러리라서요. 그래도, 최적화되지 않은 방식으로 import하는 라이브러리가 많았어요.\n\n@mui/material-icons, lodash-es, 그리고 @mui-x-date-picker로부터 import를 수정해야 했고, 그 외에도 내부 라이브러리에서 import를 고쳐야 했어요. 이런 모든 import를 업데이트하는 데 걸리는 시간이 테스트 수행 시간의 약 50%를 절약할 수 있었어요.\n\n## setupTests.ts 확인하기\n\n\n<div class=\"content-ad\"></div>\n\njest.config.js 파일에서 setupFilesAfterEnv에 대해 설정된 파일로 가는 유혹이 있습니다. 이 파일은 모든 테스트 파일에 원하지 않는 일회성 및 특이 케이스가 모두 이어지는 경향이 있습니다.\n\n이 파일이 모든 테스트보다 한 번 실행된다는 오해에서 비롯된 것으로 의심됩니다. 그러나 Jest가 각 테스트 파일을 제대로 격리할 수 있도록 이 파일의 내용은 실제로 각 테스트 파일 앞에서 실행됩니다.\n\nsetupTests.ts 파일의 영향을 확인하면 이전 단계에서의 flame 차트를 볼 수 있습니다. setupTests.ts에서 비싼 동작을 발견할 수 있으며, 해당 동작은 관련 테스트 파일로 다시 이동할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 테스트 실행에서 타입 체크 제거하기\n\n만약 우리가 테스트용으로 TypeScript를 컴파일하는 데 ts-jest를 사용하고 있다면, 해당 도구의 기본 동작은 테스트 실행이 TypeScript 컴파일러의 타입 체크도 함께 실행하는 것입니다.\n\n이 동작은 TypeScript 컴파일러가 이미 빌드 과정 중에 그 역할을 수행하고 있기 때문에 중복됩니다. 이 추가적인 체크를 포함시키면 테스트 실행에 훨씬 더 많은 시간이 소요되는데, 특히 Jest가 별도로 TypeScript 컴파일러를 켜야 할 필요가 없는 경우입니다.\n\n이 동작을 비활성화하려면 jest.config.js 파일에서 다음 속성을 설정할 수 있습니다. isolatedModules 속성에 대한 자세한 설명은 ts-jest 문서에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule.exports = {\n    transform: {\n      \"^.+\\\\.(ts|tsx|js|jsx)$\": [\n          'ts-jest', {\n              tsconfig: 'tsconfig.json',\n              isolatedModules: false\n          },\n      ]\n    },\n};\n```\n\n`isolatedModules` 설정에 대한 제 경험은 다양했어요. 이 설정을 업데이트하면 일부 레거시 애플리케이션에서 성능이 두 배로 향상되었지만, 작은 create-react-app 애플리케이션에서는 차이가 없었어요. 다시 한 번, 플레임 차트를 통해 이 추가 작업이 어떤 영향을 미치는지 확인할 수 있어요.\n\n![WhyIsMyJestTestSuiteSoSlow_6](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_6.png)\n\n## misconfigurations을 점검하기\n\n\n<div class=\"content-ad\"></div>\n\n성능 향상은 코드베이스를 개선하는 것만으로 이루어질 필요가 없어요. 책임 일부는 개발자들이 도구를 어떻게 활용하느냐에 달려 있답니다. package.json의 스크립트는 타이핑을 절약하고 복잡성을 숨기며, 프로젝트의 모든 사람들에게 최상의 CLI 구성을 공유하는 데 도움이 될 수 있어요.\n\n하지만 이들에는 심각한 단점이 따라와요. 시간이 지남에 따라 팀원들이 공통 도구의 CLI를 어떻게 사용해야 하는지를 잊고 기존 스크립트가 이미 최적의 구성인 것으로 무조건 믿는 문제가 생길 수 있어요. 제가 참여한 대부분의 프로젝트에서 package.json의 스크립트에는 중요한 설정 오류가 몇 개 있었고, 많은 시간이 낭비되었어요.\n\n사람들은 지속적 통합 파이프라인을 위해 원래 의도된 스크립트를 로컬 개발 환경에 맞는 스크립트로 혼동하기도 해요. 스크립트가 새로운 기능이나 도구의 변경에 대해 업데이트되지 않았을 수도 있고, 아니면 항상 잘못되었을 수도 있어요.\n\nJest의 경우 로컬 환경에서 실행하는 테스트에 피해야 할 몇 가지 플래그가 있어요:\n\n<div class=\"content-ad\"></div>\n\n- --maxWorkers=2라는 옵션은 Jest가 두 개의 스레드에서만 실행되도록 제한합니다. CI 빌드 에이전트에서 유용하지만 개발용 강력한 머신에서는 Jest를 5개 이상 또는 6개 이상의 스레드로 실행할 수 있습니다.\n- --runInBand 옵션은 마찬가지로 Jest가 스레드를 전혀 사용하지 못하도록 합니다. Jest는 스레드가 필요없는 상황(예: 단일 테스트 파일 실행)을 스스로 인식할 수 있는 똑똑한 기능을 갖추고 있습니다.\n- --no-cache, --cache=false, --clearCache 옵션은 Jest가 실행 사이에 데이터를 캐싱하는 것을 방지합니다. Jest 문서에 따르면 캐시를 비활성화하면 Jest가 적어도 두 배 이상 느려질 수 있습니다.\n- --coverage 옵션은 대부분의 로컬 테스트 실행에서 코드 커버리지 보고서를 생성할 필요가 없습니다. 필요하지 않은 경우 이 단계를 건너뜁시켜 몇 초를 절약할 수 있습니다.\n\nJest에는 많은 설정이 있지만 대부분의 경우 기본 설정이 잘 작동할 것입니다. package.json 파일의 스크립트에 추가 플래그의 목적을 이해하는 것이 중요합니다.\n\n## 기본값은 watch 모드 사용\n\n로컬에서 애플리케이션을 실행할 때는 대부분 watch 모드를 사용하는 것으로 익숙하지만 테스트를 실행할 때는 그렇지 않을 수 있습니다. 빌드와 마찬가지로 테스트를 watch 모드에서 실행하면 다시 계산할 필요가 없는 많은 데이터를 우리의 도구에 저장할 수 있어 좋습니다.\n\n<div class=\"content-ad\"></div>\n\nJest의 대부분의 지연은 테스트 실행보다는 시작 시간에 있습니다. watch 모드를 사용하면 이를 건너뛸 수 있습니다.\n\n![2024-06-20-WhyIsMyJestTestSuiteSoSlow_7.png](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_7.png)\n\n저는 개발자들이 IDE의 인터페이스 때문에 watch 모드의 장점을 충분히 활용하지 못하는 경우가 많다고 생각합니다.\n\n테스트 파일을 작업할 때, 각 테스트 케이스 옆의 작은 녹색 \"테스트 실행\" 화살표를 클릭하여 테스트 실행을 시작하는 데 익숙합니다. 이들은 모든 테스트 실행하거나 일부 테스트를 실행하는 구문을 기억하려고 하는 것보다 편리하고 빠릅니다.\n\n<div class=\"content-ad\"></div>\n\n더 나아가서, 그들은 테스트 결과를 우리 IDE의 테스트 결과 패널 안에 표시해줍니다. 이는 콘솔에 덤핑된 로그보다 더 유용합니다.\n\n![이미지](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_8.png)\n\nWebStorm을 사용하면 \"테스트 실행\" 바로 가기에 사용되는 실행 구성을 업데이트할 수 있어, 이를 사용하여 워치 모드에서 테스트를 실행할 수 있습니다. Jest의 실행 템플릿도 업데이트하여 기본적으로 \"테스트 실행\" 바로 가기를 모두 워치 모드로 사용할 수 있습니다.\n\n## 우리는 모든 테스트를 실행할 필요가 없습니다\n\n<div class=\"content-ad\"></div>\n\n개발자들이 특정 테스트 파일에서 작업 중이 아닐 경우 대부분 모든 테스트를 실행하는 경향이 있다는 점을 알아챘어요. 이 행동은 보통 Jest가 변경된 파일을 기반으로 실행해야 할 테스트 하위 집합을 구별할 수 있기 때문에 중복될 수 있어요.\n\n테스트 스위트가 점점 커지면 전체 스위트를 실행하는 것은 시간이 낭비일 수 있어요. 하지만 이 기사의 조언이 정상적으로 통제를 도와줄 것을 희망합니다.\n\njest를 직접 호출하는 대신 jest --onlyChanged 또는 jest --changedSince을 사용하는 것이 좋아요. 100% 신뢰할 수 없지만, master 브랜치에 직접 커밋하지 않는 한 Jest가 테스트를 놓치는 예외적인 상황을 잡아내는 Continuous Integration 파이프라인이 있을 거에요.\n\n![이미지](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_9.png)\n\n<div class=\"content-ad\"></div>\n\n테스트 스위트는 거의 정적이지 않습니다; 애플리케이션과 함께 점점 커집니다. 느린 테스트 스위트는 더 느려질 것입니다. 다행히도, 소량의 작업으로 각 테스트의 소요 시간을 절반 이상 줄일 수 있습니다. 이 작업은 지금 시간을 절약할 뿐만 아니라 테스트 스위트의 소요 시간과 품질 전반의 궤적을 바꿉니다.\n\n# 레고처럼 재사용 가능한 구성 요소로 앱 빌드하기\n\n![이미지 설명](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_10.png)\n\nBit의 오픈 소스 도구는 25만 명 이상의 개발자들이 구성 요소로 앱을 빌드할 수 있도록 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n어떤 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 만들어 여러 응용 프로그램 간에 공유하세요. 협업이 더 쉬워지고 빠르게 구축할 수 있어요.\n\n→ 자세히 알아보기\n\n앱을 구성 요소로 분할하여 응용 프로그램 개발을 쉽게 만들고 원하는 워크플로에 대한 최상의 경험을 누리세요:\n\n## → 마이크로 프론트엔드\n\n<div class=\"content-ad\"></div>\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 리포\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_0.png"},"coverImage":"/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_0.png","tag":["Tech"],"readingTime":11},{"title":"주피터 랩 IDE 기본기 TypeScript와 Deno","description":"","date":"2024-06-20 00:13","slug":"2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno","content":"\n\n## TypeScript 개발자를 위한 단계별 가이드\n\n![Image](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_0.png)\n\n이 시리즈의 시작 부분에서는 최근 변경 사항을 요약하여 Typescript로 AI 앱을 쉽게 프로토타입 및 개발할 수 있는 내용을 소개했습니다.\n\n첫 번째 부분을 아직 읽지 않으셨나요? 이 프로젝트가 무엇인지 확인해보세요. 다가오는 몇 달, 아마도 몇 년 동안 새 AI 모델과 도구를 실험해가며 그 과정에서 배우는 모든 것을 여러분에게 보여줄 것입니다. 대중을 상대로 “공개로 빌드”하며 여정의 중요한 이정표를 여러분에게 보여줄 것입니다. 결과적으로 여러분은 이 지식을 실무에 적용할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n두 번째 글에서는 Jupyter Lab IDE를 설치하는 방법과 빠른 프로토타이핑 환경을 위한 모든 필수 도구를 설명했습니다:\n\n- Jupyter Lab 웹 기반 대화형 개발 환경\n- Jupyter 노트북에서 Typescript로 Jupyter 노트북을 생성할 수 있게 해주는 Deno Typescript/Javascript 커널\n- LLMs를 로컬에서 실행할 수 있는 Ollama\n- 언어 모델을 활용하여 애플리케이션을 개발하는 프레임워크인 Langchain\n\n두 번째 글의 단계를 따라오셨다면, 이제 Typescript 지원을 갖춘 작동 중인 Jupyter Lab 환경과 로컬 LLMs 실행을 위한 Ollama 설치가 완료되었습니다.\n\n이 글에서는 Jupyter Lab의 사용 방법을 설명하고, 기본적인 코딩 워크플로우를 소개하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n모든 예제가 포함된 샘플 노트북을 다운로드할 수 있어요.\n\n# 주피터 랩 기초\n\n주피터 랩은 주피터 노트북, 코드 및 데이터 작업을 위한 통합 개발 환경(IDE)입니다. 주피터 노트북에는 코드, 출력물, 시각화 및 설명 텍스트가 포함되어 있어요.\n\n주피터 랩의 사용자 인터페이스는 VSCode 또는 JetBrains IDE와 유사해요. \"파일 브라우저\"와 파일이 열린 주 작업 영역으로 구성되어 있어요:\n\n<div class=\"content-ad\"></div>\n\n\n![JupyterLab IDE Basics](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_1.png)\n\n“File browser”에서 원본 파일을 열고 편집할 수 있습니다. “File browser”의 루트 디렉터리는 Jupyter Lab을 시작한 디렉터리입니다.\n\n“File browser” 위에 있는 플러스 아이콘 버튼은 “Launcher”입니다. 새 노트북, 텍스트 파일, 터미널, 콘솔 및 기타 도구를 생성할 수 있는 바로 가기를 제공합니다:\n\n![Launcher](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n왼쪽 사이드바에는 다음과 같은 도구들이 있습니다:\n\n- 파일 브라우저: 파일을 탐색하고 관리합니다\n- 실행 중인 터미널 및 커널: 현재 실행 중인 터미널과 커널 목록\n- 확장 관리자: Jupyter Lab 기능을 향상시키는 확장 관리\n- 명령 팔레트: 명령에 빠르게 액세스하고 Ctrl+Shift+C로 열기\n\n\"명령 팔레트\"에서는 모든 Jupyter Lab 명령과 단축키를 볼 수 있습니다:\n\n![Command Palette](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_3.png)\n\n<div class=\"content-ad\"></div>\n\n# 주피터 랩에서의 코딩 워크플로우\n\n## 새 노트북 만들기\n\n왼쪽 사이드바에 있는 + 아이콘을 클릭하여 \"런처\"를 엽니다. \"Notebook\" 아래에서 TypeScript(또는 JavaScript)용 새 노트북을 만들기 위해 \"Deno\"를 선택합니다. Ctrl+S로 노트북을 저장합니다. \"파일 브라우저\"에서 파일을 우클릭하여 \"이름 바꾸기\"를 선택하여 파일 이름을 변경합니다(F2를 눌러도 됨).\n\n## 코드 작성 및 실행\n\n<div class=\"content-ad\"></div>\n\n새 노트북에서는 코드 셀 내에서 TypeScript 코드를 작성하고 실행할 수 있어요. 각 코드 셀을 사용하여 코드 스니펫을 입력하고 실행할 수 있어요. 예를 들어, 메시지를 표시하려면 다음과 같이 작성하세요:\n\n```js\nconsole.log('Hello Deno!')\n```\n\nShift+Enter를 눌러 코드를 실행하세요. 결과는 셀 아래에 바로 나타날 거예요:\n\n![이미지](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_4.png)\n\n<div class=\"content-ad\"></div>\n\n# 커널\n\n커널은 주피터 노트북에서 코드를 실행합니다. 각 노트북은 자체 커널을 가지며, 변수, 가져오기 및 셀 실행 사이의 다른 런타임 정보를 유지합니다.\n\n# 커널 재시작\n\n노트북의 커널 메모리는 이전 실행에서 온 변수들로 어지럴 수 있습니다. 커널을 다시 시작하면 이 메모리가 지워지며 깨끗한 상태를 제공합니다. 또한 업데이트된 모듈도 다시 불러옵니다.\n\n<div class=\"content-ad\"></div>\n\n\"Kernel\" 메뉴에서 커널을 재시작할 수 있어요.\n\n# 마크다운 셀\n\n마크다운 셀은 노트북에 텍스트와 문서를 추가하여 정보 전달을 도와줘요. 마크다운 셀을 추가하려면 툴바의 + 버튼을 클릭하여 새 셀을 삽입한 후, 드롭다운 메뉴를 사용하거나 Esc + M을 눌러 셀 유형을 \"Markdown\"으로 변경하세요. 제목과 형식화된 텍스트를 만들려면 다음과 같이 작성하세요:\n\n```js\n### 출력\n\nJavaScript의 표준 출력 함수인 `console.log`을 사용하여 출력 셀에 쓸 수 있어요.\n```\n\n<div class=\"content-ad\"></div>\n\n마크다운으로 표를 변환하려면, Shift+Enter를 누르세요.\n\n![image](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_5.png)\n\n# Deno에서 패키지 가져오기\n\nDeno에서는 패키지를 가져오는 데 URL 기반 구문을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { escape } from \"https://deno.land/std/html/mod.ts\";\n```\n\nDeno에는 https://deno.land/std에서 사용 가능한 표준 라이브러리가 있습니다. 위 줄은 std 라이브러리에서 escape() 함수를 가져옵니다. 버전을 지정하려면 다음을 사용하세요:\n\n```js\nimport { escape } from \"https://deno.land/std@0.224.0/html/mod.ts\";\n```\n\n또한 Deno에는 서드 파티 모듈을 위한 저장소가 https://deno.land/x에 있습니다. html() 함수를 가져오려면 다음을 사용하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { html } from \"https://deno.land/x/display/mod.ts\";\n```\n\nDeno는 npm 모듈을 npm: 접두사를 사용하여 가져올 수 있습니다. 예를 들어 zod를 가져오기 위해서는 다음과 같이 합니다:\n\n```js\nimport { z } from \"npm:zod\";\n```\n\n# 결과 셀에 입력하는 방법\n\n<div class=\"content-ad\"></div>\n\n다음은 코드 셀에서 출력할 수 있는 방법입니다:\n\n- console.* 함수 사용\n- html 함수 사용 (HTML 출력)\n- md 함수 사용 (Markdown 출력)\n\n예시:\n\n<img src=\"/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_6.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 환경 변수\n\nDeno 또는 Node에서는 설정을 위해 환경 변수를 사용합니다. 예를 들어, Langchain의 OpenAI 래퍼는 OPENAI_API_KEY에서 키를 가져옵니다. .env 파일에 설정하세요:\n\n```js\nOPENAI_API_KEY=[여기에 키를 입력하세요]\n```\n\n다음 명령으로 이 파일을 불러옵니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport \"https://deno.land/std@0.215.0/dotenv/load.ts\";\n```\n\n아래 코드를 사용하여 값을 표시해보세요:\n\n```js\nconsole.log(Deno.env.get(\"OPENAI_API_KEY\"));\n```\n\n# 로컬 파일 가져오기\n\n<div class=\"content-ad\"></div>\n\nDeno는 로컬 파일 임포트를 지원합니다. 외부 파일을 변경한 후에는 커널을 다시 시작하여 다시로드하세요:\n\n```js\nimport { f1 } from './1.ts';\n\nf1();\n```\n\nDeno는 JSON 파일을 불러오는 것도 지원합니다:\n\n```js\nimport jsonData from \"./data.json\" with { type: \"json\" };\nconsole.log(jsonData);\n```\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n이 작은 튜토리얼을 완료한 것을 축하드립니다! 우리는 주피터 랩의 기본을 다뤘으니, 앞으로는 AI 관련 주제에 중점을 둘 수 있을 것입니다. 다음 글에서는 \"텍스트 리뷰어 앱\" 프로토타입을 어떻게 만들었는지 설명할 것입니다. 흥미로운 내용이니까 구독 부탁드립니다!\n\n# 👨‍💻저자 소개\n\n내 이름은 Gergely Szerovay이며, 많은 해간 데이터 과학자이자 풀스택 개발자로 일해왔습니다. 최근에는 Angular 기반 프론트엔드 개발에 중점을 둔 프론트엔드 기술 리드로 일하고 있습니다. 제 역할의 일환으로 Angular와 프론트엔드 개발 환경이 어떻게 발전하고 있는지 꾸준히 주시하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n지난 몇 년 동안 Angular는 매우 빠르게 발전해 왔습니다. 특히 작년에는 생성 모델 AI의 등장과 함께 소프트웨어 개발 워크플로가 급속히 발전했습니다. AI 지원 소프트웨어 개발의 발전을 밀접히 따라가기 위해, 나는 공개적으로 AI 도구를 만들기로 결심했고 진행 상황은 AIBoosted.dev 에 게시할 것입니다. 구독하시려면 여기를 눌러주세요 🚀\n\nAngular에 대해 더 알고 AI, Typescript, React, 그리고 Angular로 AI 앱을 만드는 방법을 배우고 싶다면 Substack (Angular Addicts), Substack (AIBoosted.dev), Medium, Dev.to, X, 또는 LinkedIn에서 저를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_0.png"},"coverImage":"/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_0.png","tag":["Tech"],"readingTime":6}],"page":"51","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}