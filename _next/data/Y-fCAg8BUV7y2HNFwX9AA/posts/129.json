{"pageProps":{"posts":[{"title":"Axios를 활용하여 API 요청 최적화하기 Interceptors 및 고급 오류 처리","description":"","date":"2024-05-12 22:42","slug":"2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling","content":"\n\n\n![Alt text](/assets/img/2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling_0.png)\n\n프로젝트에서 API 통신의 참된 잠재력을 발휘해 보세요! 다재다능한 HTTP 클라이언트인 Axios를 살펴보고, 인터셉터와 견고한 에러 처리로 요청 관리를 어떻게 높일 수 있는지 알아보세요.\n\nAxios와 기본 Fetch API는 JavaScript에서 HTTP 요청을 하는 도구이지만, 주요 차이점이 있습니다. Axios가 인기 있는 이유와 Fetch API와의 차이점을 강조한 비교입니다:\n\n## 1. 사용 편의성 및 구문:\n\n\n\n— Axios: 깔끔한 구문과 일관된 API를 제공하여 간단하게 사용할 수 있습니다. 그리고 메서드들은 Promises를 반환하여 비동기 작업을 쉽게 연결하고 처리할 수 있습니다.\n— Fetch API: 강력하지만 더 많은 설명이 필요한 구문을 갖고 있으며, 다양한 HTTP 메서드나 헤더를 처리하기 위해서는 추가적인 보일러플레이트(boilerplate) 코드가 필요할 수 있습니다.\n\n## 2. JSON 데이터 다루기:\n\n— Axios: JSON 응답을 자동으로 구문 분석하여 JSON 데이터를 다루는 프로세스를 간단화합니다.\n— Fetch API: 응답에서 JSON 데이터를 추출하려면 수동으로 .json() 메서드를 호출해야 합니다.\n\n## 3. 인터셉터:\n\n\n\n- Axios: Interceptors를 사용하여 HTTP 요청이나 응답이 .then() 또는 .catch() 블록에 도달하기 전에 전역적으로 가로채고 수정하는 것을 가능하게 합니다.\n- Fetch API: 내장된 Interceptors가 없기 때문에 유사한 기능을 달성하려면 추가 코드 및 각 사용 지점에서 처리가 필요합니다.\n\n## 4. 오류 처리:\n\n- Axios: 견고한 오류 처리가 있으며 HTTP 오류 상태 (예: 404 또는 500)에 대해 자동으로 프라미스를 거부합니다.\n- Fetch API: 응답의 ok 속성을 수동으로 확인해야 하며 오류는 자동으로 throw되지 않습니다.\n\nAxios가 인기 있는 이유:\n- 편리성: Axios는 개발자 친화적 인터페이스를 제공하여 명확한 구문으로 작업하기 쉽게 만듭니다.\n- 기능이 풍부함: Interceptors, 자동 JSON 구문 분석 및 요청/응답 변환과 같은 내장 기능은 인기에 기여합니다.\n- 일관된 동작: Axios는 Fetch API에 존재하는 일부 불일치에 대응하여 서로 다른 브라우저에서 일관된 동작을 보장합니다.\n\n\n\n## Axios 시작하기\n\n## 1. Axios 설치하기:\n\n프로젝트에 Axios가 설치되어 있는지 확인하세요. npm 또는 yarn을 사용하여 설치할 수 있습니다:\n\n```js\nnpm install axios\n// 또는\nyarn add axios\n```\n\n\n\n## 2. Axios 인스턴스를 가져와서 만들기:\n\nAPI 요청을 만들 예정인 JavaScript 파일에서 Axios를 가져와주세요. 그리고 기본 URL, 헤더 등과 같은 기본 설정을 설정하기 위해 Axios 인스턴스를 만들어주세요. 이렇게 하면 다른 요청에서 동일한 설정을 재사용할 수 있어요:\n\n```js\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: 'https://api.example.com',\n  headers: {\n    'Content-Type': 'application/json',\n    // 다른 공통 헤더를 추가해주세요\n  },\n});\n```\n\n## 3. 요청과 응답 인터셉터 처리:\n\n\n\n```js\nAxios는 요청과 응답을 전역적으로 처리하기 위해 인터셉터를 사용할 수 있습니다. 이는 헤더 추가, 오류 처리 등과 같은 작업에 유용합니다.\n\n// 요청 인터셉터\napi.interceptors.request.use(\n  (config) => {\n    // 요청 구성을 여기서 수정하세요 (예: 권한 헤더 추가)\n    return config;\n  },\n  (error) => {\n    // 요청 오류 처리\n    return Promise.reject(error);\n  }\n);\n\n// 응답 인터셉터\napi.interceptors.response.use(\n  (response) => {\n    // 응답 데이터를 여기서 수정하세요\n    return response;\n  },\n  (error) => {\n    // 응답 오류 처리\n    return Promise.reject(error);\n  }\n);\n\n## 4. 비동기 요청에 대해 Async/Await 사용:\n\n클린하고 가독성이 좋은 비동기 코드를 위해 async/await 구문을 활용하세요:\n```\n\n\n\n```js\nasync function fetchData() {\n  try {\n    const response = await api.get('/endpoint');\n    // 응답 데이터 처리\n  } catch (error) {\n    // 에러 처리\n  }\n}\n```\n\n## 5. 동시 요청 최적화:\n\n여러 요청을 동시에 실행할 수 있는 경우 성능을 최적화하기 위해 Promise.all을 사용해보세요:\n\n```js\nasync function fetchMultipleData() {\n  try {\n    const [data1, data2] = await Promise.all([\n      api.get('/endpoint1'),\n      api.get('/endpoint2'),\n    ]);\n    // 데이터 처리\n  } catch (error) {\n    // 에러 처리\n  }\n}\n```\n\n\n\n## 6. 요청 취소:\n\nAxios는 요청 취소를 지원합니다. 이는 사용자가 요청이 완료되기 전에 페이지를 벗어날 때 불필요한 요청을 방지하는 데 유용할 수 있습니다:\n\n```js\nconst source = axios.CancelToken.source();\n\ntry {\n  const response = await api.get('/endpoint', {\n    cancelToken: source.token,\n  });\n  // 응답 처리\n} catch (error) {\n  if (axios.isCancel(error)) {\n    // 요청이 취소되었습니다\n  } else {\n    // 다른 오류 처리\n  }\n}\n\n// 요청 취소하기\nsource.cancel('사용자에 의해 요청이 취소됨');\n```\n\n## 성공 및 오류 토스트와 함께 완전한 소스 코드\n\n\n\n```js\nimport { toast } from 'react-hot-toast';\nimport Axios from 'axios';\n\nconst axios = Axios.create({\n  // 여러분의 API 기본 URL로 변경하세요\n  baseURL: 'https://fakerapi.it/api/v1',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\naxios.interceptors.response.use(\n  (response) => {\n    const data = response?.data;\n\n    console.log(data);\n\n    if (data?.message && typeof data?.message === 'string') {\n      toast.success(data.message);\n    } else if (data?.status && typeof data?.status === 'string') {\n      toast.success(data.status + ` - 상태 코드: ${data.code}`);\n    }\n\n    // 필요에 맞게 변경하세요\n    return data.data;\n  },\n  (error) => {\n    const data = error.response.data;\n\n    if (data?.message && typeof data?.message === 'string') {\n      toast.error(data.message);\n    } else if (data?.status && typeof data?.status === 'string') {\n      toast.error(data.status + ` - 상태 코드: ${data.code}`);\n    }\n\n    return Promise.reject(data);\n  }\n);\n\naxios.interceptors.request.use((config) => {\n  let token = 'your-bearer-token';\n\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  } else {\n    // 토큰이 없는 경우 처리\n    // 로그인 페이지로 리디렉션하거나 적절한 조치를 취할 수 있습니다\n  }\n\n  return config;\n});\n\nexport default axios;\n```\n\naxios 템플릿 코드를 문서에 추가했고, 아래 링크를 참조해주세요:\n\n[GitHub Gist](https://www.0cb.tech/jbbch)\n[실시간 코드 — StackBlitz](https://www.0cb.tech/fvopy)\n\n' embed https://stackblitz.com/edit/vitejs-vite-uqovqp?embed=1&file=src%2Flib%2Faxios.js '\n","ogImage":{"url":"/assets/img/2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling_0.png"},"coverImage":"/assets/img/2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling_0.png","tag":["Tech"],"readingTime":5},{"title":"env 변수 undefined","description":"","date":"2024-05-12 22:41","slug":"2024-05-12-envvariablesundefined","content":"\n\n애플리케이션을 구축할 때 VITE, REACT 또는 NEXT를 기반으로 하는 상황에 갇혀 과연 환경 변수를 어떻게 설정해야 할지 모를 때가 있나요?\n\n저 또한 예전에 여러분과 같은 상황에 처해 있었고, 고민 끝에 제 문제에 맞는 해결책을 찾기 위해 인터넷을 뒤적였어요.\n\n우리가 설치한 패키지/모듈의 공식 문서에 기재된 케이스와 맞지 않는 기능이 있는 프로젝트를 갖고 있는 경우가 많습니다. 따라서 이 게시물은 환경 변수와 여러분의 “상황\"에서 이를 작동시키는 방법에 대한 내용입니다.\n\n환경 변수란 정확히 무엇인가요?\n\n\n\n환경 변수는 단순히 프로젝트의 파일 시스템 전역에서 사용하려는 변수들입니다. 하지만 이를 인터넷에서 다른 사람들에게 공개하거나 보여주고 싶지는 않아요. 기본적으로 \"SECRET_KEY\"나 \"PUBLISHABLE_KEY\"와 같은 민감한 변수나 키들입니다. 이러한 종류의 키/변수는 .env라는 파일 안에 작성됩니다.\n\n이 .env 파일을 어떻게 만들까요?\n\n먼저 프로젝트 폴더에서 package.json 파일의 계층을 찾으세요. 그 후, 새 파일을 만들기 위해 마우스 오른쪽 버튼을 클릭하고 파일 이름을 \"env\"로 작성하세요. 정확하게 이렇게 작성해 주셔야 하며, 이렇게 하시면 환경 변수 파일이 생성됩니다.\n\n![이미지](/assets/img/2024-05-12-envvariablesundefined_0.png)\n\n\n\n.env 파일에 환경 변수를 어떻게 작성하나요?\n\n- Vite 애플리케이션(프론트엔드)에 환경 변수를 사용하려면 패키지(dotenv)를 설치할 필요가 없습니다. .env 파일을 생성하기만 하면 됩니다.\n\n```js\nVITE_YOUR_VARIABLE_NAME=SOMETHING\n```\n\n2. 마찬가지로 React 애플리케이션(프론트엔드)에 환경 변수를 사용하려면 패키지(dotenv)를 설치할 필요가 없습니다. .env 파일을 생성하기만 하면 됩니다.\n\n\n\n3. REACT 앱에서 변수를 선언하는 구문은 다음과 같습니다. 변수 이름은 'REACT_APP_' 프리픽스가 있어야 합니다. 그렇지 않으면 변수가 제대로 작동하지 않습니다.\n\n```js\nREACT_APP_YOUR_VARIABLE_NAME=SOMETHING\n```\n\n4. NEXT 앱에서 환경 변수를 선언할 때 변수는 아래와 같이 보여야 합니다. \"NEXT_PUBLIC_\" 프리픽스가 있어야만 제대로 작동합니다.\n\n```js\nNEXT_PUBLIC_YOUR_VARIABLE_NAME=SOMETHIN\n```\n\n\n\n<img src=\"/assets/img/2024-05-12-envvariablesundefined_1.png\" />\n\n5. 백엔드(server) 폴더에서 환경 변수를 선언하는 경우, dotenv이라는 패키지가 필요합니다.\n\n설치\n\nyarn과 npm은 우리가 인터넷에서 패키지를 다운로드하여 프로젝트에서 사용하고 멋진 것을 만들 수 있도록 도와주는 패키지 관리자입니다.\n\n\n\n```js\nnpm i dotenv\n```\n\n또는\n\n```js\nyarn add dotenv\n```\n\n5. 이제 서버 측 폴더의 index.js(루트 파일/진입점)에서 방금 설치한 이 패키지를 구성해야 합니다.\n\n\n\n```js\nconst dotenv = require(\"dotenv\")\ndotenv.config()\n```\n\n![2024-05-12-envvariablesundefined_2.png](/assets/img/2024-05-12-envvariablesundefined_2.png)\n\n다음에는 .env 파일을 만드는 방법에 언급된 것과 똑같은 절차를 수행합니다. 그러나 백엔드에서는 환경 변수의 이름을 원하는 대로 지정할 수 있습니다.\n\n```js\nMONGO_URL=SDAHKAFHKLJAHFLA\nJWT_KEY=FHALKHFLAHF\n```\n\n\n\n그 변수를 컴포넌트 파일에서 어떻게 접근할 수 있는지 알고 계신가요?\n\n프런트엔드\n\n- Vite 앱의 경우\n\n```js\nconst VARIABLE_NAME = import.meta.env.VITE_YOUR_KEY_VARIABLE_NAME\n```\n\n\n\n- React 앱용\n\n```js\nconst VARIABLE_NAME = process.env.REACT_APP_YOUR_KEY_VARIABLE_NAME\n```\n\n- Next 앱용\n\n```js\nconst VARIABLE_NAME = process.env.NEXT_PUBLIC_YOUR_VARIABLE_NAME\n```\n\n\n\n백엔드\n\n- 원하는 변수에 액세스하려면 process.env.VARIABLE_NAME을 사용해야 합니다.\n\n```js\nconst VARIABLE_NAME = process.env.YOUR_VARIABLE_NAME\n```\n\n최종 참고 사항:\n\n\n\n- VARIABLE_NAME을 대문자로 작성하는 것이 좋지만 casing은 당신에게 달려 있어요.\n- 환경 변수를 선언할 때 공백, 쉼표 또는 세미콜론을 사용하지 마세요.\n\n이제 프런트엔드와 백엔드를 위한 환경 변수 설정의 기술을 습득했어요. 어려움이 있으면 언제든 저에게 GitHub 또는 프로필 내 링크를 통해 연락해 주세요.\n\n마지막으로, 표준 최고의 실천 방법을 준수하면 개발 능력이 향상되고 다른 사람에게 전문성을 나타낼 수 있어요. 이 \"case\"에서는 대문자 또는 소문자 변수 이름 사용을 피하세요.","ogImage":{"url":"/assets/img/2024-05-12-envvariablesundefined_0.png"},"coverImage":"/assets/img/2024-05-12-envvariablesundefined_0.png","tag":["Tech"],"readingTime":3},{"title":"프론트엔드에서의 JWT 인증 웹 애플리케이션 보안 강화하기","description":"","date":"2024-05-12 22:40","slug":"2024-05-12-JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications","content":"\n\n이 블로그에서는 JWT 토큰을 사용하여 프론트 엔드에서 사용자를 인증하고 웹 애플리케이션/웹 사이트에 대한 무단 액세스를 방지하는 방법에 대해 배워보겠습니다.\n\n![JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications_0.png](/assets/img/2024-05-12-JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications_0.png)\n\n이전 블로그에서 API 서버를 만들어서 로그인 엔드포인트를 제공했습니다. 사용자가 로그인하면 로그인한 사용자의 데이터와 액세스 토큰 및 리프레시 토큰을 얻을 수 있습니다. 이를 사용하여 프론트 엔드에서 서버에 자격 증명을 인증할 수 있습니다. 이 블로그에서는 프론트 엔드로 React JS를 사용할 것입니다.\n\n간단히 복습해보죠.\n\n\n\nJWT는 JSON 웹 토큰의 약자입니다. 이는 JSON 객체로 정보를 안전하게 전송하는 데 사용되는 공개 표준 (RFC 7519)입니다. JWT는 웹 애플리케이션과 API에서 인증 및 권한 부여에 일반적으로 사용됩니다.\n\n이 정보는 디지털으로 서명되어 신뢰할 수 있습니다. JWT는 HMAC 알고리즘을 사용하여 비밀을 이용하거나 RSA 또는 ECDSA를 사용한 공개/비공개 키 쌍을 사용하여 서명할 수 있습니다.\n\nJWT는 세 가지 부분으로 구성됩니다: 헤더, 페이로드 및 서명.\n\n- 헤더 — 헤더는 두 부분으로 구성됩니다: 토큰을 서명하는 알고리즘 (예: HMAC SHA256 또는 RSA) 및 이 경우 JWT인 토큰 유형이 포함됩니다.\n- 페이로드 — 페이로드는 클레임을 포함합니다. 클레임은 사용자 ID 또는 사용자 이름과 같이 엔티티 특정 정보를 전달할 수 있습니다.\n- 서명 — 서명은 인코딩된 헤더, 인코딩된 페이로드 및 서버만 알 수 있는 비밀 키를 결합하여 형성됩니다. 이는 토큰의 무결성을 확인하고 변조되지 않았음을 보장하기 위해 사용됩니다.\n\n\n\nJWT는 어떻게 동작합니까?\n\nJWT 토큰을 사용할 때 일반적으로 사용되는 흐름은 다음과 같습니다 —\n\n- 사용자 인증 — 먼저 사용자는 자격 증명을 전달하여 서버에 인증합니다.\n- 토큰 생성 — 사용자가 인증되면 사용자 세부 정보를 페이로드로 포함하는 토큰이 생성되며, 이는 프론트 엔드 및 백엔드에서 검증을 수행하는 데 필요합니다.\n- 토큰 저장 — 서버가 로그인 요청에 대한 응답으로 프론트 엔드에 토큰을 전송하고, 프론트 엔드는 이를 로컬 저장소나 세션에 저장합니다.\n- 요청 생성 — 클라이언트가 백엔드 서버에 요청을 보낼 때 헤더에 JWT 액세스 토큰을 전달하여 서버에 대한 신원을 인증합니다. 이것이 JWT의 주요 목적입니다.\n- 토큰 확인 — 서버는 요청 헤더, 즉 JWT 액세스 토큰을 확인하고 토큰이 유효하면 요청된 리소스에 대한 액세스를 제공하고, 토큰이 유효하지 않으면 401 상태 코드를 반환하여 사용자를 비인증 상태로 만듭니다.\n\nJWT 만료란 무엇을 의미합니까?\n\n\n\n보안을 강화하기 위해 JWT에는 만료 시간을 정의할 수 있는 추가 기능이 있습니다. 특정 기간이 지나면 액세스 토큰이 더 이상 유효하지 않게 됩니다. 만료된 JWT 액세스 토큰을 사용할 수 없습니다. 서버에 액세스하려면 새로운 토큰을 생성해야 합니다.\n\n이를 위해 클라이언트용 새로운 액세스 토큰을 가져오는 작업을 수행하는 리프레시 액세스 토큰을 사용합니다.\n\n우리는 프런트 엔드에서 JWT를 사용하는 방법을 볼 수 있는 로그인 폼을 만들 것입니다. 그래서 먼저 리액트 앱을 생성해보겠습니다. 리액트 앱을 만들기 위해 Vite를 사용하겠습니다.\n\n```js\nnpm create vite@latest\n```\n\n\n\n그럼 프로젝트 이름을 지정하고 React 및 간단한 JavaScript을 선택하도록 요청합니다. 이렇게 하면 앱이 포함된 폴더가 생성됩니다. 그런 다음 필요한 모든 패키지를 설치해야 합니다.\n\n```js\ncd project_name\nnpm i   \n```\n\nReact 앱을 만든 후에는 로그인을 위한 폼을 만들겠습니다. 이를 통해 사용자가 서버에 액세스할 수 있습니다. 사용자가 사용자 이름과 암호를 사용해 로그인하면 백엔드는 액세스 토큰과 리프레시 토큰과 함께 액세스를 부여할 것입니다.\n\n그러므로 먼저 로그인 폼을 만들어 봅시다.\n\n\n\nApp.js\n\n```js\nimport axios from \"axios\";\nfunction App() {\n  const [user, setUser] = useState(null);\n  const [username, setUsername] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const response = await axios.post(\"/api/login\", { username, password });\n      setUser(response.data);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  return (\n    <div className=\"container\">\n      {user ? (\n        <div className=\"login\">\n          <form onSubmit={handleSubmit}>\n            <span className=\"formTitle\">Lama Login</span>\n            <input\n              type=\"text\"\n              placeholder=\"username\"\n              onChange={(e) => setUsername(e.target.value)}\n            />\n            <input\n              type=\"password\"\n              placeholder=\"password\"\n              onChange={(e) => setPassword(e.target.value)}\n            />\n            <button type=\"submit\" className=\"submitButton\">\n              Login\n            </button>\n          </form>\n        </div>\n      ) : (\n        <span>User has been loggedIn </span>\n      )}\n    </div>\n  );\n}\n```\n\nApp.css\n\n```css\n.container {\n  font-family: \"Quicksand\", sans-serif;\n}\n\n.login {\n  width: 200px;\n  height: 200px;\n  padding: 20px;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  margin: auto;\n  border: 1px solid lightgray;\n  border-radius: 10px;\n}\n\n.formTitle {\n  color: teal;\n  font-weight: bold;\n}\n\n.submitButton {\n  width: 100px;\n  padding: 10px;\n  border: none;\n  border-radius: 10px;\n  background-color: teal;\n  color: white;\n  cursor: pointer;\n}\n```\n\n\n\n지금은 App() 함수의 반환부에 로그인 후 기능을 작성하는 코드를 작성할 것입니다. 특권을 가진 사용자는 삭제 작업을 수행할 수 있습니다. 기능을 추가한 후 App.js 파일은 다음과 같이 보일 것입니다.\n\n```js\nfunction App() {\n  const [user, setUser] = useState(null);\n  const [username, setUsername] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const res = await axios.post(\"/login\", { username, password });\n      setUser(res.data);\n    } catch (err) {\n      console.log(err);\n    }\n  };\n\n  const handleDelete = async (id) => {\n    setSuccess(false);\n    setError(false);\n    try {\n      await axios.delete(\"/users/\" + id, {\n        headers: { authorization: \"Bearer \" + user.accessToken },\n      });\n      setSuccess(true);\n    } catch (err) {\n      setError(true);\n    }\n  };\n\n  return (\n    <div className=\"container\">\n      {user ? (\n        <div className=\"home\">\n          <span>\n            {user.isAdmin ? \"어드민\" : \"사용자\"} 대시보드에 오신 것을 환영합니다, <b>{user.username}</b>님.\n          </span>\n          <span>사용자 삭제:</span>\n          <button className=\"deleteButton\" onClick={() => handleDelete(1)}>\n            John 삭제\n          </button>\n          <button className=\"deleteButton\" onClick={() => handleDelete(2)}>\n            Jane 삭제\n          </button>\n          {error && (\n            <span className=\"error\">\n              이 사용자를 삭제할 수 없습니다!\n            </span>\n          )}\n          {success && (\n            <span className=\"success\">\n              사용자가 성공적으로 삭제되었습니다...\n            </span>\n          )}\n        </div>\n      ) : (\n        <div className=\"login\">\n          <form onSubmit={handleSubmit}>\n            <span className=\"formTitle\">Lama 로그인</span>\n            <input\n              type=\"text\"\n              placeholder=\"사용자명\"\n              onChange={(e) => setUsername(e.target.value)}\n            />\n            <input\n              type=\"password\"\n              placeholder=\"비밀번호\"\n              onChange={(e) => setPassword(e.target.value)}\n            />\n            <button type=\"submit\" className=\"submitButton\">\n              로그인\n            </button>\n          </form>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n로그인 양식을 사용하여 로그인하면 사용자 데이터와 액세스 토큰 및 리프레시 토큰을 받게 됩니다. 서버로 삭제 요청을 수행할 때 액세스 토큰을 전달합니다. 그러나 액세스 토큰이 만료될 수 있으므로 서버에 전달하기 전에 액세스 토큰을 확인하고 만료되었을 경우 리프레시 토큰을 사용하여 새 액세스 토큰을 얻어야 합니다.\n\n```js\nconst axiosJWT = axios.create()\n\naxiosJWT.interceptors.request.use(\n  async (config) => {\n    let currentDate = new Date();\n    const decodedToken = jwt_decode(user.accessToken);\n    if (decodedToken.exp * 1000 < currentDate.getTime()) {\n      const data = await refreshToken();\n      config.headers[\"authorization\"] = \"Bearer \" + data.accessToken;\n    }\n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\nconst handleDelete = async (id) => {\n  setSuccess(false);\n  setError(false);\n  try {\n    await axiosJWT.delete(\"/users/\" + id, {\n      headers: { authorization: \"Bearer \" + user.accessToken },\n    });\n    setSuccess(true);\n  } catch (err) {\n    setError(true);\n  }\n};\n```\n\n\n\n이렇게 하면 액세스 토큰 만료 문제를 다룰 수 있고, 서버에 요청을 보내기 전에 새 액세스 토큰을 받을 수 있습니다.\n\nGitHub 링크는 다음에서 찾을 수 있습니다.\n\n제 블로그를 읽어 주셔서 감사합니다. 새로운 것을 배우셨으면 좋겣습니다.","ogImage":{"url":"/assets/img/2024-05-12-JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications_0.png"},"coverImage":"/assets/img/2024-05-12-JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications_0.png","tag":["Tech"],"readingTime":7},{"title":"React TypeScript로 npm 패키지 생성하고 배포하는 방법 데모 및 자동 빌드 포함","description":"","date":"2024-05-12 22:36","slug":"2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild","content":"\n\n## 제로부터 놀라운 프로젝트를 만드는 법을 배워보세요\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png)\n\n# 소개\n\nnpm 패키지를 발행하는 데 대해 더 많은 기사를 쓰기로 결정한 이유는 무엇일까요? 제가 스스로 이러한 패키지를 만들어야 할 때, 인터넷의 대부분의 지침이 오래되었거나 제품 제작에 거의 도움이 되지 않는 매우 짧았기 때문입니다.\n\n\n\n모든 단계를 가능한 명확하게 설명하고자 노력하겠습니다. 그래서 여러분도 처음부터 직접 프로젝트를 만들어보실 수 있을 거에요. 시작해 봐요!\n\n간단한 React 애플리케이션을 만드는 것을 제안합니다. 두 개의 버튼으로 이루어진 카운터 값을 증가시키거나 감소시키는 애플리케이션입니다.\n\n우리 애플리케이션은 이렇게 생겼을 거에요:\n\n데모: [링크](https://gapon2401.github.io/my-react-typescript-package/)\n저장소: [링크](https://github.com/gapon2401/my-react-typescript-package)\n\n\n\n우리는 모든 것을 다루는 14단계가 있어요:\n\n- 프로젝트 준비하기\n- React 애플리케이션 만들기\n- Git 구성하기\n- ESLint 구성하기\n- Prettier 구성하기\n- Jest로 테스트 추가하기\n- package.json 구성하고 발행 준비하기\n- 코드를 커밋하고 푸시하기\n- NPM에 발행하기\n- 예제 폴더 생성하기\n- 자동 빌드 설정하기\n- 데모 페이지\n- README.md 파일과 shields.io\n- 릴리스 만들기\n\n# 단계 1. 프로젝트 준비\n\n- 프로젝트의 명령줄에서 다음을 실행하세요:\n\n\n\n```js\nnpm init -y\n```\n\n이 명령어를 실행하면 기본 값으로 package.json 파일이 생성되고, 나중에 필요에 따라 수정할 수 있습니다.\n\n- src 폴더를 생성하세요.\n\n이 폴더에 모든 프로젝트 파일을 보관할 예정입니다.\n\n\n\n프로젝트에 React와 TypeScript를 추가해 보겠어요 (만약 상관 없다면 yarn을 사용할 거에요)\n\n```js\nyarn add -D react react-dom typescript @types/react\n```\n\n이제 node_modules 폴더와 yarn.lock 파일이 생성되었어요 — 꽤 좋죠!\n\n- TypeScript를 컴파일하기 위해 프로젝트 루트에 다음 내용을 가진 tsconfig.json 파일을 생성하세요:\n\n\n\n위의 내용을 참조하시면 가능한 모든 속성을 확인할 수 있어요: https://www.typescriptlang.org/tsconfig\n\n주요 내용:\n\n- rootDir — 소스 파일 내에서의 루트 폴더\n\n- include— TypeScript 프로젝트에 포함될 파일을 지정\n\n\n\n- exclude — TypeScript 프로젝트에서 제외할 파일을 지정합니다. dist 폴더와 모든 node_modules를 포함하고 싶지 않습니다.\n\n- outDir — 이것은 컴파일된 출력물의 위치입니다.\n\n- 빈 README.md 및 LICENSE 파일을 생성합니다.\n\n어떤 라이센스를 사용할지는 당신에게 달려있습니다. 저는 MIT를 사용할 것입니다. 해당 파일의 내용을 확인할 수 있습니다.\n\n\n\n위에 있는 내용을 마크다운 형식으로 바꿔보세요:\n\n![structure](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_1.png)\n\n## 단계 2. React 애플리케이션 만들기\n\nsrc 폴더 안에 components 폴더를 만들어주세요. 여기에 프로젝트의 모든 컴포넌트를 보관할 수 있습니다. 이 글에서는 여기에 App.tsx라는 파일 하나만 만들어보겠습니다. 파일에는 아래 내용을 넣어주세요:\n\n\n\n저희의 React 애플리케이션이에요.\n\n이제 src 폴더 안에 index.ts 파일을 만들어주세요. 모듈을 내보내세요.\n\n프로젝트를 컴파일할 시간이에요!\n\npackage.json을 열어서 scripts 섹션을 변경해봐요:\n\n\n\n터미널에서 다음 명령을 실행하세요:\n\n```js\nyarn build\n```\n\n모든 컴파일된 코드와 함께 dist 폴더가 나타날 것입니다.\n\n축하합니다! 컴파일된 애플리케이션을 생성했습니다. 조금 더 나가야 할 과정이 남았습니다! (아마도.)\n\n\n\n위에서 언급한 단계 2 이후의 프로젝트 구조를 비교해보세요:\n\n![프로젝트 구조](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_2.png)\n\n## 단계 3. git 설정하기\n\n프로젝트를 빠르게 만들었으니 이제 git을 설정할 시간입니다.\n\n\n\n프로젝트 루트에서 다음 명령어로 git을 초기화하세요:\n\n```js\ngit init\n```\n\n프로젝트 루트에 다음 내용을 가진 .gitignore 파일을 생성하세요:\n\n```js\nnode_modules\n.idea\ndist\nyarn-error.log\n```\n\n\n\nJetbrains IDE를 사용하여 개발을 도와주기 때문에 .idea를 추가했어요.\n\n.gitignore 파일에는 리포지토리에 포함하고 싶지 않은 파일과 디렉터리를 나열합니다.\n\nGitHub에서 git repo를 만드세요. 나중에 초기 커밋을 만들고 원격 git을 로컬 git에 연결할 거에요.\n\n# 단계 4. ESLint 구성\n\n\n\nESLint은 코드를 정적으로 분석하여 빠르게 문제를 찾아줍니다. 우리는 개발 시에만 필요합니다.\n\n다음 코드로 eslint와 모든 필요한 구성 요소를 추가해주세요:\n\n```js\nyarn add -D eslint eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n원하는 대로 구성할 수 있으며, 자세한 사용자 가이드는 여기에 있어요: https://eslint.org/docs/user-guide/configuring/\n\n\n\n프로젝트의 루트에 .eslintrc 파일을 만드는 것을 제안합니다:\n\n.eslintignore 파일을 추가하세요:\n\n```js\nnode_modules\ndist\n```\n\n우리는 컴파일된 파일이 위치한 dist 폴더와 node_modules를 체크하지 않도록 무시할 것입니다.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n\n\n```js\nyarn lint\n```\n\n에러가 없어야 해요. \n\n스텝 4 이후 프로젝트 구조를 비교해보세요:\n\n![프로젝트 구조 비교](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_3.png)\n\n\n\n# 단계 5. Prettier 구성\n\nPrettier는 코드 포매터입니다. 팀으로 작업할 때 사용하면 모두의 코드가 동일한 표준을 준수하게 됩니다.\n\n터미널에서 다음 명령을 실행해주세요:\n\n```js\nyarn add -D eslint-config-prettier eslint-plugin-prettier prettier\n```\n\n\n\n프로젝트 루트에서 .prettierrc.json 파일을 만들어주세요:\n\n모든 옵션에 대해 더 알아보려면 여기를 확인해주세요: https://prettier.io/docs/en/options.html.\n\n.eslintrc에 prettier 플러그인을 추가해주세요:\n\nprettier 설정이 완료되었습니다! 이제 yarn lint를 실행하여 포맷 에러를 확인해보세요. 에러가 없다면, 인간인지 확인해보세요 😆.\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_4.png\" />\n\n이제 그것들을 수정해 봅시다! package.json에 다음을 추가하세요:\n\n```js\n\"prettier\": \"prettier --write \\\"{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\\\"\"\n```\n\n좋아요, yarn prettier를 실행하면 다음과 유사한 결과를 얻을 수 있습니다:\n\n\n\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_5.png)\n\n이제 yarn lint를 실행한 후에는 오류가 없어야 합니다. src/components/App.tsx 및 src/index.ts 파일을 확인해보세요. 변경되었습니다.\n\npackage.json의 scripts 섹션:\n\n```js\n\"scripts\": {\n  \"build\": \"tsc\",\n  \"lint\": \"eslint \\\"{**/*,*}.{js,ts,jsx,tsx}\\\"\",\n  \"prettier\": \"prettier --write \\\"{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\\\"\"\n}\n``` \n\n\n\nStep 5 이후 프로젝트 구조를 비교해보세요:\n\n![프로젝트 구조](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_6.png)\n\n## 단계 6. Jest를 사용한 테스트 추가\n\n테스트를 만들기 위해 저는 Jest 라이브러리를 사용하고 있어요. Jest는 꽤 유용하고 강력한 테스트 프레임워크에요. 얼마나 어려운 테스트를 작성할지는 당신에게 달렸어요.\n\n\n\n프로젝트에 jest를 추가해주세요:\n\n```js\nyarn add -D jest jest-canvas-mock jest-environment-jsdom ts-jest @types/jest @testing-library/react\n```\n\n프로젝트 루트 파일 jestconfig.json을 생성해주세요.\n\n폴더 tests를 만들어주세요.\n\n\n\n첫 번째 테스트를 작성하는 시간입니다. 우리는 매우 간단한 테스트를 작성할 것인데, 렌더링이 성공적으로 이루어졌는지 확인할 것입니다.\n\ntests 폴더 안에 common.test.tsx 파일을 만들어주세요.\n\npackage.json 파일의 scripts 섹션을 변경해주세요:\n\n```js\n\"test\": \"jest --config jestconfig.json\"\n```\n\n\n\nyarn test 명령을 실행해보세요. 테스트가 통과해야 합니다:\n\n![프로젝트 구조 비교 후 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_7.png)\n\n스텝 6 이후의 프로젝트 구조를 비교해보세요:\n\n![스텝 6 이후 프로젝트 구조 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_8.png)\n\n\n\n# 단계 7. package.json 구성 및 발행 준비\n\n저는 빌드를 분리하는 것을 제안합니다. 우리는 패키지를 가능한 한 접근하기 쉽게 만들기 위해 ECMAScript 모듈뿐만 아니라 CommonJs 모듈도 컴파일할 것입니다.\n\npackage.json 파일에서 다음을 대체하세요:\n\n```json\n\"build\": \"tsc\",\n```\n\n\n\n다음 코드를 사용하여\n\n```js\n\"build\": \"yarn build:esm && yarn build:cjs\",\n\"build:esm\": \"tsc\",\n\"build:cjs\": \"tsc --module commonjs --outDir dist/cjs\",\n```\n\nbuild:esm과 build:cjs를 추가하고 이를 하나의 명령어로 결합했습니다.\n\nyarn build를 실행하면, 이제 dist/ 폴더에 cjs 폴더가 생성된 것을 확인할 수 있습니다.\n\n\n\n더 나아가보세요.\n\npackage.json 파일에서는 패키지가 게시될 때 자동으로 호출되는 매직 스크립트를 사용할 수 있습니다. 이러한 스크립트를 사용하면 패키지를 모든 종류의 오류로부터 확인하고 실수로 업데이트를 업로드하여 패키지가 사용되는 수백 만 프로젝트를 충돌시키지 않도록 도와줍니다!\n\n- prepare — 패키지가 패킹되고 게시되기 전에 실행됩니다. 인수 없이 로컬 npm install에서 실행됩니다.\n- prepublishOnly — 패키지가 준비되고 패킹되기 전에 실행됩니다. npm publish에서만 실행됩니다. 여기에는 테스트가 들어갑니다.\n\n다음을 스크립트 섹션에 추가하세요:\n\n\n\n```json\n\"scripts\": {\n  \"prepare\": \"npm run build\",\n  \"prepublishOnly\": \"npm test && npm run prettier && npm run lint\"\n},\n\"main\": \"dist/index.js\",\n\"types\": \"dist/index.d.ts\"\n```\n\n\n\n```js\n\"main\": \"index.js\",\n```\n\n다음과 같이 변경해주세요:\n\n```js\n\"main\": \"./dist/cjs/index.js\",\n\"module\": \"./dist/esm/index.js\",\n\"types\": \"./dist/esm/index.d.ts\",\n```\n\n원격 Git 저장소에 대한 정보를 추가해주세요 (단계 3에서 제공한 Git URL을 명시해주세요):\n\n\n\n```js\n\"repository\": {\n  \"type\": \"git\",\n  \"url\": \"git+https://github.com/gapon2401/my-react-typescript-package.git\"\n},\n```\n\n우리 패키지를 사용할 프로젝트는 적어도 `=16` 버전 이상의 리액트 버전을 가져야 합니다:\n\n```js\n\"peerDependencies\": {\n  \"react\": \">=16\"\n},\n```\n\n패키지가 불필요한 파일이 없도록하려면, 허용된 파일 및 폴더만 사용하여 패키지에 추가하십시오:\n\n\n\n\n```js\n\"files\": [\n  \"dist\",\n  \"LICENSE\",\n  \"README.md\"\n],\n```\n\n프로젝트를 찾을 수 있도록 키워드를 추가해주세요:\n\n```js\n\"keywords\": [\n  \"react\",\n  \"typescript\",\n  \"awesome-project\"\n],\n```\n\n라이선스를 명시해주세요:\n\n\n\n```js\n\"license\": \"MIT\",\n```\n\n저자 이름 변경하는거 잊지 마세요:\n\n```js\n\"author\": \"Igor Gaponov (gapon2401)\",\n```\n\n그게 충분한 것 같아요.\n\n\n\nREADME.md 파일에 설명을 추가해주세요.\n\n현재 README 파일에는 한 줄만 있습니다. 이것이 h1 입니다:\n\n```js\n# my-react-typescript-package\n```\n\npackage.json 파일의 최종 버전을 확인해보세요.\n\n\n\n# 단계 8. 코드를 커밋하고 푸시하세요\n\n우선, 원격 및 로컬 저장소를 연결하고 프로젝트를 푸시해 봅시다.\n\n다음 코드를 실행해 주세요:\n\n```js\ngit add .\ngit commit -m \"Initial commit\"\ngit remote add origin <저장소 URL>\ngit push -u origin master\n```\n\n\n\n본인의 `Repository Url`을 변경하는 것을 잊지 마세요. 이는 https URL이거나 ssh 일 수 있습니다. 이 URL은 레포지토리에서 얻을 수 있습니다.\n\n다음과 같은 예시를 살펴보세요.\n\n- HTTPS 레포지토리 URL (인증이 필요합니다)\n\n```js\ngit remote add origin https://github.com/gapon2401/my-react-typescript-package.git\n```\n\n\n\n- SSH 저장소 URL (SSH 연결 구성 필요)\n\n```js\ngit remote add origin git@github.com:gapon2401/my-react-typescript-package.git\n```\n\n저는 두 번째 해결책을 사용했어요.\n\n# 단계 9. NPM에 발행\n\n\n\n- 패키지 이름 선택하기\n\n우리 패키지의 이름을 사용할 수 있는지 확인해야 합니다. https://www.npmjs.com/ 웹사이트로 이동하여 검색 도구를 사용해보세요.\n\npackage.json 파일에서 프로젝트의 기본 이름을 찾아 변경할 수 있습니다:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_9.png)\n\n\n\n나의 경우에는 my-react-typescript-package 이 있습니다. 아직 그런 패키지는 없네요.\n\n다음과 같이 링크에 이름을 직접 삽입하여 확인하는 것이 더 좋다고 생각해요:\n\n```js\nhttps://www.npmjs.com/package/<당신의 패키지 이름>\n```\n\n`당신의 패키지 이름` 자리에 프로젝트의 이름을 넣어주세요.\n\n\n\n다음 URL을 받았어요:\n\n```js\nhttps://www.npmjs.com/package/my-react-typescript-package\n```\n\n만약 이름이 무료하면 404 페이지가 표시됩니다:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_10.png)\n\n\n\n- NPM에 등록/로그인하기\n\n프로젝트를 게시하려면 https://www.npmjs.com/에서 인증해야 합니다.\n\n아직 계정이 없다면 https://www.npmjs.com/signup에서 등록하거나 명령줄을 사용해 주세요:\n\n```js\nnpm adduser\n```\n\n\n\n사용자 이름, 비밀번호 및 이메일을 입력하라는 메시지가 표시됩니다.\n\n이미 계정이 있는 경우에는 다음을 실행하세요:\n\n```js\nnpm login\n```\n\n그리고 인증을 완료하세요.\n\n\n\n- 배포하기\n\n배포하기 전에 필요한 파일만 패키지에 포함되었는지, 오류가 없는지, 그리고 모든 것이 올바르게 포맷되어 있는지 확인하는 것을 추천합니다. 이를 위해 아래 명령어를 실행할 수 있습니다:\n\n```js\nnpm publish --dry-run\n```\n\n패키지가 실제로 게시되지는 않을 거에요, 걱정 마세요.\n\n\n\n\"매직 스크립트인 prepublishOnly가 호출되어 테스트 및 코드 형식 지정이 실행됨을 확인하게 될 거에요.\n\n그런 다음 프로젝트에 포함된 모든 파일 목록을 볼 수 있게 되며:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_11.png)\n\nTarball 콘텐츠에는 package.json에서 지정된 파일 및 폴더가 포함되어 있습니다:\"\n\n\n\n```js\n\"files\": [\n   \"dist\",\n   \"LICENSE\",\n   \"README.md\"\n ],\n```\n\n모든 준비가 끝났어요! 이제 패키지를 게시하면 돼요!\n\n다음 명령어를 실행해 주세요:\n\n```js\nnpm publish\n```\n\n\n\n이 명령을 실행할 때마다 항상 걱정이 돼요.\n\n명령 호출의 전체 결과를 첨부합니다:\n\n![Command Result](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_12.png)\n\n이제 축하해요! 패키지가 발행되었어요. 공개되었고, 누구든 사용할 수 있어요! 생각보다 어렵지 않았죠.\n\n\n\nNPM에서 해당 패키지를 확인해보세요.\n\n이전에 열었던 링크를 열어보세요.\n\n```js\nhttps://www.npmjs.com/package/<당신의 패키지 이름>\n```\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_13.png\" />\n\n\n\n잘 보이네요!\n\n# 단계 10. 예제 폴더 만들기\n\n우리 패키지를 계속 발전시키는 재미를 느껴봐요. 이번 단계에서는 패키지를 어떻게 활용할 수 있는지 보여줄 예제 폴더를 만들 것입니다. 이 폴더에서는 서버를 빠르게 시작하고 코드를 테스트할 수 있어요. \n애플리케이션을 빠르게 실행하려면 https://parceljs.org/를 사용할 거에요.\n\n`example`라는 폴더를 생성하세요.\n\n\n\n해당 폴더 안에 비어 있는 src 폴더와 파일을 만들어주세요:\n\n- .gitignore:\n\n```js\nnode_modules\nyarn.lock\n.parcel-cache\ndist\nyarn-error.log\n```\n\n- package.json:\n\n\n\n- README.md:\n\n자, 지금 주의를 기울여봐! 프로젝트의 루트 디렉토리에서 명령줄을 열고 예제 폴더로 이동해봐:\n\n```js\ncd example\n```\n\n그리고 실행해봐:\n\n\n\n```js\nyarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react\n```\n\nsrc 폴더 안에 index.html 파일을 만듭니다.\n\n이제, 우리 패키지를 가져와서 사용하는 예제를 작성해야 합니다.\n\nsrc 폴더 안에 index.tsx 파일을 만듭니다.\n\n\n\n서버를 실행할 시간입니다! 아래 명령어를 사용해주세요:\n\n```js\nyarn start\n```\n\n서버가 성공적으로 실행되면 다음 메시지가 표시됩니다:\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_14.png\" />\n\n\n\n아래의 예시를 확인하려면 http://localhost:1234 링크를 열어보세요:\n\n![예시 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_15.png)\n\n모든 설치와 서버 실행 후의 예시 폴더 구조를 비교해보세요. 아래와 같은 모양이어야 합니다:\n\n![예시 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_16.png)\n\n\n\n# 단계 11. 자동 빌드 설정하기\n\n자동 빌드에 대해 이야기해보겠습니다. 변경 사항을 git에 푸시하고 각 릴리스마다 npm에 푸시해야 하는 것은 꽤 불편합니다. 이 프로세스를 GitHub Actions로 자동화할 것입니다.\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_17.png)\n\n프로젝트 구조의 루트에 .github라는 폴더를 생성해주세요.\n\n\n\n안녕하세요! 친절한 안내드립니다.\n\nMarkdown 형식으로 테이블 태그를 변경하고,\n\n폴더 workflows를 만드세요.\n\n그 안에 파일 publish.yml을 만드세요:\n\n파일 안에는 중요한 포인트들이 주석처리되어 있습니다.\n\nGitHub에 릴리스할 때 우리의 패키지가 자동으로 빌드되어 NPM에 푸시됩니다.\n\n\n\n다음 라인을 확인해 주세요:\n\n```js\n# 우리 NPM 계정에 필요합니다\nNODE_AUTH_TOKEN: ${ secrets.NPM_TOKEN }\n```\n\n이 방법으로 GitHub를 NPM과 연결할 예정입니다.\n\n브라우저에서 https://www.npmjs.com/ 에서 계정을 열고 토큰이 있는 페이지로 이동해 주세요:\n\n\n\n아래는 Markdown 형식으로 변경된 내용입니다.\n\n\n![이미지1](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_18.png)\n\n새 토큰을 생성하십시오:\n\n![이미지2](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_19.png)\n\n이름을 입력하고 유형을 선택하라는 메시지가 표시됩니다. Automation은 github-actions에 적합합니다.\n\n\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_20.png)\n\n토큰을 복사하고 Github 레포지토리를 엽니다.\n\n탭 설정으로 이동하여 Secrets — Actions를 엽니다. 새 저장소 시크릿 변수를 만듭니다. NPM_TOKEN이라는 이름을 주고 NPM에서 받은 토큰 값을 붙여넣습니다:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_21.png)\n\n\n\n잘 했어요! 이제 프로젝트의 새 버전을 만들고 GitHub에 푸시하기만 남았어요.\n\n어떤 변경 사항을 커밋하기 전에 다음 명령어를 실행하는 것을 잊지 마세요:\n\n```js\nyarn prepublishOnly\n```\n\n코드가 깔끔하게 유지될 수 있도록 확인하는 것이 좋아요.\n\n\n\n프로젝트를 푸시한 후에 Actions 탭으로 이동하면 GitHub이 워크플로 액션을 감지했음을 알 수 있습니다. 그러나 아직 아무것도 시작되지 않았습니다. 왜냐하면 우리가 아직 릴리스를 만들지 않았기 때문입니다.)\n\n![image](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_22.png)\n\n# 단계 12. 데모 페이지\n\n이미 패키지를 사용하는 예제가 있는 폴더가 있지만, 전체 프로젝트를 클론하지 않고도 사용자가 빠르게 패키지 작업을 볼 수 있도록 서로 다른 페이지를 만들고 싶습니다. 이 페이지를 만들어 봅시다!\n\n\n\n우리는 깃허브 페이지를 사용하여 데모를 만들 거에요.\n\n새 깃 브랜치를 만들어보세요:\n\n```js\ngit checkout -b gh-pages\n```\n\n이제 프로젝트에서 모든 파일을 지우세요!\n\n\n\n이전 파일들은 모두 안전하게 다른 master 브랜치에 보관될 거니까 걱정하지 마세요. gh-pages 브랜치는 데모용으로만 사용될 거에요. 그래서 모든 파일을 삭제해야 해요. 자, 모두 삭제해주세요!\n\n그런 다음 명령 줄에서 다음을 실행하세요:\n\n```js\nnpm init -y\n```\n\n이 명령은 package.json 파일을 생성할 거에요. 이번에는 자세히 설정하지 않을 거에요.\n\n\n\n데모 페이지에는 우리가 익숙한 Parcel을 사용하는 것을 제안합니다 (단계 10)\n\n다음을 실행해보세요:\n\n```js\nyarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react typescript\n```\n\n`.gitignore` 파일을 생성하세요:\n\n\n\n```js\nnode_modules\nyarn.lock\n.parcel-cache\ndist\nyarn-error.log\n```\n\n다음 내용을 포함한 파일 tsconfig.json을 생성하세요.\n\nEslint를 설정하는 단계 4를 따르세요.\n\n빈 폴더 src를 생성하세요. 그 안에 다음 내용을 가진 파일 index.html을 생성하세요.\n\n\n\n새로운 index.tsx 파일을 생성해주세요.\n\npackage.json 파일의 scripts 섹션에 아래 코드를 추가해주세요:\n\n```json\n\"start\": \"parcel src/index.html\",\n\"build\": \"parcel build src/index.html --dist-dir docs --public-url .\"\n```\n\n제 package.json 파일을 확인해주세요.\n\n\n\n서버를 실행하여 모든 것이 잘 작동하는지 확인하세요:\n\n```js\nyarn start \n```\n\n이제 다음 명령어를 사용하여 오류를 확인하는 코드를 실행하세요:\n\n```js\nyarn lint\n```\n\n\n\n수정 사항 없습니다! 멋져요! 이제 페이지를 만들 차례에요.\n\n```js\nyarn build\n```\n\n데모 프로젝트의 모든 파일이 포함된 docs 폴더가 표시될 거예요.\n\n다음은 브랜치 gh-pages의 구조입니다:\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_23.png\" />\n\n이제 변경 사항을 모두 git에 푸시합시다. 다음을 실행하세요:\n\n```js\ngit add .\ngit commit -m \"초기 페이지 커밋\"\ngit push -u origin gh-pages\n```\n\nGitHub 저장소를 열어서 설정으로 이동하고 페이지로 이동합니다. 소스에서 /docs를 선택한 후 Save를 누릅니다:\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_24.png\" />\n\n약 3-5분 정도 기다리시면 지정된 URL에 사이트가 이용 가능해집니다. 페이지에 표시된 URL을 확인해보세요.\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_25.png\" />\n\n데모 페이지 작업이 끝났습니다. 보시다시피 사용자의 취향에 맞게 원하는 대로 커스터마이즈하고 어떠한 복잡도의 페이지나 웹사이트를 만들 수 있습니다.\n\n\n\n여기 결과가 있어요: [https://gapon2401.github.io/my-react-typescript-package/](https://gapon2401.github.io/my-react-typescript-package/)\n\n# 단계 13. README.md 파일 및 shields.io\n\n이제 코드 작업이 끝났으니, 이제 패키지의 설명 파일로 전환해 볼게요.\n\ngit에서 master 브랜치로 전환하고 README.md 파일을 열어주세요.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해주세요:\n\n\nFor the description file, we are using markdown.\n\nIn README.md, I have added a short description of the package, link to demo-page, and a usage section.\n\nAt the beginning of the readme file, I have small cute icons. This is [shields.io](https://shields.io/). It is very convenient to have them. I’ve added just a couple as an example, you can use as many as you want.\n\n\n\nGitHub 앱lications에 shields.io를 추가해보세요.\n\n파일 끝을 살펴보세요; 이미지와 링크가 있는 변수를 만들었습니다. Markdown을 사용하면 이러한 변수를 만들 수 있기 때문에 설명 파일이 더 정확해집니다. 저장소 경로와 패키지 이름을 변경하는 것을 잊지 마세요.\n\npackage.json에서 버전을 변경하고, 커밋하고 파일을 레포지토리에 푸시하세요. 모든 작업은 스스로 진행해주세요. 이전 단계에 이미 수행했던 것과 같은 절차입니다.\n\n# 단계 14. 릴리스 만들기\n\n\n\n이것이 마지막 단계입니다. 짧을 거에요.\n\n우리가 계획했던 모든 것을 완료했어요! 이제 공식 릴리스를 GitHub에 작성하고 자동 빌드가 어떻게 작동하는지 확인할 수 있어요.\n\n저장소의 메인 페이지로 이동해서 '새 릴리스 생성'을 클릭하세요:\n\n![Create a new release](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_26.png)\n\n\n\n현재 버전을 지정하는 태그를 추가하세요. 릴리스 시 자동으로 생성됩니다. 릴리스 제목과 설명을 인쇄하고 릴리스를 발행하려면 클릭하십시오.\n\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_27.png)\n\n이제 탭 \"Actions\"를 열고 빌드가 성공적으로 완료되었는지 확인하세요.\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_28.png)\n\n\n\n패키지를 NPM에서 업데이트했는지 확인해 봐요.\n\n패키지 링크를 열어 볼게요:\n\n```js\nhttps://www.npmjs.com/package/<패키지 이름>\n```\n\n제것을 열어 볼게요:\n\n\n\n```js\nhttps://www.npmjs.com/package/my-react-typescript-package\n```\n\n새 버전과 새 설명이 나와 있어요:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_29.png)\n\n긴 여정이었지만, 매우 유용하길 바랍니다. 처음 패키지를 게시할 때 어려웠던 모든 것을 설명하기 위해 노력했고, 이 정보들을 조각 조각 모았어요.\n\n\n\n읽어 주셔서 감사합니다! ❤","ogImage":{"url":"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png","tag":["Tech"],"readingTime":17},{"title":"고르는 아픔","description":"","date":"2024-05-12 22:33","slug":"2024-05-12-ChooseYourPain","content":"\n\n나의 이야기를 탐험하면서, 당신에게 권장하고 싶은 것은 당신의 삶의 여정에 대해 깊이 사색에 몰입하는 것입니다. 오늘, 여러분은 수많은 영혼 사이에서 스스로의 길을 명확한 로드맵 없이 개척하는 사람들 중 하나로 자리 잡게 될 것입니다. 당신은 스스로의 생존을 책임져야 함을 깨달았습니다.\n\n도전을 극복하며 지혜롭게 이끌어나가는 도중에, 때로는 승리를 거두기도 하고 가치 있는 교훈을 얻기도 합니다. 매일 과업을 완수하기 위해 노력하고 있습니다. 작업을 완료하지 못했더라도, 탄탄한 인내심을 지닌 채 새로운 하루를 맞이할 준비가 되어 있습니다. 삶이 불가피한 실패를 안겨주더라도, 여러분은 다시 일어서며 고통 속에서 현명해짐을 이해하고 있는 강한 의지를 지니고 있습니다.\n\n이러한 경험들이 삶의 틀을 짜며, 항복은 선택지가 아닙니다. 노력은 성공으로 가는 길이며, 무능히 행동함은 패배를 보장합니다. 삶은 다양한 고통을 제공합니다. 여러분의 고통을 선택하세요.","ogImage":{"url":"/assets/img/2024-05-12-ChooseYourPain_0.png"},"coverImage":"/assets/img/2024-05-12-ChooseYourPain_0.png","tag":["Tech"],"readingTime":1},{"title":"리액트 네이티브 앱을 위한 CICD 파이프라인 Fastlane과 GitHub Actions 사용하기 - 파트 1 Fastlane 이해하기","description":"","date":"2024-05-12 22:32","slug":"2024-05-12-CICDpipelineforReactNativeappsuseFastlaneandGitHubActions-Part1understandFastlane","content":"\n\n![Screenshot](/assets/img/2024-05-12-CICDpipelineforReactNativeappsuseFastlaneandGitHubActions-Part1understandFastlane_0.png)\n\n리액트 네이티브 프레임워크는 크로스 플랫폼 앱 개발을 혁신적으로 변화시켰으며, iOS 및 Android 모두에 대한 풍부하고 성능이 우수한 애플리케이션을 개발할 수 있도록 허용합니다. 그러나 현대 소프트웨어 개발에서 요구되는 민첩성은 코드 작성 뿐만 아니라 견고한 테스트, 자동화된 빌드 및 신속한 배포도 포함됩니다.\n\n리액트 네이티브는 iOS 및 Android 애플리케이션 모두를 제공하므로 Apple 및 Google 스토어에 출시하는 것은 머리아플 수도 있습니다: 둘 다 별도로 빌드하고 테스트하고, 리뷰에 제출하고 확인을 기다립니다. 리액트 네이티브의 초창기에 이러한 프로세스를 수행하는 것은 머리아팠지만, 그 이후에 그 작업을 수행할 수 있는 도구들이 출시되었습니다.\n\n해당 프로세스는 다음과 같이 수행되었습니다:\n\n\n\n## 안드로이드 (Google Play Store):\n\n- 개발자들은 Android Studio를 사용하여 코드를 작성하고 안드로이드 앱 프로젝트를 관리합니다. Gradle은 빌드 프로세스를 자동화하며 코드 컴파일 및 APK 생성과 같은 작업을 처리합니다. 앱이 배포 준비가 되면, 개발자들은 Google Play 콘솔을 사용하여 앱을 제출하고, 앱 메타데이터를 관리하며 사용자 피드백 및 분석을 모니터링합니다.\n\n## iOS (Apple App Store):\n\n- Xcode는 iOS 앱 개발의 주요 도구로, 구축 및 테스트를 위한 포괄적인 기능 세트를 제공합니다. Fastlane은 Xcode를 보완하여 배포 작업을 자동화합니다. 개발자들은 Fastlane 레인을 구성하여 앱을 빌드, 코드 서명, App Store에 앱을 릴리스하는 작업을 처리합니다. Apple Developer 계정은 App Store에 앱을 제출하기 위한 필수 사항이며, 여기서 개발자들은 앱 인증서, 프로비저닝 프로필 및 앱 제출을 관리합니다.\n\n\n\n표가 있던 형식은 자동화 도구들이 소개되기 전까지는 그랬어요. 그 중 일부는 다음과 같아요:\n\n## Expo\n\nExpo는 React Native 앱의 개발 및 배포를 간단하게 만드는 플랫폼이에요. iOS 및 Android 장치 모두에 앱을 쉽게 구축, 테스트 및 배포할 수 있는 도구와 서비스를 제공해요. 또한 Expo에는 Google Play Store와 Apple App Store용 앱 이진 파일을 생성할 수 있는 내장된 빌드 서버도 포함돼 있어요.\n\n## Fastlane\n\n\n\n패스트레인은 iOS 및 안드로이드 앱 개발 및 배포와 관련된 작업을 자동화하는 도구입니다. 빌드, 테스트, 앱 배포, Google Play Store 및 Apple App Store를 위한 스크린샷 및 메타데이터 생성 등과 같은 작업을 자동화하는 데 사용할 수 있습니다.\n\n패스트레인은 \"레인\"이라는 개념을 소개하여 워크플로우를 간소화합니다. 빌드, 테스트, 코드 서명 및 배포와 같은 작업을 자동화하여 수동 에러를 줄이고 전체 생산성을 향상시킵니다.\n\n## AppCenter\n\nAppCenter는 iOS 및 안드로이드 기기에 앱을 빌드, 테스트 및 배포하는 데 사용되는 도구 모음을 제공하는 플랫폼입니다. 내장된 빌드 서버, 지속적 통합 및 지속적 전달 (CI/CD) 파이프라인 및 배포 플랫폼이 포함되어 있습니다.\n\n\n\n## Codemagic\n\n코드매직은 클라우드 기반 CI/CD 플랫폼으로, 모바일 앱의 빌드 및 배포를 자동화하는 데 사용할 수 있습니다. Expo, Fastlane, AppCenter 등 다양한 도구와 통합됩니다.\n\n## Firebase\n\nFirebase는 모바일 앱을 빌드, 배포 및 관리하기 위한 다양한 서비스를 제공하는 플랫폼입니다. 내장된 CI/CD 파이프라인, 배포 플랫폼, 그리고 분석, 크래시 보고 등의 기능을 위한 도구 세트를 포함하고 있습니다.\n\n\n\n저에게 있어서 제일 좋은 도구는 Fastlane이었어요. 이 도구를 사용해서 제작한 앱들을 수동으로 제출하는데 사용했지만, GitHub Actions가 도입되면서 더 쉬워졌어요.\n\nGitHub Actions는 GitHub 저장소와 완벽하게 통합되는 CI/CD 플랫폼입니다. 이를 사용하여 개발자들은 코드 푸시 또는 풀 리퀘스트와 같은 이벤트로 트리거되는 자동화된 워크플로우를 정의할 수 있습니다.\n\n이 기사에서는 Fastlane을 GitHub Actions와 함께 사용하여 CI/CD 릴리스 프로세스를 진행하는 방법을 단계별로 안내할 거에요.\n\n## 가정들\n\n\n\n튜토리얼 일부를 따를 수 있어요:\n\n- 맥 머신을 사용하고 계시다면 좋아요\n- React Native 저장소를 호스팅하는 GitHub 계정을 가지고 있어요\n- React Native 앱과 이미 통합된 Firebase 계정을 가지고 있어요 (Firebase 앱 배포를 건너뛸 수 있다면 선택사항)\n- Google Play Store와 iOS App Store에 앱이 등록되어 있어요\n\n# 솔루션을 엔지니어링하는 방법:\n\n이 섹션에서는 Fastlane과 Github actions을 통합하는 방법을 설명하고 싶어요. 다른 튜토리얼을 읽을 수 있지만, 주로 어떻게 하는지 보여주는 것보다는 어떻게 엔지니어링하는지에 대해 알려드릴 거예요. '어떻게 생각하는지 가르치는' 방법을 알 수 있을 거예요.\n\n\n\n## Fastlane의 내부 작동 방식:\n\nFastlane은 빌드, 테스트 및 제출 작업을 자동화합니다. 아래와 같은 방법으로 사용됩니다:\n\n- 레인 정의: Fastfile에서 레인을 정의하여 관련 작업을 그룹화합니다. 예를 들어, 앱을 빌드하는 레인, 앱을 테스트하는 레인, 앱을 배포하는 레인 등이 있을 수 있습니다.\n- 플러그인 사용: Fastlane은 다양한 작업을 자동화할 수 있는 풍부한 플러그인 생태계를 보유하고 있습니다. 예를 들어, 앱을 빌드하는 플러그인, 앱을 테스트하는 플러그인, 스크린샷을 생성하는 플러그인, 앱을 앱 스토어에 제출하는 플러그인 등이 있습니다.\n- 자격증명 및 비밀 정보: Fastlane은 API 키, 인증서, 프로비저닝 프로필과 같은 중요 정보를 안전하게 관리할 수 있는 방법을 제공합니다. 이러한 정보는 빌드 프로세스 중에 안전하게 저장되고 액세스할 수 있습니다.\n\n- iOS 및 Android 앱에 서명하기 위해 인증서와 프로비저닝 프로필이 필요합니다. 이를 통해 개발자는 Apple 또는 Google에 자신을 식별하고 앱을 앱 스토어 또는 구글 플레이에 배포할 수 있습니다.\n- 이는 빌드 및 제출 작업시 다른 인증서와 프로비저닝 프로필이 필요하기 때문에 중요합니다. 이를 관리하기 위해 사용되는 플러그인 중 하나가 Fastlane Match입니다.\n\n\n\n4. 앱 테스트하기: Fastlane을 사용하면 배포 전에 앱이 정확히 작동하는지 확인하는 테스트를 실행할 수 있습니다.\n\n5. 스크린샷 생성하기: Fastlane을 사용하면 앱 스토어를 위한 스크린샷을 생성할 수 있어서 앱이 다양한 기기에서 잘 보이도록 할 수 있습니다.\n\niOS의 경우:\n\n- Fastlane을 사용하여 원하는 iOS 기기나 시뮬레이터용으로 앱을 빌드할 수 있습니다.\n- Fastlane을 사용하여 XCTest나 Jest와 같은 도구로 iOS 테스트를 실행할 수 있습니다.\n- Fastlane을 사용하여 FastlaneSnapshots와 같은 도구로 앱 스토어를 위한 스크린샷을 생성할 수 있습니다.\n- Fastlane을 사용하여 App Store Connect와 같은 도구로 앱을 앱 스토어에 제출할 수 있습니다.\n\n\n\n## 안드로이드 용:\n\n- Fastlane은 원하는 Android 장치 또는 에뮬레이터를 위해 Gradle 또는 Bazel을 사용하여 앱을 빌드할 수 있습니다.\n- Fastlane은 Espresso 또는 Mockito와 같은 도구를 사용하여 Android 테스트를 실행할 수 있습니다.\n- Fastlane은 Appium과 같은 도구를 사용하여 Google Play Store를 위한 스크린샷을 생성할 수 있습니다.\n- Fastlane은 Google Play Console과 같은 도구를 사용하여 앱을 Google Play Store에 제출할 수 있습니다.\n\n팁: Fastlane은 미리 정의된 스크립트를 실행하므로 수동으로 수행할 수 있는 작업을 자동화합니다. 이는 Fastlane이 필요하지 않고 앱을 Apple 및 Google 스토어에 제출하는 CI-CD 프로세스를 달성할 수 있다는 것을 의미합니다. 그러나 사용하면 (자동화 도구와 같은) CI-CD 프로세스를 크게 개선할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-CICDpipelineforReactNativeappsuseFastlaneandGitHubActions-Part1understandFastlane_0.png"},"coverImage":"/assets/img/2024-05-12-CICDpipelineforReactNativeappsuseFastlaneandGitHubActions-Part1understandFastlane_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트 프레임워크의 인기 모바일 앱 개발용 툴인 React Native의 AdMob 통합에 대해 알아보자","description":"","date":"2024-05-12 22:30","slug":"2024-05-12-SeniorReactNativeAdmobIntegration","content":"\n\n안녕하세요 여러분,\n\n![이미지](/assets/img/2024-05-12-SeniorReactNativeAdmobIntegration_0.png)\n\n오늘은 리액트 네이티브에서 애드몹 통합을 통해 인앱 광고를 수익화하는 방법에 대해 이야기하겠습니다.\n\n궁금한 점이 있으시면 언제든지 연락주세요.\n\n\n\n우선 link에서 계정을 만들고 iOS 및 Android용 두 가지 다른 앱을 생성해야 합니다.\n\n![image](/assets/img/2024-05-12-SeniorReactNativeAdmobIntegration_1.png)\n\n📍 이런 식으로 두 가지 다른 앱을 만들고 추가해야 합니다. 여기서 중요한 점은 귀하의 제품이 스토어에 있는 경우 스토어를 추가하지 않도록 하는 것입니다. 앱을 공유한 후에도 스토어를 추가해야 합니다.\n\n그런 다음 프로젝트에 아래 패키지를 설치해야 합니다.\n\n\n\n```js\nnpm i react-native-google-mobile-ads\n```\n\n이 패키지는 매우 건강합니다. 현재 지원은 최신 버전까지 업데이트되어 있습니다.\n\n여기서 중요한 점은 빌드 버전을 따라야 한다는 것입니다. ios 및 안드로이드 플랫폼에서 광고를 오류없이 사용하고 싶다면 버전 12.6.0을 사용하는 것을 권장드립니다.\n\n적절히 패키지를 설치한 후 pod install을 실행한 상태에서 android와 ios 모두 다음 단계를 수행해야 합니다.\n\n\n\n📌 app.json에 생성한 앱 ID를 추가하세요. 완전히 입력하는 것이 중요합니다.\n\n```js\n{\n  ...\n  \"react-native-google-mobile-ads\": {\n    \"android_app_id\": \"ca-app-pub-xxxxxxxx~xxxxxxxx\",\n    \"ios_app_id\": \"ca-app-pub-xxxxxxxx~xxxxxxxx\"\n  }\n}\n```\n\n이 작업을 올바르게 수행했다면, 이제 사용할 수 있습니다.\n\n# 배너 광고\n\n\n\n```js\nimport { GAMBannerAd, BannerAdSize, TestIds } from 'react-native-google-mobile-ads';\n```\n\n```js\n<GAMBannerAd\n    unitId={TestIds.BANNER}\n    sizes={[BannerAdSize.FULL_BANNER]}\n    requestOptions={\n      requestNonPersonalizedAdsOnly: true,\n    }\n/>\n```\n\n여기서 페이지 하단이나 상단에 배너 광고가 주목을 끕니다. 이 광고는 고정되어 있으며, 페이지에서 사용하는 상태 및 조건에 따라 표시하거나 숨길 수 있습니다.\n\n<img src=\"/assets/img/2024-05-12-SeniorReactNativeAdmobIntegration_2.png\" />\n\n\n\n위와 같은 예제를 볼 수 있습니다. 다양한 옵션을 사용하여 내용을 정리할 수 있습니다.\n\n# 인터스티셜 광고\n\n```js\nimport { InterstitialAd, TestIds, AdEventType } from 'react-native-google-mobile-ads';\n```\n\n```js\nconst interstitial = InterstitialAd.createForAdRequest(TestIds.INTERSTITIAL, {\n    requestNonPersonalizedAdsOnly: true,\n    keywords: ['fashion', 'clothing'],\n});\n```\n\n\n\n📔 여기서는 우리가 만든 요청에 키워드를 사용하여 보여줄 광고 콘텐츠 단어를 선택하고 집중할 수 있어요.\n\n이 유형의 광고는 사용자가 특정한 앱의 핵심 목표를 달성하고 특정 동작을 취한 경우에 보여줄 수 있는 광고입니다. 예를 들어 다운로드 버튼, 공유 버튼, 특정 시간 동안 앱에 머무르는 사용자 등을 포함해요.\n\n💎 여기서 중요한 점은 이거에요. 페이지가 열릴 때 생성된 요청을 가능한 빨리 로드하는 것이 필요합니다. 원격 광고 콘텐츠를 설정하고 필요한 곳에 보여주는 것이 건강에 좋을 거예요.\n\n```js\nuseEffect(() => {\n    let interValId: NodeJS.Timeout;\n    interValId = setInterval(() => {\n      if (interstitial) {\n        interstitial.addAdEventListener(AdEventType.LOADED, () => {\n          interstitial.show();\n          if (interValId) {\n            clearInterval(interValId);\n          }\n        });\n        interstitial.load();\n      }\n    }, 500);\n }, []);\n```\n\n\n\n💡 광고가 언제 업로드되고 도착할지 보장할 수 없어요. 로드 과정이 중단될 수도 있고 제어하기 어려워질 수 있어요. 그래서 주기적으로 광고를 로드하고 정리하는 것이 중요해요. 이것이 중요한 관행이에요.\n\n이것은 제가 작성한 제 코드로 완전히 자유롭습니다. 훅을 사용하여도 제어할 수 있어요. 광고를 위한 훅들에 대해 다음 기사에서 공유할 거에요.\n\n![광고 이미지](/assets/img/2024-05-12-SeniorReactNativeAdmobIntegration_3.png)\n\n위와 같은 예시를 보실 수 있어요. 다양한 옵션으로 구성할 수 있어요.\n\n\n\n# 앱 오픈 광고\n\n```js\nimport { AppOpenAd, TestIds } from 'react-native-google-mobile-ads';\n```\n\n```js\nconst appOpenAd = AppOpenAd.createForAdRequest(TestIds.APP_OPEN, {\n    requestNonPersonalizedAdsOnly: true,\n    keywords: ['패션', '의류'],\n});\n```\n\n📔 여기에서는 광고 콘텐츠에 표시하고 초점을 맞출 원하는 키워드를 요청에서 생성한 키워드와 함께 지정할 수 있습니다.\n\n\n\n앱을 열자마자 보여줄 수있는 광고입니다. 이름에서 알 수 있듯이, 이 광고를 자주 사용하는 것은 권장하지 않습니다.\n\n```js\nuseEffect(() => {\n    appOpenAd?.load();\n    setTimeout(() => {\n        if (appOpenAd) {\n            appOpenAd?.show();\n        }\n    }, 1000);\n}, []);\n```\n\napp.tsx에서 코드를 관리하는 것이 좋습니다. 또한 다른 후크를 통해 관리할 수도 있습니다. 페이지가 로드될 때 광고가 로드되고 설정한 시간이 지난 후에 페이지에 표시됩니다.\n\n![이미지](/assets/img/2024-05-12-SeniorReactNativeAdmobIntegration_4.png)\n\n\n\n위와 같이 예제를 확인할 수 있습니다. 다양한 옵션으로 조직화할 수 있어요.\n\n# 보상형/비디오 광고\n\n```js\nimport { RewardedAd, GAMBannerAd, BannerAdSize, TestIds } from 'react-native-google-mobile-ads';\n```\n\n```js\nconst rewarded = RewardedAd.createForAdRequest(TestIds.GAM_REWARDED, {\n  requestNonPersonalizedAdsOnly: true,\n  keywords: ['패션', '의류'],\n});\n```\n\n\n\n📔 여기서는 우리가 생성한 요청의 키워드를 사용자가 원하는 광고 콘텐츠 단어로 장착할 수 있어요. 이를 강조하고 보여줄 수 있도록 해보세요.\n\n이 유형의 광고는 여러분에게 가장 많은 수익을 창출해 줄 종류의 광고에요. 이 광고들은 추가 혜택으로 표시되어야 해요. 예를 들어, 광고를 시청함으로써 더 많은 코인을 얻을 수 있다고 생각할 수 있어요.\n\n💊 너무 자주 보여주면 고객을 잃을 수도 있을 거에요.\n\n```js\nuseEffect(() => {\n  rewarded.load()\n}, []);\n```\n\n\n\n컴포넌트가 로드될 때, 로드 작업을 수행합니다.\n\n```js\n<Button\n   onPress={()=> rewarded.show()}\n   title=\"보상형 광고 보기\"\n/>\n```\n\n여기에서는 광고가 로드된 시점과 페이지가 실제로 광고를로드 한 것이 있음을 공식적으로 확인할 수 없을 수 있습니다. 이를 해결하기 위해 아래 함수를 사용하여 작업을 보장하거나 모든 광고 작업을 단일 훅에서 추적할 수 있습니다.\n\n```js\nconst showAds = () => {\n    let interValId: NodeJS.Timeout;\n    interValId = setInterval(() => {\n      if (rewarded) {\n        rewarded.addAdEventListener(AdEventType.LOADED, () => {\n          rewarded.show();\n          if (interValId) {\n            clearInterval(interValId);\n          }\n        });\n        rewarded.load();\n      }\n    }, 500);\n};\n```\n\n\n\n여기에서 로드를 필수로 만들었고 광고는 완전히 표시되었습니다.\n\n![예시 이미지](/assets/img/2024-05-12-SeniorReactNativeAdmobIntegration_5.png)\n\n위의 예시처럼 보실 수 있습니다. 다양한 옵션으로 조직화할 수 있습니다.\n\n여기에서 제안하는 제어 구조와 데모는 시니어 레벨의 사례입니다. 따라서 리액트 네이티브 애플리케이션에서 google 광고로 수익을 창출할 수 있습니다. 통합을 완전히 숨기면 수익이 증가할 것입니다. 사용자 정의 키워드를 사용하는 것이 중요합니다.\n\n\n\n감사합니다. 언제든 연락 주세요. 공유하기를 잊지 마세요 🤗\n\n다음 글에서 뵙겠습니다. 안녕 👋\n\n## Linkedin\n\n## Github","ogImage":{"url":"/assets/img/2024-05-12-SeniorReactNativeAdmobIntegration_0.png"},"coverImage":"/assets/img/2024-05-12-SeniorReactNativeAdmobIntegration_0.png","tag":["Tech"],"readingTime":6},{"title":"라라벨Laravel과 이너시아Inertiajs 그리고 리액트React를 활용하여 SPA 개발을 어떻게 간소화할 수 있는지","description":"","date":"2024-05-12 22:29","slug":"2024-05-12-HowLaravelwithInertiajsandReactSimplifiesSPADevelopment","content":"\n\n![이미지](/assets/img/2024-05-12-HowLaravelwithInertiajsandReactSimplifiesSPADevelopment_0.png)\n\n과거에는 백엔드로 라라벨을, 프론트엔드로 리액트를 사용하여 Single Page Applications (SPA)를 개발하는 것이 독특한 문제를 제기했습니다. 이분법은 개발자가 Laravel API와 React 프로젝트 두 개의 별도 코드베이스를 유지해야 했기에 개발 프로세스를 복잡하게 만들었습니다. 이러한 분리는 개발 과정을 복잡하게 만들 뿐만 아니라 유지보수, 효율성, 그리고 원활한 통합 측면에서도 중요한 장애물이었습니다.\n\n전통적인 SPA 개발은 주로 React 프론트엔드에서 Laravel 백엔드로 API 호출을 수행해야 했으며 두 곳 사이의 신중한 조율이 필요했습니다. 개발자는 CORS (Cross-Origin Resource Sharing) 문제를 관리하고, API 인증을 처리하며, 효율적인 데이터 직렬화와 역직렬화를 보장해야 했습니다. 게다가 새로운 기능을 구현하거나 업데이트 중일 때, 특히 프론트엔드와 백엔드를 동기화하는 것은 계속된 고민이었습니다.\n\n또 다른 중요한 도전은 양 끝에서 작업하는 개발자들이 학습 곡선과 컨텍스트 전환이었습니다. Laravel 개발자들은 React 생태계를, 그 반대로도 익혀야 했기에 생산성이 감소하고 프로젝트 일정이 증가하게 되었습니다.\n\n\n\nInertia.js의 소개는 이 작업 방식을 혁신적으로 바꿨어요. Laravel과 React 사이에 원활한 다리 역할을 하면서 API 기반 접근법의 복잡성 없이 SPA(단일 페이지 어플리케이션)를 개발할 수 있게 했죠. Inertia.js는 Laravel 컨트롤러에서 직접 데이터를 React 컴포넌트로 보낼 수 있게 해주어, 많은 경우에 API 레이어가 필요하지 않게 되었어요. 이 통합은 개발 프로세스를 간소화시키고 비용을 절감하며, Laravel의 서버 측 렌더링과 React의 동적 사용자 인터페이스의 전체 기능을 일치시키는 일관된 생태계 내에서 개발자가 효과적으로 활용할 수 있게 했어요.\n\n본 블로그에서는 Laravel을 Inertia.js와 React와 통합하여 이러한 도전 과제를 해결하고 SPA 개발을 간소화하는 방법에 대해 탐구해 볼 거에요. 이 강력한 세트를 구현하여 효율적이고 견고하며 유지보수가 쉬운 애플리케이션을 만드는 전체 가이드를 제공하고, 현대 웹 개발에서 큰 발전을 이루는 중요한 한 걸음을 내딛을 거에요.\n\n# 전제조건\n\n시작하기 전에 다음을 확인해주세요:\n\n\n\n- Laravel, React 및 JavaScript에 대한 기본적인 이해가 필요합니다.\n- 시스템에 Laravel과 Node.js가 설치되어 있어야 합니다.\n- 의존성을 관리하기 위해 Composer 및 npm 또는 yarn이 필요합니다.\n\n# 단계 1: Laravel 설정\n\n먼저 새로운 Laravel 프로젝트를 생성하거나 기존 프로젝트로 이동하세요. Composer를 사용하여 새로운 Laravel 프로젝트를 만들 수 있습니다:\n\n```js\ncomposer create-project --prefer-dist laravel/laravel laravel-inertia-react\n```\n\n\n\n라라벨을 설정한 후에는 .env 파일에서 특히 데이터베이스 설정이 올바르게 구성되었는지 확인하세요.\n\n# 단계 2: Inertia.js 설치\n\nInertia.js는 패키지가 아닌 프로토콜이기 때문에 별도의 설치가 필요하지 않습니다. 그러나 라라벨을 위한 서버 측 어댑터와 React를 위한 클라이언트 측 어댑터를 설치해야 합니다. 다음 명령어를 실행하세요:\n\n```js\ncomposer require inertiajs/inertia-laravel\nnpm install @inertiajs/inertia @inertiajs/inertia-react\n```\n\n\n\n# 단계 3: Inertia.js 구성하기\n\n필요한 패키지를 설치한 후에는 Laravel에서 Inertia.js를 설정하십시오. 다음을 사용하여 Inertia.js 구성 파일을 발행하십시오:\n\n```js\nphp artisan inertia:middleware\n```\n\n이 명령은 Inertia 미들웨어를 만들어주며, 이를 앱/Http/Kernel.php 파일의 $middlewareGroups에 추가해야 합니다.\n\n\n\n# 단계 4: React 설정하기\n\nReact를 사용하려면 Laravel Mix 또는 Vite를 설정해야 합니다. React를 컴파일하기 위해 webpack.mix.js 파일의 내용을 다음과 같이 바꿉니다:\n\n```js\nconst mix = require('laravel-mix');\n\nmix.js('resources/js/app.js', 'public/js')\n    .react()\n    .postCss('resources/css/app.css', 'public/css', [\n        //\n    ]);\n```\n\n## Vite.js 설정하기\n\n\n\n라라벨 믹스 대신 Vite.js를 사용할 수도 있어요. 먼저 Vite를 설치하세요:\n\n```js\nnpm create vite@latest\n```\n\n템플릿으로 react를 선택해주세요. 이렇게 하면 Vite.js로 관리되는 React 환경이 설정됩니다.\n\n생성된 Vite 프로젝트의 내용(node_modules, vite.config.js 및 package.json 제외)을 resources/js로 이동하세요.\n\n\n\n그럼 Laravel과 함께 작동하도록 vite.config.js를 업데이트해 보세요:\n\n```js\nimport { defineConfig } from 'vite';\nimport laravel from 'laravel-vite-plugin';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: 'resources/js/app.jsx',\n            refresh: true,\n        }),\n        react(),\n    ],\n});\n```\n\n그리고 React와 React DOM을 설치하세요:\n\n```js\nnpm install react react-dom\n```\n\n\n\n# 단계 5: 첫 번째 페이지 생성하기\n\nresources/js/Pages에 새 파일을 만들어 첫 번째 React 페이지를 만들어보세요 (이 디렉토리를 생성해야 할 수도 있습니다). 예를 들어, Welcome.js:\n\n```js\nimport React from 'react';\nimport { InertiaLink } from '@inertiajs/inertia-react';\n\nexport default function Welcome(props) {\n    return (\n        <div>\n            <h1>Welcome to Laravel Inertia React!</h1>\n            <InertiaLink href='/about'>About</InertiaLink>\n        </div>\n    );\n}\n```\n\n# 단계 6: 라우트 및 컨트롤러 업데이트하기\n\n\n\n로컬 Laravel routes(일반적으로 routes/web.php에서)에서 Inertia를 사용하여 React 컴포넌트를 렌더링하실 수 있습니다:\n\n```js\nuse Inertia\\Inertia;\n\nRoute::get('/', function () {\n    return Inertia::render('Welcome');\n});\n```\n\n# 단계 7: 자산 컴파일\n\n아래 명령어를 실행하여 자산을 컴파일하세요:\n\n\n\n```js\nnpm run dev\n```\n\n이제 Inertia.js와 React를 사용하여 Laravel 프로젝트를 성공적으로 설정했습니다. 이 스택은 Laravel의 강력함과 React의 견고함을 함께 활용하려는 개발자들에게 매끄러운 경험을 제공합니다.\n\n이 단계를 따라 Laravel, Inertia.js 및 React의 강점을 활용하여 동적이고 반응형 웹 애플리케이션을 만들 수 있습니다. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-HowLaravelwithInertiajsandReactSimplifiesSPADevelopment_0.png"},"coverImage":"/assets/img/2024-05-12-HowLaravelwithInertiajsandReactSimplifiesSPADevelopment_0.png","tag":["Tech"],"readingTime":5},{"title":"생존 여정 결의를 갖고 건강 위기 극복하기","description":"","date":"2024-05-12 22:28","slug":"2024-05-12-AJourneyofSurvivalOvercomingaHealthCrisiswithDetermination","content":"\n\n인생은 예상치 못한 도전을 우리 앞에 던지며, 우리의 탄력과 결의를 우리가 상상조차 못했던 방식으로 시험합니다. 나에게 이 여정은 내 존재의 근간을 뒤흔드는 갑작스러운 건강 위기로 시작되었습니다. 어느 보통의 날, 나는 경고하는 증상의 급격한 악화와 맞서야 하는 상황에 처해 있었습니다. 내 죽음의 현실과 직면하며, 나는 나와 알 수 없는 것 사이에 놓인 고혈압 약물을 찾아가는 순간적인 결정을 내렸습니다.\n\n![이미지](/assets/img/2024-05-12-AJourneyofSurvivalOvercomingaHealthCrisiswithDetermination_0.png)\n\n그 중대한 순간에, 약물의 쓴 맛이 입 안에 남아있는 동안, 나는 곧 벌어질 소용돌이에 대비했습니다. 시간이 흐를수록 상황의 긴급함이 더욱 명백해져, 의료 개입을 구하기 위한 시간 다툼 속으로 밀렸습니다. 병원으로 급속히 옮겨지면서 불확실성과 두려움으로 감싸인 나는 소멸되지 않는 반항적인 희망을 마음에 품었습니다. 주변을 에워싼 혼돈 속에서, 내가 혼자가 아님을 알게 되어 사랑하는 이들의 끝없는 지지와 의료 전문가들의 확고한 헌신으로 힘을 얻었습니다.\n\n![이미지](/assets/img/2024-05-12-AJourneyofSurvivalOvercomingaHealthCrisiswithDetermination_1.png)\n\n\n\n이어진 몇 일 동안, 나는 치유와 회복의 여정에 나섰습니다. 굳건한 결의로 재활의 격렬한 파도를 탐험하며 전진했습니다. 매일 새로운 도전과 극복해야 할 장애물이 있었지만, 작은 승리마다 점점 더 강해지면서 역경에 대한 내내 더 견고해졌습니다.\n\n그 힘든 경험을 되돌아보면, 삶의 선물과 내게 주어진 두 번째 기회에 대한 감사로 충만합니다. 이것은 우리 존재의 연약함과 이 지구에서 주어진 매 순간의 소중함을 상기시키는 것입니다. 이 생존 여정을 계속하면서, 새롭게 불탑의 의지와 감사를 느끼고, 각 날을 열정적인 결의로 받아들이며 삶의 기적에 깊은 감사를 표합니다. 어두운 순간들에서 우리는 진정한 힘과 회복력의 진정한 깊이를 발견하며, 그림자에서 새로운 목적감과 삶의 아름다움에 대한 깊은 감사를 느끼며 나타납니다.\n\n![Image](/assets/img/2024-05-12-AJourneyofSurvivalOvercomingaHealthCrisiswithDetermination_2.png)\n\n\"하나님은 언제나 좋으시다.\"","ogImage":{"url":"/assets/img/2024-05-12-AJourneyofSurvivalOvercomingaHealthCrisiswithDetermination_0.png"},"coverImage":"/assets/img/2024-05-12-AJourneyofSurvivalOvercomingaHealthCrisiswithDetermination_0.png","tag":["Tech"],"readingTime":2},{"title":"검색 기능을 최적화하자  React 입력 최적화","description":"","date":"2024-05-12 22:27","slug":"2024-05-12-DebounceyourSearchReactInputOptimization","content":"\n\n<img src=\"/assets/img/2024-05-12-DebounceyourSearchReactInputOptimization_0.png\" />\n\n디바운싱은 작업이 발생하는 횟수를 제한하는 최적화 기법입니다. React에서 검색 기능을 구현했을 때 사용자가 각 문자를 입력할 때마다 목록을 자동으로 필터링하거나 fetch 요청을 보내는 경우,이 기술은 응용 프로그램의 효율성을 크게 향상시킬 수 있는 기술입니다.\n\n# 설정 / 설치\n\n이 예제에서는 고유틸리티 라이브러리인 lodash에서 debounce 함수를 가져와 사용할 것입니다. 이를 위해 필터링 작업을 처리할 구성요소의 맨 위에 다음 코드 줄을 추가하면 됩니다.\n\n\n\n```js\nimport debounce from 'lodash.debounce';\n```\n\n다음으로는 사용 중인 것에 따라 npm 또는 yarn으로 종속성을 설치해야 합니다.\n\nnpm install lodash.debounce\n\n또는\n\n\n\nyarn add lodash.debounce\n\n# 예시 분석\n\n위의 CodeSandbox 예시에서 간단한 앱을 만들어 보았어요. 해당 앱은 과일 목록을 표시하고, 입력란에 텍스트를 입력할 때마다 목록이 필터링되는 기능을 가지고 있어요.\n\n입력란은 제어 폼(Controlled Form)이에요. 표시되는 값은 상태(state)에서 가져오며, 입력란은 onChange 이벤트를 통해 상태와 연결되어 있어요.\n\n\n\n```js\nconst [searchTerm, setSearchTerm] = useState(\"\");\n\nconst handleChange = (e) => {\n  setSearchTerm(e.target.value);\n};\n```\n\n```js\n<input type=\"text\" value={searchTerm} onChange={handleChange} />\n```\n\n사용자가 입력하는 문자마다 과일 목록이 필터링되고 사용자가 볼 수 있는 목록이 업데이트됩니다.\n\n```js\nlet listToDisplay = fruits;\nif (searchTerm !== \"\")\n  listToDisplay = fruits.filter((fruit) => {\n    return fruit.includes(searchTerm);\n  });\n}\n```  \n\n\n\n# 문제\n\n이 예시는 작동이 잘되지만, 목록의 크기가 커질수록 각 검색에 걸리는 시간이 길어질 것을 상상할 수 있습니다. 또 다른 시나리오는 각 문자열을 검색할 때마다 API 요청을 보내는 것일 수 있습니다. 어느 쪽이든, 이 구현은 애플리케이션을 느리게 만들 수 있고 이를 어떻게 해결해야 할지 고민에 빠질 수 있습니다. 여기서 debounce가 등장합니다.\n\n# Debounce\n\n```js\n_.debounce(func, [wait=0], [options={}])\n```\n\n\n\n디바운스가 3개의 인수를 사용하지만, 우리는 첫 두 인수를 사용할 것입니다. 실행하고 싶은 함수와 기다리고 있는 시간입니다.\n\n또한 나중에 정리에 도움이 되는 debounce에 내장된 .cancel 함수도 사용할 것입니다.\n\n디바운스 함수에 대한 더 많은 정보는 공식 설명서를 참조해주세요.\n\n# 구현\n\n\n\n첫 번째 단계는 useMemo을 사용하여 debounce 함수에서 반환 값을 메모이즈하는 작업입니다. 이 반환된 값은 다시 렌더링 사이에 유지됩니다. 이 단계는 필수적입니다. 왜냐하면 이 데이터를 다시 렌더링 사이에서 지속하지 않으면 debounce의 다른 구현이 모든 다시 렌더링마다 발생하게 되고, 본질적으로 우리의 초기 예제를 가지고 있는 셈이 됩니다. 즉, 마지막 문자 입력 후 일정 시간이 지난 후에 한 문자씩 목록을 필터링하는 상태가 될 것입니다.\n\n```js\nconst debouncedResults = useMemo(() => {\n  return debouce(handleChange, 300);\n}, []);\n```\n\n다음으로 useEffect를 사용하여 컴포넌트가 언마운트될 때 debounce에서 발생하는 부작용을 정리할 것입니다. 더 이상 해당 페이지나 뷰에 나 있지 않을 때는 검색을 실행할 이유가 없습니다. 여기서는 메모이즈된 반환 값을 사용하여 .cancel 함수를 호출할 것입니다.\n\n```js\nuseEffect(() => {\n  return () => {\n    debouncedResults.cancel();\n  };\n});\n```\n\n\n\n마침내 이전 작업 중 일부를 취소할 차례입니다. `value` 속성을 삭제하여 폼을 비제어 상태로 만들고 `onChange`를 `debouncedResults`를 호출하도록 설정합니다. 이렇게 하면 입력이 변경될 때마다 폼이 디바운스되도록 할 수 있습니다.\n\n```js\n<input type=\"text\" onChange={debouncedResults} />\n```\n\n그리고 이렇게 완료되었습니다. 디바운싱이 적용된 입력 상자가 완성되었습니다!\n\n# 작업 예시","ogImage":{"url":"/assets/img/2024-05-12-DebounceyourSearchReactInputOptimization_0.png"},"coverImage":"/assets/img/2024-05-12-DebounceyourSearchReactInputOptimization_0.png","tag":["Tech"],"readingTime":3}],"page":"129","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}