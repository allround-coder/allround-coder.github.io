{"pageProps":{"posts":[{"title":"리플렛js와 리액트로 시작하기 간단한 지도 렌더링하기","description":"","date":"2024-05-12 19:34","slug":"2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap","content":"\n\n![Leaflet.js와 React를 사용하여 간단한 지도 렌더링 시작하기](/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png)\n\n# 소개\n\n이 시리즈에서는 강력한 오픈 소스 JavaScript 라이브러리인 Leaflet.js를 활용하여 React, HTML 및 CSS로 Google 지도 대안으로 상호 작용하는 지도를 생성하는 방법을 살펴볼 것입니다. 주니어 또는 중급 개발자라면 Leaflet.js 사용 방법을 이해함으로써 위치 데이터를 표시하고 사용자 정의 맵 기반 애플리케이션을 쉽게 구축할 수 있습니다. 이 첫 번째 글에서는 개발 환경을 설정하고 기본적인 지도를 렌더링하는 것부터 시작하겠습니다.\n\n이후의 글에서는 대화식 맵핑의 세계로 더욱 깊이 파고들어, 마커 추가, 부드러운 확대 기능 활성화, 클릭 이벤트 처리, 외부 데이터 작업 및 다각형 및 팝업 사용자 정의 등의 주제를 다룰 것입니다.\n\n\n\n이 튜토리얼과 더 나아가기 위해 다음 도구들을 활용할 것입니다:\n\n- Leaflet\n인터랙티브 지도를 생성하는 JavaScript 라이브러리\n- React\n사용자 인터페이스를 구축하는 JavaScript 라이브러리\n- React-Leaflet\nLeaflet 지도용 React 컴포넌트들\n\n# Leaflet은 무엇인가요?\n\nLeaflet.js는 오픈 소스이며 가벼운 JavaScript 라이브러리로, 웹을 위한 인터랙티브 지도를 손쉽게 만들 수 있습니다.\n\n\n\n약 38,000개의 스타를 보유한 Leaflet.js는 휴대폰 친화적 대화형 지도를 위한 주요 오픈 소스 JavaScript 라이브러리 중 하나입니다.\n\n만약 \"Leaflet\"이라는 이름의 유래에 대해 궁금하다면, 이것은 단편적이고, 표시하고, 지도를 손쉽게 탐색할 수 있도록 도와주는 편리한 도구로 생각해보세요 - 마치 바람에 흩날리는 나뭇잎처럼 손쉽게 움직일 수 있습니다.\n\nLeaflet을 선택하는 이유는?\n\n- 가볍고 빠름: 개발자들이 Leaflet을 좋아하는 주요 이유 중 하나는 가벼운 무게에 있습니다 - 약 42KB의 무게를 상하. 웹 페이지가 무거운 스크립트에 늘어지지 않도록 보장하여 부드럽고 신속한 사용자 경험을 제공합니다.\n- 사용자 친화적이고 직관적: Leaflet의 API는 명쾌하고 직관적이어서 모든 수준의 개발자에게 완벽히 적합합니다. 경험이 풍부한 전문가든 막 시작한 초심자든 쉽게 이해하고 구현할 수 있을 것입니다.\n- 사용자 정의 가능 및 다재다능: Leaflet은 가볍지만 강력한 기능을 제공합니다! 당신의 특정 요구에 맞게 지도를 맞춤화하기 위해 원활하게 통합할 수 있는 다양한 플러그인과 확장기능을 제공합니다. 마커 및 폴리곤 표시부터 상호작용 처리까지, 가능성은 거의 무한합니다.\n- 크로스 플랫폼 호환성: Leaflet으로 생성한 지도는 다양한 플랫폼과 장치에서 어려움 없이 볼 수 있습니다. 사용자가 데스크톱, 스마트폰 또는 태블릿에서 애플리케이션을 접근하더라도, 지도는 아름답게 작동할 것입니다.\n- 활발한 커뮤니티 및 지속적인 개발: 열정적이고 활발한 개발자 및 기여자들의 커뮤니티로 Leaflet은 계속 발전하고 개선되고 있습니다. 업데이트, 버그 수정 및 흥미로운 새로운 기능이 정기적으로 출시되어 당신이 최신의 지도 기술을 선도하도록 보장합니다.\n\n\n\n리플렛은 웹 페이지에서 지도를 렌더링하기 위해 HTML, CSS, 및 JavaScript를 조합하여 사용합니다. 최신 브라우저의 강력한 기능을 활용하며 OpenStreetMap, Mapbox 및 기타 인기 있는 맵 제공업체를 활용하여 다양한 스타일과 데이터 오버레이를 가진 지도를 표시할 수 있습니다.\n\n재미있는 사실: 리플렛의 \"잎\" 로고!\n\n리플렛의 재미있는 잎 로고를 본 적이 있을 지도 모릅니다. 귀여운 외양 뿐만 아니라 라이브러리의 가벼운 특성을 상징합니다. 마치 단 한 잎이 바람에 가볍게 나부끼는 것처럼, 리플렛의 최소주의 디자인은 사용자에게 부드럽고 빠른 지도 상호작용을 제공합니다.\n\n\n\n이제 Leaflet.js의 마법을 소개했으니, 소마건을 걸고 React와 함께 재미있는 상호작용 맵핑의 흥미진진한 세계에 뛰어들어 봅시다. 함께 멋진 지도 애플리케이션을 만들어 사용자에게 오랫동안 기억에 남는 경험을 선사하며 이 학습 여정을 즐겨봅시다!\n\n멋진 모험을 지도에 표현할 준비가 되셨나요? 시작해 봅시다!\n\n그런데..\n\nReact로 들어가기 전에, 일반적인 html, css 및 js를 통해 Leaflet의 기본을 이해해 봅시다. 이를 위해 Leaflet 지도를 설정하고, 마커 및 팝업을 사용하는 간단한 예제를 만들 것입니다.\n\n\n\n# Leaflet 라이브러리로 단순한 HTML, CSS 및 JS 예제 만들기\n\n이 섹션에서는 Leaflet.js 라이브러리를 포함한 간단한 HTML 페이지를 만들고, 기본 지도를 렌더링하고 마커 및 팝업을 추가하는 방법을 보여줄 것입니다.\n\n단계 1: HTML 구조 설정\n\n좋아하는 텍스트 편집기를 열고 새 HTML 파일(예: index.html)을 만들고 기본 구조를 설정하세요:\n\n\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>간단한 Leaflet 지도</title>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\" />\n  <style>\n    /* 지도 컨테이너 크기 설정 */\n    #map {\n      height: 400px;\n      width: 100%;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"map\"></div>\n  <script src=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\"></script>\n  <script src=\"app.js\"></script>\n</body>\n</html>\n```\n\nStep 2: JavaScript 파일 생성 (app.js)\n\n다음으로, HTML 파일과 동일한 디렉토리에 'app.js'라는 새 JavaScript 파일을 만듭니다. 여기에 지도를 렌더링하고 마커 및 팝업을 추가하는 코드를 작성할 것입니다.\n\n```js\n// 문서가 준비되기를 기다립니다.\ndocument.addEventListener('DOMContentLoaded', function () {\n  // 맵 인스턴스를 생성하고 초기 뷰 좌표 및 확대 수준을 설정합니다.\n  var map = L.map('map').setView([51.505, -0.09], 13);\n\n  // OpenStreetMap으로부터 지도에 타일 레이어 추가\n  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n  }).addTo(map);\n\n  // 팝업이 있는 마커를 생성하고 지도에 추가합니다.\n  var marker = L.marker([51.505, -0.09]).addTo(map);\n  marker.bindPopup(\"안녕하세요, 저는 마커입니다!\").openPopup();\n});\n```\n\n| Name      | Age | Location |\n|-----------|-----|----------|\n| John      | 25  | New York |\n| Emily     | 28  | Paris    |\n| Matthew   | 23  | London   |\n\n\n지도 만들기 및 타일 레이어 추가하기\n\n```js\n// 지도 인스턴스 생성 및 초기 보기 좌표 및 확대 수준 설정\nvar map = L.map('map').setView([51.505, -0.09], 13);\n```\n\n여기서 `L.map()` 메서드를 사용하여 새 지도 인스턴스를 생성하고 우리의 지도가 렌더링될 `div` 요소의 ID를 전달했습니다.\n\n`setView()` 메서드는 맵의 초기 보기를 지정한 위도(51.505) 및 경도(-0.09)와 확대 수준 13으로 설정합니다. 확대 수준이 높을수록 지도가 더 가깝게 표시됩니다.\n\n\n\n```js\n// 지도에 OpenStreetMap에서 타일 레이어 추가\nL.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\nattribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n}).addTo(map);\n타일 레이어의 attribution 옵션은 OpenStreetMap 기여자들에게 크레딧을 주기 위해 사용됩니다. 제3자 소스에서 지도 데이터를 사용할 때 적절한 소유권을 제공하는 것이 중요합니다.\n```\n\n위 코드에서 L.tileLayer() 메서드를 사용하여 타일 레이어를 생성했습니다.\n\n타일 레이어는 지도의 시각적 표현을 구성하는 이미지 타일 세트입니다. 이 예에서는 https://'s'.tile.openstreetmap.org/'z'/'x'/'y'.png로 제공되는 OpenStreetMap 타일 레이어를 사용하고 있습니다. 's', 'z', 'x', 'y'는 서브도메인, 줌 레벨 및 타일 좌표를 나타내는 자리 표시자입니다. Leaflet은 자동으로 이러한 자리 표시자를 교체하여 지도를 이동하고 확대/축소할 때 올바른 타일을 로드합니다.\n\n타일 레이어의 attribution 옵션은 OpenStreetMap 기여자들에게 크레딧을 주기 위해 사용됩니다. 제3자 소스에서 지도 데이터를 사용할 때 적절한 소유권을 제공하는 것이 중요합니다.\n\n\n\n팝업이 달린 마커 추가하기\n\n```js\n// 팝업이 달린 마커를 생성하고 맵에 추가하기\nvar marker = L.marker([51.505, -0.09]).addTo(map);\nmarker.bindPopup(\"안녕하세요, 저는 마커입니다!\").openPopup();\n```\n\n맵에 마커를 추가하려면 L.marker() 메소드를 사용하고 위도와 경도를 배열 [51.505, -0.09]로 전달합니다. 이로 인해 마커가 맵의 해당 위치에 배치됩니다.\n\n그런 다음 bindPopup() 메소드를 사용하여 마커에 팝업을 추가합니다. 팝업 내용은 \"안녕하세요, 저는 마커입니다!\" 라는 문자열입니다. 그리고 openPopup() 메소드를 사용하여 팝업을 마커가 맵에 추가된 직후에 바로 표시합니다.\n\n\n\n다른 타일 레이어 사용하기\n\nLeaflet은 지도의 외관과 스타일을 변경할 수 있는 다양한 타일 레이어를 제공합니다. OpenStreetMap 이외에도 Mapbox, Stamen, Esri 등 다른 제공 업체를 사용할 수 있습니다.\n\nMapbox 타일 레이어를 사용하는 예시입니다:\n\n```js\n// Mapbox 타일 레이어 사용하기\nL.tileLayer('https://{s}.tiles.mapbox.com/v4/{mapId}/{z}/{x}/{y}.png?access_token={accessToken}', {\n  attribution: '© <a href=\"https://www.mapbox.com/about/maps/\">Mapbox</a>',\n  mapId: 'your-mapbox-map-id', // 여러분의 Mapbox 맵 ID로 대체해주세요\n  accessToken: 'your-mapbox-access-token' // 여러분의 Mapbox 액세스 토큰으로 대체해주세요\n}).addTo(map);\n```\n\n\n\nMapbox 타일 레이어를 사용하려면 Mapbox 계정에 가입하고 액세스 토큰과 맵 ID를 획득해야 합니다. 'your-mapbox-map-id'와 'your-mapbox-access-token'을 실제 Mapbox 자격 증명으로 대체해주세요.\n\n# React-Leaflet\n\n이제 Leaflet과 순수 JavaScript를 사용하여 지도를 생성하고 마커를 추가하는 방법을 알게 되었습니다. React를 사용하여 동일한 결과를 어떻게 얻을 수 있는지 알아봅시다.\n\n필수 전제 조건\n\n\n\n리액트 구현에 들어가기 전에 컴퓨터에 다음이 설치되어 있는지 확인하세요:\n\n- Node.js (최신 LTS 버전) 및 npm (Node Package Manager)\n- 선호하는 코드 편집기 (예: Visual Studio Code, Sublime Text, 또는 Atom)\n\n개발 환경 설정하기\n\n먼저 터미널이나 명령 프롬프트를 열고 다음 단계를 따르세요:\n\n\n\n- Create React App을 사용하여 새로운 React 프로젝트를 만들어보세요:\n\n\nnpx create-react-app leaflet-map-app\n\ncd leaflet-map-app\n\n\n2. 필요한 종속성을 설치하세요:\n\n\n\nnpm install leaflet\n\nnpm install react-leaflet\n\n3. 이제 코드 편집기에서 프로젝트를 엽니다.\n\n간단한 지도 컴포넌트 생성\n\n\n\n프로젝트의 'src' 폴더에 'SimpleMap.js'라는 새 파일을 만들어 주세요. 이 파일은 맵을 렌더링하는 주요 리액트 컴포넌트가 될 거에요.\n\n맵 설정하기\n\nSimpleMap.js 안에서 필요한 모듈을 먼저 import 하는 것으로 시작해요:\n\n```js\nimport React, { useRef } from \"react\";\nimport { MapContainer, TileLayer } from \"react-leaflet\";\nimport \"leaflet/dist/leaflet.css\";\n```\n\n\n\n지도 렌더링하기\n\n이제 SimpleMap 컴포넌트를 구현하고 지도를 렌더링합시다:\n\n```js\nconst SimpleMap = () => {\n  const mapRef = useRef(null);\n  const latitude = 51.505;\n  const longitude = -0.09;\n\n  return ( \n    // 지도 컨테이너의 높이와 너비를 설정해야지만 지도가 표시됩니다.\n      <MapContainer center={[latitude, longitude]} zoom={13} ref={mapRef} style={{height: \"100vh\", width: \"100vw\"}}>\n        <TileLayer\n          attribution='&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n          url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        />\n        {/* 추가 지도 레이어나 컴포넌트를 이곳에 추가할 수 있습니다 */}\n      </MapContainer>\n  );\n};\n\nexport default SimpleMap;\n```\n\n중요 사항!\n\n\n\n\nMapContainer center='[위도, 경도]' zoom='13' ref='mapRef' style='높이: \"100vh\", 너비: \"100vw\"'\n\nMapContainer의 높이와 너비를 설정하지 않으면 지도가 렌더링되지 않습니다.\n\nmapRef 사용 이유:\n\nuseRef로 mapRef를 사용하면 React-Leaflet이 관리하는 Leaflet 지도 인스턴스에 직접 액세스할 수 있습니다. 이는 표준 속성이나 이벤트 처리의 범위를 벗어나야 하는 작업을 수행해야 할 때 특히 유용합니다. 예를 들어 지도와 상호 작용하거나 지도의 중심을 동적으로 업데이트하거나 Leaflet의 기본 API에 직접 액세스해야 할 수 있습니다.\n\n\n\n\nmapRef을 사용하면 맵 인스턴스를 더 많은 제어력과 유연성을 가질 수 있어요. 이는 응용 프로그램에서 더 고급 맵 기능이나 상호 작용을 구현할 때 유용해요.\n\n다음 기사에서 더 자세히 살펴보겠습니다.\n\nMapContainer 구성 요소\n\nMapContainer는 첫 번째 예제와 같이 맵을 위한 `div` 요소 컨테이너를 렌더링합니다.\n\n\n\nMapContainer이 DOM에 렌더링되는 방법:\n\nJSX 코드에 MapContainer 컴포넌트를 포함하면, 다른 React 컴포넌트와 마찬가지로 DOM에 렌더링됩니다. 그러나 MapContainer와 일반 HTML 요소 사이에 중요한 차이가 있습니다:\n\nReact-Leaflet은 내부적으로 Leaflet의 코어 라이브러리를 사용하여 DOM을 직접 조작하여 지도를 렌더링합니다. MapContainer 컴포넌트가 DOM에 렌더링되면, 지정된 높이와 너비로 `div` 요소가 생성되는데, 이는 지도의 컨테이너 역할을 합니다.\n\n초기 렌더링 후에 React가 가상 DOM의 변경 사항을 조정할 때, Leaflet의 코어 라이브러리가 제어를 가져와 맵의 모양과 업데이트를 효율적으로 관리하면서 React 컴포넌트를 전체 재렌더링시키지 않습니다. 이 접근 방식은 상호작용 형식의 맵을 다룰 때 빈번한 업데이트가 필요한 경우에 최적의 성능을 보장합니다.\n\n\n\n모든 것을 함께 적용하기\n\nApp.js 파일에서 SimpleMap 컴포넌트를 import하여 주요 응용 프로그램에서 사용합니다:\n\n```js\nimport React from 'react';\nimport SimpleMap from './SimpleMap';\n\nfunction App() {\n  return (\n    <div>\n      <h1>내 Leaflet.js 및 React 지도</h1>\n      <SimpleMap />\n    </div>\n  );\n}\nexport default App;\n```\n\n프로젝트 디렉토리에서 npm install을 실행하여 필요한 패키지를 설치해야 합니다. 모든 것이 설정되면 npm start로 개발 서버를 실행하고 브라우저에서 http://localhost:3000을 방문하여 지도를 확인할 수 있습니다.\n\n\n\n아래는 Markdown 형식으로 테이블을 변경한 결과입니다.\n\n\n<img src=\"/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_2.png\" />\n\n# React-Leaflet의 한계\n\nReact-Leaflet은 상호작용적 지도를 만드는 데 훌륭한 도구이지만 몇 가지 재미있는 한계가 있습니다.\n\n\n\n\nLeaflet은 로드될 때 DOM에 직접 호출을 하기 때문에 React Leaflet은 서버 측 렌더링과 호환되지 않습니다.\n\n노출된 구성 요소는 Leaflet 레이어의 추상화이며 DOM 요소가 아닙니다. 일부 구성 요소는 Leaflet에서 노출된 세터를 호출하여 직접 업데이트할 수 있는 프로퍼티를 가지고 있으며, 다른 구성 요소는 key 프로퍼티에 고유한 값이 설정되어 React의 알고리즘이 정확히 처리할 수 있도록 완전히 대체되어야 합니다.\n\n이러한 도전을 극복하기 위해 개발자들은 다양한 접근 방식을 사용해 왔습니다. 예를 들어:\n\n- 조건부 렌더링: 일반적인 접근 방식 중 하나는 Leaflet 구성 요소를 클라이언트 측에서만 조건부로 렌더링하는 것입니다. 동적 임포트 또는 useEffect 훅과 같은 기술을 사용하여 초기 렌더링 후 클라이언트에서만 실행되도록 보장합니다.\n- Leaflet-Headless: 일부 개발자들은 Leaflet의 headless 버전인 \"leaflet-headless\"와 같이 Leaflet의 headless 버전을 만들어 왔습니다. 이를 통해 DOM 없이 서버에서 Leaflet 지도를 렌더링할 수 있습니다. 그러나 이러한 해결책은 제한 사항을 가질 수 있으며 Leaflet의 모든 기능을 제공하지 않을 수도 있습니다.\n\n\n\nNext.js에서 조건부 렌더링의 예 및 간단한 해결책입니다:\n\n```js\nimport dynamic from 'next/dynamic'\n\nfunction HomePage() {\n  const Map = dynamic(\n    () => import('@components/map'), // 컴포넌트 위치인 '@components/map'을 교체해주세요\n    { \n      loading: () => <p>지도를 불러오는 중입니다</p>,\n      ssr: false // 이 줄이 중요합니다. 서버 측 렌더링을 막습니다\n    }\n  )\n  return <Map />\n}\n\nexport default HomePage\n```\n\n# 공식 문서 자세히 살펴보기\n\n더 많은 고급 사용 사례를 탐색하거나 React-Leaflet 컴포넌트의 속성과 기능에 대해 더 깊이 파고들고 싶다면, 공식 문서를 참조해보세요! 이 문서에는 Leaflet을 React 애플리케이션 내에서 최대한 활용할 수 있도록 가능한 모든 컴포넌트, 옵션, 특징에 대한 포괄적인 정보가 제공되어 있습니다.\n\n\n\n문서 링크: React-Leaflet 공식 문서\n\n# GitHub에서 코드 살펴보기\n\n코드를 탐험하고 지도 뒤에 숨겨진 마법을 확인하고 싶다면, 이 기사 시리즈의 전체 소스 코드가 GitHub에서 사용 가능합니다! 🚀🔍\n\nGitHub에서 코드를 확인해보세요\n\n\n\n자유롭게 살펴보고 실험하며 예제를 활용해보세요. 코딩 즐기세요! 🌟🖥️\n\n# 결론\n\n이 시리즈의 첫 번째 기사를 완료한 것을 축하합니다! 저는 개발자 기사를 쓰고 지식을 공유하는 이 여정에 기쁨을 느낍니다. Leaflet.js와 React를 함께 사용하면 쉽게 대화형 지도를 생성할 수 있어 구글 맵에 대한 무료이면서 강력한 대안을 제공합니다.\n\n다음 기사에서는 지도에 마커 추가 및 부드러운 확대 기능을 가능하게 함으로써 대화형 매핑의 세계로 더 깊이 들어갈 것입니다. 함께 하면 주니어 및 중급 개발자가 지도 시각화 기술을 마스터하기 위해 가치 있는 풍부한 애플리케이션을 만들 수 있을 것입니다.\n\n\n\n우리가 다룰 다가오는 주제들에 대해 정말 기대돼요. 여러분들도 마찬가지겠죠? 이 시리즈를 통해, 개발자들이 새로운 기술을 탐험하고 창의력을 발휘하여 멋진 애플리케이션을 만들도록 돕고 영감을 주는 것이 제 목표입니다.\n\n이 여정에 함께해 주셔서 감사드리고, 다음 시리즈를 여러분과 함께 나누는 것을 기대할 뿐입니다. 즐겁게 코딩하시고, 다음에 뵙겠습니다!","ogImage":{"url":"/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png"},"coverImage":"/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png","tag":["Tech"],"readingTime":12},{"title":"Reactforce를 사용하는 것이 좋은 아이디어라고 생각하는 ChatGPT세요","description":"","date":"2024-05-12 19:32","slug":"2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea","content":"\n\n다음 글은 ChatGPT가 쓴 것입니다:\n\n![image](/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png)\n\n나: \"salesforce.com에 웹사이트를 배포하는 데 React를 사용하는 장점에 관한 글을 써 주세요.\"\n\nChatGPT:\n\n\n\n# Salesforce에서 웹 배포를 향상시키기 위한 React 활용: IT 임원을 위한 안내서\n\n## EXECUTIVE SUMMARY\n\n기업 기술 분야의 경쟁적 환경에서 IT 임원들은 지속적으로 효율성과 혁신을 향상시키는 전략을 모색하고 있습니다. Salesforce.com과 React를 통합함으로써 복잡한 비즈니스 요구에 부합하는 강력하고 확장 가능한 웹사이트를 배포하는 혁신적인 방법론을 제시합니다. 본 기사는 Salesforce에서 웹 배포를 위해 React를 활용하는 전략적 이점에 대해 다루며 비즈니스 영향과 관리적 통찰을 강조합니다.\n\n## 전략적 개발 장점\n\n\n\n1. 구성 요소 중심의 효율성: React의 구성 요소 기반 구조는 재사용 가능한 코드를 촉진하여 개발 시간과 비용을 줄이며 Salesforce 애플리케이션 전체에서 일관성을 보장합니다. 이 모듈식 접근 방식은 기민한 개발 방법을 용이하게 하여 IT 팀이 비즈니스 요구 사항의 변화에 신속히 대응할 수 있도록 합니다.\n\n2. 간소화된 개발 및 유지 관리: JSX를 활용하여 코딩하는 것은 개발 프로세스를 단순화하여 컨셉에서 배포까지 걸리는 시간을 크게 줄입니다. React의 아키텍처는 미래 업데이트와 유지 보수를 간소화하기도 하며, 비즈니스 영향을 최소화하면서 장기적 기업 애플리케이션을 유지하는 데 중요한 역할을 합니다.\n\n## 사용자 참여 및 성능 향상\n\n3. 고성능 웹사이트: React의 가상 DOM은 웹사이트 성능을 최적화하여 기업 환경에서 일반적인 대규모 데이터셋을 처리하는 데 중요합니다. 이는 더 빠르고 반응적인 웹 애플리케이션을 통해 사용자 만족도와 참여도를 향상시킵니다.\n\n\n\n4. Salesforce Lightning과의 원활한 통합: React를 Salesforce Lightning과 조율함으로써 기관은 생산성과 사용자 도입을 향상시키는 통합 사용자 경험을 누릴 수 있습니다. 이 조합은 비즈니스 사용자를 위한 강력한 인터페이스를 제공하며 Salesforce의 강력한 백엔드 기능을 React의 동적 프론트엔드 기능과 결합합니다.\n\n## 확장성 및 기업 성장\n\n5. 확장 가능한 솔루션: React의 유연성은 비증분 솔루션을 지원하여 비즈니스와 함께 성장할 수 있습니다. 기능을 확장하거나 새로운 서비스를 통합하거나 더 많은 사용자를 수용하기 위해 확장하는 경우, React를 Salesforce와 결합함으로써 웹 인프라가 효율적으로 적응할 수 있도록 보장합니다.\n\n6. 커뮤니티 및 혁신: React의 광범위한 개발자 커뮤니티와 풍부한 생태계를 활용하면 Salesforce 배치에 첨단 혁신을 가져올 수 있습니다. 이러한 다양한 도구 및 라이브러리에 접근하는 것은 개발을 가속화하고 기업의 과제에 첨단 솔루션을 제공할 수 있습니다.\n\n\n\n## 결론\n\n디지털 생태계 내에서 가능한 경계를 넓히려는 IT 임원들에게는 Salesforce 웹사이트 배포를 위해 React를 도입하는 것이 전략적 이점을 제공합니다. 이 조합은 개발을 간소화하고 사용자 경험을 향상시키는 데에 그치지 않고 비즈니스 성장 및 적응성 목표와도 일치합니다. React를 받아들임으로써 기업은 비즈니스 성공을 이끄는 더 매력적이고 성능이 우수하며 확장 가능한 웹 솔루션을 만들 수 있습니다.\n\n## 행동 요령\n\n조직의 웹 전략에 대한 다음 단계를 고려할 때, Salesforce와 React 통합의 잠재적인 영향을 곰곰히 생각해보세요. 이 기술을 귀사의 특정 비즈니스 요구에 맞게 맞춤화하는 방법에 대해 깊이 있게 탐구하려면 귀사의 기업 맥락에 맞춘 통찰력과 실행 전략을 제공할 수 있는 전문가와 상담을 고려해 보세요.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n\n\n## 전략적 개발 장점 (내 생각)\n\n나는 React의 컴포넌트 프레임워크와 미리 만들어진 컴포넌트의 오픈 소스 제공이 Lightning의 동일한 개념보다 훨씬 선두라고 제안할 것입니다. 차이를 알기 위해 둘 다 배워야 하지만... 그저 요약하자면: React = Best\n\n또한 React 개발 과정이 극적으로 더 나은 것에 동의합니다. 당사의 Reactforce 솔루션에는 여기에 약간의 비밀 소스가 있습니다.... 개발에서 Hot Reloading을 지원하고 Salesforce 환경에 오프라인 프록시 액세스도 지원합니다. 이는 개발 워크스테이션에서 로컬로 실행되는 React 서버에서 Salesforce 스크래치 조직(또는 샌드박스)에서 라이브 데이터를 사용하여 React 앱을 구축할 수 있다는 것을 의미합니다. 이것은 React 및 Salesforce 개발자들에게 자랑스럽게 보여주는 소프트웨어 마술입니다.\n\n위 기사에서 ChatGPT가 실제로 이해하지 못하는 것은 React 사이트를 네이티브 Salesforce.com 조직에 배포함으로써, 데이터의 다수 복사본을 관리하기 위해 필요한 모든 데이터 통합, 변환 및 지속적인 지원을 우회하고 있다는 점입니다. React는 JavaScript remoting 또는 LWC 컨트롤러를 통해 Salesforce에 직접적으로 대화하며, 데이터웨어하우스나 운영 데이터 저장소로 미들웨어를 통해 고통스럽게 연결된 중요한 데이터뿐만 아니라 Salesforce 데이터 중 어떤 것이든지 솔루션을 구축하는 놀라운 속도와 유연성을 제공합니다.\n\n\n\n## 사용자 참여 및 성능 향상 (내 생각)\n\nReact에 익숙하지 않다면, 대부분의 사람들이 사용한다는 것만 말씀드립니다. 마이크로소프트 팀즈는 React로 작성되었습니다. Netflix와 지라도 마찬가지입니다. 끝이 없이 많이 있습니다. React로 작성된 웹사이트를 언제든지 표시해주는 크롬 확장 프로그램을 설치할 수 있습니다. 제가 직접 수행한 완전히 비과학적인 연구에 의하면, 가장 빠르고 시각적으로 매력적이며 반응성 있는 사이트 대부분은 대부분 React를 사용하고 있습니다.\n\nReact는 Salesforce Lightning과 비교할 수조차 없습니다. React는 단일 페이지 애플리케이션으로, 전체 사이트가 처음 로드될 때 브라우저로 다운로드됩니다. 애플리케이션은 브라우저로 푼다음 Salesforce (또는 원하는 데이터 소스)로 API 호출을 수행합니다. 단일 페이지 애플리케이션 (SPA)의 최종 결과는 브라우저가 거의 다시로드하지 않고 전체 사이트가 잘 만들어진 iOS 앱처럼 느껴진다는 것입니다. 웹 개발 세계에서 오신 분이라면 이것이 상당히 명백한 사실일 것입니다. Salesforce에서 오신 분이라면... 무엇을 놓치고 있는지 꼭 확인해보세요.\n\nReactforce에는 Salesforce 내부에서는 물론 Classic 또는 Lightning 경험 내에서도 절대적으로 매끈하게 작동하는 React의 비밀 소스가 있습니다. 더 나아가 전체 응용 프로그램을 완전히 렌더링하는 경우(예: 디지털 커뮤니티 경험)에 사용할 때 더욱 우수한 결과를 얻을 수 있습니다. 우리는 React를 사용하여 Salesforce.com에서 네이티브로 호스팅되는 금융 서비스 및 의료 포털을 구축하는 전문가입니다. 대안솔루션과의 차이는 즉시 눈에 띄며, 전체 솔루션에 대해 배울수록 혜택만 커집니다.\n\n\n\n## 확장성 및 기업 성장 (내 생각)\n\nSalesforce에서 실행 중인 React의 확장성에는 몇 가지 기술적 고려 사항이 있습니다. 먼저, React 앱이 페이지 레이아웃에서 내부적으로 실행되는지 아니면 외부적으로 커뮤니티에서 실행되는지에 따라 솔루션이 변경됩니다. 내부에서 실행할 때는 Javascript 리모팅을 사용하여 API 호출을 완전히 우회할 수 있습니다. 이것은 React에서 데이터베이스로 무제한 API 호출을 할 수 있다는 것을 의미합니다. React 앱을 내부적으로 렌더링하고 이 능력을 활용하기 위해 원격 메서드나 라이트닝 컨트롤러를 사용해야합니다.\n\n커뮤니티에서 React 앱을 외부에서 렌더링하는 경우에도 페이지 뷰(원격 메서드 및 Ajax 호출이 페이지 뷰로 계산됨)에 주의해야합니다. 우리는 규모에 맞게 외부 API 호출에 React를 사용하는 것이 비용 효율적인 대안임을 발견했습니다. Salesforce에서 필요한 API 호출을 구매하고, 예전에 고민했던 대부분의 확장성 문제에 대해서는 더 이상 생각하지 않아도 됩니다.\n\n기업은 React를 열렬히 환영할 것입니다. React 앱은 자가 포함되어 배포될 수 있으며 배포된 Salesforce 환경의 모든 보안 규칙을 존중합니다. 이는 혁신적인 창작물을 매우 빠르게 반복할 수 있음을 의미합니다. 또는 Reactforce Enterprise Portal(현재 베타)을 사용하여 회사 인트라넷 또는 익스트라넷을 철저한 솔루션으로 구성할 수 있습니다. 이 솔루션에는 완전히 사용자 정의 가능한 사용자 관리, 고급 경로 구성, 다양한 사이트 테마도 포함되어 있습니다. 마치 당신의 포털을 위한 포털 같아요. 이 애플리케이션에 대해 자랑스럽다고 생각하며, 몇 달 내에 일반 사용자에게 제공될 것으로 기대합니다.\n\n\n\n## 챗지피티(ChatGPT)가 아직은 이해하지 못하는 것들\n\nUI 계층으로 React를 채택하면 CRM 생태계에서 아직은 이해되지 않는 성숙함과 세련됨의 수준을 조직에 제공합니다. 이는 귀하의 직원, 파트너, 그리고 고객들에게 실제로 사용하고 싶어하는 UI 경험을 제공합니다.\n\n웹사이트의 백엔드로 Salesforce를 활용하면 견고하고 확장 가능하며 거의 제로 서포트 솔루션을 제공받을 수 있습니다. Salesforce의 놀라운 데이터베이스와 기업 보안 솔루션에 액세스할 수 있습니다. 귀하의 애플리케이션은 CIO들과 세계 각지의 아키텍트들이 사랑하고 존경하는 안전하고 견고한 인프라에 배포되면서 즉시 귀하의 고객들과 프로젝트 이해관계자들에게 감명을 줄 것입니다.\n\n## 내 인간적 요약\n\n\n\n재밌는 이유가 많아요! Salesforce에서 React를 사용해보는 것을 고려해볼 가치가 충분해요. 사실 저는(15년 경험의 Salesforce.com 및 AWS 전문 기술 아키텍트) 그냥 말하는 게 아니에요. ChatGPT도 이 솔루션이 얼마나 멋진지 아는 것 같아요. 더 많은 정보를 원한다면 직접 이메일 보내주세요: greg@cloudpremise.com.\n\n해피 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png"},"coverImage":"/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 컴파일러 무엇인가요 그리고 프론트엔드 개발에 어떻게 영향을 미칠까요","description":"","date":"2024-05-12 19:30","slug":"2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment","content":"\n\nReact 18가 이미 2년 이상 지난 후에, 이제는 React 19를 환영할 때가 왔습니다. 우리가 모두 사랑하는 주요 혁신은 React 컴파일러입니다! 이는 수동 메모이제이션 최적화가 필요 없어져서 프론트엔드 개발을 영원히 간단히 해 줄 것을 약속합니다.\n\n이 안내서에서는 React 컴파일러가 무엇인지, 어떻게 작동하는지, 어떤 이점을 제공하는지, 그리고 응용 프로그램을 준비하는 방법에 대해 이해하게 될 것입니다.\n\n# React 19가 가져올 혜택\n\nReact 19는 2024년 5월 15일부터 16일에 React Conf 2024에서 발표될 예정이며, 이 프레임워크의 오랫동안 기다려온 다음 버전입니다. React 18은 2022년에 출시되었고, 그 이후로 웹 기술이 크게 발전해 왔습니다. 이제는 업데이트할 때가 왔습니다.\n\n\n\n![React Compiler](/assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png)\n\n버전 19는 앞으로 나아갈 한 걸음일 뿐만 아니라, React 애플리케이션을 만드는 방법을 영원히 바꾸어 놓을 것입니다. React 19가 소개할 가장 흥미로운 기능 중 일부는 다음과 같습니다:\n\n- 서버 컴포넌트: 더 빠른 페이지 로딩과 더 나은 SEO를 위한 컴포넌트 서버사이드 렌더링. 서버에서 컴포넌트를 처리하여 페이지를 사용자에게 제공하기 전에, React 19는 웹사이트의 로딩 시간을 빠르게 하고, 검색 엔진 노출도를 향상시키며, 더 부드러운 데이터 관리를 가능하게 합니다. 이미 Next.js가 이 기능을 사용하고 있습니다.\n- 액션: 웹 페이지 내 데이터 및 상호작용 관리를 간소화합니다. 액션은 양식을 통해 페이지 정보를 업데이트하는 작업을 간단하게 만들어 복잡성을 줄이고 사용자 경험을 단순화합니다.\n- 최적화된 자산 로딩: 더 부드러운 페이지 전환을 위해 사이트 자산을 백그라운드에서 로드합니다. React 19는 사용자가 현재 페이지를 둘러 보는 동안 이미지 및 다른 파일을 백그라운드에서 로드하여 페이지 전환 중 대기 시간을 줄입니다.\n- 문서 메타데이터: 새로운 `DocumentHead` 컴포넌트 덕분에 간단한 SEO 관리. 페이지에 제목 및 메타 태그를 추가하는 것이 더 직관적으로 되어 검색 엔진 최적화를 향상시키는 반복적인 코딩을 필요로 하지 않습니다.\n- 웹 컴포넌트: 더 유연하고 호환성이 높은 프론트엔드 개발을 위한 웹 컴포넌트 표준과의 향상된 호환성.\n- 향상된 훅: 기존 및 새로운 훅을 통해 컴포넌트의 라이프사이클과 상태를 더 세밀하게 제어합니다. 최종 목표는 코딩 프로세스를 단순화하여 React 개발을 더 효율적이고 즐겁게 만드는 것입니다.\n- React 컴파일러: React 코드를 표준화된 최적화된 JavaScript 코드로 자동 변환합니다. 상태 변경 시 UI의 올바른 부분만 자동으로 렌더링하도록 컴파일된 React 코드를 허용하여 useMemo, useCallback 및 memo의 필요성을 줄입니다. 이는 단순화된 코드 기반으로 빠른 React 애플리케이션을 의미합니다.\n\n이 모든 기능들은 훌륭하지만 가장 눈에 띄는 것은 React 컴파일러입니다. 이 업그레이드는 React 개발을 영원히 바꿀 것을 약속합니다. 이제 왜 그렇게 생각하게 되었는지와 어떠한 혜택을 제공할지 이해해보도록 하겠습니다!\n\n\n\n# React 컴파일러: 알아야 할 모든 것\n\nReact 19 컴파일러 도구를 자세히 살펴보며, 이 도구가 무엇인지와 어떻게 작동하는지 알아봅니다.\n\n# React의 핵심 메인 모델\n\nReact 컴파일러 뒤에 숨겨진 이유를 이해하려면 먼저 몇 가지 주요한 React 개념을 탐구해야 합니다.\n\n\n\nReact의 핵심은 선언적이고 컴포넌트 기반의 메타 모델에 있습니다. 프론트엔드 개발에서 선언적 프로그래밍은 UI의 원하는 최종 상태를 설명하되 DOM 조작을 통해 각 단계를 명시하지 않고 도달하는 방법을 설명하는 것을 의미합니다. 한편, 컴포넌트 기반 접근 방식은 UI 요소를 재사용 가능하고 간결하며 독립적인 빌딩 블록으로 분해하여 모듈화 및 유지 보수의 용이성을 촉진합니다.\n\n특정 DOM 요소를 식별하여 업데이트해야 할 때, React는 가상 DOM이라고 불리는 사용자 인터페이스의 인메모리 표현을 활용합니다. 애플리케이션 상태 변경이 발생할 경우, React는 가상 DOM을 실제 DOM과 비교하여 필요한 최소한의 변경 사항을 식별하고 정확하게 실제 DOM을 업데이트합니다.\n\n간단히 말하면, React는 애플리케이션의 상태가 변경될 때마다 다시 렌더링합니다. 그러나 때로는 React가 지나치게 반응적일 수 있어 애플리케이션을 심각하게 느리게 만드는 불필요한 다시 렌더링이 발생할 수 있습니다.\n\n# 다시 렌더링 지옥: 컴파일러 필요성\n\n\n\n리액트는 애플리케이션 상태 변화에 민첩하게 대응하는 데 장단점이 있어요. 한편으로는 선언적인 방식을 통해 프론트엔드 개발을 간단하게 만들어 줍니다. 다른 한편으로는 상태 변경에 따른 UI 내 컴포넌트의 지나친 다시 렌더링으로 이어질 수 있어요.\n\n자바스크립트 데이터 구조인 객체와 배열을 다룰 때 특히 다시 렌더링 문제가 일반적으로 발생할 수 있어요. 문제는 두 객체나 배열이 동등한지(동일한 키와 값들을 가지고 있는지) 비교할 수 있는 계산적으로 효율적인 방법이 자바스크립트에는 없다는 것이에요.\n\n다음 시나리오를 고려해 보세요. 각 렌더링마다 새 객체나 배열을 생성하는 리액트 컴포넌트가 있다고 가정해 봅니다. 아래 예시와 같이요:\n\n```js\nimport React from \"react\";\n```\n\n\n\n```js\nconst AlphabetList = () => {\n  // 알파벳 배열 정의\n  const alphabet = Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i));\n  return (\n    <div>\n      <h2>알파벳 목록</h2>\n      <ul>\n        {/* 알파벳을 목록 항목으로 렌더링 */}\n        {alphabet.map((letter, index) => (\n          <li key={index}>{letter}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\nexport default AlphabetList;\n```\n\n로컬 배열의 내용이 각 렌더링마다 동일할지라도, React는 그 사실을 효율적으로 알 수 없습니다. 결과적으로, 배열 값에 의존하는 구성 요소의 중첩 DOM 요소에서 재렌더링이 발생할 수 있으며 UI가 동일하게 유지되어야 한다는 사실을 인식하지 못합니다. 이러한 재렌더링 메커니즘은 빠르게 무제한적으로 힘을 쏟아내어 애플리케이션 성능과 사용자 경험에 상당한 영향을 미칠 수 있습니다.\n\n재렌더링 동작을 최적화하고 이러한 문제를 피하기 위해 React 개발자들은 구성 요소에 수동으로 메모이제이션을 도입해야 합니다. React에서 메모이제이션은 비싼 계산 또는 구성 요소 출력의 결과를 캐싱하는 것을 포함하며 입력 매개변수에 기반합니다. 이러한 결과를 저장하고 재사용함으로써 메모이제이션은 구성 요소의 불필요한 다시 읽기를 방지하고 React 애플리케이션의 전체 효율성과 성능을 향상시킵니다.\n\nReact 18은 여러 가지 메모이제이션 도구를 제공합니다:\n\n\n\n\n- React.memo(): 프롭이 변경되지 않은 경우 컴포넌트의 다시 렌더링을 피하기 위한 하이어오더 함수입니다.\n- useMemo(): 재렌더링 사이에 계산 결과를 캐시하는 React 훅으로, 중복된 계산을 줄입니다.\n- useCallback(): React에서 함수 정의를 캐시하여 불필요한 함수 재생성을 피하는 훅입니다. React의 useCallback() 훅에 대해 자세히 알아보세요.\n\nuseMemo() 훅 덕분에 `AlphabetList` 컴포넌트를 최적화하여 불필요한 재렌더링을 피할 수 있습니다. 아래와 같이 구현할 수 있습니다:\n\n```js\nimport React, { useMemo } from \"react\";\n```\n\n```js\nconst AlphabetList = () => {\n  // useMemo()을 사용하여 알파벳 배열을 정의합니다.\n  const alphabet = useMemo(() => {\n    return Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i));\n    // 의존성이 없으므로 첫 렌더링 시에만 계산됩니다.\n  }, []);\n  return (\n    <div>\n      <h2>알파벳 리스트</h2>\n      <ul>\n        {/* 알파벳을 리스트 아이템으로 렌더링합니다. */}\n        {alphabet.map((letter, index) => (\n          <li key={index}>{letter}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\nexport default AlphabetList;\n```\n\n\n\n리액트에서 제공하는 메모이제이션 도구들은 정말 강력해요. 동시에 이를 도입하는 것은 리액트의 핵심적인 메타모델인 선언적 철학과는 명확히 달라요. 개발자들에게 부담을 주는데, UI의 최종 상태뿐만 아니라 렌더링 최적화를 명시적으로 관리해야 해요. 수동 메모이제이션은 코드 복잡성과 유지보수의 어려움을 도입하게 해요.\n\n해결책은 무엇일까요? 리액트 코드를 최적화된 JavaScript 코드로 변환하는 고급 컴파일러입니다. 이를 통해 상태 값이 크게 변경된 경우에만 컴포넌트가 자동으로 다시 렌더링되도록 할 수 있어요.\n\n# 리액트 컴파일러란 무엇인가요?\n\n리액트 컴파일러, 또는 리액트 포겟으로도 알려진 이것은 리액트를 위한 최적화 컴파일러에요. 지금은 인스타그램의 웹 포털에서 사용되고 있으며, 첫 번째 오픈 소스 릴리스 전에 다른 메타 어플리케이션에 배포될 예정이에요.\n\n\n\n컴파일러의 초기 목표는 React의 핵심 프로그래밍 모델을 강제로 적용하여 memo, useMemo 및 useCallback 호출의 동등물을 자동으로 생성하여 다시 렌더링 비용을 최소화하는 것이었습니다. 이 프로젝트는 \"자동 메모이징 컴파일러\"에서 \"자동 반응성 컴파일러\"로 크게 발전했습니다.\n\n지금의 React Forget의 진짜 목표는 React 애플리케이션이 기본적으로 적절한 반응성을 갖도록 보장하는 것입니다. 다시 말해, 앱은 상태 값이 의미 있는 변화가 있을 때에만 다시 렌더링되어야 합니다. 현재 React는 객체 식별이 변경될 때 구성요소를 다시 렌더링합니다. 그러나 React Forget를 사용하면 객체의 의미적 값이 변경될 때에만 다시 렌더링되지만 심층 비교의 런타임 비용을 지불하지 않습니다.\n\n구현 관점에서 React Compiler는 자동 메모이제이션을 적용합니다. 그러나 이를 제작한 팀은 반응성 프래밍을 이해하는 더 완전한 방법으로 간주합니다. React 컴파일러의 내부 작업 및 논리에 대해 자세히 알고 싶다면 React Labs 섹션의 해당 내용을 읽어보세요.\n\n아래 비디오에서 React Forget의 작동을 확인하세요: [여기를 클릭하세요](https://www.youtube.com/watch?v=qOQClO3g8-Y&)\n\n\n\n자바스크립트는 동적 성격과 느슨한 규칙 때문에 최적화하기 어렵다는 것으로 유명합니다. 그러나 React Compiler는 JavaScript 규칙과 \"React의 규칙\"을 모델링하여 코드를 안전하게 컴파일할 수 있습니다. 이러한 규칙은 개발자들이 할 수 있는 일을 제한하여 컴파일러가 최적화 작업을 수행할 안전한 공간을 마련합니다.\n\n# React의 규칙\n\nReact는 고품질 웹 애플리케이션을 지원하기 위해 고안된 규칙 세트와 함께 제공됩니다. 개발자들은 이러한 규칙을 따라야 하며, 이는 React Compiler가 기반으로 하는 것과도 일맥상통합니다.\n\nReact의 가장 중요한 규칙 중 일부는 다음과 같습니다:\n\n\n\n- 컴포넌트는 idempotent해야 합니다: React 컴포넌트는 항상 동일한 출력물을 생성해야 합니다. 입력값으로는 props, state 및 context가 포함됩니다.\n\n- 사이드 이펙트는 렌더링 외부에서 실행되어야 합니다: 데이터 가져오기, 구독 또는 수동으로 DOM을 변경하는 사이드 이펙트는 컴포넌트의 렌더링 프로세스 중에 수행해서는 안 됩니다. 대신에 useEffect와 같은 라이프사이클 훅에서 실행되어야 합니다.\n\n- Props와 state는 불변해야 합니다: React 컴포넌트의 props와 state는 불변으로 취급되어야 합니다. 직접 수정해서는 안되며, props 또는 state를 직접 변경하는 것은 버그와 예측할 수 없는 작동을 유발할 수 있습니다.\n\n- 훅에 대한 반환 값 및 인수는 불변해야 합니다: 값이 React 훅에 전달된 후에는 수정해서는 안 됩니다. 훅은 인수와 반환 값을 변경하지 않음으로써 컴포넌트 동작의 일관성과 예측 가능성을 유지합니다.\n\n- JSX에 전달된 값은 불변해야 합니다: 렌더링된 후 JSX에서 사용된 값은 변형해서는 안 됩니다. 필요한 변형은 렌더링된 JSX 이전에 수행되어야 하며, 이를 통해 렌더링된 출력물이 일관되게 유지됩니다.\n\n- 컴포넌트 함수를 직접 호출하지 말아야 합니다: React 컴포넌트는 JSX 내부에서만 사용되어야 하며, 일반 함수처럼 직접 호출해서는 안 됩니다.\n\n- 훅을 일반 값처럼 전달하지 마세요: useState나 useEffect와 같은 React 훅은 함수형 컴포넌트 내부에서만 호출되어야 합니다. 이를 일반 값으로 사용하는 것은 예상치 못한 동작을 유발하고 훅 규칙을 위반할 수 있습니다.\n\n- 훅은 항상 최상위 수준에서 호출해야 합니다: React 훅은 항상 함수형 컴포넌트의 최상위 수준에서 호출해야 하며, 어떠한 조건문이나 반복문보다 먼저 호출되어야 합니다. 이렇게 함으로써 훅이 모든 렌더링에서 동일한 순서로 호출되고 의도한 동작을 유지합니다.\n\n- React 함수에서만 훅을 호출해야 합니다: 훅은 React 함수 컴포넌트나 사용자 정의 훅 내부에서만 호출해야 합니다. 일반 JavaScript 함수에서 훅을 호출하는 것은 오류를 유발할 수 있으며 훅 규칙을 위반합니다.\n\nStrict Mode를 활성화하고 React의 ESLint 플러그인을 구성하여 React 애플리케이션이 이러한 규칙을 준수하도록하세요.\n\n# 이점과 희망\n\nReact Compiler에 의해 제공되는 주요 이점은:\n\n\n\n- 더 이상 메모이제이션에 대한 골치 아픔이 없어졌어요: 개발자들은 이제 코드에서 메모이제이션 전략을 수동으로 구현하고 관리할 필요가 없습니다. 이로 인해 복잡성과 오류 가능성이 줄어들며 개발 프로세스가 간소화됩니다.\n- 개발자 경험이 더 나아졌어요: 개발자들은 기능 구축에 더 집중하고 성능 최적화에 덜 신경 쓸 수 있어서 생산성과 만족도가 높아졌어요. 이제 React 선언적 접근 방식을 완전히 받아들일 수 있을 거에요.\n- 빠른 React 애플리케이션: 필요할 때만 컴포넌트를 렌더링하여 불필요한 계산과 오버헤드를 최소화해요. 이로 인해 빠르고 반응성이 높은 사용자 인터페이스를 구현할 수 있어 전체 성능과 사용자 경험이 개선됩니다.\n\n이 모든 것들은 흥미로운 변화이지만, 이 새로운 도구가 코드 개발에 미치는 영향을 아직 보지 못했어요. 컴파일러가 제대로 작동하기 위해서는 코드가 React 규칙을 준수해야 해요. 공식팀이 ESLint와 같은 도구를 도입하여 React 컴파일러를 위해 애플리케이션을 준비하는 것을 권장하는 이유가 여기 있어요.\n\n# React 컴파일러: 프론트엔드 혁명?\n\nReact 컴파일러가 프론트엔드 개발 영역에서 진정한 혁명을 일으킬 만큼 충분할지는 곧 알 수 있을까요. 확실한 것은, 이 컴파일러가 미래의 React 애플리케이션 개발을 크게 변화시킬 자격이 있다는 것입니다. 자동 메모이제이션을 도입함으로써, 이 컴파일러는 React 애플리케이션의 속도를 자동으로 향상시키고 개발자 경험을 향상시킬 수 있어요. 이 야심찬 프로젝트가 가져다 주는 혜택 중 일부일 뿐이에요.\n\n\n\nReact Conf 2024가 곧 다가오고 있으니, 이 야심찬 프로젝트가 프론트엔드 세계에 미칠 혁신을 기대해 봅니다!\n\n원문은 2024년 5월 9일 https://semaphoreci.com에서 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png"},"coverImage":"/assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png","tag":["Tech"],"readingTime":9},{"title":"자바스크립트 앱이 정상적으로 작동할 때 리액트 네이티브 문제를 해결하는 방법","description":"","date":"2024-05-12 19:29","slug":"2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks","content":"\n\n지난번에 React Native 앱을 작업한 건 이미 3년 전이에요. 그리고 이에 대해 글을 쓰고 싶은 마음은 오랫동안 가지고 있었는데 항상 잊어버렸었어요. 그 때는 블록체인 NFT 프로젝트도 함께 진행했었는데, 그 이야기는 다른 날에 별도로 다룰 거예요 (이 \"팁\" 글 말고 흥미로운 이야기가 될 거라고 약속해요). 비슷한 문제에 직면하고 있다면 임시 방편을 이용할 아이디어를 제공하려고 해요.\n\n# 상황\n\n이전 프로젝트는 '비전을 가진' 창업자들이 이끄는 스타트업 회사에 관련된 건데, 안타깝게도 구체적인 계획이 부족했고 성공적인 자금 마련을 할 수 없었기 때문에 제 봉급을 지급하지 못했어요 🤷‍♂️. 저는 랜딩 페이지와 모바일 앱을 동시에 만드는 것을 담당한 유일한 개발자였어요.\n\n앱은 3D 아바타를 특징으로 하는 모바일 커뮤니케이션(채팅) 플랫폼이었고, 사용자들은 채팅 앱 내에서 사용할 NFT를 구매할 수 있었어요. React에 익숙했기 때문에 3D 렌더링 라이브러리를 조사하고 React로 작동하는 PoC를 몇 시간 동안 개발한 후, React Native를 사용하여 앱을 만들기로 결정했어요. \"결국 React인데; 얼마나 다를까?\" 라고 생각했어요.\n\n\n\n# 문제\n\n“채팅 앱\"을 마치고 기분 좋았는데, 팔을 걷어내고 내 헤비 메탈 플레이리스트에서 고함 소리를 들으며 흥을 냈습니다. 간단한 3D 모델들은 잘 작동했지만, 이후 이를 렌더링할 수 없는 문제가 발생했어요. 이는 애니메이션이 포함된 3D .FBX 파일인 이진 파일을 렌더링할 수 없었던 것이었습니다. 찾아봐도 (그 때 chatGPT는 그리 도움이 되지 못했습니다) React Native 자체가 배열 버퍼를 지원하지 않는다는 것을 알 수 없었죠. 현재 해결되었는지는 확실하지 않습니다.\n\n시간이 없어서 일반 React 앱에서 로드해보았는데, 잘 작동했어요. 핸드폰으로 웹 앱을 시작해봤을 때도 문제없이 작동했습니다. 데모 날이 다가오고 있어서 그 주에 문제를 해결해야 했어요.\n\n그래서 React Native 기술 스택을 사용하는 시니어 모바일 개발자인 전 동료에게 도움을 요청했지만, 안타깝게도 그도 문제를 해결하지 못했습니다.\n\n\n\n내가 가진 제한된 시간과 기술로 React Native 코어에 깊게 파보는 일은 할 수 없었어요. 그 당시에는 절망에 빠져 있었습니다.\n\n# “가끔 어둠이 너에게 빛을 비춰줄 수도 있어\" — Disturbed\n\n어둔 시기에 멘토가 제안했어요: “React Native 앱에 웹 앱을 넣어본다면 어떨까?\"\n\n![이미지](/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png)\n\n\n\n그래서, 나는 React 앱을 Vercel에 호스팅하고 React Native 앱으로 WebView로로드하는 것을 시도했고 완벽하게 작동했어요.\n\niframe과 상호 작용하기 위해 수백만 개의 블로그가 안내를 제공하고 있어, 또는 그냥 chatGPT에게 물어보면 돼요, 그래서 여기에는 넣을게 없어요.\n\n문제는 해결됐지만, 문제는 전체 블록체인 및 NFT 트렌드가 붕괴되었을 때 피칭이 잘못된 시간에 있었고, 정말 필요한 때에 돈을 사칭 당했어요—내 결혼식을 위해서!!!\n\n고객 중심적 사고 방식을 가지고 있다면(https://medium.com/@whoz_/beyond-code-dont-just-be-a-coder-a9bad8007dca), 다양한 경우에이 해결책이 도움이 될 수 있어요. 시장을 빨리 점령하기 위해 제대로 작동하도록 시간을 낭비하지 않아도 돼요. 시장에 올 때 좋은 앱을 가지고 있다해도, 고객이 정말 필요하지 않을 때나 피드백에 따라 다시 작업하기에 너무 늦었을 때 그 점이 어떤 의미가 있겠어요?\n\n\n\ntldr; 만약 React Native 앱에 문제가 있지만 React 앱은 핸드폰 브라우저에서 잘 작동한다면 WebView을 통해 React Native에 임베드해보세요.","ogImage":{"url":"/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png"},"coverImage":"/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png","tag":["Tech"],"readingTime":2},{"title":"패키지-락json 완전 가이드","description":"","date":"2024-05-12 19:28","slug":"2024-05-12-package-lockjsonTheCompleteGuide","content":"\n\n## package-lock.json이란 무엇이고, 왜 신경 써야 하나요?\n\n### package.json이란?\n\npackage.json은 주로 당신의 Node.js 프로젝트가 실행되기 위해 필요한 종속성(라이브러리) 목록을 포함하는 버전 파일입니다.\n\n또한 스크립트, 저자 및 라이센스 정보, 설명, 프로젝트 속성 등과 같은 다른 메타 정보도 포함하고 있습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png\" />\n\n# 고유한 문제\n\n위의 package.json에서 \"dependencies\" 객체가 package-name을 버전 범위로 매핑하는 것을 볼 수 있습니다.\n\n<img src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_1.png\" />\n\n\n\n이것은 npm install을 결정론적이지 않게 만듭니다. 그래서 오늘 npm install을 실행하고 3개월 후에 다시 실행하면 동일한 node_modules 트리를 얻을 수 없을 수 있습니다.\n\n게다가, 만약 다른 개발자가 여러분의 프로젝트를 복제하고 그것에 몇 일 후에 npm install을 실행한다면, 그들은 다른 node_modules 의존성 트리를 가질 수 있습니다. 여러 명의 개발자가 같은 저장소에서 작업하는 경우(이는 대부분의 경우 조직 내에서 발생할 것으로 예상됩니다),이는 큰 문제를 일으킬 수 있으며 설치된 의존성에 일관성이 없거나 더 나빠른 변경으로 이어질 수 있습니다.\n\n그래서 해결책은 무엇일까요? 먼저, 버전 범위가 무엇을 의미하는지 이해해 봅시다. 버전 범위는 하나 이상의 공백으로 구분된 숫자가 포함된 문자열입니다. 이 숫자들은 ^ ~ ` ||와 같은 일부 특수 기호도 포함합니다. 예: ^1.0.4, ~2.3, 4.4.x, `=2.3.4, `1.0.9 ||\n\n![image](/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_2.png)\n\n\n\n이 기호들은 npm에게 다른 정보를 전달해요:\n\n예를 들어, \"foo\" 패키지를 설치하고 싶다고 해봅시다. npm i foo를 실행한 후에, 내 package.json 파일에는 대부분 다음과 같은 항목이 있을 거에요:\n\n```js\n{\n  \"dependencies\": {\n    \"foo\": \"^2.3.0\",\n    ...\n    ...\n  }\n}\n```\n\n여기서 foo는 2.3.0 [주 버전 부 버전 패치 버전] 버전으로 설치되었어요. 이 caret 기호는 또 다른 정보를 알려줘요:\n\n\n\n^2.3.0 — Caret Symbol: npm에게 마이너 및 패치 버전을 업그레이드하도록 지시하지만 메이저 버전은 업그레이드하지 않습니다. 기본적으로 2.3.4, 2.3.9, 2.4.5, 2.8는 가능하지만 3.0.0부터는 불가능합니다. (마이너 및 패치는 업그레이드하지만 메이저는 제외)\n\n~2.3.0 — Tilde Symbol: npm에게 패치 버전을 업그레이드하도록 지시하지만 마이너 및 메이저 버전은 업그레이드하지 않습니다. 따라서 2.3.4, 2.3.9는 가능하지만 2.4.0부터는 불가능합니다. (패치는 업그레이드하지만 마이너 및 메이저는 제외)\n\n다른 npm 버전 업데이트 전략을 표시하는 여러 기호가 있습니다. 공식 npm 웹사이트가 좋은 참고자료가 될 것입니다.\n\n따라서 \"foo\": \"^2.3.0\"의 경우, 며칠 후에 npm install을 실행하면 자동으로 마이너/패치 버전이 업그레이드될 수 있습니다. 이는 바람직하지 않습니다...\n\n\n\n# 패키지 잠금파일(package-lock.json)이란?\n\n![이미지](/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_3.png)\n\n패키지 잠금파일(package-lock.json)은 노드.js 프로젝트에 설치된 종속성/패키지들과 정확한 버전 번호에 대한 정보를 포함하는 잠금 파일(lockfile)입니다 (*중요).\n\n- 이 파일은 동일한 저장소에서 작업하는 다른 개발자들이 이전에 설치된 정확한 패키지 버전을 설치할 수 있도록 도와줍니다. 새 버전의 패키지가 출시되어도 다른 기기/환경에서 동일한 node_modules 트리를 유지할 수 있습니다.\n- 패키지 잠금파일(package-lock.json)은 종속성을 특정 버전 번호로 잠그는 데 주로 사용됩니다.\n- 이 파일은 node_modules 트리나 package.json 파일 중 하나라도 변경이 있을 때 자동으로 생성(또는 재생성)됩니다.\n- 저장소를 복제하고 새 기기에서 npm i를 실행할 때, npm은 먼저 패키지 잠금파일(package-lock.json)이 있는지 확인합니다. 있을 경우 해당 파일에 있는 패키지를 설치합니다. 그렇지 않으면 package.json 파일을 확인하고 필요한 종속성 패키지를 설치합니다. (📦 이에 대한 주의사항은 뒤의 글에서 설명됩니다)\n\n\n\n<img src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_4.png\" />\n\n# 패키지 잠금 파일(package-lock.json)은 커밋해야 하나요?\n\n네, 이 파일은 소스 저장소에 커밋해야 합니다. 이렇게 하면 개발자가 귀하의 리포지토리를 클론할 때 귀하의 컴퓨터/환경에 설치된 의존성과 정확히 일치하는 의존성을 설치할 수 있습니다. 다른 컴퓨터에서 node.js 환경을 복제하는 데 도움이 됩니다.\n\n# 참고로\n\n\n\n저는 YouTube에서 아름다운 자바스크립트 체험을 보여주는 비디오를 만들고 있어요. (참고로 코딩 튜토리얼 채널은 아니에요...) 제 비디오를 확인해보세요:\n\n# npm install이 package-lock.json을 다시 작성하는 이유 / 시기\n\n- 📦 주의: npm install은 package.json의 버전 범위 내에 설치할 패키지가 있는 경우에만 package-lock.json을 고려합니다.\n- 잠금 파일에 지정된 패키지 버전이 package.json 파일의 버전 범위 내에 없는 경우, 패키지가 업데이트되고 package-lock.json 파일이 덮어씌워집니다.\n- package-lock.json을 덮어쓰기 대신 설치를 실패하게 하려면 npm ci를 사용하세요.\n\n예를 들어,\n\n\n\n패키지.json에서는 종속성을 다음과 같이 선언합니다:\n\n```js\n\"foo\": \"^2.3.0\"\n```\n\n그리고 npm install을 실행하면, 다음과 같은 package-lock.json이 생성됩니다:\n\n```js\n\"foo\": \"2.3.0\"\n```\n\n\n\n몇 일 후에, \"foo\"의 새로운 부 버전인 \"2.4.0\"이 출시됩니다. 그리고 이렇게 됩니다:\n\nnpm install — package-lock 버전이 범위 내에 있으므로(예: ^2.3.0) 2.3.0이 설치됩니다.\nnpm ci — 이 명령은 어차피 package-lock.json만을 보기 때문에 2.3.0이 설치됩니다.\n\n다음으로, package.json을 수동으로 업데이트합니다:\n\n```js\n\"foo\": \"^2.4.0\"\n```\n\n\n\n그럼 다시 실행해주세요:\n\nnpm install 명령어를 실행하면 package-lock 파일의 버전이 범위 내에 없기 때문에 (예: ^2.4.0), 2.4.0 버전으로 설치되며 package-lock.json 파일은 이제 다음과 같이 다시 작성됩니다:\n\"foo\": \"2.4.0\"\n\nnpm ci 명령어를 실행하면 package-lock.json 파일만 고려하지만 버전이 범위 내에 없기 때문에 오류가 발생합니다.\n\nnpm ci 명령어는 npm install과 유사하지만 테스트 플랫폼, 지속적인 통합, 배포 등과 같은 자동 환경에서 사용하기 위한 명령어입니다. 즉, 종속성을 깔끔하게 설치하고 싶은 경우에 유용합니다. (출처: npm 문서)\n\n\n\n# 간단히 말해요:\n\n- npm install은 결정론적이지 않아서, 수천 개의 종속성이 포함된 리포지토리(다수의 개발자들이 참여)에서 작업할 때 문제가 발생할 수 있어요.\n- package-lock.json 파일은 npm install이 실행될 때 항상 동일한 node_modules 트리가 생성되도록 보장해줘요.\n- 최신 명령어인 npm ci는 항상 동일한 node_modules 트리를 생성하도록 보장하며, 그렇지 않으면 오류를 발생시켜요.","ogImage":{"url":"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png"},"coverImage":"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"React-js를 이용한 초보자를 위한 Socketio를 활용한 간단한 채팅 애플리케이션","description":"","date":"2024-05-12 19:26","slug":"2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners","content":"\n\n안녕하세요 여러분! 이 글에서는 socket.io와 React js를 사용하여 간단한 채팅 애플리케이션을 만드는 방법에 대해 알아볼 거에요. 특히 초보자분들을 위한 내용으로 모든 단계를 차근차근 알려드릴 거에요. 마지막에는 React-js로 간단한 채팅 애플리케이션을 만들게 될 거에요.\n\n![SimpleChatappusingSocketioInReact-jsForBeginners](/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png)\n\n## Socket.io란 무엇인가요?\n\nSocket.IO는 웹 클라이언트와 서버 간 실시간 양방향 통신을 용이하게 하는 강력한 JavaScript 라이브러리입니다. 사용자와 응용 프로그램 간 즉각적인 데이터 교환을 허용하는 다리 역할을 하며, 라이브 채팅, 멀티플레이어 게임 및 협업 편집 도구와 같은 참여형 경험을 만들기에 이상적입니다. 강력한 기능과 사용 편의성을 갖춘 Socket.IO는 현대적이고 인터랙티브한 웹 애플리케이션을 구축하기 위한 주요 기술로 자리잡았습니다.\n\n\n\n단계 1: 새 폴더 생성하기\n\n여기서 빈 폴더를 생성합니다. 이 폴더 안에 클라이언트 측(react)과 서버 측(socket.io)의 2개 개별 폴더를 생성합니다.\n\n```js\nmkdir react-chatapp\ncd react-chatapp\n```\n\n단계 2: socket.io를 사용하여 소켓 만들기\n\n\n\n먼저 서버 측 작업을 위해 서버 폴더를 만들어야 해요. 다음 명령어를 사용하세요.\n\n```js\nmkdir server\ncd server\n```\n\n새로운 Node.js 프로젝트를 초기화하세요:\n\n```js\nnpm init -y\n```\n\n\n\n\nsocket.io 라이브러리 설치하기\n\n```js\nnpm install socket.io\n```\n\nsocket.io를 설치한 후 server.js 파일을 만들고 아래 코드를 추가해주세요.\n\n```js\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nconst server = http.createServer((req, res) => {\n    res.end('Hello World');\n});\n\nconst io = new Server(server, {\n    cors: {\n        origin: \"*\",\n        methods: [\"GET\", \"POST\"]\n    }\n});\n\nio.on('connection', (socket) => {\n    console.log('사용자가 연결되었습니다.');\n\n    socket.on('message', (message) => {\n        io.emit('message', message);\n    });\n\n    socket.on('disconnect', () => {\n        console.log('사용자가 연결을 끊었습니다.');\n    });\n});\n\nconst PORT = process.env.PORT || 4000;\n\nserver.listen(PORT, () => {\n    console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n\n\n여기, 이 코드는 Node.js의 내장 http 모듈을 사용하여 기본 HTTP 서버를 설정하고 Socket.IO 서버를 연결하는 방법을 보여줍니다. Socket.IO 서버는 클라이언트 연결을 수신하고 모든 연결된 클라이언트에 메시지를 브로드캐스트하며 클라이언트가 연결 또는 연결 해제될 때 로그를 기록합니다.\n\n단계 3: React js에서 Socket.io 구현\n\n\"react-chatapp\" 폴더로 이동하여 리액트 프로젝트를 만듭니다.\n\n```sh\nnpx create-react-app client\n```\n\n\n\n리액트 프로젝트를 설치한 후 프로젝트 안으로 이동하여 의존성을 설치하세요.\n\n```js\ncd client\nnpm start\n```\n\n리액트 기본 의존성을 설치한 후 socket.io-client와 부트스트랩 라이브러리를 리액트에 설치하세요.\n\n```js\nnpm install socket.io-client bootstrap\n```\n\n\n\n- Socket.IO-Client:\n\n- socket.io-client은 Socket.IO를 위한 클라이언트 측 라이브러리로, 실시간 양방향 통신 라이브러리입니다.\n- 이를 통해 웹 클라이언트(예: 브라우저)가 Socket.IO 서버와 연결을 설정하고 실시간으로 통신할 수 있습니다.\n- 서버에 이벤트를 전송하거나 서버로부터 받은 이벤트를 처리하는 방법을 제공합니다.\n- socket.io-client를 사용하면 채팅, 실시간 업데이트, 협업과 같은 기능을 지원하는 대화형 웹 애플리케이션을 개발할 수 있습니다.\n\n2. Bootstrap:\n\n- Bootstrap은 반응형 및 모바일 우선 웹 프로젝트를 구축하기 위한 인기 있는 프론트엔드 프레임워크입니다.\n- 버튼, 폼, 내비게이션 바와 같은 사전 스타일이 적용된 CSS 컴포넌트 및 모달, 툴팁과 같은 JavaScript 플러그인을 제공합니다.\n- Bootstrap의 그리드 시스템을 통해 다양한 화면 크기와 장치에 대응하는 반응형 레이아웃을 생성할 수 있습니다.\n- Bootstrap을 사용하면 다양한 준비가된 컴포넌트와 스타일을 제공하여 웹 애플리케이션을 디자인하고 스타일링하는 데 시간과 노력을 절약할 수 있습니다.\n\n\n\n그럼 src/App.js 파일로 이동하여 다음 코드로 교체하세요\n\nsrc/App.js\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport '../src/App.css';\nimport io from 'socket.io-client';\n\nconst socket = io('http://localhost:4000');\n\nfunction App() {\n  const [messages, setMessages] = useState([]);\n  const [username, setUsername] = useState('');\n  const [isUsernameSubmitted, setIsUsernameSubmitted] = useState(false);\n  const [inputMessage, setInputMessage] = useState('');\n  const [isUsernameSet, setIsUsernameSet] = useState(false);\n\n  useEffect(() => {\n    const storedUsername = localStorage.getItem('username');\n    if (storedUsername) {\n      setUsername(storedUsername);\n      setIsUsernameSet(true);\n    }\n\n    socket.on('message', (message) => {\n      setMessages((prevMessages) => [...prevMessages, message]);\n    });\n\n    return () => {\n      socket.off('message');\n    };\n  }, []);\n\n  const handleUsernameChange = (e) => {\n    setUsername(e.target.value);\n  };\n\n  const handleUsernameSubmit = () => {\n    localStorage.setItem('username', username);\n    setIsUsernameSubmitted(true);\n  };\n\n  const handleMessageSend = () => {\n    if (!inputMessage.trim()) return;\n\n    socket.emit('message', {\n      username,\n      text: inputMessage\n    });\n\n    setInputMessage('');\n  };\n\n  return (\n    <div className=\"container mt-5\">\n      <div className=\"row justify-content-center\">\n        <div className=\"col-md-6\">\n          <div className=\"card\">\n            <div className=\"card-body\">\n              <h5 className=\"card-title text-center mb-4\">Chat App</h5>\n              {!isUsernameSubmitted ? (\n                <div>\n                  <div className=\"mb-3\">\n                    <input\n                      type=\"text\"\n                      className=\"form-control\"\n                      placeholder=\"사용자 이름 입력\"\n                      value={username}\n                      onChange={handleUsernameChange}\n                    />\n                  </div>\n                  <button\n                    className=\"btn btn-primary btn-block\"\n                    onClick={handleUsernameSubmit}\n                  >\n                    사용자 이름 설정\n                  </button>\n                </div>\n              ) : (\n                <div>\n                  <h4 className=\"text-center mb-4\">환영합니다, {username}님!</h4>\n                  <div className=\"message-container row\">\n                    {messages.map((msg, index) => (\n                      <div key={index} className=\"message col-md-8 offset-md-2\">\n                        <strong>{msg.username}:</strong> {msg.text}\n                      </div>\n                    ))}\n                  </div>\n                  <div className=\"input-group mb-3\">\n                    <input\n                      type=\"text\"\n                      className=\"form-control\"\n                      placeholder=\"메시지 입력...\"\n                      value={inputMessage}\n                      onChange={(e) => setInputMessage(e.target.value)}\n                    />\n                    <button\n                      className=\"btn btn-primary\"\n                      onClick={handleMessageSend}\n                    >\n                      전송\n                    </button>\n                  </div>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n이 코드에서는 React와 Socket.IO를 사용하여 실시간 채팅 애플리케이션을 만드는 과정을 안내하겠습니다. 우리는 먼저 애플리케이션의 기본 구조를 설정한 다음 사용자가 실시간으로 메시지를 보내고 받을 수 있도록 기능을 점진적으로 추가할 것입니다.\n\n\n\n단계 1: 사용자 이름 입력 컴포넌트 생성\n\n- 먼저 UsernameInput이라는 React 컴포넌트를 만드세요. 이 컴포넌트는 사용자가 사용자 이름을 입력할 수 있는 입력 필드를 렌더링합니다.\n- useState 훅을 사용하여 사용자 이름 입력 필드의 상태를 관리하세요.\n- 사용자 이름이 제출되었는지 여부에 따라 채팅 인터페이스를 조건부로 렌더링하세요.\n\n단계 2: 채팅 인터페이스 표시\n\n- 사용자가 사용자 이름을 제출하면 채팅 인터페이스를 표시하세요.\n- 메시지를 입력할 수있는 입력 필드와 메시지를 전송하는 버튼을 제공하세요.\n- 사용자 이름이 제출되었을 때에만 채팅 인터페이스를 표시하도록 조건부 렌더링을 사용하세요.\n\n\n\n단계 3: 메시지 제출 처리\n\n- 메시지 제출을 처리하기 위해 handleMessageSend라는 함수를 정의하십시오.\n- 사용자가 전송 버튼을 클릭하면이 함수를 호출하여 Socket.IO를 통해 서버로 메시지를 전송하십시오.\n- useState 훅을 사용하여 입력 메시지 필드의 상태를 관리하고, 메시지를 전송 한 후에 필드를 지우십시오.\n\n단계 4: 실시간 통신을 위한 Socket.IO 통합\n\n- socket.io-client 라이브러리를 가져와 Socket.IO 서버에 연결을 설정하십시오.\n- 서버에 io 함수를 사용하여 연결하고 서버 URL을 제공하십시오.\n- 서버에서 수신된 메시지를 처리하는 이벤트 리스너를 정의하십시오.\n- 사용자가 메시지를 보낼 때 서버로 메시지를 발신하고, 클라이언트와 서버 간의 양방향 통신을 보장하십시오.\n\n\n\n그럼 src/App.css 파일 안으로 들어가서 다음 코드를 다음과 같이 바꿔주세요.\n\nsrc/App.css\n\n```css\nbody{\n  background-color: cadetblue;\n}\n\n/* Card를 가운데 정렬 */\n.card {\n  margin-top: 50px;\n}\n\n/* 메시지 컨테이너를 스타일링 */\n.message-container {\n  max-height: 300px;\n  overflow-y: auto;\n  padding: 10px;\n}\n\n/* 각각의 메시지 스타일링 */\n.message {\n  background-color: burlywood;\n  padding: 10px;\n  margin-bottom: 5px;\n  border-radius: 5px;\n}\n\n/* 입력 그룹을 스타일링 */\n.input-group {\n \n  /* bottom: 0;\n  left: 0;\n  right: 0; */\n  padding: 15px;\n  /* background-color: #f9f9f9;\n  border-top: 1px solid #ccc; */\n}\n```\n\n위 단계를 모두 완료하면 서버를 실행할 시간입니다.\n서버 폴더로 이동하여 다음 명령어를 실행하세요.\n\n\n\n```js\nnode server.js\n```\n\n다음으로, client 폴더로 이동하여 다음 명령어를 실행하세요\n\n```js\nnpm start\n```\n\n결과:\n\n\n\n![이미지 1](/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_1.png)\n\n![이미지 2](/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_2.png)\n\n도움이 되길 바라요...","ogImage":{"url":"/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png"},"coverImage":"/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png","tag":["Tech"],"readingTime":8},{"title":"모든 개발자가 알아야 할 5가지 커스텀 React Hooks","description":"","date":"2024-05-12 19:25","slug":"2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow","content":"\n\n경력 있는 ReactJS 개발자로서, 애플리케이션을 개발하는 동안 다양한 도전과 성공을 경험해왔어요. 여행을 하면서 저는 코드의 재사용성과 효율성을 향상시키기 위해 사용자 정의 React 훅에 많은 의존을 하게 되었어요. 이 글에서는 모든 개발자가 알아야 할 다섯 가지 사용자 정의 React 훅을 공유하고 싶어요. 각 훅을 하나씩 살펴보며 예시를 제시하고 제 경험도 함께 공유할 거에요.\n\n![이미지](/assets/img/2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow_0.png)\n\n\n# useLocalStorage\n\n브라우저 스토리지 관리는 React 애플리케이션에서 흔한 요구사항입니다. useLocalStorage 훅을 사용하면 값을 localStorage와 동기화할 수 있어요. 최근 프로젝트에서 이를 어떻게 활용했는지 예시를 보여드릴게요:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nconst useLocalStorage = (key, defaultValue) => {\n  const [value, setValue] = useState(() => {\n    const storedValue = localStorage.getItem(key);\n    return storedValue ? JSON.parse(storedValue) : defaultValue;\n  });\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n  return [value, setValue];\n};\n```\n\n이 훅 안에서는 상태 값을 로컬 스토리지에 저장된 값이나 제공된 기본 값으로 초기화합니다. 값이 변경될 때마다 스토리지를 업데이트하기 위해 useEffect를 사용합니다. 컴포넌트에서 이렇게 사용할 수 있습니다:\n\n```js\nconst App = () => {\n  const [name, setName] = useLocalStorage('name', 'John Doe');\n\n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <p>Hello, {name}!</p>\n    </div>\n  );\n};\n```\n\n# useMediaQuery\n\n\n\n\n지금은 애플리케이션을 반응형으로 만들어서 다양한 화면 크기에 적응하는 것이 중요합니다. useMediaQuery 훅을 사용하면 리액트에서 미디어 쿼리를 쉽게 처리할 수 있습니다. 저는 이를 어떻게 활용했는지의 예시를 보여드리겠습니다:\n\n```js\nimport { useState, useEffect } from 'react';\n\nconst useMediaQuery = (query) => {\n  const [matches, setMatches] = useState(\n    () => window.matchMedia(query).matches\n  );\n  useEffect(() => {\n    const mediaQuery = window.matchMedia(query);\n    const handleChange = (e) => setMatches(e.matches);\n    mediaQuery.addEventListener('change', handleChange);\n    return () => {\n      mediaQuery.removeEventListener('change', handleChange);\n    };\n  }, [query]);\n  return matches;\n};\n```\n\n이 예시에서는 이벤트 리스너와 matchMedia를 사용하여 미디어 쿼리의 변경 사항을 추적하고 있습니다. 다음은 컴포넌트에서 이를 사용하는 방법입니다:\n\n```js\nconst App = () => {\n  const isMobile = useMediaQuery('(max-width: 768px)');\n\n  return (\n    <div>\n      <h1>{isMobile ? '모바일 뷰' : '데스크톱 뷰'}</h1>\n    </div>\n  );\n};\n```\n\n\n\n# useDebounce\n\nDebouncing은 일정 시간 동안의 작업 실행을 지연시키는 기술입니다. useDebounce 훅을 사용하면 어떤 값을 디바운스할 수 있습니다. 아래는 예시입니다:\n\n```js\nimport { useState, useEffect } from 'react';\n\nconst useDebounce = (value, delay) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n};\n```\n\n이 훅을 사용하면 사용자 입력, API 요청 등을 디바운스할 수 있습니다. 다음은 실용적인 예시입니다:\n\n\n\n```js\n상태로써 App을 만들었어요. \nsearchTerm이란 상태와 setSearchTerm 함수를 만들었고, debouncedSearchTerm은 searchTerm을 500 밀리초로 지연시키는 함수를 사용하고 있어요.\n\nuseEffect 안에서는 debouncedSearchTerm을 감시하며 API 호출을 수행합니다.\n\n<input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />\n\n# useFetch\n\n비동기적으로 데이터를 가져오는 것은 현대 웹 개발에서 흔한 작업입니다. 이를 간단하게 처리해주는 useFetch 훅을 알아봅시다.\n\nimport { useState, useEffect } from 'react';\n\nconst useFetch = (url) => {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(true);\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        const json = await response.json();\n        setData(json);\n      } catch (error) {\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n  return { data, error, loading };\n};\n\n\n\n이 훅은 fetch 요청의 복잡성을 추상화하고 응답, 오류 및 로딩 상태를 제공합니다. 이 훅을 사용하는 방법은 다음과 같습니다:\n\nconst App = () => {\n  const { data, error, loading } = useFetch('https://api.example.com/data');\n\n  if (loading) {\n    return <p>데이터 불러오는 중...</p>;\n  }\n  if (error) {\n    return <p>오류 발생: {error.message}</p>;\n  }\n  return (\n    <div>\n      <ul>\n        {data.map((item) => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\n# useToggle\n\n토글 및 부울 상태를 관리하는 것은 때로는 복잡해질 수 있습니다. useToggle 훅을 사용하면 부울 상태를 쉽게 다룰 수 있습니다. 여기에 간단한 구현 방법이 있습니다:\n\n\n\nimport { useState } from 'react';\n\nconst useToggle = (initialValue = false) => {\n  const [value, setValue] = useState(initialValue);\n  const toggle = () => {\n    setValue((prevValue) => !prevValue);\n  };\n  return [value, toggle];\n};\n\n이 훅은 상태를 토글하는 프로세스를 간단하게 해줍니다. 아래는 사용 예시입니다:\n\nconst App = () => {\n  const [isModalOpen, toggleModal] = useToggle(false);\n\n  return (\n    <div>\n      <button onClick={toggleModal}>모달 토글</button>\n      {isModalOpen && <Modal />}\n    </div>\n  );\n};\n\n# 결론\n\n\n\n커스텀 React 훅은 개발 경험을 혁신적으로 향상시킬 수 있는 강력한 도구입니다. 이 글에서는 useLocalStorage, useMediaQuery, useDebounce, useFetch, 그리고 useToggle이라는 다섯 가지 커스텀 훅을 탐구했습니다. 이러한 훅을 활용하여 제 코드베이스를 최적화하고 코드 재사용성을 높이며 고품질 애플리케이션을 제공할 수 있었습니다. 여러분이 이 훅들을 저만큼 유용하게 느끼셨으면 좋겠네요. 즐거운 코딩 되세요!\n\n이 문서가 유용하다고 생각되면 박수를 치는 것을 고려해보세요. 한 번에 50번까지 박수를 칠 수 있어요!\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나기 전에:\n\n\n\n- 작가를 박수로 격려해주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":6},{"title":"React Nextjs에서 Boxicons 사용하는 방법","description":"","date":"2024-05-12 19:24","slug":"2024-05-12-BoxiconsReactNextjsTypeScriptIntegration","content":"\n<img src=\"/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_0.png\" />\n\n박스 아이콘(Boxicons)은 많은 오픈 소스 아이콘을 제공하여 웹사이트나 애플리케이션에 원활하게 통합할 수 있도록 도와주는 패키지입니다. 이 패키지는 JavaScript로 작성되어 있으며 온라인 저장소에 TypeScript 정의 파일이 없습니다. 이는 TypeScript 프로젝트에 통합하기가 조금 어렵다는 것을 의미합니다. 이 글은 React/Next.js TypeScript 프로젝트에 박스 아이콘을 통합하는 단계별 가이드를 제공합니다.\n\n# Next.JS\n\n## 1. 프로젝트 설정\n\n다음 명령어를 실행하여 Next.js 애플리케이션을 시작하세요.\n\n```js\nnpx create-next-app@latest\n```\n\n프로젝트에 이름을 지정하고 설치 프롬프트에서 기본 옵션을 선택하세요.\n\n```js\n프로젝트 이름은 무엇인가요? boxicons-nextjs-ts\nTypeScript를 사용하시겠습니까? No / Yes\nESLint를 사용하시겠습니까? No / Yes\nTailwind CSS를 사용하시겠습니까? No / Yes\n`src/` 디렉토리를 사용하시겠습니까? No / Yes\nApp Router를 사용하시겠습니까? (추천) No / Yes\n기본 import 별칭을 사용자 지정하시겠습니까? No / Yes\n구성할 import 별칭을 입력해주세요. @/*\n```\n\n다음은 프로젝트 구조가 설정된 Next.js 애플리케이션의 시작 코드를 생성해야 합니다.\n\n![Next.js Starter Code](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_1.png)\n\n## 2. 의존성 설치\n\nBoxicons 설치하기\n\n```js\nnpm install boxicons --save\n```\n\n## 3. 유형 정의\n\n“src\" 디렉토리에 “types\" 폴더를 만들고 그 안에 “boxicons.d.ts\"라는 파일을 생성하세요. 이 파일은 boxicons 패키지의 유형 정의를 담고 있을 것입니다. 다음 코드 스니펫을 \"boxicons.d.ts\" 파일에 붙여넣으세요.\n\nsrc/types/boxicons.d.ts\n\n```js\ndeclare module \"boxicons\" {\n  export type IconName = string;\n}\n```\n\n위의 코드 조각에서 boxicons 패키지를 위한 모듈 선언을 생성합니다. TypeScript가 모듈을 가져올 때 해당 모듈을 해결할 수 있도록 합니다. 또한, \"IconName\"이라는 문자열 타입이 내보내집니다. 이를 통해 아이콘 이름이 모두 문자열임을 보장하고, 발생 가능한 일부 버그를 미리 방지합니다.\n\n## 4. 스타일시트 임포트\n\n프로젝트에 boxicons 스타일시트를 추가하세요. 이는 애플리케이션의 메인 스타일시트 맨 위에 CSS import를 추가하여 수행할 수 있습니다. 기본적으로 Next.js의 \"src/pages\" 디렉토리에 있는 \"global.css\" 파일이 메인 애플리케이션 스타일시트입니다.\n\n동일한 결과를 얻으려면 \"src/pages\" 디렉토리의 \"layout.tsx\" 파일에 헤드 태그에 링크 태그를 추가하면 됩니다.\n\nsrc/pages/layout.tsx\n\n```js\nimport type { Metadata } from \"next\";\nimport { Inter } from \"next/font/google\";\nimport \"./globals.css\";\n\nconst inter = Inter({ subsets: [\"latin\"] });\n\nexport const metadata: Metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode,\n}>) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <link href=\"https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css\" rel=\"stylesheet\"></link>\n      </head>\n      <body className={inter.className}>{children}</body>\n    </html>\n  );\n}\n```\n\nOR\n\nsrc/pages/globals.css\n\n```js\n@import \"~boxicons/css/boxicons.min.css\";\n# OR\n@import url(\"boxicons/css/boxicons.min.css\");\n```\n\n## 5. 아이콘 컴포넌트 생성\n\n애플리케이션에 다양한 \"boxicons\"를 가져올 수 있는 아이콘 컴포넌트를 생성하세요. 이를 위해 \"src\" 디렉터리에 \"components\"라는 폴더를 만들고 그 안에 \"Icon.tsx\" 파일을 만드세요.\n\nsrc/components/Icon.tsx\n\n```js\nimport React from \"react\";\nimport { IconName } from \"boxicons\";\n\ninterface IconProps {\n  name: IconName;\n  size?: string;\n  color?: string;\n}\n\nconst Icon: React.FC<IconProps> = ({ name, size = \"24px\", color = \"\" }) => {\n  return <i className={`bx ${name}`} style={{ fontSize: size, color }} />;\n};\n\nexport default Icon;\n```\n\n`name` 속성은 표시할 아이콘을 변경하는 데 사용됩니다. 사용할 수 있는 모든 아이콘을 확인하려면 boxicons 웹 사이트를 확인하십시오. `size` 및 `color` 속성은 각각 아이콘의 크기 및 색상을 변경하는 데 사용됩니다.\n\n컴포넌트 디렉토리의 내용을 내보내는 \"index.ts\" 파일을 만듭니다. 이는 가져오기를 \"깔끔하게\" 유지하기 위한 것이며, 이 단계를 건너 뛰어도 괜찮습니다.\n\nsrc/components/index.ts\n\n```js\nimport Icon from \"./Icon\";\n\nexport { Icon };\n```\n\n## 6. Icon 사용법\n\n프로젝트 전반에 걸쳐 사용하기 위해 components 디렉토리에서 Icon 컴포넌트를 import합니다. 아래는 예시입니다:\n\nsrc/pages/pages.tsx\n\n```js\nimport { Icon } from \"@/components\";\n\nexport default function Home() {\n  return (\n    <main className=\"flex min-h-screen flex-col items-center justify-center py-24 gap-3\">\n      <Icon name=\"bx-run\" size=\"108px\" />\n      <h2 className=\"text-6xl\">함께 떠나요</h2>\n      <div className=\"flex mt-4 gap-3\">\n        <Icon name=\"bx-rocket\" size=\"64px\" />\n        <Icon name=\"bx-rocket\" size=\"64px\" />\n      </div>\n    </main>\n  );\n}\n```\n\n개발 서버를 실행하여 아이콘이 표시되는지 확인해 보세요.\n\n```js\nnpm run dev\n```\n\nViolaaa 🚀\n\n![image](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_2.png)\n\n이 프로젝트의 소스 코드가 포함된 GitHub 저장소 링크입니다:\n\n[https://github.com/Quarcoo-arc/boxicons-nextjs-ts.git](https://github.com/Quarcoo-arc/boxicons-nextjs-ts.git)\n\n# React\n\nReact와 TypeScript 프로젝트에 boxicons를 통합하는 것은 Next.js와 TypeScript 프로젝트에 통합하는 것과 유사합니다. 그러나 몇 가지 차이가 있습니다. 이를 아래에서 강조했습니다.\n\n## 1. 프로젝트 설정\n\nReact 프로젝트를 설정하는 가장 쉬운 방법은 create-react-app 또는 Vite를 사용하는 것입니다. 저는 Vite를 선호합니다. 왜냐하면 이름이 시사하는 대로 빠르기 때문입니다. Vite는 \"신속\"을 뜻하는 프랑스어 단어이며 /vit/으로 발음합니다. 충분히 어휘적인 얘기는 여기까지 하고 아이콘들을 표시해봅시다 🚀.\n\n다음 명령어를 실행하여 Vite를 사용한 React + TypeScript 프로젝트를 시작하세요:\n\n```js\nnpm create vite@latest\n```\n\n프로젝트 이름 (boxicons-react-ts), 프레임워크 (React), 그리고 변형 (TypeScript)을 옵션에 설정하세요. 프로젝트 디렉토리로 이동하고 애플리케이션 종속성을 설치하세요.\n\n```js\ncd boxicons-react-ts\nnpm install\n```\n\n위 명령들을 실행하면 다음과 같은 폴더 구조를 갖는 프로젝트가 생성됩니다.\n\n![폴더 구조](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_3.png)\n\n## 2. 종속성 설치\n\nboxicons를 설치하세요. Next.JS 부분의 두 번째 섹션에 설명된 대로 진행하시면 됩니다.\n\n## 3. 유형 정의\n\nReact 및 Next.js에 대한 유형 정의 파일을 생성하는 방법은 동일합니다.\n\n## 4. 스타일시트 가져오기\n\nNext.js와 마찬가지로 React에서 boxicons 스타일시트를 가져오는 두 가지 옵션이 있습니다; head 태그 내부에 링크 태그를 사용하거나 CSS를 가져오는 것입니다. 차이점은 src/pages/layout.tsx가 아닌 프로젝트의 루트 디렉토리의 index.html 파일에 링크 태그가 추가된다는 점입니다. 또한 CSS를 가져오는 위치는 src/pages/globals.css가 아닌 React 애플리케이션의 기본 주 스타일시트인 src/index.css에 위치합니다.\n\n한 가지 더 알려드릴게요. 이 CSS import를 사용하면 오류가 발생합니다:\n\n```js\n# 오류가 발생합니다 ❌\n@import \"~boxicons/css/boxicons.min.css\";\n```\n\n이것을 대신 사용하세요:\n\n```js\n# 이것을 대신 사용하세요 ✅\n@import url(\"boxicons/css/boxicons.min.css\");\n```\n\n```css\n@import url(\"https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css\");\n```\n\n## 6. 아이콘 사용법\n\n이제 아이콘 컴포넌트를 가져와 프로젝트 전반에 사용할 수 있습니다. 아래에서 확인할 수 있습니다.\n\nsrc/App.tsx\n\n```jsx\nimport \"./App.css\";\nimport { Icon } from \"./components\";\n\nfunction App() {\n  return (\n    <div>\n      <Icon name=\"bxl-typescript\" size=\"36px\" />\n      <Icon name=\"bx-plus\" size=\"36px\" />\n      <Icon name=\"bxl-react\" size=\"36px\" />\n      <h1>We go again</h1>\n      <Icon name=\"bx-rocket\" size=\"36px\" />\n      <Icon name=\"bx-rocket\" size=\"36px\" />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n개발 서버를 실행해서 아이콘들을 확인해보세요.\n\n```js\nnpm run dev\n```\n\n![아이콘 이미지](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_4.png)\n\n이 프로젝트의 소스 코드가 포함된 GitHub 저장소 링크입니다:\n\n위의 링크를 통해, React/Next.js + TypeScript 프로젝트에서 boxicons를 사용할 준비가 끝났어요. TypeScript 프로젝트에서 typings이 제공되지 않는 JavaScript 패키지를 사용하는 방법도 비슷하게 따를 수 있어요.\n","ogImage":{"url":"/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_0.png"},"coverImage":"/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_0.png","tag":["Tech"],"readingTime":7},{"title":" 당신의 React 프로젝트를 위한 전화 입력 - react-international-phone","description":"","date":"2024-05-12 19:23","slug":"2024-05-12-PhoneinputforyourReactprojectreact-international-phone","content":"\n\n## React 코드베이스에 멋진 국제 전화번호 입력 컴포넌트를 구현해보세요\n\n## 배경 이야기\n\n저는 React를 UI 빌딩 라이브러리로 사용하는 내 작업 프로젝트 중 하나에서 휴대전화 번호를 입력하는 컴포넌트를 구현하는 문제를 마주쳤어요. 사용하던 한 인기 있는 전화 입력 라이브러리를 사용하는 컴포넌트가 있었지만, 스타일링하기 불편하고 작업하기도 어려웠어요.\n\n일부 npm 패키지를 조사한 후, 제 요구 사항을 충족시키는 라이브러리가 없다는 것을 알게 되었어요:\n\n\n\n- 전화 번호 형식은 모든 입력 구성 요소에 쉽게 통합할 수 있어야 합니다 (Material UI, Chakra UI, Ant Design 등과 같은 모든 UI 프레임워크와 통합 가능).\n- 쉽게 스타일링할 수 있는 독립적인 전화 번호 입력 구성 요소를 제공해야 합니다.\n- 입력 시 편안한 느낌이어야 합니다. 입력 캐럿 위치가 제대로 처리되어야 하며, 복사/붙여넣기/실행 취소/다시 실행이 예상대로 작동해야 합니다.\n- 입력된 전화 번호를 확인할 수 있는 방법을 제공해야 합니다.\n\n그래서 이러한 기능을 모두 지원하는 내 라이브러리를 작성하기로 결정했습니다.\n\n# react-international-phone\n\n🎉 react-international-phone을 소개합니다! 🎉\n\n\n\n라이브러리는 React 애플리케이션용 전화 입력 컴포넌트를 제공합니다. 국제 지원을 포함한 전화 번호를 위한 사용자 정의 가능하고 쉽게 사용할 수 있는 입력 필드를 제공합니다.\n\n![전화 입력 컴포넌트](https://miro.medium.com/v2/resize:fit:642/1*4NHcF2JMyXfeqVlCRJD9PQ.gif)\n\nreact-international-phone의 주요 기능:\n\n- 🌈 입력란 내에서 타이핑, 복사/붙여넣기, 실행취소/다시실행이 자연스럽게 작동\n- 🔍 전화 번호 형식(국가 추측과 함께)\n- 🏁 국가 깃발 렌더링(Twemoji와 함께)\n- ✅ 기본 제공 전화 유효성 검사\n- 🔒 제3자 의존성 없음(낮은 번들 크기)\n- 🔧 쉽게 사용자 정의 가능합니다\n\n\n\n## 기본 사용법\n\n이 라이브러리는 통합하기 매우 쉽습니다. PhoneInput 컴포넌트와 스타일을 가져오기만 하면 됩니다. 다음은 기본 사용법 코드 스니펫입니다:\n\n```js\nimport { useState } from 'react';\nimport { PhoneInput } from 'react-international-phone';\nimport 'react-international-phone/style.css';\n\nconst App = () => {\n  const [phone, setPhone] = useState('');\n\n  return (\n    <div>\n      <PhoneInput\n        defaultCountry=\"ua\"\n        value={phone}\n        onChange={(phone) => setPhone(phone)}\n      />\n    </div>\n  );\n};\n```\n\nCodeSandbox에서 라이브 데모를 확인하세요\n\n\n\n## UI 라이브러리 통합\n\nreact-international-phone은 Material UI, Ant Design, 또는 Chakra UI와 같은 거의 모든 기존 UI 라이브러리와 통합할 수 있습니다.\n\n보통 사용하는 입력 필드와 함께 전화 번호 형식 지정 로직을 제공하는 usePhoneInput 훅을 사용하고, 국가 선택 드롭다운을 제공하는 `CountrySelector/` 하위 구성 요소를 함께 사용할 수 있습니다.\n\nMUI, Chakra, 그리고 Antd를 사용한 라이브러리 사용 예제가 있습니다:\n\n\n\n## ✔️ 유효성 검사\n\n이 패키지는 (당연히) 전화번호 유효성 검사를 제공하는 usePhoneValidation 훅을 제공합니다.\n\n```js\nconst [phone, setPhone] = useState(\"\");\nconst phoneValidation = usePhoneValidation(phone);\n\n// 이제 `phoneValidation.isValid`를 사용하여 전화번호가 유효한지 확인할 수 있습니다\n```\n\n## 🔧 사용자 정의\n\n\n\n라이브러리는 전화 입력의 기본 동작과 모양을 사용자 지정하는 방법을 제공합니다. 다음은 가능한 작업의 일부입니다:\n\n- 프롭 또는 CSS를 통해 `PhoneInput/` 컴포넌트의 어떤 부분에도 사용자 정의 스타일 적용\n- 다이얼 코드 강제 (선택된 국가 다이얼 코드를 삭제/변경하지 못하도록 함)\n- 국가 선택기 드롭다운 숨기기\n- 초기 국가 자동 입력 비활성화\n- 국가 다이얼 코드 숨기기\n- 국가 목록 필터링 및 수정\n\n이러한 사용 사례의 데모를 이 스토리북에서 확인할 수 있습니다:\nhttps://react-international-phone-storybook.vercel.app/\n\n## 📚 문서\n\n\n\n아래에 전체 설명서를 찾을 수 있습니다:\nhttps://react-international-phone.vercel.app/\n\n## 🌟 감사합니다\n\nreact-international-phone 패키지가 마음에 드시면 GitHub 저장소에 별을 남겨주세요.\n문제, 버그, 또는 질문이 있으면 GitHub에 이슈를 열거나 토론을 해주세요.\n\n도움이 되었다면 박수를 잊지 마세요!\n즐거운 코딩하세요 👋","ogImage":{"url":"/assets/img/2024-05-12-PhoneinputforyourReactprojectreact-international-phone_0.png"},"coverImage":"/assets/img/2024-05-12-PhoneinputforyourReactprojectreact-international-phone_0.png","tag":["Tech"],"readingTime":3},{"title":"ESLint 구성 이해 eslintrcjs 대 eslintrc 대 eslintrcjson","description":"","date":"2024-05-12 19:22","slug":"2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson","content":"\n\nESLint은 JavaScript 생태계에서 중심 도구로 작용하여 개발자가 코드 품질을 유지하고 코딩 표준을 준수할 수 있도록 돕습니다. 그러나 ESLint를 구성하는 것이 항상 간단하지는 않습니다, 특히 .eslintrc.js, .eslintrc 및 .eslintrc.json과 같은 다양한 구성 형식 중에서 선택해야 할 때에는 더욱 그렇습니다. 각 형식의 세부 사항을 자세히 살펴보고 그 차이와 가장 적합한 사용 사례에 대해 알아봅시다.\n\n# .eslintrc.js 해석하기\n\n.eslintrc.js는 JavaScript 파일로, JavaScript 코드를 사용하여 ESLint를 동적으로 구성할 수 있는 구성 객체를 익스포트합니다. 이 형식은 복잡한 로직과 환경별 구성을 설정에 포함시킬 수 있는 가장 탁월한 유연성을 제공합니다.\n\n다음은 .eslintrc.js 파일이 어떻게 보일 수 있는지 한 눈에 들어보세요:  \n\n\n\n<img src=\"/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_0.png\" />\n\n# JSON 형식의 .eslintrc 탐구하기\n\n.eslintrc는 ESLint 구성을 캡슐화하는 JSON 형식의 파일입니다. .eslintrc.js와 달리 이 형식은 JavaScript 표현식이나 동적 로직을 지원하지 않습니다. 더 단순하고 선언적인 설정 방식을 제공합니다.\n\n다음은 .eslintrc 파일의 예시입니다:\n\n\n\n\n![이미지](/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_1.png)\n\n# .eslintrc.json 이해하기\n\n.eslintrc.json은 .eslintrc와 유사하게 ESLint 구성을 JSON 형식으로 제공합니다. 파일 이름 규칙이 다르지만 동일한 목적을 제공합니다. 두 형식 모두 대부분의 프로젝트에서 간편하게 사용할 수 있도록 간결하고 사용이 간편합니다.\n\n![이미지](/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_2.png)\n\n\n\n# 비교: 적합한 옵션 찾기\n\n- 유연성: .eslintrc.js는 유연성 면에서 우수하며, 개발자들이 동적 논리를 포함하고 다양한 환경에 기반한 구성을 맞춤 설정할 수 있습니다.\n\n- 간결함: .eslintrc 및 .eslintrc.json은 더 간단하고 직관적인 방식으로, 표준 구성 요구 사항을 갖는 프로젝트에 이상적입니다.\n\n- 커뮤니티 표준: .eslintrc.js가 복잡한 설정에 선호되는 반면, .eslintrc 및 .eslintrc.json은 간단한 구성에 선호되며, 커뮤니티 표준에 부합합니다.\n\n# 결론: 개발 실무 능력 강화\n\nESLint 구성 형식 선택은 프로젝트 복잡도와 팀 선호도에 달려 있습니다. .eslintrc.js는 뛰어난 유연성을 제공하나, .eslintrc 및 .eslintrc.json은 대부분의 프로젝트에 대한 간소화된 옵션을 제공합니다. 이 차이를 이해하면 개발자들이 ESLint를 효과적으로 구성하여 일관된 코드 품질을 유지할 수 있습니다.\n\n\n\n본질적으로, 당신의 선호 및 프로젝트 요구 사항에 따라 ESLint 구성 형식을 선택합니다. 그럼에도 불구하고, .eslintrc.js의 동적 성격은 복잡한 설정과 전문화된 구성에 대한 매력적인 선택으로 작용합니다.\n\n# 인사이트 공유\n\n당신이 선호하는 ESLint 구성 형식은 무엇이며, 그 이유는 무엇인가요? 프로젝트에 ESLint를 구성하는 동안 어려움을 겪은 적이 있나요? 혹은 혜택을 본 적이 있나요? 아래 댓글에서 당신의 경험과 인사이트를 공유해주세요!","ogImage":{"url":"/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_0.png"},"coverImage":"/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_0.png","tag":["Tech"],"readingTime":2}],"page":"142","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":14,"currentPageGroup":7},"__N_SSG":true}