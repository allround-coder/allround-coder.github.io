{"pageProps":{"posts":[{"title":"Angular 17 데이터 공유하기 BehaviorSubject를 활용한 간단한 가이드","description":"","date":"2024-05-14 14:45","slug":"2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide","content":"\n\n<img src=\"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png\" />\n\n앵귤러 애플리케이션에서 컴포넌트 간 데이터 흐름을 관리하는 것은 복잡해질 수 있습니다. 이때 비동기 프로그래밍을 위한 강력한 라이브러리인 RxJS가 유용합니다. RxJS는 데이터 스트림을 처리하는 다양한 연산자와 Subject를 제공하며, 그 중에서 BehaviorSubject는 중요한 역할을 합니다. BehaviorSubject는 상태를 관리하고 Angular 애플리케이션 내에서 변경 사항을 전파하는 데 기본적인 구조로 나타납니다. 이 블로그 포스트에서는 BehaviorSubject를 사용하여 컴포넌트 간 데이터를 공유하는 방법에 대해 알아보겠습니다.\n\n# BehaviorSubject란 무엇인가요?\n\n기본적으로 BehaviorSubject는 RxJS 라이브러리에서 제공하는 Observable의 한 유형입니다. 특정 이벤트가 발생할 때만 값을 방출하는 전통적인 Observable과 달리, BehaviorSubject는 최신 값을 유지하고 새로운 구독자에게 즉시 전달합니다.\n\n\n\n# 주요 기능:\n\n## 초기값으로의 초기화:\n\nBehaviorSubject를 생성할 때, 개발자는 초기값을 지정합니다. 이 초기값은 이후 발생하는 값들의 시작점으로 작용하며, 새로운 구독자가 구독 시 즉시 업데이트를 받을 수 있도록 보장해줍니다.\n\n## 상태 유지:\n\n\n\nBehaviorSubject의 독특한 특징 중 하나는 최신 값을 유지 및 구독자에게 전달할 수 있는 능력입니다. 이 행동은 추가 이벤트를 트리거할 필요 없이 컴포넌트가 가장 최신 데이터와 동기화되도록 합니다.\n\n## next() 메서드:\n\nnext() 메서드를 통해 개발자는 BehaviorSubject가 보유한 값을 동적으로 업데이트할 수 있습니다. 이 메커니즘은 응용 프로그램 전체에 이어지는 데이터 전파를 원활하게 처리하여 반응성 및 반응적인 동작을 가능하게 합니다.\n\n# 실제 구현:\n\n\n\n## 1. 빈 Angular 프로젝트를 생성하세요\n\n```js\nng new behaviorsubject-demo\n```\n\n## 2. 서비스 및 컴포넌트 생성\n\n이 프로젝트에서는 아래와 같은 UI를 만들 예정입니다. 이를 위해 인용구 데이터를 가진 Quote 서비스를 생성하고, 인용구를 업데이트하는 컴포넌트와 인용구를 표시하는 컴포넌트를 만들 예정입니다.\n\n\n\n아래 명령어를 실행하여 서비스와 컴포넌트를 생성하세요.\n\n```js\nng generate service services/quote\nng generate component components/display-quote\nng generate component components/update-quote\n```\n\n폴더 구조는 아래와 같이 보일 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_2.png\" />\n\n## 3. 서비스에 아래 코드를 추가하세요\n\n```js\n// quote.service.ts\n\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class QuoteService {\n\n  constructor() {}\n\n  // 명언 속성을 선언하고 초기화합니다. BehaviorSubject이 될 예정\n  qoute = new BehaviorSubject(\"Hello world\");\n\n  // BehaviorSubject를 Observable로 노출합니다\n  currentQuote = this.qoute.asObservable();\n\n  // BehaviorSubject 값을 업데이트하는 함수\n  updateQuote(newQuote: string){\n    this.qoute.next(newQuote);\n  }\n}\n```\n\n## 4. 명언 서비스에서 명언 값을 표시하기\n\n\n\n```typescript\n// display-quote.component.ts\n\n...\n\nimport { QuoteService } from '../../services/quote.service';\n\n...\nexport class DisplayQuoteComponent {\n\n  constructor(private quoteService: QuoteService){}\n  \n  currentQuote: string = '';\n\n  ngOnInit(): void {\n    // 현재 시간 값을 가져오기 위해 quote 서비스의 currentQuote 속성을 구독합니다\n    this.quoteService.currentQuote.subscribe(\n      // 컴포넌트의 속성을 업데이트합니다\n      quote => this.currentQuote = quote\n    );\n  }\n}\n\n// display-quote.component.html\n\n<h2>{currentQuote}</h2>\r\n```\n\n이제 display-quote 컴포넌트에서 quote 서비스의 초기 인용구를 볼 수 있게 될 것입니다\n\n## 5. 인용구 값 업데이트\n\n```typescript\n// update-quote.component.ts\n\nimport { Component } from '@angular/core';\nimport { QuoteService } from '../../services/quote.service';\n\n...\nexport class UpdateQuoteComponent {\n\n  constructor(private quoteService: QuoteService){}\n\n  quote = '';\n\n  // 서비스에서 인용구를 업데이트하는 함수\n  submitHandler(){    \n   this.quoteService.updateQuote(this.quote);\n    this.quote=\"\";\n  }\n}\n\n// update-quote.component.html\n\n<div>\n  <input type=\"text\" [(ngModel)]=\"quote\" placeholder=\"새로운 인용구를 작성하세요\" />\n  <button (click)=\"submitHandler()\">제출</button>\n</div>\r\n```\n\n\n\n이제 update-quote 컴포넌트에서 인용구 값을 업데이트할 수 있게 되었고, 이는 display-quote 컴포넌트에 직접적으로 반영될 것입니다. 아래 다이어그램에서 프로젝트 내 데이터의 흐름을 확인할 수 있습니다.\n\n![Diagram](/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_3.png)\n\n# 결론:\n\n- 이 예제에서 인용구 서비스는 BehaviorSubject를 사용하여 인용구를 저장합니다. display-quote 컴포넌트는 currentQuote observable을 구독하여 최신 인용구를 가져와 로컬 변수를 업데이트합니다.\n- Angular 개발에서 BehaviorSubject는 상태를 관리하고 컴포넌트 및 서비스 간 반응형 동작을 용이하게 하는 강력한 도구로 사용됩니다. 개발자들은 이를 활용하여 동적 데이터 흐름을 쉽게 다룰 수 있는 견고하고 반응적인 Angular 애플리케이션을 구축할 수 있습니다.\n\n\n\n아래 GitHub 저장소에서 최종 코드를 얻어보세요.","ogImage":{"url":"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png"},"coverImage":"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"더 나은 코드를 작성하기 위한 5가지 빠른 팁과 기술","description":"","date":"2024-05-14 14:43","slug":"2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode","content":"\n\n오늘 깨끗한 코드를 작성하는 데 도움이 되는 몇 가지 간단한 팁과 기술이 있습니다.\n\n![이미지](/assets/img/2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode_0.png)\n\n만약 이 기사를 읽고 있다면, 코드를 작성하는 사람이실 겁니다. 아마도 상당량의 코드를 작성하고 계신 것 같군요... 아마도 그 코드 작성이 즐거운 활동이며 중요한 일일 것입니다. 코딩을 좋아하거나 싫어할지 모르지만, 개발자로서 실제로 코드를 작성하는 시간보다 10배 정도 더 많은 시간을 코드를 읽는 데 사용하고 있는 것이 사실입니다.\n\n다른 사람의 코드를 읽는 것, 아쉽게도 때로는 우리 자신의 코드를 읽는 것은 가끔 슬픈 경험일 수 있습니다. 이해하기 어려운, 지저분하고 맡의 코드들이죠. 우리는 모두 본 적이 있습니다. 우리 모두가 작성해 봤습니다...\n\n\n\n조금만 신경을 쓰지 않으면 우리의 코드베이스는 금방 엉망이 될 수 있어요. 엉망이 된 코드를 소유하는 비용이 높아요! 회사에게도 높은 비용이 들고요. 정신적 안녕에도 높은 비용이 들어요. 부패한 코드는 우리 프로젝트를 저주받은 묘지로 만들어 버려요. 심지어 가장 경험 많은 엔지니어들조차 가기를 꺼리게 해요. 다행히도 간단한 몇 가지 기술을 사용해서 쉽게 코드를 개선할 수 있어요:\n\n- 조건부(if)문을 설명적인 메소드로 추상화\n- 주석을 선언적인 코드로 대체\n- 더 깨끗한 함수 작성\n- 다형성을 사용하여 switch 문 제거\n- 끝에서 시작하기 — 목적 코드를 생각하고 그 목적 지점에 도달하는 방법을 고민하기\n\n이러한 5가지 팁을 실제 코드 예제와 함께 설명할 거예요. 예제는 대부분의 사람들이 익숙한 JavaScript를 사용했지만, 다른 언어에도 쉽게 적용할 수 있어요. 모든 예제 코드는 제 깃허브에서 확인할 수 있어요.\n\n시작하기 전에, 깨끗한 코드와 깨끗한 코드를 작성하는 기술에 대해 간략히 얘기해 볼게요.\n\n\n\n## 깨끗한 코드\n\n여기서 궁극적인 목표는 깨끗한 코드를 만드는 것입니다. 많은 주니어 개발자들이 깨끗한 코드를 작성하는 것은 우리가 가지고 있는 기술이거나 시간이 지나면 개발되는 기술이라고 생각합니다. 사실상, 심지어 가장 경험이 많은 개발자조차 첫 번째 시도때 모든 날 깔끔하고 우아한 코드를 작성하지는 않습니다.\n\n좋은 품질의 코드를 작성하는 것은 반복 작업이며, 대부분의 기술은 리팩토링 기술입니다.\n\n## 빨강, 초록, 리팩터링\n\n\n\n더 좋은 코드를 작성하는 핵심은 신뢰할 만한 테스트를 갖고 있어서 코드를 리팩터링할 때 여전히 작동하는지 알 수 있다는 것입니다. 처음에는 종종 우리가 원하는대로 작동하는지 확인하기 위해 지저분한 절차적 코드와 몇 가지 테스트를 작성할 것입니다. 가장 중요한 단계는 다음 단계입니다 - 여기서 우리는 코드를 리팩터링하고 정리하여 더 이해하기 쉽고 유지보수하기 쉬운 상태로 만드는 것입니다.\n\n![image](/assets/img/2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode_1.png)\n\n너무 많은 개발자들은 코드를 정리하는 마지막 단계를 건너뛰곤 합니다. 테스트가 없으면 우리는 전혀 코드를 정리하기 어렵다고 느낄 가능성이 높습니다. 구글은 이에 대한 훌륭한 철학을 가지고 있습니다:\n\n## 1. 조건부(if) 문을 설명적인 메서드로 추상화하세요\n\n\n\n첫 번째 리팩터링 기법은 아마 가장 쉽게 구현할 수 있는 기법입니다. 아래 코드는 Nightclub(클럽)에 입장을 허용할 수 있는지 확인합니다. 그들은 입장이 허용되거나 대기열로 보내지거나 거절될 것입니다.\n\n첫 번째 조건부 (if) 문은 꽤 복잡하며, 무슨 일이 벌어지고 있는지 파악하기 어려운데요. 우리는 이를 명확하게 명명된 함수로 추상화할 수 있으며, 독자들이 이해할 수 있게 되죠. 또한 몇 개의 '마법' 숫자(18과 500)가 여기저기 돌아다니고 있습니다. 이것들이 무엇을 위한 것인지 명확하지 않습니다.\n\n조건부 문을 잘 명명된 함수로 추상화하면 읽기가 훨씬 쉬워집니다. '마법' 숫자들에도 유용한 이름이 지정되어 독자가 이 숫자들이 어떤 용도로 사용되는지 이해할 수 있도록 도와줍니다.\n\n## 2. 주석을 선언적인 코드로 대체\n\n\n\n프로그래밍에서 주석은 가장 남용되는 언어 기능 중 하나입니다. 잘 쓰여진 풍부한 선언형 코드는 그 자체로 말을 할 수 있어서 전혀 주석이 필요하지 않습니다.\n\n우리는 코드로 이해하기 어려운 경계 케이스가 있는 드문 상황에서만 주석을 작성해야 합니다.\n\n다음 코드는 포럼의 질문과 관련된 상위 10개 평점이 높은 답변을 검색합니다.\n\n이전 코드는 쓸데없는 주석으로 가득 차 있습니다. 거의 모든 주석은 함수와 변수의 이름을 더 잘 붙이거나 설명하는 코드를 잘 명명된 함수로 추출함으로써 제거할 수 있습니다.\n\n\n\n정리된 버전의 코드는 더 작은 함수로 분해되었고, 각 함수의 이름이 명확히 무엇을 하는지 설명하도록 되어 있어요. top 변수가 만들어져서 딱 10개의 아이템만 선택될 것임을 명확하게 보여줍니다.\n\n## 3. 더 깔끔한 함수 작성하기\n\n함수 작성에 있어서, 일반적으로 함수가 작을수록 더 나아요. 작은 함수는 이해하기 쉽고 재사용하기 쉽고 컴퓨터가 최적화하기 쉬워요.\n\n함수는 한 가지 일만 해야 해요. 만약 getDataAndThenMapAndSendToCustomer 같은 이름을 사용해야 한다면, 함수를 분해해야 한다고 생각해보세요.\n\n\n\n\"더 깨끗한 함수를 설계하는 데 도움이 되는 몇 가지 규칙이 있어요:\n\n- 함수는 작아야 해요 (이상적으로 15줄 미만)\n- 함수의 이름은 설명적이고 의미 있는 이름을 가져야 해요\n- 함수는 데이터를 검색하거나 변경해야 해요. 둘 다 하면 안 돼요.\n- 함수는 하나의 추상화 수준에서 작동해야 해요\n- 가능한 경우 else 조건 사용을 피해야 해요\n\n다음 코드는 텍스트 라인의 단어 수를 세는데 사용됩니다. 계산에서 제외할 ignoreWords 집합을 전달할 수 있어요.\n\n이전 예제는 대부분의 규칙을 어기고 있어서 이해하기 어렵습니다. 깊게 중첩된 루프와 if/else 문이 있어서 인지 복잡성이 높아져요. 또한 많은 서로 다른 추상화 수준에서 작업하고 있습니다.\"\n\n\n\n2번째 예시는 복잡한 방법을 3단계로 분해합니다: 단어를 포함해야 하는지 확인, 한 줄에 있는 단어 수 세기 및 각 줄에서의 카운트를 집계하는 것입니다.\n\n## 4. 다형성을 사용하여 switch 문을 제거\n\nswitch 문은 종종 코드 냄새로 여겨집니다. 만약 무언가를 위해 switch 문을 사용해야 한다면, 코드에 한 번만 나타나야 합니다.\n\n비슷한 switch 문이 코드 여기저기 흩어져 있다면, 그것은 코드를 더 나은 방식으로 추상화할 수 있는 좋은 신호일 수 있습니다. 종종 그것을 할 수 있는 가장 좋은 방법은 다형성을 사용하는 것입니다.\n\n\n\n다양한 채널을 사용하여 알림을 게시할 수있는 Notifier 클래스를 살펴보겠습니다. '이메일' 채널은 언제든지 알림을 전송할 수 있지만, 'SMS' 채널은 업무 시간 외에 알림을 '예약'해야 합니다.\n\n이전 코드에서는 유사한 스위치 문이 많은 곳에서 사용되고 있습니다. 비효율적일 뿐만 아니라 유지 관리도 어렵습니다. 새로운 채널이 필요하면 여러 스위치 문을 업데이트해야한다는 것을 기억해야합니다.\n\n코드를 정리하기 위해 채널을 다른 NotificationService 구현으로 분해할 수 있습니다: EmailService, SmsService\n\n이제 우리가 해야 할 일은 코드에서 어떤 유형의 NotificationService를 생성할 지 결정하는 것뿐입니다.\n\n\n\n우리는 스위치 문을 하나 제외한 모든 것을 제거했고, 결과 코드가 훨씬 간단해졌어요.\n\n이런 종류의 문제에 잘 맞는 또 다른 패턴은 '팩토리' 패턴입니다. NoticationService의 생성을 팩토리 클래스로 추출할 수 있어요.\n\n이제 우리의 Notifier 클래스를 더 간단하게 만들 수 있어요.\n\n## 5. 끝에서 시작하기\n\n\n\n이 마지막 기술은 리팩토링 기술이 아닌 목록 중 유일한 기술입니다. 이것은 경험이 풍부한 시니어 개발자가 코드를 작성하는 방식과 경험이 적은 주니어 개발자가 접근하는 방식 사이의 차이를 명확히 보여주는 기술입니다.\n\n설명하기 전에 몇 가지 예시를 살펴보겠습니다.\n\n주니어가 솔루션을 만들 때 종종 코드를 작성하기 전에 거의 계획이나 설계를 하지 않고 바로 코드를 작성하는 경우가 많습니다. 그들은 먼저 많은 양의 코드를 작성하고 나중에 어떻게 메서드나 테스트를 둘러싸야 할지를 결정합니다. 그 결과로 나오는 클래스, API 및 메서드 시그니처는 보통 설계가 잘못되어 사용하기 어렵고 변경하기 어렵습니다.\n\n반면에 경험이 풍부한 개발자는 먼저 고수준 API, 클래스 및 메서드 시그니처에 가장 적합한 설계에 대해 생각한 뒤, 코드로 어떻게 이를 달성할지 고려합니다. 문제는 Fluent, OOP, 함수형, 데이터 주도형 프로그래밍을 필요로 하는가요? 소비자는 어떻게 솔루션을 사용할 것인가요? 어떻게 테스트할 것인가요?\n\n\n\n만약 이 내용이 익숙하게 들린다면, 당신은 맞습니다. 이것이 바로 Test-Driven Development (TDD)의 본질입니다. TDD는 우리가 코드가 어떻게 사용될지 (테스트를 통해) 고민하게 만들기 때문에 훌륭합니다. 우리가 어떻게 구현할 것인지 알기 전에 코드가 어떻게 사용될지 고려합니다.\n\nTDD를 좋아하지 않는 사람도 있고, 그것도 괜찮습니다. 만약 이를 좋아하지 않는다면, 코드를 작성하기 전에 최종 모습을 상상해보는 방식으로 이 기술을 적용할 수 있습니다. 팀을 위해 공유 라이브러리 코드를 작성할 기회가 있다면, 소비자의 관점에서 최종 결과물을 고려하는 좋은 방법이 될 수 있습니다.\n\n깨끗한 코드를 작성하는 것은 과정입니다. 누구나 경험의 양에 관계없이 거쳐야 하는 과정입니다. 이러한 팁과 기술이 이 과정을 더 나은 방식으로 진행할 수 있도록 도와줄 것이라고 희망합니다.\n\n모든 코드 예제와 테스트는 아래의 제 GitHub 저장소에서 찾을 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode_0.png"},"coverImage":"/assets/img/2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode_0.png","tag":["Tech"],"readingTime":5},{"title":"Nodejs에서 CPU 집약적 작업 최적화하기 워커 스레드 가이드","description":"","date":"2024-05-14 14:40","slug":"2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads","content":"\n\n<img src=\"/assets/img/2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads_0.png\" />\n\n# 소개\n\nNode.js는 주로 단일 스레드 이벤트 루프 모델에서 작동합니다. 이는 즉, 코드가 한 번에 한 가지 작업만 수행할 수 있다는 뜻입니다. 그러나 Node.js는 또한 libuv와 같은 라이브러리를 통해 디스크에서 파일을 읽는 것과 같은 I/O 작업을 백그라운드 스레드에 지원하는 메커니즘도 제공합니다. 이러한 백그라운드 스레드는 파일 I/O, 네트워크 요청 및 DNS 조회와 같은 작업을 처리하여 주 스레드가 다른 이벤트를 계속 처리할 수 있도록 합니다.\n\n이제, 복잡한 수학 문제를 해결하거나 대형 이미지 또는 비디오 압축을 처리하는 등 매우 어려운 작업이 있다고 상상해보십시오. Node.js가 이러한 유형의 작업을 처리할 때, 완전히 점령되어 다른 작업을 완료할 때까지 아무 것도 할 수 없습니다. 이는 다른 작업이 대기 중인 경우, 그 일이 완료될 때까지 기다려야 한다는 것을 의미합니다.\n\n\n\n컴퓨터에 여러 개의 프로세서(코어)가 있더라도 Node.js는 이러한 어려운 작업을 자동으로 분산시키지 않습니다. 모든 것을 처리하기 위해 하나의 프로세서, 하나의 코어만 사용하며, 다른 것들도 사용 가능한 상황에서도 이를 계속 사용합니다. 따라서 현대 컴퓨터는 여러 코어로 더 많은 처리량을 갖고 있지만, Node.js는 이러한 어려운 작업에 대해 그것들을 완전히 활용하지 못합니다. 이는 응용 프로그램이 많은 작업을 처리해야 할 경우 속도를 늦출 수 있습니다.\n\n이를 극복하기 위해 Node.js는 \"worker-threads\"라는 모듈을 도입했습니다. 이를 사용하면 서로 다른 작업을 동시에 처리할 수 있는 별도의 스레드를 생성할 수 있습니다. 한 스레드가 작업을 마치면 결과를 메인 스레드로 다시 보내어 기다리지 않고 계속 작업할 수 있습니다. 따라서 워커 스레드를 사용하면 CPU 집약적인 작업이 메인 스레드를 더 이상 막지 않고 큰 작업을 여러 스레드로 나누어 속도를 높일 수 있습니다.\n\nNode.js 앱과 CPU 집약적 작업이 메인 스레드를 차단하는 노드를 통해 워커 스레드를 탐색해 보겠습니다. CPU 집약적 작업을 다른 스레드로 오프로드하여 메인 스레드를 차단하지 않고 작업을 진행할 수 있도록 워커 스레드 모듈을 사용할 것입니다. 마지막으로 CPU-바운드 작업을 나누어 네 개의 스레드가 병렬로 작업할 수 있도록 하여 작업을 가속화할 것입니다.\n\n# 프로젝트 및 종속성 설정하기\n\n\n\n시작하기 전에 프로젝트 디렉터리를 만들어 주세요:\n\n```js\nmkdir multi-threading\ncd multi-threading\n```\n\n이후, npm init 명령어를 사용하여 npm을 통해 프로젝트 디렉터리를 초기화해주세요:\n\n```js\nnpm init -y\n```\n\n\n\n다음으로, 다음 종속성을 설치하세요:\n\n```js\nnpm install express\n```\n\nExpress를 사용하여 블로킹 및 논블로킹 엔드포인트를 갖는 서버 애플리케이션을 만들 것입니다. 워커 스레드 모듈은 Node.js와 함께 제공되므로 별도로 설치할 필요가 없습니다.\n\n# 프로세스와 스레드 이해하기\n\n\n\nCPU 바운드 작업을 시작하기 전에, 컴퓨터에서 하나 이상의 코어를 가지고 있는 프로세스와 스레드가 어떤 것인지 이해하는 것이 중요합니다.\n\n## 프로세스\n\n프로세스란 운영 체제에서 실행 중인 프로그램입니다. 각각의 프로세스는 자체 메모리를 가지고 있으며, 다른 실행 중인 프로그램의 메모리에 접근할 수 없습니다. 무한 루프가 포함된 Node 프로그램을 만들어보겠습니다. 이 프로그램은 실행 중지되지 않고 계속 실행될 것입니다.\n\nprocess.js 라는 이름의 파일을 생성하고 아래 코드를 입력해주세요:\n\n\n\n```js\nconst process_name = process.argv.slice(2)[0];\nlet count = 0;\nwhile (true) {\n  count++;\n  if (count === 200 || count === 400) {\n    console.log(`${process_name}: ${count}`);\n  }\n}\n```\n\n이 프로그램을 node 명령어를 사용하여 실행해봅시다:\n\n```js\nnode process.js A &\n```\n\nA는 프로그램으로 전달된 명령행 인수로, process_name 변수에 저장됩니다. &는 노드 프로그램이 백그라운드에서 실행되도록 하며, 이것을 통해 셸에서 더 많은 명령을 입력할 수 있습니다.\n\n\n\n```js\n결과\n[1] 15228\nA: 200\nA: 400\n```\n\n숫자 7754는 운영 체제가 할당한 프로세스 ID입니다. A: 200 및 A: 400은 프로그램의 출력입니다.\n\nnode 명령을 사용하여 프로그램을 실행하면(가정으로 Node.js를 참조하는 경우), 프로세스가 생성됩니다. 운영 체제는 프로그램을위한 메모리를 할당하고, 컴퓨터의 디스크에서 프로그램 실행 파일을 찾아 메모리로 로드하는 작업과 같은 작업을 처리합니다. 그런 다음 프로그램에 프로세스 ID(PID)를 할당하고 실행을 시작합니다. 이 단계에서 프로그램은 프로세스가됩니다.\n\nNode 프로세스에 대한 간단한 요약을 얻으려면:\n\n\n\n```js\nps | grep node\n```\n\n```js\n출력\n15228 pts/1    00:00:15 node\n```\n\n하나의 프로그램에서 여러 프로세스를 생성할 수 있어요. 예를 들어, 다음 명령어를 사용해서 서로 다른 인수를 가진 세 개의 프로세스를 생성하고 백그라운드로 실행할 수 있어요:\n\n```js\nnode process.js B & node process.js C & node process.js D &\n```\n\n\n\n위의 명령을 실행한 후 출력 결과가 다음과 비슷할 수 있지만 순서가 다를 수 있습니다:\n\n```js\n출력:\n[1] 15925\n[2] 15926\n[3] 15927\nB: 200\nC: 200\nB: 400\nD: 400\nC: 400\nD: 400\n```\n\n출력을 주의 깊게 살펴보면 실행 순서가 고정되어 있지 않다는 것을 알 수 있습니다. B, C 및 D의 순서로 시작했지만 다른 순서로 완료될 수 있습니다. 이러한 동작의 이유는 OS가 각 프로세스를 실행할 시기를 결정하는 스케줄링 알고리즘을 가지고 있기 때문입니다.\n\n단일 코어 기계에서는 프로세스가 동시에 실행됩니다. 이는 OS가 일정 시간 동안 프로세스를 전환하는 것을 의미합니다. 예를 들어, 프로세스 D가 한정된 시간 동안 실행된 다음에는 상태가 어딘가에 저장되고 OS가 프로세스 B를 실행할 수 있도록 일정 시간을 예약하고, 이와 같은 방식으로 계속 진행됩니다. 이것은 모든 작업이 완료될 때까지 계속됩니다. 출력에서는 각 프로세스가 완료된 것처럼 보일 수 있지만 실제로는 OS 스케줄러가 계속해서 프로세스 간을 전환하고 있는 것입니다.\n\n\n\n멀티 코어(4코어) 운영 체제에서는 각 프로세스를 동시에 각 코어에서 실행하도록 OS가 스케줄링합니다. 이를 병렬 처리라고 합니다. 그러나 4개의 코어에 4개의 프로세스를 생성하면(총 8개의 프로세스), 각 코어는 두 개의 프로세스를 동시에 실행하여 완료될 때까지 처리합니다.\n\n# 스레드\n\nNode.js의 스레드는 프로세스와 유사하지만 단일 프로세스의 메모리 내에서 작동합니다. 프로세스는 자체 메모리 공간을 갖지만 각 스레드는 부모 프로세스의 메모리를 공유합니다. Node.js에서 프로세스를 생성하면 worker_threads 모듈을 사용하여 JavaScript 작업을 동시에 실행하기 위해 여러 스레드를 생성할 수 있습니다. 스레드는 메시지 전달이나 프로세스 메모리 내에서 데이터를 공유함으로써 서로 통신합니다. 프로세스와는 달리 스레드를 생성할 때 운영 체제에서 추가 메모리가 필요하지 않아 가벼우면서 작업을 병렬로 실행하기에 효율적입니다.\n\n스레드 실행 시, 프로세스와 유사하게 동작합니다. 단일 코어 시스템에 여러 스레드가 있는 경우 운영 체제는 정기적으로 스레드 간 전환을 수행하여 각 스레드가 단일 CPU에서 직접 실행되는 차례를 부여합니다. 다중 코어 시스템의 경우 OS는 모든 코어에 걸쳐 스레드를 스케줄링하여 JavaScript 코드를 동시에 실행할 수 있도록 합니다. 사용 가능한 코어보다 더 많은 스레드가 생성된 경우, 각 코어는 여러 스레드를 동시에 처리하여 리소스 사용을 최적화합니다.\n\n\n\n# Node.js에서 숨겨진 스레드들\n\nNode.js는 입출력 (I/O) 작업을 보다 효율적으로 처리하기 위해 추가 스레드를 활용하기 때문에 종종 \"다중 스레드\"라고 불립니다. 작동 방식은 다음과 같습니다:\n\n도입에서 설명한 바와 같이 JavaScript 자체는 단일 스레드형이기 때문에 한 번에 한 가지 작업만 처리합니다. 프로그램이 파일을 읽거나 네트워크 요청을 만들어야 할 때, 이러한 작업이 완료될 때까지 기다리며 주 스레드를 차단할 수 있습니다.\n\n그러나 Node.js는 libuv 라이브러리를 구현하여 4개의 추가 스레드를 Node.js 프로세스에 제공합니다. 이러한 스레드를 이용하여 I/O 작업을 별도로 처리하며, 작업이 완료되면 이벤트 루프가 해당 I/O 작업과 관련된 콜백을 마이크로태스크 대기열에 추가합니다. 주 스레드의 호출 스택이 비워지면 콜백이 호출 스택에 푸시되고 실행됩니다. 명확히 하기 위해 주어진 I/O 작업과 관련된 콜백은 병렬로 실행되지 않지만, 파일을 읽거나 네트워크 요청 등의 작업은 추가 스레드의 도움으로 병렬로 처리됩니다. I/O 작업이 완료되면 해당 콜백이 주 스레드에서 실행됩니다.\n\n\n\n위의 네 개 스레드에 추가로 V8 엔진은 자동 가비지 수집과 같은 작업을 처리하기 위해 두 개의 스레드도 제공합니다.\n\n이 말은 모든 노드 프로세스가 총 일곱 개의 스레드를 가지고 있다는 것을 의미합니다. 우리의 process.js 파일을 다시 실행하여 백그라운드에서 실행되도록 확인해보겠습니다:\n\n```js\nnode process.js A &\n```\n\n이제 스레드를 확인하기 위해 top 명령어를 사용하고 그에게 프로세스 ID를 전달해보겠습니다.\n\n\n\n```js\ntop -H -p 19821\n```\n\n위 명령을 실행하면 출력물은 다음과 유사합니다:\n\n![image](/assets/img/2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads_1.png)\n\n출력물에서 알 수 있듯이, Node.js 프로세스에는 총 일곱 개의 스레드가 있습니다: JavaScript를 실행하는 주 스레드 하나, Node.js 스레드 네 개, 그리고 V8 스레드 둘입니다.\n\n\n\n이제 Node.js 프로세스의 스레드에 대해 알았으니, 다음 섹션에서 CPU 바운드 작업을 수행하고 주요 스레드를 관찰해 보겠습니다.\n\n# 워커 스레드를 사용하지 않고 CPU 바운드 작업 생성하기\n\nExpress 서버를 생성하여 두 가지 경로를 가지는 서버를 만들어봅시다: blocking과 non-blocking(컴퓨터 집약적 작업 실행).\n\n```js\nconst express = require(\"express\");\n\nconst app = express();\nconst port = 8000;\n\napp.get(\"/non-blocking\", (req, res) => {\n  res.status(200).send(\"비차단 페이지\");\n});\n\napp.get(\"/blocking\", async (req, res) => {\n  let counter = 0;\n  for (let i = 0; i < 20000000000; i++) {\n    counter++;\n  }\n  res.status(200).send(`결과는 ${counter} 입니다`);\n});\n\napp.listen(port, () => {\n  console.log(`포트 ${port}에서 서버 실행 중`);\n});\n```\n\n\n\n위의 코드 블록에서 Express.js를 사용하여 HTTP 서버를 만들었습니다. CPU 집약적인 작업을 실행하는 /non-blocking route와 /blocking route를 만들었습니다. 200 억 번을 반복하는 for 루프를 만들어 각 반복마다 카운터 변수를 1씩 증가시킵니다.\n\n아래 명령어를 실행하여 서버를 시작해 봅시다:\n\n```js\nnode index.js\n\n출력:\nServer running on port: 8000\n```\n\n이제 http://localhost:8000/non-blocking을 방문하면 즉시 응답을 받을 수 있습니다. 그 다음으로 새 탭에서 http://localhost:8000/blocking을 열고 다시 http://localhost:8000/non-blocking을 열면 즉시 응답을 받지 못하고 페이지가 계속로드를 시도하는 것을 볼 수 있습니다. /non-blocking route는 단지 /blocking route가 응답 결과를 반환할 때만 결과를 반환합니다. 결과는 20000000000입니다.\n\n\n\n이유는 CPU 바운드 루프로 인해 메인 스레드가 차단되기 때문입니다. 메인 스레드가 차단되면 Node.js는 CPU 바운드 작업이 완료될 때까지 어떤 요청도 처리할 수 없습니다. 따라서 /non-blocking route로 동시에 수천 개의 GET 요청이 있는 경우, /blocking route로의 단일 방문은 앱이 반응하지 않게 만들 수 있습니다.\n\n이제 CPU 집약적 작업이 애플리케이션에 미치는 영향을 이해했으니, 이제 약속(promises)을 사용하여 메인 스레드를 차단하지 않도록 노력해보겠습니다.\n\n# 약속(promises) 사용하여 CPU 바운드 작업 오프로드하기\n\n개발자들이 CPU 바운드 작업으로 인한 차단 효과를 알게 되면 약속(promises)을 사용하여 코드를 차단되지 않게 만들어보려 합니다. 이들은 readFile() 및 writeFile()과 같은 차단되지 않는 약속 기반 I/O 메서드 사용에 대한 지식에서 비롯됩니다. 그러나 알고 계시다시피, I/O 작업은 Node.js의 숨겨진 스레드를 사용하지만, CPU 바운드 작업은 아닙니다. 그럼에도 불구하고 이 섹션에서는 CPU 바운드 작업을 약속으로 감싸 차단되지 않도록 시도할 것입니다. 이 방법은 작동하지 않지만, 다음 섹션에서 할 일인 워커 스레드 사용의 가치를 알 수 있습니다.\n\n\n\n우리의 index.js 파일을 프로미스를 위해 수정해 봅시다:\n\n```js\nconst express = require(\"express\");\n\nconst app = express();\nconst port = 8000;\n\napp.get(\"/non-blocking\", (req, res) => {\n  res.status(200).send(\"non-blocking 페이지\");\n});\n\nfunction calculateCount() {\n  return new Promise((resolve, reject) => {\n    let counter = 0;\n    for (let i = 0; i < 20_000_000_000; i++) {\n      counter++;\n    }\n    resolve(counter);\n  });\n}\n\n\napp.get(\"/blocking\", async (req, res) => {\n  const counter = await calculateCount();\n  res.status(200).send(`결과: ${counter}`);\n});\n\napp.listen(port, () => {\n  console.log(`서버가 포트에서 실행 중: ${port}`);\n});\n```\n\n웹 브라우저에서 http://localhost:8000/blocking을 방문하고 로드될 때, 빠르게 http://localhost:8000/non-blocking 탭을 새로 고쳐보세요. 알 수 있듯이, non-blocking 라우트도 영향을 받아 /blocking 라우트가 로딩을 완료할 때까지 모두 기다립니다. 라우트가 여전히 영향을 받기 때문에, 프로미스는 자바스크립트 코드를 병렬로 실행시키지 않고 CPU 바운드 작업을 비차단형으로 만드는 데 사용할 수 없습니다.\n\n# CPU 바운드 작업 완화를 위해 worker-threads 사용하기\n\n\n\n이제 메인 스레드를 차단하지 않기 위해 worker-thread 모듈을 사용할 것입니다.\n\nworker.js 파일을 만들고 다음 코드를 추가해봅시다:\n\n```js\nconst { parentPort } = require(\"worker_threads\");\n\nlet counter = 0;\nfor (let i = 0; i < 20000000000; i++) {\n  counter++;\n}\n\nparentPort.postMessage(counter);\n```\n\n그 다음에 index.js를 수정해주세요:\n\n\n\n```js\nconst express = require(\"express\");\nconst { Worker } = require(\"worker_threads\");\n\nconst app = express();\nconst port = 8000;\n\napp.get(\"/non-blocking/\", (req, res) => {\n  res.status(200).send(\"non-blocking 페이지\");\n});\n\napp.get(\"/blocking\", async (req, res) => {\n  const worker = new Worker(\"./worker.js\");\n  worker.on(\"message\", (data) => {\n    res.status(200).send(`결과는 ${data} 입니다`);\n  });\n  worker.on(\"error\", (msg) => {\n    res.status(404).send(`오류 발생: ${msg}`);\n  });\n});\n\napp.listen(port, () => {\n  console.log(`서버가 포트 ${port}에서 실행 중입니다.`);\n});\n```\n\n파일을 저장한 후 서버를 실행하세요:\n\n```js\nnode index.js\n```\n\n웹 브라우저에서 http://localhost:8000/blocking 탭을 다시 방문해보세요. 이 페이지가 로딩을 완료하기 전에 http://localhost:8000/non-blocking 탭을 모두 새로고침 해보세요. 이제 /blocking 루트가 로딩을 마치기를 기다리지 않고 바로 로딩되는 것을 알 수 있을 겁니다. 이는 CPU 바운드 작업이 다른 스레드로 오프로드되어 메인 스레드가 모든 요청을 처리하기 때문입니다.\n\n\n\n\n요런식으로 워커 스레드를 사용하여 CPU 집약 작업을 블로킹되지 않게 만들 수 있어요.\n\n- 기사 영감: Stanley Ulili and Rachel Lee\n- Danish Shaikh | LinkedIn\n- Danish Shaikh | Github","ogImage":{"url":"/assets/img/2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads_0.png"},"coverImage":"/assets/img/2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads_0.png","tag":["Tech"],"readingTime":10},{"title":"뉵트 3에서 데이터 가져오기","description":"","date":"2024-05-14 14:38","slug":"2024-05-14-DataFetchingwithNuxt3","content":"\n\n\n![이미지](/assets/img/2024-05-14-DataFetchingwithNuxt3_0.png)\n\nTable of Contents\n\n- 소개\n- $fetch\n- useFetch\n- useAsyncData\n- 옵션\n- 캐싱 및 재검색\n\n# 소개\n\n\n\n\n데이터 가져오기와 관련된 Nuxt 3의 세계에서는 useFetch, useAsyncData, 그리고 $fetch 세 가지 강력한 도구를 갖추고 있습니다. 흥미로운 점은 이것들이 각기 다른 목적을 위해 사용되는 두 가지 조합 가능한 함수와 하나의 내장 라이브러리로 깔끔하게 분류될 수 있다는 것입니다. 이 모든 것을 이해하기 위해선, 단순함을 위해 차이점부터 알아야 합니다.\n\n# $fetch\n\n먼저 $fetch의 차이를 정의해야 한다고 생각합니다;\n\n- $fetch는 Nuxt에서 HTTP 요청을 만들기 위한 유틸리티 함수입니다. $fetch는 Vue 앱이나 API 라우트 내에서 HTTP 요청을 만들기 위해 ofetch 라이브러리를 사용합니다.\n- $fetch는 서버 측에서 클라이언트 측으로 상태를 전달할 수 없으며, 따라서 서버 및 클라이언트 측 모두에 대해 두 번 요청해야 합니다. 이 상황은 다음과 같은 코드로 콘솔과 터미널에서 기본적으로 볼 수 있습니다;\n\n\n\n```js\nconst dataFetch = await $fetch('https://jsonplaceholder.typicode.com/photos')\nconsole.log(dataFetch)\n```\n\n![Data Fetching with Nuxt](/assets/img/2024-05-14-DataFetchingwithNuxt3_1.png)\n\n두 번째로, useAsyncData의 차이점은 다음과 같이 설명할 수 있습니다:\n\n- useAsyncData는 컴포넌트 내에서 데이터 가져오기 프로세스를 조직적으로 관리할 수 있게 해주는 복합 기능입니다.\n- useAsyncData의 특징은 key와 handler 함수를 둘 다 필요로 한다는 점입니다. 예를 들어, useAsyncData를 사용하면 axios, graphql 또는 firebase와 같은 다양한 라이브러리나 API를 활용할 수 있습니다. 또한 useAsyncData와 nuxtApp 인수를 함께 사용하면 Nuxt 애플리케이션의 다른 기능에 액세스할 수 있어 데이터, 상태, 변수를 공유할 수 있습니다.\n- useAsyncData는 서버 사이드 렌더링 중 미리 데이터를 서버에서 가져와 클라이언트 측에서 재요청 없이 사용할 수 있습니다. 따라서 $fetch와 달리 데이터를 서버 측에서 클라이언트 측으로 재요청 없이 전송할 수 있습니다.\n\n\n\n```js\nconst data = await useAsyncData('photos', () => $fetch('https://jsonplaceholder.typicode.com/photos'))\nconsole.log(data)\n```\n\n![Image](/assets/img/2024-05-14-DataFetchingwithNuxt3_2.png)\n\n보시다싶이 클라이언트 측에서 사진을 가져오는 순서가 아니라 터미널에서 가져오는 것을 볼 수 있습니다.\n\n마지막으로 foruseFetch에 대해 말하자면, useAsyncData와 같은 목적을 가졌지만 더 구체적인 방법으로 데이터를 가져오는 데 사용할 수 있습니다.\n\n\n\n- useFetch는 URL을 사용하여 데이터를 가져오는 데 사용하는 다른 조합 가능한(composable)입니다.\n- 이 함수와 거의 동등하면서 더 간단하다고 말할 수 있습니다:\n\n![이미지](/assets/img/2024-05-14-DataFetchingwithNuxt3_3.png)\n\n차이점을 확인했으므로, 어떻게 사용하는지 알아보고 세부 사항을 자세히 살펴볼 수 있습니다.\n\n# useFetch\n\n\n\n가장 간단한 형태로 useFetch 컴포저블을 사용해보고, 그 기능을 분석해봅시다;\n\n```js\nconst data = useFetch('https://jsonplaceholder.typicode.com/photos')\nconsole.log(data)\n```\n\n![이미지](/assets/img/2024-05-14-DataFetchingwithNuxt3_4.png)\n\n보시다시피 우리가 얻는 결과는 약속(promise)이고, 이는 미래에 완료될 값이 담겨 있는 비동기 작업을 나타냅니다. 따라서 우리는 await을 사용해야 합니다. 또한, 몇 가지 중요한 값들을 관찰할 수 있는데, 이들을 어떻게 사용하고 그 의미를 이해하는지 알아보겠습니다.\n\n\n\n- data: 비동기 작업의 결과물을 나타내는 RefImpl 객체입니다.\n- error: 데이터 요청이 실패할 때 오류 객체를 포함하는 ObjectRefImpl입니다. 데이터 요청이 성공한 경우 null 값을 받습니다.\n- execute: useFetch 함수에 전달된 매개변수인 execute는 데이터 요청을 다시 시작하는 데 사용되는 함수입니다. lazy 매개변수가 useFetch 함수에서 true로 설정된 경우에 사용됩니다. 이 경우 데이터 요청은 route가 로드된 후에 해결되며, execute는 데이터 요청을 수동으로 시작하는 데 사용될 수 있습니다.\n- pending: 비동기 작업이 완료되었는지를 나타내는 RefImpl 객체입니다. RefImpl의 값이 true이면 작업이 계속 진행 중이라는 것을 의미합니다.\n- refresh: useFetch 함수에서 반환된 refresh 함수는 데이터를 다시 가져오는 데 사용할 수 있는 함수입니다. refresh 함수는 useFetch 함수를 다시 호출하여 데이터를 업데이트합니다. 데이터가 변경되거나 다시 로드해야 할 때 유용합니다.\n- status: 비동기 작업의 완료 상태를 나타내는 RefImpl 객체입니다. 성공, 오류, 대기 중 또는 진행 중과 같은 값들을 가질 수 있습니다.\n\n# useAsyncData\n\n사용할 때는 useFetch와 동일한 결과가 나올 것이므로, 제대로 사용합시다;\n\n```js\nconst { data: photos, error, execute, pending, refresh, status} = await useAsyncData('photos', () => $fetch('https://jsonplaceholder.typicode.com/photos'))\n```\n\n\n\n이 사용 예에서는 가져오기에 대한 'photos' 키 값을 지정했습니다.\n\n```js\n// promise.all을 사용한 예제\nconst { data: postCard, error, execute, pending, refresh, status } = await useAsyncData('post-card', async () => {\n  const [posts, users, comments] = await Promise.all([\n    $fetch('https://jsonplaceholder.typicode.com/posts'),\n    $fetch('https://jsonplaceholder.typicode.com/users'),\n    $fetch('https://jsonplaceholder.typicode.com/comments')\n  ])\n  return { posts, users, comments }\n})\n```\n\n키 지정\n\nuseAsyncData 함수에서 키를 지정하지 않으면 Nuxt가 자동으로 하나를 생성합니다. 이 키는 useAsyncData 함수가 위치한 파일 이름과 행 번호를 기반으로합니다. 그러나 이 키는 때때로 잘못될 수 있거나 충돌할 수 있습니다. 따라서 useAsyncData 함수에서 키를 명시하는 것이 좋습니다. 키 매개변수는 데이터 가져오기에 속하는 고유한 값을 가져야합니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-DataFetchingwithNuxt3_5.png\" />\n\n# 옵션\n\n옵션은 composable에 대한 더 깊은 수준의 제어를 제공하며, useFetch와 useAsyncData에 대해 공통 값들을 취합니다. 이들을 통해 어떤 것을 달성할 수 있는지 자세히 살펴보겠습니다:\n\nLazy\n\n\n\n기본적으로 fetch composables의 기능 중 하나는 데이터를 가져오는 동안 라우트를 로딩하는 것을 방지하는 것입니다. 이는 데이터를 가져오는 예상 시간 동안 라우트 로딩이 일시 중지되어 데이터가 준비된 후 라우트가 로드됩니다. 그러나이 함수의 lazy 매개변수를 true로 설정하여 데이터 가져오기가 라우트 로드를 차단하지 않도록 허용할 수 있습니다. 이 경우 데이터를 가져오는 예상 시간 동안에도 라우트의 로드가 계속되며 결과적으로 데이터가 라우트 로드 후에 로드됩니다.\n\n기본적으로 두 가지 방법으로 lazy하게 만들 수 있습니다;\n\n```js\n// useFetch()\nconst { data } = await useFetch('https://jsonplaceholder.typicode.com/photos', {\n    lazy: true\n})\n// useAsyncData()\nconst { data }= await useAsyncData('photos', () => $fetch('https://jsonplaceholder.typicode.com/photos'), {\n    lazy: true\n})\n```\n\n```js\n// useFetch()\nconst { data } = await useLazyFetch('https://jsonplaceholder.typicode.com/photos')\n\n// useAsyncData()\nconst { data } = await useLazyAsyncData('photos', () => $fetch('https://jsonplaceholder.typicode.com/photos'))\n```\n\n\n\n클라이언트 전용 데이터 가져오기\n\n기본적으로 데이터 가져오기 구성 요소는 서버 측과 클라이언트 측에서 모두 작동합니다. 클라이언트 측에서만 실행하는 것이 서버 측에서 데이터를 가져올 필요가 없는 경우에 유용할 수 있습니다. 예를 들어 데이터가 사용자 상호작용에 따라 달라지거나 SEO에 민감하지 않은 데이터에 이 접근 방식을 사용할 수 있습니다.\n\n페이지가 처음로드 될 때 발생하는 대기 상태는 클라이언트 측 탐색 중에는 경험되지 않습니다. lazy 옵션과 함께 사용하면 초기 렌더링 시 필요하지 않은 데이터에 특히 유용할 수 있으며, 특히 클라이언트 측 탐색에 대해 유용합니다.\n\n```js\nconst { data } = await useFetch('https://jsonplaceholder.typicode.com/photos', {\n    lazy: true,\n    server: false,\n})\n```\n\n\n\n페이로드 크기 최소화\n\nNuxt 3을 사용하면 데이터를 가져올 때 pick 및 transform 옵션을 사용하여 페이지 로드를 줄일 수 있습니다. pick 옵션으로 초기 데이터에서 원하는 키 값을 가져올 수 있고, transform 기능으로 모든 데이터에서 특정 키 값을 가져올 수 있습니다.\n\n데이터를 가져오고 받는 과정에서는 변경사항이 없으며, 대신 서버 측에서 수신한 데이터를 처리하고 클라이언트 측으로는 특정 값만 보냅니다.\n\n```js\n// Pick\nconst { data: photos, error, pending, refresh, execute, status } = await useFetch('https://jsonplaceholder.typicode.com/photos?&_limit=50', {\n  pick: ['url', 'id']\n})\n// Transform\nconst {data: photos, pending, error, execute, refresh, status} = await useFetch('https://jsonplaceholder.typicode.com/photos', {\n  transform: (photos) => {\n    return photos.map(photo => ({ title: photo.title, url: photo.url }))\n  }\n})\n```\n\n\n\n와치\n\n와치 옵션을 사용하면 값을 모니터링하고 해당 값이 변경될 때마다 페치 프로세스를 다시 트리거할 수 있습니다. Immediate가 false로 설정되어 있을 때는 페치 프로세스를 완전 수동으로 수행합니다. 사용법은 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-14-DataFetchingwithNuxt3_6.png)\n\nDeep\n\n\n\n깊이 옵션을 사용하면 데이터가 ref 객체에서 어떻게 반환되는지 제어할 수 있습니다. 기본적으로 deep 값은 true로 설정되어 있어 데이터가 깊게 반응하는 ref 객체로 반환됩니다. 이는 그 안의 항목 중 하나에 대한 변경 사항이 모두 추적된다는 것을 의미합니다. 이 옵션은 일반적으로 성능을 최적화하고 데이터 내의 모든 변경을 추적할 필요가 없을 때 사용됩니다.\n\n중복 제거\n\ndedupe 옵션은 데이터 검색 시 동일한 키로 데이터를 여러 차례 반환하는 것을 방지하는 데 사용됩니다. 이 옵션의 기본값은 cancel로, 새 요청이 발생할 때 기존 요청을 취소합니다. 다른 옵션인 defer는 대기 중인 요청이 있을 때 새 요청을 만들지 않습니다. 이러한 옵션을 사용하면 데이터 검색이 더 효율적이고 성능 지향적으로 이루어집니다.\n\n# 캐싱과 재검색\n\n\n\nNuxt 3를 사용하면 서버 쪽에서 데이터를 가져와 클라이언트 쪽으로 전송하는 데 useFetch 및 useAsyncData 컴포저블을 사용하는 방법을 탐색했습니다. 이렇게 하면 양쪽에서 데이터를 가져 오는 필요가 없어지죠. 그러나 클라이언트 측 탐색 중에 반복적인 데이터 가져 오기 작업에 대한 문제가 여전히 존재합니다. 이때 캐싱이 우리를 구해줍니다. 할당 된 키 값에 따라 캐시에서 이러한 데이터를 가져 오므로 클라이언트 측 탐색 중에 이러한 데이터를 반복적으로 가져 오는 필요가 사라집니다. 대신 캐시를 일시적 저장소로 활용하여 짧은 기간 동안 사용합니다.\n\n캐시 데이터 가져 오기\n\n일반적으로 캐시에서 데이터를 검색할 때 useNuxtData를 사용하면 데이터를 성공적으로 가져올 수 있습니다. 그러나 이것만으로 충분하지 않을 수 있습니다. 또한 캐시에 데이터가 없는 경우에만 조건부로 데이터를 가져 오는 경우, 페이지 간 탐색 중에 캐시에서 데이터를 활용하고 데이터를 다시 가져 오지 않을 겁니다. 여기서 필요한 컴포저블은 useNuxtApp입니다. 그러나 먼저 수행해야 할 작은 추가 사항이 있습니다.\n\n```js\nexport default defineNuxtConfig({\n// ...\n  experimental: {\n    payloadExtraction: true,\n  },\n});\n```\n\n\n\n그런 다음, 우리는 useFetch 및 useAsyncData 조합을 사용하여 getCacheData 옵션을 이용해 작은 함수를 작성할 것입니다. 이 방법을 통해 데이터가 캐시에 없을 때에만 fetch 작업이 실행됩니다.\n\n```js\nconst nuxtApp = useNuxtApp()\nconst { data: photos, error} = await useFetch('https://jsonplaceholder.typicode.com/photos?_limit=5', {\n  key: 'photos',\n  getCachedData(key) {\n    return nuxtApp.payload.data[key] || nuxtApp.static.data[key]\n  }\n})\n```\n\nuseNuxtData\n\n이 조합을 사용하면 지정된 키를 사용하여 데이터를 쉽게 검색하거나 새로 고칠 수 있습니다. 사용 예시는 다음과 같습니다:\n\n\n\n```js\nconst { data: cachedPhotos } = useNuxtData('photos')\n```\n\n여기서 캐시에서 데이터를 직접 가져오는 것이에요. 사용자가 시작한 변경사항 또는 다른 이유로 데이터를 다시 가져와 캐시를 새로 고치는 필요가 있을 때는 refreshNuxtData가 아주 편리한 방법일 수 있어요. 이렇게 하면 데이터를 다시 불러오게 돼요:\n\n```js\nconst refreshData = async () => {\n  await refreshNuxtData('photos')\n}\n```","ogImage":{"url":"/assets/img/2024-05-14-DataFetchingwithNuxt3_0.png"},"coverImage":"/assets/img/2024-05-14-DataFetchingwithNuxt3_0.png","tag":["Tech"],"readingTime":9},{"title":"최대 컨텐츠 로딩 시간LCP을 향상시키는 방법","description":"","date":"2024-05-14 14:36","slug":"2024-05-14-HowtoImproveLargestContentfulPaintLCP","content":"\n\n![이미지](/assets/img/2024-05-14-HowtoImproveLargestContentfulPaintLCP_0.png)\n\n가장 큰 콘텐츠 페인트(LCP)는 웹 사이트의 로딩 성능을 평가하는 중요한 지표입니다. 이는 페이지에서 사용자에게 가장 큰 콘텐츠 요소가 보이기까지 걸리는 시간을 나타냅니다. 이 요소는 일반적으로 이미지, 비디오 또는 큰 텍스트 블록입니다. LCP가 왜 중요한가요? 사용자 경험에 직접적인 영향을 미치기 때문입니다.\n\n온라인 쇼핑을 한다고 상상해보세요. 제품 페이지를 클릭했을 때 제품 이미지가 올라오는 데 오랜 시간이 걸린다면, 참을성을 잃고 사이트를 나갈 수도 있습니다. 이때 LCP가 중요한 역할을 하며, 사용자가 중요한 콘텐츠가 나타날 때까지 기다리는 데 걸리는 시간을 측정합니다.\n\n# 현재 LCP 지표를 점검해봅시다\n\n\n\n최적화 작업을 시작하기 전에 지금 어디에 서 있는지 알아야 합니다. Google PageSpeed Insights나 Lighthouse와 같은 도구들이 여기서 가장 좋은 도우미가 될 거에요. 웹사이트를 돌려보고 결과를 분석해 보세요.\n\n예를 들어, 제품 페이지에서 LCP 점수가 4초라고 해봅시다. 이것은 꽤 높은 점수로, 사용자들이 기본 제품 이미지를 볼 수 있기까지 상당한 시간을 기다려야 한다는 것을 나타냅니다.\n\n# 이미지 최적화\n\n이미지는 종종 높은 LCP 점수의 원인이 된다. 이런 시나리오를 고려해 보세요: 온라인 매거진을 운영하고 기사들이 이미지가 많이 들어가 있습니다. 만약 이러한 이미지들이 최적화되지 않았다면, LCP가 영향을 받을 수 있습니다.\n\n\n\n이를 해결하기 위해 이미지를 압축하고 크기를 조절하세요. 이 작업에는 여러 도구와 플러그인이 있습니다. 또한 WebP와 같은 최신 이미지 형식을 사용해보세요. WebP는 더 작은 파일 크기로 높은 품질을 제공합니다. 예를 들어, 2MB 크기의 JPEG 이미지를 WebP 형식으로 변환하면 품질에 눈에 띄는 손실 없이 파일 크기를 200KB로 줄일 수 있습니다.\n\n# 서버 응답 시간 최소화\n\n느린 서버 응답은 LCP에 큰 영향을 줄 수 있습니다. 전자 상거래 웹사이트를 운영한다고 상상해보세요. 서버가 사용자 요청에 3초가 걸린다면, 그 3초가 LCP에 추가됩니다!\n\n서버 성능을 향상시키려면 서버 측 캐싱을 구현하세요. 자주 액세스되는 콘텐츠를 더 빨리 제공하기 위해 서버 측 캐싱을 사용하는 것이 좋습니다. 또한 사용자에게 더 가까운 서버에서 콘텐츠를 제공하여 서버 응답 시간을 줄이기 위해 콘텐츠 전송 네트워크 (CDN)를 사용하는 것도 고려해보세요.\n\n\n\n# 콘텐츠 전달 최적화\n\n콘텐츠 전달은 LCP 최적화의 또 다른 중요한 측면입니다. 전 세계 뉴스 웹 사이트를 운영한다고 가정해 봅시다. 뉴욕에 서버가 있지만 호주에 있는 사용자가 사이트에 액세스하려고 하면 그 사용자에게 콘텐츠가 도달하는 데 더 오랜 시간이 걸릴 것입니다.\n\n이것이 CDN이 유용한 이유입니다. CDN은 전 세계 여러 서버에 콘텐츠를 분산하여 사용자가 지리적으로 가까운 서버에서 액세스할 수 있도록 합니다. 이렇게 함으로써 콘텐츠의 이동 속도를 줄이고, 궁극적으로 LCP를 개선합니다.\n\n# 렌더링 차단 리소스 줄이기\n\n\n\n렌더링이 차단되는 자원인 JavaScript 및 CSS는 페이지 로딩 속도를 늦출 수 있습니다. 만약 무거운 JavaScript 라이브러리와 CSS 파일이 있는 웹사이트를 운영 중이라고 상상해보세요. 사용자가 사이트에 접속하면, 그들의 브라우저는 이러한 자원을 모두 로드할 때까지 컨텐츠를 표시하기 전에 멈춰야 합니다.\n\n최적화를 위해 렌더링을 차단하는 JavaScript 및 CSS 사용을 최소화하세요. 비필수 스크립트에 대해 비동기적으로 로드하여, 이러한 자원이 완전히 로드되기 전에도 페이지가 렌더링을 시작할 수 있도록 합니다.\n\n# 화면 상단 콘텐츠에 우선순위를 둡니다\n\n화면 상단 콘텐츠란 스크롤 없이 사용자에게 보이는 콘텐츠를 말합니다. 사용자가 더 빠른 초기 경험을 제공하기 위해 이 콘텐츠를 먼저 로드하는 것이 중요합니다.\n\n\n\n예를 들어, 블로그를 운영 중이라면 제목, 주요 이미지 및 소개 텍스트가 다른 내용보다 먼저 로드되도록하세요. 사용자들은 나머지 페이지가 백그라운드에서 계속로드될 때 독자적으로 읽기를 시작할 수 있어야 합니다.\n\n# 브라우저 캐싱\n\n브라우저 캐싱은 사용자의 장치에 정적 자산을 로컬로 저장하여 LCP를 줄이는 강력한 기술입니다. 이는 사용자가 사이트를 다시 방문할 때, 브라우저가 모든 자산을 다시 다운로드 할 필요가 없어 더 빠른 로드 시간을 보장합니다.\n\n브라우저 캐싱을 구현하기 위해, 다양한 유형의 콘텐츠에 적절한 캐시 만료 헤더를 설정할 수 있습니다. 예를 들어, 이미지, 스타일시트 및 스크립트를 일정 기간 동안 캐시하도록 서버를 구성하여 반복 다운로드를 줄여줄 수 있습니다.\n\n\n\n```js\n<! — 브라우저 캐싱을 위한 샘플 Apache 구성 →\n<IfModule mod_expires.c>\n ExpiresActive on\n ExpiresByType text/css \"access plus 1 year\"\n ExpiresByType image/jpeg \"access plus 1 month\"\n ExpiresByType image/png \"access plus 1 month\"\n</IfModule>\n```\n\n# 폰트 최적화\n\n폰트도 LCP에 영향을 미칠 수 있습니다. 다양한 폰트와 폰트 두께를 사용하면 추가로 로딩 시간이 소요될 수 있습니다. 폰트를 최적화하려면 사용하는 폰트와 변형의 수를 제한하세요.\n\n예를 들어, 여섯 가지 서로 다른 폰트 두께를 사용하는 대신 두 가지나 세 가지만 사용하는 것을 고려해보세요. 또한, font-display CSS 속성을 사용하여 폰트 로딩을 제어할 수 있습니다. font-display: swap;과 같은 설정은 폰트가 완전히 로드되지 않은 경우에도 텍스트가 보이도록 보장하여 레이아웃 변동을 방지합니다. \n\n\n\n```js\n/* 폰트 표시 방식 예시 */\n@font-face {\n font-family: 'Roboto';\n src: url('roboto.woff2') format('woff2');\n font-display: swap;\n}\n```\n\n# 반응형 디자인\n\n오늘날 다양한 기기에서 사용되는 세상에서는, 반응형 디자인은 LCP(Largest Contentful Paint)를 줄이는 데 중요합니다. 모바일 폰부터 대형 데스크탑 디스플레이까지 다양한 화면 크기에 맞게 웹사이트가 우아하게 적응하도록 해야 합니다.\n\n예를 들어, 전자상거래 사이트를 운영 중이라면, 제품 이미지가 작은 화면에 맞게 크기를 조정하고 적절하게 재구성되도록 확인하세요. 사용자의 장치에 따라 다른 이미지 크기를 제공하여 최적의 로드 시간을 보장하는 `srcset` 속성과 같은 반응형 이미지 기술을 사용하세요.\n\n\n\n\n```js\n<! — 반응형 이미지를 위해 srcset을 사용한 예시 →\n<img srcset=\"image.jpg 1024w,\n     image-800.jpg 800w,\n     image-400.jpg 400w\"\n     sizes=\"(min-width: 768px) 50vw, 100vw\"\n     src=\"image.jpg\" alt=\"반응형 이미지\">\n```\n\n# 컨텐츠 전달 우선순위화\n\nLCP를 줄이기 위해 컨텐츠 전달을 최적화하는 것이 중요합니다. 중요한 리소스를 우선적으로 다운로드하려면 프리로딩(preloading) 및 프리페칭(prefetching)과 같은 리소스 힌트를 사용할 수 있습니다. 이러한 힌트를 통해 브라우저에게 어떤 리소스를 먼저 가져와야 하는지에 대한 정보를 제공합니다.\n\n예를 들어, 상호 작용 기능에 필요한 큰 JavaScript 파일이 있다면, `link rel=\"preload\"` 태그를 사용하여 브라우저에 가능한 빨리 로드하도록 지시할 수 있습니다.\n\n\n\n\n```js\n<!— JavaScript 파일을 사전로드하는 예시 →\n<link rel=\"preload\" href=\"script.js\" as=\"script\">\n```\n\n이 힌트들을 적절히 활용하십시오. 리소스를 너무 많이 사전로드하는 것은 불필요한 로드 시간으로 이어질 수 있습니다.\n\n# 정기적인 성능 테스트\n\nLCP 최적화는 계속되는 과정이며, 정기적인 성능 테스트는 진행 상황을 추적하고 새로운 문제를 식별하는 데 중요합니다. Google PageSpeed Insights, Lighthouse 또는 WebPageTest와 같은 도구를 사용하여 정기적으로 LCP 점수를 평가하십시오.\n\n\n\n\n효율 저하 알림을 설정하여 문제를 신속하게 해결할 수 있도록 하세요. 일관된 테스트와 모니터링은 웹사이트가 시간이 지남에 따라 최적의 LCP를 유지하도록 도와줍니다.\n\n# 콘텐츠 관리 시스템(CMS) 업데이트\n\n워드프레스와 같은 콘텐츠 관리 시스템을 사용 중이라면, CMS와 해당 플러그인/테마가 업데이트되어 있는지 확인하세요. CMS 업데이트에는 성능 향상과 버그 수정이 포함되어 있어 LCP에 긍정적인 영향을 미칠 수 있습니다.\n\nCMS와 플러그인을 업데이트하지 않으면 성능을 저하시키는 오래된 코드가 발생할 수 있으므로 정기적으로 업데이트를 확인하고 적용하는 것을 습관으로 만드세요.\n\n\n\n# 사용자 경험 최적화\n\n기술적 최적화 이상으로 사용자 경험을 향상하는 것은 LCP의 인식되는 영향을 줄이는 데 중요합니다. 페이지가 로드되기를 기다리는 상황을 상상해보세요 — 간단한 로딩 애니메이션이나 콘텐츠를 위한 플레이스홀더는 사용자들을 관여시키고 기다림을 덜 지루하게 만들어줄 수 있어요.\n\n예를 들어, 뉴스 웹사이트를 운영 중이라면, 전체 기사가 백그라운드에서 로드될 때 로딩 스피너나 티저 이미지를 표시할 수 있어요. 이렇게 하면 사용자들이 로딩 프로세스 중에도 계속해서 관심을 가지고 정보를 얻을 수 있어요.\n\n# 사용자 테스트 및 피드백\n\n\n\nLCP가 사용자에게 어떤 영향을 미치는지 정확히 파악하려면 그들로부터 직접 피드백을 모으는 것이 중요합니다. 실제 사용자 피드백을 통해 성능 테스트만으로는 놓치기 쉬운 문제를 발견할 수 있습니다.\n\n웹사이트와 상호 작용하는 사용자를 관찰하는 사용자 테스트 세션을 진행해 보세요. LCP가 느릴 때 사용자의 반응에 주목해 보세요. 그들이 좌절이나 성가신 감정을 드러내는지 확인해 보세요. 그들의 피드백은 문제점을 파악하는 데 매우 소중할 수 있습니다.\n\n또한, 히트맵과 세션 녹화와 같은 도구를 활용하여 사용자 행동에 대한 통찰력을 얻을 수 있습니다. 이 도구는 사용자가 어디를 클릭하고, 어디까지 스크롤하며, 어디에서 이탈하는지 보여줍니다. 이 데이터를 LCP의 맥락에서 분석하여 개선이 필요한 영역을 정확히 식별할 수 있습니다.\n\n# 문서 작성 및 교육\n\n\n\nLCP 최적화는 일회성 작업이 아니라 팀 내 협력과 지식 공유가 필요한 지속적 노력입니다. 웹사이트를 유지하는 모든 이들이 동일한 목표를 향해 나아갈 수 있도록 최적화 전략과 모범 사례를 문서화하세요.\n\n내부 문서를 작성하여 LCP 최적화 기술, 사용하는 도구 및 웹사이트에 고유한 프로세스를 자세히 기술해보세요. 이 문서는 현재와 미래 팀원들에게 참고 자료로 활용될 수 있습니다.\n\n또한, 팀을 대상으로 교육 세션이나 워크샵을 제공하는 것도 고려해보세요. LCP의 중요성과 그에 대한 역할이 어떻게 최적화에 기여하는지에 대해 팀원들을 교육해주세요. LCP의 중요성과 각자의 역할을 이해하면, 노력이 더욱 조화롭고 효율적일 것입니다.\n\n# 지속적인 개선\n\n\n\n웹 성능 최적화는 동적인 분야입니다. 새로운 기술, 최상의 실천 방법 및 사용자 기대치는 지속적으로 발전하고 있습니다. 경쟁 우위를 유지하기 위해 계속해서 개선해야 합니다.\n\n정기적으로 LCP 지표와 최적화 전략을 재방문하세요. 변경 사항과 개선 사항을 구현하면서 LCP 점수와 사용자 경험에 미치는 영향을 모니터링하세요. 관찰한 결과에 기반하여 접근 방식을 조정할 준비를 하세요.\n\n산업 트렌드와 떠오르는 기술에 대해 최신 정보를 유지하세요. 예를 들어, 새로운 이미지 최적화 기술이나 콘텐츠 전달 방식이 인기를 얻는 경우, LCP 최적화 전략에 통합하는 것을 고려해 보세요.\n\n마지막으로, 사용자의 의견을 경청하세요. 페이지 로딩 시간이 느리거나 LCP 문제에 관한 피드백을 받으면 신속히 처리하세요. 사용자 만족도는 항상 노력의 최우선 과제여야 합니다.\n\n\n\n# 🔥 발견한 이 웹 개발 안내서가 도움이 되셨나요? 🔥\n\n이런 심층 안내서를 작성하는 데에는 시간, 헌신, 그리고 네! — 풍부한 커피가 필요합니다! 만약 이 글이나 기타 글이 여러분의 개발자 여정에 가치를 더했다면, 고맙다는 마음을 표현해주세요.\n\n👉 제 노력을 지원하고 커피 한 잔 사주세요! https://www.buymeacoffee.com/svetloslav ☕\n\n여러분이 기부해주시는 매 한 잔의 커피는 이와 같은 글들이 더 많이 나오도록 도와줍니다. 이 여정에 함께해 주셔서 감사합니다!\n\n\n\n# 친절한말로\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입하세요. 🗞️\n- 트위터(X) 대신 링크드인, 유튜브, 디스코드에서도 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-14-HowtoImproveLargestContentfulPaintLCP_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoImproveLargestContentfulPaintLCP_0.png","tag":["Tech"],"readingTime":7},{"title":"JavaScript에서 설명하는 기본적인 OOP 개념","description":"","date":"2024-05-14 14:35","slug":"2024-05-14-BasicOOPConceptsExplainedinJavaScript","content":"\n\n# 소개\n\n객체 지향 프로그래밍은 소프트웨어 개발에서 가장 중요한 프로그래밍 패러다임 중 하나입니다.\n\n그래서 나는 JavaScript의 맥락에서 OOP의 기본 개념을 설명하는 이 기사를 쓰기로 결정했습니다.\n\n![이미지](/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png)\n\n\n\n# 클래스:\n\nOOP(객체 지향 프로그래밍)를 시작할 때 보통 가장 먼저 배우는 개념은 \"클래스\"입니다. 왜냐하면 OOP 패러다임이 시작되는 곳이기도 하고 이 패러다임의 기반이기 때문이죠.\n\n클래스는 나중에 우리가 객체라고 부르게 될 것을 정의하기 시작하는 곳으로, 메서드와 속성과 같은 모든 사용할 수 있는 것들을 클래스 내에서 정의합니다.\n\n자바스크립트의 클래스 예제를 살펴보겠습니다:\n\n\n\n위의 예제에서는 \"Car\"라는 클래스를 정의했습니다. 이 클래스에는 이름, 색상 및 모델과 같은 속성이 있으며, 내부에는 두 개의 메서드가 있습니다. 첫 번째 메서드(getCarName)는 이름 속성을 반환하는 역할을 하고, 두 번째 메서드(getCarDescription)는 차량의 설명을 형식화된 방식으로 반환하는 역할을 합니다.\n\n간단히 설명하자면, OOP에서의 속성은 클래스가 메서드에서 처리할 수 있는 값들이며, 메서드는 함수와 비슷하며 클래스의 속성을 사용하여 다양한 작업, 유효성 검사 또는 요청을 수행할 수 있는 곳입니다.\n\n클래스 개념에 대해 이미 다뤘으니 이제 객체 개념에 대해 이야기해보겠습니다.\n\n# 객체:\n\n\n\nOOP(객체 지향 프로그래밍)에서 객체 개념은 대부분 클래스 개념과 함께 사용됩니다. 왜냐하면 객체는 기본적으로 클래스의 인스턴스이기 때문이죠.\n\n따라서 객체는 우리가 이전에 정의한 속성과 메서드를 사용하는 곳입니다.\n\n이제 객체의 예시를 살펴봅시다:\n\n물론, 객체 예시는 클래스 예시와 거의 비슷하죠?\n\n\n\n이렇게 두 개념이 어떻게 함께 작동하는지 정말 잘 볼 수 있습니다.\n클래스 예제와 달리, 이제는 객체(클래스의 인스턴스)를 정의하고 클래스에 속성이 갖게 될 값을 알려줍니다(정확히 22번째 줄).\n\n그래서 이 객체 내에서 이것이 클래스 안에 있는 속성들의 값입니다:\n\n```js\nthis.name = \"Ferrari\",\nthis.color = \"Red\",\nthis.model = \"Roma\";\n```\n\n객체를 생성한 후, console.log() 메소드 내에서 \"getCarDescription\" 메소드를 호출하고, 다음과 같이 기록됩니다:\n\n\n\n```js\n\"차 설명: 이름: 페라리 - 모델: 로마 - 색상: 빨간색\"\n```\n\n# 정말 간단하죠?\n\n이 두 가지 기본 개념은 가장 중요한 것들 중 하나입니다. 왜냐하면 이 둘을 명확하게 이해하지 못하면 객체 지향 프로그래밍을 배우기 매우 어려워지기 때문이죠. 이 두 요소는 시스템이 정의된 클래스와 객체를 통해 상호 작용할 수 있는지 확인하기 위해 중요한 역할을 하며, 이를 통해 이 시리즈의 다음 장에서 설명될 상속, 캡슐화, 추상화 및 다형성과 같은 객체 지향 프로그래밍의 나머지 개념을 활용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png","tag":["Tech"],"readingTime":2},{"title":"ASPNET Core Web API를 사용하여 Google reCAPTCHA 구현하기","description":"","date":"2024-05-14 14:34","slug":"2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI","content":"\n\n\n![Implementing reCAPTCHA using ASP.NET Core Web API](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_0.png)\n\n폼을 디자인했지만 웹 사이트가 봇 공격이나 다른 자동화된 공격을 받고 백엔드로 무관한 데이터를 제출할까 걱정되나요? Google reCaptcha가 이 문제에 대한 해결책을 제공합니다.\n\nGoogle reCaptcha는 사기를 탐지하고 합법적인 사용자만 시스템에 입력하고 로그인 페이지를 사용하거나 양식을 제출하거나 결제를 하거나 페이지를 보거나 가짜 사용자를 차단하는 등의 작업을 허용하는 시스템입니다.\n\n이제 프로젝트에 reCaptcha를 구현하는 방법에 대해 이야기해보겠습니다. 프론트엔드로 HTML, CSS 및 Javascript을 사용하고 백엔드로는 ASP.NET Core Web API를 사용할 것입니다.\n\n\n\n\n구현 부분은 상당히 쉽습니다. Google은 reCaptcha 생성을 위한 API를 제공하며, 해당 API의 JavaScript 파일 링크를 HTML 코드에 포함해야 합니다.\n\n우리는 HTML과 CSS를 사용하여 간단한 로그인 폼을 만드는 것부터 시작할 것입니다.\n\n나는 이 로그인 폼을 만들었는데, 여기에 Google reCaptcha를 추가할 것입니다.\n\n![Login Form](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_1.png)\n\n\n\nGoogle reCaptcha를 추가하려면 나중에 코드에서 사용할 키를 먼저 생성해야 합니다.\n\n새 키를 생성하려면 다음 URL을 방문하십시오:\n\n[https://www.google.com/recaptcha/admin/create](https://www.google.com/recaptcha/admin/create)\n\nGoogle 계정으로 이미 로그인되어 있으면 등록 대시보드가 표시됩니다. 그렇지 않으면 Google 계정으로 먼저 로그인해야 합니다.\n\n\n\n이것은 등록 키 대시보드입니다. 여기에는 레이블, reCaptcha 유형 및 도메인과 같은 기본 정보를 입력해야 합니다.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_2.png)\n\n- 레이블은 키에 할당하려는 아무 이름이 될 수 있습니다.\n- Google이 제공하는 두 가지 유형의 reCaptcha가 있습니다. v3와 v2입니다. 저희는 v2 \"나는 로봇이 아닙니다\" 확인란을 사용할 것입니다.\n- 도메인 필드에는 Google reCaptcha를 사용할 도메인을 지정해야 합니다. 예를 들어, 웹 사이트 이름이 다음과 같다면:\nhttps://your-website.com/index.html — 여기서는 도메인으로 your-website.com만 입력하면 됩니다.\n저는 데모 목적으로 reCaptcha를 구현하고 있으므로 애플리케이션을 로컬 환경에서 실행할 것입니다. 따라서 도메인으로 127.0.0.1을 사용했습니다.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_3.png)\n\n\n\n모든 세부 정보를 입력한 후 제출 버튼을 클릭해주세요. 그럼 두 개의 키가 생성됩니다. 클라이언트 측에서 사용되는 사이트 키와 서버 측에서 사용되는 시크릿 키가 있습니다.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_4.png)\n\n코딩 부분으로 돌아가면, reCaptcha를 삽입할 위치에 다음 코드 라인을 추가해야 합니다. 로그인 버튼 앞에 추가하겠습니다.\n\n```js\n<div class=\"g-recaptcha\" data-sitekey=여기에_사이트_키_입력></div>\n```\n\n\n\n원하는 위치에 이 div 클래스를 추가한 후, Google reCaptcha API를 호출하는 JavaScript 파일을 추가하십시오.\n\n```js\n<script type=\"text/javascript\" src=\"https://www.google.com/recaptcha/api.js\"></script>\n```\n\nreCaptcha를 추가한 후 로그인 페이지가 이렇게 보입니다.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_5.png)\n\n\n\n아래에 HTML(index.html) 및 CSS(style.css) 파일의 코드를 찾을 수 있어요:\n\n```js\n<!DOCTYPE html>\n<head>\n    <title>로그인 페이지</title>\n    <link rel=\"stylesheet\" href=\"style.css\">    \n    <script type=\"text/javascript\" src=\"https://www.google.com/recaptcha/api.js\"></script>\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js\"></script>\n    <script type=\"text/javascript\" src=\"script.js\"></script>\n</head>\n<body>\n    <div class=\"login-page\">\n        <div class=\"form\">      \n          <div class=\"login-form\">\n            <input type=\"text\" placeholder=\"사용자 이름\"/>\n            <input type=\"password\" placeholder=\"비밀번호\"/>\n            <div class=\"g-recaptcha\" data-sitekey=\"6LfU_xMpAAAAADmXvZq0VqCVLIyJz3x6V8dUQeZ8\"></div><br>\n            <button onclick=\"LoginButton()\">로그인</button>            \n          </div>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n```js\n@import url(https://fonts.googleapis.com/css?family=Roboto:300);\n\n.login-page {\n  width: 360px;\n  padding: 8% 0 0;\n  margin: auto;\n}\n.form {\n  position: relative;\n  z-index: 1;\n  background: rgb(116, 223, 187);\n  max-width: 360px;\n  margin: 0 auto 100px;\n  padding: 30px;\n  text-align: center;\n  box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);\n}\n.form input {\n  font-family: \"Roboto\", sans-serif;\n  outline: 0;\n  background: #f2f2f2;\n  width: 100%;\n  border: 0;\n  margin: 0 0 15px;\n  padding: 15px;\n  box-sizing: border-box;\n  font-size: 14px;\n}\n.form button {\n  font-family: \"Roboto\", sans-serif;\n  text-transform: uppercase;\n  outline: 0;\n  background: rgb(8, 103, 116);\n  width: 100%;\n  border: 0;\n  padding: 15px;\n  color: #FFFFFF;\n  font-size: 14px;\n  -webkit-transition: all 0.3 ease;\n  transition: all 0.3 ease;\n  cursor: pointer;\n}\n.form button:hover,.form button:active,.form button:focus {\n  background: #073b44;\n}\n\n.container {\n  position: relative;\n  z-index: 1;\n  max-width: 300px;\n  margin: 0 auto;\n}\n```\n\n프론트엔드 부분이 이제 완료되었어요. 그 다음에는 자바스크립트를 사용하여 reCaptcha로부터 응답을 가져와서 시크릿 키를 사용하여 백엔드에서 응답을 확인할 거에요.\n\n\n\n로그인 버튼에 onclick 함수를 추가했어요. 이 함수는 reCaptcha로부터 응답을 가져오고 API에 ajax 호출을 만들 거예요. 필요에 따라 세 개의 필드가 모두 채워질 때까지 로그인 버튼을 비활성화하는 기능 같은 다른 기능도 추가할 수 있어요. 여기서는 간단하게 reCaptcha의 유효성을 성공 또는 실패했을 때 경고 메시지를 표시해 줄 거에요.\n\nAPI 쪽에서는 ASP.NET Core와 Visual Studio 2022를 사용하고 있어요. 제 블로그의 첫 번째 부분(단계 1)을 참조해서 Visual Studio 2022를 사용해 API 프로젝트를 만드는 방법을 알아볼 수 있어요.\n\n- appsettings.json으로 이동해서 비밀 키를 추가하세요.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_6.png)\n\n\n\n```js\n\"reCaptcha\": {\n    \"SecretKey\": Your_Secret_Key, \n  },\n```\n\n2. 새 컨트롤러를 만듭니다. 다음 단계를 따라주세요:\nControllers 폴더에서 우클릭 -` 추가 -` 컨트롤러 -` 빈 API 컨트롤러 선택 -` 컨트롤러에 이름 지정 (저는 UserController라고 이름짓겠습니다).\n\n컨트롤러를 만들면 다음과 같은 모습이 될 것입니다:\n\n<img src=\"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_7.png\" />\n\n\n\n3. 컨트롤러에 reCaptcha를 검증하는 로직을 추가하세요.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_8.png)\n\n- 여기서 우리는 Configuration을 주입하여 appsettings.json에서 Secret Key를 가져오고 HttpClient를 사용하여 결과를 Google API 엔드포인트에 전송합니다.\n- 'GetreCaptchaResponse'라는 메서드를 생성했는데, 이 메서드는 프론트 엔드에서 전송된 reCaptcha 응답을 받습니다. 그다음으로, 응답 및 시크릿 키를 저장할 'content' 변수를 생성합니다.\n- Google은 응답과 시크릿 키가 전달되어야 하는 API 엔드포인트(https://www.google.com/recaptcha/api/siteverify)를 제공하고, json 형식의 결과를 제공합니다. 자세한 정보는 해당 페이지에서 확인할 수 있습니다.\n우리는 이 내용을 해당 API로 전달하고 결과를 'response' 변수에 저장합니다.\n- 이 응답이 성공하면 'Success' 및 'Error' 코드를 읽어 'result' 변수에 저장합니다.\n\n아래에서 전체 코드를 찾을 수 있습니다.\n\n\n\n```csharp\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace reCaptchaAPI.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class UserController : ControllerBase\n    {\n        private readonly IConfiguration _configuration;\n        private readonly HttpClient _httpClient;\n        public UserController(IConfiguration configuration, HttpClient httpClient)\n        {\n            _configuration = configuration;\n            _httpClient = httpClient;\n        }\n        [HttpGet(\"Captcha\")]\n        public async Task<bool> GetreCaptchaResponse(string userResponse)\n        {\n            var reCaptchaSecretKey = _configuration[\"reCaptcha:SecretKey\"];\n\n            if(reCaptchaSecretKey != null && userResponse != null)\n            {\n                var content = new FormUrlEncodedContent(new Dictionary<string, string>\n                {\n                    {\"secret\", reCaptchaSecretKey },\n                    {\"response\", userResponse }\n                });\n                var response = await _httpClient.PostAsync(\"https://www.google.com/recaptcha/api/siteverify\", content);\n                if(response.IsSuccessStatusCode)\n                {\n                    var result = await response.Content.ReadFromJsonAsync<reCaptchaResponse>();\n                    return result.Success;\n                }\n            }\n            return false;\n        }\n\n        public class reCaptchaResponse\n        {\n            public bool Success { get; set; }\n            public string[] ErrorCodes { get; set; }\n        }\n    }\n}\n```\n\n다음 단계는 HttpClient 미들웨어를 program.cs에 등록하고 이 API를 프론트엔드에서 호출할 것이므로 CORS (Cross Origin Resource Sharing)를 지정해야합니다. 이는 프론트엔드 코드에서 API에 액세스할 수 있도록 도와줍니다.\n\n<img src=\"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_9.png\" />\n\nCORS를 지정하려면:\n\n\n\n\n```js\nbuilder.Services.AddCors(options =>\n{\n    options.AddDefaultPolicy(\n        policy =>\n        {\n            policy.AllowAnyOrigin()\n                .AllowAnyHeader()\n                .AllowAnyMethod();\n        });\n});\n\napp.UseCors();\n```\n\nTo register HttpClient Middleware:\n\n```js\nbuilder.Services.AddHttpClient();\n```\n\nYour API Project is now completed. You can run and test it once using swagger.\n\n\n\n이제 남은 것은 API를 구현하기 위해 ajax 호출을 작성하는 것입니다. 로그인 버튼에 onclick 함수를 추가하고 함수 내에서 ajax 호출을 정의할 것입니다.\n\n<img src=\"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_10.png\" />\n\n여기서 reCaptcha 응답을 받아 이를 API의 매개변수로 보내고 있습니다. API 프로젝트를 실행하고 Swagger 페이지가 열리면 로컬호스트 URL을 복사하여 여기에 사용할 수 있습니다. 엔드포인트 이름을 정확히 지정했는지 확인해주세요!\n\n이러한 변경 사항을 적용하고 애플리케이션을 실행한 후, 다음과 같은 경고를 받게 될 것입니다:\n\n\n\n\n[이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_11.png)\n\n자바스크립트 (script.js) 코드는 다음과 같습니다:\n\n```js\nfunction LoginButton(){\n    const reCaptchaResponse = grecaptcha.getResponse();\n    if(reCaptchaResponse){\n        $.ajax({\n            type: \"GET\",\n            url: \"https://localhost:44317/api/User/Captcha\",\n            data: {userResponse : reCaptchaResponse},            \n            success: function(data){\n                if(data){\n                    //API returned true\n                    alert(\"Captcha Verified\");\n                }else{\n                    //API returned false\n                    alert(\"Please verify captcha again\");\n                }               \n            },\n            error: function(error){\n                alert(\"Please try again\");\n            }\n        });\n    }\n    else{\n        alert(\"Something went wrong with reCaptcha. Please try again!\");\n    }\n}\n```\n\n이 응용 프로그램의 소스 코드를 참조해주세요:\n","ogImage":{"url":"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_0.png","tag":["Tech"],"readingTime":10},{"title":"Durandal 대 Angular","description":"","date":"2024-05-14 14:32","slug":"2024-05-14-DurandalvsAngular","content":"\n\n\n![Durandal Logo](/assets/img/2024-05-14-DurandalvsAngular_0.png)\n\n알고 계신가요? Durandal을 들어보신 적이 있나요? 만일 JS 개발자 경험이 적다면 들어보지 못했을 것입니다. 10년 전에 이것은 인기 있는 싱글 페이지 앱 (SPA) 프레임워크였습니다.\n\n당시 저는 Durandal을 사용한 중요한 프로젝트에서 1년 이상 일했습니다. 저는 그것을 좋아했어요. 작고, 유연하며 확장하기 쉬웠습니다.\n\n10년은 IT분야에서 긴 시간입니다. 지금은 Durandal이 더 이상 사용되지 않고 있습니다. 새로운 세대의 프런트 엔드 JS 프레임워크가 웹 애플리케이션의 세계를 지배하고 있습니다.\n\n\n\n\n최근에 오래된 Durandal 애플리케이션에 소규모 개선 작업을 하게 되었어요. 옛 친구를 다시 만난 기분이었죠. 당연히 현재의 JS 프레임워크인 Angular 16과 비교해보았어요.\n\n아시다시피 Angular는 거의 모든 면에서 Durandal을 앞섰어요. 하지만 Durandal의 많은 디자인 개념들은 여전히 그 가치를 지키고 있어요. 이러한 비교를 보면 지난 10년 동안 Single Page App (SPA) 프레임워크가 얼마나 발전했는지 명확해져요. 우리가 얼마나 멀리 왔는지 보는 것은 꽤 흥미롭죠.\n\n## 프레임워크 개요\n\nDurandal은 단순함과 모듈성을 중점으로 둔 가벼운 SPA 프레임워크로 만들어졌어요. Knockout과 Require.js와 같은 라이브러리의 조합을 활용하여 목표를 달성했어요.\n\n\n\nDurandal은 SPA를 만드는 데 필수적인 기능을 제공합니다. 또한 다른 라이브러리와 쉽게 통합할 수 있도록 설계되었습니다.\n\n반면에 Angular는 완전한 패키지입니다. 그래서 그것은 \"배터리 포함\"이라고 불립니다. 이는 Angular가 대규모 및 복잡한 프로젝트에 적합한 풍부한 싱글 페이지 웹 앱을 구축하는 데 필요한 모든 것을 제공한다는 것을 의미합니다.\n\n## AMD vs ES6 module\n\nDurandal은 모듈 로딩과 의존성 관리를 위해 Asynchronous Module Definition (AMD) 패턴을 사용합니다. AMD의 한 예는 아래와 같습니다:\n\n\n\n```js\n// Durandal에서 AMD를 사용하여 모듈 정의하기\ndefine(['knockout'], function(ko) {\n    var viewModel = {\n        message: ko.observable('안녕, Durandal!')\n    };\n    return viewModel;\n});\n```\n\nAngular 및 다른 새로운 JS 프레임워크는 ES6 모듈을 사용합니다. AMD와 달리, ES6 모듈은 JavaScript에 기본적으로 내장되어 있어 추가적인 로더나 Require.js와 같은 라이브러리가 필요하지 않습니다. ES6 모듈은 정적 분석을 가능하게 하여 더 나은 도구 지원, 트리 쉐이킹 및 성능 향상을 제공합니다. ES6 모듈은 기본적으로 더 나은 캡슐화를 제공하여 의존성을 관리하는 것을 쉽게 만들고 의도하지 않은 충돌을 방지합니다. 아래는 사용 예시입니다.\n\n```js\n// 모듈 가져오기\nimport { greet } from './myModule';\n\n// Angular 컴포넌트\n@Component({\n  selector: 'app-greeting',\n})\nexport class GreetingComponent {\n  message: string;\n\n  constructor() {\n    // 가져온 함수 사용하기\n    this.message = greet('John');\n  }\n}\n```\n\n## 컴포넌트 기반 아키텍처\n\n\n\n\n현대 SPA 프레임워크에서 기본적인 설계 패러다임인 구성 요소 기반 아키텍처는 사용자 인터페이스를 재사용 가능한 독립적인 구성 요소로 분해하여 모듈화 및 유지 관리성을 촉진합니다.\n\nDurandal은 구성 요소 개념을 갖고 있지만 현대 SPA에서 볼 수 있는 구조화된 구성 요소 기반 아키텍처가 부족합니다.\n\nAngular은 구성 요소 기반 아키텍처를 강조하며 재사용 가능한 구성 요소 내에서 기능을 캡슐화하여 명확한 관심사 분리와 유지 관리성을 촉진하는 구조화된 개발 접근 방식을 강제합니다.\n\n## 상태 관리\n\n\n\nDurandal은 뷰 모델, 라우팅, 라이프사이클 메소드 및 저장 옵션의 조합을 사용하여 상태를 관리하고 유지하는 데 도움을 줍니다. 애플리케이션이 커지면 다른 컴포넌트 및 뷰 간의 상태 전이를 추적하고 관리하는 것이 더 어려워질 수 있습니다.\n\nAngular에는 많은 상태 관리 프레임워크가 있습니다. 가장 인기 있는 것은 Redux에서 영감을 받은 상태 관리 라이브러리인 NgRx입니다. 이를 통해 응용 프로그램 상태를 구조화하고 복잡한 데이터 흐름을 처리하기 쉬워집니다.\n\n## 의존성 주입\n\nDurandal은 전용 의존성 주입 컨테이너를 제공하지는 않지만 모듈 구조와 Require.js와 같은 AMD(비동기 모듈 정의) 로더와 통합을 제공합니다.\n\n\n\nAngular의 의존성 주입(Dependency Injection, DI)은 우리에게 종속성을 손쉽게 관리하고 주입할 수 있는 강력한 메커니즘입니다. 내장된 DI를 통해 코드를 깔끔하고 조직적으로 유지하고 테스트할 수 있으므로, 견고한 웹 응용 프로그램을 개발하는 데 탁월한 기능입니다.\n\n```js\n// 의존성 주입이 포함된 Angular 컴포넌트\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-example',\n  template: '<p>{ message }</p>',\n})\nexport class ExampleComponent {\n  constructor(private dataService: DataService) {\n    this.message = this.dataService.getMessage();\n  }\n}\n```\n\n## 바인딩\n\nDurandal은 Knockout을 이용한 양방향 데이터 바인딩을 사용하여 동적 UI 업데이트를 처리할 수 있었습니다.\n\n\n\n```js\n<!-- Durandal 바인딩 -->\nvar vm = {\n    message = ko.observable('안녕 세상아')\n};\nko.applyBindings(vm);\n```\n\nAngular은 자체적인 양방향 데이터 바인딩 메커니즘을 제공하며 시간이 지남에 따라 성능과 유연성이 향상되었습니다.\n\n```js\n<!-- Angular HTML 템플릿 -->\n<input [(ngModel)]=\"message\" />\n<p>{ message }</p>\n```\n\nReact와 같은 다른 최신 프론트엔드 JS 프레임워크들은 이벤트를 통해 데이터 상태를 업데이트하여 성능을 향상시키는 단방향 데이터 바인딩을 활용합니다.\n\n\n\n\n## 도구, CLI 및 성능 최적화\n\nDurandal은 간단하고 모듈식이지만 CLI 도구가 없었습니다. 또한 내장된 성능 최적화 기능도 제공하지 않았습니다.\n\nAngular와는 달리 Durandal에는 기본적으로 서버 측 렌더링 지원이 없었습니다.\n\nAngular에는 자체 CLI가 함께 제공됩니다. Angular 앱을 구축, 테스팅 및 배포하기 위한 풍부한 툴킷입니다. 개발자들에게 생활을 쉽게 만들어주며 생산성을 크게 향상시킵니다.\n\n\n\nAngular 16은 AOT 컴파일 및 향상된 트리 쉐이킹과 같은 멋진 성능 트릭으로 한 단계 더 나아갑니다. 이는 더 빠른 로드 시간과 더 작은 번들로 앱 전체를 보다 빠르게 만들어줍니다. \n\nAngular 16은 향상된 Angular Universal을 롤아웃하여 적절한 서버 측 렌더링 기능을 제공합니다. 이로 인해 페이지가 더 빨리 로드되고 SEO를 향상시킵니다.\n\n이러한 중요한 발전은 현대적인 단일 페이지 앱(SPAs)을 한 단계 발전시켰습니다. 이러한 앱들은 강력하며 유지 보수가 쉽고 매우 빠릅니다. Angular와 Durandal을 비교하면 새로운 멋진 스포츠카와 오래된 모델을 비교하는 것과 같습니다. Durandal은 그 시대에 놀랍지만, 새로운 세대의 SPA 프레임워크는 모든 것을 새로운 수준으로 끌어올렸습니다!","ogImage":{"url":"/assets/img/2024-05-14-DurandalvsAngular_0.png"},"coverImage":"/assets/img/2024-05-14-DurandalvsAngular_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular에서 양식Form","description":"","date":"2024-05-14 14:30","slug":"2024-05-14-FormsinAngular","content":"\n\n<img src=\"/assets/img/2024-05-14-FormsinAngular_0.png\" />\n\n안녕하세요! 이번 글에서는 Angular에서 양식과 그 종류에 관해 단계별 실제 구현과 함께 살펴보려고 해요.\n\n# 안내\n\n- Angular란 무엇인가요?\n\n\n\n## Angular에서의 폼\n\n## 폼의 종류\n\n## 실무 적용\n\n### Prerequisites\n\n\n\n- TypeScript에 대한 기본적인 이해\n\n- NodeJS\n\n- Angular CLI\n\n- Vs Code\n\n\n\n# 앵귤러란?\n\n앵귤러는 웹 애플리케이션을 구축하는 인기 있는 오픈 소스 JavaScript 프레임워크입니다. 구글에서 개발되었으며 현재는 구글의 앵귤러 팀에서 유지보수되고 있습니다. 앵귴러는 개발자들이 동적인 싱글 페이지 애플리케이션(SPA)을 만들 수 있게 하며 복잡한 웹 애플리케이션을 구축하기 위한 체계적인 접근 방식을 제공합니다.\n\n# 앵귤러에서의 폼\n\n- 앵귤러에서 폼은 사용자 입력을 처리하고 관리하는 데 도움이 되는 다양한 기능을 제공합니다.\n\n\n\n- 웹 애플리케이션의 주요 부분인 Forms. 사용자들이 애플리케이션과 상호 작용하고 애플리케이션으로 데이터를 제출할 수 있게 합니다.\n\n## Angular에서 제공하는 Forms의 종류\n\nAngular는 다음 두 가지 유형의 Forms를 제공합니다:\n\n### 1. Template-Driven Forms\n\n\n\n- 템플릿 기반 폼은 제한된 수의 필드 및 간단한 유효성 검사를 개발하기에 적합한 기본 폼입니다.\n\n- 이 폼에서 각 필드는 컴포넌트 클래스의 속성으로 표시됩니다.\n\n- '@angular/forms' 패키지에서 FormsModule를 가져와야 합니다.\n\n다음은 Angular에서 템플릿 기반 폼을 생성하는 동안 사용하는 유효성 검사 객체, 지시문, 속성과 관련된 주요 개념입니다.\n\n\n\n- ngForm 디렉티브: 이 디렉티브는 Angular 폼을 나타내며 유효성 검사 및 데이터 조작과 관련된 메서드 및 속성을 노출합니다.\n\n- ngModel 디렉티브: 이 디렉티브는 서로 다른 폼 컨트롤 요소 간의 양방향 데이터 바인딩을 달성하는 데 사용됩니다.\n\n- 유효성 검사 속성: Angular는 폼 컨트롤에 적용할 수있는 다양한 유효성 검사기 속성을 제공합니다.\n\n1. touched: 해당 컨트롤이 터치되었는지를 나타내는 부울 값입니다.\n\n\n\n2. untouched: 터치되지 않은 상태\n\n3. valid: 컨트롤 값이 유효한지 나타내는 부울 값.\n\n4. invalid: valid의 반대\n\n- 유효성 검사 디렉티브: Angular는 몇 가지 내장 유효성 검사 디렉티브를 제공하여 ngModel과 함께 사용하여 유효성 검사를 수행할 수 있습니다. 일반적으로 사용되는 몇 가지 디렉티브에는 다음이 있습니다:\n\n\n\n1. required: 값이 비어 있지 않도록 보장합니다.\n\n2. min length 및 max length: 값의 최소 및 최대 길이를 지정합니다.\n\n3. pattern: 값을 정규 표현식과 비교합니다.\n\n4. email: 값이 유효한 이메일 주소인지 확인합니다.\n\n\n\n## 2. 반응형 폼\n\n- 반응형 폼 또는 모델 기반 폼은 Angular에서 큰 양의 폼을 만들거나 다양한 폼 필드 및 복잡한 검증이 필요한 경우에 적합한 종류의 폼입니다.\n\n- 반응형 폼에서, 각 폼 필드는 Form Control로 간주되며, 폼 컨트롤 집합은 Form Group이라고 합니다.\n\n- 검증 규칙은 Validators 객체를 사용하여 컴포넌트에서 정의되며, 검증 메시지는 템플릿에서 validation 속성을 사용하여 표시할 수 있습니다.\n\n\n\n· ReactiveFormModule은 '@angular/forms' 패키지에서 가져와야 합니다.\n\nAngular에서 반응형 폼을 생성하는 동안 사용된 유효성 객체 및 속성과 관련된 주요 개념은 다음과 같습니다.\n\n· FormControl\n\nAngular에서 폼 컨트롤은 반응형 폼에서 개별 폼 요소를 나타냅니다. 또한 입력 폼 요소의 다른 상태와 값들을 관리합니다. 유효성 규칙을 정의할 수 있는 다양한 속성이 있습니다.\n\n\n\n1. Value: 양식 컨트롤의 현재 값을 확인하는 데 도움을 줍니다.\n\n2. Status: 상태는 양식 컨트롤의 상태를 나타냅니다.\n\n3. Valid: 컨트롤이 유효한지를 확인하는 부울 유효성 속성입니다.\n\n4. Invalid: 컨트롤이 유효하지 않은지를 확인하는 부울 유효성 속성입니다.\n\n\n\n5. 에러: 이는 폼 컨트롤의 유효성 검증 오류를 보유한 객체입니다.\n\n- **Validators**\n\nValidators는 폼 컨트롤의 유효성 검증 규칙을 정의하는 데 사용할 수 있는 함수들입니다.\n\n1. required: 컨트롤이 비어있지 않은 값을 가지고 있는지를 검증합니다.\n\n\n\n2. Min(최소값) 및 max(최대값): 컨트롤 값이 지정된 숫자 범위 내에 있는지 확인합니다.\n\n3. pattern(패턴): 컨트롤 값이 정규 표현식과 일치하는지 확인합니다.\n\n4. email(이메일): 컨트롤 값이 유효한 이메일 주소인지 확인합니다.\n\n5. minLength(최소길이) 및 maxLength(최대길이): 컨트롤 값의 길이를 확인합니다.\n\n\n\n- FormGroup\n\n폼 그룹은 여러 폼 컨트롤을 포함하는 컨테이너입니다. 관련된 폼 컨트롤을 함께 그룹화하고 단일 단위로 유효성을 관리할 수 있습니다.\n\n- FormBuilder\n\nFormBuilder 서비스는 FormGroup 및 FormControl의 인스턴스를 생성하는 데 사용되며 유효성 규칙을 정의하는 편리한 방법을 제공합니다.\n\n\n\n# 실용적인 구현\n\n단계 1\n\n새로운 Angular 애플리케이션을 생성하세요.\n\n단계 2\n\n\n\n다음 명령어를 사용하여 부트스트랩 모듈을 설치해 보세요:\n\nnpm install bootstrap\n\nAngular JSON 파일에서 Bootstrap을 구성하세요.\n\n```js\n \"styles\": [\n              \"src/styles.css\",\n              \"./node_modules/bootstrap/dist/css/bootstrap.min.css\"\n            ],\n            \"scripts\": [\n              \"./node_modules/bootstrap/dist/js/bootstrap.min.js\"\n            ]\n```\n\n\n\nStep 3\n\n다음으로, 새롭게 생성된 프로젝트에 두 개의 컴포넌트를 추가해보세요.\n\ntemplate-driven-form.component.html\n\n```js\n<div class=\"container\">\n    <h2 class=\"heading\">템플릿 기반 폼</h2>\n    <form #userForm=\"ngForm\" (ngSubmit)=\"submitForm(userForm)\">\n   \n      <div class=\"form-group\">\n        <label for=\"name\">이름</label>\n        <input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" [(ngModel)]=\"userDetails.name\" required>\n        <div *ngIf=\"userForm.controls.name?.touched && userForm.controls.name?.invalid\" class=\"text-danger\">\n          이름을 입력해주세요.\n        </div>\n      </div>\n      \n      <div class=\"form-group\">\n        <label for=\"email\">이메일</label>\n        <input type=\"email\" class=\"form-control\" id=\"email\" name=\"email\" [(ngModel)]=\"userDetails.email\" required email>\n        <div *ngIf=\"userForm.controls.email?.touched && userForm.controls.email?.invalid\" class=\"text-danger\">\n          올바른 이메일 주소를 입력해주세요.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"address\">주소</label>\n        <input type=\"text\" class=\"form-control\" id=\"address\" name=\"address\" [(ngModel)]=\"userDetails.address\" required>\n        <div *ngIf=\"userForm.controls.address?.touched && userForm.controls.address?.invalid\" class=\"text-danger\">\n          주소를 입력해주세요.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"mobile\">휴대폰 번호</label>\n        <input type=\"tel\" class=\"form-control\" id=\"mobile\" name=\"mobile\" [(ngModel)]=\"userDetails.mobile\" required pattern=\"[0-9]{10}\">\n        <div *ngIf=\"userForm.controls.mobile?.touched && userForm.controls.mobile?.invalid\" class=\"text-danger\">\n          올바른 휴대폰 번호를 입력해주세요.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"age\">나이</label>\n        <input type=\"number\" class=\"form-control\" id=\"age\" name=\"age\" [(ngModel)]=\"userDetails.age\" required min=\"20\" max=\"60\">\n        <div *ngIf=\"userForm.controls.age?.touched && userForm.controls.age?.invalid\" class=\"text-danger\">\n          올바른 나이를 입력해주세요.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"gender\">성별</label>\n        <select class=\"form-control\" id=\"gender\" name=\"gender\" [(ngModel)]=\"userDetails.gender\" required>\n          <option value=\"\" disabled>성별 선택</option>\n          <option value=\"male\">남성</option>\n          <option value=\"female\">여성</option>\n          <option value=\"other\">기타</option>\n        </select>\n        <div *ngIf=\"userForm.controls.gender?.touched && userForm.controls.gender?.invalid\" class=\"text-danger\">\n          성별을 선택해주세요.\n        </div>\n      </div>\n\n      <button type=\"submit\" class=\"btn btn-primary\">제출</button>\n    </form>\n  </div>\n```\n\n\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-template-driven-form',\n  templateUrl: './template-driven-form.component.html',\n  styleUrls: ['./template-driven-form.component.css']\n})\nexport class TemplateDrivenFormComponent {\n  userDetails = {\n    name: '',\n    email: '',\n    address: '',\n    mobile: '',\n    age: null,\n    gender: ''\n  };\n\n  submitForm(form: any): void {\n    if (form.valid) {\n      console.log('Form data:', this.userDetails);\n    }\n  }\n}\n```\n\n- 이 예제에서 #userForm=\"ngForm\"은 폼 참조를 생성하여 컴포넌트 내의 사용자 객체의 속성에 접근할 수 있도록 합니다. [(ngModel)] 지시문은 입력 요소와 사용자 객체의 속성 간에 양방향 데이터 바인딩을 설정합니다.\n\n- 유효성 검사 지시문 (required 및 email)이 폼 컨트롤에 적용되며, 오류 메시지는 컨트롤의 상태에 따라 조건부로 표시됩니다.\n\n\n\n\n<img src=\"/assets/img/2024-05-14-FormsinAngular_1.png\" />\n\n다음으로 아래와 같이 반응형 폼을 생성하세요.\n\nreactive-form.component.html\n\n```js\n<div class=\"container\">\n    <h2 class=\"heading\">반응형 폼</h2>\n    <form [formGroup]=\"userForm\" (ngSubmit)=\"submitForm()\">\n\n        <div class=\"form-group\">\n        <label for=\"name\">이름</label>\n        <input type=\"text\" class=\"form-control\" id=\"name\" formControlName=\"name\">\n        <div *ngIf=\"userForm?.get('name')?.invalid && userForm?.get('name')?.touched\" class=\"text-danger\">\n          이름을 입력해주세요.\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"email\">이메일</label>\n        <input type=\"email\" class=\"form-control\" id=\"email\" formControlName=\"email\">\n        <div *ngIf=\"userForm?.get('email')?.invalid && userForm?.get('email')?.touched\" class=\"text-danger\">\n          유효한 이메일을 입력해주세요.\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"address\">주소</label>\n        <input type=\"text\" class=\"form-control\" id=\"address\" formControlName=\"address\">\n        <div *ngIf=\"userForm?.get('address')?.invalid && userForm?.get('address')?.touched\" class=\"text-danger\">\n          주소를 입력해주세요.\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"mobile\">휴대전화 번호</label>\n        <input type=\"tel\" class=\"form-control\" id=\"mobile\" formControlName=\"mobile\">\n        <div *ngIf=\"userForm?.get('mobile')?.invalid && userForm?.get('mobile')?.touched\" class=\"text-danger\">\n          유효한 휴대전화 번호를 입력해주세요.\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"age\">나이</label>\n        <input type=\"number\" class=\"form-control\" id=\"age\" formControlName=\"age\">\n        <div *ngIf=\"userForm?.get('age')?.invalid && userForm?.get('age')?.touched\" class=\"text-danger\">\n          유효한 나이를 입력해주세요 (1에서 120 사이).\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"gender\">성별</label>\n        <select class=\"form-control\" id=\"gender\" formControlName=\"gender\">\n          <option value=\"\" disabled>성별 선택</option>\n          <option value=\"male\">남성</option>\n          <option value=\"female\">여성</option>\n          <option value=\"other\">기타</option>\n        </select>\n        <div *ngIf=\"userForm?.get('gender')?.invalid && userForm?.get('gender')?.touched\" class=\"text-danger\">\n          성별을 선택해주세요.\n        </div>\n      </div>\n  \n      <button type=\"submit\" class=\"btn btn-primary\">제출</button>\n    </form>\n  </div>\n```\n\n\n\n```js\nimport { Component } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-reactive-form',\n  templateUrl: './reactive-form.component.html',\n  styleUrls: ['./reactive-form.component.css']\n})\nexport class ReactiveFormComponent {\n  userForm: any;\n\n  constructor(private formBuilder: FormBuilder) {}\n\n  ngOnInit(): void {\n    this.userForm = this.formBuilder.group({\n      name: ['', Validators.required],\n      email: ['', [Validators.required, Validators.email]],\n      address: ['', Validators.required],\n      mobile: ['', [Validators.required, Validators.pattern('[0-9]{10}')]],\n      age: ['', [Validators.required, Validators.min(20), Validators.max(50)]],\n      gender: ['', Validators.required]\n    });\n  }\n\n  submitForm(): void {\n    if (this.userForm?.valid) {\n      console.log('Form data:', this.userForm.value);\n    }\n  }\n}\n```\n\n![FormsinAngular_2](/assets/img/2024-05-14-FormsinAngular_2.png)\n\n# GitHub\n\n\n\n\nhttps://github.com/Jaydeep-007/angular-forms\n\n# 결론\n\n이 글에서는 Angular에서 사용할 수 있는 양식의 기본 개념과 단계별 구현 방법, 다양한 유효성 검사기와 속성을 통해 다양한 유형의 양식을 살펴보았습니다.","ogImage":{"url":"/assets/img/2024-05-14-FormsinAngular_0.png"},"coverImage":"/assets/img/2024-05-14-FormsinAngular_0.png","tag":["Tech"],"readingTime":11},{"title":"TypeScript에서 형 추론에 대한 신기한 사례","description":"","date":"2024-05-14 14:28","slug":"2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript","content":"\n\n얼마 전에 사이드 프로젝트를 하고 있었어요. 많은 이벤트를 감지하는 특정 라이브러리를 사용했죠.\n\n제 프로젝트에서도 같은 종류의 이벤트를 사용하고 싶어서 바퀴를 다시 발명하지 않으려고 했어요.\n\n라이브러리 제작자들은 이벤트 리스너 함수의 오버로딩된 첫 번째 매개변수로 이벤트를 넣었어요, 여기처럼요:\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n}\n```\n\n\n\n의도했던 것은 적절한 유형 정의를 가져오고 계속하는 데 단지 몇 초만 걸릴 줄 알았어요.\n\n그러나 몇 초라는 시간은 분으로 늘어났죠. 더 놀라운 건, 반으로 눈 깜짝할 사이에 또 쿼터로 더 빨라졌어요. 반 시간이 흐른 후, 화면을 의심스럽게 바라보게 되었어요.\n\n\"어떻게 간단한 유형 추론이 이렇게 복잡할 수 있지?\" 라고 생각했죠.\n\n# 기본사항\n\n\n\nTS v. 5.2.2에서 제시된 모든 예제를 테스트했어요.\n\n제가 언급한 오버로드 함수는 아래와 비슷했습니다:\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n    (event: 'eventB'): void;\n    (event: 'eventC'): void;\n    // ...\n    (event: 'eventZ'): void;\n}\n```\n\n간결함을 위해 추가 매개변수와 각각 다른 반환 유형은 제거했어요. 제 업무는 이벤트 종류를 추출하여 문자열 리터럴 유니언을 형성하는 것이었죠.\n\n\n\n위의 예시에서는:\n\n```js\ntype EventType = 'eventA' | 'eventB' | 'eventC' | /*...*/ | 'eventZ';\n```\n\n내가 먼저 떠오른 것은 Parameters`T` 타입 앨리어스를 사용하는 것이었다. 반환 타입에 경악했다.\n\n```js\ntype NotEventType = Parameters<OverloadedFunction>[0];\n// type NotEventType = \"eventZ\"\n```\n\n\n\n'eventZ'만 왜 나왔을까요?\n\n![이미지](/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_0.png)\n\nParameters 타입 정의를 자세히 살펴봤습니다 (여기서는 조금 간단히 했습니다):\n\n```js\ntype Parameters<T> = T extends (...args: infer R) => any ? R : never;\n```\n\n\n\n위의 내용은 너무 많은 매개변수를 추출한다고 생각했어요. 바로 첫 번째 매개변수만 직접 타겟팅할 수 있을 거라 생각해 시도해 봤는데 결과는 여전히 같았어요.\n\n```js\ntype FirstParameter<T> = T extends (arg: infer R, ...args: never) => any\n  ? R\n  : never;\n\ntype NotEventType = FirstParameter<OverloadedFunction>;\n// type NotEventType = \"eventZ\"\n```\n\n마지막 오버로딩된 매개변수 타입을 추출했기 때문에 오버로드된 함수 타입이 제대로 분배하지 않은 유니언 타입이라고 생각했습니다.\n\n# 유니온 분배\n\n\n\n가정해보세요. 우리가 유니언 타입 A를 가지고 있다고 해봅시다.\n\n```js\ntype A = 1 | 2 | 3;\n```\n\n우리는 이 유니언에서 1을 제거하고 싶습니다. 다음과 같은 방법을 시도해 볼 수 있습니다.\n\n```js\ntype AWithout1 = A extends 1 ? never : A;\n// type AWithout1 = 1 | 2 | 3\n```\n\n\n\n놀라셨나요? TypeScript가 여기서 올바르게 동작한 것을 염두에 두세요. 위의 내용에서 A extends 1은 다음을 의미합니다:\n\nA의 연합 타입 멤버는 숫자 리터럴 1을 확장합니까?\n\n그리고 2가 1을 확장하지 않기 때문에, 답은 명백히 \"아니요\"입니다.\n\n우리는 연합 분배를 필요로 합니다. 연합 타입에서 1을 제거하기 위해 다음 예제에서 그렇게 했습니다:\n\n\n\n```js\ntype IsNotOne<T> = T extends 1 ? never : T;\n\ntype AWithout1 = IsNotOne<A>;\n// type AWithout1 = 2 | 3\n```\n\n조건부 타입에 A를 전달하면, T extends 1 조건은 다음을 의미합니다:\n\n현재 평가 중인 유니온 멤버가 숫자 리터럴 1을 확장하는가?\n\n계산의 결과는 never | 2 | 3이지만, never는 TypeScript의 타입 유니언에서 중립적인 요소입니다. 만약 대수를 공부한 적이 있다면, 지금이 그것이 도움이 될 때입니다.\n\n\n\n회원 배포에 대해 더 알고 싶다면 다른 이야기를 읽어보세요:\n\n오버로드된 함수 유형이 연합임을 확신하고 문제를 해결할 수 있다고 믿고 유형을 분배하는 데 시간을 투자했습니다.\n\n그리고 나는 그것이 연합이 아니었다는 것을 깨달았어요!\n\n![이미지](/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_1.png)\n\n\n\n# 재미없는 코딩\n\n그 날 TypeScript에 대해 새로운 것을 배웠어요. 오버로드된 함수 타입이 어떻게 작동하는지 이해하고 싶어서 더 깊이 파고들었죠.\n\n첫 번째 위대한 발견은 추론을 실험해볼 때였어요. 함수 타입이 어떻게 작성되었는지 한 글자 한 글자 따라 해보았더니, 아래 코드를 만들어냈어요:\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n    (event: 'eventB'): void;\n    (event: 'eventC'): void;\n    // ...\n    (event: 'eventZ'): void;\n}\n\ntype FirstParameter<T> = T extends {\n    (arg: infer A, ...args: never): any;\n    (arg: infer B, ...args: never): any;\n  }\n    ? A | B \n    : never;\n\ntype NotEventType = FirstParameter<OverloadedFunction>;\n// type NotEventType = \"eventC\" | \"eventZ\"\n```\n\n\n\n아주 원시적인 해결책을 찾았어요. 하지만 해결책이란 게 있었어요. 'FirstParameter`T`' 형식 뒤에 코드를 생성할 수 있었죠. 다만, 이벤트 종류의 수가 변경되면 형식의 정확성을 잃을 것 같았어요.\n\n또한, 얼마나 많은 추론 매개변수를 필요로 하시나요?\n\n이 해결책을 오버로드의 수를 모르는 다른 함수에 재사용할 수 있을까요? 저는 하나의 오버로드와 두 가지 추론으로 테스트를 시작했어요. 결과를 보고는 당황했지만요.\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n}\n\ntype FirstParameter<T> = T extends {\n    (arg: infer A, ...args: never): any;\n    (arg: infer B, ...args: never): any;\n  }\n    ? A\n    : never;\n\ntype NotEventType = FirstParameter<OverloadedFunction>;\n// type NotEventType = \"eventA\"\n```\n\n\n\nFirstParameter`T`의 반환 유형은 A이므로 NotEventType은 이벤트A입니다. 그러나 B를 반환하면 NotEventType은 동일합니다! 더 실험해본 결과, 함수 오버로드에 대한 추론보다 더 많은 추론이 있는 경우, 전자는 항상 적절한 유형을 포함한다는 결론을 내렸습니다.\n\n추론은 항상 아래에서 시작되며 다음 예시에서 명확히 나타납니다.\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n    (event: 'eventB'): void;\n}\n\ntype FirstParameter<T> = T extends {\n    (arg: infer A, ...args: never): any;\n    (arg: infer B, ...args: never): any;\n    (arg: infer C, ...args: never): any;\n    (arg: infer D, ...args: never): any;\n  }\n    ? A\n    : never;\n\ntype NotEventType = FirstParameter<OverloadedFunction>;\n```\n\n여기서 D만 `eventB`를 포함하고 A, B, C는 `eventA`를 가리킨다는 것을 알 수 있습니다.\n\n\n\n# 연구\n\n결국, 나는 인터넷을 통해 나만의 연구를 진행했습니다. 다른 사람들과 같은 해결책에 도달한 것으로 밝혀졌습니다. TypeScript의 한계에 도달한 것으로 보입니다.\n\n믿기 어려워서 TypeScript AST 뷰어를 실행시키고 오버로드가 있는 함수를 전달했습니다. 그 결과로 다음과 같은 추상 구문 트리를 반환받았습니다.\n\n![이미지](/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_2.png)\n\n\n\nAST가 올바르게 보였기 때문에 TS 컴파일러가 함수 오버로드 내에서 특정 추론을 지원하지 않았다고 가정했습니다.\n\n# 해결책\n\n모든 소프트웨어 개발자는 어떤 문제에 대해 여러 해결책을 찾아야 한다고 믿습니다. 제 경우, 아이디어를 아래에 나열했습니다. 노력이 필요한 양에 따라 순서를 매겼고, 각각에 대해 장단점이 있습니다.\n\n## 문자열로서 이벤트 종류를 입력하기\n\n\n\n모든 이벤트 종류는 문자열입니다. 하지만 그 역은 성립하지 않습니다. 이 해결책을 선택하면 유형 안정성을 희생하고 지능적인 코드 복잡성을 잃을 것이라고 판단했습니다. 다른 한편으로는 유형 확인을 충족시키기 위해 추가 리소스를 소비할 필요가 없을 것입니다.\n\n적절한 테스트를 추가하면 이 해결책이 더욱 유효함을 입증할 것입니다.\n\n맞습니다, 이것을 선택했습니다.\n\n## 타입 추론을 사용하기\n\n\n\n이 이야기에 언급된 대로, 이벤트 종류를 추론하기 위한 타입 별칭을 생성할 수 있습니다. 이러한 타입 별칭은 이벤트 종류가 변경될 때 다시 생성해야 합니다. 긍정적인 면으로는 라이브러리를 포크하거나 대체할 필요가 없다는 것입니다.\n\n## 타입 생성하기\n\n사용 가능한 타입 정의로부터 이벤트 종류를 추출하는 스크립트를 작성할 수 있습니다. 타입 추론과 마찬가지로 라이브러리를 업데이트할 때마다 스크립트를 실행해야 합니다. 다시 말해서, 이 종속성은 프로젝트에 유지됩니다.\n\n## 라이브러리 포크하기\n\n\n\n그들을 이기지 못하면 함께 하라.\n\n이 속담은 소프트웨어 개발에서도 의미가 있어요. 특정 라이선스가 있는 오픈 소스 라이브러리를 포크하고 그에 맞게 변경할 수 있습니다. 저의 경우에는 모든 이벤트 종류를 유형 리터럴 열거형으로 수집하여 내보낼 거예요.\n\n정기적으로 라이브러리의 새로운 버전이 있는지 확인하고 포크를 업데이트해야 해요.\n\n다소 부드러운 대안은 라이브러리 유지 관리자와 변경 사항을 논의하는 것이에요.\n\n\n\n## 라이브러리 변경하기\n\n가끔은 다른 라이브러리로 변경하는 것이 합리적으로 들릴 수 있습니다. 적합한 TypeScript 지원이 없다면 그것이 당신이 다루기를 원하는 마지막 짚널이 될 수도 있습니다. 상업 프로젝트의 경우, 그러한 급격한 변화는 이해관계자들과 진지한 토론이 필요할 수 있습니다.\n\n# 요약\n\n프로그래밍 언어를 사용하여 현실을 모델링합니다. 모델은 정의상 불완전합니다. 컴파일러 팀이 더 중요한 기능에 집중하고 있기 때문에 어떤 패턴에 대한 지원이 부족할 수 있습니다. 우리는 언어의 기능을 이해하고 적절히 활용해야 합니다.\n\n\n\n이것은 우리가 항상 기술을 지속적으로 개선해 나가야 한다는 것을 의미합니다. 시간이 지남에 따라 컴파일러가 개선되어 더 많은 패턴을 수용할 수 있게 됩니다. 예를 들어, TypeScript 4.9 버전이 나오기 전까지 변수가 두 가지 유형과 일치하도록 할 수 없었습니다.\n\n제 이야기를 읽어 주셔서 감사합니다!\n\nTypeScript로 고생하시는 것에 지쳤나요? 이 글을 읽어보세요:","ogImage":{"url":"/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_0.png","tag":["Tech"],"readingTime":7}],"page":"106","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}