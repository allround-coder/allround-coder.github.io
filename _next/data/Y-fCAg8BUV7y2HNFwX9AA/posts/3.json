{"pageProps":{"posts":[{"title":"JS 초보자를 위한 가이드 Part 1  스코프, 클로저, 호이스팅, 모듈 이해하기","description":"","date":"2024-06-27 18:16","slug":"2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules","content":"\n\n![이미지](/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_0.png)\n\n- Scope: 변수에 대한 접근 가능성을 정의하며, 코드 내에서 어디에서 접근할 수 있는지를 나타냅니다.\n- Closure: 실행 범위 외부에서 실행되더라도 어휘적 범위를 기억하는 함수입니다.\n- 호이스팅은 JavaScript 메커니즘으로, 변수 및 함수 선언이 코드의 선언 위치와 관계없이 컴파일 단계 중에 해당 범위의 맨 위로 이동됩니다. 이는 변수 및 함수가 선언되기 전에 사용될 수 있다는 것을 의미합니다.\n\n명령형(어떻게, 무엇) 대 선언형(무엇)\n명령형 - 작동 방식을 알고 작동 방식을 알 수 있습니다.\n선언형 - 작동 방식을 알지 못한 채, 무엇이 동작하는지만 알 수 있습니다. JS 배열 맵 함수와 같은 예시\n\n![이미지](/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_1.png)\n\n<div class=\"content-ad\"></div>\n\nScope 이전에 JS에서 변수를 선언하는 방법을 먼저 이해해야 합니다.\nlet vs var vs const\n\n![이미지](/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_2.png)\n\nScope는 변수의 접근 가능성(가시성)을 결정합니다. JavaScript에는 3가지 유형의 scope가 있습니다: ES6(2015) 이전에는 JavaScript에서 전역 Scope 및 함수 Scope만 있었지만, 블록 Scope는 나중에 let과 const로 도입되었습니다.\n\n- 전역 Scope: 어떤 함수 내에서도 선언되지 않은 변수들은 전역 Scope를 갖습니다.\n프로그래밍 환경에서 전역 Scope는 모든 다른 Scope에서 볼 수 있는 Scope입니다. 이는 브라우저에서는 window 객체에 연결되고 Node.js에서는 전역(global)에 연결됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar globalVar = 10;  \nfunction foo() {     \n   console.log(globalVar); // 사용 가능 \n   console.log(window.globalVar); // 사용 가능\n}  \nconsole.log(globalVar);\nconsole.log(window.globalVar);\nfoo(); // 출력: 10 10 10 10\n```\n\n2. 지역 범위: 함수 내에서 선언된 변수는 지역 범위를 갖습니다.\n함수 내에서 선언된 변수를 지역 변수라고 하며 함수 범위에 속합니다. 지역 변수는 함수 내 어디에서든 접근할 수 있습니다 (기능 블록 내).\n\n```js\nfunction foo() {     \n   var localVar = 20;    \n   if(true){\n   var blocklocalVar = 2\n    } \n   console.log(localVar); // 사용 가능 \n   console.log(blocklocalVar) // var의 함수 범위 때문에 접근 가능\n }  \nfoo(); \n\nconsole.log(localVar);\n// 출력: 20 2\n// 오류: localVar이(가) 정의되지 않았습니다\n```\n\n3. 블록 범위: let과 const는 블록 범위 변수이며, if, for, while 등의 블록을 기준으로 합니다.\n\n<div class=\"content-ad\"></div>\n\nES6는 JavaScript에 let 및 const라는 두 가지 중요한 새로운 키워드를 소개했습니다. 이 두 키워드는 JavaScript에서 블록 범위를 제공합니다. ' ' 블록 내에서 선언된 변수는 블록 외부에서 액세스할 수 없습니다. 예: If else 블록, for 루프 블록 등\n\n예시 (let을 사용한 블록 스코프):\n\n```js\nfunction example() {\n  if (true) {\n    let blockVar = '블록 내부에 있어요';\n    console.log(blockVar); // 접근 가능\n  }\n  console.log(blockVar); // 오류: blockVar가 정의되지 않았습니다\n}\nexample();\n```\n\n- 예시 (const를 사용한 블록 스코프):\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction example() {\n  const PI = 3.14;\n  if (true) {\n    const blockConst = 'I am inside a block';\n    console.log(PI); // Accessible\n    console.log(blockConst); // Accessible\n  }\n  console.log(PI); // Accessible\n  console.log(blockConst); // Error: blockConst is not defined\n}\nexample();\n```\n\n만약 var를 사용한다면 (함수 스코프)\n\n```js\nfunction example() {\n  const PI = 3.14;\n  if (true) {\n    var blockConst = 'I am inside a block';\n    console.log(PI); // Accessible\n    console.log(blockConst); // Accessible\n  }\n  console.log(PI); // Accessible\n  console.log(blockConst); // Error: blockConst is not defined\n}\nexample();\n3.14\nI am inside a block\n3.14\nundefined\n```\n\n```js\nfunction outer() {\n  var outerVar = 'I am outer';\n  function inner() {\n    console.log(outerVar); // Accessible\n  }\n  inner();\n}\nouter(); // 출력: I am outer\n```\n\n<div class=\"content-ad\"></div>\n\n범위의 예시\n\n1. (let을 사용한 루프 변수 범위): 블록\n\n```js\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// 결과: 0\n// 결과: 1\n// 결과: 2\n```\n\n2. var를 사용한 루프 변수 범위: 함수 또는 전역 범위\n\n```js\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// 결과: 3\n// 결과: 3\n// 결과: 3\n```\n\n<div class=\"content-ad\"></div>\n\n3. 중첩된 블록 내에서 let으로 재선언: 블록 스코프\n\n```js\nfunction example() {\n  let x = 10;\n  if (true) {\n    let x = 20;\n  }\n  console.log(x); // 출력: 10\n}\nexample();\n```\n\n4. 중첩된 블록 내에서 var로 재선언: 함수 또는 전역 스코프\n\n```js\nfunction example() {\n  var x = 10;\n  if (true) {\n    var x = 20;\n  }\n  console.log(x); // 출력: 20\n}\nexample();\n```\n\n<div class=\"content-ad\"></div>\n\n5. var 및 let을 사용한 호이스팅:\n\n```js\nconsole.log(x); // 결과: undefined\nvar x = 10;\n```\n\n```js\nconsole.log(x); // 오류: 초기화 전에 'x'에 액세스할 수 없음\nlet x = 10;\n```\n\n6. let 및 const를 사용한 블록 스코프:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction example() {\n  if (true) {\n    const x = 10;\n    console.log(x); // 출력: 10\n  }\n  console.log(x); // 오류: x가 정의되지 않았습니다\n}\nexample();\n```\n\n\n## 2. 클로저:\n\n- 정의: 클로저는 함수가 다른 곳에서 실행되더라도 주변 변수를 \"기억\"하는 것을 말합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction outer() {     \n  var outerVar = 'I am outer';      \n  function inner() {         \n   console.log(outerVar); // outer 함수 외부에서도 호출될 때 접근 가능     \n  }      \n return inner; // inner 함수 반환 \n}  \nvar closureFunc = outer(); // outer 실행, inner 반환 \nclosureFunc(); // 출력: I am outer\n```\n\n2. Loop & Closure: 클로저를 사용하는 루프에서 흔히 범하는 함정.\n\n```js\nfunction createFuncArray() {     \nvar funcArray = [];      \nfor (var i = 0; i < 5; i++) {         \n  funcArray.push(function() {            \n  console.log(i); // 항상 5를 출력하며, 0, 1, 2, 3, 4가 아님        \n });    \n }      \nreturn funcArray; \n}  \nvar myFuncArray = createFuncArray(); \nmyFuncArray[0](); // 출력: 5\n```\n\n루프 예제의 함정을 피하려면, IIFE(즉시 실행 함수 표현)를 사용하여 각 반복마다 클로저를 생성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```javascript\nfunction createFuncArray() {\n   var funcArray = [];\n   for (var i = 0; i < 5; i++) {\n       (function(num) {\n           funcArray.push(function() {\n               console.log(num);\n           });\n       })(i);\n   }\n   return funcArray;\n}\nvar myFuncArray = createFuncArray();\nmyFuncArray[0](); // 출력: 0\n```\n\n자바스크립트를 마스터하기 위해서는 스코프와 클로저를 이해하는 것이 기본이 됩니다. 이러한 예제들은 좋은 시작점이 될 것입니다!\n\n3.\n\n```javascript\nfunction makeCounter() {\n    var count = 0;\n\n    return function() {\n        return ++count;\n    };\n}\n\nvar counter1 = makeCounter();\nconsole.log(counter1()); // 출력: 1\nconsole.log(counter1()); // 출력: 2\n\nvar counter2 = makeCounter();\nconsole.log(counter2()); // 출력: 1 (다시 1부터 시작)\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서:\n\n- makeCounter() 함수는 카운트 변수를 증가시키고 반환하는 내부 함수를 반환합니다.\n- makeCounter()가 호출될 때마다, 자체 카운트 변수를 가진 새로운 렉시컬 환경이 생성되며, 이는 외부 스코프에서 숨겨져 있습니다.\n- counter1과 counter2가 호출될 때, 각각 자체 독립적인 카운트 변수를 가지며, 각각 자체 상태를 독립적으로 유지합니다.\n- 클로저는 내부 함수가 makeCounter() 실행이 끝난 후에도 포함된 스코프의 카운트 변수에 접근할 수 있도록 형성됩니다.\n\n클로저 스코프 체인\n\n모든 클로저에는 세 가지 스코프가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 지역 스코프 (자체 스코프)\r\n- 포함 스코프 (블록, 함수 또는 모듈 스코프가 될 수 있음)\r\n- 전역 스코프\n\n```js\n// 전역 스코프\nconst e = 10;\nfunction sum(a) {\n  return function (b) {\n    return function (c) {\n      // 외부 함수 스코프\n      return function (d) {\n        // 지역 스코프\n        return a + b + c + d + e;\n      };\n    };\n  };\n}\nconsole.log(sum(1)(2)(3)(4)); // 20을 출력합니다.\n```\n\n- 호이스팅\n호이스팅은 변수와 함수의 값을 초기화/할당하기 전에도 변수와 함수의 값을 추출할 수 있게 해주는 개념으로, 이는 실행 컨텍스트의 첫 번째 단계 (메모리 생성 단계 또는 생성 단계)로 인해 발생합니다.\n- JavaScript에서 호이스팅은 기본 동작으로 모든 선언을 코드 실행 전에 해당 범위의 맨 위로 이동시키는 것입니다. 기본적으로 함수와 변수가 선언된 위치와 상관없이 해당 범위의 맨 위로 이동되기 때문에 전역이든 지역이든 상관없이 우리에게 이점을 제공합니다.\n- 참고: JavaScript는 선언을 호이스트하지만 초기화는 호이스트하지 않습니다.\n- JavaScript는 프로그램에서 정의된 모든 변수와 함수에 대해 실행 전에 메모리를 할당합니다.\n\n1. var로 호이스팅:\n\n<div class=\"content-ad\"></div>\n\n- 예제 1: 변수 선언 호이스팅\n\n```js\nconsole.log(x); // 결과: undefined\nvar x = 10;\n```\n\n- 예제 2: 함수 선언 호이스팅\n\n```js\nhoistedFunction(); // 결과: \"호이스팅된 함수\"\nfunction hoistedFunction() {\n  console.log(\"호이스팅된 함수\");\n}\n```\n\n<div class=\"content-ad\"></div>\n\n2. let으로 호이스팅:\n\n- 예제 3: 변수 선언 호이스팅\n\n```js\nconsole.log(x); // 오류: 초기화 전에 'x'에 액세스할 수 없음\nlet x = 10;\n```\n\n- 예제 4: 함수 선언 호이스팅 없음\n\n<div class=\"content-ad\"></div>\n\n```js\nnotHoistedFunction(); // 에러: notHoistedFunction이 정의되지 않았습니다.\nlet notHoistedFunction = function() {\n  console.log(\"호이스팅되지 않은 함수\");\n}\n```\n\n3. const로 호이스팅:\n\n- 예제 5: 변수 선언 호이스팅\n\n```js\nconsole.log(x); // 에러: 초기화 전에 'x'에 접근할 수 없음\nconst x = 10;\n```\n\n<div class=\"content-ad\"></div>\n\n4. 함수 스코프에서 호이스팅:\n\n- 예제 6: 함수 내부의 호이스팅\n\n```js\nfunction example() {\n  console.log(innerVar); // 출력: undefined\n  var innerVar = '내부 변수';\n  console.log(innerVar); // 출력: 내부 변수\n}\nexample();\n```\n\n- 예제 7: 블록 내부의 호이스팅 (let 및 const로 호이스팅 없음)\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction example() {\n  console.log(innerLetVar); // 오류: 초기화되기 전에 'innerLetVar'에 액세스할 수 없습니다\n  let innerLetVar = '내부 let 변수';\n  console.log(innerLetVar); // 위의 오류로 이 줄은 실행되지 않습니다\n}\nexample();\r\n\r\n5. 중첩된 스코프에서 호이스팅:\n\n- 예제 8: 중첩된 함수에서 호이스팅\n\nfunction outer() {\n  console.log(outerVar); // 결과: 정의되지 않음\n  var outerVar = '바깥 변수';\n  inner();\n  function inner() {\n    console.log(outerVar); // 결과: 바깥 변수\n  }\n}\nouter();\n\n<div class=\"content-ad\"></div>\n\n6. 함수 표현식을 이용한 호이스팅:\n\n- 예시 9: 함수 표현식 호이스팅\n\nvar myFunc = function() {\n  console.log(\"함수 표현식\");\n};\nmyFunc(); // 출력: 함수 표현식\n\n7. 다른 스코프 유형에서의 호이스팅:\n\n<div class=\"content-ad\"></div>\n\n- 예제 10: 전역 범위에서 호이스팅\n\nconsole.log(globalVar); // 출력: undefined\nvar globalVar = '전역 변수';\nconsole.log(globalVar); // 출력: 전역 변수\n\n4. ES6 모듈\n모듈을 사용하면 코드를 별도의 파일로 캡슐화하고 그들 간에 기능을 import/export할 수 있습니다.\n\n기본 모듈 내보내기:\n\n<div class=\"content-ad\"></div>\n\n// moduleA.js\nexport function greet() {\n  console.log('Hello');\n}\n\n// main.js\nimport { greet } from './moduleA.js';\ngreet(); // Output: Hello\n\n2. Default Exports:\n\n// moduleB.js\nexport default function greet() {\n  console.log('Hello');\n}\n\n<div class=\"content-ad\"></div>\n\n// main.js\nimport greet from './moduleB.js';\ngreet(); // 출력: Hello\n\n3. 별칭이 지정된 Named Exports:\n\n// moduleC.js\nexport { greet as hello };\n\n// main.js\nimport { hello } from './moduleC.js';\nhello(); // 출력: Hello\n\n<div class=\"content-ad\"></div>\n\n4. 여러 값을 내보내기:\n\n// moduleD.js\nexport function greet() {\n  console.log('Hello');\n}\nexport const PI = 3.14;\n\n// main.js\nimport { greet, PI } from './moduleD.js';\ngreet(); // 결과: Hello\nconsole.log(PI); // 결과: 3.14\n\n<div class=\"content-ad\"></div>\n\n```\n// moduleE.js\nexport default function greet() {\n  console.log('Hello');\n}\nexport const PI = 3.14;\n\n\n\n// main.js\nimport greet, { PI } from './moduleE.js';\ngreet(); // Output: Hello\nconsole.log(PI); // Output: 3.14\n\n\n6. Importing All Exports:\n\n\n// moduleF.js\nexport function greet() {\n  console.log('Hello');\n}\nexport const PI = 3.14;\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// main.js\nimport * as moduleF from './moduleF.js';\nmoduleF.greet(); // 출력: Hello\nconsole.log(moduleF.PI); // 출력: 3.14\n```\n\n7. 부수 효과용 모듈 가져 오기:\n\n```js\n// moduleG.js\nconsole.log('Module G가 로드되었습니다');\n```\n\n```js\n// main.js\nimport './moduleG.js'; \nconsole.log(\"Main.js 파일이 실행 중입니다\")\n// 출력: // 먼저 가져온 파일이 먼저 실행되어\nModule G가 로드되었습니다\nMain.js 파일이 실행 중입니다\n```\n\n<div class=\"content-ad\"></div>\n\n8. 다이나믹 Imports:\n\n```javascript\n// main.js\nconst moduleName = './moduleA.js';\nimport(moduleName).then(module => {\n  module.greet(); // 출력: Hello\n});\n```\n\n9. 모듈 재내보내기:\n\n```javascript\n// moduleH.js\nexport function greet() {\n  console.log('Hello');\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// moduleI.js\nexport { greet } from './moduleH.js';\n// main.js\nimport { greet } from './moduleI.js';\ngreet(); // Output: Hello\n```\n\n10. Conditional Module Loading:\n\n```js\n// main.js\nif (condition) {\n  import('./moduleA.js').then(module => {\n    module.greet(); // Output: Hello\n  });\n} else {\n  import('./moduleB.js').then(module => {\n    module.greet(); // Output: Hi\n  });\n}\n```\n\n  `export default` 구문과 일반 `export` 구문은 JavaScript 모듈에서 값을 내보내는데 모두 사용됩니다. 그러나 다른 모듈에서 가져오고 사용하는 방법에는 차이가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n1. export default:\n\n- export default을 사용하면 모듈에서 하나의 값을 내보낼 수 있습니다.\n- 기본 내보내기를 가져올 때는 가져온 값에 대해 원하는 이름을 사용할 수 있습니다.\n- 기본 내보내기를 가져올 때는 중괄호 '{}'가 필요하지 않습니다.\n- 모듈당 기본 내보내기는 하나만 가질 수 있습니다.\n\n예시:\n\n```js\n// ModuleA.js\nconst value = 'Hello';\nexport default value;\n```  \n\n<div class=\"content-ad\"></div>\n\n```js\n// ModuleB.js\nimport myValue from './ModuleA.js';\nconsole.log(myValue); // 출력: Hello\n```\n\n2. `export default` 없이 (이름 있는 수출):\n\n- 이름 있는 수출을 사용하면 모듈에서 여러 값을 내보낼 수 있습니다.\n- 이름 있는 수출을 가져올 때 내보낸 값과 동일한 이름을 사용해야 합니다.\n- 이름 있는 수출을 가져올 때 중괄호 `{}`를 사용해야 합니다.\n- 모듈 당 여러 이름 있는 수출을 가질 수 있습니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n\n// ModuleA.js\nexport const value1 = 'Hello';\nexport const value2 = 'World';\n\n\n\n// ModuleB.js\nimport { value1, value2 } from './ModuleA.js';\nconsole.log(value1); // Output: Hello\nconsole.log(value2); // Output: World\n\n\n요약하면, export default는 모듈에서 단일 값을 지정하지 않고 내보내는 데 사용되며, named exports는 여러 값을 내보내는 데 사용되며 가져올 때 동일한 이름을 지정해야 합니다. 특정 프로젝트 요구에 따라 유용하게 사용됩니다.\n\nCommonJS와 ES6 모듈을 예제와 함께 비교하여 그 차이를 설명해 보겠습니다:\n\n\n<div class=\"content-ad\"></div>\n\n1. CommonJS:\n\n- CommonJS는 주로 서버 측 개발을 위해 Node.js에서 사용되는 모듈 시스템입니다. 이는 동기적이며 블로킹 방식으로, 모듈은 런타임에서 동기적으로 로드됩니다.\n\nCommonJS 예제:\n\n```js\n// ModuleA.js\nconst greeting = 'Hello';\nfunction sayHello() {\n  console.log(greeting);\n}\nmodule.exports = {\n  greeting,\n  sayHello\n};\n```\n\n<div class=\"content-ad\"></div>\n\n```js\r\n// ModuleB.js\nconst moduleA = require('./ModuleA');\nmoduleA.sayHello(); // Output: Hello\nconsole.log(moduleA.greeting); // Output: Hello\r\n```\n\n2. ES6 Modules:\n\n- ES6 modules are a newer module system introduced in ECMAScript 2015 (ES6). They are asynchronous and support both synchronous and asynchronous module loading.\n\nExample with ES6 Modules:\n\n<div class=\"content-ad\"></div>\n\n```js\n// ModuleA.js\nconst greeting = 'Hello';\nexport function sayHello() {\n  console.log(greeting);\n}\nexport { greeting };\n```\n\n```js\n// ModuleB.js\nimport { sayHello, greeting } from './ModuleA.js';\nsayHello(); // 출력: Hello\nconsole.log(greeting); // 출력: Hello\n```\n\n비교:\n\n동기 vs. 비동기:\n\n<div class=\"content-ad\"></div>\n\n- CommonJS 모듈은 동기적이고 블로킹이며, 실행 시 동기적으로 로드됩니다. 이는 서버 측 프로그래밍과 잘 어울리며, 블로킹 I/O 작업이 일반적인 경우에 적합합니다.\n  \n- ES6 모듈은 구현에 따라 동기적이거나 비동기적일 수 있습니다. 더 유연하며 서버 측 및 클라이언트 측 환경에서 모두 사용할 수 있습니다.\n\n사용 편의성:\n\n- CommonJS 모듈은 module.exports 및 require()를 사용하여 각각 기능을 내보내고 가져옵니다. 이 구문은 직관적이며 이해하기 쉽습니다.\n  \n- ES6 모듈은 export 및 import 문을 사용하여 기능을 내보내고 가져옵니다. 이 구문은 더 현대적이고 언어 명세와 일치하지만, 아직 ES6 모듈을 네이티브로 지원하지 않는 환경에서 변환을 위한 추가 도구가 필요할 수 있습니다.\n\n브라우저 호환성:\n\n<div class=\"content-ad\"></div>\n\n- CommonJS 모듈은 브라우저에서 네이티브로 지원되지 않습니다. CommonJS 코드를 브라우저가 이해할 수 있는 형식으로 변환하기 위해 Browserify나 Webpack과 같은 번들러가 필요합니다.\n- ES6 모듈은 최신 브라우저에서 지원되며 많은 경우 추가 도구 없이 네이티브로 사용할 수 있습니다. 그러나 오래된 브라우저에서 ES6 모듈을 지원하기 위해서는 Babel과 같은 도구를 사용하여 트랜스 파일링이 필요할 수 있습니다.\n\n서버 측 사용 사례:\n\n- Node.js는 주로 서버 측 프로그래밍에 사용되며, 동기적인 성격과 쉬운 사용성 때문에 CommonJS 모듈이 잘 어울립니다. 런타임에서 모듈을 동기적으로 로드할 수 있으며, 서버는 모듈이 로드된 후에 실행을 계속할 수 있습니다.\n- 브라우저 환경에서는 JavaScript 코드가 클라이언트 측에서 실행되며, 응답성을 보장하고 UI 쓰레드를 차단하지 않기 위해 비동기 작업이 선호됩니다. 따라서 웹 개발에서는 비동기적 모듈 로딩을 지원하는 AMD (Asynchronous Module Definition) 또는 ES6 모듈과 같은 다른 모듈 시스템이 일반적으로 사용됩니다.\n\n성능 고려 사항:\n\n<div class=\"content-ad\"></div>\n\n- CommonJS 모듈은 동기적으로 로드되어 브라우저 환경에서 특히 많은 모듈이 있는 대규모 웹 애플리케이션의 성능에 영향을 미칠 수 있습니다. 동기적 모듈 로딩은 페이지 로드 시간이 더 느려지고 응답성이 감소할 수 있습니다.\n- 다른 모듈 시스템인 AMD나 ES6 모듈에서 지원하는 비동기 모듈 로딩은 모듈이 병렬로 로드되도록 허용하여 모듈 종속성을 로드하는 데 걸리는 시간을 줄여 성능을 향상시킵니다.\n\n요약하면, CommonJS 모듈은 동기적 특성과 사용 편의성으로 인해 Node.js에서 서버 측 개발에 적합합니다. ES6 모듈은 더 많은 다양성을 제공하며 남종적 및 클라이언트 측 개발에서 점점 더 채택되고 있으며 비동기 모듈 로딩 및 현대적 구문을 지원합니다.","ogImage":{"url":"/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_0.png"},"coverImage":"/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_0.png","tag":["Tech"],"readingTime":15},{"title":"아름다운 데이터 시각화를 디자인하는 방법 Shirley Wu와의 인터뷰","description":"","date":"2024-06-27 18:14","slug":"2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu","content":"\n\n## 셜리 우는 인기 있는 Data Sketches 프로젝트의 절반으로, 매우 상호 작용적인 데이터 시각화와 데이터 주도적 예술을 만들어냅니다. 여기서 그녀는 뒷면을 엿보게 해주며 배운 교훈을 공유합니다\n\n![이미지](/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_0.png)\n\n셜리 우는 샌프란시스코의 대형 데이터 회사에서 프런트엔드 소프트웨어 엔지니어로 일했을 때 데이터 시각화 JavaScript 라이브러리인 D3.js를 알게 되었습니다. 그 도구를 사랑하게 된 이유는 그것이 그녀의 두 가지 주요 관심사인 미술 - 셜리는 네 살 때 그림과 그림을 시작했습니다 - 그리고 수학을 결합했기 때문입니다. 그녀가 트위터에서 자신을 코드 ¾ 및 예술 ¼로 설명하는 것도 놀랍지 않습니다.\n\n대학을 졸업한 지 4년만에 셜리는 독립을 택하고 데이터 시각화를 전문으로 하는 프리랜서가 되었습니다. 그녀는 문화, 정치, 예술 등 다양한 주제를 다루는 다양한 주제를 시각화합니다. 셜리는 자신의 경력에 큰 영향을 미친 세 가지 프로젝트를 2017년에 발표했습니다. 첫 번째는 Daata Sketches [최근 책으로 출간됨]로, 암스테르담의 데이터 시각화 디자이너 나디에 브레먀와의 협업으로, 이는 두 사람을 데이터 시각화 커뮤니티에 소개했습니다. 매월 주제를 선택하여 시각화를 만들고, 전체 프로세스 - 데이터 준비, 아이디어 스케치 및 실행까지 - 을 문서화하는 것이 아이디어였습니다.\n\n<div class=\"content-ad\"></div>\n\n\"라이트업들은 그냥 생각의 흔적이었어요,\" Shirley는 기억합니다. \"하지만 그것이 사람들이 가장 좋아하는 것이 되었어요. 사람들이 와서 우리에게 말해주면서 '뒷이야기를 들여다보고 연출된 최종 결과물 이상의 변화를 볼 수 있어 얼마나 멋진지'라고 말해줍니다. 아주 빠르게 떠올린 아이디어였지만 프로젝트의 이름을 지정하는 데 오랜 시간이 걸렸어요. 우리는 수많은 이름으로 가득 찬 문서를 가지고 있어요. 그 중 하나인 '셜리와 나디의 시각화 마라톤 대모험'이 제일 좋아하는 이름 중 하나에요. 당연히, 그 이름은 선택하지 않았죠!\"\n\n셜리가 유명해지게 한 두 번째 프로젝트는 뮤지컬 '햄릴턴'의 모든 라인을 인터랙티브 시각화한 것이었어요. 이 프로젝트는 The Pudding을 위해 만들어진 것으로, 이는 문화에서 논의되는 아이디어들을 시각 산문으로 설명하는 온라인 출판물이고, 시갛 산문 스튜디오 Polygraph가 제작했어요. 이 프로젝트는 21,000단어를 관련성과 주제적 통찰을 분석하고 D3, React, HTML5 Canvas를 사용했는데, 이를 통해 셜리는 데이터 수집에 대해 호기심을 갖게 되고 창의적으로 활용하는 법을 배웠어요. 이 프로젝트는 2017년 '정보는 아름답다 어워드'의 예술, 엔터테인먼트 및 대중 문화 부문에서 동상을 수상했으며, Data Sketches는 '기이한 부문'에서 금상을 수상했어요.\n\n<img src=\"/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_1.png\" />\n\n# 효과적인 데이터 시각화 작성 과정\"\n\n<div class=\"content-ad\"></div>\n\n그때 구글이 찾아왔어요. 데이터 저널리스트 알베르토 카이로의 예술적인 지도 아래, 구글 뉴스 랩은 전 세계 최고의 데이터 시각화 디자이너들과 협력했어요. 카이로는 데이터 스케치를 발견하고 셜리를 초대하여 거의 40개국의 10년 간의 여행 검색을 조사하고 상위 검색 문화 장소를 탐험하도록 했어요( explore-adventure.com). 한편 브레머는 구글 번역을 통해 영어로 가장 많이 번역된 단어를 분석했죠(www.beautifulinenglish.com).\n\n이 프로젝트는 셜리가 포트폴리오를 굳혀 기회를 얻도록 도왔고, 그녀의 경력은 정말로 발전하기 시작했어요. 셜리는 더 많은 클라이언트를 유치했을 뿐만 아니라 데이터 시각화에 대해 이야기하기 시작했고, 일본, 네덜란드, 독일, 스페인 등 전 세계의 행사에서 워크샵도 진행하게 되었어요. 이야기하는 동안 실시간 코딩을 보여주며, D3가 보다 친근하다는 것을 보여주는 한편 데이터 시각화를 만드는 데는 많은 연습, 인내력, 그리고 인내심이 필요하다는 것도 보여주었죠. 또한 샌프란시스코 베이지역 D3.js 사용자 그룹을 공동 조직하고, Frontend Master를 위해 온라인 강좌를 제작하여 프론트엔드 개발자들에게 D3의 기초부터 분석 및 자체 맞춤 데이터 시각화 설계까지 알려주었어요.\n\n“클라이언트는 항상 데이터 세트를 가져옵니다.” 셜리는 그녀의 과정을 설명합니다. “그것으로 이야기를 전하거나, 탐험적인 것을 만들고 싶어해요. 대부분은 내부 비즈니스 분석이며, 그들은 고객이 왜 그러는지 알려고 노력하고 있어요. 제가 하는 첫 번째 일은 그들의 목표와 전달하려는 내용 또는 학습 목표를 분석하는 것입니다. 둘째, 그들의 대상 청중과 그 청중의 데이터 지식에 관해 물어봐요.”\n\n그 다음 셜리는 데이터, 디자인 및 코드 세 단계를 거칩니다. 먼저 데이터를 탐색하는 것이 중요하죠. 데이터 수집, 정리, 준비 및 분석에는 Node.js 패키지를 많이 사용합니다. 또한 더 복잡한 프로젝트를 위해 데이터 과학 배경을 가진 내이와 자주 협업합니다. 예를 들어, 수상 경력이 있는 '버스트 아웃(Bussed Out)'이란 미국의 무주택자에 대한 강력한 조사 기사로, 위 대가디언(The Guardian)의 조사론시한 작품에는 약 34,000명의 무주택자의 여정을 조사했죠. 시각화의 많은 부분은 '스크롤 스토리 telling 스타일'로 제작되어 있으며 페이지를 스크롤하면 애니메이션이 트리거됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 펜과 종이에서 JavaScript로\n\n셜리가 데이터와 클라이언트의 목표를 이해하면 펜과 종이, 아이패드를 사용하여 아이디어를 디자인하고 스케치하며 종종 시각적 은유를 활용합니다. 최근에는 Mike Bostock과 함께 만든 대화형 JavaScript 노트북 플랫폼 인 Observable을 사용하기 시작했습니다. 이 플랫폼은 데이터 분석, 시각화 및 탐색에 사용되며 시각화 생성 및 데이터에 대한 가설을 확인 또는 반박하기 위해 시각적 결과를 빠르게 생성하는 Vega-Lite 차트 라이브러리와 함께 사용합니다. 클라이언트와의 상의를 통해 원하는 결과물을 도출할 때까지 이러한 도구를 반복적으로 활용하며, 코드 작성 시에는 D3, Vue 및 GreenSock Animation Platform (GSAP)를 주로 사용하고 있습니다. 또한 이야기를 할 수 있는 JavaScript 라이브러리 Scrollama를 활용하여 스크롤 기반 시각화에 대해 탐구하고 있습니다. 또한 SVG에 큰 관심을 가지고 있습니다.\n\nVue로 이동하기 전에는 React를 사용했던 셜리씨입니다. 그는 매우 늦게 채용된 사람이라고 말합니다. \"저는 관심 있는 몇 가지 도구에 집중합니다,\" 라고 설명합니다. \"이 모든 라이브러리는 그냥 도구상자 안의 도구일 뿐이라고 확신합니다. 작업을 완료하기 위해 필요한 최소한의 도구 집합을 이해하려고 합니다. 많은 사람들이 사용해야 한다고 말하기 전까지는 라이브러리를 사용하지 않습니다. 예를 들어, Sarah Drasner은 GreenSock을 소개해 주었고 그녀의 Intro to Vue.js 워크샵도 참여했습니다. 그리고 약 1년 반 동안 그녀와 몇몇 다른 분들이 Vue를 확인해보라고 권유했을 때, 마침내 확인했습니다! 이후로 모든 프로젝트에 Vue를 사용하고 있습니다. 상호작용하는 시각화 작업을 위해서 정말 많은 의미를 가지고 있습니다.\"\n\n프리랜서가 된 이후, 셜리는 기술 측면 뿐만 아니라 디자인도 발전시켰습니다. 이제는 최종 사용자를 더 많이 고려하며 데이터 시각화를 UI의 최고의 실천법과 결합시켜 작은 세부사항과 개인적인 요소를 첨가합니다.\n\n<div class=\"content-ad\"></div>\n\n“좋은 시각화를 만드는 요소, 사람들이 쉽게 읽을 수 있는 요소, 그리고 우리가 패턴을 인식하는 심리를 활용하는 방법을 배우고 싶었어요. 그래서 데이터 시각화 디자인에 관한 워크숍을 가르치기로 결정했죠. 그러다 몇 권의 책을 읽게 되었어요. 제가 가장 좋아하는 책 중 하나는 Alberto Cairo의 'The Functional Art'입니다. 매우 실용적이고 제 작업 방식을 많이 변화시켰어요.”\n\n# 3차원 데이터 시각화\n\n샤리는 처음으로 물리적 데이터 설치물에 도전했어요. 개념 예술가 Ekene Ijeoma의 2015년 작품인 'Wage Islands'를 보고 나서부터 언젠가 물리적인 작업을 하고 싶어했었어요. 이 작품은 뉴욕시의 지형지도를 검은 잉크로 수중에 가라앉혀 저임금 노동자가 어디서 지불 가능한 임대료를 지출할 수 있는지를 시각화해주는 상호작용 설치물입니다. 이를 통해 저렴한 주택 공급 위기에 대한 주목을 불러일으킵니다.\n\n“그것이 상호작용하는 3D 예술작품이었기 때문에 너무 놀랍더라고요,” 샤리가 말했습니다. “작은 휴대폰이나 데스크탑 화면을 넘어서는 무언가. 제가 물리적 데이터 시각화 아이디어에 진짜 열광하기 시작했어요.”\n\n<div class=\"content-ad\"></div>\n\n셜리는 모든 프로젝트가 2D로 구성되어 있음을 깨닫고, 물리적인 예술 작품을 만들고 싶다면 3차원으로 생각해야 한다는 것을 깨달았습니다. 그래서 Matt DesLauriers의 크리에이티브 코딩 워크샵을 수강하고 배운 기술을 활용하여 세 번째 프로젝트를 만들기 시작했어요. three.js와 WebGL로 구현된 \"Legends\"는 51명의 여성 노벨상 수상자와 그들의 업적을 3D 시각화한 작품입니다. 새로운 기술을 적용하면서 공간, 카메라 및 조명에 대해 많은 것을 배웠어요. 매 수상자는 그들의 위키피디아 페이지에서 추출된 데이터로 표현된 크리스탈로 나타납니다. 수상 카테고리로 색상이 지정되고, '영향'에 따라 크기가 조절되며, 상받은 연대에 따라 위치가 조정됩니다. 한편, 여러 별은 상을 수상한 853명의 남성을 나타냅니다.\n\n![이미지](/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_2.png)\n\n며칠 전에 셜리는 'Legends'를 수정하여 최근 30년 동안의 여성 노벨상 수상자를 나타내는 약간 축소된 물리적 버전을 제작했어요. 이는 창문 설치용으로 laser-cut 나무 꽃으로 표현된 29명의 여성 노벨상 수상자를 특징으로 합니다. 'Flower Power'는 셜리의 스튜디오 동료 앨리스 리와의 협업 작품이며, 독립 일러스트레이터, 예술가이자 2015년 넷 영 디자이너 오브 더 이어인 앨리스 리가 드롭박스, 에어비앤비, 애플 등과 함께 일해 온 경력을 바탕으로 만들어졌습니다. 이는 5x5라는 아트 쇼 및 팝업 샵의 일환으로, 샌프란시스코 미션 디스트릭트에 있는 1099 스튜디오의 다섯 거주자들이 다양한 매체로 구성된 다섯 개의 프로젝트를 선보이는 행사입니다.\n\n![이미지](/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_3.png)\n\n<div class=\"content-ad\"></div>\n\n세번째 디지털 3D 프로젝트는 three.js와 WebGL을 사용해 진행 중입니다. 한 예술 박물관에서 의뢰받아 Legends와 유사한 컨셉으로 홍콩의 여성 작가들을 산으로 표현할 예정입니다(아직 많은 데이터가 부족하다는 점에 주목합니다). 또한 뉴욕 대학교 대화형 통신 프로그램에서의 레지던시도 임박해 있습니다. Shirley의 목표는 자신에게 중요한 주제(예: 성별 균형)를 다루는 의미 있는 시각화를 지속적으로 만드는 것이며, 데이터를 정확하게 표현할 뿐만 아니라 오해할 수 없는 방식으로 표현하는 것입니다.\n\n\"데이터 시각화는 통계와 매우 닮았습니다,\" Shirley는 경계합니다. \"데이터가 올바르게 제시되지 않으면 누군가를 속이는 것이 매우 쉽습니다. 또한 데이터가 결정적이라고 생각하는 경향이 있습니다. 데이터가 말하는 대로라면, 반드시 맞는 것이지만, 대부분의 경우 데이터는 인간에 의해 수집되며 항상 인간적 편향이 있습니다. 아마 그것은 우리가 영원히 제거할 수 없는 것일 수도 있습니다. 그러한 편향을 어떻게 전달할 수 있는지는 정말 흥미로운 도전이 될 것입니다.\"\n\n본 기사는 2019년 net 매거진 321호에 실렸으며, Shirley의 Data Sketches 파트너 Nadieh Bremer 인터뷰도 참조하시기 바랍니다.","ogImage":{"url":"/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_0.png"},"coverImage":"/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_0.png","tag":["Tech"],"readingTime":7},{"title":"HTML5 svg 태그로 이모지 만드는 방법","description":"","date":"2024-06-27 18:04","slug":"2024-06-27-CreatingemojiswithHTML5svgtag","content":"\n\n이미지를 추가한 코드입니다.\n\n`svg` 태그는 서로 다른 모양을 담는 컨테이너이며, 각 모양은 컨테이너 내의 특정 지점에 배치될 수 있습니다. 다음은 `svg` 태그를 살펴봅시다.\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\"></svg>\n```\n\n<div class=\"content-ad\"></div>\n\n폭(width)과 높이(height) 속성은 컨테이너의 크기를 나타냅니다. 폭과 높이를 늘릴수록 이미지의 크기도 컨테이너에 맞게 조정됩니다. Viewbox 속성은 컨테이너의 좌표를 정의합니다.\n\n| viewbox = “x y width height”\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_1.png\" />\n\n기본 모양은 문서 내에 요소를 만들어 컨테이너에 삽입할 수 있습니다. 저희가 이모지를 만들 때 사용할 기본 모양은 원과 사각형입니다.\n\n<div class=\"content-ad\"></div>\n\n우리 이모지를 만드는 데 사용되는 기본 모양입니다\n\n원\n\n원을 만들려면 `circle` 요소를 사용하고 속성을 사용하여 색상과 스타일을 추가합니다.\n\n```js\n<circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"black\"/> \n```\n\n<div class=\"content-ad\"></div>\n\ncx — SVG 태그에서 지정된 너비를 기준으로 x 좌표 지점, cy — SVG 태그에서 지정된 높이를 기준으로 y 좌표 지점, r — 원의 반지름, fill — 색상값을 입력합니다.\n\n사각형\n\n우리는 `rect` 요소를 사용하여 직사각형을 생성하고 속성을 사용하여 색상과 스타일을 추가합니다.\n\n```js\n<rect x=\"35\" y=\"65\" width=\"30\" height=\"5\" fill=\"black\"/>\n```\n\n<div class=\"content-ad\"></div>\n\nx — x 좌표 위치, y — y 좌표 위치, width — 사각형의 너비, height — svg 태그에 대한 높이, fill — 색을 값으로 취합니다.\n\n중립적인 얼굴 이모지\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_2.png\" />\n\n```js\n코드 스니펫\n<svg width=”100\" height=”100\" viewbox=”0 0 100 100\">\n <circle cx=”50\" cy=”50\" r=”40\" fill=”yellow” stroke=”black” stroke-width=”5\"/> //얼굴 \n <circle cx=”35\" cy=”40\" r=”5\" fill=”black”/> //왼쪽 눈\n <circle cx=”65\" cy=”40\" r=”5\" fill=”black”/> //오른쪽 눈\n <rect x=”35\" y=”65\" width=”30\" height=”5\" fill=”black”/> //입\n</svg>\n```  \n\n<div class=\"content-ad\"></div>\n\n웃는 얼굴\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_3.png\" />\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"yellow\" stroke=\"black\" stroke-width=\"5\"/> //얼굴\n  <circle cx=\"35\" cy=\"63\" r=\"5\" fill=\"black\"/> //왼쪽 눈\n  <circle cx=\"65\" cy=\"63\" r=\"5\" fill=\"black\"/> // 오른쪽 눈\n  <circle cx=\"50\" cy=\"40\" r=\"15\"  fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>//입구\n  <rect x=\"30\" y=\"60\" width=\"40\" height=\"18\" fill=\"yellow\" /> //원의 상단 절반을 덮는 사각형\n</svg>\n```\n\n거꾸로 된 웃는 얼굴\n\n<div class=\"content-ad\"></div>\n\n\n![SVG](/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_4.png)\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"yellow\" stroke=\"black\" stroke-width=\"5\"/> \n  <circle cx=\"50\" cy=\"45\" r=\"15\"  fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>\n  <rect x=\"30\" y=\"45\" width=\"40\" height=\"18\" fill=\"yellow\" /> //to hide the lower part of the circle\n  <circle cx=\"35\" cy=\"67\" r=\"5\" fill=\"black\"/> \n  <circle cx=\"65\" cy=\"67\" r=\"5\" fill=\"black\"/>\n</svg>\n```\n\nFrowning face\n\n![SVG](/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"yellow\" stroke=\"black\" stroke-width=\"5\"/> \n  <circle cx=\"35\" cy=\"37\" r=\"5\" fill=\"black\"/> \n  <circle cx=\"65\" cy=\"37\" r=\"5\" fill=\"black\"/>\n  <circle cx=\"50\" cy=\"69\" r=\"11\"  fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>\n  <rect x=\"32\" y=\"70\" width=\"36\" height=\"13\" fill=\"yellow\" /> //아래 반원을 가리는데 사용됩니다\n</svg>\n```\n\n놀라운 모습\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_6.png\" />\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"yellow\" stroke=\"black\" stroke-width=\"5\"/> \n  <circle cx=\"35\" cy=\"37\" r=\"5\" fill=\"black\"/> \n  <circle cx=\"65\" cy=\"37\" r=\"5\" fill=\"black\"/>\n  <circle cx=\"50\" cy=\"65\" r=\"10\"  fill=\"black\" />\n</svg>\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_7.png\" />\n\n읽어 주셔서 감사합니다. 즐거운 하루 되세요!","ogImage":{"url":"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_0.png"},"coverImage":"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_0.png","tag":["Tech"],"readingTime":4},{"title":"이미지 없이 CSS Clip Path로 DOM에 멋진 모양 만드는 방법","description":"","date":"2024-06-27 18:02","slug":"2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages","content":"\n\n## 하트, 별, 그리고 마법의 부적 - 아니면 추가로 화려한 다각형도 괜찮아요.\n\n![shape](/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_0.png)\n\n# 소개\n\n몇 년 전까지, 웹사이트의 배경 모양이나 섹션이 직사각형이 아닌 것들을 원한다면 대부분 디자이너에게 필요한 정적 PNG 또는 JPEG 이미지를 제공받아야 했을 것입니다. 그러나 이후로 CSS는 나아졌어요, 친구들아.\n\n<div class=\"content-ad\"></div>\n\n웹사이트를 업데이트하던 중 페이지 내용을 순수한 흰색과 부드러운 회색이 번갈아가며 나타나는 다른 색상의 배경 섹션으로 분할하는 디자인 변경 작업을 하고 있었어요. 제 디자인 모형에는 일반 블록 요소처럼 페이지를 가로지르는 것이 아니라 오른쪽 위쪽으로 기울어지고 있는 섹션이 하나 포함되어 있었어요.\n\n이제 제가 디자이너에게 배경 이미지를 만들어 달라고 요청할 수도 있었지만, 대신 CSS의 clip-path를 사용하여 나 혼자서 할 수 있는지 확인해 보고 싶었어요. 그리고 놀랍게도 CSS clip-path로 가능했어요.\n\nDOM에서 흥미로운 모양과 시각 요소는 더 이상 디자이너만의 전유물이 아니에요. CSS clip-path와 같은 도구를 이용해 개발자들도 요소를 재구성할 수 있게 되었고, 어떻게 하는지 여러분께 보여드릴게요.\n\n# CSS clip-path\n\n<div class=\"content-ad\"></div>\n\nCSS clip-path 속성에 익숙하지 않은 경우에는 저와 같이 하나씩 알아가면서 그 클리핑 영역을 만들어 낼 수 있습니다. 요소의 어떤 부분이 표시되어야 하는지 설정하는 클리핑 영역을 생성합니다. 영역 내에 있는 부분은 표시되고, 외부에 있는 부분은 숨깁니다.\n\n![이미지](/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_1.png)\n\nclip-path 속성은 다양한 값들을 받아들일 수 있습니다:\n\n- `clip-source`: SVG 요소 url 같은 값을 받아들입니다.\n- `geometry-box`: margin-box나 border-box와 같은 값들을 받아들입니다.\n- `basic-shape`: circle()나 rect()와 같은 값을 받아들입니다.\n- global-values: 상속받은 값이나 되돌아가는(revert) 값을 받아들입니다.\n\n<div class=\"content-ad\"></div>\n\n`geometry-box` 및 `basic-shape` 값을 마찬가지로 한 clip-path에 결합할 수도 있습니다.\n\n```js\n/* 이 CSS는 두 가지 다른 클립 경로 속성을 결합합니다 */\nclip-path: padding-box circle(50px at 0 100px);\n```\n\n`basic-shape` 속성 중 하나인 clip-path는 polygon()을 수용하며, 이것이 내가 기울어진 배경 섹션에 필요한 솔루션이 되었습니다.\n\n# CSS로 재생성해야 하는 다각형\n\n<div class=\"content-ad\"></div>\n\n\n![사진](/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_2.png)\n\n위의 이미지는 CSS clip-path의 polygon() 속성을 사용하여 재현해야 했던 회색 배경 섹션의 스크린샷입니다. 그리고 제가 처음으로 해야 했던 것은 CSS를 적용할 몇 가지 HTML 요소를 만드는 것이었습니다.\n\n## HTML 및 CSS 설정\n\n제가 작업한 사이트는 정적 사이트 생성기 Hugo, Go 기반 프레임워크를 사용했습니다. Hugo는 템플릿을 사용하여 사이트의 HTML을 렌더링하므로 아래 예시 코드는 HTML을 알고 있다면 상당히 익숙할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n여기는 페이지의 “퍼즐 섹션”이라고 내가 지은 별명으로 불리는 코드입니다. 왜냐하면 이 섹션 전면에 퍼즐 조각이 있기 때문이에요. 이 기사를 명확하게 하기 위해, 템플릿에 주입된 Go 변수를 생성된 HTML로 대체했어요.\n\nsingle.html\n\n```html\n<div class=\"about-body\">\n    <!-- 위쪽에 더 많은 HTML 요소들 있음  -->\n\n    <section class=\"puzzle-section section\">\n      <div class=\"container\">\n        <div class=\"row\">\n          <div class=\"col-12 col-md-6 col-lg-6\">\n              <h4 class=\"mb-3\">\n                Lorem ipsum dolor\n              </h4>\n              <p class=\"mb-5\">\n                Sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Ipsum dolor sit amet consectetur adipiscing elit pellentesque.\n              </p>\n              <h4 class=\"mb-3\">\n                Duis aute irure dolor in reprehenderit\n              </h4>\n              <p class=\"mb-5\">\n                in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Consectetur adipiscing elit pellentesque habitant morbi tristique senectus et.\n              </p>\n          </div>\n          <div\n            class=\"col-sm-8 offset-sm-2 col-md-6 offset-md-0 col-lg-6 offset-lg-0\"\n          >\n            <img\n              class=\"img-fluid\"\n              src=\"/images/about/puzzle-pieces.png\"\n              alt=\"Puzzle pieces\"\n            />\n          </div>\n        </div>\n      </div>\n    </section>\n\n     <!-- 아래에 더 많은 HTML 요소들 있음  -->\n  </div>\n```\n\n이 코드 섹션은 비교적 간결하지만, 논의할 가치가 있어요. HTML 요소들 외에도, 다양한 CSS 클래스가 있습니다. 이 CSS 클래스들은 반응형 웹 디자인을 위한 최초의 오픈 소스 CSS 프레임워크 중 하나인 부트스트랩 라이브러리에서 제공됐어요.\n\n<div class=\"content-ad\"></div>\n\nabout-body와 같이 사용하여 사용자 정의 스타일을 추가한 사용자 정의 클래스 중 container, row, col-12 또는 col-md-6, mb-5, mb-3과 같은 클래스가 있습니다.\n\n후자의 클래스들은 모두 Bootstrap 클래스인데, 이는 뷰포트의 폭이 일정 이상인 경우 텍스트 및 이미지 요소가 페이지 폭을 공유하도록 하거나 `p` 태그에 특정 양만큼의 하단 여백을 적용하는 역할을 합니다 (col-md-6, mb-3 또는 mb-5).\n\n그러나이 게시물에서는 Bootstrap 클래스는 중요하지 않습니다. 여기서 주목해야 할 클래스는 모든 텍스트와 퍼즐 조각 이미지를 감싸는 puzzle-section입니다.\n\n이 puzzle-section 클래스에는 우리가 clip-path 속성을 추가하여 텍스트와 이미지 뒤에 연한 회색 배경을 표시하고 약간 기울어진 오른쪽 위의 디자인을 나타낼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## CSS clip-path를 사용하여 퍼즐 섹션의 모양을 변경해 보세요!\n\n일반적인 직사각형 `div`를 균형 잡히지 않은 모양으로 스타일링하는 방법에 대해 잘 몰랐기 때문에 온라인에서 솔루션을 찾기 시작했습니다. 그러더니 유용한 인터랙티브 clip-path 중심 사이트인 CSS clip-path maker를 발견했어요.\n\n![CSS Clip Path](/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_3.png)\n\n이 CSS clip-path maker 웹사이트는 다양한 미리 설정된 모양, 조정 가능한 이미지 크기 및 배경, 그리고 현재 표시된 이미지의 꼭짓점을 원하는 형태로 끌어서 조합할 수 있는 기능을 제공합니다. 화면 하단의 가로선은 정확한 clip-path CSS 값들을 보여주며, 이를 복사하여 개인 프로젝트의 CSS에 붙여넣을 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n저는 시작점으로 평행사변형 프리셋 모양을 선택했고, 그 후에 코너를 끌어서 원래부터 다시 만들려고 했던 배경 섹션의 각도와 일치시켰어요. 정확해 보였을 때, 페이지 아래의 CSS 라인을 클립보드에 복사했어요.\n\n내 프로젝트의 SCSS 파일에, 복사한 클립패스 CSS를 추가하여 연한 회색 배경색 속성과 텍스트 및 퍼즐 조각 이미지가 페이지에서 숨쉴 공간을 가질 수 있도록 일부 패딩을 주었어요.\n\nabout.scss\n\n```js\nabout-body {\n  // 이 화이트는 전체 웹페이지의 흰 배경색을 설정해요\n  background-color: white; \n\n  .puzzle-section {\n    // 클립패스 메이커 웹사이트에서 복사한 클립패스 코드\n    clip-path: polygon(0 0, 100% 0%, 100% 75%, 0% 100%);\n    background-color: light-grey;\n    padding: 2rem 0 10rem 0;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nclip-path에 대한 조금의 CSS만 있으면 정사각형 DOM 요소가 완벽하지 않은 다각형으로 변하는 데 필요한 모든 것이었습니다. 꽤 준수한 작업이네요!\n\n# 결론\n\nCSS는 이미지, 비디오 및 사용자 정의 디자인 요소에 자주 의존하지 않고 웹 개발자들이 할 수 있는 것의 한계를 넓히고 있습니다. 그리고 혼자서 멋진 디자인 작업을 어떻게 수행할지 찾아내는 만족감은 꽤 도전적인 일처럼 느껴집니다.\n\n최근 이것의 한 예는 CSS clip-path 속성을 사용하여 텍스트와 이미지를 위한 배경 상자를 만들어 아래쪽 가장자리가 불규칙한 박스를 만드는 것이었습니다. 모든 모양과 크기의 clip-path를 해독하는 데 전념한 대화형 웹 사이트의 도움으로, 약간 기울어진 이 다각형을 빠르게 처리할 수 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 작은 사이트나 코드 조각을 제공하여 다른 개발자가 매우 특정한 문제를 해결할 때 도움이 되는 분들을 진심으로 감사하게 생각합니다. 여러분 덕분에 인터넷이 더 나아지고 있어요.\n\n몇 주 후에 다시 방문해주세요. 더 많은 JavaScript, React, IoT 또는 웹 개발 관련 내용을 공유할 거예요.\n\n제 글을 절대 놓치고 싶지 않으시면 제 뉴스레터에 가입해주세요: https://paigeniedringhaus.substack.com\n\n읽어주셔서 감사합니다. CSS의 힘만으로 DOM에서 요소의 모양을 바꾸는 법을 배우는 것이 여러분에게 도움이 되었기를 바라며 저도 큰 도움이 되었던 것처럼요.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료 및 추가 자료\n\n- MDN 문서, CSS clip-path\n- CSS clip-path 생성기 웹사이트\n\n원문: https://www.paigeniedringhaus.com.","ogImage":{"url":"/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_0.png"},"coverImage":"/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_0.png","tag":["Tech"],"readingTime":7},{"title":"React에서 Angular로 전환하는 개발자를 위한 10가지 팁","description":"","date":"2024-06-27 17:59","slug":"2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular","content":"\n\n\n![이미지](/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png)\n\nReact에서 Angular로 전환하는 것은 개발자들에게 도전적이면서 보상이 있는 여정일 수 있습니다. 각 프레임워크마다 고유한 원칙, 구문 및 관습이 있어 전환 과정은 신중히 진행되어야 합니다.\n\nFever에서는 특정 언어나 프레임워크의 경험보다는 기술에 기반하여 최고 수준의 엔지니어를 채용하기를 우선시합니다. 따라서, React에서 Angular로의 전환은 우리 엔지니어들에게 일상적인 일입니다.\n\n본 글에서는 React에서 Angular로의 개발자 전환을 원활히 돕기 위해 우리에게 유용했던 10가지 팁을 살펴보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 팁 01: ngIf 구조 지시문 사용하기\n\n● React에서는 조건부 렌더링을 사용하여 컴포넌트나 요소를 렌더링할지 여부를 결정할 수 있습니다. 다음은 이를 구현한 예시입니다:\n\n```js\nconst ConditionalComponent = ({ shouldRender }) => {\n  return shouldRender ? <div>조건에 따라 렌더링됩니다</div> : null;\n};\n```\n\n● Angular에서는 템플릿에서 *ngIf 구조 지시문을 사용하여 요소를 조건부로 렌더링하는 것이 일반적합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<ng-container *ngIf=\"shouldRender\">\n  This is rendered conditionally\n</ng-container>\n```\n\n*Angular v17 will have a new built-in control flow template syntax for if block conditionals\n\n## Tip 02: Using ngFor structural directive\n\n- In React, you use the map function to iterate over an array and create a list of elements.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst ListComponent = ({ items }) => {\n  return (\n    - 목록\n      - {items.map((item, index) => (\n        - <li key={item.id}>\n          - {index + 1}. {item.name}\n      - ))}\n  );\n};\n```\n\n* Angular에서는 *ngFor 구조 지시자를 사용하여 템플릿에서 요소를 반복할 수 있습니다.\n\n```js\n- 목록\n    - <li *ngFor=\"let item of items; let i = index\">\n        { i + 1 }. { item.name }\n    - </li>\n```\n\n* Angular v17에서는 블록 반복기를 위한 새로운 내장 제어 흐름 템플릿 구문이 제공될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 팁 03: TrackByFunction을 사용하여 목록 렌더링 개선하기:\n\n● React에서 요소 목록을 렌더링할 때는 각 요소에 고유한 key 속성을 할당해야 합니다. 이를 통해 React가 각 요소를 고유하게 식별하고 효율적으로 DOM을 업데이트할 수 있습니다.\n\n```js\nconst ListComponent = ({ items }) => {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={item.id}>\n          {index + 1}. {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n};\n```\n\n● Angular에서는 trackBy 함수를 사용하여 동일한 결과를 얻을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n\ninterface ListItem {\n  id: number;\n  name: string;\n}\n\n@Component({\n  selector: 'app-list',\n  template: `\n    <ul>\n      <li *ngFor=\"let item of items; trackBy: trackByFn\">\n        { item.id } - { item.name }\n      </li>\n    </ul>\n  `,\n})\nexport class ListComponent {\n  items: Array<ListItem> = [ \n    { id: 1, name: 'Item 1' }, \n    { id: 2, name: 'Item 2' }\n  ];\n\n  trackByFn(index: number, item: ListItem): number {\n    return item.id; // Return a unique identifier for each item\n  }\n}\n```\n\n## 팁 04: 프로퍼티 바인딩\n\n● React에서는 데이터가 부모 구성 요소에서 자식 구성 요소로 props로 전달됩니다. 자식 구성 요소는 이러한 props을 받아 렌더링에 사용합니다.\n\n```js\nimport React from 'react';\n\nconst ImageComponent = ({ imageUrl }) => {\n  return <img src={imageUrl} alt=\"React Image\" />;\n};\n\nexport default ImageComponent;\n```\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 다음은 Angular에서 속성 바인딩을 사용하는 방법입니다. 속성 바인딩은 컴포넌트의 속성을 HTML 요소 속성이나 디렉티브에 바인딩하는 데 사용됩니다.\n\n```js\n<img [src]=\"imageUrl\" alt=\"Angular Image\" />\n```\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: '<img [src]=\"imageUrl\" alt=\"Angular Image\" />',\n})\nexport class ExampleComponent {\n  @Input() imageUrl: string;\n}\n```\n\n## 팁 05: 이벤트 바인딩\n\n<div class=\"content-ad\"></div>\n\n● React에서는 콜백 함수를 전달하기 위해 props를 사용하여 동일한 기능을 구현할 수 있습니다.\n\n```js\nconst ChildComponent = ({ onCustomEvent }) => (\n  <button onClick={onCustomEvent}>Click me</button>\n);\n\nconst App = () => {\n  const [message, setMessage] = useState('');\n\n  const handleCustomEvent = () => {...};\n\n  return (\n    <ChildComponent onCustomEvent={handleCustomEvent} />\n  );\n};\n```\n\n● Angular에서는 이벤트 바인딩을 통해 사용자 작업 (키 입력, 마우스 이동, 클릭, 터치 등)을 감지하고 대응할 수 있습니다.\n\n```js\n@Component({\n  selector: 'app-child',\n  template: `\n    <button (click)=\"doSomething()\">Click me</button>\n  `,\n})\nexport class ChildComponent {\n  doSomething() {...}\n}\n```\n\n<div class=\"content-ad\"></div>\n\n만일 자료를 부모 컴포넌트로 전달하고 싶다면, 자식 컴포넌트에서 @Output() 데코레이터를 사용할 수 있어요. 이 데코레이터가 있는 속성은 EventEmitter 유형이어야하며, 사용자 정의 이벤트를 발생시킬 때 사용돼요.\n\n```js\n@Component({\n  selector: 'app-child',\n  template: `\n    <button (click)=\"customEvent.emit()\">Click me</button>\n  `,\n})\nexport class ChildComponent {\n  @Output() customEvent: EventEmitter<void> = new EventEmitter<void>();\n}\n\n@Component({\n  selector: 'app-root',\n  template: `<app-child (customEvent)=\"handleCustomEvent()\"></app-child>`,\n})\nexport class AppComponent {\n  handleCustomEvent(): void {...}\n}\n```\n\n## 팁 06: 의존성 주입\n\n● React에서 의존성 주입을 관리하는 일반적인 방법 몇 가지가 있어요:\n\n<div class=\"content-ad\"></div>\n\n- Props\n- Context API\n- Higher-Order Components (HOCs)\n- Render Props\n- React Hooks\n\n● Angular에서는 의존성 주입이 프레임워크의 핵심 부분입니다. Angular는 서비스의 인스턴스를 생성하고 관리하는 역할을 담당하는 인젝터를 제공합니다. 간단한 예시를 확인해보세요:\n\n```js\n@Injectable({\n  providedIn: 'root',\n})\nexport class MyService {\n  getData(): string {\n    return 'Angular 서비스로부터의 데이터';\n  }\n}\n\n@Component({\n  selector: 'app-root',\n  template: `<p>{ message }</p>`,\n})\nexport class AppComponent implements OnInit {\n  message: string;\n  private readonly myService = inject(MyService);\n\n  ngOnInit(): void {\n    this.message = this.myService.getData();\n  }\n}\n```\n\n## 팁 07: 리졸버\n\n<div class=\"content-ad\"></div>\n\nReact에는 Angular의 resolver 기능과 직접적인 동등물이 없습니다. 데이터 가져오기는 보통 컴포넌트 자체 내에서 또는 라이프사이클 메서드, 훅, 또는 외부 라이브러리의 도움으로 처리됩니다. React 컴포넌트에서 사용자 정의 훅을 사용한 간단한 예제가 여기 있어요:\n\n```js\nconst useCustomHook = () => {\n  const [data, setData] = useState(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch('https://api.example.com/data');\n        const result = await response.json();\n        setData(result);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n      }\n    };\n    fetchData();\n  }, []); // 의존성 배열이 비어있어서 효과가 마운트시 한 번만 실행됨\n  return data;\n};\n\nconst MyComponent = () => {\n  const { data } = useCustomHook();\n  return (\n    <div>\n      {data ? (\n        <p>Data from React component: {data}</p>\n      ) : (\n        <p>Loading...</p>\n      )}\n    </div>\n  );\n};\nexport default MyComponent;\n```\n\nAngular에서는 resolver를 사용하여 라우트가 활성화되기 전 데이터를 가져와 해당 컴포넌트가 렌더링되기 전에 필요한 데이터를 보장합니다.\n\n```js\n@Injectable({\n  providedIn: 'root',\n})\nexport class MyDataResolver implements Resolve<string> {\n  private readonly myDataService = inject(MyDataService);\n\n  resolve(): Observable<string> {\n    return this.myDataService.fetchData();\n  }\n}\n\nconst routes: Routes = [\n  {\n    path: 'my-route',\n    component: MyComponent,\n    resolve: {\n      myData: MyDataResolver,\n    },\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n<div class=\"content-ad\"></div>\n\n## 팁 08: 인터셉터\n\n● React에서는 Redux와 같은 상태 관리 미들웨어를 통해 HTTP 인터셉터 기능을 구현할 수 있습니다. 미들웨어는 액션이 리듀서에 도달하기 전에 해당 액션을 가로챌 수 있고 수정하거나 새로운 액션을 디스패치하거나 비동기 작업을 수행할 수 있습니다. Redux 미들웨어를 사용한 간단한 예시를 살펴보겠습니다:\n\n```js\nconst myMiddleware = (store) => (next) => (action) => {\n  // 액션 수정 또는 다른 작업 수행\n\n  // 예를 들어, 액션이 리듀서에 도달하기 전에 액션을 로깅하는 경우\n  console.log('Action:', action);\n\n  // 다음 미들웨어나 리듀서에 액션 전달\n  return next(action);\n};\n\nexport default myMiddleware;\n```\n\n```js\nconst store = createStore(rootReducer, applyMiddleware(myMiddleware));\n\nexport default store;\n```\n\n<div class=\"content-ad\"></div>\n\n● Angular에서 인터셉터는 HttpClient와 등록하여 HTTP 요청이나 응답을 가로챌 수 있는 서비스입니다. React의 미들웨어와는 달리 내장된 HTTPClient에만 작동합니다.\n\n인터셉터를 사용하면 모든 HTTP 요청이나 응답에 전역적으로 공통 동작이나 수정을 적용할 수 있습니다. 아래는 간단한 Angular 인터셉터 예제입니다:\n\n```js\n@Injectable()\nexport class MyInterceptor implements HttpInterceptor {\n  intercept(\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    // 요청을 수정하거나 응답을 전역적으로 처리합니다\n\n    // 예를 들어, 각 요청에 사용자 지정 헤더 추가\n    const modifiedRequest = request.clone({\n      setHeaders: { 'X-Custom-Header': 'Custom Value' },\n    });\n\n    return next.handle(modifiedRequest);\n  }\n}\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule, HttpClientModule],\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: MyInterceptor,\n      multi: true,\n    },\n  ],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n## 팁 09: Rxjs\n\n<div class=\"content-ad\"></div>\n\nRxJS 라이브러리는 비동기 및 이벤트 기반 프로그래밍을 더 선언적이고 조립 가능한 방식으로 처리할 수 있는 도구 세트를 제공합니다. Angular에서 널리 사용됩니다. 간단히 설명하면 다음과 같습니다:\n\nObservables:\n\n- Observable은 시간에 따른 데이터 스트림의 표현입니다.\n- 비동기적으로 여러 값을 방출할 수 있습니다.\n- Observables는 이벤트, 프로미스 또는 수동으로 생성할 수 있는 다양한 소스에서 만들어질 수 있습니다.\n\nObservers:\n\n<div class=\"content-ad\"></div>\n\n- Observer는 Observable에 가입하여 Observable이 방출한 변경 사항이나 새 값에 대한 알림을 받습니다.\n- Observer에는 next(다음 값 처리), error(오류 처리), complete(작업 완료 처리)와 같이 세 가지 콜백 함수가 있습니다.\n\n주요 RxJS 연산자:\n\n- map: 제공된 함수를 사용하여 Observable이 방출한 값을 변환합니다.\n- filter: 주어진 조건에 따라 Observable이 방출한 값을 필터링합니다.\n- mergeMap: 각 소스 값을 Observable로 프로젝트하고 결과 Observable을 하나의 Observable 스트림으로 병합합니다.\n- combineLatest: 여러 Observables에서 최신 값들을 합쳐 하나의 Observable로 조합합니다.\n\n```js\nconst App = () => {\n  const [data, setData] = useState('');\n\n  useEffect(() => {\n    // 버튼 클릭에서 Observable 생성\n    const buttonClick$ = fromEvent(document.getElementById('myButton'), 'click');\n\n    // 각 클릭 이벤트를 처리하고 API 호출을 트리거하는 mergeMap 사용\n    const apiCall$ = buttonClick$.pipe(\n      mergeMap(() => fetch('https://api.example.com/data')),\n      mergeMap(response => response.json())\n    );\n\n    // API 응답에서 원하는 특정 데이터를 추출하기 위해 map을 사용\n    const subscription = apiCall$.subscribe(\n      responseData => setData(responseData.data),\n      error => console.error('오류:', error)\n    );\n\n    return () => subscription.unsubscribe(); // 컴포넌트 해제 시 정리\n  }, []);\n\n  return (\n    <div>\n      <button id=\"myButton\">클릭하세요</button>\n      <p>{data}</p>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 연산자의 전체 리스트를 확인할 수 있습니다: [Operators List](https://rxjs.dev/guide/operators#categories-of-operators).\n\n## 팁 10: Rxjs 구독 취소 시점\n\nAngular에서 메모리 누수를 방지하기 위해 옵저버블의 구독을 해제하는 것이 중요합니다. 옵저버블을 구독하면 옵저버와 옵저버블 사이에 연결이 생성되는데, 이 연결은 더 이상 필요하지 않을 때 닫혀야 합니다. 구독을 해제하지 않으면 잔류 참조와 메모리 누수로 이어질 수 있습니다.\n\nAngular에서 구독을 취소해야 하는 일반적인 시나리오 몇 가지를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n- 컴포넌트 파괴:\n\n```js\n@Component({\n  selector: 'app-my-component',\n})\nexport class MyComponent implements OnInit, OnDestroy {\n  private subscription: Subscription;\n\n  ngOnInit() {\n    this.subscription = someObservable.subscribe(data => {\n      // 데이터 처리\n    });\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n2. 무한 옵저버블:\n\n```js\nexport class MyComponent implements OnInit, OnDestroy {\n  private subscription: Subscription;\n\n  constructor(private infiniteObservableService: InfiniteObservableService) {}\n\n  ngOnInit() {\n    this.subscription = interval(1000).pipe(\n      map((value) => {\n        // 필요에 따라 발행된 값 변환\n        return value * 2;\n      })\n      .subscribe((data) => {\n        this.infiniteData = data;\n      });\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n3. 라우터 이벤트:\n\n```js\n@Component({\n  selector: 'app-my-component',\n})\nexport class MyComponent implements OnDestroy, OnInit {\n  private subscription: Subscription;\n  private router = inject(Router);\n\n  ngOnInit(): void {\n    this.subscription = this.router.events.subscribe(event => {...});\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n4. AsyncPipe\n\nAngular에서 async 파이프는 Observable에 대한 구독을 자동화하고 구성 요소가 파기될 때 구독 해제를 처리합니다. 이는 템플릿에서 비동기 데이터를 다루는 과정을 간소화합니다.\n\n<div class=\"content-ad\"></div>\n\n`async` 파이프를 활용하면 Angular 템플릿에서 Observable에 직접 구독하고 값을 끊임없이 바인딩할 수 있습니다:\n\n```js\n<div>{ observable$ | async }</div>\n```\n\n실제로는 async 파이프가 구독 및 구독 해제 수명주기를 관리해주므며, 깔끔한 자원 관리를 보장하고 메모리 누수를 방지합니다.\n\n- Angular에는 고유한 용어가 있습니다. 익숙하지 않다면 Angular 용어집이 유용할 것입니다: Angular 용어집.\n\n<div class=\"content-ad\"></div>\n\n# 영감을 받은 곳:\n\n[https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3](https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3)\n\n[https://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam](https://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam)\n\n# 참고:\n\n<div class=\"content-ad\"></div>\n\nhttps://angular.io/api/common/NgIf\n\nhttps://angular.io/guide/control_flow#if-block-conditionals\n\nhttps://angular.io/api/common/NgFor\n\nhttps://angular.io/guide/control_flow#for-block---repeaters\n\n<div class=\"content-ad\"></div>\n\n- [TrackByFunction](https://angular.io/api/core/TrackByFunction)\n- [Property Binding](https://angular.io/guide/property-binding)\n- [Event Binding](https://angular.io/guide/event-binding)\n- [inputs-outputs#sending-data-to-a-parent-component](https://angular.io/guide/inputs-outputs#sending-data-to-a-parent-component)\n\n<div class=\"content-ad\"></div>\n\n[https://angular.io/api/core/EventEmitter](https://angular.io/api/core/EventEmitter)\n\n[https://angular.io/api/core/Output](https://angular.io/api/core/Output)\n\n[https://angular.io/guide/http-intercept-requests-and-responses](https://angular.io/guide/http-intercept-requests-and-responses)\n\n[https://angular.io/api/common/http/HttpClient](https://angular.io/api/common/http/HttpClient)\n\n<div class=\"content-ad\"></div>\n\nhttps://angular.io/api/router/Resolve\n\nhttps://angular.io/guide/rx-library\n\nhttps://rxjs.dev/guide/operators#categories-of-operators\n\nhttps://angular.io/api/common/AsyncPipe\n\n<div class=\"content-ad\"></div>\n\nhttps://angular.io/guide/glossary","ogImage":{"url":"/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png"},"coverImage":"/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png","tag":["Tech"],"readingTime":14},{"title":"TypeScript Strict Mode 리팩토링 없이 몇 달 동안 바로 켜야 하는 이유","description":"","date":"2024-06-27 17:58","slug":"2024-06-27-TypeScriptStrictModeTurnItOnImmediatelyWithoutRefactoringforMonths","content":"\n\nTypeScript은 JavaScript 응용 프로그램에 유형 안전성과 코드 문서화를 향상시킵니다. 그러나 이전 프로젝트에서는 엄격 모드가 활성화되지 않을 수 있으며, 이는 유형 안전성의 모든 이점을 제대로 활용할 수 없게 할 수 있습니다. 이것은 새로운 사용자의 진입 장벽을 낮추지만, 일부 버그를 컴파일 시간에 감지하지 못하게 합니다.\n\n![이미지](/assets/img/2024-06-27-TypeScriptStrictModeTurnItOnImmediatelyWithoutRefactoringforMonths_0.png)\n\n## 소프트웨어의 아키텍처가 경제에 미치는 영향\n\n마틴 파울러(Martin Fowler)의 소프트웨어 아키텍처에 대한 인기 있는 정의 중 하나는:\n\n<div class=\"content-ad\"></div>\n\n이러한 결정들은 시간이 지남에 따라 새로운 기능을 추가하는 데 필요한 비용과 노력에 상당한 영향을 미칩니다.\n\n소프트웨어 엔지니어 및 아키텍트로서, 우리의 목표는 내부 코드 품질을 유지하여 코드베이스가 유지 가능하게 하는 것입니다. 이는 빠른 기능 개발과 지속적인 배포를 용이하게 합니다.\n\n## TypeScript의 Strict Mode의 장점\n\nTypeScript의 strict 플래그는 여러 중요한 검사를 활성화하는 일종의 통합 플래그입니다.\n\n<div class=\"content-ad\"></div>\n\n- noImplicitAny\n- noImplicitThis\n- strictNullChecks\n- strictPropertyInitialization\n- strictBindCallApply\n- strictFunctionTypes\n\n이러한 체크는 유형 안전성을 향상시켜 버그를 줄이고 코드 기반을 더 견고하고 유지 관리 가능하게 만듭니다. 그러나 큰 기존 프로젝트에서 엄격 모드를 활성화하면 수천 개의 오류가 발생할 수 있어 한 번에 모두 수정하는 것이 현실적이지 않을 수 있습니다.\n\n## 즉시 켜면 수천 개의 오류가 발생할 수 있습니다\n\n수백 개 또는 수천 개의 TypeScript 파일로 구성된 중대규모 앱을 개발 중이라면 즉시 엄격 모드를 활성화하는 것이 현실적이지 않을 수 있습니다. 컴파일 시간 오류가 여러 개 발생할 수 있어 빌드가 실패할 수 있습니다. 기능 개발을 중단하고 이러한 오류를 수정하기 위해 수개월 동안 엔지니어링 시간을 할당하는 것은 이상적이지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n귀하의 코드베이스의 유형 안정성과 아키텍처를 개선하는 동안 새로운 기능을 계속 배포하는 방법이 있습니다:\n\n- “tsconfig.json” 파일에서 “strict” 플래그를 “true”로 설정 — 이렇게하면 모든 엄격한 검사가 활성화됩니다.\n\n## 새로운 프로젝트\n\n새로운 TypeScript 프로젝트의 경우 처음부터 엄격한 모드를 활성화하는 것이 합리적입니다. 이렇게하면 시간과 귀찮음을 절약하고 소프트웨어의 품질을 크게 향상시킵니다. 개발자는 또한 중요한 JavaScript 및 TypeScript 교훈을 배우며, 안전하고 안정적인 프로그래밍 언어로 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n## 기존 프로젝트\n\n오래된 프로젝트를 다루는 개발자들은 딜레마에 직면합니다. 한편으로는 엄격한 모드를 활성화하여 최상의 품질을 얻고 싶지만, 다른 한편으로는 주요 리팩터링을 거치기 싫어합니다. JSON 파일의 플래그를 true로 설정하는 것은 간단해 보이지만, 대규모 프로젝트에서는 수백 개 또는 수천 개의 오류가 발생할 수 있습니다.\n\n만일 Git 저장소를 사용하고 현재 프로젝트 상태가 올바르다고 가정한다면, 다음과 같은 똑똑한 해결책이 가능합니다:\n\n- 엄격한 모드 활성화 — \"tsconfig.json\" 파일의 \"strict\" 플래그를 \"true\"로 설정합니다.\n- 해킹: 모든 파일에 대해 TypeScript 검사를 수동으로 비활성화 — 모든 *.ts 파일의 첫 번째 줄에 // @ts-nocheck를 추가합니다. (스크립트로 자동화할 수 있습니다)\n- Pre-Commit 후크 추가 — Git 저장소에 커밋 시 // @ts-nocheck 주석이 포함된 커밋을 거부하는 Git 후크를 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\n#!/bin/sh\n\n# 준비 중인 모든 파일 확인\nfor file in $(git diff --cached --name-only); do\n    # 디렉토리와 JavaScript/TypeScript 파일이 아닌 파일은 건너뜁니다.\n    if [ -f \"$file\" ] && [[ \"$file\" =~ \\.(js|ts|jsx|tsx)$ ]]; then\n        if grep -q \"@ts-nocheck\" \"$file\"; then\n            echo \"오류: $file 파일에 // @ts-nocheck이 포함되어 있습니다.\"\n            exit 1\n        fi\n    fi\ndone\n\nexit 0\n```\n\n## 도대체 무슨 일이 일어나고 있는 건가요?\n\n이 아이디어는 오래된 코드는 그대로 두고 새 코드를 엄격한 모드 검사로 개발하는 것입니다. // @ts-nocheck (단계 2)를 추가하면 TypeScript 컴파일러는 해당 파일에 대한 모든 검사를 무시합니다. 이를 통해 오류가 있더라도 프로젝트를 빌드할 수 있으면서도 엄격한 모드를 활성화할 수 있습니다. 후크 (단계 3)는 미래에 // @ts-nocheck가 포함된 파일을 푸시할 수 없도록 합니다. 오래된 파일을 수정하는 경우 엄격한 모드 문제를 해결하고 해킹을 제거한 다음 푸시해야 합니다.\n\n장점:\n\n<div class=\"content-ad\"></div>\n\n- 코드 품질은 계속해서 향상됩니다.\n- 엄격 모드 활성화가 가능합니다.\n\n단점:\n\n- \"혼합 모드\"에서 개발에 더 많은 시간이 필요합니다 (즉, 파일에 // @ts-nocheck 주석이 아직 있는 경우).\n\n## 추가 단계\n\n<div class=\"content-ad\"></div>\n\n에러 및 경고의 수가 증가하지 않도록 오류 임계값을 추가할 수 있어요. 먼저 다음 명령을 사용하여 보고서를 생성해보세요:\n\n```js\neslint . --format=json --output-file=eslint-report.json; node ./eslint-config.js\n```\n\n이 명령을 실행하면 모든 오류가 포함된 JSON 파일이 생성됩니다. 그런 다음 오류의 수를 계산하고 유효성을 확인하기 위해 Node.js 스크립트(eslint-config.js)를 작성해보세요:\n\n```js\nconst errors = require('./eslint-report.json');\n\nconst ERROR_THRESHOLD = 1212;\nconst WARNING_THRESHOLD = 53;\n\nconst totalErrors = errors.reduce((sum, error) => sum + error.errorCount, 0);\nconst totalWarnings = errors.reduce((sum, error) => sum + error.warningCount, 0);\n\nif (totalErrors > ERROR_THRESHOLD) {\n    console.error(`에러 임계값 초과: 발견된 오류 수 ${totalErrors}개 (임계값: ${ERROR_THRESHOLD})`);\n    process.exit(1);\n}\n\nif (totalWarnings > WARNING_THRESHOLD) {\n    console.error(`경고 임계값 초과: 발견된 경고 수 ${totalWarnings}개 (임계값: ${WARNING_THRESHOLD})`);\n    process.exit(1);\n}\n\nconsole.log(`린팅 통과: ${totalErrors}개의 오류, ${totalWarnings}개의 경고`);\n```\n\n<div class=\"content-ad\"></div>\n\nCI/CD 파이프라인에이 스크립트를 추가하여 오류 또는 경고의 수가 증가할 때마다 빌드를 실패하도록 설정하세요. 시간이 지남에 따라 오류를 수정하고 임계값을 점차 낮춰보세요.\n\n이 실천을 따르면 모든 오류를 점진적으로 수정할 수 있습니다.\n\n읽어 주셔서 감사합니다! 이 내용이 도움이 되었기를 바랍니다. 만약 도움이 되었다면 댓글로 알려주시면 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-06-27-TypeScriptStrictModeTurnItOnImmediatelyWithoutRefactoringforMonths_0.png"},"coverImage":"/assets/img/2024-06-27-TypeScriptStrictModeTurnItOnImmediatelyWithoutRefactoringforMonths_0.png","tag":["Tech"],"readingTime":5},{"title":"React에서 Lazy Loading의 내부 작동 원리 이해하기","description":"","date":"2024-06-27 17:56","slug":"2024-06-27-UndertheHoodofLazyLoadinginReact","content":"\n\n우리와 함께 게으른 로딩의 세계로 들어가보세요! 이 블로그에서는 게으른 로딩 뒤에 숨겨진 비밀을 밝혀내며, 이 똑똑한 기술이 앱의 성능을 최적화하는 방법을 안내해 드릴 거에요. 리액트가 어떻게 구성 요소를 동적으로 로드하고 사용자 경험을 향상시키는 지 살펴보며 함께 재미있게 탐험해 봐요. 당신의 앱 속도와 효율을 높이기 준비가 되셨나요? 함께 시작해봅시다!\n\n# 게으른 로딩이란?\n\n게으른 로딩은 이미지와 같은 웹페이지의 일부를 필요할 때까지 로딩을 지연시키는 기술입니다. 모든 것을 한 번에 로딩하는 것이 아니라(열렬한 로딩), 브라우저는 사용자가 스크롤하거나 해당 부분과 상호 작용할 때에만 리소스를 요청합니다. 이는 웹페이지의 빠른 로딩과 성능 향상에 도움이 됩니다.\n\n# 왜 게으른 로딩이 필요할까요?\n\n<div class=\"content-ad\"></div>\n\n리액트에서는 일반적으로 전체 코드가 번들링되어 한꺼번에 배포됩니다. 이는 성능에 큰 영향을 미치지 않기 때문에 작은 Single Page Applications (SPAs)에 대해 잘 작동합니다. 그러나 고객 및 관리자 포턄을 따로 두는 콘텐츠 관리 시스템과 같은 대규모 애플리케이션의 경우, 한꺼번에 모든 것을 로딩하는 것은 효율적이지 않습니다. 이는 불필요한 데이터 전송으로 이어져 웹사이트 로딩이 느려지게 됩니다. 고객은 관리자 기능이 필요 없으므로 이를 로딩하는 것은 메모리와 시간을 낭비하게 됩니다.\n\n# 리액트에서 어떻게 lazy loading을 구현할까요?\n\n리액트에서 lazy loading을 구현하려면 React.lazy 함수와 Suspense 컴포넌트를 함께 사용할 수 있습니다. 다음은 이를 어떻게 할 수 있는지 설명하는 간단한 예시입니다:\n\n- 리액트와 필요한 컴포넌트를 가져오기:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React, { Suspense, lazy } from 'react';\n```\n\n2. \n적게 로드되는 구성 요소를 정의하십시오:\n\n구성 요소를 직접 가져 오는 대신 React.lazy를 사용하여 게으르게로드하십시오.\n\n```js\nconst LazyComponent = lazy(() => import('./LazyComponent'));\n```\n\n<div class=\"content-ad\"></div>\n\n3. `Suspense`로 지연로드된 컴포넌트 감싸기:\n\n지연로드된 컴포넌트를 가져오는 동안 로딩 스피너와 같은 대체 UI를 제공하도록 `Suspense` 컴포넌트를 사용하세요.\n\n```js\nfunction App() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <LazyComponent />\n      </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n완성된 예시는 여기에 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport React, { Suspense, lazy } from 'react';\n\n// 컴포넌트의 Lazy로딩\nconst LazyComponent = lazy(() => import('./LazyComponent'));\n\nfunction App() {\n  return (\n    <div>\n      <h1>My App</h1>\n      <Suspense fallback={<div>Loading...</div>}>\n        <LazyComponent />\n      </Suspense>\n    </div>\n  );\n}\n\nexport default App;\r\n```\n\n이 예시에서 LazyComponent는 필요할 때만 로드되어서 애플리케이션의 초기 로드 시간을 단축시킵니다. Suspense 컴포넌트는 LazyComponent가 로드될 때까지 대체 UI(이 경우 간단한 \"로딩 중...\" 메시지)를 보여줍니다.\n\n# 내부적으로 Lazy Loading은 어떻게 작동하나요?\n\n우선, 이 주제에서 React 내부에서 어떻게 Lazy Loading이 설정되는지 설명하겠습니다. 이 주제를 잘 이해하기 위해서는 Fiber 노드와 그 속성에 익숙해져야 합니다.\n\n<div class=\"content-ad\"></div>\n\n더 많은 정보를 원하시면 Fiber 노드에 관한 이 기사를 참조해보세요: React에서 Virtual DOM 구조 이해하기.\n\n여기에서 다이어그램은 레이지 로딩이 추가되었을 때 Fiber 노드 트리가 어떻게 작동하는지, 동적 import promise가 실행되는 방식, 그리고 폴백이 표시되는 방식을 보여줍니다.\n\n![다이어그램](/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_0.png)\n\nSuspense Fiber 노드: 이 노드는 동적 import의 promise를 포함하는 WeakSet을 추적합니다.\n\n<div class=\"content-ad\"></div>\n\n예시: import('./LazyComponent')로 생성된 promise;\n\nReact.offScreen 노드: 이 노드는 나태한 promise를 추적하여 해결되었는지 여부를 결정합니다. 이 노드에서는 보류 중인 결과를 promise에서 기다립니다.\n\n![](/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_1.png)\n\n_payload 프로퍼티에서 _result는 promise(동적 import)이 포함되어 있으며, _status에는 promise의 상태(예: 0은 대기 중)가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\nFallback Div Node: 만약 프라미스가 보류 상태인 경우, 대체 div가 표시됩니다. 이 대체 div는 React.offScreen의 형제 포인터에서 나옵니다.\n\n프라미스가 해결될 때 실제 컴포넌트가 표시되는 과정에 대한 설명입니다.\n\n![이미지](/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_2.png)\n\nSuspense 노드: WeakSet은 프라미스를 추적하며, 프라미스가 해결되면 세트가 비워집니다.\n\n<div class=\"content-ad\"></div>\n\nReact.offScreen 노드: 이 노드는 실제 구성 요소를 표시하도록 값을 업데이트합니다. 형제 포인터를 null로 설정하고 실제 구성 요소를 자식 포인터로 설정합니다. 대기 중인 props가 변경되어 memorizedProps 와 동일해집니다.\n\n그리고 Pending props가 변경되고 memorized props 와 동일해집니다.\n\n![이미지](/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_3.png)\n\n약속이 이행되면: _result 속성에는 실제 모듈이 저장됩니다. _status 속성은 약속이 오류 없이 이행되었음을 나타내는 1로 설정됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 만약 지연 컴포넌트가 사용되지 않는다면?\n\n만약 지연 컴포넌트가 사용되지 않는다면, React.offScreen 노드가 트리에 생성되지 않고 프로미스가 실행되지 않습니다. 따라서 추가 작업이 수행되지 않습니다.\n\n# 요약\n\n- 프로미스가 해결되면, 실제 컴포넌트가 React.offScreen 노드를 업데이트하여 표시됩니다.\n- 지연 컴포넌트를 사용하지 않는 경우, 추가 노드나 프로미스가 생성되거나 실행되지 않습니다.","ogImage":{"url":"/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_0.png"},"coverImage":"/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_0.png","tag":["Tech"],"readingTime":4},{"title":"파이썬 숫자에 대해 미리 알았으면 좋았을 6가지 팁","description":"","date":"2024-06-27 17:55","slug":"2024-06-27-6ThingsIWishIKnewEarlierAboutPythonNumbers","content":"\n\n아래는 Mardown 형식을 사용한 표태그입니다:\n\n\n| 열1 | 열2 |\n|-----|-----|\n| 내용1 | 내용2 |\n| 내용3 | 내용4 |\n\n\n<div class=\"content-ad\"></div>\n\n```python\ny: float = 3.45e-4\n\nprint(y) # 0.000345\n```\n\n- 1.25e5 means 1.25 * 10 ^ 5 (which is 100000)\n- 3.45e-4 means 3.45 * 10 ^ -4 (which is 0.0001)\n\nWith this, we can easily type out very large and very small numbers without having to ensure that we’ve typed the correct number of zeros.\n\n# 2) We can insert underscores in our numbers\n\n\n<div class=\"content-ad\"></div>\n\n그래서 숫자를 읽기 쉽게 하기 위해 0을 모아 놓을 수 있습니다.\n\n```js\nx: int = 1_000_000_000\n\nprint(x) # 1000000000\n```\n\n^ 여기서는 3개의 0 사이마다 _ 하나를 넣어서 한 눈에 10억이라는 것을 알 수 있도록 만듭니다.\n\n```js\ny: int = 1_0_0_00_000\n\nprint(y) # 10000000\n```\n\n<div class=\"content-ad\"></div>\n\n^ 각 그룹당 3 개의 숫자가 있어야 하는 것은 의무적이 아닙니다. 원하는 만큼 많은 숫자 그룹당 0을 넣을 수 있지만, 저는 3개로 고정하는 것이 가장 읽기 쉽다고 생각했습니다.\n\n# 3) 음수 소수 자릿수로 round() 할 수 있습니다\n\n숫자를 -2 소수 자릿수로 round() 하면, 해당 숫자를 가장 가까운 100의 배수로 반올림합니다.\n\n```js\nx: int = 123456\n\nprint(round(x, -2)) # 123500\n```\n\n<div class=\"content-ad\"></div>\n\n숫자를 -3 소수점 자리로 round() 함수를 사용하면, 가장 가까운 1000으로 올립니다.\n\n```js\nx: int = 123456\n\nprint(round(x, -3)) # 123000\n```\n\n숫자를 -4 소수점 자리로 round() 함수를 사용하면, 가장 가까운 10000으로 올립니다.\n\n```js\nx: int = 123456\n\nprint(round(x, -4)) # 120000\n```\n\n<div class=\"content-ad\"></div>\n\n# 4) divmod() 함수를 사용하여 //와 %를 동시에 수행할 수 있어요\n\n```js\na, b = divmod(57, 10)\n\nprint(a) # 5\nprint(b) # 7\n```\n\n내장 함수인 divmod(a, b)는 2개의 정수 a와 b를 입력으로 받고, (몫, 나머지)를 담은 튜플을 반환해요.\n\n- 57을 10으로 나눈 결과는 몫이 5이고, 나머지가 7이에요\n- a // b를 하면 몫을 얻을 수 있어요\n- a % b를 하면 나머지를 얻을 수 있어요\n\n<div class=\"content-ad\"></div>\n\n`divmod` 함수를 사용하면 동시에 이를 수행할 수 있어서, 우리가 `//`와 `%`를 동시에 해야 할 때 코드 한 줄을 절약할 수 있어요.\n\n# 5) 양수 무한대와 음수 무한대\n\n`float('inf')`를 사용하면, 사실 양의 무한대를 얻을 수 있어요.\n\n```js\nx: float = float('inf')\n\nprint(x) # inf\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 float(`-inf`)를 실행하면 음의 무한대를 얻습니다.\n\n```js\ny: float = float('-inf')\n\nprint(y) # -inf\n```\n\n양의 무한대는 다른 모든 숫자보다 큽니다. 반면 음의 무한대는 다른 모든 숫자보다 작습니다.\n\n```js\nx: float = float('inf')\n\nprint(x > 1)          # True\nprint(x > 1_000_000)  # True\nprint(x > 3.14e100)   # True\n```\n\n<div class=\"content-ad\"></div>\n\n```js\ny: float = float('-무한대')\n\nprint(y < -1)          # True\nprint(y < -1_000_000)  # True\nprint(y < -1e1000)     # True\n```\n\n우리는 다른 모든 숫자보다 크거나 작은 숫자가 필요할 때 양의 무한대 혹은 음의 무한대를 사용할 수 있습니다.\n\n# 6) 내장 decimal 모듈\n\nPython에는 내장된 decimal 모듈이 있어서 간단히 가져와서 사용할 수 있으며, 십진수 숫자를 다룰 수 있는 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom decimal import Decimal\n\na: Decimal = Decimal(1) / Decimal(3)\n\nprint(a) # 0.3333333333333333333333333333\n```\n\n하지만 왜 우리는 보통의 부동 소숫점 숫자 대신 이것을 사용해야 할까요?\n\n- 부동 소숫점 숫자는 근사값입니다\n- 부동 소숫점 숫자는 부동 소수점의 정확도 문제가 발생할 수 있습니다\n- Decimal은 더 정확하게 설계되어 있습니다\n\n```python\na: float = 2.0\nb: float = 2.000000000000000000000001\n\nprint(a == b) # True\n```\n\n<div class=\"content-ad\"></div>\n\n특정 지점을 넘어서면 부동 소수점 정밀도 부정확성이 발생할 수 있으며, 이는 작은 숫자에 대해 문제가 될 수 있습니다.\n\n# 7) (보너스) 복소수\n\n수학 수업에서 복소수라는 이상한 개념을 다뤘던 기억이 나시나요? 파이썬에서도 이를 할 수 있습니다.\n\n```python\na: complex = complex(5, 7)\n\nprint(a)        # (5+7j)\nprint(type(a))  # <class 'complex'>\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 5 + 7j는 5 + 7i를 의미해요 (실수 부분 5 + 허수 부분 7)\n\n```js\na: complex = complex(5, 7)\n\nprint(a.real)  # 5.0\nprint(a.imag)  # 7.0\n```\n\n^ 우리는 .real과 .imag을 사용하여 허수의 실수부와 허수부를 추출할 수 있어요.\n\n```js\nimport cmath\n```  \n\n<div class=\"content-ad\"></div>\n\n^ 내장 cmath 모듈을 가져와서 다양한 복소수 연산을 수행할 수 있어요! (자세히 설명하지는 않겠죠)\n\n저는 직장에서 이것을 사용해본 적이 없어요 (왜 쓰겠어요 ㅋㅋ), 그래도 재미있는 사실을 알게 되어서 기뻤어요.\n\n# 유머 콘텐츠\n\n# 제작자로서 저를 지원하고 싶으시다면\n\n<div class=\"content-ad\"></div>\n\n- 제 책을 구매해주세요! — 파이썬에 대해 알지 못했던 101가지 이야기\n- 어디서 찾을 수 있나요: https://payhip.com/b/vywcf\n- 이 이야기에 박수 50번 치세요\n- 당신의 생각을 남겨주세요\n- 이 이야기에서 가장 마음에 드는 부분을 강조해주세요\n\n감사합니다! 이 작은 행동이 큰 도움이 되며, 정말 감사드립니다!\n\nYouTube: https://www.youtube.com/@zlliu246\n\nLinkedIn: https://www.linkedin.com/in/zlliu/","ogImage":{"url":"/assets/img/2024-06-27-6ThingsIWishIKnewEarlierAboutPythonNumbers_0.png"},"coverImage":"/assets/img/2024-06-27-6ThingsIWishIKnewEarlierAboutPythonNumbers_0.png","tag":["Tech"],"readingTime":4},{"title":"NestJS 데이터 검증 및 변환하는 방법","description":"","date":"2024-06-27 17:54","slug":"2024-06-27-NestJSDataValidationandTransformation","content":"\n\n이 보고서는 Node.js 서버 측 애플리케이션 개발을 위한 프레임워크 인 NestJS에서 데이터 유효성 검사 및 변환 기술을 요약합니다.\n\n## 데이터 유효성 검사의 중요성\n\n데이터 유효성을 검사함으로써 컨트롤러 계층에 도달하기 전에 미리 정의된 규칙을 준수하는지 확인할 수 있습니다. 이를 통해 다음과 같은 문제가 방지됩니다:\n\n- 잘못된 또는 해로운 데이터: SQL 인젝션 및 예기치 않은 데이터 유형과 같은 공격에 대비합니다.\n- 오류 및 예외: 유효하지 않은 데이터 형식으로 인한 오류를 방지합니다.\n\n<div class=\"content-ad\"></div>\n\n## 장점\n\n높은 데이터 무결성: 데이터가 정의된 규칙을 준수하는 것을 보장합니다.\n오류 감소: 잘못된 데이터로 인한 문제를 방지합니다.\n더 깔끔한 코드: 데이터 유효성 검증 논리를 컨트롤러로부터 분리합니다.\n\n![이미지](/assets/img/2024-06-27-NestJSDataValidationandTransformation_0.png)\n\n# 컨트롤러 이전에 DTO 및 입력 데이터의 유효성 검사를 확인하세요.\n\n<div class=\"content-ad\"></div>\n\nhttps://github.com/typestack/class-validator\n\n![image](/assets/img/2024-06-27-NestJSDataValidationandTransformation_1.png)\n\n# 패키지 설치\n\n```js\nyarn add class-validator class-transformer\n```\n\n<div class=\"content-ad\"></div>\n\n# 문서 유효성 검사\n\n# 개발자 모드에서 실행\n\n```js\nyarn start:dev\n```\n\n# 파이프 컨트롤러 추가\n\n<div class=\"content-ad\"></div>\n\nmain.ts\n\n```js\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { ValidationPipe } from '@nestjs/common';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalPipes(new ValidationPipe());\n  await app.listen(3000);\n}\nbootstrap();\n```\n\nDTO 폴더\n\n```js\nimport { IsNotEmpty } from 'class-validator';\n\nexport class CreateTaskDto {\n  @IsNotEmpty()\n  title: string;\n\n  @IsNotEmpty()\n  description: string;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# ID가 존재하는지 확인하기\n\n서비스\n\n```js\n  getTaskById(id: string): Task {\n    const found = this.tasks.find((task) => task.id === id);\n    if (!found) {\n      throw new NotFoundException(`ID가 \"${id}\"인 Task를 찾을 수 없습니다`);\n    }\n    return found;\n  }\n```\n\n# 요소가 삭제된 경우 ID가 존재하는지 확인하기\n\n<div class=\"content-ad\"></div>\n\n```js\n  deleteTask(id: string): void {\n    const found = this.getTaskById(id);\n    this.tasks = this.tasks.filter((task) => task.id !== found.id);\n  }\n```\n\n## 요소가 업데이트될 때 ID가 존재하는지 확인\n\n```js\n  updateTaskStatus(id: string, status: TaskStatus): Task {\n    const task = this.getTaskById(id);\n    task.status = status;\n    return task;\n  }\n```\n\n## 상태 업데이트 확인하기\n\n\n<div class=\"content-ad\"></div>\n\ndto 폴더에 update-task-status.dto를 추가해주세요.\n\n```js\nimport { IsEnum } from 'class-validator';\nimport { TaskStatus } from '../tasks.model';\n\nexport class UpdateTaskStatus {\n  @IsEnum(TaskStatus)\n  status: TaskStatus;\n}\n```\n\n컨트롤러\n\n```js\n@Patch('/:id/status')\nupdateTaskStatus(\n  @Param('id') id: string,\n  @Body() updateTaskStatusDto: UpdateTaskStatusDto,\n): Task {\n  const { status } = updateTaskStatusDto;\n  return this.tasksService.updateTaskStatus(id, status);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 검색을 위한 유효성 검사\n\ndto\n\n```js\nimport { IsEnum, IsOptional, IsString } from 'class-validator';\nimport { TaskStatus } from '../tasks.model';\n\nexport class GetTasksFilterDto {\n  @IsOptional()\n  @IsEnum(TaskStatus)\n  status?: TaskStatus;\n\n  @IsOptional()\n  @IsString()\n  search?: string;\n}\n```","ogImage":{"url":"/assets/img/2024-06-27-NestJSDataValidationandTransformation_0.png"},"coverImage":"/assets/img/2024-06-27-NestJSDataValidationandTransformation_0.png","tag":["Tech"],"readingTime":3},{"title":"초보 프로그래머가 흔히 저지르는 실수 10가지","description":"","date":"2024-06-27 17:48","slug":"2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer","content":"\n\n![이미지](/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_0.png)  \n\n우선 한 가지 명백하게 말씀드리겠습니다. 당신이 초보 프로그래머라면, 이 기사는 당신이 저지르고 있는 실수로 인해 자책감을 느끼게 하려는 것이 아니라 오히려 그 실수에 대해 인식하게 하고, 그 실수의 징후를 알려주고, 피할 수 있도록 가르치려는 것입니다.  \n\n과거에 이런 실수들을 저도 했었고, 각각의 실수로부터 배웠습니다. 나 자신이 이를 피하도록 코딩 습관을 형성했어서 기쁩니다. 당신도 그렇게 해야 합니다.  \n\n이러한 실수들은 특정한 순서로 나열되어 있지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# 1) 계획 없이 코드 작성하기\n\n일반적으로 고품질의 쓰기 콘텐츠는 쉽게 만들어질 수 없습니다. 신중한 사고와 연구가 필요합니다. 고품질의 프로그램도 예외는 아닙니다.\n\n고품질의 프로그램을 작성하는 것은 흐름이 있는 과정입니다:\n생각하기. 연구하기. 계획하기. 쓰기. 확인하기. 수정하기.\n불행하게도 이에 대한 좋은 약어는 없습니다. 이 활동들의 적절한 양을 항상 거치도록 하는 습관을 만들어야 합니다.\n\n초보 프로그래머로서 내가 한 가장 큰 실수 중 하나는 많은 사고와 연구 없이 코드 작성을 곧바로 시작한 것입니다. 이 방법은 작은 독립형 응용프로그램에는 동작할 수 있겠지만, 큰 응용프로그램에는 큰 부정적인 영향을 미칩니다.\n\n<div class=\"content-ad\"></div>\n\n당신이 후회할 만한 말을 하기 전에 생각하는 것처럼, 후회할 만한 것을 코딩하기 전에도 생각해야 합니다. 코딩 또한 당신의 생각을 전달하는 방법이에요.\n\n요즘 가장 필요한 것, 현재 시스템에 어떻게 적합한 코드를 작성할지 조사하고 기존 코드를 읽고 작은 테스트 가능한 기능을 작성하는 계획을 세우는 것이 프로그래밍의 주된 부분입니다. 실제 코드를 작성하는 것은 전체 프로세스 중 약 10% 정도라고 볼 수 있어요.\n\n프로그래밍을 코드를 쓰는 것으로만 생각하지 마세요. 프로그래밍은 양육이 필요한 논리 기반의 창의력이에요.\n\n<div class=\"content-ad\"></div>\n\n# 2) 코드를 작성하기 전에 계획을 너무 많이 세우지 마세요\n\n네. 코드를 작성하기 전에 계획을 세우는 것은 좋은 일이지만, 좋은 일도 너무 하면 해로울 수 있어요. 너무 많은 물도 독이 될 수 있어요.\n\n완벽한 계획을 찾지 마세요. 프로그래밍 세계에는 완벽한 계획이란 존재하지 않아요. 충분히 좋은 계획을 찾아보세요, 시작할 수 있는 것이요. 사실은, 당신의 계획은 변할 거예요, 하지만 좋았던 점은 코드에서 더 많은 명확성으로 이끄는 몇 가지 구조를 강요했던 것이죠. 너무 많은 계획은 단지 당신의 시간 낭비일 뿐이에요.\n\n작은 기능에 대한 계획만 얘기하고 있어요. 모든 기능을 한꺼번에 계획하는 건 단죄되어야 해요! 바로 폭포수 접근법이죠. 이것은 하나씩 완료되어야 할 명확한 단계가 있는 선형 계획 시스템을 뜻해요. 이러한 방식으로 얼마나 많은 계획이 필요한지 상상할 수 있죠. 이곳에서 얘기하고 있는 계획은 아니에요. 폭포수 접근법은 대부분의 소프트웨어 프로젝트에 적합하지 않아요. 복잡한 것은 현실에 대한 민첩한 적응을 통해 구현할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n프로그램 개발은 민첩한 활동이어야 합니다. 폭포수 모델 계획에서는 상상조차 하지 못했을 기능을 추가하게 될 것입니다. 그리고 폭포수 모델 계획에서는 고려하지 못했던 이유로 인해 기능을 제거해야 할 때도 있을 것입니다. 버그를 수정하고 변화에 적응해야 합니다. 당신은 기민해야 합니다.\n\n하지만, 항상 다음 몇 가지 기능을 계획하세요. 이를 매우 신중하게 수행해야 합니다. 계획을 너무 적게 하거나 너무 많이 하는 것은 코드 품질에 해를 끼칠 수 있습니다. 코드 품질은 위험을 감수할 수 없는 요소입니다.\n\n# 3) 코드 품질의 중요성을 과소평가하기\n\n작성한 코드의 하나의 측면에만 집중할 수 있다면, 그것은 코드의 가독성이어야 합니다. 이해하기 어려운 코드는 쓰레기입니다. 심지어 재활용할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n코드 품질의 중요성을 절대 얕보지 마세요. 코딩을 구현을 전달하는 방법으로 생각해 보세요. 코더로서 귀하의 주요 업무는 작업 중인 해결책의 구현을 명확하게 전달하는 것입니다.\n\n프로그래밍에 관한 내가 좋아하는 명언 중 하나는 다음과 같습니다:\n\n\"우수한 조언이네요, 존!\"\n\n작은 것들조차 중요하다는 사실을 명심하세요. 예를 들어, 들여쓰기 및 대소문자 사용에 일관성이 없다면, 코드 작성 라이선스를 그냥 잃어버릴만 하다구요!\n\n<div class=\"content-ad\"></div>\n\n\n이것은 \n  생각보다 훨씬 \n중요합니다.\n\n\n또 다른 간단한 것은 긴 줄의 사용입니다. 80자를 넘는 내용은 읽기가 훨씬 어렵습니다. if문 블록을 더 잘 보이게 하려면 동일한 줄에 긴 조건을 넣을 유혹을 느낄 수도 있습니다. 그렇게 하지 말아주세요. 80자 제한을 절대 넘지 마세요.\n\n이러한 간단한 문제들은 린팅 및 서식 지원 도구를 사용하여 쉽게 해결할 수 있습니다. JavaScript에서는 ESLint와 Prettier가 두 가지 우수한 도구로 완벽하게 작동합니다. 자신을 위해 항상 사용해보세요.\n\n다음은 코드 품질과 관련된 몇 가지 더 많은 실수입니다:\n\n\n\n<div class=\"content-ad\"></div>\n\n- 함수나 파일에서 여러 줄을 사용하는 것은 좋은 습관이에요. 코드가 너무 길어지면 관리하기 힘들어지므로 작은 조각으로 나눠서 테스트하고 관리하세요. 제 개인적인 생각으로는 10줄 이상인 함수는 너무 길다고 생각해요. 하지만 이것은 대략적인 기준일 뿐이에요.\n\n- 부정문을 반복해서 사용하는 것은 피하세요. 그러지 말아주세요.\n\n- 변수 이름에 짧고 일반적인 이름을 사용하는 것도 좋지 않아요. 변수에는 명확하고 모호하지 않은 이름을 사용하세요.\n\n- 문자열이나 숫자를 하드코딩하는 것도 좋지 않아요. 고정된 값에 의존하는 로직을 작성하려면 상수에 값을 할당하고 의미 있는 이름을 지어주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst answerToLifeTheUniverseAndEverything = 42;\n```\n\n- 간단한 문제 주변에서 더 많은 시간을 보내지 않기 위해 대충한 단축키와 해결책을 사용하지 마세요. 문제를 피하지 마세요. 현실에 직면하세요.\n\n- 더 긴 코드가 더 좋다고 생각하는 것. 대다수의 경우 더 짧은 코드가 더 나음. 코드를 더 읽기 쉽게 만드는 경우에만 더 긴 버전을 작성하세요. 예를 들어, 코드를 짧게 유지하기 위해 교묘한 한 줄 짜리 표현 및 중첩된 삼항 표현식을 사용하지 마세요. 또한 코드가 필요 이상으로 길어지지 않도록 의도적으로 만들지 마세요. 모든 프로그램에서 불필요한 코드를 삭제하는 것이 가장 좋습니다.\n\n- 조건 로직의 과도한 사용. 대부분의 경우 조건 로직이 필요하다고 생각하는 것은 없습니다. 모든 대안을 고려하고 가독성을 기준으로만 선택하세요. 측정할 수 없는 한 성능 최적화를 피하세요. 관련: Yoda 조건 및 조건 내 할당을 피하세요.\n\n<div class=\"content-ad\"></div>\n\n# 4) 첫 번째 해결책 선택하기\n\n프로그래밍을 시작했을 때 나는 문제를 마주했을 때 해결책을 찾아낸 다음 즉시 그것을 실행해버렸던 것을 기억한다. 첫 번째로 발견한 해결책에 대한 복잡성과 잠재적 실패에 대해 생각하기 전에 즉시 구현을 서두르곤 했다.\n\n첫 번째 해결책은 유혹적일 수 있지만, 좋은 해결책은 일반적으로 발견된 모든 해결책을 의심하기 시작했을 때 얻어진다. 문제에 대해 여러 해결책을 고려할 수 없다면, 그것은 아마도 문제를 완전히 이해하지 못했다는 신호일 것이다.\n\n전문 프로그래머로서 여러분의 역할은 문제에 대한 해결책을 찾는 것이 아닙니다. 문제에 대한 가장 간단한 해결책을 찾는 것입니다. 여기서 \"간단\"하다는 것은 해결책이 제대로 작동하고 충분히 성능이 우수해야 하지만, 여전히 읽기, 이해 그리고 유지가 용이해야 한다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n# 5) 그만 두지 않기\n\n자주 인정하고 싶지 않았던 오류 중 하나는 처음에 발견한 것이 가장 간단한 방법이 아닐 것이라고 인식한 후에도 처음 방법을 계속 고수하는 것입니다. 이겢은 심리적으로 \"그만 두지 않기\" 마인드와 관련이 있을 것입니다. 대부분의 활동에서 가져야 할 좋은 마인드이지만 프로그래밍에는 해당되지 않습니다. 사실, 프로그래밍을 할 때 올바른 마인드는 일찍 실패하고 자주 실패하는 것입니다.\n\n해결책을 의심하기 시작하면, 그것을 버리고 문제를 다시 생각해보아야 합니다. 얼마나 그 해결책에 투자했든지 상관없이 말이죠. GIT 같은 소스 컨트롤 도구를 이용하면 쉽게 다양한 해결책을 시도할 수 있습니다. 그것을 활용하세요.\n\n# 6) 검색하지 않기\n\n<div class=\"content-ad\"></div>\n\n많은 경우에 보물 같은 시간을 낭비하면서 문제를 해결하려고 노력한 적이 많았어요. 그럴 때에는 먼저 구글에서 조사하는 게 더 현명한 선택이 되곤 해요.\n\n혈액순환이 잘 이루어지는 기술을 사용 중이지 않다면, 문제에 부딪혔을 때 누군가가 이미 같은 문제를 겪고 그에 대한 해결책을 찾았을 것입니다. 시간을 절약하고 먼저 구글링을 해보세요.\n\n가끔씩, 구글링을 하다가 여러분이 문제로 생각하고 있는 것이 실제로 문제가 아니라는 것을 알게 되고, 고쳐야 하는 게 아니라 받아들여야 하는 것이라는 사실을 깨닫게 될 때가 있어요. 문제에 대한 해결책을 선택하는 데 필요한 모든 정보를 알고 있다고 가정하지 마세요. 구글은 여러분에게 놀라운 정보를 제공해줄 거예요.\n\n하지만, 구글링할 때 주의해야 해요. 초보자의 특징 중 하나는 다른 사람의 코드를 이해하지 않고 그대로 복사해 사용하는 것입니다. 그 코드가 문제를 올바르게 해결할 수 있더라도, 완전히 이해하지 못하는 코드는 사용하지 말아야 해요.\n\n<div class=\"content-ad\"></div>\n\n창의적인 코더가 되고 싶다면, 자신이 무엇을 하고 있는지 알고 있다고 생각하지 마세요.\n\n# 7) 캡슐화를 사용하지 않기\n\n이 포인트는 객체지향 패러다임을 사용하는 것과는 관련이 없습니다. 캡슐화 개념의 사용은 항상 유용합니다. 캡슐화를 사용하지 않으면 유지보수하기 어려운 시스템으로 이어지는 경우가 많습니다.\n\n어플리케이션에서 특정 기능은 그것을 처리하는 곳이 딱 하나 있어야 합니다. 보통 이것은 단일 객체의 책임입니다. 이 객체는 어플리케이션의 다른 객체가 사용하는 데 절대적으로 필요한 것만을 노출해야 합니다. 이는 비밀스러울 필요가 있는 것이 아니라 애플리케이션의 다른 부분 간 의존성을 줄이는 개념에 관한 것입니다. 이러한 규칙을 따르면 클래스, 객체 및 함수의 내부를 안전하게 변경할 수 있으며 큰 규모로 문제를 일으킬 걱정 없이 변경할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n논리와 상태의 개념적 단위는 각각 고유한 클래스를 가져야 합니다. 여기서 클래스란, 일종의 청사진 템플릿을 의미합니다. 이는 실제 Class 객체이거나 Function 객체일 수 있습니다. 이를 Module이나 Package로도 식별할 수 있습니다.\n\n논리 클래스 내에서 자체적인 작업 조각들은 각자의 메소드를 가져야 합니다. 메소드는 한 가지 일을 잘 처리해야 합니다. 비슷한 클래스는 동일한 메소드 이름을 사용해야 합니다.\n\n초보 프로그래머로서, 항상 새로운 클래스를 시작하는 직감을 가지지 못했고, 무엇이 독립적일 수 있는지 식별하는 데 실패하기도 했습니다. 만약 함께 속하지 않는 여러 요소들을 함께 모아 놓은 \"Util\" 클래스를 보게 된다면, 이는 초보자 코드의 징후입니다. 간단한 변경을 하고 나서 이 변경이 파급 효과를 일으켜 다른 곳에 많은 변경이 필요하다고 발견한다면, 이 역시 초보자 코드의 징후입니다.\n\n클래스에 메소드를 추가하거나 메소드에 더 많은 책임을 추가하기 전에, 여러분의 직감을 생각하고 의문을 제기해야 합니다. 시간이 필요합니다. 이를 건너뛰지 마시고, 나중에 리팩토링할 것이라고 생각하지 마세요. 처음부터 올바르게 해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n여기 중요한 아이디어는 코드가 높은 응집도와 낮은 결합도를 갖는 것이 좋다는 것입니다. 이는 관련된 코드를 함께 유지하고(한 클래스 안에) 서로 다른 클래스 간의 의존성을 줄이는 것을 의미하는 멋진 용어일 뿐입니다.\n\n## 8) 알 수 없는 부분을 위한 계획\n\n자신이 작성하고 있는 솔루션 이상으로 생각하는 것이 종종 유혹적일 수 있습니다. 코드를 작성할 때마다 다양한 상황이 머릿속에 떠오르게 됩니다. 이것은 엣지 케이스 테스트에 좋은 것이지만 잠재적인 요구 사항으로 사용하는 것은 바람직하지 않습니다.\n\n이러한 '만약' 상황들이 어느 주요 범주에 속하는지 식별해야 합니다. 오늘 필요 없는 코드는 작성하지 마십시오. 미래를 위한 계획을 세우지 마십시오.\n\n<div class=\"content-ad\"></div>\n\n미래에 필요할 것 같아서 기능을 작성하는 것은 그저 잘못된 방법이에요. 그러지 마세요.\n\n당신이 현재 구현 중인 해결책을 위해 필요한 최소한의 코드만 작성하세요. 예외 상황은 다루되 예외적인 기능은 추가하지 마세요.\n\n# 9) 올바른 데이터 구조를 사용하지 않기\n\n면접 준비를 할 때 초보 프로그래머들은 보통 알고리즘에 너무 많은 초점을 둡니다. 필요할 때 좋은 알고리즘을 식별하고 사용하는 것은 좋지만, 그것들을 암기하는 것이 당신의 프로그래밍 천재성에 기여하지는 않을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 언어에서 사용할 수 있는 다양한 데이터 구조의 강점과 약점을 외우는 것은 분명히 여러분을 더 좋은 개발자로 만들 것입니다.\n\n잘못된 데이터 구조를 사용하는 것은 '신입코드입니다'라고 크고 강하게 밝힌 대형 게시판 같은 것입니다.\n\n본 글은 데이터 구조에 대해 가르치려는 것이 아니지만 간단한 예를 몇 가지 언급하겠습니다:\n\n- 레코드 관리에 배열 대신 객체(맵)을 사용하는 것\n\n<div class=\"content-ad\"></div>\n\n가장 흔한 데이터 구조 오류는 레코드 목록을 관리할 때 리스트 대신 맵을 사용하는 것입니다. 네, 레코드 목록을 관리할 때는 맵을 사용해야 합니다.\n\n각 레코드에 식별자가 있고 이를 사용하여 해당 레코드를 찾는 경우에 대해 이야기하는 것이며 스칼라 값에 대한 목록을 사용하는 것은 괜찮으며 주로 값을 목록에 \"추가\"하는 것이 중점이라면 더 나은 선택입니다.\n\nJavaScript에서 가장 일반적인 목록 구조는 배열이며 가장 일반적인 맵 구조는 객체입니다(현대 JavaScript에는 맵 구조도 있습니다).\n\n레코드를 관리하기 위해 리스트 대신 맵을 사용하는 것은 종종 잘못된 방법입니다. 이 점은 주로 큰 컬렉션에 대한 이야기이지만, 저는 그냥 항상 이를 준수하는 것이 좋다고 말할 것입니다. 이것이 중요한 이유는 식별자를 사용하여 레코드를 조회할 때 맵이 리스트보다 훨씬 빠르기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n— 스택을 사용하지 않음\n\n재귀 형태의 코드를 작성할 때는 항상 간단한 재귀 함수를 사용하고 싶은 유혹이 있습니다. 그러나 특히 단일 스레드 환경에서 재귀 코드를 최적화하는 것은 어렵습니다.\n\n재귀 코드를 최적화하는 것은 재귀 함수가 무엇을 반환하는지에 따라 달라집니다. 예를 들어, 자신을 두 번 이상 호출하는 재귀 함수를 최적화하는 것은 자신을 한 번 호출하는 재귀 함수를 최적화하는 것보다 훨씬 어렵습니다.\n\n초보자로서 우리가 종종 간과하는 것은 재귀 함수를 사용하는 대안이 있다는 점입니다. 단순히 Stack 구조를 사용할 수 있습니다. Stack에 함수 호출을 직접 넣고, 호출을 되돌아가야 할 준비가 되면 이를 꺼내기 시작하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 10) 기존 코드를 더 나빠지게 만들기\n\n다음과 같이 엉망진창인 방을 받았다고 상상해보세요:\n\n![방 이미지](/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_1.png)\n\n그리고 그 방에 물건을 하나 추가해야 한다고 요청받았다고 상상해보세요. 이미 방이 큰 난잡한 상태이기 때문에 물건을 어디든 넣을 수 있을 것입니다. 몇 초만에 작업을 끝낼 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n지저분한 코드로 그렇게 하지 마십시오. 더 안 좋아지도록 만들지 마세요! 언제나 코드가 좀 더 깨끗하게 유지되도록 해야 합니다.\n\n위 방에 대한 올바른 작업은 새 항목을 올바른 위치에 배치하기 위해 필요한 것을 청소하는 것입니다. 예를 들어, 옷장에 넣어야 하는 의류라면 해당 옷장으로 가는 길을 비워야 합니다. 이것이 작업을 올바르게 수행하는 일의 일부입니다.\n\n일반적으로 코드를 더 복잡하게 만드는 몇 가지 잘못된 실천 방식(완전한 목록은 아님)은 다음과 같습니다:\n\n- 코드 복제. 코드 일부를 복사하여 그 뒤에 한 줄을 변경하면 코드를 복제하고 더 큰 혼란을 초래합니다. 방금 언급한 지저분한 방 예제의 맥락에서, 이것은 가변 높이의 새 의자에 투자하는 대신 더 낮은 베이스의 다른 의자를 소개하는 것과 같습니다. 언제나 추상화 개념을 기억하고 가능할 때 사용해야 합니다.\n- 구성 파일을 사용하지 않음. 다른 환경이나 다른 시기에 달라질 수 있는 값을 사용해야 한다면 해당 값은 구성 파일에 속합니다. 코드의 여러 위치에서 사용해야 하는 값이라면 해당 값은 구성 파일에 속합니다. 새 값이 코드에 도입될 때 이 질문을 항상 스스로에게 물어보십시오: 이 값은 구성 파일에 속하는가? 대답은 아마도 예일 것입니다.\n- 불필요한 조건문 및 임시 변수 사용. 매 if문은 최소 두 번 테스트해야 하는 논리 분기입니다. 가독성을 희생하지 않고 조건문을 피할 수 있는 경우 피해야 합니다. 이에 대한 주요 문제는 다른 함수를 도입하는 대신 함수에 분기 논리를 확장하는 것입니다. if문이나 새 함수 변수가 필요하다고 생각할 때마다 스스로에게 이 질문을 던져보십시오: 코드를 올바른 수준에서 수정하고 있는 것인가, 아니면 문제를 보다 높은 수준에서 생각해야 하는 것인가?\n\n<div class=\"content-ad\"></div>\n\n불필요한 if문에 대해 얘기해보겠습니다. 다음 코드를 살펴보세요:\n\n```js\nfunction isOdd(number) {\n  if (number % 2 === 1) {\n    return true;\n  } else {\n    return false;\n  }\n}\n```\n\n위의 isOdd 함수에는 몇 가지 문제가 있지만 가장 눈에 띄는 문제를 알 수 있나요?\n\n이 함수는 불필요한 if문을 사용하고 있습니다. 다음은 동등한 코드입니다:\n\n<div class=\"content-ad\"></div>\n\n```jsx\nfunction isOdd(number) {\n  return (number % 2 === 1);\n};\n```\n\n# 11) 당연한 것에 대한 코멘트 작성하기\n\n내가 경험적으로 알게 된 것은 가능한한 코멘트를 쓰지 않는 것이 좋다는 것이다. 대부분의 코멘트들은 코드 안에 더 명확한 이름으로 대체될 수 있다.\n\n예를 들어, 다음 코드 대신에:\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이 함수는 배열에서 홀수만 더합니다\nconst sum = (val) => {\n  return val.reduce((a, b) => {\n    if (b % 2 === 1) { // 현재 숫자가 홀수인 경우\n      a+=b;            // 현재 숫자를 누산기에 더합니다\n    }\n    return a;          // 누산기를 반환합니다\n  }, 0);\n};\r\n```\n\n같은 코드를 다음과 같이 주석 없이 작성할 수도 있습니다:\n\n```js\r\nconst sumOddValues = (array) => {\n  return array.reduce((accumulator, currentNumber) => {\n    if (isOdd(currentNumber)) { \n      return accumulator + currentNumber;\n    }\n    return accumulator;\n  }, 0);\n};\r\n```\n\n함수와 인수에 더 나은 이름을 사용하면 대부분의 주석이 필요 없어집니다. 주석을 작성하기 전에 이 사실을 염두에 두세요.\n\n<div class=\"content-ad\"></div>\n\n그러나 때로는 코드에 명확성을 더할 수 있는 유일한 방법이 주석을 통한 설명일 때가 있습니다. 이때는 이 코드 대신 이 코드를 왜 사용했는지에 대한 질문에 대답할 수 있도록 주석을 작성해야 합니다.\n\n코드를 명확히 설명하기 위해 '무엇을 하는지'가 아닌 '왜 이 코드를 사용했는지'에 대한 질문에 대답하기 위해 주석을 작성해야 합니다. 코드를 명확히 설명하려는 유혹이 강하다면 당연한 것을 가리키지 않도록 주의하세요. 아래에 코드에 소음만 추가하는 쓸데없는 주석 예시가 있습니다:\n\n```js\n// 변수를 만들고 0으로 초기화합니다\nlet sum = 0;\n// 배열을 루프합니다\narray.forEach(\n  // 배열의 각 숫자에 대해\n  (number) => {\n    // 현재 숫자를 합계 변수에 더합니다\n    sum += number;\n  }\n);\n```\n\n그런 프로그래머가 되지 마세요. 그러한 코드를 받아들이지 마세요. 이와 같은 주석을 다루어야 할 때 이런 주석을 제거하세요. 가장 중요한 것은 이런 주석을 쓰는 프로그래머들에게 그것이 얼마나 나쁜지 깨달게 하는 것입니다. 위와 같은 주석을 쓰는 프로그래머를 고용하고 있다면 이 문제가 실제로 그들이 일자리를 잃을 수 있음을 알려주세요. 그래, 그 정도로 심각합니다.\n\n<div class=\"content-ad\"></div>\n\n# 12) 테스트 코드 작성하지 않기\n\n이 포인트를 간단하게 유지하려고 합니다. 만약 당신이 전문 프로그래머라고 생각하고 그 생각으로 인해 테스트를 하지 않고 코드를 작성하는 것에 자신감이 생긴다면, 그것은 내 기준에서는 초보자 입니다.\n\n코드에 테스트를 작성하지 않는다면, 아마도 다른 방법으로 프로그램을 수동으로 테스트하고 있을 것입니다. 웹 애플리케이션을 개발 중이라면, 코드 몇 줄마다 애플리케이션을 새로고침하거나 상호 작용할 것입니다. 저도 그렇게 합니다. 코드를 수동으로 테스트하는 것에는 문제가 없습니다. 그러나 코드를 수동으로 테스트하여 어떻게 자동으로 테스트할지 알아내야 합니다. 애플리케이션과 상호 작용을 성공적으로 테스트했다면, 더 많은 코드를 프로젝트에 추가할 때 동일한 상호 작용을 자동으로 수행할 수 있도록 코드를 작성하라.\n\n당신은 사람입니다. 각 코드 변경 후 모든 이전에 성공했던 유효성 검사를 테스트하는 것을 잊을 것입니다. 컴퓨터에게 그 일을 맡기세요!\n\n<div class=\"content-ad\"></div>\n\n가능하다면 코드를 작성하여 이를 충족시키기 전에 유효성을 추측하거나 설계해 보는 것이 좋습니다. 테스트 주도 개발(TDD)은 그냥 화려한 날조가 아닙니다. 기능에 대해 생각하는 방식에 긍정적인 영향을 미치고 더 나은 설계를 고안하는 데 도움이 됩니다.\n\nTDD가 모두에게 적합한 것은 아니며 모든 프로젝트에 잘 작동하지 않지만, 가능하다면 (일부분이라도) 활용할 수 있다면 꼭 해보세요.\n\n# 13) 작동한다고 해서 옳다고 가정하기\n\nsumOddValues 기능을 구현하는 이 함수를 살펴보세요. 어떤 문제가 있나요?\n\n<div class=\"content-ad\"></div>\n\n```js\nconst sumOddValues = (array) => {\n  return array.reduce((accumulator, currentNumber) => {\n    if (currentNumber % 2 === 1) { \n      return accumulator + currentNumber;\n    }\n    return accumulator;\n  }, 0);\n};\n \n \nconsole.assert(\n  sumOddValues([1, 2, 3, 4, 5]) === 9\n);\n```\n\n단언이 통과되었습니다. 즐거운 코딩하세요! 뭔가 빠진 부분이 있어요. 몇가지 문제를 설명해 드릴게요:\n\n— 문제 #1: 빈 입력에 대한 처리가 없어요. 함수를 인자 없이 호출하면 어떻게 동작해야 할까요? 현재 상태에서는 해당 경우에 함수의 구현이 노출되는 오류가 발생합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nTypeError: 정의되지 않은 프로퍼티 'reduce'를 읽을 수 없습니다.\n```\n\n<img src=\"/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_2.png\" />\n\n일반적으로 이는 두 가지 주요 이유로 나쁜 코드의 t수입니다.\n\n- 함수를 사용하는 사용자는 구현 세부 정보를 알아서는 안 됩니다.\n- 사용자에게 도움이 되지 않는 오류입니다. 사용자의 경우 함수가 단순히 작동하지 않았음을 알게 되는 것입니다. 그러나 오류가 사용 문제에 대해 더 명확하게 설명되면, 함수를 잘못 사용했음을 알 수 있습니다. 예를 들어, 함수가 이렇게 사용자 정의 예외를 throw하도록 선택할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nTypeError: 빈 목록에 대해 함수를 실행할 수 없습니다.\n```\n\n에러를 발생시키는 대신, 빈 입력을 무시하고 0의 합계를 반환하도록 함수를 설계해야 할지도 모릅니다. 그래도 이 경우를 위해 뭔가를 해야 합니다.\n\n— 문제 #2: 잘못된 입력을 처리하는 방법이 없습니다. 배열이 아닌 문자열, 정수 또는 객체 값을 받았을 때 함수를 호출할 경우 어떻게 해야 할까요?\n\n이제 함수가 던지는 에러를 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nsumOddValues(42);\n타입 에러: 배열.reduce는 함수가 아닙니다\n```\n\n그건 안좋은 일이에요. 왜냐하면 배열.reduce는 분명히 함수인데 말이에요!\n\n함수의 인자를 array로 이름을 지었기 때문에, 함수를 호출할 때 넘겨주는 값(예를 들어 위 예시의 42)은 함수 내에서 array로 라벨링됩니다. 이 에러는 실질적으로 42.reduce가 함수가 아니라는 걸 의미하죠.\n\n혼란스럽다고 느껴지시나요? 아마 더 도움이 될만한 에러 메시지는 다음과 같았으면 좋겠네요:\n\n<div class=\"content-ad\"></div>\n\n```js\nTypeError: 42은(는) 배열이 아니야, 친구야.\n```\n\n문제 #1과 #2는 때때로 엣지 케이스라고 불리기도 합니다. 이들은 고려해야 할 일반적인 엣지 케이스들입니다. 하지만 생각해야 할 덜 명백한 엣지 케이스들도 보통 있습니다. 예를 들어 음수를 사용했을 때 어떻게 될까요?\n\n```js\nsumOddValues([1, 2, 3, 4, 5, -13]) // => 여전히 9\n```\n\n음수인 -13은 홀수입니다. 이 함수가 가져야 하는 동작인가요? 에러를 던져야 하나요? 음수를 합계에 포함해야 하나요? 아니면 현재와 같이 음수를 무시해야 하나요? 아니면 함수의 이름이 sumPositiveOddNumbers로 지어져야 하는지를 깨닫게 될지도 모릅니다.\n\n<div class=\"content-ad\"></div>\n\n이 문제에 대한 결정은 쉽습니다. 더 중요한 점은, 당신의 결정을 문서화하기 위해 테스트 케이스를 작성하지 않으면, 함수를 유지보수하는 사람들은 당신이 음수를 무시한 것이 고의적인 것인지 버그인지 알 수 없을 겁니다.\n\n— 문제 #3: 유효한 여러 경우에 대해 테스트하지 않았습니다. 경계 경우를 잊고, 이 함수는 다루지 못하는 합리적이고 매우 간단한 경우가 있습니다:\n\n```js\nsumOddValues([2, 1, 3, 4, 5]) // => 11\n```\n\n위에서 2가 합산됐지만 합산되지 말아야 하는 경우입니다.\n\n<div class=\"content-ad\"></div>\n\n해결책은 간단합니다. reduce 함수는 어큐뮈레이터의 초기값으로 사용될 두 번째 매개변수를 받습니다. 만약 해당 인수가 제공되지 않았다면(위의 코드처럼), reduce는 컬렉션의 첫 번째 값이 어큐뮈레이터의 초기값으로 사용됩니다. 이것이 테스트 케이스에서 위의 첫 번째 짝수 값이 합에 포함된 이유입니다.\n\n당신이 이 문제를 바로 발견했거나 코드가 작성된 시점에 눈치챘을지라도, 이 문제를 드러내는 이 테스트 케이스는 처음부터 여러분의 테스트에 포함되어야 했었습니다. 그리고 이 테스트와 함께, 전부 짝수인 숫자들, 0이 포함된 목록, 그리고 빈 목록과 같은 다른 많은 테스트 케이스들도 포함되어야 합니다.\n\n만약 여러분이 많은 경우를 다루지 않는 최소한의 테스트를 본다면 또는 경계 상황을 무시한다면, 그것은 초보자 코드의 또 다른 신호입니다.\n\n# 14) 기존 코드 의심하기\n\n<div class=\"content-ad\"></div>\n\n상당한 분량의 코드를 혼자서 작업하지 않는 한, 당신이 삶 속에서 어떤 종류의 바보 같은 코드와 마주칠 가능성은 의심할 여지가 없습니다. 초심자들은 그것을 인식하지 못하며, 그것이 작동하는 것처럼 보이고 오랜 시간 동안 코드베이스의 일부이기 때문에 좋은 코드라고 가정합니다.\n\n더 나쁜 점은 나쁜 코드가 바람직하지 못한 방법을 사용한다면 초심자는 그 바람직하지 못한 방법을 코드베이스 다른 곳에서 반복하기 쉽습니다. 왜냐면 그들은 그것이 좋은 코드로 생각해서 배웠기 때문입니다.\n\n어떤 코드는 나빠 보일 수 있지만, 그것 주변에 특별한 조건이 있어 개발자가 그렇게 작성할 수 밖에 없었을 수 있습니다. 초심자에게 그 조건에 대해 가르치고 코드의 작성 방식에 대해 설명하는 자세한 주석이 필요한 좋은 장소입니다.\n\n초심자로서 이해하지 못하는 문서화되지 않은 코드는 나쁜 것이 될 가능성이 있다고 가정해야 합니다. 의문을 가져 보세요. 그것에 대해 질문하세요. git blame을 사용해 보세요!\n\n<div class=\"content-ad\"></div>\n\n만약 그 코드의 작성자가 오래 전에 사라졌거나 기억하지 못한다면, 그 코드를 조사하고 이해하려고 노력하세요. 코드를 완전히 이해한 후에 그것이 좋은지 나쁜지에 대해 의견을 형성할 수 있습니다. 이 전에는 가정하지 마세요.\n\n# 15) 최적의 방법에 대해 집착하기\n\n\"최적의 방법\"이라는 용어는 실제로 해롭다고 생각합니다. 이것은 더 이상의 연구가 필요하지 않다는 것을 시사합니다. 이게 바로 최고의 방법입니다. 의문을 제기하지 마세요!\n\n최적의 방법은 없습니다. 오늘을 위한 좋은 방법이 있을 뿐이며, 이 프로그래밍 언어에 적합한 것이 있을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n프로그래밍에서 이전에 최선의 방법으로 인식되었던 것 중 일부는 오늘날 나쁜 방법으로 레이블이 지정됩니다. \n\n충분한 시간을 투자한다면 더 나은 방법을 항상 찾을 수 있습니다. 최상의 방법에 대해 걱정하지 말고 자신의 재능에 집중하세요.\n\n어딘가에서 읽은 인용구나 다른 사람이 그렇게 한 것을 보거나 누군가가 이것이 최선의 방법이라고 말한 대로 무언가를 하지 마세요. 이 글에서 제공하는 모든 조언도 이에 해당합니다! 모든 것을 의심하고 모든 이론에 도전하고 가능한 모든 옵션을 알아보고 교육된 결정을 내리세요.\n\n# 16) 성능에 대한 집착\n\n<div class=\"content-ad\"></div>\n\n프로그래밍은 도널드 누스가 위 문장을 쓴 이후에 상당히 변화했지만, 내 생각에는 지금도 유익한 조언으로 여겨집니다.\n\n이에 대해 기억해야 할 좋은 규칙은 다음과 같습니다: 코드로 의심되는 성능 문제를 측정할 수 없다면 최적화를 시도하지 말아야 합니다.\n\n코드를 실행하기 전에 최적화를 하려고 한다면, 아마 너무 이르게 최적화하고 있는 것일 수 있습니다. 또한 투자한 시간이 완전히 필요하지 않은 최적화에 사용되고 있는 가능성도 큽니다.\n\n물론 새 코드를 도입하기 전에 항상 고려해야 할 몇 가지 명백한 최적화가 있습니다. 예를 들어, Node.js에서 이벤트 루프를 즉시 차단하지 않거나 호출 스택을 차단하지 않는다는 것은 매우 중요합니다. 이것은 항상 염두에 두어야 할 초기 최적화의 한 예입니다. 자신에게 물어보세요: 고민 중인 코드가 호출 스택을 차단할까요?\n\n<div class=\"content-ad\"></div>\n\n기존 코드에 대한 어떠한 명확하지 않은 최적화도 측정 없이 진행된다면 해로울 수 있으며 피해야 합니다. 당신이 생각하는 최적화가 성능 향상으로 작용할 것이라고 생각되더라도 예상치 못한 새로운 버그의 원인이 될 수 있습니다.\n\n측정되지 않은 성능 문제에 대한 최적화에 시간을 낭비하지 마십시오.\n\n# 17) 최종 사용자 경험에 목표를 두지 않기\n\n어플리케이션에 기능을 추가하는 가장 쉬운 방법은 무엇인가요? 자신의 관점에서 살펴보거나 현재 사용자 인터페이스에 어떻게 맞추는지를 고려해보는 것입니다. 그렇죠? 만약 사용자로부터 일종의 입력을 받는 기능을 추가해야 한다면, 이미 있는 양식에 추가하세요. 만약 페이지에 링크를 추가해야 한다면, 이미 있는 중첩된 링크 메뉴에 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n그 개발자가 되지 마세요. 자신을 사용자의 입장에 놓아 생각해보세요. 특정 기능의 사용자가 필요로 하는 것과 그들이 어떻게 행동할지 상상해봅니다. 기능이 사용자들이 찾고 사용하기 쉽도록 만드는 방법을 고민하며, 그 기능이 어떻게 찾아지고 사용되는지에 대해 고민하지 않고 어떻게든 애플리케이션에 그 기능을 간단히 구현할 방법에만 집중하지 않습니다.\n\n# 18) 일에 적합한 올바른 도구를 고르지 않기\n\n모든 사람은 프로그래밍과 관련된 작업을 돕기 위해 사용하는 즐겨찾는 도구 목록을 갖고 있습니다. 일부 도구는 훌륭하고 일부는 나쁘지만 대부분의 도구는 한 가지 특정한 일에 탁월하며 다른 많은 작업에는 그리 탁월하지 않습니다.\n\n망치는 벽에 못을 박는 데 탁월한 도구이지만 나사를 조이는 데는 최악의 도구입니다. \"망치를 좋아한다\"는 이유로 나사에 망치를 사용하지 마세요. \"아마존에서 5.0 사용자 평가를 받은 가장 인기 있는 망치\"라는 이유로 나사에 망치를 사용하지 마세요.\n\n<div class=\"content-ad\"></div>\n\n도구의 인기에 의존하는 것보다 문제에 얼마나 잘 맞는지가 더 중요하다는 건 진정한 초보자의 특징입니다.\n\n이러한 점에 대한 문제 중 하나는 특정 작업에 \"더 나은\" 도구를 아마 알지 못할 것이라는 것입니다. 현재 지식 내에서 특정 도구가 알려진 최고의 도구일 수 있습니다. 그러나 다른 옵션들과 비교했을 때 상위 목록에 들지 않을 수도 있습니다. 사용 가능한 도구에 익숙해지고 새로운 도구에 대해 열린 마음을 유지해야 합니다.\n\n일부 코더는 새로운 도구를 사용하기를 거부합니다. 그들은 기존 도구에 익숙하고 아마도 새로운 것을 배우고 싶어하지 않을 것입니다. 그 점을 이해하고 공감할 수 있지만, 단순히 잘못된 것입니다.\n\n원시 도구로 집을 짓고 맘편히 시간을 들일 수도 있지만, 좋은 도구에 시간과 돈을 투자하고 훨씬 빠르게 더 나은 집을 짓을 수도 있습니다. 도구는 계속 발전하고 있으며, 그에 대해 배우고 사용하는 데 편안해지는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 19) 코드 문제를 이해하지 못하면 데이터 문제가 발생할 수 있습니다\n\n프로그램의 중요한 측면 중 하나는 종종 어떤 형태의 데이터를 관리하는 것입니다. 프로그램은 새로운 레코드를 추가하고 이전 레코드를 삭제하며 다른 레코드를 수정하는 인터페이스가 될 것입니다.\n\n프로그램의 코드에 있는 가장 작은 버그도 관리하는 데이터에 대한 예측할 수 없는 상태로 이어질 것입니다. 특히 데이터에 대한 모든 유효성 검사가 동일한 버그가 있는 프로그램을 통해 수행된다면 더욱 그러합니다.\n\n초보자들은 코드-데이터 관계에 대한 연결을 즉시 이해하지 못할 수 있습니다. 중요하지 않은 기능 X가 작동하지 않아도 좋다고 느낄 수 있습니다. 문제는 버그 있는 코드가 초기에는 명확하지 않은 데이터 무결성 문제를 계속 도입할 수 있다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n더 나쁜 것은 버그를 수정하는 코드를 배송할 때, 이 버그로 인해 발생한 미묘한 데이터 문제를 해결하지 않으면 \"회복 불가능 수준\"으로 갈수록 데이터 문제가 더 쌓일 것입니다.\n\n이런 문제에서 자신을 보호하는 방법은 무엇일까요? 여러 계층의 데이터 무결성 유효성 검사를 간단히 사용할 수 있습니다. 단일 사용자 인터페이스에 의존하지 마세요. 프론트엔드, 백엔드, 네트워크 통신 및 데이터베이스에 대해 유효성을 생성하세요. 이것이 선택 사항이 아니라면, 적어도 데이터베이스 수준의 제약을 사용해야 합니다.\n\n데이터베이스 제약을 숙지하고 데이터베이스에 열과 테이블을 추가할 때 모두 사용하세요:\n\n- 열의 NOT NULL 제약은 해당 열에 대해 NULL 값이 거부됨을 의미합니다. 애플리케이션이 해당 필드에 대한 값의 존재를 가정한다면, 데이터베이스에서 Source를 Not Null로 정의해야 합니다.\n- 열의 UNIQUE 제약은 해당 열이 전체 테이블 전체에서 중복 값을 가질 수 없음을 의미합니다. 예를 들어, 사용자 테이블의 사용자 이름이나 이메일 필드에 좋습니다.\n- CHECK 제약은 데이터가 수락되려면 true로 평가되어야 하는 사용자 정의 식입니다. 예를 들어, 값이 0과 100 사이여야 하는 보통 백분율 열이 있는 경우, 체크 제약을 사용하여 강제할 수 있습니다.\n- PRIMARY KEY 제약은 열의 값이 Not-Null이며 고유해야 함을 의미합니다. 아마 이것을 사용하고 있을 것입니다. 데이터베이스의 각 테이블은 레코드를 식별하기 위한 기본 키를 가져야합니다.\n- FOREIGN KEY 제약은 열의 값이 일반적으로 기본 키인 다른 테이블 열의 값과 일치해야 함을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n데이터 무결성과 관련된 또 다른 초보자 문제는 트랜잭션 관점에서 생각하지 않는 부분입니다. 여러 작업이 동일한 데이터 원본을 변경해야 하고 서로에게 의존하는 경우, 이러한 작업은 반드시 롤백할 수 있는 트랜잭션으로 묶여야 합니다. 그렇게 해야 한 작업이 실패할 경우 롤백할 수 있습니다.\n\n# 20) 바퀴를 다시 발명하기\n\n이것은 tricky 한 포인트입니다. 프로그래밍에서 일부 바퀴는 단순히 다시 발명할 가치가 있습니다. 프로그래밍은 명확하게 정의된 도메인이 아닙니다. 너무 많은 변화가 너무 빨리 일어나고 새로운 요구사항이 어떤 팀도 처리할 수 있는 것보다 더 빨리 도입됩니다.\n\n예를 들어, 하루 시간에 따라 다른 속도로 회전하는 바퀴가 필요한 경우, 우리가 알고 사랑하는 바퀴를 맞춤화하는 대신, 다시 생각할 필요가 있을 수 있습니다. 그러나 전혀 다른 디자인으로 사용되지 않는 바퀴가 필요하지 않다면, 바퀴를 다시 발명하지 마세요. 그냥 그 바퀴를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n가끔 필요한 휠의 브랜드를 선택하는 것은 다양한 옵션이 있어 쉬운 일이 아닙니다. 사전 조사를 하고 살기 전에 시도해보세요! 소프트웨어 \"휠\"의 멋진 점은 대부분의 것들이 무료이며 내부 디자인을 볼 수 있습니다. 내부 디자인 품질에 따라 코딩 휠을 쉽게 판단할 수 있습니다. 가능하다면 오픈 소스 휠을 사용하세요. 오픈 소스 패키지는 쉽게 디버그하고 수정할 수 있습니다. 또한 쉽게 대체할 수도 있습니다. 또한 내부에서 용이하게 지원하기도 쉽습니다. \n\n하지만, 휠이 필요한 경우, 전체 새 차를 사서 유지 중인 차를 위에 올리지 마세요. 라이브러리 전체를 가져올 필요가 없는 경우에도 함수 두 개를 사용하려고 전체 라이브러리를 포함하지 마세요. 이와 관련된 좋은 예는 JavaScript의 lodash 라이브러리입니다. 배열을 섞기만 하려면 섞기 메소드만 가져와 사용하세요. 전체 lodash 라이브러리를 가져오지 마세요.\n\n# 21) 코드 리뷰에 대한 부정적인 태도 가지기\n\n코딩 초보자들의 한 가지 특징은 코드 리뷰를 비판으로만 바라본다는 것입니다. 코드 리뷰를 싫어합니다. 감사하지도 않습니다. 때로는 두렵기까지 합니다.\n\n<div class=\"content-ad\"></div>\n\n이건 완전히 잘못됐어요. 만약 그렇게 느낀다면, 당신도 이 태도를 곧바로 바꿔야 해요. 모든 코드 리뷰를 학습 기회로 여기세요. 환영하고 감사드리세요. 거기서 배우세요. 그리고 가장 중요한 건, 누군가가 당신에게 무언가 가르칠 때 그들에게 고맙다고 말해주세요.\n\n당신은 영원한 코드 학습자에요. 그 사실을 받아들여야 해요. 대부분의 코드 리뷰는 당신이 몰랐던 것을 가르쳐 줄 거에요. 그걸 학습 자원으로 분류하세요.\n\n가끔 리뷰어가 틀릴 때가 있고, 그때는 당신이 그들에게 뭔가를 가르쳐 줘야 할 차례일 거에요. 그러나 만약 코드만으로는 명백하지 않은 무언가를 가르쳐 줘야 한다면, 아마도 당신의 코드를 수정해야 할지도 모릅니다. 그리고 어쨌든 리뷰어에게 뭔가를 가르쳐 줘야 한다면, 그것이 바로 프로그래머로서 할 수 있는 가장 보람 있는 활동 중 하나인 것을 알아두세요.\n\n# 22) 소스 컨트롤 사용하지 않기\n\n<div class=\"content-ad\"></div>\n\n신입들은 때때로 좋은 소스/변경 관리 시스템이 갖는 힘을 과소평가합니다. 여기서 말하는 '좋은 시스템'은 Git을 의미합니다.\n\n소스 관리는 다른 사람들이 공유하고 발전시키기 위해 변경 사항을 푸시하는 것에 그치는 것이 아닙니다. 그것보다 훨씬 큰 의미가 있습니다. 소스 관리는 명확한 히스토리에 관한 것입니다. 코드는 의심 받을 수 있고 해당 코드의 진전 기록은 어려운 질문 중 일부에 대한 답을 찾을 수 있도록 도와줍니다. 그래서 우리는 커밋 메시지에 중요성을 둡니다. 이것은 당신의 구현을 전달할 또 다른 수단이며, 작은 커밋으로 사용하면 코드의 미래 유지보수자가 코드가 현재 상태에 도달한 과정을 이해하는 데 도움이 됩니다.\n\n자주 커밋하고 일찍 커밋하고, 일관성을 위해 커밋 제목에 현재형 동사를 사용해주세요. 메시지는 자세하게 작성해주시되, 요약 정보여야 합니다. 메시지가 몇 줄을 넘어가면, 그 커밋이 너무 길다는 신호일 수 있습니다. 리베이스를 사용하세요!\n\n커밋 메시지에 불필요한 정보를 포함하지 마세요. 예를 들어, 추가된, 수정된, 삭제된 파일들을 커밋 요약에 나열하지 마세요. 해당 목록은 커밋 객체 자체에 존재하며 몇 가지 Git 명령 인자를 사용하여 쉽게 표시할 수 있습니다. 요약 메시지에는 단순히 노이즈가 될 뿐입니다. 어떤 팀들은 각 파일 변경 별로 다른 요약을 가지는 것을 선호하지만, 그것은 커밋이 너무 크다는 또 다른 신호로 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n소스 제어는 발견 가능성과 관련이 있어요. 함수를 만나게 되면 그 함수에 대해 필요성이나 설계를 의심하기 시작할 수도 있는데, 소스 제어를 통해 해당 함수를 도입한 커밋을 찾아 해당 함수의 문맥을 확인할 수 있어요. 커밋은 프로그램에 버그를 도입한 코드를 식별하는 데도 도움이 되죠. Git은 심지어 커밋 내에서 이진 탐색(바이섹트 명령)을 제공하여 버그를 도입한 유일한 지시 커밋을 찾을 수도 있어요.\n\n소스 제어는 변경이 공식적인 커밋이 되기 전에도 멋진 방식으로 활용할 수 있어요. 변경 사항 스테이징, 선택적 패칭, 초기화, 숨김, 수정, 적용, 다이피, 반전 등과 같은 기능을 사용하면 코딩 플로에 다양한 도구를 추가할 수 있어요. 이 도구들을 이해하고 배우고 사용하여 그 가치를 인정해 주세요.\n\nGit을 잘 알고 있는 기능이 적을수록 제 책에서는 초보자라고 생각해요.\n\n# 23) 공유 상태 남발하기\n\n<div class=\"content-ad\"></div>\n\n다시 말하지만, 함수형 프로그래밍 대비 다른 패러다임에 대한 이야기는 아닙니다. 이것은 다른 기사를 위한 주제입니다.\n\n공유 상태는 문제의 원인이 되므로 가능하면 피해야 합니다. 그렇지 않은 경우에는 공유 상태의 사용을 절대 최소화해야 합니다.\n\n초보 프로그래머로서 깨달지 못한 것은 우리가 정의하는 모든 변수가 공유 상태를 나타낸다는 것입니다. 해당 변수의 범위와 동일한 범위 내의 모든 요소에 의해 변경될 수 있는 데이터를 보유합니다. 범위가 더 길면 이 공유 상태의 영향이 심각해질 수 있습니다. 새로운 상태를 작은 범위에 포함시키고 상위로 누출되지 않도록 유의하세요.\n\n공유 상태의 주요 문제는 여러 자원이 이벤트 루프의 동일한 틱에서 함께 상태를 변경해야 할 때 발생합니다 (이벤트 루프 기반 환경에서). 경쟁 상태가 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n여기 주제가 있어요: 초심자는 데이터 락 문제를 다룰 때, 특히 공유 상태 경쟁 조건 문제로 인해 타이머를 해결책으로 사용하려 할 수 있어요. 그렇게 하면 큰 경고 신호에요. 하지 마세요. 이를 주시하고, 코드 리뷰에서 지적하고, 절대 받아들이지 마세요.\n\n# 24) 오류에 대한 잘못된 태도\n\n오류는 좋은 것이에요. 당신이 진전을 만들고 있다는 것을 의미해요. 더 나은 진전을 이루기 위한 쉬운 후속 변경을 의미해요.\n\n전문 프로그래머는 오류를 좋아해해요. 초심자는 싫어해요.\n\n<div class=\"content-ad\"></div>\n\n만약 이 멋진 작은 빨간 에러 메시지를 보는 것이 괴롭다면, 태도를 바꾸어야 합니다. 이들을 도우미로 생각해야 합니다. 그들과 대응해야 합니다. 진행을 이끌기 위해 그들을 활용해야 합니다.\n\n어떤 오류는 예외로 업그레이드해야 합니다. 예외는 사용자 정의 오류로, 대비해야 하는 오류입니다. 어떤 오류는 그냥 내버려 둬야 합니다. 애플리케이션을 중단하고 종료하도록 해야 합니다.\n\n# 25) 휴식을 취하지 않기\n\n당신은 인간이고 당신의 뇌에는 휴식이 필요합니다. 당신의 몸에도 휴식이 필요합니다. 종종 자리에 묶여 휴식을 잊게 될 것입니다. 나는 이것을 초보자의 또 다른 신호로 보고 있습니다. 이것은 타협할 수 없는 것입니다. 작업 흐름에 휴식의 강제 요소를 통합하여 휴식을 취하도록 하세요. 짧은 휴식을 자주 취하세요. 의자를 떠나 짧게 산책을 하며 다음에 해야 할 일을 생각하도록 하세요. 신선한 눈으로 코드를 다시 보세요.\n\n<div class=\"content-ad\"></div>\n\n이 긴 글을 읽느라 수고 많으셨어요.\n\n![이미지](/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_3.png)","ogImage":{"url":"/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_0.png"},"coverImage":"/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_0.png","tag":["Tech"],"readingTime":24}],"page":"3","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}