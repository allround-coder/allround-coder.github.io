{"pageProps":{"posts":[{"title":"실시간 성능 최적화 WebSockets와 Reactjs 통합하는 방법 Part I","description":"","date":"2024-06-22 03:04","slug":"2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI","content":"\n\n<img src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png\" />\n\n요즘에는 많은 양의 데이터가 있는데, 그것을 빨리 얻고 모든 것이 잘 작동하는 것이 정말 중요해요. 하지만 때로는 예전 방식(HTTP 요청)을 사용해서 계속해서 데이터를 요청하는 것은 오늘날 앱에는 충분히 빠르지 않을 수도 있어요. 그런 상황에서 WebSockets가 등장해요. WebSockets는 거의 즉시 업데이트를 보낼 수 있어 마치 마법 같은 기술이에요. 이를 통해 최신 정보를 곧바로 받아볼 수 있어요.\n\n그리고 React와 함께 사용한다면, 실시간으로 정보를 얻는 새로운 방식이 열립니다. React는 정말 빠른데, 너무 많은 것을 변경하면 신중하지 않으면, 앱이 느려지거나 작동을 멈출 수도 있어요. 그래서 React에서 일어나는 변경 사항을 신중하게 다루는 것은 중요해요, 특히 WebSockets를 사용할 때는요.\n\n우선, 이를 최적화하지 않은 방법에 대해 먼저 이야기해볼게요. 나중에는 React와 WebSockets를 사용하는 최적화된 방법에 대해 더 깊이 탐구해볼 거에요. 기대해주세요, 우리는 응용 프로그램의 성능과 효율성을 극대화하기 위한 WebSockets를 활용하는 최상의 방법에 대해 탐구할 거예요.\n\n<div class=\"content-ad\"></div>\n\n# 먼저 WebSocket이란 무엇인가요? 웹소켓 이해하기\n\n웹소켓은 단일, 오래 지속되는 연결을 통해 전이편된 통신 채널을 제공합니다. 이를 통해 클라이언트(브라우저)와 서버 간 실시간 데이터 교환이 가능해집니다. 전통적인 HTTP 요청과는 달리 웹소켓은 클라이언트와 서버가 모두 통신을 시작할 수 있어 즉각적인 업데이트가 필요한 응용 프로그램에 이상적입니다.\n\n실시간 데이터 스트리밍의 장점\n\n- 효율성 향상: 웹소켓을 통해 데이터 업데이트가 원활해집니다. 한 번 연결되면 데이터가 지연 없이 흘러가며 지속적인 요청 시간을 제거합니다.\n- 즉각적인 업데이트: 웹소켓을 통해 즉각적으로 업데이트를 받을 수 있습니다. 시장 동향이나 암호화폐 가격 추이를 추적하는 경우에도 신속한 결정을 위해 항상 최신 정보를 얻을 수 있습니다.\n- 양방향 대화: 웹소켓을 이용하면 서버와 클라이언트가 즉각적으로 양방향 대화를 할 수 있습니다. 모두가 듣고 듣는 빠른 대화와 같아서 팀워크가 쉬워집니다.\n- 확장성: 데이터 요구가 증가함에 따라 웹소켓은 부하를 다룰 수 있습니다. 연결을 열어두기 때문에 많은 사용자가 있더라도 원활하게 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_1.png\" />\n\n# React에서 WebSockets 사용하기\n\n이제, 웹소켓의 강점을 React 애플리케이션으로 가져올 수 있는 \"react-use-websocket\"이라는 유용한 도구에 대해 이야기해보겠습니다. 이 라이브러리는 웹소켓을 React 컴포넌트에 통합하는 과정을 단순화하여 심지어 초보자들도 사용할 수 있게 해줍니다.\n\n\"react-use-websocket\"을 사용하면 WebSocket 연결을 쉽게 설정할 수 있고, 메시지를 보내고 받을 수 있으며, 연결 오류를 처리할 수 있습니다 - 모두 React 컴포넌트 내에서 가능합니다. 시작하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 설치: 라이브러리를 설치하려면 npm 또는 yarn을 사용하여 다음과 같이 시작하세요:\n\n```js\nnpm install react-use-websocket\n```\n\n또는\n\n```js\nyarn add react-use-websocket\n```\n\n<div class=\"content-ad\"></div>\n\n2. 사용 방법: 설치한 후에는 React 컴포넌트에서 useWebSocket 훅을 가져와 사용할 수 있습니다. 아래는 기본 예제입니다:\n\n```js\nimport React from 'react';\nimport { useWebSocket } from 'react-use-websocket';\n\nconst MyComponent = () => {\n  const { sendMessage, lastMessage } = useWebSocket('wss://example.com/ws');\n\n  const handleClick = () => {\n    sendMessage('Hello, WebSocket!');\n  };\n\n  return (\n    <div>\n      <button onClick={handleClick}>메시지 보내기</button>\n      <p>최근 메시지: {lastMessage ? lastMessage.data : '없음'}</p>\n    </div>\n  );\n};\n\nexport default MyComponent;\n```\n\n이 예제에서는 'wss://example.com/ws'로 WebSocket 연결을 설정하기 위해 useWebSocket 훅을 사용하고 있습니다. sendMessage 함수를 사용하여 메시지를 보내고, lastMessage 객체를 사용하여 최근 받은 메시지를 표시합니다.\n\n3. 이벤트 처리: \"react-use-websocket\"은 onOpen, onMessage, onError, onClose와 같은 다양한 WebSocket 이벤트를 처리하는 훅을 제공합니다. 이러한 훅을 사용하여 UI를 업데이트하거나 오류를 기록하는 등 다양한 WebSocket 이벤트에 기반한 작업을 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { sendMessage, lastMessage, readyState } = useWebSocket('wss://example.com/ws', {\n   onOpen: () => console.log('WebSocket connection opened!'),\n   onClose: () => console.log('WebSocket connection closed!'),\n   onError: (event) => console.error('WebSocket error:', event),\n   onMessage: (event) => console.log('Received message:', event.data),\n});\n```\n\n“리액트-유즈-웹소켓”을 사용하면 React 애플리케이션에 WebSocket을 쉽고 직관적으로 통합할 수 있습니다. 실시간 채팅 애플리케이션, 실시간 데이터 대시보드 또는 협업 도구를 구축하든, \"리액트-유즈-웹소켓\"을 사용하면 익숙한 React 환경에서 WebSocket의 강력함을 활용할 수 있습니다.\n\n# 좀 더 전체적인 예시를 살펴보겠습니다.\n\n이를 위해 cryptocompare와 같은 외부 웹소켓을 사용할 것인데, 그를 위해 무료 API 키를 생성하기 위해 계정을 생성해야 합니다. 자세한 지침은 여기를 참고하세요.\n\n<div class=\"content-ad\"></div>\n\nAPI 키를 받은 후 다음 패키지를 추가하겠습니다:\n\n```js\nnpm i react-use-websocket bootstrap react-bootstrap react-router-dom --save \n```\n\n또는\n\n```js\nyarn add react-use-websocket bootstrap react-bootstrap react-router-dom\n```\n\n<div class=\"content-ad\"></div>\n\n부트스트랩 패키지는 스타일링을 위한 것입니다.\n\n설치가 완료되면 Home.tsx 컴포넌트를 생성하겠습니다. 이 컴포넌트에는 입력 텍스트만 포함되어 있고 api 키를 제출하여 http://localhost:3000/dashboard로 리디렉션하고 api_key를 쿼리 매개변수로 추가할 것입니다.\n\n```js\nimport { useState } from \"react\";\nimport Modal from \"react-bootstrap/Modal\";\nimport Button from \"react-bootstrap/Button\";\nimport Form from \"react-bootstrap/Form\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Home = () => {\n  const [show, setShow] = useState(true);\n  const [apiKey, setApiKey] = useState(\"\");\n  const navigate = useNavigate();\n\n  const handleClose = () => setShow(false);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setApiKey(e.target.value);\n  };\n\n  const handleSubmit = (e: React.SyntheticEvent) => {\n    e.preventDefault();\n    navigate(`/dashboard?api_key=${apiKey}`);\n  };\n  return (\n    <>\n      <Modal\n        show={show}\n        onHide={handleClose}\n        data-bs-theme=\"dark\"\n        style={{ color: \"white\" }}\n      >\n        <Modal.Header closeButton>\n          <Modal.Title>react use websocket</Modal.Title>\n        </Modal.Header>\n        <Modal.Body>\n          <Form onSubmit={handleSubmit}>\n            <Form.Group controlId=\"formBasicEmail\">\n              <Form.Label>Api key:</Form.Label>\n              <Form.Control\n                type=\"text\"\n                placeholder=\"Please provide api key\"\n                value={apiKey}\n                onChange={handleChange}\n              />\n            </Form.Group>\n          </Form>\n        </Modal.Body>\n        <Modal.Footer>\n          <Button variant=\"primary\" onClick={handleSubmit}>\n            Submit\n          </Button>\n        </Modal.Footer>\n      </Modal>\n    </>\n  );\n};\n\nexport default Home;\n```\n\nDashboard.tsx 컴포넌트에는 웹소켓 응답 객체를 위한 인터페이스를 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n위의 코드를 한글로 번역하면 다음과 같습니다:\n\n```js\nexport interface CryptoMessage {\n  TYPE: string;\n  M: string;\n  FSYM: string;\n  TSYM: string;\n  F: string;\n  ID?: string;\n  TS?: string;\n  Q?: number;\n  P?: number;\n  TOTAL?: number;\n  RTS?: string;\n  CCSEQ?: number;\n  TSNS?: number;\n  RTSNS?: number;\n}\n```\n\n그리고 useWebSocket 훅을 호출하세요.\n\n```js\nconst { readyState, sendJsonMessage, lastJsonMessage } =\n    useWebSocket<CryptoMessage>(socketUrl, { share: true });\n```\n\n이제 readyState, sendJsonMessage, lastJsonMessage가 무엇인지 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\nReadyState:\n\n\"useWebSocket\" 훅에서 제공하는 readyState 속성은 현재 WebSocket 연결 상태를 나타냅니다. WebSocket 연결이 보류 중인지, 열린 상태인지, 닫히는 중인지 또는 닫힌 상태인지를 나타냅니다. readyState 속성은 다음 네 가지 값 중 하나를 가질 수 있는 정수 값입니다:\n\n- CONNECTING (0): 이 상태는 WebSocket 연결이 설정 중인 상태를 나타냅니다. useWebSocket 훅을 초기 호출하고 WebSocket 연결을 시작할 때 연결이 성공적으로 설정될 때까지 CONNECTING 상태로 진입합니다.\n- OPEN (1): 이 상태는 WebSocket 연결이 열려 있고 메시지를 보내고 받을 준비가 된 상태를 나타냅니다. 연결이 성공적으로 설정되면 OPEN 상태로 전환되어 클라이언트와 서버 간에 양방향 통신이 가능해집니다.\n- CLOSING (2): 이 상태는 WebSocket 연결이 닫히는 중인 상태를 나타냅니다. useWebSocket 훅에서 제공하는 closeWebSocket 함수를 사용하여 WebSocket 연결을 종료하면 닫히기 전에 CLOSING 상태로 진입합니다.\n- CLOSED (3): 이 상태는 WebSocket 연결이 닫힌 상태를 나타냅니다. 연결이 서버에 의해 닫히거나 클라이언트가 명시적으로 closeWebSocket 함수를 사용하여 연결을 닫으면 발생합니다. 연결이 닫힌 후에는 새 WebSocket 연결을 초기화할 때까지 CLOSED 상태로 유지됩니다.\n\n<div class=\"content-ad\"></div>\n\n\"useWebSocket\" 라이브러리 내의 useWebSocket 훅에서 제공하는 sendJsonMessage 함수는 WebSocket 연결을 통해 JSON 형식의 메시지를 보내는 데 유용한 유틸리티 함수입니다. 이 함수는 JavaScript 객체를 JSON 문자열로 직렬화하는 번거로운 작업을 추상화하여 구조화된 데이터를 WebSocket 서버로 보내는 프로세스를 간소화합니다.\n\nlastJsonMessage:\n\n\"useWebSocket\" 라이브러리 내의 useWebSocket 훅에서 제공하는 lastJsonMessage 속성은 WebSocket 연결을 통해 수신한 JSON 형식의 최근 메시지를 나타냅니다. 이 속성을 사용하면 React 컴포넌트 내에서 받은 마지막 메시지에 포함된 데이터에 액세스하고 처리할 수 있습니다.\n\n다음 코드는 현재 WebSocket 연결 상태를 UI에 표시합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport useWebSocket, { ReadyState } from \"react-use-websocket\";\r\nimport { useSearchParams } from \"react-router-dom\";\r\n\r\nexport interface CryptoMessage {\r\n  TYPE: string;\r\n  M: string;\r\n  FSYM: string;\r\n  TSYM: string;\r\n  F: string;\r\n  ID?: string;\r\n  TS?: string;\r\n  Q?: number;\r\n  P?: number;\r\n  TOTAL?: number;\r\n  RTS?: string;\r\n  CCSEQ?: number;\r\n  TSNS?: number;\r\n  RTSNS?: number;\r\n}\r\n\r\nconst Dashboard = () => {\r\n  const [searchParams] = useSearchParams();\r\n  const api_key = searchParams.get(\"api_key\");\r\n  const socketUrl = `wss://streamer.cryptocompare.com/v2?api_key=${api_key}`;\r\n  const { readyState, sendJsonMessage, lastJsonMessage } =\r\n    useWebSocket<CryptoMessage>(socketUrl, { share: true });\r\n\r\n  const connectionStatus = {\r\n    [ReadyState.CONNECTING]: \"연결 중\",\r\n    [ReadyState.OPEN]: \"열림\",\r\n    [ReadyState.CLOSING]: \"닫히는 중\",\r\n    [ReadyState.CLOSED]: \"닫힘\",\r\n    [ReadyState.UNINSTANTIATED]: \"미초기화\",\r\n  }[readyState];\r\n\r\n  return <>{connectionStatus} </>;\r\n};\r\n\r\nexport default Dashboard;\r\n```\r\n\r\n\"열림\" 상태를 받으면 WebSocket 서비스로 메시지를 보낼 수 있습니다.\r\n\r\n```js\r\nuseEffect(() => {\r\n    if (readyState === ReadyState.OPEN) {\r\n      sendJsonMessage({\r\n        action: \"SubAdd\",\r\n        subs: [\r\n          \"0~Coinbase~BTC~USD\",\r\n          \"0~Coinbase~BTC~EUR\",\r\n          \"0~Coinbase~ETH~USD\",\r\n          \"0~Coinbase~ETH~EUR\",\r\n        ],\r\n      });\r\n    }\r\n  }, [readyState, sendJsonMessage]);\r\n```\r\n\r\nsendJsonMessage 내에 있는 json 객체를 설명해보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n# 작업:\n\n- 해당 객체에는 값이 \"SubAdd\"인 action 속성이 포함되어 있습니다.\n- 이는 WebSocket 서버에서 수행할 작업이 새 데이터 스트림에 구독하는 것임을 나타냅니다.\n\n# 구독:\n\n- 해당 객체에는 subs라는 속성이 포함되어 있으며 구독 문자열의 배열을 보유합니다.\n- 각 구독 문자열은 클라이언트가 구독하려는 특정 데이터 스트림을 나타냅니다.\n- 각 구독 문자열의 형식은 \"0~'거래소'~'기초통화'~'견적통화'\"입니다. 여기서:\n- \"0\": 스트리밍 데이터에 대한 구독을 나타냅니다 (역사적 데이터와 대조됨).\n- '거래소': 데이터를 제공하는 거래소의 이름을 나타냅니다 (예: \"코인베이스\").\n- '기초통화': 거래 페어의 기초 통화를 나타냅니다 (예: 비트코인의 경우 \"BTC\", 이더리움의 경우 \"ETH\").\n- '견적통화': 거래 페어의 견적 통화를 나타냅니다 (예: 미국 달러의 경우 \"USD\", 유로의 경우 \"EUR\").\n\n<div class=\"content-ad\"></div>\n\n요약하자면, 이 코드는 WebSocket 서버에게 새로운 데이터 스트리밍을 위한 구독을 추가하도록 지시합니다. subs 배열에 지정된 구독은 Coinbase 거래소의 다양한 거래 페어를 대상으로 하며, BTC/USD, BTC/EUR, ETH/USD 및 ETH/EUR 등이 포함됩니다. 이를 통해 클라이언트가 WebSocket 서버로부터 이러한 거래 페어의 실시간 업데이트를 받을 수 있게 됩니다.\n\n이제 데이터를 가능한 한 빨리 받을 수 있게 되었으니, 남은 작업은 브라우저에 스트리밍 데이터를 표시하는 것 뿐입니다.\n\n```js\nconst renderList = () => {\n    return list.map((element: CryptoMessage, index: number) => {\n      return (\n        <li key={index}>\n          {element.FSYM} - {element.P}\n        </li>\n      );\n    });\n  };\n\nreturn <>{readyState === ReadyState.OPEN? renderList() : connectionStatus} </>;\n```\n\n각 요소에 대해, element.FSYM의 값 (암호화폐 심볼인지 ETH 또는 BTC인지)을 나타내는 JSX `li` 요소를 반환하고, 그 뒤에는 대시(-)와 element.P의 값(가격)을 나타냅니다. 결과는 다음과 같을 것입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2](/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2.png)\n\n우리 데이터를 그래프로 시각화하는 것이 훨씬 쉬울 것입니다. 이를 위해 react google charts를 설치해야 합니다.\n\n```js\nnpm install --save react-google-charts\n```\n\n또는\n\n\n<div class=\"content-ad\"></div>\n\n```js\nyarn add react-google-charts\n```\n\n이후에 Chart를 가져와서 renderList 함수를 renderGraph로 변경합시다:\n\n```js\nconst graphData: any[] = [[\"\", \"BTC\", \"ETH\"]];\n      let BTCPrice;\n      let ETHPrice;\n      for (const element of list) {\n        if (element.FSYM === \"BTC\") {\n          BTCPrice = element.P;\n        } else if (element.FSYM === \"ETH\") {\n          ETHPrice = element.P;\n        }\n        if (typeof BTCPrice === \"undefined\" || typeof ETHPrice === \"undefined\") {\n          continue;\n        } else {\n          graphData.push([\"\", BTCPrice, ETHPrice]);\n        }\n      }\n      return (\n        <Chart\n          graph_id=\"graph\"\n          chartType=\"LineChart\"\n          width=\"100%\"\n          height=\"400px\"\n          data={graphData}\n          options={options}\n        />\n      );\n  };\n\n  return (\n    <>{readyState === ReadyState.OPEN ? renderGraph() : connectionStatus} </>\n  );\n```\n\n결과는 다음과 같을 것입니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_3.png\" />\n\n그리고 마지막으로 작동 예제가 있습니다.\n\n# 결론\n\n이는 웹소켓을 사용하는 매우 단순한 방법이지만 문제를 해결해야 할 두 가지 중요한 문제가 있습니다. 첫 번째는 끝없는 리스트로 브라우저를 휩쓸 것이라는 점이고, 두 번째는 배열을 \"n\"개의 요소로 나누어도 대규모 다시 렌더링 문제가 발생하여 응용 프로그램이 반응 없거나 느려질 수 있습니다. 애플리케이션을 빠르고 부드럽게 실행하기 위한 몇 가지 기술이 있지만 이 글을 너무 길게 만들고 싶지 않아 두 부분으로 나누기로 결정했습니다.","ogImage":{"url":"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png"},"coverImage":"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png","tag":["Tech"],"readingTime":12},{"title":" TypeScript와 GitHub Actions를 사용하여 React 앱을 GitHub Pages에 배포하는 방법 ","description":"","date":"2024-06-22 03:03","slug":"2024-06-22-DeployingaReactAppwithTypeScriptandGitHubActionstoGitHubPages","content":"\n\n리액트 애플리케이션을 GitHub Pages에 배포하는 것은 적절한 설정으로 간단할 수 있어요. 이 안내서를 통해 TypeScript 및 GitHub Actions를 사용하여 미리 빌드된 React 앱을 GitHub Pages에 배포하는 방법을 안내할 거에요. 최적의 방법에 중점을 두어 배포를 깔끔하고 효율적으로 만들어보겠습니다.\n\n# 소개\n\n이 워크플로우는 dist 폴더를 메인 브랜치에 커밋하는 대신 peaceiris/actions-gh-pages@v3action을 사용하여 dist 디렉토리의 내용을 직접 gh-pages 브랜치에 배포합니다. 이 방법을 통해 애플리케이션의 컴파일된 최적화된 프로덕션 빌드만 GitHub Pages에 배포되므로 메인 브랜치를 깨끗하게 유지하고 소스 코드 관리에 집중할 수 있습니다.\n\n# 구성 세부 정보\n\n<div class=\"content-ad\"></div>\n\n1. 라우터의 베이스네임 속성: 🛤️\nApp.tsx 파일에서 `Router` 컴포넌트의 basename 속성을 설정하세요. 이렇게 하면 애플리케이션이 GitHub Pages의 하위 디렉토리 (/pokemon-react-app)에 배포될 때, 라우트가 해당 기본 URL을 기준으로 올바르게 해석됩니다.\n\n```js\n<Router basename=\"/pokemon-react-app\">\n {/* 여러분의 라우트 */}\n</Router>\n```\n\n2. 웹팩 설정: 🔧\n웹팩 구성에서 publicPath를 조정하여 하위 디렉토리에 배포될 때 자산 URL을 고려하세요.\n\n```js\noutput: {\n  filename: 'bundle.js',\n  path: path.resolve(__dirname, 'dist'),\n  publicPath: '/pokemon-react-app/',\n}\n```\n\n<div class=\"content-ad\"></div>\n\n3. Package.json 구성: 📦\npackage.json의 name 및 homepage 필드가 GitHub Pages를 올바르게 구성하도록 설정되었는지 확인하세요.\n\n```js\n{\n  \"name\": \"pokemon-react-app\",\n  \"homepage\": \"https://Jagoda11.github.io/pokemon-react-app\",\n}\n```\n\n# 단계별 안내 📝\n\n# 1. gh-pages 브랜치 생성하기 🌿\n\n<div class=\"content-ad\"></div>\n\n첫째로, gh-pages 브랜치가 없는 경우에만 생성하고 해당 내용을 정리하세요:\n\n```js\ngit checkout -b gh-pages\ngit checkout gh-pages\ngit rm -r .\ngit commit -m \"배포를 위한 정리\"\ngit push origin gh-pages\n```\n\n# 2. GitHub Actions Workflow ⚙️\n\nci.yml 파일에 GitHub Actions Workflow를 설정하여 배포 프로세스를 자동화하세요.\n\n<div class=\"content-ad\"></div>\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [21.x]\n\n    steps:\n      - uses: actions/checkout@v2\n      - name: 🛠️ Use Node.js ${ matrix.node-version }\n        uses: actions/setup-node@v2\n        with:\n          node-version: ${ matrix.node-version }\n      - name: 📦 Install dependencies\n        run: npm ci\n      - name: 🖌️ Format code\n        run: npm run format\n      - name: 🧹 Lint code\n        run: npm run lint\n      - name: 🔨 Build\n        run: npm run build\n      - name: 🧪 Test with coverage\n        run: npm run test\n      - name: 🚀 Deploy to GitHub Pages 🚀\n        if: github.ref == 'refs/heads/main'\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${ secrets.GITHUB_TOKEN }\n          publish_dir: ./dist\n```\n\n# 3. Configuring GitHub Pages in GitHub Interface 🌐\n\nTo configure GitHub Pages in the GitHub interface:\n\n1. Navigate to Repository Settings: 🛠️\nGo to your repository on GitHub, click on the Settings tab.\n\n<div class=\"content-ad\"></div>\n\n2. 페이지 설정에 액세스하기: 📄\n왼쪽 메뉴에서 아래로 스크롤하여 \"페이지\"를 클릭하세요.\n\n3. 소스 브랜치 선택하기: 🌳\n\"소스\" 섹션에서 브랜치 드롭다운 메뉴에서 gh-pages를 선택하세요.\n\n4. 폴더 지정하기: 📁\n만약 당신의 dist 폴더가 리포지토리의 루트 레벨에 있다면, 폴더 드롭다운에서 / (루트)를 선택하세요. 다른 디렉토리 안에 있다면 해당 경로를 명시하세요.\n\n5. HTTPS 강제하기: 🔒\n사이트를 배포할 때 안전한 연결을 보장하기 위해 HTTPS를 활성화할 박스를 체크하세요.\n\n<div class=\"content-ad\"></div>\n\n6. 저장하기: 💾\n구성을 적용하려면 저장 버튼을 클릭하세요.\n\n![이미지](/assets/img/2024-06-22-DeployingaReactAppwithTypeScriptandGitHubActionstoGitHubPages_0.png)\n\n## 4. .gitignore에 dist 유지하기 🚫\n\n주 브랜치를 깨끗하게 유지하려면 .gitignore 파일에 dist 디렉토리를 포함시키세요. 이렇게 하면 dist 폴더가 주 브랜치에 커밋되지 않고, GitHub Actions 파이프라인에서 빌드 프로세스 중에 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n 다음과 같은 줄을 .gitignore 파일에 추가해주세요:\n\n```js\ndist/\n```\n\n# 결론 🎉\n\n위 단계를 따라하면 GitHub Actions를 통해 GitHub Pages에 React 애플리케이션을 효율적으로 배포할 수 있습니다. 이 설정은 메인 브랜치를 유지하고 소스 코드 관리에 집중하면서 최적화된 프로덕션 빌드만 배포되도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n제 포켓몬 앱의 작동 예제를 확인하고 완전한 소스 코드를 보려면 GitHub 저장소를 살펴보세요.\n\n저자 소개\n\n안녕하세요, 개발에 열정을 품고 웹 개발과 오픈 소스 프로젝트에 관심을 가지고 있는 Jagoda입니다. GitHub에서 제 작품을 더 확인하거나 LinkedIn에서 저와 소통할 수 있습니다.\n\n질문이 있거나 추가 도움이 필요하다면 언제든지 댓글을 남기거나 연락해주세요. 즐거운 배포되세요!🌟","ogImage":{"url":"/assets/img/2024-06-22-DeployingaReactAppwithTypeScriptandGitHubActionstoGitHubPages_0.png"},"coverImage":"/assets/img/2024-06-22-DeployingaReactAppwithTypeScriptandGitHubActionstoGitHubPages_0.png","tag":["Tech"],"readingTime":4},{"title":"useState와 useRef 훅을 언제 사용하는지 이해하기","description":"","date":"2024-06-22 03:02","slug":"2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks","content":"\n\n<img src=\"/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_0.png\" />\n\nReact는 사용자 인터페이스를 구축하기 위한 자바스크립트 라이브러리입니다. 선언적이고 효율적이며 유연합니다. React는 컴포넌트 기반 접근 방식을 사용하여 인터랙티브한 UI를 쉽게 생성할 수 있습니다.\n\nReact에서 Hook은 클래스 컴포넌트를 생성하지 않고도 상태 및 기타 React 기능을 사용하는 방법입니다. 가장 자주 사용되는 Hook 중 하나는 useState()이지만 때로는 useRef()를 사용하는 것이 더 나은 방법으로 상태를 관리할 수 있습니다.\n\n이 글에서는 useState() 훅 이외에 useRef() 훅을 사용할 때에 대해 배우게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 사용법 useState():\n\n폼 입력 필드를 처리할 때 주로 사용되는 경우는 제출 버튼이 클릭될 때입니다. 예를 들어, 다음 코드 조각을 살펴보겠습니다:\n\n![화면 캡처 이미지](/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_1.png)\n\n위의 예에서는 이메일과 비밀번호 두 가지 입력 필드가 있습니다. 제출 버튼을 클릭하면 두 입력 필드의 값이 콘솔에 기록됩니다. useState() 훅을 사용하여 두 입력 필드의 상태를 관리합니다. 그러나 입력 필드가 변경될 때마다 컴포넌트가 다시 렌더링되도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*0mz26TiXCcMdstgoUx73ug.gif)\n\n이걸 보면 우리가 onSubmit 안에서만 이 상태 변수들을 사용한다는 것을 알 수 있어요. 즉, 이 상태 변수들이 변경되는 값을 우리는 신경 쓰지 않습니다. 우리는 submit 버튼을 눌렀을 때 상태 변수들의 값만을 신경 씁니다. \n\n이 예시에서는 문제가 되지 않지만, 보다 복잡한 어플리케이션에서는 성능 문제를 일으킬 수 있어요.\n\n## 이를 피하려면, useState() 대신 useRef()를 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## useRef 사용:\n\n![image](/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_2.png)\n\n위 예시에서 useRef를 사용하여 ref를 생성하고 input 필드에 할당합니다. 버튼을 클릭하면 handleSubmit 함수가 실행되고 사용자의 이메일 및 비밀번호를 얻을 수 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*W-14Q7gk6Cvyre6b_fGalQ.gif)\n\n<div class=\"content-ad\"></div>\n\n보시는 대로, 이메일 및 비밀번호 필드를 변경할 때 컴포넌트가 다시 렌더링되지 않았습니다. 그리고 이를 위해 상태 값이 사용되지 않았습니다.\n\n다음은 useState() 대신 useRef()를 사용해야 하는 경우의 몇 가지 예시입니다:\n\n- 업데이트될 때 다시 렌더링을 트리거하지 않는 값을 저장해야 할 때\n- 렌더링 방법에서 사용되지 않는 값을 저장해야 할 때\n- 컴포넌트의 수명 동안 지속되어야 하는 값을 저장해야 할 때\n\n# 결론:\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 useRef와 useState가 React에서 모두 중요한 훅이지만 서로 다른 목적을 가지고 있다는 것을 배웠습니다. useRef는 DOM에 직접 액세스하고 조작할 수 있게 해주는 훅입니다. 요소에 대한 참조를 제공하지만 내용이 변경될 때 다시 렌더링을 트리거하지 않습니다. useState는 컴포넌트의 상태를 관리할 수 있게 해주는 훅입니다. 상태가 변경되면 새로운 상태로 컴포넌트가 다시 렌더링됩니다.\n\n# 읽어 주셔서 감사합니다\n\n이 기사가 유용하게 느껴졌으면 좋겠습니다. 궁금한 점이나 제안 사항이 있으시면 댓글을 남겨 주세요. 피드백은 제게 더 나아질 수 있게 도와줍니다.","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 설정 WebPack, 린트 그리고 핫리로드 사용 방법","description":"","date":"2024-06-22 03:01","slug":"2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload","content":"\n\n## React의 기본 설정, 핫 리로딩, 린트, 웹팩\n\n![React 설정](/assets/img/2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload_0.png)\n\n## 1. 폴더 생성\n\n```js\nmkdir 폴더명\ncd 폴더명\n```\n\n<div class=\"content-ad\"></div>\n\n## 2. git 설치하기\n\n```js\ngit init // 명령을 완료하려면 Enter 키를 여러 번 누르세요\n```\n\n## 3. .gitignore 파일 생성\n\n.gitignore 파일을 생성하고 아래 코드를 추가하세요\n\n<div class=\"content-ad\"></div>\n\n```js\n// .gitignore 파일에 아래 라인 추가\n\nnode_modules\n.DS_Store\n```\n\n## 4. 루트 폴더에 Package.json 생성\n\n```js\nnpm init // 명령어를 실행하고 엔터 키를 여러 번 눌러주세요\n```\n\n## 5. 루트 폴더에 린트 추가하기\n\n<div class=\"content-ad\"></div>\n\n프로젝트에 lint 패키지를 소개하고 있어요. Airbnb는 우리가 사용할 표준 lint 패키지입니다. 먼저 아래 명령어로 패키지를 설치해주세요.\n\n```js\n// lint npm 패키지 및 의존성 설치\nnpx install-peerdeps --dev eslint-config-airbnb\n```\n\n.eslintrc 파일을 만들고 아래 코드를 추가해주세요.\n\n```js\n{\n  \"extends\": \"airbnb\",\n  \"parser\": \"@babel/eslint-parser\",\n  \"plugins\": [\n    \"react-hooks\"\n  ],\n  \"globals\": {\n    \"globalThis\": true,\n    \"google\": true,\n    \"document\": true\n  },\n  \"rules\": {\n    \"import/no-extraneous-dependencies\": [\"off\"], // webpack-dashboard와 같은 외부 종속성 사용 필요\n    \"react/jsx-filename-extension\": [1, { \"extensions\": [\".js\", \".jsx\"] }] // jsx 사용 필요\n  },\n  \"parserOptions\": {\n    \"ecmaVersion\":\"latest\" // 최신 ECMA 스크립트 지원을 위해\n}\n```\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식으로 표 태그를 변경하십시오. \n\n또한 VScode에 ESLint 플러그인을 설치하십시오. vscode에서 eslint 확장 프로그램 이미지를 아래 이미지에서 확인하십시오.\n\n![eslint extension in vscode](/assets/img/2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload_1.png)\n\n## 6. 루트 폴더에 .editorconfig 파일 생성\n\n그 다음 단계로, 코드 형식을 유지하기 위해 .editorconfig 파일을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n루트 = 참\n\n[*]\n들여쓰기_스타일 = 공간\n들여쓰기_크기 = 2\n줄의_끝 = lf\n문자셋 = utf-8\n뒤의_공백_제거 = 참\n마지막_새줄_삽입 = 참\r\n\n\n## 7. 루트 폴더 내 .vscode 폴더에 setting.json 만들기\n\n우리는 .vscode라는 폴더를 생성하고 .vscode 폴더 내에 setting.json 파일을 만듭니다. 아래 라인을 추가하여 린트 자동 수정 및 탭 들여쓰기가 2인 설정을 합니다. setting.json에 아래 코드를 추가하세요.\n\n\n{\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": \"explicit\",\n    \"source.fixAll\": \"always\", \n    \"editor.tabSize\": 2 \n  },\n  \"eslint.workingDirectories\": [\n      {\"mode\": \"auto\"}\n    ],\n  },\n  \"search.exclude\": {\n      \"**/index.js\": true,\n      \"**/__build-es/**\": true\n   }\n}\n\n\n<div class=\"content-ad\"></div>\n\n## 8. 앱 폴더 생성\n\n앱 폴더를 만들어보겠습니다. 모든 개발 관련 파일은 앱 폴더 아래에 위치합니다.\n\n우리는 client.js라는 새 파일을 추가하고 있습니다. 일단 client.js 내에 콘솔을 추가하고 있습니다. 나중에는 애플리케이션을 부트스트랩하기 위해 리액트 코드를 추가할 것입니다.\n\n```js\nconsole.log('Client file loaded');\n```\n\n<div class=\"content-ad\"></div>\n\n## 9. webpack.config.js 추가하기\n\n웹팩과 웹팩-cli를 설치하여 webpack.config.js를 구성하세요.\n\n```js\nnpm install webpack webpack-cli webpack-dev-server --save-dev\n```\n\n다음 단계에서는 싱글 페이지 애플리케이션을 위해 webpack.config.js를 생성하고 구성해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst path = require('path');\n\n module.exports = {\n   entry: {\n     client: './app/client.js',\n   },\n   mode: 'development',\n   output: {\n     filename: 'client.js',\n     path: path.resolve(__dirname, 'build'),\n     publicPath: '',\n   },\n };\n```\n\npackage.json 파일 내 script 오브젝트에 명령어 추가\n\n```js\n\"build\": \"webpack --config webpack.config.js\"\n```\n\n터미널에서 명령어 실행\n\n```js\nnpm run build\n```\n\n<div class=\"content-ad\"></div>\n\n와우, 빌드 폴더 내의 js 파일을 Transpile하는 설정을 완료했어요. 빌드 폴더가 생성되었고 client.js Transpile 파일이 포함되어 있어요.\n\n## 10. JSX 지원 제공\n\nnpm i @babel/preset-react --save-dev를 설치해주세요.\n\n그리고 루트 폴더에 .babelrc 파일을 추가하고 아래 코드를 추가해주세요. 이렇게 하면 JSX 지원이 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  \"presets\": [\n    \"@babel/preset-react\"\n  ]\n}\n```\n\n## 11. babel-loader를 사용하여 React 코드를 Javascript로 변환하기\n\n```js\nnpm i babel-loader --save-dev\n```\n\nmode: \"development\" 이후에 webpack.babel.js 안에 babel-loader를 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      exclude: /node_modules/,\n      use: [{ loader: 'babel-loader', options: { cacheDirectory: true } }],\n    },\n  ],\n},\n```\n\n## 12. 프로젝트에서 React 및 JSX 사용하기\n\nReact 및 react-dom 설치\n\n```js\nnpm i react react-dom --save\n```\n\n<div class=\"content-ad\"></div>\n\n아래 코드를 client.js 파일 안에 추가해주세요.\n\n```js\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst APP = (\n  <div>앱이 실행 중입니다</div>\n);\n\ncreateRoot(document.getElementById('root')).render(APP);\n```\n\n## 13. 루트 폴더에 index.html을 추가해봅시다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>App 1</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script src=\"build/client.js\"></script>\n  </body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\nindex.html 파일을 실행해 주세요.\n\n와우, 설치가 완료되었습니다.\n\n## 14. 핫 리로딩 추가하기\n\nclient.js 파일 변경이 페이지에 반영되지 않는군요. webpack-dev-server를 이용해 핫 리로딩을 추가해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\nnpm install webpack-dev-server\r\n```\r\n\r\n이제 package.json의 start 스크립트를 변경해야 합니다.\r\n\r\n```js\r\n// 이전 설정\r\n\"start\": \"webpack  --config webpack.config.js\"\r\n\r\n// 이제 핫리로딩이 가능한 설정\r\n\"start\": \"webpack-dev-server  --config webpack.config.js\"\r\n```\r\n\r\nwebpack.config.json 파일에 webpack-dev-server를 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\ndevServer: {\n  devMiddleware: { writeToDisk: true },\n  static: {\n    directory: path.join(__dirname, '/'),\n  },\n  compress: true,\n  port: 9000,\n},\n```\n\n그거 정말 멋지죠. 이제 http://localhost:9000/에서 애플리케이션을 실행할 수 있어요.\n\n## 결론:\n\n이 설정에서 우리는 지원을 제공했습니다.\n\n<div class=\"content-ad\"></div>\n\n- git (버전 관리)\n- Airbnb의 ESlint\n- 코드 형식 유지\n- Linting 자동 수정\n- JSX 지원\n- React 지원\n- 핫 리로딩","ogImage":{"url":"/assets/img/2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload_0.png"},"coverImage":"/assets/img/2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload_0.png","tag":["Tech"],"readingTime":6},{"title":"Shadcn UI, Vite, Tailwind CSS, Storybook으로 React UI 컴포넌트 라이브러리 만드는 방법 단계별 가이드","description":"","date":"2024-06-22 02:59","slug":"2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook","content":"\n\n![이미지](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_0.png)\n\n안녕하세요! 이 글에서는 Shadcn UI, Vite, Tailwind CSS 및 Storybook을 사용하여 React UI 컴포넌트 라이브러리를 설정하는 방법에 대해 안내하겠습니다. 설정 프로세스에 들어가기 전에 이 기술들이 무엇이며 왜 사용하는지에 대해 먼저 이해해봅시다.\n\n- Shadcn UI: Shadcn UI는 아름답고 접근성 있는 컴포넌트들의 모음이며 응용 프로그램에서 사용할 수 있습니다. 이는 종속성으로 설치하는 전통적인 컴포넌트 라이브러리가 아닙니다. 대신 컴포넌트를 찾아보고 복사하여 붙여넣거나 필요에 맞게 사용자 정의할 수 있습니다. Shadcn UI를 사용하는 이유는 일관된 디자인 시스템으로 빠르게 프로토타입을 만들고 컴포넌트를 구축할 수 있기 때문입니다.\n- Vite: Vite는 현대적인 웹 프로젝트에 대해 더 빠르고 가벼운 개발 경험을 제공하도록 목적으로 하는 빌드 도구입니다. Vite에는 두 가지 주요 부분이 포함되어 있습니다. 네이티브 ES 모듈에 대해 매우 빠른 핫 모듈 교체(HMR)와 같은 기능을 제공하는 개발 서버 및 코드를 Rollup과 함께 번들로 묶어서 프로덕션용으로 매우 최적화된 정적 에셋을 출력할 수 있도록 사전 구성된 빌드 명령이 있습니다. Vite의 사용 이유는 전통적인 도구와 비교하여 더 빠르고 효율적인 빌드 프로세스를 제공하기 때문입니다.\n- Tailwind CSS: Tailwind CSS는 맞춤형 사용자 인터페이스를 빠르게 구축하기 위한 유틸리티 중심의 CSS 프레임워크입니다. HTML을 떠나지 않고 완전히 맞춤형 디자인을 구축할 수 있도록 낮은 수준의 유틸리티 클래스를 제공합니다. 버튼이나 테이블과 같은 요소에 대해 미리 정의된 클래스 시리즈를 제공하지 않습니다. Tailwind CSS를 사용하는 이유는 쉽고 효율적으로 사용자 지정 스타일을 만들 수 있기 때문입니다.\n- Storybook: Storybook은 UI 컴포넌트 및 페이지를 격리해서 구축하는 도구입니다. 전체 앱을 실행할 필요 없이 어려운 상태와 예외 사례를 개발하고 공유할 수 있습니다. 수천 개의 팀이 UI 개발, 테스트 및 문서 작업을 위해 Storybook을 사용합니다. Storybook을 사용하는 이유는 컴포넌트를 격리해서 개발 및 테스트할 수 있어 개발 프로세스를 더 효율적으로 관리할 수 있기 때문입니다.\n\n이제 이러한 기술들에 대한 이해를 더 했으니 설정 프로세스에 대해 알아봅시다. 함께 진행해보시죠!\n\n<div class=\"content-ad\"></div>\n\n# 준비 사항\n\n시작하기 전에 다음을 이미 알고 있다고 가정합니다:\n\n- React\n- TypeScript\n- Tailwind CSS\n\n그리고 시스템에 다음이 설치되어 있는지 확인하세요:\n\n<div class=\"content-ad\"></div>\n\n- Node.js와 npm\n\n# 단계 1: Vite로 프로젝트 설정하기\n\n우선 Vite (5.2.0)를 사용하여 새 프로젝트를 설정해야 합니다. 터미널에서 다음 명령을 실행하십시오:\n\n```js\nnpm create vite@latest\n```\n\n<div class=\"content-ad\"></div>\n\n터미널에서 화면 안내에 따라 따라가서 프로젝트 이름을 입력하세요. 이 글에서는 \"ui-library\"라는 이름을 사용하고 있습니다. 리액트와 TypeScript를 사용할 것이기 때문에 해당 옵션을 선택하세요.\n\n![이미지](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_1.png)\n\n모든 지침을 따르고 나면 \"ui-library\" 프로젝트 디렉토리 안에 들어가고 http://localhost:5173/에서 Vite 데모 페이지를 볼 수 있을 것입니다.\n\n# 단계 2: Tailwind CSS 설치하기\n\n<div class=\"content-ad\"></div>\n\n다음으로, Tailwind CSS (3.4.3)를 다음 명령어를 사용하여 설치합니다:\n\n```js\nnpm install -D tailwindcss postcss autoprefixer\n```\n\n# 단계 3: Tailwind CSS 구성\n\nTailwind CSS를 설치한 후, 구성 파일을 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx tailwindcss init -p\n```\n\n프로젝트 루트에 tailwind.config.js 파일이 생성됩니다. 우선 아래 내용대로 파일을 업데이트하세요. shadcn이 설치되면 업데이트될 것입니다.\n\n<img src=\"/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_2.png\" />\n\n각 Tailwind 레이어에 대한 @tailwind 지시문을 src/index.css 파일에 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\nApp.tsx 파일 안의 모든 내용을 다음과 같이 바꾸고 npm run dev를 실행하십시오:\n\n```js\r\nexport default function App() {\n  return <h1 className='text-3xl font-bold underline'>안녕, 세상아!</h1>;\n}\r\n```\n\n이제 브라우저에서 다음이 표시됩니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_3.png)\n\n현재 단계에서는 Vite 및 Tailwind가 설치된 프로젝트를 가지고 있습니다.\n\n# 단계 4: Storybook 통합\n\n이제 우리는 Storybook 8을 통합하여 UI 구성요소를 격리된 상태로 개발하고 각 구성요소에 대한 청결한 문서를 제공할 것입니다. 다음 명령을 사용하여 설치하십시오:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx storybook@latest init\n```\n\n이 명령어를 실행하면 자동으로 프로젝트 유형을 감지하고 package.json에 필요한 종속성 및 스크립트를 추가하게 될 거에요. 그리고 http://localhost:6006/에 아래의 데모 페이지를 볼 수 있을 거에요:\n\n![이미지](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_4.png)\n\nStorybook과 함께 Tailwind 클래스를 사용하려면 .storybook/preview.ts 파일에 불러와야 해요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'tailwindcss/tailwind.css'\n```\n\n# 단계 5: Shadcn UI 설치하기\n\n이제 Shadcn을 프로젝트에 설정할 것이며, 이를 통해 UI 컴포넌트를 생성할 것입니다.\n\n먼저, tsconfig.json 파일의 compilerOptions에 경로를 해결하는 몇 가지 코드를 추가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  \"compilerOptions\": {\n    // ...\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\n        \"./src/*\"\n      ]\n    }\n    // ...\n  }\n}\n```\n\n그런 다음 다음 명령을 사용하여 @types/node을 설치하겠습니다.\n\n```js\n# (\"path\"를 오류 없이 가져올 수 있도록 함)\nnpm i -D @types/node\n```\n\n아래 코드를 vite.config.ts에 추가하여 앱이 오류 없이 경로를 해석할 수 있도록 하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport path from \"path\"\nimport react from \"@vitejs/plugin-react\"\nimport { defineConfig } from \"vite\"\n \nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n})\n```\n\n프로젝트를 설정하려면 shadcn-ui init 명령을 실행하세요:\n\n```js\nnpx shadcn-ui@latest init\n```\n\n다음과 같이 옵션을 선택하세요:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_5.png)\n\n이제 첫 번째 컴포넌트를 추가할 준비가 되었습니다.\n\n# 단계 6: 컴포넌트 생성\n\n이제 Shadcn UI를 사용하여 간단한 컴포넌트를 만들어 봅시다. 아래 명령어는 Button 컴포넌트를 프로젝트에 추가합니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx shadcn-ui@latest add button\n```\n\nStorybook story나 src\\components\\ui\\button.tsx에서 Button 컴포넌트를 가져올 수 있습니다.\n\n# 단계 7: Storybook에 컴포넌트 추가하기\n\n마지막으로, Button 컴포넌트를 Storybook에 추가해 보겠습니다. Storybook에는 기존의 Button 컴포넌트가 있을텐데, 이것을 포함하여 다른 샘플 컴포넌트들을 삭제할 수 있습니다. src\\stories\\Button.stories.ts 디렉토리의 파일 Button.stories.tsx를 다음과 같이 편집하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Button } from '@/components/ui/button'\nimport type { Meta, StoryObj } from '@storybook/react'\nimport { fn } from '@storybook/test'\n\nconst meta = {\n  title: 'Example/Button',\n  component: Button,\n  parameters: {\n    layout: 'centered',\n  },\n  tags: ['autodocs'],\n  argTypes: {},\n  args: { onClick: fn() },\n} satisfies Meta<typeof Button>\nexport default meta\ntype Story = StoryObj<typeof meta>\nexport const Primary: Story = {\n  args: {\n    children: 'Button',\n  },\n}\n```\n\n이제 npm run storybook을 실행하여 Storybook을 시작하고 http://localhost:6006/에서 구성 요소를 확인할 수 있습니다. 이렇게 보일 것입니다:\n\n<img src=\"/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_6.png\" />\n\n이제 Button 구성 요소를 사용자 정의하고 여기에서 더 많은 shadcn 구성 요소를 추가할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n축하합니다! Shadcn UI, Vite, Tailwind CSS 및 Storybook을 사용하여 React UI 컴포넌트 라이브러리를 성공적으로 설정했습니다. 이 설정은 컴포넌트를 효율적으로 생성하고 관리하는 데 도움이 될 것입니다.\n\n도움이 되었다면 좋아요를 눌러주세요. 피드백은 언제나 환영합니다 :)","ogImage":{"url":"/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_0.png","tag":["Tech"],"readingTime":7},{"title":"Skeleton Loaders React 데이터 로딩 쉽게 하기 - 1부","description":"","date":"2024-06-22 02:58","slug":"2024-06-22-SkeletonLoadersSimplifyingDataLoadinginReactPart1","content":"\n\n![이미지](/assets/img/2024-06-22-SkeletonLoadersSimplifyingDataLoadinginReactPart1_0.png)\n\n# 파트 원: 우리의 리액트 앱 만들기\n\n이 두 파트 시리즈에 오신 것을 환영합니다. 우리는 Skeleton Loaders에 대해 살펴보며 React에서 데이터 로딩을 간소화하는 방법에 대해 알아볼 것입니다. 첫 번째 파트에서는 새로운, 현대적인 React 애플리케이션을 처음부터 설정할 것입니다. 그런 다음 일부 데이터를 가져와 스타일링을 추가할 것입니다.\n\n## Skeleton Loading 화면의 파워를 이해하기\n\n<div class=\"content-ad\"></div>\n\n대부분의 최신 웹 사이트는 데이터를 서버 측이 아닌 브라우저에서 가져옵니다. 사용자가 콘텐츠를 서버에서로드하기까지 기다릴 필요가 없어서 이는 장점이 될 수 있었지만, 그러면 브라우저에서 데이터를 가져와야 하므로 기다려야 하는 상황이 발생했습니다. 이 데이터 가져오기 이벤트를 처리하고 사용자가 애플리케이션 또는 웹 사이트와 상호 작용하도록 유지하기 위해 일반적으로 어떤 종류의 로더나 스피너가 표시됩니다. 매우 실용적이고 점점 일반적인 접근 방법은 스켈레톤 로딩 화면을 사용하는 것입니다. 이는 콘텐츠의 레이아웃을 반영하는 플레이스홀더 요소를 추가하여 들어오는 데이터를 나타냅니다. Facebook 및 LinkedIn과 같은 주요 웹 사이트에서 사용되는 스켈레톤 로딩 화면은 이 상황에 대한 해결책입니다.\n\n전제 조건\n\n- React의 기본 지식.\n- React Hooks에 익숙함.\n\n# 프로젝트 설정하기\n\n<div class=\"content-ad\"></div>\n\n먼저 새로운 리액트 애플리케이션을 생성하세요:\n\n```js\nnpx create-react-app react-skeleton-screens\n```\n\n프로젝트 디렉토리로 이동하세요:\n\n```js\ncd react-skeleton-screens\n```\n\n<div class=\"content-ad\"></div>\n\nVisual Studio Code에서 프로젝트를 열어보세요:\n\n```js\ncode .\n```\n\n## 보일러플레이트 코드 제거\n\ncreate-react-app으로 생성된 기본 파일들을 정리해보세요.\n\n<div class=\"content-ad\"></div>\n\n- `src` 폴더를 열어서 다음 파일들을 삭제해주세요:\n— App.css\n— App.test.js\n— logo.svg\n— setupTests.js\n\n2. index.js 파일 내에서 service worker의 import 및 호출을 제거해주세요.\n\n3. App.js 파일 내에서 logo.svg와 App.css의 import를 제거해주세요. \n\n`App.js`에 다음 코드를 넣어주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from \"react\";\nimport Home from \"./components/Home\";\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header>\n        <h1>식단 레시피</h1>\n      </header>\n      <div className=\"content\">\n        <Home />\n      </div>\n    </div>\n  );\n}\nexport default App;\n```\n\n## 컴포넌트 생성\n\nsrc 폴더 안에 components라는 새 폴더를 만들어주세요. 이 폴더 안에 Home.jsx 파일을 만들어주세요:\n\n```js\nimport React from \"react\";\nconst Home = () => {\n  return <div className=\"home\"></div>;\n};\nexport default Home;\n```\n\n<div class=\"content-ad\"></div>\n\n## 애플리케이션에 스타일 추가하기\n\n우리 애플리케이션의 외관을 개선하기 위해 App.js의 헤더에 일부 스타일을 적용할 거에요.\n\nindex.css 업데이트\n\n`index.css`의 내용을 다음 스타일로 대체해 주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\nheader {\n  font-size: 1.5rem;\n  font-weight: 900;\n  display: grid;\n  align-items: center;\n}\nheader h1 {\n  max-width: 1200px;\n  margin: 0 auto;\n}\n.container {\n  background-color: #6b7280;\n  color: #ffffff;\n  min-height: 100vh;\n  transition: all 1s ease-out;\n}\n.meals {\n  display: grid;\n  grid-template-columns: repeat(1, minmax(0, 1fr));\n  gap: 1.25rem;\n  margin-top: 1.25rem;\n  transition: all 1s ease-out;\n  padding: 10px 50px;\n}\n@media (min-width: 640px) {\n  .meals {\n    grid-template-columns: repeat(2, minmax(0, 1fr));\n  }\n}\n@media (min-width: 768px) {\n  .meals {\n    grid-template-columns: repeat(3, minmax(0, 1fr));\n  }\n}\n@media (min-width: 1280px) {\n  .meals {\n    grid-template-columns: repeat(4, minmax(0, 1fr));\n  }\n}\n.meal {\n  border-radius: 0.25rem;\n  overflow: hidden;\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),\n    0 2px 4px -1px rgba(0, 0, 0, 0.06);\n  cursor: pointer;\n  position: relative;\n  height: 15rem;\n  width: 15rem;\n}\n.meal-img:hover {\n  box-shadow: 0 10px 15px -3px rgba(147, 102, 102, 0.1),\n    0 4px 6px -2px rgba(0, 0, 0, 0.05);\n  transition: all 1s ease-out;\n}\n.meal-img {\n  width: 100%;\n  height: 100%;\n  border: solid 4px #ffffff;\n}\n```\n\n이 스타일은 애플리케이션 헤더가 깔끔하고 시각적으로 매력적으로 보이도록 보장합니다.\n\n## 애플리케이션 실행하기\n\n변경 사항을 확인하려면 개발 서버를 시작하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nyarn dev\n```\n\n브라우저에서 http://localhost:3000 으로 이동하여 새로운 스타일이 적용된 업데이트된 페이지를 확인할 수 있어요.\n\n데이터 가져오기\n\nMealDB API(https://www.themealdb.com/api.php)를 사용하여 데이터를 가져올 거에요.\n\n<div class=\"content-ad\"></div>\n\nApp.js에서 데이터를 저장할 상태를 생성해보세요:\n\n```js\nconst [meals, setMeals] = useState(null);\n```\n\n컴포넌트가 렌더링될 때 데이터를 가져오기 위해 useEffect 훅을 사용해보세요:\n\n```js\nimport { useState, useEffect } from \"react\";\nimport Home from \"./components/Home\";\nfunction App() {\n  const [meals, setMeals] = useState(null);\n  useEffect(() => {\n    setTimeout(async () => {\n      const res = await fetch(\n        \"https://www.themealdb.com/api/json/v1/1/search.php?s=chicken\"\n      );\n      const data = await res.json();\n      setMeals(data);\n    }, 5000);\n  }, []);\n  return (\n    <div className=\"App\">\n      <header>\n        <h1>Meal Recipes</h1>\n      </header>\n      <div className=\"content\">\n        <Home meals={meals} />\n      </div>\n    </div>\n  );\n}\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\nHome.js 파일에서 조건부 렌더링을 사용하여 식사 레시피 결과를 표시하십시오:\n\n```js\nimport { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nconst Home = () => {\n  const [meals, setMeals] = useState(null);\n  useEffect(() => {\n    setTimeout(async () => {\n      const res = await fetch(\n        \"https://www.themealdb.com/api/json/v1/1/search.php?s=chicken\"\n      );\n      const meals = await res.json();\n      setMeals(meals);\n    }, 5000);\n  }, []);\n  return (\n    <div className=\"bg-gray-900 text-white min-h-screen\">\n      <div className=\"m-auto max-w-3xl flex flex-col items-center justify-center text-center\">\n        <div id=\"meals\" className=\"meals\">\n          {meals &&\n            meals.meals.map((meal) => (\n              <div className=\"meal\" key={meal.idMeal}>\n                <Link to={`/MealInfo/${meal.idMeal}`}>\n                  <img\n                    className=\"meal-img\"\n                    src={meal.strMealThumb}\n                    alt={meal.strMeal}\n                  />\n                  <div className=\"meal-info\" data-mealid={meal.idMeal}>\n                    <h3>{meal.strMeal}</h3>\n                  </div>\n                </Link>\n              </div>\n            ))}\n        </div>\n      </div>\n    </div>\n  );\n};\nexport default Home;\n```\n\n## React Router 추가\n\nreact-router-dom 설치하기:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install react-router-dom\n```\n\nreact-router-dom에서 BrowserRouter을 사용하여 main.js에 App을 감싸세요:\n\n```js\nimport React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App.jsx'\nimport './index.css'\nimport { BrowserRouter } from 'react-router-dom'\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>\n);\n```\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n이번 시리즈의 첫 번째 파트에서는 리액트 애플리케이션에 스켈레톤 로딩 화면을 구현하는 기초 작업을 마무리지었습니다. 기본적인 React 프로젝트를 설정하고 컴포넌트를 생성하며, 스타일을 추가하고 API에서 데이터를 가져오면서 우리는 애플리케이션에 스켈레톤 로딩 화면을 통합할 기초를 마련했습니다.\n\n두 번째 파트에서는 스켈레톤 로딩 화면의 구현 세부사항에 더 깊이 파고들 것입니다. 재사용 가능한 스켈레톤 컴포넌트를 생성하는 방법, 로딩 애니메이션을 사용자 정의하는 방법, 그리고 다양한 로딩 시나리오를 효율적으로 처리하는 방법을 살펴볼 것입니다. PART 2로 이동하여 스켈레톤 로딩 화면을 더 발전시키는 방법을 확인해보세요!","ogImage":{"url":"/assets/img/2024-06-22-SkeletonLoadersSimplifyingDataLoadinginReactPart1_0.png"},"coverImage":"/assets/img/2024-06-22-SkeletonLoadersSimplifyingDataLoadinginReactPart1_0.png","tag":["Tech"],"readingTime":7},{"title":"파이썬과 QGIS로 인도의 낙타 80 찾는 방법","description":"","date":"2024-06-22 02:56","slug":"2024-06-22-HereshowIusedPythonandQGIStofindout80ofIndiascamelpopulation","content":"\n\n## 파이썬 자동화\n\n\"안녕 Aayush, 내가 인도의 저소득 농촌 여성들을 위한 낙타 기반 생계 개선에 집중해야 할 곳을 알고 싶어\", 라는 요구가 왔어요. 라자스탄 출신인 내 친구가 말했어요. 그녀는 라자스탄의 사막 지역이 정답일 것이라고 알고 있었지만, 직감을 뒷받침할 공식 자료가 필요했어요. 그래서 제가 나서서 이 정보를 찾기로 했어요. \n\n## 단계 1\n\n인도 정부의 데이터 제공 플랫폼인 data.gov.in 에서 2019년 20번째 가축 조사 자료 시트 제2020년 승업부와 가축전문부, 수산부, 가축전문부의 자료를 찾아보세요.\n\n<div class=\"content-ad\"></div>\n\n## 단계 2\n\n개발자 도구를 사용하여 한 번에 모든 파일에 액세스할 수 있는 URL을 얻는 cURL을 얻으세요. 이렇게 하지 않았다면 각 파일을 개별적으로 클릭하여 양식을 작성하고 캡차를 입력한 다음 CSV를 수동으로 다운로드해야 했을 것입니다. 이 방법으로 제게 많은 시간을 절약했어요.\n\n## Step 3\n\nPostman에 URL을 게시하고 해당하는 Python 요청 코드를 가져와서 응답을 구문 분석하세요.\n\n<div class=\"content-ad\"></div>\n\n## 단계 4\n\n저는 Python을 사용하여 응답을 구문 분석하고, 이 코드를 사용하여 모든 URL 링크를 가져왔어요.\n\n```js\nfrom pprint import pprint\nimport os\nimport pandas as pd\nimport requests\n\nurl = \"https://data.gov.in/backend/dmspublic/v1/resources?filters[catalog_reference]=6885101&offset=0&limit=35&sort[changed]=desc&filters[domain_visibility]=4\"\n\npayload = {}\nheaders = {\n  'Accept': 'application/json, text/plain, */*',\n  'Accept-Language': 'en-GB,en-US;q=0.9,en;q=0.8,de;q=0.7',\n  'Connection': 'keep-alive',\n  'Cookie': 'fontSize=67.5; citrix_ns_id=AAA7TRx1ZjuD0ksAAAAAADuMGtjGAxHPGX4gOzVglnj-t-2_KYp3QS5pOwB3wsrGOw==jyF1Zg==9zCLz_Tsia4CNE6H2-pAKy8Ou1w=; citrix_ns_id=AAA7TRx1ZjuD0ksAAAAAADuMGtjGAxHPGX4gOzVglnj-t-2_KYp3QS5pOwB3wsrGOw==uiR1Zg==JTC1HaNqvL2oNi2kwWYolcsi_TU=',\n  'Referer': 'https://data.gov.in/catalog/20th-livestock-census',\n  'Sec-Fetch-Dest': 'empty',\n  'Sec-Fetch-Mode': 'cors',\n  'Sec-Fetch-Site': 'same-origin',\n  'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36',\n  'dnt': '1',\n  'sec-ch-ua': '\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\"',\n  'sec-ch-ua-mobile': '?0',\n  'sec-ch-ua-platform': '\"macOS\"',\n  'sec-gpc': '1'\n}\n\nresponse = requests.request(\"GET\", url, headers=headers, data=payload)\n```\n\n```js\nrjson = response.json()\nrows = rjson['data']['rows']\nurls = []\nfor row in rows:\n    url = \"https://\"+row['datafile'][0]\n    print(url)\n    urls.append(url)\n```\n\n<div class=\"content-ad\"></div>\n\n최종 출력물은 CSV를 얻기 위해 구문 분석한 URL 목록입니다.\n\n![이미지](/assets/img/2024-06-22-HereshowIusedPythonandQGIStofindout80ofIndiascamelpopulation_0.png)\n\n## 단계 5\n\n모든 파일을 다운로드하여 연결하여 최종 데이터 프레임을 얻었습니다. 그 후에는 80%의 기준점을 사용하여 낙타 인구의 80%를 보유한 지역을 파악했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\nsave_directory = './csv_files/'\n\nif not os.path.exists(save_directory):\n    os.makedirs(save_directory)\n\ndef download_file(url, save_directory):\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # 요청이 성공적인지 확인\n        file_name = os.path.join(save_directory, url.split('/')[-1])\n        with open(file_name, 'wb') as file:\n            file.write(response.content)\n        print(f\"다운로드 완료: {file_name}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"{url}을(를) 다운로드하는 데 실패했습니다: {e}\")\n\nfor url in urls:\n    download_file(url, save_directory)\n\ncsv_directory = save_directory\n\ndataframes = []\n\nall_headers = set()\n\nfor filename in os.listdir(csv_directory):\n    if filename.endswith('.csv'):\n        file_path = os.path.join(csv_directory, filename)\n        df = pd.read_csv(file_path)\n        dataframes.append(df)\n        all_headers.update(df.columns)\n\n# 모든 데이터 프레임이 동일한 헤더를 갖고 있는지 확인\nheaders_match = all(len(df.columns.difference(all_headers)) == 0 for df in dataframes)\n\nif headers_match:\n    combined_df = pd.concat(dataframes, ignore_index=True)\nelse:\n    combined_df = pd.DataFrame(columns=all_headers)\n    for df in dataframes:\n        df = df.reindex(columns=all_headers)  # 모든 열이 존재하는지 확인\n        combined_df = pd.concat([combined_df, df], ignore_index=True)\n\ncombined_csv_path = os.path.join(csv_directory, 'combined.csv')\ncombined_df.to_csv(combined_csv_path, index=False)\n\nprint(f\"결합된 CSV가 저장되었습니다: {combined_csv_path}\")\r\n```\n\n```js\r\ndf['camel'] = pd.to_numeric(df['camel'], errors='coerce')\ndf_sorted = df.sort_values(by='camel', ascending=False).reset_index(drop=True)\ndf_sorted['cumulative_sum'] = df_sorted['camel'].cumsum()\ntotal_camels = df_sorted['camel'].sum()\nthreshold = 0.8 * total_camels\ndf_sorted['cumulative_percentage'] = df_sorted['cumulative_sum'] / total_camels\ndistricts_80_percent = df_sorted[df_sorted['cumulative_percentage'] <= 0.8]\nprint(districts_80_percent[['state_name','district_name', 'camel', 'cumulative_sum', 'cumulative_percentage']])\r\n```\n\n<img src=\"/assets/img/2024-06-22-HereshowIusedPythonandQGIStofindout80ofIndiascamelpopulation_1.png\" />\n\n## 단계 6\r\n\n\n<div class=\"content-ad\"></div>\n\n인도의 지구 행정 구역 geojson 파일을 받았어요. 이 파일을 이용하여 18개의 지구를 필터링하는 기능을 만들고, QGIS에서 이를 시각화하며 배경 레이어를 구글 위성 지도로 설정하여 최종 결과물을 얻었어요.\n\n만약 어떤 단계에 대해 더 알고 싶다면 언제든지 저에게 문의해주세요. 이것은 공개 데이터를 활용하여 결정을 내리는 데 있어 있는 가능성 중 하나의 작은 예시에 불과해요. 즐기세요!","ogImage":{"url":"/assets/img/2024-06-22-HereshowIusedPythonandQGIStofindout80ofIndiascamelpopulation_0.png"},"coverImage":"/assets/img/2024-06-22-HereshowIusedPythonandQGIStofindout80ofIndiascamelpopulation_0.png","tag":["Tech"],"readingTime":5},{"title":"시도해볼 만한 10가지 파이썬 자동화 스크립트","description":"","date":"2024-06-22 02:55","slug":"2024-06-22-10PythonScriptsforAutomationYouShouldTry","content":"\n\n<img src=\"/assets/img/2024-06-22-10PythonScriptsforAutomationYouShouldTry_0.png\" />\n\n매일 반복되는 지루한 작업을 자동화하면 어떨까요? 엑셀 파일 편집, 이메일 보내기, WhatsApp 메시지 보내기 및 일상적인 작업을 처리하는 봇 만들기와 같은 작업을 자동화할 수 있습니다. 이 스크립트에서는 매뉴얼로 수행하는 매일 작업을 자동화할 수 있는 10가지 Python 스크립트를 소개합니다. 그러니 이 글을 즐겨찾기에 추가하고 시작해보세요.\n\n# 👉 AI 이미지 생성기\n\n상상한 것으로부터 아름다운 이미지를 만들고 싶다면 Getimg.ai API를 활용한 Python 스크립트가 있습니다. 이 API는 매달 100개의 무료 텍스트-이미지 크레딧을 제공하며 이를 활용하여 이미지를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n단순하고 효과적인 이미지를 생성해 보세요. 웹사이트에서 무료 API를 쉽게 얻을 수 있어요.😄\n\n```js\n# AI 이미지 생성기\n# pip install requests\n# pip install pillow\n\nimport requests\nimport base64\nfrom PIL import Image\nfrom io import BytesIO\n\n\ndef Imagine(prompt):\n\n    url = \"https://api.getimg.ai/v1/stable-diffusion-xl/text-to-image\"\n\n    payload = { \"prompt\": prompt }\n    headers = {\n        \"accept\": \"application/json\",\n        \"content-type\": \"application/json\",\n        \"authorization\": \"Bearer 여기에 API 키 입력\"\n    }\n\n    response = requests.post(url, json=payload, headers=headers)\n    content = response.json()\n\n    # 바이트를 이미지로 변환\n    image = content[\"image\"]\n    image = base64.b64decode(image)\n    img = Image.open(BytesIO(image))\n    \n    # 이미지 저장\n    img.save(\"Image.png\")\n\n\nImagine(\"아름다운 바다 위 석양과 생동적인 하늘\")    \n```\n\n# 👉 눈길을 끄는 이메일 전송\n\n일반적인 텍스트 이메일을 보내는 데 파이썬을 사용하고 계실 텐데, 이메일 마케팅에서와 같이 고급 이메일을 보낼 수도 있어요. 이 Python 스크립트는 Smtplib와 Email 모듈을 사용하여 HTML로 멋진 이메일을 만드는 방법을 보여줄 거예요.\n\n<div class=\"content-ad\"></div>\n\n아래 코드는 디자인 HTML을 자유롭게 해보세요😄.\n\n```js\n# 눈에 띄는 이메일 보내기\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nyour_email = \"mymail@xyz.com\"\nyour_password = \"mypass\"\nreceiver_email = \"me@xzy.com\"\nmsg = MIMEMultipart()\nmsg['From'] = your_email\nmsg['To'] = receiver_email\nmsg['Subject'] = \"Just a Test\"\n# HTML 내용 생성\nhtml = \"\"\"\\\n<html>\n  <body>\n    <h1 style=\"color:blue;\">이것은 테스트 이메일입니다</h1>\n    <p>이 이메일은 Python을 사용하여 전송되었습니다!</p>\n    <p>HTML 이메일에서 할 수 있는 멋진 기능들:</p>\n    <ul>\n      <li>CSS로 텍스트 스타일링</li>\n      <li>이미지 삽입</li>\n      <li>링크 추가</li>\n    </ul>\n    <p>최고의 문의,<br>Python 스크립트</p>\n  </body>\n</html>\n\"\"\"\n# 이메일에 HTML 내용 첨부\nmsg.attach(MIMEText(html, 'html'))\n# 이메일 보내기\nserver = smtplib.SMTP('smtp.gmail.com', 587)\nserver.starttls()\nserver.login(your_email, your_password)\nserver.sendmail(your_email, receiver_email, msg.as_string())\n# 서버 종료\nprint(\"이메일이 성공적으로 전송되었습니다!\")\nserver.quit()\n```\n\n# 👉 사진 압축\n\n사진 크기가 크고 품질을 유지한 채로 크기를 줄이고 싶다면 이 Python 스크립트가 맞을 것입니다. 이 스크립트는 이미지 처리 기술을 사용하여 이미지 크기를 줄이고 최상의 품질을 유지하는 훌륭한 모듈인 Imageio를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 사진 압축기\n# pip install imageio\nimport imageio\ndef Compress_Photo(image, quality=85):\n    img = imageio.imread(image)\n    \n    output_name = 'compressed.jpg'\n    imageio.imwrite(output_name, img, quality=quality)\n    \n    print(\"이미지 압축 완료...\")\nif __name__ == '__main__':\n    Compress_Photo('photo.jpg')\n```\n\n# 👉 Whatsapp Bot\n\n기본 시간에 자동으로 메시지를 보낼 수 있는 WhatsApp 봇이 필요하거나 번호로 대량 WhatsApp 마케팅 메시지를 보내고 싶으신가요? 이 파이썬 스크립트는 Pywhatkit를 사용하여 이 작업을 수행하는데 도움이 됩니다. 아래에 빌드하는 데 도움이 되는 네 가지 함수를 설명했습니다. 자유롭게 사용해보세요.\n\n- 대량 메시징에 편리함\n- 마케팅에 유용\n- 예약 메시징에 유용함\n- 기타 많은 기능\n\n\n<div class=\"content-ad\"></div>\n\n\n# Whatsapp Bot\n\n```python\n# Whatsapp Bot\n# pip install pywhatkit\nimport pywhatkit as whatbot\ndef send_message(ph, msg, hr, min):\n    whatbot.sendwhatmsg(ph, msg, hr, min)\n    print(\"Message sent successfully\")\ndef send_image(ph, img_file, caption):\n    whatbot.sendwhats_image(ph, img_file, caption)\n    print(\"Image sent successfully\")\ndef send_msg_to_group(group_name, msg):\n    whatbot.sendwhatmsg_to_group_instantly(group_name, msg)\n    print(\"Message sent successfully\")\ndef send_msg_to_group_delay(group_name, msg, hr, min):\n    whatbot.sendwhatmsg_to_group(group_name, msg, hr, min)\n    print(\"Message sent successfully\")\nsend_message(\"+1234567890\", \"Hello\", 12, 30)\nsend_image(\"+1234567890\", \"image.jpg\", \"This is an image\")\nsend_msg_to_group(\"Group Name\", \"Yoo!\")\nsend_msg_to_group_delay(\"Group Name\", \"Hello\", 12, 30)\n```\n\n# 👉 Excel Bot\n\nIf you want to read, write, and edit your Excel files programmatically, you can bookmark this automation script that uses the popular Openpyxl module, my favorite for automating any Excel task. This module helps you read, write, create, style the Excel file, and more. \n\nThe script below is a beginner's guide to automating your Excel tasks with the basics.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n# Excel Bot\n# pip install openpyxl\nimport openpyxl\nfrom openpyxl.styles import *\n# Excel 파일 로드\nwb = openpyxl.load_workbook(\"data.xlsx\")\n# 시트 로드\nsheet = wb.active\n# 특정 열 값 가져오기\nfor x in sheet[\"A\"]:\n    print(x.value)\n# 특정 행 값 가져오기\nfor x in sheet[1]:\n    print(x.value)\n# 특정 셀 값 가져오기\nprint(sheet[\"A1\"].value)\n# 특정 행과 열 값 가져오기\nprint(sheet.cell(row=1, column=1).value)\n# 최대 행과 열 값 가져오기\nprint(sheet.max_row)\nprint(sheet.max_column)\n# 쓰기 및 추가\nsheet[\"A1\"] = \"Hello\"\n# 특정 셀에 쓰기\nsheet.cell(row=2, column=2).value = \"World\"\n# 데이터를 시트에 추가\nsheet.append([1, 2, 3, 4, 5])\n# 셀 병합\nsheet.merge_cells(\"A1:B1\")\n# 글꼴 변경\nsheet[\"A1\"].font = Font(bold=True)\n# 셀 배경색 변경\nsheet[\"A1\"].fill = PatternFill(start_color=\"FF0000\", end_color=\"FF0000\", fill_type=\"solid\")\n# 파일 저장\nwb.save(\"data.xlsx\")\r\n```\n\n# 👉 간단한 PDF에서 텍스트 추출\n\nPDF 파일에서 텍스트를 가져오고 싶다면 PyMuPDF 모듈을 사용하는 아래 자동화 스크립트를 사용해보세요. 이 모듈은 PDF의 페이지를 반복하고 서식을 유지한 채 텍스트를 추출하는 가장 좋은 방법을 제공합니다. 아래에 사용할 수 있는 코드를 안내해드릴게요.\n\n```js\n# 간단한 PDF에서 텍스트 추출\n# pip install PyMuPDF\nimport fitz\ndef PDF_To_Text(pdf_File):\n    data = \"\"\n    pdf_doc = fitz.open(pdf_File)\n    for page in pdf_doc:\n        data += page.get_text(\"text\") \n    return data\nif __name__ == \"__main__\":\n    pdf_File = \"test.pdf\"\n    print(PDF_To_Text(pdf_File))\r\n```\n\n<div class=\"content-ad\"></div>\n\n# 👉 파이썬 비디오 레코더\n\n스크린 녹화 소프트웨어를 구입할 필요가 없어요. 여러분들만의 것을 만들 수 있으니까요. 이 자동화 스크립트는 OpenCV, Numpy 및 Pyautogui를 사용하여 화면을 최고 해상도로 60FPS로 녹화합니다. Fpsm 해상도 또는 시작 및 정지 버튼도 편집할 수 있어요. 아래 코드를 그대로 복사하고 사용하세요 😉.\n\n```js\n# 파이썬 스크린 레코더\n# pip install opencv-python\n# pip install numpy\n# pip install pyautogui\nimport cv2\nimport numpy as np\nimport pyautogui\n# 해상도 지정\nresolution = (1920, 1080)\n# 비디오 코덱 지정\ncodec = cv2.VideoWriter_fourcc(*\"XVID\")\nfilename = \"Recording.avi\"\nfps = 60.0\nout = cv2.VideoWriter(filename, codec, fps, resolution)\ncv2.namedWindow(\"실시간\", cv2.WINDOW_NORMAL)\ncv2.resizeWindow(\"실시간\", 480, 270)\nwhile True:\n    img = pyautogui.screenshot()\n    \n    frame = np.array(img)\n    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n    \n    out.write(frame)\n    cv2.imshow(\"실시간\", frame)\n    key = cv2.waitKey(1)\n    \n    if key == ord(\"s\"):\n        break\n    elif key == ord(\"r\"):\n        continue\n# 비디오 레코더 해제\nout.release()\ncv2.destroyAllWindows()\n```\n\n# 👉 맞춤법 검사 봇\n\n<div class=\"content-ad\"></div>\n\n온라인 맞춤법 검사기 웹 앱이 필요하지 않습니다. 이제 파이썬으로 직접 만들 수 있습니다. 맞춤법 검사를 위해 많은 텍스트가 있으면, 온라인 검사기에 하나하나 입력하는 대신 자동으로 처리할 수 있습니다. 이 파이썬 스크립트는 Autocorrect 모듈을 사용하여 맞춤법 검사 작업을 자동화할 것입니다.\n\n```python\n# 맞춤법 검사 봇\n# pip install autocorrect\nfrom autocorrect import Speller\n\ndef SpellChecker(text):\n    spell = Speller(lang='en')\n    corrected = spell(text)\n    print(f\"원본: {text}\")\n    print(f\"수정된 내용: {corrected}\")\n\nif __name__ == \"__main__\":\n    text = \"I am goinng to the markeet\"\n    SpellChecker(text)\n```\n\n# 👉 무료 클라우드 저장 공간\n\n이 자동화 스크립트는 Pydrive2 모듈을 사용하여 파일을 Google 드라이브에 저장할 것이며, 이는 클라우드 저장 공간처럼 활용할 수 있게 됩니다. 이 스크립트는 파일을 Google 드라이브에 업로드하거나 다운로드할 수 있도록 디자인되었습니다.\n\n<div class=\"content-ad\"></div>\n\n이 스크립트는 여러 파일이 있는 것을 상상할 때 유용합니다. 단 한 번 클릭으로 모든 파일을 Google Drive에 업로드하고 필요할 때 언제든지 다시 다운로드할 수 있습니다.\n\n```js\n# 무료 클라우드 저장소\n# pip install PyDrive2\nfrom pydrive2.auth import GoogleAuth\nfrom pydrive2.drive import GoogleDrive\ndef Upload_File(filename):\n    auth = GoogleAuth()\n    auth.LocalWebserverAuth()\n    drive = GoogleDrive(auth)\n    file = drive.CreateFile()\n    file.SetContentFile(filename)\n    file.Upload()\n    print(\"파일이 성공적으로 업로드되었습니다\")\ndef Download_File( filename):\n    auth = GoogleAuth()\n    auth.LocalWebserverAuth()\n    drive = GoogleDrive(auth)\n    # 검색으로 다운로드\n    file_list = drive.ListFile({'q': f\"title='{filename}'\"}).GetList()\n    for file in file_list:\n        file.GetContentFile(filename)\n        print(\"파일이 성공적으로 다운로드되었습니다\")\nif __name__ == \"__main__\":\n    Upload_File(\"Image.png\")\n    Download_File(\"Image.png\")\n```\n\n# 👉 속도 테스트 하기\n\n이 자동화 스크립트를 사용하여 인터넷 속도에 대해 최신 정보를 얻어보세요. 이 스크립트는 OKALA 속도 테스트에서 가져온 Speedtest 모듈을 사용하여 인터넷 연결의 다운로드, 업로드 및 핑을 테스트할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n내 인터넷 속도가 떨어지거나 핑이 불안할 때 알려주는 기능이 유용합니다. 지금 바로 시도해보세요! 😎\n\n```js\n# pip install speedtest-cli\nimport speedtest as st\ndef Speed_Test():\n    test = st.Speedtest()\n    # 다운로드 속도 확인\n    down_speed = test.download()\n    down_speed = round(down_speed / 10**6, 2)\n    print(\"다운로드 속도: \", down_speed)\n    # 업로드 속도 확인\n    up_speed = test.upload()\n    up_speed = round(up_speed / 10**6, 2)\n    print(\"업로드 속도: \", up_speed)\n    # 핑 확인\n    ping = test.results.ping\n    print(\"핑: \", ping)\nSpeed_Test()\n```\n\n# 👉 마지막으로\n\n글을 끝까지 읽어주셔서 감사합니다. 다음 프로젝트나 작업에 유용한 스크립트를 찾으셨기를 바랍니다. 공유하고 싶은 유용한 스크립트가 있으면 알려주세요.\n\n<div class=\"content-ad\"></div>\n\n아래는 시청자들이 가장 사랑하는 선택된 기사들입니다. 확인해보세요.\n\n# 간단명료한 언어로 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 추천하고 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서도 만나보세요: CoFeed | Differ\n- 더 많은 컨텐츠는 PlainEnglish.io에서 확인하세요","ogImage":{"url":"/assets/img/2024-06-22-10PythonScriptsforAutomationYouShouldTry_0.png"},"coverImage":"/assets/img/2024-06-22-10PythonScriptsforAutomationYouShouldTry_0.png","tag":["Tech"],"readingTime":10},{"title":"해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer TFT 사용법","description":"","date":"2024-06-22 02:49","slug":"2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions","content":"\n\n![2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_0](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_0.png)\n\n무료 샘플 eBook 장(chapters) 보기: [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\nTeachable.com에서 eBook 구매: $22.50 [여기](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서 인쇄판 구매: $65 [여기](https://a.co/d/25FVsMx)\n\n<div class=\"content-ad\"></div>\n\n우리는 Walmart, Target 및 Best Buy와 같은 소매업체에서 쇼핑을 합니다. Macy's, Nordstrom 및 Sears와 같은 백화점에서 물건을 사거나 Kroger, Safeway 및 Whole Foods와 같은 슈퍼마켓을 방문하기도 합니다. Amazon 및 eBay와 같은 온라인 소매업체에서 제품을 구매하기도 합니다. 우리는 제품이 정확한 시간에 문 앞으로 도착하기를 기대합니다. 제품이 품절일 경우 실망스럽게 여깁니다. 이러한 비즈니스들은 여러 가지 공통점이 있습니다: 수백 개에서 수천 개의 제품을 판매하며, 모두 계획 지침을 위해 좋은 데이터 과학 모델에 의존합니다. 이러한 종류의 데이터 과학 모델은 수천 개의 제품에 대한 예측을 제공해야 합니다. 예측은 하나의 기간만이 아니라 여러 기간이어야 합니다. 예측은 위험 완화를 위한 예측 구간을 가져야 합니다.\n\n이 챕터에서는 여러 제품, 여러 기간 및 확률적 예측을 제공할 수 있는 Transformer 기반의 예측 모델을 소개합니다. 그것은 Temporal Fusion Transformer (TFT) 모델입니다. TFT는 특정 작업에서 다른 모델보다 우수한 성능을 보여준 바 있습니다. 그 효율성, 유연성 및 해석 가능성은 다양한 응용 분야에서 가치 있는 자산으로 만듭니다. 그리고 2019년에 Lim, Arik, Loeff, Pfister에 의해 소개된 것처럼 그 제목 또한 흥미로워합니다. \"Temporal\"은 시간 관련 데이터나 시간 종속성이 있는 순차 데이터를 처리한다는 것을 나타냅니다. “Fusion”은 여러 데이터 소스나 특성에서 정보를 혼합하는 설계를 포착합니다. 그리고 “Transformer”는 Transformer 기반 모델이기 때문에 사용되었습니다. 문헌 \"Attention is All You Need\" (2017)의 Transformer 모델은 모든 현대 대형 언어 모델 (LLM)의 백본입니다. 이전 챕터인 \"RNN/LSTM에서 Temporal Fusion Transformers 및 Lag-Llama\"를 참고하실 수 있습니다.\n\n오늘날의 데이터 과학 모델은 복잡한 기계이며, 아마도 아직 완전히 알아내기 어려운 미로의 영아 단계에 있을지도 모릅니다. 한편, 데이터 과학 커뮤니티는 모델의 투명성과 해석 가능성을 요구합니다. 모델이 예측을 어떻게 하는지에 대한 질문을 합니다. 모델 해석 가능성은 책 \"The explainable AI\"에서 다루었듯이 책 \"An Explanation for eXplainable AI\"에서 다루었듯이 책 \"An Explanation for eXplainable AI\"에서 다루었듯이 책 \"An Explanation for eXplainable AI\" 모델의 책임 있는 예측을 보장하기 위한 활발한 연구 분야입니다. TFT의 주요 특징인 모델 해석 가능성은 모델이 예측을 어떻게 하는지에 대한 통찰력을 제공합니다. 이는 미래 값을 예측하는 데 가장 영향력 있는 과거 시간 단계가 무엇인지 설명해줍니다. 코드 예제에서 나중에 보게 될 변수 중요도 플롯은 모델이 예측하는 방식을 설명합니다.\n\n이 챕터에서는 TFT 모델을 구축하기 위한 실제 데이터 케이스를 따라가보겠습니다. 다음 주제들을 다룰 예정입니다:\n\n<div class=\"content-ad\"></div>\n\n- 글로벌 시계열 모델 구축\n- TFT의 구조\n- 소프트웨어 요구 사항\n- 데이터\n- 데이터 Darts Python 라이브러리로 변환\n- 모델링\n- 예측\n- 그래프 그리기\n- 모델 해석 가능성\n\n이 장을 완료하면 TFT를 미래 사례에 적용하고 TFT의 혜택을 설명할 수 있을 것입니다.\n\n글로벌 시계열 모델 구축\n\nWalmart이나 Amazon의 수천 가지 제품은 수천 개의 시계열을 의미합니다. 모든 시계열을 함께 모델링하면 모델은 전역 모델입니다. 각 시계열을 단일 변수 시계열 모델로 모델링하는 경우 지역 모델입니다. 실제로 제품이나 서비스의 계층구조에 따라 별도의 글로벌 모델을 구축할 수 있습니다. 각 글로벌 모델은 제품 범주를 제공하며 관련 제품이 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n글로벌 모델의 장점은 무엇인가요? 글로벌 모델은 여러 시계열 간의 공통 패턴과 관계를 포착할 수 있어 개별 시계열의 예측 정확도를 향상시킬 수 있습니다. 글로벌 모델은 새로운 제품과 같이 데이터가 제한적인 경우 유용할 수 있습니다. 글로벌 모델은 새 제품이 동일 범주 내 유사한 제품의 기능을 활용할 수 있도록 합니다. 한편 로컬 모델은 단일 시계열에 훈련된 것이기 때문에 독특한 패턴을 포착할 수 있습니다. 시계열 간에 상당한 차이가 있는 경우 로컬 모델이 유용할 수 있습니다.\n\nTemporal Fusion Transformer(TFT) 모델은 글로벌 모델로, 각 시계열을 독립적으로 모델링하는 대신 다른 시계열 간의 관계를 모델링합니다. TFT의 아이디어는 시계열 간의 관계를 모든 시리즈에 걸친 기본 패턴과 트렌드를 포착하는 공유 표현으로 캡처할 수 있다는 것입니다. 모든 시리즈의 결합 분포를 모델링함으로써 TFT는 단일 시계열만 고려하는 로컬 모델로는 모델링하기 어려운 복잡한 패턴과 관계를 포착할 수 있습니다.\n\nTFT 아키텍처에 대한 다음 섹션이 상당히 길다는 점을 알려드리고 싶습니다. 대신 모델링을 학습할 \"소프트웨어 요구사항\" 섹션으로 건너뛰어보세요. 이후 다시 TFT 아키텍처로 돌아오셔도 됩니다.\n\nTFT 아키텍처\n\n<div class=\"content-ad\"></div>\n\n(A) 도표는 원본 논문의 TFT 아키텍처를 보여줍니다 [1]. 이 다이어그램이 조금 복잡해 보일 수 있어요. 하나씩 차근차근 블록을 설명해 드릴게요.\n\n![이미지](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_1.png)\n\n(A) 도표는 아래에서부터 읽어야 해요. 먼저 아래의 입력값부터 시작해요. 그 다음으로 'Variable Selection' 상자를 위로 한 단계 올려 보세요. 그 다음으로 'Encoders' 상자를 위로 한 단계 올려가는 식으로, 계속 해 보세요. 최종 출력은 맨 위에 있는 분위수 예측입니다.\n\n입력 데이터\n\n<div class=\"content-ad\"></div>\n\n시계열 데이터는 크게 세 가지 유형으로 그룹화될 수 있어요:\n\n- 첫 번째 그룹은 시간이 지나도 변하지 않는 정적 메타데이터입니다. 예를 들어 상점 위치나 제품 카테고리와 같은 정보가 여기에 속해요.\n- 두 번째 그룹은 k 기간 전의 입력 데이터에 해당해요.\n- 세 번째 그룹은 공휴일 플래그, 요일 또는 월, 예정된 프로모션 이벤트와 같은 다양한 공변수에 해당해요. 우리는 미래를 예측할 것이기 때문에 이러한 공변수들은 t+𝛕 기간까지 준비되어 있거나 알려져 있어야 해요.\n\n변수 선택 네트워크\n\n모든 입력 데이터가 목표 데이터를 예측하는 데 필요하지는 않아요. 변수 선택 네트워크(VSNs)는 어떤 입력 데이터가 예측에 가장 관련성이 있는지를 결정해요. 이는 TFT의 직관적인 설계입니다. VSNs는 각 시간 단계마다 예측에 가장 관련된 입력 데이터 하위 집합을 동적으로 선택해요. 이 동적 기능 선택 메커니즘은 모델이 예측 정확도를 향상시킬 수 있게 해줘요. 그러나 미리 어떤 입력이 목표와 관련이 있는지 또는 선형인지 비선형인지 관계가 명확하지 않아요. 어떻게 관련 입력을 식별할 수 있을까요? VSNs는 모델이 필요에 따라 유연하게 입력 변수를 선택하고 정보를 제거할 수 있게 해줘요. (B) 그림에 Variable Selection Network가 나와요. 각 입력 특징에 대해 게이트된 잔차 네트워크가 있어요. 다이어그램의 \"변수 선택 가중치\"는 변수 중요도에 대한 가중치입니다. 가중치는 훈련 과정 중에 결정돼요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_2.png\" />\n\nGRN을 이해해 봅시다.\n\n게이트된 잔여 네트워크 (GRN)\n\n게이트된 잔여 네트워크 (GRN)는 TFT 전반에서 복잡한 시계열 데이터의 시간적 패턴 및 의존성을 캡처하기 위해 사용됩니다. GRN은 게이트 메커니즘과 잔여 연결을 가지고 있습니다. 게이팅 메커니즘을 통해 모델은 각 레이어에서 다른 특징들의 중요성을 적응적으로 조절할 수 있습니다. 이러한 게이팅 함수는 일반적으로 시그모이드 활성화 함수의 형태를 취하며 0과 1 사이의 값을 생성합니다. 이들은 이전 레이어에서 얼마나 많은 정보가 다음 레이어로 전달되어야 하는지를 결정하며, 필요에 따라 정보를 선택적으로 보존하거나 버릴 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Temporal Fusion Transformer for Interpretable Time Series Predictions](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_3.png)\n\nFigure (C) has a dashed line for the residual connection. The output of the previous layer(s) is added to the output of the current layer. This mechanism helps address the vanishing gradient problem. Also, with the additions of the outputs of previous and subsequent layers through residual connections, the GRN has mixed the input features and can capture the non-linear interactions between features. That’s why the name “Fusion” was coined.\n\nAfter explaining the row of VSNs in Figure (A), let’s move up one row to the Static Covariate Encoders, as shown in Figure (D).\n\n![Temporal Fusion Transformer for Interpretable Time Series Predictions](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n정적 공변량 인코더\n\n그림 (D)의 정적 공변량 인코더는 범주형 정적 공변량을 숫자로 변환합니다. 이 임베딩 프로세스는 자연어 처리의 단어 임베딩과 유사합니다. 각 범주형 변수는 임베딩 공간에 있는 고차원 벡터에 매핑됩니다. 이 임베딩 프로세스는 다양한 범주 간 의미 관계를 포착합니다. 텍스트 표현과 단어 임베딩에 대한 친절한 설명을 제공하는 책 \"The Handbook of NLP with Gensim\" [3]의 1장에서 3장을 읽는 것이 좋습니다.\n\nLSTM 인코더\n\n18장 \"From RNN/LSTM to Temporal Fusion Transformers and Lag-Llama\"에서 우리는 시계열 데이터에 대해 Transformer 모델을 직접 사용하지 않는 이유를 설명했습니다. 시계열 데이터와 언어 데이터는 다르기 때문입니다. 시계열 데이터를 어떻게 인코딩할까요? 시계열 데이터는 독특한 시간적 종속성과 패턴을 가지고 있습니다. 그림 (D)에 나타난 TFT의 인코더는 LSTM(Long Short-Term Memory) 네트워크입니다. LSTM 인코더는 순차 데이터를 효과적으로 모델링하는 능력으로 알려진 순환 신경망(RNN) 아키텍처의 일종입니다. LSTM 인코더가 입력 시계열 데이터를 처리할 때, 관련 특징을 추출하고 데이터에 있는 시간적 동적의 의미 있는 표현을 학습합니다.\n\n<div class=\"content-ad\"></div>\n\n정적 공변량 인코더에서 LSTM 인코더로 향하는 화살표에 대해 알아보셨을 겁니다. Figure (D)에서 보이는 노란색 화살표는 정적 공변량의 수치 표현이 LSTM 인코더 내의 시간적 특성과 연결된다는 것을 의미합니다. 이 연결 과정은 정적 공변량과 시간적 특성 모두로부터 정보를 결합합니다. 이는 모델이 정확한 예측을 위해 시간적 및 정적 정보를 모두 활용할 수 있도록 도와줍니다. 예를 들어 코드 예제에서 정적 공변량 중 하나인 매장(store)이 있습니다. 매장의 매출은 매장 위치에 따라 다를 수 있습니다. 매장 정보를 과거 시간적 특성과 결합하는 것은 모델이 매장별 매출을 정확하게 예측할 수 있도록 유연성을 제공합니다.\n\nLSTM 디코더\n\nLSTM 디코더는 Figure (D)의 오른쪽에 있습니다. 왼쪽 화살표에서 LSTM 인코더의 정보를 가져옵니다. 또한 앞으로의 𝛕 기간을 위한 공변량이 담긴 아래쪽 화살표에서도 정보를 받습니다. LSTM 인코더와 마찬가지로 LSTM 디코더는 데이터 내의 시간 의존성과 패턴을 캡처할 수 있는 능력을 갖추고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 Figure (E)에 나와 있는 Figure (A)의 정적 보강으로 이동합시다.\n\n![image](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_5.png)\n\nGRNs를 활용한 정적 보강\n\nLSTM 인코더로부터 입력을 받는 GRN 세트와 LSTM 디코더로부터 입력을 받는 다른 GRN 세트가 있습니다. 두 세트의 GRN은 벡터 형태의 정적 공변량도 입력으로 사용합니다. 다시 말해, GRN의 정적 보강은 TFT가 시간 의존성과 정적 공변량 정보를 결합하여 보다 정확한 예측을 할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 Figure (A)에 표시된 Figure (F)의 Temporal Self-Attention으로 이동해 보겠습니다.\n\n![이미지](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_6.png)\n\nTemporal Multi-head Self-Attention\n\nTemporal self-attention 메커니즘은 모델이 동일한 입력 시퀀스에서 다른 시간 단계에 주의를 기울이도록하고 그들 사이의 복잡한 관계를 학습할 수 있게 합니다. Temporal self-attention 메커니즘은 transformer 아키텍처에서 사용되는 표준 self-attention 메커니즘과 유사하게 작동합니다. 입력 시퀀스의 각 시간 단계에서 temporal self-attention 메커니즘은 입력 시퀀스를 인코딩할 때 각 시간 단계에 얼마나 집중해야하는지 결정하는 attention weights를 계산합니다. 예측 작업에 더 관련이 있거나 정보를 전달하는 시간 단계는 더 높은 attention weights를 받고, 덜 관련이있는 시간 단계는 더 낮은 attention weights를 받습니다. 이러한 weights는 TFT가 모델 해석력을 수행하는 데 필요한 구성 요소입니다. 코드 예제에서 self-attention weights를 시각화하는 방법을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n셀프 어텐션 매커니즘은 멀티헤드입니다. 이것은 모델이 입력 시퀀스의 다양한 측면에 동시에 주의를 기울일 수 있도록 합니다. 단일 셀프 어텐션은 동일한 시계열 세그먼트 내의 일부에 주의를 기울이는 것을 의미합니다. 마찬가지로, 한 번만 주의를 계산하는 대신 멀티헤드는 모델이 여러 번 동시에 주의를 계산할 수 있도록 합니다. 각 어텐션 헤드는 입력 시퀀스 내에서 다른 유형의 관계를 포착하기 위한 고유한 어텐션 가중치 집합을 학습합니다. 여러 어텐션 헤드를 사용함으로써 모델은 다양한 패턴과 종속성을 더 효과적으로 포착할 수 있습니다.\n\n그 다음, Figure (A)에 있는 Position-wise Feed-forward Network로 이동해 보겠습니다. Figure (G)에 표시된 것입니다.\n\n![이미지](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_7.png)\n\nPosition-wise Feed-forward Network\n\n<div class=\"content-ad\"></div>\n\n전통적인 피드포워드 네트워크와 달리 TFT(Temporary Fluctuations in Temperature)의 위치별 FFN은 입력 시퀀스의 각 위치를 독립적으로 처리합니다. 이 위치별 처리는 모델이 입력 시퀀스 내에서 위치별 정보 및 상호 작용을 포착할 수 있도록 합니다. 피드포워드 네트워크는 비선형 활성화 함수(예: ReLU 또는 GELU)를 적용합니다.\n\n추가 & 정규화\n\n\"추가 & 정규화\" 블록이 몇 개 있습니다. \"추가 & 정규화\" 기술은 TFT 모델의 교육 안정성과 수렴 속도를 향상시킵니다. \"추가\" 작업의 목적은 모델이 입력으로부터 원래 정보를 유지하면서 출력으로부터 변환된 정보를 통합하는 것입니다. 레이어의 출력에 입력을 추가함으로써 모델은 원래 정보가 변환 과정 전체에서 보존되도록 보장할 수 있습니다. 이는 기울기 소멸 문제를 완화하는 데 도움이 됩니다.\n\n다중 기간에 대한 분위 회귀 출력\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 모델은 동시에 여러 미래 시간 단계에 대한 분위수 예측을 생성합니다. 분위 회귀는 다양한 불확실성 수준을 양적화하기 위해 여러 분위수(예: 10, 50, 90 백분위수)를 추정합니다. 그림 (D)에 설명된 것처럼, 이 부분은 \"다중 기간 확률적 예측을 위한 선형 회귀\"와 \"다중 기간 시계열 확률적 예측을 위한 Tree-based XGB, LightGBM 및 CatBoost 모델\"의 분위 회귀 기법과 동일합니다.\n\n![이미지](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_8.png)\n\n최적화\n\nTFT의 최적화 알고리즘은 표준 신경망 알고리즘입니다. 확률적 경사 하강법(SGD)이나 그 변형을 사용합니다. 실제 값과 예측 값 사이의 손실 함수를 정의합니다. 역전파를 사용하여 모델 매개변수에 대한 손실의 그래디언트를 계산합니다. 그래디언트는 학습률로 모수를 업데이트하는 데 사용되며, 학습률은 단계 크기를 결정합니다. 미니 배치 학습은 학습 속도를 높이고 일반화를 향상시키기 위해 사용됩니다. 오버피팅을 방지하기 위해 L1 또는 L2 정칙화와 같은 정칙화 기법을 적용할 수 있습니다. 학습률 스케줄링을 통해 학습률을 시간에 따라 조정합니다. 최적화 알고리즘은 이러한 단계를 반복적으로 수행하며 최대 에폭 수나 원하는 성능 수준과 같은 중지 기준을 충족할 때까지 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n실제 데이터 케이스를 사용하여 TFT 모델을 구축해 보겠습니다. Python 노트북은 이 Github 링크를 통해 다운로드할 수 있습니다.\n\n소프트웨어 요구 사항\n\nDarts Python 라이브러리를 설치해야 합니다. 이 책은 Darts 데이터 형식을 설명하는 \"시계열 데이터 형식을 쉽게 만드는 방법\" 장을 별도로 제공합니다. 또한 이 책은 다음 장에서 Darts를 자세히 설명합니다:\n\n- 시계열 데이터 형식을 쉽게 만드는 방법\n- 다중 기간 확률 예측을 위한 선형 회귀\n- 다중 기간 시계열 확률 예측을 위한 Tree-based XGB, LightGBM 및 CatBoost 모델\n- 응용: 아마존의 DeepAR을 활용한 주식 예측\n\n<div class=\"content-ad\"></div>\n\n필요한 라이브러리를 가져오겠습니다.\n\n```js\nimport pandas as pd\nimport numpy as np\nfrom datetime import timedelta\nimport matplotlib.pyplot as plt\n\nfrom darts import TimeSeries\nfrom darts.dataprocessing.pipeline import Pipeline\nfrom darts.models import TFTModel\nfrom darts.dataprocessing.transformers import Scaler\nfrom darts.utils.timeseries_generation import datetime_attribute_timeseries\nfrom darts.utils.likelihood_models import QuantileRegression\nfrom darts.dataprocessing.transformers import StaticCovariatesTransformer, MissingValuesFiller\n```\n\n데이터 준비\n\n에콰도르의 Favorita 스토어에서의 상점 매출 데이터를 사용할 것입니다. 이 데이터셋은 Kaggle에서 제공됩니다. 데이터셋에는 체인 스토어에서 판매되는 수천 가지 제품 군이 포함되어 있습니다. 훈련 데이터에는 날짜, 상점 및 제품 정보, 해당 제품이 프로모션 중인지 여부, 그리고 매출 숫자가 포함되어 있습니다. 추가 파일에는 모델을 구축하는 데 유용할 수 있는 보조 정보가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래 코드는 여러 파일을 병합합니다.\n\n```js\n# CSV 파일 읽기\npath = 'data/store-sales-time-series-forecasting'\ndata = pd.read_csv(path + '/train.csv', delimiter=\",\")\nholidays = pd.read_csv(path + '/holidays_events.csv', delimiter=\",\").drop('type', axis=1)\nstores = pd.read_csv(path + '/stores.csv', delimiter=\",\")\ntransactions = pd.read_csv(path + '/transactions.csv', delimiter=\",\")\n# 파일 병합\nholidays['holiday_flag'] = 1\ndata = data.merge(holidays, on='date', how='left')\ndata = data.merge(stores, on='store_nbr', how='left')\ndata = data[data['date'] != '2013-01-01'] # 잘못된 데이터\ndata = data.merge(transactions, on=['date', 'store_nbr'], how='left')\n# 기본 데이터 조작\ndata['date'] = pd.to_datetime(data[\"date\"])\ndata = data.drop_duplicates(subset=['date','store_nbr', 'family'], keep='last') \ndata.loc[data['holiday_flag'].isna(),'holiday_flag'] = 0\ndata['year'] = data['date'].dt.year \ndata.columns\n```\n\n데이터에는 다음과 같은 열이 있습니다:\n\n- store_nbr: 상점 번호\n- family: 제품 패밀리\n- sales: 상품 패밀리의 상점 및 날짜별 총 매출\n- onpromotion: 상품 패밀리 중 특정 날짜에 할인된 제품의 총 수\n- holiday_flag: 휴일 플래그\n\n<div class=\"content-ad\"></div>\n\n데이터에는 각 매장의 제품이 시계열 데이터이기 때문에 수백 개의 시계열이 있습니다. 설명을 위해, 우리는 전역 모델을 구축하기 위해 네 개의 가장 큰 매장과 네 개의 가장 큰 제품 카테고리를 선택할 것입니다. 앞서 언급한 코드는 16개의 시계열 데이터를 선택한 다음 이를 훈련 및 테스트 데이터로 분할합니다.\n\n데이터 변환을 Darts로\n\n여러 시계열을 위한 전역 모델을 구축하려면 다수의 시계열을 포함하는 데이터를 구조화해야 합니다. 이는 \"Time Series Data Formats Made Easy\" 장에서 설명된대로 Darts에 의해 편리하게 처리됩니다. 시계열의 가장 세부 레벨은 매장 및 제품 카테고리 수준이므로 \"store_nbr\" 및 \"family\"로 그룹화를 지정합니다. 이 두 변수는 단순히 그룹화 변수뿐만 아니라 예측 변수로도 사용될 수 있습니다. 예를 들어 특정 매장이나 제품 카테고리가 다른 매장이나 제품 카테고리보다 더 많이 팔릴 수 있습니다. 이 두 변수는 매장 및 제품별 정보를 포착할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nTIME_COL = \"date\"\nTARGET = \"sales\"\nSTATIC_COLS = ['store_nbr', 'family'] \nFREQ = \"D\"\nFORECAST_HORIZON = test['date'].nunique() \nCOVARIATES = ['onpromotion','holiday_flag']\nSCALER = Scaler()\nTRANSFORMER = StaticCovariatesTransformer()\nPIPELINE = Pipeline([SCALER, TRANSFORMER])\n```\n\n타겟은 \"sales\"이고, 공변량은 \"onpromotion\"과 \"holiday_flag\"입니다. Darts의 .from_group_dataframe() 함수는 누락된 값이나 값을 외삽화할 수 있는 편리한 도구입니다.\n\n```js\n# 학습 및 테스트 데이터셋을 읽고 변환합니다\ntrain_darts = TimeSeries.from_group_dataframe(df=train, \n                                              group_cols=STATIC_COLS, \n                                              time_col=TIME_COL, \n                                              value_cols=TARGET, \n                                              freq=FREQ, \n                                              fill_missing_dates=True, \n                                              fillna_value=0)\ntest_darts = TimeSeries.from_group_dataframe(df=test, \n                                             group_cols=GROUP_COLS, \n                                             time_col=TIME_COL, \n                                             value_cols=TARGET, \n                                             freq=FREQ, \n                                             fill_missing_dates=True, \n                                             fillna_value=0)\n\n[len(train_darts[0]), len(test_darts[0])] # [561, 32]는 학습 데이터와 테스트 데이터의 기간 수입니다\n```\n\n시간 인덱스에는 많은 숨은 정보가 포함되어 있습니다. 특정 이벤트가 특정 날에 발생할 수 있습니다. 예를 들어, 고객들은 주말에 일반적으로 더 많이 쇼핑하며, 여름 달은 보통 야외 제품에 대한 수요가 더 많습니다. 시간 인덱스를 사용하여 더 많은 공변량을 생성할 수 있습니다. 앞에서 제공한 코드는 연도의 12개월과 52주에 대한 지표를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncreate_covariates = []\nfor ts in train_darts:\n    # 월과 주를 공선변수로 추가\n    covariate = datetime_attribute_timeseries(\n        ts,\n        attribute=\"month\",\n        one_hot=True,\n        cyclic=False,\n        add_length=FORECAST_HORIZON,\n    )\n    covariate = covariate.stack(\n        datetime_attribute_timeseries(\n            ts,\n            attribute=\"week\",\n            one_hot=True,\n            cyclic=False,\n            add_length=FORECAST_HORIZON,\n        )\n    )\n    store = ts.static_covariates['store_nbr'].item()\n    family = ts.static_covariates['family'].item()\n    \n    # 공선변수 생성\n    other_cov = TimeSeries.from_dataframe(data[(data['store_nbr'] == store) & (data['family'] == family)], time_col=TIME_COL, value_cols=COVARIATES, freq=FREQ, fill_missing_dates=True)\n    covariate = covariate.stack(MissingValuesFiller().transform(other_cov))\n\n    create_covariates.append(covariate)\n\ncreate_covariates[0].columns\n\n#Index(['month_0', 'month_1', 'month_2', 'month_3', 'month_4', 'month_5',\n#       'month_6', 'month_7', 'month_8', 'month_9', 'month_10', 'month_11',\n#       'week_0', 'week_1', 'week_2', 'week_3', 'week_4', 'week_5', 'week_6',\n#       'week_7', 'week_8', 'week_9', 'week_10', 'week_11', 'week_12',\n#       'week_13', 'week_14', 'week_15', 'week_16', 'week_17', 'week_18',\n#       'week_19', 'week_20', 'week_21', 'week_22', 'week_23', 'week_24',\n#       'week_25', 'week_26', 'week_27', 'week_28', 'week_29', 'week_30',\n#       'week_31', 'week_32', 'week_33', 'week_34', 'week_35', 'week_36',\n#       'week_37', 'week_38', 'week_39', 'week_40', 'week_41', 'week_42',\n#       'week_43', 'week_44', 'week_45', 'week_46', 'week_47', 'week_48',\n#       'week_49', 'week_50', 'week_51', 'onpromotion', 'holiday_flag'],\n#      dtype='object', name='component')\n```\n\n어떻게 보이나요? Darts 데이터를 다시 Pandas 데이터 프레임으로 변환하여 확인할 수 있습니다. 이들은 단순한 이진 지표들입니다.\n\n```js\nTimeSeries.pd_dataframe(create_covariates[0]).tail()\n```\n\n<img src=\"/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_9.png\" />\n\n<div class=\"content-ad\"></div>\n\n\n마찬가지로, 대상 데이터 \"sales\"를 Pandas 데이터 프레임으로 변환하여 살펴볼 수 있습니다:\n\n```js\nTimeSeries.pd_dataframe(train_darts[15]).tail()\n```\n\n![이미지](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_10.png)\n\n모델링 전에 데이터를 표준화하려고 합니다. 이는 많은 데이터 과학 모델에서 흔한 실천법입니다. 앞의 코드는 훈련 데이터에 따라 스케일러를 작성합니다. 이 스케일러는 나중에 테스트 데이터에 적용될 것입니다. 입문자가 훈련 및 테스트 데이터를 독립적으로 스케일링하는 실수를 저지를 수 있습니다. 이러한 오류를 피하고 싶다면 \"경력에 영향을 줄 수 있는 치명적인 모델링 실수를 피하세요\"라는 게시물을 참조할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 데이터 스케일링 및 정적 공변량 변환\n# PIPELINE에 SCALER이 포함되어 있기 때문에 SCALER이 먼저 온다.\ntrain_transformed = PIPELINE.fit_transform(train_darts)\n# 공변량 스케일링\ncovariates_transformed = SCALER.fit_transform(create_covariates)\n```\n\n이제 모델을 구축해 봅시다.\n\n모델링\n\n모델 선언은 일반 신경망 하이퍼파라미터와 시계열 특정 하이퍼파라미터를 포함합니다. 가독성을 높이기 위해 하이퍼파라미터를 다음과 같이 그룹화했습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 데이터 준비를 위한 하이퍼파라미터: 이 그룹은 코드에서 input_chunk_length와 output_chunk_length를 가리킵니다. 이들은 단변량 시리즈에서 샘플을 생성하는 데 관련됩니다. 설명을 위해, 도식 (G)은 y0부터 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플은 입력 청크와 출력 청크를 포함합니다. 입력 청크의 길이가 5이고 출력 청크의 길이가 2라고 가정합시다. 첫 번째 샘플은 입력 청크로 y0 ~ y4를, 출력 청크로 y5, y6을 갖습니다. 시리즈를 따라 창이 이동하여 시리즈의 끝까지 샘플을 생성합니다.\n\n![이미지](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_11.png)\n\n- 시계열을 위한 하이퍼파라미터: 예측 구간을 생성하기 위해 분위 회귀를 사용할 것입니다. 이것은 모델이 예측 불확실성을 생성하는 데 중요한 기능입니다.\n- 모델 아키텍처를 위한 하이퍼파라미터: 숨겨진 레이어 수, 어텐션 헤드 수, LSTM 레이어 수를 포함한 모델 스펙을 다양하게 조정할 수 있습니다.\n- 최적화를 위한 하이퍼파라미터: 이는 표준 신경망 하이퍼파라미터입니다. 이러한 하이퍼파라미터에 대한 설명은 별지에 추가했습니다.\n\n```js\nTFT_params = {\n    # 데이터 준비를 위한 하이퍼파라미터\n    \"input_chunk_length\": 52, # 과거를 바라보는 주 수 \n    \"output_chunk_length\": FORECAST_HORIZON,\n\n    # 시계열 하이퍼파라미터\n    \"likelihood\": QuantileRegression(quantiles=[0.25, 0.5, 0.75]),\n    \n    # 모델 아키텍처를 위한 하이퍼파라미터\n    \"use_static_covariates\": True,\n    \"hidden_size\": 4,\n    \"lstm_layers\": 4,\n    \"num_attention_heads\": 4,\n\n    # 최적화를 위한 하이퍼파라미터\n    \"dropout\": 0.1,\n    \"batch_size\": 16,\n    \"n_epochs\": 60,\n    \"random_state\": 42,\n    \"optimizer_kwargs\": {\"lr\": 1e-3},\n}\n\ntft_model = TFTModel(**TFT_params)\ntft_model.fit(train_transformed, # 훈련 기간\n              future_covariates=covariates_transformed, # 전체 기간\n              verbose=False)\n```  \n\n<div class=\"content-ad\"></div>\n\n모델이 훈련되면 예측에 사용할 것입니다.\n\n예측\n\n예측 단계는 간단합니다. 기억해야 할 한 가지는 \"future_covariates\"입니다. 이미 미래 공변량을 포함하고 있으며, 월 1-12, 주 1-52 및 휴일 플래그와 같은 다른 알려진 공변량을 포함합니다. 또한, 외부에서 가져올 \"onpromotion\" 플래그와 같은 여러 다른 공변량도 포함됩니다.\n\n예측된 값은 스케일된 값입니다. 스케일된 값을 다시 원래 스케일로 역변환하는 것을 기억해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 스케일링된 예측값을 가져옵니다\nscaled_pred = tft_model.predict(n=FORECAST_HORIZON, \n                                series=train_transformed, # 훈련 기간\n                                num_samples=50, \n                                future_covariates=covariates_transformed # 전체 기간\n                               )\n\n# 스케일링된 예측값을 일반 스케일로 변환합니다\nprediction = PIPELINE.inverse_transform(scaled_pred)\n```\n\n지금까지 우리는 우리가 다루는 글로벌 모델을 완성하고 불확실성을 고려한 예측을 제공했습니다.\n\n플로팅\n\n실제 매출, 예상 매출 및 25% 및 75%의 예측 구간을 플롯팅해 봅시다. 아래 함수는 상점의 4가지 제품 패밀리를 플롯팅합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```python\ndef plot_it():\n    fig, axs = plt.subplots(2, 2, figsize=(10, 6), dpi=100)\n    ax0 = axs[0,0]\n    ax1 = axs[0,1]\n    ax2 = axs[1,0]\n    ax3 = axs[1,1]\n    \n    plt.suptitle(\"Store:\" +  str(store) , fontsize=12)\n    \n    val0[: pred0.end_time()].plot(ax=ax0, label=\"actual\", marker='o', linewidth=1)\n    pred0.plot(ax = ax0, low_quantile=0.25, high_quantile=0.75, label=\"prediction\", marker='o',linewidth=1,alpha=0.2 )\n    ax0.title.set_text('Product: '+family[0])\n    \n    val1[: pred1.end_time()].plot(ax=ax1, label=\"actual\", marker='o', linewidth=1)\n    pred1.plot(ax = ax1, low_quantile=0.25, high_quantile=0.75, label=\"prediction\", marker='o',linewidth=1,alpha=0.2 )\n    ax1.title.set_text('Product: '+family[1])\n    \n    val2[: pred2.end_time()].plot(ax=ax2, label=\"actual\", marker='o', linewidth=1)\n    pred2.plot(ax = ax2, low_quantile=0.25, high_quantile=0.75, label=\"prediction\", marker='o',linewidth=1,alpha=0.2 )\n    ax2.title.set_text('Product: '+family[2])\n    \n    val3[: pred3.end_time()].plot(ax=ax3, label=\"actual\", marker='o', linewidth=1)\n    pred3.plot(ax = ax3, low_quantile=0.25, high_quantile=0.75, label=\"prediction\", marker='o',linewidth=1,alpha=0.2 )\n    ax3.title.set_text('Product: '+family[3])\n    fig.tight_layout()\n    plt.show()\n\n\nstore_nbr = [44, 45, 47, 3]\nfamily = ['GROCERY I', 'BEVERAGES', 'PRODUCE', 'CLEANING']\n\nfor i in range(0,16,4):\n    k = int(i/4)\n    store = store_nbr[k]\n    pred0 = prediction[i]\n    pred1 = prediction[i+1]\n    pred2 = prediction[i+2]\n    pred3 = prediction[i+3]\n    val0 = test_darts[i]\n    val1 = test_darts[i+1]\n    val2 = test_darts[i+2]\n    val3 = test_darts[i+3]\n    plot_it()\n```\n\n아래 4개의 그림은 가게 44와 45의 GroceryI 및 Beverages 제품군에 대한 실제 값과 예측 값입니다.\n\n![image](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_12.png)\n\n![image](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_13.png)\n\n\n<div class=\"content-ad\"></div>\n\nTFT의 중요한 기능 중 하나는 모델 해석 가능성입니다. 함께 알아봐요.\n\n모델 해석 가능성\n\nTFT는 자기 주의 메커니즘을 통해 해석 가능성을 제공합니다. 자기 주의 메커니즘은 예측을 할 때 입력 시퀀스의 서로 다른 부분에 주의를 기울입니다. 특정 기능이나 시간 단계에 주의를 기울여 모델이 예측 과정에서 상대적인 중요성을 강조할 수 있습니다. 이를 통해 예측을 이끄는 근본적인 요소를 이해하고 데이터에 대한 통찰력을 얻을 수 있습니다. 이를 수행하기 위해 TFTExplainer() 함수를 사용할 것입니다.\n\n```js\nfrom darts.explainability import TFTExplainer\n\nexplainer = TFTExplainer(\n    tft_model,\n    background_series=train_transformed[1],\n    background_future_covariates=dynamic_covariates_transformed[1],\n)\nexplainability_result = explainer.explain()\n```\n\n<div class=\"content-ad\"></div>\n\n몇 분은 \"explainer\" 함수 이름이 SHAP 값의 explainer 함수와 달라 보일 수 있습니다. 비록 다른 기능을 하지만, 모델 자체를 설명하는 데 동일한 목표를 가지고 있습니다. SHAP explainer나 기타 기술은 \"설명 가능한 AI에 대한 설명\"과 \"설명 가능한 AI\" 책에서 찾을 수 있습니다.\n\n이제 주의 가중치를 시각화할 준비가 되었습니다. 이러한 시각화는 다른 변수나 시간 단계간의 패턴과 관계를 확인할 수 있습니다. 첫 번째 변수 중요도 차트는 인코더 중요도입니다.\n\n인코더 변수 중요도는 각 입력 변수가 예측의 정확성에 얼마나 기여하는지를 측정합니다. 이는 모델이 각 시간 단계에서 가장 관련성 있는 입력 변수에 초점을 맞출 수 있도록 해주는 주의 메커니즘을 사용하여 계산됩니다.\n\n```python\nplt.rcParams[\"figure.figsize\"] = (10,5)\nplt.barh(data=explainer._encoder_importance.melt().sort_values(by='value').tail(10), y='variable', width='value')\nplt.xlabel('중요도')\nplt.ylabel('특성')\nplt.title('Encoder 중요도')\nplt.show()\n```\n\n<div class=\"content-ad\"></div>\n\n\n![TFT Model](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_14.png)\n\nTFT 모델에서 디코더는 여러 계층으로 구성되어 있으며, 각 계층은 셀프 어텐션 메커니즘 다음에 피드 포워드 신경망(FFNN)이 이어집니다. 셀프 어텐션 메커니즘을 통해 모델은 입력 시퀀스의 여러 부분에 주의를 기울이고 출력 시퀀스를 생성할 때 그 중요성을 가중 평가할 수 있습니다. FFNN은 셀프 어텐션 메커니즘의 출력을 처리하고 현재 시간 단계의 최종 출력을 생성합니다.\n\n다음으로 중요한 변수 그래프가 디코더 중요도 차트입니다. 디코더 변수 중요도는 모델이 입력 시퀀스를 활용하여 출력 시퀀스를 생성하는 방식을 이해하는 데 유용합니다. 디코더 변수 중요도는 디코더의 각 변수에 할당된 어텐션 가중치를 분석하여 계산됩니다. 어텐션 가중치를 사용하여 각 변수의 중요도 점수가 계산되며, 이는 출력 시퀀스를 생성할 때 디코더에서 변수가 얼마나 중요한지 나타냅니다. 중요도 점수는 다음과 같이 계산됩니다:\n\n중요도 점수 = ∑ (어텐션 가중치 * 어텐션 헤드의 중요성)\n\n\n<div class=\"content-ad\"></div>\n\n```js\nplt.rcParams[\"figure.figsize\"] = (10,5)\nplt.barh(data=explainer._decoder_importance.melt().sort_values(by='value').tail(10), y='variable', width='value')\nplt.xlabel('중요도')\nplt.ylabel('특성')\nplt.title('디코더 중요도')\nplt.show()\n```\n\n위 출력에서 \"month5\", \"week_39\", \"week_29\" 등이 상위 입력 변수로 표시됩니다.\n\n<img src=\"/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_15.png\" />\n\n모델의 두 정적 변수의 효과를 검토할 수 있습니다. 그래프에서 \"family\"가 \"store\"보다 상대적으로 중요한 지표임을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n```py\nplt.rcParams[\"figure.figsize\"] = (10,5)\nplt.barh(data=explainer._static_covariates_importance.melt().sort_values(by='value').tail(10), y='variable', width='value')\nplt.xlabel('중요도')\nplt.ylabel('특성')\nplt.title('고정 Cov 중요도')\nplt.show()\r\n```\n\n<img src=\"/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_16.png\" />\n\nTFT 모델에서는 다중 헤드 어텐션이라는 기술을 사용하여 주의 시각화가 이루어집니다. 다중 헤드 어텐션을 통해 모델은 서로 다른 표현 공간에서 서로 다른 위치의 정보를 동시에 고려할 수 있습니다. 주의 가중치는 학습 중에 학습되고 입력 순서의 가중 합을 계산하는 데 사용되며, 그것은 비선형 활성화 함수를 통해 출력을 생성하기 위해 전달됩니다.\n\n미래 예측을 위한 주의 가중치를 시각화할 수도 있습니다. 그림(F)은 피라미드의 빛 굴절과 같은 그래프로, 미래를 위한 주의 가중치를 보여줍니다. 가까운 미래에 대한 예측은 더 높은 주의 가중치를 가지며, 먼 미래에 대한 예측은 더 낮은 주의 가중치를 가집니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nexplainer.plot_attention(explainability_result, plot_type=\"all\", show_index_as='time')\n```\n\n![Image](/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_17.png)\n\n내 하드웨어\n\nTFT는 계산 성능을 요구합니다. 저는 TFT를 Apple 2020 Mac Mini M1 칩 (8GB RAM, 512GB SSD 저장 용량)에서 실행했습니다. TFT를 세밀하게 조정하고 Figure (H) 및 (I)를 얻기 위해 더 나아가 데이터를 두 가게와 두 제품 패밀리로 제한하여 최대 60회 에포크까지 실행했습니다.\n\n<div class=\"content-ad\"></div>\n\n결론\n\n이 장에서는 Temporal Fusion Transformer (TFT) 기술을 설명했습니다. 이 장은 Temporal Fusion Transformer의 네 가지 중요한 측면을 강조했습니다: Multi-Horizon Forecasting, Interpretability, Temporal Fusion Mechanism 및 Transformer Architecture. 이 장은 공변량을 사용하여 전역 모델을 구축하는 방법을 보여주었습니다. 그런 다음 TFT의 모델 해석 특성에 대한 설명을 제공했습니다.\n\n부록\n\nTFT는 신경망 모델이므로 표준 신경망 하이퍼파라미터를 사용합니다. 여기서 \"드롭아웃\", \"배치 크기\" 및 \"에포크\" 개념을 이해하게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n드롭아웃\n\n신경망에서 드롭아웃은 오버피팅을 방지하고 모델의 일반화 성능을 향상시키는 정규화 기술입니다. 오버피팅은 모델이 훈련 데이터에 너무 꼭 맞아 맞춰져, 새로운 보이지 않는 데이터에서 성능이 나빠지는 현상을 말합니다.\n\n드롭아웃은 훈련 중에 층(layer) 내의 일부 뉴런(neuron)을 사용자가 지정한 확률로 랜덤하게 제거하면서 동작합니다. 이는 제거된 뉴런을 대체하기 위해 나머지 뉴런이 더 견고한 특징을 학습하도록 만듭니다.\n\n테스트 중에는 드롭아웉되지 않은 상태로 모든 뉴런이 사용됩니다. 제거된 뉴런은 실제로 네트워크에서 제거되지 않으므로, 이는 특정 세트의 뉴런에 의존하지 않고 예측을 만드는 데 도움이 됩니다. 이를 통해 오버피팅을 방지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n드롭아웃률, 즉 뉴런이 중단되는 확률은 일반적으로 0.1과 0.5 사이로 설정됩니다. 높은 드롭아웃률은 일반화 성능을 개선할 수 있지만, 학습 중에 일부 뉴런이 효과적으로 네트워크에서 제거되어 모델 용량이 감소할 수도 있습니다.\n\n배치 크기\n\n배치 크기는 학습 프로세스의 각 반복에서 한 번의 전진 및 후진 패스를 통해 처리되는 훈련 예제의 수를 나타냅니다. 학습 중에 신경망은 다양한 입력 예제를 제시받는데, 각 입력은 네트워크를 통해 전달되어 출력을 계산합니다. 그런 다음 예측된 출력과 실제 출력 간의 차이에 기초하여 네트워크의 매개변수가 조정됩니다. 이와 같은 과정을 역전파라고합니다.\n\n배치 크기는 각 반복에서 매개변수를 업데이트하는 데 사용되는 입력 예제의 수를 결정합니다. 더 큰 배치 크기는 기울기의 더 신뢰할 수있는 추정을 제공할 수 있으며, 학습 프로세스의 정확성과 안정성을 향상시킬 수 있습니다. 그러나 큰 배치 크기는 더 많은 메모리 및 계산 리소스가 필요하므로 특정 응용 프로그램에는 제한이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n제가 설명하는 방법은 베이킹 스토리를 사용하여 신경망의 배치 크기 개념을 설명하는 것을 좋아해요. 상상해봐요, 베이킹을 원하는 많은 쿠키 반죽이 있다고 해봅시다. 이 쿠키를 작은 배치 또는 큰 배치로 베이킹할 수 있어요. 한 번에 큰 배치로 쿠키를 베이킹하면 굉장히 오랜 시간이 걸릴 거예요 (ㅋㅋ). 쿠키를 8개 또는 16개 배치로 나눌 수 있어요. 몇 가지 훈련 예시를 한 번에 처리할 수 있어요. 이렇게 하면 모델 매개변수를 더 자주 업데이트할 수 있고, 기울기는 각 작은 배치 후에 계산되고 적용됩니다. 이는 보다 빠른 수렴과 더 자주 무게 업데이트를 가져올 수 있지만, 샘플 크기가 작아서 매개변수 업데이트에 더 많은 노이즈가 발생할 수도 있어요.\n\n에포크\n\n에포크는 전체 훈련 데이터 세트를 한 번 통과하는 것을 의미해요. 각 에포크 동안 신경망은 훈련 데이터 세트의 각 예시를 예측하고 예측된 값과 실제 값 사이의 오차에 따라 가중치와 바이어스를 업데이트해요.\n\n책 \"이미지 분류를 위한 전이 학습\"에서는 1,000개의 이미지 데이터 세트로 에포크 개념을 설명해요. 각 에포크 중에 신경망은 1,000개의 이미지 각각을 예측하고 예측된 값과 실제 값 사이의 오차에 따라 가중치와 바이어스를 업데이트해요. 이 프로세스는 일정한 횟수의 에포크 동안 반복되어 신경망이 전체 훈련 데이터 세트를 여러 번 보게 될 때까지 지속돼요.\n\n<div class=\"content-ad\"></div>\n\n에포크의 수는 신경망이 전체 학습 데이터 세트를 몇 번 보게 될지를 결정합니다. 에포크 수가 너무 낮으면, 신경망은 데이터의 기저 패턴을 배울 충분한 기회가 없을 수 있으며, 정확하지 않은 예측을 할 수 있습니다. 반면에, 에포크 수가 너무 높으면, 신경망은 학습 데이터에 오버피팅될 수 있으며, 새로운 보이지 않는 데이터에 대해 정확하지 않은 예측을 할 수 있습니다.\n\n참고 자료\n\n- [1] Lim, B., Arik, S.Ö., Loeff, N., & Pfister, T. (2019). Temporal Fusion Transformers for Interpretable Multi-horizon Time Series Forecasting. ArXiv, abs/1912.09363.\n- [2] Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser, Ł. & Polosukhin, I. (2017). Attention is all you need. Advances in Neural Information Processing Systems (p./pp. 5998–6008).\n- [3] Kuo, C. (2023). The Handbook of NLP with Gensim: Leverage topic modeling to uncover hidden patterns, themes, and valuable insights within textual data. Packt Publishing.\n\n샘플 eBook 장(chapter) 무료 다운로드: [https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf](https://github.com/dataman-git/modern-time-series/blob/main/​20240522beauty_TOC.pdf)\n\n<div class=\"content-ad\"></div>\n\n- 아름다운 형식으로 책을 재현해준 The Innovation Press, LLC의 직원들에게 감사드립니다. 즐거운 독서 경험을 위해 Teachable 플랫폼을 선택하고 전 세계 독자들에게 분배하였습니다. 신용 카드 거래는 Teachable.com이 신뢰성 있고 안전하게 처리합니다.\n\nTeachable.com에서의 eBook: $22.50\nhttps://drdataman.teachable.com/p/home\n\nAmazon.com의 인쇄판: $65\nhttps://a.co/d/25FVsMx\n\n- 인쇄판은 광택 처리된 표지, 컬러 인쇄 및 아름다운 Springer 글꼴과 레이아웃을 채택하여 즐길 수 있는 독서를 제공합니다. 7.5 x 9.25 인치의 크기로 대부분의 책장에 맞습니다.\n- \"이 책은 시계열 분석과 예측 분석, 이상 감지에 대한 깊은 이해를 보여주는 Kuo의 증명서입니다. 이 책은 독자들이 현실 세계의 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 경력 전환을 원하는 사람들에게 특히 가치 있습니다. Kuo는 전통적이고 첨단 기술을 자세히 탐구합니다. Kuo는 최신 동향과 분야의 최신 발전을 반영하기 위해 신경망 및 기타 고급 알고리즘에 대한 토론을 통합합니다. 이를 통해 독자들이 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이고 혁신적인 기술과 소통할 준비가 되어 있음을 보장합니다. 이 책의 명확성과 접근성은 Kuo의 매력적인 글쓰기 스타일에 의해 향상됩니다. 그는 복잡한 수학적 및 통계적 개념을 해독하여 엄격성을 희생하지 않고 접근 가능하게 만들었습니다.\"\n\n<div class=\"content-ad\"></div>\n\n# 모던 시계열 예측: 예측 분석과 이상 감지를 위한\n\n제로장: 서문\n\n제1장: 소개\n\n제2장: 비즈니스 예측을 위한 선지자\n\n<div class=\"content-ad\"></div>\n\n## Chapter 3: 튜토리얼 I: 추세 + 계절성 + 휴일 및 이벤트\n\n## Chapter 4: 튜토리얼 II: 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀자 + 미래 회귀자\n\n## Chapter 5: 시계열의 변곡점 탐지\n\n## Chapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\n<div class=\"content-ad\"></div>\n\n# 제 7장: 시계열 확률적 예측을 위한 분위 회귀\n\n# 제 8장: 시계열 확률적 예측을 위한 적응형 예측\n\n# 제 9장: 시계열 확률적 예측을 위한 적응형 분위 회귀\n\n# 제 10장: 자동 ARIMA!\n\n<div class=\"content-ad\"></div>\n\n# 챕터 11: 시계열 데이터 형식 간단히\n\n# 챕터 12: 다중 기간 확률 예측을 위한 선형 회귀\n\n# 챕터 13: 트리 기반 시계열 모델용 특성 공학\n\n# 챕터 14: 다중 기간 시계열 예측을 위한 주요 두 가지 전략\n\n<div class=\"content-ad\"></div>\n\n15장: Tree 기반 XGB, LightGBM 및 CatBoost 모델을 활용한 다기간 시계열 확률 예측\n\n16장: 시계열 모델링 기법의 진화\n\n17장: 시계열 확률 예측을 위한 Deep Learning 기반 DeepAR\n\n18장: 응용 – 주식 가격에 대한 확률 예측\n\n<div class=\"content-ad\"></div>\n\n# 19장: RNN에서 트랜스포머 기반 시계열 모델로\n\n# 20장: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\n# 21장: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼","ogImage":{"url":"/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_0.png"},"coverImage":"/assets/img/2024-06-22-TemporalFusionTransformerforInterpretableTimeSeriesPredictions_0.png","tag":["Tech"],"readingTime":30},{"title":"Django 배우기 전에 꼭 마스터 해야 할 필수 Python 주제","description":"","date":"2024-06-22 02:47","slug":"2024-06-22-EssentialPythonTopicstoMasterBeforeLearningDjango","content":"\n\nDjango는 빠른 속도로 안전하고 유지보수가 쉬운 웹 사이트를 개발할 수 있도록 하는 Python의 강력하고 인기 있는 웹 프레임워크입니다. 그러나 Django를 최대한 활용하려면 Python에 튼튼한 기반을 갖추는 것이 중요합니다. 이 블로그 포스트는 Django에 뛰어들기 전에 반드시 숙달해야 할 주요 Python 주제를 안내해 드릴 것입니다.\n\n# 기본 Python 개념\n\n## 1. 구문과 의미론\n\nPython의 구문과 의미론을 이해하는 것이 첫걸음입니다. Python은 코드 블록을 정의하는 데 들여쓰기를 사용합니다. 이를 숙달함으로써 일반적인 함정을 피하고 코드를 더 읽기 쉽게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 들여쓰기: Python은 코드 블록을 정의하는 데 들여쓰기를 활용합니다.\n- 주석: 한 줄 주석은 #을 사용하고 여러 줄 주석은 삼중 따옴표를 활용합니다.\n\n## 2. 변수와 데이터 유형\n\n변수를 선언하고 사용하는 방법을 알아야 합니다.\n\n- 데이터 유형: 정수, 부동 소수점 수, 문자열, 부울린.\n- 컬렉션: 리스트, 튜플, 세트, 사전.\n\n<div class=\"content-ad\"></div>\n\n## 3. 연산자\n\n연산자는 변수와 값에 대한 작업을 수행하는 데 사용되는 기본 요소입니다.\n\n- 산술 연산자: +, -, *, / 등\n- 비교 연산자: ==, !=, `, ` 등\n- 논리 연산자: and, or, not\n- 할당 연산자: =, +=, -= 등\n- 비트 연산자: &, |, ^, ~, ``, ``\n\n## 4. 제어 흐름\n\n<div class=\"content-ad\"></div>\n\n프로그램의 흐름을 조절하기 위해 제어 흐름 문장을 사용합니다.\n\n- 조건문: if, elif, else.\n- 반복문: for, while.\n- 반복 제어: break, continue, pass.\n\n# 파이썬 중급 개념\n\n## 5. 함수\n\n<div class=\"content-ad\"></div>\n\n함수는 특정 작업을 수행하는 재사용 가능한 코드 조각입니다.\n\n- 정의 및 호출: def 키워드.\n- 인수: 위치, 키워드, 기본, 가변 길이.\n- 반환 값: return 문.\n- 람다 함수: 람다를 사용한 익명 함수.\n\n## 6. 모듈과 패키지\n\n모듈과 패키지를 사용하여 코드를 모듈화하면 관리하기 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n- 모듈 가져오기: import 문.\n- 패키지 생성 및 사용: 모듈을 디렉토리에 구성하세요.\n- 표준 라이브러리 모듈: Python의 방대한 표준 라이브러리에 익숙해지세요.\n\n## 7. 파일 처리\n\n파일에서 읽고 쓰는 방법을 배웁니다.\n\n- 파일 읽고 쓰기: open(), read(), write(), close().\n- 파일 경로: 상대 경로와 절대 경로 이해하기.\n\n<div class=\"content-ad\"></div>\n\n## 8. 에러 및 예외 처리\n\n에러를 공손하게 처리하면 프로그램이 견고해집니다.\n\n- 예외 처리: try, except, finally 블록.\n- 사용자 정의 예외: 특정 시나리오에 대해 사용자 정의 예외를 생성하세요.\n\n# 고급 Python 개념\n\n<div class=\"content-ad\"></div>\n\n## 9. 객체 지향 프로그래밍 (OOP)\n\nOOP는 복잡한 프로그램을 조직화하는 데 도움이 됩니다.\n\n- 클래스와 객체: 클래스를 정의하고 인스턴스를 생성합니다.\n- 메소드와 속성: 클래스 내의 함수와 변수.\n- 상속: 기존 클래스를 재사용하고 확장합니다.\n- 다형성: 서로 다른 클래스를 교차로 사용할 수 있습니다.\n- 캡슐화: 특정 구성 요소에 대한 접근을 제한합니다.\n- 특별한 메소드: __init__, __str__, 등.\n\n## 10. Comprehensions\n\n<div class=\"content-ad\"></div>\n\n컴프리헨션은 컬렉션을 만드는 간결한 방법을 제공해요.\n\n- 리스트 컴프리헨션: [x for x in iterable].\n- 딕셔너리 컴프리헨션: 'k: v for k, v in iterable'.\n- 세트 컴프리헨션: 'x for x in iterable'.\n\n## 11. 데코레이터\n\n데코레이터는 함수나 클래스의 동작을 수정하는 역할을 해요.\n\n<div class=\"content-ad\"></div>\n\n- 기능 데코레이터: 다른 함수를 반환하는 함수들입니다.\n- 클래스 데코레이터: 클래스 동작을 수정합니다.\n\n## 12. 이터레이터와 제너레이터\n\n이터레이터와 제너레이터는 컬렉션을 간편하게 이터레이션할 수 있게 합니다.\n\n- 이터레이터: __iter__와 __next__ 메소드를 구현합니다.\n- 제너레이터: 값을 동적으로 생성하기 위해 yield를 사용합니다.\n- 제너레이터 표현식: 리스트 내포와 유사하지만 괄호를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n# 추가 유용한 지식\n\n## 13. 정규 표현식\n\n정규 표현식(정규식)은 문자열 매칭과 조작에 강력합니다.\n\n- 기본 패턴: 일반적인 정규식 패턴을 배웁니다.\n- re 모듈: Python의 정규식 모듈을 사용하여 패턴 매칭을 수행합니다.\n\n<div class=\"content-ad\"></div>\n\n## 14. 자료 구조\n\n기본적인 자료 구조를 이해하는 것은 효율적인 프로그래밍에 중요합니다.\n\n- 스택과 큐: LIFO 및 FIFO 구조.\n- 연결 리스트: 순차적으로 연결된 노드.\n- 트리와 그래프: 계층적 및 네트워크화된 자료 구조.\n\n## 15. 동시성\n\n<div class=\"content-ad\"></div>\n\n동시에 여러 작업을 실행하는 것이 동시성에 관한 것이에요.\n\n- Threading: 병렬 실행을 위해 스레드를 실행합니다.\n- Multiprocessing: 여러 CPU 코어를 활용하기 위해 프로세스를 실행합니다.\n- asyncio: I/O 바운드 작업을 위한 비동기 프로그래밍입니다.\n\n# 실무 경험\n\n## 16. 가상 환경\n\n<div class=\"content-ad\"></div>\n\n가상 환경을 사용하여 프로젝트 종속성을 격리하세요.\n\n- 생성 및 관리: venv, virtualenv.\n\n## 17. Pip 및 패키지 관리\n\npip로 프로젝트 종속성을 관리하세요.\n\n<div class=\"content-ad\"></div>\n\n- 패키지 설치 및 관리: pip를 사용하여 Python 패키지를 설치하고 관리합니다.\n\n## 18. 웹 기본 개념\n\nDjango를 시작할 때 웹 개념에 대한 기본적인 이해가 도움이 됩니다.\n\n- HTTP/HTTPS: 웹 통신의 기본을 이해합니다.\n- REST API: RESTful API 작동 방식을 배웁니다.\n\n<div class=\"content-ad\"></div>\n\n# 데이터베이스 작업\n\n## 19. SQL 기본\n\n데이터베이스 작업을 위해 SQL 이해가 중요합니다.\n\n- CRUD 작업: 생성(Create), 읽기(Read), 업데이트(Update), 삭제(Delete).\n- 조인(Join): 여러 테이블에서 행을 결합합니다.\n- 인덱스(Index)와 트랜잭션(Transaction): 데이터베이스 작업을 최적화하고 관리합니다.\n\n<div class=\"content-ad\"></div>\n\n## 20. ORM (객체 관계 매핑)\n\nORM은 Django에서 데이터베이스 상호작용을 단순화합니다.\n\n- 기본 ORM 개념: ORM이 데이터베이스 테이블을 클래스로 매핑하는 방법을 이해합니다.\n- ORM 라이브러리: SQLAlchemy와 같은 라이브러리에 익숙해집니다.\n\n# 학습 자료\n\n<div class=\"content-ad\"></div>\n\n## 책\n\n- “Automate the Boring Stuff with Python” by Al Sweigart\n- “Python Crash Course” by Eric Matthes\n\n## 온라인 강좌\n\n- Coursera\n- Udemy\n- Codecademy\n\n<div class=\"content-ad\"></div>\n\n## 실습 플랫폼\n\n- LeetCode\n- HackerRank\n- Codewars\n\n# 결론\n\n이 Python 주제들을 숙달함으로써 Django에 대비할 준비가 충분해질 것입니다. 이 각 영역은 Django를 더 효과적으로 이해하고 사용하는데 도움이 되는 기초를 형성합니다. 즐거운 학습 되세요!","ogImage":{"url":"/assets/img/2024-06-22-EssentialPythonTopicstoMasterBeforeLearningDjango_0.png"},"coverImage":"/assets/img/2024-06-22-EssentialPythonTopicstoMasterBeforeLearningDjango_0.png","tag":["Tech"],"readingTime":5}],"page":"27","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}