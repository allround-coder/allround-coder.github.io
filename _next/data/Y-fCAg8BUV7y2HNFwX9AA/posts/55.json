{"pageProps":{"posts":[{"title":"NodeJS 작동 방식 뒷담화부터 전달합니다","description":"","date":"2024-06-19 23:05","slug":"2024-06-19-HowNodeJSWorksBehindtheScenes","content":"\n\n\n![How Node.js Works Behind the Scenes](/assets/img/2024-06-19-HowNodeJSWorksBehindtheScenes_0.png)\n\nNode.js는 Google의 오픈 소스 V8 JavaScript 엔진을 기반으로 한 JavaScript 런타임입니다. 또한 웹 서버로 사용하기에 이상적이며, 서버 측 웹 개발에 JavaScript를 사용할 수 있는 장점을 제공합니다. Node.js는 V8 JavaScript 엔진과 런타임 환경 내의 Libuv와 같은 몇 가지 핵심 라이브러리에 의존합니다.\n\n- V8 엔진은 JavaScript 코드를 컴퓨터가 실제로 이해할 수 있는 기계 코드로 변환합니다.\n- Libuv는 비동기 I/O에 강점을 가진 오픈 소스 라이브러리입니다. 이 레이어를 통해 Node는 기본 컴퓨터 운영 체제, 파일 시스템, 네트워킹 등에 대한 액세스 권한을 얻습니다. 또한 libuv는 Node.js의 두 가지 매우 중요한 기능인 이벤트 루프와 스레드 풀도 구현합니다.\n\n# 스레드 풀\n\n\n<div class=\"content-ad\"></div>\n\n컴퓨터에서 Node를 사용할 때는 해당 컴퓓에서 실행 중인 프로그램을 나타내는 Node 프로세스가 있음을 의미합니다. 이 프로세스 내에서 Node.js는 단일 스레드에서 작동합니다. 이는 Node 애플리케이션을 실행할 때 해당 애플리케이션이 단일 스레드에서 실행된다는 것을 의미합니다. \n\n- 프로그램이 초기화될 때 모든 최상위 코드가 실행되는데, 이는 어떠한 콜백 함수 내부에 있지 않은 모든 코드를 의미합니다.\n- 추가로, 애플리케이션에 필요한 모든 모듈이 로드되고, 모든 콜백이 등록됩니다.\n- 그 다음, 이벤트 루프가 마침내 실행을 시작합니다.\n\n파일 시스템 API, 암호화, 압축 및 DNS 조회와 같은 일부 작업은 이벤트 루프 내에서 실행하기에는 너무 많은 리소스가 필요하거나 비용이 많이 드는 작업이므로 단일 스레드를 차단할 수 있습니다. 이것이 스레드 풀이 필요한 이유입니다. 이 스레드 풀은 이벤트 루프와 마찬가지로 Node.JS에 Libuv 라이브러리로 제공됩니다.\n\n- 스레드 풀은 메인 단일 스레드와 완전히 분리된 4개의 추가 스레드를 제공합니다.\n- Node.js를 최대 128개의 스레드까지 사용하도록 구성할 수 있지만, 대개 4개의 스레드만으로 대부분의 애플리케이션에 충분합니다. 그렇다면 기본 스레드 풀 크기 4를 다른 숫자로 변경하는 방법은 무엇일까요?\n\n<div class=\"content-ad\"></div>\n\n```js\nprocess.env.UV_THREADPOOL_SIZE = 1;\n```\n\n- 그런 다음 이벤트 루프는 무거운 작업을 스레드 풀로 자동으로 오프로드할 수 있습니다. 이 모든 것은 자동으로 백그라운드에서 발생합니다.\n- 개발자는 스레드 풀에 할당할 항목을 결정할 권한이 없습니다.\n\n# 이벤트 루프\n\nNode.js에서는 애플리케이션 내에서 중요한 사건이 발생할 때마다 명명된 이벤트를 방출하는 이벤트 발생자라는 특정 개체가 있습니다. 이 사건에는 서버에 요청이 도착하거나 타이머가 만료되거나 파일이 읽기 작업을 완료하는 등의 중요한 일이 포함될 수 있습니다. 이러한 이벤트는 개발자가 설정한 이벤트 리스너에 의해 수집되며, 각 리스너에 첨부된 콜백 함수가 실행됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst server = http.createServer(); server.on('request',(req,res) => { res.end('Request received'); });\n```\n\n- 서버를 생성하려면 createServer() 메서드를 사용하고 서버 변수에 저장합니다.\n- server.on 메서드는 \"request\" 이벤트를 위해 리스너를 생성하는 데 사용됩니다.\n- 서버는 이벤트를 발생시키는 발신자 역할을 하며 요청이 서버에 도달할 때마다 \"request\" 이벤트를 자동으로 발생시킵니다.\n- 이 리스너에 연결된 콜백 함수는 자동으로 호출됩니다.\n- 함수는 그런 다음 데이터를 클라이언트에 다시 보냅니다.\n\nJavaScript 프로그래밍에서 이벤트 발생자 논리는 관찰자 패턴이라고 합니다. 결론적으로 이벤트 루프는 콜백 실행 및 네트워킹 I/O와 같은 간단한 작업을 처리하는 것을 담당하며, 스레드 풀은 파일 액세스나 압축과 같은 더 많은 작업을 처리합니다.","ogImage":{"url":"/assets/img/2024-06-19-HowNodeJSWorksBehindtheScenes_0.png"},"coverImage":"/assets/img/2024-06-19-HowNodeJSWorksBehindtheScenes_0.png","tag":["Tech"],"readingTime":3},{"title":"자바스크립트의 this 키워드 설명 및 해석하기","description":"","date":"2024-06-19 23:03","slug":"2024-06-19-JavaScriptsthiskeywordexplainedanddemystified","content":"\n\n<img src=\"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_0.png\" />\n\n\"this\" 키워드는 양날의 검이에요. 복잡한 오류의 원인이 될 수도 있고, 실제로 어떻게 작동하는지 알면 개발자로서 여러분에게 삶을 쉽게 만들어 줄 수도 있어요. 요즘에는 커뮤니티가 언어를 더 함수형 패러다임으로 밀고 있어요. \"this\" 키워드를 그렇게 많이 사용하지는 않아요. 그런데 여전히 문맥에 따라 의미가 달라 혼란스러울 수 있어요. 그래서 이 글에서는 \"this\" 키워드를 설명해 실제로 어떻게 작동하는지 잘 이해하도록 도와드릴게요.\n\n# 소개\n\n이 글은 모든 자바스크립트 개발자를 위한 것입니다. 다음을 배울 수 있을 거에요:\n\n<div class=\"content-ad\"></div>\n\n- 자바스크립트에서 this 키워드란 무엇인가요?\n- 노드에서 this 키워드가 나타내는 바는 무엇인가요?\n- 전역 및 함수 실행 컨텍스트에서 this 키워드가 어떻게 결정되나요?\n- 함수가 호출되는 다양한 방법 및 이와 this의 관계\n- call() 및 apply() 메서드를 사용하여 this의 값을 제어하는 방법\n- bind() 메서드를 사용하는 방법\n- 화살표 함수에서 this가 동작하는 방식\n\n# this 키워드란 무엇인가\n\nthis 키워드는 자바스크립트에서 함수가 호출될 때 객체 참조를 저장하는 변수입니다. this 키워드가 참조하거나 가리키는 객체는 사용된 컨텍스트에 따라 달라집니다. 개념적으로, this는 영어 문법의 대명사와 유사합니다. 대명사가 명사를 참조하는 방식처럼 this는 객체를 참조하기 위해 사용됩니다.\n\n예를 들어: “Mary is running fast because she is trying to catch the bus.”\n\n<div class=\"content-ad\"></div>\n\n위 구문에서는 대명사 \"she\"가 선행사 \"Mary\"를 가리키는 데 사용됩니다. 이 개념을 JavaScript의 this 키워드와 연관시켜보겠습니다.\n\n```js\nconst person = { name: \"Mary\",\n                 pronoun: \"she\", \n                 Activity: function () { // this = person\n                     console.log(`${person.name} is running fast because ${this.pronoun} is trying to catch the bus`);\n                 } \n               }\nperson.Activity(); // Mary is running fast because she is trying to catch the bus\n```\n\n위 코드에서 this는 person 객체의 참조값으로 사용되며, 마치 대명사 \"she\"가 \"Mary\"를 가리키는 것처럼 사용됩니다.\n\n# this의 값은 어떻게 결정됩니까?\n\n<div class=\"content-ad\"></div>\n\n`table` 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n글로벌 실행 컨텍스트에서 this 키워드는 웹 브라우저의 창 객체인 글로벌 객체를 참조합니다.\n\n```js\nconsole.log(window === this ) // true this.color = 'Green' console.log(window.color) // Green\n```\n\n위 코드에서는 this 키워드를 사용하여 전역 window 객체에 속성을 추가하고 있습니다.\n\n참고: 전역 실행 컨텍스트에서는 JavaScript가 strict mode 인지 아닌지에 상관없이 this 키워드가 항상 글로벌 객체를 참조합니다.\n\n<div class=\"content-ad\"></div>\n\n## Node.js에서의 'this' 키워드\n\nNode.js 문서에 따르면,\n\n위 문장의 의미는 'this' 키워드가 Node.js에서 전역 객체를 참조하지 않는다는 것입니다. 대신, 현재 사용 중인 모듈을 가리킨다는데요. 즉, module.exports를 통해 내보낸 객체를 가리킵니다.\n\n예를 들어, 가상의 모듈인 app.js를 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\n┣ 📄 app.js \nconsole.log(this); \nmodule.exports.color = 'Green'; \nconsole.log(this);\n```\n\noutput:\n\n```js\n┣ $ node app.js \n{} \n{color: 'Green'}\n```\n\n![JavaScript this keyword explained and demystified](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_1.png)\n\n<div class=\"content-ad\"></div>\n\n위의 코드에서 먼저 app.js 모듈에 module.exports에 값이 없기 때문에 빈 객체가 로깅됩니다. 그런 다음 color 속성이 module.exports 객체에 추가되고, 이를 다시 로깅하면 업데이트된 module.exports 객체가 반환되어 color 속성이 포함됩니다.\n\n## 노드(Node)에서 전역 객체에 액세스하는 방법\n\n이제 우리는 브라우저와 달리 노드에서는 this 키워드가 전역 객체를 참조하지 않는다는 것을 알았습니다. 노드에서는 전역 객체에 global 키워드를 사용하여 액세스하며, 전역 키워드가 사용된 위치와 관계없이 전역 객체에 액세스할 수 있습니다.\n\n```js\n┣ 📄 app.js console.log(global);\n```\n\n<div class=\"content-ad\"></div>\n\n출력:\n\n```js\n┣ $ node app.js // 노드 글로벌 객체를 기록합니다.\n```\n\n<img src=\"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_2.png\" />\n\n글로벌 객체는 노드 환경에 대한 여러 유용한 속성을 노출합니다.\n\n<div class=\"content-ad\"></div>\n\n# 함수 실행 컨텍스트\n\n함수 실행 컨텍스트에서 this 키워드가 어떻게 결정되는지는 함수가 호출되는 방식에 따라 다릅니다.\n\n자바스크립트 함수는 네 가지 방법으로 호출될 수 있습니다:\n\n- 함수로서 호출\n- 메소드로서 호출\n- 생성자로서 호출\n- apply 및 call 메서드를 사용하여 호출\n\n<div class=\"content-ad\"></div>\n\n함수가 호출될 때(즉, 함수가 () 연산자를 사용하여 호출될 때) this는 비엄격 모드에서 전역 창 객체를 참조하고 엄격 모드에서는 undefined로 설정됩니다.\n\n예시\n\n```js\nfunction A() { console.log(this === window) // true }\nfunction B() { \"use strict\" console.log(this === window) // false } function C() { \"use strict\" console.log(this === undefined) // true}\n\nA(); // true\nB(); // false\nC(); // true\n```\n\n함수가 메소드로 호출될 때(즉, 객체 속성을 통해), this는 메소드의 \"소유\" 객체를 참조합니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n```js\nlet Nigeria = { continent: 'Africa', getContinent: function () { return this.continent; } } \nconsole.log(Nigeria.getContinent()); // Africa\n```\n\n함수를 생성자로 호출하려면 함수 호출 앞에 new 연산자를 사용합니다.\n\n예시\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction Context() {return this; } \nnew Context();\n```\n\n함수가 생성자로 호출될 때(new 연산자를 통해) 몇 가지 특별한 동작이 발생합니다:\n\n- 새로운 비어있는 객체가 생성됩니다.\n- 이 객체가 생성자에 this 참조 객체로 전달됩니다. 즉, 함수가 호출될 때 this가 가리키는 객체입니다.\n- 새로 생성된 객체가 new 연산자의 값으로 반환됩니다.\n\n예제\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction Person() { this.name = 'Mary', this.age = 20 }\nconst person1 = new Person(); \nconsole.log(person1.age) // 20\n```\n\n![Reference Image](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_3.png)\n\n위 코드와 다이어그램에서는 함수가 생성자로 호출될 때 this가 객체를 참조하는 방법을 보여주고 설명합니다.\n\nnew 연산자 없이 생성자 함수를 호출하려고 하면 this는 객체가 아니라 undefined를 가리킵니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n```js\nfunction Person() { this.name = 'Mary', this.age = 20 } const person2 = Person(); console.log(person2.age) // // => TypeError: Cannot read property 'age' of undefined\n```\n\nPerson() 함수가 항상 생성자 호출을 통해 실행되도록 하기 위해 Person() 함수 시작 부분에 체크를 추가합니다:\n\n```js\nfunction Person() { if (!(this instanceof Person)) { throw Error('Must use the new operator to call the function'); } \nthis.name = 'Mary',\nthis.age = 20 } \nconst person2 = Person(); console.log(person2.age) // // => Must use the new operator to call the function\n```\n\n<div class=\"content-ad\"></div>\n\nES6에서는 생성자로 호출되었는지 또는 간단하게 호출되었는지를 탐지할 수 있는 new.target이라는 메타 프로퍼티를 도입했습니다.\n\nPerson() 함수를 수정하여 new.target 메타프로퍼티를 사용할 수 있습니다:\n\n```js\nfunction Person() { \nif (!new.target) { throw Error('Must use the new operator to call the function'); }\n this.name = 'Mary', this.age = 20 }\n const person2 = Person(); \nconsole.log(person2.age)\n // => Must use the new operator to call the function\n```\n\n함수는 객체이며, 모든 JavaScript 객체와 같이 메소드가 있습니다. 이 중 두 가지 메소드인 call()과 apply()는 함수를 간접적으로 호출합니다. 이 두 메소드를 사용하면 호출에 대해 명시적으로 this 값(객체 참조)을 지정할 수 있어 어떤 함수든 해당 객체의 메소드로 호출할 수 있습니다. call()과 apply()는 호출에 대한 인수를 지정할 수도 있습니다. call() 메소드는 함수에 대해 자체 인수 목록을 함수의 인수로 사용하며, apply() 메소드는 인수로 사용할 값의 배열을 기대합니다. call() 및 apply() 모두 첫 번째 인수는 함수가 호출될 객체를 나타내는 this 키워드입니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n```js\nfunction getContinent(prefix) { console.log(`${prefix} ${this.continent}`); } \nlet nigeria = { continent: 'Africa' };\nlet china = { continent: 'Asia' }; \ngetContinent.call(nigeria, \"나이지리아는\"); getContinent.call(china, \"중국은\");\n```\n\n출력:\n\n```js\n나이지리아는 Africa 중국은 Asia\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 getContinent() 함수를 간접적으로 호출하기 위해 getContinent() 함수의 call() 메소드를 사용했습니다. call() 메소드의 첫 번째 인자로 nigeria와 china 오브젝트를 전달했기 때문에 각 호출에서 해당 국가의 대륙을 얻었습니다.\n\napply() 메소드는 call() 메소드와 유사하지만, 두 번째 인자로 argument 배열을 사용한다는 것을 이미 알고 계실 것입니다.\n\n```js\ngetContinent.apply(nigeria, [\"나이지리아는\"]); getContinent.apply(china, [\"중국은\"]);\n```\n\nOutput:\n\n<div class=\"content-ad\"></div>\n\n```js\n나이지리아는 아프리카에 있고 중국은 아시아에 있습니다.\n```\n\n화살표 함수에서 JavaScript는 this를 렉시컬하게 설정합니다. 이는 화살표 함수 내부의 this 값이 가장 가까운 \"비-화살표\" 함수에 의해 정의된다는 것을 의미합니다. 또한, 화살표 함수 내부에서 this의 값은 변경할 수 없습니다. 이는 함수의 전체 수명 주기 동안 동일한 상태를 유지합니다.\n\n몇 가지 예시를 살펴봅시다:\n\n```js\nlet getThis = () => this; console.log(getThis() === window); // true\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 this 값이 전역 객체인 즉, 웹 브라우저의 창 객체로 설정됩니다. 스택과 힙을 이용해 이전 코드를 더 자세히 이해해 봅시다.\n\n![이미지](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_4.png)\n\n- getThis 화살표 함수는 전역 window 객체를 반환하는 Global() \"non-arrow\" 함수에 렉시컬 스코프를 갖습니다.\n- getThis 화살표 함수 내의 this 값은 해당 객체를 가리키는 함수의 this 값이 렉시컬로 스코프된 것이므로 전역 window 객체입니다.\n\n다른 예시를 살펴보죠:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction confirmThis () { let getThis = () => this; console.log(getThis() === window); // true } confirmThis();\n```\n\n결과:\n\n일반 함수의 this 값은 \"비 엄격 모드\"에서 전역 window 객체를 가리킨다. this 값은 confirmThis() 함수의 렉시컬 스코프에 바인딩되므로 window 객체를 가리킬 것이다. 그러나 \"엄격\" 모드에서는 상황이 다릅니다.\n\n```js\nfunction confirmThis () { \"use strict\"; let getThis = () => this; console.log(getThis() === window); // true } confirmThis();\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 strict 모드에서 confirmThis() 함수의 this 값이 undefined로 설정되며, getThis 화살표 함수도 마찬가지입니다.\n\n예시\n\n```js\nconst module = { x: 42, getX: function() { return this.x; } };\nconst unboundGetX = module.getX; console.log(unboundGetX());\n// 함수는 전역 범위에서 실행됩니다\n// 기대 출력: undefined\nconst boundGetX = unboundGetX.bind(module); console.log(boundGetX()); // 기대 출력: 42\n```\n\n<div class=\"content-ad\"></div>\n\n앞선 코드에서는 모듈 객체의 메서드인 getX()이 전역 범위에서 \"함수\"(대신 모듈의 메서드로)로 호출됩니다. 이로 인해 이 참조가 모듈 객체에서 누락됩니다. getX 메서드가 \"함수\"로 호출될 때 이 참조가 여전히 모듈 객체를 가리키게 하려면 bind() 메서드를 통해 모듈 객체에 \"바인딩\"되어야 합니다. - const boundGetX = unboundGetX.bind(module);.\n\n# 결론\n\n이제 이 키워드가 어떻게 작동하는지와 적용되는 다양한 컨텍스트를 알게 되었습니다. 필요한 경우 편안하게 사용할 수 있을 것입니다.\n\n# 요약\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 다음을 배웠습니다:\n\n- JavaScript에서 this 키워드가 무엇인지에 대해 알게 되었습니다.\n- Node에서 this 키워드가 무엇을 나타내는지에 대해 알게 되었습니다.\n- 전역 및 함수 실행 컨텍스트에서 this 키워드가 어떻게 결정되는지에 대해 알게 되었습니다.\n- 함수가 호출되는 다양한 방법 및 this와의 관련성에 대해 알게 되었습니다.\n- call() 및 apply() 메소드를 사용하여 this의 값을 제어하는 방법에 대해 알게 되었습니다.\n- bind() 메소드를 사용하는 방법에 대해 알게 되었습니다.\n- 화살표 함수에서 this의 동작 방식에 대해 알게 되었습니다.\n\n# 용어 해설\n\nStack 또는 CallStack: 스택은 후입선출(LIFO) 원칙을 따르는 데이터 구조입니다. 그러나 실행 스택은 코드 실행 중에 생성된 모든 실행 컨텍스트를 추적하는 스택입니다. 또한 스택은 JavaScript에서 정적 데이터(변수 및 참조 값)를 저장합니다. 자세히 알아보세요.\n\n<div class=\"content-ad\"></div>\n\n힙: 힙은 JavaScript에서 동적 데이터를 저장하는 데 사용되는 데이터 구조입니다. 이 곳에는 모든 JavaScript 객체가 저장됩니다. 더 알아보려면 [여기](링크)를 확인해보세요.\n\n렉시컬 스코프: 보다 잘 이해하기 위해 [스택 오버플로우 답변](링크)을 참고하십시오.\n\nJavaScript 엄격 모드: [MDN](링크)\n\n![이미지](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_5.png)","ogImage":{"url":"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_0.png"},"coverImage":"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_0.png","tag":["Tech"],"readingTime":10},{"title":" Nx Affected에 대한 심층 탐구","description":"","date":"2024-06-19 23:00","slug":"2024-06-19-DeepDiveintoNxAffected","content":"\n\n## 모놀리포의 Nx 영향을 이해하고 최적화하기\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_0.png)\n\n- 😵‍ 왜 이대로 내버려둔 프로젝트가 영향을 받는가?\n- 🤓 영향 받은 요소\n  - 영향 받은 프로젝트\n  - 영향 받은 작업\n- 🤩 영향 받은 명령\n  - 영향 받은 실행\n  - 명령 표시\n  - Nx 그래프\n- 😶‍🌫️ 영향 받은 규칙\n  - 단계 1 - 터치된 파일 찾기\n  - 단계 2.1 - 경로별 영향 받는 노드 찾기\n  - 단계 2.2 - 작업별 영향 받는 노드 찾기\n  - 단계 2.3 - 플러그인별 영향 받는 노드 찾기\n  - 단계 2.4 - Npm 의존성으로부터 영향 받는 노드 찾기\n  - 단계 2.5 - TypeScript 구성에서 영향 받는 노드 찾기\n  - 단계 2.6 - 글로벌 파일에서 영향 받는 노드 찾기\n  - 단계 3 - 영향 받는 그래프 생성\n- 🧐 영향 조사\n  - Nx 그래프 사용\n  - 디버깅\n- 🤕 영향 해결\n  - 앱/라이브러리를 잘 분리\n  - 엄격한 명명된 입력\n  - 영향 수정\n  - Nx 패치\n- 🙂 마지막으로\n\n# 😵‍ 왜 이대로 내버려둔 프로젝트가 영향을 받게 되었을까?\n\n<div class=\"content-ad\"></div>\n\n이 질문은 매일 듣는 질문입니다! 이 질문은 제가 Nx Affected 프로세스의 디버깅 세션으로 많은 시간을 소비하게 한 질문입니다.\n\n본 문서에서는 Nx의 영향을 받는 프로세스가 어떻게 작동하는지 이해하는 데 필요한 모든 통찰력을 제공하여 그 질문에 대한 답변을 도와드리겠습니다.\n\n# 🤓 영향 프로세스 알림\n\nMonorepo에서 큰 코드베이스에서 작업할 때 여러 응용 프로그램과 라이브러리를 포함하는 저장소가 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n당신의 Monorepo가 성장함에 따라 CI에서 모든 앱/라이브러리를 재빌드하는 데 시간이 오래 걸릴 수 있습니다. 영향을 받는 앱/라이브러리만 다시 실행할 수 있는 능력은 소프트웨어 개발 주기를 크게 단축시킬 수 있습니다.\n\n## 영향을 받는 프로젝트\n\n앱/라이브러리를 수정하면 해당 앱/라이브러리 및 이에 종속된 다른 모든 앱/라이브러리에도 영향을 줍니다:\n\n![영향을 받는 프로젝트](/assets/img/2024-06-19-DeepDiveintoNxAffected_1.png)\n\n<div class=\"content-ad\"></div>\n\n앱/라이브러리 간의 종속성을 이해하기 위해 Nx는 모든 노드(앱/라이브러리), 외부 노드(npm) 및 그들 간의 모든 종속성을 포함한 프로젝트 그래프를 생성합니다.\n\n## 영향 받는 작업\n\n전체 앱/라이브러리에 대한 수정의 영향을 고려하는 것만으로 충분하지 않습니다. 예를 들어, 앱 내의 테스트를 변경한다고 해서 그 앱 전체를 다시 빌드해야 하는 것은 아닙니다. 테스트만 다시 실행하면 됩니다:\n\n![Afftected Task](/assets/img/2024-06-19-DeepDiveintoNxAffected_2.png)\n\n<div class=\"content-ad\"></div>\n\n앱/라이브러리 간 작업 종속성을 이해하기 위해 Nx는 작업에 의해 앱/라이브러리가 연결된 노드로 Task Graph를 생성합니다.\n\n## 🤩 영향을 받는 명령어\n\nNx는 어떤 프로젝트/작업이 영향을 받았는지 식별하는 여러 방법을 제공합니다.\n\n### 영향을 받는 실행\n\n<div class=\"content-ad\"></div>\n\n주로 CI에서 사용하는 주요 명령어는 Nx 영향을 받는 명령어입니다:\n\n```js\nnx affected -t lint test build\n```\n\n![Deep Dive into Nx Affected](/assets/img/2024-06-19-DeepDiveintoNxAffected_3.png)\n\n이 명령어를 사용하면 영향을 받는 작업 목록만 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Show Command\n\n또 다른 유용한 명령어는 직접적인 개요를 얻을 수 있는 Nx show 명령어입니다:\n\n```js\nnx show projects --affected\n```\n\n<img src=\"/assets/img/2024-06-19-DeepDiveintoNxAffected_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 명령은 콘솔에서 영향을 받는 프로젝트/작업을 직접 확인하고 결과를 JSON 파일로 내보내는 것을 가능하게 합니다.\n\n## Nx 그래프\n\n만약 영향을 받는 프로젝트/작업의 경로를 추적하고 UI 시각화가 필요하다면, 다음 명령을 사용하여 Nx 그래프를 열 수 있습니다:\n\n```js\nnx graph --affected\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식의 코드입니다.\n\n\n![이미지1](/assets/img/2024-06-19-DeepDiveintoNxAffected_5.png)\n\n그래프를 확인할 수 있는 웹 페이지가 열립니다:\n\n![이미지2](/assets/img/2024-06-19-DeepDiveintoNxAffected_6.png)\n\n## 😶‍🌫️ 영향 받는 규칙\n\n\n<div class=\"content-ad\"></div>\n\nNx 영향을 받는 프로세스는 여러 단계를 거치며 어떤 프로젝트가 영향을 받을 수 있는지 결정하기 위해 여러 파일 및 구성을 고려합니다:\n\n![Nx 영향 받은 내용 탐색](/assets/img/2024-06-19-DeepDiveintoNxAffected_7.png)\n\n## 단계 1 - 변경된 파일 찾기\n\nNx는 영향을 받는 프로젝트의 목록을 계산하기 전에 수정/변경된 파일 목록을 로드합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_8.png)\n\nNx는 대상 영향을 받은 베이스 이후의 수정된 파일을 계산합니다.\n\n기본적으로 베이스는 기본 브랜치이지만, -base 및 -head 옵션을 사용하여 수정할 수 있습니다.\n\n아직 커밋되지 않거나 추적되지 않은 모든 수정된 파일도 추가됩니다. -uncommitted 또는 -untracked 옵션을 사용하여 동작을 변경할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n만약 Nx에게 파일 목록을 계산하지 않았으면, -files 옵션을 사용하여 직접 파일 목록을 제공할 수 있습니다.\n\n.gitignore 또는 .nxignore에서 패턴과 일치하는 파일들은 무시됩니다.\n\n## 단계 2.1 - 경로에서 영향을 받는 노드 찾기\n\n모든 변경된 파일이 정의되었을 때, Nx는 해당 파일들이 프로젝트에 어떻게 영향을 줄 수 있는지 확인합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_9.png)\n\n가장 일반적인 규칙은 파일 경로가 프로젝트 루트 경로와 일치하는지 확인하는 것입니다.\n\n## 단계 2.2 - 작업에서 영향을받는 노드 찾기\n\nNx 작업을 실행할 때 두 가지 개념이 고려됩니다:\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-DeepDiveintoNxAffected_10.png)\n\n- 작업 실행 중에 소스 자산을 정의하는 데 사용되는 입력입니다.\n- Nx에 의해 캐시되는 작업 결과인 출력입니다.\n\n자바스크립트의 순수 함수와 유사하게, 입력이 변경되지 않았다면 출력도 동일해야 합니다.\n\n입력 목록을 재사용하기 쉽게 하려면 nx.json 또는 project.json에서 Named Inputs를 사용하여 정의할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  \"namedInputs\": {\n    \"default\": [\"{projectRoot}/**/*\", \"sharedGlobals\"], // 기본 입력값\n    \"production\": [\"default\", \"!{projectRoot}/jest.config.ts\"], // 프로덕션 입력값\n    \"sharedGlobals\": [] // 공유 전역 입력값\n  }\n}\n```\n\n그런 다음, 해당 값을 nx.json 또는 project.json의 대상 또는 실행기에 할당하십시오:\n\n```js\n\"targetDefaults\": {\n  \"build\": {\n    \"inputs\": [\"production\", \"^production\"]\n  },\n  \"test\": {\n    \"inputs\": [\"default\", \"^production\", \"{workspaceRoot}/jest.preset.js\"],\n  },\n}\n```\n\n파일을 변경하더라도 해당 작업 목록에는 영향을 미치지 않습니다:\n\n<div class=\"content-ad\"></div>\n\n아래 이미지를 확인해주세요👇\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_11.png)\n\n만약 파일을 터치하면, 영향을 받는 프로젝트 목록은 각 작업/실행자의 입력 구성에 따라 달라집니다.\n\n## 단계 2.3 - 플러그인에서 영향 받은 노드 찾기\n\nNx 프로젝트 크리스털과 추론된 구성을 통한 Nx 플러그인의 일반화로 인해 Nx는 플러그인 패턴이 터치된 파일 목록에 영향을 받는지도 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-DeepDiveintoNxAffected_12](/assets/img/2024-06-19-DeepDiveintoNxAffected_12.png)\n\n예를 들면, 파일을 삭제하거나 이동하면 Nx는 해당 프로젝트가 삭제되었다고 가정하고 모든 프로젝트를 영향을 받는 것으로 표시합니다.\n\n## 단계 2.4 - Npm 종속성에서 영향받는 노드 찾기\n\n만약 package.json이 수정되면, Nx는 어떤 것이 정확히 변경되었는지 이해하기 위해 스마트한 접근법을 사용합니다.\n\n\n<div class=\"content-ad\"></div>\n\n만약 npm 라이브러리를 수정한다면, Nx는 해당 라이브러리를 사용하는 모든 프로젝트를 찾아서 영향을 받는 것으로 표시합니다. 만약 @types/* 라이브러리를 수정한다면, Nx는 관련 라이브러리를 추출하여 동일한 원리로 라이브러리를 수정하는 것과 같은 원리를 적용합니다.\n\n만약 nx.json 플러그인에서 사용하는 라이브러리를 수정하거나 삭제한다면, 모든 프로젝트가 영향을 받는 것으로 간주됩니다:\n\n![image](/assets/img/2024-06-19-DeepDiveintoNxAffected_13.png)\n\n기본적으로 패키지 매니저 락 파일을 수정하는 것은 모든 프로젝트에 영향을 줍니다:\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 표현해 보겠습니다.\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_14.png)\n\n이 동작은 nx.json 파일의 projectsAffectedByDependencyUpdates를 사용하여 수정할 수 있습니다:\n\n```js\n\"pluginsConfig\": {\n    \"@nx/js\": { \n        \"projectsAffectedByDependencyUpdates\": \"auto\"\n    }\n}\n```\n\n옵션:\n\n<div class=\"content-ad\"></div>\n\n- 모든: 모든 프로젝트에 영향을 미칩니다.\n- 자동: 수정된 종속성과 관련된 프로젝트에만 영향을 줍니다.\n- 문자열[]: 프로젝트 목록을 정의합니다.\n\n## 단계 2.5 - TypeScript 구성에서 영향 받는 노드 찾기\n\n전역 TypeScript 구성을 수정하면 영향을 받는 노드 목록도 변경될 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_15.png)\n\n<div class=\"content-ad\"></div>\n\n만약 경로가 수정되면, Nx는 루트 경로와 일치하는 관련 프로젝트에 영향을 줍니다. 그러나 전역 구성을 수정하거나 경로를 삭제할 경우 모든 프로젝트에 영향을 줍니다.\n\n## 단계 2.6 - 글로벌 파일로부터 영향을 받는 노드 찾기\n\n기본적으로 nx.json을 수정하면 모든 프로젝트에 영향을 줍니다.\n\n![Nx Affected](/assets/img/2024-06-19-DeepDiveintoNxAffected_16.png)\n\n<div class=\"content-ad\"></div>\n\n## 단계 3 - 영향을 받은 그래프 생성\n\n영향을 받는 모든 노드를 식별한 후에, Nx는 영향을 받는 노드, 외부 노드 및 종속성이 최종적으로 영향을 받는지 확인하기 위해 영향을 받는 그래프를 생성합니다.\n\nNx는 영향을 받는 노드를 가져와 프로젝트 그래프의 모든 종속성을 재귀적으로 검색합니다:\n\n![Afftected Graph Example](/assets/img/2024-06-19-DeepDiveintoNxAffected_17.png)\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 영향을 받는 노드인 lib10이 lib4에서 사용되고 lib4는 app1에서 사용된다면, 이 모든 노드가 영향 받는 프로젝트 그래프에 추가됩니다.\n\nNx는 externalNodes에도 동일한 원칙을 적용합니다:\n\n![image](/assets/img/2024-06-19-DeepDiveintoNxAffected_18.png)\n\n예를 들어, 영향을 받는 npm 라이브러리인 enquirer가 npm 라이브러리인 nx에 의해 사용되고 nx가 내부 라이브러리 tools에 사용되는 경우입니다.\n\n<div class=\"content-ad\"></div>\n\n지금까지 영향을 받는 그래프가 완전한지 확인하려면 Nx가 관련 종속성을 추가할 것입니다.\n\n# 🧐 영향 분석\n\n여전히 특정 브랜치에서 일부 프로젝트가 영향을 받는 이유를 모르겠다면 언제든지 Nx 영향 프로세스를 디버깅할 수 있습니다.\n\n## Nx 그래프 사용하기\n\n<div class=\"content-ad\"></div>\n\n만약 영향을 받는 명령어로 Nx 그래프를 열면, 🤓 영향을 받는 프로젝트 섹션에 명시된 대로 모든 영향을 받는 프로젝트를 볼 수 있습니다.\n\n그런 다음 워크스페이스를 탐색하고 프로젝트 포커스나 의존성 추적기와 같은 여러 기능을 사용할 수 있습니다.\n\n## 디버깅\n\n그러나 대규모 저장소의 경우, 그래프는 디버깅에 사용하기 어려울 수 있습니다. 제가 선호하는 방법은 Nx-affected 프로세스를 디버깅하여 정확히 어떤 단계가 책임을 지고 있는지를 확인하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n패키지/nx/src/command-line/affected/affected.ts에서 중단점을 설정하고 디버그 모드에서 nx show project --affected를 실행해보세요.\n\n# 🤕 영향을 받는 수정 사항\n\n영향을 받는 프로세스를 사용자 정의하는 것은 간단하지 않습니다. 각 수정에 너무 많은 프로젝트가 영향을 받는다고 생각한다면 몇 가지 권장 사항을 살펴보세요:\n\n## 어플리케이션/라이브러리의 잘 구분된 분리\n\n<div class=\"content-ad\"></div>\n\n앱/라이브러리를 정확히 분할했는지 확인해 주세요.\n\n자주 사용되는 라이브러리는 한 프로젝트에서 필요로 하는 유틸리티들로 구성될 수 있습니다. 이런 경우 라이브러리를 수정하는 것이 모든 프로젝트에 영향을 줄 수 있습니다.\n\n## 엄격한 Named Inputs\n\nNamed Inputs가 올바르게 구성되었는지 확인하세요. Named Inputs는 파일을 수정했을 때 해당 대상의 출력에 영향을 줄 수 있는지를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 스펙 파일을 수정하면 테스트에 영향을 미칠 수 있지만 빌드에는 영향을 주지 않을 수 있습니다. 기본 명명된 입력을 사용하면 한 파일을 수정하면 프로젝트의 모든 대상에 영향을 줄 수 있습니다.\n\n## 영향을 받는 사용자 정의\n\n현재, 영향을 받는 프로세스에 대한 사용자 정의가 제한적으로 제공됩니다. 의존성을 업데이트할 때 configuration projectsAffectedByDependencyUpdates를 사용하여 사용자 정의할 수 있습니다(Step 2.4 — Npm Dependencies로부터 영향을 받는 노드 찾기).\n\n## Nx 패치\n\n<div class=\"content-ad\"></div>\n\n이것은 조작적인 해결책이지만, 나는 영향을 받는 프로세스를 사용자 정의하기 위해 그것을 사용합니다. 패키지 관리자의 패치 시스템을 사용하여 Nx 라이브러리를 패치하여 규칙을 변경할 수 있습니다.\n\n예를 들어, 수정하는 데 시간이 걸리는 경우 \"Affected All\" 사용 사례를 비활성화할 수 있습니다:\n\n```js\ndiff --git a/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js b/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js\nindex 72e78e7..7793bea 100644\n--- a/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js\n+++ b/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js\n@@ -20,7 +20,8 @@ const getTouchedNpmPackages = (touchedFiles, _, nxJson, packageJson, projectGrap\n             c.path.length === 2) {\n             // 패키지가 삭제되었으므로 모든 워크스페이스 프로젝트를 터치로 표시합니다.\n             if (c.type === json_diff_1.JsonDiffType.Deleted) {\n-                touched = Object.keys(projectGraph.nodes);\n+                // 패키지가 삭제된 경우 영향을받은 모든 프로젝트에 적용하지 않도록 패치\n+                // touched = Object.keys(projectGraph.nodes);\n                 break;\n             }\n             else {\ndiff --git a/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js b/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js\nindex bac7008..37ae136 100644\n--- a/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js\n+++ b/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js\n@@ -24,7 +24,8 @@ const getTouchedProjectsFromTsConfig = (touchedFiles, _a, _b, _c, graph) => {\n         }\n         // 경로가 삭제된 경우 모든 것이 터치됩니다\n         if (change.type === json_diff_1.JsonDiffType.Deleted) {\n-            return Object.keys(graph.nodes);\n+            // 경로가 삭제된 경우 영향을 받은 모든 프로젝트에 적용하지 않도록 패치\n+            // return Object.keys(graph.nodes);\n         }\n         touched.push(...getProjectsAffectedByPaths(change, Object.values(graph.nodes)));\n     }\ndiff --git a/node_modules/nx/src/project-graph/affected/affected-project-graph.js b/node_modules/nx/src/project-graph/affected/affected-project-graph.js\nindex 5665c8d..d5a69aa 100644\n--- a/node_modules/nx/src/project-graph/affected/affected-project-graph.js\n+++ b/node_modules/nx/src/project-graph/affected/affected-project-graph.js\n@@ -12,7 +12,8 @@ async function filterAffected(graph, touchedFiles, nxJson = (0, configuration_1.\n     const touchedProjectLocators = [\n         workspace_projects_1.getTouchedProjects,\n         workspace_projects_1.getImplicitlyTouchedProjects,\n-        project_glob_changes_1.getTouchedProjectsFromProjectGlobChanges,\n+        // 플러그인 패턴 일치 변경 파일에 영향을주지 않도록 패치\n+        // project_glob_changes_1.getTouchedProjectsFromProjectGlobChanges,\n         touched_projects_1.getTouchedProjects,\n     ];\n     const touchedProjects = [];\ndiff --git a/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js b/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js\nindex c5aec64..edaa989 100644\n--- a/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js\n+++ b/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js\n@@ -16,7 +16,8 @@ const getTouchedProjects = (touchedFiles, projectGraphNodes) => {\n exports.getTouchedProjects = getTouchedProjects;\n const getImplicitlyTouchedProjects = (fileChanges, projectGraphNodes, nxJson) => {\n     const implicits = {\n-        'nx.json': '*',\n+        // nx.json이 변경된 경우 영향을받은 모든 파일에 적용하지 않도록 패치\n+        // 'nx.json': '*',\n     };\n     Object.values(projectGraphNodes || {}).forEach((node) => {\n         const namedInputs = {\n```\n\n# 🙂 마지막으로 생각해보세요\n\n<div class=\"content-ad\"></div>\n\n보시다시피, 영향을 받는 프로세스는 수정된 파일 목록을 고려하는 것뿐만 아니라 다른 여러 요소를 기반으로 프로젝트 목록을 계산합니다.\n\n이로 인해 조사가 항상 간단하지는 않고 종종 영향을 받는 모든 상황으로 이어질 수 있습니다.\n\n일부 부분을 명확히 하고 영향을 받는 프로세스를 더 잘 이해하기 위한 핵심을 제공했기를 바랍니다.\n\n미래에는 종속성 업데이트에 의해 영향을 받는 프로젝트와 같은 옵션 목록을 일반화하여 영향을 받는 프로세스에 대한 더 많은 사용자 정의 옵션이 있기를 희망합니다.\n\n<div class=\"content-ad\"></div>\n\n곧 시작됩니다 🚀\n\n# 관련된","ogImage":{"url":"/assets/img/2024-06-19-DeepDiveintoNxAffected_0.png"},"coverImage":"/assets/img/2024-06-19-DeepDiveintoNxAffected_0.png","tag":["Tech"],"readingTime":13},{"title":"골프 클럽 헤드 속도를 측정하는 장치를 위한 펌웨어를 개발했어요","description":"","date":"2024-06-19 22:58","slug":"2024-06-19-IDevelopedFirmwareforaDeviceThatMeasuresGolfClubHeadSpeed","content":"\n\n## 프로그래밍\n\n![이미지](/assets/img/2024-06-19-IDevelopedFirmwareforaDeviceThatMeasuresGolfClubHeadSpeed_0.png)\n\n저는 프로그램 개발의 어려움을 보여주는 경험을 여러분과 공유하고 싶습니다. 이 경험은 프로젝트의 규모나 사용된 프로그래밍 언어와 무관하게 여전히 적용 가능하다고 믿기 때문입니다.\n\n이 클라이언트는 아마도 중소 규모의 비상장 회사였습니다. 따라서 예산이 많은 회사와 비교하여 예산이 적었고, 이 프로젝트에는 하드웨어 엔지니어 한 명과 펌웨어 엔지니어인 저 한 명이 참여했습니다.\n\n<div class=\"content-ad\"></div>\n\n어쭈도 골프 경험이 없었지만, 마스터스 토너먼트와 영국 오픈을 즐겁게 관람할 만큼 관련 정보는 알고 있었어요.\n\n시스템은 매우 간단해요. 골프공을 놓을 티와 LED 및 광 센서 두 세트로 구성되어 있어요 (다이어그램을 참고해주세요; 조금 별로에요). 이 시스템은 골프 클럽 헤드가 센서 A를 통과하는 데 걸리는 시간과 센서 B가 공을 쳤음을 감지하는 시간을 측정해요.\n\n## 펌웨어 소프트웨어로서:\n\n- 골프공이 티에 놓이고 센서 B가 그림자에 가려지면, 센서는 측정 대기 상태로 전환돼요.\n- 타이머는 클럽 헤드가 센서 A를 가려는 순간부터 시작돼요.\n- 헤드가 공을 치고 센서 B가 드러날 때, 타이머는 멈추고 PC에 시간을 알려주어요.\n\n<div class=\"content-ad\"></div>\n\n그거 다야. \n\n나는 기술대학의 첫 번째 프로그래밍 과제로서 충분히 도전적일 것 같아. 그리고 화면을 통해 디버깅할 방법이 없었기 때문에, OS나 개발 환경이 없었어.\n\n장치에서 실행하기 위해서는 코드를 ROM 라이터로 ROM에 작성해야 했기 때문에 이를 작동시키려고 애를 쓰곤 했어. 그래도 난 골프 채가 없었고 공을 한 번도 쳐본 적이 없었기 때문에 신문지를 말아 골프공 모양을 만들고, 손을 채로 이용해 말아진 신문지를 쳐보고 작동 여부를 확인했지.\n\n그때 이 제품 아이디어를 냈던 경영진이 우연히 지나가더니, 그가 직접 클럽으로 골프공을 치기로 결정해버렸어.\n\n<div class=\"content-ad\"></div>\n\n클럽을 기뻐하며 가져가 공을 놓았어요. 우리가 공을 치기 전에 큰 실수를 저질렀다는 것을 깨달았고, 문제가 있다고 공식에게 말하고 테스트를 멈추었어요.\n\n볼을 치기 전에 클럽 머리를 공 옆에 두어 접촉하도록 해요. 이 과정은 한 번만 하지만, 공식은 머리를 공 옆에 두고 두세 번 움직여요.\n\n우리 시스템은 센서 B가 첫 번째 주소의 빛에 의해 가려질 때부터 측정을 시작하고 해당 주소 액션 동안 시간을 측정하기 때문에, 머리 속도만을 고려하는 게 아니에요.\n\n해결책은 간단했어요. 센서 B가 어느 정도의 시간(약 0.5초라고 생각해요) 동안 빛에 가려지고 공이 치워지지 않으면 리셋되어 측정을 위해 대기 상태로 들어갔어요.\n\n<div class=\"content-ad\"></div>\n\n그래서 누가 잘못했었나요?\n\n그것이 옳은 일이 될 수도 있지만, 저는 그것이 매우 어려운 일이라고 생각해요. 비즈니스 시스템이나 웹 프론트 엔드든, 우리는 핵심 요구 사항을 알고 있지만 의식적으로 인식되지 않는 시스템 개발에 필수적인 숨겨진 요구 사항이 항상 있다고 생각해요.\n\n그것들을 \"잠재 의식적 요구 사항\"이라고 불러보는 것이 더 좋을 수도 있어요. 본 영업에 관해서는 우리 의식의 큰 부분이지만, 무의식적으로 작은 세부 사항을 다루는 것은 인간에게도 큰 장점이 되요.\n\n이 시스템은 골프 매장을 위한 시스템의 일부 였는데, 충격 시 클럽이 비틀리는 정도를 측정하고 각 골퍼에게 가장 적합한 클럽 유형을 결정해요. 만약 우리 중 한 명이 골프 애호가였다면, 이것을 깨달았을 수도 있었지만, 이런 상황은 거의 발생하지 않아요. 매 우리와 시스템 고객 사이에 일어나는 건드림이 나지 않을 때요.\n\n<div class=\"content-ad\"></div>\n\n시스템을 개발할 때 중요 요구사항과 상세 요구사항은 인간에게 동일한 의미를 갖고 있다고 할 수 있으며, 종종 중요 요구사항이 충족되지 않으면 만족시킬 수 없다는 경우가 많습니다.\n\n소프트웨어 개발의 어려움은 \"잠재적 요구사항\"의 존재에 있지 않을까 싶습니다.\n\n믿을 만한 각종 시스템 분석 방법이나 개발 방법(예: agile 방법)이 결국은 근본적인 요구사항을 명확히 하는 방법에 종속되어 있다고 생각해요.\n\n# 간단한 문장으로 설명하기 🚀\n\n<div class=\"content-ad\"></div>\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클립하고 팔로우해주세요 ️👏️️\n- 저희를 팔로우해주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-06-19-IDevelopedFirmwareforaDeviceThatMeasuresGolfClubHeadSpeed_0.png"},"coverImage":"/assets/img/2024-06-19-IDevelopedFirmwareforaDeviceThatMeasuresGolfClubHeadSpeed_0.png","tag":["Tech"],"readingTime":3},{"title":"시니어 개발자로서 꽁수 잘부리는데 꼭 알아야 할 10가지 JavaScript 배열 함수","description":"","date":"2024-06-19 22:56","slug":"2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev","content":"\n\n![이미지](/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_0.png)\n\n복잡한 웹 개발 프로젝트 중간에 있다고 상상해보세요. 여러 API에서 데이터가 들어오고, 그 데이터를 효율적으로 처리, 필터링 및 분석하는 것이 여러분의 임무입니다. 시간이 촉박하기 때문에 코드 한 줄 한 줄이 중요합니다.\n\n이런 때에 고급 JavaScript 배열 메서드를 배워두면 정말 도움이 됩니다.\n\n이러한 함수들은 코드를 줄이는데 그치지 않고 성능을 개선하고 개발 기술을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n시니어 개발자라면 복잡한 작업을 빠르고 정확하게 수행할 수 있도록 알아야 하는 상위 열 가지 배열 함수를 살펴보겠습니다.\n\n![array functions](https://miro.medium.com/v2/resize:fit:1400/1*zW-nrCob0sk8V4zQYCRXTQ.gif)\n\n# 필수 10가지 배열 함수\n\n## 1. forEach()\n\n<div class=\"content-ad\"></div>\n\n당신은 배열의 각 항목을 방문하고 설정한 작업을 완료하는 신뢰할만한 도우미가 필요할 수 있습니다. 이것이 forEach()의 개요입니다.\n\n각 요소에서 실행되는 콜백 함수를 사용하므로 로깅, DOM 수정 및 데이터 조작과 같은 부작용에 적합합니다.\n\n```js\nconst fruits = [\"사과\", \"바나나\", \"체리\"];\n\nfruits.forEach(fruit => console.log(fruit));\n```\n\n## 2. map()\n\n<div class=\"content-ad\"></div>\n\n현재 배열을 기반으로 한 새로운 배열이 필요하다면 어떨까요? map() 함수는 각 요소에 콜백 함수를 적용한 결과로 새로운 배열을 생성합니다.\n\n이 함수는 데이터 세트를 추출하고 데이터를 제공하며 계산을 수행하는 데 완벽합니다.\n\n```js\nconst numbers = [1, 2, 3, 4];\n\nconst doubledNumbers = numbers.map(number => number * 2);\nconsole.log(doubledNumbers);\n\n// 출력 [2, 4, 6, 8]\n```\n\n## 3. filter()\n\n<div class=\"content-ad\"></div>\n\n특정 요소만 VIP 영역에 접근할 수 있도록 확인하는 상황을 상상해 보세요. filter()는 콜백 함수 기반 테스트를 통과하는 항목만 포함된 새 배열을 생성합니다.\n\n기준을 사용하여 데이터를 필터링하거나 원치 않는 항목을 제거하거나 사용자 지정 부분 배열을 만들 때 사용할 수 있습니다.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\n\nconst evenNumbers = numbers.filter(number => number % 2 === 0);\nconsole.log(evenNumbers); \n\n// 결과 [2, 4]\n``` \n\n## 4. reduce()\n\n<div class=\"content-ad\"></div>\n\n`reduce()`은 전체 배열을 단일 값으로 통합해주는 무술 마스터입니다. 콜백 함수를 사용하여 작동합니다.\n\n이 함수는 매우 유연하여 합계 및 평균을 계산하거나, 최대 및 최소 값을 찾는 것뿐만 아니라 복잡한 데이터 구조를 만드는 데도 사용할 수 있습니다.\n\n```js\nconst numbers = [1, 2, 3, 4];\n\nconst sum = numbers.reduce((accumulator, current) => accumulator + current, 0);\nconsole.log(sum); \n\n// 결과: 10\n```\n\n## 5. find()\n\n<div class=\"content-ad\"></div>\n\n지정된 조건을 충족시키는 첫 번째 부분을 찾아야 하는가요? find()가 도와줄 것입니다.\n\n이것은 콜백 함수에 의해 주어진 테스트를 통과하는 첫 번째 부분의 값을 반환하며, 빠른 조회와 전체 배열 루프를 제거하는 데 유용합니다.\n\n```js\nconst numbers = [1, 2, 4, 5];\n\nconst firstGreaterThanThree = numbers.find(number => number > 3);\nconsole.log(firstGreaterThanThree);\n\n// 출력: 4\n```\n\n## 6. findIndex()\n\n<div class=\"content-ad\"></div>\n\nfindIndex()은 find()보다 한 단계 더 나아가서, 콜백 테스트를 통과하는 첫 번째 요소의 인덱스를 반환합니다.\n\n배열 내에서 특정 데이터를 찾을 때, 배열에서의 위치에 따라 항목을 변경하고 집중적인 작업을 수행할 때 유용합니다.\n\n```js\nconst numbers = [1, 2, 4, 5];\n\nconst indexOfFirstGreaterThanThree = numbers.findIndex(number => number > 3);\nconsole.log(indexOfFirstGreaterThanThree);\n\n// 출력: 2\n```\n\n## 7. some()\n\n<div class=\"content-ad\"></div>\n\n특정 조건을 충족하는 항목이 배열에 있는지 확인해야 할 때가 있었나요? some() 메서드가 도움이 됩니다.\n\n콜백 함수에 의해 수행된 테스트를 통과하는 요소가 최소 한 개 이상 있는지 찾습니다.\n\n조건을 확인하거나 입력을 유효성 검사하거나 단일 일치하는 요소가 충분할 때 로직을 간단히 작성하는 데 사용할 수 있습니다.\n\n```js\nconst numbers = [1, 5, 8, 12];\n\nconst hasElementGreaterThanTen = numbers.some(number => number > 10);\nconsole.log(hasElementGreaterThanTen);\n\n// 결과: true\n```\n\n<div class=\"content-ad\"></div>\n\n## 8. every()\n\nevery()은 some()의 엄격한 형제입니다. 배열 내 모든 항목이 콜백 함수에 의해 제공된 테스트를 통과하는 것을 보장합니다.\n\n이는 데이터 유효성 검사, 지정된 구조를 따르는 각 요소 확인 및 품질 검사에 유용합니다.\n\n```js\nconst data = [\"apple\", \"banana\", 10];\n\nconst allStrings = data.every(element => typeof element === \"string\");\nconsole.log(allStrings);\n\n// 결과: false\n```\n\n<div class=\"content-ad\"></div>\n\n## 9. includes()\n\n가끔은 배열 안에 특정 값이 있는지 여부를 알고 싶을 때가 있습니다. includes()는 간단한 유효성 검사를 위한 최고의 친구입니다.\n\n주어진 값이 배열에 존재하는지 빠르게 확인하여 개별 데이터 포인트 식별이나 배열 멤버십에 기반한 조건부 논리 생성에 중요합니다.\n\n```js\nconst fruits = [\"apple\", \"banana\", \"cherry\"];\n\nconst hasOrange = fruits.includes(\"orange\");\nconsole.log(hasOrange);\n\n// 출력: false\n```\n\n<div class=\"content-ad\"></div>\n\n## 10. flat()\n\n다차원 배열이나 배열 안에 배열을 본 적이 있나요? 혼동스러울 수 있습니다. `flat()` 함수는 이를 닯은 배열로 변환하여 도와줍니다.\n\n중첩된 배열을 간단하게 만들거나, 중첩 구조를 갖는 API로부터 데이터 작업을 할 때 유용하며, 추가 처리를 위해 데이터를 저장하는 데 도움이 됩니다.\n\n```js\nconst nestedArray = [1, [2, 3], 4];\n\nconst flattenedArray = nestedArray.flat();\nconsole.log(flattenedArray);\n\n// 출력: [1, 2, 3, 4]\n```\n\n<div class=\"content-ad\"></div>\n\n# 몇 가지 전술\n\n기본적인 내용을 배웠으니, 학습 범위를 확장할 몇 가지 고급 주제를 살펴보겠습니다:\n\n## 배열 메소드 연결\n\n여러 배열 메소드를 연결하여 복잡한 변화를 만들어내어 명확하고 이해하기 쉬운 결과를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 배열에서 짝수만 걸러내고 해당 숫자들을 한 줄에 연관 있는 제곱값으로 매핑할 수 있습니다:\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\n\nconst evenSquares = numbers.filter(number => number % 2 === 0)\n                           .map(number => number * number);\n\nconsole.log(evenSquares);\n\n// Output: [4, 16]\n```\n\n## 사용자 정의 콜백 함수\n\n많은 배열 함수가 콜백 함수에 의존함을 기억하세요.\n\n<div class=\"content-ad\"></div>\n\n극단적인 상황을 처리할 수 있는 강력하고 명확하게 정의된 콜백을 만들어주세요. 데이터 타입을 명시하여 타입 안전성을 보장하고 코드 유지보수성을 높일 수 있습니다.\n\n예를 들어, 숫자가 짝수인지 확인하는 잘 정의된 콜백은 다음과 같이 보일 수 있습니다:\n\n```js\nfunction isEven(number) {\n  if (typeof number !== 'number') {\n    throw new TypeError('입력값은 숫자여야 합니다');\n  }\n  return number % 2 === 0;\n}\n```\n\n## 에러 처리\n\n<div class=\"content-ad\"></div>\n\n예기치 못한 데이터나 누락된 조각은 오류를 발생시킬 수 있습니다.\n\n배열 함수 내에서 발생할 수 있는 가능한 오류를 다루는 방법을 논의해보세요.\n\n예외 처리를 세련되게 다루기 위해 try-catch 구성 요소를 사용할 수 있습니다:\n\n```js\nconst numbers = [1, \"two\", 3];\n\ntry {\n  const doubledNumbers = numbers.map(number => number * 2);\n  console.log(doubledNumbers);\n\n// [2, NaN, 6] (\"two\"에 대한 오류)\n\n} catch (error) {\n  console\n```\n\n<div class=\"content-ad\"></div>\n\n## 성능에 대한 고려사항\n\n모든 배열 메서드가 동일하게 만들어지진 않습니다. 큰 또는 복잡한 배열의 성능 영향(forEach와 for 루프의 차이 등)에 대해 간단히 논의해 봅니다.\n\n- 메모리: 많은 데이터는 시스템을 과부하로 만들 수 있습니다.\n- 루프: 대용량 배열에 접근하는 데 시간이 소요됩니다.\n- 복잡한 요소: 배열 내 복잡한 데이터를 처리하는 것은 상당히 느립니다.\n\n정말 큰 데이터 세트의 경우, 특히 최적화된 배열 함수 구현이 없을 수 있는 오래된 브라우저에서 효율성을 향상시키기 위해 전통적인 루프를 사용해 보세요.\n\n<div class=\"content-ad\"></div>\n\n## 기능적 프로그래밍\n\n배열 함수는 기능적 프로그래밍 방식에 잘 맞습니다.\n\n기능적 프로그래밍은 순수 함수(부수 효과 없음)에 집중하며 변경할 수 없는 데이터와 작업합니다.\n\n기존 데이터에서 새 배열을 구축하기 위해 배열 메서드를 사용하면 원래 데이터를 유효하게 유지하고 예측 가능성을 향상시키며 디버깅을 쉽게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 최적의 방법들\n\n- 함수 결합: 앞서 언급한대로 여러 작업을 연결하여 빠르고 강력한 작업을 수행하는 데 도움이 됩니다. 실험하고 섞어 복잡한 변경을 한 줄로 만들어보는 것을 두려워하지 마세요.\n- 불변성: 가능할 때마다 이전 배열을 변경하는 대신 새로운 배열을 만드는 것을 시도해보세요. 이렇게 하면 가독성이 향상되고 원하지 않는 효과의 위험이 줄어듭니다. map, filter, slice와 같은 메서드를 사용하여 새로운 배열을 만들어보세요.\n- 오류 처리: 이상한 입력이나 누락된 항목을 잡기 위해 콜백 습관에 작동하는 오류 처리를 항상 사용하세요. 이렇게 하면 결합 오류로 프로그램이 충돌하는 것을 방지할 수 있습니다.\n\n# 마지막으로\n\n이 10가지 배열 메서드를 마스터하면 JavaScript 초보자에서 어딘가로 (믿어주세요, 당신의 레벨이 올라갈 거에요).\n\n<div class=\"content-ad\"></div>\n\n아래는 마크다운 형식의 코드입니다.\n\n\nYou’ll be able to create code that is easier to understand, more efficient, and more flexible, letting you work with data more effortlessly.\n\n![Image 1](/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_1.png)\n\n![Image 2](/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_2.png)\n","ogImage":{"url":"/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_0.png"},"coverImage":"/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_0.png","tag":["Tech"],"readingTime":7},{"title":"2023년 최신 JavaScript 프레임워크 및 기술","description":"","date":"2024-06-19 22:54","slug":"2024-06-19-TopJavaScriptFrameworksandTechnology2023","content":"\n\n## TL;DR: JavaScript + React + Redux는 여전히 약세를 유지하고 있습니다. 가장 좋은 결과를 얻으려면 Next.js와 Vercel을 함께 사용하세요. AI는 SudoLang + Agents로 폭발적으로 성장 중입니다. Web3의 성장세도 강합니다.\n\n![이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_0.png)\n\n2023년 4월 11일 업데이트됨\n\n작년에 많은 변화가 있었는데, 모든 것이 혁신의 대상이 될 수 있다는 느낌이 들 수 있지만, 내가 지금까지 본 가장 혁신적인 해를 겪은 기술계에서 가장 큰 놀람은 올해 목록에서 프레임워크 생태계가 얼마나 변화하지 않았는지입니다.\n\n<div class=\"content-ad\"></div>\n\n게임판에는 많은 새로운 플레이어가 있어요. (SolidJS에 기립!) 하지만 작년의 대승자들은 여전히 올해를 주도하고 있고 구직 시장에서 많은 흔적을 남기지 않는 것으로 보입니다. (아래에 데이터로 증명되어 있습니다.)\n\n그런데 어떤 변화가 있었을까요?\n\n## AI가 개발자의 속도를 높이고 있어요\n\n2020년 GPT-3와의 첫 번째 비디오 인터뷰를 진행했을 때, 사람들은 그것이 실제로 무엇인지 이해한다고 생각하지 않았고 유용한 코드를 생성할 수 있다고는 더더욱 상상하지 못했어요.\n\n<div class=\"content-ad\"></div>\n\n지금으로 빨리 넘어가 보자—만약 Copilot 또는 ChatGPT와 같은 AI 도구를 사용하지 않거나 코드를 검토하지 않는다면 모든 개발자들이 이미 큰 불이익을 겪고 있다.\n\nGitHub은 AI 개발 도구(특히 GitHub Copilot)가 개발자 생산성에 미치는 영향을 발견하기 위해 테스트를 실시했으며, 그들이 발견한 것은 매우 흥미로웠습니다. Copilot을 사용한 45명과 사용하지 않은 50명의 개발자들을 대상으로 한 실험에서, Copilot 사용자들은 Copilot을 사용하지 않은 개발자들보다 55% 빨리 작업을 완료했습니다.\n\n![](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_1.png)\n\n## ChatGPT가 게임을 바꿨어요\n\n<div class=\"content-ad\"></div>\n\n2022년 11월, OpenAI가 ChatGPT를 발표하여 역사상 가장 빠르게 성장한 앱 중 하나가 되었습니다. 일주일 만에 100만 명이 넘는 사용자를 확보하였으며, 1월에는 1억 명의 사용자를 기록했습니다.\n\n![이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_2.png)\n\n10년 전에는 자연어 AI 프로젝트의 기술 리더였는데, 그때도 이미 가능성을 인정하여 모든 산업을 혼란시킬 수 있는 가능성을 알았습니다. 2015년 이후로 매년 이 블로그에서 이에 대해 글을 썼는데, 2020년부터 시작된 다가오는 해일을 예언하여 지금은 모든 기술 분야로 홍수처럼 밀려드는 것을 경고하였습니다. 오늘날, 이 혼란의 해양 변화는 전 세계적인 현실이 되었습니다. AI-최우선 도구들이 규모에 걸맞게 가치를 증명하고 있으며, 이제 슈퍼 리치만이 소유한 것이 아닙니다.\n\n2023년에는 더 많은 AI-최우선 도구들이 출시될 것입니다. 모델 임베딩의 힘은 스마트 챗봇과 코드 어시스턴스 도구와 같은 것들에 혁명을 일으킬 것이며, 전체 코드베이스에서 통찰을 제공하는 기능을 가진 것들이 조용히 새로운 변화를 이끌 것입니다.\n\n<div class=\"content-ad\"></div>\n\n언어 모델과 SudoLang은 개발자가 응용 프로그램을 작성하는 방식을 변화시키고 있습니다. 이제 유사 코드로 전체 함수 또는 전체 프로젝트를 작성하고 AI 에이전트가 창의적으로 응용 프로그램을 만들어 주는 것이 가능해졌습니다.\n\nLangChain과 같은 프로젝트를 활용하는 에이전트들은 언어 모델이 할 수 있는 능력의 한계를 넘어선다는 것을 입증하며, API 액세스, 검색, 응용 프레임워크 등과 연결시킴으로써 발전시키고 있습니다.\n\nChatGPT와 Codex가 멋지다고 생각했다면, 믿어봐요: 아직 끝이 아니에요.\n\n## JavaScript는 여전히 최고입니다.\n\n<div class=\"content-ad\"></div>\n\nJavaScript은 여전히 GitHub에서 가장 많이 사용되는 언어입니다. Python은 그 뒤를 이어가는데, 최근 AI 혁명으로부터 영감을 받아 인기를 얻고 있습니다.\n\n![JavaScript 이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_3.png)\n\n현재 JavaScript는 세계에서 가장 큰 오픈 소스 모듈 생태계를 보유한 성숙한 프로그래밍 언어입니다.\n\n![JavaScript 이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 프론트엔드 프레임워크\n\n올해에는 새로운 프론트엔드 프레임워크가 등장했습니다. 어떤 것이 최고인지 말하기보다는 2023년 취업 시장에서 강한 수요와 사용을 보이는 것만 알려드리려고 합니다. 다음 프레임워크에 대한 데이터를 수집해 보았습니다:\n\n- React\n- Angular\n- Vue.js\n- Svelte\n- SolidJS\n\n취업 시장\n\n<div class=\"content-ad\"></div>\n\nIndeed.com에 따르면 취업 시장에서 React는 모든 프론트엔드 프레임워크를 언급하는 모든 구인 공고 중 57% 이상에서 언급됩니다. Angular는 32.5%로 두 번째로 많이 언급됩니다.\n\n검색 관심\n\n![](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_5.png)\n\n![](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_6.png)\n\n<div class=\"content-ad\"></div>\n\nDownloads\n\n![Image](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_7.png)\n\n## 사용자 만족도\n\n자바스크립트 현황 조사 2022에서 사용자들에게 \"다시 사용하시겠습니까?\"라는 질문을 하였습니다. 일반적인 JavaScript 기술에 대한 결과는 다음과 같습니다. Next.js, Svelte, 그리고 React는 뛰어난 점수를 받았습니다. Vue.js는 합격점을 받았습니다. Angular와 Gatsby는 개선할 여지가 많습니다. 다른 옵션에 대한 데이터는 없습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_8.png\" />\n\n## 상태 관리\n\n<img src=\"/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_9.png\" />\n\n서버에서 주로 상태를 관리하는 시스템의 경우, React Query 및 RTK Query와 같은 도구들이 약간의 인기를 얻고 있으며, GraphQL은 여전히 백엔드 데이터 서비스를 유연하게 쿼리하는 좋은 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n클라이언트 측 상태를 다룰 때 Redux는 여전히 최상위 2위를 차지하는데, 이는 순서로 따지면 1만큼 앞서고 있습니다. 그럴 만한 이유가 있죠: Redux는 결정적이고 트랜잭션 기반의 상태 관리를 제공하며, 여전히 최고의 미들웨어 생태계를 갖추고 있습니다. 번거로운 부분을 싫어하시나요? Autodux, Redux Toolkit과 같은 도구를 살펴보세요. Zustand나 Jotai와 같은 대안들은 어떤 사용 사례에 대해 고려할 가치가 있으며, 수백 또는 수천 개의 요소에 대한 원자적 업데이트가 필요한 UI를 가진 경우 recoil이 좋은 선택일 수도 있습니다.\n\n## 풀 스택 프레임워크\n\n이러한 프레임워크들은 서버와 클라이언트 모두를 아우르며, 종종 훌륭한 배포 자동화 기능을 제공합니다. 요약하자면, Next.js가 편안하게 선두를 달리고 있지만, Nest.js가 근시 2위를 차지하고 있습니다. 더 기능적인 접근 방식을 즐기고 마법같은 개발자 경험과 배포 자동화에 초점을 맞출 경우, Next.js는 안전한 선택입니다.\n\nNext.js와 Vercel을 사용한다면 세계 최고의 데브옵스 팀을 고용하는 것과 같다고 말씀드리고 싶어요. 그러나 그들에게 월급을 주는 대신 돈을 절약해줍니다. 제 의견 상으로는 여전히 이 말이 맞고 여전히 최고입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-TopJavaScriptFrameworksandTechnology2023_10](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_10.png)\n\n## Web3\n\n곰 시장에도 불구하고, 암호화 자금은 2023년에도 Web3에 수십억 달러를 투자할 계획입니다. 예를 들어, a16z는 2022년에 자사의 45억 달러 펀드 4를 발표하며 암호화 투자에 더 많은 자금을 투자했습니다.\n\n2020년에는 DeFi가 큰 이슈였고 Web3의 사용량을 촉진했습니다. 그러나 2021년 이후로 NFT(토큰화되지 않은 자산)가 대체되어 비디오 게임 아이템부터 예술 및 음악까지 모든 것에 대한 증명 가능한 희소성과 소유권을 나타내고 있습니다. 지난 30일간 블록체인에서 NFT 거래량이 어떻게 되는지 확인해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_11.png)\n\n## 기본적으로 안전하게\n\n2018년에 Chrome은 http 사이트를 \"안전하지 않음\"으로 표시하기 시작할 것이라고 발표했습니다. 그로부터 안전하게 기본 설정하는 것이 더욱 중요해졌습니다.\n\n그러나 저희는 애플리케이션에 대한 생성한 id로 정보를 유출하는 습관이 있습니다. 이는 다양한 보안 문제와 사용자 개인 정보 침해로 이어질 수 있습니다. 10년 전, 저는 식별자 충돌에 관심을 가졌고, 이를 방지하기 위한 id 표준을 작성했는데, 그 후 UUID V6-V8을 영감을 받아 만들었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n그러나 Cuid의 첫 번째 버전은 투명하지 않았습니다. 정확한 id 작성 시간, 호스트 지문 및 세션 카운터를 포함한 정보가 노출되었습니다. 이 문제를 해결하기 위해 최근 Cuid2를 발표했습니다. 오늘날 앱 개발자들은 k-정렬 가능한 id 대신에 투명한 id를 사용해야 합니다.\n\n# 결론\n\n오늘날의 현대 기술 스택은 작년과 많이 닮아 있습니다. 다음은 전형적인 예입니다:\n\n- Next.js에서 React + Redux 사용. Vercel에 서버리스로 배포합니다.\n- Jest 및 Testing Library로 단위 테스트를 수행하며, Riteway의 간단함을 선호합니다.\n- Polygon에서 고주파 거래가 이루어지는 Ethereum의 Web3.\n- 비밀번호는 구식이며 보안에 취약합니다. Magic Connect 또는 Passkeys로 Web3 인증을 선호합니다.\n- Cuid2와 같이 안전하고 투명한 id 생성기를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n## 다음 단계\n\n자바스크립트 및 테스트 주도 개발에 대한 다양한 비디오 및 대화형 레슨을 원하신다면 EricElliottJS.com을 확인해보세요.\n\n1:1 멘토링을 원하신다면 DevAnywhere.io를 확인해보세요.\n\nEric Elliott은 기술 제품 및 플랫폼 고문이자 \"Composing Software\" 저자이며 EricElliottJS.com과 DevAnywhere.io의 공동 창립자이자 개발 팀 멘토입니다. 그는 Adobe Systems, Zumba Fitness, 월스트리트저널, ESPN, BBC 및 어셔(Usher), 프랭크 오션(Frank Ocean), 메탈리카(Metallica) 등 최고의 음악 아티스트들을 위한 소프트웨어 경험에 기여했습니다.\n\n<div class=\"content-ad\"></div>\n\n세계에서 가장 아름다운 여자와 함께 원격 생활을 즐기고 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_0.png"},"coverImage":"/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_0.png","tag":["Tech"],"readingTime":7},{"title":"JavaScript 개발을 간편하게 싱글톤 패턴 안내하기","description":"","date":"2024-06-19 22:52","slug":"2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide","content":"\n\n이제부터 테이블 태그를 Markdown 형식으로 변경할게요: \n\n\n![이미지](/assets/img/2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide_0.png)\n\n싱글톤 패턴(Singleton Pattern)은 클래스가 하나의 인스턴스만을 가지고 전역적인 접근 지점을 제공하는 디자인 패턴입니다. 이 패턴은 1994년 Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides가 공동으로 지은 \"Design Patterns: Elements of Reusable Object-Oriented Software\" 책에서 처음 소개되었습니다. 싱글톤 패턴은 게임 개발에서 널리 사용되지만, 자바스크립트를 포함한 웹 개발에도 광범위하게 적용됩니다.\n\n# 용어의 유래\n\n\"싱글톤(singleton)\"이라는 용어는 하나의 원소만 포함하는 단일한 집합을 나타내는 수학적 개념에서 유래되었습니다. 이 아이디어는 클래스에 대한 단일 인스턴스 개념과 일치합니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 싱글톤 패턴의 주요 기능\n\n싱글톤 패턴을 사용하면 객체들이 다음을 보장할 수 있습니다:\n\n- 하나의 인스턴스만 가지도록 보장\n- 해당 인스턴스에 쉽게 액세스 제공\n- 인스턴스화를 제어함 (예: 클래스의 생성자를 숨기지만 추상화 원칙을 완전히 따르지는 않음)\n\n# 싱글톤 패턴을 사용하는 이유?\n\n<div class=\"content-ad\"></div>\n\n싱글톤 패턴의 주요 목적은 클래스의 단일 인스턴스만 존재함을 보장하는 것입니다. 이는 클래스의 인스턴스가 참조될 때마다 항상 동일한 인스턴스가 반환되어 현재 상태를 유지할 수 있다는 것을 의미합니다. 이것은 클래스 인스턴스나 속성에 대한 단일 전역 수준 범위(액세스)를 유지해야 할 때 유용합니다.\n\n# JavaScript에서 싱글톤 패턴 사용 시나리오\n\nJavaScript에서 싱글톤 패턴을 사용하는 시나리오는 다음과 같습니다:\n\n1. 데이터베이스 연결:\n\n<div class=\"content-ad\"></div>\n\n싱글톤 패턴은 하나의 데이터베이스 연결만 필요한 애플리케이션에서 데이터베이스 연결의 인스턴스가 한 개만 생성되도록 하는 데 사용될 수 있습니다. 불필요한 연결을 방지하는 것뿐만 아니라 이를 통해 리소스 관리에 도움이 될 수 있습니다.\n\n2. 로거 서비스:\n\n싱글톤 패턴은 애플리케이션의 다양한 섹션에서 로그를 수집하고 집중하는 로깅 서비스를 구성하는 데 사용될 수 있습니다. 이를 통해 로그 기록은 한 곳으로 집중되고 로거의 설정과 상태가 전체 애플리케이션에서 일관되게 유지되도록 보장됩니다.\n\n3. 구성 관리:\n\n<div class=\"content-ad\"></div>\n\n싱글턴 패턴은 설정이 여러 코드 영역에서 접근 가능해야 하는 응용 프로그램에서 설정을 관리하고 액세스를 제공하는 데 사용할 수 있습니다. 이렇게 함으로써 설정의 진실이 하나뿐임을 보장합니다.\n\n4. 자원 관리:\n\n싱글턴 패턴을 사용하여 스레드 풀, 연결 풀 또는 캐싱 메커니즘과 같은 공유 자원을 관리할 수 있습니다. 이는 불필요한 중복을 줄이고 공통 자원에 대한 액세스를 조직하는 데 도움이 됩니다.\n\n5. 애플리케이션 상태:\n\n<div class=\"content-ad\"></div>\n\n애플리케이션이 중앙 집중형 상태를 갖는 경우, 예를 들어 React의 Redux나 Vue.js의 Vuex와 같은 상태 관리 라이브러리에서 전역 저장소가 있을 때는 주로 싱글톤 패턴을 사용하여 애플리케이션의 상태를 관리합니다.\n\n6. 인증 서비스:\n\n싱글톤 패턴은 사용자 권한 부여 및 인증을 관리하는 인증 서비스를 구축하는 데 사용될 수 있습니다. 이를 통해 애플리케이션 전반에 걸쳐 사용자의 권한 부여와 인증이 일관되게 보장됩니다.\n\n7. 작업 스케줄러:\n\n<div class=\"content-ad\"></div>\n\n싱글톤 패턴은 중앙 작업 스케줄러 또는 작업 대기열이 필요한 상황에서 사용할 수 있습니다. 이를 통해 단 하나의 인스턴스만이 스케줄링 및 작업 관리를 처리하도록 보장할 수 있습니다.\n\n8. 인쇄 스풀러:\n\n싱글 프린트 스풀러를 사용하여 프린터 스풀링이 필요한 시스템에서 모든 인쇄 작업을 담당하도록 보장할 수 있습니다.\n\n# JavaScript에서 싱글톤 패턴 구현하기\n\n<div class=\"content-ad\"></div>\n\n자바스크립트에서 싱글톤 패턴의 구현은 다음과 같은 방법으로 할 수 있어요:\n\n## 1. 함수 클로저 활용\n\n다음은 함수 클로저를 사용하여 싱글톤 패턴을 구현하는 예제입니다. 특히 JS에서는 즉시 호출하는 함수 표현식(IIFE)을 사용합니다.\n\n```js\nconst Singleton = (function() {\n  let instance;\n  function createInstance() {\n    // 여기서는 프라이빗 멤버와 메서드를 정의할 수 있어요\n    return {\n      // 여기서는 퍼블릭 메서드와 프로퍼티를 정의할 수 있어요\n      getInstance: function() {\n        if (!instance) {\n          instance = createInstance();\n        }\n        return instance;\n      },\n    };\n  }\n  return createInstance();\n})();\n\n// 인스턴스 참조하기\nconst singletonInstance1 = Singleton.getInstance();\nconst singletonInstance2 = Singleton.getInstance();\n\nconsole.log(singletonInstance1 === singletonInstance2); // 두 인스턴스가 동일한 인스턴스를 가리키므로 true\n```\n\n<div class=\"content-ad\"></div>\n\n## 2. ES6 클래스 사용\n\nES6 클래스 정의에서 \"인스턴스\" 프로퍼티는 클래스의 정적 프로퍼티로 정의할 수 있습니다. 생성자는 클래스의 단일 인스턴스만 있는지 확인합니다.\n\n```js\nclass Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      // 여기서는 비공개 멤버 및 메서드를 정의할 수 있습니다\n      Singleton.instance = this;\n    }\n    \n    return Singleton.instance;\n  }\n\n  // 여기서는 공개 메서드와 프로퍼티를 정의할 수 있습니다\n  getInstance() {\n    return Singleton.instance;\n  }\n}\n\n// 인스턴스 참조\nconst singletonInstance1 = new Singleton();\nconst singletonInstance2 = new Singleton();\n\nconsole.log(singletonInstance1 === singletonInstance2); // 둘 다 공통 인스턴스를 가리키므로 true\n```\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n싱글톤 패턴은 JavaScript에서 클래스의 단일 인스턴스를 보장하고 해당 인스턴스에 대한 전역 액세스를 제공하여 인스턴스화를 제어하는 강력한 도구입니다. 그 응용 분야는 데이터베이스 연결부터 구성 관리 이상으로 다양합니다. 싱글톤 패턴을 이해하고 구현함으로써 리소스 관리를 크게 향상시킬 수 있고 응용 프로그램의 다양한 부분 간에 일관성을 유지할 수 있습니다.\n\n싱글톤 패턴에 대해 궁금한 점이나 통찰이 있다면 말씀해주세요! 프로젝트에서 디자인 패턴을 어떻게 활용하고 있는지 대화를 나누어보겠습니다.","ogImage":{"url":"/assets/img/2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide_0.png"},"coverImage":"/assets/img/2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs를 사용하여 마이크로서비스 작성하기","description":"","date":"2024-06-19 22:49","slug":"2024-06-19-WritingAMicroserviceUsingNodejs","content":"\n\n\n![Image](/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png)\n\n자바스크립트는 프로그래밍 언어 평가에서 주요 위치를 유지하고 있습니다. 자바스크립트에는 브라우저와 Node.js 두 가지 구현이 있습니다. 후자는 웹 서비스 개발에 널리 사용됩니다.\n\nIT 경력을 시작한 지 약 여덟 년 전에 자바스크립트를 배우기 시작했고, 몇 년 전에 David Flanagan의 훌륭한 책 \"JavaScript: The Definitive Guide\"를 읽었습니다.\n\n이 책은 많은 질문에 답하고 흥미로운 자바스크립트 레시피를 보여줬는데, 이를 내 업무에 적용하고 있습니다. 그러나 더 중요한 것은, Node.js로 웹 서비스 개발에 초점을 맞추게 됐습니다 (이전에는 JS를 프론트엔드 개발에만 사용). 이 책을 새로운 자바스크립트 개발자뿐만 아니라 경험있는 개발자에게도 추천합니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 게시물에서는 Node.js를 사용하여 마이크로서비스를 구축하는 방법을 소개하려고 합니다. 웹 개발 경험을 기반으로 인기 있는 Node.js 스택을 활용하여 확장 가능하고 견고하며 신뢰성 있고 성능이 우수한 솔루션을 만들어 보겠습니다.\n\n# 소개\n\n이 글에서는 작업 관리 웹 서비스 예시에 마이크로서비스를 구축하는 방법을 보여드리려고 합니다. 다음 API를 제공할 것입니다:\n\n- 이름과 설명으로 작업 생성;\n- 식별자로 작업 가져오기;\n- 작업 상태/이름/설명 업데이트.\n\n<div class=\"content-ad\"></div>\n\nNode.js로 웹 애플리케이션을 빌드할 때 얼마나 강력한지 보여주는 간단한 API입니다. 개발 프로세스가 빠르고 쉽습니다.\n\n몇 가지 애플리케이션 요구 사항:\n\n- 작업은 상태 'new'로 생성되어야 합니다.\n- 사용 가능한 상태 전이: 'new'에서 'active'로, 'new'에서 'canceled'로, 'active'에서 'completed'로, 'active'에서 'canceled'로.\n- 경쟁 상태를 피하십시오 (자세한 내용은 나중에).\n\n주요 비기능 요구 사항은:\n\n<div class=\"content-ad\"></div>\n\n- 확장성 — 마이크로서비스는 증가하는 요청 양을 처리할 수 있어야 합니다.\n- 탄력성 — 마이크로서비스는 즉각 처리할 수 있어야 합니다.\n- 성능 — 마이크로서비스는 빠르게 응답하여 더 나은 사용자 경험을 제공해야 합니다.\n- 복원력 — 마이크로서비스는 장애에 대해 허용하고 회복할 수 있어야 하므로 올바르게 기능을 계속 수행할 수 있어야 합니다.\n- 모니터링 — 마이크로서비스는 건강을 모니터링하는 방법을 제공해야 합니다.\n- 관찰가능성 — 마이크로서비스는 로그 스트림 및 메트릭을 생성하여 유지할 수 있어야 합니다.\n- 테스트 용이성 — 마이크로서비스는 쉽게 테스트할 수 있어야 합니다.\n- 상태를 유지하지 않음 — 마이크로서비스는 클라이언트 컨텍스트를 저장하지 않아야 하며 대신 상태는 데이터베이스에 저장되어야 합니다.\n- 배포 용이성 — 마이크로서비스는 쉽게 배포 및 업데이트할 수 있어야 합니다.\n\nNode.js로 웹 애플리케이션을 개발할 때 모두 가능합니다. 다음 단계에서 이러한 요구사항을 어떻게 달성할지 논의해보겠습니다.\n\n# 스택\n\n웹 서비스를 구축하기 위해 사용할 기술 스택을 처음부터 선택해야 합니다. 물론, 가장 먼저 고려해야 할 질문은 프로그래밍 언어입니다. 이 마이크로서비스에서는 Node.js를 사용할 것이지만, 그럼에도 불구하고, 웹 서비스 개발에 사용하는 데 Node.js의 몇 가지 이점을 소개해 드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- 자바스크립트는 이미 프론트엔드 개발의 주요 언어이며, 백엔드 개발에도 사용하는 것이 합리적입니다. 이렇게 하면 동일한 개발자가 풀 스택 애플리케이션을 개발할 수 있습니다.\n- 자바스크립트 커뮤니티는 엄청나게 큽니다. 개발 중 발생할 수 있는 모든 질문에 대한 답변을 찾을 수 있습니다. 또한 많은 라이브러리가 커뮤니티에 의해 개발되고 유지보수됩니다. 유사한 문제를 해결하는 다른 서드파티를 찾을 수 있으며, 각각 고유한 기능을 가집니다.\n- 노드.제이에스는 구글의 V8 엔진을 사용하여 자바스크립트를 해석하며, 이를 빠르게 기계 코드로 컴파일합니다.\n\n그리고 이런식으로 계속됩니다! 하지만 가장 중요한 질문은 아닙니다.\n\n## 데이터베이스\n\n웹 요청간 데이터를 유지하고 싶습니다. 확장 가능한 상태 유지 웹 서비스를 개발하는 것은 복잡한 작업입니다. 그래서 웹 애플리케이션을 상태가 없는 상태로 유지하고 개별적으로 상태를 외부 데이터베이스에 유지하는 것이 권장됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 서비스를 개발하기 위해 인기 있는 문서 지향 데이터베이스 MongoDB를 사용할 것입니다.\n\nMongoDB는 SQL 데이터베이스보다 몇 가지 이점을 제공하는 NoSQL 데이터베이스입니다:\n\n- 스키마 무료 — MongoDB 컬렉션 (SQL 테이블에 해당하는)은 다른 스키마를 가진 문서를 보유할 수 있습니다. 문서를 컬렉션에 저장하기 전에 구조를 먼저 정의할 필요가 없습니다;\n- 확장성 — MongoDB는 여러 서버에 걸쳐 확장 가능하게 설계되었습니다;\n- 성능 — MongoDB는 읽기 중심 작업에 최적화되어 있으며 대량의 데이터를 저장할 수 있습니다.\n\nNode.js 웹 서비스를 개발할 때 인기 있는 선택 사항입니다.\n\n<div class=\"content-ad\"></div>\n\n# 웹 프레임워크\n\n웹 프레임워크는 웹 애플리케이션을 구축하는 데 필요합니다. 웹 서비스 개발 시 필요한 많은 일상적인 작업을 처리합니다. 예를 들면 라우팅, 보안, 바인딩 등이 있습니다.\n\nNode.js 웹 프레임워크에는 다양한 옵션이 있습니다. 그중에서 가장 인기 있는 것은 express입니다:\n\nexpress의 가장 큰 장점은 사용하기 간편하며 웹 서버를 시작하는 데 필요한 코드가 최소량으로만 필요하다는 것입니다. express로 작성된 'Hello, World!' 예제가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst express = require('express')\nconst app = express()\nconst port = 3000;\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n\n또한, Express는 많은 커뮤니티가 있는데, 서버 기능을 확장하는 다양한 라이브러리(일반적으로 미들웨어로 개발됨)들을 찾을 수 있습니다.\n\n# 유효성 검사\n\n유효성 검사는 웹 애플리케이션의 중요한 부분입니다. 사용자가 API를 어떻게 사용할지 알 수 없기 때문에, 침입자가 잘못된 입력을 제공하여 응용프로그램을 손상시킬 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n웹 요청에서 제공된 매개변수(경로, 본문 등)를 확인하고 올바른지 확인하기 위해 joi를 사용할 거에요:\n\njoi는 다양한 모델을 확인하는 데 사용되는 강력한 라이브러리에요. 나중에 개발할 요청 중 하나를 확인하는 예시가 있어요:\n\n```js\nconst createTask = {\n  body: Joi.object().keys({\n    name: Joi.string().required(),\n    description: Joi.string().optional(),\n  }),\n};\n```\n\n이는 객체가 두 개의 문자열을 가진 중첩된 body 객체를 갖는지 확인하며, 이 문자열은 필수인 name과 선택적인 description이에요.\n\n<div class=\"content-ad\"></div>\n\n하지만 그것만이 아닙니다. 컬렉션을 삭제할 수 있는 위험한 MongoDB 인젝션을 제공하는 경우가 여전히 있습니다. 웹 요청을 정리하기 위해 express-mongo-sanitize 패키지를 사용할 것입니다:\n\n# 설정\n\n동일한 빌드 아티팩트를 다른 환경에서 실행할 수 있도록 응용 프로그램을 구성할 필요가 있습니다. 이를 위해 환경 변수를 통해 구성을 제공하는 것이 표준 접근 방식입니다.\n\n응용 프로그램을 시작하기 전에 로컬 머신에서 환경 변수를 수동으로 설정하고 싶지 않을 것입니다. 이 문제에 대한 인기 있는 Node.js 솔루션은 dotenv 라이브러리에 구현되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n이 라이브러리는 .env(파일 이름을 변경할 수 있음)이라는 파일에서 내용을 로드하고 이 파일의 내용을 환경 변수로 설정합니다.\n\n# 정적 분석\n\nJavaScript 애플리케이션의 경우 ESLint 라이브러리를 설치하여 코드 스타일을 쉽게 강제하고 응용 프로그램을 개발할 때 동일한 규칙을 따를 수 있습니다:\n\nESLint는 코드 품질을 향상하고 몇 가지 버그를 감지할 수 있습니다. 보안 취약점을 식별할 수 있습니다. CI(지속적 통합) 중에 ESLint 검사를 포함하여 팀원들이 ESLint에서 소개한 규칙을 준수하도록 강제할 수 있습니다. 나중에 이를 수행할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# 테스트\n\n애플리케이션을 변경할 때 이전과 동일하게 작동하는지 확인하기 위해 자동 테스트를 작성하는 것이 좋은 실천법입니다. 단위, 통합, 부하, 엔드-투-엔드 (E2E) 등 다양한 테스트 유형이 있습니다. 애플리케이션의 품질과 성능을 확신하려면 더 많은 테스트가 필요합니다.\n\nJavaScript 애플리케이션을 테스트하기 위한 가장 인기 있는 라이브러리 중 하나는 Jest입니다:\n\nJest를 사용하여 단위 및 통합 테스트를 구현할 것입니다. 이러한 테스트는 나중에 코드를 개선하고 리팩토링하는 데 도움이 되었으며 애플리케이션이 손상되지 않았음을 확인했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 로깅\n\n애플리케이션 로그 스트림은 웹 서비스를 원격으로 디버깅하는 데 도움이 됩니다. 코드 실행 경로를 식별하고 요청 로직을 다양한 상황에서 설명할 수 있습니다. 코드에 로그를 삽입하면 이점을 누릴 수 있습니다.\n\nJavaScript 로그를 수집하는 가장 인기 있는 패키지는 winston입니다:\n\nwinston은 간단하지만 강력한 로깅 라이브러리로, 다양한 전송 방법(콘솔, 파일 등)을 사용하여 로그를 수집하는 데 도움을 줍니다. 로그 형식(간단한 텍스트, JSON 등)도 변경할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 메트릭\n\n메트릭을 통해 응용 프로그램의 상태를 모니터링할 수 있어요. 들어오는 요청의 수, 평균 요청 실행 시간, 5XX 응답의 수 등을 확인할 수 있습니다. 메트릭을 통해 어떠한 문제가 발생할 경우 이메일, 알림 등을 통해 알림을 받을 수 있는 다양한 모니터를 설정할 수 있어요.\n\n제 응용 프로그램에서는 express-prom-bundle이라는 표준 웹 응용 프로그램 메트릭을 수집하는 Prometheus 미들웨어를 설치할 예정이에요.\n\n다음 섹션에서 Prometheus에 대해 더 자세히 알아볼 거예요.\n\n<div class=\"content-ad\"></div>\n\n# 모니터링 스택\n\n로그 스트림 및 메트릭은 나중에 모니터링하거나 시각화하는 데 사용할 수 있도록 일부 데이터베이스에 수집되어야 합니다.\n\n로그 및 메트릭을 수집하고 시각화하기 위해 다음 스택을 사용할 것입니다:\n\n- Prometheus — 메트릭을 수집하기 위해 풀 모델을 사용하는 오픈 소스 모니터링 경보 툴킷;\n- Promtail — 로그를 포함하고 전송하는 에이전트;\n- Loki — 로그 집계 시스템;\n- Grafana — 관측 가능성 시스템.\n\n<div class=\"content-ad\"></div>\n\n# 로컬 인프라스트럭처\n\n로컬에서 애플리케이션을 개발하고 테스트하기 위해 필요한 로컬 스택을 만들기 위해 도커를 사용할 거예요.\n\n도커를 사용하면 스테이징 및 프로덕션 환경에서 사용될 것과 유사한 로컬 환경을 시작할 수 있어요. 로컬 컴퓨터에 많은 도구를 설치할 필요가 없어요. 대신 필요한 스택을 시작하기 위해 몇 가지 명령을 실행할 수 있어요.\n\n도커 컴포즈를 사용하면 단일 compose.yml 파일로 모든 인프라스트럭처를 정의하고 단일 명령으로 시작할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n도커 컴포즈 업 -d\r\n```\n\n# 지속적 통합\n\n커밋이 무엇인가를 망가뜨리지 않았는지 확인하기 위해, 지속적 통합(CI)가 필요합니다.\n\n이를 위해, 저는 GitHub Actions를 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\nGitHub 계정에는 무료 티어가 있어서 애플리케이션 코드를 확인하기 위해 간단한 빌드를 실행할 수 있어요.\n\n# 애플리케이션 개발\n\n애플리케이션 구조를 시작했고 적절한 프로젝트 스타일을 따르는 데 도움이 된 훌륭한 저장소를 찾았어요:\n\n이 저장소에서 코드 일부(예: 유효성 검사 미들웨어)를 빌려왔기 때문에 여러분이 확인하도록 추천드려요.\n\n<div class=\"content-ad\"></div>\n\n나중에 저장소 링크를 공유할 건데, 그 전에 재미있는 애플리케이션 부분을 보여주고 싶어요.\n\n나는 mongoose를 사용해서 애플리케이션을 MongoDB와 통합했어요. 먼저, 모델의 스키마를 정의했어요:\n\n```js\nconst mongoose = require('mongoose');\nconst { Schema } = mongoose;\nconst TaskSchema = new Schema(\n  {\n    name: {\n      type: String,\n      required: true,\n    },\n    description: {\n      type: String,\n      required: false,\n    },\n    status: {\n      type: String,\n      enum: ['new', 'active', 'completed', 'cancelled'],\n      default: 'new',\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now,\n    },\n    updatedAt: Date,\n  },\n  { optimisticConcurrency: true },\n);\nmodule.exports = mongoose.model('task', TaskSchema);\n```\n\n이 객체를 사용하여 모델을 유효성 검사하고 코드에서 다양한 MongoDB 작업을 수행할 수 있어요. 이는 작업 업데이트의 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nasync function updateTaskById(id, { name, description, status }) {\n  if (!name && !description && !status) {\n    return { error: '적어도 하나의 업데이트가 필요합니다', code: AT_LEAST_ONE_UPDATE_REQUIRED_CODE };\n  }\n\nif (status && !(status in availableUpdates)) {\n    return { error: '잘못된 상태입니다', code: INVALID_STATUS_CODE };\n  }\n  for (let retry = 0; retry < 3; retry += 1) {\n    // eslint-disable-next-line no-await-in-loop\n    const task = await Task.findById(id);\n    if (!task) {\n      return { error: '작업을 찾을 수 없습니다', code: INVALID_STATUS_TRANSITION_CODE };\n    }\n    if (status) {\n      const allowedStatuses = availableUpdates[task.status];\n      if (!allowedStatuses.includes(status)) {\n        return {\n          error: `'${task.status}'에서 '${status}'(으)로 업데이트할 수 없습니다`,\n          code: TASK_NOT_FOUND_CODE,\n        };\n      }\n    }\n    task.status = status ?? task.status;\n    task.name = name ?? task.name;\n    task.description = description ?? task.description;\n    task.updatedAt = Date.now();\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      await task.save();\n    } catch (error) {\n      logger.warn('저장 중 오류 발생', { error });\n      if (error.name === 'VersionError') {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n    }\n    return task;\n  }\n  return { error: '병행성 오류', code: CONCURRENCY_ERROR_CODE };\n}\n```\n\n가장 흥미로운 부분은 업데이트 후 모델을 저장하는 부분입니다. 격렬한 충돌 문제에 대처하기 위해 낙관적 락을 사용하고 있어요.\n\n두 개의 동시 요청에서 동일한 작업을 완료하고 취소하려고 하는 상황을 상상해보세요. 두 요청이 모두 상태가 '활성'인 작업을 받고 모델을 저장할 때 충돌이 발생할 수 있어요. 첫 번째 작업의 상태가 '완료'로 변경되고 그런 다음 '취소'로 변경될 수 있습니다(또는 그 반대로). 이는 '완료'-'취소' 및 '취소'-'완료' 전이가 허용되지 않기 때문에 잘못된 동작입니다.\n\nMongoose는 낙관적 락으로 이 문제에 대한 해결책을 구현했어요. 낙관적 락은 데이터베이스에서 동시 요청을 처리하는 데 사용되는 전략입니다. 각 문서에는 추가적인 버전 속성이 있어요. 트랜잭션이 모델을 저장/업데이트하려고 할 때 버전을 확인합니다. 버전이 get 쿼리를 수행할 때 받은 버전과 다른 경우, 이미 누군가 문서를 동시에 업데이트했을 수 있어요. 트랜잭션이 중단됩니다(위의 코드에서는 오류가 발생합니다).\n\n\n<div class=\"content-ad\"></div>\n\n문서 예시:\n\n```js\n{\n  \"_id\": {\n    \"$oid\": \"654e03210948a61665b7c889\"\n  },\n  \"name\": \"damnatio\",\n  \"description\": \"Ciminatio totus spiritus suffoco damnatio blanditiis.\",\n  \"status\": \"completed\",\n  \"createdAt\": {\n    \"$date\": \"2023-11-10T10:17:05.039Z\"\n  },\n  \"__v\": 2,\n  \"updatedAt\": {\n    \"$date\": \"2023-11-10T10:17:05.064Z\"\n  }\n}\n```\n\n위의 문서는 속성 __v에 버전을 저장합니다.\n\n다음 레벨은 컨트롤러입니다. 컨트롤러 예시는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst updateTaskById = catchAsync(async (req, res) => {\n  const result = await taskService.updateTaskById(req.params.id, req.body);\n  if (result.error) {\n    switch (result.code) {\n      case taskService.errorCodes.AT_LEAST_ONE_UPDATE_REQUIRED_CODE:\n        res.status(400).json({ success: false, message: '적어도 하나의 업데이트가 필요합니다' });\n        return;\n      case taskService.errorCodes.INVALID_STATUS_CODE:\n        res.status(400).json({ success: false, message: '유효하지 않은 상태' });\n        return;\n      case taskService.errorCodes.INVALID_STATUS_TRANSITION_CODE:\n        res.status(404).json({ success: false, message: '작업을 찾을 수 없음' });\n        return;\n      case taskService.errorCodes.TASK_NOT_FOUND_CODE:\n        res.status(400).json({ success: false, message: result.error });\n        return;\n      case taskService.errorCodes.CONCURRENCY_ERROR_CODE:\n        res.status(500).json({ success: false, message: '동시성 오류' });\n        return;\n      default:\n        res.status(500).json({ success: false, message: '내부 서버 오류' });\n        return;\n    }\n  }\n\nres.status(200).json({\n    success: true,\n    task: toDto(result),\n  });\n});\n```\n\n이 코드는 애플리케이션 비즈니스 로직을 실행하고 HTTP 응답을 반환합니다. 컨트롤러는 routes 모듈에 등록됩니다:\n\n```js\nconst { Router } = require('express');\nconst taskController = require('../../../controllers/task');\nconst taskValidation = require('../../../validation/task');\nconst validate = require('../../../middlewares/validate');\n\nconst router = Router();\nrouter.get('/:id', validate(taskValidation.getTaskById), taskController.getTaskById);\nrouter.put('/', validate(taskValidation.createTask), taskController.createTask);\nrouter.post('/:id', validate(taskValidation.updateTaskById), taskController.updateTaskById);\nmodule.exports = router;\n\n/**\n * @swagger\n * tags:\n *  name: Tasks\n *  description: 작업 관리 및 검색\n * /v1/tasks/{id}:\n *  get:\n *   summary: ID로 작업 가져오기\n *   tags: [Tasks]\n *   description: ID로 작업 가져오기\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   responses:\n *    200:\n *     description: 작업 검색됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    404:\n *     description: 작업을 찾을 수 없음\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n *  post:\n *   summary: ID로 작업 업데이트\n *   tags: [Tasks]\n *   description: ID로 작업 업데이트\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/UpdateTask'\n *   responses:\n *    200:\n *     description: 작업 업데이트됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *     404:\n *      description: 작업을 찾을 수 없음\n *      content:\n *       application/json:\n *        schema:\n *         $ref: '#/components/schemas/TaskResult'\n *     500:\n *      description: 내부 서버 오류\n * /v1/tasks:\n *  put:\n *   summary: 작업 생성\n *   tags: [Tasks]\n *   description: 작업 생성\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/CreateTask'\n *   responses:\n *    201:\n *     description: 작업 생성됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n */\n```\n\n맨 아래에서는 Swagger 미들웨어가 사용하는 OpenAPI 사양이 API 문서 페이지를 생성하는 데 사용됨을 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n각 경로 등록은 두 개의 핸들러를 사용합니다: 유효성 검사기와 컨트롤러 메서드 자체입니다. 유효성 검사기는 서로 다른 모델에 등록된 스키마를 유효성 검사합니다. 유효성 검사기 핸들러:\n\n```js\nconst Joi = require('joi');\nconst pick = require('../utils/pick');\n\nfunction validate(schema) {\n  return (req, res, next) => {\n    const validSchema = pick(schema, ['params', 'query', 'body']);\n    const object = pick(req, Object.keys(validSchema));\n    const { value, error } = Joi.compile(validSchema)\n      .prefs({ errors: { label: 'key' }, abortEarly: false })\n      .validate(object);\n    if (error) {\n      const errorMessage = error.details.map((details) => details.message).join(', ');\n      res.status(400).json({ success: false, message: errorMessage });\n      return;\n    }\n    Object.assign(req, value);\n    next();\n  };\n}\nmodule.exports = validate;\n```\n\n또한 업데이트 요청 유효성 검사 스키마가 있습니다:\n\n```js\nconst updateTaskById = {\n  params: Joi.object().keys({\n    id: objectId.required(),\n  }),\n  body: Joi.object().keys({\n    name: Joi.string().optional(),\n    description: Joi.string().optional(),\n    status: Joi.string().valid('new', 'active', 'completed', 'cancelled').optional(),\n  }),\n};\n```\n\n<div class=\"content-ad\"></div>\n\n업데이트 메서드에 대해 말씀드리겠습니다. 저는 통합 테스트만 구현했습니다. 통합 테스트는 모든 테스트가 실행되기 전과 후에 서버를 시작하고 중지합니다. \n\n```js\nconst path = require('path');\nconst app = require('../../src/app');\nconst db = require('../../src/db');\nconst { createConfig } = require('../../src/config/config');\nconst logger = require('../../src/config/logger');\nconst setupServer = () => {\n  let server;\n  const configPath = path.join(__dirname, '../../configs/tests.env');\n  const config = createConfig(configPath);\n  beforeAll(async () => {\n    logger.init(config);\n    await db.init(config);\n    await new Promise((resolve) => {\n      server = app.listen(config.port, () => {\n        resolve();\n      });\n    });\n  });\n  afterAll(async () => {\n    await new Promise((resolve) => {\n      server.close(() => {\n        resolve();\n      });\n    });\n    await db.destroy();\n    logger.destroy();\n  });\n};\nmodule.exports = {\n  setupServer,\n};\n```\n\n그리고 PUT 요청(태스크 생성)과 POST 요청(태스크 업데이트)을 수행하는 테스트가 있습니다:\n\n```js\ndescribe('태스크 생성 및 업데이트', () => {\n      const data = [\n        {\n          name: '상태만 업데이트',\n          taskName: '태스크 1',\n          description: '태스크 1 설명',\n          newStatus: '활성',\n        },\n        {\n          name: '영어 전체 업데이트',\n          taskName: '태스크 1',\n          description: '태스크 1 설명',\n          newTaskName: '태스크 1 새로운',\n          newDescription: '태스크 1 새로운 설명',\n          newStatus: '활성',\n        },\n        // 이하 생략\n      ];\n\ndata.forEach(({\n        name, taskName, description, newTaskName, newDescription, newStatus,\n      }) => {\n        it(name, async () => {\n          let response = await fetch(baseUrl, {\n            method: 'put',\n            body: JSON.stringify({\n              name: taskName,\n              description,\n            }),\n            headers: { 'Content-Type': 'application/json' },\n          });\n          expect(response.status).toEqual(201);\n          const result = await response.json();\n          // 여기서부터 이하는 생략\n        });\n      });\n    });\n```\n\n<div class=\"content-ad\"></div>\n\n도커 이미지를 생성하려면 간단한 Dockerfile을 정의했습니다:\n\n```js\nFROM node:20-alpine\nWORKDIR /app\nCOPY package.json yarn.lock ./\nRUN yarn install --frozen-lockfile\nCOPY src /app/src\nCMD [\"node\", \"./src/index.js\"]\n```\n\n어플리케이션과 인프라를 시작하는 데 사용하는 compose.yml 정의입니다:\n\n```js\nversion: '3.9'\nservices:\n    app:\n        build: .\n        ports:\n            - '8081:80'\n        depends_on:\n            - mongo\n        volumes:\n            - ./configs/docker.env:/app/configs/.env\n            - logs:/app/logs:rw\n    mongo:\n        image: mongo:5\n        restart: always\n        ports:\n            - 27017:27017\n        volumes:\n            - mongodata:/data/db\n        healthcheck:\n            test: echo 'db.runCommand(\"ping\").ok' | mongo localhost:27017/test --quiet\n            interval: 10s\n            timeout: 2s\n            retries: 5\n            start_period: 5s\n    loki:\n        image: grafana/loki:2.9.0\n        expose:\n            - 3100\n        command: -config.file=/etc/loki/local-config.yaml\n    promtail:\n        image: grafana/promtail:2.9.0\n        volumes:\n            - logs:/var/log:rw\n            - ./infrastructure/promtail.yml:/etc/promtail/config.yml\n        command: -config.file=/etc/promtail/config.yml\n    prometheus:\n        image: prom/prometheus:latest\n        volumes:\n            - ./infrastructure/prometheus.yml:/etc/prometheus/prometheus.yml\n        command:\n            - '--config.file=/etc/prometheus/prometheus.yml'\n        expose:\n            - 9090\n    grafana:\n        image: grafana/grafana:latest\n        volumes:\n            - grafanadata:/var/lib/grafana\n        environment:\n            - GF_PATHS_PROVISIONING=/etc/grafana/provisioning\n            - GF_AUTH_ANONYMOUS_ENABLED=true\n            - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin\n        ports:\n            - 3000:3000\nvolumes:\n    mongodata:\n    grafanadata:\n    logs:\n```\n\n<div class=\"content-ad\"></div>\n\n모두 Git push가 발생할 때마다 GitHub Actions CI가 빌드를 실행합니다. CI 중에는 종속성 설치, 린터 실행 및 모든 테스트 실행을 진행하고 있어요:\n\n```js\nname: App CI\non:\n  push:\n    branches:\n      - \"*\"\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 20\n          cache: \"yarn\"\n      - run: yarn install --frozen-lockfile\n      - run: yarn run lint\n      - run: docker-compose up -d mongo\n      - run: yarn test -- --verbose --coverage\n      - run: docker-compose build\n      - run: docker-compose logs\n        if: always()\n      - run: docker-compose down --volumes\n        if: always()\n```\n\n# 결론\n\nNode.js는 강력한 기술입니다. 더 중요한 것은 Node.js 커뮤니티가 매우 크다는 것이에요. 새로운 웹 서비스를 개발할 때마다 다른 스택을 사용할 수 있어요. 하지만 저는 이 방법을 추천하지 않아요; 만일 능숙한 Node.js 웹 개발자가 되고 싶다면 먼저 특정 기술의 기능을 익히고, 그런 다음에 다른 스택을 사용해보는 것이 좋아요.\n\n<div class=\"content-ad\"></div>\n\n이 게시물에서 웹 애플리케이션을 구축하는 데 사용한 스택은 Node.js 웹 서비스를 구축하는 데 가장 인기가 많습니다. 구현중인 다양한 기능에 도움이되는 많은 문서와 라이브러리가 있습니다.\n\nNode.js로 이전에 설정한 모든 비기능 요구 사항을 쉽게 달성할 수 있습니다. Kubernetes를 사용하여 응용 프로그램 도커 이미지를 작성하고 호스팅할 수 있습니다. Kubernetes는 배포 정의를 변경하여 응용 프로그램을 빠르게 확장하거나 축소하는 데 도움을줍니다. 또한 Kubernetes는 들어오는 트래픽에 따라 응용 프로그램을 확장할 수 있습니다. 또한 MongoDB는 필요에 따라 확장할 수 있도록 설계되어 있어서 트래픽 증가가 문제가 되지 않습니다.\n\nGoogle의 V8 Node.js 엔진을 통해 더 나은 응용 프로그램 성능을 달성할 수 있습니다. 소스 코드가 기계 코드로 번역되는 속도는 인상적입니다!\n\nNode.js를 사용하면 내결함성 있는 응용 프로그램을 구축하는 방법에 대한 다양한 인터넷 기사를 찾을 수 있습니다. 최선의 방법을 따라주세요! 또한 응용 프로그램 코드에서는 예기치 않은 연결 실패(네트워크 문제 또는 MongoDB 장애 등) 후 MongoDB 연결을 복원하는 데 시간을 소비했습니다. 이를 확인하고 응용 프로그램에 적용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nJest를 사용하면 애플리케이션을 위한 다양한 테스트를 작성하고 100%의 테스트 커버리지를 달성할 수 있어요. 몇 가지 까다로운 시나리오도 Jest를 사용하여 에뮬레이션할 수 있어요.\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png","tag":["Tech"],"readingTime":21},{"title":"뉴욕시의 거리 나무 인구 변동을 GeoPandas, Plotly, 그리고 JavaScript를 사용하여 시각화하기","description":"","date":"2024-06-19 22:45","slug":"2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript","content":"\n\n## Plotly Dash 및 JavaScript를 사용한 서버 및 클라이언트 측 렌더링의 성능 비교\n\n![image](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_0.png)\n\n이 문서에서 다음을 다룰 것입니다:\n\n- 미국 인구 조사국 및 뉴욕시 공원국의 데이터를 사용하여 1995년부터 2015년까지 NYC의 거리 나무 면책을 매핑합니다.\n- Pandas/GeoPandas 및 Plotly를 사용하여 데이터를 정리, 집계, 분석 및 시각화하는 방법을 안내하고, 웹 앱을 사용하여 데이터를 대화식으로 제시합니다.\n- 1995년부터 2020년까지 나무와 인구 밀도가 공간적으로 어떻게 변화했는지와 이러한 변화의 사회적 함의에 대해 논의합니다.\n- 이 기간 동안 도시 전역에서 블록 당 나무의 중앙값이 크게 증가했지만, 변화의 규모가 자치구별 및 지역별로 상당히 다르며 일부 지역에서는 나무가 감소하는 것을 알 수 있습니다.\n- 1995년 이후의 대상 나무 심는 노력이 적은 숲이었던 역사적으로 레드라인 지역에서 도시열섬 효과를 개선하지만, 젠트리피케이션에도 기여했음을 발견합니다.\n\n<div class=\"content-ad\"></div>\n\n마침내, 이 웹 앱의 서버 및 클라이언트 측 렌더링(Plotly Dash 및 JavaScript 사용)의 성능을 비교해보고 간단한 대화형 데이터 시각화의 경우 클라이언트 측 렌더링이 가장 우수함을 발견했습니다.\n\n# 동기\n\n작년 가을, 친구가 뉴욕 시티의 다른 동네들 사이의 나무 면적의 차이에 관한 뉴욕 타임스 기사를 보내줬어요. 2016년부터 사는 뉴욕에서 이 기사는 특히 나에게 와닿았어요.\n\n그때 이 기사가 나에게 매우 중요했던 이유는, 그 해 여름 동안 시애틀에 있던 때 전체 태평양 연안이 ‘천년에 한 번 일어나는 1급 이벤트’로 평가될 정도로 극적인 폭염을 경험했기 때문이었어요.\n\n<div class=\"content-ad\"></div>\n\nUrban Heat Island (UHI) 효과에 대해 알려줬어요. 도시보다 주변 농촌 환경에서 기온이 높아지는 현상이에요. 또한 뉴욕시와 그 이상 지역에서 레드라인, 같은 역사적인 차별 패턴에 따라 강렬하고 치명적인 여름 폭염 지역들이 어떻게 공간적으로 재현되는지 소개했어요.\n\n극지역 도시 열섬의 강도에서 주요 물리적 변수는 나무의 존재에요. 제가 항상 환경 정의에 관심이 있었고, 마지막 두 시장 행정 기간 동안의 나무 심기 노력과 주택 건설 증가를 고려할 때, 최근에 NYC(뉴욕시)의 UHI가 어떻게 변화했는지 이해하고 5개 자치구 전역에서 기후 탄력의 변화하는 지리를 이해하고 싶었어요. 구체적으로는 다음을 이해하고 싶었어요:\n\n- 나무와 인구의 추세가 어떻게 변화했는지\n- 시간이 흘러 나무와 인구의 변화가 주택 재편에 관련되어 있는지\n- 1995년에 도시에 비해 가장 적은 나무를 가진 지역이 오늘날에도 여전히 상대적으로 나무가 부족한지\n- 레드라인으로 분류된 지역이 1995년과 오늘날에 도시에 비해 나무가 덜 있는지\n\n우선, 데이터를 필요로 했어요.\n\n<div class=\"content-ad\"></div>\n\n# 데이터 수집 및 정제\n\n나는 NYC Open Data를 찾아 공원 부서의 'Street Tree Census' 프로젝트를 발견했어. 이 프로젝트는 1995년, 2005년 및 2015년에 모든 거리 나무의 수동 인벤토리를 수행했어.\n\n나는 모든 데이터를 다운로드하고 탐색을 시작했어. 데이터 사전을 읽은 후, 인구조사 구로 거리 나무를 비교하는 것이 가장 합리적인 데이터 처리 방법임을 깨달았어. 왜냐하면 97%의 나무에 대해 인구조사 구가 제공되었고 국세 데이터와 쉽게 병합할 수 있기 때문이야. UHI가 공간적으로 어떻게 변화했는지 이해하고 그 크기와 수를 결정하기 위해, 나는 시간이 지남에 따른 나무의 공간 분포, 나무의 상대 풍부도 및 거리 나무 인구의 총 성장을 비교하기로 결정했어.\n\n또한, 지난 시간 동안 어디에 열섬이 있었고 현재 어디에 있는지 확인하고 싶었어. 열섬을 추적하고 시간이 지남에 따라 그 심각성이 변하는 것을 측정하기 위해, 나는 수거된 주민들의 인구가 나무 인구와 어떻게 분포 변화했는지를 이해할 필요가 있었어. 안타깝게도 거리 나무 인구 조사는 10년 주기의 인구조사 사이에 정확히 발생했기 때문에, 나는 매 나무 인구조사마다 이전 또는 이후의 인구 데이터를 사용할지 결정해야 했어.\n\n<div class=\"content-ad\"></div>\n\n나는 각 나무 수를 센 후 인구 조사 데이터를 사용하기로 결정했습니다. 최근인 2020년 인구 조사의 데이터를 활용할 수 있어서였고, 도시의 나무 수가 증가 추세에 있었기 때문에 나무 수를 과소 추정하는 대신 사람 수를 과소 추정하는 것보다 나에게 더 적합하다고 생각했어요. 이렇게 하는 것이 기후 변화의 인간적 요소를 강조하고 싶었기 때문이죠. IPUMS NHGIS에서 2000년, 2010년, 2020년 인구 조사 정보를 다운로드했어요.\n\n첫 번째 단계는 인구 조사 구역별로 나무를 집계하는 것이었어요. 이 일이 보다 복잡하게 나타나기도 했는데, 대부분의 나무에 대해 인구 조사 구역 코드가 포함되어 있었지만, 이 코드들은 카운티 수준에서만 고유했어요. 뉴욕시의 각 자치구가 각자의 카운티인 것을 감안하면, 이는 코드가 도시 내에서 고유하지 않음을 의미했죠.\n\n공원 부서의 분들이 친절하게도 해결책을 제공해 주셨어요. boroct 또는 \"자치구 인구 조사 구역\"이라는 열이 포함되어 있었는데, 이 열은 변수 길이의 인구 조사 구역 코드를 여섯 자리 숫자로 변환하고, 해당 나무가 위치한 자치구를 나타내는 1, 2, 3, 4, 또는 5를 접두사로 붙였어요. 결과적으로, 이는 도시 수준에서 고유한 7자리 지리 식별자로 이뤄졌습니다.\n\nboroct가 2015년 인구 조사의 거의 모든 나무에 제공되었지만, 2005년과 1995년 인구 조사에는 인구 조사 구역 코드만 있고 boroct 항목이 없는 나무가 많았어요 — 2005년에 모든 나무 중 거의 20%였죠. 이 문제를 인코딩하는 짧은 함수를 작성했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# borocode, 총 인구 조사 구 코드의 길이 및 문자열 형태의 인구 조사 구 코드를 입력하면 boro_ct를 반환하는 함수\n\ndef encode_boroct(bc, l, sct):\n    bct = np.where(l == 1, bc+\"000\"+sct+\"00\",\n                  np.where(l == 2, bc+\"00\"+sct+\"00\",\n                  np.where(l == 3, bc+\"0\"+sct+\"00\",\n                  np.where(l == 4, bc+sct+\"00\",\n                  np.where(l == 5, bc+\"0\"+sct,\n                  np.where(l == 6, bc+sct,\n                                    \"NaN\"))))))\n    return bct\n```\n\n일부 나무에는 인구 조사 구가 나와 있지만 인구 조사 구 코드가 없는 것이 있었기 때문에 해당 부분은 삭제되었고, 각 인구 조사 연도별 인구 조사 구당 나무 수를 세 개의 데이터프레임에 저장했습니다. 총 1995년, 2005년 및 2015년 데이터에서 나무의 97%에는 인구 조사 구가 지정되어 있었으며, 모든 나무가 최종 데이터프레임에 포함되었습니다.\n\n2010년 인구 조사 구 지정이 세 인구 조사 연도에 모두 사용되었기 때문에 이러한 구역의 shapefile을 GeoPandas GeoDataFrame으로 가져와 NYC를 위해 하위 집합으로 만든 다음, boroct를 사용하여 2015년 나무 수 데이터와 결합했습니다.\n\n그런 다음 boroct를 사용하여 왼쪽 외부 조인을 계속 적용하여 각 인구 조사 구에 대한 2015년, 2005년 및 1995년 나무 수뿐만 아니라 각 인구 조사 구의 구 이름, 면적 및 지오메트리를 포함하는 최종 데이터프레임을 만들었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n다음으로, 인구 조사 데이터를 정리했습니다. 상대적으로 단순한 분석을 하고 있었기 때문에 작업은 간단했습니다. 인구를 조사구 단위로 집계하고, 연이어 왼쪽 조인을 사용하여 각 인구 조사 연도별로 열을 가진 단일 DataFrame을 만들었습니다.\n\n마지막으로, 2020년 인구 조사 구역의 형상 파일을 가져왔습니다. 최신 인구 조사 데이터를 최대한 활용하고 싶었기 때문입니다. 인구 조사 구역 단위로 집계하고, 2020년과 2010년 구역 지정 간의 차이가 최소한으로 유지되도록 확인했습니다. 총 나무 수의 미약한 손실에 만족하고 — 총 나무 수의 1% 미만을 차지하는 인구 조사 구역이 약 5% 미만으로 유지되었기 때문에 — 완전한 트리 GeoDataFrame을 완전한 인구 GeoDataFrame에 결합하여 그래프용 최종 GeoDataFrame을 만들었습니다.\n\n이 최종 GeoDataFrame에는 1995년, 2005년 및 2015년의 트리 카운트와 2000년, 2010년 및 2020년의 인구 통계가 포함되었습니다. 이들은 인구 조사 구역 단위로 집계되었으며, 최종 열에는 각 구역의 토지 면적 및 동네 이름이 저장되었습니다.\n\n<img src=\"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n마침내 몇 가지 지표가 필요했어요. 시간이 지남에 따라 토지 면적 당 나무를 의미 있는 방식으로 비교하기 위해, 도시 주민들에게 직관적인 토지 면적 단위를 고안하는 것이 필요했죠.\n\n인구 조사 보고서는 평방 미터로 토지 면적을 측정하지만 뉴욕 시민들은 도시 블록 단위로 생각하니까, 저는 표준 단위 블록을 정의하고 블록 당 나무 수를 보고하기로 결정했어요.\n\n조사 및 StreetEasy의 도움을 받아 데이터셋에 합리적인 나눗셈자로 작용하는 평균 블록 크기를 찾았고, 대부분의 블록이 1에서 40 그루의 나무를 보유하도록 결정되었죠. 나무 조사 연도별 블록 수로 변환하고 각 나무 조사 연도의 블록 수로 나무 수를 나누었어요.\n\n인간 중심적 맥락에서 나무 인구를 관련 지었기 때문에 세 인구 조사 연도 모두에 대해 \"인당 나무 수\" 지수를 계산했어요. 산업지역의 도시열섬은 여전히 생태학적으로 중요하지만 이러한 공간에서의 인구 감소로 인해 인간 건강에 미치는 영향의 규모는 상당히 감소되었어요.\n\n<div class=\"content-ad\"></div>\n\n내 프로젝트의 초점은 주로 인구 밀집 지역을 살펴보고, 나무 덮개가 증가함에 따라 인간 건강에 미치는 영향을 조사하는 것이었습니다.\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_2.png)\n\n이러한 지수를 계산한 후에는 데이터를 자세히 분석할 준비가 되었습니다.\n\n# 탐색적 데이터 분석\n\n<div class=\"content-ad\"></div>\n\n총으로 뉴욕시는 조사 기간 동안 15만 7천 그루 이상의 나무와 58만 7천 명의 사람이 증가했습니다. 지역 수준에서 2022개의 택트 중 1604개(79%)가 나무를 추가했고, 2022개의 택트 중 1505개(74%)가 사람을 추가했습니다. 이 데이터는 2020년 인구조사 기간 모든 택트의 95%와 나무의 96%를 대표합니다.\n\n게다가, 1995년부터 2015년까지의 나무 심는 노력을 통해 각 인구 조사 구역의 평균 나무 수가 15에서 22로 증가하고, 도시 전체의 인당 나무 수가 19에서 15로 감소했습니다.\n\n이러한 추세는 자치구 수준에서도 유지되지만, 나무와 사람이 추가된 수에는 자치구 간에 유의미한 차이가 있었습니다. 평균 인구조사 택트의 통계는 아래 표에 나와 있습니다:\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_3.png)\n\n<div class=\"content-ad\"></div>\n\n표를 보면, 브롱스가 해당 기간 동안 가장 빠른 성장을 경험했음을 알 수 있습니다. 브롱스는 블록 당 가장 많은 나무를 추가했고, 스테튼 아일랜드와 비슷한 수의 인구를 블록 당 추가했습니다. 스테튼 아일랜드의 중앙 센서스 트랙트는 브롱스의 거의 5배 크기입니다. 브루클린은 브롱스의 두 배 이상인 720개의 센서스 트랙트를 가지고 가장 많은 나무와 인구를 추가했습니다. 퀸즈는 가장 낮은 중앙 값 증가율을 보여주었는데, 그로 인해 나는 각 자치구별 통계를 자세히 살펴보게 되었습니다. 나무와/또는 인구가 감소한 트랙트의 소수를 중점적으로 살펴보니 몇 가지 추가적인 맥락을 얻을 수 있었습니다.\n\n다섯 자치구 중에서 퀸즈가 나무 총 수가 감소한 센서스 트랙트 비율이 가장 높았으며, 브롱스는 10%로 가장 낮았습니다. 흥미로운 점은 브롱스를 제외한 모든 자치구에서 나무를 잃은 대부분의 트랙트가 전체적으로 인구 증가를 경험했다는 것입니다.\n\n맨해튼에서는 센서스 트랙트의 34%가 인구 감소를 경험했지만, 그 트랙트 중 거의 80%에 공원이 추가되었습니다. 종합하면, 몇 가지 트렌드가 나타납니다: 맨해튼의 도시림이 상당히 증가했지만, 우연히도 인구 재배치는 UHI(도시 열섬) 리스크가 실질적으로 줄었음에도 불구하고, 이 혜택이 공간 또는 인구통계에 공평하게 분배되지 않았다는 점을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n퀸즈(Queens) 지역에서는 인구가 증가하고 나무가 줄어든 센서스 트랙트(census tracts)의 높은 비율(21%)은 새 주택 개발의 결과일 수 있지만, 이 가설을 확인하기 위해 추가 연구가 필요합니다.\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_5.png)\n\n이러한 변화의 공간 분포를 살펴보면, 맨해튼(Manhattan), 퀸즈(Queens) 및 브루클린(Brooklyn)에서 나무 심는 노력의 불일치가 확인되며, 특히 각 자치구 내의 분산이 가장 크다는 것을 보여줍니다. 맨해튼(Manhattan)에서는 센트럴 파크(Central Park) 북쪽의 트랙트에서 그 자치구의 대다수 나무가 심어지는 반면, 그 공원 남쪽 및 동쪽에 위치한 트랙트들은 대부분 나무를 유지하거나 순수한 거리의 나무가 감소했습니다.\n\n브루클린(Brooklyn)에서는 전체 자치구 곳곳에 나무가 심어졌지만, Prospect Park 북쪽 및 동쪽 트랙트에 대부분의 나무가 심어졌으며, 나무가 감소한 소수의 트랙트는 대부분 공원 남쪽에 거의 일체로 위치해 있습니다.\n\n<div class=\"content-ad\"></div>\n\n퀸즈 지역에서는 나무 인구 변화가 하이퍼로컬라이즈되었습니다. 잭슨 하이츠와 아스토리아 같은 특정 지역과 남쪽의 글렌데일, 리치몬드 힐 및 오존 파크는 대부분의 지역이 도시 나무 인구 수가 정체되거나 약간 증가하는 반면 가로수의 인구가 감소하는 극적인 변화가 있었습니다. 스태튼 아일랜드는 전체적으로 나무를 추가했지만, 남단 브롱스의 급증 비율보다는 낮은 속도로 나무를 추가했습니다. 이러한 특이점 중 하나는 리버데일을 제외한 대부분의 센서스 지역에서 나무 인구가 크게 증가했습니다.\n\n1995년의 코로플렛을 살펴보면, 도시의 나무 심기 노력이 대부분 가로수가 부족한 지역에 집중되었음을 알 수 있습니다. 특히 남쪽 브롱스와 북부 맨하탄 지역이 그 예시입니다. 또한, 퀸즈 지역의 이전에 가장 극단적인 산림파괴를 경험한 지역들이기도 하면서 1995년에는 상대적으로 많은 가로수가 있는 지역이었습니다.\n\n1995년부터 2015년까지의 나무 심기와 제거 작업을 종합하면 도시 전체적으로 가로수의 풍부함이 균등해졌습니다. 이는 두 해의 블록 당 나무 히스토그램을 비교함으로써 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image1](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_7.png)\n\n![image2](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_8.png)\n\n환경 정의 측면에서, 지난 20년간의 나무 심는 노력은 확실히 시내 전역에서 레드라인의 시각적 유산을 줄였습니다. 리치먼드 대학의 역사적 레드라인 지도와 1995년의 거리 나무 분포를 비교하면 수십 년 전에 내린 결정이 지금까지도 도시 지리를 지속적으로 영향을 미치고 있다는 것을 명확히 보여줍니다:\n\n![image3](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_10.png\" />\n\n트리가 풍부한 거리를 완벽하게 대변하는 것은 아니지만, 레드라인 지역 여부와 그에 포함된 나무 수 간에는 분명한 관계가 있었습니다. 그러나 2015년까지 는 20년 동안의 주로 적은 숲이 있는 지역을 대상으로 한 거리에 나무를 심는 노력을 통해 이 상관관계가 줄어든 것을 알 수 있습니다. 아래에서 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_11.png\" />\n\n새로 심은 나무들은 적어도 한 측면에서 역사적인 잘못을 해소하는 데 성공했지만, 이러한 노력의 사회적 영향이 오로지 좋은 것만은 아닙니다. 상대적으로 신속한 도시 녹화는 분명히 만약 뉴욕(특히 맨해튼과 브루클린) 전역에서 특별히 내달리피케이션을 가속합니다.\n\n<div class=\"content-ad\"></div>\n\n다양한 연구에서는 도시 내 녹지 공간의 증가와 젠트리피케이션 사이에 인과 관계를 발견했으며, NYC의 데이터를 보다 자세히 살펴보면 이 연결이 명백해집니다. Urban Displacement Project의 NYC에서의 젠트리피케이션과 이주 문제 지도는 1995년부터 2015년까지 가장 많은 나무를 심은 지역이 젠트리피케이션을 겪고 있는 동시에 저소득 가구를 이주하고 있다는 것을 보여줍니다.\n\n나무를 추가하면서 인구가 감소한 지역만 나타내는 지도는 부시윅, 크라운 하이츠, 윌리엄스버그, 아스토리아, 이스트 할렘, 워싱턴 하이츠, 그리고 사우스 브롱스와 같은 젠트리피케이션의 요충지를 강조합니다.\n\n또한, 블록 당 나무 수와 블록 당 인구 변화의 도시 전체 이차원 히스토그램은 인구 밀도와 나무 수 모두 약간 증가하는 대부분의 센서스 트랙트들의 거의 정규 분포를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Visualization 1](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_13.png)\n\nWhen this distribution is mapped according to the borough, however, vast differences can be observed between boroughs.\n\n![Visualization 2](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_14.png)\n\nAs is shown above, Queens and Brooklyn had a much larger number of tracts decreasing their population density in the sampled period than did Staten Island, Manhattan, and the Bronx.\n\n\n<div class=\"content-ad\"></div>\n\n이 변경은 퀸즈의 나무 밀도 변화와는 독립적으로 일어났지만, 브루클린에서는 거리에 심겨진 나무의 증가와 함께 주로 발생했습니다.\n\n인구 밀도 감소는 일대 일 대응의 개발 동향을 반영하는 것은 아니지만, 연구에 따르면 인구 밀도 감소는 가구 규모 축소에서 비롯된 도심 내 개발 현상의 결과입니다. 특히 브루클린에서는 특정 지역에서 춘추화에 기여하는 가로수 증가가 있을 확률이 높습니다.\n\n# 그래프 만들기\n\n프로젝트 시작부터 나는 결과물을 명확히 전달하는 가장 좋은 방법으로 나무 변화를 보여줄 수 있는 코로플레쓰 집합이 되기를 원했습니다.\n\n<div class=\"content-ad\"></div>\n\n코로플레스는 지역의 하위 구획이 일정 지표에 따라 색칠된 지리적 지도입니다. Plotly는 다양한 유형의 코로플레스를 지원하며 기본적으로 상호작용이 가능하며, 파이썬 인터페이스가 GeoPandas를 지원하여 이 프로젝트에 쉽게 사용할 수 있었습니다.\n\n지도를 만들기 전에 해야 할 결정이 있었어요: 데이터를 분위로 나눌지 여부입니다. 기본적으로 Plotly는 숫자 값을 연속적인 데이터로 해석합니다. 이것은 많은 데이터셋에서 작동하지만 경우에 따라 이상치가 색상 척도를 심하게 왜곡시켜 데이터의 의미 있는 차이를 줄일 수 있습니다. 이 결정을 내리기 위해, 기본적으로 그래프로 사용할 '블록 당 나무 개수' 지수의 히스토그램을 살펴보았습니다.\n\n위 그래프를 보면, 1995년에 인구 조사 구역 대부분은 블록 당 3에서 25그루의 나무를 가지고 있었습니다. 분포는 로그 정규 분포로 보이며, 범위 양 끝에 몇몇 이상한 인구 조사 구역이 있어 한 구역에서는 72그루, 다른 구역에서는 0.5그루의 나무를 가지고 있습니다. 데이터의 대다수를 더 의미 있게 나타내기 위해, 나는 그래프로 사용할 데이터를 이산적인 분위로 나누기로 결정했습니다.\n\n<div class=\"content-ad\"></div>\n\n나는 클리닝 단계에서 생성한 데이터프레임을 가져와서 px.choropleth를 사용하여 트레이스 기반 지도(즉, 배경 지도 없이)를 만들었어. 나는 지도를 뉴욕 시를 중심으로 설정하고 첫 번째 초안을 렌더링했어:\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_16.png)\n\n보다시피, 뉴욕 시의 대부분의 땅 면적이 표시되어 있어. 그럼에도 불구하고 나는 그 위에 베이스 레이어를 추가함으로써 시의 다양한 인구조사 지역을 비교하고 대조할 수 있는 능력을 향상시키고, 주요 공원의 위치를 중요하게 표시할 수 있다고 느꼈어.\n\n개선된 지도:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_17.png)\n\n이렇게 하면 더 좋아 보이고 사용자에게 데이터의 공백이 어디에 있는지 이해하는 데 도와주며 이러한 공백의 중요성을 판단할 수 있게 합니다.\n\n지도에 있는 토목은 \"블록 당 나무\" 지수에 따라 색칠되어 있습니다. 하지만 이 지수와 함께 제시하고 싶었던 여러 측정 항목이 더 있어서 이를 마우스 오버 팝업에 포함시켰습니다.\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_18.png)\n\n\n<div class=\"content-ad\"></div>\n\n제가 세 개의 그림을 만들었어요. 각각은 나무 인구 조사 연도를 나타냅니다. 추가적으로 1995년 이후 모든 통계의 누적 변화를 보여주는 추가 그림을 만들고 싶었어요. 2015년부터 1995년까지 각 인구 조사 구역의 나무 수의 차이와 2020년부터 2000년까지 해당 지역의 차이를 계산하여 '블록당 나무 변화' 및 '나무 당 인구 변화' 열을 만들었어요.\n\n이전과 마찬가지로 '블록당 나무 변화'의 분포를 조사하고, 이를 이산화하기로 결정하고 합리적인 분위수(총 9개)를 만들었어요. 색상 척도를 분위수에 맞게 조정하고 더 많은 정보를 수용할 수 있도록 hover 템플릿을 수정했어요. 새로운 템플릿은 다음과 같아요:\n\n마지막으로 NaN을 \"-\"로 대체한 다섯 번째 데이터프레임을 만들어 hover 템플릿에 전달했어요. Plotly 그래프 엔진에 전달되는 동일한 데이터프레임 내 NaN을 더 읽기 쉬운 문자로 대체하지 않으면, 이전에 설정한 이산화된 색상 구성에 문제가 발생할 수 있기 때문에 이 작업이 필요했어요.\n\n이렇게 해서 그래프들이 완성되었어요!\n\n<div class=\"content-ad\"></div>\n\n# 모두 온라인에 올리기: Dash vs JavaScript 성능\n\n내 프로젝트를 온라인으로 올리기로 결심했다. 사용자들이 등대를 찾아보는 작은 Dash 앱을 만들기로 했다. 슬라이더와 로딩 스피너를 추가하는 데 시간을 투자했고, 로컬 머신에서 결과에 만족한 후에 Heroku Dyno를 설정하여 앱을 테스트했다. 다른 사람들은 이 과정을 자세히 설명했다.\n\n거의 즉시 서버 측 응답 시간에 실망했다. 내 최종 등대는 각각 14~40mb로 비교적 작았지만, 슬라이더를 이동한 후 각 개별 그래프를 수신하고 표시하는 데 Dyno가 최대 25초가 걸렸다. 이것은 일정한 3~4초의 서버 응답 시간과 매우 가변적인 12~22초의 데이터 전송 시간으로 분해되었다. 초기 로드 시간에 추가로 5~10초가 걸렸다.\n\n내 옵션을 고려했다. Heroku가 더 나은 서비스를 위해 더 많은 돈을 지불할 수도 있었지만, 나에게는 불필요하고 게으르게 보였다. 클라이언트 측 캐싱을 추가할 수도 있었지만, 이는 초기 데이터 전달의 느리움을 해결하지 못했다. 서버의 결과를 저장하여 해당 입력이 동일한 경우에 다시 함수를 호출할 때 검색할 수 있게 하는 캐싱 유형인 메모이제이션을 추가했지만, 이것은 서버 응답 시간만 향상시키고 처리량 문제는 해결되지 않았다. 등대의 크기를 줄일 수도 있었지만, 이는 호버 박스의 정보를 대폭 줄이는 것을 의미했을 가능성이 높았다 — 이것은 나에게는 프로젝트의 목적을 완전히 잃게 되는 것으로 보였다.\n\n<div class=\"content-ad\"></div>\n\n마침내, Dash 사용을 완전히 포기하기로 결정했습니다. 사용자가 시각화되는 데이터 세트를 수정할 수 없다는 것을 깨달았기 때문에 과도한 엔지니어링을 하고 있었다는 것을 깨달았습니다. 결과적으로 서버 응답이 전혀 필요하지 않았습니다. 대신, Plotly.py가 단지 JavaScript 라이브러리 Plotly.js를 위한 Python 인터페이스일 뿐이라는 사실을 이용했습니다.\n\nPython 전용 구현에 갇혀들지 않고, orjson을 사용하여 완성된 그림을 JSON으로 내보내고, Dash에서 구축한 기본 HTML, CSS 및 JS를 사용한 베어본 웹페이지를 복사했습니다.\n\n생성된 웹페이지는 초기 로드 시간이 짧지만 여러 그래프 간에 전환 시 지연이 없습니다. 사용자 관점에서 봤을 때 훨씬 더 원활한 경험을 제공합니다.\n\nHeroku 구현 사이트를 여기에서 확인할 수 있으며 JavaScript 구현을 여기에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n요약하자면 다음을 발견했습니다:\n\n- 1995년부터 2020년까지 거리의 나무와 인구 모두 전체 도시에서 증가했지만, 이러한 증가의 폭은 자치구 간 및 그 사이에 상당한 공간적 변동이 있었으며, 일부 지역은 한쪽 또는 양쪽 범주에서 큰 손실을 겪었습니다.\n- 특정한 나무 심기 노력은 과거 레드라인 지역에서 열도심화 효과를 완화시켰으나, 이러한 새로운 나무들은 게트리피케이션에 기여하는 부차적 효과를 가졌습니다.\n\n성능 측면에서 데이터를 \"오프라인\"으로 처리하고 결과를 저장하는 것이 매번 \"온라인\"으로 처리하는 것보다 나은 방법이라는 것을 발견했습니다. 즉, 정적 데이터 집합을 특징으로 하는 데이터 시각화의 경우 오프라인 구현이 항상 더 좋은 선택입니다. 이 분석은 인종, 연령, 소득 및 신규 주택 건설과 같은 추가적인 인구 변수를 포함하여 나무 심기의 사회적 영향과 패턴을 더 체계적으로 이해하는 데 확장될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n인구 및 나무 데이터를 보간하면 이러한 변화에 대한 보다 전체적인 시간적 이해를 얻을 수 있으며, 특히 각 나무 조사 연도에 대한 보다 정확한 인구 추정을 얻을 수 있습니다.\n\n나무 위치의 지리적 정밀도를 높이는 것으로 더 정밀한 분석을 실시할 수 있으며, 위도 및 경도 좌표 또는 LIDAR 포인트 클라우드 모델을 통해 이루어지며, 이러한 지리적 위치 데이터와 위시각화함으로써 정확한 인구 추정을 얻을 수 있을 것입니다. 지리적 정밀도\n\n이 연구 및 분석은 도시 기획가들에게 유용할 것으로, 이들은 물리적 환경 변화가 이웃의 사회적 특성이 발전하는 데 기여할 것이라는 점을 알고 있어야 합니다.\n\n이 프로젝트의 코드를 찾아서 GitHub에 올리고 최종 시각화를 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n당신은 제 LinkedIn에서 저를 찾을 수 있어요.","ogImage":{"url":"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_0.png"},"coverImage":"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_0.png","tag":["Tech"],"readingTime":15},{"title":"HTML과 CSS를 사용하여 반응형 헤더를 만드는 방법","description":"","date":"2024-06-19 22:43","slug":"2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS","content":"\n\n\n<img src=\"/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_0.png\" />\n\n안녕하세요, 이 기사에서는 웹사이트 구축시 필수 요소 중 하나 인 반응형 헤더를 만드는 방법에 대해 이야기하겠습니다. 이 기사에서 모든 코드와 세부 정보를 찾을 수 있습니다.\n\n```js\n<div class=\"hero\">\n      <nav>\n        <nav>\n          <h2 class=\"logo\">İlhan <span>Bal</span></h2>\n        </nav>\n    </nav>\n    </div>\n```\n\n우선, 코드를 body 태그 사이에 작성합니다. 첫 번째 단계에서 고유한 클래스 이름을 가진 div 태그를 만듭니다. 이 div 태그 내부에 2개의 nav 태그를 엽니다. 두 번째 nav 태그 내에서 로고를 추가하기 위해 고유한 클래스 이름을 가진 h2인 서브 태그를 생성합니다. 여기서 h2 태그를 사용했지만, 선호하는 경우 h1, h3 등을 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_1.png)\n\n다음으로 진행하기 전에, 코드 블록에 요소들을 포함해야 합니다. 이를 위해 정렬되지 않은 목록 태그인 ul을 사용할 것입니다.\n\n```js\n  <div class=\"hero\">\n      <nav>\n        <nav>\n          <h2 class=\"logo\">İlhan <span>Bal</span></h2>\n        </nav>\n      <ul>\n        <li class><a href=\"yeni.html\">Home</a></li>\n        <li class><a href=\"about.html\">About</a></li>\n        <li class><a href=\"contact.html\">Contact</a></li>\n        <li class><a href=\"galeri.html\">Gallery</a></li>\n      </ul>\n        </nav>\n        </div>\n``` \n\n\n<div class=\"content-ad\"></div>\n\n위의 코드 블록에서 볼 수 있듯이, 우리는 ul 클래스를 생성하고 요소를 추가했습니다. 우리의 요소는 홈, 소개, 연락처 및 갤러리입니다. 사용자가 마우스로 클릭하면 이러한 페이지로 이동하기 위해 요소 수만큼의 HTML 사본을 만들고 요소 이름에 따라 이름을 지정합니다. 그런 다음 href=\"about.html\"과 같이 링크를 제공합니다.\n\n![이미지](/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_2.png)\n\n우리의 출력물은 이렇게 보여야 합니다.\n\n페이지 오른쪽 상단에 있는 버튼과 같은 버튼을 만들려면 “button” 클래스 이름을 가진 버튼을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\nOur HTML code block is completed. Now we can use CSS to enhance the appearance of our page.\n\nIn the second step, create a file with a .css extension. To link our existing HTML file with the CSS file we created, place the following code block between the head tags of our HTML page.\n\n```html\n<head>\n\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>İlhan Bal</title>\n\n    <link rel=\"stylesheet\" href=\"app.css\"> \n \n</head>\n```\n\n\n<div class=\"content-ad\"></div>\n\n이렇게 하면 CSS 파일에서의 업데이트가 페이지에 반영되는 것을 확인할 수 있습니다.\n\n```js\n*{\n    margin: 0;\n    padding:0;\n    box-sizing: border-box;\n    font-family: 'Poppins' , sans-serif;\n}\n.hero{\n    height: 100vh;\n    width: 100%;\n    padding-right: 111px;\n}\nnav{\n    margin-top: 20px;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding-top: 20px;\n    padding-left: 5%;\n    padding-right: 10%;\n}\n.logo{\n    color: white;\n    font-size: 32px;\n    margin-top: 0px;\n}\nspan{\n    color: #4070f4;\n}\nnav ul li{\n    margin-top: 32px;\n    display:inline-block;\n    list-style-type: none;\n    padding: 10px 20px;\n}\nnav ul li a{\n    color: white;\n    text-decoration: none;\n    font-weight: bold;\n    align-items: center;\n}\n\nbutton{\n    margin-top: 32px;  \n    border: none;\n    background: #4070f4;\n    padding: 2px 30px;\n    border-radius: 30px;\n    color: white;\n    font-weight: bold;\n    font-size: 15px;\n    transition: .4s;\n}\n```\n\n홈, 소개, 연락처 및 갤러리 요소 위에 마우스를 올리면 텍스트 색상과 커서를 변경하는 추가 단계를 적용해야 하며, 구독 버튼 위에 마우스를 올리면 커질 수 있도록 하고 다시 작아져야 합니다.\n\n```js\nnav ul li a:hover{\n    color: #4070f4;\n    transition: .3s;\n}\n\nbutton:hover{\n    transform: scale(1.1);\n    cursor: pointer;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n프로젝트가 완료되었습니다. HTML과 CSS를 사용하여 반응형 헤더를 완성했습니다. 이제 라이브 미리보기를 확인해보세요.\n\n이 튜토리얼은 여기까지입니다. 유용하게 활용하셨기를 바라겠습니다.\n\n이제 HTML과 CSS를 사용하여 성공적으로 반응형 헤더를 만들었습니다. 이 프로젝트를 직접 사용하려면 IDE에 복사하세요. 프로젝트를 이해했기를 바라며, 의문이 있으시면 언제든지 댓글을 달아주세요!\n\n독자 여러분, 읽어주셔서 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n태그를 마크다운 형식으로 바꿔보세요.\n\n| follow : @ilhanbal577\n\n| Written By : İlhan Bal\n\n| Code by : İlhan Bal\n\n# 웹사이트 안에 헤더 섹션을 넣는 장점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 헤더는 웹 사이트의 여러 섹션을 이동하는 데 사용될 수 있습니다.\n- 헤더는 다른 섹션 링크를 포함하는 컨테이너입니다.\n- 사용 편의성을 제공합니다.\n- 시간을 절약할 수 있습니다.\n\n## 헤더는 반응형인가요?\n\n네, 헤더는 반응형으로서 화면 크기에 따라 헤더의 크기를 조절합니다.\n\n## 웹 사이트 내에서 헤더의 목적은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n헤더는 사용자 상호작용을 촉진하고 편안한 환경을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_0.png"},"coverImage":"/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_0.png","tag":["Tech"],"readingTime":4}],"page":"55","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}