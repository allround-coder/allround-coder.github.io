{"pageProps":{"posts":[{"title":"JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하는 방법","description":"","date":"2024-06-23 13:08","slug":"2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript","content":"\n\n<img src=\"/assets/img/2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript_0.png\" />\n\n가끔은 JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하고 싶을 때가 있습니다.\n\n이 글에서는 JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하는 방법을 살펴보겠습니다.\n\n# JavaScript로 정의되지 않은 객체에 속성을 자동으로 추가하기\n\n<div class=\"content-ad\"></div>\n\nJavaScript에서 정의되지 않은 객체에 속성을 자동으로 추가하려면 hasOwnProperty 메서드를 사용하여 속성이 있는지 확인할 수 있습니다.\n\n해당 속성이 있으면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n\n만약 false를 반환하면, 원하는 값으로 속성 값을 설정할 수 있습니다.\n\n예를 들어, 다음과 같이 작성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst test = {}\nif (!test.hasOwnProperty('hello')) {\n  test.hello = {};\n}\ntest.hello.world = \"Hello World!\"\n```\n\n우리는 hello 속성을 추가하고 싶은 test 객체를 가지고 있어요.\n\n!test.hasOwnProperty('hello')로 존재하지 않는지 확인해요.\n\n만약 그게 사실이라면, test.hello를 빈 객체로 설정해요.\n\n<div class=\"content-ad\"></div>\n\n그럼 test.hello.world를 \"Hello World!\"로 설정해 봅시다.\n\nhasOwnProperty 메서드는 Object 생성자로부터 상속되므로 쉽게 재정의할 수 있습니다.\n\n따라서 정확한 hasOwnProperty 메서드를 항상 호출하도록 하려면 다음과 같이 작성할 수 있습니다:\n\n```js\nconst test = {}\nif (!Object.prototype.hasOwnProperty.call(test, 'hello')) {\n  test.hello = {};\n}\ntest.hello.world = \"Hello World!\"\n```\n\n<div class=\"content-ad\"></div>\n\nObject.prototype.hasOwnProperty.call을 사용하여 test로 test.hasOwnProperty와 같은 작업을 수행할 수 있지만, 항상 Object 생성자에서 올바른 것을 호출한다는 것을 확인합니다.\n\n# 결론\n\nJavaScript로 정의되지 않은 객체에 자동으로 속성을 추가하려면 hasOwnProperty 메서드를 사용하여 속성이 있는지 확인할 수 있습니다.\n\n해당 속성이 존재하면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\nFalse가 반환되면 속성 값을 원하는 값으로 설정할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoAutomaticallyAddPropertiestoanObjectthatisUndefinedwithJavaScript_0.png","tag":["Tech"],"readingTime":2},{"title":"env 파일 이제는 그만 둘 때  더 나은 대안 찾기","description":"","date":"2024-06-23 13:05","slug":"2024-06-23-Itstimetodeprecatetheenvfile","content":"\n\n<img src=\"/assets/img/2024-06-23-Itstimetodeprecatetheenvfile_0.png\" />\n\n반년마다 우리는 개발자들이 환경 변수를 관리하고 .env 파일을 사용해야 하는지에 대해 논의합니다. 이 논의는 주로 개발자들이 .env 파일 또는 기타 방법 또는 시크릿 매니저를 사용하여 환경 변수를 관리해야 하는지에 대한 것입니다. 짜증난 트윗부터 비디오와 블로그까지 많은 증거가 있어 보여주지만 많은 개발자들이 최적의 방법에 동의할 수 없다는 것을 나타낸다.\n\n명확히 말하자면, 나의 입장은 항상 \"적합한 도구가 있다\"는 것입니다. 간단하거나 샌드박스용 경우에는 .env 파일을 사용하는 것을 고려할 수 있습니다. 그러나 진지한 조직은 시크릿 매니저를 사용하여 전체 인프라 스택 및 개발 주기 전체에 걸쳐 변수를 효율적으로 관리하고 자동화해야 한다고 생각합니다. 이는 그들의 스택에서 .env 파일을 폐기하는 것을 의미합니다.\n\n# .env에 대한 내 의견은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n.env 파일을 사용하는 접근 방식은 zuverlässigekeit(신뢰성) 및 보안과 관련된 상당한 결함을 가지고 있다고 생각하지만 여기에서 자세히 설명하는 것과는 별개로, 이를 계속해서 사용하여 오래된, 부실한 개념을 앞세우는 데 대해 더 큰 문제를 느낍니다. 특히 클라우드 네이티브 컴퓨팅 시대를 고려할 때, 우수한 도구를 대면하여 오래된 개념을 보급하는 것은 더욱 부적절합니다. 요즘에는 각 소프트웨어 인프라 수직으로 필요한 목적에 맞는 도구가 있으므로, 오래된, 오류가 발생하기 쉬우며 비효율적인 방식을 대체하기 위한 새로운 산업 표준을 배우고 채택해야 합니다.\n\n.env가 오래된 이유는 인프라와 개발 주기의 차이점 때문이라고 생각합니다. 적어도 현재처럼 확장성이 더 낮고 넓어진 환경이 아니었다고 주장할 수 있습니다. 그런 \"단순한\" 컴퓨팅 환경에서 이러한 구성 파일을 사용하는 것이 더 타당했었습니다. 이 이유로, 나는 후에 더 설명할 것을 생각해도 간단한 사용 사례를 위해 .env 파일을 사용하는 것에 동의합니다. 왜냐하면 \"일에 적합한 적절한 도구\"가 필요한데, 간단한 작업에는 실제로 간단한 도구만 필요하기 때문입니다.\n\n그러나 오늘날의 컴퓨팅 환경은 근본적으로 다릅니다. 기술적으로는 수평적으로 확장 가능한 서비스를 지원하는 경향이 있으며, 이러한 서비스는 종종 마이크로 서비스 아키텍처, 컨테이너화 및 Kubernetes와 같은 오케스트레이션 도구를 사용하여 운영 환경에서 기계를 수평으로 확장합니다. 또한 캐싱, 로깅, 데이터베이스 및 저장소 솔루션에 의존하는 애플리케이션과 같은 종속 서비스의 수가 증가했습니다(AWS만이 각 소프트웨어 공급 사슬 수직으로 200개 이상의 서비스를 제공한다는 것은 비밀이 아닙니다). 현재는 CI/CD 및 \"임시\" 환경을 포함하는 더 정교한 개발 프로세스도 사용합니다. 전반적으로, 프로세스는 매우 확대됐으므로 대부분의 대규모 조직에서는 복잡한 시스템을 관리하고 최적화하기 위해 플랫폼 엔지니어와 같은 전문 인력을 고용합니다. - 이런 플랫폼 엔지니어들은 자신들의 환경 변수 관리를 더욱 체계적으로 하기 위해 전용 도구를 사용합니다. 이에 대해서 곧 다루어 보겠습니다.\n\n이전에 언급했듯이, \"일에 적합한 적절한 도구\"가 필요하며, 특히 오늘날의 환경에서 일의 성격은 확실히 변했습니다. 변수를 관리하는 문맥에서는 대규모 조직에서 복잡한 스택 전반에 걸쳐 조정되는 수천 개 또는 수십만 개의 변수에 대해 빠르게 이야기하게 됩니다. 따라서 이와 관련하여 귀하의 조직 전반에서 사용해야 할 것들에 대해 논의해 보겠습니다, 이미 채택하지 않았다면요.\n\n<div class=\"content-ad\"></div>\n\n# 시크릿 매니저란 무엇이며 환경 변수 관리에서의 역할은 무엇인가요?\n\n익숙하지 않은 분들을 위해, 시크릿 매니저의 개념에 대해 소개해드리겠습니다: 팀이 애플리케이션 구성 및 API 키, 데이터베이스 자격 증명과 같은 민감한 데이터를 관리하는 데 도움이 되는 전용 솔루션으로, “시크릿”을 관리하는 데 사용됩니다. 인기 있는 시크릿 매니저 예시로는 Infisical, HashiCorp Vault, 그리고 AWS Secret Manager, GCP Secret Manager, Azure Key Vault와 같은 주요 클라우드 제공업체가 있습니다.\n\n시크릿 매니저를 사용하는 주된 이점은 중앙 집중화를 통해 시크릿 확산을 막는 능력입니다. 시크릿 확산의 아이디어는 인프라가 다양한 클라이언트(개발자, 애플리케이션, CI/CD 파이프라인 등)를 가질 수 있고 각각이 자체 변수를 필요로 할 때, 많은 변수를 관리해야 하며 이는 보안 위험, 잘못된 구성, 오류의 가능성을 가져온다는 것입니다. 환경 변수의 진실의 원천을 도입함으로써, 시크릿 매니저는 많은 연관된 시나리오를 피할 수 있도록 도와줍니다:\n\n- 변수를 도입하고 업데이트에 대해 다른 팀 멤버에게 알리지 않는다. 그들이 개발을 진행하다가 누락된 변수와 관련된 버그에 부딪히게 된다.\n- 코드베이스에 변수를 추가하였지만 제품에는 추가하지 않은 채로 운영에 배포하는 경우, 제품 서비스를 다시 배포한 후 모두에게 잘 작동하지 않는 것을 발견할 수 있습니다.\n- 시크릿이 어떤 식으로 유출되었는지 알게 되지만, 사건을 조사하는 능력이 부족하여 그에 대한 다섯 가지 질문에 대답할 수 없게 됩니다.\n- 시크릿이 유출되고, 복잡한 인프라 내에서 그 위치가 명확하지 않아 즉시 폐기하지 못하는 경우가 발생하여, 확산이 발생합니다.\n\n<div class=\"content-ad\"></div>\n\n어떤 사람들에게는 관련성이 적을 수도 있지만 매우 흔하고 문제가 되는 상황들도 있습니다:\n\n- 지금까지 100명 넘는 엔지니어로 성장한 당신의 조직은 개발 주기의 다양한 영역에 접근 가능한 엔지니어들이 있습니다. 새로운 엔지니어들이 조직에 합류하고 떠날 때, 민감한 변수에 대한 직원의 접근을 효과적으로 허용/차단하고 모니터링하는 데 어려움을 겪고 있습니다. 더 나쁜 상황은 최근 해고된 직원이 회사의 프로덕션 데이터베이스에 여전히 접근할 수 있다는 것이 밝혀진다는 것입니다 (실제 이야기를 바탕으로 함).\n- 당신의 조직은 각 고객을 위해 별도의 멀티텐넌트 전용 클러스터 또는 인스턴스를 제공합니다. 각 클러스터/인스턴스는 자체 환경 변수 세트를 필요로 하며, 100,000명을 넘는 고객들의 변수를 추적하는 데 어려움을 겪고 있습니다.\n\n시크릿 늘어남에 대응하는 것 외에도, 시크릿 매니저는 많은 보안 및 운영상의 이점을 제공합니다: 특권이 있는 엔티티에게 변수에 대한 세밀한 접근을 분할, 주기적으로 변수를 회전하거나 트리거에 의해 회전, 플라이에 대한 일회성 데이터베이스 자격 증명 생성, 레코드 보관을 위해 변수 버전 관리/감사, 등과 같은 기능을 포함합니다.\n\n전반적으로, 시크릿 매니저를 응용 프로그램 구성 및 시크릿에 관한 모든 것을 효과적으로 관리하는 데 도움을 주기 위해 만들어진 목적에 맞는 도구로 생각할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 모두가 \"적절한 도구를 올바른 작업에 사용\"을 찾고 있습니다\n\n의견을 조율하기 전에, 적어도 한 가지 사항에 동의할 수 있다고 믿습니다: 우리는 \"작업에 적합한 적절한 도구\"를 사용하려고 합니다. 이는 간단한 작업을 처리하기 위한 최소한의 오버헤드를 도입하고 실제로 요구되는 복잡한 작업을 처리하기 위한 충분한 도구를 사용하겠다는 것을 의미합니다.\n\n환경 변수 관리의 맥락에서, 효율적이고 안전하게 변수를 관리하는 방법이나 도구를 원합니다. 또한 당사 조직의 가용 자원, 능력, 내부 정책 등의 가변적 제약 조건 하에 이를 수행하길 원합니다; 이는 예산, 인프라 복잡성, 팀 규모, 위협 모델 등을 포함합니다. 다르게 말하면, 환경 변수 관리를 최적화하기 위한 작업인 곳에 \"작업에 적합한 적절한 도구\"를 원합니다.\n\n# \"적절한 도구를 올바른 작업에 사용\"은 모두에게 다르게 적용됩니다\n\n<div class=\"content-ad\"></div>\n\n대부분의 사람들이 환경 변수를 가장 잘 관리하는 방법에 대해 의견이 분분한 이유는 \"작업\" 정의가 다른 사람에게는 다르기 때문이라고 믿습니다. 결과적으로, 일부는 최소한의 추가 도구 사용으로 .env 파일을 사용할 것을 주장하고, 다른 사람들은 시크릿 매니저나 보다 정교한 도구가 필요하다는 데에 동의합니다.\n\n일반적인 상황을 설명하자면, 어떤 사람들에게는 \"작업\"이 Vercel에 배포된 단일 애플리케이션에 대해 2개의 환경(개발 및 프로덕션)을 가진 50개의 환경 변수를 관리하는 것을 의미할 수 있습니다. 한편, 다른 사람들에게는 \"작업\"이 수 천 개의 마이크로 서비스를 다중 클라우드 제공업체에 배포하고 온프레미스 구성 요소와 몇 개의 환경(개발, 스테이징, 프로덕션 또는 일회성 환경)에 걸쳐 50,000개 이상의 환경 변수를 조율하는 일을 의미할 수 있습니다. 이 서비스들은 고객을 대상으로 하는 애플리케이션이 아닐 수도 있고, 인프라 스택 내에서 지원 서비스일 수도 있습니다. 예를 들어, 애플리케이션은 데이터베이스, 스토리지, 모니터링/가시성 등을 위해 포스트그레SQL, 레디스, 프로메테우스 등의 서비스 조합에 의존할 수 있습니다.\n\n전자의 경우에는 개발 주기에 시크릿 스프롤(이전에 논의한)이 아직 존재하지 않기 때문에 시크릿 매니저를 도입하는 것이 의미가 없을 수 있습니다. 따라서, 이러한 규모의 팀은 처음부터 굳이 도입할 필요가 없기 때문에 시스템에 오버헤드를 도입하는 것으로 인해 더 높은 재정 및 운영 비용을 부담해야 할 수 있습니다. 그러나 후자의 경우에는 \"작업\"의 거대한 규모 때문에 운영자들이 시크릿 스프롤과 그로 인한 잠재적인 결과에 직면하게 될 것이며, 이를 적절히 대응하지 않을 경우 심각한 다운타임과 재정적 부담이 발생할 수 있습니다. 수천개의 시크릿에 의존하는 인프라 상황에서는 잘못 관리된 시크릿(누락, 노출된 등)이 심각한 다운타임과 재정적 부담을 유발할 수 있으므로, 시크릿 관리의 확률을 최소화할 수 있는 도구를 도입함으로써 장기적으로 상당한 재정 및 운영 비용을 절감할 수 있습니다. 그러나 일반적으로, 우리는 모두 어느 정도는 클라우드 네이티브 컴퓨팅 시대의 일부이기 때문에, 오늘날의 \"작업\"은 결국 더 많은 서비스를 도입함으로써 필연적으로 더 복잡해질 것으로 생각됩니다.\n\n오늘날 더 정교한 환경 변수 관리 도구가 필요한 더 구체적인 예시는 현대 은행 인프라에서 발생합니다. 여기서는 핵심 은행 및 대출 발행 등을 포괄하는 시스템이 복잡하며 규정 및 보안 문제로 인해 멀티 클라우드 및 온프레미스로 구성되어 시크릿 스프롤에 직면하는 경우가 일반적입니다. 애플리케이션/서버 구성의 실수가 수백만 명의 은행 고객에게 지불에 영향을 미칠 수 있기 때문에 오류 허용 여부가 낮으며, 그 결과 환경 변수를 잘못 관리하는 가능성을 낮추기 위해 시크릿 매니저를 사용하는 것은 장기적으로 중요한 비용 절감을 이끌어낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n고유한 케이스 스펙트럼에 따라 각각의 요구 사항이 다르므로, \"일에 알맞은 적절한 도구\"는 작업의 규모와 함께 조절됩니다. 언제나 도구 선택은 조직의 사용 가능한 자원, 능력 및 적응해야하는 정책을 고려해야 합니다.\n\n# 가끔은 \"일\"로 다른 사람들의 작업을 관리해야 할 때가 있습니다\n\n사용자를 위해 자사의 서비스 뿐만 아니라 멀티 테넌트, 전용 서비스도 관리해야 하는 경우라면 많은 환경 변수를 관리해야 하는 사용 사례가 매우 흔합니다.\n\n한 가지 예를 들어보겠습니다. SaaS 플랫폼을 구축하고 다른 조직에게 판매하는 경우를 상상해보세요. 자신의 플랫폼을 공유 클러스터로 구축하여 노드 간에 적용된 환경 변수를 하나의 세트로 제공하는 대신에, 이제 각 고객에게 플랫폼의 전용 클러스터 또는 인스턴스를 제공하도록 인프라를 변경했다고 가정해 봅시다. 이 새로운 모델에서 각 클러스터는 고유한 환경 변수 세트가 필요합니다. 관리해야 할 조직이 1만개일 경우, 각 조직의 클러스터를 위한 비밀 관리를 체계화하고 자동화할 일정 수준의 구조가 필요하다는 것을 빨리 깨닫게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n보통 비록 특이해 보일지라도, 이 사용 사례는 GitHub, MongoDB, Fly.io 등 다양한 플랫폼에 매우 관련이 높습니다. 예를 들어 Fly.io는 풀 스택 앱 및 데이터베이스를 실행하는 플랫폼으로, 여기에서 플랫폼을 통해 배포된 애플리케이션의 환경 변수/시크릿을 어떻게 관리하는지 공개적으로 문서화하고 있습니다. 이 경우에는 \"시크릿이 암호화된 보관소에 저장\"되며, \"flyctl을 통해 시크릿을 설정하면 시크릿 값이 우리의 API를 통해 전송되어, Fly 앱에 대한 보관소로 기록됩니다. API 서버는 암호화만 할 수 있고, 시크릿 값을 해독할 수는 없습니다. 시크릿 값은 절대 기록되지 않습니다.\"\n\n이 사용 사례에서 배울 수 있는 점은 전문화된 보관소나 시크릿 매니저를 사용하여 인프라를 프로비저닝한다는 것이며, API(프론트엔드 UI에 연결되는)는 시크릿에 대한 쓰기 액세스만을 갖고 있고, 아마도 Fly.io의 응용 프로그램을 배포하는 인프라 영역은 응용 프로그램을 읽을 수 있는 능력을 가지고 있다는 것입니다. 수백만 개의 앱의 시크릿을 관리하는 데 도움을 주는 동시에, 시크릿 매니저는 기반이 되는 시스템의 보안을 최적화하기 위해 필요한 안전한 세분화된 권한 시스템을 제공합니다.\n\n# 언제 시크릿 매니저를 사용하는 것이 적절한가요?\n\n일반적으로, 조직이 시크릿 매니저가 필요하다고 판단하는 것은 시크릿 매니저 없이 작업하는 것이 고통스러워질 때입니다. 그렇지만 적정한 타이밍을 결정하는 데 도움이 되는 두 가지 지표는 시크릿이 널리 퍼지기 시작하고 회사가 인프라에 더 관심을 기울이기 시작할 때입니다.\n\n<div class=\"content-ad\"></div>\n\n먼저, 알아차릴 수 있었을 것으로 생각되는대로, 시크릿 관리자가 필요한 정도는 개발자, CI/CD 파이프라인, 및 변수에 액세스해야 하는 애플리케이션 등의 클라이언트 수에 많이 의존합니다. 일반적으로 그 숫자가 충분히 많아지고 연관된 시크릿 확산이 문제가 될 때, 혼돈을 완화하기 위해 전용 도구를 도입하고 싶어할 것입니다.\n\n둘째로, 귀하의 조직이 기술 제품을 운영하고 있다고 가정하면, 시크릿 관리자의 필요성은 주로 인프라에 투자하기 시작했을 때 형성됩니다. 이러한 투자의 성격은 구체적인 기능을 구축하는 데보다는 고객 서비스의 원활한 배포, 테스트, 시스템 신뢰성 등을 보장하는 데 더 관련이 있습니다. 5명 또는 20명의 엔지니어가 되었을 때, 언젠가는 DevOps 엔지니어가 투자의 일환으로 팀에 고용될 것입니다. 이 시점에서 엔지니어는 개발 주기에 시크릿 관리를 포함한 모범 사례를 도입하기 시작할 것입니다.\n\n이러한 지표를 넘어서, 모든 규모와 산업의 기업이 시크릿 관리를 실시한다는 사실을 알 수 있습니다. 규모 구상 계획을 시작하는 5~10명의 팀부터 시크릿 확산을 잡기 위해 필요한 1,000명 조직까지, 시크릿 관리자를 사용하는 기업의 수는 많으므로 일찍 채택하는 데 두려워하지 마세요.\n\n# 그런데... 인터넷에서는 시크릿 관리자가 필요 없다고 생각하는 사람도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n솔직히 말해서, 모든 산업 전반에 걸친 소프트웨어 도구 카테고리는 지지자와 반대자가 있습니다. 공급망에서 비밀 관리 소프트웨어를 포함한 다양한 도구 집합이 \"필요하지 않다\"는 이유로 채택하지 말아야 한다고 주장할 수는 있지만, 그 도구들이 산업 전반에 표준으로 자리 잡고 있다는 점에 대해 당신은 틀렸습니다. 사실은 목적에 특화된 개발자 도구는 소프트웨어 스택 및 개발 프로세스를 개선하고, 제품 제공과 직접적으로 관련이 없는 항목들을 전문적으로 제공하는 업체에게 외부로 전담하여 도와줍니다. 예를 들어,\n\n- 관측 가능한 로깅 도구를 도입하는 것은 불필요하다고 주장할 수 있습니다. 왜냐하면 로그를 자체 호스팅된 오픈 소스 데이터베이스 인스턴스로 전달하고 로그를 직접 쿼리할 수 있기 때문입니다.\n- 키 관리 시스템을 도입하는 것이 불필요하다고 주장할 수 있습니다. 왜냐하면 애플리케이션 수준에서 환경 변수로 저장된 키를 사용하여 직접 데이터의 암호화/해독을 할 수 있기 때문입니다.\n- 당연히 비밀 관리 도구를 도입하는 것은 불필요하다고 주장할 수 있습니다. 왜냐하면 .env 파일을 사용하거나 소스 컨트롤로 직접 공유 변수의 암호화/해독을 할 수도 있기 때문입니다.\n\n이론적으로는 위의 해결책을 직접 구현하여 사용할 수 있지만, 그럴 경우 각자의 문제점을 안고 있을 것입니다. 주요 장점을 잃거나 프로세스의 최적화를 잃게 되거나, 마지막에는 해당 소프트웨어 스택의 일부에 대해 전용 도구를 채택하는 것보다 해당 부분을 자체적으로 개발하는 데 더 많은 시간을 투자하게 될 것입니다.\n\n비밀 관리의 맥락에서, 이것은 저만의 권고가 아닌 업계 전체에서 채택되는 인프라 실천 방식 및 도구입니다. 비밀 퍼지기가 심각한 문제로 여겨질 때 특정 규모에 도달한 조직이 채택하는 것입니다. 제가 말하는 게 마구잡이 광고가 아니라 그것은 주요 클라우드 제공 업체들이 자사의 비밀 관리 제품을 보유하거나 GitHub나 Ubisoft와 같은 조직들이 어떻게 비밀 관리자를 사용하는지 알아보는 것을 통해 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 좋은데… 하지만 도구의 안전성은 어떻게 되나요?\n\n당연히 시크릿 관리에 대한 새로운 이용자들은 API 키와 데이터베이스 자격 증명을 신뢰할 수 있는 제3자가 관리할 수도 있는 서비스에 전달하는 것에 대해 유효한 보안 우려가 있습니다. 알다시피, 제3자의 서비스는 여러 액세스 토큰을 한꺼번에 훔치기를 원하는 나쁜 행위자들에게 주로 대상이 될 수 있습니다. 플랫폼 코드에 보안 취약점이 포함되어 있다면 침입당할 수 있고 … 그 이후 일들은 엉망이 될 수 있습니다.\n\n이러한 우려를 고려하여 아래에 몇 가지 생각을 정리해 보았습니다:\n\n- 모든 변수를 하나의 도구에 저장하면 해당 도구가 침해당하면 모든 변수가 유출될 수 있다고 걱정하실 지도 모릅니다. 이는 정당한 우려이지만, 모든 시크릿 매니저는 조직 수준과 제품 수준 모두 최고 수준의 보안을 보장하기 위한 중요한 조치들을 시행한다는 점을 알아야 합니다. 보통 이에는 보안 감사, 인증, 침투 테스트, 특정 기능 (예: 인증/인가 제어, IP 제한과 관련된 토큰 바인딩 제한; TTL; 그리고 더 많은 것들) 등이 포함됩니다. 시크릿 관리 워크플로에 적용할 수 있는 맞춤화와 레이어링이 얼마나 많은지 깜짝 놀랄 것입니다. 마지막으로, 이에 대해 항상 믿을 수 있는 또는 잘 알려진 공급업체를 사용하는 것을 권장합니다. 시크릿 관리는 본질적으로 매우 민감한 영역이므로요.\n- 특히 나쁜 행위자들을 위한 주요 대상이 될까봐 걱정하실 수도 있습니다. 이에 대해, Infisical 및 Vault와 같은 오픈 소스 솔루션들을 살펴보는 것을 강력히 추천드립니다. 이러한 솔루션들은 클라우드 인프라나 온프레미스에 배포하여 다른 사람의 대상이 되는 것을 방지할 수 있습니다.\n- 마지막으로, 규모 확장에 따른 시크릿 분산과 관련된 위험을 다루는 것이 문제를 완화하는 전용 도구를 사용하는 것보다 훨씬 나을 수 있습니다. 아직 느끼지 못했을지 모르겠지만, 문제가 자연스럽게 발생하면 알게 될 것입니다. 여기서 사용하는 비유는 시크릿 관리자를 패스워드 관리자에 비교하는 것인데, 많은 암호를 관리해야 할 때 더 유용해집니다. 사용하기 전에 여러 서비스에 걸친 약간의 패스워드에 만족했으며 때때로 암호를 잊어버린 적이 있어 암호 복구 과정을 거쳐 서비스 로그인을 재설정했었습니다. 그렇지만, 서로 다른 암호 요구 사항을 충족시키는 각 암호의 수가 증가함에 따라, 각 조합을 수동으로 추척하고 효과적으로 패스워드 분산에 직면하게 되었습니다. 이것은 나에게 비밀번호 관리자에 가입하도록 설득하였고, 그 이후로는 되돌아보지 않았습니다.\n\n<div class=\"content-ad\"></div>\n\n최종적으로, 비밀 노출 문제에 직면할 때 보안 정보가 널리 퍼지는 상황을 고려할 때 비밀 관리자를 사용하는 필요성이 그것이 없는 것에 비해 더 높습니다. 따라서 신뢰할 수 있는 솔루션을 채택하고 권장된 보안 제어를 구현해야 합니다. 해결책 구성이든 개발 주기 전체에서 변수를 최상의 방법으로 검색하는 워크플로 권장사항이든 상관없이요.\n\n# 알겠어. 난 설득됐어. 비밀 관리자를 어떻게 사용하는지 보여줘, 코드 좀 줘봐\n\n일을 간단하게 유지하기 위해, Infisical을 사용할 거야. 이 오픈 소스 비밀 관리 플랫폼을 사용할 텐데. Vault나 AWS Parameter Store와 같은 다른 비밀 관리자도 사용할 수 있는데, Infisical을 선택한 이유는 빠르게 구동할 수 있고, 자체 인프라에서 호스팅할 수 있으며 잘 문서화되어 있기 때문이야.\n\n![그림](/assets/img/2024-06-23-Itstimetodeprecatetheenvfile_1.png)\n\n<div class=\"content-ad\"></div>\n\n어쨌든, 이 간단한 예제를 통해 런타임에 환경 변수를 가져오기 위해 Node SDK를 사용할 것입니다. 그러나 환경 변수를 API 호출을 통해 가져오거나, 다른 SDK(파이썬, 자바, C# 등), CLI, 쿠버네티스 오퍼레이터, 인피지컬 에이전트 등의 다른 메서드도 사용할 수 있습니다. 이는 당신의 스택 및 개발 주기와 같은 여러 요인에 따라 당신에게 더 적합할 수 있습니다.\n\n그럼 시작해봅시다.\n\n먼저, 프로젝트에 패키지를 설치하세요:\n\n```js\n$ npm install @infisical/sdk\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로 SDK를 가져와서 기계 식별 유니버설 인증 자격증명으로 클라이언트 인스턴스를 생성하세요.\n\n```js\nimport { InfisicalClient, LogLevel } from \"@infisical/sdk\";\n\nconst client = new InfisicalClient({\n    clientId: \"YOUR_CLIENT_ID\",\n    clientSecret: \"YOUR_CLIENT_SECRET\",\n    logLevel: LogLevel.Error\n});\n```\n\n최적의 성능을 보장하기 위해 클라이언트의 단일 인스턴스를 생성하고 전체 앱에서 사용하도록 내보내는 것을 권장합니다. SDK는 주기적으로 업데이트될 수 있는 비밀을 캐시할 수 있기 때문에 불필요한 호출을 줄이고, 이 내장 캐싱은 환경 변수를 대규모로 동기화하는 것을 원활하게 만듭니다.\n\n이제 클라이언트를 사용하여 애플리케이션에 필요한 비밀을 필요에 따라 가져올 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\napp.get(\"/\", async (req, res) => {\n    // 접근 값 설정\n\n    const name = await client.getSecret({\n        environment: \"dev\",\n        projectId: \"PROJECT_ID\",\n        path: \"/\",\n        secretName: \"NAME\"\n    });\n\n    res.send(`안녕하세요! 제 이름은: ${name.secretValue}`);\n});\n```\n\n이제 애플리케이션이 환경 변수를 필요로 할 때, 필요한 환경 변수를 Infisical로부터 요청할 수 있습니다. 이제 Node 애플리케이션의 모든 환경 변수를 한 곳에서 확인하고 누락된 환경 변수를 방지할 수 있습니다.\n\n이전에 언급했듯이, 이는 런타임 중에 애플리케이션을 위한 변수를 가져오기 위해 시크릿 매니저를 사용하는 방법의 미니멀한 예시입니다. 사용 사례에 따라, 또 다른 방법으로 시크릿 매니저와 프로그래밍 방식으로 상호 작용하는 것이 더 적합할 수 있습니다. 어떠한 경우에도, 이에 관심이 있다면 여기서 Infisical 문서를 참고해야 합니다.\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n시크릿 매니저는 인프라스트럭처 공간에 처음 입문하는 사람들에게 종종 오해받는 도구지만, 복잡한 인프라 작업을 간소화하고 여러 변수에 의존하는 조직에게 매우 관련이 있습니다. 클라우드 네이티브 컴퓨팅 시대에는 전형적인 인프라가 수백 개 이상의 분산된 서비스 및 복제로 구성되어 있기 때문에, 작업에 적합한 도구를 배우고 사용하는 것이 중요합니다.","ogImage":{"url":"/assets/img/2024-06-23-Itstimetodeprecatetheenvfile_0.png"},"coverImage":"/assets/img/2024-06-23-Itstimetodeprecatetheenvfile_0.png","tag":["Tech"],"readingTime":13},{"title":"웹 컴포넌트에서 커스텀 상태의 숨겨진 힘","description":"","date":"2024-06-23 13:03","slug":"2024-06-23-TheHiddenPowerofCustomStatesForWebComponents","content":"\n\n사용자 정의 요소의 진화 과정에서 중요한 단계\n\n![image](/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png)\n\n이전에 썼던 \"웹 컴포넌트가 이제 네이티브 폼 요소가 될 수 있게 되었고\"와 \"웹 컴포넌트의 네이티브 폼 유효성 검사\"라는 기사에서, ElementInternals 속성에 대해 설명했었어요. 이 속성을 통해 사용자 정의 요소가 양식과 관련되도록 할 수 있게 되었죠.\n\n이 인터페이스는 또한 개발자들이 사용자 정의 상태와 사용자 정의 요소를 연관시킬 수 있도록 하며, 이 상태에 기반하여 스타일을 입힐 수 있게 해줍니다.\n\n<div class=\"content-ad\"></div>\n\nElementInternals의 states 속성은 사용자 지정 요소가 있는 상태를 나타내는 CustomStateSet을 반환합니다. 이 CustomStateSet은 집합에 추가 및 제거를 가능하게 합니다.\n\n집합의 각 상태는 문자열로 표시되며 현재 그에는 두 가지 유형의 구문이 있습니다:\n\n- 이전 구문: --mystate (향후 지원 중단 예정)\n- 새로운 구문: mystate\n\n이러한 상태는 내장된 상태와 마찬가지로 사용자 지정 상태 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 선택된 체크박스는 내장된 :checked 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n```js\ninput[type=”checkbox”]:checked {\n outline: solid green;\n}\n```\n\n다른 예로, 비활성화된 버튼은 :disabled 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n```js\nbutton:disabled {\n cursor: not-allowed;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n비슷하게, 사용자 정의 상태를 포함하는 요소는 다음과 같은 방식으로 CSS에서 액세스할 수 있습니다:\n\n```js\n/* 이전 구문 */\nmy-element:--mystate {\n  color: red;\n}\n\n/* 새 구문 */\nmy-element:state(mystate) {\n  color: red;\n}\n```\n\n# 사용자 정의 상태의 사용 사례\n\n사용자 정의 상태는 강력한 기능을 해제합니다.\n\n<div class=\"content-ad\"></div>\n\n내부 상태에 기반을 둔 Web Components의 스타일링을 지원하기 때문에 이러한 상태를 반영하기 위해 컴포넌트에 속성이나 클래스를 추가할 필요가 없어요. 따라서 완전히 내부적으로 유지됩니다.\n\n예를 들어, `video-player` 컴포넌트가 있고 이 컴포넌트는 비디오를 재생하는 데 사용되는 재생 버튼을 표시합니다.\n\n재생 버튼을 클릭하면 비디오가 재생되고, 이 때 재생 버튼이 숨겨지고 일시 정지 버튼이 표시되기를 원합니다.\n\n그런 후 일시 정지 버튼을 클릭하면 이 버튼이 숨겨지고 재생 버튼이 다시 표시되어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n이 작업을 간단히 수행하는 방법은 플레이 속성을 소개하고 해당 속성을 반영하고 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 것입니다.\n\n```js\nclass VideoPlayer extends HTMLElement {\n\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({mode: 'open'});\n\n    shadowRoot.innerHTML = `\n      <style>\n        :host {\n          display: block;\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        :host([playing]) #play {\n          display: none;\n        }\n\n        :host([playing]) #pause {\n          display: block;\n        }\n      </style>\n\n      <button id=\"play\" type=\"button\">Play</button>\n      <button id=\"pause\" type=\"button\">Pause</button\n    `;\n  }\n\n  connectedCallback() {\n    const playButton = this.shadowRoot.querySelector('#play');\n    const pauseButton = this.shadowRoot.querySelector('#pause');\n\n    playButton.addEventListener('click', () => {\n      this.playing = true;\n    });\n\n    pauseButton.addEventListener('click', () => {\n      this.playing = false;\n    });\n  }\n\n  get playing() {\n    return this.hasAttribute('playing');\n  }\n\n  set playing(isPlaying) {\n    if(isPlaying) {\n      this.setAttribute('playing', '');\n    }\n    else {\n      this.removeAttribute('playing');\n    }\n  }\n}\n```\n\n기본적으로 재생 버튼이 표시됩니다. 플레이 속성을 위한 설정자가 정의되어 해당 속성을 설정하거나 제거하며 CSS 규칙은 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 역할을 합니다.\n\n아래에 작동하는 예제가 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n이 방법은 잘 작동하지만 이 구현에 잠재적인 문제가 있을 수 있어요.\n\n이렇게 내부 속성을 속성으로 노출하는 것은 항상 바람직하지 않을 수 있고 캡슐화를 깨버릴 수 있어요.\n\n이 경우 playing 속성을 노출하는 것은 나쁜 생각은 아닐 수 있지만, 이는 사용자가 그냥 속성을 추가함으로써 컴포넌트를 재생 상태로 수동 설정할 수 있지만, 실제로 비디오가 재생되는 것은 아니라는 점이에요.\n\n이 속성을 노출함으로써 사용자가 playing 속성을 추가하기만 하면 비디오를 재생할 수 있다는 기대감조차 줄 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n사실 특정 상태의 웹 컴포넌트를 설정하기 위해 속성을 추가하는 것은 해당 상태를 설정하는 것이 아니기 때문에 playing 속성을 true로 설정하지 않습니다. playing 속성에 playing 속성을 추가하는 것만으로 playing 속성을 true로 설정하지는 않습니다.\n\n이 경우 실제로 심각한 피해를 입히지는 않겠지만 내부 속성을 노출하는 것이 좋지 않은 경우가 항상 있을 수 있습니다.\n\n이것은 사용자 정의 상태에 대한 완벽한 사용 사례입니다. 속성은 노출되지 않지만 이러한 상태에 기반한 CSS 스타일을 사용하여 컴포넌트를 여전히 스타일링할 수 있습니다.\n\n# 사용자 정의 상태 추가 및 제거\n\n<div class=\"content-ad\"></div>\n\n언급한 바와 같이 모든 사용자 지정 상태는 ElementInternals 인터페이스의 states 속성에 저장된 CustomStateSet 객체에 저장됩니다.\n\n상태를 추가하고 제거하는 데 사용되는 add 및 delete 메서드와 요소가 특정 상태를 갖고 있는지 확인하는 has 메서드가 있습니다.\n\n다른 주목할 만한 메서드로는 모든 상태를 지우는 clear 및 요소의 모든 상태를 반복하는 forEach가 있습니다:\n\n```js\n// 내부 구현 부착\nthis.internals = this.attachInternals();\n\n// 상태 추가 예전 문법\nthis.internals.states.add('--foo');\n\n// 상태 추가 새 문법\nthis.internals.states.add('bar');\n\n// 상태 반복\nthis.internals.states.forEach(state => {\n console.log(state); // foo bar\n});\n\n// 상태 제거 예전 문법\nthis.internals.states.delete('--bar');\n\n// 상태 제거 새 문법\nthis.internals.states.delete('bar');\n\n// 상태 존재 여부 확인 예전 문법\nthis.internals.states.has('--foo'); // true\nthis.internals.states.has('--bar'); // false\n\n// 상태 존재 여부 확인 새 문법\nthis.internals.states.has('foo'); // true\nthis.internals.states.has('bar'); // false\n```\n\n<div class=\"content-ad\"></div>\n\n브라우저에서 오래된 구문만 지원하는 경우 --로 시작하지 않는 상태를 추가하려고 할 때 오류가 발생합니다:\n\n```js\nthis.internals = this.attachInternals();\nthis.internals.states.add('foo'); // 오류, '--'로 시작하지 않음 (오래된 구문만 지원)\n```\n\n이전 예제가 사용자 정의 상태와 함께 작동하도록 하려면 `playing` 속성의 게터 및 세터를 상태와 함께 작동하도록 변경해야 합니다. 이를 오래된 및 새로운 구문을 지원하는 브라우저에서 작동하도록 하려면 --없이 상태를 설정하는 것은 try/catch 블록으로 감싸야 합니다:\n\n```js\nget playing() {\n  return this.internals.states.has('--playing') || this.#internals.states.has('playing');\n}\n\nset playing(isPlaying) {\n  if(isPlaying) {\n    try {\n      this.internals.states.add('playing');\n    }\n    catch(e) {\n      this.internals.states.add('--playing');\n    }\n  }\n  else {\n   this.internals.states.delete('playing');\n   this.internals.states.delete('--playing');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경했습니다.\n\n```js\n/* 이전 구문 */\nhost(:--playing) #play {\n  display: none;\n}\n\n/* 이전 구문 */\n:host(:--playing) #pause {\n  display: block;\n}\n\n/* 새로운 구문 */\nhost(:state(playing)) #play {\n  display: none;\n}\n\n/* 새로운 구문 */\n:host(:state(playing)) #pause {\n  display: block;\n}\n```\n\n내부 속성이 속성으로 노출되지 않도록 하는 것은 좋지만, 여전히 소비자가 내부 속성을 통해 상태에 액세스하고 add 및 delete 메서드를 호출하여 상태를 추가하거나 제거할 수 있습니다:\n\n```js\nconst player = document.querySelector('video-player');\n\n// 이전 구문\nplayer.internals.states.add('--playing');\n\n// 새로운 구문\nplayer.internals.states.add('playing');\n```\n\n<div class=\"content-ad\"></div>\n\n더 좋지 않은 점은 소비자가 내부 상태를 변경하기 위해 playing의 setter를 호출할 수 있다는 것입니다.\n\n이를 수정하여 getter와 setter 및 내부 속성을 모두 #으로 접두사를 붙여 private로 만들 수 있습니다:\n\n```js\n// internals is now private\nthis.#internals = this.attachInternals();\n\nget playing() {\n  return this.#internals.states.has('--playing') || this.#internals.states.has('playing');\n}\n\nset playing(isPlaying) {\n  if(isPlaying) {\n    try {\n      this.#internals.states.add('playing');\n    }\n    catch(e) {\n      this.#internals.states.add('--playing');\n    }\n        \n  }\n  else {\n   this.#internals.states.delete('playing');\n   this.#internals.states.delete('--playing');\n  }\n}\n```\n\nprivate 속성에 대한 getter와 setter 쌍을 작성하는 것이 직관적이지 않을 수 있지만, 이것이 실제로 작동한다는 것에 주목하세요.\n\n<div class=\"content-ad\"></div>\n\n비록 playing에 getter와 setter가 정의되어 있지만, 여전히 private이며 클래스 내에서만 접근 가능합니다.\n\n값을 할당하면 setter가 호출되고 값을 읽으면 getter가 호출됩니다.\n\n아래에 전체 코드가 있습니다:\n\n```js\nclass VideoPlayer extends HTMLElement {\n  #internals;  // private property를 필요로 하는 클래스 필드\n\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({mode: 'open'});\n\n    this.#internals = this.attachInternals();\n\n    shadowRoot.innerHTML = `\n      <style>\n        :host {\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        /* 예전 문법 */\n        :host(:--playing) #play {\n          display: none;\n        }\n\n        :host(:--playing) #pause {\n          display: block;\n        }\n\n        /* 새로운 문법 */\n        :host(:state(playing)) #play {\n          display: none;\n        }\n\n        :host(:state(playing)) #pause {\n          display: block;\n        }\n      </style>\n\n      <button id=\"play\" type=\"button\">재생</button>\n      <button id=\"pause\" type=\"button\">일시정지</button>\n    `;\n  }\n\n  connectedCallback() {\n    const playButton = this.shadowRoot.querySelector('#play');\n    const pauseButton = this.shadowRoot.querySelector('#pause');\n\n    playButton.addEventListener('click', () => {\n      this.#playing = true;\n    });\n\n    pauseButton.addEventListener('click', () => {\n      this.#playing = false;\n    });\n  }\n\n  get playing() {\n    return this.#internals.states.has('--playing') || this.#internals.states.has('playing');\n  }\n\n  set playing(isPlaying) {\n    if(isPlaying) {\n      try {\n        this.#internals.states.add('playing');\n      }\n      catch(e) {\n        this.#internals.states.add('--playing');\n      }\n    }\n    else {\n      this.#internals.states.delete('playing');\n      this.#internals.states.delete('--playing');\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 여기에는 오래된 구문과 새 구문 둘 다 작동하는 작동 예제가 있습니다:\n\n이 예제들은 커스텀 상태에 기반하여 커스텀 요소를 내부 컴포넌트 내에서 :host 가상 클래스를 사용하여 스타일링하는 방법을 보여줍니다.\n\n커스텀 요소는 사용자 정의 상태에 기반하여 외부에서 스타일링될 수도 있습니다.\n\n이 스타일링은 :checked나 :hover와 같은 내장 상태에 기반하여 구성 요소를 스타일링하는 것과 동일한 형태를 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* 예전 구문 */\nvideo-player:--playing {\n  border: 1px solid red;\n}\n\n/* 새로운 구문 */\nvideo-player:state(playing) {\n  border: 1px solid red;\n}\n```\n\n같은 CSS 속성에 대한 사용자 지정 상태를 기반으로 스타일 지정이 내부와 외부에서 모두 정의된 경우, 외부에서 정의된 스타일이 우선합니다.\n\n다음 예제에서 컴포넌트는 --playing/playing 사용자 지정 상태일 때 녹색 테두리가 추가됩니다.\n\n--playing/playing 상태에 대해 컴포넌트 내부에서 정의된 파란색 테두리는 덮어씌워집니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 컴포넌트 외부에서 정의된 스타일\n// 이렇게 하면 컴포넌트에 녹색 테두리가 우선적으로 적용됩니다.\n// 이전 구문\nvideo-player:--playing {\n  border: 2px solid green;\n}\n\n// 새로운 구문\nvideo-player:state(playing) {\n  border: 2px solid green;\n}\n\n// 컴포넌트 내부에서 정의된 스타일\n// 외부에서 정의된 스타일에 덮어씌워지게 됩니다.\n// 이전 구문\n:host(:--playing) {\n  border: 2px solid blue;\n}\n\n// 새로운 구문\n:host(:state(playing)) {\n  border: 2px solid blue;\n}\n```\n\n# 결론\n\n사용자 정의 상태(Custom States)는 웹 컴포넌트의 진화를 위한 중요한 단계입니다.\n\n이를 통해 컴포넌트의 상태를 속성이나 클래스를 추가하지 않고도 스타일링할 수 있어 외부에서 상태를 조작할 수 없도록 유지할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n커스텀 상태는 Chrome, Edge, Safari Tech Preview 187에서는 CustomStateSet 기능 플래그가 활성화되어 있고, Firefox 122에서는 dom.element.customstateset.enabled가 true로 설정되어 있을 때 지원됩니다.\n\n현대 웹 플랫폼, 웹 컴포넌트, 그리고 Progressive Web Apps에 관한 제 주간 뉴스레터 'Modern Web Weekly'에 가입해보세요.","ogImage":{"url":"/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png"},"coverImage":"/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png","tag":["Tech"],"readingTime":11},{"title":"상위 1 웹 개발자가 되기 위해 꼭 가져야 할 10가지 기술","description":"","date":"2024-06-23 13:02","slug":"2024-06-23-10must-haveskillstobecomeatop1webdeveloper","content":"\n\n\n![Image](/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png)\n\n웹 개발자가 반드시 갖추어야 할 10가지 필수 기술…\n\n이미 알고 있을 수 있는 웹 기초부터 시작하여 브라우저 개발 도구를 활용하고 AI로 빠르게 코딩하는 것과 같은 중요한 기술까지 배워보세요.\n\n이론적 지식보다는 실제 행동에 초점을 맞춘 것을 알 수 있죠 — 왜냐하면 그것이 중요하기 때문입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 1. HTML essentials: Create a basic functional web page\n\n웹 사이트의 핵심 뼈대에 대해 알아보세요.\n\n다음과 같이 진행해보세요:\n\n- 편집기에서 HTML 페이지를 만들고 브라우저에서 엽니다\n- 페이지 제목 및 아이콘 설정\n- 텍스트 단락 만들기\n- 제목 만들기\n- 다른 페이지로 연결하는 링크 만들기\n- 이미지 표시\n- 테이블 데이터 표시\n- 요소 목록 표시\n- 폼을 사용하여 입력 처리\n- 주석 만들기 및 코드 주석 처리\n- 시맨틱 HTML로 페이지를 더 유의미하게 만들기\n\n<div class=\"content-ad\"></div>\n\n일부 사람들은 CSS 때문에 시맨틱 HTML이 무의미하다고 생각하지만, 그들은 틀렸어요.\n\n접근성과 페이지 내용을 검색 엔진에 설명하여 결과 페이지에서 높은 순위를 얻는 데 여전히 중요합니다.\n\n\n![image](/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_1.png)\n\n\n시맨틱 요소가 없다면, 모든 것에 'div'를 사용하는 개발자들처럼 될 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 2. CSS 핵심: 웹 페이지 스타일링\n\n이렇게 변화시킬 수 있어요:\n\n![Before and after](/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_2.png)\n\n<div class=\"content-ad\"></div>\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*OjV0rbJN2AKW1VAh.gif)\n\n뼈대에 생명을 불어넣는 방법:\n\n- 페이지에 스타일 추가하기\n- 색상 추가: 채우기, 그라데이션, 불투명도, 전경 및 배경 색상\n- 글꼴 사용자 정의: 글꼴 패밀리, 크기, 스타일, 두께, 웹 안전한 글꼴, Google Fonts\n- 레이아웃 만들기: 여백 및 안팎 간격, 시각적 쌓임, 상대적 정렬\n- 배경 추가 및 사용자 정의\n- 애니메이션 및 전환으로 더 매력적으로 꾸미기\n- 특정 상태 및 요소 부분에 스타일 적용: 가상 선택자 및 가상 클래스\n- 모양 사용자 정의: 외곽선 및 테두리, 높이, 너비\n- 스타일 재사용: CSS 변수\n- 모든 화면 크기에 대해 멋지게 보이도록 페이지 스타일링하기: 미디어 쿼리, 반응형 이미지\n- 프레임워크로 더 빨리 스타일링하기: Tailwind, Sass\n\n<div class=\"content-ad\"></div>\n\n# 3. JavaScript essentials\n\n웹 페이지에 상호 작용성을 추가하고 일어나는 일들을 만드는 방법:\n\n# 기본 사항\n\n코딩을 처음 시작하신 분들에게:\n\n<div class=\"content-ad\"></div>\n\n어떻게:\n\n- 프로그래밍에 대해 생각해보기\n- 페이지에 JavaScript 코드 추가\n- 출력하기: alert(), innerHTML, console logging\n- 데이터 관리하기 — 변수 만들기, 사용하기, 업데이트하기, 출력하기: 데이터 타입, 스코프\n- 주석 작성하기 및 기존 코드를 주석 처리하기\n- 동작 재사용하기: 함수 만들기 및 호출하기: 구문, 매개변수 및 인자, 반환 값, 타입, 스코프\n- 현실 세계 엔티티를 나타내는 객체들 생성하기: 데이터 및 변수, 동작 및 메소드, 중첩된 객체\n- 페이지의 요소 선택 및 조작하기: getElementById, querySelector, 메소드 및 속성 사용 등\n- 입력 및 이벤트 처리하기: 웹 페이지에서 등\n- 문자열로 텍스트 조작하기: 여러 줄, 부분 문자열, 대소문자, 연결, 보간, 분할 및 결합, 자르기 및 채우기, 검색 및 대체, 정규 표현식\n- 목록 사용하기: 초기화, 추가, 업데이트, 제거, 반복, 변환, 검색, 필터, 정렬, 역순\n- 날짜와 시간 사용하기: 생성, 업데이트, 형식화 및 표시\n- 조건부로 데이터 가져오거나 동작하기: if/else, switch, 삼항 연산자, 사전 선택\n- 조건부로 계속해서 동작하기: while, do while, for, break, continue\n- TypeScript로 개발 환경 업그레이드하기: 타입, 제네릭, 인터페이스, 트랜스 파일링, 구성 설정 등.\n\n# 클라이언트 측 개발\n\n당신은 코딩 기초를 알고 계시겠지만, 브라우저에 특히적인 JS 코드를 작성할 수 있나요?\n\n<div class=\"content-ad\"></div>\n\n아래와 같은 방법으로:\n\n- 서버에 네트워크 요청을 보내는 방법: fetch() API, HTTP 동사, 데이터 전송 및 수신\n- UI 상태 다루기: 비어 있는 상태, 로딩 중인 상태, 오류가 발생한 상태, 일부만 화면에 나타낸 상태, 이상적인 상태\n- 데이터를 로컬에 저장하기: 쿠키, 로컬 저장소, 세션 저장소 등\n- 코드를 구성하고 패키지화하는 방법: 모듈 및 모듈 번들러\n- 폼 입력 처리하기\n- NPM 패키지를 사용하여 더 빠르게 코딩하는 방법\n\n# 4. 개발 도구로 삶의 질 개선하기\n\n아래와 같은 방법으로:\n\n<div class=\"content-ad\"></div>\n\n- 콘솔 로그를 만들고 검사하고 필터링하세요: 정보, 오류, 경고\n- 임시 스크립트 및 작업을 추가하세요\n- HTML 요소를 검사, 선택, 및 디버그하세요\n- 스타일을 임시로 수정하세요\n- 네트워크 요청을 모니터링하세요\n- 여러 화면 크기에서 페이지를 테스트하세요\n- 더 빨리 개발하기 위해 편집기 확장 기능을 설치하세요\n- 편집기 테마, 글꼴 및 설정을 사용자 정의하여 개발을 더 즐기세요\n- 통합된 디버거를 사용하세요\n- Emmet을 포함한 스니펫을 사용하여 더 빠르게 코드를 작성하세요\n- 키보드 단축키를 사용하여 더 빨리 개발하세요\n- AI를 사용하여 더 빨리 개발하세요\n\n# 5. 사이트 성능 향상\n\n방법:\n\n- 성능을 측정하세요\n- 인지 성능을 향상시키세요\n- 핵심 웹 핵심 지표 개선: LCP, CLS, INP\n- 일반적인 리소스 전달을 최적화하세요: 캐싱,\n- 이미지를 최적화하세요: 압축, WebP\n- 이미지와 비디오를 지연 로드하세요\n- CSS를 최적화하세요\n- 웹 글꼴을 최적화하세요: 압축, 스와핑 등.\n\n<div class=\"content-ad\"></div>\n\n# 6. 자바스크립트 프레임워크: 빠르게 개발하기\n\nReact, Angular 또는 Vue인 경우에 관계없이 모두 동일한 기본 개념을 가지고 있습니다.\n\n다음 방법에 대해 알아 봅시다:\n\n- 컴포넌트를 생성하고 재사용합니다\n- 컴포넌트에서 데이터를 수락하고 표시합니다: 데이터 바인딩, 조건부 렌더링 등\n- 컴포넌트에서 상태를 관리합니다\n- 목록 데이터를 표시하고 업데이트합니다\n- 컴포넌트에서 이벤트를 처리합니다\n- 부작용 및 외부 데이터 변경 및 상태 변경을 처리합니다\n- 앱-수준 상태를 관리합니다 — 컴포넌트와 독립적으로\n- 폼 입력을 처리합니다\n- 컴포넌트를 스타일링합니다\n- 프론트엔드 라우팅을 사용한 SPA 네비게이션을 처리합니다\n\n<div class=\"content-ad\"></div>\n\n# 7. 버전 컨트롤: 변경 사항 추적\n\n버전 컨트롤을 사용하면 코드베이스 전체의 변경 사항을 추적하고 실험하는 것이 쉬워집니다.\n\n방법:\n\n- 로컬 저장소를 만들어 코드 및 에셋을 저장합니다.\n- 파일 및 변경 사항을 스테이징하고 커밋합니다: 최선의 방법, 등.\n- .gitignore를 사용하여 파일 무시\n- 이전 커밋 가져오기\n- 새 브랜치 생성: 최신 또는 이전 커밋에서\n- 브랜치 병합: 병합 충돌 해결 등.\n\n<div class=\"content-ad\"></div>\n\n# Git & GitHub\n\n다음을 참고하세요:\n\n- 자신의 GitHub 레포지토리 만들기: README.md, 라이센스 등\n- 원격 저장소 사용하기: 만들기, 푸시, 풀, 제거\n- GitHub에서 레포지토리 복제하기\n- GitHub 레포지토리 포크하기\n- GitHub 레포지토리에 풀 리퀘스트 만들기\n\n# 8. 데이터베이스에서 데이터 관리하기\n\n<div class=\"content-ad\"></div>\n\n프론트엔드에 전념하고 있더라도 데이터 처리 및 조작에 대한 이해력을 향상시킬 수 있습니다.\n\n다음을 하는 방법:\n\n- 데이터를 위한 스키마 설계\n- 스키마 구현: 테이블, 키, 데이터 형식, 외래 키, 컬렉션 (NoSQL)\n- 데이터베이스에 데이터 추가\n- 데이터 읽기: 조인, 필터링, 정렬, 검색, 집계\n- 데이터 업데이트\n- 데이터 삭제\n\n# 9. 서버 측 개발\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n- 필요 시 빠르게 학습하기\n- 코드에서 독립적으로 문제 해결하기\n- 디자이너, 클라이언트 및 다른 개발자와 소통하기\n- 디버그하고 인내심을 갖기\n- 필요에 따라 정보를 검색하고 필요에 맞게 처리하기\n\n# 마무리\n\n이 모든 것을 배우면 웹 앱과 사이트의 99%를 높은 품질과 빠른 속도로 처음부터 끝까지 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png"},"coverImage":"/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png","tag":["Tech"],"readingTime":5},{"title":"React로 카운트다운 타이머 만드는 방법","description":"","date":"2024-06-22 15:35","slug":"2024-06-22-BuildingaCountdownTimerinReact","content":"\n\n\n![Countdown Timer](/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png)\n\nReact 애플리케이션에 동적 카운트다운 타이머를 추가해보고 싶었나요? 생산성 앱을 만들고 있거나 라이브 이벤트를 진행하거나 웹사이트를 화려하게 꾸미고 싶은 경우, 카운트다운 타이머는 매력적이고 기능적인 추가물이 될 수 있습니다. 이 기사에서는 React.js를 사용하여 간단하면서도 강력한 1시간 카운트다운 타이머를 구축하는 방법에 대해 살펴보겠습니다.\n\n# 시작하기\n\n코드에 들어가기 전에, 우리가 달성하려는 목표를 명확히 해 봅시다. 우리의 목표는 실시간으로 업데이트되는 시각적으로 매력적인 카운트다운 타이머를 만드는 것입니다. 이 타이머는 1시간부터 0까지 카운트다운됩니다. 이를 달성하기 위해 우리는 인기 있는 React 라이브러리와 useState 및 useEffect 훅을 활용할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 카운트다운 컴포넌트\n\n시작해봅시다. 카운트다운 타이머 컴포넌트를 만들어봅시다. 이 컴포넌트는 카운트다운 논리와 렌더링을 캡슐화할 것입니다.\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nconst CountdownTimer = () => {\n  // 초기 시간 (1시간 단위)\n  const initialTime = 60 * 60;\n  const [timeRemaining, setTimeRemaining] = useState(initialTime);\n\n  useEffect(() => {\n    const timerInterval = setInterval(() => {\n      setTimeRemaining((prevTime) => {\n        if (prevTime === 0) {\n          clearInterval(timerInterval);\n          // 타이머가 0이 되면 수행할 작업\n          console.log('카운트다운 완료!');\n          return 0;\n        } else {\n          return prevTime - 1;\n        }\n      });\n    }, 1000);\n\n    // 컴포넌트가 언마운트될 때 인터벌 정리\n    return () => clearInterval(timerInterval);\n  }, []); // 빈 의존성 배열은 효과가 마운트 시에 한 번만 실행되도록 함\n\n  // 초를 시간, 분, 초로 변환\n  const hours = Math.floor(timeRemaining / 3600);\n  const minutes = Math.floor((timeRemaining % 3600) / 60);\n  const seconds = timeRemaining % 60;\n\n  return (\n    <div>\n      <p>카운트다운 타이머:</p>\n      <p>{`${hours}시간 ${minutes}분 ${seconds}초`}</p>\n    </div>\n  );\n};\n\nexport default CountdownTimer;\n```\n\n# 카운트다운타이머 컴포넌트 사용하기\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\nimport CountdownTimer from './CountdownTimer';\n\nconst App = () => {\n  return (\n    <div>\n      <h1>React Countdown Timer</h1>\n      <CountdownTimer />\n    </div>\n  );\n};\n\nexport default App;\n```\n\n# 결론\n\nReact와 해당 훅을 이용하여, 유연하고 매력적인 카운트다운 타이머를 제작했습니다. 이를 프로젝트에 손쉽게 통합할 수 있습니다. 스타일링을 맞춤화하거나 음향 효과를 추가하거나, 애플리케이션의 요구 사항에 기반한 추가 기능을 통합하는 자유를 누려보세요.\n\n자, 이제 다음 React 프로젝트에서 시간을 효율적으로 활용해 보세요. 즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png","tag":["Tech"],"readingTime":3},{"title":"실전 HTML과 CSS 빠른 실력 향상을 위한 10개 프로젝트","description":"","date":"2024-06-22 15:35","slug":"2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement","content":"\n\nHTML과 CSS를 숙달하는 것은 시각적으로 매력적인 웹사이트를 만드는 데 그치지 않습니다 — 사용자 경험을 공감시키는 것입니다. 처음부터 시작하든지 기술을 더욱 향상시키는 중이든, 저희가 선별한 10일 가이드는 실전 프로젝트로 학습을 가속화하는 데 도움이 될 것입니다.\n\n1일차: 미디어 쿼리를 사용하여 반응형 네비게이션 바를 만들어, 다양한 화면 크기에 매끄럽게 적응되도록 합시다.\n\n- 프로젝트 1: 드롭다운이 있는 반응형 네비게이션 바\n- 프로젝트 2: 호버 효과가 있는 세련된 네비게이션 바\n- 프로젝트 3: 로고와 메뉴 항목이 있는 네비게이션 바\n- 프로젝트 4: 검색 창이 있는 투명한 네비게이션 바\n- 프로젝트 5: 아이콘 링크가 있는 네비게이션 바\n\n2일차: Flexbox를 사용하여 유연한 항목 위치 지정 및 그리드를 사용하여 구조화된 카드 배열을 디자인하고 구현해보세요.\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트는 나중에 추가될 예정입니다. (22/6/24)\n\nDay 3: CSS Grid을 활용하여 반응형이고 시각적으로 매력적인 고급 레이아웃을 생성하는 데 초점을 맞춘 Grid Stock 프로젝트를 살펴보세요.\n\n- 프로젝트는 나중에 추가될 예정입니다. (23/6/24)\n\nDay 4: 부드러운 전환 효과와 컨트롤을 갖춘 가로 및 세로 이미지 슬라이더를 개발하여 이미지를 쇼케이스하세요.\n\n<div class=\"content-ad\"></div>\n\n- 나중에 프로젝트가 추가될 예정입니다. (24/6/24)\n\n5일차: 다음 튜토리얼에서 프로젝트를 구현해 보세요: https://www.youtube.com/watch?v=NU6BqU67Lv8, 해당 개념을 이해하고 적용에 중점을 두세요.\n\n6일차: 적어도 3–5개의 다른 프로젝트로 푸터의 디자인 및 스타일링을 연습해 보며 레이아웃, 내용 정렬 및 시각적 매력에 실험해 보세요.\n\n- 나중에 프로젝트가 추가될 예정입니다. (26/6/24)\n\n<div class=\"content-ad\"></div>\n\n일일 프로젝트를 수행하면서 링크를 업데이트할 예정입니다. 이를 통해 CSS를 단계별로 숙달하는 데 집중하고, 각 날짜 학습 목표와 일치하는 관련 자습서 및 자료에 액세스할 수 있습니다. 제 진행을 따라가고 최신 업데이트를 확인하려면 정기적으로 방문해주세요. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement_0.png"},"coverImage":"/assets/img/2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement_0.png","tag":["Tech"],"readingTime":2},{"title":"HTMX 20 이해하기 웹 개발을 단순화하는 방법","description":"","date":"2024-06-22 15:34","slug":"2024-06-22-UnderstandingHTMX20SimplifyingWebDevelopment","content":"\n\n<img src=\"/assets/img/2024-06-22-UnderstandingHTMX20SimplifyingWebDevelopment_0.png\" />\n\nHTMX 2.0 최근 릴리즈로 인해 복잡한 JavaScript 프레임워크를 쉽게 이해할 수 있는 HTML 속성으로 대체할 수 있는 잠재력에 대한 관심을 끌었습니다. 이 새로운 버전은 웹 개발을 간단하게 만들어 개발자들이 JavaScript에 심취하지 않고도 동적이고 상호작용이 가능한 웹 애플리케이션을 만들 수 있도록 하는 것을 목표로 합니다.\n\n## HTMX란?\n\nHTMX는 개발자들이 AJAX, CSS 전환, 웹소켓 및 서버-보낸 이벤트에 HTML 속성을 통해 직접 액세스 할 수 있도록 하는 라이브러리입니다. 주요 목표는 상호작용을 HTML에서 직접 처리함으로써 JavaScript의 필요성을 줄이고 웹 개발을 더 간단하게 만드는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## HTMX 2.0의 주요 기능\n\n- 향상된 HTML 속성: HTMX는 JavaScript를 작성하지 않고도 HTML 속성을 사용하여 클라이언트 측 상호작용(예: HTTP 요청)을 트리거합니다. 이 접근 방식은 코드를 더 쉽게 읽고 유지보수하기 쉽게 만듭니다.\n- WebSockets 및 SSE 지원: HTMX 2.0은 WebSockets 및 Server-Sent Events (SSE)를 내장 지원하여 실시간 데이터 업데이트 및 클라이언트와 서버 간 통신을 가능하게 합니다.\n- 점진적 향상: HTMX는 점진적 향상의 원칙을 따라 JavaScript가 비활성화되거나 사용자의 브라우저에서 완전히 지원되지 않아도 웹 페이지가 작동하도록 보장합니다.\n- 성능 향상: 클라이언트 측 로직의 많은 부분을 서버로 옮기고 필요한 JavaScript의 양을 줄이면 HTMX는 성능을 향상시키고 더 빠른 로드 시간을 제공할 수 있습니다.\n\n## HTMX 작동 방식\n\nHTMX는 요소의 동작을 정의하기 위해 HTML 속성을 이용합니다. 다음은 일반적인 HTMX 속성 몇 가지입니다:\n\n<div class=\"content-ad\"></div>\n\n- hx-get: 요소를 트리거했을 때 지정된 URL로 GET 요청을 보냄.\n- hx-post: 지정된 URL로 POST 요청을 보냄.\n- hx-trigger: 클릭, 마우스 오버 또는 제출과 같이 요청을 트리거하는 이벤트를 정의함.\n- hx-swap: 응답이 DOM에 삽입되는 방식을 결정함. innerHTML, outerHTML, beforebegin, afterbegin, beforeend, afterend과 같은 옵션이 있음.\n\n예시\n\nHTMX를 활용한 간단한 예시입니다:\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n    <title>HTMX 예시</title>\n    <script src=\"https://unpkg.com/htmx.org\"></script>\n</head>\n<body>\n    <button hx-get=\"/hello\" hx-trigger=\"click\" hx-swap=\"innerHTML\">\n        Click me\n    </button>\n    <div id=\"content\"></div>\n    <script>\n        document.addEventListener('DOMContentLoaded', () => {\n            htmx.on('htmx:beforeRequest', function(evt) {\n                console.log('요청을 보내기 전:', evt.detail);\n            });\n        });\n    </script>\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n이 예에서는 버튼을 클릭하면 /hello로 AJAX GET 요청이 전송됩니다. 서버에서의 응답이 버튼의 내부 HTML을 대체합니다. 이 설정을 통해, AJAX 호출 및 DOM 조작을 처리하기 위한 추가 JavaScript 작성이 필요하지 않습니다.\n\n## HTMX 사용의 장점\n\n- 복잡성 감소: 상호 작용 로직을 HTML로 이동함으로써, HTMX는 JavaScript 중심의 프레임워크와 관련된 복잡성을 줄입니다.\n- 유지보수 용이성: 코드는 HTML에서 요소의 동작이 명확하게 정의되므로 유지보수 및 가독성이 향상됩니다.\n- 성능 향상: 더 많은 작업을 서버로 옮기고 클라이언트 측 JavaScript를 줄이면 성능이 향상되고 로드 시간이 줄어듭니다.\n- 사용자 경험 향상: WebSockets 및 SSE를 통한 실시간 업데이트는 웹 애플리케이션의 응답성과 상호 작용성을 개선합니다.\n\n## Laravel과의 통합\n\n<div class=\"content-ad\"></div>\n\nHTMX를 Laravel 애플리케이션에 신속하게 통합하여 동적 동작을 개선할 수 있습니다. 상당한 복잡성을 추가하지 않고 사용할 수 있어요. 아래는 Laravel 프로젝트에 HTMX를 설정하는 방법에 대한 간략한 개요입니다:\n\n- 설정: Laravel Blade 템플릿에 HTMX 라이브러리를 포함시킵니다.\n- 라우트와 컨트롤러: HTMX가 수행하는 AJAX 요청을 처리하기 위한 라우트 및 컨트롤러를 정의하세요.\n- Blade 템플릿: Blade 템플릿에서 HTMX 속성을 사용하여 AJAX 요청을 트리거하고 페이지 일부를 동적으로 업데이트하세요.\n\n라라벨 예시\n\n다음은 Laravel에서 HTMX를 사용하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\nBlade Template (resources/views/welcome.blade.php)\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Laravel with HTMX</title>\n    <script src=\"https://unpkg.com/htmx.org\"></script>\n</head>\n<body>\n    <button hx-get=\"{ route('getData') }\" hx-trigger=\"click\" hx-target=\"#content\" hx-swap=\"innerHTML\">\n        Get Data\n    </button>\n    <div id=\"content\"></div>\n</body>\n</html>\n```\n\nRoute (routes/web.php)\n\n```js\nRoute::get('/getData', function () {\n    return response()->json(['message' => 'Hello, World!']);\n})->name('getData');\n```\n\n<div class=\"content-ad\"></div>\n\n이 설정은 버튼 클릭이 AJAX 요청을 트리거하여 Laravel 라우트에 전달하고 응답이 추가 JavaScript를 작성하지 않고 div의 내용을 업데이트하는 방법을 보여줍니다.\n\n# 결론\n\nHTMX 2.0은 작업 흐름을 간소화하고 응용 프로그램 성능을 향상시키려는 웹 개발자들에게 흥미로운 개발을 제공합니다. 클라이언트 측 상호 작용을 처리하기 위해 HTML 속성을 활용함으로써, HTMX는 복잡한 JavaScript 프레임워크에 대한 필요성을 줄이고 유지 보수성을 향상시킵니다.\n\n더 많은 독해 및 고급 사용법을 위해서 HTMX 문서를 참조하고 최신 릴리스 및 기능을 확인해 주세요.","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingHTMX20SimplifyingWebDevelopment_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingHTMX20SimplifyingWebDevelopment_0.png","tag":["Tech"],"readingTime":4},{"title":"Position Sticky 문제 해결하기 Overflow Clip으로 Overflow Hidden 문제 해결하는 방법","description":"","date":"2024-06-22 15:33","slug":"2024-06-22-OvercomingPositionStickyIssuesSolvingOverflowHiddenProblemswithOverflowClip","content":"\n\n\n<img src=\"/assets/img/2024-06-22-OvercomingPositionStickyIssuesSolvingOverflowHiddenProblemswithOverflowClip_0.png\" />\n\nPosition sticky는 특정 스크롤 위치에 도달했을 때 요소가 뷰포트에 \"붙어 있는\" CSS 위치 지정 속성입니다. 그러나 CSS overflow 속성과 호환되지 않아 종종 \"overflow: hidden\"을 사용하는 상황에서 문제가 발생합니다. 이로 인해 요소가 \"붙어 있지 않고\" 대신 \"고정된 것처럼\" 행동할 수 있습니다. 그러나 이 문제를 해결하는 방법이 있습니다. 대신 \"overflow: clip\"을 사용하는 것입니다.\n\n이 문제에 대한 자세한 내용과 \"overflow: clip\"이 어떻게 문제를 해결하는 데 도움이 되는지 살펴보겠습니다.\n\nPosition sticky: 간단한 개요\n\n\n<div class=\"content-ad\"></div>\n\n우선, position: sticky가 무엇을 하는지 간략히 살펴봅시다. 요소에 position: sticky를 적용하면 일정 지점을 스크롤하면 \"sticky\"가 됩니다. 이로써 요소가 화면 내에 계속 보이게 할 수 있고, 지나치게 스크롤했을 때에도 그대로 보이게 됩니다. 사용자가 웹 사이트를 스크롤하는 동안 계속 보이게 하고 싶은 내비게이션 바, 헤더 및 기타 요소를 만들 때 유용한 속성입니다.\n\noverflow: hidden 문제점\n\nposition: sticky를 사용할 때, CSS overflow 속성을 \"hidden\" 값과 함께 사용하면 제대로 작동하지 않을 수 있습니다. 이는 “overflow: hidden”이 요소에 새로운 블록 형식화 컨텍스트를 만들기 때문입니다. 이것은 요소의 크기와 위치를 제한하는 컨테이너로 작용하므로 자식 요소의 크기와 위치에 영향을 줍니다.\n\nposition: sticky가 적용된 요소가 \"overflow: hidden\" 속성이 적용된 요소 내에 있을 때, 요소는 뷰포트에 대한 위치를 더 이상 알 수 없어 \"붙지\" 못하는 현상이 발생합니다. 대신, 스크롤하면 화면에서 고정된 위치에 남아 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: overflow: clip\n\n좋은 소식은 이 문제에 대한 간단한 해결책이 있다는 것입니다. “overflow: hidden” 대신에 “overflow: clip”을 사용할 수 있습니다. 이 속성 값은 요소의 콘텐츠를 클립하여 보여주는 방식에서 “overflow: hidden”과 유사하지만 새로운 블록 서식 맥락을 만들지 않습니다. 즉, “overflow: clip”이 적용된 요소 안의 요소들은 “overflow: hidden”과 같은 방식으로 영향을 받지 않습니다.\n\n“overflow: hidden” 대신에 “overflow: clip”을 사용함으로써 position: sticky가 있는 요소가 기대한 대로 작동하도록 할 수 있습니다. 스크롤하면 해당 요소들이 뷰포트에 고정되는 것을 확인할 수 있습니다.\n\n결론\n\n<div class=\"content-ad\"></div>\n\n요약하자면, `position: sticky`는 사용자가 웹사이트를 스크롤할 때 요소가 뷰포트에 \"붙는\" 유용한 CSS 속성입니다. 그러나 \"overflow: hidden\"과 함께 사용할 때 예상치 못한 동작을 일으켜 요소가 제대로 고정되지 못하는 상황이 발생할 수 있습니다. 이 문제를 해결하려면 대신에 \"overflow: clip\"을 사용할 수 있습니다. 새로운 블록 포맷팅 컨텍스트를 생성하지 않고 요소의 콘텐츠를 클립하는 기능을 제공합니다. 이렇게 하면 `position: sticky`가 있는 요소가 예상대로 작동하고 사용자가 그 요소를 스크롤하면 계속 가시적으로 유지됩니다.","ogImage":{"url":"/assets/img/2024-06-22-OvercomingPositionStickyIssuesSolvingOverflowHiddenProblemswithOverflowClip_0.png"},"coverImage":"/assets/img/2024-06-22-OvercomingPositionStickyIssuesSolvingOverflowHiddenProblemswithOverflowClip_0.png","tag":["Tech"],"readingTime":2},{"title":"여러분의 웹사이트를 위해 꼭 필요한 5가지 웹 접근성 기능과 사용자들이 당연히 누려야 할 것들","description":"","date":"2024-06-22 15:32","slug":"2024-06-22-5AccessibilityFeaturesYourWebsiteNeedsandThatYourUsersDeserve","content":"\n\n상위 백만 대 웹사이트 중 95% 이상*의 홈페이지가 기본 접근성 기준을 준수하지 못한다는 사실을 알고 계셨나요? 세계 인구의 16%*가 장애를 가지고 살고 있다고 하니(세계보건기구 기준), 접근성 있는 사용자 경험은 결코 간과되어서는 안 됩니다. 웹사이트의 모든 상호작용은 방문 예정인 모든 사람을 위해 작동해야 합니다.\n\n![image](/assets/img/2024-06-22-5AccessibilityFeaturesYourWebsiteNeedsandThatYourUsersDeserve_0.png)\n\n## 조금의 이해\n\n웹 디자인과 개발 여정 중 사용자 상호작용(UI)과 사용자 경험(UX)은 계획 프로세스의 큰 부분을 차지합니다. UX 요구 사항 수집 과정이나 웹 디자이너를 위한 지침에 접근성 있는 사용자 이야기를 포함하는 것이 매우 중요합니다. 웹 디자인 도구도 좋지만, 이 주제에서는 제한적일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래 고려해야 할 사항 중 일부를 이미 알고 계실 수도 있습니다. Content Management Systems, Documents, 그리고 요즘 대부분의 소셜 미디어에서 보다 일반적으로 사용되는 '대체 텍스트(Alt Tags)'에 대해 말이죠. 사용자가 온라인에서 정보, 제품 또는 서비스를 찾을 때 여기저기서 찾을 수 있습니다.\n\n# 주요 접근성 기능\n\n아마도 이러한 측면 중 일부는 여러분의 웹사이트를 조사해 볼 새로운 통찰력을 제공할 것으로 기대합니다:\n\n## Alt 태그 (또는 대체 텍스트 또는 대체 설명)\n\n<div class=\"content-ad\"></div>\n\n웹 사이트에서 가장 일반적인 접근성 기능입니다. HTML 이미지 마크업 내에 포함되어 있으며, 스크린 리더가 필요한 사용자들이 이미지와 그래픽에 대한 설명을 경험할 수 있도록 합니다.\n\n## 색 대비\n\n색맹부터 저시력자까지, 웹 사이트에 대한 추가적인 스타일링 기능이 중요합니다. 이를 통해 색 대비를 자유롭게 변경할 수 있습니다. 다른 예로, 디스렉시아는 웹 요소의 주의를 산만하게 만드는 것을 줄이거나 제거하고, 밝은(흰색이 아닌) 배경에 더 어두운 글꼴 색상을 사용할 수 있는 옵션을 제공합니다. 이러한 색상 기술을 사용하면 자폐 스펙트럼 질환자에도 도움이 될 수 있습니다.\n\n## 명확한 피드백\n\n<div class=\"content-ad\"></div>\n\n사용자들은 당신의 웹사이트가 잘 반응할 때 잘 반응합니다. 대부분의 상호작용에 쉬운 지침을 제공하는 것이 중요합니다. 또한 직관적인 양식 유효성 검사를 하는 것은 사용자들이 자신의 데이터를 제공할 때 확신을 갖게 합니다. 발생한 오류도 경험의 일부로 사용자가 다음에 무엇을 해야 하는지 안내해야 합니다.\n\n## CSS 웹킷 (레거시 웹 브라우저 지원)\n\n당신의 웹사이트는 멋져 보일 수 있습니다. 팬시한 그라데이션과 클라우드에서 가져온 폰트... 그것은 멋집니다! 그렇지만 사용자들이 오래된 웹 브라우저에 접근하는 것에 제한이 있는 경우 가장 중요합니다. 당신의 CSS가 웹사이트의 스타일링 속성에서 대체할 수 있는 능력을 갖추는 것이 필수입니다.\n\n## 키보드 탐색\n\n<div class=\"content-ad\"></div>\n\n웹사이트를 키보드만 사용해서 쉽게 이동할 수 있는 능력을 갖추세요. 이 기능은 모든 내비게이션과 상호작용 요소에 통합되어야 합니다. 또 다른 고려 사항은 웹 디자인이 접근성 있는 디자인을 방해하는 요소로 의도적으로 요소의 외관을 비활성화하지 않았는지 확인하는 것입니다.\n\n# 웹사이트를 더 나은 상태로 만들기 위해 무엇을 할 수 있을까요?\n\n만약 웹사이트에서 접근성이슈에 대해 확신이 없는 경우, W3C에서 제공하는 무료 마크업 체커를 사용하는 것이 좋은 시작점입니다.\n\n웹 접근성에 관련된 경험이나 질문이 있다면 댓글을 남겨주세요. 다른 사람들로부터 더 많이 배우고 제 지식을 공유하는 것을 즐기고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n* [https://www.acquia.com/blog/accessibility-statistics](https://www.acquia.com/blog/accessibility-statistics)\n* [https://validator.w3.org/](https://validator.w3.org/)","ogImage":{"url":"/assets/img/2024-06-22-5AccessibilityFeaturesYourWebsiteNeedsandThatYourUsersDeserve_0.png"},"coverImage":"/assets/img/2024-06-22-5AccessibilityFeaturesYourWebsiteNeedsandThatYourUsersDeserve_0.png","tag":["Tech"],"readingTime":3},{"title":"Javascript scrollIntoView 메소드 사용 방법","description":"","date":"2024-06-22 15:32","slug":"2024-06-22-JavascriptscrollIntoViewmethod","content":"\n\n\n![scrollIntoView method](/assets/img/2024-06-22-JavascriptscrollIntoViewmethod_0.png)\n\nscrollIntoView는 요소를 뷰포트 안으로 부드럽게 스크롤할 수 있는 자바스크립트 메소드입니다. 이 메소드는 이미 보이는 뷰포트에 요소가 없다면 요소를 보이게 만듭니다. 사용자가 어떤 작업을 수행하거나 애니메이션 효과로 요소를 보여줄 때 유용합니다.\n\nscrollIntoView 메소드는 문서 객체 모델(DOM)의 Element 인터페이스의 일부입니다.\n\nelement.scrollIntoView();\nelement.scrollIntoView([scrollIntoViewOptions]);\n\n<div class=\"content-ad\"></div>\n\nscrollIntoView의 문법에는 2 가지 유형이 있습니다.\n\n이 메소드는 기본 옵션으로 요소를 보이도록 스크롤하는 데 사용됩니다.\n\n이는 요소가 이미 보이지 않은 경우 요소가 포함되어 있는 요소의 맨 위나 뷰포트로 스크롤됩니다.\n\nscrollIntoViewOptions는 뷰포트에서 요소를 스크롤하는 여러 옵션을 지정하는 선택적 객체 속성입니다.\n\n<div class=\"content-ad\"></div>\n\n다음과 같은 속성이 있습니다.\n\n이 속성은 아래 유형을 통해 스크롤의 동작을 정의하는 데 사용됩니다.\n\n가능한 값은\n\n- auto(기본값): 스크롤 동작에 따라 요소를 스크롤합니다.\n- smooth: 부드럽고 애니메이션 효과로 요소를 스크롤합니다.\n- instant: 즉시 요소를 스크롤하여 단일 점프와 동일합니다.\n\n<div class=\"content-ad\"></div>\n\n이 속성은 가시 영역 내 요소의 수직 정렬을 정의하는 데 사용됩니다.\n\n가능한 값은\n\n- start(기본): 요소를 시작 위치에 스크롤합니다.\n- center: 요소를 중앙에 스크롤합니다.\n- end: 요소를 끝에 스크롤합니다.\n- nearest: 수직으로 가장 가까운 가장자리로 스크롤합니다.\n\n이 속성은 가시 영역 내 요소의 수평 정렬을 정의하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 가능한 값들입니다\n\n- start(기본): 요소를 시작 위치에 스크롤합니다.\n- center: 요소를 중앙에 스크롤합니다.\n- end: 요소를 끝에 스크롤합니다.\n- nearest: 수평으로 가장 가까운 가장자리로 스크롤합니다.\n\n## 예시\n\n여기에 scrollIntoView의 다양한 속성 조합에 따라 생성된 3가지 예시가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 1. scrollIntoView() 기본\n\n이것은 요소를 보이는 뷰포인트로 스크롤합니다.\n\n<!DOCTYPE html>\n<html>\n    <style>\n        #container {\n            height: 250px;\n            overflow: auto;\n        }\n        #scroll-div {\n            margin: 500px;\n            height: 800px;\n            background-color: pink;\n        }\n    </style>\n\n    <body>\n        <h1>Javascript scrollIntoView</h1>\n\n        <button onclick=\"myFunction()\">요소로 스크롤하려면 클릭</button>\n\n        <div id=\"container\">\n            <div id=\"scroll-div\">\n                <p>텍스트1</p>\n                <p>텍스트2</p>\n                <p>텍스트3</p>\n            </div>\n        </div>\n\n        <script>\n            function myFunction() {\n                const element = document.getElementById('scroll-div');\n                element.scrollIntoView();\n            }\n        </script>\n    </body>\n</html>\n\n# 2. scrollIntoView() 수직으로\n\n<div class=\"content-ad\"></div>\n\n아래 코드는 요소를 수직으로 화면 안에 스크롤합니다.\n\n<!DOCTYPE html>\n<html>\n    <style>\n        #scroll-div {\n            margin-top: 100px;\n            padding-right: 100%;\n            height: 800px;\n            background-color: pink;\n            overflow: auto;\n        }\n    </style>\n\n    <body>\n        <h1>Javascript scrollIntoView</h1>\n\n        <button onclick=\"myFunction()\">요소를 스크롤하려면 클릭하세요</button>\n\n        <div id=\"scroll-div\">텍스트</div>\n\n        <script>\n            function myFunction() {\n                const element = document.getElementById('scroll-div');\n                element.scrollIntoView({\n                    behavior: 'smooth',\n                    block: 'end',\n                    inline: 'nearest',\n                });\n            }\n        </script>\n    </body>\n</html>\n\n# 3 .scrollIntoView() 수평 방향\n\n이것은 요소를 수평으로 화면 안에 스크롤합니다.\n\n<div class=\"content-ad\"></div>\n\n<!DOCTYPE html>\n<html>\n    <style>\n        #scroll-div {\n            margin-left: 100%;\n            padding-right: 100%;\n            height: 800px;\n            background-color: pink;\n            overflow: auto;\n        }\n    </style>\n\n    <body>\n        <h1>Javascript scrollIntoView</h1>\n\n        <button onclick=\"myFunction()\">Click to scroll the element</button>\n\n        <div id=\"scroll-div\">Text</div>\n\n        <script>\n            function myFunction() {\n                const element = document.getElementById('scroll-div');\n                element.scrollIntoView({\n                    behavior: 'smooth',\n                    block: 'nearest',\n                    inline: 'start',\n                });\n            }\n        </script>\n    </body>\n</html>\r\n\n참고: scrollIntoView 메서드는 요소의 CSS에 많이 의존합니다. 요소에 대한 스크롤 간격에 대한 유효한 CSS를 제공했을 경우에만 예상대로 작동합니다.\n\n이 글을 읽어주셔서 감사합니다. 이 글이 요소 스크롤에 도움이 되기를 바랍니다.","ogImage":{"url":"/assets/img/2024-06-22-JavascriptscrollIntoViewmethod_0.png"},"coverImage":"/assets/img/2024-06-22-JavascriptscrollIntoViewmethod_0.png","tag":["Tech"],"readingTime":4}],"page":"12","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}