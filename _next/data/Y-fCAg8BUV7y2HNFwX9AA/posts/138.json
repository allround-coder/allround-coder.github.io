{"pageProps":{"posts":[{"title":"리얼타임 스트리밍 Askbot을 React, Express, ChatGPT로 개발하기","description":"","date":"2024-05-12 20:32","slug":"2024-05-12-Real-timestreamingAskbotwithReactExpressChatGPT","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:1244/1*pgF3zoeDTN7tEbUP67AzaA.gif)\n\n이 블로그는 React를 사용하여 ChatGPT 앱을 안전하게 설정하는 데 초점을 맞춥니다.\n\nOpenAI는 클라이언트 라이브러리를 제공하여 React 앱에서 ChatGPT를 직접 사용할 수 있지만, 라이브러리 자체가 경고하는 대로:\n\n그러므로 이상적인 방법은 서버가 ChatGPT와 통신하여 원하는 응답을 받은 다음 해당 응답을 다시 React 앱으로 전달하는 것입니다.\n\n\n\n하지만 위 스크린샷에 나와 있는 것처럼 ChatGPT와 같은 스트리밍 응답을 어떻게 구현할 수 있을까요?\n\n이를 달성하기 위한 세 가지 단계는 다음과 같습니다:\n\n- NodeJS-Express 서버 설정\n- OpenAI 및 스트리밍 응답 설정\n- React 앱에서 작동시키기\n\n# NodeJS-Express 서버 설정\n\n\n\n첫 번째로, React 앱과 OpenAI ChatGPT API 사이에서 중계 역할을 하는 Express 서버를 만들어야 합니다. 이 서버는 OpenAI로의 API 호출을 처리하고 응답을 React 앱으로 스트리밍합니다.\n\n먼저 Node.js와 npm이 설치되어 있는지 확인하세요. 그런 다음 프로젝트 디렉토리에서 다음 명령을 실행하세요:\n\n```js\nnpm install express cors body-parser\n```\n\n아래 코드를 사용하여 app.js에 빠른 Express 서버 설정을해보세요:\n\n\n\n```js\nimport express from \"express\";\nimport bodyParser from \"body-parser\";\nimport cors from \"cors\";\n\nconst app = express();\nconst port = 2000;\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cors());\n\napp.get(\"/\", (req, res) => {\n  return res.json({ data: \"success\" });\n});\n\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n```\n\n다음 명령어를 사용하여 서버를 실행하세요:\n\n```js\nnode app.js\n```\n\n팁: 언제든지 변경 사항을 만들 때마다 Express 서버를 다시로드하려면 nodemon을 사용할 수 있습니다.\n\n\n\n# OpenAI 및 스트리밍 응답 설정\n\n## OpenAI 설정하기\n\n오픈에이아이 라이브러리를 설치하고 시작하세요!\n\n```js\nimport OpenAI from \"openai\";\n\nconst client = new OpenAI({\n  apiKey: 'YOUR_OPENAI_API_KEY',\n});\n\nconst systemMessage = {\n  role: \"system\",\n  content:\n    \"You are a Askbot. You are supposed to answer the questions asked by the users. Validate the prompts to be a question and it should not in approprite. Give funky responses\",\n};\n\nexport const getStreamingCompletion = async ({ userPrompt }) => {\n  return client.chat.completions.create({\n    model: \"gpt-3.5-turbo\",\n    messages: [systemMessage, { role: \"user\", content: userPrompt }],\n    stream: true,\n  });\n};\n```\n\n\n\nOpenAI 웹사이트에서 실제 OpenAI API 키를 얻을 수 있습니다.\n\n작성 시점에서 현재 안정 버전인 openai 라이브러리(3.3.0)에서는 스트리밍이 제대로 작동하지 않습니다. 여기에 설명된 대로.\n\n라이브러리의 곧 출시될 v4 버전에서는 이를 지원할 것입니다. 베타 버전을 통해 이미 사용 가능합니다. 그럼 설치해봅시다:\nnpm install openai@4.0.0-beta.6 . 코드는 그대로 유지됩니다.\n\n## ChatGPT에서 스트리밍 패치 설정\n\n\n\n스트리밍 응답의 큰 장점은 응답이 도착하는 대로 표시될 수 있어 사용자가 완전한 응답을 기다릴 필요가 없다는 것입니다. 이것은 프롬프트에 따라 시간이 오래 소요될 수 있기 때문에 중요합니다.\n\n스트리밍 응답을 소비하려면 아래 코드를 확인해보세요:\n\n```js\nlet starttime = Date.now();\nconst stream = await getStreamingCompletion({ userPrompt: userPrompt });\n for await (const part of stream) {\n    const chunkTime = (Date.now() - starttime) / 1000;\n    process.stdout.write(JSON.stringify(part.choices[0]?.delta || \"\"));\n    console.log(\" chunk time:\", chunkTime);\n}\n```\n\n해보세요. 델타와 해당 델타가 표시되기까지 걸린 시간을 볼 수 있어야 합니다. 델타는 결과에서 다음 토큰입니다. 사용자가 \"안녕\"이라는 프롬프트를 제시하면 다음과 유사한 응답을 받게 될 것입니다:\n\n\n\n\n![이미지](/assets/img/2024-05-12-Real-timestreamingAskbotwithReactExpressChatGPT_0.png)\n\n## Express API로부터의 스트리밍 응답\n\nExpress에는 응답을 스트림으로 반환하는 API가 이미 준비되어 있습니다.\n\n아래는 Express 서버의 전체 코드입니다:\n\n\n\n```js\nimport express from \"express\";\nimport bodyParser from \"body-parser\";\nimport cors from \"cors\";\nimport { getStreamingCompletion } from \"./src/modules/openai/index.js\";\n\nconst app = express();\nconst port = 2000;\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cors());\n\napp.get(\"/\", (req, res) => {\n  return res.json({ data: \"success\" });\n});\n\napp.post(\"/aiCompletion\", async (req, res) => {\n  const data = req.body;\n  let starttime = Date.now();\n  const stream = await getStreamingCompletion({ userPrompt: data?.userPrompt });\n  for await (const part of stream) {\n    // here express will stream the response\n    res.write(part.choices[0]?.delta.content || \"\");\n  }\n  // here express sends the closing/done/end signal for the stream consumer\n  res.end();\n});\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n```\n# 리액트 앱에서 작동시키는 방법\n\n프론트 엔드를 설정해 봅시다. 나는 React SPA를 사용하고 있어요. 왜 SPA를 사용하냐고요? Next나 Remix가 제공하는 풀 스택 기능이 필요하지 않기 때문에 ExpressJS 기반의 백엔드를 이미 사용하고 있어요.\n\nVite를 사용해서 빠르게 설정해 보세요 (당연한 이유로 CRA는 사용하지 않는 것이 좋아요).\n\n\n\n스트리밍 데이터를 읽기 위해 응답으로부터 리더를 사용해야 하며, 그 데이터를 바이트 스트림에서 문자열로 변환하기 위해 디코딩해야 합니다. 아래는 그에 대한 샘플 코드입니다:\n\n```js\n  // 사용자 프롬프트에 기반한 서버 응답 가져오기\n  const response = await fetch(\"http://localhost:2000/aiCompletion\", {\n    method: \"post\",\n    headers: {\n      Accept: \"application/json, text/plain, */*\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({ userPrompt: prompt }),\n  });\n  if (!response.ok || !response.body) {\n    throw response.statusText;\n  }\n\n  // 여기서 스트리밍 응답 준비를 시작합니다\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  const loopRunner = true;\n\n  while (loopRunner) {\n    // 여기서 스트림을 읽기 시작합니다. 완료될 때까지.\n    const { value, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    const decodedChunk = decoder.decode(value, { stream: true });\n    setAnswer(answer => answer + decodedChunk); // 새 청크로 상태 업데이트\n  }\n```\n\nReact에서 useState를 사용하여 decodedChunk를 추가해 실시간 스트리밍 응답을 형성할 수 있습니다.\n\n이 예제는 ReactJS, Express, 그리고 OpenAI ChatGPT API를 사용하여 스트리밍 채팅 응답을 구현하는 기본적인 예제를 보여줍니다. 사용 사례 및 요구 사항에 따라 오류 처리를 개선하거나 스타일을 추가하고 대화 흐름을 세밀하게 조정해야 할 수 있습니다.\n\n\n\n당신은 이 레포지토리를 사용하여 직접 askbot을 실행하고 실험해볼 수 있어요.","ogImage":{"url":"/assets/img/2024-05-12-Real-timestreamingAskbotwithReactExpressChatGPT_0.png"},"coverImage":"/assets/img/2024-05-12-Real-timestreamingAskbotwithReactExpressChatGPT_0.png","tag":["Tech"],"readingTime":6},{"title":"React에서 Props 시작하기 초보자를 위한 가이드","description":"","date":"2024-05-12 20:31","slug":"2024-05-12-GettingStartedwithPropsinReactABeginnersGuide","content":"\n\nReact에 오신 것을 환영합니다. 초보자라면 'props'에 대해 들어봤을 것입니다. 함께 props가 무엇이며 어떻게 사용하는지 알아보겠습니다.\n\nProps란\n\nProps는 React에서 특별한 키워드로, 속성을 나타냅니다. 주로 데이터를 한 컴포넌트에서 다른 컴포넌트로 전달하는 데 사용됩니다. 컴포넌트는 사용자 인터페이스의 구성 요소입니다. props는 컴포넌트 간에 통신하기 위해 사용하는 메시지로 생각할 수 있습니다.\n\n컴포넌트에 Props 전달하기\n\n\n\nProps를 전달하려면 HTML 요소와 마찬가지로 컴포넌트에 속성을 추가해야 합니다. 아래에 예를 통해 한 가지 컴포넌트를 만들고 그에게 props를 전달하는 예제가 있습니다.\n\n```html\n<Button label=\"Click me!\" />\n```\n\n이 예제에서 우리의 컴포넌트는 `Button`이며, 'label'이라는 prop을 전달하여 레이블을 지정했습니다.\n\nProps에 접근하기\n\n\n\n컴포넌트에 속성을 전달한 후에는 해당 속성에 어떻게 접근하는지 살펴봅시다. 컴포넌트에 속성을 전달한 후에는 해당 컴포넌트 내에서 ‘props’ 객체를 사용하여 속성에 접근할 수 있습니다. 이전 예제에서 전달했던 ‘label’ 속성에 접근해 봅시다. ‘props.label’을 사용할 것입니다.\n\n```javascript\nfunction Button(props) {\n  return `<button>${props.label}</button>`;\n}\n```\n\n이렇게 함으로써 우리의 속성에 접근할 수 있었습니다.\n\n속성 사용하기: 동적 콘텐츠 렌더링\n\n\n\nProps를 사용하면 컴포넌트를 동적으로 만들 수 있어요. 컴포넌트의 동작과 모습은 전달된 데이터를 기반으로 한 Props를 통해 사용자 정의할 수 있어요. 아래 예시를 통해 `Button` 컴포넌트로 서로 다른 레이블을 전달하여 다른 버튼을 만들 수 있어요:\n\n```html\n<Button label=\"Save\" />\n<Button label=\"Edit\" />\n<Button label=\"Delete\" />\n```\n\n기본 Props\n\n부모 컴포넌트로부터 전달되지 않은 경우를 위해 Props에 기본 값이 제공되어야 하는 경우를 생각해보세요. React에는 'defaultProps'라는 속성이 있어 Props의 기본 값을 지정할 수 있어요.\n\n\n\n아래의 예시를 참고해주세요:\n\n```javascript\nfunction Button(props) {\n  return `<button>${props.label}</button>`;\n}\n\nButton.defaultProps = {\n  label: \"제출\",\n};\n```\n\n결론\n\n\n지금까지 우리는 props를 이해하는 데 성공했습니다. 프롭스는 React에서 기본적인 개념으로, 동적이고 재사용 가능한 컴포넌트를 만들 수 있는 기회를 제공합니다. 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달함으로써 사용자 입력에 반응하고 데이터를 동적으로 표시하는 강력한 UI를 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-GettingStartedwithPropsinReactABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-05-12-GettingStartedwithPropsinReactABeginnersGuide_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 개발을 더욱 강력하게 필수 유틸리티 함수들","description":"","date":"2024-05-12 20:30","slug":"2024-05-12-EmpoweringReactDevelopmentEssentialUtilityFunctions","content":"\n\n<img src=\"/assets/img/2024-05-12-EmpoweringReactDevelopmentEssentialUtilityFunctions_0.png\" />\n\n리액트는 리액트 컴포넌트의 자식 속성(children prop)과 작업하기 위한 여러 유틸리티 메소드를 제공합니다. 여기에는 가장 일반적으로 사용되는 몇 가지 React.Children 메소드에 대한 개요가 있습니다.\n\nReact.Children.map\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  return (\n    <div>\n      {React.Children.map(children, (child, index) => (\n        // 자식 컴포넌트 조작 또는 복제\n        React.cloneElement(child, { key: index })\n      ))}\n    </div>\n  );\n}\n```\n\n\n\nReact.Children.toArray\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  const childrenArray = React.Children.toArray(children);\n  // childrenArray에 대해 조작하거나 반복\n  return (\n    <div>\n      {childrenArray}\n    </div>\n  );\n}\n```\n\nReact.Children.only\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  const onlyChild = React.Children.only(children);\n  // onlyChild 사용\n  return (\n    <div>\n      {onlyChild}\n    </div>\n  );\n}\n```\n\n\n\nReact.Children.forEach\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  React.Children.forEach(children, (child, index) => {\n    // 각각의 자식 요소에 작업 수행\n    console.log(`자식 ${index + 1}:`, child);\n  });\n  return (\n    <div>\n      {children}\n    </div>\n  );\n}\n```\n\nReact.Children.count\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  const numChildren = React.Children.count(children);\n  // numChildren 사용\n  return (\n    <div>\n      {children}\n      <p>자식 요소 수: {numChildren}</p>\n    </div>\n  );\n}\n```\n\n\n\n이 React.Children 메서드는 React 컴포넌트의 children prop과 관련한 유용한 유틸리티를 제공합니다. 이를 사용하여 자식 컴포넌트를 보다 효과적으로 조작, 반복 또는 유효성 검사할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-EmpoweringReactDevelopmentEssentialUtilityFunctions_0.png"},"coverImage":"/assets/img/2024-05-12-EmpoweringReactDevelopmentEssentialUtilityFunctions_0.png","tag":["Tech"],"readingTime":2},{"title":"프로덕션 환경에서 Vite와 Nginx를 활용해 도커 안에서 Front-end React 앱을 패키징하기","description":"","date":"2024-05-12 20:30","slug":"2024-05-12-PackagingFrontEndReactApplicationsunderaProductionEnvironmentwithViteandNginxinDocker","content":"\n\n## 현대 웹 개발의 효율적인 길을 탐험하다: 빠른 빌드를 위한 Vite, 고성능 서빙을 위한 Nginx, 그리고 견고한 React 애플리케이션을 위한 유연한 배포를 위해 도커를 활용하다.\n\n# 소개\n\n현대 웹 개발은 종종 React와 같은 프론트엔드 프레임워크와 Vite와 같은 강력한 빌드 도구를 활용하여 개발 프로세스를 효율화합니다. Docker도 애플리케이션을 패키징하고 배포하는 데 표준으로 자리 잡았습니다. 이 글에서는 Vite와 Nginx를 함께 사용하여 Frontend React 애플리케이션을 위한 Docker 이미지를 생성하는 방법을 살펴볼 것입니다. Vite와 Nginx의 기능과 장점에 대해 탐구하고, Nginx가 React 애플리케이션을 프로덕션 환경에서 배포하는 데 어떻게 적합한지 이해할 것입니다.\n\n![이미지](/assets/img/2024-05-12-PackagingFrontEndReactApplicationsunderaProductionEnvironmentwithViteandNginxinDocker_0.png)\n\n\n\n# Vite 및 Nginx 개요\n\n## Vite: 빠른 빌드 도구\n\nVite는 프론트엔드 애플리케이션 개발 프로세스를 대폭 가속화하는 빌드 도구입니다. Vite는 네이티브 ES 모듈, 핫 모듈 교체 (HMR), 그리고 빠른 개발 서버를 활용하여 효율적인 개발 경험을 제공합니다. Vite의 독특한 종속성 해결 방식은 빠른 빌드를 가능케 하며, React 애플리케이션을 생성하는 데 우수한 선택지입니다.\n\nReact 애플리케이션 생성에 Vite를 활용하는 방법에 익숙하지 않다면, 제공된 링크에서 유용한 안내서를 참조하세요.\n\n\n\n## Nginx: 고성능 웹 서버\n\nNginx는 대규모 연결을 처리하고 정적 파일을 효율적으로 제공하는 데 뛰어난 웹 서버입니다. 안정성, 낮은 자원 사용량 및 고부하 처리 능력으로 유명하여 프로덕션 배포에 이상적입니다. 저희 설정에서 Nginx는 React 애플리케이션을 제공하고 백엔드 서버와 통신하기 위해 역방향 프록시로 작동할 것입니다.\n\n# 코드 안내\n\n## Nginx 구성\n\n\n\n다음 Nginx 구성은 8080번 포트에서 수신하고 React 애플리케이션의 요청을 처리하는 서버를 설정합니다:\n\n```js\nserver {\n    listen 8080;\n    server_name localhost;\n    location / {\n        root /usr/share/nginx/html;\n        index index.html;\n        try_files $uri $uri/ /index.html;\n    }\n    location /api/ {\n        proxy_pass YOUR_BACKEND_URL;\n    }\n}\n```\n\n이 구성은 Nginx에게 /usr/share/nginx/html에서 정적 파일을 제공하도록 지정하며, 여기에는 React 빌드가 위치합니다. 해결되지 않은 URL에 대해서는 index.html 페이지를 반환하여 React가 클라이언트 측 라우팅을 처리할 수 있도록 합니다. location /api/ 블록은 백엔드 서버로 요청을 전달하는 프록시를 설정하여, 프론트엔드와 백엔드 간의 원활한 통신을 가능하게 합니다.\n\n## Vite 구성\n\n\n\nVite 설정 파일에서는 Vite가 React 애플리케이션을 빌드하는 방법을 정의합니다:\n\n```js\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport path from 'path';\nimport dotenv from 'dotenv';\n\nexport default defineConfig(({ mode }) => {\n    const envFile = mode === 'development' ? '.env.development' : '.env.production';\n    dotenv.config({ path: envFile });\n    return {\n        plugins: [react()],\n        build: {\n            outDir: 'build',\n            assetsDir: 'assets',\n            emptyOutDir: true,\n        },\n        resolve: {\n            alias: {\n                '@': path.resolve(__dirname, './src'),\n            },\n        },\n        server: {\n            proxy: {\n                '/api': {\n                    target: process.env.VITE_API_BASE_URL,\n                    changeOrigin: true,\n                },\n            },\n        },\n    };\n});\n```\n\nVite 구성은 React에 필요한 플러그인을 설정하고, 빌드 출력 디렉토리를 build로 정의합니다. 또한 src 디렉토리에서 모듈을 쉽게 가져오기 위한 별칭을 설정합니다. 또한 개발 환경을 위해 백엔드 API로 요청을 전달하기 위한 프록시를 구성합니다. 이를 통해 개발 중에 교차 출처 문제에 대해 걱정하지 않고 프론트 엔드를 개발할 수 있습니다.\n\nVite의 프록시 사용에 익숙하지 않다면, 이전 글을 확인해 보세요:\n\n\n\n마지막으로, 환경 변수가 올바르게 작동하도록 dotenv 라이브러리를 설치해야 합니다.\n\n## Dockerfile 구성\n\nDockerfile은 애플리케이션을 빌드하고 프로덕션 환경을 설정하는 역할을 담당합니다:\n\n```js\n# 단계 1: 애플리케이션 빌드\nFROM node:16 AS builder\nWORKDIR /app\nCOPY package.json package-lock.json ./\nRUN npm ci\n\nCOPY . .\nRUN npm run build\n\n# 단계 2: 프로덕션 환경 설정\nFROM nginx:stable-alpine\nCOPY --from=builder /app/build /usr/share/nginx/html\nCOPY nginx/nginx.conf /etc/nginx/conf.d/default.conf\n\nEXPOSE 8080\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n\n\n도커 파일은 다중 단계 빌드를 사용합니다. 첫 번째 단계에서는 React 애플리케이션을 Vite로 빌드하기 위해 Node.js 환경을 설정합니다. 최종 프로덕션 이미지에는 가벼운 Nginx Alpine 이미지가 사용되며, 빌드된 React 애플리케이션을 적절한 디렉토리로 복사하고 Nginx를 사용자 정의 Nginx 구성 파일로 구성합니다. 외부 액세스를 위해 포트 8080을 노출하고 Nginx 서버를 전경에서 시작합니다.\n\n# 결론\n\nVite가 제공하는 뛰어난 빠른 개발 환경과 안정적이고 고성능인 Nginx 웹 서버를 조합하여, Docker를 사용하여 Frontend React 애플리케이션을 효율적으로 패키지화하고 배포할 수 있는 원활한 경로를 만듭니다. Vite의 빠른 빌드 시간과 핫 모듈 교체는 개발 프로세스를 활기차게 만들어 주며, Nginx의 안정성과 효율성은 프로덕션 배포를 위해 애플리케이션을 강화합니다. 제공된 코드 예제와 구성을 이해하고 적용함으로써, React 애플리케이션용 Docker 이미지를 만들고 자신감 있고 편리하게 배포할 수 있게 준비가 되실 겁니다. 즐거운 코딩되세요!\n\n# 자료 출처\n\n\n\n# 연결하고 싶다면?\n\nhttps://www.linkedin.com/in/hongji-li/","ogImage":{"url":"/assets/img/2024-05-12-PackagingFrontEndReactApplicationsunderaProductionEnvironmentwithViteandNginxinDocker_0.png"},"coverImage":"/assets/img/2024-05-12-PackagingFrontEndReactApplicationsunderaProductionEnvironmentwithViteandNginxinDocker_0.png","tag":["Tech"],"readingTime":4},{"title":"React Hook Form과 Nextjs 134를 사용하여 React에서 폼 만들기","description":"","date":"2024-05-12 20:29","slug":"2024-05-12-CreatingaForminReactwithReactHookFormandNextjs134","content":"\n\n![이미지](/assets/img/2024-05-12-CreatingaForminReactwithReactHookFormandNextjs134_0.png)\n\n이번 튜토리얼에서는 React Hook Form을 사용하여 폼 처리 및 유효성 검사를 수행하는 Next.js 애플리케이션에서 로그인 폼을 만들겠습니다. 또한 Zod 라이브러리를 사용하여 폼 스키마를 정의하고 유효성을 검사할 것입니다. 이 튜토리얼이 끝나면 클라이언트 측 유효성을 갖춘 완전히 작동하는 로그인 폼이 준비될 것입니다.\n\n# 준비물\n\n시작하기 전에 다음이 설치되어 있는지 확인하세요:\n\n\n\n- 노드.js 및 npm (Node Package Manager)\n- Next.js 버전 13.4 이상\n\n## 프로젝트 설정\n\n다음 단계로 Next.js 프로젝트를 설정하고 필요한 종속성을 설치해보겠습니다.\n\n- 다음 명령어를 실행하여 새 Next.js 프로젝트를 생성하세요:\n\n\n\n```js\nnpx create-next-app login-form-app\ncd login-form-app\n```\n\n2. **폼 처리 및 유효성 검사를 위해 필요한 패키지 설치:**\n\n```js\nnpm install react-hook-form @hookform/resolvers zod\n```\n\n# 폼 생성하기\n\n\n\n이 예제에서는 이메일과 비밀번호를 입력 필드로 사용하는 로그인 양식을 만들겠습니다.\n\n다음 내용을 가진 src 디렉토리에 LoginForm.tsx라는 새 파일을 생성하세요:\n\n```js\n// app/components/LoginForm.tsx\n\"use client\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { useRouter } from \"next/router\";\nimport { useForm } from \"react-hook-form\";\nimport * as z from \"zod\";\nimport { loginSchema } from \"../zodSchema/login\";\n\ntype FormData = z.infer<typeof loginSchema>;\n\nexport default function LoginForm() {\n  const router = useRouter();\n  const {\n    handleSubmit,\n    register,\n    formState: { errors, isSubmitting, isDirty, isValid },\n  } = useForm<FormData>({\n    resolver: zodResolver(loginSchema),\n  });\n\n  async function onSubmit(data: FormData) {\n    console.log(isSubmitting);\n    console.log(data);\n    // 이를 서버 액션으로 변경하거나 인증 API 엔드포인트를 가져오세요\n    await new Promise<void>((resolve) => {\n      setTimeout(() => {\n        resolve();\n      }, 2000); // 2초를 밀리초로 변환\n    });\n    router.push(\"/tweets\");\n  }\n\n  return (\n    <div className=\"selection:bg-rose-500 selection:text-white\">\n      <div className=\"flex min-h-screen items-center justify-center bg-rose-100\">\n        <div className=\"flex-1 p-8\">\n          <div className=\"mx-auto w-80 overflow-hidden rounded-3xl bg-white shadow-xl\">\n            {/* 양식 헤더 */}\n            <div className=\"rounded-bl-4xl relative h-44 bg-rose-500\">\n              <svg\n                className=\"absolute bottom-0\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n                viewBox=\"0 0 1440 320\"\n              >\n                <path\n                  fill=\"#ffffff\"\n                  fillOpacity=\"1\"\n                  d=\"M0,64L48,80C96,96,192,128,288,128C384,128,480,96,576,85.3C672,75,768,85,864,122.7C960,160,1056,224,1152,245.3C1248,267,1344,245,1392,234.7L1440,224L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z\"\n                ></path>\n              </svg>\n            </div>\n\n            {/* 양식 본문 */}\n            <div className=\"rounded-tr-4xl bg-white px-10 pb-8 pt-4\">\n              <h1 className=\"text-2xl font-semibold text-gray-900\">\n                다시 오신 것을 환영합니다!\n              </h1>\n              <form\n                className=\"mt-12\"\n                action=\"\"\n                method=\"POST\"\n                onSubmit={handleSubmit(onSubmit)}\n              >\n                {/* 이메일 입력 */}\n                <div className=\"relative\">\n                  <input\n                    {...register(\"email\", { required: true })}\n                    id=\"email\"\n                    name=\"email\"\n                    type=\"text\"\n                    className=\"peer h-10 w-full border-b-2 border-gray-300 text-gray-900 placeholder-transparent focus:border-rose-600 focus:outline-none\"\n                    placeholder=\"john@doe.com\"\n                    autoComplete=\"off\"\n                  />\n                  {errors?.email && (\n                    <p className=\"text-red-600 text-sm\">\n                      {errors?.email?.message}\n                    </p>\n                  )}\n                  <label\n                    htmlFor=\"email\"\n                    className=\"absolute -top-3.5 left-0 text-sm text-gray-600 transition-all peer-placeholder-shown:top-2 peer-placeholder-shown:text-base peer-placeholder-shown:text-gray-400 peer-focus:-top-3.5 peer-focus:text-sm peer-focus:text-gray-600\"\n                  >\n                    이메일 주소\n                  </label>\n                </div>\n\n                {/* 비밀번호 입력 */}\n                <div className=\"relative mt-10\">\n                  <input\n                    {...register(\"password\", { required: true })}\n                    id=\"password\"\n                    type=\"password\"\n                    name=\"password\"\n                    className=\"peer h-10 w-full border-b-2 border-gray-300 text-gray-900 placeholder-transparent focus:border-rose-600 focus:outline-none\"\n                    placeholder=\"비밀번호\"\n                    autoComplete=\"off\"\n                  />\n                  {errors?.password && (\n                    <p className=\"text-red-600 text-sm\">\n                      {errors?.password?.message}\n                    </p>\n                  )}\n                  <label\n                    htmlFor=\"password\"\n                    className=\"absolute -top-3.5 left-0 text-sm text-gray-600 transition-all peer-placeholder-shown:top-2 peer-placeholder-shown:text-base peer-placeholder-shown:text-gray-400 peer-focus:-top-3.5 peer-focus:text-sm peer-focus:text-gray-600\"\n                  >\n                    비밀번호\n                  </label>\n                </div>\n\n                {/* 제출 버튼 */}\n                <button\n                  type=\"submit\"\n                  disabled={!isDirty || !isValid || isSubmitting}\n                  className=\"mt-20 block w-full cursor-pointer rounded bg-rose-500 px-4 py-2 text-center font-semibold text-white hover:bg-rose-400 focus:outline-none focus:ring focus:ring-rose-500 focus:ring-opacity-80 focus:ring-offset-2 disabled:opacity-70\"\n                >\n                  {isSubmitting ? (\n                    <div role=\"status\">\n                      <svg\n                        aria-hidden=\"true\"\n                        className=\"inline w-6 h-6 mr-2 text-white animate-spin fill-rose-600 opacity-100\"\n                        viewBox=\"0 0 100 101\"\n                        fill=\"none\"\n                        xmlns=\"http://www.w3.org/2000/svg\"\n                      >\n                        {/* 스피너 애니메이션용 SVG */}\n                      </svg>\n                    </div>\n                  ) : (\n                    \"로그인\"\n                  )}\n                </button>\n              </form>\n\n              {/* 비밀번호 잊은 경우 링크 */}\n              <a\n                href=\"#\"\n                className=\"mt-4 block text-center text-sm font-medium text-rose-600 hover:underline focus:outline-none focus:ring-2 focus:ring-rose-500\"\n              >\n                비밀번호를 잊으셨나요?\n              </a>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n이제 LoginForm 컴포넌트를 만들었으므로 메인 페이지 컴포넌트에서 가져와 사용할 수 있습니다.\n\n\n\n페이지 디렉토리에 index.tsx라는 새 파일을 만들어서 아래 내용을 넣어주세요:\n\n```js\n// app/page.tsx\n\nimport LoginForm from \"../src/components/LoginForm\";\n\nexport default function HomePage() {\n  return (\n      <LoginForm />\n  );\n}\n```\n\n이 파일에서는 LoginForm 컴포넌트를 import하여 HomePage 컴포넌트 내에서 렌더링하고 있습니다.\n\n# Zod Schema\n\n\n\n다음으로, 로그인 양식 유효성 검사를 위해 Zod를 사용하여 loginSchema를 정의해 봅시다. 다음 내용을 포함하는 src/zodSchema 디렉토리에 login.ts라는 새 파일을 만들어주세요:\n\n```js\n// src/zodSchema/login.ts\n\nimport z from \"zod\";\n\nexport const loginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n});\n\nexport type User = z.infer<typeof loginSchema>;\n```\n\n이 스키마는 로그인 양식 필드에서 예상하는 데이터의 구조를 정의합니다.\n\n# 양식 테스트\n\n\n\n이제 클라이언트 측 유효성 검사가 포함된 완전히 작동하는 로그인 폼이 있습니다. 이 폼은 제출을 허용하기 전에 이메일이 올바른 형식인지와 비밀번호가 최소 8자 이상인지를 확인할 것입니다.\n\n폼을 테스트하려면 Next.js 애플리케이션을 실행하세요:\n\n```js\nnpm run dev\n```\n\n브라우저에서 http://localhost:3000을 방문하여 로그인 폼이 작동하는 것을 확인할 수 있습니다.\n\n\n\n# 요약\n\n이 튜토리얼에서는 React Hook Form을 사용하여 Next.js 애플리케이션에서 로그인 폼을 만드는 방법을 배웠습니다. 폼 처리와 유효성 검사를 위해 사용했습니다. 우리는 Zod를 사용하여 폼 스키마를 정의하고 유효성을 검사했습니다. 사용자가 잘못된 데이터를 입력하면 오류 메시지가 표시되고, 폼이 올바르게 작성될 때까지 제출 버튼이 비활성화됩니다. 이 구현은 React 및 Next.js 프로젝트에서 더 복잡한 폼을 만드는 좋은 시작점을 제공합니다.\n\n사용자 경험을 향상시키는 좋은 방법인 클라이언트 측 유효성 검사를 기억해주세요. 하지만 로그인 폼의 유일한 보안 계층이 되어서는 안 됩니다. 항상 강력한 서버 측 유효성 검사와 인증 메커니즘을 갖추어 애플리케이션을 잠재적인 보안 위협으로부터 보호해야 합니다.\n\n즐거운 코딩! 🚀","ogImage":{"url":"/assets/img/2024-05-12-CreatingaForminReactwithReactHookFormandNextjs134_0.png"},"coverImage":"/assets/img/2024-05-12-CreatingaForminReactwithReactHookFormandNextjs134_0.png","tag":["Tech"],"readingTime":9},{"title":"너드닷컴 서머 연습 프로그램 2024으로 잠재력을 발휘해보세요","description":"","date":"2024-05-12 20:28","slug":"2024-05-12-UnlockYourPotentialwithNerdsshSummerPracticeProgram2024","content":"\n\n<img src=\"/assets/img/2024-05-12-UnlockYourPotentialwithNerdsshSummerPracticeProgram2024_0.png\" />\n\n안녕하세요, 기술 열정가 여러분! 여러분의 기술을 향상시키고 혁신적인 학습 경험의 문을 열 준비가 되셨나요? Nerds.sh에서 여러분을 초대합니다. 여러분이 학문적 여정의 끝에 다가온 학생들을 위해 특별히 구성된 여름 실습 프로그램에 참여해보세요. 2024년 7월 1일부터 시작되는 3주 동안의 모험에 도전하고 여러분의 지적 능력을 도전하며 기술에 대한 열정을 일으킬 준비를 하세요!\n\nNerds.sh를 선택해야 하는 이유가 무엇일까요? Nerds.sh에서는 여러분의 기술 향상을 위한 이상적인 환경을 조성하며 여러분의 기술 경력의 진로를 열어줍니다. 이번 여름, 백엔드 개발을 위한 C# 및 현대적인 프런트엔드 체험을 위한 React에서 실용적인 경험을 쌓고, 다재다능한 소프트웨어 엔지니어가 되고자 하는 분들에게 최적입니다.\n\n# 왜 우리의 여름 실습을 선택해야 할까요?\n\n\n\n- 진짜 프로젝트, 실질적인 영향: 우리의 운영에 큰 영향을 미치는 프로젝트에 참여하세요. 이 프로그램을 마치면 성취와 기술이 가득한 포트폴리오를 갖게 될 거에요.\n- 전문적인 안내: 산업에서 가장 뛰어난 두뇌들로부터 배우세요. 업계 최고의 멘토들이 백엔드와 프론트엔드 개발의 복잡성을 안내하고 꼭 필요한 통찰력과 강력한 지원을 제공할 거예요.\n- 네트워킹과 협업: 기술과 혁신에 대한 공동 열정을 추구하는 동료들로 이루어진 커뮤니티에 참여하세요. 저희 인턴들은 종종 오랜 우정과 가치 있는 전문 네트워크를 형성하곤 해요.\n- 경력 발전: 우리는 단순히 훈련만 하는 게 아니에요. 많은 인턴들이 Nerds.sh 내에서 정규직으로 매끄럽게 전환했거나 기술 분야에서 다른 곳으로 날개를 펼쳤어요.\n- 너드적 재미의 문화: 관심을 가지고 지지며 극도로 너드적인 환경에 몰두하세요. 우리는 모두가 우수하게 발전할 수 있는 커뮤니티를 만들기를 소중히 여겨요.\n\n# 이번 여름 우리와 함께하고 싶나요?\n\n당신의 여정을 시작할 준비가 됐나요? Nerds.sh 여름 연습 프로그램에 지원하는 방법은 다음과 같습니다:\n\n- Nerds.sh Careers 방문하기\n- 기술 및 관련 경험을 강조하는 이력서 제출하기\n- 기다려 주세요 — 저희 팀원 중 한 분이 다음 단계를 논의하기 위해 연락을 드릴 거예요.\n\n\n\n사용신청이 열렸어요, 하지만 자리가 빨리 차고 있어요! 당신의 커리어를 슈퍼차지할 기회를 놓치지 마세요. 2024년 6월 10일까지 신청하세요. 그리고 이번 여름에 우리와 함께 열정적으로 참여해 보세요!\n\n미래의 기술 파이오니어여, 7월 1일에 만나요! 이 여름을 잊지 못할 것 같아요!","ogImage":{"url":"/assets/img/2024-05-12-UnlockYourPotentialwithNerdsshSummerPracticeProgram2024_0.png"},"coverImage":"/assets/img/2024-05-12-UnlockYourPotentialwithNerdsshSummerPracticeProgram2024_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트JS를 사용하여 Amazon S3로 파일을 업로드하기 위한 사전 서명 된 URL 사용하기","description":"","date":"2024-05-12 20:26","slug":"2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS","content":"\n\n## 아마존 S3와 웹 애플리케이션을 연결하는 초보자 가이드\n\n파일을 아마존 S3에 업로드하는 것은 상대적으로 간단하고 흔한 작업일 줄 알았습니다. 버킷을 설정하고 자격 증명을 사용하여 요청을 보내기만 하면 되는 것 아닐까요? 그렇게 복잡할 수 없겠죠?\n\n유튜브, 스택 오버플로우, 그리고 AWS 자체 문서와 블로그에서 사용할 수 있는 다양한 리소스들이 있습니다 (리소스의 전체 목록은 아래에서 찾아볼 수 있습니다). 그러나 저 (그리고 아마 여러분도) 곧 깨닫게 될 것은, 특히 부주의한 실수를 범하기 쉬운 초보자라면 생각했던 것보다 간단하지 않다는 것입니다.\n\n본래 제 목표는 (이미지, 비디오 등등) 파일을 웹 애플리케이션을 통해 업로드하고 버튼을 클릭하면 S3 버킷에 업로드되도록 하는 것이었습니다. 이를 위해 제가 찾은 방법은 웹 애플리케이션과 AWS 백엔드 사이에서 요청을 보내기 위해 사전 서명된 URL을 사용하는 것입니다. 이런식으로 동작합니다:\n\n\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_0.png)\n\n요약하면 이렇게 해야 합니다: 이 실제 작동 방식에 대한 더 자세한 내용은 하단의 자료에서 링크된 블로그 포스트를 확인하는 것을 추천합니다. 그러나 이 게시물에서는 가능한 단순한 용어로 설정하는 프로세스를 주로 살펴보려고 할 것이기 때문에 더 이해하기 쉽도록 노력하겠습니다. 준비되셨나요? 🙂 \n\n상상할 수 있겠지만, 설정해야 할 4가지 주요 구성 요소가 있습니다: Amazon S3, AWS Lambda, Amazon API Gateway, 그리고 물론 응용 프로그램 프론트엔드입니다. 이번에 우리가 따라갈 단계를 아래에서 요약해 보겠습니다:\n\n\n\n- Amazon S3 설정하기\n1.1 S3 버킷 생성\n1.2 S3 버킷에 CORS 활성화하기\n\n- AWS Lambda 설정하기\n2.1 AWS Lambda 함수 생성\n2.2 Lambda 함수 테스트하기\n2.3 Lambda 함수 IAM 역할에 S3 액세스 활성화하기\n\n- Amazon API GateWay 설정하기\n3.1 HTTP API 엔드포인트 생성\n3.2 Postman을 사용하여 엔드포인트 테스트하기\n\n- 업로더 컴포넌트 설정하기\n4.1 필수 라이브러리 설치하기\n4.2 API GateWay로 요청을 하는 함수 설정하기\n\n이 방법으로 간단한 작업을 수행하기 위해 배포 단계에서 많은 구성이 진행되며, 때로는 AWS의 오류 메시지가 모호하여 문제가 발생한 구체적인 위치를 파악하기 어려울 수 있습니다. (위의 비디오에 좋은 예시가 있음).\n\n# 단계 1: Amazon S3 설정하기\n\n## 단계 1.1: S3 버킷 생성하기\n\n\n\n먼저, 아직 S3 버킷이 없다면 만드세요. 설명적인 이름을 지정하고 보안상의 이유로 \"모든 공개 액세스 차단\"란에 체크하세요 (물론 공개 액세스를 허용하고 싶다면 그렇게 하셔도 됩니다).\n\n<img src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_1.png\" />\n\n## 단계 1.2: S3 버킷에 CORS 활성화하기\n\n다음으로, 방금 생성한 버킷을 클릭하고 \"Permissions(권한)\" 탭으로 이동하세요.\n\n\n\n`<img src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_2.png\" />`\n\n바닥으로 스크롤을 내려 CORS 섹션을 찾아 \"편집\"을 클릭하세요.\n\n`<img src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_3.png\" />`\n\n그리고 아래 JSON을 붙여넣으세요:\n\n\n\n```js\n[\n    {\n        \"AllowedHeaders\": [\n            \"*\"\n        ],\n        \"AllowedMethods\": [\n            \"PUT\",\n            \"GET\"\n        ],\n        \"AllowedOrigins\": [\n            \"*\"\n        ],\n        \"ExposeHeaders\": []\n    }\n]\n```\n\n작업을 마치면 외부 출처(예: React 애플리케이션)에 S3 버킷으로의 \"PUT\" 및 \"GET\" 요청을 허용할 수 있게 될 것입니다.\n\n# 단계 2: AWS Lambda 설정\n\nAWS Lambda는 서버리스 컴퓨트 서비스로, 어떤 종류의 응용 프로그램이나 백엔드 서비스에도 코드를 실행할 수 있도록 해주며 어떠한 관리도 필요하지 않습니다. 여기에서는 이전에 만든 S3 버킷에서 사전 서명된 URL을 얻는 데 AWS Lambda를 사용할 것입니다.\n\n\n\n## 단계 2.1: AWS 람다 함수 생성하기\n\n기본 설정을 사용하여 함수에 설명적인 이름을 지정하고 함수를 만듭니다:\n\n![lambda-function](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_4.png)\n\n함수가 생성되면 \"코드\" 탭으로 이동하여 \"index.js\" 파일을 엽니다.\n\n\n\n위의 템플릿 코드를 다음으로 대체해주세요:\n\n기본적으로 여기서 일어나는 것은 람다 함수가 S3 버킷에서 사전 서명된 URL을 요청하는 것입니다. 9번째 줄은 진입점이며, getUploadURL 함수(12번부터 정의됨)가 호출됩니다. 반환된 결과는 다음을 포함하는 JSON 객체입니다:\n\n- 실제 파일을 업로드하는 데 사용할 \"uploadURL\"\n- 파일 업로드 시 S3에 표시될 \"filename\" (파일이 성공적으로 업로드되면 표시되는 파일 이름)\n\n주의하세요! 필요에 맞게 변경하고 싶을 수 있는 3줄이 있습니다:\n\n\n\n- 4번 줄: 여기에 실제 버킷 이름을 사용하세요\n- 14번 줄: 업로드된 파일 이름을 사용자 정의하고 싶다면\n- 21번 줄: ContentType을 업로드할 파일과 일치하도록 변경하세요\n\n## 단계 2.2: Lambda 함수 테스트하기\n\n이제 Lambda에서 함수를 테스트할 준비가 되었습니다. 그러나 \"테스트\"를 클릭하기 전에 변경 사항을 배포했는지 확인하세요!\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_5.png)\n\n\n\n\"Test\"을 클릭하면 테스트에 이름을 지어서 만들어보세요.\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_6.png)\n\n실제로 함수를 테스트하면 실행 결과로 이와 같은 출력이 나올 것입니다:\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_7.png)\n\n\n\n응당이 JSON 본문을 포함하고 있어서 uploadURL과 filename이 나옵니다.\n\n## 단계 2.3: 람다 기능 IAM 역할에 대한 S3 액세스 활성화\n\n아마도 다음 단계는 덜 직관적일 수 있습니다. 이곳에서 우리는 람다 함수가 S3 버킷과 통신할 수 있도록 권한을 부여해야 합니다.\n\n\"구성\"으로 이동하여 \"실행 역할\" 아래의 IAM 역할 이름을 클릭하십시오. IAM은 Identity Access Management의 약자로, AWS가 각 도구나 서비스가 갖는 권한을 관리하는 데 사용됩니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_8.png\" />\n\n현재 IAM 역할을 검토하면 람다 함수를 실행하는 권한만 있고 S3에 대한 권한이 없는 것을 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_9.png\" />\n\n권한을 부여하려면 \"정책 연결\"을 클릭하고 검색 창에 \"S3\"를 입력한 다음 \"S3FullAccess\"를 선택한 후 \"정책 연결\"을 클릭하세요.\n\n\n\n이제 S3 버킷에 파일 개체를 넣을 수 있게 되었어요!\n\n참고: 더 나은 보안 관행을 위해 실제로는 Lambda 함수에 대해 S3 버킷과 관련된 객체를 가져오고 넣는 권한만 부여해야 합니다. 또한 해당 S3 버킷에 대해만 권한이 적용될 수 있도록 권한을 제한해야 합니다. 이 작업을 실제로 어떻게 수행하는지 확인하려면 AWS의 리소스 섹션에서 제공하는 비디오 자습서를 참조하세요.\n\n# 단계 3: Amazon API Gateway 설정\n\n좋아요, 그래서 AWS에서 Lambda 함수를 테스트했는데, 어떻게 웹 애플리케이션에서 동일한 Lambda 함수를 실행할 수 있을까요? 그렇게 하려면 호출할 수 있는 API 엔드포인트를 설정해야 합니다. 다행히도, AWS는 이를 우리에게 Amazon API Gateway를 통해 제공해줍니다.\n\n\n\n## 단계 3.1 HTTP API 엔드포인트 생성\n\nLambda 함수로 이동하여 \"추가 트리거\"를 클릭하여 Lambda 함수가 실행되도록 트리거할 HTTP 엔드포인트를 생성합니다.\n\n![Lambda function trigger](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_10.png)\n\n보안을 \"열림\"으로 설정하고 CORS를 활성화합니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_11.png\" />\n\n트리거를 추가하면 \"Triggers\" 섹션에서 엔드포인트를 가져올 수 있습니다:\n\n<img src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_12.png\" />\n\n## 단계 3.2. Postman을 사용하여 엔드포인트를 테스트합니다\n\n\n\n지금까지 모든 것을 올바르게 설정했는지 확인하기 위해 Postman을 사용하여이 엔드포인트를 테스트할 수 있습니다. 엔드포인트를 복사하고 다음과 같이 GET 요청을 만들어보세요:\n\n[마크다운 링크](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_13.png)\n\n다음으로 uploadURL 값을 복사하고 다른 요청을 만들어보세요. 이번에는 메소드를 \"PUT\"로 변경하고 테스트를 위해 샘플 .jpeg 이미지를 업로드하세요. 이미지를 업로드하려면 'Body' 탭을 선택하고 파일 시스템에서 파일을 선택할 수 있게 해주는 'binary' 옵션을 선택하세요. 모두 준비가 되었으면 \"Send\"를 클릭하세요. 반응에 오류 메시지가 표시되지 않는다면, 그것은 좋은 신호입니다!\n\n\n[마크다운 링크](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_14.png)\n\n\n\n이제 S3 버킷을 확인해 보세요. 무작위로 생성된 파일 이름을 가진 파일이 업로드된 것을 확인할 수 있어요:\n\n![Uploaded File](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_15.png)\n\n# 단계 4: 업로더 컴포넌트 설정\n\n이제 거의 끝났어요! 프론트엔드 부분에서는 업로더 컴포넌트가 어떻게 보이길 원하는지는 자유롭게 결정할 수 있어요. 이 예시에서는 react-dropzone-uploader 패키지를 사용했지만, 여러분이 원하는 대로 사용할 수 있어요. 먼저 axios와 필요한 다른 패키지를 설치하세요. (이 경우, 나는 react-dropzone-uploader를 사용했어요)\n\n\n\n## 단계 4.1: 필수 패키지 설치\n\n```js\nnpm install axios react-dropzone-uploader\n```\n\n## 단계 4.2 API Gateway에 요청을 보내는 함수 설정\n\n웹 애플리케이션 코드에서 axios가 필요하며(API_GATEWAY_SECRET 엔드포인트 URL)를 API 엔드포인트 URL로 교체합니다.\n\n\n\n30번 라인에서 파일을 제출할 수 있게 해주는 Dropzone 컴포넌트가 있어요 (원하시면 마음에 드는 컴포넌트로 디자인해도 괜찮아요).\n\n이제 우리는 handleSubmit 함수(Line 13)를 사용하여 Postman에서 했던 두 단계 과정을 거의 똑같이 따를 거에요. 먼저 API 엔드포인트로 \"GET\" 요청을 보내고, 그런 다음 응답으로 반환된 사전 서명된 uploadURL로 \"PUT\" 요청을 보내면 돼요.\n\n그리고 이제 마침내 끝났어요! 이 예제에서 .jpeg 이미지 파일을 앱에 제출하면 Amazon S3로 업로드되는 것을 확인할 수 있을 걸요 👍\n\n# 마무리\n\n\n\n간단히 말해, AWS를 구성하는 것은 어렵고 지루해 보일 수 있지만, 이 기사가 여러분께 사전 서명된 URL을 사용하여 Amazon S3로 파일을 업로드하는 프로세스를 더 잘 이해할 수 있게 도움이 되기를 바랍니다. 도움이 되었다면 좋아요와 공유도 부탁드리며, 더 나은 방법이나 궁금한 점이 있으면 언제든지 연락해 주세요! 💪\n\n## 자료\n\n- AWS 블로그 글: [https://aws.amazon.com/blogs/compute/uploading-to-amazon-s3-directly-from-a-web-or-mobile-application/](https://aws.amazon.com/blogs/compute/uploading-to-amazon-s3-directly-from-a-web-or-mobile-application/)\n- AWS 유튜브 튜토리얼: [https://www.youtube.com/watch?v=mw_-0iCVpUc&ab_channel=AmazonWebServices](https://www.youtube.com/watch?v=mw_-0iCVpUc&ab_channel=AmazonWebServices)\n- AWS GitHub 저장소: [https://github.com/aws-samples/amazon-s3-presigned-urls-aws-sam](https://github.com/aws-samples/amazon-s3-presigned-urls-aws-sam)\n- 내 GitHub 저장소: [https://github.com/AllardQuek/react-demo](https://github.com/AllardQuek/react-demo)\n- CORS: [https://www.youtube.com/watch?v=4KHiSt0oLJ0](https://www.youtube.com/watch?v=4KHiSt0oLJ0)\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_16.png)","ogImage":{"url":"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_0.png"},"coverImage":"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_0.png","tag":["Tech"],"readingTime":8},{"title":"리액트  Props들어오는 값와 State내부값의 명명 규칙","description":"","date":"2024-05-12 20:24","slug":"2024-05-12-ReactNamingConventionforPropsinoutandState","content":"\n\n프로그래밍에서 가장 어려운 일 중 하나가 이름 짓기라고 자주 들어봤을 거예요.\n\n대부분의 경우, 우리는 컴포넌트의 프로퍼티와 상태 변수를 어떻게 명명할지에 대해 많은 생각을 하게 됩니다.\n\n이 자료에서는 React를 사용할 때 내가 사용하는 명명 규칙을 공유하고, 여러분이 프로퍼티와 상태를 어떻게 명명할지 쉽게 결정할 수 있도록 도와드릴 거예요.\n\n# ☯️ 프로퍼티용 명명 규칙\n\n\n\n리액트 프롭(prop)을 보는 방식은 입력과 출력 두 가지로 구성되어 있다고 생각해요.\n\n그리고 이 두 가지는 서로 다른 네이밍 규약을 갖고 있어요.\n\n입력 프롭은 부모 컴포넌트에서 자식 컴포넌트로 전달되어 자식 컴포넌트의 동작을 커스터마이즈하는 데 사용돼요.\n\n![React Naming Convention for Props](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png)\n\n\n\n출력 props는 입력 props와 거의 동일하지만 그 주요 목적은 이벤트 핸들러로 알려진 것과 같이 자식 컴포넌트가 부모와 통신할 수 있도록 하는 것입니다.\n\n![React-Naming-Convention-for-Props](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_1.png)\n\n이제 입력 및 출력 props 간의 차이를 이해했으므로 네이밍 규칙으로 넘어가 봅시다.\n\n## 입력 props의 네이밍 규칙\n\n\n\n입력 프롭스에 대해 다음과 같은 네이밍 규칙을 사용합니다:\n\n- 프롭스가 부울형인 경우 접두사로 is 또는 has를 사용하고 그 뒤에 프롭스의 이름을 붙입니다. 예를 들어: isDisabled, hasError, isActive, isOpen.\n\n- 프롭스가 컴포넌트의 \"도메인 값\" 또는 \"도메인 데이터\"인 경우 그것을 값으로 명명합니다. 문자열, 숫자, 배열 또는 객체인지에 상관없이 모두 value로 명명합니다. 네이티브 HTML 요소 속성과 유사합니다. 예를 들어: value, defaultValue, initialValue.\n\n- 컴포넌트 내의 자식 컴포넌트의 스타일인 경우, 자식 컴포넌트의 이름 뒤에 Props를 붙입니다. 예를 들어: textProps, buttonProps, inputProps, switchProps.\n\n\n\n- 만약 prop이 ref prop이라면, 접미사 Ref 뒤에 ref의 이름을 사용합니다. 예를 들어, inputRef, buttonRef, textRef와 같이 사용합니다.\n\n## 출력 Props에 대한 네이밍 규칙\n\n출력 Props의 경우, 다음과 같은 네이밍 규칙을 사용합니다:\n\n- 만약 prop이 렌더 prop이라면, 접두사 render를 사용하고 prop의 이름을 뒤에 붙입니다. 예를 들어, renderItem, renderHeader, renderFooter와 같이 사용합니다.\n\n\n\n- 만약 prop이 이벤트 핸들러인 경우에는 해당 이벤트의 이름 뒤에 on을 붙입니다. 예를 들어, onClick, onSubmit, onClose, onOpen입니다.\n\n일부 출력 props가 이벤트 핸들러일 때에는 해당 이벤트의 이름 앞에 handleOn을 붙입니다. 예를 들어, handleOnClick, handleOnSubmit, handleOnClose, handleOnOpen입니다.\n\n만약 이벤트가 변경(change) 이벤트인 경우에는 이름 뒤에 Change를 추가합니다. 예를 들어, handleOnChange, handleOnInputChange입니다.\n\n![React props naming convention](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_2.png)\n\n\n\n# ⚙️ 상태에 대한 네이밍 규칙\n\n상태 속성은 변수의 네이밍 규칙과 거의 동일합니다.\n\n만약 변수에 대해 이미 네이밍 규칙을 가지고 있고 익숙하다면, 동일한 네이밍 규칙을 상태 변수에 적용할 수 있습니다.\n\n하지만 변수에 대해 네이밍 규칙이 없다면, 다음 네이밍 규칙을 사용할 수 있습니다:\n\n\n\n- 만약 상태가 부울(Boolean) 값인 경우, 상태의 이름에 \"is\" 또는 \"has\" 접두사를 사용합니다. 예를 들면: [isDisabled, setIsDisabled], [hasError, setHasError], [isActive, setIsActive], [isOpen, setIsOpen].\n\n- 만약 상태가 컴포넌트의 \"도메인 값\" 또는 \"도메인 데이터\"인 경우, 값을 value로 지정합니다. 이 값이 문자열, 숫자, 배열 또는 객체든 상관없이 모두 같은 value로 표기합니다. 네이티브 HTML 입력 요소와 유사합니다. 예를 들면: [value, setValue], [defaultValue, setDefaultValue], [initialValue, setInitialValue].\n\n위의 명명 규칙 중 어떤 것이 props와 충돌한다면, 구조분해 할 때 별칭으로 설정하세요.\n\n- 만약 상태가 메모이제이션(memoized)된 값인 경우, 상태/컴포넌트의 이름 뒤에 memoized/Memoized 접두사를 사용합니다.\n\n\n\n메모이즈된 값이 컴포넌트가 아닌 경우, 접두사는 소문자로 지정됩니다. 예를 들어: memoizedValue, memoizedSum, memoizedResult.\n\n![이미지1](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_3.png)\n\n메모이즈된 값이 컴포넌트인 경우, 접두사는 대문자로 지정됩니다. 예를 들어: MemoizedButton, MemoizedText, MemoizedHeader.\n\n![이미지2](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_4.png)\n\n\n\n# 🚀 결론\n\n이름 짓기는 어렵지만 결정을 돕는 가이드가 있다면 더 쉬울 수 있어요.\n\nReact 작업 시 사용하는 이 명명 규칙은 HTML 요소 속성에서 영감을 받았습니다. 비슷한 점을 찾아야 해서 일부 명명 규칙을 재사용하는 것을 좋아해요.\n\n만약 이 중 어떤 것도 도움이 되지 않는다면, 언제든지 여러분, 여러분의 사용 사례 및 팀에 가장 적합한 명명 규칙을 만들 수 있다는 것을 염두에 두세요.\n\n\n\n하루 마무리할 때 중요한 것은 일관되게 따를 수 있는 네이밍 규칙을 가지고 있다는 것입니다.\n\n언제든지 궁금한 점이 있거나 제안할 내용이 있다면 아래에 댓글을 남겨주세요. 당신의 의견을 듣는 것을 기쁘게 생각할 거에요.\n\n읽어주셔서 감사합니다. 여러분의 여정에 도움이 되기를 바랍니다! ❤️\n\n# 간단히 표현한 것 🚀\n\n\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클립하고 팔로우해 주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png"},"coverImage":"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png","tag":["Tech"],"readingTime":4},{"title":"React JS를 사용하여 어떤 패키지도 사용하지 않고 호버 시 드롭다운 메뉴를 만드는 방법","description":"","date":"2024-05-12 20:22","slug":"2024-05-12-HowtocreateadropdownmenuonhoverinReactJSwithoutanypackage","content":"\n\n<img src=\"https://miro.medium.com/v2/resize:fit:796/1*AXro4l-eefcJcsCr40yw2w.gif\" />\n\nReact에서 외부 패키지를 사용하지 않고 호버 시 드롭다운 메뉴를 만들려면 다음 단계를 따를 수 있습니다:\n\n단계 1: React 프로젝트 설정\n\n아직 React 프로젝트를 설정하지 않은 경우 터미널에 아래 명령을 붙여넣어 새로운 프로젝트를 만들어야 합니다.\n\n\n\n```js\nnpx create-react-app dropdown-menu\n```\n\n단계 2: 드롭다운 컴포넌트 생성\n\n프로젝트 디렉토리 내에 DropdownMenu이라는 이름의 컴포넌트를 생성하고 아래 코드를 붙여넣으세요.\n\n```js\nimport React from \"react\";\n\nconst DropdownMenu = () => {\n  return (\n    <div className=\"dropdown-menu\">\n      <ul>\n        <li>메뉴 1</li>\n        <li>메뉴 2</li>\n        <li>메뉴 3</li>\n      </ul>\n    </div>\n  );\n};\n\nexport default DropdownMenu;\n```\n\n\n\n위의 코드에서는 호버 시에 표시되는 간단한 메뉴를 생성하고 있습니다.\n\n단계 3: 드롭다운 컴포넌트 가져오고 이벤트 처리하기\n\n당신의 주요 컴포넌트(App.js 등)에서 DropdownMenu 컴포넌트를 가져오고 호버 이벤트를 처리해보세요.\n\n```js\nimport { useState } from \"react\";\nimport DropdownMenu from \"./DropdownMenu\";\nimport \"./App.css\";\n\nfunction App() {\n  const [isDropdownVisible, setDropdownVisible] = useState(false);\n\n  const handleMouseEnter = () => {\n    setDropdownVisible(true);\n  };\n\n  const handleMouseLeave = () => {\n    setDropdownVisible(false);\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <div\n          className=\"menu\"\n          onMouseEnter={handleMouseEnter}\n          onMouseLeave={handleMouseLeave}\n        >\n          <button>Dropdown Menu</button>\n          {/* <DropdownMenu /> */}\n          {isDropdownVisible && <DropdownMenu />}\n        </div>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n\n\n위의 코드에서 App 컴포넌트는 사용자가 요소 위로 마우스를 올리면 true로 설정되는 상태 변수 isDropdownVisible을 관리하며, 마우스가 요소를 벗어나면 false로 설정됩니다. handleMouseEnter 및 handleMouseLeave 함수는 상태를 적절히 업데이트하는 데 사용됩니다.\n\n단계 4: 스타일 추가\n\n이제 드롭다운 컴포넌트에 일부 스타일을 추가하세요. 아래 CSS를 App.css 파일에 붙여넣기만 하면 됩니다.\n\n```js\nheader {\n  width: 100%;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\nbutton {\n  background: #000;\n  box-shadow: 0px 10px 30px 0px rgba(82, 63, 105, 0.05);\n  color: #fff;\n  padding: 12px 25px;\n  border: none;\n  cursor: pointer;\n}\n\nul {\n  list-style: none;\n  padding: unset;\n  margin: unset;\n}\n\nli {\n  padding: 14px;\n  transition: all linear 0.3s;\n}\n\nli:hover {\n  background: gray;\n  cursor: pointer;\n  color: #fff;\n}\n\n.dropdown-menu {\n  background: #fff;\n  box-shadow: 0px 10px 30px 0px rgba(82, 63, 105, 0.05);\n  transition: all linear 0.3s;\n}\n```\n\n\n\n오늘은 여기까지입니다. 아래에서 GitHub 저장소와 Codesandbox 데모를 확인하실 수 있어요.\n\n궁금한 점이 있으시면 LinkedIn을 통해 연락해주세요.","ogImage":{"url":"/assets/img/2024-05-12-HowtocreateadropdownmenuonhoverinReactJSwithoutanypackage_0.png"},"coverImage":"/assets/img/2024-05-12-HowtocreateadropdownmenuonhoverinReactJSwithoutanypackage_0.png","tag":["Tech"],"readingTime":3},{"title":"useCallback 훅 사용 방법","description":"","date":"2024-05-12 20:22","slug":"2024-05-12-HowtouseuseCallbackhook","content":"\n\n## useCallback()을 사용하여 React 컴포넌트의 성능을 향상시키세요.\n\n![이미지](/assets/img/2024-05-12-HowtouseuseCallbackhook_0.png)\n\nReact 애플리케이션의 성능 향상에는 불필요한 렌더링을 방지하고 렌더링이 전파되는 시간을 줄이는 것이 포함됩니다. useCallback()을 사용하면 몇 가지 불필요한 렌더링을 방지하고 성능을 향상시킬 수 있습니다.\n\n이 글에서는 useCallback() 훅을 자세히 살펴보고, 더 나은 React 코드를 작성하기 위해 올바르게 사용하는 방법에 대해 알아보겠습니다.\n\n\n\n# 1. 함수 동등성\n\nuseCallback()에 대해 자세히 알아보기 전에 참조 동등성과 함수 동등성의 개념을 간단히 상기해 보겠습니다.\n\nJavaScript에서 함수는 다른 변수와 마찬가지로 다룰 수 있습니다. 함수는 다른 함수에서 인수로 전달될 수 있고, 다른 함수에 의해 반환될 수 있으며, 변수에 값을 할당하거나 비교하는 등의 작업을 수행할 수 있습니다. 다시 말해, 객체가 할 수 있는 모든 작업을 수행할 수 있습니다.\n\nsumFunctionFactory()라는 함수를 구현하여 숫자를 더하는 다른 함수를 반환하는 함수를 만들어 보겠습니다. 그런 다음 이 함수를 사용하여 function1과 function2라는 두 가지 함수를 만들어 보겠습니다.\n\n위에서 function1과 function2 함수는 동일한 코드 소스를 공유하지만 별도의 함수 객체이며 서로 다른 인스턴스를 가리키기 때문에 그들을 비교하면 false가 나옵니다. 이것이 JavaScript가 동작하는 방식입니다.\n\n# 2. useCallback() 훅\n\nReact로 돌아와서, 컴포넌트가 다시 렌더링될 때, 컴포넌트 내부의 각 함수가 재생성되므로 이러한 함수의 참조는 렌더 간에 변경됩니다.\n\nuseCallback(callback, dependencies)은 의존성 중 하나가 변경되었을 때에만 변경되는 캐시된 콜백의 인스턴스를 반환합니다. 이는 매 렌더링마다 함수 객체를 재생성하는 대신 렌더 간에 동일한 함수 객체를 사용할 수 있음을 의미합니다.\n\n\n\n```js\nconst memoized = useCallback(() => {\n   // the callback function to be memoized\n},\n  // dependencies array\n[]);\n```\n\n# 3. 사용 사례 시나리오\n\n## 최적화된 자식 컴포넌트에 콜백 전달하기\n\nuseCallback은 참조 동등성에 의존하는 최적화된 자식 컴포넌트에 콜백을 전달할 때 불필요한 렌더링을 방지하는 데 특히 유용합니다. 항목 목록을 렌더링하는 컴포넌트를 가정해보십시오:\n\n\n\n비싸고 불필요한 리스트 다시 렌더링을 방지하기 위해 React.memo()로 묶어주세요.\n\n부모 컴포넌트 `ParentComponent`에서 자식 컴포넌트 `MyList`로 핸들러 함수를 제공합니다:\n\n핸들러 콜백은 useCallback()으로 메모이즈됩니다. 의존성이 동일한 한, useCallback()은 동일한 함수 객체를 반환합니다. `ParentComponent`가 다시 렌더링될 때, 핸들러 함수 객체는 동일하게 유지되어 `MyList`의 메모리제이션을 깨지지 않습니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseuseCallbackhook_1.png)\n\n\n\n# 4. useCallback()를 사용하지 말아야 하는 경우\n\n과도하게 사용하지 않도록 주의합시다. useCallback()에는 주로 코드 복잡성이라는 단점이 있습니다. useCallback()를 추가하는 것이 의미가 없는 경우가 많이 있고, 함수를 계속 재생성해야 하는 경우도 있습니다.\n\nuseCallback()은 여전히 모든 컴포넌트 재렌더링에서 실행해야 하므로 성능적인 단점이 있습니다. 이 예제에서는 useCallback()이 최적화에 도움이 되지 않습니다. 왜냐하면 매번 렌더링할 때마다 clickHandler 함수를 생성하기 때문에, 오히려 최적화 비용이 최적화하지 않는 것보다 더 많이 듭니다.\n\n# 5. 결론\n\n\n\n`useCallback(callback, dependencies)`는 `useMemo()`처럼 사용할 수 있지만 값 대신 함수를 메모이징하여 매 렌더링마다 재생성을 방지합니다. 불필요한 다시 렌더링을 피할 수 있어 응용 프로그램을 더욱 효율적으로 만들어줍니다.\n\n성능 업그레이드를 고려할 때는 언제나 최적화 작업 이전에 컴포넌트의 속도를 측정(또는 프로파일링)해야 합니다. 최적화는 복잡성을 증가시키므로, 개발자로서 효과를 확실하게 확인해야 합니다.\n\n더 많은 멋진 콘텐츠와 이와 유사한 프로젝트를 확인하려면 저희를 팔로우해주세요. Github 리포지토리도 꼭 확인해보세요:","ogImage":{"url":"/assets/img/2024-05-12-HowtouseuseCallbackhook_0.png"},"coverImage":"/assets/img/2024-05-12-HowtouseuseCallbackhook_0.png","tag":["Tech"],"readingTime":3}],"page":"138","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}