{"pageProps":{"posts":[{"title":"JavaScript와 TypeScript 비교 정리","description":"","date":"2024-05-27 18:10","slug":"2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years","content":"\n\n\n![2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png](/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png)\n\n이 기사는 지난 3년 동안 (그리고 그 이전에서도) JavaScript/ECMAScript와 TypeScript에서 발생한 거의 모든 변경 사항을 살펴봅니다.\n\n다음의 기능들 중 일부는 여러분에게 적용되지 않거나 실용적이지 않을 수 있지만, 이러한 언어에 대한 이해를 더 깊게 하고 가능한 기능을 보여주기 위한 것입니다.\n\n많은 TypeScript 기능들을 생략했는데, 그 이유는 \"이전과 달리 예상대로 작동하지 않았으나, 지금은 그렇게 됩니다\"로 요약할 수 있습니다. 따라서 과거에 작동하지 않았던 것이 있다면, 다시 시도해 보세요.\n\n\n<div class=\"content-ad\"></div>\n\n- JavaScript / ECMAScript (가장 오래된 것부터)\n- TypeScript (가장 오래된 것부터)\n\n# 내용\n\n# ECMAScript\n\n## 과거 (아직도 중요한 이전 소개들)\n\n<div class=\"content-ad\"></div>\n\n- Tagged template literals: 템플릿 리터럴 앞에 함수 이름을 붙이면 함수가 템플릿 리터럴 및 템플릿 값들을 전달받게 됩니다. 이 방법에는 재미있는 활용법이 있습니다.\n\n```js\n// 임의의 숫자를 포함한 문자열을 로깅할 때 숫자를 형식화하는 방법을 작성하고 싶다고 가정해 봅시다.\n// 그럴 때 태그드 템플릿을 사용할 수 있습니다.\nfunction formatNumbers(strings: TemplateStringsArray, number: number): string {\n  return strings[0] + number.toFixed(2) + strings[1];\n}\nconsole.log(formatNumbers`This is the value: ${0}, it's important.`); // This is the value: 0.00, it's important.\n\n// 문자열 내의 번역 키를 \"번역\"하고 싶을 때 (여기서는 소문자로 변경)\nfunction translateKey(key: string): string {\n  return key.toLocaleLowerCase();\n}\nfunction translate(strings: TemplateStringsArray, ...expressions: string[]): string {\n  return strings.reduce((accumulator, currentValue, index) => accumulator + currentValue + translateKey(expressions[index] ?? ''), '');\n}\nconsole.log(translate`Hello, this is ${'NAME'} to say ${'MESSAGE'}.`); // Hello, this is name to say message.\n```\n\n- Symbols: 객체에 대한 고유 키: Symbol(\"foo\") === Symbol(\"foo\"); // false. 내부적으로 사용됩니다.\n\n```js\nconst obj: { [index: string]: string } = {};\n\nconst symbolA = Symbol('a');\nconst symbolB = Symbol.for('b');\n\nconsole.log(symbolA.description); // \"a\"\n\nobj[symbolA] = 'a';\nobj[symbolB] = 'b';\nobj['c'] = 'c';\nobj.d = 'd';\n\nconsole.log(obj[symbolA]); // \"a\"\nconsole.log(obj[symbolB]); // \"b\"\n\n// 다른 심볼이나 심볼 없이는 키에 액세스할 수 없습니다.\nconsole.log(obj[Symbol('a')]); // undefined\nconsole.log(obj['a']); // undefined\n\n// for ... in을 사용할 때 키가 열거되지 않습니다.\nfor (const i in obj) {\n  console.log(i); // \"c\", \"d\"\n}\n```  \n\n<div class=\"content-ad\"></div>\n\n## ES2020\n\n- Optional chaining: 잠재적으로 정의되지 않은 객체의 값을 (인덱싱을 통해) 액세스하기 위해 부모 객체 이름 뒤에 ?를 사용하여 선택적 연결을 사용할 수 있습니다. 이는 인덱싱 ([...]) 또는 함수 호출에도 사용할 수 있습니다.\n\n```js\n// 이전:\n// 우리가 정확히 정의된 것인지 확신할 수 없는 객체 변수 (또는 다른 구조)가 있을 때,\n// 속성에 쉽게 액세스할 수 없습니다.\nconst object: { name: string } | undefined = Math.random() > 0.5 ? undefined : { name: 'test' };\nconst value = object.name; // 타입 오류: 'object' 가 'undefined' 일 수 있습니다.\n\n// 먼저 정의되었는지 확인해야 했지만, 이는 가독성을 해치며 중첩된 객체에 대해 복잡해집니다.\nconst objectOld: { name: string } | undefined = Math.random() > 0.5 ? undefined : { name: 'test' };\nconst valueOld = objectOld ? objectOld.name : undefined;\n\n// 새로운 방법:\n// 대신 선택적 연결을 사용할 수 있습니다.\nconst objectNew: { name: string } | undefined = Math.random() > 0.5 ? undefined : { name: 'test' };\nconst valueNew = objectNew?.name;\n\n// 이것은 인덱싱 및 함수에도 사용할 수 있습니다.\nconst array: string[] | undefined = Math.random() > 0.5 ? undefined : ['test'];\nconst item = array?.[0];\nconst func: (() => string) | undefined = Math.random() > 0.5 ? undefined : () => 'test';\nconst result = func?.();\n```\n\n- 널 병합 연산자 (??): 조건부 할당을 위해 || 연산자를 사용하는 대신 새로운 ?? 연산자를 사용할 수 있습니다. 모든 거짓 값에 적용되는 대신 undefined와 null에만 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst value: string | undefined = Math.random() > 0.5 ? undefined : 'test';\n\n// 이전:\n// 값이 undefined 또는 null인 경우 다른 값으로 조건적으로 할당하려면 \"||\" 연산자를 사용할 수 있었습니다.\nconst anotherValue = value || 'hello';\nconsole.log(anotherValue); // \"test\" 또는 \"hello\"\n\n// 이는 참 값 사용 시 잘 작동하지만, 0이나 빈 문자열과 비교할 경우에도 적용됩니다.\nconst incorrectValue = '' || 'incorrect';\nconsole.log(incorrectValue); // 항상 \"incorrect\"\nconst anotherIncorrectValue = 0 || 'incorrect';\nconsole.log(anotherIncorrectValue); // 항상 \"incorrect\"\n\n// 새로운 방법:\n// 이제 nullish 병합 연산자를 사용할 수 있습니다. 이는 오직 undefined와 null 값에만 적용됩니다.\nconst newValue = value ?? 'hello';\nconsole.log(newValue) // 항상 \"hello\"\n\n// 이제 falsy 값들이 교체되지 않습니다.\nconst correctValue = '' ?? 'incorrect';\nconsole.log(correctValue); // 항상 \"\"\nconst anotherCorrectValue = 0 ?? 'incorrect';\nconsole.log(anotherCorrectValue); // 항상 0\n```\n\n- import(): 변수를 사용하여 런타임에서 동적으로 import ... from ... 처럼 모듈을 가져올 수 있습니다.\n\n```js\nlet importModule;\nif (shouldImport) {\n  importModule = await import('./module.mjs');\n}\n```\n\n- String.matchAll(): 루프를 사용하지 않고 정규 표현식의 여러 일치 항목과 캡처 그룹을 모두 얻을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst stringVar = 'testhello,testagain,';\n\n// 이전:\n// 일치 항목만 검색되며 캡처 그룹은 포함되지 않습니다.\nconsole.log(stringVar.match(/test([\\w]+?),/g)); // [\"testhello,\", \"testagain,\"]\n\n// 캡처 그룹을 포함한 하나의 일치 항목만 검색합니다.\nconst singleMatch = stringVar.match(/test([\\w]+?),/);\nif (singleMatch) {\n  console.log(singleMatch[0]); // \"testhello,\"\n  console.log(singleMatch[1]); // \"hello\"\n}\n\n// 같은 결과를 얻지만 매우 직관적이지 않습니다 (exec 메서드는 마지막 인덱스를 저장합니다).\n// 루프 외부에서 정의되어야 하며 전역으로 선언되어야 하며 (/g) 모드여야 합니다.\nconst regex = /test([\\w]+?),/g;\nlet execMatch;\nwhile ((execMatch = regex.exec(stringVar)) !== null) {\n  console.log(execMatch[0]); // \"testhello,\", \"testagain,\"\n  console.log(execMatch[1]); // \"hello\", \"again\"\n}\n\n// 새로운 방법:\n// 정규식은 전역 (/g)이어야 합니다. 그렇지 않으면 작동하지 않습니다.\nconst matchesIterator = stringVar.matchAll(/test([\\w]+?),/g);\n// 순회해야 하거나 배열(Array.from())로 변환해야 하며 직접 색인화(인덱싱)할 수 없습니다.\nfor (const match of matchesIterator) {\n  console.log(match[0]); // \"testhello,\", \"testagain,\"\n  console.log(match[1]); // \"hello\", \"again\"\n}\n```\n\n- Promise.allSettled(): Promise.all()과 유사하지만 모든 Promise가 완료될 때까지 기다리며 첫 번째 reject/throw에서 반환하지 않습니다. 모든 오류 처리를 보다 쉽게 할 수 있습니다.\n\n```js\nasync function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n\n// 이전:\nconsole.log(await Promise.all([success1(), success2()])); // [\"a\", \"b\"]\n// 하지만:\ntry {\n  await Promise.all([success1(), success2(), fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 주의: 하나의 에러만 처리하고 성공 값에 액세스할 수 없습니다.\n\n// 이전 해결 방법 (정말 최적이 아님):\nconsole.log(await Promise.all([ // [\"a\", \"b\", undefined, undefined]\n  success1().catch(e => { console.log(e); }),\n  success2().catch(e => { console.log(e); }),\n  fail1().catch(e => { console.log(e); }), // \"fail 1\"\n  fail2().catch(e => { console.log(e); })])); // \"fail 2\"\n\n// 새로운 방법:\nconst results = await Promise.allSettled([success1(), success2(), fail1(), fail2()]);\nconst sucessfulResults = results\n  .filter(result => result.status === 'fulfilled')\n  .map(result => (result as PromiseFulfilledResult<string>).value);\nconsole.log(sucessfulResults); // [\"a\", \"b\"]\nresults.filter(result => result.status === 'rejected').forEach(error => {\n  console.log((error as PromiseRejectedResult).reason); // \"fail 1\", \"fail 2\"\n});\n// 또는:\nfor (const result of results) {\n  if (result.status === 'fulfilled') {\n    console.log(result.value); // \"a\", \"b\"\n  } else if (result.status === 'rejected') {\n    console.log(result.reason); // \"fail 1\", \"fail 2\"\n  }\n}\n```\n\n- BigInt: 새로운 BigInt 데이터 유형을 사용하여 큰 (정수) 숫자를 정확하게 저장하고 처리할 수 있어 JavaScript가 숫자를 부동 소수점으로 저장하는 것에 의한 오류를 방지할 수 있습니다. BigInt() 생성자를 사용하여 생성할 수 있고(불완전성을 방지하기 위해 문자열을 선호) 또는 숫자 끝에 n을 추가하여 생성할 수 있습니다.\n  \n\n<div class=\"content-ad\"></div>\n\n\n// 이전:\n// JavaScript는 숫자를 부동 소수점으로 저장하기 때문에 항상 약간의 부정확성이 있습니다.\n// 더 중요한 것은 특정 숫자 이후에 정수 연산에 부정확성이 시작됩니다.\nconst maxSafeInteger = 9007199254740991;\nconsole.log(maxSafeInteger === Number.MAX_SAFE_INTEGER); // true\n\n// 해당 숫자보다 큰 숫자와 비교하면 부정확성이 발생할 수 있습니다.\nconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2);\n\n// NEW:\n// BigInt 데이터 형식을 사용하면 이론적으로 무한히 큰 (정수) 숫자를 저장하고 조작할 수 있습니다.\n// 숫자 끝에 \"n\"을 추가하거나 BigInt 생성자를 사용하여 사용합니다.\nconst maxSafeIntegerPreviously = 9007199254740991n;\nconsole.log(maxSafeIntegerPreviously); // 9007199254740991\n\nconst anotherWay = BigInt(9007199254740991);\nconsole.log(anotherWay); // 9007199254740991\n\n// 안전한 정수(Number.MAX_SAFE_INTEGER)보다 큰 정수를 전달하면 안됩니다.\nconst incorrect = BigInt(9007199254740992);\nconsole.log(incorrect); // 9007199254740992\nconst incorrectAgain = BigInt(9007199254740993);\nconsole.log(incorrectAgain); // 9007199254740992\n// 오랜, 동일한 값으로 변환됩니다.\n\n// 대신 문자열을 사용하거나 더 좋은 다른 구문을 사용합니다.\nconst correct = BigInt('9007199254740993');\nconsole.log(correct); // 9007199254740993\nconst correctAgain = 9007199254740993n;\nconsole.log(correctAgain); // 9007199254740993\n\n// 16진수, 8진수 및 2진수도 문자열로 전달할 수 있습니다.\nconst hex = BigInt('0x1fffffffffffff');\nconsole.log(hex); // 9007199254740991\nconst octal = BigInt('0o377777777777777777');\nconsole.log(octal); // 9007199254740991\nconst binary = BigInt('0b11111111111111111111111111111111111111111111111111111');\nconsole.log(binary); // 9007199254740991\n\n// 대부분의 산술 연산은 예상대로 작동하지만 다른 연산자도 BigInt 여야합니다. 모든 연산도 BigInt를 반환합니다.\nconst addition = maxSafeIntegerPreviously + 2n;\nconsole.log(addition); // 9007199254740993\n\nconst multiplication = maxSafeIntegerPreviously * 2n;\nconsole.log(multiplication); // 18014398509481982\n\nconst subtraction = multiplication - 10n;\nconsole.log(subtraction); // 18014398509481972\n\nconst modulo = multiplication % 10n;\nconsole.log(modulo); // 2\n\nconst exponentiation = 2n ** 54n;\nconsole.log(exponentiation); // 18014398509481984\n\nconst exponentiationAgain = 2n ^ 54n;\nconsole.log(exponentiationAgain); // 18014398509481984\n\nconst negative = exponentiation * -1n;\nconsole.log(negative); // -18014398509481984\n\n// BigInt로 인한 정수 나눗셈은 조금 다르게 작동합니다.\nconst division = multiplication / 2n;\nconsole.log(division); // 9007199254740991\n// 나뉠 수 있는 정수에 대해서는 제대로 작동합니다.\n\n// 나누기가 안 되는 숫자에 대해서는 정수 나눗셈(내림)처럼 작동할 것입니다.\nconst divisionAgain = 5n / 2n;\nconsole.log(divisionAgain); // 2\n\n// 일치하는(엄격한) 비교가 BigInt 숫자에는 적용되지 않습니다.\nconsole.log(0n === 0); // false\nconsole.log(0n == 0); // true\n\n// 그러나 비교는 예상대로 작동합니다.\nconsole.log(1n < 2); // true\nconsole.log(2n > 1); // true\nconsole.log(2 > 2); // false\nconsole.log(2n > 2); // false\nconsole.log(2n >= 2); // true\n\n// 타입은 \"bigint\"입니다.\nconsole.log(typeof 1n); // \"bigint\"\n\n// 일반 숫자(부호있는 부호 없는 (음수 없음))로 다시 변환할 수 있습니다.\n// 그러나 이는 정확도를 희생합니다. 유효 숫자의 수를 지정할 수 있습니다.\n\nconsole.log(BigInt.asIntN(0, -2n)); // 0\nconsole.log(BigInt.asIntN(1, -2n)); // 0\nconsole.log(BigInt.asIntN(2, -2n)); // -2\n// 보통 더 높은 비트 수를 사용할 것입니다.\n\n// 음수 숫자는 부호가 있는 숫자로 변환될 때 2의 보수로 변환됩니다.\nconsole.log(BigInt.asUintN(8, -2n)); // 254\n\n\n- globalThis: 환경(브라우저, NodeJS, ...)와 상관없이 전역 컨텍스트에서 변수에 액세스할 수 있습니다. 여전히 권장되지는 않지만 때로는 필요합니다. 브라우저의 최상위 수준에서 this와 유사합니다.\n\n\nconsole.log(globalThis.Math); // Math Object\n\n\n- import.meta: ES-모듈을 사용할 때 현재 모듈 URL import.meta.url을 얻습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconsole.log(import.meta.url); // \"file://...\"\n```\n\n- export * as … from …: 쉽게 기본값을 하위 모듈로 다시 내보냅니다.\n\n```js\nexport * as am from 'another-module'\n```\n\n```js\nimport { am } from 'module'\n```\n\n<div class=\"content-ad\"></div>\n\n## ES2021\n\n- String.replaceAll(): 이제 문자열 내에서 부분 문자열의 모든 인스턴스를 대체할 수 있습니다. 더 이상 항상 전역 플래그(/g)를 사용하는 정규 표현식을 사용할 필요가 없습니다.\n\n```js\nconst testString = 'hello/greetings everyone/everybody';\n// 이전:\n// 첫 번째 인스턴스만 대체함\nconsole.log(testString.replace('/', '|')); // 'hello|greetings everyone/everybody'\n\n// 대체하기 위해 정규 표현식을 사용해야 했는데, 이는 성능이 좋지 않고 이스케이프가 필요합니다.\n// 전역 플래그(/g)를 참고하세요.\nconsole.log(testString.replace(/\\//g, '|')); // 'hello|greetings everyone|everybody'\n\n// 새로운 기능:\n// replaceAll을 사용하면 더 명확하고 빠릅니다.\nconsole.log(testString.replaceAll('/', '|')); // 'hello|greetings everyone|everybody'\n```\n\n- Promise.any(): 프로미스 목록 중 하나의 결과만 필요한 경우, 첫 번째 결과를 반환합니다. 모든 프로미스가 거부될 때만 거부하고 AggregateError를 반환하며, 즉시 거부되는 Promise.race가 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconsole.log(await Promise.race([success1(), success2()])); // \"a\"\n// 그러나:\ntry {\n  await Promise.race([fail1(), fail2(), success1(), success2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 유의: 하나의 오류만 catch하고 성공 값을 액세스할 수 없습니다.\n\n// 이전 수정 (정말 최적화되지 않음):\nconsole.log(await Promise.race([ // \"a\"\n  fail1().catch(e => { console.log(e); }), // \"fail 1\"\n  fail2().catch(e => { console.log(e); }), // \"fail 2\"\n  success1().catch(e => { console.log(e); }),\n  success2().catch(e => { console.log(e); })]));\n\n// 새로운:\nconsole.log(await Promise.any([fail1(), fail2(), success1(), success2()])); // \"a\"\n// 모든 프로미스가 거부될 때만 거부하고 모든 오류를 포함하는 AggregateError를 리턴합니다.\ntry {\n  await Promise.any([fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // [AggregateError: All promises were rejected]\n  console.log(e.errors); // [\"fail 1\", \"fail 2\"]\n}\n```\n\n- Nullish coalescing assignment (??=): 이전에 \"nullish\"였을 때만 값을 할당합니다 (null 또는 undefined).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () => 'b';\n\n// undefined는 nullish이므로 새 값이 x1에 할당됩니다.\nx1 ??= 'b';\nconsole.log(x1) // \"b\"\n\n// 문자열은 nullish가 아니므로 x2에 새 값이 할당되지 않습니다.\n// 또한 참고: getNewValue()가 실행되지 않습니다.\nx2 ??= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- Logical and assignment (&&=): 이전에 \"truthy\"였을 때만 값을 할당합니다 (true 또는 true로 변환되는 값).\n\n<div class=\"content-ad\"></div>\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () => 'b';\n\n// 지정되지 않은 값인 x1에 새 값이 할당되지 않습니다. 왜냐하면 지정되지 않은 값은 참이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx1 &&= getNewValue();\nconsole.log(x1) // undefined\n\n// 문자열은 참이므로 새 값이 x2에 할당됩니다.\nx2 &&= 'b';\nconsole.log(x2) // \"b\"\n```\n\n- 논리 또는 할당 (||=): 이전에 \"거짓\"인 경우에만 값이 할당됩니다 (false 또는 false로 변환).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () => 'b';\n\n// x1에 새 값이 할당됩니다. 왜냐하면 지정되지 않은 값은 거짓이기 때문입니다.\nx1 ||= 'b';\nconsole.log(x1) // \"b\"\n\n// x2에 새 값이 할당되지 않습니다. 왜냐하면 문자열은 거짓이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx2 ||= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- WeakRef: 객체가 가비지 수집되는 것을 방지하지 않고 객체에 \"약한\" 참조를 보유합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst ref = new WeakRef(element);\n\n// 만약 객체/요소가 여전히 존재하고 쓰레기 수집되지 않았다면 값을 가져옵니다.\nconst value = ref.deref;\nconsole.log(value); // undefined\n// 객체가 더는 존재하지 않는 것 같습니다.\n```\n\n- 숫자 리터럴 구분자 (_): 가독성을 위해 숫자를 _로 구분합니다. 이는 기능에 영향을 미치지 않습니다.\n\n```js\nconst int = 1_000_000_000;\nconst float = 1_000_000_000.999_999_999;\nconst max = 9_223_372_036_854_775_807n;\nconst binary = 0b1011_0101_0101;\nconst octal = 0o1234_5670;\nconst hex = 0xD0_E0_F0;\n```\n\n## ES2022\n  \n\n<div class=\"content-ad\"></div>\n\n- 최상위 대기: await 키워드는 이제 ES 모듈의 최상위 수준에서 사용할 수 있습니다. 이는 래퍼 함수의 필요성을 제거하고 오류 처리를 개선합니다.\n\n```js\nasync function asyncFuncSuccess() {\n  return 'test';\n}\n\nasync function asyncFuncFail() {\n  throw new Error('Test');\n}\n\n// 이전:\n// 프로미스를 대기하려면 async 함수 내부에서만 가능했습니다.\n// await asyncFuncSuccess(); // SyntaxError: await is only valid in async functions\n// 따라서 async 함수 내부로 래핑해야 했고 이는 오류 처리와 최상위 동시성을 잃게 했습니다.\ntry {\n  (async () => {\n    console.log(await asyncFuncSuccess()); // \"test\"\n    try {\n      await asyncFuncFail();\n    } catch (e) {\n      // 오류 처리를 위해 필요합니다. 그렇지 않으면 오류가 캐치되지 않거나 적절한 추적 없이 너무 늦게 되어버립니다.\n      console.error(e); // Error: \"Test\"\n      throw e;\n    }\n  })();\n} catch (e) {\n  // 함수가 async여서 절대 호출되지 않거나(적절한 추적이 없거나 너무 늦게) 이유 때문에\n  console.error(e);\n}\n\n// 비동기 함수가 기다려지지 않았기 때문에 이 프로미스 결과보다 먼저 기록됩니다.\nconsole.log('Hey'); // \"Hey\"\n\n// 새로운:\n// 파일이 ES 모듈이라면(package.json에 설정되었고, exports가 있고, \".mts\"로 명명된 경우) 최상위 수준에서 바로 await할 수 있습니다.\nconsole.log(await asyncFuncSuccess()); // \"test\"\ntry {\n  await asyncFuncFail();\n} catch (e) {\n  console.error(e); // Error: \"Test\"\n}\n\n// 모든 비동기 호출이 기다려지기 때문에 이 프로미스 결과 뒤에 기록됩니다.\nconsole.log('Hello'); // \"Hello\"\n```\n\n- #private: 클래스 멤버(속성 및 메서드)를 이름이 #로 시작하게하여 비공개로 만듭니다. 따라서 이러한 멤버는 클래스 내부에서만 액세스할 수 있습니다. 삭제되거나 동적으로 할당할 수 없습니다. 잘못된 동작은 JavaScript(하지만 TypeScript가 아닌) 구문 오류를 발생시킵니다. TypeScript 프로젝트에서는 권장되지 않습니다. 대신 기존 private 키워드를 사용하십시오.\n\n```js\nclass ClassWithPrivateField {\n  #privateField;\n  #anotherPrivateField = 4;\n\n  constructor() {\n    this.#privateField = 42; // 유효\n    delete this.#privateField; // 구문 오류\n    this.#undeclaredField = 444; // 구문 오류\n    console.log(this.#anotherPrivateField); // 4\n  }\n}\n\nconst instance = new ClassWithPrivateField();\ninstance.#privateField === 42; // 구문 오류\n```\n\n<div class=\"content-ad\"></div>\n\n- static 클래스 멤버: 클래스 필드(속성 및 메서드)를 static으로 표시하세요.\n\n```js\nclass Logger {\n  static id = 'Logger1';\n  static type = 'GenericLogger';\n  static log(message: string | Error) {\n    console.log(message);\n  }\n}\n\nclass ErrorLogger extends Logger {\n  static type = 'ErrorLogger';\n  static qualifiedType;\n  static log(e: Error) {\n    return super.log(e.toString());\n  }\n}\n\nconsole.log(Logger.type); // \"GenericLogger\"\nLogger.log('Test'); // \"Test\"\n\n// 정적으로만 있는 클래스를 생성하는 것은 무의미하지만 여기선 시연을 위해 수행되었습니다.\nconst log = new Logger();\n\nErrorLogger.log(new Error('Test')); // 에러: \"Test\" (부모 클래스의 생성에 영향을 받지 않음)\nconsole.log(ErrorLogger.type); // \"ErrorLogger\"\nconsole.log(ErrorLogger.qualifiedType); // undefined\nconsole.log(ErrorLogger.id); // \"Logger1\"\n\n// log()가 인스턴스 메서드가 아닌 정적 메서드이기 때문에 예외를 발생시킵니다.\nconsole.log(log.log()); // log.log is not a function\n```\n\n- 클래스 내의 정적 초기화 블록: 클래스가 초기화될 때 실행되는 블록, 기본적으로 정적 멤버를 초기화하는 \"생성자\"입니다.\n\n```js\nclass Test {\n  static staticProperty1 = '속성 1';\n  static staticProperty2;\n  static {\n    this.staticProperty2 = '속성 2';\n  }\n}\n\nconsole.log(Test.staticProperty1); // \"Property 1\"\nconsole.log(Test.staticProperty2); // \"Property 2\"\n```\n\n<div class=\"content-ad\"></div>\n\n- 가져오기 어설션 (비표준, V8에서 구현됨): 가져온 항목의 유형을 확인하기 위해 사용할 수 있습니다. `import ... from ... assert ' type: `json` '`로 JSON을 직접 가져오고 구문 분석할 필요 없이 사용할 수 있습니다.\n\n```js\nimport json from './foo.json' assert { type: 'json' };\nconsole.log(json.answer); // 42\n```\n\n- 정규표현식 일치 인덱스: 정규표현식 일치 및 캡처 그룹의 시작 및 끝 인덱스를 가져올 수 있습니다. RegExp.exec(), String.match() 및 String.matchAll()에 대해 작동합니다.\n\n```js\nconst matchObj = /(test+)(hello+)/d.exec('start-testesthello-stop');\n\n// 이전:\nconsole.log(matchObj?.index);\n\n// 새로운:\nif (matchObj) {\n  // 전체 일치 항목의 시작 및 끝 인덱스(이전에 시작만 있었음).\n  console.log(matchObj.indices[0]); // [9, 18]\n\n  // 캡처 그룹의 시작 및 끝 인덱스.\n  console.log(matchObj.indices[1]); // [9, 13]\n  console.log(matchObj.indices[2]); // [13, 18]\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- Negative indexing (.at(-1)): 배열이나 문자열을 인덱싱할 때, at()을 사용하여 뒤에서부터 인덱싱할 수 있습니다. 값 가져오기(arr[arr.length - 1]와 동일)만 가능하며 값을 설정할 수는 없습니다.\n\n```js\nconsole.log([4, 5].at(-1)) // 5\n\nconst array = [4, 5];\narray.at(-1) = 3; // SyntaxError: Assigning to rvalue\n```\n\n- hasOwn: 객체가 어떤 속성을 가지고 있는지 obj.hasOwnProperty()을 사용하는 대신 추천되는 새 방법입니다. 일부 특수한 경우에 더 잘 작동합니다.\n\n```js\nconst obj = { name: 'test' };\n\nconsole.log(Object.hasOwn(obj, 'name')); // true\nconsole.log(Object.hasOwn(obj, 'gender')); // false\n```\n\n<div class=\"content-ad\"></div>\n\n- 오류 원인: 이제 오류에 대한 선택적 원인을 지정할 수 있습니다. 이는 다시 throw할 때 원래 오류를 지정할 수 있게 합니다.\n\n```js\ntry {\n  try {\n    connectToDatabase();\n  } catch (err) {\n    throw new Error('데이터베이스 연결에 실패했습니다.', { cause: err });\n  }\n} catch (err) {\n  console.log(err.cause); // ReferenceError: connectToDatabase is not defined\n}\n```\n\n## 미래 (이미 TypeScript 4.9에서 사용 가능)\n\n- Auto-Accessor: 속성을 자동으로 비공개로 만들고 get/set 접근자를 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass Person {\n  accessir name: string;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name) // 'test'\n  }\n}\n\nconst person = new Person('test');\n```\n\n# TypeScript\n\n## 기초 (추후 소개를 위한 문맥)\n\n- 제네릭: 다른 유형으로 유형을 전달합니다. 이를 통해 유형을 일반화 할 수 있지만 여전히 유형 안전성을 유지할 수 있습니다. 항상 `any` 또는 `unknown` 대신 이를 선호해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// WITHOUT:\nfunction getFirstUnsafe(list: any[]): any {\n  return list[0];\n}\n\nconst firstUnsafe = getFirstUnsafe(['test']); // typed as any\n\n// WITH:\nfunction getFirst<Type>(list: Type[]): Type {\n  return list[0];\n}\n\nconst first = getFirst<string>(['test']); // typed as string\n\n// In this case the parameter can even be dropped because it is inferred from the argument.\nconst firstInferred = getFirst(['test']); // typed as string\n\n// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.\nclass List<T extends string | number> {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nconst list = new List<string>();\nlist.push(9); // Type error: Argument of type 'number' is not assignable to parameter of type 'string'.\nconst booleanList = new List<boolean>(); // Type error: Type 'boolean' does not satisfy the constraint 'string | number'.\n```\n\n## 과거 (아직도 유효한 이전 소개)\n\n- 유틸리티 타입: TypeScript에는 많은 유틸리티 타입이 포함되어 있으며, 그 중 가장 유용한 몇 가지가 여기에서 설명되었습니다.\n\n```js\ninterface Test {\n  name: string;\n  age: number;\n}\n\n// Partial 유틸리티 타입은 모든 속성을 선택적으로 만듭니다.\ntype TestPartial = Partial<Test>; // typed as { name?: string | undefined; age?: number | undefined; }\n// Required 유틸리티 타입은 반대로 동작합니다.\ntype TestRequired = Required<TestPartial>; // typed as { name: string; age: number; }\n// Readonly 유틸리티 타입은 모든 속성을 읽기 전용으로 만듭니다.\ntype TestReadonly = Readonly<Test>; // typed as { readonly name: string; readonly age: string }\n// Record 유틸리티 타입은 객체/맵/사전을 간단하게 정의할 수 있습니다. 가능한 경우에는 인덱스 시그니처보다 선호됩니다.\nconst config: Record<string, boolean> = { option: false, anotherOption: true };\n// Pick 유틸리티 타입은 지정된 속성만 가져옵니다.\ntype TestLess = Pick<Test, 'name'>; // typed as { name: string; }\ntype TestBoth = Pick<Test, 'name' | 'age'>; // typed as { name: string; age: string; }\n// Omit 유틸리티 타입은 지정된 속성을 무시합니다.\ntype TestFewer = Omit<Test, 'name'>; // typed as { age: string; }\ntype TestNone = Omit<Test, 'name' | 'age'>; // typed as {}\n// Parameters 유틸리티 타입은 함수 타입의 매개변수를 가져옵니다.\nfunction doSmth(value: string, anotherValue: number): string {\n  return 'test';\n}\ntype Params = Parameters<typeof doSmth>; // typed as [value: string, anotherValue: number]\n// ReturnType 유틸리티 타입은 함수 타입의 반환 타입을 가져옵니다.\ntype Return = ReturnType<typeof doSmth>; // typed as string\n\n// 이 외에도 많은 유틸리티 타입이 있으며, 그 중 일부는 아래에서 소개됩니다.\n```\n\n<div class=\"content-ad\"></div>\n\n- 조건부 타입: 어떤 타입이 다른 타입과 일치/확장되면 그에 따라 타입을 조건부로 설정합니다. 이는 JavaScript의 조건부(삼항) 연산자와 비슷하게 해석될 수 있습니다.\n\n```js\n// 배열인 경우에만 배열 타입을 추출하고, 그렇지 않으면 동일한 타입을 반환합니다.\ntype Flatten<T> = T extends any[] ? T[number] : T;\n\n// 요소 타입을 추출합니다.\ntype Str = Flatten<string[]>; // string 타입으로 지정됨\n\n// 타입을 그대로 유지합니다.\ntype Num = Flatten<number>; // number 타입으로 지정됨\n```\n\n- 조건부 타입으로 추론: 모든 일반 타입이 소비자에 의해 명시적으로 지정되어야 하는 것은 아닙니다. 일부는 코드로부터 추론될 수도 있습니다. 추론된 타입을 기반으로 조건부 논리를 작성하려면 infer 키워드가 필요합니다. 이는 일시적인 추론된 타입 변수를 정의하는 방식입니다.\n\n```js\n// 이전 예제를 기반으로 해서 더 깔끔하게 작성할 수 있습니다.\ntype FlattenOld<T> = T extends any[] ? T[number] : T;\n\n// 배열에서 직접 인덱싱하는 대신, 배열에서 항목(Item)의 타입을 추론할 수 있습니다.\ntype Flatten<T> = T extends (infer Item)[] ? Item : T;\n\n// 함수의 반환 타입을 가져오고, 그 외의 경우에는 undefined로 지정하는 타입을 작성할 수도 있습니다.\ntype GetReturnType<Type> = Type extends (...args: any[]) => infer Return ? Return : undefined;\n\ntype Num = GetReturnType<() => number>; // number 타입으로 지정됨\n\ntype Str = GetReturnType<(x: string) => string>; // string 타입으로 지정됨\n\ntype Bools = GetReturnType<(a: boolean, b: boolean) => void>; // undefined 타입으로 지정됨\n```\n\n<div class=\"content-ad\"></div>\n\n- 튜플 Optional Elements와 Rest: 튜플에서 `?`를 사용하여 옵셔널 요소를 선언하고, 다른 타입을 기반으로 나머지 요소를 사용할 수 있습니다.\n\n```js\n// 튜플의 길이를 아직 알 수 없지만 적어도 한 개는 있는 경우, `?`를 사용하여 옵셔널 타입을 지정할 수 있습니다.\nconst list: [number, number?, boolean?] = [];\nlist[0] // number 타입으로 지정됩니다\nlist[1] // number 또는 undefined 타입으로 지정됩니다\nlist[2] // boolean 또는 undefined 타입으로 지정됩니다\nlist[3] // Type error: 길이가 '3'인 '[number, (number | undefined)?, (boolean | undefined)?]' 형식의 튜플에는 '3' 인덱스 요소가 없습니다.\n\n// 기존 타입을 기반으로 튜플을 사용할 수도 있습니다.\n// 배열의 시작 부분에 패딩을 추가하려면 나머지 연산자 `...`를 사용할 수 있습니다.\nfunction padStart<T extends any[]>(arr: T, pad: string): [string, ...T] {\n  return [pad, ...arr];\n}\n\nconst padded = padStart([1, 2], 'test'); // [string, number, number] 타입으로 지정됩니다\n```\n\n- 추상 클래스와 메소드: 클래스와 그 내부 메소드를 추상으로 선언하여 인스턴스화되지 않도록 할 수 있습니다.\n\n```js\nabstract class Animal {\n  abstract makeSound(): void;\n\n  move(): void {\n    console.log('roaming the earth...');\n  }\n}\n\n// 추상 메소드는 확장 시 구현되어야 합니다.\nclass Cat extends Animal {} // 컴파일 오류: 추상 클래스 'Animal'로부터 상속된 추상 멤버 'makeSound'가 구현되지 않은 비-추상 클래스 'Cat'입니다.\n\nclass Dog extends Animal {\n  makeSound() {\n    console.log('woof');\n  }\n}\n\n// 추상 클래스는 (인터페이스처럼) 인스턴스화할 수 없으며, 추상 메소드는 호출할 수 없습니다.\nnew Animal(); // 컴파일 오류: 추상 클래스의 인스턴스를 생성할 수 없습니다.\n\nconst dog = new Dog().makeSound(); // \"woof\"가 출력됩니다\n```\n\n<div class=\"content-ad\"></div>\n\n- 생성자 서명: 클래스 선언 외부에서 생성자의 유형을 정의합니다. 대부분의 경우에 사용되지 않아야 하며, 추상 클래스 대신 사용할 수 있습니다.\n\n```js\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass AnotherTest {\n  age: number;\n}\n\nfunction makeObj(n: ConstructsMyInterface) {\n  return new n('hello!');\n}\n\nconst obj = makeObj(Test); // Test로 타입 지정됨\nconst anotherObj = makeObj(AnotherTest); // 타입 오류: 'AnotherTest'의 유형은 'ConstructsMyInterface'의 매개변수에 할당할 수 없습니다.\n```\n\n- ConstructorParameters 유틸리티 타입: TypeScript 도우미 함수로, 생성자 타입에서 생성자 매개변수를 가져옵니다 (클래스에서 가져오는 것이 아닙니다).\n\n```js\n// makeObj 함수에 생성자 인수를 얻고 싶다면?\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nfunction makeObj(test: ConstructsMyInterface, ...args: ConstructorParameters<ConstructsMyInterface>) {\n  return new test(...args);\n}\n\nmakeObj(Test); // 타입 오류: 2개의 매개변수가 필요하지만 1개만 전달되었습니다.\nconst obj = makeObj(Test, 'test'); // Test로 타입 지정됨\n```\n\n<div class=\"content-ad\"></div>\n\n## TypeScript 4.0\n\n- Variadic Tuple Types: 튜플에서의 나머지 요소는 이제 제네릭할 수 있습니다. 여러 개의 나머지 요소를 사용하는 것도 허용됩니다.\n\n```js\n// 만약 길이와 타입이 정의되지 않은 두 튜플을 결합하는 함수가 있다면 어떨까요? 반환 타입을 어떻게 정의할 수 있을까요?\n\n// 이전:\n// 우리는 몇 가지 오버로드를 작성할 수 있었습니다.\ndeclare function concat(arr1: [], arr2: []): [];\ndeclare function concat<A>(arr1: [A], arr2: []): [A];\ndeclare function concat<A, B>(arr1: [A], arr2: [B]): [A, B];\n// 이하 생략\n\n// 대신에 타입을 결합할 수 있습니다.\ndeclare function concatBetter<T, U>(arr1: T[], arr2: U[]): (T | U)[];\n// 그러나 이것은 (T | U)[]로 타입이 지정됩니다.\n\n// 새로운 기능:\n// 가변 길이 튜플 타입을 사용하면 쉽게 정의할 수 있고 길이 정보를 유지할 수 있습니다.\ndeclare function concatNew<T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U];\n\nconst tuple = concatNew([23, 'hey', false] as [number, string, boolean], [5, 99, 20] as [number, number, number]);\nconsole.log(tuple[0]); // 23\nconst element: number = tuple[1]; // 타입 오류: 타입 'string'을 'number'에 할당할 수 없습니다.\nconsole.log(tuple[6]); // 타입 오류: 길이 '6'인 튜플 타입 '[23, \"hey\", false, 5, 99, 20]'에는 인덱스 '6'에 요소가 없습니다.\n```\n\n- Labeled Tuple Elements: 튜플 요소는 이제 [start: number, end: number]와 같이 이름을 지정할 수 있습니다. 요소 중 하나가 이름이 지정되면 모두 이름이 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n혹시 클래스 생성자에서 속성이 설정될 때 속성의 타입을 자동으로 추론할 수 있어서 더 이상 수동으로 설정할 필요가 없습니다.\n\n```js\nclass Animal {\n  // 생성자에서 할당될 때 타입을 설정할 필요가 없습니다.\n  name;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name); // 문자열로 타입이 지정됨\n  }\n}\n```\n\n- JSDoc @deprecated 지원: JSDoc/TSDoc의 @deprecated 태그가 TypeScript에서 인식됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n/** @deprecated 메시지 */\ntype Test = string;\n\nconst test: Test = 'dfadsf'; // 타입 오류: '테스트'가 사용되지 않습니다.\n```\n\n## TypeScript 4.1\n\n- 템플릿 리터럴 타입: 리터럴 타입을 정의할 때, '$'를 이용하여 템플릿을 활용할 수 있습니다. 이를 통해 여러 개의 문자열 리터럴을 조합하는 등 복잡한 문자열 타입을 만들 수 있습니다.\n\n```js\ntype VerticalDirection = 'top' | 'bottom';\ntype HorizontalDirection = 'left' | 'right';\ntype Direction = `${VerticalDirection} ${HorizontalDirection}`;\n\nconst dir1: Direction = 'top left';\nconst dir2: Direction = 'left'; // 타입 오류: '\"left\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\nconst dir3: Direction = 'left top'; // 타입 오류: '\"left top\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\n\n// 이는 제네릭 및 새로운 유틸리티 타입과도 결합할 수 있습니다.\ndeclare function makeId<T extends string, U extends string>(first: T, second: U): `${Capitalize<T>}-${Lowercase<U>}`;\n```\n\n<div class=\"content-ad\"></div>\n\n- 키 다시 매핑하기: 매핑된 타입을 다시 정의하여 그 값들을 사용할 수 있습니다. [K in keyof T as NewKeyType]: T[K].\n\n```js\n// 예를 들어, 객체를 다시 포맷하되 그 ID 앞에 밑줄을 추가하고 싶다고 가정해 봅시다.\nconst obj = { value1: 0, value2: 1, value3: 3 };\nconst newObj: { [Property in keyof typeof obj as `_${Property}`]: number }; // { _value1: number; _value2: number; value3: number; }로 타입이 지정됩니다.\n```\n\n- 재귀 조건부 타입: 조건부 타입을 해당 정의 내부에서 사용합니다. 이를 통해 무한히 중첩된 값을 조건부적으로 언패킹하는 타입을 생성할 수 있습니다.\n\n```js\ntype Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;\n\ntype P1 = Awaited<string>; // string으로 타입이 지정됩니다.\ntype P2 = Awaited<Promise<string>>; // string으로 타입이 지정됩니다.\ntype P3 = Awaited<Promise<Promise<string>>>; // string으로 타입이 지정됩니다.\n```\n\n<div class=\"content-ad\"></div>\n\n- JSDOC @see 태그를 지원하는 편집기: 이제 편집기에서 JSDoc/TSDoc @see 변수/유형/링크 태그가 지원됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * 다른 값의 복사본\n * @see originalValue\n */\nconst value = originalValue;\n```\n\n- tsc --explainFiles: --explainFiles 옵션은 TypeScript CLI에서 컴파일에 사용된 파일과 그 이유를 설명해주는 데 사용될 수 있습니다. 이는 디버깅에 유용할 수 있습니다. 경고: 대규모 프로젝트나 복잡한 설정의 경우 많은 출력물이 생성됩니다. 대신 tsc --explainFiles | less 또는 비슷한 방법을 사용하십시오.\n\n```js\ntsc --explainFiles\n\n<<output\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es5.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n...\noutput\n```\n\n<div class=\"content-ad\"></div>\n\n- Destructured 변수는 명시적으로 사용되지 않음을 표시할 수 있습니다: 구조 분해할 때 밑줄을 사용하여 변수가 사용되지 않음을 표시할 수 있습니다. 이를 통해 TypeScript에서 \"사용되지 않는 변수\" 오류를 방지할 수 있습니다.\n\n```js\nconst [_first, second] = [3, 5];\nconsole.log(second);\n\n// 심지어 더 짧게\nconst [_, value] = [3, 5];\nconsole.log(value);\n```\n\n## TypeScript 4.3\n\n- 속성에 대한 별도의 쓰기 유형: set/get 접근자를 정의할 때, 쓰기/설정 형식이 읽기/가져오기 형식과 다를 수 있습니다. 이를 통해 동일한 값의 여러 형식을 수락하는 setter를 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass Test {\n  private _value: number;\n\n  get value(): number {\n    return this._value;\n  }\n\n  set value(value: number | string) {\n    if (typeof value === 'number') {\n      this._value = value;\n      return;\n    }\n    this._value = parseInt(value, 10);\n  }\n}\n```\n\n- override: 상속된 클래스 메서드를 명확하게 오버라이드로 표시하기 위해 override를 사용하세요. 부모 클래스가 변경되면 TypeScript에서 부모 메서드가 더 이상 존재하지 않음을 알려줄 수 있습니다. 이를 통해 더 안전한 복잡한 상속 패턴을 구현할 수 있습니다.\n\n```js\nclass Parent {\n  getName(): string {\n    return 'name';\n  }\n}\n\nclass NewParent {\n  getFirstName(): string {\n    return 'name';\n  }\n}\n\nclass Test extends Parent {\n  override getName(): string {\n    return 'test';\n  }\n}\n\nclass NewTest extends NewParent {\n  override getName(): string { // Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.\n    return 'test';\n  }\n}\n```\n\n- static Index Signatures: 클래스에서 정적 속성을 사용할 때, 정적 [propName: string]: string을 사용하여 색인 서명을 설정할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이전 코드:\nclass Test {}\n\nTest.test = ''; // 타입 오류: 'test' 속성을 'Test' 형식에서 찾을 수 없습니다.\n\n// 새로운 코드:\nclass NewTest {\n  static [key: string]: string;\n}\n\nNewTest.test = '';\n```\n\n- JSDOC @link 태그를 위한 편집기 지원: JSDoc/TSDoc의 '@link 변수/타입/링크' 인라인 태그가 이제 지원되며 편집기에서 표시되고 해결됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * {@link originalValue}의 복사본\n */\nconst value = originalValue;\n```\n\n## TypeScript 4.4\n\n<div class=\"content-ad\"></div>\n\n- 정확한 선택적 속성 유형 (--exactOptionalPropertyTypes): 컴파일러 플래그 --exactOptionalPropertyTypes (또는 tsconfig.json에)를 사용하면, 암시적으로 undefined를 허용하는 속성에 대해 undefined로 할당하는 것이 허용되지 않습니다 (예: property?: string). 대신, property: string | undefined와 같이 명시적으로 undefined를 허용해야 합니다.\n\n```js\nclass Test {\n  name?: string;\n  age: number | undefined;\n}\n\nconst test = new Test();\ntest.name = undefined; // 타입 오류: 'exactOptionalPropertyTypes: true'를 사용하여 'undefined' 타입을 'string'에 할당할 수 없습니다. 대상의 유형에 'undefined'를 추가하는 것을 고려해보세요.\ntest.age = undefined;\nconsole.log(test.age); // undefined\n```\n\n## TypeScript 4.5\n\n- Awaited`` 유형 및 Promise 개선: 새로운 Awaited`` 유틸리티 유형은 무한히 중첩된 Promises에서 값 유형을 추출합니다 (값에 대해 await이 하는 것과 같이). 이는 또한 Promise.all()에 대한 유형 추론을 개선했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 제네릭 대기값을 가지고 싶다고 가정해 봅시다.\n// 이러한 경우 Awaited 유틸리티 타입을 사용할 수 있습니다 (소스 코드는 이전 예제의 일부였습니다).\n// 따라서 무한하게 중첩된 Promises가 모두 값으로 해결됩니다.\ntype P1 = Awaited<string>; // 문자열로 타입 지정\ntype P2 = Awaited<Promise<string>>; // 문자열로 타입 지정\ntype P3 = Awaited<Promise<Promise<string>>>; // 문자열로 타입 지정\n```\n\n- Import 이름에 대한 유형 수식어: 일반 (import type 아닌) import 문 안에서 type 키워드를 사용하여 해당 값이 유형 컴파일을 위해만 가져와야 함을 신호로 삼을 수 있습니다 (컴파일 후에 제거할 수 있습니다).\n\n```js\n// 이전:\n// 유형을 가져오는 가장 좋은 방법은 `import type` 키워드를 사용하여 컴파일 이후에 실제로 가져오지 않도록 하는 것입니다.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// 이 파일에 대해 두 개의 import 문이 필요했습니다.\n\n// 새로운:\n// 이제 이를 하나의 문으로 결합할 수 있습니다.\nimport { something, type SomeType } from './file';\n```\n\n- Const 어순: 상수를 정의할 때 const 키워드를 사용하여 이를 리터럴 타입으로 정확하게 지정할 수 있습니다. 이는 다양한 용례가 있으며 정확한 유형 정의가 쉬워집니다. 또한 상수 객체와 배열은 읽기 전용이 되어 상수 객체의 변이를 방지합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이전:\nconst obj = { name: 'foo', value: 9, toggle: false }; // { name: string; value: number; toggle: boolean; }으로 타입 지정됨\n// 일반적으로 타입이 지정되어 있으므로 어느 값이든 할당 가능합니다.\nobj.name = 'bar';\n\nconst tuple = ['name', 4, true]; // (string | number | boolean)[]으로 타입 지정됨\n// 타입으로 길이와 정확한 형식을 결정할 수 없습니다. 어떤 값이든 어디에든 할당할 수 있습니다.\ntuple[0] = 0;\ntuple[3] = 0;\n\n// 새로운 방식:\nconst objNew = { name: 'foo', value: 9, toggle: false } as const; // { readonly name: \"foo\"; readonly value: 9; readonly toggle: false; }으로 타입 지정됨\n// 값을 할당할 수 없습니다 (\"foo\"(그리고 readonly로 정의되었기 때문).\nobjNew.name = 'bar'; // 타입 에러: 'name'에 할당할 수 없습니다. 읽기 전용 속성입니다.\n\nconst tupleNew = ['name', 4, true] as const; // readonly [\"name\", 4, true]으로 타입 지정됨\n// 이제 길이와 정확한 형식이 정의되어 있고, 값을 할당할 수 없습니다 (리터럴로 정의되었으며 readonly).\ntupleNew[0] = 0; // 타입 에러: '0'에 할당할 수 없습니다. 읽기 전용 속성입니다.\ntupleNew[3] = 0; // 타입 에러: 'readonly[\"name\", 4, true]'에 있는 인덱스 서명에는 읽기만 허용됩니다.\n```\n\n- 클래스 내의 메서드에 대한 코드 조각 완성: 클래스가 메서드 타입을 상속하면 편집기에서 코드 조각으로 제안됩니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:800/1*31No189vLt2Kdx5Ay_Ihig.gif\" />\n\n## TypeScript 4.6\n\n<div class=\"content-ad\"></div>\n\n- 인덱스된 액세스 추론 개선: 키로 직접 타입을 색인화할 때, 이제 같은 객체에 있는 경우 타입이 더 정확해집니다. 현대적인 TypeScript로 어떤 것이 가능한지 보여주는 좋은 예시입니다.\n\n```js\ninterface AllowedTypes {\n  'number': number;\n  'string': string;\n  'boolean': boolean;\n}\n\n// Record는 허용된 타입의 종류와 값 타입을 지정합니다.\ntype UnionRecord<AllowedKeys extends keyof AllowedTypes> = { [Key in AllowedKeys]:\n{\n  kind: Key;\n  value: AllowedTypes[Key];\n  logValue: (value: AllowedTypes[Key]) => void;\n}\n}[AllowedKeys];\n\n// 함수 logValue는 Record의 값만을 허용합니다.\nfunction processRecord<Key extends keyof AllowedTypes>(record: UnionRecord<Key>) {\n  record.logValue(record.value);\n}\n\nprocessRecord({\n  kind: 'string',\n  value: 'hello!',\n\n  // 값이 암묵적으로 string | number | boolean 타입을 가졌던 것이\n  // 이제 올바르게 오직 string으로 추론됩니다.\n  logValue: value => {\n    console.log(value.toUpperCase());\n  }\n});\n```\n\n- TypeScript 추적 분석기 (--generateTrace): --generateTrace '출력 폴더' 옵션을 사용하여 TypeScript CLI가 타입 검사 및 컴파일 프로세스에 대한 자세한 내용을 포함한 파일을 생성할 수 있습니다. 이는 복잡한 타입을 최적화하는 데 도움이 될 수 있습니다.\n\n```js\ntsc --generateTrace trace\n\ncat trace/trace.json\n<<출력\n[\n{\"name\":\"process_name\",\"args\":{\"name\":\"tsc\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"thread_name\",\"args\":{\"name\":\"Main\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"TracingStartedInBrowser\",\"cat\":\"disabled-by-default-devtools.timeline\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"program\",\"ts\":...,\"name\":\"createProgram\",\"args\":{\"configFilePath\":\"/...\",\"rootDir\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"E\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"X\",\"cat\":\"program\",\"ts\":...,\"name\":\"resolveModuleNamesWorker\",\"dur\":...,\"args\":{\"containingFileName\":\"/...\"},\n...\n출력\n\ncat trace/types.json\n<<출력\n[{\"id\":1,\"intrinsicName\":\"any\",\"recursionId\":0,\"flags\":[\"...\"]},\n{\"id\":2,\"intrinsicName\":\"any\",\"recursionId\":1,\"flags\":[\"...\"]},\n{\"id\":3,\"intrinsicName\":\"any\",\"recursionId\":2,\"flags\":[\"...\"]},\n{\"id\":4,\"intrinsicName\":\"error\",\"recursionId\":3,\"flags\":[\"...\"]},\n{\"id\":5,\"intrinsicName\":\"unresolved\",\"recursionId\":4,\"flags\":[\"...\"]},\n{\"id\":6,\"intrinsicName\":\"any\",\"recursionId\":5,\"flags\":[\"...\"]},\n{\"id\":7,\"intrinsicName\":\"intrinsic\",\"recursionId\":6,\"flags\":[\"...\"]},\n{\"id\":8,\"intrinsicName\":\"unknown\",\"recursionId\":7,\"flags\":[\"...\"]},\n{\"id\":9,\"intrinsicName\":\"unknown\",\"recursionId\":8,\"flags\":[\"...\"]},\n{\"id\":10,\"intrinsicName\":\"undefined\",\"recursionId\":9,\"flags\":[\"...\"]},\n{\"id\":11,\"intrinsicName\":\"undefined\",\"recursionId\":10,\"flags\":[\"...\"]},\n{\"id\":12,\"intrinsicName\":\"null\",\"recursionId\":11,\"flags\":[\"...\"]},\n{\"id\":13,\"intrinsicName\":\"string\",\"recursionId\":12,\"flags\":[\"...\"]},\n...\n출력\n```\n\n<div class=\"content-ad\"></div>\n\n## TypeScript 4.7\n\n- Node.js에서 ECMAScript 모듈 지원: CommonJS 대신 ES 모듈을 사용할 때, TypeScript가 이제 default를 지정할 수 있습니다. tsconfig.json에서 지정하세요.\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"module\": \"es2020\"\n]\n...\n```\n\n- package.json의 type: package.json의 type 필드를 \"module\"로 설정할 수 있습니다. 이것은 Node.js와 ES 모듈을 사용하기 위해 필요합니다. 대부분의 경우에 TypeScript에 충분하며 위의 컴파일러 옵션이 필요하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n\"type\": \"module\"\n...\n```\n\n- 인스턴스화 표현식: 인스턴스화 표현식을 사용하면 값을 참조할 때 유형 매개변수를 지정할 수 있습니다. 이를 통해 래퍼를 생성하지 않고 일반적인 유형을 좁힐 수 있습니다.\n\n```js\nclass List<T> {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nfunction makeList<T>(items: T[]): List<T> {\n  const list = new List<T>();\n  items.forEach(item => list.push(item));\n  return list;\n}\n\n// 특정 값만 허용하는 목록을 만드는 함수가 필요한 경우를 가정해 봅시다.\n// 이전:\n// 직접 래퍼 함수를 정의하고 인수를 전달해야 했습니다.\nfunction makeStringList(text: string[]) {\n  return makeList(text);\n}\n\n// 새로운 방법:\n// 인스턴스화 표현식을 사용하면 훨씬 쉽습니다.\nconst makeNumberList = makeList<number>;\n```\n\n- 추론된 유형 변수에 대한 extend 제한: 조건부 유형에서 유형 변수를 추론할 때, extends를 사용하여 직접 좁히거나 제한할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 배열의 첫 번째 요소가 문자열인 경우에만 해당 요소를 가져오는 유형을 작성하려고 한다고 가정해 봅시다.\n// 이를 위해 조건부 유형을 사용할 수 있습니다.\n\n// 이전:\ntype FirstIfStringOld<T> =\n  T extends [infer S, ...unknown[]]\n    ? S extends string ? S : never\n    : never;\n\n// 그러나 이 방법은 두 개의 중첩된 조건부 유형이 필요합니다. 이를 하나의 유형으로도 할 수 있습니다.\ntype FirstIfString<T> =\n  T extends [string, ...unknown[]]\n    // `T`에서 첫 번째 유형을 가져옵니다.\n    ? T[0]\n    : never;\n\n// 이것도 여전히 최적화되지 않은 상태이며 올바른 유형을 위해 배열을 인덱싱해야 합니다.\n\n// 새로운 방식:\n// 추론된 유형 변수에 extends 제약 조건을 사용하여 이를 더 간단하게 선언할 수 있습니다.\ntype FirstIfStringNew<T> =\n  T extends [infer S extends string, ...unknown[]]\n    ? S\n    : never;\n// 유형을 알아내는 방식은 이전과 동일하지만 더 깔끔한 구문입니다.\n\ntype A = FirstIfStringNew<[string, number, number]>; // string으로 유형 지정\ntype B = FirstIfStringNew<[\"hello\", number, number]>; // \"hello\"로 유형 지정\ntype C = FirstIfStringNew<[\"hello\" | \"world\", boolean]>; // \"hello\" 또는 \"world\"로 유형 지정\ntype D = FirstIfStringNew<[boolean, number, string]>; // never로 유형 지정\n```\n\n- 유형 매개변수를 위한 선택적 분산 주석: 제네릭은 \"일치하는지\" 확인할 때 다른 동작을 가질 수 있습니다. 예를 들어, 상속을 허용할 경우 getters 및 setters에 대해 반대로 반전됩니다. 이제 이를 명시적으로 지정할 수 있습니다.\n\n```js\n// 다른 인터페이스 / 클래스를 확장하는 인터페이스가 있다고 가정해 봅시다.\ninterface Animal {\n  animalStuff: any;\n}\n\ninterface Dog extends Animal {\n  dogStuff: any;\n}\n\n// 그리고 일반적인 \"getter\" 및 \"setter\"가 있습니다.\ntype Getter<T> = () => T;\n\ntype Setter<T> = (value: T) => void;\n\n// Getter<T1>과 Getter<T2> 또는 Setter<T1>과 Setter<T2>가 일치하는지 확인하려면 분산에 따라 달라집니다.\nfunction useAnimalGetter(getter: Getter<Animal>) {\n  getter();\n}\n\n// 이제 함수에 Getter를 전달할 수 있습니다.\nuseAnimalGetter((() => ({ animalStuff: 0 }) as Animal));\n// 당연히 작동합니다.\n\n// 그러나 Dog를 반환하는 Getter를 사용하려면 어떻게 해야 할까요?\nuseAnimalGetter((() => ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// 이 또한 작동합니다. 왜냐하면 Dog도 Animal이기 때문입니다.\n\nfunction useDogGetter(getter: Getter<Dog>) {\n  getter();\n}\n\n// useDogGetter 함수에 동일한 작업을 시도하면 동일한 동작을 얻지 못할 것입니다.\nuseDogGetter((() => ({ animalStuff: 0 }) as Animal); // Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.\n// 이는 Animal이 아닌 Dog가 필요하기 때문에 작동하지 않습니다.\n\nuseDogGetter((() => ({ animalStuff: 0, dogStuff: 0 }) as Dog);\n// 그러나 이 경우는 작동합니다.\n\n// 직관적으로 Setters가 같은 방식으로 작동할 것으로 기대할 수도 있지만, 사실은 그렇지 않습니다.\nfunction setAnimalSetter(setter: Setter<Animal>, value: Animal) {\n  setter(value);\n}\n\n// 동일한 유형의 Setter를 전달해도 작동합니다.\nsetAnimalSetter((value: Animal) => {}, { animalStuff: 0 });\n\nfunction setDogSetter(setter: Setter<Dog>, value: Dog) {\n  setter(value);\n}\n\n// 여기도 마찬가지로 작동합니다.\nsetDogSetter((value: Dog) => {}, { animalStuff: 0, dogStuff: 0 });\n\n// 그러나 Dog Setter를 setAnimalSetter 함수에 전달하면 Getter와는 반대로 동작이 반전됩니다.\nsetAnimalSetter((value: Dog) => {}, { animalStuff: 0, dogStuff: 0 }); // Type error: Argument of type '(value: Dog) => void' is not assignable to parameter of type 'Setter<Animal>'.\n\n// 이번에는 상황이 반대로 작동합니다.\nsetDogSetter((value: Animal) => {}, { animalStuff: 0, dogStuff: 0 });\n\n// 새로운 방법:\n// TypeScript에이를 표시하기 위해 (필수는 아니지만 가독성을 위해 유용), 유형 매개변수에 대한 선택적 분산 주석을 사용합니다.\ntype GetterNew<out T> = () => T;\ntype SetterNew<in T> = (value: T) => void;\n```\n\n- moduleSuffixes로 해상도 사용자 정의: 사용자 정의 파일 접미사를 사용하는 환경(예: 네이티브 앱 빌드에 .ios를 사용하는 경우)에서는 TypeScript가 가져오기를 정확하게 해석하도록 이 접미사를 tsconfig.json에 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"moduleSuffixes\": [\".ios\", \".native\", \"\"]\n]\n...\n```\n\n```js\nimport * as foo from './foo';\n// 이 코드는 먼저 ./foo.ios.ts를 확인하고, 그 다음에는 ./foo.native.ts를, 마지막으로 ./foo.ts를 확인합니다.\n```\n\n- 에디터에서 소스 정의로 이동: 에디터에서 새로운 \"소스 정의로 이동\" 메뉴 옵션이 사용 가능합니다. 이는 \"정의로 이동\"과 유사하지만, .ts 및 .js 파일을 .d.ts 타입 정의 파일보다 우선합니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:800/1*y45nF8mb-nfBuVIUPt7KJQ.gif\" />\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*qvzGqfF844cXCPMeDrg_IQ.gif)\n\n## TypeScript 4.9\n\n- `satisfies` 연산자: `satisfies` 연산자는 실제로 그 타입을 할당하지 않고도 타입과의 호환성을 확인할 수 있게 해줍니다. 이를 통해 더 정확한 추론된 타입을 유지하면서도 호환성을 유지할 수 있습니다.\n\n```js\n// 이전:\n// 여러 항목과 그 색상을 저장하는 객체/맵/딕셔너리가 있다고 가정해 보겠습니다.\nconst obj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // { fireTruck: number[]; bush: string; ocean: number[]; } 타입으로 정의됨\n\n// 배열과 문자열에 대해 작업을 수행할 수 있도록 속성을 암시적으로 타입 지정합니다.\nconst rgb1 = obj.fireTruck[0]; // 숫자로 타입 지정\nconst hex = obj.bush; // 문자열로 타입 지정\n\n// 특정 객체만 허용하고 싶다면 Record 타입을 사용할 수 있습니다.\nconst oldObj: Record<string, [number, number, number] | string> = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // Record<string, [number, number, number] | string> 타입으로 정의됨\n// 하지만 이제 우리는 속성의 타입에 대한 정보를 잃어버립니다.\nconst oldRgb1 = oldObj.fireTruck[0]; // string 또는 number로 타입 지정\nconst oldHex = oldObj.bush; // string 또는 number로 타입 지정\n\n// 새롭게:\n// `satisfies` 키워드를 사용하여 타입과 호환성을 확인할 수 있습니다.\nconst newObj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} satisfies Record<string, [number, number, number] | string> // { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; } 타입으로 정의됨\n// 이제 속성의 타입에 대한 정보를 유지할 수 있을 뿐만 아니라 배열은 튜플로 더 정확해집니다.\nconst newRgb1 = newObj.fireTruck[0]; // 숫자로 타입 지정\nconst newRgb4 = newObj.fireTruck[3]; // 타입 오류: 길이가 '3'인 튜플 타입 '[number, number, number]'에는 인덱스 '3'에 해당하는 요소가 없습니다.\nconst newHex = newObj.bush; // 문자열로 타입 지정\n```\n\n<div class=\"content-ad\"></div>\n\n- 편집기의 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령: 편집기에서 새로운 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령(및 자동 수정)을 사용하면 Imports를 관리하는 것이 더 쉬워집니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*z5SG6BKwzyxrG6sG7OKciw.gif)\n\n## TypeScript 5.0\n\n- ES 데코레이터 지원: TypeScript는 이제 ES 데코레이터(곧 나올 ES 기능)를 지원하며, 기존 데코레이터와는 다릅니다. 이전에 TypeScript는 데코레이터에 대해 실험적인 지원을 했었는데, 이는 Angular와 같은 프레임워크에서 사용되는 것으로, --experimentalDecorators 플래그(또는 tsconfig.json에서)로 선택할 수 있었으며 약간 다르게 동작했습니다. 그러나 이제 새로운 ES 데코레이터는 이전 것과는 다르게 메타데이터를 내보내지 못하며 아직은 매개변수에서도 지원되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 주의: 2023년 5월 기준으로 이것은 예정된 ES 기능이므로 이 코드는 아직 작동하지 않습니다.\n\n// 디버깅 중에 메서드에 진입하거나 나갈 때마다 기록하려고 합니다.\n// 이것을 수동으로 하는 것은 상당히 지루할 수 있습니다. 자동화할 방법이 있을까요?\n// 네, 데코레이터를 사용하여 실행 컨텍스트를 대체할 수 있습니다.\n\n// 먼저 데코레이터 역할을 할 함수를 정의합니다. 이 함수는 원본 메서드와 컨텍스트 개체를 매개변수로 받아 새로운 실행 함수를 반환합니다.\nfunction logMethod<This, Args extends any[], Return>(originalMethod: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext) {\n  const methodName = String(context.name);\n\n  function replacementFunction(this: This, ...args: Args) {\n    console.log(`LOG: 메서드 '${methodName}' 진입 중.`)\n    const result = originalMethod.call(this, ...args);\n    console.log(`LOG: 메서드 '${methodName}' 나감.`)\n    return result;\n  }\n\n  return replacementFunction;\n}\n\n// 이제 이를 사용할 클래스를 정의합니다. 데코레이터는 클래스와 그 멤버에만 작동합니다.\n// 메서드에 '@'와 함수명을 사용하여 데코레이터를 적용합니다.\nclass Test {\n  @logMethod\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testObj = new Test();\n\n// 메서드를 실행하면 대체 메서드가 호출됩니다.\nconsole.log(testObj.doSomething()); // \"LOG: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"LOG: 메서드 'doSomething' 나감.\"\n\n// 사용자 정의 메시지와 같은 추가 인수를 전달하려면 데코레이터 팩토리(데코레이터 함수를 반환하는 함수)를 정의할 수 있습니다.\nfunction logMethodCustom(customMessage: string) {\n  return <This, Args extends any[], Return>(originalMethod: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext) => {\n    const methodName = String(context.name);\n\n    function replacementFunction(this: This, ...args: Args) {\n      console.log(`${customMessage}: 메서드 '${methodName}' 진입 중.`)\n      const result = originalMethod.call(this, ...args);\n      console.log(`${customMessage}: 메서드 '${methodName}' 나감.`)\n      return result;\n    }\n\n    return replacementFunction;\n  }\n}\n\n// 이번에는 함수 호출을 포함하는 `()`로 된 추가 인수를 사용하여 메서드에 데코레이터를 적용합니다.\nclass TestCustom {\n  @logMethodCustom('테스트 로그')\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testCustomObj = new Test();\n\n// 메서드 실행시 모든 작업이 예상대로 작동합니다.\nconsole.log(testCustomObj.doSomething()); // \"테스트 로그: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"테스트 로그: 메서드 'doSomething' 나감.\"\n\n// 데코레이터 함수에서 대체 메서드를 반환하지 않으면 원본 메서드가 호출되지만 관련 설정을 아직 설정할 수 있습니다.\n// 예를 들어 `constructor` 단계 이전에 `this`를 바인딩하여 클래스 외부에서 콜백으로 전달할 경우 동일하게 실행되도록합니다.\n// `constructor` 단계 이전에 코드를 실행하려면 컨텍스트 개체의 `addInitializer` 메서드를 사용할 수 있습니다.\nfunction bindThis(_: unknown, context: ClassMethodDecoratorContext) {\nconst methodName = context.name;\nif (context.private) {\n  throw new Error(`'bound'는 ${methodName as string}과 같은 비공개 속성을 데코레이션할 수 없습니다.`);\n}\ncontext.addInitializer(function (this: any) {\n  const methodName = context.name;\n    if (typeof methodName === 'string') {\n      this[methodName] = this[methodName].bind(this);\n    }\n  });\n}\n\n// 바인딩하지 않은 상태로 한번 정의합니다.\nclass TestUnbound {\n  private returnVal = '작업 중';\n\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testUnboundObj = new TestUnbound();\n\n// 메서드에 다시 \"데코레이터\"를 적용합니다.\nclass TestBound {\n  private returnVal = '작업 중';\n\n  @bindThis\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testBoundObj = new TestBound();\n\n// 클래스 컨텍스트 외부에 메서드를 저장하고 실행시키면 속성 값에 액세스할 수 없습니다.\nconst unboundFunc = testUnboundObj.doSomething;\nconsole.log(unboundFunc()); // 오류: \"Cannot read properties of undefined (reading 'returnVal')\"\n\n// 그러나 바인딩하면 예상대로 작동합니다.\nconst boundFunc = testBoundObj.doSomething;\nconsole.log(boundFunc()); // \"작업 중\"\n```\n\n- const 형식 매개변수: 형식 매개변수 앞에 const를 지정하는 const는 readonly 형식을 그대로 사용하는 것처럼 동작하도록 시도합니다. 그러나 변경 가능한 값을 형식화했다면 인자유추가 작동하지 않을 수 있습니다(왜냐하면 읽기전용 형식은 변경 가능한 형식에 할당할 수 없기 때문에 항상 readonly 형식을 상속해야 합니다). 이것은 여전히 허용된 매개변수를 제한하지 않습니다. 여전히 extends 내에서 제한해야 합니다.\n\n- 타입을 활용한 여러 구성 파일 지원: 복잡한 상속 구조를 만들거나 모든 \"tsconfig\"에서 항상 동일한 구성을 확장하거나 모든 설정을 복사하여 모두 복사하는 대신, \"tsconfig\" 파일에서 \"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"]를 지정함으로써 여러 파일을 확장하여 동작을 재정의할 수 있습니다. 후자의 파일이 오버라이드 동작을 우선시합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n// 여기서 \"tsconfig1.json\"은 \"@tsconfig/strictest/tsconfig.json\"을 덮어씁니다. \"tsconfig2.json\"은 \"tsconfig1.json\"과 \"@tsconfig/strictest/tsconfig.json\"을 덮어쓰며, 이 파일은 모두 덮어씁니다.\n\"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"./tsconfig1.json\", \"./tsconfig2.json\"],\n...\n```\n\n- 모든 열거형이 합집합 열거형입니다: 동적으로 할당된 열거형 값은 이제 더 이상 예전의 열거형 전략 기본값을 갖지 않습니다(열거형 키에 대한 타입 없음, 값으로만 사용 가능하며 타입으로 사용할 수 없음). 대신 이제 타입으로도 사용할 수 있습니다.\n\n```js\n// 열거형은 각 값마다 다른 타입을 만듭니다.\nenum Color {\n  Red, Green, Blue, Orange, Yellow, Violet\n}\n\n// 이를 통해 그들을 좁히고 다른 타입처럼 사용할 수 있습니다.\ntype PrimaryColor = Color.Red | Color.Green | Color.Blue;\n\n// 하지만:\n// 값이 동적으로 할당되면 고정된 값이 없습니다.\n// 이전에는 예전 열거형 동작으로 되돌아가게 되었습니다.\n// 예전 열거형 동작에서 그 멤버는 값으로만 존재하며 타입으로는 존재하지 않음.\nenum ColorRandom {\n  Red = Math.random(),\n  Green = Math.random(),\n  Blue = Math.random(),\n  Orange = Math.random(),\n  Yellow = Math.random(),\n  Violet = Math.random()\n}\n\n// 그래서 이전에는 좁혀지지 못했습니다.\ntype PrimaryColorRandom = ColorRandom.Red | ColorRandom.Green | ColorRandom.Blue; // 이전 타입 오류: Enum 타입 'ColorRandom'은 리터럴이 아닌 초기화 값을 갖는 멤버를 가지고 있습니다.\n// 하지만 이제 그들에게도 자체 타입이 있기 때문에 작동합니다.\n```\n\n- --moduleResolution bundler: TS 4.7의 모듈 해결 전략 \"node16\"은 ES 모듈을 더 잘 모델링할 수 있게 해주지만 일부 불필요한 제약이 있었습니다(파일 확장자를 명시해야 했으며, ...). 번들러를 사용 중이라면, 새 전략은 최신 기능을 유지하면서 일부 제약을 제거하려고 시도합니다. 컴파일러 플래그 --moduleResolution bundle를 지정하여 사용할 수 있습니다(또는 tsconfig.json에서). 번들러를 사용할 때만 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"moduleResolution\": \"bundler\"\n]\n...\n```\n\n```json\nimport * as foo from './foo';\n// 이제는 파일 확장자가 지정되지 않아도 다시 허용됩니다.\n```\n\n- 해상도 Customization Flags: \"hybrid\" 모듈 해상도에 대한 규칙을 설정합니다. 규칙은 다음과 같습니다: allowImportingTsExtensions, resolvePackageJsonExports (imports를 위해 package.json exports을 고려함), resolvePackageJsonImports (#로 시작하는 경로를 위해 로컬 package.json을 참조함), allowArbitraryExtensions 및 customConditions (node16 및 bundler 전용, package.json에서 조건부 exports 및 imports을 위해 사용됨)입니다. 이러한 모든 설정은 --를 접두사로 하여 컴파일러 플래그로 지정하거나 tsconfig.json에 지정할 수 있습니다.\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"allowImportingTsExtensions\": false,\n  \"resolvePackageJsonExports\": true,\n  \"resolvePackageJsonImports\": true,\n  \"allowArbitraryExtensions\": false,\n  \"customConditions\": [\"my-condition\"]\n  // 이제는 `package.json`의 `exports` 및 `imports`에 대한 사용자 정의 조건을 해결하려고 시도합니다.\n  // TS는 그런 다음 해당 사용자 정의 조건에 맞도록 파일을 매칭하려고 할 것입니다 (이 경우 `foo.mjs`).\n]\n...\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  ...\n  \"exports\": {\n    \".\": {\n      \"my-condition\": \"./foo.mjs\",\n      \"node\": \"./bar.mjs\",\n      \"import\": \"./baz.mjs\",\n      \"require\": \"./biz.mjs\"\n    }\n  }\n}\n```\n\n- **--verbatimModuleSyntax:** 자동으로 import (import elision) 및 exports를 제거하지 않도록 TypeScript를 중지합니다. 이것은 import side effects가 사용될 때 또는 TS가 import가 어디에서 사용되는지 인식하지 못할 때 유용할 수 있습니다. import type 및 export type 문은 여전히 최종 컴파일에서 제거됩니다. 대개 import가 타입인지 아닌지 명시하는 것이 권장됩니다. compiler flag --verbatimModuleSyntax(또는 tsconfig.json에서)를 지정하여 사용할 수 있습니다.\n\n```js\n// `verbatimModuleSyntax`가 설정되지 않으면 이 import는 최종 컴파일에서 제거될 것입니다.\nimport { Car } from './car';\n// 이 import는 아무 경우에나 제거될 것입니다.\nimport type { Car } from './car';\n// 이 import는 절대로 제거되지 않습니다.\nimport { logCar } from './car';\n\nexport function drive(car: Car) {\n  logCar(car);\n  // ...\n}\n```\n\n- **export type * 지원:** 기본 형식을 하위 모듈로 쉽게 다시 내보낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 기본 타입들을 다른 모듈로서 서브모듈로 내보냅니다.\nexport type * as am from 'another-module';\n// 또는 다시 기본 내보낸 것으로 제공합니다.\nexport type * from 'another-module';\n```\n\n```js\nimport type { am } from 'module';\n// 또는\nimport type { } from 'module';\n```\n\n- --build 하위에서 Emit-Specific 플래그 전달: 빌드에 대한 동작을 지정하는 플래그들 (--build를 사용할 때). 이들은 --declaration, --emitDeclarationOnly, --declarationMap, --sourceMap 및 --inlineSourceMap를 포함합니다. 모두 이제 컴파일러 플래그로 지정할 수 있습니다. 이전에는 tsconfig.json에서만 설정할 수 있었어요.\n\n```js\n# 이것은 `tsconfig.json`에서 비활성화되어 있더라도 타입 선언을 생성합니다.\ntsc --build --declaration\n```\n\n<div class=\"content-ad\"></div>\n\n- 에디터에서 대소문자 구분 없는 import 정렬: 에디터에서 import를 정렬할 때 대소문자 구분 동작을 변경하세요. 이 기능은 VSCode의 JSON 설정 내 typescript.unstable 아래에서 활성화하고 구성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1032/1*Fei6JPgYzIgnl_IMekhOQg.gif)\n\n- Exhaustive switch/case 자동 완성: 에디터에서 이제 리터럴 타입의 case 문을 자동으로 완성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:656/1*e9FNtf4-kxU787rEl1w9lQ.gif)","ogImage":{"url":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png"},"coverImage":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png","tag":["Tech"],"readingTime":53},{"title":"Nodejs에서 CRON 작업으로 일정 관리하기","description":"","date":"2024-05-27 18:09","slug":"2024-05-27-SchedulingTaskswithCRONJobsinNodejs","content":"\n\nCRON 작업은 특정 간격으로 실행되는 작업을 예약하는 강력한 방법입니다. 이는 뉴스레터를 보내거나 정기 백업을 수행하거나 오래된 데이터를 정리하는 등 다양한 애플리케이션에 매우 유용합니다.\n\n예: 매주 월요일에 세일 소식을 기존 사용자에게 이메일로 보내고 싶다면, CRON이 그 역할을 수행해줄 것입니다.\n\n이것들은 OS에서 실행되는 주기적인 작업이며, 주어진 간격에 대해 OS에 명령을 내리고 특정 작업을 실행할 수 있습니다.\n\n이 블로그에서는 Node.js에서 CRON 작업을 설정하고 관리하는 방법을 알아볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\nCRON 작업을 왜 사용해야 하나요?\n\nCRON 작업은 다음과 같은 용도로 사용됩니다:\n\n- 백업하기: 정기적으로 데이터베이스나 파일을 백업합니다.\n- 로깅: 주기적으로 로그를 생성하고 저장합니다.\n- 통지: 이메일이나 푸시 알림을 사용자에게 보냅니다.\n- 정리: 데이터베이스에서 오래된 파일이나 레코드를 제거합니다.\n\nCRON 작업을 시작하려면, CRON 작업에 대한 좋은 지식이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n- Node.js\n- Npm\n\nNode.js에서 CRON 작업을 생성하는 방법\n\n1. Node.js 프로젝트 생성하기\n\n새로운 Node.js 프로젝트를 초기화하거나 기존 프로젝트를 사용하세요\n\n<div class=\"content-ad\"></div>\n\n2. 패키지 설치\n\n사용할 패키지는 \"node-cron\" 입니다.\n아래 명령을 실행하여 패키지를 설치하세요.\n\n```js\nnpm install node-cron\n```\n\n3. 서버용 express 패키지 설치\n\n<div class=\"content-ad\"></div>\n\n익스프레스 패키지를 설치하여 서버를 실행하거나 따르고자 하는 다른 방법을 사용할 수 있어요.\n\n지금은 익스프레스를 사용해보겠습니다.\n\n```js\nnpm install express \n```\n\n4. 크론 작업 작성하기\n\n<div class=\"content-ad\"></div>\n\n일정에 따라 실행되는 함수를 생성해보겠습니다. 이 예제에서는 콘솔에 메시지를 기록할 것입니다:\n\n```js\nfunction logMessage() {\n    console.log('작업이 실행됨:', new Date().toLocaleString());\n}\n```\n\n이제 함수를 만들었으니 주기적으로 실행해봅시다.\n\nCRON 작업의 문법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ncron.schedule(\"* * * * *\", function() {\n    // Task\n});\n```\n\n별표에 대해 이해해 봅시다.\n\n이제 각 별표가 무언가를 정의합니다.\n\n예를 들어 ( * * * * * * )\n\n\n<div class=\"content-ad\"></div>\n\n아래 표는 왼쪽부터 두 번째, 분, 시간, 월 별일, 월, 및 주를 나타냅니다.\n\n- 초 — 선택사항\n- 분: 0–59\n- 시간: 0–23\n- 월 별일: 1–31\n- 월: 1–12\n- 요일: 0–7 (0과 7은 모두 일요일을 나타냅니다)\n\n예시 :\n\n- ( * * * * * ) — 매 분 실행\n- ( 0 * * * * ) — 매 시간 실행\n- ( 0 15 15 * * ) — 매달 15일 오후 3시에 실행\n- ( * * 5 * * ) — 매월 5일에 실행\n\n<div class=\"content-ad\"></div>\n\n위의 내용을 한국어로 번역해 드리겠습니다. 친근한 어조로 작성되었습니다.\n\n```js\n// 일반적인 임포트\nconst cron = require(\"node-cron\");\nconst express = require(\"express\");\n\n// 익스프레스 초기화\napp = express();\n\n// 당신이 만든 함수\nfunction message() {\n    console.log('작업이 실행됨:', new Date().toLocaleString());\n}\n\n// cron 스케줄\ncron.schedule(\"* * * * *\", function() {\n    message();\n});\n\napp.listen(3000);\n```\n\n위 스크립트를 'script.js'로 저장하세요.\n\n5. 스크립트를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n노드.js 애플리케이션을 시작하세요\n\n```js\nnode script.js\n```\n\n파일 이름에 맞게 파일 이름을 변경해주세요\n\n이렇게 하면 코드가 실행되고 함수가 주어진 간격대로 작동할 것입니다\n\n<div class=\"content-ad\"></div>\n\n약간의 예시\n\n다음은 CRON 작업의 몇 가지 더 예시입니다:\n\n- 자정에 매일 정리\n\n```js\ncron.schedule('0 0 * * *', () => {\n    console.log('자정에 작업을 실행중입니다');\n    // 여기에 정리 코드를 추가하세요\n});\n```\n\n<div class=\"content-ad\"></div>\n\n- 매주 월요일에 보고서 생성\n\n```js\ncron.schedule('0 9 * * 1', () => {\n    console.log('주간 보고서 생성 중');\n    // 보고서 생성 코드를 여기에 추가\n});\n```\n\n일부 최상의 사례\n\n- 에러 처리: CRON 작업에 적절한 에러 처리가 있어 예기치 않은 실패를 피할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncron.schedule('0 0 * * *', () => {\n    try {\n        // 작업 내용\n    } catch (err) {\n        console.error('CRON 작업 중 오류가 발생했습니다:', err);\n    }\n});\n```\n\n- Logging: 작업이 실행되는 시간과 결과를 추적하기 위해 로깅 구현 필요\n\n가능한 함정\n\n- 시간대 문제: CRON 작업은 서버의 시간대에 따라 실행됩니다. 애플리케이션이 전 세계 사용자를 대상으로 하는 경우 시간대 차이에 유의해야 합니다.\n- 동시성: 작업이 CRON 간격보다 오래 걸릴 경우, 작업이 예기치 않게 겹쳐지지 않도록 주의해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n다음 절차를 따라서, Node.js 애플리케이션에서 CRON 작업을 효과적으로 활용하여 간단한 로깅부터 복잡한 데이터 처리까지 다양한 작업을 자동화할 수 있습니다.\n\n코딩해요!","ogImage":{"url":"/assets/img/2024-05-27-SchedulingTaskswithCRONJobsinNodejs_0.png"},"coverImage":"/assets/img/2024-05-27-SchedulingTaskswithCRONJobsinNodejs_0.png","tag":["Tech"],"readingTime":4},{"title":"React Hooks useState, useEffect를 제대로 사용하는 방법","description":"","date":"2024-05-20 23:26","slug":"2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect","content":"\n\n<img src=\"/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png\" />\n\n개발자로서, 우리는 종종 useState와 useEffect의 힘을 활용하여 애플리케이션에 생명을 불어넣는 황홀한 모험을 떠납니다. 그러나 흥분 속에, 조심하지 않는 이들을 덫에 걸릴 위험한 함정이 숨어 있습니다.\n\n걱정하지 마세요. 이 안내서에서는 이 위험한 영역을 통과하기 위한 코스를 제시하여 안전하게 항해할 수 있는 지식과 도구를 갖춰 드립니다. 함께 useState와 useEffect의 신비를 해독하고 모험을 떠나 봅시다! 🌟\n\n# useState\n\n<div class=\"content-ad\"></div>\n\n```js\nconst [state, setState] = useState(initialState);\n```\n\n- 상태와 상태를 변경하는 함수를 반환합니다.\n- 초기 렌더링 중에 반환된 상태(state)는 첫 번째 인수로 전달된 값(initialState)과 동일합니다.\n- setState 함수는 상태를 업데이트하는 데 사용됩니다. 새 상태 값을 받아 구성 요소의 다시 렌더링을 대기열에 넣습니다.\n\n## 상태 업데이트\n\nsetState 메서드를 통해 상태를 업데이트할 수 있습니다. 예를 들어:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst [count, setCount] = useState(0);\n\nfunction handleOnClick(){\n  setCount(prevCount => prevCount + 1)\n  setCount(prevCount => prevCount + 1)\n  setCount(prevCount => prevCount + 1)\n}\n\nreturn (\n    <div>\n        <div>\n            count: {count}\n        </div>\n        <button onClick={handleOnClick}>\n            +1\n        </button>\n    </div>\n);\n```\n\n버튼을 클릭할 때 setCount(count + 1)을 세 번 연속 호출하면 인터페이스에 표시된 카운트 값이 +3이 아니라 +1씩만 증가하는 것을 알 수 있어요. 🔄\n\n## 함수형 업데이트\n\n새 상태를 이전 상태를 사용하여 계산해야 할 경우 setState에 함수를 전달할 수 있어요. 이 함수는 이전 상태를 받고 업데이트된 값을 반환할 거예요.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nsetCount(count => count + 1);\nsetCount(count => count + 1);\nsetCount(count => count + 1);\n```\n\n## 객체 업데이트\n\nuseState의 값이 객체일 때, 뷰가 업데이트되지 않는 상황이 발생할 수 있습니다. 예를 들어:\n\n```js\nconst [list, setList] = useState([0, 1, 2]);\nconst [userInfo, setUserInfo] = useState({\n  name: 'Bob',\n  age: 20\n});\n\nfunction handleOnClick(){\n  list.push(4);\n  list.push(4);\n  setList([...list]);\n\n  userInfo.name = 'Jack';\n  userInfo.age = 30;\n  setUserInfo({...userInfo});\n}\n\nreturn (\n    <div>\n        <p>Name：{userInfo.name}</p>\n        <p>Age：{userInfo.age}</p>\n        <p>list.length: {list.length}</p>\n        <button onClick={handleOnClick}>\n            Edit\n        </button>\n    </div>\n);\n```\n\n<div class=\"content-ad\"></div>\n\n문제의 원인: 문제는 React의 기본 얕은 비교 메커니즘에서 발생합니다. 상태가 객체인 경우 React는 객체의 참조(주소)를 스택에 저장합니다. setState를 호출하면 힙에있는 데이터가 수정되지만 스택의 참조는 변경되지 않습니다. React의 얕은 비교는 참조가 변경되었는지 확인하고, 그렇지 않으면 상태가 변경되지 않았다고 가정하고 페이지를 다시 렌더링하지 않습니다. 🔄\n\n해결책: 단순히 원본 객체의 주소를 변경하면 이를 다음과 같은 방법으로 달성할 수 있습니다.\n\n- 원본 객체를 복제합니다.\n- ES6 전개 연산자를 사용합니다.\n\n배열의 경우 배열의 자체 메서드 중 일부를 사용하여 깊은 복사를 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// Array.slice\nconst nextList = list.slice(0);\nnextList.push(\"slice\");\nsetList(nextList);\n\n// Array.concat\nconst nextList = list.concat();\nnextList.push(\"concat\");\nsetList(nextList);\n```\n\n요약: useState에서나 함수로 전달된 매개변수에서, 객체 자체를 직접 조작하지 말아야 합니다. 먼저 복사본을 만들고 그 복사본을 조작하여 예상치 못한 문제가 발생하는 것을 피하세요.\n\n## setState 이후 최신 값 가져올 수 없음\n\nsetState는 즉시 업데이트되지 않기 때문에, React는 업데이트 전 어느 시점에서 여러 setState 호출을 병합합니다. 따라서 setState 이후 최신 값을 가져오는 것은 어려울 수 있습니다. 다음은 몇 가지 접근 방법입니다:\n\n<div class=\"content-ad\"></div>\n\n1. useRef를 사용해보세요: 이 방법은 useState의 값을 저장하지만 화면 업데이트를 트리거하지 않습니다.\n\n2. useEffect를 활용하세요: 효과적이지만 항상 적합한 방법은 아닙니다. 왜냐하면 이 방법은 모든 업데이트마다 내용을 실행하기 때문에 특정 요구에 부합하지 않을 수 있습니다.\n\n3. 함수 업데이트를 사용하세요.\n\n4. [useGetstate 훅 사용 원칙]: 최신 상태에 안전하게 액세스할 수 있는 hand를 제공하기 위해 useState값을 저장하는 useRef를 활용하세요. 🔄\n\n```js\nconst [count, setCount] = useState(0);\nconst countRef = useRef(0);\n\nuseEffect(()=>{\n  console.log(\"useEffect\", count);\n},[count]);\n\nfunction handleOnClick(){\n  countRef.current += 1;\n  setCount(count + 1);\n  setCount((count) => {\n    return count;\n  });\n}\n\nreturn (\n    <div>\n        <div>\n            count: {count}\n        </div>\n        <button onClick={handleOnClick}>\n            +1\n        </button>\n    </div>\n);\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nconst useGetState = (initiateState) => {\n  const [state, setState] = useState(initiateState);\n  const stateRef = useRef(state);\n  stateRef.current = state;\n\n  const getState = useCallback(() => stateRef.current, []);\n\n  return [state, setState, getState];\n};\n```\n\n## 타이머에서 최신 값을 가져오기\n\n다음 예제에서는 뷰나 출력과 관계없이 count의 값은 항상 0입니다.\n\n```js\nconst [count, setCount] = useState(0);\nuseEffect(()=>{\n  const interval = setInterval(() => {\n    setCount(count + 1);\n  },1000);\n  return () => {\n    clearInterval(interval);\n  }\n},[]);\n```\n\n<div class=\"content-ad\"></div>\n\n문제의 원인: 타이머가 생성된 후에 정리되지 않아 내부 상태가 항상 초기값을 반영하게 되었습니다.\n\n해결책:\n\n1️⃣ 타이머는 최신 상태를 캡처하기 위해 함수 업데이트를 사용하여 내부적으로 상태를 업데이트해야 합니다. 이렇게 하면 화면 업데이트 문제가 해결되지만 타이머는 여전히 0을 출력합니다.\n\n2️⃣ useEffect에서 상태를 종속성으로 활용합니다. 이를 통해 상태 변경 후에 타이머가 다시 생성되어 문제가 해결됩니다. 🔄\n\n<div class=\"content-ad\"></div>\n\n# useEffect\n\ncomponentDidMount와는 달리, useEffect 훅에 전달된 함수는 브라우저가 레이아웃 및 그리기를 완료한 후 지연 이벤트로 호출됩니다. 🎨 이 특성은 구독 설정 및 이벤트 처리와 같은 여러 일반 부작용 시나리오에 적합하게 만듭니다. 🔄 이러한 작업은 일반적으로 브라우저의 화면 업데이트를 차단해서는 안됩니다.\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nfunction Example(){\n  const [count, setCount] = useState(0);\n\n  useEffect(()=>{\n    document.title = `You clicked &{count} times`;\n  });\n\n    return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\nuseEffect는 첫 번째 렌더링 및 모든 업데이트를 포함한 모든 렌더링 후에 실행됩니다. React는 효과가 실행될 때마다 DOM이 업데이트된 것을 보장합니다. 🔄✨\n\n<div class=\"content-ad\"></div>\n\n다음은 `useEffect`를 언제 실행할지 결정하는 두 번째 매개변수에 대한 설명입니다.\n\n```js\nimport { useState, useEffect } from \"react\";\n\nexport default () => {\n   const [count, setCount] = useState(0);\n   const [number, setNumber] = useState(0);\n\n   // 의존성이 없는 경우, 매번 다시 렌더링될 때마다 실행됩니다.\n   useEffect(() => {\n     console.log(\"null\", count);\n   });\n\n   // 의존성 값이 비어 있으며, 처음 렌더링 후 한 번만 실행됩니다.\n   useEffect(() => {\n     console.log(\"[]\", count);\n   }, []);\n\n   // 의존성 값이 변경될 때만 실행되며, 첫 렌더링 시에도 실행됩니다.\n   useEffect(() => {\n     console.log(\"count\", count);\n   }, [count]);\n\n    function addCount() {\n    setCount(count + 1);\n    }\n  \n    function addNumber() {\n      setNumber(number + 1);\n    }\n  \n    return (\n      <div>\n        <div>count: {count}</div>\n        <div>number: {number}</div>\n        <button onClick={addCount}>count+1</button>\n        <button onClick={addNumber}>number+1</button>\n      </div>\n    );\n}\n```\n\n## 의존성 값이 객체인 경우\n\n자주 객체를 사용하여 의존 관계를 설정합니다.\n\n<div class=\"content-ad\"></div>\n\nuseEffect에서 객체의 변경 사항 처리하는 것이 중요합니다. 보통은 객체의 내용이 변경되었을 때 특정 작업을 수행하고 싶어합니다. 그러나 실제 비즈니스 개발 중에는 이유를 알 수 없는 문제가 발생할 수 있습니다. 몇 가지 흔한 현상을 살펴보겠습니다:\n\n🤔 객체의 내용이 분명히 변경되었는데, 왜 useEffect가 작동하지 않을까요?\n\n🤔 객체의 내용이 분명히 변경되지 않았는데, 왜 useEffect가 항상 작동할까요?\n\n이것은 말장난처럼 들릴 수 있지만, 이 문제의 본질은 객체가 참조 유형이라는 점에 있습니다. 아래 예시를 통해 보다 깊은 이해를 얻을 수 있습니다. 🔄✨\n\n<div class=\"content-ad\"></div>\n\nCase 1️⃣: 객체의 속성 값을 변경하면 useEffect가 트리거되지 않습니다\n\n```js\nconst [info, setInfo] = useState({\n  name: \"Bob\",\n  age: 20\n});\n\nuseEffect(() => {\n  console.log(\"info\", info);\n},[info]);\n\nfunction handleChangeName(e){\n  const value = e.target.value;\n  setInfo((info)=>{\n    info.name = value;\n    return info;\n  });\n}\n\nreturn <input onChange={handleChangeName} />;\n```\n\n문제의 원인: setInfo를 호출할 때 입력 매개변수가 직접 변경됩니다. 이때 변경된 정보가 반환되며 그 참조가 변경되지 않습니다.\n\n참고: 어떠한 경우에도 입력 매개변수를 직접 변경하거나 상태 값을 직접 변경해서는 안 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n//잘못된 작성법\ninfo.name = value;\nsetInfo(info);\n\n//잘못된 작성법\nsetInfo((info) => {\n   info.name = value;\n   return info;\n});\n\n//올바른 작성법\nsetInfo({\n     ...info,\n     name: value\n});\n\n// 올바른 작성법\nsetInfo((info) => {\n   return {\n     ...info,\n     name: value\n   };\n});\n```\n\nCase 2️⃣: 부모 구성 요소의 객체 속성을 종속성으로 수락하여 useEffect가 자주 트리거됨\n\n컴포넌트를 개발할 때 일부 속성에 대한 기본 값을 설정하는 것이 종종 필요합니다. 전형적인 접근 방식은 props를 구조화하고 기본 값 동시에 할당하는 것입니다. 🛠️🔧\n\n```js\nconst {\n    count = 0,\n    list = []\n} = \n```\n \n\n\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트에서 \"list\" 속성을 전달하지 않으면, 자식 컴포넌트는 부모 컴포넌트가 다시 렌더링될 때마다 다시 렌더링되어 useEffect가 각 렌더링마다 트리거됩니다. 🔃\n\n```js\nimport { useState, useEffect } from \"react\";\n\nconst Com = () => {\n  const [count, setCount] = useState(0);\n  \n  function handleOnClick(){\n    setCount((count) => count + 1);\n  }\n\n  return (\n    <div>\n      <button onClick={hanleOnClick}>add</button>\n      <SubCom count={count} />\n    </div>\n  );\n};\n\nconst SubCom  = (props) => {\n  const { list = [], count } = props;\n  \n  useEffect(() => {\n    console.log(list)\n  },[list])\n\n  return <div>child component: {count}</div>;\n\n};\n\nexport default Com;\n```\n\n문제의 원인: 부모 컴포넌트가 업데이트될 때, 자식 컴포넌트가 다시 렌더링되어 각 렌더링마다 새로운 props.list 참조가 제공됩니다. 빈 배열로 표시되더라도, useEffect는 list의 참조 변경을 감지하여 실행됩니다. 복잡한 시나리오에서 빈번한 업데이트는 화면이 흰색으로 나타나는 문제를 야기할 수 있습니다.\n\n올바른 접근법: 컴포넌트가 사용된 곳에서 호환성 처리를 구현하고, 기본값을 직접 할당하는 것을 피하십시오. 🛠️\n\n<div class=\"content-ad\"></div>\n\nCase 3️⃣: 객체 내용이 변경되지 않았을 때 useEffect가 트리거되지 않도록 설정하고 싶어요.\n\n객체가 의존성으로 사용될 때, 해당 실행이 내용이 변경될 때 트리거되는 것이 일반적입니다. 그러나 useEffect의 본질은 참조 변경을 모니터하는 것이라, 실제 비즈니스 개발과 다소 일치하지 않을 수 있어요. 🤔\n\n- 비즈니스 레이어는 종종 일부 상태를 재설정하고, setState([]) 또는 setState('')을 사용합니다. 상태 값 자체가 [] 또는 ''일 수 있으며, 재설정 후 내용은 변경되지 않았지만 참조가 변경되어 useEffect가 트리거되는 경우가 생길 수 있어요.\n\n```js\nimport { useState, useEffect } from \"react\";\n\nconst Com = () => {\n   const [list, setList] = useState([]);\n\n   function reset() {\n     setList([]);\n   }\n\n   return (\n     <div>\n       <p>{list.join(\",\")}</p>\n       <button onClick={reset}>reset</button>\n       <SubCom list={list} />\n     </div>\n   );\n};\n\nconst SubCom = (props) => {\n   const { list } = props;\n\n   useEffect(() => {\n     console.log(list);\n   }, [list]);\n\n   return <div>자식 컴포넌트</div>;\n};\n\nexport default Com;\n```\n\n<div class=\"content-ad\"></div>\n\n솔루션:\n\n- 오브젝트를 문자열로 변환한 뒤 useEffect의 의존성으로 사용하세요.\n\n```js\nuseEffect(() => {\n  console.log(list);\n}, [JSON.stringify(list)]);\n```\n\n- 문제를 해결하기 위해 훅의 useDeepCompareEffect을 사용하세요. 사용 방법은 useEffect와 동일하지만 deps는 lodash isEqual을 통해 깊게 비교됩니다.\n\n<div class=\"content-ad\"></div>\n\n\nCase 4️⃣: 두 개의 useEffect 업데이트가 서로에게 의존하며 무한 업데이트로 인해 화면이 흰색으로 나타납니다.\n\n```js\nconst {\n     value,\n     defaultValue = 0.5,\n     onChange\n} = props;\n\nconst [innerValue, setInnerValue] = useState<number>(defaultValue);\n\n// useEffect1이라고 명명된 효과\nuseEffect(() => {\n     if (value !== undefined) {\n         setInnerValue(value);\n     }\n}, [value]);\n\n// useEffect2라고 명명된 효과\nuseEffect(() => {\n     onChange?.(innerValue);\n}, [innerValue]);\n```\n\n문제:\n\n\n<div class=\"content-ad\"></div>\n\n- 🔍 첫 번째 로드 시, useEffect2가 트리거되어 onChange 메서드가 호출됩니다.\n- 🔄 비즈니스 레이어에서 값이 수동으로 변경되면, onChange도 트리거됩니다.\n\n올바르게 작성하는 방법:\n\n- 🛠️ 실제로 양식 값 변경을 수동으로 하는 경우, useEffect를 직접 사용하는 대신 innerValue의 변경 사항을 모니터링하기 위해 onChange를 호출하세요.\n\nCase 5️⃣: useRef 값을 모니터링하는데 의존하면, 때로는 업데이트가 트리거될 수 있지만 때로는 업데이트가 트리거되지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { useState, useEffect, useRef } from \"react\";\n\nexport default () => {\n   const [count, setCount] = useState(0);\n   const countRef = useRef(0);\n    \n   // Named useEffect1\n   useEffect(() => {\n     console.log(\"count\", count);\n   }, [count]);\n\n   // Named useEffect2\n   useEffect(() => {\n     console.log(\"countRef\", countRef);\n   }, [countRef.current]);\n\n  \n\n   return (\n     <div>\n       <p>{count}</p>\n       <button onClick={() => setCount((c) => c + 1)}>button1</button>\n       <button onClick={() => (countRef.current += 1)}>button2</button>\n     </div>\n   );\n};\n```\n\n현상:\n🔘 버튼1을 클릭하면 useEffect1이 실행됩니다.\n🔘 버튼2를 클릭하면 useEffect2가 실행되지 않습니다.\n🔘 버튼1을 다시 클릭하면 useEffect1과 useEffect2가 모두 실행됩니다.\n\n문제의 원인:\n🔍 상태가 변경될 때만 업데이트가 트리거됩니다. useState와 useReducer는 업데이트를 시작할 수 있는 유일한 훅입니다.\n\n사용 안내:\n📌 useRef의 값은 useRef의 변경으로 상태 변경이 필요한 경우가 확실한 경우에만 의존성으로 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\nReact 개발의 광활한 바다에서 useState와 useEffect는 우리의 애플리케이션에 생명과 기능을 부여할 수 있는 강력한 동료들입니다. 그러나 강력한 도구처럼, 그들만의 문제와 함정이 따릅니다.\n\n올바른 상태 업데이트를 보장하고 의존성과 부작용을 처리하는 등, 이 안내서는 React 개발의 위험한 지형을 안전하게 탐험하기 위해 필요한 지식과 전략을 제공했습니다.\n\n여정을 계속하면서 주의를 기울이고 철저하게 테스트하며, 동료 개발자로부터 지식을 얻거나 신뢰할 만한 자료를 참고하는 것을 꺼리지 마세요. useState와 useEffect를 잘 이해하고 인내심을 가지면 가장 어려운 React 프로젝트도 정복하고 우수한 애플리케이션을 구축할 수 있습니다. 즐거운 코딩하세요! 🚀🌟","ogImage":{"url":"/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png"},"coverImage":"/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png","tag":["Tech"],"readingTime":12},{"title":"5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 ","description":"","date":"2024-05-20 23:24","slug":"2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives","content":"\n\n파이썬 스크립트를 실행하는 방법이 궁금하거나 파이썬 애플리케이션을 서버에 배포하는 방법을 알고 싶거나, 파이썬 프로젝트에 대한 최상의 클라우드 호스팅 솔루션을 찾고 계신다면 망설이지 마세요.\n\n![이미지](/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png)\n\n본 비교에서는 네이티브 파이썬 지원을 제공하는 다섯 가지 인기 호스팅 플랫폼을 살펴볼 것입니다. 비교를 도와줄 이전 멘션되지 않은 Heroku가 마지막에 포함되어 있습니다.\n\n본 비교는 다음 기준을 탐색합니다:\n\n<div class=\"content-ad\"></div>\n\n- 무료 티어\n- 가장 저렴한 유료 인스턴스의 비용\n- 배포 방법\n- 지원되는 워크로드\n- 네이티브 파이썬 지원\n- 도커 파일 지원\n- 지원되는 지역\n- 기본 인프라\n- 파이썬 배포에 대한 문서\n\n모든 이 솔루션은 클라우드에서 애플리케이션을 신속하게 배포하는 데 도움이 됩니다. 이 비교 기준은 귀하의 프로젝트에 가장 적합한 솔루션을 식별하는 데 도움이 될 것입니다. 이제 소개 없이 2024년에 당신의 파이썬 애플리케이션을 호스팅할 수 있는 최고의 호스팅 플랫폼을 살펴보겠습니다.\n\n# 1. Koyeb\n\n웹사이트: https://www.koyeb.com/\n\n<div class=\"content-ad\"></div>\n\n- 무료 티어: 서비스 하나 및 관리형 PostgreSQL 데이터베이스 하나 배포 가능합니다.\n- 가장 저렴한 유료 인스턴스 비용: eNano 인스턴스는 초 단위로 과금됩니다. 한 달 동안 실행하면 $1.61이 소요됩니다.\n- 배포 방법: Git을 통한 배포 및 Docker 기반의 배포가 가능합니다. CLI 및 제어판을 통해 실행할 수 있습니다.\n- 지원하는 워크로드: 풀 스택 애플리케이션, 웹 서비스, API, 백그라운드 작업 및 데이터베이스를 지원합니다.\n- 네이티브 Python 지원: ✅ 플랫폼에 배포된 Python 프로젝트를 식별하고 빌드하는 네이티브 빌드팩이 제공됩니다.\n- Dockerfile 지원: ✅ Dockerfile에서 빌드할 수 있어 빌드 프로세스를 더 세밀하게 제어할 필요가 있는 경우에도 지원됩니다.\n- 지원하는 지역: 세계 세 대륙에 걸쳐 총 여섯 개의 지역을 지원합니다. 샌프란시스코(미국), 워싱턴 D.C.(미국), 프랑크푸르트(독일), 파리(프랑스), 도쿄(일본) 및 싱가포르.\n- 기반이 되는 인프라: Koyeb는 베어 메탈 머신에서 직접 실행됩니다.\n\nPython 배포용 문서\n\n- Koyeb에서 Python Flask 배포\n- Koyeb에서 Python Django 배포\n- Koyeb에서 Python FastAPI 배포\n- Koyeb에서 Git을 통한 Python 배포\n- Koyeb에서 Celery Worker 배포\n\n# 2. pythonanywhere.com\n\n<div class=\"content-ad\"></div>\n\n- 무료 티어: 웹 애플리케이션 1개\n- 가장 저렴한 유료 인스턴스 비용: 월 $5\n- 배포 방법: GitHub 또는 Bitbucket을 통해 배포합니다. 도커 컨테이너를 배포할 수 없습니다. CLI 및 대시보드 사용 가능\n- 지원하는 작업 부하: 웹 애플리케이션, 크론 작업, 데이터베이스 및 정적 사이트\n- 네이티브 파이썬 지원: 가능\n- Dockerfile 지원: Dockerfile에서 빌드 지원 불가\n- 지원하는 지역: 미국 동부의 1개 위치. 플랫폼의 EU 버전은 프랑크푸르트 지역에 작업 부하를 실행합니다.\n- 기반이 되는 인프라: PythonAnywhere은 AWS 위에서 실행됩니다.\n\nPython 배포를 위한 문서\n\n- PythonAnywhere에서 Python Flask 배포하기\n- PythonAnywhere에서 Python Django 배포하기\n\n# 3. Render\n\n<div class=\"content-ad\"></div>\n\n웹사이트: https://render.com/\n\n- 무료 티어: 매달 한 서비스당 750시간.\n- 가장 저렴한 유료 인스턴스 비용: 월 $7.\n- 배포 방법: Git 및 Docker 기반 배포. CLI 및 제어판 제공.\n- 지원되는 Workloads: 웹 서비스, 정적 사이트, 데이터베이스 및 cron 작업.\n- 네이티브 파이썬 지원: Render에서 파이썬을 배포할 수 있도록 네이티브 런타임 제공.\n- Dockerfile 지원: Dockerfile에서 빌드하는 기능도 지원됩니다.\n- 지원되는 지역: 세 대륙에 걸쳐 네 개 지역 – 오리건 (미국), 오하이오 (미국), 프랑크푸르트 (독일), 싱가포르.\n- 기본 인프라: Render는 AWS 및 GCP 상에서 실행됩니다.\n\n파이썬 배포를 위한 문서\n\n- Render에서 Python Django 배포하기\n- Render에서 Python Flask 배포하기\n- Render에서 Celery Worker 배포하기\n\n<div class=\"content-ad\"></div>\n\n# 4. Fly.io\n\n- 무료 티어: $5 회원 가입 크레딧. 무료 자원을 사용하여 최대 3개의 서비스를 배포할 수 있습니다.\n- 가장 저렴한 유료 인스턴스 비용: 월 $1.94\n- 배포 방법: 애플리케이션, 크론 작업, 대기열 및 데이터베이스.\n- 지원되는 워크로드: 도커화된 애플리케이션.\n- 내장된 Python 지원: 내장 Python 빌더 탑재.\n- Dockerfile 지원: Dockerfile에서 빌드 지원됨.\n- 지원되는 지역: 전 세계 35개 지역 지원.\n- 기반이 되는 인프라: Fly.io는 베어 메탈 머신 상에서 실행됩니다.\n\nPython 배포에 대한 문서\n\n- Fly.io에서 Python Flask 배포하기\n- Fly.io에서 Python Django 배포하기\n\n<div class=\"content-ad\"></div>\n\n# 5. DigitalOcean 앱 플랫폼\n\n웹사이트: https://www.digitalocean.com/products/app-platform\n\n- 무료 티어: 무료로 3개의 정적 사이트를 빌드하고 배포할 수 있습니다.\n- 가장 저렴한 유료 인스턴스 비용: 월별 $5.\n- 배포 방법: Git 기반의 배포 및 미리 빌드된 Docker 이미지 사용 가능.\n- 지원하는 워크로드: 어플리케이션, 정적 사이트, 크론 작업, 데이터베이스.\n- 네이티브 파이썬 지원: 네이티브 빌드팩으로 파이썬 프로젝트를 식별하고 빌드합니다.\n- Dockerfile 지원: Dockerfile로부터 빌드하는 기능을 지원합니다.\n- 지원되는 지역: 9개 지역을 지원합니다.\n- 기반 인프라: DigitalOcean 앱 플랫폼은 DigitalOcean의 인프라에서 실행됩니다.\n\n파이썬 배포를 위한 문서\n\n<div class=\"content-ad\"></div>\n\n- DigitalOcean 앱 플랫폼에 Python Flask 배포\n- DigitalOcean 앱 플랫폼에 Python Django 배포\n\n# 6. Heroku\n\n웹사이트: https://www.heroku.com/\n\n- 무료 티어: Heroku는 무료 티어를 중단했습니다.\n- 가장 저렴한 유료 인스턴스 비용: 매월 $5.\n- 배포 방법: Git 기반의 배포 및 미리 구축된 Docker 이미지 사용.\n- 지원되는 작업 부하 유형: 애플리케이션, 백그라운드 작업, cron 작업, 데이터베이스.\n- 네이티브 파이썬 지원: 네, Heroku의 네이티브 빌드팩은 파이썬 프로젝트를 인식하고 빌드합니다.\n- Dockerfile 지원: Heroku는 Dockerfile에서 빌드하는 것을 지원하지만, Heroku는 고급 사용 사례에 대해 Heroku 컨테이너 스택 사용을 권장합니다. Heroku의 기본 빌드팩 시스템이 권장됩니다.\n- 지원되는 지역: 유럽과 미국 두 군데의 지역이 지원됩니다. 엔터프라이즈 플랜이 없으면.\n- 기본 인프라: Heroku는 AWS 위에서 운영됩니다.\n\n<div class=\"content-ad\"></div>\n\n파이썬 배포에 대한 문서\n\n- 파이썬 시작하기: [여기를 클릭하세요](https://devcenter.heroku.com/articles/getting-started-with-python)\n- Heroku에서 파이썬 및 장고 앱 배포하기: [여기를 클릭하세요](https://devcenter.heroku.com/articles/deploying-python)\n\n# 결론: 원하는 곳에 배포하세요!\n\n다뤄 본 내용: 무료 티어, 배포 방법, 워크로드 호환성, 기본 인프라 및 예산을 그대로 유지할 수 있는 유료 요금제에 대해 다루었습니다. 아마도 여러분의 프로젝트에 가장 적합한 선택을 할 수 있도록 도움이 될 통찰력을 발견했을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 비교를 마무리하면, 여러분의 호스팅 플랫폼은 앱의 성능에 영향을 미칠 뿐만 아니라 데브옵스에서 시간을 확보하여 앱 개발에 집중할 수도 있습니다. 행복하고 빠른 배포를 기원합니다!","ogImage":{"url":"/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png"},"coverImage":"/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png","tag":["Tech"],"readingTime":5},{"title":"Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션","description":"","date":"2024-05-20 23:21","slug":"2024-05-20-SymfonyMulti-TenantApplicationswithEcotone","content":"\n\n<img src=\"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png\" />\n\n비즈니스 도메인에 따라 멀티 테넌시를 어떻게 구현하는지가 달라집니다. 데이터베이스를 공유해야 할 수도 있고 완전히 격리된 별도의 데이터베이스를 필요로 할 수도 있습니다. 테넌트가 몇 개뿐인 경우도 있지만 수백 개인 경우도 있습니다. 주어진 테넌트의 성능에 대한 쿼터링 또는 성능 향상이 필요할 수 있습니다. 이 모든 것은 멀티 테넌시가 기술적인 측면 뿐만 아니라 비즈니스적인 고려 사항이기도 함을 의미합니다.\n\n이전 기사에서는 최소한의 노력으로 Laravel 및 Ecotone을 사용하여 멀티 테넌트 시스템을 구축하는 방법에 대해 설명했습니다. 이번에는 Symfony 프레임워크에 대해 동일한 작업을 수행할 것입니다.\n\n이 기사의 시나리오는 각 섹션의 끝에 연결된 데모와 함께 제시될 것입니다. 이렇게 하면 예제를 논의할 뿐만 아니라 실행 가능한 데모를 참고할 수도 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 테넌트별 데이터베이스로 메시지 전송\n\n만약 전자 상거래 도메인에서 활동 중이고 각각이 별도의 데이터베이스를 가지고 있는 두 개의 테넌트가 있다고 가정합시다(DB per Tenant 전략).\nE-커머스 시스템에서 가장 먼저 발생해야 하는 것은 새로운 고객 등록이며, 이것에 대해 지금 집중하겠습니다.\n\n새로운 고객을 등록하는 과정은 다음과 같이 진행됩니다:\n\n![이미지](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_1.png)\n\n<div class=\"content-ad\"></div>\n\n우리는 Command Handler로 등록 고객 Command Message를 보낼 것입니다.\n\nCommand Bus를 사용하여 Command Handler에 등록 고객 Command를 보내서 새로운 고객을 데이터베이스에 저장할 것입니다. 중요한 부분은 주어진 테넌트와 관련된 데이터베이스에 고객을 저장하려고 한다는 것입니다.\n\n시작하기 위해 Symfony용 Ecotone을 설치해 봅시다:\n\n이를 통해 Ecotone의 Symfony 통합 및 데이터베이스 지원 도구를 제공받을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 테넌트에 대한 연결 매핑\n\n우리는 예제로 Doctrine ORM을 사용할 것입니다. 각 테넌트는 자체 데이터베이스 연결을 갖게 될 것이므로, 먼저 각 테넌트에 대한 Doctrine 구성을 정의해야합니다(doctrine.yaml).\n\n연결이 정의되면, 이제 어떻게 테넌트 이름에 매핑될지 설정할 수 있습니다. Ecotone의 ServiceContext 속성으로 표시된 구성 방법을 사용하여 수행합니다.\n\n이것이 기본적으로 전부입니다. Ecotone은 이제 지정된 테넌트 이름이 지정된 연결에 매핑되는 방법을 알게 됩니다. 따라서 어떤 종류의 메시지(명령/쿼리/이벤트)를 보내면 어떤 연결을 사용해야 하는지 알 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Multi-Tenant Command Handler\n\n우리는 다중 테넌트 시스템에 Ecotone의 CQRS를 사용할 것입니다. 이를 통해 다중 테넌트 시스템에서 사용할 수 있는 다양한 기본 기능을 제공받습니다.\n\n우리의 Register Customer Command Handler를 정의해봅시다:\n\nCommand Handler를 보면 특별한 것이 없는 것을 알 수 있습니다. PHP 속성으로 표시된 비즈니스 로직을 수행하는 메서드일 뿐입니다. 우리의 Command Handler는 Command Class를 가져와 Doctrine ORM을 사용하여 고객을 저장합니다. 이 코드는 단일 테넌트 환경에서도 문제없이 작동할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 꼼꼼한 부분은 특정 Tenant에 대한 ObjectManager/EntityManager를 사용해야 한다는 것입니다. 각 Tenant마다 자체 데이터베이스 연결이 있기 때문입니다.\n#[MultiTenantObjectManager] 속성을 추가함으로써 Ecotone에게 현재 활성화된 Tenant에 대한 ObjectManager를 주입하도록 알려줍니다. 이렇게 하면 고객을 올바른 Tenant의 데이터베이스에 저장하고 코드를 Multi-Tenancy에 대해 직관적으로 유지할 수 있습니다.\n\n이제 RegisterCustomer Command Class를 정의해봅시다:\n\nCommand Class는 간단한 POPO (Plain Old PHP Object)이며 특정 프레임워크 클래스를 확장하거나 구현하지 않습니다. Command에는 고객 등록에 필요한 모든 데이터가 포함되어 있습니다.\n\n# Multi-Tenant Message Bus\n\n<div class=\"content-ad\"></div>\n\n우리 코드베이스에 Command Handler를 소개한 후에는 이제 주어진 테넌트에 대해 Command를 보낼 수 있습니다.\n우리는 주어진 테넌트의 문맥에서 주어진 Command를 실행할 것입니다:\n\n여기서는 Command를 Command Bus를 통해 보내고 메타데이터 (메시지 헤더)를 사용하여 테넌트 이름을 전달합니다. 이렇게 하면 Ecotone이 해당 Command Handler를 주어진 테넌트의 데이터베이스 context에서 수행하고 있다는 것을 이해할 것입니다. 일반적으로 HTTP 도메인 또는 사용자 세션을 기반으로 여기서 테넌트 이름을 해결할 것입니다.\n\n이것이 말 그대로 다중 테넌트 환경에서 고객을 저장하는 데 필요한 모든 것입니다. 기본적으로 우리의 코드는 단일 테넌트 또는 다중 테넌트 모두에 대해 작동할 것입니다. 다중 테넌시에 완전히 중립적이기 때문입니다. 이제 우리의 다중 테넌트 시스템에서 필요할 수 있는 더 많은 시나리오를 확인해 봅시다.\n\n데모 구현은 이 링크에서 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 공유 및 다중 데이터베이스 테넌트\n\n기본적으로 우리는 각 테넌트를 동일한 데이터베이스에 넣지만, 고객이 프리미엄을 구매하면 별도의 데이터베이스 인스턴스를 받게되는 비즈니스 모델을 가질 수 있습니다.\n\n이러한 경우를 처리하기 위해 Ecotone은 기본 연결을 제공합니다. 따라서 주어진 테넌트 이름에 대한 매핑이 없는 경우 기본값이 사용됩니다:\n\n# 메시지 핸들러에서 현재 테넌트에 액세스하기\n\n<div class=\"content-ad\"></div>\n\n특정 시나리오에서는 실행이 수행되는 테넌트의 맥락을 인식해야 할 수도 있습니다. 예를 들어, 특정 테넌트가 고급 상점을 가지고 있을 때는 주문 후 즉시 배송이 이뤄져야 하지만, 다른 테넌트에게는 시간이 중요하지 않을 수도 있습니다.\n\nEcotone의 경우, 메시지 헤더(메타데이터)를 통해 전송하는 모든 것은 메시지 핸들러 수준에서 접근할 수 있습니다. 따라서 필요에 따라 특정 메타데이터를 무시하거나 접근할 수 있습니다. 그리고 메시지 헤더를 통해 테넌트 이름을 전송하므로 필요한 경우 이를 접근할 수 있습니다:\n\n헤더 속성은 접근하려는 메시지 헤더를 나타냅니다. 우리의 경우, 우리가 이전에 커맨드 버스를 통해 전송한 테넌트 헤더에 접근하려고 합니다.\n\n# 테넌트 전환에 연결하기\n\n<div class=\"content-ad\"></div>\n\n이미 멀티 테넌트 애플리케이션이 실행 중이라면, 사용자 정의 라이브러리나 통합을 사용하고 있을 가능성이 높습니다. 이러한 경우 특정 테넌트가 활성화되거나 비활성화될 때 일부 코드를 트리거해야 할 수도 있습니다.\n\nEcotone은 테넌트 전환 프로세스에 훅을 걸 수 있는 가능성을 엽니다. 여기에서 활성화될 Connection과 테넌트 이름을 제공할 수 있습니다.\n\n활성화할 메소드를 OnTenantActivation 또는 OnTenantDeactivation으로 표시하기만 하면 되며, 지정된 메소드는 트리거될 것이며 이에 따라 작업이 수행됩니다. 이 방법으로 특정 어트리뷰트로 메소드를 표시함으로써, 흐름에 훅을 걸고 필요한 로직을 수행할 수 있습니다.\n\n데모 구현은 다음 링크에서 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 이벤트 및 테넌트 전파\n\n고객이 등록되면 환영 메시지가 포함된 이메일을 보내는 등 부수 효과를 발생시키고 싶을 수 있습니다. 이러한 상황에서는 이벤트 및 이벤트 핸들러를 정의할 수 있습니다.\n\n고객이 등록되면 Event Bus를 사용하여 CustomerWasRegistered 이벤트 메시지를 발행합니다. 그런 다음 구독하는 이벤트 핸들러에 대한 모든 메서드(첫 번째 매개변수는 구독하는 이벤트를 지정)가 실행됩니다.\n\nEcotone을 사용하면 이벤트 핸들러에서 테넌트 메시지 헤더에 액세스할 수 있습니다. 이는 Ecotone의 메타데이터 전파 기능 덕분에 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n아래 링크에서 데모 구현을 찾을 수 있습니다.\n\n# 컨텍스트 및 메타데이터 전파\n\nEcotone은 기본적으로 모든 메시지 헤더를 자동으로 전파합니다. 이를 통해 컨텍스트인 테넌트를 보존합니다. 우리의 경우, 고객 등록이 진행된 테넌트의 컨텍스트에서 알림을 보낼 것입니다:\n\n![이미지](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_2.png)\n\n<div class=\"content-ad\"></div>\n\n메타데이터는 명령에서 발행된 이벤트로 자동 전파됩니다.\n\n물론 우리는 Event Handlers에서 또한 테넌트 이름에 접근할 수 있습니다.\n\n## 비동기 이벤트\n\n우리는 기본적으로 이벤트 핸들러를 동기적으로 실행할 수 있지만 비동기적으로 실행할 수도 있습니다. Ecotone은 RabbitMQ, Redis, Database 채널과 같은 비동기 처리를 위한 통합 세트를 제공하며 Symfony Messenger Transport를 사용할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 데이터베이스 채널을 사용하려고 합니다. 이는 주어진 테넌트의 메시지를 해당 테넌트의 데이터베이스에 저장할 것으로 기대됩니다. 이를 위해 Ecotone의 데이터베이스 메시지 채널을 사용할 것입니다. 이는 멀티 테넌시를 지원하기 때문에 사용합니다.\n\n![Image](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_3.png)\n\n이제 이벤트 핸들러를 비동기적으로 처리하도록 표시해 봅시다.\n\n해당 이벤트 핸들러는 이제 비동기적으로(백그라운드에서) 처리된다는 것을 의미하고, 이벤트 메시지는 \"notifications\" 메시지 채널로 전송될 것입니다. 그래서 이 채널을 데이터베이스 큐로 정의합시다:\n\n<div class=\"content-ad\"></div>\n\n해당 이벤트 핸들러를 비동기로 구성하는 데 필요한 모든 작업은 여기까지입니다. 이제 이벤트 핸들러가 실행될 때마다 이벤트 메시지가 주어진 테넌트의 데이터베이스 대기열로 먼저 이동한 다음 비동기적으로 소비될 것입니다.\n\n# 비동기 메시지 소비자 실행\n\n비동기 메시지 채널(우리 경우 데이터베이스 대기열)에 메시지를 발행하면 이를 소비해야 합니다.\n메시지 소비자를 실행하기 위해 내장된 콘솔 명령 \"ecotone:run\"을 사용할 것입니다:\n\n이 명령은 \"notifications\" 채널로 오는 메시지를 가져와 실행하는 별도의 메시지 소비 프로세스가 실행될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n여러 테넌트 환경에서 운영 중이며 우리의 \"알림\"은 데이터베이스 큐입니다. 이는 각 테넌트마다 별도의 대기열을 가진 별도의 데이터베이스가 있음을 실제로 의미합니다. 이것은 소비 과정에서 고려되어야 합니다.\n\n작업 중인 비즈니스 도메인에 따라 수백 개의 테넌트가 있을 수 있으므로 수백 개의 메시지 소비자를 실행하는 것이 이상적이라고는 할 수 없습니다. 이러한 상황에서 Ecotone은 기본적으로 라운드로빈 전략을 사용하여 단일 프로세스를 사용하여 수용합니다. 이는 각 테넌트에서 순서대로 가져올 것을 의미합니다:\n\n![이미지](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_4.png)\n\nEcotone은 다중 테넌트에서 메시지를 소비하는 데 라운드 로빈 전략을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n이 방법으로 소비하는 것은 즉시 작동합니다. 이를 실현하기 위해 고객 구성을 할 필요가 없습니다. 메시지 소비 속도를 높이고 싶다면 해당 프로세스를 여러 개 실행할 수 있습니다.\n사실, 우리는 특정 프리미엄 테넌트의 메시지 소비 속도를 높이거나, 많은 메시지를 생성하는 테넌트의 제어를 가져가서 전체 프로세스를 관리할 수 있습니다. 그러나 이 부분은 별도의 기사에서 탐구할 것입니다.\n\n데모 구현은 이 링크에서 찾을 수 있습니다.\n\n# 데이터베이스 트랜잭션 및 아웃박스 패턴\n\n시스템을 장애에 강하게 만들기 위해 데이터베이스 트랜잭션을 활성화하고 싶을 수 있습니다. 물론 우리의 경우에는 트랜잭션을 지정된 테넌트의 데이터베이스에 대해 시작하길 원할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_5.png\" />\n\nCommand Bus가 실행될 때 자동으로 데이터베이스 트랜잭션이 시작됩니다.\n\n우리가 Command를 실행할 때 Ecotone은 올바른 테넌트 데이터베이스를 자동으로 시작하기 위해 데이터베이스 트랜잭션을 시작합니다. 이것은 Symfony Starter와 함께 설치된 Dbal Module에서 사용 가능한 기능으로, 추가 구성이 필요하지 않습니다. 트랜잭션을 구성하는 방법에 대해 더 알고 싶다면 문서를 참조해 주세요.\n\n이벤트를 데이터베이스 큐로 비동기적으로 발행할 때 이 역시 트랜잭션으로 처리됩니다. 이렇게 함으로써 예외가 발생한 경우 모든 과정이 함께 롤백될 것임을 확신할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![SymfonyMulti-TenantApplicationswithEcotone_6](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_6.png)\n\n이 작업은 Multi-Tenant 시스템에서 Outbox 패턴으로 작동합니다. 이외에도 Ecotone은 메시지가 데이터베이스에서 메시지 브로커(예: RabbitMQ, Redis, SQS)로 자동으로 이동될 수 있는 결합된 메시지 채널을 제공합니다. 이렇게 하면 메시지 처리가 메시지 브로커 소비자(그리고 그것들을 확장할 수 있음)를 위해 이루어지고, 데이터베이스 소비자가 아닙니다.\n\n# Dbal Business Methods\n\nDbal 모듈은 Business Interface를 제공하는데, 이는 추상화된 형태로 감춰진 데이터베이스 쿼리를 쉽게 작성할 수 있는 방법입니다.\n\n\n<div class=\"content-ad\"></div>\n\n우리는 이루고 싶은 것의 인터페이스를 정의하고 Ecotone이 해결방안을 처리합니다. 이것은 우리가 해야 할 일은 인터페이스를 작성하는 것뿐이며 구현은 제공되며 의존성 컨테이너에 등록될 것임을 의미합니다.\n비즈니스 인터페이스는 메시지 핸들러(Command/Query/Event Handlers)에서 호출될 때 자동으로 테넌트의 연결을 상속받습니다.\n\n더 많은 정보를 알고 싶다면 Dbal을 기반으로 한 비즈니스 인터페이스 사용에 대한 이 기사를 읽어보세요.\n\n# 명령을 직접 모델로 보내기\n\nEcotone은 명령을 우리의 Doctrine ORM Entity에 직접 보내는 것을 지원합니다. 이 방법으로는 어떤 위임 수준의 코드도 작성할 필요가 없습니다.\n물론, 이는 멀티 테넌시와 함께도 작동합니다:\n\n<div class=\"content-ad\"></div>\n\n위의 예시에서 보듯이 정적 팩토리 메서드를 생성했습니다. 이 방법으로 Ecotone에게 이 팩토리 메서드 \"register\"가 새로운 고객을 생성한다고 알려줍니다. 이 메서드가 실행된 후, Ecotone은 해당 테넌트에 대해 EntityManager를 사용하여 올바른 데이터베이스에 저장합니다.\n이것은 더 이상 이와 같은 코드를 작성할 필요가 없다는 것을 의미합니다:\n\n컨트롤러 측에서는 아무 것도 바뀌지 않고 이전과 똑같이 보냅니다:\n\n중요한 점은 이것이 Action 기반 메서드에 대해서도 작동하며, 일부 시나리오에서 Command 클래스를 완전히 없앨 수 있게 합니다:\n\n그리고 다음과 같이 Command Bus를 실행할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nmetadata를 통해 aggregate.id를 전달하여 어떤 Customer 인스턴스에서 메서드를 실행할지를 나타낼 수 있습니다. 이 주제에 대해 더 알아보려면 Doctrine ORM을 Aggregate로 사용하는 방법에 대해 이 기사에서 읽을 수 있습니다.\n\n데모 구현은 이 링크에서 찾을 수 있습니다.\n\n# 이벤트 소싱\n\n시스템에서 다른 뷰를 구축하거나 변경 사항을 감사하는 경우, Event Sourcing을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nEcotone는 다양한 테넌트 시스템을 위해 프로덕션에 적합한 이벤트 소싱 애플리케이션을 신속하게 구현할 수 있는 완전한 이벤트 소싱 지원이 제공됩니다.\n\n이 프로세스는 이전에 살펴본 Doctrine ORM 집합체와 동일하게 작동합니다. 차이점은 이벤트 소싱된 집합체가 내부 상태를 변경하는 대신 이벤트 클래스를 반환한다는 것입니다.\n\n## Auto-Setup\n\n물론, 각 테넌트의 이벤트를 저장할 곳이 필요한데, 이를 위해 테넌트의 데이터베이스에 이벤트 저장소를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n에코톤은 이벤트의 직렬화와 역직렬화, 주어진 테넌트 데이터베이스에 이벤트 스토어 설정(포스트그레SQL, MySQL, MariaDB에 내장된 지원) 및 리드 모델 프로젝션 설정을 도와줍니다.\n\n## 리드 모델 프로젝션\n\n프로젝션은 이벤트에서 다양한 뷰를 만드는 데 사용됩니다. 각 프로젝션은 데이터베이스의 별도의 테이블이나 테이블 세트일 수 있으며 동적으로 생성됩니다:\n\n이벤트가 발행되면 관련 프로젝션이 트리거됩니다. 메타데이터에 기반하여 에코톤은 어떤 테넌트와 관련이 있는지 이해하고 이전에 발생하지 않은 경우 프로젝션을 초기화할 것입니다.\n초기화 후 우리 프로젝션의 이벤트 핸들러가 트리거됩니다:\n\n<div class=\"content-ad\"></div>\n\n기본적으로 모든 작업은 동기적으로 발생하며, 이는 이벤트 소싱을 작업하기 매우 쉽게 만듭니다. 필요한 경우 프로젝션을 비동기적으로 실행하도록 전환할 수도 있습니다.\n\n더 많은 내용을 알고 싶다면 문서를 참조하세요. 이벤트 소싱 주제에 대해 더 탐구하고 싶다면 데모 구현은 다음 링크에서 찾을 수 있습니다.\n\n# 요약\n\n이 문서에서는 미리 계획된 코드를 사용하여 Multi-Tenant 친화적인 Symfony 애플리케이션을 구축하는 방법을 활성화했습니다. 이 방식을 통해 우리가 작성한 코드는 어떠한 변경 없이도 단일 테넌트 및 멀티 테넌트 환경에서 작동할 수 있어 애플리케이션을 쉽게 구축하고 유지할 수 있습니다. Ecotone은 컨텍스트 전파를 처리해 줍니다. 따라서 코드가 동기적인지 비동기적인지에 상관없이 작업이 실행되는 테넌트의 컨택스트가 우리를 위해 유지됩니다.\n\n<div class=\"content-ad\"></div>\n\n비동기 처리와 백그라운드 작업을 시작하게 되면 더 정교한 큐 기반 솔루션이 필요할 수 있습니다. 메시지를 너무 많이 생성하는 테넌트의 처리량을 제어하고, \"프리미엄\" 테넌트의 처리 속도를 높이며, 쉽게 작업할 수 있는 방식으로 실패 및 재시도를 처리하고자 할 때 이러한 문제가 발생할 수 있습니다. Ecotone은 이를 제공하지만, 이 주제는 별도의 글이 필요합니다.","ogImage":{"url":"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png"},"coverImage":"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png","tag":["Tech"],"readingTime":10},{"title":"글의 가능성을 높이는 단어 카운터와 텍스트 분석기","description":"","date":"2024-05-20 23:19","slug":"2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer","content":"\n\n텍스트 분석을 통해 더 나은 글을 작성할 수 있는 잘 알려진 도구입니다\n\n![Image](/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png)\n\n참고: 이것은 제가 Medium에 작성한 첫 번째 기사이므로, 부디 제 미숙한 글쓰기와 오타를 용서해 주시기 바랍니다. 😊\n\n안녕하세요 여러분!\n\n<div class=\"content-ad\"></div>\n\n다음은 잘 알려진 속담으로 기사를 시작하려고 합니다:\n\n\"정확하게 사용한다면 모든 말이 할 수 있는 일을 강조하는 가장 좋은 방법입니다.\"\n\n기사를 발행할 글이나 시험 답안을 분석해야 하는 상황에 처해본 적이 있나요?\n\n그렇다면, 저는 텍스트를 분석하고 단어 수, 불용어, 고유한 단어, 단락, 문장, 줄 수 등과 같은 중요한 통계 정보를 제공하며 독해, 쓰기, 말하기, 타이핑 시간과 같은 시간 관련 측정값을 제공하는 효과적인 도구를 개발했다는 것을 기쁘게 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n모든 것을 고려해도 무료이며 모든 기능에 무제한 액세스가 가능합니다.\n\n이 도구를 사용하려면 여기에서 이용할 수 있습니다: [https://livingtocode.com/word-counter/](https://livingtocode.com/word-counter/) 자유롭게 확인해보세요.\n\n이 도구는 SEO 전문가, 학생, 작가, 연구자, 저자, 선생님들이 일상생활에서 글을 평가하고 최적화하는 데 도움이 될 수 있습니다.\n\n위의 모두에 대해 처음이더라도 이 도구는 여전히 글쓰기 기술을 향상시키는 데 도움이 되며, 동기부여를 제공하고 제한 내에서 텍스트를 최적화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\"많은 도구들이 이미 같은 작업을 수행하고 있지만, 가능성을 탐험하기 위해 한 번 만들어 보고 싶었습니다.\n\n건의나 개선 아이디어가 있으면 언제든 환영합니다.\n\n의견을 공유해 주세요.\n\n읽어 주셔서 감사합니다.\"","ogImage":{"url":"/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png"},"coverImage":"/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter에서 clean code를 작성하는 방법","description":"","date":"2024-05-20 23:18","slug":"2024-05-20-Whyshouldweusecleancodeinflutter","content":"\n\n![image](/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png)\n\n플러터에서 깨끗한 코드를 사용하는 것은 유지보수성, 가독성, 확장성 및 디버깅의 용이성을 포함한 여러 가지 이유로 중요합니다. 아래에는 깨끗한 코드의 중요성을 설명하기 위한 몇 가지 구체적인 예와 함께 자세한 설명이 나와 있습니다.\n\n- 유지보수성\n\n깨끗한 코드는 이해하기 쉽고 수정하기 쉽습니다. 코드베이스가 커질수록 잘 구성되고 이해하기 쉬운 코드를 가지고 있으면 버그를 수정하고 새로운 기능을 추가하기가 더 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// .......................코드 작성이 잘못된 부분............................\n\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text('내 앱'),\n    ),\n    body: Column(\n      children: [\n        Text('내 앱에 오신 것을 환영합니다', style: TextStyle(fontSize: 24)),\n        RaisedButton(\n          onPressed: () {\n            // 복잡한 로직\n          },\n          child: Text('눌러보세요'),\n        ),\n      ],\n    ),\n  );\n}\n\n// .......................깔끔한 코드...................................\n\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: _buildAppBar(),\n      body: _buildBody(),\n    );\n  }\n\n  AppBar _buildAppBar() {\n    return AppBar(\n      title: Text('내 앱'),\n    );\n  }\n\n  Widget _buildBody() {\n    return Column(\n      children: [\n        _buildWelcomeText(),\n        _buildPressMeButton(),\n      ],\n    );\n  }\n\n  Widget _buildWelcomeText() {\n    return Text(\n      '내 앱에 오신 것을 환영합니다',\n      style: TextStyle(fontSize: 24),\n    );\n  }\n\n  Widget _buildPressMeButton() {\n    return RaisedButton(\n      onPressed: _handlePressMeButton,\n      child: Text('눌러보세요'),\n    );\n  }\n\n  void _handlePressMeButton() {\n    // 복잡한 로직\n  }\n}\n```\n\n깔끔한 코드 예제에서, build 메서드는 더 작고 더 집중된 메서드로 분해되어 유지보수가 더 쉽습니다.\n\n2. 가독성\n\n깔끔한 코드는 더 읽기 쉽고 이해하기 쉽습니다. 이는 코드가 작성되기보다는 더 자주 읽히기 때문에 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// .......................작성된 코드가 좋지 않습니다............................\n\nvoid updateUserProfile(User user) {\n  if (user.name != null && user.email != null) {\n    // 프로필 업데이트\n  }\n}\n\n\n// ............................깨끗한 코드................................\n\nvoid updateUserProfile(User user) {\n  if (_isUserProfileValid(user)) {\n    _updateProfileInDatabase(user);\n  }\n}\n\nbool _isUserProfileValid(User user) {\n  return user.name != null && user.email != null;\n}\n\nvoid _updateProfileInDatabase(User user) {\n  // 프로필 업데이트\n}\n```\n\n깨끗한 코드 예제는 조건을 잘 명명된 메서드로 추상화하여 가독성을 향상시킵니다.\n\n3. 확장성\n\n프로젝트가 확장될수록, 깨끗한 코드는 코드베이스의 품질을 저하시키지 않고 새로운 기능을 추가하는 것을 더 쉽게 만듭니다.\n  \n\n<div class=\"content-ad\"></div>\n\n```js\n// ..........잘못 작성된 코드.........\n\nvoid performAction(String action) {\n  if (action == 'login') {\n    // 로그인 로직\n  } else if (action == 'logout') {\n    // 로그아웃 로직\n  } else if (action == 'signup') {\n    // 가입 로직\n  }\n}\n\n// ...........깔끔한 코드...............\n\nvoid performAction(String action) {\n  switch (action) {\n    case 'login':\n      _login();\n      break;\n    case 'logout':\n      _logout();\n      break;\n    case 'signup':\n      _signup();\n      break;\n    default:\n      _handleUnknownAction();\n  }\n}\n\nvoid _login() {\n  // 로그인 로직\n}\n\nvoid _logout() {\n  // 로그아웃 로직\n}\n\nvoid _signup() {\n  // 가입 로직\n}\n\nvoid _handleUnknownAction() {\n  // 알 수 없는 동작 처리\n}\n```\n\n깔끔한 코드 예시는 switch 문을 사용하여 동작을 각각의 메서드로 분리하여 새로운 동작을 추가하기 쉽게 만듭니다.\n\n4. 디버깅 용이성\n\n깔끔한 코드는 더 직관적으로 코드를 추적하고 실행 흐름을 이해하기 쉬워져 디버깅을 단순화합니다.\n\n<div class=\"content-ad\"></div>\n\n잘못 작성된 코드:\n\n```js\n// ...........잘못 작성된 코드..............\n\nvoid processOrder(Order order) {\n  if (order.isValid()) {\n    if (order.total > 100) {\n      applyDiscount(order);\n    }\n    // 주문 처리\n  }\n}\n\n\n// ...........깨끗한 코드..............\n\nvoid processOrder(Order order) {\n  if (!order.isValid()) {\n    return;\n  }\n  _applyDiscountIfEligible(order);\n  _processOrderDetails(order);\n}\n\nvoid _applyDiscountIfEligible(Order order) {\n  if (order.total > 100) {\n    applyDiscount(order);\n  }\n}\n\nvoid _processOrderDetails(Order order) {\n  // 주문 처리\n}\n```\n\n깨끗한 코드 예시에서는 로직이 작고 관리하기 쉬운 메소드로 분해되어 있어 이해하고 디버그하기가 더 쉽습니다.\n\n추가 예시: 변수\n\n<div class=\"content-ad\"></div>\n\n```js\n// ........잘못 작성된 코드......\n\nint a;\nString b;\n\n// ........깔끔한 코드..........\n\nint productCount;\nString activeUserName;\n```\n\n함수:\n\n```js\n// ........잘못 작성된 코드.......\n\nvoid doSomething();\nString getSomething();\n\n// ........깔끔한 코드..........\n\nvoid updateProductCount() {\n  // ...\n}\n\nString getUserName() {\n  // ...\n}\n```\n\n클래스:\n\n<div class=\"content-ad\"></div>\n\n\n// ......잘못 작성된 코드....\n\nclass MyClass {\n  // ...\n}\n\n// ........깔끔한 코드..........\n\nclass VideoList {\n  // ...\n}\n\nclass UserAccount {\n  // ...\n}\n\n\n## 결론\n\nFlutter에서 깔끔한 코드를 사용하면 코드베이스가 유지 가능하고 가독성이 높고 확장 가능하며 쉽게 디버깅할 수 있습니다. 깔끔한 코드 원칙을 준수하면 애플리케이션의 전반적인 품질을 향상시켜 미래에 코드를 작업할 때 자신과 다른 사람들이 더 쉽게 작업할 수 있게 됩니다.\n\n<img src=\"/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_1.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n이 기사를 즐겁게 보셨기를 바라요! 제공된 정보를 감사하게 여기신다면, 'Buy Me A Coffee'로 저를 지원할 수 있어요! 여러분의 센스에 감사드릴 거예요!","ogImage":{"url":"/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png"},"coverImage":"/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터에서 코드를 작성하는 간단한 방법","description":"","date":"2024-05-20 23:16","slug":"2024-05-20-ASimplewaytoorganizeyourcodeinFlutter","content":"\n\n<img src=\"/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png\" />\n\n플러터를 개발 앱에 매일 사용하는 과정에서 앞으로도 문제가 되지 않도록 코드를 체계적으로 구성할 방법을 찾고 있었습니다. 여러 프로젝트를 유지하는 것은 언제나 쉽지 않은 일이며, 코드가 깨끗할수록 쉬워집니다. 그래서 이전에 네이티브 안드로이드, Apache Flex, 심지어 PHP와 같은 기술을 경험한 바탕으로 체계적인 프로젝트 구조를 만들었습니다. 여러분에게도 도움이 되었으면 합니다.\n\n# 앱의 구조\n\n저는 모든 프로젝트에서 사용하는 이 구조를 사용하여 프로젝트 간의 이동이 쉽고 물건의 위치를 파악하기 위해 더 이상 찾아다니지 않아도 됩니다. 저희 팀은 이 구조에 익숙해져 있어, 제작량을 최소화하여 며칠 안에 앱을 개발할 수 있는 수준까지 줄일 수 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_1.png)\n\n자, 좀 더 구조에 대해 이야기해 봐요:\n\n화면: 이 폴더에는 일반적으로 앱의 모든 화면이 들어갑니다. 스크린샷에서 볼 수 있듯이, 각 화면에는 각각의 폴더가 있습니다. 이 구체적인 예에서 이 앱에는 하단 내비게이션 바를 사용하는 홈 화면과 4개의 주요 화면(war, news, major_orders, game)이 있습니다. 이 부분에 대해 나중에 더 자세히 설명하겠습니다.\n\n위젯: 이 폴더에는 일반적으로 앱의 재사용 가능한 위젯이 들어갑니다. 이 폴더에는 custom_scaffold와 \"리사이클러\" 또는 리스트 아이템 위젯과 같은 파일을 저장합니다.\n\n<div class=\"content-ad\"></div>\n\n서비스: 나는 내가 만드는 앱에서 사용하는 모든 외부 서비스를 가지고 있는 DIO 폴더로 알려진 것이다. 여기에는 보통 앱에 데이터를 공급하는 REST API에 연결하는 클래스들이 포함되어 있습니다.\n\n모델: 서비스 폴더를 따라서 항상 나는 모델(객체 클래스)들을 Models라는 별도의 폴더에 유지합니다. 과거에 Flex 또는 AIR를 사용한 사람들을 위해, 이곳은 예전에 내 ValueObjects 폴더였습니다. 사전 용어에 대한 모델 예시:\n\n```js\nclass TermVO {\n  int? id;\n  String? title;\n  String? description;\n  String? language;\n\n  TermVO({this.id, this.title, this.description, this.language});\n\n  TermVO.fromJson(Map<String, dynamic> json) {\n    id = json['id'];\n    title = json['title'];\n    description = json['description'];\n    language = json['language'];\n  }\n}\n```\n\n유틸리티: 이 폴더는 외부 API나 로컬 라이브러리를 위한 \"도우미\" 파일들의 집입니다. 여기에는 Firebase 헬퍼 클래스, OneSignal 헬퍼 클래스 또는 우리 프로젝트에서 문자열을 포맷하는 함수를 포함하는 내 StringHelper 클래스와 같은 것들이 들어갈 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\nStyles: 테마와 스타일을 포함하므로 직관적입니다.\n\nCommons.dart: 이 파일은 앱에서 사용되는 모든 것을 주요 \"import\"로 사용합니다. 이렇게 하면 파일에서 하나의 파일만 가져오면 빠른 리팩터링, 변경 또는 라이브러리 추가에도 도움이 됩니다.\n\n![이미지](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_2.png)\n\n이 구조를 사용하면 큰 프로젝트조차도 상당히 조직화하여 귀하의 삶을 훨씬 쉽게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# UI와 코드의 분리\n\n우리 모두 알다시피, Flutter는 의견이 강제되지 않아서 코드를 자유롭게 작성할 수 있습니다. Flutter에서 부족하다고 생각했던 한 가지는 Native Android(xml + kt 파일)나 심지어 사랑하는 과거 기술인 Apache Flex(MXML으로 UI를 작성하고 코드는 AS로 분리)처럼 코드와 UI를 분리하는 것이었습니다. 개발자 친구와 함께 이를 논의한 결과, Roipeker님의 제안을 토대로 이 아이디어를 실현했습니다. 이것이 바로 우리가 여기에 있는 이유입니다(Roipeker님 감사합니다).\n이 아이디어의 핵심은 각 화면이 UI를 포함하는 한 개의 파일과 화면의 모든 기능, 변수, 작동 코드를 포함하는 다른 파일로 분리된다는 것입니다.\nREST API에서 뉴스 목록이 포함된 화면의 예시를 살펴보겠습니다.\n\n![News screen](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_3.png)\n\n\"뉴스\" 화면은 UI를 포함하는 *_screen.dart 파일과 기능을 포함하는 *_controller.dart 파일로 나뉘어 있음을 확인할 수 있습니다. 이를 달성하기 위해, screen.dart에서 \"part 'news_controller.dart'\"를 사용하고, controller.dart 파일에서는 \"part of 'news_screen.dart'\"를 사용합니다. 이렇게 두 파일이 하나처럼 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image1](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_4.png)\n\nYou can see that the first file is simple and only contains the UI part.\n\n![image2](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_5.png)\n\nThis is the controller file which is used to load the news and sort them. As you can see, the newsList is loaded with content in the `controller.dart` and used in the `screen.dart`.\n\n\n<div class=\"content-ad\"></div>\n\n이것은 간단한 예제이지만 코드를 정리하고 깨끗하게 유지하는 두 파일을 가지는 가치를 볼 수 있습니다.\n\n더 나아가서 개발 시간을 최소화하는 것을 목표로 이를 더 발전시키기 위해 Android Studios에서 File 및 Code 템플릿으로 통합했습니다. 이렇게 하면 각 새로운 화면을 빠르게 만들 수 있습니다.\n\n# 2개 파일의 화면 구조에 대한 템플릿 만들기\n\n이를 템플릿에 추가하려면 다음 단계를 따라야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![screenshot](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_6.png)\n\n- 파일 — 설정 — 코드 스타일 — 파일 및 코드 템플릿\n- 새 항목 추가\n- 아무 이름으로 지정 (저는 뷰 상태를 이름으로 사용했습니다)\n\n![screenshot](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_7.png)\n\n- 파일 이름은 $'NAME'_screen이어야 합니다\n- 확장자는 dart여야 합니다\n- 메인 파일 (screen.dart)에 대한 다음 코드 사용\n\n\n<div class=\"content-ad\"></div>\n\n\n#set($class = ${NAME})\n#set($class_start = $class.substring(0,1).toUpperCase())\n#set($class_rest = $class.substring(1).toLowerCase())\n#set($class = $class_start + $class_rest)\n\npart '${NAME}_controller.dart';\n\nclass ${class}Screen extends StatefulWidget {\n  const ${class}Screen({Key? key}) : super(key: key);\n\n  @override\n  createState() => _${class}Screen();\n}\n\nclass _${class}Screen extends ${class}Controller {\n  @override\n  Widget build(BuildContext context) {\n    return Container();\n  }\n}\n\n\n7. 메인 파일 아래에 다음 코드와 함께 자식 템플릿 파일을 만듭니다.\n\n\n#set($class = ${NAME})\n#set($class_start = $class.substring(0,1).toUpperCase())\n#set($class_rest = $class.substring(1).toLowerCase())\n#set($class = $class_start + $class_rest)\n\npart of '${NAME}_screen.dart';\n\nabstract class ${class}Controller extends State<${class}Screen> {\n\n  @override\n  void initState() {\n    // TODO: initState 구현\n    super.initState();\n  }\n\n  @override\n  void dispose() {\n    // TODO: dispose 구현\n    super.dispose();\n  }\n}\n\n\n8. 자식 템플릿 파일을 '$'NAME'_controller.dart'로 명명하고 확장자는 이전과 동일한 dart로 설정합니다.\n  \n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_8.png)\n\n9. 적용 및 확인을 눌러 완료합니다\n\n이후에는 폴더로 이동하여 새로운 테스트 폴더(screens-test)를 생성한 다음 해당 폴더에서 마우스 오른쪽 버튼을 클릭하여 — 새로 만들기 — View State — 이름을 지정하세요.\n그러면 name_screen 및 name_controller 두 파일이 생성됩니다.\n\n제가 앞서 말했듯이, 이것은 제 팀이 코드를 구성하는 방식일 뿐이며 다양한 방법이 있지만, 2019년 첫 번째 Flutter 프로젝트의 엉망으로부터 잘 구성되고 유지 관리가 빠른 방식으로 나아가게 도와준 것을 잠시 공유하고 싶었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 메서드를 좋아하신다면, 귀하의 프로젝트에 통합하고 플러터 개발자 동료들과 공유하며 박수 치는 것을 잊지 마세요.","ogImage":{"url":"/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png"},"coverImage":"/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png","tag":["Tech"],"readingTime":6},{"title":"플러터에서 최고의 Bloc 상태 관리 파트 2","description":"","date":"2024-05-20 23:15","slug":"2024-05-20-BestBlocstatehandlinginFlutterpart2","content":"\n안녕하세요, 친구들,\n첫 번째 파트에 대한 좋은 피드백에 기쁩니다.\n이번 파트에서는 디자인에서 EventStatus를 사용하는 방법을 가르치고 디자인의 모든 상태를 다루는 것을 알려드리고 싶어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:580/1*wL6d8JPLeO4MbkwBPLHwcA.gif)\n\n지난 파트에서는 Bloc_state에서 상태를 다루기위해 EventStatus 클래스를 사용했었습니다.\n\nhttps://medium.com/@moeinmoradi.dev/best-bloc-state-handling-in-flutter-0f95a8e89e40\n\n<div class=\"content-ad\"></div>\n\n제 친구 한 명의 제안에 따라, EventStatus 클래스에 대해 좀 더 나은 컨셉을 제안하고 그 이름을 StateStatus로 변경해보겠습니다. 다음과 같이 변경해주세요.\n\n```js\n@immutable\nabstract class StateStatus<T> {\n  final int? itemId;\n  final T? data;\n  final ErrorModel? message;\n\n  const StateStatus({\n    this.itemId,\n    this.data,\n    this.message,\n  });\n}\n\nclass StateLoading<T> extends StateStatus<T> {\n  const StateLoading({super.itemId});\n}\n\nclass StateCompleted<T> extends StateStatus<T> {\n  const StateCompleted({required super.data});\n}\n\nclass StateInitial<T> extends StateStatus<T> {}\n\nclass StateError<T> extends StateStatus<T> {\n  const StateError({required super.message});\n}\n```\n\n좋아요, StateStatusLayout를 위한 클래스를 만들어봅시다.\n\n# StateStatusLayout\n\n<div class=\"content-ad\"></div>\n\nStateStatus에 따라 다른 디자인 상태를 표시하는 클래스가 필요합니다. 이 클래스는 각 상태와 해당 위젯을 표시할 수 있어야 합니다.\n\n이 클래스에서 BlocBuilder로부터 StateStatus를 받고 States에 따라 위젯을 반환했습니다 :\n\n```js\nclass StateStatusLayout<T> extends StatelessWidget {\n  final StateStatus<T> status;\n  final Widget onErrorStatus;\n  final void Function(ErrorModel error)? onErrorListener;\n  final Widget Function(BuildContext context, T? data) onCompletedStatus;\n  final Widget onInitialStatus;\n  final Widget onLoadingStatus;\n  const StateStatusLayout({\n    super.key,\n    required this.status,\n    required this.onCompletedStatus,\n    required this.onErrorStatus,\n    required this.onInitialStatus,\n    required this.onLoadingStatus,\n    this.onErrorListener,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    if (status is StateError) {\n      if (onErrorListener != null) {\n        onErrorListener!(status.message!);\n      }\n    }\n    if (status is StateCompleted) {\n      return StreamBuilder(\n        stream: Stream.value(status),\n        builder: (context, snapshot) {\n          log(status.data!.toString());\n          return onCompletedStatus(context, status.data);\n        },\n      );\n    }\n    if (status is StateError) {\n      return onErrorStatus;\n    }\n    if (status is StateInitial) {\n      return onInitialStatus;\n    }\n    if (status is StateLoading) {\n      return onLoadingStatus;\n    }\n    return Container();\n  }\n}\n```\n\n그런데, StateCompleted 조건을 살펴보세요. 데이터를 표시하기 위해 StreamBuilder를 사용했습니다. 이것에 대해 어떻게 생각하시나요?\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:700/1*I6k_gZJ0KRZYR4KU22Okig.gif)\n\n가끔 블록 쪽에서 데이터를 페이지네이션하거나 스트리밍해야 할 때, 위젯은 반드시 모든 상황에서 업데이트되어야 합니다. 그리고 위젯에서 오류가 발생하지 않도록하기 위해 이러한 가능한 상황을 고려하기 위해 StreamBuilder를 사용합니다.\n\n간단한 샘플 코드를 보여드리겠습니다. StateStatusLayout을 사용한 코드입니다:\n\n```js\nimport 'package:flutter/material.dart';\n\nclass ShowLayout extends StatelessWidget {\n  const ShowLayout({Key? key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<ShowBloc, ShowState>(\n        builder: (context, state) {\n          return StateStatusLayout(\n            status: state.showsStatus,\n            onCompletedStatus: (context, data) {\n              return GridView.count(\n                shrinkWrap: true,\n                padding: const EdgeInsets.all(10),\n                physics: const ClampingScrollPhysics(),\n                crossAxisSpacing: 10,\n                mainAxisSpacing: 20,\n                crossAxisCount: 4,\n                childAspectRatio: 9 / 16,\n                children: List.generate(data!.shows!.length, (index) {\n                  ShowModel item = data.shows![index];\n                  return ShowCard(\n                      show: item,\n                      onSelected: () {\n                        /// do Somethigs...\n                      },\n                    );\n                }),\n              );\n            },\n            onErrorStatus: const SizedBox(),\n            onInitialStatus: const SizedBox(),\n            onLoadingStatus: Padding(\n              padding: const EdgeInsets.all(48.0),\n              child: SizedBox(\n                width: 50,\n                height: 50,\n                child: SpinKitRipple(\n                  color: themeData.colorScheme.secondary,\n                  size: 40,\n                ),\n              ),\n            ),\n          );\n        },\n      );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 샘플 코드에서는 Bloc이 emit() 함수로 갱신될 때 showsStatus 상태에 대한 onCompletedStatus 및 onLoadingStatus를 처리했습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1280/1*XwwugAFY35KNciVoDHThEw.gif)\n\n## 지금까지 함께 해주셔서 감사합니다\n\n나와 함께 계속 이야기를 공유해주시고 피드백을 기다리고 있습니다. 분들의 소중한 의견을 기다리고 있습니다. 🙏\n","ogImage":{"url":"/assets/img/2024-05-20-BestBlocstatehandlinginFlutterpart2_0.png"},"coverImage":"/assets/img/2024-05-20-BestBlocstatehandlinginFlutterpart2_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터 3.22에 새로 추가된 내용 정리","description":"","date":"2024-05-20 23:13","slug":"2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings","content":"\n\n## 플러터 3.22 릴리스는 웹 어셈블리, 불칸 그래픽, 위젯 상태 향상 등을 포함하고 있습니다\n\n![이미지](/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png)\n\n이 글에서는 플러터 3.22의 새로운 기능을 알아보겠습니다. 플러터 3.22에서는 성능 향상을 위해 웹 어셈블리 지원과 안드로이드에서 더 부드러운 그래픽을 위한 불칸 백엔드가 소개되었습니다. 위젯 상태 관리가 **위젯 상태 속성**과 함께 강화되었으며, **동적 뷰 크기 조정**으로 UI 적응성이 향상되었습니다. 또한 **개선된 폼 유효성 검증**을 통해 사용자 입력 처리를 강화했습니다.\n\n**플레이버 조건부 자산 번들링**을 통해 앱 플레이버를 기반으로 선택적 자산 번들링이 가능하게 되었으며, **Gradle Kotlin DSL 지원**은 코드 편집을 개선했습니다. iOS에서 플랫폼 뷰 성능이 **스크롤링에 특히 더 나아졌습니다.** Firebase Dart SDK 미리보기를 통해 **Vertex AI**를 활용한 AI 기능을 구현할 수 있으며, **Google Mobile Ads SDK 5.0.1**은 **UMP SDK** 및 더 많은 중재 파트너에 대한 향상된 지원을 제공합니다. 이러한 업데이트는 플러터에서 앱 성능, 사용자 경험 및 개발자 생산성을 향상시키기 위해 종합적으로 목표로 하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서, 플러터 3.22 릴리스에서의 탑 10 업데이트를 소개할게요:\n\n1. WebAssembly 지원\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*JPFkftr0XrFTo1zLm8U3WQ.gif)\n\n플러터 3.22의 WebAssembly (Wasm) 지원은 웹 앱 개발에 큰 도약이에요. Wasm은 코드를 브라우저가 효율적으로 실행할 수 있는 바이너리 형식으로 컴파일함으로써, 플러터 웹 앱이 거의 네이티브 속도로 실행되도록 해줍니다.\n\n<div class=\"content-ad\"></div>\n\n전통적인 웹 기술과 비교했을 때, 이는 혁신적인 성능 향상을 가져옵니다. 게다가, Wasm은 주요 웹 브라우저에서 널리 지원되어 Flutter 웹 앱에 대한 광범위한 호환성을 보장합니다. Wasm을 활용함으로써 Flutter는 코드 크기를 줄이고 빠른 로드 시간 및 향상된 전반적인 성능을 제공합니다. 게다가, Wasm은 빠르게 발전하는 기술로, 앞으로 더 많은 향상이 기대됩니다.\n\n전반적으로, Flutter 3.22에서의 Wasm 지원은 웹 개발을 위한 플랫폼 기능을 향상시켜 개발자에게 고성능 웹 애플리케이션을 구축하는 강력하고 효율적인 도구를 제공합니다.\n\n2. Impeller를 위한 Vulkan Backend\n\nFlutter 3.22에서 Impeller의 Vulkan 백엔드는 안드로이드에서 Flutter 앱에서 사용되는 렌더링 엔진에 대한 중요한 향상입니다. Vulkan은 현대적인 GPU에 대한 고효율적이고 크로스 플랫폼 액세스를 제공하는 저부하, 크로스 플랫폼 3D 그래픽 및 컴퓨팅 API입니다.\n\n<div class=\"content-ad\"></div>\n\n임펠러에 Vulkan을 통합함으로써, 플러터는 Vulkan의 능력을 활용하여 그래픽을 더 효율적으로 렌더링할 수 있어 안드로이드 기기에서 플러터 앱의 그래픽이 더 부드럽고 성능이 향상될 수 있습니다. 이 향상은 특히 애니메이션과 풍부한 전환 효과를 갖는 앱에 유용하며, 부드러운 프레임 속도를 유지하고 전반적인 사용자 경험을 향상시킵니다.\n\n### 위젯 상태 속성\n\n플러터 3.22의 위젯 상태 속성은 위젯이 외관과 동작을 어떻게 추적하는지에 관한 것입니다. 플러터는 이를 관리하는 특별한 방법인 \"매터리얼 상태(MaterialState)\"라는 것을 갖고 있습니다. 이번 업데이트에서 매터리얼 상태는 \"위젯 상태(WidgetState)\"로 이름이 변경되었으며 플러터의 더 많은 부분에서 사용할 수 있습니다.\n\n이 변경으로 개발자는 위젯이 어떻게 보이고 작동하는지를 더 쉽게 제어할 수 있게 되었으며, 이는 잘 작동하고 멋지게 보이는 플러터 앱을 만드는 데 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n4. 동적 뷰 크기 조정\n\nFlutter 3.22에서의 동적 뷰 크기 조정은 반응형 레이아웃을 처리하는 프레임워크의 기능을 향상시키는 기능입니다. 이 기능은 위젯이 사용 가능한 화면 공간에 기반하여 크기를 조절하도록 개선합니다. 이는 작은 스마트폰부터 큰 태블릿까지 다양한 기기에 걸쳐 일관적이고 매력적인 사용자 인터페이스를 만들 때 특히 유용합니다.\n\n이 업데이트 이전에, 개발자들은 종종 다양한 화면 크기에서 올바르게 표시되도록 위젯의 크기를 수동으로 계산하고 설정해야했습니다. 동적 뷰 크기 조정을 통해, 개발자들은 `Expanded`, `Flexible`, `MediaQuery`와 같은 기능을 사용하여 레이아웃을 생성할 수 있습니다. 이를 통해 위젯 크기를 화면의 차원에 따라 동적으로 조정할 수 있습니다.\n\n예를 들어, `Expanded` 또는 `Flexible` 컨테이너로 래핑된 위젯은 자동으로 확장 또는 축소하여 사용 가능한 공간을 채울 수 있어 반응형 디자인을 쉽게 만들 수 있습니다. 마찬가지로, `MediaQuery` 클래스를 사용하면 현재 화면 크기를 조회하고 위젯 크기를 조정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n동적 뷰 크기 조정은 반응형 플러터 레이아웃을 만드는 프로세스를 간단화해줍니다. 이는 다양한 기기와 화면 크기에서 일관된 사용자 경험을 제공하는 앱을 결과적으로 만들어냅니다.\n\n5. 폼 유효성 검사 개선\n\nFlutter 3.22에서 개선된 폼 유효성 검사는 사용자 입력을 다루는 더 유연하고 견고한 방법을 제공합니다. 이러한 향상된 기능은 개발자들이 사용자 입력을 어떻게 유효성을 검사할지 더 많은 제어력을 제공하며, 특정 애플리케이션 요구에 맞게 사용자 정의 유효성 검사 로직을 구현할 수 있게 해줍니다.\n\n이 개선된 유효성 검사 능력은 더 사용자 친화적인 경험으로 이어지며, 잘못된 데이터를 입력할 때 앱이 사용자에게 보다 정확한 피드백을 제공할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n또한, 이러한 향상된 기능은 인젝션 공격과 같은 보안 취약점을 예방하여 증가된 보안을 제공합니다. 총괄적으로 말하면, Flutter 3.22에서 개선된 양식 유효성 검사는 Flutter 앱의 사용성, 보안 및 유연성을 강화하며, 더 견고하고 사용자 친화적인 애플리케이션을 개발하는 데 강력한 도구를 제공합니다.\n\n6. 플레이버 조건부 자산 번들링\n\nFlutter 3.22의 플레이버 조건부 자산 번들링은 개발자들이 앱의 여러 버전 또는 \"플레이버\" 간에 효과적으로 자산을 관리할 수 있는 기능입니다. 이 기능을 통해 개발자는 앱의 플레이버에 기초하여 어떤 자산(예: 이미지, 폰트, 또는 설정 파일)을 앱 번들에 포함해야 하는지 지정할 수 있습니다.\n\n이는 특정 버전의 앱에 특정한 자산(예: 브랜드 자산 또는 설정 파일)을 포함시킬 수 있으면서 다른 버전의 앱에 영향을 미치지 않게 됨을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n자산을 이렇게 정리함으로써, 개발자들은 더 깔끔하고 조직화된 코드베이스를 유지할 수 있어 필요할 때 자산을 관리하고 업데이트하기가 더 쉬워집니다. 또한 각 버전에 필요한 자산만 포함함으로써, 앱 번들의 전체 크기를 줄일 수 있어 사용자들에게 빠른 다운로드 및 시작 시간을 제공할 수 있습니다.\n\n전반적으로, Flavor-Conditional Asset Bundling은 개발 프로세스를 향상시키고 Flutter 앱의 성능을 향상시키는 가치 있는 기능입니다.\n\n7. Gradle Kotlin DSL 지원\n\nFlutter 3.22에서의 Gradle Kotlin DSL 지원은 개발자들이 Gradle 빌드 스크립트를 작성할 때 Groovy 대신 Kotlin을 사용할 수 있게 해주는 기능입니다.\n\n<div class=\"content-ad\"></div>\n\nKotlin은 Groovy보다 여러 가지 이점을 제공하는 현대적이고 표현력 있는 프로그래밍 언어입니다. 이점으로는 더 나은 타입 안전성, 널 안전성, 그리고 향상된 도구 지원이 있습니다. Gradle Kotlin DSL 지원을 통해, 개발자들은 Flutter 프로젝트용 빌드 스크립트를 작성할 때 이러한 이점을 활용할 수 있습니다.\n\n이는 더 읽기 쉽고 유지보수하기 쉽며 견고한 빌드 스크립트로 이어져, 결국 Flutter 개발자들의 전체 개발 경험을 향상시킬 수 있습니다.\n\n8. 플랫폼 뷰 성능 개선 (iOS)\n\nFlutter 3.22에서의 플랫폼 뷰 성능 개선은 iOS 앱 내에서 플랫폼 뷰의 성능을 향상시키는 데 초점을 맞춥니다. 플랫폼 뷰는 지도나 웹 뷰와 같은 네이티브 구성 요소를 Flutter 앱에 통합하는 데 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n다음 업데이트는 주로 여러 플랫폼 뷰가 자주 사용되는 스크롤 뷰 내의 성능을 대상으로 합니다. 개선 사항에는 GPU 사용량이 50% 감소하여 배터리 효율성이 향상되고 사용자 상호 작용이 더 부드러워질 수 있는 잠재적인 이점이 포함되어 있습니다.\n\n게다가, 평균 프레임 렌더 시간이 1.66ms만큼 줄어든 것으로 (33%의 향상), 최악의 경우 렌더 시간은 3.8ms만큼 감소하여 (21%의 향상) 스무스한 애니메이션과 스크롤 중에 버벅임이 줄어들어 더 나은 경험을 제공하게 되었습니다.\n\n이러한 최적화는 iOS 기기에서 플랫폼 뷰를 활용하는 Flutter 앱의 성능을 현저히 향상시키도록 설계되었으며, 사용자에게 더 부드럽고 반응성 있는 경험을 제공합니다.\n\n9. Firebase Dart SDK 미리보기용 Vertex AI\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_1.png)\n\n플러터 3.22에 대한 Vertex AI for Firebase Dart SDK 미리보기는 제니미 API를 소개합니다. 이를 통해 개발자들은 자체 Dart 또는 Flutter 앱에 생성 AI 기능을 통합할 수 있습니다.\n\n이 SDK는 생산 수준의 성능과 확장성을 제공하며 Firebase App Check와의 통합으로 보안을 강화합니다. 개발자들은 이 SDK를 사용하여 이미지 및 텍스트 생성과 같은 제니미 API의 기능을 앱에서 사용할 수 있습니다.\n\n이 미리보기 릴리스는 프로모션 코드로 무료로 제공되며, 개발자들은 앱에 통합하기 전에 SDK의 기능을 탐색하고 테스트할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n10. Google Mobile Ads SDK 5.0.1\n\n플러터 3.22의 Google Mobile Ads SDK 5.0.1은 광고로 Flutter 앱을 수익화하는 개발자들을 위한 여러 개선 사항을 가져왔어요.\n\n이 업데이트에는 사용자 메시징 플랫폼 (UMP) SDK에 대한 향상된 지원이 포함되어 있어요. 개인화된 광고에 대한 동의 수집 프로세스를 간소화하기 위한 새로운 API가 제공돼요. 게다가 이제 SDK는 Unity, Meta, AppLovin, Iron Source, Mintegral, Pangle, DT Exchange, InMobi, Liftoff를 포함한 확장된 중개 파트너를 지원해요.\n\n이러한 통합은 개발자들에게 더 많은 기회를 제공하여 앱 수익을 극대화하는 광고 수익화 옵션을 확대시켜 줘요.\n\n<div class=\"content-ad\"></div>\n\n요약하자면, Flutter 3.22는 앱 개발자들을 위한 몇 가지 큰 개선 사항을 가져왔습니다. 그들은 그래픽 및 애니메이션에 특히 빠르고 부드러운 사용을 가능하게 만들었습니다. 또한 이미지 및 폰트와 같은 앱 자산을 구성하고 관리하는 새로운 방법을 추가하여 앱을 구축하고 유지하는 것을 더 쉽게 만들었습니다. 게다가 Android 및 iOS용으로 더 나은 딥 링크 지원 및 부드러운 스크롤링을 위한 멋진 새로운 기능이 추가되었습니다.\n\n전반적으로, Flutter 3.22는 훌륭한 앱을 만드는 것을 더 쉽고 재미있게 만들어줍니다. 또한 이 정보는 다양한 웹사이트를 조사하여 수집했습니다. 잘못된 정보나 오해된 정보가 있는 경우 아래 댓글로 알려주시면 감사하겠습니다.\n\n내용 중 오류가 있었다면 댓글에 언급해주세요. 개선하고 싶어합니다. 여러분의 지원은 저에게 매우 큰 의미를 갖습니다! 만족스러우셨다면 구독 고려해 주시면 감사하겠습니다.\n\n저는 Sherish Shukla입니다, 창의적인 개발자이자 기술 애호가입니다. LinkedIn에서 저를 찾을 수도 있고 Twitter에서도 팔로우할 수 있으며 자세한 내용을 보려면 포트폴리오로 가보세요. 물론 GitHub에서도 팔로우해 주시면 감사하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n좋은 하루 되세요!🙂","ogImage":{"url":"/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png"},"coverImage":"/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png","tag":["Tech"],"readingTime":7}],"page":"61","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}