{"pageProps":{"posts":[{"title":"Angular 16 Signals 완벽 설명 5가지 예제로 배우는 법","description":"","date":"2024-06-22 03:19","slug":"2024-06-22-Angular16SignalsExplainedWithFiveExamples","content":"\n\nMarkdown 형식으로 테이블 태그를 변경해 주세요.\n\n<div class=\"content-ad\"></div>\n\n시그널의 값은 항상 게터 함수를 통해 읽습니다. 이는 Angular이 시그널이 사용된 위치를 추적할 수 있게 합니다.\n\n그래서 이 개념을 실제로 적용하고 TypeScript에서 몇 가지 실용적인 예제로 배워봅시다:\n\n## 예제 1: 시그널을 사용하여 총 가격 업데이트하기\n\n가정해보죠. 사용자가 쇼핑 카트에 항목을 추가할 수 있는 전자 상거래 애플리케이션을 가지고 있다고 해봅시다. 항목의 총 가격을 표시하고 새 항목이 추가되거나 제거될 때마다 업데이트하고 싶습니다. 이를 달성하기 위해 시그널을 사용하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n  selector: 'my-cart',\n  template: `\n    <ul>\n      <li *ngFor=\"let item of items\">\n        {item.name} - ${item.price}\n        <button (click)=\"removeItem(item)\">Remove</button>\n      </li>\n    </ul>\n    Total Price: ${totalPrice()}\n  `,\n})\nexport class CartComponent {\n  items = [    { name: 'Product A', price: 10 },    { name: 'Product B', price: 15 },    { name: 'Product C', price: 20 },  ];\n  \n  // 장바구니의 항목 목록을 위한 신호인 itemList을 정의합니다.\n  itemList = signal(this.items);\n  \n  // 총 가격을 위한 계산된 값인 totalPrice를 정의합니다.\n  totalPrice = computed(() => {\n    return this.itemList().reduce((acc, curr) => acc + curr.price, 0);\n  });\n  \n  removeItem(item) {\n    // 선택한 항목을 제거하여 itemList 신호를 업데이트합니다.\n    this.itemList.set(this.itemList().filter((i) => i !== item));\n  }\n}\n```\n\n이 예제에서는 장바구니에 있는 항목 목록을 나타내는 신호인 itemList을 정의하고, itemList에 의존하는 총 가격인 totalPrice를 계산된 값으로 정의합니다. 장바구니에서 항목을 제거할 때 itemList 신호를 업데이트하여 totalPrice를 다시 계산합니다.\n\n## 예제 2: 신호를 사용하여 로딩 스피너를 보이거나 숨기기\n\nAPI에서 데이터를 가져와 테이블에 표시하는 컴포넌트가 있다고 가정해봅시다. 데이터를 가져오는 동안 로딩 스피너를 표시하려고 합니다. 이를 신호를 사용하여 구현하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n  selector: 'my-table',\n  template: `\n    <div *ngIf=\"isLoading()\">\n      Loading...\n    </div>\n    <table *ngIf=\"!isLoading()\">\n      <thead>...</thead>\n      <tbody>...</tbody>\n    </table>\n  `,\n})\nexport class TableComponent {\n  // 로딩 상태를 위한 신호 loading을 정의하고 초기값을 true로 설정합니다.\n  \n  loading = signal(true);\n  \n  ngOnInit() {\n    // API에서 데이터를 가져옵니다.\n    fetchData().subscribe((data) => {\n      // 데이터가 수신되면 로딩 신호를 false로 업데이트합니다.\n      this.loading.set(false);\n      \n      // 테이블에 데이터를 렌더링합니다.\n      ...\n    });\n  }\n  \n  isLoading() {\n    return this.loading();\n  }\n}\n```\n\n이 예제에서는 로딩 상태를 나타내는 신호 loading을 정의하고 초기값을 true로 설정합니다. 컴포넌트가 초기화될 때 API에서 데이터를 가져와 데이터를 수신했을 때 로딩 신호를 false로 업데이트합니다. isLoading 메서드는 현재 로딩 신호의 값을 반환하며, 이 값은 로딩 스피너 또는 테이블을 조건부로 렌더링하는 데 사용됩니다.\n\n## 예제 3: 응용 프로그램에서 반응형 프로그래밍을 위한 신호 사용\n\n이 예제에서는 여러 가지 신호, 계산된 신호 및 이펙트를 활용하여 더 복잡한 시나리오에서의 사용법을 시연합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { signal, computed, effect } from 'signal';\n\n// Writable signals\nconst firstName = signal('John');\nconst lastName = signal('Doe');\nconst age = signal(30);\n\n// Computed signal to calculate the full name\nconst fullName = computed(() => `${firstName()} ${lastName()}`);\n\n// Computed signal to determine if the person is an adult\nconst isAdult = computed(() => age() >= 18);\n\n// Effect to log the full name and adult status whenever any of the signals change\neffect(() => {\n  console.log(`Full Name: ${fullName()}`);\n  console.log(`Is Adult: ${isAdult()}`);\n});\n\n// Update the values of the writable signals\nfirstName.set('Jane');\nlastName.set('Smith');\nage.set(25);\n```\n\n여기 예제에서는 세 가지 쓰기 가능한 시그널이 있습니다: firstName, lastName 및 age입니다. firstName과 lastName을 결합하는 fullName 및 나이를 기반으로 사람이 성인인지 여부를 결정하는 isAdult라는 두 개의 계산된 시그널을 만듭니다. 그런 다음, 시그널이 변경 될 때마다 전체 이름 및 성인 여부를 기록하는 효과를 만듭니다.\n\n쓰기 가능한 시그널의 값을 업데이트하면, 해당 값이 변경되었을 때 효과가 실행되어 업데이트된 전체 이름과 성인 여부가 기록됩니다.\n\n이 예제는 시그널, 계산된 시그널 및 효과가 데이터의 변경을 추적하고 반응하여 애플리케이션에서 반응형 프로그래밍을 가능하게 하는 방법을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 예제 4: 다양한 조건에 따라 데이터를 필터링, 정렬 및 계산하는 신호 사용\n\n이 예제는 여러 신호를 통합하고 종속성을 가진 계산된 신호 및 효과를 포함하여 더 복잡한 시나리오를 다룹니다:\n\n```js\nimport { signal, computed, effect } from 'signal';\n\n// 쓰기 가능한 신호\nconst todos = signal([\n  { id: 1, title: '장보기', completed: false },\n  { id: 2, title: '세탁하기', completed: true },\n  { id: 3, title: '개 산책시키기', completed: false }\n]); // 할 일 목록\n\nconst showCompleted = signal(false); // 완료된 할 일을 표시해야 하는지 여부를 나타내는 플래그\n\n// showCompleted 플래그에 기반하여 할 일을 필터링하고 정렬하는 계산된 신호\nconst filteredTodos = computed(() => {\n  const filtered = todos().filter(todo => showCompleted() || !todo.completed);\n  return filtered.sort((a, b) => a.id - b.id);\n});\n\n// 남은 할 일 수를 계산하는 계산된 신호\nconst remainingTodosCount = computed(() =>\n  todos().reduce((count, todo) => (todo.completed ? count : count + 1), 0)\n);\n\n// 변경 시 필터링된 할 일과 남은 수를 로그하는 효과\neffect(() => {\n  console.log('필터링된 할 일:');\n  console.log(filteredTodos());\n  console.log(`남은 할 일 수: ${remainingTodosCount()}`);\n});\n\n// 쓰기 가능한 신호의 값 업데이트\ntodos.mutate(value => {\n  value.push({ id: 4, title: '집 청소하기', completed: false });\n  value[1].completed = false;\n});\n\n// showCompleted 플래그 업데이트\nshowCompleted.set(true);\n```\n\n이 예제에서는 할 일 목록을 나타내는 쓰기 가능한 신호 todos가 있습니다. 또한 완료된 할 일을 표시해야 하는지를 나타내는 쓰기 가능한 신호 showCompleted가 있습니다. showCompleted 플래그에 따라 할 일을 필터링하고 정렬하는 computed 신호 filteredTodos를 생성합니다. 추가로, 남은 할 일 수를 계산하는 computed 신호 remainingTodosCount를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 그런 다음, 변경될 때마다 필터된 할 일 목록과 남은 항목 수를 기록하는 효과를 만듭니다. 결정이 변경될 때마다 이 효과가 여러 번 실행됩니다.\n\n할 일 목록을 업데이트하고 showCompleted 플래그를 변경하는 경우와 같이 쓰기 가능한 시그널의 값을 업데이트할 때, 이 효과가 실행되어 업데이트된 필터된 할 일 목록과 남은 항목 수를 기록합니다. 마지막으로 showCompleted 플래그를 업데이트하여 새로운 필터된 할 일 목록으로 다시 효과를 트리거합니다.\n\n이 예제에서는 시그널, 계산된 시그널 및 효과가 어떻게 함께 작동하여 필터링, 정렬 및 다양한 조건에 따라 데이터를 계산하는 복잡한 시나리오를 처리하는지 보여줍니다.\n\n## 예제 5: 다수의 사용자가 공유하고 수정할 수 있는 장보기 목록 애플리케이션을 구현하는 데 시그널을 사용하는 예시\n\n<div class=\"content-ad\"></div>\n\n여기 신호(Signals)를 활용하여 다수 사용자가 공유하고 수정할 수 있는 식료품 쇼핑 목록 애플리케이션을 만드는 방법 예제가 있어요.\n\n```js\n@Component({\n  selector: 'my-grocery-list',\n  template: `\n    <h2>식료품 목록:</h2>\n    <ul>\n      <li *ngFor=\"let item of items\">\n        {item.name} - {item.quantity} - 최종 편집자: {item.lastEditedBy}\n        <button (click)=\"removeItem(item)\">삭제</button>\n      </li>\n    </ul>\n    <h3>아이템 추가:</h3>\n    <form (submit)=\"addItem()\">\n      <input type=\"text\" [(ngModel)]=\"newItemName\" placeholder=\"이름\">\n      <input type=\"number\" [(ngModel)]=\"newItemQuantity\" placeholder=\"수량\">\n      <button type=\"submit\">추가</button>\n    </form>\n  `,\n})\nexport class GroceryListComponent {\n  items = [    { name: '사과', quantity: 5, lastEditedBy: null },    { name: '바나나', quantity: 3, lastEditedBy: null },    { name: '우유', quantity: 1, lastEditedBy: null },  ];\n  \n  // 아이템 목록에 대한 신호(signal) 정의\n  itemList = signal(this.items);\n  \n  // 현재 사용자의 이름에 대한 신호(signal) 정의\n  currentUser = signal('남편');\n  \n  addItem() {\n    // 현재 사용자의 이름을 마지막으로 편집한 값으로 하는 새로운 항목을 itemList 신호에 추가\n    this.itemList.set([...this.itemList(), { name: this.newItemName, quantity: this.newItemQuantity, lastEditedBy: this.currentUser() }]);\n    \n    // 입력 필드를 지웁니다\n    this.newItemName = '';\n    this.newItemQuantity = '';\n  }\n  \n  removeItem(item) {\n    // 선택한 항목을 itemList 신호에서 제거\n    this.itemList.set(this.itemList().filter((i) => i !== item));\n  }\n}\n```\n\n이 예제에서는 식료품 쇼핑 목록의 항목 리스트를 위한 itemList 신호와 현재 사용자의 이름을 위한 currentUser 신호를 정의했습니다. 새 항목을 추가하거나 기존 항목을 제거할 때 itemList 신호를 업데이트하여 뷰의 재계산이 일어나도록 합니다. 또한 수정된 항목의 lastEditedBy 속성을 currentUser 신호의 현재 값으로 설정합니다.\n\naddItem 메서드는 현재 사용자의 이름을 lastEditedBy 값으로 하는 새 항목을 itemList 신호에 추가합니다. removeItem 메서드는 선택한 항목을 itemList 신호에서 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n이 글을 읽어주셔서 감사합니다. 제 글이 유익하고 생각을 자극했기를 바랍니다.\n\n만약 여러분이 이 글을 지금까지 즐겁게 읽으셨다면, 제 Medium 페이지를 팔로우하시고 박수를 쳐주세요! 🙂\n\n![image](/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_1.png)\n\n팔로우하신다면 댓글 섹션에서 다른 분들과 함께 소통할 수 있는 기회도 생기고, 여러분의 의견을 항상 환영합니다. 팔로워 여러분들의 의견을 매우 소중히 여깁니다. 💬🌟\n\n<div class=\"content-ad\"></div>\n\n내 다른 게시물에 대한 링크:\n1. PART ONE: 간단한 예제와 함께 마이크로서비스 애플리케이션에서 사용되는 가장 일반적인 Spring Boot 어노테이션\n2. PART TWO: 간단한 예제와 함께 마이크로서비스 애플리케이션에서 사용되는 가장 일반적인 Spring Boot 어노테이션\n3. MySQL 및 Rest 엔드포인트를 사용하는 간단한 Spring Boot 애플리케이션\n4. Spring Boot를 사용하여 마이크로서비스 애플리케이션에서 REST API를 개발할 때 따를 가장 좋은 방법들","ogImage":{"url":"/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_0.png"},"coverImage":"/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_0.png","tag":["Tech"],"readingTime":8},{"title":"Redux에서 Redux Toolkit으로 마이그레이션 3부작 시리즈","description":"","date":"2024-06-22 03:16","slug":"2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries","content":"\n\n## 파트 1: Redux 및 Typescript를 사용하여 애플리케이션 개발하기\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png)\n\n레거시 코드베이스를 React로 이관하는 것은 오래된 개발 방식에서 새로운 방식을 가르치는 것과 비슷합니다. 도전적이지만 보람이 있어요! 저희 애플리케이션 중 하나에서는 Redux Toolkit 없이 Redux를 사용하고 있는데, 이전 방식에 대한 리소스를 찾기는 바늘을 건삭하는 것과 같습니다. 대부분의 현대적인 앱은 이제 Redux Toolkit을 사용하며, 이것은 Redux가 공식적으로 추천하는 방식입니다.\n\n이것이 Redux에서 Redux Toolkit으로 마이그레이션하는 가이드를 작성하게 된 계기예요. 앱에 세련된 업그레이드를 해주는 것으로 생각해보세요! 이 튜토리얼은 3부작 시리즈로 이루어져 있을 것입니다: 먼저 전통적인 Redux를 사용하여 앱을 구축한 다음, Redux Toolkit으로 메이크오버할 거예요.\n\n<div class=\"content-ad\"></div>\n\n간단한 GitHub 프로필 찾기 애플리케이션을 만들어 보세요\n\n![GitHub profile finder](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_1.png)\n\n이 애플리케이션에서는 팔로워 수가 1000을 초과하는 인기 있는 사용자 목록을 선별해 두었습니다. 코딩 세계에서는 인기가 중요하니까요! 코딩 영웅들을 찾아보고 'View Repos' 옵션으로 그들의 공개 저장소로 들어가 보세요. 또한 즐겨찾기한 즐겨찾기기능(데이터 표시 제외)이 있어 좋아하는 사용자를 즐겨찾기할 수 있습니다.\n\n전제 조건\n\n<div class=\"content-ad\"></div>\n\nReact와 TypeScript에 대한 좋은 이해도가 있어야 하며, Redux와 Tailwind CSS의 기본 지식이 필요합니다.\n\nGitHub에서 우리 React 앱의 기본 설정을 찾을 수 있습니다.\n\n이 저장소에 대해:\n이 저장소 내에서, Vite 빌드 도구를 사용하여 구축된 기본 React 애플리케이션을 발견할 수 있습니다. 타입 안전성을 위해 TypeScript를 활용하고, 디자인을 위해 Tailwind CSS를 사용할 것입니다.\n\n이 애플리케이션에 필요한 라이브러리를 설치해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n저희는 인터넷 연결에 Axios를 사용하고 앱을 탐색하기 위해 React Router를 사용하며 물론 상태를 유지하기 위해 Redux를 사용할 것입니다. 이 라이브러리들을 설치해 봅시다!!\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_2.png)\n\n폴더 구조\n\n이 폴더 구조를 계속 사용할 것입니다. 함께 따라오고 싶다면 이 튜토리얼과 함께 feature/old-redux 브랜치를 확인해 주세요. 함께 여정을 즐길까요!\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_3.png)\n\n먼저, 쉬운 작업으로 시작해보죠 - API 요청 설정해보기.\n\n'redux' 폴더 아래에 'services'라는 폴더를 만들고, 그 안에 'index.ts'라는 파일을 만들어봅시다.\n\n이 파일에서는 네 가지 유용한 메소드를 사용하여 조금의 마법을 부릴 겁니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 'fetchTopUsersBySize': 상위 사용자 목록을 가져옵니다.\n- 'fetchUserBySearch': 사용자를 검색합니다.\n- 'fetchReposByUserName': 특정 사용자의 저장소를 검색합니다.\n- 'fetchRepoBySearch': 이름으로 저장소를 검색합니다.\n\n```js\nimport api from '../api';\n\nexport const fetchTopUsersBySize = async (size: number = 30) => {\n  const response = await api.get(\n    `/search/users?q=followers:>1000&sort=followers&order=desc&per_page=${size}`\n  );\n  return response.data;\n};\n\nexport const fetchUserBySearch = async (text: string) => {\n  const response = await api.get(`/search/users?q=${text}`);\n  return response.data;\n};\n\nexport const fetchReposByUserName = async (userName: string) => {\n  const response = await api.get(\n    `/users/${userName}/repos?sort=created&direction=desc`\n  );\n  return response.data;\n};\n\nexport const fetchRepoBySearch = async (userName: string, text: string) => {\n  const response = await api.get(\n    `/search/repositories?q=user:${userName}+${text}`\n  );\n  return response.data;\n};\n```\n\n주요 Redux 개념 요약\n\n- Store: 애플리케이션 전체 상태를 보유하는 단일 진리의 소스입니다.\n- Actions: 발생한 일을 설명하는 일반적인 자바스크립트 객체입니다.\n- Reducers: 현재 상태와 동작을 인자로 받아 새로운 상태를 반환하는 순수 함수입니다.\n\n<div class=\"content-ad\"></div>\n\n리덕스 폴더 구조\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_4.png)\n\n내 폴더 구조에 대한 자세한 내용은 다루지 않겠습니다. 다양한 개발자들은 서로 다른 관점으로 폴더 구조를 설정하기 때문입니다. 내 GitHub 저장소를 참조하여 내 코드 구조와 누락된 사항이 무엇인지 확인해보세요.\n\n가장 먼저, 우리 액션을 설정해봅시다.\n\n<div class=\"content-ad\"></div>\n\n우리의 액션 유형을 설정해 봅시다! 액션 유형을 다양한 섹션으로 분할하여 깔끔하게 유지합니다.\n\n- Action Types를 위한 Enum: UsersActionTypes라는 열거형을 정의하여 모든 액션 유형 상수를 포함시킵니다. 이렇게 하면 관리가 쉬워지고 오타를 방지할 수 있습니다.\n- 액션 인터페이스: 각 액션 유형에 대한 인터페이스를 정의합니다.\n- 액션을 위한 Union Types: 관련된 액션을 그룹화하기 위해 유니온 타입을 정의합니다.\n\n```js\nimport { Users } from '../../types/usersTypes';\n\nexport enum UsersActionTypes {\n  /** 사용자 가져오기 */\n  FETCH_TOP_USERS_REQUEST = 'FETCH_TOP_USERS_REQUEST',\n  FETCH_TOP_USERS_SUCCESS = 'FETCH_TOP_USERS_SUCCESS',\n  FETCH_TOP_USERS_FAILURE = 'FETCH_TOP_USERS_FAILURE',\n\n  /** 검색으로 사용자 가져오기 */\n  FETCH_USERS_BY_SEARCH_REQUEST = 'FETCH_USERS_BY_SEARCH_REQUEST',\n  FETCH_USERS_BY_SEARCH_SUCCESS = 'FETCH_USERS_BY_SEARCH_SUCCESS',\n  FETCH_USERS_BY_SEARCH_FAILURE = 'FETCH_USERS_BY_SEARCH_FAILURE',\n\n  /** 사용자 좋아요 옵션 전환 */\n  TOGGLE_USER_LIKE = 'TOGGLE_USER_LIKE',\n}\n\nexport interface FetchTopUsersRequestAction {\n  type: typeof UsersActionTypes.FETCH_TOP_USERS_REQUEST;\n}\n\nexport interface FetchTopUsersSuccessAction {\n  type: typeof UsersActionTypes.FETCH_TOP_USERS_SUCCESS;\n  payload: Users;\n}\n\nexport interface FetchTopUsersFailureAction {\n  type: typeof UsersActionTypes.FETCH_TOP_USERS_FAILURE;\n  payload: string;\n}\n\nexport interface FetchUsersBySearchRequestAction {\n  type: typeof UsersActionTypes.FETCH_USERS_BY_SEARCH_REQUEST;\n}\n\nexport interface FetchUsersBySearchSuccessAction {\n  type: typeof UsersActionTypes.FETCH_USERS_BY_SEARCH_SUCCESS;\n  payload: Users;\n}\n\nexport interface FetchUsersBySearchFailureAction {\n  type: typeof UsersActionTypes.FETCH_USERS_BY_SEARCH_FAILURE;\n  payload: string;\n}\n\nexport interface ToggleUserLikeAction {\n  type: typeof UsersActionTypes.TOGGLE_USER_LIKE;\n  payload: number;\n}\n\nexport type FetchTopUsersActions =\n  | FetchTopUsersRequestAction\n  | FetchTopUsersSuccessAction\n  | FetchTopUsersFailureAction;\n\nexport type FetchUsersBySearchActions =\n  | FetchUsersBySearchRequestAction\n  | FetchUsersBySearchSuccessAction\n  | FetchUsersBySearchFailureAction;\n\nexport type UserActions =\n  | FetchTopUsersActions\n  | FetchUsersBySearchActions\n  | ToggleUserLikeAction;\n```\n\n- FetchTopUsersRequestAction, FetchTopUsersSuccessAction, FetchTopUsersFailureAction: 상위 사용자 가져오기와 관련된 작업에 대한 인터페이스입니다. FETCH_TOP_USERS_SUCCESS에는 가져온 사용자 데이터가 포함된 Users 유형의 payload가 포함되어 있으며, FETCH_TOP_USERS_FAILURE에는 오류 메시지를 나타내는 문자열 유형의 payload가 포함되어 있습니다.\n- FetchUsersBySearchRequestAction, FetchUsersBySearchSuccessAction, FetchUsersBySearchFailureAction: 검색으로 사용자를 가져오기 위한 유사한 인터페이스입니다.\n- ToggleUserLikeAction: 좋아요 옵션을 전환하는 작업을 위한 인터페이스로, 사용자 ID를 나타내는 숫자 유형의 payload가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n알림: 계속 진행하기 전에 redux-thunk를 설치해 봅시다.\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_5.png)\n\nRedux Thunk는 액션 생성자가 액션 객체 대신 함수를 반환할 수 있게 해주는 미들웨어입니다. 이 함수는 비동기 작업을 수행하고 해당 작업이 완료되면 일반 동기 액션을 디스패치할 수 있습니다.\n\n이제 우리의 액션 생성자와 thunk 함수를 준비해 봅시다. 이들은 데이터를 가져오고 필요한 액션을 디스패치하는 Redux 설정의 핵심 역할을 담당할 것입니다. 아래는 코드와 각 부분이 하는 역할에 대한 설명입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Users } from '../../types/usersTypes';\nimport { fetchTopUsersBySize, fetchUserBySearch } from '../../services';\nimport { ThunkAction } from 'redux-thunk';\nimport { ApplicationState } from '../../store';\nimport {\n  FetchTopUsersRequestAction,\n  UsersActionTypes,\n  FetchTopUsersSuccessAction,\n  FetchTopUsersFailureAction,\n  FetchUsersBySearchRequestAction,\n  FetchUsersBySearchSuccessAction,\n  FetchUsersBySearchFailureAction,\n  FetchTopUsersActions,\n  FetchUsersBySearchActions,\n  ToggleUserLikeAction,\n} from './types';\n\n// 액션 생성자\nexport const fetchTopUsersRequest = (): FetchTopUsersRequestAction => ({\n  type: UsersActionTypes.FETCH_TOP_USERS_REQUEST,\n});\n\nexport const fetchTopUsersSuccess = (\n  users: Users\n): FetchTopUsersSuccessAction => ({\n  type: UsersActionTypes.FETCH_TOP_USERS_SUCCESS,\n  payload: users,\n});\n\nexport const fetchTopUsersFailure = (\n  error: string\n): FetchTopUsersFailureAction => ({\n  type: UsersActionTypes.FETCH_TOP_USERS_FAILURE,\n  payload: error,\n});\n\nexport const fetchSearchUsersRequest = (): FetchUsersBySearchRequestAction => ({\n  type: UsersActionTypes.FETCH_USERS_BY_SEARCH_REQUEST,\n});\n\nexport const fetchSearchUsersSuccess = (\n  users: Users\n): FetchUsersBySearchSuccessAction => ({\n  type: UsersActionTypes.FETCH_USERS_BY_SEARCH_SUCCESS,\n  payload: users,\n});\n\nexport const fetchSearchUsersFailure = (\n  error: string\n): FetchUsersBySearchFailureAction => ({\n  type: UsersActionTypes.FETCH_USERS_BY_SEARCH_FAILURE,\n  payload: error,\n});\n\nexport const toogleUserLike = (userId: number): ToggleUserLikeAction => ({\n  type: UsersActionTypes.TOGGLE_USER_LIKE,\n  payload: userId,\n});\n\n// Thunk 함수\nexport const getTopUsersBySize =\n  (\n    size: number = 30\n  ): ThunkAction<void, ApplicationState, unknown, FetchTopUsersActions> =>\n  async (dispatch) => {\n    dispatch(fetchTopUsersRequest());\n    try {\n      const users = await fetchTopUsersBySize(size);\n      dispatch(fetchTopUsersSuccess(users));\n    } catch (error) {\n      if (error instanceof Error) {\n        dispatch(fetchTopUsersFailure(error.message));\n      } else {\n        dispatch(fetchTopUsersFailure('Oops something went wrong!!!'));\n      }\n    }\n  };\n\nexport const getUsersBySearch =\n  (\n    userName: string\n  ): ThunkAction<void, ApplicationState, unknown, FetchUsersBySearchActions> =>\n  async (dispatch) => {\n    dispatch(fetchSearchUsersRequest());\n    try {\n      const users = await fetchUserBySearch(userName);\n      dispatch(fetchSearchUsersSuccess(users));\n    } catch (error) {\n      if (error instanceof Error) {\n        dispatch(fetchSearchUsersFailure(error.message));\n      } else {\n        dispatch(fetchSearchUsersFailure('Oops something went wrong!!!'));\n      }\n    }\n  };\r\n```\n\n참고: ' ApplicationState '를 ‘../../store’에서 가져오는 것은 오류를 발생시킵니다. 하지만 걱정하지 마세요. 코드를 설정할 때 이를 수정할 것입니다.\n\n- 액션 생성자: Redux 스토어에 보내는 액션을 생성하는 함수들입니다.\n\n- fetchTopUsersRequest, fetchTopUsersSuccess, 그리고 fetchTopUsersFailure: 이러한 함수들은 상위 사용자를 가져오는 과정의 다른 단계(요청, 성공, 실패)을 위한 액션을 생성합니다.\n- fetchSearchUsersRequest, fetchSearchUsersSuccess, 그리고 fetchSearchUsersFailure: 검색을 통해 사용자를 가져오기 위한 유사한 함수들입니다.\n- toggleUserLike: 사용자의 좋아요 상태를 전환하는 액션을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n2. Thunk 함수: 이는 비동기 작업을 처리하고 결과에 따라 액션을 디스패치하는 함수들입니다.\n\n- getTopUsersBySize: 이 Thunk 함수는 특정 크기를 기반으로 상위 사용자들을 가져옵니다. 먼저 요청이 시작되었음을 나타내기 위해 fetchTopUsersRequest를 디스패치합니다. 그런 다음 fetchTopUsersBySize를 사용하여 사용자를 가져오려고 시도합니다. 성공하면 가져온 사용자와 함께 fetchTopUsersSuccess를 디스패치하고 오류가 발생하면 오류 메시지와 함께 fetchTopUsersFailure를 디스패치합니다.\n- getUsersBySearch: getTopUsersBySize와 유사하게,이 Thunk 함수는 검색어를 기반으로 사용자를 가져오는 작업을 처리합니다. 시작을 나타내기 위해 fetchSearchUsersRequest를 디스패치 한 후 fetchUserBySearch를 사용하여 사용자를 가져오려고 시도합니다. 성공하면 사용자와 함께 fetchSearchUsersSuccess를 디스패치하고 실패하면 오류 메시지와 함께 fetchSearchUsersFailure를 디스패치합니다.\n\n이러한 액션 생성자 및 Thunk 함수는 Redux 애플리케이션에서 데이터를 가져오고 상태 전환이 관리되는 논리를 처리하는 데 중요합니다. 이러한 방식으로 액션과 액션 유형을 구성함으로써 Redux 설정에서 다양한 사용자 관련 작업을 처리하기 위한 명확하고 관리 가능한 구조를 만들 수 있습니다. 이러한 구조가 갖춰지면 리듀서를 설정하여 이러한 작업을 처리하러 진행할 수 있습니다.\n\n다음으로 리듀서를 설정해 봅시다. 여기서 상태 관리가 게임을 시작합니다.\n\n<div class=\"content-ad\"></div>\n\n이 코드 조각은 애플리케이션의 상태가 Redux 스토어에 전달된 다양한 액션에 대한 응답으로 어떻게 업데이트되는지를 정의하기 때문에 중요합니다. 각 부분이 무엇을 하는지 살펴보겠습니다.\n\n```js\nimport {\n  UserActions,\n  UsersActionTypes,\n  FetchTopUsersSuccessAction,\n  FetchTopUsersFailureAction,\n  ToggleUserLikeAction,\n} from '../actions/users/types';\nimport { Users } from '../types/usersTypes';\n\ninterface UsersState {\n  loading: boolean;\n  users: Users | null;\n  error: string | null;\n}\n\nconst initialState: UsersState = {\n  loading: false,\n  users: null,\n  error: null,\n};\n\nexport const usersReducer = (\n  state = initialState,\n  action: UserActions\n): UsersState => {\n  switch (action.type) {\n    case UsersActionTypes.FETCH_TOP_USERS_REQUEST:\n    case UsersActionTypes.FETCH_USERS_BY_SEARCH_REQUEST:\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n    case UsersActionTypes.FETCH_TOP_USERS_SUCCESS:\n    case UsersActionTypes.FETCH_USERS_BY_SEARCH_SUCCESS:\n      return {\n        ...state,\n        loading: false,\n        users: (action as FetchTopUsersSuccessAction).payload,\n        error: null,\n      };\n    case UsersActionTypes.FETCH_TOP_USERS_FAILURE:\n    case UsersActionTypes.FETCH_USERS_BY_SEARCH_FAILURE:\n      return {\n        ...state,\n        loading: false,\n        error: (action as FetchTopUsersFailureAction).payload,\n      };\n\n    case UsersActionTypes.TOGGLE_USER_LIKE: {\n      const userId = (action as ToggleUserLikeAction).payload;\n      if (!state.users) {\n        return state; // 사용자 데이터가 null인 경우 상태를 그대로 반환합니다.\n      }\n      const updatedUsers = state.users.items.map((user) => {\n        if (user.id === userId) {\n          return {\n            ...user,\n            isLiked: !user.isLiked, // 좋아하는 속성을 토글합니다.\n          };\n        }\n        return user;\n      });\n      return {\n        ...state,\n        users: {\n          ...state.users,\n          items: updatedUsers,\n        },\n      };\n    }\n    default:\n      return state;\n  }\n};\n```\n\n- 상태 인터페이스 및 초기값:\n\n- UsersState: 사용자의 Redux 상태의 모양을 정의하며, 데이터가 검색 중인지를 나타내는 loading, 사용자 데이터를 보유하거나 아직 검색되지 않은 경우 null 또는 오류 메시지를 저장하는 error를 포함합니다.\n- initialState: 기본값으로 UsersState를 초기화합니다.\n\n<div class=\"content-ad\"></div>\n\n2. Reducer Function:\n\n- usersReducer: 이 함수는 디스패치된 액션에 기반하여 상태 업데이트를 처리합니다. 상태와 액션을 매개변수로 받습니다.\n- switch 문: action.type을 평가하여 상태를 업데이트하는 방법을 결정합니다.\n- FETCH_TOP_USERS_REQUEST 및 FETCH_USERS_BY_SEARCH_REQUEST: loading을 true로 설정하고 기존 오류를 지웁니다.\n- FETCH_TOP_USERS_SUCCESS 및 FETCH_USERS_BY_SEARCH_SUCCESS: payload에서 가져온 사용자 데이터로 상태를 업데이트하고 loading을 false로 설정합니다.\n- FETCH_TOP_USERS_FAILURE 및 FETCH_USERS_BY_SEARCH_FAILURE: payload에서 가져온 오류 메시지로 상태를 업데이트하고 loading을 false로 설정합니다.\n- TOGGLE_USER_LIKE: userId로 식별된 사용자의 isLiked 속성을 토글합니다. 상태.users.items를 매핑하여 사용자를 찾고 isLiked를 토글한 후 새 배열인 updatedUsers를 반환합니다. 마지막으로 updatedUsers로 상태를 업데이트합니다. 왜 이렇게 많이 빙빙 돌까요? 상태는 불변이기 때문에 새 복사본을 만들어야 합니다.\n\n3. Default case: 액션 유형이 어떤 케이스와도 일치하지 않으면 상태를 그대로 반환합니다.\n\n이 리듀서는 우리 상태의 내비게이터 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n루트 리듀서를 만들어 봅시다. combineReducers를 사용하여 rootReducer를 생성합니다. combineReducers를 사용하면 Redux 상태의 관리를 간단하게 만들 수 있습니다. 이를 통해 상태 관리 로직을 분리하여 전문화된 리듀서로 분할할 수 있습니다. 우리의 리듀서를 하나의 rootReducer로 결합함으로써, Redux 스토어가 애플리케이션의 다른 부분의 상태를 조직적이고 확장 가능한 방식으로 관리할 수 있도록 합니다.\n\n```js\nimport { combineReducers } from 'redux';\nimport { usersReducer } from './userReducer';\n\n// Combine Reducers\nconst rootReducer = combineReducers({\n  users: usersReducer,\n});\n\n// export type AppState = ReturnType<typeof rootReducer>;\nexport default rootReducer;\n```\n\n이제 우리의 액션과 리듀서가 원활하게 함께 작동하고 있으니, Redux 상태의 기반인 스토어를 구축할 시간입니다!\n\n다음으로, 스토어 설정에 대해 자세히 알아보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 그 전에 애플리케이션에서 사용할 액션 유형을 내보내보겠습니다.\n\n```js\nimport { UserActions } from '../actions/users/types';\n\nexport type AppActionTypes = UserActions;\n```\n\n여기는 Redux 스토어를 설정하는 코드입니다. 이곳에서 모든 마법이 일어납니다.\n\n```js\nimport {\n  applyMiddleware,\n  compose,\n  legacy_createStore as createStore,\n} from 'redux';\nimport { thunk, ThunkDispatch } from 'redux-thunk';\nimport rootReducer from '../reducers';\nimport { AppActionTypes } from '../types/types';\nimport loggingMiddleware from '../middlewares/logging';\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n  }\n}\n\n// 미들웨어 배열 정의\nconst middleware = [thunk, loggingMiddleware];\n\nconst composeEnhancers =\n  (typeof window !== 'undefined' &&\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) ||\n  compose;\n\nexport const store = createStore(\n  rootReducer,\n  undefined,\n  composeEnhancers(applyMiddleware(...middleware))\n);\n\nexport type ApplicationState = ReturnType<typeof rootReducer>;\nexport type ApplicationDispatch = ThunkDispatch<\n  ApplicationState,\n  unknown,\n  AppActionTypes\n>;\n```\n\n<div class=\"content-ad\"></div>\n\n- 창 선언: 우리는 Redux DevTools Extension과 호환되는 저장소를 만들기 위한 전역 인터페이스를 선언하여, 둘 사이의 원활한 통신을 보장합니다.\n- 미들웨어 설정: 우리는 미들웨어 팀을 구성하며 thunk와 loggingMiddleware을 포함시켜, 비동기 작업 및 로깅 활동과 같은 작업을 처리할 준비를 합니다.\n- Enhancers 조합: 이 함수는 미들웨어를 결합하고 저장소를 향상시키는 조합자를 만들어서, 모든 것이 원활하게 동작하도록 합니다. Redux DevTools Extension과 통합되며, 보기 좋은 저장소가 되도록 세심하게 조정됩니다!\n- 저장소 생성: createStore를 사용하여 Redux 저장소를 만들어냅니다. rootReducer를 취하여 상태를 관리하며, 초기 상태로 undefined를 사용하며, 작업 및 상태 변경을 효과적으로 관리하기 위해 미들웨어를 적용합니다.\n- 타입 정의: 마지막으로 rootReducer가 관리하는 Redux 상태의 유형으로 ApplicationState를 정의하고, 디스패치 함수의 유형으로 ApplicationDispatch를 정의하여 Redux 여행 중에 타입 안전성을 보장합니다.\n\n```js\nimport { Middleware } from 'redux';\nimport { ApplicationState } from '../store';\n\nconst loggingMiddleware: Middleware<object, ApplicationState> =\n  (store) => (next) => (action) => {\n    // 액션을 기록합니다.\n    console.log('Action:', action);\n\n    // 액션이 전달되기 전의 현재 상태를 가져옵니다.\n    const prevState = store.getState();\n\n    // 액션을 실행합니다.\n    const result = next(action);\n\n    // 액션이 전달된 후의 상태를 가져옵니다.\n    const nextState = store.getState();\n\n    // 상태 변경 사항을 기록합니다.\n    console.log('이전 상태:', prevState);\n    console.log('다음 상태:', nextState);\n\n    return result;\n  };\n\nexport default loggingMiddleware;\n```\n\n저장소가 설정되어 있으므로, Redux 상태 관리는 응용 프로그램의 복잡성을 처리할 준비가 되어 있습니다. 이제, 페이지를 구축하기 전에, 우리 전체 응용 프로그램을 `Provider store='store'`로 감싸봅시다. 이렇게 하면 Redux 저장소가 구성 요소 트리의 모든 구성 요소에서 사용할 수 있게 됩니다. store는 Redux 저장소의 인스턴스를 나타내는 속성으로 전달되며, 저장소는 여러분의 Redux 저장소 인스턴스를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n메인.tsx 파일에 이 코드를 추가해주세요.\n\n```js\n<Provider store={store}>\n      <div className=\"min-h-screen flex  justify-center bg-gray-100\">\n        <div class=\"w-full max-w-screen-lg m-4 p-4 bg-white rounded shadow-md\">\n          <h1 className=\"text-4xl font-bold text-blue-900 mb-4 tracking-wider uppercase\">\n            GitHub Finder\n          </h1>\n          <RouterProvider router={router} />\n        </div>\n      </div>\n    </Provider>\r\n```\n\n이 글이 조금 무거워지고 있는 것 같지만, Redux 상태 관리를 설정하는 데에는 약간의 노력이 필요합니다. 그게 바로 Redux Toolkit이라는 것을 만들었기 때문이죠. 다음 시리즈에서 이에 대해 다룰 예정입니다. 이제 내가 당신의 신뢰를 되찾았길 바라며, 어플리케이션에 대해 살펴봐요!\n\nuseSelector와 useDispatch 훅\n\n<div class=\"content-ad\"></div>\n\nReact Redux에서 useSelector 및 useDispatch 훅을 사용하면 컴포넌트가 Redux 스토어와 상호작용하는 방법이 간소화됩니다.\n\nuseSelector: 이 훅을 사용하면 컴포넌트가 Redux 상태의 특정 슬라이스를 선택할 수 있어 데이터 접근을 최적화하고 불필요한 렌더링을 최소화할 수 있습니다.\n\nuseDispatch: 액션을 디스패치하는 데 사용되며, useDispatch를 사용하면 컴포넌트가 상태 변경을 트리거하고 응용 프로그램 내에서 비동기 작업을 관리할 수 있습니다.\n\n우리 애플리케이션에서 useSelector 훅을 사용하는 것은 다음과 같이 보입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst state = useSelector((state:ApplicationState) => state.users);\n```\n\n매번 ApplicationState를 import하는 것은 조금 귀찮을 수 있습니다. 그래서 대신 전체 애플리케이션에서 사용할 수 있는 사용자 정의 훅을 만드는 것을 선호합니다. 제 사용자 정의 훅은 이렇게 생겼어요:\n\n```js\nexport const useAppSelector: TypedUseSelectorHook<ApplicationState> =\n  useSelector;\n```\n\n코드에서 단축키를 만드는 것과 비슷한데요 — 누가 코딩에서 단축키를 좋아하지 않겠어요? 😉\n\n\n<div class=\"content-ad\"></div>\n\n비슷하게, 우리 애플리케이션에서 useDispatch 훅을 사용하는 것은 다음과 같습니다:\n\n```js\nconst dispatch = useDispatch<ApplicationDispatch>();\n```\n\n또한, 반복적으로 ApplicationDispatch를 다루는 것은 번거로울 수 있습니다. 그래서 여기 내가 만든 커스텀 훅이 어떻게 단순화시키는지 알아봅시다:\n\n```js\nexport const useAppDispatch: () => ApplicationDispatch = useDispatch;\n```\n\n<div class=\"content-ad\"></div>\n\n우리가 사용자 정의 훅을 사용할 수 있게 되었으니, 이제 사용자 목록 페이지 구축에 집중해 보겠습니다. Redux 상태에 접근하기 위한 useAppSelector 및 액션을 디스패치하기 위한 useAppDispatch를 사용하여 원활한 사용자 경험을 만들 준비가 되었습니다. 시작해 봅시다!\n\n```js\nimport React, { useEffect } from 'react';\nimport SearchBox from '../components/SearchBox';\nimport {\n  getTopUsersBySize,\n  getUsersBySearch,\n  toggleUserLike,\n} from '../redux/actions/users/actions';\nimport Loading from '../components/Loading';\nimport Error from '../components/Error';\nimport { NavLink } from 'react-router-dom';\nimport { useAppDispatch, useAppSelector } from '../hooks/hooks';\nimport LikeButton from '../components/LikeButton';\n\nconst Home: React.FC = () => {\n  const { loading, users, error } = useAppSelector((state) => state.users);\n  const dispatch = useAppDispatch();\n  const handleSearch = (query: string) => {\n    if (query) {\n      dispatch(getUsersBySearch(query));\n    } else {\n      dispatch(getTopUsersBySize());\n    }\n  };\n  useEffect(() => {\n    dispatch(getTopUsersBySize());\n  }, [dispatch]);\n\n  return (\n    <div className=\"container mx-auto p-4 flex flex-col\">\n      <div className=\"flex justify-center mb-6\">\n        <div className=\"w-2/3\">\n          <SearchBox placeholder=\"Search user...\" onSearch={handleSearch} />\n        </div>\n      </div>\n      <hr />\n      <h2 className=\"text-2xl text-blue-700 font-bold my-4\">\n        Users - {users?.total_count}\n      </h2>\n      {loading ? (\n        <Loading />\n      ) : error ? (\n        <Error message={error} />\n      ) : (\n        <div\n          className=\"flex-grow  overflow-y-auto\"\n          style={{ maxHeight: 'calc(100vh - 300px)' }}\n        >\n          <ul className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6\">\n            {users?.items.map((user) => (\n              <li\n                key={user.login}\n                className=\"flex items-center space-x-4 p-4 bg-white rounded shadow hover:shadow-lg transition-shadow\"\n              >\n                <img\n                  src={user.avatar_url}\n                  alt={`${user.login} avatar`}\n                  className=\"w-16 h-16 rounded-full\"\n                />\n                <div className=\"flex flex-col gap-0.5\">\n                  <span className=\"text-lg text-blue-950 font-medium\">\n                    {user.login}\n                  </span>\n                  <div className=\"flex gap-2\">\n                    <NavLink\n                      className=\"underline underline-offset-2 text-orange-500 hover:text-orange-600\"\n                      to={`/${user.login}/repos`}\n                    >\n                      View repos\n                    </NavLink>\n                    <div>\n                      <LikeButton\n                        liked={!!user.isLiked}\n                        toggleLike={() => dispatch(toggleUserLike(user.id))}\n                      />\n                    </div>\n                  </div>\n                </div>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n- 상태 관리: useAppSelector 훅을 사용하여 Redux 상태에 접근하고, 특히 로딩 상태 (loading), 사용자 데이터 (users), 오류 메시지 (error)가 포함된 state.users에 접근합니다.\n- 디스패치 함수: useAppDispatch는 디스패치 함수 dispatch를 얻기 위해 사용되며, 컴포넌트가 getTopUsersBySize, getUsersBySearch, toggleUserLike와 같은 액션을 디스패치할 수 있도록 합니다.\n\n더 많은 라우팅 코드는 제 저장소에서 확인하실 수 있습니다\n\n\n\n<div class=\"content-ad\"></div>\n\n지금 애플리케이션을 실행하면, 위대한 사용자 목록 페이지가 나타납니다! 축하해요, 성공했어요! 🎉 이 코드를 자유롭게 조작하고 도전하여 자체 Repository 페이지를 구현해 보세요. 그리고 기억하세요, 올바른 방향으로 가는 데 조금의 도움이 필요하다면, 우리의 저장소가 도와드릴 준비가 되어 있어요. 지금 바로 들어가서 새로 만든 것을 탐험해 보세요!\n\n제가 긴 글을 썼다는 것을 알고 있어요, 전통적인 Redux 애플리케이션을 설치하는 것은 실제로 시간이 걸릴 수 있습니다 — 이렇게 강력한 라이브러리조차 비판에 직면하기도 했죠. 하지만 걱정하지 마세요! Redux 팀은 이 피드백을 즐겁게 받아들이고 이러한 문제점을 해결하는 주요 업데이트인 Redux Toolkit을 소개했어요. 마치 Redux가 새 옷을 입고 다시 사랑에 빠지는 것 같아요!\n\n당신의 애플리케이션을 Redux Toolkit으로 마이그레이션하는 방법이 궁금하신가요? 계속 주목해 주세요. 더 간단하고 즐거운 상태 관리를 위한 건박스 스!!\n\n코딩 즐기세요!!!","ogImage":{"url":"/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png"},"coverImage":"/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png","tag":["Tech"],"readingTime":23},{"title":"자꾸 사라지지 않는 오래된 습관들  고치기 위한 실질적인 방법들","description":"","date":"2024-06-22 03:15","slug":"2024-06-22-oldhabitsdiesceaming","content":"\n\n![이미지](/assets/img/2024-06-22-oldhabitsdiesceaming_0.png)\n\n정말 잘 되기를 바래요.\n\n과거를 돌아보지 않고 앞으로 나아가 주길 바래요. 다시 돌아가려는 유혹이 너무 압도적이지 않기를 바래요. 이번에는 누군가를 만나서 함께 잘 지내길 진심으로 바래요. 우리의 개인적인 재미있는 얘기들이 지난날의 무덤 속으로 속삭임으로 남길 바라며, 나와는 상관 없는 다른 사람과 나누는 웃음 소리로 대체되길 바라요. 우리의 노래가 너에게서 내 얼굴을 불러보지 않게 된 삶의 배경 속으로 사라지길 바래요. 다시 나를 그리워하지 않기를 바래요.\n\n네게 잘 되기를 원하지 않아요. 쓰러지길 바래요.\n\n<div class=\"content-ad\"></div>\n\n누군가가 당신 앞에 바리케이드가 되어 차들이 경적을 울릴 때, 후방을 보기 위해 브레이크를 밟는다면 좋겠어요. 당신이 나를 남겨둔 자리를 여전히 후방 거울에 보고 싶어할 거라고 기대해요. 230km/h로 가속하고 U턴을 하려다가 실수로 차를 충돌시키고 자신을 파멸로 몰아넣을 거라고 기대해요. 누군가를 만나 어딘가로 데려가다가 갑자기 우리의 꿈 속에 엮인 비극적인 노래가 흘러나온다면 정말 좋겠어요. 그 노래 가사를 알지 못했으면 좋겠고, 그 순간 당신이 나를 그리워할 거라고 기대해요.\n\n당신이 아직도 내가 그리워지지 않는다는 걸 이해하지 못해서 그렇습니다.","ogImage":{"url":"/assets/img/2024-06-22-oldhabitsdiesceaming_0.png"},"coverImage":"/assets/img/2024-06-22-oldhabitsdiesceaming_0.png","tag":["Tech"],"readingTime":1},{"title":"Angular에서 DOCUMENT를 사용해야 하는 이유","description":"","date":"2024-06-22 03:14","slug":"2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular","content":"\n\n\n![image](/assets/img/2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular_0.png)\n\nDOCUMENT은 Angular에서 제공하는 의존성 주입 토큰으로, 문서 객체 모델(DOM)을 나타내는 주요 렌더링 컨텍스트를 나타냅니다. DOCUMENT 토큰은 @angular/common 패키지에서 import됩니다. 문서 객체 모델(DOM)은 웹 페이지를 스크립트나 프로그래밍 언어와 연결해주는 역할을 합니다. 일반적으로 JavaScript를 참조하지만, HTML, SVG 또는 XML 문서를 객체로 모델링하는 것은 JavaScript 언어의 핵심 부분은 아닙니다. DOCUMENT와 document 객체 모두 DOM에 액세스할 수 있지만, Angular 애플리케이션에서 전역 document 객체 대신 DOCUMENT를 사용하는 것에는 장점이 있습니다. 먼저, Angular 애플리케이션에서 DOCUMENT와 document를 사용하는 한 가지 사례를 살펴보겠습니다.\n\n다음 예제는 HTML 템플릿의 섹션을 보고자 할 때 document를 사용하는 방법을 보여줍니다.\n\n```js\nimport { Component, OnInit } from '@angular/core';\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css'],\n})\nexport class MyComponent implements OnInit {\n  constructor() {}\n  ngOnInit(): void {\n    const myButton = document.getElementById('myButton');\n    myButton.addEventListener('click', () => {\n      const targetElement = document.getElementById('targetElement');\n      targetElement.scrollIntoView({ behavior: 'smooth' });\n    });\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음 예제는 이전 기능에 DOCUMENT를 사용하는 방법을 보여줍니다.\n\n```js\nimport { Component, Inject, OnInit } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css'],\n})\nexport class MyComponent implements OnInit {\n  constructor(@Inject(DOCUMENT) private document: Document) {}\n  ngOnInit(): void {\n    const myButton = this.document.getElementById('myButton');\n    myButton.addEventListener('click', () => {\n      const targetElement = this.document.getElementById('targetElement');\n      targetElement.scrollIntoView({ behavior: 'smooth' });\n    });\n  }\n}\n```\n\n위 예제에서는 DOCUMENT 서비스를 주입하고 Document 객체의 메서드와 속성에 액세스합니다. 두 구현은 거의 유사해 보이지만 DOCUMENT 주입 토큰을 사용하는 이점을 살펴보겠습니다.\n\n- 플랫폼에 독립적: DOCUMENT 토큰은 플랫폼에 독립적이므로 전역 document 객체가 사용할 수 없는 서버 측 렌더링 (SSR) 시나리오에서 사용할 수 있습니다. SSR을 사용할 때 document는 Domino에 의해 생성됩니다.\n- 의존성 주입: DOCUMENT 토큰은 Angular의 의존성 주입으로 주입될 수 있습니다. 이를 통해 컴포넌트를 전역 범위에서 분리함으로써 더 나은 코드 구성, 테스트 가능성, 유지 관리성이 증진됩니다.\n- 타입 안전성: DOCUMENT 토큰은 타입 정의를 제공하여 IDE에서 더 나은 타입 안전성과 코드 완성을 가능하게 합니다.\n- Angular zone 인식: Angular의 DOCUMENT는 Angular의 zone.js 라이브러리를 인식하고 변경 감지 메커니즘과 원활하게 통합됩니다. 이를 통해 Angular 컴포넌트에 의해 트리거된 DOM 업데이트가 올바르게 감지되고 처리되며, 변경 감지로 인한 발생할 수 있는 문제를 방지하여 일관된 사용자 경험을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n전역 문서는 특정 시나리오에 적합할 수 있지만 Angular의 DOCUMENT 토큰은 플랫폼 중립성, 의존성 주입, 유형 안전성 및 Angular 특정 기능 측면에서 여러 가지 장점을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular_0.png"},"coverImage":"/assets/img/2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular_0.png","tag":["Tech"],"readingTime":3},{"title":"Angular에서 Enum 파워 유저 되는 방법","description":"","date":"2024-06-22 03:13","slug":"2024-06-22-BeaPowerUserofEnumsinAngular","content":"\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 기본 Enums\n\nAngular의 Enums은 기본적으로 숫자형입니다:\n\n```js\n// colors.enum.ts\n\nexport enum Color {\n  Blue,  // 0\n  Green, // 1\n  Red    // 2\n}\n```\n\n문자열 Enums도 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nexport enum TimeZone {\n  EasternTime = 'Eastern Time',\n  CentralTime = 'Central Time',\n  MountainTime = 'Mountain Time',\n  PacificTime = 'Pacific Time',\n  AlaskaTime = 'Alaska Time',\n  HawaiiAleutianTime = 'Hawaii-Aleutian Time'\n}\n```\n\n지금 필요에 따라 사용하면 됩니다.\n\n# HTML에서의 Enum\n\nEnum을 가지고 있으면 관련 데이터를 표현하는데 어디서든 사용하고 싶어질 것입니다. 그러나 Angular에서, HTML 코드에서 enum을 사용하는 것은 생각한 것만큼 간단하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n## 코드\n\n```js\n// colors.model.ts\n\nimport { Color } from 'colors.enum.ts';\n\nexport interface ColorsViewModel {\n  Color: typeof Color;\n  colors: Color[];\n  formGroup: FormGroup;\n}\n```\n\n```js\n// colors-example.component.ts\n\nimport { Color } from 'colors.enum.ts';\nimport { ColorsViewModel } from 'colors.model.ts';\n\n@Component({\n  selector: 'colors-example',\n  styleUrls: ['colors-example.component.scss'],\n  templateUrl: 'colors-example.component.html'\n})\nexport class ColorsExampleComponent implements OnInit {\n  @Input({ required: true }) public color: Color;\n\n  public vm: ColorsViewModel;\n\n  public ngOnInit(): void {\n    this.vm = {\n      Color,\n      colors: Object.values(Color),\n      formGroup: this.createFormGroup();\n  }\n\n  private createFormGroup(): FormGroup {\n    return new FormGroup({\n      colorOption: new FormControl<Color>(Color.Green)\n    });\n  }\n}\n```\n\n```js\n<!-- colors-example.component.html -->\n\n<div *ngIf=\"vm\">\n  <ng-container [ngSwitch]=\"color\">\n    <ng-container *ngSwitchCase=\"vm.Color.Blue\">\n      <p style=\"color: blue\">파란색</p>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"vm.Color.Greed\">\n      <p style=\"color: green\">초록색</p>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"vm.Color.Red\">\n      <p style=\"color: red\">빨간색</p>\n    </ng-container>\n  </ng-container>\n\n  <p *ngIf=\"color === vm.Color.Red\">대단해요!</p>\n\n  <form [formGroup]=\"vm.formGroup\">\n    <mat-form-field>\n      <mat-label>색상을 선택하세요</mat-label>\n      <mat-select formControlName=\"colorOption\">\n        <mat-option *ngFor=\"let color of vm.colors\" [value]=\"color\">\n          { color }\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </form>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n## 설명\n\n여기서는 Color enum을 HTML에서 세 가지 다른 방법으로 사용하는 방법을 보여줍니다.\n1. ngSwitch에서\n2. === 비교에서\n3. select/dropdown에서\n\nColor enum의 실제 값들을 참조하여 enum을 사용합니다. 그러기 위해 colors.model.ts에서 Color: typeof Color라는 중요한 코드가 있습니다. 이 코드는 enum을 뷰 모델 개체에 추가하여 *ngIf=\"color === 2와 같은 것을 코딩하지 않고도 HTML에서 참조할 수 있도록 합니다.\n\n그리고 dropdown에서는 Object.values(Color);를 사용하여 mat-select 옵션을 재입력할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n탁월하네요, 맞죠?\n\n# TypeScript에서 Enum 사용하기\n\nTypeScript에서 Enum을 사용하여 비교하는 것은 매우 간단합니다.\n\n```js\nif (this.color === Color.Blue) {\n  console.log('바다를 좋아하나요?');\n}\n\nswitch(this.color) {\n  case Color.Blue:\n    console.log('바다를 좋아하나요?');\n    break;\n  case Color.Green:\n    console.log('잔디를 좋아하나요?');\n    break;\n  case Color.Red:\n    console.log('일출을 좋아하나요?');\n    break;\n  default:\n    console.log('기본 색상이 아닙니다.');\n}\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 열거형(enum)에서 모든 값을 사용하고 싶지 않을 때는 어떻게 해야 할까요?\n\n색상 열거형(enum)을 변경하고 확장해 봅시다:\n\n```js\n// colors.enum.ts\n\nexport enum Color {\n  Black,\n  Blue,\n  Brown,\n  Green,\n  Indigo,\n  Orange,\n  Red,\n  Yellow,\n  Violet\n}\n```\n\n이제 색상을 서버로 전달하여 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst coloredShoes: Shoes[] = await this.colorService\n  .getShoesOfColor(this.vm.formGroup.get('colorOption'));\n```\n\n이제, 모든 색상을 사용하고 싶다고 상상해 봅시다:\n\n```js\nconst allShoes: Shoes[] = await this.colorService\n  .getShoesOfColor(Object.values(Color));\n```\n\n하지만 만약 일부 색상만 사용하고 싶다면 어떻게 해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n이렇게 할 수 있어요:\n\n```js\nconst rainbowShoes: Shoes[] = await this.colorService\n  .getShoesOfColor([\n     Color.Red,\n     Color.Orange,\n     Color.Yellow,\n     Color.Green,\n     Color.Blue,\n     Color.Indigo,\n     Color.Violet\n   ]);\n```\n\n하지만 만약 16개 색상, 64개 색상 또는 256개 색상이 있는 Color enum이 있다면 어떻게 될까요? 아이디어를 이해하셨죠. 경우에 따라서는 원하는 enum 값이 아닌 것을 지정하는 것이 더 쉬울 수 있습니다. 하지만 \"파란색 계통이 아닌 모든 신발\"과 같은 것을 어떻게 지정할 수 있을까요? Enum은 Object.values(Color).not([Color.Blue, Color.Indigo]);와 같이 쉬운 방법을 제공하지 않습니다.\n\nTypeScript 제네릭이 해결책을 제공합니다!\n\n<div class=\"content-ad\"></div>\n\n```js\n/**\n * 주어진 enum 및 허용되지 않는 값에 따라 enum 값을 포함하는 배열을 반환합니다.\n *\n * @param myEnum enum의 이름입니다.\n * @param disallowedValues 반환되지 말아야할 myEnum 값들의 배열입니다.\n *\n * @return 허용되지 않는 값들을 제외한 모든 myEnum 값들의 배열입니다.\n */\nexport const numericEnumFilterOut: Function =\n  <R extends number,\n   T extends {[key: string]: R}>(myEnum: T, disallowedValues: R[]): R[] =>\n    Object.entries(myEnum)\n      .filter((type: [string, string | R]): boolean =>\n        typeof type[1] === 'number' && !disallowedValues.includes(type[1]))\n      .map((type: [string, R]): [string, R] => type as [string, R])\n      .map(([, value]: [string, R]): R => value);\n```\n\n## 사용법\n\n```js\nconst noBlue: Color[] =\n  numericEnumFilterOut(Color, [Color.Blue, Color.Indigo]);\n\n// noBlue = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Violet]\n```\n\n이제 다음과 같이 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n상수 비파란신: Shoes[] = await this.colorService\n  .getShoesOfColor(numericEnumFilterOut(Color, [Color.Blue, Color.Indigo]));\n```\n\n# 결론\n\nEnum은 깔끔한 코드를 작성하는 데 매우 강력한 도구입니다. TypeScript와 HTML 모두에서 사용하는 방법이 많습니다. 코딩할 때 강력한 무기가 될 수 있습니다. 즐거운 코딩하세요!\n\n# 간단히 말하면 🚀\n\n<div class=\"content-ad\"></div>\n\n인 플레인 잉글리쉬 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 박수를 보내고 작가를 팔로우해주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: 스타카데믹 | 코피드 | 벤처 | 큐브드\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-06-22-BeaPowerUserofEnumsinAngular_0.png"},"coverImage":"/assets/img/2024-06-22-BeaPowerUserofEnumsinAngular_0.png","tag":["Tech"],"readingTime":6},{"title":"기존 인터페이스를 강력한 타입의 리액티브 폼으로 사용하는 방법 Angular","description":"","date":"2024-06-22 03:12","slug":"2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform","content":"\n\nAngular 14+에서 우리는 기다리던 바대로 반응형 폼에 타입을 지정할 수 있는 기회를 얻었습니다. 문제는 폼 자체에 대한 특정 모델을 만들어야 하므로, 앱이 더 복잡한 객체를 사용할 때 폼 타입이 약간 더 복잡하고 유지하기 어려워진다는 점입니다.\n\n![이미지](/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png)\n\n간단한 모델이 있는 경우에는 어느 정도 쉽게 이해됩니다. 이런 식으로 User 인터페이스를 가진 경우를 살펴봅시다:\n\n```js\nexport interface User {\n    id: number;\n    name: string;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위 인터페이스를 기반으로 강력한 유형화된 반응형 폼을 만들려면, 폼 컨트롤을 보유할 미러 모델이 필요합니다:\n\n```js\nexport interface UserForm {\n    id: FormControl<number>;\n    name: FormControl<string>;\n}\n```\n\n그리고 많은 모델을 가지고 있을 때, 이 방법은 꽤 지루하고 시간이 많이 걸릴 수 있어요.\n\n## 모델을 복제하는 것은 해결책이 아닙니다.\n\n<div class=\"content-ad\"></div>\n\nTypescript의 힘을 이용해서, 우리는 인터페이스를 래핑할 타입을 만들 것이고, 이를 통해 프로젝트에서 모델 중복을 피할 수 있습니다.\n\n시작해봅시다!\n\n우리의 타입은 Generics을 사용하여 어떤 종류의 인터페이스든 받을 수 있어야 하며, 이를 FormGroup으로 변환하고 모든 속성을 FormControl로 변환해야 합니다.\n\n```js\nexport type ToFormType<T> = FormGroup<{\n    [K in keyof T]: FormControl<T[K] | null>;\n}>;\n```\n\n<div class=\"content-ad\"></div>\n\n쉽죠? 이제 우리가 하는 일 인터페이스 T를 감싸는 슈퍼 타입을 만들어요. 이 슈퍼 타입은 FormGroup으로 변환하고 각 속성은 FormControl으로 변환하죠.\n\n사용법:\n\n```js\npublic myForm: ToFormType<User>;\n\n...\n\nmyForm = this.fb.group(...);\n```\n\n기다려 주세요! 아직 끝나지 않았어요.\n\n<div class=\"content-ad\"></div>\n\n저희 유저 인터페이스에 작은 변경사항을 가해보도록 하죠:\n\n```js\nexport interface User {\n    id: number;\n    name: string;\n    address: Address;\n}\n\nexport interface Address {\n    zipCode: number;\n    city: string;\n}\n```\n\n음... 이전 유형에서 오류가 발생했네요.\n\n```js\n'Type 'FormGroup<{…}>' is not assignable to type 'ToFormType<User>'.\nTypes of property 'controls' are incompatible.\n```\n\n<div class=\"content-ad\"></div>\n\n잘 했어요… FormControl과 FormGroup을 처리할 수 있도록 유형을 업데이트해야 해요.\n\n다음과 같이 시도해 봅시다:\n\n```js\nexport type ToFormType<T> = FormGroup<{\n    [K in keyof T]: T[K] extends object\n        ? ToFormType<T[K]>\n        : FormControl<T[K] | null>;\n}>;\n```\n\n작동하는 것으로 보이네요. 중첩된 객체가 있는 경우에도 처리할 수 있어요. 하지만, 한 가지 문제가 있어요: 만약 User에 birthDate 속성이 있다면 어떻게 될까요? Date는 object를 확장한다네요… 안타깝지만요.\n\n<div class=\"content-ad\"></div>\n\n위에 있는 내용을 친한 톤으로 한국어로 번역해 드리겠습니다:\n\n말씀하신 대로, 쉽게 코드를 업데이트하여 작동시킬 수 있습니다:\n\n```js\nexport type ToFormType<T> = FormGroup<{\n    [K in keyof T]: T[K] extends object\n        ? T[K] extends Date\n            ? FormControl<T[K] | null>\n            : ToFormType<T[K]>\n        : FormControl<T[K] | null>;\n}>;\r\n```\n\n조금은 섬세하지 않지만, 대부분의 경우에는 작동할 것입니다.\n\n```js\nexport interface User {\n    id: number;\n    name: string;\n    address: Address;\n    hobbies: Hobby[];\n}\n\nexport interface Address {\n    zipCode: number;\n    city: string;\n}\n\nexport interface Hobby {\n    name: string;\n    description: string;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 번역됩니다:\n\n```js\n'Type 'FormGroup<{…}>'은(는) 'ToFormType<User>' 유형에 할당할 수 없습니다. 'controls' 속성의 유형이 호환되지 않습니다.\n```\n\n익숙하신가요? 어떻게 해야 할 지 알겠어요! 다시 한번 형식을 발전시켜 봅시다!\n\n이렇게 하고 싶은 유혹을 느낄 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\nT[K]이 배열을 확장한다면 FormArray<ToFormType<T[K]>>으로 ....를 설정합니다.\n\n그러나 이 방법은 작동하지 않을 것입니다. 이유는 타입이 일치하지 않기 때문입니다. \n\n이를 피하기 위해서는 배열로부터 타입을 « 추출 » 할 때 infer를 사용해야 합니다. (자세한 내용은 https://blog.logrocket.com/understanding-infer-typescript/에서 확인할 수 있습니다):\n\nexport type ToFormType<T> = FormGroup<{\n    [K in keyof T]: T[K]이 객체를 확장한다면\n        ? T[K]이 날짜인 경우\n            ? FormControl<T[K] | null>\n            : T[K]이 알 수 없는 배열인 경우\n                ? FormArray<ToFormType<T[K] extends (infer V)[] ? V : T[K]>>\n                : ToFormType<T[K]>\n        : FormControl<T[K] | null>;\n}>;\n\n<div class=\"content-ad\"></div>\n\n이제 우리에게 대부분의 인터페이스를 강력하게 입력 형식화된 반응 형식으로 변환할 수 있는 타입이 생겼어요!\n\n폼 내부에서 인터페이스를 풍부하게 제공하거나 부분적으로 사용하려면 Typescript의 Pick, Required, Intersection, Omit과 같은 기능을 활용할 수도 있어요. 예를 들면:\nToFormType<Pick<User, 'id' | 'name' >>;\n// OR\nToFormType<User & { birthDate: Date }>;\n\n그리고 모든 사용 사례에 대해 중복으로 정의하지 않고 단일 인터페이스를 사용할 수 있어요:)\n\n<div class=\"content-ad\"></div>\n\n참고 자료\n\n- [Typescript 공식 문서: 제네릭](https://www.typescriptlang.org/docs/handbook/2/generics.html)\n- [TypeScript의 infer 키워드 이해하기](https://blog.logrocket.com/understanding-infer-typescript/)\n- [Typescript 공식 문서: 유틸리티 타입 - `Pick`](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys)\n- [Typescript 공식 문서: 병합과 교차 타입](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html)\n\n지금까지였습니다! 즐겁게 보셨길 바라요!\n\n이와 같은 글을 계속해서 놓치고 싶지 않다면, 저희를 팔로우해주시면 감사하겠습니다 :)","ogImage":{"url":"/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png"},"coverImage":"/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png","tag":["Tech"],"readingTime":5},{"title":"httpOnly 쿠키로 React 앱 보안을 강화하는 방법","description":"","date":"2024-06-22 03:10","slug":"2024-06-22-UsehttpOnlycookieToSecureYourReactApp","content":"\n\n\n<img src=\"/assets/img/2024-06-22-UsehttpOnlycookieToSecureYourReactApp_0.png\" />\n\n안녕하세요 여러분, 영원한 학습자가 돌아왔어요. 처음 게시물이 백엔드 개발에 관한 것이었으니, 이번에는 프론트엔드 주제에 대해 이야기하기로 했어요. 보안과 관련된 주제를 선택했어요.\n\n사용자 세션을 관리하고 localStorage에 토큰을 저장하기로 결정한다고 상상해보세요. 이 접근 방식은 편리해 보일 수 있지만, 여러분의 토큰을 잠재적인 보안 위험에 노출시키게 됩니다.\n\n외부 사이트 스크립팅 (XSS) 공격을 통해 삽입된 악성 스크립트는 쉽게 localStorage에 접근하여 이러한 토큰을 도용할 수 있어 사용자 계정 및 중요한 정보에 미승인된 액세스를 유발할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 위험을 줄이기 위한 더 안전한 대안은 세션 토큰을 저장하기 위해 httpOnly 쿠키를 사용하는 것입니다.\n\n간단 요약.\n\n이 블로그 포스트는 React 앱에서 httpOnly 쿠키를 사용하는 방법을 설명합니다. 이미 해당 쿠키를 제공하는 API가 있는 것으로 가정합니다.\n\n# HttpOnly 쿠키란 무엇인가\n\n<div class=\"content-ad\"></div>\n\nHttpOnly 쿠키는 서버에서만 액세스할 수 있는 쿠키로, JavaScript와 같은 클라이언트 측 스크립트에서는 액세스할 수 없는 쿠키입니다.\n\nHttpOnly 속성은 Set-Cookie HTTP 응답 헤더에 포함되며, 해당 쿠키가 JavaScript의 Document.cookie API를 통해 액세스할 수 없음을 나타냅니다. 이를 통해 쿠키를 크로스 사이트 스크립팅 (XSS) 공격으로부터 보호하여 보안을 강화합니다.\n\n이러한 관행은 세션 토큰이 도용되거나 남용되는 것을 방지하여 사용자 세션의 기밀성과 무결성을 유지함으로써 웹 응용 프로그램의 보안을 강화합니다.\n\nHttpOnly 쿠키를 구현하는 것은 일반적인 웹 취약점에 대한 응용 프로그램의 방어를 강화하는 간단하고 효과적인 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n# 전제 조건\n\n다음 코드 스니펫은 다음 라이브러리를 사용합니다:\n\n- react-hook-form\n- axios\n- react-query\n- react-router-dom\n\n# 인증 시스템 설정\n\n<div class=\"content-ad\"></div>\n\n우리의 React 앱은 로그인 페이지가 있고 사용자가 로그인한 후에 리소스에 액세스할 것입니다. 로그인 폼 제출 프로세스를 설정하는 방법을 알려드리겠습니다:\n\n## 로그인 폼 제출하기\n\n이미 로그인 폼이 준비되어 있다고 가정하고, 제출 프로세스에 집중해 봅시다:\n\n```js\nimport { LoginFailure } from \"./types/LoginFailure\";\nimport { LoginRequest } from \"./types/LoginRequest\";\nimport { UserInterface } from \"./types/UserInterface\";\nimport { useMutation } from \"@tanstack/react-query\";\nimport { SubmitHandler, useForm } from \"react-hook-form\";\nimport { useAuth } from \"./Service/AuthProvider\";\nimport apiClient from './apiClient';\n\nconst Login = () => {\n  const { mutate, isPending } = useMutation({\n    mutationFn: (data: LoginRequest) => {\n      const config = { withCredentials: true };\n      return apiClient.post<UserInterface | LoginFailure>(\"/login\", data, config);\n    },\n  });\n\n  const { control, handleSubmit } = useForm<LoginRequest>({\n    defaultValues: { email: \"\", password: \"\" },\n  });\n\n  const { logUserIn } = useAuth();\n  const onSubmit: SubmitHandler<LoginRequest> = (formData) => {\n    mutate(formData, {\n      onSuccess: (response) => {\n        logUserIn();\n      },\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {/* 여기에 폼 필드를 넣으세요 */}\n    </form>\n  );\n}\n\nexport default Login;\n```\n\n<div class=\"content-ad\"></div>\n\n## 여기서 우리가 한 일은 무엇인가요 ?\n\n우리는 React 기능 컴포넌트인 Login을 만들었습니다. 이는 폼 핸들링과 뮤테이션 훅을 사용하여 사용자 로그인 기능을 다룹니다.\n\n- useMutation: React Query의 이 훅은 뮤테이션(실제로 서버에서 데이터를 변경하는 API 호출)을 다루는 데 사용됩니다.\n- useForm: React Hook Form에서는 폼 관리에 사용됩니다.\n- useAuth: 사용자 로그인을 포함한 인증 관련 작업을 처리하는 사용자 정의 훅입니다.\n- onSubmit: 폼이 제출될 때 호출되는 함수입니다.\n\nhttpOnly 쿠키를 고려해야 할 사항은 mutationFn 메서드에서 API 호출에 설정한 구성입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// ...\nmutationFn: (data: LoginRequest) => {\n  const config = { withCredentials: true };\n  return apiClient.post<UserInterface | LoginFailure>(\n    \"/login\", data, config\n  );\n},\n// ...\n```\n\n그 구성 없이는 헤더가 손실되어 React 요청이 성공하지 않을 것입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*4CPCLz6E3A5f1RAq5Cbq1A.gif)\n\n## 알아두면 좋은 사항\n\n<div class=\"content-ad\"></div>\n\nCORS 문제를 만날 수 있습니다. 해결하는 방법은 다음과 같습니다:\n\n- Node 백엔드의 경우 cors NPM 모듈을 사용하세요.\n- Symfony PHP 애플리케이션의 경우 NelmioCorsBundle을 사용하세요.\n- 허용된 출처를 설정하도록 웹 서버 구성을 업데이트하세요.\n\n⚠️ 앱과 API가 서로 다른 도메인에 위치하는 경우, API 쿠키의 sameSite 매개변수를 Lax 또는 None으로 설정해야 합니다.\n\nSymfony 앱에서 lexik/LexikJWTAuthenticationBundle을 사용하는 경우 예시가 아래에 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```yaml\nlexik_jwt_authentication:\n  secret_key: '%env(resolve:JWT_SECRET_KEY)%'\n  public_key: '%env(resolve:JWT_PUBLIC_KEY)%'\n  pass_phrase: '%env(resolve:JWT_PASSPHRASE)%'\n\n  token_extractors:\n    cookie:\n      enabled: true\n      name: BEARER\n  set_cookies:\n    BEARER:\n      # Update here to set strict, lax or none\n      samesite: none\n```\n\n# 로그인 후 리소스 가져오기\n\n우리는 login 및 홈페이지로 리디렉트를 처리하는 logUserIn() 메서드를 포함하는 custom hookuserAuth()를 구현할 것입니다.\n\n그리고 예를 들어 홈페이지에서 API 호출을 하게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\nAuthProvier를 구현했습니다.\n\n```js\nimport { Context, ReactNode, createContext, useContext, useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\ntype AuthContextType = {\n  isAuthenticated: boolean;\n  logUserIn: () => void;\n};\n\ntype AuthContextPropsType = {\n  children: ReactNode;\n};\n\nconst AuthContext: Context<AuthContextType | null> =\n  createContext<AuthContextType | null>(null);\n\nexport const AuthProvider = ({ children }: AuthContextPropsType) => {\n  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);\n  const navigate = useNavigate();\n\n  const logUserIn = () => {\n    // 예시를 위해 prop을 설정했지만 여기서 더 많은 작업이 필요합니다\n    setIsAuthenticated(true);\n    // 홈페이지로 리디렉션\n    navigate(\"/\");\n  };\n\n  return (\n    <AuthContext.Provider value={{ isAuthenticated, logUserIn }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error(\n      \"useAuth는 AuthProvider 내에서 사용되어야 합니다. 애플리케이션의 최상위 수준에 AuthProvider를 렌더링하는지 확인해주세요.\"\n    );\n  }\n\n  return context;\n};\n```\n\n여기서 우리는 무엇을 했나요?\n\n사용자 로그인 상태를 관리하고 앱 전체에서 이 상태에 액세스하고 업데이트할 수 있는 방법을 제공하기 위해 인증 컨텍스트를 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n인증 로직의 중앙 처리를 가능하게 합니다. 사용자가 한 번 로그인하면 자동으로 홈페이지로 리디렉션됩니다.\n\n## 홈페이지에서 리소스 가져오기\n\n```js\nimport { useQuery } from 'react-query';\nimport { UseQueryResult, useQuery } from \"@tanstack/react-query\";\nimport apiClient from './apiClient';\n\ntype ApiResponse = {\n  message: string;\n};\n\nexport default function HomeView() {\n  const query = useQuery<ApiResponse, Error>({\n    queryKey: [\"unique_name_example\"],\n    queryFn: async () => {\n      const response = await apiClient.get<ApiResponse>(\"/test\", {\n        withCredentials: true,\n      });\n      return response.data;\n    },\n  });\n  const { data, isFetching, isError, error }: UseQueryResult<ApiResponse, Error> = query;\n\n  return (\n    <>\n      <h1>여기는 API에서 온 메시지입니다</h1>\n      {isFetching && <div>로딩 중</div>}\n      {isError && <div>오류가 발생했습니다: {error?.message}</div>}\n      {!isError && !isFetching && <div>{JSON.stringify(data)}</div>}\n    </>\n  );\n}\n\nexport default Home;\n```\n\n여기서는 API에서 리소스를 가져오기 위해 전통적인 쿼리를 수행했고, credentials 구성도 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n{ withCredentials: true }\n```\n\n이를 통해 세션이 유지됩니다.\n\n이것을 제거하면 멋진 401 Unauthorized HTTP 응답을 받게 될 거에요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:996/1*aY_QKlVYUqtW2JmHjFaO1g.gif\" />\n\n<div class=\"content-ad\"></div>\n\n# 이어서\n\n- HttpOnly 쿠키는 XSS 공격으로부터 세션 토큰을 보호하여 앱의 보안을 강화합니다.\n- CORS를 적절하게 처리하고 SameSite 매개변수를 도메인 설정에 따라 설정하는 것을 기억하세요.\n- 마지막으로, API 호출에서 withCredentials를 true로 설정하면 세션이 유지됩니다.\n\n그리고 이로써 이 주제에 대한 내용이 마무리되었습니다.\n\n도움이 되었으면 좋겠습니다. 가능한 더 효율적으로 만들려고 노력했지만, 중요하지 않다고 생각하는 것은 생략했습니다.","ogImage":{"url":"/assets/img/2024-06-22-UsehttpOnlycookieToSecureYourReactApp_0.png"},"coverImage":"/assets/img/2024-06-22-UsehttpOnlycookieToSecureYourReactApp_0.png","tag":["Tech"],"readingTime":7},{"title":"React 컴파일러 발견 최적화된 React 마법 탐험하기","description":"","date":"2024-06-22 03:09","slug":"2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic","content":"\n\n안녕하세요, React 열정가 여러분! 오늘은 새로운 React 컴파일러에 관한 흥미로운 소식을 공유하려고 해요. React 팀에서 나온 이 편리한 도구는 React 앱을 자동으로 최적화해줍니다. 함께 React 컴파일러가 무엇인지, 시작하는 방법, 그리고 한번 시도해볼 가치가 있는 이유에 대해 알아보려고 해요.\n\n# 공사 중 🚧\n\n우선, React 컴파일러에 대한 문서 작업은 아직 진행 중입니다. 자세한 내용은 React 컴파일러 작업 그룹 레포를 확인해주세요. 하지만 지금은 전반적인 내용을 살펴볼까요?\n\n# React 컴파일러란?\n\n<div class=\"content-ad\"></div>\n\nReact Compiler은 빌드 시간에 React 앱을 최적화하기 위해 설계된 실험적인 도구입니다. 커뮤니티로부터 피드백을 모으기 위해 오픈 소스로 제공되며 일반 JavaScript와 완벽하게 작동합니다. 최고의 점은 기존 코드를 다시 작성할 필요가 없다는 것입니다.\n\n그러나 React Compiler를 사용하려면 React 19 RC가 필요합니다. 이전 버전에 머물러 있으면 해결책이 있지만 업그레이드하는 것이 가장 좋습니다.\n\n# 컴파일러는 무엇을 하는가?\n\n간단히 말해, React Compiler는 코드를 자동으로 메모이즈합니다. useMemo, useCallback 또는 React.memo를 사용해 본 적이 있다면 메모이제이션의 강력함을 알고 있을 것입니다. 컴파일러는 이를 자동으로 수행하여 효율적인 업데이트를 보장하며 별다른 노력없이 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n# Vite를 이용한 React 컴파일러 설정:\n\nReact 컴파일러를 Vite와 통합하는 것은 프로젝트의 성능을 크게 향상시킬 수 있는 간단한 과정입니다. 이 설정에서는 React 컴파일러를 쉽게 통합할 수 있는 방법을 보여주기 위해 샘플 프로젝트를 만들 것입니다. 이 설정은 Vite로 구동되는 React 앱에 React 컴파일러가 가져다주는 효율성과 속도 향상의 잠재적인 개선 사항을 보여줄 것입니다.\n\n# 필수 조건\n\n이전 버전과 호환되지 않으니 React 19 RC 이상을 사용하는지 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 설치 및 설정\n\n- 새로운 Vite 프로젝트를 만들기:\n\n가장 먼저, 새로운 Vite 프로젝트를 만들어 봅시다. 터미널을 열고 다음 명령을 실행해 주세요:\n\n```js\nnpm create vite@latest react-beta-test\n```\n\n<div class=\"content-ad\"></div>\n\n2. React 19 Beta 설치하기:\n\n이제 방금 만든 디렉토리로 이동해서 React 19 Beta를 설치해봅시다.\n\n```js\ncd react-beta-test\nnpm install react@beta react-dom@beta\n```\n\n<div class=\"content-ad\"></div>\n\nTypeScript 팬 여러분, 여기 한 가지 팁이 있습니다. 모든 것이 조화롭게 맞물리도록 package.json 파일을 조금 조정해야 합니다.\n\n```js\n\"dependencies\": {\n  \"@types/react\": \"npm:types-react@alpha\",\n  \"@types/react-dom\": \"npm:types-react-dom@alpha\",\n  \"react\": \"^19.0.0-beta-94eed63c49-20240425\",\n  \"react-dom\": \"^19.0.0-beta-94eed63c49-20240425\"\n},\n\"overrides\": {\n  \"@types/react\": \"npm:types-react@alpha\",\n  \"@types/react-dom\": \"npm:types-react-dom@alpha\"\n}\n```\n\n- Babel Plugin 설치:\n- 다음으로, React 컴파일러를 활성화할 Babel 플러그인을 설치해야 합니다. 다음 명령어를 실행해주세요:\n\n```js\nnpm install babel-plugin-react-compiler\n```\n\n<div class=\"content-ad\"></div>\n\n2. Vite 구성에 React 컴파일러 플러그인을 추가해보세요:\n\n마지막으로, Vite가 React 컴파일러 플러그인을 사용하도록 구성해 봅시다. vite.config.js 파일을 열고 다음 구성을 추가하세요:\n\n```js\n// vite.config.js\nReactCompilerConfig = {};\n\nexport default defineConfig(() => {\n  return {\n    plugins: [\n      react({\n        babel: {\n          plugins: [\n            [\"babel-plugin-react-compiler\", ReactCompilerConfig],\n          ],\n        },\n      }),\n    ],\n  };\n});\n```\n\n# 파트 1: 컴파일러 및 useMemo 없이\n\n<div class=\"content-ad\"></div>\n\n간단한 앱을 두 가지 상태로 가정해 봅시다: 숫자(n)와 카운터. 1부터 n까지 숫자의 합을 계산할 겁니다. useMemo 없이 이 계산은 컴포넌트가 다시 렌더링될 때마다 발생하게 됩니다. 카운터만 변경된 경우에도 그렇죠. 무엇이 발생하는지 확인해 볼까요? 함께 알아봐요!\n\n# 컴포넌트 설정하기\n\n우선, 두 개의 상태와 합을 계산하는 함수로 컴포넌트를 설정해 보겠습니다. App.jsx 파일의 코드를 바꿔서 결과를 확인해 보세요. (\"use no memo\"를 사용해서 컴파일러가 자동으로 메모이제이션하지 않게 합니다)\n\n```js\n\"use no memo\";\nimport React, { useState } from 'react';\nconst App = () => {\n  const [number, setNumber] = useState(1);\n  const [counter, setCounter] = useState(0);\n  const calculateSum = (n) => {\n    console.log('합을 계산 중...');\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  const sum = calculateSum(number);\n  return (\n    <div>\n      <h1>1부터 {number}까지의 합: {sum}</h1>\n      <button onClick={() => setNumber(number + 1)}>숫자 증가</button>\n      <button onClick={() => setCounter(counter + 1)}>카운터 증가</button>\n      <p>카운터: {counter}</p>\n    </div>\n  );\n};\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n# 불필요한 재렌더링 관찰\n\n이 설정에서는 \"Increment Counter\" 버튼을 클릭할 때마다 숫자가 변경되지 않았음에도 불구하고 calculateSum 함수가 실행됩니다. 콘솔을 확인해보세요 - 매번 \"Calculating sum...\"이 기록되는 것을 볼 수 있을 겁니다. 이것은 비효율적입니다! 숫자가 변경되지 않았다면 sum을 다시 계산하고 싶지 않습니다.\n\n# 파트 2: 컴파일러 없이 useMemo 사용하기\n\n여기서 마법이 벌어집니다. 숫자를 종속성으로 전달하여 calculateSum 호출을 useMemo로 감싸겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# useMemo 추가하기\n\n컴포넌트를 최적화해보죠. number가 변경될 때에만 계산이 발생하도록 useMemo를 사용해보세요.\n\n```js\n\"use no memo\";\nimport React, { useState, useMemo } from 'react';\nconst App = () => {\n  const [number, setNumber] = useState(1);\n  const [counter, setCounter] = useState(0);\n  const calculateSum = (n) => {\n    console.log('계산 중...');\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  const sum = useMemo(() => calculateSum(number), [number]);\n  return (\n    <div>\n      <h1>1부터 {number}까지의 합: {sum}</h1>\n      <button onClick={() => setNumber(number + 1)}>숫자 증가</button>\n      <button onClick={() => setCounter(counter + 1)}>카운터 증가</button>\n      <p>카운터: {counter}</p>\n    </div>\n  );\n};\nexport default App;\n```\n\n# 최적화 즐기기\n\n<div class=\"content-ad\"></div>\n\n이제 useMemo가 적용되어 있어서 calculateSum 함수는 숫자가 변경될 때만 실행됩니다. 한 번 시도해보세요! \"Increment Counter\" 버튼을 클릭하고 콘솔을 확인해보세요. 불필요한 \"Calculating sum...\" 메시지가 사라졌죠. 높은 다섯! 🖐\n\n# 파트 3: 컴파일러와 함께\n\n상상해보세요: 프로젝트를 작업 중인데 useMemo를 추가하는 것을 깜빡했습니다. 걱정하지 마세요! 우리 마법같은 React 컴파일러가 자동으로 추가해 줍니다. 어떻게 작동하는지 보겠습니다. (우리는 \"use no memo\"를 사용하지 않기 때문에 컴파일러가 자체적으로 동작합니다)\n\n# 마법 같은 컴파일러 동작 방식\n\n<div class=\"content-ad\"></div>\n\n리액트 컴파일러를 사용하면, useMemo 없이 코드를 작성해도 컴포넌트가 자동으로 최적화됩니다. 다시 원본 코드를 확인해보겠습니다:\n\n```js\nimport React, { useState } from 'react';\nconst SumComponent = () => {\n  const [number, setNumber] = useState(1);\n  const [counter, setCounter] = useState(0);\n  const calculateSum = (n) => {\n    console.log('Calculating sum...');\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  const sum = calculateSum(number);\n  return (\n    <div>\n      <h1>Sum from 1 to {number}: {sum}</h1>\n      <button onClick={() => setNumber(number + 1)}>Increment Number</button>\n      <button onClick={() => setCounter(counter + 1)}>Increment Counter</button>\n      <p>Counter: {counter}</p>\n    </div>\n  );\n};\nexport default SumComponent;\n```\n\n# 최고 수준의 자동 최적화\n\n![image](/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png)\n\n<div class=\"content-ad\"></div>\n\n컴파일러의 마법 덕분에 이 코드는 자동으로 변경되어 useMemo을 포함하여 효율적인 다시 렌더링을 보장해줍니다. 우리는 손가락 한 번 까딱하지 않아도 됩니다! 컴파일러는 필요한 곳에 useMemo를 추가하여 컴포넌트를 최적화합니다. 콘솔을 다시 확인해보세요 – \"Calculating sum...\" 메시지가 필요없어졌죠. 마치 성능 요정이 어깨에 앉아 있는 느낌이에요! 🧚‍♂️\n\n# 해볼 가치가 있을까요?\n\nReact 컴파일러는 아직 실험 단계이며 베타 버전으로, 완전히 제품으로 출시되지는 않았습니다. Meta에서 이미 사용 중이지만, 여러분의 앱에 적합한지 여부는 코드가 React의 규칙을 얼마나 잘 준수하는지에 달려 있습니다.\n\n컴파일러를 더 작은 프로젝트나 앱의 일부분에서 실험하는 것이 전체 앱에서 시도하는 것보다 좋은 아이디어입니다.\n\n<div class=\"content-ad\"></div>\n\n# 마무리하며\n\nReact 컴파일러는 React 앱의 성능을 최적화해줄 것으로 기대되는 흥미로운 새로운 도구입니다. 아직 개발 중이고 베타 버전이지만, 앱 성능을 향상시키려는 열정을 가지고 있다면 탐색할 가치가 있습니다. 한번 시도해보고 생각을 공유해보세요!\n\n이 개요가 React 컴파일러에 대해 흥미를 느끼게 해주기를 바랍니다. 궁금한 점이나 의견이 있으시면 언제든 댓글로 남겨주세요. 즐거운 코딩 되세요! 🎉","ogImage":{"url":"/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png"},"coverImage":"/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png","tag":["Tech"],"readingTime":7},{"title":"TypeScript로 React의 forwardRef 완벽 마스터하기","description":"","date":"2024-06-22 03:08","slug":"2024-06-22-MasteringforwardRefinReactwithTypeScript","content":"\n\n부모 컴포넌트에서 자식 컴포넌트의 DOM 요소에 액세스하거나 메서드를 호출합니다.\n\n![이미지](/assets/img/2024-06-22-MasteringforwardRefinReactwithTypeScript_0.png)\n\n## 소개\n\nReact에서 참조(refs)를 처리하고 부모 컴포넌트가 자식 컴포넌트와 상호 작용하는 것은 까다로울 수 있습니다. 다행스럽게도, React의 forwardRef 기능을 사용하면 이러한 상호작용을 효율적으로 관리할 수 있는 좋은 방법을 제공합니다. TypeScript와 함께 사용될 때, forwardRef는 컴포넌트간의 통신을 더 원활하게 만들뿐만 아니라 코드 안전성과 유지 보수의 용이성을 향상시킵니다. 이 안내서에서는 TypeScript와 함께 forwardRef를 사용하는 방법을 살펴보고, 실용적인 예제를 보여주며 최상의 사용 사례에 대한 팁을 공유할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## forwardRef 이해하기\n\nReact에서 forwardRef를 사용하면 참조(ref)를 한 컴포넌트를 통해 바로 해당 컴포넌트의 자식 컴포넌트로 전달할 수 있습니다. 이 기술은 특히 부모 컴포넌트에서 자식 컴포넌트의 DOM 요소에 직접 액세스하거나 메소드를 호출하는 데 유용합니다.\n\n## TypeScript와 함께 사용하는 기본 구문\n\n```js\nimport { forwardRef } from 'react';\n\nconst MyComponent = forwardRef((props, ref) => {\n  return <button ref={ref} onClick={props.onClick}>Click Me!</button>;\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# TypeScript를 이용한 간단한 예제\n\n자식 구성 요소에서 DOM 요소에 액세스하기 위해 forwardRef를 사용하는 간단한 사용 사례를 보여드립니다.\n\n## forwardRef를 사용한 자식 구성 요소\n\n```js\nimport { forwardRef } from 'react';\n\nconst TextInput = forwardRef<HTMLInputElement, { placeholder: string }>(\n  (props, ref) => {\n    return <input ref={ref} type=\"text\" placeholder={props.placeholder} />;\n  }\n);\n```\n\n<div class=\"content-ad\"></div>\n\n## 부모 컴포넌트가 자식의 DOM 노드에 액세스하는 방법\n\n```js\nimport { useRef, useEffect } from 'react';\n\nconst App: React.FC = () => {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    inputRef.current?.focus();\n  }, []);\n\n  return <TextInput ref={inputRef} placeholder=\"Focus on me\" />;\n};\n```\n\n이 예제에서 부모 컴포넌트는 TextInput 컴포넌트에 포커스를 맞추며, DOM 요소를 조작하기 위해 forwardRef를 간단하게 활용한 것을 보여줍니다.\n\n# 고급 사용법: 자식 컴포넌트 메서드 노출\n\n<div class=\"content-ad\"></div>\n\n더 복잡한 시나리오는 자식 컴포넌트 메서드를 부모에 노출하는 것을 포함합니다. 이것이 forwardRef가 진정으로 빛을 발하는 곳이며, 특히 useImperativeHandle과 함께 사용할 때 빛을 발합니다.\n\n## 노출된 메서드를 가진 자식 컴포넌트\n\n이 시나리오에서는 onClick 메서드를 노출하는 버튼이 있습니다. 이 메서드는 부모 컴포넌트에서 트리거될 것입니다.\n\n```js\nimport { forwardRef, useImperativeHandle } from \"react\";\n\ninterface ChildProps {}\n\n/**\n * 부모 컴포넌트에 노출될 인터페이스입니다.\n */\nexport interface ChildRef {\n  onClick: () => void;\n}\n\nexport const ChildComponent = forwardRef<ChildRef, ChildProps>((props, ref) => {\n  const onClick = () => {\n    alert(\"자식 컴포넌트의 버튼이 클릭되었습니다!\");\n  };\n\n  /**\n   * `onClick` 함수를 부모 컴포넌트에 노출합니다.\n   */\n  useImperativeHandle(ref, () => ({\n    onClick,\n  }));\n\n  return <button onClick={onClick}>알림 표시하기!</button>;\n});\n```\n\n<div class=\"content-ad\"></div>\n\n## 자식을 제어하는 부모 컴포넌트\n\n부모 컴포넌트에서는 자식 컴포넌트의 `onClick` 메서드를 트리거할 것입니다. 여기서는 또한 `ChildRef`를 사용하여 ref의 타입을 지정합니다.\n\n```js\nimport { useRef } from \"react\";\n\nimport { ChildComponent, ChildRef } from \"../child\";\n\nexport const App: React.FC = () => {\n  const childRef = useRef<ChildRef>(null);\n\n  const triggerChild = () => {\n    childRef.current?.onClick();\n  };\n\n  return (\n    <div className=\"app\">\n      <header>\n        forwardRef의 사용법을 보여줍니다.{\" \"}\n        <a onClick={triggerChild}>여기를 클릭</a>하여 자식 컴포넌트의 버튼을 클릭하는 이벤트를 발생시킵니다.\n      </header>\n\n      <div className=\"child\">\n        <ChildComponent ref={childRef} />\n      </div>\n    </div>\n  );\n};\n```\n\n이 섹션은 TypeScript에서 `forwardRef`와 `useImperativeHandle`를 결합하여 자식 컴포넌트의 동작을 제어하는 방법을 보여줍니다. 이 패턴을 사용하여 아코디언을 토글하거나 모달을 열기와 같은 다양한 기능을 구현할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nGitHub 레포지토리에서 고급 예제의 완전한 소스 코드를 찾아볼 수 있습니다: [https://github.com/mattdeveloper/mastering-react-forward-ref](https://github.com/mattdeveloper/mastering-react-forward-ref)\n\n# forwardRef를 사용한 컴포넌트 타입 지정\n\nTypeScript에서 forwardRef를 사용할 때, props와 refs에 알맞은 유형을 정의하여 타입 안정성을 보장하는 것이 매우 중요합니다.\n\n## 유형 정의\n\n<div class=\"content-ad\"></div>\n\n컴포넌트의 props와 ref를 명확히하려면 먼저 각각의 타입을 정의해야 합니다.\n\n```js\ninterface MyComponentProps {\n  label: string;\n}\n\ninterface MyComponentRef {\n  focus: () => void;\n}\n```\n\n## 타입 구현하기\n\n정의된 타입을 사용하여 forwardRef를 이용해 컴포넌트를 구현하세요. 이렇게 하면 props와 ref가 명시된 타입에 따라 작동하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst MyComponent = forwardRef<MyComponentRef, MyComponentProps>((props, ref) => {\n  const internalRef = useRef<HTMLInputElement>(null);\n\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      internalRef.current?.focus();\n    },\n  }));\n\n  return <input ref={internalRef} aria-label={props.label} />;\n});\n```\n\n# 소스 코드\n\n여기 고급 예제의 완전한 소스 코드가 포함된 GitHub 리포지토리가 있습니다: https://github.com/mattdeveloper/mastering-react-forward-ref\n\n# 최고의 사례와 고려 사항\n\n<div class=\"content-ad\"></div>\n\n컴포넌트에서 forwardRef를 활용할 때, 특히 TypeScript와 함께 사용할 때는 다음과 같은 모범 사례를 고려해보세요:\n\n- forwardRef를 사용하는 경우는 자식 컴포넌트의 DOM 노드나 메서드에 직접 액세스해야 할 때에만 사용하세요.\n- useImperativeHandle을 활용하여 자식 컴포넌트의 필요한 기능만 노출시켜 컴포넌트의 API를 깔끔하고 명시적으로 유지하세요.\n- 중첩된 컴포넌트나 forwardRef를 다룰 때 특히 ref를 올바르게 전파하세요.\n\n# 결론\n\n특히 TypeScript와 함께 사용할 때 forwardRef는 React 컴포넌트의 유연성, 재사용성, 유형 안정성을 향상시키는 강력한 방법을 제공합니다. 사용 패턴과 모범 사례를 이해하면 더 유지보수하기 쉽고 견고한 React 애플리케이션을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-MasteringforwardRefinReactwithTypeScript_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringforwardRefinReactwithTypeScript_0.png","tag":["Tech"],"readingTime":5},{"title":"동적이고 확장 가능한 마이크로 프런트엔드 모듈 페더레이션 사용 방법","description":"","date":"2024-06-22 03:06","slug":"2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation","content":"\n\n![DynamicScalableMicro-FrontendswithModuleFederation_0](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_0.png)\n\n안녕하세요! \n\nKredX는 내국 (인보이스 할인) 및 국제 (글로벌 무역 금융 거래소)에서 접근성을 보장하는 공급망 금융(SCF) 플랫폼입니다.\n\n인도의 중소기업 및 중소기업(MSME) 부문의 급속한 성장을 고려해, KredX는 이 섹터의 모든 금융 요구에 대한 일괄 해결책으로 나타났습니다. 우리는 SCF 및 현금 관리 솔루션(CMS) SaaS 생태계의 다양한 측면에서 빠르게 발전하고 있습니다.\n\n성장에는 주의가 필요합니다!\n비즈니스의 보다 광범위한 요구를 충족하기 위해, 저희의 SCF 제품 중 하나인 인보이스 할인(ID)의 코드베이스는 거대한 단일체(monolith)가 되었으며, 이로 인해 개발자의 생산성을 저해하고 독자적인 변경이 적게 유연해졌습니다.\n\n<div class=\"content-ad\"></div>\n\n마크다운 포맷으로 위의 텍스트를 번역하겠습니다.\n\n![이미지](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_1.png)\n\n매일 개발하는 것이 얼마나 어려워졌는지 이해하는 데 도움이 되었으면 좋겠습니다. 우리의 ID 프론트엔드 코드 빌드 시간이 거의 50-55분이 걸리고, 프로젝트를 로컬에서 실행하는 데 약 8-12분이 소요됩니다.\n\n오늘날, 프로젝트는 너무 끌려다붙었다고 할 정도로 심각해졌는데, 우리의 단일 내부 모듈 중 하나에 문제가 발생하면 전체 앱에 영향을 줄 수도 있습니다(무하랏 모듈의 단일 문제가 금융가 및 관리자 대시보드 전체를 다운시키는 문제가 발생) 그리고 때로는 여러 제품에도 영향을 미칠 수 있습니다(재사용할 수 없는 인증 과정으로 인해 여러 제품에 영향을 미침).\n\n기존 단일체 아키텍처의 고통\n코드베이스가 커짐에 따라 여러 문제가 시작되었습니다:\n\n<div class=\"content-ad\"></div>\n\n- 빌드 시간이 길어짐: 코드베이스의 크기가 커지면 개발 서버를 시작하는 데와 HMR이 개발자 변경 사항을 반영하는 데 더 오래 걸립니다.\n- 높은 인지 부담: 여러 앱의 코드가 동일한 저장소에 있기 때문에, 개발자가 이해해야 하는 코드 영역이 증가하여 개발자의 인지 부담이 커집니다.\n- 단일 장애점: 모놀리스의 어떤 부분에서 버그가 발생하면 전체 애플리케이션을 다운시키는 결과를 가져옵니다. 즉, 모든 다양한 사용자 설정이 영향을 받아 신뢰성이 떨어지고 수동 및 자동화된 테스트에 더 많은 부담이 생깁니다.\n- 독립적인 CI/CD 부재: 금융 자금 할인용으로 사용되는 동일한 ID 코드베이스가 운영자용 대시보드, IPA용 대시보드, GTX용 인증 흐름, KredX Financier 앱에 대한 일반 코드, 그리고 그 이외 많은 곳에도 사용됩니다. 한 모듈의 작은 변경이 전체 코드베이스의 배포를 필요로 합니다.\n\n우리에게는 코드베이스를 더 작고 독립적인 모듈로 분리할 수 있는 해결책이 필요하다는 점이 매우 명확했습니다. 각 모듈은 유연하여 매끄럽게 플러그인하고 플러그아웃할 수 있어야 하며, 개발, 테스트 및 배포를 독립적으로 수행할 수 있어야 합니다.\n\n기술적인 탐색은 이곳에서 시작됩니다.\n동적이고 확장 가능한 솔루션을 찾기 위한 연구\n\n해당 솔루션에 대한 고민에 들어가기 전에 솔루션이 어떻게 보일지에 대한 몇 가지 기준을 결정했습니다:\n\n<div class=\"content-ad\"></div>\n\n- 좋은 개발자 경험: 이 솔루션은 전반적인 개발자 경험을 향상시켜야 합니다.\n- 최소한의 아키텍처 변경: 기존 웹 아키텍처에 급격한 수정이 필요하지 않아야 합니다.\n- 구성의 용이성: 솔루션을 비교적 쉽게 구성할 수 있어야 합니다.\n- 점진적인 학습 곡선: 개발자들에게 순차적인 학습 곡선을 가지며 빠른 도입을 용이하게 해야 합니다.\n- 미래 기술 이전: 미래 기술 이전을 위해 솔루션을 쉽게 분리할 수 있어야 합니다.\n- 커뮤니티 지원 및 미래 비전: 강력한 커뮤니티 지원과 미래 비전을 가져야 합니다.\n\n다양한 접근법\n문제를 자세히 고려하여, 우리는 몇 가지 실행 가능한 접근법을 식별했습니다:\n\n![Dynamic Scalable Micro-Frontends with Module Federation](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_2.png)\n\n우리가 시도한 솔루션 중에, Module Federation과 Monorepo가 모든 영역을 충족하고 그 이상을 제공하는 솔루션이라는 것을 발견했습니다.\n\n<div class=\"content-ad\"></div>\n\n결국, 모듈 페더레이션이 무엇인가요?\n믿어봐요, 기다릴 가치가 있어요!\n\n모듈 페더레이션은 Webpack 및 Rspack의 고급 기능으로, JavaScript 애플리케이션을 분산화하는 아키텍처 패턴을 제공하여 (서버 측의 마이크로서비스와 유사하게) 다른 애플리케이션(또는 마이크로 프론트엔드)로부터 코드를 동적으로 로드할 수 있는 방법을 제공합니다. 이는 다음과 같은 이점을 제공할 수 있어요:\n\n- 코드 중복 감소\n- 코드 유지 관리성 향상\n- 애플리케이션 전체 크기 감소\n- 애플리케이션 성능 향상\n\n모듈 페더레이션의 주요 요소\n모듈 페더레이션 애플리케이션에서는 이해해야 할 여러 요소가 있지만, 아키텍처를 설명할 수 있는 3가지 요소가 있어요:\n\n<div class=\"content-ad\"></div>\n\n- 호스트 또는 셸: 이름 그대로, 이것은 여러 연합된 원격 모듈과 결합될 수 있는 컨테이너입니다. (그 자체가 연합된 모듈임)\r\n- 원격: 자바스크립트, 기본 값, 복잡한 값 또는 전체 모듈 모두 일 수 있습니다. 원격에서 노출하고자 하는 내용은 무엇이든 될 수 있습니다. 기본적으로 이러한 원격 모듈은 최종 조각을 만들기 위해 셸 안에 결합됩니다.\r\n- 공유 의존성: 다른 원격들 간에 공유되는 패키지/라이브러리와 같은 종속성입니다. 이로 인해 중복이 줄어들고 코드 크기도 작아집니다.\n\n모든 이러한 설정은 웹팩 구성 내에서 이루어집니다.\n\n![이미지1](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_3.png)\n\n![이미지2](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_4.png)\n\n<div class=\"content-ad\"></div>\n\n여러 가지 방법으로 모듈 연합을 활용할 수 있습니다.\n연합 모듈을 사용하는 방법에는 다음과 같은 다양한 유연성이 있습니다.\n\n- 도메인 수준: 여기에 각 연합 모듈은 별도의 도메인에 호스팅되어 독립적으로 사용됩니다.\n- 위젯/컴포넌트 수준: 이 방법을 통해 어떤 앱에서든 다른 앱으로부터 어떤 위젯(예: 작은 코드 조각)을 추가할 수 있습니다.\n- 하이브리드 수준: 첫 번째와 두 번째 방법을 함께 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_5.png)\n\n저희는 우리의 요구에 하이브리드 방법을 선택했습니다. 이곳에서 호스트는 여러 마이크로 프론트엔드(원격)간의 탐색 로직 뿐만 아니라 루트의 지연 로딩도 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 다양한 리모트들 사이에서 모든 공통 유틸, 컴포넌트, 훅 등을 처리하는 일반 위젯/컴포넌트 페더레이티드 모듈도 만들었습니다.\n\n그저 하나의 웹팩 플러그인을 추가하면 끝이라고요? 그 답은: 네와 아니요 둘 다!\n\n네, 의심의 여지가 없이 이것은 극적인 변화를 일으키지 않으며, 모듈을 레고처럼 간단하게 만들어 코드베이스에 쉽게 꽂아 넣고 뺄 수 있게 만들어 줍니다. 게다가, 다른 웹팩 플러그인 옆에 앉아서 단순히 연결하기만 하면 됩니다.\n\n하지만, 아니요, 저희 팀이 이를 해결하느라 겪은 일부 고통스러운 문제가 있었습니다. 주요 문제로는 오류 처리, 버전 리소스 및 버전 관리, HMR, 타입 안전성 등이 있었어요.\n\n<div class=\"content-ad\"></div>\n\n각각의 내부 요구사항과 접근법에 따라 이 문제에 대한 여러 가지 다른 방법을 얻을 수 있습니다. 간단히 말씀드리면, 오늘은 가장 일반적이고 귀찮은 문제인 Type-Safety에 대해 이야기해 볼 거예요. 우리는 개발자가 로컬에서 코드를 작성할 때 타입 안전성과 자동 완성을 원하며, 추가로 타입 확인을 실행하여 TS 오류가 없는지 확인하고 싶어해요.\n\n타입 안전성을 되찾아보자!\n\n우리는 모노 저장소 구조를 사용하기 때문에 생성된 .d.ts 파일들을 참조하려고 노력했어요. 작동은 했지만 모노 저장소 구조와 결합되었고 외부 모듈에 독립적으로 사용할 수 없었어요.\n\n그 다음으로 시도한 것은 타입을 NPM 패키지로 내보내는 것이었지만 이 문제가 우리에게 큰 장애물이었어요.\n\n<div class=\"content-ad\"></div>\n\n마침내 확장 가능한 솔루션이다. 이 솔루션에는 웹팩 구성 내부에 다음 도구가 포함되어 있습니다.\n\n- dts-loader: 모든 d.ts 파일을 별도의 폴더에 생성하는 데 사용됨\n- ExternalTemplateRemotesPlugin: 원격지에서 생성된 타입 tar 파일을 다운로드함\n\n![이미지](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_6.png)\n\n기본적으로 자바스크립트와 함께 생성된 유형의 tar 파일을 번들링하며, 해당 원격지가 사용된 곳에서 ExternalTemplateRemotesPlugin을 통해 해당 파일을 다운로드합니다.\n\n<div class=\"content-ad\"></div>\n\n저희가 새로운 애플리케이션을 만들었는데 ID의 모든 경우/기능이 다 다뤄지지 않았기 때문에 이 결과는 사전 보드 결과와 비슷할 것입니다. 지금은 대략적인 방향을 얻을 수 있습니다;\n\n![이미지](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_7.png)\n\n축하합니다! 성공하셨네요!\n의문이나 제안이 있으면 댓글에 남겨주세요. 또는 제 소셜 미디어 ID 중 하나로 메시지를 남겨주세요. 이처럼 도전을 해결하는 것을 즐기신다면, 저희 채용 페이지 https://www.kredx.com/join-our-team을 꼭 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_0.png"},"coverImage":"/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_0.png","tag":["Tech"],"readingTime":6}],"page":"26","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}