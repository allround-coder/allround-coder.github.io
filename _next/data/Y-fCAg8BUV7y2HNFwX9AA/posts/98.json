{"pageProps":{"posts":[{"title":"아두이노와 iOS 간의 블루투스 연결","description":"","date":"2024-05-15 04:34","slug":"2024-05-15-BluetoothconnectionbetweenArduinoandiOS","content":"\n\n# 소개\n\n안녕하세요!! 여기에 오신 것을 환영합니다. 아두이노 장치에서 iOS 장치로 블루투스를 사용하여 데이터를 송수신하는 방법을 찾고 계시다고 생각합니다, 맞나요? (빌드할 내용을 설명하는 비디오가 있는 GitHub 링크를 여기에 배치했습니다).\n\n이를 위해 지식을 두 부분으로 나누기로 결정했습니다. 첫 번째 부분에서는 하드웨어 구체적인 내용, 블루투스 모듈의 조립 및 아두이노 코드를 통해 정보를 전송하는 방법에 대해 다룰 것입니다. 이 문서의 후반부에서는 iOS 개발에 대해 다룰 예정입니다.\n\n# 블루투스 모듈\n\n\n\n이 프로젝트에서는 에너지 소비가 적은 통신 형태인 블루투스를 아두이노와 IOS 장치 간에 사용하기로 결정했습니다. 이것은 배터리로 아두이노를 사용할 때 중요한 요소입니다.\n이를 염두에 두고 프로젝트를 시작할 때의 첫 번째 질문은 아두이노에 이미 블루투스가 내장되어 있는지 여부입니다(이를 위해 문서에 접근할 수 있음). 저의 경우, 블루투스가 내장되어 있지 않은 ArduinoUno를 사용할 예정이므로 이 기술을 제공하는 모듈이 필요합니다.\n\n어떤 모듈을 사용해야 할까요?\niOS 기기는 BLE(Bluetooth Low Energy)라는 기술을 사용하여 통신하며, 일반적인 블루투스와 차이가 있지만, 이는 다른 기사로 남기겠습니다. 따라서 BLE를 지원하는 모듈이 필요하며, 여러 옵션이 있습니다(구매하기 전에 주의하세요), 하지만 저는 HC-08 모듈을 사용할 예정입니다.\n\n![Image](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png)\n\n# Arduino에 HC-08 연결하기\n\n\n\n조립을 더 잘 설명하기 위해 어셈블리를 시연하기 위한 다이어그램을 만들었습니다.\n\n![Bluetooth Connection Diagram](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_1.png)\n\n프로젝트에서 핀 2와 3을 이미 사용 중이라면, TX 및 RX를 사용 가능한 핀에 연결할 수 있습니다(이 경우 SoftwareSerial을 사용합니다). 그러나 코드에 도달하면 사용 중인 핀을 변경해야 합니다.\n이미지에 문제가 있을 경우, HC-08에서 아두이노로 연결되는 방법을 적어놓겠습니다:\n\n- VCC → 5V\n- GND → GND\n- TXD(송신) → 2\n- RXD(수신) → 3\n\n\n\n# 코딩 시간\n\n우리가 아두이노에 업로드할 코드는 블루투스 모듈(나의 iOS 기기에 연결될 것)로 정보를 보내고, 그 모듈은 나의 iOS 기기로 데이터를 전송할 것을 목적으로 합니다.\n\n```js\n#include \"SoftwareSerial.h\"\nSoftwareSerial bluetooth(3, 2); //3 = RX ; 2 = TX\n```\n\n기본적으로, 코드의 이 부분에서는 SoftwareSerial 라이브러리를 사용하고 있습니다. 이 라이브러리를 사용하면 아두이노 디지털 핀에 추가적인 시리얼 포트를 생성할 수 있습니다. 이 기능은 시리얼 통신이 필요하지만 이미 주 시리얼 포트를 코드를 디버깅하기 위한 시리얼 모니터로 사용하는 경우와 같이 주 시리얼 포트가 다른 목적으로 이미 사용 중인 경우 유용합니다.\n\n\n\n소프트웨어 시리얼 인스턴스가 이름이 \"bluetooth\"인 것을 만들었습니다. 매개변수 (3, 2)는 아두이노의 핀 3을 RX(수신)로, 핀 2를 TX(송신)로 사용할 것을 나타냅니다 (기본적으로 첫 번째 숫자가 RX이며 두 번째 숫자가 TX입니다).\n\n⚠️만약 다른 핀을 사용했다면, 숫자를 변경하세요.⚠️\n\n```js\nvoid setup() {\n  Serial.begin(9600);\n  bluetooth.begin(9600);\n}\n```\n\n설정 함수에서(스크립트가 실행될 때에만 실행되는 함수), 아두이노와 컴퓨터 사이에 표준 시리얼 포트를 통해 초당 9600비트의 속도로 시리얼 통신을 시작합니다 (디버깅에 유용합니다).\n\n\n\n이제 \"블루투스\"라고 불리는 객체의 직렬 통신을 9600 비트로 설정하여 시작합니다. 이는 아두이노와 핀 2와 3에 연결된 블루투스 모듈 간의 통신을 수립합니다.\n\n```js\nvoid loop() {\n    bluetooth.print(\"성공!\"); \n    delay(2000);\n    bluetooth.print(\"잘 했어요!\");\n    delay(2000);\n}\n```\n\n이제 우리의 루프에서는 코드가 계속해서 실행되며, 기본적으로 블루투스 모듈과 통신하도록 한 책임자에게 문자열을 보내고 있습니다. 매 2초마다 다른 문자열을 보내고 있습니다.\n\n이 코드 스니펫의 아이디어는 여러분의 프로젝트에 맞는 데이터를 가져와 생성된 통신으로 보내는 것입니다. 이 경우 문자열만 보내고 있지만 다양한 유형의 데이터를 보낼 수 있습니다.\n\n\n\n# iOS 프로젝트\n\n지금까지 배운 것으로는, 코드와 아두이노가 준비가 되어 블루투스 장치와 연결하고 정보를 전송할 수 있게 되었어요. 이제는 SwiftUI iOS 프로젝트를 만들어야 할 때입니다.\n\n# XCode 권한\n\nXCode에서 프로젝트를 생성한 후, \"info.plist\"에 블루투스 사용을 추가해야 합니다. 그러면 애플리케이션이 사용자에게 다른 블루투스 장치에 연결할 권한을 요청할 수 있어요.\n\n\n\n프로젝트 파일에 액세스하고 \"info\" 탭에 들어가야 해요. 그 화면에 들어가면 기존 항목 위에 마우스 포인터를 두고 \"＋\"를 클릭해서 \"Privacy — Bluetooth Peripheral Usage Description\"을 추가해야 해요.\n\n우리가 추가할 이 권한은 사용자에게 Bluetooth 장치에 연결할 권한을 요청하는 것이에요. \"value\"는 연결을 요청하는 메시지로 사용자에게 표시될 거에요.\n\n그런데 다른 권한인 \"Privacy — Bluetooth always usage Description\"도 있어요. 이 권한은 앱이 종료되어도 계속 Bluetooth을 사용하도록 사용자에게 요청하는데, 우리가 여기서 제안한 프로젝트에는 필요 없는 권한이에요.\n\n권한을 추가한 후에는 우리의 \"info\" 목록에 새로운 줄이 이렇게 보여야 해요:\n\n\n\n# Swift 코딩\n\n이제 Arduino를 준비하고 Bluetooth를 사용하기 위한 필수 권한을 설정했으니, 코드 작성을 시작할 수 있습니다.\n\n이 맥락에서, 이 기사에서 \"BluetoothController\"라고 부르는 부분만 설명하겠습니다. 이 컨트롤러에서 수집된 정보와 데이터를 표시하는 뷰는 GitHub에서 액세스할 수 있지만, 기본적으로 컨트롤러에서 수집된 정보와 데이터를 표시합니다.\n\n이 매체 기사의 이 부분에서 설명하고자 하는 섹션을 넣은 다음, 더 작은 섹션으로 나누어 각각 설명하겠습니다. 세 개의 점을 통과할 때마다, 새로운 섹션을 설명하기 시작함을 나타냅니다.\n\n\n\n이렇게 할 것입니다:\n\n```js\nimport Foundation\nimport CoreBluetooth\nclass BluetoothController: NSObject, ObservableObject, CBPeripheralDelegate {\n    \n    private var centralManager: CBCentralManager!\n    \n    @Published var connectedPeripheral: CBPeripheral?\n    @Published var discoveredPeripherals = [CBPeripheral]()\n    @Published var isConnected = false\n    @Published var bluetoothStatus: BluetoothStatus = .off\n    @Published var valueReceived: String?\n   \n    override init() {\n        super.init()\n        centralManager = CBCentralManager(delegate: self, queue: nil)\n        centralManagerDidUpdateState(centralManager)\n    }\n}\n```\n\n\"BluetoothController\"은 뷰에서 정보에 액세스할 것이므로 observable해야 하고, ObjectiveC stuff를 사용할 예정이므로 NSObject여야 하며, 연결될 블루투스 장치(페리페럴)로부터 이벤트를 처리할 수 있는 메서드를 정의하는 CoreBluetooth가 제공하는 프로토콜인 CBPeripheralDelegate를 준수해야 합니다.\n\n```js\nprivate var centralManager: CBCentralManager!\n```\n\n\n\n우리는 CBCentralManager 타입의 centralManager 변수를 생성했습니다. 이는 CoreBluetooth에서 제공하는 타입으로, BLE 통신에서 중심 역할을 하는 Bluetooth \"페리페랄\"과 통신 관리를 담당합니다.\n\n```js\n@Published var connectedPeripheral: CBPeripheral?\n@Published var discoveredPeripherals = [CBPeripheral]()\n@Published var isConnected = false\n@Published var bluetoothStatus: BluetoothStatus = .off\n@Published var valueReceived: String?\n```\n\n생성된 이 변수들은 화면에 표시할 정보입니다.\n\n```js\noverride init() {\n        super.init()\n        centralManager = CBCentralManager(delegate: self, queue: nil)\n        centralManagerDidUpdateState(centralManager)\n}\n```\n\n\n\n마지막으로, init을 사용하여 우리의 슈퍼클래스인 NSObject을 초기화하는 init 메서드가 있습니다. 여기서 모든 BluetoothController의 추가 설정을 제공하기 전에 NSObject에서 제공하는 모든 것을 초기화합니다.\n\ncentralManager = CBCentralManager(delegate: self, queue: nil) - 이 줄은 Bluetooth 통신을 위한 \"중앙 매니저\"인 CBCentralManager의 인스턴스를 초기화합니다. 중앙 매니저의 \"delegate\"를 self로 설정하여 BluetoothController 인스턴스가 Bluetooth 이벤트에 관련된 반환을 받게 됩니다. 상태 변경, 페리페럴 발견 등과 관련된 반환에 대한 delegate로서 센트럴 매니저가 메인 디스패치 큐를 사용할 것을 나타내는 queue 매개변수는 nil로 설정되어 있습니다.\n\ncentralManagerDidUpdateState(centralManager) - 이 줄은 BluetoothController의 centralManagerDidUpdateState 메서드를 직접 호출합니다. 이 메서드는 CBCentralManagerDelegate 프로토콜의 일부이며 Bluetooth 상태가 변경될 때 호출됩니다. 센트럴 매니저를 초기화한 후 이 메서드를 직접 호출함으로써 BluetoothController 인스턴스가 초기화 직후 현재 Bluetooth 상태를 처리할 수 있도록 보장됩니다.\n\n```js\nextension BluetoothController: CBCentralManagerDelegate {\n    \n    func centralManagerDidUpdateState(_ central: CBCentralManager) {\n        switch central.state {\n        case .poweredOn:\n            centralManager.scanForPeripherals(withServices: nil, options: nil)\n            bluetoothStatus = BluetoothStatus.on\n            \n        case .poweredOff:\n            self.connectedPeripheral = nil\n            self.discoveredPeripherals = []\n            self.isConnected = false\n            self.valueReceived = nil\n            bluetoothStatus = BluetoothStatus.off\n            \n        case .resetting:\n            // Wait for next state update and consider logging interruption of Bluetooth service\n            bluetoothStatus = BluetoothStatus.resetting\n            \n        case .unauthorized:\n            // Alert user to enable Bluetooth permission in app Settings\n            bluetoothStatus = BluetoothStatus.unathorized\n            \n        case .unsupported:\n            // Alert user their device does not support Bluetooth and app will not work as expected\n            bluetoothStatus = BluetoothStatus.unsupported\n            \n        case .unknown:\n            // Wait for next state update\n            bluetoothStatus = BluetoothStatus.unknown\n            \n        @unknown default:\n            print(\"---Default case---\")\n        }\n    }\n```\n\n\n\n\"centralManagerDidUpdateState\" 메서드 내에서 중앙 매니저의 현재 상태에 따라 다양한 조치가 취해집니다:\n\n- .poweredOn: Bluetooth가 켜져 있으면 중앙 매니저가 블루투스 장치를 스캔하기 시작합니다\n- .poweredOff: Bluetooth가 꺼져 있으면, 이미 발견되거나 연결된 장치에 대한 모든 참조를 지우고 Bluetooth를 다시 켤 때 모두 다시 발견해야 합니다.\n\n각 상태마다 적절한 처리를 해야 하며, 이 경우에는 블루투스 상태를 현재 상태로 설정하고 이러한 경우를 처리한 것이 아니라는 점을 유의하십시오. 그러나 각 상태가 의미하는 바는 문서에서 찾을 수 있습니다.\n\n본 코드는 본질적으로 Bluetooth 상태 변화를 모니터하고 이에 적절하게 대응하여 애플리케이션이 이러한 변화에 적절하게 반응하도록 보장합니다.\"\n\n\n\n```swift\nfunc centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {\n    if !peripheralAlreadyRegistered(peripheral: peripheral){\n        discoveredPeripherals.append(peripheral)\n    }\n}\n\nfunc peripheralAlreadyRegistered(peripheral: CBPeripheral) -> Bool{\n    return discoveredPeripherals.contains(peripheral)\n}\n```\n\n이제 CentralManager가 감지하는 이벤트에 따라 자동으로 호출되는 일련의 메소드를 입력할 것입니다. 예를 들어, 이전에 블루투스가 켜져 있음을 감지했을 때 \"peripheral\"를 스캔하기 시작했고, 발견하자마자 첫 번째 함수 \"didDiscover\"에 들어갔습니다. 여기에는 발견된 페리페럴과 함께 수행할 작업이 포함되어 있습니다.\n\n이 경우에는 기본적으로 이미 발견되었는지 확인한 후, 아직 발견되지 않은 경우에만 발견된 페리페럴을 발견된 페리페럴 배열에 추가했습니다(뷰에 표시될 배열이며 사용자가 어떤 페리페럴에 연결할지 선택할 수 있도록 표시됩니다).\n\n\n\n```js\nfunc connect(peripheral: CBPeripheral) {\n    centralManager.connect(peripheral, options: nil)\n}\n\nfunc centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {\n    self.connectedPeripheral = peripheral\n    self.isConnected = true\n\n    peripheral.delegate = self\n    peripheral.discoverServices(nil)\n}\n```\n\n여기에는 뷰에서 선택된 페리페럴에 연결하는 데 책임이 있는 두 가지 함수가 있습니다. 발견된 장치 목록에서 페리페럴을 클릭하면 \"connect\" 함수를 호출하여 중앙 관리자에게 매개변수로 전달된 페리페럴과의 연결을 요청합니다.\n\n연결이 성공하면 Bluetooth 모듈의 LED가 깜박이는 것이 멈추고 켜져 있어야 합니다.\n\n연결이 성공하면 자동으로 CentralManager 함수 \"didConnect\"로 들어가며, 이 경우에:\n\n\n\n\n- 연결된 장치에 대한 참조(connectedPeripheral)를 저장합니다.\n- 연결된 주변 장치의 \"대리자(delegate)\"로서 객체 자체의 정의. 이를 통해 객체는 주변 장치에서 발생하는 이벤트에 대한 알림을 받을 수 있습니다.\n- 연결된 주변 장치로부터 서비스(블루투스 장치가 제공하는 \"기능\"들에 대해 계속 논의됩니다)를 검색을 시작합니다.\n\n```js\nfunc centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {\n    // 오류 처리\n    print(\"주의: 연결 실패\")\n}\n```\n\n다른 함수가 이것을 호출할 수 있는데, 해당 주변 장치에 연결을 시도할 때 연결에 실패했을 때입니다. 이 경우 콘솔에 연결이 실패했다는 메시지를 출력했지만, 이 시나리오를 처리해야 합니다.\n\n```js\nfunc disconnect() {\n    guard let peripheral = connectedPeripheral else {\n        return\n    }\n    centralManager.cancelPeripheralConnection(peripheral)\n}\n\nfunc centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {\n    self.connectedPeripheral = nil\n    self.discoveredPeripherals = []\n    self.isConnected = false\n    self.valueReceived = nil\n        \n    centralManager.scanForPeripherals(withServices: nil, options: nil)\n}\n```\n\n\n\n이제 영구적으로 주변 장치와 연결되어 있지 않도록 연결을 해제하는 기능이 있습니다. 이 기능은 우리가 무엇에 연결돼 있는지 확인한 후, CentralManager에 연결을 취소하도록 요청합니다.\n\n이 연결을 취소하면, 이전에 연결돼 있던 것이 더 이상 연결되지 않았으므로 발견된 장치와 연결된 모든 참조를 지우기로 결정했습니다. 게다가, 주변 기기를 연결하고 30m를 걸어가서 이미 발견한 다른 기기를 잃는 경우도 있을 수 있으므로, 그들의 참조를 삭제하여 더 이상 존재하지 않는 것에 연결하려고 하지 않도록 합니다.\n\n그 후, 다시 주변에 있는 주변 기기를 찾기 시작합니다.\n\n# 서비스\n\n\n\n기본적으로, 서비스는 주변 장치에서 제공되는 기능을 나타내는 특성의 모음입니다. 각 서비스는 하나 이상의 특성을 포함할 수 있으며, 이러한 특성은 주변 장치에서 제공되는 특정 정보를 나타냅니다.\n\n예를 들어, Bluetooth 주변 장치는 \"온도 센서\" 서비스를 가질 수 있으며, 이 서비스에는 센서가 측정한 현재 온도를 제공하는 특성이 포함될 수 있습니다. 또한 \"LED 제어\" 서비스를 가질 수 있으며, 이 서비스에는 LED를 켜거나 끄고 색상을 설정하는 특성이 포함될 수 있습니다.\n\n```js\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {\n        guard peripheral.services != nil else {\n            return\n        }\n        discoverCharacteristics(peripheral: peripheral)\n}\n```\n\n장치와의 연결이 끊기거나 연결이 실패할 가능성을 다룬 후, 이전에 서비스를 찾는 함수를 호출한 지점으로 돌아가서, 발견된 서비스가 있을 때 이 함수에 들어가는데, 이것은 이제 CBPeriperalDelegate의 메서드이고 더 이상 CentralManager의 메서드가 아니기 때문에 제 주변 장치에서 발생하는 이벤트는 CBPeripeheralDelegate의 메서드를 통해 처리해야 합니다.\n\n\n\n우리가 서비스 검색 시 호출되는 함수는 기본적으로 해당 장치에 서비스가 있는지 확인하고, 서비스가 있는 경우 해당 서비스의 특성을 찾도록 요청합니다.\n\n```js\nfunc discoverCharacteristics(peripheral: CBPeripheral) {\n    guard let services = peripheral.services else {\n        return\n    }\n    \n    for service in services {\n        peripheral.discoverCharacteristics(nil, for: service)\n    }\n}\n\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {\n    guard let characteristics = service.characteristics else {\n        return\n    }\n    \n    for characteristic in characteristics {\n        if characteristic.uuid == CBUUID(string: \"FFE1\") {\n            if characteristic.properties.contains(.notify) {\n                peripheral.setNotifyValue(true, for: characteristic)\n            }\n            \n            self.connectedPeripheral?.readValue(for: characteristic)\n            break\n        }\n    }\n}\n```\n\n첫 번째 함수는 간단히 발견된 모든 서비스에 있는 특성을 검색하도록 요청합니다. 이러한 특성을 찾으면, CBPeripheralDelegate 대리자가 이 이벤트를 식별하고 \"didDiscoverCharacteristics\" 메서드를 호출합니다.\n\n이 메서드에서는 특성 목록이 null이 아닌지 확인하고, 그 후에 찾은 모든 특성을 특성 식별자가 \"FFE1\"인 특성을 찾아냅니다. 이는 우리가 원하는 값을 제공하는 특성이며 값이 변경될 때 경고해주는 notify 속성을 가지고 있습니다.\n\n\n\n그 후에 이 속성에 포함된 값이 무엇인지를 읽습니다.\n\n# 주의\n\nHC-08 모듈을 사용하는 이 프로젝트의 경우, 찾고 있는 ID는 \"FFE1\"입니다. 그러나 다른 모듈을 사용 중이라면 ID가 다를 수도 있습니다.\n\n찾아야 할 기능이 무엇인지 알아보려면 모듈 또는 아두이노의 데이터 시트를 읽는 것을 추천합니다. 또한 \"LightBlue\"라는 앱을 사용하여 장치에 연결하고 장치가 제공하는 서비스에 대한 정보를 포함하여 장치에 대한 몇 가지 정보를 제공할 수 있습니다.\n\n\n\nHC-08 모듈을 사용하는 분들을 위해 gitHub에 데이터 시트를 올려두었어요.\n\n![Bluetooth connection between Arduino and iOS](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_2.png)\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {\n        if let value = characteristic.value {\n            if let stringValue = String(data: value, encoding: .utf8) {\n                valueReceived = stringValue\n            }\n        }\n    }\n```\n\n마지막으로 값을 읽기 위해 요청한 후, 값이 변경되면 \"didUpdateValueFor\" 메서드에 들어가게 되는데, 이 메서드는 받은 값을 문자열로 변환하는 역할을 담당합니다 (이 프로젝트의 목적은 아두이노에서 보내는 두 문자열을 표시하는 것이기 때문이죠).\n\n\n\n그러나 당신의 프로젝트에서는 받고 싶은 데이터 유형으로 변환할 수 있고, 심지어 데이터를 받기 전에 값이 업데이트되길 기다리지 않고도 이 변환을 수행할 수 있습니다. 하지만 이 경우에는 매 두 초마다 문자열을 변경하는 것이 목표였습니다.\n\n# 결론\n\n우리는 다음을 구축했습니다.\n\n- 블루투스 장치와 통신하고 데이터를 수신할 수 있는 클래스;\n- 아두이노에서 블루투스 모듈을 사용하는 방법을 배웠습니다;\n- 아두이노와 iOS가 블루투스를 통해 통신할 수 있도록 만들었습니다.\n\n\n\n저희의 다음 단계로, BluetoothController에서 제공하는 정보에 액세스하여 원하는 뷰에서 사용해야 합니다.\n\n소스 코드는 제 GitHub에서 확인해주세요.\n도움이 되었기를 바랍니다!🫡","ogImage":{"url":"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png"},"coverImage":"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png","tag":["Tech"],"readingTime":14},{"title":"2D 스캐닝 방법 개요","description":"","date":"2024-05-15 04:23","slug":"2024-05-15-AnOverviewofKey2DScanningMethods","content":"\n\n<img src=\"/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_0.png\" />\n\n3D 스캔은 실제 세계의 물체나 환경을 분석하여 모양, 색상 및 잠재적으로 외관이나 다른 표면 특성에 대한 데이터를 수집하는 과정입니다. 수집된 데이터는 이후 제조, 품질 관리 및 문화 유산 보존과 같은 다양한 응용 분야에서 사용하기 위해 디지털 3D 모델을 구축하는 데 사용될 수 있습니다.\n\n오늘날 많은 기술이 있으며, 이러한 기술은 물리적 물체를 정확하게 2차원으로 스캔하는 데 다른 원리를 이용합니다. 이 문서는 다섯 가지 주요 방법을 비교하여 M - 각 방법이 기본적으로 어떻게 작동하는지 설명하고 상대적인 장단점을 강조합니다.\n\n목차\n\n\n\n- 레이저 삼각측량\n- 사진측량\n- 구조빛\n- 레이저 펄스 거리측정\n- 접촉 수치화\n- 스캔 방법의 트레이드오프 정리:\n- 결론\n\n# 레이저 삼각측량\n\n![이미지](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_1.png)\n\n레이저 삼각측량 스캐너는 오늘날 매우 흔한 유형의 2D 스캐닝 하드웨어입니다. 이름에서 알 수 있듯이, 이 스캐너는 삼각측량을 통해 표면을 분석하기 위해 레이저 빔을 활용합니다.\n\n\n\n개발자이시군요. 위의 텍스트를 친근한 톤으로 한국어로 번역해 드리겠습니다.\n\n물체를 스캔할 때 단일 레이저 점 또는 선이 물체에 투사됩니다. 이 레이저 광선은 표면에서 반사되어 센서에 의해 이미지화됩니다. 반사된 광선의 각도는 원래 방향과의 상대적인 각도를 인코딩하여 표면을 매핑하는 데 사용할 수 있는 거리 정보를 부호화합니다. 이 프로세스는 2D 스캔을 구축하기 위해 물체 전체에 걸쳐 반복됩니다.\n\n장점:\n- 복잡한 물체 세부 정보를 캡처하는 데 매우 높은 해상도와 스캔 정확도\n- 빠른 스캔 속도\n\n제한 사항:\n\n\n\n- 다양한 표면 특성에 민감함 - 투명 또는 광택 마무리는 문제가 될 수 있음\n- 한 줄의 레이저만 있어서 스캔 시간이 길어짐\n\n전체적으로 레이저 삼각측량은 구현이 쉬우면서도 정밀도가 높습니다. 이는 제조된 부품을 CAD 모델과 비교하는 품질 보증 작업과 같은 작업에 이상적으로 적합합니다.\n\n# 사진측량\n\n![image](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_2.png)\n\n\n\n포토그램메트리는 2D 사진으로부터 측정을 하는 과학이에요. 특히 표면 점들의 정확한 위치를 재구성하기 위해 사용돼. 이 원칙은 서로 다른 각도에서 주제물을 촬영한 사진들의 시리즈로부터 완전한 2D 모델을 만들 수 있는 포토그램메트리 스캐닝 시스템에 의해 활용돼.\n\n전문 알고리즘이 여러 사진에서 공통 점을 분석해. 초점 거리와 같은 카메라 파라미터 정보를 이용하여 수십만 개의 표면 점이 물리적으로 접촉하지 않고도 높은 정확도로 표시될 수 있어.\n\n장점:\n\n- 완전 비접촉 프로세스로 소박하거나 원격으로 스캔 가능\n- 복잡한 기하학을 가진 물체에 대해 다른 기술들보다 우수한 성과를 보여줘.\n\n\n\n제약 사항:\n\n- 0.1mm보다 더 높은 정밀도 달성이 어려움\n- 계산 집약적인 분석은 스캔 소프트웨어/하드웨어에 높은 수요를 야기함\n\n사진측량은 삼각측량 스캔의 정확도에는 미치지 못하지만, 컴퓨터 비전과 계산 파워의 지속적인 향상으로 이러한 제약을 덜 제한적으로 만들고 있습니다.\n\n# 구조물 조명\n\n\n\n\n![Image](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_3.png)\n\nThe structured light scanning approach is similar to laser triangulation, but substitutes the single laser with a structured pattern of light projected onto objects. This pattern might be bars, grids, or other shapes that establish a frame of reference.\n\nThe way that these shapes deform when striking surfaces encodes detailed information about the surface itself. This allows for reconstructing the surface geometry in fine detail. Common light patterning techniques include digital light processing (DLP) projectors or laser speckle projectors if coherent laser light is preferred.\n\nBenefits:\n\n\n\n\n- 빠른 비접촉 스캔 방법\n- 로봇 레이저 스팟과 다르게 표면 색상/질감도 포착함\n\n한계:\n\n- 주변 조명 조건에 민감함\n- 그림자 효과가 데이터 수집에 방해할 수 있음\n\n구조광 시스템의 속도와 다용도성은 인라인 산업 스캔 응용에 적합합니다. 또한 마이크로소프트 키넥트와 같은 소비자 기기를 통해 대중에 널리 보급되고 있습니다.\n\n\n\n# 레이저 펄스 거리 측정\n\n![image](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_4.png)\n\n레이저 펄스 거리 측정은 레이저 펄스의 시간을 측정하는 방식으로 작동합니다. 핵심 원리는 레이저 빛이 방출된 후 반사된 빛을 감지하는 사이의 시간 지연을 측정하는 것입니다. 빛의 속도가 알려진 상수이기 때문에 이 시간 간격을 계산하면 이동한 거리를 예측할 수 있습니다.\n\n스캐너는 초점을 맞춘 레이저 펄스의 회전을 대상물에 걸쳐 휘게 하여, 정밀한 시간-비행 거리 측정값을 수백만 개 만들어냅니다. 이 데이터는 주제 표면의 상세한 3D 지도로 변환됩니다.\n\n\n\n혜택:\n\n- 약 0.3mm 정밀도까지 극도의 높은 정확성\n- 수백 미터 범위에 이르는 큰 스캔 거리\n\n제한 사항:\n\n- 레이저 에너지를 너무 많이 흡수하는 어두운 물체에 대한 어려움\n-비용 증가와 빠른 처리가 필요합니다.\n\n\n\n레이저 펄스 거리 측정의 뛰어난 정확성과 범위는 건물 현장을 측량하여 항공 스캔에서 디지턤 지형지도를 만드는 등 다양한 대규모 스캔 요구에 적합합니다.\n\n# 연락처 디지타이징\n\n![이미지](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_5.png)\n\n이름 그대로 연락처 디지타이징은 계측 장치와 대상 표면 간의 물리적 접촉을 기반으로 하는 방식으로서 치수 데이터를 수집합니다. 이는 터치 프로브, 계측 팔, 또는 표면에 XYZ 좌표를 플로팅할 수 있는 다른 장치를 활용할 수 있습니다.\n\n\n\n컨택 디지타이저는 손으로 윤곽을 따를 때, 밀리미터의 작은 부분까지 정밀하게 측정할 수 있습니다. 연속 스캔 과정을 통해 광택이나 투명한 재질과 같이 이미지 촬영이 어려운 표면도 정확히 잡을 수 있습니다.\n\n장점:\n\n- 약 0.05mm까지의 정밀도로 골드 스탠다드 제공\n- 투명/반사/볼록한 표면에 효과적\n\n제한사항:\n\n\n\n- 수작업 시간이 많이 소모됩니다.\n- 표면 접근이 필요하기 때문에 대상 크기/기하학이 제한됩니다.\n\n치과 임플란트나 조각물 복제와 같은 특수 응용에 적합한 맞춤형 접촉 디지타이징 방식은 서브밀리미터 수준의 완벽함이 중요합니다.\n\n# 스캔 방법의 대안들을 요약하면:\n\n![image](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_6.png)\n\n\n\n위의 비교를 통해 특정 스캐닝 기술이 다른 경우에 비해 어떻게 높은 성능을 발휘하는지 알 수 있어요 — 각 접근 방식에 내재된 장단점을 잘 활용하고 있거든.\n\n# 요약\n\n이것은 우리의 능력을 확장시키는 2D 스캐닝을 통해 물리적 객체와 장면을 디지털화하는 다양하고 널리 사용되는 5가지 방법에 대한 짧은 소개였어요. 레이저 거리측정, 카메라 이미지, 투사된 빛 패턴 등을 활용한 방법을 통해 과학자들은 전문적인 용도에 사용되는 고상세 연락처 디지털화와 다재다능한 비접촉 스캐닝을 만들어 냈어요.\n\n자동 스캐닝은 수동 측정보다 수백 배 빠를 뿐만 아니라 더 뛰어난 정확도를 제공하기도 해요. 이를 통해 품질 보증, 아카이빙, 제품 설계에 대한 효율성이 증대되며, 레이저 삼각측량과 사진측량과 같은 현재의 기술을 향상시키는 노력이 계속되고 있어요. 실제로, 정밀도, 작업 공간 크기, 획득 속도의 한계를 넘어서 물리적 세계를 디지털 세계로 끌어오는 최첨단 기술이 형성되고 있어요.\n\n\n\n산업, 유산, 또는 창의적 목적으로 2D 스캔 어플리케이션을 사용해본 경험이 있나요? 의견란에서 여러분의 직접적인 시각을 공유해주세요!\n\n이 게시물은 원문이 3dprintjunction.com에 게시되었습니다.\n저희의 작업을 지원해주신 모든 분들께 감사드리며, 더 많은 유사한 기사들을 확인하시려면 3dprintjunction.com을 방문해주시기를 부탁드립니다.","ogImage":{"url":"/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_0.png"},"coverImage":"/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_0.png","tag":["Tech"],"readingTime":5},{"title":"내 멍청한 주전자를 축하하며","description":"","date":"2024-05-15 04:18","slug":"2024-05-15-InCelebrationofMyDumbKettle","content":"\n\n![image](/assets/img/2024-05-15-InCelebrationofMyDumbKettle_0.png)\n\n작년에 유투브 동영상으로 사람들에게 주방 가전제품을 재설정하는 방법을 보여줌으로써 5,000달러 이상을 벌었어요.\n\n이건 자랑하는 게 아니에요 - 이건 실제로 심각한 문제의 증거에요. 예전에는 간단한 장치조차 방대한 수의 모드, 메뉴 및 \"스마트\" 기능을 갖춘 심각한 복잡성을 보이게 되었어요.\n\n이러한 장치들은 고장이 잘 발생하는 센서, 칩 및 기계 학습 기능으로 가득하고 있어요. 생성 AI의 출현과 함께 상황이 훨씬 더 나빠지고 더 위험해질 거에요.\n\n\n\n## 토스터 전원 사이클링\n\n요즘, 베이글을 구우려고 했는데 제 꽤 멋진 Cuisinart 스마트 토스터의 화면이 멈춰 있는 걸 발견했어요.\n\n플러그를 그냥 뽑아 꽂으면 리부팅되지 않고 같은 화면이 그대로 남아 있는 걸 깨닫고 몇 분을 고민했어요.\n\n결국 올바른 절차를 기억해냈는데, 그것은 특정한 시간동안 조절기를 누르고 토스터의 펌웨어가 다시 부팅되기를 기다린 후 홈 메뉴로 돌아가야 했어요. 이 과정을 거쳐, 조금 좌절스러운 기분으로 아침을 준비할 수 있었답니다.\n\n\n\n토스터를 다시 시작하는 아이디어는 1990년대의 재미있는 농담처럼 느껴질 수 있어요. 하지만 컴퓨터 칩의 비용이 하락하면서 디자이너들이 사용할 수 있는 센서의 종류가 증가하고, 무선 연결성이 저렴해져서 심지어 간단한 기기에도 내장하기 쉬워져서, 이른바 \"스마트\" 가전제품이 급부상했어요.\n\nStatista에 따르면, 2024년에 스마트 가전제품은 112억 달러 규모의 산업이 될 것으로 예상돼요. 2028년까지 4500만 명 이상의 미국인이 스마트 가전제품을 일상생활에서 사용할 것으로 예상돼요.\n\n스마트 기술은 이미 우리 주변에 있어요, 찾아보면요. 제 아마존 스마트 전자레인지는 인터넷에 연결되어 제 목소리에 반응해요. 저의 Aeris 주방 공기 청정기는 자동으로 레인지에서 무언가를 태운 것을 감지하면 자동으로 파워를 높여 공기를 청소해요.\n\n제 Nest 온도 조절기는 제가 집에 있는지 알고, 내 선호도에 맞추어 열을 조절해요 (그리고 저가 밖에 있을 때는 제 개인 선호도보다는 우선적으로 제 개를 Lance의 선호도를 고려해요).\n\n\n\n## 똑똑한 세탁기\n\n그것은 출발에 불과합니다. 오늘의 스마트 가전제품들은 종종 제조사들이 \"AI\"로 마케팅하는 내장된 기계 학습 알고리즘을 통합합니다. 이러한 알고리즘들은 그들이 그들이 그 밖에 일상적인 일에 사고와 분석의 모습을 더합니다.\n\n예를 들어 내 LG 세탁기는 센서를 사용하여 내가 넣은 천의 정확한 종류를 감지하고 이에 따라 세탁 시간과 온도를 조절합니다. 그런 다음 이 정보를 동료인 내 LG ThinQ 건조기에 전달합니다. 세탁물을 말릴 때 건조기는 이미 어떤 내용물을 포함할지 인식하고 바지를 녹이지 않기 위해 열을 조절할 수 있습니다.\n\n많은 신제품들이 이를 더 나아가는 방향으로 발전하고 있습니다. 삼성의 Family Hub 냉장고는 내부 카메라와 AI를 사용하여 넣은 식품을 감지합니다. 그런 다음 당신이 가지고 있는 것을 기반으로 저녁 식사 레시피를 제안합니다.\n\n\n\nLG에서 가져온 AI 기반 오븐을 최근에 테스트해봤는데, 이 오븐은 기계 학습을 이용하여 닭 요리가 피부가 바삭바삭해질 때 알려줘요. 핸드폰에 알림이 오면 요리를 꺼내서 먹을 준비를 할 수 있어요.\n\n## Edge를 향해 달린다\n\n이런 기능들은 정말 멋진 재주 중 하나에요. 그러나 대부분의 경우, 오늘날 \"AI 기반\"으로 마케팅되는 스마트 기능들은 간단한, 초기 세대의 기계 학습 알고리즘을 사용해 그럴듯하게 작동하는 것 뿐이예요.\n\n예를 들어, 제 스마트 세탁기는 옷의 반사율을 결정하기 위해 적외선 센서를 사용하고 (그리고 이것으로 옷의 재질에 대한 대략적인 개념을 얻을 수 있을 거에요), 드럼에 장착된 중량 센서를 사용하여 넣은 옷의 상대적 중량을 계산할 수 있어요.\n\n\n\n그런 다음, 간단한 룩업 기능을 수행하여 내 부하의 매개변수를 11,000개의 미리 저장된 프로필과 비교합니다. 그 라이브러리에서 가장 유사한 항목을 찾으면 해당 매치의 미리 저장된 설정을 가져와 해당 설정으로 세탁주기를 실행합니다.\n\n이것은 도움이 되고 인상적입니다, 맞아요. 그러나 세탁기는 실제로 AI를 사용하지는 않습니다. 대신, 주로 똑똑한 센서와 매우 기본적인 알고리즘, 즉 간단한 패턴 매칭을 사용하여 더 깊이있는 지능을 모방합니다.\n\n그러나 생성 AI가 발전함에 따라 가전제품들은 정말로 스마트하고 빠르게 발전할 것입니다.\n\n2023년 말에, 구글은 새로운 Gemini 대형 언어 모델 (LLM)을 발표하였는데, 이는 OpenAI의 보편적인 GPT 모델의 경쟁 상품입니다. Gemini Ultra가 모든 주목을 받았지만, 구글은 그들의 생성 AI 기술의 혁신적인 버전 중 하나인 Gemini Nano도 발표했습니다.\n\n\n\n나노는 완전한 LLM이지만 모바일 기기에서 실행되도록 최적화되어 있어요. 현재 LLM은 너무 복잡하고 계산 비용이 많이 들어서 거대한 서버 뱅크나 원격 데이터 센서에 제한되어 있는 경우가 많아요. 그런 제한 때문에 그들의 영향력이 제한적이에요.\n\n하지만 Gemini 나노와 같은 효율적인 모델은 LLM이 더 간단한 하드웨어에서도 실행될 수 있게 해줘요. 컴퓨터 공학에서 이를 \"에지\"로 이동시켜 사용자들의 기기에서 로컬로 실행되게 해줘요. 그것은 거대한 서버 팜 대신 사용자의 소중한 기기에서 실행될 수 있게 해준답니다.\n\n현재 Gemini 나노는 아직 상당히 강력한 스마트폰이 필요해요. 하지만 LLM이 더 효율적으로 변화함에 따라 에지로의 이동이 가속화될 것이며, 점차 더 저렴하고 간단한 하드웨어에서 실행될 수 있을 거에요. 궁극적으로 이러한 모델들은 스마트 가전제품을 구동하는 단순한 칩에서도 실행될 수 있는 지점에 이를 것이랍니다. \n\n그 일이 일어나면, 당신의 토스터, 믹서기, 오븐이 단순한 기계 학습 트릭뿐만 아니라 오늘날의 고급 챗봇처럼 수행하는 작업을 분석, 이해하고 의사소통할 수 있게 될 거에요.\n\n\n\n간단히 말해서, 당신의 토스터가 생각할 수 있게 될 것입니다.\n\n## 당신의 스마트 주방에 도사리는 위험\n\n내 YouTube 채널에 좋은 소식입니다 — 더 많은 복잡성은 더 많은 문제가 발생할 가능성을 의미하며, 따라서 똑똑한 토스터 문제 해결 동영상이 더 필요해집니다!\n\n하지만 소비자들에게는 반드시 좋은 일이라고 할 수는 없습니다. AI 기반 가전제품은 정상적으로 작동할 때 훌륭합니다. 그러나 고장이 날 경우, 이러한 시스템의 추가 복잡성으로 인해 고장 해결이 어려워지거나 불가능해질 수 있습니다.\n\n\n\n1985년식 스바루와 2023년식 테슬라를 비교해보면 차이가 있습니다. 취미로 만져봐도 전자를 집에서 수리하고 재설정할 수 있을 겁니다. 그러나 후자는 전문 장비와 절차가 필요하며 일반적인 전문 메커닉조차 그 능력을 능가하는 것이 필요할 수도 있습니다. 복잡성은 성능을 증가시키지만, 우리의 기기를 유지하는 것을 더 어렵고 비싸지게 만듭니다.\n\n때로는 발전적 AI 기술이 탑재된 가전제품으로 전환이 그저 불편할 뿐만 아니라 위험할 수도 있을 것입니다.\n\n오늘날의 발전적 AI 모델은 블랙박스입니다. 심지어 그 창조자조차도 그들이 어떻게 작동하는지 드물게 이해합니다. 훈련방식으로 인해 LLM과 같은 발전적 AI 시스템은 종종 그들을 만드는 사람들의 편견을 내재하려고 하며 반영하기도 합니다.\n\n이미 증거가 보여주듯이, 예를 들어 자율주행 자동차는 짙은 피부색을 가진 보행자를 감지하기 어려운 경우가 많아 사고의 위험에 두게 할 수 있습니다.\n\n\n\n편향된 토스터라면 크게 피해를 줄 수도 없겠지만, 모든 내포된 편견을 지닌 LLMs가 스마트 가전제품인 홈 보안 카메라나 알람 시스템에 들어가 있다면 상상해보세요.\n\n어두운 피부색의 사람들을 감지하면 우선적으로 알림을 보내는 스마트 홈 카메라는 실제 피해를 야기하고 많은 커뮤니티에 위험을 초래할 수 있습니다.\n\n더 기본적인 수준에서 제너레이티브 AI 모델의 예측 불가능성이 위험을 초래합니다.\n\n만약 내 연기 감지기가 연기를 감지하면, 즉시 경보음을 울리기를 원합니다. \"음, 연기를 감지했어요. 하지만 톰의 달력을 보니 내일 아침 큰 프레젠테이션이 있고 잠이 필요한 것 같아요. 그를 깨우지 않는 편이 좋겠네요!\"와 같은 일은 원치 않습니다.\n\n\n\n생각하는 기계에는 자리가 있습니다. 그러나 때로는 내부 \"뇌\"가 무엇을 말하든 항상 동일한 절차를 따르는 결정론적인 코드가 필요할 때가 있습니다.\n\n## 나의 어리석은 주전자\n\n다행히도 이러한 생성적 AI 기능 둔화에 대항할 수 있는 쉬운 방법이 있습니다: 선택하지 않습니다.\n\n최근에 차를 끓이기 위해 전기 주전자를 사기로 결심했습니다. 내가 선택한 모델은 매우 간단합니다. 물을 채우고 작은 레버를 눌러 켜는 방식입니다. 물이 끓으면 레버가 만족스러운 찰칵 소리를 내면서 다시 올라가며 주전자가 꺼집니다.\n\n\n\n내 주전자는 명백하게 변명 없이 어리석습니다. 스마트 기능도 없고, 내장 AI 알고리즘도 없으며 복잡한 내장 센서도 없습니다.\n\n이게 내가 가장 좋아하는 가전제품 중 하나가 된 것 같아.\n\n\"분명히 주전자처럼 간단한 물끓이는 도구에 스마트 기능을 추가한 사람은 없을 텐데!\" 하고 이의를 제기하시기 전에 말씀드립니다. 실제로 그들이 했습니다. 최근에 Cuisinart PerfecTemp 스마트 주전자를 리뷰했는데, 이 주전자에는 아홉 개의 버튼, 여섯 개의 열 설정, LED 표시등, 심지어 내장 메모리까지 모두 녹아들어 있어 간단한 작업인 물 끓이기를 수행합니다.\n\n이 주전자는 구매하지 않았어요. 정확한 물의 온도에 대한 집요한 통제를 원하는 사람이나 무의미한 파란색 LED를 좋아하는 사람들에게 훌륭하게 작동할 것 같아요.\n\n\n\n하지만 저에게 있어서, 내 어리석은 주전자의 간단함과 사용 편의성이 가장 매력적인 특징입니다. 켜기만 하면 잠시 후 끓는 물이 나와요. 메뉴를 좀 만지거나 결정을 내릴 필요가 없어요. 전원을 다시 켜거나 재부팅할 필요가 없을 거예요.\n\n## 어리석은 것을 선택하세요\n\n더 많은 가전제품이 이렇게 간단하고 튼튼하며 어리석었으면 좋겠어요.\n\n오해하지 마세요. 제가 루딧(Luddite)은 아니에요(존 더튼도 아니에요!). 절 가짜 AI 어플라이언스 세탁기와 건조기를 사랑하고 있어요. 많은 양의 세탁물을 던져 넣고 완벽하게 세탁되고 줄어들거나 변색되지 않을 것이라는 점을 알 수 있다는 것은 기쁜 일이에요. 제 목소리로 조작하는 전자레인지는 시각 장애가 있는 가족 구성원들에게 큰 도움이 되었어요.\n\n\n\n하지만 모든 가전제품이 스마트 기능을 활용할 수 있는 것은 아닙니다. 그리고 대부분의 장치는 분명히 곧 다가올 내장 생성형 AI의 급습에서 혜택을 받지 못할 것입니다.\n\nLLM을 기반으로 한 장치들의 쇄도가 찾아오면, 소비자로서 한 발 물러서서 잠시 저항해 보라고 말씀드리고 싶습니다.\n\n서로 경쟁하여 가능한 한 혁신적으로 보이려 하고 (비싼 애드온으로 이익을 올리기 위해), 브랜드들은 곧 AI를 절대적으로 모든 것에 내장시킬 것이며, 이 AI 기능들이 여러분의 삶을 더 쉽거나 나은 것으로 만든다고 설득하려 할 것입니다.\n\n대부분의 경우, 실제로 그렇지 않을 것입니다.\n\n\n\n생성형 인공지능은 자리를 차지하고 있습니다. 하지만 LLM 기술로 작동하는 블렌더를 구매하기 전에, 삶에 도입하게 되는 복잡성과 잠재적 위험에 대해 신중히 생각해보세요.\n\n생명을 지켜주는 가전제품의 경우, 알지 못했던 편견을 어떤 것을 지속하게 하고 있는지, 그리고 도입하고 있는 어떤 위험은 무엇인지 생각해보세요. 여러분의 스마트 가전제품 뒤에 있는 회사가 개인정보를 보호하고 수집하는 데이터를 안전하게 보호하기 위한 조치를 취하고 있는지 확인해보세요. 여러분의 복잡한 새로운 스마트 가제품이 한 달 안에 고장날 가능성이 있을까요?\n\n요약하자면, 생성형 인공지능 스마트 기능의 급격한 발전에 직면할 때 스스로에게 묻는 것이 중요합니다: 이 새로운 스마트 기기의 내장된 지능이 정말 가치가 있는가요? 아니면 내 주전자만큼 간단하고 신뢰할 수 있는 장치가 더 좋을까요?\n\n작년 동안 수천 개의 ChatGPT 프롬프트를 테스트해보았습니다. 전문 창작자로서, 매일 돌아오는 것 중에는 소수의 것들이 있습니다. 이를 모아 무료 가이드 '창작자를 위한 매우 유용한 ChatGPT 프롬프트 7가지'로 편집했습니다. 지금 바로 다운로드하세요!","ogImage":{"url":"/assets/img/2024-05-15-InCelebrationofMyDumbKettle_0.png"},"coverImage":"/assets/img/2024-05-15-InCelebrationofMyDumbKettle_0.png","tag":["Tech"],"readingTime":7},{"title":"사물인터넷IoT의 미래 성장에 인공 지능이 미칠 영향은 무엇일까요","description":"","date":"2024-05-15 04:15","slug":"2024-05-15-iotWhatimpactwillartificialintelligencehaveonthefuturegrowthoftheInternetofThings","content":"\n\n인공 지능 (AI)은 인터넷 오브 씽스 (IoT)의 미래 성장에 상당한 영향을 미칠 것으로 예측되며 다음과 같은 몇 가지 방식으로 영향을 줄 것으로 예상됩니다:\n\n- 향상된 데이터 분석: AI 알고리즘은 실시간으로 생성된 대량의 데이터를 분석하여 인간만으로는 식별하기 어려운 유용한 통찰과 패턴을 도출할 수 있습니다. 이 능력을 통해 조직은 더 많은 정보에 기초한 결정을 내릴 수 있고 다양한 산업에서 운영을 최적화하고 효율성을 향상시킬 수 있습니다.\n- 예측 유지보수: AI 기반 분석은 IoT 센서 데이터를 기반으로 장비 고장 및 유지보수 요구를 예측할 수 있어 조직이 선행 유지보수 전략을 구현할 수 있게 합니다. 진행되기 전에 문제를 감지함으로써 예측 유지보수는 다운타임을 최소화하고 비용을 줄이며 자산 수명을 연장하는 데 도움이 됩니다.\n- 맞춤형 사용자 경험: AI는 스마트 홈, 웨어러블 기술, 연결된 차량과 같은 분야에서 사용자 경험을 맞춤화하는 데 IoT 장치로부터의 데이터를 활용할 수 있습니다. 사용자 선호도와 행동 패턴을 이해하며 AI는 권장 사항을 맞춤화하고 작업을 자동화하며 사용자 요구를 예측함으로써 전반적인 만족도와 참여도를 향상시킬 수 있습니다.\n- 자율 시스템: AI를 IoT와 통합하여 인간 개입 없이 결정을 내리고 조치를 취할 수 있는 자율 시스템을 개발할 수 있습니다. 예를 들어, 자율 차량은 AI 알고리즘을 활용하여 센서 데이터를 해석하고 주변 환경을 탐색하며 변화하는 조건에 대응함으로써 더 안전하고 효율적인 교통을 이끌어 냅니다.\n- 향상된 에너지 효율성: AI 기반 최적화 알고리즘은 IoT 활성화 스마트그리드, 건물 및 산업 시설에서 에너지 사용량을 최적화할 수 있습니다. 센서 및 액추에이터에서 데이터를 분석함으로써 AI는 에너지 소비를 동적으로 조절하고 낭비를 줄이며 자원 할당을 최적화하여 에너지 효율성과 비용 절감을 이끌어 냅니다.\n- 보안 및 이상 탐지: AI 기반 사이버 보안 솔루션은 전통적인 규칙 기반 접근법보다 IoT 네트워크에서의 보안 위협 및 이상을보다 효과적으로 감지하고 대응할 수 있습니다. 네트워크 트래픽 패턴 및 장치 행동을 분석함으로써 AI 알고리즘은 의심스러운 활동을 식별하고 위험을 최소화하며 사이버 공격으로부터 IoT 생태계를 보호할 수 있습니다.\n- 엣지 컴퓨팅: IoT 장치에 더 가까운 네트워크 엣지에 배포된 AI 알고리즘은 데이터를 실시간으로 처리하여 대기 시간과 대역폭 요구 사항을 줄입니다. 엣지 AI는 더 빠른 의사 결정을 가능하게 하고 오프라인 운영을 지원하며 데이터 전송을 최소화하여 개인 정보 보호를 강화합니다.","ogImage":{"url":"/assets/img/2024-05-15-iotWhatimpactwillartificialintelligencehaveonthefuturegrowthoftheInternetofThings_0.png"},"coverImage":"/assets/img/2024-05-15-iotWhatimpactwillartificialintelligencehaveonthefuturegrowthoftheInternetofThings_0.png","tag":["Tech"],"readingTime":2},{"title":"글 제목 오픈AI GPT-4o를 사용하여 데이터베이스를 쿼리하는 방법","description":"","date":"2024-05-15 04:12","slug":"2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase","content":"\n\n오늘 OpenAI가 최신 LLM 모델인 GPT-4o를 발표했어요. 사람들이 이 혁신적인 모델을 기반으로 만든 놀라운 응용 프로그램을 공유하고 있어요. GPT-4o를 사용하면 데이터 검색에 개선 사항이 있어, 사용자들이 더 빠른 응답과 더 효율적인 비용 효과(비용이 GPT-4 Turbo보다 적음)을 누릴 수 있어요.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_0.png)\n\n12시간 내에 WrenAI 팀이 최신 버전을 출시했어요. GPT-4o LLM 모델을 지원하여 본인의 데이터베이스를 쿼리하는 데 도움을 줄 거예요. 이 글에서는 gpt-4o를 사용하여 PostgreSQL 데이터베이스를 쿼리하는 방법을 안내할 거에요!\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_1.png)\n\n\n\n시작해 봅시다!\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_2.png)\n\n# PostgreSQL 데이터베이스 설정\n\nPostgreSQL 서버를 시작하고, psql 클라이언트를 사용하여 PostgreSQL 데이터베이스에 접속하세요.\n\n\n\n<img src=\"/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_3.png\" />\n\n여기서 PostgreSQL에서 데이터베이스를 생성하십시오. 데이터베이스 이름은 ecom-wrenai로 지정했습니다.\n\n```js\nCREATE DATABASE ecom_wrenai;\n```\n\n생성된 데이터베이스 ecom-wrenai에 연결하려면 `\\c database_name`을 사용하십시오.\n\n\n\n\n```js\nlijungchi=# \\c ecom_wrenai\npsql (13.1, server 13.0)\n지금은 사용자 \"lijungchi\"로 데이터베이스 \"ecom_wrenai\"에 연결되었습니다.\necom_wrenai=#\n```\n\n이제 이 데이터 세트의 테이블을 만들고 데이터를 가져오려고 합니다. 여기 gist에서 SQL 스크립트를 확인해주세요.\n\nSQL 스크립트를 psql로 복사하거나 psql을 통해 SQL을 가져올 수 있습니다.\n\n```js\necom_wrenai=# \\i <파일 경로>/import.sql\n``` \n\n\n\n\n데이터를 성공적으로 가져오면 아래 정보가 표시됩니다.\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_4.png)\n\n# WrenAI 설치\n\n다음으로 WrenAI를 설치해 봅시다. 시작하기 전에 Docker를 설치해야 합니다.\n\n\n\n## 1. 로컬 컴퓨터에 Docker Desktop을 설치해주세요.\n\nDocker Desktop의 버전이 적어도 `4.17` 이상인지 확인해주세요.\n\n## 2. OpenAI API 키를 준비해주세요.\n\nOpen API 키가 Full Permission(All)을 가지고 있는지 확인해주세요.\n\n\n\nOpenAI 개발자 플랫폼을 방문해주세요.\n\n\n![Image 1](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_5.png)\n\n\nWrenAI를 위한 새로운 API 키를 전체 권한으로 생성해주세요.\n\n\n![Image 2](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_6.png)\n\n\n\n\n## 2. WrenAI 런처 설치\n\n만약 맥을 사용 중이라면(윈도우 또는 리눅스 사용자는 여기를 확인하세요) 최신 WrenAI 런처를 설치하려면 아래 명령어를 입력하세요.\n\n```js\ncurl -L https://github.com/Canner/WrenAI/releases/latest/download/wren-launcher-darwin.tar.gz | tar -xz && ./wren-launcher-darwin\n```\n\n그러면 런처가 아래와 같이 OpenAI API 키를 요청할 것입니다. 키를 복사하여 해당 명령어에 붙여넣고 엔터를 눌러주세요.\n\n\n\nWrenAI에서 OpenAI의 생성 모델인 gpt-4o, gpt-4-turbo, gpt-3.5-turbo를 선택할 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_7.png)\n\n이제 컴퓨터에서 docker-compose가 실행되고 있음을 볼 수 있습니다. 설치 후에는 도구가 자동으로 브라우저를 열어 WrenAI에 액세스할 것입니다.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_8.png)\n\n\n\n# 데이터 소스 연결\n\n터미널이 성공적으로 설치되었으면 브라우저가 시작됩니다\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_9.png)\n\nPostgreSQL 데이터베이스 커넥터를 선택하세요.\n\n\n\n\n![Image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_10.png)\n\n만약 Mac 로컬 PostgreSQL 데이터베이스를 사용하는 경우, 데이터베이스에 액세스하려면 docker.for.mac.localhost를 입력하십시오.\n\n![Image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_11.png)\n\n다음 단계는 시맨틱 모델과의 관계를 정의하는 것입니다. 이는 LLMs가 시맨틱 데이터 구조에 대해 더 잘 이해하도록 도울 수 있습니다.\n\n\n\n\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_12.png)\n\n## 이제 모든 준비가 다 되었어요!\n\nWrenAI UI에서 모든 데이터 모델을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_13.png)\n\n\n\n\n# WrenAI와 함께 놀아보기\n\n## WrenAI UI 시맨틱 모델링\n\nWrenAI UI를 사용하면 데이터 모델을 시맨틱 컨텍스트에서 모델링할 수 있습니다. 설명, 관계, 계산 등을 추가할 수 있습니다. 이 컨텍스트는 LLM이 비즈니스 용어 및 KPI 정의를 학습하고 여러 테이블을 조인할 때 환각을 줄일 수 있는데, LLM은 테이블 간의 관계를 통해 학습하여 데이터 구조 계층구조를 파악할 수 있습니다. 이 관계는 테이블 간이 많 대 일, 일 대 많, 또는 많 대 많인 관계인지 여부와 같이 관계를 통해 학습합니다.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_14.png)\n\n\n\n당신의 비즈니스 KPI 및 수식을 WrenAI에서 계산하여 정의하세요.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_15.png)\n\n테이블 간의 의미 관계 추가하기.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_16.png)\n\n\n\n## WrenAI를 사용하여 비즈니스 질문을 하고 관련 정보를 확인하세요\n\n이제 WrenAI UI의 홈 페이지로 전환할 수 있습니다. New Thread를 클릭하여 비즈니스 질문을 시작할 수 있으며, WrenAI는 벡터 저장소를 통해 관련 의미론을 찾고 추천을 제공합니다.\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_17.png)\n\nWrenAI는 비즈니스 질문에 대해 최대 3가지 옵션을 제시하며, 최종 결과를 생성할 가장 관련성 높은 질문을 선택할 수 있습니다.\n\n\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_18.png)\n\n옵션을 선택하면 WrenAI가 SQL 및 데이터를 포함한 요약을 단계별로 표시하여 결과가 원하는 것인지 확인할 수 있습니다.\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_19.png)\n\n결과를 더 깊이 파악하기 위해 후속 질문을 할 수 있습니다.\n\n\n\n<img src=\"/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_20.png\" />\n\n안녕하세요! 이 부분이 궁금하신가요? gpt-4o를 사용하시는데 즐거우신가요?\n\n만약 저희 작품을 좋아해주신다면, GitHub에서 별표와 지지를 부탁드립니다!\n\n🚀 GitHub: https://github.com/canner/wrenai\n\n\n\n🙌 웹사이트: [https://www.getwren.ai/](https://www.getwren.ai/)\n\n📫 구독하기: [https://blog.getwren.ai/](https://blog.getwren.ai/)\n\n이 글을 즐겨보셨다면 깃허브에서 ⭐ WrenAI에 별표를 주시고, 항상 읽어주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_0.png"},"coverImage":"/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_0.png","tag":["Tech"],"readingTime":5},{"title":"SQL 마스터리 이 필수 기술로 데이터 엔지니어링 실력을 향상하세요","description":"","date":"2024-05-15 04:07","slug":"2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills","content":"\n\n<img src=\"/assets/img/2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills_0.png\" />\n\n데이터 엔지니어링 스킬을 향상시키기 준비가 되셨나요? 오늘날의 데이터 중심 세계에서 SQL을 알고 있는 것은 필수입니다. 면접 준비를 하거나 경력 성장을 목표로 한다면, SQL을 이해하는 것은 여러분에게 문을 열어줄 것입니다.\n\nSQL 또는 Structured Query Language은 데이터베이스에서 데이터를 다루는 마법의 지팡이와 같습니다. SQL을 배우면 통찰을 얻거나 멋진 분석을 수행하고 스마트한 결정을 내릴 수 있습니다.\n\n데이터 엔지니어링 면접에서 능숙하게 대답할 수 있는 모든 SQL 개념입니다.\n\n\n\n서브쿼리: SELECT, FROM, WHERE 절 및 파생 테이블로서 서브쿼리를 사용하는 방법을 이해해보세요.\n\n인덱스: 쿼리 성능 최적화를 위해 인덱스의 중요성을 알고 B-tree, Hash 등 다양한 유형을 사용하는 시기를 파악해보세요.\n\n정규화 및 비정규화: 데이터베이스 정규화의 원칙을 이해하고 성능을 위해 비정규화를 언제 해야 하는지 파악해보세요.\n\n트랜잭션 및 락: ACID 속성의 기본 개념, 트랜잭션 격리 수준, 락 메커니즘을 통해 동시성 문제를 다루는 방법에 대해 알아보세요.\n\n\n\n퍼포먼스 튜닝: 쿼리 최적화, 쿼리 프로파일링, 인덱싱 전략과 같은 기술에 익숙해져 SQL 성능을 향상시키세요.\n\n데이터 모델링: 스타 스키마, 스노우플레이크 스키마와 같은 다양한 데이터 모델링 기술을 이해하고 사용 사례에 따라 올바른 모델링 기법을 선택하세요.\n\nETL 프로세스: 추출, 변환, 적재 (ETL) 프로세스를 위한 SQL 쿼리 작성과 데이터 변환을 효율적으로 처리하는 방법을 알아보세요.\n\n윈도우 프레임: WINDOW 구문을 이용해 범위(RANGE)와 행(ROWS)과 같은 고급 윈도우 프레임 옵션을 살펴봐 더 세밀한 윈도우 함수 제어를 할 수 있습니다.\n\n\n\n시간 관련 쿼리: 시간 관련 테이블, 시간 관련 쿼리, 시계열 데이터 처리 등을 활용하여 시간 데이터를 다루는 방법에 대해 이해하세요.\n\n성능 모니터링: EXPLAIN PLAN, SQL Profiler 및 기타 데이터베이스 모니터링 도구와 같은 도구를 사용하여 SQL 성능을 모니터링하는 방법을 알아보세요.\n\n데이터 웨어하우스 개념: 스타 스키마, 스노우플레이크 스키마, 데이터 웨어하우징 아키텍처 등과 같은 개념에 익숙해지고 효율적인 데이터 웨어하우스를 디자인하는 방법을 알아보세요.\n\n분산 SQL 시스템: 분산 SQL 데이터베이스, 그들의 아키텍처 및 분산 시스템에 최적화된 SQL 쿼리를 작성하는 방법에 대해 배우세요.\n\n\n\n큰 데이터 SQL: Apache Hive, Apache Impala와 같은 Hadoop 프레임워크를 탐색하고, 대용량 데이터 처리를 위한 효율적인 SQL 쿼리 작성 방법을 배워보세요.\n\n이러한 개념을 숙달하면 SQL 스킬이 향상되고 데이터 엔지니어링 면접에서 성공을 거둘 수 있을 겁니다. #데이터엔지니어링 🚀","ogImage":{"url":"/assets/img/2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills_0.png"},"coverImage":"/assets/img/2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills_0.png","tag":["Tech"],"readingTime":2},{"title":"파워 BI로 복잡한 데이터 필터링하기 사례 연구","description":"","date":"2024-05-15 04:03","slug":"2024-05-15-FilteringComplexDatawithPowerBIACaseStudy","content":"\n\n![2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_0](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_0.png)\n\n시작해 봅시다.\n\n안녕하세요, 데이터 열정가 여러분!\n\n데이터가 제멋대로 안 맞을 때 곤욕을 겪어본 적이 있나요? 제게도 그랬어요. 하지만 문제는 항상 뭔가 새로운 것을 배울 수 있는 기회라고 하죠. 그래서 저의 프로젝트에서 최근에 경험한 요구 사항에 대해 이야기해보려고 해요. Power BI에서 굉장히 고집 센 데이터와 씨름해야 했던 일에 대해 말이죠.\n\n\n\n상상해보세요: 클라이언트가 데이터 더미를 전달했는데, 이 데이터는 필터링을 시도해도 혼란스럽다고 느끼게 할 것 같습니다. 이것은 클라이언트의 잘못이 아니에요. 단순히 데이터의 문제일 뿐이죠. 하지만 수동으로 거두기보다는 Power BI의 다양한 기능을 파헤치는 기회로 삼았습니다.\n\n이 블로그 포스트에서는 Power BI에서 데이터 필터링을 탐색하는 과정을 공유할 거에요. 그 과정에서 Power BI를 완전히 새로운 수준에서 이해할 수 있게 도와준 몇 가지 중요한 개념에 대해 소개할 예정이에요.\n\n그래서, 소매 팔뚝을 걷어 올리고, 한 걸음 한 걸음 데이터 필터링 도전에 어떻게 극복했는지 알아보겠습니다.\n\n# 요구 사항 이해하기\n\n\n\n일단 보자마자 이 작업은 간단해 보였습니다: Power BI에서 슬라이서를 구현하여 특정 필드를 기반으로 데이터를 필터링하는 것입니다. 슬라이서를 클릭하면 데이터가 적절하게 조정되어 중복 행 없이 제공된 것과 정확히 일치하게 표시되어야 합니다. 간단하죠? 그렇지만, 사실 그렇지 않았습니다. 여기서 재미있는 일이 벌어졌습니다.\n\n# 도전 과제\n\n도전의 핵심은 필터링해야 할 필드의 특성에 있었습니다. 이 필드는 한 행당 하나의 단일 값이 포함되는 대신, 아래 그림에서 보여지는 것처럼 한 행에 여러 값이 포함될 수 있었습니다. 그러면 아마 궁금해 할 것입니다. 이게 문제인 이유는 무엇일까요?\n\n![그림](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_1.png)\n\n\n\n첫 번째 난관은 필드를 슬라이서 위로 끌어다 놓으려고 시도했을 때 발생한 당연한 문제였어요. 이게 그 문제죠: 필드에 여러 값을 포함할 수 있기 때문에, 슬라이서가 예상대로 작동하지 않았다는 거죠. 선택할 discrete 옵션을 깔끔하게 표시하는 대신, 값들의 얽힌 혼동스러운 모습이 나왔죠. 말할 필요도 없이, 이것이 내 고객이 원하는 것은 아니었습니다.\n\n슬라이서는 사용자가 선택한 기준에 따라 시각적으로 데이터를 필터링하는 도구로, 차트, 그래프, 또는 테이블과 같은 시각화된 데이터에서 데이터를 상호작용적으로 필터링할 수 있게 해줍니다. 데이터를 잘게 썰고 다루는 사용자 친화적인 방법을 제공하여 사용자가 기존 데이터 모델이나 쿼리를 수정하지 않고도 데이터의 특정 하위 집합에 집중할 수 있게 합니다. 슬라이서는 날짜, 범주, 숫자 범위와 같은 다양한 유형의 데이터 필드에 적용될 수 있으며, 사용자는 슬라이서에서 하나 이상의 값을 선택하여 시각화를 상응하게 필터링할 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_2.png)\n\n다음으로 마주한 어려움은 슬라이서에서 중복되지 않는 값만 표시하는 방법과 동시에 여러 값을 포함하는 행들에서 값을 추출하는 것이었습니다. 몇 가지 아이디어 회의 끝에, 우리가 해결책을 찾았다고 생각했어요: Power BI에서 모든 중복되지 않는 값을 추출하는 별도의 테이블을 만드는 것. 이 접근 방식은 중복되지 않는 값을 제공했지만, 우리의 기대에 미치지 못했어요. 단 하나의 키워드와 정확히 일치하는 행만 보여주고 다른 변형이나 추가 키워드를 포함하는 행은 제외했죠. 또한, 이 새로운 테이블을 어떻게 생성하는지 주의해주지 않으면, 뒤에 더 많은 도전 과제를 안겨줄 수 있습니다. 이것에 대해 더 자세히 논의할 거예요.\n\n\n\n만난 도전이 나를 깊게 파고들게 만들었어요. 기억해주세요, 해결한 모든 문제는 작은 것일지라도 앞으로 한걸음 나아가는 것입니다. 그래서, 다음 단계로 가기 위해 슬라이서 안의 고유 값이 그 키워드를 포함하는 행을 필터링하도록 보장하기 위해 노력했어요.\n\n예를 들어, \"subject\"라는 필드를 생각해보죠. 값으로 \"CO, CN,\" \"CO,\" \"Python,\" \"DAA\" 같은 것이 있을 수 있습니다. \"CO\"를 클릭하면 \"CO, CN\"과 \"CO\"를 가진 행을 검색해야 합니다. 이 문제를 해결하기 위해 우리는 해결책을 고안했습니다: 두 개의 열을 가진 테이블을 만드는 것입니다. 한 열은 슬라이서의 고유 값이 들어가고, 다른 하나는 클릭했을 때 표시해야 하는 해당 값이 들어갈 거예요. 그러나, 이 방법은 중복을 생산할 수밖에 없습니다. 이를 해결하기 위해, 두 열을 선택하고 중복된 행을 제거했어요.\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_3.png)\n\n다음 도전은 이 테이블과 주요 문제가 있는 주 테이블 간의 관계를 설정하는 것이었어요.\n\n\n\n테이블을 만들면서 독특한 과제가 있었어요. 해당 테이블에 기본 키가 없었거든요. 데이터의 특성으로 인해 두 열 모두 고유한 값을 가지지 않았죠. 예를 들어, 필드에는 “CO, CN\" 및 “CN, CO\"와 같은 값이 포함될 수 있었어요. 이러한 상황에서 “CO\"는 두 값 모두에 매핑되어야 했고, “CN\"도 그렇죠. 두 열 모두 고유한 값이 없는 상황에서 전통적인 기본 키 설정은 불가능했어요. 떠오른 해결책 중 하나는 주 데이터 세트 테이블과 새로 만든 테이블을 많이-대-많이(Many-to-Many) 관계로 연결하는 것이었어요. 그러나 신중한고려 끝에, 이 접근 방식에 대해 결정을 내렸어요. 많이-대-많이 관계는 복잡성을 도입하고 예상치 못한 결과나 성능 문제를 야기할 수 있어요. 데이터 집계를 모호하게 만들며, 데이터 모델을 복잡하게하고, 특히 대규모 데이터 세트에서는 성능에 영향을 미칠 수 있기 때문이죠. 따라서 더 효율적이고 관리하기 쉬운 해결책을 찾기로 했어요.\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_4.png)\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_5.png)\n\n# 문제 해결\n\n\n\n이전에 언급한 여러 어려움을 극복한 후에, 저는 효율적이고 효과적인 해결책에 도달했습니다. 이 해결책은 데이터 필터링 요구 사항의 복잡성을 해결하면서 내 클라이언트의 요구를 충족하는 간소화된 접근 방식을 제공했습니다. 신중한 실험과 문제 해결을 통해, 작동뿐만 아니라 Power BI 기능에 대한 이해를 향상시키는 방법을 발견했습니다. 이제 솔루션으로 들어가 봅시다.\n\nPower Query 활용하기\n\nPower Query는 데이터 변환 및 데이터 준비 엔진입니다. Power Query에는 소스에서 데이터 가져오는 데 사용하는 그래픽 인터페이스와 변환을 적용하는 Power Query 편집기가 함께 제공됩니다. Power Query를 사용하여 데이터의 추출, 변환 및 로드 (ETL) 처리를 수행할 수 있습니다.\n\n- 슬라이서의 기능에 특별히 맞춘 별도의 테이블을 생성하여 시작했습니다. 이 과정은 슬라이서가 고유한 값을 표시하고 해당 키워드를 포함하는 행만 표시하도록 클릭하는 것을 확인하는 것을 포함했습니다. 이전에 강조했듯이 테이블을 만들 때 데이터를 그대로 복사하거나 중복해서 사용하지 않도록 주의해야 합니다. 그 대신, 데이터의 정확성과 일관성을 유지하기 위해 Power Query의 참조 기능을 사용했습니다. 참조 기능을 사용하면 기존 쿼리의 출력을 참조하는 새로운 쿼리를 생성할 수 있어 데이터의 일관성과 정확성을 보장합니다. 쿼리를 다른 경로로 분기하려는 경우 좋은 선택지입니다. 한 경로는 일련의 단계를 따르고, 다른 경로는 다른 단계를 따르고, 두 경로가 원본 쿼리의 일부 단계를 공유하는 경우에 유용합니다.\n\n\n\n<img src=\"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_6.png\" />\n\n- 새 테이블을 생성한 후에는 다양한 기술을 활용하여 변형하였습니다. 불필요한 열을 제거하고 필요한 열만 유지하며, 열을 복제하고 구분자로 열을 분할하여 여러 값을 고려했습니다. 그 후에 두 열을 선택하고 중복 행을 제거했습니다. 이 과정을 통해 키워드와 해당 값이 정확하게 매핑된 필요한 매핑 테이블이 생성되었고, 데이터 조직화와 검색을 효율적으로 지원하게 되었습니다.\n\n<img src=\"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_7.png\" />\n\n- 매핑 테이블을 생성한 후에는 다대다 관계를 처리하는 것이 정확한 데이터 분석을 보장하기 위해 필수적임을 알게 되었습니다. 따라서 Power BI 모델에 다리 테이블을 도입했습니다. 이 다리 테이블은 주 테이블 필드의 모든 고유한 값들을 포함하며, 매핑 테이블과 주 테이블 사이의 중요한 링크 역할을 합니다. 다리 테이블은 데이터 모델 내의 다대다 관계를 해결하는 데 중요한 역할을 합니다. 이를 위해 매핑 테이블과 주 테이블 둘 다와 일대다 관계를 설정합니다. 두 연결하는 테이블의 주요 필드의 고유한 조합을 포함합니다. 이러한 관계를 통해 주 테이블과 매핑 테이블 간의 직접 필터링이 가능해지며, 전체 모델 전반에 걸쳐 데이터가 일관되고 신뢰할 수 있도록 보장됩니다.\n\n\n\n<img src=\"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_8.png\" />\n\n효과적인 Power BI 모델링을 통한 관계 구축\n\n모델링은 분석과 시각화를 위해 데이터를 구조화하고 조직화하는 과정을 말합니다. 데이터를 다양한 소스에서 가져오고 분석적 요구에 맞게 조성하며, 테이블 간의 관계를 수립하고 DAX를 사용하여 계산을 정의하며, 시각화를 디자인하는 등의 작업을 포함합니다. 효과적인 모델링을 통해 데이터가 논리적으로 구성되고 관계가 정확하게 표현되며, 인사이트가 명확하게 제시되어 의사 결정에 도움이 되는 방향으로 제공됩니다.\n\n- 주 테이블과 브릿지 테이블 사이에 다대일 관계를 설정했습니다.\n- 브릿지 테이블과 맵핑 테이블 사이에 일대다 관계를 구현하여, 맵핑 테이블에서 주 테이블로의 원활한 필터링을 용이하게 하였습니다. 이 선택이 중요한 이유는, 양방향 선택을 하지 않으면 필터링이 브릿지 테이블에서 맵핑 테이블로 제한되어 클라이언트의 기대와 일치하지 않는 필터링 동작이 발생할 수 있었기 때문입니다. Power BI의 양방향 관계는 연결된 테이블 사이에서 필터링이 양방향으로 흐를 수 있도록 합니다. 이는 주 테이블이나 관련 테이블에서 필터링을 적용할 때 다른 테이블에도 영향을 미치게 됩니다. 이 양방향 필터링 흐름은 관련된 테이블 간에 관련 데이터가 정확하게 표시되어 데이터 분석 및 시각화 능력을 향상시켜 더 많은 통찰력 있는 의사 결정을 이끌어냅니다.\n\n\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_9.png)\n\nPower View\n\n- 매핑 테이블에서 단일 값 열을 최종 보고서 내 슬라이서에 통합하여 원활하게 고객 요구 사항을 충족시키고 기대대로 최적의 기능성을 보장했습니다.\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_10.png)\n\n\n\n# 결론\n\n마치 *Power BI*의 데이터 필터링 과제를 해결해 나가는 것은 학습 기회와 통찰력으로 가득한 여정이었습니다. 보이는 것이 간단한 작업으로 시작했지만, 실제로는 데이터 모델링, 관계 설정 및 시각화 디자인의 복잡성에 대한 심층적인 탐구로 이어졌습니다. 중간에 여러 어려움을 만나면서, 단일 필드에서 여러 값을 처리하는 것부터 다대다 관계를 해결하는 데까지 다양한 장애물을 겪었습니다. 그러나 각각의 도전은 *Power BI*의 기능을 탐색하고 혁신적인 해결책을 개발하는 기회로 이어졌습니다.\n\n데이터 변환을 위해 *Power Query*를 활용하고, 효과적인 모델링을 통해 효율적인 관계를 설정하고, *Power View* 슬라이서를 활용하여 상호 작용성을 향상시키는 방법으로 데이터 필터링 도전을 성공적으로 극복할 수 있었습니다. 제안한 솔루션은 클라이언트의 요구를 충족시키는 데뿐만 아니라 *Power BI*의 기능과 모범 사례에 대한 이해를 확장시키는 데 도움이 되었습니다.\n\n도전을 받아들이고 우리가 보유한 도구와 기술을 활용하면 가장 고집 센 데이터 장애물도 극복할 수 있습니다. 데이터 탐색 및 분석 여정을 계속하면서, 해결한 각 문제는 성장과 학습의 기회임을 기억합시다. 앞으로도 많은 성공적인 데이터 모험을 기대합니다!\n\n\n\n이 사례 연구는 다양한 데이터 시나리오를 처리하는 데 Power BI의 강력함과 다재다능성을 강조하여 이러한 장벽을 극복하기 위한 가능한 한 가지 방법을 소개합니다. 또한 DAX(Data Analysis Expressions)를 활용하여 더 효율적이고 맞춤화된 솔루션을 탐색하는 등 더 많은 가능성을 탐색합니다.\n\nLinkedIn에서 저와 연결하고 더 많은 기사를 읽어보세요. 이제 제 여정의 시작이며, 여러분도 함께하고 싶습니다!","ogImage":{"url":"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_0.png"},"coverImage":"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_0.png","tag":["Tech"],"readingTime":7},{"title":"SigmaHQ Rules 릴리스 하이라이트  r2024-05-13","description":"","date":"2024-05-15 03:57","slug":"2024-05-15-SigmaHQRulesReleaseHighlightsr20240513","content":"\n\n\n![SigmaHQRulesReleaseHighlights](/assets/img/2024-05-15-SigmaHQRulesReleaseHighlightsr20240513_0.png)\n\n2024년 5월 13일 Sigma Rule Packages가 발표되었습니다. 이번 릴리즈에는 16개의 새로운 규칙, 7개의 규칙 업데이트 및 1개의 규칙 수정이 7명의 기여자에 의해 추가되었습니다.\n\n# 새로운 규칙\n\n새로운 규칙 중 일부 하이라이트는 다음과 같습니다. Wbadmin을 이용하여 민감한 파일을 덤프/복원하고 백업을 삭제하는 다양한 사례를 다루는 규칙입니다.\n\n\n\n```js\n제목: Wbadmin.EXE를 통한 파일 복구\n아이디: 6fe4aa1e-0531-4510-8be2-782154b73b48\n관련:\n    - 아이디: 84972c80-251c-4c3a-9079-4f00aad93938\n      유형: 파생\n상태: 실험적\n설명: |\n    \"wbadmin.exe\"를 통한 백업 파일로부터 파일 복구를 감지합니다.\n    공격자는 NTDS.DIT 또는 레지스트리 하이브와 같은 민감한 파일을 백업에서 복원하여 자격 증명을 뽑아낼 수 있습니다.\n참고:\n    - https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/wbadmin-start-recovery\n    - https://lolbas-project.github.io/lolbas/Binaries/Wbadmin/\n작성자: Nasreddine Bencherchali (Nextron Systems), frack113\n날짜: 2024/05/10\n태그:\n    - attack.impact\n    - attack.t1490\n로그 소스:\n    카테고리: process_creation\n    제품: windows\n감지:\n    선택 이미지:\n        - Image|endswith: '\\wbadmin.exe'\n        - OriginalFileName: 'WBADMIN.EXE'\n    선택 CLI:\n        CommandLine|contains|all:\n            - ' recovery'\n            - 'recoveryTarget'\n            - 'itemtype:File'\n    조건: 모두 선택_*\n거짓 양성:\n    - 알 수 없음\n수준: 중간\n```\n\n```js\n제목: Wbadmin.EXE를 통한 민감한 파일 덤프\n아이디: 8b93a509-1cb8-42e1-97aa-ee24224cdc15\n상태: 실험적\n설명: |\n    \"NTDS.DIT\" 및 \"SECURITY\" 하이브와 같은 고도로 민감한 파일의 덤프를 감지합니다.\n    공격자는 \"wbadmin\" 유틸리티를 활용하여 자격 증명이나 민감한 정보가 포함된 민감한 파일을 덤프할 수 있습니다.\n참고:\n    - https://github.com/LOLBAS-Project/LOLBAS/blob/2cc01b01132b5c304027a658c698ae09dd6a92bf/yml/OSBinaries/Wbadmin.yml\n    - https://lolbas-project.github.io/lolbas/Binaries/Wbadmin/\n    - https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/wbadmin-start-recovery\n    - https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/wbadmin-start-backup\n작성자: Nasreddine Bencherchali (Nextron Systems), frack113\n날짜: 2024/05/10\n태그:\n    - attack.credential_access\n    - attack.t1003.003\n로그 소스:\n    카테고리: process_creation\n    제품: windows\n감지:\n    선택 이미지:\n        - Image|endswith: '\\wbadmin.exe'\n        - OriginalFileName: 'WBADMIN.EXE'\n    선택 백업:\n        CommandLine|contains:\n            - 'start'\n            - 'backup'\n    선택 경로:\n        CommandLine|contains:\n            - '\\config\\SAM'\n            - '\\config\\SECURITY'\n            - '\\config\\SYSTEM'\n            - '\\Windows\\NTDS\\NTDS.dit'\n    조건: 모두 선택_*\n거짓 양성:\n    - 허가된 관리자에 의한 합법적인 백업 작업. 일치 사항은 감사하고 사안별로 허용되어야 합니다.\n수준: 높음\n```\n\n파워셸 cmdlet인 “Start-NetEventSession\" 및 “New-NetFirewallRule\" 사용을 다루는 새로운 규칙을 소개하였습니다. 공격자가 패킷을 캡처하거나 새 방화벽 규칙을 생성하는 데 사용할 수 있습니다.\n\n```js\n제목: New-NetFirewallRule Cmdlet을 통한 새 Windows 방화벽 규칙 추가 - ScriptBlock\n아이디: 8d31dd2e-b582-48ca-826e-dcaa2c1ca264\n관련:\n    - 아이디: 51483085-0cba-46a8-837e-4416496d6971\n      유형: 유사\n상태: 실험적\n설명: |\n    PowerShell 스크립트에 \"New-NetFirewallRule\" cmdlet 호출이 포함되어 있어 \"허용\" 동작을 하는 새 방화벽 규칙이 추가될 때 감지합니다.\n참고:\n    - https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1562.004/T1562.004.md#atomic-test-24---set-a-firewall-rule-using-new-netfirewallrule\n    - https://malware.news/t/the-rhysida-ransomware-activity-analysis-and-ties-to-vice-society/72170\n    - https://cybersecuritynews.com/rhysida-ransomware-attacking-windows/\n작성자: frack113\n날짜: 2024/05/10\n태그:\n    - attack.defense_evasion\n    - attack.t1562.004\n    - detection.threat_hunting\n로그 소스:\n    제품: windows\n    카테고리: ps_script\n    정의: '요구 사항: 스크립트 블록 로깅이 활성화되어 있어야 함'\n감지:\n    선택:\n        ScriptBlockText|contains: 'New-NetFirewallRule*-Action*Allow'\n    조건: 선택\n거짓 양성:\n    - 관리자 스크립트\n수준: 낮음\n```\n\n\n\n```yaml\ntitle: \"Start-NetEventSession를 통한 잠재적인 패킷 캡처 활동 - 스크립트 블록\"\nid: da34e323-1e65-42db-83be-a6725ac2caa3\nstatus: experimental\ndescription: |\n    \"Start-NetEventSession\" cmdlet을 호출하는 PowerShell 스크립트 실행을 감지합니다. 이를 통해 공격자는 네트워크 이벤트 세션에 이벤트 및 패킷 캡처를 시작할 수 있습니다.\n    이 기술을 통해 수행 중인 작업의 정보를 수집하기 위해 공격자가 네트워크를 캡처하려 할 수 있습니다.\n    이 기술을 통해 캡처된 데이터에는 특히 안전하지 않고 암호화되지 않은 프로토콜을 통해 전송된 사용자 자격 증명이 포함될 수 있습니다.\nreferences:\n    - https://github.com/redcanaryco/atomic-red-team/blob/5f866ca4517e837c4ea576e7309d0891e78080a8/atomics/T1040/T1040.md#atomic-test-16---powershell-network-sniffing\n    - https://github.com/0xsyr0/Awesome-Cybersecurity-Handbooks/blob/7b8935fe4c82cb64d61343de1a8b2e38dd968534/handbooks/10_post_exploitation.md\n    - https://github.com/forgottentq/powershell/blob/9e616363d497143dc955c4fdce68e5c18d28a6cb/captureWindows-Endpoint.ps1#L13\nauthor: frack113\ndate: 2024/05/12\ntags:\n    - attack.credential_access\n    - attack.discovery\n    - attack.t1040\nlogsource:\n    product: windows\n    category: ps_script\n    definition: 'Script Block Logging이 활성화되어 있어야 함'\ndetection:\n    selection:\n        ScriptBlockText|contains: 'Start-NetEventSession'\n    condition: selection\nfalsepositives:\n    - 적절한 네트워크 진단 스크립트.\nlevel: medium\n```\n\n또한 \"KeyScrambler.exe\"의 잠재적으로 의심스러운 자식 프로세스를 보와하는 새로운 규칙이 추가되었습니다.\n\n```yaml\ntitle: \"KeyScrambler.exe의 잠재적으로 의심스러운 자식 프로세스\"\nid: ca5583e9-8f80-46ac-ab91-7f314d13b984\nrelated:\n    - id: d2451be2-b582-4e15-8701-4196ac180260\n      type: similar\nstatus: experimental\ndescription: KeyScrambler.exe의 잠재적으로 의심스러운 자식 프로세스를 감지합니다.\nreferences:\n    - https://twitter.com/DTCERT/status/1712785421845790799\nauthor: Swachchhanda Shrawan Poudel\ndate: 2024/05/13\ntags:\n    - attack.execution\n    - attack.defense_evasion\n    - attack.privilege_escalation\n    - attack.t1203\n    - attack.t1574.002\nlogsource:\n    category: process_creation\n    product: windows\ndetection:\n    selection_parent:\n        ParentImage|endswith: '\\KeyScrambler.exe'\n    selection_binaries:\n        - Image|endswith:\n              - '\\cmd.exe'\n              - '\\cscript.exe'\n              - '\\mshta.exe'\n              - '\\powershell.exe'\n              - '\\pwsh.exe'\n              - '\\regsvr32.exe'\n              - '\\rundll32.exe'\n              - '\\wscript.exe'\n        - OriginalFileName:\n              - 'Cmd.Exe'\n              - 'cscript.exe'\n              - 'mshta.exe'\n              - 'PowerShell.EXE'\n              - 'pwsh.dll'\n              - 'regsvr32.exe'\n              - 'RUNDLL32.EXE'\n              - 'wscript.exe'\n    condition: all of selection_*\nfalsepositives:\n    - 알 수 없음\nlevel: medium\n```  \n\n모든 새로운 규칙 목록의 전체 릴리스 변경 로그를 확인하세요.\n\n\n\n\n# 새로운 업데이트\n\n일부 이전 규칙들이 커버리지 및 메타데이터에서 개선되었습니다.\n\n우선, \"Microsoft-Windows-Windows Firewall With Advanced Security\"를 활용하는 몇 가지 규칙에서는 커버리지를 늘리기 위해 EID 2097이 추가되었습니다.\n\n```js\ntitle: 잠재적으로 의심스러운 응용 프로그램을 위한 Windows 방화벽 예외 목록에 새로운 방화벽 규칙이 추가되었습니다.\nid: 9e2575e7-2cb9-4da1-adc8-ed94221dca5e\nrelated:\n    - id: cde0a575-7d3d-4a49-9817-b8004a7bf105\n      type: derived\nstatus: experimental\ndescription: 잠재적으로 의심스러운 위치에 있는 응용 프로그램에 대한 Windows 방화벽 예외 목록에 새로운 규칙이 추가되는 것을 탐지합니다.\nreferences:\n    - https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-r2-and-2008/dd364427(v=ws.10)\n    - https://app.any.run/tasks/7123e948-c91e-49e0-a813-00e8d72ab393/#\nauthor: frack113\ndate: 2023/02/26\nmodified: 2024/05/10\ntags:\n    - attack.defense_evasion\n    - attack.t1562.004\nlogsource:\n    product: windows\n    service: firewall-as\ndetection:\n    selection:\n        EventID:\n            - 2004 # Windows Defender 방화벽 예외 목록에 규칙이 추가되었습니다. (Windows 10)\n            - 2071 # Windows Defender 방화벽 예외 목록에 규칙이 추가되었습니다. (Windows 11)\n            - 2097\n        ApplicationPath|contains:\n            - ':\\PerfLogs\\'\n            - ':\\Temp\\'\n            - ':\\Tmp\\'\n            - ':\\Users\\Public\\'\n            - ':\\Windows\\Tasks\\'\n            - ':\\Windows\\Temp\\'\n            - '\\AppData\\Local\\Temp\\'\n    filter_main_block:\n        Action: 2 # 차단\n    condition: selection and not 1 of filter_main_*\nfalsepositives:\n    - 알 수 없음\nlevel: 높음\n```\n\n\n\n```js\ntitle: Windows 방화벽 예외 목록에 추가된 새로운 드문한 방화벽 규칙\nid: cde0a575-7d3d-4a49-9817-b8004a7bf105\nstatus: experimental\ndescription: Windows 방화벽 예외 목록에 규칙이 추가된 것을 감지합니다\nreferences:\n    - https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-r2-and-2008/dd364427(v=ws.10)\nauthor: frack113\ndate: 2022/02/19\nmodified: 2024/05/10\ntags:\n    - attack.defense_evasion\n    - attack.t1562.004\nlogsource:\n    product: windows\n    service: firewall-as\ndetection:\n    selection:\n        EventID:\n            - 2004 # Windows Defender 방화벽 예외 목록에 규칙이 추가됨\n            - 2071 # Windows Defender 방화벽 예외 목록에 규칙이 추가됨. (Windows 11)\n            - 2097\n    filter_main_block:\n        Action: 2 # 차단\n    filter_main_generic:\n        ApplicationPath|contains:\n            - ':\\Program Files (x86)\\'\n            - ':\\Program Files\\'\n            - ':\\Windows\\System32\\'\n            - ':\\Windows\\SysWOW64\\'\n            - ':\\Windows\\WinSxS\\'\n    filter_optional_msmpeng:\n        ModifyingApplication|contains|all:\n            - ':\\ProgramData\\Microsoft\\Windows Defender\\Platform\\'\n            - '\\MsMpEng.exe'\n    filter_main_covered_paths:\n        # 이 필터는 9e2575e7-2cb9-4da1-adc8-ed94221dca5e로부터의 중복 경고 방지를 위해 추가되었습니다\n        ApplicationPath|contains:\n            - ':\\PerfLogs\\'\n            - ':\\Temp\\'\n            - ':\\Tmp\\'\n            - ':\\Users\\Public\\'\n            - ':\\Windows\\Tasks\\'\n            - ':\\Windows\\Temp\\'\n            - '\\AppData\\Local\\Temp\\'\n    condition: selection and not 1 of filter_main_* and not 1 of filter_optional_*\nlevel: medium\n```\n\n`PDQDeployRunner`를 사용하여 추가 경로 및 프로세스가 규칙에 추가되었습니다. 이는 악의적인 랜섬웨어 위협 행위자들이 환경 전체로 악성 소프트웨어를 배포하기 위해 종종 사용하는 유틸리티입니다.\n\n```js\ntitle: PDQDeployRunner의 잠재적으로 의심스러운 실행\nid: 12b8e9f5-96b2-41e1-9a42-8c6779a5c184\nrelated:\n    - id: d679950c-abb7-43a6-80fb-2a480c4fc450\n      type: 비슷함\nstatus: 테스트\ndescription: \"PDQDeployRunner\"의 의심스러운 실행을 감지합니다. 이는 원격 장치에서 명령과 패키지를 실행하는 PDQDeploy 서비스 스택의 일부입니다\nreferences:\n    - https://twitter.com/malmoeb/status/1550483085472432128\nauthor: Nasreddine Bencherchali (Nextron Systems)\ndate: 2022/07/22\nmodified: 2024/05/02\ntags:\n    - 공격.실행\nlogsource:\n    category: process_creation\n    product: windows\ndetection:\n    selection_parent:\n        ParentImage|contains: '\\PDQDeployRunner-'\n    selection_child:\n        # 다른 의심스러운 프로세스, 명령줄 또는 경로 추가하여 이 섹션을 개선\n        - Image|endswith:\n              # 다음 프로세스 중 하나를 정상적으로 사용할 경우 주석 처리\n              - '\\bash.exe'\n              - '\\certutil.exe'\n              - '\\cmd.exe'\n              - '\\csc.exe'\n              - '\\cscript.exe'\n              - '\\dllhost.exe'\n              - '\\mshta.exe'\n              - '\\msiexec.exe'\n              - '\\regsvr32.exe'\n              - '\\rundll32.exe'\n              - '\\scriptrunner.exe'\n              - '\\wmic.exe'\n              - '\\wscript.exe'\n              - '\\wsl.exe'\n        - Image|contains:\n              - ':\\ProgramData\\'\n              - ':\\Users\\Public\\'\n              - ':\\Windows\\TEMP\\'\n              - '\\AppData\\Local\\Temp'\n        - CommandLine|contains:\n              - ' -decode '\n              - ' -enc '\n              - ' -encodedcommand '\n              - ' -w hidden'\n              - 'DownloadString'\n              - 'FromBase64String'\n              - 'http'\n              - 'iex '\n              - 'Invoke-'\n    condition: all of selection_*\nfalsepositives:\n    - PDQDeploy 도구를 사용하여 이러한 명령을 실행하는 것이 정당할 경우\nlevel: medium\n```\n\n모든 업데이트 목록을 확인하려면 전체 릴리스 변경 로그를 확인하세요.\n\n\n\n\n# 수정 사항\n\n이 릴리스에서는 \"Forest Blizzard APT - 프로세스 생성 활동\" 규칙이 작동하지 않도록 만드는 누락된 수정 자를 처리한 것을 확인할 수 있었습니다.\n\n변경 사항 및 추가 사항의 전체 변경 로그를 확인하려면 아래 릴리스 페이지를 참조해주세요.\n\n# 기여자\n\n\n\n이 릴리스는 Sigma 커뮤니티 기여자 여러분 덕분에 가능해 졌어요. 다음 분들께 큰 감사를 전합니다.\n\n- @ahmedfarou22\n- @frack113\n- @hasselj\n- @joshnck\n- @nasbench\n- @pratinavchandra\n- @swachchhanda000","ogImage":{"url":"/assets/img/2024-05-15-SigmaHQRulesReleaseHighlightsr20240513_0.png"},"coverImage":"/assets/img/2024-05-15-SigmaHQRulesReleaseHighlightsr20240513_0.png","tag":["Tech"],"readingTime":12},{"title":"iPad Pro에 macOS 앱이 없다면, Apple은 그것을 그냥 죽여 버릴 수도 있을 거에요","description":"","date":"2024-05-15 03:53","slug":"2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit","content":"\n\n<img src=\"/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_0.png\" />\n\n애플의 \"Let Loose\" 이벤트가 지나가면서 새로운 iPad Pro 및 iPad Air 모델과 함께 완전히 필요 없는 드라마도 함께 등장했습니다. 이제 우리가 기다리는 건 실제 기기와 악세사리 자체입니다. 미디어에서 애플의 프레젠테이션, 발표 및 제품에 대해 다양한 의견이 있었지만 대부분의 댓글러들은 새로운 iPad Pro 모델은 인상적이었지만 업그레이드가 필요한 것은 하드웨어가 아니라는 데 동의했습니다. 실제로 iPadOS가 가장 강력한 iPad을 진정한 잠재력을 실현하지 못하게 하고 있습니다.\n\n말할 필요도 없이, 우리는 이미 이런 상황을 겪어본 적이 있습니다. 그러나 이번에는 다르게 보입니다. 사람들은 더 나은 iPadOS 버전을 요청하는 것이 아닙니다. 아니요. 그들이 요청하는 것은 iPad Pro에서 macOS 앱입니다. 이 개념은 듣기에는 듣던 대로인 것 같지만, 지금은 시기적절하거나 심지어 필수적으로 느껴집니다. 이것은 애플의 전략에서 주요 변화를 일으킬 가능성이 있고 전체적으로 태블릿 범주에 중요한 발전이 될 수도 있습니다. 이것이 그 이유이며, 왜 이제야 시간이 된 것인지 말씀드리겠습니다.\n\n## \"iPad에서 macOS 사용\" 사가: 왜 이쪽으로 오게 되었는가?\n\n\n\niPad Pro이 macOS 애플리케이션을 실행하는 아이디어는 결코 새로운 것이 아닙니다. 예를 들어, 저는 M1 기반 iPad Pro를 발표한 이후인 2021년 봄부터 iPad가 macOS에 액세스할 수 있도록 Apple에 촉구하고 있었습니다. 긴 시간이 너무 오래요? 네, 왜냐하면 그 때부터 iPad Pro가 잠재력을 충분히 발휘하지 못하고 있다는 것이 이미 분명해졌기 때문입니다. 그뿐만 아니라 \"Pro\" 장치로서가 아니라 기술 제품으로서 모두에서도 그랬습니다.\n\n![이미지](/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_1.png)\n\nMonica Chin의 유명한 \"이 겁하지 마세요, iPad에 macOS를 넣으세요\"라는 기사가 그 때 The Verge에 게재된 후 여러 개의 유사한 기사가 이어졌습니다. 이것이 바로 대다수의 우리 기술 기자들이 이전 몇 년 동안 iPad Pro를 생산적으로 사용해 본 적이 있는데도 Tim Cook이 M1 프로세서를 iPad에 담아둔 그 유명한 영상을 보면서 느꼈던 정황과 정확히 일치했습니다.\n\n이후의 한 해 동안 Apple이 macOS를 iPad에 넣는 아이디어를 적어도 고려하기 시작한 것으로 보이는 몇 가지 신호가 있었습니다. 그러나 회사가 그 문제에 대해 어떠한 업데이트도 제공하지 않는 것이 계속되면서, M2 기반 iPad가 동일한 기존 iPadOS를 기반으로 할 경우 그것이 어떤 의미가 있는 지 의문을 품기 쉬워졌습니다. 저와 같은 많은 사람들은 심지어 진정한 데스크톱 수준의 프로페셔널 macOS 애플리케이션에 액세스할 수 없는 iPad \"Pro\"라는 개념을 심각하게 의심하기 시작했습니다.\n\n\n\n시간이 흐를수록 더 많은 사람들이 그 관점으로 기울어가는 것 같았고, 확실히 WWDC 2022에서 아무 변화도 없이 10월에 더 강력한 M2 기반 iPad Pro 모델을 출시한 후 실망을 표현하는 목소리가 훨씬 많아졌습니다. 이러한 태블릿들은 대체 누구를 위한 것이었을까요?\n\n하드웨어 면에서는 조용한 한 해였던 2023년 동안, “생산성을 위한 iPadOS를 개선하는\" 과정을 지켜보는 것은 점점 더 답답한 경험이 되었습니다. 이 운영 체제는 명백히 그 목적으로 설계된 것이 아니었기 때문에 다양한 시도나 미완성된 아이디어는 별다른 차이를 만들지 못했습니다. iPad Pro가 맥과 정확히 같은 하드웨어를 갖게 된 후, 프로페셔널들이 일을 위해 설계된 적합한 운영 체제를 요구하는 것은 당연했습니다. 그것이 macOS였습니다.\n\n이제 iPad Pro와 Magic Keyboard 조합은 맥북과 동등한 가격을 초과하게 되면서, 이전의 기기가 이후의 판매를 침해할 것을 기대하는 애플의 잘 알려진 두려움도 더 이상 타당하지 않습니다. 그 결과로 회사는 이제 macOS 애플리케이션을 iPad Pro에서 한 방이나 다른 방식으로 실행할 수 있도록 허용해야 하는 압박을 받고 있습니다. 그렇다면 회사가 어떻게 그런 일을 할 수 있을까요? 어떤 제약이나 제한을 이 기능에 부과할 것이며, 그것이 iPad Pro의 미래에 어떤 의미를 갖게 될까요?\n\n## iPad Pro에서 macOS가 어떻게 작동할까요?\n\n\n\nApple이 이를 처리할 수있는 몇 가지 다른 방법이 있지만, 소비자에게는 아마도 가장 간단한 것이 가장 좋을 것입니다: 듀얼 부팅 옵션입니다. 회사는 iPad Pro의 내부 저장 공간을 파티션하고 macOS를 다운로드하고 태블릿에 설치하는 과정을 안내하는 앱을 제공할 수 있습니다. 그러면 사용자들은 장치를 다시 시작하고 부팅 시 OS를 선택함으로써 이전에 인텔 기반 맥에서 macOS 및 Windows 간에 수행했던 것과 같은 방식으로 두 OS 사이를 전환할 수 있을 것입니다.\n\n![아이패드 프로에서 macOS 앱을 사용할 수 없다면 아예 없애버릴 수도 있어요](/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_2.png)\n\nApple이 iPad Pro에서 macOS를 실행하는 또 다른 방법은 가상 머신을 통한 것입니다. 소비자들은 Apple의 태블릿에 macOS를 설치하기 위해 동일한 설정 앱을 사용하지만, 각각의 운영 체제를 전환할 때마다 재부팅하는 대신, 데스크톱 애플리케이션을 사용할 필요가 있을 때에는 macOS 환경을 (아마도 최대화하여) 열고, 완료되면 \"닫을\" 것입니다.\n\n이 접근법은 macOS와 iPadOS간의 즉각적인 전환을 제공할 뿐만 아니라 일부 보안 및 개인 정보 보호 이점도 제공할 것입니다. ── 가상 머신은 \"박스형 모드\" 즉, 특정하고 보호된 메모리 공간에서 조정 가능한 시스템 액세스 권한으로 실행할 수 있기 때문에 ── 그러나 시스템 리소스 공유로 인한 응용 프로그램 성능 저하가 발생할 수 있을 수도 있습니다.\n\n\n\n소비자들에게는 덜 투명한 세 번째 방법이 있을 수 있지만, 이는 iPad Pro에서 macOS 애플리케이션이 작동하는 방식에 대한 Apple의 최대 통제력을 제공할 것입니다. 회사는 \"투명하지 않은\" macOS의 설치를 허용할 수 있으며, 이는 소비자가 macOS 애플리케이션을 실행해야 할 때에만 요청될 것입니다. 이 시스템을 통해 iPad Pro에서 macOS 프로그램은 실제로 디바이스 소유자에게 운영 시스템을 노출시키지 않으면서 전체 기능을 유지할 수 있게 됩니다.\n\n## Apple에게 최선인 것이 소비자에게도 잘 맞을까요?\n\n상세히 설명한 세 번째 접근 방식은 소비자들에게 분명한 단점들을 가지고 있습니다. 예를 들어 파일 관리와 멀티태스킹이 더 어려워질 수 있습니다. 그러나 이는 Apple이 선호하는 익숙한 \"잠긴 상태\"로 작동하며, iPad Pro에서 애플리케이션은 여전히 전체 속도로 실행됩니다. 이 방식으로 사용자들은 Mac의 전통적인 데스크톱 환경에 액세스할 수 없지만, 애플리케이션은 iPad Pro에서 전체 속도로 실행됩니다. Apple은 \"iPad Pro에서 Mac 프로그램을 제공하고 있다\"고 주장할 수 있을 것인데, 기술적으로 거짓말하지 않게 될 것입니다. 그러나 전체 macOS 사용자 경험을 제공하는 것은 아니게 될 것입니다.\n\n상기한 세 가지 접근 방법 중에서, 듀얼 부팅 방식이 아마도 소비자들이 iPad Pro에서 macOS 소프트웨어를 경험하는 데 가장 좋은 방법이 될 것입니다. Apple은 같은 디바이스의 iPadOS와 macOS 파티션들이 서로 접근할 수 없도록 보장하기 위해 어떤 노력을 해야 할 것이지만 (다양한 이유들을 위해서), 가상 머신 방식도 가능할 것입니다. 이 방식도 작동할 수 있지만 시스템 리소스에 더 큰 부담을 줄 것이고, 이는 적절한 관리 없이 성능에 영향을 줄 수 있습니다.\n\n\n\n![image](/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_3.png)\n\n만약 내가 내기하는 사람이었다면, '잠겨 있는' 방식이 가장 가능성이 높게 구현될 것이라고 돈을 거는 것이 올바른 것 같습니다. 사용자 경험을 제어하는 데 있어서 애플의 스타일과 일치합니다.\n\n그런데 아이패드 프로에서 macOS 아이디어를 구현할 때 애플이 가할 수 있는 제한 사항은 무엇인가요?\n\n\n\n당연히 어떠한 제약도 없이 제공된다면 좋을텐데, 애플이 애플답게 macOS가 iPad에서 제공될 경우에는 어떤 형태로든 제약이 따를 것입니다. 첫 번째, 분명한 제약 사항: 여기서는 iPad Pro 모델만이 어떠한 형태로든 macOS를 받게 될 것이라는 것입니다. 일반 iPad나 iPad 미니에서는 이 기능을 제공하는 것은 말도 안 되며 솔직히 그것이 괜찮습니다. 강력한 iPad를 생산적으로 사용하고자 하는 사람들이 실제로 macOS를 필요로 하는 것이기 때문입니다. 입문용 모델들은 다른 용도로 디자인되었기 때문에 불만이 없습니다.\n\n그리고, 2022년 5월에 Patently Apple에 의해 밝혀진 널리 논의된 특허는 iPad Pro에 macOS와 유사한 인터페이스를 제공한다면 Magic Keyboard와 같은 액세서리에 연결되어 있어야 한다는 것을 시사했습니다. 이는 여러 면에서 잘못될 수 있습니다 — 많은 소비자들이 자신의 선택에 따라 블루투스 키보드와 마우스를 사용하는 것을 선호하더라도, 애플이 해당 액세서리의 더 높은 매출을 원하는 욕심을 드러내는 것입니다. 하지만... 우리는 현실적으로 여기서 얘기하자면, 해당 기업은 이를 할 수 있고 그로 인해 이득을 얻을 수도 있습니다.\n\n애플이 가능한 듀얼 부팅 macOS/iPadOS 설치에 부과할 수 있는 다른 제약은 저장 공간과 관련이 있습니다. 현재 어떤 맥 컴퓨터든 최소 256GB의 저장 공간을 제공하고 있으며, 이는 사실상 2024년 기준으로는 절대 미약한 용량입니다. 애플은 iPad Pro에 macOS 파티션을 생성하는 것은 최소한 그것과 일치해야 한다고 주장할 수 있을 것입니다. 이 요구 사항은 512GB 또는 그 이상의 저장 공간이 장착된 iPad Pro 모델만이 macOS에 액세스할 수 있음을 의미하며, 이는 분명히 애플의 수익에 도움이 될 것입니다.\n\n이상적으로 소비자는 macOS 용으로 얼마의 내부 저장 공간을 예약하길 원하는지 조절할 수 있어야 합니다 — 최신 macOS조차도 실제로 자체적으로 32GB 이상의 용량이 필요하지 않기 때문입니다. 하지만 다시 한번 말하지만, 애플은 이 256GB 제약을 쉽게 시행할 수 있을 것입니다. 또한 애플은 원한다면 외부 SSD에 macOS를 설치할 수 있도록 허용할 수도 있겠지만, 이는 각자의 요구 사항과 제한 사항을 가지고 있을 것이기 때문에 대부분의 소비자들이 원하는 대로 원활하게 작동하지 않을 것입니다.\n\n\n\niPad Pro와 macOS를 함께 사용하는 데 Apple이 부과할 수 있는 제약 중 하나는 시스템 메모리와 관련이 있을 수 있지만, 이는 데스크톱 운영 체제가 회사의 가장 강력한 태블릿에서 실행되도록 구현되는 방식에 따라 달라집니다. 이 구현이 macOS가 iPadOS와 함께 실행되어 두 운영 체제 간의 전환을 순간적으로 만들어주는 방식으로 설계되었다면, Apple은 아마도 이러한 시나리오를 위해 16GB의 시스템 메모리가 필요하다고 주장할 수 있을 것입니다 (이는 1TB/2TB 저장 구성을 사용하는 iPad Pro 모델에서만 제공됩니다).\n\n![링크 이름](/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_4.png)\n\n반면에 간단한 듀얼 부팅 구현에 대해 언급하는 것이면, Apple이 8GB가 macOS를 효과적으로 실행하기에 충분하지 않다고 주장하기는 다소 어려울 것입니다... 그동안 모두에게 그 반대를 주장해 왔기 때문에 말이죠. 맞나요?\n\n마지막으로: Apple이 iPad Pro에서 macOS를 허용하기로 결정할 경우, M2 및 M4 세대의 프로세서에서 데스크톱 OS의 사용을 제한하기 위한 변명을 찾을 수도 있습니다. 이는 확실한 현금 잡기일 것입니다 - M1은 어떠한 문제없이 최신 macOS를 실행할 수 있기 때문에 - 그러나 2024년 가을에는 M1이 소개된지 거의 4년이 되어갈 때이니까요... 어쩔 수 없이. Apple이라니까요.\n\n\n\n## 아이패드 프로는 어려운 결정 앞에 있습니다 — 애플은 무엇을 할까요?\n\n아이패드의 macOS 호환성 측면에서 애플이 선택한 것이 무엇이든, 만약 제공하려는 선택을 구현하는 방법에 대해 계획한다면, 모두에게 분명한 것은 이것입니다: 아이패드 프로는 공식적으로 어려운 결정 앞에 있는 상황입니다.\n\n이 회사의 최고의 태블릿은 수년간 “거의, 그러나 그렇지 않은 컴퓨터\"라는 어색한 위치에 있었으며, 하드웨어 측면에 맞춰 소프트웨어 측면이 시행할 계획이 있었기 때문입니다. 애플은 아이패드 프로가 맥처럼 다재다능하고 유용할 정도로 발전하는 걸 원하지 않았기 때문에, 회사가 한 일은 주로 소비자가 업그레이드하도록 유도하기 위해 자사의 주력 태블릿을 점진적으로 강화하는 것뿐이었습니다.\n\n그래서 이제 아이패드 프로의 하드웨어 측면이 너무 발전해서 혼란스러운 수준에 이르렀다는 것에는 이유가 있습니다. 애플은 결국 너무 멀리 갔습니다: 단순히 아이패드 프로의 소프트웨어 측면에 대해 뭔가 해야할 필요가 있는데, 그것을 빨리 처리하지 않는다면 소말리아해야만 할지도 모릅니다. 만약 현재의 iPadOS에서 실행된다면 이 유형의 새로운 모델을 다시 출시하는 것에는 절대로 아무 의미가 없습니다. 그것을 시도해봤습니다. 제대로 작동하지 않습니다. 애플은 이 기기가 이제 드디어 자신이 어떤 것을 정말 제공할 수 있는지 증명할 수 있도록... 그리고 이것을 하는 방법은 하나뿐입니다: macOS와 데스크톱 애플리케이션이 아이패드 프로에서 실행되도록 허용하는 것이 바람직합니다. 가능하다면 듀얼 부팅 모드에서 실행되도록 하는 것이 좋습니다.\n\n\n\n그래서 WWDC 2024는 iPad의 역사상 가장 중요한 이벤트가 될 것입니다. 이 이벤트를 통해 애플이 iPad Pro를 항상 의도했던 디바이스의 본 모습을 세계에 증명할 것입니다. 회사는 변명의 여지가 없으며, 시간이 부족하다는 것을 알고 있습니다. 만약 우리가 iPad Pro를 iPad Deluxe로 사용하기로 결정한다면 - \"작업\"하는 척하는 대신, 사실상 어떤 일반 iPad나 심지어 iPad 미니에서 할 수 있는 것을 하는 것이라면 - 우리는 그냥 그렇게 하면 됩니다. 모두 연기를 그만 두고, iPad \"Pro\"를 잊고 간단한 iPad를 구입하고 이 모든 것을 마무리 지으세요. 결정은 애플에 달려 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_0.png"},"coverImage":"/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_0.png","tag":["Tech"],"readingTime":8},{"title":"맥OS 및 리눅스용 SSH 키 생성기","description":"","date":"2024-05-15 03:50","slug":"2024-05-15-SSHKeyGeneratorforMacOSLinux","content":"\n\n<img src=\"/assets/img/2024-05-15-SSHKeyGeneratorforMacOSLinux_0.png\" />\n\n우선, 제 코딩 인생에서 좋아하는 인용구부터 시작하겠어요:\n“어떤 일을 6분 동안 수동으로 할 때 6시간을 써서 자동화를 실패하는 것이 더 나을 때가 있다.\" — Zhuowei Zhang\n\n대부분의 개발자들이 SSH 키를 생성하고 연결하는 방법에 대해 문서를 참고해 왔을 겁니다. 지난 3년간 이 프로세스를 4~5번 되풀이했는데, 총 40~50분 정도 걸렸어요. 결국, 이러한 과업을 다시 찾아보지 않도록 스크립트를 작성하기로 결심했습니다. 아래에는 해당 스크립트를 공유하고 있어요. \"your_remote_server_url\"을(를) 실제 원격 서버 URL로 교체해 주시기 바랍니다.\n\n```js\n#!/bin/bash\n\n# Command existence 확인하는 함수\ncommand_exists() {\n  command -v \"$1\" >/dev/null 2>&1\n}\n\n# 현재 운영 체제 감지\nif [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n  # macOS\n  CLIP_CMD=\"pbcopy\"\nelif [[ \"$OSTYPE\" == \"linux-gnu\"* ]]; then\n  # Linux\n  if command_exists \"xclip\"; then\n    CLIP_CMD=\"xclip -selection clipboard\"\n  elif command_exists \"xsel\"; then\n    CLIP_CMD=\"xsel --clipboard\"\n  else\n    echo \"클립보드 유틸리티(xclip 또는 xsel)를 찾을 수 없습니다. 계속 진행하려면 설치해 주세요.\"\n    exit 1\n  fi\nelif [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"cygwin\" ]]; then\n  # Windows (Cygwin 또는 MSYS)\n  echo \"Windows에서는 클립보드 복사 명령을 지원하지 않습니다.\"\n  echo \"SSH 키를 수동으로 복사해 주세요.\"\n  CLIP_CMD=\":\"\nelse\n  echo \"지원되지 않는 운영 체제입니다.\"\n  exit 1\nfi\n\n# 사용자에게 GitHub 이메일 입력 요청\nread -p \"GitHub 이메일 주소를 입력하세요: \" email\n\n# SSH 키 생성\nssh-keygen -t rsa -b 4096 -C \"$email\"\n\n# SSH 키를 클립보드에 복사\ncat ~/.ssh/id_rsa.pub | $CLIP_CMD\n\n# 사용자에게 SSH 키가 클립보드에 복사되었음을 알림\necho \"SSH 키가 클립보드에 복사되었습니다.\"\n\n# GitHub 설정 페이지를 기본 브라우저에서 열기 (macOS 및 Linux 전용)\nif [[ \"$OSTYPE\" == \"darwin\"* || \"$OSTYPE\" == \"linux-gnu\"* ]]; then\n  echo \"기본 브라우저에서 GitHub 설정 페이지를 엽니다...\"\n  open \"https://github.com/settings/ssh\" # 여기에 원격 서버 URL이 있어요\nfi\n\necho \"SSH 키를 GitHub 계정에 추가해 주세요.\"\n```\n\n\n\n원하는대로 스크립트를 수정하십시오!","ogImage":{"url":"/assets/img/2024-05-15-SSHKeyGeneratorforMacOSLinux_0.png"},"coverImage":"/assets/img/2024-05-15-SSHKeyGeneratorforMacOSLinux_0.png","tag":["Tech"],"readingTime":2}],"page":"98","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}