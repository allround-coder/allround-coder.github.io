{"pageProps":{"posts":[{"title":"클라이언트 측 JavaScript를 사용하여 문자열을 버퍼 및 데이터 URL 형식으로 변환하는 방법","description":"","date":"2024-05-14 13:52","slug":"2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript","content":"\n\n웹 애플리케이션에서는 Base64가 종종 사용됩니다. 바이너리 데이터를 ASCII 텍스트 형식으로 저장하거나 전송하기 위해 인코딩하는 데 쓰입니다. 예를 들어, 파일 전송 API는 효율적인 저장 및 처리 속도로 인해 이진 데이터로 반환된 응답을 받는 경우가 많습니다.\n\n![image](/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png)\n\n# NodeJS의 버퍼 클래스\n\nNodeJS에 독점적인 전역 API 중 하나인 버퍼 클래스는 보내거나 받는 이진 데이터를 처리하는 편리한 수단으로 사용됩니다. 예를 들어, 다음 코드 스니펫은 NodeJS의 버퍼 모듈을 사용하여 문자열을 ArrayBuffer로 변환하거나 그 반대로 변환하는 방법을 보여줍니다:\n\n\n\n```js\nconst str = 'Hey. this is a string!';\n\nconst buffer = Buffer.from(str, 'utf-8'); // 형식: ArrayBuffer\nconst b64Str = Buffer.from(str, 'utf-8').toString('base64');\nconsole.log(b64Str);\n/* 예상 결과: */\n// SGV5LiB0aGlzIGlzIGEgc3RyaW5nIQ==\n\nconst originalStr = Buffer.from(b64Str, 'base64').toString('utf-8');\nconsole.log(originalStr);\n/* 예상 결과: */\n// Hey. this is a string!\n```\n\n## 클라이언트 측 브라우저 환경\n\n- btoa()는 Base64로 인코딩된 문자열을 읽고 출력합니다.\n- atob()은 Base64 문자열의 디코딩에 사용됩니다.\n\nNodeJS의 Buffer 모듈은 기본적으로 UTF-8 인코딩 체계를 사용하는 반면, btoa()와 atob()은 유니코드 텍스트와 같은 비 ASCII 문자를 해석할 수 없어 에러를 발생시킵니다.\n\n\n\n```js\ntry {\n  btoa('ヾξ⸨🎀˶❛ヮ❛⸩ﾉ ᵀᴴᴱ ᴿᴵᴮᴮᴼᴺ ᴳᴵᴿᴸ'); // 유니코드 문자만\n} catch(err) {\n  console.error(err);\n}\n// 콘솔 출력:\n/* InvalidCharacterError: Failed to execute 'btoa' on 'Window': The */\n/* string to be encoded contains characters outside of the Latin1 range. */\n```\n\n그러므로 데이터를 이진 데이터 형식으로 변환하는 경우 — 즉, Data URL 및 ArrayBuffer로 변환하기 위해 사전에 UTF-8로 문자열을 바이트 시퀀스로 변환한 후 이 바이트 시퀀스를 Base64 문자열로 인코딩해야 합니다.\n\n# 구현 세부 사항\n\n여기 클라이언트 측 JavaScript를 사용하여 \"유니코드 문제\"를 해결하기 위한 2가지 가능한 방법이 있습니다. 양 구현 모두 아래의 헬퍼 함수 convertBitArrtoB64 및 convertB64ToBitArr가 포함되어야 한다는 점을 유의하십시오:\n\n\n\n```js\n// Uint8Array를 Base64 문자열로 변환하는 함수\nconst convertBitArrtoB64 = (bitArr) => ( btoa( bitArr.reduce((data, byte) => data + String.fromCharCode(byte), '') ) );\n\n// Base64 문자열을 Uint8Array로 변환하는 함수\nconst convertB64ToBitArr = (b64Str) => ( Uint8Array.from(atob( (b64Str.includes(';base64,') ? (b64Str.split(','))[1] : b64Str) ), (v) => v.charCodeAt(0)) );\n```\n\n## (1) TextEncoder & TextDecoder\n\nUTF-8 문자열 인코딩은 네이티브 브라우저에서 TextEncoder 인터페이스(반대 방향으로는 TextDecoder)로 처리할 수 있습니다:\n\n- 문자열을 ArrayBuffer 및 Base64로 인코딩된 데이터 URL로 변환하기\n\n\n\n\n```js\nconst inputStr = '히카리 미나미';\n\n// 문자열을 Uint8Array로 출력하는 인자를 사용하는 함수\nconst bitArr = (utf8Str) => (new TextEncoder().encode(utf8Str));\n\nconst uInt8Arr = bitArr(inputStr);\nconsole.log(uInt8Arr);\n// 예상 결과:\n// 236,150,136,237,132,132,235,170,164,237,157,144,32,236,130,183,235,143,138\n\nconst buffer = uInt8Arr.buffer; \nconsole.log(buffer); \n// 예상 결과:\n// 바이트 길이가 21인 ArrayBuffer 출력\n\nconst b64Str = convertBitArrtoB64( bitArr(inputStr) );\nconsole.log(b64Str);\n// 예상 결과:\n// 7ZWw7ISw7Iqk7YOJIDA=\n```\n\n- 원래 입력된 텍스트로의 역 변환\n\n```js\n// Uint8Array를 사용하는 인자를 문자열로 출력하는 함수\nconst utf8Str = (bitArr) => (new TextDecoder().decode(bitArr.buffer));\n\nconst originalStr = utf8Str(convertB64ToBitArr(b64Str));\nconsole.log(originalStr);\n// 예상 결과:\n// 히카리 미나미\n```\n\n## (2) unescape + encodeURIComponent 및 decodeURIComponent + escape\n\n\n\n\n그러나 대안으로 UTF-8 인코더를 구현하는 JavaScript를 사용할 수도 있습니다. 이를 위해 브라우저 글로벌 객체인 unescape + encodeURIComponent (그리고 반대 방향으로는 decodeURIComponent + escape)를 사용할 수 있습니다:\n\n- 문자열을 ArrayBuffer와 Base64로 인코딩된 데이터 URL로 변환\n\n```js\nconst inputStr = 'ヾξ⸨🎀˶❛ヮ❛⸩ﾉ ᵀᴴᴱ ᴿᴵᴮᴮᴼᴺ ᴳᴵᴿᴸ';\n\n// 문자열을 받아 Base64 문자열을 출력하는 함수\nconst utf8_to_b64 = (str) => (btoa(unescape(encodeURIComponent(str))));\n\nconst b64Str = utf8_to_b64(inputStr);\nconsole.log(b64Str);\n// 예상 결과:\n// 44O+zr7iuKjwn46Ay7binZvjg67inZviuKnvvokg4bWA4bS04bSxIOG0v+G0teG0ruG0ruG0vOG0uiDhtLPhtLXhtL/htLg=\n\nconst uInt8Arr = convertB64ToBitArr(utf8_to_b64(inputStr));\nconsole.log(uInt8Arr);\n// 예상 결과:\n// 227,131,190,206,190,226,184,168,240,159,142,128,203,182,226,157,155,227,131,174,226,157,155,226,184,169,239,190,137,32,225,181,128,225,180,180,225,180,177,32,225,180,191,225,180,181,225,180,174,225,180,174,225,180,188,225,180,186,32,225,180,179,225,180,181,225,180,191,225,180,184\n\nconst buffer = uInt8Arr.buffer; \nconsole.log(buffer); \n// 예상 결과:\n// 71바이트 길이의 ArrayBuffer를 출력함\n```\n\n- 원래 입력 텍스트로의 역변환\n\n\n\n```js\n// Base64로 인코딩된 데이터 URL을 받아 String을 출력하는 함수입니다.\nconst b64_to_utf8 = (str) => (decodeURIComponent(escape(atob(str)));\n\nconst originalStr = b64_to_utf8(b64Str);\n// 예상 결과:\n// ヾξ⸨🎀˶❛ヮ❛⸩ﾉ ᵀᴴᴱ ᴿᴵᴮᴮᴼᴺ ᴳᴵᴿᴸ\n```\n\n# 실시간 데모\n\n## ASCII 문자만 사용\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*FHtRkS1iUjaSCPGv6Pz0-A.gif\" />\n\n\n\n\n## 유니코드 문자만\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*kwj-q8KMkj_nQcqWhliUBw.gif)\n\nconvert-to-buffer에서 직접 시도해보세요!\n\n여기까지 읽어주셔서 정말 감사합니다! ❤ 이 구현이 유용했기를 바라며, 더 많은 GIS, 데이터 분석 및 웹 응용 프로그램 관련 콘텐츠를 원하시면 Medium에서 제 팔로우를 해주세요. 정말로 감사하겠습니다 — 😀\n\n\n\n— 🌮 타코 한 개 사주세요 ξ(🎀˶❛◡❛)\n\n## 다른 웹 관련 콘텐츨 후보:\n\n# PlainEnglish.io 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 저자에 대한 박수 및 팔로우 부탁드려요️\n- In Plain English에 글을 쓸 수 있는 방법을 배워보세요️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture","ogImage":{"url":"/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png","tag":["Tech"],"readingTime":5},{"title":"믿거나 말거나, 우리에게 또 다른 할 일 앱이 필요합니다","description":"","date":"2024-05-14 13:50","slug":"2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp","content":"\n\n## 네, 이미 수백만 개 이상 구현된 것이 있음에도 불구하고...\n\n그 중에 하나가 있어요:\n\n- 찾을 수가 없어요.\n- 정말 필요해요.\n\n그래서, 제가 직접 만들기로 결정했어요. 생산성 앱으로 넘쳐나는 세상에서 새 할일 목록을 소개하는 아이디어는 중복되었거나 아주 불필요한 것처럼 보일 수 있어요. 이미 잘 밟힌 길을 왜 가야 할까요?\n\n\n\n그럼에도 불구하고, 내 목표는 초보 개발자의 작은 프로젝트에 흔히 볼 수 있는 애플리케이션 개념의 성공을 단순히 희망하는 데 그치지 않습니다. 저는 실제로 더 집중할 만한 몇 가지 사안이 있는데, 이에 대해 뒤에 자세히 논의할 것입니다. 이 애플리케이션의 아이디어에서부터 시작해보죠. 인기 있는 책에서 영감을 받았습니다.\n\n# 할 일 목록이란?\n\n팀 페리스(Tim Ferriss)의 책 '4시간 근무주'에 대해 들어봤을지도 모릅니다. 개인적으로 매우 유용하다고 생각하며 유용한 팁과 기교가 많이 있습니다. 그 중 하나를 사용해 보고 굉장히 강력한 도구라고 판단했습니다. 간단히 설명하자면, 그것은 플래너입니다. 하지만 처음에 상상할 것과 다른 플래너입니다. 오히려 그것을 도구라고 하거나, 단지 삶을 현재의 상태에서 기대되는 상태로 바꾸기 위한 프레임워크라고 할 것입니다. 일반적으로 그것이 플래너의 목표겠죠? 그렇다고 볼 수도 있겠지만, 저는 이것이 제가 알고 있는 다른 것보다 훨씬 잘 작동한다고 생각합니다. 한 번 해봤고 결과에 만족했습니다. 그래서 다시 해보고 싶습니다. 이번에는 종이가 아닌 앱을 사용하려고 합니다. 계획의 디지털 버전을 사용하면 다양한 일을 할 수 있습니다... 적어도 언제든지 출력하여 종이 버전을 얻을 수 있습니다! 농담은 놓고 — 정확히 어떻게 보일지와 어떤 기능이 최종적으로 포함될지 아직 모르겠지만, 디지턼 버전으로부터 혜택을 얻을 수 있는 여러 방법이 있는데요:\n\n- 접근성과 휴대성: 디지털 정보도 분실될 수 있습니다. 다만, 전반적으로 디지털 자산을 보관하는 것이 훨씬 쉽습니다.\n- 동기화와 백업: 처음 버전에는 포함되지 않을 것인데 필요할 때 실행할 수 있는 기회가 있습니다.\n- 업데이트와 편집: 거의 깜빡했네요! 종이에서는 어떻게 편집하시나요?\n- 데이터 분석과 통찰: 이것은 명백히 애플리케이션의 일부여야 합니다. 최소한 진행 상황의 시각화가 필수적인 것으로 보입니다.\n- 멀티미디어 통합: 진부해 보일지 모르지만 중요하지 않다는 뜻은 아닙니다. 종이 버전에 외부 자원에 대한 링크를 추가할 수는 없겠지요.\n\n\n\n## 그리고 훨씬 많은 것이 있어요! 사실 세계에 직접적으로 속하지 않아요 — 우리의 상상력으로 제한돼요.\n\n## 계획자.\n\n알았어요, 그러니까 우리가 어플리케이션이 가치를 가져다준다고 합의했으니, 이 책에서 계획자가 어떻게 정의되었는지 살펴보고 그 요소들을 세분화해보겠습니다.\n\n![이미지](/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png)\n\n\n\n제가 두 가지 주요 부분으로 나누어서 설명해 드릴게요. 먼저 목표를 정의하는 단계와 관련된 7단계를 포함한 부분이고 두 번째로는 그 목표를 이루기 위해 필요한 작업 목록을 설정하는 부분입니다.\n\n기본적으로 먼저, 원하는 것, 되고 싶은 사람, 하고 싶은 일을 정의한 뒤, 그것을 이루기 위한 시간이나 돈을 투자하는 비용을 확인해야 해요:\n\n![이미지](/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_1.png)\n\n두 번째로, 이루어져야 하는 구체적인 작업 목록이에요:\n\n\n\n<img src=\"/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_2.png\" />\n\n실생활 예시로 가볍게 한 번 생각해보자. 나만의 자동차로 전국을 여행하는 꿈이 있다고 상상해봐. 그런데 당장은 운전 면허나 자동차 둘 다 없군. 정말 큰 프로젝트 같지만 그래도 6개월 안에 완성할 수 있는 것이야.\n이번에 우리가 할 일을 표로 나눠서 좀 더 구체화해보자.\n\n## 단계 1: 소유\n\n당연하게도, 자동차와 운전 면허가 필요하겠지? 이 두 가지를 목록에 추가해보자:\n- 자동차\n- 운전 면허\n\n\n\n## 단계 5: 비용\n\n앗, 단계 번호가 혼란스러울 수 있어요. 방금 전에는 1단계에 있었는데, 이제는 5단계에요. 아마도 우리 애플리케이션에서는 이제 이런 단계들의 번호를 숫자 색인으로 사용하지 않을 거예요.\n\n그래서, 제가 전문가는 아니지만 이 차가 당신에게 처음으로 소개되는 차일 거예요. 그렇기 때문에 너무 걱정할 필요는 없지만 너무 오래된 차도 아니어야 해요. 10~15년 된 일본 제조 차량이 좋은 후보라고 생각해요. 상태가 괜찮은 차를 구입하기 위해 약 10,000 달러를 준비해야 할 거예요.\n또한 운전 면허를 취득하는 데 일부 비용이 들어요. 당신이 사는 나라에 따라 비용이 다르겠지만, 여기서는 평균적으로 약 500달러를 사용해볼게요.\n\n그럼 이 두 가지를 추가해볼게요:\n- 오래되지 않은 차: 10,000 달러\n- 운전 면허: 500 달러\n\n\n\n월 1,750달러를 모아야 한다는 것은 꽤 많은 금액입니다. 그러나 특정한 경우에는 이미 약간의 저축이 있을 수도 있고, 더 싼 차를 사기 위해 노력하고 있을 수도 있습니다.\n\n## 지금 취해야 할 단계\n\n글을 쓰고 나서 곧바로 할 수 있는 일들입니다. 다음 주 월요일이나 아침까지 기다릴 필요는 없습니다. 지금 바로 시작하세요.\n예를 들어:\n— 운전 규칙 배우기\n— 자산 계산하기\n— 저축 계획 수립하기\n— 줄일 수 있는 지출 결정하기\n\n## 내일\n\n\n\n\"내일\"을 정확히 의미하지는 않습니다. 대신 이것은 막힘이 있는 작업이며 다른 일을 완료하거나 일어난 후에만 할 수 있습니다. 이전 목록의 작업이 완료되기를 기다릴 수도 있습니다:\n\n- 운전 이론 시험 통과\n- 운전 교육사 찾기\n- 저축 계획을 평가하고 필요하다면 조정하기\n\n## 이후\n\n다시 말해, \"내일\"을 문자 그대로 받아들여서는 안 된다고 생각합니다. 이것은 직접적으로 당신의 주요 목표로 이어지는 마지막 작업이며 이전 목록을 해결함으로써 막힘이 해제됩니다:\n\n- 운전 시험을 통과하고 면허증을 받기\n- 지역 중고차 시장 분석\n- 저축 계좌에서 돈 인출\n- 중고차 판매자와 몇 가지 약속하기\n- 자동차 구매\n- 여행을 떠나세요!\n\n\n\n그거거든요, 거의 다 됐어요. 지금까지 받은 것으로 이미 유용한 계획을 가지고 있지만, 우리가 아직 STEP 2: BEING과 STEP 3: DOING에 손을 대지 않았어요. 작가나 음악가가 되고 싶을 수도 있고, 직업을 바꾸고 싶을 수도 있어요. 체육관에 가거나 마라톤을 뛰기 시작해도 좋아요. 무엇이든 좋아요—써 내려보고, 그것을 이룰 방법을 생각하고 계획을 세워보세요.\n\n이것은 일반적인 꿈과 아이디어를 구체적인 것들로 분해하고 그것들을 이루기 위한 계획을 세우는 강력한 도구에요. 그리고 한번 이걸 마치면 두 가지 중요한 지점으로 이끌어줘요:\n1. 목표를 이루기 위해 정확히 무엇이 필요한지 생각해보기.\n2. 실제로 그것에 얼마나 많은 자원이 필요한지 이해하기.\n\n첫 번째 지점이 매우 명백하고, 우리는 이미 이에 대해 지나왔기 때문에—두 번째 지점의 중요성은 몇 가지 설명이 필요할 수도 있어요. 저자는 일주일에 너무 많은 시간을 일하게 되어 결국 필요한 것보다 더 많이 벌게 되지만, 이른 퇴직을 위한 충분한 금액은 아니라는 사례를 제시해요. 이렇게 하다 보면 돈을 벌기 위해 시간을 소비하는데 있어서 차이를 만들지 못하게 되죠. 자신의 기회를 가로채지 말고 레버리지를 만들고 더 많이 벌게 되는 걸 시작해보세요. 적어도 기쁨을 주는 일을 하세요.\n\n제가 다른 경우를 상상해볼 수도 있는데, 소득이 좋아서 부채들—차 대출, 주택 대출, 할부 등 때문에 여유 자금이 없는 경우가 있을 수 있어요. 정확히 무엇이 필요한지 판단하고 그 외의 것들을 모두 끊어내면—청구서를 지불하기 위해 쓰는 시간을 줄이고 미래를 위해 투자할 수 있는 시간을 늘릴 수도 있어요.\n\n\n\n# 앱이 무엇인가요?\n\n내 계획은 브라우저 전용 앱으로 만들어서 모든 \"단계\"와 \"동작\"을 채울 수 있는 것이다. 완료된 항목을 확인하고 새 항목을 추가하는 등 할 일 앱의 일반적인 기능 세트가 포함되어 있습니다. 총 비용 및 월 단위 비용의 기본적인 계산, 남은 시간 및 완료 여부를 나타내는 진행률 표시 막대도 포함됩니다.\n\n목표는 가능한 한 적은 기능을 가지고 있으면서도 완전한 제품이라고 부를 수 있을 정도로 충분히 많은 것을 갖추는 것입니다.\n\n하지만 알고 있는 바로는 — 인기/성공이 된다는 가능성은 무의미하다고 생각합니다. 복권에 당첨될 확률 정도나 비슷한 수준이라고 말씀 드릴 것입니다. 그러나 복권은 비교적 아무것도 들지 않는 대가로 구매할 수 있지만, 애플리케이션을 만들기에는 시간을 많이 투자해야 하는 도전적인 작업입니다. 그것이 무슨 일이 좀 괴물스러운 것 같다고 생각합니다. 그래서 내가 좀 더 일반적인 애플리케이션의 성공 여부와 관계없이 유익한 다른 목표가 필요합니다. 그리고 적어도 두 가지 목표가 이미 떠오르고 있습니다.\n\n\n\n## 1. 가능한 한 간단한 방법을 찾아보세요.\n\n낚시 끈과 고무줄을 사용하여 슬링샷을 만들어보세요. 그것은 가능한 한 적은 양의 기능/기술을 적절하게 조합하여, 최종 제품으로 잠재적 사용자에게 독특하고 (적어도 어느 정도는) 유용한 경험을 제공할 수 있도록 하는 것이 목표임을 강조하고 싶습니다. 서버 없이, 데이터베이스 없이, 인증 없이 등을 염두에 두세요. 브라우저에서 시작부터 끝까지 실행되는 순수한 JavaScript 앱이 될 것입니다. 데이터는 탭 간에 영속적이며 사용자가 브라우저를 닫고 다시 열어도 유지될 것이지만, 다른 기기에서는 사용할 수 없을 것입니다. 이것은 흠이 될 수 있지만, 사용자가 제공하는 민감한 데이터의 보안을 보장하기 때문에 동시에 이점이 될 수 있습니다. 사용자 브라우저의 벽 밖으로는 결코 나가지 않습니다. 그래서 이것은 제 생각에 꽤 유익한 대가제이며, 이 경우에는 개발 노력이 필요하지 않습니다.\n그게 다에요. 한 번의 네트워크 요청도 없죠... 호스팅에서 앱을 다운로드하기 위해 한 번 제외하고 말이에요. 첫 번째 버전에서는 반드시 적절한 데이터베이스와 인증이 삽입될 수도 있지만, 결코 중요하지는 않아요.\n\n## 2. 과정을 기록하세요.\n\n이것도 중요한 사항입니다. 저는 이미 10년 이상 업계에서 다양한 프로젝트를 맡아왔습니다. 내가 말해도 믿지 못할 정도로 나쁜 과정과 매우 좋고 수월한 과정들을 목격했어요. 그것들이 완벽하지는 않지만 더 나은 방법을 상상할 수 없을 만큼 좋았죠. 그러나 무언가를 한 곳에서 가져와 다른 곳에 적용하면 대부분 실패할 가능성이 높을 것입니다. 각 사례는 가능한 모든 방법에서 독특할 수 있으며, 그것들을 구축하기 위해서는 기술을 배워야 합니다. 좋은 장인은 장차 나올 제품에 어울리는 것이 아니라, 잘하는 도구가 아닌 제품에 맞는 도구를 사용한다는 것을 유념해야 합니다.\n그래서 개발 과정에서 마주하는 도전들을 기록하고, 어떤 관행이 잘 작동했고 어떤 것이 그렇지 않았는지 이유를 적어나갈 것입니다. 최종적으로 이는 시리즈로 이어지는 기사 집필이 되어야 할 것입니다.\n\n\n\n# 팀\n\n물론, 모든 것을 혼자서 하지는 않을 거에요. 프로젝트를 함께 진행할 친구가 있습니다. 그는 초보 개발자이지만 JavaScript와 ReactJS에 대한 지식이 있어서, 약간의 도움과 멘토링으로 일을 처리할 만하다고 믿어요.  \n나는 코딩을 최대한 멀리하려고 노력할 거에요. 그러다가 그가 곤경에 처했을 때나 전략적 결정을 내려야 할 때만 개입할 거에요.\n\n# 결론\n\n이 여정은 시작에 불과하고, 목적지는 불확실하지만, 우리가 그리고 있는 길은 학습과 혁신의 가능성으로 가득합니다. 여러분을 이 모험에 초대합니다. 피드백을 제공하거나 기능을 제안하거나, 그냥 우리의 진행상황을 따라오는 것까지. 함께 무엇을 만들 수 있는지 탐험해봐요.","ogImage":{"url":"/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png"},"coverImage":"/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png","tag":["Tech"],"readingTime":6},{"title":"Nextjs는 프론트엔드 또는 백엔드 프레임워크일까요","description":"","date":"2024-05-14 13:48","slug":"2024-05-14-IsNextjsaFrontendorBackendFramework","content":"\n\n<img src=\"/assets/img/2024-05-14-IsNextjsaFrontendorBackendFramework_0.png\" />\n\n# 소개\n\nNext.js는 웹 개발 세계에서 강력하고 다재다능한 도구로 떠오르고 있습니다. 개발자들이 그 능력을 탐구할 때 일반적인 질문이 제기됩니다: Next.js는 프론트엔드인가 백엔드 프레임워크인가? 이 글에서는 Next.js의 특성을 살펴보고 프론트엔드와 백엔드 개발과 일치하는 부분을 살펴보며, 그 이중적인 성격과 실제 적용 사례를 탐구할 것입니다.\n\n# 🚀 ShipFast: SaaS, AI 또는 웹 앱용 Next.js 보일러플레이트. $100 할인, 남은 자리는 13개뿐! ⏰\n\n\n\n# 프론트엔드 프레임워크 특징\n\n프론트엔드 프레임워크는 사용자 인터페이스를 구축하고 클라이언트 측 로직을 관리하는 데 중요합니다. React를 기반으로 구축된 Next.js는 프론트엔드 개발에 적합한 기능을 갖추고 있습니다:\n\n- React 기반 아키텍처: Next.js는 React를 기반으로 구성되어 있어, 개발자들이 쉽게 상호작용적이고 동적인 사용자 인터페이스를 만들 수 있습니다.\n- 클라이언트 측 렌더링 (CSR): CSR을 활용하여 Next.js는 브라우저가 렌더링을 처리하도록 하여 초기 페이지 로드 속도를 높이고 더 빠른 사용자 경험을 제공합니다.\n- 라우팅 기능: Next.js는 내장된 라우팅 시스템을 통해 애플리케이션 내에서의 탐색을 단순화시켜 프론트엔드 개발에 적합합니다.\n\n# 백엔드 프레임워크 특징\n\n\n\n백엔드 프레임워크는 서버 측 로직, 데이터 처리 및 서버 관리를 다루는 반면, Next.js는 프론트엔드와 백엔드 간의 경계를 희미하게 만드는 특징을 나타냅니다:\n\n- 서버 측 렌더링 (SSR): SSR을 통해 Next.js는 서버 측에서 HTML을 생성하여 성능과 검색 엔진 최적화를 향상시킵니다.\n- API 라우트 및 서버리스 함수: Next.js는 API 라우트와 서버리스 함수를 생성할 수 있어 개발자가 프론트엔드 코드베이스 내에서 강력한 백엔드 기능을 구축할 수 있도록 합니다.\n- 데이터 가져오기와 미들웨어 사용: 이 프레임워크는 효율적인 데이터 가져오기를 용이하게 만들어 서버 측 로직과 미들웨어를 관리하는 데 적합합니다.\n\n# Next.js의 이중적 성격\n\nNext.js는 프론트엔드와 백엔드 기능을 부드럽게 결합하는 것으로 두드러집니다. 전통적인 프론트엔드와 백엔드 간의 구분이 덜 명확해지는 상황에서 이중적 성격이 드러납니다. 예를 들어, Next.js 애플리케이션은 외부 API에서 데이터를 가져오는 독립적인 프론트엔드 역할을 하거나 서버 측 렌더링과 백엔드 로직을 갖춘 풀 스택 애플리케이션으로 작동할 수 있습니다.\n\n\n\n# 사용 사례\n\nNext.js는 다양한 사용 사례에서 응용 프로그램을 찾을 수 있습니다:\n\n- 프런트엔드 강조: 동적이고 클라이언트 측 상호 작용 및 신속한 사용자 인터페이스 개발을 우선시하는 프로젝트입니다.\n- 백엔드 강조: 서버 측 렌더링, API 개발 및 서버리스 함수를 필요로 하는 프로젝트입니다.\n- 하이브리드 프로젝트: 단일 코드베이스 내에서 프런트엔드 및 백엔드 기능이 원할하게 통합된 응용 프로그램에 이점이 있는 프로젝트입니다.\n\n# 🚀 ShipFast: SaaS, AI 또는 모든 웹 앱을 위한 NextJS 보일러플레이트. 13개 자리 만 움직이세요! ⏰\n\n\n\n# 장단점\n\n## 프런트엔드 관점\n\n장점:\n- 빠른 UI 개발: Next.js는 React를 기반으로하며 React 컴포넌트의 선언적 특성 덕분에 동적 사용자 인터페이스를 신속하고 효율적으로 개발할 수 있습니다.\n- 클라이언트 측 렌더링 (CSR): CSR을 활용하여 Next.js는 초기 페이지 로드 속도를 높이고 렌더링을 클라이언트 측으로 이동하여 더 원활한 사용자 경험을 제공합니다.\n- 컴포넌트 재사용성: Next.js의 모듈식 React 컴포넌트 구조는 쉬운 재사용을 가능케 하며 유지보수가 용이하고 확장 가능한 코드베이스를 촉진합니다.\n- 커뮤니티와 에코시스템: React를 기반으로 한 Next.js는 거대하고 활발한 커뮤니티로부터 다양한 라이브러리, 도구 및 지원을 제공받습니다.\n- SEO 친화적: Next.js는 서버 측 렌더링 (SSR)을 지원하여 사전 렌더링된 HTML 콘텐츠를 검색 엔진 크롤러에 전달함으로써 SEO를 개선합니다.\n\n\n\n단점:\n\n- 서버 측 로직에 대한 초점이 제한적임: Next.js는 서버 측 렌더링이 가능하지만, 주로 프론트엔드 영역에서 빛을 발하며, 백엔드 기능이 특화된 백엔드 프레임워크보다 강력하지 않을 수 있습니다.\n- 부가적인 복잡성 및 오버헤드의 가능성: 서버 측 렌더링이 포함될 경우, 특히 클라이언트 측 렌더링만으로 충분한 프로젝트에서는 추가 복잡성 및 오버헤드가 발생할 수 있습니다.\n- 학습 곡선: React 또는 Next.js에 익숙하지 않은 개발자들은 React의 컴포넌트 기반 아키텍처의 복잡성을 마스터하는 데 학습 곡선이 존재할 수 있습니다.\n- 성능 트레이드오프: 프로젝트 요구 사항에 따라 클라이언트 측 렌더링의 장점이 대규모 데이터 렌더링 시 성능 트레이드오프와 함께 제공될 수 있습니다.\n- 레거시 시스템 호환성: 레거시 시스템과 통합하는 것은 Next.js의 현대적이고 React 중심적인 성격으로 인해 어려울 수 있으며, 매끄러운 호환성을 위해 추가적인 노력이 필요할 수 있습니다.\n\n## 백엔드 관점\n\n장단점:\n\n\n\n- 서버 측 렌더링 (SSR): Next.js는 SSR을 지원하여 서버에서 페이지를 사전 렌더링하여 성능을 향상시키고 더 빠른 로딩 시간과 향상된 SEO를 제공합니다.\n- API 라우트 및 서버리스 함수: Next.js에서 API 라우트와 서버리스 함수를 생성할 수 있는 기능으로 효율적인 백엔드 개발을 가능하게 하여 RESTful API 및 서버 측 로직을 구축하는 데 적합합니다.\n- 미들웨어 사용: Next.js는 개발자가 미들웨어를 구현하여 서버 측 로직 및 사용자 정의 처리에 유연하고 확장 가능한 메커니즘을 제공합니다.\n- 통합 개발: 프론트엔드 및 백엔드 로직을 단일 코드베이스 내에서 원활하게 통합할 수 있는 능력으로 개발을 단순화시켜 별도의 프로젝트를 관리할 필요성을 줄입니다.\n- 데이터 가져오기 기능: Next.js의 효율적인 데이터 가져오기는 최적의 서버 측 성능을 제공하여 개발자가 서버에서 데이터 처리를 관리할 수 있게 합니다.\n\n단점:\n\n- 이중 구조로 인한 복잡성: Next.js의 이중 구조는 풀스택 개발에 유리하지만, 특화된 백엔드 프레임워크에 익숙한 개발자들에게는 추가 복잡성을 도입할 수 있습니다.\n- 코드 중복 가능성: 프론트엔드 및 백엔드 능력을 강조하는 프로젝트에서는 코드 중복이나 모듈화되지 않은 구조의 위험이 있어 유지보수에 영향을 줄 수 있습니다.\n- 자원 소모: 프론트엔드 및 백엔드 기능의 결합은 자원 사용량 증가로 이어지며 서버 성능에 영향을 미칠 수 있어 추가 인프라가 필요할 수 있습니다.\n- 확장성 도전: 프로젝트의 확장 요구에 따라 Next.js의 통합 구조는 프론트엔드 및 백엔드 구성 요소의 최적의 확장성을 달성하는 데 어려움을 겪을 수 있습니다.\n- 의존성 관리: 프론트엔드 및 백엔드 측면의 의존성을 조화시키기 위해 잠재적인 충돌 및 버전 관리 문제를 신중하게 관리해야 할 수도 있습니다.\n\n\n\nNext.js는 전통적인 프론트엔드 및 백엔드 프레임워크 사이의 구분을 초월합니다. React 기반으로 강력한 백엔드 기능을 결합하여 현대 웹 개발에 다재다능한 도구로써 떠오르고 있습니다. 동적 사용자 인터페이스를 개발하거나 견고한 서버 측 로직을 구축하는 데 중점을 둔다 해도, Next.js는 통합된 솔루션을 제공합니다. 프론트엔드와 백엔드 간의 경계가 더 많이 흐려지는 가운데, Next.js의 이중적 성격을 탐구하는 것은 자신의 프로젝트에서 유연성과 효율성을 추구하는 개발자에게 필수적입니다.","ogImage":{"url":"/assets/img/2024-05-14-IsNextjsaFrontendorBackendFramework_0.png"},"coverImage":"/assets/img/2024-05-14-IsNextjsaFrontendorBackendFramework_0.png","tag":["Tech"],"readingTime":4},{"title":"타입 생성 비밀 탐구 in TypeScript","description":"","date":"2024-05-14 13:47","slug":"2024-05-14-SecretsofTypeGenerationinTypeScript","content":"\n\n한 번 TypeScript 모임에서 발표하기 위해 나라의 절반을 여행했던 적이 있어요. 제 발표를 진행한 후에는 청중들이 흥미로워 한 것 같았는데, 다른 연사가 나타났어요. 그는 매우 사소하지만 중요한 주제에 대해 이야기했어요. TypeScript에서 데이터 유효성 검사에 대해 논의했죠.\n\n![이미지](/assets/img/2024-05-14-SecretsofTypeGenerationinTypeScript_0.png)\n\n저는 자바 개발자로 경력을 시작했는데, 당연히 일상 업무에서 다양한 유효성 검사 라이브러리를 활용했어요.\n\nTypeScript 코딩을 시작하자, 유사한 도구 세트가 쉽게 사용 가능하지 않다는 것을 깨달았어요! JavaScript 커뮤니티에서 유효성 검사가 점점 중요해지고 있는 개념인 것 같았어요.\n\n\n\n발표자는 io-ts에 대해 이야기하며 유효성 검사 스키마에서 타입을 쉽게 추론할 수 있다고 설명했습니다. 추론이라는 아이디어가 나를 순간적으로 사로잡았어요. 만약 테이블 스키마와 같은 임의의 객체에서 타입을 생성할 수 있다면 어떨까요?\n\nSequelize, Prisma 또는 Zod와 같은 도구의 구현을 분석하여 타입 추론을 이해하기 위해 노력했습니다. 이 이야기는 제 학습 내용을 요약하며 사용자 정의 스키마를 활용하여 타입을 생성하는 방법을 설명할 것입니다.\n\n# 소개\n\n본 이야기에서, TypeScript에서의 두 가지 유형 생성 범주를 고안했습니다: 정적과 동적. 정적 생성은 코드 생성기를 활용하며 동적 생성은 TypeScript 추론을 활용하여 실시간으로 타입을 제공합니다.\n\n\n\n# 정적 타입 생성\n\n스키마 파일을 기반으로 타입 정의를 생성하는 라이브러리 또는 프레임워크를 찾을 수 있습니다. Prisma가 좋은 예입니다만, Prisma는 타입 뿐만 아니라 클라이언트 코드도 생성합니다.\n\n정적 타입 생성은 세 단계의 프로세스로 생각할 수 있습니다:\n\n- 스키마 파일을 생성(또는 업데이트)합니다.\n- CLI를 사용하여 코드 생성기를 실행합니다.\n- 프로젝트에서 생성된 코드를 사용합니다.\n\n\n\n일반적으로 도구 제작자가 허용하는 어떤 언어로든 스키마 파일을 작성합니다. 그들은 프로그래밍 언어를 사용하는 대신 도메인 특화 언어(DSL)를 선택할 수도 있습니다. 이런 선택은 TypeScript에 익숙하지 않은 사람들도 스키마 파일에 기여할 수 있도록 할 수 있습니다.\n\n예를 들어, Prisma의 제작자들은 데이터 모델링 언어를 개발했습니다. 아래에 전형적인 스니펫을 보실 수 있습니다.\n\n```js\ngenerator client {\n  provider = \"prisma-client-js\"\n  output   = \"./client\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id String @unique\n}\n```\n\n이 스니펫은 코드 생성 및 모델 자체에 대한 지시사항을 모두 포함하고 있다는 점을 언급할 가치가 있다고 생각합니다!\n\n\n\n다음 명령어를 실행하여 TypeScript 코드를 생성할 수 있어요.\n\n```js\npnpm exec prisma generate\n```\n\nPrisma는 스키마 파일이 가리키는 디렉토리에 코드를 생성합니다. 아래에 생성된 코드의 사용 예시를 확인해보세요.\n\n```js\nimport { randomBytes } from \"node:crypto\";\nimport { PrismaClient } from \"./prisma/client\";\n\nconst createUser = async () => {\n  const prisma = new PrismaClient();\n  try {\n    const id = randomBytes(16).toString(\"base64url\");\n\n    return await prisma.user.create({\n      data: {\n        id,\n      },\n    });\n  } finally {\n    await prisma.$disconnect();\n  }\n}\n```\n\n\n\n데이터베이스 스키마 설계에 대해 궁금하다면, 아래 이야기를 읽어보세요:\n\n## 정적 타입 생성의 장점\n\n정적 타입 생성을 통해 비즈니스 로직 구조와 TypeScript를 분리할 수 있습니다.\n\n이를 통해 비개발자들이 독립적으로 스키마 파일에 기여할 수 있습니다. 비기술자에게 코딩 원리를 가르치는 대신, 도메인 특화 언어 개념을 빠르게 설명할 수 있습니다!\n\n\n\n또한, 사람들은 스키마 파일을 특정 디렉토리에 특정 확장자로 저장합니다. 코드베이스 전체를 찾는 대신에 효율적으로 찾을 수 있도록 도와줄 수 있습니다.\n\n마지막으로, 저는 TypeScript 추론이 강력하지만 일부 응용 프로그램에서는 제약이 있음을 발견했습니다. TypeScript가 개발하기 어려워지지 않도록 추론을 제한해야 한다고 생각합니다.\n\n제가 TypeScript 추론의 불가피한 한계에 대해 사례 연구를 진행했고, 아래에서 읽을 수 있습니다:\n\n## 정적 타입 생성의 단점\n\n\n\n지금까지 도메인 특화 언어를 사용하여 코드와 유형을 생성하는 방법에 대해 설명했습니다. 흥미롭게도 TypeScript 파일을 기반으로 코드를 생성할 수도 있습니다.\n\n프로젝트 내 각 파일에 대해 특정 디렉토리 구조 및 특정 이름으로 내보내기를 강제하기를 원할 수 있습니다. 예를 들어, 데이터베이스 모델을 모델 디렉토리에 각 파일로 구성하고, 파일 이름에 모델 이름을 포함할 수 있습니다. 각 파일은 스키마 이름 아래 모델 스키마를 내보내야 합니다.\n\n생성기를 구현하여 적절한 유형 규율을 달성할 수 있습니다. 이 생성기는 폴더 구조를 읽고 유형 정의를 작성합니다. 모델을 생성한 후에는 생성기를 실행해야 합니다.\n\n이러한 접근 방식은 지속적인 유형 차이로 이어질 수 있습니다. 모델을 변경하면 기존 유형 정의에 반영되지 않는 변경 사항을 도입할 수 있습니다. 파일을 유효성 검사하려면 TypeScript 오류가 없을 때까지 생성기를 계속 실행해야 합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-SecretsofTypeGenerationinTypeScript_1.png)\n\n두번째, 스키마에 대한 모든 변경 사항은 이후에 명령을 실행해야 하며, 이 단계는 경험이 부족한 엔지니어들에게 쉽게 간과될 수 있습니다.\n\n세번째, TypeScript에는 인상적인 타입 추론이 포함되어 있기 때문에, 처음부터 정적으로 타입을 생성해야 하는 이유가 있을까요? 제 생각에는 그에 대한 좋은 이유가 필요합니다.\n\n네번째, 생성된 타입을 소스 제어에 커밋해야 할까요? 아마도 생성되는 것이 정확히 무엇인지에 따라 다를 것입니다.\n\n\n\n# 동적 유형 생성\n\n여기 예제를 통해 동적 유형 생성을 보여 드리겠습니다.\n\n누군가가 TypeScript에서 새로운 ORM 생성을 맡겨줬다고 상상해 봅시다. 우리는 먼저 SQL 데이터 유형을 위한 추상화를 생성하는 것으로 시작할 것입니다. 먼저, 행에서 nullable 값을 허용하거나 허용하지 않을 수 있는 열을 인식합니다.\n\nNullable 및 non-nullable 열 사이의 구분을 만들기 위해 고유한 심볼을 사용할 수 있습니다.\n\n\n\n```js\nexport const NULL: unique symbol = Symbol();\nexport const NOT_NULL: unique symbol = Symbol();\n```\n\n저는 심볼을 실수로 선택한 것이 아닙니다. 이제 첫 번째 유형을 설명하겠습니다.\n\n특정 데이터 유형 내에 정의된 널 가능성 일반 유형을 앵커하는 TNULLABLE 유형을 정의하겠습니다.\n\n```js\ntype TNULLABLE = typeof NULL | typeof NOT_NULL;\n```\n\n\n\n다시 말해, 단순히 true 또는 false로 nullability를 제어해서는 안 됩니다. NULL 및 NOT_NULL 기호에 바인딩된 일반 타입 내에 nullability를 포함시킬 것입니다.\n\nTCHAR 타입 정의를 살펴봅시다.\n\n```js\ntype TCHAR<N extends TNULLABLE, L extends number> = Readonly<{\n  type: \"char\";\n  length: L;\n  nullable: N;\n}>;\n```\n\n이 정의에서 N은 nullability를 관리하고, L은 SQL CHAR 열의 길이를 설정합니다.\n\n\n\n다음으로 CHAR 컬럼을 위한 빌더를 생성합니다. 클래스 생성자가 아니기 때문에 '빌더'라는 용어를 사용했습니다.\n\n```js\nconst CHAR = <N extends TNULLABLE, L extends number>(\n  nullable: N,\n  length: L\n): TCHAR<N, L> => ({\n  type: \"char\",\n  length,\n  nullable,\n});\n```\n\nCHAR(false, 255) 대신 CHAR(NULL, 255)로 작성할 수 있습니다. 전후 문맥을 알지 못해도 이전 표현식을 쉽게 이해할 수 있습니다.\n\n이제 SQL INTEGER 컬럼에 대해 비슷한 내용을 작성합니다.\n\n\n\n```js\ntype TINTEGER<N extends TNULLABLE> = Readonly<{\n  type: \"integer\";\n  nullable: N;\n}>;\n\nconst INTEGER = <N extends TNULLABLE>(nullable: N): TINTEGER<N> => ({\n  type: \"integer\",\n  nullable,\n});\n```\n\n이제 스키마 유형을 정의하는 시간이 왔습니다. 키-값 쌍으로 구성된 객체로 생각할 수 있습니다. 키는 열 이름을 나타내고 값은 해당 열 정의를 제공합니다. 아래 예제를 살펴보세요.\n\n```js\nexport type Schema = Readonly<{\n  [K in string]?: TCHAR<TNULLABLE, number> | TINTEGER<TNULLABLE>;\n}>;\n```\n\n스키마 유형을 정의한 후에는 예제를 진행할 수 있습니다. 다음 스니펫을 만들었습니다.\n\n\n\n```js\n상수 스키마 = {\n  a: CHAR(NULL, 255),\n  b: CHAR(NOT_NULL, 1),\n  c: INTEGER(NULL),\n  d: INTEGER(NOT_NULL),\n}을(를) 스키마로써 만족합니다;\n```\n\n저는 \"만족합니다\" 키워드를 의도적으로 사용했습니다. 스키마를 Schema 유형에 할당하고 싶지 않았기 때문에 추론에 부정적인 영향을 미치지 않을 수 있습니다! 대신, 스키마 정의가 Schema 유형을 만족하는지 확인할 수 있습니다.\n\n이제 가장 흥미로운 부분인 추론이 시작됩니다!\n\n아래에 두 가지 도우미 유형을 정의해보겠습니다.\n\n\n\n```js\n유형 NullableString<N> = N이 typeof NOT_NULL인 경우\n  ? string\n  : string | null;\n\n유형 NullableNumber<N> = N이 typeof NOT_NULL인 경우\n  ? number\n  : number | null;\n```\n\n이 범용 유형은 널 가능성을 켜고 끄는 데 사용됩니다. 이런 도우미들은 TypeScript에서 유형 생성 시 흔한 속임수로 생각합니다.\n\n이제 추론에 사용되는 유형을 최종적으로 정의할 수 있습니다.\n\n```js\n유형 Attributes<T> = {\n  [K in keyof T]: T[K]이 TCHAR<infer N, number>의 확장인 경우\n    ? NullableString<N>\n    : T[K]이 TINTEGER<infer N>의 확장인 경우\n    ? NullableNumber<N>\n    : never;\n};\n```\n\n\n\n천천히 설명해 드릴게요.\n\n먼저, 일반 타입은 스키마 타입입니다.\n\n둘째, 값만 변환합니다. 키는 그대로 유지됩니다.\n\n셋째, 값이 TCHAR 타입이면 널 가능성 일반 타입 N을 추론하고 NullableString 도우미 타입으로 전달합니다.\n\n\n\n우리는 N에 따라 문자열 또는 null을 반환할 것입니다.\n\nTINTEGER 유형에 대해서도 비슷한 작업을 수행합니다. 값이 명시적 유형과 일치하지 않는 경우 never 유형을 전달합니다.\n\nAttributes 타입을 다음과 같이 사용할 수 있습니다:\n\n```js\ntype A = Attributes<typeof schema>;\n```\n\n\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해 드리겠습니다:\n\n\n타입 A의 정의는 다음과 같습니다:\n\n```js\ntype A = {\n    a: string | null;\n    b: string;\n    c: number | null;\n    d: number;\n}\n```\n\n## 동적 타입 생성의 장점\n\n나는 TypeScript에서 schema를 유지하는 것이 동적 타입 생성의 자연스러운 장점이라고 생각합니다.\n\n\n\n\n먼저, 스키마를 구현하기 위해 다른 언어를 생각해 낼 필요가 없습니다. 둘째, 스키마에 대한 모든 변경 사항은 프로젝트 전체에 즉시 타입 영향을 줍니다. 셋째, 스키마를 변경한 후에 생성기를 실행할 필요가 없습니다.\n\n## 동적 타입 생성의 단점\n\n이전에 언급했듯이, TypeScript 추론에는 한계가 있습니다. 특정 상황에서 정적 타입 생성으로 전환하면 복잡한 타입 추론 도우미를 만들 필요가 줄어듭니다.\n\n게다가 TypeScript에서 스키마를 유지함으로써 업데이트를 개발자에게 의존해야 합니다. 진행 중인 프로그래밍 언어의 고급 메커니즘을 비 전공자들이 처리할 것을 거의 기대할 수 없습니다.\n\n\n\n# 결론\n\n정적 또는 동적 유형 생성을 선택하기 전에 문제와 모든 가능한 옵션을 고려해야 합니다. 유형 생성이 내 문제를 해결하는 가장 좋은 방법인가요? 더 수고로운 만큼 기술적이지 않은 해결책이 있을까요?\n\n실제로 올바른 선택을 하는 것은 우리 산업에서의 중대한 영향을 미칩니다!\n\n또한 TypeScript의 아키텍트들이 시간이 지남에 따라 유형 추론의 기능을 확대할 것으로 예상됩니다. 저는 지난 6년간 이 언어를 사용해왔는데, 새로운 기능과 개선 사항의 수는 놀라울 정도로 많았습니다!\n\n\n\n이야기가 유형 생성의 모든 주의사항을 이해하는 데 도움이 되었고 유도 추론에 조금 흥미를 느끼게 했다면 좋겠어요.\n\n이 이야기가 흥미로웠다면 아래에서 QR 코드의 실용적 구현에 대한 다른 이야기를 읽어보세요:","ogImage":{"url":"/assets/img/2024-05-14-SecretsofTypeGenerationinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-SecretsofTypeGenerationinTypeScript_0.png","tag":["Tech"],"readingTime":8},{"title":"앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript","description":"","date":"2024-05-14 13:45","slug":"2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript","content":"\n\n<img src=\"/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png\" />\n\n# 아주 간단히 요약하면;\n\n약 1년 전, SvelteKit이 TypeScript에서 JSDoc으로의 전환 결정을 내렸을 때 개발자 커뮤니티에 주목할 만한 변화가 있었습니다. TypeScript는 라이브러리 개발에 이상적인 선택이 아니라고 명시하며 이 전환이 일어났는데, 이로 인해 개발자들 사이에서 논란이 일었습니다. 처음에는 이것이 발전이 아닌 퇴보로 보여 의심스러웠습니다. TypeScript는 심지어 이전 블로그 포스트 중 하나에서 추천하는 도구로 소개되기도 했습니다. 그러나 이 결정은 시간이 흐름에 따라 점차 나에게 와닿게 되었고, 구글 앱스 스크립트에서 유사한 접근 방식을 채택하게 되었습니다. 이 전환의 이유는 여러 가지가 있으며, 일부는 보편적으로 적용되는 이유이며, 다른 일부는 앱스 스크립트의 특이성과 관련된 이유입니다.\n\n여기에 다시 레포 및 NPM 페이지 링크가 있습니다.\n\n\n\n자 TypeScript를 처음 선택했던 이유와 그것보다 JSDoc를 선호하는 이유에 대해 알아봅시다.\n\n# TypeScript를 처음 선택한 이유\n\nTypeScript는 스크립팅 및 앱 개발 분야에서 게임 체인저였습니다. 이는 주로 견고한 타입 안전 기능 때문입니다. TypeScript를 사용하면 명시적으로 선언하거나 지능적으로 추론할 수 있는 정적 타입을 사용할 수 있어 안전하고 견고한 코드를 작성하는 능력을 향상시킵니다. Google Apps Script 개발자에게 TypeScript는 추가적인 이점을 제공합니다; npm i -D @types/google-apps-script 명령어를 사용하여 GAS 타입을 쉽게 설치할 수 있습니다. 이를 통해 이러한 유형을 정의하는 데 필요한 초기 투자 시간에도 불구하고 개발 프로세스 초기에 버그를 조기에 발견하는 데 큰 도움이 됩니다.\n\n또한 TypeScript는 타입에 대한 자동 완성을 제공하여 코드 품질과 유지 보수성을 향상시키고 코딩 프로세스를 가속화하며 오류를 줄입니다. 또한, 네임스페이스와 모듈을 사용할 수 있어 보다 조직적이고 모듈식 코드 구조를 구현할 수 있습니다. 이러한 기능들이 모두 Google Apps Script로 복잡하고 확장 가능한 애플리케이션을 개발하려는 개발자들에게 TypeScript를 매력적인 선택으로 만듭니다.\n\n\n\n# TypeScript의 단점\n\nTypeScript은 많은 이점을 제공하지만 몇 가지 개발자들에게는 특히 번거로울 수 있는 단점도 있습니다. 먼저, 컴파일 단계가 필요하다는 점은 주요한 문제일 수 있습니다. 이 과정은 빌드 시스템의 설정 및 유지에 추가적인 복잡성을 추가하므로 일부 팀이 추구하는 간소화된 프로세스와 일치하지 않을 수 있습니다.\n\n또한, TypeScript은 종종 추가적인 종속성을 필요로 합니다. 예를 들어 프로젝트에 단위 테스트를 통합할 때 추가 패키지를 다루어야 한다는 점과 Cucumber와 같은 프레임워크와 특히 호환성 문제가 발생할 수 있어 통합이 거의 불가능해질 수 있습니다. 이는 특정 테스트 프레임워크에 의존하는 팀들에게 문제가 될 수 있습니다.\n\n다른 중요한 단점은 많은 양을 요구한다는 점입니다. TypeScript는 타입을 명시적으로 선언해야하므로 코드가 비대해질 수 있습니다. 이로 인해 코드가 덜 우아해지며 타입 정의를 작성하고 관리하는 데 더 많은 시간이 소비되어 개발 속도가 느려질 수 있습니다.\n\n\n\n마지막으로, 이러한 유형을 최신 상태로 유지하는 것은 상당한 부담이 될 수 있습니다. 프로젝트가 규모가 확장되고 발전함에 따라 정확한 유형 정의를 유지하는 것은 지속적인 관심이 필요하며 유용한 자원을 다른 개발 활동으로 전환할 수 있습니다. 이 과부하는 TypeScript를 사용하는 이점을 초월할 정도로 중요할 수 있으며, 이로 인해 일부 팀은 선택을 재검토하기도 합니다.\n\n# Apps Script 특정 단점\n\nTypeScript를 사용하는 데 관한 주목할만한 Apps Script 특정 단점 중 하나는 clasp 사용에 관련이 있습니다. clasp는 TypeScript를 JavaScript로 컴파일하는 도구 중 하나로, Apps Script 런타임과 호환되는 방식으로 작동합니다. 그러나 아쉽게도 clasp는 더 이상 업데이트되지 않는 상태이며, 이는 상당한 위험을 야기할 수 있습니다. clasp가 의존하는 TypeScript 버전이 점점 구식화되고 있으며, 호환성 문제나 완전한 실패가 발생하기 전에 오랜 시간이 걸리지 않을 것입니다. 이 구식화로 인해 더 최신의 TypeScript 기능이나 업데이트에 의존하는 스크립트들이 실행 안 될 가능성이 있습니다.\n\nclasp의 기본 컴파일을 우회하려는 사람들을 위해서 자체 컴파일 구성을 설정하는 것은 대안이 될 수 있습니다. 그러나 이 방법은 자체적인 어려움을 포함하고 있습니다. 개발자들은 최종적인 JavaScript 출력이 Apps Script와 호환되도록 보장해야 합니다. 최소한, module.exports를 폴리필하는 노력이 필요하며, TypeScript 없이 이러한 조정을 관리하는 것이 간단하고 더 직관적일 수 있습니다.\n\n\n\n또한 Google Apps Script와 호환되는 JavaScript 번들링 과정은 이 시리즈에서 나중에 다룰 예정입니다. 이 과정은 Apps Script 환경에서 스크립트가 원활하게 실행되도록 보장하므로 ECMAScript 표준 및 기타 호환성 장벽과 관련된 문제를 피할 수 있습니다. 이러한 요소들은 Apps Script 컨텍스트에서 TypeScript 대안을 고려하는 강력한 이유가 됩니다. 이에 대해 더 자세히 알아볼 것입니다.\n\n# JSDoc의 구원\n\nJSDoc로 전환하면 Apps Script 환경에서 TypeScript의 복잡성과 오버헤드에 좌절한 사람들에게 매력적인 대안이 제공됩니다. JSDoc의 가장 중요한 장점 중 하나는 컴파일 단계가 필요하지 않다는 것입니다. 이는 개발 프로세스를 간소화하고 설정 시간을 줄이며 빌드 중에 발생하는 오류 가능성을 줄입니다. 또한 clasp의 기능을 망가뜨릴 염려없이 컴파일이 실패할 걱정을 할 필요가 없습니다.\n\n게다가 JSDoc는 추가적인 종속성 없이 작동합니다. 이 간소화된 접근 방식은 많은 종속성을 유지하는 환경에서 부담이 될 수 있는 곳에서 특히 유용하며, 충돌 및 관리 문제로 이어질 수 있는 가능성을 줄일 수 있습니다.\n\n\n\n복잡한 유형이 필요한 경우에도 JSDoc은 여전히 유연성을 제공합니다. 개발자들은 .d.ts 파일을 활용하여 복잡한 유형을 정의할 수 있으며, TypeScript의 엄격한 요구 사항을 완전히 따르지 않고 고급 유형 안전성이 필요한 중간 지점을 제공합니다.\n\n중요한 점은 JSDoc이 다수의 개발자가 필요로 하는 기본적인 기능을 지원하면서도 타입 체크와 자동 완성을 제공한다는 것입니다. 이러한 기능을 통해 개발자들은 추가적인 도구의 부담 없이 정확하고 효율적인 코드를 작성할 수 있습니다.\n\n마지막으로, JSDoc을 사용하는 주목할만한 장점 중 하나는 코드베이스에서 기술 문서를 직접 생성하는 능력입니다. 간단한 명령행 명령을 통해 JSDoc은 소스 코드의 주석을 서식이 있는 HTML 문서로 변환하여 문서 작성 및 업데이트를 일관되게 수행하기 쉽게 만듭니다. 이 기능은 사용자 채택 및 개발자 온보딩에 중요한 문서를 최신 상태로 유지해야 하는 프로젝트에서 특히 가치가 있습니다.\n\n# 결론\n\n\n\n종류들은 멋지지만 JSDoc이 TypeScript보다 우세합니다.\n\n# 시리즈의 다른 글들\n\n- 파트 1: 나는 Google Apps Script에서 console.table()이 필요했고, 여기에 대해 한 일입니다.\n- 파트 2: 소스 코드와 프로젝트 구조\n- 파트 3: JSDoc 대 TypeScript (바로 이 글)\n- 파트 4: 곧 배포 예정\n- 파트 5: 곧 배포 예정\n- 파트 6: 곧 배포 예정\n- 파트 7: 곧 배포 예정\n\n# 나에 대해\n\n\n\n저는 전업 Google Workspace 및 Google Cloud Platform 개발자이자 Workspace Google Developer Expert (GDE)입니다. 또한 Wurkspaces.dev의 창립자이기도 합니다. 프로젝트에 신뢰할 수 있는 개발자를 찾고 계시다면 저를 고용해보세요.\n\n# 쉽게 이해할 수 있는 영어로 🚀\n\n이 쉽게 이해할 수 있는 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우하는 것을 잊지 마세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지친 적이 있나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인해보세요","ogImage":{"url":"/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png","tag":["Tech"],"readingTime":5},{"title":"LWC에서 Apex 메소드 사용하기","description":"","date":"2024-05-14 13:43","slug":"2024-05-14-WorkWithApexMethodInLWC","content":"\n\n![이미지](/assets/img/2024-05-14-WorkWithApexMethodInLWC_0.png)\n\n라이트닝 웹 컴포넌트(LWC)는 Salesforce가 제공하는 강력한 프레임워크로, 현대적이고 효율적인 사용자 인터페이스를 구축하는 데 사용됩니다. LWC의 기능을 향상시키는 주요 기능 중 하나는 Apex 메서드와 함께 작업할 수 있는 능력입니다. Apex 메서드를 사용하면 서버 측 작업을 수행하고 Salesforce 데이터베이스에서 데이터를 검색할 수 있어, 프런트엔드 LWC 컴포넌트와 백엔드 Salesforce 로직 사이에 원활한 통합이 제공됩니다. 이 블로그 포스트에서는 LWC에서 Apex 메서드를 사용하는 프로세스를 살펴보고 실제 예제를 통해 안내할 것입니다.\n\n이 주제에서는 LWC 컴포넌트에서 어떻게 Apex 메서드를 호출하는지에 대해 알아볼 것입니다.\n\n\n\n- 와이어 어댑터를 사용하여 Apex 메서드를 호출하는 방법을 소개합니다.\n- 명령형 접근을 사용하여 Apex 메서드를 호출하는 방법을 소개합니다.\n- 비동기 및 대기 접근 방법을 사용하여 Apex 메서드를 호출하는 방법을 소개합니다.\n\n라이트닝 웹 컴포넌트(LWC)에서 Salesforce 개발 시 고려해야 할 두 가지 주요 측면이 있습니다: Apex 메서드를 라이트닝 웹 컴포넌트로 가져오는 방법과 다른 컴포넌트에서 사용할 수 있도록 Apex 메서드를 노출하는 방법입니다.\n\n# 라이트닝 웹 컴포넌트로 Apex 메서드 가져오기\n\n## 1. Import문:\n\n\n\n라이트닝 웹 구성 요소에서 Apex 메서드를 사용하려면 해당 메서드를 구성 요소로 가져와야 합니다. 이 작업은 구성 요소의 JavaScript 파일에서 import 문을 사용하여 수행됩니다. import 문에는 Apex 메서드의 네임스페이스와 이름이 포함됩니다.\n\n```js\nimport apexMethodName from '@salesforce/apex/namespace.classname.apexMethodReference';\n```\n\n- apexMethodName - Apex 메서드를 식별하는 심볼입니다.\n- apexMethodReference - 가져올 Apex 메서드의 이름입니다.\n- classname - Apex 클래스의 이름입니다.\n- namespace - 구성 요소와 동일한 네임스페이스에 있는 클래스인 경우 네임스페이스를 지정하지 않습니다. 관리되는 패키지에 있는 클래스인 경우 관리되는 패키지의 네임스페이스를 지정합니다.\n\n예시:\n\n\n\n```js\nimport getAccountDetails from '@salesforce/apex/MyApexController.getAccountDetails';\n```\n\n## 2. Apex 메서드 호출하기:\n\n한 번 가져온 후에 Apex 메서드를 컴포넌트의 JavaScript 파일에서 호출할 수 있어요. 이를 위해 반응형 데이터 가져오기에 `@wire` 데코레이터를 사용하거나 더 많은 제어를 위해 명령형 Apex를 사용할 수 있어요.\n\n```js\n// @wire 데코레이터 사용\n@wire(getAccountDetails, { accountId: '$recordId' })\nwiredAccount;\n \n// 명령형 Apex 사용\nconnectedCallback() {\n    getAccountDetails({ accountId: this.recordId })\n        .then(result => {\n            // 결과 처리\n        })\n        .catch(error => {\n            // 에러 처리\n        });\n}\n```\n\n\n\n위의 예시에서 'getAccountDetails'는 가져온 Apex 메서드입니다. 첫 번째 예시는 데이터를 반응적으로 가져오기 위해 `@wire` 데코레이터를 사용하고, 두 번째 예시는 `connectedCallback` 라이프사이클 훅에서 명령형 호출을 보여줍니다.\n\n# 컴포넌트에 Apex 메서드 노출하기\n\n## 1. Apex 클래스에 주석 추가:\n\nApex 메서드를 라이트닝 웹 컴포넌트에서 접근 가능하게 하려면 `@AuraEnabled` 또는 `@AuraEnabled(cacheable=true)`와 같은 주석을 추가해야 합니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-WorkWithApexMethodInLWC_1.png\" />\n\n알아두세요!\n\nApex 메서드를 노출하려면 메서드가 `static`으로 표시되어 있어야 하며 반드시 `@AuraEnabled`로 주석 처리된 `global` 또는 `public`이어야 합니다.\n\n`@AuraEnabled(cacheable=true)`로 표시된 Apex 메서드는 클라이언트 측 Lightning Data Service 캐시를 확인한 후 서버에서 Apex 메서드를 호출하려면 네트워크 호출을 발생시키기 전에 확인됩니다.\n\n\n\n```js\npublic with sharing class MyApexController {\n    @AuraEnabled(cacheable=true)\n    public static String getAccountDetails(String accountId) {\n        // Apex logic to fetch account details\n        return 'Account details for ' + accountId;\n    }\n}\n```\n\n이 예제에서 `getAccountDetails`는 `@AuraEnabled(cacheable=true)`로 주석이 달려 있습니다.\n\n## 2. Lightning 웹 컴포넌트에서 가져오고 사용하기:\n\nApex 메서드가 주석 처리된 후, 이전 섹션에서 설명한대로 Lightning 웹 컴포넌트에서 가져와 사용할 수 있습니다.\n\n\n\n```js\nimport getAccountDetails from '@salesforce/apex/MyApexController.getAccountDetails';\n\n// ...\n\n@wire(getAccountDetails, { accountId: '$recordId' })\nwiredAccount;\n```\n\n이제 Lightning Web Component에서 `getAccountDetails`를 사용하여 서버에서 데이터를 가져올 수 있습니다.\n\n이러한 단계를 따라 하면 Lightning Web Component로 Apex 메서드를 원활하게 가져와 데이터를 검색하고, Apex 클래스에서 Apex 메서드를 Lightning Web Component에서 사용할 수 있게 공개할 수 있습니다. 이를 통해 Salesforce 개발에서 프론트엔드와 백엔드 간의 효율적인 통신이 가능해집니다.\n\n각 시나리오를 예제 코드와 함께 단계별로 살펴보겠습니다:\n\n\n\n# 1. LWC에 Apex 메서드 연결하기\n\nSalesforce 데이터를 가져오려면 JS 파일에서 `@wire` 어댑터를 사용해야 합니다. 데이터를 받으려면 프로퍼티나 함수에 `@wire`를 사용할 수 있습니다. 반환된 데이터를 조작하려면 함수에 `@wire`를 사용하면 됩니다.\n\n구문:\n\n```js\nimport apexMethodName from '@salesforce/apex/namespace.classname.apexMethodReference';\n@wire(apexMethodName, { apexMethodParams })\npropertyOrFunction;\n```\n\n\n\n와이어 어댑터 예시\n\n```js\n// Apex 클래스(MyApexController)의 Apex 메서드\npublic with sharing class MyApexController {\n \n    @AuraEnabled(cacheable=true)\n    public static list<Account> getAccountDetails(){\n        return [SELECT Id, Name, Rating, Type FROM Account LIMIT 10];\n    }\n}\n```\n\n```js\n<!-- ldsWithApex.html -->\n<template>\n  <lightning-card title=\"LDS with Apex controller\">\n    <div class=\"slds-p-horizontal_small\">\n      <template for:each={accData} for:item=\"data\">\n        <div key={data.Id}>\n          <p><strong>Name: - </strong>{data.Name}</p>\n        </div>\n      </template>\n    </div>\n  </lightning-card>\n</template>\n```\n\n```js\n// ldsWithApex.js\nimport { LightningElement, wire } from 'lwc';\nimport getAccountDetails from '@salesforce/apex/MyApexController.getAccountDetails';\n \nexport default class LdsWithApex extends LightningElement {\n \n  accData = [];\n \n  @wire(getAccountDetails)\n  accDetails({ data, error }) {\n    if (data) {\n      console.log(JSON.stringify(data));\n      this.accData = data\n      if (error)\n        console.log(error);\n    }\n  }\n}\n```\n\n\n\n이 예제에서는 `@wire` 데코레이터를 사용하여 `getAccountDetails` 메서드를 호출합니다. 결과는 accData 속성에 저장되며, 포맷된 이름은 템플릿에 표시됩니다.\n\n출력:\n\n<img src=\"/assets/img/2024-05-14-WorkWithApexMethodInLWC_2.png\" />\n\n매개변수를 사용한 와이어 어댑터의 예시\n\n\n\n```js\n// ApexClassController에 있는 Apex 클래스의 Apex 메소드\n\npublic with sharing class ApexClassController {\n \n    @AuraEnabled(cacheable=true)\n    public static list<Account> getAccountDetailsByRating(String accRating){\n        return [SELECT Id, Name, Rating, Type \n                FROM Account\n                WHERE Rating =: accRating\n                WITH SECURITY_ENFORCED LIMIT 10];\n    }\n}\n```\n\n```js\n<!-- ldsWithApex.html -->\n\n<template>\n  <lightning-card title=\"Apex 컨트롤러에서 매개변수를 이용한 LDS\">\n    <div class=\"slds-p-horizontal_small\">\n      <lightning-combobox name=\"rating\" label=\"등급\" value=\"{accRating}\" placeholder=\"등급 선택\" options=\"{options}\" onchange=\"{handleChange}\">\n      </lightning-combobox>\n      <template for:each=\"{accDataByRating}\" for:item=\"accData\">\n        <div key=\"{accData.Id}\">\n          <p><strong>이름: - </strong>{accData.Name} </p>\n        </div>\n      </template>\n    </div>\n  </lightning-card>\n</template>\n```\n\n```js\n// ldsWithApex.js\n\nimport { LightningElement, wire } from 'lwc';\nimport filterAccountDetails from '@salesforce/apex/ApexClassController.getAccountDetailsByRating';\n \nexport default class LdsWithApex extends LightningElement {\n  accDataByRating = [];\n  accRating = '';\n \n  @wire(filterAccountDetails, { accRating: '$accRating' })\n  accDetailsByType({ data, error }) {\n    if (data) {\n      console.log(JSON.stringify(data));\n      this.accDataByRating = data;\n      if (error)\n        console.log(error);\n    }\n  }\n \n  get options() {\n    return [\n      { label: '핫', value: 'Hot' },\n      { label: '따뜻', value: 'Warm' },\n      { label: '차가운', value: 'Cold' }\n    ]\n  }\n \n  handleChange(event) {\n    this.accRating = event.target.value;\n    console.log('검색 등급:- ' + this.accRating);\n  }\n}\n```\n\n결과:\n \n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*Ij_zMfi-q9nY4eIt.gif)\n\n## 2. Apex 메서드를 명령적으로 호출하기\n\n라이트닝 웹 컴포넌트(LWC)에서 Apex 메서드를 명령적으로 호출하는 것은 JavaScript 코드에서 Apex 메서드에 직접 호출을 하여 호출이 언제, 어떻게 실행되는지에 대해 더 많은 제어를 제공합니다. `@wire` 데코레이터를 사용하는 것과 달리, 명령적인 Apex 호출은 일반적으로 사용자 상호작용, 라이프사이클 이벤트 또는 다른 동적 조건에 대응하여 프로그래밍적으로 시작됩니다.\n\n![이미지](/assets/img/2024-05-14-WorkWithApexMethodInLWC_3.png)\n\n\n\nMIND IT!\n\n메소드가 언제 호출되어야 하는지 제어하려면 명령형 접근 방식을 사용하세요.\n예를 들어, 버튼을 클릭하여 데이터를 가져오고 싶다면 명령형 접근 방식을 사용할 수 있습니다.\n\n사용하는 시점\n\n- cacheable=true로 주석이 달려 있지 않은 메소드를 호출할 때, 이는 데이터를 삽입, 업데이트 또는 삭제하는 메소드를 포함합니다.\n- 호출 시점을 제어할 때 (예: 버튼을 클릭하는 경우).\n- Task 및 Event와 같이 지원되지 않는 객체로 작업할 때.\n- `LightningElement`를 확장하지 않는 ES6 모듈에서 메소드를 호출할 때.\n\n\n\n```js\n// 에이펙스 클래스(ApexClassController)에 있는 에이펙스 메소드\n\npublic with sharing class ApexClassController {\n     \n    @AuraEnabled\n    public static list<Account> getAccountDetailsImperatively(){\n        return [SELECT Id, Name, Rating, Type \n                FROM Account\n                WITH SECURITY_ENFORCED LIMIT 10];\n    }\n}\n```\n\n```js\n<!-- ldsWithApex.html -->\n<template>\n  <lightning-card title=\"Imperatively Apex 메소드 호출\">\n    <div class=\"sIds-p-horizontal_small\">\n      <lightning-button variant=\"Brand\" label=\"계정 세부정보 가져오기\" title=\"acc details\" onclick=\"{handleClick}\">\n      </lightning-button>\n    </div>\n    <div class=\"slds-p-horizontal_small\">\n      <template lwc:if=\"{accDetailsImperatively}\">\n        <template for:each=\"{accDetailsImperatively}\" for:item=\"item\">\n          <div key=\"{item.Id}\">\n            <p><strong>이름: - </strong>{item.Name}</p>\n          </div>\n        </template>\n      </template>\n    </div>\n  </lightning-card>\n</template>\n```\n\n```js\n// ldsWithApex.js\nimport { LightningElement, wire } from 'lwc';\nimport getAccountDetailsImperatively from '@salesforce/apex/ApexClassController.getAccountDetailsImperatively';\n \nexport default class LdsWithApex extends LightningElement {\n  accDetailsImperatively = [];\n  error = '';\n \n  // Apex 메소드를 명령형적으로 호출하는 함수\n  handleClick() {\n    getAccountDetailsImperatively()\n      .then((result) => {\n        console.log(result);\n        this.accDetailsImperatively = result\n        this.error = undefined\n      })\n      .catch((error) => {\n        console.log(error);\n        this.accDetailsImperatively = undefined\n        this.error = error\n      })\n  }\n}\n```\n\n설명:\n\n\n\n\n1. Imports:\n\n- `import { LightningElement, wire } from ‘lwc’;`: 여기서는 LightningElement 및 wire와 같은 필요한 Lightning 웹 컴포넌트 모듈을 가져옵니다.\n- `import getAccountDetailsImperatively from ‘@salesforce/apex/ApexClassController.getAccountDetailsImperatively’;`: ApexClassController Apex 클래스에서 getAccountDetailsImperatively Apex 메서드를 가져옵니다.\n\n2. Class Definition:\n\n- `export default class LdsWithApex extends LightningElement`: 여기서는 LdsWithApex 클래스를 정의하고 LightningElement를 확장합니다. 이 클래스는 Lightning 웹 컴포넌트의 동작을 캡슐화합니다.\n\n\n\n3. 속성:\n\n- `accDetailsImperatively = []; `: 이 속성은 Apex 메서드에서 반환된 결과를 저장할 배열(accDetailsImperatively)입니다.\n- `error = ‘’; `: 이 속성은 Apex 메서드 호출 중 발생한 오류를 저장합니다.\n\n4. 명령형 Apex 메서드 호출:\n\n- `handleClick() '`: 이 메서드(handleClick)는 구성 요소에서 버튼 클릭과 같은 작업이 발생했을 때 호출됩니다.\n- `getAccountDetailsImperatively()`: 이것은 명령형 Apex 메서드 호출입니다. 가져오기된 Apex 메서드를 사용하여 계정 세부 정보를 가져옵니다.\n- `.then((result) =` ' … ') `: 이 부분은 성공 시나리오를 처리합니다. Apex 메서드 호출이 성공하면 결과가 콘솔에 로깅되고 `accDetailsImperatively` 속성이 결과로 업데이트됩니다.\n- `.catch((error) =` ' … ') `: 이 부분은 오류를 처리합니다. Apex 메서드 호출 중 오류가 발생하면 오류가 콘솔에 로깅되고 오류 메시지로 `error` 속성이 업데이트됩니다.\n\n\n\n사용 방법:\n\n이 컴포넌트는 버튼이나 다른 사용자 인터페이스 요소와 연결할 수 있는 메소드 (`handleClick`)를 노출합니다. 사용자가 해당 요소와 상호 작용할 때, 명령형 Apex 메소드인 (`getAccountDetailsImperatively`)가 호출되고, 결과나 오류가 적절히 처리됩니다.\n\n이 코드는 라이트닝 웹 컴포넌트에서 명령형 Apex를 사용하는 방법을 보여줍니다. 데이터를 가져오고 성공 및 오류 시나리오를 모두 처리합니다. 가져온 데이터는 컴포넌트에서 표시하거나 추가 처리를 위해 속성에 저장됩니다.\n\n출력:\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*ty-u1bBD3a58qUzR.gif)\n\nApex 메소드에 매개변수 값을 전달할 때, Apex 메소드의 매개변수와 일치하는 속성을 가진 객체에 값을 전달합니다.\n\n예를 들어, Apex 메소드가 문자열 매개변수를 사용한다면 직접 문자열을 전달하지 마세요. 대신 값이 문자열인 속성을 포함한 객체를 전달하세요.\n\n```js\n// Apex 클래스의 Apex 메소드 (ApexClassController)\npublic with sharing class ApexClassController {\n     \n    @AuraEnabled\n    public static list<Account> getAccountDetailsImperatively(String rating){\n        return [SELECT Id, Name, Rating, Type \n                FROM Account\n                WHERE Rating =: rating\n                WITH SECURITY_ENFORCED LIMIT 10];\n    }\n}\n```\n\n\n\n```js\n<!-- ldsWithApex.html -->\n<template>\n  <lightning-card title=\"매개변수와 함께 Apex 메서드를 취급하는 법\">\n    <div class=\"slds-p-horizontal_small\">\n      <lightning-combobox name=\"rating\" label=\"등급\" value=\"{rating}\" placeholder=\"등급 선택\" options=\"{options}\" onchange=\"{handleRatingChange}\">\n      </lightning-combobox>\n      <lightning-button variant=\"Brand\" label=\"계정 세부 정보 가져오기\" title=\"계정 세부 정보\" onclick=\"{buttonHandler}\">\n      </lightning-button>\n    </div>\n \n    <div class=\"slds-p-horizontal_small\">\n      <template lwc:if=\"{accDetailsByRatingImperatively}\">\n        <template for:each=\"{accDetailsByRatingImperatively}\" for:item=\"item\">\n          <div key=\"{item.Id}\">\n            <p><strong>이름: - </strong>{item.Name}</p>\n          </div>\n        </template>\n      </template>\n    </div>\n  </lightning-card>\n</template>\n```\n\n```js\n// ldsWithApex.js\n \nimport { LightningElement } from 'lwc';\nimport getAccountDetailsByRatingImperatively from '@salesforce/apex/ApexClassController.getAccountDetailsByRatingImperatively';\n \nexport default class LdsWithApex extends LightningElement {\n  rating = '';\n  error = '';\n  accDetailsByRatingImperatively = [];\n \n  get options() {\n    return [\n      { label: '뜨거운', value: 'Hot' },\n      { label: '따뜻한', value: 'Warm' },\n      { label: '차가운', value: 'Cold' }\n    ]\n  }\n \n  handleRatingChange(event) {\n    this.rating = event.target.value;\n  }\n \n  buttonHandler() {\n    getAccountDetailsByRatingImperatively({ rating: this.rating })\n      .then((result) => {\n        this.accDetailsByRatingImperatively = result\n        this.error = undefined\n      })\n      .catch((error) => {\n        this.error = error\n        this.accDetailsByRatingImperatively = undefined\n      })\n  }\n}\n```\n\n출력:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/0*TytD0CuSTNo7y-1i.gif\" />\n\n\n\n\n아래 링크를 방문하시면 더 많은 정보를 얻을 수 있어요:\n\n\"더 흥미로운 LWC 주제를 기다려주세요. Salesforce 개발 전문가가 되기 위해 Lightning Web Components 세계를 계속 탐험해보세요.\"\n\nLWC로 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-14-WorkWithApexMethodInLWC_0.png"},"coverImage":"/assets/img/2024-05-14-WorkWithApexMethodInLWC_0.png","tag":["Tech"],"readingTime":13},{"title":"JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요","description":"","date":"2024-05-14 13:41","slug":"2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing","content":"\n\nJavaScript과 나는 생일이 같아요. 난 어린이였던 그 때에는 레고, 책, 그리고 곱셈표를 발견한 바로 그 때였어요. 1995년, 난 컴퓨터를 한 번도 보지 못했어요. 베를린의 장벽이 무너져내리고 철의 커튼이 열리기까지도 어딘가에서는 일어난 일들이었어요. 동유럽에서는 컴퓨터는 마음속에서 가장 먼 곳에 있었죠. 하지만 세계 반대편에서 중요한 일이 있었어요. 오늘날 우리가 알고 있는 웹과 기술을 가능케 한 일이죠. 그것이 바로 JavaScript인데, 누구도 중요하게 여기지 않았습니다. 윈도우 1995가 열광의 중심이었을 때, 누구나 어떤 어린 스크립트 언어에 대해 신경 쓸 이유가 있었을까요?\n\n## JavaScript의 역사로 가는 롤러코스터\n\n아마도 브랜든 아이치, 넷스케이프, 썬 마이크로시스템즈의 리더십을 제외하고는, 현재의 모든 인터넷 사용자를 위한 12월 4일의 순간이 얼마나 중요해질지 정말 아무도 몰랐을 거예요.\n\nJavaScript가 시작되었던 사실 중에 잘 알려지지 않은 것 하나는 그것이 언어가 되기로 의도된 것이 아니었다는 것이에요. 브랜든 아이치를 고용했을 때의 목표는 넷스케이프에 스킴 언어를 통합하는 것이었지만, 동시에 자바도 통합하려고 노력했습니다. 그러나 헝가리 속담에는 \"두 마리 토끼를 쫓다가 한 마리도 잡지 못한다\"라는 말이 있는데, 여기서도 적용되죠. 우리가 지금 알게 된 대로, 자바나 스킴은 브라우저에 통합되지 않았고, 넷스케이프의 경영진은 토끼를 쫓는 것을 멈추고 자바보다는 자바와 가까운 문법이 적용된 새로운 언어를 개발하기로 결정했어요.\n\n\n\n공식 릴리스가 된 12월까지는 이 언어가 JavaScript가 아니라 LiveScript라는 이름을 갖지 않았어요. 28년이 지난 지금도 제 생각에는 그 이름이 넷스케이프 경영진이 선택한 이름보다 훨씬 적합하다고 생각해요. 특히 Web 2.0과 Ajax의 소개 이후로 JavaScript의 주요 이점 중 하나는 페이지 새로 고침이 필요하지 않는 실시간 웹 애플리케이션을 가능하게 하는 능력이에요.\n\n10년이 흘러 2006년에는 우리가 사랑하고 미워하는 jQuery가 나왔어요. 단독으로 StackOverflow를 웹 개발자들에게 지옥으로 만든 라이브러리예요. 그리고 그래서 태어났죠. 단순한 JavaScript로 작성된 코드에 손 대지 않을 JS 엘리트들도 있는 반면 jQuery \"개발자\"를 어디서든 비하하는 JS 스노브도 있어요. 제 경우 어느 캠프에도 속하지 않는 것 같아요.\n\n물론 모든 상황에 이상적인 선택은 아니에요. 예를 들어 버전 3.0.0의 주요 문제는 dataType 옵션이 지정되지 않은 상태에서 교차 도메인 Ajax 요청을 수행했을 때 크로스사이트 스크립팅(XSS) 공격에 취약하다는 점이에요. jQuery 열차에 올라타기 전에 모든 개발자들이 알아야 할 실제적인 문제지요.\n\njQuery의 인기에서 영감을 받았거나 \"JS를 더 나아지게 만들어야 한다\"는 지속적인 요구에 의해 2009년 3년 뒤에는 아무도 실제로 요청하지 않았던 CoffeeScript가 등장했어요. \"Java\"가 \"커피\"를 뜻하기도 하니 그 새 언어의 이름으로는 너무나 분명한 선택이었을 지도 모르지만, 우리 개발자들은 명명하는 것에서 진짜 열악해요. 그래서 그 이름은 자리를 지켰죠. 브랜든 아이크는 자신의 생각에 JavaScript의 미래에 영향을 미치는 요인으로서 이 언어를 언급했어요. 그 말로 우스움 있어도 사랑받은 것이죠. 하게, Ruby on Rails 3.1에는 CoffeeScript를 내장 지원하는 기능이 있었는데, RoR이 얼마나 인기가 있었는지(시대에 따라 아직도 그렇죠.) 생각해보면 전혀 작지 않은 일이죠.\n\n\n\n세 년 뒤인 2012년에, 바닐라 JS 애호가들이 겸허함을 배우는 때가 왔습니다. 마이크로소프트가 JavaScript를 \"개선\"하기로 결정하는 바람에요. 그러나 그들의 엔지니어들은 CoffeeScript처럼 JS로 컴파일되는 새 언어를 만들지 않고, 덜 고통스러운 슈퍼셋 경로를 선택했어요. 위키피디아에 따르면:\n\n누군가는 이것에 논쟁할지도 모르지만, 그 인기는 부정할 수 없죠. 이것은 많은 소프트웨어 엔지니어들의 상상력과 주의를 사로잡았습니다. 그것은 갑자기 강력하게 타입이 지정된 언어를 좋아하는 많은 소프트웨어 엔지니어들의 관심을 끌었기 때문에, 갑자기 바닐라 JS 애호가들은 TS보다 JS를 지지하게 되었어요. 2023년에는 원래의 언어와 그 슈퍼셋 간에 어느 정도 균형이 이루어졌지만, 최근에는 Svelte와 Turbo 8와 같은 프레임워크가 TypeScript를 버리고 부담이 적은 다른 솔루션을 선호하는 모습을 보여주기도 해서, 마이크로소프트의 개선된 JS의 미래는 확실하지 않습니다.\n\n한편, 자바스크립트 뒤의 ECMAScript 표준은 멈추지 않았습니다. 그래서 또 세 년 후인 2015년에, 웹 개발자들은 드디어 브라우저에서 자연스럽게 실행되는 자신들의 가장 좋아하는 언어에 중요한 업데이트를 얻었어요. ES6 (ECMAScript 2015)는 오랜 시간 동안 가장 중요한 변화였으며, 모든 변화가 개발자들에 의해 매우 환영을 받았어요. 몇 주 안에, 개발자들은 화살표 함수, 템플릿 문자열 및 상수를 사랑하게 되었죠. 물론 이것들은 빙산의 일각에 불과했습니다.\n\n2015년 이후로 매년 새로운 표준 및 JavaScript로의 업데이트 세트가 도입되고 있습니다. 2023년에는 모든 주요 브라우저에서 심지어 ES7도 아주 잘 지원되며, 실시간 및 동적 애플리케이션 개발이 이전보다 더 직관적이고 편리해지고 있습니다.\n\n\n\n## JS 이상의 존재\n\n자바스크립트의 가장 흥미로운 측면 중 하나는 브라우저에서 동작하는 역사를 가졌다는 것 뿐만 아니라, 어디서든 실행되는 언어가 되었다는 점입니다. 일부 사람들은 \"할 수 없다고 해서 반드시 해서는 안 된다\"고 강력히 이야기할지 모르지만, 자바스크립트는 가장 이색적인 플랫폼에서도 다양한 해결책을 개발할 수 있도록 해주었습니다.\n\nJS를 백엔드에서 실행하거나 OS에서 실행하고 싶나요? 가능합니다. Node.js, Deno 그리고 이제 Bun까지 모두 사용하실 수 있습니다. 흔히 사용되는 많은 경우를 위해 바퀴를 다시 발명할 필요 없이 최신 UI를 구축하고 싶다면, React, Vue, Svelte, Angular 및 기타 다양한 UI 라이브러리와 프레임워크를 선택할 수 있습니다. 대부분의 경우 서버 사이드 렌더링을 기본으로 지원하기 때문에 따로 추가 패키지가 필요하지 않습니다. 데스크톱 및 모바일용 네이티브 애플리케이션을 만들 수도 있습니다. 필요한 것은 Electron이나 Ionic 뿐입니다.\n\n하지만 JS는 더 나아갑니다. 작은 퍽을 블루투스 파워포인트 프레젠터 리모컨으로 변신시킨 것처럼 임베디드 시스템이나 마이크로컨트롤러에서 실행할 수도 있습니다. 놀랍게도, 자바스크립트는 게임 개발에도 탁월합니다. 따라서 플래피 버드나 요즘 아이들이 하는 게임을 만드는 데 어려움은 없을 것입니다. 저는 게이머가 아니며 게임을 즐기기에 충분히 심심하지 않습니다. LEGO를 쌓는 것이 취미죠. 😁\n\n\n\n자바스크립트는 겸손한 언어에서 전체 스택으로 발전했는데, 이것은 소프트웨어 개발 세계에서 엄청난 파워를 발휘합니다. 개발자 뿐만 아니라 스마트한 비용 절약 결정을 내리고 싶은 기업에게도 이점이 있죠. 자바스크립트는 더 이상 개발자의 선호도에 그치는 것이 아니라, 훨씬 더 큰 기업 전략 대화로 진화하고 있습니다. 자바스크립트는 현실적으로 돈을 절약하고 벌 수 있으며, 소프트웨어 엔지니어의 기술 세트를 매우 재사용 가능하게 만들어, 그들이 그 외의 경우에 비해 훨씬 더 가치 있게 만듭니다. 동일한 언어를 모든 곳에서 사용할 수 있는 능력은 무척 강력하고 만족스럽습니다.\n\n## '2023년, 꽤 좋았던 해였어요'\n\n2023년은 일반적으로 세상을 볼 때 최고의 해는 아니었을지许는데, 그러나 자바스크립트 팬들로서 우리는 새로운 업데이트를 풍부하게 받았고 그중에서 지루하지 않았죠.\n\n아마도 가장 주목할 만한 유틸리티 함수는 새로운 Object.groupBy()일 거예요. 이제 객체의 속성을 다른 속성 값에 따라 그룹화할 수 있게 되었는데, 에러가 발생하기 쉬운 끝도 없는 코드를 작성하지 않고도 가능하며, 이 과정은 다음과 같이 간단합니다:\n\n\n\n```js\nconst inventory = [\n  { name: \"asparagus\", type: \"vegetables\", quantity: 5 },\n  { name: \"bananas\", type: \"fruit\", quantity: 0 },\n  { name: \"goat\", type: \"meat\", quantity: 23 },\n  { name: \"cherries\", type: \"fruit\", quantity: 5 },\n  { name: \"fish\", type: \"meat\", quantity: 22 },\n];\n\nconst result = Object.groupBy(inventory, ({ type }) => type);\n```\n\n결과는 다음과 같습니다:\n\n```js\n{\n  vegetables: [\n    { name: 'asparagus', type: 'vegetables', quantity: 5 },\n  ],\n  fruit: [\n    { name: \"bananas\", type: \"fruit\", quantity: 0 },\n    { name: \"cherries\", type: \"fruit\", quantity: 5 }\n  ],\n  meat: [\n    { name: \"goat\", type: \"meat\", quantity: 23 },\n    { name: \"fish\", type: \"meat\", quantity: 22 }\n  ]\n}\n```\n\n이것이 아름다운 것이 아니라면, 무엇이 아름다운지 모르겠어요. 🙂\n\n\n\n\n마침내 배열을 복제하지 않고도 변이를 피하기 위해 원래 배열을 변형하지 않고 배열을 뒤집거나 분할하고 정렬할 수도 있게 되었습니다. 여기에서 작동하는 toReversed(), toSpliced() 및 toSorted()을 살펴봅시다:\n\n```js\n// toReversed()\n\nconst items = [1, 2, 3];\nconsole.log(items); // [1, 2, 3]\n\nconst reversedItems = items.toReversed();\nconsole.log(reversedItems); // [3, 2, 1]\nconsole.log(items); // [1, 2, 3]\n// toSpliced()\n\nconst months = [\"Jan\", \"Mar\", \"Apr\", \"May\"];\n\n// 인덱스 1에 요소 삽입\nconst months2 = months.toSpliced(1, 0, \"Feb\");\nconsole.log(months2); // [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"]\n\n// 인덱스 2부터 두 요소 삭제\nconst months3 = months2.toSpliced(2, 2);\nconsole.log(months3); // [\"Jan\", \"Feb\", \"May\"]\n\n// 인덱스 1의 요소를 새로운 두 요소로 대체\nconst months4 = months3.toSpliced(1, 1, \"Feb\", \"Mar\");\nconsole.log(months4); // [\"Jan\", \"Feb\", \"Mar\", \"May\"]\n\n// 원본 배열이 수정되지 않음\nconsole.log(months); // [\"Jan\", \"Mar\", \"Apr\", \"May\"]\n// toSorted()\n\nconst months = [\"Mar\", \"Jan\", \"Feb\", \"Dec\"];\nconst sortedMonths = months.toSorted();\nconsole.log(sortedMonths); // ['Dec', 'Feb', 'Jan', 'Mar']\nconsole.log(months); // ['Mar', 'Jan', 'Feb', 'Dec']\n\nconst values = [1, 10, 21, 2];\nconst sortedValues = values.toSorted((a, b) => a - b);\nconsole.log(sortedValues); // [1, 2, 10, 21]\nconsole.log(values); // [1, 10, 21, 2]\n```\n\nJavaScript의 특이한 점들은 나를 거의 짜증나게 하지 않지만, 이러한 개선 사항은 확실히 환영받을 만하며 앞으로 훨씬 깔끔한 코드 베이스로 이어집니다.\n\n올해 나를 흥분하게 한 마지막 것은 HTML5의 dialog 태그이며, 이제 내장된 showModal() 및 close() 함수가 있습니다. 이제 대화 상자나 모달을 열고 닫을 수 있습니다:\n\n\n\n\n```js\ndialog.showModal();\nclose(); // 당신은 안쪽에 값도 반환할 수 있어\n```\n\n이거 정말 멋지지 않아요!\n\n물론, 대부분의 주요 JS 프레임워크도 상당한 변화를 겪었죠. create-react-app은 사라졌고 이제 Next.js가 대부분의 미래 React 애플리케이션과 동의어가 되었습니다. 또한, Next.js v13에서 채택된 React 서버 사이드 컴포넌트로 API를 호출할 수도 있어요.\n\nSvelte도 눈에 띄게 변화하고자 했고, 웹에서 \"반응성\"을 다시 생각하기 위해 \"룬\" 개념을 도입했어요. 기본적으로 컴파일 시간 반응성에서 섬세한 단위의 반응성으로 전환하는 것이죠. 그들이 말하는 바에 따르면:\n\n\n\n하지만 Angular 17보다 더 빠를까요? 여전히 제 마음 속에 가장 가까운 JS 프레임워크는 2023년 11월에 17버전에 도달했으며, 오랜 시간 만에 가장 큰 변화 중 하나를 가져왔습니다. 누구나 새로운 템플릿 구문을 바로 알아차릴 것입니다. 즉, 이제 ngIf와 ngFor를 작별하게 되었습니다.\n\n이것은 프론트엔드에서의 변화 중 하나일 뿐입니다. 백엔드에서도 Node.js는 조용히 개선되고 있습니다. 그중 하나의 주목할만한 업데이트는 --experimental-websocket 플래그인 도입으로 Node 21에서 자체 웹소켓 클라이언트를 소개했습니다.\n\nNode.js가 명백히 매우 인기가 많다는 것은 2023년에 새로운 경쟁 상대가 나타나지 않았다는 것을 의미하지 않습니다. Bun.js는 올인원 JavaScript 런타임이며, 특정 환경에서 Node보다 5배 이상 빠르다고 합니다. Bun 팀은 다음과 같이 주장합니다:\n\n아직 초기 단계이지만 확실히 약속을 보여줍니다. 하지만 저는 여전히 Node나 Deno를 한동안 사용하는 것을 선호합니다.\n\n\n\n## JS의 다음은 무엇일까요?\n\n그래서, 28년 만에 JavaScript의 다음은 무엇일까요? 실제 기능 측면에서는, 우리는 무엇을 기대해야 하는지 알고 있습니다. ES 제안의 제3 단계 후보는 상당히 많은데요 — 총 14개 — 모두 충분히 흥미롭어서 곧 현실이 될 것으로 예상됩니다. 초안에서는 23개 제안이 있으며, 그 중 일부는 수천 표를 받았습니다. 반면 제안 단계 1에서는 총 90개가 있습니다. 하지만 그 중 대부분은 단계 2 또는 3에 도달할 가능성이 적을 것으로 생각합니다.\n\n생태계 측면에서, JavaScript는 계속 번창할 것으로 생각됩니다. IEEE.org에 따르면, 2023년에 가장 인기 있는 언어 중 3위에 올랐으며, 앞으로 몇 년 동안 이것이 크게 변할 것 같지는 않습니다. 직업 기회 측면에서 보면, SQL, Python, 그리고 Java 다음으로 가장 많이 찾는 기술이 되었습니다. 🎉\n\n\n\n![JavaScript Birthday](/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_1.png)\n\n사랑하든 싫어하든, JavaScript는 활기차고 성숙하며 열정적인 커뮤니티를 갖고 있습니다. 이 커뮤니티는 JavaScript를 오롯이 유지하는 것뿐만 아니라 새로운 높이로 끌어올리고 있습니다. JS로 무엇이든 구축하는 방법에 대한 정보는 파이썬만큼이나 풍부합니다. 이는 프로그래밍에 새로운 사람들에게 접근하기 쉬운 언어이며, 아마도 파이썬보다 더 쉽게 접근할 수 있다고 말해도 좋을 것입니다. 네, 이상한 점들이 있지만, 저는 한 사람으로서 이를 사랑하고 함께 일하며 조정하기를 배웠습니다.\n\n생일 축하, JavaScript! 🍻🎂\n\nAttila Vago - 세상을 하나의 코드 줄씩 개선하는 소프트웨어 엔지니어. 영원한 멋쟁이, 코드와 블로그의 작가. 웹 접근성 옹호자, 레고 팬, 비닐 레코드 컬렉터. 수제 맥주를 좋아합니다! 제 \"안녕 이야기\"를 여기서 읽어보세요! 레고, 기술, 코딩 및 접근성에 관한 더 많은 이야기를 구독하세요! 가끔씩 방문하시는 독자분들을 위해 랜덤 이야기와 글도 써봅니다.","ogImage":{"url":"/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_0.png"},"coverImage":"/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_0.png","tag":["Tech"],"readingTime":9},{"title":"흥미로운 자바스크립트 요령들","description":"","date":"2024-05-14 13:39","slug":"2024-05-14-ObscureYetUsefulJavaScriptTricks","content":"\n\n<img src=\"/assets/img/2024-05-14-ObscureYetUsefulJavaScriptTricks_0.png\" />\n\n제가 매일 업무 중에 수집한 약간 낯설지만 유용한 JavaScript 트릭 몇 가지를 소개해드릴게요. 이 모든 트릭들은 간결하고 우아한 한 줄짜리 코드들입니다. 이 트릭들이 여러분의 JavaScript 개발에 조금 도움이 될 수 있다고 믿어요.\n\n# 웹\n\n## 현재 페이지 다시 불러오기\n\n\n\n```js\nconst reload = () => location.reload();\nreload()\n```\n\n## 페이지 맨 위로 이동하기\n\n페이지를 맨 위로 가져와야 하는 경우\n\n```js\nconst goToTop = () => window.scrollTo(0, 0);\n\ngoToTop()\n```\n\n\n\n## 요소 스크롤링\n\n요소를 부드럽게 스크롤하여 뷰포트의 시작 지점으로 이동하려면\n\n```js\nconst scrollToTop = (element) =>\n  element.scrollIntoView({ behavior: \"smooth\", block: \"start\" })\n\nscrollToTop(document.body)\n```\n\n요소를 부드럽게 스크롤하여 뷰포트의 끝 지점으로 이동하려면\n\n\n\n```js\nconst scrollToBottom = (element) =>\n  element.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\nscrollToBottom(document.body);\n```\n\n## 현재 브라우저가 인터넷 익스플로러인지 확인하기\n\n```js\nconst isIE = !!document.documentMode;\n```\n\n## 주어진 텍스트에서 HTML 태그 제거하기\n\n\n\n단어로 마크업 태그들을 걸러내야 할 때\n\n```js\nconst stripHtml = (html) => new DOMParser().parseFromString(html, 'text/html').body.textContent || '';\n\nstripHtml('<div>test</div>') // 'test'\n```\n\n## 리다이렉트\n\n다른 페이지로 이동할 때.\n\n\n\n## 텍스트 붙여넣기\n\n클립보드에 텍스트를 복사해야 할 때\n\n```js\nconst copy = (text) => navigator.clipboard?.writeText && navigator.clipboard.writeText(text)\ncopy('당신이 붙여넣어야 할 텍스트')\n```\n\n\n\n# 기능\n\n## 비동기 함수 확인\n\n함수가 비동기인지 확인하려면\n\n```js\nconst isAsyncFunction = (v) => Object.prototype.toString.call(v) === '[object AsyncFunction]'\n\nisAsyncFunction(async function () {}); // true\n```\n\n\n\n# 숫자\n\n## 숫자 자르기\n\n소수점 이후 특정 자릿수를 버릴 때 반올림하지 않고 잘라야 할 때\n\n```js\nconst toFixed = (n, fixed) => `${n}`.match(new RegExp(`^-?\\d+(?:.\\d{0,${fixed})?`))[0]\n\ntoFixed(10.255, 2) // 10.25\n```\n\n\n\n## 가장 가까운 수로 반올림\n\n소수점 이후의 특정 자릿수를 버리고 가장 가까운 수로 반올림해야 하는 경우\n\n```js\nconst round = (n, decimals = 0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`)\n\nround(10.255, 2) // 10.26\n```\n\n## Zero padding\n\n\n\n숫자 'num'을 'len' 자릿수가 될 때까지 앞에 0을 채우고 싶을 때\n\n```js\nconst replenishZero = (num, len, zero = 0) => num.toString().padStart(len, zero)\n\nreplenishZero(8, 2) // 08\n```\n\n# 객체\n\n## 잘못된 속성 삭제\n\n\n\n객체 내 값이 null 또는 정의되지 않은 속성들을 모두 삭제해야 할 때\n\n```js\nconst removeNullUndefined = (obj) => Object.entries(obj).reduce((a, [k, v]) => (v == null ? a : ((a[k] = v), a)), {});\n\nremoveNullUndefined({name: '', age: undefined, sex: null}) // { name: '' }\n```\n\n## 객체 키-값 쌍 반전\n\n객체의 키-값 쌍을 교환해야 할 때\n\n\n\n```js\nconst invert = (obj) => Object.keys(obj).reduce((res, k) => Object.assign(res, { [obj[k]]: k }), {})\n\ninvert({name: 'jack'}) // {jack: 'name'}\n```\n\n## 문자열을 객체로 변환하기\n\n'이름: \"jack\"'과 같은 문자열을 객체로 변환해야할 때는 JSON.parse를 직접 사용하면 오류가 발생할 수 있습니다.\n\n```js\nconst strParse = (str) => JSON.parse(str.replace(/(\\w+)\\s*:/g, (_, p1) => `\"${p1}\":`).replace(/\\'/g, \"\\\"\"))\n\nstrParse('{name: \"jack\"}')\n```\n\n\n\n# 날짜\n\n## 오늘 날짜인지 확인하기.\n\n```js\nconst isToday = (date) => date.toISOString().slice(0, 10) === new Date().toISOString().slice(0, 10)\n```\n\n## 날짜 변환\n\n\n\n날짜를 YYYY-MM-DD 형식으로 변환해야 할 때\n\n```js\nconst formatYmd = (date) => date.toISOString().slice(0, 10);\nformatYmd(new Date())\n```\n\n## 두 번째 변환\n\n시간(초)를 hh:mm:ss 형식으로 변환해야 할 때\n\n\n\n```js\nconst formatSeconds = (s) => new Date(s * 1000).toISOString().substr(11, 8)\n\nformatSeconds(200) // 00:03:20\n```\n\n## 특정 연도와 월의 첫 번째 날을 가져오기\n\n```js\nconst getFirstDate = (d = new Date()) => new Date(d.getFullYear(), d.getMonth(), 1);\n\ngetFirstDate(new Date('2024/05')) \n```\n\n## 특정 연도와 월의 마지막 날을 가져오기\n\n\n\n\n```js\nconst getLastDate = (d = new Date()) => new Date(d.getFullYear(), d.getMonth() + 1, 0);\ngetLastDate(new Date('2023/03/04')) \n```\n\n## 특정 연도의 특정 월의 전체 일 수 구하기\n\n```js\nconst getDaysNum = (year, month) => new Date(year, month, 0).getDate()  \nconst day = getDaysNum(2024, 2) // 29\n```\n\n# 배열\n\n\n\n## 배열 생성하기\n\n0부터 99까지의 배열이 필요할 때 아래의 코드를 사용하세요.\n\n```js\n// 방법1\nconst createArr = (n) => Array.from(new Array(n), (v, i) => i)\nconst arr = createArr(100)\n```\n\n```js\n// 방법2\nconst createArr = (n) => new Array(n).fill(0).map((v, i) => i)\ncreateArr(100)\n```\n\n\n\n## 배열 섞기\n\n배열이 있고 순서를 섞어야 할 때\n\n```js\nconst randomSort = list => list.sort(() => Math.random() - 0.5)\nrandomSort([0,1,2,3,4,5,6,7,8,9]) // 무작위 순열 결과\n```\n\n## 간단한 배열 중복 제거\n\n\n\n배열에서 각 중복 요소의 인스턴스를 하나만 유지해야 할 때\n\n```js\nconst removeDuplicates = list => [...new Set(list)]\nremoveDuplicates([0, 0, 2, 4, 5]) // [0,2,4,5]\n```\n\n## 배열의 고유한 값 중복 제거\n\n고유한 값에 기반하여 배열에서 중복을 제거합니다.\n\n\n\n```js\nconst duplicateById = list => [...list.reduce((prev, cur) => prev.set(cur.id, cur), new Map()).values()]\nduplicateById([{id: 1, name: 'jack'}, {id: 2, name: 'rose'}, {id: 1, name: 'jack'}])\n// [{id: 1, name: 'jack'}, {id: 2, name: 'rose'}]\n```\n\n## 여러 배열의 교집합\n\n여러 배열의 교집합을 찾아야 할 때\n\n```js\nconst intersection = (a, ...arr) => [...new Set(a)].filter((v) => arr.every((b) => b.includes(v)))\n\nintersection([1, 2, 3, 4], [2, 3, 4, 7, 8], [1, 3, 4, 9])\n// [3, 4]\n```\n\n\n\n## 최대 값의 인덱스 찾기\n\n배열에서 최대 값의 인덱스를 찾아야 할 때\n\n```js\nconst indexOfMax = (arr) => arr.reduce((prev, curr, i, a) => (curr > a[prev] ? i : prev), 0);\nindexOfMax([1, 3, 9, 7, 5]); // 2\n```\n\n## 최소 값의 인덱스 찾기\n\n\n\n배열에서 최솟값의 인덱스를 찾아야 할 때\n\n```js\nconst indexOfMin = (arr) => arr.reduce((prev, curr, i, a) => (curr < a[prev] ? i : prev), 0)\nindexOfMin([2, 5, 3, 4, 1, 0, 9]) // 5\n```\n\n## 가장 가까운 숫자 값 찾기\n\n배열에서 주어진 숫자에 가장 가까운 값을 찾아야 할 때\n\n\n\n```js\nconst closest = (arr, n) => arr.reduce((prev, curr) => (Math.abs(curr - n) < Math.abs(prev - n) ? curr : prev))\nclosest([29, 87, 8, 78, 97, 20, 75, 33, 24, 17], 50) // 33\n```\n\n## 여러 배열을 압축하기\n\n여러 배열을 하나의 배열로 압축해야 할 때\n\n```js\nconst zip = (...arr) => Array.from({ length: Math.max(...arr.map((a) => a.length)) }, (_, i) => arr.map((a) => a[i]))\nzip([1,2,3,4], ['a', 'b', 'c', 'd'], ['A', 'B', 'C', 'D'])\n// [[1, 'a', 'A'], [2, 'b', 'B'], [3, 'c', 'C'], [4, 'd', 'D']]\n```\n\n\n\n## 행과 열 바꾸기\n\n행과 열을 교환해야 할 때\n\n```js\nconst transpose = (matrix) => matrix[0].map((col, i) => matrix.map((row) => row[i]));\ntranspose(\n    [              // [\n        [1, 2, 3], //      [1, 4, 7],\n        [4, 5, 6], //      [2, 5, 8],\n        [7, 8, 9], //      [3, 6, 9],\n     ]             //  ]\n );\n```\n\n# 숫자 변환\n\n\n\n## 기수 변환\n\n기수 10에서 n으로 변환하려면 toString(n)을 사용할 수 있어요!\n\n```js\nconst toDecimal = (num, n = 10) => num.toString(n) \n// 만약 10을 이진수 (기수 2)로 변환해야 한다면\ntoDecimal(10, 2) // '1010'\n```\n\n기수 n에서 기수 10으로 변환하려면 parseInt(num, n)을 사용할 수 있어요!\n\n\n\n```js\nconst toDecimalism = (num, n = 10) => parseInt(num, n)\ntoDecimalism(1010, 2)\n```\n\n# 기타\n\n## 두 객체 비교하기\n\n두 객체를 비교해야 할 때 JavaScript의 등가 연산자는 객체의 주소가 동일한지만 판단할 수 있습니다. 주소가 다를 경우 두 객체의 키-값 쌍이 동일한지 여부를 판단할 수 없습니다.\n\n\n\n```js\nconst isEqual = (...objects) => objects.every(obj => JSON.stringify(obj) === JSON.stringify(objects[0]))\nisEqual({name: 'jack'}, {name: 'jack'}) // true\nisEqual({name: 'jack'}, {name: 'jack1'}, {name: 'jack'}) // false\n```\n\n## 랜덤 색상 생성\n\n랜덤한 색상이 필요할 때\n\n```js\nconst getRandomColor = () => `#${Math.floor(Math.random() * 0xffffff).toString(16)}`\ngetRandomColor() // '#4c2fd7'\n```\n\n\n\n## 컬러 형식 변환\n\n16진수 색상을 RGB로 변환해야 할 때\n\n```js\nconst hexToRgb = hex => hex.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, (_, r, g, b) => `#${r}${r}${g}${g}${b}${b}`).substring(1).match(/.{2}/g).map((x) => parseInt(x, 16));\nhexToRgb('#00ffff'); // [0, 255, 255]\nhexToRgb('#0ff'); // [0, 255, 255]\n```\n\n## 랜덤 IP 주소 가져오기\n\n\n\nIP 주소를 생성할 때 필요한 함수입니다.\n\n```js\nconst randomIp = () =>\n    Array(4)\n        .fill(0)\n        .map((_, i) => Math.floor(Math.random() * 255) + (i === 0 ? 1 : 0))\n        .join('.');\n```\n\n# UUID\n\nID를 생성할 때 필요한 함수입니다.\n\n\n\n```javascript\nconst uuid = (a) => (a ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid))\nuuid()\n```\n\n## 쿠키 가져오기\n\n쿠키를 객체로 변환해야 할 때\n\n```javascript\nconst getCookie = () => document.cookie\n    .split(';')\n    .map((item) => item.split('='))\n    .reduce((acc, [k, v]) => (acc[k.trim().replace('\"', '')] = v) && acc, {})\ngetCookie()\n```\n\n\n\n## 강제 대기\n\n일정 시간 동안 기다려야 할 때 setTimeout 함수에 작성하고 싶지 않은 경우, 콜백 지옥을 유발할 수 있습니다.\n\n```js\nconst sleep = async (t) => new Promise((resolve) => setTimeout(resolve, t));\nsleep(2000).then(() => {console.log('time')});\n```\n\n# 간단히 말해 🚀\n\n\n\nThank you for being a part of the In Plain English community! Before you go:\n\n- Be sure to clap and follow the writer 👏\n- Follow us: X | LinkedIn | YouTube | Discord | Newsletter\n- Visit our other platforms: Stackademic | CoFeed | Venture | Cubed\n- Tired of blogging platforms that force you to deal with algorithmic content? Try Differ\n- More content at PlainEnglish.io","ogImage":{"url":"/assets/img/2024-05-14-ObscureYetUsefulJavaScriptTricks_0.png"},"coverImage":"/assets/img/2024-05-14-ObscureYetUsefulJavaScriptTricks_0.png","tag":["Tech"],"readingTime":9},{"title":"앵귤러에서의 라우팅","description":"","date":"2024-05-14 13:37","slug":"2024-05-14-RoutinginAngular","content":"\n\n<img src=\"/assets/img/2024-05-14-RoutinginAngular_0.png\" />\n\n안녕하세요! 이 기사에서는 Angular에서 라우팅에 대해 이야기하고 서로 다른 컴포넌트를 렌더링하기 위해 라우팅을 사용하는 다양한 방법에 대해 알아볼 거예요.\n\n# 아젠다\n\n- Angular가 무엇인가요?\n\n\n\n- 라우팅이란 무엇인가요?\n\n- 라우팅의 장점은 무엇인가요?\n\n- 앵귤러에서의 라우팅\n\n- 라우팅 예시\n\n\n\n# 요구 사항\n\n- Node.js\n- Angular\n- VS Code\n\n\n\n# 앵귤러란 무엇인가요?\n\n앵귤러는 웹 애플리케이션을 구축하기 위한 인기있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재 Google의 앵귤러 팀에서 유지보수되고 있습니다. 앵귤러를 사용하면 개발자들은 동적인 싱글 페이지 애플리케이션(SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하는 구조적인 방법을 제공합니다.\n\n# 라우팅이란 무엇인가요?\n\n웹 개발의 맥락에서 라우팅이란 특정 URL이나 경로에 대한 애플리케이션의 응답 방식을 결정하는 프로세스를 말합니다. 이는 URL을 애플리케이션 내의 다른 구성 요소나 뷰로 매핑하고 요청된 URL에 따라 적절한 콘텐츠를 렌더링하는 것을 포함합니다.\n\n\n\n클라이언트 측 웹 애플리케이션인 Angular로 만든 싱글 페이지 애플리케이션(SPA)과 같은 경우에는 라우팅을 통해 사용자가 새로운 HTML 페이지를 서버에서 로드하지 않고도 서로 다른 뷰 또는 페이지 간을 이동할 수 있습니다. 대신, 요청한 라우트에 기반하여 응용 프로그램이 필요한 구성 요소와 데이터를 동적으로 업데이트하여 브라우저의 내용을 로드합니다.\n\n라우팅의 장점\n\n웹 애플리케이션의 라우팅은 여러 가지 이점을 제공합니다. 여기에 라우팅을 사용하는 주요 이점 중 일부가 있습니다:\n\n사용자 경험 향상: 라우팅을 통해 전체 페이지 다시로드 없이 응용 프로그램 내에서 서로 다른 뷰나 페이지로 내비게이션할 수 있어 사용자 경험을 원활하고 상호작용적으로 만들어줍니다.\n\n\n\n빠른 페이지 전환: 라우팅을 사용하면 요청된 경로에 필요한 컴포넌트와 데이터만 로드되어 더 빠른 페이지 전환을 경험할 수 있어요.\n\n모듈화와 유지보수성: 라우팅은 응용 프로그램을 모듈화된 구조로 유지하도록 장려하여 특정 경로와 관련된 서로 다른 뷰나 컴포넌트로 분할합니다. 이는 코드의 재사용성, 관심사의 분리 및 더 나은 유지보수성을 촉진합니다. 각 경로에는 해당 컴포넌트가 있어서 응용 프로그램의 특정 섹션을 보다 쉽게 관리하고 업데이트할 수 있습니다.\n\n조건부 렌더링과 동적 콘텐츠: 라우팅을 통해 현재 경로에 따라 컴포넌트를 조건부로 렌더링할 수 있습니다. 이를 통해 사용자의 탐색 경로에 따라 응용 프로그램의 특정 섹션을 표시하거나 숨길 수 있어요.\n\n경로 매개변수와 쿼리 매개변수: 라우팅은 경로 매개변수와 쿼리 매개변수를 지원합니다. 경로 매개변수를 사용하면 URL 내에서 ID나 사용자 이름과 같은 동적값을 전달하고 해당 컴포넌트에서 이를 검색할 수 있습니다. 쿼리 매개변수는 URL에 추가 데이터를 전달하여 필터링, 정렬 또는 기타 목적으로 사용할 수 있어요.\n\n\n\n보안 및 라우팅 가드: Angular 라우팅에는 특정 조건을 기반으로 특정 경로에 대한 액세스를 제어하는 메커니즘인 라우트 가드가 포함되어 있습니다. 라우트 가드는 인증, 권한 부여 및 기타 보안 관련 목적으로 사용할 수 있습니다. 사용자가 필요한 기준을 충족해야만 경로에 액세스하거나 작업을 수행할 수 있도록 도와줍니다.\n\n중첩 라우트: 라우팅은 중첩된 또는 하위 경로를 지원하여 응용 프로그램 내에서 계층적 탐색 구조를 정의할 수 있습니다. 이는 다중 수준의 탐색 또는 캡슐화되고 독립적으로 관리해야 하는 섹션을 처리할 때 특히 유용합니다.\n\n전반적으로 라우팅은 사용자 경험을 향상시키고 성능을 향상시키며 웹 애플리케이션에서 모듈식이고 유지 보수 가능한 코드 구조를 가능하게 하는 데 중요한 역할을 합니다.\n\n# Angular에서의 라우팅\n\n\n\n클라이언트 측 웹 애플리케이션에서 Angular을 사용하여 구축된 싱글 페이지 애플리케이션(SPA)과 같은 경우에는 라우팅을 통해 사용자가 서버로부터 새 HTML 페이지를 로딩하지 않고도 서로 다른 뷰 간을 이동할 수 있습니다. 대신에 어플리케이션은 요청된 경로에 기반하여 필요한 컴포넌트와 데이터를 동적으로 브라우저에 업데이트하여 내용을 렌더링합니다.\n\nAngular에서의 라우팅은 일반적으로 다음 구성 요소를 포함합니다:\n\n- 라우트(Routes): 라우트는 URL 경로와 해당 컴포넌트 간의 매핑을 정의합니다. 각 라우트는 URL 경로 및 해당 경로에 액세스할 때 렌더링될 컴포넌트로 정의됩니다.\n\n- 라우터(Router): 라우터는 현재 URL을 해석하고 정의된 라우트를 기반으로 적절한 컴포넌트를 로딩하는 역할을 담당합니다. 라우터는 URL 변경을 감지하고 어플리케이션 내에서의 네비게이션을 처리합니다.\n\n\n\nRouter Outlet: 라우터 아웃렛은 현재 라우트의 내용이 렌더링되는 애플리케이션 템플릿의 자리 표시자입니다.\n\nRouter 링크 및 내비게이션: 링크 및 내비게이션 요소인 앵커 태그(`a`)나 버튼과 같은 요소는 애플리케이션 내에서 다른 라우트로의 이동을 트리거하는 데 사용됩니다. 이러한 요소에는 Angular의 routerLink와 같은 디렉티브로 대상 경로를 지정할 수 있습니다.\n\n# Angular에서의 라우팅 예제\n\n단계 1\n\n\n\nNodeJS를 설치하세요.\n\nhttps://nodejs.org/en/download\n\n단계 2\n\n다음 명령을 사용하여 Angular CLI를 설치하세요.\n\n\n\n3단계\n\n다음 명령어를 사용하여 NodeJS와 Angular CLI가 설치되었는지 확인하세요:\n\n![Routing in Angular](/assets/img/2024-05-14-RoutinginAngular_1.png)\n\n새로운 Angular 애플리케이션을 생성하세요.\n\n\n\n**단계 4**\n\nAngular 애플리케이션을 VS Code와 같은 편집기 중 하나에서 열고 다음 명령어를 사용하여 부트스트랩을 설치하세요:\n\n이후에 angular.json 파일 내에 있는 스크립트 및 스타일 섹션에 부트스트랩 스크립트를 추가하세요.\n\n```js\n\"styles\": [\n\"src/styles.css\",\n\"./node_modules/bootstrap/dist/css/bootstrap.min.css\"\n],\n\"scripts\": [\n\"./node_modules/bootstrap/dist/js/bootstrap.min.js\"\n]\n```\n\n\n\n## 단계 5\n\n터미널이나 명령 프롬프트를 열고 Angular 프로젝트 디렉터리로 이동합니다. 아래 명령어를 실행하여 컴포넌트를 생성합니다:\n\n## 단계 6\n\n라우팅 구성:\n\n\n\n프로젝트에서 app-routing.module.ts 파일을 열어 새로 생성된 컴포넌트를 포함하도록 라우트 구성을 업데이트해주세요.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './components/home/home.component';\nimport { ProductComponent } from './components/product/product.component';\nimport { AboutComponent } from './components/about/about.component';\nimport { ContactComponent } from './components/contact/contact.component';\nimport { ProductOfferComponent } from './components/product-offer/product-offer.component';\nimport { ProductUpdatesComponent } from './components/product-updates/product-updates.component';\nimport { RatingComponent } from './components/rating/rating.component';\nimport { FeedbackComponent } from './components/feedback/feedback.component';\n\nconst routes: Routes = [\n  { path: '', redirectTo: 'home', pathMatch: 'full' }, // 기본 경로\n  { path: 'home', component: HomeComponent },\n  {\n    path: 'product/:id', component: ProductComponent,\n    children: [\n      {path: '', redirectTo:'updates', pathMatch:'full'},\n      { path: 'offers', component: ProductOfferComponent },\n      { path: 'updates', component: ProductUpdatesComponent }\n    ]\n  },\n  { path: 'about', component: AboutComponent, \n    children: [\n      {path: 'rating', outlet:'rate', component:RatingComponent},\n      {path: 'feedback', outlet:'feed', component:FeedbackComponent}\n    ]\n  },\n  { path: 'contact', component: ContactComponent },\n  { path: '**', component: HomeComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n이 구성은 각 경로를 해당 컴포넌트에 매핑합니다.\n\nAngular에서 RouterModule와 Routes는 응용 프로그램에서 라우팅을 구성하고 관리하는 데 사용되는 주요 구성 요소입니다.\n\n\n\n## RouterModule:\n\nRouterModule은 애플리케이션에서 라우팅을 구현하는 데 필요한 지시자, 서비스 및 기능을 제공하는 Angular 모듈입니다.\n\n## Routes:\n\nRoutes는 애플리케이션 내에서 경로 및 구성을 정의하는 배열입니다. Routes 배열 내의 각 route 개체는 해당 경로에 액세스할 때 렌더링될 URL 경로 및 해당 구성 요소를 지정합니다.\n\n\n\n13 번째 줄:\n\nAngular에서 기본 경로를 정의하려면 빈 경로 ''를 Routes 배열 구성에서 경로로 사용할 수 있습니다. 빈 경로에 액세스하면 Angular가 해당 경로에 연결된 컴포넌트를 렌더링합니다.\n\n기본 경로에 액세스할 때 다른 경로로 리디렉션하려면 redirectTo 속성을 사용하여 대상 경로로 이동할 수 있습니다. 또한 pathMatch 속성을 사용하여 경로의 일치 전략을 정의할 수 있습니다.\n\n15 번째 줄부터 22 번째 줄까지:\n\n\n\n제품 세부 정보를 표시하는 id 매개변수가 포함된 경로를 생성하려면 Angular에서 라우팅 구성을 다음과 같이 수정할 수 있습니다:\n\n```js\npath: 'product/:id', component: ProductComponent\n```\n\n이 예에서는 경로가 'product/:id'인 경로를 추가하여 제품 세부 정보 페이지를 나타냈습니다. :id 부분은 ProductComponent에서 액세스할 수 있는 동적 매개변수를 나타냅니다.\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { ProductsService } from '../../services/products.service';\n\n@Component({\n  selector: 'app-products',\n  templateUrl: './product.component.html',\n  styleUrls: ['./product.component.css']\n})\nexport class ProductComponent implements OnInit {\n\n  productDetail? : any;\n\n  constructor(private route : ActivatedRoute, private productService : ProductsService) {}\n\n  ngOnInit(): void {\n    let productId = this.route.snapshot.params['id'];\n    this.getProductDetailById(productId)\n  }\n\n  getProductDetailById(id: number) {\n    this.productService.getProductDetailById(id).subscribe(res => {\n      this.productDetail = res\n      console.log(res)\n    })\n  }\n}\n```\n\n\n\n이 코드에서는 ActivatedRoute 서비스를 주입하여 현재 라우트의 매개변수에 액세스합니다. ngOnInit() 라이프사이클 훅에서는 this.route.snapshot.params['id']를 사용하여 id 매개변수를 검색하고 이를 나중에 구성 요소의 템플릿에서 사용하기 위해 productId 속성에 할당합니다.\n\n마지막으로 URL에 id 값을 제공하여 제품 세부 정보 페이지로 이동할 수 있습니다. 예를 들어 id가 123인 제품이 있다면 http://localhost:4200/product/123로 이동하여 제품 세부 정보를 볼 수 있습니다.\n\nProductComponent는 URL에서 검색한 해당 id 매개변수로 렌더링되며 템플릿에서 관련 제품 정보를 표시하는 데 productId 속성을 사용할 수 있습니다.\n\nProductComponent 아래에 중첩된 자식 구성 요소인 ProductOfferComponent 및 ProductUpdatesComponent를 만들려면 Angular에서 라우팅 구성을 다음과 같이 수정할 수 있습니다:\n\n\n\n루트 배열을 업데이트하여 ProductComponent 아래에 자식 라우트를 포함하도록 라우팅 모듈 (예: app-routing.module.ts)을 업데이트하세요:\n\n```js\n{\n  path: 'product/:id', component: ProductComponent,\n  children: [\n    {path: '', redirectTo:'updates', pathMatch:'full'},\n    { path: 'offers', component: ProductOfferComponent },\n    { path: 'updates', component: ProductUpdatesComponent }\n  ]\n}\n```\n\n이 업데이트된 예제에서는 ProductComponent에 자식 라우트를 추가했습니다. 자식 라우트 내의 빈 경로 ''는 /product에 액세스할 때 렌더링할 기본 구성 요소로 ProductComponent에 해당합니다. offers 및 updates 경로는 각각 ProductOfferComponent 및 ProductUpdatesComponent로 매핑됩니다.\n\n\n\nAboutComponent 아래에 중첩된 RatingComponent 및 FeedbackComponent 자식 구성 요소를 만들고, rating 및 feedback을 위한 이름이 지정된 outlet을 사용하려면 Angular에서 라우팅 구성을 다음과 같이 수정할 수 있습니다:\n\n라우팅 모듈(예: app-routing.module.ts)의 Routes 배열을 업데이트하여 AboutComponent 아래에 자식 라우트를 이름이 지정된 outlet과 함께 포함시킵니다:\n\n```js\n{ \n  path: 'about', component: AboutComponent,\n  children: [\n    {path: 'rating', outlet:'rate', component:RatingComponent},\n    {path: 'feedback', outlet:'feed', component:FeedbackComponent}\n  ]\n}\n```\n\n이 업데이트된 예제에서 AboutComponent에 자식 라우트를 추가하고 RatingComponent 및 FeedbackComponent에 대해 각각 이름이 지정된 outlet rate 및 feed을 지정했습니다.\n\n\n\nAboutComponent 템플릿(about.component.html)을 구현하여 이름이 지정된 outlet(출구) 플레이스홀더를 포함하도록 합니다. 예를 들어:\n\n```js\n<p>Lorem ipsum dolor sit, amet consectetur adipisicing elit. Tenetur magni saepe sint, vel eaque veniam recusandae laboriosam numquam necessitatibus? Laborum mollitia excepturi qui. Modi corporis quasi ab minima eligendi numquam!</p>\n\n<div class=\"row\">\n    <div class=\"col-md-6\">\n        <router-outlet name=\"rate\"></router-outlet>\n    </div>\n    <div class=\"col-md-6\">\n        <router-outlet name=\"feed\"></router-outlet>        \n    </div>\n</div>\n```\n\n이 템플릿에서는 'rate' 및 'feed'로 설정된 이름 속성을 가진 두 개의 `router-outlet` 플레이스홀더를 추가했습니다. 이 플레이스홀더는 AboutComponent 템플릿 내에서 RatingComponent 및 FeedbackComponent를 렌더링하는 데 사용될 것입니다.\n\nRatingComponent 및 FeedbackComponent의 컴포넌트 파일을 필요에 맞게 업데이트하십시오.\n\n\n\nAbout 및 Child 컴포넌트로 이름이 지정된 outlet을 사용하여 이동할 수 있습니다. 예를 들어, rating 컴포넌트에 액세스하려면 http://localhost:4200/about/(rate:rating//feed:feedback) 로 이동하면 됩니다.\n\n저는 앱 컴포넌트에서 아래에 보여드린대로 외부 링크를 만들었습니다. 그러나 필요에 따라 URL을 생성할 수 있습니다. 그 경우 적절한 라우터 링크와 outlet이 필요합니다.\n\n```js\n<a class=\"nav-link\" [routerLink]=\"['/about',{\n  outlets:{\n    'rate': ['rating'],\n    'feed': ['feedback']\n  }\n}]\">About</a>\n```\n\n30번째 줄:\n\n\n\n앵귤러에서 이중 별표 (**) 루트는 와일드카드 루트 또는 캐치-올 루트라고도 알려진데, 미리 정의된 루트와 일치하지 않는 루트를 처리하는 데 사용됩니다. 이는 응용 프로그램 내에서 알 수 없는 또는 잘못된 URL을 처리하는 폴백 루트 역할을 합니다.\n\n와일드카드 루트를 정의하려면 루트 배열 끝에 경로가 '**'인 구성을 추가할 수 있습니다. 이 루트는 요청된 URL과 일치하는 다른 루트가 없을 때 일치됩니다.\n\n```js\n{ path: '**', component: HomeComponent }\n```\n\n7단계\n\n\n\n앱 컴포넌트 뷰에서 라우터 아웃렛을 언급하여 네비게이션에 따라 다른 컴포넌트를 조건부로 렌더링하세요.\n\n```js\n<nav class=\"navbar navbar-expand-lg bg-body-tertiary\">\n  <div class=\"container-fluid\">\n    <a class=\"navbar-brand\" href=\"#\">\n      <img src=\"../assets/logo/coder.png\" class=\"navlogo\"/> 제품 어플리케이션\n    </a>\n    <button class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#navbarNavAltMarkup\" aria-controls=\"navbarNavAltMarkup\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\n      <span class=\"navbar-toggler-icon\"></span>\n    </button>\n    <div class=\"collapse navbar-collapse\" id=\"navbarNavAltMarkup\">\n      <div class=\"navbar-nav\">\n        <a class=\"nav-link\" [routerLink]=\"['/about', {\n          outlets: {\n            'rate': ['rating'],\n            'feed': ['feedback']\n          }\n        }]\">About</a>\n        <a class=\"nav-link\" routerLink=\"/contact\">Contact</a>\n      </div>\n    </div>\n  </div>\n</nav>\n\n<router-outlet></router-outlet>\n```\n\n![라우팅 이미지 1](/assets/img/2024-05-14-RoutinginAngular_2.png)\n\n![라우팅 이미지 2](/assets/img/2024-05-14-RoutinginAngular_3.png)\n\n\n\n<img src=\"/assets/img/2024-05-14-RoutinginAngular_4.png\" />\n\n<img src=\"/assets/img/2024-05-14-RoutinginAngular_5.png\" />\n\n<img src=\"/assets/img/2024-05-14-RoutinginAngular_6.png\" />\n\n그래서, 이것이 Angular에서 라우팅에 대한 모든 것입니다.\n\n\n\n# GitHub\n\nhttps://github.com/Jaydeep-007/angular-routing\n\n# 결론\n\n이 글에서는 Angular에서 라우팅의 이점과 Angular 15에서 서로 다른 컴포넌트를 만든 후 단계별 구현에 대해 설명했습니다.\n\n\n\n행복한 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-14-RoutinginAngular_0.png"},"coverImage":"/assets/img/2024-05-14-RoutinginAngular_0.png","tag":["Tech"],"readingTime":12},{"title":"잠시만, 종 TypeScript를 잘못 사용하는 이유입니다","description":"","date":"2024-05-14 13:35","slug":"2024-05-14-ZodWhyyoureusingTypeScriptwrong","content":"\n\n![이미지](/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png)\n\n간략 요약: 런타임에서 외부 데이터를 검증해야 합니다.\n\n웹 개발 경험이 있다면, API에서 외부 데이터를 다룰 때 런타임 오류를 반드시 마주쳐보았을 것입니다. TypeScript를 사용하면 애플리케이션 전체에서 모든 데이터의 구조와 유형을 상기시켜 주어 이러한 오류를 크게 줄일 수 있습니다. 그러나 TypeScript는 컴파일 중에 알려진 데이터에 대한 불가능한 작업을 방지하는 데 강점을 가지고 있지만, 외부(다른 말로, 알 수 없는) 데이터에 대해서는 너무 관대할 수 있습니다.\n\n본 문서에서는 TypeScript를 사용하여 런타임에서 실패할 수 있는 코드를 작성할 수 있게 하는 이유와 Zod가 이러한 데이터 관련 오류를 방지할 수 있는 방법에 대해 설명하겠습니다.\n\n\n\n# TypeScript의 목표\n\n소개에서 말했듯이, TypeScript의 아이디어는 전체 코드에서 모든 데이터의 구조와 유형을 추적하는 것입니다. 이는 IDE에서 자동완성을 제공하는 데 도움이 되는 것뿐만 아니라 런타임 중에 오류를 일으킬 수있는 유효하지 않은 작업을 방지하기도 합니다. 이론적으로 TypeScript 컴파일 중에 발생할 수 있는 모든 런타임 오류를 예측하고 식별할 수 있습니다. 그러나 실제론 그렇지 않습니다.\n\n## TypeScript는 목표를 달성하지 못했을까요?\n\n실제로 TypeScript의 주요 목표는 생산성을 향상시키는 것입니다. 이것은 TypeScript가 언제나 \"안전\"보다는 생산성을 선택한다는 것을 의미합니다.\n\n\n\n있는 것은 any 타입입니다. 그러나 널리 받아들여지는 것은 사용하지 말아야 한다는 것입니다. 그러나 우리 코드에서 any를 하나도 쓰지 않는다고 해서 우리 애플리케이션이 런타임 오류에 면역이라는 뜻은 아닙니다. 다음 스니펫을 살펴보세요:\n\n```js\nconst obviouslyAnArticle: Article = JSON.parse(input); // input is a string\n```\n\nJSON.parse의 반환 타입이 any인데, 이는 명시적으로 타입이 지정된 변수(이 예에서는 Article)와 연관시킬 수 있습니다. 우리 자신으로부터 명시적으로 작성하지 않아도 TypeScript에게 우리가 any로 작성하지 않고도 파싱된 내용이 Article 타입을 충족하지 않을 수 있는 런타임 가능성을 무시하도록 알려주고 있는 것입니다.\n\n## unknown 및 단언(assertions)\n\n\n\n만약 '어느' 대신 '모든'이 사용되었다면 위 조각을 만들 수 없었을 것입니다. 대신 as 키워드를 사용하여 명시적인 주장을 작성해야 합니다:\n\n```js\nconst shouldBeAnArticle = JSON.parse(input) as Article;\n```\n\n이 구문을 사용하면 TypeScript에게 명시적으로 경계를 낮추도록 지시합니다. 여전히 좋지 않지만 숨겨지지 않았어요!\n\n## 유형 좁히기 식\n\n\n\n위험한 유형 단언을 의존하는 대신, 유형 축소 표현식을 사용할 수 있어요.\n\n예를 들어, JavaScript에서 제공하는 typeof 연산자는 객체의 유형을 런타임 중에 결정할 수 있어요.\n\n```js\nconsole.log(typeof 42);\n// 기대하는 출력: \"number\"\n```\n\n조건문에서 사용되면 TypeScript는 객체의 유형을 축소할 수 있어요.\n\n\n\n```js\nif(typeof input === \"string\") {\n    // input이 문자열 형식으로 좁혀졌습니다.\n    submit(input.toLowerCase());\n}\n```\n\n이 표현은 TypeScript에게 해당 범위에서 input이 문자열만 가능함을 예측할 수 있도록 해줍니다.\n\n## 타입 추론\n\nTypeScript는 다른 표현식들로 타입을 좁힐 수 있지만, 이는 보통 유니언 혹은 원시 타입을 구체화할 때 의미가 있습니다. 이를 \"타입의 차별\"이라고 부릅니다.\n\n\n\n```js\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n\nfunction move(animal: Fish | Bird) {\n  if (\"swim\" in animal) {\n    // input is narrowed to the type Fish\n    return animal.swim();\n  }\n  // input is narrowed to the type Bird\n  return animal.fly();\n}\n```\n\n위 예제에서 키워드 in은 TypeScript가 animal 객체의 유형을 식별하도록 합니다.\n\n알 수 없는 데이터의 경우, 유형 판별은 시간 낭비일 수 있습니다:\n\n```js\nif(typeof input !== \"string\") {\n    // input is still unkown\n}\n```\n\n\n\n외부 데이터에 대해 유형 좁히기 표현식에만 의존할 수 없다는 뜻이에요. 유형을 좁히기 위한 또 다른 방법이 필요합니다: 데이터 유효성 검사.\n\n# Zod가 도와줍니다\n\nZod는 기본적으로 객체 스키마 유효성 검사 도구입니다. 이는 정의된 스키마를 가진 모든 객체의 유효성을 런타임에서 보장할 수 있다는 뜻이에요.\n\n## 스키마 선언\n\n\n\nZod을 사용할 때 첫 번째 할 일은 스키마를 정의하는 것입니다.\n\n```js\nimport * as z from \"zod\";\n\nconst userSchema = z.object({\n    id: z.number(),\n    name: z.string(),\n    age: z.number().optional()\n}).strict();\n```\n\n만약 이전에 yup이나 joi와 같은 유효성 검사 도구를 사용해본 적이 있다면, 이 방법에 익숙할지도 모릅니다. Zod은 object(), string()과 같은 여러 함수를 제공하며, 각 함수는 Zod 스키마를 반환하고 이를 조합하여 더 큰 스키마를 만들 수 있습니다.\n\n각 스키마 조각은 .optional()과 같은 메소드를 사용하여 \"새롭게 정의\"될 수 있으며, 이를 통해 복잡한 유효성 검사 규칙을 얻을 수 있습니다.\n\n\n\n## 스키마 사용하기\n\n스키마는 데이터를 유효성 검사하는 두 가지 방법을 제공합니다. .parse() 메서드는 에러를 throw할 수 있고, .safeParse() 메서드도 그렇습니다:\n\n```js\nconst result = userSchema.safeParse(input);\nif (!result.success) {\n  result.error;\n} else {\n  result.data; // 데이터 유형은 userSchema에서 유추됩니다\n}\n```\n\n파싱이 실패하거나 정의된 유효성 검사 스키마와 일치하는 객체가 반환됩니다. 이 경우 객체는 스키마 구조에서 추론된 유형을 상속받습니다.\n\n\n\n## 스키마로부터 타입 추론하기\n\n일반적으로 데이터는 여러 범위와 문맥에서 공유됩니다. 이러한 이유로 우리는 보통 한번만 타입 별칭을 선언하고 나서 데이터가 전달되는 모든 곳에서 사용합니다. Zod는 z.infer`` 제네릭을 제공하여 스키마에서 추론된 타입에 액세스할 수 있습니다.\n\n```js\ntype Article = z.infer<typeof articleSchema>;\n```\n\n# Zod 실용적 사용법\n\n\n\n따라서, TypeScript 프로젝트에서 Zod를 사용하는 경우는 어디인가요?\n\n## API 응답 구문 분석\n\n알 수 없거나 예측할 수 없는 데이터의 주요 원천은 API 응답입니다. fetch promise에서 오는 데이터를 수동으로 유효성을 검사할 수 있습니다.\n\n```js\nfetch(getArticle)\n  .then((response) => response.json())\n  .then((data) => {\n    return articleSchema.parse(data);\n  })\n  .catch(console.error);\n```\n\n\n\n테이블 태그를 Markdown 형식으로 변경할 수도 있어요. \n\n## 양식 데이터 유효성 검사\n\n사용자 입력 또한 외부 데이터의 하나이죠. Zod는 문자열 유효성 검사를 위한 내장 유틸리티를 제공해요. 물론, .refine() 메서드를 사용하여 자신만의 규칙을 구현할 수도 있어요.\n\n```js\nconst myString = z.string().refine((val) => val.length <= 255, {\n  message: \"문자열은 255자를 초과할 수 없어요\",\n});\n```\n\n\n\n만약 React를 사용 중이라면, React Hook Form에서 양식 유효성 검사를 위해 Zod 스키마를 사용할 수 있어요.\n\n## 구분하는 유형?\n\n저는 버전 1부터 Zod를 사용하기 시작했어요. 이 버전에는 .check() 메서드가 포함되어 스키마를 유형 가드로 사용할 수 있게 되었는데, 이는 유형을 구분하는 조건으로 사용될 수 있었어요.\n\n이 기능 때문에 “full-schema\" 접근 방식을 선택하고 Zod를 유효성 검사 및 유형 구분 모두에 사용하게 되는 것이 유혹스러웠어요. 그러나 이 방식을 취하는 것은 빠르게 시간이 낭비되는 것으로 나타났어요.\n\n\n\n해당 메서드는 라이브러리의 다음 버전에서 삭제되었습니다. 이것은 좋은 일이에요. 왜냐하면 Zod는 이제 외부 데이터 유효성 검사에 집중하고 있거든. 타입 축소 표현은 대부분의 상황에서 충분히 유용해서 타입 판별에 좋은 도구가 됐어요.\n\n# 요약\n\nTypeScript는 기본적으로 너무 관대해요. 더 안전한 코드를 작성하려면 외부 데이터(본질적으로 알 수 없는 데이터)를 Zod와 같은 도구로 유효성을 검사해야 해요. Zod는 폼 입력이나 API 응답과 같이 예측할 수 없는 데이터를 유효성 검사하는 데 가장 유용해요. 그 외의 대부분의 시나리오에서는 타입 축소 표현만으로 충분할 거에요.","ogImage":{"url":"/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png"},"coverImage":"/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png","tag":["Tech"],"readingTime":5}],"page":"109","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}