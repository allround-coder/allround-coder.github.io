{"pageProps":{"posts":[{"title":"전략 패턴 NET C","description":"","date":"2024-06-20 04:08","slug":"2024-06-20-StrategyPatternNETC","content":"\n\n전략(pattern) 패턴은 알고리즘의 동작을 런타임(runtime)에서 선택할 수 있게 해주는 행동 디자인 패턴입니다. 주요 아이디어는 알고리즘의 집합을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만드는 것입니다. 전략(pattern) 패턴은 알고리즘을 사용하는 클라이언트로부터 독립적으로 알고리즘을 변경할 수 있게 합니다.\n\n## 구성 요소\n\n- 컨텍스트(Context): Strategy 인스턴스에 대한 참조를 포함하는 클래스입니다. 이는 전략(strategy)이 작동하는 방법의 세부 정보를 이해하지 않고도 작업의 실행을 전략(strategy)의 구현에 위임합니다.\n- 전략(strategy) 인터페이스: 이는 모든 구체적인 전략(strategy)들을 위한 공통 인터페이스를 정의합니다. 컨텍스트가 전략을 실행하는 데 사용하는 메서드를 선언합니다.\n- 구체적인 전략(strategy): 전략(strategy) 인터페이스를 구현하는 개별 클래스입니다. 각각은 다른 알고리즘이나 작업 수행 방법을 나타냅니다.\n\n## 원칙과 정책\n\n<div class=\"content-ad\"></div>\n\n- 변이의 캡슐화: 전략 패턴은 알고리즘의 변하는 부분을 유지되는 부분과 캡슐화합니다. 이는 알고리즘의 변경이 클라이언트 코드에 영향을 미치지 않는다는 것을 의미합니다.\n- 인터페이스에 프로그래밍, 구현에 프로그래밍하지 말기: 클라이언트는 구현이 아닌 인터페이스를 통해 전략과 상호작용합니다. 이는 클라이언트 코드가 인터페이스를 구현하는 어떤 전략과도 작동할 수 있다는 것을 의미합니다.\n- 상속보다 구성을 선호: 상속하는 대신 전략 패턴은 구성을 사용하여 책임을 전략 객체에 위임합니다. 이는 적절한 동작을 선택하는 더 많은 유연성을 제공합니다.\n- 개방/폐쇄 원칙: 시스템은 확장을 위해 열려 있지만 수정에 대해 폐쇄되어야 합니다. 새로운 전략을 추가할 때 콘텍스트나 클라이언트 코드가 시스템을 사용하는 방식을 변경하지 않아도 됩니다.\n- 단일 책임 원칙: 각 전략 클래스는 특정 알고리즘이나 동작을 나타내는 단일 책임이 있습니다. 이로 인해 이해하기 쉽고 구현하고 테스트하기 쉽습니다.\n\n이러한 원칙을 따르면 전략 패턴은 다양한 알고리즘이나 동작을 처리하는 유연한 구조를 제공하여 애플리케이션의 기능적 부분을 관리, 확장 및 수정하기 쉽도록 만들어줍니다.\n\n# 결제 처리 시스템\n\n크레딧 카드, PayPal 또는 암호화폐와 같이 다양한 결제 전략이 필요한 결제 처리 시스템을 고려해 봅시다. 결제 전략은 종종 변경되거나 추가가 필요할 수 있어 전략 패턴에 적합한 사용 사례입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-StrategyPatternNETC_0.png\" />\n\n# 전략 패턴 없이\n\n초기에 시스템은 신용카드 결제만 지원할 수 있으므로 직접 클래스 내에 구현할 수 있습니다.\n\n```js\npublic class PaymentProcessor\n{\n    public void ProcessPayment(decimal amount, string method)\n    {\n        if (method == \"CreditCard\")\n        {\n            // 신용카드 결제 처리 로직\n            Console.WriteLine($\"신용카드를 통한 {amount} 처리 중\");\n        }\n    }\n}\n\n// 사용법\nvar paymentProcessor = new PaymentProcessor();\npaymentProcessor.ProcessPayment(100.00m, \"CreditCard\");\n```\n\n<div class=\"content-ad\"></div>\n\n이제 PayPal을 결제 방법으로 추가해야 한다고 가정해 보겠습니다. PaymentProcessor 클래스를 수정하여 다른 if-else 조건을 추가해야 할 수 있습니다.\n\n```js\npublic class PaymentProcessor\n{\n    public void ProcessPayment(decimal amount, string method)\n    {\n        if (method == \"CreditCard\")\n        {\n            // 신용카드 결제 처리 로직\n            Console.WriteLine($\"신용카드로 {amount} 처리중\");\n        }\n        else if (method == \"PayPal\")\n        {\n            // PayPal 결제 처리 로직\n            Console.WriteLine($\"PayPal로 {amount} 처리중\");\n        }\n        // 새 결제 방법을 추가할 때마다 더 많은 if-else 문이 여기에 추가됩니다.\n    }\n}\n\n// 사용 예\nvar paymentProcessor = new PaymentProcessor();\npaymentProcessor.ProcessPayment(100.00m, \"CreditCard\");\npaymentProcessor.ProcessPayment(75.50m, \"PayPal\");\n```\n\n## 이 접근 방식의 문제점\n\n- 확장성: 새 결제 방법마다 ProcessPayment 메서드에 더 많은 if-else 조건을 추가해야 하므로, 메서드는 무한정으로 커지게 됩니다.\n- 유지보수성: 시간이 흐르면서 ProcessPayment 메서드는 점점 복잡해지고 관리하기 어려워집니다.\n- 개방/폐쇄 원칙 위반: 이 클래스는 수정을 열어둔 상태입니다. 새로운 결제 유형을 추가할 때마다 이 클래스를 수정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 전략 패턴 사용하기\n\n자, 이제 코드를 전략 패턴을 사용하도록 리팩토링해보겠습니다. 이렇게 하면 더 유연하고 유지보수하기 쉬워집니다.\n\n## 전략 인터페이스\n\n```js\npublic interface IPaymentStrategy\n{\n    void ProcessPayment(decimal amount);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 구체적인 전략\n\n```js\npublic class CreditCardPaymentStrategy : IPaymentStrategy\n{\n    public void ProcessPayment(decimal amount)\n    {\n        // 신용 카드 결제 처리 로직\n        Console.WriteLine($\"신용 카드로 {amount} 처리 중\");\n    }\n}\n\npublic class PayPalPaymentStrategy : IPaymentStrategy\n{\n    public void ProcessPayment(decimal amount)\n    {\n        // PayPal 결제 처리 로직\n        Console.WriteLine($\"PayPal로 {amount} 처리 중\");\n    }\n}\n```\n\n## 컨텍스트 클래스\n\n```js\npublic class PaymentProcessor\n{\n    private IPaymentStrategy _paymentStrategy;\n\n    public PaymentProcessor(IPaymentStrategy paymentStrategy)\n    {\n        _paymentStrategy = paymentStrategy;\n    }\n\n    public void SetPaymentStrategy(IPaymentStrategy paymentStrategy)\n    {\n        _paymentStrategy = paymentStrategy;\n    }\n\n    public void ProcessPayment(decimal amount)\n    {\n        _paymentStrategy.ProcessPayment(amount);\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 사용법\n\n```js\nvar creditCardPayment = new PaymentProcessor(new CreditCardPaymentStrategy());\ncreditCardPayment.ProcessPayment(100.00m); \n// 출력: 신용 카드로 100.00 처리 중\n\nvar payPalPayment = new PaymentProcessor(new PayPalPaymentStrategy());\npayPalPayment.ProcessPayment(75.50m); \n// 출력: PayPal로 75.50 처리 중\n```\n\n전략 패턴의 맥락에서 새 결제 방법을 추가하는 것은 간단한 프로세스이며 기존 코드를 변경할 필요가 없기 때문에 이 패턴의 주요 이점 중 하나입니다.\n\n기존 시스템에 새로운 암호화폐 결제 전략을 추가하는 방법을 살펴보고 이 접근 방식이 기능 확장을 어떻게 단순화하는지 비교해봅시다.\n\n<div class=\"content-ad\"></div>\n\n## 암호화폐 결제 전략 추가하기\n\nIPaymentStrategy 인터페이스를 구현하는 클래스를 생성하여 새로운 구체적인 전략을 정의하세요.\n\n```js\npublic class CryptoPaymentStrategy : IPaymentStrategy\n{\n    public void ProcessPayment(decimal amount)\n    {\n        Console.WriteLine($\"암호화폐를 통한 {amount} 처리 중\");\n        // 실제 암호화폐 처리 로직\n    }\n}\n```\n\n새 전략을 사용하는 방법은 새 CryptoPaymentStrategy로 PaymentProcessor를 인스턴스화하는 것만으로 간단합니다.\n\n<div class=\"content-ad\"></div>\n\n```javascript\nvar cryptoPayment = new PaymentProcessor(new CryptoPaymentStrategy());\ncryptoPayment.ProcessPayment(50.00m); \n// 출력: 50.00을(를) 암호화폐를 통해 처리 중\n```\n\n전략 패턴의 맥락에서 새로운 지불 전략을 추가함으로써, 해당 패턴이 변경과 확장을 효율적으로 다루는 능력을 보여줍니다. 이를 통해 새로운 기능을 기존 코드베이스에 영향을 주지 않고 매끄럽게 추가할 수 있어서 버그 도입 위험을 크게 줄이고 시스템을 더 관리 가능하고 확장 가능하게 만들 수 있습니다.\n\n## 전략 패턴 사용의 장점\n\n- 확장 용이성: IPaymentStrategy 인터페이스를 구현하는 새 클래스를 만들기만 하면 됩니다. 기존 코드를 수정할 필요가 없습니다.\n- 개방/폐쇄 원칙 준수: 시스템은 확장을 위해 열려 있지만 수정은 닫혀 있습니다. 기존 클래스를 변경하지 않고 새로운 지불 전략을 추가할 수 있습니다.\n- 간결함과 유지보수성: PaymentProcessor 클래스는 간단한 상태를 유지하며 새 지불 방법이 추가될수록 복잡성이 증가하지 않습니다. 각 지불 방법은 자체 클래스에 캡슐화되어 있어 시스템을 이해하고 유지하기 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n이 정보가 유용했길 바랍니다. 🌟 즐거우면서도 풍부한 학습 여정을 희망합니다!\n\n📚 이와 같은 통찰력을 더 원하신다면, 자유롭게 👉 Merwan Chinta를 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-06-20-StrategyPatternNETC_0.png"},"coverImage":"/assets/img/2024-06-20-StrategyPatternNETC_0.png","tag":["Tech"],"readingTime":6},{"title":"좋은 이름을 선택하기 위한 7단계 치트 시트","description":"","date":"2024-06-20 04:06","slug":"2024-06-20-My7-StepCheatSheetforChoosingGoodNames","content":"\n\n뭔가 이름 짓기는 결코 쉬운 일이 아니었죠. 특히 개발자들에게!\n\n![이미지](/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_0.png)\n\n변수, 클래스, 함수 및 기타 코드 요소에 선택한 이름은 의미 있는, 정확한 및 쉽게 이해할 수 있는 이름이어야 하기 때문에 이름 짓는 것은 어려운 작업으로 간주될 수 있습니다.\n\n코드베이스를 깨끗하고 유지보수 가능하게 유지하기 위해서는 좋고 일관된 이름 규칙이 필수적입니다. 시스템이 커짐에 따라 새로운 이름이 기존 이름과 충돌하지 않도록 보장하는 것이 어려울 수 있기 때문에 이것은 도전적일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 코드 이름을 선택할 때 고려해야 할 사항에 대한 체크리스트를 살펴보겠습니다. 이 목록에는 저의 개인적인 통찰과 Uncle Bob 및 Eric Evans와 같은 유명한 저자들의 아이디어가 포함되어 있습니다.\n\n## 1. 의도 및 측정 단위\n\n선택한 이름은 요소의 의도 및 기능뿐만 아니라 해당되는 측정 단위도 명확히 전달해야 합니다. 이렇게 함으로써 코드를 작성하는 사람뿐만 아니라 나중에 코드를 읽거나 수정해야 하는 다른 사람에게도 코드를 이해하고 유지할 수 있도록 도와줄 것입니다.\n\n반면에 지나치게 짧은 변수 이름이나 믿을 수 없는 약어의 사용은 관련된 모든 사람들에게 코드의 가독성과 이해도를 크게 해치게 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\npublic double calculateBmi(double m, double h) {\n    double sh = h * h;\n    double mKg = m * 0.453d;\n    return mKg / sh;\n}\n```\n\n위 코드 스니펫을 보기 좋게 개선할 수 있습니다. 변수에 적절한 이름을 선택하면 코드의 가독성이 크게 향상됩니다:\n\n```js\npublic static final double LBS_TO_KG = 0.453d;\n\npublic double calculateBmi(double massInLbs, double heightInMeters) {\n    double squaredHeight = heightInMeters * heightInMeters;\n    double massInKg = massInLbs * LBS_TO_KG;\n    return massInKg / squaredHeight;\n}\n```\n\n## 2. Avoid Noise Words\n\n\n<div class=\"content-ad\"></div>\n\n한번 웃어보세요! 자바 애플리케이션을 위한 클래스 이름을 생성해주는 재밌는 웹사이트가 있어요. \"enterprisify\"를 몇 번 클릭해보세요! 이런 생성된 이름들은 '소음 단어'로 이루어져 있어요. 이것은 의도를 표현하지 않는 기술 용어들이에요.\n\n클래스 이름에 소음 단어를 사용하면 코드를 이해하기 어려울 수 있어요. AccountData와 Account 클래스와 다른 점을 알고 계신가요?\n\n그러면 AccountSummary가 더 나은 선택이 될 수도 있어요.\n\n그리고 AccountDto나 AccountEntity는 어떨까요?\n\n<div class=\"content-ad\"></div>\n\n“Data”라는 노이즈 단어는 추가 정보를 제공하지 않아요. 하지만 때로는 클래스 이름을 지을 때 기술 용어를 사용해서 클래스의 위치나 구현을 나타낼 수 있어요. 예를 들어, Service, Dto, Entity, Repository와 같은 접미사를 사용할 수 있어요.\n\n![이미지](/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_1.png)\n\n## 3. 데이터 유형 및 키워드 피하기\n\n데이터 유형 역시 \"노이즈 단어\"로 간주될 수 있어요. 몇 가지 예시는 다음과 같아요:\n\n<div class=\"content-ad\"></div>\n\n```js\n기록 PromotionRecord (\n    // ...\n){}\n\n추상 클래스 AbstarctPromotion {\n  // ...\n}\n\nOffsetDateTime startOffsetDateTime;\n\nList<Account> listOfAccounts;\n```\n\n동일하게 인터페이스와 그 구현에 대한 특별한 명명 패턴은 안티 패턴으로 간주될 수 있습니다. 흔히 사용되는 방법은 인터페이스에 \"I\"를 접두사로 붙이고 클래스에 \"Impl\" 접미사를 붙이는 것입니다:\n\n```js\ninterface ICustomerDetailsProvider {}\n\nclass CustomerDetailsProviderImpl implements ICustomerDetailsProvider {}\n```\n\n그럼 정말 인터페이스가 필요한 이유는 무엇일까요? 대부분의 경우 인터페이스를 두 가지 경우 중 하나에서 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- 의존 역전(Dependency Inversion): 인터페이스는 도메인 레이어의 일부이며 구현은 인프라스트럭처 레이어의 코드를 사용하는 어댑터처럼 작동합니다.\n예를 들어, 도메인 레이어의 일부로 CustomerDetailsProvider 인터페이스를 가질 수 있고, 해당 구현은 네트워크 호출을 통해 고객에 대한 특정 데이터를 가져옵니다. 만약 해당 구현을 \"CustomerDetailsProviderImpl\"이라고 명명한다면 \"Impl\" 접미사는 가치를 추가하지 않을 것입니다. 대신, \"CustomerDetailsApiClient\" 또는 \"CustomerApiAdapter\"와 같이 데이터가 어떻게 가져와지는지에 대한 힌트를 제공해줄 것입니다.\n- 다형성(Polymorphism): 다형성을 위해 인터페이스를 사용한다면, 최소 두 가지 이상의 명확히 구분된 구현이 있어야 합니다. 예를 들어, \"Payment\" 인터페이스와 다른 결제 방법을 위한 다양한 구현이 있다면 구현은 매우 다르며 의미 있는 이름을 가져야 합니다: \"CashPayment\", \"VisaPayment\", \"OnlinePayment\" 등.\n\n## 4. 길이 대 무게\n\n변수 이름을 짓는 경우, 이름의 길이는 변수의 범위와 직접적으로 비례해야 합니다. 따라서 작은 범위의 경우, 단일 작은 단어나 약어가 충분합니다. Uncle Bob은 더 나아가서 매우 작은 범위(한 줄짜리 코드와 같은)에는 하나의 글자 이름조차 충분하다고 말합니다.\n\n```js\n// 작은 범위\nfor(Employee employee : employeesEligibleForPromotion) {\n    // 4-5 줄의 코드\n}\n\n// 매우 작은 범위\nemployeesEligibleForPromotion.stream()\n    .map(e -> e.getName().toLowerCase())\n    .forEach(this::sendNotificationToHrDepartment);\n```\n\n<div class=\"content-ad\"></div>\n\n더 긴 범위에 따라, 변수 이름도 길어집니다. 하지만 변수 이름이 너무 길어진다면, 이는 코드 향기의 지표일 수 있습니다: 함수가 너무 커졌다는 것을 의미할 수 있습니다.\n\n예를 들어, 위의 코드 스니펫에서 직원 목록에 대해 꽤 긴 이름을 사용했죠: employeesEligibleForPromotion. 이는 함수의 범위가 크거나 동일한 범위 내에 다른 직원 목록이 있음을 의미할 수 있습니다. 어쨌든, 기능을 추출할 수 있습니다:\n\n```js\npublic void sendNotificationToHrForEmployees(List<Employees> employees) {\n    employees.stream()\n      .map(e -> e.getName().toLowerCase())\n      .forEach(this::sendNotificationToHrDepartment);\n}\n```\n\n우리가 볼 수 있듯이, 함수를 추출하고 변수의 범위를 작게 만들면 이름을 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n함수를 명명할 때는 범위가 길수록 이름을 작고 추상적으로 지어야 합니다. 이는 우리가 상위 수준의 함수가 구현 세부 정보를 누설하지 않도록 원하기 때문입니다. 따라서 범위가 작은 함수는 이름이 더 길어질 것입니다.\n\n## 5. 일관성\n\n일관된 명명 규약은 다른 사람들이 작성한 코드를 탐색하고 이해하기 쉽게 만들어줍니다. 특히 대규모 공동 작업 프로젝트에서 이는 중요합니다. 또한, 일관성은 명명 충돌을 방지하고 코드에 버그나 오류가 도입되는 가능성을 줄일 수 있습니다.\n\n동일한 작업에 대해 다른 동사를 사용하지 않도록 주의하세요: 구현이 동일한 경우 fetch, retrieve, get 및 find를 서로 교차적으로 사용하지 마세요. 동시에 다른 구현이나 개념에 대해 서로 다른 단어를 선택해야 합니다. 예를 들어, \"find\" 동사를 사용하여 Optional 또는 nullable 데이터를 반환할 수 있지만, 데이터가 누락된 경우에는 \"get\"이 항상 예외를 throw합니다.\n\n<div class=\"content-ad\"></div>\n\n## 6. 비즈니스 용어 vs. 기술 용어\n\n비즈니스 용어와 기술 용어는 우리에게 적절한 이름을 선택하는 데 도움을 줄 수 있습니다. Clean Code에서 Uncle Bob은 기술 용어가 다른 개발자들에 의해 쉽게 이해될 수 있기 때문에 우선적으로 고려해야 한다고 제안합니다. Adapter, Builder, Repository, Dto와 같은 용어는 컴포넌트의 구현이나 위치를 나타낼 수 있습니다.\n\n반면에 Eric Evan의 도메인 주도 설계는 비즈니스 언어를 받아들이는 것이 복잡한 도메인 모델을 가진 대규모 시스템에서 도움이 된다고 가르쳐줍니다. 이는 개발자와 비즈니스 담당자 간의 커뮤니케이션 간극을 크게 줄일 수 있습니다.\n\n전반적으로, 컴포넌트에 이름을 선택할 때 비즈니스 용어와 기술 용어 모두 좋은 후보가 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 7. 동사 vs. 명사\n\n약칭으로는, 함수에는 동사를 사용하고 필드 및 변수에는 명사를 사용해야 합니다.\n\n대부분의 경우 클래스에는 명사를 사용할 것이지만 몇 가지 특별한 경우가 있을 수 있습니다. 예를 들어, \"세로 슬라이스\" 디자인을 사용하는 경우 사용 사례를 나타내는 클래스를 가질 수 있습니다. 이러한 클래스는 CreateAccount, DisableAcount, ApplyPromotion과 같은 이름을 가질 것입니다.\n\n인터페이스는 모두 메서드와 동작에 관한 것입니다. 인터페이스 이름을 정할 때에는 명사를 사용해야 하지만, 동시에 그들이 가능하게 하는 행동을 명확하게 표현해야 합니다. 예를 들어 Clonable, Runnable, Executable, DataProvider 등이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n이 글에서는 좋은 이름을 선택하기 위한 7단계 체크리스트를 살펴보았습니다. 우리는 의도 표현, 측정 단위, 그리고 \"잡음 단어\" 피하기에 대해 처음에 논의했습니다. 그 후에는 이름의 길이, 일관성, 그리고 사용할 수 있는 단어 유형에 대해 배웠습니다.\n\n![링크](/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_2.png)\n\n# 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n기사를 읽어 주셔서 감사합니다! 의견을 주시면 감사하겠습니다. 어떠한 피드백이든 환영입니다.\n\n프로젝트 이름을 선택할 때 꼭 지켜야 할 사항과 지켜야 할 규칙에 대한 .svg 치트 시트를 만들었습니다. 이 글에서 논의한 내용을 간결하게 요약한 것입니다. 제 콘텐츠가 마음에 들고, 이 치트 시트를 이메일로 받고 싶다면, 이메일 구독을 고려해 주세요.\n\n즐거운 코딩 시간 보내세요!\n\n# 레벨업 코딩\n\n<div class=\"content-ad\"></div>\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 👏 스토리에 박수를 보내고 저자를 팔로우하세요 👉\n- 📰 Level Up Coding 게시물에서 더 많은 콘텐츠를 확인하세요\n- 🔔 팔로우하기: Twitter | LinkedIn | Newsletter\n\n🚀👉 Level Up 재능 동호회에 가입하여 멋진 취업 기회를 찾아보세요","ogImage":{"url":"/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_0.png"},"coverImage":"/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_0.png","tag":["Tech"],"readingTime":7},{"title":"V8 엔진 시리즈 I 아키텍처","description":"","date":"2024-06-20 04:04","slug":"2024-06-20-TheV8EngineSeriesIArchitecture","content":"\n\n![V8 Engine Series Architecture](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_0.png)\n\n# 소개\n\nV8은 현대 웹 브라우저에서 JavaScript와 WebAssembly을 실행하기 위해 Google에서 개발한 오픈 소스 고성능 엔진입니다. 현대 웹에서는 Google Chrome과 Node.js에서 사용되며, 클라이언트 및 서버 측에서 JavaScript가 빠르게 실행되도록 보장합니다. C++로 작성되어 있으며, 코드 실행 속도를 현저히 향상시킵니다. 최신 및 고급 Just-In-Time (JIT) 컴파일 기술의 도움을 받아 JavaScript 코드를 컴파일하여 빠른 시작과 높은 실행 속도를 결합하는 방법을 제공합니다. 이 논문에서는 V8 아키텍처와 운영 측면을 설명하여 추가로 이해할 수 있도록 합니다.\n\n이 시리즈에서는 V8 엔진의 내부 아키텍처를 탐구하며, 개요부터 시작하여 각 구성 요소를 자세히 살펴보고 기술적 세부 사항을 설명할 것입니다. 시리즈가 끝나면 V8 엔진을 사용하여 Node.js와 유사한 것을 간소화된 버전으로 만들 것입니다. V8를 통해 정보를 얻고 실용적인 여정을 계속 따라와 주세요!\n\n<div class=\"content-ad\"></div>\n\n# V8 아키텍처의 주요 구성 요소\n\n## 1. 파서\n\nV8 아키텍처의 첫 번째 구성 요소는 파서입니다. 이는 JavaScript 소스 코드를 가져와서 추상 구문 트리(Abstract Syntax Tree, AST)로 변환합니다. 이 트리는 코드의 구조에 따라 계층적으로 표현되며, V8에서 코드를 쉽게 조작하고 최적화할 수 있도록 합니다.\n\n## 2. 이그니션 인터프리터\n\n<div class=\"content-ad\"></div>\n\n이그니션은 V8 내부의 낮은 수준에서 작동하는 가벼운 인터프리터입니다. 이는 AST를 바이트코드로 컴파일하여 자바스크립트 소스 코드의 고효율 표현으로 작용합니다. 이것은 고수준 자바스크립트와 저수준 머신 코드 사이의 다리 역할을하며 보다 효율적으로 실행됩니다.\n\n## 3. TurboFan 컴파일러\n\nTurboFan은 V8의 최적화 컴파일러입니다. 이는 Ignition에서 생성된 바이트 코드를 고도로 최적화 된 머신 코드로 컴파일합니다. 따라서 TurboFan은 런타임 피드백을 기반으로 여러 최적화를 수행하여 더 높은 성능을 제공하기 위해 함수 인라인화 및 죽은 코드 제거 등의 최적화를 더 고급 수준에서 수행합니다.\n\n# 자세한 V8 아키텍처\n\n<div class=\"content-ad\"></div>\n\n## 1. 파싱\n\n자바스크립트 코드를 실행하기 전에 V8 파서가 동작합니다. 파싱은 소스 코드를 추상 구문 트리 (AST) 구조로 변환하는 과정으로, 소스 코드의 구문을 유지합니다.\n\n![이미지](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_1.png)\n\n이는 사람이 읽을 수 있는 코드를 엔진이 올바르고 효과적으로 사용할 수 있도록 만들기 때문입니다. V8는 JavaScript를 해석하지 않습니다. V8와 같은 엔진에서 제대로 실행되려면 이 형태여야 합니다.\n\n<div class=\"content-ad\"></div>\n\nAST는 여러 이유로 필수입니다:\n\n- 코드 이해: 소스 코드의 구조화된 트리 형태 표현은 V8가 코드를 더 쉽게 이해하고 조작할 수 있도록 돕습니다.\n- 최적화: V8의 이 측면은 상수 폴딩, 죽은 코드 제거, 또는 함수 인라인 등의 다양한 최적화 기술을 적용하여 더 나은 성능을 지원합니다.\n- 도구 및 분석: JavaScript 코드를 분석하고 변환하여 개발 도구가 효율적이고 유지보수 가능한 코드를 작성할 수 있도록 돕습니다.\n\n다음 JavaScript 코드를 참고하십시오:\n\n```js\nconst chk = \"have it\";\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드는 다음과 같이 시각적으로 AST로 구문 분석됩니다:\n\n\n![image](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_2.png)\n\n\n## 2. 바이트 코드 생성 (Ignition)\n\n\n![image](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_3.png)\n\n\n<div class=\"content-ad\"></div>\n\nAST가 형성되면 Ignition은 이를 바이트코드로 컴파일합니다. 바이트코드는 원래의 JavaScript 소스보다 더 빠르게 실행되는 중간 코드 표현입니다. Ignition은 이 바이트코드를 계속 실행하여 V8의 최적화 컴파일러 TurboFan 내에서 효과적인 최적화를 위해 필요한 런타임 정보를 수집할 수 있게 합니다.\n\nIgnition은 V8와 JavaScript 함수를 짧고 매우 최적화된 바이트코드로 컴파일합니다. 이 바이트코드는 동등한 기본 기계 코드의 크기의 50~25% 사이입니다. 그런 다음 이 바이트코드는 고성능 인터프리터에 의해 실행되어 실제 웹사이트에서 V8의 기본 컴파일러가 생성한 코드에 근접한 실행 속도를 제공합니다.\n\nAST를 바이트코드로 변환하는 과정은 다음과 같습니다:\n\n- Traversal: Ignition은 AST를 통과하며 각 노드를 방문하여 해당하는 바이트코드 명령을 생성합니다.\n- 명령어 집합: 바이트코드는 V8에서 실행을 위해 최적화된 명령어 집합으로 구성됩니다.\n- 효율성: 바이트코드는 더 작고 더 효율적이므로 고수준 JavaScript 코드를 실행하는 것보다 더 빠르게 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n바이트코드 생성 후에 Ignition이 실행을 시작합니다. 이는 몇 가지 이유로 매우 중요한 실행 단계입니다:\n\n- 런타임 정보: Ignition은 바이트코드를 실행하는 동안 자주 호출되는 함수나 자주 액세스되는 속성 등의 런타임 정보를 수집합니다. 이 정보는 더 많은 최적화를 수행하는 데 매우 중요합니다.\n- 빠른 시작: Ignition은 원래 JavaScript 대신 바이트코드를 실행하므로 시작 속도가 더 빨라집니다. 빠른 시작은 사용자에게 즉시 반응해야 하는 앱에 대해 굉장히 중요합니다, 특히 브라우저나 서버 공간에서.\n\n바이트코드가 생성된 후 인라인 최적화를 거칩니다. 이러한 최적화는 코드의 바이트 스트림에서 단순 분석을 수행하며 일반적인 패턴을 더 빠른 시퀀스로 대체하고 중복된 작업을 제거하며 불필요한 레지스터로드 및 전송을 최소화합니다. 이러한 최적화는 바이트 코드의 크기를 줄이고 성능을 향상시킵니다. Ignition이 바이트코드를 실행하는 동안 캡처된 모든 정보는 최적화 단계에서 매우 중요합니다. 이에는 가장 자주 호출되는 함수, 반복적으로 액세스되는 속성, 그리고 서로 다른 객체가 사용되는 방식 등이 포함됩니다.\n\n## 3. 최적화 (TurboFan)\n\n<div class=\"content-ad\"></div>\n\n```html\n<img src=\"/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_4.png\" />\n```\n\nTurboFan는 JavaScript를 더 효율적으로 최적화된 기계 코드로 생성하기 위해 설계되었습니다. 이는 오래된 CrankShaft JIT 컴파일러를 대체하고 훨씬 더 복잡한 최적화를 제공합니다. TurboFan을 위한 두 가지 중요한 혁신은 중간 표현(IR) 사용과 다중 계층 최적화 파이프라인을 이용하는 것입니다.\n\n## TurboFan 작동 방식\n\n## 1. JavaScript에서 IR(Intermediate Representation)로\n\n<div class=\"content-ad\"></div>\n\nJavaScript 코드가 실행되면 먼저 AST가 파생됩니다. 그런 다음 TurboFan은 이 AST를 더 유연한 IR 구조로 변환하는데, 이를 \"노드의 바다\"라고 합니다. 이는 그래프 기반 IR이며, 따라서 TurboFan에서는 연산 간 복잡한 관계를 표현함으로써 많은 최적화를 수행할 수 있습니다.\n\n## 2. 최적화\n\nTurboFan 컴파일러는 IR에 여러 고급 최적화를 적용합니다:\n\n- 숫자 범위 분석: 이것은 TurboFan이 숫자 연산을 올바르게 이해하고, 불필요한 체크를 줄여 더 효율적으로 만듭니다.\n- 제어 흐름 최적화: 코드를 재배치하고 불필요한 명령을 제거하여, 루프 밖에서 자주 실행되지 않는 경로로 코드를 이동합니다.\n- 인라인 캐싱: 첫 번째 참조 후 객체 유형 및 속성을 캐싱하여 속성 액세스 속도를 높이며, 반복 액세스 시 유형 검사 및 찾아보기를 우회합니다.\n- 숨겨진 클래스: 숨겨진 클래스를 제공하여 객체의 속성 액세스를 매우 효율적으로 만들며, 속성이 추가될 때 객체를 변환합니다. 메모리 레이아웃을 예측하고 예측을 바탕으로 최적화된 코드를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. IR(Intermediate Representation)에서 머신 코드로\n\nTurboFan은 최적화된 IR을 가져와 머신 코드를 생성합니다. 이것은 CPU가 직접 실행하는 저수준 코드입니다. x86, ARM 및 MIPS와 같은 여러 하드웨어 아키텍처에서 효율적으로 실행되도록 코드를 만들기 위해 여러 컴파일 단계가 필요합니다.\n\nTurboFan의 컴파일은 다음 단계로 진행됩니다:\n\n- 명령 선택: TurboFan은 IR의 고수준 작업을 특정 머신 명령에 매핑합니다. 이 단계에서 생성된 코드가 대상 아키텍처의 명령 집합을 활용하도록 보장합니다.\n- 레지스터 할당: TurboFan은 변수에 대한 CPU 레지스터를 할당하여 메모리 접근을 최소화하고 그 과정에서 실행 시간을 가속화합니다. 사용 패턴 및 가용성에 따라 변수 저장을 위한 최상의 레지스터를 선택합니다.\n- 코드 생성: 이것이 이전 단계에서의 모든 최적화 및 적응을 포함한 결과 머신 코드일 것입니다. 따라서 이것이 CPU가 실행하는 실제 머신 코드입니다.\n\n<div class=\"content-ad\"></div>\n\n런타임 시, V8은 자바스크립트 코드 동작을 모니터링하여 자주 호출되는 함수 및 자주 액세스되는 속성에 대한 데이터를 수집합니다. 이 런타임 프로파일링을 통해 TurboFan은 최적화된 핫 코드 경로를 결정하고 가능한 한 효율적인 기계 코드로 변환합니다.\n\n함수 인라인화는 TurboFan에 의해 수행되는 강력한 최적화입니다. 자주 호출되는 함수일 경우 TurboFan은 해당 함수를 인라인으로 바꾸어 함수 호출을 실제 함수 본문으로 대체함으로써 호출 오버헤드를 제거하고 성능을 향상시킬 수 있습니다.\n\n또한 TurboFan은 런타임 프로파일링을 사용하여 실행되지 않은 코드를 제거함으로써 죽은 코드를 제거합니다. 이러한 코드를 제거함으로써 TurboFan은 생성된 기계 코드의 크기를 줄이고 실행 속도를 향상시킵니다.\n\n## TurboFan의 중요성\n\n<div class=\"content-ad\"></div>\n\n- 성능: TurboFan의 정교한 최적화로 JavaScript 코드가 더 빠르게 실행됩니다. 이는 웹 응용 프로그램에서 응답성이 중요한 경우와 효율성이 확장성과 비용에 중요한 영향을 미치는 서버 측 응용 프로그램에서 모두 중요합니다.\n- 최신 JavaScript 기능 지원: TurboFan은 모든 최신 JavaScript 기능 (ES6 이상)을 지원하도록 설계되었습니다. 유연한 설계로 새로운 언어 기능을 추가할 때 많은 아키텍처별 코드를 다시 작성할 필요가 없습니다.\n- 유지 관리성: TurboFan의 계층화된 아키텍처는 고수준 및 저수준 최적화를 분리함으로써 컴파일러의 설계를 간단하게 하고 유지 관리 및 확장을 용이하게 합니다.\n\n## TurboFan의 계층화된 아키텍처\n\n컴파일러는 새로운 기능을 지원하고 최적화를 추가하며 다른 아키텍처를 대상으로 할수록 복잡해집니다. TurboFan의 계층화된 아키텍처는 JavaScript(소스 레벨 언어), VM 기능(V8), 아키텍처 세부 사항(예: x86, ARM, MIPS) 사이에 명확한 분리를 만들어 이러한 요구 사항을 효과적으로 해결합니다.\n\n이러한 분리로 인해 최적화 및 기능 구현 시 엔지니어가 지역적으로 사고할 수 있어 더 견고하고 유지 보수가 쉬운 코드를 작성할 수 있습니다. 계층화된 접근 방식은 플랫폼별 코드가 필요한 양을 줄입니다. TurboFan이 지원하는 일곱 가지 대상 아키텍처 각각은 CrankShaft의 13,000-16,000 줄에 비해 3,000 줄 미만의 플랫폼별 코드를 필요로 합니다. 이 간소화된 설계는 ARM, Intel, MIPS, IBM 등의 엔지니어가 더 효과적으로 기여할 수 있도록 했습니다.\n\n<div class=\"content-ad\"></div>\n\nTurboFan은 CrankShaft보다 더 강력한 최적화를 구현하는 여러 가지 고급 기술을 통해 성능을 향상시킵니다. JavaScript는 최적화되지 않은 형태로 컴파일러 파이프라인에 들어가며 점진적으로 번역되어 낮은 형태로 최적화됩니다. TurboFan의 핵심은 코드의 조합을 더 효과적으로 재정렬하고 최적화할 수 있는 내부 표현(IR)인 '노드 바다'입니다.\n\n- 수치 범위 분석: 이 기능을 통해 TurboFan은 숫자 연산 코드를 더 잘 이해하여 보다 정확한 최적화를 수행할 수 있습니다.\n- 그래프 기반 IR: 대부분의 최적화는 간단한 지역적 축소로 표현되어 코드 작성 및 독립적 테스트가 더 쉬워집니다. 최적화 엔진은 이러한 지역 규칙을 체계적으로 적용합니다.\n- 혁신적인 스케줄링 알고리즘: 이 알고리즘은 코드를 루프에서 이탈하여 덜 자주 실행되는 경로로 이동할 수 있는 재정렬 자유도를 활용합니다.\n- 아키텍처별 최적화: 각 대상 플랫폼의 기능을 활용한 복잡한 명령 선택은 최상의 품질 코드를 생성합니다.\n\n## 현대 JavaScript 기능 지원\n\nTurboFan은 ES5에서 사용 가능한 모든 JavaScript 기능을 최적화하기 위해 설계되었으며 ES2015 및 이후 계획된 기능을 수용합니다. 계층별 컴파일러 설계는 고수준 및 저수준 컴파일러 최적화 사이에 깔끔한 분리를 제공하여 새로운 언어 기능을 추가할 때 아키텍처별 코드를 변경하지 않고 간단화합니다. TurboFan은 명시적 명령 선택 컴파일 단계를 도입하여 아키텍처별 코드가 더 필요하지 않도록 하며 컴파일러를 모든 지원되는 아키텍처에서 유지 관리 및 확장 가능하도록 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 개념을 이해한다면, 개발자는 현대 JavaScript 엔진의 복잡성을 인지하고 V8의 기능을 완전히 활용하는 코드를 작성할 수 있습니다. TurboFan의 혁신과 최적화는 V8 엔진의 필수 구성 요소로, 오늘날과 미래의 JavaScript 애플리케이션의 성능과 효율성을 촉진합니다.\n\n## 상세한 디옵티마이제이션\n\n디옵티마이제이션은 V8 엔진의 중요한 기능으로, 초기 가정이 변경되더라도 코드 실행이 올바른 상태로 유지되도록 보장합니다. 이것은 다음과 같은 과정을 포함합니다:\n\n- 모니터링: V8는 최적화된 머신 코드의 실행을 지속적으로 모니터링합니다.\n- 디옵티마이제이션 트리거: 런타임 환경이 변경되면(새로운 객체 유형을 만나거나 예상치 못한 실행 경로를 만나면), V8는 디옵티마이제이션의 필요성을 인식합니다.\n- 바이트코드로 되돌리기: V8는 그런 다음 Ignition에 의해 생성된 일반 바이트코드로 실행을 되돌립니다. 이는 안전하며 무효화된 가정에 기반하지 않습니다.\n- 재최적화: 되돌린 후에 새로운 패턴이 나타난 경우, V8는 코드를 다시 최적화할 수 있으며, 필요에 따라 최적화와 디옵티마이제이션의 사이클을 계속합니다.\n\n<div class=\"content-ad\"></div>\n\n## V8 프로세스 흐름\n\n![V8 엔진 시리즈I 아키텍처](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_5.png)\n\n- 코드 로딩: 엔진은 JavaScript 또는 WebAssembly 코드를 로드하여 시작합니다.\n- 구문 분석: 구문 분석기가 소스 코드를 AST로 변환합니다.\n- AST 변환: AST가 처리되고 Ignition에 전달됩니다.\n- 바이트코드 생성: Ignition이 AST를 바이트코드로 컴파일합니다.\n- 초기 실행: Ignition이 바이트코드를 실행하여 빠른 시작과 실행 시간 정보 수집을 보장합니다.\n- 런타임 피드백: 자주 사용되는 코드 경로 및 기타 런타임 데이터에 대한 정보가 수집됩니다.\n- 피드백 레이어: 런타임 피드백을 분석하여 최적화 기회를 결정합니다.\n- 최적화: TurboFan은 피드백 레이어의 정보를 사용하여 바이트코드를 머신 코드로 최적화합니다.\n- 실행: 최적화된 머신 코드가 실행되어 효율적이고 빠른 성능을 제공합니다.\n- 비최적화: 런타임 조건이 변경되어 최적화된 코드가 무효화되면 V8은 올바른 상태를 유지하기 위해 보다 최적화되지 않은 버전으로 되돌아갑니다.\n\n요약하면, V8 엔진의 아키텍처는 오늘날의 웹 애플리케이션에 중요한 빠른 시작과 고속 실행이 결합된 것을 보여줍니다. V8의 구성 요소와 상호 작용을 이해하면 엔진의 기능에 대한 소중한 통찰력을 제공받아 효율적이고 고성능의 JavaScript 코드를 작성하며 이 정교한 엔진의 가능성을 최대한 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사를 읽어 주셔서 감사합니다. 유익하고 흥미로운 내용이었기를 바랍니다. 이 시리즈에서 더 많은 내용이 기대되니 기대해 주세요.\n\n![image](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_6.png)\n\n질문이나 의견이 있으시면 언제든지 말씀해 주세요! 도와드리기 위해 언제나 준비되어 있으며 여러분의 생각을 듣고 싶습니다. 😊","ogImage":{"url":"/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_0.png"},"coverImage":"/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_0.png","tag":["Tech"],"readingTime":9},{"title":"HMPL  API를 통해 HTML을 가져오는 새로운 템플릿 언어","description":"","date":"2024-06-20 03:41","slug":"2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI","content":"\n\n\n![이미지](/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_0.png)\n\n이 글에서는 HMPL이라고 불리는 새로운 템플릿 언어에 대해 이야기하겠습니다. 이 언어를 사용하면 API에서 HTML을 쉽게 불러올 수 있어 굉장히 많은 불필요한 코드를 줄일 수 있습니다.\n\nhmpl.js의 주요 목표는 작은 요청 구조를 HTML에 통합하여 서버 작업을 간단하게 만드는 것입니다. 이는 php 확장자가 있는 파일에서 php 요청을 통해 서버로부터 받은 응답을 처리하는 방식과 비교될 수 있지만 동시에 javascript를 통해 직접적으로 처리할 수 있는 방법을 제공합니다. 단순히 버튼에서 제목을 가져오는 예를 통해 이 템플릿 언어가 귀하의 작업을 단순화할 수 있는 방법을 이해할 수 있습니다.\n\n이 템플릿 언어를 이용하면 지정된 문자열 템플릿을 반복할 수 있습니다. 코드로 표현하면 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { compile } from \"hmpl-js\";\nconst templateFn = compile(\n   `<div>\n     <request src=\"/api/test\"></request>\n   </div>`\n);\n\nconst wrapper = document.getElementById(\"wrapper\");\nconst obj1 = templateFn();\n\nconst obj2 = templateFn();\n\nwrapper.appendChild(obj1.response);\nwrapper.appendChild(obj2.response);\n```\n\n이 모듈은 최신 JS 도구를 사용하여 서버와 작업할 수 있도록 fetch API에 기반을 둔 것입니다.\n\nfetch API와 상호작용하려면 RequestInit 유형을 기반으로 한 설정 객체도 생성되었습니다. 예시 코드:\n\n```js\nconst elementObj = templateFn({\n  method: \"POST\",\n  mode: \"cors\",\n  cache: \"no-cache\",\n  credentials: \"same-origin\",\n  headers: {\n    \"Content-Type\": \"text/html\",\n  },\n  redirect: \"follow\",\n  get: (prop, value) => {},\n  referrerPolicy: \"no-referrer\",\n  body: JSON.stringify(data),\n  signal: new AbortController().signal,\n  integrity: \"…\",\n  window: null,\n  refferer: \"about:client\",\n});\n```\n\n<div class=\"content-ad\"></div>\n\n템플릿 언어의 구문 자체로 .hmpl 확장자 파일을 사용하여 실용적이고 이해하기 쉬운 프로젝트 파일 구조를 만들고 일반 HTML과 \"모듈화된\" HTML을 분리하는 것이 가능합니다.\n\n![이미지](/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_1.png)\n\n해당 모듈은 매우 작은 크기입니다 (버전 1.0.9). npm에서 100킬로바이트 미만을 차지합니다. 미니파이된 파일 자체도 더욱 가벼워집니다.\n\n![이미지](/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_2.png)\n\n<div class=\"content-ad\"></div>\n\n아래는 작업을 더욱 쉽게 수행할 수 있는 여러 연결 옵션이 있는 모듈입니다:\n\n```js\n<script src=\"https://unpkg.com/hmpl-js/dist/hmpl.min.js\"></script>\n```\n\n또는\n\n```js\n{\n  \"dependencies\": {\n    \"hmpl-js\": \"latest\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n웹팩 구성 파일\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.hmpl$/i,\n        use: [\"hmpl-loader\"],\n      }\n    ]\n  }\n}\n```\n\n모듈에 대한 간단한 프로젝트 예시:\n\n<div class=\"content-ad\"></div>\n\nhttps://github.com/hmpljs/examples\n\n다른 유용한 링크:\n\n- https://hmpljs.github.io\n- https://github.com/hmpljs/hmpl-loader\n- https://github.com/hmpljs/hmpl\n- https://www.youtube.com/@antonmak1\n\n이 모듈에 관심이 있으시다면 댓글에 여러분의 의견을 남겨주시면 멋질 것 같아요 :). 이 기사를 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_0.png"},"coverImage":"/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_0.png","tag":["Tech"],"readingTime":3},{"title":"SwiftUI에서 HTML 렌더링하기","description":"","date":"2024-06-20 03:39","slug":"2024-06-20-RenderHTMLinSwiftUI","content":"\n\n## NSAttributedString, UITextView 및 UIViewRepresentable를 사용하여 SwiftUI에서 HTML 렌더링하기.\n\n![이미지](/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png)\n\nSwiftUI는 멋지지만 여전히 기능이 부족한 것이 많습니다. 몇 년간 UIKit을 사용한 후 익숙해진 기능이죠. 그 중 하나는 NSAttributedString 및 UITextView를 사용하여 간단한 HTML 텍스트를 렌더링할 수 있는 기능입니다.\n\n이 글에서는 SwiftUI를 UIViewRepresentable을 사용하여 UIKit과 연결하고, HTML을 렌더링하는 사용자 정의 SwiftUI View를 만드는 방법을 간단히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n업데이트: 원본 기사 개선 사항\n\n이 기사의 원본 버전에서는 NSAttributedString을 사용하여 HTML을 스타일링하고 렌더링하는 데 특화된 간단한 사용자 정의 SwiftUI 뷰를 만드는 방법에 대해 살펴보았습니다. 이 기사에서는 AttributedText 뷰도 언급되었습니다. 그러나 이로 인해 이상한 동작이 발생했는데, 아직 적절한 해결책을 찾지 못했습니다. 따라서 이 기사의 업데이트된 버전에서는 HTML 뷰를 제거하고 NSAttributedString에 대한 편리한 확장 기능이 몇 가지 추가되었습니다. 나는 이상한 동작에 대한 더 나은 이해를 얻기 위해 Apple 개발자 포럼과 스택 오버플로에 게시했습니다.\n\n## 주요 포인트\n\n- UIViewRepresentable 프로토콜을 사용하여 UIKit 뷰를 SwiftUI 뷰 계층구조에 포함할 수 있습니다.\n- NSAttributedString (UITextView를 통해)의 강력한 기능을 노출할 수 있으며, 현재 SwiftUI 세계에는 동등한 것이 없습니다 (하지만 AttributedString는 좋은 후보일 수 있음).\n- 스타일이 지정된 HTML 형식의 NSAttributedStrings는 UIViewRepresentable에 의해 관리되는 UITextView에 의해 렌더링될 수 있습니다. HTML 형식의 텍스트에서 일부 CSS 스타일 속성을 인라인으로 정의하거나 HTML 형식의 텍스트의 전용 스타일 태그로 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서 사용된 완성된 예제 코드는 GitHub에서 찾을 수 있어요: https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML.\n\n# 커스텀 UIViewRepresentable\n\nSwiftUI가 처음 발표됐을 때는 기존 UIKit 뷰를 SwiftUI 뷰 계층구조에 임베드할 수 있도록 하는 API도 함께 제공되었습니다. 개발자들에게 UIKit에서 SwiftUI로의 전환이 쉬워졌어요.\n\n이러한 API 중 하나는 UIViewRepresentable 프로토콜인데요, SwiftUI의 컨텍스트에서 UIKit 뷰를 관리하는 데 사용돼요. Apple은 이 프로토콜과 다른 SwiftUI와 UIKit을 연결하는 프로토콜을 통해 이를 통한 가능성을 보여주는 멋진 WWDC 비디오를 제공했어요. 적어도 'Integrating SwiftUI'를 확인해보시기를 권해요.\n\n<div class=\"content-ad\"></div>\n\n## AttributedText\n\nNSAttributedString은 텍스트 문자열을 강력하게 관리하는 도구로, 텍스트 문자열의 문자 범위를 스타일링하는 강력한 방법을 제공합니다. 심지어 간단한 HTML에 따라 텍스트를 스타일링할 수도 있습니다.\n\nNSAttributedString을 스타일링된 상태로 초기화하려면 NSAttributedString.init(data:options:documentAttributes:) 이니셜라이저에 .documentType 옵션을 .html로 설정한 HTML 문자열(데이터 형식으로)을 전달하면 됩니다. 그리고 UITextView와 함께 사용하여 앱에서 HTML을 렌더링할 수 있습니다!\n\nUIViewRepresentable 프로토콜을 사용하여 NSAttributedString 및 UITextView의 기능을 SwiftUI에 사용되는 사용자 지정 AttributedText View로 노출시킬 것입니다!\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct AttributedText: UIViewRepresentable {\n    private let attributedString: NSAttributedString\n\n    init(_ attributedString: NSAttributedString) {\n        self.attributedString = attributedString\n    }\n\n    func makeUIView(context: Context) -> UITextView {\n        // SwiftUI이 이 \"View\"를 렌더링하는 첫 번째 시간에 호출됩니다.\n\n        let uiTextView = UITextView()\n\n        // 배경 뷰가 반짝일 수 있도록 투명하게 만듭니다.\n        uiTextView.backgroundColor = .clear\n\n        // 텍스트 시각화만을 위한 것이므로 편집되지 않도록 합니다.\n        uiTextView.isEditable = false\n\n        // UITextView를 가능한 너비에 맞게 유연하게 만들지만, 콘텐츠에 맞는 높이를 요구합니다.\n        // 또한 UITextView가 스크롤되지 않게 하여 UITextView가 텍스트 콘텐츠와 일치하도록 `intrinsicContentSize`를 설정합니다.\n        uiTextView.isScrollEnabled = false\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .vertical)\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .horizontal)\n        uiTextView.setContentCompressionResistancePriority(.required, for: .vertical)\n        uiTextView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n\n        return uiTextView\n    }\n\n    func updateUIView(_ uiTextView: UITextView, context: Context) {\n        // SwiftUI이 이 UIViewRepresentable을 처음 렌더링하는 시간과 상태 변경에 대해 알림을 받을 때마다 호출됩니다. (예: @State 변수를 통해)\n        uiTextView.attributedText = attributedString\n    }\n}\n```\n\nUIViewRepresentable로 위에서 정의한 AttributedText를 사용하여 SwiftUI 앱에서 NSAttributedStrings를 렌더링할 수 있습니다. HTML 형식의 텍스트로 초기화된 NSAttributedStrings를 렌더링하는 것이 주된 목표이므로 NSAttributedString에 대한 편의 생성자를 만듭니다.\n\n```swift\nimport UIKit\n\nextension NSAttributedString {\n    static func html(withBody body: String) -> NSAttributedString {\n        // 앱에서 사용되는 현재 로케이션과 일치하는 HTML `lang` 속성을 매치합니다. (즉, Bundle.main)\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            <!doctype html>\n            <html lang=\"\\(lang)\">\n            <head>\n                <meta charset=\"utf-8\">\n                <style type=\"text/css\">\n                    /*\n                      HTML 형식의 텍스트에 대한 사용자 정의 CSS 스타일 지정\n                      주의: NSAttributedString/UITextView에서 지원하는 CSS 기능은 제한적입니다.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(UIColor.secondaryLabel.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(UIColor.label.hex);\n                    }\n\n                    a {\n                        color: \\(UIColor.systemGreen.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                </style>\n            </head>\n            <body>\n                \\(body)\n            </body>\n            </html>\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// UIColor를 CSS 친화적인 색상 헥스 문자열로 변환\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(&red, green: &green, blue: &blue, alpha: &alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nNSAttributedString은 일부 CSS 기능을 지원합니다 (안타깝게도 어딘가 제대로 문서화되지 않은 기능들이 있습니다), 하지만 인라인 및 별도의 태그 내에서 스타일을 정의하는 것이 가능합니다 (일반적으로 HTML head 태그의 일부로).\n\n## SwiftUI에서 HTML 렌더링하기\n\n그런 다음, 우리는 AttributedText UIViewRepresentable을 사용하여 NSAttributedString 편리한 초기화자를 함께 사용하여 SwiftUI 앱에서 HTML을 렌더링할 수 있습니다 - 심지어 인라인 스타일링도 가능합니다!\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.html(withBody: \"\"\"\n                <h3>This is a H3 header</h3>\n                <p>This is a paragraph</p>\n                <ul>\n                    <li>List item one</li>\n                    <li>List item two</li>\n                </ul>\n                <p>This is a paragraph with a <a href=\"https://developer.apple.com/\">link</a></p>\n                <p style=\"color: blue; text-align: center;\">\n                    This is a paragraph with inline styling\n                </p>\n                \"\"\"))\n                .padding()\n            }\n            .navigationTitle(\"Render HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 보너스: 테마별 HTML 렌더링\n\n만약 앱이 (색상) 테마 개념을 사용하여 앱 전반에 대한 색상 정보 등을 전파한다면, 현재 테마 정보를 기반으로 HTML을 스타일링할 수도 있습니다.\n\n사용자 정의 테마 환경 값과 다른 NSAttributedString 편의 이니셜라이저를 사용하면 다음과 같이 보일 수 있습니다:\n\n사용자 정의 테마 환경 값\n\n<div class=\"content-ad\"></div>\n\n다음은 Markdown 형식으로 테이블 태그를 변경한 코드입니다.\n\n\nimport SwiftUI\n\n// Example of a simple Theme struct.\nstruct Theme {\n    let textPrimary: UIColor\n    let textSecondary: UIColor\n    let textInteractive: UIColor\n}\n\nextension Theme {\n    static let `default` = Theme(\n        textPrimary: .label,\n        textSecondary: .secondaryLabel,\n        textInteractive: .systemGreen\n    )\n}\n\nprivate struct ThemeEnvironmentKey: EnvironmentKey {\n    static var defaultValue: Theme = .default\n}\n\nextension EnvironmentValues {\n    var theme: Theme {\n        get { self[ThemeEnvironmentKey.self] }\n        set { self[ThemeEnvironmentKey.self] = newValue }\n    }\n}\n\n\nNSAttributedString을 위한 편리한 이니셜라이저\n\n\nimport UIKit\n\nextension NSAttributedString {\n    static func themedHtml(withBody body: String, theme: Theme = .default) -> NSAttributedString {\n        // Match the HTML `lang` attribute to current localisation used by the app (aka Bundle.main).\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            <!doctype html>\n            <html lang=\"\\(lang)\">\n            <head>\n                <meta charset=\"utf-8\">\n                <style type=\"text/css\">\n                    /*\n                      Custom CSS styling of HTML formatted text.\n                      Note, only a limited number of CSS features are supported by NSAttributedString/UITextView.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(theme.textSecondary.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(theme.textPrimary.hex);\n                    }\n\n                    a {\n                        color: \\(theme.textInteractive.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                </style>\n            </head>\n            <body>\n                \\(body)\n            </body>\n            </html>\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// MARK: Converting UIColors into CSS friendly color hex string\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(&red, green: &green, blue: &blue, alpha: &alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n\n\nSwiftUI에서 테마가 적용된 HTML 렌더링하기\n\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @Environment(\\.theme) private var theme: Theme\n\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.themedHtml(withBody: \"\"\"\n                <h3>This is a H3 header</h3>\n                <p>This is a paragraph</p>\n                <ul>\n                    <li>List item one</li>\n                    <li>List item two</li>\n                </ul>\n                <p>This is a paragraph with a <a href=\"https://developer.apple.com/\">link</a></p>\n                <p style=\"color: blue; text-align: center;\">\n                    This is a paragraph with inline styling\n                </p>\n                \"\"\", theme: theme))\n                .padding()\n            }\n            .navigationTitle(\"Render Themed HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n## 이게 다야!\n\n쉽죠! SwiftUI가 정말 멋지지만, 때로는 몇 년 동안 사랑해 온 UIKit 뷰와 기능을 임베드할 수 있는 것이 참 좋습니다.\n\n코딩하세요! 🙌\n","ogImage":{"url":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png"},"coverImage":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png","tag":["Tech"],"readingTime":12},{"title":"프런트엔드 웹 개발에서 초보자의 여정","description":"","date":"2024-06-20 03:37","slug":"2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment","content":"\n\n![2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png](/assets/img/2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png)\n\n안녕하세요, 야망 넘치는 웹 개발자 여러분! 프론트엔드 개발 세계에 막 발을 딛으셨거나 기본기를 다듬는 중이라면, 여기서 잘 왔습니다. 지난 주에 '바이트와이즈 프론트엔드 펠로우십'의 일환으로 HTML 기초를 깊이 있게 탐구하고 있는데요. 오늘은 제 경험을 공유하려고 해요. 그동안 얻은 통찰, 조언, 그리고 도움이 된 자료들을 함께 나누어 드리겠습니다.\n\n따라서, 초보자이신 분들이든 프론트엔드 개발에 관심이 있는 분들이든, 제가 지금까지 배운 것을 함께 살펴보도록 합시다.\n\n# 프론트엔드 개발이란?\n\n<div class=\"content-ad\"></div>\n\n집을 짓는다고 상상해보세요. 건축가가 청사진을 설계하고 시공 스탭이 벽돌을 쌓으며, 그리고 인테리어 디자이너가 색상, 질감 및 가구로 비전을 구현하는 과정을 생각해보세요. 디지털 세계에서 프론트엔드 개발은 바로 그 인테리어 디자이너와 같습니다. 이는 사용자가 직접 상호 작용하는 웹 어플리케이션의 일부를 만드는 것으로, HTML, CSS, JavaScript와 같은 언어를 사용하여 정적 디자인을 동적이고 매력적인 인터페이스로 변환하는 작업을 포함합니다.\n\n## HTML: 웹 페이지의 기초\n\nHTML은 웹 페이지의 뼈대인 Hypertext Markup Language의 줄임말입니다. 다른 모든 것이 의존하는 프레임워크로 생각할 수 있습니다. HTML을 사용하여 텍스트, 이미지, 링크 등을 표시하기 위해 태그를 사용하여 웹 페이지의 구조와 내용을 정의합니다. 예를 들어:\n\n- `h1`은 제목을 생성합니다.\n- `p`는 단락을 나타냅니다.\n- `img src=\"image.jpg\"`는 이미지를 삽입합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n    <title>내 첫 번째 웹 페이지</title>\n</head>\n<body>\n    <h1>내 웹 사이트에 오신 것을 환영합니다!</h1>\n    <p>이것은 하나의 문단입니다.</p>\n    <img src=\"welcome-image.jpg\" alt=\"환영 이미지\">\n</body>\n</html>\n```\n\n## CSS: 웹 디자인의 스타일러\n\nHTML은 콘텐츠를 구조화하는 반면, CSS(Cascading Style Sheets)은 그것을 잘 꾸미는 역할을 합니다. CSS에서는 색상, 글꼴, 레이아웃 및 애니메이션을 적용하여 평범한 HTML 문서를 시각적으로 멋진 웹 페이지로 만들어줍니다. CSS를 영화의 의상 부서로 상상해보세요; 모든 장면이 정확히 보이도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n```js\nbody {\n    background-color: lightblue;\n}\n\nh1 {\n    color: navy;\n    margin-left: 20px;\n}\n```\n\n# JavaScript: 상호 작용의 마법사\n\n자바스크립트는 웹 페이지에 생명을 불어넣어주는 마법과 같습니다. 상호 작용, 양식 제출, 애니메이션 등을 가능하게 합니다. 자바스크립트 없이는 웹 페이지가 정적이고 반응하지 않는 상태가 됩니다. 그것은 도시에 전기를 공급하는 것과 같습니다; 갑자기 모든 것이 밝아지고 기능적으로 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n```js\ndocument.querySelector('button').addEventListener('click', function() {\n    alert('버튼이 클릭되었습니다!');\n});\n```\n\n# 프론트엔드 개발 해양 항해\n\n프론트엔드 개발 분야에서의 경력은 거대한 바다를 항해하는 것과 같습니다. 여기에 몇 가지 항해 보조 도구가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 기초 학습: HTML, CSS, 그리고 JavaScript부터 시작하세요. W3Schools, Codecademy, Udemy와 같은 다양한 온라인 자원들이 포괄적인 안내서와 자습서를 제공합니다.\n- 꾸준한 연습: 코딩은 반복을 통해 향상되는 기술입니다. 배운 것을 강화하기 위해 작은 프로젝트를 만들어보세요.\n- 커뮤니티 참여: Stack Overflow, GitHub, Reddit와 같은 플랫폼에서 동료 학습자 및 전문가들과 소통하세요. 지식 공유와 조언 요청은 성장을 가속화할 수 있습니다.\n- 호기심 유지: 기술은 빠르게 진화합니다. 경쟁력을 유지하기 위해 새로운 도구, 프레임워크, 최상의 실천법에 대해 계속해서 알아두세요.\n\n# 나의 바이트위즈 펠로우십 모험\n\n## 🗓️ 제 1일: 툴킷 설정하기\n\n코딩에 뛰어들기 전에 올바른 도구와 자원을 설정하는 것이 중요합니다. 첫 날 우리가 한 것은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n## 설정할 계정:\n\n- LinkedIn: 전문가들과 연결하고 성장 과정을 공유하세요.\n- Twitter: 기술 인플루언서를 팔로우하고 여정을 공유하세요.\n- GitHub: 프로젝트를 호스팅하고 다른 사람과 협업하세요.\n- Medium: 학습 경험에 대한 기사를 쓰고 공유하세요.\n- Google Drive: 일일 회의와 프로젝트 파일을 정리하세요.\n\n## 학습 자료:\n\n- 동영상: 프론트엔드 개발자 로드맵 2024 또는 대체 동영상\n- 기사: 초심자 프론트엔드 개발자의 교훈\n\n<div class=\"content-ad\"></div>\n\n# 🗓️ Day 2: 필수 프론트엔드 스킬\n\n강력한 기반을 구축하는 것이 중요합니다. 오늘은 프론트엔드 개발을 올바르게 학습하는 방법에 중점을 두었습니다.\n\n## 학습 자료:\n\n- 비디오: 올바른 방법으로 프론트엔드 개발 학습하기\n- 비디오: 2배 빨리 프론트엔드 개발 배우기\n\n<div class=\"content-ad\"></div>\n\n# 🗓️ 3일차: HTML 기초\n\nHTML (하이퍼텍스트 마크업 언어)는 모든 웹사이트의 기초입니다. 모든 것을 함께 유지하는 뼈대로 생각해보세요.\n\n## 학습 자료:\n\n- 비디오 튜토리얼: HTML 기본 태그\n\n<div class=\"content-ad\"></div>\n\n## 중요 개념:\n\n- 제목: `h1`부터 `h6`까지 사용하여 제목을 정의합니다.\n- 문단: `p` 태그는 문단을 만듭니다.\n- 리스트: 순서가 있는 목록에는 `ol`을, 순서가 없는 목록에는 `ul`을 사용합니다.\n- 링크: `a` 태그는 하이퍼링크를 만듭니다. 예시:\n\n```js\n<a href=\"https://www.bytewise.com\">바이트와이즈 방문하기</a>\n```\n\n- 이미지: `img` 태그는 이미지를 삽입합니다. 예시:\n\n<div class=\"content-ad\"></div>\n\n\n![Description of Image](path/to/image.jpg)\n\n\n# 🗓️ Day 4: HTML Semantic Tags\n\n시맨틱 HTML 태그는 웹 콘텐츠에 의미를 부여하여 콘텐츠를 더 접근 가능하고 유지 보수하기 쉽게 만듭니다.\n\n## 학습 자료:\n\n<div class=\"content-ad\"></div>\n\n- 비디오 자습: HTML 시맨틱 요소\n\n## 주요 개념:\n\n- `header`: 페이지의 헤더 섹션을 정의합니다.\n- `nav`: 내비게이션 링크를 포함합니다.\n- `article`: 글을 나타냅니다.\n- `section`: 문서 내에서 섹션을 정의합니다.\n\n## 예시:\n\n<div class=\"content-ad\"></div>\n\n\n# 🗓️ Day 5: HTML 미디어 태그\n\n미디어 태그를 사용하면 비디오, 오디오 및 기타 멀티미디어 요소를 웹 페이지에 삽입하여 사용자 경험을 향상시킬 수 있습니다.\n\n## 학습 자료:\n\n\n<div class=\"content-ad\"></div>\n\n- 비디오 튜토리얼: HTML 미디어 요소\n\n## 주요 개념:\n\n- 비디오: `video` 태그는 비디오 파일을 임베드합니다. 예시:\n\n```js\n<video controls>\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  브라우저가 비디오 태그를 지원하지 않습니다.\n</video>\n```\n\n<div class=\"content-ad\"></div>\n\n- Audio: `audio` 태그는 오디오 파일을 임베드합니다. 예시:\n\n```js\n<audio controls>\n  <source src=\"sound.mp3\" type=\"audio/mpeg\">\n  //브라우저가 오디오 태그를 지원하지 않습니다.\n</audio>\n```\n\n- iFrame: `iframe` 태그는 외부 콘텐츠를 임베드합니다. 예시:\n\n```js\n<iframe src=\"https://www.example.com\" width=\"600\" height=\"400\"></iframe>\n```\n\n<div class=\"content-ad\"></div>\n\n# 📝 결론: 앞으로의 여정\n\n프론트엔드 개발을 배우는 것은 흥미진진한 모험을 떠나는 것과 같습니다. 매일 새로운 도전과 성장의 기회가 찾아옵니다. 여러분이 여정을 계속할 때 기억해야 할 몇 가지 팁이 있습니다:\n\n- 꾸준한 연습: 코드를 많이 작성할수록 능력이 향상됩니다.\n- 호기심을 유지하라: 늘 새로운 것을 배우고 다양한 자료를 탐험하려고 노력하세요.\n- 커뮤니티 지원을 찾아라: 포럼에 가입하거나 웨비나에 참석하고 다른 개발자와 소통하세요.\n\nHTML, CSS, JavaScript의 기본을 마스터하면 멋진 웹사이트를 만들고 숙련된 프론트엔드 개발자가 될 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사가 도움이 되었다면, 더 많은 웹 개발 팁과 통찰을 얻기 위해 LinkedIn과 Twitter에서 저를 팔로우해 주세요. 아래 댓글에 여러분의 경험과 배운 교훈을 공유해 주시기를 환영합니다.\n\n성공의 열쇠는 끈기와 학습에 대한 사랑입니다.\n\n즐거운 코딩하세요! 😊🌸✨","ogImage":{"url":"/assets/img/2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png"},"coverImage":"/assets/img/2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png","tag":["Tech"],"readingTime":6},{"title":"내부 HTML을 사용하지 말아야 하는 이유와 대신 사용할 것","description":"","date":"2024-06-20 03:36","slug":"2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead","content":"\n\n## innerText, textContent, 및 innerHTML\n\n![이미지](/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_0.png)\n\n# 소개\n\n코딩에 입문했고 JavaScript와 HTML의 기본을 알게 되었다면, 이제 DOM을 탐색하기 시작할 준비가 된 것 같네요. JavaScript를 사용하여 HTML 요소를 선택했고, 이제 해당 요소에 콘텐츠를 추가하려고 할 때 innerHTML, textContent, innerText 속성이 모두 도와줄 수 있지만, 어떤 것을 선택해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 HTML에 빈 `li` 요소들로 이루어진 순서 없는 목록이 있다고 가정해 봅시다. 우리는 이러한 요소들에 JavaScript를 사용하여 일반 텍스트 내용을 추가하고 싶습니다.\n\n우리가 `li` 요소들에 부여한 id를 활용하여 JavaScript에서 이러한 요소들에 내용을 추가할 수 있고, 세 속성 중 아무것이나 사용해도 거의 동일하게 작동할 것입니다.\n\n여기서 볼 수 있듯이 어떤 속성을 사용하든 우리의 웹페이지에 텍스트가 항목으로 나타날 것입니다.\n\n![이미지](/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_1.png)\n\n<div class=\"content-ad\"></div>\n\n그래서, 세 개의 속성이 모두 같은 기능을 한다면, 그 목적은 무엇인가요? 각각의 차이와 innerHTML이 해커들에게 취약해지게 하는 방법, 그리고 대신에 사용할 수 있는 것을 알아보려면 계속 읽어보세요.\n\n# 각각의 콘텐츠를 페이지에 렌더하는 방법\n\n이미 존재하는 요소에 일반 텍스트를 추가하는 방법은 위에서 했던 것처럼 상당히 간단하지만, 더 복잡한 코드를 작성하고 있다면 어떨까요. 예를 들어, HTML에 `li` 태그를 입력하지 않고 JavaScript를 사용하여 추가하려고 하는 상황을 생각해보세요. 또 하나의 복잡성을 더해주기 위해, 글을 굵게 표시하기 위해 텍스트 주위에 `strong` 태그를 추가하고 싶다고 가정해 보겠습니다. 이전에 제공했던 \"list\" id를 통해 `ul` 요소를 선택한 후에, HTML 콘텐츠를 추가하고 일반 텍스트를 넣어놓는 것 역시 시작할 수 있습니다. textContent 속성을 사용하여 목록을 만들어 보겠습니다.\n\n이것이 웹 페이지에 표시되는 결과입니다:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_2.png\" />\n\n이 부분은 확실히 제대로 보이지 않아요. 만약 'textContent'를 'innerText'로 바꾼다면 어떻게 될까요?\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_3.png\" />\n\n음... 아무래도 조금 나아졌지만, 여전히 원하는 것과는 다르네요. 아마 'innerText' 대신에 'innerHTML'을 사용하면 우리가 원하는 굵은 목록을 얻을 수 있을 것 같아요.\n\n\n<div class=\"content-ad\"></div>\n\n아래는 표입니다.\n\n| 일자 | 카테고리 | 주제 |\n| ---- | -------- | ---- |\n| 6월 20일 | 웹 개발 | innerHTML의 단점 | \n\n내용이 완벽해 보여요! innerHTML이 여기서 멋지게 작동하고 있지만, 웹 페이지에 문제를 일으킬 수 있는 상당히 중요한 단점이 몇 가지 있습니다.\n\n# innerHTML의 단점\n\n## 사이버 보안 문제\n\n<div class=\"content-ad\"></div>\n\n모든 세 속성(textContent, innerText 및 innerHTML)은 빈 요소에 콘텐츠를 추가하는 것뿐만 아니라 기존 콘텐츠를 대체합니다. innerHTML은 단순한 문자열이 아닌 실제 HTML 코드 조각을 포함하는 콘텐츠를 추가할 수 있기 때문에 보안 위험을 야기할 수 있습니다. 예를 들어 innerHTML을 사용하여 웹페이지에 제출 양식을 만들고 누군가 악성 콘텐츠를 제출하면 본인 뿐만 아니라 웹사이트나 프로젝트의 다른 사용자에게 실제 문제가 발생할 수 있습니다. 이러한 이유로 보안 검토를 받을 예정인 사이트나 프로젝트의 경우, innerHTML 사용은 테스트를 통과하지 못하고 거부당할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_5.png\" />\n\n## 비효율성\n\n또 다른 innerHTML의 단점은 다른 옵션에 비해 느립니다. 예를 들어, 코드에서 이전에 생성한 배열이나 어쩌면 API에서 가져온 수백 개 또는 수천 개의 아이템이 있는 배열에 대해 각 항목에 대해 새 요소를 만들어야 하는 프로젝트를 작업 중이라고 가정해봅시다. innerHTML을 사용하면 이 데이터를 로드하는 데 몇 초가 걸릴 수 있습니다. 오늘날 온라인 사용자에게 속도가 매우 중요한 요소인만큼, 이 몇 초가 빠르게 누적될 수 있습니다. Digital.com의 기사에 따르면 온라인 쇼핑객의 53%가 3초 이상 걸리는 전자상거래 웹사이트를 방문하지 않을 것이라고 합니다 (Leng, 2022). 다행히 JavaScript를 사용해 HTML 요소를 추가할 때 다른 옵션이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 사용 대신할 것\n\n## HTML 추가하기\n\n우리는 innerHTML을 사용하여 한 번에 HTML 요소와 텍스트 문자열을 추가하는 방법을 보았습니다. 또한 이렇게 하는 것의 단점을 살펴보았습니다. 우리의 코드를 안전하고 효율적으로 만드는 좋은 대안은 이러한 작업을 분리하는 것입니다.\n\n위의 그림에서, 우리는 'greetings'라는 배열에 우리의 인사말을 입력했습니다. 그런 다음 이 배열에 대한 'forEach' 루프를 만들었고, 배열의 각 항목에 대해 새로운 li 태그를 만들도록 지시했습니다. 새로운 강조 태그를 만들고, ul 요소를 선택하고, 방금 선택한 ul 요소에 새로 만든 li 태그를 추가하고, 해당 li 태그에 새로 만든 강조 태그를 추가하고, 배열에서 가져온 텍스트 항목을 입력하도록 했습니다. 휴, 많이 보일 수 있지만, 보다 간단하게 쪼개면, 우리는 원하는 HTML 요소를 생성하고, 그 위치를 선택하고, 해당 위치에 추가하고, 텍스트를 추가하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## innerText 대 textContent\n\n만약 HTML을 삽입할 필요가 없는 경우, 콘텐츠를 추가할 요소를 선택하고 innerText 또는 textContent로 텍스트를 입력할 수 있습니다. 일반적으로 messy한 코드를 생성할 수 있는 textContent 대신 innerText를 선택하는 것이 좋습니다. 예를 들어, `li` 태그 아래에 텍스트를 작성하고 세 줄로 나누었다고 가정해 봅시다.\n\n그런 다음 JavaScript에서 innerText와 textContent를 사용하여 해당 텍스트를 콘솔에 출력했습니다.\n\n아래에서 확인할 수 있듯이 innerText는 콘솔에 내용을 표시할 때 페이지에 표시되는 방식과 유사하게 나타내며, textContent는 동일한 콘텐츠를 콘솔에 출력할 때 처음에 HTML에 입력된 방식과 더 유사하게 출력됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_6.png\" />\n\n# 결론\n\n간편성 때문에 innerHTML을 사용하기 유혹받을 수 있지만, 웹 페이지의 로딩을 느리게 만들고 보안 위험을 초래할 수 있으므로 innerHTML을 피하고 요소를 생성하고 텍스트를 추가하는 작업을 분리하는 것이 좋습니다. textContent와 innerText 모두 원하는 텍스트를 안전하게 추가할 수 있지만, innerText는 콘솔에서 내용을 더 명확하게 표시하기 때문에 일반적으로 선호됩니다. innerHTML, textContent 및 innerText 간의 차이를 명확히 해주고 어떤 것을 사용할지 결정하는 데 도움이 되었기를 바랍니다. 즐거운 코딩 되세요!\n\n## 출처\n\n\n<div class=\"content-ad\"></div>\n\n\n[Element.innerHTML.](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)\n\nLeng, Allen. [“1 In 2 Visitors Abandon a Website That Takes More than 6 Seconds to Load.”](https://digital.com/1-in-2-visitors-abandon-a-website-that-takes-more-than-6-seconds-to-load/#:~:text=However%2C%20when%20it%20comes%20to,will%20leave%20after%20one%20second.)\n","ogImage":{"url":"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_0.png"},"coverImage":"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_0.png","tag":["Tech"],"readingTime":5},{"title":"CSS 레이아웃 및 반응 형성 Flexbox, Grid 및 미디어 쿼리 마스터하기","description":"","date":"2024-06-20 03:34","slug":"2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries","content":"\n\n웹 레이아웃을 잘 구조화하고 반응형으로 만드는 것은 어려울 수 있지만, CSS는 이 작업을 쉽게 만들어 주는 강력한 도구를 제공합니다.\n\n이 포스트에서는 두 가지 필수적인 CSS 레이아웃 방법인 플렉스박스와 그리드를 탐색할 것입니다. 또한, 반응형 디자인을 위한 중요한 개념인 미디어 쿼리에 대해 알아볼 것입니다.\n\n이 글을 끝까지 읽으면, 이러한 도구들을 사용하여 유연하고 반응형 웹 페이지를 만드는 방법에 대해 확실하게 이해하게 될 것입니다.\n\n# 왜 CSS 레이아웃 방법이 중요한 이유\n\n<div class=\"content-ad\"></div>\n\n구체적인 내용에 들어가기 전에 CSS 레이아웃 방법이 왜 중요한지 이해해 봅시다. 전통적인 레이아웃 기술인 플로트(floats) 사용은 종종 복잡하고 유지보수하기 어려운 코드로 이어집니다.\n\n플렉스박스(Flexbox)와 그리드(Grid)는 정렬, 간격 및 반응형 동작과 같은 일반적인 문제를 해결하면서 더 효율적이고 직관적인 레이아웃 설계 방법을 제공합니다.\n\n# Flexbox: 유연한 박스 레이아웃\n\n플렉스박스(Flexbox) 또는 유연한 박스 레이아웃은 하나의 축(수평 또는 수직)을 따라 공간을 분배하도록 디자인되었습니다. 컨테이너 내에서 항목을 정렬하고 공간을 분배하는 것을 쉽게 만들어 줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 플렉스박스를 사용해야 하는 경우:\n\n- 일차원 레이아웃(예: 네비게이션 바, 행이나 열에 아이템 정렬).\n- 컨테이너 내에서 공간을 분배하고 아이템을 정렬해야 할 때.\n\n## 기본 플렉스박스 예시:\n\nHTML:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Flex Box example</title>\n</head>\n\n<body>\n    <div class=\"flex-container\">\n        <div class=\"flex-item\">Item 1</div>\n        <div class=\"flex-item\">Item 2</div>\n        <div class=\"flex-item\">Item 3</div>\n    </div>\n</body>\n\n</html>\n```\n\n## CSS:\n\n```js\n.flex-container {\n  display: flex;\n  justify-content: space-between; /* Distributes space evenly */\n  align-items: center; /* Aligns items vertically centered */\n  padding: 10px;\n  background-color: #f0f0f0;\n  flex-wrap: wrap; /* Wraps items if they don't fit */\n}\n.flex-item {\n  background-color: #007bff;\n  color: white;\n  padding: 20px;\n  margin: 5px;\n  flex: 1 1 200px; /* 1:1:200px grow: shrink: basis*/\n}\n```\n\n## What the code displays\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_0.png\" />\n\n## Flexbox로 해결하는 문제들:\n\n- 컨테이너 내에서 항목을 수평 또는 수직으로 정렬.\n- 항목들 사이에서 공간을 균등하게 분배.\n- 복잡한 계산 없이 다양한 화면 크기에 맞게 레이아웃 조정.\n\n## Flexbox의 제한사항:\n\n<div class=\"content-ad\"></div>\n\n- 하나의 차원적 레이아웃을 위해 디자인되었으며, 따라서 행이나 열 중 하나만 처리하고 동시에 둘 다 처리하지는 않습니다.\n\n# CSS Grid: 이차원 레이아웃\n\nCSS Grid Layout 또는 격자(Grid)는 두 차원 레이아웃을 만들기 위한 강력한 도구입니다. 행과 열을 둘 다 포함하는 복잡한 레이아웃을 디자인할 수 있습니다.\n\n## Grid을 사용해야 하는 경우:\n\n<div class=\"content-ad\"></div>\n\n- 2차원 레이아웃(예: 포토 갤러리, 복잡한 웹 페이지 레이아웃)에 사용됩니다.\n- 행과 열을 모두 정확하게 제어해야 할 때 유용합니다.\n\n## 기본 그리드 예시:\n\nHTML:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CSS Grid Example</title>\n</head>\n\n<body>\n    <div class=\"grid-container\">\n        <div class=\"grid-item\">아이템 1</div>\n        <div class=\"grid-item\">아이템 2</div>\n        <div class=\"grid-item\">아이템 3</div>\n        <div class=\"grid-item\">아이템 4</div>\n        <div class=\"grid-item\">아이템 5</div>\n        <div class=\"grid-item\">아이템 6</div>\n        <div class=\"grid-item\">아이템 7</div>\n        <div class=\"grid-item\">아이템 8</div>\n    </div>\n</body>\n\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\nCSS:\n\n```js\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr); /* 2개의 동일한 너비의 열을 생성합니다 */\n  gap: 10px; /* 항목 사이의 간격을 추가합니다 */\n  padding: 10px;\n  background-color: #f0f0f0;\n}\n.grid-item {\n  background-color: #007bff;\n  color: white;\n  padding: 20px;\n  text-align: center;\n}\n```\n\n## 코드 결과\n\n<img src=\"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 그리드의 문제를 해결하는 부분:\n\n- 행과 열을 활용한 복잡한 레이아웃 생성.\n- 레이아웃 내 항목의 크기와 위치 제어.\n- 광범위한 미디어 쿼리 없이 반응형 디자인을 손쉽게 만들기.\n\n## 그리드의 제한점:\n\n- 간단한 레이아웃에는 부담스러울 수 있으며, 해당 경우 플렉스박스가 더 적합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 미디어 쿼리를 활용한 반응형 디자인\n\n미디어 쿼리는 반응형 디자인의 중요한 요소로, 화면 너비와 같은 기기 특성에 따라 다른 스타일을 적용할 수 있게 해줍니다.\n\n이를 통해 레이아웃이 다양한 화면 크기에 적응하여 더 나은 사용자 경험을 제공할 수 있습니다.\n\n## 기본적인 미디어 쿼리 예시:\n\n<div class=\"content-ad\"></div>\n\nMarkdown:\n\n\n# Media Query Example\n\n```css\n.responsive-container {\n  display: flex;\n  flex-wrap: wrap; /* Allows items to wrap to the next line */\n  gap: 10px;\n  background-color: #f0f0f0;\n  padding: 10px;\n}\n.responsive-item {\n  flex: 1 1 100%; /* Takes full width on small screens */\n  background-color: #007bff;\n  color: white;\n  padding: 20px;\n  text-align: center;\n}\n```\n\n**Media query for screens wider than 600px:**\n```css\n@media (min-width: 600px) {\n  .responsive-item {\n    flex: 1 1 calc(50% - 20px); /* Takes half the width on larger screens */\n  }\n}\n```\n\n**Media query for screens wider than 900px:**\n```css\n@media (min-width: 900px) {\n  .responsive-item {\n    flex: 1 1 calc(33.33% - 20px); /* Takes a third of the width on even larger screens */\n  }\n}\n```\n\n```html\n<div class=\"responsive-container\">\n  <div class=\"responsive-item\">Item 1</div>\n  <div class=\"responsive-item\">Item 2</div>\n  <div class=\"responsive-item\">Item 3</div>\n  <div class=\"responsive-item\">Item 4</div>\n  <div class=\"responsive-item\">Item 5</div>\n  <div class=\"responsive-item\">Item 6</div>\n  <div class=\"responsive-item\">Item 7</div>\n  <div class=\"responsive-item\">Item 8</div>\n  <div class=\"responsive-item\">Item 9</div>\n  <div class=\"responsive-item\">Item 10</div>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n## 미디어 쿼리가 해결하는 문제:\n\n- 다양한 화면 크기에 레이아웃을 적응시키기.\n- 다양한 장치 (데스크톱, 태블릿, 모바일)에서의 사용 향상.\n- 장치 특성에 따라 조건부로 스타일을 적용하기.\n\n# 결론\n\n플렉스박스와 그리드와 같은 CSS 레이아웃 기법 및 미디어 쿼리를 사용한 반응형 디자인 원칙을 이해하고 숙달하는 것은 현대 웹 개발에 필수적인 기술입니다.\n\n<div class=\"content-ad\"></div>\n\n이 도구들은 유연하고 적응 가능하며 사용자 친화적인 웹 레이아웃을 만드는 과정을 간편화합니다.\n\n## 추가 자료:\n\n- MDN Web Docs: Flexbox\n- MDN Web Docs: CSS Grid\n- MDN Web Docs: 미디어 쿼리\n- CSS Tricks\n\n이 CSS 레이아웃 방법과 미디어 쿼리를 활용하여 아름다운 반응형 웹 디자인을 만들어 보세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_0.png"},"coverImage":"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_0.png","tag":["Tech"],"readingTime":6},{"title":"웹소켓, NodeJS를 사용하여 Kafka 앱을 처음부터 만들면서 배운 교훈","description":"","date":"2024-06-20 03:33","slug":"2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o","content":"\n\n예전에 나는 HTML5 앱을 개발하는 일을 했었어요. 새롭게 인가된 WebSocket 표준의 강력함을 보여주는 앱들이었죠. 데이터 스트리밍 데모와 튜토리얼의 공통된 문제는 데이터의 소스입니다. 데이터는 풍부해야 하며(내 발코니의 온도 데이터는 변화가 느리고 따라서 지루합니다) 확인 가능해야 합니다(랜덤한 데이터는 시각화할 수 없습니다). 사람이 만들고 이해하기 쉬운 데이터를 사용하는 것이 종종 좋은 해결책입니다. 이 문제를 해결하기 위해 과거에 제가 개발한 앱 중 하나는 다중 사용자 드로잉 앱이었어요. 이 앱은 한 사용자의 상호작용을 다른 사용자 화면에 반영했죠.\n\n저는 Apache Kafka와 함께 일하기 시작한 이후로 Kafka 백엔드를 가진 이 간단한 데모 앱을 만들고 싶어했어요. 여러 날이 걸릴 것 같아서 미뤄왔었는데, 그리고 시간이 부족하다고 느꼈었죠.\n\n# 데모 앱에 대해\n\n저의 고수준 목표는 Kafka를 Node.js에 연결하고 Node.js가 WebSocket을 통해 브라우저와 대화할 수 있도록 하는 것이에요. 두 개의 별개의 웹 앱을 가지고 싶어요: 드로잉에 사용하는 프로듀서 앱과 다른 기기에서 드로잉을 반영하는 소비자 앱이에요. Kafka 백엔드로는 Confluent Cloud를 사용하고 싶은데, 그 이유는 Confluent에서 일하고 있기 때문일 뿐만 아니라 이와 같은 실험에 적합한 간단하고 정교한 클라우드 환경이기 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n마침내 결정해서 새로운 도전을 해보기로 했어요. 하지만 조금 다르게 해보려고 했어요: 최근에 출시된 ChatGPT-4o가 얼마나 도움이 될지 직접 시험해보고 싶었어요. 이 게시물에서는 ChatGPT와의 상호작용과 여정, 우리가 마주친 오류들, 그리고 어떻게 해결했는지에 대한 소개를 할 거예요. (내가 이 모델을 이미 사람처럼 취급하고 있다는 게 참 재미있다고 생각해.)\n\n# 아키텍처 개요\n\n![Architecture Overview](/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_0.png)\n\nConfluent Cloud에서 실행되는 Kafka 클러스터가 우리 앱의 중심에 있어요. 메시지는 drawing_topic으로 발행하고 소비해요. Kafka 상호작용의 핵심 부분은 프로듀서(왼쪽)와 컨슈머(오른쪽) Node.js 앱에 의해 처리돼요. 마지막으로, 발행해야 하는 데이터(그리기 좌표 및 그림과 관련된 일부 메타데이터)는 각각 브라우저에서 실행되는 HTML5 앱에 의해 생성(왼쪽) 및 렌더링(오른쪽)돼요.\n\n<div class=\"content-ad\"></div>\n\n# ChatGPT가 얼마나 도움이 되었나요?\n\nChatGPT의 성능에 관해 말하자면 (Github의 소스를 참고): 저는 ChatGPT의 성능에 깊은 감명을 받았습니다! 첫 번째 시도로 간단하지만 작동하는 앱을 만들어냈습니다. 문제를 작은 단위로 쪼개고 테스트할 수 있는 단계로 나누어 진행했기 때문에 전체 과정에서 운전자의 자리에 있었습니다. ChatGPT는 두 가지 오류를 범했지만, 제가 지적하자 바로 해결했습니다. 이 연습의 한 부분으로, 모든 프롬프트, 응답, 그리고 코드 조각들을 자세하게 공유하고자 합니다. 이를 통해 우리 빠르게 변화하는 세상에 대한 일부 힌트나 스냅샷이 될 것이라고 생각합니다.\n\n저는 깊은 인상을 받았지만 동시에 걱정도 되고 있습니다. 우리의 이 새로운 세계가 실패할 위기의 상황이 되지 않기를 소망하며요.\n\n# 작동 중인 앱\n\n<div class=\"content-ad\"></div>\n\n여기 앱이 어떻게 동작하는지 보여주는 GIF 파일이 있어요. 왼쪽 브라우저에서 마우스로 그림을 그리고 있어요. 그 아래에 있는 터미널 창에서 Node.js 애플리케이션이 Kafka 토픽에 메시지를 발행하고, 메시지가 스크롤되고 있어요. 오른쪽에는 다른 브라우저에서 메시지를 소비하는 것을 볼 수 있어요. 제 그림을 그리는 영역 아래에는 Chrome 개발자 도구 콘솔에서 소비 앱에 도착한 메시지를 보여줘요.\n\n중요한 점은 두 브라우저가 로컬에서 실행되는 것이지만 (내 컴퓨터에서 실행 중), 메시지가 흐르는 Kafka 클러스터는 클라우드에 위치하고 있다는 것이에요. 이 애플리케이션은 이와 같은 시스템에서 기대할 수 있는 대략적인 지연 시간에 대한 아이디어를 제공해줍니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*6mgRUEq_ou44GxWiaU7FPg.gif\" />\n\n# 목차 — 어떤 식으로든\n\n<div class=\"content-ad\"></div>\n\n우리가 가는 방향에 대한 아이디어를 주기 위해, 여기 ChatGPT에 제공한 모든 프롬프트를 읽을 수 있습니다. 이 글의 목차 같은 역할을 할 수 있어요. GitHub 저장소로 바로 이동하거나 아래 프롬프트를 따라올 수 있습니다.\n\n시작해 보겠습니다...\n\n프롬프트 1\n\nChatGPT의 답변 및 모든 소스 코드를 보려면 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n프롬프트 4\n\nChatGPT의 답변 및 모든 소스 코드를 확인하려면 클릭하세요.\n\n프롬프트 5\n\nChatGPT의 답변 및 모든 소스 코드를 확인하려면 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 다음 단계\n\n이 포스트에서는 앱을 간단히 유지하고 싶었지만, 몇 가지 아이디어가 더 발전할 수 있을 것 같아요:\n\n- UI 개선, CSS로 앱 꾸미기: 현재 UI의 스크린샷을 찍어 모델에게 CSS 개선 제안을 해달라고 요청하세요. 색상, 선 굵기, 지우기, 되돌리기 등 여러 기능을 추가하여 봄.\n- 음성 명령을 포함한 자연어 기능 추가: 그대신 그림을 그리도록 음성 명령에 대한 기능을 추가하세요.\n- 소비자 및 프로듀서 HTML5 앱 병합: 이들을 하나로 결합하여 전체 협업 경험을 제공하는 단일 앱으로 만드세요. 이렇게 하면 모든 클라이언트가 그림을 그리고 다른 클라이언트의 그림을 보는 것이 가능해져서 Google 문서와 유사한 경험을 제공할 수 있어요.\n- 백엔드 아키텍처 간소화: 두 개의 Node.js 앱을 하나의 앱으로 병합하여 코드를 최적화하고 앱을 더 쉽게 관리할 수 있도록 만드세요.\n- Kafka와 영속 메시지 로그를 활용하는 것을 고려하면, 메시지를 되돌려 다시 그림을 그릴 수도 있어요. 각 메시지에 연관된 타임스탬프를 사용하여 그림을 빨리 또는 천천히 그릴 수도 있어요.\n\n<img src=\"/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n모델의 도움을 받아 약 한 시간 만에 완전히 작동하는 프로토 타입 앱을 만들 수 있었습니다. 생산 준비가 된 상태는 아니지만, 보통의 귀찮음과 기술적인 어려움이 대부분 없는 기술을 배우는 놀라운 방법입니다.\n\n나는 목표를 명확히 가지고 이 연습에 임했습니다. 이벤트 주도 방식으로 문제를 해결하는 방법, 클라이언트 및 서버 측에서 사용하려는 기술, 그리고 서로 통신하는 방법에 대해 알고 있었습니다. 게다가, 모델을 안내할 그림 그리기 앱의 예도 있었습니다.\n\n두 번의 경우에 솔루션이 조금 부적절했습니다 (프롬프트 4 및 7). 코드에 문제가 있는 이유에 대해 의아해할 수 있습니다. 이 부분에서는 시간이 지남에 따라 상당한 개선이 예상됩니다. 제 프롬프트가 다소 모호했을 수도 있고, 모델이 제 목표를 완벽하게 이해하지 못했을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이번 연습에서 코드 작성에 집중하지 않았지만, 문제를 마주했을 때 명확한 증상과 오류 메시지를 제공하여 모델의 도움을 효과적으로 활용했습니다. 구글링, StackOverflow 검색 또는 문서 읽기는 필요하지 않았어요 — 간단한 영어 프롬프트만 있으면 돼요.\n\n지식을 나누고 전달하는 데 열정을 가진 사람으로써 나는 항상 YouTube를 지식을 민주화하는 최고의 도구로 보아왔어요. 이 연습은 대형 언어 모델이 많은 이전 가정에 도전하며 이를 다음 수준으로 이끌고 있다는 것을 보여줍니다.\n\n우리는 몇 년 전과는 근본적으로 다른 세상에서 살고 있으며, 나는 그것이 나를 흥분시키고 동시에 걱정도되도록 느끼게 해요.","ogImage":{"url":"/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_0.png"},"coverImage":"/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_0.png","tag":["Tech"],"readingTime":5},{"title":"Pumpi - 유기농 채소 쇼핑몰 20 테마","description":"","date":"2024-06-20 03:32","slug":"2024-06-20-PumpiOrganicVegetablesShopify20Theme","content":"\n\n🔍 Pumpi- Organic Vegetables Shopify 2.0 테마를 확인해보세요! 📁 Shopify CMS 템플릿 라이브러리를 살펴보고 🆓 무료 다운로드를 받아보세요. 함께 만들어 봐요! 🚀\n\nPumpi는 유기농 식품을 위해 특별히 디자인된 테마에요. 유기농 식품은 기존 식품보다 항산화제와 영양소가 더 많을 수 있지만, 아직까지 그 증거는 매우 제한적이에요. 유기농 식품을 섭취하면 인공 화학물질, 호르몬 및 항생제에 저항성이 있는 박테리아에 노출될 위험이 줄어들 수 있어요.\n\nPumpi는 스마트 필터를 갖춘 완벽한 스토어 프론트를 지원해요. 페이지가 로드되길 기다릴 필요 없이 초고속으로 제공될 거에요. 또한 Instant Product Search 시스템을 갖춘 Pumpi는 입력하는 대로 즉시 결과를 찾아주며, 시간을 기다릴 필요가 없어요. Pumpi 테마는 SEO 친화적으로 설계되었으며 HTML 5 표준을 준수해요. 많은 기사나 동일한 페이지에서 로드되는 다양한 제품이 있더라도 가장 빠른 페이지 로드 속도를 제공하도록 설계되었어요.\n\nPumpi는 코드 지식이나 웹마스터 없이도 누구나 쉽게 사용할 수 있어요. 모든 데모는 한 번의 클릭으로 빠르게 가져올 수 있어요. 체험하기 위해 데모를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n테마 기능\n\n- 섹션 드래그 & 드롭 페이지 빌더\n- 전체 Oberlo 호환성\n- 약관 및 동의 사항 카트에 추가\n- 함께 구매하기\n- 업셀 제품\n- 서브 컬렉션 페이지\n- 페이스북 채팅\n- 다이내믹 체크아웃 준비\n- 새로운 룩북\n- 주문제품 알림\n- 360도 제품 뷰\n- 카트에 추가 팝업\n- 고급 변수 스와치\n- Ajax 제품\n- Ajax 검색\n- 소셜 공유\n- 모바일 기기에 최적화\n- 고정 ATC 및 소셜\n- 사이즈 안내 팝업\n- 강력한 필터\n- 인스타그램 샵\n- 팝업 로그인\n- 자동 가격 변경\n- 유연한 내장형 메가 메뉴\n- 퀵뷰 제품 색상\n- 스마트 제품 퀵뷰\n- 고급 계층적 네비게이션\n- 무제한 구글 폰트\n- 사이트 식별\n- 헤더 및 푸터 스타일 옵션\n- 내장형 놀라운 슬라이더\n- 무제한 색상\n- SEO 최적화\n- “New”, “Hot”, “Sale”… 레이블\n- 다국화 지원\n- 놀라운 레이아웃 변화\n- 뉴스레터\n- 반응형 및 레티나 대응\n- 헤더에 드롭다운 장바구니\n- 다양한 스티키 헤더 스타일\n- Ajax 장바구니 & 위시리스트 추가\n- Ajax 페이징 및 Ajax 도구 모음 내장\n- Ajax 그리드 및 목록 보기 컬렉션\n- 제품 보기 페이지에 이전 및 다음 기능\n- 업셀 제품 및 관련 제품 블록용 슬라이더\n- 내장 제품 확대 기능\n- 베스트셀러 제품\n- 맨 위로 버튼\n- 배경 패턴 및 색상 선택기\n- 탭\n- 그리드 / 목록 보기\n- 제품 속성에 대한 \"추가 정보\" 탭\n- 브랜드 로고 슬라이더\n- 내장된 블로그 포스트 슬라이더\n- FontAwesome 아이콘\n- 원 클릭 가져오기\n- 크로스 브라우저 지원\n- 고객 리뷰\n- 연락처\n- 제품 캐러셀\n- HTML5 및 CSS3 및 Sass CSS\n- 소셜 네트워킹\n- 온라인 24/7 지원\n- 상세 문서화\n\n![이미지](/assets/img/2024-06-20-PumpiOrganicVegetablesShopify20Theme_0.png)\n\nEngoTheme님의 Envato Elements에서 제공하는 사진\n\n<div class=\"content-ad\"></div>\n\n면책 조항: 본 글에는 제휴 링크가 포함되어 있습니다. 이는 이 링크를 통해 구매를 하시는 경우 추가 비용 없이 수수료를 받을 수 있음을 의미합니다.","ogImage":{"url":"/assets/img/2024-06-20-PumpiOrganicVegetablesShopify20Theme_0.png"},"coverImage":"/assets/img/2024-06-20-PumpiOrganicVegetablesShopify20Theme_0.png","tag":["Tech"],"readingTime":2}],"page":"40","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}