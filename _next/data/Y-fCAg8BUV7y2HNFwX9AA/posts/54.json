{"pageProps":{"posts":[{"title":"파이썬에서 Uncle Bob의 Clean Code 원칙 적용하는 방법","description":"","date":"2024-06-19 23:23","slug":"2024-06-19-HowtoApplyUncleBobsCleanCodePrinciplesinPython","content":"\n\n![이미지](/assets/img/2024-06-19-HowtoApplyUncleBobsCleanCodePrinciplesinPython_0.png)\n\n온클 밥, 모든 코더의 아버지,는 2008년에 '클린 코드'라는 책을 출판했습니다. 소프트웨어 엔지니어링에 진지하다면, 꼭 이 책을 읽어야 합니다. 이 글에서는 이 책을 요약하고 그 원칙들을 우리의 파이썬 코드에 어떻게 적용할 수 있는지 살펴보겠습니다. 이는 책에서 논의된 SOLID 원칙이 아니라, 코드베이스에서 그것을 따라야 하는 실제 상황에 대한 이야기입니다.\n\n로버트 마틴이 논의한 이 원칙들은 어떤 프로그래밍 언어에도 적용 가능하므로, 내 생각에는 모든 소프트웨어 개발자에게 필수적입니다. 나쁜 코드는 아무도 도와준 적이 없습니다.\n\n이 원칙들이 어떻게 작용하는지 확인하고 싶으신가요? 여기서 제 YouTube 비디오를 확인해보세요: [YouTube 비디오 링크](링크 주소)\n\n<div class=\"content-ad\"></div>\n\n## 깔끔한 코드란 무엇인가요?\n\n로버트 C. 마틴이 쓴 'Clean Code: Agile Software Craftsmanship'에서 소개한 깔끔한 코드란 쉽게 읽고 이해하며 유지보수할 수 있는 코드를 말합니다. 가독성, 간결함, 유지보수성을 강조합니다. 깔끔한 코드는 잘 구조화되어 있고 표준 규칙을 따르며 불필요한 복잡성이 없습니다. 또한 모듈화되어 있고 테스트 가능하며, 단일 책임을 갖는 함수와 메소드를 가지고 있어 코드 수정 및 확장이 쉽게 가능하며 버그를 도입하지 않도록 설계되어 있습니다. 깔끔한 코드의 궁극적인 목표는 견고하고 유연하며 작업하기 즐거운 코드베이스를 만드는 것입니다.\n\n## 깔끔한 코드의 주요 원칙\n\n이러한 일반 규칙은 간단하지만 강력합니다. 자세한 내용을 살펴보고 즐겨 사용하는 프로그래밍 언어인 Python에서 명확한 예제와 함께 이를 어떻게 구현하는지 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n- 표준 규칙 준수하기\n\n표준 규칙을 따르는 것은 깔끔하고 유지보수가 쉬운 코드를 작성하는 데 중요합니다. Python에서는 PEP 8에 따르는 것이 중요합니다. PEP 8는 일관된 Python 코드를 작성하는 데 대한 가이드라인과 모범 사례를 제공합니다.\n\n- KISS 원칙 준수하기\n\n디자인 시에 간결함을 중요시해야 합니다. 간단한 코드는 보다 쉽게 읽고 이해할 수 있으며 유지보수하기도 쉽습니다.\n\n<div class=\"content-ad\"></div>\n\n이 책의 SOLID 원칙과는 논란이 될 수 있습니다. 적용하는 것이 그렇지 않을 때보다 쉽다고 말할 순 없지만 결국 그들이 당신의 삶을 더 나아지게 만들 수 있다는 것은 사실입니다.\n\n- 보이 스카우트 규칙\n\n보이 스카우트 규칙은 항상 코드를 발견한 것보다 깨끗하게 남겨야 한다고 제안합니다. 이것은 지저분한 코드를 발견하면 변경 사항을 가입하는 동안 정리해야 한다는 것을 의미합니다.\n\n- 항상 근본 원인을 찾으세요\n\n<div class=\"content-ad\"></div>\n\n문제의 원인을 항상 찾아보고, 단기적인 해결책을 찾는 대신에 해결하시는 것이 좋습니다. 이렇게 하면 반복되는 문제가 발생하지 않고 시스템의 무결성을 유지할 수 있습니다.\n\n그렇다면, 이제 우리의 Python 코드에 깔끔한 코드 원칙을 적용하는 방법을 살펴보겠습니다.\n\n## if/else 대신 다형성 선호\n\n간단히 말해 다형성은 서로 다른 객체가 동일한 클래스의 인스턴스로 보일 수 있는 능력입니다. 이는 동일한 작업을 서로 다른 클래스에서 다르게 동작하도록 하는 것을 허용합니다. 예를 들어, 다른 클래스가 동일한 이름의 메소드를 가지고 있는 경우, 다형성을 통해 해당 메소드를 각 클래스의 객체에 대해 호출하고 그 클래스의 구현에 따라 특정 결과를 얻을 수 있습니다. 이는 코드에서 유연성과 재사용을 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n다형성을 활용하면 상속과 메서드 재정의를 통해 복잡한 조건 로직을 피할 수 있습니다. 이 접근 방식은 개방/폐쇄 원칙과 일치합니다.\n\n- if/else를 사용한 나쁜 예시\n\n```js\ndef get_discount(customer_type): \n    if customer_type == \"regular\": \n        return 0.1 \n    elif customer_type == \"premium\": \n        return 0.2 else: \n    return 0.0\n```\n\n- 다형성을 활용한 좋은 예시\n\n<div class=\"content-ad\"></div>\n\n```python\nclass Customer:\n    def get_discount(self):\n        return 0.0\n\nclass RegularCustomer(Customer):\n    def get_discount(self):\n        return 0.1\n\nclass PremiumCustomer(Customer):\n    def get_discount(self):\n        return 0.2\n\ndef get_customer_discount(customer):\n    return customer.get_discount()\n```\n\n## Use Dependency Injection\n\n의존성 주입(Dependency Injection, DI)은 클래스에 의존성을 주입할 수 있도록 하는 디자인 패턴으로, 클래스 간의 결합도를 줄이고 테스트 용이성과 유지보수성을 향상시킵니다.\n\n클래스가 자체적으로 의존성을 내부적으로 생성하는 경우, 해당 클래스는 해당 의존성에 강하게 결합됩니다. 이는 클래스가 의존성의 특정 구현에 대해 직접적으로 알고 있고 의존하고 있다는 것을 의미하며, 이를 수정하지 않고는 의존성을 변경하거나 대체하기가 어려워집니다. 이는 의존성 역전 원칙(Dependency Inversion Principle)을 위반하는 것으로, 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화에 의존해야 한다는 원칙에 어긋납니다.\n\n\n<div class=\"content-ad\"></div>\n\n한편, 의존성 주입은 외부에서 클래스로 의존성을 주입할 수 있게 합니다. 이는 클래스가 의존성을 어떻게 생성해야 하는지 알 필요가 없다는 것을 의미합니다. 그 대신 외부에서 제공되는 의존성에 의존하는 방식입니다. 이는 클래스 간의 느슨한 결합을 촉진하는데, 클래스는 구체적인 구현이 아닌 추상화(인터페이스 또는 추상 클래스)에만 의존합니다. 또한 클래스를 테스트하기가 더 쉬우며, 의존성을 테스트 중에는 목업 또는 테스트용 대체품으로 교체할 수 있습니다.\n\n총론적으로, 의존성 주입은 더 유연하고 유지보수하기 쉬운 코드를 이끌며, 객체지향 설계 원칙을 더 잘 준수하게 만듭니다.\n\n- 의존성 주입이 없는 경우\n\n```js\nclass Service: \n    def init(self): \n        self.repository = Repository()\n```\n\n<div class=\"content-ad\"></div>\n\n```python\n    def perform_action(self):\n        data = self.repository.get_data()\r\n```\n\n- DI\n\n```python\r\nclass Service: \n    def init(self, repository): \n        self.repository = repository\n    def perform_action(self):\n        data = self.repository.get_data()\n        # perform action with data\n\nrepository = Repository() \nservice = Service(repository)\r\n```\n\n## Prevent Over-Configurability and Don’t Use Flag Arguments\n\n<div class=\"content-ad\"></div>\n\n소프트웨어를 간단하게 유지하는 것은 불필요한 설정이나 옵션을 추가하지 않는 것을 의미합니다. 플래그 인수는 함수를 복잡하고 이해하기 어렵게 만들 수 있습니다.\n코드에서 과도한 구성 가능성은 복잡성, 유지 관리 부담 증가, 코드 냄새, 가독성 저하와 같은 문제를 일으킬 수 있습니다. 함수가 너무 많은 구성 옵션을 가지고 있는 경우, 단일 책임 원칙(SRP)을 위반하고 있는 것으로, 책임이 불명확하고 코드 구성이 떨어지게 됩니다. 또한, 긴 복잡한 구성이 코드를 읽고 이해하기 어렵게 만들 수 있습니다.\n\n- 플래그 인수를 사용한 나쁜 예시\n\n```js\ndef create_user(name, email, is_admin=False): \n    user = User(name, email) \n    if is_admin: \n        user.set_admin_permissions() \n    return user\n```\n\n- 플래그 인수를 사용하지 않은 좋은 예시\n\n<div class=\"content-ad\"></div>\n\n```js\ndef create_user(name, email): \n    return User(name, email)\n\ndef create_admin_user(name, email): \n    user = User(name, email) \n    user.set_admin_permissions() \n    return user\n```\n\n## Law of Demeter를 따르세요\n\n클래스는 직접적인 의존성만을 알아야 합니다. 이는 느슨한 결합과 캡슐화를 장려하여 코드를 모듈화하고 유지보수하기 쉽게 만듭니다.\n\n- Law of Demeter를 위반하는 나쁜 예\n\n<div class=\"content-ad\"></div>\n\n```python\ndef get_user_info(user): \n    address = user.get_address() \n    city = address.get_city() \n    return city\n```\n\n- 지데르 법칙을 잘 따른 좋은 예시\n\n```python\ndef get_user_info(user): \n    return user.get_city()\n```\n\n## 논리적 의존성 회피하기\n\n<div class=\"content-ad\"></div>\n\n클래스 내의 메서드는 동일한 클래스 내의 다른 메서드의 내부 상태나 동작에 의존해서는 안 됩니다. 각 메서드는 독립적이고 독립적이어야 합니다.\n\n- 논리적 의존성이 있는 나쁜 예시\n\n```js\nclass Calculator: \n    def init(self): \n        self.result = 0\n    def add(self, number):\n        self.result += number\n    \n    def subtract(self, number):\n        self.result -= number\n    \n    def get_result(self):\n        return self.result\n```\n\n- 논리적 의존성이 없는 좋은 예시\n\n<div class=\"content-ad\"></div>\n\n\nclass Calculator: \n    def add(self, a, b): \n        return a + b\n    def subtract(self, a, b):\n        return a - b\n\n\n## 부작용 방지\n\n부작용이 없는 함수는 예측 가능하고, 테스트하기 쉽고, 모듈화되어 있으며, 병렬 실행에 안전하며, 일반적으로 유지보수가 용이하고 가독성이 좋은 코드로 이어집니다. 이러한 함수들은 입력에만 의존하고 외부 상태를 수정하지 않고 출력을 생성해야 합니다.\n\n이것은 또한 SOLID의 \"단일 책임 원칙\"의 예입니다. 함수는 한 가지 일만 수행해야 합니다. 즉, 부작용을 발생시키면 안 됩니다. 변수 2개를 더한 함수라면 콘솔에 뭔가를 로깅해서는 안 됩니다. 데이터베이스에서 사용자를 생성하는 함수라면 검증을 수행해서도 안 됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n- 부작용이 있는 안좋은 예시\n\n```python\ndef add_to_list(item, item_list=[]): \n    item_list.append(item) \n    return item_list\n```\n\n- 부작용이 없는 좋은 예시\n\n```python\ndef add_to_list(item, item_list=None): \n    if item_list is None: \n        item_list = [] \n    \n    new_list = item_list + [item] \n    return new_list\n```\n\n<div class=\"content-ad\"></div>\n\n## 깨끗한 코드를 읽는 가치가 있을까요?\n\n절대로요. 로버트 C. 마틴의 Clean Code는 소프트웨어 개발에 진지한 사람에게 꼭 필요한 책입니다. 이 책은 읽기 쉽고 유지보수가 쉽며 효율적인 코드 작성에 대한 실용적인 조언을 제공하여 더 나은 소프트웨어 품질과 더 쉬운 유지보수를 이루어냅니다. 이 책에 투자하는 시간은 귀하의 코딩 스킬과 전문 실무 방법을 크게 향상시킬 것입니다.\n\n## 결론\n\n요약하면, 우리는 Uncle Bob의 Clean Code에서 여러 원칙을 다뤄보았고 파이썬에서의 적용 방법을 보여주었습니다. 이 책을 꼭 읽어보시기를 강력히 추천합니다. 서로의 코드 품질을 높이는 데 노력합시다.\n\n<div class=\"content-ad\"></div>\n\n클린 코드 책 요약 페이지를 보려면 GitHub 페이지를 확인해보세요.\n\n코딩 즐기세요!","ogImage":{"url":"/assets/img/2024-06-19-HowtoApplyUncleBobsCleanCodePrinciplesinPython_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoApplyUncleBobsCleanCodePrinciplesinPython_0.png","tag":["Tech"],"readingTime":7},{"title":"파이썬 프로젝트를 위한 완벽한 패키지 프로토 타입 제안","description":"","date":"2024-06-19 23:20","slug":"2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects","content":"\n<img src=\"/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_0.png\" />\n\n# 소개\n\nPython 패키지의 구조를 세울 때 고려해야 할 많은 옵션이 있고 많은 결정을 내려야 합니다. 그러나 한 번 디자인 선택사항을 결정하면 기본적인 구조적 변경을 만들기가 매우 어려워집니다.\n\n또한 사용자가 자신의 프로젝트에 네임스페이스를 포함하기 시작했다면, 어떠한 변경을 가하더라도 그 사용자가 소스 코드를 변경해야 할 필요가 생깁니다.\n\n<div class=\"content-ad\"></div>\n\n그러므로 처음에 꾸미고 배치 결정을 잘 내리는 것이 매우 중요합니다.\n\n## 문제\n\n파이썬 패키지를 구성하는데 여러 옵션이 많기 때문에 적절한 디자인을 찾거나 적어도 나중에 문제를 일으키지 않을 디자인을 찾는 것이 어려울 수 있습니다.\n\n## 기회\n\n<div class=\"content-ad\"></div>\n\n일반 패키지 레이아웃을 구성하고 모든 도전 과제를 해결하는 데 필요한 스켈레톤 프로젝트에서 프로토타입을 구축할 수 있다면, 앞으로 패키지를 만드는 것은 빠르고 간단한 복사 및 붙여넣기만으로 완료될 것입니다.\n\n## 앞으로의 계획\n\n제안된 완벽한 패키지 프로토타입에 대한 요구 사항을 설정한 다음, 모든 이러한 요구 사항을 해결하는 표준 프로젝트 구조를 생성할 수 있습니다.\n\n# 배경\n\n<div class=\"content-ad\"></div>\n\n여러 해 동안 많은 파이썬 패키지를 작성해 왔고, 프로젝트 구조를 각각 실험하고 수정하여 완벽한 구조를 찾으려 했지만, 항상 어느 한 측면에서는 불완전한 상태였습니다.\n\n그로 인해 완벽한 패키지 구조에 대한 요구 사항을 작성하고, 모든 원하는 것을 이루기 위한 방법을 찾기 위해 연구에 착수했습니다.\n\n# 요구 사항\n\n- 인기 있는 전문 패키지의 네임 스페이스 관례를 모방해야 합니다 (예: statsmodels.regression.linear_model에서 RegressionResultsWrapper를 가져옵니다).\n- 코드와 클래스를 잘 구조화된 폴더 및 파일 세트로 구성해야 합니다.\n- 패키지 사용자에게 노출되는 네임스페이스가 statsmodels.regression.linear_model과 같이 잘 지어진 체계를 반영해야 하며, 폴더와 파일 이름을 철저하게 따라서는 안 됩니다.\n- 하위 폴더의 클래스가 다른 하위 폴더 및 폴더 계층구조 상위 폴더의 클래스를 참조하고 액세스할 수 있어야 합니다.\n- 패키지 코드를 개발하고 테스트할 수 있는 Jupyter 노트북이 포함된 최상위 폴더를 포함해야 합니다.\n- 패키지의 모든 코드 및 클래스를 발견할 수 있는하위 폴더로 구성된 단위 테스트가 포함된 최상위 폴더를 포함해야 합니다.\n- 모든 패키지 폴더와 하위 폴더의 클래스 docstring에서 자동으로 생성된 문서가 포함된 최상위 폴더를 포함해야 합니다.\n- Jupyter 노트북, 단위 테스트 및 패키지에 접근하는 다른 프로젝트에서 패키지 위치를 하드 코딩하는 것을 피해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 솔루션이 작동하는 것을 증명하기\n\n솔루션을 증명하기 위해 2개의 테스트 클래스를 포함하는 빈 프로젝트 템플릿 또는 스켈레톤을 만들었습니다 -\n\n- class BaseLearner()는 알고리즘 클래스 집합을 위한 베이스 클래스로 설계된 가상의 클래스입니다.\n- class Fisher(BaseLearner)는 \"Fisher\" 알고리즘 코드를 포함할 가상의 클래스로, 이 클래스는 BaseLearner(폴더 구조의 완전히 다른 부분에 위치한)를 상속받는 것이 목적입니다.\n\n# 뒤의 시작하기\n\n<div class=\"content-ad\"></div>\n\n모든 요구 사항을 해결하고 두 개의 테스트 클래스에 대한 개요를 제공하는 완료된 프로젝트/패키지 구조 미리보기입니다 (Fisher 클래스가 fisher_file.py에 포함되어 있고 BaseLearner 클래스가 base_file.py에 포함되어 있는 것을 알립니다)\n\n![이미지](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_1.png)\n\n# 그렇다면 큰 문제는 무엇인가요?\n\n이 구조는 모든 요구 사항을 해결했을 것으로 보이지만, 이 구조에는 주의할 필요가 있는 몇 가지 근본적인 문제가 있습니다...\n\n<div class=\"content-ad\"></div>\n\n# 네이밍 규칙\n\n주어진 패키지 레이아웃에 따라 BaseLearner를 가져오기 위한 코드는 다음과 같습니다.\n\n```python\nfrom common.base_file import BaseLearner\n```\n\n원하는 가져오기는 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\nghpackage.common 모듈에서 BaseLearner를 가져왔습니다.\n\n따라서 이 패키지를 사용하는 사람들이 사용하는 네이밍 규칙이 직관적이지 않고 statsmodels.regression.linear_model에서 사용하는 표준과 일치하지 않을 수 있습니다.\n\n# 상대 및 절대 참조\n\nfisher_file.py에서는 ghtestpackage.common 모듈의 BaseLearner를 불러오는 코드가 작동하지 않을 것입니다. 왜냐하면 현재 위치에서 상대적인 참조를 사용했기 때문입니다. 즉, ghtestpackage.common 모듈에서 BaseLearner를 해결하려는 시도는 algorithms.ghtestpackage.common에서 BaseLearner를 찾지 못할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 큰 문제가 있어요\n\n그 문제는 더 심각해지고 있어요. 다양한 요구 사항을 통합하려고 하면서 이 패키지는 한꺼번에 3가지 역할을 수행하려고 노력하고 있어요:\n\n- 외부에서 참조할 수 있는 패키지.\n- Jupyter 노트북을 실행하는 환경.\n- pytest 단위 테스트를 실행하는 환경.\n\n문제는, 이 3가지 다른 사용 사례가 서로 다른 방식으로 실행되며 다른 상대적인 위치에서 실행을 시작한다는 것이 거의 불가능하다는 것이에요.\n\n<div class=\"content-ad\"></div>\n\n패키지가 Python 프로그램으로 가져올 때, 해당 패키지의 시작 지점은 부모 폴더입니다. 다음 시스템 경로를 고려하면 확인할 수 있습니다...\n\n```js\n[\n  \"c:\\\\Users\\\\GHarr\\\\OneDrive\\\\Python Projects\\\\Public-Github\\\\Package Structure\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\python310.zip\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\DLLs\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\",\n  \"\",\n  \"C:\\\\Users\\\\GHarr\\\\AppData\\\\Roaming\\\\Python\\\\Python310\\\\site-packages\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages\",\n  \"C:\\\\Users\\\\GHarr\\\\OneDrive\\\\Python Projects\\\\Packages\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages\\\\win32\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages\\\\win32\\\\lib\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages\\\\Pythonwin\",\n];\n```\n\n저는 현재 Anaconda를 사용 중이며, project-env 채널을 선택한 상태입니다. 경로에서 알 수 있듯이, **site-packages**가 **c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages**에 위치하고 있습니다.\n\nAnaconda에서 CMD.exe 프롬프트를 실행하고 **site-packages** 폴더의 디렉토리를 나열하여 쉽게 확인할 수 있습니다...\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_2.png)\n\n프로그램이 pandas에서 DataFrame을 가져오는 것과 같이 import를 실행할 때, 참조는 C:\\Users\\GHarr\\anaconda3\\envs\\project-env\\Lib\\site-packages에서 시작되며 DataFrame이 포함 된 pandas라는 이름의 디렉토리를 찾을 것으로 예상합니다.\n\n주피터 노트북은 다르게 동작합니다. 그들의 \"홈\" 위치(또는 시작 실행 경로)는 .ipynb 소스 파일을 포함하는 폴더이며, 참조는 주피터 노트북에서 상대적으로(및 아래로) 진행됩니다.\n\n마지막으로 Visual Studio Code에서의 pytest 단위 테스트는 다시 다르게 동작합니다. VS Code 안에서 pytest 단위 테스트의 홈 / 실행 경로는 프로젝트의 루트 폴더입니다.\n\n<div class=\"content-ad\"></div>\n\n요약하면 다음과 같습니다...\n\n- 참조된 패키지는 프로젝트 폴더의 상위를 기준으로 상대적인 경로를 참조합니다.\n- Jupyter Notebook은 노트북을 포함하는 폴더를 기준으로 상대적인 경로를 참조합니다.\n- pytest 유닛 테스트는 프로젝트의 루트 폴더를 기준으로 상대적인 경로를 참조합니다.\n\n# 큰 문제 해결하기\n\n오랫동안 이 난제에 대한 유일한 해결책은 내 패키지에서 가져와야 하는 프로젝트의 import 코드에 직접 경로를 삽입하는 것이었습니다...\n\n<div class=\"content-ad\"></div>\n\n이 방법은 작동하지만 일부 심각한 단점이 있습니다.\n\n먼저 이 코드를 실행하는 데 매우 느립니다. 프로젝트가 처음으로 로드되고 VS Code에서 실행될 때, 외부 참조를 해결하고 가져오기를 처리하는 데, 꽤 좋은 i7 프로세서를 사용해도 52초가 걸립니다.\n\n다음 단점은 ghlibrary 프로젝트가 구조가 잘못되었다는 것입니다.\n\n예를 들어, dag_tools.py 및 causal_tools.py가 ghlibrary의 루트에 직접 존재하며 위치를 변경하는 옵션이 제한되어 있습니다. 따라서 시간이 지남에 따라 이러한 소스 파일이 커졌고, VS Code는 린팅, 도구 팁 및 기타 기능을 처리하는 데 느려졌습니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n또한, 패키지에 액세스하는 모든 프로젝트에 경로를 추가하는 코드도 포함되어야 하며, 실제로 패키지 위치를 하드코딩해야 합니다. 이 코드는 구성 파일로 옮길 수 있지만, 여러 프로젝트가 패키지에 액세스하고 패키지가 이동한다면 모두 업데이트해야 합니다.\n\n마지막으로, 이 접근 방식을 취하는 것은 패키지를 더 넓은 Python 커뮤니티에 배포하는 옵션을 방지한다는 가장 큰 단점입니다.\n\n홈/실행 폴더는 부모 폴더가 아닌 패키지 폴더이므로 pandas나 pgmpy와는 다르게 작동합니다. 그 이상으로, Python 커뮤니티가 수동 참조 코드를 포함하고 처리 시간이 느려진다는 것을 기대하는 것은 합리적이지 않습니다.\n\n더 나은 대안이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n사이트 패키지의 경로는 sys.path를 실행하여 쉽게 식별할 수 있습니다. 이미 제 컴퓨터에서는 C:\\Users\\GHarr\\anaconda3\\envs\\project-env\\lib\\site-packages임을 확인했습니다.\n\n파일 이름과 .pth 확장자가 붙은 파일을 생성한 다음, 해당 파일을 site-packages 폴더에 저장하면 Anaconda가 자동으로 읽어 시작 시 삽입할 패키지 경로를 추가할 수 있습니다.\n\n여기에 제 .pth 파일이 어떻게 생겼는지 알려드리겠습니다...\n\n![링크명](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_3.png)\n\n<div class=\"content-ad\"></div>\n\n이 의미는 만약 ghtestpackage가 C:\\Users\\GHarr\\OneDrive\\Python Projects\\Packages의 하위 폴더로 생성된다면, 모든 Python 프로젝트의 검색 경로에 자동으로 포함되며 그 안에 포함된 모든 파일 및 클래스를 참조하고 가져올 수 있게 됩니다…\n\n- 한 번에 특정 경로를 모든 프로젝트에 하드 코딩할 필요가 사라집니다.\n- 또한, 컴퓨터 전체에서 Packages 경로에 대한 단일 참조만 있기 때문에 pandas 및 기타 인기 있는 패키지와 완전히 동일한 방식으로 작동합니다.\n- 만약 이 패키지가 GitHub을 통해 분산되고 pip 사용자가 이를 사이트 패키지 폴더에 다운로드한다면 계속해서 작동할 것입니다.\n\n모든 이러한 것들이 한 줄의 코드를 한 파일에 추가함으로써 해결됩니다!\n\n큰 문제가 해결되면 나머지 요구사항을 달성하는 것이 훨씬 쉬워질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 남은 문제 해결하기\n\n## 패키지를 서브 폴더와 파일로 구성하기\n\n제가 소스 파일을 base_file.py 및 fisher_file.py로 명명하고 서브 폴더를 base_folder 및 fisher_folder로 명명한 것을 알아채셨을지도 모릅니다.\n\n소스 파일을 서브 폴더와 파일로 구성해야 하지만, 반대로 가져오기(import)할 때 이러한 이름을 사용하고 싶지는 않을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 다음과 같이 import하는 것은 너무 길고 직관적이지 않습니다.\n\nfrom ghlibrary.algorithms.fisher_folder.fisher_file import Fisher\n\n더 나은 import 방법은 다음과 같습니다.\n\nfrom ghlibrary.algorithms import Fisher\n\n<div class=\"content-ad\"></div>\n\n하지만 코드를 폴더 및 파일로 계층적으로 분할하는 유연성과 패키지의 소비자에게 표시되는 가져오기를 여전히 제어할 수도 있습니다. 이것은 패키지 각 수준에 있는 **init**.py 파일을 통해 이루어집니다.\n\nghpackage\\algorithms\\fisher_folder부터 시작합니다. 여기에 있는 **init**.py 파일은 다음과 같습니다.\n\n```python\nfrom .fisher_file import Fisher\n```\n\n이는 전처리기에게 현재 폴더의 fisher_file.py를 찾도록 지시합니다. ( .은 현재 폴더에 대한 표기법입니다.) 그리고 Fisher 클래스는 이제 fisher_file이 아닌 fisher_folder에 직접 존재하며 해당 폴더에서 참조할 수 있습니다.\n\n이 시점에서 가져오기를 from ghlibrary.algorithms.fisher_folder import Fisher로 단축시킬 수 있으나 더 나은 방법이지만 완벽하지는 않습니다.\n\n<div class=\"content-ad\"></div>\n\n다음 단계는 알고리즘 폴더에 다음과 같이 **init**.py를 제공하는 것입니다...\n\n이전 단계에서 fisher_folder에 추가한 참조를 취하고, 이를 알고리즘 폴더에서 사용할 수 있도록 만듭니다.\n\nfrom .fisher_folder import Fisher은 전처리기에게 현재 폴더에서 시작 (.은 여기에서 시작하라는 뜻이며, algorithms에서 시작) 하고 fisher_folder로 한 수준 아래로 이동하여 Fisher 클래스를 가져오도록 지시합니다.\n\n패키지를 사용하는 소비자는 이제 다음을 사용할 수 있습니다 -\n\n<div class=\"content-ad\"></div>\n\nghlibrary.algorithms에서 Fisher를 가져와주세요.\n\n베이스 클래스를 마무리하기 위해서 동일한 처리가 필요합니다.\n\nghpackage\\common 하위 폴더의 **init**.py 파일은 다음과 같습니다...\n\n그리고 common 폴더에 추가 하위 폴더가 없기 때문에 그게 전부입니다.\n\n<div class=\"content-ad\"></div>\n\n소비자 분들은 다음과 같이 참조할 수 있어요...\n\n```python\nfrom ghpackage.common import BaseLearner\n```\n\n... 심지어 BaseLearner 클래스가 base_file.py에 저장되어 있는 경우에도요.\n\n하위 폴더와 파일로 계층적으로 구성된 프로젝트 클래스들은 이제 클라이언트가 다음과 같이 참조할 수 있어요...\n\n<div class=\"content-ad\"></div>\n\n아직 풀지 않은 수수께끼가 하나 있습니다. Fisher 클래스의 소스 코드를 살펴보십시오...\n\n문제는 Fisher()가 ghtestpackage/algorithms/fisher_folder/fisher_file.py에 있고 ghtestpackage.common에서 from ghtestpackage.common import BaseLearner를 사용하여 BaseLearner를 가져오는 방법입니다.\n\nBaseLearner는 ghtestpackage/common/base_file.py에 위치해 있고 따라서 ghtestpackage.common에서 from ghtestpackage.common import BaseLearner를 사용하는 것은 동작하지 않아야 합니다.\n\n동작하는 이유는 .pth 파일을 사용하여 Anaconda에 C:\\Users\\GHarr\\anaconda3\\envs\\project-env\\lib\\site-packages를 포함하도록 알려주었기 때문입니다. 이 경로는 ghtestpackage의 상위 폴더입니다. 따라서 ghtestpackage.common에서 BaseLearner를 참조하는 것은 패키지의 상위 폴더에서 해결됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 단계에서는 \"완벽한 패키지 프로토타입\"이 생성되었고, 남은 일은 그것이 예상대로 작동하는지 증명하기 위해 철저히 테스트하는 것입니다.\n\n# 완벽한 패키지 프로토타입 테스트\n\n증명 및 테스트를 시작하려면 ghtestpackage/common/base_file.py의 BaseLearner() 및 ghtestpackage/algorithms/fisher_folder/fisher_file.py의 Fisher()의 소스 코드를 확인해보세요...\n\nBaseLearner()이 서로 다른 폴더 위치의 여러 알고리즘을 위한 기본 클래스가 될 것이라는 아이디어 때문에, 이 코드는 common 폴더로 분리되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이번 데모에서 기본 클래스에는 서브 클래스에서 호출할 수 있어야 할 단일 메서드가 있습니다. 각 클래스는 호출되었음을 증명하기 위해 icecream을 사용하여 디버그 메시지를 출력합니다.\n\n## 주피터 노트북 클라이언트 테스트\n\nghtestpackage\\notebooks 폴더에는 ghtest_notebook.ipynb라는 주피터 노트북이 있습니다. 이는 \"완벽한 패키지\" 구조가 패키지 코드를 개발하고 테스트하는 데 도움이 되는 노트북을 포함할 수 있어야 한다는 요구 사항을 충족하기 위한 것입니다.\n\n노트북에 있는 코드는 다음과 같습니다...\n\n<div class=\"content-ad\"></div>\n\n그리고 이것이 출력 결과입니다...\n\n```js\nic | \"BaseLearner.init\";\nic | \"BaseLearner.init\";\nic | \"fisher.init\";\nic | \"BaseLearner.test\";\n```\n\n...결과적으로 베이스 클래스와 알고리즘 클래스를 참조하고 인스턴스화하고 호출할 수 있다는 것을 증명했습니다.\n\n또한 주의할 점은 완전히 별도의 프로젝트에 노트북이 생성되고 위의 코드가 셀에 입력된 경우에도 모든 작업이 올바르게 수행된다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## pytest 클라이언트 테스트 중\n\n여기에는 ghtestbackage/unit_tests/test_base/test_base.py에 저장된 기본 클래스를 테스트하기 위한 코드가 있습니다...\n\n... 그리고 여기에는 ghtestbackage/unit_tests/test_fisher/test_fisher.py의 코드가 있습니다.\n\n다시 말하지만, .pth 파일의 지시에 따라 패키지의 부모 폴더를 시스템 경로에 추가했기 때문에 참조가 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n최종 증명은 VS Code의 단위 테스트 패널로 이동하여 단위 테스트가 식별되고 발견되었는지 확인하고, 모두 실행하여 오류 없이 완료되는지 확인하는 것입니다...\n\n![image](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_4.png)\n\n이것은 제안된 완벽한 패키지 프로토타입의 주요 이점 중 하나입니다 —\n\n# 문서 작성\n\n<div class=\"content-ad\"></div>\n\n마지막 요구 사항은 문서 생성과 관련이 있습니다. 한 가지 방법은 모듈, 클래스 및 함수에 포괄적인 독스트링이 있는지 확인하는 것입니다(이 스텁은 VS Code에서 자동으로 생성될 수 있습니다).\n\n다음은 잘 구조화되고 포괄적인 독스트링의 예시입니다…\n\n이러한 독스트링은 작성하는 데 시간이 걸리지만 메서드의 기능, 매개변수, 반환 값, 호출 방법 예시 및 맥락적인 참고 사항을 완벽하게 기록합니다.\n\n이 접근 방식을 모든 소스 코드에 적용하면 pydoc를 사용하여 HTML 형식의 도움말 파일을 자동으로 생성하는 것이 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n제안된 프로젝트 프로토타입에는 makedocs.bat 파일이 포함된 docs라는 폴더가 있습니다...\n\n```js\npython -m pydoc -w \"..\\algorithms\\fisher_folder\\fisher_file.py\"\npython -m pydoc -w \"..\\common\\base.py\"\n```\n\n해야 할 일은 단순히 docs 폴더에서 makedocs를 실행하면 docstrings에서 자동으로 문서가 생성됩니다...\n\n![이미지](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_5.png)\n\n<div class=\"content-ad\"></div>\n\n많은 다양한 방법으로 도움 파일을 작성하고 생성할 수 있지만 여기서는 pydoc을 선택했습니다. pydoc은 코드와 클래스의 목적과 사용을 설명하는 문서를 빠르고 쉽게 생성할 수 있는 방법을 제공하기 때문입니다.\n\n# 마지막으로 — 디버깅 테스트\n\n현재 제안된 것은 거의 작동하지만 한 가지 더 있습니다...\n\n유닛 테스트가 실패하거나 예상치 못한 결과를 내는 경우 디버깅이 필요할 수 있으며 이 구성에서는 VS Code에서 유닛 테스트 내에서 디버깅을 시작하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n디버깅을 시도하면 \"Invalid message: Found duplicate in \"env\": PATH\"와 함께 프로세스가 크래시됩니다.\n\n오류 대화상자에서는 launch.json을 열 수 있는 옵션이 제공되며, 이를 통해 .vscode 폴더에 다음과 같이 보이는 launch.json 파일이 생성됩니다.\n\n그런데 여전히 제대로 작동하지 않습니다. 목적 속성을 설정하기 위해 추가로 라인을 추가해야 합니다.\n\n여기에 파이널 프루프가 있습니다 — pytest 단위 테스트인 test_fisher_3()가 디버깅되고 있으며, 곧 \"test_fisher\"를 커맨드 라인에 출력할 예정입니다...\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_6.png\" />\n\n# 결론\n\n어떤 프로그래밍 프로젝트도 잘 구조화되고 잘 작성된 코드에 의존하여 코드가 효율적으로 구축되고 예기치 않은 결과를 출력할 때 효과적으로 디버깅 및 수정할 수 있습니다.\n\n또한, 원래 프로그래머거나 다른 사람에 의해 언젠가는 코드를 변경해야 할 것이고 미래 관리 가능성의 효과성을 위해서는 잘 작성된 코드가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n그럼, 코드를 포함하는 프로젝트가 잘 구조화되고 조직화되어 훌륭한 코드를 제공할 수 있는 기반이 제공되기 때문에 이것이 가능합니다.\n\n프로젝트가 1000줄 이상을 포함하는 경우, 여전히 상대적으로 적은 규모이지만, .py 파일을 여러 개에 걸쳐 지능적으로 분산하지 않으면 VS Code가 느려지고 린팅, 코드 개요 및 타입-어헤드와 같은 기능이 제대로 동작하지 않을 수 있습니다.\n\n이 모든 것의 핵심은 첫 번째 코드 줄을 작성하기 전에 프로젝트 구조를 올바르게 가져야 한다는 것입니다.\n\n이 기사는 요구 사항의 집합을 설명하여 테스트를 통해 이러한 요구 사항을 충족하는 레이아웃 및 구조를 제시함으로써 \"완벽한\" 패키지 구조에 대한 한 제안을 제시했습니다.\n\n<div class=\"content-ad\"></div>\n\n주요 도전 과제는 전문적인 네임스페이스의 최상의 폴더 및 파일 레이아웃을 통합하고 클래스가 .pth 파일을 구성하고 **init**.py 파일의 항목을 통해 일반 프로젝트, Jupyter 노트북 및 pytest 단위 테스트로 가져올 수 있도록 하는 것이었습니다.\n\n파이썬 프로젝트용 완벽한 패키지 프로토타입에 대한 다른 제안이 많을 수 있겠지만, 이 프로젝트는 매우 잘 작동합니다.\n\n# 추가 섹션: 프로토타입 빠르고 쉽게 사용하기...\n\n패키지 프로토타입 프로젝트는 다음 링크를 통해 GitHub에서 다운로드할 수 있습니다...\n\n<div class=\"content-ad\"></div>\n\n... 그리고 다음 단계를 따릅니다...\n\n- 프로젝트를 다운로드하세요.\n- 이를 개발 패키지를 저장할 부모 폴더 바로 아래에 위치시킵니다.\n- docs 하위 폴더에서 mypackages.pth 파일을 Anaconda 설치의 site-packages 폴더로 복사합니다.\n- mypackages.pth 파일을 편집하여 로컬 컴퓨터에서 만든 경로로 대체합니다.\n- Jupyter Notebook 및 pytest 유닛 테스트를 실행하여 참조 및 네임스페이스를 확인합니다.\n- 뼈대 프로젝트를 복사하여 Fisher() 및 BaseLearner()를 실제 클래스로 대체하고 제품 코드로 배치를 시작합니다.\n\n만약 로컬 컴퓨터에서 site-packages 폴더가 어디에 있는지 모호하다면, 간단히 sys를 import하고 sys.path 명령을 실행하여 다음과 유사한 경로를 찾아보세요...\n\n```js\nC:\\Users\\GHarr\\anaconda3\\envs\\project-env\\lib\\site-packages\n```\n\n<div class=\"content-ad\"></div>\n\n# 소통하고 연락하기...\n\n이 기사가 마음에 드셨다면 제 소식을 받아보려면 팔로우해주세요.\n\n인과 추론(저의 다른 최근 기사 참조)에 대한 생각 또는 견해가 있다면 언제든지 연락주세요. 이 흥미로운 새로운 데이터 과학 분야가 어디로 향하고 있는지 알려주세요. 메시지를 남겨주시면 저에게 연락드리겠습니다.\n\n제 이전 기사는 제 연구와 인과 추론과 관련된 모든 내용이 담겨 있는 제 블로그(The Data Blog)에서 확인하실 수 있습니다. 감사합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_0.png"},"coverImage":"/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_0.png","tag":["Tech"],"readingTime":14},{"title":"팬더스를 포함한 다양한 라이브러리에서 Case-When 다시 살펴보기","description":"","date":"2024-06-19 23:17","slug":"2024-06-19-LetsRevisitCase-WheninDifferentLibrariesIncludingtheNewPlayerPandas","content":"\n\n\n![이미지](/assets/img/2024-06-19-LetsRevisitCase-WheninDifferentLibrariesIncludingtheNewPlayerPandas_0.png)\n\n데이터 분석, 데이터 정리 또는 심지어 피처 엔지니어링을 할 때, 다른 열의 값에 기반한 새로운 열을 만드는 것은 자주 수행되는 작업입니다.\n\n나는 데이터 정리 및 조작에 사용한 모든 도구들이 이 작업을 위한 함수를 가지고 있었다 (예: SQL, R 데이터 테이블, PySpark). 이제 우리에게 새로운 플레이어가 등장했습니다: Pandas.\n\n그런데, Pandas로 조건부 열을 만드는 것은 가능했지만, 전용 case-when 함수는 없었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n판다 2.2.0에서 case_when 함수가 도입되어 한 개 이상의 조건에 기반한 Series 객체를 생성할 수 있습니다.\n\n이 유용한 작업을 어떻게 수행하는지 다시 살펴봅시다. 이것은 데이터 분석 및 조작 도구로 널리 사용되는 방법입니다.\n\n도구 간 차이를 쉽게 식별하고 일관성 있게 유지하기 위해 작은 데이터셋을 사용하겠습니다.\n\n## SQL\n\n<div class=\"content-ad\"></div>\n\n다음은 'mytable'이라는 작은 SQL 테이블입니다.\n\n```js\n|           a |        b |       c |\n|-------------|----------|---------|\n|           0 |        5 |       1 |\n|           1 |       -1 |       0 |\n|           5 |       20 |       0 |\n|           4 |        8 |       1 |\n|           4 |        4 |       1 |\n|          10 |        7 |       0 |\n|           4 |        2 |       1 |\n```\n\n기존 열의 값에 따라 새로운 열을 생성할 것입니다. 다음은 조건입니다:\n\n- a 열이 b 열보다 크면 a 열의 값이 사용됩니다.\n- a 열이 b 열보다 작으면 a 열과 c 열의 곱이 사용됩니다.\n- 그렇지 않은 경우 (즉, a 열이 b 열과 같은 경우), a 열과 b 열의 합이 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n필요에 따라 여러 조건을 만들고, 그것들을 훨씬 복잡하게 만들 수 있지만, 이 세 가지 조건은 논리를 배울 때 충분합니다.\n\n새 열을 \"d\" 라고 부르고, 위 두 조건에 기반한 이 열을 생성하기 위한 SQL 코드는 다음과 같습니다:\n\n```js\nselect \n  (case \n     when a > b then a\n     when a < b then a * c\n     else a + b end\n  ) as d\nfrom mytable\n```\n\n이 SQL 코드는 \"mytable\"에서 열 d만 생성하고 선택합니다. 열 a, b, c를 함께 반환하도록 필요하다면, select 문에 해당 열을 작성해주세요.\n\n<div class=\"content-ad\"></div>\n\n```R\nselect \n  a,\n  b,\n  c,\n  (case \n     when a > b then a\n     when a < b then a * c\n     else a + b end\n  ) as d\nfrom mytable\n```\n\n## R data table\n\n데이터 테이블 패키지는 R 프로그래밍 언어를 위한 매우 효율적인 데이터 분석 및 조작 도구입니다.\n\n이제 이 패키지를 사용하여 조건부 열 d를 생성하는 방법을 배워보겠습니다. 먼저 SQL 테이블과 동일한 열을 포함하는 데이터 테이블을 만들어봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nmytable <- data.table(\n      a=c(0, 1, 5, 4, 4, 10, 4), \n      b=c(5, -1, 20, 8, 4, 7, 2), \n      c=c(1, 0, 0, 1, 1, 0, 1)\n)\n```\n\n데이터 테이블에서 조건에 맞는 경우 fcase 함수를 사용하여 구현할 수 있습니다. 조건을 작성하고 해당하는 값들을 쉼표로 구분하여 입력할 수 있습니다.\n\n다음은 주어진 조건에 따라 열 d를 만드는 방법입니다:\n\n```js\nmytable[, d := (fcase(a > b, a, a < b, a*c, a==b, a+b))]\n```\n\n<div class=\"content-ad\"></div>\n\nfcase 함수 내부의 첫 번째 표현식(a ` b)은 첫 번째 조건이며, 두 번째 표현식(a)은 해당 값을 나타냅니다. 세 번째 표현식(a ` b)은 두 번째 조건이며, 네 번째 표현식(a*c)은 해당 값을 의미합니다. 그리고 이어서 계속됩니다.\n\n이제 데이터 테이블 \"mytable\"은 다음과 같습니다:\n\n```js\n    a  b c  d\n1:  0  5 1  0\n2:  1 -1 0  1\n3:  5 20 0  0\n4:  4  8 1  4\n5:  4  4 1  8\n6: 10  7 0 10\n7:  4  2 1  4\n```\n\n## PySpark\n\n<div class=\"content-ad\"></div>\n\n파이스파크는 대규모 데이터 처리에 사용되는 분석 엔진인 Spark를 위한 Python API입니다. 수십억 개의 행을 가진 데이터셋 작업에는 보통 Spark가 선호되는 도구입니다.\n\nPySpark API는 매우 직관적이며 이해하기 쉬운 구문을 가지고 있습니다. 먼저 이전과 동일한 열과 값이 포함된 Spark DataFrame을 만들어 봅시다.\n\n```python\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import functions as F\nspark = SparkSession.builder.getOrCreate()\n\ndata = [\n    {\"a\": 0, \"b\": 5, \"c\": 1},\n    {\"a\": 1, \"b\": -1, \"c\": 0},\n    {\"a\": 5, \"b\": 20, \"c\": 0},\n    {\"a\": 4, \"b\": 8, \"c\": 1},\n    {\"a\": 4, \"b\": 4, \"c\": 1},\n    {\"a\": 10, \"b\": 7, \"c\": 0},\n    {\"a\": 4, \"b\": 2, \"c\": 1}\n]\n\nmytable = spark.createDataFrame(data)\n```\n\n우리는 먼저 spark 세션을 시작하고 그 후에 DataFrame을 만들었습니다. Databricks와 같은 개발 환경에서 작업하는 경우에는 명시적으로 spark 세션을 생성할 필요가 없다는 점에 유의하세요.\n\n<div class=\"content-ad\"></div>\n\nwithColumn 함수를 사용하여 새 열을 생성하고 여러 조건에 따라 값을 결정하기 위해 when 함수를 사용할 수 있습니다.\n\n```js\nmytable = (\n    mytable\n    .withColumn(\"d\",\n                F.when(F.col(\"a\") > F.col(\"b\"), F.col(\"a\"))\n                 .when(F.col(\"a\") < F.col(\"b\"), F.col(\"a\") * F.col(\"c\"))\n                 .otherwise(F.col(\"a\") + F.col(\"b\")))\n)\n\nmytable.show()\n\n+---+---+---+---+\n|  a|  b|  c|  d|\n+---+---+---+---+\n|  0|  5|  1|  0|\n|  1| -1|  0|  1|\n|  5| 20|  0|  0|\n|  4|  8|  1|  4|\n|  4|  4|  1|  8|\n| 10|  7|  0| 10|\n|  4|  2|  1|  4|\n+---+---+---+---+\n```\n\n이전 도구와 마찬가지로 필요한만큼 많은 조건을 결합할 수 있습니다. 각 조건은 자체 when 함수를 가지고 있고 최종 조건의 값 (이전 조건 중 어느 것도 충족되지 않을 경우)은 otherwise 함수를 사용하여 지정됩니다.\n\n## 판다스\n\n<div class=\"content-ad\"></div>\n\n팬더스는 데이터 분석 및 조작 작업 중 가장 자주 사용되는 도구일 수 있습니다. 버전 2.2.0 이전에는 팬더스에 case_when 함수가 없었습니다. 그러나 다른 함수들을 사용하여 작업을 처리할 수 있었습니다. 예를 들어, 팬더스의 where 함수나 NumPy의 where 및 select 함수를 사용할 수 있었습니다. 그러나 지금은 팬더스에 case_when 함수가 있으니 다른 도구들로 작업하던 것을 이 함수를 사용하여 보겠습니다.\n\n먼저 팬더스 데이터프레임을 생성해보겠습니다.\n\n```python\nimport pandas as pd\n\nmytable = pd.DataFrame(\n    {\n        \"a\": [0, 1, 5, 4, 4, 10, 4],\n        \"b\": [5, -1, 20, 8, 4, 7, 2],\n        \"c\": [1, 0, 0, 1, 1, 0, 1]\n    }\n)\n```\n\ncase_when 함수는 조건 및 해당 값을 튜플로 포함하는 케이스 리스트를 인수로 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncaselist = [\n    (mytable[\"a\"] > mytable[\"b\"], mytable[\"a\"]),\n    (mytable[\"a\"] < mytable[\"b\"], mytable[\"a\"] * mytable[\"c\"]),\n    (mytable[\"a\"] == mytable[\"b\"], mytable[\"a\"] + mytable[\"b\"])\n]\n\nmytable.loc[:, \"d\"] = mytable[\"a\"].case_when(caselist)\n\nmytable\n\n    a  b  c  d\n0   0  5  1  0\n1   1 -1  0  1\n2   5 20  0  0\n3   4  8  1  4\n4   4  4  1  8\n5  10  7  0 10\n6   4  2  1  4\n```\n\ncaselist의 각 튜플은 조건과 해당하는 값이 포함되어 있어요. DataFrame의 열에 대해 case_when 함수를 적용할 때 중요한 점이에요. 주어진 조건 중 어느 조건도 충족되지 않는 행이 있는 경우, 새 열의 해당 행은 원래 열의 값을 가져와요.\n\n위의 예시에서, 만약 그러한 행이 있다면, 열 d의 해당 값은 열 a에서 가져오게 될 거에요. caselist의 마지막 조건을 제거하여 시도해보겠어요.\n\n```js\ncaselist = [\n    (mytable[\"a\"] > mytable[\"b\"], mytable[\"a\"]),\n    (mytable[\"a\"] < mytable[\"b\"], mytable[\"a\"] * mytable[\"c\"])\n]\n\nmytable.loc[:, \"d\"] = mytable[\"a\"].case_when(caselist)\n\nmytable\n\n    a  b  c  d\n0   0  5  1  0\n1   1 -1  0  1\n2   5 20  0  0\n3   4  8  1  4\n4   4  4  1  4\n5  10  7  0 10\n6   4  2  1  4\n```\n\n<div class=\"content-ad\"></div>\n\n4번 행의 값들을 확인해 보세요. 열 d의 값은 열 a의 값과 같습니다.\n\n## 마지막으로\n\n데이터 정리, 분석 및 조작을 위한 많은 도구와 라이브러리가 있습니다. 대부분의 경우 사용할 도구는 선택의 문제입니다. 이러한 도구들은 일반적인 작업을 효율적으로 수행할 수 있는 능력을 갖추고 있습니다. 그러나 여전히 다양한 도구를 사용하여 특정 작업을 수행하는 방법을 알고 있는 것이 좋습니다.\n\n이 글에서는 SQL, PySpark, R 데이터 테이블 및 Pandas를 사용하여 조건부 열을 생성하는 방법에 대해 배웠습니다.\n\n<div class=\"content-ad\"></div>\n\n읽어 주셔서 감사합니다. 피드백이 있으시면 언제든 알려주세요!","ogImage":{"url":"/assets/img/2024-06-19-LetsRevisitCase-WheninDifferentLibrariesIncludingtheNewPlayerPandas_0.png"},"coverImage":"/assets/img/2024-06-19-LetsRevisitCase-WheninDifferentLibrariesIncludingtheNewPlayerPandas_0.png","tag":["Tech"],"readingTime":6},{"title":"Nestjs 오류 처리","description":"","date":"2024-06-19 23:16","slug":"2024-06-19-NestjsErrorHandling","content":"\n\n<img src=\"/assets/img/2024-06-19-NestjsErrorHandling_0.png\" />\n\n# 1. 소개\n\nNestJs는 백엔드 시스템을 개발하는 데 사용되는 프레임워크입니다. 이 프레임워크는 컨트롤러 레이어에서 오류 처리에 대한 규칙을 정의했지만, 이는 대규모 프로젝트에는 충분하지 않을 수 있습니다. 본 문서에서는 오류를 우아하게 처리하고 신중하게 대우하는 더 효과적이고 구조화된 접근 방식을 소개합니다.\n\n# 2. 오류 처리 전략\n\n<div class=\"content-ad\"></div>\n\n# 에러 유형\n\n코드에서 발생할 수 있는 에러 유형을 정의해보겠습니다:\n\n- 유효성 검사 에러\n- 제삼자 에러\n- 데이터베이스 에러\n- 일반(예기치 않은) 에러\n\n언급된 모든 종류의 에러에 특히 주의해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n특정 오류, 예를 들어 유효성 검사 오류와 같은 경우 적절한 응답이나 상태 코드로 처리할 수 있습니다. 그러나 일반 오류와 같은 다른 종류의 오류의 경우, 유지보수자에게 알리거나 높은 우선순위로 티켓을 생성하는 등의 추가 조치가 필요할 수 있습니다. 또 다른 오류 유형인 데이터베이스 오류는 복구와 복원 논리가 필요할 수 있습니다.\n\n# 3. 다른 계층에서의 오류 처리\n\n저는 우리의 응용프로그램 계층을 다음과 같이 분류하는 것을 선호합니다:\n\n- 요청 계층\n- 인터셉터\n- 가드\n- 컨트롤러 계층(*)\n- 서비스 계층\n- 모델\n- 데이터베이스\n- 예외 처리 계층\n\n<div class=\"content-ad\"></div>\n\n컨트롤러 레이어 아래의 모든 레이어에서 오류가 발생하면 상위 레이어로 throw해야 합니다. 예를 들어:\n\n- 데이터베이스 CRUD 함수(ORM 함수 등)에서 오류가 발생하면 Database Error 유형을 throw해야 합니다.\n- 서드파티 호출(Stripe 등)에서 오류가 발생하면 Third-party 에러 유형을 throw해야 합니다.\n- 예기치 않은 오류가 발생하면 Generic 에러 유형으로 간주해야 합니다.\n- 등등\n\n```js\nasync sampleFucntion(@AuthenticatedUser() jwtPayload: JwtDto) {\n        try {\n            return this.utilsService.apiResponse(200, await this.sampleService.sampleServiceFucntion(jwtPayload.id))\n        } catch (error) {\n            this.utilsService.handleError(error, jwtPayload, {}, 'description')\n        }\n    }\n```\n\n언급한 모든 오류는 상위 레이어로 throw되어야 하며, throw된 오류를 받은 해당 레이어도 Controller 레이어가 `try-catch` 블록에서 오류를 받게 될 때까지 throw해야 합니다. 그런 다음 Controller 레이어는 잡힌 오류를 utils 모듈이나 errors 모듈에 포함된 `ErrorHandler` 함수로 전달해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 오류 처리기 함수\n\n이 함수는 받은 오류 유형을 Switch-case 또는 if-else 방식으로 감지하여 처리해야 합니다.\n\n```js\nhandleError(error, jwt: JwtDto, additionalInfo: any, description: string): void {\n        if (error instanceof CheckingException) {\n            throw new CheckingException(error.message, error.statusCode,error.messageData)\n        } else if (error instanceof DatabaseException) {\n            throw new DatabaseException(error.message, error, error.queryParams, description)\n        } else if (error instanceof StripeErrorException) {\n            throw new StripeErrorException(error as Stripe.errors.StripeError, error.stack, description)\n        } else if (error instanceof HttpException){\n                throw error\n        } else {\n            throw new GenericException(error.message, error, jwt, additionalInfo, description)\n        }\n    }\n```\n\n유형을 감지한 후, 각 오류 유형에 적합한 매개변수로 오류 유형을 생성하고 해당 오류를 throw해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n샘플 Exception 클래스:\n\n```js\nexport class DatabaseException extends Error {\n    queryParams: any\n    description: any\n    stack:any\n    message : string\n    constructor(message: string,error: Error, q: any, description?: string) {\n        super(`데이터베이스 오류가 발생했습니다: ${message}`)\n        this.queryParams = q\n        this.description = description\n        this.stack = error.stack\n        this.message = error.message\n    }\n}\n```\n\n특정 APP_FILTER를 정의하고 app.module에서 등록해야 합니다:\n\n```js\nproviders: [\n    {\n        provide: APP_FILTER,\n        useClass: GenericExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: checkingExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: DatabaseExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: StripeExceptionFilter,\n    },\n    AppService,\n    UtilsService,\n    JwtService,\n    LoggerService,\n]\n```\n\n<div class=\"content-ad\"></div>\n\n예외 필터에서는 이제 이러한 오류 중 하나에 완벽하게 대응해야 합니다:\n다음 조건을 고려해 주세요:\n\n- 데이터베이스 및 일반적인 오류는 유지보수자에게 알리고 처리된 오류에 대한 사용자 응답이 있어야 합니다.\n- Stripe 및 Checking(유효성) 오류는 사용자에게만 응답해야 합니다.\n\n데이터베이스 및 일반적인 오류에 대한 샘플 예외 필터:\n\n```js\n// database.filter.ts\nimport { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common'\nimport { LoggerService } from '../../../../logger/logger.service'\nimport { GenericException } from './generic.exception'\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@Catch(GenericException)\nexport class GenericExceptionFilter implements ExceptionFilter {\n    constructor(private readonly loggerService: LoggerService) {}\n    catch(exception: GenericException, host: ArgumentsHost) {\n        const ctx = host.switchToHttp()\n        const response = ctx.getResponse()\n        const errorData = {\n            description: exception.description,\n            stack: exception.stack,\n            jwtPayload: exception.jwtPayload,\n            additionalInfo: exception.additionalInfo,\n            message: exception.message,\n        }\n        this.loggerService.error(exception.message, errorData)\n        response.status(500).json({\n            statusCode: 500,\n            message: exception.message,\n            error: 'Error',\n        })\n    }\n}\n```\n\nWinston 로거를 사용하여 오류 수준 로그를 송신 및 티켓 생성을 위해 로그 전송기를 정의했습니다:\n\nthis.loggerService.error(exception.message, errorData)\n\n일반적인 오류(외부 라이브러리 또는 유효성 검사 오류)에 대한 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common'\nimport { CheckingException } from './checking.exception'\n```\n\n```js\n@Catch(CheckingException)\nexport class checkingExceptionFilter implements ExceptionFilter {\n    catch(exception: CheckingException, host: ArgumentsHost) {\n        const ctx = host.switchToHttp()\n        const response = ctx.getResponse()\n        response.status(exception.statusCode).json({\n            statusCode: exception.statusCode,\n            message: exception.messageData,\n            error: exception.message,\n        })\n    }\n}\n```\n\n# 모니터링 도구\n\n더 나은 오류 처리를 위해 몇 가지 도구를 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- Sentry\n- Raygun\n- Winston\n- 등\n\n이 프로젝트에서는 Raygun을 사용하여 오류 모니터링 및 보고를 합니다.\n\n## Raygun\n\nRaygun은 개발자가 애플리케이션에서 문제를 식별하고 전체 소프트웨어 품질을 향상시키는 종합 오류, 충돌 및 성능 모니터링 솔루션입니다.\n\n<div class=\"content-ad\"></div>\n\n```typescript\nasync createUser(createUserDto: CreateUserDto): Promise<User> {\n    try {\n      // 사용자 생성을 위한 비즈니스 로직\n    } catch (error) {\n      this.raygunLoggerService.error('사용자 생성 실패', error.stack);\n      throw new Error('사용자 생성 실패');\n    }\n```\n\n성능 모니터링\n\n- Raygun은 성능 메트릭을 추적하고 응용 프로그램의 병목 현상을 식별하는 실제 사용자 모니터링 (RUM) 및 응용 프로그램 성능 모니터링 (APM)도 제공합니다.\n\nRaygun 대시보드\n\n<div class=\"content-ad\"></div>\n\nRaygun 대시 보드에 액세스하여 자세한 오류 보고서를 확인하고 응용 프로그램 성능을 추적하며 중요한 문제에 대한 경보 및 알림을 설정할 수 있습니다.\n\nRaygun을 NestJS 애플리케이션에 통합하면 오류 및 성능 문제에 대한 강력한 통찰력을 얻어 문제를 선제적으로 해결하고 소프트웨어의 전반적인 안정성과 신뢰성을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-NestjsErrorHandling_0.png"},"coverImage":"/assets/img/2024-06-19-NestjsErrorHandling_0.png","tag":["Tech"],"readingTime":7},{"title":"초보자를 위한 Nestjs","description":"","date":"2024-06-19 23:15","slug":"2024-06-19-Nestjsforbeginners","content":"\n\nNest.js는 TypeScript를 사용하여 확장 가능한 서버 측 애플리케이션을 구축하기 위한 Node.js 프레임워크입니다.\n\n![Nest.js](/assets/img/2024-06-19-Nestjsforbeginners_0.png)\n\n# Nest.js를 선택하는 이유\n\n아마 이미 알고 계시다시피, 인기 있는 Node.js 프레임워크 중 하나는 Express입니다. 디자인상으로 매우 미니멀하게 설계되어 있습니다. 몇 가지 기능을 소개하여 서버 측 애플리케이션을 구축할 수 있지만, 백엔드의 전반적인 아키텍처는 사용자에게 달려 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Nestjsforbeginners_1](/assets/img/2024-06-19-Nestjsforbeginners_1.png)\n\nExpress 문서를 살펴보면 라우팅, 미들웨어, 일부 오류 처리를 수행할 수 있는 몇 가지 기능을 제공합니다. 이렇게 보면 이것이 거의 전부입니다. 이러한 아키텍처의 부재는 굉장히 유연하다는 점을 의미합니다. Express로 원하는 대로 거의 무엇이든 할 수 있습니다.\n\n그러나 프로젝트나 팀이 성장함에 따라 여러분은 매우 쉽게 스파게티로 변할 수 있다는 것을 발견할 것입니다. 여러분은 실제로 규칙과 구조가 필요합니다. 특히 GraphQL, REST 또는 Swagger와 같은 것들을 통합해야 할 때 이것들은 매우 중요합니다.\n\n이제 Nest가 나와서 말합니다: \"에이, 우리가 서버 쪽 애플리케이션의 아키텍처를 돌보겠다고. 그리고 가장 좋은 부분은 무엇일까요? Express를 여전히 사용할 수 있다는 것입니다!\"\n\n\n<div class=\"content-ad\"></div>\n\n# Nest.js가 작동하는 방식\n\nNest.js는 빠른 개발과 예측 가능하고 가독성 있는 코드를 위해 express (Fastify도 포함)를 활용하는 도구 모음을 제공합니다. 기본적으로 REST 및 GraphQL API를 지원하거나 Laravel이나 Ruby on Rails와 같은 프레임워크를 사용하여 모델-뷰-컨트롤러(MVC) 설계 패턴을 활용하여 풀 스택 애플리케이션을 구축하는 데 사용할 수 있습니다.\n\n데이터베이스 작업을 처리하거나 보안을 다루는 등 서버 측 애플리케이션에서 수행할 수 있는 작업을 상상할 수 있는 모듈이 풍부하게 포함되어 있습니다.\n\n![Nest.js 이미지](/assets/img/2024-06-19-Nestjsforbeginners_2.png)\n\n\n<div class=\"content-ad\"></div>\n\nNest.js에는 훌륭한 문서가 있어요. 모든 핵심 개념에 대한 개요를 제공할 뿐만 아니라 테스팅, 데이터베이스 연결, 작업 스케줄링, 큐, 이벤트, 웹소켓, GraphQL 등 다른 작업 방법에 대한 지침도 볼 수 있어요.\n\n그리고 TypeScript에 매우 중점을 두고 있어요. OOP와 FP의 요소를 결합했는데, 데코레이터에 큰 비중을 두고 있어요. 스프링부트 프레임워크를 사용해봤다면 익숙할 수도 있겠죠.\n\n# Nest CLI\n\nNest에는 자체 강력한 Command Line Tool이 있어요. nest new 명령어로 새 프로젝트를 손쉽게 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\n> nest new server-side-app\n```\n\n이 명령은 Jest를 통해 미리 구성된 코드베이스를 제공하고, 타입스크립트를 설정하여 더 가독성이 있고 믿을만한 코드를 작성할 수 있도록 합니다. 이제 Nest.js로 시작할 준비가 되었습니다!\n\n독자 여러분 감사합니다 🎉\n","ogImage":{"url":"/assets/img/2024-06-19-Nestjsforbeginners_0.png"},"coverImage":"/assets/img/2024-06-19-Nestjsforbeginners_0.png","tag":["Tech"],"readingTime":2},{"title":"Nodejs에서 첫 번째 REST API를 만드는 방법","description":"","date":"2024-06-19 23:14","slug":"2024-06-19-HowtomakeyourfirstRESTAPIinNodejs","content":"\n\n## 5분 이내로\n\n![이미지](/assets/img/2024-06-19-HowtomakeyourfirstRESTAPIinNodejs_0.png)\n\nNode.js에서 REST API (Representational State Transfer Application Programming Interface)를 만드는 것은 현대 웹 개발자에게 필수적인 기술입니다. 이 유형의 API는 웹 애플리케이션과 같은 다양한 클라이언트가 상태를 유지하지 않는 일련의 작업을 사용하여 서버와 상호 작용할 수 있게 합니다. 이 튜토리얼에서는 Node.js에서 간단한 REST API를 설정하는 기본 사항을 살펴보며, 데이터 유형, 클래스 및 다양한 HTTP 메서드를 사용한 코드 예제를 다룰 것입니다.\n\n# 필수 사항\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 시스템에 Node.js가 설치되어 있는지 확인해주세요. Node.js는 nodejs.org에서 다운로드할 수 있습니다. 또한 JavaScript, Node.js, 그리고 인기 있는 Node.js 프레임워크 Express에 대한 기본적인 이해가 필요합니다.\n\n# 단계 1: 프로젝트 설정하기\n\n먼저, 프로젝트를 위한 새 디렉토리를 만들고 그 안에서 새 Node.js 프로젝트를 초기화하세요.\n\n```js\nmkdir my-rest-api\ncd my-rest-api\nnpm init -y\n```\n\n<div class=\"content-ad\"></div>\n\n위 작업은 당신의 프로젝트 종속성을 관리할 package.json 파일을 디렉토리에 생성합니다.\n\n# 단계 2: Express 설치하기\n\nHTTP 요청을 쉽게 처리하려면 Express를 설치하세요.\n\n```js\nnpm install express\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: 첫 번째 엔드포인트 생성하기\n\n이제 프로젝트 디렉토리에 index.js 파일을 생성하세요. 이것이 진입점이 될 것입니다.\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.listen(3000, () => {\n console.log(\"포트 3000에서 실행 중인 서버\");\n});\n```\n\n이 코드는 포트 3000에서 수신 대기하는 기본 Express 서버를 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 4: HTTP 메소드 처리\n\nREST API는 다양한 HTTP 메소드와 함께 작동합니다. 가장 일반적인 메소드는 GET, POST, PUT 및 DELETE입니다.\n\n# GET 요청\n\n간단한 메시지를 반환하는 GET 엔드포인트를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\napp.get(\"/msg\", (req, res, next) => {\n  res.json({\"message\": \"안녕, 세계!\"});\n});\n```\n\n# POST 요청\n\nPOST 요청을 할 때는 종종 데이터를 받게 됩니다. 예시를 보겠습니다.\n\n```js\napp.use(express.json()); // for parsing application/json\n\napp.post(\"/msg\", (req, res, next) => {\n  const message = req.body.message;\n  res.json({\"receivedMessage\": message});\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 5: 클래스와 데이터 유형 사용하기\n\n더 나은 코드 구성을 위해 클래스를 사용하여 코드를 구성할 수 있습니다. Message 클래스를 만들어 봅시다.\n\n```js\nclass Message {\n  constructor(content) {\n    this.content = content;\n  }\n\n  getContent() {\n    return this.content;\n  }\n}\n```\n\n이제 이 클래스를 사용하여 POST 엔드포인트를 리팩토링할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\napp.post(\"/msg\", (req, res, next) => {\n  const newMessage = new Message(req.body.message);\n  res.json({\"receivedMessage\": newMessage.getContent()}); \n});\n```\n\n# 단계 6: API 테스트하기\n\nAPI를 테스트하려면 Postman이나 cURL과 같은 도구를 사용할 수 있습니다. GET 요청의 경우 브라우저에서 http://localhost:3000/msg 로 간단히 방문할 수 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\nNode.js에서 REST API를 만드는 것은 연습을 통해 더 직관적인 과정이 되는 간단한 일입니다. Express의 사용은 다양한 HTTP 메소드를 간단하게 처리하게 해주며, 클래스와 적절한 데이터 유형을 사용하여 코드를 조직화하면 유지 관리 및 가독성을 크게 향상시킬 수 있습니다.\n\n기억하세요, 이것은 시작점에 불과합니다. 더 편안해지면 API를 더 복잡한 라우트로 확장하거나 데이터베이스에 연결하거나 인증을 구현하는 등 다양한 기능을 추가할 수 있습니다. 계속해서 탐험하고 실험하여 더 견고하고 효율적인 API를 만들어 보세요!","ogImage":{"url":"/assets/img/2024-06-19-HowtomakeyourfirstRESTAPIinNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-HowtomakeyourfirstRESTAPIinNodejs_0.png","tag":["Tech"],"readingTime":3},{"title":"NestJS에서 의존성 주입은 어떻게 처리될까요","description":"","date":"2024-06-19 23:13","slug":"2024-06-19-HowDoesNestJSHandleDependencyInjection","content":"\n\nNestJS와 TypeScript를 사용하여 백엔드를 개발할 때, NestJS에서 @Injectable 데코레이터를 사용하는 것이 일반적입니다. EmailService가 @Injectable이고 다른 서비스에서 이를 주입하고 사용하려는 시나리오를 고려해 보겠습니다. 아래 코드를 살펴보세요:\n\n```js\n@Injectable()\nclass MyService {\n  constructor(private readonly emailService: EmailService) {}\n}\n```\n\n첫눈에 보기에는 모든 것이 잘 동작하는 것처럼 보입니다. 그러나 자세히 살펴보면 이 코드가 조금 이상해 보일 수 있습니다. TypeScript 코드가 JavaScript로 변환될 때, 타입 주석이 제거되기 때문입니다. 그래서 문제는 다음과 같이 발생합니다: NestJS는 EmailService와 같은 타입만으로 어떻게 주입할 서비스를 결정할까요?\n\n![How Does NestJS Handle Dependency Injection](/assets/img/2024-06-19-HowDoesNestJSHandleDependencyInjection_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 설명:\n\nNestJS는 TypeScript의 메타데이터 및 리플렉션 기능을 활용하여 런타임에서 의존성에 대한 필요한 정보를 유지합니다. 이를 위해 reflect-metadata라는 라이브러리를 사용합니다. 이 라이브러리를 사용하면 NestJS가 의존성 주입에 사용할 수 있는 클래스와 메소드에 메타데이터를 추가할 수 있습니다.\n\nNestJS는 의존성 주입을 처리하기 위해 데코레이터를 사용합니다. 위 예시에서 @Injectable() 데코레이터는 NestJS에 EmailService 클래스에 대한 메타데이터를 저장하도록 알려줍니다. 런타임에서 NestJS는 이 메타데이터를 활용하여 의존성을 식별하고 주입합니다.\n\n이 프로세스가 올바르게 작동하도록 하려면 프로젝트에 reflect-metadata를 설치하고 주 파일(예: main.ts)에서 import해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'reflect-metadata';\n```\n\n이렇게 하면 NestJS가 JavaScript로 변환될 때 타입 주석이 제거되어도 메타데이터 정보를 사용하여 의존성을 올바르게 식별하고 주입할 수 있습니다.\n\n# 결론\n\nNestJS는 TypeScript에서 메타데이터와 리플렉션을 사용하여 의존성을 효과적으로 관리합니다. 이 기능을 통해 NestJS는 타입 주석이 제거되어도 올바르게 의존성을 식별하고 주입할 수 있습니다. TypeScript로 서버 측 응용 프로그램을 개발할 때 NestJS의 강점 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\nNestJS가 메타데이터와 리플렉션을 통해 의존성 주입을 처리하는 방식을 이해하면 TypeScript와 NestJS의 힘을 최대로 발휘하면서 더 견고하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n\n나의 Linkedin | 나의 Github","ogImage":{"url":"/assets/img/2024-06-19-HowDoesNestJSHandleDependencyInjection_0.png"},"coverImage":"/assets/img/2024-06-19-HowDoesNestJSHandleDependencyInjection_0.png","tag":["Tech"],"readingTime":2},{"title":"Golang 대 Nodejs","description":"","date":"2024-06-19 23:12","slug":"2024-06-19-GolangvsNodejs","content":"\n\n소프트웨어 개발자로서, 언제나 앱을 개발하는 데 최적화된 가장 빠르고 효율적인 도구를 찾고 있어요. 속도와 복잡한 작업 처리에 관한 것이라면, Golang과 Node.js가 두 강자로 뽑히죠. 둘 다 성능 면에서 뛰어난 평판을 자랑하지요. 그런데 고민거리는 여전히 존재합니다 — Golang과 Node.js 중 어느 쪽이 더 빠를까요? 이 논쟁을 해결하기 위해, 내가 이 두 기술을 철저히 비교하는 벤치마크 테스트의 여정에 나섰어요. 자세한 결과를 분석하여, 빠른 속도면에서 어떤 플랫폼이 우위를 차지하는지 확인하는 게 제 목표에요. 데이터를 통해 어느 플랫폼이 고성능 앱을 개발하는 데 분명한 장점을 가지고 있는지 밝혀낼 거예요.\n\n<img src=\"/assets/img/2024-06-19-GolangvsNodejs_0.png\" />\n\n# 소개\n\n최근 몇 년 동안 Golang과 Node.js는 주목을 받아왔어요. 각각의 강점과 장점을 가지고 있죠.\nGolang, Go로도 알려진, 구글에서 개발한 정적 타입의 컴파일된 프로그래밍 언어입니다. Golang은 간결성, 고루틴을 통한 동시성 지원, 그리고 빠른 성능으로 칭찬을 받아왔어요. 반면에 Node.js는 Chrome의 V8 JavaScript 엔진 위에 구축된 이벤트 기반, 논 블로킹 I/O 플랫폼입니다. 비동기 프로그래밍 모델, npm을 통한 확장 패키지 생태계, 빠른 개발 능력으로 인정을 받았죠.\n\n<div class=\"content-ad\"></div>\n\n# 성능 평가 방법론\n\n벤치마킹 테스트 결과를 살펴보기 전에 공정하고 정확한 비교를 보장하기 위해 표준화된 방법론을 수립하는 것이 중요합니다. 저희의 벤치마킹 테스트에서는 응답 시간, 처리량 및 리소스 이용률과 같은 일반적인 성능 지표에 집중할 것입니다. 벤치마킹 테스트 환경에서는 Golang 및 Node.js 애플리케이션에 대해 동일한 하드웨어 사양 및 구성을 적용할 것입니다. 또한 신뢰할 수 있는 벤치마킹 도구와 프레임워크를 활용하여 모든 실험의 신뢰성과 일관성을 보장할 것입니다.\n\n# 응답 시간 비교\n\n웹 서버 성능을 평가하는 데 중요한 지표 중 하나인 응답 시간은 요청을 보내고 응답을 받는 지속 시간을 측정합니다. 저희의 벤치마킹 테스트에서는 Golang과 Node.js로 작성된 동일한 웹 서버 애플리케이션을 배포하여 각각 간단한 HTTP 요청을 제공하고 처리 오버헤드를 최소화할 것입니다. 서로 다른 수준의 동시 클라이언트 연결을 시뮬레이션하고 해당 응답 시간을 분석함으로써 Golang과 Node.js의 성능을 현실적인 작업 부하 시나리오에서 평가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// Node.js HTTP 서버\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.writeHead(200);\n  res.end('안녕, 세상아!');\n});\n\nserver.listen(3000);\n```\n\n<img src=\"/assets/img/2024-06-19-GolangvsNodejs_1.png\" />\n\n초당 요청 횟수\n\n```js\n// Golang HTTP 서버\npackage main\n\nimport (\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"안녕, 세상아!\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":3000\", nil)\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 처리량 분석\n\n응답 시간 외에도 처리량은 시스템이 수신 요청을 처리하는 속도를 측정하는 또 다른 중요한 성능 지표입니다. 높은 처리량 값은 동시 연결을 처리하고 응답을 즉시 전달할 능력을 나타냅니다. Golang 및 Node.js 애플리케이션의 처리량을 비교하기 위해 동시 클라이언트 요청 수를 증가시키고 각 플랫폼의 요청 처리 능력에 대한 확장성을 모니터링할 것입니다.\n\n# 자원 활용\n\n응답 시간과 처리량 외에도, 부하 하에서 Golang 및 Node.js 애플리케이션의 자원 활용 평가는 매우 중요합니다. 이는 CPU 사용률, 메모리 소비 및 네트워크 활동을 모니터링하여 잠재적인 병목 현상이나 비효율성을 찾아내는 것을 포함합니다. 자원 활용 지표를 면밀히 살펴봄으로써 각 플랫폼의 전체 효율성과 확장성에 대한 통찰력을 얻을 수 있으며, 프로젝트에 적합한 최적 기술 스택을 선택할 때 개발자들이 정보에 기반한 결정을 내릴 수 있게 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n# CPU 사용량:\n\n- Golang은 기계 코드를 컴파일하여 CPU를 효율적으로 사용합니다. 벤치마크 테스트 결과 Golang은 CPU 자원 활용에서 Node.js를 능가하는 것으로 지속적으로 증명되고 있습니다.\n- Node.js는 단일 스레드에서 작동하며 비동기 I/O 호출에 의존하므로 CPU 자원을 미적절하게 사용하고 오버헤드가 증가할 수 있습니다.\n\n# 메모리 사용량:\n\n- 정적 타입 및 컴파일된 성격으로 인해 Golang은 Node.js보다 낮은 메모리 사용량을 보입니다. 덜 필요한 런타임 메타데이터를 요구합니다.\n- Node.js는 동적 타입 및 V8 JavaScript 엔진에 의존하여 유형 정보와 힙을 저장하는 데 더 많은 메모리가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 스레딩 모델:\n\n- Golang은 경량 스레드(고루틴)를 활용하여 동시성을 간단하게 다루고 병렬성을 달성합니다.\n- Node.js는 단일 스레드, 논블로킹 I/O 모델을 채택합니다. 동시성은 Worker Threads를 사용하여 명시적으로 코딩해야 합니다.\n\n# 확장성:\n\n- 경량 고루틴 스레드를 통해 Golang은 수평적으로 뛰어난 확장성을 갖추어 대규모 동시 요구를 처리할 수 있습니다.\n- Node.js는 단일 기계에서 수직적으로 확장성이 뛰어나지만, 단일 스레드 특성으로 인해 확장성을 넓히는 동안 병목 현상을 겪을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 동시성 성능\n\nGolang의 탁월한 기능 중 하나는 가벼운 고루틴과 채널을 통한 동시성을 네이티브로 지원한다는 것입니다. 이를 통해 Golang 애플리케이션은 수천 개의 동시 작업을 효율적으로 처리하면서 오버헤드를 최소화할 수 있어 웹 서버, 마이크로서비스 및 분산 애플리케이션과 같이 높은 동시성 시스템을 구축하는 데 이상적입니다. 반면에 Node.js는 이벤트 기반 비차단 I/O 모델을 통해 동시성을 처리하며 비동기 함수와 이벤트 루프를 활용합니다. 우리는 두 플랫폼에서 고도의 동시성 작업을 스트레스 테스트하여 동시성 성능을 비교하고, 반응성과 확장성을 평가할 것입니다.\n\n# 결론\n\n벤치마크 테스트 결과는 Golang과 Node.js 간의 성능 차이를 생생하게 보여줍니다. 두 플랫폼 모두 장단점을 가지고 있지만, Golang은 순수 속도, 동시성 및 자원 효율성 면에서 우수한 성능을 뽐내고 있습니다. 컴파일된 성격, 가벼운 고루틴 및 효율적인 런타임으로 인해 빠른 응답 시간과 확장 가능한 동시성을 필요로 하는 고성능 애플리케이션에 매력적인 선택이 됩니다.\n반면 Node.js는 탁월한 개발자 생산성, 광범위한 생태계 지원 및 JavaScript 프론트엔드 프레임워크와의 원활한 통합을 제공합니다.\n최종적으로 Golang과 Node.js 중 어느 것을 선택할지는 프로젝트의 특정 요구사항과 우선순위에 따라 결정됩니다 - 성능 최대화, 기존 JavaScript 전문성 활용 또는 개발자 효율성 최적화 등을 고려해야 합니다.","ogImage":{"url":"/assets/img/2024-06-19-GolangvsNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-GolangvsNodejs_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs를 사용한 서버 측 렌더링 운영화","description":"","date":"2024-06-19 23:08","slug":"2024-06-19-OperationalizingNodejsforServerSideRendering","content":"\n\n## Airbnb이 서버 측 렌더링을 중심으로 Frontend를 더 많이 구축함에 따라, 서버 구성을 최적화하는 방법을 살펴보았습니다.\n\nAirbnb에서는 몇 년 동안 Frontend 코드를 일관된 아키텍처로 이주시켜 왔습니다. 전체 웹 페이지가 API에서 제공하는 데이터를 활용하여 React 구성 요소의 계층 구조로 작성되었습니다. Ruby on Rails가 브라우저로 웹을 가져오는 방식에서의 역할은 매일 줄어들고 있습니다. 사실, 곧 우리는 노드.js로 완전한 형태의 서버 렌더링 웹 페이지를 제공할 새로운 서비스로 이행할 것입니다. 이 서비스는 모든 Airbnb 제품의 대부분의 HTML을 렌더링할 것입니다. 이 렌더링 엔진은 우리가 실행하는 대부분의 백엔드 서비스와는 다르며, 루비나 자바로 작성되지 않았음을 특징으로 합니다. 그러나 이 렌더링 엔진은 우리가 생각하는 일반적인 I/O 집중적인 노드.js 서비스와도 다릅니다.\n\n노드.js를 떠올렸을 때, 여러분은 고도로 비동기식인 애플리케이션이 효율적으로 수백 또는 수천 개의 연결을 동시에 처리하는 모습을 상상합니다. 서비스는 동네 곳곳에서 데이터를 가져와 상당히 가볍게 처리하여 많은 클라이언트가 사용할 수 있도록 만듭니다. 아마도 여러분은 수많은 오랜 기간 유지되는 WebSocket 연결을 처리하고 있습니다. 여러분은 이 잘 튠된 경량 동시성 모델로 업무에 완벽히 적합하다는 점에 만족하고 확신하고 있습니다.\n\n서버 측 렌더링(SSR)은 이러한 상상을 일부 깨는 연산 집약적인 작업입니다. 노드.js에서 사용자 코드는 단일 스레드에서 실행되므로 연산 작업(즉, I/O가 아닌 작업)의 경우 동시에 실행할 수 있지만 병렬로 실행할 수는 없습니다. 노드.js는 많은 양의 비동기 I/O를 병렬로 처리할 수 있지만 연산에 한계가 있습니다. 요청의 연산 부분이 I/O에 상대적으로 더 많아질수록 동시 요청은 CPU 경합으로 인해 지연에 미치는 영향이 증가할 것입니다¹.\n\nPromise.all([fn1, fn2])를 고려해보세요. fn1 또는 fn2가 I/O에 의해 해결되는 promise이면 이와 같이 병렬성을 달성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 fn1과 fn2이 연산되면, 대신 이렇게 실행될 것입니다:\n\n![OperationalizingNodejsforServerSideRendering_1](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_1.png)\n\n두 작업 중 하나가 완료될 때까지 다른 하나는 기다려야 합니다. 왜냐하면 실행 스레드가 하나뿐이기 때문입니다.\n\n서버 측 렌더링에서는 서버 프로세스가 여러 동시 요청을 처리할 때 이 문제가 발생합니다. 동시 요청이 처리 중인 다른 요청들에 의해 지연될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_2.png)\n\n현실에서는 요청이 여러 가지 다른 비동기 단계로 구성되는 경우가 많습니다. 심지어 대부분이 계산에 대한 경우라도요. 이는 더 나쁜 교차 결과로 이어질 수 있습니다. renderPromise().then(out => formatResponsePromise(out)).then(body => res.send(body))와 같은 체인으로 요청이 구성된 경우, 다음과 같은 요청 교차가 발생할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_3.png)\n\n이 경우, 두 요청 모두 두 배로 오래 걸릴 수 있습니다. 이 문제는 동시성이 증가함에 따라 심각해집니다.\n\n게다가 SSR의 일반적인 목표 중 하나는 클라이언트와 서버 모두에서 동일하거나 유사한 코드를 사용할 수 있어야 한다는 것입니다. 이러한 환경 간의 큰 차이점 중 하나는 클라이언트 컨텍스트가 본질적으로 단일 테넌트인 반면 서버 컨텍스트는 다중 테넌트입니다. 클라이언트 측에서 쉽게 작동하는 싱글톤이나 다른 전역 상태와 같은 기법은 서버에서 동시 요청 부하하에 대해 버그, 데이터 누출 및 일반적인 혼돈을 초래할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 문제들은 병행성이 발생할 때만 문제가 됩니다. 낮은 부하 수준이거나 개발 환경의 독점적인 단일 테넌시에서는 대부분 잘 작동합니다.\n\n이는 노드 애플리케이션의 전형적인 예제들과 매우 다른 상황을 초래합니다. 우리는 JavaScript 런타임을 사용하여 라이브러리 지원과 브라우저의 특성을 활용하기 위해 사용하고 있습니다. 병행성 모델 대신 이러한 애플리케이션에서는 비동기 병행성 모델이 그 모든 비용을 부과하지만 그 혜택은 별로 없거나 거의 없습니다.\n\n# Hypernova에서 배운 점\n\n저희의 새로운 렌더링 서비스인 Hyperloop은 Airbnb 웹 사이트 이용자가 상호 작용하는 주요 서비스가 될 것입니다. 따라서 그 신뢰성과 성능은 사용자 경험에 절대적으로 중요합니다. 새 서비스로의 프로덕션 전환에 따라 이제는 사전 SSR 서비스인 Hypernova에서 배운 교훈을 통합하고 있습니다.\n\nHypernova는 새 서비스와 다르게 작동합니다. 그것은 순수한 렌더러입니다. 우리의 레일즈 단일체 Monorail에서 호출되고, 특정 렌더링된 컴포넌트에 대한 HTML 조각만 반환합니다. 대부분의 경우 \"조각\"은 페이지의 대부분이며, 레일즈는 단지 바깥 쪽 레이아웃만 제공합니다. 레거시의 경우, 페이지의 구성 요소를 ERB를 사용하여 연결할 수 있습니다. 그러나 어느 경우든 Hypernova는 데이터를 자체로 가져오지 않습니다. 데이터는 레일즈에서 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n위에서 언급한대로, Hyperloop과 Hypernova는 컴퓨트에 관한 유사한 운영 특성을 공유합니다. 실제 트래픽을 처리하는 서비스로, Hypernova는 그 대체품이 프로덕션 환경에서 어떻게 동작할지 이해하는 데 좋은 테스트 대상을 제공합니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_4.png)\n\n사용자로부터 요청이 주요 Rails 앱 Monorail에 들어오며, Monorail은 React 컴포넌트를 해당 페이지에 렌더링하고자 하는 속성을 조합하고 해당 속성과 컴포넌트 이름을 Hypernova에 요청합니다. Hypernova는 속성과 함께 컴포넌트를 렌더링하여 Monorail로 반환할 HTML을 생성하고, Monorail은 페이지 템플릿에 내장시키고 전체를 클라이언트에게 되돌려보냅니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_5.png)\n\n<div class=\"content-ad\"></div>\n\n렌더링 중 실패(오류 또는 타임아웃으로 인한) 발생 시, 하이퍼노바 렌더링의 대체 방법은 렌더링된 HTML 없이 페이지에 구성 요소와 해당 속성을 삽입하는 것입니다. 이렇게 함으로써 클라이언트 렌더링이 성공적으로 수행될 수 있습니다. 이로 인해 하이퍼노바를 선택적 종속성으로 간주하고, 일부 타임아웃과 실패를 허용할 수 있게 되었습니다. 호출에 대한 타임아웃 시간은 서비스의 관찰된 p95 값과 유사하게 설정되었습니다. 기본적으로 5% 미만의 타임아웃이 발생하는 것이 예상대로였습니다.\n\n최대 일일 트래픽로드 배포 중에는 모노레일에서 하이퍼노바에 대한 요청 중 최대 40%가 타임아웃되는 경우가 발생했습니다. 하이퍼노바로부터 배포 중 BadRequestError: Request aborted의 오류율이 증가하는 것을 보았습니다. 이러한 오류는 다른 모든 응용 프로그램/코딩 오류를 효과적으로 숨겨버리는 상당한 기준 오류율 또한 존재했습니다.\n\n이러한 동작은 선택적 종속성으로, 높은 우선순위가 아닌 번거로움으로 여겨졌습니다. 저희는 타임아웃 및 오류를 초기 GC가 비용이 많이 드는 초기 시작 동작, JIT 부족, 캐시 채움, 빗물과 같은 요소의 예상으로 충분히 설명할 수 있다고 합리적으로 생각했습니다. React 또는 Node의 새로운 릴리스가 느린 시작을 완화하기 위한 충분한 성능 개선을 제공할 것을 희망했습니다.\n\n이는 배포 중에 나쁜 로드 밸런싱이나 용량 문제로 인한 확실한 결과로 의심되어질 수 있습니다. 동일한 프로세스에서 거의 100%의 계산 요청을 동시에 처리함으로써 늘어난 대기 시간을 볼 수 있었고, 여러 요청이 한 번에 실행되는 경우가 있을 때에는 해당하는 프로세스에서 동시에 처리된 요청 수를 로그하는 미들웨어를 추가했습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 실제로 CPU 사용을 기다리는 동시 요청 때문에 발생한 지연을 시작 지연으로 원망했습니다. 우리의 성능 지표에서 다른 실행 중인 요청 때문에 실행을 대기하는 시간은 요청을 실행하는 데 소비된 시간과 구별할 수 없습니다. 이는 동시성으로 인한 지연이 개별 요청의 비용을 실제로 증가시키는 새로운 코드 경로 또는 기능에서 발생하는 지연과 동일하게 나타날 것이라는 것을 의미합니다.\n\n또한 BadRequestError: Request aborted 오류가 일반적인 느린 시작 성능으로 충분히 설명되지 않는다는 사실이 점점 더 분명해지고 있었습니다. 이 오류는 body parser에서 발생하며 특히 클라이언트가 서버가 요청 본문을 완전히 읽기 전에 요청을 중단한 경우에 발생합니다. 클라이언트가 포기하고 연결을 끊어가면 우리가 처리를 계속하기 위해 필요한 소중한 데이터를 가져가는데, 개별 요청의 비용을 증가시키는 것이 실제로 더 가능성이 높습니다.\n\nHypernova의 요청 페이로드도 평균적으로 수백 킬로바이트로 상당히 크기 때문에 이 문제가 더 복잡해집니다.\n\n<img src=\"/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_7.png\" />\n\n우리는 이 문제를 해결하기 위해 우리에게 많은 양의 운영 경험을 제공하는 두 가지 외부 구성 요소를 사용하기로 결정했습니다: 역방향 프록시(nginx) 및 로드 밸런서(haproxy).\n\n<div class=\"content-ad\"></div>\n\n# Reverse Proxying 및 로드 밸런싱\n\n우리의 하이퍼노바 인스턴스에 존재하는 여러 CPU 코어를 활용하기 위해 노드.js 클러스터 모듈을 통해 여러 하이퍼노바 프로세스를 실행합니다. 이러한 프로세스들은 독립적이기 때문에 동시 요청을 병렬로 처리할 수 있습니다.\n\n![image](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_8.png)\n\n여기서 문제는 각 노드 프로세스가 요청이 완료될 때까지 효과적으로 점유되며, 이는 클라이언트(모노레일)로부터 요청 본문을 읽는 작업을 포함합니다. 하나의 프로세스에서 병렬로 여러 요청을 읽을 수는 있지만, 이는 작업을 렌더링할 때 연산이 교차되는 문제로 이어집니다. 노드 프로세스의 이용률은 클라이언트 및 네트워크의 속도에 결합됩니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션은 클라이언트와의 통신을 처리하기 위해 버퍼링 리버스 프록시를 사용하는 것입니다. 이를 위해 nginx를 사용합니다. Nginx는 클라이언트로부터의 요청을 버퍼에 읽고, 완전히 읽힌 후에만 전체 요청을 노드 서버에 전달합니다. 이 전송은 머신 내에서 루프백 또는 유닉스 도메인 소켓을 통해 이루어지며 이는 머신 간 통신보다 빠르고 안정적입니다.\n\n![image](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_9.png)\n\nnginx가 요청을 읽는 작업을 처리하면, 노드 프로세스의 사용률을 높일 수 있습니다.\n\n![image](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_10.png)\n\n<div class=\"content-ad\"></div>\n\n우리는 몇 가지 요청을 처리하기 위해 nginx를 사용하여 Node.js 프로세스로 직행할 필요 없이 처리합니다. 우리의 서비스 검색 및 라우팅 레이어는 호스트 간의 연결 상태를 확인하기 위해 낮은 비용의 /ping 요청을 사용합니다. 이를 nginx에서 완전히 처리함으로써 Node.js 프로세스로의 (비록 저렴하지만) 상당한 처리량 출처를 제거합니다.\n\n다음은 부하 분산입니다. 어떤 Node.js 프로세스가 어떤 요청을 받아야 하는지에 대한 스마트한 결정을 내려야 합니다. 클러스터 모듈은 라운드 로빈 방식으로 요청을 분배합니다. 각 프로세스는 차례로 요청을 받습니다. 라운드 로빈은 요청 지연 시간에 큰 변동이 없을 때 훌륭합니다. 그림 1을 참고하세요.\n\n다루는 시간이 극명하게 다른 다양한 유형의 요청이 있는 경우 라운드 로빈은 좋지 않습니다. 프로세스의 후속 요청은 이전 요청이 모두 완료될 때까지 기다려야 합니다. 이에 대처할 수 있는 또 다른 처리 용량이 있는 다른 프로세스가 있더라도요.\n\n<div class=\"content-ad\"></div>\n\n\n![데이터](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_12.png)\n\n이 요청의 더 나은 분배 방식은 다음과 같습니다:\n\n![데이터](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_13.png)\n\n대기 시간을 최소화하고 응답을 빠르게 반환할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 작업은 요청을 대기열에 유지하고 프로세스가 다른 요청으로 쓰여지지 않게 될 때에만 해당 요청을 프로세스에 할당하여 달성할 수 있습니다. 이를 위해 우리는 haproxy를 사용합니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_14.png)\n\n이를 Hypernova에 적용하면 배포시에 타임아웃 스파이크와 BadRequestErrors가 완전히 제거되었습니다. 동시 요청은 정상 작동 중에 높은 백분위 지연의 주요 원인이기도 했기 때문에 이로 인해 그 지연도 감소하였습니다. 이러한 결과 중 하나는 구성된 타임아웃이 같더라도 타임아웃 비율이 5%에서 2%로 줄어든 것입니다. 40%의 배포 실패에서 2%로 감소한다는 것은 승리 같은 느낌입니다. 오늘날 사용자들은 로딩 화면이 훨씬 덜 나타납니다. 내일은 Hypernova의 오류 대비 기능이 없는 새 랜더러를 위해 우리에게 매우 중요한 배포를 통한 안정성이 될 것입니다.\n\n# 자세한 내용과 설정\n\n<div class=\"content-ad\"></div>\n\n이 설정을 위해 nginx, haproxy 및 우리 노드 애플리케이션을 구성해야 합니다. 이 설정을 이해하는 데 사용할 수 있는 nginx 및 haproxy 구성이 포함된 샘플 노드 앱을 준비했습니다. 이러한 구성은 우리가 프로덕션 환경에서 실행하는 것을 기반으로 하지만, 단순화되고 비특권 사용자로 전경에서 실행되도록 수정되었습니다. 프로덕션 환경에서는 모든 것을 프로세스 감독자(저희는 runit 또는 점점 더 많이 사용하는 kubernetes를 사용합니다)로 구성해야 합니다.\n\nNginx 구성은 매우 표준적이며, 포트 9000에서 듣는 서버를 구성하여 요청을 포트 9001(저희 환경에서는 Unix 도메인 소켓을 사용)에 듣는 haproxy로 프록시하는 것입니다. 또한 /ping 엔드포인트를 가로채서 연결성 확인을 직접 제공합니다. 내부 표준 nginx 구성과의 차이점은 worker_processes를 1로 줄였다는 것인데, 단일 nginx 프로세스가 단일 haproxy 프로세스와 노드 애플리케이션을 충분히 포화시키기 때문입니다. 또한 hypernova를 위한 컴포넌트의 속성으로 큰 요청 및 응답 버퍼를 사용하고 있습니다(수백 킬로바이트 단위). 자신의 요청/응답 크기에 기반하여 버퍼 크기를 조정해야 합니다.\n\nNode의 클러스터 모듈은 로드 밸런싱과 프로세스 생성을 모두 처리합니다. 로드 밸런싱을 위해 HAProxy로 전환하려면 클러스터의 프로세스 관리 부분을 대체해야 했습니다. 이는 worker 프로세스 풀을 유지하는 데에 대해 클러스터보다 약간 더 의견을 갖추는 pool-hall로 구성되었는데, 로드 밸런싱 게임과는 완전히 무관합니다. 예제 앱은 pool-hall을 사용하여 다른 포트에서 듣는 네 개의 worker 프로세스를 시작하는 방법을 보여줍니다.\n\nHAProxy 구성은 포트 9001에서 듣는 프록시를 구성하여 포트 9002에서 9005까지 듣는 네 개의 worker로 트래픽을 라우팅합니다. 각각의 worker에 대해 가장 중요한 설정은 maxconn 1 입니다. 이는 각 worker가 한 번에 하나의 요청을 처리하도록 제한합니다. 이는 HAProxy 통계 페이지(포트 8999에서 실행하도록 구성됨)에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![HAProxy Configuration](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_15.png)\n\n안녕하세요!\n\nHAProxy는 각 워커와의 현재 열린 연결 수를 추적합니다. maxconn을 통해 구성된 제한이 있습니다. 라우팅은 static-rr (정적 라운드 로빈)으로 설정되어 있어 일반적으로 각 워커에게 순서대로 요청이 제공됩니다. 제한이 설정된 경우 라우팅은 라운드 로빈으로 진행되지만 현재 요청 제한에 도달한 워커는 건너뛰게 됩니다. 연결 제한 이하의 워커가 없는 경우 요청은 대기열에 들어가며 가장 먼저 사용 가능해진 워커에게 배달됩니다. 이것이 우리가 원하는 동작입니다.\n\n이 구성은 아마도 사용하려는 것과 매우 가까운 것일 것입니다. 여기에는 다른 흥미로운 설정(그리고 필요한 복사 붙여넣기)이 있습니다. 이 구성을 준비하는 일안하며, 우리는 일반적이고 이상적인 상황에서 여러 테스트를 수행하고 그에 기반하여 구성 값을 유도했습니다. 이는 깊이 들어가는 내용으로서 설정을 사용하는 데까지 꼭 이해할 필요는 없지만, 다음 섹션에서 제공됩니다.\n\n# HAProxy 심층 분석\n\nHAProxy 구성이 우리가 원하는 대로 정확히 작동하는 것에 많은 것이 달려 있었습니다. 동시 요청 제한 또는 대기열매 확인되지 않았다면 잘못된 것입니다. 또한 각종 종류의 실패가 어떻게 처리되는지(또는 처리되지 않는지)를 이해하는 것이 중요했습니다. 현재 클러스터 설정에 대한 적합한 대체물인지 확인할 필요가 있었습니다. 이를 확인하기 위해 여러 테스트를 수행했습니다.\n\n<div class=\"content-ad\"></div>\n\n테스트의 일반적인 형태는 Apache Benchmark을 사용하여 다양한 동시성 수준에서 10,000개의 요청을 실행하는 것이었습니다. \n\n```js\nab -l -c <CONCURRENCY> -n 10000 http://<HOSTNAME>:9000/render\n```\n\n저희 설정에서는 예시 앱의 4개 대신 15개의 워커를 사용했고, 벤치마킹 및 시스템 테스트 간 간섭을 피하기 위해 앱을 실행하는 인스턴스와 별도 인스턴스에서 ab를 실행했습니다. 저희는 낮은 부하 (동시성=5), 높은 부하 (동시성=13), 대기 부하 (동시성=20)에서 테스트를 실행했습니다. 대기 부하를 통해 haproxy가 항상 대기열을 처리하도록 했습니다.\n\n첫 번째 테스트 세트는 그저 정상 작동을 확인하는 것이었고, 다음 테스트 세트는 배포 중 발생할 수 있는 모든 프로세스의 우아한 재시작을 확인하였습니다. 마지막 테스트 세트는 제가 일부 프로세스를 무작위로 종료하는 시나리오를 확인하는 것이었습니다. 이는 발생하지 않은 예외가 프로세스를 비정상적으로 종료시키는 상황을 시뮬레이션한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션 코드에서 무한 루프가 별도로 문제가 되었기 때문에 무한 루프가 포함된 엔드포인트에 대해 단일 요청을 실행했습니다.\n\n이러한 테스트는 우리의 구성 및 작동 방식을 이해하는 데 도움이 되었습니다.\n\n일반 작업에서 maxconn 1은 한 번에 하나의 요청을 처리하도록 각 프로세스를 제한하는 대로 정확히 기대했던 대로 작동했습니다. 백엔드에는 HTTP 또는 TCP 헬스체크를 구성하지 않았습니다. 이는 혼란을 야기하고 가치가 없다는 것을 발견했기 때문입니다. 헬스체크는 maxconn을 존중하지 않는 것으로 보입니다. 그러나 코드에서 이를 확인한 적은 없습니다. 우리의 예상 동작은 프로세스가 건강하고 서비스를 제공할 수 있는지 여부이거나 리스닝 중이지 않아 즉시 연결 오류를 발생시킬 것임을 의미합니다 (이에는 한 가지 주요 예외가 있습니다). 우리는 이러한 헬스체크를 우리 사례에 유용할 정도로 충분히 제어 가능하지 않아서 다른 헬스체킹 regime의 예측 불가능성을 피하기로 결정했습니다.\n\n연결 오류는 다룰 수 있는 문제입니다. 우리는 옵션 redispatch 및 retries 3을 설정하여 연결 오류를 수신하는 요청을 더 협조적인 다른 백엔드로 전달할 수 있게 했습니다. 연결이 거부되면 즉시 오류가 발생하여 우리는 비즈니스를 계속할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n거부된 연결에만 적용됩니다. 지금은 수신 대기 중이 아니라는 이유로 연결이 거부됩니다. 로컬 네트워크를 다루고 있기 때문에 연결 제한 시간은 별로 유용하지 않습니다. 무한 루프에 갇힌 워커를 방지하기 위해 낮은 연결 제한 시간을 설정할 수 있을 것으로 예상했습니다. 100밀리초의 타임아웃을 설정했을 때, 이벤트 루프로 제어가 되돌아가지 않았음에도 클라이언트/서버에서 설정된 10초 타임아웃 후에 우리 요청이 타임아웃되는 것에 놀랐습니다. 이는 커널이 서버가 수락하기 전에 클라이언트 관점에서 연결을 설정하는 것을 처리하기 때문에 발생합니다.\n\n주목할 만한 점으로, 백로그를 설정하여도 백로그 길이는 서버가 SYN-ACK에 응답한 후에 평가되어 연결이 설정되지 않는 것으로 결과되지 않습니다 (실제로는 서버가 클라이언트에서 돌아온 ACK 응답을 놓는 것을 구현/처리). 이로 인해 연결이 설정된 요청은 백엔드가 해당 요청을 처리했는지 여부를 판단할 수 있는 방법이 없기 때문에 다시 보내거나 다시 시도할 수 없습니다.\n\n또 다른 흥미로운 결과로, 무한 계산 루프에 갇힌 프로세스에서 수행한 테스트에서 클라이언트/서버 타임아웃은 예상치 못한 동작을 허용합니다. 무한 루프에 빠지게 하는 프로세스로 요청을 보낼 때, 백엔드의 연결 개수가 1로 설정됩니다. maxconn의 경우에는 우리가 원하는대로 작동하여 다른 요청이 연결될 수 없게 합니다. 클라이언트/서버 타임아웃이 만료되면 연결 개수가 다시 0으로 감소되며, 요청처리가 성공했는지 여부를 알 수 없어 우리의 1대1 보장이 위반되고 이전 요청은 실패로 이끌게 됩니다. 클라이언트가 타임아웃이나 변덕 때문에 연결을 닫을 때, 연결 개수는 영향을 받지 않고 라우팅은 계속해서 작동합니다. abortonclose를 설정하면 클라이언트가 닫는 즉시 연결 개수가 감소됩니다. 이에 따라 최선의 조치는 이러한 타임아웃에 높은 값을 설정하고 abortonclose를 해제하는 것입니다. 더 강력한 타임아웃은 클라이언트 또는 nginx 측에서 설정할 수 있습니다.\n\n또한 고부하 사례에서 적용되는 상당히 불편한 매력 요소를 발견했습니다. 만약 서버가 안정적인 대기열을 갖고 있는 상태에서 워커 프로세스가 충돌한다면 (이는 매우 드문 경우여야 합니다), 요청은 해당 백엔드에서 시도될 것이지만 프로세스가 수신 대기 중이기 때문에 연결에 실패합니다. 그럼 HAProxy는 그 후 다음 열린 연결 슬롯을 가진 다음 백엔드로 다시 배분하지만, 실제로 작업 중인 다른 백엔드는 없기 때문에 실패했던 이전 백엔드만 다시 시도됩니다. 이렇게 되면 재시도가 빠르게 소모되어 연결 오류가 HTML 렌더링보다 더 빠르게 발생하여 실패한 요청으로 이어집니다. 이 과정은 대기열이 완전히 소진될 때까지 나머지 요청에 계속 반복됩니다. 이는 좋지 않은 상황이지만, 프로세스 충돌이 드문 데에, 지속적인 대기열이 드문 데에 (계속해서 대기 중이면 공급이 부족한 것입니다) 그리고 특정한 경우에는 서비스 검색의 건강 검사를 빠르게 마킹하므로 전체 인스턴스를 건강하지 않게 표시하고 새 요청을 처리할 수 없게 만듭니다. 이는 좋지 않지만 위험을 최소화합니다. 미래의 작업은 HAProxy 통합을 통해 이를 해결할 수 있으며, 감독자 프로세스가 프로세스의 종료를 감지하고 haproxy stats 소켓을 통해 MAINT로 표시할 수 있는 깊은 HAProxy 통합을 통해 처리할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n다른 변경 사항 중 하나는 Node에서 server.close가 기존 요청이 완료될 때까지 기다리지만 HAProxy 대기열에 있는 것은 서버가 아직 받지 않은 요청을 기다릴지 모르기 때문에 실패할 것입니다. 인스턴스가 요청을 받지 않는 시간과 서버 재시작 프로세스를 시작하는 시간 사이에 충분한 드레인 시간을 보장하는 것이 대부분의 경우 이 문제를 해결해야 합니다.\n\n또한, 대부분의 트래픽을 처음에 사용 가능한 워커에 지시하는 'balance first'를 설정하면 (기본적으로 worker1을 포화시키는) 앱의 지연 시간이 'balance static-rr'보다 15% 감소했습니다. 이 효과는 합성 및 프로덕션 로드에서 지속되었으며, 웜 업으로 쉽게 설명되지 않는 결과였습니다. 이는 배포 후 몇 시간 동안 지속되었습니다. 성능은 시간이 지남에 따라 (12시간 동안) 점점 악화되었지만, 아마도 핫 프로세스의 메모리 누수 때문이었을 것입니다. 또한, 차가운 프로세스가 매우 차가웠기 때문에 트래픽의 급증에는 적응이 덜했습니다. 이에 대한 좋은 설명을 아직 찾지 못했습니다.\n\n마지막으로, Node의 server.maxConnections 설정은 여기에서 유용할 것으로 보였지만 (적어도 저에게는 그랬습니다), 실제로는 많은 효용성을 제공하지 않았으며 때때로 오류를 일으켰습니다. 이 설정은 서버가 maxConnections 이상의 새 핸들을 받지 않도록 하여 제한을 초과한 것을 확인한 후 새 핸들을 닫습니다. 이 확인은 JavaScript에서 적용되므로 무한 루프 상황에 대비하지 않습니다 (이벤트 루프로 돌아가면 요청을 올바르게 중단합니다...기다려). 또한 요청이 중단되면서 정상 작동 중에도 이로 인한 연결 오류가 발생했으며 다른 요청이 여러 개 실행 중인 증거는 없었습니다. 이는 연결이 언제 시작하고 끝나는지에 대한 약간의 타이밍 문제 또는 haproxy와 Node 간의 의견 차이로 의심됩니다. 상호 배타적 보증을 보유하는 것은 개발자가 싱글톤 또는 다른 전역 상태를 안전하게 사용할 수 있게 해주는 좋은 것입니다. 이는 익스프레스 미들웨어로 프로세스별 대기열을 구현함으로써 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n서버 측 렌더링은 주로 I/O 워크로드와는 다른 작업 부하를 나타냅니다. 이는 노드(Node)가 뛰어난 부분입니다. 이상적인 동작의 원인을 파악함으로써, 우리는 기존 운영 경험이 있는 제품을 사용하여 문제에 대처했습니다.\n\n에어비앤비에서는 세계적 수준의 프론트엔드 경험 구축에 크게 투자하고 있습니다. 이 글을 읽는 것이 즐거우셨고 이것이 흥미로운 도전이라고 생각하셨다면, 우리는 항상 역량 있는 호기심 많은 분들을 팀에 초대하고 있습니다. 여러분의 소식을 기다립니다!\n\n이 게시물을 검토하고 수정해준 Brian Wolfe, Joe Lencioni, Adam Neary에게 감사드립니다.\n\n## 각주\n\n<div class=\"content-ad\"></div>\n\n- 비동기 렌더링의 경우 여전히 자원 경합이 발생합니다. 비동기 렌더링은 프로세스나 브라우저의 응답성에 중점을 두지만 병렬 처리나 지연을 해결하지는 않습니다. 이 블로그 포스트는 순수 컴퓨팅 작업의 간단한 모델에 초점을 맞출 것입니다. IO 및 컴퓨팅의 혼합된 작업에서 요청 동시성이 증가하면 지연 시간이 증가하지만 더 높은 처리량을 얻을 수 있다는 장점이 있습니다.\n- 유니콘 웹 서버에서 영감을 받아 우리의 Rails 애플리케이션을 제공하는 데 사용합니다. 유니콘 철학은 특히 잘 설명하고 있습니다.\n- 대부분은 반응이 없는 프로세스를 우회하려고 시도합니다.\n- 클러스터는 요청이 아니라 연결을 분배하므로 예기치 않은 동작을 하며, 특히 지속적인 연결을 사용할 때 더 나빠집니다. 클라이언트로부터의 지속적인 연결은 특정한 워커 프로세스에 바인딩되어 있으므로 작업을 효율적으로 분배하기가 더 어려워집니다.","ogImage":{"url":"/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_0.png"},"coverImage":"/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_0.png","tag":["Tech"],"readingTime":15},{"title":"GraphQL 이해하기 효과적인 사용, 장단점 및 TypeScript와 Nodejs로 구현한 실용적인 사례","description":"","date":"2024-06-19 23:06","slug":"2024-06-19-UnderstandingGraphQLEffectivenessProsandConsandaPracticalUseCasewithTypeScriptandNodejs","content":"\n\nAPI에 대한 쿼리 언어인 GraphQL은 데이터 요청을 관리하는 효율성과 유연성으로 개발자들 사이에서 급속히 인기를 얻고 있어요. 2012년 Facebook에서 개발되어 2015년에 오픈 소스 프로젝트로 공개된 GraphQL은 REST에 대한 효율적이고 강력하며 유연한 대안을 제공해요. 이 글에서는 GraphQL의 효과를 탐구하고, 장단점을 살펴보고, TypeScript와 Node.js를 사용한 구체적인 사용 사례를 제시할 거에요.\n\nGraphQL의 효과\n\nGraphQL의 효과는 클라이언트가 정확히 필요한 데이터만 요청할 수 있는 능력에 있어요. 이는 네트워크 상에서 전송되는 데이터 양을 줄이고 애플리케이션의 성능을 최적화해요. 다음은 이 효과를 증진시키는 몇 가지 주요 기능들이에요:\n\n1. 정확한 데이터 가져오기\n\n<div class=\"content-ad\"></div>\n\nGraphQL을 사용하면 클라이언트가 응답 구조를 지정하여 필요한 데이터만 받을 수 있습니다. 이를 통해 과다 검색(필요 이상의 데이터 검색) 및 부족 검색(충분하지 않은 데이터 검색)을 방지할 수 있습니다.\n\n2. 단일 엔드포인트\n\nREST와 달리 데이터를 위해 여러 엔드포인트가 필요한 경우가 많은데, GraphQL은 다양한 리소스에 액세스하기 위해 단일 엔드포인트를 사용합니다. 이는 API를 단순화하고 여러 엔드포인트를 관리하는 복잡성을 줄여줍니다.\n\n3. 강력한 유형 지정 스키마\n\n<div class=\"content-ad\"></div>\n\nGraphQL API는 강력한 유형 시스템을 사용하여 스키마로 정의됩니다. 이 스키마는 클라이언트와 서버 간의 계약 역할을 하며 API와 상호 작용하기 쉽게 만들어줍니다.\n\n4. 구독을 통한 실시간 데이터\n\nGraphQL은 구독을 통해 실시간 데이터를 지원하여 클라이언트가 서버에서 특정 이벤트 발생 시 업데이트를 받을 수 있습니다. 실시간 업데이트가 필요한 애플리케이션에는 채팅 애플리케이션이나 실시간 대시보드 등이 특히 유용합니다.\n\nGraphQL의 장단점\n\n<div class=\"content-ad\"></div>\n\nGraphQL은 많은 이점을 제공하지만 일부 도전 과제도 함께 가지고 있습니다. 이점과 단점을 살펴보겠습니다:\n\n장점\n\n- 효율적인 데이터로딩: 클라이언트는 필요한 것만 요청할 수 있어 대역폭 사용량을 줄이고 성능을 향상시킬 수 있습니다.\n\n- 유연성: GraphQL은 버전 관리 없이 발전할 수 있습니다. 클라이언트는 새로운 필드와 타입을 쿼리할 수 있으며 새로운 API 버전이 필요하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n• 강력한 유형: 스키마는 데이터 유형을 강제하므로 오류를 줄이고 API가 더 예측 가능해집니다.\n\n• 인트로스펙션: GraphQL API는 인트로스펙션할 수 있어서 도구가 자동으로 문서와 클라이언트 라이브러리를 생성할 수 있습니다.\n\n• 개발자 경험: GraphiQL 및 Apollo Client와 같은 도구는 실시간 쿼리 테스트 및 캐싱과 같은 기능으로 개발 경험을 향상시킵니다.\n\n단점:\n\n<div class=\"content-ad\"></div>\n\n• 복잡성: GraphQL의 유연성으로 인해 복잡한 쿼리와 서버 측 리졸버의 복잡성이 증가할 수 있습니다.\n\n• 학습 곡선: REST에 익숙한 개발자들은 GraphQL로 전환할 때 학습 곡선에 직면할 수 있습니다.\n\n• 성능: 최적화되지 않은 GraphQL 쿼리는 데이터베이스 액세스의 N+1 문제와 같은 성능 문제를 일으킬 수 있습니다.\n\n• 캐싱 도전: 전통적인 HTTP 캐싱 전략은 GraphQL에서 덜 효과적이며, 더 정교한 캐싱 메커니즘이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n실용 사례: TypeScript와 Node.js로 GraphQL API 구축하기\n\nGraphQL의 실용적인 사용 사례를 설명하기 위해 TypeScript와 Node.js를 사용하여 간단한 GraphQL API를 구축할 것입니다. 이 API는 책과 저자 목록을 관리할 것입니다.\n\n프로젝트 설정\n\n먼저, 새로운 Node.js 프로젝트를 초기화하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nmkdir graphql-api\ncd graphql-api\nnpm init -y\nnpm install express express-graphql graphql typescript ts-node @types/node @types/express\n```\n\n타입스크립트 구성을 위한 tsconfig.json 파일을 생성하세요:\n\n```js\nimport { buildSchema } from 'graphql';\n\nconst schema = buildSchema(`\n  type Query {\n    books: [Book]\n    authors: [Author]\n  }\n\n  type Book {\n    id: ID!\n    title: String!\n    author: Author!\n  }\n\n  type Author {\n    id: ID!\n    name: String!\n    books: [Book]\n  }\n`);\n\nexport default schema;\n```\n\n리졸버 생성하기\n\n\n<div class=\"content-ad\"></div>\n\n```js\ninterface Book {\n  id: string;\n  title: string;\n  authorId: string;\n}\n\ninterface Author {\n  id: string;\n  name: string;\n}\n\nconst books: Book[] = [\n  { id: '1', title: '1984', authorId: '1' },\n  { id: '2', title: 'Brave New World', authorId: '2' },\n];\n\nconst authors: Author[] = [\n  { id: '1', name: 'George Orwell' },\n  { id: '2', name: 'Aldous Huxley' },\n];\n\nconst resolvers = {\n  books: () => books,\n  authors: () => authors,\n};\n\nexport default resolvers;\n```          \n\n서버 설정하기\n\nExpress 서버를 GraphQL과 함께 설정하기 위해 index.ts 파일을 생성하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport express from 'express';\nimport { graphqlHTTP } from 'express-graphql';\nimport schema from './schema';\nimport resolvers from './resolvers';\n\nconst app = express();\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: resolvers,\n  graphiql: true,\n}));\n\napp.listen(4000, () => console.log('서버가 http://localhost:4000/graphql 주소에서 실행 중입니다.'));\n```\n\n서버 실행\n\n서버를 실행하려면 TypeScript 코드를 컴파일하고 서버를 시작하면 됩니다:\n\n```js\nnpx tsc\nnode dist/index.js\n```\n\n<div class=\"content-ad\"></div>\n\n이제 http://localhost:4000/graphql에 방문하여 GraphiQL을 사용하여 GraphQL API와 상호 작용할 수 있어요.\n\n예시 쿼리\n\n모든 책과 저자를 쿼리할 수 있어요:\n\n```js\n{\n  books {\n    id\n    title\n    author {\n      name\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n아니면 모든 작가와 그들의 책들을 조회할 수도 있습니다:\n\n```js\n{\n  authors {\n    id\n    name\n    books {\n      title\n    }\n  }\n}\n```\n\n결론\n\nGraphQL은 API 디자인에 강력하고 유연한 접근 방식을 제공하여 클라이언트가 필요한 데이터를 정확히 요청할 수 있습니다. 복잡성 및 캐싱 문제와 같은 도전 과제가 있지만, 이러한 단점을 능가하는 이점이 많습니다. TypeScript와 Node.js를 사용하여 개발자는 GraphQL을 활용하여 효율적이고 확장 가능하며 견고한 API를 작성할 수 있으며 개발자 경험과 응용 프로그램 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nFynd Node.js.","ogImage":{"url":"/assets/img/2024-06-19-UnderstandingGraphQLEffectivenessProsandConsandaPracticalUseCasewithTypeScriptandNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-UnderstandingGraphQLEffectivenessProsandConsandaPracticalUseCasewithTypeScriptandNodejs_0.png","tag":["Tech"],"readingTime":5}],"page":"54","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}