{"pageProps":{"posts":[{"title":"새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화","description":"","date":"2024-06-20 07:16","slug":"2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers","content":"\n\nReact Native 개발자들이 기대할만한 새로운 것이 있습니다 — 현재 베타 단계에 있는 새로운 React Native IDE입니다. 이 흥미로운 새로운 도구는 Visual Studio Code (VS Code) 확장 프로그램으로 제공되며, macOS에서 안드로이드와 iOS 플랫폼 모두에 대한 개발을 지원합니다. 이 블로그에서는 이 IDE의 기능, 이점 및 잠재적인 도전 과제에 대해 탐구하고, React Native 개발 커뮤니티에 중요한 발전을 뜻하는 이유를 살펴보겠습니다.\n\n# React Native IDE 시작하기\n\n# 설치\n\n<div class=\"content-ad\"></div>\n\n리액트 네이티브 IDE 설치는 간단합니다. VS Code에 확장 프로그램을 추가하여 리액트 네이티브 프로젝트를 위해 특별히 설계된 강력한 개발 도구 모음을 활성화할 수 있습니다. 아래는 시작하는 방법입니다:\n\n- VS Code 열기: 최신 버전이 설치되어 있는지 확인해주세요.\n- 확장 프로그램으로 이동: 활동 표시줄의 확장 프로그램 아이콘을 클릭하거나 Ctrl+Shift+X를 눌러 확장 프로그램 뷰로 이동합니다.\n- 리액트 네이티브 IDE 검색: 검색 상자에 \"리액트 네이티브 IDE\"를 입력합니다.\n- 확장 프로그램 설치: 설치 버튼을 클릭하여 확장 프로그램을 VS Code 환경에 추가합니다.\n\n설치 후, 이 확장 프로그램은 원활하게 통합되어 리액트 네이티브 개발에 특화된 고급 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 1. 자동 시뮬레이터 관리\n\n시뮬레이터 및 에뮬레이터 관리는 귀찮은 일일 수 있지만, React Native IDE는 자동 시뮬레이터 관리 기능으로 이를 간단하게 처리합니다. 이 기능은 프로젝트에 적합한 시뮬레이터를 감지하고 시작하여 구성보다는 코딩에 집중할 수 있도록 합니다.\n\n# 2. 고급 디버깅 도구\n\nReact Native에서 디버깅하는 것은 이제 더 쉽지 않을 수 있습니다. IDE는 중단점 설정, 코드 스텝 진행 및 변수 검사를 포함한 견고한 디버깅 도구를 제공합니다. 이러한 도구는 문제를 신속하게 식별하고 해결하는 데 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 3. 요소 검사\n\n클릭하여 검사하는 기능이 특히 주목할 만합니다. 웹 개발 도구와 유사하게, 이 기능을 사용하면 시뮬레이터에서 어떤 요소를 클릭해도 VS Code 내에서 해당 요소의 속성을 직접 검사할 수 있습니다. 이 익숙한 작업 흐름은 사용하기 쉽고 효과적으로 인정 받고 있습니다.\n\n# 4. 라우팅 및 내비게이션\n\nExpo 라우터와 통합된 IDE를 사용하면 프로젝트 내에서 탐색을 간편화 할 수 있습니다. URL 바를 통해 경로를 지정하여 서로 다른 화면과 구성 요소를 테스트하고 디버그하기가 더 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n# 5. 로그 통합\n\nIDE 내에서 로그를 통합하면 개발 환경을 떠나지 않고 콘솔 출력과 오류 로그를 모니터링할 수 있습니다. 이 통합은 디버깅 프로세스를 간편하게 만들어주고 생산성을 향상시켜줍니다.\n\n# 6. 독립적인 컴포넌트 개발\n\nReact Native IDE의 특징 중 하나는 독립적인 환경에서 컴포넌트를 개발할 수 있는 기능입니다. 이 기능을 통해 개발자는 개별 컴포넌트에 집중하여 해당 컴포넌트가 완벽하게 작동하는지 확인한 뒤 더 큰 응용 프로그램에 통합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 도전 과제 및 베타 단계에서 발생하는 문제\n\n모든 베타 소프트웨어와 마찬가지로, React Native IDE에는 고려해야 할 도전 과제가 있습니다. 초기 설정은 일부 사용자에게 번거로울 수 있으며, 기능적인 결함이 예상되기도 합니다. 그러나 이러한 것들은 도구가 점차 성숙해지면 개선될 가능성이 높습니다.\n\n## 결론\n\n베타 단계에 있음에도 불구하고 React Native IDE는 React Native 개발자들에게 상당한 진전을 제공합니다. 개발 프로세스를 간소화하고 디버깅 기능을 강화하며 강력한 기능을 제공함으로써, 이 IDE는 생산성을 향상시키고 개발을 보다 쉽게 만들어주는 것을 약속합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 React Native 개발자이신 경우, 이 IDE의 베타 버전에 액세스를 요청하는 것은 워크플로우를 크게 향상시킬 수 있습니다. 이 인상적인 새로운 도구로 React Native 개발의 미래를 받아들이고 시대를 앞서가세요.\n\nIDE가 발전함에 따라 더 많은 안정성과 기능이 기대됩니다. 이는 React Native 개발자 툴킷의 필수적인 부분이 될 것입니다. React Native IDE가 완전히 출시될 때까지 업데이트와 개선 사항을 기대해주세요.\n\n🌟 읽어 주셔서 감사합니다!\n\n- 🚀 이 링크를 클릭하여 내 작업을 지원하세요: Support Me 🌟\n- 👏 이 기사에 박수를 보내어 감사의 표시를 전하세요.\n- 📌 더 많은 통찰력 있는 콘텐츠를 얻기 위해 Avishek Kumar를 팔로우하세요.\n\n<div class=\"content-ad\"></div>\n\n📣 계속 참여해 주세요\n\n- 🔔 트위터에서 팔로우하기(X)\n- 🔗 링크드인에서 연결하기\n\n# 스택아데믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n<div class=\"content-ad\"></div>\n\n- 작가를 응원하고 팔로우하기를 고려해 주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers_0.png"},"coverImage":"/assets/img/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers_0.png","tag":["Tech"],"readingTime":3},{"title":"웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법","description":"","date":"2024-06-20 07:15","slug":"2024-06-20-HowtoSecureYourSiteAgainstWebScrapers","content":"\n\n## 가장 좋은 브라우저 지문 기술입니다. 당신만의 지문 코드를 몇 분 안에 구현하는 법을 배워보세요!\n\n![이미지](/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png)\n\n브라우저 지문 기술은 사용자를 고유하게 식별하고 싶은 다양한 상황에서 사용되는 보안 기술입니다. 물론, 그러한 상황 중 하나는 당신의 웹 사이트를 스크랩하는 경우입니다. 사용자 에이전트나 IP를 확인하는 것과 같은 제한적인 탐지 기술을 사용하면 그 정보를 쉽게 변경할 수 있으며 당신은 알지 못할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 브라우저 핑거프린트와 같은 것을 구현한다면, 그들의 작업을 훨씬 더 어렵게 만들 수 있습니다. 왜냐하면 가짜로 만들기 어려운 정보를 사용하기 때문이죠.\n\n이 기사에서는 이렇게 불리는 \"브라우저 핑거프린트\"를 만드는 가장 일반적인 기술 중 일부를 다루고, 그 중 하나를 구현하는 방법을 안내해 드릴 거예요.\n\n# 일반적인 브라우저 핑거프린팅 기술\n\n이 제목이 어려운 것처럼 들릴 수 있지만, 핑거프린트란 특정 입력 데이터 집합으로부터 생성된 해시에 불과합니다.\n\n<div class=\"content-ad\"></div>\n\n진짜 핵심은 어떻게 그것에 도달하는지에 있어요.\n\n### 캔버스 요소 사용하기\n\n지문을 얻는 한 가지 방법은 사용자가 보지 못하도록 뭔가를 그려내고 그 결과를 확인하는 것입니다.\n\n각 브라우저는 캔버스 요소에 콘텐츠를 렌더링하는 방식에 약간의 차이가 있습니다. 이들은 미묘한 차이이므로 찾고 있지 않다면 정말로 발견하기 어렵습니다.\n\n<div class=\"content-ad\"></div>\n\n특정한 사용 사례는 여러 사실을 활용합니다:\n\n- 모든 시스템에 폰트가 제공되지 않아서 그런 경우에는 대체 옵션을 사용해야 합니다.\n- 적용된 안티 앨리어싱이 항상 동일하지는 않습니다.\n- 브라우저의 구현에 따라 다른 세부 사항이 있습니다.\n\n한 번 렌더링된 후 이미지를 해시로 변환해야 하며, 그렇게 하면 지문이 생성됩니다.\n\n최고의 부분은 캔버스 요소를 숨길 수 있어서 사용자가 실제로 무엇을 하는지 알 수 없다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 미디어 장치 목록\n\n브라우저의 지문을 식별하는 또 다른 방법은 시스템에 연결된 미디어 장치 목록을 수집하고 그 정보를 기반으로 해시를 생성하는 것입니다.\n\n이를 어떻게 할 수 있을까요? 실은 매우 간단합니다. 모든 최신 브라우저에는 연결된 모든 장치를 나열할 수 있는 미디어 장치 API가 있습니다.\n\n다음 코드는 시스템에서 모든 미디어 장치를 나열합니다:\n\n<div class=\"content-ad\"></div>\n\nMDN 공식 문서에서 가져온 코드입니다. 제 Firefox에서 실행하면 다음 출력이 나옵니다:\n\n```html\n<img src=\"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_1.png\" />\n```\n\n미래 요청에서 식별자 역할을 할 수 있는 단일 해시 값을 생성하는 방법을 쉽게 파악할 수 있을 것 같습니다. 브라우저 구성을 변경하더라도 식별 가능합니다.\n\n## 오디오 파형 지문분석\n\n<div class=\"content-ad\"></div>\n\n캔버스 요소 기술과 마찬가지로 Web Audio API를 사용하여 오디오 클립을 생성할 수도 있습니다. 고정된 소스(모든 시스템에 동일한 입력을 제공하는 발진기)를 기반으로 하고 출력의 해시를 계산할 수도 있습니다.\n\nWeb Audio API의 복잡성을 고려하면, 많은 수학과 부동 소수점 수학이 관련되어 있습니다. 이는 각 브라우저가 조금씩 다른 구현을 갖게 되며, 이는 누가 작성했는지와 해당 운영 체제에 따라 달라집니다. 이러한 차이점은 실행 중인 시스템이 매 실행에서 일관된 고유값을 생성할 수 있을 정도로 충분히 누적됩니다.\n\n이러한 값은 브라우저와 운영 체제를 식별하는 데 사용할 수 있는 신뢰할 수 있는 지문으로 사용할 수 있습니다. 특히, 브라우저의 시크릿 모드를 사용하더라도 동일한 지문이 유지됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 직접 지문코드를 구현해 봅시다\n\n가장 흔한 지문 기술 중 일부를 이해했으니, 여기서는 그 중 하나를 구현하는 방법에 대해 빠르게 살펴보겠습니다.\n\n미디어 장치 목록에 대한 코드 일부를 이미 보았지만, 캔버스 요소에 중점을 둘 것입니다. 많은 데이터 포인트를 수집하는 것보다 더 흥미로운 것이라고 생각하기 때문입니다.\n\n이 기술을 사용하려면 텍스트가 포함된 그림을 캔버스 요소 내부에 그리고, 그 그림을 단일 해시로 변환해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 해야 할 일은 캔버스를 정의하고 그 안에 몇 가지 모양을 그리고 텍스트를 추가한 다음, 그 위에서 toDataURL 메서드를 호출하는 것 뿐이에요. 기본적으로 캔버스는 우리의 이미지를 PNG로 변환하고, 그것을 단일 해시 값으로 변환할 겁니다.\n\n특히, 우리의 \"해시\"는 단일 정수가 될 겁니다. 본인이 원하는 해싱 방법을 사용해도 돼요. 저는 코딩하기 쉽고 빠른 성능을 가진 하나를 선택했어요.\n\n이 코드는 다음과 같은 출력물을 생성합니다:\n\n![How to Secure Your Site Against Web Scrapers](/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_2.png)\n\n<div class=\"content-ad\"></div>\n\n당연히 실제 이미지는 상당히 추악합니다. 우리는 지금 아름다운 것을 만들려는 것이 아니라 해시에 대해 걱정하고 있습니다. 크롬과 시크릿 모드의 크롬의 값이 동일하고 파이어폭스에서는 다르다는 것을 주목하세요.\n\n이것은 중요한 포인트입니다. 이는 크롤러/스크레이퍼가 그들의 브라우저에서 음해모드를 사용함으로써 \"속이려\" 하려고 할 때 언제인지 알 수 있다는 것을 의미합니다.\n\n그들은 브라우저를 변경할 수 있고, 그러면 당신은 몰라도 될 것입니다. 그러나 스크레이퍼/크롤러는 보통 자신을 다른 것처럼 식별하려고 하는 동일한 브라우저를 항상 사용합니다 (User Agent 문자열과 같이).\n\n이 상황에서 당신은 웹사이트를 크롤링/스크래핑하려는 헤드리스 브라우저에 대해 보호할 수 있습니다. 위 코드를 숨겨진 Canvas 요소에 실행하는 스크립트를 갖고, 해시를 가져와서 자체 \"블랙리스트\" 값 목록과 비교하세요. 그들이 거기에 있다면, 그럼 무슨 일을 해야하는지 알 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n브라우저 지문 추적은 사용자가 시스템과 상호 작용하는 방식을 원치 않을 때 보호하는 데 훌륭한 도구일 수 있습니다. 사이트를 스크랩하려는 사람부터 사용자가 유료 콘텐츠를 속일 수 없도록 하는 데 사용되며, 또는 콘텐츠에 제한된 횟수로만 액세스하도록 하는 데도 사용될 수 있습니다. 정말로 여러분의 상상력이 한계입니다.\n\n그리고 이론이 복잡해 보이지만 실제 구현은 그렇지 않다는 것을 알 수 있습니다. 여러분은 손쉽게 자체 지문 코드를 작성할 수 있습니다.\n\n이런 기술 중 하나를 사용해 보셨나요? 혹은 더 나아가, 과거에 한 번 속여 본 경험이 있으신가요? 그렇다면 어떻게 하셨는지 이야기를 공유해 주세요!\n\n# 재사용 가능한 컴포넌트로 마이크로프론트엔드 구축하기\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_3.png\" />\n\nBit의 오픈소스 도구를 통해 25만 명 이상의 개발자가 컴포넌트로 앱을 만들 수 있습니다.\n\n어떤 UI, 기능 또는 페이지도 재사용 가능한 컴포넌트로 변환하여 여러 애플리케이션에서 공유할 수 있습니다. 협업이 더 쉬워지고 빠르게 개발할 수 있습니다.\n\n→ 자세히 알아보기\n\n<div class=\"content-ad\"></div>\n\n앱을 구성 요소로 나누어 앱 개발을 쉽게 만들고 원하는 워크플로우에 최적의 경험을 즐기세요:\n\n- **Micro-Frontends**   \n- **Design System**   \n- **Code-Sharing and reuse**  \n\n<div class=\"content-ad\"></div>\n\n## → 모노리포\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png","tag":["Tech"],"readingTime":5},{"title":"Reactjs 심층 분석 1  createElement와 jsx-runtime","description":"","date":"2024-06-20 07:13","slug":"2024-06-20-ReactjsDeepDive1createElementandjsx-runtime","content":"\n\n<img src=\"/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png\" />\n\nReact는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리로, 상호작용적이고 동적인 웹 애플리케이션을 만들기 위한 다양한 도구와 기능이 풍부합니다. React의 최신 버전(React 17부터)에서는 JSX 변환 방법이 크게 변경되었습니다. React 17에서 소개된 새로운 JSX 변환은 더 이상 React.createElement을 직접적으로 사용하지 않습니다. 대신, react/jsx-runtime 및 react/jsx-dev-runtime 패키지에서 jsx, jsxs, jsxDEV 등의 새로운 함수를 도입하였습니다. 이 글은 \"React.js Deep Dive\" 시리즈 중 첫 번째로, React.createElement, jsx-runtime을 사용한 새 버전 및 React 생태계에서의 역할을 탐구합니다.\n\n이 새로운 변환 방법이 작동하는 방식에 대한 개요는 다음과 같습니다:\n\n# React 17 이전\n\n<div class=\"content-ad\"></div>\n\n이전에는 JSX가 React.createElement 호출로 컴파일되었습니다. 예를 들어, 다음 JSX:\n\n```js\nfunction App() {\n  return (\n    <div>\n      My App\n    </div>\n  );\n}\n\nexport default App;\n```\n\n백그라운드에서 JSX는 React.createElement 호출로 변환됩니다:\n\n```js\nfunction App() {\n  return React.createElement(\"div\", {\n    children: \"My App\"\n  });\n}\n``` \n\n<div class=\"content-ad\"></div>\n\n# React 17버전 이후\n\n새 JSX 변환 기능을 사용하면 같은 JSX 코드:\n\n```js\nfunction App() {\n  return (\n    <div>\n      My App\n    </div>\n  );\n}\n\nexport default App;\n```\n\n다음으로 변환됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction App() {\n  return /*#__PURE__*/_jsx(\"div\", {\n    children: \"내 앱\"\n  });\n}\nexport default App;\n```\n\n개발 모드에서는 더 나은 디버깅 정보를 제공하기 위해 react/jsx-dev-runtime의 jsxDEV을 사용할 수 있습니다:\n\n```js\nfunction App() {\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n    children: \"내 앱\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 3,\n    columnNumber: 5\n  }, this);\n}\n```\n\n# 왜 이 변화가 있었을까요?\n\n\n<div class=\"content-ad\"></div>\n\n새로운 JSX 트랜스폼에는 여러 가지 이점이 있습니다:\n\n- 범위 내에서 React 사용량이 필요 없음: 새로운 트랜스폼을 사용하면 JSX를 사용하는 모든 파일 맨 위에 React를 가져오지 않아도 됩니다. 이는 코드를 간소화하고 보일러플레이트를 줄일 수 있습니다.\n- 더 작은 번들 크기: 새로운 트랜스폼은 좀 더 최적화된 코드를 생성하기 때문에 조금 더 작은 번들 크기로 이어질 수 있습니다.\n- 미래 지향적: 이 변경 사항은 React 생태계를 미래 개선과 최적화를 위해 준비시킵니다.\n\n이 함수를 더 자세히 살펴보면 반환 값이 이와 같아야 합니다:\n\n```js\n{\n  $$typeof: Symbol(react.element),\n  type: \"div\",\n  props: {children: 'My App'},\n  key:null,\n  ref:null,\n  _owner: null,\n  _store: {validated: false}\n  _self: undefined\n  _source: {\n    fileName: '/my-app/src/App.tsx', \n    lineNumber: 3, \n    columnNumber: 5\n  }\n  [[Prototype]]: Object\n}\n```\n\n<div class=\"content-ad\"></div>\n\n자, 이제 반환된 각 속성을 자세히 살펴보겠습니다:\n\n타입\n\n전달한 요소의 유형입니다. HTML 태그나 React 컴포넌트를 나타내는 문자열일 수 있습니다. 위의 코드에서는 타입이 HTML 태그 div입니다.\n\n프롭스\n\n<div class=\"content-ad\"></div>\n\n전달 된 props 중에서 ref 및 key를 제외한 항목들. 컴포넌트의 타입이 defaultProps 속성을 가지고 있다면, 누락되거나 정의되지 않은 props는 기본 값으로 설정됩니다.\n\nref\n\n전달된 ref입니다. ref가 전달되지 않았다면, 이 속성은 null이 될 것입니다. Ref를 사용하면 DOM 노드에 직접 액세스할 수 있어 입력란에 초점을 맞추거나 스크롤 위치를 읽거나 DOM에 직접 액세스가 필요한 타사 DOM 라이브러리와 통합하는 등의 작업을 수행할 수 있습니다.\n\nkey\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n# 내부 메커니즘\n\n전달된 키가 문자열로 강제 변환됩니다. 키가 전달되지 않았다면, 이 속성은 null이 될 것입니다.\n\n중요한 점은 $$typeof, _store, _owner 및 _self가 React에서 개발 시 사용되는 내부 메커니즘임을 알아두어야 합니다. 이들은 React 작동에 중요한 역할을 하지만, 애플리케이션 코드에서 사용되도록 의도된 것은 아닙니다.\n\n$$typeoff\n\n<div class=\"content-ad\"></div>\n\nReact는 React 요소를 고유하게 식별하기 위해 $$typeof 속성을 사용합니다. 심볼을 초기에 사용한 선택은 다른 환경에서 전역 고유성을 보장하고 다른 라이브러리나 전역 범위의 코드와의 이름 충돌을 피하기 위한 욕구에서 비롯되었습니다.\n\n_store\n\nReact 요소 객체의 _store 속성은 주로 개발 모드(__DEV__)에서 유효성 검사를 위해 사용됩니다. 이 속성에는 validated라는 단일 부울 속성이 포함되어 있습니다. 이 속성은 React 요소가 특정 규칙에 대해 유효성을 검사했는지 여부를 나타내는 플래그 역할을 합니다. 예를 들어, 요소가 목록의 일부이고 고유한 키 속성이 없는 경우, React의 유효성 검사 논리는 _store.validated를 false로 표시할 것입니다. 요소를 유효성을 검사한 후, React는 _store.validated를 true로 설정하여 요소가 검사되었고 해당 요소에 대해 추가 유효성 검사가 필요하지 않음을 나타냅니다.\n\n_owner\n\n<div class=\"content-ad\"></div>\n\nReact에서 _owner 속성은 구성 요소 인스턴스의 소유자를 추적하는 데 내부적으로 사용됩니다. 이것은 React의 조정 프로세스에 중요한데요, 여기서 구성 요소가 다시 렌더링해야 하는지 여부를 결정합니다. 부모 구성 요소가 렌더링되면, 해당 자식 구성 요소의 인스턴스가 생성됩니다. 이러한 각 자식 인스턴스는 _owner 속성을 통해 부모에 대한 참조를 가지게 됩니다. 이를 통해 React는 구성 요소의 계층 구조를 추적하고 상태 변경을 효율적으로 관리할 수 있습니다.\n\n_self\n\nReact 요소의 _self 속성은 개발 모드 확인 및 최적화를 위해 React에서 사용되는 또 다른 내부 속성입니다. 이는 이벤트 위임 중에 원래 이벤트 대상을 저장하는 데 사용됩니다.\n\n이벤트가 트리거될 때 React는 _self를 사용하여 이벤트의 원래 대상을 기억합니다.\n\n<div class=\"content-ad\"></div>\n\n_소스\n\n리액트 요소에서 _소스 속성은 공식 리액트 문서나 표준 리액트 자원에서 직접적으로 문서화되지 않았습니다. 그러나 맥락을 고려하면, _소스는 리액트의 합성 이벤트 시스템 내에서 이벤트 원천 또는 소스를 내부적으로 추적하는 데 관련이 있을 수 있습니다.\n\n# 결론\n\n요약하면, 리액트는 React 17부터 도입된 새 JSX 변환에서 더 이상 React.createElement을 직접적으로 사용하지 않습니다. 대신, react/jsx-runtime(jsx, jsxs) 및 react/jsx-dev-runtime(jsxDEV)에서 함수를 사용합니다. 이 변경으로 JSX를 사용할 때 React를 가져와야 하는 필요성을 제거하고, 잠재적으로 더 작은 번들 크기를 갖게 하며, 미래의 향상을 대비합니다. 해당 기능을 이해함으로써 리액트의 작동 방식에 대해 보다 깊은 통찰을 얻을 수 있어서 효율적이고 효과적인 리액트 애플리케이션을 작성하는 능력을 향상시킬 수 있습니다. 다음 글에서는 가상 DOM을 탐험하고, 리액트가 렌더링 성능을 최적화하기 위해 어떻게 사용하는지 살펴볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 더 많은 통찰과 즐거운 코딩을 기대해 주세요!\n\n참고 자료:\n\n- React 문서: React 17: 새로운 JSX 변환\n- Babel 문서: Babel: JSX 런타임\n- Webpack 문서: Webpack: 모드 구성","ogImage":{"url":"/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png"},"coverImage":"/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png","tag":["Tech"],"readingTime":5},{"title":"대시트랩 - 부트스트랩 5 관리자 대시보드, UI 키트","description":"","date":"2024-06-20 06:09","slug":"2024-06-20-DashtrapBootstrap5AdminDashboardUIKits","content":"\n\n🔍 다시 한 번 Dashtrap을 확인해보세요 - Bootstrap 5 Admin Dashboard & UI Kits! 🎉 저희의 📁 관리자 템플릿 웹 템플릿 라이브러리를 살펴보시고 🆓 무료 다운로드 혜택을 누리세요. 함께 즐겁게 작업해봅시다! 🚀\n\nXeloro는 Bootstrap 5, HTML5, CSS3, 그리고 JQuery를 기반으로 한 개발자 친화적이며 매우 커스터마이즈 가능한 HTML 관리 대시보드 템플릿 중 가장 우수한 제품입니다. 완전히 반응형이며 컴포넌트, 위젯 및 UI 요소의 거대한 컬렉션을 포함한 청결한 사용자 인터페이스를 제공합니다. Xeloro는 다음 Bootstrap을 더 빠르게 만들 수 있도록 도와줍니다. SAAS 기반 인터페이스, 관리자 대시보드, 또는 웹에서 구축하고 싶은 모든 것을 만드는 데 사용할 수 있습니다. Xeloro는 팀이 더 빠르게 움직이고 개발 비용을 절약할 수 있도록 도와줍니다.\n\n특징:\n\n- 응답형 레이아웃 (데스크톱, 태블릿, 모바일 기기)\n- Bootstrap v5.3.2로 구성\n- 쉽게 사용자 정의 가능\n- 48개 이상의 빌드된 페이지\n- 깨끗하고 평평한 디자인\n- HTML5 및 CSS3\n- SASS 지원\n- 로그인, 등록 및 오류 페이지\n- 캘린더 보기\n- 수직 및 수평 레이아웃\n- 양식 유효성 검사\n- Google 및 Vector Maps\n- Dropify 파일 업로드\n- Quill Js 편집기\n- 부스트랩 및 데이터테이블 테이블\n- Feather, Material Design, Dripicons 및 Font Awesome 5 아이콘\n- 양식 마스크\n- 팀원, 송장, 유지보수, FAQ 및 가격 페이지\n- Apex Chats 라이브러리\n- Bootstrap, React, MaxLength, Switchery, Select2, Bootstrap Touchspin, Colorpicker, Bootstrap Datepicker, Date Range Picker 및 Auto-Numberic 플러그인\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-DashtrapBootstrap5AdminDashboardUIKits_0.png)\n\nMyraStudio님의 Envato Elements에서 사진을 찍음\n\n고지: 본 문서에는 제휴 링크가 포함되어 있습니다. 이 링크를 통해 구매를 하신 경우 추가 비용없이 수수료를 받을 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-DashtrapBootstrap5AdminDashboardUIKits_0.png"},"coverImage":"/assets/img/2024-06-20-DashtrapBootstrap5AdminDashboardUIKits_0.png","tag":["Tech"],"readingTime":2},{"title":"자바를 사용하여 Flying Saucer로 HTML을 PDF로 변환하기","description":"","date":"2024-06-20 06:08","slug":"2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer","content":"\n\n<img src=\"/assets/img/2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer_0.png\" />\n\n요즘의 디지털 세계에서 HTML 파일을 PDF 문서로 프로그래밍적으로 변환하는 것은 보고서 생성, 문서 보관 등 엔터프라이즈 애플리케이션에서 흔한 요구 사항입니다. 이 블로그 포스트에서는 Maven 종속성을 활용하여 Java를 이용해 이 작업을 어떻게 수행하는지 알아보겠습니다.\n\n# Flying Saucer 소개\n\nFlying Saucer는 XHTML/XML 문서를 PDF로 쉽게 변환할 수 있는 오픈 소스 Java 라이브러리입니다. PDF 생성을 위해 강력한 iText 라이브러리를 내부적으로 활용합니다.\n\n<div class=\"content-ad\"></div>\n\n# Maven 종속성 설정\n\n```java\n<dependency>\n    <groupId>org.xhtmlrenderer</groupId>\n    <artifactId>flying-saucer-core</artifactId>\n    <version>9.1.22</version>\n</dependency>\n<dependency>\n    <groupId>org.xhtmlrenderer</groupId>\n    <artifactId>flying-saucer-pdf</artifactId>\n    <version>9.1.22</version>\n</dependency>\n<dependency>\n    <groupId>org.xhtmlrenderer</groupId>\n    <artifactId>flying-saucer-pdf-openpdf</artifactId>\n    <version>9.1.20</version>\n</dependency>\n<dependency>\n    <groupId>org.jsoup</groupId>\n    <artifactId>jsoup</artifactId>\n    <version>1.13.1</version>\n</dependency>\n```\n\n이러한 종속성에는 핵심 Flying Saucer 라이브러리, PDF 렌더링 기능, OpenPDF를 사용한 Flying Saucer PDF 구현, 그리고 HTML 파싱을 위한 Jsoup 라이브러리가 포함되어 있습니다.\n\n# HTML을 PDF로 변환하기 - Java 코드\n\n<div class=\"content-ad\"></div>\n\n이제 자바 코드를 살펴봅시다:\n\n```js\nimport java.io.FileOutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.xhtmlrenderer.pdf.ITextRenderer;\n\npublic class PdfGenerator {\n\n    private static String htmlToXhtml(String html) {\n        // Convert HTML to XHTML\n        Document document = Jsoup.parse(html);\n        document.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n        return document.html();\n    }\n\n    public static void main(String[] args) {\n        String inputFile = \"appointment_letter.html\"; // XHTML/XML 파일 경로\n        String outputFile = \"output.pdf\"; // 출력 PDF 파일 경로\n\n        try {\n            // ITextRenderer 인스턴스 생성\n            ITextRenderer renderer = new ITextRenderer();\n\n            // 파일에서 HTML 콘텐츠 읽기\n            String content = FileUtils.readFileToString(Paths.get(inputFile).toFile(), StandardCharsets.UTF_8);\n\n            // 치환 작업 수행\n            Map<String, String> valueMap = new HashMap<>();\n            valueMap.put(\"employeeId\", \"20240200001\");\n            valueMap.put(\"employeeName\", \"Harish Jay Raj\");\n            valueMap.put(\"startDate\", \"25-03-2024\");\n\n            Set<Entry<String, String>> entrySet = valueMap.entrySet();\n            for (Entry<String, String> es : entrySet) {\n                content = content.replace(\"@{\" + es.getKey() + \"}\", es.getValue());\n            }\n\n            // HTML을 XHTML로 변환\n            String htmlToXhtml = PdfGenerator.htmlToXhtml(content);\n            renderer.setDocumentFromString(htmlToXhtml);\n\n            // 문서를 PDF로 렌더링\n            renderer.layout();\n            FileOutputStream fos = new FileOutputStream(outputFile);\n            renderer.createPDF(fos);\n            fos.close();\n\n            System.out.println(\"PDF 생성 성공!\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 코드 이해\n\n- Flying Saucer의 ITextRenderer 클래스를 사용하여 HTML 콘텐츠를 PDF로 렌더링합니다.\n- HTML 콘텐츠는 파일(appointment_letter.html)에서 읽혀서 문자열로 저장됩니다.\n- Map을 사용하여 동적 콘텐츠 치환을 수행합니다. 예를 들어 '@employeeId'나 '@employeeName'과 같은 플레이스홀더를 실제 값으로 대체합니다.\n- HTML 콘텐츠를 Flying Saucer와 호환성을 위해 Jsoup 라이브러리를 사용하여 XHTML로 변환합니다. 마지막으로, XHTML 콘텐츠를 PDF로 렌더링하여 지정된 출력 파일(output.pdf)에 저장합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>임명서</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n        }\n\n        .letter {\n            max-width: 600px;\n            margin: 0 auto;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\n        }\n\n        .header {\n            text-align: center;\n            margin-bottom: 20px;\n        }\n\n        .employee-info {\n            margin-bottom: 20px;\n        }\n\n        .closing {\n            margin-top: 20px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"letter\">\n        <div class=\"header\">\n            <h2>임명서</h2>\n        </div>\n\n        <p>\n            친애하는 <span id=\"employeeName\">@{employeeName}</span>님,\n        </p>\n\n        <p>\n            당신이 XYZ 회사의 직원으로 임명되었음을 기쁘게 알려드립니다. 당신의 헌신과 기술이 아래 세부 사항을 통해 당신에게 이 직책을 얻게 했습니다.\n        </p>\n\n        <div class=\"employee-info\">\n            <p><strong>직원 ID:</strong> <span id=\"employeeId\">@{employeeId}</span></p>\n        </div>\n\n        <p>\n            XYZ 회사와의 근무는 <span id=\"startDate\">@{startDate}</span>에 시작될 것입니다. 입사일에 인사부서에 보고하여 추가 방향과 절차에 대해 안내받으시기 바랍니다.\n        </p>\n\n        <p>\n            여러분의 전문 지식이 팀에 크게 기여할 것이라 믿으며, 소중한 공헌을 기대하고 있습니다.\n        </p>\n\n        <div class=\"closing\">\n            <p>감사합니다,</p>\n            <p>XYZ 회사 팀</p>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 튜토리얼에서는 Flying Saucer 라이브러리를 사용하여 Java로 HTML 파일을 PDF 문서로 변환하는 방법을 알아보았습니다. 이 접근 방식을 통해 HTML 내용을 프로그래밍 방식으로 PDF 문서로 생성할 수 있는 유연성과 사용자 정의 옵션이 제공됩니다. 제공된 단계와 코드 스니펫을 따라하면 Java 애플리케이션에 쉽게 HTML을 PDF로 변환하는 기능을 통합할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer_0.png"},"coverImage":"/assets/img/2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer_0.png","tag":["Tech"],"readingTime":6},{"title":"HTML5 캔버스를 사용하여 픽셀 완벽한 그래픽 만들기 방법","description":"","date":"2024-06-20 06:07","slug":"2024-06-20-HowtoCreatePixelPerfectGraphicsUsingHTML5Canvas","content":"\n\n진짜 8비트 시각을 위한 캔버스 그래픽 마스터링 단계별 안내서입니다.\n\n이 포스트에서는 픽셀 완벽한 웹 게임을 만들기 위한 기반을 구축할 것입니다. \"픽셀 완벽\"이란 모든 픽셀이 선명하고 흐릿하지 않다는 것을 의미합니다. 이 자습서를 완료하면 픽셀화된 별 배경 위에 두 개의 이동하는 직사각형을 애니메이션하는 단일 HTML 파일이 생깁니다.\n\n다음 세 단계로 진행하겠습니다:\n\n1. 캔버스가 올바르게 크기 조정되는 기본 HTML 구조 설정\n\n<div class=\"content-ad\"></div>\n\n# 직사각형과 별을 그려보세요\n\n# 이미지 흐림 방지, 모든 픽셀을 선명하게 설정\n\n# 크기 조절 가능한 캔버스\n\n한 가지 HTML5 캔버스를 가진 간단한 HTML 페이지를 만들 것입니다. 이 캔버스는 브라우저 창 크기가 변경될 때 동적으로 크기가 조정됩니다. 정수 스케일링 상수를 사용하여 스케일링이 균일한 픽셀 크기를 유지하는지 제어할 수 있습니다. 정수 스케일링을 true로 설정하면 모든 픽셀이 동일한 크기를 유지합니다. 단점은 정수 스케일링으로 인해 일부 브라우저 창 크기에 따라 캔버스 주변에 더 큰 테두리가 생길 수 있다는 점입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>빈 크기 조절 캔버스</title>\n    <style>\n      html,\n      body {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        height: 100%;\n        margin: 0;\n        background-color: #887ecb;\n      }\n    \n      .canvas-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        width: 100%;\n        height: 100%;\n      }\n\n      #gameCanvas {\n        background-color: #50459b;\n        max-width: 100%;\n        max-height: 100%;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"canvas-container\">\n      <canvas id=\"gameCanvas\" width=\"64\" height=\"36\"></canvas>\n    </div>\n    <script>\n      const INTEGER_SCALING = true;\n\n      const canvas = document.getElementById(\"gameCanvas\");\n\n      function resizeCanvas() {\n        let scale = Math.min(\n          window.innerWidth / canvas.width,\n          window.innerHeight / canvas.height\n        );\n        if (INTEGER_SCALING) {\n          scale = Math.floor(scale);\n        }\n        canvas.style.width = `${Math.round(scale * canvas.width)}px`;\n        canvas.style.height = `${Math.round(scale * canvas.height)}px`;\n      }\n\n      resizeCanvas();\n      window.addEventListener(\"resize\", resizeCanvas);\n    </script>\n  </body>\n</html>\n```\n\n위 코드의 주요 포인트는 크기 조절 이벤트에 등록하고 이벤트가 발생할 때마다 페이지의 캔버스 크기를 변경하는 것입니다. 스케일은 내부 캔버스 크기가 화면에 가장 적은 수의 배에 맞도록 계산됩니다. 이는 다른 방향으로 테두리를 유발할 수 있지만 내부 캔버스 크기의 종횡비를 유지합니다.\n\n창의 크기를 조정하면 캔버스 크기가 변경되는 것을 확인할 수 있습니다. 또한 INTEGER_SCALING 값을 false로 변경하여 캔버스가 항상 창을 가로 또는 세로로 채우는 방법을 확인해보세요.\n\n# 캔버스에 그리기\n\n\n<div class=\"content-ad\"></div>\n\n캔버스에 그리기 위해서는 먼저 캔버스의 컨텍스트를 가져와야 합니다. 투명한 픽셀을 남기지 않을 것이기 때문에 알파값을 false로 설정합니다.\n\n```js\nconst canvas = document.getElementById(\"gameCanvas\");\nconst ctx = canvas.getContext(\"2d\", { alpha: false });\n```\n\n간단하게 유지하기 위해 이 게시물에서는 사각형만 그릴 것입니다.\n\n```js\nfunction drawRectangle(x, y, width, height, color) {\n  ctx.fillStyle = color;\n  ctx.fillRect(x, y, width, height);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 우리는 배경을 위해 200개의 별을 만듭니다. 별은 색에 따라 정렬되어 있으므로 덜 밝은 별이 더 밝은 별 위에 그려지지 않습니다.\n\n```js\nfunction createStar() {\n  const color = Math.floor(Math.random() * 256);\n  return {\n    x: Math.random() * canvas.width,\n    y: Math.random() * canvas.height,\n    color: color,\n    fillStyle: `rgb(${color}, ${color}, ${color})`,\n  }; \n}\n\nconst stars = Array.from({ length: 200 }, createStar).sort(\n  (a, b) => a.color - b.color\n);\n```\n\n우리는 requestAnimationFrame을 사용하여 게임 루프가 필요한 매 프레임마다 발생하도록 만듭니다. gameLoop이 호출될 속도는 \"일반적으로 디스플레이 새로고침 속도와 일치\"합니다. 많은 경우에 초당 60프레임인 경우가 많지만 다를 수도 있습니다. `now` 매개변수는 이전 프레임 렌더링의 밀리초를 나타냅니다. 애니메이션 중에 이 시간을 사용하는 것이 중요하며 일정한 프레임 속도를 가정하는 대신 해당 시간을 사용해야 합니다.\n\n```js\nfunction gameLoop(now) {\n  draw(now);\n  requestAnimationFrame(gameLoop);\n}\ngameLoop();\n```\n\n<div class=\"content-ad\"></div>\n\n이제 재미있는 부분이 시작됩니다 — 캔버스에 그림을 그리는 것! 이전 프레임의 그래픽을 지우기 위해 캔버스를 지우는 것으로 시작합니다. 그런 다음, 모든 별과 두 개의 사각형을 그리는데, 이는 일정한 사인 및 코사인 패턴에 따라 움직입니다.\n\n```js\nfunction draw(t) {\n  drawRectangle(0, 0, canvas.width, canvas.height, \"#000\");\n\n  stars.forEach((star) => {\n    drawRectangle(star.x, star.y, 1, 1, star.fillStyle);\n    star.x = (star.x - star.color / 5000 + canvas.width) % canvas.width;\n  });\n  drawRectangle(\n    canvas.width / 4,\n    canvas.height / 4 + (canvas.width / 10) * Math.sin(t / 500),\n    canvas.width / 2,\n    canvas.height / 2,\n    \"#008\"\n  );\n  drawRectangle(\n    canvas.width / 2 + (canvas.width / 4) * Math.cos(t / 1000) - 4,\n    canvas.height / 2 + (canvas.height / 4) * Math.sin(t / 1000) - 4,\n    8,\n    8,\n    \"#00c\"\n  );\n}\n```\n\n그리고 이렇게 보입니다.\n\n이 코드펜에서 실행 중인 애니메이션을 확인해보세요:\n\n<div class=\"content-ad\"></div>\n\n그게 많이 8-bit스럽지 않네요, 맞죠? 우리가 마주한 두 가지 문제는 스케일링할 때 픽셀 보간과 그릴 때 안티앨리어싱입니다.\n\n# Unblur\n\n## 픽셀 보간 끄기\n\n브라우저는 캔버스를 확대할 때 픽셀을 보간하고 있습니다. 이는 합리적인 표준 동작이지만 픽셀 그래픽에 적합하지 않습니다. 대신 css에서 픽셀화된 스케일링을 사용하도록 브라우저에 지시합니다:\n\n<div class=\"content-ad\"></div>\n\n```css\ncanvas {\n  background-color: #50459b;\n  max-width: 100%;\n  max-height: 100%;\n  image-rendering: pixelated;\n}\n```\n\n## 안티앨리어싱 피하기\n\n또 다른 흐림 현상을 일으키는 문제는 정수가 아닌 값을 그릴 때 발생합니다. 별이 픽셀 사이에 위치할 때 브라우저는 일관성있게 만들려고 노력합니다. 해결책은 간단합니다. 우리는 좌표를 모두 정수로 반올림하면 됩니다. 이 해결책을 drawRectangle 함수에 넣어서 어디서든 무언가를 그릴 때마다 생각할 필요가 없게 만듭니다:\n\n```js\nfunction drawRectangle(x, y, width, height, color) {\n  ctx.fillStyle = color;\n  ctx.fillRect(\n    Math.round(x),\n    Math.round(y),\n    Math.round(width),\n    Math.round(height)\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음은 정리된 버전에 대한 코드펜입니다:\n\n여기 정리된 버전에 대한 전체 소스입니다:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Pixel perfect canvas</title>\n    <style>\n      html,\n      body {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        height: 100%;\n        margin: 0;\n        background-color: #887ecb;\n      }\n\n      .canvas-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        width: 100%;\n        height: 100%;\n      }\n\n      canvas {\n        background-color: #50459b;\n        max-width: 100%;\n        max-height: 100%;\n        image-rendering: pixelated;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"canvas-container\">\n      <canvas id=\"gameCanvas\" width=\"64\" height=\"36\"></canvas>\n    </div>\n    <script>\n      const INTEGER_SCALING = true;\n\n      const canvas = document.getElementById(\"gameCanvas\");\n      const ctx = canvas.getContext(\"2d\");\n\n      function createStar() {\n        const color = Math.floor(Math.random() * 256);\n        return {\n          x: Math.random() * canvas.width,\n          y: Math.random() * canvas.height,\n          color: color,\n          fillStyle: `rgb(${color}, ${color}, ${color})`,\n        };\n      }\n\n      const stars = Array.from({ length: 200 }, createStar).sort(\n        (a, b) => a.color - b.color\n      );\n\n      function resizeCanvas() {\n        let scale = Math.min(\n          window.innerWidth / canvas.width,\n          window.innerHeight / canvas.height\n        );\n        if (INTEGER_SCALING) {\n          scale = Math.floor(scale);\n        }\n        canvas.style.width = `${Math.round(scale * canvas.width)}px`;\n        canvas.style.height = `${Math.round(scale * canvas.height)}px`;\n      }\n\n      function drawRectangle(x, y, width, height, color) {\n        ctx.fillStyle = color;\n        ctx.fillRect(\n          Math.round(x),\n          Math.round(y),\n          Math.round(width),\n          Math.round(height)\n        );\n      }\n\n      function gameLoop(now) {\n        draw(now);\n        requestAnimationFrame(gameLoop);\n      }\n\n      function draw(t) {\n        drawRectangle(0, 0, canvas.width, canvas.height, \"#000\");\n\n        stars.forEach((star) => {\n          drawRectangle(star.x, star.y, 1, 1, star.fillStyle);\n          star.x = (star.x - star.color / 5000 + canvas.width) % canvas.width;\n        });\n        drawRectangle(\n          canvas.width / 4,\n          canvas.height / 4 + (canvas.width / 10) * Math.sin(t / 500),\n          canvas.width / 2,\n          canvas.height / 2,\n          \"#008\"\n        );\n        drawRectangle(\n          canvas.width / 2 + (canvas.width / 4) * Math.cos(t / 1000) - 4,\n          canvas.height / 2 + (canvas.height / 4) * Math.sin(t / 1000) - 4,\n          8,\n          8,\n          \"#00c\"\n        );\n      }\n\n      resizeCanvas();\n      window.addEventListener(\"resize\", resizeCanvas);\n      gameLoop();\n    </script>\n  </body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n이제 기초가 마련되었습니다 - 브라우저에서 픽셀 완벽한 그래픽을 애니메이트할 수 있는 코드 조각이 있습니다! 다음에는 몇 가지 스프라이트를 애니메이션화할 것입니다!","ogImage":{"url":"/assets/img/2024-06-20-HowtoCreatePixelPerfectGraphicsUsingHTML5Canvas_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoCreatePixelPerfectGraphicsUsingHTML5Canvas_0.png","tag":["Tech"],"readingTime":9},{"title":"환상적인 CSS 테두리 애니메이션","description":"","date":"2024-06-20 06:05","slug":"2024-06-20-FantasticCSSborderanimation","content":"\n\n오늘 나는 블로그 사이트인 shoptalkshow를 방문했는데, 그 사이트에서 다음과 같은 스타일을 보게 되어 정말 흥미로웠어요:\n\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_0.png\" />\n\n\n그 사이트의 스타일은 유니크하다고 생각되며, 특히 일부 베젤들이 돋보였어요.\n\n따라서, 이 글에서는 CSS를 사용하여 다양하고 멋진 테두리 효과를 만들어볼 거예요.\n\n<div class=\"content-ad\"></div>\n\n# CSS Border 속성\n\n테두리에 관한 이야기를 할 때, 가장 흔히 사용되는 속성은 solid와 dashed가 생각나는데, 위 그림에서는 dashed가 나타납니다.\n\n가장 일반적인 solid와 dashed 외에도, CSS 테두리는 none, hidden, dotted, double, groove, ridge, inset, outset 등 다른 스타일도 지원합니다. 모든 네이티브 지원 테두리 스타일을 보려면 none, hidden을 제거해주세요:\n\n![Fantastic CSS Border Animation](/assets/img/2024-06-20-FantasticCSSborderanimation_1.png)\n\n<div class=\"content-ad\"></div>\n\n이것들은 기본 사항들입니다. 다른 스타일의 테두리를 구현하거나 테두리에 애니메이션을 추가하려면 몇 가지 다른 속성과 협력하거나 마음을 열어야 합니다. 좋아요, 몇 가지 추가로 흥미로운 테두리를 살펴보겠습니다.\n\n# 테두리 길이 변경\n\n간단한 것부터 시작하여 다음과 같은 효과의 테두리를 얻는 방법을 살펴보겠습니다:\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n사실 이것은 두 가지 의사 요소가 요소를 빌려 사용하는 것입니다. 두 의사 요소의 상단 및 왼쪽 테두리, 아래쪽 및 오른쪽 테두리가 각각 설정되어 있으며, hover을 통해 두 가지 의사 요소의 높이와 너비를 변경할 수 있습니다. 이해하기 매우 쉽습니다.\n\n```js\ndiv {\n    position: relative;\n    border: 1px solid #03A9F3;\n    \n    &::before,\n    &::after {\n        content: \"\";\n        position: absolute;\n        width: 20px;\n        height: 20px;\n    }\n    \n    &::before {\n        top: -5px;\n        left: -5px;\n        border-top: 1px solid var(--borderColor);\n        border-left: 1px solid var(--borderColor);\n    }\n    \n    &::after {\n        right: -5px;\n        bottom: -5px;\n        border-bottom: 1px solid var(--borderColor);\n        border-right: 1px solid var(--borderColor);\n    }\n    \n    &:hover::before,\n    &:hover::after {\n        width: calc(100% + 9px);\n        height: calc(100% + 9px);\n    }\n}\n```\n\nCodePen Demo — 너비 테두리 애니메이션\n\n다음으로 난이도를 조금 더 심화해 볼 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# 점선 테두리 애니메이션\n\n`dashed` 키워드를 사용하여 쉽게 점선 테두리를 만들 수 있어요.\n\n```js\ndiv {\n    border: 1px dashed #333;\n}\n```\n\n![Fantastic CSS border animation](/assets/img/2024-06-20-FantasticCSSborderanimation_3.png)\n\n<div class=\"content-ad\"></div>\n\n물론, 테이블 태그를 마크다운 형식으로 변경하겠습니다.\n\n\n| 브라우저 | 지원 여부 |\n| ------- | --------- |\n| Chrome  | 예        |\n| Firefox | 예        |\n| Safari  | 예        |\n| Edge    | 예        |\n\n\n<div class=\"content-ad\"></div>\n\n그래디언트는 여러 개의 그래디언트를 지원해요. 우리는 모든 컨테이너의 네 면을 나타내기 위해 그래디언트를 사용할 수 있어요:\n\n```js\ndiv {\n    background: \n        linear-gradient(90deg, #333 50%, transparent 0) repeat-x,\n        linear-gradient(90deg, #333 50%, transparent 0) repeat-x,\n        linear-gradient(0deg, #333 50%, transparent 0) repeat-y,\n        linear-gradient(0deg, #333 50%, transparent 0) repeat-y;\n    background-size: 4px 1px, 4px 1px, 1px 4px, 1px 4px;\n    background-position: 0 0, 0 100%, 0 0, 100% 0;\n}\n```\n\n효과는 다음과 같아요:\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n좋아요, 지금까지 우리의 점선 테두리 애니메이션이 사실상 절반 이상 완료되었습니다. 애니메이션에서 border-style: dashed가 지원되지는 않지만 gradients는 지원됩니다. 우리는 hover 효과를 추가하고 animation을 추가할 때, 배경 위치를 변경할 수 있습니다.\n\n```js\ndiv:hover {\n    animation: linearGradientMove .3초 무한 선형;\n}\n\n@keyframes linearGradientMove {\n    100% {\n        background-position: 4px 0, -4px 100%, 0 -4px, 100% 4px;\n    }\n}\n```\n\n이제 효과를 보세요. hover가 발생할 때 테두리가 이동할 수 있습니다. 애니메이션 전체가 끝에서 끝으로 연결되어 있으므로 무한 루프 애니메이션은 항상 점선 테두리가 계속 이동하는 것처럼 보입니다. 이것은 작은 꼼수나 트릭입니다:\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_6.png\" />\n\n<div class=\"content-ad\"></div>\n\n여기 또 하나의 작은 꿀팁이 있어요. 만약 주어진 그림자 테두리 애니메이션을 다른 테두리에서 대시 테두리로 전환하고 싶은 경우, 애니메이션을 시뮬레이션하는 것이 가능해요. 예를 들어 다음과 같을 거예요:\n\n```js\ndiv {\n    border: 1px solid #333;\n\n    &:hover {\n        border: none;\n        background: \n            linear-gradient(90deg, #333 50%, transparent 0) repeat-x,\n            linear-gradient(90deg, #333 50%, transparent 0) repeat-x,\n            linear-gradient(0deg, #333 50%, transparent 0) repeat-y,\n            linear-gradient(0deg, #333 50%, transparent 0) repeat-y;\n        background-size: 4px 1px, 4px 1px, 1px 4px, 1px 4px;\n        background-position: 0 0, 0 100%, 0 0, 100% 0;\n    }\n}\n```\n\n박스 모델에서 테두리와 배경의 위치 차이로 인해 시각적인 정렬 오류가 발생할 수 있어요.\n\n![예시 이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_7.png)\n\n<div class=\"content-ad\"></div>\n\n위 문제를 해결하기 위해 테이블 태그를 마크다운 형식으로 변경할 수 있습니다. \n\n```js\ndiv {\n    outline: 1px solid #333;\n    outline-offset: -1px;\n    \n    &:hover {\n        outline: none;\n    }\n}\n```\n\n실제 버튼에 적용된 효과를 살펴보세요:\n\n![버튼 효과](/assets/img/2024-06-20-FantasticCSSborderanimation_8.png)\n\n<div class=\"content-ad\"></div>\n\n위 Demo의 전체 코드는 다음과 같습니다:\n\nCodePen 데모 - 대시 테두리 애니메이션\n\n# 그라데이션의 다른 멋진 사용법\n\n그라데이션을 사용하면 위의 효과뿐만 아니라 더 많은 효과를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그라데이션에 대해 자세히 들어가서 이러한 배경을 만들기 위해 그라데이션을 사용하고 있어요:\n\n```css\ndiv {\n    position: relative;\n\n    &::after {\n        content: '';\n        position: absolute;\n        left: -50%;\n        top: -50%;\n        width: 200%;\n        height: 200%;\n        background-repeat: no-repeat;\n        background-size: 50% 50%, 50% 50%;\n        background-position: 0 0, 100% 0, 100% 100%, 0 100%;\n        background-image: linear-gradient(#399953, #399953), linear-gradient(#fbb300, #fbb300), linear-gradient(#d53e33, #d53e33), linear-gradient(#377af5, #377af5);\n    }\n}\n```\n\n여기에서 요소의 가상 요소로 생성된 그래픽을 사용하고 있으며, 부모 요소의 너비와 높이는 200%이고, `overflow: hidden`으로 설정되어 있습니다.\n\n![FantasticCSSborderanimation_9](/assets/img/2024-06-20-FantasticCSSborderanimation_9.png)\n\n<div class=\"content-ad\"></div>\n\n다음으로, 그것에 회전을 추가해 보세요:\n\n```js\ndiv {\n    animation: rotate 4s linear infinite;\n}\n\n@keyframes rotate {\n    100% {\n        transform: rotate(1turn);\n    }\n}\n```\n\n효과를 확인해 보세요:\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_10.png\" />\n\n<div class=\"content-ad\"></div>\n\n마지막으로 가상 요소를 사용하여 중간 부분을 가리고 멋진 테두리 애니메이션이 나오게 할 수 있어요. (투명한 요소들이 애니메이션 속에서 나타나면, 원리를 이해하는 데 도움이 될 거예요):\n\n![gradient border animation](/assets/img/2024-06-20-FantasticCSSborderanimation_11.png)\n\n위 Demo의 완전한 코드는 다음과 같아요. 이 효과를 처음 본 곳은 이 저자 - Jesse B의 저자.\n\nCodePen Demo - 그라데이션 테두리 애니메이션\n\n<div class=\"content-ad\"></div>\n\n# 그라데이션 색상 변경\n\n위의 기본 기술을 익힌 후에는 그라데이션의 색상을 조정할 수 있습니다. 4가지 색상을 1가지 색상으로 변환할 것입니다:\n\n```js\ndiv::after {\n    content: '';\n    position: absolute;\n    left: -50%;\n    top: -50%;\n    width: 200%;\n    height: 200%;\n    background-color: #fff;\n    background-repeat: no-repeat;\n    background-size: 50% 50%;\n    background-position: 0 0;\n    background-image: linear-gradient(#399953, #399953);\n}\n```\n\n이와 같은 그래픽을 얻을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_12.png\" />\n\n다시 한 번 함께 돌려보고 단색 추격 테두리 애니메이션이 나옵니다:\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_13.png\" />\n\nCodePen 데모 - 그라데이션 테두리 애니메이션 2\n\n\n<div class=\"content-ad\"></div>\n\n와우, 정말 멋지네요. 그러나 한 줄인 경우 뚜렷한 결함이 있습니다. 즉, 테두리 끝이 작은 삼각형인 대신 수직인 경우가 있습니다. 이는 특정 시나리오에서 적용되지 않거나 PM이 이를 수용하지 않을 수 있습니다.\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_14.png\" />\n\n이러한 작은 삼각형을 제거할 방법이 있을까요? 네, 아래에서는 clip-path를 사용하여 이러한 작은 삼각형을 제거하는 다른 방법을 소개하겠습니다.\n\n# 코닉 그래디언트의 스마트한 사용\n\n<div class=\"content-ad\"></div>\n\n우리가 clip-path에 대해서 더 이상 진행하기 전에, 우선 각도 그라데이션에 대해 이야기해 봅시다.\n\n위에서 언급된 내용은 주로 선형 그라데이션인 linear-gradient에 사용됩니다. 실제로 conic-gradient도 사용할 수 있습니다.\n\n한 번 darker style로 conic-gradient을 시도해 보죠. 아래는 핵심 코드입니다:\n\n```js\n.conic {\n    position: relative;\n    \n    &::before {\n        content: '';\n        position: absolute;\n        left: -50%;\n        top: -50%;\n        width: 200%;\n        height: 200%;\n        background: conic-gradient(transparent, rgba(168, 239, 255, 1), transparent 30%);\n        animation: rotate 4s linear infinite;\n    }\n}\n@keyframes rotate {\n    100% {\n        transform: rotate(1turn);\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음은 렌더링 및 개요도입니다. 부분 각도 그라데이션을 사용하여 그래프를 회전하고, 다른 가상 요소를 사용하여 중간 부분을 마스킹하여 선 부분 만이 노출되도록합니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_15.png)\n\nCodePen 데모 - 회전 테두리 3\n\n# 클립 경로의 스마트한 사용\n\n<div class=\"content-ad\"></div>\n\n이전에 친한 친구 clip-path가 다시 나타났습니다. 재미있는 일은 결코 없을 것입니다.\n\nclip-path는 좌표점 자체를 애니메이션화하여 하나의 클리핑 모양에서 다른 클리핑 모양으로 변환할 수 있습니다.\n\n이 기능을 사용하여 테두리 따라오는 효과를 잘 구현할 수 있습니다. 의사 코드는 다음과 같습니다:\n\n```js\ndiv {\n    position: relative;\n\n    &::before {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        border: 2px solid gold;\n        animation: clippath 3s infinite linear;\n    }\n}\n\n@keyframes clippath {\n    0%,\n    100% {\n        clip-path: inset(0 0 95% 0);\n    }\n    25% {\n        clip-path: inset(0 95% 0 0);\n    }\n    50% {\n        clip-path: inset(95% 0 0 0);\n    }\n    75% {\n        clip-path: inset(0 0 0 95%);\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음은 스키매틱 다이어그램과 함께 렌더링 내용입니다:\n\n![FantasticCSSborderanimation_16](/assets/img/2024-06-20-FantasticCSSborderanimation_16.png)\n\nCodePen - 클립 패스 보더 애니메이션\n\n여기서는 요소가 클립된다는 점을 감안하고 가상 요소를 사용하여 클리핑 및 애니메이션용 배경으로 사용할 수 있습니다. clip-path를 사용하면 잘려진 보더가 작은 삼각형을 생성하지 않는다는 것을 기억해 주세요. 동시에 이 방법은 둥근 border-radius모서리도 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 다른 가상 요소를 사용하여 실제로 버튼 스타일을 구현한다면 다음과 같은 효과를 얻을 수 있습니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_17.png)\n\nCodePen — clip-path border animation 2\n\n# overflow의 스마트한 활용\n\n<div class=\"content-ad\"></div>\n\n다음 트릭은 오버플로우를 사용하여 구현되었습니다. 이러한 테두리 애니메이션을 구현해보세요:\n\n![border animation](/assets/img/2024-06-20-FantasticCSSborderanimation_18.png)\n\n왜 오버플로우로 구현했다고 말하는 건가요?\n\n도표를 붙여주세요:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_19.png\" />\n\nCodePen Demo — Using overflow and transform to achieve line hover effect\n\nTwo core points:\n\n- We use overflow: hiddento hide an entire element that was originally outside the container\n- used transform-origin, controls the center of rotation of the element\n\n\n<div class=\"content-ad\"></div>\n\n사실 흥미로운 CSS 효과 대부분이 비슷한 기술을 사용한다는 것을 발견했나요?\n\n간단히 말해, 우리가 보는 애니메이션은 원래 현상의 일부에 불과합니다. 특정한 잘라내기, 투명도 변경, 마스크 등을 통해 우리는 결국 원래 현상의 일부만을 보게 됩니다.\n\n# Border-image의 스마트한 활용\n\nborder-image를 사용하여 흥미로운 테두리 애니메이션도 구현할 수 있습니다. border-image에 대해 매우 좋은 설명글이 있습니다 -- border-image의 올바른 사용법, 이 글은 기본 정의에 대해 자세히 설명하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 이런 그래프가 있다면:\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_20.png\" />\n\n비슷한 테두리 패턴을 얻기 위해 다음과 같이 사용할 수 있습니다:\n\n```css\ndiv {\n  width: 200px;\n  height: 120px;\n  border: 24px solid;\n  border-image: url(image-url);\n  border-image-slice: 32;\n  border-image-repeat: round;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위와 같이 요소의 높이와 너비를 마음대로 변경할 수 있으므로, 컨테이너 테두리의 크기에 맞춰 확장할 수 있습니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_21.png)\n\n코드펜 데모 — border-image 데모\n\n그리고, 이 기사인 — border-image를 사용한 SVG 애니메이션 방법 에서도, 매우 멋진 효과를 낼 수 있는 border animation를 설명했었어요.\n\n<div class=\"content-ad\"></div>\n\n위 예제와의 차이점은 우리가 패턴을 움직이게 할 필요가 있다는 점입니다. 즉, 이러한 배경 이미지가 필요합니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_22.png)\n\n그럼, 우리도 움직이는 테두리 맵을 얻을 수 있습니다. 코드는 정확히 같지만, 테두리가 움직입니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_23.png)\n\n<div class=\"content-ad\"></div>\n\nCodePen 데모 — 춤추는 해골 테두리\n\n# border-image 및 그라데이션\n\nborder-image는 텍스처 참조 url에 추가하여 직접 색상 또는 그라데이션을 채울 수 있습니다.\n\nborder-image와 filter, clip-path를 사용하여 그라데이션 변환을 가진 둥근 테두리를 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n.border-image-clip-path {\n    width: 200px;\n    height: 100px;\n    border: 10px solid;\n    border-image: linear-gradient(45deg, gold, deeppink) 1;\n    clip-path: inset(0px round 10px);\n    animation: huerotate 6s infinite linear;\n    filter: hue-rotate(360deg);\n}\n\n@keyframes huerotate {\n    0% {\n        filter: hue-rotate(0deg);\n    }\n    100% {\n        filter: hue-rotate(360deg);\n    }\n}\n```\n\n<img src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_24.png\" />\n\n코드펜 데모 - clip-path, border-image 및 필터를 사용하여 둥근 그라데이션 테두리 구현하기\n\n# 마무리하기\n\n<div class=\"content-ad\"></div>\n\niCSS에 좀 더 멋진 CSS 기술 관련 문서들이 요약되어 있어요.\n\n그리고 아마도 제 CodePen을 좋아하실 거에요. 여기에는 놀라운 CSS 효과가 많아요.\n\n여튼, 이 기사는 여기까지입니다. 도움이 되길 바라요. :)","ogImage":{"url":"/assets/img/2024-06-20-FantasticCSSborderanimation_0.png"},"coverImage":"/assets/img/2024-06-20-FantasticCSSborderanimation_0.png","tag":["Tech"],"readingTime":12},{"title":"HTML의 마법을 해제하세요 멀티미디어, 수학 표현식, 그리고 고급 테이블 구조 통합하기","description":"","date":"2024-06-20 06:01","slug":"2024-06-20-UnlocktheMagicofHTMLIntegratingMultimediaMathematicalExpressionsandAdvancedTableStructures","content":"\n\n## 안녕하세요, 기술 열정가 분들! HTML의 멀티미디어, 수학 및 테이블 태그에 대한 흥미로운 그리고 유머 넘치는 안내서로 빠져들어보세요. 경험 많은 개발자이건 막 시작한 분이던, 웹 프로젝트를 향상시킬 팁과 트릭을 찾을 수 있습니다. 더 많은 흥미로운 콘텐츠를 위해 STATIC & FLOW를 팔로우하는 걸 잊지 마세요. 기술과 창의성을 결합한 콘텐츠를 제공합니다. 함께 웹 개발을 즐겁고 인터랙티브하게 만들어봐요!\n\n![Unlock the Magic of HTML](/assets/img/2024-06-20-UnlocktheMagicofHTMLIntegratingMultimediaMathematicalExpressionsandAdvancedTableStructures_0.png)\n\n생동감 넘치고 끊임없이 발전하는 웹 개발 세계에서 멀티미디어 콘텐츠는 생일 카드 위의 눈부신 빛과 같아요 — 모든 것을 더욱 흥미롭고 매력적으로 만들어줍니다! HTML, 우리의 신뢰할 수 있는 조수, 웹 페이지에 오디오 및 비디오 콘텐츠를 완벽하게 통합하는 다양한 멀티미디어 태그를 제공합니다. 마법 속으로 빠져들 준비가 됐나요? 유머와 개인적인 터치를 더해 멀티미디어 HTML 태그를 탐험해봅시다!\n\n![Unlock the Magic of HTML](/assets/img/2024-06-20-UnlocktheMagicofHTMLIntegratingMultimediaMathematicalExpressionsandAdvancedTableStructures_1.png)\n\n<div class=\"content-ad\"></div>\n\n# `audio` 태그\n\n웹 사이트를 탐색하다가 배경에서 가장 좋아하는 노래가 흘러나오는 모습을 상상해보세요 — 마법 같은 일이죠? `audio` 태그를 사용하면 오디오 콘텐츠를 웹페이지에 직접 포함시켜 이를 가능하게 할 수 있습니다. 이 태그는 src, controls, autoplay와 같은 속성을 가지며 오디오 플레이어의 기능을 사용자 정의할 수 있습니다. 아래는 간단한 예시입니다:\n\n```js\n<audio controls>\n  <source src=\"audio.mp3\" type=\"audio/mpeg\">\n  브라우저가 오디오 요소를 지원하지 않습니다.\n</audio>\n```\n\ncontrols 속성은 오디오 플레이어 인터페이스를 추가해주며, autoplay는 페이지가 로드될 때 오디오가 바로 재생되도록 합니다. 여러분의 즐겨듣는 곡으로 사용자를 세레나데하실 준비가 되셨나요?\n\n<div class=\"content-ad\"></div>\n\n# `video` 태그\n\n비디오가 라디오 스타를 죽였지만, 당신의 웹사이트를 슈퍼스타로 만들어 줄 수도 있어요! `video` 태그를 사용하면 비디오 콘텐츠를 쉽게 삽입할 수 있어요. `video` 요소 내에 `source` 태그를 사용함으로써 크로스 브라우저 호환성을 보장할 수 있어요. 사용 방법은 다음과 같아요:\n\n```js\n<video controls>\n  <source src=\"video.mp4\" type=\"video/mp4\">\n  비디오 태그를 지원하지 않는 브라우저입니다.\n</video>\n```\n\n컨트롤 속성을 추가하면 재생 컨트롤이 표시되어 사용자 친화적인 경험을 제공할 수 있어요. 불편함 없이 고양이 영상을 시청하는 모습을 상상해보세요—순수한 기쁨이죠!\n\n<div class=\"content-ad\"></div>\n\n# `source` 태그\n\n알려지지 않은 영웅, `source` 태그는 `audio` 및 `video` 요소의 미디어 리소스를 정의합니다. src 및 type과 같은 속성을 지원하여 특정 형식을 지원하지 않는 브라우저에 대비하여 여러 소스를 제공합니다. 멀티미디어 보험 같은 역할이죠!\n\n# `track` 태그\n\n접근성이 중요합니다! `track` 태그는 `audio` 및 `video` 요소에 시간별 텍스트 트랙(자막 또는 캡션)을 추가합니다. kind, src 및 srclang과 같은 속성을 통해 멀티미디어 콘텐츠에 대한 접근성 및 로컬라이제이션 옵션을 제공할 수 있습니다. 이제 모든 사람이 언어나 청각 능력에 관계없이 콘텐츠를 즐길 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# `canvas` 태그\n\n여기서 예술적으로 변화가 시작됩니다 — `canvas` 태그는 그래픽, 애니메이션 또는 다른 시각적 요소를 동적으로 렌더링할 수 있는 HTML 내에서 그림을 그릴 수 있는 영역을 제공합니다. 자바스크립트는 여러분의 붓이고, `canvas` 요소는 여러분의 캔버스입니다. 내면의 피카소를 발휘할 준비가 되셨나요?\n\n이러한 멀티미디어 HTML 태그들을 효과적으로 활용하여 개발자들은 사용자들을 사로잡고 관여시키는 웹 경험을 만들어낼 수 있습니다. 자, 여러분의 프로젝트에서 이러한 태그들을 실험해보세요. 여러분의 콘텐츠가 생동감을 띠고 살아나는 것을 보실 거에요!\n\n# HTML에서 수학 식표현\n\n<div class=\"content-ad\"></div>\n\n숫자와 수식은 어렵게 느껴질 수 있지만 HTML의 `math` 태그를 사용하면 웹페이지에 수학 식을 쉽게 삽입할 수 있습니다. 교육 웹사이트, 과학 문서 또는 수학적 명확성을 필요로 하는 모든 콘텐츠에 완벽하게 어울리는 `math` 태그는 게임 체인저입니다. 몇 가지 실용적인 예제로 자세히 살펴보겠습니다.\n\n## 문법과 속성\n\n`math` 태그는 HTML 문서의 본문 내에서 사용되는 인라인 요소로써 수학적 콘텐츠를 표시하는 데 사용됩니다. 주요 속성은 다음과 같습니다:\n\n- display: 수학 표현이 인라인 또는 블록으로 표시되어야 하는지를 지정합니다.\n- xmlns: MathML (Mathematical Markup Language) 콘텐츠의 네임스페이스를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n# 실용적인 응용\n\n## 예제 1: 간단한 수학식\n\nMathML을 사용하여 \"a + b\"를 표시하는 방법은 다음과 같습니다. `math` 태그 내에서:\n\n```js\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <mrow>\n        <mi>a</mi>\n        <mo>+</mo>\n        <mi>b</mi>\n    </mrow>\n</math>\n```\n\n<div class=\"content-ad\"></div>\n\n## 예제 2: 제곱과 아래 첨자가 포함된 복잡한 방정식\n\n“x² + y₂”와 같은 보다 복잡한 방정식을 다룰 때는 다음과 같이 사용하세요:\n\n```js\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <mrow>\n        <msup>\n            <mi>x</mi>\n            <mn>2</mn>\n        </msup>\n        <mo>+</mo>\n        <msub>\n            <mi>y</mi>\n            <mn>2</mn>\n        </msub>\n    </mrow>\n</math>\n```\n\n수학적 개념과 공식을 보다 상호작용적으로 제시함으로써 교육 웹사이트나 온라인 강좌가 크게 이점을 얻을 수 있습니다. 여러분의 웹사이트 내 수학적 콘텐츠의 품질을 높이기 위해 이 태그를 활용해 보세요.\n\n<div class=\"content-ad\"></div>\n\n# HTML 테이블의 구조 요소\n\n테이블 - 사랑하든 싫어하든, 웹 페이지에서 데이터를 일관되게 표현하는 데 필수적입니다. HTML은 테이블의 접근성과 미학을 향상시키기 위한 다양한 구조 요소를 제공합니다. 주요 구성 요소를 살펴보겠습니다.\n\n# `table` 태그\n\n`table` 태그는 HTML에서 테이블을 만드는 데 필수적인 기반 요소입니다. 모든 다른 테이블 요소를 포함합니다. 더 나은 구성과 의미론적으로 `thead`, `tbody`, `tfoot`와 같은 섹션을 포함시키세요.\n\n<div class=\"content-ad\"></div>\n\n# `caption` 태그\n\n`caption` 태그를 추가하면 표에 제목이나 설명을 제공하여 맥락과 명확성을 높일 수 있습니다. 이는 특히 접근성에 유용하며, 화면 낭독기 사용자가 표의 목적을 이해하는 데 도움이 됩니다.\n\n# `colgroup` 및 `col` 태그\n\n이 태그들은 열 그룹 및 개별 열 속성을 정의합니다. 이를 사용하여 특정 열을 일관되게 스타일링하고 서식을 지정하여 표를 시각적으로 매력적으로 만들고 관리하기 쉽게 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# `thead`, `tbody`, `tfoot` 태그\n\n- `thead`: 헤더 행을 그룹화합니다.\n- `tbody`: 주요 데이터 행을 포함합니다.\n- `tfoot`: 요약이나 메타데이터를 위한 푸터 섹션을 정의합니다.\n\n다음은 예시입니다:\n\n```js\n| Product    | Sales  |\n|------------|--------|\n| Product A  | $1000  |\n| Product B  | $1500  |\n```\n\n<div class=\"content-ad\"></div>\n\n이러한 요소를 활용하여 잘 구성된 시각적으로 매력적인 테이블을 만들 수 있어요. 프로젝트에서 시도하여 데이터 표현력을 향상시키는 방법을 확인해보세요.\n\n![테이블 이미지](/assets/img/2024-06-20-UnlocktheMagicofHTMLIntegratingMultimediaMathematicalExpressionsandAdvancedTableStructures_2.png)\n\n# 실용적인 연습 및 사용 사례 시나리오\n\n이제 다양한 대화형 및 미디어 HTML 태그에 익숙해졌으니, 여러분의 지식을 실전에 적용해보는 시간이에요. 다음은 여러분의 기술을 향상시키는 데 도움이 되는 연습과 시나리오입니다:\n\n<div class=\"content-ad\"></div>\n\n# 운동 1: 이미지 맵 구현\n\n시나리오: 여행사 웹사이트를 만들고 인기 있는 여행지의 상호작용하는 지도를 만들고 싶습니다. 작업: `map` 및 `area` 태그를 사용하여 서로 다른 지역을 나타내는 이미지에서 클릭 가능한 영역을 만들고, 각 영역을 특정 목적지 페이지에 연결합니다.\n\n# 운동 2: 반응형 이미지 디스플레이\n\n시나리오: 포트폴리오 웹사이트를 디자인하고 반응형 이미지로 작업물을 쇼케이스하고 싶습니다. 작업: `picture` 태그를 활용하여 다른 화면 크기에 따라 이미지에 대한 여러 소스를 제공합니다. 브라우저 창을 조절하여 반응성을 테스트해보세요.\n\n<div class=\"content-ad\"></div>\n\n# Exercise 3: Embedding Multimedia Content\n\n상황: 온라인 강좌 플랫폼을 개발 중이며 비디오 강의를 삽입해야 합니다. 작업: `video` 태그를 사용하여 재생 컨트롤이 있는 비디오 파일을 삽입하십시오. 사용자 경험을 향상시키기 위해 controls와 autoplay와 같은 속성을 실험해보세요.\n\n# Use Case Scenario: 교육 수학 웹사이트\n\n상황: 복잡한 방정식으로 학생들을 도와주는 수학 과외 서비스를 위한 웹사이트를 구축 중입니다. 작업: `math` 태그를 활용하여 수학적 표현과 방정식을 올바른 표기법과 함께 표시하십시오. 학생들이 참여하고 학습을 용이하게하기 위해 대화형 예제를 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n# Exercise 4: 오디오 통합\n\n시나리오: 음악 블로그를 전면 개편하고 음악 리뷰에 오디오 샘플을 추가하려고 합니다. 작업: `audio` 태그를 사용하여 재생 컨트롤이 있는 오디오 클립을 임베드하십시오. controls 및 autoplay와 같은 속성을 사용하여 오디오 플레이어를 사용자 정의하십시오.\n\n# Exercise 5: 테이블 구조 향상\n\n시나리오: 연구 기관을 위한 데이터 기반 웹사이트를 조직하고 연구 결과를 테이블로 제시해야 합니다. 작업: `colgroup`, `col`, `caption` 태그를 포함하여 테이블 구조를 향상시키십시오. 더 나은 조직화와 시각적 매력을 위해 열 스타일링을 실험하여 가독성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n이 연습에 참여하면 HTML 태그에 대한 지식을 더욱 확고히 할 뿐만 아니라 실제 프로젝트에 적용하는 경험도 얻게 됩니다. 이러한 작업에 뛰어들어 HTML의 모든 가능성을 펼쳐보세요.\n\n그래서, 이 연습에 대해 어떻게 생각하시나요? 웹 개발 기술을 더욱 향상시키기에 준비가 되셨나요? 코딩을 시작하고 함께 재미를 느껴봅시다!\n\nPART 17 끝!\n\n![이미지](/assets/img/2024-06-20-UnlocktheMagicofHTMLIntegratingMultimediaMathematicalExpressionsandAdvancedTableStructures_3.png)\n\n<div class=\"content-ad\"></div>\n\n# 퀴즈\n\n## 1. `audio` 태그에서 오디오 플레이어 인터페이스를 추가하는 데 사용되는 속성은 무엇인가요?\n\nA) autoplay  \nB) controls  \nC) src  \nD) type  \n\n## 2. 수학 표현 및 표기를 웹페이지에 직접 임베드하는 데 사용되는 HTML 태그는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nA) `수학`\nB) `스크립트`\nC) `수식`\nD) `방정식`\n\n## 3. 멀티미디어 HTML 요소에서 `track` 태그의 주요 목적은 무엇입니까?\n\nA) 미디어 자원 정의\nB) 자막 추가\nC) 오디오 콘텐츠 임베드\nD) 재생 속도 제어\n\n## 4. 다음 중 HTML 테이블에서 열 그룹을 정의하는 데 사용되는 태그는 무엇입니까?\n\n<div class=\"content-ad\"></div>\n\nA) `thead`\nB) `tbody`\nC) `tfoot`\nD) `colgroup`\n\n## 5. `math` 태그의 속성 중 수학 표현이 인라인으로 표시되어야 하는지 또는 블록 요소로 표시되어야 하는지를 지정하는 것은 무엇입니까?\n\nA) xmlns\nB) display\nC) type\nD) src","ogImage":{"url":"/assets/img/2024-06-20-UnlocktheMagicofHTMLIntegratingMultimediaMathematicalExpressionsandAdvancedTableStructures_0.png"},"coverImage":"/assets/img/2024-06-20-UnlocktheMagicofHTMLIntegratingMultimediaMathematicalExpressionsandAdvancedTableStructures_0.png","tag":["Tech"],"readingTime":7},{"title":"부모 요소를 벗어나는 플렉스 자식 요소 크기 조절 방법","description":"","date":"2024-06-20 06:00","slug":"2024-06-20-Preventflexchildfromgrowingoutofparent","content":"\n\n부모 요소 내에 맞춰 콘텐츠 크기를 줄이고 싶어요.\n\n콘텐츠(이 경우 비디오)는 축소되어 스크롤 막대가 허용되어야 합니다.\n\n정적 높이 값을 설정하지 않고 절대 위치를 지정하지 않고, 녹색 상자가 빨간 상자 내에 포함되도록 어떻게 해야 할까요?\n\n![이미지](/assets/img/2024-06-20-Preventflexchildfromgrowingoutofparent_0.png)\n\n<div class=\"content-ad\"></div>\n\n```js\n.my-box {\n  height: 300px;\n  width: 600px;\n  background: red;\n  padding: 5px;\n}\n.content-box {\n  background: blue;\n}\n.col {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between\n}\n.box-shrink {\n  flex: 0 1 auto;\n  background: green;\n  padding: 5px;\n  margin: 5px;\n}\n.box-grow {\n  flex: 1;\n  background: green;\n  padding: 5px;\n  margin: 5px;\n}\nvideo {\n  max-height: 100%;\n  max-width: 100%;\n  margin: auto;\n  display: block;\n}\n```\n\n```js\n<div class=\"my-box col\">\n  <div class=\"box-shrink\">\n    작은 크기의 정적 콘텐츠\n  </div>\n  <div class=\"content-box box-grow\">\n    <video controls>\n      <source src=\"http://techslides.com/demos/sample-videos/small.webm\" type=\"video/webm\">\n    </video>\n  </div>\n  <div class=\"box-shrink\">\n    작은 크기의 정적 콘텐츠\n  </div>\n</div>\n```\n\n# 해결책 #1 — 스크롤 없이\n\n비디오 컨테이너의 flex: 1 0 auto 대신에 flex: 1을 사용하십시오. 이는 항목을 내용의 내재 높이가 아닌 사용 가능한 공간에 기반하여 크기를 결정합니다.\n\n<div class=\"content-ad\"></div>\n\n그러면 flex 항목은 내용보다 작아질 수 없습니다. min-height: auto는 기본값이므로 min-height: 0을 추가하여 항목이 컨테이너 내에 들어갈 수 있도록 합니다.\n\n```js\n.box-grow {\n  flex: 1; /* 이전에는 flex: 1 0 auto; */\n  background: green;\n  padding: 5px;\n  margin: 5px;\n  min-height: 0; /* 새로운 속성 */\n}\n```\n\n# 해결책 #2 — 스크롤 기능 추가\n\n또는 비디오 컨테이너에 overflow: auto를 지정하여 위와 동일한 효과를 얻을 수 있지만 비디오를 전체 너비로 유지합니다. 이 기능을 활성화하려면 flex-shrink를 활성화해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n.box-grow {\n  flex: 1 1 auto; /* 이전에는 flex: 1 0 auto; 였습니다. */\n  background: green;\n  padding: 5px;\n  margin: 5px;\n  overflow: auto; /* 새로 추가된 스타일 */\n}\n```\n\n# 해결책 #3\n\n컨텐츠(이 경우 비디오)가 줄어들 수 있고 스크롤바가 허용되는 경우입니다. .box-grow 클래스에 overflow:auto;를 적용하고 flex-shrink: 1;를 설정해보는 것은 어떨까요? flex: 1 1 auto;와 같이 설정하면 됩니다. 또는 flex: 1 1 100%;로 설정하면 비디오가 .box-grow 클래스가 중앙에 맞게 표시되며, overflow:auto도 필요합니다.\n\n```js\n.my-box {\n    height: 300px;\n    width: 600px;\n    background: red;\n    padding: 5px;\n}\n\n.content-box {\n    background: blue;\n}\n\n.col {\n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n}\n\n.box-shrink {\n    flex: 0 1 auto;\n    background: green;\n    padding: 5px;\n    margin: 5px;\n}\n\n.box-grow {\n    flex: 1 1 auto;  /* 기본값인 shrink 1로 설정합니다. */\n    background: green;\n    padding: 5px;\n    margin: 5px;\n    overflow:auto; /* flex:1 1 100%로 설정하면 overflow가 필요합니다. */\n}\n\nvideo {\n    max-height: 100%;\n    max-width: 100%;\n    margin: auto;\n    display: block;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n<div class=\"my-box col\">\n    <div class=\"box-shrink\">\n        작은 크기의 정적 콘텐츠\n    </div>\n    <div class=\"content-box box-grow\">\n        <video controls>\n            <source src=\"http://techslides.com/demos/sample-videos/small.webm\" type=\"video/webm\">\n        </video>\n    </div>\n    <div class=\"box-shrink\">\n        작은 크기의 정적 콘텐츠\n    </div>\n</div>\r\n```\n\n# 왜 플렉스 아이템이 콘텐츠 크기 아래로 줄어들지 않을까요?\n\n## 플렉스 아이템의 자동 최소 크기\n\n이는 플렉스박스의 기본 설정으로 인한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n주축을 따라 플렉스 항목은 콘텐츠의 크기보다 작을 수 없어요.\n\n기본값은...\n\n- min-width: auto\n- min-height: auto\n\n...행 방향 및 열 방향의 플렉스 항목에 대해 각각 적용돼요.\n\n<div class=\"content-ad\"></div>\n\n여러분은 flex 항목을 다음과 같이 설정하여 기본값을 재정의할 수 있어요:\n\n- min-width: 0\n- min-height: 0\n- overflow: hidden (또는 다른 값, visible을 제외한)\n\n# Flexbox 명세\n\nauto 값에 대해서는...\n\n<div class=\"content-ad\"></div>\n\n다시 말해:\n\n- min-width: auto 및 min-height: auto 기본값은 오버플로우가 visible로 설정된 경우에만 적용됩니다.\n- 만약 오버플로우 값이 visible이 아닌 경우 min-size 속성의 값은 0이 됩니다.\n- 따라서 overflow: hidden은 min-width: 0 및 min-height: 0의 대안이 될 수 있습니다.\n\n그리고...\n\n- 최소 크기 조정 알고리즘은 주요 축에만 적용됩니다.\n- 예를 들어, 행 방향 컨테이너 내의 플렉스 항목은 기본적으로 min-height: auto를 적용받지 않습니다.\n- 보다 자세한 설명은 다음 게시물을 참조하세요:\n- flex-direction: row 및 flex-direction: column일 때 min-width가 다르게 렌더링됨\n\n<div class=\"content-ad\"></div>\n\n# 브라우저 렌더링 참고 사항\n\n- Chrome 대 Firefox / Edge\n적어도 2017년 이후로 Chrome은 min-width: 0 / min-height: 0 기본값으로 되돌아가거나(1) 특정 상황에서 신비한 알고리즘을 기반으로 0 기본값을 자동으로 적용하는 것으로 보입니다. (이를 개입(intervention)이라고도 할 수 있습니다.) 결과적으로 많은 사람들이 Chrome에서는 레이아웃(특히 원하는 스크롤 바)이 예상대로 작동하지만 Firefox / Edge에서는 그렇지 않다는 것을 알 수 있습니다. 이 문제에 대한 자세한 내용은 여기에서 다루고 있습니다: Firefox와 Chrome 사이의 flex-shrink 불일치\r\n- IE11\n명세서에 명시된 대로, min-width 및 min-height 속성의 auto 값은 \"new\"입니다. 이는 일부 브라우저가 아직 최신값을 적용하지 않을 수 있음을 의미합니다. 왜냐하면 일부 브라우저는 flex 레이아웃을 업데이트하기 전에 구현했기 때문에 CSS 2.1에서 min-width 및 min-height의 초기값이 0이었기 때문입니다. IE11와 같은 브라우저가 해당됩니다. 다른 브라우저들은 flexbox 명세에 정의된 최신 auto 값으로 업데이트되었습니다.","ogImage":{"url":"/assets/img/2024-06-20-Preventflexchildfromgrowingoutofparent_0.png"},"coverImage":"/assets/img/2024-06-20-Preventflexchildfromgrowingoutofparent_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트를 사용하여 동적으로 생성된 HTML - 그룹 프로젝트를 활용한 빠른 데모","description":"","date":"2024-06-20 05:59","slug":"2024-06-20-DynamicallycreatedHTMLusingJavaScriptAquickdemousingagroupproject","content":"\n\nJavaScript를 사용하여 HTML 요소를 동적으로 생성하는 것은 당신이 생각하는 것보다 복잡하지 않아요! 중요한 기본 원칙을 기억하면 괜찮아요! 사용자 상호작용 후 페이지 내용이 변경되어야 하는 모든 애플리케이션에는 어떠한 형태의 동적 요소 조작이 필요해요. 여기서는 특히 요소 생성과 \"제거\" (불완전한 용어로)에 초점을 맞출 거예요.\n\n# 이것을 배워야 하는 이유는?\n\nHTML은 현재 페이지에 있는 내용의 청사진 역할을 할 것이지만, 만약 당신이 그 내용을 버튼을 누르면 변경하고 싶다면 어떻게 할 건가요? 또는 입력을 제출한 후, 입력에 따라 응용 프로그램이 다양한 결과를 반환하길 원한다면 어떡해야 할까요? 최근에 기여한 프로젝트를 예로 들 수 있겠어요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*czD6QBwXt7Oh69m8JXMcvA.gif)\n\n<div class=\"content-ad\"></div>\n\n요 동적 \"주요 칵테일 카드\"를 생성하기 위해서 필요한 JavaScript 함수는 실제로 한 가지뿐입니다: element.append().\n\n```js\n<section id=\"featured-cocktail\" class=\"is-flex-direction-column card py-5 mt-2\" style=\"background-color: var(--secondary); color: var(--dark-text)\">\n</section>\n```\n\n```js\nconst featuredCocktailCard = $('#featured-cocktail');\n// ...\nfeaturedCocktailCard.append(content)\n```\n\n![이미지](/assets/img/2024-06-20-DynamicallycreatedHTMLusingJavaScriptAquickdemousingagroupproject_0.png)\n\n<div class=\"content-ad\"></div>\n\n\"featuredCocktailCard.append()\" 함수 핸들이 호출되면, 괄호 안에 추가된 내용은 선택된 요소(즉, 객체의 이름이 지정된 요소)에 HTML 문서에 삽입됩니다. 이후에는 JavaScript로 작성된 코드지만 HTML 구문과 용어를 따를 것입니다.\n\n```js\nfeaturedCocktailCard.empty().append(`\n          <h3 class=\"is-size-1 card-header-title is-centered\">${toTitleCase(cocktailName)}</h3>\n          <div id=\"featuredCocktailSection\" class=\"is-flex is-justify-content-center\">\n            <div class=\"columns card-image\">`)\n```\n\n스크린샷에 캡쳐된 코드 양은 기술적으로 페이지에 추가할 수 있는 HTML의 제한이 없다는 것을 보여줍니다. 그러나, 발생하는 동적 요소 생성을 가능한 경우 여러 함수로 분리하여 더 잘 관리하는 것이 좋습니다. 게다가, 위에서 \"append(...)\" 앞에 \".empty()\"도 있는 것을 알 수 있습니다. \".empty()\"는 특징있는 칵테일 카드 ID 내의 모든 요소를 제거하지만, 이를 따라오는 \".append\"는 그 후에 콘텐츠를 다시 교체할 것입니다(이 경우 반복 때문에 다른 입력 세트로).\n\n동적 HTML 내에서 사이즈 및 정렬/정렬에 대한 클래스 및 ID 선언이 있음에 유의하십시오. 해당 용어를 알아보셨나요? 요소를 추가하거나 제거하지 않더라도 이것은 알아두어야 할 중요한 옵션입니다: 이제 CSS를 사용하여 동적 요소 조작에 참여할 수 있습니다. HTML을 변경하여 외관을 완전히 변경할 수 있는 새로운 특성 집합을 수용하도록 변경할 수 있습니다!","ogImage":{"url":"/assets/img/2024-06-20-DynamicallycreatedHTMLusingJavaScriptAquickdemousingagroupproject_0.png"},"coverImage":"/assets/img/2024-06-20-DynamicallycreatedHTMLusingJavaScriptAquickdemousingagroupproject_0.png","tag":["Tech"],"readingTime":2}],"page":"32","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}