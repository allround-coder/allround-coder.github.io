{"pageProps":{"posts":[{"title":"자바스크립트 버그 바운티 20 익스트림 에디션 2024","description":"","date":"2024-06-19 22:41","slug":"2024-06-19-JSforBugBounties20ExtremeEdition2024","content":"\n\n안녕하세요 여러분,\n\n인도 출신 Aditya Shende로 알려진 Kongsec입니다. 저는 바운티 헌터, 바이커, 연구원 및 트레이너입니다. 지난 5년 동안 버그 바운티에서 사람들을 교육하고 기사를 읽었을 때 항상 틈새를 발견했습니다. 무엇을 악용했는지와 어떻게 악용했는지를 공유하는 것은 매우 다릅니다. 많은 연구원들이 어떤 취약점을 악용했는지 공유하지만 어떻게 이러한 것들을 대규모로 찾을 수 있는 방법은 아직 숨겨져 있습니다.\n\n이 기사가 사람들이 버그를 더 많이 집중하는 대신 더 많은 기술을 공유하도록 영감을 주기를 바랍니다. 물을 불 지피자 🔥\n\n이 기사는 특별 기사를 위해 완전히 업그레이드된 버전입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_0.png\" />\n\n안녕하세요! 아래와 같이 다양한 도구를 사용하여 점프할 수 있어요:\n\n- hakrawler — 쉽고 빠른 웹 크롤러로, 웹 애플리케이션 내의 엔드포인트와 에셋을 빠르게 발견할 수 있어요.\n- crawley — 고랭로 작성된 빠르고 기능 풍부한 유닉스 스타일 웹 스크래퍼/크롤러에요.\n- katana — 차세대 크롤링 및 스파이더링 프레임워크에요.\n- LinkFinder — JavaScript 파일에서 엔드포인트를 찾아주는 파이썬 스크립트에요.\n- JS-Scan — php로 제작된 .js 스캐너로, URL 및 다른 정보를 크롤링하는데 사용돼요.\n- LinksDumper — 응답에서 (링크/가능한 엔드포인트)를 추출하고 디코딩/정렬을 통해 필터링하는데 사용돼요.\n- GoLinkFinder — 빠르고 간단한 JS 엔드포인트 추출기에요.\n- BurpJSLinkFinder — 엔드포인트 링크를 패시브 스캔하는 Burp Extension에요.\n- urlgrab — 웹사이트를 스패이더링하여 추가 링크를 찾는 고랭 유틸리티에요.\n- waybackurls — 도메인에 대해 Wayback Machine이 알고 있는 모든 URL을 가져와요.\n- gau — AlienVault의 Open Threat Exchange, Wayback Machine 및 Common Crawl에서 알려진 URL을 가져와요.\n- getJS — 모든 자바스크립트 소스/파일을 빠르게 가져오는 도구에요.\n- linx — JavaScript 파일 내에 숨겨진 링크를 드러내는데 사용돼요.\n- waymore — Wayback Machine에서 더 많은 정보를 찾기 위한 도구에요.\n- xnLinkFinder — 특정 대상에 대한 엔드포인트, 잠재적 매개변수 및 대상별 워드리스트를 찾는 데 사용되는 파이썬 도구에요.\n\n하지만 다른 사용자와 같은 파일을 받고 있어요. 중복되는 결과를 생성하고 있어요.\n\n<div class=\"content-ad\"></div>\n\n초기 발견 내용은 다음과 같았어요\n\n하지만 만약에 이 단어들을 대상 도메인에 대한 무차별 대입(bruteforce)해본다면 어떨까요? 아니면 당신이 추적 중인 어떤 대상에 대해서도요.\n\n여기 테스트를 위해 수집한 기본 단어 목록이 있어요:\n\ndialogs540f334e628dbce748a8js navigation_secondary55dfd8fe215f8edecd48js dialogsb18150a252f68f70f0c9js navigation_secondary147987372ed67d94de50js buttons147987372ed67d94de50jsnpmangular-animate8f9be52ce8a521f715a3js mainb18150a252f68f70f0c9js navigation7b5ba7de4b5e5fb011c7js dialogs147987372ed67d94de50js appmain7b5ba7de4b5e5fb011c7js main147987372ed67d94de50js buttons7b5ba7de4b5e5fb011c7jsnpmangulary-focus-store9327d7778ee0d85c3500js mainfb562f3396222d196abfjs breeze7b5ba7de4b5e5fb011c7js breezeb18150a252f68f70f0c9js breeze30886581e43164d9d721js breeze147987372ed67d94de50js navigationb18150a252f68f70f0c9js appmain147987372ed67d94de50js breezeee32c0b1526644e9b562js main7b5ba7de4b5e5fb011c7js dialogs7b5ba7de4b5e5fb011c7js navigationba64bbac173b1d655721js navigation147987372ed67d94de50js navigation_secondaryb18150a252f68f70f0c9js buttonscf9c75fee1de19837ae7js appmainb18150a252f68f70f0c9js navigation_secondary7b5ba7de4b5e5fb011c7js modalsb0f4a82ac6f25a46dc71js npmangular-ui-calendar423a597b943dc586730dns npmapollo-angular-link-httpe7a942f9925da8411a4ejsnpmangular-ui-switch90766204ecd17b03ca76js appmainaf9ea97e6139d8cd52c2js npmapollo-angular-link-http-common87eff82eb4bc194887bfjs npmapollo-angular22f1de8a666515c86242js npmapollo-cache53668769616dc1466d8js npmapollo-cache-inmemorydaeb4f1b88a15680fd12js buttonsb18150a252f68f70f0c9js npmangular-ui-bootstrapcd3d849d20f1a4f7dfacjs configjs npmattr-accept81d56f5e133bac14feb5js npmapollo-clientf1fffac92f44507c8f3ajs npmbase64-js61d2367f7816d6fec60fjs npmapollo-utilities9e092209349bda108468js npmaxiosb02cc1c0e336b6ce9d09js app147987372ed67d94de50js npmauth0b681a646eef51d083006js npmbraintree24d4f13fb9a355dadc24js npmbabel5fd8b43fabbd6864e9a2js npmcall-bind0f09a0bd48e4dac9d679js npmbreeze-client-labs03a64fb13d406c33bbc8js appaf9ea97e6139d8cd52c2js npmavailable-typed-arrays558d90654f4d4fc2aa04js npmcharacter-entities-legacy7f4022465f0c9c4a6fabjs npmblueimp-load-image3d0d2393c631d92c5a1ejs npmchartjs-color-stringbd3a54729bf6f60404afjs npmapollo-linka5d82a3252db6d3e8d15jsnpmaria-hiddena316c352eb617c047815js npmckeditorfde05d6a29366eaf2c71js npmcollapse-white-spacebdd075f4c3faca5c940fjs npmcharacter-reference-invalid2f9cdaeeea24c3f3897ejs npmbail2e238f58e0858fcf0e31js npmcolor-convert101a98cb8d9df306dc12js npmchartjs-color703b6867120bd9ebf784js npmbreeze-client75c1a11b2c8e46de7ce4js\n\n<div class=\"content-ad\"></div>\n\n위의 명령어를 사용하여 새로운 대상에 대한 단어 목록을 사용할 수 있습니다.\n\n하는 방법은 다음과 같습니다:\n\nwaybackurls \"site.com\" | grep -Eo 'https?://[^/]+/[^\"]+\\.js' | sed 's|^https\\?://[^/]\\+/||' | awk -F '/' 'print $NF'\n\n\n명령어의 각 부분을 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n- waybackurls \"example.com\": 해당 명령어는 Wayback Machine 아카이브에서 \"example.com\"과 관련된 URL을 검색합니다.\n- grep -Eo `https?://[^/]+/[^\"]+\\.js`: 이 명령어는 .js 확장자를 가진 URL을 검색합니다. -E 플래그는 확장 정규 표현식을 활성화하고, -o 플래그는 grep이 일치하는 부분만 출력하도록 지시합니다.\n- sed `s|^https\\?://[^/]\\+/||`: 이 몤령어는 각 URL에서 프로토콜(http:// 또는 https://)과 도메인 이름을 제거하고 경로만 남깁니다.\n- awk -F `/` `'print $NF'`: 이 명령어는 URL을 /로 분할한 뒤 각 URL의 마지막 부분을 추출하여 도메인 부분을 제거합니다.\n\n따라서, 이 명령어를 실행하면 도메인 이름을 제외한 아카이브 스냅샷에서 추출된 .js 엔드포인트 목록이 제공됩니다. \"site.com\"을 원하는 도메인으로 대체하십시오. \n\n![2024-06-19-JSforBugBounties20ExtremeEdition2024_1](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_1.png)\n\n![2024-06-19-JSforBugBounties20ExtremeEdition2024_2](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_2.png)\n\n<div class=\"content-ad\"></div>\n\n일부 키워드가 새롭고 독특하다는 것을 확인할 수 있어요. 하나의 대상에서 JS 단어 목록을 정리하고 이를 새로운 대상에 활용할 수 있어요. 예를 들어,\n\n우리는 dell.com에서 JS 단어를 얻어서 data.samsung.com에서 사용했어요. 새로운 파일들, 스택 오류, 디렉터리 목록에 유용할 거예요.\n\n![JSforBugBounties20ExtremeEdition2024](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_3.png)\n\n우리는 최종적으로 새로운 대상에서 매우 새로운 JS 파일들을 얻을 수 있어요. 크기, 데이터 유형, 내용 등을 기준으로 정렬할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n동일한 키워드를 쇼단에서 얻은 IP에 적용할 수 있습니다.\n\n![이미지1](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_4.png)\n\n![이미지2](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_5.png)\n\n나머지 공격은 마찬가지지만 작은 수정점이 있습니다.\n\n<div class=\"content-ad\"></div>\n\ncurl -s https://app.site.com/config.js |\ngrep -E “environment: ‘Production’|storageUrl: ‘https://buildxact.blob.core.windows.net/’|googleApiKey: ‘|appInsightsInstrumentationKey: ‘|globalApiEndpoint: ‘|streamChatApiKey: ‘|auth0ClientId: ‘|auth0Domain: ‘|flatfileApiKey: ‘|webSpellCheckerServiceId: ‘|webSpellCheckerServiceUrl: ‘|clientPortalUrl: ‘|appVersion: ‘|appVersionDate: ‘|appDomainUrl: ‘|oneBuildKey: ‘|flatfilePlatformPublishableKey: ‘|flatfilePlatformEnvironmentId: ‘“ |\nsed “s/.*’\\([^']*\\)’.*/\\1/”\n\n\nWe can add the words which we think are sensitive here:\n\nExample:\n\n\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식의 표입니다.\n\n\n| 변수명                           | 값                   |\n|------------------------------------|---------------------|\n| ANACONDA_TOKEN                    |                     |\n| ANALYTICS                         |                     |\n| ANDROID_DOCS_DEPLOY_TOKEN         |                     |\n| android_sdk_license               |                     |\n| android_sdk_preview_license       |                     |\n| ANSIBLE_VAULT_PASSWORD            |                     |\n| aos_key                           |                     |\n| aos_sec                           |                     |\n| API_KEY_MCM                       |                     |\n| API_KEY_SECRET                    |                     |\n| API_KEY_SID                       |                     |\n| API_KEY                           |                     |\n| API_SECRET                        |                     |\n| APIARY_API_KEY                    |                     |\n| APIDOC_KEY                        |                     |\n| APIGW_ACCESS_TOKEN                |                     |\n| apiKey                            |                     |\n| apiSecret                         |                     |\n| APP_BUCKET_PERM                   |                     |\n| APP_ID                            |                     |\n| APP_NAME                          |                     |\n| APP_REPORT_TOKEN_KEY              |                     |\n| APP_SECRETE                       |                     |\n| APP_SETTINGS                      |                     |\n| APP_TOKEN                         |                     |\n| appClientSecret                   |                     |\n| APPLE_ID_PASSWORD                 |                     |\n| APPLE_ID_USERNAME                 |                     |\n| APPLICATION_ID_MCM                |                     |\n| APPLICATION_ID                    |                     |\n| applicationCacheEnabled           |                     |\n| ARGOS_TOKEN                       |                     |\n| ARTIFACTORY_KEY                   |                     |\n| ARTIFACTORY_USERNAME              |                     |\n| ARTIFACTS                         |                     |\n| ARTIFACTS_AWS_ACCESS_KEY_ID       |                     |\n| ARTIFACTS_AWS_SECRET_ACCESS_KEY   |                     |\n| ARTIFACTS_BUCKET                  |                     |\n| ARTIFACTS_KEY                     |                     |\n| ARTIFACTS_SECRET                  |                     |\n| ASSISTANT_IAM_APIKEY              |                     |\n| ASYNC_MQ_APP_SECRET               |                     |\n\n\nJS URL을 얻으면 nuclei 노출 태그를 사용하여 더 많은 민감한 정보를 얻을 수 있습니다.\n\njs.txt 파일에서 노출 태그를 사용하여 Nuclei 명령을 실행하려면 다음 명령어를 사용하실 수 있습니다:\n\n```bash\nnuclei -l js.txt -t ~/nuclei-templates/exposures/ -o js_exposures_results.txt\n``` \n\n\n<div class=\"content-ad\"></div>\n\n위 명령어 각 부분에 대한 설명입니다:\n\n- nuclei: 이것은 빠르고 사용자 정의 가능한 취약점 스캐너 인 Nuclei를 실행하는 명령어입니다.\n- -l js.txt: -l 플래그는 Nuclei와 함께 스캔할 URL 목록이 포함된 파일(js.txt)을 지정합니다.\n- -t ~/nuclei-templates/exposures/: -t 플래그는 노출 태그에 대한 Nuclei 템플릿 디렉터리 경로를 지정합니다. 실제 Nuclei 템플릿이 저장된 경로에 맞게 경로 ~/nuclei-templates/exposures/를 조정하십시오.\n- -o js_exposures_results.txt: -o 플래그는 스캔 결과가 저장될 출력 파일(js_exposures_results.txt)을 지정하는 데 사용됩니다. 원하는 출력 파일 이름으로 js_exposures_results.txt를 대체할 수 있습니다.\n\nExploitation은 동일하게 유지되며 이 문서를 참조할 수 있습니다. 읽어 주셔서 감사합니다.\n\nJai Shree Ram","ogImage":{"url":"/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_0.png"},"coverImage":"/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_0.png","tag":["Tech"],"readingTime":10},{"title":"웹 콘텐츠를 더 빠르게 전달하는 새로운 패러다임들","description":"","date":"2024-06-19 22:38","slug":"2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster","content":"\n\n\n![TheEmergingParadigmsforDeliveringWebContentFaster_0](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_0.png)\n\nReact, Svelte, Vue 등 구성 요소 기반 프레임워크가 나오기 전에는 모든 콘텐츠를 서버에서 렌더링하는 것이 보편적이었습니다. 그때는 웹 사이트를 탐색하는 것이 서버로 여러 요청을 하게 되어 HTML, CSS 및 JS로 렌더링된 내용을 다시 웹 브라우저로 보내는 것이었습니다. 이를 서버 사이드 렌더링 (SSR)이라고 합니다.\n\n![TheEmergingParadigmsforDeliveringWebContentFaster_1](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_1.png)\n\n이후 React 및 다른 구성 요소 기반 프레임워크들이 나오면서 조금 덜 일반적인 클라이언트 사이드 렌더링 (CSR) 방법이 개발자들의 가장 선호하는 선택이 되었습니다. 개발자들은 싱글 페이지 애플리케이션을 만들고, 렌더링 콘텐츠의 책임을 서버에서 브라우저로 옮기는 경향을 보였습니다.\n\n\n<div class=\"content-ad\"></div>\n\n![TheEmergingParadigmsforDeliveringWebContentFaster_2](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_2.png)\n\n이러한 유형의 CSR은 시간이 지남에 따라 지나치게 발전되었습니다. 웹 사이트에서 애플리케이션의 모든 렌더링 논리를 브라우저로 보내는 것이 드문 일이 아닙니다. 문제는 JavaScript가 바이트 단위로 볼 때 브라우저에서 가장 느린 파일을 불러오는 것입니다. 서버는 사용자에게 정적 HTML로 콘텐츠를 렌더링하는 데 더 많은 리소스를 활용할 수 있으며 해당 콘텐츠를 더 빠르게 받을 수 있습니다. 제가 Islands Architecture에 대한 내 문서를 읽었다면 다른 옵션 몇 가지를 이미 알고 있을 것입니다.\n\n그러나 클라우드 컴퓨팅의 등장으로 인해, 클라이언트와 애플리케이션 서버만 고려해야 하는 것보다 더 많은 고려해야 할 사항이 있습니다. 정적 콘텐츠의 전달 속도를 높이는 데 도움이 되는 다른 글로벌 사용 가능한 기술이 있습니다.\n\n이 기사에서는 클라우드를 활용하여 정적 및 동적 콘텐츠의 캐싱 및 렌더링을 가속화하는 최근의 패러다임 중 하나인 정적 사이트 생성, 컨텐츠 전송 네트워크 및 Edge Computing에 대해 자세히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 정적 사이트 생성 (SSG)\n\nSSR 및 CSR과 마찬가지로, 정적 사이트 생성은 웹 사이트를 HTML 콘텐츠로 렌더링하는 또 다른 방법입니다.\n\n## SSG란?\n\nSSG는 클라이언트 요청을 받기 전에 HTML을 미리 렌더링하는 방법입니다. SSG는 서버사이드 렌더링과 대조적으로 페이지가 빌드 타임에 정적으로 렌더링되므로 클라이언트가 서버에 요청할 때가 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_3.png\" />\n\n이 방법에는 몇 가지 장점이 있습니다. 클라이언트가 서버로부터 웹페이지를 요청할 때, 자동적으로 해당 콘텐츠로 응답할 수 있습니다. 렌더링이 필요하지 않습니다. JavaScript는 이미 정적 HTML로 변환되어 클라이언트로 직접 전송할 수 있습니다.\n\n## CSR 및 SSR의 단점 해결\n\n정적 사이트 생성은 SSR과 CSR의 문제를 해결하기 위한 솔루션으로 등장했습니다. SSR은 Time to First Byte (TTFB)가 낮다는 문제가 있습니다. 간단히 말해서, SSR 웹사이트를 요청하는 경우 서버에서 해당 웹페이지를 각 요청에 대해 렌더링해야 하므로 서버에서 느린 응답을 받을 수 있습니다. 반면에 CSR은 브라우저가 웹페이지 콘텐츠를 생성하는 데 걸리는 시간과 해당 생성된 콘텐츠가 상호작용 가능해지는 데 걸리는 시간인 First Contentful Paint (FCP), Largest Contentful Paint (LCP), Time to Interactive (TTI)가 더욱 느릴 수 있습니다. 이러한 지표는 브라우저가 웹페이지 콘텐츠를 생성하는 데 얼마나 오래 걸리는지 및 생성된 콘텐츠가 상호작용 가능해지기까지 얼마나 걸리는지를 측정합니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_4.png\" />\n\nSSG란 각 웹 사이트 경로에 대해 미리 HTML 파일을 생성하여 FCP, LCP 및 TTI가 빨라지도록 하는 것입니다. 내용은 이미 렌더링되어 있으며 요청이 발생할 때 서버에서 로직을 수행할 필요가 없어 TTFB가 더 빨라집니다. 내용은 서버나 CDN에 캐시될 수도 있어 매우 빠른 응답이 가능합니다. SSG는 자주 변경되지 않는 정적 콘텐츠에 이상적입니다. FAQ나 About 페이지와 같은 내용에 적합합니다.\n\n## SSG의 함정\n\n정적 사이트 생성은 데이터가 필요한 페이지에도 적용 가능합니다. 이 데이터는 빌드 시간에 HTML에 통합됩니다. 뉴스 기사나 블로그 게시물을 다루는 웹 사이트에서 해당될 수 있습니다. 안타깝게도, 이러한 경우는 SSG의 주요 단점 중 하나인 것을 강조합니다: 변경이 발생할 때마다 전체 페이지를 재구축해야 하며 캐시된 HTML 파일이 무효화됩니다. 이는 SSG가 매우 동적인 콘텐츠에 대해 최상의 선택이 아닐 수 있다는 것을 의미합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_5.png)\n\n또한, 사이트의 경로가 많다면 많은 사전 렌더링된 HTML 사이트가 필요할 수 있습니다. 예를 들어, 모든 블로그 게시물을 SSG를 통해 렌더링하는 경우 많은 HTML 파일을 저장할 수 있습니다. 기본 코드베이스에 변경 사항이 발생할 때마다 전체 사이트를 재구축하고 다시 배포해야 한다는 점을 기억하세요. 오타를 수정해야 할 때마다 사이트를 다시 배포해야 한다고 상상해보세요.\n\n## 증분 정적 사이트 생성 (iSSG)\n\nNext.js와 같은 프레임워크에서 제공하는 증분 정적 사이트 생성 (iSSG)을 사용하여 이러한 문제 중 일부를 해결할 수 있습니다. iSSG를 사용하면 서버가 백그라운드에서 사이트에 페이지를 업데이트하고 추가할 수 있으면서도 클라이언트 요청을 처리할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_6.png)\n\niSSG를 사용하면 페이지가 빌드 시간이 아닌 첫 요청 시 생성됩니다. 첫 번째 사용자는 서버가 페이지를 빌드할 때 약간의 지연된 응답을 받습니다. 그런 다음 서버는 페이지를 캐시합니다. 그 후의 요청은 이미 빌드되어 있기 때문에 캐시된 사전 렌더링된 HTML 페이지를 보다 빠르게 받을 수 있습니다. 이는 한 형태의 레이지 로딩입니다.\n\niSSG를 사용하면 만료 시간을 설정해야 합니다. 이후 서버가 페이지를 백그라운드에서 다시 생성합니다. 페이지가 재생성된 후에는 이전의 사전 렌더링된 HTML 복사본이 캐시에서 삭제되고 새 복사본이 이후 요청에 제공됩니다. 이는 상태 갱신 중 사용자가 백그라운드에서 HTML을 재생성하는 동안 사용자에게 이전 페이지가 제공되는 'stale-while-revalidate' 전략의 한 예입니다.\n\n# 컨텐츠 전송 네트워크 (CDN)\n\n<div class=\"content-ad\"></div>\n\n콘텐츠 전달 네트워크인 CDN은 정적 웹 콘텐츠의 전달을 혁신적으로 개선했습니다.\n\n## CDN이란?\n\n![CDN](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_7.png)\n\nCDN은 매우 간단한 개념입니다. 지리적으로 분산된 서버 네트워크로, 빠르게 콘텐츠를 최종 사용자에게 제공할 수 있습니다. 네트워크 작업을 하는 사람이라면 거리가 요청-응답 주기의 속도에 가장 큰 장애물 중 하나라는 것을 알고 있습니다. CDN은 클라이언트와 콘텐츠 사이의 거리를 제한합니다. 이는 서버가 전 세계 여러 데이터 센터에 존재하기 때문입니다. 이러한 센터들은 정적 콘텐츠를 메모리에 캐시하고, 그런 다음 요청 시 전달하며, 보통 소액의 요금으로 이용 가능합니다. Amazon CloudFront, Akamai, CloudFlare와 같은 예시가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## SSG, iSSG 및 CDNs\n\nSSG 및 iSSG로 만든 정적 웹 콘텐츠는 CDN에 이상적이며 글로벌 규모에서도 콘텐츠를 전달하는 데 다음 수준의 속도를 제공할 수 있습니다.\n\nSSG 및 CDN을 사용한 전통적인 배포에서는 오리진 서버가 정적 페이지를 빌드하고 CDN으로 캐시할 것을 보냅니다. 사이트가 재구축될 때마다 CDN 캐시를 업데이트해야 합니다.\n\n<div class=\"content-ad\"></div>\n\niSSG를 사용하면 CDN이 클라이언트 요청시 오리진 서버와 더 직접적으로 상호작용합니다. iSSG를 사용하면 페이지는 첫 요청시 빌드되며 만료될 때 백그라운드에서 다시 빌드됩니다. 클라이언트가 요청하면 CDN이 해당 페이지가 캐시되어 있는지 확인합니다. 캐시되어 있다면 해당 페이지를 클라이언트에 제공합니다. 그렇지 않으면 오리진 서버에서 페이지를 요청하고, 서버가 페이지를 빌드하면 해당 페이지가 CDN에 캐시되어 사용자에게 제공됩니다.\n\n첫 번째 사용자만 느린 응답을 받을 수 있습니다. 그 이후에는 일부 사용자가 지난 페이지에 대해 만료된 후 상태 정보를 받을 수 있습니다. 만료는 캐시 제어 HTTP 헤더의 max-age 속성을 사용하여 설정됩니다. Express.js를 사용하여 문서의 최대 나이를 설정하는 예시를 보여드리겠습니다:\n\n```js\nres.set('Cache-Control', 'public, max-age=120');\n```\n\nmax-age는 초 단위로 설정됩니다. 위 예시에서는 2분 후에 캐시된 사전 렌더링된 HTML을 무효화합니다. 그 후에는 iSSG를 통해 CDN이 새로운 페이지를 요청하지만, 오리진 서버가 백그라운드에서 요청을 처리함에 따라 만료된 페이지를 계속 제공합니다. 사용자는 일부 만료된 정보를 받을 수 있지만, CDN의 응답은 정적 및 동적 콘텐츠 모두에 대해 매우 빠릅니다.\n\n<div class=\"content-ad\"></div>\n\n# 엣지 컴퓨팅\n\n지금까지 SSG와 iSSG가 CDN 캐시에서 빠르게 제공될 수 있는 정적, 사전 렌더링된 HTML 페이지를 만들 수 있다는 것을 살펴보았습니다. 그러나 이러한 예제에서는 클라이언트 요청이 여전히 원본 서버와 간접적으로 상호작용하고 있습니다. 페이지는 여전히 원본 서버에서 렌더링되고 CDN에서 제공됩니다. 중간 단계 없이 진행할 수 없을까요? 이 접근 방식을 유지하면서 CDN의 전역 아키텍처를 최적화할 수 있을까요?\n\n네, 가능합니다. 답은 엣지 컴퓨팅이라고 불리는 것에 있습니다.\n\n## 엣지 컴퓨팅이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n\n![Edge computing](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_9.png)\n\n에지 컴퓨팅은 IoT와 웹 애플리케이션 개발에서 부상하고 있는 패러다임입니다. 사용자에 가까운 위치에 컴퓨팅 로직과 데이터를 가져오려고 노력합니다. 클라우드와 마찬가지로 글로벌 아키텍처를 추구합니다. 그러나 클라우드와 달리 응용프로그램을 위한 상태 없는 분산 컴퓨팅 성능을 추구합니다.\n\nCDN 서버가 이 패러다임에 완벽하게 들어맞는 모습을 볼 수 있습니다. 이 서버들은 거의 웹 서버처럼 작동하여 클라이언트 요청에 응답하지만 많은 데이터 센터에 전 세계적으로 배치되어 정적 콘텐츠를 최대한 사용자에게 가까이 가져옵니다. CDN 서버의 근접성은 요청과 응답이 웹 페이지를 렌더링하는 데 필요한 거리를 줄이므로 전송 속도에 막대한 혜택을 제공합니다.\n\n![CDN servers](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_10.png)\n\n\n<div class=\"content-ad\"></div>\n\n에지 컴퓨팅은, 애플리케이션 서버에 의해 점진적으로 업데이트되어야 하는 정적 콘텐츠를 넘어보며 개발자들이 에지 서버에서 자체 코드를 실행할 수 있게 합니다. 예를 들어, 정적 콘텐츠는 미리 렌더링되어 CDN 캐시에 저장될 수 있고 CDN의 에지 서버에서 실행할 수 있는 스크립트와 함께 저장될 수 있으며 먼 오리진 서버가 아닌 CDN의 에지 서버에서 실행될 수 있어 클라이언트 요청에 따라 진정한 동적 콘텐츠가 생성될 수 있습니다. 이것은 동적 콘텐츠를 캐싱하는 한 가지 방법입니다.\n\n에지는 CDN에만 한정되지 않습니다. 사용자의 기기나 로컬 네트워크에서 데이터를 처리하는 것이나 클라우드가 아닌 곳에서 처리하는 것이 될 수 있습니다. 이에는 사용자의 휴대폰이나 여러 IoT 장치가 포함될 수 있습니다.\n\n## 장단점\n\n에지 컴퓨팅은 정적 및 동적 콘텐츠를 사용자에게 최적화하는 방법이 많이 있습니다. 이러한 성능상의 이점은 이미 분명합니다 - 에지 위치의 근접성으로 인해 사용자가 응답을 받는 데 걸리는 시간이 줄어듭니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_11.png\" />\n\n성능 향상뿐만 아니라 이 패러다임은 비용 절감과 증가하는 보안을 제공합니다. 특히 IoT 기기로 콘텐츠를 전달하거나 데이터를 처리할 때 더욱 그렇습니다. 현재 전 세계 가정에 설치된 750억 개 이상의 IoT 기기로 인해 이전보다 훨씬 많은 데이터가 생성되고 있습니다. 모든 이 데이터를 원본 서버로 전송하여 처리하는 것은 시간이 오래 걸리고 비용이 많이 드는 작업일 것입니다. 이 데이터 중 일부는 민감할 수도 있고 시간이 중요한 경우도 있습니다. 엣지 컴퓨팅을 통해 사용자가 생성한 데이터와 가능한 가까운 곳에 유지할 수 있습니다. 사용자나 비즈니스 데이터의 실시간 처리도 가능합니다.\n\n그러나 기본 웹 콘텐츠의 전달에 엣지 컴퓨팅이 최적의 선택이라고 할 수는 없습니다. 이는 신흥 분야이며 엣지에서 일부 기술이 다른 기술(예: 서버리스 함수 등) 대비 40%의 속도 향상을 보여주기는 했지만, 여전히 단점도 있습니다. 예를 들어 데이터베이스를 쿼리해야 하는 경우 엣지에서 요청하는 것이 지연을 증가시킬 수 있습니다. 이는 데이터베이스가 원본 서버보다 엣지 위치에서 더 멀리 있을 수 있기 때문입니다. 이 차이를 줄이기 위한 몇 가지 엣지 데이터베이스는 이미 있지만, 이러한 기술들은 아직 초기 단계에 있습니다.\n\n<img src=\"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_12.png\" />\n\n<div class=\"content-ad\"></div>\n\n게다가, 엣지 컴퓨팅은 민감한 데이터가 네트워크를 통해 전송되는 양을 줄이는 것으로 일부 보안 이점을 가질 수 있지만, 더 많은 공격 대상을 노출시킬 수도 있습니다. IoT 장치는 특히 공격에 취약한데, 이는 그들의 창조자들이 항상 보안을 최우선으로 하지 않기 때문입니다. 우리는 모두 해커들이 가정용 보안 카메라나 베이비 모니터를 해킹하는 동영상을 본 적이 있습니다. 이러한 공격은 특히 경고적이지만, 많은 민감한 데이터의 보안 침해가 IoT 장치에서 발생하고 완전히 눈에 띄지 않을 수 있습니다. 이러한 공격은 사용자의 개인 정보에도 심각한 피해를 줄 수 있습니다. 침해된 장치는 심지어 봇넷을 생성하고 웹 서버에 DDOS 공격을 발동할 수도 있습니다.\n\n# 신흥 패러다임\n\n현대 사회에서 분권화는 커지는 추세인 것으로 보입니다. 웹 콘텐츠 전달은 기술의 분권화의 다음 단계일 수 있습니다. 결국, 우리는 엔드 사용자에 가능한 한 가까운 곳에 있는 엣지 데이터베이스에 저장된 사용자 데이터가 엣지 서버와 상호 작용하여 개인화된 콘텐츠를 생성하는 것을 볼 수 있을 겁니다. 이러한 사용자 경험은 더 빠르고 더 상호 작용적이며, 희망적으로 더 안전할 것입니다.\n\n지금 당장, 개발자이면 CDNs와 기본적인 엣지 컴퓨팅을 탐험해보는 것이 좋습니다. 이미 사용 가능한 옵션인 Lambda@Edge나 Vercel Edge Functions과 같은 것은 동적 콘텐츠를 엔드 사용자에게 더 가까운 곳에 캐싱함으로써 성능과 보안을 향상시키고 비용을 절감하는 데 도움이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nSSG 또는 iSSG에 대해 더 알고 싶다면, patterns.dev를 방문해보세요. 그곳에서 이 주제에 대해 더 깊이 파고들어 설명하고 있어요. Edge 컴퓨팅에 대해 더 알고 싶다면, Vercel Edge Functions나 AWS의 Lambda@Edge를 살펴보세요.","ogImage":{"url":"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_0.png"},"coverImage":"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_0.png","tag":["Tech"],"readingTime":9},{"title":"타입스크립트에서 제네릭 마스터하기 유연하고 안전하며 중복이 없는 코드 작성","description":"","date":"2024-06-19 22:37","slug":"2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode","content":"\n\n![이미지](/assets/img/2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode_0.png)\n\n## 소개\n\nTypeScript의 제네릭은 소프트웨어의 견고성과 확장성을 향상시키는 뿐만 아니라 any를 대체함으로써 유형 정확성을 향상시킵니다. 이 개념은 TypeScript에만 한정되지 않고 Swift, Java, C#, C++ 등 다른 프로그래밍 언어에서도 널리 채택되었습니다.\n\n## 제네릭 미사용 방법 대 제네릭 사용 방법\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction logInformations<T>(infos: T): T {\n  return infos;\n}\n\nlogInformations<number>(1234);\nlogInformations<string[]>(['React Native', 'TypeScript']);\n```\n\n<div class=\"content-ad\"></div>\n\n제네릭을 사용하면 logInformations 메서드를 이제 모든 데이터 유형과 함께 사용할 수 있어 코드 중복을 피하고 유연성을 제공할 수 있습니다. 이는 개발을 간소화할 뿐만 아니라 더 견고하고 확장 가능한 코드를 보장하여 유형 정확성을 높이는 장점이 있습니다.\n\n또 다른 흥미로운 특징은 제네릭의 유추 타입(type inference)입니다. TypeScript 컴파일러에서 수행되며, 일반 함수를 호출할 때 유형 명세가 선택 사항이 될 수 있도록 합니다:\n\n```js\nlogInformations(1234)\nlogInformations(['React Native', 'TypeScript'])\n```\n\n이 과정은 컴파일러가 자동으로 처리하여 유형 명세가 선택 사항이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 명명 규칙\n\nTypeScript에서 제네릭을 사용할 때, 일반적으로 T를 제네릭 유형 매개변수로 사용하는 것이 일반적입니다. 그러나 중요한 점은 T가 단지 관습이라는 것이며, 코드의 문맥에 맞는 의미있는 이름으로 대체할 수 있다는 것입니다. 예를 들어, 항목 목록을 다룰 때 T 대신 Item을 사용하면 코드 가독성을 높일 수 있습니다.\n\n## 제약 조건\n\n제약 조건은 사용되는 제네릭 유형에 제약 조건을 부여하여 특정 규칙이나 인터페이스를 준수하도록 하는 제네릭의 기능입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n인터페이스 ExtraInformations {\n  createdAt: string;\n}\n\nfunction logInformations<T extends ExtraInformations>(infos: T): T {\n  return infos;\n}\n```\n\n따라서 logInformations 메서드에 전달된 제네릭 타입은 어떤 타입이든 될 수 있지만, 반드시 string 타입의 createdAt 속성을 가져야 합니다.\n\n## 결론\n\nTypeScript의 제네릭은 더 유연하고 안전한 코드를 작성하는 데 필수적이며, any를 사용한 적 less robust한 방식을 대체하고 불필요한 코드 중복을 제거합니다. 타입을 추론하고 제약을 부과할 수 있는 기능을 통해, 제네릭은 개발을 단순화하고 타입의 정확성을 크게 향상시켜 코드를 확장 가능하고 유지보수하기 쉽게 만듭니다.\n\n\n<div class=\"content-ad\"></div>\n\n소셜 미디어에서 나를 팔로우해 주세요: LinkedIn | GitHub","ogImage":{"url":"/assets/img/2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode_0.png","tag":["Tech"],"readingTime":2},{"title":"MySQL JOIN 뒤의 작업 공개 실행 흐름의 상세 분석과 최적화 권고사항","description":"","date":"2024-05-27 19:27","slug":"2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations","content":"\n\nMySQL JOIN 실행 프로세스의 복잡성을 탐색하고 데이터베이스 성능을 향상시키기 위해 깊이있는 분석과 실용적인 최적화 기술을 제공해 드립니다. 쿼리 작업을 원활하게 하는 비밀에 대해 해체하고 있습니다.\n\n![MySQL JOIN 동작의 세부 분석과 실행 흐름 및 최적화 권장 사항](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_0.png)\n\nMySQL의 JOIN 작업에 대해 실행 프로세스를 고찰해 보거나 자신의 이해력에 대해 의문을 품어 보셨나요? 확인하는 방법이 불분명하다면, 다음 질문에 답하려고 시도해 보십시오.\n\n- MySQL이 주도 테이블을 선택하는 방법은 고찰할 가치가 있는 문제입니다. 그것은 라인업에서 첫 번째 테이블부터 시작하여 왼쪽에서 오른쪽 순차적인 순서로 선택됩니까?\n- 다중 테이블 조인을 수행할 때, 어떤 기준이 테이블을 조인하는 순서를 선택하는 데 도움이 되나요?\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 주행 테이블의 개념을 이해하는 것이 중요합니다.\n\n다중 테이블 조인 쿼리의 맥락에서 주행 테이블은 처리되는 첫 번째 테이블을 가리키며, 베이스 테이블이라고도 알려져 있습니다. 이 테이블의 레코드는 다른 테이블과 연관 지을 때 사용됩니다.\n\n주행 테이블을 선택하는 것은 원칙을 준수합니다: 최종 결과 집합에 영향을 주지 않는 한 가장 작은 결과 집합을 가진 테이블을 우선적으로 주행 테이블로 선택합니다.\n\n이 원칙은 이해하기 어려울 수 있습니다. 가장 작은 결과 집합을 추정하는 것은 가능하지만, 이것이 최종 결과 집합에 영향을 주지 않는 것을 판단하는 것은 더 복잡합니다. 그러나 이 과정은 파악할 수 있는 패턴이 존재합니다.\n\n<div class=\"content-ad\"></div>\n\nLEFT JOIN은 일반적으로 왼쪽 테이블을 주도 테이블로 삼습니다 (RIGHT JOIN은 일반적으로 오른쪽 테이블을 포함합니다).\n\nINNER JOIN에서는 결과 세트가 더 작은 테이블이 일반적으로 주도 테이블로 선택됩니다.\n\n의문이 남는 경우, EXPLAIN을 사용하여 주도 테이블을 식별할 수 있습니다. 결과에서 첫 번째 테이블은 주도 테이블로 간주됩니다.\n\n그러나 EXPLAIN이 항상 정확하지는 않을 수 있음을 유의해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실행 계획은 실제 실행 중에 변경될 수 있습니다.\n\n데이터 준비 중입니다.\n\nInnoDB 엔진을 사용하여 MySQL 버전 5.7을 실행 중입니다.\n\n데이터에 대한 초기 SQL은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nDROP TABLE IF EXISTS tb_user;\n\nCREATE TABLE tb_user (\n  id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  user_name VARCHAR(50) NOT NULL,\n  gender TINYINT(1) NOT NULL,\n  created_at datetime NOT NULL,\n  updated_at datetime NOT NULL,\n  PRIMARY KEY (id)\n);\n\nINSERT INTO tb_user(user_name, gender, created_at, updated_at) VALUES\n('Girvan', 1, NOW(), NOW()),\n('Paul', 0, NOW(), NOW()),\n('Max', 1, NOW(), NOW()),\n('Brogan', 0, NOW(), NOW()),\n('Aydan', 1, NOW(), NOW()),\n('Colm', 0, NOW(), NOW()),\n('Jason', 1, NOW(), NOW()),\n('Quillan', 0, NOW(), NOW()),\n('Donnacha', 1, NOW(), NOW()),\n('Iarla', 0, NOW(), NOW());\n\nDROP TABLE IF EXISTS tb_login_log;\n\nCREATE TABLE tb_login_log (\n  id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  user_name VARCHAR(50) NOT NULL,\n  ip VARCHAR(15) NOT NULL,\n  created_at datetime NOT NULL,\n  PRIMARY KEY (id)\n);\n\nINSERT INTO tb_login_log(user_name, ip, created_at) VALUES\n('Girvan', '192.168.1.101', '2024-01-01 12:01:01'),\n('Girvan', '192.168.1.102', '2024-01-02 12:02:02'),\n('Girvan', '192.168.1.103', '2024-01-03 12:03:33'),\n('Paul', '192.168.1.104', '2024-01-04 12:00:01'),\n('Max', '192.168.1.105', '2024-01-05 12:00:01'),\n('Brogan', '192.168.1.106', '2024-01-06 12:00:01'),\n('Aydan', '192.168.1.107', '2024-01-07 12:00:01'),\n('Colm', '192.168.1.108', '2024-01-08 12:00:01');\n\nSELECT * FROM tb_user;\nSELECT * FROM tb_login_log;\n``` \n\n단일 테이블 쿼리 실행 과정이 비교적 간단하며 다음과 같이 요약할 수 있습니다:\n\n![query_execution_flow](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_1.png)\n\n조인 알고리즘.\n\n<div class=\"content-ad\"></div>\n\nMySQL의 조인 알고리즘은 중첩 루프 알고리즘에서 파생되었으며, 다양한 조건에 따라 선택된 일련의 알고리즘을 포함하고 있습니다.\n\n인덱스 기반 조인을 사용할 때는 두 가지 알고리즘인 인덱스 중첩 루프 조인과 일괄 키 액세스 조인이 있습니다.\n\n인덱스 기반 조인이 없을 때는 두 가지 알고리즘인 단순 중첩 루프 조인과 블록 중첩 루프 조인이 있습니다.\n\n# 1. 단순 중첩 루프.\n\n<div class=\"content-ad\"></div>\n\n간단한 중첩 루프 조인, 줄여서 SNL이라고도하는 것은 한 번에 한 레코드씩 일치시키는 것을 포함하며, 순차적으로 한 번에 하나씩 진행됩니다.\n\n```js\nfor each row in t1 matching range {\n  for each row in t2 matching reference key {\n    for each row in t3 {\n      if row satisfies join conditions, send to client\n    }\n  }\n}\n```\n\n![MySQL 조인의 실행 흐름 및 최적화 권장사항에 대한 자세한 분석 이미지](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_2.png)\n\n이 알고리즘은 직관적이지만 성능이 떨어지며, 시간 복잡성 측면에서 테이블의 레코드 수를 N, 조인된 테이블의 수를 M이라고 할 때 N의 M 제곱에 비례합니다.\n\n<div class=\"content-ad\"></div>\n\n이를 최적화하기 위해 MySQL은 조인 쿼리에 대해 이러한 알고리즘을 사용하지 않습니다. WHERE 조건이 없고 ON 조인 키에 인덱스가 없는 경우에도 이 알고리즘을 사용하지 않습니다.\n\n# 2. 블록 중첩 루프.\n\n블록 중첩 루프 조인, 줄여서 BNL,은 SNL의 최적화 방법입니다.\n\n주행 테이블의 여러 행을 한꺼번에 조인 버퍼에 캐싱하는 것을 포함합니다. 그런 다음, 조인 버퍼의 데이터가 일치하도록 매치할 수 있게 배치되며, 이는 내부 루프에서 검색한 데이터와 유사한 방식으로 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfor each row in t1 matching range {\n  for each row in t2 matching reference key {\n    store used columns from t1, t2 in join buffer\n    if buffer is full {\n      for each row in t3 {\n        for each t1, t2 combination in join buffer {\n          if row satisfies join conditions, send to client\n        }\n      }\n      empty join buffer\n    }\n  }\n}\n\nif buffer is not empty {\n  for each row in t3 {\n    for each t1, t2 combination in join buffer {\n      if row satisfies join conditions, send to client\n    }\n  }\n}\n```\n\n내부 루프에서 검색된 각 행을 버퍼의 모든 레코드와 비교함으로써 내부 루프에서의 테이블 읽기 횟수를 줄일 수 있습니다.\n\n예를 들어, Join 버퍼가 없을 경우 주도 테이블이 30개 레코드를 가지고 있고 대입 테이블에 50개 레코드가 있을 때 내부 루프는 30 * 50 = 1500 개의 테이블 읽기를 요구합니다.\n\n그러나 Join 버퍼가 있고 10개 레코드를 저장할 수 있는 경우 (Join 버퍼에는 주도 테이블로부터 쿼리에서 사용된 열이 저장되며, SELEC 열, ON 열, WHERE 열이 포함됩니다), 내부 루프는 30 / 10 * 50 = 150 개의 테이블 읽기만 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n주어진 테이블이 수행해야 하는 읽기 작업의 수를 한 차원 줄입니다.\n\n이 알고리즘은 주어진 테이블이 조인 키에 인덱스가 없고 WHERE 필터링 조건에도 인덱스가 없는 경우에 자주 사용됩니다. 이러한 경우에는 다음과 같이 접근합니다:\n\n![이미지 1](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_3.png)\n\n![이미지 2](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_4.png)\n\n<div class=\"content-ad\"></div>\n\n# 3. 인덱스 중첩 루프.\n\n인덱스 중첩 루프 조인(약어: INL)은 조인을 수행하기 위해 주도 테이블의 인덱스를 기반으로 하는 알고리즘입니다.\n\n이 알고리즘에서는 주도 테이블의 레코드가 주도 테이블의 인덱스와 일대일로 일치하도록 하나씩 매칭됩니다.\n\n이렇게 하면 주도 테이블의 모든 레코드와 비교할 필요가 없어져 주도 테이블과의 매칭 작업 수를 줄일 수 있습니다. 일반적인 프로세스는 아래 다이어그램에 설명되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n![image 5](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_5.png)\n\n실제 예제를 살펴보겠습니다. 먼저 쿼리를 사용하여 tb_login_log 테이블에 인덱스를 추가해 봅시다. ALTER TABLE tb_login_log ADD INDEX idx_user_name (user_name). 그 후에 조인을 위한 실행 계획을 확인해 봅시다.\n\n![image 6](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_6.png)\n\ntb_login_log 테이블에 대한 인덱스가 현재 작용하는 것을 관찰할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 WHERE 조건을 포함한 쿼리를 테스트하기로 하겠습니다.\n\n![image](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_7.png)\n\n흥미로운 사건이 발생했습니다: 주도 테이블이 tb_login_log로 변경되었고, tb_user가 이제 기동 테이블이 되었습니다.\n\ntb_login_log의 인덱스를 거쳐 결과 집합을 얻은 후, BNL 알고리즘이 이 결과 집합과 tb_user 테이블을 일치시키는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\nMySQL의 이 최적화는 tb_login_log에서의 인덱스 필터링을 통해 얻은 결과 집합이 tb_user의 레코드 수보다 작기 때문에 발생합니다. 결과적으로 MySQL은 주도 테이블로 tb_login_log를 선택했습니다.\n\n## 4. 배치 키 액세스.\n\n배치 키 액세스(Batched Key Access) 또는 BKA는 인덱스 중첩 루프(INL) 알고리즘의 최적화입니다.\n\n배치 키 액세스(BKA)가 인덱스 중첩 루프(INL) 알고리즘에 제공하는 최적화는 배치 키 액세스가 단순 중첩 루프(SNL) 알고리즘에 제공하는 향상과 유사합니다. 그러나 둘 사이에는 구별점이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n먼저, 다음 쿼리를 사용하여 tb_user 테이블에 인덱스를 추가하세요: ALTER TABLE tb_user ADD INDEX i_aaa(user_name);.\n\n그 다음, 다음 쿼리를 사용하여 실행 계획을 확인하세요: EXPLAIN SELECT * FROM tb_login_log tl LEFT JOIN tb_user tu ON tl.user_name = tu.user_name.\n\n결과는 다음 다이어그램과 비슷해야 합니다:\n\n<img src=\"/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_8.png\" />\n\n<div class=\"content-ad\"></div>\n\n지금 시점에서 조인 알고리즘은 INL입니다. 그 이유는 tb_login_log 테이블의 user_name 열에 색인이 없기 때문입니다.\n\n결과적으로, user_name 열에서 tb_login_log 테이블에서 검색된 값은 정렬되지 않습니다.\n\ntb_user와 연관시킬 때 일치 과정은 아래 다이어그램과 유사한 i_aaa 색인에 무작위 액세스를 포함합니다.\n\n![다이어그램](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_9.png)\n\n<div class=\"content-ad\"></div>\n\nBKA 기능은 기본적으로 비활성화되어 있습니다 (batched_key_access=off). 이를 활성화하려면 다음 명령을 실행하세요:\n\n```js\nSET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';\n```\n\n![이미지](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_10.png)\n\ntb_login_log에서 검색된 user_name의 값은 먼저 조인 버퍼에 배치됩니다.\n\n<div class=\"content-ad\"></div>\n\n조인 버퍼가 가득 차거나 데이터 검색이 완료되면 조인 버퍼의 값이 정렬됩니다.\n\n이후에 버퍼는 tb_user와 연관시켜 사용되어, i_aaa 인덱스와 연속적으로 일치시킵니다. 아래 다이어그램과 유사한 방식입니다.\n\n![다이어그램](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_11.png)\n\n요약.\n\n<div class=\"content-ad\"></div>\n\n- Index Nested-Loop join (INL)는 주테이블의 각 행을 드라이븐 테이블의 인덱스와 비교하여 레코드를 매칭하는 알고리즘입니다.\n- Batched Key Access join (BKA)는 INL의 최적화로, 주테이블의 값들이 먼저 조인 버퍼에 배치되고 정렬된 후 드라이븐 테이블의 인덱스와 순차적으로 매칭에 사용됩니다.\n- 조인 쿼리의 최적화를 위해 MySQL은 사용 가능한 인덱스, 결과 집합 크기 및 필터링 조건과 같은 요소를 기반으로 가장 효율적인 알고리즘을 동적으로 선택할 수 있습니다.\n- 실행 계획을 이해하고 EXPLAIN을 사용하며 인덱스를 고려하는 것은 MySQL에서 조인 쿼리의 성능을 최적화하고 분석하는 데 도움이 됩니다.\n\n이런 이야기를 좋아하시고 제 지원을 원하신다면, 박수를 부탁드립니다.\n\n여러분의 지원은 저에게 매우 중요합니다. 감사합니다.","ogImage":{"url":"/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_0.png"},"coverImage":"/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_0.png","tag":["Tech"],"readingTime":9},{"title":"장고의 왕국이 곧 종말을 맞이할 이유","description":"","date":"2024-05-27 19:25","slug":"2024-05-27-UnveilingtheTruthIsDjangosReignOverDispellingMythsandEmbracingItsEvolution","content":"\n\n# 소개:\n\n안녕하세요, 개발자 여러분! 👋 웹 개발의 끊임없이 변화하는 세계에서 Django는 파이썬과 함께 견고하고 확장 가능한 웹 응용 프로그램을 구축하는 데 우리에게 신뢰할 만한 친구였습니다. 그러나 이 모든 새로운 기술들이 등장하면서, \"Django가 죽는 것인가?\" 궁금해할 수 있습니다. 이 대화에 뛰어들어 이들 소문에 진실이 있는지, 아니면 Django가 우리 모두처럼 진화하고 있는지 확인해보겠습니다.\n\n# 대체 기술의 부상:\n\nReact, Angular, Vue.js와 같은 JavaScript 프레임워크들이 인기를 끌면서, 일부 사람들은 Django와 같은 서버 측 프레임워크의 타당성을 의심하기 시작했습니다. 그리고 마이크로서비스 아키텍처, 서버리스 컴퓨팅, 헤드리스 CMS 솔루션 주변의 소문을 잊지 말아야 합니다. 이러한 트렌드로 인해 Django와 같은 단일 프레임워크가 구식이 되고 있는지 의심하기 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n# 신화를 해소하다:\n\n잠깐만 기다려주세요! 어떤 결론을 내기 전에, Django가 웹 개발에서 아직 강력한 위치를 차지하는 이유에 대해 자세히 알아봅시다:\n\n- 성숙한 생태계: Django는 그냥 프레임워크가 아닌 완전히 갖춰진 툴킷입니다. 포괄적인 문서와 활기찬 커뮤니티를 통해 Django는 효율적으로 웹 애플리케이션을 구축하는 데 필요한 모든 것을 제공합니다. ⚡\n- 확장성과 성능: 단일체로 불리기도 하지만, Django는 탁월한 확장성을 보여줄 수 있습니다. 캐싱, 비동기 처리, 수평 확장 등 적절한 최적화를 통해 Django는 대량의 트래픽을 처리할 수 있습니다. 📈\n- 다재다능성과 유연성: Django는 일일이 해줘야 할 일이 하나뿐인 것이 아닙니다. Django는 기존의 웹 애플리케이션부터 API, 마이크로서비스, 콘텐츠 관리 시스템(CMS)까지 다양한 프로젝트에 적합합니다. 🛠️\n- 보안과 안정성: 보안은 중요한 문제이며, Django는 이를 심각하게 대합니다. XSS, CSRF, SQL 인젝션 같은 일반적인 취약점에 대한 내장형 방어 기능을 통해 Django는 애플리케이션을 안전하게 유지합니다. 또한 역호환성에 대한 헌신은 장기 프로젝트에 안정성을 제공합니다. 🔒\n\n# Django의 진화:\n\n<div class=\"content-ad\"></div>\n\n과거에 머물고 있는 것이 아닌 Django는 현대 개발자의 요구를 충족시키기 위해 지속적으로 발전하고 있습니다:\n\n- Django REST Framework (DRF): RESTful API를 구축 중이라면 DRF를 찾을 필요가 없습니다. Django와 함께 강력하고 확장 가능한 웹 API를 만드는 데 필수 도구로 자리 잡았습니다. 이제 이보다 더 쉽습니다. 🌐\n- Django Channels를 통한 Async 지원: 실시간 반응형 웹 애플리케이션을 만들고 싶나요? Django Channels가 도와줄 겁니다. 비동기 통신을 지원하여 Django 생태계 내에서 채팅 플랫폼 등을 만들 수 있습니다. 📡\n- 현대 프론트엔드 기술 통합: Django는 다른 도구들과도 잘 어울립니다. React, Angular, Vue.js와 같은 프론트엔드 프레임워크와 원활하게 통합되어 두 가지 세계의 장점을 활용할 수 있습니다. 🎨\n\n# 결론:\n\n그래서 Django가 쇼에 가고 있는 걸까요? 전혀 그렇지 않습니다! Django가 앞으로 나아가고 있는 것은 오해입니다. 새로운 기술이 항상 등장하지만, Django는 견고하고 적응성이 뛰어난 도구로 남아 웹 개발의 미래에 도전할 준비가 되어 있습니다. Django의 진화는 능력을 높여줄 뿐 아니라 그 가치를 유지하고 강화함을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n거대한 체계 속에서 Django는 강건한 생태계, 확장성, 보안 및 적응성으로 성장하고 있습니다. Django는 그저 살아있는 것뿐만이 아니라 진화하며 디지털 랜드스케이프에서 혁신과 영향력을 만들어내는 새로운 시대를 열고 있습니다.\n\n그래서 이런 소문들은 잊어버리세요. Django의 통치 시대는 멀었으며, 그 여정은 더욱 흥미진진해지고 있습니다! 🌟\n\n읽어 주셔서 감사합니다. 즐거운 코딩되세요! 🚀","ogImage":{"url":"/assets/img/2024-05-27-UnveilingtheTruthIsDjangosReignOverDispellingMythsandEmbracingItsEvolution_0.png"},"coverImage":"/assets/img/2024-05-27-UnveilingtheTruthIsDjangosReignOverDispellingMythsandEmbracingItsEvolution_0.png","tag":["Tech"],"readingTime":3},{"title":"Laravel 개발 혁신하기 매크로에 작별을 고하고 믹신스에 안녕을 외치다","description":"","date":"2024-05-27 19:24","slug":"2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins","content":"\n\n<img src=\"/assets/img/2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins_0.png\" />\n\n안녕하세요! Laravel에서 Mixins를 전문적으로 사용하는 방법에 대한 포괄적인 안내서에 오신 것을 환영합니다! 이 가이드는 Mixins의 세계에 심취하여 Laravel 개발 기술을 향상시키도록 설계되었습니다. 그러나 먼저 Macros에 대해 간단히 설명하겠습니다. Macros는 Laravel의 주요 측면으로, 사용자 정의 메서드를 추가하여 클래스의 기능을 확장할 수 있게 해줍니다. Macros는 Laravel에서 재사용 가능하고 조직화된 코드를 개발하는 데 중요한 역할을 하며, Macro를 최대한 활용하여 효율적이고 확장 가능한 애플리케이션을 만드는 방법을 여러분께 보여드리겠습니다. 예를 들어, Laravel의 Str 및 Arr 헬퍼 클래스에 사용자 정의 메서드를 추가하고 싶을 수 있습니다.\n\nStr 헬퍼의 경우 다음과 같이 사용할 수 있습니다:\n\nfullName\ninitials\n\n<div class=\"content-ad\"></div>\n\n\nArr 도우미 클래스에 대해:\n\ncamelToSnake snakeToCamel filterNulls\n\n지금은 macros를 사용해서 AppServiceProvider.php의 boot 메서드 안에 위의 메서드들을 추가해보도록 합시다.\n\n```php\n<?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Arr;\nuse Illuminate\\Support\\ServiceProvider;\nuse Illuminate\\Support\\Str;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * 어플리케이션 서비스를 부트스트랩합니다.\n     */\n    public function boot(): void\n    {\n        Str::macro('fullName', function (string $firstname, string $lastname) {\n            return trim($firstname . ' ' . $lastname);\n        });\n\n        Str::macro('initials', function (string $firstname, string $lastname) {\n            return strtoupper($firstname[0] . $lastname[0]);\n        });\n\n        Arr::macro('camelToSnake', function (array $array) {\n            return Arr::mapWithKeys($array, function ($value, $key) {\n                return [Str::snake($key) => $value];\n            });\n        });\n\n        Arr::macro('snakeToCamel', function (array $array) {\n            return Arr::mapWithKeys($array, function ($value, $key) {\n                return [Str::camel($key) => $value];\n            });\n        });\n\n        Arr::macro('filterNulls', function (array $array) {\n            return Arr::where($array, function ($value) {\n                return !is_null($value);\n            });\n        });\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n라라벨(Laravel)에서는 사용자 정의 메소드로 쉽게 확장할 수 있는 여러 클래스가 있습니다. 이러한 클래스들을 \"매크로 가능(Macroable)\" 클래스라고 합니다. 각 클래스마다 AppServiceProvider를 다른 매크로 메소드로 혼잡하게 만드는 대신에, 각 매크로 가능 클래스에 대한 개별 제공자 클래스를 만들고 config/app.php 파일에 등록할 수 있습니다. 그러나 이러한 방법은 모든 메소드를 추적하는 것이 조금 귀찮고 혼잡하게 만들 수 있습니다. 저는 보다 자연스럽고 가독성이 좋고 유지보수가 용이한 접근법을 선호합니다. 그렇다면 어떻게 해야 할까요? 여기에서 Mixins이 나옵니다. Mixins을 사용하면 클래스를 확장하는 프로세스를 간단하게 만들어 코드를 보다 구조적으로 관리하기 쉽게 할 수 있습니다.\n\n## Mixin이란 무엇인가요?\n\n매크로와 마찬가지로 Mixin은 넓은 라라벨 컨텍스트에서 기존 클래스의 기능을 확장하는 개념입니다. Mixin이 작동하는 방법을 살펴보겠습니다:\n\n- Mixin 클래스에는 다른 클래스에 추가하려는 메소드가 포함되어 있습니다. 이러한 메소드는 일반적으로:\n\n<div class=\"content-ad\"></div>\n\n- `Table` 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\nArrayMixin.php\n\n```js\n<?php\n\nnamespace App\\Mixins;\n\nuse Closure;\nuse Illuminate\\Support\\Arr;\nuse Illuminate\\Support\\Str;\n\nclass ArrayMixin\n{\n    /**\n     * @return Closure\n     */\n    public function camelToSnake()\n    {\n        return function (array $array) {\n            return Arr::mapWithKeys($array, function ($value, $key) {\n                return [Str::snake($key) => $value];\n            });\n        };\n    }\n\n    /**\n     * @return Closure\n     */\n    public function snakeToCamel()\n    {\n        return function (array $array) {\n            return Arr::mapWithKeys($array, function ($value, $key) {\n                return [Str::camel($key) => $value];\n            });\n        };\n    }\n\n    /**\n     * @return Closure\n     */\n    public function filterNulls()\n    {\n        return function (array $array) {\n            return Arr::where($array, function ($value) {\n                return !is_null($value);\n            });\n        };\n    }\n}\n```\n\nStringMixin.php\n\n```js\n<?php\n\nnamespace App\\Mixins;\n\nuse Closure;\n\nclass StringMixin\n{\n    /**\n     * @return Closure\n     */\n    public function fullName()\n    {\n        return function (string $firstname, string $lastname) {\n            return trim($firstname.' '.$lastname);\n        };\n    }\n\n    /**\n     * @return Closure\n     */\n    public function initials()\n    {\n        return function (string $firstname, string $lastname) {\n            return strtoupper($firstname[0].$lastname[0]);\n        };\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 AppServiceProvider에 이 Mixin들을 등록하세요:\n\n```js\n/**\n* 어플리케이션 서비스를 초기화합니다.\n*/\npublic function boot(): void\n{\n    Str::mixin(new StringMixin());\n    Arr::mixin(new ArrayMixin());\n}\n```\n\n잘 했어요! 이제 프로젝트가 잘 정리되었고 코드를 더 쉽게 읽을 수 있게 되었어요.\n\n여전히 Str::initials(...), Arr::filterNulls(...)와 같이 이 도우미 메서드를 이전과 같은 방식으로 사용할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n믹신의 장점:\n\n- 코드 재사용성: 믹신 클래스 내에 도우미 로직을 캡슐화함으로써 코드를 중복하지 않고 응용 프로그램의 다른 부분에서 재사용할 수 있습니다.\n- 코드 청결함: 믹신은 원래 클래스 코드를 청소하고 핵심 기능에 집중할 수 있도록 도와줍니다. 도우미 메서드는 전용 클래스로 분리됩니다.\n- 유지보수성 향상: 도우미 로직을 수정하거나 제거해야 할 경우, 모든 내용이 한 군데에 있습니다 - 믹신 클래스 내에 위치하고 있습니다.\n\n다음 기사에서 뵙겠습니다.","ogImage":{"url":"/assets/img/2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins_0.png"},"coverImage":"/assets/img/2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins_0.png","tag":["Tech"],"readingTime":5},{"title":"현업에서 Django를 더이상 사용하지 않는 이유","description":"","date":"2024-05-27 19:23","slug":"2024-05-27-IsDjangoDyingAnHonestLookattheFuture","content":"\n\n\n![Is Django Dying](/assets/img/2024-05-27-IsDjangoDyingAnHonestLookattheFuture_0.png)\n\nDjango의 소멸을 선언하는 클릭베이트 제목에 지쳤나요? 저는 그렇습니다. 여전히 Django를 의존하는 대규모 기업들이나 커뮤니티가 구축하는 놀라운 것들을 확인하지 않은 것처럼 보입니다. 솔직히, Django를 \"소멸\"이라고 부르는 것은 인터넷 익스플로러를 사용하는 것보다 더 접촉을 잃은 것으로 여겨집니다. Django가 톱 플레이어로 남아 있는 이유에 대해 알아봅시다.\n\n## 섹션 1: Django는 비디오 게임 고양이보다 더 많은 생명력을 가지고 있습니다.\n\n정말이에요, \"Django가 죽었다\"는 기사들은 금방 질리죠. 이 프레임워크는 핵 겨울 속의 바퀴벌레보다 더 저항력이 있습니다. 여기 이유가 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 새로운 묘기 (최근 업데이트): 장고의 개발자들은 꼼짝마라하지 않습니다. 최근 업데이트로 비동기 뷰(안녕, 속도 향상!)와 내장 JSON 필드 지원(데이터 처리가 더욱 원활해졌어요)와 같은 좋은 기능들을 선사했습니다. 이제 비동기 뷰의 훌륭함을 맛보세요:\n\n```js\nfrom django.http import HttpResponse\nimport asyncio\n\nasync def my_async_view(request):\n    # 비동기적으로 시간이 오래 걸리는 작업 수행\n    result = await long_running_task()\n    return HttpResponse(f\"여기에 결과가 있습니다: {result}\")\n```\n\n- 충실한 크루 (커뮤니티): 새벽 2시에 코딩 질문을 했더니 누군가가 답변해준 적이 있나요? 이것이 장고 커뮤니티의 마법입니다. 스택 오버플로우, 전용 포럼 및 다양한 경험 많은 개발자들을 만날 수 있어요. 이는 장고를 훨씬 더 쉽고 재미있게 배울 수 있게 만들어줍니다.\n- 현실 세계 챔피언 (성공 스토리): 만약 장고가 정말로 사라지는 길에 있다면 인스타그램, 스포티파이, 워싱턴 포스트와 같은 기업들이 그 위에 서비스를 구축할까요? 아니요. 이러한 거물들이 장고의 확장 가능성과 복잡한 웹 애플리케이션 처리 능력을 인정했습니다.\n- 미래를 위해 만들어진 (지속적인 관련성): 웹 개발 트렌드는 내가 점심에 뭘 시켜야 할지 바꾸는 것보다 빠르게 변합니다. 하지만 장고의 적응력은 전설적입니다. 강력한 데이터 처리, 매끄러운 API 생성 및 보안에 대한 집중은 소셜 미디어 사이트부터 심각한 데이터 주도 플랫폼까지 모든 분야에서 여전히 뛰어난 선택지임을 의미합니다.\n\n보셨나요? 장고는 단순히 살아남는 것이 아니라 경쟁하고 성공을 거두고 있습니다. 비판하는 사람들은 그들의 Clickbait 제목을 쓸 테니 우리는 계속 이 지속적으로 발전하는 프레임워크로 멋진 것들을 만드는 데 바쁠 거에요.\n\n<div class=\"content-ad\"></div>\n\n## 섹션 2: 좋아요, 코딩 방 안의 코끼리 얘기를 좀 해볼까요?\n\n알았어요, 고무단으로 가리지 않겠어요: 어떤 사람들은 Django가 멸종의 길로 가야 한다고 생각하고 있어요. 이들이 선호하는 몇 가지 이유들을 해결해보고 상황에 현실성을 추가해보겠습니다:\n\n- 눈부신 새로운 장난감 (다른 프레임워크의 유혹): “자바스크립트가 더 핫해! React가 더 빠르다! FastAPI가 미래야!” 그렇지만, 새로운 기술은 흥미롭지만 자동적으로 오래된 기술을 구식으로 만들지 않아요. 서로 다른 도구들은 서로 다른 강점을 가지고 있어요. 복잡한 데이터베이스와 원활하게 작동하는 견고한 백엔드가 필요하다면, Django가 종종 많은 최첨단 옵션들에 밀리지 않을 수 있어요.\n- 확장의 고민 (단일체의 신화): 막대한 Django 앱을 확장하는 것은 까다로울 수 있다는 것이 사실이에요. 그러나 알고 계세요? 특정 규모에 도달했을 때 어떤 프레임워크든 그렇다는 건 사실이에요. 스마트한 설계 선택, 캐싱, 그리고 부하 분산은 여기서 친구입니다—어떤 기술 스택을 사용하든 말이죠. 여기 Django 커뮤니티가 빛을 발하는 곳입니다: 이러한 도전에 직면한 개발자들이 이를 해결하는 해법을 즐겁게 공유하고 있습니다.\n\n```js\n# 예시: 데이터베이스 부하를 줄이기 위해 캐싱 사용 \nfrom django.core.cache import cache\n\ndef get_trending_topics(request):\n    trending_topics = cache.get('trending_topics')\n    if not trending_topics:\n       trending_topics = calculate_trending_topics()  # 시간이 많이 걸리는 작업\n       cache.set('trending_topics', trending_topics, 600)  # 10분 동안 캐싱\n   return render(request, 'trending.html', {'topics': trending_topics})\n```\n\n<div class=\"content-ad\"></div>\n\n- 균형 잡힌 시각 (장고가 빛을 발하는 곳): Django는 모든 웹 프로젝트의 마법 해결책은 아닙니다. 하지만 신속한 개발, 깔끔한 구조 및 견고한 신뢰성이 필요하다면 고려해볼 수 있는 옵션입니다. 스타트업, 뉴스 사이트, 내부 도구 등이 Django가 빛나는 영역입니다. 또한, 더 높은 성능을 끌어낼 수 있는 다양한 전략이 존재합니다.\n\n이 결론? 혹독한 하이프 사이클에 빠지지 마세요. Django가 우스꽝스럽게 여길 오래된 것이 아니라, 일을 멋지게 처리할 수 있는 성숙하고 전투에서 검증 받은 프레임워크입니다.\n\n## 섹션 3: Django의 크리스탈 볼 - 번창하는 미래를 내다봅니다\n\n\"Dying\" 예언에 대해 하나 더 말씀드리자면: Django의 자신을 새롭게 바꾸는 능력을 과소평가하고 있습니다. 이 프레임워크는 망가진 유명 세계 스타보다 더 많은 컴백을 계획 중입니다. 앞으로 무엇을 기대할 수 있을 지 엿보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n- 성능에 집중: 속도가 중요하고 Django 개발자는 이를 알고 있습니다. 지속적인 최적화가 기대되며, 각 릴리스마다 Django를 더 가볍고 효과적으로 만들기 위한 노력이 이어질 것입니다. 적은 노력으로 로드 밸런싱을 수행할 수 있는 내장 도구가 추가된다면 얼마나 좋을까요? 불가능한 일은 아닙니다!\n- 새로운 기술 수용: WebAssembly가 인기를 끌고 있나요? AI 기능이 게임을 바꾸고 있나요? Django는 이러한 변화를 효율적으로 통합하고 발전시킬 스마트한 방법을 찾을 것입니다. Django는 웹의 발전과 함께 성장하는 역사가 있습니다.\n- Django: 웹 개발의 스위스 아미 나이프: API 개발 및 통합과 같은 영역에 대한 관심이 증가함에 따라 Django는 더 다양한 프로젝트의 신뢰할 수 있는 핵심이 될 것입니다. 특정 niche를 대상으로 한 더 많은 특화된 '플레이버'들이 등장할 수도 있습니다.\n```js\n# Django REST Framework를 사용한 API 생성 예시\nfrom rest_framework import serializers, viewsets\nfrom .models import BlogPost\n\nclass BlogPostSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = BlogPost\n        fields = '__all__'\n\nclass BlogPostViewSet(viewsets.ModelViewSet):\n    queryset = BlogPost.objects.all()\n    serializer_class = BlogPostSerializer\n```\n- 이러한 점이 긍정적인 이유: Django는 능력이 증가하는 동안에도 사물을 간단하게 유지하는 능력이 있습니다. 이는 새로운 개발자를 유치함으로써(멋진 커뮤니티 확장!) 경험이 풍부한 사람들이 지속적인 학습 곡선에 직면하지 않도록 보장합니다. Django는 산업의 트렌드가 떠오르기를 바라며 적응하기 좋은 동물이며, 관건성을 유지하여 항상 적용 가능하게 유지합니다.\n\n파멸론자들이 선동성 기사에 집착하더라도, 우리 중 일부는 Django를 활용하여 놀라운 웹 경험의 다음 세대를 구축할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론: 장고는 계속해서 성장 중이며 당신도 그렇게 해야 합니다\n\n우리가 뭘 얘기하고 싶은지 말해 봅시다 — 장고는 그저 살아남는 것뿐만이 아니라 번창하고 있습니다. 이 프레임워크는 지속적인 업데이트가 이뤄지고 열정적인 커뮤니티가 뒷받침하며 실제 세계에서도 뛰어난 실력을 입증하고 있습니다.\n\n그 지겨운 \"장고가 죽었는가?\"라는 글들을 잊어버리세요. 더 나은 질문은 \"장고가 앞으로 어떻게 발전하며 성공할 것인가?\"라는 것입니다. 왜냐하면 그게 분명할테니까요.\n\n당신의 다음 행보: 이제 장고에 참여하는 방법을 알아보세요:\n\n<div class=\"content-ad\"></div>\n\n- 도전해 보세요: 아직 장고를 시도해 보지 않았나요? 키보드를 먼지 털고 초보 프로젝트에 도전해 보세요. 장고의 일 처리 태도에 사로잡힐지도 모르겠어요.\n- 클럽에 가입하세요: 장고 포럼에 참여하고, 디스코드에서 다른 개발자들과 연결해 보세요 (저 같이 함께하실래요? - https://discord.com/invite/JGTayeYnXs). 이 커뮤니티를 멋지게 만드는 모든 지식을 활용해 보세요.\n- 미래를 만드세요: 장고의 오픈 소스 마법 덕분에 다음 단계를 결정할 수 있어요. 멋진 기능 아이디어가 있나요? 기여해서 자신의 흔적을 남겨 보세요!\n\n장고의 이야기는 아직 끝나지 않았고, 여러분의 이야기는 지금부터 시작될 수 있어요. 우리가 다음에 함께 놀라운 응용 프로그램을 얼마나 만들 수 있을지 기대해 보세요.\n\n그런데… 제가 다룰 도저히 지치지 않는 질문이나 멋진 기사 아이디어가 있나요? 아래 댓글에 남겨 주세요! 그리고 친절하게도, Medium에서 (https://medium.com/@danielbuilescu) 제 팔로우도 눌러 주세요. 더 많은 프로그래밍 소식을 확인할 수 있을 거예요.\n\n# 쉬운 용어로 🚀\n\n<div class=\"content-ad\"></div>\n\n인 플레인 영어 커뮤니티의 일원이 되어 주셔서 감사합니다! 나가시기 전에:\n\n- 작가에게 박수를 보내고 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: 스택아카데믹 | 코피드 | 벤처 | 큐브드\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-27-IsDjangoDyingAnHonestLookattheFuture_0.png"},"coverImage":"/assets/img/2024-05-27-IsDjangoDyingAnHonestLookattheFuture_0.png","tag":["Tech"],"readingTime":6},{"title":"HCI 제1부 상호 작용을 형성하는 과소평가된 감각 - 촉각","description":"","date":"2024-05-27 19:22","slug":"2024-05-27-HCIPart1TheUnderratedSenseShapingOurInteractionsTouch","content":"\n\n인간-컴퓨터 상호작용 시리즈 첫 번째 기사에 오신 것을 환영합니다. 우리는 주변 세계와 상호작용하는 데 주로 시각과 청각을 생각합니다. 그러나 종종 간과되는 촉각은 우리의 일상생활과 기술과의 인터페이스 방법에서 중요한 역할을 합니다.\n\n![touch image](/assets/img/2024-05-27-HCIPart1TheUnderratedSenseShapingOurInteractionsTouch_0.png)\n\n촉각은 단지 물체의 질감을 느끼는 것 이상입니다. 피부 표면(온도, 압력)의 감각과 자기 지각, 우리 몸이 공간에서의 위치와 움직임을 인식하는 것이 결합된 것입니다. 이 복잡한 감각은 컵을 집거나 가상 현실 세계를 탐험하는 것처럼 단순한 행동부터 복잡한 행동까지 수행할 수 있게 합니다.\n\n# 사용자 인터페이스에서의 촉각의 힘\n\n<div class=\"content-ad\"></div>\n\nUI(사용자 인터페이스)의 영역에서 터치는 중요한 역할을 합니다. 스마트폰 화면 위에서 손가락이 부드럽게 움직이는 것부터 물리적 버튼을 눌렀을 때의 쾌적한 감쇠 소리까지, 터치 상호작용은 사용성과 사용자 경험을 향상시킬 수 있습니다. 진동이나 힘 피드백을 사용하여 촉감을 만드는 햅틱스는 상호작용에 또 다른 층을 더해줍니다.\n\n다음은 UI 디자인에서 터치가 어떻게 사용되는지와 UI/UX 디자이너 및 프런트엔드 엔지니어를 위한 실용적인 고려 사항과 함께 예시 몇 가지입니다:\n\n## 진동 알림:\n\n메시지나 전화 알림을 통지하는 핸드폰의 익숙한 진동 경고는 햅틱스의 기본이지만 효과적인 활용 사례입니다.\n\n<div class=\"content-ad\"></div>\n\nUI/UX 고려사항: 디자이너는 진동 알림이 섬세하면서도 눈에 띄게 되도록 설계해야 합니다. 사용자가 혼란스럽거나 압도당하지 않도록 주의해야 합니다. 엔지니어들은 다양한 알림을 위한 다른 진동 패턴을 만들기 위해 햅틱 피드백 API를 구현할 수 있습니다.\n\n## 질감 있는 가상 버튼\n\n물리적 버튼의 느낌을 모방하여 섬세한 진동을 이용하면 터치 스크린 사용의 정확도와 만족도가 향상될 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*j947PelqqZbU_U4iWIrhsw.gif)\n\n<div class=\"content-ad\"></div>\n\nUI/UX 고려 사항: 디자이너들은 조금 불투명도가 변화하거나 섬세한 엠보싱과 같은 질감 있는 버튼을 나타내는 시각적 단서를 만들 수 있습니다.\n\n## 대화식 슬라이더\n\n조절 중에 햅틱 피드백을 제공하는 슬라이더는 사용자의 제어와 정밀도를 향상시킬 수 있습니다.\n\nUI/UX 고려 사항: 디자이너들은 슬라이더의 범위와 현재 값이 나타나는 명확한 시각적 단서를 사용해야 합니다. 엔지니어들은 슬라이더가 한계에 다다를 때 강도가 증가하는 햅틱 피드백을 통합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 대상 크기 및 간격\n\n클릭 가능한 대상(버튼, 메뉴 항목) 사이의 적절한 크기와 간격은 모바일 기기에서 정확한 터치 상호작용을 위해 중요합니다.\n\n![이미지](/assets/img/2024-05-27-HCIPart1TheUnderratedSenseShapingOurInteractionsTouch_1.png)\n\nUI/UX 고려 사항: 디자이너는 기기 유형 및 사용자 연구에 따라 권장되는 터치 대상 크기를 준수해야 합니다. 프런트엔드 엔지니어는 상호작용 요소 사이의 적절한 간격을 보장하는 라이브러리나 프레임워크를 구현할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 나쁜 예 및 그를 피하는 방법\n\n## 부정확한 터치 대상\n\n작은 버튼이나 잘 조정되지 않은 터치 스크린은 분노와 놓친 클릭으로 이어질 수 있습니다.\n\n해결책: 터치 대상의 크기를 키우고 디자인 중 적절한 간격을 유지하십시오.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-HCIPart1TheUnderratedSenseShapingOurInteractionsTouch_2.png\" />\n\n## 너무 복잡한 햅틱:\n\n너무 세고 부정확하며 화면 상의 동작과 일치하지 않는 햅틱 피드백은 혼란을 초래할 수 있으며 주의를 산만하게 만들 수 있습니다.\n\n해결책: 디자이너들은 명확성을 우선시하고 다양한 진동 패턴을 사용자들과 테스트해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 터치 기술의 미래\n\n터치 기술의 세계는 끊임없이 발전하고 있습니다. 기대할만한 몇 가지 신기한 발전들이 있습니다:\n\n- 울트라햅틱스: 이 기술은 초음파를 사용하여 공중에서 촉각을 만들어 가상 현실 경험을 혁신할 수 있습니다.\n\n- 모양 변화 재료: 터치에 따라 물리적으로 변형되는 인터페이스를 상상해 보세요. 이는 새로운 수준의 상호작용을 제공할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-27-HCIPart1TheUnderratedSenseShapingOurInteractionsTouch_3.png)\n\n이러한 기술이 발전함에 따라 UI 디자이너들은 더 많은 도구를 활용하여 직관적이고 매혹적인 사용자 경험을 만들어낼 수 있습니다.\n\n# 결론: 터치의 미래를 위한 디자인\n\n터치는 단순히 신체적 감각 이상의 것이며, 세계와 상호작용하는 방법에 대한 창이기도 합니다. 터치의 복잡성을 이해하고 새로운 기술을 받아들이면, UI/UX 디자이너 및 프론트엔드 엔지니어는 기능성 뿐만 아니라 직관적이고 쾌활하게 느껴지는 인터페이스를 만들어낼 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n터치의 미래는 흥미로운 가능성을 약속합니다. 공중에서의 햅틱 피드백부터 형태를 변화시키는 소재까지, 디지털과 물리적 사이의 경계가 흐려지고 있습니다. 이러한 발전이 계속되면, 우리는 상상할 수만 있던 방식으로 터치의 힘을 활용한 더욱 풍부하고 몰입적인 사용자 경험을 기대할 수 있을 겁니다.\n\n그래서 다음 번에 스마트폰을 사용하거나 가상 세계를 탐험할 때, 그 경험의 토대가 되는 터치의 무성의 심포니를 한 순간이나마 감상해 보세요. 이 강력한 감각을 이용하여 우리의 삶에 기술이 자연스럽게 통합되는 미래를 디자인할 수 있습니다. 그것은 우리 자신의 연장으로 느껴지는 것처럼 자연스러울 것입니다.\n\n# 나의 참고문헌","ogImage":{"url":"/assets/img/2024-05-27-HCIPart1TheUnderratedSenseShapingOurInteractionsTouch_0.png"},"coverImage":"/assets/img/2024-05-27-HCIPart1TheUnderratedSenseShapingOurInteractionsTouch_0.png","tag":["Tech"],"readingTime":4},{"title":"Dart에서 Annotations 사용하는 방법","description":"","date":"2024-05-27 19:20","slug":"2024-05-27-ExploringAnnotationsinDartProgramming","content":"\n![Exploring Annotations in Dart Programming](/assets/img/2024-05-27-ExploringAnnotationsinDartProgramming_0.png)\n\nDart에서 주석은 개발자가 코드에 메타데이터를 추가할 수 있는 기능입니다. 이 메타데이터는 도구, 라이브러리 및 런타임에서 코드 생성, 유효성 검사 및 문서화와 같은 다양한 작업을 수행하는 데 사용될 수 있습니다. 이 블로그에서는 Dart에서 주석이 작동하는 방법, 사용 방법 및 사용자 정의 주석을 만드는 방법을 살펴보겠습니다.\n\n## Annotations이란?\n\nDart에서 주석은 클래스, 메서드, 필드 등과 같은 다양한 프로그램 요소에 첨부할 수 있는 메타데이터 형식입니다. 컴파일러 또는 런타임에서 처리될 수 있는 추가 정보를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n다트(Dart)에서 어노테이션은 상수 값이나 생성자 호출을 참조하는 '@' 기호로 표현됩니다. 이 값은 타입(type), 클래스의 인스턴스(instance) 또는 리터럴(literal)일 수 있습니다.\n\n## 일반적인 사용 사례\n\n- 문서화: 어노테이션은 자동으로 문서를 생성하는 데 사용될 수 있습니다.\n- 코드 생성: build_runner와 같은 도구는 어노테이션을 사용하여 생성된 보일러플레이트 코드를 생성합니다.\n- 유효성 검사: 어노테이션은 데이터 유효성 검사 또는 코딩 표준 적용에 도움을 줄 수 있습니다.\n\n## 내장된 어노테이션\n\n<div class=\"content-ad\"></div>\n\nDart는 몇 가지 내장 주석을 제공합니다:\n\n- @override: 메서드가 수퍼 클래스의 메서드를 재정의하기 위해 의도된 것을 나타냅니다.\n- @deprecated: 기능을 사용하지 말아야 함을 나타내어 폐기 예정으로 표시합니다.\n\n```js\nclass Parent {\n  void doSomething() {\n    print('Parent에서 작업 중');\n  }\n}\n\nclass Child extends Parent {\n  @override\n  void doSomething() {\n    print('Child에서 작업 중');\n  }\n}\n\nvoid main() {\n  var child = Child();\n  child.doSomething();  // 출력: Child에서 작업 중\n}\n```\n\n## 사용자 정의 주석 만들기\n\n<div class=\"content-ad\"></div>\n\n다트(Dart)에서 사용자 정의 어노테이션을 만드는 것은 간단합니다. 어노테이션을 클래스로 정의한 후에 인스턴스화하면 됩니다.\n\n다음은 사용자 정의 어노테이션의 예시입니다:\n\n```js\n// 사용자 정의 어노테이션 클래스\nclass RequiresPermission {\n  final String permission;\n  const RequiresPermission(this.permission);\n}\n\n// 권한 상수\nconst String INTERNET_PERMISSION = \"인터넷\";\nconst String CAMERA_PERMISSION = \"카메라\";\n\n// RequiresPermission 어노테이션을 사용한 예시 클래스\nclass NetworkService {\n  @RequiresPermission(INTERNET_PERMISSION)\n  void fetchData() {\n    // 인터넷에서 데이터 가져오기\n    print(\"인터넷에서 데이터 가져오는 중...\");\n  }\n\n  void localDataProcessing() {\n    // 로컬 데이터 처리\n    print(\"로컬 데이터 처리 중...\");\n  }\n}\n\nclass CameraService {\n  @RequiresPermission(CAMERA_PERMISSION)\n  void takePicture() {\n    // 카메라를 사용하여 사진 찍기\n    print(\"사진 찍는 중...\");\n  }\n\n  void processImage() {\n    // 이미지 처리\n    print(\"이미지 처리 중...\");\n  }\n}\n\n// 예시 사용법\nvoid main() {\n  NetworkService networkService = NetworkService();\n  CameraService cameraService = CameraService();\n\n  // 메소드 호출 전 권한 확인하는 예시\n  if (hasPermission(INTERNET_PERMISSION)) {\n    networkService.fetchData();\n  } else {\n    print(\"인터넷 권한이 필요합니다.\");\n  }\n\n  if (hasPermission(CAMERA_PERMISSION)) {\n    cameraService.takePicture();\n  } else {\n    print(\"카메라 권한이 필요합니다.\");\n  }\n\n  networkService.localDataProcessing();\n  cameraService.processImage();\n}\n\n// 더미 권한 확인 함수\nbool hasPermission(String permission) {\n  // 실제 권한 확인하는 부분\n  // 이 예시에서는 모든 권한이 허용된 것으로 가정합니다\n  return true;\n}\n```\n\n이 예시에서:\n\n<div class=\"content-ad\"></div>\n\n- `RequiresPermission` 커스텀 어노테이션이 정의되었으며 이 어노테이션은 권한 문자열을 가져옵니다.\n- `NetworkService` 클래스에는 `@RequiresPermission`으로 어노테이트된 메서드들이 있어서 `fetchData` 메서드가 인터넷 권한이 필요하다는 것을 나타냅니다.\n- `CameraService` 클래스에는 `@RequiresPermission`으로 어노테이트된 메서드들이 있어서 `takePicture` 메서드가 카메라 권한이 필요하다는 것을 나타냅니다.\n- 주요 함수는 이러한 어노테이트된 메서드들을 호출하기 전에 권한을 확인하여, 실행 전에 필요한 권한이 부여되었는지를 확인합니다.\n\n우리의 지식을 공유하여 커뮤니티를 더 강하게 만들어가요. 최신 웹 및 모바일 기술 분야에서 업데이트된 정보를 얻기 위해 저와 제 팀을 팔로우해주세요.\n","ogImage":{"url":"/assets/img/2024-05-27-ExploringAnnotationsinDartProgramming_0.png"},"coverImage":"/assets/img/2024-05-27-ExploringAnnotationsinDartProgramming_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터에서 흔히 하는 로컬라이제이션 실수 방지하는 방법","description":"","date":"2024-05-27 19:19","slug":"2024-05-27-AvoidingcommonlocalizationmistakesinFlutterbestpracticesandsolutions","content":"\n완벽한 로컬라이제이션을 달성하려면 번역만으로는 충분하지 않습니다. 언어적 뉘앙스와 지역적 선호도를 신중히 고려해야 합니다. 이 글에서는 Flutter 앱 로컬라이제이션 중에 생길 수 있는 일반적인 오류들과 그것들을 극복하기 위한 효과적인 전략을 탐구해보겠습니다.\n\n## 1. 하나의 문장을 연결하여 다른 문자열 항목을 사용하는 것.\n\n다음 문장을 예시로 들어보겠습니다:\n\n강조된 부분은 다른 텍스트 스타일을 가지고 클릭할 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n많은 사람들이 종종 여러 항목으로 나누어서 TextSpan을 연결합니다. 이 해결책은 영어에는 작동하지만 앱의 다른 언어에도 적용될 수 있습니다. 그러나 문제는 문법 격조나 다른 단어 순서를 가진 언어와 작업할 때 발생합니다.\n\n문제가 어디에서 발생하는지 분석해보겠습니다.\n\n저는 +약관+과 +개인정보 처리방침+에 동의합니다.\n\n에스토니아어로 동일한 문장을 작성하면 다음과 같이 됩니다:\n\n<div class=\"content-ad\"></div>\n\n병적으로 이용약관 및 개인정보 보호 정책에 동의합니다\n\n단어 순서는 똑같아. 괜찮잖아? 같은 이름의 화면 제목으로 이용약관 항목을 재사용하면 참 괜찮을 것 같지? 영어로 돌리면 완벽히 작동하지만, 에스토니아어로 하면 \"약관과 함께\"라는 의미가 나올거야. 인가로 끝나서 \"약관\" 대신 \"약관과\"라는 뜻이 날거야. 다른 문제는, 각각의 항목을 번역하면서 전체 문장의 맥락을 손실하기도 굉장히 쉬워. 그리고 띄어쓰기가 사라지는 것도 말이야.\n\n일부 언어에서는 다른 단어 순서를 가질거야. 예를 들어, 독일어에서:\n\n처음에 만든 솔루션이 이걸 지원하지 않아. 개인정보 보호 정책 단어 다음에 텍스트가 있는데 거기에 추가 텍스트 스팬을 더해야 돼. 머리가 아플 것 같아?\n\n<div class=\"content-ad\"></div>\n\n솔루션: 태그된 로컬라이제이션 항목을 사용하세요. 예를 들어, styled_text 패키지를 사용하면 문자열에 사용자 정의 태그를 추가한 다음 코드에서 처리할 수 있습니다:\n\n\"agreeWithTerms\": \"나는 `a action=`OPEN_TC`` 약관 및 조건`/a`, `a action=`OPEN_PP ``개인정보 보호정책`/a`을 읽었으며 동의합니다\"\n\n이 문제 때문에 맷테오게코의 이 라이브러리 포크를 사용하는 것을 권장합니다. 더 나은 해결책을 아시는 경우 댓글로 알려주세요.\n\n```js\ndependencies: styled_text: git: ref: bd403bd6c7c7df422b8d13e14b995662818fd9a9;\nurl: //github.com/Maatteogekko/styled_text_package.git\nhttps: path: styled_text;\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 코드에 그겨되어 있을 것입니다:\n\n```js\n      StyledText(\n        text: t.agreeWithTerms,\n        style: Theme.of(context).textTheme.bodyMedium,\n        tags: {\n          'a': StyledTextActionTag(\n            (String? text, Map<String?, String?> attrs) {\n              final action = attrs['action'];\n              switch (action) {\n                case 'OPEN_TC':\n                  _openTC();\n                case 'OPEN_PP':\n                  _openPP();\n              }\n            },\n            style: Theme.of(context).textTheme.bodyMedium!.copyWith(\n                color: Theme.of(context).primaryColor,\n                decoration: TextDecoration.underline),\n          )\n        },\n      )\n```\n\n그 결과는 다음과 같이 나옵니다:\n\n<img src=\"/assets/img/2024-05-27-AvoidingcommonlocalizationmistakesinFlutterbestpracticesandsolutions_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 2. 복수형 무시하거나 사용자 정의 로직을 적용하여 처리하기\n\n예를 들어 다음과 같은 문장이 있다고 가정해 봅시다:\n\n만약 사용자가 한 명뿐이라면, \"1명의 사용자가 온라인 상태입니다.\"라고 표시해야 합니다. 그냥 코드에 조건을 추가하면 될 것 같지 않나요? (n==1)이면 다른 문자열을 사용하도록 하는 것이나, 더 간단하게 \"N명의 사용자\" 문자열을 사용하는 방법이 어떨까요? 이 방법은 영어의 경우에 완벽하게 작동할 것입니다.\n\n하지만 러시아어를 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n1명 온라인\n\n2명 온라인\n\n5명 온라인\n\n21명 온라인\n\n<div class=\"content-ad\"></div>\n\n아랍어는 더 복잡해요.\n\n다행히도 복수화 표준이 있습니다. 유니코드 웹사이트에서 자세히 읽을 수 있어요. 또한 이 기사는 일부 인기 있는 언어에서 복수 범주가 어떻게 나타나는지 보여줍니다.\n\n요약하자면, 앱에 있는 모든 언어에 대해 적절한 복수 범주를 제공해야 해요.\n\n```js\n\"usersOnline\": {\n    \"one\": \"$n명의 사용자가 온라인 상태입니다\",\n    \"other\": \"$n명의 사용자가 온라인 상태입니다\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n    \"usersOnline\": {\n        \"one\": \"$n 명의 사용자 온라인\",\n        \"few\": \"$n 명의 사용자 온라인\",\n        \"many\": \"$n 명의 사용자 온라인\",\n        \"other\": \"$n 명의 사용자 온라인\"\n    }\n```\n\n나는 복수형을 구현하는 데 slang 패키지를 사용하고 있어:\n\n```js\nText(t.usersOnline(n: 3)),\n```\n\n그 결과로 문법적으로 올바른 복수형을 얻게됩니다. POEditor와 같은 온라인 편집기도 이를 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. 날짜와 시간을 수동으로 형식 지정하고, 월의 이름과 요일의 이름을 하드코딩하기\n\n그것은 매우 흔한 실수입니다. 서로 다른 지역에는 날짜 형식이 다릅니다. 요일을 줄이는 규칙도 다릅니다.\n\n예를 들어 핀란드에서 시간과 분은 점으로 구분됩니다. 에스토니아에서는 요일을 1자로 표시합니다. 미국에서는 날짜에 월이 먼저 나온다는 점도 언급할 수 없겠네요. 이런 모든 것들을 고려하면서 날짜와 시간을 다룬다는 것은 상당히 어려운 일처럼 보입니다. 다행히도 모든 것이 다시 표준화되었습니다. intl 패키지를 사용해봅시다.\n\n기본적으로 DateFormat은 앱에서 사용되는 로캘을 사용하지만 데모 목적을 위해 특정 로캘을 명시하여 출력을 확인할 수 있습니다. TimeOfDay는 컨텍스트에서 로캘을 가져옵니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfinal date = DateTime.now();\nformat(String locale) => \"$locale: ${DateFormat.yMMMEd(locale).format(date)}\";\nprint(format(\"en_US\"));\nprint(format(\"en_GB\"));\nprint(format(\"et_EE\"));\nprint(format(\"fi_FI\"));\nprint(format(\"ar_QA\"));\nprint(TimeOfDay.now().format(context));\n```\n\nThe output:\n\n```js\nflutter: en_US: Tue, May 21, 2024\nflutter: en_GB: Tue, 21 May 2024\nflutter: et_EE: T, 21. mai 2024\nflutter: fi_FI: ti 21. toukok. 2024\nflutter: ar_QA: الثلاثاء، ٢١ مايو ٢٠٢٤\nflutter: 13:24\n```\n\n## 4. Concatenating currency and price strings\n\n<div class=\"content-ad\"></div>\n\n어떤 국가에서는 천 단위 구분으로 콤마를 사용하는 반면, 다른 국가에서는 점을 사용합니다. 이런 작은 변화가 앱에 영향을 줄 수도 있어요.\n\n```js\nString formatCurrency(String currency, String amount) => currency + amount;\n```\n\n<div class=\"content-ad\"></div>\n\n지금은 intl 패키지를 사용하여 통화를 다루는 방법을 살펴보겠습니다:\n\n```js\nprint(NumberFormat.simpleCurrency(locale: 'en_US', name: 'USD').format(199.99));\nprint(NumberFormat.simpleCurrency(locale: 'en_GB', name: 'GBP').format(199.99));\nprint(NumberFormat.simpleCurrency(locale: 'es_ES', name: 'EUR').format(199.99));\n```\n\nNumberFormat.simpleCurrency는 기본적으로 앱의 로캘을 사용합니다. 여기서는 데모를 위해 몇 가지 특정 로케일을 전달하고 있습니다. 결과는 다음과 같습니다:\n\n```js\nflutter: $199.99\nflutter: £199.99\nflutter: 199,99 €\n```\n\n<div class=\"content-ad\"></div>\n\n또한, 짧고 명확한 형식이 있습니다. 가장 일반적인 사용 사례는 판매 중인 상품 목록이나 쇼핑 카트에서 짧은 형식을 표시하는 것입니다. 그리고 명시적 형식은 체크아웃 중에 사용해야 합니다. 이에 대해 더 읽어 보려면 Shopify의 이 기사를 확인하세요.\n\n이게 왜 중요할까요? 가렌다인 사용자가 앱을 열고 달러 기호가 있는 가격을 보는 상황을 상상해보세요. 사용자는 실제로 미국 달러가 아니라 캐나다 달러로 지불하고 있는지 확신하고 싶어할 것입니다. 이를 간단한 함수를 사용하여 수행할 수 있습니다:\n\n```js\nString explicitFormat(String currencyCode, String? locale, num amount) {\n    final shortFormat = NumberFormat.simpleCurrency(locale: locale, name: currencyCode).format(amount);\n\n    return \"$shortFormat $currencyCode\";\n}\n```\n\n이 기사가 유익했기를 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n오른쪽에서 왼쪽으로 (RTL/LTR) 케이스와 서로 다른 측정 시스템을 다루지 않았어요. 별도의 기사를 쓸 가치가 있어요. 업데이트를 받으시려면 구독을 확인해주세요.\n\n![이미지](/assets/img/2024-05-27-AvoidingcommonlocalizationmistakesinFlutterbestpracticesandsolutions_1.png)\n","ogImage":{"url":"/assets/img/2024-05-27-AvoidingcommonlocalizationmistakesinFlutterbestpracticesandsolutions_0.png"},"coverImage":"/assets/img/2024-05-27-AvoidingcommonlocalizationmistakesinFlutterbestpracticesandsolutions_0.png","tag":["Tech"],"readingTime":6}],"page":"56","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}