{"pageProps":{"posts":[{"title":"파이썬, Jinja2, Weasyprint를 사용한 인보이스 생성기 만들기","description":"","date":"2024-06-23 14:41","slug":"2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint","content":"\n\n프리랜서 프로젝트로 작은 작업을 부탁받을 때는 어떻게 하시나요?\n\n고객에게 할 작업과 해당 작업에 대한 비용을 나열한 송장을 작성합니다. 이를 통해 작업 범위를 세부적으로 설명하고 해당 비용에 대해 투명하게 고객에게 알림을 줍니다. 이는 비즈니스 거래에서 명확성과 공정성에 대한 당신의 헌신을 보여줍니다.\n\n프리랜서 고객과 거래할 때 전문성에 기여하는 다른 요소들이 많지만, 실제로 신경 쓸 필요가 없는 기능으로 여러 기능이 넘치는 완벽한 송장 솔루션 대신 사용할 도구로 이것을 선택했습니다.\n\n이 작업을 위한 빠르고 간편한 솔루션이 필요했기 때문에 이 스크립트를 만들었고, 정확히 어떻게 만들었는지 보여드릴게요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint_0.png\" />\n\n# 랜드스케이프\n\n저는 단순함을 유지하고 싶었어요... 정말 한없이 단순하게. 보통 제가 하는 것과 같이 OOP 방식을 선택하는 대신 함수를 만들었어요. 그러나 다소 사용자 정의할 수 있도록 하기 위해 invoice를 설정하는 방법에 대한 구성이 담긴 settings.py를 추가했어요.\n\ninvoice 자체는 jinja2 구문으로 작성된 HTML 파일입니다. 이 템플릿에 렌더링되는 데이터는 data.json에서 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n당연히 나는 render_template()를 팩토리로 사용하는 원시적인 팩토리 디자인 패턴을 선택했고 이는 invoice_gen.py 내에 있습니다.\n\n각 파일이 의도된 용도는 다음과 같습니다:\n\n- data.json 👉 Jinja 템플릿으로 렌더링 될 데이터를 포함합니다.\n- invoice_gen.py 👉 팩토리로 작용하여 송장을 생성하는 스크립트 파일입니다.\n- settings.py 👉 HTML 템플릿의 구성을 포함합니다.\n\n조금 더 이해하기 쉽게 하기 위해 아래 다이어그램에서 어떻게 작동하는지 설명했습니다:\n\n<div class=\"content-ad\"></div>\n\n# 기술\n\n다음을 사용하고 있습니다:\n\n- Jinja\n- WeasyPrint\n\n# 데이터 파일\n\n<div class=\"content-ad\"></div>\n\n이건 저희가 템플릿에 렌더링하려는 모든 정보를 포함한 JSON 파일입니다. 제 파일은 다음과 같은 형식을 가지고 있어요:\n\n```js\n{\n    \"title\": \"서비스 청구서\",\n    \"invoiceNumber\": 13,\n    \"issueDate\": \"2023년 11월 12일\",\n    \"dueDate\": \"2023년 12월 18일\",\n    \"status\": \"만기\",\n\n...\n\n    \"server\": {\n        \"logo\": \"로고/경로.png\",\n        \"companyName\": \"Hammad의 회사\",\n        \"firstName\": \"M. Hammad\",\n        \"lastName\": \"Hassan\",\n        \"address\": {\n            \"city\": \"신드주 카라치\",\n            \"country\": \"파키스탄\"\n        },\n        \"email\": \"hammad.hassan@localhost.com\",\n        \"profileURL\": {\n            \"url\": \"https://www.upwork.com/freelancers/~01f9b5bc6f481f0385\",\n            \"displayText\": \"Upwork의 Hammad\"\n        }\n    },\n    \"itemList\": [\n        {\n            \"title\": \"파이썬 코스\",\n            \"description\": \"시작하기에 좋은 파이썬 기초 코스\",\n            \"isFixedPrice\": false,\n            \"rate\": 10,\n            \"hours\": 15\n        },\n        {\n            \"title\": \"HTML/CSS/JS\",\n            \"description\": \"초보자용 프론트엔드 코스\",\n            \"isFixedPrice\": false,\n            \"rate\": 6,\n            \"hours\": 10\n        }\n    ],\n    \"moderatorCharges\": 0.1,\n    \"percentIncreaseAfterDueDate\": 0.05\n\n...\n\n}\n```\n\n위의 JSON 파일은 제가 사용하는 실제 파일의 간략한 버전입니다.\n\n# 주요 스크립트\n\n<div class=\"content-ad\"></div>\n\ndata.json 파일에 정의된 데이터 세트에서 송장을 생성하는 프로세스는 송장을 만들기 위해 여러 리소스를 사용합니다. 클라이언트에게 보낼 수 있는 송장을 생성합니다.\n\n먼저 의존성을 가져와야 합니다.\n\n```js\nfrom jinja2 import Template\nimport json\n```\n\n그런 다음, Jinja HTML 템플릿에 일부 컨텍스트를 삽입하는 함수를 작성하고 나중에 이러한 템플릿을 pdf로 변환할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```python\ndef render_template(\n    template_file: str, \n    context: dict, \n    styles: list, \n    output_filename: str\n) -> str:\n    \n    # 템플릿 파일을 가져와 컨텍스트 변수를 사용하여 렌더링합니다.\n    template = Template(template_file)\n    rendered_html = template.render(context)\n\n    # 출력 파일의 이름을 설정합니다.\n    html_file = f\"{output_filename}.html\"\n    pdf_file = f\"{output_filename}.pdf\"\n\n    # HTML 콘텐츠를 파일에 기록합니다.\n    with open(html_file, 'w') as file:\n        file.write(rendered_html)\n\n    # WeasyPrint를 사용하여 HTML을 PDF로 변환합니다.\n    HTML(html_file).write_pdf(pdf_file, stylesheets=styles)\n\n    # 파일 이름을 반환합니다.\n    return pdf_file\n```\n\n이제 동일한 스크립트 파일 내에서 템플릿을 렌더링하는 데 필요한 에셋을 로드합니다.\n\n```python\n# 컨텍스트 데이터 로드\ncontext_data = {}\nwith open(\"./data.json\") as data:\n    context_data = get_context_data(json.load(data))\n    \n# Jinja 템플릿 로드\ntemplate_html = \"\"\nwith open(TEMPLATE_HTML_PATH) as template:\n    template_html = template.read()\n\n# 템플릿을 렌더링하고 PDF를 생성합니다.\npdf_filename = render_template(template_html, context_data, TEMPLATE_CSS, OUTPUT_FILENAME)\nprint(f\"PDF 생성됨: {pdf_filename}\")\n```\n\nget_context_data() 함수에서 컨텍스트 데이터를 불러오고, 이 함수는 settings.py에 위치합니다. 이 함수는 파이썬 딕셔너리 하나를 매개변수로 받습니다. 이 딕셔너리는 data.json에서 가져옵니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 또한 Jinja 템플릿(HTML 파일)을 로드하고 'with' 키워드와 'open' 함수를 사용하여 내용을 읽습니다. TEMPLATE_HTML_PATH는 settings.py에서 왔는데, 이는 다음 섹션에서 설명됩니다.\n\n마지막으로, 우리는 render_template() 함수를 호출하여 그 마법을 일으킵니다.\n\n# 설정 파일\n\n이 파일에는 스크립트의 모든 사용자 정의 가능한 부분이 포함되어 있습니다. 따라서 위에서 언급한 스크립트의 결과를 변경하고 싶다면, 이 파일을 변경하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n의존성을 가져오세요. 이제 weasyprint가 포함되어 있습니다.\n\n```js\nfrom weasyprint import HTML, CSS\nfrom datetime import datetime\n```\n\n이 파일에는 변수 3개와 함수 하나만 포함되어 있습니다.\n\n```js\nOUTPUT_FILENAME = f\"output-{datetime.now().strftime('%d-%b-%Y')}\"\nTEMPLATE_HTML_PATH = \"./invoice_template_002.html\"\n\nTEMPLATE_CSS = [\n    CSS(\"./invoice_template_002.css\"),\n    CSS(\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css\" ),\n    CSS(\"https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css\" )\n]\n```\n\n<div class=\"content-ad\"></div>\n\n첫 두 변수는 설명이 분명하기 때문에 그에 대해 많은 시간을 낭비하지 않을 겁니다.\n\n그러나 TEMPLATE_CSS는 weasyprint 라이브러리에서 가져온 CSS 개체의 목록입니다.\n\n이 목록에는 필요한 만큼 많은 CSS 모듈을 추가할 수 있으며 모두 HTML 템플릿에 적용됩니다.\n\n이 목록의 첫 번째 요소는 제 개인적인 사용자 정의 CSS이므로 상대 경로를 갖고 있습니다. 다른 두 개는 Bootstrap 및 Font Awesome CDNs에서 가져온 링크입니다.\n\n<div class=\"content-ad\"></div>\n\n```python\ndef get_context_data(context_json:dict)->dict:\n    \"\"\"이 함수는 data.json에서 가져온 컨텍스트를 조작합니다.\"\"\"\n    context_json['issueDate'] = datetime.strptime(context_json['issueDate'], '%d-%m-%Y').strftime('%d-%m-%Y')\n    context_json['dueDate'] = datetime.strptime(context_json['dueDate'], '%d-%m-%Y').strftime('%d-%m-%Y')\n    context_json['invoiceDate'] = datetime.strptime(context_json['issueDate'], '%d-%m-%Y').strftime('%B')\n    return context_json\n```\n\nget_context_data()는 정확히 그 이름이 의미하는 대로 동작합니다. 이 함수는 컨텍스트 데이터를 가져오고, 사용자가 해당 데이터를 조작할 수 있도록 해주며, 수식을 적용하고 계산을 수행한 다음 데이터를 Python 사전 형태로 반환합니다.\n\n나는 이 함수를 사용했는데, data.json에는 많은 정보가 있지만, 계산이 필요한 데이터를 넣지 않았기 때문이다. 예를 들어, 송장에 판매 중인 다양한 제품이 있을 수 있지만, 고객에게 청구하는 총 금액은 하드 코딩하는 대신 계산되어야 합니다.\n\n하지만 위의 함수에서 그중 어떤 것도 계산하지는 않았습니다. 그 이유는 저는 계산을 Jinja 템플릿 내에서 수행하기로 선택했기 때문입니다.\n\n\n<div class=\"content-ad\"></div>\n\n어찌되었든, 여기저기 숫자를 하드 코딩하진 않아요.\n\n너무 많은 공간을 차지하기 때문에 템플릿 파일은 여기에 포함하지 않겠습니다. 그러나 완전한 코드를 확인하려면 내 GitHub 저장소를 확인해주세요.\n\n# GitHub 저장소\n\n# 샘플 미리보기\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint_1.png\" />\n\n위는 제가 제공한 공장 코드로 할 수 있는 가능성 중 하나입니다. 예를 들어, 인증서를 만들거나 CSS로 스타일을 지정하고 data.json에 수령인의 이름을 넣을 수도 있습니다.\n\n즐겁게 사용하시기 바랍니다.\n\n만약 이 글이 도움이 되었고 새로운 것을 배웠다면 👏을 남겨주시거나 제게 알려주셔요 📣. 여러분의 피드백을 듣고 싶어합니다.","ogImage":{"url":"/assets/img/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint_0.png"},"coverImage":"/assets/img/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint_0.png","tag":["Tech"],"readingTime":7},{"title":"CSS에서 테두리 속성 다루는 방법","description":"","date":"2024-06-23 14:40","slug":"2024-06-23-EngineeringBorderPropertiesinCSS","content":"\n\n공학 (CSS)\n\n![EngineeringBorderPropertiesinCSS_0.png](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_0.png)\n\n## 테두리 속성\n\n- 테두리 속성을 사용하면 HTML 요소 주변에 테두리를 정의할 수 있습니다.\n- border-width\n- border-style\n- border-color\n- border-radius\n- border\n\n<div class=\"content-ad\"></div>\n\n# 테두리 너비:\n\n- '얇은', '보통', '두꺼운' 또는 구체적인 크기 (예: 2px, 0.1em 등)로 지정할 수 있습니다.\n\n# 테두리 색상:\n\n- 유효한 색상 값 중 하나 (예: 색 이름, 16진수, RGB, RGBA, HSL, HSLA 등)을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 테두리 스타일:\n\n- none, hidden, dotted, dashed, solid, double, groove, ridge, inset, outset 중 하나 가능\n\n# 위 속성에 대한 예시\n\n![이미지](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_1.png)\n\n<div class=\"content-ad\"></div>\n\n\n# Individual border sides:\n\n\n<div class=\"content-ad\"></div>\n\n- border-top: 상단 테두리를 설정합니다.\n- border-right: 우측 테두리를 설정합니다.\n- border-bottom: 하단 테두리를 설정합니다.\n- border-left: 좌측 테두리를 설정합니다.\n\n![EngineeringBorderPropertiesinCSS_5](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_5.png)\n\n![EngineeringBorderPropertiesinCSS_6](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_6.png)\n\n# border-radius:\n\n<div class=\"content-ad\"></div>\n\n- border-radius 속성을 사용하면 테두리에 둥근 모퉁이를 추가할 수 있습니다.\n- 모든 모퉁이에 적용하는 대신 다음 중 하나를 사용할 수 있습니다:\n  - border-top-left-radius\n  - border-top-right-radius\n  - border-bottom-right-radius\n  - border-bottom-left-radius\n\n![EngineeringBorderPropertiesinCSS_7](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_7.png)\n\n![EngineeringBorderPropertiesinCSS_8](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_8.png)\n\n# All in one\n\n<div class=\"content-ad\"></div>\n\n- `border` 속기 속성을 사용하면 요소의 테두리 너비, 스타일 및 색상을 한 번에 설정할 수 있습니다.\n\n![EngineeringBorderPropertiesinCSS_9](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_9.png)\n\n![EngineeringBorderPropertiesinCSS_10](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_10.png)","ogImage":{"url":"/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_0.png"},"coverImage":"/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_0.png","tag":["Tech"],"readingTime":2},{"title":"반응형 이미지와 동적 미디어 제대로 구현하기  Part III","description":"","date":"2024-06-23 14:37","slug":"2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII","content":"\n\n# 동적 미디어 및 HTML 5\n\n오늘날의 웹사이트는 다양한 기기에서 경험됩니다. 화면 크기는 물론 해상도, 방향 및 종횡비도 다양합니다.\n\n![ResponsiveImagingandDynamicMediadoneRightPartIII_0](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_0.png)\n\n다양한 기기를 위해 이미지를 다른 해상도와 포맷으로 제공해야 합니다. HTML5는 이를 어떻게 수행할 수 있는지에 대한 일부 힌트를 제공합니다. 그러나 표준은 다소 복잡하며 오류를 발생시키기 쉽습니다. 또한 HTML5는 약간 정적이며 AEM Dynamic Media를 사용할 때 활용할 수 있는 고급 렌더링 기능을 완전히 활용하지 못합니다.\n\n<div class=\"content-ad\"></div>\n\n이 글은 네 부분 시리즈의 세 번째 파트입니다. 시리즈는 아래와 같이 나뉘어 있습니다:\n\n- 첫 번째 파트: 반응형 이미징이란 무엇인가? 왜 필요한지 그리고 어떤 사용 사례가 있는지.\n- 두 번째 파트: AEM Dynamic Media를 사용하여 페이지 로딩 성능을 높이는 방법은?\n- 세 번째 파트: HTML 5로 Dynamic Media를 어떻게 구현할 수 있는가?\n- 네 번째 파트: HTML 5 이상: 사용자 정의 이미지 로더를 사용하여 페이지 로딩 시간을 단축하는 방법.\n\n# Responsive Images를 위한 HTML 마크업\n\n아직 여기 있나요? 멋지네요. 여태까지 오신 것을 기뻐해요. 이 장에서는 반응형 이미지의 HTML 부분에 중점을 둘 것입니다. HTML5 표준은 반응형 이미지를 지원하는 몇 가지 새로운 태그를 제공합니다. 경험 많은 웹 개발자라면 아마도 srcset 속성과 `picture` 태그를 이미 사용해 본 적이 있을 것입니다. 이것이 우리가 작업할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n앞서 이 태그들에 익숙하다 해도, 여기 머무르는 것을 초대해요. 이 마크업 유형에는 잘 알지 못하는 몇 가지 숨은 기능이 있을 수 있어요. 그리고 나중에는, 앱이나 정적 웹사이트에서 사용하는 기술이 콘텐츠 관리 시스템(CMS)에서 생성된 사이트에 적용 가능하지 않을 수도 있다고 주장할 거예요.\n\n# 유동 및 반응형 레이아웃의 이미지\n\n지금쯤이면 개별 이미지를 잘라내거나 크기 조절하는 방법을 알고 계실 거에요. 각 이미지는 개별 URL로 참조될 수 있어요. 그렇다면 브라우저는 어떤 URL을 특정 레이아웃에 사용해야 할지 어떻게 알 수 있을까요?\n\n이는 사용 사례에 따라 다릅니다. 설명하기 위해 몇 가지 전형적인 사용 사례를 다루는 간단한 레이아웃을 만들었어요. 이 레이아웃은 유동적이고 반응형입니다.\n\n<div class=\"content-ad\"></div>\n\n\"Fluid\"은 모든 너비 정의가 %로 되어 있음을 의미합니다. 브라우저 창의 크기를 줄이면 페이지 상의 모든 요소의 너비가 비례하여 줄어듭니다.\n\n\"반응형\": 어느 순간 – 전형적인 모바일 기기용 브레이크포인트에 도달하면 약간 다른 레이아웃이 적용됩니다. 즉, 다중 열 요소가 쌓이게 됩니다:\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_1.png)\n\n# 사용 사례들\n\n<div class=\"content-ad\"></div>\n\nA: 화면 너비의 100%를 차지하는 히어로 배너입니다. 크기는 실제 화면 너비에 맞게 조정됩니다. 모든 기기에서 종횡비 3:1이 동일합니다.\n\nB: 옆에 표시된 두 개의 작은 티저 구성 요소입니다. 이미지는 사용 가능한 너비의 50%를 차지하고 비례하여 확대됩니다. 좁은 화면을 가진 모바일 기기에서는 티저가 쌓이게 표시되며 화면 너비의 100%를 차지합니다. 종횡비 1:1이 동일합니다.\n\nC: 텍스트-이미지 구성 요소입니다. 데스크톱 해상도에서 이미지는 텍스트 오른쪽에 표시되며 뷰포트 너비의 33%를 차지합니다. 모바일 기기에서 이미지는 텍스트 위에 표시되며 종횡비가 1:1에서 3:1로 변경됩니다.\n\nD: 텍스트와 이미지가 있는 큰 티저입니다. 데스크톱에서 이미지는 화면 너비의 33%를 사용합니다. 모바일 화면에서 이미지는 쌓이고 화면 너비의 100%를 사용하며 3:1로 표시됩니다. 텍스트 이미지 구성 요소와 달리, 이미지의 높이는 가변적입니다. 이미지의 높이는 텍스트 블록의 높이에 따라 정의됩니다. 더 긴 복사 텍스트는 더 늘어진 형식을 유도합니다. 이미지는 모든 종횡비를 가질 수 있으며 미리 정의된 형식 중 하나에 부합되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n테스트 환경\n\n5 페이지에 간단한 테스트 페이지 세트를 준비해두었어요. 이를 따라가며 제 결과물을 검증할 수 있어요.\n\n여러 브라우저를 병렬로 사용하는 것을 추천해요. 각각 약간 다르게 작동하기 때문이에요. 새로운 개념을 익히기에는 Firefox가 최적이라고 생각해요. Chrome은 몇 가지 성능 최적화를 적용하고 핵심 기능을 가리는 특징이 있어요. 이 점이 약간 혼란스러울 수 있어요.\n\n실험을 위해 dummyimage.com을 사용하여 테스트 이미지를 생성하고 있어요. 이 이미지들은 내재적인 크기를 표시해요.\n\n<div class=\"content-ad\"></div>\n\ndummyimage.com에 차원 매개변수를 사용하여 요청을 보내면 이렇게 됩니다:\n\nhttps://dummyimage.com/300x100/000/fff\n\n이는 300x100 픽셀 이미지를 렌더링하고 이미지 콘텐츠로 차원을 표시합니다. 즉, 다음과 같이 됩니다:\n\n\n![image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n이것은 곧 유용할 것입니다.\n\n프로덕션에서는 물론 실제 이미지를 제공하는 Dynamic Media를 사용할 것입니다.\n\n## Hero 배너\n\n![Hero 배너](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_3.png)\n\n<div class=\"content-ad\"></div>\n\n간단한 확장 - 순진한 방법\n\n히어로 배너는 화면 너비의 100%를 차지합니다. 종횡비는 3:1입니다. 먼저 간단한 방법으로 시작해보죠. 웜업을 해봅시다. 간단한 `img` 태그를 사용해 봅시다:\n\n```js\n<style>\n  .hero{\n    width: 100%;\n  }\n…\n</style>\n\n<div class=\"hero\">\n  <img src=\"https://dummyimage.com/300x100/D3C8D9/000\" id=\"hero\" class=\"hero\"/>\n</div>\n```\n\n결과는 이와 같습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Responsive Image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_4.png)\n\nAlso, check out [this link](https://ackoch.github.io/image-zoo/001-hero-naive.html).\n\nIt looks like the image quality is not great. The image appears blurry because we are loading an image with an intrinsic size of 300x100, which is smaller than what your screen can handle in terms of pixel display.\n\nI've also included some additional metrics on the test page using JavaScript. You will see the total viewport width, the logical dimension of the image, and the physical dimension. The \"logical\" dimension is what the browser uses for layout calculations, while \"physical\" represents the actual pixel density of the screen. I am currently using a MacBook with a \"Retina\" display, which has a higher pixel density compared to the layout elements. This means that images and fonts are rendered sharper on my screen.\n\nThis pixel density is expressed as the device pixel ratio (DPR), which is also displayed on the test page. A higher DPR value is common on modern screens, with most starting above 1. Entry-level devices may have a DPR of 1.5, while an iPhone 14 has a DPR of 3.0.\n\n\n<div class=\"content-ad\"></div>\n\n결론: 이미지를 선명하고 선명하게 보이게 하려면 더 높은 해상도의 이미지가 필요합니다.\n\n그냥 이미지의 크기를 1500x500으로 늘리면 될 것 같아요:\n\n```js\n<div class=\"hero\">\n  <img src=\"https://dummyimage.com/1500x500/D3C8D9/000\" id=\"hero\" class=\"hero\"/>\n</div>\n```\n\n<img src=\"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n위의 링크를 참조해 보세요. (https://ackoch.github.io/image-zoo/001-hero-naive-2.html)\n\n이제 이미지가 매우 선명해 보입니다. 위 스크린샷에서 창 너비를 450px로 줄인 것을 알아챘을 겁니다. 지금은 1500px 이미지를 불러오고 있습니다. 하지만 900px 이미지로도 충분히 좋았을 것입니다. 소개에서 기억하실 것처럼, 파일 크기의 증가는 차원에 비해 과도하게 높습니다: 여기서 많은 대역폭을 낭비하고 있는 것입니다. 특히, 좁은 화면이 모바일 기기에서 더 많이 발견될 가능성이 높다는 점을 고려하면 대역폭이 귀중한 환경에서 더욱 그렇습니다.\n\n\"srcset\" 접근법\n\n표준 해결책은 간단합니다: 하나 이상의 이미지를 제공해야 합니다 — 이미지 집합, 소스 세트를 제공해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<img srcset=\"https://dummyimage.com/300x100/D3C8D9/000 300w,\n             https://dummyimage.com/600x200/D3C8D9/000 600w,\n             https://dummyimage.com/900x300/D3C8D9/000 900w,\n             https://dummyimage.com/1200x400/D3C8D9/000 1200w,\n             https://dummyimage.com/1500x500/D3C8D9/000 1500w\"\n  id=\"hero\"/>\n```\n\n여기에는 브라우저가 선택할 수 있는 다양한 해상도의 후보 이미지가 제공됩니다. 브라우저는 각 이미지의 실제 너비를 알 수 없기 때문에 각 후보에 이 정보를 추가해야 합니다.\n\n예를 들어, 다음 표현식\n\n```js\nhttps://dummyimage.com/300x100/D3C8D9/000 300w\n```\n\n<div class=\"content-ad\"></div>\n\n위 URL에서 제공하는 이미지가 300픽셀 너비(300w)로 되어있음을 알려줍니다.\n\n첫 번째 테스트를 진행해 보겠습니다:\n- Firefox에서 페이지를 엽니다 (정말로 Firefox에서).\n- 캐시를 비활성화합니다 (개발 도구 / 네트워크 / 캐시 비활성화).\n- 개발 도구 창을 열어둡니다 (!).\n- 창 크기를 변경하여 확인합니다.\n\n로딩된 이미지가 필요한 물리적 크기에 맞는지 확인할 수 있습니다. 또한 Firefox가 항상 다음으로 큰 후보를 로딩하고 있다는 것을 알 수 있습니다. 1040픽셀 뷰포트에서 1200픽셀 이미지를 로드하는 등 약간의 대역폭이 낭비되긴 하지만, 수용할만 합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식의 테이블입니다.\n\n\n<img src=\"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_6.png\" />\n\nFirefox에서 창 크기 변경하기\n\nFirefox와 Chrome이 다르게 작동하는 것을 말씀드렸나요? 아래 예시를 보세요.\n\n이제 Chrome에서 같은 작업을 해봅시다:\n\n\n<div class=\"content-ad\"></div>\n\n- 크롬에서 페이지를 열어주세요.\n- 캐시를 비활성화하세요 (개발자 도구 / 네트워크 / 캐시 사용 안 함)\n- 개발자 도구 창을 열어둡시다!\n- 창 크기를 변경할 때 창 테두리를 드래그하세요.\n\n작은 창에서 시작하여 차츰 창 크기를 키울 때, 크롬은 더 큰 이미지를로드합니다.\n\n그러나 그 이후에 다시 크기를 줄이면 페이지가 가장 큰 크기로 \"붙어\" 있습니다. 페이지를 강제 새로 고침할 때만 크롬이 이미지의 작은 버전을 다시로드합니다. 개발자 도구를 닫은 상태에서는 크롬이 다시로드 할 때조차 다시평가하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\nhttps://ackoch.github.io/image-zoo/001-hero.html을(를) 참고하세요.\n\n이것은 버그가 아닌 기능입니다. 크롬은 이미 더 큰 후보가 메모리에 있을 때 작은 버전의 이미지를 로드하지 않고 다운 샘플링할 수 있습니다. 이것은 성능에 좋지만 새로운 HTML 기능이 어떻게 작동하는지 이해하려고 할 때 혼란스러울 수 있습니다.\n\n그래서 반응형 이미지를 다룰 때는 Firefox를 선호합니다. 이것이 테스트를 조금 더 쉽게 만들어주기 때문입니다.\n\n참고: \"sizes\" 매개변수를 놓치셨다면. 그렇습니다. 다음 챕터에서 목적을 더 잘 설명하기 위해 고의로 실수한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 작은 티저 ½와 ½에서 \n\n![Small Teasers](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_8.png)\n\n우리가 배운 것을 두 작은 티저 구성 요소에 적용해 보겠습니다. 이 두 요소는 50%씩 나란히 표시되어야 합니다:\n\n```js\n<div class=\"flex-container\">\n  <div class=\"card\">\n\n    <img srcset=\"https://dummyimage.com/600x600/D5E8D4/000 600w,\n                 https://dummyimage.com/800x800/D5E8D4/000 800w,\n                 https://dummyimage.com/1200x1200/D5E8D4/000 1200w,\n                 https://dummyimage.com/1500x1500/D5E8D4/000 1500w\"\n         id=\"card1\">\n\n    <p id=\"dimensions-card1\"></p>\n\n  </div>\n\n  <div class=\"card\">\n    <img srcset=\"… 위와 동일하게 …\" src=\"…\" id=\"card2\">\n    <p id=\"dimensions-card2\"></p>\n  </div>\n\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n`800px` 스크린에서 `flex-container`를 감싸도록 스타일에 미디어 쿼리가 있습니다:\n\n```js\n@media(max-width: 800px){\n  .flex-container{\n    flex-wrap: wrap;\n  }\n}\n```\n\n브라우저에서 데모 페이지를 열고 창 크기를 변경해보세요.\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_9.png)\n\n<div class=\"content-ad\"></div>\n\n위 링크를 참조해보세요:  [링크](https://ackoch.github.io/image-zoo/002-small-teaser-naive.html)\n\n첫눈에는 모든 것이 잘 보일 것입니다. 그러나 주의 깊게 살펴보면, 로드된 이미지가 이미지의 실제 너비에 맞추어 정렬되지 않는 것을 알 수 있을 겁니다. 이미지 해상도가 뷰포트의 실제 너비에 맞추어 정렬됩니다.\n\n옆으로 나열된 경우에도 브라우저가 1500px 이미지를 로드하고 있습니다. 그러나 800px 이미지로도 충분히 표시될 수 있습니다. 줄바꿈된 경우에도 1200px 이미지가 로드되는 것을 보실 수 있을 겁니다. 이 경우에도 800px 후보 이미지로도 충분합니다.\n\n이게 왜 발생하는 걸까요?\n\n<div class=\"content-ad\"></div>\n\n브라우저는 가능한 빨리 이미지를 로드합니다: `img` 태그를 구문 분석할 때입니다. 그 시점에는 문서가 완전히 로드되지 않았기 때문에 브라우저는 페이지 레이아웃을 완전히 수행할 수 없고 어떤 후보 이미지를로드해야 하는지 결정할 수 없습니다. 따라서 이미지 품질을 잃지 않도록 발견한 가장 큰 후보를로드합니다.\n\n브라우저가 문서가 로드되고 페이지가 완전히 렌더링된 후에 결정하는 것이 더 나을 수 있다고 주장할 수 있습니다. 그러나 이렇게 하면:\n\na) 이미지로드가 약간 지연되었고 인지적 성능이 느려질 수 있습니다.\n\nb) 이미지가 주변 `div`에 의해 제약되지 않았을 경우(예: width: 100%로 수행한 것처럼) 일부 다시 렌더링이 필요할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n브라우저가 조금 더 작은 정보로 이미지를 미리로드하는 것은 성능 및 교환의 상과 관련이 있습니다.\n\n실제로 이 동작은 HTML5 표준에 따라 이루어집니다.\n\n제가 일부러 여기에 오류를 만들었어요. 포인트를 증명하기 위해서 말이에요. MDN의 srcset 문서를 확인해보세요 [6]:\n\nsrcset에 \"w\" 설명자가 포함된 경우, 브라우저는 이 설명자를 sizes 속성과 함께 사용하여 리소스를 선택함니다.\n\n<div class=\"content-ad\"></div>\n\n번역해 드릴게요: \"브라우저는 요소 내 이미지의 너비를 모르기 때문에 크기 속성을 명시적으로 정의해야 합니다.\"\n\n자, 그것을 해봐요:\n\n```js\n<div class=\"card\">\n  <img srcset=\"https://dummyimage.com/600x600/D5E8D4/000 600w,\n               https://dummyimage.com/800x800/D5E8D4/000 800w,\n               https://dummyimage.com/1200x1200/D5E8D4/000 1200w,\n               https://dummyimage.com/1500x1500/D5E8D4/000 1500w\"\n       sizes=\"40vw\"\n       id=\"card1\">\n       ...\n</div>\n```\n\n이 속성 sizes=\"40vw\"는 이미지가 뷰포트 너비의 40%를 차지한다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n이미지가 화면 가장자리까지 표시되지 않고 양옆과 가운데에 약간의 여백이 남아 있기 때문에 50%가 아닌 40%를 선택했어요. 40%는 대략적인 추정입니다. 의심스러우시다면 더 큰 값을 선택하여 품질을 희생하지 마세요. 이미지가 정확하게 일치할 필요는 없습니다. 왜냐하면 이미지 후보자들은 우리 예제에서 대략 200px 간격으로 있거든요.\n\n이제 이미지들은 sizes 속성에서 정의된 대로 맞춰졌어요:\n\n\n<img src=\"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_10.png\" />\n\n\nhttps://ackoch.github.io/image-zoo/002-small-teaser-sizes.html\n\n<div class=\"content-ad\"></div>\n\n데스크톱 모드에서는 적어도 문제가 세세해도 어색함이 없지만, 모바일 모드에서는 여전히 괜찮아 보이지 않아요. 이 차이는 크기를 출력하지 않으면 놓칠 수 있는 부분일 거에요:\n\n![Responsive Image Example](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_11.png)\n\n렌더링된 이미지의 물리적 너비는 1000픽셀이에요. 하지만 브라우저는 600픽셀 후보를 불러옵니다. 40vw 미디어 쿼리를 평가하여 1298px * 40% = 519px 이 되기 때문이에요. 따라서 가장 적합한 후보는 600픽셀 이미지예요.\n\nsizes 속성을 개선해야 해요:\n\n<div class=\"content-ad\"></div>\n\n```js\n<div class=\"card\">\n  <img srcset=\"https://dummyimage.com/600x600/D5E8D4/000 600w,\n               https://dummyimage.com/800x800/D5E8D4/000 800w,\n               https://dummyimage.com/1200x1200/D5E8D4/000 1200w,\n               https://dummyimage.com/1500x1500/D5E8D4/000 1500w\"\n       sizes=\"(max-width: 800px) 90vw,\n              (min-width: 801px) 40vw\"\n       id=\"card2\">\n  ...\n</div>\n```\n\n`sizes` 속성은 미디어 쿼리 / 너비 쌍의 목록을 가져옵니다. 여기서 우리는 다음을 지정합니다:\n\n- 뷰포트의 800px까지 이미지는 뷰포트 너비의 90%를 차지합니다 (간격 포함한 단일 열).\n- 801px 이상부터 40%만으로도 충분합니다 (간격을 고려한 두 열).\n\n이제 모든 경우가 적절한 이미지 차원으로 렌더링됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_12.png)\n\nSee: [link](https://ackoch.github.io/image-zoo/002-small-teaser-sizes-responsive.html)\n\n# Interlude: The CMS Point of View\n\nLet’s take a short break here.\n\n\n<div class=\"content-ad\"></div>\n\n지난 섹션에서 브라우저가 이미지를 즉시 로드할 수 있도록 몇 가지 추가적인 마크업이 필요하다고 설명했습니다. 브라우저의 관점에서는 합리적인 접근 방식입니다. 그러나 아키텍처적인 측면에서는 이 해결책이 최적이라고 생각하지 않습니다. 특히 CMS 애플리케이션의 맥락에서는:\n\na) 구성 요소는 적합한 미디어 쿼리를 렌더링할 수 있도록 렌더링되는 컨텍스트를 인지해야 합니다. 뷰포트 너비의 1/1을 차지하는 페이지와 너비의 1/3만 차지하는 여백 열에서 동일한 탄성 \"이미지\" 구성 요소를 재사용하려면 해당 다른 컨텍스트에 대해 명시적으로 구성해야 합니다. (예를 들어 AEM에서 컴포넌트 정책을 사용할 수 있습니다). 이미지 구성 요소를 1/3 뷰포트 너비만 사용하는 티저로 재사용하는 경우 더 복잡해집니다.\n\nb) 일반적으로 CSS에서 분리되어 유지되는 미디어 쿼리 정의가 HTML 마크업으로 누설됩니다. 이제 CSS와 HTML에서 미디어 쿼리를 일치시켜야 하며, 이는 다중 테넌트 플랫폼에서 공유된 컴포넌트 라이브러리를 재사용하기 더 복잡하게 만듭니다. 다른 스타일링을 위해 CSS만 변경할 수 없습니다. 컴포넌트의 렌더링을 매개변수화해야 합니다.\n\nc) \"버그\"를 발견하기 어렵습니다. 우리의 예에서, 해상도가 너무 높거나 너무 낮은지 확인하는 것은 상대적으로 쉬웠습니다. 그래나 이미지의 고유한 크기를 알려주기 때문에 가능했습니다. 사진에서는 문제가 너무 낮은 해상도일 때만 발생합니다. 우리가 해상도를 \"과다 할당\"하고 있는지 파악하기가 훨씬 더 어렵습니다.\n\n<div class=\"content-ad\"></div>\n\n또한, 브라우저 캐시는 혼란을 가중시킵니다. 테스트는 정말로 어렵고 거의 모든 테스터들이 반응형 이미징 개념을 잘 이해하지 못합니다.\n\n# 텍스트 이미지\n\n![텍스트 이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_13.png)\n\n아직 끝나지 않았습니다. 다음 사용 사례, 텍스트 이미지 구성 요소에는 다른 측면이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n데스크톱 화면에서는 이미지의 너비가 33%이고 1:1 비율을 갖도록 설정되어야 합니다. 모바일 장치에서는 이미지가 100%로 표시되며 3:1 형식으로 표시됩니다. 단순 축소만으로는 도움이 되지 않습니다.\n\n우리는 주위에 `div`를 사용하여 높이를 제한하고 `img`를 \"object-fit: cover\"로 설정할 수 있습니다. 하지만 그렇게 하면 여전히 전체 이미지를 전송하고 그 중 2/3을 버려야 합니다. 그리고 잘라내기는 간단히 중심을 자를 것입니다.\n\n다행히도 두 가지 고정된 종횡비만 있는 것을 미리 알고 있습니다. 그리고 언제 어떤 것을 적용해야 하는지 정확히 알고 있습니다. 그래서 `picture` 태그를 사용할 수 있습니다:\n\n```jsx\n<picture class=\"image\">\n  <source srcset=\"\n      https://dummyimage.com/100x100/C0CCDE/000&text=square+500 500w,\n      https://dummyimage.com/200x200/C0CCDE/000&text=square+600 600w,\n      https://dummyimage.com/300x300/C0CCDE/000&text=square+700 700w,\n      https://dummyimage.com/600x600/C0CCDE/000&text=square+800 800w,\n      https://dummyimage.com/800x800/C0CCDE/000&text=square+900 900w,\n      https://dummyimage.com/1000x1000/C0CCDE/000&text=square+1000 1000w,\n      https://dummyimage.com/1200x1200/C0CCDE/000&text=square+1200 1200w,\n      https://dummyimage.com/1500x1500/C0CCDE/000&text=square+1500 1500w\"\n    sizes=\"30vw\"\n    media=\"(min-width: 801px)\">\n\n  <source srcset=\"\n      https://dummyimage.com/500x166/C0CCDE/000&text=panorama+700 700w,\n      https://dummyimage.com/600x200/C0CCDE/000&text=panorama+800 800w,\n      https://dummyimage.com/900x300/C0CCDE/000&text=panorama+900 900w,\n      https://dummyimage.com/900x300/C0CCDE/000&text=panorama+1000 1000w,\n      https://dummyimage.com/900x300/C0CCDE/000&text=panorama+1200 1200w,\n      https://dummyimage.com/1500x500/C0CCDE/000&text=panorama+1500 1500w\"\n      sizes=\"85vw\"\n      media=\"(max-width: 800px)\">\n\n  <img src=\"https://dummyimage.com/900x300/C0CCDE/000&text=panorama+900\" \n       id=\"card3\" >\n\n</picture>\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시의 표 태그를 Markdown 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![Responsive Image and Dynamic Media](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_14.png)\n\n이런! 이미지를 30vw로 구성했던 것 같아요. viewport 너비의 30%로 설정했었지만, 실제로는 주요 콘텐츠 영역의 30%만 필요한 거 같네요. 낮은 해상도에서는 콘텐츠 영역과 viewport가 동일한 너비이기 때문에 문제가 없었어요. 1024px 이상에서는 콘텐츠 영역의 너비가 고정되어 확장되지 않아요. 우리는 잘못된 참조점을 사용하여 필요한 이미지 너비를 불필요하게 늘리고 있어요: 1024px * 30% ~ 300px 크기의 이미지가 필요한데, 1500px 너비의 viewport에서는 1500px * 30% ~ 500px 이미지를 요청하고 있어요 (또는 2배 레티나 디스플레이를 사용하는 경우 약 600px 대 약 1000px). \n\n문제는 주요 콘텐츠 영역의 max-width 제약이 소스 요소의 미디어 쿼리에 반영되지 않는다는 것이에요. 이를 수정하기 위해 1024px 이상의 다른 브레이크포인트를 추가하는 것으로 해결할 수 있어요:\n\n\n```js\n<source srcset=\"https://dummyimage.com/500x500/C0CCDE/000&text=square+600\"\n        media=\"(min-width: 1024px)\">\n```\n\n<div class=\"content-ad\"></div>\n\n여기를 참고해 주세요: https://ackoch.github.io/image-zoo/003-text-image-art-direction.html\n\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_15.png)\n\n\n내 컴퓨터에서는 잘 작동하고 아마 당신의 것에서도 잘 작동할 것입니다. 그러나 브라우저의 논리적 해상도보다 이미지에서 두 배 더 많은 픽셀을 표시할 수 있는 화면이 있음을 기억하세요. 위 예제에서는 2배의 장치 픽셀 비율(1024 x 33% * 2 ≈ 675)을 가정합니다.\n\n고정 크기 이미지에 대해 서로 다른 장치 픽셀 비율을 구분하려면 srcset 정의에서 약간 다른 구문을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<source srcset=\"https://dummyimage.com/300x300/C0CCDE/000&text=square+300 1x,\n                https://dummyimage.com/600x600/C0CCDE/000&text=square+600 2x\"\n        media=\"(min-width: 1024px)\">\n```\n\n여기에서는 저해상도 화면에 300px 이미지를 사용하고 고해상도 화면에는 600px 변형을 사용합니다.\n\n결과는 여기에서 확인할 수 있습니다: https://ackoch.github.io/image-zoo/003-text-image-art-direction-capped-dpr.html\n\n# 사이드노트: 파라미터 가져오는 방법\n\n<div class=\"content-ad\"></div>\n\n`picture` 및 `srcset`를 사용하려면 정의해야 할 많은 매개변수가 있습니다. 이러한 매개변수를 어떻게 얻을까요? 이는 상황에 따라 다릅니다. 아주(!) 잘 설계된 스타일 가이드가 있다면 해당 스타일 가이드에서 미디어 쿼리를 계산할 수도 있습니다. 그러나 저는 구현된 페이지를 자세히 살펴보고 상식을 적용하는 것이 더 실용적이라고 생각했습니다. 일반적으로 100px 또는 200px 간격으로 이미지 후보를 제공합니다. 그래서 그것은 정확한 과학은 아닙니다. 특정 브레이크포인트에서 이미지가 뷰포트의 약 1/3을 차지한다는 것을 알고 있고, 요소 사이의 공간을 고려하여 sizes=\"30vw\"로 안전하게 정의할 수 있습니다. 일부 실험을 통해 이를 28%로 낮출 수도 있습니다.\n\n테스트하는 모니터의 디바이스 픽셀 비율을 알아야 합니다. 즉, 특정 브레이크포인트에서 논리적인 차원을 300px부터 800px 사이로 측정한다면, 1x 모니터와 좁은 뷰포트를 위해 300px 이미지 후보를 제공하고 넓은 화면 2x 모니터를 위해 1600px 버전을 제공해야 합니다.\n\n# 큰 티저\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_16.png)\n\n<div class=\"content-ad\"></div>\n\n첫눈에는 Large Teaser가 텍스트와 이미지 구성요소처럼 보입니다. 그러나 여기서는 이미지의 높이를 항상 텍스트 상자의 높이에 맞추고 싶습니다.\n\n데스크톱에서 이미지는 화면 너비의 33%를 사용합니다. 모바일 화면에서는 이미지가 쌓이고 화면 너비의 100%를 사용하며 3:1로 표시됩니다. 텍스트 이미지 구성요소와는 달리 이미지의 높이는 가변적입니다. 이미지의 높이는 텍스트 블록의 높이로 정의됩니다. 긴 복사 텍스트는 보다 늘어진 형식으로 이어집니다:\n\n![이미지 1](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_17.png)\n\n![이미지 2](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_18.png)\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_19.png)\n\nThe image can have any aspect ratio and does not conform to any of the pre-defined formats. We can see that it’s getting dynamically narrower the longer the text gets. Remember, that Dynamic Media’s Smart Cropping requires an exact and pre-defined aspect ratio.\n\nThere are two ways to solve that:\n\n## Dynamic Cropping without Dynamic Media\n\n\n<div class=\"content-ad\"></div>\n\nDynamic Media를 사용하지 않으면 이미지의 크기를 제한하기 위해 `img` 주위에 래핑 된 `div`를 만들 수 있습니다. 그런 다음 `img` 태그는 다음과 같이 스타일을 지정할 수 있습니다.\n\n```js\nheight: 100%;\nwidth: 100%;\nobject-fit: cover;\nposition: absolute;\n```\n\n기본적으로 이미지는 상대적인 측면에서 고르게 잘립니다. object-position 매개변수로 영향을 받을 수 있습니다.\n\n```js\nobject-position: 50% 50%;\n```\n\n<div class=\"content-ad\"></div>\n\n가운데 맞춤 자르기를 나타냅니다.\n\n`object-position: 0% 100%;`은 이미지를 왼쪽에서 0%, 위쪽에서 100% (즉, 아래에서) 위치에 배치하며, 이는 기본적으로 오른쪽 상단에서 자르는 것을 의미합니다. 다시 말해, 이는 남서쪽 사분면에 초점이 있음을 가정합니다.\n\n<div class=\"content-ad\"></div>\n\n브라우저에서는 여전히 전체 이미지를 전송하지만 가장자리가 잘립니다. 따라서 여기에서는 대역폭을 낭비하고 있습니다.\n\n각 이미지마다 객체 위치를 정의해야 합니다. 전역 스타일 시트에서 이를 정의하는 것은 의미가 없습니다. 각 이미지에는 다른 자르기 매개변수가 필요합니다.\n\n콘텐츠 관리 시스템에서는 일반적으로 작성자에게 이러한 매개변수를 제공하도록 요청합니다. 예를 들어 Part I에서 제안한 3x3 매트릭스로요. 또는 작성자에게 모든 가장자리에서 안전하게 자를 수 있는 이미지만 사용하도록 권장할 수도 있습니다.\n\n![Responsive Image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_20.png)\n\n<div class=\"content-ad\"></div>\n\n왼쪽의 사진은 중앙에 아무것도 없습니다. 기본 모드에서 브라우저는 사진의 흥미로운 부분을 자르게 될 것입니다. 오른쪽의 이미지는 안전하게 제거할 수 있는 가장자리의 많은 배경이 있습니다.\n\n# Dynamic Media로 동적 자르기\n\nDynamic Media는 실시간으로 스마트 자르기를 적용할 수는 없지만, 저자 경험 및 성능을 향상시키는 몇 가지 기능을 제공합니다:\n\n- 안전하게 중앙에서 자를 수 있는 영역을 정의하기 위해 스마트 사전 자르기를 사용할 수 있습니다.\n- 서버 측에서 동적 자르기를 적용하여 수행할 수 있습니다. 이를 통해 브라우저에서의 (가중치가 지정된) 중앙 자르기와 동일한 시각적 결과를 얻을 수 있습니다. 다만 이 작업은 서버에서 수행됩니다. 따라서 전송되는 이진 데이터가 작아지며 페이지 렌더링이 더욱 빨라집니다.\n\n<div class=\"content-ad\"></div>\n\n스마트 프리크롭은 제품 설명서에 나오는 기능이 아니에요. 일반 스마트 크롭핑을 적용할 수 있는 간단한 방법이에요.\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_21.png)\n\n원본 이미지로 스마트 크롭을 먼저 만들어 브라우저에 전달해서 나머지 부분을 자르는 것이 아이디어에요. 첫 번째로 스마트 크롭(그리고 수동 보정도 함께)을 사용하면 가장자리가 충분한 영역을 쉽게 찾을 수 있어요.\n\n# 다이나믹 크롭\n\n<div class=\"content-ad\"></div>\n\nDynamic Media에는 또 다른 강점이 있습니다. 우리는 다음과 같은 URL을 사용하여 서버 측에서 자르기를 할 수 있습니다:\n\nhttps://techsupporteu.scene7.com/is/image/AEMEMEAPractice/AdobeStock_636568731?fit=crop&wid=300&hei=100\n\nfit=crop 매개변수는 Dynamic Media에게 이미지를 너비와 높이로 정의된 사각형에 맞추어 그려진 명시적들을 잘라 제거하세요.\n\n만약 우리가 HTML5만으로 후보 중 하나를 선택하고 있다면, 이것은 특별히 유용하지 않을 수 있습니다. 우리가 동적 자르기를 위해 필요한 정적 URL이나 URL의 범위를 정의할 수 없기 때문입니다. 우리가 사용자 지정 이미지 로더를 구현할 때 Dynamic Media의 동적 자르기 기능을 완전히 최대한 활용하는 방법과 다이나믹 자르기 기능을 완전히 활용하는 방법에 대해 다룬 이 시리즈의 제4부를 참고하십시오.\n\n<div class=\"content-ad\"></div>\n\n# AEM 코어 컴포넌트 만들기\n\n우리는 이제 모든 중요한 사용 사례를 모두 조합했습니다.\n\n어차피 AEM 코어 컴포넌트를 사용하는 게 어떨까요? 그게 편하지 않을까요?\n\n안타깝지만 그렇지 않아요. AEM 코어 컴포넌트는 다이나믹 미디어를 위한 제한된 지원만 제공합니다. 또한 컴포넌트마다 지원하는 정도가 다릅니다. 지원하는 내용의 몇 가지 예시는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_22.png)\n\n이미지 구성 요소는 스마트 크로핑을 지원합니다. 그러나 비율적인 스케일링은 허용되지 않습니다. 모든 뷰포트 크기에서 원본 해상도를 사용합니다. 아트 방향이나 브라우저 크로핑은 지원되지 않습니다. 하지만 이러한 구성 요소에는 대개 필요하지 않습니다.\n\n이미지 목록은 브라우저에서 크로핑되며 이는 스마트 크로핑에 이상적인 사용 사례일 것입니다. 적어도 이미지를 축소합니다.\n\n티저는 브라우저에서만 크로핑됩니다. 이는 스마트 사전 크로핑에 좋은 후보였을 것입니다. 이미지에 대한 아트 방향을 지원하지 않지만 데스크탑과 모바일의 형식은 매우 다릅니다. 다시 말해, 기본 크로핑만 적용되어 대역폭을 낭비하며 최적의 결과를 얻지 못합니다.\n\n\n<div class=\"content-ad\"></div>\n\n모든 구성 요소의 스케일링 단계는 이미지 코어 구성 요소의 정책에서 정의됩니다. 이 구성은 모든 구성 요소에 적용되어야 하므로 srcset에 후보 URL이 매우 긴 목록으로 생성됩니다. 기본적으로 100px에서 1600px까지 13개의 후보 이미지가 있습니다. 저는 각 구성 요소에 개별적인 srcset을 구성하는 것이 더 나았을 것 같아요. 이것은 조금은 미학적인 문제입니다. 전체 HTML이 조금은 늘어납니다만 너무 많이 늘지는 않아요.\n\n지원이 더 좋을 수 있다는 것을 깨달은 첫 번째 사람은 아니에요. wcm.io [7] 프로젝트에는 동적 미디어에 대한 더 나은 지원을 약속하는 고급 미디어 핸들러가 있습니다. 하지만 아직 시도해보지는 않았어요.\n\n# 결론\n\n파트 IV에서는 동적 미디어의 대역폭을 최대한 끌어내는 사용자 정의 이미지 로더를 구현하는 방법에 대해 다룰 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# 감사의 말\n\n친애하는 동료들인 Eryk Lagun과 Rob Freeman에게 영감, 교정 및 사실 확인에 대해 감사드립니다.\n\n# 참고 문헌\n\n[1] https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\n\n<div class=\"content-ad\"></div>\n\n[2] [Adobe Dynamic Media Developer Resources - Image Serving API - HTTP Protocol Reference - Command Reference](https://experienceleague.adobe.com/docs/dynamic-media-developer-resources/image-serving-api/image-serving-api/http-protocol-reference/command-reference/c-command-reference.html)\n\n[3] [Adobe Experience Manager Learn - Smart Crop Feature Video Use](https://experienceleague.adobe.com/docs/experience-manager-learn/assets/dynamic-media/images/smart-crop-feature-video-use.html)\n\n[4] [Adobe Experience Manager Cloud Service - Dynamic Media Image Profiles](https://experienceleague.adobe.com/docs/experience-manager-cloud-service/content/assets/dynamicmedia/image-profiles.html)\n\n[5] [Image Zoo GitHub Repository](https://github.com/ackoch/image-zoo/blob/master/README.md)\n\n<div class=\"content-ad\"></div>\n\n[6] https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/srcset\n\n[7] https://wcm.io/handler/media/usage.html","ogImage":{"url":"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_0.png"},"coverImage":"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_0.png","tag":["Tech"],"readingTime":23},{"title":"JavaScript로 페이지 콘텐츠 변경 및 추가하는 방법","description":"","date":"2024-06-23 14:35","slug":"2024-06-23-JavaScriptChangingandAddingPageContent","content":"\n\n![image](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_0.png)\n\n이제 우리는 바꾸려는 요소를 DOM에서 쿼리하는 방법을 알게 되었습니다. 이제는 그 요소들로 무엇을 하는지 살펴봅시다.\n\n![image](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_1.png)\n\n이 첫 번째 p 태그를 가져와서 그 안의 텍스트를 추출해 봅시다. 그리고 그 내용을 변경해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_2.png)\n\n여기서는 첫 번째 p 태그를 찾는 document.querySelector 메서드에 대한 참조를 저장하고 있습니다. 그런 다음 para.innerText를 \"Yo!\"로 설정하고 있습니다. innerText는 메서드가 아닌 속성이기 때문에 괄호를 사용하지 않습니다.\n\n![이미지](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_3.png)\n\n한 번에 여러 가지를 변경해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_4.png)\n\nHere I'm using querySelectorAll to get all the p tags. Then I'm using the forEach method to simply log out each one.\n\n![Image 2](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_5.png)\n\nNow I'm just appending 'new text' to each p tag.\n\n\n<div class=\"content-ad\"></div>\n\n무언가의 HTML을 변경하고 싶다면 어떻게 해야 할까요?\n\n첫 번째 단계는 해당 요소에 대한 참조를 가져오는 것입니다.\n\n![image](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_6.png)\n\n여기서 content 클래스에 대한 참조를 가져와 innerHTML을 로깅하고 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_7.png)\n\n그런 다음 innerHTML 속성을 사용하여 해당 요소의 실제 HTML을 변경할 수 있습니다.\n\n여기 가정해 봅시다!\n\n우리가 사람들의 데이터베이스를 보고 있는 것으로 상상해 봅시다. 그리고 각 사람에 대해 HTML 템플릿을 만들어 브라우저에 출력하고 싶습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*Esh6L4NcymzAF3vIW5MQfw.gif)\n\n여기서 people이라는 배열을 만들고 forEach 메소드를 사용하여 .content 요소의 innerHTML을 변경하고 있습니다. 내용을 추가하므로 브라우저에는 이름 목록과 함께 페이지 요소를 검사할 때 div 내부에 이름 목록이 표시됩니다.\n","ogImage":{"url":"/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_0.png"},"coverImage":"/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_0.png","tag":["Tech"],"readingTime":2},{"title":"iframe과 부모 앱 간의 통신 방법","description":"","date":"2024-06-23 14:34","slug":"2024-06-23-Communicationbetweeniframeanditsparentapp","content":"\n\n여기에서는 iframe과 해당 부모 앱 간의 통신이 가능한 방법을 간단히 설명하고 있어요.\n\n이 경우에는 브라우저에로드되는 주 응용프로그램이자 iframe을 포함하고 있는 부모 응용프로그램이 있습니다. 여기에서는 iframe의 src 속성을 통해 다른 웹 페이지를 로드하고 있어요. 따라서 부모 앱과 iframe의 두 가지 원본이 있죠.\n\n![iframe and its parent app communication](/assets/img/2024-06-23-Communicationbetweeniframeanditsparentapp_0.png)\n\n## 시나리오 1 - 부모와 iframe이 동일한 출처를 가지고 있으며 부모 및 자식 모두를 제어할 수 있는 경우\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 부모는 www.abc.com을 가지고 있고 자식은 www.abc.com/child를 가지고 있습니다.\n\n이 경우 브라우저는 부모에서 자식으로, 그리고 자식에서 부모로 window 객체를 통해 통신을 허용합니다.\n\n부모 - 자식\n\n```js\n// 자식 앱에서\n// window 객체에 메소드 바인딩\nwindow.childCallback = function() {\n  console.log('부모가 자식 메소드 호출 중');\n}\n\n// 부모 앱에서\n// iframe 로드\n<iframe id='iframe' src=\"http://www.abc.com/child\"/>\n// iframe window을 통해 메소드 호출\nconst iframe = document.getElementById(\"iframe\");\niframe.contentWindow.childCallback();\n```\n\n<div class=\"content-ad\"></div>\n\nChild - Parent\n\n```js\n// Parent 앱에서\n// window 객체에 메소드를 바인딩합니다.\nwindow.parentCallback = function() {\n  console.log('자식이 부모 메소드를 호출합니다');\n}\n\n// Child 앱에서\n// window 객체를 통해 메소드를 호출하세요\nwindow.parent.parentCallback();\n```\n\n데모 보기 - https://thinugigs-iframe-test-same-origin.web.app/\n\n소스코드(간단한 리액트 앱) - https://github.com/thinugigs/-Iframe-test-same-origin\n\n<div class=\"content-ad\"></div>\n\n## 시나리오 2 - 부모와 아이프레임이 서로 다른 출처를 가지고 있고 부모와 자식 요소를 모두 제어할 수 있는 경우\n\n부모 요소의 출처이 www.abc.com이고 자식 요소의 출처이 www.xyz.com인 경우를 예로 들어보겠습니다.\n\n이 시나리오에서 브라우저는 postMessage를 통해 부모에서 자식으로 통신하거나 자식에서 부모로 통신하는 것을 허용합니다.\n\n부모 - 자식\n\n<div class=\"content-ad\"></div>\n\n```js\n// 자식 애플리케이션에서\n// 윈도우 객체에 메시지 이벤트 리스너를 연결합니다\nwindow.addEventListener(\"message\", function(event) {\n  console.log('부모가 자식 메소드 호출 중');\n});\n\n// 부모 애플리케이션에서\n// iframe만 로드합니다\n<iframe id='iframe' src=\"http://www.xyz.com\"/>\n// iframe 창을 통해 메시지를 전송합니다\nconst iframeWindow = document.getElementById(\"iframe\").contentWindow;\niframeWindow.postMessage(\"\", \"*\");\n```\n\n자식 - 부모\n\n```js\n// 부모 애플리케이션에서\n// 윈도우 객체에 메시지 이벤트 리스너를 연결합니다\nwindow.addEventListener(\"message\", function(event) {\n  console.log('자식이 부모 메소드 호출 중');\n});\n\n// 부모 애플리케이션에서\n// 부모 객체를 통해 메시지를 전송합니다\nparent.postMessage(\"\", \"*\");\n```\n\n샘플 데모 - https://thinugigs-iframe-test-different-origin-parent.web.app/\n\n\n<div class=\"content-ad\"></div>\n\n원본(간단한 html 앱입니다) - https://github.com/thinugigs/-iframe-test-different-origins\n\n## 시나리오 3 - 부모와 아이프레임이 서로 다른 출처를 갖지만 부모나 자식 중 한 곳을 제어할 수 있는 경우\n\n이러한 시나리오에서 당신은 부모 앱 또는 자식 앱 중 하나에 속할 수 있습니다. 따라서 한쪽에서만 메시지 구현이 가능하여 상호 통신을 양방향으로 할 수 없게 됩니다, 즉 부모에서 자식으로, 그리고 자식에서 부모로의 통신이 불가능해집니다.\n\n따라서 다음은 우리가 경험한 내용의 요약입니다.","ogImage":{"url":"/assets/img/2024-06-23-Communicationbetweeniframeanditsparentapp_0.png"},"coverImage":"/assets/img/2024-06-23-Communicationbetweeniframeanditsparentapp_0.png","tag":["Tech"],"readingTime":3},{"title":"PDF 분할 로드  풀스택 솔루션 안내","description":"","date":"2024-06-23 14:32","slug":"2024-06-23-PDFSliceLoadingFullStackSolution","content":"\n\n# 서문\n\n본 문서는 PDF 파일을 로딩하는 최적화 솔루션에 대해 풀 스택 관점에서 설명합니다. 서버인 NestJS를 통해 PDF 파일을 업로드하고 노드를 통해 PDF를 이미지로 나누는 과정을 거칩니다. 그 후, 모바일 H5는 원본 PDF 파일 자원이 로드될 때까지 이미지를 우선적으로 로딩합니다. 그 이후에 PDF 소스 파일이 표시되며 사용자 제스처 확대/축소 및 복사 기능을 지원합니다.\n\n# 배경\n\n전반적으로 프런트엔드 페이지에서 PDF 파일을 로드해야 하는 필요성이 종종 발생합니다, 특히 정부 기관, 금융 업계 등에서 많이 발생합니다. PDF 파일은 여러 객체(텍스트, 이미지, 폰트 등)를 포함하는 컨테이너로, 파일 내부에는 어떤 순서로든 저장될 수 있습니다. 전체 PDF 파일은 네트워크로부터 다운로드된 후 파싱되어 렌더링되어야 페이지에 올바르게 표시됩니다. PDF 파일이 수십 메가바이트 또는 수백 메가바이트일 때, 사용자들은 PDF 파일 콘텐츠를 보기 위해 오랜 시간을 기다려야 합니다. 모바일 기기에서 PDF 파일을 여는 데 필요한 대기 시간은 더욱 길어질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 스키마 비교\n\n- HTTP Range Requests 헤더\n- PDF 조각 잘라내기\n\n솔루션 1: 프론트 엔드는 PDF 파일에 대한 네트워크 페이징 요청을 생성하며, 네트워크 병렬 요청은 리소스 다운로드 과정을 가속화합니다. 서버는 이 Content-Range을 지원하도록 수정되어야 하지만, 이 방법은 가시 범위 내의 우선 순위로 페이지 로드를 제어하기 어려운 문제가 있습니다.\n\n솔루션 2: 이것은 이 장에서 소개하는 주요 내용입니다. 이 방법의 장점은 가시 범위 내의 PDF 콘텐츠를 먼저 로드할 수 있어 첫 화면에서 PDF 콘텐츠를 렌더링하는 시간을 크게 단축할 수 있다는 것입니다. 그러나 이 방법의 단점은 조각으로 표시된 PDF 이미지가 확대 및 복사를 지원하지 않는다는 것입니다. 제스처 확대 및 복사는 원본 PDF 파일이 로드될 때까지 지원되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# PDF 분할 솔루션 비교\n\n운영 환경: Chrome 브라우저에서 모바일 기기로 PDF를 로드하는 시뮬레이션, 네트워크는 4G로 설정\n\n로드된 PDF 파일: NVIDIA 2024년 제1분기 재무 보고서 PDF 파일, 페이지 번호 183, 파일 크기: 34.8MB\n\n이 그림은 원본 PDF 로딩 효과를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:480/1*6z6XdVED9HwQ4lBWiqjwMA.gif)\n  \n이 그림은 슬라이싱 솔루션로딩 효과를 보여줍니다\n\n![이미지](https://miro.medium.com/v2/resize:fit:480/1*Cgp-GrVHbvSPYaunMduhZQ.gif)\n\n# 사용된 환경과 기술적인 포인트\n\n\n<div class=\"content-ad\"></div>\n\n- 서버: 노드, 네스트져스, MulterModule, ServeStaticModule, FileInterceptor, postman 도구\n- 프론트엔드: http-server (글로벌로 설치), pdfjs, pdfh5\n\n# 노드 서버\n\n서버는 업로드된 PDF 리소스를 페이지 번호에 따라 여러 이미지로 분할하고, 로딩된 PDF API를 요청하는 것을 주로 담당합니다. 인터페이스는 PDF 리소스 주소와 분할로 생성된 이미지 리소스 주소를 반환하며, nestjs 프레임워크를 사용합니다.\n\n# 1. 네스트져스 프로젝트 생성 및 종속성 설치\n\n<div class=\"content-ad\"></div>\n\n우선, NestJS 프로젝트를 빠르게 만들고 `upload` 모듈을 업로드해 보세요. 자세한 내용이 필요하시면 NestJS 시작하기 (파트 2): 사진 업로드를 꼭 읽어보세요. `upload.module`을 수정하여 PDF 형식의 업로드를 허용하도록 변경하세요.\n\n```js\n  // src/upload/upload.module.ts\n  \n  fileFilter: (req, file, cb) => { \n     if ( \n       file.mimetype === 'image/jpeg' || \n       file.mimetype === 'image/png' || \n+       file.mimetype === 'application/pdf' ) { \n         cb(null, true); \n       } else { \n         cb(new Error('Only images (JPEG, PNG) and PDF files are allowed...'), false);\n         } \n       }\n```\n\nPDF 자르기에 필요한 도구를 설치해보세요:\n\n- pdfjs-dist: 새 버전의 사용 방법을 피하기 위해 pdf 파일 도구킷(문서 주소)을 사용하세요. 이 글은 아래와 같은 고정된 패키지를 설치합니다. @2.7.570\n- canvas: canvas를 통해 pdf 스트림을 읽어 이미지를 생성하세요.\n- @types/pdfjs-dist: pdfjs-dist 데클레어션 파일 패키지\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install pdfjs-dist@2.7.570 canvas @types/pdfjs-dist --save\n```\n\n## 2. PDF 파일의 각 페이지를 이미지로 잘라내기\n\nPDF 파일을 페이지 번호에 따라 사진으로 자릅니다. 각 페이지는 한 장의 사진에 해당합니다. 잘린 사진은 루트 디렉토리 uploads/images/에 저장됩니다. 시작 파일에서 uploads/images/ 디렉토리가 있는지 확인해야 합니다. 디렉토리가 없으면 생성해야 합니다.\n\n```js\n// src/main.ts\n\nasync function bootstrap() {\n...\n+ const imagesDir = join(process.cwd(), 'uploads/images');\n+  if (!existsSync(imagesDir)) {\n+    mkdirSync(imagesDir);\n+  }\n...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n캔버스Create a class to convert PDF stream to image\n\n```js\n// src/upload/node-canvas-factory.ts\n\nimport { Canvas, createCanvas, CanvasRenderingContext2D } from 'canvas';\n\nexport class NodeCanvasFactory {\n    create(width: number, height: number) {\n        const canvas = createCanvas(width, height);\n        const context = canvas.getContext('2d');\n        return {\n            canvas,\n            context,\n        };\n    }\n\n    reset(canvasAndContext: { canvas: Canvas; context: CanvasRenderingContext2D }, width: number, height: number) {\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n\n    destroy(canvasAndContext: { canvas: Canvas; context: CanvasRenderingContext2D }) {\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n}\n```\n\nCreate a basic class for reading PDF and generating imagesupload.service\n\n```js\n// src/upload/upload.service.ts\n\nimport { Injectable } from '@nestjs/common';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { NodeCanvasFactory } from './node-canvas-factory';\n\n// 使用 require 语句导入 pdfjs-dist\nconst pdfjsLib = require(\"pdfjs-dist/es5/build/pdf.js\");\n\n@Injectable()\nexport class UploadService {\n    async convertPdfToImages(pdfPath: string, outputDir: string): Promise<string[]> {\n        const pdfBuffer = await fs.readFile(pdfPath);\n        const pdfDocument = await pdfjsLib.getDocument({ data: pdfBuffer }).promise;\n        const numPages = pdfDocument.numPages;\n        const imageUrls = [];\n        for (let pageNum = 1; pageNum <= numPages; pageNum++) {\n            const imageUrl = await this.processPage(pdfDocument, pageNum, outputDir);\n            imageUrls.push(imageUrl);\n        }\n        return imageUrls;\n    }\n\n    private async processPage(pdfDocument, pageNumber: number, outputDir: string): Promise<string> {\n        const page = await pdfDocument.getPage(pageNumber);\n        const viewport = page.getViewport({ scale: 1.8 });\n        const canvasFactory = new NodeCanvasFactory();\n        const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n\n        const renderContext = {\n            canvasContext: canvasAndContext.context,\n            viewport: viewport,\n            canvasFactory: canvasFactory,\n        };\n\n        const renderTask = page.render(renderContext);\n        await renderTask.promise;\n\n        const imageBuffer = canvasAndContext.canvas.toBuffer();\n        const outputFileName = path.join(outputDir, `output_page_${pageNumber}.png`);\n        await fs.writeFile(outputFileName, imageBuffer);\n\n        return `http://localhost:3000/uploads/images/output_page_${pageNumber}.png`;\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nThe `convertPdfToImages` 함수는 PDF 파일을 읽고 슬라이싱하여 생성된 이미지의 주소를 반환합니다. `processPage` 함수는 PDF의 각 페이지를 이미지로 변환합니다.\n\n이제 해당 업로드 PDF 리소스 인터페이스를 추가해야 합니다: `uploadPdf`\n\n```js\n// src/upload/upload.controller.ts\n\n...\nexport class UploadController {\n    ...\n    \n+    @Post('/uploadPdf')\n+    @UseInterceptors(FileInterceptor('file'))\n+    async uploadPdf(@UploadedFile() file) {\n+       const outputDir = join(process.cwd(), 'uploads/images');\n+        const filePath = join(process.cwd(), 'uploads', file.filename);\n+        const imageUrls = await this.uploadService.convertPdfToImages(filePath, outputDir);\n+        return { urls: imageUrls };\n+    }\n\n}\n```\n\n이제 Postman을 사용하여 2024년 첫 번째 분기 NVIDIA 재무 보고서를 업로드 PDF 파일로 제출해주세요. 페이지 수는 183페이지이고 파일 크기는 34.8MB입니다. 업로드 프로세스 중 PDF 슬라이싱 과정을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*I0SxO90cmJAwt4rxlvYcHA.gif)\n\n# 3. PDF 및 해당 슬라이스 이미지 주소를 얻기 위한 API 인터페이스 생성\n\npdf 및 해당 슬라이스 이미지 주소를 얻기 위한 메소드를 생성합니다. 간편함을 위해, 단계 2에서 생성된 정적 리소스 주소를 지정합니다. upload.controller.ts.Get\n\n```js\n// src/upload/upload.controller.ts\n\nimport {\n    Controller,\n    Post,\n    UploadedFile,\n    UseInterceptors,\n    Get\n} from '@nestjs/common';\n...\nexport class UploadController {\n    ...\n    \n    @Get()\n    async getPdf() {\n        const baseUrl = 'http://localhost:3000/uploads/';\n        const pdf = `${baseUrl}1718437748872.pdf`;\n        const images = [] // Slice image storage\n        // There are 187 images\n        for (let i = 0; i < 187; i++) {\n            images.push(`${baseUrl}images/output_page_${i}.png`);\n        }\n        return { pdf, images };\n    }\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\nPostmanGet 요청: localhost:3000/upload\n\n리턴 형식:\n\n```js\n{\n   \"pdf\": \"http://localhost:3000/uploads/1718437748872.pdf\",\n   \"images\": [ \n        \"http://localhost:3000/uploads/images/output_page_0.png\",\n        \"http://localhost:3000/uploads/images/output_page_1.png\",\n        \"http://localhost:3000/uploads/images/output_page_2.png\",\n        .....\n   ] \n}\n```\n\n# 4. 서버는 CORS를 시작하여 인터페이스에 대한 크로스도메인 액세스를 허용합니다\n\n주로 나중을 위해, 프런트엔드 프로젝트 서비스는 포트 8080이며, 해당 서비스 포트 3000에 대해 크로스도메인 문제가 있습니다. 여기서 main.ts를 업로드 인터페이스에 대한 크로스도메인 액세스를 허용하도록 설정해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// src/main.ts\n\n+ app.use('/uploads', (req, res, next) => {\n+   res.header(\"Access-Control-Allow-Origin\", \"*\");\n+   res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n+   next();\n+ });\n\napp.use('/uploads', express.static(join(process.cwd(), 'uploads'));\n\n// Enable CORS\n+ app.enableCors({\n+    origin: '*', // Front-end address allowed\n+    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n+    credentials: true,\n+ });\n```\n\n마침내 서버가 이미지를 성공적으로 자르고 정적 리소스 디렉터리에 저장합니다. 다음으로는 PDF 슬라이스 이미지의 프론트엔드 분할 렌더링을 소개하겠습니다.\n\n# Front End\n\n본 문서에서는 H5 모바일 터미널에서 PDF 로드 속도를 최적화하는 해결책을 주로 다루므로, H5 터미널에서는 오픈 소스 프레임워크인 pdfh5를 사용하여 PDF 파일을 표시합니다. 이 문서에서는 HTML을 사용하여 pdfh5를 실행합니다. React, Vue에서 실행해야 하는 경우 저자의 해당 프레임워크 예제를 참조할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 1. 프론트엔드 프로젝트 웹 만들기 및 로컬 서비스 시작하기\n\n프론트엔드 프로젝트 웹을 만들고 index.html을 생성해주세요.\n\n```js\n// index.html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    />\n    <title>H5 성능을 고려한 PDF 뷰어 로딩</title>\n  </head>\n  <body>\n    <h2>H5 성능을 고려한 PDF 뷰어 로딩</h2>\n  </body>\n</html>\n```\n\n프론트엔드는 순수한 Html 페이지이므로 로컬로 서비스를 시작해야합니다. 여기서 http-server을 사용하여 먼저 전역으로 설치해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n npm i http-server -g\n```\n\n폴더를 열고 다음 명령어로 서비스를 시작해보세요\n\n```js\n cd web\n http-server ./ -p 8080\n```\n\n브라우저에서 localhost:8080으로 접속하면 화면이 보일 거에요:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-23-PDFSliceLoadingFullStackSolution_0.png)\n\n## 2. 웹 프로젝트에 pdfh5 통합하기\n\npdfh5 프로젝트 다운로드\n\n```js\ngit clone https://github.com/gjTool/pdfh5.git\n```\n\n<div class=\"content-ad\"></div>\n\n프론트엔드 웹 프로젝트에 CSS와 JS 파일을 복사하고, index.html 코드를 수정하여 이전에 작성한 서버 인터페이스인 localhost:3000/upload 를 요청하도록 변경해보세요.\n\n아래는 수정된 index.html 코드입니다.\n\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n    <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n    <meta name=\"format-detection\" content=\"telephone=no\" />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1,user-scalable=no\" />\n    <meta http-equiv=\"pragma\" content=\"no-cache\" />\n    <meta http-equiv=\"cache-control\" content=\"no-cache\" />\n    <meta http-equiv=\"expires\" content=\"0\" />\n    <title>PDFH5</title>\n    <link rel=\"stylesheet\" href=\"css/pdfh5.css\" />\n    <style>\n      html, body {\n        width: 100%;\n        height: 100%;\n        padding: 0;\n        margin: 0;\n      }\n    </style>\n  </head>\n  <body>\n    <div id=\"demo\"></div>\n    <script src=\"js/pdf.js\"></script>\n    <script src=\"js/pdf.worker.js\"></script>\n    <script src=\"js/jquery-3.6.0.min.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"js/pdfh5.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script type=\"text/javascript\">\n      var pdfh5;\n      $(function () {\n        // AJAX GET 요청을 수행하여 PDF URL을 가져옵니다.\n        $.get('http://localhost:3000/upload', function(response) {\n          if (response && response.pdf) {\n            var pdfUrl = response.pdf;\n            pdfh5 = new Pdfh5(\"#demo\", {\n              pdfurl: pdfUrl,\n              pageNum: false,\n              URIenable: false, \n              lazy: false,\n            });\n \n            // PDF 렌더링의 성공 이벤트 처리\n            pdfh5.on(\"success\", function (time) {\n              time = time / 1000;\n              console.log(\"pdf rendering completed, total time taken: \" + time + \" seconds\");\n            });\n\n          } else {\n            console.error('PDF URL을 검색하는 데 실패했습니다.');\n          }\n        }).fail(function() {\n          console.error('GET 요청 수행에 실패했습니다.');\n        });\n      });\n    </script>\n  </body>\n</html>\n```\n\n브라우저가 H5 모드로 전환되었음을 확인하고, http://127.0.0.1:8080/ 로 이동하여 서버 인터페이스에 요청을 보내고, 반환된 PDF 주소가 성공적으로 로드되었습니다:\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-23-PDFSliceLoadingFullStackSolution_1.png)\n\n# 3. 우선 PDF 조각 렌더링하기\n\nPDF 표시에는 레이어를 다운로드한 후 렌더링이 필요하기 때문에 PDF 파일이 큰 경우 사용자는 대기해야 하는 경우가 많습니다. 이 기다리는 동안에 조각 이미지를 먼저 렌더링한 다음 네트워크를 이용하여 PDF 파일을 조각화합니다. 이렇게 하면 사용자에게 더 친화적입니다. 사용자는 원본 PDF 파일을 표시하며, 복사, 확대 등의 상호 작용을 지원합니다.\n\nslice 맵 컨테이너를 추가하고 .image-list를 만들어 서비스 인터페이스 이미지의 배열에서 가져온이미지 노드 src를 생성하십시오. 먼저 첫 번째 맵을로드한 다음 로드가 성공하면 순서대로 조각 맵을로드하십니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// index.html\n\n...\n<style>\n+ .이미지-리스트 {\n+       패딩: 12px 8px;\n+       z-인덱스: 999;\n+     }\n+     .이미지-리스트 img {\n+       상자-사이징: 테두리-박스;\n+       테두리: 없음;\n+       패딩: 0;\n+       마진: 0;\n+       너비: 100%;\n+       마진-바텀: 8px;\n+       박스-그림자: 어두운회색 0px 1px 3px 0px;\n+      }\n</style>\n...\n+  <div class=\"이미지-리스트\"></div>\n   <div id=\"demo\"></div>\n\n...\n <script type=\"text/javascript\">\n+ const imageList = $(\".이미지-리스트\");\n\n    $.get(\"http://localhost:3000/upload\", function (response) {\n          if (response && response.pdf) {\n            var pdfUrl = response.pdf;\n+            var images = response.images;\n+            loadImageSequentially(images);\n...\n\n\n+function loadImageSequentially(images) {\n+        let index = 1;\n+        function loadNextImage() {\n+          if (index < images.length + 1) {\n+            const img = new Image();\n+           img.src = images[index];\n+           img.onload = function () {\n+              index++;\n+             loadNextImage(); // 다음 이미지 로드\n+            };\n+            img.onerror = function (error) {\n+             console.error(\"이미지 로드 실패:\", img.src, error);\n+             index++;\n+              loadNextImage(); // 다음 이미지로 건너뜀\n+            };\n+           imageList.append(img);\n+         }\n+        }\n+        loadNextImage();\n+      }\r\n```\n\n참고: .image-list 노드는 #demo 노드앞에 있어야 첫 화면에서 먼저 PDF 자른 이미지 자원을 볼 수 있습니다. loadImageSequentially 함수는 자른 이미지 자원을 재귀적으로 로드하는 기능을 합니다.\n\n이미지를 로드할 때, 노드는 삭제해야 합니다. image-list\n\n```js\n// index.html\n\n  pdfh5.on(\"success\", function (time) {\n+       imageList.remove();\n              time = time / 1000;\n              console.log(\"렌더링 완료: \" + time + \"초\");\n  });\r\n```\n\n<div class=\"content-ad\"></div>\n\n효과:\n\n![이미지](https://miro.medium.com/v2/resize:fit:400/1*vDNwCJmngtkbiZQO6Pu0ZA.gif)\n\n위의 효과를 보면, PDF가 성공적으로 로드되면 분할 이미지가 제거되면서 맨 위로 호출되는 것을 볼 수 있습니다. 이러한 상호 작용은 매우 사용자 친화적이지 않습니다. 이 전환 과정은 스크롤 바 위치를 변경하지 않고 유지해야 합니다:\n\n```js\n// index.html\n\npdfh5.on(\"success\", function (time) {\n    const scrollTop = $(window).scrollTop();\n    imageList.remove();\n    document.querySelector(\".viewerContainer\").scrollTo(0, scrollTop);\n    time = time / 1000;\n    console.log(\"pdf 렌더링 완료, 총 걸린 시간: \" + time + \"초\");\n});\n```\n\n<div class=\"content-ad\"></div>\n\n마지막 효과:\n\n![final effect](https://miro.medium.com/v2/resize:fit:480/1*pgy_ZFs9x3PQwi0V9s_d6g.gif)\n\n마침내 효과를 확인할 수 있습니다. PDF 원본 파일이 PDF 슬라이스 이미지로 대체되면, 프로세스가 매우 부드럽고 사용자는 전환을 거의 느낄 수 없습니다. 이것으로 고성능 PDF 로딩 풀스택 솔루션에 대한 예비 소개를 마칩니다.\n\n# 요약\n\n<div class=\"content-ad\"></div>\n\nPDF 슬라이스 솔루션에 대한 많은 기사가 있지만, 그 중에서도 다양한 관점에서 자세히 설명하는 것은 많지 않아서 이 기사를 쓰게 되었습니다. 이 기사는 프론트엔드와 백엔드 솔루션 및 공동 디버깅 단계를 주로 설명합니다. 현재 솔루션의 많은 세부 사항이 더 최적화될 수 있습니다. 예를 들어: 슬라이스의 압축, PDF의 총 폭과 높이에 대한 사전 페이지 높이 획득, 이미지의 가상 목록, 애플리케이션의 네이티브 측에서의 로컬 로드, pdfh5 종속성 패키지... 등이 있습니다. 나중에 최적화 솔루션 기사가 공개될 예정이니 기대해 주세요!\n\n소스 코드 주소","ogImage":{"url":"/assets/img/2024-06-23-PDFSliceLoadingFullStackSolution_0.png"},"coverImage":"/assets/img/2024-06-23-PDFSliceLoadingFullStackSolution_0.png","tag":["Tech"],"readingTime":16},{"title":"JavaScript로 API에서 데이터를 받아 카드 형태로 렌더링하는 방법","description":"","date":"2024-06-23 14:31","slug":"2024-06-23-HowtofetchdatafromanAPIandrenderitintocardsusingJavaScript","content":"\n\n<img src=\"/assets/img/2024-06-23-HowtofetchdatafromanAPIandrenderitintocardsusingJavaScript_0.png\" />\n\n안녕하세요! 제 첫 블로그 포스트에 오신 것을 환영합니다! 처음 프로젝트로 즐겨 보는 것을 만들고 접목하고 싶었습니다. 그것은 (위의 이미지에서 유추하지 못했다면) Rick and Morty입니다. 웹 개발에 진입하기 전에 API에 대해 들어본 적이 없었기 때문에 첫 프로젝트에서 사용하기로 선택했습니다. Rick and Morty를 시청하는 것을 즐기며 재미있게 느껴서 Rick and Morty API를 빠르게 구글 검색한 후 사용하기로 결정했습니다.\n\n이제 시작해 봅시다:\n\n먼저, JavaScript 파일(index.js)을 링크하기 위해 index.html을 가지고 있어야 합니다.<script> 태그를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n  <html lang=\"eng\">\n    <head>\n      <title>Rick and Morty Character Generator</title>\n     </head>\n     <body>\n       <div id=\"cards-container\">\n        </div> \n      <script src=\"index.js\" defer></script>\n     </body>\n  </html>\r\n```\n\n스크립트 태그는 body의 끝에 있으며 'defer' 속성이 있습니다. 이는 HTML이 파싱되고 JavaScript가 로드되기 전에 스크립트가 실행되도록 하기 위한 것입니다. 또한, 대신에 'defer' 속성 대신 index.js에서 \"DomContentLoaded\" 이벤트 리스너를 추가할 수도 있지만 무조건 body 태그 내에서 스크립트 태그를 사용하도록 주의해야 합니다. body 태그 안에는 id가 \"cards-container\"인 div 태그가 있습니다. 이는 카드를 생성할 때 사용될 것입니다.\n\n팁: API를 다룰 때는 문서를 살펴보는 것이 좋습니다. 보통 문서를 읽으면 어떤 데이터와 어떻게 액세스할 수 있는지 미리 확인할 수 있습니다.\n\nAPI를 가져오려면 올바른 구문을 사용해야 합니다. 이 프로젝트를 작업하기 전에 fetch를 소개받았지만 프로젝트에서 데이터를 가져오는 작업은 해본 적이 없었습니다. 데이터를 가져오는 다른 방법도 있지만 그것은 나중에 다시 다루도록 하겠습니다.\n\n<div class=\"content-ad\"></div>\n\nindex.js에 다음과 같이 작성되어 있어야 해요:\n\n구문:\n\n```js\nfetch('API_URL')\n.then(response => response.json())\n.then(data => console.log(data));\n```\n\n<img src=\"/assets/img/2024-06-23-HowtofetchdatafromanAPIandrenderitintocardsusingJavaScript_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n릭 앤 모티 문서를 확인한 후, 우리는 필요한 모든 캐릭터를 가져오기 위해 \"/character\" 엔드포인트를 추가해야 한다는 것을 배웠어요. 위의 구문에서 한 가지 변경한 점은 '데이터' 대신 '캐릭터'를 사용하기로 결정한 것이에요. 이름을 지을 때 '데이터'를 사용하는 대신 '캐릭터'로 지었어요. 왜냐하면 우리가 가지고 오려고 하는 정확한 데이터가 '캐릭터'이기 때문이에요.\n\n팁: 무엇을 하기 전에 데이터를 console.log 해보는 것이 좋아요. 이것은 좋은 초보 실습이에요. 콘솔을 통해 작업할 API의 데이터를 볼 수 있기 때문에 어떻게 데이터를 가져올 수 있는지 정확히 파악할 수 있어요. 또한, API에 더 많은 속성이 있다면, 점 표기법을 사용해 접근할 수 있어요.\n\n\n<img src=\"/assets/img/2024-06-23-HowtofetchdatafromanAPIandrenderitintocardsusingJavaScript_2.png\" />\n\n\n우리가 console.log(characters)를 사용했기 때문에, 크롬 개발자 도구의 콘솔을 열면 API의 데이터를 볼 수 있어요 (Windows에서는 Ctrl Shift J 또는 Mac에서는 Ctrl Option J). \"info\"라는 객체와 \"results\"라는 배열이 있어요. 우리가 원하는 것은 \"results\" 배열에서 모든 캐릭터를 가져오는 것이에요. 이번에는 '캐릭터' 뒤에 '.results'를 추가할 거에요.\n\n<div class=\"content-ad\"></div>\n\n이제 이 캐릭터들의 경로를 알았습니다. \"characters.results\"입니다.\n\n카드를 생성하기 전에 index.html에서 cards-container div를 index.js로 가져와야 합니다. API를 가져올 때 캐릭터를 렌더링 할 곳이 되기 때문입니다. index.js에서 전역 변수를 만들고(어떤 함수 외부에서) DOM(Document Object Model)의 querySelector() 메서드를 사용하여 Id가 'cards-container'인 div를 가져와야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst cardsContainer = document.querySelector('#cards-container');\n```\n\n이제 다음 단계로 넘어가 보겠습니다. 콜백 함수를 만드는 것입니다.\n\n'characters' (데이터)를 인자로 사용하여 'renderCharacters'라는 함수를 생성할 것입니다. 이 함수 블록에서 우리는 characters로 시작하여 forEach() 메소드를 사용할 것입니다. 각 character마다 div 카드가 생성될 것입니다. 이 카드에는 캐릭터의 이미지, 이름, 종류, 캐릭터를 좋아하는 좋아요 버튼이 포함될 것입니다. 우리는 DOM의 createElement() 메소드를 사용하여 새로운 요소를 생성할 수 있고 각 새로 생성된 요소를 개별 변수로 선언할 수 있습니다.\n\n```js\nfunction renderCharacters(characters) {\n  characters.forEach(character => {\n    const div = document.createElement('div');\n    const image = document.createElement('img');\n    const name = document.createElement('h3');\n    const species = document.createElement('h3');\n    const like = document.createElement('button');\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로는 CSS를 사용하여 스타일을 적용할 수 있도록 div, 이미지 및 좋아요 버튼에 class를 추가합니다. 이를 위해 요소 이름 뒤에 점 표기법을 사용하여 해당 요소에 사용할 이름을 할당해주면 됩니다.\n\n```js\ndiv.classList = 'card'\nimage.classList = 'card-img'\nlike.classList = 'empty'\n```\n\n선호하는 API에 따라 데이터를 가져오는 것이 가능합니다. Rick and Morty API의 경우 캐릭터의 이미지, 이름 및 종족이 제공되므로 해당 데이터를 가져오기 위해 점 표기법을 사용할 수 있습니다.\n\n```js\nimage.src = character.image\nname.innerText = `이름: ${character.name}`\nspecies.innerText = `종족: ${character.species}`\nlike.textContent = '좋아요'\n```\n\n<div class=\"content-ad\"></div>\n\n캐릭터 이미지를 얻기 위해서는 이미지 뒤에 'src' (소스의 약자)를 추가한 후 character.image에 할당해야 합니다. 이름과 종 요소에 대해서는 innerText와 역따옴표 (``)를 사용했습니다. 캐릭터의 이름과 종 옆에 텍스트를 표시하려면 이 작업이 필요합니다. 이를 위해 역따옴표와 보간 구문 (`$''`)을 사용합니다. 그렇지 않으면 'Name:'과 'Species:' 텍스트가 표시되지 않습니다. 또한, 좋아요 버튼에는 'like'의 textContent를 지정해줍니다.\n\n마지막으로, 이러한 요소들을 새롭게 생성한 div 요소에 추가한 다음 해당 div를 이전에 생성한 'cardsContainer' 전역 변수에 추가해야 합니다. 이 단계는 매우 중요합니다. 그렇지 않으면 새롭게 생성된 카드가 전혀 표시되지 않습니다. 이를 위해 appendChild() 메서드를 사용합니다. 우리는 이미지, 이름, 종, 그리고 좋아요 버튼을 개별적으로 div에 추가한 다음 그 div를 이제 카드가 존재할 'cardsContainer'에 추가합니다.\n\n팁: 요소를 추가한 순서가 페이지에 나타나는 순서입니다. 이 경우에는, 캐릭터 이미지가 먼저 나타나고 그 다음으로 이름 및 기타 정보가 나타나도록 하려고 합니다.\n\n<div class=\"content-ad\"></div>\n\n함수 전체를 다음과 같이 작성해 보세요:\n\n```js\nfunction renderCharacters(characters) {\n  characters.forEach(character => {\n    const div = document.createElement('div');\n    const image = document.createElement('img');\n    const name = document.createElement('h3');\n    const species = document.createElement('h3');\n    const like = document.createElement('button');\n    div.classList = 'card';\n    image.classList = 'card-img';\n    like.classList = 'empty';\n    image.src = character.image;\n    name.innerText = `이름: ${character.name}`;\n    species.innerText = `종: ${character.species}`;\n    like.textContent = '좋아요';\n    div.appendChild(image);\n    div.appendChild(name);\n    div.appendChild(species);\n    div.appendChild(like);\n    cardsContainer.appendChild(div);\n  });\n};\n```\n\n멋져요! 마지막 단계는 다시 fetch로 돌아가서 두 번째 'then()'에서 renderCharacters를 콜백으로 호출하는 것입니다. characters.results를 이용하여 캐릭터 배열에 접근하는 방법을 알고 있으므로 해당 매개변수로 추가해줍시다.\n\n<img src=\"/assets/img/2024-06-23-HowtofetchdatafromanAPIandrenderitintocardsusingJavaScript_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n브라우저에서 index.html을 열어보면 이와 같은 모습을 볼 수 있을 거에요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*9bylXDqCvO_s_lbb9KQHGA.gif)\n\n이게 다에요! 이제 각 캐릭터에 대한 카드를 공식적으로 만들었어요. 이제 CSS를 사용하여 카드를 스타일링하고 원하는 대로 보이게 만들 수 있어요. 테두리를 추가하거나 가운데 정렬하거나 꾸밈을 줄 수 있어요. 더 멋지게 하려면 플렉스박스를 사용해보세요. 우리는 div card, image, like 버튼에 대한 클래스를 생성했으므로 CSS에서 규칙을 설정할 수 있을 거에요. 잘하고 있어요!","ogImage":{"url":"/assets/img/2024-06-23-HowtofetchdatafromanAPIandrenderitintocardsusingJavaScript_0.png"},"coverImage":"/assets/img/2024-06-23-HowtofetchdatafromanAPIandrenderitintocardsusingJavaScript_0.png","tag":["Tech"],"readingTime":6},{"title":"SEO 기초 이해하기 2024년 필수 가이드","description":"","date":"2024-06-23 14:29","slug":"2024-06-23-UnderstandingtheBasicsofSEO","content":"\n\n\n\n<img src=\"/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_0.png\" />\n\nSEO(Search Engine Optimization)은 Google과 같은 검색 엔진에서 웹 사이트의 가시성과 순위를 향상시키는 데 개발자에게 중요합니다. 모든 사이트가 강력한 SEO가 필요한 것은 아니지만, 최적화할 때의 시기와 방법을 이해하는 것이 중요합니다. 이 글에서는 SEO를 세 가지 주요 관점을 통해 탐구해 보겠습니다:\n\n- 사용자에 공감하기\n- 검색 엔진에 사이트를 전달하기\n- 제품에 집중하기\n\nSEO는 확실히 간단한 주제가 아니지만, 적어도 기본 이해를 가지고 코딩하는 동안 유의해야 한다고 믿습니다. 이 글을 통해 몇 가지 기본 주제를 전달할 수 있기를 희망합니다. 먼저, SEO가 정확히 무엇을 의미하고 무엇이 아닌지 살펴보는 것부터 시작해보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 목차\n\n- SEO란 무엇이며 무엇이 아닌가요?\n- 사용자와 공감하다\n- 사용자가 편안하게 느낄 수 있도록\n- 사용자를 만족시키다\n- 사이트를 검색 엔진에 전달하기\n- 메타 타이틀과 설명이란 무엇인가요?\n- 검색 의도\n- 제품에 초점을 맞추다\n- 올바른 경로 구성\n- 태그와 링크 리디렉션이 올바르게 사용되어야 함\n\n# SEO란 무엇이며 무엇이 아닌가요?\n\nSEO(Search Engine Optimization)는 주로 Google을 포함한 검색 엔진과 효과적으로 소통하도록 웹사이트를 최적화하는 것을 의미합니다. 검색어를 사용하여 웹사이트를 검색 엔진에 효과적으로 전달한다는 점으로 SEO를 단순화하는 오해가 있습니다. 하지만 검색 엔진은 그렇게 간단히 동작하지 않습니다. 사용자 검색을 평가하고 해당 검색어와 일치하는 콘텐츠를 제공하여 사용자 만족을 보장합니다. 따라서 단순히 올바른 키워드를 사용하여 클릭 수를 증가시키려는 것만으로는 효과적인 최적화가 이루어지지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# 사용자와 공감하기\n\n개발자로서, 우리는 가장 활발한 웹 사용자 중 한 명이기 때문에 사용자 경험에 대한 독특한 시각을 갖게 됩니다. 생각해보세요 - 하루에 웹을 검색하거나 활용하는 횟수가 얼마나 되나요? 지금까지 웹을 검색하는 데 얼마나 많은 시간을 보냈나요? 평균 사용자보다 더 많다고 확신합니다. 그러니까 사용자를 이해하는 것은 정말 어렵지 않은 일일 것입니다. 왜냐하면 여러분 중 한 명이 가장 활발한 사용자이기 때문이죠.\n\n자신을 생각해보세요. 가장 많이 사용하는 사이트는 무엇인가요? 이들은 모두 특정한 공통점을 가지고 있을 것입니다: 당신의 요구에 부합하는 원본 콘텐츠, 정확한 결과를 제공하면서 불필요한 정보를 피하는 것, UI/UX 측면에서 사용하기 쉽고, 무엇보다도 당신의 요구를 충족시켜주는 것입니다. 사실, 이러한 각 특성은 SEO의 기반이 됩니다.\n\n# 사용자가 편안한 느낌을 받을 수 있도록 하세요\n\n<div class=\"content-ad\"></div>\n\n프론트엔드 개발자로서, 사용자 친화적인 디자인이나 구성 요소를 선택하는 것은 가장 어려운 작업 중 하나입니다. 종종 특정 동적 기능을 좋아해도 사용자들이 그것을 이해하기 어려울 수 있기 때문에 사용을 삼가곤 합니다. 이 시점에서, 사용자가 원하는 것을 쉽게 접근할 수 있도록 하는 것이 화려한 디자인보다 우선입니다. 또한, 복잡성과 피로는 사용자가 사이트에 머무르는 시간을 크게 줄일 수 있습니다. 사이트의 목적에 따라 이러한 고려 사항은 다양하지만, 마케터처럼 생각하고 고객이 최대한 편안하게 느끼도록 하는 것이 중요합니다.\n\n# 사용자 만족시키기\n\n사이트의 콘텐츠를 중요시하고 SEO 친화적으로 만드는 데 타협하지 마세요. 이 사항에 집중하는 것은 교통량을 크게 증가시키지는 않겠지만, 유인된 사용자를 보유하는 데 중요합니다. 컨텐츠와 일치하는 SEO 최적화를 구현하세요. 예를 들어, 단백질 파우더의 혜택에 대한 콘텐츠가 있지만 특정 브랜드를 선호하도록 프로모션하거나 존재하지 않는 혜택을 제안하는 (즉, 편향적인 정보를 제공하는) 방법으로 제시하면 사용자가 이를 느끼고 다른 사이트를 찾으려고 할 것입니다. 검색 엔진은 이를 고려합니다. 또한, 완전하거나 상세한 정보를 제공하지 못할 경우 사용자를 만족시킬 수 없습니다. 사용자의 요구를 충족시키세요.\n\n사용자를 이해하려면 스스로부터 시작하세요.\n\n<div class=\"content-ad\"></div>\n\n# 검색 엔진에 사이트를 알리세요\n\n자바스크립트는 유연성을 제공하지만 SEO 목적을 위해 자연 HTML 요소를 사용하는 것이 중요합니다. 일례로 자바스크립트로 경로 탐색을 처리할 수 있다고 해서 반드시 그렇게 해야하는 것은 아닙니다. 사이트 내부 링크는 검색 엔진이 페이지를 이해하는 데 가장 중요한 자원 중 하나입니다. HTML에서 의도한 대로 `a` 태그를 사용하세요. 검색 엔진은 자바스크립트 함수에서의 탐색을 인식할 수 없습니다.\n\n이와 유사하게 제목에 적합한 HTML 태그를 사용해보세요. CSS로 스타일링할 수 있는 div, span 또는 p 태그에 큰 글꼴 크기를 사용하는 것은 h1 태그를 사용할 때 그 의미를 놓치는 것입니다. h1 태그는 텍스트가 제목임을 나타내고 강조되어야 한다는 이유로 HTML에 존재합니다. 자연스러운 방법을 사용하면 검색 엔진이 콘텐츠를 이해하기 쉬워집니다.\n\n요약하면, 가능한 한 HTML을 우선적으로 사용하고 이후 CSS, 필요할 때만 JavaScript를 사용하는 것이 좋습니다. 이는 성능을 향상시키는데 도움이 되며 SEO에서 중요한 이점을 제공합니다. 이를 간과해서는 안 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 메타 타이틀과 설명이란 무엇인가요?\n\n메타 타이틀과 설명은 검색 엔진이 당신의 페이지의 목적과 콘텐츠를 이해하고 사용자 검색에 따라 강조하는데 도움이 되는 간단한 설명입니다. 특정 길이 제한은 없지만 불필요한 단어를 사용하는 것을 피해야 하며, 그 내용에 따라 달라져야 합니다. 예를 들어, 여성 트랙수트 모델을 소개하는 페이지의 경우, \"의류\"나 \"여성 패션\"과 같이 일반적인 제목이 아니라 페이지와 직접적으로 관련된 제목을 사용해야 합니다.\n\n반면에 설명은 페이지에 대한 더 자세한 정보를 제공하고, 필요없는 세부 사항을 피하면서 콘텐츠와 관련된 정확한 정보를 포함해야 합니다. 구글에서 스니펫으로 표시될 수 있는데, 이때 텍스트에는 검색 페이지에서 사용자가 볼 수 있는 한도가 있습니다.\n\n메타 타이틀과 설명은 각 페이지마다 고유해야 하며, 서로 다른 언어 옵션이 있는 경우 해당 언어에 따라 달라져야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 검색 의도\n\n검색 의도는 사용자가 제공하는 콘텐츠에 도달하기 위해 사용하는 단어 및 문장의 집합입니다. 검색 의도를 맞추거나 가장 일반적인 검색어를 포함시키기 위해 단어를 사용하되 사용자를 만족시키는 데만 집중하지 않는다면 중요합니다. 키워드로 가득 채운 스니펫이나 콘텐츠를 채우는 것은 바라는 마지막 일이 될 수 있습니다. 왜냐하면 이것은 검색 엔진 스팸 정책을 위반하고 오히려 눈에 띄기 보다는 오히려 뒤로 밀릴 수 있기 때문입니다. 사용자 만족도를 우선시하여 단순히 키워드에 맞추는 것이 아니라 사용자의 요구사항과 기대에 정말로 부합하는 콘텐츠를 제공하는 것이 중요합니다. 이 방법은 사용자 경험을 향상시키는 것뿐만 아니라 품질과 관련성을 우선시하는 지속 가능한 SEO 실천 방법과 더 잘 부합합니다. 콘텐츠를 키워드로 가득 채우지 않도록 주의하십시오.\n\n검색 의도를 파악하는 데 사용할 수 있는 도구들:\n\n- Google 자동완성\n- 키워드 연구 도구 (예: Semrush, Ahrefs)\n- Google Trends\n- Google Ads 키워드 플래너\n- Google 검색 콘솔\n- \"사용자가 또 질문한 것\" 섹션\n- 관련 검색 섹션\n\n<div class=\"content-ad\"></div>\n\n# 제품에 집중하세요\n\n제품을 출시할 때, 이 SEO 기본 사항은 더욱 중요해집니다. 이 단계에서는 개발자로서 주의를 기울여야 할 점들을 논의해 보겠습니다. 가능한 한 많은 올바른 및 부정확한 예시를 들어 설명해 드리겠습니다.\n\n# 올바른 경로 구성\n\n<div class=\"content-ad\"></div>\n\n적절한 라우트 구성은 검색 엔진이 페이지를 효과적으로 크롤할 수 있게 하고 콘텐츠가 올바른 사용자에게 도달할 수 있도록 하는 데 중요합니다.\n\n- 페이지의 이름을 해당 콘텐츠에 맞게 지정하세요.\n\n![UnderstandingtheBasicsofSEO_1.png](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_1.png)\n\n- 가능한 한 지나치게 동적인 제품 ID 사용을 피하세요. 페이지나 제품에 명확하고 이해하기 쉬운 URL이 가장 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이해하는 것은 SEO의 기초](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_2.png)\n\n- 당신의 경로는 UTF-8과 호환되는 문자를 사용해야 합니다. 다른 알파벳을 사용 중이라면 해당 알파벳에 적합한 UTF-8 문자를 사용해야 합니다.\n\n중국어 UTF-8 문자\n\n![이해하는 것은 SEO의 기초](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n- 복합 단어를 사용하지 않고 적절한 구분자를 사용해주세요.\n\n![이미지](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_4.png)\n\n- 국가별 도메인 확장자를 사용하고 언어를 구별해주세요.\n\n![이미지](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_5.png)\n\n<div class=\"content-ad\"></div>\n\n# `a` 태그의 적절한 사용 및 링크 리다이렉션\n\n이전에 언급한 대로, 검색 엔진이 당신의 페이지를 색인화하고 인식하는 가장 중요한 방법 중 하나는 내부 링크를 사용하는 것입니다. 다음 요소들이 당신의 페이지의 색인화에 영향을 줄 수 있습니다:\n\n- 검색 엔진 스팸 정책\n- 검색 엔진이 작성된 코드와 미디어 파일에 접근할 수 없음\n\n<div class=\"content-ad\"></div>\n\n• 로그인 요구 조건과 같은 조건이 존재하는지 확인\n\n• 적절한 경로 구조를 만들지 못하는 경우\n\n• 크롤링할 수 없는 미디어 파일 유형을 사용하는 경우\n\n이 모든 지침을 따르고 적절한 `a` 태그를 사용한다면, 페이지가 크롤링될 수 있고 적절한 스니펫이 포함된 검색 결과에 나타날 수 있습니다. 이제 `a` 태그의 적절한 사용법을 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_6.png)\n\nUsing redirects in this way or within functions can reduce crawlability and decrease the likelihood of search engines understanding your page.\n\n![Image 2](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_7.png)\n\nUsing appropriate text within the `a` tag is crucial for SEO and user experience. Here are some guidelines and examples:\n\n\n<div class=\"content-ad\"></div>\n\n\n![Understanding the Basics of SEO 8](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_8.png)\n\n![Understanding the Basics of SEO 9](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_9.png)\n\nUnfortunately, the following usages are very common and familiar. However, they are quite incorrect from an SEO perspective, and if you need your page to be crawled, these are mistakes you should never make.\n\n![Understanding the Basics of SEO 10](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_10.png)\n\n\n<div class=\"content-ad\"></div>\n\n또 다른 중요한 측면은 `a` 태그 내의 콘텐츠가 가능한 한 쉽게 크롤링되도록 하는 것입니다. `a` 태그는 CSS로 쉽게 스타일을 지정할 수 있으므로 div나 span과 같은 구성 요소를 내부에 넣지 않도록 해야 합니다. 이미지나 비디오와 같은 태그를 사용해야 하는 경우에는 검색 엔진이 크롤할 수 있는 형식으로 제공하고 SEO 목적에 맞게 필요한 alt 정보를 제공해야 합니다.\n\n![UnderstandingtheBasicsofSEO_11](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_11.png)\n\n검색 엔진이 올바른 미디어 alt 태그를 사용하여 콘텐츠를 이해하도록 해야 합니다. 미디어 콘텐츠를 올바르게 활용하면 SEO 강점을 살릴 수 있습니다. Alt 설명은 콘텐츠의 내용과 관련성을 명확히 나타내야 합니다. 또한, 미디어 태그와 관련된 텍스트, 제목, 그리고 비슷한 콘텐츠를 부모 요소에 포함하거나 나란히 배치하면 이 관계를 더욱 강화할 수 있습니다. 올바른 alt 태그 사용 예시를 살펴보겠습니다.\n\n![UnderstandingtheBasicsofSEO_12](/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_12.png)\n\n<div class=\"content-ad\"></div>\n\n모든 정보를 고려할 때, 우리가 도출한 결론은 먼저 정확하고 적절하며 명확하며 독창적인 콘텐츠를 초기에 제작하고 사용자를 항상 우선시하는 것이 중요하다는 것입니다. 검색 엔진도 사용자를 우선시하기 때문입니다. 콘텐츠를 검색 엔진을 우선시하거나 최신 트렌드 때문에 관련 없는 SEO 방법을 사용하면 사용자에게 먼저 알려질 것이며, 아마도 검색 엔진으로부터 원하는 성과를 얻지 못할 것입니다. 이 시점에서 해야 할 일은 콘텐츠를 처음부터 신뢰하고 검색 엔진이 쉽게 이해할 수 있도록 최적화하는 것입니다.\n\n더 자세한 정보를 위해, 개발자 블로그와 검색 엔진의 공식 문서를 탐험하는 것을 강력히 추천합니다. 이 기사는 SEO에 대한 기본적인 이해를 제공하는 것을 목표로 하며, 계속 배우고 최신 방법을 습득하는 것을 장려합니다.","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingtheBasicsofSEO_0.png","tag":["Tech"],"readingTime":8},{"title":"JavaScript windowprint로 인쇄할 때 페이지가 잘리는 문제 해결 방법","description":"","date":"2024-06-23 14:27","slug":"2024-06-23-JavaScriptwindowprintcutsoffpagewhenprinting","content":"\n\n\n![Printing Issue](/assets/img/2024-06-23-JavaScriptwindowprintcutsoffpagewhenprinting_0.png)\n\n현재 페이지를 하드 복사본에 인쇄하는 window.print() 함수를 사용합니다. 그러나 스크롤했거나 문제가 발생한 경우 인쇄할 때 창의 일부가 잘릴 수 있습니다. 이는 함수가 페이지 맨 위에 있다고 가정하기 때문입니다. 이 문제를 해결하려면 몇 가지 단계를 거쳐야 합니다.\n\n첫째, 사용자가 페이지를 인쇄하려면 버튼을 클릭할 때 JavaScript 이벤트인 \"beforeprint\"를 사용하여 페이지 맨 위로 스크롤할 수 있습니다. 버튼을 클릭할 때 스크롤 위치를 설정해야 하며, 사용자가 다시 아래로 스크롤하길 원하지 않을 수 있습니다.\n\n```js\nlet scrollY = 0\n\nbtn.addEventListener('click', () => {\n  scrollY = window.scrollY\n  window.print()\n})\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 사용자가 페이지 맨 위로 스크롤하도록 이전 인쇄 이벤트를 청취하세요.\n\n```js\nwindow.addEventListener(\"beforeprint\", (e) => {\n  scrollTo(0, 0)\n})\n```\n\n마지막으로 인쇄 후에는 scrollY 변수를 사용하여 사용자를 처음에 있던 위치로 스크롤하십시오.\n\n```js\nwindow.addEventListener(\"afterprint\", (e) => {\n  scrollTo(0, scrollY)\n})\n```\n\n<div class=\"content-ad\"></div>\n\n이제 모든 것이 예상대로 원활하게 작동해야 합니다. 읽어 주셔서 감사합니다. 이 블로그가 도움이 되었다면, 자주 유용한 내용을 게시하고 있으니 Medium에서 저를 팔로우하여 개발 지식을 향상시키세요.","ogImage":{"url":"/assets/img/2024-06-23-JavaScriptwindowprintcutsoffpagewhenprinting_0.png"},"coverImage":"/assets/img/2024-06-23-JavaScriptwindowprintcutsoffpagewhenprinting_0.png","tag":["Tech"],"readingTime":1},{"title":"HTML과 CSS로 간단한 싱글 페이지 웹사이트 만드는 방법","description":"","date":"2024-06-23 14:26","slug":"2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS","content":"\n\n## HTML과 CSS를 사용한 간단한 웹사이트 디자인\n\n![이미지](/assets/img/2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS_0.png)\n\n웹 개발자가 되기 위해서는 먼저 HTML과 CSS를 배워야 합니다. 하지만, HTML과 CSS를 완전히 배울 수 없습니다. 당신이 할 수 있는 것은 기본 구문을 배우고 과제를 수행하여 시험에 통과하는 것뿐입니다. 진정한 경험과 지식을 얻는 것은 현장에서 웹사이트를 디자인할 때입니다. 웹 개발에 초보이거나 HTML과 CSS와 관련된 과제를 해결해야 하는 경우, 이 글을 따라가보세요. 5~10분 안에 단일 페이지 웹사이트를 만들 수 있습니다. 지식 습득을 위해 모든 태그와 다른 내용을 설명해 두었습니다.\n\n# 필수 준비사항\n\n<div class=\"content-ad\"></div>\n\n- VS 코드\n\nVisual Studio Code은 내가 선호하는 통합 개발 환경입니다. 파일을 편집하는 데에는 다른 IDE를 사용할 수도 있습니다. 또는 여기서 VS 코드 편집기를 다운로드할 수도 있습니다.\n\n- VS 코드에 Live Server 확장 프로그램을 설치하세요.\n\n브라우저에서 변경 사항을 확인하고 실행하기 위해, Live Server를 VS 코드에 설치했습니다. 이제 웹 페이지를 개발할 때 변경 사항을 한 번의 클릭으로 확인할 수 있습니다. 또는 선호하는 다른 방법으로 파일을 실행할 수도 있습니다. Live Server를 설치하려면 VSCode를 열고 ctrl + P를 입력하여 ext install ritwickdey.liveserver를 입력하고 엔터를 누르면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n그럼 구현 방법을 살펴보겠습니다. 아래 단계를 따라야 합니다.\n\n## 단계 01\n\n컴퓨터 어디에서나 genotechies라는 폴더를 만들고 에디터를 통해 해당 폴더를 엽니다. 해당 폴더 내부에 index.html 파일을 생성하세요.\n\n![이미지](/assets/img/2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS_1.png)\n\n<div class=\"content-ad\"></div>\n\n- Live server를 사용하여 index.html 파일을 실행할 수 있어요. index.html 파일에 마우스 오른쪽 버튼을 클릭하고 Live Server로 열기 옵션을 선택해주세요. 그러면 즐겨 사용하는 브라우저에서 페이지가 열릴 거에요.\n\n![image](/assets/img/2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS_2.png)\n\n# 단계 02\n\n이것은 HTML 페이지의 기본 템플릿이에요. 먼저 해당 내용을 index.html 파일로 복사했어요. 그래서 우리는 이 템플릿에 모든 다른 구성 요소들을 추가할 거에요.\n\n<div class=\"content-ad\"></div>\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<title>Page Title</title>\n</head>\n<body>\n<h1>This is a Heading</h1>\n<p>This is a paragraph.</p>\n</body>\n</html>\n\n\n# Step 03: Add meta tags and edit the title in the head tag\n\nThe `meta` tag defines metadata about an HTML document. Metadata describes the data contained inside the web page.\n\n`meta` tags always go inside the `head` element and are typically used to specify the character set, keywords, page description, author of the document, and viewport settings.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <link rel=\"stylesheet\" href=\"style.css\">\n    <title>Genotechies Website Design</title>\n</head>\n```\n\n# 단계 04: 이미지 폴더 및 기타 파일 생성\n\nbody 태그를 편집하기 전에 동일한 디렉토리에 이미지 폴더와 style.css 파일을 생성해야 합니다. 필요할 때마다 이미지를 추가해야 합니다. 그리고 CSS 파일을 업데이트해야 합니다.\n\n# 단계 05: 본문 상단에 컨테이너 추가하기\n\n\n<div class=\"content-ad\"></div>\n\n먼저, 상단 컨테이너를 추가합니다. 로고, 검색 바, 이미지, 제목 및 소셜 아이콘을 포함했습니다.\n\n```js\n  <div class=\"container\">\n        <div class=\"logo\">\n            <img src=\"Images/logo.png\" alt=\"Programming PEN\">\n        </div>\n        <div class=\"sectionSearch\">\n            <div class=\"searchBox\">\n                <i class=\"fas fa-search\"></i>\n                <input type=\"search\" placeholder=\"검색\">\n            </div>\n        </div>\n        <div class=\"firstSectinImage\">\n            <img src=\"Images/photo01.jpg\" alt=\"\" srcset=\"\">\n        </div>\n        <div class=\"firstSectionHeading\">\n            <h1><span>여름</span> 특별행사</h1>\n            <h1 class=\"letterSpacing\"> 컬렉션 <span>할인혜택 포함</span></h1>\n            <button class=\"btnBuyNow\">지금 구매</button>\n        </div>\n        <div class=\"mediaIcons\">\n            <a href=\"#\"><i class=\"fab fa-facebook-f\"></i></a>\n            <a href=\"#\"><i class=\"fab fa-twitter\"></i></a>\n            <a href=\"#\"><i class=\"fab fa-instagram\"></i></a>\n            <a href=\"#\"><i class=\"fab fa-youtube\"></i></a>\n        </div>\n    </div>\n    <script src=\"https://kit.fontawesome.com/9e5a623fa6.js\" crossorigin=\"anonymous\"></script>\n```\n\n여기서 container, logo, sectionSearch, firstSectinImage, firstSectionHeading, letterSpacing, btnBuyNow 및 mediaIcons 클래스를 지정했습니다. 따라서 해당 클래스에 스타일을 적용하려면 해당 클래스 이름을 참조하십시오.\n\n```js\n* {\n  margin: 0;\n  padding: 0;\n  font-family: sans-serif;\n}\n.container {\n  width: 100%;\n  height: 100vh;\n}\n.logo {\n  position: absolute;\n  top: 50px;\n  left: 90px;\n}\n.sectionSearch {\n  position: fixed;\n  top: 50px;\n  right: 90px;\n  width: 170px;\n  height: 45px;\n  background-color: #fff;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border-radius: 10% 10% 10% 10% / 50% 50% 50% 50%;\n  box-shadow: 2px 2px 30px rgba(167, 158, 245, 0.2);\n  box-sizing: border-box;\n  z-index: 1;\n  border: 1px solid rgba(167, 158, 245, 0.1);\n}\n.searchBox input {\n  width: 90px;\n  height: 20px;\n  border: none;\n  outline: none;\n  background-color: transparent;\n  color: #1f1f1f;\n  font-size: 1rem;\n  padding: 0px 10px;\n}\nfirstSectinImage {\n  position: absolute;\n  left: 15%;\n  top: 50%;\n  transform: translate(-15%, -50%);\n}\nfirstSectinImage img {\n  height: 400px;\n}\nfirstSectionHeading {\n  position: absolute;\n  top: 50%;\n  left: 70%;\n  transform: translate(-40%, -50%);\n}\nfirstSectionHeading h1 {\n  font-family: roboto, arial, helvetica;\n  font-weight: bold;\n  margin: 0px;\n  line-height: 60px;\n  font-size: 2.4rem;\n  text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.4);\n  color: #3d3d4a;\n  text-transform: uppercase;\n}\n.letterSpacing {\n  letter-spacing: 7px;\n}\n.firstSectionHeading span {\n  color: #5b53ff;\n}\n.btnBuyNow {\n  width: 150px;\n  height: 40px;\n  background-color: #2f2e41;\n  box-shadow: 2px 2px 30px rgba(0, 0, 0, 0.1);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border-radius: 10% 10% 10% 10% / 50% 50% 50% 50%;\n  margin-top: 20px;\n  color: #fff;\n  font-family: Cambria, Cochin, Georgia, Times, \"Times New Roman\", serif;\n  font-weight: 600;\n  letter-spacing: 0.5px;\n  font-size: 1rem;\n  outline: none;\n  cursor: pointer;\n  border: transparent !important;\n}\n.btnBuyNow:hover {\n  color: #fff;\n  background-color: #5b53ff;\n  transition: all ease 0.5s;\n}\nmediaIcons {\n  position: fixed;\n  left: 30px;\n  top: 50%;\n  transform: translateY(-50%);\n  border-radius: 20px;\n  background-color: #fff;\n  box-shadow: 2px 2px 30px rgba(0, 0, 0, 0.2);\n  padding: 1px 2px;\n  z-index: 1;\n}\nmediaIcons a {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  padding: 20px 15px;\n  text-decoration: none;\n}\nmediaIcons a i {\n  color: rgba(39, 39, 39, 0.8);\n}\nmediaIcons a:hover .fa-facebook-f {\n  color: #5078cf;\n}\nmediaIcons a:hover .fa-twitter {\n  color: #00acee;\n}\nmediaIcons a:hover .fa-instagram {\n  color: #fd9217;\n}\nmediaIcons a:hover .fa-youtube {\n  color: #ff0000;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n표 태그를 마크다운 형식으로 변경했어요.\n\n<img src=\"/assets/img/2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS_3.png\" />\n\n# 단계 05: 제품 섹션 추가\n\n`section` 태그는 문서 내의 섹션을 정의합니다. 여기서 몇 가지 섹션을 추가했어요. 먼저, 제품 섹션입니다.\n\n<div class=\"content-ad\"></div>\n\n\n# 제품 섹션\r\n이곳은 새로운 제품 컬렉션을 소개하는 곳입니다.\r\n\r\n- 베이비 걸 드레스\r\n- 남성 블레이저 자켓\r\n- 남성 소프트 플란넬 셔츠\r\n- 여성 코트 테니스화\r\n- 여성 스탠다드 셔츠 자켓\r\n- 남성 패션 시계\r\n\r\n각 제품은 각각의 가격과 함께 카트에 담을 수 있는 링크가 제공됩니다.\r\n\r\n디자인된 CSS 스타일은 각 클래스 이름을 참조하도록 정의되어 있습니다.\r\n\r\n이미지는 마크다운 형식에 맞게 추가되어 있습니다.\r\n\r\n자세한 내용은 이미지를 참조해주세요.\r\n\n\n<div class=\"content-ad\"></div>\n\n# 단계 05: 어바웃 섹션 추가\n\n비즈니스/회사에 대한 섹션을 추가하는 것이 중요합니다. 따라서 몇 가지 세부 사항을 언급한 다음 섹션을 추가했습니다.\n\n```js\n  <section class=\"aboutCompany\">\n      <div class=\"aboutBox\">\n          <h1>Genotechies Clothes Inc.</h1>\n          <h4>세계 모두를 위한 최신 패션 트렌드 <span>지금 구매하세요</span></h4>\n          <p>세계 곳곳에 위치한 수천 개의 매장을 보유한 글로브 최대 패션 체인은 남성, 여성 및 아동을 위한 다양한 옷과 액세서리를 제공하기 위해 헌신되어 있습니다...</p>\n      </div>\n      <div class=\"aboutBox\">\n          <img src=\"Images/photo02.jpg\">\n      </div>\n  </section>\n```\n\n```js\n.aboutCompany {\n    width: 85%;\n    display: flex;\n    margin: 50px auto;\n    justify-content: space-around;\n    align-items: center;\n    padding: 30px;\n    margin-bottom: 100px;\n  }\n  .aboutCompany span {\n    color: #5b53ff;\n  }\n  .aboutBox {\n    width: 40%;\n    font-family: \"Franklin Gothic Medium\", \"Arial Narrow\", Arial, sans-serif;\n  }\n  .aboutBox img {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n  }\n  .aboutBox h1 {\n    color: #333333;\n    font-weight: 700;\n    font-size: 3rem;\n    margin: 0;\n  }\n  .aboutBox h4 {\n    color: #333333;\n    font-weight: 400;\n    font-size: 2rem;\n    margin-top: 10px;\n    margin-bottom: 10px;\n  }\n  .aboutBox p {\n    font-size: 1rem;\n    color: #bdbdbd;\n    letter-spacing: 0.5px;\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot](/assets/img/2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS_5.png)\n\n# Step 06: 사용자 구독 섹션 추가\n\n사용자들은 제품 업데이트를 받기 위해 웹 사이트의 이메일 주소를 사용하여 구독할 수 있습니다.\n\n```js\n    <section class=\"newsletter\">\n        <h3>새 제품 업데이트 구독</h3>\n        <div class=\"inputEmail\">\n            <input type=\"email\" placeholder=\"이메일을 입력하세요\">\n            <button type=\"submit\" class=\"btnSend\">전송</button>\n        </div>\n    </section>\n```\n\n<div class=\"content-ad\"></div>\n\n```js\r\n.newsletter {\r\n  width: 100%;\r\n  height: 250px;\r\n  margin-bottom: 30px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border-bottom: 2px solid rgba(0, 0, 0, 0.03);\r\n}\r\n.newsletter h3 {\r\n  font-size: 2rem;\r\n  color: #565656;\r\n}\r\n.inputEmail {\r\n  width: 500px;\r\n  background-color: #fff;\r\n  border-radius: 7% 7% 7% 7% / 50% 50% 50% 50%;\r\n  height: 60px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  padding: 5px 20px;\r\n  box-shadow: 2px 5px 30px rgba(0, 0, 0, 0.1);\r\n  margin-top: 30px;\r\n}\r\n.inputEmail input {\r\n  width: 100%;\r\n  height: 40px;\r\n  border: none;\r\n  outline: none;\r\n  background-color: transparent;\r\n}\r\n.btnSend {\r\n  width: 120px;\r\n  height: 40px;\r\n  background-color: #202020;\r\n  border-radius: 20px;\r\n  color: #fff;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  text-transform: uppercase;\r\n  font-weight: bold;\r\n  box-shadow: 2px 2px 30px rgba(0, 0, 0, 0.1);\r\n  font-size: 1rem;\r\n}\r\n.btnSend:hover {\r\n  background-color: #6b60ec;\r\n  transition: all ease 0.5s;\r\n}\r\n```\r\n\r\n![Image](/assets/img/2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS_6.png)\r\n\r\n# Step 07: Footer section 추가하기\r\n\r\n`footer` 태그는 문서나 섹션의 하단에 푸터를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n    <!-- Footer Section-->\n    <footer class=\"footerSection\">\n        <div id=\"footerContanier\">\n\n            <div id=\"footerLogoLeft\">\n                GENOTECHIES CLOTHES\n            </div>\n            <div id=\"footerSocialIcon\">\n                <img src=\"Images/instagram-icon.png\">\n                <img src=\"Images/facebook-icon.png\">\n                <img src=\"Images/twitter-icon.png\">\n                <img src=\"Images/youtube-icon.png\">\n            </div>\n\n            <div id=\"footerCenter\">\n\n                <h3>Contact Us</h3>\n                <p><span>Tel:</span>061 765 342 122</p>\n                <p><span>E-Mail:</span>hello@genotechies.com</p>\n                <p><span>Web:</span>www.genotechies.com</p>\n                <p><span>Adress:</span>427, Brisbain Road, Canel Street, CA, US</p>\n\n            </div>\n\n            <div id=\"footerRight\">\n                <h3>About Us</h3>\n                <p>Globe biggest fashion chain with its thousands of outlets located world wide is dedicated to offer a wide array of Clothes and Accessories for Men, Women and Children</p>\n            </div>\n        </div>\n    </footer>\r\n```\n\n```js\r\nfooter {\n    width: 100%;\n    height: 200px;\n    background-color: #201f1f;\n    background-size: cover;\n    position: relative;\n}\n\n#footerContanier {\n    width: 1526px;\n    margin: auto;\n    position: relative;\n}\n\n#footerContanier #footerLogoLeft {\n    font-family: 'Pacifico', cursive;\n    font-size: 25px;\n    font-weight: bold;\n    color: #ffffff;\n    position: relative;\n    left: 60px;\n    display: inline-block;\n}\n\n#footerContanier #footerSocialIcon {\n    position: relative;\n    top: 100px;\n    left: -220px;\n    display: inline-block;\n}\n\n#footerContanier #footerSocialIcon img {\n    width: 50px;\n    height: 50px;\n    cursor: pointer;\n}\n\n#footerContanier #footerSocialIcon img:hover {\n    transform: scale(1.1);\n}\n\n#footerContanier #footerCenter {\n    width: 430px;\n    position: absolute;\n    top: -10px;\n    left: 545px;\n    color: #ffffff;\n    text-align: center;\n}\n\n#footerContanier #footerCenter h3,\n#footerRight h3 {\n    font-size: 40px;\n    font-family: 'Righteous';\n    border-bottom: 2px solid red;\n    text-align: center;\n    margin-bottom: 10px;\n    padding-bottom: 5px;\n}\n\n#footerRight input:focus {\n    border: 2px solid blue;\n}\n\n#footerContanier #footerCenter p {\n    line-height: 30px;\n}\n\n#footerContanier #footerCenter p span {\n    color: red;\n    font-weight: 400;\n    text-indent: 10px;\n    margin-right: 10px;\n}\n\n#footerContanier #footerRight {\n    width: 400px;\n    left: 1030px;\n    display: inline-block;\n    position: absolute;\n    top: -10px;\n    color: white;\n    text-align: center;\n}\n\n#footerContanier #footerRight p {\n    padding: 10px;\n    line-height: 30px;\n    padding-bottom: 20px;\n}\n\n#footerContanier #footerRight input {\n    margin-top: 10px;\n    width: 280px;\n    height: 28px;\n    text-align: center;\n    font-size: 15px;\n}\r\n```\n\n<img src=\"/assets/img/2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS_7.png\" />\n\nGitHub에서 이 작은 웹사이트 디자인을 찾아보세요.\n\n<div class=\"content-ad\"></div>\n\n본 게시물이 유용하셨다면 아래의 👏 버튼을 눌러주세요! :)","ogImage":{"url":"/assets/img/2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS_0.png"},"coverImage":"/assets/img/2024-06-23-CreateaSimpleSinglePageWebsiteUsingHTMLandCSS_0.png","tag":["Tech"],"readingTime":14}],"page":"5","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}