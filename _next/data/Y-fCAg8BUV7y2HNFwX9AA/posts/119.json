{"pageProps":{"posts":[{"title":"오픈 소스로 배우는 팁 Nextjs에서 리다이렉트가 어떻게 작동하는지 살펴보기","description":"","date":"2024-05-14 11:04","slug":"2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood","content":"\n\n이 기사에서는 넥스트.js에서 리다이렉션 작동 방식을 살펴보면서 넥스트.js 소스 코드 주변의 리다이렉션 기능에 대해 배우게 됩니다.\n\n# 나의 접근 방식:\n\n- Import를 시작으로\n- Redirect 함수를 redirect.ts 파일까지 추적\n- redirect.ts 설명\n- 에러를 throw 하는 것이 리디렉션이 작동하는 방법\n- 전체 맥락을 이해하기 위해 redirect.test.ts 확인\n- redirect-boundary.ts에 리다이렉션 기능이 있음\n\n# 1. Import를 시작으로:\n\n\n\n리다이렉트 함수는 next/navigation에서 가져온 것입니다. 리다이렉트에 대해 더 알고 싶다면 다음 링크를 확인해보세요: https://nextjs.org/docs/app/api-reference/functions/redirect.\n\n하지만 next/navigation 코드는 어디에서 찾을 수 있을까요? navigation.js 파일에서 이 코드를 찾을 수 있습니다. 이 파일은 기본적으로 navigation.ts를 내보내는데, 이는 /packages/next/src/client/components에 있습니다.\n\n# 2. 리다이렉트 함수를 redirect.ts 파일로 추적하기\n\n현재 이 글을 작성하는 시점에서 navigation.ts에는 272줄의 코드가 있지만, 우리가 관심 있는 것은 파일 끝에 아래와 같이 표시된 \"redirect\"의 내보내기입니다. 찾고자 하는 것에 집중하세요. 다른 코드에 방해받지 마세요.\n\n\n\n\"여기 보시다시피, redirect는 navigation.react-server.ts에서 내보내는 것입니다. navigation.react-server.ts 안에 들어가보면, redirect 함수가 실제로 redirect.ts에서 왔다는 것을 알게 될 거에요.\n\n저는 중첩된 내보내기를 몰랐어요. 흥미롭네요.\"\n\n\n\n# 3. Render.ts 설명\n\n“redirect() 함수를 호출하면 NEXT_REDIRECT 오류가 발생하고 발생한 위치의 라우트 세그먼트의 렌더링을 중단합니다.\" — Nextjs 문서\n\nredirect.ts 파일 내에서 오류를 발생시키는 코드 조각을 살펴봅시다.\n\n![이미지](/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_2.png)\n\n\n\n# 4. 에러를 발생시켜서 리디렉션이 작동하는 방식은 무엇인가요?\n\n리디렉트 함수가 에러를 발생시켜서 에러.digest를 설정하지만, 에러를 발생시켜서 리디렉션이 작동하는 방식이 명확하지 않았습니다.\n\n오랫동안 찾아봤고, 리디렉트가 에러를 발생시킨다는 것을 고려하여 catch 블록을 찾으려고 노력했습니다. 서버 관련 파일을 뒤져봐도 도움이 되지 않았어요.\n\nredirect.test.ts를 살펴보면서 조금씩 이해되기 시작했어요.\n\n\n\n# 5. 전체 맥락을 이해하려면 redirect.test.ts를 확인하세요\n\n![image](/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_3.png)\n\n한 번 어딘가에서 함수의 컨텍스트를 이해하는 데 테스트를 사용할 수 있다고 읽은 적이 있습니다. 그래서 redirect.test.ts에서 코드를 확인한 이유입니다.\n\n테스트 코드에서 getURLFromRedirectError(err) 함수가 호출되는 것이 명백합니다. 이 함수는 react-boundary.ts에서 찾을 수 있습니다.\n\n\n\n알겠어요. 테스트에서는 getURLFromRedirectError 함수를 호출하는데 실행 흐름은 어떻게 될까요? 에러가 발생한 후에는 무엇이 일어날까요? getURLFromRedirectError 함수를 기반으로 검색한 결과는 다음과 같아요:\n\n![이미지](/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_4.png)\n\n## 6. redirect-boundary.ts에는 리디렉션 기능이 있어요\n\n답은 Next.js 리디렉션이 useRouter 훅을 사용하며 리디렉션 유형에 따라 URL을 푸시하거나 교체합니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_5.png\" />\n\n이 리다이렉트 경계는 아래에 표시된 앱-라우터 코드의 일부입니다.\n\n<img src=\"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_6.png\" />\n\n리다이렉트에서 오류가 발생하면 리다이렉트 경계에서 오류가 catch되고 리다이렉트가 발생합니다. 리다이렉트 함수 자체가 리다이렉트를 수행하지 않고 앱-라우터 내부의 리다이렉트 경계가 라우팅 로직을 처리하는 것이 상당히 흥미로운 점입니다.\n\n\n\n# 결론:\n\n나는 이 API가 왜 이런 식으로 설계되었는지 모르겠지만, 여기에 오류를 throw하는 패턴을 사용하고 해당 오류를 catch하고 원하는 작업을 수행하는 boundary 를 사용할 수 있습니다. 이 npm 패키지에서 오류를 throw하는 패턴을 사용하여 해당 오류를 catch하고 원하는 작업을 수행하는 boundary 를 사용해 보세요.\n\nredirect.test.ts 코드를 확인하지 않았다면, redirect 작동 방식을 파악하지 못했을 것입니다. 나는 redirect.ts 에 catch 블록을 찾고 있었지만 그렇지 않았기 때문입니다.\n\n이 글에 대해 궁금한 점이 있으시면 언제든지 ramu.narasinga@gmail.com 으로 연락 주세요.\n\n\n\n# 더 많은 자료:\n\n- [navigation.react-server.ts](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/src/client/components/navigation.react-server.ts)\n- [navigation.js](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/navigation.js)\n- [redirect.ts](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/src/client/components/redirect.ts)\n- [redirect.test.ts](https://github.com/vercel/next.js/blob/canary/packages/next/src/client/components/redirect.test.ts)\n- [redirect-boundary.tsx](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/src/client/components/redirect-boundary.tsx#L8)","ogImage":{"url":"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_0.png"},"coverImage":"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_0.png","tag":["Tech"],"readingTime":4},{"title":"Lexical와 함께하는 React용 리치 텍스트 에디터 시작하기","description":"","date":"2024-05-14 11:00","slug":"2024-05-14-GettingStartedwithLexicalRichTextEditorforReact","content":"\n\n## React JS에서 Lexical을 사용하는 방법에 대한 튜토리얼; 예제와 함께 기본 사항.\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png\" />\n\n... 그러나 유감스럽게도 이 문서는 좋은 설명의 예시가 아닙니다. 이 기사에서는 이 라이브러리를 어떻게 사용하는지를 간단한 용어로 설명하겠습니다.\n\n여기서는 특별한 스타일, 모달 또는 팝오버 없이 렉시컬 리치 텍스트 기능의 기본을 다룰 것입니다:\n\n\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_1.png)\n\n만약 이 라이브러리가 무엇을 할 수 있는지 확인하고 싶다면, 멋진 렉시컬 플레이그라운드를 확인해보세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_2.png)\n\n관련 이야기:\n\n\n\n# 다룰 내용\n\n- 준비물\n- 시작하기\n- 히스토리 플러그인\n- 노드\n- 리치 텍스트\n- 테마\n- 제목, 도우미 및 노드 구성\n- 페이로드로 자신만의 명령어를 만드는 방법\n- 사용자 정의 노드 만들기\n\n# 준비물\n\n우리는 다음과 같이 만들어진 간단한 React JS 애플리케이션으로 시작할 것입니다:\n\n\n\n```js\nyarn create react-app react-lexical-examples --template typescript\n```\n\n그리고 우리는 어휘 패키지를 설치해야 합니다:\n\n```js\nyarn add lexical @lexical/react\n\n// OR\n\nnpm install --save lexical @lexical/react\n```\n\n# 시작\n\n\n\n\nLexical을 이용하여 작업을 시작하려면 이 템플릿을 사용할 수 있어요:\n\n```js\nimport React, {useMemo} from 'react';\nimport {InitialConfigType, LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {PlainTextPlugin} from \"@lexical/react/LexicalPlainTextPlugin\";\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n\nexport const App: React.FC = () => {\n\n    const CustomContent = useMemo(() => {\n        return (\n            <ContentEditable style={\n                position: 'relative',\n                borderColor: 'rgba(255,211,2,0.68)',\n                border: '2px solid red',\n                borderRadius: '5px',\n                maxWidth: '100%',\n                padding: '10px'\n            }/>\n        )\n    }, []);\n\n    const CustomPlaceholder = useMemo(() => {\n        return (\n            <div style={\n                position: 'absolute', top: 30, left: 30,\n            }>\n                텍스트를 입력하세요...\n            </div>\n        )\n    }, []);\n\n    const lexicalConfig: InitialConfigType = {\n        namespace: '나의 리치 텍스트 편집기',\n        onError: (e) => {\n            console.log('에러 발생:', e)\n        }\n    }\n\n    return (\n        <div style={padding: '20px'}>\n            <LexicalComposer initialConfig={lexicalConfig}>\n                <PlainTextPlugin\n                    contentEditable={CustomContent}\n                    placeholder={CustomPlaceholder}\n                    ErrorBoundary={LexicalErrorBoundary}\n                />\n            </LexicalComposer>\n        </div>\n    );\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*-7S9xp-EweAiYl8Fn0O8_w.gif)\n\n보다시피, 아주 복잡해 보이지 않죠. 걱정하지 마세요, 나중에 이 컴포넌트들에 대해 자세히 다룰 거예요. 일단은 모든 것이 예상대로 작동하는지 확인하는 것이 중요해요.\n\n\n\n이제 기능을 하나씩 추가해 봅시다.\n\n# 히스토리 플러그인\n\n이전 예제에서 새 텍스트를 입력할 수 있었지만, CTRL-Z(실행 취소)를 누르면 아무 일도 일어나지 않았죠. 이 문제를 해결하기 위해 @lexical/history 플러그인을 추가하여 CTRL-Z(실행 취소)와 CTRL-SHIFT-Z(다시 실행)를 사용할 수 있게 할 수 있습니다.\n\n선택 사항으로 직접 Undo/Redo를 처리하는 사용자 정의 컴포넌트를 추가할 수도 있습니다:\n\n\n\n```js\n@@ -3,6 +3,8 @@\n import {PlainTextPlugin} from \"@lexical/react/LexicalPlainTextPlugin\";\n import {ContentEditable} from '@lexical/react/LexicalContentEditable';\n import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n+import {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\n+import {CustomHistoryActions} from \"./components\";\n \n export const App: React.FC = () => {\n \n@@ -44,7 +46,12 @@\n                     placeholder={CustomPlaceholder}\n                     ErrorBoundary={LexicalErrorBoundary}\n                 />\n+                <HistoryPlugin/>\n+                <div style={margin: '20px 0px'}>\n+                    <CustomHistoryActions/>\n+                </div>\n             </LexicalComposer>\n+\n         </div>\n     );\n }\n```\n\n```js\nimport {UNDO_COMMAND, REDO_COMMAND} from 'lexical';\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\n\nexport const CustomHistoryActions = () => {\n    const [editor] = useLexicalComposerContext();\n    return (\n        <>\n            <button onClick={() => editor.dispatchCommand(UNDO_COMMAND, undefined)}>되돌리기</button>\n            <button onClick={() => editor.dispatchCommand(REDO_COMMAND, undefined)}>다시 실행</button>\n        </>\n    );\n}\n```\n\n설명:\n\n- editor는 `LexicalComposer/` 컴포넌트에서 가져온 컨텍스트 값입니다. 에디터 클래스/메소드에 대한 자세한 내용은 여기서 확인할 수 있습니다:\n\n\n\n간단한 사용 예시:\n\n```js\nconst [editor] = useLexicalComposerContext();\n\n  useEffect(() => {\n    // 이펙트가 발생할 때 에디터에 포커스를 맞춥니다!\n    editor.focus();\n  }, [editor]);\n```\n\n- UNDO_COMMAND과 REDO_COMMAND는 에디터 내용(또는 원하는 내용)을 처리해야 할 것을 렉시컬에 알리는 등록된 렉시컬 명령입니다. 다음과 같이 사용자 고유의 명령을 생성할 수도 있습니다:\n\n```js\nimport { createCommand, COMMAND_PRIORITY_NORMAL } from \"lexical\";\n\nexport const DO_SOMETHING_AWESOME = createCommand(\"create_banner\");\n\nexport const CustomComponent: React.FC = () => {\n  const [editor] = useLexicalComposerContext();\n\n  editor.registerCommand(\n    DO_SOMETHING_AWESOME,\n    () => {\n      console.log('이것은 내가 만든 명령입니다')\n      return true;\n    },\n    COMMAND_PRIORITY_NORMAL,\n  );\n\n  return null;\n};\n```\n\n\n\n걱정하지 마세요, 나중에 이 주제를 조금 더 다룰 거예요.\n\n- editor.dispatchCommand(UNDO_COMMAND, undefined) → 왜 두 번째 인자로 undefined를 전달하는 걸까요? 첫 번째, 그렇게 하지 않으면 TS 오류가 발생합니다. 둘째, 이것은 명령과 함께 전달될 수 있는 페이로드 데이터입니다(우리 경우에는 해당되지 않습니다). dispatchCommand에 대해 더 알아보세요.\n\n# 노드\n\n이 섹션에서는 용어의 작동 방식과 저장하는 데이터에 대해 깊이 파헤쳐야 할 것입니다.\n\n\n\n먼저, 에디터의 상태 변화를 모니터링하고 에디터의 상태를 로깅하는 간단한 플러그인을 만들 것입니다:\n\n```js\n// src/components/OnChangePlugin/OnChangePlugin.tsx\n\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {useEffect} from \"react\";\n\nexport const OnChangePlugin = () => {\n    const [editor] = useLexicalComposerContext();\n    useEffect(() => {\n        return editor.registerUpdateListener((listener) => {\n            console.log('DATA', listener.editorState.toJSON())\n        });\n    }, [editor]);\n\n    return null;\n}\n```\n\n다음으로, `LexicalComposer/`의 하위 컴포넌트로 `OnChangePlugin/` 컴포넌트를 추가해주세요:\n\n```js\nIndex: src/App.tsx\n@@ -5,6 +5,7 @@\n import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n import {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\n import {CustomHistoryActions} from \"./components\";\n+import {OnChangePlugin} from \"./components\";\n\nexport const App: React.FC = () => {\n\n@@ -47,6 +48,7 @@\n                    ErrorBoundary={LexicalErrorBoundary}\n                />\n                <HistoryPlugin/>\n+                <OnChangePlugin />\n                <div style={margin: '20px 0px'}>\n                    <CustomHistoryActions/>\n                </div>\n```\n\n\n\n이제 편집기의 상태가 변경될 때마다 편집기의 상태 트리 데이터를 콘솔에 출력할 것입니다:\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_3.png)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Lqyfyb4peVPoHJQvYuBNhQ.gif)\n\n이 텍스트를 입력하면 어떤 데이터를 얻을지 확인해 봅시다:\n\n\n\n```json\n{\n  \"root\": {\n    \"children\": [\n      {\n        \"children\": [\n          {\n            \"detail\": 0,\n            \"format\": 0,\n            \"mode\": \"normal\",\n            \"style\": \"\",\n            \"text\": \"asd\",\n            \"type\": \"text\",\n            \"version\": 1\n          },\n          {\n            \"type\": \"linebreak\",\n            \"version\": 1\n          },\n          {\n            \"detail\": 0,\n            \"format\": 0,\n            \"mode\": \"normal\",\n            \"style\": \"\",\n            \"text\": \"dsa\",\n            \"type\": \"text\",\n            \"version\": 1\n          }\n        ],\n        \"direction\": \"ltr\",\n        \"format\": \"\",\n        \"indent\": 0,\n        \"type\": \"paragraph\",\n        \"version\": 1\n      }\n    ],\n    \"direction\": \"ltr\",\n    \"format\": \"\",\n    \"indent\": 0,\n    \"type\": \"root\",\n    \"version\": 1\n  }\n}\n```\n\n아마도 노드가 간단한 속성을 가진 객체임을 알았을겁니다. 주요 속성은 노드의 종류인 type과 노드의 내용인 text입니다.\n\n\n\n```js\nimport initialState from './initialState.json';\n\n// ...\n\nreturn (\n      <LexicalComposer\n        initialConfig={\n          // ...\n          editorState: JSON.stringify(initialState),\n        }\n      >\n            {/* ... */}\n      </LexicalComposer>\n    );\n```\n\n이 경우 앱을 다시 시작할 때마다 동일한 결과를 얻을 수 있습니다:\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_4.png\" />\n\nNodes에 대해 더 많은 정보를 읽어보실 수 있습니다.\n\n\n\n\n# 리치 텍스트\n\n첫 번째 노드 수정 핸들러를 만들어 봅시다.\n\n이전에 PlainTextPlugin 컴포넌트를 사용했기 때문에 \"bold\" (CTRL+B) 액션과 같은 텍스트 작업을 처리할 수 없습니다:\n\n```js\n<LexicalComposer initialConfig={lexicalConfig}>\n  <PlainTextPlugin ...  />\n...\n</LexicalComposer>\n```\n\n\n\nApp.tsx 파일에서 PlainTextPlugin을 RichTextPlugin으로 변경해야 합니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -1,6 +1,6 @@\n import React, {useMemo} from 'react';\n import {InitialConfigType, LexicalComposer} from '@lexical/react/LexicalComposer';\n-import {PlainTextPlugin} from \"@lexical/react/LexicalPlainTextPlugin\";\n+import {RichTextPlugin} from \"@lexical/react/LexicalRichTextPlugin\";\n import {ContentEditable} from '@lexical/react/LexicalContentEditable';\n import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n import {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\n@@ -46,7 +46,7 @@\n             <LexicalComposer\n                 initialConfig={lexicalConfig}\n             >\n-                <PlainTextPlugin\n+                <RichTextPlugin\n                     contentEditable={CustomContent}\n                     placeholder={CustomPlaceholder}\n                     ErrorBoundary={LexicalErrorBoundary}\n```\n\n이제 에디터에서 기본 텍스트 작업을 사용할 수 있을 것입니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:768/1*GWYMSFDfd3PI2PSh5bVsYw.gif\" />\n\n\n\n우리의 커스텀 버튼을 만들어 봅시다:\n\n```js\n// src/components/CustomTextActions/CustomTextActions.tsx\n\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {FORMAT_TEXT_COMMAND, TextFormatType} from 'lexical';\n\nexport const CustomTextActions = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (formatType: TextFormatType) => {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, formatType)\n    }\n\n    return (\n        <div style={{marginTop: '10px'}}>\n            <span style={{fontWeight: 'bold'}}>텍스트 액션</span>\n            <div>\n                {[\n                    '굵게',\n                    '이탤릭체',\n                    '밑줄',\n                    '코드',\n                    '하이라이트',\n                    '취소선',\n                    '아래첨자',\n                    '위첨자'\n                ].map(value => {\n                    return (\n                        <button\n                            onClick={() => handleOnClick(value.toLowerCase() as TextFormatType)}>\n                            {value}\n                        </button>\n                    )\n                })}\n            </div>\n        </div>\n    );\n}\n```\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_5.png\" />\n\n하지만 텍스트를 수정하려고 하면 기대했던 결과가 나오지 않을 수 있습니다: 일부 항목은 변경되고 일부는 변경되지 않을 수 있습니다. 그 이유가 무엇일까요?\n\n\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_6.png\" />\n\nHTML 출력을 확인해 봅시다:\n\n```js\n<p dir=\"ltr\"><strong data-lexical-text=\"true\">굵게</strong></p>\n<p dir=\"ltr\"><em data-lexical-text=\"true\">이탤릭체</em></p>\n<p dir=\"ltr\"><span data-lexical-text=\"true\">밑줄</span></p>\n<p dir=\"ltr\"><code data-lexical-text=\"true\"><span>코드</span></code></p>\n<p dir=\"ltr\">\n    <mark data-lexical-text=\"true\"><span>강조</span></mark>\n</p>\n<p dir=\"ltr\"><span data-lexical-text=\"true\">취소선</span></p>\n<p dir=\"ltr\"><sub data-lexical-text=\"true\"><span>아래 첨자</span></sub></p>\n<p dir=\"ltr\"><sup data-lexical-text=\"true\"><span>위 첨자</span></sup></p>\n<p dir=\"ltr\"><code data-lexical-text=\"true\"><strong>모두 표시</strong></code></p>\n```\n\n요소에는 적용된 스타일이 없지만 브라우저에서 `mark`/`strong/`/`em/`에 대한 사전 정의된 스타일이 있어 약간의 스타일 변화가 있습니다. 그러나 우리가 기대한 것은 아닙니다.\n\n\n\n이제 다음 주제인 → 테마를 다루어볼 시간입니다.\n\n👉 작은 참고사항입니다. Align 작업 구현이 이렇게 보일 것입니다 (텍스트와 동일한 디스패치 명령어 접근 방식):\n\n```js\nimport {\n    useLexicalComposerContext\n} from \"@lexical/react/LexicalComposerContext\";\nimport {\n    FORMAT_ELEMENT_COMMAND,\n    ElementFormatType,\n    OUTDENT_CONTENT_COMMAND,\n    INDENT_CONTENT_COMMAND\n} from 'lexical';\n\nexport const CustomAlignActions = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (formatType: ElementFormatType) => {\n        editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, formatType)\n    }\n\n    return (\n        <div style={marginTop: '10px'}>\n            <span style={fontWeight: 'bold'}>Align actions</span>\n            <div>\n                {[\n                    'Left',\n                    'Center',\n                    'Right',\n                    'Justify',\n                ].map(value => {\n                    return (\n                        <button\n                            onClick={() => handleOnClick(value.toLowerCase() as ElementFormatType)}>\n                            {value}\n                        </button>\n                    )\n                })}\n                <button\n                    onClick={() => editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined)}>\n                    Outdent\n                </button>\n                <button\n                    onClick={() => editor.dispatchCommand(INDENT_CONTENT_COMMAND, undefined)}>\n                    Indent\n                </button>\n            </div>\n        </div>\n    );\n}\n```\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_7.png)\n\n\n\n위의 경우 \"정당화\" 노드가 편집기 상태 JSON에서 어떻게 나타낼지에 대한 예시입니다:\n\n```js\n{\n  \"children\": [\n    {\n      \"detail\": 0,\n      \"format\": 1,\n      \"mode\": \"normal\",\n      \"style\": \"\",\n      \"text\": \"Justify\",\n      \"type\": \"text\",\n      \"version\": 1\n    },\n    {\n      \"detail\": 0,\n      \"format\": 0,\n      \"mode\": \"normal\",\n      \"style\": \"\",\n      \"text\": \" - Lorem ipsum dolor sit amet, <...>\",\n      \"type\": \"text\",\n      \"version\": 1\n    }\n  ],\n  \"direction\": \"ltr\",\n  \"format\": \"justify\",\n  \"indent\": 0,\n  \"type\": \"paragraph\",\n  \"version\": 1\n}\n```\n\n# 테마\n\nNodes를 수정할 때, lexical은 테마 객체 theme.[`노드-타입`]에서 지정된 노드 타입에 대해 스타일(클래스 이름)을 적용합니다.\n\n\n\n해달 코드를 추가하고 텍스트 스타일을 적용해 보겠습니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -10,6 +10,7 @@\n     CustomHistoryActions\n } from \"./components\";\n import initialState from './initialState.json';\n+import './App.css'\n \n export const App: React.FC = () => {\n \n@@ -38,6 +39,18 @@\n \n     const lexicalConfig: InitialConfigType = {\n         namespace: 'My Rich Text Editor',\n+        theme: {\n+            text: {\n+                bold: \"text-bold\",\n+                italic: \"text-italic\",\n+                underline: \"text-underline\",\n+                code: 'text-code',\n+                highlight: 'text-highlight',\n+                strikethrough: 'text-strikethrough',\n+                subscript: 'text-subscript',\n+                superscript: 'text-superscript',\n+            },\n+        },\n         onError: (e) => {\n             console.log('ERROR:', e)\n         },\n```\n\nCSS:\n\n```js\n.text-bold {\n    font-weight: bold;\n}\n\n.text-italic {\n    font-style: italic;\n}\n\n.text-underline {\n    text-decoration: underline;\n}\n\n.text-code {\n    background-color: #f0f2f5;\n    padding: 1px 0.25rem;\n    font-family: Menlo, Consolas, Monaco, monospace;\n    font-size: 94%;\n}\n\n.text-highlight {\n    margin: 0 5px;\n}\n\n.text-strikethrough {\n    text-decoration: line-through;\n}\n\n.text-subscript {\n    vertical-align: sub;\n}\n\n.text-superscript {\n    vertical-align: super;\n}\n\np {\n    margin: 0;\n}\n```\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1260/1*_KW7zAxitBpOe3HrAqHHfw.gif)\n\n![image](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_8.png)\n\n**Bold**\n*Italic*\n<ins>Underline</ins>\n`Code`\n<mark>Highlight</mark>\n~~Strike~~\nX<sub>Sub</sub>\nX<sup>Super</sup>\n<mark><strong><em><ins><u><strike><sub>All of them</sub></strike></u></ins></em></strong></mark>\n\n\n\n\n알겠지만, 우리가 디스패치를 트리거할 때마다, 렉시컬이 클래스를 교체하지 않고, 있는 경우 추가하거나 있는 경우 제거했습니다. 이 점을 명심해주세요. \"굵게 기울임체 밑줄\"에 대해 별도의 CSS 클래스를 만들 필요가 없습니다.\n\n에디터의 상태 JSON:\n\n```js\n{\n  \"root\": {\n    \"children\": [\n      {\n        \"children\": [\n          {\n            \"detail\": 0,\n            \"format\": 11,\n            \"mode\": \"normal\",\n            \"style\": \"\",\n            \"text\": \"굵게 기울임체 밑줄\",\n            \"type\": \"text\",\n            \"version\": 1\n          }\n        ],\n        \"direction\": \"ltr\",\n        \"format\": \"\",\n        \"indent\": 0,\n        \"type\": \"paragraph\",\n        \"version\": 1\n      }\n    ],\n    \"direction\": \"ltr\",\n    \"format\": \"\",\n    \"indent\": 0,\n    \"type\": \"root\",\n    \"version\": 1\n  }\n}\n```\n\n# 헤딩. 헬퍼 및 노드 구성\n\n\n\n등록된 어휘 명령이 없을 경우 어떻게 해야 할까요? 단어 요소(어휘의 기본 노드)를 어휘 명령을 사용하지 않고 헤더 노드로 변환해 봅시다:\n\n```js\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { $getSelection, $isRangeSelection } from \"lexical\";\nimport { $setBlocksType } from \"@lexical/selection\";\nimport { HeadingTagType, $createHeadingNode } from \"@lexical/rich-text\";\n\nexport const CustomHeadingActions = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (tag: HeadingTagType) => {\n        editor.update(() => {\n            const selection = $getSelection();\n            if ($isRangeSelection(selection)) {\n                $setBlocksType(selection, () => $createHeadingNode(tag));\n            }\n        });\n    };\n\n    return (\n        <div style={{ marginTop: '10px' }}>\n            <span style={{ fontWeight: 'bold' }}>Align actions</span>\n            <div>\n                {([\"h1\", \"h2\", \"h3\", \"h4\", \"h5\"] as Array<HeadingTagType>).map((tag) => {\n                    return (\n                        <button\n                            key={tag}\n                            onClick={() => handleOnClick(tag)}\n                        >\n                            {tag}\n                        </button>\n                    );\n                })}\n            </div>\n        </div>\n    );\n}\n```\n\n일부 노드를 헤딩 노드로 변환하는 데 미리 정의된 명령이 없기 때문에 여기서는 다음과 같은 작업을 수행합니다:\n\n- 콜백을 인수로 전달하는 editor.update 함수 호출\n- 선택된 노드를 가져오기 위해 $getSelection 헬퍼 사용\n- $isRangeSelection을 사용하여 RangeSelection 유형인지 확인합니다.\n\n\n\n```js\n// 소스코드\nexport function $isRangeSelection(x: unknown): x is RangeSelection {\n  return x instanceof RangeSelection;\n}\n```\n\n4. $setBlocksType을 새로운 $createHeadingNode (h1, h2, h3…)으로 변경하세요;\n\n⚠️ 하지만 앱에서 사용해보면 아무 일도 일어나지 않습니다 → 문단이 헤더로 변경되지 않습니다. 에디터에서 사용하고 싶은 노드에 대해 렉시컬이 알지 못하기 때문입니다 (기본 노드를 제외하고). 노드 구성 배열에 HeaderNode를 추가해야 합니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -10,6 +10,7 @@\n     CustomHistoryActions,\n     CustomAlignActions, CustomHeadingActions\n } from \"./components\";\n+import {HeadingNode} from \"@lexical/rich-text\";\n import initialState from './initialState.json';\n import './App.css'\n \n@@ -40,6 +41,7 @@\n \n     const lexicalConfig: InitialConfigType = {\n         namespace: 'My Rich Text Editor',\n+        nodes: [HeadingNode],\n         theme: {\n             text: {\n                 bold: \"text-bold\",\n```\n\n\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_9.png\" />\n\n# 페이로드와 함께 자신만의 명령어를 생성하는 방법\n\n이전 코드를 다시 작성해 보겠습니다. 다른 곳에서 변환 명령을 호출해야 하는 경우에도 이 조각을 복사-붙여넣기할 필요가 없도록 바꿀 거에요:\n\n```js\neditor.update(() => {\n    const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        $setBlocksType(selection, () => $createHeadingNode(tag));\n      }\n});\n```\n\n\n\n위 작업을 위해 페이로드 `\"h1\" | \"h2\" | \"h3\", ...`을 사용하여 자체 FORMAT_HEADING_COMMAND를 생성하고 등록합니다.\n\n```js\n// src/components/CustomHeadingPlugin/CustomHeadingPlugin.tsx\n\nimport { useEffect } from \"react\";\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport {\n    createCommand,\n    $getSelection,\n    $isRangeSelection,\n    COMMAND_PRIORITY_NORMAL,\n} from \"lexical\";\nimport {\n    $setBlocksType\n} from \"@lexical/selection\";\nimport {\n    HeadingTagType,\n    $createHeadingNode\n} from \"@lexical/rich-text\";\n\nexport const FORMAT_HEADING_COMMAND = createCommand(\"FORMAT_HEADING_COMMAND\");\n\nexport const CustomHeadingPlugin = () => {\n    const [editor] = useLexicalComposerContext();\n\n    useEffect(() => {\n        editor.registerCommand<HeadingTagType>(\n            FORMAT_HEADING_COMMAND,\n            (payload) => {\n                const selection = $getSelection();\n                if ($isRangeSelection(selection)) {\n                    $setBlocksType(selection, () => $createHeadingNode(payload));\n                }\n                return true;\n            },\n            COMMAND_PRIORITY_NORMAL,\n        );\n    }, []);\n\n    return null;\n}\n```\n\n이제 `CustomHeadingActions/` 구현을 업데이트할 수 있습니다:\n\n```js\nIndex: src/components/CustomHeadingActions/CustomHeadingActions.tsx\n@@ -1,22 +1,15 @@\nimport {\n    useLexicalComposerContext\n} from \"@lexical/react/LexicalComposerContext\";\nimport {HeadingTagType} from \"@lexical/rich-text\";\nimport {FORMAT_HEADING_COMMAND} from \"../CustomHeadingPlugin\";\n\nexport const CustomHeadingActions = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (tag: HeadingTagType) => {\n        editor.dispatchCommand(FORMAT_HEADING_COMMAND, tag);\n    };\n\n    return (\n        <div style={marginTop: '10px'}>\n```\n\n\n\n이 변형은 내게 훨씬 깔끔하고 재사용 가능해 보여요. 그 이후에는 LexicalComposer의 자식으로 우리가 만든 Header Plugin을 배치해야할거에요:\n\n```js\nIndex: src/App.tsx\n\n@@ -8,8 +8,11 @@\n     OnChangePlugin,\n     CustomTextActions,\n     CustomHistoryActions,\n     CustomAlignActions,\n     CustomHeadingActions,\n+    CustomHeadingPlugin,\n } from \"./components\";\n import {HeadingNode} from \"@lexical/rich-text\";\n import initialState from './initialState.json';\n import './App.css'\n\n@@ -70,7 +74,7 @@\n                 />\n                 <HistoryPlugin/>\n                 <OnChangePlugin/>\n+                <CustomHeadingPlugin/>\n                 <div style={margin: '20px 0px'}>\n                     <CustomHistoryActions/>\n                     <CustomHeadingActions/\n```\n\n👉 참고: 이전에 다뤘지만 다시 한 번 상기시키자면... 테마 구성을 업데이트하여 각 헤딩 엘리먼트에 적용하려는 CSS 클래스 이름을 지정할 수 있어요:\n\n```js\nIndex: src/App.tsx\n\n@@ -62,6 +62,14 @@\n                 subscript: 'text-subscript',\n                 superscript: 'text-superscript',\n             },\n+            heading: {\n+                // Flowbite examples: https://flowbite.com/docs/typography/headings/#heading-one-h1\n+                h1: \"text-5xl font-extrabold dark:text-white\",\n+                h2: \"text-4xl font-bold dark:text-white\",\n+                h3: \"text-3xl font-bold dark:text-white\",\n+                h4: \"text-2xl font-bold dark:text-white\",\n+                h5: \"text-xl font-bold dark:text-white\",  \n+            },\n             banner: 'banner'\n         },\n         onError: (e) => {\n```\n\n\n\n# 커스텀 노드를 만드는 방법\n\n이전 섹션에서는 기본적으로 모든 것을 다루었으니, 이번 섹션에서는 직접 노드를 만들어보겠습니다. 제가 생각하기에 렉시컬이 노드를 처리하는 전체 그림을 파악하게 될 것입니다.\n\n가장 간단한 배너 노드:\n\n```js\nimport {\n    EditorConfig,\n    ElementNode,\n    LexicalEditor,\n    SerializedElementNode,\n    Spread,\n} from \"lexical\";\n\nexport type SerializedBannerNode = Spread<\n    {\n        customValue: string;\n    },\n    SerializedElementNode\n>;\n\nexport class BannerNode extends ElementNode {\n    createDOM(_config: EditorConfig, _editor: LexicalEditor): HTMLElement {\n        const div = document.createElement(\"div\");\n        div.className = _config.theme.banner;\n        return div;\n    }\n\n    static clone(node: BannerNode): BannerNode {\n        return new BannerNode(node.__key);\n    }\n\n    static getType(): string {\n        return \"banner\";\n    }\n\n    /**\n     * Returning false tells Lexical that this node does not need its\n     * DOM element replacing with a new copy from createDOM.\n     */\n    updateDOM(\n        _prevNode: unknown,\n        _dom: HTMLElement,\n        _config: EditorConfig,\n    ): boolean {\n        return false;\n    }\n\n    exportJSON(): SerializedBannerNode {\n        return {\n            type: \"banner\",\n            version: 1,\n            children: [],\n            customValue: \"anything you like\",\n            format: \"\",\n            indent: 1,\n            direction: null,\n        };\n    }\n}\n```\n\n\n\n설명:\n- 새로운 어휘 노드를 만들려면 미리 정의된 어휘 노드(ElementNode | TextNode | DecoratorNode 중 하나를 확장한 클래스를 만들고 메서드를 재정의해야 합니다(모든 메서드를 다루지는 않겠습니다));\n- 먼저, 어휘는 노드의 타입에 대한 일치 항목을 찾으려고 할 것이며, 타입 함수를 호출하여 구성 노드 배열('banner'의 경우)에서 지정한 노드들로부터 getType 함수를 호출할 것입니다;\n- 그 다음으로, 어휘는 HTML 요소를 만드는 createDOM 메서드를 호출할 것입니다;\n- OnChangePlugin에 toJSON 함수가 있는 것을 기억하시나요?\n\n```js\n// src/components/OnChangePlugin/OnChangePlugin.tsx\n\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {useEffect} from \"react\";\n\nexport const OnChangePlugin = () => {\n    const [editor] = useLexicalComposerContext();\n    useEffect(() => {\n        return editor.registerUpdateListener((listener) => {\n            console.log('DATA', listener.editorState.toJSON())\n        });\n    }, [editor]);\n\n    return null;\n}\n```\n\n여기서 우리의 Banner exportJSON 함수가 호출될 것입니다.\n\n\n\n이제 BannerNode를 위한 플러그인을 생성해야 합니다. 이미 Headings 섹션에서 이를 수행한 적이 있습니다:\n\n```js\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {$getSelection, $isRangeSelection, COMMAND_PRIORITY_NORMAL, createCommand} from \"lexical\";\nimport {\n    $setBlocksType\n} from \"@lexical/selection\";\nimport {BannerNode} from \"../../nodes\";\nimport React from \"react\";\n\nexport const $createBannerNode = (): BannerNode => new BannerNode();\n\nexport const INSERT_BANNER_COMMAND = createCommand(\"create_banner\");\n\nexport const CustomBannerPlugin: React.FC = () => {\n    const [editor] = useLexicalComposerContext();\n\n    if (!editor.hasNode(BannerNode)) {\n        throw new Error('BannerPlugin: \"BannerNode\" not registered on editor');\n    }\n    editor.registerCommand(\n        INSERT_BANNER_COMMAND,\n        () => {\n            const selection = $getSelection();\n            if ($isRangeSelection(selection)) {\n                $setBlocksType(selection, $createBannerNode);\n            }\n            return true;\n        },\n        COMMAND_PRIORITY_NORMAL,\n    );\n\n    return null;\n};\n```\n\nCustomBannerActions 컴포넌트를 추가하세요: 우리 명령어와 함께 간단한 버튼이 있습니다:\n\n```js\nimport React from \"react\";\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {INSERT_BANNER_COMMAND} from \"../CustomBannerPlugin\";\n\nexport const CustomBannerActions: React.FC = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = () => {\n        editor.dispatchCommand(INSERT_BANNER_COMMAND, undefined);\n    };\n\n    return (\n        <div style={{marginTop: '10px'}}>\n            <span style={{fontWeight: 'bold'}}>Heading actions</span>\n            <div>\n                <button onClick={handleOnClick}>\n                    Banner\n                </button>\n            </div>\n        </div>\n    );\n};\n```\n\n\n\nApp.tsx를 업데이트하였습니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -11,10 +11,13 @@\n     CustomAlignActions,\n     CustomHeadingActions,\n     CustomHeadingPlugin,\n+    CustomBannerPlugin,\n+    CustomBannerActions,\n } from \"./components\";\n import {HeadingNode} from \"@lexical/rich-text\";\n import initialState from './initialState.json';\n import './App.css'\n+import {BannerNode} from \"./nodes\";\n \n export const App: React.FC = () => {\n \n@@ -43,7 +46,10 @@\n \n     const lexicalConfig: InitialConfigType = {\n         namespace: 'My Rich Text Editor',\n-        nodes: [HeadingNode],\n+        nodes: [\n+            BannerNode,\n+            HeadingNode\n+        ],\n         theme: {\n             text: {\n                 bold: \"text-bold\",\n@@ -55,6 +61,7 @@\n                 subscript: 'text-subscript',\n                 superscript: 'text-superscript',\n             },\n+            banner: 'banner'\n         },\n         onError: (e) => {\n             console.log('ERROR:', e)\n@@ -75,8 +82,10 @@\n                 <HistoryPlugin/>\n                 <OnChangePlugin/>\n                 <CustomHeadingPlugin/>\n+                <CustomBannerPlugin/>\n                 <div style={margin: '20px 0px'}>\n                     <CustomHistoryActions/>\n+                    <CustomBannerActions/>\n                     <CustomHeadingActions/>\n                     <CustomTextActions/>\n                     <CustomAlignActions/>\n```\n\nCSS:\n\n```js\nIndex: src/App.css\n\n@@ -33,6 +33,13 @@\n     vertical-align: super ;\n }\n \n+.banner {\n+    border-left: 3px coral solid;\n+    background-color: lightskyblue;\n+    border-radius: 3px;\n+    padding: 10px 0;\n+}\n+\n p {\n     margin: 0;\n }\n```\n\n\n\n결과:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1334/1*zesdcbkZmVlSoY1HaflYUA.gif\" />\n\n🔴 문제가 두 가지 있을 것입니다:\n\n- 사용자가 Enter 키 또는 Shift+Enter 키를 눌러 노드에서 \"나가기\"를 할 수 없을 것입니다.\n- 사용자가 Backspace 키를 눌러 노드를 \"제거\"할 수 없을 것입니다.\n\n\n\n우리의 BannerNode를 업데이트해 봅시다:\n\n```js\nIndex: src/nodes/BannerNode/BannerNode.tsx\n\n@@ -2,6 +2,9 @@\n     EditorConfig,\n     ElementNode,\n     LexicalEditor,\n+    $createParagraphNode,\n+    LexicalNode,\n+    RangeSelection,\n     SerializedElementNode,\n     Spread,\n } from \"lexical\";\n@@ -40,6 +43,34 @@\n         return false;\n     }\n\n+    /**\n+     * 사용자가 모든 콘텐츠를 삭제할 때 노드를 단락으로 설정해야 합니다\n+     */\n+    collapseAtStart(_: RangeSelection): boolean {\n+        const paragraph = $createParagraphNode();\n+        const children = this.getChildren();\n+        children.forEach((child) => paragraph.append(child));\n+        this.replace(paragraph);\n+\n+        return true;\n+    }\n+\n+    /**\n+     * 사용자가 Enter 키를 누를 때 노드를 단락으로 설정해야 합니다.\n+     * Shift+Enter를 누를 경우 노드는 유지됩니다\n+     */\n+    insertNewAfter(\n+        _: RangeSelection,\n+        restoreSelection?: boolean,\n+    ): LexicalNode | null {\n+        const paragraph = $createParagraphNode();\n+        const direction = this.getDirection();\n+        paragraph.setDirection(direction);\n+        this.insertAfter(paragraph, restoreSelection);\n+\n+        return paragraph;\n+    }\n+\n     exportJSON(): SerializedBannerNode {\n         return {\n             type: \"banner\",\n```\n\n지금까지 얻은 것을 확인해 보겠습니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1334/1*44Wg5Stz5crAXpP3Qi-PRA.gif\" />\n\n\n\n🟢 업데이트 후:\n\n- 사용자는 노드에서 Enter 키를 눌러 \"나가기\" 할 수 있습니다;\n- 사용자는 노드를 Shift + Enter 키를 눌러 \"확장\"할 수 있습니다;\n- 사용자는 콘텐츠 텍스트가 비어 있을 때 Backspace 키를 눌러 노드를 \"삭제\"할 수 있습니다;\n\n마지막으로, 에디터의 JSON 트리에서 BannerNode을 파싱하는 함수가 필요합니다:\n\n```js\nIndex: src/nodes/BannerNode/BannerNode.tsx\n\n@@ -71,6 +71,10 @@\n         return paragraph;\n     }\n \n+    static importJSON(_: SerializedBannerNode): BannerNode {\n+        return new BannerNode();\n+    }\n+\n     exportJSON(): SerializedBannerNode {\n         return {\n             type: \"banner\",\n```\n\n\n\n# 깃허브 리포지토리:\n\n관련된 기사들:\n\n이 글이 도움이 되었기를 바랍니다. 만약 그렇다면, \"claps\"를 주시면 감사하겠습니다.\n\n# 간단히 설명\n\n\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 작가를 칭찬하고 팔로우하세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입하세요. 🗞️\n- 트위터, 링크드인, 유튜브, 그리고 디스코드에서 저희를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png","tag":["Tech"],"readingTime":31},{"title":"리액트와 ASPNet Core 웹 API를 사용한 Full Stack CRUD 애플리케이션 개발하기","description":"","date":"2024-05-14 10:58","slug":"2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI","content":"\n\n리액트를 사용하여 ASP.NET Core 웹 API와 함께 전체 스택 CRUD 애플리케이션을 만드는 것은 강력한 방법입니다. 견고하고 효율적인 웹 애플리케이션을 개발하는 데 도움이 됩니다. 이 안내서에서는 CRUD 작업의 기본 원리를 탐구하고 React 프론트엔드와 ASP.NET Core 웹 API 백엔드를 설정하고 연결하는 단계별 프로세스를 살펴볼 것입니다. 각 계층의 복잡성과 상호 작용을 이해하여 개발자는 확장 가능하고 효율적인 전체 스택 애플리케이션을 구축하는 데 능숙해질 수 있습니다.\n\n# 전체 스택 CRUD 애플리케이션 소개\n\n전체 스택 CRUD (생성, 읽기, 업데이트, 삭제) 애플리케이션을 만드는 것은 프론트엔드와 백엔드 구성 요소 모두를 데이터베이스와 상호 작용하도록 구축하는 것을 포함합니다. 이를 통해 사용자는 기본적인 데이터베이스 작업을 원활하게 수행할 수 있습니다.\n\n# CRUD 작업 이해\n\n\n\n데이터베이스 작업시 사용되는 기본 작업은 CRUD 연산입니다. Create는 새 데이터를 추가하고, Read는 기존 데이터를 검색하며, Update는 데이터를 수정하고, Delete는 데이터를 삭제합니다. 이러한 작업들은 상호 작용하는 애플리케이션의 기본을 형성합니다.\n\nASP.Net Core Web API 백엔드 개발\n\nASP.Net Core Web API를 사용하여 백엔드를 구축하는 것은 데이터 작업을 처리하고 프론트엔드 애플리케이션과 상호 작용하는 견고한 기반을 만드는 것을 의미합니다.\n\n먼저 시작하기 위해 먼저 Visual Studio에서 필요한 종속성을 설치해야 합니다. 이를 위해 Tools-`NuGet Package Manager-` Manage Nuget Packages for solution로 이동해야 합니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png)\n\n\n그러고 나서 이 패키지들을 모두 설치하세요,\n\n- Microsoft.EntityFrameworkCore.Design\n- Microsoft.EntityFrameworkCore.SqlServer\n- Microsoft.EntityFrameworkCore.Tools\n- Newtonsoft.Json\n\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_1.png)\n\n\n\n\n첫 번째 단계로 모델 폴더를 선택한 후에 마우스 오른쪽 단추를 클릭하여 Student.cs 클래스를 만드세요.\n\n## Student.cs\n\n```js\nusing System.ComponentModel.DataAnnotations;\n\nnamespace ReactASPCrud.Models\n{\n    public class Student\n    {\n\n    [Key] // 이것을 추가한 후에 위 라이브러리(DataAnnotations)가 자동으로 작성됩니다.\n    public int id { get; set; }\n    public string stname { get; set; }\n\n    public string course { get; set; }\n\n    }\n}\n```\n\n## StudentDbContext.cs\n\n\n\n```cs\nusing Microsoft.EntityFrameworkCore;\n\nnamespace ReactASPCrud.Models\n{\n    public class StudentDbContext : DbContext\n    {\n\n        public StudentDbContext(DbContextOptions<StudentDbContext> options) : base(options) \n        {\n        \n        }\n    \n        public DbSet<Student> Students { get; set; }\n\n        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n        {\n            optionsBuilder.UseSqlServer(\"Data Source=.; initial Catalog=lbs;User Id=test; password=123; TrustServerCertificate= True\");\n        }\n\n    }\n}\n```\n\n이곳에 SQL 인증을 추가하는 대신, 위의 OnConfiguring 메소드에 아래 코드를 사용하여 Windows 인증을 적용할 수 있습니다. (여기서는 id, password를 추가할 필요가 없습니다)\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_2.png)\n\n```js\nData Source=DIVANI\\SQLEXPRESS;Database=lbs;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\n```\n\n\n\n- 데이터 원본 = DIVANI\\SQLEXPRESS: 서버 이름 또는 IP 주소.\n- 데이터베이스 = lbs: 데이터베이스의 이름.\n- 통합 보안 = True: Windows 인증을 사용하여 연결을 인증하는 것을 나타냅니다.\n- 연결 제한 시간 = 30: 연결 제한 시간(초).\n- 암호화 = False: 암호화 비활성화.\n- 서버 인증서 신뢰 = False: 서버 인증서 신뢰.\n- 애플리케이션 의도 = ReadWrite: 읽기 및 쓰기 작업을 위한 의도.\n- 멀티 서브넷 장애 조치 = False: 멀티 서브넷 장애 조치 설정. 이 설정은 클라이언트가 더 나은 오류 허용성을 위해 여러 서브넷을 통해 데이터베이스에 연결할 수 있게 합니다.\n\n데이터베이스 연결 설정하기\n\n다음 내용을 Program.cs 파일에 추가합니다.\n\n```js\nbuilder.Services.AddDbContext<StudentDbContext>(options =>\noptions.UseSqlServer(builder.Configuration.GetConnectionString(\"StudentDbContext\")));\n```\n\n웹 API에 이 권한을 허용하도록 설정하기\n\n```js\napp.UseCors(policy => policy.AllowAnyHeader()\n.AllowAnyMethod()\n.SetIsOriginAllowed(origin => true)\n.AllowCredentials());\n```\n\n\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\n| Header1 | Header2 | Header3 |\n| ------- | ------- | ------- |\n| Data1   | Data2   | Data3   |\n| Data4   | Data5   | Data6   |\n\n\n이제 위의 코드를 Program.cs 파일 내 어디에 붙여넣어야 하는지 알려줄 거에요.\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ReactAspCrud.Models;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// 컨테이너에 서비스 추가.\n\nbuilder.Services.AddControllers();\n// 더 자세한 Swagger/OpenAPI 구성 방법은 https://aka.ms/aspnetcore/swashbuckle에서 확인하세요.\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddDbContext<StudentDbContext>(options =>\n   options.UseSqlServer(builder.Configuration.GetConnectionString(\"StudentDbContext\")));\n\nvar app = builder.Build();\napp.UseCors(policy => policy.AllowAnyHeader()\n                            .AllowAnyMethod()\n                            .SetIsOriginAllowed(origin => true)\n                            .AllowCredentials());\n\n// HTTP 요청 파이프라인 구성.\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n이제 appsettings.json 파일에 연결 문자열을 추가하세요.\n\n```json\n{\n  \"ConnectionStrings\": {\n    \"StudentDbContext\": \"Data Source=DIVANI\\SQLEXPRESS;Database=lbs;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\"\n  }\n}\n```\n\n\n\n그 후에 도구-`NuGet 패키지 관리자-`패키지 관리자 콘솔로 이동하여 아래 명령어를 추가하십시오:\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_3.png)\n\nadd-migration initial\n\nupdate-database\n\n\n\n마이그레이션 파일을 생성하고 나서 데이터베이스가 만들어졌습니다. SQL Server를 열어서 데이터베이스가 생성되었는지 확인해보세요. 동시에 프로젝트에 마이그레이션 폴더가 생성되어 있습니다. 해당 폴더를 확인할 수 있습니다.\n\n이제 SQL Server를 통해 추가되었는지 확인할 수 있습니다.\n\n![이미지 1](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_4.png)\n\n![이미지 2](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_5.png)\n\n\n\n이후에 Controller 폴더를 선택하고 Web API로 Student Controller를 생성하세요.\n\n![이미지1](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_6.png)\n\n![이미지2](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_7.png)\n\n![이미지3](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_8.png)\n\n\n\n이제 StudentController.cs 파일에 API를 만들어야 합니다.\n\n여기서 API 내에서 CRUD 작업을 처리하기 위한 엔드포인트를 생성할 것입니다. POST, GET, PUT 및 DELETE와 같은 HTTP 동사를 사용하여 데이터를 생성, 읽기, 업데이트 및 삭제하는 메서드를 구현할 것입니다.\n\n## StudentController.cs\n\n```csharp\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing ReactAspCrud.Models;\n\nnamespace ReactAspCrud.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class StudentController : ControllerBase\n    {\n        private readonly StudentDbContext _studentDbContext;\n\n        public StudentController(StudentDbContext studentDbContext)\n        {\n            _studentDbContext = studentDbContext;\n        }\n\n        [HttpGet]\n        [Route(\"GetStudent\")]\n        public async Task<IEnumerable<Student>> GetStudents()\n        {\n            return await _studentDbContext.Student.ToListAsync();\n        }\n\n        [HttpPost]\n        [Route(\"AddStudent\")]\n        public async Task<Student> AddStudent(Student objStudent)\n        {\n            _studentDbContext.Student.Add(objStudent);\n            await _studentDbContext.SaveChangesAsync();\n            return objStudent;\n        }\n\n        [HttpPatch]\n        [Route(\"UpdateStudent/{id}\")]\n        public async Task<Student> UpdateStudent(Student objStudent)\n        {\n            _studentDbContext.Entry(objStudent).State= EntityState.Modified;\n            await _studentDbContext.SaveChangesAsync();\n            return objStudent;\n        }\n\n        [HttpDelete]\n        [Route(\"DeleteStudent/{id}\")]\n        public bool DeleteStudent(int id) \n        {\n            bool a = false;\n            var student = _studentDbContext.Student.Find(id);\n            if (student != null)\n            {\n                a = true;\n                _studentDbContext.Entry(student).State= EntityState.Deleted;\n                _studentDbContext.SaveChanges();\n            }\n            else\n            {\n                a = false;\n            }\n            return a;\n        }\n    }\n}\n```\n\n\n\n프로그램을 실행한 후 Swagger를 통해 확인할 수 있어요.\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_9.png)\n\n값을 실행하여 각 API 컨트롤러가 작동하는지 확인하세요.\n\n# 어플리케이션을 위한 React Frontend 설정\n\n\n\n이제 백엔드 개발 부분을 이미 마무리했군요.\n\n이제 프론트엔드 개발 부분으로 넘어가 볼까요?\n\n먼저, 관련 경로 내에서 React 앱을 생성해야 합니다.\n\n![React app 생성](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_10.png)\n\n\n\n그럼 명령 프롬프트에 다음 명령을 입력해야 해요:\n\nnpx create-react-app my-app\ncd my-app\n\nReact 프로젝트를 VS code 편집기에서 열고 React 앱을 실행하려면 이 명령을 추가하세요,\n\ncode .\nnpm start\n\n\n\n이제 React 환영 페이지를 보실 수 있습니다.\n\n그 후 다음 명령어를 입력하여 Bootstrap을 설치하십시오.\n\nnpm i bootstrap\n\n그 후 다음 명령어를 입력하여 axios를 설치하십시오.\n\n\n\nnpm i axios\n\nVS code에서 프로젝트를 열고 아래 코드를 추가하세요,\n\n## App.js\n\n```js\nimport './App.css';\nimport StudentCrud from './components/StudentCrud';\n\nfunction App() {\n  return (\n    <div>\n      <StudentCrud/>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n\n\n새 폴더(components)를 만든 후, 그 안에 StudentCrud.js 파일을 생성하고 아래 코드를 추가해주세요.\n\n<img src=\"/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_11.png\" />\n\n## StudentCrud.js\n\n```js\nimport axios from \"axios\";\nimport { useEffect, useState } from \"react\";\n\nfunction StudentCrud(){\n\nconst [id, setId] = useState(\"\");\nconst [stname, setName] = useState(\"\");\nconst [course, setCourse] = useState(\"\");\nconst [students, setUsers] = useState([]);\n\n  useEffect(() => {\n    (async () => await Load())();\n  }, []);\n\n  async function Load() {\n\n    const result = await axios.get(\"https://localhost:7135/api/Student/GetStudent\");\n    setUsers(result.data);\n    console.log(result.data);\n  }\n\n  async function save(event) {\n\n    event.preventDefault();\n    try {\n      await axios.post(\"https://localhost:7135/api/Student/AddStudent\", {\n\n        stname: stname,\n        course: course,\n\n      });\n      alert(\"학생 등록 성공\");\n          setId(\"\");\n          setName(\"\");\n          setCourse(\"\");\n\n\n      Load();\n    } catch (err) {\n      alert(err);\n    }\n  }\n  async function editStudent(students) {\n    setName(students.stname);\n    setCourse(students.course);\n\n\n    setId(students.id);\n  }\n\n  async function DeleteStudent(id) {\n\n  await axios.delete(\"https://localhost:7135/api/Student/UpdateStudent/\" + id);\n  alert(\"학생이 성공적으로 삭제되었습니다\");\n  setId(\"\");\n  setName(\"\");\n  setCourse(\"\");\n  Load();\n  }\n\n  async function update(event) {\n    event.preventDefault();\n    try {\n      //this is API handling the path\n  await axios.patch(\"https://localhost:7135/api/Student/UpdateStudent/\"+ students.find((u) => u.id === id).id || id,\n        {\n        id: id,\n        stname: stname,\n        course: course,\n        }\n      );\n      alert(\"등록이 업데이트되었습니다\");\n      setId(\"\");\n      setName(\"\");\n      setCourse(\"\");\n\n      Load();\n    } catch (err) {\n      alert(err);\n    }\n  }\n\n\nreturn(\n //student form\n<div>\n<h1>학생 세부 정보</h1>\n      <div class=\"container mt-4\">\n        <form>\n          <div class=\"form-group\">\n\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              id=\"id\"\n              hidden\n              value={id}\n              onChange={(event) => {\n                setId(event.target.value);\n              }\n            />\n            <label>학생 이름</label>\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              id=\"stname\"\n              value={stname}\n              onChange={(event) => {\n                setName(event.target.value);\n              }\n            />\n          </div>\n          <div class=\"form-group\">\n            <label>과정</label>\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              id=\"course\"\n              value={course}\n              onChange={(event) => {\n                setCourse(event.target.value);\n              }\n            />\n          </div>\n          <div>\n            <button class=\"btn btn-primary mt-4\" onClick={save}>\n              등록\n            </button>\n            <button class=\"btn btn-warning mt-4\" onClick={update}>\n              업데이트\n            </button>\n          </div>\n        </form>\n      </div>\n      <br></br>\n\n\n      <table class=\"table table-dark\" align=\"center\">\n        <thead>\n          <tr>\n            <th scope=\"col\">학생 아이디</th>\n            <th scope=\"col\">학생 이름</th>\n            <th scope=\"col\">과정</th>\n\n            <th scope=\"col\">옵션</th>\n          </tr>\n        </thead>\n        {students.map(function fn(student) {\n          return (\n            <tbody>\n              <tr>\n                <th scope=\"row\">{student.id} </th>\n                <td>{student.stname}</td>\n                <td>{student.course}</td>\n\n                <td>\n                  <button\n                    type=\"button\"\n                    class=\"btn btn-warning\"\n                    onClick={() => editStudent(student)}\n                  >\n                    편집\n                  </button>\n                  <button\n                    type=\"button\"\n                    class=\"btn btn-danger\"\n                    onClick={() => DeleteStudent(student.id)}\n                  >\n                    삭제\n                  </button>\n                </td>\n              </tr>\n            </tbody>\n          );\n        })}\n      </table>\n</div>\n);\n}\n\nexport default StudentCrud;\n```\n\n\n\n프론트엔드와 백엔드 간 통신 수립하기\nReact 프론트엔드와 ASP.Net Core 웹 API 백엔드가 준비되었습니다. 이제 이들끼리 소통할 시간이에요. 이 디지털 소개팅을 설정하고 둘 사이에 원활한 통신 경로를 수립해봅시다.\n\nReact 컴포넌트에서 API 엔드포인트 사용하기\nReact 컴포넌트들은 마치 만물뷔페에서 배고픈 십대처럼, ASP.Net Core 웹 API에서 제공하는 API 엔드포인트를 소비하기를 열망하고 있습니다. 백엔드에서 데이터를 컴포넌트에 공급하는 방법을 배워서 UI를 기쁘게 춤추게 해보세요.\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_12.png)\n\n따라서 백엔드 코드를 실행한 후, StudentCrud.js 파일의 해당 위치에 각 웹 API 규칙에 대한 요청 URL을 추가하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_13.png)\n\n데이터 응답 및 오류 처리\n가끔 데이터가 마치 부드러운 시냇물처럼 매끈하게 흘러들어오지만, 때로는 오류가 예기치 못하게 파티에 뜬금 없이 나타나는 손님처럼 발생하기도 합니다. 전문가처럼 데이터 응답을 우아하게 처리하고 문제를 해결하는 방법을 발견하여 응용 프로그램이 매끈하게 실행되도록 유지해보세요.\n\n# 전체 스택 CRUD 애플리케이션 테스트 및 디버깅\n\nReact 컴포넌트의 유닛 테스트\n우리의 React 컴포넌트를 현미경 아래 두고 연구실 쥐처럼 테스트해보겠습니다(하지만 더 정성을 다하면서요). 각 컴포넌트가 훌륭하게 역할을 수행하고 그 귀찮은 버그를 피하여 사용자 경험을 망가뜨리는 일을 방지하는 방법을 배워보세요.\n\n\n\nAPI 엔드포인트의 통합 테스트\n탐정 모자를 살 때입니다. API 엔드포인트의 동작을 조사해보세요. 통합 테스트를 통해 백엔드 서비스가 정확히 응답하고 프론트엔드와 잘 작동하는지 확인할 수 있습니다. 셜록 홈즈가 자랑스러워할 것입니다.\n\n크로스 플랫폼 문제 해결\n크로스 플랫폼 개발의 기쁨입니다. 다양한 브라우저에서 다양한 디바이스로, 이러한 문제를 해결하고 디버그하는 방법을 탐색해보세요. 이 문제들은 어플리케이션이 이상하게 작동하게 할 수 있습니다.\n\n# 배포 및 유지보수 고려 사항\n\n배포를 위한 애플리케이션 준비\n쇼타임입니다! 풀 스택 CRUD 애플리케이션을 인터넷의 넓은 세계에 배포하기 위한 필수 단계를 배워보세요. 설정에서 최적화까지, 앱을 큰 무대에서 빛나게 할 준비를 해보세요.\n\n\n\n애플리케이션 확장 전략\n애플리케이션이 인기를 얻게 되면 확장이 매우 중요해집니다. 전체 스택 애플리케이션을 효율적으로 확장할 수 있는 전략을 알아보세요. 이를 통해 향후 증가하는 트래픽을 처리하고 최적 성능을 유지할 수 있습니다. 디지털 성장 분기점을 대비하는 것으로 생각해보세요.\n\n모니터링 및 유지보수 최고의 실천법\n애플리케이션이 러브 상태가 되면 일은 끝나지 않습니다. 애플리케이션 성능을 모니터링하고 사용자 행동을 추적하며 유지보수 루틴을 실행하는 최고의 실천법을 살펴보세요. 모든 것이 원활히 작동되도록 하기 위해 앱에 정기적인 건강 진단을 하는 느낌이죠.\n\n결론적으로, ASP.Net Core Web API를 사용한 React를 이용한 Full Stack CRUD 애플리케이션 작성에 숙달하면 다재다능하고 반응 좋은 웹 애플리케이션을 개발하고자 하는 개발자들에게 다양한 기회를 제공해줍니다. 이 기사에서 제시된 지침을 따르면 두 기술의 장점을 활용하여 사용자 경험을 원활하게 만들고 프로젝트에서 혁신을 이끌어낼 수 있습니다. 풀 스택 개발의 잠재력을 받아들이고 늘 새로운 방법을 탐구하여 기술을 향상시키고 디지털 환경의 변화하는 경험을 만들어보세요.\n\n# FAQ\n\n# 1. 풀 스택 CRUD 애플리케이션이란 무엇인가요?\n\n\n\n풀 스택 CRUD 애플리케이션은 프론트엔드 및 백엔드 기술을 이용하여 데이터를 생성, 읽기, 업데이트 및 삭제하는 웹 애플리케이션입니다. 일반적으로 사용자 인터페이스를 위한 프론트엔드 프레임워크와 데이터 및 비즈니스 로직을 관리하는 백엔드 시스템으로 구성됩니다.\n\n## 2. 이 안내를 따르려면 React 및 ASP.Net Core 이전 경험이 필요한가요?\n\nReact와 ASP.Net Core의 이전 경험이 도움이 될 수 있지만, 이 안내서는 초보자를 위한 단계별 접근 방식을 제공하도록 구성되어 있습니다. JavaScript와 C#의 기본 지식이 도움이 될 것이나, 설명과 코드 샘플은 모든 개발자 수준에게 접근하기 쉽도록 하고 있습니다.\n\n## 3. 완료 후 풀 스택 CRUD 애플리케이션을 어떻게 배포할 수 있나요?\n\n\n\n애플리케이션을 배포하는 것은 프론트엔드와 백엔드 구성 요소를 서버에 호스팅하는 과정을 말합니다. React 프론트엔드의 경우, Netlify 또는 Vercel과 같은 플랫폼에 배포할 수 있습니다. ASP.Net Core Web API 백엔드는 Azure, AWS 또는 온프레미스 서버와 같은 서비스에 호스팅할 수 있습니다. 호스팅 환경에 따라 배포 과정이 달라질 수 있습니다.\n\n# 4. 최고의 API 문서 작성 도구는 무엇인가요?\n\n- Swagger\n- Postman\n- Readme\n- Stoplight\n- Redocly\n- Document360","ogImage":{"url":"/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png"},"coverImage":"/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png","tag":["Tech"],"readingTime":16},{"title":"Google Gemini을 Nodejs 애플리케이션에 통합하는 방법","description":"","date":"2024-05-14 10:56","slug":"2024-05-14-IntegratingGoogleGeminitoNodejsApplication","content":"\n\n<img src=\"/assets/img/2024-05-14-IntegratingGoogleGeminitoNodejsApplication_0.png\" />\n\n# 구글 젬이니란?\n\n구글 젬이니는 구글 AI가 개발한 강력하고 다양한 AI 모델입니다. 젬이니는 텍스트뿐만 아니라 코드, 오디오, 이미지 및 비디오와 같은 다양한 형식에서 작동하고 이해할 수 있습니다. 이는 Node.js 프로젝트에 대한 흥미로운 가능성을 열어줍니다.\n\n이 기사에서는 구글 젬이니를 Node.js 애플리케이션에 통합하는 방법을 안내하겠습니다. 우리는 구글 젬이니 SDK를 사용할 것입니다.\n\n\n\n## 준비물\n\n- 개인 컴퓨터에 Node.Js가 설치되어 있어야 합니다.\n- API 키 생성을 위한 Google AI Platform 계정이 있어야 합니다.\n\n- Node.Js 버전 18 이상이 필요합니다.\n- Node.Js에서 import를 사용하려면 package.json 파일에 \"type\": \"module\"을 추가해야 합니다.\n\n# 시작하기\n\n\n\n새로운 Node.js 프로젝트를 만들어봅시다. 터미널을 열고 다음 명령어를 실행해주세요:\n\n```js\nmkdir google-gemini-nodejs\ncd google-gemini-nodejs\nnpm init -y\n```\n\n다음으로, Google Gemini SDK와 dotenv 패키지를 설치해주세요:\n\n```js\nnpm install @google/generative-ai dotenv\n```\n\n\n\n## 구글 AI 플랫폼 계정 생성하기\n\nGoogle Gemini SDK를 사용하려면 API 키가 필요합니다. 구글 AI 플랫폼 웹사이트를 방문하여 새 API를 생성할 수 있습니다.\n\n새 API 키를 만들려면 \"Get API Key\" 버튼을 클릭하세요. API 키를 획득한 후에는 프로젝트의 루트에 있는 .env 파일에 저장하세요.\n\n```js\nAPI_KEY=YOUR_API_KEY\n```\n\n\n\n# Google Gemini SDK 설정하기\n\n이제 API 키를 가지고 있으니 Google Gemini SDK를 설정해 봅시다. 프로젝트의 루트에 index.js라는 새 파일을 만들고 아래 코드를 추가해주세요:\n\n## Google Gemini Pro 모델\n\n```js\nimport { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\nconst gemini_api_key = process.env.API_KEY;\nconst googleAI = new GoogleGenerativeAI(gemini_api_key);\nconst geminiConfig = {\n  temperature: 0.9,\n  topP: 1,\n  topK: 1,\n  maxOutputTokens: 4096,\n};\n\nconst geminiModel = googleAI.getGenerativeModel({\n  model: \"gemini-pro\",\n  geminiConfig,\n});\n\nconst generate = async () => {\n  try {\n    const prompt = \"Tell me about google.\";\n    const result = await geminiModel.generateContent(prompt);\n    const response = result.response;\n    console.log(response.text());\n  } catch (error) {\n    console.log(\"response error\", error);\n  }\n};\n\ngenerate();\n```\n\n\n\n위 코드에서는 텍스트 생성, 번역, 그리고 멀티턴 텍스트 및 코드 채팅과 같은 자연어 작업을 처리하는 데 뛰어난 성능을 발휘하는 Google Gemini Pro 모델을 사용했습니다. 이는 사용자와 자연어로 상호 작용하는 지능형 시스템을 구축하기에 완벽한 모델입니다.\n\n## Google Gemini Vision Model\n\n```js\nimport { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport fs from \"fs/promises\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n \nconst gemini_api_key = process.env.API_KEY;\nconst googleAI = new GoogleGenerativeAI(gemini_api_key);\nconst geminiConfig = {\n  temperature: 0.4,\n  topP: 1,\n  topK: 32,\n  maxOutputTokens: 4096,\n};\n \nconst geminiModel = googleAI.getGenerativeModel({\n  model: \"gemini-pro-vision\",\n  geminiConfig,\n});\n \nconst generate = async () => {\n  try {\n    // 이미지 파일 읽기\n    const filePath = \"some-image.jpeg\";\n    const imageFile = await fs.readFile(filePath);\n    const imageBase64 = imageFile.toString(\"base64\");\n \n    const promptConfig = [\n      { text: \"이 이미지에 대해 무슨 일이 일어나고 있는지 알려줄 수 있나요?\" },\n      {\n        inlineData: {\n          mimeType: \"image/jpeg\",\n          data: imageBase64,\n        },\n      },\n    ];\n \n    const result = await geminiModel.generateContent({\n      contents: [{ role: \"user\", parts: promptConfig }],\n    });\n    const response = await result.response;\n    console.log(response.text());\n  } catch (error) {\n    console.log(\"응답 오류\", error);\n  }\n};\n \ngenerate();\r\n```\n\n위 코드에서는 이미지의 내용을 기반으로 전체 이미지를 분류하고 이미지에 대한 캡션을 생성하는 Google Gemini Vision 모델을 사용했습니다. 이는 사용자와 자연어로 상호 작용하는 지능형 시스템을 구축하기에 완벽한 모델입니다.\n\n\n\n## 어플리케이션 실행하기\n\n어플리케이션을 실행하려면 터미널을 열고 다음 명령어를 실행하세요:\n\n```js\nnode index.js\n```\n\n## 결론\n\n\n\n이 글에서는 Google Gemini를 Node.js 어플리케이션에 통합하는 방법에 대해 배웠습니다. 또한 Google Gemini Pro와 Vision 모델을 사용하여 텍스트 및 이미지 캡션을 생성하는 방법도 배웠습니다. GitHub에서 전체 소스 코드를 찾을 수 있습니다.\n\n여기까지입니다. 이 글이 유용했으면 좋겠습니다. 궁금한 점이나 피드백이 있으시다면 댓글 섹션에 공유해주세요. 기꺼이 답변해 드리겠습니다.","ogImage":{"url":"/assets/img/2024-05-14-IntegratingGoogleGeminitoNodejsApplication_0.png"},"coverImage":"/assets/img/2024-05-14-IntegratingGoogleGeminitoNodejsApplication_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 애플리케이션에 캐로셀 통합하는 방법","description":"","date":"2024-05-14 10:53","slug":"2024-05-14-HowtoIntegrateaCarouselintoReactApplications","content":"\n\n## 이 글에서는 AI 도우미와 함께 React 웹사이트를 계속해서 구축하고 있어요! React Responsive Carousel 라이브러리를 사용하여 프로젝트에 캐러셀을 추가하는 방법을 배워보세요. 예상보다 쉬워요!\n\n![이미지](/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_0.png)\n\n이 글에서는 AI와 페어 프로그래밍을 통해 배우고 있는 React 개념을 다루며 '스타 워즈 아소카' 웹사이트를 만들어 나가고 있어요.\n\n이 글에서는 React 프로젝트에 이미지 캐러셀을 추가하는 방법에 중점을 둘 거예요.\n\n\n\n프로젝트에서 React 이미지 캐러셀을 구현한 방법, 조건부 렌더링 방법 및 통합하는 동안 마주한 일부 어려움에 대해 이야기하겠습니다.\n\nReact 프로젝트에 이미지 캐러셀을 추가하는 방법을 알고 싶다면, React Responsive Carousel을 설치하고 Carousel 컴포넌트를 프로젝트에 추가하여 이미지 소스를 넣기만 하면 됩니다.\n\nReact Responsive Carousel 라이브러리를 사용해 React 프로젝트에 Carousel 컴포넌트를 추가하려면 다음 단계를 따르세요:\n\n- 다음을 실행하여 React Responsive Carousel 라이브러리를 설치하세요:\n\n\n\n```js\nnpm install react-responsive-carousel\n```\n\n- 리액트 파일에서 Carousel 컴포넌트와 스타일을 불러오세요:\n  \n```js\nimport { Carousel } from 'react-responsive-carousel';\nimport 'react-responsive-carousel/lib/styles/carousel.min.css'; // 로더가 필요합니다\n```\n\n- 프로젝트에 Carousel 컴포넌트를 추가하고 원하는 속성을 전달하세요:\n\n\n\n```js\n<뷰캐로셀>\n    <div>\n        <img src=\"/assets/image1.jpg\" />\n        <p className=\"legend\">이미지 1</p>\n    </div>\n    <div>\n        <img src=\"/assets/image2.jpg\" />\n        <p className=\"legend\">이미지 2</p>\n    </div>\n    <div>\n        <img src=\"/assets/image3.jpg\" />\n        <p className=\"legend\">이미지 3</p>\n    </div>\n</뷰캐로셀>\n```\n\n이 설정을 사용하면 프로젝트에 세 개의 슬라이드가 있는 기본 캐로셀이 포함됩니다. 이미지의 경로에 해당하는 src 속성을 조정하고 필요에 맞게 내용을 수정하세요.\n\n이 기사 시리즈를 따라오고 있거나 React 프로젝트에 이미지 캐로셀을 포함하는 방법에 대해 보다 자세한 설명을 원한다면, 이 기사 계속 읽어보세요!\n\n<img src=\"/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_1.png\" />\n\n\n\n\n# 준비물\n\n\"스타 워즈 아소카 리액트 웹사이트\"를 만드는 시리즈의 기사를 기초로, 이미지 캐러셀을 구현하는 것은 특정 개념을 익히는 것이 필요합니다. 사용된 사용자 지정 컴포넌트와 기능을 이해하기 위해 이전 기사를 참조해주세요.\n\n캐러셀을 만들기 위한 준비물은 다음과 같습니다:\n\n- 사용자 지정 메뉴 및 네비게이션 바 컴포넌트에 대한 이해.\n- 햄버거 메뉴 컴포넌트에 대한 이해.\n\n\n\n# 아티클 시리즈:\n\n- 리액트 애플리케이션에 YouTube 비디오 통합하는 방법\n- 리액트에서 동적 햄버거 메뉴 개발하기: 단계별 가이드\n- 리액트에서 드롭다운 메뉴 구축하기: 단계별 가이드\n- 파일 분리를 통한 리액트 코드 조직화 방법 안내\n- 컴포넌트 식별자를 사용하여 다양한 HTML 요소 동적 렌더링하는 방법 배우기\n\n# 리액트 반응형 캐러셀 라이브러리란?\n\n리액트 반응형 캐러셀 라이브러리는 캐러셀을 리액트 애플리케이션에 통합하는 것을 간단하게 해주는 컴포넌트입니다. 이 라이브러리는 리액트 프로젝트와 동적 캐러셀 기능 간을 원활하게 연결해줍니다. 이미지 슬라이드쇼나 콘텐츠 캐러셀을 웹 페이지 안에 쉽게 포함하고 관리할 수 있게 해줍니다. 이 라이브러리를 사용하면 설치만 하고 프로젝트에 캐러셀 컴포넌트를 삽입하고 보고 싶은 이미지나 콘텐츠로 구성만 하면 됩니다.\n\n\n\nReact Responsive Carousel 라이브러리는 React 애플리케이션에서 캐러셀의 기능과 외관을 향상시키는 다양한 사용자 정의 옵션을 제공합니다. 이러한 옵션을 사용하여 개인화된 대화형 경험을 만들 수 있습니다.\n\nReact Responsive Carousel 라이브러리의 Carousel 컴포넌트를 사용하면 다양한 속성을 사용하여 캐러셀을 사용자 정의할 수 있습니다. 이러한 속성에는 다음이 포함됩니다:\n\n- showArrows: 네비게이션 화살표를 표시할지 여부. 값: true 또는 false.\n- showStatus: 슬라이드의 현재 상태 표시 여부. 값: true 또는 false.\n- showIndicators: 네비게이션 지시기를 표시할지 여부. 값: true 또는 false.\n- infiniteLoop: 슬라이드의 무한 루핑 활성화 여부. 값: true 또는 false.\n- useKeyboardArrows: 슬라이드 간 이동에 키보드 화살표 사용 여부. 값: true 또는 false.\n- autoPlay: 슬라이드를 자동으로 순환시킬지 여부. 값: true 또는 false.\n- stopOnHover: 마우스가 캐러셀 위에 올라갈 때 슬라이드 순환 중지 여부. 값: true 또는 false.\n- interval: 슬라이드가 전환되는 간격(밀리초).\n- transitionTime: 슬라이드 간 전환 지속 시간(밀리초).\n- swipeable: 터치 지원 장치에서 슬라이드 이동을 위한 스와이프 제스처 허용 여부. 값: true 또는 false.\n- dynamicHeight: 현재 슬라이드의 높이에 따라 캐러셀 높이 조정 여부. 값: true 또는 false.\n- emulateTouch: 터치 지원되지 않는 장치에서 스와이프 활성화 여부. 값: true 또는 false.\n\n참고: 이 라이브러리는 더 이상 제작자가 유지 관리하지 않습니다. react-responsive-carousel에 대해 자세히 알아보려면 문서를 읽어보세요.\n\n\n\n# 왜 이 캐러셀 라이브러리를 선택했을까요?\n\nHashnode AI 어시스턴트에게 조언을 구해서 React 프로젝트에 캐러셀을 추가할 수 있는 옵션에 대해 물어보았어요. React Responsive Carousel은 이제 더 이상 만들자가 관리하지 않지만, 이 라이브러리는 \"사용하기 쉬운\" 캐러셀로 쉽게 구현할 수 있습니다.\n\n제가 이미지 캐러셀을 프로젝트에 구현하는 데 일정한 노력이 필요할 것이라는 것을 알고, Navbar 및 Hamburger 메뉴 구성 요소에서 이를 제어할 수 있는 기능을 원했기 때문에 쉽게 작업할 수 있는 하나를 선택했어요.\n\n# 나의 캐러셀 메뉴 구성 요소\n\n\n\n처음에, 최상의 코딩 관행을 따르기 위해 이미 제작한 메뉴 컴포넌트를 사용하여 이미지 카테고리 옵션(캐릭터, 포스터, 스틸)을 렌더링하려고 시도했습니다. 이미 \"video\" 카테고리를 제거하는 필터를 추가해야 했기 때문에 이제는 세 가지 이미지 카테고리도 필터링해야 한다는 것을 깨달았습니다.\n\n그래서, 다시 한 번 AI 어시스턴트에게 상담하여 메뉴 컴포넌트를 수정할 지, 아니면 캐러셀을 위해 새로운 컴포넌트를 만들어야 할 지 결정해보았습니다. 실제로 새로운 컴포넌트를 만들 시간이었습니다.\n\nReact를 배우면서 주목한 점: 작동하는 코드를 작성하는 방법을 알지만 여러 용도로 컴포넌트를 수정할 때와 별도의 컴포넌트를 작성해야 할 때를 결정하는 것이 여전히 어려운 것 같습니다.\n\n이전에 작성한 메뉴 컴포넌트의 컨텍스트를 제공하여 AI 어시스턴트와 함께 페어 프로그래밍을 하여 캐러셀 메뉴 컴포넌트에 유사한 기능을 만드는 데 도움이 되었습니다.\n\n\n\n## 캐러셀 메뉴 컴포넌트\n\n```js\nimport { carousel_character, carousel_poster, carousel_stills } from \"../data.js\";\n\nexport default function CarouselMenu({ setSelectedCategory, setShowCarousel }) {\n    const categoriesMap = {\n        character: carousel_character,\n        poster: carousel_poster,\n        stills: carousel_stills\n    };\n\n    const handleCategoryChange = (category) => {\n        setSelectedCategory(categoriesMap[category] || categoriesMap['character']);\n        setShowCarousel(true);\n    };\n\n    return (\n        <menu>\n            {Object.keys(categoriesMap).map((category) => (\n                <button className=\"button-sw\"\n                    key={category}\n                    onClick={() => handleCategoryChange(category)}\n                >\n                    {category.charAt(0).toUpperCase() + category.slice(1)}\n                </button>\n            ))}\n        </menu>\n    );\n}\n```\n\n# CarouselMenu 컴포넌트 이해하기\n\nCarouselMenu 컴포넌트는 사용자가 캐릭터, 포스터 및 스틸컷과 같은 이미지 카테고리 간에 전환할 수 있도록 설계되었습니다. 이 컴포넌트가 어떻게 작동하는지 분석하여 사용자가 보고 싶은 콘텐츠를 탐색하고 제어하기 쉽게 만들어 보겠습니다.\n\n\n\n## 데이터 가져오기\n\n먼저, 컴포넌트는 data.js 파일에서 특정 데이터 세트를 가져옵니다. 이 데이터 세트는 carousel_character, carousel_poster, carousel_stills라는 이름을 가지고 있으며 각각 다른 이미지 카테고리를 나타냅니다.\n\n## 컴포넌트 설정\n\nCarouselMenu는 setSelectedCategory와 setShowCarousel 두 가지 함수를 props로 받는 함수형 컴포넌트입니다. 이 함수들은 부모 컴포넌트의 상태를 업데이트하기 위해 사용되며, 표시할 이미지 카테고리와 Carousel을 표시할지 여부를 제어합니다.\n\n\n\n## 카테고리 매핑\n\n컴포넌트 내부에서 categoriesMap 객체가 생성됩니다. 이 객체는 문자열 키(`character`, `poster`, `stills`)를 이전에 가져온 대응하는 데이터셋으로 매핑합니다. 이 매핑은 사용자 선택에 따라 데이터에 쉽게 액세스할 수 있도록 합니다.\n\n## 카테고리 변경 처리\n\nhandleCategoryChange 함수는 상호작용에 매우 중요합니다. 사용자가 메뉴의 버튼 중 하나를 클릭하면 이 함수가 트리거됩니다. 이 함수는 사용자가 클릭한 버튼에 해당하는 카테고리를 인수로 받습니다. 그런 다음 함수는 다음 두 가지 작업을 수행합니다:\n\n\n\n- 선택된 카테고리와 관련된 데이터를 사용하여 setSelectedCategory를 호출하여 부모 구성요소의 상태를 업데이트하여 표시할 이미지의 새 카테고리를 반영합니다.\n- setShowCarousel을 true로 설정하여 선택된 카테고리마다 Carousel이 표시되도록 합니다.\n\n## 메뉴 렌더링\n\n이 구성요소는 각 카테고리에 대한 버튼이 포함된 `menu` 요소를 반환합니다. 이러한 버튼들은 Object.keys(categoriesMap).map(...)을 사용하여 동적으로 생성되며, 이는 categoriesMap의 키 배열을 생성하고 이를 매핑하여 각 카테고리에 대한 버튼을 만듭니다. 각 버튼은 클릭 이벤트가 있어 handleCategoryChange를 해당 카테고리로 트리거하는 것으로 설정됩니다. 버튼 레이블은 각 카테고리 이름의 첫 글자를 대문자로 변환하여 가독성을 높입니다.\n\n이 구성은 직관적인 네비게이션을 제공하고 인터페이스를 깨끗하고 집중시킴으로써 사용자 경험을 향상시킵니다. 이를 통해 Carousel 내에서 다른 데이터 세그먼트와의 원활한 상호 작용이 가능합니다.\n\n\n\n# 네비게이션바 컴포넌트\n\n네비게이션바 컴포넌트는 카테고리 메뉴, YouTube 비디오 및 이제는 React Carousel에서 이미지를 표시하는 모든 앱 기능을 처리합니다.\n\nReact Carousel에 중점을 두기 위해 여기에 더 나은 관찰을 위한 Navbar 컴포넌트의 요약 버전이 있습니다:\n\n```js\nimport { useState } from \"react\";\nimport CarouselMenu from \"./CarouselMenu\";\n\nfunction Navbar({ setSelectedCategory, setShowCarousel, carousel }) {\n    const [isGalleryVisible, setGalleryVisible] = useState(false);\n\n    return (\n        <nav>\n            <div className=\"flex-col\">\n                <div className=\"flex ctn-navbar\">\n                    <div\n                        className=\"navbar-buttons desktop-menu\"\n                        onMouseEnter={() => setGalleryVisible(true)}\n                        onMouseLeave={() => setGalleryVisible(false)}\n                    >\n                        GALLERY\n                        {isGalleryVisible && (\n                            <div className=\"dropdown-menu dropdown-menu-carousel\">\n                                <CarouselMenu\n                                    setSelectedCategory={setSelectedCategory}\n                                    setShowCarousel={setShowCarousel}\n                                    carousel={carousel}\n                                />\n                            </div>\n                        )}\n                    </div>\n                </div>\n            </div>\n        </nav>\n    );\n}\n\nexport default Navbar;\n```\n\n\n\n# 주요 포인트:\n\n- 동적 가시성: isGalleryVisible 상태는 캐러셀 메뉴의 가시성을 제어합니다. \"GALLERY\" 버튼에서의 마우스 이벤트(onMouseEnter, onMouseLeave)에 의해 토글됩니다. 이 접근 방식은 필요할 때만 캐러셀을 표시하는 사용자 친화적인 방법을 제공하여 혼잡도를 줄이고 UI 반응성을 향상시킵니다.\n- 캐러셀 메뉴 통합: \"GALLERY\" 섹션이 활성화된 경우(isGalleryVisible이 true인 경우), CarouselMenu 컴포넌트가 렌더링됩니다. 이 컴포넌트는 캐러셀에 표시될 이미지 카테고리 선택을 처리하는 데 중요합니다.\n- 상호 작용 핸들러: CarouselMenu에 setSelectedCategory 및 setShowCarousel 함수가 props로 전달됩니다. 이러한 함수는 CarouselMenu 내에서 사용되어 사용자 상호 작용에 기반하여 애플리케이션의 상태를 업데이트하는 데 사용됩니다.             \n                           \n이 설정은 Navbar 컴포넌트가 캐러셀 기능과 효과적으로 통합되어 원활하고 대화식 사용자 경험을 제공함을 보장합니다.\n\n# 햄버거 메뉴 컴포넌트\n\n\n\n이 섹션에서는 햄버거 메뉴 구성 요소 내에서 캐러셀이 통합되어 작동하는 방법을 유사하게 종합적으로 살펴볼 것입니다.\n\n## 구성 요소 구조 및 상태 관리\n\n햄버거 메뉴는 내용물의 가시성을 제어하기 위해 여러 상태 변수를 사용합니다:\n\n- isActive : 햄버거 메뉴가 활성화되어 있는지 여부를 결정합니다.\n- isCarouselVisible : 메뉴 내 캐러셀 옵션의 가시성을 제어합니다.\n\n\n\n```js\nconst [isActive, setIsActive] = useState(false);\nconst [isCarouselVisible, setCarouselVisible] = useState(false);\n```\n\n## 동적 UI 조정을 위한 효과\n\n이 컴포넌트는 React의 useEffect를 활용하여 UI의 동적 변경을 처리합니다. 활성화 상태를 기반으로 UI에서 동적 변경이 이뤄집니다. 햄버거 메뉴가 활성화되면 데이터 뱅크와 캐러셀 메뉴와 같은 다른 상호 작용 요소가 숨겨진 기본 상태로 재설정됩니다.\n\n```js\nuseEffect(() => {\n    if (isActive) {\n        setDatabankVisible(false);\n        setCarouselVisible(false); // 햄버거를 토글할 때 캐러셀 메뉴를 닫습니다\n    }\n}, [isActive]);\n```\n\n\n\n## 캐러셀 가시성 토글\n\n햄버거 메뉴에는 \"갤러리\"를 위한 인터랙티브 섹션이 포함되어 있으며 상호 작용 시 캐러셀 메뉴의 가시성을 토글합니다. 이는 마우스 이벤트(onMouseEnter 및 onMouseLeave)를 활용하여 isCarouselVisible 상태를 설정하는 방식으로 처리됩니다. 이 접근 방식은 필요할 때만 캐러셀에 접근할 수 있는 사용자 친화적인 방법을 제공하며 응용 프로그램의 사용성과 인터페이스의 청결함을 향상시킵니다.\n\n```js\n<div\n    className=\"navbar-buttons\"\n    onMouseEnter={() => setCarouselVisible(true)}\n    onMouseLeave={() => setCarouselVisible(false)}\n>\n    GALLERY\n    {isCarouselVisible && (\n        <CarouselMenu\n            setSelectedCategory={setSelectedCategory}\n            setShowCarousel={setShowCarousel}\n        />\n    )}\n</div>\n```\n\n## 기능성 및 사용자 상호작용\n\n\n\nhandleClick함수는 햄버거 메뉴의 isActivestate를 토글하여 드롭다운 메뉴 항목의 전반적인 가시성을 제어합니다. 또한 toggleCarouselfunction은 캐러셀의 가시성을 명시적으로 토글하는 방법을 제공하여 메뉴의 상호작용 능력을 더욱 향상시킵니다.\n\n```js\nfunction handleClick() {\n    setIsActive(!isActive);\n}\n```\n\n이 햄버거 메뉴 설정은 캐러셀 기능이 매끄럽게 통합되어 있어 응용 프로그램의 다양한 섹션을 탐색하기 위한 간결하고 효과적인 사용자 인터페이스를 제공합니다.\n\n# 메뉴 컴포넌트\n\n\n\n위 코드는 Menu 컴포넌트 내에서 React 캐러셀이 관리되는 방식에 초점을 맞춘 버전입니다. 기본적으로 사용자가 캐러셀에 없는 카테고리를 선택하면 React 캐러셀이 숨겨집니다:\n\n```js\nfunction Menu({ setSelectedCategory, setShowCarousel, categories }) {\n    return (\n        <menu>\n            {Object.keys(categories)\n                .filter((category) => category !== \"youtube\")\n                .map((category) => (\n                    <button className=\"button-sw\"\n                        key={category}\n                        onClick={() => {\n                            setSelectedCategory(categories[category]);\n                            setShowCarousel(false);\n                        }}\n                    >\n                        {category.charAt(0).toUpperCase() + category.slice(1)}\n                    </button>\n                ))}\n        </menu>\n    );\n}\n```\n\n# 주요 기능:\n\n- 카테고리 필터링: Menu는 특정 카테고리(예: `youtube`)를 걸러내어 표시되는 버튼을 조정합니다. 이를 통해 상호 작용할 수 있는 관련 카테고리만 포함됩니다.\n- 버튼 다이내믹스: 각 버튼은 사용 가능한 카테고리를 기반으로 동적으로 생성되며, 필터링된 항목은 제외됩니다. 버튼 텍스트는 가독성과 미적 매력을 높이기 위해 대문자로 표시됩니다.\n- 상태 관리: 버튼을 클릭하면 두 가지 중요한 기능이 호출됩니다:\n  - setSelectedCategory(categories[category]): 이 함수는 선택한 카테고리를 반영하도록 상태를 업데이트하여 캐러셀이나 다른 구성 요소에 표시되는 데이터 또는 이미지를 결정합니다.\n  - setShowCarousel(false): 이 함수는 캐러셀의 가시성을 제어하여 캐러셀을 숨길 수 있도록 합니다. 이미지와 관련이 없는 카테고리가 선택된 경우 또는 캐러셀이 필요하지 않은 경우에 사용됩니다.\n\n\n\n이 구성은 애플리케이션의 상호작용성을 향상시키고 사용자 인터페이스가 깨끗하고 집중력이 있으며 사용자 입력에 반응할 수 있도록 보장합니다.\n\n# 주요 애플리케이션 구성 요소에서 React 캐러셀 구현하기\n\nReact 애플리케이션의 주요 Appcomponent에서 React Responsive Carousel 통합은 콘텐츠의 동적 프레젠테이션을 향상시키는 데 중요한 역할을 합니다. 여기에는 캐러셀이 이 구성 내에서 어떻게 구현되고 작동하는지에 대한 개요가 있습니다:\n\n## 캐러셀 가시성을 위한 상태 관리\n\n\n\nAppComponent은 여러 상태 변수를 관리하지만 캐로셀 기능에 중요한 것은 showCarousel과 selectedCategory입니다. showCarousel 상태는 캐로셀을 표시해야 하는지 여부를 결정하고, selectedCategory는 캐로셀에 표시될 항목 데이터를 보유합니다.\n\n```js\nconst [showCarousel, setShowCarousel] = useState(false);\nconst [selectedCategory, setSelectedCategory] = useState(characters);\n```\n\n## 캐로셀의 조건부 렌더링\n\n캐로셀은 showCarousel 상태에 따라 조건부로 렌더링됩니다. showCarousel이 true이면 캐로셀이 표시되고, 그렇지 않으면 StarWarsCard와 같은 다른 컴포넌트가 표시됩니다. 이 접근 방식은 유연하고 사용자 중심의 표시를 가능하게 하며, 캐로셀과 다른 콘텐츠 뷰 간을 전환할 수 있습니다.\n\n\n\n```js\n{showCarousel가 true이면 (\n    <Carousel className=\"ctn-carousel\">\n        {selectedCategory && selectedCategory.map((item) => (\n            <div key={item.name}>\n                <img src={item.image} />\n                <p className=\"legend\">{item.name}</p>\n            </div>\n        ))}\n    </Carousel>\n)}\n```\n\n## 캐로셀 콘텐츠 동적\n\n캐로셀의 내용은 선택한 카테고리에서 동적으로 생성됩니다. 선택한 카테고리의 각 항목이 캐로셀 슬라이드에 매핑되어 이미지와 캡션(이름)이 표시됩니다. 이 동적 매핑은 캐로셀이 항상 선택한 카테고리의 콘텐츠와 최신 정보를 유지할 수 있도록 합니다.\n\n## 네비게이션 바와의 상호작용\n\n\n\nNavbar 컴포넌트는 App 컴포넌트와 상호작용하여 selectedCategory를 설정하고 showCarousel 상태를 토글합니다. 이 설정은 Navbar이 제어판 역할을 하며 어떤 콘텐츠가 어떻게 표시되는지에 영향을 미치는 역할을 명확히 보여줍니다.\n\n```js\n<Navbar\n    categories={categories}\n    setSelectedCategory={setSelectedCategory}\n    setShowCarousel={setShowCarousel}\n/>\n```\n\nApp 컴포넌트에서 이 디자인 패턴은 캐러셀이 어플리케이션의 시각적 매력을 높이는 데만 그치는 것이 아니라, 원활하고 상호작용이 가능한 사용자 경험을 제공한다는 것을 보장합니다.\n\n# 직면한 문제들\n\n\n\n초반에는 캐러셀 썸네일을 이미지 위에 표시하도록 재배치하려고 했어요. 여러 번 시도했지만 성공하지 못했어요. 먼저 리액트 캐러셀 컴포넌트 자체에 들어가보려고 했지만, 내 의심이 확인되어 내 코드 변경이 프로젝트에서 리액트 캐러셀 라이브러리를 업데이트하면 덮어씌워질 거라는 제 AI 도우미가 알려줬어요!\n\n두 번째 시도는 CSS 파일을 사용해서 캐러셀 썸네일을 이미지 위로 재배치하는 것이었어요. 하지만 AI 도우미와 함께 해도 리액트 캐러셀 컴포넌트의 구조를 재배치할 수 없었어요. 그래서 그냥 내버려두기로 결정했어요.\n\n다른 문제는 리액트 캐러셀 컴포넌트의 스타일링이었어요. 이번에 처음으로 만드는 캐러셀을 다루기 때문에 처음에는 별 생각없이 해봤는데, 살짝 어설펐어요. \"슬라이딩\" 기능도 잘 작동하지 않았을 뿐만 아니라 좌우 화살표가 이미지 중앙에 가운데 정렬된 것을 발견했어요. 좌우 화살표는 이미지 옆에 있어야 하는데 말이죠.\n\n맞아요, 제 의심이 다시 한 번 맞았어요. 이번에는 내 CSS 코드가 리액트 캐러셀과 충돌했어요. CSS 파일을 주석 처리해서 일단 내 CSS 파일을 비활성화하고 리액트 캐러셀 라이브러리의 CSS만 활성화되도록 문제를 해결할 수 있었어요. CSS 파일을 제거하고 나니 리액트 캐러셀 컴포넌트의 의도한 모습과 기능을 명확히 볼 수 있었어요.\n\n\n\n내 CSS 실수가 HTML Button 요소 자체를 대상으로 했기 때문에 React Carousel 구성요소가 의도치 않게 깨졌습니다. HTML Button 요소 자체 대신 새 클래스를 생성하고 대상으로 지정함으로써 문제를 해결했습니다.\n\n## 초기 CSS 코드는 다음과 같았습니다:\n\n```css\nbutton {\n margin: 3px;\n padding: 0;\n width: 100%;\n background-color: black;\n color: white;\n font-weight: bold;\n font-size: xx-large;\n}\n```\n\n## 코드를 다음과 같이 업데이트했습니다:\n\n\n\n```js\n.button-sw {\n margin: 3px;\n padding: 0;\n width: 100%;\n background-color: black;\n color: white;\n font-weight: bold;\n font-size: xx-large;\n}\n```\n\nReact Carousel 구성 요소에 표시된 이미지 크기 조정에도 고민이 많았어요. 기본 크기가 제공한 가장 큰 이미지에 맞는 것으로 보입니다. 제 경우에는, 가장 큰 이미지가 Carousel의 높이를 거의 전체 화면 크기로 설정했어요!\n\n\".carousel .slide img\"에 CSS 규칙을 적용하여 React Carousel 구성 요소의 높이를 올바르게 조정하고, 그 안의 이미지를 왜곡되지 않게 원하는 값으로 max-height를 설정하고, object-fit: contain을 사용하여 이미지가 컨테이너 내에서 올바르게 비율로 나타날 수 있도록 했어요.\n\n```js\n.carousel .slide img {\n max-height: 350px;\n object-fit: contain; \n}\n```\n\n\n\n마지막으로 마주한 문제는 React Carousel 구성 요소 위에 확장되어 드롭다운 메뉴가 고장이 났다는 것이었습니다. 이제 카루셀과 충돌하기 때문에 메뉴에서 새 카테고리를 선택할 수 없었고, 사용자 클릭은 이제 카루셀 구성 요소에서만 인식되었습니다.\n\n드롭다운 메뉴와 카루셀 구성 요소 사이의 충돌을 해결하기 위해 메뉴의 z-index를 1로 설정하고 카루셀 구성 요소의 z-index를 0으로 설정했습니다.\n\n# 지금까지의 프로젝트 상황\n\n프로젝트에 대한 링크는 다음과 같습니다:\n\n\n\n- GitHub 저장소\n- Netlify 배포된 프로젝트\n\n![이미지](/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_2.png)\n\n# 이 시리즈의 다른 글들\n\n- 동적으로 다양한 HTML 요소 렌더링을 위한 컴포넌트 식별자 사용 배우기\n- React에서 파일 분리를 통한 더 나은 코드 구성 안내\n- React에서 드롭다운 메뉴 만들기: 단계별 안내서\n- React에서 동적 햄버거 메뉴 개발하기: 단계별 안내서\n- React 애플리케이션에 YouTube 비디오 통합하는 방법\n\n\n\n# 결론\n\n프로젝트에 이미지 캐러셀을 추가하면 시각적으로 향상되며, React Responsive 캐러셀 라이브러리를 사용하면 구현이 간단해집니다! 그냥 설치하고, Carousel 컴포넌트를 프로젝트에 추가하고, 이미지와 다른 선택적 매개변수를 전달하면 됩니다.\n\n이 라이브러리를 만든 사람은 더 이상 관리하지 않지만, 초보자 프로젝트를 만들 때 좋은 선택입니다.\n\n그래서, 프로젝트에 캐러셀을 구현하는 것은 내게 쉽지 않은 일이었는데, 내가 사용자 정의 드롭다운 메뉴를 사용하여 제어하기로 선택했기 때문입니다. 이 어려움은 React 캐러셀 컴포넌트 자체가 아닌 내가 설계한 레이아웃에서 나온 것입니다.\n\n\n\n시행착오 끝에 AI 도우미의 도움을 받아 모든 문제를 해결하고 React 캐러셀을 예상대로 작동하도록 성공적으로 구현했어요.\n\n알게 된 것은 React 컴포넌트 내의 코드를 직접 변경하거나 추가해서는 안 된다는 점이에요. 변경 사항은 덮어씌워지기 때문이죠! 대신, React Carousel 컴포넌트의 경우 CSS 코드를 작성하여 세밀한 조정을 할 수 있었어요. 단, React Carousel은 자체 CSS 파일을 가지고 있으며, 코드 충돌을 피하기 위해 HTML 요소를 직접 대상으로 삼지 않고 클래스 이름을 추가하는 것이 좋아요. 처음에 했던 것처럼!\n\n저와 연락을 유지해요! LinkedIn과 Twitter에서 활동 중이에요.\n\n![이미지](/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_3.png)\n\n\n\n당신은 selftaughttxg.com에서 제가 쓴 모든 글을 읽을 수 있어요.\n\n이제 React Responsive Carousel 라이브러리를 사용하여 캐러셀을 React 프로젝트에 통합하는 방법을 알게 되었나요? 여러분의 프로젝트에서 비슷한 어려움을 겪은 적이 있나요? 이 글을 공유하고 의견을 남겨주세요!","ogImage":{"url":"/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_0.png","tag":["Tech"],"readingTime":16},{"title":"리액트 NextJS 앱에 Material UI 통합하기","description":"","date":"2024-05-14 10:52","slug":"2024-05-14-IntegratingMaterialUIintoaReactNextJSapp","content":"\n\n이제 Material UI를 NextJS 앱에 추가하는 방법을 자세히 살펴보겠습니다. 빠르게 실행할 수 있도록 도와 드리겠습니다!\n\n![image](/assets/img/2024-05-14-IntegratingMaterialUIintoaReactNextJSapp_0.png)\n\n빨리 보고 싶다면 여기에서 전체 변경 사항을 확인할 수 있어요 😄. 이것은 react-portfolio-app의 일부로 더 큰 프로젝트의 일부입니다.\n\n먼저 Material UI, emotion/react 및 emotion/styled를 설치하는 일반적인 설치 가이드를 따라 시작하세요.\n\n\n\n```js\nyarn add @mui/material @emotion/react @emotion/styled\n```\n\nEmotion styled 컴포넌트를 사용하여 스타일이 적용된 React 컴포넌트를 정의할 수 있어요. JSX 형식으로 모든 것이 포함되어 가독성이 더 높아지고 스타일링이 재사용 가능한 컴포넌트에 포함되어 있어요.\n\n# NextJS를 위한 특정 구성 변경\n\n어플리케이션에 대해 세 가지 변경 사항이 필요해요.\n\n\n\n- 앱 라우터 추가\n- 테마 생성\n- 테마를 ThemeProvider 클라이언트 렌더링 파일에서 사용\n\nNextJS 통합을 위한 Material UI와 관련된 특정 종속성을 설치해야 합니다. 페이지 라우터 대신 앱 라우터를 사용해야 합니다.\n\n```js\nyarn add @mui/material-nextjs @emotion/cache\n```\n\n## 1. 앱 라우터 추가\n\n\n\nAppRouterCacheProvider를 루트 레이아웃에 추가해보세요.\n\n```js\n// app/layout.tsx\nimport { AppRouterCacheProvider } from '@mui/material-nextjs/v13-appRouter';\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>\n        <AppRouterCacheProvider>\n          {children}\n        </AppRouterCacheProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n## 2. 테마 생성\n\ntheme.ts 파일을 만들고 문서에서 설명된 대로 ThemeProvider에서 사용할 테마를 정의하세요.\n\n\n\n```js\r\n// app/theme.ts\n'use client';\nimport { Roboto } from 'next/font/google';\nimport { createTheme } from '@mui/material/styles';\n\nconst roboto = Roboto({\n  weight: ['300', '400', '500', '700'],\n  subsets: ['latin'],\n  display: 'swap',\n});\n\nconst theme = createTheme({\n  typography: {\n    fontFamily: roboto.style.fontFamily,\n  },\n});\n\nexport default theme;\r\n```\n\n## 3. 테마를 ThemeProvider 클라이언트 렌더링 파일에서 사용하기\n\n루트 layout.tsx에 ThemeProvider를 직접 추가하는 대신, ThemeProvider 및 layout.tsx에서 호출할 별도의 파일을 생성해야 합니다. 이렇게 하는 이유는 ThemeProvider가 클라이언트 측 컨텍스트를 설정하기 때문에 서버 측에서 렌더링할 수 없으므로 코드를 자체 클라이언트 렌더링 파일로 가져와서 layout.tsx에서 호출합니다.\n\n이 새 파일인 StyledRoot.tsx에서는 client-side rendered 파일임을 나타내기 위해 파일을 'use client'로 시작합니다 (더 읽기). 파일은 다음과 같이 보일 것입니다:\n\n\n\n```js\n// app/StyledRoot.tsx\n'use client';\nimport { ThemeProvider } from '@mui/material/styles';\nimport theme from './theme';\n\nexport function StyledRoot({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <ThemeProvider theme={theme}>\n      {children}\n    </ThemeProvider>\n  );\n}\n```\n\n그런 다음 우리는 레이아웃(layout.tsx)에 이를 추가하여 자식 구성 요소를 StyledRoot.tsx로 전달합니다.\n\n```js\n// app/layout.tsx\nimport { AppRouterCacheProvider } from '@mui/material-nextjs/v13-appRouter';\nimport { StyledRoot } from './StyledRoot';\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>\n        <AppRouterCacheProvider>\n           <StyledRoot>{children}</StyledRoot>\n        </AppRouterCacheProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n그래서 마무리입니다!\n\n\n\n이제 Material UI를 사용하여 NextJs 앱을 실행할 수 있습니다. 다음 단계는 컴포넌트를 추가하는 것입니다!\n\n컴포넌트 라이브러리를 살펴보며 디자인을 지원하는 컴포넌트를 확인하고, 해당 컴포넌트를 구현하는 방법에 대한 코드 예제를 살펴보세요!\n\nMaterial UI 템플릿도 훌륭한 자료입니다. 실제로 Material UI 컴포넌트를 사용하는 다양한 예제를 제공합니다. 저는 포트폴리오 앱을 구축할 때 블로그 템플릿에 특별히 관심을 가졌어요.\n\n이상으로 모두인데요! 이 기사가 도움이 되었는지, 빠진 중요한 내용이 있는지 알려주세요!","ogImage":{"url":"/assets/img/2024-05-14-IntegratingMaterialUIintoaReactNextJSapp_0.png"},"coverImage":"/assets/img/2024-05-14-IntegratingMaterialUIintoaReactNextJSapp_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 라우터 시작하기","description":"","date":"2024-05-14 10:51","slug":"2024-05-14-GettingStartedwithReactRouter","content":"\n\n![React Router](/assets/img/2024-05-14-GettingStartedwithReactRouter_0.png)\n\n다이나믹 웹 앱을 만들어 보고 싶은 꿈이 있나요? 사용자가 페이지를 새로 고침하지 않고 서로 다른 섹션 또는 페이지로 쉽게 이동할 수 있는 경험을 제공하는 React Router가 여러분의 비밀 병기가 될 거예요! React 앱에 초능력을 부여하는 강력한 라이브러리로, 부드럽고 직관적인 내비게이션 경험을 만들어볼 수 있어요.\n\n이 안내서는 여러분이 React Router 여행을 떠날 때 나침반 역할을 할 거예요. 기본 사항을 분해하고 일반적인 경로를 탐색하여 페이지 이동 및 사용자 친화적인 앱 구축을 시작하는 데 도움을 줄 거예요.\n\n설치 및 설정\n\n\n\n코드를 시작하기 전에 React Router를 사용해보겠습니다. 터미널을 열고 다음 설치 명령어를 입력하세요:\n\n```js\nbash\nnpm install react-router-dom\n```\n\n이 명령어는 React 어플리케이션 내에서 작업하기 위해 특별히 설계된 React Router의 최신 버전을 설치합니다.\n\n이제, React Router를 우리 어플리케이션의 주요 파일인 index.js(main.jsx)에 소개해야 합니다. react-router-dom에서 BrowserRouter 컴포넌트를 import하세요. 이 컴포넌트는 네이게이션의 주인공으로 현재 URL을 추적하고 해당 내용이나 컴포넌트를 렌더링하는 역할을 합니다.\n\n\n\n애플리케이션 전체(일반적으로 App.jsx)을 BrowserRouter로 감싸세요. 이렇게 하면 모든 컴포넌트가 라우팅 마법을 활용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithReactRouter_1.png)\n\n라우트 및 컴포넌트\n\n앱을 각각의 뷰 또는 섹션을 나타내는 섬들의 집합으로 상상해보세요. React Router의 Route 컴포넌트는 사용자를 이러한 섬들 사이를 운반해주는 배 역할을 합니다.\n\n\n\n간단한 예제입니다:\n\n```js\nimport {Routes, Route } from 'react-router-dom';\nimport Home from './components/Home';\nimport About from './components/About';\nfunction App() {\n return (\n\n <Routes>\n <Route path=\"/\" element={<Home />} /> {/* 홈 페이지로 이동하는 경로 */}\n <Route path=\"/about\" element={<About />} /> {/* 소개 페이지로 이동하는 경로 */}\n </Routes>\n \n );\n}\n\nexport default App;\n```\n\n이 예제에서 두 가지 경로가 있습니다:\n\n1. 첫 번째 경로 (path=\"/\")는 Home 컴포넌트에 해당하는 홈 페이지를 가리킵니다.\n2. 두 번째 경로 (path=\"/about\")는 About 컴포넌트에 해당하는 소개 페이지로 이동합니다.\n\n\n\n사용자가 앱의 루트 URL을 방문하면 홈페이지가 표시됩니다. 그들이 /about으로 이동하면 About 컴포넌트가 주인공이 됩니다.\n\n링크로 탐색하기\n\n그럼 사용자는 이럿의 다른 섬들을 어떻게 탐험할까요? React Router는 링크 컴포넌트를 제공합니다. 이는 마법의 앵커와 같은 역할을 하는데요. 이는 html의 앵커 태그와 동의어입니다. 링크를 클릭하면 React Router가 지정된 경로로 항해하라고 알려줍니다.\n\n다음은 사용 방법입니다:\n\n\n\n```js\nimport { Routes, Route, Link } from 'react-router-dom';\nfunction App() {\n return (\n \n <nav>\n   <Link to=\"/\">홈</Link>\n   <Link to=\"/about\">소개</Link>\n </nav>\n\n\n <Routes>\n   <Route path=\"/\" element={<Home />} /> {/* 홈 경로 */}\n   <Route path=\"/about\" element={<About />} /> {/* 소개 경로 */}\n </Routes>\n\n );\n}\n\nexport default App;\n```\n\n이 코드는 두 개의 링크가 있는 간단한 내비게이션 바를 만듭니다. \"홈\" 링크를 클릭하면 사용자를 홈 페이지로 이동시키고, \"소개\"를 클릭하면 소개 페이지로 이동시킵니다. 모두 React Router가 원활하게 처리합니다.\n\n만약 Not Found Routes가 있으면 어떨까요?\n\n![GettingStartedwithReactRouter_2](/assets/img/2024-05-14-GettingStartedwithReactRouter_2.png)\n\n\n\n\n만약 사용자가 정의된 경로와 일치하지 않는 URL을 입력하려고 하면 어떻게 될까요? React Router는 이러한 상황을 처리하는 편리한 방법을 제공합니다. 사용자 지정 \"404 Not Found\" 페이지를 표시하기 위한 catch-all route를 추가할 수 있습니다:\n\n```js\n<Route path=\"*\" element={<NotFound />} />\n```\n\n이 route는 이전에 정의된 경로와 일치하지 않는 모든 URL에 일치하며, 사용자가 길을 잃지 않도록 보장합니다. 별표(`*`)는 와일드카드로 작동하여 이 route가 애플리케이션의 기본 URL 뒤에 오는 내용에 관계없이 모든 URL 경로와 일치할 것을 나타냅니다.\n\n이것은 React Router가 제공하는 일부 기능의 일부에 불과합니다. 앱이 성장함에 따라 중첩된 route, 동적 매개변수, 프로그래밍 방식의 탐색과 같은 더 고급 기능을 탐색할 수 있습니다. React Router는 복잡하고 사용자 친화적인 네비게이션 경험을 구축할 수 있도록 돕으며, 웹 앱을 탐험하기 즐거운 경험으로 만들어줍니다.\n\n\n\nReact Router 모험의 시작에 불과하다는 것을 기억하세요. 더 많은 기능을 발견할 수 있고 연습을 통해 금방 마스터 네비게이터가 될 거에요!","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithReactRouter_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithReactRouter_0.png","tag":["Tech"],"readingTime":3},{"title":"서버 측 세션 구현하기 - Nextjs","description":"","date":"2024-05-14 10:50","slug":"2024-05-14-NextjsImplementingServer-SideSessions","content":"\n\n<img src=\"/assets/img/2024-05-14-NextjsImplementingServer-SideSessions_0.png\" />\n\n# 단계 1: 서버 측 세션 구현하기\n\n먼저 세션 관리 시스템을 설정하세요. 일반적으로 세션을 생성하고 유효성을 검사하며, 세션 정보를 안전한 HTTP-only 쿠키에 저장하는 과정을 포함합니다.\n\n## API 라우트에서의 세션 관리\n\n\n\nAPI 라우트(app/routes/api/)에서 세션을 관리할 수 있습니다. 예를 들어, 로그인 라우트에서는 사용자를 인증하고 세션을 생성한 후 세션 쿠키를 설정할 수 있습니다.\n\n```js\n// app/routes/api/login.ts\n\nimport { createSession, getUser } from '@/lib/auth'; // 이 함수들을 구현하세요\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\nexport default async function login(req: NextApiRequest, res: NextApiResponse) {\n  const user = await getUser(req.body.username, req.body.password); // 사용자 인증\n  if (!user) {\n    return res.status(401).json({ error: '유효하지 않은 자격 증명' });\n  }\n\n  const sessionId = await createSession(user.id); // 세션 생성\n  res.setHeader('Set-Cookie', `sessionId=${sessionId}; HttpOnly; Path=/; SameSite=Lax`);\n  res.status(200).json({ message: '성공' });\n}\n```\n\n# 단계 2: App Router 미들웨어를 사용한 리디렉션\n\nApp Router 미들웨어를 사용하여 요청을 가로채고 세션 상태를 기반으로 로직을 구현할 수 있습니다.\n\n\n\n## 미들웨어 예시\n\n세션 유효성 검사와 리다이렉션을 처리하는 미들웨어 파일(e.g., app/middleware.ts)을 생성하세요.\n\n```js\n// app/middleware.ts\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getSession } from '@/lib/session'; // 이 함수 구현 필요\n\nexport async function middleware(req: NextRequest) {\n  const session = await getSession(req.cookies.sessionId); // 세션 유효성 검사\n\n  // 세션이 없고 요청이 보호된 경로일 경우에는 로그인 페이지로 리다이렉션\n  if (!session && req.nextUrl.pathname.startsWith('/protected')) {\n    return NextResponse.redirect(new URL('/login', req.url));\n  }\n\n  return NextResponse.next();\n}\n```\n\n# 단계 3: 클라이언트에서 세션 유효성 검사 및 리다이렉션\n\n\n\n클라이언트 측에서는 여전히 세션 관련 업데이트를 처리해야 할 수도 있습니다. 로그인/로그아웃 후 리다이렉트 또는 로딩 상태 표시와 같은 작업들이 필요할 수 있어요.\n\n```js\n// 당신의 React 컴포넌트 안에서\nimport { useEffect } from 'react';\nimport { useRouter } from 'next/router';\n\nconst MyComponent = () => {\n  const router = useRouter();\n\n  useEffect(() => {\n    // 세션 상태 확인하고 필요시 리다이렉트\n    // 세션을 확인하는 API 루트에 요청을 보낼 수도 있어요.\n    checkSession().then(isValidSession => {\n      if (!isValidSession) {\n        router.push('/login');\n      }\n    });\n  }, []);\n\n  // 컴포넌트 렌더링\n};\n```\n\n# 결론\n\n- 세션 보안: 안전한 HTTP-only 쿠키를 사용하여 세션 식별자를 저장하세요.\n- 쿠키 플래그: SameSite 및 Secure와 같은 적절한 쿠키 플래그 설정을 통해 보안을 강화하세요.\n- 확장성: 확장 가능한 애플리케이션을 위해 세션 관리에 데이터베이스나 Redis와 같은 서비스를 고려해보세요.\n- 오류 처리: 세션 관리 로직에서 견고한 오류 처리를 보장하세요.\n- 클라이언트 측 처리: 서버 측 확인이 있더라도, 사용자 경험을 향상시키기 위해 세션 상태에 따라 특정 클라이언트 측 동작을 처리할 수도 있습니다.\n\n\n\n이 설정은 App Router를 사용하여 Next.js 애플리케이션에서 서버 측 세션을 관리하고 라우트 액세스를 제어하는 강력한 시스템을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-14-NextjsImplementingServer-SideSessions_0.png"},"coverImage":"/assets/img/2024-05-14-NextjsImplementingServer-SideSessions_0.png","tag":["Tech"],"readingTime":3},{"title":"TypeScript에서 리터럴 이해하기 포괄적인 안내","description":"","date":"2024-05-14 10:49","slug":"2024-05-14-UnderstandingLiteralsinTypeScriptAComprehensiveGuide","content":"\n\n<img src=\"/assets/img/2024-05-14-UnderstandingLiteralsinTypeScriptAComprehensiveGuide_0.png\" />\n\n프로그래밍 세계에서 기초 개념을 이해하는 것은 중요합니다. 리터럴은 TypeScript의 기본 개념 중 하나입니다. TypeScript를 막 시작했거나 지식을 더 키우고 싶다면, 이 안내서는 TypeScript에서 리터럴과 그 중요성에 대해 포괄적으로 이해하도록 도와줄 것입니다.\n\n# 리터럴이란 무엇인가요?\n\nTypeScript에서 리터럴이란 정확하고 변경할 수 없는 값들을 가리킵니다. 이러한 값들은 계산이나 변환 없이 코드에 직접 제공됩니다. TypeScript는 숫자 리터럴, 문자열 리터럴, 부울 리터럴 등 여러 유형의 리터럴을 지원합니다.\n\n\n\n# 숫자 리터럴\n\n숫자 리터럴은 TypeScript에서 숫자를 나타냅니다. 십진수(기수 10), 16진수(기수 16), 8진수(기수 8), 또는 2진수(기수 2)와 같은 다양한 형식으로 표현할 수 있습니다. 여기에 몇 가지 예시가 있습니다:\n\n```js\nlet decimalLiteral: number = 42;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\n```\n\n\n\n문자열 리터럴은 홑따옴표(‘ ‘)나 겹따옴표(“ “)로 둘러싸인 텍스트 데이터를 나타냅니다. 문자, 숫자, 기호 및 특수 문자를 포함할 수 있습니다. TypeScript에서 문자열 리터럴이 어떻게 보이는지 여기에 있습니다:\n\n```js\nlet hello: string = \"Hello\";\nlet world: string = 'World';\n```\n\n# 부울 리터럴\n\n부울 리터럴은 true 또는 false라는 두 가지 가능한 값만을 나타냅니다. 논리 연산 및 조건식에 일반적으로 사용됩니다. 부울 리터럴의 사용법은 다음과 같습니다:\n\n\n\n```js\nlet isTrue: boolean = true;\nlet isFalse: boolean = false;\n```\n\n# 다른 리터럴 타입\n\n숫자, 문자열 및 불리언 리터럴 외에도 TypeScript는 null 및 undefined와 같은 다른 리터럴 타입을 지원합니다.\n\n```js\nlet nullLiteral: null = null;\nlet undefinedLiteral: undefined = undefined;\n```\n\n\n\n# 리터럴 사용의 장점\n\n- 타입 안전성: 리터럴을 사용하면 TypeScript가 특정 타입을 추론하여 개발 중에 타입 안전성을 제공합니다. 예를 들어, 숫자 리터럴을 변수에 할당하는 경우 TypeScript는 변수의 타입이 숫자임을 알고 있습니다.\n- 명확성과 가독성: 리터럴을 사용하면 코드가 명확하고 가독성이 좋아집니다. 코드에서 리터럴 값을 보면 다른 곳에서 정의를 찾아볼 필요없이 해당 값이 무엇을 나타내는지 정확하게 알 수 있습니다.\n- 향상된 도구 지원: TypeScript의 IntelliSense 및 코드 편집기는 리터럴을 사용할 때 더 나은 자동 완성 제안 및 타입 검사 지원을 제공하여 더 생산적인 개발 경험을 제공할 수 있습니다.\n\n# 리터럴 타입 사용\n\nTypeScript에서는 문자열, 숫자 또는 부울 리터럴을 기본 타입으로 사용하여 사용자 정의 리터럴 타입을 생성할 수 있습니다. 이를 통해 변수가 보유할 수 있는 특정 값들을 정의할 수 있습니다.\n\n\n\n```js\ntype 방향 = '위' | '아래' | '왼쪽' | '오른쪽';\n\nlet move: 방향 = '위'; // 유효함\nlet invalidMove: 방향 = '대각선'; // 에러: '대각선'을 '방향' 타입에 할당할 수 없습니다\n```\n\n# 결론\n\n리터럴은 TypeScript에서 타입 안정성과 코드 가독성을 향상시키는 정확하고 변경할 수 없는 값 제공하는 데 중요한 역할을 합니다. 리터럴을 효과적으로 사용하는 방법을 이해하면 TypeScript 코드의 품질과 유지보수성을 향상시킬 수 있습니다. 사용자 정의 리터럴 타입을 정의하거나 내장된 리터럴을 활용하든, 코드베이스에 포함시킬 경우 더 견고하고 신뢰할 수 있는 소프트웨어를 개발할 수 있습니다\n","ogImage":{"url":"/assets/img/2024-05-14-UnderstandingLiteralsinTypeScriptAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-14-UnderstandingLiteralsinTypeScriptAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트js와 TypeScript의 차이를 탐구해보기","description":"","date":"2024-05-14 10:48","slug":"2024-05-14-ExploringtheDifferencesBetweenReactjsandTypeScript","content":"\n\n![React vs TypeScript](/assets/img/2024-05-14-ExploringtheDifferencesBetweenReactjsandTypeScript_0.png)\n\n자바스크립트를 좋아하는 건 음악을 즐기는 것과 비슷해. 사람마다 다르지만, 나는 항상 프로젝트에 대해 자바스크립트를 사용해왔어. 뭐든지 말해봐, 프론트엔드에는 React.js, 백엔드에는 Node.js, 모바일에는 React Native, 심지어 머신 러닝에는 TensorFlow까지 사용해. 모든 문제를 해결하는 거야.\n\n그런데 TypeScript가 나타났어. \"아 또 다른 언어구나!\" 라고 생각했지만, 한 번 시도해보니 의외로 매력을 느꼈어. 지금은 TypeScript를 배우고 있고, React 팬들과 몇 가지 멋진 TypeScript와 React의 차이를 공유하고 싶어.\n\n먼저, 그들은 쌍둥이가 아니야. React는 프론트엔드에서 멋진 친구인 반면, TypeScript는 좀 더 다재다능해. 라이브러리뿐만 아니라, 자바스크립트를 더 멋지게 만드는 전체 프로그래밍 언어야.\n\n\n\nReact.js와 TypeScript는 웹 개발 분야에서 슈퍼히어로 같은 역할을 해. 그들이 멋진 일을 하고 있어. 그런데 알겠니? 때때로, 그들은 함께 협력해서 잘 작동하는 멋진 앱을 만들어. 그래서, React.js와 TypeScript가 어떻게 다른지 이야기해보고, 간단한 코드 조각들을 보여줄게. 멋지지?\n\n오케이, 조금 더 활력을 불어넣어 보자.\n\n## 타입 안전성\n\nReact.js를 상상해봐. 그것은 자바스크립트를 사용하여 아름다운 사용자 인터페이스를 그려내는 예술가 같아. 웹 세상을 위해 재사용 가능한 구성 요소를 만드는 것에 집중해. 하지만, 잠깐만, 자연스럽게 어떤 보디가드도 문에서 타입을 확인하고 있는 건 아니야!\n\n\n\n이제 TypeScript을 소개합니다, JavaScript의 슈퍼히어로 사이드킥입니다. TypeScript은 안전 요소를 추가한 JavaScript 같은 언어입니다. TypeScript은 \"정적 유형 지정\"이라고 하는 멋진 기능을 추가합니다. 이것은 코드 클럽의 보디가 있는 것으로 상상해보세요. 모든 것이 잘 정리되어 있는지 확인합니다. 이것은 단지 코드를 최고 수준으로 만드는 것뿐만 아니라 개발자들이 놀 수 있는 정말 멋진 도구들을 제공합니다. 안전과 멋진 도구 - TypeScript은 이 조합을 가지고 있어요! 🦸‍♂️💻\n\nTypeScript 예제에서 우리는 인터페이스를 사용하여 name 속성의 유형을 명시적으로 정의하여 문자열 유형의 값만 전달되도록 보장합니다.\n\n## 정적 유형 지정 vs. 동적 유형 지정\n\nReact.js는 동적 유형 지정에 의존하여 변수가 실행 중에 유형을 변경할 수 있도록 합니다. TypeScript은 정적 유형 지정을 사용하여 개발 중에 유형 오류를 잡아내어 버그를 줄이고 코드 유지 관리성을 향상시킵니다.\n\n\n\nTypeScript 예제에서 문자열로 선언된 변수에 숫자를 할당하려고 시도하면 컴파일 시 오류가 발생하여 정적 타입의 장점이 부각됩니다.\n\n## 코드 가독성과 유지 보수성\n\nTypeScript는 타입을 명시적으로 정의하여 코드의 가독성을 높이고, 개발자가 코드를 이해하고 유지할 수 있도록 돍게 만듭니다. React.js는 덜 번잡하므로 작은 프로젝트나 빠른 개발이 우선시되는 경우에 선호될 수 있습니다.\n\nTypeScript 예제는 매개변수와 반환 유형의 타입을 명시적으로 선언하여 개발자에게 추가적으로 명확성을 제공합니다.\n\n\n\n## 도구 및 개발 경험\n\nTypeScript는 현대 통합 개발 환경(IDE)에서 고급 도구를 제공합니다. 이 도구에는 자동 완성, 리팩터링 지원, 그리고 더 나은 오류 확인이 포함됩니다. 반면에 언어가 아닌 라이브러리인 React.js는 이러한 기능을 기본적으로 제공하지 않습니다.\n\n이 TypeScript 예제에서는 Visual Studio Code와 같은 코드 편집기를 사용하여 개발 중에 자동 완성 제안과 유형에 대한 즉각적인 피드백을 제공합니다.\n\n## 이것으로 마무리하며 약간의 흥분을 더해봅시다\n\n\n\n그럼 이만큼! React.js와 TypeScript는 웹 개발 세계의 다이내믹한 듀오 같아요. 각각이 갖고 있는 특별한 능력을 가져와서 테이블에 올려놓으니까요. 화려하고 동적인 사용자 인터페이스가 필요해? React.js가 최고의 선택이에요. 코드 품질과 개발자 스웨거에도 조금 더 신경 쓰고 싶어? TypeScript는 정적 타이핑을 제공하는 멋진 친구랍니다.\n\n그런데요, 이 둘이 만나면 마법이 벌어져요! 동적인 UI가 견고한 구조를 만날 때, 마치 코딩 걸작품을 만드는 느낌이랍니다. 그래서 결론은 뭐냐면? 그들은 경쟁자가 아니라 범죄 동료일 뿐이에요. 웹 개발자들에게 놀라운 디지털 경험을 제작하기 위한 최고의 태그 팀을 제공해주죠. 이거 완전한 웹 개발 모험이에요. React.js와 TypeScript와 함께하면 꿈의 팀을 가지게 되는 거죠! 🚀✨\n\n그리고 작은 비밀 보너스가 있어요\n\nTypeScript는 React.js를 위한 무대 뒤의 영웅이 아닙니다. 아니요, 이중 요원이에요! TypeScript를 전면과 후면 모두에서 활용할 수 있습니다. 웹 개발 무대 어느 쪽에서든 마법을 부릴 수 있는 다재다능한 마술사를 가지고 있는 것과 같아요.\n\n\n\n그래서 React.js로 사용자 인터페이스를 더 멋지게 만들고 있건지, 백엔드에서 뒷담화를 조성하고 있건지, TypeScript가 여러분에게 더 부드럽고 버그에 강한 코딩 경험을 제공해줄 겁니다. 이것은 코딩용 스위스 아미 나이프를 가지고 있는 것과 같아요 — 실용적이고 다재다능하며, 어떤 웹 개발 모험이 오더라도 준비되어 있는 겁니다! 🎩🔮✨\n\n다음 주에 뵙겠습니다.","ogImage":{"url":"/assets/img/2024-05-14-ExploringtheDifferencesBetweenReactjsandTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-ExploringtheDifferencesBetweenReactjsandTypeScript_0.png","tag":["Tech"],"readingTime":3}],"page":"119","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}