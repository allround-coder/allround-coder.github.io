{"pageProps":{"posts":[{"title":"프론트엔드 개발자를 위한 필수 치트 8가지","description":"","date":"2024-05-01 23:57","slug":"2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1","content":"\n\n![이미지](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png)\n\n웹 개발자를 위한 궁극적인 자료인 \"웹 개발자를 위한 필수 치트 시트\"에 오신 것을 환영합니다: 에디션 1!\n\n이 대화식 기사에서는 HTML 및 CSS부터 JavaScript 이상의 필수 치트 시트를 살펴볼 것입니다. 이 치트 시트들은 웹 개발의 복잡성을 쉽게 탐색할 수 있도록 도와줄 것입니다.\n\n자, 이제 들어가서 코딩 실력을 향상시켜 보세요!🤍\n\n<div class=\"content-ad\"></div>\n\n- HTML Cheat Sheet\n\n![HTML Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_1.png)\n\nHTML Cheat Sheet는 HTML 요소, 속성 및 구문에 대한 포괄적인 개요를 제공합니다. \"div\" 및 \"p\"와 같은 기본 태그부터 양식 및 표와 같은 더 고급 개념까지, 이 치트 시트는 HTML을 사용하여 웹 페이지를 구조화하고 형식 지정하는 데 필요한 모든 내용을 다룹니다.\n\n2. CSS Cheat Sheet\n\n<div class=\"content-ad\"></div>\n\n![CSS Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_2.png)\n\nCSS Cheat Sheet은 CSS 선택자, 속성 및 값에 대한 go-to 참조 자료입니다. 텍스트 스타일링, 요소 위치 지정 또는 반응형 레이아웃 생성 등을 할 때, 이 치트 시트는 명확한 설명과 CSS 규칙 및 기술의 예제로 유용합니다.\n\n3. JavaScript Cheat Sheet\n\n![JavaScript Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_3.png)\n\n<div class=\"content-ad\"></div>\n\nJavaScript Cheat Sheet은 JavaScript 구문, 데이터 유형, 연산자 및 함수에 대한 편리한 참조 자료입니다. 동적 웹 상호작용을 위한 스크립트를 작성하거나 브라우저에서 데이터를 조작하는 경우, 이 치트 시트는 깔끔하고 효율적인 JavaScript 코드를 작성하고 변수, 반복문 및 조건문과 같은 주요 개념을 이해하는 데 도움이 될 것입니다.\n\n4. Git Cheat Sheet\n\n![](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_4.png)\n\nGit Cheat Sheet은 소프트웨어 개발 프로젝트에서 버전 관리 및 협업에 필수적입니다. `git add` 및 `git commit`과 같은 기본 Git 명령에서 브랜치 및 병합과 같은 더 고급 워크플로까지, 이 치트 시트는 Git을 사용하여 코드베이스를 효과적으로 관리하는 데 빠른 참조 자료를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n5. 부트스트랩 치트 시트\n\n![부트스트랩 치트 시트](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_5.png)\n\n부트스트랩 치트 시트는 부트스트랩 프레임워크에 대한 포괄적인 가이드로, 그리드 시스템, 구성 요소 및 유틸리티를 포함하고 있습니다. 반응형 레이아웃을 구축하거나 UI 요소에 스타일을 적용할 때, 이 치트 시트는 부트스트랩 클래스와 기능을 사용하여 개발 프로세스를 더욱 효율적으로 만들어주는 빠른 참고 자료를 제공합니다.\n\n6. jQuery 치트 시트\n\n<div class=\"content-ad\"></div>\n\n\n![jQuery Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_6.png)\n\njQuery Cheat Sheet은 DOM 조작과 이벤트 처리를 위한 인기 있는 JavaScript 라이브러리에 대한 안내서입니다. 요소 선택 및 CSS 조작, 애니메이션 및 AJAX 요청 처리부터 웹 프로젝트에서 상호작용 및 기능성을 향상하는 데 필요한 jQuery 메소드와 구문을 다룬다.\n\n7. React Cheat Sheet\n\n![React Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_7.png)\n\n<div class=\"content-ad\"></div>\n\n리액트 치트 시트는 사용자 인터페이스를 구축하는 데 리액트 라이브러리를 사용하는 개발자들에게 유용한 참고 자료입니다. 컴포넌트 생성 및 상태 관리, 이벤트 처리 및 동적 콘텐츠 렌더링까지, 이 치트 시트는 리액트 개념과 패턴에 대한 간략한 개요를 제공하여 강력하고 효율적인 리액트 애플리케이션을 개발하는 데 도움이 됩니다.\n\n8. Node.js 치트 시트\n\n![Node.js Cheat Sheet 이미지](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_8.png)\n\nNode.js 치트 시트는 Node.js를 사용한 서버 측 JavaScript 개발을 안내해주는 가이드입니다. 서버 설정 및 HTTP 요청 처리, 모듈 및 파일 시스템 작업부터 확장 가능하고 성능이 우수한 웹 애플리케이션을 구축하는 데 필수적인 Node.js API 및 기능을 다루는 치트 시트입니다.\n\n<div class=\"content-ad\"></div>\n\n이 필수 참고 자료들을 손끝으로 사용하면 어떤 웹 개발 프로젝트에도 자신감 있고 효율적으로 대응할 수 있을 거예요.\n\n이 자원들을 반드시 즐겨찾기 해 두세요✅ 그리고 필요할 때마다 빠르게 참고할 수 있도록 다시 돌아오세요.\n\n더 많은 유용한 기사를 탐색하고 싶다면, Medium에서 저를 팔로우해보세요 🔗 아래 댓글 💬을 남겨주시고 함께할 기술 모험 종류를 알려주세요! 의견을 듣고 싶어요.\n\n이 기사를 즐겼다면, 응원의 의미로 👏 박수를 주는 것을 잊지 마세요!","ogImage":{"url":"/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png"},"coverImage":"/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png","tag":["Tech"],"readingTime":4},{"title":"크로스 도메인에서 로컬스토리지 구현하기","description":"","date":"2024-05-01 23:55","slug":"2024-05-01-Howtoachievecross-domainlocalStorage","content":"\n\n\n![이미지](/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png)\n\nLocalStorage는 웹에 데이터를 저장하는 한 가지 방법입니다. 이는 클라이언트 컴퓨터 브라우저에 저장됩니다.\n\n데이터는 도메인별로 저장되며, 동일한 도메인을 가진 페이지만이 데이터에 액세스하고 수정할 수 있습니다. 다른 도메인의 페이지는 서로의 데이터에 액세스할 수 없습니다. 이는 브라우저 저장소 보안 문제이며, 사실 도메인 및 서브도메인 간에 LocalStorage/SessionStorage/IndexedDB를 공유할 수 없습니다. 이는 \"동일 출처 정책\"의 일부입니다.\n\n# 왜 localStorage를 공유해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n내가 겪은 실제 예시 중 하나는 회사에서 개발하지 않은 마케팅 사이트의 데이터에 접근해야 했을 때였어요. 우리 회사에서 개발하지 않은 사이트는 저희 응용 프로그램 사이트와 다른 도메인에 호스팅되어 있었거든요.\n마케팅 사이트가 www.marketing.com 도메인에 있고, 저희 응용 프로그램이 다른 도메인인 www.app-site.com에 있었다고 해봅시다. 사용 사례는 분석 목적을 위해 이 두 사이트 간의 전체 사용자 이동을 저장하는 것이었어요. 사용자는 localStorage에 저장된 사용자 ID를 받았고, 그 여정 중 각 이벤트가 그 ID와 함께 기록되었어요. 저는 도메인 간에 localStorage를 공유할 수 있는 방법이 필요했어요.\n\n# 어떻게 해결할까요?\n\nA 도메인이 www.aaa.com이고 B 도메인이 www.bbb.com일 때, B 도메인이 A 도메인의 localStorage를 읽고 쓸 수 있도록 하고 싶다고 해봅시다.\n\n## 요약\n\n<div class=\"content-ad\"></div>\n\n- 도메인 B에 있는 Iframe을 사용하여 도메인 A에서 작은 HTML을로드합니다.\n- 각 도메인(domain B 및 도메인 A의 Iframe)에서 리스너를 설정하고 postMessage를 통해 통신합니다.\n- 도메인 A는 localStorage에서 데이터를 가져와 메시지로 보냅니다.\n\n![이미지](/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_1.png)\n\n## 다른 localStorage에 쓰기\n\n먼저 도메인 B에 Iframe을 생성하고 도메인 A에서 작은 HTML 파일을로드하도록합니다. Iframe 스타일에는 높이, 너비 및 테두리가 없습니다. 또한 절대 위치에 떠 있습니다. DOM의 자연 흐름에 차지되지 않도록하기 위함입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// www.bbb.com\n<iframe id=\"iframe\" src=\"www.aaa.com/external.html\" onload=\"onMyFrameLoad()\"  style=\"width:0;height:0;border:none;position:absolute;\"></iframe>\n```\n\n그리고 도메인 A에서 호스팅된 작은 HTML 파일을 만들어서 리스너를 설정합니다:\n```js\n// www.aaa.com/external.html\n<html>\n    <head>\n      <script>\n          window.addEventListener('message', (message) => {\n            if (message.origin === 'http://www.bbb.com') {\n              const data = JSON.parse(message.data);\n              const { userId } = data;\n              if (userId){\n                localStorage.setItem('userId', userId);\n              }\n            }\n          });\n      </script>\n    </head>\n</html>\n```\n\n이제 도메인 A는 도메인 B로부터 userId와 같은 데이터가 포함된 메시지를 받을 준비가 되었습니다. 이 데이터를 localStorage에 저장합니다. 이 스크립트는 www.aaa.com 아래에 있음을 기억하세요. Iframe에 포함되어 있더라도 여전히 도메인 A의 localStorage를 사용합니다. 사용자가 도메인 B에서 도메인 A로 이동할 때, 우리는 이미 데이터를 갖고 있을 것입니다. 왜냐하면 도메인 B가 메시지를 보내고 도메인 A가 해당 데이터를 localStorage에 저장했기 때문입니다. 중요한 보안 점검으로 message.origin을 먼저 확인하는 것을 잊지 마세요! 우리는 익숙하지 않은 출처의 메시지에 응답하고 싶지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\n우리는 실제로 도메인 B에서 postMessage를 통해 메시지를 보내야 합니다. 이를 위해 Iframe의 onMyFrameLoad 함수 코드를 추가합니다:\n\n```js\n// www.bbb.com\n<script>\n  function onMyFrameLoad() {\n    var userId = getUserId();\n    var data = {userId: userId};\n    var iframeEl = document.getElementById(\"myIframe\");\n    iframeEl.contentWindow.postMessage(JSON.stringify(data), 'www.aaa.com');\n  };\n</script>\n\n<iframe id=\"iframe\" src=\"www.aaa.com/external.html\" onload=\"onMyFrameLoad()\"  style=\"width:0;height:0;border:none;position:absolute;\"></iframe>\n```\n\nIframe가로드 된 후에 onMyFrameLoad 함수가 실행되어야 하는 것이 중요합니다. 즉, onload에서 호출해야 합니다. 메시지를 보내기 전에 다른 쪽에서 이벤트 리스너를 추가해야 합니다.\n\n그래서 모든 것을 설정했습니다. 사용자가 도메인 B에 도달하면 Iframe이 로드되고, 그런 다음 도메인 A의 external.html이 호출되어 메시지를 위한 리스너를 설정합니다. 도메인 B는 이후 userId를 도메인 A로 전송할 postMessage를 실행한 후, 그것이 localStorage에 저장될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 반대 방향\n\n이제 사용자가 처음에 도메인 A를 방문한 경우를 고려해 봅시다. 우리는 도메인 A의 로컬 저장소에 저장된 사용자 ID와 같은 데이터를 도메인 B와 공유하고 싶습니다.\n\n이를 위해 외부.html에 이 데이터가 이미 있는지 확인하는 if 문을 추가해야 합니다. 데이터가 있는 경우, 도메인 B에게 postMessage를 보냅니다. 그렇지 않으면, 도메인 B가 데이터를 보내기를 대기합니다.\n\n```js\n// www.aaa.com/external.html\n<html>\n    <head>\n      <script>\n            const userId = localStorage.getItem('userId');\n            if (userId) {\n              const data = {userId: userId};\n              parent.postMessage(JSON.stringify(data), \"http://www.bbb.com\")\n            }\n            else {\n              window.addEventListener('message', (message) => {\n                if (message.origin === 'http://www.marketing.com') {\n                  const data = JSON.parse(message.data);\n                  const { userId } = data;\n                  if (userId){\n                    localStorage.setItem('userId', userId);\n                  }\n                }\n              });       \n            }  \n      </script>\n    </head>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n알림: 이제 postMessage는 iframe 요소가 아니라 부모의 속성입니다. 이는 iframe이 포함되어 있을 때 해당 window이 로드를 담당하는 부모 객체이기 때문입니다.\n\n그리고 도메인 A와 유사하게, 도메인 B에서 듣는 리스너를 추가할 것입니다.\n\n```js\n// www.bbb.com\n<script> \n    window.addEventListener('message', function(message) {\n    if (message.origin === 'wwww.aaa.com') {\n      var data = JSON.parse(message.data);\n      var userId = data.userId;\n      if (userId){\n        doSomethingWithTheData()\n      }\n    }\n  });\n</script>\n\n<script>\n  function onMyFrameLoad() {\n    var userId = getUserId();\n    var data = {userId: userId};\n    var iframeEl = document.getElementById(\"myIframe\");\n    iframeEl.contentWindow.postMessage(JSON.stringify(data), 'www.aaa.com');\n  };\n</script>\n\n<iframe id=\"myIframe\" src=\"www.aaa.com/external.html\" onload=\"onMyFrameLoad()\"  style=\"width:0;height:0;border:none;position:absolute;\"></iframe>\n```\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n우리는 localStorage에 저장된 데이터를 다른 도메인과 iframe을 사용하여 postMessage를 통해 공유할 수 있다는 것을 알았어요.\n\n이것은 물론 2개의 도메인 간에 정확히 공유하려는 매개변수에 대한 합의가 있는 구체적인 사용 사례에 적합합니다. 우리는 거의 없지만 교차 도메인 스토리지 규칙을 어길 용의가 있는 몇 가지 사용 사례가 있으므로, 당신의 경우가 적합한 사용 사례인지 신중히 생각해야 해요.","ogImage":{"url":"/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png"},"coverImage":"/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png","tag":["Tech"],"readingTime":6},{"title":"HTMX와 Express.JS를 이용해 얼굴 인식 기능 추가하기","description":"","date":"2024-05-01 23:54","slug":"2024-05-01-IntegratingFaceIOusingHTMXandExpressJS","content":"\n\n요즘 빠르게 발전하는 디지털 시대에는 보안과 사용자 경험이 중요한 고려 사항이며, 견고한 인증 솔루션을 찾는 노력이 더 커지고 있습니다. 암호와 같은 전통적인 방법은 더 많은 위협에 노출되고 사용자 불만을 증가시키므로 대체 메커니즘에 대한 탐구가 증가하고 있습니다. 얼굴 인증은 보안과 사용자 경험을 결합한 유망한 솔루션이 되어 나타났습니다.\n\n이 기사는 얼굴인식을 웹 애플리케이션에 쉽게 통합할 수 있는 FACEIO와 HTMX, Express.js의 융합을 탐구합니다. HTMX의 동적 기능과 Express.js의 견고함을 활용하여 이 통합은 웹 인증을 혁신하고 안전하고 사용자 친화적인 경험을 제공할 것으로 약속합니다. 실용적인 예제와 통찰을 통해, 이 융합이 개발자들에게 보안 및 사용자 만족도를 향상시키는 정교한 인증 시스템을 만들 수 있는 능력을 부여하는 방법을 살펴보겠습니다.\n\n![faceio](/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png)\n\nFaceIO 개요\n\nFACEIO는 원활한 통합과 실시간 이벤트 알림을 위한 포괄적인 API 및 Webhooks 기능을 제공합니다. API를 통해 개발자들은 애플리케이션을 관리하고 등록 및 인증과 같은 작업을 수행하고 분석을 수집할 수 있습니다. 이는 HTTP를 통해 작동하여 모든 요청에 대해 표준 응답 코드를 제공하고 JSON을 반환합니다. API 키를 FACEIO 콘솔을 통해 관리하여 안전한 액세스가 보장됩니다. Webhooks는 등록 및 인증과 같은 이벤트에 대한 실시간 알림을 가능하게 합니다. 이벤트가 트리거될 때, FACEIO는 사용자 ID, 이벤트 유형, 타임스탬프 및 IP 정보와 같은 이벤트 세부 정보가 포함된 HTTP POST 요청을 구성된 URL로 보내어 적시에 백엔드 업데이트와 적극적인 대응을 용이하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n![](https://miro.medium.com/v2/resize:fit:1400/1*Nc0gNijxAiCVb3-UfHcQSQ.gif)\n\nHTMX에 대한 간단한 설명\nHTMX는 HTML에서 브라우저 기능에 직접 액세스하여 JavaScript와 클라이언트-서버 통신 관리의 필요성을 줄이는 방식으로 웹 개발을 간소화합니다. 클라이언트 측 렌더링 기능을 통해 전체 페이지 새로고침을 최소화하여 웹 앱의 반응성을 향상시킵니다. HTMX는 hx-get 및 hx-post와 같은 직관적인 HTML 속성을 통해 폼 제출 및 실시간 업데이트와 같은 기능을 용이하게 지원합니다.\n\nHTMX와 FaceIO 통합\nFaceIO를 HTMX와 통합하는 것은 웹 애플리케이션에서 원활한 얼굴 인증을 가능하게 하는 여러 단계로 이뤄집니다. 아래는 이 통합 프로세스를 보여주는 주요 단계와 코드 샘플입니다:\n\n![](/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_1.png)\n\n<div class=\"content-ad\"></div>\n\nFaceIO 설정하기\nFaceIO 콘솔에서 FaceIO 애플리케이션의 공개 ID를 가져옵니다.\n웹 애플리케이션에서 FaceIO 얼굴 인식 엔진을 초기화합니다.\nFaceIO를 설정하는 샘플 코드:\n\n```js\n<head>\n  <script src=\"https://cdn.faceio.net/fio.js\"></script>\n  <script>\n    // 공개 ID로 FaceIO를 초기화합니다\n    const faceIO = new FaceIO('YOUR_PUBLIC_ID');\n  </script>\n</head>\n```\n\nHTMX 통합하기\nHTMX 라이브러리를 HTML에 스크립트 태그를 포함하여 프로젝트에 추가합니다.\nHTMX 속성을 활용하여 동적 상호작용을 정의하고, 예를 들어 버튼 클릭 시 FaceIO 인증을 트리거할 수 있습니다.\nHTMX를 통합하는 샘플 코드:\n\n```js\n<head>\n  <script src=\"https://cdn.jsdelivr.net/npm/htmx.org@1.6.1/dist/htmx.min.js\"></script>\n</head>\n<body>\n  <!-- 버튼 클릭으로 FaceIO 인증 트리거하기 -->\n  <button hx-get=\"/authenticate\" hx-trigger=\"click\">FaceIO로 인증하기</button>\n</body>\n```\n\n<div class=\"content-ad\"></div>\n\nNode.js와 Express를 사용하여 서버 측 엔드포인트 만들기\nFaceIO 인증 요청을 처리하기 위한 서버 측 엔드포인트를 정의하십시오.\nFaceIO API와 상호 작용하여 얼굴 인식을 기반으로 사용자를 인증하는 서버 측 로직 구현하기\n\n```js\nconst express = require('express');\nconst app = express();\n\n// FaceIO 인증을 처리하는 엔드포인트\napp.get('/authenticate', async (req, res) => {\n  try {\n    // 얼굴 인증을 수행하기 위해 FaceIO API 호출\n    const authenticationResult = await faceIO.authenticate();\n\n    // 인증 결과 처리 (예: 액세스 부여 또는 오류 메시지 표시)\n    res.send(authenticationResult);\n  } catch (error) {\n    // 오류 처리 (예: 오류 메시지 기록 또는 오류 응답 반환)\n    res.status(500).send('내부 서버 오류');\n  }\n});\n\n// 서버 시작\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`포트 ${PORT}에서 서버 실행 중`);\n});\n```\n\n원활한 인증 경험 설계하기\n사용자 인터페이스를 맞춤 설정하여 FaceIO 인증 프로세스 중에 피드백을 제공하기\n서버로부터의 인증 응답을 처리하여 UI를 그에 맞게 업데이트하기\n인증 결과에 따라 UI를 업데이트하는 샘플 코드:\n\n```js\n<script>\n  async function authenticateWithFaceIO() {\n    try {\n      // HTMX를 통해 FaceIO 인증 수행\n      const response = await hx.get('/authenticate');\n\n      // 인증 결과에 따라 UI 업데이트\n      if (response.success) {\n        alert('인증 성공!');\n      } else {\n        alert('인증 실패. 다시 시도해주세요.');\n      }\n    } catch (error) {\n      console.error('오류:', error);\n    }\n  }\n</script>\n```\n\n<div class=\"content-ad\"></div>\n\n결론\n\n요약하자면, FaceIO를 HTMX와 Express.js와 통합하는 것은 웹 애플리케이션에서 보안을 강화하고 사용자 경험을 향상시키는 강력한 해결책을 제공합니다. FaceIO를 통해 얼굴 인증을 활용하고, HTMX가 제공하는 동적 HTML 상호작용과 Express.js의 강력한 백엔드 기능을 결합하여 개발자는 견고하고 사용자 친화적인 인증 시스템을 구축할 수 있습니다. 이 통합은 비밀번호 관련 위반 사례를 완화함으로써 보안 조치를 강화할 뿐만 아니라, 인증 프로세스를 간소화하여 원활하고 효율적인 사용자 경험을 조성합니다. FaceIO, HTMX 및 Express.js 간의 협업을 더 심층적으로 탐구함으로써, 웹 개발에서 혁신적인 발전을 이루며 안전하고 동적인 애플리케이션이 접근 가능하면서도 최고의 개인 정보 보호와 사용 용이성 기준을 유지할 수 있도록 합니다.","ogImage":{"url":"/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png"},"coverImage":"/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러로 웹사이트 만들 때 캐시 함정을 피하는 방법","description":"","date":"2024-05-01 23:52","slug":"2024-05-01-AvoidcachetrapwhenservingAngularapp","content":"\n\n![이미지](/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png)\n\n가장 이상한 버그 중 하나는 대규모 디자인 변경 후 발생했어요. 매일 아침마다 문제가 생기는 건데, 왜 그런 걸까요? 이 기사 제목을 보셨으니 이미 캐시와 관련이 있다는 건 알겠죠. 그렇다면 이런 문제가 왜 발생하는 걸까요, 그리고 어떻게 예방할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n우리는 모두 캐시를 좋아합니다, 맞지요? 캐시는 앱을 더 빨리 로드하는 데 도움을 주고, 서버로부터 일부 부하를 줄여 주며, 사용자들이 우리 앱에서 좋은 사용자 경험을 느낄 수 있도록 합니다.\n\n하지만 때로는 이 캐시가 우리에게 반대로 작용하고 사용자들이 앱의 최신 버전을 얻지 못하도록 할 수 있습니다. 이는 아마도 서버의 잘못된 캐시 구성 때문인 경우가 많습니다.\n\n우리 Angular 애플리케이션에서 캐시 문제를 피하고 앱 버전 관리하기 위해서, 우리가 ng build --prod로 프로덕션용 앱을 빌드할 때 Angular는 (기본적으로) 우리의 js 파일에 해시를 추가하고 index.html 파일을 해시 파일을 참조하도록 업데이트합니다. 새 버전을 배포하면 해시 키가 변경되고 사용자가 사이트를 다시 요청하면 index.html은 서버에서 새 파일을 로드하도록 요청합니다. 브라우저에는 이러한 파일이 캐시되어 있지 않기 때문에 서버에서 파일을 받아옵니다.\n\n그래서 Angular 덕분에 문제가 해결됐다고 할 수 있을까요? 음, 완전히 그렇지는 않습니다. 문제는 index.html 파일이 캐시될 때 발생합니다. 새로운 앱 버전을 디플로이했고 정적 파일과 index.html 파일이 캐시되어 있는 상황에서 사용자가 메인 URL에서 앱을 시작하면 캐시된 index.html은 이전 js 파일을 로드하도록 요청할 것이고, 이 파일들은 브라우저 캐시로부터 로드될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 시나리오를 계속 진행하면서 약간 복잡해집니다. 사용자는 우리 앱을 사용하며(기억하세요 - 이전 버전으로), 화면 간 이동을 하고 몇 가지 작업을 합니다. 어느 시점에서 새로고침을 하기로 결정했는데, 이제 새 앱 버전을 받게 되었습니다.\n\n기다려주세요, 새 버전? 하지만 왜요? index.html이 캐시에 있고, 왜 새 버전을 받고 있을까요? 이는 SPA를 서버에서 제공할 때 리다이렉트하는 방식과 관련이 있습니다.\n\nSPA는 클라이언트 측에서 앱 내비게이션을 처리하며, Angular 라우터를 통해 새 경로로 이동할 때마다 주소 표시줄의 URL을 동적으로 변경합니다. 사용자가 브라우저 주소 표시줄에 앱의 루트를 입력하고, 예를 들어 https://some-domain.com/home을 입력하고 엔터를 클릭하면, 실제로 서버에 이 루트가 없지만, 404를 반환하는 대신 서버에서 index.html을 반환하도록 구성되어 있습니다. Angular 라우터가 작업을 수행하고 사용자를 올바른 화면으로 이동시킵니다.\n\n이제 우리 시나리오에서 무슨 일이 일어나고 있는지 이해할 수 있습니다. 메인 URL에서 앱에 접속하면 캐시에 이 엔드포인트가 있기 때문에 이전 버전을 받게 됩니다. 그러나 특정 경로를 요청하는 경우, 항상 서버에서 index.html을 받고 캐시에서가 아닌 새 버전을 보게 됩니다 - 따라서 새로 고침 후에 새 버전이 나타날 것입니다.\n\n<div class=\"content-ad\"></div>\n\n좋죠, 그렇죠? 덕분에 캐시에 있는 하나의 index.html 때문입니다.\n\n## index.html 파일이 캐시되었는지 확인하는 방법\n\nindex.html 파일이 캐시되어 있는지 확인하는 것은 매우 쉽습니다.\n\n- 브라우저 개발 도구를 엽니다.\n- 네트워크 탭으로 이동합니다.\n- 캐시 사용 확인란이 선택되지 않았는지 확인합니다.\n- 문서로 필터링합니다.\n- 화면을 새로 고칩니다.\n- 첫 번째 문서를 클릭합니다.\n- 캐시 제어 헤더를 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어 angular.io/docs 사이트를 살펴봅시다:\n\n![이미지](/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_1.png)\n\n캐시 제어 헤더를 보면 no-cache로 설정되어 있습니다. 캐시 제어 헤더에서 어떤 값이 우리에게 좋은지 알아봅시다.\n\n- no-cache — 이 값을 사용하면 index.html 파일이 캐시되지만, 캐시 시스템이 서버에 더 새로운 버전이 있는지 확인하도록 합니다. 우리에게 적합합니다.\n- no-store — 이 값을 사용하면 캐시 시스템이 index.html 파일을 캐시하지 않도록 합니다. 좋은 방법입니다.\n- max-age=0 — 이 값 또한 index.html을 캐시하지 않습니다.\n- max-age=31536000 — 이 값은 좋지 않습니다. max-age의 값은 초로 표현되며, index.html이 1년 동안 캐시됩니다. 어떤 값이 적합한지는 본인의 의견에 따라 다를 수 있지만, index.html을 1년 동안 캐시하고 싶지 않을 것이라는 점에 동의할 수 있을 것 같습니다.\n\n<div class=\"content-ad\"></div>\n\n그것들은 cache-control 헤더에 대한 인기있는 값들이에요; 응답에서 다른 것을 본다면, 여기서 확인해보실 수 있어요.\n\n## cache-control 헤더를 제공하지 않았을 경우에는 어떻게 될까요?\n\n음, 지금은 \"무인도\" 영역에 있다고 할 수 있어요.\n\n![이미지](/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_2.png)\n\n<div class=\"content-ad\"></div>\n\n이 문구는 w3.org 섹션 13.2.2에서 인용한 것입니다:\n\n여기서 몇 가지 종류의 캐시를 언급하는 것이 좋을 것 같습니다. 우리 브라우저의 캐시는 우리 브라우저에서만 우리에게 서비스하는 개인 캐시입니다. 그러나 여러 가지 가능성으로 사용자 간에 공유되는 공개 캐시도 있습니다: 프록시 캐시, 게이트웨이 캐시, CDN, 역방향 프록시 캐시 및 로드 밸런서 등이 있습니다.\n\n따라서, 우리는 indx.html을 캐시하는 방법에 대한 구체적인 지시를 제공하지 않았을 때 어떻게 캐시를 처리해야 하는지에 대한 명세가 없음을 이해했습니다. 기본적으로 모든 캐시나 브라우저는 우리가 제공하거나 제공하지 않는 다른 헤더에 기반한 자체 알고리즘을 적용하고 여전히 index.html을 캐시 할 수 있습니다. 게다가, 이러한 종류의 것들은 테스트할 수 없습니다. 사용자들이 사설 네트워크나 캐시 알고리즘을 적용하는 ISP에서 앱에 접속할 수 있으며 당신은 그 사실조차 알지 못할 수 있습니다. 이것이 W3가 적용을 권장하는 이유입니다. 우리가 명시적인 만료 시간을 제공하도록 하는 것입니다.\n\n따라서, index.html에 올바른 캐시 제어 헤더가 함께 제공되는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n## 캐시 함정\n\ncached index.html의 실제 문제는 캐시에 이미 파일을 받은 사용자들이 캐시된 파일로 갇혀 있을 수 있는 점입니다. 이 상황이 해결되는 방법은 두 가지 중 하나가 발생할 때까지 기다려야 합니다:\n\n- 사용자가 캐시를 수동으로 지우는 경우(브라우저 캐시에 파일이 캐시된 경우를 가정함).\n- 캐시 만료일이 도래하는 경우.\n\n걱정하지 마세요; 이러한 index.html 문제는 상당히 드뭅니다. 대부분의 호스팅 서비스들은 기본적으로 오랜 캐시 구성이 있는 정적 파일을 제공하지 않습니다. 그러나 Angular 앱을 제공하는 서버가 이미 존재하고 동적 파일을 제공하는 경우에는 이 문제가 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## index.html 폼이 캐싱되는 것을 방지하는 방법\n\n아마도 HTML 메타 태그로 캐시를 제어하려고 시도하라는 StackOverflow 답변을 몇 가지 찾을 수 있을 겁니다. 심지어 이를 테스트해 볼 수 있고, 브라우저에서 작동할 수도 있습니다. 하지만 좀 더 조사해 보면, 이는 캐시를 방지하는 효과적인 방법이 아님을 알게 될 것입니다. 이러한 태그들은 일부 브라우저에 의해 존중될 수 있지만 다른 유형의 캐시에는 존중되지 않을 수 있습니다.\n\n가장 좋은 방법은 서버의 index.html에 캐시 제어 헤더를 설정하는 것입니다. 이를 위해 서버 구성에 일부 변경이 필요하지만 이것이 캐시를 방지하는 가장 간단하고 효과적인 방법입니다.\n\n## 서비스 워커를 사용하고 있어요; 모두 좋아요!\n\n<div class=\"content-ad\"></div>\n\n죄송하지만 아니에요.\n\nangular.io의 예제에서 서비스 워커에서 서비스되는 파일을 주목했을 수 있습니다. 그러나 Angular 팀은 여전히 이 파일을 캐시 제어=no-cache 헤더와 함께 서버에서 보냅니다.\n\n서비스 워커는 멋져요! 풀 컨트롤을 제공하는 동시에 파일을 캐싱합니다. 그러나 이전에 언급한 대로 몇 가지 캐시 유형이 있죠. 서비스 워커는 그 중 하나일 뿐입니다. 요청이 통과하는 레이어 중 하나인 서비스 워커는 HTTP 캐시(브라우저 캐시)나 공용 캐시는 대신하지 않습니다. 서비스 워커가 서버에서 파일을 가져오기로 결정하면 브라우저는 여전히 해당 헤더를 확인하여 캐시에서 제공할지 여부를 결정할 것입니다.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n몇 가지 캐시 문제는 디버그하기 어렵고 재현하기 어렵며 쉽게 코드 문제로 오해될 수 있습니다. 보통 우리 앱의 최종 사용자로부터 발생하며 새 버전을 얼마나 자주 릴리스하는지에 따라 달라집니다. 일부 사용자는 문제가 있다고 신고하지 않을 수도 있고, 그냥 \"새로고침하면 사라지는 이상한 동작\"으로만 설명할 수도 있습니다.\n\n우리 모두는 사용자들을 위해 최상의 경험을 원합니다 — 자신이 확신이 없다면, 오늘은 캐시를 확인해보세요! 😏","ogImage":{"url":"/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png"},"coverImage":"/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png","tag":["Tech"],"readingTime":5},{"title":"Figma 디자인을 HTML과 CSS로 변환하는 플러그인 10가지","description":"","date":"2024-05-01 23:51","slug":"2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/0*63WG6R0wvA90tl3C.gif)\n\n요즘 디지털 세상에서 온라인 애플리케이션은 인터넷 생활을 이끌기 위한 필수 구성 요소 중 하나입니다. 그러한 애플리케이션을 만드는 것은 더 많은 노력이 필요합니다. 디자인부터 개발까지, 작업이 복잡했던 반면, 디자이너와 개발자 간의 협업은 특히 디자인 제품을 만들 때 항상 도전이었습니다.\n\nFigma 및 그 플러그인들은 전체 제품을 처음부터 수동 코드로 작성하는 과정과 같은 모든 소음을 제거하는 단일 소스로 나타났습니다. 따라서, 여기에서는 Figma 디자인을 HTML 및 CSS 코드 스니펫으로 변환하여 디자인부터 코드로의 여정을 이전보다 훨씬 원활하게 만들어주는 최고의 15가지 Figma 플러그인을 소개합니다.\n\n# 디자인을 HTML 및 CSS 코드로 변환하는 최고의 10개 Figma 플러그인\n\n<div class=\"content-ad\"></div>\n\n- 제플린\n\n![제플린](https://miro.medium.com/v2/resize:fit:1400/0*7-PK7dTGINR7K4O6.gif)\n\n제플린은 디자이너와 개발자 양쪽 모두에게 최고의 도구 중 하나입니다. 이 도구는 협업 작업을 간단화할 뿐만 아니라 Figma 디자인 및 요소를 픽셀 완벽한 CSS 및 HTML 스니펫으로 변환합니다. 가장 좋은 점은 생성된 코드를 수동 편집 없이 개발 프로세스에 직접 구현할 수 있다는 것입니다. 제플린을 사용하면 개발 프로세스를 더 효과적이고 생산적으로 더욱 촉진할 수 있습니다.\n\n2. Anima\n\n<div class=\"content-ad\"></div>\n\n\n![Anima](https://miro.medium.com/v2/resize:fit:1400/0*jCye8_4bx0e-doVR.gif)\n\n애니마(Anima)는 다른 유명한 도구로, 반응형 디자인을 통해 사용자 경험을 향상시키는 데 알려져 있습니다. 이 도구는 모든 요소를 서로 다른 화면 크기에 맞춰 유지함으로써 애플리케이션이 매력적이고 매력적으로 보이도록합니다. 사용자가 애플리케이션에 액세스할 때 화면 크기가 어떻게 되든 웹사이트가 일정하게 유지됩니다. 또한 Anima는 Figma 내에서 상호작용 및 애니메이션을 직접 결정하도록 하면서 모든 디자인에 대한 자동 HTML 및 CSS 코드를 생성합니다.\n\n3. Framer Web\n\n![Framer Web](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png)\n\n<div class=\"content-ad\"></div>\n\n프레이머 웹은 하나의 플러그인 내에서 세 가지 필수 코딩 측면을 제공하는 세 가지인-원 솔루션 툴입니다. 디자이너가 모델을 설계하고 프로토타입을 만들 수 있도록 도와주며, 개발자는 손쉽게 실행 가능한 HTML 및 CSS 코드로 변환할 수 있습니다. 이 모든 작업을 Figma와 프레이머 웹을 떠나지 않고 하나의 인터페이스에서 수행할 수 있습니다. 만약 올인원 디자인, 프로토타입 및 코딩 도구가 필요하다면 이 플러그인을 선택해야 합니다.\n\n4. HTML to Figma\n\n![HTML to Figma](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_1.png)\n\nHTML to Figma은 외부 HTML 및 CSS 코드를 Figma로 가져올 수 있는 기능으로 구성되어 다른 디자인-코드 변환 방식과는 다릅니다. 디자이너와 개발자가 기존 코드베이스를 개선하기 위해 협업할 수 있습니다. 이를 통해 디자이너와 협력하여 개발 주기를 가속화시키고 코드의 수동 업데이트 필요성을 제거할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n5. Figma를 HTML로\n\n![Figma to HTML](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_2.png)\n\nFigma를 HTML로 변환하여 개발 과정을 가속화할 수 있습니다. 이 플러그인은 Figma 디자인을 HTML 및 CSS 코드 조각으로 변환하여 코드가 반응형임을 보장합니다. 세부 사항에 주의를 기울이는 이 플러그인을 사용하면 프로젝트를 더 정확하고 효율적으로 만들 수 있습니다. 게다가 코드가 이미 반응형이므로 사용자 경험을 향상시킬 수 있습니다.\n\n6. Koncept\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*vdRtH-uxMhPYHYXX.gif)\n\nKoncept은 디자인을 코드로 변환하는 프로세스를 넘어서는 포괄적인 디자인 및 프로토타이핑 플랫폼입니다. 깔끔하고 조직적인 HTML 및 CSS 코드 조각을 생성하여 개발 프로세스에서 직접 구현할 수 있는 기본 기능 외에도 플랫폼 내에서 애니메이션 및 상호작용을 정의할 수 있습니다.\n\n7. Auto-Layout to HTML\n\n![image](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_3.png)\n\n<div class=\"content-ad\"></div>\n\nAuto-Layout to HTML 플러그인은 반응형 디자인에 중점을 둡니다. Figma의 자동 레이아웃 기능을 활용하여 요소를 유연한 CSS Grid 또는 Flexbox 레이아웃으로 변환합니다. Auto-Layout to HTML은 자동 레이아웃 기능에 의존하기 때문에 버튼은 텍스트에 따라 크기가 조절되고, 목록은 항목과 함께 재배열되며, 복잡한 인터페이스를 생성할 수 있습니다. 컨텐츠에 반응하는 웹사이트를 만들 수 있습니다. PixelPerfect은 Figma 디자인과 생성된 HTML 및 CSS 코드 간의 정확도를 높입니다. 번역된 코드는 완벽할 정도로 정확하여 실행된 코드가 Figma 디자인과 똑같은 결과를 제공합니다. 이 플러그인은 변환 프로세스 중에 디자인 일관성을 유지하는 데 안성맞춤입니다.\n\n<div class=\"content-ad\"></div>\n\n9. CSS Scan\n\n![CSS Scan](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_4.png)\n\nCSS Scan은 작은 수정 사항이 있는 동일한 디자인 세트에서 작업할 때 도와주는 시간을 절약하는 도구입니다. 코드에서 정확한 색상, 글꼴 크기 및 기타 스타일을 복제할 때 어떤 요소에서도 CSS 값들을 직접 추출할 수 있습니다. 몇 번의 클릭으로 모든 작업을 완료할 수 있어서 지루한 색상 코드를 기억할 필요도 없습니다.\n\n10. Figmify\n\n<div class=\"content-ad\"></div>\n\n![figmify](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_5.png)\n\n디자인에 복잡한 상호 작용이나 애니메이션이 필요하지 않은 경우 Figmify가 최적의 선택일 수 있습니다. 몇 번의 클릭으로 Figmify가 Figma 디자인을 깔끔한 HTML 및 CSS 코드 조각으로 변환하도록 자동화할 수 있습니다.\n\n# 요약:\n\n애플리케이션을 구축하는 것은 어렵습니다. 특히 디자이너와 개발자 간의 적절한 협력이 없을 때입니다. 이 모든 것을 연결하는 과정에서 Figma는 개발 프로세스를 용이하게 해주는 플러그인을 소개했습니다.\n\n<div class=\"content-ad\"></div>\n\n각 플러그인은 반응형 디자인부터 고급 상호 작용 프로토타이핑까지 다양한 기능을 제공하여 특정 요구 사항을 충족시킵니다. 이러한 플러그인을 사용하면 Figma 요소를 실행 가능한 HTML 및 CSS 코드로 변환하는 번거로운 작업을 완전히 제거할 수 있습니다. 넓은 Figma 커뮤니티를 탐험하고, 도전적인 디자인-코드 작업 프로세스를 향상시켜보세요!\n\nFigma의 기능과 업데이트를 보려면 Linkedin에서 팔로우하기를 잊지마세요.","ogImage":{"url":"/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png"},"coverImage":"/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png","tag":["Tech"],"readingTime":5},{"title":"실무에 적용하면 퇴근시간 단축하는 웹 스크래퍼 만들기","description":"","date":"2024-05-01 23:48","slug":"2024-05-01-BuildingaWebScraperforThreeCommonUseCases","content":"\n\n![이미지](/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_0.png)\n\n# 동기부여\n\n최근 지역 소매업체 웹사이트에서 새 노트북을 찾고 있었는데, 여러 페이지의 검색 결과를 통해 여러 노트북의 브랜드, 사양 및 가격을 수동으로 메모해야 했습니다(비교 목적). 이 매뉴얼한 방식에 대한 frustration을 파트너에게 털어놓자, e-커머스 웹사이트에서도 유사한 불만을 표현했습니다.\n\n그 후, 웹 스크래퍼를 사용하여 웹사이트의 내용을 구조화된(예: 테이블 형식) 데이터로 자동 변환하는 과정을 자동화하는 것에 대한 사례를 탐구했습니다. 본 문서는 다음 세 가지 일반적인 사용 사례에 대한 웹 스크래퍼의 실제 단계별 가이드를 제공합니다:\n\n<div class=\"content-ad\"></div>\n\n- 여러 페이지에 걸쳐 검색 결과를 반환하는 웹사이트를 찾을 때 (\"페이지별 검색\")\n- 수동으로 아래로 스크롤하여 더 많은 검색 결과를 반환하는 웹사이트를 찾을 때 (\"무한 스크롤\")\n- 웹사이트에 호스팅된 이미지를 다운로드할 때 (\"이미지 스크랩\")\n\n# 웹 스크레이핑에 대한 비 기술적 소개\n\n사용자가 웹사이트에서 만나는 대부분의 콘텐츠는 사실 HTML 코드의 출력물입니다. 이러한 코드는 일반적으로 모든 웹사이트가 따르는 일반 규칙과 함께 컴파일됩니다. 즉, 웹사이트의 '프론트엔드'에 사용자에게 표시되는 콘텐츠는 웹사이트의 HTML 코드의 관련 레이어를 쿼리하여 저장 및 다운로드할 수 있습니다.\n\n이 기사의 목적을 위해 사용된 웹 스크레이퍼는 주로 BeautifulSoup 및 Selenium 라이브러리를 사용하여 Python으로 개발되었습니다. 특히, BeautifulSoup 라이브러리는 웹사이트 뒤의 HTML 코드에서 데이터를 검색하고 쿼리하며 반환하는 기능을 제공하며, Selenium 라이브러리는 브라우저 자동화를 지원합니다(예: Google Chrome 또는 Firefox 브라우저에서 특정 작업 수행).\n\n<div class=\"content-ad\"></div>\n\n# 사용 사례 1: 페이지별 검색을 위한 웹 스크래퍼\n\n이 사용 사례를 보여주기 위해 세포라 웹 사이트에서 \"파운데이션\"과 관련된 데이터를 스크래핑 할 것입니다 (비난하지 마세요). 다음과 같이 Python 라이브러리를 가져오는 것으로 시작할 것입니다.\n\n```js\nfrom bs4 import BeautifulSoup\nfrom selenium import webdriver\nimport pandas as pd # 데이터를 데이터프레임에 저장하기 위해\n```\n\n그런 다음 Google Chrome을 사용하여 검색 '페이지 1'에서 관심 있는 데이터를 스크래핑하려고 시도한 다음, For-Loop를 사용하여 다른 모든 페이지에 대해이 스크래핑을 구축할 것입니다. 각각 화장품 제품의 브랜드, 설명 및 가격을 스크래핑하기 위해 웹 사이트의 HTML 코드를 파이썬 객체인 soup_sephora로 구문 분석하기 시작할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n## Sephora 웹 사이트에서 \"파운데이션\"을 검색한 결과 페이지 1의 URL\nurl = \"https://www.sephora.com.au/search?q=foundation&page=1\"\n## 아래 옵션은 Chrome이 실제로 열리는 것을 방지합니다\noptions = webdriver.ChromeOptions()\noptions.add_argument('--headless')\n## chromedriver 다운로드 및 위치 지정\ndriver = webdriver.Chrome(\n                          executable_path = r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe',\n                          chrome_options = options\n                           )\ndriver.get(url)\n## HTML 코드 반환\nsoup_sephora = BeautifulSoup(driver.page_source, 'lxml')\n```\n\n저장된 HTML 코드 (soup_sephora 객체에 저장된)를 Microsoft Word나 메모장과 같이 검색 가능한 문서 유형에 붙여 넣는 것이 좋습니다. 이렇게 하면 관심 있는 데이터를 반환하기 위해 쿼리해야 할 속성을 식별하는 데 도움이 됩니다. 예를 들어, 페이지 1의 각 제품의 가격 속성은 HTML 구조에서 \"product-price\" 클래스에 저장되어 있으며, 특정 제품의 가격을 확인하기 위해 가격에 대한 \"CTRL+F\"를 수행하여 식별할 수 있습니다. 첫 번째 이미지에서 보이는 가격 $95의 YSL 파운데이션이 경우, 이는 두 번째 이미지에서 \"product-price\" 클래스 아래의 텍스트 문자열로 soup_sephora 객체에 포함되어 있으며, Microsoft Word 문서에서 \"$95\"를 검색하여 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_1.png\" />\n\n<img src=\"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n아래 코드는 파이썬 리스트에 페이지 1의 모든 제품의 가격을 반환합니다.\n\n```js\nsoup_sephora.findAll(class_ = \"product-price\")\n```\n\n위 내용을 고려하면, 검색 결과 페이지 1에 있는 모든 제품의 브랜드, 설명, 가격을 다음과 같이 판다스 데이터프레임에 저장할 수 있습니다.\n\n```js\nbrand = []\ndescription = []\nprice = []\nurl = \"https://www.sephora.com.au/search?q=foundation&page=1\"\noptions = webdriver.ChromeOptions()\noptions.add_argument('--headless')\ndriver = webdriver.Chrome(\n                                 executable_path = r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe',\n                                 chrome_options = options\n                                )\ndriver.get(url)\nsoup_sephora = BeautifulSoup(driver.page_source, 'lxml')\ni = 0\nfor item in soup_sephora.findAll(class_ = \"product-card-brand\"):\n    i = i + 1\n    brand.append(item.get_text(strip = True))\nfor item in soup_sephora.findAll(class_ = \"product-card-product\"):\n    i = i + 1\n    description.append(item.get_text(strip = True))\n            \nfor item in soup_sephora.findAll(class_ = \"product-price\"):\n    i = i + 1\n    price.append(item.get_text(strip = True))\ndriver.close()\n## 판다스 데이터프레임으로 변환\ndf_sephora = pd.DataFrame(\n                        {'브랜드': brand,\n                         '설명': description,\n                         '가격': price\n                        })\ndf_sephora.head(10)\n```\n\n<div class=\"content-ad\"></div>\n\n위의 판다 데이터프레임의 출력은 아래 이미지에서 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_3.png)\n\n'Price' 열은 할인이 적용된 제품과 관련하여 추가 정제가 필요할 수 있음을 유의해주세요.\n\n이후 페이지를 스크랩하기 위해서는 단순히 위의 코드를 For-Loop로 감싸고 아래와 같이 url 객체를 소프트 코딩하면 됩니다 (데이터프레임으로 열을 결합하기 전에).\n\n<div class=\"content-ad\"></div>\n\n```js\n## For-Loop에 페이지 수를 지정하기\nfor j in range(1, 페이지 수):\n    url = \"https://www.sephora.com.au/search?q=foundation&page=\" + str(j)\n    **페이지별 크롤링 관련 코드 삽입**\n             .\n             .\n             .\n```\n\n# 사용 사례 2: 무한 스크롤용 웹 스크레이퍼\n\n무한 스크롤은 사용자가 페이지를 스크롤할 때 더 많은 콘텐츠를 로드하는 웹사이트 디자인으로, 페이지 이동을 클릭하지 않고 자동으로 더 많은 콘텐츠를 로드합니다. 이로 인해 Use Case 1용으로 작성된 For-Loop가 다소 유용하지 않을 수 있습니다.\n\n그러나 무한 스크롤은 더 스크롤하는 모션을 흉내 내는 웹 스크레이퍼로 자동화할 수도 있습니다. 이를 위해 스크레이퍼에게 먼저 전체 웹페이지 길이만큼 스크롤하도록 지시하고, 컨텐츠가 로드되기를 기다린 후 몇 초 동안 기다린 후 다시 전체 페이지 길이만큼 스크롤하여 무한 스크롤의 끝에 도달한 후 HTML 코드를 Python 객체로 파싱할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 사용 사례를 보여주기 위해, \"가방\" 검색과 관련된 Acne Studio 웹사이트에서 데이터를 스크래핑할 것입니다.\n\n필요한 Python 라이브러리는 대부분 Use Case 1과 일치하며 다음 추가 사항이 있습니다:\n\n```js\nimport time ## 대기 시간 설정에 사용\nfrom urllib.parse import urljoin ## url을 위한 문자열 결합에 사용\n```\n\n먼저 Google Chrome을 시작하고 Use Case 1에 기반해 URL을 설정하고 \"스크롤, 몇 초 대기한 후 다시 스크롤\" 이동 순서를 다음과 같이 지정합니다.\n\n<div class=\"content-ad\"></div>\n\n```python\noptions = webdriver.ChromeOptions()\noptions.add_argument('--headless')\ndriver = webdriver.Chrome(executable_path=r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe', chrome_options=options)\nurl_acne = \"https://www.acnestudios.com/au/en/search?q=bags\"\nprint(url_acne)\ndriver.get(url_acne)\ntime.sleep(2)  # 웹 페이지가 열리기까지 2초 기다립니다\nscroll_pause_time = 2  # 웹 페이지 로딩을 위해 2초 기다립니다\n\nscreen_height = driver.execute_script(\"return window.screen.height;\")  # 웹의 화면 높이 가져오기\ni = 1\nwhile True:\n   # 한 화면 높이씩 스크롤\n   driver.execute_script(\"window.scrollTo(0, {screen_height}*{i});\".format(screen_height=screen_height, i=i))\n   i += 1\n   time.sleep(scroll_pause_time)\n   # 각 스크롤 후 스크롤 높이 업데이트\n   scroll_height = driver.execute_script(\"return document.body.scrollHeight;\")\n   # 웹 페이지의 끝에 도달하면 루프 종료\n   if (screen_height) * i > scroll_height:\n       break\n```\n\nInfinite Scroll의 최하단에 도달했을 때, HTML 코드를 저장하고 Use Case 1과 동일한 방법으로 데이터를 다운로드할 수 있습니다. 이번 유스케이스에서는 각 핸드백의 설명, 가격 및 이미지 URL을 다운로드할 것입니다.\n\n```python\ndescription = []\nprice = []\nurl = []\nsoup = BeautifulSoup(driver.page_source, \"html.parser\")\nfor desc in soup.find_all(class_=\"product-tile__name\"):\n    \n    description.append(desc.get_text(strip=True))\n    \nfor desc in soup.find_all(class_=\"product-tile__price font--monospace\"):\n    \n    price.append(desc.get_text(strip=True))\n    \nfor item in soup.find_all(class_=\"tile__link\"):\n    \n    base = \"https://www.acnestudios.com/\"\n    link = item.attrs[\"href\"]\n    url_join = urljoin(base, link)\n    \n    url.append(url_join)\n## pandas 데이터프레임으로 변환\ndf_acne = pd.DataFrame(\n                        {\n                         'Description': description,\n                         'Price': price,\n                         'URL': url\n                        })\ndf_acne\n```\n\n데이터프레임 결과 샘플은 아래와 같습니다. Infinite Scroll이 없었다면 데이터프레임에는 아마 10개 정도의 기록만 포함되었을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_4.png\" />\n\n# 사용 사례 3: 이미지 스크래핑\n\n이미지 스크래핑은 웹사이트에 호스팅된 이미지를 다운로드하고 로컬 컴퓨터에 체계적으로 저장하는 자동화를 의미합니다. 이는 다음과 같은 이유로 유용할 수 있습니다:\n\n- 웹사이트에서 게시된 이미지가 나중에 제거될 수 있음\n- 다운로드한 이미지는 오프라인에서 다시 확인할 수 있음 (즉, 인터넷 없이)\n- 다운로드한 이미지는 더 포괄적인 방식으로 확인할 수 있음 (예: 특정 순서로 또는 명명 규칙에 따라)\n\n<div class=\"content-ad\"></div>\n\n이 사용 사례를 보여 주기 위해, MangaPark 웹 사이트에서 Manga 시리즈 아래의 모든 이미지를 스크랩하겠습니다. 개인 컴퓨터에 전체 Manga가 저장되어 있으면, 온라인에서 각 장에 대한 \"다음\" 버튼을 클릭하고 여러 개의 온라인 광고를 만나는 대신 Manga 페이지를 편리하게 넘길 수 있습니다.\n\n사용 사례 1과 2와 동일한 Python 라이브러리를 사용하여, 우리는 한 장의 이미지를 스크랩하기 위해 시작하고 For-Loop를 사용하여 다른 장의 이미지까지 스크랩해가는 작업을 확장합니다. 일본 Manga 시리즈 \"H2\"의 첫 번째 장에서:\n\n```js\nurl = \"https://v2.mangapark.net/manga/h2/i294558/c1\"\nprint(url)\noptions = webdriver.ChromeOptions()\noptions.add_argument('--headless')\ndriver = webdriver.Chrome( \n                          executable_path = r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe',\n                          chrome_options = options\n                         )\ndriver.get(url)\nsoup = BeautifulSoup(driver.page_source, 'html')\n## 장의 이미지 수는 다양하며, 오류 처리 덕분에\n## 인덱스 오류 없이 최대 50개까지 다운로드 가능함\n## 이미지는 시간순으로 H2 폴더에 저장됨\n## Python 스크립트가 저장된 경로에 저장됨\ntry:\nfor i in range(50):    \n        urllib.request.urlretrieve(str(soup.find_all(class_ = \"img\")[i].attrs[\"src\"]),\n                               \"H2/\" + str(i) + \".jpg\".format(i))\nexcept:\n    pass\n```\n\n위의 작업을 완료하면, \"다음\" 페이지의 URL을 찾고 위의 스크래핑을 반복하는 문제로 전환됩니다. 이 작업은 다음과 같이 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nurl = \"https://v2.mangapark.net/manga/h2/i294558/c1\"\nchapter_number = 338\nfor j in range(1, upper_limit + 1):\n      \n    print(url)\n    options = webdriver.ChromeOptions()\n    options.add_argument('--headless')\n    driver = webdriver.Chrome(\n                              executable_path = r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe',\n                              chrome_options = options\n                             )\n    driver.get(url)\n    soup = BeautifulSoup(driver.page_source, 'html')\ntry:\nfor i in range(50):    \n            urllib.request.urlretrieve(str(soup.find_all(class_ = \"img\")[i].attrs[\"src\"]),\n                                   \"H2/\" + str(j) + \"_\" + str(i) + \".jpg\".format(i))\nexcept: ## number of pictures may vary on a webpage\n        pass\n## 아래는 \"다음\" 페이지를 위한 URL을 찾습니다.\nbase_url = \"https://v2.mangapark.net/\"\n    next_page = soup.find_all(\"a\", href = True)[12].get(\"href\")\nurl = urljoin(base_url, next_page)\n```\n\n지금은 차 한 잔과 함께 H2 만화를 즐겨보세요! 정말 재미있어요.\n\n# 결론\n\n이 기사에서는 실행 가능한 코드로 웹 스크래핑의 세 가지 사용 사례를 소개했습니다. 이러한 사용 사례들은 쉽게 확장하여 웹사이트의 HTML 코드가 가지고 있는 추가 속성을 포함시킬 수 있습니다. 독자들이 자세히 살펴보면 됩니다!\n\n<div class=\"content-ad\"></div>\n\n다음으로, 행위 보험사/데이터 과학자 모자를 쓰고, 경쟁 업체 웹사이트의 변경 사항을 모니터링하거나 리뷰 웹사이트에서 고객의 긍정적/부정적 댓글을 스크래핑하는 등의 상업 기회를 탐색할 예정입니다. 계속 주목해주세요!","ogImage":{"url":"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_0.png"},"coverImage":"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_0.png","tag":["Tech"],"readingTime":11},{"title":"알아두면 쓸모있는 잘 알려지지 않은 HTML 태그들","description":"","date":"2024-05-01 23:47","slug":"2024-05-01-UnearthingHiddenGemsLesser-KnownHTMLTags","content":"\n\n![UnearthingHiddenGemsLesser-KnownHTMLTags](/assets/img/2024-05-01-UnearthingHiddenGemsLesser-KnownHTMLTags_0.png)\n\n웹 개발의 광활한 풍경 속에서 특정 HTML 태그들이 빛나며 주목을 받고 있습니다. 우리는 모두 `div`, `p`, `a`와 같은 태그를 알고 있지만, 마크업의 미천한 영웅들에 대해 얼마나 알고 계신가요? 함께 HTML의 심연을 탐험하며 주목할 만한 몇 가지 알려지지 않은 보석을 발굴해봅시다.\n\n- `details`와 `summary`: 확장 가능한 콘텐츠\n\n웹페이지에서 보충 정보를 숨겨야 할 때 토글이나 버튼으로 페이지를 혼동시키기만 했던 적이 있나요? `details`와 `summary`가 나타나는 순간입니다. 이러한 태그를 사용하면 쉽게 접어지는 콘텐츠 섹션을 만들 수 있습니다. 콘텐츠를 `details`로 감싸고 `summary` 내에서 간단한 요약을 제공하여 사용자가 한 번의 클릭으로 추가 세부 정보를 공개할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<details>\n  <summary>더 많은 정보를 확인하려면 클릭하세요</summary>\n  <p>여기에 추가 정보가 들어갑니다...</p>\n</details>\n```\n\n2. `time`: 의미론적 시간 표현\n\n날짜와 시간을 수동으로 형식화하는 것은 잊어버리세요. `time`은 대신 그 일을 해 줄 겁니다. 종종 간과되는 이 태그는 날짜와 시간을 의미론적으로 표현하는 방법을 제공하여 접근성과 검색 엔진 최적화를 향상시킵니다. 최대 호환성을 위해 ISO 8601 형식으로 datetime 속성을 지정하세요.\n\n```js\n<p>게시일 <time datetime=\"2024-04-29T08:00:00Z\">2024년 4월 29일</time></p>\n```\n\n<div class=\"content-ad\"></div>\n\n3. `cite`: 간편한 인용\n\n오남용 시대에 올바른 인용은 이제보다 중요합니다. 그러나 많은 사람들이 평범한 텍스트나 이탤릭체 대신 `cite` 태그를 무시합니다. 이 의미 있는 태그로 인용을 더욱 강조하여 작품의 제목이나 저자 이름을 나타내세요.\n\n```js\n<blockquote>\n  <p>\"지식은 힘입니다.\" <cite>프란시스 베이컨</cite></p>\n</blockquote>\n```\n\n4. `mark`: 텍스트 동적 강조\n\n<div class=\"content-ad\"></div>\n\n텍스트를 동적으로 강조하는 것은 적절한 도구 없이는 번거로울 수 있습니다. `mark`가 등장했습니다. 텍스트 일부를 `mark`로 감싸면 강조 효과가 적용되어 검색 결과나 중요한 용어를 강조하는 데 안성맞춤입니다.\n\n```js\n<p>검색 결과: Lorem <mark>ipsum</mark> dolor sit amet...</p>\n```\n\n5. `wbr`: 단어 나누기 기회\n\n복잡한 단어 구조가 있는 언어나 긴 URL에서 올바른 줄 바꿈을 보장하기 위해 `wbr`이 등장합니다. 이 태그는 브라우저에 어디에 줄 바꿈을 삽입해야 하는지 힌트를 줌으로써 가독성을 보장하면서 콘텐츠 무결성을 보존합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<p>중단이 필요한 긴단어<wbr>중단이 필요한 긴단어</p>\n```\n\n6. `fieldset`와 `legend`: 양식 요소 그룹화\n\n사용자 경험을 위해서 양식을 적절하게 구성하는 것이 중요합니다. 그런데 `fieldset`와 `legend`는 종종 눈에 띄지 않는다. `fieldset`를 사용하여 관련된 양식 요소를 함께 그룹화하고 `legend`를 사용하여 해당 그룹에 캡션 또는 제목을 제공하세요. 이렇게 하면 양식이 더 구조화되고 접근성이 향상됩니다.\n\n```js\n<fieldset>\n  <legend>연락 정보</legend>\n  <!-- 여기에 양식 요소를 넣으세요 -->\n</fieldset>\n```\n\n<div class=\"content-ad\"></div>\n\n7. `dialog`: 모달 대화 상자\n\n모달 대화 상자를 만드는 것은 예전에 JavaScript와 CSS를 사용하여 지루한 작업이었습니다. 하지만 걱정하지 마세요, `dialog`가 나타나서 이 프로세스를 간단하게 해 줍니다. 이 태그는 HTML 문서 내에 대화 상자나 창을 정의하여 팝업 알림, 경고 또는 상호 작용 프롬프트를 쉽게 만들 수 있게 합니다.\n\n```js\n<dialog open>\n  <p>이것은 모달 대화 상자입니다!</p>\n  <button onclick=\"this.parentNode.close()\">닫기</button>\n</dialog>\n```\n\n8. `meter`: 스칼라 측정값 시각화\n\n<div class=\"content-ad\"></div>\n\n특정 범위 내에서 측정 값을 표시해야 한다면 `meter`태그를 사용해보세요. 이 태그는 디스크 사용량, 다운로드 진행률 또는 주관적 등급과 같은 알려진 범위 내의 스칼라 측정 값을 나타냅니다. 필요에 맞게 값을, 최소값(min), 최대값(max) 속성을 사용자 정의할 수 있습니다.\n\n```js\n<meter value=\"0.6\" min=\"0\" max=\"1\">60%</meter>\n```\n\n9. `progress`: 작업 진행률 추적\n\n작업 진행률을 추적하는 것은 웹 응용프로그램에서 흔한 요구 사항입니다. `progress`태그를 사용하면 쉽게 할 수 있습니다. 이 태그를 사용하여 파일 업로드, 양식 제출 또는 로딩 화면과 같은 작업의 완료 진행률을 나타낼 수 있습니다. 현재 진행 상황을 나타내기 위해 값(value) 속성을 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n<progress value=\"50\" max=\"100\">50%</progress>\n```\n\n10. `samp`: 샘플 출력\n\n프로그램이나 코드 스니펫의 샘플 출력을 표시할 때 `samp` 태그를 사용하면 의미론적으로 더 좋습니다. 이 태그는 컴퓨터 프로그램에서의 샘플 출력을 나타내어 사용자 입력이나 프로그램 코드와 구분짓습니다.\n\n```js\n<p>출력: <samp>Hello, World!</samp></p>\n```\n\n<div class=\"content-ad\"></div>\n\n11. `abbr`: 약어 및 두문자어\n\n`abbr`를 사용하면 접근성과 명확성을 쉽게 향상시킬 수 있어요. 이 태그를 사용하여 약어와 두문자어를 표시하고, 보조 기술에서 접근 가능한 확장 또는 설명을 제공하세요.\n\n```js\n<p><abbr title=\"Hypertext Markup Language\">HTML</abbr>은 멋져요!</p>\n```\n\n12. `slot`: 콘텐츠 분배\n\n<div class=\"content-ad\"></div>\n\n웹 컴포넌트의 등장으로 `slot`이 점점 더 중요해지고 있어요. 이 태그는 웹 컴포넌트의 템플릿에 동적 콘텐츠를 삽입할 수 있는 자리 표시자를 정의하여 유연한 콘텐츠 배포와 조합을 가능케 해줘요.\n\n```js\n<my-custom-element>\n  <p slot=\"header\">헤더 내용</p>\n  <p slot=\"footer\">푸터 내용</p>\n</my-custom-element>\n```\n\n프로젝트에 종종 간과되는 HTML 태그들을 통합함으로써 기능을 향상시키고 접근성을 개선하며 개발을 더욱 간편하게 할 수 있어요. 기억하세요, HTML의 진정한 힘은 익숙한 태그뿐만 아니라 발견되고 활용되기를 기다리는 숨은 보석들의 가치에 있어요.","ogImage":{"url":"/assets/img/2024-05-01-UnearthingHiddenGemsLesser-KnownHTMLTags_0.png"},"coverImage":"/assets/img/2024-05-01-UnearthingHiddenGemsLesser-KnownHTMLTags_0.png","tag":["Tech"],"readingTime":4},{"title":"파이썬에서 HTML을 PDF로 변환하는 방법","description":"","date":"2024-05-01 23:45","slug":"2024-05-01-ConvertHTMLtoPDFinPythonStep-by-StepGuide","content":"\n\n요즘 디지털 시대에는 HTML 콘텐츠를 PDF 형식으로 변환해야 하는 일이 자주 있습니다. 보고서 생성, 웹 콘텐츠 보관, 인쇄 가능 문서 작성 등 다양한 목적으로 HTML을 PDF 파일로 변환해야 하는데, 이는 제 프로그래밍 도구상에서 중요한 기술이 되었습니다.\n\n다행히도 Python은 이 작업을 단순화시키는 강력한 라이브러리를 제공하여, 초보자를 포함한 모든 프로그래머들에게 접근하기 쉽게 만들어 주고 있습니다. 이 글에서는 Python을 사용하여 HTML을 PDF로 변환하는 과정을 안내해 드릴 것이며, 이를 통해 HTML 콘텐츠로부터 전문적으로 보이는 PDF 문서를 쉽게 생성할 수 있게 될 것입니다.\n\npdfkit 및 wkhtmltopdf와 같은 Python 라이브러리를 활용함으로써, 명령줄 도구인 wkhtmltopdf의 기능을 활용하면서도 Python 코드의 간편함과 유연성을 누릴 수 있었습니다.\n\n저는 이러한 라이브러리의 설치 및 구성을 안내하여, 모든 것을 올바르게 설정할 수 있도록 도와 드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n우리 환경이 준비되면 실제 변환 과정으로 들어가게 될 거에요. HTML 파일 또는 HTML 콘텐츠를 로드하고 아름다운 PDF 문서로 변환하는 방법을 보여드릴 거에요.\n\n하지만 여기서 우리의 여정은 끝나지 않아요. PDF 변환을 여러분의 특정한 요구에 맞게 맞춤화할 수 있는 다양한 사용자 정의 옵션도 살펴볼 거에요.\n\n여러분은 페이지 크기, 여백, 헤더, 풋터를 조절하는 방법과 CSS 스타일시트와 외부 에셋을 사용하여 PDF 렌더링을 향상시키는 방법을 배울 거에요.\n\n이미지와 외부 자원을 원활하게 처리할 수 있는 지식을 제공해 드릴 거에요, 이를 통해 여러분의 PDF가 원본 HTML 콘텐츠를 정확하게 반영할 수 있도록 도와드릴 거에요.\n\n<div class=\"content-ad\"></div>\n\n모든 프로그래밍 작업과 마찬가지로, 문제 해결은 과정에서 불가피한 부분임을 알고 있습니다. 안심하세요, 변환 과정 중에 발생할 수 있는 글꼴 문제나 렌더링 차이와 같은 잠재적인 어려움에 대처하고, 극복할 수 있는 실용적인 팁과 해결책을 제시해 드리겠습니다.\n\n더불어, 고급 주제를 탐구하고 실력을 더욱 향상시킬 수 있는 추가 자료들을 안내해 드리겠습니다.\n\n이 글을 마치면, 파이썬을 사용하여 HTML을 PDF로 손쉽게 변환하는 데 필요한 지식과 도구를 소유하게 될 것이라고 자신 있습니다.\n\n이 새로운 능력은 문서 생성을 자동화하고 응용 프로그램을 향상시키며, 시각적으로 매력적이고 전문적인 PDF 문서를 제작하는 데 창의성을 발휘할 수 있는 힘을 줄 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그러니 함께 HTML을 PDF로 변환하는 Python의 잠재력을 발휘해 보도록 하죠!\n\npdfkit 설치하기\n\npdfkit을 설치하고 파이썬 환경에 추가하려면 다음 코드 스니펫을 사용할 수 있어요:\n\n```js\npip install pdfkit\n```\n\n<div class=\"content-ad\"></div>\n\n명령 줄 인터페이스나 터미널에서이 명령을 실행하면 pdfkit 라이브러리의 설치 과정이 시작됩니다. pip는 Python의 패키지 관리자이며, Python 패키지 인덱스 (PyPI)에서 pdfkit을 자동으로 다운로드하고 설치합니다.\n\n설치가 완료되면 Python 프로젝트에서 pdfkit을 사용할 수 있게 됩니다. 이 라이브러리는 명령줄 도구 wkhtmltopdf를 편리하게 감싸는 역할을 하며, Python 코드를 사용하여 HTML을 쉽게 PDF로 변환할 수 있게 해줍니다.\n\npdfkit이 성공적으로 설치되면 HTML에서 PDF로 변환하는 프로세스의 다음 단계로 진행할 수 있습니다.\n\n아래 스크린샷을 참조해주세요.\n\n<div class=\"content-ad\"></div>\n\nwkhtmltopdf를 설치해보세요.\n\nwkhtmltopdf를 설치하려면 운영 체제에 따라 다음 지침을 따르세요.\n\nUbuntu:\n\n터미널을 열고 다음 명령을 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt-get install wkhtmltopdf\n```\n\n시스템 비밀번호를 요청하면 제공하고 설치가 진행됩니다.\n\nmacOS:\n\nHomebrew가 설치되어 있는 경우, 터미널을 열고 다음 명령어를 실행하십시오.\n\n<div class=\"content-ad\"></div>\n\n```js\nbrew install homebrew/cask/wkhtmltopdf\n```\n\n설치가 시작됩니다. Homebrew가 대신 처리해줄 거에요.\n\nWindows:\n\n- 공식 wkhtmltopdf 다운로드 페이지인 https://wkhtmltopdf.org/downloads.html을 방문해주세요.\n- Windows 버전에 맞는 wkhtmltopdf 버전(32비트 또는 64비트)을 선택해주세요.\n- 다운로드가 완료되면 다운로드한 파일을 찾아 두 번 클릭하여 설치 프로세스를 시작해주세요.\n- 화면에 나타나는 지침에 따라 원하는 옵션을 선택하여 설치를 완료해주세요.\n- 기본적으로 wkhtmltopdf는 C:\\Program Files\\wkhtmltopdf 경로에 설치됩니다.\n- 명령 프롬프트에서 어디서든 명령을 실행할 수 있도록 하기 위해 환경 변수 설정에서 시스템의 PATH 변수에 bin 폴더를 추가해야 합니다.\n- 예를 들어, PATH 변수에 C:\\Program Files\\wkhtmltopdf\\bin을 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n설치가 완료되고 필요한 구성이 마무리되면 Python 프로젝트에서 HTML을 PDF로 변환하는 데 wkhtmltopdf를 사용할 준비가 됩니다.\n\n관련 글: 라라벨 10에서 완전한 CRUD 애플리케이션 구축하기\n\n예시:\n\npdfkit을 사용하여 URL로부터 PDF 파일을 생성하는 방법을 보여주는 예제입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport pdfkit\n\npdfkit.from_url('https://www.google.com/', 'test.pdf')\n```\n\n이 예제에서 우리는 pdfkit 모듈을 import하고 from_url() 함수를 사용하여 지정된 URL(https://www.google.com/)의 웹페이지를 PDF 파일로 변환합니다.\n\n결과로 생성된 PDF 파일은 `test.pdf`라는 파일명으로 저장됩니다.\n\nURL과 출력 파일명을 필요에 맞게 사용자 정의할 수 있습니다. 이 코드를 실행하면 변환 프로세스가 시작되고 제공된 URL에서 PDF 파일이 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n이 예시에서는 pdfkit 모듈을 가져와서 from_file() 함수를 사용하여 `test.html`이라는 HTML 파일을 PDF 파일로 변환합니다.\n\n생성된 PDF 파일은 `example.pdf`라는 파일 이름으로 저장됩니다.\n\n```js\nimport pdfkit \n\npdfkit.from_file('test.html', 'example.pdf')\n```\n\n<div class=\"content-ad\"></div>\n\nHTML 파일의 실제 경로 또는 파일 이름을 입력하고 싶은 HTML 파일의 경로나 파일 이름으로 대체해주세요.\n\n또한, 원하는 대로 출력 파일 이름을 사용자 정의할 수 있습니다. 이 코드를 실행하면 HTML 콘텐츠로부터 PDF 파일을 생성하는 변환 프로세스가 시작됩니다.\n\n예시:\n\n이 예시에서는 헤딩과 단락이 포함된 HTML 문자열 html_str을 정의합니다. from_string()을 사용하여 이 HTML 문자열을 `test.pdf`라는 PDF 파일로 변환합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport pdfkit \n\npdfkit.from_string('안녕하세요!', 'test.pdf')\n\n또는\n\nvar htmlstr = '<h2>PDF 파일 생성</h2><p>PDF 파일을 생성합니다</p>'\n\npdfkit.from_string(htmlstr, 'test.pdf')\n```\n\n예시:\n\n여기에는 여러 URL 또는 파일을 하나의 PDF로 변환하는 방법을 보여주는 예시가 있습니다:\n\n예시 1: 여러 URL을 PDF로 변환하기:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport pdfkit\n\npdfkit.from_url(['google.com', 'yandex.ru', 'engadget.com'], 'test.pdf')\n```\n\n이 예제에서는 from_url() 함수를 사용하여 여러 웹페이지를 단일 PDF 파일로 변환할 때 URL 목록([`google.com`, `yandex.ru`, `engadget.com`])을 전달합니다. PDF 파일은 `test.pdf`라는 이름으로 생성됩니다.\n\n각 URL은 생성된 PDF 내에서 개별 페이지로 변환됩니다.\n\n예제 2: 여러 HTML 파일을 PDF로 변환하기:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport pdfkit\n\npdfkit.from_file(['file1.html', 'file2.html'], 'test.pdf')\n```\n\n이 예제에서는 from_file() 함수를 사용하여 여러 HTML 파일을 단일 PDF 파일인 `test.pdf`로 변환하는데 HTML 파일의 목록([`file1.html`, `file2.html`])을 제공합니다.\n\n생성된 PDF 내에 각 HTML 파일은 별도의 페이지로 변환됩니다.\n\n추가로 도움이 될 만한 정보:\n\n<div class=\"content-ad\"></div>\n\n- 추천 도서: 파이썬 입문: 파이썬 시작하기\n- 추천 도서: 파이썬: 세계에서 가장 인기 있는 언어로의 여정\n- 추천 도서: 라라벨에서의 AJAX CRUD 작업 10가지: 단계별 안내","ogImage":{"url":"/assets/img/2024-05-01-ConvertHTMLtoPDFinPythonStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-01-ConvertHTMLtoPDFinPythonStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"개발자 대부분은 모르는 HTML 이야기","description":"","date":"2024-05-01 23:42","slug":"2024-05-01-Atalefrom30yearsofHTML","content":"\n\n몇 일 후에 대부분이 간단히 \"HTML\"로 알고 있는 하이퍼텍스트 마크업 언어가 30세가 됩니다. 1992년 11월 3일에 첫 버전이 출시된 이후로 긴 여정을 걷고 있어요. 정말 오래된 여정이죠.\n\n1992년에 출시되었지만 HTML과 월드 와이드 웹이 인기를 얻기까지는 시간이 걸렸어요. 월드 와이드 웹이 활발해지기 시작한 것은 1995년과 1996년으로, 그 전까지는 꾸준히 여러 기술 천재들과 프로그래머 등 소수의 사람들이 사용하는 것이었습니다.\n\n월드 와이드 웹을 둘러보는 것은 이미 모험이었고, 설정하는 데 꽤 많은 시간과 인내심이 필요했어요. 웹사이트를 만드는 것이 그리 익숙한 일이 아니었고, 상업용 응용프로그램을 개발하려면 여전히 웹, 프랑스의 미네텔, 독일의 BTX 중에서 선택해야 했어요. 이 자리에서 고퍼 프로토콜에 대해서도 한마디 더 남기고 싶어요.\n\n<div class=\"content-ad\"></div>\n\n# 90년대 스타일로 웹사이트 만드는 방법\n\n90년대 초반, 웹사이트를 호스팅해줄 사람을 찾는 것이 가장 큰 과제였습니다. 당시 도메인 등록은 전혀 다른 이야기였어요. 자체 서버를 가지고 있거나 누군가가 웹사이트를 호스팅해주었다면, 아마도 Unix 머신에 FTP 액세스를 제공해주어 HTML과 멋진 GIF 이미지를 저장하고 원하는 누구든지 서비스할 수 있었을 거예요.\n\nHTML 1.0, 2.0에서부터 3.2까지는 기본적인 수준이었습니다. 정말 기본적이죠. 자바스크립트는 1995년에 드디어 나왔지만 당시 브라우저들(주로 넷스케이프와 인터넷 익스플로러)에서 채택되기까지 시간이 걸렸어요. HTTP 쿠키도 1994년에 등장했습니다. 거의 모든 브라우저에서 사용자가 수락해야 하는 쿠키 메시지를 표시했죠 — 데자뷰 같지 않나요? 그래서 누군가가 Unix 머신에서 웹 서버 소프트웨어를 사용할 수 있게 허용해준다면 (예를 들어 NCSA HTTPd), HTML 파일과 이미지 몇 개만 호스팅하고 나면 갑자기 웹마스터가 되는 것이었어요. 요즘의 인터넷 사용자들을 흥분시킬만한 것은 아니었죠.\n\n만약 사용자가 둘러보기만 하는 것이 아니라 실제로 상호작용할 수 있는 의미있는 인터랙티브 웹사이트를 만들고 싶다면 — 예를 들어 채팅 같은 것 — CGI(\"Common Gateway Interface\")를 사용하거나 자체 웹 서버 소프트웨어를 만들게 될 확률이 매우 높았어요. 예전에 자체 웹 서버를 만드는 것은 그리 흔치 않진 않았습니다. 하지만 대부분의 사람들이 CGI를 사용했죠. CGI는 기본적으로 HTTP 요청을 응용프로그램에 전달하고, 응용프로그램은 헤더와 HTML 코드 또는 해당하는 콘텐츠를 반환하는 역할을 했어요. Perl, C 및 C++는 웹서버용 CGI 응용프로그램을 개발하는 데 가장 흔한 언어였습니다. 서버에서 상호작용하는 모든 것을 처리해야 했기 때문에 매우 번거로웠습니다. 쿠키가 없었던 당시에 세션 처리와 세션 관리는 대부분 각 사용자 또는 세션마다 고유 식별자를 사용하여 URL 경로 구성 요소를 통해 이루어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n및 90년대 중반 컴퓨터의 성능을 고려할 때, CPU 클럭 속도가 25에서 180 Mhz 사이였던 때에는 대화형 웹 서버를 실행하는 것이 비싼 일이었습니다. Sun Microsystem의 SPARC CPU 및 시스템이 그 용도로 흔히 사용되었으며, 그 당시에는 싸지 않았습니다.\n\n# '95, '96 및 붐\n\n'95년과 '96년은 현재의 세계적인 웹과 인터넷에 대한 중요한 시기였습니다. 사용량이 급증하고 무료 웹 호스팅 업체인 Yahoo의 GeoCities, 경매 플랫폼인 eBay 및 온라인 상점인 Amazon.com과 같은 서비스가 번창했습니다. 특히 Microsoft Frontpage, Sierra의 WWW Artist 및 기타 많은 소프트웨어들은 자신의 HTML 페이지를 쉽게 작성하고 FTP로 업로드하는 데 큰 도움이 되었습니다.\n\n<img src=\"/assets/img/2024-05-01-Atalefrom30yearsofHTML_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n인터넷 정보 서버를 위한 PHP, Microsoft Active Server Pages와 같은 새로운 프로그래밍 언어들은 월드 와이드 웹을 위한 애플리케이션을 쉽게 만들 수 있게 했습니다. 쿠키와 자바스크립트는 상호작용성을 훨씬 더 높일 수 있었지만, 브라우저가 자바스크립트 코드를 실행하고 브라우저 충돌이 흔했던 시기였습니다. 맥로미디어에서 1996년에 출시된 인기 있는 플래시 플레이어와 자바 애플릿은 언급할 바를 잊으면 안 됩니다. 또한, 1996년에는 CSS인 Cascading Style Sheets도 출시되었습니다.\n\n하지만 당시 웹사이트 레이아웃을 구축하는 방식은 여전히 테이블 레이아웃이었습니다. 모든 것을 수많은 테이블 안에 감싸고 테이블 안에 테이블이 포함된 것이었죠. 인터넷 업데이트는 흔치 않았기 때문에 낡은 웹 브라우저를 만나는 것이 불가피했습니다. 95년부터 98년까지 브라우저 전쟁이 벌어지면서 여러 브라우저의 크로스 브라우저 지원 문제가 머리아팠고, 테이블 사용이 가장 안전한 방법이었습니다. 또한 웹사이트를 만들 때 사용하는 브라우저 정보를 보여주는 애니메이션 GIF도 있었습니다. 요소들의 스타일은 요소가 가진 스타일 어트리뷰트만 가능했습니다. 매우 화려한 스타일을 적용하려면 결국 이미지, 이미지 맵, 그리고 (누가 아냐구요?) 테이블로 감싼 이미지를 사용해야 했습니다. 웹페이지를 제작한다면 기본적으로 하루종일 테이블을 다루었을 것입니다.\n\n’95~’98년의 대부분 연결 속도가 56K 또는 7킬로바이트/초 수준으로 굉장히 느리기 때문에 이미지 로딩도 오래 걸렸습니다. 이렇게 멋진 애니메이션 GIF가 각 브라우저를 홍보할 때 거의 2초가 걸렸습니다. 웹사이트가 나오기까지 30초를 기다리는 것은 비일비재한 상황이었습니다. 콘텐츠 전달 네트워크도 존재하지 않았고, 지연은 \"경험\"에 영향을 미쳤습니다. 그리고 그 경험입니다.\n\n# 97년부터 2000년 이후로 달려가는 중\n\n<div class=\"content-ad\"></div>\n\n샌프란시스코 소재의 작은 회사인 Macromedia가 제공한 소프트웨어 제품인 Dreamweaver, Fireworks, Flash는 많은 프로 웹마스터들에게 가장 선호되는 솔루션이 되었습니다. 웹마스터는 사람들이 가진 직업 중 하나였죠. 그러나 CSS, JavaScript, PHP 등 여러 다른 프로그래밍 언어들이 웹에 순수하게 초점을 맞추며 웹사이트를 만드는 것이 순수한 소프트웨어 개발 또는 엔지니어링 작업이 되는 추세였습니다.\n\n![이미지](/assets/img/2024-05-01-Atalefrom30yearsofHTML_2.png)\n\n2000년대 초까지 많은 웹사이트는 여전히 테이블 레이아웃이었고, 인터넷 익스플로러 3.0과 같은 오래된 브라우저들이 여전히 보였습니다. 그러나 시간이 흐름에 따라 웹사이트는 보다 상호 작용적이고 미디어가 풍부해졌습니다. 개발자들과 사용자들 모두에게 Flash, 자바 애플릿 또는 Real Player 플러그인과 같은 플러그인을 다루어야 했습니다. 사용자들에게는 플러그인을 계속 업데이트하고 새로운 플러그인을 설치해야 하는 번거로움이 있었습니다. 다운로드 속도는 그 시기에도 허용 가능한 수준 이하였습니다.\n\n![이미지](/assets/img/2024-05-01-Atalefrom30yearsofHTML_3.png)\n\n<div class=\"content-ad\"></div>\n\n90년대 후반에는 첫 비디오 및 음악 스트리밍 서비스가 나타났습니다. 그러나 \"브로드밴드\" 사용자들조차 초당 한 메가비트 이상이 있다면 거의 아무런 경험을 할 수 없는 수준의 화질이었습니다. 하지만 새롭고 멋있었습니다. 오늘날의 오픈 소스 세계와 비교하면 Real Networks와 같은 제품과 같은 소프트웨어는 매우 비싼 편이었습니다.\n\n# ‘98년의 WML - 모바일 웹이 태어나고 사라지다\n\n무선 응용 프로토콜(WAP)은 무선 표시 언어(WML)를 사용하며 서로 다른 페이지(카드라고 불리는)를 카드 세트로 구성할 수 있었습니다. 이렇게 함으로써 여러 페이지를 클라이언트로 한 번에 전송하는 데이터 양을 줄일 수 있었습니다. 현재의 프론트엔드 프레임워크가 하는 것과 비슷한 일을 했습니다. 또한 모바일 네트워크 운영자들의 끔찍한 가격 정책 덕분에, WAP와 모바일 브라우저는 놀랍게도 몇 초만에 큰 청구서를 낳을 정도의 경험이 되어 버렸습니다. 사용자들은 그것을 별로 좋아하지 않았다고 해도 과언이 아닙니다.\n\n<img src=\"/assets/img/2024-05-01-Atalefrom30yearsofHTML_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n이어서, WAP과 WML은 금방 사라졌어요. 기술적으로는 꽤 흥미로웠지만, 상업적 환경 속에서 그들의 소멸로 이어졌어요. Pocket PC 2002 이후 Windows Mobile 등의 더 강력한 모바일 브라우저들과 많은 다른 모바일 브라우저들이 나오면서 WAP은 더 이상 필요하지 않았어요. Palm, Nokia 등이 여러 방식으로 모바일 웹에 접근했지만 대부분 실패했어요.\n\n# 2002 — Windows XP, IE 6 & Firefox가 등장\n\n2002년, Firefox와 Windows XP, Internet Explorer 6의 탄생을 맞이했어요. 2000년 닷컴 버블 이후에는 인터넷과 웹이 성숙해졌어요. 온라인 상점, 호텔 및 항공편 예약 사이트와 같은 상업적 웹 서비스가 실제로 등장했어요. JavaScript, CSS 및 HTML이 HTML 4.01로 성숙해지면서, 웹은 종종 \"웹 2.0\"으로 정의되던 것으로 나아가고 있었죠. 브라우저는 이제 달력, 자동 완성 텍스트 상자, 대화형 테이블, 지도 등과 같이 상대적으로 복잡한 UI 구성 요소들을 렌더링하고 작동할 수 있었어요.\n\n![Atalefrom30yearsofHTML_5](/assets/img/2024-05-01-Atalefrom30yearsofHTML_5.png)\n\n<div class=\"content-ad\"></div>\n\nGoogle Maps와 같은 애플리케이션이 등장하면서 현대의 \"웹 2.0\"은 이제 Microsoft AutoRoute와 같이 데스크톱 애플리케이션으로만 가능했던 완전한 규모의 애플리케이션을 구축할 수 있는 능력을 나타냈습니다. 상호 작용식 백과사전인 위키피디아로 인해 서버 팜은 이제 대규모 상호 작용식 웹사이트를 운영할 충분한 데이터베이스, 저장소 및 컴퓨팅 능력을 갖추게 되었습니다.\n\n![Image](/assets/img/2024-05-01-Atalefrom30yearsofHTML_6.png)\n\nJavaScript는 갑자기 전체 DOM을 조작할 수 있게 되었으며, 브라우저는 복잡한 페이지를 렌더링할 충분한 성능을 갖추었으며 CSS를 통해 애플리케이션의 스타일링을 더 편리하게 할 수 있었습니다. 이전에 데스크톱에서만 사용되던 이메일 애플리케이션은 이미 보다 상호 작용적인 이메일 클라이언트 디자인을 채택한 무료 이메일 서비스를 통해 주로 웹 기반으로 전환되었습니다. 웹 기반의 이메일 서비스는 이미 90년대 후반에 등장했습니다. 그러나 대화식 편집기, 채팅 등이 더 널리 사용되기 시작했습니다. HTML, CSS 및 JavaScript의 모든 개선사항마다 웹은 데스크톱 애플리케이션의 능력과 더 일치하게 되었습니다.\n\n# 2008 — 모바일 웹이 태어남\n\n<div class=\"content-ad\"></div>\n\n90년대 중반에 태어난 모바일 웹은 항상 성장을 막는 두 가지 중대한 문제를 가지고 있었어요.\n\n- 모바일 통신사들의 끔찍한 가격 정책\n- 작은 화면과 뚱뚱한 손가락에 최적화되지 않은 웹사이트\n\n가끔 많은 사람들이 망각하는 것은 애플이 이동 통신사들과 계약을 체결하고 Wi-Fi가 모바일 기기에서 주류가 되었다는 사실이에요. 또한 구글의 안드로이드가 등장했죠. 이러한 변화와 함께 더 많은 웹마스터와 개발자들이 모바일 웹사이트를 만들기 시작했어요. 모바일 인터넷 초기에는 모바일 기기가 종종 단순화된 모바일 웹사이트로 리디렉트되었어요. wap.mydomain.com과 같은 도메인 아래에서 자주 발생했죠. 이후 WAP 서비스를 유지한 사람들이 살며시 새로운 모바일 웹으로 전환했어요 (예: CNN).\n\n![이미지](/assets/img/2024-05-01-Atalefrom30yearsofHTML_7.png)\n\n<div class=\"content-ad\"></div>\n\n노키아가 이루지 못한 것을 애플과 구글이 마침내 성취했습니다: 모바일 웹을 대중화하는 것입니다. 악명 높았던 \"모바일 웹사이트\"는 2012년 CSS 미디어 쿼리가 도입되면서 점차 사라지며, 웹사이트가 다양한 화면 크기, 기기 및 형식에 적응할 수 있게 되었습니다. 또한 모바일 브라우저는 훨씬 더 강력해지고, 그 아래에 있는 기기들도 마찬가지입니다. 물론 JavaScript도 포함되어 있군요.\n\n# 2020년, 2021년, 2022년 그리고 앞으로\n\n2020년 초반에는 웹과 웹 브라우저가 지난 수십 년간의 모든 과제를 해결했습니다. 브라우저는 이제 비디오를 스트리밍하고, 이미지와 비디오를 조작하며, 모든 종류의 장치에 적응하고, 기본적으로 브라우저에서 거의 모든 풀 애플리케이션을 실행할 수 있게 되었습니다. 심지어 브라우저가 WebAssembly로 이식된 전체 운영 체제까지 실행할 수 있을 정도입니다. HTML, CSS, JavaScript, WebAssembly 그리고 다양한 네이티브 API들이 오늘날 현대 애플리케이션의 주요 구성 요소입니다. 그리고 HTML은 그것이 웹 브라우저를 넘어서 데스크톱 애플리케이션과 모바일 앱에서도 공통 표준이 되었는데요. React Native, Electron 그리고 다양한 다른 구현을 통해 이뤄졌습니다.\n\n브라우저는 또한 ChromeOS, Android, iOS, Windows와 같은 운영 체제에 더 많이 통합되어 가고 있습니다. 동시에 더 많은 애플리케이션이 웹과 HTML을 대규모로 활용하여 콘텐츠를 표시하고 서비스를 제공하고 있습니다. 소프트웨어 서비스로의 상승으로 현대 비즈니스 애플리케이션도 빠르게 브라우저로 이동하고 있으며, 사용자로부터 설치 부담과 복잡한 라이선싱을 해방시켜 주는 추세입니다.\n\n<div class=\"content-ad\"></div>\n\n# 아직 남아 있는 과제들\n\n옛날에는 브라우저 테스트가 고통스러웠죠. 그리고 지금도 그렇습니다. 인터넷 익스플로러가 이제는 과거의 일이지만, 다양한 모바일 기기, 다양한 형태 요소 및 HTML5 또는 웹 API의 지원 차이는 여전히 과제입니다. 그러나 현대의 개발 환경은 매우 발전했습니다. Chrome, Safari 및 Firefox를 사용하면 데스크톱 및 모바일 기기의 이 브라우저들 간의 차이가 초기의 인터넷 익스플로러나 넷스케이프 네비게이터처럼 심각하지 않습니다.\n\n오늘날의 웹 애플리케이션은 모바일 네트워크, 여러 네트워크를 거쳐 로밍하는 기기 및 갑작스러운 네트워크 커버리지 손실로 인한 연결 중단과 같은 문제에 대처해야 합니다. 그래서 어떤 식으로든 네트워킹과 관련된 과제들이 여전히 존재합니다.\n\nz-index 조작의 도입은 팝업 창의 새로운 버전을 불러왔습니다. 사용자가 웹사이트의 실제 콘텐츠에 접근하지 못하게 하는 중앙 레이어가 등장했습니다. 역사는 분명히 여기서 반복되고 있습니다. 사람들은 팝업 위기로부터 아무것도 배우지 않았나요?\n\n<div class=\"content-ad\"></div>\n\nHTML, CSS 및 JavaScript의 복잡성이 증가함에 따라 새로운 소프트웨어 개발자들이 웹 개발 세계에 진입하고 Lighthouse 테스트와 같은 성능 테스트와 같은 웹 응용 프로그램 표준을 유지하기가 점점 더 어려워지고 있습니다. 오늘날의 일부 웹 사이트는 쉽게 5메가바이트 이상을 초과합니다. 과거의 성능 문제는 오늘도 여전히 해결되지 않은 채로 남아 있습니다.\n\n# 요약 및 전망\n\nW3C가 웹을 위한 로드맵에 더 많은 것들이 있으며, W3C는 표준화에서 매우 복잡한 도전을 해결하는 능력을 계속 증명하고 있습니다. 오늘날 웹 응용 프로그램을 구축하는 것은 이전보다는 더 유연하고 복잡해진 적이 없습니다.\n\n오늘날 일부 사람들은 Frontend(실제 웹 앱 구축)와 Backend(앱이 통신하는 서버 측 구성 요소를 구축)을 구분하는 경향이 있습니다. 그러나 웹의 역사는 이것이 잘못된 접근법임을 증명했습니다. 예전에는 HTML이 많이 서버 측에서 생성되었고 오늘날은 비디오 및 이미지 편집과 같은 많은 작업이 빠르게 브라우저 쪽으로 이동했기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n좋은 웹 앱을 만드는 것은 React와 같은 프레임워크로 더 쉬워졌어요. JSX 같은 React 요소들이 브라우저의 표준으로 채택될 것을 기대할 수 있어요. W3C 표준에 의해 대체된 Flash와 많은 다른 기술들처럼 말이에요.\n\nHTML, CSS, JavaScript, 그리고 웹을 위해 노력하는 모든 분들에게 더 많은 행복한 시간이 더 많이 있기를 바라요!","ogImage":{"url":"/assets/img/2024-05-01-Atalefrom30yearsofHTML_0.png"},"coverImage":"/assets/img/2024-05-01-Atalefrom30yearsofHTML_0.png","tag":["Tech"],"readingTime":9},{"title":"HTML을 배우기 시작했다면 알아야하는 내용들","description":"","date":"2024-05-01 23:40","slug":"2024-05-01-StartingwithHTML","content":"\n\nHTML은 무엇인가요? HTML은 HyperText Markup Language의 줄임말로, 프로그래밍 언어가 아닙니다. 100%의 웹사이트가 사용하는 스크립팅 언어입니다. HTML은 모든 웹사이트의 구조 또는 기반이 되는 요소입니다. 그러므로 HTML이 없으면 웹사이트가 없습니다.\n\n![HTML 이미지](/assets/img/2024-05-01-StartingwithHTML_0.png)\n\n# HTML vs. HTML5\n\n간단히 말해서 HTML은 오래된 버전이고 HTML5는 최신 버전입니다. HTML은 1993년에 WHATWG(Web Hypertext Application Technology Working Group)와 W3C(World Wide Web Consortium)에 의해 31년 전에 발명되었습니다. HTML5는 HTML의 5번째 버전이며, HTML6는 없을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 설정하기\n\n예를 들어 텍스트 편집기 VScode가 필요합니다. [여기](링크)에서 다운로드할 수 있어요.\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_1.png)\n\n# HTML 구문\n\n<div class=\"content-ad\"></div>\n\n저희 언어에서 .,;을 사용하는 것처럼 HTML에도 그런 기호가 있어요. 아래 예시를 확인해보세요,\n\n<img src=\"/assets/img/2024-05-01-StartingwithHTML_2.png\" />\n\n<img src=\"/assets/img/2024-05-01-StartingwithHTML_3.png\" />\n\n# 기본 구조\n\n<div class=\"content-ad\"></div>\n\n![HTML images](/assets/img/2024-05-01-StartingwithHTML_4.png)\n\n![HTML images](/assets/img/2024-05-01-StartingwithHTML_5.png)\n\nTo render a document as an HTML file, you start with `<!DOCTYPE html>`. The `html` tag encloses everything in a webpage. Within the `head` tag, you place meta tags, the title, and more. The `title` tag specifies the title displayed in the browser tab. The `body` tag contains the content visible on the page. Additionally, HTML does not consider white spaces. Here is an element you can start working with:\n\n- Title element\n\n<div class=\"content-ad\"></div>\n\n<div class=\"content-ad\"></div>\n\n![2024-05-01-StartingwithHTML_8.png](/assets/img/2024-05-01-StartingwithHTML_8.png)\n\n![2024-05-01-StartingwithHTML_9.png](/assets/img/2024-05-01-StartingwithHTML_9.png)\n\n4. Div 요소\n\nDivider, 데모 요소. 특별한 의미는 없습니다. 블록 요소입니다.\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-05-01-StartingwithHTML_10.png)\n\n![Image](/assets/img/2024-05-01-StartingwithHTML_11.png)\n\n5. **Bold element**\n\n![Image](/assets/img/2024-05-01-StartingwithHTML_12.png)\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_13.png)\n\n6. 이탤릭 요소\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_14.png)\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_15.png)\n\n<div class=\"content-ad\"></div>\n\n7. 밑줄 요소\n\n![이미지 1](/assets/img/2024-05-01-StartingwithHTML_16.png)\n\n![이미지 2](/assets/img/2024-05-01-StartingwithHTML_17.png)\n\n## 중첩된 HTML 요소\n\n<div class=\"content-ad\"></div>\n\n\n![2024-05-01-StartingwithHTML_18.png](/assets/img/2024-05-01-StartingwithHTML_18.png)\n\n![2024-05-01-StartingwithHTML_19.png](/assets/img/2024-05-01-StartingwithHTML_19.png)\n\n# 블록 요소 vs. 인라인 요소\n\n블록 요소는 전체 너비를 차지합니다. 예를 들어, 단락 태그나 헤더 태그 같은 것들이 있고, 인라인 요소는 굵게, 기울임꼴, 밑줄 등과 같이 같은 줄에서 남아 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_20.png)\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_21.png)\n\n8. Anchor Element\n\n\n<div class=\"content-ad\"></div>\n\n![Image 1](/assets/img/2024-05-01-StartingwithHTML_23.png)\n\n![Image 2](/assets/img/2024-05-01-StartingwithHTML_24.png)\n\n![Image 3](/assets/img/2024-05-01-StartingwithHTML_25.png)\n\n![Image 4](/assets/img/2024-05-01-StartingwithHTML_26.png)\n\n<div class=\"content-ad\"></div>\n\n![StartingwithHTML_27](/assets/img/2024-05-01-StartingwithHTML_27.png)\n![StartingwithHTML_28](/assets/img/2024-05-01-StartingwithHTML_28.png)\n![StartingwithHTML_29](/assets/img/2024-05-01-StartingwithHTML_29.png)\n![StartingwithHTML_30](/assets/img/2024-05-01-StartingwithHTML_30.png)\n\n<div class=\"content-ad\"></div>\n\n파일/페이지가 존재하지 않는 오류가 발생했어요.\n\n수정해 주세요\n\n- [이미지 1](/assets/img/2024-05-01-StartingwithHTML_31.png) \n- [이미지 2](/assets/img/2024-05-01-StartingwithHTML_32.png)\n\n<div class=\"content-ad\"></div>\n\n두 페이지가 서로 링크되어 있습니다\n\n![image1](/assets/img/2024-05-01-StartingwithHTML_33.png)\n\n![image2](/assets/img/2024-05-01-StartingwithHTML_34.png)\n\n새 창에서 링크 열기\n\n<div class=\"content-ad\"></div>\n\n![Start HTML](/assets/img/2024-05-01-StartingwithHTML_35.png)\n\n새 탭에서 열어주세요\n\n![Image Element](/assets/img/2024-05-01-StartingwithHTML_36.png)\n\n9. 이미지 요소\n\n<div class=\"content-ad\"></div>\n\nhttps://unsplash.com/ 에서 무료 이미지를 확인해보세요. 원하는 이미지를 다운로드하여 최고 품질로 사용해보세요.\n\n![이름](/assets/img/2024-05-01-StartingwithHTML_37.png)\n\n![이름](/assets/img/2024-05-01-StartingwithHTML_38.png)\n\n![이름](/assets/img/2024-05-01-StartingwithHTML_39.png)\n\n<div class=\"content-ad\"></div>\n\n![Starting with HTML_40](/assets/img/2024-05-01-StartingwithHTML_40.png)\n\n![Starting with HTML_41](/assets/img/2024-05-01-StartingwithHTML_41.png)\n\nUse either width or height, not both.\n\n![Starting with HTML_42](/assets/img/2024-05-01-StartingwithHTML_42.png)\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-05-01-StartingwithHTML_43.png)\n\n![Image](/assets/img/2024-05-01-StartingwithHTML_44.png)\n\nLinking an image on the another page.\n\n![Image](/assets/img/2024-05-01-StartingwithHTML_45.png)\n\n<div class=\"content-ad\"></div>\n\n10. 가로 줄 요소\n\n![가로 줄 요소 이미지](/assets/img/2024-05-01-StartingwithHTML_46.png)\n\n![가로 줄 요소 이미지](/assets/img/2024-05-01-StartingwithHTML_47.png)\n\n11. 줄 바꿈 요소\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-01-StartingwithHTML_48.png\" />\n\n<img src=\"/assets/img/2024-05-01-StartingwithHTML_49.png\" />\n\n12. Ordered List\n\n<img src=\"/assets/img/2024-05-01-StartingwithHTML_50.png\" />\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_51.png)\n\n13. Unordered List\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_52.png)\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_53.png)\n\n<div class=\"content-ad\"></div>\n\n\n![StartingwithHTML_54](/assets/img/2024-05-01-StartingwithHTML_54.png)\n\n![StartingwithHTML_55](/assets/img/2024-05-01-StartingwithHTML_55.png)\n\n화면에 표시되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_56.png)\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_57.png)\n\nCSS (Cascading Style Sheets) 태그는 `<head>`와 `</head>` 사이에 위치합니다.\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_58.png)\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_59.png)\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_60.png)\n\nJavaScript 태그 - `body` 내부 `body`\n\n![이미지](/assets/img/2024-05-01-StartingwithHTML_61.png)\n\n<div class=\"content-ad\"></div>\n\n![Codepen practice](/assets/img/2024-05-01-StartingwithHTML_62.png)\n\n![Codepen practice](/assets/img/2024-05-01-StartingwithHTML_63.png)\n\nCodepen을 연습할 때 사용하면 좋아요.\n\n![Codepen practice](/assets/img/2024-05-01-StartingwithHTML_64.png)","ogImage":{"url":"/assets/img/2024-05-01-StartingwithHTML_0.png"},"coverImage":"/assets/img/2024-05-01-StartingwithHTML_0.png","tag":["Tech"],"readingTime":7}],"page":"148","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":14,"currentPageGroup":7},"__N_SSG":true}