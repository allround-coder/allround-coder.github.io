{"pageProps":{"posts":[{"title":"NestJS에서 의존성 주입은 어떻게 처리될까요","description":"","date":"2024-06-19 23:13","slug":"2024-06-19-HowDoesNestJSHandleDependencyInjection","content":"\n\nNestJS와 TypeScript를 사용하여 백엔드를 개발할 때, NestJS에서 @Injectable 데코레이터를 사용하는 것이 일반적입니다. EmailService가 @Injectable이고 다른 서비스에서 이를 주입하고 사용하려는 시나리오를 고려해 보겠습니다. 아래 코드를 살펴보세요:\n\n```js\n@Injectable()\nclass MyService {\n  constructor(private readonly emailService: EmailService) {}\n}\n```\n\n첫눈에 보기에는 모든 것이 잘 동작하는 것처럼 보입니다. 그러나 자세히 살펴보면 이 코드가 조금 이상해 보일 수 있습니다. TypeScript 코드가 JavaScript로 변환될 때, 타입 주석이 제거되기 때문입니다. 그래서 문제는 다음과 같이 발생합니다: NestJS는 EmailService와 같은 타입만으로 어떻게 주입할 서비스를 결정할까요?\n\n![How Does NestJS Handle Dependency Injection](/assets/img/2024-06-19-HowDoesNestJSHandleDependencyInjection_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 설명:\n\nNestJS는 TypeScript의 메타데이터 및 리플렉션 기능을 활용하여 런타임에서 의존성에 대한 필요한 정보를 유지합니다. 이를 위해 reflect-metadata라는 라이브러리를 사용합니다. 이 라이브러리를 사용하면 NestJS가 의존성 주입에 사용할 수 있는 클래스와 메소드에 메타데이터를 추가할 수 있습니다.\n\nNestJS는 의존성 주입을 처리하기 위해 데코레이터를 사용합니다. 위 예시에서 @Injectable() 데코레이터는 NestJS에 EmailService 클래스에 대한 메타데이터를 저장하도록 알려줍니다. 런타임에서 NestJS는 이 메타데이터를 활용하여 의존성을 식별하고 주입합니다.\n\n이 프로세스가 올바르게 작동하도록 하려면 프로젝트에 reflect-metadata를 설치하고 주 파일(예: main.ts)에서 import해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'reflect-metadata';\n```\n\n이렇게 하면 NestJS가 JavaScript로 변환될 때 타입 주석이 제거되어도 메타데이터 정보를 사용하여 의존성을 올바르게 식별하고 주입할 수 있습니다.\n\n# 결론\n\nNestJS는 TypeScript에서 메타데이터와 리플렉션을 사용하여 의존성을 효과적으로 관리합니다. 이 기능을 통해 NestJS는 타입 주석이 제거되어도 올바르게 의존성을 식별하고 주입할 수 있습니다. TypeScript로 서버 측 응용 프로그램을 개발할 때 NestJS의 강점 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\nNestJS가 메타데이터와 리플렉션을 통해 의존성 주입을 처리하는 방식을 이해하면 TypeScript와 NestJS의 힘을 최대로 발휘하면서 더 견고하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n\n나의 Linkedin | 나의 Github","ogImage":{"url":"/assets/img/2024-06-19-HowDoesNestJSHandleDependencyInjection_0.png"},"coverImage":"/assets/img/2024-06-19-HowDoesNestJSHandleDependencyInjection_0.png","tag":["Tech"],"readingTime":2},{"title":"Golang 대 Nodejs","description":"","date":"2024-06-19 23:12","slug":"2024-06-19-GolangvsNodejs","content":"\n\n소프트웨어 개발자로서, 언제나 앱을 개발하는 데 최적화된 가장 빠르고 효율적인 도구를 찾고 있어요. 속도와 복잡한 작업 처리에 관한 것이라면, Golang과 Node.js가 두 강자로 뽑히죠. 둘 다 성능 면에서 뛰어난 평판을 자랑하지요. 그런데 고민거리는 여전히 존재합니다 — Golang과 Node.js 중 어느 쪽이 더 빠를까요? 이 논쟁을 해결하기 위해, 내가 이 두 기술을 철저히 비교하는 벤치마크 테스트의 여정에 나섰어요. 자세한 결과를 분석하여, 빠른 속도면에서 어떤 플랫폼이 우위를 차지하는지 확인하는 게 제 목표에요. 데이터를 통해 어느 플랫폼이 고성능 앱을 개발하는 데 분명한 장점을 가지고 있는지 밝혀낼 거예요.\n\n<img src=\"/assets/img/2024-06-19-GolangvsNodejs_0.png\" />\n\n# 소개\n\n최근 몇 년 동안 Golang과 Node.js는 주목을 받아왔어요. 각각의 강점과 장점을 가지고 있죠.\nGolang, Go로도 알려진, 구글에서 개발한 정적 타입의 컴파일된 프로그래밍 언어입니다. Golang은 간결성, 고루틴을 통한 동시성 지원, 그리고 빠른 성능으로 칭찬을 받아왔어요. 반면에 Node.js는 Chrome의 V8 JavaScript 엔진 위에 구축된 이벤트 기반, 논 블로킹 I/O 플랫폼입니다. 비동기 프로그래밍 모델, npm을 통한 확장 패키지 생태계, 빠른 개발 능력으로 인정을 받았죠.\n\n<div class=\"content-ad\"></div>\n\n# 성능 평가 방법론\n\n벤치마킹 테스트 결과를 살펴보기 전에 공정하고 정확한 비교를 보장하기 위해 표준화된 방법론을 수립하는 것이 중요합니다. 저희의 벤치마킹 테스트에서는 응답 시간, 처리량 및 리소스 이용률과 같은 일반적인 성능 지표에 집중할 것입니다. 벤치마킹 테스트 환경에서는 Golang 및 Node.js 애플리케이션에 대해 동일한 하드웨어 사양 및 구성을 적용할 것입니다. 또한 신뢰할 수 있는 벤치마킹 도구와 프레임워크를 활용하여 모든 실험의 신뢰성과 일관성을 보장할 것입니다.\n\n# 응답 시간 비교\n\n웹 서버 성능을 평가하는 데 중요한 지표 중 하나인 응답 시간은 요청을 보내고 응답을 받는 지속 시간을 측정합니다. 저희의 벤치마킹 테스트에서는 Golang과 Node.js로 작성된 동일한 웹 서버 애플리케이션을 배포하여 각각 간단한 HTTP 요청을 제공하고 처리 오버헤드를 최소화할 것입니다. 서로 다른 수준의 동시 클라이언트 연결을 시뮬레이션하고 해당 응답 시간을 분석함으로써 Golang과 Node.js의 성능을 현실적인 작업 부하 시나리오에서 평가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// Node.js HTTP 서버\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.writeHead(200);\n  res.end('안녕, 세상아!');\n});\n\nserver.listen(3000);\n```\n\n<img src=\"/assets/img/2024-06-19-GolangvsNodejs_1.png\" />\n\n초당 요청 횟수\n\n```js\n// Golang HTTP 서버\npackage main\n\nimport (\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"안녕, 세상아!\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":3000\", nil)\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 처리량 분석\n\n응답 시간 외에도 처리량은 시스템이 수신 요청을 처리하는 속도를 측정하는 또 다른 중요한 성능 지표입니다. 높은 처리량 값은 동시 연결을 처리하고 응답을 즉시 전달할 능력을 나타냅니다. Golang 및 Node.js 애플리케이션의 처리량을 비교하기 위해 동시 클라이언트 요청 수를 증가시키고 각 플랫폼의 요청 처리 능력에 대한 확장성을 모니터링할 것입니다.\n\n# 자원 활용\n\n응답 시간과 처리량 외에도, 부하 하에서 Golang 및 Node.js 애플리케이션의 자원 활용 평가는 매우 중요합니다. 이는 CPU 사용률, 메모리 소비 및 네트워크 활동을 모니터링하여 잠재적인 병목 현상이나 비효율성을 찾아내는 것을 포함합니다. 자원 활용 지표를 면밀히 살펴봄으로써 각 플랫폼의 전체 효율성과 확장성에 대한 통찰력을 얻을 수 있으며, 프로젝트에 적합한 최적 기술 스택을 선택할 때 개발자들이 정보에 기반한 결정을 내릴 수 있게 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n# CPU 사용량:\n\n- Golang은 기계 코드를 컴파일하여 CPU를 효율적으로 사용합니다. 벤치마크 테스트 결과 Golang은 CPU 자원 활용에서 Node.js를 능가하는 것으로 지속적으로 증명되고 있습니다.\n- Node.js는 단일 스레드에서 작동하며 비동기 I/O 호출에 의존하므로 CPU 자원을 미적절하게 사용하고 오버헤드가 증가할 수 있습니다.\n\n# 메모리 사용량:\n\n- 정적 타입 및 컴파일된 성격으로 인해 Golang은 Node.js보다 낮은 메모리 사용량을 보입니다. 덜 필요한 런타임 메타데이터를 요구합니다.\n- Node.js는 동적 타입 및 V8 JavaScript 엔진에 의존하여 유형 정보와 힙을 저장하는 데 더 많은 메모리가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 스레딩 모델:\n\n- Golang은 경량 스레드(고루틴)를 활용하여 동시성을 간단하게 다루고 병렬성을 달성합니다.\n- Node.js는 단일 스레드, 논블로킹 I/O 모델을 채택합니다. 동시성은 Worker Threads를 사용하여 명시적으로 코딩해야 합니다.\n\n# 확장성:\n\n- 경량 고루틴 스레드를 통해 Golang은 수평적으로 뛰어난 확장성을 갖추어 대규모 동시 요구를 처리할 수 있습니다.\n- Node.js는 단일 기계에서 수직적으로 확장성이 뛰어나지만, 단일 스레드 특성으로 인해 확장성을 넓히는 동안 병목 현상을 겪을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 동시성 성능\n\nGolang의 탁월한 기능 중 하나는 가벼운 고루틴과 채널을 통한 동시성을 네이티브로 지원한다는 것입니다. 이를 통해 Golang 애플리케이션은 수천 개의 동시 작업을 효율적으로 처리하면서 오버헤드를 최소화할 수 있어 웹 서버, 마이크로서비스 및 분산 애플리케이션과 같이 높은 동시성 시스템을 구축하는 데 이상적입니다. 반면에 Node.js는 이벤트 기반 비차단 I/O 모델을 통해 동시성을 처리하며 비동기 함수와 이벤트 루프를 활용합니다. 우리는 두 플랫폼에서 고도의 동시성 작업을 스트레스 테스트하여 동시성 성능을 비교하고, 반응성과 확장성을 평가할 것입니다.\n\n# 결론\n\n벤치마크 테스트 결과는 Golang과 Node.js 간의 성능 차이를 생생하게 보여줍니다. 두 플랫폼 모두 장단점을 가지고 있지만, Golang은 순수 속도, 동시성 및 자원 효율성 면에서 우수한 성능을 뽐내고 있습니다. 컴파일된 성격, 가벼운 고루틴 및 효율적인 런타임으로 인해 빠른 응답 시간과 확장 가능한 동시성을 필요로 하는 고성능 애플리케이션에 매력적인 선택이 됩니다.\n반면 Node.js는 탁월한 개발자 생산성, 광범위한 생태계 지원 및 JavaScript 프론트엔드 프레임워크와의 원활한 통합을 제공합니다.\n최종적으로 Golang과 Node.js 중 어느 것을 선택할지는 프로젝트의 특정 요구사항과 우선순위에 따라 결정됩니다 - 성능 최대화, 기존 JavaScript 전문성 활용 또는 개발자 효율성 최적화 등을 고려해야 합니다.","ogImage":{"url":"/assets/img/2024-06-19-GolangvsNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-GolangvsNodejs_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs를 사용한 서버 측 렌더링 운영화","description":"","date":"2024-06-19 23:08","slug":"2024-06-19-OperationalizingNodejsforServerSideRendering","content":"\n\n## Airbnb이 서버 측 렌더링을 중심으로 Frontend를 더 많이 구축함에 따라, 서버 구성을 최적화하는 방법을 살펴보았습니다.\n\nAirbnb에서는 몇 년 동안 Frontend 코드를 일관된 아키텍처로 이주시켜 왔습니다. 전체 웹 페이지가 API에서 제공하는 데이터를 활용하여 React 구성 요소의 계층 구조로 작성되었습니다. Ruby on Rails가 브라우저로 웹을 가져오는 방식에서의 역할은 매일 줄어들고 있습니다. 사실, 곧 우리는 노드.js로 완전한 형태의 서버 렌더링 웹 페이지를 제공할 새로운 서비스로 이행할 것입니다. 이 서비스는 모든 Airbnb 제품의 대부분의 HTML을 렌더링할 것입니다. 이 렌더링 엔진은 우리가 실행하는 대부분의 백엔드 서비스와는 다르며, 루비나 자바로 작성되지 않았음을 특징으로 합니다. 그러나 이 렌더링 엔진은 우리가 생각하는 일반적인 I/O 집중적인 노드.js 서비스와도 다릅니다.\n\n노드.js를 떠올렸을 때, 여러분은 고도로 비동기식인 애플리케이션이 효율적으로 수백 또는 수천 개의 연결을 동시에 처리하는 모습을 상상합니다. 서비스는 동네 곳곳에서 데이터를 가져와 상당히 가볍게 처리하여 많은 클라이언트가 사용할 수 있도록 만듭니다. 아마도 여러분은 수많은 오랜 기간 유지되는 WebSocket 연결을 처리하고 있습니다. 여러분은 이 잘 튠된 경량 동시성 모델로 업무에 완벽히 적합하다는 점에 만족하고 확신하고 있습니다.\n\n서버 측 렌더링(SSR)은 이러한 상상을 일부 깨는 연산 집약적인 작업입니다. 노드.js에서 사용자 코드는 단일 스레드에서 실행되므로 연산 작업(즉, I/O가 아닌 작업)의 경우 동시에 실행할 수 있지만 병렬로 실행할 수는 없습니다. 노드.js는 많은 양의 비동기 I/O를 병렬로 처리할 수 있지만 연산에 한계가 있습니다. 요청의 연산 부분이 I/O에 상대적으로 더 많아질수록 동시 요청은 CPU 경합으로 인해 지연에 미치는 영향이 증가할 것입니다¹.\n\nPromise.all([fn1, fn2])를 고려해보세요. fn1 또는 fn2가 I/O에 의해 해결되는 promise이면 이와 같이 병렬성을 달성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 fn1과 fn2이 연산되면, 대신 이렇게 실행될 것입니다:\n\n![OperationalizingNodejsforServerSideRendering_1](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_1.png)\n\n두 작업 중 하나가 완료될 때까지 다른 하나는 기다려야 합니다. 왜냐하면 실행 스레드가 하나뿐이기 때문입니다.\n\n서버 측 렌더링에서는 서버 프로세스가 여러 동시 요청을 처리할 때 이 문제가 발생합니다. 동시 요청이 처리 중인 다른 요청들에 의해 지연될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_2.png)\n\n현실에서는 요청이 여러 가지 다른 비동기 단계로 구성되는 경우가 많습니다. 심지어 대부분이 계산에 대한 경우라도요. 이는 더 나쁜 교차 결과로 이어질 수 있습니다. renderPromise().then(out => formatResponsePromise(out)).then(body => res.send(body))와 같은 체인으로 요청이 구성된 경우, 다음과 같은 요청 교차가 발생할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_3.png)\n\n이 경우, 두 요청 모두 두 배로 오래 걸릴 수 있습니다. 이 문제는 동시성이 증가함에 따라 심각해집니다.\n\n게다가 SSR의 일반적인 목표 중 하나는 클라이언트와 서버 모두에서 동일하거나 유사한 코드를 사용할 수 있어야 한다는 것입니다. 이러한 환경 간의 큰 차이점 중 하나는 클라이언트 컨텍스트가 본질적으로 단일 테넌트인 반면 서버 컨텍스트는 다중 테넌트입니다. 클라이언트 측에서 쉽게 작동하는 싱글톤이나 다른 전역 상태와 같은 기법은 서버에서 동시 요청 부하하에 대해 버그, 데이터 누출 및 일반적인 혼돈을 초래할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 문제들은 병행성이 발생할 때만 문제가 됩니다. 낮은 부하 수준이거나 개발 환경의 독점적인 단일 테넌시에서는 대부분 잘 작동합니다.\n\n이는 노드 애플리케이션의 전형적인 예제들과 매우 다른 상황을 초래합니다. 우리는 JavaScript 런타임을 사용하여 라이브러리 지원과 브라우저의 특성을 활용하기 위해 사용하고 있습니다. 병행성 모델 대신 이러한 애플리케이션에서는 비동기 병행성 모델이 그 모든 비용을 부과하지만 그 혜택은 별로 없거나 거의 없습니다.\n\n# Hypernova에서 배운 점\n\n저희의 새로운 렌더링 서비스인 Hyperloop은 Airbnb 웹 사이트 이용자가 상호 작용하는 주요 서비스가 될 것입니다. 따라서 그 신뢰성과 성능은 사용자 경험에 절대적으로 중요합니다. 새 서비스로의 프로덕션 전환에 따라 이제는 사전 SSR 서비스인 Hypernova에서 배운 교훈을 통합하고 있습니다.\n\nHypernova는 새 서비스와 다르게 작동합니다. 그것은 순수한 렌더러입니다. 우리의 레일즈 단일체 Monorail에서 호출되고, 특정 렌더링된 컴포넌트에 대한 HTML 조각만 반환합니다. 대부분의 경우 \"조각\"은 페이지의 대부분이며, 레일즈는 단지 바깥 쪽 레이아웃만 제공합니다. 레거시의 경우, 페이지의 구성 요소를 ERB를 사용하여 연결할 수 있습니다. 그러나 어느 경우든 Hypernova는 데이터를 자체로 가져오지 않습니다. 데이터는 레일즈에서 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n위에서 언급한대로, Hyperloop과 Hypernova는 컴퓨트에 관한 유사한 운영 특성을 공유합니다. 실제 트래픽을 처리하는 서비스로, Hypernova는 그 대체품이 프로덕션 환경에서 어떻게 동작할지 이해하는 데 좋은 테스트 대상을 제공합니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_4.png)\n\n사용자로부터 요청이 주요 Rails 앱 Monorail에 들어오며, Monorail은 React 컴포넌트를 해당 페이지에 렌더링하고자 하는 속성을 조합하고 해당 속성과 컴포넌트 이름을 Hypernova에 요청합니다. Hypernova는 속성과 함께 컴포넌트를 렌더링하여 Monorail로 반환할 HTML을 생성하고, Monorail은 페이지 템플릿에 내장시키고 전체를 클라이언트에게 되돌려보냅니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_5.png)\n\n<div class=\"content-ad\"></div>\n\n렌더링 중 실패(오류 또는 타임아웃으로 인한) 발생 시, 하이퍼노바 렌더링의 대체 방법은 렌더링된 HTML 없이 페이지에 구성 요소와 해당 속성을 삽입하는 것입니다. 이렇게 함으로써 클라이언트 렌더링이 성공적으로 수행될 수 있습니다. 이로 인해 하이퍼노바를 선택적 종속성으로 간주하고, 일부 타임아웃과 실패를 허용할 수 있게 되었습니다. 호출에 대한 타임아웃 시간은 서비스의 관찰된 p95 값과 유사하게 설정되었습니다. 기본적으로 5% 미만의 타임아웃이 발생하는 것이 예상대로였습니다.\n\n최대 일일 트래픽로드 배포 중에는 모노레일에서 하이퍼노바에 대한 요청 중 최대 40%가 타임아웃되는 경우가 발생했습니다. 하이퍼노바로부터 배포 중 BadRequestError: Request aborted의 오류율이 증가하는 것을 보았습니다. 이러한 오류는 다른 모든 응용 프로그램/코딩 오류를 효과적으로 숨겨버리는 상당한 기준 오류율 또한 존재했습니다.\n\n이러한 동작은 선택적 종속성으로, 높은 우선순위가 아닌 번거로움으로 여겨졌습니다. 저희는 타임아웃 및 오류를 초기 GC가 비용이 많이 드는 초기 시작 동작, JIT 부족, 캐시 채움, 빗물과 같은 요소의 예상으로 충분히 설명할 수 있다고 합리적으로 생각했습니다. React 또는 Node의 새로운 릴리스가 느린 시작을 완화하기 위한 충분한 성능 개선을 제공할 것을 희망했습니다.\n\n이는 배포 중에 나쁜 로드 밸런싱이나 용량 문제로 인한 확실한 결과로 의심되어질 수 있습니다. 동일한 프로세스에서 거의 100%의 계산 요청을 동시에 처리함으로써 늘어난 대기 시간을 볼 수 있었고, 여러 요청이 한 번에 실행되는 경우가 있을 때에는 해당하는 프로세스에서 동시에 처리된 요청 수를 로그하는 미들웨어를 추가했습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 실제로 CPU 사용을 기다리는 동시 요청 때문에 발생한 지연을 시작 지연으로 원망했습니다. 우리의 성능 지표에서 다른 실행 중인 요청 때문에 실행을 대기하는 시간은 요청을 실행하는 데 소비된 시간과 구별할 수 없습니다. 이는 동시성으로 인한 지연이 개별 요청의 비용을 실제로 증가시키는 새로운 코드 경로 또는 기능에서 발생하는 지연과 동일하게 나타날 것이라는 것을 의미합니다.\n\n또한 BadRequestError: Request aborted 오류가 일반적인 느린 시작 성능으로 충분히 설명되지 않는다는 사실이 점점 더 분명해지고 있었습니다. 이 오류는 body parser에서 발생하며 특히 클라이언트가 서버가 요청 본문을 완전히 읽기 전에 요청을 중단한 경우에 발생합니다. 클라이언트가 포기하고 연결을 끊어가면 우리가 처리를 계속하기 위해 필요한 소중한 데이터를 가져가는데, 개별 요청의 비용을 증가시키는 것이 실제로 더 가능성이 높습니다.\n\nHypernova의 요청 페이로드도 평균적으로 수백 킬로바이트로 상당히 크기 때문에 이 문제가 더 복잡해집니다.\n\n<img src=\"/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_7.png\" />\n\n우리는 이 문제를 해결하기 위해 우리에게 많은 양의 운영 경험을 제공하는 두 가지 외부 구성 요소를 사용하기로 결정했습니다: 역방향 프록시(nginx) 및 로드 밸런서(haproxy).\n\n<div class=\"content-ad\"></div>\n\n# Reverse Proxying 및 로드 밸런싱\n\n우리의 하이퍼노바 인스턴스에 존재하는 여러 CPU 코어를 활용하기 위해 노드.js 클러스터 모듈을 통해 여러 하이퍼노바 프로세스를 실행합니다. 이러한 프로세스들은 독립적이기 때문에 동시 요청을 병렬로 처리할 수 있습니다.\n\n![image](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_8.png)\n\n여기서 문제는 각 노드 프로세스가 요청이 완료될 때까지 효과적으로 점유되며, 이는 클라이언트(모노레일)로부터 요청 본문을 읽는 작업을 포함합니다. 하나의 프로세스에서 병렬로 여러 요청을 읽을 수는 있지만, 이는 작업을 렌더링할 때 연산이 교차되는 문제로 이어집니다. 노드 프로세스의 이용률은 클라이언트 및 네트워크의 속도에 결합됩니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션은 클라이언트와의 통신을 처리하기 위해 버퍼링 리버스 프록시를 사용하는 것입니다. 이를 위해 nginx를 사용합니다. Nginx는 클라이언트로부터의 요청을 버퍼에 읽고, 완전히 읽힌 후에만 전체 요청을 노드 서버에 전달합니다. 이 전송은 머신 내에서 루프백 또는 유닉스 도메인 소켓을 통해 이루어지며 이는 머신 간 통신보다 빠르고 안정적입니다.\n\n![image](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_9.png)\n\nnginx가 요청을 읽는 작업을 처리하면, 노드 프로세스의 사용률을 높일 수 있습니다.\n\n![image](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_10.png)\n\n<div class=\"content-ad\"></div>\n\n우리는 몇 가지 요청을 처리하기 위해 nginx를 사용하여 Node.js 프로세스로 직행할 필요 없이 처리합니다. 우리의 서비스 검색 및 라우팅 레이어는 호스트 간의 연결 상태를 확인하기 위해 낮은 비용의 /ping 요청을 사용합니다. 이를 nginx에서 완전히 처리함으로써 Node.js 프로세스로의 (비록 저렴하지만) 상당한 처리량 출처를 제거합니다.\n\n다음은 부하 분산입니다. 어떤 Node.js 프로세스가 어떤 요청을 받아야 하는지에 대한 스마트한 결정을 내려야 합니다. 클러스터 모듈은 라운드 로빈 방식으로 요청을 분배합니다. 각 프로세스는 차례로 요청을 받습니다. 라운드 로빈은 요청 지연 시간에 큰 변동이 없을 때 훌륭합니다. 그림 1을 참고하세요.\n\n다루는 시간이 극명하게 다른 다양한 유형의 요청이 있는 경우 라운드 로빈은 좋지 않습니다. 프로세스의 후속 요청은 이전 요청이 모두 완료될 때까지 기다려야 합니다. 이에 대처할 수 있는 또 다른 처리 용량이 있는 다른 프로세스가 있더라도요.\n\n<div class=\"content-ad\"></div>\n\n\n![데이터](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_12.png)\n\n이 요청의 더 나은 분배 방식은 다음과 같습니다:\n\n![데이터](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_13.png)\n\n대기 시간을 최소화하고 응답을 빠르게 반환할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 작업은 요청을 대기열에 유지하고 프로세스가 다른 요청으로 쓰여지지 않게 될 때에만 해당 요청을 프로세스에 할당하여 달성할 수 있습니다. 이를 위해 우리는 haproxy를 사용합니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_14.png)\n\n이를 Hypernova에 적용하면 배포시에 타임아웃 스파이크와 BadRequestErrors가 완전히 제거되었습니다. 동시 요청은 정상 작동 중에 높은 백분위 지연의 주요 원인이기도 했기 때문에 이로 인해 그 지연도 감소하였습니다. 이러한 결과 중 하나는 구성된 타임아웃이 같더라도 타임아웃 비율이 5%에서 2%로 줄어든 것입니다. 40%의 배포 실패에서 2%로 감소한다는 것은 승리 같은 느낌입니다. 오늘날 사용자들은 로딩 화면이 훨씬 덜 나타납니다. 내일은 Hypernova의 오류 대비 기능이 없는 새 랜더러를 위해 우리에게 매우 중요한 배포를 통한 안정성이 될 것입니다.\n\n# 자세한 내용과 설정\n\n<div class=\"content-ad\"></div>\n\n이 설정을 위해 nginx, haproxy 및 우리 노드 애플리케이션을 구성해야 합니다. 이 설정을 이해하는 데 사용할 수 있는 nginx 및 haproxy 구성이 포함된 샘플 노드 앱을 준비했습니다. 이러한 구성은 우리가 프로덕션 환경에서 실행하는 것을 기반으로 하지만, 단순화되고 비특권 사용자로 전경에서 실행되도록 수정되었습니다. 프로덕션 환경에서는 모든 것을 프로세스 감독자(저희는 runit 또는 점점 더 많이 사용하는 kubernetes를 사용합니다)로 구성해야 합니다.\n\nNginx 구성은 매우 표준적이며, 포트 9000에서 듣는 서버를 구성하여 요청을 포트 9001(저희 환경에서는 Unix 도메인 소켓을 사용)에 듣는 haproxy로 프록시하는 것입니다. 또한 /ping 엔드포인트를 가로채서 연결성 확인을 직접 제공합니다. 내부 표준 nginx 구성과의 차이점은 worker_processes를 1로 줄였다는 것인데, 단일 nginx 프로세스가 단일 haproxy 프로세스와 노드 애플리케이션을 충분히 포화시키기 때문입니다. 또한 hypernova를 위한 컴포넌트의 속성으로 큰 요청 및 응답 버퍼를 사용하고 있습니다(수백 킬로바이트 단위). 자신의 요청/응답 크기에 기반하여 버퍼 크기를 조정해야 합니다.\n\nNode의 클러스터 모듈은 로드 밸런싱과 프로세스 생성을 모두 처리합니다. 로드 밸런싱을 위해 HAProxy로 전환하려면 클러스터의 프로세스 관리 부분을 대체해야 했습니다. 이는 worker 프로세스 풀을 유지하는 데에 대해 클러스터보다 약간 더 의견을 갖추는 pool-hall로 구성되었는데, 로드 밸런싱 게임과는 완전히 무관합니다. 예제 앱은 pool-hall을 사용하여 다른 포트에서 듣는 네 개의 worker 프로세스를 시작하는 방법을 보여줍니다.\n\nHAProxy 구성은 포트 9001에서 듣는 프록시를 구성하여 포트 9002에서 9005까지 듣는 네 개의 worker로 트래픽을 라우팅합니다. 각각의 worker에 대해 가장 중요한 설정은 maxconn 1 입니다. 이는 각 worker가 한 번에 하나의 요청을 처리하도록 제한합니다. 이는 HAProxy 통계 페이지(포트 8999에서 실행하도록 구성됨)에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![HAProxy Configuration](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_15.png)\n\n안녕하세요!\n\nHAProxy는 각 워커와의 현재 열린 연결 수를 추적합니다. maxconn을 통해 구성된 제한이 있습니다. 라우팅은 static-rr (정적 라운드 로빈)으로 설정되어 있어 일반적으로 각 워커에게 순서대로 요청이 제공됩니다. 제한이 설정된 경우 라우팅은 라운드 로빈으로 진행되지만 현재 요청 제한에 도달한 워커는 건너뛰게 됩니다. 연결 제한 이하의 워커가 없는 경우 요청은 대기열에 들어가며 가장 먼저 사용 가능해진 워커에게 배달됩니다. 이것이 우리가 원하는 동작입니다.\n\n이 구성은 아마도 사용하려는 것과 매우 가까운 것일 것입니다. 여기에는 다른 흥미로운 설정(그리고 필요한 복사 붙여넣기)이 있습니다. 이 구성을 준비하는 일안하며, 우리는 일반적이고 이상적인 상황에서 여러 테스트를 수행하고 그에 기반하여 구성 값을 유도했습니다. 이는 깊이 들어가는 내용으로서 설정을 사용하는 데까지 꼭 이해할 필요는 없지만, 다음 섹션에서 제공됩니다.\n\n# HAProxy 심층 분석\n\nHAProxy 구성이 우리가 원하는 대로 정확히 작동하는 것에 많은 것이 달려 있었습니다. 동시 요청 제한 또는 대기열매 확인되지 않았다면 잘못된 것입니다. 또한 각종 종류의 실패가 어떻게 처리되는지(또는 처리되지 않는지)를 이해하는 것이 중요했습니다. 현재 클러스터 설정에 대한 적합한 대체물인지 확인할 필요가 있었습니다. 이를 확인하기 위해 여러 테스트를 수행했습니다.\n\n<div class=\"content-ad\"></div>\n\n테스트의 일반적인 형태는 Apache Benchmark을 사용하여 다양한 동시성 수준에서 10,000개의 요청을 실행하는 것이었습니다. \n\n```js\nab -l -c <CONCURRENCY> -n 10000 http://<HOSTNAME>:9000/render\n```\n\n저희 설정에서는 예시 앱의 4개 대신 15개의 워커를 사용했고, 벤치마킹 및 시스템 테스트 간 간섭을 피하기 위해 앱을 실행하는 인스턴스와 별도 인스턴스에서 ab를 실행했습니다. 저희는 낮은 부하 (동시성=5), 높은 부하 (동시성=13), 대기 부하 (동시성=20)에서 테스트를 실행했습니다. 대기 부하를 통해 haproxy가 항상 대기열을 처리하도록 했습니다.\n\n첫 번째 테스트 세트는 그저 정상 작동을 확인하는 것이었고, 다음 테스트 세트는 배포 중 발생할 수 있는 모든 프로세스의 우아한 재시작을 확인하였습니다. 마지막 테스트 세트는 제가 일부 프로세스를 무작위로 종료하는 시나리오를 확인하는 것이었습니다. 이는 발생하지 않은 예외가 프로세스를 비정상적으로 종료시키는 상황을 시뮬레이션한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션 코드에서 무한 루프가 별도로 문제가 되었기 때문에 무한 루프가 포함된 엔드포인트에 대해 단일 요청을 실행했습니다.\n\n이러한 테스트는 우리의 구성 및 작동 방식을 이해하는 데 도움이 되었습니다.\n\n일반 작업에서 maxconn 1은 한 번에 하나의 요청을 처리하도록 각 프로세스를 제한하는 대로 정확히 기대했던 대로 작동했습니다. 백엔드에는 HTTP 또는 TCP 헬스체크를 구성하지 않았습니다. 이는 혼란을 야기하고 가치가 없다는 것을 발견했기 때문입니다. 헬스체크는 maxconn을 존중하지 않는 것으로 보입니다. 그러나 코드에서 이를 확인한 적은 없습니다. 우리의 예상 동작은 프로세스가 건강하고 서비스를 제공할 수 있는지 여부이거나 리스닝 중이지 않아 즉시 연결 오류를 발생시킬 것임을 의미합니다 (이에는 한 가지 주요 예외가 있습니다). 우리는 이러한 헬스체크를 우리 사례에 유용할 정도로 충분히 제어 가능하지 않아서 다른 헬스체킹 regime의 예측 불가능성을 피하기로 결정했습니다.\n\n연결 오류는 다룰 수 있는 문제입니다. 우리는 옵션 redispatch 및 retries 3을 설정하여 연결 오류를 수신하는 요청을 더 협조적인 다른 백엔드로 전달할 수 있게 했습니다. 연결이 거부되면 즉시 오류가 발생하여 우리는 비즈니스를 계속할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n거부된 연결에만 적용됩니다. 지금은 수신 대기 중이 아니라는 이유로 연결이 거부됩니다. 로컬 네트워크를 다루고 있기 때문에 연결 제한 시간은 별로 유용하지 않습니다. 무한 루프에 갇힌 워커를 방지하기 위해 낮은 연결 제한 시간을 설정할 수 있을 것으로 예상했습니다. 100밀리초의 타임아웃을 설정했을 때, 이벤트 루프로 제어가 되돌아가지 않았음에도 클라이언트/서버에서 설정된 10초 타임아웃 후에 우리 요청이 타임아웃되는 것에 놀랐습니다. 이는 커널이 서버가 수락하기 전에 클라이언트 관점에서 연결을 설정하는 것을 처리하기 때문에 발생합니다.\n\n주목할 만한 점으로, 백로그를 설정하여도 백로그 길이는 서버가 SYN-ACK에 응답한 후에 평가되어 연결이 설정되지 않는 것으로 결과되지 않습니다 (실제로는 서버가 클라이언트에서 돌아온 ACK 응답을 놓는 것을 구현/처리). 이로 인해 연결이 설정된 요청은 백엔드가 해당 요청을 처리했는지 여부를 판단할 수 있는 방법이 없기 때문에 다시 보내거나 다시 시도할 수 없습니다.\n\n또 다른 흥미로운 결과로, 무한 계산 루프에 갇힌 프로세스에서 수행한 테스트에서 클라이언트/서버 타임아웃은 예상치 못한 동작을 허용합니다. 무한 루프에 빠지게 하는 프로세스로 요청을 보낼 때, 백엔드의 연결 개수가 1로 설정됩니다. maxconn의 경우에는 우리가 원하는대로 작동하여 다른 요청이 연결될 수 없게 합니다. 클라이언트/서버 타임아웃이 만료되면 연결 개수가 다시 0으로 감소되며, 요청처리가 성공했는지 여부를 알 수 없어 우리의 1대1 보장이 위반되고 이전 요청은 실패로 이끌게 됩니다. 클라이언트가 타임아웃이나 변덕 때문에 연결을 닫을 때, 연결 개수는 영향을 받지 않고 라우팅은 계속해서 작동합니다. abortonclose를 설정하면 클라이언트가 닫는 즉시 연결 개수가 감소됩니다. 이에 따라 최선의 조치는 이러한 타임아웃에 높은 값을 설정하고 abortonclose를 해제하는 것입니다. 더 강력한 타임아웃은 클라이언트 또는 nginx 측에서 설정할 수 있습니다.\n\n또한 고부하 사례에서 적용되는 상당히 불편한 매력 요소를 발견했습니다. 만약 서버가 안정적인 대기열을 갖고 있는 상태에서 워커 프로세스가 충돌한다면 (이는 매우 드문 경우여야 합니다), 요청은 해당 백엔드에서 시도될 것이지만 프로세스가 수신 대기 중이기 때문에 연결에 실패합니다. 그럼 HAProxy는 그 후 다음 열린 연결 슬롯을 가진 다음 백엔드로 다시 배분하지만, 실제로 작업 중인 다른 백엔드는 없기 때문에 실패했던 이전 백엔드만 다시 시도됩니다. 이렇게 되면 재시도가 빠르게 소모되어 연결 오류가 HTML 렌더링보다 더 빠르게 발생하여 실패한 요청으로 이어집니다. 이 과정은 대기열이 완전히 소진될 때까지 나머지 요청에 계속 반복됩니다. 이는 좋지 않은 상황이지만, 프로세스 충돌이 드문 데에, 지속적인 대기열이 드문 데에 (계속해서 대기 중이면 공급이 부족한 것입니다) 그리고 특정한 경우에는 서비스 검색의 건강 검사를 빠르게 마킹하므로 전체 인스턴스를 건강하지 않게 표시하고 새 요청을 처리할 수 없게 만듭니다. 이는 좋지 않지만 위험을 최소화합니다. 미래의 작업은 HAProxy 통합을 통해 이를 해결할 수 있으며, 감독자 프로세스가 프로세스의 종료를 감지하고 haproxy stats 소켓을 통해 MAINT로 표시할 수 있는 깊은 HAProxy 통합을 통해 처리할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n다른 변경 사항 중 하나는 Node에서 server.close가 기존 요청이 완료될 때까지 기다리지만 HAProxy 대기열에 있는 것은 서버가 아직 받지 않은 요청을 기다릴지 모르기 때문에 실패할 것입니다. 인스턴스가 요청을 받지 않는 시간과 서버 재시작 프로세스를 시작하는 시간 사이에 충분한 드레인 시간을 보장하는 것이 대부분의 경우 이 문제를 해결해야 합니다.\n\n또한, 대부분의 트래픽을 처음에 사용 가능한 워커에 지시하는 'balance first'를 설정하면 (기본적으로 worker1을 포화시키는) 앱의 지연 시간이 'balance static-rr'보다 15% 감소했습니다. 이 효과는 합성 및 프로덕션 로드에서 지속되었으며, 웜 업으로 쉽게 설명되지 않는 결과였습니다. 이는 배포 후 몇 시간 동안 지속되었습니다. 성능은 시간이 지남에 따라 (12시간 동안) 점점 악화되었지만, 아마도 핫 프로세스의 메모리 누수 때문이었을 것입니다. 또한, 차가운 프로세스가 매우 차가웠기 때문에 트래픽의 급증에는 적응이 덜했습니다. 이에 대한 좋은 설명을 아직 찾지 못했습니다.\n\n마지막으로, Node의 server.maxConnections 설정은 여기에서 유용할 것으로 보였지만 (적어도 저에게는 그랬습니다), 실제로는 많은 효용성을 제공하지 않았으며 때때로 오류를 일으켰습니다. 이 설정은 서버가 maxConnections 이상의 새 핸들을 받지 않도록 하여 제한을 초과한 것을 확인한 후 새 핸들을 닫습니다. 이 확인은 JavaScript에서 적용되므로 무한 루프 상황에 대비하지 않습니다 (이벤트 루프로 돌아가면 요청을 올바르게 중단합니다...기다려). 또한 요청이 중단되면서 정상 작동 중에도 이로 인한 연결 오류가 발생했으며 다른 요청이 여러 개 실행 중인 증거는 없었습니다. 이는 연결이 언제 시작하고 끝나는지에 대한 약간의 타이밍 문제 또는 haproxy와 Node 간의 의견 차이로 의심됩니다. 상호 배타적 보증을 보유하는 것은 개발자가 싱글톤 또는 다른 전역 상태를 안전하게 사용할 수 있게 해주는 좋은 것입니다. 이는 익스프레스 미들웨어로 프로세스별 대기열을 구현함으로써 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n서버 측 렌더링은 주로 I/O 워크로드와는 다른 작업 부하를 나타냅니다. 이는 노드(Node)가 뛰어난 부분입니다. 이상적인 동작의 원인을 파악함으로써, 우리는 기존 운영 경험이 있는 제품을 사용하여 문제에 대처했습니다.\n\n에어비앤비에서는 세계적 수준의 프론트엔드 경험 구축에 크게 투자하고 있습니다. 이 글을 읽는 것이 즐거우셨고 이것이 흥미로운 도전이라고 생각하셨다면, 우리는 항상 역량 있는 호기심 많은 분들을 팀에 초대하고 있습니다. 여러분의 소식을 기다립니다!\n\n이 게시물을 검토하고 수정해준 Brian Wolfe, Joe Lencioni, Adam Neary에게 감사드립니다.\n\n## 각주\n\n<div class=\"content-ad\"></div>\n\n- 비동기 렌더링의 경우 여전히 자원 경합이 발생합니다. 비동기 렌더링은 프로세스나 브라우저의 응답성에 중점을 두지만 병렬 처리나 지연을 해결하지는 않습니다. 이 블로그 포스트는 순수 컴퓨팅 작업의 간단한 모델에 초점을 맞출 것입니다. IO 및 컴퓨팅의 혼합된 작업에서 요청 동시성이 증가하면 지연 시간이 증가하지만 더 높은 처리량을 얻을 수 있다는 장점이 있습니다.\n- 유니콘 웹 서버에서 영감을 받아 우리의 Rails 애플리케이션을 제공하는 데 사용합니다. 유니콘 철학은 특히 잘 설명하고 있습니다.\n- 대부분은 반응이 없는 프로세스를 우회하려고 시도합니다.\n- 클러스터는 요청이 아니라 연결을 분배하므로 예기치 않은 동작을 하며, 특히 지속적인 연결을 사용할 때 더 나빠집니다. 클라이언트로부터의 지속적인 연결은 특정한 워커 프로세스에 바인딩되어 있으므로 작업을 효율적으로 분배하기가 더 어려워집니다.","ogImage":{"url":"/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_0.png"},"coverImage":"/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_0.png","tag":["Tech"],"readingTime":15},{"title":"GraphQL 이해하기 효과적인 사용, 장단점 및 TypeScript와 Nodejs로 구현한 실용적인 사례","description":"","date":"2024-06-19 23:06","slug":"2024-06-19-UnderstandingGraphQLEffectivenessProsandConsandaPracticalUseCasewithTypeScriptandNodejs","content":"\n\nAPI에 대한 쿼리 언어인 GraphQL은 데이터 요청을 관리하는 효율성과 유연성으로 개발자들 사이에서 급속히 인기를 얻고 있어요. 2012년 Facebook에서 개발되어 2015년에 오픈 소스 프로젝트로 공개된 GraphQL은 REST에 대한 효율적이고 강력하며 유연한 대안을 제공해요. 이 글에서는 GraphQL의 효과를 탐구하고, 장단점을 살펴보고, TypeScript와 Node.js를 사용한 구체적인 사용 사례를 제시할 거에요.\n\nGraphQL의 효과\n\nGraphQL의 효과는 클라이언트가 정확히 필요한 데이터만 요청할 수 있는 능력에 있어요. 이는 네트워크 상에서 전송되는 데이터 양을 줄이고 애플리케이션의 성능을 최적화해요. 다음은 이 효과를 증진시키는 몇 가지 주요 기능들이에요:\n\n1. 정확한 데이터 가져오기\n\n<div class=\"content-ad\"></div>\n\nGraphQL을 사용하면 클라이언트가 응답 구조를 지정하여 필요한 데이터만 받을 수 있습니다. 이를 통해 과다 검색(필요 이상의 데이터 검색) 및 부족 검색(충분하지 않은 데이터 검색)을 방지할 수 있습니다.\n\n2. 단일 엔드포인트\n\nREST와 달리 데이터를 위해 여러 엔드포인트가 필요한 경우가 많은데, GraphQL은 다양한 리소스에 액세스하기 위해 단일 엔드포인트를 사용합니다. 이는 API를 단순화하고 여러 엔드포인트를 관리하는 복잡성을 줄여줍니다.\n\n3. 강력한 유형 지정 스키마\n\n<div class=\"content-ad\"></div>\n\nGraphQL API는 강력한 유형 시스템을 사용하여 스키마로 정의됩니다. 이 스키마는 클라이언트와 서버 간의 계약 역할을 하며 API와 상호 작용하기 쉽게 만들어줍니다.\n\n4. 구독을 통한 실시간 데이터\n\nGraphQL은 구독을 통해 실시간 데이터를 지원하여 클라이언트가 서버에서 특정 이벤트 발생 시 업데이트를 받을 수 있습니다. 실시간 업데이트가 필요한 애플리케이션에는 채팅 애플리케이션이나 실시간 대시보드 등이 특히 유용합니다.\n\nGraphQL의 장단점\n\n<div class=\"content-ad\"></div>\n\nGraphQL은 많은 이점을 제공하지만 일부 도전 과제도 함께 가지고 있습니다. 이점과 단점을 살펴보겠습니다:\n\n장점\n\n- 효율적인 데이터로딩: 클라이언트는 필요한 것만 요청할 수 있어 대역폭 사용량을 줄이고 성능을 향상시킬 수 있습니다.\n\n- 유연성: GraphQL은 버전 관리 없이 발전할 수 있습니다. 클라이언트는 새로운 필드와 타입을 쿼리할 수 있으며 새로운 API 버전이 필요하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n• 강력한 유형: 스키마는 데이터 유형을 강제하므로 오류를 줄이고 API가 더 예측 가능해집니다.\n\n• 인트로스펙션: GraphQL API는 인트로스펙션할 수 있어서 도구가 자동으로 문서와 클라이언트 라이브러리를 생성할 수 있습니다.\n\n• 개발자 경험: GraphiQL 및 Apollo Client와 같은 도구는 실시간 쿼리 테스트 및 캐싱과 같은 기능으로 개발 경험을 향상시킵니다.\n\n단점:\n\n<div class=\"content-ad\"></div>\n\n• 복잡성: GraphQL의 유연성으로 인해 복잡한 쿼리와 서버 측 리졸버의 복잡성이 증가할 수 있습니다.\n\n• 학습 곡선: REST에 익숙한 개발자들은 GraphQL로 전환할 때 학습 곡선에 직면할 수 있습니다.\n\n• 성능: 최적화되지 않은 GraphQL 쿼리는 데이터베이스 액세스의 N+1 문제와 같은 성능 문제를 일으킬 수 있습니다.\n\n• 캐싱 도전: 전통적인 HTTP 캐싱 전략은 GraphQL에서 덜 효과적이며, 더 정교한 캐싱 메커니즘이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n실용 사례: TypeScript와 Node.js로 GraphQL API 구축하기\n\nGraphQL의 실용적인 사용 사례를 설명하기 위해 TypeScript와 Node.js를 사용하여 간단한 GraphQL API를 구축할 것입니다. 이 API는 책과 저자 목록을 관리할 것입니다.\n\n프로젝트 설정\n\n먼저, 새로운 Node.js 프로젝트를 초기화하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nmkdir graphql-api\ncd graphql-api\nnpm init -y\nnpm install express express-graphql graphql typescript ts-node @types/node @types/express\n```\n\n타입스크립트 구성을 위한 tsconfig.json 파일을 생성하세요:\n\n```js\nimport { buildSchema } from 'graphql';\n\nconst schema = buildSchema(`\n  type Query {\n    books: [Book]\n    authors: [Author]\n  }\n\n  type Book {\n    id: ID!\n    title: String!\n    author: Author!\n  }\n\n  type Author {\n    id: ID!\n    name: String!\n    books: [Book]\n  }\n`);\n\nexport default schema;\n```\n\n리졸버 생성하기\n\n\n<div class=\"content-ad\"></div>\n\n```js\ninterface Book {\n  id: string;\n  title: string;\n  authorId: string;\n}\n\ninterface Author {\n  id: string;\n  name: string;\n}\n\nconst books: Book[] = [\n  { id: '1', title: '1984', authorId: '1' },\n  { id: '2', title: 'Brave New World', authorId: '2' },\n];\n\nconst authors: Author[] = [\n  { id: '1', name: 'George Orwell' },\n  { id: '2', name: 'Aldous Huxley' },\n];\n\nconst resolvers = {\n  books: () => books,\n  authors: () => authors,\n};\n\nexport default resolvers;\n```          \n\n서버 설정하기\n\nExpress 서버를 GraphQL과 함께 설정하기 위해 index.ts 파일을 생성하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport express from 'express';\nimport { graphqlHTTP } from 'express-graphql';\nimport schema from './schema';\nimport resolvers from './resolvers';\n\nconst app = express();\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: resolvers,\n  graphiql: true,\n}));\n\napp.listen(4000, () => console.log('서버가 http://localhost:4000/graphql 주소에서 실행 중입니다.'));\n```\n\n서버 실행\n\n서버를 실행하려면 TypeScript 코드를 컴파일하고 서버를 시작하면 됩니다:\n\n```js\nnpx tsc\nnode dist/index.js\n```\n\n<div class=\"content-ad\"></div>\n\n이제 http://localhost:4000/graphql에 방문하여 GraphiQL을 사용하여 GraphQL API와 상호 작용할 수 있어요.\n\n예시 쿼리\n\n모든 책과 저자를 쿼리할 수 있어요:\n\n```js\n{\n  books {\n    id\n    title\n    author {\n      name\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n아니면 모든 작가와 그들의 책들을 조회할 수도 있습니다:\n\n```js\n{\n  authors {\n    id\n    name\n    books {\n      title\n    }\n  }\n}\n```\n\n결론\n\nGraphQL은 API 디자인에 강력하고 유연한 접근 방식을 제공하여 클라이언트가 필요한 데이터를 정확히 요청할 수 있습니다. 복잡성 및 캐싱 문제와 같은 도전 과제가 있지만, 이러한 단점을 능가하는 이점이 많습니다. TypeScript와 Node.js를 사용하여 개발자는 GraphQL을 활용하여 효율적이고 확장 가능하며 견고한 API를 작성할 수 있으며 개발자 경험과 응용 프로그램 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nFynd Node.js.","ogImage":{"url":"/assets/img/2024-06-19-UnderstandingGraphQLEffectivenessProsandConsandaPracticalUseCasewithTypeScriptandNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-UnderstandingGraphQLEffectivenessProsandConsandaPracticalUseCasewithTypeScriptandNodejs_0.png","tag":["Tech"],"readingTime":5},{"title":"NodeJS 작동 방식 뒷담화부터 전달합니다","description":"","date":"2024-06-19 23:05","slug":"2024-06-19-HowNodeJSWorksBehindtheScenes","content":"\n\n\n![How Node.js Works Behind the Scenes](/assets/img/2024-06-19-HowNodeJSWorksBehindtheScenes_0.png)\n\nNode.js는 Google의 오픈 소스 V8 JavaScript 엔진을 기반으로 한 JavaScript 런타임입니다. 또한 웹 서버로 사용하기에 이상적이며, 서버 측 웹 개발에 JavaScript를 사용할 수 있는 장점을 제공합니다. Node.js는 V8 JavaScript 엔진과 런타임 환경 내의 Libuv와 같은 몇 가지 핵심 라이브러리에 의존합니다.\n\n- V8 엔진은 JavaScript 코드를 컴퓨터가 실제로 이해할 수 있는 기계 코드로 변환합니다.\n- Libuv는 비동기 I/O에 강점을 가진 오픈 소스 라이브러리입니다. 이 레이어를 통해 Node는 기본 컴퓨터 운영 체제, 파일 시스템, 네트워킹 등에 대한 액세스 권한을 얻습니다. 또한 libuv는 Node.js의 두 가지 매우 중요한 기능인 이벤트 루프와 스레드 풀도 구현합니다.\n\n# 스레드 풀\n\n\n<div class=\"content-ad\"></div>\n\n컴퓨터에서 Node를 사용할 때는 해당 컴퓓에서 실행 중인 프로그램을 나타내는 Node 프로세스가 있음을 의미합니다. 이 프로세스 내에서 Node.js는 단일 스레드에서 작동합니다. 이는 Node 애플리케이션을 실행할 때 해당 애플리케이션이 단일 스레드에서 실행된다는 것을 의미합니다. \n\n- 프로그램이 초기화될 때 모든 최상위 코드가 실행되는데, 이는 어떠한 콜백 함수 내부에 있지 않은 모든 코드를 의미합니다.\n- 추가로, 애플리케이션에 필요한 모든 모듈이 로드되고, 모든 콜백이 등록됩니다.\n- 그 다음, 이벤트 루프가 마침내 실행을 시작합니다.\n\n파일 시스템 API, 암호화, 압축 및 DNS 조회와 같은 일부 작업은 이벤트 루프 내에서 실행하기에는 너무 많은 리소스가 필요하거나 비용이 많이 드는 작업이므로 단일 스레드를 차단할 수 있습니다. 이것이 스레드 풀이 필요한 이유입니다. 이 스레드 풀은 이벤트 루프와 마찬가지로 Node.JS에 Libuv 라이브러리로 제공됩니다.\n\n- 스레드 풀은 메인 단일 스레드와 완전히 분리된 4개의 추가 스레드를 제공합니다.\n- Node.js를 최대 128개의 스레드까지 사용하도록 구성할 수 있지만, 대개 4개의 스레드만으로 대부분의 애플리케이션에 충분합니다. 그렇다면 기본 스레드 풀 크기 4를 다른 숫자로 변경하는 방법은 무엇일까요?\n\n<div class=\"content-ad\"></div>\n\n```js\nprocess.env.UV_THREADPOOL_SIZE = 1;\n```\n\n- 그런 다음 이벤트 루프는 무거운 작업을 스레드 풀로 자동으로 오프로드할 수 있습니다. 이 모든 것은 자동으로 백그라운드에서 발생합니다.\n- 개발자는 스레드 풀에 할당할 항목을 결정할 권한이 없습니다.\n\n# 이벤트 루프\n\nNode.js에서는 애플리케이션 내에서 중요한 사건이 발생할 때마다 명명된 이벤트를 방출하는 이벤트 발생자라는 특정 개체가 있습니다. 이 사건에는 서버에 요청이 도착하거나 타이머가 만료되거나 파일이 읽기 작업을 완료하는 등의 중요한 일이 포함될 수 있습니다. 이러한 이벤트는 개발자가 설정한 이벤트 리스너에 의해 수집되며, 각 리스너에 첨부된 콜백 함수가 실행됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst server = http.createServer(); server.on('request',(req,res) => { res.end('Request received'); });\n```\n\n- 서버를 생성하려면 createServer() 메서드를 사용하고 서버 변수에 저장합니다.\n- server.on 메서드는 \"request\" 이벤트를 위해 리스너를 생성하는 데 사용됩니다.\n- 서버는 이벤트를 발생시키는 발신자 역할을 하며 요청이 서버에 도달할 때마다 \"request\" 이벤트를 자동으로 발생시킵니다.\n- 이 리스너에 연결된 콜백 함수는 자동으로 호출됩니다.\n- 함수는 그런 다음 데이터를 클라이언트에 다시 보냅니다.\n\nJavaScript 프로그래밍에서 이벤트 발생자 논리는 관찰자 패턴이라고 합니다. 결론적으로 이벤트 루프는 콜백 실행 및 네트워킹 I/O와 같은 간단한 작업을 처리하는 것을 담당하며, 스레드 풀은 파일 액세스나 압축과 같은 더 많은 작업을 처리합니다.","ogImage":{"url":"/assets/img/2024-06-19-HowNodeJSWorksBehindtheScenes_0.png"},"coverImage":"/assets/img/2024-06-19-HowNodeJSWorksBehindtheScenes_0.png","tag":["Tech"],"readingTime":3},{"title":"자바스크립트의 this 키워드 설명 및 해석하기","description":"","date":"2024-06-19 23:03","slug":"2024-06-19-JavaScriptsthiskeywordexplainedanddemystified","content":"\n\n<img src=\"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_0.png\" />\n\n\"this\" 키워드는 양날의 검이에요. 복잡한 오류의 원인이 될 수도 있고, 실제로 어떻게 작동하는지 알면 개발자로서 여러분에게 삶을 쉽게 만들어 줄 수도 있어요. 요즘에는 커뮤니티가 언어를 더 함수형 패러다임으로 밀고 있어요. \"this\" 키워드를 그렇게 많이 사용하지는 않아요. 그런데 여전히 문맥에 따라 의미가 달라 혼란스러울 수 있어요. 그래서 이 글에서는 \"this\" 키워드를 설명해 실제로 어떻게 작동하는지 잘 이해하도록 도와드릴게요.\n\n# 소개\n\n이 글은 모든 자바스크립트 개발자를 위한 것입니다. 다음을 배울 수 있을 거에요:\n\n<div class=\"content-ad\"></div>\n\n- 자바스크립트에서 this 키워드란 무엇인가요?\n- 노드에서 this 키워드가 나타내는 바는 무엇인가요?\n- 전역 및 함수 실행 컨텍스트에서 this 키워드가 어떻게 결정되나요?\n- 함수가 호출되는 다양한 방법 및 이와 this의 관계\n- call() 및 apply() 메서드를 사용하여 this의 값을 제어하는 방법\n- bind() 메서드를 사용하는 방법\n- 화살표 함수에서 this가 동작하는 방식\n\n# this 키워드란 무엇인가\n\nthis 키워드는 자바스크립트에서 함수가 호출될 때 객체 참조를 저장하는 변수입니다. this 키워드가 참조하거나 가리키는 객체는 사용된 컨텍스트에 따라 달라집니다. 개념적으로, this는 영어 문법의 대명사와 유사합니다. 대명사가 명사를 참조하는 방식처럼 this는 객체를 참조하기 위해 사용됩니다.\n\n예를 들어: “Mary is running fast because she is trying to catch the bus.”\n\n<div class=\"content-ad\"></div>\n\n위 구문에서는 대명사 \"she\"가 선행사 \"Mary\"를 가리키는 데 사용됩니다. 이 개념을 JavaScript의 this 키워드와 연관시켜보겠습니다.\n\n```js\nconst person = { name: \"Mary\",\n                 pronoun: \"she\", \n                 Activity: function () { // this = person\n                     console.log(`${person.name} is running fast because ${this.pronoun} is trying to catch the bus`);\n                 } \n               }\nperson.Activity(); // Mary is running fast because she is trying to catch the bus\n```\n\n위 코드에서 this는 person 객체의 참조값으로 사용되며, 마치 대명사 \"she\"가 \"Mary\"를 가리키는 것처럼 사용됩니다.\n\n# this의 값은 어떻게 결정됩니까?\n\n<div class=\"content-ad\"></div>\n\n`table` 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n글로벌 실행 컨텍스트에서 this 키워드는 웹 브라우저의 창 객체인 글로벌 객체를 참조합니다.\n\n```js\nconsole.log(window === this ) // true this.color = 'Green' console.log(window.color) // Green\n```\n\n위 코드에서는 this 키워드를 사용하여 전역 window 객체에 속성을 추가하고 있습니다.\n\n참고: 전역 실행 컨텍스트에서는 JavaScript가 strict mode 인지 아닌지에 상관없이 this 키워드가 항상 글로벌 객체를 참조합니다.\n\n<div class=\"content-ad\"></div>\n\n## Node.js에서의 'this' 키워드\n\nNode.js 문서에 따르면,\n\n위 문장의 의미는 'this' 키워드가 Node.js에서 전역 객체를 참조하지 않는다는 것입니다. 대신, 현재 사용 중인 모듈을 가리킨다는데요. 즉, module.exports를 통해 내보낸 객체를 가리킵니다.\n\n예를 들어, 가상의 모듈인 app.js를 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\n┣ 📄 app.js \nconsole.log(this); \nmodule.exports.color = 'Green'; \nconsole.log(this);\n```\n\noutput:\n\n```js\n┣ $ node app.js \n{} \n{color: 'Green'}\n```\n\n![JavaScript this keyword explained and demystified](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_1.png)\n\n<div class=\"content-ad\"></div>\n\n위의 코드에서 먼저 app.js 모듈에 module.exports에 값이 없기 때문에 빈 객체가 로깅됩니다. 그런 다음 color 속성이 module.exports 객체에 추가되고, 이를 다시 로깅하면 업데이트된 module.exports 객체가 반환되어 color 속성이 포함됩니다.\n\n## 노드(Node)에서 전역 객체에 액세스하는 방법\n\n이제 우리는 브라우저와 달리 노드에서는 this 키워드가 전역 객체를 참조하지 않는다는 것을 알았습니다. 노드에서는 전역 객체에 global 키워드를 사용하여 액세스하며, 전역 키워드가 사용된 위치와 관계없이 전역 객체에 액세스할 수 있습니다.\n\n```js\n┣ 📄 app.js console.log(global);\n```\n\n<div class=\"content-ad\"></div>\n\n출력:\n\n```js\n┣ $ node app.js // 노드 글로벌 객체를 기록합니다.\n```\n\n<img src=\"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_2.png\" />\n\n글로벌 객체는 노드 환경에 대한 여러 유용한 속성을 노출합니다.\n\n<div class=\"content-ad\"></div>\n\n# 함수 실행 컨텍스트\n\n함수 실행 컨텍스트에서 this 키워드가 어떻게 결정되는지는 함수가 호출되는 방식에 따라 다릅니다.\n\n자바스크립트 함수는 네 가지 방법으로 호출될 수 있습니다:\n\n- 함수로서 호출\n- 메소드로서 호출\n- 생성자로서 호출\n- apply 및 call 메서드를 사용하여 호출\n\n<div class=\"content-ad\"></div>\n\n함수가 호출될 때(즉, 함수가 () 연산자를 사용하여 호출될 때) this는 비엄격 모드에서 전역 창 객체를 참조하고 엄격 모드에서는 undefined로 설정됩니다.\n\n예시\n\n```js\nfunction A() { console.log(this === window) // true }\nfunction B() { \"use strict\" console.log(this === window) // false } function C() { \"use strict\" console.log(this === undefined) // true}\n\nA(); // true\nB(); // false\nC(); // true\n```\n\n함수가 메소드로 호출될 때(즉, 객체 속성을 통해), this는 메소드의 \"소유\" 객체를 참조합니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n```js\nlet Nigeria = { continent: 'Africa', getContinent: function () { return this.continent; } } \nconsole.log(Nigeria.getContinent()); // Africa\n```\n\n함수를 생성자로 호출하려면 함수 호출 앞에 new 연산자를 사용합니다.\n\n예시\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction Context() {return this; } \nnew Context();\n```\n\n함수가 생성자로 호출될 때(new 연산자를 통해) 몇 가지 특별한 동작이 발생합니다:\n\n- 새로운 비어있는 객체가 생성됩니다.\n- 이 객체가 생성자에 this 참조 객체로 전달됩니다. 즉, 함수가 호출될 때 this가 가리키는 객체입니다.\n- 새로 생성된 객체가 new 연산자의 값으로 반환됩니다.\n\n예제\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction Person() { this.name = 'Mary', this.age = 20 }\nconst person1 = new Person(); \nconsole.log(person1.age) // 20\n```\n\n![Reference Image](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_3.png)\n\n위 코드와 다이어그램에서는 함수가 생성자로 호출될 때 this가 객체를 참조하는 방법을 보여주고 설명합니다.\n\nnew 연산자 없이 생성자 함수를 호출하려고 하면 this는 객체가 아니라 undefined를 가리킵니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n```js\nfunction Person() { this.name = 'Mary', this.age = 20 } const person2 = Person(); console.log(person2.age) // // => TypeError: Cannot read property 'age' of undefined\n```\n\nPerson() 함수가 항상 생성자 호출을 통해 실행되도록 하기 위해 Person() 함수 시작 부분에 체크를 추가합니다:\n\n```js\nfunction Person() { if (!(this instanceof Person)) { throw Error('Must use the new operator to call the function'); } \nthis.name = 'Mary',\nthis.age = 20 } \nconst person2 = Person(); console.log(person2.age) // // => Must use the new operator to call the function\n```\n\n<div class=\"content-ad\"></div>\n\nES6에서는 생성자로 호출되었는지 또는 간단하게 호출되었는지를 탐지할 수 있는 new.target이라는 메타 프로퍼티를 도입했습니다.\n\nPerson() 함수를 수정하여 new.target 메타프로퍼티를 사용할 수 있습니다:\n\n```js\nfunction Person() { \nif (!new.target) { throw Error('Must use the new operator to call the function'); }\n this.name = 'Mary', this.age = 20 }\n const person2 = Person(); \nconsole.log(person2.age)\n // => Must use the new operator to call the function\n```\n\n함수는 객체이며, 모든 JavaScript 객체와 같이 메소드가 있습니다. 이 중 두 가지 메소드인 call()과 apply()는 함수를 간접적으로 호출합니다. 이 두 메소드를 사용하면 호출에 대해 명시적으로 this 값(객체 참조)을 지정할 수 있어 어떤 함수든 해당 객체의 메소드로 호출할 수 있습니다. call()과 apply()는 호출에 대한 인수를 지정할 수도 있습니다. call() 메소드는 함수에 대해 자체 인수 목록을 함수의 인수로 사용하며, apply() 메소드는 인수로 사용할 값의 배열을 기대합니다. call() 및 apply() 모두 첫 번째 인수는 함수가 호출될 객체를 나타내는 this 키워드입니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n```js\nfunction getContinent(prefix) { console.log(`${prefix} ${this.continent}`); } \nlet nigeria = { continent: 'Africa' };\nlet china = { continent: 'Asia' }; \ngetContinent.call(nigeria, \"나이지리아는\"); getContinent.call(china, \"중국은\");\n```\n\n출력:\n\n```js\n나이지리아는 Africa 중국은 Asia\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 getContinent() 함수를 간접적으로 호출하기 위해 getContinent() 함수의 call() 메소드를 사용했습니다. call() 메소드의 첫 번째 인자로 nigeria와 china 오브젝트를 전달했기 때문에 각 호출에서 해당 국가의 대륙을 얻었습니다.\n\napply() 메소드는 call() 메소드와 유사하지만, 두 번째 인자로 argument 배열을 사용한다는 것을 이미 알고 계실 것입니다.\n\n```js\ngetContinent.apply(nigeria, [\"나이지리아는\"]); getContinent.apply(china, [\"중국은\"]);\n```\n\nOutput:\n\n<div class=\"content-ad\"></div>\n\n```js\n나이지리아는 아프리카에 있고 중국은 아시아에 있습니다.\n```\n\n화살표 함수에서 JavaScript는 this를 렉시컬하게 설정합니다. 이는 화살표 함수 내부의 this 값이 가장 가까운 \"비-화살표\" 함수에 의해 정의된다는 것을 의미합니다. 또한, 화살표 함수 내부에서 this의 값은 변경할 수 없습니다. 이는 함수의 전체 수명 주기 동안 동일한 상태를 유지합니다.\n\n몇 가지 예시를 살펴봅시다:\n\n```js\nlet getThis = () => this; console.log(getThis() === window); // true\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 this 값이 전역 객체인 즉, 웹 브라우저의 창 객체로 설정됩니다. 스택과 힙을 이용해 이전 코드를 더 자세히 이해해 봅시다.\n\n![이미지](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_4.png)\n\n- getThis 화살표 함수는 전역 window 객체를 반환하는 Global() \"non-arrow\" 함수에 렉시컬 스코프를 갖습니다.\n- getThis 화살표 함수 내의 this 값은 해당 객체를 가리키는 함수의 this 값이 렉시컬로 스코프된 것이므로 전역 window 객체입니다.\n\n다른 예시를 살펴보죠:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction confirmThis () { let getThis = () => this; console.log(getThis() === window); // true } confirmThis();\n```\n\n결과:\n\n일반 함수의 this 값은 \"비 엄격 모드\"에서 전역 window 객체를 가리킨다. this 값은 confirmThis() 함수의 렉시컬 스코프에 바인딩되므로 window 객체를 가리킬 것이다. 그러나 \"엄격\" 모드에서는 상황이 다릅니다.\n\n```js\nfunction confirmThis () { \"use strict\"; let getThis = () => this; console.log(getThis() === window); // true } confirmThis();\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 strict 모드에서 confirmThis() 함수의 this 값이 undefined로 설정되며, getThis 화살표 함수도 마찬가지입니다.\n\n예시\n\n```js\nconst module = { x: 42, getX: function() { return this.x; } };\nconst unboundGetX = module.getX; console.log(unboundGetX());\n// 함수는 전역 범위에서 실행됩니다\n// 기대 출력: undefined\nconst boundGetX = unboundGetX.bind(module); console.log(boundGetX()); // 기대 출력: 42\n```\n\n<div class=\"content-ad\"></div>\n\n앞선 코드에서는 모듈 객체의 메서드인 getX()이 전역 범위에서 \"함수\"(대신 모듈의 메서드로)로 호출됩니다. 이로 인해 이 참조가 모듈 객체에서 누락됩니다. getX 메서드가 \"함수\"로 호출될 때 이 참조가 여전히 모듈 객체를 가리키게 하려면 bind() 메서드를 통해 모듈 객체에 \"바인딩\"되어야 합니다. - const boundGetX = unboundGetX.bind(module);.\n\n# 결론\n\n이제 이 키워드가 어떻게 작동하는지와 적용되는 다양한 컨텍스트를 알게 되었습니다. 필요한 경우 편안하게 사용할 수 있을 것입니다.\n\n# 요약\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 다음을 배웠습니다:\n\n- JavaScript에서 this 키워드가 무엇인지에 대해 알게 되었습니다.\n- Node에서 this 키워드가 무엇을 나타내는지에 대해 알게 되었습니다.\n- 전역 및 함수 실행 컨텍스트에서 this 키워드가 어떻게 결정되는지에 대해 알게 되었습니다.\n- 함수가 호출되는 다양한 방법 및 this와의 관련성에 대해 알게 되었습니다.\n- call() 및 apply() 메소드를 사용하여 this의 값을 제어하는 방법에 대해 알게 되었습니다.\n- bind() 메소드를 사용하는 방법에 대해 알게 되었습니다.\n- 화살표 함수에서 this의 동작 방식에 대해 알게 되었습니다.\n\n# 용어 해설\n\nStack 또는 CallStack: 스택은 후입선출(LIFO) 원칙을 따르는 데이터 구조입니다. 그러나 실행 스택은 코드 실행 중에 생성된 모든 실행 컨텍스트를 추적하는 스택입니다. 또한 스택은 JavaScript에서 정적 데이터(변수 및 참조 값)를 저장합니다. 자세히 알아보세요.\n\n<div class=\"content-ad\"></div>\n\n힙: 힙은 JavaScript에서 동적 데이터를 저장하는 데 사용되는 데이터 구조입니다. 이 곳에는 모든 JavaScript 객체가 저장됩니다. 더 알아보려면 [여기](링크)를 확인해보세요.\n\n렉시컬 스코프: 보다 잘 이해하기 위해 [스택 오버플로우 답변](링크)을 참고하십시오.\n\nJavaScript 엄격 모드: [MDN](링크)\n\n![이미지](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_5.png)","ogImage":{"url":"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_0.png"},"coverImage":"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_0.png","tag":["Tech"],"readingTime":10},{"title":" Nx Affected에 대한 심층 탐구","description":"","date":"2024-06-19 23:00","slug":"2024-06-19-DeepDiveintoNxAffected","content":"\n\n## 모놀리포의 Nx 영향을 이해하고 최적화하기\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_0.png)\n\n- 😵‍ 왜 이대로 내버려둔 프로젝트가 영향을 받는가?\n- 🤓 영향 받은 요소\n  - 영향 받은 프로젝트\n  - 영향 받은 작업\n- 🤩 영향 받은 명령\n  - 영향 받은 실행\n  - 명령 표시\n  - Nx 그래프\n- 😶‍🌫️ 영향 받은 규칙\n  - 단계 1 - 터치된 파일 찾기\n  - 단계 2.1 - 경로별 영향 받는 노드 찾기\n  - 단계 2.2 - 작업별 영향 받는 노드 찾기\n  - 단계 2.3 - 플러그인별 영향 받는 노드 찾기\n  - 단계 2.4 - Npm 의존성으로부터 영향 받는 노드 찾기\n  - 단계 2.5 - TypeScript 구성에서 영향 받는 노드 찾기\n  - 단계 2.6 - 글로벌 파일에서 영향 받는 노드 찾기\n  - 단계 3 - 영향 받는 그래프 생성\n- 🧐 영향 조사\n  - Nx 그래프 사용\n  - 디버깅\n- 🤕 영향 해결\n  - 앱/라이브러리를 잘 분리\n  - 엄격한 명명된 입력\n  - 영향 수정\n  - Nx 패치\n- 🙂 마지막으로\n\n# 😵‍ 왜 이대로 내버려둔 프로젝트가 영향을 받게 되었을까?\n\n<div class=\"content-ad\"></div>\n\n이 질문은 매일 듣는 질문입니다! 이 질문은 제가 Nx Affected 프로세스의 디버깅 세션으로 많은 시간을 소비하게 한 질문입니다.\n\n본 문서에서는 Nx의 영향을 받는 프로세스가 어떻게 작동하는지 이해하는 데 필요한 모든 통찰력을 제공하여 그 질문에 대한 답변을 도와드리겠습니다.\n\n# 🤓 영향 프로세스 알림\n\nMonorepo에서 큰 코드베이스에서 작업할 때 여러 응용 프로그램과 라이브러리를 포함하는 저장소가 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n당신의 Monorepo가 성장함에 따라 CI에서 모든 앱/라이브러리를 재빌드하는 데 시간이 오래 걸릴 수 있습니다. 영향을 받는 앱/라이브러리만 다시 실행할 수 있는 능력은 소프트웨어 개발 주기를 크게 단축시킬 수 있습니다.\n\n## 영향을 받는 프로젝트\n\n앱/라이브러리를 수정하면 해당 앱/라이브러리 및 이에 종속된 다른 모든 앱/라이브러리에도 영향을 줍니다:\n\n![영향을 받는 프로젝트](/assets/img/2024-06-19-DeepDiveintoNxAffected_1.png)\n\n<div class=\"content-ad\"></div>\n\n앱/라이브러리 간의 종속성을 이해하기 위해 Nx는 모든 노드(앱/라이브러리), 외부 노드(npm) 및 그들 간의 모든 종속성을 포함한 프로젝트 그래프를 생성합니다.\n\n## 영향 받는 작업\n\n전체 앱/라이브러리에 대한 수정의 영향을 고려하는 것만으로 충분하지 않습니다. 예를 들어, 앱 내의 테스트를 변경한다고 해서 그 앱 전체를 다시 빌드해야 하는 것은 아닙니다. 테스트만 다시 실행하면 됩니다:\n\n![Afftected Task](/assets/img/2024-06-19-DeepDiveintoNxAffected_2.png)\n\n<div class=\"content-ad\"></div>\n\n앱/라이브러리 간 작업 종속성을 이해하기 위해 Nx는 작업에 의해 앱/라이브러리가 연결된 노드로 Task Graph를 생성합니다.\n\n## 🤩 영향을 받는 명령어\n\nNx는 어떤 프로젝트/작업이 영향을 받았는지 식별하는 여러 방법을 제공합니다.\n\n### 영향을 받는 실행\n\n<div class=\"content-ad\"></div>\n\n주로 CI에서 사용하는 주요 명령어는 Nx 영향을 받는 명령어입니다:\n\n```js\nnx affected -t lint test build\n```\n\n![Deep Dive into Nx Affected](/assets/img/2024-06-19-DeepDiveintoNxAffected_3.png)\n\n이 명령어를 사용하면 영향을 받는 작업 목록만 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Show Command\n\n또 다른 유용한 명령어는 직접적인 개요를 얻을 수 있는 Nx show 명령어입니다:\n\n```js\nnx show projects --affected\n```\n\n<img src=\"/assets/img/2024-06-19-DeepDiveintoNxAffected_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 명령은 콘솔에서 영향을 받는 프로젝트/작업을 직접 확인하고 결과를 JSON 파일로 내보내는 것을 가능하게 합니다.\n\n## Nx 그래프\n\n만약 영향을 받는 프로젝트/작업의 경로를 추적하고 UI 시각화가 필요하다면, 다음 명령을 사용하여 Nx 그래프를 열 수 있습니다:\n\n```js\nnx graph --affected\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식의 코드입니다.\n\n\n![이미지1](/assets/img/2024-06-19-DeepDiveintoNxAffected_5.png)\n\n그래프를 확인할 수 있는 웹 페이지가 열립니다:\n\n![이미지2](/assets/img/2024-06-19-DeepDiveintoNxAffected_6.png)\n\n## 😶‍🌫️ 영향 받는 규칙\n\n\n<div class=\"content-ad\"></div>\n\nNx 영향을 받는 프로세스는 여러 단계를 거치며 어떤 프로젝트가 영향을 받을 수 있는지 결정하기 위해 여러 파일 및 구성을 고려합니다:\n\n![Nx 영향 받은 내용 탐색](/assets/img/2024-06-19-DeepDiveintoNxAffected_7.png)\n\n## 단계 1 - 변경된 파일 찾기\n\nNx는 영향을 받는 프로젝트의 목록을 계산하기 전에 수정/변경된 파일 목록을 로드합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_8.png)\n\nNx는 대상 영향을 받은 베이스 이후의 수정된 파일을 계산합니다.\n\n기본적으로 베이스는 기본 브랜치이지만, -base 및 -head 옵션을 사용하여 수정할 수 있습니다.\n\n아직 커밋되지 않거나 추적되지 않은 모든 수정된 파일도 추가됩니다. -uncommitted 또는 -untracked 옵션을 사용하여 동작을 변경할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n만약 Nx에게 파일 목록을 계산하지 않았으면, -files 옵션을 사용하여 직접 파일 목록을 제공할 수 있습니다.\n\n.gitignore 또는 .nxignore에서 패턴과 일치하는 파일들은 무시됩니다.\n\n## 단계 2.1 - 경로에서 영향을 받는 노드 찾기\n\n모든 변경된 파일이 정의되었을 때, Nx는 해당 파일들이 프로젝트에 어떻게 영향을 줄 수 있는지 확인합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_9.png)\n\n가장 일반적인 규칙은 파일 경로가 프로젝트 루트 경로와 일치하는지 확인하는 것입니다.\n\n## 단계 2.2 - 작업에서 영향을받는 노드 찾기\n\nNx 작업을 실행할 때 두 가지 개념이 고려됩니다:\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-DeepDiveintoNxAffected_10.png)\n\n- 작업 실행 중에 소스 자산을 정의하는 데 사용되는 입력입니다.\n- Nx에 의해 캐시되는 작업 결과인 출력입니다.\n\n자바스크립트의 순수 함수와 유사하게, 입력이 변경되지 않았다면 출력도 동일해야 합니다.\n\n입력 목록을 재사용하기 쉽게 하려면 nx.json 또는 project.json에서 Named Inputs를 사용하여 정의할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  \"namedInputs\": {\n    \"default\": [\"{projectRoot}/**/*\", \"sharedGlobals\"], // 기본 입력값\n    \"production\": [\"default\", \"!{projectRoot}/jest.config.ts\"], // 프로덕션 입력값\n    \"sharedGlobals\": [] // 공유 전역 입력값\n  }\n}\n```\n\n그런 다음, 해당 값을 nx.json 또는 project.json의 대상 또는 실행기에 할당하십시오:\n\n```js\n\"targetDefaults\": {\n  \"build\": {\n    \"inputs\": [\"production\", \"^production\"]\n  },\n  \"test\": {\n    \"inputs\": [\"default\", \"^production\", \"{workspaceRoot}/jest.preset.js\"],\n  },\n}\n```\n\n파일을 변경하더라도 해당 작업 목록에는 영향을 미치지 않습니다:\n\n<div class=\"content-ad\"></div>\n\n아래 이미지를 확인해주세요👇\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_11.png)\n\n만약 파일을 터치하면, 영향을 받는 프로젝트 목록은 각 작업/실행자의 입력 구성에 따라 달라집니다.\n\n## 단계 2.3 - 플러그인에서 영향 받은 노드 찾기\n\nNx 프로젝트 크리스털과 추론된 구성을 통한 Nx 플러그인의 일반화로 인해 Nx는 플러그인 패턴이 터치된 파일 목록에 영향을 받는지도 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-DeepDiveintoNxAffected_12](/assets/img/2024-06-19-DeepDiveintoNxAffected_12.png)\n\n예를 들면, 파일을 삭제하거나 이동하면 Nx는 해당 프로젝트가 삭제되었다고 가정하고 모든 프로젝트를 영향을 받는 것으로 표시합니다.\n\n## 단계 2.4 - Npm 종속성에서 영향받는 노드 찾기\n\n만약 package.json이 수정되면, Nx는 어떤 것이 정확히 변경되었는지 이해하기 위해 스마트한 접근법을 사용합니다.\n\n\n<div class=\"content-ad\"></div>\n\n만약 npm 라이브러리를 수정한다면, Nx는 해당 라이브러리를 사용하는 모든 프로젝트를 찾아서 영향을 받는 것으로 표시합니다. 만약 @types/* 라이브러리를 수정한다면, Nx는 관련 라이브러리를 추출하여 동일한 원리로 라이브러리를 수정하는 것과 같은 원리를 적용합니다.\n\n만약 nx.json 플러그인에서 사용하는 라이브러리를 수정하거나 삭제한다면, 모든 프로젝트가 영향을 받는 것으로 간주됩니다:\n\n![image](/assets/img/2024-06-19-DeepDiveintoNxAffected_13.png)\n\n기본적으로 패키지 매니저 락 파일을 수정하는 것은 모든 프로젝트에 영향을 줍니다:\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 표현해 보겠습니다.\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_14.png)\n\n이 동작은 nx.json 파일의 projectsAffectedByDependencyUpdates를 사용하여 수정할 수 있습니다:\n\n```js\n\"pluginsConfig\": {\n    \"@nx/js\": { \n        \"projectsAffectedByDependencyUpdates\": \"auto\"\n    }\n}\n```\n\n옵션:\n\n<div class=\"content-ad\"></div>\n\n- 모든: 모든 프로젝트에 영향을 미칩니다.\n- 자동: 수정된 종속성과 관련된 프로젝트에만 영향을 줍니다.\n- 문자열[]: 프로젝트 목록을 정의합니다.\n\n## 단계 2.5 - TypeScript 구성에서 영향 받는 노드 찾기\n\n전역 TypeScript 구성을 수정하면 영향을 받는 노드 목록도 변경될 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_15.png)\n\n<div class=\"content-ad\"></div>\n\n만약 경로가 수정되면, Nx는 루트 경로와 일치하는 관련 프로젝트에 영향을 줍니다. 그러나 전역 구성을 수정하거나 경로를 삭제할 경우 모든 프로젝트에 영향을 줍니다.\n\n## 단계 2.6 - 글로벌 파일로부터 영향을 받는 노드 찾기\n\n기본적으로 nx.json을 수정하면 모든 프로젝트에 영향을 줍니다.\n\n![Nx Affected](/assets/img/2024-06-19-DeepDiveintoNxAffected_16.png)\n\n<div class=\"content-ad\"></div>\n\n## 단계 3 - 영향을 받은 그래프 생성\n\n영향을 받는 모든 노드를 식별한 후에, Nx는 영향을 받는 노드, 외부 노드 및 종속성이 최종적으로 영향을 받는지 확인하기 위해 영향을 받는 그래프를 생성합니다.\n\nNx는 영향을 받는 노드를 가져와 프로젝트 그래프의 모든 종속성을 재귀적으로 검색합니다:\n\n![Afftected Graph Example](/assets/img/2024-06-19-DeepDiveintoNxAffected_17.png)\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 영향을 받는 노드인 lib10이 lib4에서 사용되고 lib4는 app1에서 사용된다면, 이 모든 노드가 영향 받는 프로젝트 그래프에 추가됩니다.\n\nNx는 externalNodes에도 동일한 원칙을 적용합니다:\n\n![image](/assets/img/2024-06-19-DeepDiveintoNxAffected_18.png)\n\n예를 들어, 영향을 받는 npm 라이브러리인 enquirer가 npm 라이브러리인 nx에 의해 사용되고 nx가 내부 라이브러리 tools에 사용되는 경우입니다.\n\n<div class=\"content-ad\"></div>\n\n지금까지 영향을 받는 그래프가 완전한지 확인하려면 Nx가 관련 종속성을 추가할 것입니다.\n\n# 🧐 영향 분석\n\n여전히 특정 브랜치에서 일부 프로젝트가 영향을 받는 이유를 모르겠다면 언제든지 Nx 영향 프로세스를 디버깅할 수 있습니다.\n\n## Nx 그래프 사용하기\n\n<div class=\"content-ad\"></div>\n\n만약 영향을 받는 명령어로 Nx 그래프를 열면, 🤓 영향을 받는 프로젝트 섹션에 명시된 대로 모든 영향을 받는 프로젝트를 볼 수 있습니다.\n\n그런 다음 워크스페이스를 탐색하고 프로젝트 포커스나 의존성 추적기와 같은 여러 기능을 사용할 수 있습니다.\n\n## 디버깅\n\n그러나 대규모 저장소의 경우, 그래프는 디버깅에 사용하기 어려울 수 있습니다. 제가 선호하는 방법은 Nx-affected 프로세스를 디버깅하여 정확히 어떤 단계가 책임을 지고 있는지를 확인하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n패키지/nx/src/command-line/affected/affected.ts에서 중단점을 설정하고 디버그 모드에서 nx show project --affected를 실행해보세요.\n\n# 🤕 영향을 받는 수정 사항\n\n영향을 받는 프로세스를 사용자 정의하는 것은 간단하지 않습니다. 각 수정에 너무 많은 프로젝트가 영향을 받는다고 생각한다면 몇 가지 권장 사항을 살펴보세요:\n\n## 어플리케이션/라이브러리의 잘 구분된 분리\n\n<div class=\"content-ad\"></div>\n\n앱/라이브러리를 정확히 분할했는지 확인해 주세요.\n\n자주 사용되는 라이브러리는 한 프로젝트에서 필요로 하는 유틸리티들로 구성될 수 있습니다. 이런 경우 라이브러리를 수정하는 것이 모든 프로젝트에 영향을 줄 수 있습니다.\n\n## 엄격한 Named Inputs\n\nNamed Inputs가 올바르게 구성되었는지 확인하세요. Named Inputs는 파일을 수정했을 때 해당 대상의 출력에 영향을 줄 수 있는지를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 스펙 파일을 수정하면 테스트에 영향을 미칠 수 있지만 빌드에는 영향을 주지 않을 수 있습니다. 기본 명명된 입력을 사용하면 한 파일을 수정하면 프로젝트의 모든 대상에 영향을 줄 수 있습니다.\n\n## 영향을 받는 사용자 정의\n\n현재, 영향을 받는 프로세스에 대한 사용자 정의가 제한적으로 제공됩니다. 의존성을 업데이트할 때 configuration projectsAffectedByDependencyUpdates를 사용하여 사용자 정의할 수 있습니다(Step 2.4 — Npm Dependencies로부터 영향을 받는 노드 찾기).\n\n## Nx 패치\n\n<div class=\"content-ad\"></div>\n\n이것은 조작적인 해결책이지만, 나는 영향을 받는 프로세스를 사용자 정의하기 위해 그것을 사용합니다. 패키지 관리자의 패치 시스템을 사용하여 Nx 라이브러리를 패치하여 규칙을 변경할 수 있습니다.\n\n예를 들어, 수정하는 데 시간이 걸리는 경우 \"Affected All\" 사용 사례를 비활성화할 수 있습니다:\n\n```js\ndiff --git a/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js b/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js\nindex 72e78e7..7793bea 100644\n--- a/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js\n+++ b/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js\n@@ -20,7 +20,8 @@ const getTouchedNpmPackages = (touchedFiles, _, nxJson, packageJson, projectGrap\n             c.path.length === 2) {\n             // 패키지가 삭제되었으므로 모든 워크스페이스 프로젝트를 터치로 표시합니다.\n             if (c.type === json_diff_1.JsonDiffType.Deleted) {\n-                touched = Object.keys(projectGraph.nodes);\n+                // 패키지가 삭제된 경우 영향을받은 모든 프로젝트에 적용하지 않도록 패치\n+                // touched = Object.keys(projectGraph.nodes);\n                 break;\n             }\n             else {\ndiff --git a/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js b/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js\nindex bac7008..37ae136 100644\n--- a/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js\n+++ b/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js\n@@ -24,7 +24,8 @@ const getTouchedProjectsFromTsConfig = (touchedFiles, _a, _b, _c, graph) => {\n         }\n         // 경로가 삭제된 경우 모든 것이 터치됩니다\n         if (change.type === json_diff_1.JsonDiffType.Deleted) {\n-            return Object.keys(graph.nodes);\n+            // 경로가 삭제된 경우 영향을 받은 모든 프로젝트에 적용하지 않도록 패치\n+            // return Object.keys(graph.nodes);\n         }\n         touched.push(...getProjectsAffectedByPaths(change, Object.values(graph.nodes)));\n     }\ndiff --git a/node_modules/nx/src/project-graph/affected/affected-project-graph.js b/node_modules/nx/src/project-graph/affected/affected-project-graph.js\nindex 5665c8d..d5a69aa 100644\n--- a/node_modules/nx/src/project-graph/affected/affected-project-graph.js\n+++ b/node_modules/nx/src/project-graph/affected/affected-project-graph.js\n@@ -12,7 +12,8 @@ async function filterAffected(graph, touchedFiles, nxJson = (0, configuration_1.\n     const touchedProjectLocators = [\n         workspace_projects_1.getTouchedProjects,\n         workspace_projects_1.getImplicitlyTouchedProjects,\n-        project_glob_changes_1.getTouchedProjectsFromProjectGlobChanges,\n+        // 플러그인 패턴 일치 변경 파일에 영향을주지 않도록 패치\n+        // project_glob_changes_1.getTouchedProjectsFromProjectGlobChanges,\n         touched_projects_1.getTouchedProjects,\n     ];\n     const touchedProjects = [];\ndiff --git a/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js b/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js\nindex c5aec64..edaa989 100644\n--- a/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js\n+++ b/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js\n@@ -16,7 +16,8 @@ const getTouchedProjects = (touchedFiles, projectGraphNodes) => {\n exports.getTouchedProjects = getTouchedProjects;\n const getImplicitlyTouchedProjects = (fileChanges, projectGraphNodes, nxJson) => {\n     const implicits = {\n-        'nx.json': '*',\n+        // nx.json이 변경된 경우 영향을받은 모든 파일에 적용하지 않도록 패치\n+        // 'nx.json': '*',\n     };\n     Object.values(projectGraphNodes || {}).forEach((node) => {\n         const namedInputs = {\n```\n\n# 🙂 마지막으로 생각해보세요\n\n<div class=\"content-ad\"></div>\n\n보시다시피, 영향을 받는 프로세스는 수정된 파일 목록을 고려하는 것뿐만 아니라 다른 여러 요소를 기반으로 프로젝트 목록을 계산합니다.\n\n이로 인해 조사가 항상 간단하지는 않고 종종 영향을 받는 모든 상황으로 이어질 수 있습니다.\n\n일부 부분을 명확히 하고 영향을 받는 프로세스를 더 잘 이해하기 위한 핵심을 제공했기를 바랍니다.\n\n미래에는 종속성 업데이트에 의해 영향을 받는 프로젝트와 같은 옵션 목록을 일반화하여 영향을 받는 프로세스에 대한 더 많은 사용자 정의 옵션이 있기를 희망합니다.\n\n<div class=\"content-ad\"></div>\n\n곧 시작됩니다 🚀\n\n# 관련된","ogImage":{"url":"/assets/img/2024-06-19-DeepDiveintoNxAffected_0.png"},"coverImage":"/assets/img/2024-06-19-DeepDiveintoNxAffected_0.png","tag":["Tech"],"readingTime":13},{"title":"골프 클럽 헤드 속도를 측정하는 장치를 위한 펌웨어를 개발했어요","description":"","date":"2024-06-19 22:58","slug":"2024-06-19-IDevelopedFirmwareforaDeviceThatMeasuresGolfClubHeadSpeed","content":"\n\n## 프로그래밍\n\n![이미지](/assets/img/2024-06-19-IDevelopedFirmwareforaDeviceThatMeasuresGolfClubHeadSpeed_0.png)\n\n저는 프로그램 개발의 어려움을 보여주는 경험을 여러분과 공유하고 싶습니다. 이 경험은 프로젝트의 규모나 사용된 프로그래밍 언어와 무관하게 여전히 적용 가능하다고 믿기 때문입니다.\n\n이 클라이언트는 아마도 중소 규모의 비상장 회사였습니다. 따라서 예산이 많은 회사와 비교하여 예산이 적었고, 이 프로젝트에는 하드웨어 엔지니어 한 명과 펌웨어 엔지니어인 저 한 명이 참여했습니다.\n\n<div class=\"content-ad\"></div>\n\n어쭈도 골프 경험이 없었지만, 마스터스 토너먼트와 영국 오픈을 즐겁게 관람할 만큼 관련 정보는 알고 있었어요.\n\n시스템은 매우 간단해요. 골프공을 놓을 티와 LED 및 광 센서 두 세트로 구성되어 있어요 (다이어그램을 참고해주세요; 조금 별로에요). 이 시스템은 골프 클럽 헤드가 센서 A를 통과하는 데 걸리는 시간과 센서 B가 공을 쳤음을 감지하는 시간을 측정해요.\n\n## 펌웨어 소프트웨어로서:\n\n- 골프공이 티에 놓이고 센서 B가 그림자에 가려지면, 센서는 측정 대기 상태로 전환돼요.\n- 타이머는 클럽 헤드가 센서 A를 가려는 순간부터 시작돼요.\n- 헤드가 공을 치고 센서 B가 드러날 때, 타이머는 멈추고 PC에 시간을 알려주어요.\n\n<div class=\"content-ad\"></div>\n\n그거 다야. \n\n나는 기술대학의 첫 번째 프로그래밍 과제로서 충분히 도전적일 것 같아. 그리고 화면을 통해 디버깅할 방법이 없었기 때문에, OS나 개발 환경이 없었어.\n\n장치에서 실행하기 위해서는 코드를 ROM 라이터로 ROM에 작성해야 했기 때문에 이를 작동시키려고 애를 쓰곤 했어. 그래도 난 골프 채가 없었고 공을 한 번도 쳐본 적이 없었기 때문에 신문지를 말아 골프공 모양을 만들고, 손을 채로 이용해 말아진 신문지를 쳐보고 작동 여부를 확인했지.\n\n그때 이 제품 아이디어를 냈던 경영진이 우연히 지나가더니, 그가 직접 클럽으로 골프공을 치기로 결정해버렸어.\n\n<div class=\"content-ad\"></div>\n\n클럽을 기뻐하며 가져가 공을 놓았어요. 우리가 공을 치기 전에 큰 실수를 저질렀다는 것을 깨달았고, 문제가 있다고 공식에게 말하고 테스트를 멈추었어요.\n\n볼을 치기 전에 클럽 머리를 공 옆에 두어 접촉하도록 해요. 이 과정은 한 번만 하지만, 공식은 머리를 공 옆에 두고 두세 번 움직여요.\n\n우리 시스템은 센서 B가 첫 번째 주소의 빛에 의해 가려질 때부터 측정을 시작하고 해당 주소 액션 동안 시간을 측정하기 때문에, 머리 속도만을 고려하는 게 아니에요.\n\n해결책은 간단했어요. 센서 B가 어느 정도의 시간(약 0.5초라고 생각해요) 동안 빛에 가려지고 공이 치워지지 않으면 리셋되어 측정을 위해 대기 상태로 들어갔어요.\n\n<div class=\"content-ad\"></div>\n\n그래서 누가 잘못했었나요?\n\n그것이 옳은 일이 될 수도 있지만, 저는 그것이 매우 어려운 일이라고 생각해요. 비즈니스 시스템이나 웹 프론트 엔드든, 우리는 핵심 요구 사항을 알고 있지만 의식적으로 인식되지 않는 시스템 개발에 필수적인 숨겨진 요구 사항이 항상 있다고 생각해요.\n\n그것들을 \"잠재 의식적 요구 사항\"이라고 불러보는 것이 더 좋을 수도 있어요. 본 영업에 관해서는 우리 의식의 큰 부분이지만, 무의식적으로 작은 세부 사항을 다루는 것은 인간에게도 큰 장점이 되요.\n\n이 시스템은 골프 매장을 위한 시스템의 일부 였는데, 충격 시 클럽이 비틀리는 정도를 측정하고 각 골퍼에게 가장 적합한 클럽 유형을 결정해요. 만약 우리 중 한 명이 골프 애호가였다면, 이것을 깨달았을 수도 있었지만, 이런 상황은 거의 발생하지 않아요. 매 우리와 시스템 고객 사이에 일어나는 건드림이 나지 않을 때요.\n\n<div class=\"content-ad\"></div>\n\n시스템을 개발할 때 중요 요구사항과 상세 요구사항은 인간에게 동일한 의미를 갖고 있다고 할 수 있으며, 종종 중요 요구사항이 충족되지 않으면 만족시킬 수 없다는 경우가 많습니다.\n\n소프트웨어 개발의 어려움은 \"잠재적 요구사항\"의 존재에 있지 않을까 싶습니다.\n\n믿을 만한 각종 시스템 분석 방법이나 개발 방법(예: agile 방법)이 결국은 근본적인 요구사항을 명확히 하는 방법에 종속되어 있다고 생각해요.\n\n# 간단한 문장으로 설명하기 🚀\n\n<div class=\"content-ad\"></div>\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클립하고 팔로우해주세요 ️👏️️\n- 저희를 팔로우해주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-06-19-IDevelopedFirmwareforaDeviceThatMeasuresGolfClubHeadSpeed_0.png"},"coverImage":"/assets/img/2024-06-19-IDevelopedFirmwareforaDeviceThatMeasuresGolfClubHeadSpeed_0.png","tag":["Tech"],"readingTime":3},{"title":"시니어 개발자로서 꽁수 잘부리는데 꼭 알아야 할 10가지 JavaScript 배열 함수","description":"","date":"2024-06-19 22:56","slug":"2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev","content":"\n\n![이미지](/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_0.png)\n\n복잡한 웹 개발 프로젝트 중간에 있다고 상상해보세요. 여러 API에서 데이터가 들어오고, 그 데이터를 효율적으로 처리, 필터링 및 분석하는 것이 여러분의 임무입니다. 시간이 촉박하기 때문에 코드 한 줄 한 줄이 중요합니다.\n\n이런 때에 고급 JavaScript 배열 메서드를 배워두면 정말 도움이 됩니다.\n\n이러한 함수들은 코드를 줄이는데 그치지 않고 성능을 개선하고 개발 기술을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n시니어 개발자라면 복잡한 작업을 빠르고 정확하게 수행할 수 있도록 알아야 하는 상위 열 가지 배열 함수를 살펴보겠습니다.\n\n![array functions](https://miro.medium.com/v2/resize:fit:1400/1*zW-nrCob0sk8V4zQYCRXTQ.gif)\n\n# 필수 10가지 배열 함수\n\n## 1. forEach()\n\n<div class=\"content-ad\"></div>\n\n당신은 배열의 각 항목을 방문하고 설정한 작업을 완료하는 신뢰할만한 도우미가 필요할 수 있습니다. 이것이 forEach()의 개요입니다.\n\n각 요소에서 실행되는 콜백 함수를 사용하므로 로깅, DOM 수정 및 데이터 조작과 같은 부작용에 적합합니다.\n\n```js\nconst fruits = [\"사과\", \"바나나\", \"체리\"];\n\nfruits.forEach(fruit => console.log(fruit));\n```\n\n## 2. map()\n\n<div class=\"content-ad\"></div>\n\n현재 배열을 기반으로 한 새로운 배열이 필요하다면 어떨까요? map() 함수는 각 요소에 콜백 함수를 적용한 결과로 새로운 배열을 생성합니다.\n\n이 함수는 데이터 세트를 추출하고 데이터를 제공하며 계산을 수행하는 데 완벽합니다.\n\n```js\nconst numbers = [1, 2, 3, 4];\n\nconst doubledNumbers = numbers.map(number => number * 2);\nconsole.log(doubledNumbers);\n\n// 출력 [2, 4, 6, 8]\n```\n\n## 3. filter()\n\n<div class=\"content-ad\"></div>\n\n특정 요소만 VIP 영역에 접근할 수 있도록 확인하는 상황을 상상해 보세요. filter()는 콜백 함수 기반 테스트를 통과하는 항목만 포함된 새 배열을 생성합니다.\n\n기준을 사용하여 데이터를 필터링하거나 원치 않는 항목을 제거하거나 사용자 지정 부분 배열을 만들 때 사용할 수 있습니다.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\n\nconst evenNumbers = numbers.filter(number => number % 2 === 0);\nconsole.log(evenNumbers); \n\n// 결과 [2, 4]\n``` \n\n## 4. reduce()\n\n<div class=\"content-ad\"></div>\n\n`reduce()`은 전체 배열을 단일 값으로 통합해주는 무술 마스터입니다. 콜백 함수를 사용하여 작동합니다.\n\n이 함수는 매우 유연하여 합계 및 평균을 계산하거나, 최대 및 최소 값을 찾는 것뿐만 아니라 복잡한 데이터 구조를 만드는 데도 사용할 수 있습니다.\n\n```js\nconst numbers = [1, 2, 3, 4];\n\nconst sum = numbers.reduce((accumulator, current) => accumulator + current, 0);\nconsole.log(sum); \n\n// 결과: 10\n```\n\n## 5. find()\n\n<div class=\"content-ad\"></div>\n\n지정된 조건을 충족시키는 첫 번째 부분을 찾아야 하는가요? find()가 도와줄 것입니다.\n\n이것은 콜백 함수에 의해 주어진 테스트를 통과하는 첫 번째 부분의 값을 반환하며, 빠른 조회와 전체 배열 루프를 제거하는 데 유용합니다.\n\n```js\nconst numbers = [1, 2, 4, 5];\n\nconst firstGreaterThanThree = numbers.find(number => number > 3);\nconsole.log(firstGreaterThanThree);\n\n// 출력: 4\n```\n\n## 6. findIndex()\n\n<div class=\"content-ad\"></div>\n\nfindIndex()은 find()보다 한 단계 더 나아가서, 콜백 테스트를 통과하는 첫 번째 요소의 인덱스를 반환합니다.\n\n배열 내에서 특정 데이터를 찾을 때, 배열에서의 위치에 따라 항목을 변경하고 집중적인 작업을 수행할 때 유용합니다.\n\n```js\nconst numbers = [1, 2, 4, 5];\n\nconst indexOfFirstGreaterThanThree = numbers.findIndex(number => number > 3);\nconsole.log(indexOfFirstGreaterThanThree);\n\n// 출력: 2\n```\n\n## 7. some()\n\n<div class=\"content-ad\"></div>\n\n특정 조건을 충족하는 항목이 배열에 있는지 확인해야 할 때가 있었나요? some() 메서드가 도움이 됩니다.\n\n콜백 함수에 의해 수행된 테스트를 통과하는 요소가 최소 한 개 이상 있는지 찾습니다.\n\n조건을 확인하거나 입력을 유효성 검사하거나 단일 일치하는 요소가 충분할 때 로직을 간단히 작성하는 데 사용할 수 있습니다.\n\n```js\nconst numbers = [1, 5, 8, 12];\n\nconst hasElementGreaterThanTen = numbers.some(number => number > 10);\nconsole.log(hasElementGreaterThanTen);\n\n// 결과: true\n```\n\n<div class=\"content-ad\"></div>\n\n## 8. every()\n\nevery()은 some()의 엄격한 형제입니다. 배열 내 모든 항목이 콜백 함수에 의해 제공된 테스트를 통과하는 것을 보장합니다.\n\n이는 데이터 유효성 검사, 지정된 구조를 따르는 각 요소 확인 및 품질 검사에 유용합니다.\n\n```js\nconst data = [\"apple\", \"banana\", 10];\n\nconst allStrings = data.every(element => typeof element === \"string\");\nconsole.log(allStrings);\n\n// 결과: false\n```\n\n<div class=\"content-ad\"></div>\n\n## 9. includes()\n\n가끔은 배열 안에 특정 값이 있는지 여부를 알고 싶을 때가 있습니다. includes()는 간단한 유효성 검사를 위한 최고의 친구입니다.\n\n주어진 값이 배열에 존재하는지 빠르게 확인하여 개별 데이터 포인트 식별이나 배열 멤버십에 기반한 조건부 논리 생성에 중요합니다.\n\n```js\nconst fruits = [\"apple\", \"banana\", \"cherry\"];\n\nconst hasOrange = fruits.includes(\"orange\");\nconsole.log(hasOrange);\n\n// 출력: false\n```\n\n<div class=\"content-ad\"></div>\n\n## 10. flat()\n\n다차원 배열이나 배열 안에 배열을 본 적이 있나요? 혼동스러울 수 있습니다. `flat()` 함수는 이를 닯은 배열로 변환하여 도와줍니다.\n\n중첩된 배열을 간단하게 만들거나, 중첩 구조를 갖는 API로부터 데이터 작업을 할 때 유용하며, 추가 처리를 위해 데이터를 저장하는 데 도움이 됩니다.\n\n```js\nconst nestedArray = [1, [2, 3], 4];\n\nconst flattenedArray = nestedArray.flat();\nconsole.log(flattenedArray);\n\n// 출력: [1, 2, 3, 4]\n```\n\n<div class=\"content-ad\"></div>\n\n# 몇 가지 전술\n\n기본적인 내용을 배웠으니, 학습 범위를 확장할 몇 가지 고급 주제를 살펴보겠습니다:\n\n## 배열 메소드 연결\n\n여러 배열 메소드를 연결하여 복잡한 변화를 만들어내어 명확하고 이해하기 쉬운 결과를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 배열에서 짝수만 걸러내고 해당 숫자들을 한 줄에 연관 있는 제곱값으로 매핑할 수 있습니다:\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\n\nconst evenSquares = numbers.filter(number => number % 2 === 0)\n                           .map(number => number * number);\n\nconsole.log(evenSquares);\n\n// Output: [4, 16]\n```\n\n## 사용자 정의 콜백 함수\n\n많은 배열 함수가 콜백 함수에 의존함을 기억하세요.\n\n<div class=\"content-ad\"></div>\n\n극단적인 상황을 처리할 수 있는 강력하고 명확하게 정의된 콜백을 만들어주세요. 데이터 타입을 명시하여 타입 안전성을 보장하고 코드 유지보수성을 높일 수 있습니다.\n\n예를 들어, 숫자가 짝수인지 확인하는 잘 정의된 콜백은 다음과 같이 보일 수 있습니다:\n\n```js\nfunction isEven(number) {\n  if (typeof number !== 'number') {\n    throw new TypeError('입력값은 숫자여야 합니다');\n  }\n  return number % 2 === 0;\n}\n```\n\n## 에러 처리\n\n<div class=\"content-ad\"></div>\n\n예기치 못한 데이터나 누락된 조각은 오류를 발생시킬 수 있습니다.\n\n배열 함수 내에서 발생할 수 있는 가능한 오류를 다루는 방법을 논의해보세요.\n\n예외 처리를 세련되게 다루기 위해 try-catch 구성 요소를 사용할 수 있습니다:\n\n```js\nconst numbers = [1, \"two\", 3];\n\ntry {\n  const doubledNumbers = numbers.map(number => number * 2);\n  console.log(doubledNumbers);\n\n// [2, NaN, 6] (\"two\"에 대한 오류)\n\n} catch (error) {\n  console\n```\n\n<div class=\"content-ad\"></div>\n\n## 성능에 대한 고려사항\n\n모든 배열 메서드가 동일하게 만들어지진 않습니다. 큰 또는 복잡한 배열의 성능 영향(forEach와 for 루프의 차이 등)에 대해 간단히 논의해 봅니다.\n\n- 메모리: 많은 데이터는 시스템을 과부하로 만들 수 있습니다.\n- 루프: 대용량 배열에 접근하는 데 시간이 소요됩니다.\n- 복잡한 요소: 배열 내 복잡한 데이터를 처리하는 것은 상당히 느립니다.\n\n정말 큰 데이터 세트의 경우, 특히 최적화된 배열 함수 구현이 없을 수 있는 오래된 브라우저에서 효율성을 향상시키기 위해 전통적인 루프를 사용해 보세요.\n\n<div class=\"content-ad\"></div>\n\n## 기능적 프로그래밍\n\n배열 함수는 기능적 프로그래밍 방식에 잘 맞습니다.\n\n기능적 프로그래밍은 순수 함수(부수 효과 없음)에 집중하며 변경할 수 없는 데이터와 작업합니다.\n\n기존 데이터에서 새 배열을 구축하기 위해 배열 메서드를 사용하면 원래 데이터를 유효하게 유지하고 예측 가능성을 향상시키며 디버깅을 쉽게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 최적의 방법들\n\n- 함수 결합: 앞서 언급한대로 여러 작업을 연결하여 빠르고 강력한 작업을 수행하는 데 도움이 됩니다. 실험하고 섞어 복잡한 변경을 한 줄로 만들어보는 것을 두려워하지 마세요.\n- 불변성: 가능할 때마다 이전 배열을 변경하는 대신 새로운 배열을 만드는 것을 시도해보세요. 이렇게 하면 가독성이 향상되고 원하지 않는 효과의 위험이 줄어듭니다. map, filter, slice와 같은 메서드를 사용하여 새로운 배열을 만들어보세요.\n- 오류 처리: 이상한 입력이나 누락된 항목을 잡기 위해 콜백 습관에 작동하는 오류 처리를 항상 사용하세요. 이렇게 하면 결합 오류로 프로그램이 충돌하는 것을 방지할 수 있습니다.\n\n# 마지막으로\n\n이 10가지 배열 메서드를 마스터하면 JavaScript 초보자에서 어딘가로 (믿어주세요, 당신의 레벨이 올라갈 거에요).\n\n<div class=\"content-ad\"></div>\n\n아래는 마크다운 형식의 코드입니다.\n\n\nYou’ll be able to create code that is easier to understand, more efficient, and more flexible, letting you work with data more effortlessly.\n\n![Image 1](/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_1.png)\n\n![Image 2](/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_2.png)\n","ogImage":{"url":"/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_0.png"},"coverImage":"/assets/img/2024-06-19-10JavaScriptArrayFunctionsYouShouldMasterasaSeniorDev_0.png","tag":["Tech"],"readingTime":7},{"title":"2023년 최신 JavaScript 프레임워크 및 기술","description":"","date":"2024-06-19 22:54","slug":"2024-06-19-TopJavaScriptFrameworksandTechnology2023","content":"\n\n## TL;DR: JavaScript + React + Redux는 여전히 약세를 유지하고 있습니다. 가장 좋은 결과를 얻으려면 Next.js와 Vercel을 함께 사용하세요. AI는 SudoLang + Agents로 폭발적으로 성장 중입니다. Web3의 성장세도 강합니다.\n\n![이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_0.png)\n\n2023년 4월 11일 업데이트됨\n\n작년에 많은 변화가 있었는데, 모든 것이 혁신의 대상이 될 수 있다는 느낌이 들 수 있지만, 내가 지금까지 본 가장 혁신적인 해를 겪은 기술계에서 가장 큰 놀람은 올해 목록에서 프레임워크 생태계가 얼마나 변화하지 않았는지입니다.\n\n<div class=\"content-ad\"></div>\n\n게임판에는 많은 새로운 플레이어가 있어요. (SolidJS에 기립!) 하지만 작년의 대승자들은 여전히 올해를 주도하고 있고 구직 시장에서 많은 흔적을 남기지 않는 것으로 보입니다. (아래에 데이터로 증명되어 있습니다.)\n\n그런데 어떤 변화가 있었을까요?\n\n## AI가 개발자의 속도를 높이고 있어요\n\n2020년 GPT-3와의 첫 번째 비디오 인터뷰를 진행했을 때, 사람들은 그것이 실제로 무엇인지 이해한다고 생각하지 않았고 유용한 코드를 생성할 수 있다고는 더더욱 상상하지 못했어요.\n\n<div class=\"content-ad\"></div>\n\n지금으로 빨리 넘어가 보자—만약 Copilot 또는 ChatGPT와 같은 AI 도구를 사용하지 않거나 코드를 검토하지 않는다면 모든 개발자들이 이미 큰 불이익을 겪고 있다.\n\nGitHub은 AI 개발 도구(특히 GitHub Copilot)가 개발자 생산성에 미치는 영향을 발견하기 위해 테스트를 실시했으며, 그들이 발견한 것은 매우 흥미로웠습니다. Copilot을 사용한 45명과 사용하지 않은 50명의 개발자들을 대상으로 한 실험에서, Copilot 사용자들은 Copilot을 사용하지 않은 개발자들보다 55% 빨리 작업을 완료했습니다.\n\n![](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_1.png)\n\n## ChatGPT가 게임을 바꿨어요\n\n<div class=\"content-ad\"></div>\n\n2022년 11월, OpenAI가 ChatGPT를 발표하여 역사상 가장 빠르게 성장한 앱 중 하나가 되었습니다. 일주일 만에 100만 명이 넘는 사용자를 확보하였으며, 1월에는 1억 명의 사용자를 기록했습니다.\n\n![이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_2.png)\n\n10년 전에는 자연어 AI 프로젝트의 기술 리더였는데, 그때도 이미 가능성을 인정하여 모든 산업을 혼란시킬 수 있는 가능성을 알았습니다. 2015년 이후로 매년 이 블로그에서 이에 대해 글을 썼는데, 2020년부터 시작된 다가오는 해일을 예언하여 지금은 모든 기술 분야로 홍수처럼 밀려드는 것을 경고하였습니다. 오늘날, 이 혼란의 해양 변화는 전 세계적인 현실이 되었습니다. AI-최우선 도구들이 규모에 걸맞게 가치를 증명하고 있으며, 이제 슈퍼 리치만이 소유한 것이 아닙니다.\n\n2023년에는 더 많은 AI-최우선 도구들이 출시될 것입니다. 모델 임베딩의 힘은 스마트 챗봇과 코드 어시스턴스 도구와 같은 것들에 혁명을 일으킬 것이며, 전체 코드베이스에서 통찰을 제공하는 기능을 가진 것들이 조용히 새로운 변화를 이끌 것입니다.\n\n<div class=\"content-ad\"></div>\n\n언어 모델과 SudoLang은 개발자가 응용 프로그램을 작성하는 방식을 변화시키고 있습니다. 이제 유사 코드로 전체 함수 또는 전체 프로젝트를 작성하고 AI 에이전트가 창의적으로 응용 프로그램을 만들어 주는 것이 가능해졌습니다.\n\nLangChain과 같은 프로젝트를 활용하는 에이전트들은 언어 모델이 할 수 있는 능력의 한계를 넘어선다는 것을 입증하며, API 액세스, 검색, 응용 프레임워크 등과 연결시킴으로써 발전시키고 있습니다.\n\nChatGPT와 Codex가 멋지다고 생각했다면, 믿어봐요: 아직 끝이 아니에요.\n\n## JavaScript는 여전히 최고입니다.\n\n<div class=\"content-ad\"></div>\n\nJavaScript은 여전히 GitHub에서 가장 많이 사용되는 언어입니다. Python은 그 뒤를 이어가는데, 최근 AI 혁명으로부터 영감을 받아 인기를 얻고 있습니다.\n\n![JavaScript 이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_3.png)\n\n현재 JavaScript는 세계에서 가장 큰 오픈 소스 모듈 생태계를 보유한 성숙한 프로그래밍 언어입니다.\n\n![JavaScript 이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 프론트엔드 프레임워크\n\n올해에는 새로운 프론트엔드 프레임워크가 등장했습니다. 어떤 것이 최고인지 말하기보다는 2023년 취업 시장에서 강한 수요와 사용을 보이는 것만 알려드리려고 합니다. 다음 프레임워크에 대한 데이터를 수집해 보았습니다:\n\n- React\n- Angular\n- Vue.js\n- Svelte\n- SolidJS\n\n취업 시장\n\n<div class=\"content-ad\"></div>\n\nIndeed.com에 따르면 취업 시장에서 React는 모든 프론트엔드 프레임워크를 언급하는 모든 구인 공고 중 57% 이상에서 언급됩니다. Angular는 32.5%로 두 번째로 많이 언급됩니다.\n\n검색 관심\n\n![](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_5.png)\n\n![](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_6.png)\n\n<div class=\"content-ad\"></div>\n\nDownloads\n\n![Image](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_7.png)\n\n## 사용자 만족도\n\n자바스크립트 현황 조사 2022에서 사용자들에게 \"다시 사용하시겠습니까?\"라는 질문을 하였습니다. 일반적인 JavaScript 기술에 대한 결과는 다음과 같습니다. Next.js, Svelte, 그리고 React는 뛰어난 점수를 받았습니다. Vue.js는 합격점을 받았습니다. Angular와 Gatsby는 개선할 여지가 많습니다. 다른 옵션에 대한 데이터는 없습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_8.png\" />\n\n## 상태 관리\n\n<img src=\"/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_9.png\" />\n\n서버에서 주로 상태를 관리하는 시스템의 경우, React Query 및 RTK Query와 같은 도구들이 약간의 인기를 얻고 있으며, GraphQL은 여전히 백엔드 데이터 서비스를 유연하게 쿼리하는 좋은 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n클라이언트 측 상태를 다룰 때 Redux는 여전히 최상위 2위를 차지하는데, 이는 순서로 따지면 1만큼 앞서고 있습니다. 그럴 만한 이유가 있죠: Redux는 결정적이고 트랜잭션 기반의 상태 관리를 제공하며, 여전히 최고의 미들웨어 생태계를 갖추고 있습니다. 번거로운 부분을 싫어하시나요? Autodux, Redux Toolkit과 같은 도구를 살펴보세요. Zustand나 Jotai와 같은 대안들은 어떤 사용 사례에 대해 고려할 가치가 있으며, 수백 또는 수천 개의 요소에 대한 원자적 업데이트가 필요한 UI를 가진 경우 recoil이 좋은 선택일 수도 있습니다.\n\n## 풀 스택 프레임워크\n\n이러한 프레임워크들은 서버와 클라이언트 모두를 아우르며, 종종 훌륭한 배포 자동화 기능을 제공합니다. 요약하자면, Next.js가 편안하게 선두를 달리고 있지만, Nest.js가 근시 2위를 차지하고 있습니다. 더 기능적인 접근 방식을 즐기고 마법같은 개발자 경험과 배포 자동화에 초점을 맞출 경우, Next.js는 안전한 선택입니다.\n\nNext.js와 Vercel을 사용한다면 세계 최고의 데브옵스 팀을 고용하는 것과 같다고 말씀드리고 싶어요. 그러나 그들에게 월급을 주는 대신 돈을 절약해줍니다. 제 의견 상으로는 여전히 이 말이 맞고 여전히 최고입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-TopJavaScriptFrameworksandTechnology2023_10](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_10.png)\n\n## Web3\n\n곰 시장에도 불구하고, 암호화 자금은 2023년에도 Web3에 수십억 달러를 투자할 계획입니다. 예를 들어, a16z는 2022년에 자사의 45억 달러 펀드 4를 발표하며 암호화 투자에 더 많은 자금을 투자했습니다.\n\n2020년에는 DeFi가 큰 이슈였고 Web3의 사용량을 촉진했습니다. 그러나 2021년 이후로 NFT(토큰화되지 않은 자산)가 대체되어 비디오 게임 아이템부터 예술 및 음악까지 모든 것에 대한 증명 가능한 희소성과 소유권을 나타내고 있습니다. 지난 30일간 블록체인에서 NFT 거래량이 어떻게 되는지 확인해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_11.png)\n\n## 기본적으로 안전하게\n\n2018년에 Chrome은 http 사이트를 \"안전하지 않음\"으로 표시하기 시작할 것이라고 발표했습니다. 그로부터 안전하게 기본 설정하는 것이 더욱 중요해졌습니다.\n\n그러나 저희는 애플리케이션에 대한 생성한 id로 정보를 유출하는 습관이 있습니다. 이는 다양한 보안 문제와 사용자 개인 정보 침해로 이어질 수 있습니다. 10년 전, 저는 식별자 충돌에 관심을 가졌고, 이를 방지하기 위한 id 표준을 작성했는데, 그 후 UUID V6-V8을 영감을 받아 만들었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n그러나 Cuid의 첫 번째 버전은 투명하지 않았습니다. 정확한 id 작성 시간, 호스트 지문 및 세션 카운터를 포함한 정보가 노출되었습니다. 이 문제를 해결하기 위해 최근 Cuid2를 발표했습니다. 오늘날 앱 개발자들은 k-정렬 가능한 id 대신에 투명한 id를 사용해야 합니다.\n\n# 결론\n\n오늘날의 현대 기술 스택은 작년과 많이 닮아 있습니다. 다음은 전형적인 예입니다:\n\n- Next.js에서 React + Redux 사용. Vercel에 서버리스로 배포합니다.\n- Jest 및 Testing Library로 단위 테스트를 수행하며, Riteway의 간단함을 선호합니다.\n- Polygon에서 고주파 거래가 이루어지는 Ethereum의 Web3.\n- 비밀번호는 구식이며 보안에 취약합니다. Magic Connect 또는 Passkeys로 Web3 인증을 선호합니다.\n- Cuid2와 같이 안전하고 투명한 id 생성기를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n## 다음 단계\n\n자바스크립트 및 테스트 주도 개발에 대한 다양한 비디오 및 대화형 레슨을 원하신다면 EricElliottJS.com을 확인해보세요.\n\n1:1 멘토링을 원하신다면 DevAnywhere.io를 확인해보세요.\n\nEric Elliott은 기술 제품 및 플랫폼 고문이자 \"Composing Software\" 저자이며 EricElliottJS.com과 DevAnywhere.io의 공동 창립자이자 개발 팀 멘토입니다. 그는 Adobe Systems, Zumba Fitness, 월스트리트저널, ESPN, BBC 및 어셔(Usher), 프랭크 오션(Frank Ocean), 메탈리카(Metallica) 등 최고의 음악 아티스트들을 위한 소프트웨어 경험에 기여했습니다.\n\n<div class=\"content-ad\"></div>\n\n세계에서 가장 아름다운 여자와 함께 원격 생활을 즐기고 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_0.png"},"coverImage":"/assets/img/2024-06-19-TopJavaScriptFrameworksandTechnology2023_0.png","tag":["Tech"],"readingTime":7}],"page":"54","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}