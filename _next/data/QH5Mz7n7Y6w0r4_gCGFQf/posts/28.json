{"pageProps":{"posts":[{"title":"Nodejs와 Reactjs에서 Razorpay 결제 게이트웨이 통합 방법","description":"","date":"2024-06-22 02:29","slug":"2024-06-22-RazorpayPaymentGatewayIntegrationInNodeJSReactJS","content":"\n\n# Node.js 및 React JS에서 Razorpay 결제 게이트웨이 통합\n\n<img src=\"/assets/img/2024-06-22-RazorpayPaymentGatewayIntegrationInNodeJSReactJS_0.png\" />\n\n# Node.js에서 Razorpay 결제 API 구현\n\n많은 시장에서 제공되는 결제 게이트웨이는 온라인 거래가 처리되는 곳입니다. 여기에서 Node.js를 사용하여 온라인 상점에 Razorpay 결제 API를 구현하는 방법을 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 ReactJS에서 Node.js로 작성된 API를 사용하여 Razorpay 결제 게이트웨이를 통합하는 방법에 대해 이야기할 것입니다.\n\n물론 로직은 동일하기 때문에 사용하는 언어가 중요하지 않습니다. 그러니 시작해 봅시다!\n\n## 단계 1:\n\nRazorpay 웹사이트에서 계정을 만들어 여기에서 Key Id 및 Key Secret을 받으세요.\n이 정보는 설정 - `API keys`에서 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n노트- 테스트 모드에 계십니까? 확인 부탁드립니다.\n\n## 단계 2:\n\n이번 단계에서는 Razorpay 결제 게이트웨이가 어떻게 작동하는지 이해해 보겠습니다. Razorpay 결제 게이트웨이의 흐름은 무엇인가요?\n\n다음 단계들은 Razorpay에서의 결제 흐름의 주요 구성 요소입니다-\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-RazorpayPaymentGatewayIntegrationInNodeJSReactJS_1.png\" />\n\n- 고객이 주문을 생성합니다.\n- Razorpay는 주문에 대한 주문 ID를 생성하고, 우리는 이를 통합에 사용합니다.\n- 주문 ID를 사용하여 결제 UI가 열리며, 고객은 세부 정보를 입력하고 결제 수단을 선택하고 금액을 지불합니다.\n- 그런 다음,이 단일 지불에는 처리를 받는 결제 ID이 있으며 우리는 응답으로 razorpay_signature, razorpay_order_id 및 razorpay_payment_id를 받습니다.\n- 그런 다음,이 결제를 인증하고 캡처하여 전체 거래를 정리하고 완료해야 합니다.\n\n## 단계 3:\n\n이제 코드를 작성합시다.\n\n<div class=\"content-ad\"></div>\n\n## 백엔드\n\nRazorpay를 초기화합니다.\n\n```js\nnpm i razorpay\n```\n\n## 비밀 키 사용하기\n\n<div class=\"content-ad\"></div>\n\nRazorpay의 모든 API에 접근하려면 먼저 Razorpay 패키지를 설치한 다음 시크릿 키를 사용해야 합니다.\n\n```js\nconst Razorpay = require('razorpay')\n```\n\n```js\nconst razorpay = new Razorpay({\nkey_id: 'rzp_test_uGoq5ADrFTgYRAhk',\n   key_secret: 'FySe2f58UYtg6Hjkj1a5s6clk9B'\n})\n```\n\n## 주문 생성을 위한 API 경로\n\n<div class=\"content-ad\"></div>\n\n우리는 주문을 배치하고 아래 나열된 API를 호출해야 합니다. 주문에 관한 기본 정보를 유지하고 주문을 반환해야 합니다. 나는 Razorpay를 위한 이 API의 요청 본문을 구성하고 create order 함수를 호출했습니다. 그런 다음에는 주문 ID를 프론트엔드 팀에 보내야 했으므로 그들이 이를 활용할 수 있고 Razorpay 체크아웃 페이지의 비밀키도 사용할 수 있습니다. 지불이 성공하면 상태가 \"Failed\"에서 \"Authorized\"로 변경됩니다. Razorpay 대시보드에서 확인할 수 있습니다.\n\n```js\napp.post('/order', async (req, res) => {\n    // razorpay 초기화\n    const razorpay = new Razorpay({\n        key_id: req.body.keyId,\n        key_secret: req.body.keySecret,\n    });\n\n    // razorpay 주문에 대한 옵션 설정\n    const options = {\n        amount: req.body.amount,\n        currency: req.body.currency,\n        receipt: \"각 주문에 대한 고유 ID\",\n        payment_capture: 1\n    };\n    try {\n        const response = await razorpay.orders.create(options)\n        res.json({\n            order_id: response.id,\n            currency: response.currency,\n            amount: response.amount,\n        })\n    } catch (err) {\n       res.status(400).send('주문을 생성할 수 없습니다. 다시 시도해주세요!');\n    }\n});\n```\n\n## 지불 캡처를 위한 API 경로\n\nRazorpay 설정에서 다음 URL을 웹훅에 특별한 비밀 키로 입력하고 \"payment.capture\" 열을 선택해야 하며, 이렇게하면 지불이 성공할 때마다 활성화됩니다.\n\n<div class=\"content-ad\"></div>\n\nWebhook에서 제공한 비밀 키를 사용하여 이 URL에서 서명을 확인해야 합니다. 지불 상태는 확인 후 \"캡처됨\"으로 변경됩니다.\n\n```js\nconst crypto = require('crypto')\n\nconst secret_key = '1234567890'\n\napp.post('/paymentCapture', (req, res) => {\n\n   // 유효성 검사 수행\n\nconst data = crypto.createHmac('sha256', secret_key)\n\n   data.update(JSON.stringify(req.body))\n\n   const digest = data.digest('hex')\n\nif (digest === req.headers['x-razorpay-signature']) {\n\n       console.log('요청이 유효합니다')\n\n       // 응답을 보내고 정보를 데이터베이스에 저장할 수 있습니다.\n\n       res.json({\n\n           status: 'ok'\n\n       })\n\n} else {\n\n       res.status(400).send('유효하지 않은 서명');\n\n   }\n\n})\n```\n\n## 환불\n\n지불이 완료된 후 환불할 수 있습니다. 요청할 API 호출과 함께 지불 ID와 금액을 제공하면 내부적으로 Razorpay의 환불 함수가 호출되어 돈을 동일한 계좌로 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n```javascript\napp.post('/refund', async (req, res) => {\n\n   try {\n\n       // 먼저 결제 ID를 확인한 후 Razorpay API에 액세스합니다.\n\n       const options = {\n\n           payment_id: req.body.paymentId,\n\n           amount: req.body.amount,\n\n       };\n\nconst razorpayResponse = await razorpay.refund(options);\n\n       // 응답을 보내고 데이터베이스에 정보를 저장할 수 있습니다.\n\n       res.send('환불 성공')\n\n   } catch (error) {\n\n       console.log(error);\n\n       res.status(400).send('환불 발행에 문제가 있습니다');\n\n   }\n\n})\n```\n\n## 장점\n\nRazorpay Payment Gateway와 통합하는 이점은 아래에 나열되어 있습니다.\n\nOnboarding\n\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n은행으로부터 수신한 오류 코드에 기초하여 Razorpay는 실패한 API 환불을 지능적으로 다시 시도합니다. 당사의 인스턴트 환불 도구 덕분에 최상의 환불 경험을 고객에게 제공할 수 있습니다.\n\n확장성과 가용성\n\n당사 시스템은 1초에 800개의 트랜잭션 요청을 처리할 수 있으며 성능이 저하되지 않습니다. 상태 페이지와 대시보드 외에도 장애 업데이트 이메일을 전송합니다.\n\n정산 조정\n\n<div class=\"content-ad\"></div>\n\n거래 처리를 추적하려면 특정 날짜나 월에 지불된 지불, 환불, 이체 및 조정을 모두 추적하기 위해 결제 조정을 사용하십시오.\n\n보상\n\n우리 회사는 국내외 다양한 카드, 다양한 인터넷뱅킹 대안, UPI 수집 및 의도, EMI, 무카드 EMI 및 Paytm 및 PhonePe와 같은 지갑을 모두 지원합니다.\n\n## 단계 4: 프론트엔드 (React js)\n\n<div class=\"content-ad\"></div>\n\n다음은 Razorpay를 렌더링하는 코드입니다.\n\n```js\nimport { useEffect, useRef } from 'react';\nimport crypto from 'crypto-js';\nimport PropTypes from 'prop-types';\nimport Axios from 'axios';\n\n// 스크립트를로드하고 DOM 트리에 추가하는 함수\nconst loadScript = src => new Promise((resolve) => {\n  const script = document.createElement('script');\n  script.src = src;\n  script.onload = () => {\n    console.log('razorpay가 성공적으로로드되었습니다');\n    resolve(true);\n  };\n  script.onerror = () => {\n    console.log('razorpay로드 중 오류 발생');\n    resolve(false);\n  };\n  document.body.appendChild(script);\n});\n\n\nconst RenderRazorpay = ({\n  orderId,\n  keyId,\n  keySecret,\n  currency,\n  amount,\n}) => {\n  const paymentId = useRef(null);\n  const paymentMethod = useRef(null);\n\n  // razorpay 체크아웃 모달 스크립트로드\n  const displayRazorpay = async (options) => {\n    const res = await loadScript(\n      'https://checkout.razorpay.com/v1/checkout.js',\n    );\n\n    if (!res) {\n      console.log('Razorpay SDK를로드하지 못했습니다. 온라인 상태이십니까?');\n      return;\n    }\n    // 모든 정보가 나중에 논의 할 options에로드됩니다.\n    const rzp1 = new window.Razorpay(options);\n\n    // 선택한 결제 방법을 검색하려는 경우\n    rzp1.on('payment.submit', (response) => {\n      paymentMethod.current = response.method;\n    });\n\n    // 거래 실패시 결제 ID를 검색\n    rzp1.on('payment.failed', (response) => {\n      paymentId.current = response.error.metadata.payment_id;\n    });\n\n    // razorpay 체크아웃 모달 열기\n    rzp1.open();\n  };\n\n\n  // 결제 서버에 알리기\n  const handlePayment = async (status, orderDetails = {}) => {\n    await Axios.post(`${serverBaseUrl}/payment`,\n      {\n        status,\n        orderDetails,\n      });\n  };\n\n\n  // 다음 단계에서이 객체를 작성 할 것입니다.\n  const options = {},\n\n  useEffect(() => {\n    console.log('레이저페이');\n    displayRazorpay(options);\n  }, []);\n\n  return null;\n};\n\nexport default RenderRazorpay;\n```\n\n<div class=\"content-ad\"></div>\n\n이제 통합의 가장 중요한 부분입니다.\n\n```js\nconst options = {\n    key: keyId, // 프롭스로부터 키 ID\n    amount, // 프롭스로부터 최소 단위 금액\n    currency, // 프롭스로부터 통화\n    name: 'amit', // 결제 모달에 표시할 조직의 제목\n    // image, // 사용자 정의 로고 URL\n    order_id: orderId, // 프롭스로부터 주문 ID\n    // 이 핸들러 메서드는 항상 결제에 성공했을 때 실행됩니다. \n    handler: (response) => {\n      console.log('succeeded');\n      console.log(response);\n      paymentId.current = response.razorpay_payment_id;\n\n      // 지불을 캡처하고 승인하는 가장 중요한 단계입니다. 이 작업은 백엔드 서버에서 수행할 수 있습니다.\n      const succeeded = crypto.HmacSHA256(`${orderId}|${response.razorpay_payment_id}`, keySecret).toString() === response.razorpay_signature;\n\n      // 성공적으로 승인되면 결제를 성공으로 간주할 수 있습니다.\n      if (succeeded) {\n        handlePayment('succeeded', {\n          orderId,\n          paymentId,\n          signature: response.razorpay_signature,\n        });\n      } else {\n        handlePayment('failed', {\n          orderId,\n          paymentId: response.razorpay_payment_id,\n        });\n      }\n    },\n    modal: {\n      confirm_close: true, // true로 설정하면 × 버튼을 클릭했을 때 확인이 필요합니다.\n      // 체크아웃 모달이 닫힐 때 실행되는 함수입니다.\n      // 이 모달이 닫히는 이유는 3가지가 있을 수 있습니다.\n      ondismiss: async (reason) => {\n        const {\n          reason: paymentReason, field, step, code,\n        } = reason && reason.error ? reason.error : {};\n        // 이유 1- 지불이 취소될 때. 이는 × 아이콘을 클릭하거나 명시적으로 지불을 취소할 때 발생할 수 있습니다.\n        if (reason === undefined) {\n          console.log('cancelled');\n          handlePayment('Cancelled');\n        } \n        // 이유 2- 시간 초과로 인해 모달이 자동으로 닫힐 때\n        else if (reason === 'timeout') {\n          console.log('timedout');\n          handlePayment('timedout');\n        } \n        // 이유 3- 지불이 실패했을 때\n        else {\n          console.log('failed');\n          handlePayment('failed', {\n            paymentReason, field, step, code,\n          });\n        }\n      },\n    },\n    // 이 속성을 사용하여 재시도를 활성화/비활성화할 수 있습니다.\n    // 기본적으로 활성화되어 있습니다.\n    retry: {\n      enabled: false,\n    },\n    timeout: 900, // 시간 제한(초) \n    theme: {\n      color: '', // 체크아웃 모달에 대한 사용자 정의 색상\n    },\n  };\n```\n\n## 단계 5: 이제 결제를 진행해 봅시다.\n\n이렇게 보입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-22-RazorpayPaymentGatewayIntegrationInNodeJSReactJS_2](/assets/img/2024-06-22-RazorpayPaymentGatewayIntegrationInNodeJSReactJS_2.png)\n","ogImage":{"url":"/assets/img/2024-06-22-RazorpayPaymentGatewayIntegrationInNodeJSReactJS_0.png"},"coverImage":"/assets/img/2024-06-22-RazorpayPaymentGatewayIntegrationInNodeJSReactJS_0.png","tag":["Tech"],"readingTime":9},{"title":"제로부터 챗봇까지 대형 언어 모델LLMs의 동작 원리 및 쉽게 활용하는 방법","description":"","date":"2024-06-22 02:27","slug":"2024-06-22-FromZerotoChatbotHowLargeLanguageModelsLLMsWorkandHowtoHarnessThemEasily","content":"\n\n# Node.js, OpenAI와 차 한 잔으로 즐거운 시간을 보내세요.\n\n![이미지](/assets/img/2024-06-22-FromZerotoChatbotHowLargeLanguageModelsLLMsWorkandHowtoHarnessThemEasily_0.png)\n\n인터넷의 모든 책, 기사 및 블로그 글을 읽어 버린 초지능 친구가 있다고 상상해보세요. 이 친구는 당신의 질문에 답변하고 창의적인 글쓰기를 돕며, 해변 거리의 어떤 주제에 대해 당신과 이야기를 나누어 줄 수 있습니다. 그것이 바로 Large Language Model (LLM) 입니다!\n\n이제 상상해 보세요, 여러분이 직접 하나를 만들 수 있다는 것을!\n\n<div class=\"content-ad\"></div>\n\n## 대형 언어 모델 (LLMs)\n\n대형 언어 모델(Large Language Models, LLMs)인 OpenAI의 GPT(Generative Pre-trained Transformer)와 같은 모델들은 기술과 상호 작용하는 방식을 혁신하고 있습니다. 이러한 모델들은 방대한 양의 텍스트 데이터로 학습되어 인간과 유사한 텍스트를 이해하고 생성할 수 있으며, 챗봇과 같은 응용 프로그램에 이상적입니다. 이 기사에서는 LLMs의 기본 개념, 프롬프트 엔지니어링의 개념, 그리고 Node.js, LangChain 및 OpenAI를 사용하여 챗봇을 구축하는 방법을 살펴보겠습니다.\n\nLLMs의 주요 특징:\n\n- 문맥적인 이해: LLMs는 주어진 입력의 문맥을 이해하여 그들의 응답을 일관되고 문맥적으로 관련성 있게 만듭니다.\n- 다용도성: 이러한 모델들은 번역, 요약 및 대화를 포함한 다양한 작업을 처리할 수 있습니다.\n- 확장성: LLMs는 특정 응용 프로그램에 대해 세밀하게 조정될 수 있어 특정 사용 사례의 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## LLM(언어 모델) 활용 방법\n\nLLM을 효과적으로 활용하려면, 입력을 처리하고 출력을 생성하는 방법을 이해하는 것이 중요합니다. 이는 모델이 원하는 응답을 생성하도록 이끄는 입력인 프롬프트를 만드는 것을 포함합니다.\n\n프롬프트 구조: 잘 구조화된 프롬프트는 명확한 지시사항과 충분한 맥락을 제공합니다. 프롬프트의 품질은 출력의 품질에 직접적으로 영향을 미칩니다.\n\n토크나이제이션: LLM은 텍스트를 토큰이라고 불리는 더 작은 단위로 분해하여 처리합니다. 각 토큰은 한 글자에서 한 단어까지일 수 있습니다. 모델의 이해는 이러한 토큰들에 기반합니다.\n\n<div class=\"content-ad\"></div>\n\n온도 및 최대 토큰:\n\n- 온도: 출력의 무작위성을 조절합니다. 낮은 값은 출력을 더 결정론적으로 만들고, 높은 값은 무작위성을 높입니다.\n- 최대 토큰: 생성된 응답의 길이를 제한합니다. 적절한 최대 토큰 값을 설정하면 응답이 간결하고 관련성이 있도록 보장합니다.\n\n## 프롬프트 엔지니어링\n\n![이미지](/assets/img/2024-06-22-FromZerotoChatbotHowLargeLanguageModelsLLMsWorkandHowtoHarnessThemEasily_1.png)\n\n<div class=\"content-ad\"></div>\n\n상당히 지식이 풍부한 친구와 대화하고 있다고 상상해보세요. 그는 당신이 가진 모든 질문에 대답할 수 있는 친구입니다. 일반적인 질문을 시작하여도, 그는 귀하가 정확히 필요한 것을 이해하기 위해 명확하게 질문합니다. 이러한 주고받음은 명확하고 유용한 답변을 제공할 때까지 계속됩니다.\n\n이것은 AI와의 프롬프트 엔지니어링과 유사합니다. 우리가 OpenAI의 GPT-3와 같은 대형 언어 모델(LLM)과 상호작용할 때, 관련 응답을 생성하는 데 충분한 맥락을 제공하는 잘 가공된 프롬프트를 제공합니다.\n\n예를 들어, AI 챗봇에 \"Node.js의 이점은 무엇입니까?\"라고 묻는다면 기술적인 응답을 받을 수 있습니다. 더 명확한 프롬프트로 수정할 수 있습니다. \"웹 개발에 Node.js의 장점을 설명해 줄 수 있나요?\" 이러한 구조화된 접근 방식은 AI가 귀하의 질의를 이해하고 정확한 응답을 제공하는 데 도움이 됩니다.\n\n프롬프트 엔지니어링을 통해 개발자들은 AI와 효과적으로 소통하여 다양한 작업을 지원할 수 있는 스마트하고 반응성 있는 챗봇을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n효과적인 프롬프트 엔지니어링 팁:\n\n- 명확하고 구체적으로: 프롬프트가 작업을 명확하게 정의하는지 확인하세요. 모호한 프롬프트는 모호한 응답으로 이어질 수 있습니다.\n- 맥락 제공: 모델이 요청의 맥락을 이해할 수 있도록 충분한 정보를 제공하세요.\n- 반복하고 개선하기: 다양한 프롬프트로 실험을 해보고 모델의 응답에 따라 프롬프트를 개선하세요.\n\n## Node.js와 LangChain로 챗봇 만들기\n\n이제 즐거운 부분인 Node.js, LangChain 및 OpenAI를 사용하여 챗봇을 만드는 것에 대해 알아봅시다. 우리는 프롬프트 엔지니어링이 챗봇의 응답을 강화하는 방법에 초점을 맞출 것입니다.\n\n<div class=\"content-ad\"></div>\n\n환경 설정하기:\n\n- Node.js 프로젝트 초기화하기:\n\n```js\nmkdir chatbot-app\ncd chatbot-app\nnpm init -y\nnpm install langchain openai axios\n```\n\n- 챗봇 구조 생성하기:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { OpenAI } = require('langchain');\nconst axios = require('axios');\n\nconst openai = new OpenAI({\n    apiKey: 'YOUR_OPENAI_API_KEY',  // OpenAI API 키로 바꿔주세요\n});\n\nasync function generateResponse(prompt) {\n    const response = await openai.complete({\n        model: 'text-davinci-003',  // 다른 사용 가능한 모델을 사용할 수 있어요\n        prompt: prompt,\n        maxTokens: 150,\n    });\n\n    return response.data.choices[0].text.trim();\n}\n```\n\n- LangChain을 사용한 프롬프트 엔지니어링 구현:\n\n```js\nconst { OpenAI, PromptTemplate } = require('langchain');\n\nconst openai = new OpenAI({\n    apiKey: 'YOUR_OPENAI_API_KEY',\n});\n\nconst template = new PromptTemplate({\n    inputVariables: ['query'],\n    template: `도움이 되는 어시스턴트입니다. 다음 질문에 답변하세요: {query}`\n});\n\nasync function generateResponse(query) {\n    const prompt = await template.format({ query });\n    const response = await openai.complete({\n        model: 'text-davinci-003',\n        prompt: prompt,\n        maxTokens: 150,\n    });\n\n    return response.data.choices[0].text.trim();\n}\n\n// 예시 사용법\n(async () => {\n    const userQuery = \"Node.js를 사용하는 장점은 무엇인가요?\";\n    const response = await generateResponse(userQuery);\n    console.log(response);\n})();\n```\n\n## 챗봇 테스트 및 개선하기\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n- 사용자: \"Node.js에서 비동기 프로그래밍은 어떻게 작동하나요?\"\n- 챗봇: \"Node.js에서의 비동기 프로그래밍은 블로킹되지 않는 작업을 가능하게 하며, 이는 이전 작업이 완료될 때까지 기다리지 않고 여러 작업을 동시에 처리할 수 있다는 것을 의미합니다.\"\n\n프롬프트와 응답을 반복하여 자신의 챗봇을 계속 향상시킬 수 있습니다.\n\n## 결론\n\nNode.js, LangChain 및 OpenAI를 활용하여 챗봇을 구축하는 것은 LLM(Large Language Model)의 능력을 활용하기 위한 흥미진진하고 접근성 있는 방법입니다. LLM의 기본 원리를 이해하고 프롬프트 엔지니어링을 숙달하는 것은 정확하고 맥락에 맞는 응답을 제공하는 챗봇을 만드는 데 필수적입니다. 본 안내서가 여러분의 응용 프로그램에서 LLM의 잠재력을 탐험하며 영감을 주기를 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n행복한 코딩!\n\n#AI, #인공지능, #챗봇, #오픈AI, #LangChain, #머신러닝, #NodeJS, #웹개발, #풀스택개발, #API개발, #프로그래밍, #기술튜토리얼, #소프트웨어공학, #자연어처리","ogImage":{"url":"/assets/img/2024-06-22-FromZerotoChatbotHowLargeLanguageModelsLLMsWorkandHowtoHarnessThemEasily_0.png"},"coverImage":"/assets/img/2024-06-22-FromZerotoChatbotHowLargeLanguageModelsLLMsWorkandHowtoHarnessThemEasily_0.png","tag":["Tech"],"readingTime":5},{"title":"npm 링크 사용 방법 2024 최신 가이드","description":"","date":"2024-06-22 02:26","slug":"2024-06-22-npmlink","content":"\n\nnpm 링크는 반복적으로 npm 패키지를 개발하고 테스트할 때 꾸준히 다시 빌드할 필요 없이 사용할 수 있는 필수 도구입니다. 원하는 대상 코드베이스에서 패키지를 직접 테스트할 수 있어요. 게시 후 불쾌한 놀라움을 피할 수 있어요. 저는 이것을 오랫동안 사용해왔어요. 처음에는 매우 간단했어요. 하지만 nvm, Webpack 등과 같은 도구를 사용하여 코드베이스가 복잡해지면서 작업하는 데 문제가 있었어요. 이 글은 npm 링크에 대한 제 경험에서 배운 것에 대한 내용입니다.\n\n# 사용 사례\n\n본 토론에서는 다음과 같은 사용 사례를 고려해 보세요.\n\n~/Documents/workspace/app에 node 앱인 app이라는 이름의 앱이 있고 이 앱은 utils라는 패키지를 사용합니다. utils는 이미 npm에 발행되어 있어요. utils에서 새로운 기능을 개발하고 이를 app에서 테스트하고 싶어요. 이를 위해 ~/Documents/workspace/utils에서 패키지를 확인했어요. utils 패키지에는 package.json에서 메인 파일로 src/index.js를 가지고 있어요.\n\n<div class=\"content-ad\"></div>\n\nutils에서 app으로 새 기능을 테스트하기 위한 링크를 생성할 예정입니다.\n\n# 사용법\n\n또 다른 코드베이스로부터 패키지를 연결하는 것은 2단계로 이루어집니다.\n\n## 단계 1\n\n<div class=\"content-ad\"></div>\n\n테스트할 패키지가 있는 디렉토리에서 npm link를 실행해주세요.\n\n그렇게 하면 패키지 디렉토리에서 전역 node_modules 디렉토리로 심볼릭 링크가 생성됩니다. 이 디렉토리는 'prefix'/lib/node_modules/`package-name` 에 위치해 있습니다. 또한 패키지 내의 모든 실행 파일들도 'prefix'/bin/`bin-name`에 링크됩니다.\n\n여기서 `package-name`은 package.json 파일에 있는 패키지의 이름을 가리키며, 패키지 코드가 있는 디렉토리의 이름은 아닙니다.\n\n'prefix'는 npm prefix -g의 출력을 나타냅니다. 저의 macOS에서는 homebrew를 통해 node가 설치되었으므로 /usr/local에 위치합니다. 따라서 전역 node_modules는 /usr/local/lib/node_modules에 있습니다.\n\n<div class=\"content-ad\"></div>\n\nutils 디렉터리에서 npm link를 실행하면 /usr/local/lib/node_modules/utils에서 ~/Documents/workspace/utils로 심볼릭 링크가 생성됩니다. 전역 노드 모듈 디렉터리로 이동하면 ls 명령어의 결과는 다음과 같습니다.\n\n![이미지](/assets/img/2024-06-22-npmlink_0.png)\n\n## 단계 2\n\n테스트하려는 패키지가 있는 코드베이스에서 npm link `package-name`을 실행하세요.\n\n<div class=\"content-ad\"></div>\n\nnpm 문서에 따르면, 이 코드베이스 내 node_modules/`package-name`에 심볼릭 링크를 생성하여 글로벌 node_modules 즉 'prefix'/lib/node_modules/`package-name` 로 연결해줍니다. 그러나 제가 8버전 이후의 새로운 npm 버전인 경우에 이 동작이 변경된 것을 알게 되었습니다. 새로운 버전에서는 심볼릭 링크가 node_modules/`package-name`에서 바로 로컬 패키지 저장소로 만들어집니다.\n\n내 앱 디렉토리에서 npm link utils를 실행하면, ~/Documents/workspace/app/node_modules/utils 에서 utils 패키지 위치인 ~/Documents/workspace/utils 로 심볼릭 링크가 생성됩니다. 이것은 npm 8.11에서 실행 중이기 때문에 ls 명령어의 출력은 app 디렉토리의 node_modules 디렉토리에 표시됩니다.\n\n![이미지](/assets/img/2024-06-22-npmlink_1.png)\n\n저는 npm 6.14.4에서도 동일한 작업을 시도해 보았습니다. 이 경우 utils는 npm 문서에서 언급된대로 글로벌 node_modules에 대한 링크가 생성됩니다. 즉 /usr/local/lib/node_modules/utils 입니다.\n\n<div class=\"content-ad\"></div>\n\n# nvm 사용 방법\n\nnvm을 사용하면 같은 컴퓨터에서 다양한 버전의 노드를 전환할 수 있습니다. 여러 버전의 노드가 설치되어 있더라도, 오직 1개의 버전만이 현재 버전으로 설정됩니다. nvm을 사용하는 경우, 패키지에서 npm link를 실행하면 현재 노드 버전(nvm use를 통해 설정됨)의 전역 node_modules에 링크가 생성됩니다. 이후 대상 코드베이스에서 npm link `패키지 이름`을 실행할 때, nvm의 현재 노드 버전이 변경되었다면, 링크가 생성되지 않습니다.\n\n## 사용 사례\n\n초기 사용 사례에서, 앱이 노드 18이 필요하고 utils는 적어도 노드 16이 필요한 경우를 가정해봅시다. 이들을 링크하려면 다음 작업을 수행해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n- nvm을 사용하여 노드 18로 변경합니다.\n- npm linkin utils를 실행합니다. 이렇게 하면 해당 패키지가 노드 v18의 전역 node_modules에 연결됩니다.\n- 앱에서 npm link utils을 실행합니다.\n\n이제 utils를 사용하는 app_1이 있고, 이 앱은 노드 16에서만 작동하는 경우를 가정해 봅시다. app_1을 utils에 연결하려면 다음을 수행해야 합니다.\n\n- nvm을 사용하여 노드 16로 변경합니다.\n- utils에서 다시 npm link를 실행하여 노드 v16의 전역 node_modules에 연결되도록 합니다.\n- app_1에서 npm link utils을 실행합니다.\n\n# 웹팩과의 사용법\n\n<div class=\"content-ad\"></div>\n\n링크를 설정하면 애플리케이션이 Webpack과 번들로 결합된 패키지의 경우 몇 가지 문제가 발생할 수 있습니다.\n\n## resolve.symlinks 설정 문제\n\n내 앱 중 일부에서 링크된 패키지가 포함된 앱을 번들링할 때, Webpack이 연결된 모듈에서 수입을 해결할 수 없는 문제가 발생했습니다. 이는 아마도 Webpack 구성의 resolve.symlinks 설정 때문일 것입니다. 기본적으로이 boolean은 true이며, 패키지는 심볼릭 링크 위치가 아닌 실제 경로로 해결됩니다. 따라서 이 문제가 발생하면 webpack 구성에서 resolve.symlinks를 false로 설정하면 문제가 해결될 것입니다.\n\n우리가 따르고있는 사용 사례에는 resolve.symlinkswith 값에 해당합니다.\n\n<div class=\"content-ad\"></div>\n\n- true를 사용하면 utils가 ../utils/src/index.js로 해석됩니다.\n- false를 사용하면 utils가 ./node_modules/utils/src/index.js로 해석됩니다.\n\n이 차이가 언제 문제가 될지 정확히 알 수 없었습니다. 일부 코드베이스에서는 링크된 모듈이 제대로 작동하여 resolve.symlinks를 설정하지 않아도 완벽하게 작동합니다. 반면에 일부 다른 코드베이스에서는 false로 설정하지 않으면 빌드가 실패합니다. 이 속성에 대한 Webpack 문서의 설명은 약간 모호합니다. — 패키지를 심볼릭 링크하는 도구를 사용할 때 모듈 해결에 실패할 수 있음을 참고하세요.\n\n## React 패키지를 링크하는 중 문제\n\nReact 컴포넌트를 포함한 패키지를 개발 중이라고 가정해보겠습니다. 이를 앱에서 링크하고 테스트하고자 합니다. Webpack 빌드는 잘 처리됩니다. 그러나 브라우저에서 애플리케이션을 로드할 때, 앱이 오류와 함께 크래시된 것을 확인할 수 있습니다 — 동일한 앱에서 React의 복사본이 여러 개 있는 것으로 보입니다.\n\n<div class=\"content-ad\"></div>\n\n리액트 컴포넌트가 npm에 발행되면 해당 컴포넌트가 번들에 포함되지 않도록 하기 위해 리액트 패키지를 피어 종속성으로 추가해야 합니다. 피어 종속성으로 표시하면 다른 리액트 앱에서 해당 컴포넌트를 사용할 때 그 앱의 node_modules에서 리액트를 가져옵니다.\n\n따라서 이 문제를 마주하게 되면,\n\n- 반드시 확인해야 할 점은 컴포넌트의 package.json에서 dependencies가 아닌 peerDependencies로 리액트가 추가되었는지 확인하는 것입니다.\n- 컴포넌트의 번들러(Webpack의 externals 및 Rollup의 external)에서도 리액트를 외부 종속성으로 표시해야 합니다. 이렇게 하면 번들에 추가되지 않습니다.\n- 이상적으로는 위 두 가지가 문제를 해결해야 합니다. 그러나 문제가 지속되는 경우, 앱의 개발 Webpack 구성에서 리액트에 대한 별칭을 작성하고 아래와 같이 앱의 리액트 버전으로 해결합니다.\n\n```js\n// webpack.config.js\nresolve: {\n  alias: {\n    react: path.resolve('./node_modules/react'),\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## TypeScript\n\nTypeScript에는 preserveSymlinks 옵션이 있어요. 문서에 따르면, 이 옵션은 Webpack의 resolve.symlinks와 반대 효과를 나타냅니다. 그런데 제가 지금까지 제 어플리케이션에 이 옵션을 조정해야 했던 적은 없어요. preserveSymlinks의 효과를 확인한 케이스가 두 가지 있었어요.\n\n- TypeScript를 활성화하고 Webpack으로 번들링한 프로젝트\n- TypeScript를 활성화하고 tsc를 사용해 변환한 NodeJS 프로젝트\n\n두 경우 모두, preserveSymlinks: true로 생성된 파일은 preserveSymlinks: false로 생성된 파일과 동일했어요. 그래서 이 옵션의 유틸리티를 확인하지 못했습니다.\n\n<div class=\"content-ad\"></div>\n\n# NodeJS\n\nNodeJS에는 링킹과 관련된 2가지 옵션이 있어요\n\n- — preserve-symlinks\n- — preserve-symlinks-main\n\n이 옵션들에 대한 자세한 설명은 NodeJS 문서에 있어요. 하지만 제가 어떤 앱에서도 이것들을 사용하지 않고도 링킹이 잘 동작했어요.\n\n<div class=\"content-ad\"></div>\n\n# 다른 링킹 문제 \n\n링크 명령은 항상 전체 종속성 트리를 해결합니다. 즉 npm install 처럼 노드_모듈을 삭제하고 npm install A 라고 쓴다면, package.json에 있는 전체 종속성 목록이 A와 함께 설치된다는 것을 알 수 있습니다. 마찬가지로 npm link A 를 실행할 때, npm은 패키지 A를 연결하고 package.json의 다른 종속성을 모두 설치합니다.\n\n나는 npm link의 이 동작과 관련된 몇 가지 링킹 문제를 알아 냈습니다.\n\n## 여러 패키지 연결\n\n<div class=\"content-ad\"></div>\n\n가정하자면 여러분이 패키지 A를 연결해 놓은 코드베이스가 있다고 해봅시다. 이제 동일한 코드베이스에 다른 패키지 B를 연결해야 합니다. npm link B 명령을 실행하면 A가 더 이상 연결되지 않는 것을 확인할 수 있을 겁니다. 이는 npm link B가 npm에게 B 패키지를 연결하고 package.json에 있는 모든 다른 의존성을 설치하도록 지시하기 때문입니다. npm이 이 작업을 수행하면 package A에 대한 연결이 덮어씌워지고 레지스트리에서 다운로드한 A의 버전으로 대체됩니다. package.json에 명시된 A의 버전이 레지스트리에 없으면 package A에 대한 터미널에서 404 오류가 발생하여 연결에 실패합니다. 그래서 A와 B를 모두 코드베이스에 연결하려면 npm link A B를 실행하세요.\n\n## 다른 패키지 설치하기\n\n가정하자면 여러분이 패키지 A를 연결해 놓은 코드베이스가 있다고 해봅시다. 새 패키지를 설치하면 A에 대한 연결이 사라지는 것을 알 수 있을 겁니다. 이는 npm install이 전체 트리를 다시 해석하고 A를 레지스트리에서 설치하여 연결을 덮어씌웠기 때문입니다. 만약 package.json에 명시된 A의 버전이 레지스트리에 없었다면 npm install이 404로 실패했을 겁니다. 이 문제를 해결하려면 모든 npm install 후에 연결해야 하는 모든 패키지들을 다시 연결하시면 됩니다.","ogImage":{"url":"/assets/img/2024-06-22-npmlink_0.png"},"coverImage":"/assets/img/2024-06-22-npmlink_0.png","tag":["Tech"],"readingTime":7},{"title":"HTTP2 특징 총정리","description":"","date":"2024-06-22 02:24","slug":"2024-06-22-OverviewofHTTP2Features","content":"\n\n![HTTP/2 Features](/assets/img/2024-06-22-OverviewofHTTP2Features_0.png)\n\nHTTP는 보안 부재와 최적 성능 부족이라는 두 가지 주요 단점이 있습니다.\n\nSSL/TLS의 도입으로 보안 문제는 극복되었지만, 성능 향상 측면에서는 부족했습니다. 이는 핸드쉐이크 암호화 프로세스를 최적화했지만, 전체 데이터 전송에 대한 더 나은 해결책을 제시하지 않았으며 여전히 \"장기 연결\"이라는 구식 기술에 의존하고 있었습니다.\n\n따라서 HTTPS가 성숙해지자, HTTP는 성능에 초점을 맞추고 또 다른 진화의 길을 걸어왔습니다.\n\n<div class=\"content-ad\"></div>\n\nHTTP의 역사로 돌아가면, 구글은 SPDY 프로토콜을 개척했고 이를 크롬 브라우저에 적용하여 HTTP 성능을 최적화한 “첫발”을 내딛었습니다.\n\n이어서 인터넷 공학 작업 국(IETF)은 다양한 당사자들의 참여를 통합하여 SPDY를 기반으로 하여 HTTP/1의 후계자인 오늘날의 주인공인 “HTTP/2”를 소개함으로써 성능 면에서 큰 도약을 이루었습니다.\n\n# 왜 HTTP/2.0 이 아닌가\n\n과연 이전 버전인 “1.0”과 “1.1.”처럼 HTTP/2가 “2.0”으로 명명되지 않은 이유가 궁금할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n실은 HTTP/2에 새로운 사용자들이 가장 자주 묻는 질문 중 하나이며, HTTP/2 작업 그룹은 이에 대한 설명을 제공했습니다.\n\n과거에 \"1.0\" 및 \"1.1\"을 사용한 것이 혼란과 오해를 초래하여 실제 사용 중인 버전을 구별하기 어렵게 만들었다고 믿습니다. 그래서, HTTP 프로토콜은 이제 미니 버전 번호를 사용하지 않고 주 버전 번호만 사용하기로 결정했습니다. 앞으로 \"HTTP/2.0\" 또는 \"HTTP/2.1\" 같은 것은 더 이상 없을 것이며 오직 \"HTTP/2\", \"HTTP/3\" 등만 사용될 것입니다.\n\n이 방식은 프로토콜 버전의 \"도약\"을 명확하고 모호하지 않게 하는데 도움이 되며, 이는 프로토콜이 더 오랜 기간 동안 안정적으로 유지되도록 합니다. HTTP 프로토콜의 각 새 버전은 상당한 차이를 가지며, 점진적인 개선은 없을 것입니다.\n\n# HTTP/1과의 호환성\n\n<div class=\"content-ad\"></div>\n\nHTTPS가 이미 보안에서 뛰어났기 때문에 HTTP/2의 유일한 초점은 성능 향상입니다.\n\n그러나 HTTP/2는 방대한 기대뿐만 아니라 HTTP/1의 거대한 역사적 부담도 갖고 있습니다. 따라서 어떠한 프로토콜 수정도 호환성을 주요 목표로 신중히 고려되어야 합니다. 그렇지 않으면 TLS 사례에서와 같이 기존 자산들에 심각한 혼란을 초래할 수 있습니다 (TLS 1.2와 호환성을 위해 \"위장\"이 필요했던 것과 같이).\n\n그럼 HTTP/2는 어떻게 이를 달성할까요?\n\n기능적 호환성을 유지하기 위해 HTTP/2는 HTTP를 \"의미론\"과 \"구문\" 두 부분으로 분할합니다. \"의미론\" 레이어는 동일하게 유지되어 HTTP/1과 완전히 일관성이 있습니다 (즉, RFC 7231). 요청 방법, URI, 상태 코드 및 헤더 필드와 같은 개념은 모두 유지되어 다시 배우는 필요가 없습니다. HTTP 위에 구축된 응용 프로그램도 수정이 필요 없이 HTTP/2로 원활하게 전환할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nhttps://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Accept-Encoding\n\n<div class=\"content-ad\"></div>\n\n먼저, HTTP/2는 메시지 헤더를 주요하게 개선했어요.\n\nHTTP/1에서는 \"Content-Encoding\" 헤더 필드를 사용하여 바디의 인코딩을 지정할 수 있었어요. 예를 들어 gzip 압축을 사용하여 대역폭을 저장할 수 있죠. 그러나 메시지의 다른 구성 요소인 헤더는 무시되고 최적화가 부족했어요.\n\n보통 메시지의 헤더는 \"User Agent\", \"Cookie\", \"Accept\", \"Server\"와 같은 많은 고정 헤더 필드를 가지고 있어요. 이는 수백 바이트에서 심지어 몇 천 바이트에 이르기도 하죠. 한편, 바디는 종종 GET 요청이나 204/301/304 응답과 같이 몇십 바이트만 포함하곤 해요. 이러한 이유로 헤더가 '지배적인 요인'으로 나타났어요. 게다가, 수천이나 수백만에 이르는 요청-응답 메시지 중 많은 필드 값이 반복되면서 상당한 낭비가 발생했어요. \"롱테일 효과\"는 이러한 고도 중복 데이터로 인해 상당한 대역폭이 소비되는 결과를 가져와요.\n\n그래서 HTTP/2는 주요 성능 향상으로 '헤더 압축'에 초점을 맞추었어요. 예상하신 대로, 최적화 방법은 여전히 '압축'이에요.\n\n<div class=\"content-ad\"></div>\n\n그러나 HTTP/2는 전통적인 압축 알고리즘을 사용하지 않습니다. 대신 전용 \"HPACK\" 알고리즘을 개발했는데, 이는 클라이언트와 서버 양쪽에서 \"사전\"을 설정합니다. 반복되는 문자열을 나타내는 데 인덱스 번호를 사용하고 허프만 코딩을 사용하여 정수와 문자열을 압축하여 50%에서 90%의 높은 압축률을 달성합니다.\n\n# 이진 형식\n\nHTTP/1의 메시지의 평문 형식에 이미 익숙할 수 있습니다. 이 형식은 \"이해하기 쉬우며\" 간단한 도구로 개발 및 디버그할 수 있어 매우 편리합니다.\n\n그러나 HTTP/2는 이러한 측면에서 \"타협\"하지 않으며 10년이 넘도록 지속되어 온 현재 상태를 변경하기로 결정했습니다. 인간이 읽을 수 있는 ASCII 코드 대신 하위 수준의 TCP/IP 프로토콜에 더 가까워지는 쪽으로 이동하여 완전히 이진 형식을 채택합니다.\n\n<div class=\"content-ad\"></div>\n\n비록 사용자 친화적이지는 않지만 컴퓨터 구문 분석을 크게 용이하게 만든다. 일반 텍스트의 경우, 대소문자 구분, 공백 문자, 캐리지 리턴, 줄 바꿈, 부족하거나 추가된 문자 등과 같은 모호성이 쉽게 발생할 수 있다. 이러한 것들을 처리하기 위해 프로그램은 복잡한 상태 기계를 사용해야 하며, 이는 비효율적이고 번거로울 수 있다.\n\n반면에 이진(binary)은 오직 \"0\"과 \"1\"로 이루어져 있어 필드 크기, 순서, 플래그 비트 및 기타 형식을 엄격히 정의할 수 있다. 구문 분석은 모호하지 않고, 구현은 간단하며, 콤팩트하고 빠르며 \"내부 효율성\"을 달성할 수 있다.\n\n이진 형식을 기반으로, HTTP/2는 \"급진적인\" 개혁을 시작했다.\n\nTCP 프로토콜의 일부 기능을 응용 계층으로 이동하여 원래의 \"헤더+바디(본문)\" 메시지를 여러 개의 작은 이진 \"프레임\"으로 분해하였으며, \"헤더\" 프레임은 헤더 데이터를 포함하고 \"데이터\" 프레임은 엔티티 데이터를 포함하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그 접근 방식은 \"Chunked\" 전송 인코딩과 약간 유사하며, \"작은 부분으로 분해\"하는 원칙을 따릅니다. 그러나 HTTP/2가 데이터를 프레임으로 분할한 후에는 메시지의 \"Header+Body\" 구조가 완전히 사라지고 프로토콜은 \"조각\"만을 처리합니다.\n\n![HTTP/2 Features](/assets/img/2024-06-22-OverviewofHTTP2Features_1.png)\n\n# 가상 '스트림'\n\n메시지의 조각들이 목적지에 도착하면 어떻게 조립될까요?\n\n<div class=\"content-ad\"></div>\n\nHTTP/2는 \"스트림\"이라는 개념을 정의하는데, 이는 이진 프레임의 양방향 시퀀스입니다. 각 메시지 왕복은 고유한 스트림 ID가 할당됩니다. 이를 가상의 \"데이터 스트림\"으로 생각할 수 있는데, 순서대로 데이터 프레임의 시리즈가 흐르는 것입니다. 이러한 데이터 프레임은 HTTP/1의 요청 및 응답 메시지를 형성하기 위해 순서대로 조립됩니다.\n\n\"스트림\"이 가상이며 실제로 존재하지 않기 때문에, HTTP/2는 단일 TCP 연결을 사용하여 여러 \"단편화된\" 메시지를 동시에 전송할 수 있습니다. 이를 \"다중화\"라고 하며, 단일 연결을 통해 여러 양방향 통신이 처리되는 것입니다.\n\n\"스트림\"의 관점에서 메시지는 순서가 지정된 \"프레임\"의 시퀀스이며, \"연결\"의 관점에서 메시지는 순서대로 받아들여지고 보내집니다. 여러 요청/응답이 있을 때 순차적인 관계가 더 이상 존재하지 않으므로, 줄 서서 기다릴 필요가 없어지며 \"헤드오브라인 차단\" 문제가 제거되고 지연 시간이 줄어들며 연결 활용도가 크게 증가합니다.\n\n![이미지](/assets/img/2024-06-22-OverviewofHTTP2Features_2.png)\n\n<div class=\"content-ad\"></div>\n\n네트워크 연결을 더 잘 활용하고 처리량을 늘리기 위해 HTTP/2는 가상 \"스트림\"을 관리하기 위해 일부 제어 프레임을 추가했습니다. 이는 우선순위 및 플로우 제어와 같은 기능을 구현하며 TCP 프로토콜과 매우 유사합니다.\n\n또한 HTTP/2는 기존의 \"요청-응답\" 작업 방식을 어느 정도 변경합니다. 서버는 더 이상 요청에 순응적으로 응답하는 것이 아니라, 클라이언트에게 메시지를 전송하기 위해 \"스트림\"을 미리 생성할 수도 있습니다. 예를 들어, 브라우저가 HTML을 요청할 때 서버가 클라이언트에게 사용할 수 있는 JS 및 CSS 파일을 푸시할 수 있어 대기 시간이 줄어듭니다. 이를 \"서버 푸시\"라고 하며, 캐시 푸시로도 알려져 있습니다.\n\n# 보안 강화\n\n호환성을 고려해 HTTP/2는 HTTP/1의 평문 기능을 계속 유지하여 데이터를 평문으로 전송할 수 있도록 합니다. 이는 암호화된 통신을 요구하지 않지만, 여전히 형식은 이진(binary)이며 복호화할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 HTTPS가 주류이며 Chrome 및 Firefox와 같은 주요 브라우저는 암호화된 HTTP/2만 지원한다고 공개적으로 발표했기 때문에 실제로 HTTP/2는 암호화됩니다. 이것은 인터넷에서 흔히 볼 수 있는 HTTP/2가 TLS를 통해 실행되는 \"https\" 프로토콜 이름을 사용한다는 것을 의미합니다.\n\n암호화된 버전과 평문 버전을 구별하기 위해 HTTP/2 프로토콜은 두 개의 문자열 식별자를 정의합니다. 암호화된 HTTP/2의 경우 \"h2\"이고 평문 HTTP/2의 경우 \"h2c\"이며 여기서 \"c\"는 \"클리어 텍스트\"를 나타냅니다.\n\nHTTP/2 표준이 2015년에 제정될 때 SSL/TLS의 많은 취약점이 이미 발견되었고 새로운 TLS1.3이 아직 출시되지 않은 상황이었습니다. 따라서 HTTP/2의 암호화된 버전은 보안 측면에서 강화되었으며 기본 통신 프로토콜이 적어도 TLS1.2 이상이어야 하며 포워드 시크리시와 SNI(서버 이름 지칭)를 지원하고 약간의 여전콜 암호 알고리즘 몇백 개를 블랙리스트에 올려두었습니다. DES, RC4, CBC 및 SHA-1과 같은 약한 암호 알고리즘은 HTTP/2에서 사용할 수 없으며 이는 하위 수준에서 \"TLS1.25\"를 사용하는 것과 같습니다.\n\n# 프로토콜 스택\n\n<div class=\"content-ad\"></div>\n\n다음 다이어그램은 HTTP/1, HTTPS 및 HTTP/2의 프로토콜 스택을 비교한 것입니다. HTTP/2는 \"HPack,\" \"Stream,\" 및 \"TLS1.2\" 위에 구축되어 있어 HTTP/1 및 HTTPS보다 약간 더 복잡한 것을 명확히 볼 수 있습니다.\n\n![](/assets/img/2024-06-22-OverviewofHTTP2Features_3.png)\n\nHTTP/2의 내부 구현은 복잡할지라도, 그 \"의미론\"은 여전히 간단한 HTTP/1과 같습니다. 이전에 학습한 지식은 더 이상 사용되지 않지 않고 여전히 적용할 수 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n오늘은 HTTP/2의 중요한 기능들을 간단히 소개했어요. 이론에 더 초점을 맞춰서 설명했어요. 다음에는 Wireshark를 사용하여 패킷을 캡처하고 HTTP/2의 헤더 압축, 이진 프레임, 스트림 기능에 대해 자세히 설명할 거예요.\n\n- HTTP 프로토콜에서는 작은 버전 번호를 제거했기 때문에 HTTP/2의 공식 이름은 2.0이 아니에요.\n- HTTP/2는 HTTP/1과 의미론적으로 호환되며, 요청 방법 및 URI와 같은 전통적인 개념을 유지해요.\n- HTTP/2는 헤더 정보를 압축하는 \"HPACK\" 알고리즘을 사용하여 중복 데이터를 제거하여 대역폭을 절약해요.\n- HTTP/2의 메시지는 더 이상 \"헤더+바디\" 형식이 아니라 여러 이진 \"프레임\"으로 분산돼요.\n- HTTP/2는 가상 \"스트림\"을 사용하여 메시지를 전송하며, \"헤드-오브-라인 차단\" 문제를 해결하고 \"멀티플렉싱\"을 통해 연결 이용률을 향상시켜요.\n- HTTP/2는 보안을 강화하며, 최소 TLS 1.2를 요구하고 많은 취약한 암호 스위트를 비활성화해요.\n\n![HTTP/2 기능 개요](/assets/img/2024-06-22-OverviewofHTTP2Features_4.png)","ogImage":{"url":"/assets/img/2024-06-22-OverviewofHTTP2Features_0.png"},"coverImage":"/assets/img/2024-06-22-OverviewofHTTP2Features_0.png","tag":["Tech"],"readingTime":7},{"title":"Nestjs와 TypeORM으로 CRUD 애플리케이션 만드는 방법","description":"","date":"2024-06-22 02:22","slug":"2024-06-22-BuildingaCRUDApplicationwithNestjsandTypeORM","content":"\n\n![그림](/assets/img/2024-06-22-BuildingaCRUDApplicationwithNestjsandTypeORM_0.png)\n\nNest는 효율적이고 확장 가능하며 신뢰할 수 있는 서버 측 애플리케이션(웹사이트)을 구축하기 위한 혁신적인 Node JS 프레임워크입니다. 데코레이터는 이 프레임워크에서 주로 사용되며 Java의 Spring Boot 프레임워크와 유사합니다.\n\n이 안내서에서는 Nest.js 프로젝트 설정, TypeORM을 사용한 데이터 모델 정의 및 기본 CRUD 작업(생성, 읽기, 업데이트, 삭제) 구현 과정을 안내합니다. 이 튜토리얼을 완료하면 확장 가능하고 유지보수 가능한 백엔드 애플리케이션 구축 방법을 명확히 이해하게 될 것입니다.\n\n# 필요 조건\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 먼저 컴퓨터에 Node.js와 npm이 설치되어 있는지 확인해주세요. 다음 명령을 실행하여 Nest CLI를 전역으로 설치할 수 있습니다:\n\n```js\nnpm install -g @nestjs/cli\n```\n\n# 단계 1: 프로젝트 설정\n\n새로운 Nest.js 프로젝트를 생성해봅시다. 터미널을 열고 다음 명령을 실행해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnest new nest-crud-tutorial\n```\n\n```js\ncd nest-crud-tutorial\n```\n\n```js\nnpm install @nestjs/typeorm typeorm\n```\n\n우리는 데이터베이스로 PostgreSQL을 사용할 것이기 때문에 해당 패키지를 설치해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install pg\n```\n\n# 단계 2: 데이터베이스 구성\n\n프로젝트 루트 디렉토리에 .env 파일을 생성하고 데이터베이스에 맞게 구성해주세요.\n\n```js\nPOSTGRES_HOST=127.0.0.1\nPOSTGRES_PORT=5432\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=pawan123\nPOSTGRES_DATABASE=nest-crud\nPORT=3000\nMODE=DEV\nRUN_MIGRATIONS=true\n```\n\n<div class=\"content-ad\"></div>\n\n기본으로 생성된 파일 app.module.ts에서 TypeORM을 구성하십시오.\n\n```js\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'postgres',\n      host: process.env.POSTGRES_HOST,\n      port: parseInt(process.env.POSTGRES_PORT),\n      password: process.env.POSTGRES_PASSWORD,\n      username: process.env.POSTGRES_USER,\n      entities: [],\n      database: process.env.POSTGRES_DATABASE,\n      synchronize: false,\n      logging: true,\n    }),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n# 단계 3: 사용자를 위한 리소스 생성\n\n다음 명령어로 nest-cli를 사용하여 DTO, 엔티티, 컨트롤러 및 서비스를 생성할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnest g resource user\n```\n\n이 명령은 CRUD 기능을 갖는 리소스를 생성하는 데 필요한 파일을 생성합니다.\n\n# 단계 4: 엔티티 생성\n\n이제 TypeORM을 사용하여 엔티티를 생성하여 데이터 모델을 정의해 봅시다. 이 예시에서는 fullName과 email 속성을 갖는 간단한 User 엔티티를 생성할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```ts\nimport {\n  Entity,\n  PrimaryGeneratedColumn,\n  Column,\n} from 'typeorm';\n\n@Entity()\nexport class User {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  fullName: string;\n\n  @Column({ unique: true })\n  email: string;\n}\n```\n\n생성된 user.entity.ts 파일에 위 코드를 추가해주세요.\n\n# 단계 5: 유효성 검사 추가\n\n유효성 검사를 위해 nest는 기본적으로 오류 처리를 위한 검증 파이프를 제공합니다. main.ts 파일에서 검증 파이프를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { ValidationPipe } from '@nestjs/common';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalPipes(\n    new ValidationPipe({ whitelist: true }),\n  );\n  await app.listen(3000);\n}\nbootstrap();\r\n```\n\n유효성 검사를 위해 class-validator 패키지를 설치해야 합니다. 다음 명령을 사용하여 설치하세요.\n\n```js\r\nnpm install class-validator\r\n```\n\n이제 createUserDto.ts 파일에 DTO를 생성하세요. 이는 사용자의 데이터 스키마를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {\n  IsEmail,\n  IsNotEmpty,\n  IsString,\n} from 'class-validator';\n\n// create-user-dto\nexport class CreateUserDto {\n  @IsNotEmpty()\n  @IsString()\n  fullName: string;\n\n  @IsNotEmpty()\n  @IsEmail()\n  email: string;\n}\n```\n\n또한 CreateUserDto의 부분 유형인 update-user-dto.ts 파일을 만들고 null 값을 가질 수 있습니다.\n\n```js\nimport { PartialType } from '@nestjs/mapped-types';\nimport { CreateUserDto } from './create-user.dto';\n\nexport class UpdateUserDto extends PartialType(CreateUserDto) {}\n```\n\n# 6단계: 서비스 만들기\n\n\n<div class=\"content-ad\"></div>\n\n다음으로, TypeORM을 사용하여 데이터베이스와 상호작용하는 서비스를 생성하세요. 유저 서비스에서는 TypeORM에 의해 생성된 엔티티에서 의존성 주입을 통해 만들어진 저장소를 초기화해야 합니다. 서비스 레이어는 애플리케이션의 비즈니스 로직을 처리합니다.\n\n```js\nimport {\n  HttpException,\n  Injectable,\n} from '@nestjs/common';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { UserEntity } from './entities/user.entity';\n\n@Injectable()\nexport class UserService {\n  constructor(\n    @InjectRepository(UserEntity)\n    private readonly userRepository: Repository<UserEntity>,\n  ) {}\n\n  async create(\n    createUserDto: CreateUserDto,\n  ): Promise<UserEntity> {\n    const userData =\n      await this.userRepository.create(\n        createUserDto,\n      );\n    return this.userRepository.save(userData);\n  }\n\n  async findAll(): Promise<UserEntity[]> {\n    return await this.userRepository.find();\n  }\n\n  async findOne(id: number): Promise<UserEntity> {\n    const userData =\n      await this.userRepository.findOne(id);\n    if (!userData) {\n      throw new HttpException(\n        'User Not Found',\n        404,\n      );\n    }\n    return userData;\n  }\n\n  async update(\n    id: number,\n    updateUserDto: UpdateUserDto,\n  ): Promise<UserEntity> {\n    const existingUser = await this.findOne(id);\n    const userData = this.userRepository.merge(\n      existingUser,\n      updateUserDto,\n    );\n    return await this.userRepository.save(\n      userData,\n    );\n  }\n\n  async remove(id: number): Promise<UserEntity> {\n    const existingUser = await this.findOne(id);\n    return await this.userRepository.remove(\n      existingUser,\n    );\n  }\n}\n```\n\n# 단계 7: 컨트롤러 생성\n\nHTTP 요청을 처리하고 서비스와 상호작용하는 컨트롤러를 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {\n  Controller,\n  Get,\n  Post,\n  Body,\n  Patch,\n  Param,\n  Delete,\n} from '@nestjs/common';\nimport { UserService } from './user.service';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\n\n@Controller('users') // route 그룹\nexport class UserController {\n  constructor(\n    private readonly userService: UserService,\n  ) {}\n\n  @Post()\n  async create(\n    @Body() createUserDto: CreateUserDto,\n  ) {\n    try {\n      await this.userService.create(\n        createUserDto,\n      );\n\n      return {\n        success: true,\n        message: '사용자가 성공적으로 생성되었습니다',\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message,\n      };\n    }\n  }\n\n  @Get()\n  async findAll() {\n    try {\n      const data =\n        await this.userService.findAll();\n      return {\n        success: true,\n        data,\n        message: '사용자가 성공적으로 검색되었습니다',\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message,\n      };\n    }\n  }\n\n  @Get(':id')\n  async findOne(@Param('id') id: string) {\n    try {\n      const data = await this.userService.findOne(\n        +id,\n      );\n      return {\n        success: true,\n        data,\n        message: '사용자가 성공적으로 검색되었습니다',\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message,\n      };\n    }\n  }\n\n  @Patch(':id')\n  async update(\n    @Param('id') id: string,\n    @Body() updateUserDto: UpdateUserDto,\n  ) {\n    try {\n      await this.userService.update(\n        +id,\n        updateUserDto,\n      );\n      return {\n        success: true,\n        message: '사용자가 성공적으로 업데이트되었습니다',\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message,\n      };\n    }\n  }\n\n  @Delete(':id')\n  async remove(@Param('id') id: string) {\n    try {\n      await this.userService.remove(+id);\n      return {\n        success: true,\n        message: '사용자가 성공적으로 삭제되었습니다',\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message,\n      };\n    }\n  }\n}\n```\n\n# 단계 8: 모든 것을 연결하기\n\n이제 서비스, 컨트롤러 및 엔티티를 연결해보겠습니다. Nest.js는 애플리케이션 구성 요소를 관리하기 위해 의존성 주입을 사용합니다. 서비스 및 컨트롤러를 user.module.ts 파일에 import 및 등록해야 합니다.\n\n```js\nimport { Module } from '@nestjs/common';\nimport { UserService } from './user.service';\nimport { UserController } from './user.controller';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserEntity } from './entities/user.entity';\n\n@Module({\n  imports: [\n    TypeOrmModule.forFeature([UserEntity]),\n  ],\n  controllers: [UserController],\n  providers: [UserService],\n})\nexport class UserModule {}\n```\n\n<div class=\"content-ad\"></div>\n\n축하합니다! Nest.js와 TypeORM을 사용하여 기본 CRUD 애플리케이션을 성공적으로 만드셨군요. 프로젝트 설정, 데이터 모델 정의, 서비스 및 컨트롤러 구현, 애플리케이션 테스트 등을 다뤘습니다. 이것은 시작에 불과합니다. Nest.js와 TypeORM은 견고한 백엔드 애플리케이션을 구축하기 위한 다양한 기능을 제공합니다.\n\n편의를 위해, 이 튜토리얼의 전체 소스 코드는 제 GitHub 저장소에서 찾아볼 수 있습니다. 저장소를 클론하여 코드를 자유롭게 실험해보세요.\n\nNest.js와 TypeORM CRUD 튜토리얼을 따라주셔서 감사합니다. 이 튜토리얼이 숙련된 백엔드 개발자가 되는 여정에서 도움이 되셨기를 바랍니다. 즐거운 코딩되시길 바라겠습니다!","ogImage":{"url":"/assets/img/2024-06-22-BuildingaCRUDApplicationwithNestjsandTypeORM_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingaCRUDApplicationwithNestjsandTypeORM_0.png","tag":["Tech"],"readingTime":9},{"title":"웹 애플리케이션에서 데이터 검증 소개","description":"","date":"2024-06-22 02:21","slug":"2024-06-22-1IntroductiontoDataValidationinWebApplications","content":"\n\n1. 웹 애플리케이션에서 데이터 유효성 검사 소개.\n2. NestJS를 유효성 검사 용으로 설정하기.\n- 선행 조건 및 프로젝트 설정.\n- 유효성 검사 스키마 생성 및 사용하기.\n3. Joi와 함께 pipe를 소개하고 사용하는 방법.\n4. Joi를 사용하여 매개변수 및 쿼리 매개변수의 유효성 검사.\n5. 실제 구현: nestjs-joi 및 joi-class-decorators를 활용한 완전한 NestJS 애플리케이션 탐색하기: GitHub의 NestJS Sample App with nestjs-joi. \n\n# 1. 웹 애플리케이션에서 데이터 유효성 검사 소개.\n\n- 데이터 유효성 검사는 사용자가 입력한 데이터나 외부 소스에서 가져온 데이터가 지정된 기준과 형식을 충족하는지 확인하는 프로세스입니다. 데이터 유효성 검사는 클라이언트 측, 서버 측 및 데이터베이스 수준을 포함하여 여러 수준에서 수행할 수 있습니다. \n\n# 2. NestJS를 유효성 검사 용으로 설정하기.\n\n<div class=\"content-ad\"></div>\n\n- 전제 조건 및 프로젝트 설정:\n\n## 1. Node 및 npm 설치:\n\nNodejs 웹 사이트에 가서 Node를 설치해야 합니다.\n\n## 2. NestJs 설치 및 새로운 nestApp 생성:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm i -g @nestjs/cli\nnest new my-nestjs-app\ncd ./my-nestjs-app\n```\n\n## 3. 새로운 파이프인 validation을 생성하세요:\n\n```js\n// --no-spec => spec 파일 생성 비활성화\n// --flat => 요소를 위한 폴더를 생성하지 않습니다.\nnest g pipe validation --no-spec --flat\n```\n\n## 4. 필요한 패키지 설치하기 (nestjs-joi, joi-class-decorators)\n\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm i class-transformer joi nestjs-joi joi-class-decorators\n```\n\n- 확인 스키마 생성 및 사용:\n\n## 1. `/testBody` 엔드포인트 생성, 메서드 유형: POST, 앱 컨트롤러에서\n\n```js\nimport { Body, Controller, HttpCode, HttpStatus, Post, Req, Res } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { Request, Response } from 'express';\nimport { validationBodyDto } from './validate.dto';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Post('/testBody')\n  @HttpCode(HttpStatus.OK)\n  testJoiValidation(@Body() reqBody: validationBodyDto, @Res() res: Response) {\n    const data = reqBody;\n    res.json(data);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 2. validate.dto.ts 파일을 만들어서 이 엔드포인트를 검증하고 joi 스키마 클래스(validationBodyDto)를 만드세요:\n\n```js\nimport { Expose } from \"class-transformer\";\nimport { JoiSchema, JoiSchemaOptions } from \"joi-class-decorators\";\nimport * as Joi from 'joi';\n\ninterface reviewInterface {\n    rating: number;\n    comment: string;\n}\n// @Expose ==> 시리얼라이제이션 및 디시리얼라이제이션을 위해 전환 프로세스에 포함되어야 하는 속성을 표시하는 데 사용됩니다.\n// @JoiSchema() ==> 타입(클래스) 속성에 스키마를 정의합니다. 스키마 주석이 달린 속성은 전체 객체 스키마를 구성하는 데 사용됩니다.\n\n//명시적으로 정의되지 않은 속성을 허용하지 않아 엄격한 유효성을 보장합니다. \n@JoiSchemaOptions({\n    allowUnknown: false\n})\n\nexport class validationBodyDto {\n\n   //기본 유효성 검사는 문자열 유형 및 필수입니다.\n    @Expose() @JoiSchema(Joi.string().trim().required())\n    fullName: string;\n\n   //길이를 확인하고 유효한 이집트 전화 번호인지 확인합니다\n    @Expose() @JoiSchema(Joi.string().length(11).pattern(/^(011|012|015|010)\\d{8}$/).required())\n    phoneNumber: string;\n\n\n   //유효한 이메일인지 확인합니다.\n    @Expose() @JoiSchema(Joi.string().email().optional())\n    email?: string;\n\n    //값이 M 또는 F인 경우에만 유효성을 확인합니다.\n    @Expose() @JoiSchema(Joi.string().valid('M', 'F').required())\n    gender: string;\n\n    //gender가 M이면 militaryStatus는 필수이고 그렇지 않으면 선택사항입니다.\n    @Expose() @JoiSchema(\n        Joi.when('gender', {\n            is: 'M',\n            then: Joi.string().required(),\n            otherwise: Joi.string().optional(),\n        }),\n    )\n    militaryStatus: string;\n\n    //나이가 숫자이고 최소값은 14이고 최대 나이는 100입니다.\n    @Expose() @JoiSchema(Joi.number().min(14).max(100).message('유효하지 않은 나이'))\n    age: number;\n\n\n    //객체 배열이 유효한지 확인합니다.\n    @Expose()\n    @JoiSchema(\n        Joi.array().items(\n                Joi.object({\n                        rating: Joi.number().min(0.1).required(),\n                        comment: Joi.string().min(3).max(300).required(),\n                    }).required(),\n            ).required(),\n    )\n    reviews: reviewInterface[];\n\n    //빈 문자열을 허용하는 필드입니다.\n    @Expose() @JoiSchema(Joi.string().allow('').optional())\n    profilePicture?: string;\n\n    //profilePicture에 값이 있을 경우 profileFileName은 필수이고 그렇지 않으면 선택사항입니다.\n    @Expose() @JoiSchema(\n        Joi.when('profilePicture', {\n            is: Joi.string().exist(),\n            then:  Joi.string().required(),\n            otherwise: Joi.string().allow('').optional(),\n    }))\n    profileFileName: string;\n\n    //isVerified가 부울 값이고 필수인지 확인합니다.\n    @Expose() @JoiSchema(Joi.boolean().required())\n    isVerified: boolean;\n}\n```\n\n## 3. pipe 소개 및 Joi와 함께 사용하는 방법:\n\n- NestJS에서 \"pipe\"는 @Injectable() 데코레이터가 붙은 클래스로, PipeTransform 인터페이스를 구현합니다. Pipe는 일반적으로 데이터의 변환 또는 유효성 검사에 사용됩니다. 메소드 수준, 컨트롤러 수준 또는 전역 수준 등 다양한 수준에서 사용할 수 있습니다.\n- Pipes 소개\n변환: Pipes는 입력 데이터를 원하는 형식으로 변환할 수 있습니다.\n유효성 검사: Pipes는 데이터를 요청 핸들러에 전달하기 전에 데이터를 유효성 검사할 수 있습니다. 데이터가 유효하지 않으면 Pipe가 예외를 throw할 수 있고, 이는 NestJS에서 처리됩니다.\n- 우리의 경우, 일반 객체를 유형화된 객체로 변환하여 유효성을 적용할 수 있게 합니다.\n- 이제 우리가 이전에 만들었던 유효성 파이프를 사용해 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { BadRequestException, Injectable, PipeTransform, Type } from '@nestjs/common’;\nimport { plainToInstance } from 'class-transformer’;\nimport { getClassSchema } from 'joi-class-decorators’;\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    const { metatype } = metadata;\n    const bodyDto = metatype; // Dto Schema\n    /*\n      우리의 일반 JavaScript 인수 객체를 형식화된 객체로 변환하여 유효성을 적용합니다.\n      이 작업을 수행해야 하는 이유는, 네트워크 요청에서 역직렬화된 전송 온 post body 객체에는 어떤 유형 정보도 포함되어 있지 않기 때문입니다. \n    */\n    // getClassSchema(bodyDto) ==> 클래스와 연결된 Joi 유효성 스키마를 가져오는 joi-class-decorators의 함수입니다.\n    const bodyInput = plainToInstance(bodyDto, value); // 일반 Dto 객체를 인스턴스로 변환하여 수동으로 변환합니다\n    const bodySchema = getClassSchema(bodyDto); // Dto에서 Joi 스키마 가져오기\n    // 클래스 인스턴스를 Joi 스키마에 대해 유효성 검사합니다. 유효성 검사가 실패하면 error에 유효성 오류가 포함됩니다.\n    const error = bodySchema.validate(bodyInput).error;  \n    if (error) {\n      throw new BadRequestException(`유효성 검사 실패: ${error.details.map((err) => err.message).join(', ')}.`);  \n    }\n    return value\n  }\n}\ninterface ArgumentMetadata {\n  type: 'body' | 'query' | 'param' | 'custom';\n  metatype?: Type<unknown>;\n  data?: string;\n}\n```\n\n## 4. Param 및 Query Params에 대한 Joi 유효성 검사.\n\n- `/testParams/:category’` 경로를 만들고, GET 방식으로 작성합니다. category라는 하나의 param을 받고, 두 개의 Query Params인 limit와 page를 받습니다.\n\n```js\n@Get(’/testParams/:category’) \n@HttpCode(HttpStatus.OK) \n@UsePipes(new ValidationPipe()) \ntestJoiValidationParam( \n@Param() category: validationParamDto, \n@Query() limitAndPageSize: validationQueryParamDto, \n@Res() res: Response \n) { \n   res.json({ category, limitAndPageSize }); \n}\n```\n\n<div class=\"content-ad\"></div>\n\n- 이러한 매개변수를 위해 두 개의 DTO를 생성하세요:\n\n```js\n@JoiSchemaOptions({\n    allowUnknown: false\n})\n\nexport class validationParamDto {\n     @Expose() @JoiSchema(Joi.string().valid('Fashions', 'Electronics', 'MobilesPhones', 'Perfumes').required())\n     category: string; \n}\n\n@JoiSchemaOptions({\n    allowUnknown: false\n})\n\nexport class validationQueryParamDto {\n\n    @Expose() @JoiSchema(Joi.number().min(0).max(100).message('잘못된 제한입니다'))\n    limit: string;\n\n    @Expose() @JoiSchema(Joi.number().min(0).max(100).message('잘못된 페이지 크기입니다'))\n    page: string;\n}\n```\n\nGitHub에서 NestJS 샘플 앱을 탐색하세요.","ogImage":{"url":"/assets/img/2024-06-22-1IntroductiontoDataValidationinWebApplications_0.png"},"coverImage":"/assets/img/2024-06-22-1IntroductiontoDataValidationinWebApplications_0.png","tag":["Tech"],"readingTime":7},{"title":"Nestjs에서 Retry 패턴 구현하는 방법","description":"","date":"2024-06-22 02:20","slug":"2024-06-22-ImplementRetryPatterninNestjs","content":"\n\n![2024-06-22-ImplementRetryPatterninNestjs_0.png](/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png)\n\n이 기사에서는 다시 시도 및 회로 차단 패턴의 개념을 살펴보고 구현해야 하는 시점과 이유를 파악할 것입니다.\n\n가끔은 추가 서비스를 활용해야 할 때가 있습니다. 우리의 서비스 또는 결제 서비스와 같은 타사 서비스를 호출할 때 상상해 보세요. 그때 결제 서비스가 부하 상태에 있어 우리 요청에 응답하지 못할 수 있습니다. 또는 네트워크 지연이나 인프라 서비스의 문제로 인해 요청이 처리되지 않을 수 있습니다. 그러나 요청을 다시 보내면 대상 서비스가 부하가 해소될 수 있거나 인프라 문제가 해결될 수 있으며 우리 요청이 성공적으로 처리될 수 있습니다.\n\n이 상황에서 우리는 어떻게 해야 할까요?\n개발자로서 우리의 책임 중 하나는 시스템 실패의 허용한도를 높이는 것입니다. 개발된 서비스는 다양한 시나리오와 상황에서 호환되며 방탄이어야 하며 원활한 사용자 경험을 제공해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n여러 번 시도하면 성공 응답을 받을 수 있는 경우가 있음을 알고 있습니다. 사용자에게는 제3자 서비스에서 오류가 발생하는 첫 번째 시도에 대해 응답하지 않아야 하며, 한 두 번 더 시도하면 성공 응답을 받을 수도 있습니다. 그러나 UnAuth, 액세스 거부 등과 같이 다시 시도할 수 없는 오류도 있음을 알고 있어야 합니다.\n\n이제 다른 개념, Jitter에 대해 알아보겠습니다!\n\n여러 클라이언트가 특정 서비스를 호출하려고 시도하는 상황을 상상해보세요. 해당 서비스는 부하를 받아 일부 클라이언트에게 응답하지 못할 것이며, 실패 응답을 받은 클라이언트는 동시에 해당 서비스를 호출하려고 하면 다시 부하를 받아 서비스 거부 상태가 될 것입니다. 이때, 다시 시도 사이에 지연을 설정하는 것이 좋습니다. 다음 공식을 통해 지연을 설정하세요:\n\n고정된 밀리초 + 임의의 밀리초\n\n<div class=\"content-ad\"></div>\n\n무작위 시간에 서비스를 호출하여 서비스가 스스로 회복될 수 있도록 도와줍니다.\n\n아래는 Axios와 호환되는 jitter를 사용한 재시도 유틸리티 서비스 구현 예시입니다:\n\n```js\nimport { Injectable } from '@nestjs/common';\nimport { AxiosResponse } from 'axios';\n\nexport type AxiosMethod = () => Promise<AxiosResponse>;\n\n@Injectable()\nexport class Retry {\n  constructor() {}\n\n  async retry(\n    axiosMethod: AxiosMethod,\n    retry: number,\n    delayInMs: number,\n    jitter: boolean,\n  ): Promise<AxiosResponse> {\n    try {\n      let res: AxiosResponse | null = null;\n\n      for (let i = 0; i <= retry; i++) {\n        try {\n          res = await axiosMethod();\n          break;\n        } catch (err) {\n          if (i < retry) {\n            const j = this.getJitter(jitter);\n            await this.executeWithDelay(delayInMs + j);\n            continue\n          } else {\n            throw err;\n          }\n        }\n      }\n      return res;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private executeWithDelay(delay: number) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n  }\n\n  private getJitter(jitter: boolean) {\n    return jitter ? Math.floor(Math.random() * (200 - 50 + 1)) + 50 : 0;\n  }\n}\n```\n\n이 설명이 프로젝트 개발에 높은 실패 허용성을 가로지어드릴 수 있기를 바랍니다. 궁금한 점이 있으시면 언제든지 질문해주세요.👌\n\n<div class=\"content-ad\"></div>\n\n# 관련 자료\n\nhttps://learn.microsoft.com/en-us/azure/architecture/patterns/retry","ogImage":{"url":"/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png"},"coverImage":"/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png","tag":["Tech"],"readingTime":3},{"title":"Nestjs에서 구조화된 API 응답 처리 방법","description":"","date":"2024-06-22 02:19","slug":"2024-06-22-NestjsStructuredAPIResponse","content":"\n\n\n![이미지](/assets/img/2024-06-22-NestjsStructuredAPIResponse_0.png)\n\nNest.js에는 미리 정의된 HTTP 응답 JSON 구조가 있습니다:\n\n```js\n{\n  \"statusCode\": 500,\n  \"message\": \"Internal server error\"\n}\n```\n\n응답 구조를 변경해야 하는 경우 더 많은 세부 정보를 추가하거나 이름이나 구조를 변경해야 할 수도 있습니다.\n때로는 클라이언트(프론트엔드 또는 다른 서비스 클라이언트)를 위해 보다 구체적인 응답 구조를 정의해야 할 수도 있습니다.\n컨트롤러 라우트의 끝에 사용자 정의 구조 응답을 작성하거나, 어디에서나 사용자 정의 응답을 보내기 위해 객체를 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n가끔은 클라이언트(프론트엔드 또는 다른 서비스 클라이언트)에 대한 보다 구체적인 응답 구조를 정의하는 것이 필요할 수 있습니다.\n\n어떤 경우에는 커스텀한 응답 구조를 작성해야 할 것이라고 생각할 수 있으며, 이를 위해 컨트롤러 루트의 끝에 커스텀 응답을 작성하거나 Response 객체를 사용하여 어디서든지(custom response를 전송할) 다음과 같이 사용할 수 있습니다:\n\n```js\nresponse\n  .status(status)\n  .json({\n    statusCode: status,\n    timestamp: new Date().toISOString(),\n    path: request.url,\n  });\n```\n\n# Class-Validator 응답이 커스텀 API 응답과 충돌합니다!\n\n<div class=\"content-ad\"></div>\n\n우리 모두는 프로젝트에서 입력값을 유효성 검사하는 데 사용하고 있어요.\n이 패키지는 다음과 같은 사전 정의된 오류 구조를 사용해요:\n\n모두, 우리는 프로젝트에서 입력값을 유효성 검사하는 데 class-validator를 사용하고 있어요.\n이 패키지는 다음과 같은 사전 정의된 오류 구조를 사용해요:\n\n```js\n{\n  \"statusCode\": 400,\n  \"message\": [\n    {\n      \"property\": \"firstName\",\n      \"message\": \"firstName must be longer than or equal to 1 characters\"\n    }\n  ],\n  \"error\": \"Bad Request\"\n}\n```\n\n이 패키지를 사용할 때 코드에서는 class-validator 응답 구조와 호환되는 API 응답 구조를 사용하는 것이 좋아요. \"property\"를 클라이언트 측에 활용하여 오류를 적절한 위치(예: \"property\" 하단)에 표시할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 서버에서 다국어 API 응답\n\n다국어 플랫폼에서는 서버 측에서 오류 또는 메시지를 생성해야 할 경우가 있습니다. 클라이언트 측에서는 단순히 서버에서 받은 메시지를 표시해야 합니다. 이러한 경우에는 API 응답에 메시지를 포함해야 하며 이때 클라이언트가 메시지를 적절한 위치에 표시할 수 있도록 가이드하는 속성 필드가 포함되어야 합니다.\n\n# 사용자 정의 응답 구조를 어떻게 정의할까요?\n\n코드를 DRY하게 작성하고 복잡성을 줄이며 코드를 유지보수 가능하고 개발 가능하도록 해결해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Let's Magic 🪄\n\n다국어 및 class-validator와 호환되는 사용자 지정 응답을 정의하는 좋은 방법을 찾아봅시다:\n\n- API 응답 유형 정의:\n\n```js\nexport class messagesType {\n  message: string\n  property:string\n}\nexport class ApiResponseDto<T> {\n  statusCode: number;\n  messages: messagesType[] | [];\n  data: T;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n응답 데이터를 처리하기 위해 일반 유형을 사용하고 메시지를 메시지와 속성 필드를 포함한 배열로 만듭니다.\n\nutils 서비스 또는 더 나은 곳에서 이 메서드를 정의할 수 있습니다:\n\n```js\napiResponse<T>(statusCode: number, data: any = null, message: { message: string, property: string }[] | [] = []): ApiResponseDto<T> {\n    return {\n        statusCode,\n        message,\n        data,\n    };\n}\n```\n\n이 메서드는 API 응답 구조를 생성하여 반환하며, 유효성 검사, 살균 또는 원하는 모든 것을 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3. 이제 컨트롤러에서 메소드를 사용하여 반환하세요:\n\n```js\nreturn this.utilsService.apiResponse(\n    HttpStatus.OK,\n    functionReult,\n    [{message:\"email subscribed to newsletter\",property:\"email\"}]\n )\n```\n\n4. apiResponseDto에 timeStamp, route 등의 데이터를 추가할 수 있어요. ✌️\n\n이제 API 응답 결과를 즐기세요 ❤️.\n질문은 언제든 환영이고, API 응답 구조에 대한 의견을 남겨주세요. 더 나아지도록 도와드릴게요.","ogImage":{"url":"/assets/img/2024-06-22-NestjsStructuredAPIResponse_0.png"},"coverImage":"/assets/img/2024-06-22-NestjsStructuredAPIResponse_0.png","tag":["Tech"],"readingTime":3},{"title":"NodeJS에서 자식 프로세스 멀티태스킹을 구현하는 방법","description":"","date":"2024-06-22 02:16","slug":"2024-06-22-ChildProcessesMultitaskinginNodeJS","content":"\n\n## 자식 프로세스, Spawn, Exec, ExecFile, Fork, IPC의 심층 탐험\n\n![Child Processes](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_0.png)\n\n이 글은 시니어 엔지니어를 위한 고급 NodeJS 시리즈의 다섯 번째 글입니다. 이 글에서는 자식 프로세스가 어떻게 작동하는지, 왜 필요한지, 어떻게 사용하는지를 자세히 설명하고 자식 프로세스를 사용하여 최상의 성능을 얻는 방법을 알려드리겠습니다. 공식 문서에서 자식 프로세스에 대한 자세한 내용을 확인할 수 있습니다.\n\n[고급 NodeJS 시리즈의 다른 글들](#)\n\n\n글 시리즈 로드맵\n\n* V8 JavaScript 엔진\n* NodeJS의 비동기 I/O\n* NodeJS의 이벤트 루프\n* 워커 스레드: NodeJS에서의 멀티태스킹\n* 자식 프로세스: NodeJS에서의 멀티태스킹 (이 글)\n* 클러스터링과 PM2: NodeJS에서의 멀티태스킹\n* NodeJS에 대한 흔한 오해의 해소\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\n콘텐츠 테이블\n\n* 자식 프로세스란 무엇인가요?\n* 왜 필요한 것인가요?\n  * 외부 프로그램 실행\n  * 향상된 격리성\n  * 향상된 확장성\n  * 향상된 견고성\n* 자식 프로세스 생성\n  * 프로세스 생성을 위해 .spawn() 사용\n  * 프로세스 생성을 위해 .fork() 사용\n  * 프로세스 생성을 위해 exec() 사용\n  * 프로세스 생성을 위해 execFile() 사용\n  * 동기식 프로세스 생성\n  * 언제 어떤 것을 사용해야 할까요?\n* 자식 프로세스 중단/중지/종료하기\n* 자식 및 부모 프로세스 간 I/O 처리\n  * 스트림을 함께 연결하기\n* 명령 실행 시 보안\n* 자식 프로세스가 부모 프로세스와 독립적으로 실행되도록 설정\n* spawn을 사용하여 쉘 구문 및 부모의 표준 I/O 상속 사용\n```\n\n# 자식 프로세스란 무엇인가요?\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1080/1*4FmkxDXT9kOVn-b2x6onYA.gif\" />\n\nNodeJS 애플리케이션을 실행하면 VS Code, VLC Player 등과 같이 다른 애플리케이션을 실행할 때와 마찬가지로 자체 프로세스를 가집니다. 이 프로세스의 속성은 글로벌 객체의 process 변수에 사용 가능하며 해당 값을 Node 앱 코드에서 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nNodeJS는 본질적으로 단일 스레드이지만 동기화, CPU 집약 작업을 실행해야 하는 경우와 같이 멀티 프로세스가 필요한 경우가 있을 수 있습니다. 여기서 자식 프로세스가 등장합니다. node:child_process 모듈을 사용하면 부모 프로세스와 자식 프로세스 간의 통신 채널인 IPC(Inter Process Communication)을 설정할 수 있습니다.\n\n이 모듈은 긴 작업을 처리하는 데만 한정되지 않고 운영 체제와 쉘 명령을 실행하는 능력이 있습니다. 간단히 말해, 이는 JavaScript뿐만 아니라 Git, Python, PHP 또는 다른 언어도 실행할 수 있도록 해줍니다.\n\n# 그렇다면 왜 필요했을까요?\n\n이미 CPU 집약 작업을 처리하기 위한 워커 스레드가 있는데 왜 자식 프로세스가 필요한지 궁금할 수 있습니다. 워커 스레드는 자체 힙(heap), V8 인스턴스 및 이벤트 루프를 갖고 있기 때문입니다. 하지만 동일한 프로세스 내에서 스레드보다 별도의 서브 프로세스가 더 바람직한 경우가 있습니다. 왜 그런지 설명하겠습니다:\n\n<div class=\"content-ad\"></div>\n\n## 외부 프로그램 실행\n\n자식 프로세스를 사용하면 외부 프로그램이나 스크립트를 별도의 프로세스로 실행할 수 있습니다. 다른 실행 파일과 상호 작용해야 할 때 매우 유용합니다.\n\n## 향상된 격리성\n\n워커 스레드와 달리, 자식 프로세스는 전체 Node.js 런타임의 별도 인스턴스를 제공합니다. 각 자식 프로세스는 자체 메모리 공간을 가지고 IPC(Inter-Process Communication)를 통해 주 프로세스와 통신합니다. 이러한 수준의 격리는 자원 충돌이나 분리되어야 하는 종속성이 있는 작업에 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n## 향상된 확장성\n\n자식 프로세스는 여러 프로세스 사이에서 작업을 분산하여 멀티 코어 시스템의 성능을 활용할 수 있습니다. 이를 통해 더 많은 동시 요청을 처리하고 응용 프로그램의 전체적인 확장성을 향상시킬 수 있습니다.\n\n## 향상된 안정성\n\n자식 프로세스가 어떤 이유로 인해 충돌하더라도 주 프로세스는 함께 무너지지 않습니다. 이는 응용 프로그램이 실패에도 불구하고 안정적이고 강건하게 유지됨을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n일꾼 스레드는 특정 시나리오에서 좋지만, 자식 프로세스는 외부 프로그램 실행, 격리 제공, 확장성 향상 및 견고성을 보장하는 멋진 장점을 제공합니다.\n\n# 자식 프로세스 생성\n\nchild_process 모듈을 사용하면 운영 체제 기능에 액세스할 수 있습니다. 해당 모듈은 자식 프로세스 내에서 시스템 명령을 실행하는 경우에 사용됩니다. 이러한 자식 프로세스는 동기적 및 비동기적으로 생성할 수 있습니다.\n```javascript\nconst { spawn, fork, exec, execFile } = require('child_process');\n```\n\nchild_process.spawn(), child_process.fork(), child_process.exec(), child_process.execFile() 메서드는 서브 프로세스를 비동기적으로 생성하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n각 메소드는 ChildProcess 인스턴스를 반환합니다. 이러한 객체들은 Node.js EventEmitter API를 구현하며, 부모 프로세스가 자식 프로세스의 라이프 사이클 중 특정 이벤트가 발생할 때 호출되는 리스너 함수를 등록할 수 있습니다. 예시는 다음과 같습니다.\n\n- `disconnect` 이벤트는 부모 프로세스에서 subprocess.disconnect() 메소드를 호출한 후에 발생하거나 자식 프로세스에서 process.disconnect() 메소드를 호출한 후에 발생합니다.\n- 에러 이벤트는 프로세스가 스폰되거나 종료되거나 자식 프로세스로 메시지를 보내는 데 실패했거나 자식 프로세스로 메시지를 보내는 데 실패할 때 발생합니다.\n- `close` 이벤트는 자식 프로세스의 stdio 스트림이 닫힐 때 발생합니다. 이는 `exit` 이벤트와 구별됩니다. 여러 프로세스가 동일한 stdio 스트림을 공유할 수 있기 때문입니다. `close` 이벤트는 항상 `exit`가 이미 발생한 후에 발생하거나 자식이 스폰에 실패한 경우에는 `error`가 발생합니다.\n- `exit` 이벤트는 자식 프로세스가 종료된 후에 발생합니다.\n- 메시지 이벤트는 가장 중요한 이벤트입니다. 이 이벤트는 자식 프로세스가 process.send() 함수를 사용하여 메시지를 보낼 때 발생합니다. 부모/자식 프로세스가 서로 통신하는 방법입니다.\n- `spawn` 이벤트는 자식 프로세스가 성공적으로 생성되면 한 번 발생합니다. 자식 프로세스가 성공적으로 생성되지 않으면 `spawn` 이벤트가 발생하지 않고 대신 `error` 이벤트가 발생합니다.\n\n## 프로세스 생성을 위해 .spawn() 사용하기\n\n.spawn() 메소드를 사용하여 명령어를 실행할 때 전달하려는 인수, 명령을 실행할 때 사용할 인수의 문자열 배열 형식, 마지막으로 프로세스 생성 시 일부 설정을 재정의할 수 있는 options 객체를 전달하여 자식 프로세스를 생성할 수 있습니다. 이 설정에는 환경 변수인 env, 명령을 셸 내에서 실행할지 여부인 shell, 부모가 종료된 후에도 자식 프로세스를 계속 실행할지 여부인 detached, 자식 프로세스를 중단하는 데 사용할 수있는 signal 등이 포함됩니다. 이러한 옵션에 대한 자세한 정보는 spawn의 공식 문서에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n.spawn() 메서드가 다른 프로세스 생성 메서드와 다른 점은 외부 응용 프로그램을 새로운 프로세스에서 생성하고 I/O용 스트리밍 인터페이스를 반환한다는 것입니다. 이때문에 데이터가 많이 생성되는 애플리케이션을 처리하거나 데이터가 읽히는 대로 작업하는 데 좋습니다. 스트림 기반의 I/O는 다음과 같은 이점을 제공할 수 있습니다:\n\n- 낮은 메모리 풋프린트.\n- 백프레셔를 자동으로 처리합니다.\n- 버퍼링된 청크 단위로 데이터를 게으르게 생성하거나 소비합니다.\n- 이벤트 기반이며 논블로킹입니다.\n- 버퍼를 사용하여 V8 힙 메모리 제한을 회피할 수 있습니다.\n\n각각의 자식 프로세스는 세 가지 표준 stdio 스트림을 갖는데, 이를 child.stderr, child.stdout(각각 읽기 가능한 스트림), child.stdin(쓰기 가능한 스트림)을 통해 액세스할 수 있습니다. 이러한 스트림들은 이벤트 이밋터입니다. 각 자식 프로세스에 연결된 stdio 스트림 들에서 다양한 이벤트를 감지할 수 있습니다. child.stdout와 child.stderr의 경우 데이터 이벤트를 수신하여 명령의 출력이나 명령 실행 중 발생한 오류를 확인할 수 있습니다.\n\n예를 들어 ls -lh /usr를 실행하고 stdout, stderr 및 종료 코드를 캡처하는 예제를 살펴보겠습니다. 이 예제는 리눅스/유닉스 시스템에서 실행해보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { spawn } = require('node:child_process');\nconst ls = spawn('ls', ['-lh', '/usr']);\n\nls.stdout.on('data', (data) => {\n    console.log(`stdout: ${data}`);\n});\n\nls.stderr.on('data', (data) => {\n    console.error(`stderr: ${data}`);\n});\n\nls.on('close', (code) => {\n    console.log(`child process exited with code ${code}`);\n});\n```\n\n<img src=\"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_1.png\" />\n\n한 발 더 나아가 복잡한 예제로 가보죠. 여기서는 ps | grep bash를 실행해볼 겁니다. ps 명령은 현재 진행 중인 프로세스를 반환하고 grep은 일치하는 패턴을 찾을 때 유용한 명령입니다. 여기서는 'bash'를 찾아보겠습니다. ps를 위해 하나의 프로세스가 시작될 것이며, ps.stdout의 출력 스트림을 grep의 입력 스트림으로 작성하려고 합니다. ps가 끝나면 grep의 입력 스트림을 끝내고 grep 명령이 실행될 것입니다. 아래 내용은 index.js 내부에 작성해야 합니다.\n\n```js\nconst { spawn } = require('node:child_process');\nconst ps = spawn('ps');\nconst grep = spawn('grep', ['bash']);\n\nps.stdout.on('data', (data) => {\n    grep.stdin.write(data);\n});\n\nps.stderr.on('data', (data) => {\n    console.error(`ps stderr: ${data}`);\n});\n\nps.on('close', (code) => {\n    if (code !== 0) {\n        console.log(`ps process exited with code ${code}`);\n    }\n    grep.stdin.end();\n});\n\ngrep.stdout.on('data', (data) => {\n    console.log(data.toString());\n});\n\ngrep.stderr.on('data', (data) => {\n    console.error(`grep stderr: ${data}`);\n});\n\ngrep.on('close', (code) => {\n    if (code !== 0) {\n        console.log(`grep process exited with code ${code}`);\n    }\n});\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_2.png)\n\n한번 더 예시를 살펴보겠습니다. 여기서는 명령을 실행하는 과정에서 spawn이 실패하는 예제입니다.\n\n```js\nconst { spawn } = require('node:child_process')\nconst subprocess = spawn('bad_command')\n\nsubprocess.on('error', (err) => {\n console.error('서브프로세스 시작 실패.')\n})\n```\n\n![Image](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_3.png)\n\n\n<div class=\"content-ad\"></div>\n\nWindows에서 실행할 때는 .bat 및 .cmd 파일을 shell 옵션을 설정하여 child_process.spawn()로 호출하거나 child_process.exec()를 사용하거나 cmd.exe를 생성하고 .bat 또는 .cmd 파일을 인수로 전달하는 방법(즉 shell 옵션과 child_process.exec()가 하는 방식)으로 호출할 수 있습니다. 어떤 경우에도 스크립트 파일 이름에 공백이 포함되어 있다면 인용 부호로 감싸야 합니다.\n\n## 프로세스 생성에 .fork() 사용하기\n\n.fork()는 Node.js 스크립트를 새로운 프로세스에서 실행하고 두 프로세스 간에 IPC 통신 채널을 원할 때 특히 유용합니다. child_process.fork() 메서드는 새로운 Node.js 프로세스를 생성하는 데 사용하는 child_process.spawn()의 특수한 경우입니다. child_process.spawn()과 마찬가지로 ChildProcess 객체가 반환됩니다. 반환된 ChildProcess에는 부모와 자식 간에 메시지를 교환할 수 있는 추가 통신 채널이 내장되어 있습니다.\n\nfork 메서드는 노드 프로세스 간 메시지 전달을 허용하는 IPC 채널을 열게 됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 자식 프로세스에서는 process.on('message')와 process.send('부모에게 메시지')를 사용하여 데이터를 수신하고 전송할 수 있습니다.\n- 부모 프로세스에서는 child.on('message')와 child.send('자식에게 메시지')를 사용합니다.\n\n간단한 예시를 살펴봅시다. index.js 파일입니다.\n\n```js\nconst { fork } = require('child_process');\n\nconst forked = fork('child_program.js');\n\nforked.on('message', (msg) => {\n  console.log('자식으로부터 메시지:', msg);\n});\n\nforked.send('안녕 세계');\n```\n\nchild_program.js 파일에서는\n\n<div class=\"content-ad\"></div>\n\n```js\nprocess.on('message', (msg) => {\n  console.log('부모로부터 온 메시지:', msg);\n});\n\nlet counter = 0;\n\nsetInterval(() => {\n  process.send({ counter: counter++ });\n}, 1000);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*CpWRroHhVhSmzrIwyE4zbw.gif\" />\n\n부모로부터 자식에게 메시지를 전달하려면 포크된 객체 자체에서 send 함수를 실행하고, 자식 스크립트에서는 전역 process 객체의 메시지 이벤트를 수신할 수 있습니다.\n\n상기 parent.js 파일을 실행하면 먼저 `hello world`를 포크된 자식 프로세스에서 출력하도록 전송한 다음, 포크된 자식 프로세스는 매 초마다 증가된 카운터 값을 부모 프로세스가 출력하도록 전송합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 더 실용적인 내용의 예시를 살펴보겠습니다. 아래 예시는 각각 \"일반\" 또는 \"특별\" 우선순위로 연결을 처리하는 두 개의 자식 프로세스를 생성합니다:\n\nindex.js 파일에서:\n\n```js\nconst { fork } = require('node:child_process');\nconst normal = fork('child_program.js', ['normal']);\nconst special = fork('schild_program.js', ['special']);\n\n// 서버를 열고 소켓을 자식 프로세스로 전달합니다. 소켓이 자식 프로세스로 전송되기 전에 읽히지 않도록 pauseOnConnect를 사용합니다.\nconst server = require('node:net').createServer({ pauseOnConnect: true });\nserver.on('connection', (socket) => {\n\n  // 특별한 우선순위인 경우...\n  if (socket.remoteAddress === '74.125.127.100') {\n    special.send('socket', socket);\n    return;\n  }\n  // 일반 우선순위인 경우.\n  normal.send('socket', socket);\n});\nserver.listen(1337); \n```\n\nchild_program.js 파일에서:\n\n<div class=\"content-ad\"></div>\n\n```js\nprocess.on('message', (m, socket) => {\n  if (m === 'socket') {\n    if (socket) {\n      // 클라이언트 소켓이 있는지 확인합니다.\n      // 소켓이 전송된 후 자식 프로세스에서 수신되는 동안 소켓이 닫힐 수 있습니다.\n      socket.end(`Request handled with ${process.argv[2]} priority`);\n    }\n  }\n}); \n```\n\n상기 예제에 따르면 remoteAddress에 따라 소켓이 해당 자식 프로세스로 전달됩니다. 특정 remoteAddress인 경우 특별한 서브프로세스로, 그렇지 않은 경우 일반 서브프로세스로 전달됩니다. 서브프로세스에 전달된 소켓에 .maxConnections를 사용하지 마십시오. 부모 프로세스는 소켓이 소멸된 시점을 추적할 수 없습니다. 서브프로세스의 `message` 핸들러는 소켓이 존재하는지 확인해야 합니다. 소켓이 전달되는 동안 연결이 닫힐 수 있습니다.\n\n## process 생성을 위한 exec() 사용\n\nexec 함수는 쉘 구문을 사용해야 하고 명령에서 예상되는 데이터의 크기가 작은 경우 좋은 선택입니다. exec 함수는 명령에서 생성된 출력을 버퍼링하고 전체 출력 값을 콜백 함수에 전달합니다 (spawn이 스트림 대신에 사용하는 것입니다).\n\n<div class=\"content-ad\"></div>\n\n워커가 셸을 설정하고 해당 셸 내에서 명령을 실행합니다. 콜백 함수가 제공된 경우에는 해당 함수가 (error, stdout, stderr) 인자를 사용하여 호출됩니다. 성공할 경우 error는 null이 됩니다. 오류 발생 시 error는 Error의 인스턴스가 됩니다. error.code 속성은 프로세스의 종료 코드가 됩니다. 콜백에 전달된 stdout 및 stderr 인자에는 자식 프로세스의 표준 출력 및 표준 오류 출력이 포함됩니다.\n\n간단한 예제를 살펴봅시다. cat 명령어로 index.js 파일을 읽고 wc -l 명령어로 결과의 라인 수를 세어 보겠습니다.\n\n```js\nconst { exec } = require('node:child_process')\nexec('cat index.js | wc -l', (error, stdout, stderr) => {\n if (error) {\n  console.error(`exec error: ${error}`)\n  return\n }\n console.log(`stdout: ${stdout}`)\n console.error(`stderr: ${stderr}`)\n})\n```\n\n![그림](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_4.png)\n\n<div class=\"content-ad\"></div>\n\n이 exec에 추가할 수있는 흥미로운 특징은 Options 개체에서 몇 가지 설정을 제공하는 것입니다. 예를들어 cwd 옵션을 사용하여 스크립트의 작업 디렉토리를 변경할 수 있습니다. 예를들어, 위의 예제를 다른 디렉토리에서 실행하도록 설정할 수 있습니다.\n\n아래의 Markdow 형식으로 표를 변경해주셔야합니다.\n\nSince the exec function uses a shell to execute the command, we can use the shell syntax directly here making use of the shell pipe feature.\n\n## Using execFile() for process creation\n\n<div class=\"content-ad\"></div>\n\n그 파일을 쉘을 사용하지 않고 실행해야 할 경우, execFile 함수가 필요합니다. 이 함수는 exec 함수와 정확히 동일하게 작동하지만 쉘을 사용하지 않기 때문에 조금 더 효율적입니다.\n\n```js\nconst { execFile } = require('node:child_process');\nconst child = execFile('node', ['--version'], (error, stdout, stderr) => {\n  if (error) {\n    throw error;\n  }\n  console.log(stdout);\n});\n```\n\n![Child Processes in Node.js](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_6.png)\n\nWindows에서는 .bat 또는 .cmd 확장자와 같이 특정 파일은 자체로 실행할 수 없습니다. 이러한 파일은 execFile로 실행할 수 없으며, 실행하려면 exec 또는 spawn을 shell 속성을 true로 설정하여 실행해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 동기적 프로세스 생성\n\n.spawnSync, .execSync 및 .execFileSync 메서드는 동기적이며 Node.js 이벤트 루프를 차단하며, 생성된 프로세스가 종료될 때까지 추가 코드의 실행을 일시 중지합니다.\n\n이러한 차단 호출은 주로 일반 스크립팅 작업을 간소화하고 시작시 응용 프로그램 구성의 로드/처리를 간단화하는 데 유용합니다.\n\n## 언제 어떻게 사용해야 하나요?\n\n<div class=\"content-ad\"></div>\n\n\n![Child Processes Multitasking in NodeJS](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_7.png)\n\n# 자식 프로세스 중지 및 종료\n\n자식 프로세스를 종료하는 몇 가지 방법이 있습니다.\n\n- ChildProcess 객체에서 .kill()을 사용하여.\n- 옵션 객체의 타임아웃 옵션을 사용함으로서. 프로세스가 실행되는 최대 시간을 밀리초로 설정해야 합니다. 기본값: 정의되지 않음\n- 시그널을 사용하여, 시그널 옵션이 활성화된 경우, 해당 AbortController에서 .abort()를 호출하는 것은 child 프로세스에서 .kill()을 호출하는 것과 유사하게 동작하지만 콜백에 전달된 오류가\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { spawn } = require('node:child_process');\nconst controller = new AbortController();\nconst { signal } = controller;\nconst grep = spawn('grep', ['ssh'], { signal });\ngrep.on('error', (err) => {\n  // controller가 중단되면 AbortError가 err로 전달될 것입니다\n});\ncontroller.abort(); // 차일드 프로세스를 중지합니다\n```\n\n# 자식 및 부모 프로세스 간의 I/O 처리\n\nstdio 옵션은 자식 프로세스의 입/출력 대상을 결정하는 데 책임이 있습니다. 이는 배열 또는 문자열로 할당할 수 있습니다. 문자열 값은 흔히 사용되는 배열 구성으로 자동 변환되는 편리한 바로 가기로 작동합니다.\n\n기본적으로 stdio는 다음과 같이 구성됩니다\nstdio: 'pipe'\n다음과 같은 배열 값의 단축키입니다:\nstdio: [ 'pipe', 'pipe', 'pipe' ]\n\n\n<div class=\"content-ad\"></div>\n\n위 코드는 ChildProcess 객체가 파일 기술자 0부터 2까지 액세스 제공하는 스트림 (child.stdio[0], child.stdio[1], child.stdio[2])를 갖게 됨을 의미합니다.\n\n만약 입출력을 다른 곳으로 보내려면 파일 기술자를 할당할 수 있는 옵션이 있습니다. 반면, 완전히 무시하고 싶다면 'ignore'를 사용할 수도 있습니다.\n\n예를 통해 설명해보겠습니다. 예를 들어 입력을 제공하지 않을 자식 프로세스를 생성하고자 한다면 입력 FD 0 (stdin)을 무시하고 출력 FD 1(stdout)과 오류 FD 2(stderr)를 별도의 로그 파일에 기록하려는 경우에 대해 알아봅시다. 이렇게 구현할 수 있습니다.\n\n```js\nlet fs = require('fs')\nlet cp = require('child_process')\n\nlet outFd = fs.openSync('./outputlogs', 'a')\nlet errFd = fs.openSync('./errorslogs', 'a')\nlet child = cp.spawn('ls', [], {\n stdio: ['ignore', outFd, errFd]\n})\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_8.png\" />\n\n## 스트림을 연쇄시키기\n\n한 프로세스의 출력이 다음 프로세스에 공급되는 프로그램을 작성해 봅시다. cat 명령어는 데이터를 파일에서 읽고, 이 데이터를 sort 명령어의 입력으로 전달하여 정렬된 라인을 출력으로 제공할 것이며, 이것은 다시 중복된 줄을 제거할 uniq 명령어의 입력으로 제공되어야 합니다.\n\nin filesToBeChecked.txt\n\n<div class=\"content-ad\"></div>\n\n\nLOL\nLMAO\nROLF\nLOL\nGTG\n\n\n`index.js` 파일에서:\n\n```javascript\nlet cp = require('child_process')\nlet cat = cp.spawn('cat', ['filesToBeChecked.txt'])\nlet sort = cp.spawn('sort')\nlet uniq = cp.spawn('uniq')\ncat.stdout.pipe(sort.stdin)\nsort.stdout.pipe(uniq.stdin)\nuniq.stdout.pipe(process.stdout)\n```\n\n<img src=\"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_9.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n## 명령 실행과 보안\n\n자식 프로세스가 셸에 액세스할 수 있도록 허용할 때 주의해야 합니다. 셸 구문을 사용하는 것이 보안 위험을 초래할 수 있음을 인식하는 것이 중요합니다, 특히 외부 소스에서 동적 입력을 다룰 때 그렇습니다. 이는 사용자가 셸 구문 문자인 ';' 나 '$' 와 같은 문자를 이용하여 악성 명령을 실행할 수 있는 명령 주입 공격의 가능성을 남겨둡니다. 예를 들어 사용자가 command + '; rm -rf ~' 와 같은 명령을 입력하여 중요 파일을 삭제할 수 있습니다.\n\n예시를 살펴보겠습니다. (시스템에서 하지 마세요)\n\n<div class=\"content-ad\"></div>\n\n유저 입력을 받아 명령어를 실행하는 프로세스가 있다고 가정해 봅시다. 이 때, 입력을 받아 실행하는 명령어가 exec를 이용하여 다음과 같이 구성된 경우가 있습니다.\ncp.exec(`고정된 명령어` + req.query.userInput);\n악의적인 사용자가 \" ; rm -rf / ;\" 와 같이 입력을 제공했다고 가정해 봅시다.\n아직 이해가 안 된 분들을 위해 설명드리자면, 이 메시지는 정확히 \"새로운 명령어(;)를 실행하여 파일 시스템의 중심부에 있는 모든 파일과 디렉토리를 강제로 철저히 삭제하고(; rm -rf /), 명령어를 종료시킵니다(;), 뒤에 뭔가가 더 올 경우 처리합니다.\" 를 의미합니다.\n\n만약 셸 기능을 필요로 하지 않고 응용 프로그램을 실행하려면, 실제로 execFile을 사용하는 것이 더 안전하고(그리고 약간 빠릅니다).\ncp.execFile('고정된 명령어', [req.query.schema]);\n\n여기서 악의적인 인젝션 공격은 셸에서 실행되지 않으므로 실패하고, 외부 응용 프로그램은 전달된 인수를 이해하지 못하고 오류를 발생시킬 가능성이 높습니다.\n\n# 부모 프로세스와 독립적으로 실행되는 자식 프로세스\n\n<div class=\"content-ad\"></div>\n\n아래 사항을 주의해야 합니다:\n- 기본적으로 부모 프로세스는 분리된(떨어져 있는) 자식 프로세스의 종료를 기다릴 것입니다.\n- 부모 프로세스와 노드를 연결하는 몇 가지 사항이 있습니다. 부모 프로세스와 자식 프로세스 사이의 참조인 ref 및 부모와 자식 간에 형성된 통신 채널이 있습니다.\n\n자식 프로세스가 독립적으로 실행되도록 만드는 방법은 다음과 같습니다:\n\n- 부모 프로세스가 자식 프로세스 종료 후에도 계속되도록 원한다면, 옵션 객체 중 하나인 option.detached 옵션을 사용할 수 있습니다.\nWindows에서 options.detached를 true로 설정하면 부모 프로세스가 종료된 후에도 자식 프로세스가 계속 실행됩니다. 한 번 활성화되면 다시 비활성화할 수 없습니다.\nWindows 이외의 플랫폼에서 options.detached가 true로 설정된 경우, 자식 프로세스는 새로운 프로세스 그룹 및 세션의 리더로 만들어집니다. 자식 프로세스는 분리되었든 그렇지 않든 부모가 종료되어도 계속 실행할 수 있습니다.\n- 부모의 이벤트 루프에서 자식 프로세스의 참조를 유지하면 부모가 종료되지 않습니다. 이 참조를 제거하려면 해당 childprocess에 .unref()를 호출하면 됩니다. (참조를 다시 추가하려면 .ref()를 호출할 수도 있습니다.)\n- options.stdio는 부모와 자식 간의 채널을 나타냅니다. options.stdio 옵션은 부모와 자식 프로세스 간에 설정되는 파이프를 구성하는 데 사용됩니다. 이 옵션을 'ignore'로 설정하면 이 통신 채널을 무시하도록 지시합니다. 더 많은 정보는 공식 문서를 참조하세요.\n\n부모의 종료를 무시하려면 부모의 stdio 파일 디스크립터를 무시하여 자식 프로세스를 분리하고 또한 부모의 stdio 파일 디스크립터를 무시하도록 설정한 장기 실행 프로세스의 예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { spawn } = require('node:child_process');\n\nconst subprocess = spawn(process.argv[0], ['child_program.js'], {\n  detached: true,\n  stdio: 'ignore',\n});\n\nsubprocess.unref();\n```\n\n더 복잡한 예제를 살펴봅시다. options.stdio를 사용하면 스트림을 어떻게 정의할지 알려줍니다.\n예를 들어, 입력 스트림으로 pipe를 전달하고 출력 스트림으로 파일 설명자를 전달하며 현재 주 프로세스의 에러 스트림을 오류 스트림으로 전달하려면 이 옵션이 [`pipe`, fd, process.stderr]와 같이 설정됩니다.\n모든 std 스트림을 무시하려면 이전 예제와 같이 'ignore'를 전달하면 됩니다. ignore를 전달하는 것은 ['ignore', 'ignore', 'ignore']를 전달하는 것과 동일합니다. ignore 외에도 pipe, inherit, overlapped, ipc, null, undefined와 같은 다른 옵션이 있습니다. 자세한 내용은 공식 문서를 참조하세요.\n\n파일 설명자를 자식 프로세스에게 출력 스트림으로 전달하여 자식이 지정된 파일에 출력을 작성할 수 있도록 하는 방법을 통해 이를 설명해 보겠습니다.\nindex.js에서\n\n```js\nconst fs = require('node:fs')\nconst { spawn } = require('node:child_process')\nconst out = fs.openSync('./out.log', 'a')\n\nconst subprocess = spawn('node', ['child_program.js'], {\n detached: true,\n stdio: ['ignore', out, process.stderr]\n})\n\nsubprocess.unref()\n```\n\n<div class=\"content-ad\"></div>\n\nchild_program.js 파일에는 아래와 같은 내용이 있습니다.\n\n```js\nconst { spawn } = require('node:child_process')\nconst ls = spawn('ls', ['-lh', '/usr'])\n\nls.stdout.on('data', (data) => {\n console.log(`stdout: ${data}`)\n})\n\nls.stderr.on('data', (data) => {\n console.error(`stderr: ${data}`)\n})\n\nls.on('close', (code) => {\n console.log(`child process exited with code ${code}`)\n})\n```\n\n![여기](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_10.png)에서 설명한 예제는 fork를 사용하여 동일한 결과를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst fs = require('node:fs')\nconst { fork } = require('node:child_process')\nconst out = fs.openSync('./out.log', 'a')\n\nconst subprocess = fork('child_program.js', [], {\n detached: true,\n stdio: ['ipc', out, process.stderr]\n})\n\nsubprocess.unref()\r\n```\n\n# 스폰을 사용하여 쉘 구문 및 부모의 표준 IO 상속하기\n\n만약 우리가 원한다면, 생성된 자식 프로세스가 부모의 표준 IO 객체들을 상속받게 할 수 있지만, 더 중요한 것은 스폰 함수가 쉘 구문을 사용하도록 만들 수 있다는 것입니다.\n\n아래 예시를 살펴봅시다.\n\n\n<div class=\"content-ad\"></div>\n\nchild_program.js에 위의 코드를 붙여넣기해주세요.\n\n```js\nconst { spawn } = require('node:child_process')\nconst ls = spawn('ls', ['-lh', '/usr'])\nls.stdout.on('data', (data) => {\n console.log(`stdout: ${data}`)\n})\nls.stderr.on('data', (data) => {\n console.error(`stderr: ${data}`)\n})\nls.on('close', (code) => {\n console.log(`child process exited with code ${code}`)\n})\n```\n\nstdio: `inherit` 및 shell: true을 사용하지 않고\n\nindex.js에서 실행해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { spawn } = require('node:child_process');\nconst ps = spawn('node child_program.js', {\n\n});\n```\n\n![Child Processes Multitasking in Node.js](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_11.png)\n\nspawn 함수가 쉘 구문을 이해하지 못해서 에러가 발생했어요.\n\n새로운 옵션인 shell을 추가해보는 건 어때요?\n\n<div class=\"content-ad\"></div>\n\nin index.js\n\n```js\nconst { spawn } = require('child_process');\nconst ps = spawn('node child_program.js', { shell: true });\n```\n\n![Child Processes Multitasking in NodeJS](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_12.png)\n\nThere are a few things to note here. With the use of `shell: true`, the `spawn` method is now able to interpret the shell syntax and run the `child_program.js`. However, the output of the child process is not visible because the terminal/console we are currently viewing is connected to the main process's standard IO streams, not the subprocess's. To display the output of the child process in the main process's terminal, we need to share the main IO stream with the child process. This can be achieved by using the `stdio: 'inherit'` option.\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 바꿔보세요.\n\n```js\nconst { spawn } = require('node:child_process')\nconst ps = spawn('node child_program.js', {\n stdio: 'inherit',\n shell: true\n})\n```\n\n![Child Processes Multitasking in NodeJS](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_13.png)\n\n`stdio: 'inherit'` 옵션을 추가해보세요. 코드를 실행하면, 자식 프로세스가 주 프로세스의 stdin, stdout 및 stderr를 상속받게 됩니다. 이로 인해 자식 프로세스 데이터 이벤트 핸들러가 주 프로세스 stdout 스트림에서 트리거되어 결과를 즉시 출력하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n위의 shell: true 옵션 덕분에 전달된 명령어에서 exec와 마찬가지로 셸 구문을 사용할 수 있었습니다. 그러나 이 코드로는 spawn 함수가 제공하는 데이터의 스트리밍 이점도 누릴 수 있습니다.\n\n# 떠나기 전에!\n\n- 더 많은 통찰을 기대해 주세요! 팔로우하고 구독해주세요.\n- 박수 👏 버튼을 클릭하고 누르면 무슨 일이 벌어지는지 보셨나요?","ogImage":{"url":"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_0.png"},"coverImage":"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_0.png","tag":["Tech"],"readingTime":20},{"title":"LinkedIn에서 만난 수상한 블록체인 구직 제안, 어떻게 대처해야 할까","description":"","date":"2024-06-22 02:14","slug":"2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn","content":"\n\n\n<img src=\"/assets/img/2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn_0.png\" />\n\n몇 일 전에 한 사람이 블록체인 관련 직업으로 나에게 LinkedIn을 통해 연락했어. 그는 내 GitHub 계정을 공유해달라고 하고 나에게 그의 프로젝트를 실행하여 해결책을 확인하라고 했지.\n\n초대장을 받자, 리포지토리가 포크되거나 Codespaces에서 사용되지 않는 걸 깨달았어. 그래도 처음에는 그렇게 심각하게 생각 안 했어. 노트북이 많이 무겁고, 더 이상 불필요한 프로젝트를 설치하고 싶지 않았기 때문에, 결국 Hostinger의 작은 개발 서버에서 실행하기로 결정했어.\n\n코드를 실행하고 결과를 그에게 보냈어. 그는 몇 가지 오류를 지적하고, 특히 node_modules를 설치하기 위해 다음을 강조한 지침을 공유했어.\n\n<div class=\"content-ad\"></div>\n\n\n# 노드 버전 16.20.0이 필요합니다.\nnpm i --force\nnpm start\n\n\n--force 플래그는 레지스트리에서 강제로 설치하여 기존 종속성을 제거하고 새로운 종속성을 설치합니다. 그는 \"적절한\" 종속성이 설치되었는지 확인하기 위해 현재 node_modules 폴더를 지우고 다시 설치하라고 지시했습니다. 물론 나는 의심 없이 그의 지시에 따랐어요.\n\n업데이트된 결과물을 보내자, 그는 VPN, VPS 또는 WSL을 사용했는지 물어보았습니다. 나는 VPN과 VPS를 둘 다 사용했다고 확인했습니다. 그러자, 그는 미안하다며 그의 프로젝트는 VPN을 지원하지 않고 로컬 설치를 요구한다고 말했습니다. 그 순간부터 조금 수상한 것을 느끼기 시작했습니다. 결과가 명확했고 오류도 없었는데 문제가 무엇인지 물어보았습니다. 그는 API가 잘 작동하지 않았다고 주장했습니다.\n\nVPN이 문제가 아니라고 말했는데, 나는 자체 서버에서 실행하고 있고 VPN을 끄어도 아무 영향도 없다고 말했습니다. 그는 그 후 내 OS에 대해 물었고, 나는 Ubuntu를 사용한다고 대답했습니다. 그에게서는 그의 개발팀 문화가 Mac 또는 Windows를 선호하며 개발할 때 VPN을 사용하지 않는다고 응답했습니다 (흠?). \n\n\n<div class=\"content-ad\"></div>\n\n내가 그에게 말했어, \"당신의 프로젝트에 대해 더 많은 세부 정보를 가지게 되면 내 로컬 맥북을 사용해서 개발할 거야.\" 그는 팀 문화 때문에 곧잘 고치길 바란다며 내게 말했어. 난 당신이 이해하길 바랐지만\n\n나는 대답했어, \"프로젝트를 이해하고 뭘 업그레이드할지 더 자세히 말해주시면 당신의 요구 사항에 적응할게요. 지금은 테스트를 위해 배포만 했습니다.\"\n\n그는 괜찮다고 하고 작업 목록을 공유하기 시작했고 예산을 세팅해달라고 했어. 난 주변을 확인하고 나중에 알려줄 거라고 했어.\n\n하루가 지나 그가 다시 나에게 연락해 일이 어떻게 되고 있는지 물었어. 나는 사과하고 그의 요구 사항에 대한 타임라인, 다른 개발자, 그리고 이 프로젝트의 급여에 대해 물었어. 그는 매달 5천-1만 달러를 제안했어.\n\n<div class=\"content-ad\"></div>\n\n깃허브를 다시 확인하기로 결정했는데, 레포에서 제 이름이 지워져 있었어요. 그래서 다시 초대장을 받도록 요청했어요. 새 초대장을 받고 보니 레포가 단 3시간 전에 만들어진 것을 알게 됐어요. 이제 제 의심은 90%까지 올랐어요.\n\n그래도 계속 대화를 이어가기 위해 몇 가지 조건을 제안했어요. 그 모든 것에 동의를 해주었어요. 심지어 첫 달에 $9,000을 요청했을 때도요.\n\n그 동안 다른 격리된 개발 환경을 설정하여 레포를 파헤치기 시작할 수 있도록 했어요. 하루를 들여서 조사를 시작했지만 아무 것도 찾지 못해서 그만두고 제 사업으로 돌아갔어요.\n\n며칠 후, 클라우드 제공업체로부터 서버에 악성 소프트웨어가 발견되었음을 알리는 이메일을 받았어요. 이후 2시간 후, 서버가 리소스 한도를 초과하여 남용으로 중단되었음을 알리는 다른 이메일을 받았어요. 서버를 다시 활성화하기 위해 제공업체에 연락해야 했어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn_1.png\" />\n\n# 의심스러운 조직 제안과 배운 점\n\n처음부터 발견한 몇 가지 의심스러운 점은 다음과 같습니다:\n\n- GitHub 레포지토리가 포킹되거나 Codespaces에서 사용되지 않았습니다.\n- 레포지토리는 최신의 최소한의 커밋으로 새롭게 만들어졌습니다.\n- 로컬 종속성 대신 종속성을 강제로 설치하는 것이 필요했습니다.\n- 팀 및 프로젝트에 대한 의심스러운 정보가 있었습니다.\n- 다양한 조건이 포함된 높은 제안이 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n마침내, 이 경험을 공유하여 다른 사람들에게 새로운 공격 벡터에 대해 알리고 싶어요. 다른 개발자들과 공유해주세요.\n\n그리고 모르는 것을 실행하지 말라는 경고를 꼭 기억해주세요!\n\n관련해서 유용한 기사를 찾아보았습니다:\n\n블록체인 활동을 모니터링하기 위한 도구를 개발했는데, 이는 여기에서 확인할 수 있어요: [https://www.crypitor.com/](https://www.crypitor.com/)\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트는 오픈소스입니다. https://github.com/crypitor/blockchain-webhook\n\n테스트, 피드백 및 생각을 공유해주시면 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn_0.png"},"coverImage":"/assets/img/2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn_0.png","tag":["Tech"],"readingTime":3}],"page":"28","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}