{"pageProps":{"posts":[{"title":"크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까","description":"","date":"2024-05-12 23:28","slug":"2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread","content":"\n\n<img src=\"/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png\" />\n\n# 목차\n\nChrome의 성능 패널에 익숙해지기\n\n- 프로파일러의 사용자 인터페이스 이해\n- 사전 설정 단계\n\n\n\n프로파일링을 시작해봐요!\n\n- CPU 활용률\n- 네트워크 요청 타임라인\n- 프레임 및 이벤트 타이밍\n- JavaScript 주 스레드\n\n팁: 프로파일러를 효과적으로 사용하는 방법\n\n- 예시 1: LCP 성능 저하 조사하기\n- 예시 2: 클릭 동작 시 어플리케이션이 멈추는 현상 조사하기\n\n\n\n프론트엔드 개발자로서, 크롬의 성능 패널에 있는 자바스크립트 프로파일러를 들어본 적이 있거나 마주쳐 본 적이 있을지도 모릅니다. 초안에서는 차트와 그래프가 압도적으로 보일 수 있습니다.\n\n![Chrome Performance Panel](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_1.png)\n\n처음에는 다소 복잡해 보일 수 있지만, 자바스크립트 프로파일러는 디버깅에 매우 유용합니다. 이 도구를 사용하면 애플리케이션을 실행할 때 자바스크립트 메인 스레드에서 발생하는 모든 일들을 살펴볼 수 있습니다. 이 글에서는 크롬의 성능 패널을 사용한 프로파일링에 관한 제 경험을 공유하겠습니다.\n\n# 크롬의 성능 패널에 친숙해지기\n\n\n\n## 프로파일러의 사용자 인터페이스 이해하기\n\n프로파일러의 모든 설정을 다루지는 않겠습니다. 오직 몇 가지 중요한 기능만이 필수이며 앱 프로파일링을 위해 구성될 것입니다.\n\n![프로파일러](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_2.png)\n\n- 녹화 및 프로파일링 시작 및 페이지 다시로드하는 작업 버튼과 Clear 버튼이 있습니다.\n- 프로파일링 레코드의 이력.\n- 스크린샷 및 JavaScript 힙 메모리 사용량을 프로파일링과 함께 보여주는 옵션.\n- CPU 및 네트워크 쓰로틀링.\n\n\n\n기능에 대한 포괄적인 문서를 원하시면 Chrome DevTools 성능 문서를 참고해보세요.\n\n## 사전 구성 단계\n\n정확한 결과를 보장하고 디버깅 프로세스를 쉽게 해 하기 위해 다음 설정을 고려해보세요:\n\n- 시크릿 모드: 시크릿 모드에서 Chrome을 실행하면 브라우저에 영향을 미치지 않도록 확장 프로그램을 비활성화하고 캐시를 지움으로써 성능 측정에 영향을 주지 않도록합니다.\n- Localhost 대 Production: 저는 TypeScript, React 또는 Webpack과 같은 번들러를 사용하는 프로젝트에서 트랜스 파일 된 또는 최소화된 코드에 문제가 발생하는 것을 피하기 위해 localhost에서 프로필링을 선호합니다. 소스 코드 추적을 쉽게 하기 위해 Chrome DevTools에 소스 맵을 업로드하여 제품 프로필링을 위해 정확한 소스 코드를 파일에 매핑하세요.\n- CPU 쓸개 (4배 느리게): 주요 사용자 그룹이 모바일 기기를 사용하는 경우 CPU 쓸개를 활성화하는 것을 고려해보세요. 주의할 점은 쓸개 속도가 귀하의 기기의 CPU 성능을 기준으로 하며 결과가 다른 기기에서 달라질 수 있다는 점입니다.\n- 네트워크 쓸개 (느린 3G): 네트워크를 Fast 3G 또는 Slow 3G로 설정하는 것을 추천합니다. 이 접근 방식은 네트워크 병목 현상을 더 명확하게 드러낼 수 있습니다.\n\n\n\n# 프로파일링을 시작해봐요\n\n만약 우리가 index.html 파일에 다음과 같은 코드 조각이 있다고 가정해봅시다:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <h1>API에서 데이터 가져오기:</h1>\n    <div id=\"api-data\">로딩 중...</div>\n    <script>\n      const getData = async () => {\n        const apiUrl = \"https://jsonplaceholder.typicode.com/todos/1\";\n        try {\n          const response = await fetch(apiUrl);\n          if (!response.ok) {\n            throw new Error(\"네트워크 응답이 올바르지 않습니다.\");\n          }\n          const data = await response.json();\n          document.getElementById(\"api-data\").innerHTML = `\n                    <p>제목: ${data.title}</p>\n                `;\n        } catch (error) {\n          document.getElementById(\"api-data\").innerText =\n            \"데이터를 불러오는 데 실패했습니다.\";\n        }\n      };\n      document.addEventListener(\"DOMContentLoaded\", getData);\n    </script>\n  </body>\n</html>\n```\n\n이 코드는 로딩한텍스트를 출력한 후 더미 데이터를 가져 오기 위해 HTTP 요청을 보내고 그것으로 로딩 텍스트를 바꾸는 역할을 합니다. 이렇게 간단해요.\n\n\n\n인크ognito Chrome 창에서 index.html을 열고 \"프로파일링 시작 및 페이지 다시로드\" 버튼을 클릭해 보세요.\n\n다음은 결과입니다.\n\n## CPU 활용률\n\n![Image](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_3.png)\n\n\n\n상단 섹션(빨간 상자)은 CPU 활용을 나타내며, 다양한 브라우저 활동을 나타내는 다양한 색상이 있습니다. 예를 들어 스크립팅, 렌더링, 페인팅 또는 아이들 활동이 있습니다. 이러한 것들은 보통 JavaScript 주 스레드 활동에 상응합니다.\n\n이 특정 시간대에 CPU는 대부분 유휴 상태입니다. HTML 구문 분석, DOMContentLoaded의 이벤트 핸들러 실행 및 레이아웃 단계에 사용되는 것들이 필요합니다. 레이아웃 단계는 브라우저 렌더링 단계 중 하나이며, 모든 노드의 차원과 위치를 계산하고 페이지의 각 객체의 크기와 위치를 결정합니다. 브라우저 렌더링 프로세스에 대해 더 자세히 알아보려면 여기를 읽어보세요: 브라우저 작동 방식 - 렌더링.\n\n## 네트워크 요청 타임라인\n\n![Network Request Timeline](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_4.png)\n\n\n\n네트워크 요청 타임라인에서는 API 엔드포인트인 https://jsonplaceholder.typicode.com/todos/1이 호출되고 응답이 약 2초 후에 반환되는 것을 볼 수 있습니다.\n\n## 프레임 및 이벤트 타이밍\n\n![Frames and Event Timings](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_5.png)\n\n프레임 타임라인은 API 응답이 반환될 때 텍스트 로드부터 결과를 렌더링하는 과정을 알려줍니다. 이벤트 타이밍 타임라인에서는 DCL (DOM 내용 로드됨), FCP (첫 번째 콘텐츠 페인트), L (로드됨), LCP (가장 큰 콘텐츠 페인트)와 같은 다양한 이벤트를 보여줍니다.\n\n\n\n## 자바스크립트 메인 스레드\n\n![자바스크립트 메인 스레드](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_6.png)\n\n자바스크립트 메인 스레드의 모든 활동과 각 활동을 완료하는 데 소요된 시간을 보여줍니다. 호출 스택을 시각화하며 각 레이어가 작업을 나타냅니다. 각 작업을 완료하는 데 소요된 자체 시간과 총 시간을 제공합니다.\n\n![작업 시간 시각화](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_7.png)\n\n\n\n자기 시간은 해당 메서드가 그 안에서 호출된 다른 메서드로 인해 발생한 시간을 제외하고 코드 라인 전체를 실행하는 데 걸리는 시간을 의미합니다. 총 시간은 해당 메서드 자체와 내부에서 호출된 다른 메서드에 의해 소요된 시간을 포함합니다.\n\n화염 차트에서는 위에서 아래로 쌓인 함수들을 볼 수 있습니다. JavaScript 이벤트 루프는 호출 스택을 확인하고 다음 호출 스택을 시작하기 전에 비어 있는 상태에서 LIFO (Last In, First Out) 순서로 쌓인 모든 작업을 실행합니다. 이는 JavaScript가 단일 스레드 언어임을 나타내며, 즉 한 번에 하나의 작업을 수행할 수 있다는 것을 보여줍니다.\n\n위의 화염 차트에서 JavaScript 메인 스레드에서 어떤 작업이 발생하는지 설명하기 위해 몇 가지 중요한 부분에 대해 강조해 보겠습니다.\n\n\n\n초록 상자 안에는 최상위 함수가 DOMContentLoaded에 대한 이벤트 핸들러이고, 콜백 함수는 getData() 함수입니다. 이 함수는 Fetch API를 호출하여 HTTP 요청을 보내는 것을 담당합니다. 이 시점에서 fetch 작업은 브라우저의 Web API로 전달됩니다.\n\n자바스크립트 이벤트 루프에서 자바스크립트 엔진은 다음 매크로태스크를 시작하기 전에 실행할 마이크로태스크가 있는지 확인합니다. API 호출이 메인 자바스크립트 스레드 외부에서 처리되므로, 데이터가 도착하기 전에 브라우저 렌더링 단계(빨간 상자에 표시됨)나 기타 동기 코드와 같은 다른 매크로태스크를 계속 실행합니다.\n\n데이터가 도착하면 프로미스의 해결(resolve) 부분(try-catch 블록 내 await 뒤에 배치된 코드)이 마이크로태스크로 예약됩니다. 현재 매크로태스크가 완료되면, 이벤트 루프는 다음 매크로태스크로 넘어가기 전에 모든 누적된 마이크로태스크를 처리합니다.\n\n\n\n이 문서는 단일 스레드 JavaScript가 매크로태스크와 마이크로태스크 개념을 사용하여 I/O 작업을 비차단으로 수행하는 방법을 완벽하게 보여줍니다. 이를 통해 UI가 상호작용하고 응답성을 유지할 수 있습니다.\n\n# 팁: 프로파일러를 효율적으로 활용하는 방법\n\nJavaScript 메인 스레드 타임라인에서 특정 함수를 검색하려면 키보드 단축키 Command + F를 사용할 수 있습니다. 일반적으로, 조사하려는 이벤트나 네트워크 요청을 먼저 찾고, 그런 다음 JavaScript 메인 스레드의 작업들을 살펴보곤 합니다.\n\n## 예시 1: LCP 성능 저하 조사하기\n\n\n\n앱이 콘텐츠를 로드하는 데 오랜 시간이 걸리거나 LCP 점수가 낮은 이유를 알아보고 싶다면 DOMContentLoaded 이벤트를 검색하여 콜 스택에서 발생하는 작업을 확인할 수 있습니다. 프리즈는 일반적으로 오랜 작업으로 인해 발생하며, 이는 콜 스택이 50ms 이상 소요되는 것을 의미합니다.\n\n## 예시 2: 클릭 작업에서 앱 프리징 조사하기\n\n버튼을 클릭할 때 앱이 왜 멈추는지 조사하고 싶다면 녹화를 시작하고 해당 작업을 수행하세요. 그런 다음 마우스 이벤트인 Event: pointerdown 또는 Event: mousedown을 검색하고 콜 스택의 기능을 검토하세요.\n\n또한 스크린샷을 사용하여 조사하고자 하는 특정 시간대를 파악할 수도 있습니다.\n\n\n\n프로파일러는 디버깅 및 브라우저, JavaScript, 심지어 프레임워크 작동 이해에 매우 유용한 도구입니다! 여기서 무언가를 배웠으면 좋겠네요. 프로파일링을 즐기세요!","ogImage":{"url":"/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png"},"coverImage":"/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png","tag":["Tech"],"readingTime":6},{"title":"DOM 기반 XSS에 대해서 알아보자","description":"","date":"2024-05-12 23:27","slug":"2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration","content":"\n안녕하세요 여러분, 모두 잘 지내시길 바랍니다.\n이 글은 DOM XSS에 관한 것이며, 클라이언트 측 JavaScript의 소스 코드 분석만으로도 DOM XSS를 찾아낼 수 있는 방법에 대해 다룹니다.\n\n웹 애플리케이션의 클라이언트 측 코드를 분석하는 중에 보안 취약점이 발견되었습니다. 이 취약점은 DOM 기반 크로스사이트 스크립팅(XSS) 공격을 허용합니다.\n\n![DOM XSS](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png)\n\n이 취약점은 URL 매개변수에서 가져온 사용자 입력을 잘못 처리한 것에서 비롯됩니다. 애플리케이션은 window.location.search 함수를 사용하여 utm_source 및 utm_campaign 두 매개변수를 가져옵니다. 이 매개변수는 그런 다음 getUrlParameter() 함수로 전달됩니다.\n\n![이미지](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_1.png)\n\n이 함수는 URL 쿼리 문자열에서 특정 매개변수의 값을 추출하고 디코딩한 후 해당 값을 반환하는 데 목적을 둡니다. 예를 들어, URL이 다음과 같은 경우 https://exapmle.com/redact?utm_source=hello Figure 1의 아래 코드가 실행됩니다.\n\ngetUrlParamter(`utm_source`, queryString) 함수는 utm_source 매개변수인 hello의 값을 반환하여 utm_source 변수에 저장할 것이며, utm_campaign 매개변수에 대해서도 동일합니다.\n\n![이미지](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_2.png)\n\n그림 3에서 utm_campaign 매개변수 값이 \"closedDomains\"로 설정되면, 애플리케이션은 utm_source의 값에 따라 switch case 문을 실행합니다. 일치하는 case가 없는 경우, 애플리케이션은 utm_source의 값으로 brandName() 함수를 호출합니다.\n\n![이미지](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_3.png)\n\n그림 4에서 brandName 함수는 매개변수 값에 따라 .js-brandname-container 클래스를 가진 요소를 숨기거나 .js-brandname 클래스를 가진 요소의 inner HTML을 설정하는 방식으로 설계되었습니다. brandName 값이 false로 설정되면 지정된 요소를 숨기고, 그렇지 않으면 요소의 inner HTML을 제공된 brandName 값으로 설정합니다.\n\n그림 3에서 이미 알 수 있듯이, 우리는 URL 매개변수 utm_source를 통해 함수brandName(utm_source)에 전달되는 매개변수 값을 제어할 수 있으므로 이제 HTML 태그를 삽입하고 임의의 JavaScript 코드를 실행할 수 있습니다.\n\n프론트 엔드 개발자입니다. 위의 텍스트를 친절한 어조로 한국어로 번역해 주세요.\n\n아카마이 방화벽이 구출 작업을 수행했습니다. 이제 (WAF)가 잠재적으로 존재할지라도 XSS 공격을 실행하기 위해 성공적으로 우회했습니다. 다음 payload를 자유롭게 사용하세요.\n\nhttps://your-server/x.js를 자신의 서버로 바꿔주세요. 자바스크립트 파일을 업로드한 서버에 대체하세요. 해당 파일은 payload를 실행할 것입니다.\n\n\"Click Me\" 버튼을 클릭하면 됩니다.\n\n![DOM-based XSS Attack](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_6.png)\n\n읽어 주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png"},"coverImage":"/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기","description":"","date":"2024-05-12 23:23","slug":"2024-05-12-MockingDatainreactjsorjavascript","content":"\n\n- React.js나 JavaScript에서 모킹 데이터는 개발이나 테스트 중에 API나 백엔드 서비스로부터의 응답을 시뮬레이션하기 위해 가짜 데이터를 생성하는 것을 의미합니다.\n- 이를 통해 백엔드에 독립적으로 프론트 엔드 애플리케이션을 개발하고 테스트할 수 있습니다. 서버가 실제로 반환한 데이터와 상관없이 UI 컴포넌트가 예상대로 작동하는지 확인할 수 있습니다.\n\n다음은 React.js나 JavaScript에서 모킹 데이터를 하는 일반적인 방법 몇 가지입니다:\n\n- 하드코딩된 데이터: 코드 내에서 모의 데이터를 직접 정의합니다. 작은 데이터 세트나 정적 콘텐츠의 경우 특히 간단한 방법입니다.\n\n```js\nconst mockData = [\n  { id: 1, name: 'John Doe', age: 30 },\n  { id: 2, name: 'Jane Smith', age: 25 },\n  // 기타 모킹 데이터...\n];\n```\n\n\n\n2. JSON 파일: 모의 데이터를 JSON 파일에 저장하고 필요할 때 코드로 가져옵니다. 이렇게 하면 모의 데이터를 코드베이스와 별도로 구성하고 관리할 수 있습니다.\n\n```js\n// mockData.json\n[\n  { \"id\": 1, \"name\": \"John Doe\", \"age\": 30 },\n  { \"id\": 2, \"name\": \"Jane Smith\", \"age\": 25 }\n  // 더 많은 모의 데이터...\n]\n```\n\n- `./mockData.json`에서 mockData를 가져옵니다;\n\n모의 라이브러리: faker.js 또는 mockjs와 같이 데이터를 모의하는 데 특별히 설계된 라이브러리를 사용하십시오. 이러한 라이브러리는 미리 정의된 스키마나 템플릿에 따라 랜덤하거나 현실적으로 보이는 모의 데이터를 생성합니다.\n\n\n\n```js\n// Using faker.js\nimport faker from 'faker';\n\nconst mockData = Array.from({ length: 10 }, () => ({\n  id: faker.datatype.uuid(),\n  name: faker.name.findName(),\n  age: faker.datatype.number({ min: 18, max: 100 })\n}));\n```\n\n4. API 모킹: 만일 당신의 애플리케이션이 API와 통신한다면, axios-mock-adapter나 msw (Mock Service Worker)와 같은 도구를 사용하여 API 응답을 모킹할 수 있습니다. 이러한 도구들은 HTTP 요청을 가로채 미리 정의된 응답을 반환함으로써 다양한 시나리오와 예외 상황을 시뮬레이션할 수 있게 합니다.\n\n```js\nimport axios from 'axios';\nimport MockAdapter from 'axios-mock-adapter';\n\nconst mock = new MockAdapter(axios);\n\nmock.onGet('/users').reply(200, [\n  { id: 1, name: 'John Doe', age: 30 },\n  { id: 2, name: 'Jane Smith', age: 25 }\n  // 더 많은 모킹 데이터...\n]);\n```\n\n이것들은 React.js나 JavaScript에서 데이터를 모킹하는 방법의 일부 예시일 뿐입니다. 선택하는 접근 방식은 특정 사용 사례, 기호 및 애플리케이션의 복잡성에 따라 다릅니다. 데이터 모킹은 효과적인 개발과 테스트를 위해 필수적이며, 애플리케이션의 각 부분을 독립적으로 분리하고 유효성을 검사할 수 있도록 합니다.","ogImage":{"url":"/assets/img/2024-05-12-MockingDatainreactjsorjavascript_0.png"},"coverImage":"/assets/img/2024-05-12-MockingDatainreactjsorjavascript_0.png","tag":["Tech"],"readingTime":2},{"title":"단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포","description":"","date":"2024-05-12 23:21","slug":"2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker","content":"\n\n모노 레포는 여러 프로젝트를 보관하는 버전 관리 코드 저장소입니다. 이러한 프로젝트들은 서로 관련이 있을 수 있지만 종종 논리적으로 독립적이며 다른 팀에 의해 운영됩니다. 일부 회사는 모든 코드를 모든 사람 사이에서 공유되는 단일 저장소에 호스팅합니다. 모노 레포는 거대한 크기에 도달할 수 있습니다.\n\n저는 이러한 소프트웨어 개발 전략을 매우 매력적으로 생각했습니다. 팀 간의 장벽과 칸막이를 제거하여 함께 잘 작동하는 일련의 마이크로서비스를 설계하고 유지하는 것이 더 쉬워집니다.\n\n![이미지](/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png)\n\n시작하기 전에 여기서 다룰 내용에 대한 기본적인 이해를 갖겠습니다.\n\n\n\n- 표준 프로젝트에서는 프로젝트 전체에서 사용되는 외부 종속성에 의존합니다.\n- 이러한 종속성은 여러 프로젝트가 이를 필요로 할 경우 여러 복사본이 생길 수 있습니다.\n- 여러 패키지가 서로 보완하는 경우 추상화가 최선의 접근 방식이 아닐 수 있습니다.\n- 한 번에 여러 앱을 실행하는 것은 이해관계자들에게 보여주는 즐거움입니다.\n\n이 문서에서는 pnpm 워크스페이스, 프론트엔드에서 React, 백엔드에서 ExpressJS를 사용하여 풀 스택 애플리케이션을 구축할 것입니다:\n\n- pnpm 워크스페이스: 이 프로젝트를 주관하고 클라이언트와 서버에서 필요한 일반적인 도구를 공유합니다.\n- 클라이언트: React 애플리케이션을 실행하는 모든 프론트엔드 코드를 포함합니다.\n- 서버: API 엔드포인트를 노출하는 ExpressJS 서버가 있습니다.\n\n전제 조건:\n\n\n\n- NodeJS: Node.js 설치 방법\n- pnpm: pnpm 설치 방법\n\n## pnpm 워크스페이스\n\n- 루트 폴더에 pnpm 워크스페이스 생성하기\n\n```js\npnpm init\n```\n\n\n\n- 패키지라는 폴더를 만드세요. 여기에는 클라이언트와 서버가 들어갈 거에요.\n\n```js\nmkdir packages\n```\n\n- pnpm-workspace.yaml 파일을 생성하세요. 이를 통해 pnpm이 제 패키지 폴더를 확인할 수 있어요.\n\n```js\ntouch pnpm-workspace.yaml\n```\n\n\n\n- 우리는 pnpm에게 내 패키지가 직장의 일부임을 알려줄 거에요.\n\n```js\n//pnpm-workspace.yaml\npackages:\n  - 'packages/*'\n```\n\n- 루트 디렉토리에 docker-compose.yml 파일을 만들어주세요. 나중에 이에 대해 이야기할 거에요\n\n```js\ntouch docker-compose.yml\n```\n\n\n\n## 클라이언트\n\n- 우리는 Vite를 사용하여 리액트 프로젝트를 설정할 것입니다. 프로젝트 이름은 client로 지정하세요. 이 이름은 pnpm이 이 패키지를 감지하는 방법이기 때문에 중요합니다.\n\n```js\n pnpm create vite\n```\n\n- 클라이언트를 위한 모든 종속성을 설치합니다. pnpm이 루트에 node_modules 폴더를 가지고 있다는 것에 주목하세요. 멋지죠!\n\n\n\n```js\ncd client\npnpm install\npnpm run dev\n```\n\n- 클라이언트용 도커 파일\n\n```js\ntouch Dockerfile\n```\n\n## 서버\n\n\n\n\n- 여기에 익스프레스 애플리케이션을 설정할 거에요. 그를 위해 패키지 폴더로 이동하여 서버 폴더를 만들어야 해요.\n\n```js\nmkdir server\ncd server\n```\n\n- 서버 폴더 안에 새로운 npm 패키지를 생성할 거에요.\n\n```js\nnpm init\n```\n\n\n\n- 그리고 Express 프레임워크를 설치하세요.\n\n```js\nnpm install express\n```\n\n- 서버용 도커 파일도 만들어주세요.\n\n```js\ntouch Dockerfile\n```\n\n\n\n- 멋져요, 우리 절반 이상을 이미 지났어요! 그리고 이미 풀 스택 앱을 만들었다니 축하해요(조금 더 연결이 필요하지만, 클라이언트에서 서버로) :)\n\n연결이 얼마나 잘 되었는지 확인해봐요!\n\n## 서버 + 클라이언트\n\n- 서버에 index.js 파일을 만들어, 잘 진행 중이라고 말하고 http://localhost:3000에서 제공할 목록이 있어요\n\n\n\n```js\ntouch index.js\n```\n\n```js\n// server/index.js\nconst express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.get(\"/\", (req, res) => {\n  res.json([\n    { name: \"John\", age: 25 },\n    { name: \"Jane\", age: 30 },\n    { name: \"Bob\", age: 35 },\n  ]);\n});\n\napp.listen(PORT, () => {\n  console.log(`I am doing great and serving at ${PORT}`);\n});\n```\n\n- 패키지.json에서 서버를 시작하는 스크립트를 추가하세요.\n\n```js\n\"scripts\": {\n    \"dev\": \"node index.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n},\n```\n\n\n\n- 그리고 물론 실행해 주세요\n\n```js\npnpm run dev\n```\n\n- 이제 클라이언트에서 이 목록을 받습니다. Vite는 이를 사용하여 프론트엔드에서 http://localhost:3000을 자체 URL처럼 사용할 수 있습니다. 귀찮은 CORS 오류도 없어요 :) 이 코드를 vite.config.ts에 추가해 보세요.\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) => path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n\n\n- vite.config.ts 파일에서는 특별한 것이 없어요. localhost와 네트워크의 8080 포트에서 프론트엔드 코드를 실행합니다. 그리고 백엔드 API인 http://localhost:3000을 /api를 호출하여 프록시합니다.\n- 이제 App.ts 파일에서는 /api를 호출하여 http://localhost:3000에서 데이터를 가져옵니다.\n\n```js\nimport { useEffect, useState } from \"react\";\n\nimport \"./App.css\";\n\nfunction App() {\n  const [data, setData] = useState<any>(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      const response = await fetch(\"/api\");\n      const data = await response.json();\n      console.log(data);\n      setData(data);\n    };\n    fetchData();\n  }, []);\n\n  return <>{data && <pre>{JSON.stringify(data, null, 2)}</pre>}</>;\n}\n\nexport default App;\n```\n\n- 목록을 보려면 프론트앱을 시작해주세요.\n\n```js\npnpm run dev\n```\n\n\n\n이제 이 앱은 풀 스택 앱입니다! 그러나 pnpm에서 개발 경험을 향상시키고 이전에 만들었던 Docker 파일을 사용해 봅시다.\n\n개선 사항\n\n- 이제 백엔드와 프론트엔드를 별도로 시작해야 하므로, 워크스페이스 루트에 이를 추가하여 단일 명령으로 실행할 수 있게 합시다. package.json에 다음을 추가하여 pnpm run app을 통해 모두 시작할 수 있도록 하겠습니다!\n\n```js\n\"scripts\": {\n    \"client\": \"pnpm --filter \\\"client\\\" run dev\",\n    \"server\": \"pnpm --filter \\\"server\\\" run dev\",\n    \"app\": \"pnpm run client & pnpm run server\"\n},\n```\n\n\n\n- 클라이언트용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/client\n\n# 클라이언트 package.json 복사\nCOPY package.json .\n\n# 의존성 설치 \nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 8080\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n- 서버용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/server\n\n# 서버 package.json 복사\nCOPY package.json .\n\n# 의존성 설치\nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 3000\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n\n\n- 도커 컴포즈 파일로 이동하기 전에, 클라이언트 폴더의 vite.config.ts 파일에서 약간의 조정을 해보겠어요. 이 조정 내용은 이미지를 만들 때 'server_c'라는 이름의 서버 컨테이너를 사용하므로 기본적으로 로컬호스트가 아닌 http://server_c:3000을 타겟하도록 프론트엔드에 알려주는 것이에요.\n\n```js\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target:\n          process.env.NODE_ENV === \"docker\"\n            ? \"http://server_c:3000\"\n            : \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) => path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n- 루트 디렉토리에 위치한 도커 컴포즈 파일을 사용하여 두 이미지를 만들어봅시다. vite.config.ts 파일에서 제공하는 NODE_ENV=docker 환경을 주의해주세요.\n\n```yaml\nservices:\n  client:\n    build: ./packages/client\n    container_name: client_c\n    ports:\n      - \"8080:8080\"\n    environment:\n      - NODE_ENV=docker\n\n  server:\n    build: ./packages/server\n    container_name: server_c\n    ports:\n      - \"3000:3000\"\n```\n\n\n\n여기서 재밌는 마크다운 표 형식을 사용한 코드가 있어요. 도커 이미지를 빌드하고 도커 환경에서 앱을 시작하려면 docker-compose 파일을 실행해보세요!\n\n```js\ndocker-compose up\n```\n\n더 많은 코드들은 여기에서 확인할 수 있어요. 계속 배우고 있어요.\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 글을 추천하고 작가를 팔로우해 주시는 것을 고려해주세요! 👏\n- 우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠와 싸우는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png"},"coverImage":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png","tag":["Tech"],"readingTime":7},{"title":"마무리는 제대로 했나요 컴포넌트 라이프사이클에서 오류가 발생하지 않게 하는 비동기 작업","description":"","date":"2024-05-12 23:20","slug":"2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle","content":"\n\nReact의 useEffect 훅은 함수 컴포넌트에서 부작용을 관리하는 강력한 도구입니다. 하지만 적절한 처리 없이 사용하면 코드베이스의 최악의 악몽이 될 수 있습니다. 오늘은 제가 즐겨 사용하는 API 중 하나인 TheCatAPI를 사용하여, useEffect에서 비동기 작업을 정리하는 방법에 초점을 맞추어 React 컴포넌트를 가능한 깨끗하고 효율적으로 유지하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png)\n\n## useEffect에서 정리 작업이 중요한 이유\n\nReact 컴포넌트는 마운트되고 업데이트되며 마침내 언마운트됩니다. useEffect 훅을 사용하면 이러한 단계를 우회하여 코드를 실행할 수 있습니다. DOM을 조작하거나 서비스에 구독하거나 타이머를 설정하거나 데이터를 가져오는 등의 작업을 수행할 수 있습니다. 그러나 중요한 건 이러한 작업을 설정하는 것뿐 아니라 그것들을 언제, 어떻게 해제해야 하는지를 알고 있는 것입니다.\n\n\n\n적절한 정리가 없으면 애플리케이션이 더는 필요하지 않은 효과를 계속 실행하거나, 더 나쁜 경우에는 DOM에서 사라진 구성 요소를 참조할 수 있습니다. 이러한 문제는 성능 문제, 메모리 누수 및 디버깅하기 어려운 오류로 이어질 수 있습니다.\n\n# 먼저, 고양이 사진을 가져와 봅시다\n\n아마도 많은 분들이 이 고양이 서비스 API를 이미 알고 있을 겁니다. 이 글에서는 이미지 엔드포인트만 사용할 것입니다. 만약 이 API에 대해 더 알고 싶다면, 이 링크를 확인해보세요:\n\n프로그램이 초기 페이지 로드 시 10개의 고양이 사진을 표시하도록 해 봅시다.\n\n\n\n```js\nimport { useState, useEffect } from \"react\";\n\nfunction App() {\n  const [catImageUrl, setCatImageUrl] = useState([]);\n\n  useEffect(() => {\n    const fetchCatImage = async () => {\n      try {\n        const response = await fetch(\n          `https://api.thecatapi.com/v1/images/search?limit=10&api_key=${APIKEY}`\n        );\n        const data = await response.json();\n        if (data.length > 0) {\n          const imageURLS = data.map((obj) => obj.url);\n          setCatImageUrl(imageURLS); // 첫 번째 이미지 URL을 설정하려 가정합니다\n        }\n      } catch (error) {\n        console.error(\"데이터를 가져오는 중 오류 발생:\", error);\n      }\n    };\n\n    fetchCatImage();\n  }, []); // 의존성 배열이 비어 있어서 효과가 한 번만 실행됩니다\n\n  return (\n    <>\n      <h1>당신의 하루 고양이 사진</h1>\n      <div\n        style={{\n          display: \"flex\",\n          flexWrap: \"wrap\",\n          gap: \"10px\",\n        }}\n      >\n        {catImageUrl.map((url, index) => (\n          <img\n            key={index}\n            src={url}\n            alt=\"랜덤한 고양이\"\n            style={{ flex: \"0 0 200px\", height: \"200px\" }}\n          />\n        ))}\n      </div>\n    </>\n  );\n}\n```\n\n<img src=\"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_1.png\" />\n\n아주 좋아요, 의도한 대로 10개의 고양이 사진을 요청했지만 잠재적인 문제가 있습니다: 데이터 가져오기가 비동기적인 것으로 인해 작업이 완료되기 전에 컴포넌트가 언마운트될 수 있습니다 (예: 경로 변경 또는 DOM에서 컴포넌트가 제거되는 경우). 그런 경우에 컴포넌트가 언마운트된 상태에서 상태를 업데이트하려고 하면 \"Can’t perform a React state update on an unmounted component\"와 같은 오류가 발생할 수 있습니다.\n\nuseEffect 내에서 데이터를 가져올 때 주요 도전 과제는 컴포넌트의 라이프사이클을 처리하는 것입니다.\n\n\n\n\n그러니까, 코드에 버그가 없도록 정리를 해봅시다!\n\n# 효과에서 직접 함수를 반환하기\n\nReact의 useEffect 훅을 사용할 때, 정리를 처리하는 일반적이고 권장되는 방법은 효과에서 직접 함수를 반환하는 것입니다.\n\n```js\nuseEffect(() => {\n  // 코드 로직\n\n  return () => {\n    // 정리 작업 \n  };\n}, []); //효과가 한 번만 발생해야 하는 경우, 의존성을 비워둡니다\n```\n\n\n\n# 효율적인 데이터 가져오기 정리를 위해 AbortController 사용\n\nAbortController는 현대 브라우저와 node-fetch를 사용하는 Node.js 환경에서 널리 지원되지만, 모든 환경에서 지원되지 않을 수 있다는 점을 고려하는 것이 중요합니다 (예: IE의 모든 버전이나 일부 오래된 브라우저).\n\nAbortController를 사용하면 fetch가 시작된 시점에 컨트롤러 신호를 추가하여 fetch 요청을 취소할 수 있습니다. isMounted 플래그를 사용하는 것과 비교해 (곧 다룰 예정), fetch 요청과 같은 비동기 작업을 취소하는 표준화된 방법을 제공합니다.\n\n먼저, 새 AbortController를 만들어야 합니다:\n\n\n\n```js\nconst controller = new AbortController();\nconst { signal } = controller;\n```\n\nAbortController 인스턴스를 생성하면 signal 속성을 포함한 객체가 반환됩니다. 이 signal은 fetch 요청이 중단되어야 함을 신호하는데 사용되는 AbortSignal의 인스턴스입니다.\n\n그런 다음 signal을 옵션 객체로 fetch 요청에 전달할 수 있습니다. 이를 통해 컨트롤러의 signal을 fetch 요청과 연결할 수 있습니다.\n\n```js\nconst fetchCatImage = async () => {\n      try {\n        const response = await fetch(\n          `https://api.thecatapi.com/v1/images/search?limit=10&api_key=${APIKEY}`, { signal } // 이곳에 signal 전달\n      );\n        const data = await response.json();\n        if (data.length > 0) {\n          const imageURLS = data.map((obj) => obj.url);\n          setCatImageUrl(imageURLS);\n        }\n      } catch (error) {\n        if (error.name === \"AbortError\") {\n          console.log(\"Fetch aborted\"); // fetch가 중단된 경우 처리\n        } else {\n          console.error(\"데이터를 불러오는 중 오류 발생:\", error); // 다른 오류 처리\n        }\n      }\n    };\n    \n    fetchCatImage();\n\n    return () => {\n      controller.abort(); // 컴포넌트가 언마운트 될 때 fetch 요청 중단\n    };\n  }, []);\n```\n\n\n\n\"AbortError\"은 AbortController에서 abort() 함수가 호출될 때 발생하는 고유한 오류 객체입니다. catch 블록에서 AbortError에 대한 특정 메시지를 추가할 수 있습니다.\n\n이제 각 새로운 효과가 발생하기 전이나 컴포넌트가 마운트 해제되기 바로 전에 fetch 요청이 즉시 취소됩니다.\n\nAbortController를 useEffect 정리 함수와 함께 사용하면 React에서 비동기 작업을 처리하는 견고한 해결책을 제공할 수 있습니다. 이 패턴을 사용하면 컴포넌트가 마운트 해제된 후에 상태를 업데이트하려고 시도하지 않도록 보장할 수 있습니다.\n\n# IsMounted 플래그 설정:\n\n\n\n오래된 브라우저나 제한된 JavaScript 환경에서 개발 중이라면 IsMounted 플래그를 사용하면 간단한 대안이 될 수 있습니다.\n\n컴포넌트가 초기에 마운트될 때 isMounted를 true로 설정합니다. 컴포넌트가 여전히 마운트된 상태인 경우에만 상태를 업데이트합니다. 마지막으로 useEffect에서 반환된 정리 함수에서 컴포넌트가 마운트 해제되면 isMounted를 false로 설정하여 컴포넌트가 마운트 해제된 후 데이터 가져오기가 완료된 경우 상태 업데이트를 방지합니다.\n\n```js\n  useEffect(() => {\n    let isMounted = true; // 컴포넌트가 마운트된 상태를 추적하는 플래그\n\n    const fetchCatImage = async () => {\n      try {\n        const response = await fetch(\n          `https://api.thecatapi.com/v1/images/search?limit=10&api_key=${APIKEY}`\n        );\n        const data = await response.json();\n        if (isMounted && data.length > 0) {\n          const imageURLS = data.map((obj) => obj.url);\n          setCatImageUrl(imageURLS);\n        }\n      } catch (error) {\n        console.error(\"데이터를 불러오는 중 오류 발생:\", error);\n      }\n    };\n\n    fetchCatImage();\n\n    return () => {\n      isMounted = false; // 컴포넌트가 언마운트될 때 isMounted를 false로 설정하여 정리\n    };\n  }, []);\n```\n\n그러니, 간략히 정리하면:\n\n\n\n- useEffect 정리: 권장하는 방법은 정리를 수행하는 함수를 직접 반환하는 것입니다.\n- AbortController 사용: 대부분의 경우에 해당합니다. 주요 비동기 작업(예: 데이터 가져오기)에 신호를 첨부하고 정리 함수에서 컨트롤러를 중지합니다.\n- isMounted 플래그 사용: 일부 오래된 환경이나 제한적인 환경에서 AbortController을 지원하지 않을 때\n\n여기까지 하면 useEffect가 스스로 정리할 수 있어요! 고양이 사진을 즐기세요!\n\n이 게시물을 읽어주셔서 감사합니다!! 💜\n\n게시물이 마음에 들었다면 👏 또는 댓글을 남겨주세요.\n\n\n\n질문이나 제안이 있으시거나 저와 함께 일하고 싶으시다면 언제든지 연락해 주세요:\n\n- 이메일: renashen314@gmail.com\n- LinkedIn","ogImage":{"url":"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png"},"coverImage":"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png","tag":["Tech"],"readingTime":6},{"title":"Nodejs가 더욱 쉬워졌어요 env 파일에 대한 네이티브 지원","description":"","date":"2024-05-12 23:19","slug":"2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles","content":"\n\n\n![Node.js Gets Even Easier Native Support for env Files](/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png)\n\nNode.js 작업을 한다면 환경 변수 사용법에 익숙할 것입니다. 다양한 환경(개발, 테스트, 프로덕션)에서 설정을 관리하거나 민감한 데이터를 저장하는 데 사용되는 것으로 추측됩니다.\n일반적으로.env 파일에서 이러한 변수를 로드하는 전통적인 방법은 이전에 \"dotenv\"와 같은 패키지를 설치해야 했습니다.\n\n하지만 Node.js v20.6.0부터 상황이 바뀌었습니다! 지금은.env 파일이 네이티브로 지원됩니다.\n\n왜 중요한 이유인가요\n\n\n\n- 더 간단한 설정: 더 적은 외부 종속성을 갖는 경량 구조의 프로젝트입니다.\n- 표준화: .env 파일을 사용하는 것이 일반적이며, 네이티브 지원이 있어서 Node.js 코드를 다양한 백그라운드를 갖는 개발자가 이해하기 쉬워집니다.\n- 다양한 구성: 다른 환경 간에 쉽게 전환하기 위해 다른 .env 파일을 활용합니다.\n\n사용 방법\n\n- .env 파일 생성: 프로젝트의 루트 디렉토리에 .env이라는 일반 텍스트 파일을 추가합니다.\n- 변수 설정: KEY=VALUE와 같은 형식으로 변수를 정의합니다. 예를 들어:\nPORT=3000\n- 변수 접근: Node.js 코드에서 이들에 접근하기 위해 process.env를 사용합니다.\n- 기본 위치: Node.js는 프로젝트의 루트에서 .env 파일을 자동으로 찾습니다. 사용자 정의 위치가 필요하다면 앱을 실행할 때 --env-file 플래그를 사용하세요 (예: node app.js --env-file=./config/.env).\n\n단순함을 환영합니다.\n\n\n\n이 작은 변경은 다른 프레임워크에서의 표준 절차와 일치하게 만들어 Node.js 개발 프로세스를 약간 더 쉽게 만들어줍니다. 한 번 시도해 보세요!\n\nNode.js 프로젝트에서 환경 변수의 특정 응용 프로그램에 대해 논의하거나 문의 사항이 있으시면 언제든지 연락해 주세요!\n\n읽어주셔서 감사합니다 😊","ogImage":{"url":"/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png"},"coverImage":"/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png","tag":["Tech"],"readingTime":2},{"title":"DraftJS를 사용한 풍부한 텍스트 편집기","description":"","date":"2024-05-12 23:18","slug":"2024-05-12-RichTextEditorusingDraftJS","content":"\n\n그래도 봐, 요즘에는 보통의 텍스트 영역으로는 충분하지 않아. 요즘에는 가능한 모든 서식을 필요로 해서 고객들이 데이터를 인상적인 형식으로 제시할 수 있게 해야 해.\n\n그런 상황에서 draft.js가 등장해. React 앱용 멋진 텍스트 편집기야. 우리가 어떻게 고객을 위해 텍스트 영역을 흥미롭게 만들었는지 여기에 나와 있어.\n\n```js\nimport { EditorState, ContentState, convertFromHTML } from 'draft-js';\nimport { stateToHTML } from 'draft-js-export-html';\nimport React, { useEffect, useState } from 'react';\nimport { Editor } from 'react-draft-wysiwyg';\nimport 'react-draft-wysiwyg/dist/react-draft-wysiwyg.css';\n\ntype RichTextAreaProps = {\n  name: string;\n  onChange: (value: any) => void;\n  onReset?: () => void;\n  placeholder?: string;\n  reset?: boolean;\n  value: string;\n};\n\nconst RichTextArea: React.FC<RichTextAreaProps> = ({\n  name,\n  onChange,\n  value,\n  placeholder = 'Enter Details',\n  reset,\n  onReset,\n}) => {\n  const [editorState, setEditorState] = useState(EditorState.createEmpty());\n\n  const handleEditorChange = (newEditorState) => {\n    setEditorState(newEditorState);\n\n    const rawContentState = editorState.getCurrentContent();\n    const html = stateToHTML(rawContentState);\n\n    onChange({\n      target: {\n        name,\n        value: html,\n      },\n    });\n  };\n\n  useEffect(() => {\n    const blocksFromHTML = convertFromHTML(value);\n    const contentState = ContentState.createFromBlockArray(blocksFromHTML);\n    setEditorState(EditorState.createWithContent(contentState));\n  }, []);\n\n  useEffect(() => {\n    if (reset) {\n      setEditorState(EditorState.createEmpty());\n\n      const blocksFromHTML = convertFromHTML(value);\n      const contentState = ContentState.createFromBlockArray(blocksFromHTML);\n\n      setEditorState(EditorState.createWithContent(contentState));\n      onReset();\n    }\n  }, [reset]);\n\n  return (\n    <div className=\"w-full bg-white p-2\">\n      <Editor\n        name={name}\n        placeholder={placeholder}\n        editorState={editorState}\n        onEditorStateChange={handleEditorChange}\n        toolbar={{\n          options: ['inline', 'fontSize', 'list', 'textAlign', 'link', 'image'],\n          inline: {\n            options: ['bold', 'italic', 'underline'],\n          },\n          list: {\n            options: ['unordered', 'ordered'],\n          },\n          textAlign: {\n            options: ['left', 'center', 'right'],\n          },\n          link: {\n            defaultTargetOption: '_blank',\n          },\n          image: {\n            defaultSize: {\n              height: 'auto',\n              width: '100%',\n            },\n          },\n        }}\n      />\n    </div>\n  );\n};\n\nexport default RichTextArea;\n```\n\n- Editor는 draft.js에서 제공하는 구성요소야. 그냥 그것을 추가함으로써 기본 툴바가 있는 리치 텍스트 편집기를 얻을 수 있어.\n- 툴바 prop을 사용하면 툴바에 표시하고 싶은 모든 형식을 사용자 정의할 수 있어.\n- editorState는 사용자가 편집기에 입력하는 상태나 내용을 제어하는 것이야.\n- Editor는 사실 formik과 연결돼 있어서 이름과 onChange 호출을 처리해.\n- 기본적으로 편집기는 EditorState 객체를 반환하는데, 이를 의미 있게 만들기 위해 stateToHTML(rawContentState) 호출을 통해 HTML로 변환해야 해.\n- 반대로 백엔드로 전송할 때 HTML로 변환되는 EditorState 객체에서 데이터를 로드할 때 ContentState.createFromBlockArray를 통해 이를 역으로 수행해야 해.\n\n\n\n```js\n<FormControl\n  label=\"피드백\"\n  error={formik.touched.response && formik.errors.response}\n>\n  <RichTextArea\n    name=\"피드백\"\n    value={formik.values.feedback}\n    onChange={formik.handleChange}\n  />\n</FormControl>\n```\n\n이렇게 `RichTextArea` 컴포넌트를 사용합니다. `FormControl`은 실제로 formik 프로바이더를 이 안에 감쌉니다.\n\n<img src=\"/assets/img/2024-05-12-RichTextEditorusingDraftJS_0.png\" />\n\n이렇게 보입니다.\n\n\n\n\n행복한 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-RichTextEditorusingDraftJS_0.png"},"coverImage":"/assets/img/2024-05-12-RichTextEditorusingDraftJS_0.png","tag":["Tech"],"readingTime":4},{"title":"Webpack 탐험","description":"","date":"2024-05-12 23:16","slug":"2024-05-12-ExploringWebpack","content":"\n\n프론트엔드 개발자들의 삶 속에는 번들러에서 뭔가를 편집해야 하는 시기가 올 때가 있죠. 다행히 아직은 그런 날이 오지 않았지만, 여유 시간이 좀 생겨 이 키워드들을 해결해 보기로 했어요: Webpack — Craco — Bundles — Chunks — Bundle Size — Code Splitting — Dynamic imports.\n\n이 포스트를 통해 웹팩의 기본적인 것을 알아보고, 왜 현대 웹 개발에 중요한지 이해하는 데 도움이 되도록 하겠습니다.\n\n그럼 첫 번째 질문은:\n\n## 웹팩이란 무엇인가요?\n\n\n\n웹팩은 모듈 번들러입니다. 프로젝트의 파일을 하나 이상의 파일(번들)로 번들링합니다. 그런 다음 일부 추가 정리 작업(ES6를 이전 JavaScript로 변환, 최소화/압축, 트리 쉐이킹, 코드 분할, 압축 및 자산 최적화, 그리고 추가 프로덕션 모드별 최적화)을 수행하여 코드를 제품용으로 준비합니다. 요약하면, 웹팩은 개발 코드와 제품 코드 사이의 중간 매개체라고 할 수 있습니다.\n\n![이미지1](/assets/img/2024-05-12-ExploringWebpack_0.png)\n\n웹팩이 하는 또 다른 중요한 작업은 종속성을 해결하고 최종 번들에 포함하는 것입니다. 프론트엔드 프레임워크가 나오기 전의 이야기를 하나 들려드릴게요.\n\n![이미지2](/assets/img/2024-05-12-ExploringWebpack_1.png)\n\n\n\n옛날에는 HTML, CSS, 그리고 자바스크립트만 사용했던 시절, 우리가 HTML 파일을 구조화했던 방법을 기억하나요?\n\n```js\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Document</title>\n    <link rel='stylesheet' href='style.css'>\n</head>\n<body>\n    \n    <script src='script.js'></script>\n</body>\n</html>\n```\n\n만약 프로젝트에 부트스트랩을 추가하고 싶다면 어떻게 할까요?\n\n```js\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Document</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH\" crossorigin=\"anonymous\">\n    <link rel='stylesheet' href='style.css'>\n</head>\n<body>\n    \n    <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz\" crossorigin=\"anonymous\"></script>\n    <script src='script.js'></script>\n</body>\n</html>\n```\n\n\n\n스타일시트와 스크립트가 부트스트랩의 스타일시트와 스크립트 뒤에 위치하는 것을 알아 보았나요? 왜 그렇게 한걸까요?\n\n우리는 스타일시트가 기본 부트스트랩 스타일을 덮어쓰도록 하고 싶었거나, 스크립트의 경우에는 사용자 정의 스크립트가 웹페이지에서 마지막으로 실행되어 이전 스크립트에 덮어쓰거나 사용될 수 있도록 하고, 페이지의 나머지가 완전히 렌더링되었는지 확인하려고 합니다. 그래서 다음과 같이 무언가를 할 때:\n\n```js\ndocument.querySelector('#firstName')\n```\n\n#firstName이 DOM에 존재해야합니다. 부트스트랩 스크립트도 마찬가지입니다. 그래서 스크립트가 페이지 맨 아래에 있고 맨 위에 있지 않은 이유입니다. HTML이 추가되기 전에 자바스크립트를 추가하기를 원합니다.\n\n\n\n여기서 일부 종속성이 발생하고 있어요. 순서가 중요하며 요소는 조작하기 전에 DOM에 존재해야 합니다.\n\n현대 웹 개발에서는 HTML이나 스크립트를 작성하지 않고, HTML 헤드에 Bootstrap 링크를 추가하지 않고, 패키지를 다운로드하고, react-bootstrap과 같은 라이브러리를 사용하여 구성 요소를 파일로 가져옵니다. 맞죠?\n\n여기서 Webpack 마법이 뒤에서 일어나는 첫 번째 신비한 모습을 볼 수 있어요. 다음 코드를 참고하세요:\n\n```js\nimport Container from 'react-bootstrap/Container';\nimport Row from 'react-bootstrap/Row';\nimport Col from 'react-bootstrap/Col';\n\nfunction AutoLayoutExample() {\n  return (\n    <Container>\n      <Row>\n        <Col>1 of 2</Col>\n        <Col>2 of 2</Col>\n      </Row>\n      <Row>\n        <Col>1 of 3</Col>\n        <Col>2 of 3</Col>\n        <Col>3 of 3</Col>\n      </Row>\n    </Container>\n  );\n}\n\nexport default AutoLayoutExample;\n```\n\n\n\n자동 레이아웃 예제 컴포넌트가 올바르게 렌더링되려면 이 파일에는 존재하지 않지만 자동 레이아웃 예제 컴포넌트를 올바르게 렌더링하려면 반드시 있어야 하는 3가지 다른 컴포넌트(Container, Row 및 Col)에 의존합니다. 웹팩은 교통 담당자입니다. 컴포넌트가 사용되기 전에 해당 컴포넌트에 종속된 코드가 존재하는지 확인하여 HTML을 스크립트보다 먼저 배치하는 것과 같은 역할을 합니다.\n\n웹팩은 또한 개발 서버를 실행함으로써 프로젝트 개발을 도와줍니다. 예전에는 코드 변경을 테스트하려면 변경된 파일을 저장하고 새로고침 버튼을 눌러야 했지만, 이제는 그렇지 않습니다. 더 이상 새로고침 버튼을 클릭할 필요가 없습니다. package.json에서 start 스크립트를 실행하면 start 스크립트에 나열된 스크립트가 실행되어 WebpackDevServer의 새 인스턴스가 생성되고 컴파일러와 구성이 전달됩니다. 인스턴스의 리스너 메소드가 호출되어 포트와 호스트 값을 전달합니다. 그런 다음 콘솔을 지우고 \"개발 서버 시작 중...\"이라고 읽습니다. 브라우저는 올바른 개발 URL로 열립니다. 마지막으로 프로세스가 종료될 때 두 개의 리스너가 추가됩니다. 이는 웹 서버를 종료하고 start.js 프로세스를 종료합니다.\n내부적으로 start 스크립트는 다음과 같이 작동합니다:\n\n\n\"start\": \"webpack-dev-server --mode development --open\"\n\n\n이는 Webpack에 개발 서버를 시작하고 파일을 실시간으로 제공하고 브라우저를 webpack.config 파일에서 지정한 포트로 엽니다(또는 기본값 8080을 사용합니다). 프로젝트를 최종 배포용으로 빌드하려면 아래와 같이 보일 수 있는 빌드 스크립트를 실행할 것입니다:\n\n\n\n```js\n\"build\": \"webpack --mode production\"\n```\n\n이 스크립트는 기본 Webpack 구성을 사용합니다. 이 구성은 프로젝트 루트에서 src 디렉토리를 찾고 index.js를 엔트리 포인트로 찾습니다. index.js에서 Webpack은 종속성 그래프를 빌드하기 시작합니다. 이전 예제와 유사하게 Container, Row 및 Col이 필요했던 것과 같이 AutoLayoutExample을 올바르게 렌더링하려면 Bootstrap이 AutoLayoutExample을 렌더링하기 전에 있는지 확인해야 합니다.\n\n전형적인 React 앱에는 package.json이나 프로젝트 트리에 webpack.config.js 파일이 없는 것을 알아채셨나요?\n\n이것은 React 팀이 이미 create-react-app을 사용할 때 모든 Webpack 구성을 내부에서 처리하고 있기 때문입니다. 그들은 무작위로 Webpack 구성을 변경하는 개발자들이 전반적인 경험을 저하시킬 수 있는 예상치 못한 동작을 도입할 위험 때문에 Webpack 구성을 무작위로 조정하길 원하지 않습니다.\n\n\n\n하지만 자신이 무엇을 하고 있는지 알고 있다면 어떻게 해야 할까요? React의 웹팩 config를 재정의하는 데 도움이 되는 도구인 CRACO(Create React App Configuration Override)가 있습니다.\n\n다음은 Craco가 공식 문서에서 자신을 어떻게 정의하는지에 대한 내용입니다:\n\n이 정의 아래에 큰 경고도 있습니다:\n\n따라서 CRACO를 사용하는 것은 React에게 \"나는 안다, 내가 뭘 하고 있는지 안다\"고 말하는 것과 동등합니다.\n\n\n\n제 경우에는 CRACO를 사용하여 빌드를 분석할 계획입니다. 기본 빌드 스크립트를 수정하지 않을 것이고, 학습 목적으로 새로운 스크립트를 추가하여 번들을 조사하는 것을 목표로 할 것입니다. \n\n이제부터 회사에서 사용하는 볼륨이 큰 비공개 레포지토리를 분석할 것입니다. 그 레포지토리는 매우 크기 때문에 번들과 청크에 대해 배우기에 완벽한 대상이라고 생각합니다.\n\n그러나 어떤 도구를 설치하기 전에, 손에 있는 것을 활용해보는 것은 어떨까요? 브라우저를 사용하면 번들을 분석하는 방법을 배우는 데 좋은 시작점이 될 수 있습니다. 그렇다면 번들은 무엇일까요? 청크는 무엇일까요?\n\n## 번들(Bundle):\n\n\n\n## 청크:\n\n애플리케이션이 상당히 큰 경우 큰 번들을 청크로 나누어 게으르게 로드하는 것은 의미가 있습니다. 일반적으로 시간을 크게 단축할 수 있습니다.\n\n번들을 분석하는 것은 브라우저로 제공되는 JavaScript 양을 최적화하는 좋은 첫 번째 단계이며, 이를 통해 페이지 로딩 시간을 향상시키고 직접적으로 더 나은 대규모 내용 그리기 속도(LCP)와 첫 입력 지연(FID)을 얻을 수 있습니다.\n브라우저가 코드를 구문 분석, 분석 및 컴파일하는 데 필요한 시간을 단축함으로써.\n\n다음 예제를 고려해보세요. 앱에서 사용자 페이지로 이동한 경우:\n\n\n\n![Webpack](/assets/img/2024-05-12-ExploringWebpack_2.png)\n\n위의 스크린샷에서는 네트워크 탭에서 이 페이지를로드하기 위해 서버에서 보낸 청크를 볼 수 있습니다. 또한 청크의 크기와 서버에서 브라우저로 이 청크를 보내는 데 필요한 시간도 볼 수 있습니다. 커버리지 탭에는 사용되지 않는 바이트의 크기를 볼 수 있습니다. 또한 개발 모드에서만, 청크 내의 실제 파일을 가리키는 소스 맵을 볼 수 있습니다. 청크 옆의 드롭다운 지시기를 클릭하여 찾을 수 있습니다.\n\n14.chunk.js에는 97.7%의 사용되지 않은 바이트를 가진 useLocalStorage 커스텀 훅이 있는 한 개의 파일이 있습니다. 이는 useLocalStorage의 사용을 다시 확인해야 할 지표일 수 있습니다. 아마도 이 페이지에서는 그것이 필요하지 않을 수도 있습니다.\n\n네트워크 및 커버리지 탭을 사용하면 이미 작은 범위에 대한 분석을 수행할 준비가 되어 있다면 좋은 시작이 될 수 있습니다. 그러나 프로젝트의 전반적인 분석을 원하는 경우, 일부 3rd 파티 도구의 도움이 필요할 수 있습니다.\n\n\n\n우리가 먼저 할 일은 \"craco\"와 \"webpack-bundle-analyzer\"라는 웹팩 프러그인을 설치하는 것입니다. 이러한 패키지들은 새로운 스크립트를 실행할 때 웹팩이 출력하는 번들된 코드를 확인하는 데 도움이 됩니다:\n\n```js\nyarn add @craco/craco webpack-bundle-analyzer progress-bar-webpack-plugin chalk --dev\n```\n\n그런 다음 package.json 파일 아래에 \"analysis\"라는 스크립트를 추가할 수 있습니다.\n\n```js\n \"scripts\": {\n        \"analysis\": \"craco build\",\n        // 다른 스크립트들\n \n}\n```\n\n\n\n우리는 craco.config.js 파일을 만들고 다음 코드를 추가합니다.\n\n```js\nconst chalk = require('chalk');\nconst ProgressBarPlugin = require('progress-bar-webpack-plugin');\nconst BundleAnalyzerPlugin =\n    require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\n\nmodule.exports = {\n    webpack: {\n        plugins: [\n            new BundleAnalyzerPlugin({\n                analyzerMode: 'server',\n            }),\n            new ProgressBarPlugin({\n                format: `${chalk.green('분석 중...')} ${chalk.green(\n                    '[:bar]'\n                )}${chalk.green('[:percent]')}${chalk.green(\n                    '[:elapsed seconds]'\n                )} - :msg`,\n            }),\n        ],\n    },\n};\n```\n\n참고: CommonJS 구문을 사용하였습니다. 왜냐하면 webpack 구성 파일은 Node.js 환경에서 실행되기 때문입니다.\n\n이 파일에서는 BundleAnalyzerPlugin을 사용하여 빌드 후 서버를 열어 Webpack 출력 파일의 크기와 내용을 시각적으로 표시하고, ProgressBarPlugin을 사용하여 빌드 중에 터미널에 진행률 표시줄을 표시하여 빌드가 얼마나 완료되었는지와 실행 시간이 얼마나 되었는지 나타냅니다. 마지막으로 터미널에 색을 추가하기 위해 chalk를 사용하고 있습니다.\n\n\n\n우리의 분석 스크립트를 실행한 결과입니다:\n\n- [ExploringWebpack_3](/assets/img/2024-05-12-ExploringWebpack_3.png)\n- [ExploringWebpack_4](/assets/img/2024-05-12-ExploringWebpack_4.png)\n- [ExploringWebpack_5](/assets/img/2024-05-12-ExploringWebpack_5.png)\n\n\n\n이 것은 무엇인가요?\n\n저희의 최종 번들입니다. 응용 프로그램 코드와 그에 의존하는 어떤 모듈도 모두 포함되어 있습니다. 코드 스플리팅 및 다양한 웹팩 최적화 후 node_modules에서 발생하는 종속성도 포함되어 있습니다. BundleAnalyzerPlugin을 통해 3가지 화면을 제공합니다:\n\n- Stat: 이 화면에서는 최적화가 적용되기 전 번들 내 각 모듈의 원시 크기를 보여줍니다. 프로젝트 내 각 파일/모듈의 크기에 대한 아이디어를 제공합니다.\n- Parsed: 이 화면에서는 웹팩이 해석하고 처리한 후 각 모듈의 크기를 볼 수 있습니다. 일반적으로 트리 쉐이킹, 코드 스플리팅 및 기타 최적화 작업이 포함됩니다. 따라서 이 화면에서 보이는 숫자는 웹팩이 다양한 최적화를 적용한 후의 모듈 크기를 반영합니다.\n- Gzipped: 이 화면에서는 gzip 압축이 적용된 후 각 모듈의 크기를 보여줍니다. Gzip 압축은 네트워크를 통해 전송되는 파일의 크기를 줄이는 데 사용되는 표준 기술입니다. 이 화면의 숫자는 압축 후 각 모듈의 예상 크기를 나타냅니다.\n\n일반적으로 번들 크기에 대해 이야기할 때는 Gzipped 크기를 의미합니다. 그러나 Parsed와 Gzipped 둘 다 중요한 지표입니다. Parsed 크기는 브라우저가 앱을 로드할 때 수행해야 할 작업 양을 이해하는 데 도움을 줍니다. 반면 Gzipped 크기는 앱이 사용자에게 빠르게 다운로드되고 실행을 시작할 수 있는 속도를 알려줍니다.\n\n\n\n우리는 React Lazy Imports에 마법 주석을 추가하여 출력을 향상시킬 수 있어요.\n\nLazy Imports 또는 Lazy Loading:\n\n```js\nimport React from 'react';\n\nconst Users = React.lazy(() =>\n    import(\n        /* webpackChunkName:\"Users\" */ 'users/page의 경로'\n    )\n);\n\n\nreturn (\n<React.Suspense fallback={<div>로딩 중....</div>}>\n  <Users/>\n<React.Suspense>\n)\n```\n\n이 향상된 결과는 엄청난 번들을 향상시키기 위한 좋은 시작점이 될 수 있어요. 내가 상위 여덟 청크로 줄인 후 (번들 크기의 약 2/3을 차지해요😲) Webpack 마법 주석을 lazy import된 routes 컴포넌트에 추가한 후에, EmployeeScoreCard (452 KB) 청크와 Style 청크 (296 KB) 중 두 가장 큰 문제가 되는 청크를 식별할 수 있어요.\n\n\n\n\n![ExploringWebpack_6](/assets/img/2024-05-12-ExploringWebpack_6.png)\n\n번들 크기를 최적화하는 데 일반적으로 사용되는 두 가지 방법은 레이지 로딩과 동적 임포트입니다. 또 더 나아가 EmployeeScoreCard 내부의 일부 구성 요소를 레이지 로딩하여 이 청크를 여러 개의 청크로 분할할 수 있습니다. 결과는 다음과 같습니다:\n\n내부 구성 요소를 레이지 로딩한 후 EmployeeScoreCard는 훨씬 작아졌습니다. 우리가 명시적으로 확인하지 않는 이상 전혀 표시되지 않습니다. 또한 마지막 이미지에서 EmployeeInfoGrid라는 청크를 볼 수 있는데, 이 간단한 개선의 결과에 대해 저도 놀랍습니다. 총 청크 크기가 7.25MB에서 6.83MB로 감소했습니다. 6%의 감소입니다. 🤯\n\n번들을 최적화하는 두 번째 방법은 청크 내부에서 동적 임포트를 사용하는 것입니다. 동적 임포트는 일반적으로 사용자 작업에 따라 조건적으로 로딩됩니다. 다음 코드를 고려해보세요:\n\n\n\n```js\nimport React, { useState } from 'react';\n\nconst Dashboard = () => {\n  const [showUserDetails, setShowUserDetails] = useState(false);\n  const [UserDetails, setUserDetails] = useState(null);\n\n  const handleClick = async () => {\n    if (!UserDetails) {\n      const { default: UserDetailsComponent } = await import('./UserDetails');\n      setUserDetails(UserDetailsComponent);\n    }\n    setShowUserDetails(true);\n  };\n\n  return (\n    <div>\n      <button onClick={handleClick}>세부 정보 보기</button>\n      {showUserDetails && UserDetails && <UserDetails user={/* 사용자 데이터 입력 */} />}\n    </div>\n  );\n};\n\nexport default Dashboard;\n```\n\n여기서는 사용자가 버튼을 클릭한 후 UserDetailsComponent만 가져오기 때문에, UserDetailsComponent를 위한 별도의 청크를 만듭니다.\n\n이러한 기술을 따르면 번들 크기를 크게 줄일 수 있어 다음과 같은 결과를 얻을 수 있습니다:\n\n- 초기 로딩 시간 단축\n- 대역폭 사용 감소\n- 브라우저 캐싱 향상\n- 이탈률 낮춤\n- 사용자 경험 향상\n- SEO 향상\n\n\n\n하지만 번들 크기를 줄이는 데 가장 중요한 팁은 제 생각에는:\n\n당신이 할 말을 아는 편이에요:\n- \"나한테 바퀴를 재발명하라는 거야?\"\n- \"그 라이브러리가 내 삶을 더 쉽게 만들어줘.\"\n\n내가 당신에게 그것을 설치하지 말라고 금지하는 건 아니에요 😅 그저 자원을 효율적으로 활용해봐요. 터미널 출력이나 웹팩 분석기 출력을 자세히 살펴보면, 모든 그 무명의 청크들이 node_modules 이거나, 아무 로직이 없는 코드거나, 그리고 우리가 지타줘야 하는 추가적인 부담이 있는 거예요.\n\n\n\n나도 누구 다름 없이 도서관을 좋아해요. 하지만 프로젝트에 라이브러리를 설치한다면 다음을 지켜주세요:\n\n- 정기적으로 유지/업그레이드하기\n- 같은 작업을 수행하는 여러 라이브러리를 설치하지 않기\n- 최신 정보 유지하기. 라이브러리는 사용이 중단되고 브라우저는 매일 라이브러리를 대체할 수 있는 기능을 추가합니다.\n\n마지막으로 번들을 분석한 후, 이 라이브러리들이 반드시 필요하다면 더 작은 라이브러리로 대체해보세요. 다음 패키지를 설치하기 전에 https://bundlephobia.com/ 같은 도구가 여러분의 여정에서 큰 도움이 될 수 있습니다.\n\n작은 번들과 버그 없는 하루 되세요!","ogImage":{"url":"/assets/img/2024-05-12-ExploringWebpack_0.png"},"coverImage":"/assets/img/2024-05-12-ExploringWebpack_0.png","tag":["Tech"],"readingTime":11},{"title":"React 초보자를 위한 기본 개념","description":"","date":"2024-05-12 23:15","slug":"2024-05-12-Reactbasicconceptsforbeginner","content":"\n\n글을 쓰는 것은 제가 배운 것을 다시 상기시키는 데 도움이 돼요. 그럼 시작해볼까요!\n\n리액트란? 웹페이지를 렌더링하는 데 도움이 되는 JavaScript 라이브러리\n\n라이브러리인가요, 프레임워크인가요? 라이브러리는 필요할 때마다 즉시 구축하는 데 도움이 되는 일반적인 도구를 제공하고, 프레임워크는 사용자 정의할 수 있는 기본 청사진을 제공합니다. 리액트는 청사진보다는 도구 상자와 같아서 라이브러리에 속합니다.\n\n왜 리액트를 사용해야 하나요? 간결한 코딩 스타일, 쉬운 코드 블록 재사용, 그리고 더 나은 로직 유닛 형성(업무 분리)이 가능합니다.\n\n\n\n```js\n// 단계 정의, 명령형, DOM 스타일\nlet btn = document.querySelector('button');\n\nif (user.isLoggedIn){\n  button.textContent = '계속하기'\n}\nelse {\n  button.textContent = '로그인'\n}\ndocument.body.append(btn);\n```\n\n```js\n// 목표 정의, 선언형, React-Dom 스타일\nlet content;\nif (user.isLoggedIn){\n  content = <button>계속하기</button>\n}\nelse {\n  content = <button>로그인</button>\n}\nreturn content;\n```\n\n리액트의 네 가지 개념: JSX, 컴포넌트, 프롭스, 상태. 이를 분해하여 이해해봅시다.\n\nJSX는 자바스크립트 문법 확장으로 HTML을 자바스크립트 코드에 포함할 수 있게 해줍니다.\n\n\n\n\n```js\n// Header.jsx에 저장\nexport default function Header() {\n  return (\n    <header>\n      <h1> 이것은 헤더에 속해 있습니다. </h1>\n    </header>\n  )\n}\n```\n\n컴포넌트는 HTML 블록(React 레고)을 반환하는 함수입니다. 일반적으로 이러한 블록을 결합하여 웹페이지를 만듭니다.\n\n```js\nimport Header from './Header.jsx'\n\nexport default function App() {\n  return(\n    <div>\n      <Header />     // 컴포넌트\n    </div>\n  )    \n}\n```\n\nProps는 사용자 정의 컴포넌트에 설정할 수 있는 속성입니다. 데이터가 컴포넌트 간에 흐를 수 있도록 하는 것이 목적입니다.\n\n\n\n\n```js\nfunction MyComponent(props){\n  console.log(props.name); // appName\n  console.log(props.age); // 777\n}\n\nfunction App(){\n  return (\n    <div>\n      <MyComponent\n        name=\"appName\"\n        age=777\n      />\n    </div>\n  )\n}\n```\n\n상태(State)는 두 가지 역할을 하는 React 후크입니다. 업데이트를 기다리고 웹페이지를 다시 렌더링합니다. 상태 후크가 필요한 이유는 React 컴포넌트가 내부적으로 시작할 때 한 번만 실행되고 나중에 업데이트되면 기본적으로 다시 렌더링되지 않기 때문입니다. 따라서 React에게 특정 정보나 상태가 변경되었음을 알리고 그것을 다시 렌더링하도록 전달할 방법이 필요합니다.\n\n```js\n// .jsx 형식으로 저장\nimport {useState} from \"react\"\n\nconst [getInfo, setInfo] = useState()\n\nfunction handleInfo(newInfo) {\n  setInfo(newInfo)\n}\n\nlet info = <p>기본 정보</p>\nif(getInfo) {\n  info = getInfo\n}\n\nreturn (\n  <CusButton onClick={() => handleInfo(\"CB가 클릭되었습니다\")}> CB </CusButton>\n  <div>\n    {info}\n  </div>\n)\n```\n\n간단히 말하면, React는 주로 웹페이지 렌더링에 초점을 맞춘 자바스크립트 라이브러리입니다. JSX, 컴포넌트, 프롭스(props) 및 상태(State)라는 네 가지 필수 개념이 있습니다. JavaScript 문법 확장을 통해 관련 HTML/CSS/JS를 컴포넌트로 그룹화할 수 있습니다. 컴포넌트는 서로 통신하기 위해 프롭스를 포함하고, 마지막으로 상태(State)는 업데이트 시 컴포넌트를 다시 렌더링할 수 있게 합니다.\n","ogImage":{"url":"/assets/img/2024-05-12-Reactbasicconceptsforbeginner_0.png"},"coverImage":"/assets/img/2024-05-12-Reactbasicconceptsforbeginner_0.png","tag":["Tech"],"readingTime":3},{"title":"코로나19 이후 의료 분야에서 데이터의 역할","description":"","date":"2024-05-12 23:14","slug":"2024-05-12-TheroleofdatainhealthcareafterCOVID-19","content":"\n\n코로나19 이후 건강 관리에서 데이터의 역할은 계속 발전하며 건강 관리 환경의 다양한 측면을 형성하고 있습니다. 데이터가 중요한 역할을 하는 주요 영역은 다음과 같습니다:\n\n질병 감시 및 모니터링:\n\n데이터 분석은 COVID-19 확산 추적, 핫스팟 식별 및 트렌드 예측에 핵심적인 역할을 해왔습니다. 정부와 건강 기관이 검사 결과, 입원 환자, 이동 패턴 등 다양한 소스에서 얻은 데이터를 활용하여 공중보건 조치와 자원 할당을 위한 의사결정에 어떻게 활용했는지 알아보세요.\n\n![이미지](/assets/img/2024-05-12-TheroleofdatainhealthcareafterCOVID-19_0.png)\n\n\n\n공중보건 개입 및 정책 결정:\n\n데이터 기반 모델링 및 시뮬레이션이 어떻게 코로나바이러스 감염 확산 완화를 위한 공중보건 정책, 사회적 거리두기 조치 및 접종 전략에 영향을 미쳤는지 살펴보세요. 개인 데이터를 공중보건 감시 및 접촉 추적에 사용하는 것의 윤리적 및 개인정보 보호 측면에 대해 논의해보세요.\n\n![이미지](/assets/img/2024-05-12-TheroleofdatainhealthcareafterCOVID-19_1.png)\n\n건강 격차 감소 및 균형성:\n\n\n\n건강 격차에 대한 대응과 건강 평등 증진은 팬데믹 이후 계속해서 중요한 우선 순위 사항입니다. 데이터 기반 이니셔티브는 의료 접근성, 결과 및 건강의 사회적 결정 요인에 대한 격차를 식별하여, 불평등에 기여하는 근본적인 요소를 해결하기 위한 특정 대응책을 가능하게 합니다. 데이터 분석을 통해 의료 이해권자들은 증거 기반 정책과 개입을 개발하여 모든 인구 집단을 위해 격차를 줄이고 건강 평등을 향상시킬 수 있습니다.\n\n요약하면, 데이터는 팬데믹 이후 의료 분야에서 혁신을 이끄는 역할을 지속하고 있으며, 환자 결과를 개선하고 의료 시스템이 미래 도전에 대비할 수 있도록 강화함으로써 건강을 향상시키고 있습니다. 데이터 분석의 능력을 활용하여 의료 이해권자들은 공중 보건 목표를 추진하고 의료 서비스 제공을 최적화하여 궁극적으로 개인과 지역사회의 건강과 복지를 향상시킵니다.","ogImage":{"url":"/assets/img/2024-05-12-TheroleofdatainhealthcareafterCOVID-19_0.png"},"coverImage":"/assets/img/2024-05-12-TheroleofdatainhealthcareafterCOVID-19_0.png","tag":["Tech"],"readingTime":2}],"page":"125","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}