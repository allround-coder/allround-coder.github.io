{"pageProps":{"posts":[{"title":"리액트 라우터 시작하기","description":"","date":"2024-05-14 10:51","slug":"2024-05-14-GettingStartedwithReactRouter","content":"\n\n![React Router](/assets/img/2024-05-14-GettingStartedwithReactRouter_0.png)\n\n다이나믹 웹 앱을 만들어 보고 싶은 꿈이 있나요? 사용자가 페이지를 새로 고침하지 않고 서로 다른 섹션 또는 페이지로 쉽게 이동할 수 있는 경험을 제공하는 React Router가 여러분의 비밀 병기가 될 거예요! React 앱에 초능력을 부여하는 강력한 라이브러리로, 부드럽고 직관적인 내비게이션 경험을 만들어볼 수 있어요.\n\n이 안내서는 여러분이 React Router 여행을 떠날 때 나침반 역할을 할 거예요. 기본 사항을 분해하고 일반적인 경로를 탐색하여 페이지 이동 및 사용자 친화적인 앱 구축을 시작하는 데 도움을 줄 거예요.\n\n설치 및 설정\n\n\n\n코드를 시작하기 전에 React Router를 사용해보겠습니다. 터미널을 열고 다음 설치 명령어를 입력하세요:\n\n```js\nbash\nnpm install react-router-dom\n```\n\n이 명령어는 React 어플리케이션 내에서 작업하기 위해 특별히 설계된 React Router의 최신 버전을 설치합니다.\n\n이제, React Router를 우리 어플리케이션의 주요 파일인 index.js(main.jsx)에 소개해야 합니다. react-router-dom에서 BrowserRouter 컴포넌트를 import하세요. 이 컴포넌트는 네이게이션의 주인공으로 현재 URL을 추적하고 해당 내용이나 컴포넌트를 렌더링하는 역할을 합니다.\n\n\n\n애플리케이션 전체(일반적으로 App.jsx)을 BrowserRouter로 감싸세요. 이렇게 하면 모든 컴포넌트가 라우팅 마법을 활용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithReactRouter_1.png)\n\n라우트 및 컴포넌트\n\n앱을 각각의 뷰 또는 섹션을 나타내는 섬들의 집합으로 상상해보세요. React Router의 Route 컴포넌트는 사용자를 이러한 섬들 사이를 운반해주는 배 역할을 합니다.\n\n\n\n간단한 예제입니다:\n\n```js\nimport {Routes, Route } from 'react-router-dom';\nimport Home from './components/Home';\nimport About from './components/About';\nfunction App() {\n return (\n\n <Routes>\n <Route path=\"/\" element={<Home />} /> {/* 홈 페이지로 이동하는 경로 */}\n <Route path=\"/about\" element={<About />} /> {/* 소개 페이지로 이동하는 경로 */}\n </Routes>\n \n );\n}\n\nexport default App;\n```\n\n이 예제에서 두 가지 경로가 있습니다:\n\n1. 첫 번째 경로 (path=\"/\")는 Home 컴포넌트에 해당하는 홈 페이지를 가리킵니다.\n2. 두 번째 경로 (path=\"/about\")는 About 컴포넌트에 해당하는 소개 페이지로 이동합니다.\n\n\n\n사용자가 앱의 루트 URL을 방문하면 홈페이지가 표시됩니다. 그들이 /about으로 이동하면 About 컴포넌트가 주인공이 됩니다.\n\n링크로 탐색하기\n\n그럼 사용자는 이럿의 다른 섬들을 어떻게 탐험할까요? React Router는 링크 컴포넌트를 제공합니다. 이는 마법의 앵커와 같은 역할을 하는데요. 이는 html의 앵커 태그와 동의어입니다. 링크를 클릭하면 React Router가 지정된 경로로 항해하라고 알려줍니다.\n\n다음은 사용 방법입니다:\n\n\n\n```js\nimport { Routes, Route, Link } from 'react-router-dom';\nfunction App() {\n return (\n \n <nav>\n   <Link to=\"/\">홈</Link>\n   <Link to=\"/about\">소개</Link>\n </nav>\n\n\n <Routes>\n   <Route path=\"/\" element={<Home />} /> {/* 홈 경로 */}\n   <Route path=\"/about\" element={<About />} /> {/* 소개 경로 */}\n </Routes>\n\n );\n}\n\nexport default App;\n```\n\n이 코드는 두 개의 링크가 있는 간단한 내비게이션 바를 만듭니다. \"홈\" 링크를 클릭하면 사용자를 홈 페이지로 이동시키고, \"소개\"를 클릭하면 소개 페이지로 이동시킵니다. 모두 React Router가 원활하게 처리합니다.\n\n만약 Not Found Routes가 있으면 어떨까요?\n\n![GettingStartedwithReactRouter_2](/assets/img/2024-05-14-GettingStartedwithReactRouter_2.png)\n\n\n\n\n만약 사용자가 정의된 경로와 일치하지 않는 URL을 입력하려고 하면 어떻게 될까요? React Router는 이러한 상황을 처리하는 편리한 방법을 제공합니다. 사용자 지정 \"404 Not Found\" 페이지를 표시하기 위한 catch-all route를 추가할 수 있습니다:\n\n```js\n<Route path=\"*\" element={<NotFound />} />\n```\n\n이 route는 이전에 정의된 경로와 일치하지 않는 모든 URL에 일치하며, 사용자가 길을 잃지 않도록 보장합니다. 별표(`*`)는 와일드카드로 작동하여 이 route가 애플리케이션의 기본 URL 뒤에 오는 내용에 관계없이 모든 URL 경로와 일치할 것을 나타냅니다.\n\n이것은 React Router가 제공하는 일부 기능의 일부에 불과합니다. 앱이 성장함에 따라 중첩된 route, 동적 매개변수, 프로그래밍 방식의 탐색과 같은 더 고급 기능을 탐색할 수 있습니다. React Router는 복잡하고 사용자 친화적인 네비게이션 경험을 구축할 수 있도록 돕으며, 웹 앱을 탐험하기 즐거운 경험으로 만들어줍니다.\n\n\n\nReact Router 모험의 시작에 불과하다는 것을 기억하세요. 더 많은 기능을 발견할 수 있고 연습을 통해 금방 마스터 네비게이터가 될 거에요!","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithReactRouter_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithReactRouter_0.png","tag":["Tech"],"readingTime":3},{"title":"서버 측 세션 구현하기 - Nextjs","description":"","date":"2024-05-14 10:50","slug":"2024-05-14-NextjsImplementingServer-SideSessions","content":"\n\n<img src=\"/assets/img/2024-05-14-NextjsImplementingServer-SideSessions_0.png\" />\n\n# 단계 1: 서버 측 세션 구현하기\n\n먼저 세션 관리 시스템을 설정하세요. 일반적으로 세션을 생성하고 유효성을 검사하며, 세션 정보를 안전한 HTTP-only 쿠키에 저장하는 과정을 포함합니다.\n\n## API 라우트에서의 세션 관리\n\n\n\nAPI 라우트(app/routes/api/)에서 세션을 관리할 수 있습니다. 예를 들어, 로그인 라우트에서는 사용자를 인증하고 세션을 생성한 후 세션 쿠키를 설정할 수 있습니다.\n\n```js\n// app/routes/api/login.ts\n\nimport { createSession, getUser } from '@/lib/auth'; // 이 함수들을 구현하세요\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\nexport default async function login(req: NextApiRequest, res: NextApiResponse) {\n  const user = await getUser(req.body.username, req.body.password); // 사용자 인증\n  if (!user) {\n    return res.status(401).json({ error: '유효하지 않은 자격 증명' });\n  }\n\n  const sessionId = await createSession(user.id); // 세션 생성\n  res.setHeader('Set-Cookie', `sessionId=${sessionId}; HttpOnly; Path=/; SameSite=Lax`);\n  res.status(200).json({ message: '성공' });\n}\n```\n\n# 단계 2: App Router 미들웨어를 사용한 리디렉션\n\nApp Router 미들웨어를 사용하여 요청을 가로채고 세션 상태를 기반으로 로직을 구현할 수 있습니다.\n\n\n\n## 미들웨어 예시\n\n세션 유효성 검사와 리다이렉션을 처리하는 미들웨어 파일(e.g., app/middleware.ts)을 생성하세요.\n\n```js\n// app/middleware.ts\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getSession } from '@/lib/session'; // 이 함수 구현 필요\n\nexport async function middleware(req: NextRequest) {\n  const session = await getSession(req.cookies.sessionId); // 세션 유효성 검사\n\n  // 세션이 없고 요청이 보호된 경로일 경우에는 로그인 페이지로 리다이렉션\n  if (!session && req.nextUrl.pathname.startsWith('/protected')) {\n    return NextResponse.redirect(new URL('/login', req.url));\n  }\n\n  return NextResponse.next();\n}\n```\n\n# 단계 3: 클라이언트에서 세션 유효성 검사 및 리다이렉션\n\n\n\n클라이언트 측에서는 여전히 세션 관련 업데이트를 처리해야 할 수도 있습니다. 로그인/로그아웃 후 리다이렉트 또는 로딩 상태 표시와 같은 작업들이 필요할 수 있어요.\n\n```js\n// 당신의 React 컴포넌트 안에서\nimport { useEffect } from 'react';\nimport { useRouter } from 'next/router';\n\nconst MyComponent = () => {\n  const router = useRouter();\n\n  useEffect(() => {\n    // 세션 상태 확인하고 필요시 리다이렉트\n    // 세션을 확인하는 API 루트에 요청을 보낼 수도 있어요.\n    checkSession().then(isValidSession => {\n      if (!isValidSession) {\n        router.push('/login');\n      }\n    });\n  }, []);\n\n  // 컴포넌트 렌더링\n};\n```\n\n# 결론\n\n- 세션 보안: 안전한 HTTP-only 쿠키를 사용하여 세션 식별자를 저장하세요.\n- 쿠키 플래그: SameSite 및 Secure와 같은 적절한 쿠키 플래그 설정을 통해 보안을 강화하세요.\n- 확장성: 확장 가능한 애플리케이션을 위해 세션 관리에 데이터베이스나 Redis와 같은 서비스를 고려해보세요.\n- 오류 처리: 세션 관리 로직에서 견고한 오류 처리를 보장하세요.\n- 클라이언트 측 처리: 서버 측 확인이 있더라도, 사용자 경험을 향상시키기 위해 세션 상태에 따라 특정 클라이언트 측 동작을 처리할 수도 있습니다.\n\n\n\n이 설정은 App Router를 사용하여 Next.js 애플리케이션에서 서버 측 세션을 관리하고 라우트 액세스를 제어하는 강력한 시스템을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-14-NextjsImplementingServer-SideSessions_0.png"},"coverImage":"/assets/img/2024-05-14-NextjsImplementingServer-SideSessions_0.png","tag":["Tech"],"readingTime":3},{"title":"TypeScript에서 리터럴 이해하기 포괄적인 안내","description":"","date":"2024-05-14 10:49","slug":"2024-05-14-UnderstandingLiteralsinTypeScriptAComprehensiveGuide","content":"\n\n<img src=\"/assets/img/2024-05-14-UnderstandingLiteralsinTypeScriptAComprehensiveGuide_0.png\" />\n\n프로그래밍 세계에서 기초 개념을 이해하는 것은 중요합니다. 리터럴은 TypeScript의 기본 개념 중 하나입니다. TypeScript를 막 시작했거나 지식을 더 키우고 싶다면, 이 안내서는 TypeScript에서 리터럴과 그 중요성에 대해 포괄적으로 이해하도록 도와줄 것입니다.\n\n# 리터럴이란 무엇인가요?\n\nTypeScript에서 리터럴이란 정확하고 변경할 수 없는 값들을 가리킵니다. 이러한 값들은 계산이나 변환 없이 코드에 직접 제공됩니다. TypeScript는 숫자 리터럴, 문자열 리터럴, 부울 리터럴 등 여러 유형의 리터럴을 지원합니다.\n\n\n\n# 숫자 리터럴\n\n숫자 리터럴은 TypeScript에서 숫자를 나타냅니다. 십진수(기수 10), 16진수(기수 16), 8진수(기수 8), 또는 2진수(기수 2)와 같은 다양한 형식으로 표현할 수 있습니다. 여기에 몇 가지 예시가 있습니다:\n\n```js\nlet decimalLiteral: number = 42;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\n```\n\n\n\n문자열 리터럴은 홑따옴표(‘ ‘)나 겹따옴표(“ “)로 둘러싸인 텍스트 데이터를 나타냅니다. 문자, 숫자, 기호 및 특수 문자를 포함할 수 있습니다. TypeScript에서 문자열 리터럴이 어떻게 보이는지 여기에 있습니다:\n\n```js\nlet hello: string = \"Hello\";\nlet world: string = 'World';\n```\n\n# 부울 리터럴\n\n부울 리터럴은 true 또는 false라는 두 가지 가능한 값만을 나타냅니다. 논리 연산 및 조건식에 일반적으로 사용됩니다. 부울 리터럴의 사용법은 다음과 같습니다:\n\n\n\n```js\nlet isTrue: boolean = true;\nlet isFalse: boolean = false;\n```\n\n# 다른 리터럴 타입\n\n숫자, 문자열 및 불리언 리터럴 외에도 TypeScript는 null 및 undefined와 같은 다른 리터럴 타입을 지원합니다.\n\n```js\nlet nullLiteral: null = null;\nlet undefinedLiteral: undefined = undefined;\n```\n\n\n\n# 리터럴 사용의 장점\n\n- 타입 안전성: 리터럴을 사용하면 TypeScript가 특정 타입을 추론하여 개발 중에 타입 안전성을 제공합니다. 예를 들어, 숫자 리터럴을 변수에 할당하는 경우 TypeScript는 변수의 타입이 숫자임을 알고 있습니다.\n- 명확성과 가독성: 리터럴을 사용하면 코드가 명확하고 가독성이 좋아집니다. 코드에서 리터럴 값을 보면 다른 곳에서 정의를 찾아볼 필요없이 해당 값이 무엇을 나타내는지 정확하게 알 수 있습니다.\n- 향상된 도구 지원: TypeScript의 IntelliSense 및 코드 편집기는 리터럴을 사용할 때 더 나은 자동 완성 제안 및 타입 검사 지원을 제공하여 더 생산적인 개발 경험을 제공할 수 있습니다.\n\n# 리터럴 타입 사용\n\nTypeScript에서는 문자열, 숫자 또는 부울 리터럴을 기본 타입으로 사용하여 사용자 정의 리터럴 타입을 생성할 수 있습니다. 이를 통해 변수가 보유할 수 있는 특정 값들을 정의할 수 있습니다.\n\n\n\n```js\ntype 방향 = '위' | '아래' | '왼쪽' | '오른쪽';\n\nlet move: 방향 = '위'; // 유효함\nlet invalidMove: 방향 = '대각선'; // 에러: '대각선'을 '방향' 타입에 할당할 수 없습니다\n```\n\n# 결론\n\n리터럴은 TypeScript에서 타입 안정성과 코드 가독성을 향상시키는 정확하고 변경할 수 없는 값 제공하는 데 중요한 역할을 합니다. 리터럴을 효과적으로 사용하는 방법을 이해하면 TypeScript 코드의 품질과 유지보수성을 향상시킬 수 있습니다. 사용자 정의 리터럴 타입을 정의하거나 내장된 리터럴을 활용하든, 코드베이스에 포함시킬 경우 더 견고하고 신뢰할 수 있는 소프트웨어를 개발할 수 있습니다\n","ogImage":{"url":"/assets/img/2024-05-14-UnderstandingLiteralsinTypeScriptAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-14-UnderstandingLiteralsinTypeScriptAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트js와 TypeScript의 차이를 탐구해보기","description":"","date":"2024-05-14 10:48","slug":"2024-05-14-ExploringtheDifferencesBetweenReactjsandTypeScript","content":"\n\n![React vs TypeScript](/assets/img/2024-05-14-ExploringtheDifferencesBetweenReactjsandTypeScript_0.png)\n\n자바스크립트를 좋아하는 건 음악을 즐기는 것과 비슷해. 사람마다 다르지만, 나는 항상 프로젝트에 대해 자바스크립트를 사용해왔어. 뭐든지 말해봐, 프론트엔드에는 React.js, 백엔드에는 Node.js, 모바일에는 React Native, 심지어 머신 러닝에는 TensorFlow까지 사용해. 모든 문제를 해결하는 거야.\n\n그런데 TypeScript가 나타났어. \"아 또 다른 언어구나!\" 라고 생각했지만, 한 번 시도해보니 의외로 매력을 느꼈어. 지금은 TypeScript를 배우고 있고, React 팬들과 몇 가지 멋진 TypeScript와 React의 차이를 공유하고 싶어.\n\n먼저, 그들은 쌍둥이가 아니야. React는 프론트엔드에서 멋진 친구인 반면, TypeScript는 좀 더 다재다능해. 라이브러리뿐만 아니라, 자바스크립트를 더 멋지게 만드는 전체 프로그래밍 언어야.\n\n\n\nReact.js와 TypeScript는 웹 개발 분야에서 슈퍼히어로 같은 역할을 해. 그들이 멋진 일을 하고 있어. 그런데 알겠니? 때때로, 그들은 함께 협력해서 잘 작동하는 멋진 앱을 만들어. 그래서, React.js와 TypeScript가 어떻게 다른지 이야기해보고, 간단한 코드 조각들을 보여줄게. 멋지지?\n\n오케이, 조금 더 활력을 불어넣어 보자.\n\n## 타입 안전성\n\nReact.js를 상상해봐. 그것은 자바스크립트를 사용하여 아름다운 사용자 인터페이스를 그려내는 예술가 같아. 웹 세상을 위해 재사용 가능한 구성 요소를 만드는 것에 집중해. 하지만, 잠깐만, 자연스럽게 어떤 보디가드도 문에서 타입을 확인하고 있는 건 아니야!\n\n\n\n이제 TypeScript을 소개합니다, JavaScript의 슈퍼히어로 사이드킥입니다. TypeScript은 안전 요소를 추가한 JavaScript 같은 언어입니다. TypeScript은 \"정적 유형 지정\"이라고 하는 멋진 기능을 추가합니다. 이것은 코드 클럽의 보디가 있는 것으로 상상해보세요. 모든 것이 잘 정리되어 있는지 확인합니다. 이것은 단지 코드를 최고 수준으로 만드는 것뿐만 아니라 개발자들이 놀 수 있는 정말 멋진 도구들을 제공합니다. 안전과 멋진 도구 - TypeScript은 이 조합을 가지고 있어요! 🦸‍♂️💻\n\nTypeScript 예제에서 우리는 인터페이스를 사용하여 name 속성의 유형을 명시적으로 정의하여 문자열 유형의 값만 전달되도록 보장합니다.\n\n## 정적 유형 지정 vs. 동적 유형 지정\n\nReact.js는 동적 유형 지정에 의존하여 변수가 실행 중에 유형을 변경할 수 있도록 합니다. TypeScript은 정적 유형 지정을 사용하여 개발 중에 유형 오류를 잡아내어 버그를 줄이고 코드 유지 관리성을 향상시킵니다.\n\n\n\nTypeScript 예제에서 문자열로 선언된 변수에 숫자를 할당하려고 시도하면 컴파일 시 오류가 발생하여 정적 타입의 장점이 부각됩니다.\n\n## 코드 가독성과 유지 보수성\n\nTypeScript는 타입을 명시적으로 정의하여 코드의 가독성을 높이고, 개발자가 코드를 이해하고 유지할 수 있도록 돍게 만듭니다. React.js는 덜 번잡하므로 작은 프로젝트나 빠른 개발이 우선시되는 경우에 선호될 수 있습니다.\n\nTypeScript 예제는 매개변수와 반환 유형의 타입을 명시적으로 선언하여 개발자에게 추가적으로 명확성을 제공합니다.\n\n\n\n## 도구 및 개발 경험\n\nTypeScript는 현대 통합 개발 환경(IDE)에서 고급 도구를 제공합니다. 이 도구에는 자동 완성, 리팩터링 지원, 그리고 더 나은 오류 확인이 포함됩니다. 반면에 언어가 아닌 라이브러리인 React.js는 이러한 기능을 기본적으로 제공하지 않습니다.\n\n이 TypeScript 예제에서는 Visual Studio Code와 같은 코드 편집기를 사용하여 개발 중에 자동 완성 제안과 유형에 대한 즉각적인 피드백을 제공합니다.\n\n## 이것으로 마무리하며 약간의 흥분을 더해봅시다\n\n\n\n그럼 이만큼! React.js와 TypeScript는 웹 개발 세계의 다이내믹한 듀오 같아요. 각각이 갖고 있는 특별한 능력을 가져와서 테이블에 올려놓으니까요. 화려하고 동적인 사용자 인터페이스가 필요해? React.js가 최고의 선택이에요. 코드 품질과 개발자 스웨거에도 조금 더 신경 쓰고 싶어? TypeScript는 정적 타이핑을 제공하는 멋진 친구랍니다.\n\n그런데요, 이 둘이 만나면 마법이 벌어져요! 동적인 UI가 견고한 구조를 만날 때, 마치 코딩 걸작품을 만드는 느낌이랍니다. 그래서 결론은 뭐냐면? 그들은 경쟁자가 아니라 범죄 동료일 뿐이에요. 웹 개발자들에게 놀라운 디지털 경험을 제작하기 위한 최고의 태그 팀을 제공해주죠. 이거 완전한 웹 개발 모험이에요. React.js와 TypeScript와 함께하면 꿈의 팀을 가지게 되는 거죠! 🚀✨\n\n그리고 작은 비밀 보너스가 있어요\n\nTypeScript는 React.js를 위한 무대 뒤의 영웅이 아닙니다. 아니요, 이중 요원이에요! TypeScript를 전면과 후면 모두에서 활용할 수 있습니다. 웹 개발 무대 어느 쪽에서든 마법을 부릴 수 있는 다재다능한 마술사를 가지고 있는 것과 같아요.\n\n\n\n그래서 React.js로 사용자 인터페이스를 더 멋지게 만들고 있건지, 백엔드에서 뒷담화를 조성하고 있건지, TypeScript가 여러분에게 더 부드럽고 버그에 강한 코딩 경험을 제공해줄 겁니다. 이것은 코딩용 스위스 아미 나이프를 가지고 있는 것과 같아요 — 실용적이고 다재다능하며, 어떤 웹 개발 모험이 오더라도 준비되어 있는 겁니다! 🎩🔮✨\n\n다음 주에 뵙겠습니다.","ogImage":{"url":"/assets/img/2024-05-14-ExploringtheDifferencesBetweenReactjsandTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-ExploringtheDifferencesBetweenReactjsandTypeScript_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트의 종말","description":"","date":"2024-05-14 10:47","slug":"2024-05-14-TheDeathofReact","content":"\n\n요즘 소프트웨어 개발 커뮤니티에서는 페이스북에서 개발한 JavaScript 라이브러리인 React의 급부상을 목격했습니다. 이 도민은 어디서 온 걸까요? 구성 요소 기반 접근 방식으로 동적 애플리케이션 개발을 용이하게 한다는 약속은 많은 이의 상상력을 사로잡았습니다. 그러나 시간이 흐르면서 필연적으로 질문이 제기됩니다: 우리는 React의 \"죽음\"을 목격하는 것인가요?\n\n온라인 강좌에 의한 부상\n\n최근의 React 상황은 초보자를 위한 온라인 강좌의 쇄도에 크게 영향을 받았습니다. 이러한 강좌들은 누구나 몇 달 안에 개발자로 변신할 수 있는 것을 약속하며, 표준 기술인 JavaScript, React 및 TypeScript를 가르칩니다. 이러한 강좌들의 접근성과 가르침 방식은 React의 인기에 크게 기여했습니다. 이러한 강좌들은 React를 배우면 기술 시장에 진입하는 관성적인 지름길임이 확실하다는 인식을 만듭니다.\n\n과잉 포화된 시장과 직업 현실\n\n\n\nReact 교육 대중화의 직접적인 결과는 시장 포화입니다. 많은 참가자로 구성된 반응 개발자 채용 공고가 링크드인에 올라오는데, 스타트업과 기업들은 수백, 수천 명의 지원자에 직면할 수도 있습니다. 이는 React의 인기를 증명하는 것이지만 동시에 지원자들 사이의 품질과 차별화에 대한 의문을 던집니다. 모두가 유사한 기술을 가지고 있다면, 돋보이는 것이 더 큰 도전이 될 것입니다.\n\n확장성과 유지보수 문제\n\nReact에 대한 또 다른 자주 제기되는 비판은 라이브러리 자체에 집중되는 것이 아니라 대규모로 사용될 때의 영향에 대한 것입니다. React는 매우 강력하고 유연하지만, 대규모 프로젝트에서는 복잡하고 유지보수가 어려울 수 있습니다. 이는 방대한 생태계와 수많은 보조 라이브러리 및 아키텍처 중에서 선택해야 하는 지속적인 필요 때문에 발생하며, 이는 일관성 및 장기적인 유지보수의 어려움으로 이어질 수 있습니다.\n\n불가피한 기술적 진화\n\n\n\n기술은 그 본질상 항상 진화하고 있습니다. 새로운 도구들이 나오고, 기존 도구들이 개선되거나 대체되고 있습니다. Vue와 Svelte와 같은 프레임워크는 React보다 가벼우면서 더 빠르다는 약속이나 React의 지각된 문제들 중 일부를 해결하는 접근 방식을 제공하기 때문에 인기를 얻고 있습니다. 게다가 React 팀 자체도 라이브러리를 계속 발전시켜와서 성능 향상을 중점으로 새로운 기능인 Hooks와 같은 것을 통해 코드를 간단하게 하고 컴포넌트 재사용성을 높이는 방향으로 업데이트하고 있습니다.\n\n결론\n\nReact의 \"죽음\"을 선고하는 것은 조급하고 과장된 것일 것입니다. 온라인 강의를 통한 인기화와 확장 가능성에 따른 시장 포화에 직면하긴 하지만, React는 여전히 산업에서 강력하고 널리 사용되는 도구입니다. 개발자들이 기술적 지식을 깊게 함으로써 그들 자신을 차별화하고 새로운 기술과 방법들을 꾸준히 업데이트함으로써 중요성은 이전보다 더 커지고 있습니다. 죽음보다는, 아마도 웹 애플리케이션 개발 방식을 바꾼 도구의 자연스러운 발전을 우리는 지켜보고 있는 것이 아닐까요?","ogImage":{"url":"/assets/img/2024-05-14-TheDeathofReact_0.png"},"coverImage":"/assets/img/2024-05-14-TheDeathofReact_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트에 대해 꼭 알아야 할 10가지 핵심 개념","description":"","date":"2024-05-14 10:45","slug":"2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact","content":"\n\n<img src=\"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png\" />\n\n- React Js를 배워야 하는 이유\n\nReact의 가장 중요한 개념인 JSX, 클래스 및 함수 컴포넌트, 프롭스, 상태, 라이프사이클 메서드 및 훅에 대한 굳은 이해를 갖게 될 것입니다. 이러한 아이디어들을 React의 모듈식 프로그래밍 스타일로 결합할 수 있습니다.\n\n저는 지금까지 React를 사용해왔습니다. 또한 사람들이 처음부터 배우도록 지도하는 훈련을 진행하고 있습니다. 매 훈련 세션마다 같은 개념 세트를 반복해서 설명하고 있다는 것을 알게 되었습니다. 제가 생각하기에 그 개념들은 React를 \"구사하려면\" 필수적입니다. 지금 학습 중이라면 이 글을 읽는 것에 관심이 있을 것입니다.\n\n\n\n## 프레임워크가 아닙니다\n\nAngular나 Ember는 이미 몇 가지 결정이 완료된 프레임워크입니다. React는 라이브러리일 뿐이며 모든 결정을 직접 내려야 합니다. React는 컴포넌트를 사용하여 사용자 인터페이스를 구축하는 데 도움을 주는 데에 중점을 둡니다.\n\n2. JSX 내에서 표현식\n\nJSX 내에서 중괄호를 사용하여 어떤 곳에서든 JavaScript 표현식을 포함할 수 있습니다.\n\n\n\n## 중첩된 JSX 엘리먼트\n\n```javascript\nconst myClasses = (\n\t<>\n\t\t<a href=\"https://www.payal.com\">\n\t\t\t<h1>가입하기!</h1>\n\t\t</a>\n\t</>\n);\n```\n\n\n\n아래 코드 블록에서 `a` 태그가 가장 바깥에 있는 요소여야 합니다.\n\nJSX는 JavaScript의 구문 확장입니다. React DOM에서 렌더링되는 DOM 요소를 생성하는 데 사용됩니다.\n\n\n\nJSX를 포함한 JavaScript 파일은 웹 브라우저에 도달하기 전에 컴파일해야 합니다. 아래 코드 블록은 컴파일이 필요한 일부 예제 JavaScript 코드를 보여줍니다.\n\n3. React Virtual DOM\n\nReact를 사용하거나 배우고 있다면, \"Virtual DOM\"이라는 용어를 들어봤을 것입니다. 그렇다면 Virtual DOM은 무엇이고, React가 왜 사용하는 걸까요?\n\n## Virtual DOM\n\n\n\n가상 DOM의 개념이 중요한 이유입니다. 실제 DOM보다 훨씬 뛰어난 성능을 발휘합니다. 가상 DOM은 DOM의 가상 표현입니다. 애플리케이션의 상태가 변경될 때마다 실제 DOM이 아닌 가상 DOM이 업데이트됩니다.\n\n가상 DOM이 훨씬 빠르고 효율적인 이유는 다음과 같습니다.\n\n## 가상 DOM이 더 빠른 이유는 무엇인가요?\n\nUI에 새로운 요소가 추가되면 트리로 표시되는 가상 DOM이 생성됩니다. 각 요소는 이 트리의 노드입니다. 이러한 요소 중 하나의 상태가 변경되면 새로운 가상 DOM 트리가 생성됩니다. 그런 다음이 트리는 이전 가상 DOM 트리와 비교됩니다(\"diffed\").\n\n\n\n이 작업이 완료되면 가상 DOM은 실제 DOM에 이러한 변경사항을 적용하는 최상의 방법을 계산합니다. 이를 통해 실제 DOM에 대한 작업이 최소화됩니다. 따라서 실제 DOM을 업데이트하는 성능 비용이 줄어듭니다.\n\n아래 이미지는 가상 DOM 트리와 차이 비교 과정을 보여줍니다.\n\n![가상 DOM 트리 및 차이 비교](/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_1.png)\n\n4. React는 어떻게 가상 DOM을 사용할까요?\n\n\n\n이제 Virtual DOM이 무엇인지에 대한 이해가 어느 정도 되었으니, 어떻게 React가 가상 DOM을 활용하는지 알아보겠습니다.\n\nReact에서 모든 UI 조각은 컴포넌트이며, 각 컴포넌트는 상태를 가지고 있습니다. React는 관찰 가능한 패턴을 따르며 상태 변경을 감지합니다. 컴포넌트의 상태가 변경되면 React는 가상 DOM 트리를 업데이트합니다. 가상 DOM이 업데이트된 후, React는 현재 가상 DOM 버전을 이전 가상 DOM 버전과 비교합니다. 이 과정을 \"diffing(차이 찾기)\"이라고 합니다.\n\nReact는 어떤 가상 DOM 객체가 변경되었는지 알고 나면, 실제 DOM에서 해당 객체만 업데이트합니다. 이는 실제 DOM을 직접 조작하는 것과 비교했을 때 성능이 훨씬 우수합니다. 이로 인해 React는 고성능 JavaScript 라이브러리로 인정받게 되었습니다.\n\n이러한 세부 사항은 React 개발자로부터 추상화되어 있습니다. 당신이 해야 할 일은 컴포넌트의 상태를 필요할 때 업데이트하고 나머지는 React가 처리하도록 하는 것뿐입니다. 이는 React를 사용할 때 우수한 개발자 경험을 보장합니다.\n\n\n\n5. JSX에서 속성\n\nJSX에서 속성을 지정하는 여러 가지 방법이 있습니다.\n\n''. 예를 들어, 다음 JSX에서:\n\n```js\n<MyComponent foo={1 + 2 + 3 + 4} />\n```\n\n\n\nMyComponent에 대한 경우, props.foo의 값은 1 + 2 + 3 + 4가 평가되기 때문에 10이 될 것입니다.\n\n자바스크립트에서 if 문과 for 루프는 표현식이 아니기 때문에 JSX에서 직접 사용할 수 없습니다. 대신 주변 코드에 넣을 수 있습니다. 예를 들어:\n\n```js\nfunction NumberDescriber(props) {\n  let description;\n  if (props.number % 2 == 0) {\n    description = <strong>even</strong>;\n  } else {\n    description = <i>odd</i>;\n  }\n  return <div>{props.number}는 {description} 숫자입니다</div>;\n}\n```\n\n해당 섹션에서 조건부 렌더링 및 반복문에 대해 더 자세히 알아볼 수 있습니다.\n\n\n\n프로퍼티에 값을 전달하지 않으면 true로 기본 설정됩니다. 다음 두 JSX 표현식은 동등합니다:\n\n```js\n<MyTextBox autocomplete />\n<MyTextBox autocomplete={true} />\n```\n\n일반적으로 프로퍼티에 값을 지정하지 않는 것을 권장하지 않습니다. 왜냐하면 ES6 객체 단축 구문인 'foo'가 'foo: foo' 대신 'foo: true'로 간주될 수 있기 때문입니다. 이 동작은 HTML의 동작과 일치하도록 만들어졌습니다.\n\n6. ReactJS — 컴포넌트\n\n\n\n이 장에서는 컴포넌트를 결합하여 앱을 유지보수하기 쉽게 만드는 방법을 배울 것입니다. 이 접근 방식을 통해 컴포넌트를 업데이트하고 변경할 수 있습니다. 페이지의 나머지 부분에 영향을 미치지 않으면서 컴포넌트를 업데이트하고 변경할 수 있습니다.\n\n다음 예제에서 첫 번째 컴포넌트는 App입니다. 이 컴포넌트는 Header와 Content의 소유자입니다. 우리는 Header와 Content를 별도로 생성하고 App 컴포넌트의 JSX 트리 내에 추가하기만 하면 됩니다. 내보내기해야 하는 것은 App 컴포넌트뿐입니다.\n\n```js\nimport React from 'react';\nclass App extends React.Component {\n   render() {\n      return (\n         <div>\n            <Header/>\n            <Content/>\n         </div>\n      );\n   }\n}\nclass Header extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>Header</h1>\n         </div>\n      );\n   }\n}\nclass Content extends React.Component {\n   render() {\n      return (\n         <div>\n            <h2>Content</h2>\n            <p>컨텐츠 텍스트!!!</p>\n         </div>\n      );\n   }\n}\nexport default App;\n```\n\n## 7. Props 및 PropTypes React\n\n\n\nProps와 PropTypes는 React 컴포넌트 간에 정보를 전달하는 중요한 메커니즘입니다. 이번에는 이에 대해 자세히 살펴보도록 하겠습니다. 이 튜토리얼에서는 props, props 전달 및 접근, 그리고 props를 사용하여 어떤 컴포넌트에 정보를 전달하는지에 대한 세부 사항을 소개할 것입니다. 그러나 props를 통해 받는 데이터를 PropTypes를 사용하여 유효성 검사하는 것은 항상 좋은 습관입니다. 따라서 React에서 PropTypes를 어떻게 통합하는지도 배우게 됩니다.\n\nReact는 props라고 불리는 것을 사용하여 컴포넌트에 정보를 전달할 수 있도록 합니다 (props는 properties의 약자). React는 여러 컴포넌트로 구성되어 있기 때문에, props를 사용하면 해당 정보가 필요한 컴포넌트 간에 동일한 데이터를 공유할 수 있습니다. 이는 단방향 데이터 흐름(부모에서 자식 컴포넌트로)을 사용합니다. 그러나 콜백 함수를 사용하면 자식 컴포넌트에서 다시 부모 컴포넌트로 props를 전달하는 것이 가능합니다.\n\n이러한 데이터는 숫자, 문자열, 배열, 함수, 객체 등 다양한 형식으로 올 수 있습니다. 우리는 HTML 태그의 속성을 선언하는 것과 같이 어떤 컴포넌트에도 props를 전달할 수 있습니다. 아래 코드를 살펴보세요:\n\n```js\n<PostList posts={postsList} />\n```\n\n\n\n이 코드 스니펫에서는 'postsList' 값을 가진 posts라는 prop을 PostList라는 컴포넌트로 전달하고 있습니다. 데이터에 액세스하고 전달하는 방법을 알아봅시다.\n\n8. React 앱의 성능 최적화\n\nReact가 등장한 이후로 프런트엔드 개발자들이 웹 애플리케이션을 구축하는 방식을 변화시켰으며, 가상 DOM은 컴포넌트를 효과적으로 렌더링하는 데 유명합니다. 이 튜토리얼에서는 React 애플리케이션의 성능을 최적화하는 다양한 방법과 성능을 향상시킬 수 있는 React의 기능에 대해 논의할 것입니다.\n\n처음 렌더링 과정에서 React는 컴포넌트들의 DOM 트리를 구성합니다. 따라서 DOM 트리 내에서 데이터가 변경되면 변경에 영향을 받는 컴포넌트들만 다시 렌더링되도록 하고, 변경사항에 영향을 받지 않는 다른 컴포넌트들은 건너뛰도록 React에 요청합니다.\n\n\n\n그러나 React에서는 모든 구성 요소를 다시 렌더링할 수 있습니다. 실제로 영향을 받은 구성 요소가 아닌 경우에도 모든 구성 요소를 다시 렌더링할 수 있습니다. 이는 더 오랜로딩 시간이 소요되고, 시간과 CPU 자원이 낭비될 수 있습니다. 이를 방지해야 합니다. 따라서, 우리는 최적화를 위해 노력할 곳입니다.\n\n9. React에서의 상태\n\n지금까지 정적 데이터가 구성 요소 트리를 통해 전달되는 정적 구성 요소에 대해서만 논의했습니다. 종종, 시간이 지남에 따라 상태가 변하는 상태지향 구성 요소를 만들어야 합니다.\n\n아래에 표시되는 텍스트를 입력할 수 있는 \"input\"을 고려해 봅시다.\n\n\n\n```js\nconst InputBox = React.createClass({\ngetInitialState () {\nreturn {\ntext: ''\n}\n},\nchangeText (event) {\nthis.setState({text: event.target.value})\n},\nrender () {\nreturn (\n<div>\n<input type='text' onChange={this.changeText}\nplaceholder='text' value={this.state.text} />\n<span>{this.state.text}</span>\n</div>\n)\n}\n})\n```\n\n우선, 컴포넌트의 기본 상태를 설정합니다. 이 경우에는 빈 텍스트 값을 갖고 싶습니다. 컴포넌트 메서드인 getInitialState()를 사용하여 컴포넌트를 위한 상태 객체를 반환해야 합니다.\n\n상태를 업데이트하기 위해 onChange 이벤트에 changeText() 이벤트 핸들러가 할당됩니다. 상태를 업데이트하기 위해서는 내장된 setState() 메서드를 사용해야 합니다.\n\n상태 업데이트는 예약되고 컴포넌트는 다시 렌더링됩니다. setState() 호출은 React에 대기 중인 상태 변경에 대해 알리기 위해 사용되어야 합니다. 변경 사항이 적용되도록 하기 위해 사용되므로 루프가 변경 사항을 추적하지 않습니다.\n\n\n\n\nsetState()은 비동기적으로 작동한다는 것을 기억해야 합니다. 결과가 즉시 반영되지 않을 수 있습니다. 아래 예시에서는 상태 변경 즉시 접근하는 나쁜 방법과 좋은 방법을 보여줍니다.\n\n### 10. React Hooks\n\nHooks는 React 16.8 버전에서 소개된 새로운 기능입니다. 클래스를 작성하지 않고도 상태와 다른 React 기능을 사용할 수 있게 해줍니다. Hooks는 함수 컴포넌트에서 React 상태와 라이프사이클 기능에 \"갈고리를 걸어\" 사용하는 함수입니다. 클래스 내에서는 작동하지 않습니다.\n\nHooks는 하위 호환성이 있어서 기존의 React 개념을 대체하지 않고, 변경 사항이 없다는 것을 의미합니다.\n\n\n\n함수 컴포넌트를 작성한 후에 상태를 추가하고 싶을 때는 이전에는 클래스로 변환하여 작업했지만, 지금은 기존 함수 컴포넌트 내에서 Hook을 사용하여 할 수 있습니다.\n\nHook은 JavaScript 함수와 비슷하지만 사용할 때 두 가지 규칙을 따라야 합니다. Hook 규칙을 따르면 컴포넌트의 상태 논리가 해당 소스 코드에 보이도록할 수 있습니다. 이 규칙은 다음과 같습니다:\n\n- 반복문, 조건문 또는 중첩 함수 내에서 Hook을 호출하지 마십시오. React 함수의 최상위 수준에서만 Hook을 사용해야 합니다. 이 규칙은 Hook이 컴포넌트가 렌더링될 때마다 동일한 순서로 호출되도록 보장합니다.\n- 일반 JavaScript 함수에서 Hook을 호출할 수 없습니다. 대신 React 함수 컴포넌트에서 Hook을 호출해야 합니다. Hook은 맞춤 Hook에서도 호출할 수 있습니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_2.png\" />\n\n# 결론\n\n이제 ReactJs의 핵심 개념을 배웠습니다. 이를 기반으로 조금 더 발전시키고 싶다면, 힘내세요! Cheers!","ogImage":{"url":"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png"},"coverImage":"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png","tag":["Tech"],"readingTime":8},{"title":"이메일 보내기가 쉬워졌어요 Reactjs와 Nodemailer를 통합해보세요","description":"","date":"2024-05-14 10:43","slug":"2024-05-14-SendingEmailsMadeEasyIntegratingNodemailerwithReactjs","content":"\n\n<img src=\"/assets/img/2024-05-14-SendingEmailsMadeEasyIntegratingNodemailerwithReactjs_0.png\" />\n\n이메일 기능은 현재 대부분의 웹 애플리케이션의 중요한 부분입니다. 사용자들은 애플리케이션으로부터 이메일 확인, 알림, 영수증 등을 기대합니다.\n\nReact.js는 사용자 인터페이스를 구축하는 인기있는 JavaScript 라이브러리로, 기능이 풍부한 웹 앱을 개발하는 데 자주 사용됩니다. React.js 앱에서 강력한 이메일 기능을 활성화하려면 인기 있는 Node.js 이메일 전송 모듈인 Nodemailer를 신속하게 통합할 수 있습니다.\n\n이 포껠 한이 gu이 Nodemailer를 React.js와 통합하는 것을 안내해 React 구성 요소에서 바로 이메일을 보낼 수 있는 기능을 제공합니다.\n\n\n\nNodemailer에 대한 더 많은 정보를 확인하려면 이 안내서를 참조하세요: JavaScript 프레임워크와 Nodemailer 통합하기.\n\n마지막에는 다음을 이해할 것입니다:\n\n- Nodemailer 구성 및 작업하는 방법\n- Nodemailer를 사용하여 React 앱에서 이메일 보내기\n- 템플릿, 오류, 테스트 및 모범 사례 처리\n\n그럼 시작해봅시다!\n\n\n\n# React.js 소개\n\n2013년에 출시된 React.js(React)는 상호작용이 가능한 사용자 인터페이스를 구축하는 데 가장 인기 있는 JavaScript 라이브러리 중 하나로 등장했습니다. 페이스북과 개발자 커뮤니티에 의해 유지보수되는 React는 컴포넌트 개념을 중심으로 구축되어 있습니다.\n\n컴포넌트는 재사용 가능한 모듈식 UI 조각으로, 복잡한 UI를 구성하는 데 사용할 수 있습니다. React는 선언적 패러다임을 사용하여 일반적인 JavaScript와 비교하여 UI 로직 코딩을 간단하게 만듭니다.\n\n다른 주목할 만한 React 기능으로는 가상 DOM, 우수한 조정 알고리즘 성능, 통합 디버깅 개발 도구, 그리고 Node.js와 같은 프레임워크와의 쉬운 통합이 있습니다.\n\n\n\n이러한 기능의 조합으로 인해 React.js가 현재 현대적인 웹 애플리케이션을 만들기 위한 최상의 선택지로 떠오르면서, 넷플릭스, 에어비앤비, 우버이츠와 같은 대형 기업부터 작은 스타트업 앱까지 다양한 앱을 구동하고 있습니다.\n\n# React 애플리케이션 설정\n\n외부 라이브러리인 Nodemailer와 같은 라이브러리를 통합하기 전에 React 프로젝트를 준비해야 합니다. 새로운 React 앱을 만드는 것은 단 한 줄의 명령어로 간단히 할 수 있습니다:\n\n```js\nnpx create-react-app my-app\n```\n\n\n\n아래는 모두 빌드 구성 및 폴더 구조가 설정된 my-app이라는 React 프로젝트를 생성합니다:\n\n- Public — 이미지 및 index.html과 같은 정적 자산을 보관합니다\n- Src\n- JS 컴포넌트를 보관합니다\n- Index.js — 진입 파일\n- Package.json — 의존성을 나열합니다\n- 다양한 구성 파일들\n\n간단히 my-app으로 cd 명령어를 실행하고 npm start를 실행하여 핫 리로딩이 활성화된 개발 서버를 시작할 수 있습니다.\n\n앱이 성장함에 따라 App.js로 컴포넌트를 가져와 index.js를 사용하여 DOM에 렌더링합니다. 이제 앱에 이메일 기능을 추가할 준비가 완료되었습니다!\n\n\n\n# Nodemailer 소개 - Node.js 이메일 전송 라이브러리\n\nReact 앱에서 이메일을 보내려면 SMTP 및 기타 이메일 프로토콜을 원활하게 처리하는 강력한 라이브러리가 필요합니다.\n\n여기서 Nodemailer가 필요한데요 - Node.js 백엔드 코드에서 이메일을 보내는 데 가장 인기 있는 npm 패키지 중 하나입니다.\n\nNodemailer의 주요 기능 몇 가지:\n\n\n\n- SMTP, sendmail, mailgun 및 기타 전송 방식 지원\n- 텍스트, HTML 템플릿 및 첨부 파일을 포함한 이메일 전송\n- SMTP 서버를 위한 간편한 인증\n- 대량 이메일 발송 지원\n- 사용자 정의 스타일 옵션\n- 복잡한 이메일 로직 처리\n\n주간 다운로드 수가 1400만건을 넘는 Nodemailer는 Node 기반 백엔드에 전문적인 이메일 기능을 구축하는 도구로 선택되고 있습니다. 그리고 React와 API 호출을 통해 결합하면 프론트 엔드에서 이메일 기능을 활용할 수 있습니다!\n\n# React에서 Nodemailer 이메일 전송 통합\n\nReact 앱을 설정하고 Nodemailer 기본 사항을 이해한 후, 두 가지를 결합할 수 있습니다:\n아래는 워크플로우 내용입니다:\n\n\n\n- 사용자가 React 프런트엔드에서 이메일 양식 작성\n- 양식 데이터가 제출되면 Node+Express 백엔드로 전송\n- 백엔드에서 Nodemailer 모듈로 API 호출\n- Nodemailer가 이메일 발송 프로토콜을 처리\n- 사용자에게 성공 또는 실패 알림\n\n아래는이 흐름을 구현하는 자세한 단계입니다:\n\n- React에서 이메일 양식 구성요소 생성\n\nUI 양식은 수신자 주소, 제목, 이메일 본문과 같은 필수 세부 정보를 입력합니다.\n\n\n\n```js\n// EmailForm.js\n```\n\n```js\n    import { useState } from 'react'; \n    export default function EmailForm() {\n      const [to, setTo] = useState(\"\");  \n      const [subject, setSubject] = useState(\"\");\n      const [message, setMessage] = useState(\"\");\n      const handleSubmit = (e) => {\n        // Call API\n      };\n      return (\n        <form onSubmit={handleSubmit}>\n          <input \n            type=\"email\"\n            placeholder=\"To\"\n            value={to}\n            onChange={(e) => setTo(e.target.value)}  \n          />\n          <input\n            type=\"text\"\n            placeholder=\"Subject\"\n            value={subject}\n            onChange={(e) => setSubject(e.target.value)}  \n          />\n          <textarea \n            rows=\"3\"\n            placeholder=\"Message\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}  \n          ></textarea>\n          <button type=\"submit\">Send Email</button>\n        </form>\n      )\n    }\n```\n\n- Create Express + Nodemailer Backend\n\n백엔드에는 Express 서버가 필요하며 API 엔드포인트를 노출해야합니다. 필요한 패키지를 설치하세요:\n\n\n\n```js\nnpm install express nodemailer cors\n```\n\n엔드포인트 내에서 Nodemailer를 구성하고 이메일을 발송할 수 있습니다:\n\n```js\n// server.js\n```\n\n```js\n    const express = require(\"express\");\n    const nodemailer = require(\"nodemailer\");\n    const cors = require(\"cors\");\n    const app = express();\n    app.use(cors());\n    app.use(express.json());\n    const transporter = nodemailer.createTransport({\n      service: \"Gmail\", \n      auth: {\n        user: \"mygmail@gmail.com\",\n        pass: \"password\"\n      }\n    });\n    app.post(\"/api/send\", (req, res) => {\n      const mailOptions = {\n        from: req.body.from,\n        to: req.body.to,\n        subject: req.body.subject,\n        html: req.body.message\n      };\n      transporter.sendMail(mailOptions, (error, info) => {\n         if(error){\n           return res.status(500).send(error);\n         }\n         res.status(200).send(\"이메일이 성공적으로 전송되었습니다\");\n      });\n    });\n    const port = 3030;\n    app.listen(port, () => console.log(`서버가 포트 ${port}에서 실행 중입니다`));\n```\n\n\n\n- React Form을 API와 연결하기\n\naxios 또는 fetch를 사용하여 양식을 제출할 때 API를 호출합니다:\n\n```js\n// EmailForm.js\n```\n\n```js\n    import axios from \"axios\";\n    const handleSubmit = async (e) => {\n      e.preventDefault();\n      try {\n        await axios.post(\"/api/send\", {\n          from: \"my@email.com\",  \n          to,\n          subject,\n          message\n        });\n        alert(\"이메일이 전송되었습니다!\");\n      } catch(err) {\n        alert(err);\n      }\n    };\r\n```\n\n\n\n그것으로 통합이 완료되었습니다! 사용자는 React 프론트엔드와 Nodemailer 백엔드가 제공하는 이메일 알림을 받을 수 있습니다.\n\n# 고급 사용법과 모범 사례\n\n기본적인 내용은 간단하지만, 좀 더 복잡한 사용 사례는 확장성, 오류 처리, 그리고 최적화를 위한 계획이 필요합니다.\n\nReact에서 Nodemailer를 사용할 때 몇 가지 모범 사례:\n\n\n\n- 이메일 템플릿\n\n올바르게 포맷된 HTML 이메일을 보내는 것이 중요합니다. Nodemailer은 Handlebars, Pug, EJS 등 다양한 템플릿 엔진과 잘 작동하여 응답성이 좋고 매력적인 이메일 본문을 만들 수 있습니다.\n\n이메일에는 동적 매개변수가 포함될 수 있으므로 템플릿 생성 논리를 백엔드에 유지하면서 React 프론트엔드에서 사용자 정의를 허용하세요.\n\n- 대기열 및 대량 발송\n\n\n\n대량 이메일을 처리하는 데 큐를 사용하면 직접 발송보다 발신 가능성과 신뢰성이 향상됩니다.\n\nBeeQueue, Bull Queue, 또는 Agenda.js와 같은 솔루션은 배치 처리, 자동 재시도, 콜백 제공 등을 통해 수천 개의 이메일을 보낼 때 오류를 최소화하는 데 도움이 됩니다.\n\n- 캡차 및 스팸 방지\n\n스팸 가입 방지를 위해 이메일 양식 제출을 허용하기 전에 reCAPTCHA와 기타 확인 작업을 통합하세요. 속도 제한을 통해 이메일 엔드포인트 남용을 방지할 수도 있습니다.\n\n\n\n- 분석 및 통찰\n\n중요한 측정 항목을 추적하여 이메일 발송, 전송 상태, 웹훅 클릭 또는 콜백과 같은 정보를 얻으세요. 분석 소프트웨어를 통합하여 캠페인 성과를 시각화하세요.\n\n- 테스트 및 디버깅\n\n이메일 흐름을 관리하는 구성 요소를 철저히 테스트하세요.\n\n\n\n- 리액트 양식 유효성 검사 로직 단위 테스트\n- API 호출을 통한 통합 테스트\n- 이메일 발송 프로세스 로드 테스트\n- 요청 검사를 통한 문제 해결\n## 결론\n\n믿을만한 이메일 기능을 구현하는 데는 작업이 필요하지만 참여도를 높일 수 있습니다. 직관적인 UI를 위해 React를 결합하고 강력한 배송을 위해 Nodemailer를 사용하여 훌륭한 경험을 제공할 수 있습니다.\n\n이 가이드를 활용하여 기본 통합을 시작하고 필요에 맞게 최고의 실천 방법을 발전시키세요.\n\n사용 가능한 많은 가능성이 있습니다. 사용자 정의 스타일링, 고급 인증, A/B 테스트 이메일 및 인기 있는 라이브러리 통합 등이 있습니다. 이메일 기능을 활용하여 React 편안 영역을 넓히는 동안 다음 웹 앱을 업그레이드할 수 있습니다.\n\n\n\n만약 이 포스트가 흥미롭다면, Learnhub 블로그에서 이와 같은 흥미로운 포스트를 더 찾아보세요! 우리는 클라우드 컴퓨팅부터 프론트엔드 개발, 사이버 보안, AI 및 블록체인까지 모든 기술에 대해 다룹니다.\n\n# 자료\n\n- NodeMailer 초급 가이드\n- NodeMailer로 이메일 보내는 방법\n- JavaScript 이메일 프레임워크 4가지\n- Node 문서","ogImage":{"url":"/assets/img/2024-05-14-SendingEmailsMadeEasyIntegratingNodemailerwithReactjs_0.png"},"coverImage":"/assets/img/2024-05-14-SendingEmailsMadeEasyIntegratingNodemailerwithReactjs_0.png","tag":["Tech"],"readingTime":7},{"title":"ReactJS 앱을 GraphQL 미들웨어와 NodeJS-MongoDB 백엔드로 구축하기","description":"","date":"2024-05-14 10:38","slug":"2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend","content":"\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_0.png\" />\n\n가끔 옛날을 그리곤 합니다. 2006년이었던 그 때, 믿을만한 웹사이트를 만드는 가장 좋은 해결책은 HTML, CSS, 때로는 가끔씩 JS만 있었죠. 그 해에 고등학교에서 배운 것과 정확히 일치합니다. 혹시 당시에는 인터넷 서비스를 사용하는 것이 현재처럼 쉽지 않았거나 기술이 아직 그에 미쳐하지 않아 항상 연결된 세상에서 얻을 수 있는 웹사이트의 장점을 활용할 수 없었기 때문인가요.\n\n하지만 웹사이트를 호스팅하는 기술은 개선되고, 웹 앱도 변화합니다. FTP나 버전 관리 없이 일하는 시대는 이미 지나갔으며, 이제 웹 응용 프로그램이 최신 코딩 관행을 준수하고 일반 Javascript 이상의 개발 작업을 촉진하는 것이 이전보다 더 중요합니다. 네, 더 복잡해지긴 했지만, 신기술의 세계는 더 나은 소프트웨어를 만들기 위해 기술을 활용할 수 있는 여러 가지 방법을 제시합니다! 그러나 ReactJS나 AngularJS 같은 프레임워크는 개발 환경에서 효과적으로 작업할 수 있지만, 어플리케이션 내에서 복잡한 상태/데이터 변경을 유지하기 위해서는 정적 코드가 아닌 것이 필요합니다. 이를 위해서 우리가 잘 알고 있는 Filezilla 같은 오래된 도구는 거의 사용되지 않게 되었습니다!\n\n그럼에도 불구하고, 이러한 정적 웹사이트는 여전히 존재합니다. Github Pages 같은 무료 서비스를 통해 프로젝트 빌드를 호스팅하고 브라우저에서 액세스할 수 있습니다. 다만 다른 애플리케이션과의 통신 없이 상태/데이터가 변경되는 것을 보장하는 복잡한 소프트웨어 개발 주기가 관련되어 있지 않다면요. 이러한 무료 서비스의 존재로 취미로 하는 사람들과 개발자들이 과거 기술을 사용하여 스스로 컨텐츠를 온라인에 호스팅할 수 있습니다. HTML, CSS 그리고 JS 파일은 여전히 잘 동작하지만, 언급한 프레임워크를 고려할 때 이러한 장점은 제한됩니다. 물론 AWS, Azure, Heroku와 같은 선도적인 클라우드 호스팅 서비스는 저렴한 호스팅 경험을 제공합니다. 그러나 이러한 서비스의 설정과 구성을 소홀히 한다면, 언제든지 트래픽이 있는지 없는지 애플리케이션을 호스팅하는데 사용되는 컨테이너가 호스팅 비용을 발생시킬 수 있는 소득 미니 진공청소기가 될 수 있습니다.\n\n\n\n이젠 온라인으로 제공되는 서비스들이 있어요. 적절하게 활용하면 아마추어, 초보자, 그리고 작은 비즈니스들에게 유용한 개발 작업이 될 수 있는 겁니다. Vercel과 같은 서비스를 통해 여러 서버리스 애플리케이션을 호스팅할 수 있어요. 이는 애플리케이션을 쉽게 준비하고 배포할 수 있어서 복잡함에 대해 걱정하지 않고 작동시킬 수 있어요.\n\n이 튜토리얼은 소프트웨어 개발 생명주기에 대해 더 완벽한 경험을 제공하기 위한 것이에요. 구성할 분산 시스템의 기본을 다룰 거에요: ReactJS 프론트엔드 앱이 GraphQl 미들웨어에 연결되며, 미들웨어는 다시 백엔드로 NodeJS 익스프레스 앱이나 MongoDB 데이터베이스에 연결하는 서비가 될 거에요. 모두 무료로 호스팅될 거에요.\n\n## 설정\n\n우선 https://github.com/signup 에서 깃허브 계정이 있어야 해요.\n\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_1.png)\n\n계정을 설정했다면 https://github.com/new에서 적어도 한 개의 저장소를 만들 수 있어야 합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_2.png)\n\n이 튜토리얼에서는 ReactJS와 NodeJS를 사용할 것이며 프로젝트용 .gitignore를 만들고 싶다면 아무런 경우에나 나중에 각 앱에 추가할 것입니다!\n이 튜토리얼에서는 다음과 같이 저장소를 만들었습니다:\n\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_3.png\" />\n\n그러면, 재미있는 부분이 시작됐습니다!\n\n## 보일러플레이트 설정\n\n우선, 만든 저장소를 복제하거나 해당 저장소와 동일한 이름의 폴더 안에서 다음 단계를 따라주세요:\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_4.png\" />\n\n첫 번째 커밋을 푸시하거나 계속 진행하세요. 다음으로 터미널을 열고 npm init을 실행해야 합니다. 이렇게 하면 package.json 파일이 생성됩니다. 지금은 다음과 같이 보일 것입니다:\n\n```js\n{\n  \"name\": \"react-graphql-node-mongo-boilerplate\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n} \n```\n\n이게 왜 중요한가요? 이 보일러플레이트에서는 모든 어플리케이션을 함께 모아놓는 데 초점을 맞추었는데, 이 package.json은 그 모든 것을 제어하는 데 유용할 것입니다. 그러나 이 보일러플레이트의 각 부분(프론트엔드, 미들웨어, 백엔드)을 별도의 저장소에 넣는 데 제한이 있으면 안 될 것입니다.\n\n\n\n어쨌든, 프로젝트 구조는 다음과 같이 보이면 충분히 좋을 것입니다:\n\n![프로젝트 구조](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_5.png)\n\n코드를 깃허브 저장소에 푸시해 보세요.\n\n## 프론트엔드\n\n\n\n아래 명령어를 실행해 주세요:\n\n```js\nnpx create-react-app frontend --template typescript\n```\n\n이 명령어를 실행하면 frontend에 TypeScript 템플릿을 이용한 ReactJS 앱이 생성됩니다. 작업이 완료되면 프로젝트 구조는 다음과 같아요:\n\n![프로젝트 구조](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_6.png)\n\n\n\n만약 npm start를 실행하면 브라우저에서 앱이 이렇게 나타날 것입니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_7.png)\n\n보일러플레이트/프론트엔드 통합\n\n다음으로, 보일러플레이트에 대해 말씀드리겠습니다. 프론트엔드 앱을 폴더 외부에서 호출했을 때도 실행할 수 있도록 보장할 거에요. 메인 package.json을 다음과 같이 변경하세요:\n\n\n\n```js\n{\n  \"name\": \"react-graphql-node-mongo-boilerplate\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start-fe\": \"npm run --prefix ./frontend start\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\n참고: 테스트가 중요하지 않다는 것은 아닙니다. 그러나 이 튜토리얼을 좀 더 간략하게 유지하기 위해 테스트는 포함하지 않았습니다.\n\n어쨌든, 이제 start-fe 스크립트가 있다는 것을 알 수 있습니다. --prefix 플래그를 사용하면 내부 디렉토리에서 명령을 실행할 수 있습니다. 이를 통해 전체 위치에서 프론트엔드 앱을 실행할 수 있게 됩니다. 이것은 결국 미들웨어와 백엔드를 동일한 위치와 동시에 실행할 수 있어야 한다는 의미입니다.\n\n## Frontend Vercel 통합\n\n\n\n이제 적어도 하나 이상의 앱이 있으므로 Vercel을 무료 호스팅 도구로 활용할 수 있도록 배포를 시작할 수 있습니다. 이를 위해 Vercel에서 계정을 만들어야 합니다.https://vercel.com/signup .\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_8.png)\n\n계정을 만들었다면 새 프로젝트를 만들 수 있어야 합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_9.png)\n\n\n\n해당하는 git 저장소를 가져올 수 있어야합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_10.png)\n\n작업 중인 저장소를 선택한 후, 이 프로젝트에 이름을 지정하고 프레임워크 및 루트 디렉토리를 선택할 수 있어야합니다. 단일 저장소에 모든 앱을 가질 수 있도록 허용되기 때문에 매우 유용합니다. 혹시 모노 레포라고 부르는 것 같아요:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_11.png)\n\n\n\n작업을 마치면 배포 버튼을 클릭하세요. 그러면 이와 유사한 화면을 볼 수 있을 거에요:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_12.png)\n\nVisit을 클릭하면 온라인으로 무료로 배포된 ReactJS 앱을 볼 수 있을 거에요!\n\n레포를 연결하고 Vercel에 배포하는 데의 장점은 이제 코드를 쉽게 게시할 수 있다는 것이죠. 코드가 푸시될 때마다 Vercel 프로젝트는 변경 사항을 인식하고 새로운 배포를 준비할 거에요.\n\n\n\n## 미들웨어\n\n이제 다른 애플리케이션을 생성할 차례입니다. 이 미들웨어는 일종의 경비병 역할을 하는 중개자로, 프론트엔드와 백엔드의 서비스 사이의 요청 통신을 라우팅할 수 있는 기능을 제공합니다 (비록 이 튜토리얼에서는 하나의 서비스만 구현하겠지만요).\n\n최상위 디렉토리에서 middleware라는 폴더를 생성합니다. 해당 폴더 안에서 npm init -y 명령을 실행합니다. 이렇게 하면 GraphQL과 Vercel을 함께 실행할 수 있도록 기본 프로젝트가 생성됩니다.\n\nmiddleware 폴더 안에 api 폴더를 만듭니다. 그 안에 server.js라는 파일을 만듭니다. 이 파일은 GraphQL과 Vercel을 설정하는 주요 부분이 구현될 곳입니다. 다음 코드를 추가하세요:\n\n\n\n```js\nconst express = require('express');\nconst { ApolloServer } = require('apollo-server-express');\nconst { createServer } = require('http');\nconst cors = require('cors');\n\nconst isDev = process.env.MIDDLEWARE_ENV === 'dev';\n\nconst typeDefs = gql`\ntype Query {\n    hello: String\n}\n`;\n\nconst resolvers = {\n    Query: {\n        hello: () => 'Hello world!',\n    },\n};\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  introspection: isDev,\n  playground: isDev\n});\nconst app = express();\napp.use(cors());\n\nasync function startServer() {\n  await server.start();\n  server.applyMiddleware({ app });\n\n  // Only listen on HTTP port in local development, not when deployed on Vercel\n  if (!process.env.VERCEL) {\n    const PORT = process.env.PORT || 4000;\n    app.listen(PORT, () => console.log(`💫 Server ready at http://localhost:${PORT}/graphql`));\n  }\n}\n\nstartServer();\nconst requestHandler = app;\nconst vercelServer = createServer((req, res) => requestHandler(req, res));\nmodule.exports = vercelServer;\n```\n\n현재는 백엔드에서 서비스 호출로부터 반환되는 데이터 구조를 해결하는 함수인 resolvers와 백엔드 서비스로의 호출 스키마를 지정하는 것인 typeDefs의 매우 간단한 구현을 사용 중입니다. 배포된 인스턴스에서 이를 수행하면 데이터 스키마가 노출되어도 훨씬 더 안전하지 않을 수 있으므로 개발 환경에서만 인트로스펙션 쿼리를 실행하고 플레이그라운드를 볼 수 있도록 허용합니다.\n\n여기서 개발 환경에 있는지 확인하기 위해 process.env.MIDDLEWARE_ENV를 사용합니다. 이는 실행 중에 사용할 환경을 지정할 수 있어야 한다는 것을 의미합니다. 우리가 dev 환경에서 플레이그라운드를 사용하고 싶기 때문에 npm start를 실행할 때 환경 변수로 사용할 MIDDLEWARE_ENV를 포함하고 싶을 것입니다. NodeJS에서 이를 달성하는 간단한 방법 중 하나는 middleware 폴더 내에 .env 파일을 생성하는 것입니다. 파일은 아래와 같이 보여야 합니다:\n\n```js\nMIDDLEWARE_ENV=dev\n```\n\n\n\n그리고 이제 이 변수를 사용할 수 있어야 합니다. 그냥 .env 파일을 추가했다고 해서 앱이 자동으로 그것을 사용한다고는 알 수 없습니다. 따라서 dotenv 패키지를 설치할 수 있습니다. 그런데 우리가 server.js에서 사용하는 패키지들도 함께 설치해 봅시다! 다음을 실행해 주세요:\n\n```js\nnpm i @vercel/node apollo-server-express dotenv express graphql\n```\n\n@vercel/node를 왜 사용해야 하냐구요? Vercel에 이 앱을 배포할 것이기 때문입니다. 왜냐하면 어째선지 Vercel은 NodeJS 프레임워크 프리셋을 포함하지 않기 때문입니다 :( 이를 위해 middleware 폴더 안에 vercel.json 파일을 생성하세요:\n\n```js\n{\n  \"version\": 2,\n  \"routes\": [\n    {\n      \"src\": \"/graphql\",\n      \"dest\": \"/api/server.js\"\n    },\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/api/server.js\"\n    }\n  ]\n}\n```\n\n\n\n여기서 우리는 어떤 경로든 서버.js를 거쳐야 하며, 프론트엔드에서의 GraphQL 호출(/graphql 경로)이 동일한 위치로 이동한다는 것을 나타냅니다.\n\n이제 로컬에서 실행하려면 package.json을 수정하여 start 명령을 포함해야 합니다:\n\n```js\n\"start\": \"node -r dotenv/config api/server.js\"\n```\n\nnpm start를 실행한 후 http://localhost:4000/graphql로 이동하여 다음을 볼 수 있어야 합니다:\n\n\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n\n\n하지만 이제 우리가 작동시킨 것을 리포에 푸쉬해야 할까요? 이제 .env 파일이 있으니까요. 이 파일에 중요한 정보(주소, 키 등)가 저장되어 있다면, 리포나 이를 의존하는 어플리케이션에 보안 문제가 발생할 수 있습니다. 이제 이 특정 파일을 푸쉬하지 않도록 무시할 수 있도록 하고 싶으므로, 미들웨어 폴더 안에 .gitignore 파일을 추가할 시간입니다. 아래와 같이 추가하세요:\n\n그러나 node_modules와 .env만 추가하면 되지만, 이것은 여러 종류의 프로젝트에 사용할 gitignore 파일 모음을 보유하는 이런 리포에서 얻을 수 있는 종합적인 파일입니다.\n\n하지만 이제, 이런 프로젝트를 완료하고 얼마 후에도 작업을 계속하지 않게 된다면 어떻게 될까요? 코드가 이렇게 남게 되면 사용되는 환경 변수가 무엇인지 기억하지 못할 수 있습니다. 항상 코드 편집기에서 확인할 수 있지만, 그건 별로 필요한 작업이 아닐 수 있습니다. 미래의 자신이나 귀하의 리포를 포크하려는 누군가에게 암시할 수 있는 방법은 .env.sample 파일을 만드는 것입니다. 이 파일은 환경 변수 이름만 포함합니다:\n\n\n\n```js\nMIDDLEWARE_ENV=\n```\n\n물론, 여기에 민감한 정보가 저장되지 않도록 주의를 기울이는 것이 당신의 책임입니다. 이 미들웨어 설정이 끝난 후에는 미들웨어 폴더 구조가 다음과 같아야 합니다:\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_15.png\" />\n\n## 보일러플레이트/미들웨어 통합\n\n\n\n계속해서 보일러플레이트 프로세스를 이어가려고 합니다. 미들웨어 앱을 외부에서 실행할 수 있도록 하려면 concurrently 패키지가 필요합니다. 미들웨어 폴더 외부에서 다음을 실행해주세요:\n\n```js\nnpm i concurrently -D\n```\n\n이 명령을 통해 한 번에 여러 앱을 실행해야 하기 때문에 개발 종속성으로 패키지가 설치됩니다. 다음으로 두 가지 스크립트를 추가해야 합니다:\n\n```js\n\"start:mw\": \"npm run --prefix ./middleware start\",\n\"start\": \"concurrently \\\"npm run start:fe\\\" \\\"npm run start:mw\\\"\"\n```\n\n\n\n위에 언급된 내용대로 하면, 우리가 미들웨어를 프로젝트 외부에서만 실행하고 싶을 때에는 start:mw를 실행합니다. 새로운 start 명령어는 새로 설치한 concurrently 패키지를 사용하여 start:fe와 start:mw 명령어를 동시에 실행합니다.\n\n하지만 이제 한 개의 패키지가 있기 때문에 package-lock.json 파일과 node_modules 폴더가 생길 것입니다. 파일은 사용할 수 있지만 폴더는 사용하지 않을 거에요. 다음과 같은 .gitignore 파일을 간단히 추가해주세요:\n\n```js\n/node_modules\n```\n\n그러면 레포지토리에 설치된 파일들을 푸시하지 않도록 합니다. 이제 보일러플레이트 구조는 아래와 같을 것입니다:\n\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_16.png)\n\n### 미들웨어 Vercel 통합\n\n이제 Vercel에서 다른 프로젝트를 만들 수 있어야 합니다. 동일한 저장소를 선택하고 이름을 지정하되 Root Directory에서 미들웨어 폴더를 선택하십시오. 이제 두 개의 프로젝트가 배포되어 있어야 합니다!\n\n### 데이터베이스\n\n\n\n\n자, 이제 우리는 무료 NoSQL 데이터베이스를 호스팅하기 위해 MongoDB 계정을 생성할 거에요. 먼저 https://account.mongodb.com/account/register에 접속해서 양식을 채워주세요.\n\n![MongoDB Registration](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_17.png)\n\n양식을 채웠으면, 이 MongoDB 간단 튜토리얼을 따라해보세요:\n- 조직 생성\n- 프로젝트 생성\n- 클러스터 생성\n\n\n\n그러나 클러스터를 만들 때 M0 공유 클러스터 배포를 선택해야 합니다:\n\n![image](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_18.png)\n\n이를 통해 데이터베이스가 무료 공간에 호스팅됨이 보장됩니다. 물론, 상당한 트래픽이나 사용자가 예상되어 많은 저장 공간이 필요한 경우에는 다른 배포 템플릿을 사용하는 것이 좋습니다. 마지막으로, 배포 생성을 클릭하세요.\n\n이 작업을 완료한 후, 왼쪽 메뉴의 Database 옵션으로 이동하여 Browse Collections 버튼을 클릭하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_19.png\" />\n\n한 번 들어오면 샘플 데이터 세트를 추가하여 작업을 시작하거나 본인의 데이터를 추가할 수 있습니다:\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_20.png\" />\n\n데이터베이스 이름과 컬렉션 이름을 작성한 다음 '생성'을 클릭하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_21.png\" />\n\n다음으로, 문서를 삽입할 버튼을 찾아 클릭하세요. 모달에서,\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_22.png\" />\n\n다음 데이터를 추가하세요:\n\n\n\n```js\n[\n  {\"userId\": 1, \"name\": \"Andrew\"},\n  {\"userId\": 2, \"name\": \"Bob\"},\n  {\"userId\": 3, \"name\": \"Charles\"},\n  {\"userId\": 4, \"name\": \"Damian\"}\n]\n```\n\n물론, 데이터베이스 계정, 컬렉션 사용자, 데이터는 모두 테스트 목적으로 제공됩니다. 프로젝트에서는 필요한 데이터를 자유롭게 사용할 수 있습니다. 작업이 완료되면 왼쪽 메뉴에서 \"데이터베이스 액세스\"를 클릭하십시오.\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_23.png\" />\n\n이렇게 하면 백엔드에서 데이터베이스 액세스를 처리할 사용자인 새 데이터베이스 사용자를 추가할 수 있습니다. 버튼을 클릭한 후 사용자 이름과 비밀번호를 입력한 다음 역할을 선택하려면 아래로 스크롤하세요. 읽기 및 쓰기가 충분합니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_24.png\" />\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_25.png\" />\n\n마지막으로, '사용자 추가'를 클릭해주세요.\n\n## 백엔드\n\n\n\n코드로 돌아가기 전에 MongoDB에서 왼쪽 메뉴에서 '데이터베이스'로 이동한 다음 '연결'을 클릭해주세요:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_26.png)\n\n그다음 '드라이버'를 클릭하고 '드라이버'에서 Node.js를 선택해주세요. 최신 버전을 선택하면 됩니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_27.png)\n\n\n\n언급했듯이, 백엔드에는 mongodb 패키지가 필요합니다. 또한 아래 형식을 따르는 연결 문자열을 메모해주세요:\n\n```js\nmongodb+srv://<db-user>:<db-password>@<cluster-url>?retryWrites=true&w=majority&appName=<app-name>\n```\n\n이를 염두에 두고 저장소로 돌아가봅시다. 루트 수준에서 backend라는 폴더를 만들고 그 안에서 npm init -y를 실행하세요. 이렇게 하면 간단한 NodeJS 앱이 생성됩니다. 또한 안에 index.js 파일을 만들어 아래와 같이 작성해주세요:\n\n```js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst testRouter = require('./routes/testRoutes');\nconst connectToDb = require('./configs/db.config');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(cors({ credentials: true, origin: '*' }));\n\napp.get('/', (req, res) => {\n  res.send('Hello from the NodeJS backend!');\n});\n\napp.use('/test', testRouter.getUsers);\n\nasync function startServer() {\n  const port = process.env.PORT || 5000;\n  app.listen({ port }, () =>\n    console.log(`✨ Server ready at http://localhost:${port}`)\n  );\n  connectToDb();\n}\n\nstartServer();\n```\n\n\n\n프로젝트에서 요청을 처리하고 백엔드 서비스 내에서 특정 기능으로 라우팅하는 데 사용할 express는 RESTful 기능을 활용하여 데이터베이스와 상호 작용하기 위해 앱에 통합됩니다. body-parser는 앱에 통합된 경우 요청 경로로 JSON 데이터를 보내면 이를 올바르게 이해하도록합니다. cors는 도메인에 상관없이 모든 도메인의 교차 출처 요청을 허용하는 데 사용됩니다. testRouter와 connectToDb는 나중에 보여줄 코드에서 가져온 것입니다.\n\n간단히 말하면, index.js의 역할은 기본 포트 5000에서 연결을 설정하고 데이터베이스 연결을 설정하며 두 가지 별도의 요청을 처리하는 것입니다: 하나는 간단한 hello-world 스타일 텍스트를 표시하는 /로의 요청이고, 다른 하나는 데이터베이스에서 사용자를 가져 오는 /test로의 요청입니다. 이를 실제로 보려면 다음 명령을 실행하십시오:\n\n```js\nnpm i body-parser cors dotenv express mongodb\n```\n\n다음으로, 스크립트를 다음과 같이 수정하십시오:\n\n\n\n```js\n\"start\": \"node -r dotenv/config index.js\"\n```\n\n프로그램을 실행할 수 있어야 합니다. 그러나 dotenv을 사용하므로 index.js에서 process.env를 사용하므로 환경 변수를 설정해야 합니다. 다음과 같이 보이는 .env.sample 파일을 만드세요:\n\n```js\nPORT=\nDB_USER=\nDB_PASSWORD=\nDB_CLUSTER_URL=\nDB_APP_NAME=\nDB_NAME=\nDB_COLLECTION=\n```\n\n이러한 변수가 모두 연결 문자열에서 가져오는 변수여야 하며, 포트를 제외한 모든 변수를 채워넣어야 합니다. 포트는 미들웨어나 프론트엔드에 사용된 것과 중복되지 않는 한 5000 또는 다른 값이어야 합니다. 이제 .gitignore를 추가하십시오. 미들웨어에서 사용된 것과 유사하거나 node_modules와 .env를 언급하는 한 사용할 수 있습니다.\n\n\n\n위 내용을 실제로 보고 싶다면 index.js에서 testRouter와 connectToDb에 언급된 라인들, 그리고 /test route를 주석 처리해보세요. npm start를 실행하면 브라우저에서 다음과 같은 내용을 확인할 수 있을 거에요:\n\n![image](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_28.png)\n\n그래서 적어도 텍스트 요청이 작동하는지 확인할 수 있어요! 이제 db 요청을 실행해보겠습니다. 위의 코드를 테스트했다면 index.js의 코드를 주석 처리하고 다음 두 개 폴더를 만드세요:\n\n- 폴더 configs: 내부에 다음과 같은 내용이 들어 있는 db.config.js 파일을 만들어보세요:\n\n\n\n```js\nconst { MongoClient } = require('mongodb');\nconst uri = `mongodb+srv://${process.env.DB_USER}:` +\n            `${process.env.DB_PASSWORD}@${process.env.DB_CLUSTER_URL}/` +\n            `?retryWrites=true&w=majority&appName=${process.env.DB_APP_NAME}`;\nconst client = new MongoClient(uri);\n\nlet database;\n\nconst connectToDb = async () => {\n  if (database) {\n    return database;\n  }\n  try {\n    await client.connect();\n    console.log('📘 Connected to MongoDB');\n    database = client.db(process.env.DB_NAME);\n    return database;\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nmodule.exports = connectToDb;\n```\n\n요렇게, 이제 connectToDb를 호출할 때 (예를 들어 인덱스 파일에서), 우리의 MongoDB 데이터베이스에 연결합니다. if(database) 블록은 connectToDb를 호출해도, 이미 연결이 시작된 경우 다시 연결하는 대신 해당 연결을 사용할 수 있도록 합니다.\n\n2. 폴더 routes: 내부에 testRoutes.js라는 파일을 만들어 사용자와 관련된 모든 호출을 보관합니다. 다음을 작성하세요:\n\n```js\nconst connectToDb = require('../configs/db.config');\n\nconst getUsers = async (req, res) => {\n  try {\n    let db = await connectToDb();\n    const collection = db.collection(process.env.DB_COLLECTION);\n    const data = await collection.find({}).toArray();\n    res.send({\n      message: '그리고 백엔드도!',\n      data\n    });\n  } catch (error) {\n    console.error('데이터베이스에 액세스하는 중 오류 발생', error);\n    res.status(500).send('데이터 검색에 실패했습니다');\n  }\n};\n\nmodule.exports = {\n  getUsers,\n};\n```\n\n\n\n이전 파일에서 언급한 대로, connectToDb는 여기에서도 쉽게 재사용할 수 있습니다. 다시 연결할 위험이 없습니다. 그러나 이제 이 파일에서는 getUsers를 호출할 때(/test route in index.js에 있는 것과 같이) 환경 변수에서 정의된 컬렉션을 가져와 배열로 변환한 다음 결과를 보내게 됩니다. 간단하게 하기 위해 이 강좌에서는 모든 사용자를 가져오는 방법만 언급할 것입니다. 그러나 이러한 것들을 사용하여 각종 CRUD 작업을 쉽게 구현할 수 있습니다. 연습 삼아 데이터 처리와 조회 방법을 익히실 수 있습니다.\n\n```js\nconst collection = db.collection('users');\n\n// 모두 가져오기\nawait collection.find().toArray();\n\n// 하나 가져오기 (예를 들어, 이름으로 가져오기)\nawait collection.findOne({ name: 'Charles' });\n\n// 하나 생성하기\nawait collection.insertOne({ userId: '5', name: 'Eric' });\n\n// 다수 생성하기\nawait collection.insertMany([\n  { userId: 5, name: 'Ethan' },\n  { userId: 6, name: 'Felix' }\n]);\n\n// 하나 업데이트하기\nawait collection.updateOne({ userId: '5' }, { $set: { name: 'Ethan' } });\n\n// 하나 삭제하기\nawait collection.deleteOne({ userId: '5' });\n\n// userId가 3 미만인 모든 항목 가져오기\nawait collection.find({ userId: { $lt: 3 } }).toArray();\n\n// userId가 [2,3] 리스트에 있는 사용자 이름에 '*' 추가하기\nawait collection.updateMany(\n  { userId: { $in: [2, 3] } },\n  { $set: { name: { $concat: ['$name', '*'] } } }\n);\n\n// userId가 홀수인 모든 항목 삭제하기\nawait collection.deleteMany({ userId: { $mod: [2, 1] } });\n```\n\n이러한 내용을 더 자세히 알아보려면 아주 유용한 Operand 목록을 이곳에서 찾을 수 있습니다: https://www.mongodb.com/docs/manual/reference/operator/query/ 여기서 데이터 처리를 필요로 할 때 데이터를 조작하는 데 도움이 될 것입니다. 어쨌든, 세 파일의 코드가 모두 완성되었으므로 이제 로컬에서 MongoDB를 쿼리할 수 있습니다. 백엔드를 다시 실행하고 브라우저에서 /test로 이동하면 아마도 다음과 같이 보일 것입니다:\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_29.png\" />\n\n\n\n베르셀과 통합해야 하니, 백엔드 폴더 안에 vercel.json을 추가해주세요:\n\n```js\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    }\n  ]\n}\n```\n\n마지막으로, 루트 package.json으로 가서 새로운 스크립트를 추가하고 start 스크립트를 업데이트해주세요:\n\n```js\n\"start:be\": \"npm run --prefix ./backend start\"\n\n\"start\": \"concurrently \\\"npm run start:fe\\\" \\\"npm run start:mw\\\" \\\"npm run start:be\\\"\"\n```\n\n\n\n이로써, boilerplate에서 프론트엔드, 미들웨어 및 백엔드 앱을 함께 실행할 수 있게 됩니다. 이를 통해 백엔드 앱은 이 boilerplate의 목적을 위해 완료되었습니다. 그것에 대한 폴더 구조는 다음과 같아야 합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_30.png)\n\n## 백엔드 Vercel 통합\n\n코드를 푸시한 후, Vercel에서 다른 프로젝트를 생성하고, boilerplate 리포를 선택하여 이름을 지정하며, root 디렉토리에서는 백엔드 폴더를 선택합니다. 프로젝트가 환경 변수를 사용하기 때문에 프로젝트가 작동하지 않을 것임을 유념하십시오. Vercel은 프로젝트에 환경 변수를 추가할 수 있는 옵션을 제공하지만, 이를 고려하도록 한 번 다시 배포하여야 합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_31.png)\n\n몽고디비 데이터베이스를 위해 사용 중인 모든 환경 변수를 추가하고 프로젝트를 다시 배포해야 합니다.\n\n그러나 아직 끝나지 않았어요! `/test` 페이지로 이동하면 페이지에 이런 내용이 나타날 수 있습니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_32.png)\n\n\n\n이 게이트웨이 시간 초과 오류는 단순히 백엔드 배포의 IP 주소가 데이터베이스에 액세스할 권한이 없다는 것을 의미합니다. 해결하기 위해 프로젝트에 MongoDBAtlas 통합을 추가하면 됩니다. 이 경우 백엔드 프로젝트는 여기에 있습니다: https://vercel.com/integrations/mongodbatlas. 이 과정은 비교적 직관적이며 클러스터를 선택할 수 있어야 합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_33.png)\n\n이 작업을 통해 최종적으로 하는 일은 MongoDB 왼쪽 메뉴의 데이터베이스 액세스에서 찾을 수 있는 사용자를 만드는 것이며, 이 사용자는 백엔드에서의 요청을 처리하기 위해 해당 IP를 화이트리스트에 추가합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_34.png)\n\n\n\n바이노 희석 고 내부 값에 대한 SQLite 데이터베이스에서 임베드 된 데이터를 가지고 있습니다. 이 데이터를 포함된 SQL 질의 명령문으로 SELECT하려면 다른 단일값 또는 여러 행 및 열을 반환하는 SQL 함수를 사용하시면 됩니다.\n\n\n\nresolvers 폴더에는 모든 리졸버가 저장될 것입니다. 이들은 백엔드/서비스 호출에서 나오는 데이터를 수정할 수 있는 함수들로, 프론트엔드로 다시 전송하기 전에 준비됩니다. 또한 data-sources 폴더에는 모든 데이터 소스가 저장될 것입니다. 이들은 리졸버에서 받은 데이터를 사용하여 외부 호출(예: 백엔드로)을 수행하는 함수로, 실패 시에는 즉시 반환하거나 예비 동작을 수행합니다.\n\nresolvers 폴더는 test라는 단일 폴더를 가지고 있으며, test.js 파일이 있습니다.\n\n```js\nconst { gql } = require('apollo-server-express');\nconst TestDataSource = require('../../data-sources/test/test.js');\n\nconst testTypeDefs = gql`\ntype UserData {\n  name: String\n  userId: String\n}\ntype Response {\n  message: String\n  data: [UserData]\n}\ntype Query {\n  test: Response\n}\n`;\n\nconst buildTestResponse = (response) => {\n  return {\n    message: `FE integrated successfully with Middleware! ${response.message}`,\n    data: response.data\n  };\n}\n\nconst testResolvers = {\n  Query: {\n    test: async () => {\n      const response = await TestDataSource.test();\n      return buildTestResponse(response);\n    },\n  },\n};\n\nmodule.exports = { testTypeDefs, testResolvers };\n```\n\n여기서 testResolvers는 리졸버로 사용할 모든 함수가 정의되어 있습니다. 데이터 소스 함수 호출을 하고, 데이터를 정리하여 buildTestResponse를 사용하여 프론트엔드로 다시 전송합니다. 또한 testTypeDefs는 사용할 모든 쿼리(이 프로젝트에서는 하나뿐)를 보유하고 응답 유형을 정의합니다. 이로써 우리는 미들웨어를 통해 다양한 쿼리나 변이가 어떤 것인지를 playground에서 확인할 수 있습니다. 이를 통해 프론트 엔드에서 올바른 인수를 사용하여 쿼리 호출을 준비하는 것을 보장합니다.\n\n\n\n```js\nconst axios = require('axios');\n\nclass TestDataSource {\n  static async test() {\n    try {\n      const response = await axios.get(`${process.env.BACKEND_URL}/test`);\n      return response.data;\n    } catch (error) {\n      console.error('백엔드에서 데이터를 가져오기 실패했습니다:', error);\n      return '데이터 가져오기 실패';\n    }\n  }\n}\n\nmodule.exports = TestDataSource;\n```\n\n이 데이터 소스 함수는 axios에 의존하여 백엔드에 요청을 보내고 받은 데이터를 간단히 반환하는 간단한 함수입니다. 이를 필요에 따라 처리할 수 있도록 하겠습니다. 그러므로 axios 패키지를 미들웨어 앱에 추가하기 위해 npm i axios를 실행해야 합니다.\n\n다음으로, api/server.js 파일을 다음과 같이 업데이트해야 합니다. 기본적으로 더미 typedef 및 리졸버를 생성한 것으로 대체합니다.\n\n\n\n```js\nconst express = require('express');\nconst { ApolloServer } = require('apollo-server-express');\nconst { createServer } = require('http');\nconst cors = require('cors');\nconst { testTypeDefs, testResolvers } = require('../src/graphql/resolvers/test/test.js');\n\nconst isDev = process.env.MIDDLEWARE_ENV === 'dev';\n\nconst server = new ApolloServer({\n  typeDefs: [testTypeDefs],\n  resolvers: [testResolvers],\n  introspection: isDev,\n  playground: isDev\n});\n\nconst app = express();\napp.use(cors());\n\nasync function startServer() {\n  await server.start();\n  server.applyMiddleware({ app });\n\n  // Only listen on HTTP port in local development, not when deployed on Vercel\n  if (!process.env.VERCEL) {\n    const PORT = process.env.PORT || 4000;\n    app.listen(PORT, () => console.log(`💫 서버가 http://localhost:${PORT}/graphql 에 준비되었습니다`));\n  }\n}\n\nstartServer();\n\nconst requestHandler = app;\nconst vercelServer = createServer((req, res) => requestHandler(req, res));\n\nmodule.exports = vercelServer;\n```\n\n`.env.sample` 파일을 업데이트하여 `MIDDLEWARE_ENV` 변수를 포함시킵니다. `.env` 파일에서는 로컬 백엔드에서 로컬 미들웨어에 액세스하려면 `http://localhost:5000`으로 설정해주세요. 코드를 푸시하세요.\n\n## 배포된 미들웨어를 배포된 백엔드에 연결하기\n\n미들웨어 Vercel 앱에는 이제 모든 GraphQL 관련 코드가 있지만, 백엔드의 배포된 인스턴스에 연결되지 않을 것입니다. 왜냐하면 `MIDDLEWARE_ENV` 변수가 없기 때문입니다. 미들웨어 프로젝트의 설정에서 해당 환경 변수를 추가하고, 배포된 백엔드 URL을 사용하세요. 미들웨어에서 `/test`로 요청하면 이제 백엔드에서 해당 경로로부터 데이터를 반환할 수 있어야 합니다.\n\n\n\n\n이제 남은 것은 프론트엔드를 미들웨어에 연결하도록 변경하는 것뿐입니다!\n\n## 로컬 프론트엔드와 로컬 미들웨어 연결하기\n\n모든 코드를 작성하고 성공적인 연결을 수행하려면 먼저 몇 가지 패키지를 추가해야 합니다:\n\n```js\nnpm i @apollo/client dotenv graphql react-router-dom\nnpm i -D @babel/plugin-proposal-private-property-in-object @types/react-router-dom @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo\n```\n\n\n\n프론트엔드 폴더 안에 있는 src 폴더 내의 index.tsx 파일을 찾아서, App 래퍼를 수정하여 ApolloProvider를 도입하고 ApolloClient를 사용해 프론트엔드를 미들웨어에 연결하도록 만들어보세요. 파일은 아래와 같이 보일 것입니다:\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { ApolloProvider } from '@apollo/client';\nimport client from './apolloClient';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  <ApolloProvider client={client}>\n    <App />\n  </ApolloProvider>\n);\n\n// 만약 앱의 성능을 측정하려면, 결과를 기록할 함수를 전달하세요 (예: reportWebVitals(console.log))\n// 또는 애널리틱스 엔드포인트로 전송하세요. 더 자세한 내용은 여기를 참고하세요: https://bit.ly/CRA-vitals\nreportWebVitals();\n```\n\n그러므로 똑같은 수준에서 apolloClient.ts 파일을 생성해야 합니다. 해당 파일은 아래와 같이 보일 것입니다:\n\n```js\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: process.env.REACT_APP_GRAPHQL_ENDPOINT,\n  cache: new InMemoryCache()\n});\n\nexport default client;\n```\n\n\n\n이것은 데이터를 더 빨리 읽고 쓰기 위해 메모리 캐시를 지정하는 매우 간단한 구현입니다. uri는 환경변수로 지정된 env를 사용합니다. 따라서 frontend 폴더 안에 .env.sample 파일을 생성해야 합니다.\n\n```js\nREACT_APP_GRAPHQL_ENDPOINT=\n```\n\n그런 다음 일치시키기 위해 .env 파일을 만드세요. 로컬에서는 이 값을 http://localhost:4000/graphql로 설정해야 합니다. 왜냐하면 이것은 Frontend에서 쿼리를 호출하려면 graphql 호출을 할 로컬 주소이기 때문입니다. Vercel의 경우, Frontend 앱의 설정으로 가서 이 값을 추가하고, 중간웨어 앱의 배포 URL을 사용하도록 해야 합니다(일반적으로 링크를 클릭하면 표시된 것과 동일한 URL에 /graphql를 추가해야 합니다):\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_36.png)\n\n\n\n이제 App.tsx 파일을 다음과 같이 수정해주세요:\n\n```js\nimport React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { Route, BrowserRouter as Router, Switch } from 'react-router-dom';\nimport TestPage from './pages/TestPage';\n\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <Switch>\n          <Route path=\"/test\">\n            <TestPage />\n          </Route>\n          {/* 필요한 만큼 더 많은 경로 추가 */}\n          <Route path=\"/\">\n            {/* TODO: 실제 앱 개발 시에는 이 샘플 코드를 제거하세요 */}\n            <div className=\"App\">\n              <header className=\"App-header\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\" />\n                <p>\n                  Edit <code>src/App.tsx</code> and save to reload.\n                </p>\n                <a\n                  className=\"App-link\"\n                  href=\"https://reactjs.org\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                >\n                  Learn React\n                </a>\n              </header>\n            </div>\n          </Route>\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n```\n\nTODO를 남겨두어서 무엇을 제거해야 하는지 명확하게 했지만, 연결을 테스트하기 위해 /test로 이동하는 Route를 추가했습니다. 여기에는 백엔드를 호출하여 사용자를 가져오는 GraphQL 쿼리가 있을 것입니다. 이는 실제로 함수 컴포넌트인 TestPage 컴포넌트를 호출할 것입니다. 이를 만들어봅시다. src 폴더 내에 pages 폴더를 생성한 다음, 그 안에 TestPage 폴더를 만들고 그 안에 index.tsx 파일을 다음과 같이 작성해주세요:\n\n```js\nimport { useQuery } from '@apollo/client';\nimport React from 'react';\nimport { GET_TEST_DATA } from '../../graphql/queries/test';\nimport { TestQuery } from '../../generated/graphql';\n\nconst TestPage: React.FC = () => {\n  const { data, error, loading } = useQuery<TestQuery>(GET_TEST_DATA);\n\n  if (loading) {\n    return <p>로딩 중...</p>;\n  }\n\n  return error ? (\n    <p>{`오류 발생: ${JSON.stringify(error)}`}</p>\n  ) : (\n    <div>\n      <h2>GraphQL로부터</h2>\n      <p>{`응답: ${data?.test?.message}`}</p>\n      {data?.test?.data?.length && (\n        <ul>\n          {data?.test?.data.map((currUserData, i) => {\n            const { name, userId } = currUserData!;\n\n            return (\n              <li key={i}>\n                {`${userId}: ${name}`}\n              </li>\n            )\n          })}\n        </ul>\n      )}\n    </div>\n  )\n}\nexport default TestPage;\n```\n\n\n\n여기서는 @apollo/client를 사용하여 useQuery 훅을 활용하여 미들웨어로부터 쿼리를 호출하여 백엔드-데이터베이스 통신을 시작할 수 있습니다. 쿼리에서 세 가지 속성을 분해하여 사용합니다: 데이터, 에러, 로딩입니다. 적절하게 명명되었으므로, 다음과 같이 사용할 수 있습니다:\n\n- 데이터는 처음에는 null 상태이지만 쿼리 호출로 반환된 정보를 포함하며, 성공적인 경우\n- 에러는 초기에 false인 부울 값이지만 쿼리 호출 시 오류가 발생하면 true가 됩니다.\n- 로딩은 다른 부울 값이며, 초기에는 false이지만 쿼리가 실행되면 true로 변경되고 완료되면 false가 되거나 오류가 발생하거나 상관없이 false가 됩니다.\n\n위 세 가지 속성을 통해 페이지의 상태에 따라 화면에 무엇을 표시할지 유연하게 설정할 수 있습니다. 데이터가 로드되는 동안 애니메이션을 표시하거나, 실패한 경우 이미지와 함께 오류 메시지를 표시하거나, 쿼리 호출이 성공한 경우 데이터를 표시할 수 있습니다. 그런데 이 글이 너무 길어지지 않도록 하기 위해 각 경우에 텍스트만 표시하겠습니다: 데이터가 로드되는 동안 if 블록, 오류가 발생한 경우 텍스트, 성공적으로 데이터가 로드되면 목록을 표시합니다.\n\n하지만 useQuery 라인으로 돌아와서: '' 괄호 내부의 변수는 가져온 데이터의 응답 유형을 나타내며, 괄호 내부의 변수는 호출할 쿼리를 지정합니다. 따라서 GET_TEST_DATA 및 TestQuery를 가져올 두 개의 파일이 필요합니다.\n\n\n\nGET_TEST_DATA는 간단해요; 미들웨어에 선언된 쿼리와 일치하는 쿼리일 뿐이에요. src 안에 graphql라는 폴더를 만들고 그 안에 queries라는 폴더를 만들고 그 안에 test.ts라는 파일을 만드세요:\n\n```js\nimport { gql } from \"@apollo/client\";\n\nexport const GET_TEST_DATA = gql`\n  query GetTestData {\n    test {\n      message\n      data {\n        name\n        userId\n      }\n    }\n  }\n`;\n```\n\ntest 블록 안에 있는 내용은 응답 페이로드에 다시 보낼 값을 지정해요. 이렇게 하면 필요한 것만 가져오고 가져오려는 값의 프로세스를 최적화할 수 있어요.\n\nTestQuery의 import는 조금 더 복잡해요. import가 나타내는 바처럼, GraphQL 미들웨어에서의 유형을 인식하여 응답 유형을 생성하고 그것을 프론트엔드로 가져와 유형으로 사용할 수 있도록 파일에 넣는 것을 의도했어요. 이를 위해 frontend 폴더 안에 graphql-types.js라는 파일을 만들어요.\n\n\n\n```js\nrequire('dotenv').config();\n\nconst { generate } = require('@graphql-codegen/cli');\n\nasync function generateTypes() {\n  const options = {\n    overwrite: true,\n    schema: process.env.REACT_APP_GRAPHQL_ENDPOINT,\n    documents: 'src/graphql/queries/*',\n    generates: {\n      'src/generated/graphql.tsx': {\n        plugins: [\n          'typescript',\n          'typescript-operations',\n          'typescript-react-apollo'\n        ],\n        config: {\n          withHooks: true,\n          withHOC: false,\n          withComponent: false,\n        }\n      }\n    }\n  };\n\n  try {\n    await generate(options, true); // true here means to print generation logs\n  } catch (error) {\n    console.error('Error during code generation', error);\n  }\n}\n\ngenerateTypes();\n```\n\n이 파일이 실행되면 generateTypes 함수가 호출되고, 이 함수는 @graphql-codegen/cli 패키지의 generate 함수를 호출합니다. 이 함수는 제공된 GraphQL URL(데이터 처리 미들웨어의 GraphQL URL)을 통해 쿼리의 스키마를 검사하고 형성할 문서 디렉토리를 나타냅니다. 쿼리는 src/graphql/queries에 있으므로 해당 디렉토리의 모든 내용을 가져오기로 선택했습니다. 마지막으로 generates 옵션은 이 생성에서 만들 파일과 위치를 언급하며, 설정과 플러그인을 일치시키기 위한 것입니다. src/generated/graphql.tsx 주소가 익숙한가요? 페이지에서 가져오는 생성된 파일입니다!\n\n마지막으로 필요한 코드 변경은 패키지.json 스크립트를 수정하여 graphql-types.js 파일을 호출하는 것입니다. 이를 위해 다음 스크립트를 추가합니다:\n\n```js\n\"generate\": \"node graphql-types.js\",\n```\n\n\n\n프론트엔드가 실행되어 있지 않고 미들웨어가 실행 중인지 확인한 후, npm run generate로 이 스크립트를 실행해야 합니다. 완료되면 frontend/src/generated/graphql.tsx 파일을 확인할 수 있어야 합니다. 파일은 아래와 같이 보이어야 합니다:\n\n```js\nimport { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends '$fragmentName' | '__typename' ? T[P] : never };\nconst defaultOptions = {} as const;\n/** 모든 기본 및 사용자 정의 스칼라, 실제 값으로 매핑됨 */\nexport type Scalars = {\n  ID: { input: string; output: string; }\n  String: { input: string; output: string; }\n  Boolean: { input: boolean; output: boolean; }\n  Int: { input: number; output: number; }\n  Float: { input: number; output: number; }\n};\n\nexport type Query = {\n  __typename?: 'Query';\n  test?: Maybe<Response>;\n};\n\nexport type Response = {\n  __typename?: 'Response';\n  data?: Maybe<Array<Maybe<UserData>>>;\n  message?: Maybe<Scalars['String']['output']>;\n};\n\nexport type UserData = {\n  __typename?: 'UserData';\n  name?: Maybe<Scalars['String']['output']>;\n  userId?: Maybe<Scalars['String']['output']>;\n};\n\nexport type TestQueryVariables = Exact<{ [key: string]: never; }>;\n\nexport type TestQuery = { __typename?: 'Query', test?: { __typename?: 'Response', message?: string | null, data?: Array<{ __typename?: 'UserData', name?: string | null, userId?: string | null } | null> | null } | null };\n\nexport const TestDocument = gql`\n    query Test {\n  test {\n    message\n    data {\n      name\n      userId\n    }\n  }\n}\n    `;\n\n/**\n * __useTestQuery__\n *\n * React 컴포넌트 내에서 쿼리를 실행하려면 `useTestQuery`를 호출하고 필요한 옵션을 전달하십시오.\n * 컴포넌트가 렌더링될 때, `useTestQuery`는 Apollo Client에서 로딩, 에러 및 데이터 속성을 포함하는 객체를 반환하며\n * UI를 렌더링하는 데 사용할 수 있습니다.\n *\n * @param baseOptions 옵션은 다음에서 지원하는 옵션을 전달할 수 있습니다: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @예시\n * const { data, loading, error } = useTestQuery({\n *   variables: {\n *   },\n * });\n */\nexport function useTestQuery(baseOptions?: Apollo.QueryHookOptions<TestQuery, TestQueryVariables>) {\n        const options = { ...defaultOptions, ...baseOptions };\n        return Apollo.useQuery<TestQuery, TestQueryVariables>(TestDocument, options);\n}\n\nexport function useTestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TestQuery, TestQueryVariables>) {\n          const options = { ...defaultOptions, ...baseOptions };\n          return Apollo.useLazyQuery<TestQuery, TestQueryVariables>(TestDocument, options);\n}\n\nexport function useTestSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TestQuery, TestQueryVariables>) {\n          const options = { ...defaultOptions, ...baseOptions };\n          return Apollo.useSuspenseQuery<TestQuery, TestQueryVariables>(TestDocument, options);\n}\n\nexport type TestQueryHookResult = ReturnType<typeof useTestQuery>;\nexport type TestLazyQueryHookResult = ReturnType<typeof useTestLazyQuery>;\nexport type TestSuspenseQueryHookResult = ReturnType<typeof useTestSuspenseQuery>;\nexport type TestQueryResult = Apollo.QueryResult<TestQuery, TestQueryVariables>;\n```\n\nTestQuery라는 줄은 페이지 컴포넌트에서 사용하는 응답 데이터를 보여줍니다. 이제 쿼리 응답 데이터에서 추출하고 데이터를 구성하는 작업이 필요한 마지막 코드 조각입니다! 이제 쿼리 호출에서 필드를 사용할 수 있는 인텔리센스 도움을 얻을 수 있어야 합니다.\n\n## 최종 프로젝트 구조\n\n\n\n이 튜토리얼의 모든 단계를 따르셨면 다음과 같이 완전한 폴더 구조를 갖게 됩니다:\n\n![folder structure](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_37.png)\n\n## 최종 실행\n\n이제 루트 폴더로 이동하여 npm start 명령어를 실행하세요. 이 명령은 프론트엔드, 미들웨어 및 백엔드 세 앱을 시작합니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_38.png)\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_39.png)\n\n프론트엔드가 준비되면 http://localhost:3000/test로 이동하면 미들웨어에서 백엔드로부터 데이터를 받은 후 TestPage의 코드를 볼 수 있습니다. 테스트 리졸버에서 추가된 텍스트를 표시합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_40.png)\n\n\n\n\n코드를 저장소에 푸시하세요. 이렇게 하면 Vercel 프로젝트에서 배포가 트리거됩니다. 작업이 완료되면 프론트엔드 배포로 이동해서 /test로 이동하세요:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_41.png)\n\n로컬호스트와 같은 동작을 본다면 성공적입니다! 세 앱이 완전히 연결되어 어떤 사용자 정의도 원할 때 준비가 된 상태입니다. 이 튜토리얼의 마지막 단계에서 바로 작업하길 원한다면 아래 저장소를 포크해도 괜찮습니다: https://github.com/gfcf14/react-graphql-node-mongo-boilerplate 세 앱의 설정을 따릅니다. 다만 Vercel 앱은 직접 설정해주어야 합니다.\n\n그럼 즐거운 코딩되세요! 이 기사가 웹 개발의 전반적인 소프트웨어 개발 경험에 대해 읽는 사람을 깨우칠 수 있기를 희망합니다.","ogImage":{"url":"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_0.png","tag":["Tech"],"readingTime":35},{"title":"React Hook Form과 Zod를 사용하여 React에서 양식 유효성 검사 다루기","description":"","date":"2024-05-14 10:34","slug":"2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod","content":"\n\n<img src=\"/assets/img/2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod_0.png\" />\n\n# 소개\n\n웹 애플리케이션에서 폼 유효성 검사는 데이터 무결성을 보장하고 일관된 사용자 경험을 제공하는 데 중요합니다. React에서 폼 유효성을 처리하는 것은 때때로 복잡하고 시간이 많이 소요될 수 있습니다. 그러나 적절한 도구와 라이브러리를 사용하면 이 과정을 간단화하고 효율적으로 만들 수 있습니다.\n\n이 글에서는 React Hook Form, Zod, 그리고 TypeScript를 활용하여 React에서 폼 유효성을 처리하는 방법을 살펴볼 것입니다. React Hook Form은 폼 상태와 유효성을 관리하기 위한 사용하기 쉬운 API를 갖춘 가벼운 조절 가능한 폼 라이브러리입니다. Zod는 스키마 유효성 검사 라이브러리로 데이터 구조를 정의하고 유효성을 검사하는 것을 간단하게 만들어줍니다.\n\n\n\nReact Hook Form과 Zod를 결합하여 React 애플리케이션에서 강력하고 신뢰할 수 있는 폼 유효성 검사 시스템을 만들 수 있습니다. 시작해보고 폼 유효성을 효과적으로 다루는 주요 개념, 기술 및 코드 예제를 살펴보겠습니다.\n\n데모에서는 Sass를 사용하여 유효성 검사 및 기본 스타일이 적용된 기본 양식을 만들어 보겠습니다(아래 이미지 참조). 이 데모는 React의 새로운 앱을 만들기 위해 React가 커뮤니티에서 인기 있는 React 기반 프레임워크를 사용할 것을 권장하는 Nextjs React 프레임워크를 사용하여 앱을 생성합니다. 자세한 내용은 여기를 참조하세요.\n\n![이미지](/assets/img/2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod_1.png)\n\n# React Hook Form과 Zod 설정\n\n\n\n폼 유효성 검사를 처리하기 전에, 프로젝트에 React Hook Form과 Zod를 설치해야합니다. 이미 React 또는 Next.js 프로젝트가 설정되어 있고 폼이 생성되어 있다고 가정하고, 다음 단계를 따라 진행하세요:\n\n- 필요한 종속성 설치:\n\n```js\nnpm install react-hook-form zod @hookform/resolvers\n```\n\n2. 필요한 컴포넌트와 훅을 가져옵니다:\n\n\n\n```js\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n```\n\n3. Zod을 사용하여 폼 스키마를 정의하세요:\n\n저희의 유효성 검사 스키마는 새로운 사용자를 등록하는 폼을 유효성 검사하기 위해 사용자명, 이메일, 비밀번호, 그리고 비밀번호 확인을 포함할 것입니다.\n\n```js\n const schema = z.object({\n    username: z.string().min(3, {message: '사용자 이름은 최소 3자 이상이어야 합니다'}),\n    email: z.string().min(1, {message: '이메일은 필수 항목입니다'}).email('유효하지 않은 이메일 주소입니다'),\n    password: z.string().min(6, {message: '비밀번호는 최소 6자 이상이어야 합니다'}),\n    confirmPassword: z.string().min(6, {message: '비밀번호는 최소 6자 이상이어야 합니다'})\n  })\n\n//스키마에서 유추된 타입 추출하기\ntype ValidationSchemaType = z.infer<typeof schema>\n```\n\n\n\n4. 양식과 유효성 해결 프로그램을 설정하십시오:\n\n```js\n const { register, handleSubmit, formState: { errors } } = useForm<ValidationSchemaType>({\n    resolver: zodResolver(schema),\n  });\n```\n\nReact Hook Form과 Zod를 설정했으니, 이제 React 애플리케이션에서 양식 유효성 검사를 처리할 준비가 되었습니다.\n\n# 기본 양식 유효성 검사\n\n\n\nReact Hook Form 및 Zod를 사용한 폼 유효성 검사의 기본 사항부터 시작해 봅시다. 개별 폼 필드의 유효성을 검사하고 오류 메시지를 표시하며, 폼 제출을 처리하는 방법을 살펴보겠습니다.\n\n- 폼 필드 등록:\n\nReact Hook Form의 register 함수는 폼 필드를 등록하는 데 사용되며, 폼 필드의 속성 이름 또는 스키마 이름을 인수로 취합니다.\n\n```js\n<input type=\"text\" {...register('name')} />\n```\n\n\n\n```js\n\"use client\";\n\nimport React from 'react'\nimport styles from './form.module.scss'\nimport { useForm, SubmitHandler } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst Form = () => {\n\n  const schema = z.object({\n    username: z.string().min(3, {message: 'Username must be at least 3 characters'}),\n    email: z.string().min(1, {message: 'Email is required'}).email('Invalid email address'),\n    password: z.string().min(6, {message: 'Password must be at least 6 characters'}),\n    confirmPassword: z.string().min(6, {message: 'Password must be at least 6 characters'})\n  }).refine((data) => data.password === data.confirmPassword, {\n    path: ['confirmPassword'],\n    message: 'Passwords does not match'\n  })\n\n  //extract the inferred type from schema\n  type ValidationSchemaType = z.infer<typeof schema>\n\n  const { register, handleSubmit, formState: { errors } } = useForm<ValidationSchemaType>({\n    resolver: zodResolver(schema),\n  });\n\n  return (\n    <form className={styles.form_main}>\n      <label htmlFor=\"username\">\n        Username:\n        <input type=\"text\" placeholder='username goes here...' {...register('username')} />\n      </label>\n      <label htmlFor=\"email\">\n        Email:\n        <input type=\"email\" placeholder='email goes here...' {...register('email')} />\n      </label>\n\n      <label htmlFor=\"password\">\n        Password:\n        <input type=\"password\" placeholder='password goes here...' {...register('password')} />\n      </label>\n\n      <label htmlFor=\"confirmPassword\">\n        Confirm Password:\n        <input type=\"password\" placeholder='Confirm password' {...register('confirmPassword')} />\n      </label>\n      <button type='submit'>Login</button>\n    </form>\n  )\n}\n\nexport default Form\n```\n\n2. Displaying error messages:\n\nReact Hook Form은 errors 객체를 반환하는데, 이 객체는 formState에서 비구조화된 것입니다. errors를 통해 우리는 양식 오류에 접근할 수 있고 각 등록된 양식 필드에 대한 지정된 유효성 제약 메시지를 반환합니다.\n\n```js\nconst { register, handleSubmit, formState: { errors } } = useForm<ValidationSchemaType>({\n    resolver: zodResolver(schema),\n  });\n```\n\n\n\n그럼 각 폼 필드에 대한 유효성 검사 스키마에서 선언된 오류 메시지를 조건부로 렌더링할 수 있어요. 또한, 잘못된 정보를 입력했을 때 입력란 테두리를 빨간색으로 만들기 위해 error_input이라는 CSS 클래스도 만들었어요.\n\n```js\n{errors.username && <span>{errors.username.message}</span>}\n```\n\n```js\n<form className={styles.form_main}>\n      <label htmlFor=\"username\">\n        Username:\n        <input type=\"text\" placeholder='사용자명을 입력해주세요...' {...register('username')} className={errors.username && styles.error_input}/>\n        {errors.username && (\n          <span className={styles.error}>{errors.username?.message}</span>\n        )}\n      </label>\n      <label htmlFor=\"email\">\n        Email:\n        <input type=\"email\" placeholder='이메일을 입력해주세요...' {...register('email')}  className={errors.email && styles.error_input}/>\n        {errors.email && (\n          <span className={styles.error}>{errors.email?.message}</span>\n        )}\n      </label>\n\n\n      <label htmlFor=\"password\">\n        Password:\n        <input type=\"password\" placeholder='비밀번호를 입력해주세요...' {...register('password')}  className={errors.password && styles.error_input}/>\n        {errors.password && (\n          <span className={styles.error}>{errors.password?.message}</span>\n        )}\n      </label>\n\n      <label htmlFor=\"confirmPassword\">\n        Confirm Password:\n        <input type=\"password\" placeholder='비밀번호를 확인해주세요' {...register('confirmPassword')}  className={errors.confirmPassword && styles.error_input}/>\n        {errors.confirmPassword && (\n          <span className={styles.error}>{errors.confirmPassword?.message}</span>\n        )}\n      </label>\n      <button type='submit'>로그인</button>\n    </form>\n```\n\n3. 폼 제출 처리:\n\n\n\n우리는 onSubmit이라는 사용자 정의 폼 제출 핸들러 함수를 생성하고, 폼 데이터를 콘솔에 출력합니다.\n\n```js\nconst onSubmit: SubmitHandler<ValidationSchemaType> = (data) => {\n    console.log(data)\n}\n```\n\n그런 다음, React Hook form에서 제공하는 handleSubmit 함수에 전달합니다.\n\n```js\n\"use client\";\n\nimport React from 'react'\nimport styles from './form.module.scss'\nimport { useForm, SubmitHandler } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst Form = () => {\n\n  const schema = z.object({\n    username: z.string().min(3, {message: 'Username must be at least 3 characters'}),\n    email: z.string().min(1, {message: 'Email is required'}).email('Invalid email address'),\n    password: z.string().min(6, {message: 'Password must be at least 6 characters'}),\n    confirmPassword: z.string().min(6, {message: 'Password must be at least 6 characters'})\n  }).refine((data) => data.password === data.confirmPassword, {\n    path: ['confirmPassword'],\n    message: 'Passwords does not match'\n  })\n\n  type ValidationSchemaType = z.infer<typeof schema>\n\n  const { register, handleSubmit, formState: { errors } } = useForm<ValidationSchemaType>({\n    resolver: zodResolver(schema),\n  });\n\n  // Form submit handler\n  const onSubmit: SubmitHandler<ValidationSchemaType> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <form className={styles.form_main} onSubmit={handleSubmit(onSubmit)}>\n      // 다른 코드\n    </form>\n  )\n}\n\nexport default Form\n```\n\n\n\n이 예시에서는 React Hook Form에서 제공하는 register 함수를 사용하여 '사용자 이름', '이메일\" 및 \"비밀번호\" 필드를 등록합니다. 그런 다음 필드에 오류가 있는 경우 오류 메시지를 표시합니다. 마지막으로, 폼 제출은 제출된 폼을 처리하는 onSubmit 함수를 호출하여 처리합니다. 아래 데모를 확인해보세요.\n\n# 일부 고급 폼 유효성 검사 기술\n\n다음 기술들 중 일부를 살펴보겠습니다:\n\n- Cross-Field Validation:\n\n\n\n리파인 커스텀 유효성 검사기는 비밀번호와 확인 비밀번호를 상호 검증하는 데 사용할 수 있습니다. 유효성 검사 함수와 양식 데이터를 가져와 비밀번호가 확인된 비밀번호와 동일한지 확인하고 오류 경로를 확인 비밀번호로 설정합니다.\n\n```js\n// 비밀번호와 확인 비밀번호를 상호 검증\nconst schema = z.object({\n    username: z.string().min(3, {message: '사용자 이름은 최소 3자 이상이어야 합니다'}),\n    email: z.string().min(1, {message: '이메일이 필요합니다'}).email('잘못된 이메일 주소입니다'),\n    password: z.string().min(6, {message: '비밀번호는 최소 6자 이상이어야 합니다'}),\n    confirmPassword: z.string().min(6, {message: '비밀번호는 최소 6자 이상이어야 합니다'})\n  }).refine((data) => data.password === data.confirmPassword, {\n    path: ['confirmPassword'],\n    message: '비밀번호가 일치하지 않습니다'\n  })\n```\n\n이 예시에서는 '확인 비밀번호' 필드가 '비밀번호' 필드와 일치하는지 확인합니다. 값이 일치하지 않으면 오류 메시지가 표시됩니다.\n\n2. 비동기 유효성 검사:\n\n\n\n```js\nconst schema = z.object({\n  email: z.string().email(\"유효하지 않은 이메일 주소\").refine(async (value) => {\n    // 비동기 유효성 검사 로직 수행 (예: 데이터베이스에 이메일이 있는지 확인)\n    // 유효성이 통과되면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n  }, '이메일이 이미 존재합니다'),\n});\n```\n\n이는 데이터를 외부 소스와 대조하여 유효성을 검사해야 할 때 유용합니다. 이메일이 이미 데이터베이스에 존재하는지 확인하는 것과 같은 상황에서 유용합니다.\n\n# 결론\n\nReact에서 양식 유효성을 처리하는 것은 견고하고 사용자 친화적인 웹 애플리케이션을 구축하는 데 필수적입니다. React Hook Form과 Zod의 조합으로 프로세스를 간소화하고 효율적으로 사용하는 방법에 대해 살펴보았습니다. React Hook Form과 Zod를 구성하는 방법, 기본 및 고급 양식 유효성 검사 수행, 복잡한 유효성 시나리오 다루기, 사용자 경험 향상 방법 등을 배웠습니다.\n\n\n\n귀하가 원하는 기준에 따라 사용자 입력을 유효성 검사할 수 있도록 React Hook Form과 Zod의 강력함과 유연성을 활용할 수 있습니다. 이를 통해 데이터 무결성이 향상되고 오류가 줄어들며 더 쾌적한 사용자 경험을 제공할 수 있습니다. 다음 React 프로젝트에서 이러한 기술과 라이브러리를 실험하여 양식 유효성을 효과적이고 효율적으로 처리해 보세요.\n\n더 많은 정보를 원하시면 React hook form 및 Zod 공식 문서를 참조하여 해당 라이브러리 및 고급 개념에 대해 더 많이 알아보세요.\n\n데모의 GitHub 저장소는 여기에서 확인할 수 있습니다. 전체 코드와 CSS 스타일링을 확인할 수 있습니다.\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod_0.png"},"coverImage":"/assets/img/2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod_0.png","tag":["Tech"],"readingTime":10},{"title":"React Native 정렬 또는 필터가 있는 긴 목록의 성능 최적화","description":"","date":"2024-05-14 10:33","slug":"2024-05-14-ReactNativePerformanceoptimizationforlonglistswithsortorfilters","content":"\n\nReact Native에서 긴 요소 목록을 다루는 것은 꽤 도전적일 수 있어요. RN 문서에서는 FlatList를 사용하는 것을 권장하지만, 제공된 예제는 종종 방대한 목록이나 필터 적용 및 목록 정렬과 같은 시나리오를 다루지 않아서 많은 애플리케이션에서 필수적인 요구 사항들을 보여주지 못합니다.\n\n# 예시와 관찰\n\nRN 문서의 성능에 따른 가이드에 따라 매우 간단한 사용자 인터페이스를 갖춘 새로운 React Native 프로젝트를 만들어 보겠습니다. 우리는 이 인터페이스를 따라 MOCK 데이터셋을 만들었습니다. 이 데이터셋은 다음 인터페이스를 따르는 500개의 제품 항목이 있어요:\n\n```js\ninterface Item {\n id: number\n name: string\n expiration_date: string\n qty: number\n}\n```\n\n\n\n그럼, 헤더와 두 개의 버튼이 있는 FlatList를 구현했습니다. 하나의 버튼은 ID가 가장 높은 순서대로 목록을 정렬하고, 다른 하나는 ID가 가장 낮은 순서대로 정렬합니다.\n\n```js\nexport const List = () => {\n  const [orderBy, setOrderBy] = useState<'normal' | 'reverse'>('normal');\n\n  const renderListItem = useCallback(({item, index}: {item: Item; index: number}) => {\n    return <ListItem item={item} index={index} />;\n  }, []);\n\n  const ListHeaderComponent = useCallback(() => {\n    return (\n      <Header\n        title={'Order by'}\n        onPressButton1={() => {\n          setOrderBy('normal');\n        }}\n        onPressButton2={() => {\n          setOrderBy('reverse');\n        }}\n      />\n    );\n  }, []);\n\n  const orderedData = useMemo(() => {\n    return orderBy === 'normal'\n      ? mockData.data.sort((a, b) => a.id - b.id)\n      : mockData.data.sort((a, b) => b.id - a.id);\n  }, [orderBy]);\n\n  return (\n    <>\n      <FlatList\n        ListHeaderComponent={ListHeaderComponent}\n        keyExtractor={({id}) => id.toString()}\n        renderItem={renderListItem}\n        data={orderedData}\n        stickyHeaderIndices={[0]}\n      />\n    </>\n  );\n}\n```\n\nListItem 컴포넌트를 메모이즈하여 불필요한 다시 렌더링을 피했습니다. 인덱스에 따라 배경색이 결정되며, 동작을 이해하기 위해 인덱스를 기록하고 있습니다.\n\n```js\nexport const ListItem = memo(({item, index}: {item: Item; index: number}) => {\n  const backgroundColor = item.id % 2 === 0 ? '#red' : 'pink';\n\n  console.log(index);\n  return (\n    <View\n      style={{\n        ...styles.container,\n        backgroundColor,\n      }}>\n      <Text>\n        {item.name} - {item.id}\n      </Text>\n    </View>\n  );\n})\n```\n\n\n\nFlatList은 동작을 이해하고 문제를 해결하는 데 도움이 되는 세 가지 중요한 속성을 제공합니다:\n\n- initialNumToRender: 초기 배치에서 렌더링할 아이템 수를 결정하며, 화면을 채우되 과도하게 많이 렌더링하지 않아야 합니다.\n- maxToRenderPerBatch: 각 증분 렌더 배치에서 렌더링할 최대 아이템 수를 지정합니다.\n- updateCellsBatchingPeriod: 배치 렌더 사이의 밀리초 단위 지연 시간을 설정합니다.\n\n예를 들어, initialNumToRender=10, maxToRenderPerBatch=10, updateCellsBatchingPeriod=10으로 설정하면, 리스트는 초기 10개 아이템을 먼저 렌더링한 다음, 10ms마다 10개씩 더 추가하여 완료될 때까지 부드럽게 렌더링되며, JS 스레드를 차단하지 않습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*okgjSFX3jUmN-5CM2dAESw.gif)\n\n\n\n리스트를 스크롤하는 동안 추가 항목이 배경에서 완료될 때까지 렌더링됩니다.\n\n![scrolling](https://miro.medium.com/v2/resize:fit:1200/1*cDzV6w7LguahgYZ4ywfQig.gif)\n\n그러나 목록을 정렬할 때 예상대로 동작하지 않습니다.\n\n![sorting](https://miro.medium.com/v2/resize:fit:1200/1*a4yZcj1iJYYel3tllSJqEw.gif)\n\n\n\nRN의 가이드라인을 따라 FlatList 성능을 향상시키려고 노력했지만, 목록이 예상대로 동작하지 않았어요. 그러나 성능을 향상시키는 것으로 보이는 잠재적인 해결책을 고안해 냈어요.\n\n주문 상태가 변경될 때마다 리스트의 다시 마운트를 트리거할 수 있도록 키를 사용함으로써, 초기 마운트 과정을 완료될 때까지 JS 스레드를 차단하지 않고 효율적으로 진행할 수 있어요.\n\n```js\n<FlatList\n    key={orderBy}\n    ...나머지 초기 속성\n/>\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*yLeRxhhh2BRKBJ2MBERS5Q.gif)\n\n\n\n행동을 더 잘 이해하기 위해 initialNumToRender=20, maxToRenderPerBatch=1 및 updateCellsBatchingPeriod=500으로 설정합니다.\n\n![이미지1](https://miro.medium.com/v2/resize:fit:1200/1*1JSiEZjP8PLNiP8I2OEvVw.gif)\n\n그러나 키가 삭제되면 어떻게 되나요?\n\n![이미지2](https://miro.medium.com/v2/resize:fit:1200/1*vnZ50uq7oTxc1T_vdNHopQ.gif)\n\n\n\n요약하자면, 렌더링된 목록에서 데이터를 필터링하거나 정렬하는 것은 초기 렌더링 시 항목 수와 동일한 수의 항목이 렌더링될 때까지 JS 스레드를 차단하는데 이상적인 방법이 아닙니다. \n목록의 성능을 향상시킬 수 있습니다. 목록을 강제로 마운트하여 교차 상태를 키로 전달하면 목록의 데이터도 변경할 수 있습니다.\n\n저장소: https://gitlab.com/sebastian.e.vogel/reactnativelonglistperformance","ogImage":{"url":"/assets/img/2024-05-14-ReactNativePerformanceoptimizationforlonglistswithsortorfilters_0.png"},"coverImage":"/assets/img/2024-05-14-ReactNativePerformanceoptimizationforlonglistswithsortorfilters_0.png","tag":["Tech"],"readingTime":4}],"page":"119","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}