{"pageProps":{"posts":[{"title":"Angular 18 Zoneless 2024년 핵심 기능 탐구","description":"","date":"2024-06-27 18:23","slug":"2024-06-27-Angular18ZonelessExploringthePillars","content":"\n\n\n![Image](/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png)\n\n\"동의하지 않을 수도 있지만, 저는 Angular이 존리스(zoneless)가 되길 원했고 실현될 줄은 상상도 못 했습니다. 이제 실험 모드로 Angular 18에서 사용할 수 있습니다. 제발 프로덕션 환경에서 사용하지 마십시오.\"\n\n# 존리스(zoneless)란?\n\n네, 맞습니다. Angular의 존리스 설정에서 Angular 스케줄러는 컴포넌트 내에서 무언가 변경되었을 때 변경 감지를 자동으로 트리거하지 않습니다. 대신 Angular의 ChangeDetectorRef 서비스를 사용하여 변경 감지를 수동으로 트리거해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n여기 간단한 설명이 있어요:\n\nZone.js를 사용하는 기존 Angular 애플리케이션에서는 Angular이 모든 비동기 작업(HTTP 요청, setTimeout, 사용자 상호작용 등)이 완료될 때 자동으로 변경 감지를 트리거합니다. Zone.js는 이러한 비동기 작업들을 monkey-patch하여 Angular에게 변경 감지를 실행할 때 알리게 합니다.\n\n우리가 무언가를 요리했다고 생각하실 지도 모르겠지만, 네 개의 기둥은 어디에 있을까요? 🧐\n\n우선, Angular 18의 zoneless API를 확인하는 설정을 해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n- 설치.\n\n```js\nng install @angular/cli@^18\n```\n\n2. 새 앱 만들기\n\n```js\nng new zoneless-app\ncd zoneless-app\n```\n\n<div class=\"content-ad\"></div>\n\n3. app.config.ts 파일이나 애플리케이션 부트스트랩 파일로 이동하세요.\n\n```js\nimport { ApplicationConfig, provideExperimentalZonelessChangeDetection, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter } from '@angular/router';\n\nimport { routes } from './app.routes';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideExperimentalZonelessChangeDetection(), provideRouter(routes)]\n};\n```\n\n4. angular.json의 폴리필에서 zone.js를 제거하세요.\n\n<img src=\"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n이제 모든 설정이 완료되었으니 애플리케이션을 실행하면 됩니다.\n\n이제 이 설정 이후에는 Angular가 자동으로 변경 감지를 트리거하지 않습니다.\n\n# 왜 zoneless를 사용해야 하는가? .\n\n불필요한 변경 감지를 피하기 위해서 간단하게 제안드립니다.\n\n<div class=\"content-ad\"></div>\n\n모든 컴포넌트의 비동기 작업이 발생할 때 Angular는 루트부터 모든 하위 컴포넌트를 확인하는데, 이는 비효율적일 수 있습니다.\n\n\"changeDetection\" 전략 \"OnPush\"를 사용하여 이 문제를 극복할 수 있는 옵션이 있습니다. 이는 컴포넌트와 해당 모든 하위 컴포넌트를 일반 변경 감지 주기에서 격리시킵니다.\n\n# 네 기둥이 무엇인가요?\n\n- 이벤트 핸들러.\n- MarkForChanges 관리.\n- 비동기 파이프.\n- 시그널.\n\n<div class=\"content-ad\"></div>\n\n## 이벤트 핸들러 :\n\n앵귤러의 이벤트 핸들러는 템플릿의 이벤트에 바인딩된 컴포넌트 클래스 내의 메서드입니다.\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: '<button (click)=\"onClick()\">{state}</button>'\n})\nexport class AppComponent {\n state = \"Click Me\";\n  onClick() {\n    this.state = \"Clicked\";\n  }\n}\n```\n\n## MarkForChanges 관리하기:\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서, markForCheck은 앵귤러의 기본 변경 감지가 변경 사항을 감지하지 못하는 시나리오에서 사용됩니다. 이는 OnPush 변경 감지 전략 및 지금은 zoneless에서 일반적입니다.\n\n```js\nimport { ChangeDetectorRef, Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: `\n      {data}\n      <button (click)=\"update()\">Update</button>\n     `,\n})\nexport class AppComponent {\n  data = '초기 데이터';\n\n  constructor(private cdr: ChangeDetectorRef) { }\n\n  update() {\n    this.data = '업데이트된 데이터';\n    this.cdr.markForCheck();\n  }\n}\n```\n\n## Async 파이프 :\n\n앵귤러의 AsyncPipe는 Observable 또는 Promise에 자동으로 구독하고 최신 값을 반환합니다. 또한 컴포넌트가 파괴될 때 자동으로 구독을 해제합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, inject } from '@angular/core';\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { Observable, of } from 'rxjs';\nimport 'zone.js';\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n     Hello world\n     {data$ | async }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule],\n})\nexport class App {\n  name = 'Angular';\n  data$: Observable<string> | undefined;\n  cRef = inject(ChangeDetectorRef);\n\n  constructor() {\n    setTimeout(() => {\n      this.data$ = of('Hello, AsyncPipe!');\n      this.cRef.markForCheck();\n    }, 4000);\n  }\n}\n\nbootstrapApplication(App);\n```\n\n## Signals:\n\nAngular에 Signals가 포함되어 정말 기쁩니다. 이전에는 불필요한 다시 렌더링 오버헤드를 극복하기 위해 신호를 사용해야 했습니다. 또한 이제 더 선언적 프로그래밍 스타일로 코드를 작성할 수 있고, 대부분의 주요 API는 Signals과 호환됩니다. 이것은 반응성을 위해 더 이상 RxJS에 의존하지 않아도 된다는 것을 의미합니다.\n\n```js\nimport { Component } from '@angular/core';\nimport { Signal, createSignal } from '@angular/core/signals';\n\n@Component({\n  selector: 'app-counter',\n  standalone: true,\n  template: `\n    <div class=\"counter\">\n      <h1>Counter: { count.value }</h1>\n      <button (click)=\"decrement()\">-</button>\n      <button (click)=\"increment()\">+</button>\n    </div>\n  `,\n  styles: [`\n    .counter {\n      text-align: center;\n      margin-top: 50px;\n    }\n    button {\n      margin: 0 5px;\n      padding: 10px;\n      font-size: 16px;\n    }\n  `]\n})\nexport class CounterComponent {\n  // Count 상태를 관리하기 위한 Signal 생성\n  count: Signal<number> = createSignal(0);\n\n  // Count 증가 메소드\n  increment() {\n    this.count.set(this.count.value + 1);\n  }\n\n  // Count 감소 메소드\n  decrement() {\n    this.count.set(this.count.value - 1);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n\"markForCheck\" 또는 수동 변경 감지가 필요하지 않습니다.\n\n신호 패턴 때문에 수동 변경 감지 확인이 필요하지 않습니다. 수동 코드 작성 부담이 줄어들고, Angular 팀은 Input/Output, ViewChild 및 기타 모든 API를 신호로 변환하고 있습니다.\n\n## 마지막 기둥:\n\nSSR은 Angular의 마지막 기둥입니다. 다음 포스트에서 계속합니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론:\n\nAngular은 이제 시그널의 도입으로 올바른 방향으로 나아가고 있습니다. Angular를 지원하는 중요한 요소 가운데 시그널이 특히 두드러집니다. 시그널은 Angular 18에서 존리스 작업으로의 전환을 용이하게 하뿐만 아니라 불필요한 다시 렌더링과 수동 변경 감지 확인의 부담으로부터 자유로움을 제공합니다. 이 방식은 성능을 향상시키는 것뿐만 아니라 더 선언적인 코딩 스타일을 촉진합니다.\n\n서버 측 렌더링(SSR)은 Angular의 중요한 측면으로 남아 있으며, 제가 이후에 다룰 것입니다. 이 네 가지 중요한 요소인 이벤트 핸들러, MarkForChanges 관리, 비동기 파이프, 그리고 시그널을 계속 탐험하면 코드를 더 읽기 쉽고 간단하게 만드는 데 기여하는 방법을 발견할 것입니다.\n\n즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png"},"coverImage":"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular로 사용자 지정 날짜 범위 선택기 만드는 방법","description":"","date":"2024-06-27 18:22","slug":"2024-06-27-CreatingaCustomDatesRangePickerinAngular","content":"\n\n이 글은 Angular에서 구성 요소로써 처음부터 날짜 범위 선택기를 만드는 방법을 설명하는 것을 목표로 하고 있습니다. 이것은 제 첫 번째 글의 두 번째 버전으로 여기에서 찾을 수 있습니다: [Medium 링크](https://medium.com/stackademic/creating-a-custom-date-time-picker-in-angular-5f00591d641c). 또한, 다음 글에서 작성할 사용자 정의 구성 요소의 장점을 잊지 않으세요.\n\n![이미지](/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png)\n  \n## 생성 의도\n\n이 구성 요소를 만들기 전에, 쉽게 스타일링할 수 있고 다음을 제공하는 범용 날짜 선택기를 찾고 있었습니다: 날짜 선택, 시간 선택, 범위 선택. 제가 필요한 것은 간단한 것이었지만, 조사 중에 대부분의 날짜 선택기가 너무 복잡하거나 필요한 조합을 제공하지 않는 것을 발견했습니다.\n\n<div class=\"content-ad\"></div>\n\n## 필요한 기능들:\n\n- 날짜 - 시간 선택기\n- 오직 날짜 선택기\n- 오직 시간 선택기\n- 날짜 - 범위 선택기\n\n이전에는 이 모든 것이 있었지만 범위 기능만 빠졌었어요. 그래서 논리를 간단한 말로 적어보기 시작했어요:\n\n# 논리\n\n<div class=\"content-ad\"></div>\n\n범위=false인 경우에 대한 두 가지 다른 출력이 필요합니다. 하나는 단일 선택이고 두 번째는 선택된 범위 배열이며 selectedRange[0]는 시작 선택이되고 selectedRange[1]는 끝 선택이됩니다.\n\n\n![Creating a Custom Dates Range Picker in Angular](/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_1.png)\n\n\n그런 다음 범위를 확인하여 시각적으로 선택을 표시할 수 있도록해야합니다.\n\n```js\ninRangeSelection(i: number) {\n  const currentDay = new Date(\n    this.date.getFullYear(),\n    this.date.getMonth(),\n    i\n  );\n\n  return (\n    this.range &&\n    this.clickedDate &&\n    this.clickedToDate &&\n    this.clickedDate.getDate() < currentDay.getDate() &&\n    this.clickedToDate.getDate() > currentDay.getDate() &&\n    this.clickedDate.getFullYear() >= currentDay.getFullYear() &&\n    this.clickedToDate.getFullYear() >= currentDay.getFullYear() &&\n    this.clickedDate.getMonth() >= currentDay.getMonth() &&\n    this.clickedToDate.getMonth() >= currentDay.getMonth()\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n  setDate(index: number) {\n    // 만약 범위 선택이 요청된 경우\n    if (this.range) {\n      // 순서가 매우 중요합니다 -> 이미 범위가 있는 경우 새로운 선택을 클릭하면 다시 처음부터 시작합니다\n      if (this.clickedDate && this.clickedToDate) {\n        this.clickedDate = null;\n        this.clickedToDate = null;\n      }\n\n      // 이미 첫 번째 선택이 있는 경우 값을 clickedToDate에 할당합니다\n      if (this.clickedDate && !this.clickedToDate) {\n        this.clickedToDate = new Date(\n          this.date.getFullYear(),\n          this.date.getMonth(),\n          index\n        );\n      }\n\n      // 여기서만 첫 번째 및 가장 중요한 시작점 설정이 가능합니다\n      if (!this.clickedToDate && !this.clickedDate) {\n        this.clickedDate = new Date(\n          this.date.getFullYear(),\n          this.date.getMonth(),\n          index\n        );\n      }\n\n      // clickedToDate가 clickedDate보다 낮은 경우 뒤집습니다\n      if (\n        this.clickedDate &&\n        this.clickedToDate &&\n        this.clickedDate > this.clickedToDate\n      ) {\n        const clickedToDate = this.clickedDate;\n        const clickedDate = this.clickedToDate;\n        this.clickedDate = clickedDate;\n        this.clickedToDate = clickedToDate;\n      }\n    // 일반 모드에서\n    } else {\n      this.clickedDate = new Date(\n        this.date.getFullYear(),\n        this.date.getMonth(),\n        index\n      );\n    }\n  }\n```\n\n마지막으로 출력 메서드가 변경되었습니다:\n\n```js\n  confirm() {\n    if (this.range) {\n      if (this.clickedDate && this.clickedToDate) {\n        this.selectRange.emit([this.clickedDate, this.clickedToDate]);\n      }\n    } else {\n      if (this.clickedDate) {\n        this.clickedDate.setHours(this.timeForm.get('hours')?.value || 0);\n        this.clickedDate.setMinutes(this.timeForm.get('minutes')?.value || 0);\n        this.selectDate.emit(this.clickedDate);\n      }\n    }\n  }\n```\n\n## 모든 로직을 컴포넌트 내부에 놓게 된 이유는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n만약 저장소에서 전체 컴포넌트를 확인했다면: https://github.com/marekpanti/dateTimePicker/blob/master/projects/marekpanti/angular-date-time-picker/src/lib/angular-date-time-picker.component.ts 아마도 궁금할 것입니다. 왜 Marek는 패서드와 깔끔한 컴포넌트에 대해 언급했을 때 모든 로직을 컴포넌트 내부에 넣는 건지요.\n\n룰에는 예외가 없는 법입니다. 복잡한 컴포넌트와 UI 컴포넌트의 경우, 나는 내 로직이 한 곳에 있기를 원합니다. 내 컴포넌트가 시각적이며 각 속성이 각 메소드와 연결되어 있음을 이해하기 때문에, 서비스를 분리하여 메소드를 읽는 것이 오히려 더 어려울 것입니다.\n\n# 결론\n\n이 글은 처음에 복잡해 보이지만 적절한 계획과 문제 이해로 자신만의 컴포넌트를 쉽게 만들 수 있는 방법을 잘 정리한 요약입니다.\n\n<div class=\"content-ad\"></div>\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해 주시면 감사하겠습니다! 👏\n- 다음 채널을 구독해 주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해 보세요: In Plain English | CoFeed | Differ\n- 더 많은 컨텐츠는 Stackademic.com에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png"},"coverImage":"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png","tag":["Tech"],"readingTime":5},{"title":"React Query 활용법 데이터 페칭 최강자 되기","description":"","date":"2024-06-27 18:20","slug":"2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse","content":"\n\nReact 어플리케이션을 더 빠르게 만들어주는 캐싱이 어떻게 변화를 주는지 궁금했던 적이 있나요? 이 블로그에서 React Query가 캐싱을 활용하여 데이터 가져오기와 관리를 간편하게 하는 방법을 탐구하고 있습니다. 뿐만 아니라 효율적인 캐싱을 위한 다양한 방법들을 살펴볼 예정이에요. 게다가, 낙관적 업데이트의 힘도 발견해 볼 거예요. 이것은 거의 사용되지 않는 주요 최적화 기술이랍니다.\n\n캐시란 무엇인가요?\nReact Query에서 캐시는 API 요청의 결과를 저장하는 임시 저장 메커니즘입니다. 이는 React 컴포넌트와 서버 사이에서 중개 역할을 하며, 자주 필요한 것들을 기억해두고 필요할 때 즉시 제공하는 친구처럼 작동합니다.\nReact Query의 내부 메커니즘을 이해하는 것은 사용하기 전에 필수적이며, 어플리케이션의 상태 관리에서 중요한 역할을 합니다.\n\nreact query를 사용하여 API 호출하는 간단한 예제를 살펴보겠습니다(세부적으로 아래에서 설명됩니다)\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_0.png)\n\n<div class=\"content-ad\"></div>\n\nAPI 호출 후 받은 응답은 데이터에 저장되고 키를 'user'로하여 캐싱됩니다.\n\nReact Query 작동 방식: 깊게 들어가기\nReact Query가 어떻게 작동하는지 알아보기 전에 몇 가지 주요 용어에 익숙해져 보겠습니다.\n\nQueryClient — 인스턴스를 생성할 때 생성되는 queryCache 및 mutationCache를 보유하는 용기/컨테이너입니다.\n\nQueryCache — 모든 가져온 데이터와 쿼리 세부 정보를 저장하는 중앙 메모리입니다. 고유한 키를 사용하여 특정 데이터를 찾고 결과를 캐싱하고 앱 전반에 걸쳐 데이터를 일관되게 관리하여 성능을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\nMutationCache — React Query에서 변이(mutation)는 데이터를 업데이트하는 작업(항목 추가 또는 제거와 같은 작업)을 의미합니다. 이 캐시는 이러한 변이의 결과를 일시적으로 저장하여 서버에서 확인될 때까지 그 결과를 유지합니다.\n\nQuery — 쿼리는 데이터를 가져오는 핵심 작업입니다. 필요한 정보(데이터, 상태 등)를 보유하며 해당 데이터를 가져오는 함수를 실행하고 데이터가 변경될 때 다시 시도, 취소 및 업데이트를 관리합니다. 데이터 가져오기 과정을 위한 소규모 관리자와 같은 역할을 합니다.\n\nQueryObservers — 옵저버(observer)는 useQuery를 호출할 때 생성되며 쿼리에 구독된 상태입니다. 이것이 useQuery에 쿼리 키(queryKey)를 전달하는 이유입니다.\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_1.png)\n\n<div class=\"content-ad\"></div>\n\n이제 내부 작업을 살펴보겠습니다 - \n구성 요소가 마운트될 때 QueryClient의 인스턴스가 생성되고 QueryClientProvider를 통해 전체 응용 프로그램에 전달되며 (내부적으로 React Context를 사용함) 컨텍스트를 통해 사용됩니다.\n\nquery 키와 함께 useQuery를 호출할 때 useQuery는 QueryClient와 상호 작용합니다. QueryClient는 queryKey로 식별된 데이터를 QueryCache에서 확인합니다. 데이터가 존재하고 캐시/풀린 시간을 충족하며 다시 가져오기가 트리거되지 않은 경우:\n\n- 캐시된 데이터가 직접 구성 요소로 반환되고 구성 요소가 캐시된 데이터로 렌더링됩니다.\n- useQuery에 의해 생성된 QueryObserver가 구성 요소에 가용한 데이터에 대해 알립니다.\n\n데이터가 캐시에 없거나 신선도 기준을 충족하지 못한 경우:\n\n<div class=\"content-ad\"></div>\n\n- 쿼리 객체가 생성되고(아직 없는 경우), QueryObserver가 설정되어 Query에 연결됩니다.\n\n두 경우 모두, 데이터가 가져오는 동안 초기로딩 상태를 포함한 객체가 있습니다. useQuery에 제공된 queryFunction은 비동기적으로 트리거되어 새로운 데이터를 가져옵니다. 데이터를 가져오면 QueryCache에 쿼리 키와 함께 저장되고 QueryObserver에 업데이트에 대해 알립니다. 구성요소는 useQuery 훅을 통해 업데이트된 데이터를 받아와 새로운 데이터로 재렌더링이 트리거됩니다.\n\nReact Query에서 비동기 작업을 수행하는 방법은 useQuery와 useMutation 두 가지가 있습니다. 이러한 훅을 탐색해 봅시다.\n- useQuery: React 구성요소에서 데이터를 가져오기 위해 React Query 내에서 사용되는 사용자 정의 훅입니다. 이 훅은 초기 가져오기 후 데이터 캐싱, 백그라운드에서 데이터 다시 가져오기 등 많은 기능을 관리합니다.\n\n![LeveragingReactQueryAData-FetchingPowerhouse_2.png](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_2.png)\n\n<div class=\"content-ad\"></div>\n\nuseQuery 훅을 사용하여 구문 및 데이터를 가져오는 방법을 확인해 봅시다.\n세 가지 매개변수가 필요합니다 -\n\n쿼리 키: 데이터를 가져오고 캐시하며 응용 프로그램 전반에서 쿼리를 다시 가져올 때 사용되는 고유한 키입니다.\n\n쿼리 함수:이 함수에는 프라미스를 반환하거나 오류를 발생시키는 비동기 작업이 포함되어 있습니다.\n\n옵션: CacheTime, staleTime, refetchInterval, refetchOnWindowFocus, retry 등 여러 속성이 포함된 개체입니다. 자세한 내용은 여기를 참조하시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\nuseQuery 훅은 여러 속성을 포함한 객체를 반환합니다:\n\n- data: API 응답입니다.\n- isLoading: API 호출의 현재 상태를 나타내는 부울 플래그입니다.\n- error: 쿼리가 데이터를 가져오는 동안 오류가 발생했을 경우 나타나는 객체입니다.\n- refetch: API 호출을 수동으로 트리거할 수 있는 함수입니다.\n\n그리고 더 많은 속성이 있는데, 자세한 내용은 여기를 참조해주세요.\n\n# 메모\n\n<div class=\"content-ad\"></div>\n\n쿼리 키는 적절한 캐싱과 재검색을 보장하기 위해 고유해야 합니다. 내부적으로 배열로 변환되어 키-값 쌍과 유사합니다.\n\n- 예를 들어, useQuery(`Todo`, fetchTodo) 는 키 `Todo`로 결과를 저장합니다.\n- useQuery([`Todo`, 1], () => fetchTodo(1)) 는 키 [`Todo`, 1] 로 결과를 저장합니다.\n\n이 두 캐시는 별개입니다. 의존성 목록에 거짓값이 포함되어 있다면 쿼리 함수가 호출되지 않습니다.\n\n다른 queryFunctions에 동일한 queryKey를 사용하면 해당 키 아래에 가장 최근 결과가 저장되어 잠재적인 문제를 야기할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nUseMutation은 변경 작업(데이터 수정 작업)을 관리하는 강력한 훅입니다. 이를 통해 백엔드 API로 변이를 보내고 응답을 처리하는 프로세스가 간단해집니다.\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_3.png)\n\nuseMutation에서 반환된 옵션과 객체는 거의 비슷하지만 refetch 대신 mutate를 반환하며 useMutation에는 queryKey가 없습니다. 왜냐하면 이들은 데이터 수정 작업이기 때문입니다.\nmutate는 변이를 시작하는 데 사용되는 함수입니다. 데이터 변이 함수로 보낼 데이터를 나타내는 선택적 페이로드를 인수로 받습니다.\n옵션 및 속성에 대한 자세한 내용은 이 링크를 참조하세요.\n\nuseMutation 및 useQuery를 활용한 예제를 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n낙관적인 업데이트\n\n참고 - 이것은 일반적으로 대부분의 프로젝트에서 객체를 생성할 때 백엔드에서 id가 생성되기 때문에, 패치, 삭제 및 업데이트에 대해서만 작동합니다.\n\n위 예시를 고려해 봅시다. 할 일이 삭제되면 현재 2개의 작업이 발생합니다 -\n1. 할 일 ID로 삭제 호출.\n2. 즉시 업데이트된 할 일 목록 보여주기 위해 get 호출.\n\n이전 get API가 호출될 때, 응답과 함께 데이터가 캐시에 저장됩니다.\n우리가 해야 할 일은 캐시를 업데이트하는 것뿐입니다(캐시에서 항목에 기반한 할 일 항목 제거).\n\n<div class=\"content-ad\"></div>\n\n리액트 쿼리는 setQueryData를 사용하여 수동으로 캐시 관리하는 것보다 더 간편한 방법을 제공하여 캐시된 데이터를 업데이트할 수 있습니다. 이 방법을 사용하면 특정 쿼리 키와 연관된 데이터를 직접 수정할 수 있습니다.\n이에 대한 2가지 경우가 있습니다 -\n\n삭제 API 호출의 성공 후 캐시 업데이트\n이 경우, 삭제 API 호출이 성공한 경우에 캐시를 업데이트합니다.\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_4.png)\n\nAPI 호출 전에 캐시 업데이트\n이 경우, API 호출이 성공할 것으로 가정하고 onMutate 함수를 사용하여 데이터를 업데이트합니다.\nonMutate은 변이가 발생하기 전에 실행됩니다. 따라서 여기서 todoItem을 삭제하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_5.png\" />\n\n참고 -\n불변 업데이트: 항상 캐시 데이터를 불변하게 업데이트합니다. React Query는 기존 데이터를 직접 수정하는 대신 새로운 데이터 객체를 기대합니다.\n쿼리 키: 관련 캐시 항목을 대상으로 정확한 쿼리 키를 지정합니다.\n\n이 블로그에서는 React Query의 강력한 기능에 대해 살펴보았습니다. 특히 React 애플리케이션에서 데이터 가져오기와 관리를 최적화하기 위해 캐싱을 활용하는 방법에 중점을 두었습니다. React Query의 내부 메커니즘을 이해함으로써 QueryClient, QueryCache, MutationCache 및 QueryObservers와 같은 요소를 통해 개발자들은 API 요청을 효율적으로 처리하고 애플리케이션 성능을 향상시키며 애플리케이션 전체에서 데이터 일관성을 보장할 수 있습니다.\n\nuseQuery 및 useMutation 훅의 사용을 탐구하며 각각 데이터 가져오기 및 변이에 대한 역할을 강조했습니다. 게다가 낙관적 업데이트의 중요성을 논의하면서 사용자 경험을 향상시킬 수 있는 방법을 살펴보았습니다. 서버 확인을 기다리는 동안 즉각적인 피드백을 제공함으로써 사용자 경험을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nReact Query를 다룬 이번 내용이 유익하고 실용적이었기를 바라요. React 애플리케이션을 최적화하는 더 많은 팁과 기술에 대한 소식을 기대해 주세요. 이 블로그가 유용하다면 공유하고 더 많은 콘텐츠를 구독해 주세요. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_0.png"},"coverImage":"/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_0.png","tag":["Tech"],"readingTime":6},{"title":"구글이 Streamlit을 죽였는가","description":"","date":"2024-06-27 18:19","slug":"2024-06-27-DidGoogleJustKillStreamlit","content":"\n\n## 구글의 Mesop 프레임워크를 살펴보면 Streamlit보다 더 나은지 확인해보세요.\n\n내가 소파에 앉아 YouTube의 추천을 살펴보던 중 Google의 최신 오픈 소스 파이썬 프레임워크인 'Mesop'에 관한 Prompt Engineering의 비디오를 보게 되었습니다. 구글 팀이 내부 도구 및 빠른 프로토타이핑에 사용하는 'Mesop'라는 프레임워크입니다. 'Mesop'이 무엇을 의미하는지 궁금하다면, 너무 깊게 생각하지 마세요. 삶에는 모든 것이 의미가 있는 것은 아닙니다. 이 글을 읽는 Will이 있다면 아래 댓글에 남겨주세요.\n\n아마 Mesop을 시도해보고 Streamlit보다 실제로 더 나은지 확인해봐야겠다고 생각했습니다. Streamlit은 코드 작성 경험이 매우 직관적하고 마법 같이 순식간에 앱을 생성할 수 있는 능력 때문에 정말 좋아합니다. 하지만 그 인터페이스를 보자마자 Streamlit임을 알 수 있습니다.\n\n이 문제에 대처하기 위해 Python과 Tailwind CSS만 사용하여 아름다운 웹 앱을 개발하는 방법에 대해 작성한 블로그가 예상치 못하게 터져나왔습니다. 여기서 읽을 수 있습니다. 이 과정은 훨씬 더 제작 친화적이지만, 사용자 정의 가능한 프로토타입을 개발하려면 어떨까요?\n\n<div class=\"content-ad\"></div>\n\n당신이 바로 Mesop이 하는 일입니다.\n\n간략히 요약하면, Mesop은 아직 초기 단계에 있으므로 그것을 기반으로 SaaS 스타트업을 구축하기 위해 키보드로 코딩을 시작하지 마세요. 또한 Google에서 공식적으로 지원하지는 않습니다.\n\n# Mesop의 기능\n\n- 오픈 소스.\n- 미리 구축된 구성 요소로 시작하기 쉽습니다.\n- Python에서 작성된 자연스러운 코드.\n- 핫 리로드.\n- 구성 요소는 기본적으로 Python 함수입니다.\n- Angular로 구축되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# Mesop 시작하기\n\n안녕하세요! 메소프 기술의 다양한 기능에 대한 장황한 문학작품으로 사람들을 지루하게 만드는 것을 싫어하기 때문에, 메소프로 기본 UI를 만드는 것으로 바로 도입하겠습니다. 메소프로 작업할 때 알아두어야 할 주요한 세 가지 구성 요소가 있습니다:\n\n- 상태 클래스: 이는 세션의 상태 역할을 하며 다른 구성 요소 간에 데이터를 공유하는 능력을 제공합니다.\n- 페이지 및 이벤트: 앱의 주요 UI입니다.\n- 스타일링 요소: CSS 스타일 (Tailwind 지원은 아직 제공되지 않습니다)\n\n시작하기 전에 pip install mesop을 사용해서 메소프를 설치해보세요. 함께 즐거운 개발 시간 보내시길 바랍니다!\n\n<div class=\"content-ad\"></div>\n\n## State 클래스\n\n앱 내에서 사용되는 모든 모델은 데코레이터 @me.stateclass를 사용하여 state 클래스를 인스턴스화하는 데 사용됩니다. 예를 들어, 제목과 개요를 사용하여 기사를 생성하는 GenAI 앱을 개발 중이라고 가정해보겠습니다. 'Article'이라는 이름의 state 클래스를 생성해야 합니다. 해당 state 클래스는 다음과 같이 보일 것입니다:\n\n```js\nimport mesop as me\n\n@me.stateclass\nclass Article:\n    title: str\n    outline: str\n    response: str\n```\n\n우리가 생성하는 각 함수나 구성 요소에서 이 state 클래스 데이터는 유지되며 전역적으로 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 페이지 및 이벤트\n\n모든 페이지는 Mesop에서 @me.page() 데코레이터를 사용하여 태그가 지정됩니다.\n\n```js\n@me.page()\ndef app():\n    me.input(label=\"제목\", type=\"text\")\n    me.input(label=\"개요\", type=\"text\")\n```\n\n위의 코드는 두 개의 입력 필드가 있는 기본 페이지를 생성합니다. 이전에 만든 상태 클래스에 데이터를 저장할 수 있도록 각 필드에는 별도의 함수가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ndef on_title_input(title: me.InputEvent):\n    s = me.state(Article)\n    s.title = title.value\n\ndef on_outline_input(outline: me.InputEvent):\n    s = me.state(Article)\n    s.outline = outline.value\n\n@me.page()\ndef app():\n    me.input(label=\"Title\", on_input=on_title_input, type=\"text\")\n    me.input(label=\"Outline\", on_input=on_outline_input, type=\"text\")\r\n```\n\n상태 클래스에 액세스하려면 me.state() 함수를 사용합니다. 그 인스턴스는 변수 s에 저장됩니다.\n\nMesop에서 이벤트는 InputEvent, ClickEvent 등의 클래스를 사용하여 처리됩니다.\n\n클릭 이벤트를 처리하기 위해 다른 함수를 호출하여 입력 데이터를 제출할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 응답 스키마\nclass Blog(typing_extensions.TypedDict):\n    title: str\n    content: str\n\ndef on_title_input(title: me.InputEvent):\n    s = me.state(Article)\n    s.title = title.value\n\ndef on_outline_input(outline: me.InputEvent):\n    s = me.state(Article)\n    s.outline = outline.value\n\ndef on_click(click: me.ClickEvent):\n    s = me.state(Article)\n    prompt = f\"다음 기사 제목 및 개요를 사용하여 블로그를 작성해주세요: <article_title>{s.title}</article_title><article_outline>{s.outline}</article_outline>. 최종 블로그와 제목을 마크다운 형식으로 반환하세요.\"\n    # 훅 URL을 저장할 환경 변수 추가\n    response = model.generate_content(\n                prompt,\n                generation_config=genai.GenerationConfig(\n                    response_mime_type=\"application/json\",\n                    response_schema=Blog,\n                    temperature=0.8\n                ))\n    data = json.loads(response.text)\n    s.response = data\n\n@me.page()\ndef app():\n    me.input(label=\"제목\", on_input=on_title_input, type=\"text\")\n    me.input(label=\"개요\", on_input=on_outline_input, type=\"text\")\n    me.button(\"블로그 생성\", on_click=on_click)\r\n```\n\n재미있는 일을 위해 Mesop을 사용하여 Gemini 모델을 활용해 블로그를 생성할 것입니다. on_click 함수는 Article 인스턴스로부터 data s.title과 s.outline를 가져와서 만든 prompt에 주입할 것입니다. LLM의 응답은 블로그 내용을 담은 JSON일 것입니다.\n\n## 스타일링\n\nMesop에서 요소를 스타일링하는 것은 기존 CSS 속성과 유사하지만, 모든 속성은 me.style()의 매개변수입니다.\n\n\n<div class=\"content-ad\"></div>\n\nme.style()을 사용하여 스타일을 정의한 후, 해당 스타일을 변수에 저장하여 컴포넌트에서 매개변수로 호출할 수 있습니다.\n\n```js\n_STYLE_INPUT_WIDTH = me.Style(width=\"100%\")\n\n_STYLE_BUTTON = me.Style(\n    background=\"#1976D2\",\n    color=\"#fff\",\n    padding=me.Padding.symmetric(horizontal=20, vertical=10),\n    font_size=\"16px\",\n    cursor=\"pointer\",\n    margin=me.Margin(bottom=20),\n)\n\n@me.page()\ndef app():\n    with me.box(style=_STYLE_CONTAINER):\n        s = me.state(Article)\n        with me.box(style=_STYLE_MAIN_COLUMN):\n            me.input(label=\"Title\", on_input=on_title_input, type=\"text\", style=_STYLE_INPUT_WIDTH)\n            me.input(label=\"Outline\", on_input=on_outline_input, type=\"text\", style=_STYLE_INPUT_WIDTH)\n            me.button(\"Generate Blog\", on_click=on_click, style=_STYLE_BUTTON)\n    with me.box(style=_STYLE_PREVIEW_CONTAINER):\n        if s.response:\n            me.markdown(f\"{s.response['content']}\", style=_STYLE_PREVIEW)\n```\n\n# 최종 인터페이스\n\n<img src=\"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 테이블 태그를 마크다운 형식으로 변경해 드릴게요. \n\n\n| Not the best-looking UI, but that’s because I didn’t make the effort to style it enough. It still looks a lot better than raw HTML with just a few tweaks here and there. With the ability to use all CSS properties for the components, you can make the UI unique. |\n\n# Is Streamlit dead?\n\nNo, absolutely not. Mesop is still under development, and the documentation lacks in certain aspects. Deploying a Mesop application is not straightforward and requires containerization unless you are deploying it directly to Google Cloud.\n\nStreamlit still comes with its own set of benefits and is fundamentally stronger compared to Mesop, especially if you are looking to build something in the data visualization domain. Moreover, Streamlit Cloud is a boon for anyone looking to share their applications absolutely free of charge.\n\n\n무엇이든 더 도와드릴게요!\n\n<div class=\"content-ad\"></div>\n\n그러나 Mesop은 성장 잠재력이 있으며 매일 업데이트를 받고 있어 가벼운 성격으로 REST API에서 작동하는 빠른 도구 및 간단한 프로토 타입에 더 적합해지고 있습니다.\n\nMesop의 Will과 다른 기여자들에게 시간과 노력을 들여 이러한 프레임워크를 개발하고 유지하는 데 기쁨을 느낍니다.\n\n# 더 많은 UI 프레임워크가 필요합니다\n\nStreamlit, Nicegui, Gradio 그리고 이제 Mesop와 같은 새로운 Python UI 프레임워크가 등장하는 것을 항상 좋게 생각합니다. Python의 관용구 문법은 코딩을 훨씬 더 접근 가능하게 만들어주며, 이는 지금 Streamlit 프로젝트의 많은 수로부터 명확히 확인됩니다.\n\n<div class=\"content-ad\"></div>\n\n행운이던지 불행이던지, 파이썬이 내가 처음으로 배운 프로그래밍 언어였고, 그것에 즉시 사랑에 빠졌어요. 이와 같은 더 많은 프레임워크로 인해, Python은 사용량이 급격히 증가할 것이고, 미래에는 더 많은 실무급 Python 앱들을 볼 수 있기를 희망해요.\n\n저는 Mesop에 관한 이 짧은 블로그를 좋아해주셨으면 좋겠어요. 더 깊이 파고들고 싶었지만, 제한된 시간 때문에 글을 짧게 유지하게 된 것과, 우리 모두가 금붕어 수준의 집중력을 고려했기 때문이에요. 만약 이 글에 박수를 보내주시고, 파이썬과 Google 커뮤니티의 더 많은 사용자와 공유해주시고, 앞으로의 다른 글들을 위해 팔로우해주시면 정말 감사하겠어요.\n\n# 링크\n\n- Github\n- Mesop","ogImage":{"url":"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png"},"coverImage":"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png","tag":["Tech"],"readingTime":7},{"title":"JS 초보자를 위한 가이드 Part 1  스코프, 클로저, 호이스팅, 모듈 이해하기","description":"","date":"2024-06-27 18:16","slug":"2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules","content":"\n\n![이미지](/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_0.png)\n\n- Scope: 변수에 대한 접근 가능성을 정의하며, 코드 내에서 어디에서 접근할 수 있는지를 나타냅니다.\n- Closure: 실행 범위 외부에서 실행되더라도 어휘적 범위를 기억하는 함수입니다.\n- 호이스팅은 JavaScript 메커니즘으로, 변수 및 함수 선언이 코드의 선언 위치와 관계없이 컴파일 단계 중에 해당 범위의 맨 위로 이동됩니다. 이는 변수 및 함수가 선언되기 전에 사용될 수 있다는 것을 의미합니다.\n\n명령형(어떻게, 무엇) 대 선언형(무엇)\n명령형 - 작동 방식을 알고 작동 방식을 알 수 있습니다.\n선언형 - 작동 방식을 알지 못한 채, 무엇이 동작하는지만 알 수 있습니다. JS 배열 맵 함수와 같은 예시\n\n![이미지](/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_1.png)\n\n<div class=\"content-ad\"></div>\n\nScope 이전에 JS에서 변수를 선언하는 방법을 먼저 이해해야 합니다.\nlet vs var vs const\n\n![이미지](/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_2.png)\n\nScope는 변수의 접근 가능성(가시성)을 결정합니다. JavaScript에는 3가지 유형의 scope가 있습니다: ES6(2015) 이전에는 JavaScript에서 전역 Scope 및 함수 Scope만 있었지만, 블록 Scope는 나중에 let과 const로 도입되었습니다.\n\n- 전역 Scope: 어떤 함수 내에서도 선언되지 않은 변수들은 전역 Scope를 갖습니다.\n프로그래밍 환경에서 전역 Scope는 모든 다른 Scope에서 볼 수 있는 Scope입니다. 이는 브라우저에서는 window 객체에 연결되고 Node.js에서는 전역(global)에 연결됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar globalVar = 10;  \nfunction foo() {     \n   console.log(globalVar); // 사용 가능 \n   console.log(window.globalVar); // 사용 가능\n}  \nconsole.log(globalVar);\nconsole.log(window.globalVar);\nfoo(); // 출력: 10 10 10 10\n```\n\n2. 지역 범위: 함수 내에서 선언된 변수는 지역 범위를 갖습니다.\n함수 내에서 선언된 변수를 지역 변수라고 하며 함수 범위에 속합니다. 지역 변수는 함수 내 어디에서든 접근할 수 있습니다 (기능 블록 내).\n\n```js\nfunction foo() {     \n   var localVar = 20;    \n   if(true){\n   var blocklocalVar = 2\n    } \n   console.log(localVar); // 사용 가능 \n   console.log(blocklocalVar) // var의 함수 범위 때문에 접근 가능\n }  \nfoo(); \n\nconsole.log(localVar);\n// 출력: 20 2\n// 오류: localVar이(가) 정의되지 않았습니다\n```\n\n3. 블록 범위: let과 const는 블록 범위 변수이며, if, for, while 등의 블록을 기준으로 합니다.\n\n<div class=\"content-ad\"></div>\n\nES6는 JavaScript에 let 및 const라는 두 가지 중요한 새로운 키워드를 소개했습니다. 이 두 키워드는 JavaScript에서 블록 범위를 제공합니다. ' ' 블록 내에서 선언된 변수는 블록 외부에서 액세스할 수 없습니다. 예: If else 블록, for 루프 블록 등\n\n예시 (let을 사용한 블록 스코프):\n\n```js\nfunction example() {\n  if (true) {\n    let blockVar = '블록 내부에 있어요';\n    console.log(blockVar); // 접근 가능\n  }\n  console.log(blockVar); // 오류: blockVar가 정의되지 않았습니다\n}\nexample();\n```\n\n- 예시 (const를 사용한 블록 스코프):\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction example() {\n  const PI = 3.14;\n  if (true) {\n    const blockConst = 'I am inside a block';\n    console.log(PI); // Accessible\n    console.log(blockConst); // Accessible\n  }\n  console.log(PI); // Accessible\n  console.log(blockConst); // Error: blockConst is not defined\n}\nexample();\n```\n\n만약 var를 사용한다면 (함수 스코프)\n\n```js\nfunction example() {\n  const PI = 3.14;\n  if (true) {\n    var blockConst = 'I am inside a block';\n    console.log(PI); // Accessible\n    console.log(blockConst); // Accessible\n  }\n  console.log(PI); // Accessible\n  console.log(blockConst); // Error: blockConst is not defined\n}\nexample();\n3.14\nI am inside a block\n3.14\nundefined\n```\n\n```js\nfunction outer() {\n  var outerVar = 'I am outer';\n  function inner() {\n    console.log(outerVar); // Accessible\n  }\n  inner();\n}\nouter(); // 출력: I am outer\n```\n\n<div class=\"content-ad\"></div>\n\n범위의 예시\n\n1. (let을 사용한 루프 변수 범위): 블록\n\n```js\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// 결과: 0\n// 결과: 1\n// 결과: 2\n```\n\n2. var를 사용한 루프 변수 범위: 함수 또는 전역 범위\n\n```js\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// 결과: 3\n// 결과: 3\n// 결과: 3\n```\n\n<div class=\"content-ad\"></div>\n\n3. 중첩된 블록 내에서 let으로 재선언: 블록 스코프\n\n```js\nfunction example() {\n  let x = 10;\n  if (true) {\n    let x = 20;\n  }\n  console.log(x); // 출력: 10\n}\nexample();\n```\n\n4. 중첩된 블록 내에서 var로 재선언: 함수 또는 전역 스코프\n\n```js\nfunction example() {\n  var x = 10;\n  if (true) {\n    var x = 20;\n  }\n  console.log(x); // 출력: 20\n}\nexample();\n```\n\n<div class=\"content-ad\"></div>\n\n5. var 및 let을 사용한 호이스팅:\n\n```js\nconsole.log(x); // 결과: undefined\nvar x = 10;\n```\n\n```js\nconsole.log(x); // 오류: 초기화 전에 'x'에 액세스할 수 없음\nlet x = 10;\n```\n\n6. let 및 const를 사용한 블록 스코프:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction example() {\n  if (true) {\n    const x = 10;\n    console.log(x); // 출력: 10\n  }\n  console.log(x); // 오류: x가 정의되지 않았습니다\n}\nexample();\n```\n\n\n## 2. 클로저:\n\n- 정의: 클로저는 함수가 다른 곳에서 실행되더라도 주변 변수를 \"기억\"하는 것을 말합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction outer() {     \n  var outerVar = 'I am outer';      \n  function inner() {         \n   console.log(outerVar); // outer 함수 외부에서도 호출될 때 접근 가능     \n  }      \n return inner; // inner 함수 반환 \n}  \nvar closureFunc = outer(); // outer 실행, inner 반환 \nclosureFunc(); // 출력: I am outer\n```\n\n2. Loop & Closure: 클로저를 사용하는 루프에서 흔히 범하는 함정.\n\n```js\nfunction createFuncArray() {     \nvar funcArray = [];      \nfor (var i = 0; i < 5; i++) {         \n  funcArray.push(function() {            \n  console.log(i); // 항상 5를 출력하며, 0, 1, 2, 3, 4가 아님        \n });    \n }      \nreturn funcArray; \n}  \nvar myFuncArray = createFuncArray(); \nmyFuncArray[0](); // 출력: 5\n```\n\n루프 예제의 함정을 피하려면, IIFE(즉시 실행 함수 표현)를 사용하여 각 반복마다 클로저를 생성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```javascript\nfunction createFuncArray() {\n   var funcArray = [];\n   for (var i = 0; i < 5; i++) {\n       (function(num) {\n           funcArray.push(function() {\n               console.log(num);\n           });\n       })(i);\n   }\n   return funcArray;\n}\nvar myFuncArray = createFuncArray();\nmyFuncArray[0](); // 출력: 0\n```\n\n자바스크립트를 마스터하기 위해서는 스코프와 클로저를 이해하는 것이 기본이 됩니다. 이러한 예제들은 좋은 시작점이 될 것입니다!\n\n3.\n\n```javascript\nfunction makeCounter() {\n    var count = 0;\n\n    return function() {\n        return ++count;\n    };\n}\n\nvar counter1 = makeCounter();\nconsole.log(counter1()); // 출력: 1\nconsole.log(counter1()); // 출력: 2\n\nvar counter2 = makeCounter();\nconsole.log(counter2()); // 출력: 1 (다시 1부터 시작)\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서:\n\n- makeCounter() 함수는 카운트 변수를 증가시키고 반환하는 내부 함수를 반환합니다.\n- makeCounter()가 호출될 때마다, 자체 카운트 변수를 가진 새로운 렉시컬 환경이 생성되며, 이는 외부 스코프에서 숨겨져 있습니다.\n- counter1과 counter2가 호출될 때, 각각 자체 독립적인 카운트 변수를 가지며, 각각 자체 상태를 독립적으로 유지합니다.\n- 클로저는 내부 함수가 makeCounter() 실행이 끝난 후에도 포함된 스코프의 카운트 변수에 접근할 수 있도록 형성됩니다.\n\n클로저 스코프 체인\n\n모든 클로저에는 세 가지 스코프가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 지역 스코프 (자체 스코프)\r\n- 포함 스코프 (블록, 함수 또는 모듈 스코프가 될 수 있음)\r\n- 전역 스코프\n\n```js\n// 전역 스코프\nconst e = 10;\nfunction sum(a) {\n  return function (b) {\n    return function (c) {\n      // 외부 함수 스코프\n      return function (d) {\n        // 지역 스코프\n        return a + b + c + d + e;\n      };\n    };\n  };\n}\nconsole.log(sum(1)(2)(3)(4)); // 20을 출력합니다.\n```\n\n- 호이스팅\n호이스팅은 변수와 함수의 값을 초기화/할당하기 전에도 변수와 함수의 값을 추출할 수 있게 해주는 개념으로, 이는 실행 컨텍스트의 첫 번째 단계 (메모리 생성 단계 또는 생성 단계)로 인해 발생합니다.\n- JavaScript에서 호이스팅은 기본 동작으로 모든 선언을 코드 실행 전에 해당 범위의 맨 위로 이동시키는 것입니다. 기본적으로 함수와 변수가 선언된 위치와 상관없이 해당 범위의 맨 위로 이동되기 때문에 전역이든 지역이든 상관없이 우리에게 이점을 제공합니다.\n- 참고: JavaScript는 선언을 호이스트하지만 초기화는 호이스트하지 않습니다.\n- JavaScript는 프로그램에서 정의된 모든 변수와 함수에 대해 실행 전에 메모리를 할당합니다.\n\n1. var로 호이스팅:\n\n<div class=\"content-ad\"></div>\n\n- 예제 1: 변수 선언 호이스팅\n\n```js\nconsole.log(x); // 결과: undefined\nvar x = 10;\n```\n\n- 예제 2: 함수 선언 호이스팅\n\n```js\nhoistedFunction(); // 결과: \"호이스팅된 함수\"\nfunction hoistedFunction() {\n  console.log(\"호이스팅된 함수\");\n}\n```\n\n<div class=\"content-ad\"></div>\n\n2. let으로 호이스팅:\n\n- 예제 3: 변수 선언 호이스팅\n\n```js\nconsole.log(x); // 오류: 초기화 전에 'x'에 액세스할 수 없음\nlet x = 10;\n```\n\n- 예제 4: 함수 선언 호이스팅 없음\n\n<div class=\"content-ad\"></div>\n\n```js\nnotHoistedFunction(); // 에러: notHoistedFunction이 정의되지 않았습니다.\nlet notHoistedFunction = function() {\n  console.log(\"호이스팅되지 않은 함수\");\n}\n```\n\n3. const로 호이스팅:\n\n- 예제 5: 변수 선언 호이스팅\n\n```js\nconsole.log(x); // 에러: 초기화 전에 'x'에 접근할 수 없음\nconst x = 10;\n```\n\n<div class=\"content-ad\"></div>\n\n4. 함수 스코프에서 호이스팅:\n\n- 예제 6: 함수 내부의 호이스팅\n\n```js\nfunction example() {\n  console.log(innerVar); // 출력: undefined\n  var innerVar = '내부 변수';\n  console.log(innerVar); // 출력: 내부 변수\n}\nexample();\n```\n\n- 예제 7: 블록 내부의 호이스팅 (let 및 const로 호이스팅 없음)\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction example() {\n  console.log(innerLetVar); // 오류: 초기화되기 전에 'innerLetVar'에 액세스할 수 없습니다\n  let innerLetVar = '내부 let 변수';\n  console.log(innerLetVar); // 위의 오류로 이 줄은 실행되지 않습니다\n}\nexample();\r\n\r\n5. 중첩된 스코프에서 호이스팅:\n\n- 예제 8: 중첩된 함수에서 호이스팅\n\nfunction outer() {\n  console.log(outerVar); // 결과: 정의되지 않음\n  var outerVar = '바깥 변수';\n  inner();\n  function inner() {\n    console.log(outerVar); // 결과: 바깥 변수\n  }\n}\nouter();\n\n<div class=\"content-ad\"></div>\n\n6. 함수 표현식을 이용한 호이스팅:\n\n- 예시 9: 함수 표현식 호이스팅\n\nvar myFunc = function() {\n  console.log(\"함수 표현식\");\n};\nmyFunc(); // 출력: 함수 표현식\n\n7. 다른 스코프 유형에서의 호이스팅:\n\n<div class=\"content-ad\"></div>\n\n- 예제 10: 전역 범위에서 호이스팅\n\nconsole.log(globalVar); // 출력: undefined\nvar globalVar = '전역 변수';\nconsole.log(globalVar); // 출력: 전역 변수\n\n4. ES6 모듈\n모듈을 사용하면 코드를 별도의 파일로 캡슐화하고 그들 간에 기능을 import/export할 수 있습니다.\n\n기본 모듈 내보내기:\n\n<div class=\"content-ad\"></div>\n\n// moduleA.js\nexport function greet() {\n  console.log('Hello');\n}\n\n// main.js\nimport { greet } from './moduleA.js';\ngreet(); // Output: Hello\n\n2. Default Exports:\n\n// moduleB.js\nexport default function greet() {\n  console.log('Hello');\n}\n\n<div class=\"content-ad\"></div>\n\n// main.js\nimport greet from './moduleB.js';\ngreet(); // 출력: Hello\n\n3. 별칭이 지정된 Named Exports:\n\n// moduleC.js\nexport { greet as hello };\n\n// main.js\nimport { hello } from './moduleC.js';\nhello(); // 출력: Hello\n\n<div class=\"content-ad\"></div>\n\n4. 여러 값을 내보내기:\n\n// moduleD.js\nexport function greet() {\n  console.log('Hello');\n}\nexport const PI = 3.14;\n\n// main.js\nimport { greet, PI } from './moduleD.js';\ngreet(); // 결과: Hello\nconsole.log(PI); // 결과: 3.14\n\n<div class=\"content-ad\"></div>\n\n```\n// moduleE.js\nexport default function greet() {\n  console.log('Hello');\n}\nexport const PI = 3.14;\n\n\n\n// main.js\nimport greet, { PI } from './moduleE.js';\ngreet(); // Output: Hello\nconsole.log(PI); // Output: 3.14\n\n\n6. Importing All Exports:\n\n\n// moduleF.js\nexport function greet() {\n  console.log('Hello');\n}\nexport const PI = 3.14;\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// main.js\nimport * as moduleF from './moduleF.js';\nmoduleF.greet(); // 출력: Hello\nconsole.log(moduleF.PI); // 출력: 3.14\n```\n\n7. 부수 효과용 모듈 가져 오기:\n\n```js\n// moduleG.js\nconsole.log('Module G가 로드되었습니다');\n```\n\n```js\n// main.js\nimport './moduleG.js'; \nconsole.log(\"Main.js 파일이 실행 중입니다\")\n// 출력: // 먼저 가져온 파일이 먼저 실행되어\nModule G가 로드되었습니다\nMain.js 파일이 실행 중입니다\n```\n\n<div class=\"content-ad\"></div>\n\n8. 다이나믹 Imports:\n\n```javascript\n// main.js\nconst moduleName = './moduleA.js';\nimport(moduleName).then(module => {\n  module.greet(); // 출력: Hello\n});\n```\n\n9. 모듈 재내보내기:\n\n```javascript\n// moduleH.js\nexport function greet() {\n  console.log('Hello');\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// moduleI.js\nexport { greet } from './moduleH.js';\n// main.js\nimport { greet } from './moduleI.js';\ngreet(); // Output: Hello\n```\n\n10. Conditional Module Loading:\n\n```js\n// main.js\nif (condition) {\n  import('./moduleA.js').then(module => {\n    module.greet(); // Output: Hello\n  });\n} else {\n  import('./moduleB.js').then(module => {\n    module.greet(); // Output: Hi\n  });\n}\n```\n\n  `export default` 구문과 일반 `export` 구문은 JavaScript 모듈에서 값을 내보내는데 모두 사용됩니다. 그러나 다른 모듈에서 가져오고 사용하는 방법에는 차이가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n1. export default:\n\n- export default을 사용하면 모듈에서 하나의 값을 내보낼 수 있습니다.\n- 기본 내보내기를 가져올 때는 가져온 값에 대해 원하는 이름을 사용할 수 있습니다.\n- 기본 내보내기를 가져올 때는 중괄호 '{}'가 필요하지 않습니다.\n- 모듈당 기본 내보내기는 하나만 가질 수 있습니다.\n\n예시:\n\n```js\n// ModuleA.js\nconst value = 'Hello';\nexport default value;\n```  \n\n<div class=\"content-ad\"></div>\n\n```js\n// ModuleB.js\nimport myValue from './ModuleA.js';\nconsole.log(myValue); // 출력: Hello\n```\n\n2. `export default` 없이 (이름 있는 수출):\n\n- 이름 있는 수출을 사용하면 모듈에서 여러 값을 내보낼 수 있습니다.\n- 이름 있는 수출을 가져올 때 내보낸 값과 동일한 이름을 사용해야 합니다.\n- 이름 있는 수출을 가져올 때 중괄호 `{}`를 사용해야 합니다.\n- 모듈 당 여러 이름 있는 수출을 가질 수 있습니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n\n// ModuleA.js\nexport const value1 = 'Hello';\nexport const value2 = 'World';\n\n\n\n// ModuleB.js\nimport { value1, value2 } from './ModuleA.js';\nconsole.log(value1); // Output: Hello\nconsole.log(value2); // Output: World\n\n\n요약하면, export default는 모듈에서 단일 값을 지정하지 않고 내보내는 데 사용되며, named exports는 여러 값을 내보내는 데 사용되며 가져올 때 동일한 이름을 지정해야 합니다. 특정 프로젝트 요구에 따라 유용하게 사용됩니다.\n\nCommonJS와 ES6 모듈을 예제와 함께 비교하여 그 차이를 설명해 보겠습니다:\n\n\n<div class=\"content-ad\"></div>\n\n1. CommonJS:\n\n- CommonJS는 주로 서버 측 개발을 위해 Node.js에서 사용되는 모듈 시스템입니다. 이는 동기적이며 블로킹 방식으로, 모듈은 런타임에서 동기적으로 로드됩니다.\n\nCommonJS 예제:\n\n```js\n// ModuleA.js\nconst greeting = 'Hello';\nfunction sayHello() {\n  console.log(greeting);\n}\nmodule.exports = {\n  greeting,\n  sayHello\n};\n```\n\n<div class=\"content-ad\"></div>\n\n```js\r\n// ModuleB.js\nconst moduleA = require('./ModuleA');\nmoduleA.sayHello(); // Output: Hello\nconsole.log(moduleA.greeting); // Output: Hello\r\n```\n\n2. ES6 Modules:\n\n- ES6 modules are a newer module system introduced in ECMAScript 2015 (ES6). They are asynchronous and support both synchronous and asynchronous module loading.\n\nExample with ES6 Modules:\n\n<div class=\"content-ad\"></div>\n\n```js\n// ModuleA.js\nconst greeting = 'Hello';\nexport function sayHello() {\n  console.log(greeting);\n}\nexport { greeting };\n```\n\n```js\n// ModuleB.js\nimport { sayHello, greeting } from './ModuleA.js';\nsayHello(); // 출력: Hello\nconsole.log(greeting); // 출력: Hello\n```\n\n비교:\n\n동기 vs. 비동기:\n\n<div class=\"content-ad\"></div>\n\n- CommonJS 모듈은 동기적이고 블로킹이며, 실행 시 동기적으로 로드됩니다. 이는 서버 측 프로그래밍과 잘 어울리며, 블로킹 I/O 작업이 일반적인 경우에 적합합니다.\n  \n- ES6 모듈은 구현에 따라 동기적이거나 비동기적일 수 있습니다. 더 유연하며 서버 측 및 클라이언트 측 환경에서 모두 사용할 수 있습니다.\n\n사용 편의성:\n\n- CommonJS 모듈은 module.exports 및 require()를 사용하여 각각 기능을 내보내고 가져옵니다. 이 구문은 직관적이며 이해하기 쉽습니다.\n  \n- ES6 모듈은 export 및 import 문을 사용하여 기능을 내보내고 가져옵니다. 이 구문은 더 현대적이고 언어 명세와 일치하지만, 아직 ES6 모듈을 네이티브로 지원하지 않는 환경에서 변환을 위한 추가 도구가 필요할 수 있습니다.\n\n브라우저 호환성:\n\n<div class=\"content-ad\"></div>\n\n- CommonJS 모듈은 브라우저에서 네이티브로 지원되지 않습니다. CommonJS 코드를 브라우저가 이해할 수 있는 형식으로 변환하기 위해 Browserify나 Webpack과 같은 번들러가 필요합니다.\n- ES6 모듈은 최신 브라우저에서 지원되며 많은 경우 추가 도구 없이 네이티브로 사용할 수 있습니다. 그러나 오래된 브라우저에서 ES6 모듈을 지원하기 위해서는 Babel과 같은 도구를 사용하여 트랜스 파일링이 필요할 수 있습니다.\n\n서버 측 사용 사례:\n\n- Node.js는 주로 서버 측 프로그래밍에 사용되며, 동기적인 성격과 쉬운 사용성 때문에 CommonJS 모듈이 잘 어울립니다. 런타임에서 모듈을 동기적으로 로드할 수 있으며, 서버는 모듈이 로드된 후에 실행을 계속할 수 있습니다.\n- 브라우저 환경에서는 JavaScript 코드가 클라이언트 측에서 실행되며, 응답성을 보장하고 UI 쓰레드를 차단하지 않기 위해 비동기 작업이 선호됩니다. 따라서 웹 개발에서는 비동기적 모듈 로딩을 지원하는 AMD (Asynchronous Module Definition) 또는 ES6 모듈과 같은 다른 모듈 시스템이 일반적으로 사용됩니다.\n\n성능 고려 사항:\n\n<div class=\"content-ad\"></div>\n\n- CommonJS 모듈은 동기적으로 로드되어 브라우저 환경에서 특히 많은 모듈이 있는 대규모 웹 애플리케이션의 성능에 영향을 미칠 수 있습니다. 동기적 모듈 로딩은 페이지 로드 시간이 더 느려지고 응답성이 감소할 수 있습니다.\n- 다른 모듈 시스템인 AMD나 ES6 모듈에서 지원하는 비동기 모듈 로딩은 모듈이 병렬로 로드되도록 허용하여 모듈 종속성을 로드하는 데 걸리는 시간을 줄여 성능을 향상시킵니다.\n\n요약하면, CommonJS 모듈은 동기적 특성과 사용 편의성으로 인해 Node.js에서 서버 측 개발에 적합합니다. ES6 모듈은 더 많은 다양성을 제공하며 남종적 및 클라이언트 측 개발에서 점점 더 채택되고 있으며 비동기 모듈 로딩 및 현대적 구문을 지원합니다.","ogImage":{"url":"/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_0.png"},"coverImage":"/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_0.png","tag":["Tech"],"readingTime":15},{"title":"아름다운 데이터 시각화를 디자인하는 방법 Shirley Wu와의 인터뷰","description":"","date":"2024-06-27 18:14","slug":"2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu","content":"\n\n## 셜리 우는 인기 있는 Data Sketches 프로젝트의 절반으로, 매우 상호 작용적인 데이터 시각화와 데이터 주도적 예술을 만들어냅니다. 여기서 그녀는 뒷면을 엿보게 해주며 배운 교훈을 공유합니다\n\n![이미지](/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_0.png)\n\n셜리 우는 샌프란시스코의 대형 데이터 회사에서 프런트엔드 소프트웨어 엔지니어로 일했을 때 데이터 시각화 JavaScript 라이브러리인 D3.js를 알게 되었습니다. 그 도구를 사랑하게 된 이유는 그것이 그녀의 두 가지 주요 관심사인 미술 - 셜리는 네 살 때 그림과 그림을 시작했습니다 - 그리고 수학을 결합했기 때문입니다. 그녀가 트위터에서 자신을 코드 ¾ 및 예술 ¼로 설명하는 것도 놀랍지 않습니다.\n\n대학을 졸업한 지 4년만에 셜리는 독립을 택하고 데이터 시각화를 전문으로 하는 프리랜서가 되었습니다. 그녀는 문화, 정치, 예술 등 다양한 주제를 다루는 다양한 주제를 시각화합니다. 셜리는 자신의 경력에 큰 영향을 미친 세 가지 프로젝트를 2017년에 발표했습니다. 첫 번째는 Daata Sketches [최근 책으로 출간됨]로, 암스테르담의 데이터 시각화 디자이너 나디에 브레먀와의 협업으로, 이는 두 사람을 데이터 시각화 커뮤니티에 소개했습니다. 매월 주제를 선택하여 시각화를 만들고, 전체 프로세스 - 데이터 준비, 아이디어 스케치 및 실행까지 - 을 문서화하는 것이 아이디어였습니다.\n\n<div class=\"content-ad\"></div>\n\n\"라이트업들은 그냥 생각의 흔적이었어요,\" Shirley는 기억합니다. \"하지만 그것이 사람들이 가장 좋아하는 것이 되었어요. 사람들이 와서 우리에게 말해주면서 '뒷이야기를 들여다보고 연출된 최종 결과물 이상의 변화를 볼 수 있어 얼마나 멋진지'라고 말해줍니다. 아주 빠르게 떠올린 아이디어였지만 프로젝트의 이름을 지정하는 데 오랜 시간이 걸렸어요. 우리는 수많은 이름으로 가득 찬 문서를 가지고 있어요. 그 중 하나인 '셜리와 나디의 시각화 마라톤 대모험'이 제일 좋아하는 이름 중 하나에요. 당연히, 그 이름은 선택하지 않았죠!\"\n\n셜리가 유명해지게 한 두 번째 프로젝트는 뮤지컬 '햄릴턴'의 모든 라인을 인터랙티브 시각화한 것이었어요. 이 프로젝트는 The Pudding을 위해 만들어진 것으로, 이는 문화에서 논의되는 아이디어들을 시각 산문으로 설명하는 온라인 출판물이고, 시갛 산문 스튜디오 Polygraph가 제작했어요. 이 프로젝트는 21,000단어를 관련성과 주제적 통찰을 분석하고 D3, React, HTML5 Canvas를 사용했는데, 이를 통해 셜리는 데이터 수집에 대해 호기심을 갖게 되고 창의적으로 활용하는 법을 배웠어요. 이 프로젝트는 2017년 '정보는 아름답다 어워드'의 예술, 엔터테인먼트 및 대중 문화 부문에서 동상을 수상했으며, Data Sketches는 '기이한 부문'에서 금상을 수상했어요.\n\n<img src=\"/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_1.png\" />\n\n# 효과적인 데이터 시각화 작성 과정\"\n\n<div class=\"content-ad\"></div>\n\n그때 구글이 찾아왔어요. 데이터 저널리스트 알베르토 카이로의 예술적인 지도 아래, 구글 뉴스 랩은 전 세계 최고의 데이터 시각화 디자이너들과 협력했어요. 카이로는 데이터 스케치를 발견하고 셜리를 초대하여 거의 40개국의 10년 간의 여행 검색을 조사하고 상위 검색 문화 장소를 탐험하도록 했어요( explore-adventure.com). 한편 브레머는 구글 번역을 통해 영어로 가장 많이 번역된 단어를 분석했죠(www.beautifulinenglish.com).\n\n이 프로젝트는 셜리가 포트폴리오를 굳혀 기회를 얻도록 도왔고, 그녀의 경력은 정말로 발전하기 시작했어요. 셜리는 더 많은 클라이언트를 유치했을 뿐만 아니라 데이터 시각화에 대해 이야기하기 시작했고, 일본, 네덜란드, 독일, 스페인 등 전 세계의 행사에서 워크샵도 진행하게 되었어요. 이야기하는 동안 실시간 코딩을 보여주며, D3가 보다 친근하다는 것을 보여주는 한편 데이터 시각화를 만드는 데는 많은 연습, 인내력, 그리고 인내심이 필요하다는 것도 보여주었죠. 또한 샌프란시스코 베이지역 D3.js 사용자 그룹을 공동 조직하고, Frontend Master를 위해 온라인 강좌를 제작하여 프론트엔드 개발자들에게 D3의 기초부터 분석 및 자체 맞춤 데이터 시각화 설계까지 알려주었어요.\n\n“클라이언트는 항상 데이터 세트를 가져옵니다.” 셜리는 그녀의 과정을 설명합니다. “그것으로 이야기를 전하거나, 탐험적인 것을 만들고 싶어해요. 대부분은 내부 비즈니스 분석이며, 그들은 고객이 왜 그러는지 알려고 노력하고 있어요. 제가 하는 첫 번째 일은 그들의 목표와 전달하려는 내용 또는 학습 목표를 분석하는 것입니다. 둘째, 그들의 대상 청중과 그 청중의 데이터 지식에 관해 물어봐요.”\n\n그 다음 셜리는 데이터, 디자인 및 코드 세 단계를 거칩니다. 먼저 데이터를 탐색하는 것이 중요하죠. 데이터 수집, 정리, 준비 및 분석에는 Node.js 패키지를 많이 사용합니다. 또한 더 복잡한 프로젝트를 위해 데이터 과학 배경을 가진 내이와 자주 협업합니다. 예를 들어, 수상 경력이 있는 '버스트 아웃(Bussed Out)'이란 미국의 무주택자에 대한 강력한 조사 기사로, 위 대가디언(The Guardian)의 조사론시한 작품에는 약 34,000명의 무주택자의 여정을 조사했죠. 시각화의 많은 부분은 '스크롤 스토리 telling 스타일'로 제작되어 있으며 페이지를 스크롤하면 애니메이션이 트리거됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 펜과 종이에서 JavaScript로\n\n셜리가 데이터와 클라이언트의 목표를 이해하면 펜과 종이, 아이패드를 사용하여 아이디어를 디자인하고 스케치하며 종종 시각적 은유를 활용합니다. 최근에는 Mike Bostock과 함께 만든 대화형 JavaScript 노트북 플랫폼 인 Observable을 사용하기 시작했습니다. 이 플랫폼은 데이터 분석, 시각화 및 탐색에 사용되며 시각화 생성 및 데이터에 대한 가설을 확인 또는 반박하기 위해 시각적 결과를 빠르게 생성하는 Vega-Lite 차트 라이브러리와 함께 사용합니다. 클라이언트와의 상의를 통해 원하는 결과물을 도출할 때까지 이러한 도구를 반복적으로 활용하며, 코드 작성 시에는 D3, Vue 및 GreenSock Animation Platform (GSAP)를 주로 사용하고 있습니다. 또한 이야기를 할 수 있는 JavaScript 라이브러리 Scrollama를 활용하여 스크롤 기반 시각화에 대해 탐구하고 있습니다. 또한 SVG에 큰 관심을 가지고 있습니다.\n\nVue로 이동하기 전에는 React를 사용했던 셜리씨입니다. 그는 매우 늦게 채용된 사람이라고 말합니다. \"저는 관심 있는 몇 가지 도구에 집중합니다,\" 라고 설명합니다. \"이 모든 라이브러리는 그냥 도구상자 안의 도구일 뿐이라고 확신합니다. 작업을 완료하기 위해 필요한 최소한의 도구 집합을 이해하려고 합니다. 많은 사람들이 사용해야 한다고 말하기 전까지는 라이브러리를 사용하지 않습니다. 예를 들어, Sarah Drasner은 GreenSock을 소개해 주었고 그녀의 Intro to Vue.js 워크샵도 참여했습니다. 그리고 약 1년 반 동안 그녀와 몇몇 다른 분들이 Vue를 확인해보라고 권유했을 때, 마침내 확인했습니다! 이후로 모든 프로젝트에 Vue를 사용하고 있습니다. 상호작용하는 시각화 작업을 위해서 정말 많은 의미를 가지고 있습니다.\"\n\n프리랜서가 된 이후, 셜리는 기술 측면 뿐만 아니라 디자인도 발전시켰습니다. 이제는 최종 사용자를 더 많이 고려하며 데이터 시각화를 UI의 최고의 실천법과 결합시켜 작은 세부사항과 개인적인 요소를 첨가합니다.\n\n<div class=\"content-ad\"></div>\n\n“좋은 시각화를 만드는 요소, 사람들이 쉽게 읽을 수 있는 요소, 그리고 우리가 패턴을 인식하는 심리를 활용하는 방법을 배우고 싶었어요. 그래서 데이터 시각화 디자인에 관한 워크숍을 가르치기로 결정했죠. 그러다 몇 권의 책을 읽게 되었어요. 제가 가장 좋아하는 책 중 하나는 Alberto Cairo의 'The Functional Art'입니다. 매우 실용적이고 제 작업 방식을 많이 변화시켰어요.”\n\n# 3차원 데이터 시각화\n\n샤리는 처음으로 물리적 데이터 설치물에 도전했어요. 개념 예술가 Ekene Ijeoma의 2015년 작품인 'Wage Islands'를 보고 나서부터 언젠가 물리적인 작업을 하고 싶어했었어요. 이 작품은 뉴욕시의 지형지도를 검은 잉크로 수중에 가라앉혀 저임금 노동자가 어디서 지불 가능한 임대료를 지출할 수 있는지를 시각화해주는 상호작용 설치물입니다. 이를 통해 저렴한 주택 공급 위기에 대한 주목을 불러일으킵니다.\n\n“그것이 상호작용하는 3D 예술작품이었기 때문에 너무 놀랍더라고요,” 샤리가 말했습니다. “작은 휴대폰이나 데스크탑 화면을 넘어서는 무언가. 제가 물리적 데이터 시각화 아이디어에 진짜 열광하기 시작했어요.”\n\n<div class=\"content-ad\"></div>\n\n셜리는 모든 프로젝트가 2D로 구성되어 있음을 깨닫고, 물리적인 예술 작품을 만들고 싶다면 3차원으로 생각해야 한다는 것을 깨달았습니다. 그래서 Matt DesLauriers의 크리에이티브 코딩 워크샵을 수강하고 배운 기술을 활용하여 세 번째 프로젝트를 만들기 시작했어요. three.js와 WebGL로 구현된 \"Legends\"는 51명의 여성 노벨상 수상자와 그들의 업적을 3D 시각화한 작품입니다. 새로운 기술을 적용하면서 공간, 카메라 및 조명에 대해 많은 것을 배웠어요. 매 수상자는 그들의 위키피디아 페이지에서 추출된 데이터로 표현된 크리스탈로 나타납니다. 수상 카테고리로 색상이 지정되고, '영향'에 따라 크기가 조절되며, 상받은 연대에 따라 위치가 조정됩니다. 한편, 여러 별은 상을 수상한 853명의 남성을 나타냅니다.\n\n![이미지](/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_2.png)\n\n며칠 전에 셜리는 'Legends'를 수정하여 최근 30년 동안의 여성 노벨상 수상자를 나타내는 약간 축소된 물리적 버전을 제작했어요. 이는 창문 설치용으로 laser-cut 나무 꽃으로 표현된 29명의 여성 노벨상 수상자를 특징으로 합니다. 'Flower Power'는 셜리의 스튜디오 동료 앨리스 리와의 협업 작품이며, 독립 일러스트레이터, 예술가이자 2015년 넷 영 디자이너 오브 더 이어인 앨리스 리가 드롭박스, 에어비앤비, 애플 등과 함께 일해 온 경력을 바탕으로 만들어졌습니다. 이는 5x5라는 아트 쇼 및 팝업 샵의 일환으로, 샌프란시스코 미션 디스트릭트에 있는 1099 스튜디오의 다섯 거주자들이 다양한 매체로 구성된 다섯 개의 프로젝트를 선보이는 행사입니다.\n\n![이미지](/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_3.png)\n\n<div class=\"content-ad\"></div>\n\n세번째 디지털 3D 프로젝트는 three.js와 WebGL을 사용해 진행 중입니다. 한 예술 박물관에서 의뢰받아 Legends와 유사한 컨셉으로 홍콩의 여성 작가들을 산으로 표현할 예정입니다(아직 많은 데이터가 부족하다는 점에 주목합니다). 또한 뉴욕 대학교 대화형 통신 프로그램에서의 레지던시도 임박해 있습니다. Shirley의 목표는 자신에게 중요한 주제(예: 성별 균형)를 다루는 의미 있는 시각화를 지속적으로 만드는 것이며, 데이터를 정확하게 표현할 뿐만 아니라 오해할 수 없는 방식으로 표현하는 것입니다.\n\n\"데이터 시각화는 통계와 매우 닮았습니다,\" Shirley는 경계합니다. \"데이터가 올바르게 제시되지 않으면 누군가를 속이는 것이 매우 쉽습니다. 또한 데이터가 결정적이라고 생각하는 경향이 있습니다. 데이터가 말하는 대로라면, 반드시 맞는 것이지만, 대부분의 경우 데이터는 인간에 의해 수집되며 항상 인간적 편향이 있습니다. 아마 그것은 우리가 영원히 제거할 수 없는 것일 수도 있습니다. 그러한 편향을 어떻게 전달할 수 있는지는 정말 흥미로운 도전이 될 것입니다.\"\n\n본 기사는 2019년 net 매거진 321호에 실렸으며, Shirley의 Data Sketches 파트너 Nadieh Bremer 인터뷰도 참조하시기 바랍니다.","ogImage":{"url":"/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_0.png"},"coverImage":"/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_0.png","tag":["Tech"],"readingTime":7},{"title":"HTML5 svg 태그로 이모지 만드는 방법","description":"","date":"2024-06-27 18:04","slug":"2024-06-27-CreatingemojiswithHTML5svgtag","content":"\n\n이미지를 추가한 코드입니다.\n\n`svg` 태그는 서로 다른 모양을 담는 컨테이너이며, 각 모양은 컨테이너 내의 특정 지점에 배치될 수 있습니다. 다음은 `svg` 태그를 살펴봅시다.\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\"></svg>\n```\n\n<div class=\"content-ad\"></div>\n\n폭(width)과 높이(height) 속성은 컨테이너의 크기를 나타냅니다. 폭과 높이를 늘릴수록 이미지의 크기도 컨테이너에 맞게 조정됩니다. Viewbox 속성은 컨테이너의 좌표를 정의합니다.\n\n| viewbox = “x y width height”\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_1.png\" />\n\n기본 모양은 문서 내에 요소를 만들어 컨테이너에 삽입할 수 있습니다. 저희가 이모지를 만들 때 사용할 기본 모양은 원과 사각형입니다.\n\n<div class=\"content-ad\"></div>\n\n우리 이모지를 만드는 데 사용되는 기본 모양입니다\n\n원\n\n원을 만들려면 `circle` 요소를 사용하고 속성을 사용하여 색상과 스타일을 추가합니다.\n\n```js\n<circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"black\"/> \n```\n\n<div class=\"content-ad\"></div>\n\ncx — SVG 태그에서 지정된 너비를 기준으로 x 좌표 지점, cy — SVG 태그에서 지정된 높이를 기준으로 y 좌표 지점, r — 원의 반지름, fill — 색상값을 입력합니다.\n\n사각형\n\n우리는 `rect` 요소를 사용하여 직사각형을 생성하고 속성을 사용하여 색상과 스타일을 추가합니다.\n\n```js\n<rect x=\"35\" y=\"65\" width=\"30\" height=\"5\" fill=\"black\"/>\n```\n\n<div class=\"content-ad\"></div>\n\nx — x 좌표 위치, y — y 좌표 위치, width — 사각형의 너비, height — svg 태그에 대한 높이, fill — 색을 값으로 취합니다.\n\n중립적인 얼굴 이모지\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_2.png\" />\n\n```js\n코드 스니펫\n<svg width=”100\" height=”100\" viewbox=”0 0 100 100\">\n <circle cx=”50\" cy=”50\" r=”40\" fill=”yellow” stroke=”black” stroke-width=”5\"/> //얼굴 \n <circle cx=”35\" cy=”40\" r=”5\" fill=”black”/> //왼쪽 눈\n <circle cx=”65\" cy=”40\" r=”5\" fill=”black”/> //오른쪽 눈\n <rect x=”35\" y=”65\" width=”30\" height=”5\" fill=”black”/> //입\n</svg>\n```  \n\n<div class=\"content-ad\"></div>\n\n웃는 얼굴\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_3.png\" />\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"yellow\" stroke=\"black\" stroke-width=\"5\"/> //얼굴\n  <circle cx=\"35\" cy=\"63\" r=\"5\" fill=\"black\"/> //왼쪽 눈\n  <circle cx=\"65\" cy=\"63\" r=\"5\" fill=\"black\"/> // 오른쪽 눈\n  <circle cx=\"50\" cy=\"40\" r=\"15\"  fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>//입구\n  <rect x=\"30\" y=\"60\" width=\"40\" height=\"18\" fill=\"yellow\" /> //원의 상단 절반을 덮는 사각형\n</svg>\n```\n\n거꾸로 된 웃는 얼굴\n\n<div class=\"content-ad\"></div>\n\n\n![SVG](/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_4.png)\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"yellow\" stroke=\"black\" stroke-width=\"5\"/> \n  <circle cx=\"50\" cy=\"45\" r=\"15\"  fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>\n  <rect x=\"30\" y=\"45\" width=\"40\" height=\"18\" fill=\"yellow\" /> //to hide the lower part of the circle\n  <circle cx=\"35\" cy=\"67\" r=\"5\" fill=\"black\"/> \n  <circle cx=\"65\" cy=\"67\" r=\"5\" fill=\"black\"/>\n</svg>\n```\n\nFrowning face\n\n![SVG](/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"yellow\" stroke=\"black\" stroke-width=\"5\"/> \n  <circle cx=\"35\" cy=\"37\" r=\"5\" fill=\"black\"/> \n  <circle cx=\"65\" cy=\"37\" r=\"5\" fill=\"black\"/>\n  <circle cx=\"50\" cy=\"69\" r=\"11\"  fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>\n  <rect x=\"32\" y=\"70\" width=\"36\" height=\"13\" fill=\"yellow\" /> //아래 반원을 가리는데 사용됩니다\n</svg>\n```\n\n놀라운 모습\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_6.png\" />\n\n```js\n<svg width=\"100\" height=\"100\" viewbox=\"0 0 100 100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"yellow\" stroke=\"black\" stroke-width=\"5\"/> \n  <circle cx=\"35\" cy=\"37\" r=\"5\" fill=\"black\"/> \n  <circle cx=\"65\" cy=\"37\" r=\"5\" fill=\"black\"/>\n  <circle cx=\"50\" cy=\"65\" r=\"10\"  fill=\"black\" />\n</svg>\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_7.png\" />\n\n읽어 주셔서 감사합니다. 즐거운 하루 되세요!","ogImage":{"url":"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_0.png"},"coverImage":"/assets/img/2024-06-27-CreatingemojiswithHTML5svgtag_0.png","tag":["Tech"],"readingTime":4},{"title":"이미지 없이 CSS Clip Path로 DOM에 멋진 모양 만드는 방법","description":"","date":"2024-06-27 18:02","slug":"2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages","content":"\n\n## 하트, 별, 그리고 마법의 부적 - 아니면 추가로 화려한 다각형도 괜찮아요.\n\n![shape](/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_0.png)\n\n# 소개\n\n몇 년 전까지, 웹사이트의 배경 모양이나 섹션이 직사각형이 아닌 것들을 원한다면 대부분 디자이너에게 필요한 정적 PNG 또는 JPEG 이미지를 제공받아야 했을 것입니다. 그러나 이후로 CSS는 나아졌어요, 친구들아.\n\n<div class=\"content-ad\"></div>\n\n웹사이트를 업데이트하던 중 페이지 내용을 순수한 흰색과 부드러운 회색이 번갈아가며 나타나는 다른 색상의 배경 섹션으로 분할하는 디자인 변경 작업을 하고 있었어요. 제 디자인 모형에는 일반 블록 요소처럼 페이지를 가로지르는 것이 아니라 오른쪽 위쪽으로 기울어지고 있는 섹션이 하나 포함되어 있었어요.\n\n이제 제가 디자이너에게 배경 이미지를 만들어 달라고 요청할 수도 있었지만, 대신 CSS의 clip-path를 사용하여 나 혼자서 할 수 있는지 확인해 보고 싶었어요. 그리고 놀랍게도 CSS clip-path로 가능했어요.\n\nDOM에서 흥미로운 모양과 시각 요소는 더 이상 디자이너만의 전유물이 아니에요. CSS clip-path와 같은 도구를 이용해 개발자들도 요소를 재구성할 수 있게 되었고, 어떻게 하는지 여러분께 보여드릴게요.\n\n# CSS clip-path\n\n<div class=\"content-ad\"></div>\n\nCSS clip-path 속성에 익숙하지 않은 경우에는 저와 같이 하나씩 알아가면서 그 클리핑 영역을 만들어 낼 수 있습니다. 요소의 어떤 부분이 표시되어야 하는지 설정하는 클리핑 영역을 생성합니다. 영역 내에 있는 부분은 표시되고, 외부에 있는 부분은 숨깁니다.\n\n![이미지](/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_1.png)\n\nclip-path 속성은 다양한 값들을 받아들일 수 있습니다:\n\n- `clip-source`: SVG 요소 url 같은 값을 받아들입니다.\n- `geometry-box`: margin-box나 border-box와 같은 값들을 받아들입니다.\n- `basic-shape`: circle()나 rect()와 같은 값을 받아들입니다.\n- global-values: 상속받은 값이나 되돌아가는(revert) 값을 받아들입니다.\n\n<div class=\"content-ad\"></div>\n\n`geometry-box` 및 `basic-shape` 값을 마찬가지로 한 clip-path에 결합할 수도 있습니다.\n\n```js\n/* 이 CSS는 두 가지 다른 클립 경로 속성을 결합합니다 */\nclip-path: padding-box circle(50px at 0 100px);\n```\n\n`basic-shape` 속성 중 하나인 clip-path는 polygon()을 수용하며, 이것이 내가 기울어진 배경 섹션에 필요한 솔루션이 되었습니다.\n\n# CSS로 재생성해야 하는 다각형\n\n<div class=\"content-ad\"></div>\n\n\n![사진](/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_2.png)\n\n위의 이미지는 CSS clip-path의 polygon() 속성을 사용하여 재현해야 했던 회색 배경 섹션의 스크린샷입니다. 그리고 제가 처음으로 해야 했던 것은 CSS를 적용할 몇 가지 HTML 요소를 만드는 것이었습니다.\n\n## HTML 및 CSS 설정\n\n제가 작업한 사이트는 정적 사이트 생성기 Hugo, Go 기반 프레임워크를 사용했습니다. Hugo는 템플릿을 사용하여 사이트의 HTML을 렌더링하므로 아래 예시 코드는 HTML을 알고 있다면 상당히 익숙할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n여기는 페이지의 “퍼즐 섹션”이라고 내가 지은 별명으로 불리는 코드입니다. 왜냐하면 이 섹션 전면에 퍼즐 조각이 있기 때문이에요. 이 기사를 명확하게 하기 위해, 템플릿에 주입된 Go 변수를 생성된 HTML로 대체했어요.\n\nsingle.html\n\n```html\n<div class=\"about-body\">\n    <!-- 위쪽에 더 많은 HTML 요소들 있음  -->\n\n    <section class=\"puzzle-section section\">\n      <div class=\"container\">\n        <div class=\"row\">\n          <div class=\"col-12 col-md-6 col-lg-6\">\n              <h4 class=\"mb-3\">\n                Lorem ipsum dolor\n              </h4>\n              <p class=\"mb-5\">\n                Sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Ipsum dolor sit amet consectetur adipiscing elit pellentesque.\n              </p>\n              <h4 class=\"mb-3\">\n                Duis aute irure dolor in reprehenderit\n              </h4>\n              <p class=\"mb-5\">\n                in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Consectetur adipiscing elit pellentesque habitant morbi tristique senectus et.\n              </p>\n          </div>\n          <div\n            class=\"col-sm-8 offset-sm-2 col-md-6 offset-md-0 col-lg-6 offset-lg-0\"\n          >\n            <img\n              class=\"img-fluid\"\n              src=\"/images/about/puzzle-pieces.png\"\n              alt=\"Puzzle pieces\"\n            />\n          </div>\n        </div>\n      </div>\n    </section>\n\n     <!-- 아래에 더 많은 HTML 요소들 있음  -->\n  </div>\n```\n\n이 코드 섹션은 비교적 간결하지만, 논의할 가치가 있어요. HTML 요소들 외에도, 다양한 CSS 클래스가 있습니다. 이 CSS 클래스들은 반응형 웹 디자인을 위한 최초의 오픈 소스 CSS 프레임워크 중 하나인 부트스트랩 라이브러리에서 제공됐어요.\n\n<div class=\"content-ad\"></div>\n\nabout-body와 같이 사용하여 사용자 정의 스타일을 추가한 사용자 정의 클래스 중 container, row, col-12 또는 col-md-6, mb-5, mb-3과 같은 클래스가 있습니다.\n\n후자의 클래스들은 모두 Bootstrap 클래스인데, 이는 뷰포트의 폭이 일정 이상인 경우 텍스트 및 이미지 요소가 페이지 폭을 공유하도록 하거나 `p` 태그에 특정 양만큼의 하단 여백을 적용하는 역할을 합니다 (col-md-6, mb-3 또는 mb-5).\n\n그러나이 게시물에서는 Bootstrap 클래스는 중요하지 않습니다. 여기서 주목해야 할 클래스는 모든 텍스트와 퍼즐 조각 이미지를 감싸는 puzzle-section입니다.\n\n이 puzzle-section 클래스에는 우리가 clip-path 속성을 추가하여 텍스트와 이미지 뒤에 연한 회색 배경을 표시하고 약간 기울어진 오른쪽 위의 디자인을 나타낼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## CSS clip-path를 사용하여 퍼즐 섹션의 모양을 변경해 보세요!\n\n일반적인 직사각형 `div`를 균형 잡히지 않은 모양으로 스타일링하는 방법에 대해 잘 몰랐기 때문에 온라인에서 솔루션을 찾기 시작했습니다. 그러더니 유용한 인터랙티브 clip-path 중심 사이트인 CSS clip-path maker를 발견했어요.\n\n![CSS Clip Path](/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_3.png)\n\n이 CSS clip-path maker 웹사이트는 다양한 미리 설정된 모양, 조정 가능한 이미지 크기 및 배경, 그리고 현재 표시된 이미지의 꼭짓점을 원하는 형태로 끌어서 조합할 수 있는 기능을 제공합니다. 화면 하단의 가로선은 정확한 clip-path CSS 값들을 보여주며, 이를 복사하여 개인 프로젝트의 CSS에 붙여넣을 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n저는 시작점으로 평행사변형 프리셋 모양을 선택했고, 그 후에 코너를 끌어서 원래부터 다시 만들려고 했던 배경 섹션의 각도와 일치시켰어요. 정확해 보였을 때, 페이지 아래의 CSS 라인을 클립보드에 복사했어요.\n\n내 프로젝트의 SCSS 파일에, 복사한 클립패스 CSS를 추가하여 연한 회색 배경색 속성과 텍스트 및 퍼즐 조각 이미지가 페이지에서 숨쉴 공간을 가질 수 있도록 일부 패딩을 주었어요.\n\nabout.scss\n\n```js\nabout-body {\n  // 이 화이트는 전체 웹페이지의 흰 배경색을 설정해요\n  background-color: white; \n\n  .puzzle-section {\n    // 클립패스 메이커 웹사이트에서 복사한 클립패스 코드\n    clip-path: polygon(0 0, 100% 0%, 100% 75%, 0% 100%);\n    background-color: light-grey;\n    padding: 2rem 0 10rem 0;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nclip-path에 대한 조금의 CSS만 있으면 정사각형 DOM 요소가 완벽하지 않은 다각형으로 변하는 데 필요한 모든 것이었습니다. 꽤 준수한 작업이네요!\n\n# 결론\n\nCSS는 이미지, 비디오 및 사용자 정의 디자인 요소에 자주 의존하지 않고 웹 개발자들이 할 수 있는 것의 한계를 넓히고 있습니다. 그리고 혼자서 멋진 디자인 작업을 어떻게 수행할지 찾아내는 만족감은 꽤 도전적인 일처럼 느껴집니다.\n\n최근 이것의 한 예는 CSS clip-path 속성을 사용하여 텍스트와 이미지를 위한 배경 상자를 만들어 아래쪽 가장자리가 불규칙한 박스를 만드는 것이었습니다. 모든 모양과 크기의 clip-path를 해독하는 데 전념한 대화형 웹 사이트의 도움으로, 약간 기울어진 이 다각형을 빠르게 처리할 수 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 작은 사이트나 코드 조각을 제공하여 다른 개발자가 매우 특정한 문제를 해결할 때 도움이 되는 분들을 진심으로 감사하게 생각합니다. 여러분 덕분에 인터넷이 더 나아지고 있어요.\n\n몇 주 후에 다시 방문해주세요. 더 많은 JavaScript, React, IoT 또는 웹 개발 관련 내용을 공유할 거예요.\n\n제 글을 절대 놓치고 싶지 않으시면 제 뉴스레터에 가입해주세요: https://paigeniedringhaus.substack.com\n\n읽어주셔서 감사합니다. CSS의 힘만으로 DOM에서 요소의 모양을 바꾸는 법을 배우는 것이 여러분에게 도움이 되었기를 바라며 저도 큰 도움이 되었던 것처럼요.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료 및 추가 자료\n\n- MDN 문서, CSS clip-path\n- CSS clip-path 생성기 웹사이트\n\n원문: https://www.paigeniedringhaus.com.","ogImage":{"url":"/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_0.png"},"coverImage":"/assets/img/2024-06-27-LeanonCSSClipPathtoMakeCoolShapesintheDOMwithoutImages_0.png","tag":["Tech"],"readingTime":7},{"title":"React에서 Angular로 전환하는 개발자를 위한 10가지 팁","description":"","date":"2024-06-27 17:59","slug":"2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular","content":"\n\n\n![이미지](/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png)\n\nReact에서 Angular로 전환하는 것은 개발자들에게 도전적이면서 보상이 있는 여정일 수 있습니다. 각 프레임워크마다 고유한 원칙, 구문 및 관습이 있어 전환 과정은 신중히 진행되어야 합니다.\n\nFever에서는 특정 언어나 프레임워크의 경험보다는 기술에 기반하여 최고 수준의 엔지니어를 채용하기를 우선시합니다. 따라서, React에서 Angular로의 전환은 우리 엔지니어들에게 일상적인 일입니다.\n\n본 글에서는 React에서 Angular로의 개발자 전환을 원활히 돕기 위해 우리에게 유용했던 10가지 팁을 살펴보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 팁 01: ngIf 구조 지시문 사용하기\n\n● React에서는 조건부 렌더링을 사용하여 컴포넌트나 요소를 렌더링할지 여부를 결정할 수 있습니다. 다음은 이를 구현한 예시입니다:\n\n```js\nconst ConditionalComponent = ({ shouldRender }) => {\n  return shouldRender ? <div>조건에 따라 렌더링됩니다</div> : null;\n};\n```\n\n● Angular에서는 템플릿에서 *ngIf 구조 지시문을 사용하여 요소를 조건부로 렌더링하는 것이 일반적합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<ng-container *ngIf=\"shouldRender\">\n  This is rendered conditionally\n</ng-container>\n```\n\n*Angular v17 will have a new built-in control flow template syntax for if block conditionals\n\n## Tip 02: Using ngFor structural directive\n\n- In React, you use the map function to iterate over an array and create a list of elements.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst ListComponent = ({ items }) => {\n  return (\n    - 목록\n      - {items.map((item, index) => (\n        - <li key={item.id}>\n          - {index + 1}. {item.name}\n      - ))}\n  );\n};\n```\n\n* Angular에서는 *ngFor 구조 지시자를 사용하여 템플릿에서 요소를 반복할 수 있습니다.\n\n```js\n- 목록\n    - <li *ngFor=\"let item of items; let i = index\">\n        { i + 1 }. { item.name }\n    - </li>\n```\n\n* Angular v17에서는 블록 반복기를 위한 새로운 내장 제어 흐름 템플릿 구문이 제공될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 팁 03: TrackByFunction을 사용하여 목록 렌더링 개선하기:\n\n● React에서 요소 목록을 렌더링할 때는 각 요소에 고유한 key 속성을 할당해야 합니다. 이를 통해 React가 각 요소를 고유하게 식별하고 효율적으로 DOM을 업데이트할 수 있습니다.\n\n```js\nconst ListComponent = ({ items }) => {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={item.id}>\n          {index + 1}. {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n};\n```\n\n● Angular에서는 trackBy 함수를 사용하여 동일한 결과를 얻을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n\ninterface ListItem {\n  id: number;\n  name: string;\n}\n\n@Component({\n  selector: 'app-list',\n  template: `\n    <ul>\n      <li *ngFor=\"let item of items; trackBy: trackByFn\">\n        { item.id } - { item.name }\n      </li>\n    </ul>\n  `,\n})\nexport class ListComponent {\n  items: Array<ListItem> = [ \n    { id: 1, name: 'Item 1' }, \n    { id: 2, name: 'Item 2' }\n  ];\n\n  trackByFn(index: number, item: ListItem): number {\n    return item.id; // Return a unique identifier for each item\n  }\n}\n```\n\n## 팁 04: 프로퍼티 바인딩\n\n● React에서는 데이터가 부모 구성 요소에서 자식 구성 요소로 props로 전달됩니다. 자식 구성 요소는 이러한 props을 받아 렌더링에 사용합니다.\n\n```js\nimport React from 'react';\n\nconst ImageComponent = ({ imageUrl }) => {\n  return <img src={imageUrl} alt=\"React Image\" />;\n};\n\nexport default ImageComponent;\n```\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 다음은 Angular에서 속성 바인딩을 사용하는 방법입니다. 속성 바인딩은 컴포넌트의 속성을 HTML 요소 속성이나 디렉티브에 바인딩하는 데 사용됩니다.\n\n```js\n<img [src]=\"imageUrl\" alt=\"Angular Image\" />\n```\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: '<img [src]=\"imageUrl\" alt=\"Angular Image\" />',\n})\nexport class ExampleComponent {\n  @Input() imageUrl: string;\n}\n```\n\n## 팁 05: 이벤트 바인딩\n\n<div class=\"content-ad\"></div>\n\n● React에서는 콜백 함수를 전달하기 위해 props를 사용하여 동일한 기능을 구현할 수 있습니다.\n\n```js\nconst ChildComponent = ({ onCustomEvent }) => (\n  <button onClick={onCustomEvent}>Click me</button>\n);\n\nconst App = () => {\n  const [message, setMessage] = useState('');\n\n  const handleCustomEvent = () => {...};\n\n  return (\n    <ChildComponent onCustomEvent={handleCustomEvent} />\n  );\n};\n```\n\n● Angular에서는 이벤트 바인딩을 통해 사용자 작업 (키 입력, 마우스 이동, 클릭, 터치 등)을 감지하고 대응할 수 있습니다.\n\n```js\n@Component({\n  selector: 'app-child',\n  template: `\n    <button (click)=\"doSomething()\">Click me</button>\n  `,\n})\nexport class ChildComponent {\n  doSomething() {...}\n}\n```\n\n<div class=\"content-ad\"></div>\n\n만일 자료를 부모 컴포넌트로 전달하고 싶다면, 자식 컴포넌트에서 @Output() 데코레이터를 사용할 수 있어요. 이 데코레이터가 있는 속성은 EventEmitter 유형이어야하며, 사용자 정의 이벤트를 발생시킬 때 사용돼요.\n\n```js\n@Component({\n  selector: 'app-child',\n  template: `\n    <button (click)=\"customEvent.emit()\">Click me</button>\n  `,\n})\nexport class ChildComponent {\n  @Output() customEvent: EventEmitter<void> = new EventEmitter<void>();\n}\n\n@Component({\n  selector: 'app-root',\n  template: `<app-child (customEvent)=\"handleCustomEvent()\"></app-child>`,\n})\nexport class AppComponent {\n  handleCustomEvent(): void {...}\n}\n```\n\n## 팁 06: 의존성 주입\n\n● React에서 의존성 주입을 관리하는 일반적인 방법 몇 가지가 있어요:\n\n<div class=\"content-ad\"></div>\n\n- Props\n- Context API\n- Higher-Order Components (HOCs)\n- Render Props\n- React Hooks\n\n● Angular에서는 의존성 주입이 프레임워크의 핵심 부분입니다. Angular는 서비스의 인스턴스를 생성하고 관리하는 역할을 담당하는 인젝터를 제공합니다. 간단한 예시를 확인해보세요:\n\n```js\n@Injectable({\n  providedIn: 'root',\n})\nexport class MyService {\n  getData(): string {\n    return 'Angular 서비스로부터의 데이터';\n  }\n}\n\n@Component({\n  selector: 'app-root',\n  template: `<p>{ message }</p>`,\n})\nexport class AppComponent implements OnInit {\n  message: string;\n  private readonly myService = inject(MyService);\n\n  ngOnInit(): void {\n    this.message = this.myService.getData();\n  }\n}\n```\n\n## 팁 07: 리졸버\n\n<div class=\"content-ad\"></div>\n\nReact에는 Angular의 resolver 기능과 직접적인 동등물이 없습니다. 데이터 가져오기는 보통 컴포넌트 자체 내에서 또는 라이프사이클 메서드, 훅, 또는 외부 라이브러리의 도움으로 처리됩니다. React 컴포넌트에서 사용자 정의 훅을 사용한 간단한 예제가 여기 있어요:\n\n```js\nconst useCustomHook = () => {\n  const [data, setData] = useState(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch('https://api.example.com/data');\n        const result = await response.json();\n        setData(result);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n      }\n    };\n    fetchData();\n  }, []); // 의존성 배열이 비어있어서 효과가 마운트시 한 번만 실행됨\n  return data;\n};\n\nconst MyComponent = () => {\n  const { data } = useCustomHook();\n  return (\n    <div>\n      {data ? (\n        <p>Data from React component: {data}</p>\n      ) : (\n        <p>Loading...</p>\n      )}\n    </div>\n  );\n};\nexport default MyComponent;\n```\n\nAngular에서는 resolver를 사용하여 라우트가 활성화되기 전 데이터를 가져와 해당 컴포넌트가 렌더링되기 전에 필요한 데이터를 보장합니다.\n\n```js\n@Injectable({\n  providedIn: 'root',\n})\nexport class MyDataResolver implements Resolve<string> {\n  private readonly myDataService = inject(MyDataService);\n\n  resolve(): Observable<string> {\n    return this.myDataService.fetchData();\n  }\n}\n\nconst routes: Routes = [\n  {\n    path: 'my-route',\n    component: MyComponent,\n    resolve: {\n      myData: MyDataResolver,\n    },\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n<div class=\"content-ad\"></div>\n\n## 팁 08: 인터셉터\n\n● React에서는 Redux와 같은 상태 관리 미들웨어를 통해 HTTP 인터셉터 기능을 구현할 수 있습니다. 미들웨어는 액션이 리듀서에 도달하기 전에 해당 액션을 가로챌 수 있고 수정하거나 새로운 액션을 디스패치하거나 비동기 작업을 수행할 수 있습니다. Redux 미들웨어를 사용한 간단한 예시를 살펴보겠습니다:\n\n```js\nconst myMiddleware = (store) => (next) => (action) => {\n  // 액션 수정 또는 다른 작업 수행\n\n  // 예를 들어, 액션이 리듀서에 도달하기 전에 액션을 로깅하는 경우\n  console.log('Action:', action);\n\n  // 다음 미들웨어나 리듀서에 액션 전달\n  return next(action);\n};\n\nexport default myMiddleware;\n```\n\n```js\nconst store = createStore(rootReducer, applyMiddleware(myMiddleware));\n\nexport default store;\n```\n\n<div class=\"content-ad\"></div>\n\n● Angular에서 인터셉터는 HttpClient와 등록하여 HTTP 요청이나 응답을 가로챌 수 있는 서비스입니다. React의 미들웨어와는 달리 내장된 HTTPClient에만 작동합니다.\n\n인터셉터를 사용하면 모든 HTTP 요청이나 응답에 전역적으로 공통 동작이나 수정을 적용할 수 있습니다. 아래는 간단한 Angular 인터셉터 예제입니다:\n\n```js\n@Injectable()\nexport class MyInterceptor implements HttpInterceptor {\n  intercept(\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    // 요청을 수정하거나 응답을 전역적으로 처리합니다\n\n    // 예를 들어, 각 요청에 사용자 지정 헤더 추가\n    const modifiedRequest = request.clone({\n      setHeaders: { 'X-Custom-Header': 'Custom Value' },\n    });\n\n    return next.handle(modifiedRequest);\n  }\n}\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule, HttpClientModule],\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: MyInterceptor,\n      multi: true,\n    },\n  ],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n## 팁 09: Rxjs\n\n<div class=\"content-ad\"></div>\n\nRxJS 라이브러리는 비동기 및 이벤트 기반 프로그래밍을 더 선언적이고 조립 가능한 방식으로 처리할 수 있는 도구 세트를 제공합니다. Angular에서 널리 사용됩니다. 간단히 설명하면 다음과 같습니다:\n\nObservables:\n\n- Observable은 시간에 따른 데이터 스트림의 표현입니다.\n- 비동기적으로 여러 값을 방출할 수 있습니다.\n- Observables는 이벤트, 프로미스 또는 수동으로 생성할 수 있는 다양한 소스에서 만들어질 수 있습니다.\n\nObservers:\n\n<div class=\"content-ad\"></div>\n\n- Observer는 Observable에 가입하여 Observable이 방출한 변경 사항이나 새 값에 대한 알림을 받습니다.\n- Observer에는 next(다음 값 처리), error(오류 처리), complete(작업 완료 처리)와 같이 세 가지 콜백 함수가 있습니다.\n\n주요 RxJS 연산자:\n\n- map: 제공된 함수를 사용하여 Observable이 방출한 값을 변환합니다.\n- filter: 주어진 조건에 따라 Observable이 방출한 값을 필터링합니다.\n- mergeMap: 각 소스 값을 Observable로 프로젝트하고 결과 Observable을 하나의 Observable 스트림으로 병합합니다.\n- combineLatest: 여러 Observables에서 최신 값들을 합쳐 하나의 Observable로 조합합니다.\n\n```js\nconst App = () => {\n  const [data, setData] = useState('');\n\n  useEffect(() => {\n    // 버튼 클릭에서 Observable 생성\n    const buttonClick$ = fromEvent(document.getElementById('myButton'), 'click');\n\n    // 각 클릭 이벤트를 처리하고 API 호출을 트리거하는 mergeMap 사용\n    const apiCall$ = buttonClick$.pipe(\n      mergeMap(() => fetch('https://api.example.com/data')),\n      mergeMap(response => response.json())\n    );\n\n    // API 응답에서 원하는 특정 데이터를 추출하기 위해 map을 사용\n    const subscription = apiCall$.subscribe(\n      responseData => setData(responseData.data),\n      error => console.error('오류:', error)\n    );\n\n    return () => subscription.unsubscribe(); // 컴포넌트 해제 시 정리\n  }, []);\n\n  return (\n    <div>\n      <button id=\"myButton\">클릭하세요</button>\n      <p>{data}</p>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 연산자의 전체 리스트를 확인할 수 있습니다: [Operators List](https://rxjs.dev/guide/operators#categories-of-operators).\n\n## 팁 10: Rxjs 구독 취소 시점\n\nAngular에서 메모리 누수를 방지하기 위해 옵저버블의 구독을 해제하는 것이 중요합니다. 옵저버블을 구독하면 옵저버와 옵저버블 사이에 연결이 생성되는데, 이 연결은 더 이상 필요하지 않을 때 닫혀야 합니다. 구독을 해제하지 않으면 잔류 참조와 메모리 누수로 이어질 수 있습니다.\n\nAngular에서 구독을 취소해야 하는 일반적인 시나리오 몇 가지를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n- 컴포넌트 파괴:\n\n```js\n@Component({\n  selector: 'app-my-component',\n})\nexport class MyComponent implements OnInit, OnDestroy {\n  private subscription: Subscription;\n\n  ngOnInit() {\n    this.subscription = someObservable.subscribe(data => {\n      // 데이터 처리\n    });\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n2. 무한 옵저버블:\n\n```js\nexport class MyComponent implements OnInit, OnDestroy {\n  private subscription: Subscription;\n\n  constructor(private infiniteObservableService: InfiniteObservableService) {}\n\n  ngOnInit() {\n    this.subscription = interval(1000).pipe(\n      map((value) => {\n        // 필요에 따라 발행된 값 변환\n        return value * 2;\n      })\n      .subscribe((data) => {\n        this.infiniteData = data;\n      });\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n3. 라우터 이벤트:\n\n```js\n@Component({\n  selector: 'app-my-component',\n})\nexport class MyComponent implements OnDestroy, OnInit {\n  private subscription: Subscription;\n  private router = inject(Router);\n\n  ngOnInit(): void {\n    this.subscription = this.router.events.subscribe(event => {...});\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n4. AsyncPipe\n\nAngular에서 async 파이프는 Observable에 대한 구독을 자동화하고 구성 요소가 파기될 때 구독 해제를 처리합니다. 이는 템플릿에서 비동기 데이터를 다루는 과정을 간소화합니다.\n\n<div class=\"content-ad\"></div>\n\n`async` 파이프를 활용하면 Angular 템플릿에서 Observable에 직접 구독하고 값을 끊임없이 바인딩할 수 있습니다:\n\n```js\n<div>{ observable$ | async }</div>\n```\n\n실제로는 async 파이프가 구독 및 구독 해제 수명주기를 관리해주므며, 깔끔한 자원 관리를 보장하고 메모리 누수를 방지합니다.\n\n- Angular에는 고유한 용어가 있습니다. 익숙하지 않다면 Angular 용어집이 유용할 것입니다: Angular 용어집.\n\n<div class=\"content-ad\"></div>\n\n# 영감을 받은 곳:\n\n[https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3](https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3)\n\n[https://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam](https://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam)\n\n# 참고:\n\n<div class=\"content-ad\"></div>\n\nhttps://angular.io/api/common/NgIf\n\nhttps://angular.io/guide/control_flow#if-block-conditionals\n\nhttps://angular.io/api/common/NgFor\n\nhttps://angular.io/guide/control_flow#for-block---repeaters\n\n<div class=\"content-ad\"></div>\n\n- [TrackByFunction](https://angular.io/api/core/TrackByFunction)\n- [Property Binding](https://angular.io/guide/property-binding)\n- [Event Binding](https://angular.io/guide/event-binding)\n- [inputs-outputs#sending-data-to-a-parent-component](https://angular.io/guide/inputs-outputs#sending-data-to-a-parent-component)\n\n<div class=\"content-ad\"></div>\n\n[https://angular.io/api/core/EventEmitter](https://angular.io/api/core/EventEmitter)\n\n[https://angular.io/api/core/Output](https://angular.io/api/core/Output)\n\n[https://angular.io/guide/http-intercept-requests-and-responses](https://angular.io/guide/http-intercept-requests-and-responses)\n\n[https://angular.io/api/common/http/HttpClient](https://angular.io/api/common/http/HttpClient)\n\n<div class=\"content-ad\"></div>\n\nhttps://angular.io/api/router/Resolve\n\nhttps://angular.io/guide/rx-library\n\nhttps://rxjs.dev/guide/operators#categories-of-operators\n\nhttps://angular.io/api/common/AsyncPipe\n\n<div class=\"content-ad\"></div>\n\nhttps://angular.io/guide/glossary","ogImage":{"url":"/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png"},"coverImage":"/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png","tag":["Tech"],"readingTime":14},{"title":"TypeScript Strict Mode 리팩토링 없이 몇 달 동안 바로 켜야 하는 이유","description":"","date":"2024-06-27 17:58","slug":"2024-06-27-TypeScriptStrictModeTurnItOnImmediatelyWithoutRefactoringforMonths","content":"\n\nTypeScript은 JavaScript 응용 프로그램에 유형 안전성과 코드 문서화를 향상시킵니다. 그러나 이전 프로젝트에서는 엄격 모드가 활성화되지 않을 수 있으며, 이는 유형 안전성의 모든 이점을 제대로 활용할 수 없게 할 수 있습니다. 이것은 새로운 사용자의 진입 장벽을 낮추지만, 일부 버그를 컴파일 시간에 감지하지 못하게 합니다.\n\n![이미지](/assets/img/2024-06-27-TypeScriptStrictModeTurnItOnImmediatelyWithoutRefactoringforMonths_0.png)\n\n## 소프트웨어의 아키텍처가 경제에 미치는 영향\n\n마틴 파울러(Martin Fowler)의 소프트웨어 아키텍처에 대한 인기 있는 정의 중 하나는:\n\n<div class=\"content-ad\"></div>\n\n이러한 결정들은 시간이 지남에 따라 새로운 기능을 추가하는 데 필요한 비용과 노력에 상당한 영향을 미칩니다.\n\n소프트웨어 엔지니어 및 아키텍트로서, 우리의 목표는 내부 코드 품질을 유지하여 코드베이스가 유지 가능하게 하는 것입니다. 이는 빠른 기능 개발과 지속적인 배포를 용이하게 합니다.\n\n## TypeScript의 Strict Mode의 장점\n\nTypeScript의 strict 플래그는 여러 중요한 검사를 활성화하는 일종의 통합 플래그입니다.\n\n<div class=\"content-ad\"></div>\n\n- noImplicitAny\n- noImplicitThis\n- strictNullChecks\n- strictPropertyInitialization\n- strictBindCallApply\n- strictFunctionTypes\n\n이러한 체크는 유형 안전성을 향상시켜 버그를 줄이고 코드 기반을 더 견고하고 유지 관리 가능하게 만듭니다. 그러나 큰 기존 프로젝트에서 엄격 모드를 활성화하면 수천 개의 오류가 발생할 수 있어 한 번에 모두 수정하는 것이 현실적이지 않을 수 있습니다.\n\n## 즉시 켜면 수천 개의 오류가 발생할 수 있습니다\n\n수백 개 또는 수천 개의 TypeScript 파일로 구성된 중대규모 앱을 개발 중이라면 즉시 엄격 모드를 활성화하는 것이 현실적이지 않을 수 있습니다. 컴파일 시간 오류가 여러 개 발생할 수 있어 빌드가 실패할 수 있습니다. 기능 개발을 중단하고 이러한 오류를 수정하기 위해 수개월 동안 엔지니어링 시간을 할당하는 것은 이상적이지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n귀하의 코드베이스의 유형 안정성과 아키텍처를 개선하는 동안 새로운 기능을 계속 배포하는 방법이 있습니다:\n\n- “tsconfig.json” 파일에서 “strict” 플래그를 “true”로 설정 — 이렇게하면 모든 엄격한 검사가 활성화됩니다.\n\n## 새로운 프로젝트\n\n새로운 TypeScript 프로젝트의 경우 처음부터 엄격한 모드를 활성화하는 것이 합리적입니다. 이렇게하면 시간과 귀찮음을 절약하고 소프트웨어의 품질을 크게 향상시킵니다. 개발자는 또한 중요한 JavaScript 및 TypeScript 교훈을 배우며, 안전하고 안정적인 프로그래밍 언어로 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n## 기존 프로젝트\n\n오래된 프로젝트를 다루는 개발자들은 딜레마에 직면합니다. 한편으로는 엄격한 모드를 활성화하여 최상의 품질을 얻고 싶지만, 다른 한편으로는 주요 리팩터링을 거치기 싫어합니다. JSON 파일의 플래그를 true로 설정하는 것은 간단해 보이지만, 대규모 프로젝트에서는 수백 개 또는 수천 개의 오류가 발생할 수 있습니다.\n\n만일 Git 저장소를 사용하고 현재 프로젝트 상태가 올바르다고 가정한다면, 다음과 같은 똑똑한 해결책이 가능합니다:\n\n- 엄격한 모드 활성화 — \"tsconfig.json\" 파일의 \"strict\" 플래그를 \"true\"로 설정합니다.\n- 해킹: 모든 파일에 대해 TypeScript 검사를 수동으로 비활성화 — 모든 *.ts 파일의 첫 번째 줄에 // @ts-nocheck를 추가합니다. (스크립트로 자동화할 수 있습니다)\n- Pre-Commit 후크 추가 — Git 저장소에 커밋 시 // @ts-nocheck 주석이 포함된 커밋을 거부하는 Git 후크를 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\n#!/bin/sh\n\n# 준비 중인 모든 파일 확인\nfor file in $(git diff --cached --name-only); do\n    # 디렉토리와 JavaScript/TypeScript 파일이 아닌 파일은 건너뜁니다.\n    if [ -f \"$file\" ] && [[ \"$file\" =~ \\.(js|ts|jsx|tsx)$ ]]; then\n        if grep -q \"@ts-nocheck\" \"$file\"; then\n            echo \"오류: $file 파일에 // @ts-nocheck이 포함되어 있습니다.\"\n            exit 1\n        fi\n    fi\ndone\n\nexit 0\n```\n\n## 도대체 무슨 일이 일어나고 있는 건가요?\n\n이 아이디어는 오래된 코드는 그대로 두고 새 코드를 엄격한 모드 검사로 개발하는 것입니다. // @ts-nocheck (단계 2)를 추가하면 TypeScript 컴파일러는 해당 파일에 대한 모든 검사를 무시합니다. 이를 통해 오류가 있더라도 프로젝트를 빌드할 수 있으면서도 엄격한 모드를 활성화할 수 있습니다. 후크 (단계 3)는 미래에 // @ts-nocheck가 포함된 파일을 푸시할 수 없도록 합니다. 오래된 파일을 수정하는 경우 엄격한 모드 문제를 해결하고 해킹을 제거한 다음 푸시해야 합니다.\n\n장점:\n\n<div class=\"content-ad\"></div>\n\n- 코드 품질은 계속해서 향상됩니다.\n- 엄격 모드 활성화가 가능합니다.\n\n단점:\n\n- \"혼합 모드\"에서 개발에 더 많은 시간이 필요합니다 (즉, 파일에 // @ts-nocheck 주석이 아직 있는 경우).\n\n## 추가 단계\n\n<div class=\"content-ad\"></div>\n\n에러 및 경고의 수가 증가하지 않도록 오류 임계값을 추가할 수 있어요. 먼저 다음 명령을 사용하여 보고서를 생성해보세요:\n\n```js\neslint . --format=json --output-file=eslint-report.json; node ./eslint-config.js\n```\n\n이 명령을 실행하면 모든 오류가 포함된 JSON 파일이 생성됩니다. 그런 다음 오류의 수를 계산하고 유효성을 확인하기 위해 Node.js 스크립트(eslint-config.js)를 작성해보세요:\n\n```js\nconst errors = require('./eslint-report.json');\n\nconst ERROR_THRESHOLD = 1212;\nconst WARNING_THRESHOLD = 53;\n\nconst totalErrors = errors.reduce((sum, error) => sum + error.errorCount, 0);\nconst totalWarnings = errors.reduce((sum, error) => sum + error.warningCount, 0);\n\nif (totalErrors > ERROR_THRESHOLD) {\n    console.error(`에러 임계값 초과: 발견된 오류 수 ${totalErrors}개 (임계값: ${ERROR_THRESHOLD})`);\n    process.exit(1);\n}\n\nif (totalWarnings > WARNING_THRESHOLD) {\n    console.error(`경고 임계값 초과: 발견된 경고 수 ${totalWarnings}개 (임계값: ${WARNING_THRESHOLD})`);\n    process.exit(1);\n}\n\nconsole.log(`린팅 통과: ${totalErrors}개의 오류, ${totalWarnings}개의 경고`);\n```\n\n<div class=\"content-ad\"></div>\n\nCI/CD 파이프라인에이 스크립트를 추가하여 오류 또는 경고의 수가 증가할 때마다 빌드를 실패하도록 설정하세요. 시간이 지남에 따라 오류를 수정하고 임계값을 점차 낮춰보세요.\n\n이 실천을 따르면 모든 오류를 점진적으로 수정할 수 있습니다.\n\n읽어 주셔서 감사합니다! 이 내용이 도움이 되었기를 바랍니다. 만약 도움이 되었다면 댓글로 알려주시면 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-06-27-TypeScriptStrictModeTurnItOnImmediatelyWithoutRefactoringforMonths_0.png"},"coverImage":"/assets/img/2024-06-27-TypeScriptStrictModeTurnItOnImmediatelyWithoutRefactoringforMonths_0.png","tag":["Tech"],"readingTime":5}],"page":"2","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}