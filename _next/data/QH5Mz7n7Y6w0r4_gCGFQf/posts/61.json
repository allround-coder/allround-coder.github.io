{"pageProps":{"posts":[{"title":"Flutter에서 clean code를 작성하는 방법","description":"","date":"2024-05-20 23:18","slug":"2024-05-20-Whyshouldweusecleancodeinflutter","content":"\n\n![image](/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png)\n\n플러터에서 깨끗한 코드를 사용하는 것은 유지보수성, 가독성, 확장성 및 디버깅의 용이성을 포함한 여러 가지 이유로 중요합니다. 아래에는 깨끗한 코드의 중요성을 설명하기 위한 몇 가지 구체적인 예와 함께 자세한 설명이 나와 있습니다.\n\n- 유지보수성\n\n깨끗한 코드는 이해하기 쉽고 수정하기 쉽습니다. 코드베이스가 커질수록 잘 구성되고 이해하기 쉬운 코드를 가지고 있으면 버그를 수정하고 새로운 기능을 추가하기가 더 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// .......................코드 작성이 잘못된 부분............................\n\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text('내 앱'),\n    ),\n    body: Column(\n      children: [\n        Text('내 앱에 오신 것을 환영합니다', style: TextStyle(fontSize: 24)),\n        RaisedButton(\n          onPressed: () {\n            // 복잡한 로직\n          },\n          child: Text('눌러보세요'),\n        ),\n      ],\n    ),\n  );\n}\n\n// .......................깔끔한 코드...................................\n\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: _buildAppBar(),\n      body: _buildBody(),\n    );\n  }\n\n  AppBar _buildAppBar() {\n    return AppBar(\n      title: Text('내 앱'),\n    );\n  }\n\n  Widget _buildBody() {\n    return Column(\n      children: [\n        _buildWelcomeText(),\n        _buildPressMeButton(),\n      ],\n    );\n  }\n\n  Widget _buildWelcomeText() {\n    return Text(\n      '내 앱에 오신 것을 환영합니다',\n      style: TextStyle(fontSize: 24),\n    );\n  }\n\n  Widget _buildPressMeButton() {\n    return RaisedButton(\n      onPressed: _handlePressMeButton,\n      child: Text('눌러보세요'),\n    );\n  }\n\n  void _handlePressMeButton() {\n    // 복잡한 로직\n  }\n}\n```\n\n깔끔한 코드 예제에서, build 메서드는 더 작고 더 집중된 메서드로 분해되어 유지보수가 더 쉽습니다.\n\n2. 가독성\n\n깔끔한 코드는 더 읽기 쉽고 이해하기 쉽습니다. 이는 코드가 작성되기보다는 더 자주 읽히기 때문에 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// .......................작성된 코드가 좋지 않습니다............................\n\nvoid updateUserProfile(User user) {\n  if (user.name != null && user.email != null) {\n    // 프로필 업데이트\n  }\n}\n\n\n// ............................깨끗한 코드................................\n\nvoid updateUserProfile(User user) {\n  if (_isUserProfileValid(user)) {\n    _updateProfileInDatabase(user);\n  }\n}\n\nbool _isUserProfileValid(User user) {\n  return user.name != null && user.email != null;\n}\n\nvoid _updateProfileInDatabase(User user) {\n  // 프로필 업데이트\n}\n```\n\n깨끗한 코드 예제는 조건을 잘 명명된 메서드로 추상화하여 가독성을 향상시킵니다.\n\n3. 확장성\n\n프로젝트가 확장될수록, 깨끗한 코드는 코드베이스의 품질을 저하시키지 않고 새로운 기능을 추가하는 것을 더 쉽게 만듭니다.\n  \n\n<div class=\"content-ad\"></div>\n\n```js\n// ..........잘못 작성된 코드.........\n\nvoid performAction(String action) {\n  if (action == 'login') {\n    // 로그인 로직\n  } else if (action == 'logout') {\n    // 로그아웃 로직\n  } else if (action == 'signup') {\n    // 가입 로직\n  }\n}\n\n// ...........깔끔한 코드...............\n\nvoid performAction(String action) {\n  switch (action) {\n    case 'login':\n      _login();\n      break;\n    case 'logout':\n      _logout();\n      break;\n    case 'signup':\n      _signup();\n      break;\n    default:\n      _handleUnknownAction();\n  }\n}\n\nvoid _login() {\n  // 로그인 로직\n}\n\nvoid _logout() {\n  // 로그아웃 로직\n}\n\nvoid _signup() {\n  // 가입 로직\n}\n\nvoid _handleUnknownAction() {\n  // 알 수 없는 동작 처리\n}\n```\n\n깔끔한 코드 예시는 switch 문을 사용하여 동작을 각각의 메서드로 분리하여 새로운 동작을 추가하기 쉽게 만듭니다.\n\n4. 디버깅 용이성\n\n깔끔한 코드는 더 직관적으로 코드를 추적하고 실행 흐름을 이해하기 쉬워져 디버깅을 단순화합니다.\n\n<div class=\"content-ad\"></div>\n\n잘못 작성된 코드:\n\n```js\n// ...........잘못 작성된 코드..............\n\nvoid processOrder(Order order) {\n  if (order.isValid()) {\n    if (order.total > 100) {\n      applyDiscount(order);\n    }\n    // 주문 처리\n  }\n}\n\n\n// ...........깨끗한 코드..............\n\nvoid processOrder(Order order) {\n  if (!order.isValid()) {\n    return;\n  }\n  _applyDiscountIfEligible(order);\n  _processOrderDetails(order);\n}\n\nvoid _applyDiscountIfEligible(Order order) {\n  if (order.total > 100) {\n    applyDiscount(order);\n  }\n}\n\nvoid _processOrderDetails(Order order) {\n  // 주문 처리\n}\n```\n\n깨끗한 코드 예시에서는 로직이 작고 관리하기 쉬운 메소드로 분해되어 있어 이해하고 디버그하기가 더 쉽습니다.\n\n추가 예시: 변수\n\n<div class=\"content-ad\"></div>\n\n```js\n// ........잘못 작성된 코드......\n\nint a;\nString b;\n\n// ........깔끔한 코드..........\n\nint productCount;\nString activeUserName;\n```\n\n함수:\n\n```js\n// ........잘못 작성된 코드.......\n\nvoid doSomething();\nString getSomething();\n\n// ........깔끔한 코드..........\n\nvoid updateProductCount() {\n  // ...\n}\n\nString getUserName() {\n  // ...\n}\n```\n\n클래스:\n\n<div class=\"content-ad\"></div>\n\n\n// ......잘못 작성된 코드....\n\nclass MyClass {\n  // ...\n}\n\n// ........깔끔한 코드..........\n\nclass VideoList {\n  // ...\n}\n\nclass UserAccount {\n  // ...\n}\n\n\n## 결론\n\nFlutter에서 깔끔한 코드를 사용하면 코드베이스가 유지 가능하고 가독성이 높고 확장 가능하며 쉽게 디버깅할 수 있습니다. 깔끔한 코드 원칙을 준수하면 애플리케이션의 전반적인 품질을 향상시켜 미래에 코드를 작업할 때 자신과 다른 사람들이 더 쉽게 작업할 수 있게 됩니다.\n\n<img src=\"/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_1.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n이 기사를 즐겁게 보셨기를 바라요! 제공된 정보를 감사하게 여기신다면, 'Buy Me A Coffee'로 저를 지원할 수 있어요! 여러분의 센스에 감사드릴 거예요!","ogImage":{"url":"/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png"},"coverImage":"/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터에서 코드를 작성하는 간단한 방법","description":"","date":"2024-05-20 23:16","slug":"2024-05-20-ASimplewaytoorganizeyourcodeinFlutter","content":"\n\n<img src=\"/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png\" />\n\n플러터를 개발 앱에 매일 사용하는 과정에서 앞으로도 문제가 되지 않도록 코드를 체계적으로 구성할 방법을 찾고 있었습니다. 여러 프로젝트를 유지하는 것은 언제나 쉽지 않은 일이며, 코드가 깨끗할수록 쉬워집니다. 그래서 이전에 네이티브 안드로이드, Apache Flex, 심지어 PHP와 같은 기술을 경험한 바탕으로 체계적인 프로젝트 구조를 만들었습니다. 여러분에게도 도움이 되었으면 합니다.\n\n# 앱의 구조\n\n저는 모든 프로젝트에서 사용하는 이 구조를 사용하여 프로젝트 간의 이동이 쉽고 물건의 위치를 파악하기 위해 더 이상 찾아다니지 않아도 됩니다. 저희 팀은 이 구조에 익숙해져 있어, 제작량을 최소화하여 며칠 안에 앱을 개발할 수 있는 수준까지 줄일 수 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_1.png)\n\n자, 좀 더 구조에 대해 이야기해 봐요:\n\n화면: 이 폴더에는 일반적으로 앱의 모든 화면이 들어갑니다. 스크린샷에서 볼 수 있듯이, 각 화면에는 각각의 폴더가 있습니다. 이 구체적인 예에서 이 앱에는 하단 내비게이션 바를 사용하는 홈 화면과 4개의 주요 화면(war, news, major_orders, game)이 있습니다. 이 부분에 대해 나중에 더 자세히 설명하겠습니다.\n\n위젯: 이 폴더에는 일반적으로 앱의 재사용 가능한 위젯이 들어갑니다. 이 폴더에는 custom_scaffold와 \"리사이클러\" 또는 리스트 아이템 위젯과 같은 파일을 저장합니다.\n\n<div class=\"content-ad\"></div>\n\n서비스: 나는 내가 만드는 앱에서 사용하는 모든 외부 서비스를 가지고 있는 DIO 폴더로 알려진 것이다. 여기에는 보통 앱에 데이터를 공급하는 REST API에 연결하는 클래스들이 포함되어 있습니다.\n\n모델: 서비스 폴더를 따라서 항상 나는 모델(객체 클래스)들을 Models라는 별도의 폴더에 유지합니다. 과거에 Flex 또는 AIR를 사용한 사람들을 위해, 이곳은 예전에 내 ValueObjects 폴더였습니다. 사전 용어에 대한 모델 예시:\n\n```js\nclass TermVO {\n  int? id;\n  String? title;\n  String? description;\n  String? language;\n\n  TermVO({this.id, this.title, this.description, this.language});\n\n  TermVO.fromJson(Map<String, dynamic> json) {\n    id = json['id'];\n    title = json['title'];\n    description = json['description'];\n    language = json['language'];\n  }\n}\n```\n\n유틸리티: 이 폴더는 외부 API나 로컬 라이브러리를 위한 \"도우미\" 파일들의 집입니다. 여기에는 Firebase 헬퍼 클래스, OneSignal 헬퍼 클래스 또는 우리 프로젝트에서 문자열을 포맷하는 함수를 포함하는 내 StringHelper 클래스와 같은 것들이 들어갈 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\nStyles: 테마와 스타일을 포함하므로 직관적입니다.\n\nCommons.dart: 이 파일은 앱에서 사용되는 모든 것을 주요 \"import\"로 사용합니다. 이렇게 하면 파일에서 하나의 파일만 가져오면 빠른 리팩터링, 변경 또는 라이브러리 추가에도 도움이 됩니다.\n\n![이미지](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_2.png)\n\n이 구조를 사용하면 큰 프로젝트조차도 상당히 조직화하여 귀하의 삶을 훨씬 쉽게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# UI와 코드의 분리\n\n우리 모두 알다시피, Flutter는 의견이 강제되지 않아서 코드를 자유롭게 작성할 수 있습니다. Flutter에서 부족하다고 생각했던 한 가지는 Native Android(xml + kt 파일)나 심지어 사랑하는 과거 기술인 Apache Flex(MXML으로 UI를 작성하고 코드는 AS로 분리)처럼 코드와 UI를 분리하는 것이었습니다. 개발자 친구와 함께 이를 논의한 결과, Roipeker님의 제안을 토대로 이 아이디어를 실현했습니다. 이것이 바로 우리가 여기에 있는 이유입니다(Roipeker님 감사합니다).\n이 아이디어의 핵심은 각 화면이 UI를 포함하는 한 개의 파일과 화면의 모든 기능, 변수, 작동 코드를 포함하는 다른 파일로 분리된다는 것입니다.\nREST API에서 뉴스 목록이 포함된 화면의 예시를 살펴보겠습니다.\n\n![News screen](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_3.png)\n\n\"뉴스\" 화면은 UI를 포함하는 *_screen.dart 파일과 기능을 포함하는 *_controller.dart 파일로 나뉘어 있음을 확인할 수 있습니다. 이를 달성하기 위해, screen.dart에서 \"part 'news_controller.dart'\"를 사용하고, controller.dart 파일에서는 \"part of 'news_screen.dart'\"를 사용합니다. 이렇게 두 파일이 하나처럼 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image1](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_4.png)\n\nYou can see that the first file is simple and only contains the UI part.\n\n![image2](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_5.png)\n\nThis is the controller file which is used to load the news and sort them. As you can see, the newsList is loaded with content in the `controller.dart` and used in the `screen.dart`.\n\n\n<div class=\"content-ad\"></div>\n\n이것은 간단한 예제이지만 코드를 정리하고 깨끗하게 유지하는 두 파일을 가지는 가치를 볼 수 있습니다.\n\n더 나아가서 개발 시간을 최소화하는 것을 목표로 이를 더 발전시키기 위해 Android Studios에서 File 및 Code 템플릿으로 통합했습니다. 이렇게 하면 각 새로운 화면을 빠르게 만들 수 있습니다.\n\n# 2개 파일의 화면 구조에 대한 템플릿 만들기\n\n이를 템플릿에 추가하려면 다음 단계를 따라야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![screenshot](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_6.png)\n\n- 파일 — 설정 — 코드 스타일 — 파일 및 코드 템플릿\n- 새 항목 추가\n- 아무 이름으로 지정 (저는 뷰 상태를 이름으로 사용했습니다)\n\n![screenshot](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_7.png)\n\n- 파일 이름은 $'NAME'_screen이어야 합니다\n- 확장자는 dart여야 합니다\n- 메인 파일 (screen.dart)에 대한 다음 코드 사용\n\n\n<div class=\"content-ad\"></div>\n\n\n#set($class = ${NAME})\n#set($class_start = $class.substring(0,1).toUpperCase())\n#set($class_rest = $class.substring(1).toLowerCase())\n#set($class = $class_start + $class_rest)\n\npart '${NAME}_controller.dart';\n\nclass ${class}Screen extends StatefulWidget {\n  const ${class}Screen({Key? key}) : super(key: key);\n\n  @override\n  createState() => _${class}Screen();\n}\n\nclass _${class}Screen extends ${class}Controller {\n  @override\n  Widget build(BuildContext context) {\n    return Container();\n  }\n}\n\n\n7. 메인 파일 아래에 다음 코드와 함께 자식 템플릿 파일을 만듭니다.\n\n\n#set($class = ${NAME})\n#set($class_start = $class.substring(0,1).toUpperCase())\n#set($class_rest = $class.substring(1).toLowerCase())\n#set($class = $class_start + $class_rest)\n\npart of '${NAME}_screen.dart';\n\nabstract class ${class}Controller extends State<${class}Screen> {\n\n  @override\n  void initState() {\n    // TODO: initState 구현\n    super.initState();\n  }\n\n  @override\n  void dispose() {\n    // TODO: dispose 구현\n    super.dispose();\n  }\n}\n\n\n8. 자식 템플릿 파일을 '$'NAME'_controller.dart'로 명명하고 확장자는 이전과 동일한 dart로 설정합니다.\n  \n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_8.png)\n\n9. 적용 및 확인을 눌러 완료합니다\n\n이후에는 폴더로 이동하여 새로운 테스트 폴더(screens-test)를 생성한 다음 해당 폴더에서 마우스 오른쪽 버튼을 클릭하여 — 새로 만들기 — View State — 이름을 지정하세요.\n그러면 name_screen 및 name_controller 두 파일이 생성됩니다.\n\n제가 앞서 말했듯이, 이것은 제 팀이 코드를 구성하는 방식일 뿐이며 다양한 방법이 있지만, 2019년 첫 번째 Flutter 프로젝트의 엉망으로부터 잘 구성되고 유지 관리가 빠른 방식으로 나아가게 도와준 것을 잠시 공유하고 싶었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 메서드를 좋아하신다면, 귀하의 프로젝트에 통합하고 플러터 개발자 동료들과 공유하며 박수 치는 것을 잊지 마세요.","ogImage":{"url":"/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png"},"coverImage":"/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png","tag":["Tech"],"readingTime":6},{"title":"플러터에서 최고의 Bloc 상태 관리 파트 2","description":"","date":"2024-05-20 23:15","slug":"2024-05-20-BestBlocstatehandlinginFlutterpart2","content":"\n안녕하세요, 친구들,\n첫 번째 파트에 대한 좋은 피드백에 기쁩니다.\n이번 파트에서는 디자인에서 EventStatus를 사용하는 방법을 가르치고 디자인의 모든 상태를 다루는 것을 알려드리고 싶어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:580/1*wL6d8JPLeO4MbkwBPLHwcA.gif)\n\n지난 파트에서는 Bloc_state에서 상태를 다루기위해 EventStatus 클래스를 사용했었습니다.\n\nhttps://medium.com/@moeinmoradi.dev/best-bloc-state-handling-in-flutter-0f95a8e89e40\n\n<div class=\"content-ad\"></div>\n\n제 친구 한 명의 제안에 따라, EventStatus 클래스에 대해 좀 더 나은 컨셉을 제안하고 그 이름을 StateStatus로 변경해보겠습니다. 다음과 같이 변경해주세요.\n\n```js\n@immutable\nabstract class StateStatus<T> {\n  final int? itemId;\n  final T? data;\n  final ErrorModel? message;\n\n  const StateStatus({\n    this.itemId,\n    this.data,\n    this.message,\n  });\n}\n\nclass StateLoading<T> extends StateStatus<T> {\n  const StateLoading({super.itemId});\n}\n\nclass StateCompleted<T> extends StateStatus<T> {\n  const StateCompleted({required super.data});\n}\n\nclass StateInitial<T> extends StateStatus<T> {}\n\nclass StateError<T> extends StateStatus<T> {\n  const StateError({required super.message});\n}\n```\n\n좋아요, StateStatusLayout를 위한 클래스를 만들어봅시다.\n\n# StateStatusLayout\n\n<div class=\"content-ad\"></div>\n\nStateStatus에 따라 다른 디자인 상태를 표시하는 클래스가 필요합니다. 이 클래스는 각 상태와 해당 위젯을 표시할 수 있어야 합니다.\n\n이 클래스에서 BlocBuilder로부터 StateStatus를 받고 States에 따라 위젯을 반환했습니다 :\n\n```js\nclass StateStatusLayout<T> extends StatelessWidget {\n  final StateStatus<T> status;\n  final Widget onErrorStatus;\n  final void Function(ErrorModel error)? onErrorListener;\n  final Widget Function(BuildContext context, T? data) onCompletedStatus;\n  final Widget onInitialStatus;\n  final Widget onLoadingStatus;\n  const StateStatusLayout({\n    super.key,\n    required this.status,\n    required this.onCompletedStatus,\n    required this.onErrorStatus,\n    required this.onInitialStatus,\n    required this.onLoadingStatus,\n    this.onErrorListener,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    if (status is StateError) {\n      if (onErrorListener != null) {\n        onErrorListener!(status.message!);\n      }\n    }\n    if (status is StateCompleted) {\n      return StreamBuilder(\n        stream: Stream.value(status),\n        builder: (context, snapshot) {\n          log(status.data!.toString());\n          return onCompletedStatus(context, status.data);\n        },\n      );\n    }\n    if (status is StateError) {\n      return onErrorStatus;\n    }\n    if (status is StateInitial) {\n      return onInitialStatus;\n    }\n    if (status is StateLoading) {\n      return onLoadingStatus;\n    }\n    return Container();\n  }\n}\n```\n\n그런데, StateCompleted 조건을 살펴보세요. 데이터를 표시하기 위해 StreamBuilder를 사용했습니다. 이것에 대해 어떻게 생각하시나요?\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:700/1*I6k_gZJ0KRZYR4KU22Okig.gif)\n\n가끔 블록 쪽에서 데이터를 페이지네이션하거나 스트리밍해야 할 때, 위젯은 반드시 모든 상황에서 업데이트되어야 합니다. 그리고 위젯에서 오류가 발생하지 않도록하기 위해 이러한 가능한 상황을 고려하기 위해 StreamBuilder를 사용합니다.\n\n간단한 샘플 코드를 보여드리겠습니다. StateStatusLayout을 사용한 코드입니다:\n\n```js\nimport 'package:flutter/material.dart';\n\nclass ShowLayout extends StatelessWidget {\n  const ShowLayout({Key? key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<ShowBloc, ShowState>(\n        builder: (context, state) {\n          return StateStatusLayout(\n            status: state.showsStatus,\n            onCompletedStatus: (context, data) {\n              return GridView.count(\n                shrinkWrap: true,\n                padding: const EdgeInsets.all(10),\n                physics: const ClampingScrollPhysics(),\n                crossAxisSpacing: 10,\n                mainAxisSpacing: 20,\n                crossAxisCount: 4,\n                childAspectRatio: 9 / 16,\n                children: List.generate(data!.shows!.length, (index) {\n                  ShowModel item = data.shows![index];\n                  return ShowCard(\n                      show: item,\n                      onSelected: () {\n                        /// do Somethigs...\n                      },\n                    );\n                }),\n              );\n            },\n            onErrorStatus: const SizedBox(),\n            onInitialStatus: const SizedBox(),\n            onLoadingStatus: Padding(\n              padding: const EdgeInsets.all(48.0),\n              child: SizedBox(\n                width: 50,\n                height: 50,\n                child: SpinKitRipple(\n                  color: themeData.colorScheme.secondary,\n                  size: 40,\n                ),\n              ),\n            ),\n          );\n        },\n      );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 샘플 코드에서는 Bloc이 emit() 함수로 갱신될 때 showsStatus 상태에 대한 onCompletedStatus 및 onLoadingStatus를 처리했습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1280/1*XwwugAFY35KNciVoDHThEw.gif)\n\n## 지금까지 함께 해주셔서 감사합니다\n\n나와 함께 계속 이야기를 공유해주시고 피드백을 기다리고 있습니다. 분들의 소중한 의견을 기다리고 있습니다. 🙏\n","ogImage":{"url":"/assets/img/2024-05-20-BestBlocstatehandlinginFlutterpart2_0.png"},"coverImage":"/assets/img/2024-05-20-BestBlocstatehandlinginFlutterpart2_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터 3.22에 새로 추가된 내용 정리","description":"","date":"2024-05-20 23:13","slug":"2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings","content":"\n\n## 플러터 3.22 릴리스는 웹 어셈블리, 불칸 그래픽, 위젯 상태 향상 등을 포함하고 있습니다\n\n![이미지](/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png)\n\n이 글에서는 플러터 3.22의 새로운 기능을 알아보겠습니다. 플러터 3.22에서는 성능 향상을 위해 웹 어셈블리 지원과 안드로이드에서 더 부드러운 그래픽을 위한 불칸 백엔드가 소개되었습니다. 위젯 상태 관리가 **위젯 상태 속성**과 함께 강화되었으며, **동적 뷰 크기 조정**으로 UI 적응성이 향상되었습니다. 또한 **개선된 폼 유효성 검증**을 통해 사용자 입력 처리를 강화했습니다.\n\n**플레이버 조건부 자산 번들링**을 통해 앱 플레이버를 기반으로 선택적 자산 번들링이 가능하게 되었으며, **Gradle Kotlin DSL 지원**은 코드 편집을 개선했습니다. iOS에서 플랫폼 뷰 성능이 **스크롤링에 특히 더 나아졌습니다.** Firebase Dart SDK 미리보기를 통해 **Vertex AI**를 활용한 AI 기능을 구현할 수 있으며, **Google Mobile Ads SDK 5.0.1**은 **UMP SDK** 및 더 많은 중재 파트너에 대한 향상된 지원을 제공합니다. 이러한 업데이트는 플러터에서 앱 성능, 사용자 경험 및 개발자 생산성을 향상시키기 위해 종합적으로 목표로 하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서, 플러터 3.22 릴리스에서의 탑 10 업데이트를 소개할게요:\n\n1. WebAssembly 지원\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*JPFkftr0XrFTo1zLm8U3WQ.gif)\n\n플러터 3.22의 WebAssembly (Wasm) 지원은 웹 앱 개발에 큰 도약이에요. Wasm은 코드를 브라우저가 효율적으로 실행할 수 있는 바이너리 형식으로 컴파일함으로써, 플러터 웹 앱이 거의 네이티브 속도로 실행되도록 해줍니다.\n\n<div class=\"content-ad\"></div>\n\n전통적인 웹 기술과 비교했을 때, 이는 혁신적인 성능 향상을 가져옵니다. 게다가, Wasm은 주요 웹 브라우저에서 널리 지원되어 Flutter 웹 앱에 대한 광범위한 호환성을 보장합니다. Wasm을 활용함으로써 Flutter는 코드 크기를 줄이고 빠른 로드 시간 및 향상된 전반적인 성능을 제공합니다. 게다가, Wasm은 빠르게 발전하는 기술로, 앞으로 더 많은 향상이 기대됩니다.\n\n전반적으로, Flutter 3.22에서의 Wasm 지원은 웹 개발을 위한 플랫폼 기능을 향상시켜 개발자에게 고성능 웹 애플리케이션을 구축하는 강력하고 효율적인 도구를 제공합니다.\n\n2. Impeller를 위한 Vulkan Backend\n\nFlutter 3.22에서 Impeller의 Vulkan 백엔드는 안드로이드에서 Flutter 앱에서 사용되는 렌더링 엔진에 대한 중요한 향상입니다. Vulkan은 현대적인 GPU에 대한 고효율적이고 크로스 플랫폼 액세스를 제공하는 저부하, 크로스 플랫폼 3D 그래픽 및 컴퓨팅 API입니다.\n\n<div class=\"content-ad\"></div>\n\n임펠러에 Vulkan을 통합함으로써, 플러터는 Vulkan의 능력을 활용하여 그래픽을 더 효율적으로 렌더링할 수 있어 안드로이드 기기에서 플러터 앱의 그래픽이 더 부드럽고 성능이 향상될 수 있습니다. 이 향상은 특히 애니메이션과 풍부한 전환 효과를 갖는 앱에 유용하며, 부드러운 프레임 속도를 유지하고 전반적인 사용자 경험을 향상시킵니다.\n\n### 위젯 상태 속성\n\n플러터 3.22의 위젯 상태 속성은 위젯이 외관과 동작을 어떻게 추적하는지에 관한 것입니다. 플러터는 이를 관리하는 특별한 방법인 \"매터리얼 상태(MaterialState)\"라는 것을 갖고 있습니다. 이번 업데이트에서 매터리얼 상태는 \"위젯 상태(WidgetState)\"로 이름이 변경되었으며 플러터의 더 많은 부분에서 사용할 수 있습니다.\n\n이 변경으로 개발자는 위젯이 어떻게 보이고 작동하는지를 더 쉽게 제어할 수 있게 되었으며, 이는 잘 작동하고 멋지게 보이는 플러터 앱을 만드는 데 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n4. 동적 뷰 크기 조정\n\nFlutter 3.22에서의 동적 뷰 크기 조정은 반응형 레이아웃을 처리하는 프레임워크의 기능을 향상시키는 기능입니다. 이 기능은 위젯이 사용 가능한 화면 공간에 기반하여 크기를 조절하도록 개선합니다. 이는 작은 스마트폰부터 큰 태블릿까지 다양한 기기에 걸쳐 일관적이고 매력적인 사용자 인터페이스를 만들 때 특히 유용합니다.\n\n이 업데이트 이전에, 개발자들은 종종 다양한 화면 크기에서 올바르게 표시되도록 위젯의 크기를 수동으로 계산하고 설정해야했습니다. 동적 뷰 크기 조정을 통해, 개발자들은 `Expanded`, `Flexible`, `MediaQuery`와 같은 기능을 사용하여 레이아웃을 생성할 수 있습니다. 이를 통해 위젯 크기를 화면의 차원에 따라 동적으로 조정할 수 있습니다.\n\n예를 들어, `Expanded` 또는 `Flexible` 컨테이너로 래핑된 위젯은 자동으로 확장 또는 축소하여 사용 가능한 공간을 채울 수 있어 반응형 디자인을 쉽게 만들 수 있습니다. 마찬가지로, `MediaQuery` 클래스를 사용하면 현재 화면 크기를 조회하고 위젯 크기를 조정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n동적 뷰 크기 조정은 반응형 플러터 레이아웃을 만드는 프로세스를 간단화해줍니다. 이는 다양한 기기와 화면 크기에서 일관된 사용자 경험을 제공하는 앱을 결과적으로 만들어냅니다.\n\n5. 폼 유효성 검사 개선\n\nFlutter 3.22에서 개선된 폼 유효성 검사는 사용자 입력을 다루는 더 유연하고 견고한 방법을 제공합니다. 이러한 향상된 기능은 개발자들이 사용자 입력을 어떻게 유효성을 검사할지 더 많은 제어력을 제공하며, 특정 애플리케이션 요구에 맞게 사용자 정의 유효성 검사 로직을 구현할 수 있게 해줍니다.\n\n이 개선된 유효성 검사 능력은 더 사용자 친화적인 경험으로 이어지며, 잘못된 데이터를 입력할 때 앱이 사용자에게 보다 정확한 피드백을 제공할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n또한, 이러한 향상된 기능은 인젝션 공격과 같은 보안 취약점을 예방하여 증가된 보안을 제공합니다. 총괄적으로 말하면, Flutter 3.22에서 개선된 양식 유효성 검사는 Flutter 앱의 사용성, 보안 및 유연성을 강화하며, 더 견고하고 사용자 친화적인 애플리케이션을 개발하는 데 강력한 도구를 제공합니다.\n\n6. 플레이버 조건부 자산 번들링\n\nFlutter 3.22의 플레이버 조건부 자산 번들링은 개발자들이 앱의 여러 버전 또는 \"플레이버\" 간에 효과적으로 자산을 관리할 수 있는 기능입니다. 이 기능을 통해 개발자는 앱의 플레이버에 기초하여 어떤 자산(예: 이미지, 폰트, 또는 설정 파일)을 앱 번들에 포함해야 하는지 지정할 수 있습니다.\n\n이는 특정 버전의 앱에 특정한 자산(예: 브랜드 자산 또는 설정 파일)을 포함시킬 수 있으면서 다른 버전의 앱에 영향을 미치지 않게 됨을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n자산을 이렇게 정리함으로써, 개발자들은 더 깔끔하고 조직화된 코드베이스를 유지할 수 있어 필요할 때 자산을 관리하고 업데이트하기가 더 쉬워집니다. 또한 각 버전에 필요한 자산만 포함함으로써, 앱 번들의 전체 크기를 줄일 수 있어 사용자들에게 빠른 다운로드 및 시작 시간을 제공할 수 있습니다.\n\n전반적으로, Flavor-Conditional Asset Bundling은 개발 프로세스를 향상시키고 Flutter 앱의 성능을 향상시키는 가치 있는 기능입니다.\n\n7. Gradle Kotlin DSL 지원\n\nFlutter 3.22에서의 Gradle Kotlin DSL 지원은 개발자들이 Gradle 빌드 스크립트를 작성할 때 Groovy 대신 Kotlin을 사용할 수 있게 해주는 기능입니다.\n\n<div class=\"content-ad\"></div>\n\nKotlin은 Groovy보다 여러 가지 이점을 제공하는 현대적이고 표현력 있는 프로그래밍 언어입니다. 이점으로는 더 나은 타입 안전성, 널 안전성, 그리고 향상된 도구 지원이 있습니다. Gradle Kotlin DSL 지원을 통해, 개발자들은 Flutter 프로젝트용 빌드 스크립트를 작성할 때 이러한 이점을 활용할 수 있습니다.\n\n이는 더 읽기 쉽고 유지보수하기 쉽며 견고한 빌드 스크립트로 이어져, 결국 Flutter 개발자들의 전체 개발 경험을 향상시킬 수 있습니다.\n\n8. 플랫폼 뷰 성능 개선 (iOS)\n\nFlutter 3.22에서의 플랫폼 뷰 성능 개선은 iOS 앱 내에서 플랫폼 뷰의 성능을 향상시키는 데 초점을 맞춥니다. 플랫폼 뷰는 지도나 웹 뷰와 같은 네이티브 구성 요소를 Flutter 앱에 통합하는 데 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n다음 업데이트는 주로 여러 플랫폼 뷰가 자주 사용되는 스크롤 뷰 내의 성능을 대상으로 합니다. 개선 사항에는 GPU 사용량이 50% 감소하여 배터리 효율성이 향상되고 사용자 상호 작용이 더 부드러워질 수 있는 잠재적인 이점이 포함되어 있습니다.\n\n게다가, 평균 프레임 렌더 시간이 1.66ms만큼 줄어든 것으로 (33%의 향상), 최악의 경우 렌더 시간은 3.8ms만큼 감소하여 (21%의 향상) 스무스한 애니메이션과 스크롤 중에 버벅임이 줄어들어 더 나은 경험을 제공하게 되었습니다.\n\n이러한 최적화는 iOS 기기에서 플랫폼 뷰를 활용하는 Flutter 앱의 성능을 현저히 향상시키도록 설계되었으며, 사용자에게 더 부드럽고 반응성 있는 경험을 제공합니다.\n\n9. Firebase Dart SDK 미리보기용 Vertex AI\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_1.png)\n\n플러터 3.22에 대한 Vertex AI for Firebase Dart SDK 미리보기는 제니미 API를 소개합니다. 이를 통해 개발자들은 자체 Dart 또는 Flutter 앱에 생성 AI 기능을 통합할 수 있습니다.\n\n이 SDK는 생산 수준의 성능과 확장성을 제공하며 Firebase App Check와의 통합으로 보안을 강화합니다. 개발자들은 이 SDK를 사용하여 이미지 및 텍스트 생성과 같은 제니미 API의 기능을 앱에서 사용할 수 있습니다.\n\n이 미리보기 릴리스는 프로모션 코드로 무료로 제공되며, 개발자들은 앱에 통합하기 전에 SDK의 기능을 탐색하고 테스트할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n10. Google Mobile Ads SDK 5.0.1\n\n플러터 3.22의 Google Mobile Ads SDK 5.0.1은 광고로 Flutter 앱을 수익화하는 개발자들을 위한 여러 개선 사항을 가져왔어요.\n\n이 업데이트에는 사용자 메시징 플랫폼 (UMP) SDK에 대한 향상된 지원이 포함되어 있어요. 개인화된 광고에 대한 동의 수집 프로세스를 간소화하기 위한 새로운 API가 제공돼요. 게다가 이제 SDK는 Unity, Meta, AppLovin, Iron Source, Mintegral, Pangle, DT Exchange, InMobi, Liftoff를 포함한 확장된 중개 파트너를 지원해요.\n\n이러한 통합은 개발자들에게 더 많은 기회를 제공하여 앱 수익을 극대화하는 광고 수익화 옵션을 확대시켜 줘요.\n\n<div class=\"content-ad\"></div>\n\n요약하자면, Flutter 3.22는 앱 개발자들을 위한 몇 가지 큰 개선 사항을 가져왔습니다. 그들은 그래픽 및 애니메이션에 특히 빠르고 부드러운 사용을 가능하게 만들었습니다. 또한 이미지 및 폰트와 같은 앱 자산을 구성하고 관리하는 새로운 방법을 추가하여 앱을 구축하고 유지하는 것을 더 쉽게 만들었습니다. 게다가 Android 및 iOS용으로 더 나은 딥 링크 지원 및 부드러운 스크롤링을 위한 멋진 새로운 기능이 추가되었습니다.\n\n전반적으로, Flutter 3.22는 훌륭한 앱을 만드는 것을 더 쉽고 재미있게 만들어줍니다. 또한 이 정보는 다양한 웹사이트를 조사하여 수집했습니다. 잘못된 정보나 오해된 정보가 있는 경우 아래 댓글로 알려주시면 감사하겠습니다.\n\n내용 중 오류가 있었다면 댓글에 언급해주세요. 개선하고 싶어합니다. 여러분의 지원은 저에게 매우 큰 의미를 갖습니다! 만족스러우셨다면 구독 고려해 주시면 감사하겠습니다.\n\n저는 Sherish Shukla입니다, 창의적인 개발자이자 기술 애호가입니다. LinkedIn에서 저를 찾을 수도 있고 Twitter에서도 팔로우할 수 있으며 자세한 내용을 보려면 포트폴리오로 가보세요. 물론 GitHub에서도 팔로우해 주시면 감사하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n좋은 하루 되세요!🙂","ogImage":{"url":"/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png"},"coverImage":"/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png","tag":["Tech"],"readingTime":7},{"title":"Google IO, Flutter가 발표한 최신 내용들 정리","description":"","date":"2024-05-20 23:12","slug":"2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements","content":"\n\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png)\n\n위의 스냅샷이 모두의 본질을 잡아냈음에 기쁩니다. 올해 개인적으로 Google I/O에 참석할 수 있었던 것은 정말 특권이었고, 이 기사는 행사 중에 메모한 내용을 반영하고 있습니다.\n\nGoogle I/O에 처음 참석한 나로서는, 개발자에게는 놀라운 경험이었으며 온라인에서만 알고 있던 사람들을 직접 만날 기회가 생기는 것은 더욱 소중한 경험입니다. \"Flutter로 적응형 UI를 구축하는 방법\"에 대한 Reid와 Tyler의 강연 후의 스냅샷은 행사 전반에 걸쳐 나의 흥분을 완벽하게 담아 냈습니다.\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n알았어요. 그럼, 구글 I/O 2024 및 그 이후의 Flutter에서 무엇이 새로운지에 대해 이야기해 봅시다. 케빈과 존이 진행한 'What's new in Flutter' 동안 주요 개선 사항이 다음과 같은 주제로 요약되었습니다.\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_2.png)\n\n## 주요 진전:\n\n- Google AI Dart SDK: 이 Flutter 프레임워크의 새로운 추가 사항은 또한 존과 케빈의 발표에서 강조되었습니다. 현재 Flutter 3.19가 라이브 중이며, 이로써 구글의 최신 생성적 AI(젬니) 기능이 Flutter 앱으로 제공되어 많은 창의적인 가능성과 쉬운 통합이 가능해졌습니다. 이제 개발자는 간단히 다음과 같이 시작할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_3.png\" />\n\n- 캐주얼 게임 도구 키트: Flutter를 사용한 게임 개발 가속화를 위한 리소스로 발표되었습니다.\nhttps://docs.flutter.dev/resources/games-toolkit\n- 임펠러: Google I/O 2024에서 특정 발표는 없었지만, Vulkan 백엔드가 강조되어 Flutter 앱의 그래픽 렌더링에서 현저한 개선을 제공한다는 것이 언급되었습니다. 즉시 성능을 향상시키려는 개발자들에게 좋은 대안이 될 수 있습니다. 임펠러로 전환하려면 단순히 다음을 실행하십시오:\n\n<img src=\"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_4.png\" />\n\n- 안정적인 WebAssembly 지원: 이는 Flutter 웹 개발을 위한 게임 체인저입니다. WebAssembly (Wasm)로 컴파일함으로써 기존 JavaScript 백엔드 대비 크게 빠른 렌더링 속도(2-3배)를 달성할 수 있습니다. 이는 Flutter를 사용한 고성능 웹 앱 개발을 위한 길을 열어줍니다.\n- Dart 3.4 통합: 이번 업데이트로 Flutter 개발자들을 위한 흥미로운 새로운 기능이 도입되었습니다. Experimental macros: Flutter 개발의 미래를 엿볼 수 있는 기능으로, macros는 편집기 내부에 내장된 기능으로 코드 생성을 가능하게 합니다. 이는 뼈대 코드를 크게 줄이고 유지보수성을 개선하며 반복되는 작업을 자동화할 수 있습니다. 초기 예시로, 새로운 내장 매크로가 JSON 데이터 직렬화 및 역직렬화를 간단하게 만들어줍니다.\n\n<div class=\"content-ad\"></div>\n\n위 주제와 관련된 보다 구체적인 정보를 찾으려면 다음 링크를 방문해보세요:\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_5.png)\n\n## 추가 개선 사항:\n\n- 향상된 웹 앱 성능: 웹어셈블리(WebAssembly) 이상, Flutter 3.22는 웹 앱을 위한 다른 최적화도 제공하여 사용자 경험을 더욱 원활하게 만듭니다.\n- 최신 업데이트를 통해 Flutter 앱은 안드로이드 예측 제스처와 완벽하게 통합되어 사용자가 백 스와이프를 시작하는 동안 이전 화면(홈 화면이나 다른 앱)을 간략히 볼 수 있습니다.\n- Flutter 앱에서 iOS 플랫폼 뷰가 속도 향상을 겪었습니다! CPU 사용량이 최대 50% 감소되어 더 원활한 사용자 경험을 제공합니다.\n- 부드러운 그래픽을 위한 Vulkan 백엔드: 이 업데이트로 안드로이드에서 Flutter 앱의 그래픽 렌더링이 현저히 향상되었습니다.\n- 더 나은 위젯 상태 관리: Flutter 3.22는 위젯이 상태를 처리하는 방법에 대한 향상을 제공하여 유지 및 효율적인 코드를 이끌어냅니다.\n- 폼 유효성 검사, 자산 번들링 및 Gradle 스크립트 편집: Flutter 3.22의 추가 기능 중 일부로 개발 워크플로우를 간소화하고 앱 품질을 향상시킵니다.\n- CameraX를 사용한 Flutter에서 일관되고 신뢰할 수 있는 카메라 경험 구축: (Building Consistent and Reliable Camera Experiences in Flutter with CameraX 비디오를 기반으로 함) Android에서의 Flutter 카메라 플러그인의 새로운 구현은 CameraX를 사용하여 구축되었습니다. CameraX는 카메라 개발을 더 쉽게 만들고 카메라 동작을 기기 간 일관되게 유지하는 목적으로 만들어진 Jetpack 라이브러리입니다. CameraX에는 자동 선택 및 기기별 문제 수정이라는 두 가지 주요 혜택이 있습니다. 자동 선택은 해상도나 종횡비를 명시하지 않거나 지정된 값이 사용 불가능한 경우 최상의 해상도나 종횡비를 결정하여 개발자를 돕습니다. CameraX는 또한 기기별 카메라 버그를 수정합니다.\n\n<div class=\"content-ad\"></div>\n\n## 향상된 개발자 경험:\n\n- Material 3로 새롭게 업그레이드된 DevTools: 친숙한 DevTools 인터페이스가 현대적인 Material 3 디자인 언어로 새롭게 탄생하여 미적으로 매력적이고 접근성이 좋은 경험을 제공합니다.\n- 강력한 DevTools 기능 개선: DevTools는 고급 필터링과 타임라인에서 CPU 샘플 지원으로 더욱 강력해졌습니다. 이를 통해 Flutter 앱의 프로파일링과 최적화를 더욱 정밀하게 할 수 있습니다.\n- 딥 링크 디버깅 단순화: Flutter 앱과 웹 경험 사이의 딥 링크 문제 해결이 더욱 쉬워졌습니다. 새로운 딥링크 유효성 검사 도구를 통해 구성 오류를 신속하게 식별하고 수정할 수 있습니다.\n\n## 실제 적용사례:\n\n- Universal Studios Destinations & Experiences, LG, Brickit 등 주요 기업들이 Flutter를 점점 더 많이 도입하며 프레임워크의 성숙성과 기능을 전시하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위 업데이트는 Flutter에 대한 중대한 발전을 의미하며, 아름답고 고성능이며 크로스 플랫폼 애플리케이션을 더욱 쉽게 구축할 수 있는 선택지로 만들어줍니다. 구글 I/O에서 발표된 사진은 Flutter가 전 세계에서 가장 인기 있는 크로스 플랫폼 프레임워크로 부상하는 모습을 보여줍니다.\n\n![Flutter Soars at Google I/O](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_6.png)\n\n## 게다가, 다음 자료들로 특정 측면에 대해 자세히 알아볼 수 있습니다:\n\n- John Ryan과 Kevin Moore에 의한 Flutter 최신 소식 토크\n- Reid Baker와 Tyler Holland에 의한 Flutter로 적응형 UI 구축하기 방법\n- Hangyu Jin과 Zoey Fan에 의한 Flutter에서 딥링킹 성공: 더 이상 깨진 링크가 없음\n- Camille Simon에 의한 Flutter에서 CameraX로 완벽한 카메라 경험 구축하기\n- Michael Thomsen의 최신 Flutter 3.22 및 Dart 3.4에 관한 기사\n- Vertex AI for Firebase SDK를 사용하여 Gemini API 시작하기\n\n<div class=\"content-ad\"></div>\n\n읽어 주셔서 감사합니다.\n\n기사를 즐겼으면 좋겠고, 앞으로 더 많은 게시물을 기대해 주세요. 건배!!! \n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_7.png)","ogImage":{"url":"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png"},"coverImage":"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png","tag":["Tech"],"readingTime":5},{"title":"웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유","description":"","date":"2024-05-20 23:10","slug":"2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps","content":"\n\n\n![image](/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png)\n\n웹 개발에서 간단함과 효과적인 기능 사이의 균형을 찾는 것이 중요합니다.\n\n개발자로서, 우리는 프로세스를 최적화하고 우수한 결과를 제공하는 방법을 계속해서 찾고 있습니다.\n\nHTML을 우선으로 한 백엔드 개발은 웹 애플리케이션 분야에서 그 가치를 입증해온 실증된 접근 방식으로 부상했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# HTML-First로 간단하게 유지하는 것이 왜 중요한가요\n\n기본 웹 애플리케이션을 구축해야 한다고 상상해보세요. 간단한 필터 옵션으로 데이터를 표시하는 테이블과 같은 웹 애플리케이션입니다.\n\n일반적으로 개발자들은 React 또는 Vue와 같은 복잡한 프론트엔드 프레임워크를 사용하여 이러한 작업을 수행할 수 있습니다.\n\n하지만, 이러한 프레임워크는 사용자 입력 이벤트를 듣는다거나 일반적으로 JSON 형식의 데이터를 가져와서 이 데이터를 동적으로 HTML로 렌더링하는 등 복잡한 단계들이 많이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 잠시 멈추어서 스스로에게 물어보세요. 사용자에게 구조화된 HTML을 제시하는 것이 최종 목표인데, 왜 이 복잡한 JSON 중간 매개체를 통해 탐색해야 하는 걸까요?\n\nHTML 중심 접근 방식을 채택함으로써, 우리는 불필요한 복잡성을 우회하고 더 직접적인 경로를 택하게 됩니다.\n\n라라벨, 장고, 루비 온 레일스와 같이 널리 사용되는 백엔드 프레임워크들은 템플릿을 사용하여 구조화된 HTML을 생성하는 강력한 기능을 제공합니다. 이것은 개발 프로세스를 간단하게 만들뿐만 아니라 성능을 향상시킴으로써 큰 장점을 제공합니다.\n\n# 팬시한 프론트엔드 프레임워크 없이 간소화하기\n\n<div class=\"content-ad\"></div>\n\n테이블 내에서 드롭다운 필터를 구현한다고 상상해보세요.\n\n프론트엔드 프레임워크의 복잡성에 의존하는 대신에 기본 HTML 폼 입력과 전통적인 폼 제출 메커니즘을 활용할 수 있습니다.\n\n아래는 작동 방식입니다:\n\n- 백엔드가 필요한 모든 데이터를 포함한 초기 뷰로 작동합니다.\n- 사용자가 필터와 상호 작용하면 폼이 데이터를 백엔드로 제출하고, 그러면 백엔드가 필터링된 데이터셋으로 페이지를 다시로드합니다.\n\n<div class=\"content-ad\"></div>\n\n이 방식은 전체 페이지 다시로드를 필요로 할 수 있지만, 상당한 이점을 제공합니다.\n\n특히, 현재 상태(적용된 필터와 같은)를 URL에 직접 인코딩함으로써, 응용 프로그램의 특정 뷰를 공유하고 재현하는 것을 간단하게 만든다는 점이 두드러집니다.\n\n또한 별도의 API 계층이 필요하지 않아 응용 프로그램 아키텍처를 간소화하고 전반적인 복잡성을 줄이는 효과가 있습니다.\n\n# 최신 JavaScript로 사용자 경험을 더 나은 방향으로 만들기\n\n<div class=\"content-ad\"></div>\n\n이제 사용자 경험 문제를 다루어보겠습니다. 특히 전체 페이지 새로 고침 상황에서 말이죠. 전통적인 HTML 중심 접근 방식은 단숨함과 신뢰성을 제공하지만, 쾌적한 사용자 경험을 제공하는 데는 부족할 수 있습니다.\n\n이를 해소하기 위해 현대적인 JavaScript 기술을 도입하여 단순함을 희생하지 않고 상호 작용성을 향상시킬 수 있습니다:\n\n- JavaScript를 사용하여 양식 제출을 가로채서 기본 동작을 방지합니다.\n- 백엔드로부터 업데이트된 데이터를 비동기적으로 요청하기 위해 fetch API를 활용합니다.\n- 새로 가져온 데이터로 테이블과 같은 페이지의 해당 부분만 동적으로 교체합니다.\n\n이 방식은 현대적인 프론트엔드 관행을 통합하면서 HTML 중심 개발의 핵심 원칙을 보존합니다. URL을 동적으로 업데이트함으로써 응용 프로그램이 단순함을 희생하지 않고 사용자 친화적이고 효율적으로 유지되도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n# HTMX를 사용하여 멋진 상호 작용\n\nHTML-중심 애플리케이션에서 더 많은 유연성과 동적 성을 찾는 개발자들을 위해, HTMX와 같은 도구는 매력적인 해결책을 제공합니다.\n\nHTMX를 사용하면 특별 속성을 HTML에 추가하여 동적 콘텐츠 업데이트를 용이하게 할 수 있습니다.\n\n다음 기능을 고려해보세요:\n\n<div class=\"content-ad\"></div>\n\n- 데이터를 가져오기 위해 GET 요청을 트리거하는 hx-get 활용하기.\n- 가져온 콘텐츠가 삽입될 위치를 정의하는 hx-target 사용하여 대상 요소 지정하기.\n- 상호 작용성을 향상시키기 위해 특정 이벤트에 따라 업데이트를 트리거하는 hx-trigger 활용하기.\n\nHTMX를 HTML을 우선으로 한 개발 워크플로에 통합함으로써, 개발자는 동적 상호 작용성의 힘을 활용하면서 백엔드에서 렌더링된 HTML의 간결함과 효율성을 유지할 수 있습니다.\n\n**실무에 적용하기: 다단계 폼**\n\nHTML을 우선으로 한 개발의 실용적인 적용을 설명하기 위해 다단계 폼을 구축하는 시나리오를 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nHTMX의 도움을 받아 개발자들은 전체 페이지 새로 고침 없이 동적인 양식 제출 및 유효성 처리를 구현할 수 있습니다:\n\n- 각 양식 단계는 백엔드에서 별도의 HTML 엔드포인트로 제공됩니다.\n- 양식 제출은 후속 단계 로딩이나 동적 유효성 오류 표시를 트리거하며, 전체 페이지 새로 고침이 필요하지 않습니다.\n\n이 접근 방식은 HTML 중심 개발이 복잡한 상호 작용을 수용하면서도 간결함과 효율성을 유지하는 우아함을 보여줍니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n프론트엔드 프레임워크는 의심의 여지없이 고급 기능과 기능을 제공하지만, 모든 웹 애플리케이션에 항상 최적의 선택은 아닙니다.\n\n많은 프로젝트가 HTML 기반 백엔드 접근 방식의 간결함과 효율성을 크게 누릴 수 있습니다.\n\n최신 JavaScript 기술을 통합하고 HTMX와 같은 도구를 선택적으로 통합함으로써, 개발자는 사용자 경험에 중점을 두면서 강인하고 유지보수 가능한 웹 애플리케이션을 만들 수 있습니다.\n\nHTML 기반 방식은 간결성, 효율성 및 효과적인 요소의 매력적인 혼합물을 제공하는 단단한 선택이 계속되고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 글은 스타일을 위해 AI 도움을 받아 작성되었고, 내용은 정보를 제공하기 위한 것으로 제시된 아이디어에 대해 비판적으로 참여할 것을 촉구합니다.\n\n이 글이 마음에 들었다면 👏 로 박수를 보내고 팔로우해 주세요! 가장 좋아하는 부분을 강조해도 좋습니다. 당신의 참여가 저를 영감을 주어요!","ogImage":{"url":"/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png"},"coverImage":"/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png","tag":["Tech"],"readingTime":4},{"title":"SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기","description":"","date":"2024-05-20 23:05","slug":"2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI","content":"\n\n이 문서는 WKWebView와 네이티브 측 간의 프로세스간 통신을 탐구합니다. 이는 로컬/임베디드 웹 페이지에 집중할 것입니다.\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png)\n\n# WKWebView의 탄생\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_1.png)\n\n<div class=\"content-ad\"></div>\n\n애플은 2003년 맥용 Safari 웹 브라우저의 첫 번째 버전을 출시할 때, 네이티브 애플리케이션에서 웹 콘텐츠를 표시하기 위한 최초 세대의 프로그래밍 인터페이스인 WebView 클래스를 개발했습니다.\n\n2007년, 스티브 잡스가 최초의 iPhone을 발표했습니다. 이후 해에는 iPhone 3G가 출시되었으며 WebKit 프레임워크도 함께 출시되었습니다. 이 프레임워크에는 iOS용 또 다른 프로그래밍 인터페이스인 UIWebView 클래스가 포함되어 있습니다.\n\n애플은 2010년에 WebKit의 두 번째 세대에 대한 작업을 시작했습니다. 4년 후, WebView (macOS) 및 UIWebView (iOS) 클래스를 대체하기 위해 WKWebView가 출시되었습니다. 두 클래스는 2018년에 폐기되었습니다.\n\n이것이 WKWebView의 간단한 역사입니다.\n\n<div class=\"content-ad\"></div>\n\n# WKWebView이 뭔가요?\n\n답은 애플 문서에 있어요.\n\n중요한 점은 네이티브 애플리케이션이 동일한 뷰에서 HTML 및 SwiftUI/UIKit 구성 요소를 표시할 수 있다는 거예요.\n\n왜 HTML과 네이티브 구성 요소를 함께 사용해야 하죠?\n\n<div class=\"content-ad\"></div>\n\n텍스트 콘텐츠나 멋진 UI를 SwiftUI/UIKit로 서식 지정하는 것은 상당히 어려울 수 있습니다. HTML과 CSS는 검증된 기술입니다. 웹 개발자가 모바일 친화적 웹사이트를 제작할 수 있다면, 네이티브 애플리케이션용 UI를 쉽게 만들 수 있습니다!\n\n그로 인해 네이티브 애플리케이션 개발자들이 다른 작업을 처리할 수 있게 되죠...\n\n이 글에서는 좀 더 탐구해보겠습니다.\n\n웹 콘텐츠는 어디서 오는 걸까요?\n\n<div class=\"content-ad\"></div>\n\n당연히, 웹 브라우저는 웹 서버에서 웹 페이지를 로드합니다. WKWebView이 로컬 파일이나 심지어 HTML 스트링에서 웹 콘텐츠를 로드할 수 있다는 것을 알아내는 것은 흥미롭습니다.\n\n로컬 웹 콘텐츠!\n\n이것은 의미하는 바는 기기가 오프라인 상태일 때에도 네이티브 애플리케이션이 여전히 작동할 수 있다는 것입니다! 게다가, 네이티브 애플리케이션은 네트워크 지연을 피할 수도 있습니다.\n\nWKWebView에 대해 자세히 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 웹 뷰 생성하기\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    typealias UIViewType = WKWebView\n    \n    var vm: BaseWebViewVM\n\n    // 뷰 모델로 초기화\n    init(viewModel: BaseWebViewVM) {\n        self.vm = viewModel\n    }\n    \n    func makeUIView(context: Context) -> WKWebView {\n        return vm.webView\n    }\n    \n    func updateUIView(_ uiView: WKWebView, context: Context) {\n    }\n    \n    func makeCoordinator() -> Coordinator {\n        return Coordinator(viewModel: vm)\n    }\n}\n\nextension SwiftUIWebView {\n    class Coordinator: NSObject {\n        var viewModel: BaseWebViewVM \n        \n        init(viewModel: BaseWebViewVM) {\n            self.viewModel = viewModel\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    @Published var webResource: String?\n    var webView: WKWebView\n\n    init(webResource: String? = nil) {\n        self.webResource = webResource\n        \n        self.webView = WKWebView(frame: .zero,\n                                 configuration: WKWebViewConfiguration())\n    }\n\n    func loadWebPage() {\n        if let webResource = webResource {\n            guard let url = URL(string: webResource) else {\n                print(\"잘못된 URL\")\n                return\n            }\n\n            let request = URLRequest(url: url)\n            webView.load(request)\n        }\n    }\n}\n```\n\n이 코드만 있으면 WKWebView에서 웹 페이지를 보여줄 수 있어요.\n\n## SwiftUIWebView\n\n<div class=\"content-ad\"></div>\n\nWKWebView은 UIView입니다. SwiftUIWebView는 UIViewRepresentable을 구현하는 구조체로 표현되어야 합니다.\n\nSwiftUIWebView는 BaseWebViewVM의 인스턴스로 초기화되어야 합니다.\n\nmakeUIView 메서드는 뷰 모델에서 WKWebView의 인스턴스를 반환합니다.\n\nmakeCoordinator 메서드는 Coordinator의 인스턴스를 반환합니다. Coordinator에는 WKWebView를 위한 델리게이트 함수들이 포함되어 있습니다. 현재로서는 특별한 작업을 수행하지는 않습니다.\n\n<div class=\"content-ad\"></div>\n\n## BaseWebViewVM\n\nBaseWebViewVM에는 공개된 속성 webResource가 있습니다. 이 속성은 클래스 생성자(init 메서드)를 통해 초기화될 수 있습니다. 또한 사용자 인터페이스를 통해 채워질 수도 있습니다.\n\n생성자는 대상 webResource를 로드하지 않은 WKWebView의 인스턴스를 만듭니다.\n\n일단 loadWebPage 메서드는 인터넷 웹 리소스를 로드할 것입니다. 나중에 로컬 웹 콘텐츠를 처리하는 방법도 살펴볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\nXCode Playground에서 시도해 보고 싶다면 다음을 추가해보세요:\n\n```js\nimport SwiftUI\nimport WebKit\nimport PlaygroundSupport\n\n// 위의 코드를 포함해주세요\n\nstruct ContentView: View {\n    let vm = BaseWebViewVM(webResource: \"http://www.google.com\")\n    \n    var body: some View {\n        SwiftUIWebView(viewModel: vm)\n            .onAppear(perform: vm.loadWebPage)\n    }\n}\n\nPlaygroundPage.current.setLiveView(ContentView())\n```\n\n<img src=\"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_2.png\" />\n\n인터넷 웹 페이지를 표시하는 데 유용합니다. 로컬 웹 콘텐츠를 표시하는 방법을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 내장 웹 페이지 표시\n\n먼저 XCode 프로젝트 루트에 Web 폴더를 생성합니다. 모든 웹 페이지와 관련 자료가 포함되어 있습니다.\n\n<img src=\"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_3.png\" />\n\n웹 콘텐츠 폴더는 원시 애플리케이션 프로젝트의 물리적인 일부일 수도 있고 그렇지 않을 수도 있습니다. 두 개가 별도의 개체이면 소스 코드 관리에 특히 주의해야 합니다!\n\n<div class=\"content-ad\"></div>\n\n애플리케이션이 특정 HTML 파일에 액세스하는 방법은 무엇인가요?\n\n애플리케이션이 Web 폴더에있는 다음 웹 페이지에 액세스해야 하는 경우: (위 스크린샷 참조)\n\n```js\nWeb/userGuide/section1/login.html\n```\n\n이것은 상대 경로입니다. 애플리케이션은 절대 경로로만 파일을 열 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 시뮬레이터에서\n\n/Users/<your user ID>/Library/Developer/CoreSimulator/Devices/.../Web/userGuide/section1/login.html\n\n# XCode Playground 프로젝트에서\n\n/var/folders/.../Web/userGuide/section1/login.html\n```\n\n상대 경로를 절대 경로로 변환하는 코드는 다음과 같습니다:\n\n```js\nlet nswr = NSString(string: relativePath)\n\nlet pathName = nswr.deletingLastPathComponent\nlet fileExtension = nswr.pathExtension\nlet fileName = nswr.lastPathComponent.replacing(\".\\(fileExtension)\", with: \"\")\n\n// pathName: Web/userGuide/section1\n// fileName: login\n// fileExtension: html\n\nlet absolutePath = Bundle.main.path(forResource: fileName,\n                                    ofType: fileExtension,\n                                    inDirectory: inDirectory)\n```\n\n애플리케이션 메인 번들에서 path 메서드는 주어진 파일 정보를 절대 경로로 변환하려고 합니다. 만약 주어진 파일 정보가 잘못되었다면 nil을 반환합니다. \n\n<div class=\"content-ad\"></div>\n\n애플리케이션이 HTML 파일의 절대 경로를 획득하면, 웹 뷰에 해당 파일을 로드할 수 있습니다.\n\n```js\nlet url = URL(filePath: absolutePath)\nwebView.loadFileURL(url, allowingReadAccessTo: url)\n```\n\n로드 메서드 대신에 파일 경로를 사용할 때는 loadFileURL 메서드를 사용해야 합니다.\n\n위 샘플 코드를 기준으로 설명하자면, LocalWebViewVM이라는 새 클래스를 추가할 것입니다. 이 클래스는 BaseWebViewVM의 하위 클래스입니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nclass LocalWebViewVM: BaseWebViewVM {\n    private func processWebResource(webResource: String) -> (inDirectory: String,\n                                                             fileName: String,\n                                                             fileExtension: String) {\n        // 상대 경로명을 구성 요소로 분해하는 코드\n    }\n\n    override func loadWebPage() {\n        if let webResource = webResource {\n            let (inDirectory,\n                 fileName,\n                 fileExtension) = processWebResource(webResource: webResource)\n\n            guard let filePath = Bundle.main.path(forResource: fileName,\n                                                  ofType: fileExtension,\n                                                  inDirectory: inDirectory) else {\n                print(\"잘못된 경로\")\n                return\n            }\n\n            print(filePath)\n            let url = URL(filePath: filePath)\n\n            webView.loadFileURL(url, allowingReadAccessTo: url)\n        }\n    }\n}\n```\n\n해당 하위 클래스는 loadWebPage 메서드를 오버라이드합니다.\n\nContentView를 다른 뷰 모델로 업데이트합니다.\n\n```swift\nstruct ContentView: View {\n    let vm = LocalWebViewVM(webResource: \"Web/userGuide/section1/login.html\")\n    \n    var body: some View {\n        SwiftUIWebView(viewModel: vm)\n            .onAppear(perform: vm.loadWebPage)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 캔버스에서 표시되는 내용입니다. (XCode Playground에서 라이브 뷰로 확인)\n\n![MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_4](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_4.png)\n\n# 사용자 상호작용\n\n## 자바스크립트 경고\n\n<div class=\"content-ad\"></div>\n\n웹 페이지나 어플리케이션은 다음과 같은 Javascript 코드를 통해 사용자에게 알림 메시지를 표시할 수 있습니다:\n\n```js\nalert(\"이것은 알림입니다\");\n```\n\n이것이 발생할 때 WKWebView는 대화 상자를 표시하지 않습니다. 대신, 이 역할은 호스팅 애플리케이션에 위임됩니다.\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    ...\n\n    func makeUIView(context: Context) -> WKWebView {\n        // 알림 처리\n        vm.webView.uiDelegate = context.coordinator\n        \n        return vm.webView\n    }\n\n    ...\n}\n\nextension SwiftUIWebView {\n    class Coordinator: NSObject, WKUIDelegate {\n        ...\n\n        // webView 함수는 Javascipt 알림을 처리합니다\n        func webView(_ webView: WKWebView,\n                     runJavaScriptAlertPanelWithMessage message: String,\n                     initiatedByFrame frame: WKFrameInfo,\n                     completionHandler: @escaping () -> Void) {\n            viewModel.webPanel(message: message,\n                               alertCompletionHandler: completionHandler)\n        }\n    }\n}\n\nenum JSPanelType {\n    case alert\n    \n    var description: String {\n        switch self {\n        case .alert:\n            return \"알림\"\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // Javascript 알림, 확인, 프롬프트 대화 상자에 대한 프로퍼티\n    @Published var showPanel: Bool = false\n    var panelTitle: String = \"\"\n    var panelType: JSPanelType? = nil\n    \n    var panelMessage: String = \"\"\n        \n    // 알림 프로퍼티\n    var alertCompletionHandler: () -> Void = {}\n\n    // 해당 알림 UI를 위한 프로퍼티 설정\n    func webPanel(message: String,\n                  alertCompletionHandler completionHandler: @escaping () -> Void) {\n        self.panelTitle = JSPanelType.alert.description // \"알림\"\n        self.panelMessage = message\n        self.alertCompletionHandler = completionHandler\n        self.panelType = .alert\n        self.showPanel = true\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n먼저, 응용 프로그램은 context.coordinator를 웹 뷰 uiDelegate 속성에 할당해야 합니다.\n\nCoordinator 클래스는 WKUIDelegate 프로토콜을 구현하고 여러 webView 함수 중 하나를 구현해야 합니다. 더 구체적으로는 Javascript alert용 함수입니다. 이 webView 함수는 UI 표시를 시작하지 않습니다. 대신, 알림 메시지와 콜백 함수를 뷰 모델로 전달합니다.\n\nJavascript alert는 모든 웹 페이지에 대해 일반적인 기능이므로 해당 기능을 하위 클래스가 아닌 BaseWebViewVM에 구현하는 것이 가장 좋습니다.\n\n다음은 몇 가지 새로운 속성입니다:\n\n<div class=\"content-ad\"></div>\n\n\nshowPanel - ContentView에서 UI 표시를 토글하는 발행된 속성입니다.\n\npanelTitle - 일반적인 UI 표시 제목입니다.\n\npanelMessage - 웹 페이지에서 나오는 메시지입니다.\n\npanelType - UI 표시의 유형을 나타냅니다.\n\n\n<div class=\"content-ad\"></div>\n\nalertCompletionHandler — 특정 Javascript 경고 콜백 함수\n\nwebPanel 함수는 panelType을 JSPanelType.alert로 설정합니다. 또한 showPanel을 true로 설정하여 해당 UI 프레젠테이션을 트리거해야 합니다.\n\nJSPanelType은 열거 유형입니다. 현재는 alert 값만 포함하고 있습니다. 또한 선택한 값에 대한 제목 설명을 반환하는 description이라는 계산된 속성이 있습니다.\n\n다음은 업데이트된 ContentView입니다:\n\n<div class=\"content-ad\"></div>\n\n```swift\nstruct ContentView: View {\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index.html\")\n\n    var body: some View {\n        VStack {\n            SwiftUIWebView(viewModel: vm)\n                .onAppear(perform: vm.loadWebPage)\n                .alert(vm.panelTitle,\n                       isPresented: $vm.showPanel,\n                       actions: {\n                           switch vm.panelType {\n                           case .alert:\n                               Button(\"Close\") {\n                                   vm.alertCompletionHandler()\n                               }\n                           default:\n                               Button(\"Close\") {}\n                           }\n                       }, message: {\n                           Text(vm.panelMessage)\n                       })\n        }\n        .padding()\n    }\n}\n```\n\nSwiftUIWebView에는 alert modifier가 포함되어 있습니다. 해당 alert에는 Close 버튼이 있습니다. 이 버튼은 alertCompletionHandler 함수를 호출할 것입니다.\n\n다음은 웹 페이지입니다:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  ...\n</head>\n\n<body>\n  <button onclick=\"alert('This is an alert!')\">Alert</button>\n</body>\n\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Image](https://miro.medium.com/v2/resize:fit:508/1*crNpOlR8VlOFpZSVQXkF-Q.gif)\n\n이것은 표준 프레젠테이션입니다. 그러나 필요에 따라 시트, 팝오버 또는 응용 프로그램에 적합한 UI로 구현할 수 있습니다.\n\n## Javascript Confirm\n\nJavascript confirm 기능은 javascript alert와 유사합니다. 표준 프레젠테이션에서 모달에는 메시지, 확인 버튼 및 취소 버튼이 포함됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconfirm(\"Are you sure?\")\n```\n\n자바스크립트 confirm 함수는 OK 버튼을 클릭할 때 TRUE를 반환합니다. 그렇지 않으면 FALSE를 반환합니다.\n\nSwift에서 자바스크립트 confirm을 처리하려면 애플리케이션은 다른 WKUIDelegate webView 함수를 추가해야 합니다.\n\n```js\nextension SwiftUIWebView {\n    class Coordinator: NSObject, WKUIDelegate {\n        ...\n\n        // webView 함수가 자바스크립트 confirm을 처리합니다.\n        func webView(_ webView: WKWebView,\n                     runJavaScriptConfirmPanelWithMessage message: String,\n                     initiatedByFrame frame: WKFrameInfo,\n                     completionHandler: @escaping (Bool) -> Void) {\n            viewModel.webPanel(message: message,\n                               confirmCompletionHandler: completionHandler)\n        }\n    }\n}\n\nenum JSPanelType {\n    case alert\n    case confirm\n    \n    var description: String {\n        switch self {\n        case .alert:\n            return \"알림\"\n        case .confirm:\n            return \"확인\"\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // 확인 속성\n    var confirmCompletionHandler: (Bool) -> Void = { _ in }\n\n    // 해당 확인 UI에 대한 속성 설정\n    func webPanel(message: String,\n                  confirmCompletionHandler completionHandler: @escaping (Bool) -> Void) {\n        self.panelTitle = JSPanelType.confirm.description\n        self.panelMessage = message\n        self.confirmCompletionHandler = completionHandler\n        self.panelType = .confirm\n        self.showPanel = true\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nJavaScript의 confirm을 위한 webView 함수는 약간 다른 콜백 함수 서명을 가지고 있어요.\n\n```js\ncompletionHandler: @escaping (Bool) -> Void\n```\n\nboolean 값을 인자로 받아요.\n\nJSPanelType에 confirm 값을 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\nBaseWebViewVM에 confirmCompletionHandler 속성을 추가하십시오. Javascript confirm을 위한 다른 webPanel 함수를 추가하십시오. panelType 속성을 JSPanelType.confirm으로 설정하십시오. 다시 한번 showPanel을 true로 설정하여 UI 표시를 트리거합니다.\n\n다음은 업데이트된 ContentView입니다:\n\n```swift\nstruct ContentView: View {\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index.html\")\n\n    var body: some View {\n        VStack {\n            SwiftUIWebView(viewModel: vm)\n                .onAppear(perform: vm.loadWebPage)\n                .alert(vm.panelTitle,\n                       isPresented: $vm.showPanel,\n                       actions: {\n                    switch vm.panelType {\n                    case .alert:\n                        Button(\"Close\") {\n                            vm.alertCompletionHandler()\n                        }\n                    case .confirm:\n                        Button(\"Ok\") {\n                            vm.confirmCompletionHandler(true)\n                        }\n                        Button(\"Cancel\") {\n                            vm.confirmCompletionHandler(false)\n                        }\n                    default:\n                        Button(\"Close\") {}\n                    }\n                }, message: {\n                    Text(vm.panelMessage)\n                })\n        }\n        .padding()\n    }\n}\n```\n\n다음은 업데이트된 웹 페이지입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  ...\n  <script>\n    ...\n    function callConfirm() {\n      if (confirm(\"This is a confirm dialog\")) {\n        document.getElementById(\"confirmValue\").innerText = \"You hit ok\";\n      } else {\n        document.getElementById(\"confirmValue\").innerText = \"You hit cancel\";\n      }\n    }    \n  </script>\n</head>\n\n<body>\n  ...\n  <div>\n    <button onclick=\"callConfirm()\">Confirm</button>\n    <div>Confirmed? <span id=\"confirmValue\"></span></div>\n  </div>\n</body>\n\n</html>\n```\n\n![Image](https://miro.medium.com/v2/resize:fit:504/1*DJyWQIktvhBdSEaqEIYJlw.gif)\n\n## Javascript Prompt\n\nThe last standard Javascript modal is prompt. The modal contains a text field for user input.\n\n<div class=\"content-ad\"></div>\n\n```swift\nvar response = prompt(\"이것은 프롬프트입니다! 어떻게 지내세요?\", \"좋음\");\n```\n\nprompt 함수의 두 번째 선택적 매개변수는 기본값입니다. 기본값은 webView 델리게이트 메서드를 통해 전달됩니다.\n\n다시 한 번, 응용 프로그램은 다른 WKUIDelegate webView 함수를 추가해야 하며, JSPanelType을 업데이트하고 BaseWebViewVM 클래스에 새 속성 및 webPanel 함수를 추가해야 합니다.\n\n```swift\nextension SwiftUIWebView {\n    class Coordinator: NSObject, WKUIDelegate {\n        ...\n\n        // webView 함수는 자바스크립트 프롬프트를 처리합니다\n        func webView(_ webView: WKWebView,\n                     runJavaScriptTextInputPanelWithPrompt prompt: String,\n                     defaultText: String?,\n                     initiatedByFrame frame: WKFrameInfo,\n                     completionHandler: @escaping (String?) -> Void) {\n            viewModel.webPanel(message: prompt,\n                               promptCompletionHandler: completionHandler,\n                               defaultText: defaultText)\n        }\n    }\n}\n\nenum JSPanelType {\n    case alert\n    case confirm\n    case prompt\n    \n    var description: String {\n        switch self {\n        case .alert:\n            return \"알림\"\n        case .confirm:\n            return \"확인\"\n        case .prompt:\n            return \"프롬프트\"\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // 프롬프트 속성\n    var promptInput: String = \"\"\n    var promptCompletionHandler: (String?) -> Void = { _ in }\n\n    // 해당 프롬프트 UI에 대한 속성 설정\n    func webPanel(message: String,\n                  promptCompletionHandler completionHandler: @escaping (String?) -> Void,\n                  defaultText: String? = nil) {\n        self.panelTitle = JSPanelType.prompt.description\n        self.panelMessage = message\n        self.promptInput = defaultText ?? \"\"\n        self.promptCompletionHandler = completionHandler\n        self.panelType = .prompt\n        self.showPanel = true\n}\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n콜백 함수는 promptInput 속성 값을 전달합니다. promptInput은 null이 아닌 문자열 속성임을 유의하세요. 따라서 콜백은 빈 문자열이거나 사용자 입력일 수 있습니다.\n\n다음은 업데이트된 웹 페이지입니다:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  ...\n  <script>\n    ...\n    function callPrompt() {\n      var response = prompt(\"프롬프트입니다! 어떻게 지내세요?\", \"좋아요\");\n      if (response) {\n        document.getElementById(\"promptResult\").innerText =\n          \"당신의 응답은: \" + response;\n      } else {\n        document.getElementById(\"promptResult\").innerText = \"취소됨\";\n      }\n    }  \n    </script>\n</head>\n\n<body>\n  ...\n  <div>\n    <button onclick=\"callPrompt()\">프롬프트</button>\n    <div><span id=\"promptResult\"></span></div>\n  </div>\n</body>\n\n</html>\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:508/1*rlolSsaDf_BRguFOB8td5Q.gif)\n\n<div class=\"content-ad\"></div>\n\nHTML5에서는 다이얼로그 요소가 있습니다. 이 요소는 HTML에서 모달 및 비모달 대화 상자를 만드는 데 사용됩니다.\n\n다이얼로그 요소를 사용하면 사용자 정의 경고, 확인 대화 상자 및 프롬프트 모달 대화 상자를 만들 수 있습니다. 이 접근 방식을 사용하면 모달을 다른 웹 애플리케이션과 일치하도록 스타일링할 수 있습니다.\n\n다이얼로그 요소를 사용하면 Swift 코드를 작성하는 대신 모든 사용자 상호 작용을 처리하기 위해 Javascript 코드를 작성해야 합니다. 하지만 이것은 원격 대화 상자를 생성하는 방법을 호스트(기본)에게 전달할 수 없다는 것을 의미하지는 않습니다. 다음 섹션에서는 웹 페이지와 호스트(기본) 응용 프로그램 간의 메시지나 이벤트를 전송하는 방법에 대해 알아볼 것입니다.\n\n# 웹 페이지와 기본 응용프로그램 간 통신\n\n<div class=\"content-ad\"></div>\n\n웹킷 프레임워크는 Objective-C 및 Swift를 위해 설계되었습니다. WebKit JS라고도 하는 자바스크립트 부분도 있습니다. 이는 Safari DOM 확장 기능입니다. (그것이 원래 이름일 수도 있습니다!) 기본적으로 이는 Safari 환경에 터치 제스처 이벤트, 스타일링 및 시각적 효과를 추가합니다. 실제로 그 기능 중 일부는 이미 W3C 표준의 일부로 채택되었습니다.\n\n웹 페이지에서 네이티브 애플리케이션으로 메시지/데이터를 보내려면 수신 측에 \"리스너\" 또는 WebKit 용어로는 메시지 핸들러가 필요하고, 보내는 쪽에는 메시지 전송 함수가 있어야 합니다.\n\n이 섹션에서는 웹 뷰에서 네이티브 애플리케이션으로 메시지를 보내거나 받고 응답하는 방법을 설명합니다.\n\n우선 웹 콘텐츠부터 시작해보죠.\n\n<div class=\"content-ad\"></div>\n\n```javascript\n<!-- index2.html -->\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  ...\n  <title>Index 2</title>\n  <script>\n    async function sendWebKitMessage(handler, message) {\n      if (\n        message != \"\" &&\n        handler != \"\" &&\n        window.webkit &&\n        window.webkit.messageHandlers &&\n        window.webkit.messageHandlers.hasOwnProperty(handler)\n      ) {\n        console.log(\"Going to send a message to\", handler)\n        var reply = await window.webkit.messageHandlers[handler].postMessage(message);\n        return reply\n      } else {\n        throw Error(\"뭔가 빠지는 게 있어요!\");\n      }\n    }\n\n    async function sendReceiveReply(handler, message, elementId) {\n      try {\n        var reply = await sendWebKitMessage(handler, message);\n\n        var sanitizedReply = reply.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        document.getElementById(elementId).innerHTML = sanitizedReply;\n      } catch (error) {\n        document.getElementById(elementId).innerHTML = \"에러: \" + error.message;\n      }\n    }\n  </script>\n</head>\n\n<body>\n  <div>\n    <button onclick=\"sendWebKitMessage('fromWebPage', '웹 뷰에서 온 메시지')\">메시지 보내기</button>\n  </div>\n  <div style=\"margin-top: 15px\">\n    <button onclick=\"sendReceiveReply('getData', '보내줘야 할 데이터 있어?', 'reply')\">데이터 가져오기</button>\n    <div id=\"reply\"></div>\n  </div>\n</body>\n\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n\"Send Message\" 버튼으로부터 발생한 처리되지 않은 예외의 스크린샷과 \"Get Data\" 버튼에서 처리된 예외의 스크린샷입니다.\n\n![예외 스크린샷](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_5.png)\n\n핸들러는 window.webkit.messageHandlers 네임스페이스에 있는 객체입니다. 모든 메시지 핸들러에는 postMessage라는 메소드가 있습니다. 이 메소드는 네이티브 애플리케이션으로 메시지/데이터를 보내는 데 사용됩니다.\n\nsendWebKitMessage 함수에는 console.log가 있습니다. 이 함수는 웹 인스펙터 콘솔 영역에 메시지를 표시할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n네이티브 애플리케이션 UI와 웹 뷰를 Safari 웹 브라우저에서 검사할 수 있도록 몇 가지 변경을 가해봅시다.\n\n```js\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // 웹 뷰로부터의 메시지\n    @Published var messageFromWV: String = \"\"\n\n    init(webResource: String? = nil) {\n        ...\n        \n#if DEBUG\n        // 검사 가능한 웹 뷰\n        self.webView.isInspectable = true\n#endif\n    }\n\n    ...\n}\n\nstruct ContentView: View {\n    // 이 VM은 메시지를 보내는 로컬 웹 페이지를 표시합니다.\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index2.html\")\n\n    var body: some View {\n        VStack {\n            SwiftUIWebView(viewModel: vm)\n                ...\n            Text(\"웹 뷰에서 온 메시지:\\n\\(vm.messageFromWV)\")\n        }\n    }\n}\n```\n\nBaseWebViewVM에서 messageFromWV라는 publish된 속성이 추가되었습니다. 이 속성은 웹 뷰에서 수신된 메시지를 저장할 것입니다. Text 요소가 이 변수에 바인딩됩니다.\n\n```js\n@Published var messageFromWV: String = \"\"\n\nText(\"웹 뷰에서 온 메시지:\\n\\(vm.messageFromWV)\")\n```\n\n<div class=\"content-ad\"></div>\n\nBaseWebViewVM 이니셜라이저에는 다음과 같은 코드 줄이 포함되어 있습니다.\n\n```js\n#if DEBUG\n    self.webView.isInspectable = true\n#endif\n```\n\n이를 통해 Safari가 웹 뷰 안에 있는 웹 페이지를 검사할 수 있습니다. 샘플 웹 페이지의 제목이 \"Index 2\"인 것에 유의하십시오. iOS 시뮬레이터에서 애플리케이션을 실행할 때 Develop > Simulator 하위 메뉴 아래에서 웹 페이지 제목을 볼 수 있어야 합니다.\n\n<img src=\"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_6.png\" />\n\n<div class=\"content-ad\"></div>\n\nHTML 버튼이 네이티브 애플리케이션과 상호 작용하도록 만들어 봅시다.\n\n먼저 \"fromWebPage\"와 \"getData\"에 대한 메시지 핸들러를 정의해야 합니다.\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    ...\n\n    func makeUIView(context: Context) -> WKWebView {\n        let userContentController = vm.webView\n            .configuration\n            .userContentController\n        \n        // 모든 메시지 핸들러를 제거합니다 (기존에 있으면)\n        userContentController.removeAllScriptMessageHandlers()\n\n        // 응답 없이 메시지 핸들러 추가\n        userContentController.add(context.coordinator,\n                                  name: \"fromWebPage\")\n\n        // 응답과 함께 메시지 핸들러 추가\n        userContentController.addScriptMessageHandler(context.coordinator,\n                                                      contentWorld: WKContentWorld.page,\n                                                      name: \"getData\")\n        ...\n    }\n}\n```\n\n사용자 콘텐츠 컨트롤러(WKUserContentController)는 \"앱의 네이티브 코드와 웹페이지의 스크립트 및 기타 콘텐츠 간의 상호 작용을 조정\"합니다. 이것은 웹 뷰 구성(WKWebViewConfiguration) 구성 요소입니다.\n\n<div class=\"content-ad\"></div>\n\n메시지 송수신 핸들러를 위해 애플리케이션은 사용자 콘텐츠 컨트롤러의 add 메서드를 사용해야 합니다.\n\n메시지 송수신-응답 핸들러를 위해 애플리케이션은 사용자 콘텐츠 컨트롤러의 addScriptMessageHandler 메서드를 사용해야 합니다.\n\n두 메서드 모두 사용자 콘텐츠 컨트롤러 메서드를 구현한 객체와 메시지 핸들러의 이름을 전달해야 합니다. 메시지 송수신의 경우, 객체는 WKScriptMessageHandler 프로토콜을 구현해야 합니다. 메시지 송수신-응답의 경우, 객체는 WKScriptMessageHandlerWithReply를 구현해야 합니다.\n\naddScriptMessageHandler는 또한 메시지 핸들러를 설치할 위치를 알아야 합니다. 이 샘플 코드에서, 애플리케이션은 WKContentWorld.page를 contentWorld 인자에 전달합니다.\n\n<div class=\"content-ad\"></div>\n\n자연스럽게, 코디네이터가 메시지 통신을 처리할 것입니다. 여기 구현입니다.\n\n```js\nextension SwiftUIWebView {\n    class Coordinator: ..., WKScriptMessageHandler, WKScriptMessageHandlerWithReply {\n        ...\n\n        // MARK: - WKScriptMessageHandler delegate function\n\n        // 메시지 송수신을 위한\n        func userContentController(_ userContentController: WKUserContentController, \n                                   didReceive message: WKScriptMessage) {\n            self.viewModel.messageFrom(fromHandler: message.name,\n                                       message: message.body)\n        }\n\n        // MARK: - WKScriptMessageHandlerWithReply delegate function\n\n        // 메시지 송수신 및 응답을 위한\n        func userContentController(_ userContentController: WKUserContentController,\n                                   didReceive message: WKScriptMessage,\n                                   replyHandler: @escaping (Any?, String?) -> Void) {\n            do {\n                let returnValue = try self.viewModel.messageFromWithReply(fromHandler: message.name,\n                                                                          message: message.body)\n                \n                replyHandler(returnValue, nil)\n            } catch WebViewErrors.GenericError {\n                replyHandler(nil, \"일반 오류\")\n            } catch WebViewErrors.ErrorWithValue(let value) {\n                replyHandler(nil, \"값 오류: \\(value)\")\n            } catch {\n                replyHandler(nil, error.localizedDescription)\n            }\n        }\n    }\n}\n```\n\nuserContentController 두 가지 구현은 사용자 컨텐츠 컨트롤러 및 수신 메시지에 대한 참조를 받습니다.\n\n메시지인 WKScriptMessage는 두 가지 중요한 매개변수, 메시지 핸들러의 이름(name)과 메시지 내용(body)을 포함합니다. 이 샘플 코드에서, 두 구현은 모두 이름과 내용을 사용하여 뷰 모델 메서드를 호출합니다.\n\n<div class=\"content-ad\"></div>\n\n보내기-수신-응답 버전을 위해 추가적인 replyHandler 클로저 인자가 있습니다. 클로저는 반환값과 오류 메시지 2개의 인자를 갖습니다. 클로저를 호출할 때 애플리케이션이 \"something\"을 한 인자로 전달하고 다른 하나는 nil입니다.\n\n마지막으로, 애플리케이션은 수신 메시지의 의도를 실행하기 위한 메서드를 구현해야 합니다.\n\n```swift\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // MARK: - 메시징을 위한 함수\n    func messageFrom(fromHandler: String, message: Any) {\n        self.panelTitle = JSPanelType.alert.description // \"Alert\"\n        self.panelMessage = String(describing: message)\n        self.alertCompletionHandler = {}\n        self.panelType = .alert\n        self.showPanel = true\n        self.messageFromWV = String(describing: message)\n    }\n\n    func messageFromWithReply(fromHandler: String, message: Any) throws -> String {\n        self.messageFromWV = String(describing: message)\n\n        var returnValue: String = \"Good\"\n\n        /*\n         * 이 함수는 다음과 같은 예외를 던질 수 있습니다:\n         *\n         * - WebViewErrors.GenericError\n         * - WebViewErrors.ErrorWithValue(value: 99)\n         */\n        \n        if fromHandler == \"getData\" {\n            returnValue = \"{ data: \\\"It is good!\\\" }\"\n        }\n        \n        return returnValue\n    }\n}\n```\n\nmessageFrom 메서드는 send-receive 메시징을 처리합니다. 예외를 던지지는 않는다는 점에 유의하십시오. 던진다 해도 userContentController 메서드는 해당 오류를 웹 뷰로 다시 전달할 수 없을 것입니다. 오류를 웹 뷰로 다시 전달해야 하는 경우 send-receive-reply 메시징 전략을 사용해야 합니다 - messageFromWithReply 메서드를 사용하세요!\n\n<div class=\"content-ad\"></div>\n\nmessageFromWithReply 메서드는 예외를 throw하고 문자열 값을 반환합니다. 샘플 코드에서는 JSON 문자열을 웹 뷰로 다시 반환합니다. 자바스크립트 세계에서는 JSON 문자열을 쉽게 자바스크립트 객체로 파싱할 수 있습니다.\n\n현재 샘플 코드는 예외를 throw하지 않습니다. 그러나 이 샘플 프로젝트에서 정의된 오류는 다음과 같습니다.\n\n```js\nenum WebViewErrors: Error {\n    case ErrorWithValue(value: Int)\n    case GenericError\n}\n```\n\n첫 번째 오류는 정수값을 받습니다. 하나 이상의 인수를 받을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n앱의 enum을 앱에 맞게 사용자 정의하세요!\n\n마침내, 이것이 보이는 모습입니다:\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*-PYrd32kdzvXGs27tgr8yQ.gif)\n\n네이티브 애플리케이션에서 웹 뷰로 메시지를 보내는 방법은 어떤가요?\n\n<div class=\"content-ad\"></div>\n\n네이티브 애플리케이션에서 메시지를 수신하려면 웹 페이지가 \"메시지\" 이벤트를 \"청취\"해야 합니다.\n\n다음은 샘플 웹 페이지입니다:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  ...\n</head>\n\n<body>\n  <div>\n    <label for=\"\">호스트로부터의 메시지:</label>\n    <br>\n    <div id=\"message\"></div>\n  </div>\n</body>\n<script>\n  window.addEventListener(\"message\", (event) => {\n    // 수신 메시지 소독(Process of cleaning untrusted input)\n    var content = event.data.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\")\n    document.getElementById(\"message\").innerHTML = content\n  })\n</script>\n\n</html>\n```\n\n웹 페이지는 \"메시지\" 이벤트리스너를 추가합니다. event.data에는 메시지 콘텐츠가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n웹 페이지가 \"메시지\"를 수신하면 해당 내용을 웹 페이지에 단순히 표시합니다.\n\n웹 뷰에 메시지를 보낼 수 있는 UI를 만들어봅시다.\n\n```js\nstruct MessageToWebView: View {\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index3.html\")\n    @State var message: String = \"\"\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"메시지:\")\n                .font(.system(size: 26))\n            HStack(alignment: .center, spacing: 10) {\n                TextField(\"메시지를 입력하세요\", text: $message)\n                    .textFieldStyle(.roundedBorder)\n                    .border(.blue)\n                    .font(.system(size: 26))\n                Button(\"전송\") {\n                    vm.messageTo(message: message)\n                }\n                .buttonStyle(.borderedProminent)\n            }\n            WebView(vm: vm)\n        }\n        .padding()\n    }\n}\n```\n\n![MessagingBetweenWKWebViewandNativeApplicationinSwiftUI](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_7.png)\n\n<div class=\"content-ad\"></div>\n\n\"보내기\" 버튼은 뷰 모델에서 messageTo 메서드를 호출합니다.\n\n```js\nfunc messageTo(message: String) {\n    let escapedMessage = message.replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n    \n    let js = \"window.postMessage(\\\"\\(escapedMessage)\\\", \\\"*\\\")\"\n    self.webView.evaluateJavaScript(js) { (result, error) in\n        if let error = error {\n            print(\"Error: \\(error.localizedDescription)\")\n        }\n    }\n}\n```\n\n위의 다른 시나리오들과는 달리, 구현해야 할 프로토콜 메서드가 없습니다. 웹 뷰로 메시지를 보내기 위한 네이티브 메서드도 없습니다.\n\n대신 네이티브 애플리케이션은 Javascript postMessage 호출을 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nwindow.postMessage(...)\n```\n\npostMessage 메서드는 텍스트 인수를 받습니다. 결과적으로, 웹 뷰의 evaluateJavaScript 메서드에서 실행하기 전에 콘텐츠를 올바르게 이스케이프하고 인코딩해야 합니다.\n\n```js\nfunc evaluateJavaScript(\n    _ javaScriptString: String,\n    completionHandler: ((Any?, Error?) -> Void)? = nil\n)\n```\n\nevaluateJavaScript에는 completionHandler가 있습니다. 이는 반환 값을 또는 에러를 네이티브 응용 프로그램으로 돌려 보내는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\nevaluateJavaScript 메서드는 JavaScript 코드를 실행하거나 평가할 수 있습니다. 예시 코드에서 window.postMessage 호출은 값을 반환하거나 오류를 반환하지 않습니다. 다른 경우에는 실행되는 코드가 값이 반환되고 예외가 발생할 수 있습니다.\n\n마지막으로, 실제 동작을 확인할 수 있습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*AZXEKStS4IuR49Ho-HwihA.gif)\n\n위 웹 페이지에는 이벤트 리스너 선언을 포함한 스크립트 요소가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션이 모든 웹 페이지에 동일한 Javascript 코드를 주입해야 할 때, 모든 웹 페이지에 수동으로 스크립트 요소를 추가하는 대신, 사용자 콘텐츠 컨트롤러의 addUserScript 메서드를 활용할 수 있습니다.\n\n다음은 간단한 구현입니다:\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    ...\n\n   func makeUIView(context: Context) -> WKWebView {\n      ...\n\n      injectJS(userContentController)\n\n      ...\n    }\n\n    func injectJS(_ userContentController: WKUserContentController) {\n        // 메시지 이벤트 리스너 정의\n        //\n        // <script> HTML 요소를 포함할 필요가 없다는 점에 유의하십시오.\n        let msgEventListener = \"\"\"\nwindow.addEventListener(\"message\", (event) => {\n    // 수신된 메시지 정제\n    var content = event.data.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\")\n    document.getElementById(\"message\").innerHTML = content\n})\n\"\"\"\n\n        // 이벤트 리스너 주입\n        userContentController.addUserScript(WKUserScript(source: msgEventListener,\n                                                         injectionTime: .atDocumentEnd,\n                                                         forMainFrameOnly: true))\n    }\n}\n```\n\ninjectJS 함수는 동일한 이벤트 리스너 코드를 가진 변수(msgEventListener)를 포함하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n`addUserScript` 함수에는 `WKUserScript`의 인스턴스가 필요합니다.\n\n`injectionTime`은 `.atDocumentEnd`로 설정되어 있습니다. 이는 원본 스크립트 요소 선언과 동일합니다. 다른 값으로는 `.atDocumentStart`가 있습니다.\n\n만약 자바스크립트 코드가 콘텐츠 요소에 의존한다면, 코드를 `.atDocumentEnd`에 주입하는 것이 가장 좋을 수 있습니다.\n\n만약 자바스크립트 코드가 라이브러리이면, 코드를 `.atDocumentStart`에 주입하는 것이 가장 좋을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nforMainFrameOnly 인수는 부울 값입니다. true를 전달하면 자바스크립트 코드가 주 페이지에만 삽입됩니다. 애플리케이션은 모든 iframe 요소에 동일한 자바스크립트 코드를 삽입하지 않습니다. 그렇지 않으면 자바스크립트 코드는 주 페이지와 해당 iframe 요소에 삽입됩니다.\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_8.png)\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_9.png)\n\n웹 인스펙터에서 삽입된 자바스크립트 코드는 \"추가 스크립트 `user-script:1`\" 아래에 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n사용자가 하이퍼링크를 통해 다른 웹 페이지로 이동하면, 애플리케이션이 해당 웹 페이지에 동일한 자바스크립트 블록을 삽입합니다.\n\n이 웹 페이지에 iframe을 추가하고 forMainFrameOnly를 false로 설정해봅시다.\n\n![image](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_10.png)\n\n웹 인스펙터에서 \"user-script:1\"이 두 번 표시됩니다. 각 웹 페이지는 자바스크립트 코드 블록을 수신합니다.\n\n<div class=\"content-ad\"></div>\n\n# 사용 시나리오\n\n## 앱 내 사용자 가이드\n\niOS 또는 macOS 애플리케이션에서 사용자 가이드나 맥락에 맞는 도움말 정보를 제공해야 하는 경우, 어떻게 할까요?\n\nUIKit의 UILabel 및 SwiftUI의 Text 요소는 기본적인 마크다운 형식을 지원합니다. 서식이 있는 텍스트와 이미지로 유용한 도움말 페이지를 만드는 것은 다소 귀찮은 작업이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n도움 페이지는 HTML과 CSS를 사용하여 웹 페이지로 작성할 수도 있습니다. 도움 페이지는 앱 내에 포함되어 WKWebView를 사용하여 표시될 수 있습니다.\n\n## 사용자 인터페이스\n\nSwiftUI 또는 UIKit을 사용하여 전체 네이티브 애플리케이션을 만드는 대신 대부분의 사용자 인터페이스를 HTML과 CSS를 사용하여 구현할 수 있습니다. 대부분의 비즈니스 로직은 Javascript를 사용하여 구현할 수 있습니다.\n\nReactJS, Angular, VueJS 등의 Javascript 프레임워크를 사용하면 프론트엔드 로직을 구성하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n자바스크립트 UI 라이브러리인 Bootstrap, Foundation, Semantic UI, Tailwind Elements 등은 많은 매력적인 UI 구성 요소들을 제공해요. 이 라이브러리들은 네이티브 애플리케이션의 느낌과 모양에 맞게 사용자정의할 수 있어요.\n\n물론, 이러한 라이브러리와 프레임워크를 사용하면 애플리케이션의 크기가 커질 수 있어요. 현명하게 사용해야 해요!\n\n# 샘플 XCode 프로젝트\n\n해당 XCode 프로젝트에 대한 GitHub 링크는 여기에서 확인할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료\n\n- WKWebView\n- UIViewRepresentable\n- Coordinator\n- WKUIDelegate\n- WKUserContentController\n- WKWebViewConfiguration\n- WKContentWorld\n- WKScriptMessageHandler\n- WKScriptMessageHandlerWithReply\n- WKScriptMessage\n- DOM 메시지 이벤트 및 window.postMessage 메서드\n- WKUserScript\n\n이 기사는 여기서 끝입니다. 아마도 여러분이 프로젝트에서 WKWebView를 어떻게 활용할 수 있는지에 대한 아이디어를 얻을 수 있기를 바랍니다.\n\n이 기사를 즐겁게 읽어 주셨으면 좋겠습니다. 감사합니다!","ogImage":{"url":"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png"},"coverImage":"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png","tag":["Tech"],"readingTime":34},{"title":"ERR_BLOCKED_BY_RESPONSENotSameOrigin 에 대한 간단한 해결 방법","description":"","date":"2024-05-20 23:04","slug":"2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin","content":"\n\n<img src=\"/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png\" />\n\n\"ERR_BLOCKED_BY_RESPONSE.NotSameOrigin\"은 일반적으로 웹 브라우저에서 발생하는 오류입니다. 이 오류는 웹페이지가 접근하려는 리소스가 페이지 자체와 다른 출처(또는 도메인)를 가지고 있는 경우에 발생합니다. 이는 웹 브라우저에 내장된 보안 기능으로, 다중 사이트 스크립팅 공격을 방지하기 위한 것입니다.\n\n웹 페이지가 다른 출처로 요청을 시도할 때, 브라우저는 해당 요청을 차단하고 \"ERR_BLOCKED_BY_RESPONSE.NotSameOrigin\" 오류 메시지를 반환합니다. 이는 요청을 허용할 경우 민감한 정보가 노출되거나 악성 코드가 페이지에서 실행될 수 있기 때문입니다.\n\n이 오류를 해결하려면 페이지가 접근하려는 모든 리소스(예: 이미지, 스크립트 및 기타 파일)가 페이지 자체와 동일한 도메인에 호스팅되어 있는지 확인해야 합니다. 또는 특정 출처가 리소스에 액세스할 수 있도록 크로스 출처 리소스 공유(CORS)를 사용할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n제 프로젝트에서 가져온 간단한 예시입니다:\n\n이미지 파일 위치를 지정하는 src 속성이 있는 HTML img 태그입니다. 이는 제3자 API입니다.\n\n```js\n<img src={`https://countryflagsapi.com/png/${country.alpha3Code.toLowerCase()}`} alt=\"flag\"/>\n```\n\nimg 태그에 crossorigin 속성을 간단히 추가할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<img crossorigin='anonymous' src={`https://countryflagsapi.com/png/${country.alpha3Code.toLowerCase()}`} alt=”flag”/>\n```\n\n문제를 해결할 수 있는 또 다른 고급 방법이 있습니다. Helmet을 사용하여 crossOriginEmbedderPolicy 미들웨어를 비활성화하는 방법도 있습니다. 더 많은 세부 정보는 여기에서 확인할 수 있습니다.\n\n추가 자료:\nRFC 섹션-3.4.2\n","ogImage":{"url":"/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png"},"coverImage":"/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png","tag":["Tech"],"readingTime":2},{"title":"웹사이트로 계산기 프로젝트 만들기","description":"","date":"2024-05-20 23:03","slug":"2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects","content":"\n\n\n![Simple Calculator](/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png)\n\nAs a 1st year IT undergraduate, I always work on pet projects to enhance my skills. I thought I would share my little pet project with you - a simple calculator.\n\n## How did I create this?\n\nI used HTML, CSS, and JavaScript to create this project and used Visual Studio Code as my code editor.\n\n\n<div class=\"content-ad\"></div>\n\n# 하는 일의 중요성 반려동물 프로젝트\n\n요즘에는 인터넷에서 프로그래밍, 코딩 또는 원하는 것을 배울 수 있어요. 기술이 발전함에 따라 지금은 모든 것이 손끝에 있어요. 무엇을 배우든 모든 것을 기억할 수 없을 거예요. 그게 인간의 본성이에요. 하지만 배운 것을 실천해보려고 노력하면 기억에 큰 도움이 될 거예요. 저는 IT 학부생으로 항상 반려동물 프로젝트를 합니다. 반려동물 프로젝트를 통해 당신은\n\n- 이전에 배운 것을 상기시킬 수 있어요.\n- 이론의 실제 응용을 알 수 있어요.\n- 코딩과 프로그래밍을 연습할 수 있어요.\n- 실수로부터 배울 수 있어요.\n- 기술을 향상시키는 좋은 방법이에요.\n- 천천히 산업 수준으로 진입할 수 있어요.\n\n또한, 이렇게 만든 반려동물 프로젝트를 취업 면접에서 보여줄 수 있어요. 분명히 당신에게 이점을 줄 거예요. 아직 시작하지 않았다면, 지금 반려동물 프로젝트에 착수하세요.\n\n<div class=\"content-ad\"></div>\n\n# 내 간단한 계산기에 관한 작은 비디오\n\n# 내 간단한 계산기를 확인해 보세요","ogImage":{"url":"/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png"},"coverImage":"/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png","tag":["Tech"],"readingTime":1},{"title":"웹 개발에 필요한 내용들 전반적으로 소개","description":"","date":"2024-05-20 23:02","slug":"2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT","content":"\n\n웹 개발은 웹 사이트 및 웹 애플리케이션을 만들고 유지 보수하는 동적이고 끊임없이 발전하는 분야입니다. 이 블로그에서는 웹 개발의 개요를 제공하고 프론트엔드, 백엔드, 풀스택 개발 간의 차이를 살펴보며 필수 도구와 기술을 소개할 것입니다. 이 분야에 처음 발을 딛는 초보자이든, 지식을 업데이트하고자 하는 경험 많은 개발자이든, 이 안내서가 안정적인 기반을 제공할 것입니다.\n\n![웹 개발 소개](/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png)\n\n웹 개발은 웹 사이트 및 웹 애플리케이션을 만드는 모든 활동을 포괄합니다. 코딩 및 마크업, 스크립팅, 네트워크 구성, CMS(콘텐츠 관리 시스템) 개발 등이 모두 포함됩니다. 주요 목표는 기능적이고 사용자 친화적이며 시각적으로 매력적인 사이트를 만드는 것입니다.\n\n- 웹 디자인: 웹 사이트의 레이아웃, 색상 구도, 타이포그래피, 전반적인 사용자 경험(UX) 및 사용자 인터페이스(UI) 디자인과 같은 미학적 측면을 다룹니다.\n- 웹 콘텐츠: 웹사이트에서 사용자 경험의 일부로 만나는 텍스트, 시각적 또는 청각적 콘텐츠를 말합니다.\n- 클라이언트 측 스크립팅: 사용자의 웹 브라우저에서 실행되는 코드를 작성하여 상호 작용성과 사용자 경험을 향상시킵니다. HTML, CSS, JavaScript와 같은 기술이 일반적으로 사용됩니다.\n- 서버 측 스크립팅: 서버에서 실행되고 데이터베이스와 상호작용하며 사용자 인증을 처리하고 사용자에게 웹 페이지를 제공하는 코드를 작성하는 것을 말합니다. PHP, ASP.NET, Node.js, Python과 같은 기술이 널리 사용됩니다.\n- 데이터베이스 관리: 웹 애플리케이션을 위해 데이터를 저장하는 데이터베이스를 생성하고 관리하는 작업입니다. MySQL, PostgreSQL, MongoDB와 같은 인기있는 데이터베이스가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n웹 개발은 일반적으로 프론트엔드, 백엔드 및 풀스택 개발 세 가지 주요 범주로 나뉩니다. 각각은 기능적인 웹 애플리케이션을 구축하는 데 중요한 역할을 합니다.\n\n프론트엔드 개발, 또는 클라이언트 측 개발로도 알려져 있으며 사용자가 직접 상호작용하는 웹 사이트 부분에 초점을 맞춥니다. 이는 사용자가 웹 브라우저에서 보거나 상호작용하는 모든 것을 포함합니다. 레이아웃, 버튼, 이미지 및 폼 등이 포함됩니다.\n\n- HTML (Hyper Text Markup Language): 웹 페이지를 생성하는 데 사용되는 표준 마크업 언어로, 웹의 내용을 구조화합니다.\n- CSS (Cascading Style Sheets): HTML로 작성된 문서의 표현을 설명하는 스타일시트 언어로, 레이아웃, 색상, 폰트 및 전반적인 스타일을 제어합니다.\n- JavaScript: 상호작용적인 웹 페이지를 만들 수 있는 프로그래밍 언어로, 동적 콘텐츠 생성, 멀티미디어 제어, 이미지 애니메이션 등 다양한 용도에 사용됩니다.\n- 프론트엔드 프레임워크 및 라이브러리: React, Angular, Vue.js와 같은 도구를 사용하여 재사용 가능한 컴포넌트와 효율적인 상태 관리를 제공하여 프론트엔드 개발을 단순화하고 향상시킵니다.\n\n![이미지](/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_1.png)\n\n<div class=\"content-ad\"></div>\n\n백엔드 개발 또는 서버 측 개발은 웹 사이트의 서버 측에 초점을 맞춥니다. 이는 데이터를 처리하고 전면에서 의도한 대로 작동하도록 하는 메커니즘을 생성하고 유지하는 작업을 포함합니다. \n\n- 서버 사이드 언어: Python, Ruby, Java, PHP, C#과 같은 언어들이 서버 측 로직을 작성하는 데 일반적으로 사용됩니다.\n- 프레임워크: Express(Node.js), Django(Python), Ruby on Rails(Ruby), ASP.NET(C#)과 같은 프레임워크는 견고한 백엔드 애플리케이션을 개발하기 위한 구조와 도구를 제공합니다.\n- 데이터베이스: MySQL, PostgreSQL, MongoDB, SQL Server 등의 데이터베이스는 웹 애플리케이션의 데이터를 저장하고 관리합니다.\n- API (Application Programming Interfaces): RESTful 및 GraphQL API는 전면 및 백엔드 간, 백엔드 서비스 간의 통신을 활성화하는 데 사용됩니다.\n\n<img src=\"/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_2.png\" />\n\n풀 스택 개발은 개발자가 웹 애플리케이션의 전면 및 백엔드 부분 모두에 작업하는 포괄적인 접근 방식을 의미합니다. 풀 스택 개발자는 넓은 스킬 세트를 갖추고 프로젝트를 처음부터 끝까지 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n주요 기술:\n\n- 프론트엔드 및 백엔드 기술 능숙\n- 데이터베이스 및 데이터 관리 이해\n- Git과 같은 버전 관리 시스템에 대한 이해\n- API 작업 및 다른 서비스 통합 능력\n\n숙련된 웹 개발자가 되기 위해서는 다양한 도구와 기술에 익숙해져야 합니다. 여기 몇 가지 필수 요소가 있습니다:\n\n텍스트 편집기 및 통합 개발 환경(IDE): Visual Studio Code, Sublime Text, IntelliJ IDEA와 같은 도구는 코딩에 효율적인 환경을 제공합니다.\n버전 관리 시스템: Git은 가장 인기 있는 버전 관리 시스템이며, GitHub, GitLab, Bitbucket과 같은 플랫폼은 협력 개발과 코드 공유를 용이하게 합니다.\n패키지 관리자: npm(Node Package Manager)와 yarn과 같은 도구는 프로젝트 의존성 및 라이브러리를 관리하는 데 도움을 줍니다.\n\n<div class=\"content-ad\"></div>\n\n- HTML/CSS/JavaScript: 웹 페이지를 구축하고 스타일링하는 데 필수적인 핵심 기술들입니다.\n- 프런트엔드 프레임워크/라이브러리: React, Angular, Vue.js는 동적 사용자 인터페이스를 구축하는 데 인기 있는 선택지입니다.\n- 반응형 디자인: Bootstrap 및 Foundation 같은 프레임워크는 반응형 및 모바일 친화적인 디자인을 도와줍니다.\n\n- 서버 사이드 언어: JavaScript (Node.js), Python, Ruby, Java, C#과 같은 언어들이 있습니다.\n- 백엔드 프레임워크: Express (Node.js), Django (Python), Ruby on Rails (Ruby), ASP.NET (C#) 등이 있습니다.\n- 데이터베이스: MySQL, PostgreSQL와 같은 SQL 데이터베이스와 MongoDB와 같은 NoSQL 데이터베이스가 있습니다.\n\n- 버전 관리: Git과 GitHub 같은 플랫폼입니다.\n- 작업런너 및 모듈 번들러: Gulp, Grunt, Webpack과 같은 도구들은 반복적인 작업을 자동화하고 JavaScript 파일을 번들링하는 데 도움이 됩니다.\n- API 테스팅 도구: Postman 및 Insomnia는 API를 테스트하고 디버깅하는 데 유용합니다.\n\n웹 개발은 다양한 기술과 지식을 요구하는 다각적인 분야입니다. 프런트엔드, 백엔드 및 풀스택 개발의 차이를 이해하고 필수 도구와 기술에 익숙해지면 능숙한 웹 개발자로 나아갈 수 있습니다. 앞으로의 블로그에서는 웹 개발의 각 측면을 더 자세히 살펴보며 실전 예제와 상세한 설명을 제공하여 견고하고 동적인 웹 애플리케이션을 만드는 과정을 안내할 예정입니다.","ogImage":{"url":"/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png"},"coverImage":"/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png","tag":["Tech"],"readingTime":4}],"page":"61","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}