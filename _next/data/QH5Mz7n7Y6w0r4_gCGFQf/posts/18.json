{"pageProps":{"posts":[{"title":"고급 자료 구조와 알고리즘 트라이tries 사용법 완벽 가이드","description":"","date":"2024-06-22 13:46","slug":"2024-06-22-AdvancedDataStructuresandAlgorithmsTries","content":"\n\n## 트라이(Tries)로 직접 Google을 만들어보기: 잠재적 검색 엔진 구현의 내부를 살펴보겠습니다\n\n![image](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_0.png)\n\n우리는 모두 웹 애플리케이션에 어떤 종류의 검색을 구축하는 데 익숙합니다. 특히 \"구축\"을 단순히 프로젝트에 Algolia 플러그인을 추가하고 SDK를 사용하여 그들의 API를 호출하는 것으로 생각한다면요.\n\n사실, 웹 애플리케이션에 기본 검색을 구현하는 것은 이제 그렇게 어렵지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 API라는 \"커튼\" 뒤에 사용되는 알고리즘이 어떤 종류인지 생각해 본 적이 있나요?\n\n오늘은 \"고급\" 데이터 구조라고 부르는 것을 살펴볼 것입니다. 이 구조는 텍스트 코퍼스 안에서 텍스트 검색을 수행하는 데 사용할 수 있는데, 그것이 바로 \"Tries\"입니다.\n\n저는 최근까지 이들에 대해 들어본 적이 없어서 여러분도 비슷하다면 놀라지 마세요. 하지만 걱정하지 마세요. 실제로는 생각보다 덜 위험하게 들립니다.\n\n자, 시작해 보죠!\n\n<div class=\"content-ad\"></div>\n\n# 트라이(Tries)는 무엇인가요?\n\n우선 이해해야 할 것은 트라이가 트리(Tree)의 특별한 종류임을 알아야 합니다. 우리 모두가 트리를 알고 있죠. 각 노드가 다양한 수의 자식 노드 요소를 가질 수 있는 방법으로 노드 객체를 구성하는 방법입니다. 노드가 자식이 없으면 “잎 노드”라고 부릅니다(“트리” 비유를 유지하면서).\n\n이제 트라이는 특별한데, 각 노드는 알파벳순으로 최대 26개의 자식을 가질 수 있다는 점입니다 (다른 알파벳을 사용하려면 해당 숫자가 달라지겠지만, 모든 노드가 동일한 최대 자식 수를 가집니다).\n\n그 위에, 단어는 트리 전체에 \"수직으로\" (또는 레벨별로) 삽입됩니다. 이것이 트라이가 어떻게 보이는지 보여드리죠:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_1.png)\n\nTrie의 루트는 항상 \"null\"일 것입니다. 이 것이 이 데이터 구조의 한 가지 특징입니다. 제가 4개의 단어를 추가했음을 볼 수 있습니다:\n\n- All\n- Alt\n- Cat\n- Cow\n\n이것들을 수직으로 읽을 수 있습니다. 이것이 제가 이전에 \"레벨\"이라고 했던 의미입니다. 각 레벨은 우리 단어에서의 위치가 될 것입니다. 각 단어의 마지막 노드는 또한 플래그 \"isFinal\"과 함께 표시될 것입니다. 이 플래그가 얼마나 중요한 지 곧 알게 될 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n여러 자식을 가진 노드가 있을 때는 알파벳 순으로 정렬됩니다. 이는 데이터를 삽입하고 나중에 검색하는 알고리즘을 간단하게 만들기 위해 정렬된 것입니다. 기억하세요, 우리는 소문자 \"a\"부터 \"z\"까지 26개의 문자만 다룬다는 가정 아래 작업을 하고 있습니다. 보다 유연성을 가지려면 이 숫자를 높일 수 있으며 노드를 적절하게 색인화하는 방법을 찾을 수 있습니다.\n\n그래서 Trie로 가장 기본적인 두 가지 작업을 어떻게 구현할 수 있는지 살펴봅시다: 데이터를 삽입하고, 나중에 그 데이터를 검색하는 것입니다.\n\n읽은 내용이 마음에 드셨나요? IT 산업에서 2십 년 간의 지혜를 무료로 공유하는 제 뉴스레터에 구독해 보시는 건 어떨까요? \"The Rambling of an old developer\"에 가입해보세요!\n\n# Trie에 데이터 삽입하기\n\n<div class=\"content-ad\"></div>\n\n이 데이터 구조 안에 데이터를 삽입하는 데 필요한 기본 알고리즘은 간단합니다:\n\n- 삽입하려는 단어를 소문자로 변환합니다.\n- 루트의 자식 노드들 중에서 단어의 첫 글자를 찾습니다.\n- 글자가 예상한 위치에 있나요? 그렇다면 단어의 다음 글자로 넘어가고 방금 찾은 현재 글자의 자식 노드들 중에서 해당 글자를 찾습니다.\n- 글자를 찾을 수 없다면 새로운 노드를 추가하고 단어의 다음 글자로 넘어갑니다.\n\n글자가 떨어질 때까지 이러한 과정을 계속 반복하다가 마지막 글자를 “isFinal”로 표시하면 완료됩니다.\n\n예를 들어, \"ALL\"이라는 단어를 빈 Trie에 추가한다고 가정하면:\n\n<div class=\"content-ad\"></div>\n\n- 소문자를 \"모두\"로 변경합니다.\n- 루트에 첫 번째 자식 노드에 \"a\"가 있나요? 아니요, 비어 있기 때문에 첫 번째 자식 슬롯에 새 노드를 추가합니다.\n- 이제 첫 번째 \"l\"로 이동합니다. 이 \"l\"은 \"a\"의 12번째 자식에 없습니다. 왜냐하면 후자가 방금 추가되었기 때문입니다. 따라서 12번째 자식 슬롯에 \"l\"을 위한 새 노드를 추가합니다.\n- 마지막 \"l\"로 이동하면 똑같은 작업을 반복합니다. 이전 글자(첫 번째 \"l\") 내에서 12번째 자식 슬롯을 찾아서 비어 있기 때문에 마지막 \"l\"을 위한 새 노드를 만듭니다. 유일한 차이점은 \"isFinal\"로도 표시한다는 것입니다.\n\n이제 \"alt\" 단어를 추가하려면 첫 두 글자가 이미 있음을 알 수 있습니다. 따라서 해당 노드를 추가하는 부분을 건너 뜁니다.\n\nJavaScript로 어떻게 변환되는지 이해하기 위해 코드를 살펴봅시다:\n\n노드는 구조가 매우 간단합니다. 솔직히 말해서 레이블 속성조차 선택 사항입니다. 노드의 실제 위치가 나타내는 글자를 결정하기 때문입니다. 그렇다고 해서 이해하기 쉽다고 생각하기 때문에 이 방법을 사용하는 것이 더 좋다고 생각합니다. 마음대로 수정하셔도 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n실제 Trie는 이렇게 생겼어요:\n\n보시다시피, 생성 시에 \"루트\" 노드는 null로 초기화되고 새로운 단어를 삽입할 때마다 루트의 자식부터 시작해서 이동합니다.\n\n단어의 마지막 노드는 isFinalLetter로 표시되어 해당 단어의 끝을 알 수 있습니다. 이를 통해 검색이 어떻게 수행되는지 알아보기 전에 중요한 부분이 됩니다.\n\n# Trie 내에서 데이터 검색하기\n\n<div class=\"content-ad\"></div>\n\n검색은 실제로 삽입과 매우 유사합니다. 우리는 동일한 알고리즘을 따라 Trie를 통과해야 하기 때문에 찾으려는 글자가 없는 경우, 추가하는 대신 false를 반환해야 합니다.\n\n이제 검색에 대한 다른 작은 세부 사항은 단어의 끝에서 모든 글자를 찾았을 때, 마지막 노드가 isFinalLetter로 표시되어 있는지 확인해야 한다는 것입니다. 그럴 경우, Trie에 단어가 존재하는 것을 의미하고, 그렇지 않으면 삽입된 단어의 부분 문자열을 찾고 있으므로 \"부분\" 일치를 얻었다는 것을 의미합니다.\n\n기본적으로 Trie에 \"Words\"라는 단어가 있는 것을 상상해보세요.\n\n- \"want\"를 찾는 경우에는 \"w\"의 자식들에서 \"a\"를 찾을 수 없기 때문에 \"there\"가 아닙니다.\n- \"word\"를 찾는 경우에는 \"d\"에 도달하지만 \"d\"가 isFinalLetter로 표시되지 않으므로 \"word\"가 Trie에 없음을 알 수 있지만 그 단어를 포함하는 다른 단어를 찾은 것을 알 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n자, 이제 코드로 어떻게 보이는지 확인해 봅시다:\n\n이전과 동일한 클래스이지만 검색 방법이 바뀌어서 더 읽기 쉽습니다.\n\n이 메서드는 다음 세 가지 값을 반환합니다:\n\n- 일치하는 값이 없으면 false를 반환합니다.\n- 최종 글자까지 도달하여 마지막 글자가 실제로 isFinalLetter로 표시된 경우 full-match를 반환합니다\n- 끝까지 도달하였지만 마지막 글자가 표시되지 않은 경우 partial-match를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n이 방법에서는 forEach를 일반 for로 바꿨어요. 후자를 사용하면 간단한 return 문으로 빨리 반환할 수 있지만, 전자는 전체 단어를 모두 확인할 때까지 빠져나올 수 없어요.\n\n다음 예제는 지금까지 본 모든 것을 사용합니다:\n\n결과는 당신이 기대하는 대로 이렇습니다:\n\n```js\n'fer'를 찾고 있습니다: 완전일치\n'angel'을 찾고 있습니다: 없음\n'fernando2'을 찾고 있습니다: 없음\n'federico'를 찾고 있습니다: 완전일치\n'fern'을 찾고 있습니다: 부분일치\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 한 걸음 더 나아가보죠. 실험은 재미있지만, 실제 애플리케이션에서 어떻게 사용할까요? 그렇다면 Next 앱에 이를 추가하는 방법을 보겠습니다!\n\n# Next 내 Trie-검색 사용하기\n\n사용하고 싶은 프레임워크를 선택할 수 있습니다. 저는 Next를 선택했는데, 그 이유는 좋은 API 프레임워크를 제공하기 때문입니다.\n\n간단하게 npx create-next-app@latest 명령을 사용해서 새로운 앱을 만들겠습니다.\n\n<div class=\"content-ad\"></div>\n\n새 앱의 폴더 구조 안에 다음과 같은 새 폴더를 만들 것입니다:\n\n- /components: 여기에 새로운 검색 컴포넌트를 추가할 것입니다.\n- /utils: 여기에는 방금 보여드린 클래스가 있는 tries 폴더를 저장하고 새로운 search.js 파일을 추가할 것입니다. 이 파일은 우리의 Trie에 대한 게이트웨이 역할을 할 것입니다.\n\n검색 서비스는 백엔드에 유지할 것이므로, 우리는 페이지/api/search 폴더 안에 추가할 API 엔드포인트를 통해 상호 작용할 것입니다.\n\n마지막으로, 당신의 폴더 구조는 다음과 같이 보일 것입니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_2.png\" />\n\n## 검색 엔드포인트 추가\n\n이 예제에서는 검색 엔드포인트를 만들어 보겠습니다. 매우 간단하게 처리할 것이며 모든 요청을 처리하고 검색 문자열이 저장될 q 쿼리 매개변수를 찾을 것입니다.\n\n따라서 전체 코드는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n조금 후에 getSearch 함수에 대해 걱정할 거예요. 이제 알아둬야 할 것은 당신에게 Trie 인스턴스에 액세스할 수 있다는 것뿐이에요.\n\n## 검색 UI 구성요소 추가\n\n사용자가 무언가를 검색하고 어떤 피드백을 보여줄 수 있도록 UI 구성 요소가 필요할 거예요.\n\n우리 경우에는 피드백이 \"찾을 수 없음\", \"부분 일치\" 또는 \"전체 일치\"일 거예요. 하지만 당신이 원하는 만큼 창의적이 해도 돼요.\n\n<div class=\"content-ad\"></div>\n\n우리 컴포넌트의 코드는 다음과 같이 보입니다:\n\n다시 말하지만, 이것은 그리 미친 짓은 아닙니다. 입력 필드가 변경될 때마다 새 API로 Fetch 요청을 수행하는 컴포넌트뿐입니다. 이것을 개선하고 요청의 수를 제어하는 방법을 찾을 수 있을 겁니다.\n\n다음은 렌더링된 결과입니다 (여기에는 스타일이 없으므로 예쁘지 않을 수 있습니다!):\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_3.png)\n\n<div class=\"content-ad\"></div>\n\n방금 말했잖아요!\n\n이제 getSearch 함수를 살펴봅시다. 이 함수는 흥미로운 일을 하고 있어요.\n\n## 검색 게이트웨이\n\n무언가를 검색할 수 있도록 하려면, 우리 Trie에 그 \"무언가\"를 먼저 삽입해야 합니다. 그래서 그 \"무언가\"를 언제 삽입하는 거죠?\n\n<div class=\"content-ad\"></div>\n\n저희 검색 엔진의 \"코퍼스\"를 첫 번째 검색 요청으로 로드하기로 결정했습니다. 그리고 메모리에 Trie를 유지하고 기본 싱글톤 패턴을 구현하여 덮어쓰지 않도록하겠습니다. 다음과 같이요:\n\n여러분은 아마도 제가 실제 Trie를 처음으로 생성할 때 몇 가지 단어를 Trie에 추가하는 loadIndex 함수를 호출하는 것을 확인할 수 있습니다. 그런 다음에는 처음 생성한 인스턴스를 반환하는 것 뿐입니다.\n\n이 방법은 전체 앱 실행 중에 단일 인스턴스를 유지하는 깔끔한 방법입니다.\n\n이 예제를 더 자세히 살펴보고 싶다면, 여기에서 코드를 확인해보세요. 즐겁게 이용하세요!\n\n<div class=\"content-ad\"></div>\n\n이전에 Trie에 대해 들어보셨나요? 혹은 더 좋은 경우, 어디에 사용해 본 적이 있나요? 댓글에서 여러분의 경험을 공유해 주세요. 무엇을 해봤는지 알고 싶어요!\n\n# 레고처럼 재사용 가능한 구성 요소로 앱 만들기\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_4.png)\n\nBit은 25만 명 이상의 개발자가 컴포넌트로 앱을 구축하는 데 도움을 주는 오픈 소스 도구입니다.\n\n<div class=\"content-ad\"></div>\n\n어떠한 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 변환하여 여러 애플리케이션 간에 공유하세요. 협업이 쉬워지고 더 빠르게 개발할 수 있습니다.\n\n→ 더 알아보기\n\n애플리케이션을 구성 요소로 나누어 앱 개발을 쉽게 만들고 원하는 워크플로에 대한 최상의 경험을 누려보세요:\n\n## → Micro-Frontends\n\n<div class=\"content-ad\"></div>\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 단일 저장소\n\n# 자세히 알아보기","ogImage":{"url":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_0.png"},"coverImage":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 인기를 끌고 있는 오픈 소스 도구 4가지","description":"","date":"2024-06-22 13:44","slug":"2024-06-22-4TrendingOpenSourcetools","content":"\n\n효율적인 응용 프로그램을 개발하기 위한 효과적인 도구와 플랫폼의 필요성은 절대적입니다. 이 분야에서 큰 발전을 이루고 있는 네 가지 주목할만한 오픈 소스 솔루션은 Bisheng, CesiumJS, Dokploy 및 AgentScope입니다.\n\n각 플랫폼은 다양한 응용 프로그램 개발 측면을 고려한 독특한 기능과 기능을 제공합니다. 큰 언어 모델부터 대화형 3D 매핑, 셀프 호스트된 PaaS 솔루션 및 다중 에이전트 시스템까지 다양한 기능을 갖추고 있습니다. 본 문서에서는 이러한 혁신적인 도구들에 대한 개요를 제공하며, 주요 기능 및 잠재적인 응용 분야를 강조합니다.\n\n## 더 읽기:\n\nUX를 위한 카드 정렬 이해\n\n<div class=\"content-ad\"></div>\n\n4가지 개방형 소스 도구로 설명 가능한 AI\n\n값에 의한 전달과 참조에 의한 전달 이해하기\n\n자원봉사 기회를 찾을 수 있는 새로운 앱\n\n그리고 구독 무료인 AI 뉴스레터 BrainScriblr도 쓰고 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 비생\n\n비생은 대규모 언어 모델 (LLM) 애플리케이션의 개발을 가속화하고 간소화하기 위해 디자인되었습니다. Apache 2.0 라이선스 하에 출시되었으며, 비즈니스 사용자와 기술 전문가 모두에게 액세스 가능하도록 LLM 개발을 민주화하는 것을 목표로 합니다.\n\n비생은 사전 구성된 애플리케이션 템플릿 및 직관적인 폼 작성 프로세스를 통해 비즈니스 사용자에게 사용 용이성이 제공됩니다. 이를 통해 깊은 기술적 전문 지식이 없는 사람들도 빠르게 LLM을 중심으로 한 지능적인 애플리케이션을 구축할 수 있습니다.\n\nLLM 기술에 익숙한 개발자들을 위해, 비생은 수백 가지 개발 구성 요소와 시각적 프로세스 조종 기능을 제공하여 다양하고 정교한 LLM 애플리케이션을 만들 수 있도록 광범위한 유연성을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\nBisheng은 계약 검토, 신용 조사, 문서 요약과 같은 작업에 대한 분석 보고서 생성을 포함한 다양한 응용 프로그램을 개발할 수 있도록 지원합니다. 또한 사용 설명서 Q&A 및 연구 보고서 지식 베이스를 포함한 지식 베이스 Q&A 시스템의 작성을 지원합니다.\n\n마지막으로 Bisheng은 면접관이나 외국어 교사로서의 역할 연기, 이력서 최적화, 그리고 계약서, 공학 보고서 등에서 요소를 추출하는 작업을 쉽게 할 수 있도록 지원합니다.\n\n## Cesiumjs\n\nCesiumJS는 플러그인 없이 웹 브라우저에서 대화형 3D 지구 및 지도를 생성하기 위한 오픈 소스 JavaScript 라이브러리입니다.\n\n<div class=\"content-ad\"></div>\n\nCesiumJS는 하드웨어 가속화된 그래픽을 위해 WebGL을 사용하며 크로스 플랫폼, 크로스 브라우저이며 대규모 데이터 시각화에 최적화되어 있습니다. 강력한 상호 운용성을 위해 오픈 포맷으로 구축되어 있으며 대규모 데이터 세트에 대한 확장성을 제공합니다. 주요 기능으로는 3D Tiles 스트리밍 및 기타 표준 포맷, 고정밀도 WGS84 지구를 사용한 데이터 시각화 및 분석, 데스크톱이나 모바일 사용자와 데이터 공유가 있습니다.\n\nCesiumJS는 Apache 2.0 라이선스로 출시되었으며 2012년부터 오픈 소스로 제공되어 상업적 및 비상업적 사용 모두 무료입니다. 시작하려면 CDN에서 가져오거나 npm을 통해 설치할 수 있습니다. CesiumJS 퀵 스타트 가이드는 실제 데이터를 사용하여 앱을 설정하는 단계별 지침을 제공합니다.\n\n또한 CesiumJS는 ArcGIS 위치 서비스와 통합되어 개발자가 지오코딩, 루팅, 데이터 풍부화 및 공간 쿼리와 같은 기능에 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-4TrendingOpenSourcetools_0.png)\n\n<div class=\"content-ad\"></div>\n\n## 독플로이\n\n독플로이는 배포와 애플리케이션 및 데이터베이스 관리를 간단하게 해주는 무료 오픈 소스 자체 호스팅 가능한 플랫폼서비스(PaaS) 입니다.\n\n독플로이는 Node.js, PHP, Python, Go, Ruby 등 도커화할 수 있는 모든 종류의 애플리케이션을 배포하는 것을 지원합니다. 또한 MySQL, PostgreSQL, MongoDB, MariaDB, Redis와 같은 데이터베이스의 생성과 관리도 지원합니다.\n\n독플로이의 중요한 기능은 데이터베이스에 대한 자동 백업, Docker Compose의 네이티브 지원, Docker Swarm을 사용한 멀티 노드 스케일링, 오픈 소스 템플릿의 원클릭 배포, 자원의 실시간 모니터링 및 사용자 친화적인 웹 인터페이스가 있습니다.\n\n<div class=\"content-ad\"></div>\n\nDokploy는 Vercel, Netlify 및 Heroku와 같은 플랫폼 대안으로 개방형 소스로 위치하고 있습니다. 사용자들은 자체 VPS에 플랫폼을 호스팅하고 벤더 잠금 현상이나 관리 서비스 비용을 피할 수 있습니다.\n\nDokploy는 각 애플리케이션에 대한 웹훅 URL을 제공하여 GitHub 또는 DockerHub와 같은 서비스와 통합하여 자동 배포에 사용할 수 있습니다. 다른 태그가 있는 여러 이미지가 푸시될 때 Dokploy는 현재 각 태그별로 별도의 배포 작업을 트리거합니다.\n\nDokploy는 비교적 새로운 프로젝트이지만 활발한 커뮤니티를 갖고 있으며 새로운 기능으로 지속적으로 개선 중입니다. 다른 오픈 소스 PaaS 대안으로는 CapRover, KintoHub 및 Render가 있습니다.\n\n![이미지](/assets/img/2024-06-22-4TrendingOpenSourcetools_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 에이전트 범위\n\n에이전트 스코프는 개발자가 대형 언어 모델(LLMs)을 사용하여 더 쉽게 애플리케이션을 개발할 수 있는 오픈 소스 멀티에이전트 플랫폼입니다.\n\n에이전트 스코프는 LLM을 에이전트에 통합하여 고급 추론, 지식, 대화 능력을 가능하게 하는 LLM-강화형 에이전트, 유연한 에이전트 상호작용을 지원하는 에이전트 상호작용, 중앙화된 프로그래밍 방식으로 분산 멀티에이전트 애플리케이션을 구축하기 위한 Actor-Based Distribution과 같은 세 가지 고수준 기능을 제공합니다.\n\n에이전트 스코프는 OpenAI (gpt-4, gpt-3.5-turbo 등), Hugging Face, BLOOM, Llama, Vicuna, Alpaca, ChatGLM, MOSS 등 다양한 모델 라이브러리 및 API를 지원합니다. 이를 쉽게 통합할 수 있도록 `ModelWrapper` 클래스를 제공합니다. 최신 릴리스(v0.0.4)에서는 에이전트 스코프 워크스테이션, AgentScope에 대한 질문에 대답하는 코파일럿, Llama3 및 DashScope와 같은 더 많은 모델 지원, 새로운 예제 등 여러 새로운 기능을 소개했습니다.\n\n<div class=\"content-ad\"></div>\n\nAgentScope은 Python 3.9 이상을 필요로 하며 소스로부터 설치할 수 있습니다. 자세한 설치 지침은 README에 제공됩니다. 해당 저장소에는 AgentScope의 기능을 보여주는 다양한 예제가 포함되어 있습니다. 예를 들어 멀티 에이전트 대화, AI 지원 프로그래밍, AI 지원 쉘, 멀티 에이전트 논쟁, 고모쿠 게임 등이 있습니다.\n\n이 프로젝트는 다양한 기여자들로 이루어진 활발한 커뮤니티를 가지고 있습니다. 해당 저장소에는 최근 풀 리퀘스트와 새로운 기능, 향상 사항, 버그 수정에 대한 이슈가 토론되고 있습니다.\n\n결론적으로, AgentScope은 대형 언어 모델을 활용한 멀티 에이전트 애플리케이션 개발을 간단하게 만드는 유연하고 견고한 오픈 소스 플랫폼입니다.\n\n이 네 플랫폼은 오픈 소스 개발 도구의 최첨단을 대표하며, 각각 기술 생태계 내에서 특정 요구 사항을 해결합니다. LLM 애플리케이션 생성, 3D 데이터 시각화, 쉬운 애플리케이션 배포, 멀티 에이전트 시스템 구축 등을 위한 강력한 솔루션을 제공하는 Bisheng, CesiumJS, Dokploy, 그리고 AgentScope은 현대 개발자들을 위한 강력한 도구입니다.","ogImage":{"url":"/assets/img/2024-06-22-4TrendingOpenSourcetools_0.png"},"coverImage":"/assets/img/2024-06-22-4TrendingOpenSourcetools_0.png","tag":["Tech"],"readingTime":5},{"title":"경이로운 WebGL 점 구체 만드는 방법","description":"","date":"2024-06-22 13:43","slug":"2024-06-22-StunningWebGLDotSpheres","content":"\n\n\n![Image](/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png)\n\n최근에 Stripe와 GitHub에서 WebGL 지구 모형이 눈에 띄게 사용되면서 많은 관심을 받았습니다. 둘 다 자사 홈페이지에서 그것들을 주목적으로 활용했고, 이에 관한 블로그 포스트를 작성했습니다(Stripe의 포스트는 [여기](Stripe's link)에서 확인할 수 있고, GitHub의는 [여기](GitHub's link)에서 확인할 수 있습니다).\n\n두 지구 모형은 대부분 점들로 이루어져 있는데, 이것이 저에게 구체 표면에 점들을 분산시키는 다양한 방법에 대해 생각해보게 했습니다. 구 형태에 대한 점 배치는 수학자들이 적극적으로 고민하는 복잡한 퍼즐로, 이 기사를 위해서 제가 몇 가지 기본적인 방법을 소개하고 WebGL에서 어떻게 구현할 수 있는지에 대해 제한했습니다.\n\n# 씬 설정하기\n\n\n<div class=\"content-ad\"></div>\n\n현재 진행하기 전에, 구를 만들 WebGL 씬을 구축하는 것이 필요합니다. WebGL API와 상호 작용하기 위한 주요 프레임워크로 Three.js를 사용하고 있어요. 이 글의 코드 스니펫은 간결하고 관련성이 높도록 유지하고 있으니, 전체 코드를 확인하려면 포함된 샌드박스를 살펴보세요.\n\n씬을 생성한 후, 모든 점에 대한 geometries를 포함할 dotGeometries 배열을 정의합니다. 그런 다음, 씬 내의 공간에 빈 벡터, 즉 3D 포인트를 생성하며, 해당 위치는 각각의 점을 만들 때마다 재할당됩니다.\n\n```js\n// 씬을 설정합니다.\nconst scene = new THREE.Scene();\n\n// 모든 점의 geometries를 보관할 배열을 정의합니다.\nconst dotGeometries = [];\n\n// 점에서 사용할 빈 벡터를 생성합니다.\nconst vector = new THREE.Vector3();\n\n// 이곳에서 점을 생성하고 위치를 지정합니다!\n```\n\n점을 생성하고 그 geometries를 dotGeometries 배열에 넣은 후, mergeBufferGeometries 유틸리티를 사용하여 이를 하나의 geometry로 병합할 수 있습니다. 그런 다음, dot geometries에서 mesh를 생성하고, 이에 재질을 부여하고 씬에 추가하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 모든 점 지오메트리를 하나의 버퍼 지오메트리로 병합합니다.\nconst mergedDotGeometries = BufferGeometryUtils.mergeBufferGeometries(\n  dotGeometries\n);\n\n// 점을 위한 재질을 정의합니다.\nconst dotMaterial = new THREE.MeshBasicMaterial({\n  color: DOT_COLOR,\n  side: THREE.DoubleSide\n});\n\n// 점 지오메트리와 재질에서 점 메시를 생성합니다.\nconst dotMesh = new THREE.Mesh(mergedDotGeometries, dotMaterial);\n\n// 점 메시를 씬에 추가합니다.\nscene.add(dotMesh);\n```\n\n이제 어떻게 점을 생성하고 배치할지 살펴봅시다.\n\n# 기본적인 접근 방법\n\n구에 점을 추가하는 가장 쉬운 방법은 단순히 구가 갖도록 원하는 위도 선 및 경도 선의 수를 정의한 다음 해당 선들에 따라 점을 배치하는 것입니다. 여기에는 몇 가지 중요한 사항이 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n먼저, 각 점에 대해 phi와 theta 각도를 정의합니다. 이러한 각도는 구 좌표계의 일부로, 점이 3D 공간에서 원점과의 관계를 정확히 나타내는 시스템입니다 (우리의 경우에는 구의 중심).\n\n두 번째로, phi와 theta는 모두 라디안으로 측정됩니다. 핵심은 180º에 π 라디안이 있다는 것을 기억하는 것입니다. 여기서 phi를 찾기 위해선 단순히 π를 위도 주선 수로 나누면 됩니다. 그러나 theta를 찾기 위해서는 경도 주선 수로 2 * π를 나누어야 합니다. 왜냐하면 경도 주선이 구의 전체 360º를 계속 감싸도록 하기 때문입니다.\n\n```js\n// 위도를 반복합니다.\nfor (let lat = 0; lat < LATITUDE_COUNT; lat += 1) {\n  // 경도를 반복합니다.\n  for (let lng = 0; lng < LONGITUDE_COUNT; lng += 1) {\n    // 점에 대한 geometry를 생성합니다.\n    const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n    // 점을 위한 phi와 theta 각도를 정의합니다.\n    const phi = (Math.PI / LATITUDE_COUNT) * lat;\n    const theta = ((2 * Math.PI) / LONGITUDE_COUNT) * lng;\n\n    // 구 반지름, phi 및 theta에서 생성된 구 좌표를 사용하여 벡터를 설정합니다.\n    vector.setFromSphericalCoords(SPHERE_RADIUS, phi, theta);\n\n    // 점이 올바른 방향을 향하도록 합니다.\n    dotGeometry.lookAt(vector);\n\n    // 점 geometry를 올바른 위치로 이동합니다.\n    dotGeometry.translate(vector.x, vector.y, vector.z);\n\n    // 위치 지정 geometry를 배열에 추가합니다.\n    dotGeometries.push(dotGeometry);\n  }\n}\n```\n\n이렇게 해서 다음 결과를 얻을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n만약 구를 회전시키면, 맨 위와 맨 아래의 고리가 가운데보다 훨씬 더 밀집되어 있는 것을 알게 될 거에요. 이는 각 위도선에 있는 점들의 개수를 다양하게 하지 않았기 때문입니다. 여기서 구 패킹이 필요한 때입니다.\n\n# 실로택시스 방법론\n\n해바라기 꽃의 머리나 솔방울의 바닥을 본 적이 있다면, 이상하고 독특한 패턴을 알아차릴 수 있을 겁니다. 이 패턴은 피보나치 수열을 기반으로 하는 배열에 의해 만들어져, 실로택시스로 알려져 있습니다. 이를 이용하여 점들을 구의 표면 위에 더 균일하게 위치시켜 보이도록 할 수 있습니다.\n\n이번에는 위도와 경도 선의 개수를 정의하는 대신, 단순히 구에 나타나길 원하는 총 점의 수를 정의합니다. 위도 선을 가로지르는 대신, 점들은 구의 한 극에서 다른 극까지 단일하고 연속적인 나선 형태로 렌더링될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 점의 개수만큼 반복합니다.\nfor (let dot = 0; dot < DOT_COUNT; dot += 1) {\n  // 점을 위한 geometry를 생성합니다.\n  const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n\n  // 각 점의 구면 좌표를 계산하여 피로태시스 패턴으로 만듭니다.\n  const phi = Math.acos(-1 + (2 * dot) / DOT_COUNT);\n  const theta = Math.sqrt(DOT_COUNT * Math.PI) * phi;\n\n  // 구의 반지름, phi 및 theta에서 생성된 구면 좌표를 사용하여 벡터를 설정합니다.\n  vector.setFromSphericalCoords(SPHERE_RADIUS, phi, theta);\n\n  ...\n\n}\n```\n\n위와 같은 결과가 나타납니다.\n\n이 방법은 훨씬 더 만족스럽습니다. 그러나 가능한 한 점들을 골고루 배치하고 싶지만 자유롭게 위도 선 수를 정의하고 싶다면 어떻게 해야 할까요?\n\n# 선형 접근법\n\n\n<div class=\"content-ad\"></div>\n\n이번에는 필요한 위도선 수를 정의하되, 점의 수도 위치한 위도선의 둘레에 기반하여 조절됩니다. 간격에 대한 더 큰 제어를 위해 점 밀도 매개변수도 정의할 것입니다.\n\n여기서 까다로운 부분은 각 위도선의 반지름을 계산하는 것입니다. 일단 그것을 구했다면, 얼마나 많은 점을 표시해야 하는지 간단히 알아내고, 각각에 대해 첫 번째 방법과 유사한 방식으로 파이와 세타를 찾는 것도 상대적으로 간단합니다.\n\n```js\n// 위도 선을 가로지르는 루프\n  for (let lat = 0; lat < LATITUDE_COUNT; lat += 1) {\n    // 위도선의 반지름 계산\n    const radius =\n      Math.cos((-90 + (180 / LATITUDE_COUNT) * lat) * (Math.PI / 180)) *\n      SPHERE_RADIUS;\n    // 위도선의 둘레 계산\n    const latitudeCircumference = radius * Math.PI * 2 * 2;\n    // 해당 위도선에 필요한 점의 수 계산\n    const latitudeDotCount = Math.ceil(latitudeCircumference * DOT_DENSITY);\n\n    // 해당 위도선의 점 수에 대해 루프 수행\n    for (let dot = 0; dot < latitudeDotCount; dot += 1) {\n      const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n      // 점을 위한 파이와 세타 각도 계산\n      const phi = (Math.PI / LATITUDE_COUNT) * lat;\n      const theta = ((2 * Math.PI) / latitudeDotCount) * dot;\n\n      ...\n\n    }\n  }\n```\n\n이로써 매우 만족스러운 점 배치가 됩니다:\n\n<div class=\"content-ad\"></div>\n\n저희는 구체에 점들이 표시되는 방법에 대해 다루었습니다. 그렇다면 더 복잡한 효과를 얻을 수는 없을까요?\n\n# 모양 마스킹\n\n더 복잡한 패턴으로 점을 표시하는 방법을 알아내려면 수학적인 두통으로 빠르게 빠질 수 있습니다. 그러나 위의 포장 배치 중 하나와 마스크 이미지를 결합하여 일부 특별한 효과를 얻을 수 있습니다.\n\n이를 위해 먼저 HTML 캔버스 요소를 만들고 마스크 이미지를 그려야 합니다. 이 요소는 실제로 화면에 렌더링되지 않습니다. 이미지에서 픽셀 데이터를 추출하는 편리한 방법 뿐입니다. 이 일은 한 번만 해야하므로 미리 수행한 다음 추출된 이미지 데이터를 renderScene 함수로 전달하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이미지 로더를 초기화합니다.\nconst imageLoader = new THREE.ImageLoader();\n\n// 점이 표시되는 위치를 결정하는 이미지를 로드합니다. 이 작업이 완료되기 전에 구 cannot be initialised until this is complete.\nimageLoader.load(MASK_IMAGE, (image) => {\n    // HTML 캔버스를 생성하고 해당 캔버스의 컨텍스트를 가져와 이미지를 그립니다.\n    const tempCanvas = document.createElement(\"canvas\");\n\n    tempCanvas.width = image.width;\n    tempCanvas.height = image.height;\n\n    const ctx = tempCanvas.getContext(\"2d\");\n\n    ctx.drawImage(image, 0, 0);\n\n    // 캔버스 컨텍스트에서 이미지 데이터를 읽어옵니다.\n    const imageData = ctx.getImageData(0, 0, image.width, image.height);\n\n    renderScene(imageData);\n});\n```\n\n이제 이미지 데이터를 사용할 수 있으므로 몇 가지 유틸리티 함수를 추가해야 합니다. 첫 번째 함수는 구의 한 점을 가져와 해당 점이 구에 매핑된 경우 mask 이미지에서의 UV 좌표를 반환합니다.\n\n```js\n// 구의 한 점을 가져와 해당 점이 사각 텍스처 또는 이미지에서 UV 포인트로 변환하는 유틸리티 함수입니다.\nconst spherePointToUV = (dotCenter, sphereCenter) => {\n    // 구의 중심에서 점의 중심 방향을 나타내는 새로운 벡터를 만듭니다.\n    const newVector = new THREE.Vector3();\n    newVector.subVectors(sphereCenter, dotCenter).normalize();\n\n    // 점의 UV 좌표를 계산해서 벡터로 반환합니다.\n    const uvX = 1 - (0.5 + Math.atan2(newVector.z, newVector.x) / (2 * Math.PI));\n    const uvY = 0.5 + Math.asin(newVector.y) / Math.PI;\n\n    return new THREE.Vector2(uvX, uvY);\n};\n```\n\n두 번째 함수는 주어진 UV 좌표에서 mask 이미지의 픽셀 데이터를 반환합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이미지에서 특정 지점의 데이터를 샘플링하는 유틸리티 함수입니다. imageData 객체가 필요합니다.\nconst sampleImage = (imageData, uv) => {\n  // UV 좌표를 기반으로 점의 데이터를 계산하고 반환합니다.\n  const point =\n    4 * Math.floor(uv.x * imageData.width) +\n    Math.floor(uv.y * imageData.height) * (4 * imageData.width);\n\n  return imageData.data.slice(point, point + 4);\n};\n```\n\n이제 마스킹 효과를 적용하는 데 필요한 모든 것을 갖추었습니다. 각 점의 위치를 계산한 후에 해당 점의 경계 구를 계산합니다. 이후에 이를 사용하여 dot의 중심점을 spherePointToUV 함수에 전달할 수 있습니다. 이후에는 sampleImage 함수를 사용하여 해당 지점의 특정 픽셀 데이터를 찾을 수 있습니다. 픽셀이 투명하지 않으면 도트를 포함하고, 투명하면 도트를 제외합니다.\n\n```js\n// 도트 geometry를 위치로 이동합니다.\ndotGeometry.translate(vector.x, vector.y, vector.z);\n\n// 도트의 경계 구를 찾습니다.\ndotGeometry.computeBoundingSphere();\n\n// 랜드 이미지에서 도트의 UV 위치를 찾습니다.\nconst uv = spherePointToUV(\n  dotGeometry.boundingSphere.center,\n  new THREE.Vector3()\n);\n\n// 주어진 UV 위치에서 랜드 이미지의 픽셀을 샘플링합니다.\nconst sampledPixel = sampleImage(imageData, uv);\n\n// 픽셀에 색상 값이 포함되어 있으면 (다시 말해, 투명하지 않으면),\n// 도트를 생성합니다. 그렇지 않으면 건너뜁니다.\nif (sampledPixel[3]) {\n  // 위치 지정 geometry를 배열에 추가합니다.\n  dotGeometries.push(dotGeometry);\n}\n```\n\n실제로는 투명 배경을 가진 png 이미지를 마스크로 지정할 수 있습니다. 도트는 이미지의 해당 점이 투명하지 않은 경우에만 구로 렌더링됩니다. 간단한 다이아몬드 패턴을 가진 이미지로부터 이 멋진 결과를 얻을 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n더 복잡한 마스크 이미지를 사용하여 이 지구 효과와 같은 모양을 얻을 수 있어요:\n\n또한 텍스트를 렌더링할 수도 있어요:\n\n# 여기까지!\n\n이러한 구 형상 기법들을 WebGL 쇼피스의 기초로 여러 곳에서 사용했어요. 이를 통해 여러분도 같은 작업을 해볼 수 있기를 바랄게요. 만약 이 기사를 즐겨보았거나 어떤 면에서 도움이 되었다면 꼭 알려주세요! 제 웹사이트는 여기 있어요.","ogImage":{"url":"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png"},"coverImage":"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png","tag":["Tech"],"readingTime":9},{"title":"JavaScript로 배열 흉내내기 Objectassign, arr 방법","description":"","date":"2024-06-22 12:53","slug":"2024-06-22-JavaScriptFakesArraysObjectassignarr","content":"\n\n## 자바스크립트에서 배열은 사실 객체임을 비밀로 만들 필요가 없습니다. 그런데 이를 무시하는 대신, 배열에 객체 메소드를 적용해보면 어떨까요?..\n\n![이미지](/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png)\n\n## 1. Object.assign()\n\n자바스크립트는 배열을 객체로 변환하는 데 전혀 문제가 없다고 인식합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst arr = [1, 2, 3];\nconst newObj = Object.assign({}, arr);\nconsole.log(newObj); // 출력: {0: 1, 1: 2, 2: 3}\n```\n\n하지만 재미있는 점은 인수를 바꾸고 일부 비어 있지 않은 객체를 사용하는 경우 발생합니다:\n\n```js\nconst arr = [1, 2, 3];\nconst newObj = Object.assign(arr, {a: 4, b: 5});\nconsole.log(newObj); // 출력: (3) [1, 2, 3, a: 4, b: 5]\n```\n\n이제 \"무언가\"를 찾을 수 없는 전형적인 이름을 가진: 반 배열 — 반 객체입니다. 이것이 어떻게 동작하는지는 심지어 더더욱 우스꽝스럽습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst arr = [1, 2, 3];\nconst newObj = Object.assign(arr, {a: 4, b: 5});\nconsole.log(newObj); // Output: [1, 2, 3, a: 4, b: 5]\nconsole.log(arr.a); // Output: 4\nconsole.log(arr.length); // Output: 3\nconsole.log(JSON.stringify(arr)); // Output: [1,2,3]\n```\n\n자바스크립트는 괴상한 짓을 할 때 양심에 찔리는 듯한 척합니다. 한쪽에서는 배열에 문제가 없는 것처럼 꾸미지만, “이상한” 것들에 명시적으로 접근하면 추악한 진실을 드러내야 할 뿐입니다.\n\n## 2. Object.freeze()\n\nObject.freeze()는 객체에 새로운 속성이 추가되거나 기존 속성이 제거 또는 수정되지 못하도록 합니다. 배열과 함께 완벽하게 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst arr = [1, 2, 3];\nObject.freeze(arr);\narr[0] = 10; // 영향이 없음\nconsole.log(arr); // 출력: [1, 2, 3]\narr.push(4); // TypeError: Cannot add property 3, object is not extensible\n```\n\n여기서는 \"object is not extensible\"라고 속이지 않고 그냥 객체라고 합니다.\n\n## 3. Object.seal() 사용하기\n\nObject.seal()은 객체에 새로운 속성을 추가하지 못하게 하지만 기존 속성의 수정은 허용합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst arr = [1, 2, 3];\nObject.seal(arr);\narr[0] = 10; // 작동합니다\nconsole.log(arr); // 출력: [10, 2, 3]\narr.push(4); // TypeError: 프로퍼티를 추가할 수 없습니다\n```\n\n이 도구는 정의된 크기로 배열을 생성할 수 있게 해줄 수 있었지만, 제대로 작동했더라면 유용한 도구가 될 수도 있었습니다. 왜냐하면:\n\n```js\nconst arr = []\narr.length = 10\nconsole.log(arr) // 출력: [empty × 10]\nObject.seal(arr)\narr[0] = 1 // 여기에 오류가 없습니다\nconsole.log(arr) // 안타깝게도, 다시 출력은: [empty × 10]\n```\n\n## 4. Object.getOwnPropertyDescriptors() 사용하기\n\n<div class=\"content-ad\"></div>\n\n`Object.getOwnPropertyDescriptors()`은 객체의 모든 소유 속성 설명자를 반환합니다. 배열에서 사용할 때는 배열 색인에 대한 설명자도 포함됩니다.\n\n```js\nconst arr = [1, 2, 3];\nconst descriptors = Object.getOwnPropertyDescriptors(arr);\nconsole.log(descriptors);\n/* 결과:\n{\n  \"0\": { value: 1, writable: true, enumerable: true, configurable: true },\n  \"1\": { value: 2, writable: true, enumerable: true, configurable: true },\n  \"2\": { value: 3, writable: true, enumerable: true, configurable: true },\n  \"length\": { value: 3, writable: true, enumerable: false, configurable: false }\n}\n*/\n```\n\nJS 배열의 진정한 성격을 보여주는 쇼케이스입니다.\n\n## 5. `Object.getPrototypeOf()` 사용하기\n\n<div class=\"content-ad\"></div>\n\nObject.getPrototypeOf()은 지정된 객체의 프로토타입을 반환합니다. 배열에 사용하면 Array.prototype을 반환합니다:\n\n```js\nconst arr = [1, 2, 3];\nconst proto = Object.getPrototypeOf(arr);\nconsole.log(proto === Array.prototype); // 출력: true\n```\n\n그것은 배열을 식별하는 방법으로 정말 유용합니다. 왜냐하면:\n\n```js\nconst arr = []\ntypeof arr // 출력 'object'\n```\n\n<div class=\"content-ad\"></div>\n\n## 6. Object.defineProperty() 사용하기\n\nObject.defineProperty()은 객체에 새로운 속성을 정의하거나 기존 속성을 수정하고 해당 객체를 반환합니다. 배열에 사용될 때, 새로운 속성을 정의하거나 기존 속성을 수정할 수 있습니다.\n\n```js\nconst arr = [1, 2, 3];\nObject.defineProperty(arr, '0', {\n  value: 10,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\nconsole.log(arr[0]); // 결과: 10\narr[0] = 20; // 쓰기가 불가능하기 때문에 영향을 주지 않음\nconsole.log(arr[0]); // 결과: 10\n```\n\n어째서 이렇게 할까요? 저는 상당히 작은 이유로 동료들을 놀리기 위해서 한다는 것 밖에 상상이 안됩니다. 또 다른 아이디어가 있나요?\n\n<div class=\"content-ad\"></div>\n\n## 7. Object.setPrototypeOf() 사용\n\nObject.setPrototypeOf()은 지정된 객체의 프로토타입을 설정합니다. 배열에 사용하면 프로토타입을 다른 객체로 변경할 수 있습니다.\n\n```js\nconst arr = [1, 2, 3];\nObject.setPrototypeOf(arr, Object.prototype);\nconsole.log(arr); // 출력: [1, 2, 3]\nconsole.log(arr.push); // 출력: undefined\nconsole.log(arr.shift); // 출력: undefined\nconsole.log(arr.pop); // 출력: undefined\n// .map(), .filter(), .forEach() 등도 동일\nconsole.log(arr.toString()); // 출력: '[object Array]'\narr[3] = 4\nconsole.log(arr); // 출력: [1, 2, 3, 4]\nconst newArr = [5,6]\nconsole.log([...arr, ...newArr]) // TypeError: arr은 반복 가능하지 않음\n```\n\n반 배열에서 반 죽은 노파를 만드는 재미있는 방법이에요. \"arr[3] = 4\"와 같이 새 요소를 추가하거나 \"delete arr[2]\"를 호출하여 요소를 삭제할 수 있지만, 거의 모든 다른 것들이 동작하지 않아요.\n\n<div class=\"content-ad\"></div>\n\n## 8. delete 연산자 사용하기\n\n이전 포인트의 아이디어를 백 퍼센트 따르지는 않지만, 자바스크립트에서 값의 \"존재하지 않음\"을 나타내는 null, undefined와의 연결을 드러내어 매우 흥미로운 부분입니다.\n다음 예제를 살펴보세요:\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // 출력: [1, empty, 3]\n```\n\n특정 크기의 객체를 봉인하려고 시도할 때 \"empty\"가 표시되었습니다. 하지만 이것이 무엇인가요? \"empty\"라는 값 또는 유형은 없기 때문에 표시된 것은 실제 데이터가 아니며, 그저 \"희소 배열\"을 나타내는 방법일 뿐입니다. 누락된 인덱스가 있는 배열에 대한 일반적인 용어입니다. 하지만 이 값을 액세스하려고 해보죠:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr[1]); // Output: undefined\n```\n\n이것이 우리에게 알려주는 바는 Javascript가 존재하지 않는 것에 접근하려고 할 때 \"undefined\"로 대체한다는 것입니다. 이것은 실제로 공백으로 변환되기보다 \"undefined\"를 배열에 명시적으로 넣어두면 \"empty\"로 다시 변환되지 않는다는 트릭입니다:\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // Output: [1, empty, 3]\nconsole.log(arr[1]); // Output: undefined\narr[1] = undefined\nconsole.log(arr); // Output: [1, undefined, 3]\n```\n\n이게 다가 아닙니다. JS 데이터를 표현하는 또 다른 내장 방법인 JSON이 있습니다. JSON이 우리에게 어떤 것을 제공할 수 있는지 살펴봅시다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // 결과: [1, 빈 칸, 3]\nconsole.log(JSON.stringify(arr)); // 결과: [1, null, 3]\nconsole.log(JSON.parse(JSON.stringify(arr))); // 결과: [1, null, 3]\n```\n\nJSON.stringify()은 그냥 \"undefined\"를 \"null\"로 변환하기 때문에 JSON에는 undefined가 없다. 자바스크립트에도 \"null\"이 있기 때문에 다시 파싱할 때 \"null\"로 유지되는 것이 예상된다... 정말 이상한 일이다:\n한 가지 방향은 empty -` undefined -` null이다.\n돌아오는 방향은 null -` null -` null이다.\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // 결과: [1, 빈 칸, 3]\nconsole.log(arr[1]); // 결과: undefined\nconst jsonArr = JSON.stringify(arr);\nconsole.log(jsonArr); // 결과: [1, null, 3]\nconst parsedArr = JSON.parse(jsonArr);\nconsole.log(parsedArr) // 결과: [1, null, 3]\nconsole.log(parsedArr[1]) // 결과: null\n```\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n자바스크립트에서 배열의 동작은 밑바닥 복잡성을 보여줍니다. 이는 종종 짜증을 유발할 수 있습니다. JavaScript 배열은 기술적으로 객체이지만, 고유한 특성과 표준 객체 메서드와의 상호작용으로 인해 예상치 못한 결과를 초래할 수 있습니다. 이러한 특이점을 이해하는 것은 개발자에게 잠재적인 문제를 피하는 데 중요할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png"},"coverImage":"/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png","tag":["Tech"],"readingTime":7},{"title":"정규 표현식에서 여러 조건을 일치시키는 방법","description":"","date":"2024-06-22 12:52","slug":"2024-06-22-HowToMatchMultipleConditionsinRegex","content":"\n\n<img src=\"/assets/img/2024-06-22-HowToMatchMultipleConditionsinRegex_0.png\" />\n\n이전 포스트에서는 미디엄 게시물에서 YouTube 링크를 썸네일로 표시하는 방법에 대해 설명했습니다. 이를 위해서는 제공된 URL에서 특정 패턴을 일치시키고 바꾸기 위해 일부 정규 표현식을 활용해야 합니다.\n\n포스트에는 두 가지 다른 조건을 고려해야 하는 보너스 섹션이 포함되어 있습니다. 두 가지 경우를 처리하기 위해 각각 별도의 문을 사용할 수 있습니다. 또는 여러 조건을 하나의 정규 표현식 문으로 통합하여 깔끔하고 효율적으로 할 수도 있습니다.\n\n이 포스트에서는 이에 대해 조금 더 깊이 이해해 보겠습니다! 아래는 문자열에서 정규 표현식 조건에 일치하는 부분을 찾을 수 있도록 match와 함께 사용할 수 있는 간단한 정규 표현식입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst line = '내 이름은 매튜 크로크입니다. 나는 NY 메츠를 좋아합니다.';\nconst regex = /[A-Za-z]/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n\n> (33) ['M', 'y', 'n', 'a', 'm', 'e', 'i', 's', 'M', 'a', 't', 't', 'h', 'e', 'w', 'C', 'r', 'o', 'a', 'k', 'I', 'l', 'o', 'v', 'e', 't', 'h', 'e', 'N', 'Y', 'M', 'e', 't', 's']\n```\n\n<div class=\"content-ad\"></div>\n\n좋아요! 만약 우리가 전체 단어와 일치시키고 싶다면 어떨까요? 예를 들어, 'love'란 단어를 찾고 싶으면 이렇게 할 수 있어요!\n\n```js\nconst line = '내 이름은 매튜 크로크입니다. 나는 뉴욕 메츠를 사랑해요.';\nconst regex = /love/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n\n> ['love']\n```\n\n쉽죠? 만약 우리가 대괄호 안에 love를 넣어서 /[love]/g와 같이 하면 아래와 같은 결과가 나올 거에요.\n\n```js\n> (9) ['e', 'e', 'o', 'l', 'o', 'v', 'e', 'e', 'e']\n```\n\n<div class=\"content-ad\"></div>\n\n이는 대괄호가 \"문자 클래스\"로 사용되기 때문입니다. 즉, \"a, b 또는 c 중의 어떤 문자\"를 의미합니다. 문자 클래스는 범위를 사용할 수도 있습니다. 예를 들어 [a-d] = [abcd]입니다. [여기](https://stackoverflow.com/questions/3512471/what-does-it-mean-to-escape-the-regex-square-brackets)에서 원본 스택 오버플로 설명을 볼 수 있습니다.\n\n## 다중 조건\n\n이 게시물의 원래 목적으로 돌아가 보겠습니다: 정규식에서 여러 조건을 사용하는 방법은 무엇인가요?\n\n예를 들어 우리가 love와 Mets 단어를 찾고 싶다고 할 때, 파이프 (|)를 사용하여 아래와 같은 정규식을 작성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst line = '내 이름은 매튜 크로크입니다. 나는 NY 메츠를 좋아합니다.';\nconst regex = /좋아합니다|메츠/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n\n> ['좋아합니다', '메츠']\n```\n\n파이프는 논리 OR 표현을 나타냅니다. 하나의 패턴이나 다른 패턴 중 하나를 찾고 싶을 때 사용할 수 있습니다. 만약 love와 Mets 간에 공백을 넣었다면 또는 아예 아무것도 넣지 않았다면, 정규식에서 아무런 결과도 얻을 수 없을 것입니다.\n\n이는 이제 match 패턴이 loveMets 또는 love Mets라는 둘 중 하나가 되었기 때문입니다. 이들은 문자열에 나타나지 않는 패턴들입니다. OR 로직을 실행하려면 파이프가 필요합니다.\n\n이 OR 연산자는 두 개뿐만 아니라 다양한 조건과 함께 사용할 수 있습니다! 한 번 살펴보세요. 매튜, 좋아합니다, 메츠를 찾아 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst line = '내 이름은 Matthew Croak이다. 나는 NY Mets를 사랑해.';\nconst regex = /love|Mets|Matthew/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n\n> ['Matthew', 'love', 'Mets']\n```\n\n패턴을 포함하는 순서가 중요하지 않은 것을 주목하셨나요? 여전히 일치 항목을 찾아 문자열에 나타난 순서대로 기록할 거에요.\n\n조금 더 복잡한 것을 시도해보죠.\n\n## 다중 조건 (특수 문자 사용)\n\n<div class=\"content-ad\"></div>\n\n위의 코드를 Markdown 형식으로 변경하면 아래와 같아요.\n\n```js\nconst line = \"내 이름은 Matthew Croak :). 나는 NY 메츠를 좋아해요 (양키스는 그렇게 좋아하지는 않지만, 괜찮아요.)\";\n\n// 이모티콘을 모두 찾고 싶다면 아래 내용을 콘솔에서 실행해보세요.\n\nconst line = \"내 이름은 Matthew Croak :). 나는 NY 메츠를 좋아해요 (양키스는 그렇게 좋아하지는 않지만, 괜찮아요).\";\nconst regex = /<3|:)/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n```\n\n<div class=\"content-ad\"></div>\n\n무슨 일이 있었나요? 로그를 찍을 때 이렇게 나왔나요...\n\nUncaught SyntaxError: Invalid regular expression: /`3|:)/: Unmatched ‘)’\n\n왜 이런 일이 발생했을까요? 그것은 단순히 )가 정규식에서 특수 문자로 사용되기 때문이에요! 그것은 그룹화에 사용돼요. 문자열에서 )를 찾으려면 백슬래시로 이스케이핑 해야 해요.\n\n아래 사항을 확인해 보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst regex = /<3|:\\)/g;\n```\n\n코드를 업데이트하면 아래와 같은 응답이 나와야 합니다.\n\n```js\n> (2) [':)', '<3']\n```\n\n여기 있습니다! 여러 개의 정규 표현식을 논리 OR 연산자를 사용하여 하나로 결합하는 방법과 문자열에서 특수하거나 예약된 문자를 찾을 수 있도록 이스케이프하는 방법까지 배웠습니다!\n\n<div class=\"content-ad\"></div>\n\n다른 방법으로 정규식에서 여러 조건을 사용하는 방법이 있나요? 댓글로 알려주세요! \n\n나의 정리된 정규식 목록을 확인하려면 더 많은 자료를 보십시오!\n\n무제한 광고 없는 이야기를 수천 명의 작가로부터 받으며 무료 Medium 멤버십을 업그레이드하세요. 이것은 제가 작성한 콘텐츠에 대한 보상을 받게 해주는 제 계정과 연계된 링크입니다.\n\n또한 이메일로 구독하여 새로운 글이 올라올 때마다 알림을 받을 수도 있습니다!\n\n<div class=\"content-ad\"></div>\n\n# 참고문헌","ogImage":{"url":"/assets/img/2024-06-22-HowToMatchMultipleConditionsinRegex_0.png"},"coverImage":"/assets/img/2024-06-22-HowToMatchMultipleConditionsinRegex_0.png","tag":["Tech"],"readingTime":4},{"title":"사용자 맞춤 AI Meta의 Llama 3와 Nodejs로 프라이버시 중심 LLM 배포 방법","description":"","date":"2024-06-22 06:09","slug":"2024-06-22-AIonYourTermsPrivacy-FocusedLLMDeploymentwithMetasLlama3andNodejs","content":"\n\n\"우리는 이 새로운 기술들의 힘을 활용해야 해,\" CEO가 단호하게 선언했다. \"하지만 우리는 고객 데이터 보안을 저해할 여유가 없어.\"","ogImage":{"url":"/assets/img/2024-06-22-AIonYourTermsPrivacy-FocusedLLMDeploymentwithMetasLlama3andNodejs_0.png"},"coverImage":"/assets/img/2024-06-22-AIonYourTermsPrivacy-FocusedLLMDeploymentwithMetasLlama3andNodejs_0.png","tag":["Tech"],"readingTime":1},{"title":"실생활 비유로 이해하는 JavaScript call, apply, bind 메서드 사용 방법","description":"","date":"2024-06-22 06:09","slug":"2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies","content":"\n\n\n![image](/assets/img/2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies_0.png)\n\n자바스크립트는 함수가 작동하는 문맥(this)을 제어하기 위해 call, apply, bind 세 가지 강력한 메서드를 제공합니다. 이러한 메서드를 이해하면 유연하고 재사용 가능한 코드를 작성할 수 있는 능력이 크게 향상됩니다. 각 메서드를 간단한 설명과 현실적인 비유와 함께 살펴보겠습니다.\n\n# call\n\ncall은 한 객체로부터 메서드를 빌려와 다른 객체에 즉시 사용할 수 있도록 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n안녕하세요!\n\n아래 예시를 보시면 함수 호출 시 사용되는 `table` 태그를 Markdown 형식으로 변경하였습니다.\n\n예시:\n\nAlice가 인사하는 메소드를 가지고 있다고 상상해봅시다:\n\n```js\nconst alice = {\n    name: 'Alice',\n    sayHello: function(greeting) {\n        console.log(greeting + ', ' + this.name);\n    }\n};\n\nalice.sayHello('Hi');  // 결과: \"Hi, Alice\"\n```\n\n<div class=\"content-ad\"></div>\n\n밥이 인사를 하고 싶지만 sayHello 메서드가 없어요. call을 사용하면 앨리스의 메서드를 빌려와서 즉시 사용할 수 있어요:\n\n```js\nconst bob = { name: 'Bob' };\n\nalice.sayHello.call(bob, 'Hello');  // 출력: \"Hello, Bob\"\n```\n\n유사성: call은 앨리스의 메서드 책을 빌려와서 바로 사용하여 밥이 누군가에게 인사할 수 있게 도와주는 것처럼 생각해 보세요.\n\n# apply\n\n<div class=\"content-ad\"></div>\n\napply는 call과 비슷하지만, 인수를 배열로 전달할 수 있습니다.\n\n```js\nfunction.apply(thisArg, [argsArray])\n```\n\n예시:\n\n같은 인사 방법을 사용하면, 만약 인사말이 배열에 저장되어 있다면 apply를 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst args = ['안녕'];\n\nalice.sayHello.apply(bob, args);  // 출력: \"안녕, Bob\"\n```\n\n비유: apply는 앨리스의 메서드 책을 빌리는 것처럼 즉시 사용하는 것이지만 개별 지시사항을 주는 대신에 지시사항 목록을 전달합니다.\n\n# bind\n\nbind는 제공된 값으로 this 값을 설정하고 주어진 인수 시퀀스로 호출될 때 새 함수를 생성합니다. call 및 apply와 달리 bind는 함수를 즉시 실행하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction.bind(thisArg, arg1, arg2, ...)\n```\n\n예시:\n\n만약 나중에 Bob에게 인사를 준비하고 싶다면, bind를 사용하여 그렇게 할 수 있어요.\n\n```js\nconst greetBobLater = alice.sayHello.bind(bob, '좋은 아침');\n\ngreetBobLater();  // 출력: \"좋은 아침, Bob\"\n```\n\n<div class=\"content-ad\"></div>\n\n비유: bind는 밥을 위해 알람 시계를 설정하는 것과 같습니다. 인사말을 미리 설정하고, 시간이 되면 밥이 사용할 수 있습니다.\n\n# 주요 차이점\n\n— 호출 시기:\n\n- call과 apply는 함수를 즉시 호출합니다.\n- bind는 나중에 호출할 수 있는 새로운 함수를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n— 인수 처리:\n\n- call은 개별적인 인수를 사용합니다.\n- apply는 배열로 인수를 사용합니다.\n- bind는 새 함수를 호출할 때 제공할 수 있는 새 함수를 위한 미리 설정된 인수를 사용할 수 있습니다.\n\n## 사용 사례\n\n- call: 함수를 즉시 호출하고 this 컨텍스트를 제어하고 개별적으로 인수를 전달하고 싶을 때 사용합니다. 예: 하나의 객체에서 메서드를 빌려와서 다른 객체에서 즉시 사용할 때.\n- apply: 함수를 즉시 호출하고 배열에 있는 인수를 사용해야 할 때 사용합니다. 예: 배열에 저장된 매개변수 목록을 사용하는 방법.\n- bind: 특정한 this 컨텍스트와 선택적으로 미리 설정된 인수를 사용하여 나중에 호출할 수 있는 함수를 만들어야 할 때 사용합니다. 예: 이벤트 핸들러나 콜백을 위해 메서드를 미리 설정하는 경우.\n\n<div class=\"content-ad\"></div>\n\n# 간단한 비유를 통한 요약:\n\n- call: \"앨리스야, 밥이 지금 `sayHello` 메서드를 빌려와서 사용해도 될까?\" (즉시 사용)\n- apply: call과 동일하지만 목록 형태의 지시사항 제공: \"여기, 밥, 여기 있는 목록 [`안녕`]을 사용해서 인사해봐.\"\n- bind: \"앨리스, 밥이 `좋은 아침`이라는 것으로 나준비를 해놓을 수 있을까?\" (나중 사용을 위한 준비)\n\n# 결론\n\nJavaScript에서 call, apply 및 bind를 이해하면 함수 실행과 this 바인딩에 대한 더 큰 제어력을 가질 수 있습니다. 이러한 방법은 객체 지향 및 함수형 프로그래밍 패턴에서 특히 유용하며 코드의 유연성과 재사용성을 향상시킵니다. 간단한 비유를 사용하여, call과 apply는 즉시 메서드를 빌려와서 사용하는 것과 유사하며, bind는 미래 사용을 위해 메서드를 준비하는 것과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n초보자든 숙련된 개발자든, 이러한 방법을 숙달하는 것은 더 견고하고 유지보수가 쉬운 JavaScript 코드를 작성하는 데 도움이 될 것입니다. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies_0.png","tag":["Tech"],"readingTime":3},{"title":"JS 정규표현식 성능 문제 해결 방법","description":"","date":"2024-06-22 06:08","slug":"2024-06-22-JSRegexpPerformanceIssue","content":"\n\n## 자주, 우리는 잠재적인 성능 문제를 인식하지 못하고 간단한 문자열 검색을 위해 정규식 표현을 사용합니다.\n\n![이미지](/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png)\n\n입력 또는 문자열 유효성 검사의 성능 문제의 일반적인 이유 중 하나는 정규식 검사의 복잡성입니다.\n\n크롬 기반 브라우저 (예: Chrome, Edge, Opera 등)에는 정규식 엔진과 관련된 알려진 문제가 있습니다. Firefox도 마찬가지 문제를 가지고 있습니다. 왜냐하면 SpiderMonkey 엔진이 Chrome의 정규식에 동일한 엔진을 사용하기 때문입니다. 문제는 엔진이 정규식을 테스트하는 방법 (백트래킹 알고리즘)에서 나옵니다. 엔진이 적합한 패턴을 찾을 수 없을 때 검색을 완료하는 데 필요한 시간복잡도가 기하급수적으로 높아지기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n이 문제를 확인하려면 새 탭을 열고 about:blank로 이동하십시오. 콘솔에서 다음 코드 조각을 실행하십시오. URL에 사용된 ID의 길이에 따라 정규 표현식 검색을 완료하는 데 걸리는 시간이 다를 수 있습니다.\n\n만약 숫자와 단어 \"ID\"가 연달아 나오는 형식의 ID가 있는지 확인하고 싶다면 아래의 코드를 실행해보세요:\n\n```js\nconst url1 = \"www.somesite1.com/18329719832791721285462id/user\"\nconst url2 = \"www.somesite2.com/18329719832791721285462/user\"\n\nlet start = performance.now();\n/(\\d*)*(id)/.exec(url1);\nconsole.log(performance.now() - start)\n\nstart = performance.now();\n/(\\d*)*(id)/.exec(url2);\nconsole.log(performance.now() - start)\n```\n\n위 코드의 성능평가:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-JSRegexpPerformanceIssue_1.png)\n\n만약 우리가 숫자로 구성된 ID 뒤에 \"id\"라는 단어가 오는 존재를 확인하려고 한다고 가정해봅시다. 우리의 정규 표현식에서는 (\\d*) 표현식이 반복되는 숫자 시퀀스를 찾습니다. 하나의 추가와일드카드로 감싸면 엔진은 시퀀스의 시퀀스를 찾습니다. 와일드카드 하나를 제거하면 여전히 동일한 결과를 얻으면서 검색에 필요한 시간을 크게 줄일 수 있습니다.\n\n(백트래킹 알고리즘의 문제에 대해 더 자세히 설명된 것은 여기에서 확인할 수 있습니다)\n\n결론:\n\n\n<div class=\"content-ad\"></div>\n\n- regexp는 필요한 경우에만 사용하고 기본 선택지로 사용하지 마세요. includes() 및 split() 메소드를 사용하여 동일한 결과를 얻을 수 있습니다.\n- 때로는 성능 문제를 일으키지 않는 새로운 regexp 패턴을 수정하거나 만들 수 있습니다.\n- 각 추가된 문자로 성능 문제가 크게 증가하거나 문자열 검색이 있는 경우 해당 함수가 regexp를 사용한 것일 수 있음을 나타낼 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png"},"coverImage":"/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png","tag":["Tech"],"readingTime":2},{"title":"내 인생을 구한 6가지 Pandas 테크닉","description":"","date":"2024-06-22 06:04","slug":"2024-06-22-6PandasTechniquesthatSavedMyLife","content":"\n\n\n![img](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_0.png)\n\n만약 귀하가 직장이나 사이드 프로젝트에서 데이터 작업을 한다면, 실제로 대부분의 시간을 데이터를 정리, 조작 및 변환하는 데 쓸 것입니다. 사실 데이터 과학자들 사이에서 80%의 시간이 데이터를 다루는 데 소요된다는 것은 인기 있는 트로프입니다.\n\n이 현실을 감안하면, 데이터 조작을 위한 필수적인 Python 라이브러리인 판다스를 이미 사용해 보셨을 것입니다. 저는 판다스를 광범위하게 사용하여 즉석 분석부터 제품 수준의 데이터 파이프라인 구축에 이르기까지 모든 일에 활용했습니다. 제 경험을 통해, 제 워크플로우를 크게 단순화하고 코드 품질을 향상시킨 6가지 주요 기술을 수집했습니다.\n\n이 글에서는 해당 기술들을 탐구하고, 상징적인 Titanic 데이터셋을 사용하여 효과적으로 적용하는 방법을 보여드릴 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 연쇄\n\n아래에 설명된 모든 기술의 중심에는 연쇄(Chaining)가 있습니다. 이는 데이터에 여러 작업을 한 번에 연속적으로 적용할 수 있는 방법으로, 개별적인 단계들이 아니라 하나의 순차적인 파이프라인처럼 보이는 효율적인 절차를 만들어냅니다. 이 스타일은 맷 해리슨(Matt Harrison)로 인해 pandas에서 인기를 얻었으며, 그는 파이썬 및 데이터 과학 교육자이자 Effective Pandas의 저자입니다(강력 추천).\n\n연쇄는 연산을 독립적으로 만들고 함수를 작고 간단하게 유지하는 기존 프로그래밍과는 다른 방식입니다. 대신, 연쇄는 데이터를 점진적으로 정리하거나 보강하는 연산들의 시리즈를 통해 데이터 중심적인 워크플로우를 더 현실적으로 나타냅니다. 이 접근 방식은 초심자에게는 워크플로우의 잠재적인 길이와 복잡성 때문에 위협적일 수 있습니다. 그러나 연쇄는 몇 가지 기본 원칙을 이해하고 워크플로우를 단계별로 쪼개면서 견고한 데이터 파이프라인을 만드는 간단하고 직관적인 방법이 됩니다.\n\n아래에서 데이터셋에 대해 일반적인 작업 세트를 수행하는 샘플 워크플로우를 생성했습니다. 첫 번째 스니펫에서 변수 재할당을 사용하고, 두 번째에서는 연쇄를 사용했습니다. 두 가지 중 어떤 것이 더 깔끔해 보이나요?\n\n<div class=\"content-ad\"></div>\n\n\n![링크1](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_1.png)\n\n![링크2](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_2.png)\n\n체인 방식으로 변수를 생성할 필요가 없다는 것을 주목하세요! 만약 주피터 노트북에서 이 파이프라인을 실행하고 있다면 셀을 직접 실행하여 결과를 확인할 수 있습니다. 프로덕션에서는 결과를 변수에 저장해야 하지만, 다른 네 개의 변수 인스턴스화를 제거하여 코드를 더 깨끗하고 유지보수하기 쉽게 만듭니다.\n\n체이닝 시 시각적 명확성을 유지하려면 각 인덴트가 파이프라인의 더 깊은 수준에 해당하도록 코드를 계층적으로 배치하세요. 이는 워크플로가 더 복잡해질수록 점점 더 중요해집니다. 또한, .assign 메소드에서 \"lambda\" 함수의 사용에 주목하세요. 처음에는 복잡해 보일 수 있지만, 이 람다는 간단히 앞서 언급된 DataFrame을 참조하는 것뿐입니다. 그룹화된 또는 필터된 데이터에 변환을 적용하거나 여러 의존하는 열을 생성할 때 특히 유용합니다.\n\n\n<div class=\"content-ad\"></div>\n\n이제 우리가 체이닝의 중요성과 이점을 이해했으니, 이 접근 방식을 활용하여 복잡한 작업을 쉽게 처리하는 몇 가지 기술을 살펴보겠습니다.\n\n## 중복 행 검사\n\nPandas의 내장 drop_duplicates 함수는 중복 행을 제거하는 데 유용하지만, 중복된 행 자체를 보여주지는 않습니다. 중복을 식별하려면 .duplicated 메서드를 사용하며, 이 메서드는 중복되는 행에 대한 boolean 시리즈를 반환합니다. 여기서 행이 이전 행의 중복인 경우 해당 행은 True가 됩니다. 그러나 이렇게 하면 종종 코드가 복잡해질 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n우리가 목적을 달성했지만, 접근 방식을 개선할 수 있어요. 먼저 바닐라 불리언 인덱싱을 .loc로 대체하여 동적 필터링 표현을 만들 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_4.png)\n\n그리고 완성! 변수 재할당 없이 중복된 행을 필터링했어요. 위에서 언급한 것처럼 .drop_duplicates를 사용하여 중복된 행을 삭제할 수 있지만, 동일한 표현을 사용하여 이전에 행 중복 필터에 ~ 연산자를 추가하여 필터링할 수도 있어요.\n\n![이미지](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_5.png)\n\n<div class=\"content-ad\"></div>\n\nThe ~ operator reverses the boolean conditions of the filter statement, so that only rows that were not duplicated would be returned. This is useful when you want to examine your data and quickly look at the duplicated and non-duplicated rows.\n\n## Value selection using .loc\n\nOne aspect of pandas I found challenging is accessing a specific value in a cell. While we often work with rows or columns in pandas, sometimes we need to retrieve individual values. The typical approach to doing this looks something like the following:\n\n![Value selection using .loc](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_6.png)\n\n<div class=\"content-ad\"></div>\n\n이 방법은 정말 좋지만, .iloc 속성은 조금 강제로 느껴질 수 있어요. 다행히 .loc 메소드를 사용하기 전에 조금의 준비를 해두면 값을 직접적으로 접근할 수 있어요. 중요한 것은 DataFrame의 색인을 필터링할 때 사용하는 열로 설정하는 것이에요. 이렇게 하면 .loc 문에서 이름을 첫 번째 액세서로 사용하고 원하는 열을 두 번째 액세서로 지정할 수 있어요.\n\n![2024-06-22-6PandasTechniquesthatSavedMyLife_7](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_7.png)\n\n다음 기술들은 모두 .pipe을 중심으로 돌아간답니다. 이는 판다스에서 가장 편리한 메소드 중 하나예요. 이를 사용하면 DataFrame이나 series에 미리 정의되거나 lambda를 통해 표현된 사용자 정의 함수를 연속해서 체인할 수 있어요. 하지만 주의해야 할 점은, pipe 함수를 통해 전달된 DataFrame의 결과는 항상 DataFrame이 되는 것은 아니라는 점이에요. 함수가 반환하는 방식에 따라, 추가적인 판다스 변환이 어려울 수도 있어요. 어떻게 작동하는지 살펴봅시다.\n\n## Pipe Ternary\n\n<div class=\"content-ad\"></div>\n\n판다는 데이터의 행, 열 및 테이블 지향 변환을 수행하는 데 탁월하지만, 조건부 작업을 지원하는 데는 한계가 있다는 게 엽기적이에요. 저는 해결책 중 하나로 .pipe 메소드 내부의 람다 함수에서 삼항 연산자를 사용하는 방법을 활용해왔어요. 가령, 타이타닉 데이터셋을 위한 파이프라인을 생성하는 경우를 생각해보죠. \"Cabin\"이라는 열이 있는 것을 보장할 수 없을 때도 있어요. 이럴 때, 아래와 같은 방법을 사용할 수 있어요:\n\n<img src=\"/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_8.png\" />\n\n이 방법은 동작하지만, 체인이 끊어진다는 문제점이 있어요! 일회성 작업으로는 수용할만한 방법이겠지만, 대규모 파이프라인에서 여러 번 이런 상황이 발생하면 가독성이 떨어질 수 있어요. 대신, 파이프 내부에 간단한 람다 함수를 정의하여 삼항 연산자를 수행할 수 있어요:\n\n<img src=\"/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_9.png\" />\n\n<div class=\"content-ad\"></div>\n\n.pipe을 사용하여 DataFrame의 열에서 “Cabin”이 이미 존재하는지를 확인하는 사용자 정의 삼항 함수를 생성합니다. 만약 존재한다면, 함수는 DataFrame을 바로 반환하고, 그렇지 않다면 열을 할당합니다. 이제 조금 더 화려한 것을 살펴보겠습니다...\n\n## 열의 일부에 변환 적용하기\n\n이 기술은 저의 일상 업무에서 가장 유용한 기법으로, 종종 비슷한 열들이 동일한 변환을 필요로 하는 다양한 데이터 유형으로 구성된 데이터 세트를 다룹니다. 예를 들어 타이타닉 데이터 세트를 살펴봅시다. 각 열에는 널 값이 있지만 “Age”와 “Sex” 열만 forward-fill 하려고 합니다. 이를 어떻게 할 수 있을까요? .assign 메서드와 람다 함수를 사용하여 원래 열을 덮어쓰는 방법 중 하나는 다음과 같습니다:\n\n![image](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_10.png)\n\n<div class=\"content-ad\"></div>\n\n하지만 만약 두 개의 열을 변환하는 대신에 열 개를 변환하고 싶다면 어떻게 해야 할까요? 동일한 변환을 반복해서 입력하는 것은 지루해지며, 변환을 변경해야 하는 경우 열 번 수정해야 합니다. 다행히 .pipe, lambda, 그리고 약간의 파이썬 언패킹 마법을 사용하여 더 나은 방법이 있습니다:\n\n![image](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_11.png)\n\n처음에는 혼란스러워 보일 수 있지만, 다른 연결된 흐름과 마찬가지로 한 단계씩 나누어 살펴봅시다. 먼저, .pipe 메서드의 람다 함수는 DataFrame을 새로운 흐름으로 전달합니다 (네, 흐름 내의 또 다른 흐름입니다). 이 흐름에서 우리는 원하는 열만 포함한 작은 DataFrame을 원본 DataFrame에서 언패킹합니다. 이 기술을 사용하면 작은 DataFrame에만 .ffill을 적용하여 원하는 열에만 집중한 다음, 이 열을 직접 원본 DataFrame에 다시 언패킹할 수 있습니다. 이 접근 방식은 구문적으로 더 명확할 뿐만 아니라 .ffill이 한 번만 호출되므로 성능 최적화도 제공합니다!\n\n다음으로, .pipe가 어떻게 사용되어 준비된 데이터를 시각화 라이브러리로 직접 전달하는 데 도움이 되는지 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## Plotly로 변환된 데이터를 바로 시각화하기\n\n나는 직관성과 시각적 매력 때문에 Plotly를 선호하지만, 이 전략은 Matplotlib, Seaborn 및 pandas DataFrame과 NumPy 시리즈와 직접 통합되는 기타 그래프 라이브러리와도 작동합니다. 보통은 데이터 조작을 먼저 수행한 다음 결과를 시각화하는 두 번째 기능을 생성합니다. 그러나 데이터 작업을 진행할 때 반복 속도가 중요합니다. 이상적으로는 시각화를 연쇄적 흐름에 직접 추가하여 분석 결과를 더 잘 검토할 수 있어야 합니다. .pipe 메서드를 사용하면 이를 할 수 있습니다. 예를 들어, 타이타닉의 티켓 가격 분포를 간단히 살펴보고 싶다면:\n\n![image](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_12.png)\n\n이 흐름에서는 람다 함수 대신에 원하는 함수를 .pipe 메서드의 첫 번째 인수로 직접 전달하고 있습니다. 그 후속 인수들은 px.histogram 함수와 관련이 있으며, 판다스가 이들을 추가 키워드 인수로 전달합니다. .pipe 메서드의 결과는 Plotly 차트이며, 이를 통해 연쇄에 직접 Plotly 메서드를 추가하여 파이프라인과 시각화를 효율적으로 통합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_13.png)\n\n여기 여러분을 위한 것입니다 — 더 나은 그리고 더 효율적인 판다 코드를 작성하는데 도움이 되는 여섯 가지 생명을 구하는 기술입니다. 각 예제에서, 전체 데이터셋으로 흐름을 시작했습니다. 이것은 의도적입니다. 분석할 때마다 데이터를 직접 소스에서 읽는 것이 일반적으로 더 좋기 때문입니다, 특히 노트북 환경에서. 이 방법을 통해 이전 데이터 변환으로 인해 파이프라인 결과가 변경되는 것을 방지하고, 노트북 출력이 새로 고쳐지거나 삭제되어도 파이프라인을 재현 가능하게 유지할 수 있습니다.\n\n위에서 언급한 코드 예제들을 실험해 보고 싶다면, 제 GitHub의 이 기사의 노트북 버전을 확인해보세요. 저에 대해 더 알고 싶거나, 제 프로젝트와 다른 작업에 대해 더 알고 싶다면, 제 웹사이트를 방문해주세요.","ogImage":{"url":"/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_0.png"},"coverImage":"/assets/img/2024-06-22-6PandasTechniquesthatSavedMyLife_0.png","tag":["Tech"],"readingTime":7},{"title":"MERN 스택 완벽 정복 최적의 프로젝트 아키텍처 가이드","description":"","date":"2024-06-22 05:57","slug":"2024-06-22-MasteringtheMERNStackAGuidetoPerfectProjectArchitecture","content":"\n\nMERN 스택은 MongoDB, Express, React 및 Node.js로 구성된 인기있는 웹 개발 프레임워크입니다. MongoDB는 유연한 JSON과 유사한 문서에 데이터를 저장하는 NoSQL 데이터베이스입니다. Express는 Node.js에서 웹 애플리케이션을 구축하기 위한 가벼운 프레임워크입니다. React는 동적 사용자 인터페이스를 구축하기 위한 강력한 프런트엔드 라이브러리이며, Node.js는 서버 측 코드를 실행할 수 있게 해주는 JavaScript 런타임입니다.\n\n![MERN Stack](/assets/img/2024-06-22-MasteringtheMERNStackAGuidetoPerfectProjectArchitecture_0.png)\n\n잘 구성된 프로젝트 구조는 코드 가독성, 확장성 및 협업의 용이성을 유지하는 데 중요합니다. 개발자가 빠르게 파일을 찾고 응용 프로그램 흐름을 이해할 수 있도록 도와줌으로써 디버깅에 소요되는 시간을 줄이고 생산성을 향상시킵니다.\n\n# 개발 환경 설정하기\n\n<div class=\"content-ad\"></div>\n\n먼저, 모든 애플리케이션 코드를 보관할 주요 폴더를 생성합니다. 이 폴더 내에서 Frontend 및 Backend이라는 두 개의 디렉터리를 생성할 것입니다. Frontend은 npm create vite@latest 명령어를 통해 만들고, Backend은 백엔드를 위한 익스프레스 서버를 설정하기 위해 npm init -y 명령어를 통해 초기화할 것입니다. 이 구분은 React가 백엔드 논리를 직접적으로 프론트엔드 코드와 함께 구현하는 것을 지원하지 않기 때문에 필요합니다. 또한, 이 구조는 프로젝트 조직을 깔끔하고 이해하기 쉽게 유지하는 데 도움이 됩니다.\n\nFrontend 폴더에서 다음 명령어를 아래 스크린샷에 표시된 대로 실행해주세요:\n\n![이미지](/assets/img/2024-06-22-MasteringtheMERNStackAGuidetoPerfectProjectArchitecture_1.png)\n\n다음으로, Backend 폴더로 이동하여 npm init -y를 실행하여 프로젝트를 초기화합니다. 이는 package.json 파일을 생성할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Mastering the MERN Stack: A Guide to Perfect Project Architecture](/assets/img/2024-06-22-MasteringtheMERNStackAGuidetoPerfectProjectArchitecture_2.png)\n\nNow we will install dependencies which will be required for setting up the backend server.\n\n![Mastering the MERN Stack: A Guide to Perfect Project Architecture](/assets/img/2024-06-22-MasteringtheMERNStackAGuidetoPerfectProjectArchitecture_3.png)\n\nWhy are we using these libraries?\n\n\n<div class=\"content-ad\"></div>\n\n- express: Node.js 웹 애플리케이션을 빌드하기 위한 최소한이면서 유연한 웹 애플리케이션 프레임워크입니다.\n- mongoose: MongoDB와 Node.js를 위한 ODM(Object Data Modeling) 라이브러리로, 응용 프로그램 데이터 모델링을 위한 스키마 기반 솔루션을 제공합니다.\n- body-parser: 수신 요청 바디를 구문 분석하는 미들웨어로, req.body 속성 하에 사용할 수 있습니다.\n- cors: 다른 도메인에서 리소스를 요청할 수 있도록 하는 Cross-Origin Resource Sharing을 활성화하는 미들웨어입니다.\n- bcrypt: bcrypt 해싱 알고리즘을 사용하여 비밀번호를 안전하게 해싱하고 비교하는 라이브러리입니다.\n\n이제 우리는 요구 사항이 확장 될 경우에도 우리의 프로젝트를 쉽게 찾고 코딩 할 수 있는 확장 가능한 프로젝트 구조를 위해 여러 폴더를 생성할 것입니다.\n\n![Mastering the MERN Stack: A Guide to Perfect Project Architecture](/assets/img/2024-06-22-MasteringtheMERNStackAGuidetoPerfectProjectArchitecture_4.png)\n\n- controllers: 다양한 애플리케이션 엔드포인트의 백엔드 로직과 구현을 처리합니다.\n- middleware: 컨트롤러에 도달하기 전에 요청을 처리하는 함수들입니다.\n- models: 데이터베이스의 구조를 나타내고 데이터 상호 작용을 처리합니다.\n- node_modules: 프로젝트에 설치된 모든 종속성을 포함하는 디렉토리입니다.\n- routes: 애플리케이션 엔드포인트를 정의하고 컨트롤러 함수에 연결합니다.\n- .env: 환경별 변수와 구성을 저장하는 파일입니다.\n- index.js: 어플리케이션의 주진입점으로, 서버를 초기화하고 실행합니다.\n- .gitignore: Git이 무시하고 추적하지 않아야 하는 파일과 디렉토리를 지정합니다.\n- package-lock.json: 종속성의 정확한 버전을 잠그어 일관된 설치를 보장하는 파일입니다.\n- package.json: 프로젝트의 종속성과 스크립트 목록, 프로젝트 이름 및 버전과 같은 메타데이터를 나열하는 파일입니다.\n\n<div class=\"content-ad\"></div>\n\n# 백엔드 폴더 아키텍처를 왜 선택했나요?\n\n소프트웨어 개발에서 프로젝트를 구체적인 파일과 폴더로 구성하는 것은 여러 가지 중요한 목적을 제공합니다. 컨트롤러, 미들웨어, 라우트 및 모델과 같은 폴더로 코드베이스를 분리함으로써 애플리케이션의 유지보수성과 확장성을 향상시킵니다. 각 폴더는 특정 기능을 캡슐화합니다: 컨트롤러는 애플리케이션 로직을 관리하고 응답을 처리하며, 미들웨어는 주요 로직에 도달하기 전에 요청을 가로채고 처리합니다, 라우트는 엔드포인트를 정의하고 해당 컨트롤러에 연결하며, 모델은 데이터베이스와의 구조 및 상호 작용을 나타냅니다.","ogImage":{"url":"/assets/img/2024-06-22-MasteringtheMERNStackAGuidetoPerfectProjectArchitecture_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringtheMERNStackAGuidetoPerfectProjectArchitecture_0.png","tag":["Tech"],"readingTime":4}],"page":"18","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}