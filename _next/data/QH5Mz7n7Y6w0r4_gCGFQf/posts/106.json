{"pageProps":{"posts":[{"title":"ASPNET Core Web API를 사용하여 Google reCAPTCHA 구현하기","description":"","date":"2024-05-14 14:34","slug":"2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI","content":"\n\n\n![Implementing reCAPTCHA using ASP.NET Core Web API](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_0.png)\n\n폼을 디자인했지만 웹 사이트가 봇 공격이나 다른 자동화된 공격을 받고 백엔드로 무관한 데이터를 제출할까 걱정되나요? Google reCaptcha가 이 문제에 대한 해결책을 제공합니다.\n\nGoogle reCaptcha는 사기를 탐지하고 합법적인 사용자만 시스템에 입력하고 로그인 페이지를 사용하거나 양식을 제출하거나 결제를 하거나 페이지를 보거나 가짜 사용자를 차단하는 등의 작업을 허용하는 시스템입니다.\n\n이제 프로젝트에 reCaptcha를 구현하는 방법에 대해 이야기해보겠습니다. 프론트엔드로 HTML, CSS 및 Javascript을 사용하고 백엔드로는 ASP.NET Core Web API를 사용할 것입니다.\n\n\n\n\n구현 부분은 상당히 쉽습니다. Google은 reCaptcha 생성을 위한 API를 제공하며, 해당 API의 JavaScript 파일 링크를 HTML 코드에 포함해야 합니다.\n\n우리는 HTML과 CSS를 사용하여 간단한 로그인 폼을 만드는 것부터 시작할 것입니다.\n\n나는 이 로그인 폼을 만들었는데, 여기에 Google reCaptcha를 추가할 것입니다.\n\n![Login Form](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_1.png)\n\n\n\nGoogle reCaptcha를 추가하려면 나중에 코드에서 사용할 키를 먼저 생성해야 합니다.\n\n새 키를 생성하려면 다음 URL을 방문하십시오:\n\n[https://www.google.com/recaptcha/admin/create](https://www.google.com/recaptcha/admin/create)\n\nGoogle 계정으로 이미 로그인되어 있으면 등록 대시보드가 표시됩니다. 그렇지 않으면 Google 계정으로 먼저 로그인해야 합니다.\n\n\n\n이것은 등록 키 대시보드입니다. 여기에는 레이블, reCaptcha 유형 및 도메인과 같은 기본 정보를 입력해야 합니다.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_2.png)\n\n- 레이블은 키에 할당하려는 아무 이름이 될 수 있습니다.\n- Google이 제공하는 두 가지 유형의 reCaptcha가 있습니다. v3와 v2입니다. 저희는 v2 \"나는 로봇이 아닙니다\" 확인란을 사용할 것입니다.\n- 도메인 필드에는 Google reCaptcha를 사용할 도메인을 지정해야 합니다. 예를 들어, 웹 사이트 이름이 다음과 같다면:\nhttps://your-website.com/index.html — 여기서는 도메인으로 your-website.com만 입력하면 됩니다.\n저는 데모 목적으로 reCaptcha를 구현하고 있으므로 애플리케이션을 로컬 환경에서 실행할 것입니다. 따라서 도메인으로 127.0.0.1을 사용했습니다.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_3.png)\n\n\n\n모든 세부 정보를 입력한 후 제출 버튼을 클릭해주세요. 그럼 두 개의 키가 생성됩니다. 클라이언트 측에서 사용되는 사이트 키와 서버 측에서 사용되는 시크릿 키가 있습니다.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_4.png)\n\n코딩 부분으로 돌아가면, reCaptcha를 삽입할 위치에 다음 코드 라인을 추가해야 합니다. 로그인 버튼 앞에 추가하겠습니다.\n\n```js\n<div class=\"g-recaptcha\" data-sitekey=여기에_사이트_키_입력></div>\n```\n\n\n\n원하는 위치에 이 div 클래스를 추가한 후, Google reCaptcha API를 호출하는 JavaScript 파일을 추가하십시오.\n\n```js\n<script type=\"text/javascript\" src=\"https://www.google.com/recaptcha/api.js\"></script>\n```\n\nreCaptcha를 추가한 후 로그인 페이지가 이렇게 보입니다.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_5.png)\n\n\n\n아래에 HTML(index.html) 및 CSS(style.css) 파일의 코드를 찾을 수 있어요:\n\n```js\n<!DOCTYPE html>\n<head>\n    <title>로그인 페이지</title>\n    <link rel=\"stylesheet\" href=\"style.css\">    \n    <script type=\"text/javascript\" src=\"https://www.google.com/recaptcha/api.js\"></script>\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js\"></script>\n    <script type=\"text/javascript\" src=\"script.js\"></script>\n</head>\n<body>\n    <div class=\"login-page\">\n        <div class=\"form\">      \n          <div class=\"login-form\">\n            <input type=\"text\" placeholder=\"사용자 이름\"/>\n            <input type=\"password\" placeholder=\"비밀번호\"/>\n            <div class=\"g-recaptcha\" data-sitekey=\"6LfU_xMpAAAAADmXvZq0VqCVLIyJz3x6V8dUQeZ8\"></div><br>\n            <button onclick=\"LoginButton()\">로그인</button>            \n          </div>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n```js\n@import url(https://fonts.googleapis.com/css?family=Roboto:300);\n\n.login-page {\n  width: 360px;\n  padding: 8% 0 0;\n  margin: auto;\n}\n.form {\n  position: relative;\n  z-index: 1;\n  background: rgb(116, 223, 187);\n  max-width: 360px;\n  margin: 0 auto 100px;\n  padding: 30px;\n  text-align: center;\n  box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);\n}\n.form input {\n  font-family: \"Roboto\", sans-serif;\n  outline: 0;\n  background: #f2f2f2;\n  width: 100%;\n  border: 0;\n  margin: 0 0 15px;\n  padding: 15px;\n  box-sizing: border-box;\n  font-size: 14px;\n}\n.form button {\n  font-family: \"Roboto\", sans-serif;\n  text-transform: uppercase;\n  outline: 0;\n  background: rgb(8, 103, 116);\n  width: 100%;\n  border: 0;\n  padding: 15px;\n  color: #FFFFFF;\n  font-size: 14px;\n  -webkit-transition: all 0.3 ease;\n  transition: all 0.3 ease;\n  cursor: pointer;\n}\n.form button:hover,.form button:active,.form button:focus {\n  background: #073b44;\n}\n\n.container {\n  position: relative;\n  z-index: 1;\n  max-width: 300px;\n  margin: 0 auto;\n}\n```\n\n프론트엔드 부분이 이제 완료되었어요. 그 다음에는 자바스크립트를 사용하여 reCaptcha로부터 응답을 가져와서 시크릿 키를 사용하여 백엔드에서 응답을 확인할 거에요.\n\n\n\n로그인 버튼에 onclick 함수를 추가했어요. 이 함수는 reCaptcha로부터 응답을 가져오고 API에 ajax 호출을 만들 거예요. 필요에 따라 세 개의 필드가 모두 채워질 때까지 로그인 버튼을 비활성화하는 기능 같은 다른 기능도 추가할 수 있어요. 여기서는 간단하게 reCaptcha의 유효성을 성공 또는 실패했을 때 경고 메시지를 표시해 줄 거에요.\n\nAPI 쪽에서는 ASP.NET Core와 Visual Studio 2022를 사용하고 있어요. 제 블로그의 첫 번째 부분(단계 1)을 참조해서 Visual Studio 2022를 사용해 API 프로젝트를 만드는 방법을 알아볼 수 있어요.\n\n- appsettings.json으로 이동해서 비밀 키를 추가하세요.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_6.png)\n\n\n\n```js\n\"reCaptcha\": {\n    \"SecretKey\": Your_Secret_Key, \n  },\n```\n\n2. 새 컨트롤러를 만듭니다. 다음 단계를 따라주세요:\nControllers 폴더에서 우클릭 -` 추가 -` 컨트롤러 -` 빈 API 컨트롤러 선택 -` 컨트롤러에 이름 지정 (저는 UserController라고 이름짓겠습니다).\n\n컨트롤러를 만들면 다음과 같은 모습이 될 것입니다:\n\n<img src=\"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_7.png\" />\n\n\n\n3. 컨트롤러에 reCaptcha를 검증하는 로직을 추가하세요.\n\n![이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_8.png)\n\n- 여기서 우리는 Configuration을 주입하여 appsettings.json에서 Secret Key를 가져오고 HttpClient를 사용하여 결과를 Google API 엔드포인트에 전송합니다.\n- 'GetreCaptchaResponse'라는 메서드를 생성했는데, 이 메서드는 프론트 엔드에서 전송된 reCaptcha 응답을 받습니다. 그다음으로, 응답 및 시크릿 키를 저장할 'content' 변수를 생성합니다.\n- Google은 응답과 시크릿 키가 전달되어야 하는 API 엔드포인트(https://www.google.com/recaptcha/api/siteverify)를 제공하고, json 형식의 결과를 제공합니다. 자세한 정보는 해당 페이지에서 확인할 수 있습니다.\n우리는 이 내용을 해당 API로 전달하고 결과를 'response' 변수에 저장합니다.\n- 이 응답이 성공하면 'Success' 및 'Error' 코드를 읽어 'result' 변수에 저장합니다.\n\n아래에서 전체 코드를 찾을 수 있습니다.\n\n\n\n```csharp\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace reCaptchaAPI.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class UserController : ControllerBase\n    {\n        private readonly IConfiguration _configuration;\n        private readonly HttpClient _httpClient;\n        public UserController(IConfiguration configuration, HttpClient httpClient)\n        {\n            _configuration = configuration;\n            _httpClient = httpClient;\n        }\n        [HttpGet(\"Captcha\")]\n        public async Task<bool> GetreCaptchaResponse(string userResponse)\n        {\n            var reCaptchaSecretKey = _configuration[\"reCaptcha:SecretKey\"];\n\n            if(reCaptchaSecretKey != null && userResponse != null)\n            {\n                var content = new FormUrlEncodedContent(new Dictionary<string, string>\n                {\n                    {\"secret\", reCaptchaSecretKey },\n                    {\"response\", userResponse }\n                });\n                var response = await _httpClient.PostAsync(\"https://www.google.com/recaptcha/api/siteverify\", content);\n                if(response.IsSuccessStatusCode)\n                {\n                    var result = await response.Content.ReadFromJsonAsync<reCaptchaResponse>();\n                    return result.Success;\n                }\n            }\n            return false;\n        }\n\n        public class reCaptchaResponse\n        {\n            public bool Success { get; set; }\n            public string[] ErrorCodes { get; set; }\n        }\n    }\n}\n```\n\n다음 단계는 HttpClient 미들웨어를 program.cs에 등록하고 이 API를 프론트엔드에서 호출할 것이므로 CORS (Cross Origin Resource Sharing)를 지정해야합니다. 이는 프론트엔드 코드에서 API에 액세스할 수 있도록 도와줍니다.\n\n<img src=\"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_9.png\" />\n\nCORS를 지정하려면:\n\n\n\n\n```js\nbuilder.Services.AddCors(options =>\n{\n    options.AddDefaultPolicy(\n        policy =>\n        {\n            policy.AllowAnyOrigin()\n                .AllowAnyHeader()\n                .AllowAnyMethod();\n        });\n});\n\napp.UseCors();\n```\n\nTo register HttpClient Middleware:\n\n```js\nbuilder.Services.AddHttpClient();\n```\n\nYour API Project is now completed. You can run and test it once using swagger.\n\n\n\n이제 남은 것은 API를 구현하기 위해 ajax 호출을 작성하는 것입니다. 로그인 버튼에 onclick 함수를 추가하고 함수 내에서 ajax 호출을 정의할 것입니다.\n\n<img src=\"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_10.png\" />\n\n여기서 reCaptcha 응답을 받아 이를 API의 매개변수로 보내고 있습니다. API 프로젝트를 실행하고 Swagger 페이지가 열리면 로컬호스트 URL을 복사하여 여기에 사용할 수 있습니다. 엔드포인트 이름을 정확히 지정했는지 확인해주세요!\n\n이러한 변경 사항을 적용하고 애플리케이션을 실행한 후, 다음과 같은 경고를 받게 될 것입니다:\n\n\n\n\n[이미지](/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_11.png)\n\n자바스크립트 (script.js) 코드는 다음과 같습니다:\n\n```js\nfunction LoginButton(){\n    const reCaptchaResponse = grecaptcha.getResponse();\n    if(reCaptchaResponse){\n        $.ajax({\n            type: \"GET\",\n            url: \"https://localhost:44317/api/User/Captcha\",\n            data: {userResponse : reCaptchaResponse},            \n            success: function(data){\n                if(data){\n                    //API returned true\n                    alert(\"Captcha Verified\");\n                }else{\n                    //API returned false\n                    alert(\"Please verify captcha again\");\n                }               \n            },\n            error: function(error){\n                alert(\"Please try again\");\n            }\n        });\n    }\n    else{\n        alert(\"Something went wrong with reCaptcha. Please try again!\");\n    }\n}\n```\n\n이 응용 프로그램의 소스 코드를 참조해주세요:\n","ogImage":{"url":"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingGooglereCAPTCHAusingASPNETCoreWebAPI_0.png","tag":["Tech"],"readingTime":10},{"title":"Durandal 대 Angular","description":"","date":"2024-05-14 14:32","slug":"2024-05-14-DurandalvsAngular","content":"\n\n\n![Durandal Logo](/assets/img/2024-05-14-DurandalvsAngular_0.png)\n\n알고 계신가요? Durandal을 들어보신 적이 있나요? 만일 JS 개발자 경험이 적다면 들어보지 못했을 것입니다. 10년 전에 이것은 인기 있는 싱글 페이지 앱 (SPA) 프레임워크였습니다.\n\n당시 저는 Durandal을 사용한 중요한 프로젝트에서 1년 이상 일했습니다. 저는 그것을 좋아했어요. 작고, 유연하며 확장하기 쉬웠습니다.\n\n10년은 IT분야에서 긴 시간입니다. 지금은 Durandal이 더 이상 사용되지 않고 있습니다. 새로운 세대의 프런트 엔드 JS 프레임워크가 웹 애플리케이션의 세계를 지배하고 있습니다.\n\n\n\n\n최근에 오래된 Durandal 애플리케이션에 소규모 개선 작업을 하게 되었어요. 옛 친구를 다시 만난 기분이었죠. 당연히 현재의 JS 프레임워크인 Angular 16과 비교해보았어요.\n\n아시다시피 Angular는 거의 모든 면에서 Durandal을 앞섰어요. 하지만 Durandal의 많은 디자인 개념들은 여전히 그 가치를 지키고 있어요. 이러한 비교를 보면 지난 10년 동안 Single Page App (SPA) 프레임워크가 얼마나 발전했는지 명확해져요. 우리가 얼마나 멀리 왔는지 보는 것은 꽤 흥미롭죠.\n\n## 프레임워크 개요\n\nDurandal은 단순함과 모듈성을 중점으로 둔 가벼운 SPA 프레임워크로 만들어졌어요. Knockout과 Require.js와 같은 라이브러리의 조합을 활용하여 목표를 달성했어요.\n\n\n\nDurandal은 SPA를 만드는 데 필수적인 기능을 제공합니다. 또한 다른 라이브러리와 쉽게 통합할 수 있도록 설계되었습니다.\n\n반면에 Angular는 완전한 패키지입니다. 그래서 그것은 \"배터리 포함\"이라고 불립니다. 이는 Angular가 대규모 및 복잡한 프로젝트에 적합한 풍부한 싱글 페이지 웹 앱을 구축하는 데 필요한 모든 것을 제공한다는 것을 의미합니다.\n\n## AMD vs ES6 module\n\nDurandal은 모듈 로딩과 의존성 관리를 위해 Asynchronous Module Definition (AMD) 패턴을 사용합니다. AMD의 한 예는 아래와 같습니다:\n\n\n\n```js\n// Durandal에서 AMD를 사용하여 모듈 정의하기\ndefine(['knockout'], function(ko) {\n    var viewModel = {\n        message: ko.observable('안녕, Durandal!')\n    };\n    return viewModel;\n});\n```\n\nAngular 및 다른 새로운 JS 프레임워크는 ES6 모듈을 사용합니다. AMD와 달리, ES6 모듈은 JavaScript에 기본적으로 내장되어 있어 추가적인 로더나 Require.js와 같은 라이브러리가 필요하지 않습니다. ES6 모듈은 정적 분석을 가능하게 하여 더 나은 도구 지원, 트리 쉐이킹 및 성능 향상을 제공합니다. ES6 모듈은 기본적으로 더 나은 캡슐화를 제공하여 의존성을 관리하는 것을 쉽게 만들고 의도하지 않은 충돌을 방지합니다. 아래는 사용 예시입니다.\n\n```js\n// 모듈 가져오기\nimport { greet } from './myModule';\n\n// Angular 컴포넌트\n@Component({\n  selector: 'app-greeting',\n})\nexport class GreetingComponent {\n  message: string;\n\n  constructor() {\n    // 가져온 함수 사용하기\n    this.message = greet('John');\n  }\n}\n```\n\n## 컴포넌트 기반 아키텍처\n\n\n\n\n현대 SPA 프레임워크에서 기본적인 설계 패러다임인 구성 요소 기반 아키텍처는 사용자 인터페이스를 재사용 가능한 독립적인 구성 요소로 분해하여 모듈화 및 유지 관리성을 촉진합니다.\n\nDurandal은 구성 요소 개념을 갖고 있지만 현대 SPA에서 볼 수 있는 구조화된 구성 요소 기반 아키텍처가 부족합니다.\n\nAngular은 구성 요소 기반 아키텍처를 강조하며 재사용 가능한 구성 요소 내에서 기능을 캡슐화하여 명확한 관심사 분리와 유지 관리성을 촉진하는 구조화된 개발 접근 방식을 강제합니다.\n\n## 상태 관리\n\n\n\nDurandal은 뷰 모델, 라우팅, 라이프사이클 메소드 및 저장 옵션의 조합을 사용하여 상태를 관리하고 유지하는 데 도움을 줍니다. 애플리케이션이 커지면 다른 컴포넌트 및 뷰 간의 상태 전이를 추적하고 관리하는 것이 더 어려워질 수 있습니다.\n\nAngular에는 많은 상태 관리 프레임워크가 있습니다. 가장 인기 있는 것은 Redux에서 영감을 받은 상태 관리 라이브러리인 NgRx입니다. 이를 통해 응용 프로그램 상태를 구조화하고 복잡한 데이터 흐름을 처리하기 쉬워집니다.\n\n## 의존성 주입\n\nDurandal은 전용 의존성 주입 컨테이너를 제공하지는 않지만 모듈 구조와 Require.js와 같은 AMD(비동기 모듈 정의) 로더와 통합을 제공합니다.\n\n\n\nAngular의 의존성 주입(Dependency Injection, DI)은 우리에게 종속성을 손쉽게 관리하고 주입할 수 있는 강력한 메커니즘입니다. 내장된 DI를 통해 코드를 깔끔하고 조직적으로 유지하고 테스트할 수 있으므로, 견고한 웹 응용 프로그램을 개발하는 데 탁월한 기능입니다.\n\n```js\n// 의존성 주입이 포함된 Angular 컴포넌트\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-example',\n  template: '<p>{ message }</p>',\n})\nexport class ExampleComponent {\n  constructor(private dataService: DataService) {\n    this.message = this.dataService.getMessage();\n  }\n}\n```\n\n## 바인딩\n\nDurandal은 Knockout을 이용한 양방향 데이터 바인딩을 사용하여 동적 UI 업데이트를 처리할 수 있었습니다.\n\n\n\n```js\n<!-- Durandal 바인딩 -->\nvar vm = {\n    message = ko.observable('안녕 세상아')\n};\nko.applyBindings(vm);\n```\n\nAngular은 자체적인 양방향 데이터 바인딩 메커니즘을 제공하며 시간이 지남에 따라 성능과 유연성이 향상되었습니다.\n\n```js\n<!-- Angular HTML 템플릿 -->\n<input [(ngModel)]=\"message\" />\n<p>{ message }</p>\n```\n\nReact와 같은 다른 최신 프론트엔드 JS 프레임워크들은 이벤트를 통해 데이터 상태를 업데이트하여 성능을 향상시키는 단방향 데이터 바인딩을 활용합니다.\n\n\n\n\n## 도구, CLI 및 성능 최적화\n\nDurandal은 간단하고 모듈식이지만 CLI 도구가 없었습니다. 또한 내장된 성능 최적화 기능도 제공하지 않았습니다.\n\nAngular와는 달리 Durandal에는 기본적으로 서버 측 렌더링 지원이 없었습니다.\n\nAngular에는 자체 CLI가 함께 제공됩니다. Angular 앱을 구축, 테스팅 및 배포하기 위한 풍부한 툴킷입니다. 개발자들에게 생활을 쉽게 만들어주며 생산성을 크게 향상시킵니다.\n\n\n\nAngular 16은 AOT 컴파일 및 향상된 트리 쉐이킹과 같은 멋진 성능 트릭으로 한 단계 더 나아갑니다. 이는 더 빠른 로드 시간과 더 작은 번들로 앱 전체를 보다 빠르게 만들어줍니다. \n\nAngular 16은 향상된 Angular Universal을 롤아웃하여 적절한 서버 측 렌더링 기능을 제공합니다. 이로 인해 페이지가 더 빨리 로드되고 SEO를 향상시킵니다.\n\n이러한 중요한 발전은 현대적인 단일 페이지 앱(SPAs)을 한 단계 발전시켰습니다. 이러한 앱들은 강력하며 유지 보수가 쉽고 매우 빠릅니다. Angular와 Durandal을 비교하면 새로운 멋진 스포츠카와 오래된 모델을 비교하는 것과 같습니다. Durandal은 그 시대에 놀랍지만, 새로운 세대의 SPA 프레임워크는 모든 것을 새로운 수준으로 끌어올렸습니다!","ogImage":{"url":"/assets/img/2024-05-14-DurandalvsAngular_0.png"},"coverImage":"/assets/img/2024-05-14-DurandalvsAngular_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular에서 양식Form","description":"","date":"2024-05-14 14:30","slug":"2024-05-14-FormsinAngular","content":"\n\n<img src=\"/assets/img/2024-05-14-FormsinAngular_0.png\" />\n\n안녕하세요! 이번 글에서는 Angular에서 양식과 그 종류에 관해 단계별 실제 구현과 함께 살펴보려고 해요.\n\n# 안내\n\n- Angular란 무엇인가요?\n\n\n\n## Angular에서의 폼\n\n## 폼의 종류\n\n## 실무 적용\n\n### Prerequisites\n\n\n\n- TypeScript에 대한 기본적인 이해\n\n- NodeJS\n\n- Angular CLI\n\n- Vs Code\n\n\n\n# 앵귤러란?\n\n앵귤러는 웹 애플리케이션을 구축하는 인기 있는 오픈 소스 JavaScript 프레임워크입니다. 구글에서 개발되었으며 현재는 구글의 앵귤러 팀에서 유지보수되고 있습니다. 앵귴러는 개발자들이 동적인 싱글 페이지 애플리케이션(SPA)을 만들 수 있게 하며 복잡한 웹 애플리케이션을 구축하기 위한 체계적인 접근 방식을 제공합니다.\n\n# 앵귤러에서의 폼\n\n- 앵귤러에서 폼은 사용자 입력을 처리하고 관리하는 데 도움이 되는 다양한 기능을 제공합니다.\n\n\n\n- 웹 애플리케이션의 주요 부분인 Forms. 사용자들이 애플리케이션과 상호 작용하고 애플리케이션으로 데이터를 제출할 수 있게 합니다.\n\n## Angular에서 제공하는 Forms의 종류\n\nAngular는 다음 두 가지 유형의 Forms를 제공합니다:\n\n### 1. Template-Driven Forms\n\n\n\n- 템플릿 기반 폼은 제한된 수의 필드 및 간단한 유효성 검사를 개발하기에 적합한 기본 폼입니다.\n\n- 이 폼에서 각 필드는 컴포넌트 클래스의 속성으로 표시됩니다.\n\n- '@angular/forms' 패키지에서 FormsModule를 가져와야 합니다.\n\n다음은 Angular에서 템플릿 기반 폼을 생성하는 동안 사용하는 유효성 검사 객체, 지시문, 속성과 관련된 주요 개념입니다.\n\n\n\n- ngForm 디렉티브: 이 디렉티브는 Angular 폼을 나타내며 유효성 검사 및 데이터 조작과 관련된 메서드 및 속성을 노출합니다.\n\n- ngModel 디렉티브: 이 디렉티브는 서로 다른 폼 컨트롤 요소 간의 양방향 데이터 바인딩을 달성하는 데 사용됩니다.\n\n- 유효성 검사 속성: Angular는 폼 컨트롤에 적용할 수있는 다양한 유효성 검사기 속성을 제공합니다.\n\n1. touched: 해당 컨트롤이 터치되었는지를 나타내는 부울 값입니다.\n\n\n\n2. untouched: 터치되지 않은 상태\n\n3. valid: 컨트롤 값이 유효한지 나타내는 부울 값.\n\n4. invalid: valid의 반대\n\n- 유효성 검사 디렉티브: Angular는 몇 가지 내장 유효성 검사 디렉티브를 제공하여 ngModel과 함께 사용하여 유효성 검사를 수행할 수 있습니다. 일반적으로 사용되는 몇 가지 디렉티브에는 다음이 있습니다:\n\n\n\n1. required: 값이 비어 있지 않도록 보장합니다.\n\n2. min length 및 max length: 값의 최소 및 최대 길이를 지정합니다.\n\n3. pattern: 값을 정규 표현식과 비교합니다.\n\n4. email: 값이 유효한 이메일 주소인지 확인합니다.\n\n\n\n## 2. 반응형 폼\n\n- 반응형 폼 또는 모델 기반 폼은 Angular에서 큰 양의 폼을 만들거나 다양한 폼 필드 및 복잡한 검증이 필요한 경우에 적합한 종류의 폼입니다.\n\n- 반응형 폼에서, 각 폼 필드는 Form Control로 간주되며, 폼 컨트롤 집합은 Form Group이라고 합니다.\n\n- 검증 규칙은 Validators 객체를 사용하여 컴포넌트에서 정의되며, 검증 메시지는 템플릿에서 validation 속성을 사용하여 표시할 수 있습니다.\n\n\n\n· ReactiveFormModule은 '@angular/forms' 패키지에서 가져와야 합니다.\n\nAngular에서 반응형 폼을 생성하는 동안 사용된 유효성 객체 및 속성과 관련된 주요 개념은 다음과 같습니다.\n\n· FormControl\n\nAngular에서 폼 컨트롤은 반응형 폼에서 개별 폼 요소를 나타냅니다. 또한 입력 폼 요소의 다른 상태와 값들을 관리합니다. 유효성 규칙을 정의할 수 있는 다양한 속성이 있습니다.\n\n\n\n1. Value: 양식 컨트롤의 현재 값을 확인하는 데 도움을 줍니다.\n\n2. Status: 상태는 양식 컨트롤의 상태를 나타냅니다.\n\n3. Valid: 컨트롤이 유효한지를 확인하는 부울 유효성 속성입니다.\n\n4. Invalid: 컨트롤이 유효하지 않은지를 확인하는 부울 유효성 속성입니다.\n\n\n\n5. 에러: 이는 폼 컨트롤의 유효성 검증 오류를 보유한 객체입니다.\n\n- **Validators**\n\nValidators는 폼 컨트롤의 유효성 검증 규칙을 정의하는 데 사용할 수 있는 함수들입니다.\n\n1. required: 컨트롤이 비어있지 않은 값을 가지고 있는지를 검증합니다.\n\n\n\n2. Min(최소값) 및 max(최대값): 컨트롤 값이 지정된 숫자 범위 내에 있는지 확인합니다.\n\n3. pattern(패턴): 컨트롤 값이 정규 표현식과 일치하는지 확인합니다.\n\n4. email(이메일): 컨트롤 값이 유효한 이메일 주소인지 확인합니다.\n\n5. minLength(최소길이) 및 maxLength(최대길이): 컨트롤 값의 길이를 확인합니다.\n\n\n\n- FormGroup\n\n폼 그룹은 여러 폼 컨트롤을 포함하는 컨테이너입니다. 관련된 폼 컨트롤을 함께 그룹화하고 단일 단위로 유효성을 관리할 수 있습니다.\n\n- FormBuilder\n\nFormBuilder 서비스는 FormGroup 및 FormControl의 인스턴스를 생성하는 데 사용되며 유효성 규칙을 정의하는 편리한 방법을 제공합니다.\n\n\n\n# 실용적인 구현\n\n단계 1\n\n새로운 Angular 애플리케이션을 생성하세요.\n\n단계 2\n\n\n\n다음 명령어를 사용하여 부트스트랩 모듈을 설치해 보세요:\n\nnpm install bootstrap\n\nAngular JSON 파일에서 Bootstrap을 구성하세요.\n\n```js\n \"styles\": [\n              \"src/styles.css\",\n              \"./node_modules/bootstrap/dist/css/bootstrap.min.css\"\n            ],\n            \"scripts\": [\n              \"./node_modules/bootstrap/dist/js/bootstrap.min.js\"\n            ]\n```\n\n\n\nStep 3\n\n다음으로, 새롭게 생성된 프로젝트에 두 개의 컴포넌트를 추가해보세요.\n\ntemplate-driven-form.component.html\n\n```js\n<div class=\"container\">\n    <h2 class=\"heading\">템플릿 기반 폼</h2>\n    <form #userForm=\"ngForm\" (ngSubmit)=\"submitForm(userForm)\">\n   \n      <div class=\"form-group\">\n        <label for=\"name\">이름</label>\n        <input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" [(ngModel)]=\"userDetails.name\" required>\n        <div *ngIf=\"userForm.controls.name?.touched && userForm.controls.name?.invalid\" class=\"text-danger\">\n          이름을 입력해주세요.\n        </div>\n      </div>\n      \n      <div class=\"form-group\">\n        <label for=\"email\">이메일</label>\n        <input type=\"email\" class=\"form-control\" id=\"email\" name=\"email\" [(ngModel)]=\"userDetails.email\" required email>\n        <div *ngIf=\"userForm.controls.email?.touched && userForm.controls.email?.invalid\" class=\"text-danger\">\n          올바른 이메일 주소를 입력해주세요.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"address\">주소</label>\n        <input type=\"text\" class=\"form-control\" id=\"address\" name=\"address\" [(ngModel)]=\"userDetails.address\" required>\n        <div *ngIf=\"userForm.controls.address?.touched && userForm.controls.address?.invalid\" class=\"text-danger\">\n          주소를 입력해주세요.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"mobile\">휴대폰 번호</label>\n        <input type=\"tel\" class=\"form-control\" id=\"mobile\" name=\"mobile\" [(ngModel)]=\"userDetails.mobile\" required pattern=\"[0-9]{10}\">\n        <div *ngIf=\"userForm.controls.mobile?.touched && userForm.controls.mobile?.invalid\" class=\"text-danger\">\n          올바른 휴대폰 번호를 입력해주세요.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"age\">나이</label>\n        <input type=\"number\" class=\"form-control\" id=\"age\" name=\"age\" [(ngModel)]=\"userDetails.age\" required min=\"20\" max=\"60\">\n        <div *ngIf=\"userForm.controls.age?.touched && userForm.controls.age?.invalid\" class=\"text-danger\">\n          올바른 나이를 입력해주세요.\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n        <label for=\"gender\">성별</label>\n        <select class=\"form-control\" id=\"gender\" name=\"gender\" [(ngModel)]=\"userDetails.gender\" required>\n          <option value=\"\" disabled>성별 선택</option>\n          <option value=\"male\">남성</option>\n          <option value=\"female\">여성</option>\n          <option value=\"other\">기타</option>\n        </select>\n        <div *ngIf=\"userForm.controls.gender?.touched && userForm.controls.gender?.invalid\" class=\"text-danger\">\n          성별을 선택해주세요.\n        </div>\n      </div>\n\n      <button type=\"submit\" class=\"btn btn-primary\">제출</button>\n    </form>\n  </div>\n```\n\n\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-template-driven-form',\n  templateUrl: './template-driven-form.component.html',\n  styleUrls: ['./template-driven-form.component.css']\n})\nexport class TemplateDrivenFormComponent {\n  userDetails = {\n    name: '',\n    email: '',\n    address: '',\n    mobile: '',\n    age: null,\n    gender: ''\n  };\n\n  submitForm(form: any): void {\n    if (form.valid) {\n      console.log('Form data:', this.userDetails);\n    }\n  }\n}\n```\n\n- 이 예제에서 #userForm=\"ngForm\"은 폼 참조를 생성하여 컴포넌트 내의 사용자 객체의 속성에 접근할 수 있도록 합니다. [(ngModel)] 지시문은 입력 요소와 사용자 객체의 속성 간에 양방향 데이터 바인딩을 설정합니다.\n\n- 유효성 검사 지시문 (required 및 email)이 폼 컨트롤에 적용되며, 오류 메시지는 컨트롤의 상태에 따라 조건부로 표시됩니다.\n\n\n\n\n<img src=\"/assets/img/2024-05-14-FormsinAngular_1.png\" />\n\n다음으로 아래와 같이 반응형 폼을 생성하세요.\n\nreactive-form.component.html\n\n```js\n<div class=\"container\">\n    <h2 class=\"heading\">반응형 폼</h2>\n    <form [formGroup]=\"userForm\" (ngSubmit)=\"submitForm()\">\n\n        <div class=\"form-group\">\n        <label for=\"name\">이름</label>\n        <input type=\"text\" class=\"form-control\" id=\"name\" formControlName=\"name\">\n        <div *ngIf=\"userForm?.get('name')?.invalid && userForm?.get('name')?.touched\" class=\"text-danger\">\n          이름을 입력해주세요.\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"email\">이메일</label>\n        <input type=\"email\" class=\"form-control\" id=\"email\" formControlName=\"email\">\n        <div *ngIf=\"userForm?.get('email')?.invalid && userForm?.get('email')?.touched\" class=\"text-danger\">\n          유효한 이메일을 입력해주세요.\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"address\">주소</label>\n        <input type=\"text\" class=\"form-control\" id=\"address\" formControlName=\"address\">\n        <div *ngIf=\"userForm?.get('address')?.invalid && userForm?.get('address')?.touched\" class=\"text-danger\">\n          주소를 입력해주세요.\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"mobile\">휴대전화 번호</label>\n        <input type=\"tel\" class=\"form-control\" id=\"mobile\" formControlName=\"mobile\">\n        <div *ngIf=\"userForm?.get('mobile')?.invalid && userForm?.get('mobile')?.touched\" class=\"text-danger\">\n          유효한 휴대전화 번호를 입력해주세요.\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"age\">나이</label>\n        <input type=\"number\" class=\"form-control\" id=\"age\" formControlName=\"age\">\n        <div *ngIf=\"userForm?.get('age')?.invalid && userForm?.get('age')?.touched\" class=\"text-danger\">\n          유효한 나이를 입력해주세요 (1에서 120 사이).\n        </div>\n      </div>\n  \n      <div class=\"form-group\">\n        <label for=\"gender\">성별</label>\n        <select class=\"form-control\" id=\"gender\" formControlName=\"gender\">\n          <option value=\"\" disabled>성별 선택</option>\n          <option value=\"male\">남성</option>\n          <option value=\"female\">여성</option>\n          <option value=\"other\">기타</option>\n        </select>\n        <div *ngIf=\"userForm?.get('gender')?.invalid && userForm?.get('gender')?.touched\" class=\"text-danger\">\n          성별을 선택해주세요.\n        </div>\n      </div>\n  \n      <button type=\"submit\" class=\"btn btn-primary\">제출</button>\n    </form>\n  </div>\n```\n\n\n\n```js\nimport { Component } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-reactive-form',\n  templateUrl: './reactive-form.component.html',\n  styleUrls: ['./reactive-form.component.css']\n})\nexport class ReactiveFormComponent {\n  userForm: any;\n\n  constructor(private formBuilder: FormBuilder) {}\n\n  ngOnInit(): void {\n    this.userForm = this.formBuilder.group({\n      name: ['', Validators.required],\n      email: ['', [Validators.required, Validators.email]],\n      address: ['', Validators.required],\n      mobile: ['', [Validators.required, Validators.pattern('[0-9]{10}')]],\n      age: ['', [Validators.required, Validators.min(20), Validators.max(50)]],\n      gender: ['', Validators.required]\n    });\n  }\n\n  submitForm(): void {\n    if (this.userForm?.valid) {\n      console.log('Form data:', this.userForm.value);\n    }\n  }\n}\n```\n\n![FormsinAngular_2](/assets/img/2024-05-14-FormsinAngular_2.png)\n\n# GitHub\n\n\n\n\nhttps://github.com/Jaydeep-007/angular-forms\n\n# 결론\n\n이 글에서는 Angular에서 사용할 수 있는 양식의 기본 개념과 단계별 구현 방법, 다양한 유효성 검사기와 속성을 통해 다양한 유형의 양식을 살펴보았습니다.","ogImage":{"url":"/assets/img/2024-05-14-FormsinAngular_0.png"},"coverImage":"/assets/img/2024-05-14-FormsinAngular_0.png","tag":["Tech"],"readingTime":11},{"title":"TypeScript에서 형 추론에 대한 신기한 사례","description":"","date":"2024-05-14 14:28","slug":"2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript","content":"\n\n얼마 전에 사이드 프로젝트를 하고 있었어요. 많은 이벤트를 감지하는 특정 라이브러리를 사용했죠.\n\n제 프로젝트에서도 같은 종류의 이벤트를 사용하고 싶어서 바퀴를 다시 발명하지 않으려고 했어요.\n\n라이브러리 제작자들은 이벤트 리스너 함수의 오버로딩된 첫 번째 매개변수로 이벤트를 넣었어요, 여기처럼요:\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n}\n```\n\n\n\n의도했던 것은 적절한 유형 정의를 가져오고 계속하는 데 단지 몇 초만 걸릴 줄 알았어요.\n\n그러나 몇 초라는 시간은 분으로 늘어났죠. 더 놀라운 건, 반으로 눈 깜짝할 사이에 또 쿼터로 더 빨라졌어요. 반 시간이 흐른 후, 화면을 의심스럽게 바라보게 되었어요.\n\n\"어떻게 간단한 유형 추론이 이렇게 복잡할 수 있지?\" 라고 생각했죠.\n\n# 기본사항\n\n\n\nTS v. 5.2.2에서 제시된 모든 예제를 테스트했어요.\n\n제가 언급한 오버로드 함수는 아래와 비슷했습니다:\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n    (event: 'eventB'): void;\n    (event: 'eventC'): void;\n    // ...\n    (event: 'eventZ'): void;\n}\n```\n\n간결함을 위해 추가 매개변수와 각각 다른 반환 유형은 제거했어요. 제 업무는 이벤트 종류를 추출하여 문자열 리터럴 유니언을 형성하는 것이었죠.\n\n\n\n위의 예시에서는:\n\n```js\ntype EventType = 'eventA' | 'eventB' | 'eventC' | /*...*/ | 'eventZ';\n```\n\n내가 먼저 떠오른 것은 Parameters`T` 타입 앨리어스를 사용하는 것이었다. 반환 타입에 경악했다.\n\n```js\ntype NotEventType = Parameters<OverloadedFunction>[0];\n// type NotEventType = \"eventZ\"\n```\n\n\n\n'eventZ'만 왜 나왔을까요?\n\n![이미지](/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_0.png)\n\nParameters 타입 정의를 자세히 살펴봤습니다 (여기서는 조금 간단히 했습니다):\n\n```js\ntype Parameters<T> = T extends (...args: infer R) => any ? R : never;\n```\n\n\n\n위의 내용은 너무 많은 매개변수를 추출한다고 생각했어요. 바로 첫 번째 매개변수만 직접 타겟팅할 수 있을 거라 생각해 시도해 봤는데 결과는 여전히 같았어요.\n\n```js\ntype FirstParameter<T> = T extends (arg: infer R, ...args: never) => any\n  ? R\n  : never;\n\ntype NotEventType = FirstParameter<OverloadedFunction>;\n// type NotEventType = \"eventZ\"\n```\n\n마지막 오버로딩된 매개변수 타입을 추출했기 때문에 오버로드된 함수 타입이 제대로 분배하지 않은 유니언 타입이라고 생각했습니다.\n\n# 유니온 분배\n\n\n\n가정해보세요. 우리가 유니언 타입 A를 가지고 있다고 해봅시다.\n\n```js\ntype A = 1 | 2 | 3;\n```\n\n우리는 이 유니언에서 1을 제거하고 싶습니다. 다음과 같은 방법을 시도해 볼 수 있습니다.\n\n```js\ntype AWithout1 = A extends 1 ? never : A;\n// type AWithout1 = 1 | 2 | 3\n```\n\n\n\n놀라셨나요? TypeScript가 여기서 올바르게 동작한 것을 염두에 두세요. 위의 내용에서 A extends 1은 다음을 의미합니다:\n\nA의 연합 타입 멤버는 숫자 리터럴 1을 확장합니까?\n\n그리고 2가 1을 확장하지 않기 때문에, 답은 명백히 \"아니요\"입니다.\n\n우리는 연합 분배를 필요로 합니다. 연합 타입에서 1을 제거하기 위해 다음 예제에서 그렇게 했습니다:\n\n\n\n```js\ntype IsNotOne<T> = T extends 1 ? never : T;\n\ntype AWithout1 = IsNotOne<A>;\n// type AWithout1 = 2 | 3\n```\n\n조건부 타입에 A를 전달하면, T extends 1 조건은 다음을 의미합니다:\n\n현재 평가 중인 유니온 멤버가 숫자 리터럴 1을 확장하는가?\n\n계산의 결과는 never | 2 | 3이지만, never는 TypeScript의 타입 유니언에서 중립적인 요소입니다. 만약 대수를 공부한 적이 있다면, 지금이 그것이 도움이 될 때입니다.\n\n\n\n회원 배포에 대해 더 알고 싶다면 다른 이야기를 읽어보세요:\n\n오버로드된 함수 유형이 연합임을 확신하고 문제를 해결할 수 있다고 믿고 유형을 분배하는 데 시간을 투자했습니다.\n\n그리고 나는 그것이 연합이 아니었다는 것을 깨달았어요!\n\n![이미지](/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_1.png)\n\n\n\n# 재미없는 코딩\n\n그 날 TypeScript에 대해 새로운 것을 배웠어요. 오버로드된 함수 타입이 어떻게 작동하는지 이해하고 싶어서 더 깊이 파고들었죠.\n\n첫 번째 위대한 발견은 추론을 실험해볼 때였어요. 함수 타입이 어떻게 작성되었는지 한 글자 한 글자 따라 해보았더니, 아래 코드를 만들어냈어요:\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n    (event: 'eventB'): void;\n    (event: 'eventC'): void;\n    // ...\n    (event: 'eventZ'): void;\n}\n\ntype FirstParameter<T> = T extends {\n    (arg: infer A, ...args: never): any;\n    (arg: infer B, ...args: never): any;\n  }\n    ? A | B \n    : never;\n\ntype NotEventType = FirstParameter<OverloadedFunction>;\n// type NotEventType = \"eventC\" | \"eventZ\"\n```\n\n\n\n아주 원시적인 해결책을 찾았어요. 하지만 해결책이란 게 있었어요. 'FirstParameter`T`' 형식 뒤에 코드를 생성할 수 있었죠. 다만, 이벤트 종류의 수가 변경되면 형식의 정확성을 잃을 것 같았어요.\n\n또한, 얼마나 많은 추론 매개변수를 필요로 하시나요?\n\n이 해결책을 오버로드의 수를 모르는 다른 함수에 재사용할 수 있을까요? 저는 하나의 오버로드와 두 가지 추론으로 테스트를 시작했어요. 결과를 보고는 당황했지만요.\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n}\n\ntype FirstParameter<T> = T extends {\n    (arg: infer A, ...args: never): any;\n    (arg: infer B, ...args: never): any;\n  }\n    ? A\n    : never;\n\ntype NotEventType = FirstParameter<OverloadedFunction>;\n// type NotEventType = \"eventA\"\n```\n\n\n\nFirstParameter`T`의 반환 유형은 A이므로 NotEventType은 이벤트A입니다. 그러나 B를 반환하면 NotEventType은 동일합니다! 더 실험해본 결과, 함수 오버로드에 대한 추론보다 더 많은 추론이 있는 경우, 전자는 항상 적절한 유형을 포함한다는 결론을 내렸습니다.\n\n추론은 항상 아래에서 시작되며 다음 예시에서 명확히 나타납니다.\n\n```js\ntype OverloadedFunction = {\n    (event: 'eventA'): void;\n    (event: 'eventB'): void;\n}\n\ntype FirstParameter<T> = T extends {\n    (arg: infer A, ...args: never): any;\n    (arg: infer B, ...args: never): any;\n    (arg: infer C, ...args: never): any;\n    (arg: infer D, ...args: never): any;\n  }\n    ? A\n    : never;\n\ntype NotEventType = FirstParameter<OverloadedFunction>;\n```\n\n여기서 D만 `eventB`를 포함하고 A, B, C는 `eventA`를 가리킨다는 것을 알 수 있습니다.\n\n\n\n# 연구\n\n결국, 나는 인터넷을 통해 나만의 연구를 진행했습니다. 다른 사람들과 같은 해결책에 도달한 것으로 밝혀졌습니다. TypeScript의 한계에 도달한 것으로 보입니다.\n\n믿기 어려워서 TypeScript AST 뷰어를 실행시키고 오버로드가 있는 함수를 전달했습니다. 그 결과로 다음과 같은 추상 구문 트리를 반환받았습니다.\n\n![이미지](/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_2.png)\n\n\n\nAST가 올바르게 보였기 때문에 TS 컴파일러가 함수 오버로드 내에서 특정 추론을 지원하지 않았다고 가정했습니다.\n\n# 해결책\n\n모든 소프트웨어 개발자는 어떤 문제에 대해 여러 해결책을 찾아야 한다고 믿습니다. 제 경우, 아이디어를 아래에 나열했습니다. 노력이 필요한 양에 따라 순서를 매겼고, 각각에 대해 장단점이 있습니다.\n\n## 문자열로서 이벤트 종류를 입력하기\n\n\n\n모든 이벤트 종류는 문자열입니다. 하지만 그 역은 성립하지 않습니다. 이 해결책을 선택하면 유형 안정성을 희생하고 지능적인 코드 복잡성을 잃을 것이라고 판단했습니다. 다른 한편으로는 유형 확인을 충족시키기 위해 추가 리소스를 소비할 필요가 없을 것입니다.\n\n적절한 테스트를 추가하면 이 해결책이 더욱 유효함을 입증할 것입니다.\n\n맞습니다, 이것을 선택했습니다.\n\n## 타입 추론을 사용하기\n\n\n\n이 이야기에 언급된 대로, 이벤트 종류를 추론하기 위한 타입 별칭을 생성할 수 있습니다. 이러한 타입 별칭은 이벤트 종류가 변경될 때 다시 생성해야 합니다. 긍정적인 면으로는 라이브러리를 포크하거나 대체할 필요가 없다는 것입니다.\n\n## 타입 생성하기\n\n사용 가능한 타입 정의로부터 이벤트 종류를 추출하는 스크립트를 작성할 수 있습니다. 타입 추론과 마찬가지로 라이브러리를 업데이트할 때마다 스크립트를 실행해야 합니다. 다시 말해서, 이 종속성은 프로젝트에 유지됩니다.\n\n## 라이브러리 포크하기\n\n\n\n그들을 이기지 못하면 함께 하라.\n\n이 속담은 소프트웨어 개발에서도 의미가 있어요. 특정 라이선스가 있는 오픈 소스 라이브러리를 포크하고 그에 맞게 변경할 수 있습니다. 저의 경우에는 모든 이벤트 종류를 유형 리터럴 열거형으로 수집하여 내보낼 거예요.\n\n정기적으로 라이브러리의 새로운 버전이 있는지 확인하고 포크를 업데이트해야 해요.\n\n다소 부드러운 대안은 라이브러리 유지 관리자와 변경 사항을 논의하는 것이에요.\n\n\n\n## 라이브러리 변경하기\n\n가끔은 다른 라이브러리로 변경하는 것이 합리적으로 들릴 수 있습니다. 적합한 TypeScript 지원이 없다면 그것이 당신이 다루기를 원하는 마지막 짚널이 될 수도 있습니다. 상업 프로젝트의 경우, 그러한 급격한 변화는 이해관계자들과 진지한 토론이 필요할 수 있습니다.\n\n# 요약\n\n프로그래밍 언어를 사용하여 현실을 모델링합니다. 모델은 정의상 불완전합니다. 컴파일러 팀이 더 중요한 기능에 집중하고 있기 때문에 어떤 패턴에 대한 지원이 부족할 수 있습니다. 우리는 언어의 기능을 이해하고 적절히 활용해야 합니다.\n\n\n\n이것은 우리가 항상 기술을 지속적으로 개선해 나가야 한다는 것을 의미합니다. 시간이 지남에 따라 컴파일러가 개선되어 더 많은 패턴을 수용할 수 있게 됩니다. 예를 들어, TypeScript 4.9 버전이 나오기 전까지 변수가 두 가지 유형과 일치하도록 할 수 없었습니다.\n\n제 이야기를 읽어 주셔서 감사합니다!\n\nTypeScript로 고생하시는 것에 지쳤나요? 이 글을 읽어보세요:","ogImage":{"url":"/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-TheCuriousCaseofTypeInferenceinTypeScript_0.png","tag":["Tech"],"readingTime":7},{"title":"마이크로 프론트엔드 마스터하기 수직 대 수평 아키텍쳐 공개","description":"","date":"2024-05-14 14:27","slug":"2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled","content":"\n\n\n![이미지](/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png)\n\n마이크로 프론트엔드는 현대 웹 개발에서 강력한 아키텍처 패턴으로 등장했습니다. 이는 팀이 거대한 프론트엔드 응용 프로그램을 더 작고 관리하기 쉬운 조각으로 나눌 수 있도록 합니다. 마이크로 프론트엔드 아키텍처에서 중요한 결정 중 하나는 수직 또는 수평 구성에 관한 선택입니다. 이러한 구성은 개별 프론트엔드 모듈이 구조화되고 전체 응용 프로그램에 통합되는 방식을 결정합니다. 이 기사에서는 수직 및 수평 마이크로 프론트엔드 아키텍처 간의 차이를 탐구하고 클라이언트 측, 엣지 및 서버 측과 같은 여러 구성 전술 및 각각의 장단점 및 실제 응용 프로그램을 살펴봅니다.\n\n# 수직형 마이크로 프론트엔드 아키텍처:\n\n![이미지](/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_1.png)\n\n\n\n\n수직 마이크로프런트엔드 아키텍처에서 각 모듈은 특정 수직 단위의 기능을 담당하며, 특정 기능이나 사용자 이동을 제공하기 위해 필요한 프론트엔드와 백엔드 구성 요소를 모두 포괄합니다. 수직 마이크로프런트엔드와 관련된 구성에 대해 자세히 살펴봅시다:\n\n클라이언트 측 구성에서 모듈은 독립적으로 개발 및 배포되며, 최종 구성은 사용자의 브라우저 내에서 발생합니다. JavaScript 오케스트레이터인 single-spa 또는 Webpack Module Federation과 같은 도구를 사용하여 런타임에서 모듈을 동적으로 로드하고 통합하는 것이 일반적입니다.\n\n장점:\n\n- 격리성: 각 모듈은 독립적으로 작동하여 한 모듈의 실패가 다른 모듈에 영향을 미치는 위험을 최소화합니다.\n- 유연성: 팀이 독립적으로 모듈을 개발하고 배포할 수 있어 빠른 이터레이션 및 릴리스 주기를 용이하게 합니다.\n- 확장성: 동일 모듈의 인스턴스를 추가함으로써 수평적으로 손쉽게 확장할 수 있습니다.\n\n\n\n단점:\n\n- 성능 오버헤드: 동적 모듈 로딩으로 인한 초기 로드 시간 증가 및 런타임 오버헤드 가능성.\n- 복잡성: 모듈 로딩, 라우팅 및 통신 처리를 위한 견고한 조율 메커니즘 필요.\n\n실제 사례 시나리오: 각 모듈이 구체적인 쇼핑 기능을 나타내는 전자 상거래 플랫폼(예: 제품 목록, 장바구니 관리, 결제 과정).\n\nEdge 구성은 중앙 게이트웨이 또는 Edge 서버를 통해 요청을 경유하며, 요청된 URL에 기반하여 프론트엔드 모듈을 동적으로 조합합니다. Edge 서버는 서버리스 함수나 리버스 프록시를 사용하여 구성된 애플리케이션을 사용자에게 제공할 수 있습니다.\n\n\n\n장점:\n\n- 효율성: 구성이 네트워크 가장자리에서 발생하기 때문에 클라이언트 측 부하가 줄어듭니다.\n- 보안: 요청의 중앙화된 처리로 통합 보안 정책과 접근 제어가 가능합니다.\n- 성능: 가장자리에서 개선된 캐싱 및 콘텐츠 전달 최적화가 이루어집니다.\n\n단점:\n\n- 복잡한 배포: 글로벌 배포를 위해 가장자리 인프라를 설정하고 관리하는 것은 어려울 수 있습니다.\n- 한정된 동적성: 구성 논리 변경시 가장자리 서버 구성 업데이트가 필요할 수 있습니다.\n\n\n\n실제 사례 시나리오: 다양한 모듈이 콘텐츠 유형(예: 기사, 동영상, 이미지)을 나타내며 사용자 요청에 따라 조합되는 콘텐츠 관리 시스템입니다.\n\n# 수평 마이크로프론트엔드 아키텍처:\n\n![Horizontal Micro-Frontend Architecture](/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_2.png)\n\n수평 마이크로프론트엔드 아키텍처에서는 모듈이 공유된 기능 또는 구성 요소 주변에 정리되며 각 모듈이 전체 응용 프로그램에 특정 기능을 기여합니다. 수평 마이크로프론트엔드와 관련된 조합 전술을 살펴보겠습니다.\n\n\n\n수직 아키텍처와 유사하게, 수평 미크로 프론트엔드에서의 클라이언트 측 구성은 사용자의 브라우저 내에서 모듈을 동적으로 로드하고 통합하는 것을 의미합니다. 그러나 수평 아키텍처의 경우, 모듈은 주로 재사용 가능한 UI 구성 요소나 서비스를 제공하는 데 중점을 두며 완전한 기능을 제공하기보다는 집중적으로 활용됩니다.\n\n장점:\n\n- 재사용성: 공유 UI 구성 요소와 서비스는 일관성을 유지하고 모듈 간의 중복을 줄이는 데 도움이 됩니다.\n- 협업: 응용 프로그램의 다른 부분에 작업하는 팀 간의 협력을 촉진합니다.\n- 점진적 적용: 개별 구성 요소를 대체함으로써 단일체에서 미크로프론트엔드 아키텍처로 점진적인 이전이 가능합니다.\n\n단점:\n\n\n\n- 종속성 관리: 공유 종속성과 통신 프로토콜은 신중한 버전 및 호환성 관리가 필요합니다.\n- 조정 오버헤드: 모듈 간 일관된 UI/UX를 보장하는 것은 추가 조정 노력이 필요할 수 있습니다.\n\n실제 사례 시나리오: 대시보드 애플리케이션에서 모듈이 다른 데이터 시각화 구성 요소(예: 차트, 표, 지도)를 나타내며 여러 페이지나 뷰에서 공유됩니다.\n\n서버 측 구성에서는 백엔드 서버가 클라이언트로 전송하기 전에 모듈의 출력을 결합한 최종 HTML 마크업을 집계하고 렌더링하는 역할을 합니다. 이 접근 방식은 종종 Next.js나 Nuxt.js와 같은 서버 측 렌더링(SSR) 프레임워크와 함께 사용됩니다.\n\n장점:\n\n\n\n**장점:**\n\n- 성능: 초기 페이지 로드 시간을 서버에서 조합된 HTML을 렌더링하여 최적화할 수 있습니다.\n- SEO: 서버 렌더링된 콘텐츠는 검색 엔진에 더 쉽게 색인되어 발견성을 향상시킵니다.\n- 점진적인 향상: 제한된 JavaScript 기능을 갖는 클라이언트에 대해 우아한 저하를 가능하게 합니다.\n\n**단점:**\n\n- 서버 부하: 복잡한 조합을 위한 서버 측 처리와 렌더링 부하가 증가합니다.\n- 강한 결합: 백엔드 서버가 조합 로직과 데이터 집계를 위한 단일 장애 지점이 됩니다.\n\n**실제 사례 시나리오:**\n\n- 모놀리식 전자 상거래 앱이 마이크로 프론트엔드로 변형되어 각 마이크로 애플리케이션이 독립적인 개발, 저장소, 배포를 필요로 하며 최소한의 의존성이나 제로 의존성이 필요한 것입니다. (예: 헤더, 푸터, 필터, 제품 목록 등)\n\n\n\n# 결론:\n\n수직 및 수평 미크로프론트엔드 아키텍처 사이를 선택하거나 적절한 구성 전술을 선택하는 것은 프로젝트 요구 사항, 팀 구조, 확장 가능성 요구 사항 및 성능 고려 사항과 같은 여러 요소에 의존합니다. 각 접근 방식의 장단점 및 실제 응용 프로그램을 이해함으로써, 개발 팀은 특정 사용 사례 및 목표와 일치하는 정보에 기반한 결정을 내릴 수 있으며, 웹 개발의 계속 변화하는 환경에서 확장 가능하고 모듈식이며 유지 보수 가능한 프론트엔드 응용 프로그램을 위한 길을 열 수 있습니다.\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나기 전에:\n\n\n\n- 작가를 응원하고 팔로우해 주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루게 만드는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png","tag":["Tech"],"readingTime":4},{"title":"2024년에 Nodejs로 CLI 애플리케이션 만들기","description":"","date":"2024-05-14 14:25","slug":"2024-05-14-BuildingaCLIAppwithNodejsin2024","content":"\n\n## Node.js로 CLI 앱을 만드는 과정을 자세히 안내하는 스텝바이스텝 가이드입니다. 명령 처리와 사용자 프롬프트부터 사용자 경험 향상, 프로젝트 구조 정리 및 문서화에 이르기까지 모든 것을 다루고 있습니다.\n\n![CLI App with Node.js](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png)\n\n## 왜 Node.js를 사용해야 하는가?\n\n이벤트 기반 아키텍처와 이를 위해 특별히 설계된 많은 패키지를 제공하는 npm 생태계로 인해 효율적이고 확장 가능한 CLI 도구를 개발하는 데 가장 적합한 선택지가 됩니다.\n\n\n\n## CLI 앱을 만드는 이유는?\n\n- 작업 자동화\n- 개발자를 위한 도구 만들기\n- 시스템과 흐름 관리와 상호작용\n\n## 실제 예시\n\nNielsen에서는 많은 가치를 제공하는 여러 CLI를 만들었습니다.\n\n\n\n- CI/CD 플로우에서 동적 파이프라인을 관리하는 CLI — 더 이상 수동 구성이나 프로세스 간 대기가 필요하지 않아요.\n- 로컬 도커 환경을 설정하고 관리하는 CLI.\n- 마이그레이션을 위한 미리 정의된 단계를 실행하는 CLI.\n\n이제 한 개 만드는 것이 얼마나 쉬운지 알게 될 거예요.\n바로 코드로 빠져들기를 원하시는 분들을 위해, 파일은 여기서 찾을 수 있어요.\n\n# 목차\n\n- 설정하기\n∘ 프로젝트 부트스트랩\n∘ Commander.js 가져오기\n∘ CLI 만들기\n- 유저 경험\n∘ 색상 추가하기\n∘ 쉬운 프롬프팅\n∘ 멋진 로더\n∘ ASCII 아트 추가하기\n- 프로젝트 구조\n- 문서화\n∘ 자동 문서 생성\n- 최선의 실천법\n\n\n\n# 설정하기\n\n먼저 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요.\n\n## 단계 1: 프로젝트 시작하기\n\n프로젝트를 위한 새 폴더를 만들고 그 안으로 들어가세요:\n\n\n\n```js\nmkdir my-node-cli\ncd my-node-cli\n```\n\n새 Node.js 프로젝트를 시작해보세요:\n\n```js\nnpm init\n```\n\n## 단계 2: Commander.js 가져오기\n\n\n\nCommander.js은 Node.js에서 CLI를 구축하는 데 사용하는 핵심 도구입니다. 입력 구문 분석, 도움말 텍스트 및 오류 관리를 위한 스위스 아미 나이프가 있는 것과 같습니다.\n\n```js\nnpm install commander\n```\n\n## 단계 3: CLI 만들기\n\n프로젝트 폴더에 index.js라는 파일을 만듭니다. 이것이 우리의 CLI가 시작하는 곳이 될 것입니다. 이 CLI를 실행하기 위해 맨 위에 shebang을 추가하십시오.\n\n\n\n\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\n\nprogram\n  .version(\"1.0.0\")\n  .description(\"내 노드 CLI\")\n  .option(\"-n, --name <type>\", \"당신의 이름을 추가하세요\")\n  .action((options) => {\n    console.log(`안녕, ${options.name}!`);\n  });\n\nprogram.parse(process.argv);\n\n\n패키지.json에 bin을 추가하여 CLI 명령을 인식하도록하고 CommonJS 대신 ES 모듈과 함께 작동하도록 유형을 추가하십시오:\n\n```js\n\"bin\": {\n    \"my-node-cli\": \"./index.js\"\n},\n\"type\": \"module\"\n```\n\n프로젝트를 전역적으로 연결하려면:\n```bash\nnpm link\n```\n\n\n\n```js\nnpm link \n```\n\n그러면, 내 my-node-cli가 당신의 터미널에서 실행될 준비가 끝납니다!\n\n```js\nmy-node-cli --name YourName\n```\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_1.png)\n\n\n\n참고: Node.js 18.3부터는 내장된 커맨드 라인 인수 구문 분석기가 있습니다. 이것에 대해 읽어보고 commander.js 대신 사용할지 결정할 수 있습니다.\n\n# 사용자 경험\n\n## 색상 추가하기\n\nChalk는 CLI 출력을 다채롭게 만드는 데 완벽합니다. 다음 명령을 사용하여 가져올 수 있습니다:\n\n\n\n```js\nnpm install chalk\n```\n\n이제 우리의 인사말을 개선해 보겠습니다:\n\n```js\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\nimport chalk from \"chalk\";\n\nprogram\n  .version(\"1.0.0\")\n  .description(\"내 Node CLI\")\n  .option(\"-n, --name <type>\", \"당신의 이름을 추가하세요\")\n  .action((options) => {\n    console.log(chalk.blue(`안녕, ${options.name}!`));\n    console.log(chalk.green(`안녕, ${options.name}!`));\n    console.log(chalk.red(`안녕, ${options.name}!`));\n  });\n\nprogram.parse(process.argv);\n```\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_2.png)\n\n\n\n## 손쉬운 프롬프팅\n\n더욱 상호작용적인 느낌을 원하신다면 Inquirer.js가 좋은 선택입니다.\n\n```js\nnpm install inquirer\n```\n\n데이터를 수집하기 위해 명령줄 옵션을 사용하는 대신, 사용자에게 질문하세요.\n\n\n\n```js\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\nimport chalk from \"chalk\";\nimport inquirer from \"inquirer\";\n\nprogram.version(\"1.0.0\").description(\"나의 Node CLI\");\n\nprogram.action(() => {\n  inquirer\n    .prompt([\n      {\n        type: \"input\",\n        name: \"name\",\n        message: \"당신의 이름은 무엇인가요?\",\n      },\n    ])\n    .then((answers) => {\n      console.log(chalk.green(`안녕하세요, ${answers.name}님!`));\n    });\n});\n\nprogram.parse(process.argv);\n```\n\n![Building a CLI App with Node.js](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_3.png)\n\n사용 가능한 Confirm 프롬프트 유형이 있습니다. 사용자에게 예/아니오 질문을 합니다.\n\n![Building a CLI App with Node.js](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_4.png)\n\n\n\n\n프롬프트 유형 — 사용자가 옵션 목록에서 선택할 수 있도록 합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_5.png)\n\n또한 체크박스, 비밀번호, 목록 및 확장 기능도 있습니다. https://github.com/SBoudrias/Inquirer.js에서 더 많이 알아보세요.\n\n## 멋진 로더들\n\n\n\n로딩 시간을 어떻게 보내시나요? ora를 사용하면 재미있게 만들 수 있어요. 스피너 애니메이션을 추가하는 데 좋아요:\n\n```js\nnpm install ora\n```\n\n시간이 걸리는 프로세스에 로더를 뿌려보세요:\n\n```js\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\nimport chalk from \"chalk\";\nimport inquirer from \"inquirer\";\nimport ora from \"ora\";\n\nprogram.version(\"1.0.0\").description(\"My Node CLI\");\n\nprogram.action(() => {\n  inquirer\n    .prompt([\n      {\n        type: \"list\",\n        name: \"choice\",\n        message: \"옵션을 선택하세요:\",\n        choices: [\"옵션 1\", \"옵션 2\", \"옵션 3\"],\n      },\n    ])\n    .then((result) => {\n      const spinner = ora(`${result.choice} 작업 중...`).start(); // 스피너 시작\n\n      setTimeout(() => {\n        spinner.succeed(chalk.green(\"완료!\"));\n      }, 3000);\n    });\n});\n\nprogram.parse(process.argv);\n```\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*wFmspYHAW5572fRutff1MQ.gif\" />\n\n## ASCII Art 추가\n\nfiglet.js로 마지막 손질을 해봅시다:\n\n```js\nnpm install figlet\n```\n\n\n\nindex.js에 다음을 추가해주세요.\n\n```js\nimport figlet from \"figlet\";\n\nconsole.log(\n  chalk.yellow(figlet.textSync(\"My Node CLI\", { horizontalLayout: \"full\" }))\n);\n```\n\n<img src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_6.png\" />\n\nCLI의 aesthetic에 맞게 ASCII 아트를 맞춤화할 수 있는 다양한 글꼴 및 사용자 정의 옵션이 있습니다.\n\n\n\n# 프로젝트 구조\n\n프로젝트를 깔끔하게 유지하면 나중에 시간을 아낄 수 있어요, 특히 프로젝트가 커지면 더욱 그렇습니다. 다음은 시작하기에 좋은 간단하면서도 효과적인 구조입니다:\n\n```js\nmy-node-cli/\n├─ bin/\n│ └─ index.js\n├─ src/\n│ ├─ commands/\n│ ├─ utils/\n│ └─ lib/\n├─ package.json\n└─ README.md\n```\n\n- bin — 여러분의 CLI가 있는 곳입니다. 누군가가 CLI를 실행할 때 호출되는 곳입니다.\n- src/commands — 개별 명령어 파일이 있는 위치입니다. 새로운 명령어를 추가하거나 기존 명령어를 편집할 때 더 깔끔하게 작업할 수 있습니다.\n- src/utils — 여러 명령어에서 필요한 유틸리티 함수를 담고 있습니다. 데이터 형식 설정과 같은 기능이 포함될 수 있습니다.\n- src/lib — 여러분의 CLI가 API와 상호 작용하거나 복잡한 로직을 실행하는 경우 주요 기능이 위치할 수 있습니다.\n\n\n\n# 문서화\n\n명확한 문서화가 중요합니다. 사용자를 명령줄 도구를 통해 직접 놀라운 작업을 수행할 수 있도록 설치, 사용법 및 명령 옵션을 README.md에 개요로 기록하십시오.\n\n```js\n# 내 노드 CLI\n내 노드 CLI는 터미널에서 직접 멋진 작업을 수행할 수 있는 도구입니다.\n\n## 설치\n\nnpm install -g my-node-cli\n\n## 사용법\n내 노드 CLI를 사용하려면 다음을 실행하십시오:\n\nmy-node-cli - help\n\n### 명령어\n- `my-node-cli - name YourName`: 당신의 이름으로 인사합니다.\n- `my-node-cli option1`: 옵션 1을 실행합니다.\n\n더 자세한 명령어 정보는 `my-node-cli --help`를 실행해 주세요.\n\n## 기여하기\n기여는 환영합니다...\n\n## 라이선스\n이 프로젝트는 라이선스가 부여되었습니다...\n \n\n## 문서 자동 생성하기\n\n\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n/**\n * 이 함수는 사용자의 이름으로 인사합니다.\n * @param {string} name 사용자의 이름\n */\nconst greet = (name) => {\n  console.log(`안녕, ${name}!`);\n};\n\n# Best Practices\n\n실제 CLI 논리 작업을 시작하기 전에 Liran Tal의 이 리포를 확인하는 것을 강력히 권장합니다. 이 리포는 3천 개 이상의 스타를 받았으며 제가 생각한 모든 최상의 실천 방법과 그 이상을 다룹니다.\n\n\n\n예를 들어, 사용자가 호출할 때 동일한 정보를 반복해서 제공하는 것을 요구하지 않고, 상태를 유지하면서 사용자 경험을 제공할 수 있습니다. conf를 사용하여 사용자 이름, 이메일 또는 API 토큰과 같은 데이터를 저장할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_7.png)\n\n이 모든 것이 실제로 작동하는 것을 보고 싶나요? 모든 예시 파일과 함께 완성된 프로젝트를 제 GitHub 페이지에서 확인해보세요. 들어가서 둘러보고, 자유롭게 실험해보세요. 만약 도움이 된다면 리포지토리를 fork하거나 스타를 눌러주세요!","ogImage":{"url":"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png","tag":["Tech"],"readingTime":7},{"title":"웹지엘WebGL로 애니메이션된 물 효과 구현하기 반사와 굴절 추가하기","description":"","date":"2024-05-14 14:23","slug":"2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL","content":"\n\n![워터 이미지](/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png)\n\n물은 컴퓨터 그래픽에서 렌더링하기 가장 어려운 부분 중 하나이면서 동시에 가장 보상이 큰 요소 중 하나입니다, 특히 실시간으로 처리할 때입니다. 잘 보이는 물은 시각적으로 매력적이며 나는 항상 현실적인 물을 렌더링하는 도전에 매혹을 느꼈습니다. 그래서 나는 지난 몇 주간 WebGL 엔진에 물을 추가해 보았습니다. 이 게시물에서는 WebGL에서 물을 렌더링하는 데 사용할 수 있는 다양한 기술과 제가 구현한 것에 대해 알아보겠습니다.\n\n# 기본 물\n\n실시간 그래픽에서 물을 렌더링하는 여러 가지 방법이 있습니다. 장면의 모양에 따라 쉬울 수도, 매우 복잡할 수도 있습니다. 아마 가장 간단한 방법은 큰 파란색 사각형을 그리는 것입니다. 이것만으로도 Minecraft 환경과 같은 것에 충분할 수도 있습니다.\n\n\n\n파란색 쿼드에서 발전하는 다음 단계는 원활한 애니메이션된 물 질감을 추가하고 루프를 돌아야 할 것입니다. 그러나 평면 물은 별로 흥미로워 보이지 않기 때문에 파도를 추가하는 것이 좋을 것 같습니다. 첫 번째 옵션은 쿼드를 훨씬 작은 쿼드 그리드로 세분화한 다음 버텍스의 y 위치를 버텍스 셰이더에서 애니메이션하는 것입니다. 이 접근 방식은 실제로 물 표면의 고도가 변경된다는 장점이 있습니다. 그러나 이러한 방법의 단점은 물의 크기와 규모에 따라 좋아 보이려면 많은 버텍스가 필요할 수 있다는 것입니다.\n\n두 번째 옵션은 보통 선호하는 방법이라고 할 수 있는데, 노멀 맵으로 파도를 추가하는 것입니다. 이로 인해 물의 고도는 실제로 변경되지 않고 항상 완벽히 평평합니다. 노멀 맵은 표면과 빛이 상호 작용하는 방식을 변경하기 때문에 파도가 있는 것처럼 보입니다. 노멀은 프래그먼트 수준에서 계산되고 애니메이션되며, 이는 성능에 미치는 영향이 최소화되면서 작은 파도를 쉽게 추가할 수 있다는 것을 의미합니다.\n\n과거에는 사인스 패턴이나 인터넷에서 가져온 물 질감 및 노멀 맵을 사용했었는데, 이는 학습과 테스트에는 적합한 방법이었습니다. 그러나 (유감스럽게도 아직 출시되지 않은) 독립 개발 게임을 작업할 때는 인터넷에서 무작위 텍스처를 사용할 수 없었습니다. 대신에 나는 연속 애니메이션된 물 질감과 노멀 맵을 만들기 위한 절차적 알고리즘을 만들었습니다. 이러한 질감을 만들기 위한 꼼수는 주기적 3D Perlin 잡음입니다. 주기적 3D 잡음은 3D 공간을 완벽하게 타일링하는 3D 쿠브로 상상할 수 있으며 쿠브의 모든 면이 이웃과 일치합니다. 그런 다음 Perlin 잡음의 값들을 물의 고도로 사용하여 메시를 만들고 노멀을 계산한 다음, RGB 값으로 인코딩하게 됩니다. 비슷하게 몇 가지 다른 푸른색을 섞어 색 질감을 만들 수 있습니다. 지금까지는 C++에서만 이를 구현했으며 JavaScript 및 WebGL의 이미지만 사용하고 있습니다. 그러나 이러한 텍스처는 상당히 크기 때문에 WebGL에서는 제한된 인터넷 속도 문제로 인해 훨씬 큰 문제가 됩니다. 앞으로는 이 접근 방식을 JavaScript로 변환하고 대용량 텍스처의 평균 다운로드 속도보다 더 빠르게 생성할 수 있는지 시도해 볼 수도 있을 것입니다.\n\n# 반사 및 굴절\n\n\n\n물의 가장 상징적인 측면 중 하나는 그 반사입니다: 고요한 빙하 호수에 산과 나무가 반영되는 모습, 해질녘의 색감이 바다에 반사되는 모습, 혹은 지역 연못에 당신의 반영. 반영은 정말 멋집니다. 하지만 광선 추적 없이 반사를 어떻게 렌더링할까요? 임의의 반사는 WebGL과 같은 래스터화 API로는 매우 어려우며, 레이 트레이싱 기술의 가장 큰 이점인 그림자와 함께 구현은 더욱 어렵습니다. 가장 좋은 선택은 사전에 빠져 나온 반사 큐브맵인데, 이는 플레이어 캐릭터와 같은 동적 실시간 객체를 반사할 수 없습니다.\n\n그러나 큰 물 표면은 행운의 예외입니다. 생각해 보면, 물체의 반사는 마치 수면 아래서 보는 듯한 것이다.\n\n![image](/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_1.png)\n\n이는 단순히 카메라를 물 표면에 반사시키고 새로운 카메라 위치에서 장면을 텍스처로 렌더링하는 것을 의미합니다. 물 표면 아래의 모든 것은 어차피 반사될 수 없기 때문에 제거됩니다. 같은 트릭은 굴절에도 작동합니다. 장면은 일반 카메라 위치에서 또 다른 텍스처로 렌더링되며, 물 표면 위의 모든 것이 잘립니다.\n\n\n\n하지만, 이는 추가적인 렌더링 패스 두 개를 추가합니다. 낮은 해상도와 더 적은 세부 정보로 렌더링할 수 있지만, 장면의 복잡성에 따라 프레임 시간에 상당한 시간을 추가할 수 있습니다.\n\n물 표면이 그려질 때, 보통 맵을 사용하여 반사와 굴절을 왜곡시킬 수 있어 물결에도 영향을 받게 만들 수 있습니다.\n\n# 구현\n\n일반 맵 파도나 반사를 위해 카메라를 반사하는 것과 같은 물 관련 트릭은 그 자체로 복잡하지 않습니다. 그러나 잘 보이는 물을 얻기 위해서는 많은 작은 효과가 필요하며, 이러한 조합은 더 복잡해질 수 있습니다. 물이 잘 보이기 시작하려면 최소한 일련의 조작해야할 다양한 매개변수가 있습니다. 하나의 값이 너무 많이 벗어나면 상당히 나쁘게 보일 수 있습니다. 그러나 이것을 이용할 수도 있습니다. 몇 가지 매개변수를 이상한 값으로 설정하면 여전히 파란 물 텍스처를 사용하여 라바를 꽤 잘 보이게 만들 수도 있었습니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_2.png\" />\n\n내 WebGL 물 구현은 그것이 기반으로하는 OpenGL 버전과 비교해서 큰 향상을 이루었습니다. 물을 사용하고 싶을 때, 물 개체를 만들고 반사 및 굴절할 모든 개체를 추가하기만 하면 됩니다. 복잡한 쉐이더 전환, 유니폼, 카메라 반사 등은 내부적으로 처리됩니다. 이것이 지난 리팩터링 블로그 글에서 이야기한 쉐이더 모듈과 행렬 슬롯이 필요한 이유 중 하나였습니다. 외부에서 물 클래스를 사용하는 것은 매우 깨끗하고 간단하지만, 엔진 내부 코드는 여전히 복잡성을 줄이고 앞으로 유지보수 가능하도록 개선할 필요가 있습니다.\n\n```js\nvar water = new Sparrow.Water( engine , { /* 물 옵션 */ } );\nwater.addObject( cube );\nwater.addObject( model );\n```\n\nWebGL이나 다른 그래픽 API에서 물을 렌더링하는 것은 매우 간단한 경우부터 매우 복잡한 경우까지 다양한데, 이를 수행하는 여러 가지 방법과 맞춰야 할 많은 세부 사항이 있기 때문입니다. 그러나 이 포스트가 무엇이 필요한지에 대한 좋은 아이디어를 제공했으면 좋겠습니다. 현재 물 구현의 상태에 만족하고 있지만, 미래에 다양한 시나리오에 대해 더 맞춤화할 수 있도록 추가적인 컨트롤을 추가하고 싶습니다.\n\n\n\n원문: https://pingpoli.de.","ogImage":{"url":"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png","tag":["Tech"],"readingTime":4},{"title":"네스트JS에서 인증 구현하는 방법에 대한 상세 가이드","description":"","date":"2024-05-14 14:21","slug":"2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS","content":"\n\n이 포괄적인 안내서는 강력한 Node.js 프레임워크인 NestJS에서 인증 구현에 대한 단계별 안내를 제공합니다. 기본 개념, 최선의 실천법 및 실전 예제를 다루며, 이 안내서는 NestJS 애플리케이션을 위한 견고한 인증 시스템을 구축하기 위한 지식을 개발자들에게 제공하는 것을 목표로 합니다.\n\n![이미지](/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png)\n\n인증은 많은 애플리케이션의 기능성에서 중요한 구성 요소로 자리 잡고 있습니다. 인증 관리는 특정 프로젝트의 특정 요구 사항에 맞게 맞춘 각기 다른 접근 방식과 전략을 탐색하는 과정을 포함합니다. 이 섹션에서는 여러 인증 접근 방식을 개요하여 다양한 응용프로그램의 명백한 요구 사항을 충족시킬 수 있는 사용자 정의 옵션을 설명합니다.\n\n특정 시나리오에서 클라이언트는 사용자 이름과 비밀번호로 인증하여 프로세스를 시작합니다. 성공적인 인증 후에 서버는 JWT(JSON Web Token)를 생성하고, 이를 인증 확인을 위한 후속 요청의 권한 부여 헤더로 전송할 수 있는 베어러 토큰으로 전송합니다. 더불어, 유효한 JWT가 포함된 요청에서만 접근 가능한 안전한 경로를 설정할 것입니다.\n\n\n\n# 스텝 바이 스텝 가이드:\n\n진행은 초기 요구 사항으로 시작됩니다: 사용자 인증. 그 다음으로는 JWT를 생성하고 발급함으로써 이를 확장합니다. 마지막으로는 수신 요청 내의 유효한 JWT의 존재를 확인하는 보호된 라우트를 구축합니다.\n\n## 1. 종속성 설치\n\n```js\nnpm install @nestjs/jwt passport-jwt @types/passport-jwt\n```\n\n\n\n## 2. 인증 및 사용자 모듈 생성하기\n\n```js\nnest g module auth\nnest g controller auth\nnest g service auth\n```\n\nAuthService를 구현할 때 유용하게 사용자 작업을 캡슐화하는 UsersService를 만드는 것이 좋습니다. 그러니 바로 해당 모듈과 서비스를 생성합시다:\n\n```js\nnest g module users\nnest g service users\n```\n\n\n\n## 3. 사용자 DTO 구현\n\nData Transfer Object (DTO)는 응용 프로그램의 다른 부분 간에 네트워크를 통해 전송될 데이터를 정의하고 유효성 검사하는 데 사용되는 디자인 패턴입니다.\n\n```js\n// backend/src/dto/user/base-user.dto.ts\n```\n\n```js\nimport { ApiProperty } from '@nestjs/swagger';\nexport class BaseUser {\n  @ApiProperty()\n  id?: string;\n  @ApiProperty()\n  username?: string;\n  @ApiProperty()\n  email: string;\n  @ApiProperty()\n  password: string;\n  @ApiProperty()\n  confirmPassword?: string;\n  @ApiProperty()\n  designation?: string;\n}\n```\n\n\n\n```js\n// backend/src/dto/user/create-user.dto.ts\n```\n\n```js\nimport { BaseUser } from \"./base-user.dto\";\nexport class CreateUserDto extends BaseUser {\n  createdAt: Date;\n}\n```\n\n```js\n// backend/src/dto/user/update-user.dto.ts\n```\n\n```js\nimport { BaseUser } from \"./base-user.dto\";\nexport class UpdateUserDto extends BaseUser {\n  updatedAt: Date;\n}\n```\n\n\n\n## 4. 사용자 엔티티 구현\n\n엔티티란 TypeScript 클래스 또는 오브젝트를 가리키며 데이터베이스 테이블이나 문서의 모델을 나타냅니다. 엔티티는 TypeORM이나 Sequelize와 같은 ORM 라이브러리와 함께 사용되어 데이터베이스와 상호 작용합니다. 엔티티는 데이터 구조를 정의하며 주로 데이터베이스 테이블의 직접적인 표현입니다.\n\n```js\n// backend/src/entities/user.entity.ts\n```\n\n```js\nimport { Column, Entity, ObjectId, ObjectIdColumn } from 'typeorm';\n@Entity()\nexport class UserEntity {\n  @ObjectIdColumn()\n  id: ObjectId;\n  @Column()\n  username: string;\n  @Column()\n  email: string;\n  @Column()\n  password: string;\n  @Column()\n  createdAt: Date;\n  @Column()\n  updatedAt: Date;\n}\n```\n\n\n\n**사용자 클래스**는 **@Entity 데코레이터**로 표시되어 엔티티를 나타낸다는 것을 나타냅니다. 클래스 속성 (id, username, email, password, confirmPassword, createdAt, updatedAt)은 @PrimaryGeneratedColumn 및 @Column과 같은 데코레이터로 주석이 달려 있어 데이터베이스 스키마에서의 역할을 지정합니다.\n\n## 5. Auth Controller 구현\n\n이 NestJS 컨트롤러, **AuthController**,는 인증 관련 HTTP 요청을 처리합니다. 라우트 처리를 위해 데코레이터를 활용하고, 설명서를 위해 Swagger를 통합하며, 타입 확인을 위해 DTO를 사용합니다. **@Public 데코레이터**는 특정 엔드포인트가 인증을 요구하지 않는 것을 나타내며, **AuthService**는 실제 인증 로직을 담당합니다.\n\n```js\n// backend/src/modules/auth/auth.controller.ts\n```\n\n\n\n\n## 6. 인증 모듈 구현\n\n이 NestJS 모듈인 AuthModule은 컨트롤러, 서비스 및 가드를 포함한 인증 관련 컴포넌트를 캡슐화하고 조직화하기 위해 설계되었습니다. 전반적으로, AuthModule은 코드 조직화를 촉진하고 재사용성을 촉진하며 인증 관련 컴포넌트를 관리하는 중앙 모듈로 작용합니다. 가드, 서비스의 사용 및 JwtModule 및 TypeOrmModule과 같은 외부 모듈의 구성은 NestJS에서 모듈화되고 확장 가능한 애플리케이션 아키텍처에 가장 적합한 방법을 따릅니다.\n\n```js\n// backend/src/modules/auth/auth.module.ts\n```\n\n\n\n```js\nimport { Module } from '@nestjs/common';\nimport { AuthController } from './auth.controller';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\nimport { JwtModule } from '@nestjs/jwt';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserEntity } from 'src/entities/user.entity';\nimport { jwtConstants } from './constants';\nimport { APP_GUARD } from '@nestjs/core';\nimport { AuthGuard } from './auth.guard';\n@Module({\n  imports: [\n    UsersModule,\n    JwtModule.register({\n      global: true,\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '1d' },\n    }),\n    TypeOrmModule.forFeature([UserEntity]),\n  ],\n  controllers: [AuthController],\n  providers: [\n    {\n      provide: APP_GUARD,\n      useClass: AuthGuard,\n    },\n    AuthService\n  ],\n  exports: [AuthService]\n})\nexport class AuthModule {}\n```\n\n- JwtModule: JwtModule을 구성하고 가져와서 JSON Web Tokens (JWT)을 다루는 데 사용되며 비밀 및 만료 시간과 같은 지정된 옵션을 제공합니다.\n- TypeOrmModule.forFeature([UserEntity]): TypeORM을 구성하여 모듈 내에서 UserEntity를 제공하도록 설정합니다.\n- 'provide: APP_GUARD, useClass: AuthGuard': APP_GUARD 토큰을 사용하여 AuthGuard를 글로벌 가드로 등록합니다. 해당 가드는 JWT 토큰을 유효성 검사하고 사용자의 인증 상태를 보장하는 역할을 합니다.\n- AuthService: 해당 모듈 내에서 제공자로 AuthService를 등록합니다. 해당 서비스는 사용자 인증을 위한 비즈니스 로직을 포함하고 있을 것입니다.\n\n## 7. 인증 가드 구현:\n\nNestJS의 AuthGuard 클래스는 애플리케이션 내의 루트를 보호하기 위한 사용자 정의 인증 가드를 구현하는 역할을 합니다. 이 AuthGuard는 미들웨어로 사용되어 인증이 필요한 루트를 보호합니다. 루트의 메타데이터를 확인하고 JWT 토큰을 유효성 검사함으로써, 애플리케이션의 특정 부분에만 인증된 사용자만 접근하도록 보장합니다. 또한, 사용자 페이로드는 편리하게 요청 객체에 첨부되어 라우트 핸들러에서 추가 처리를 위해 사용됩니다.\n\n\n\n```js\n// backend/src/modules/auth/auth.guard.ts\n```\n\n```js\nimport {\n  CanActivate,\n  ExecutionContext,\n  Injectable,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\nimport { Request } from 'express';\nimport { Reflector } from '@nestjs/core';\nimport { IS_PUBLIC_KEY } from './public-strategy';\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  constructor(private jwtService: JwtService, private reflector: Reflector) {}\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (isPublic) {\n      return true;\n    }\n    const request = context.switchToHttp().getRequest();\n    const token = this.extractTokenFromHeader(request);\n    if (!token) {\n      throw new UnauthorizedException();\n    }\n    try {\n      const payload = await this.jwtService.verifyAsync(\n        token,\n        {\n          secret: jwtConstants.secret\n        }\n      );\n      // 💡 We're assigning the payload to the request object here\n      // so that we can access it in our route handlers\n      request['user'] = payload;\n    } catch {\n      throw new UnauthorizedException();\n    }\n    return true;\n  }\n  private extractTokenFromHeader(request: Request): string | undefined {\n    const [type, token] = request.headers.authorization?.split(' ') ?? [];\n    return type === 'Bearer' ? token : undefined;\n  }\n}\n```\n\n## 8. Auth Service 구현\n\nNestJS 애플리케이션에서 이 AuthService 클래스는 사용자 인증 및 가입 프로세스를 처리하는 역할을 담당합니다.\n\n\n\n\n\n```js\n// backend/src/modules/auth/auth.service.ts\n```\n\n```js\nimport { Injectable, UnauthorizedException } from \"@nestjs/common\";\nimport { UsersService } from \"../users/users.service\";\nimport { JwtService } from '@nestjs/jwt';\nimport { CreateUserDto } from \"src/dto/user/create-user.dto\";\n@Injectable()\nexport class AuthService {\n  constructor(private usersService: UsersService, private jwtService: JwtService) {}\n  async signIn(email, pass) {\n    const user = await this.usersService.findOneBy(email);\n    if (user?.password !== pass) {\n      throw new UnauthorizedException();\n    }\n    const payload = { sub: user.id, email: user.email };\n    return {\n      access_token: await this.jwtService.signAsync(payload),\n    };\n  }\n  async signUp(payload: CreateUserDto) {\n    const user = await this.usersService.create(payload);\n    return user;\n  }\n}\n```\n\n## 9. JWT 사용하여 비밀 키를 보관하는 상수 구현\n\nJWT 기반 인증에서, 비밀 키는 토큰의 무결성과 신뢰성을 보장하기 위해 사용되는 중요한 정보입니다. 이는 토큰을 발급하는 서버와 토큰을 유효성을 검증하는 서버 또는 클라이언트 사이에서 공유되는 비밀 키로 작용합니다.\n\n\n\n```js\n// backend/src/modules/auth/constants.ts\n```\n\n```js\nexport const jwtConstants = {\n  secret: \"JWTSecret#@!\",\n};\n```\n\n## 10: Implement Public Strategy\n\n이 전략은 AuthModule에서 위에서 AuthGuard를 사용하여 전역 인증을 활성화했기 때문에 인증이 필요하지 않음을 나타내는 루트 또는 핸들러를 표시하는 유틸리티를 정의합니다. route 또는 핸들러에 메타데이터를 첨부하기 위해 @nestjs/common 모듈에서 SetMetadata 함수를 사용합니다.\n\n\n\n```js\n// backend/src/modules/auth/public-strategy.ts\n```\n\n```js\nimport { SetMetadata } from '@nestjs/common';\nexport const IS_PUBLIC_KEY = 'isPublic';\nexport const Public = () => SetMetadata(IS_PUBLIC_KEY, true);\n```\n\n## 11. 사용자 모듈 구현\n\n이 모듈인 UsersModule은 응용 프로그램 내에서 사용자 관리와 관련된 기능을 구성하고 제공하는 데 전념합니다.\n\n\n\n```js\n// backend/src/modules/users/users.module.ts\n```\n\n```js\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserEntity } from 'src/entities/user.entity';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n  imports: [\n    TypeOrmModule.forFeature([UserEntity]),\n  ],\n})\nexport class UsersModule {}\n```\n\n- providers 배열: UsersService를 providers 배열에 포함합니다. 이는 UsersService가 모듈 전반에 걸쳐 injectable하게 만듭니다.\n\n2. exports 배열: UsersService를 exports 배열에 추가합니다. 즉, UsersModule을 import하는 다른 모듈에서 UsersService를 사용할 수 있습니다.\n  \n\n\n\n3. `imports` 배열: Utilizes `TypeOrmModule.forFeature([UserEntity])`를 사용하여 UserEntity를 모듈에 import합니다. 이를 통해 UserEntity와 관련된 TypeORM 기능에 액세스할 수 있습니다.\n\n## 12. 사용자 서비스 구현\n\nUsersService는 사용자 관련 데이터와 상호 작용하는 데 책임이 있으며, 이메일로 사용자를 찾거나 새 사용자를 생성하는 메서드를 제공합니다. 이 서비스에서 `@InjectRepository(UserEntity)`를 사용하여 MongoRepository`UserEntity`를 서비스에 주입합니다. 이 저장소는 UserEntity와 관련이 있으며 데이터베이스 상호 작용을 위한 메서드를 제공합니다.\n\n```js\n// backend/src/modules/users/users.service.ts\n```\n\n\n\n```js\nimport { Injectable } from \"@nestjs/common\";\nimport { InjectRepository } from \"@nestjs/typeorm\";\nimport { BaseUser } from \"src/dto/user/base-user.dto\";\nimport { CreateUserDto } from \"src/dto/user/create-user.dto\";\nimport { UserEntity } from \"src/entities/user.entity\";\nimport { MongoRepository } from \"typeorm\";\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectRepository(UserEntity)\n    private userRepository: MongoRepository<UserEntity>,\n) { }\n  async findOneBy(email: string): Promise<UserEntity | undefined> {\n    return await this.userRepository.findOneBy({ email: email });\n  }\n  async create(createUserDto: CreateUserDto) {\n    return this.userRepository.save({\n        ...createUserDto,\n        createdAt: new Date(),\n    });\n  }\n}\n```\n\nUsersService는 사용자 관련 작업에 대한 로직을 캡슐화하여 사용자 데이터와 상호 작용하는 깔끔하고 모듈식 방법을 제공합니다. 리포지토리 사용, 의존성 주입, 그리고 TypeORM과의 통합은 NestJS로 확장 가능하고 유지보수 가능한 애플리케이션을 구축하기 위한 모범 사례와 일치합니다.\n\n## Swagger에 따라 모든 것이 잘 설정되었습니다 😜:\n\n<img src=\"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_1.png\" />\n\n\n\n\n<img src=\"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_2.png\" />\n\n## 참고자료:","ogImage":{"url":"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png"},"coverImage":"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png","tag":["Tech"],"readingTime":11},{"title":"JavaScript 제너레이터에 대해 두렵지 마세요","description":"","date":"2024-05-14 14:20","slug":"2024-05-14-DontBeAfraidofJavaScriptGenerators","content":"\n\n![이미지](/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png)\n\n솔직히 말해봅시다: 제너레이터를 사용한 코드를 얼마나 자주 만나게 되나요?\n\n매일 다양한 개발자들의 코드를 검토하지만, 제너레이터를 거의 만나지 못합니다.\n\n그 이유는 무엇일까요?\n\n\n\n사람들은 이해하지 못하나요? 아니면 혜택을 못 보는 건가요?\n\nJavaScript는 유연성과 폭넓은 기능으로 유명한데요, ECMAScript 2015에서 독특한 도구인 제너레이터를 소개했습니다. 이들은 비동기 프로그래밍을 제어하고, 반복 가능한 객체를 생성하며, 여러 값을 반환하는 강력한 수단입니다. 이 안내서에서는 제너레이터의 동작 방식, 적용 분야, 그리고 어떻게 잠재력을 활용할 수 있는지 배워볼 거에요.\n\n# 제너레이터란 무엇인가요?\n\n제너레이터는 전통적인 함수와 다릅니다. 그들은 실행을 여러 번 시작하고 중단할 수 있어요. 이는 여러 값을 반환하고 나중에 실행을 계속할 수 있게 해주어 비동기 작업을 관리하거나, 반복자를 생성하거나, 끝없는 데이터 스트림을 처리하는 데 완벽한 방법입니다.\n\n\n\n생성기는 function* 구문으로 구분됩니다. 다음 기본 예제를 살펴보세요:\n\n```js\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n```\n\n여기서 yield는 값을 반환하고 생성기의 실행을 일시 중단합니다. 각 호출마다, 생성기는 그 다음 값을 반환합니다.\n\n# 생성기 객체와 상호 작용하기\n\n\n\n제너레이터 함수를 호출하면 해당 바디가 직접 실행되지 않습니다. 대신, 실행을 제어할 수 있는 제너레이터 객체가 생성됩니다. 이 객체는 순회 가능하므로 for...of 루프 및 유사한 작업에 적합합니다.\n\n제너레이터 객체를 살펴봅시다:\n\n- next(): 이 메소드는 제너레이터를 다시 시작하고, 다음으로 순회된 값을 반환하며, 제너레이터가 완료되었는지(done 속성으로 확인합니다.\n이전에 작성한 generateSequence 예제를 사용하여:\n\n```js\nconsole.log(generator.next()); // { value: 1, done: false }\n```\n\n\n\n- return(): 이 메서드는 generator를 일찍 종료시키며, 마치 return 명령을 실행한 것처럼 동작합니다.\n\n```js\nconsole.log(numbers.return(100)); // { value: 100, done: true }\n```\n\n- throw(): 이 메서드는 오류를 삽입할 수 있게 해주며, generator 내부에서 오류 처리를 간편하게 할 수 있습니다.\n\n```js\nfunction* generateTasks() {\n  try {\n    yield \"작업 시작\";\n    yield \"작업 진행 중\";\n    yield \"작업 거의 완료\";\n  } catch (error) {\n    console.log('문제 발생:', error.message);\n  }\n}\n\nconst tasks = generateTasks();\n\nconsole.log(tasks.next().value); // 출력: \"작업 시작\"\nconsole.log(tasks.next().value); // 출력: \"작업 진행 중\"\ntasks.throw(new Error('이런! 문제가 발생했어요.')); \n// 출력: \"문제 발생: 이런! 문제가 발생했어요.\"\nconsole.log(tasks.next()); // 출력: { value: undefined, done: true }\n```\n\n\n\n위의 예제에서는 next() 메서드를 사용하여 몇 가지 작업을 시작한 후 throw() 메서드를 사용하여 오류를 발생시킵니다. 제너레이터는 try-catch 블록 덕분에이 오류를 캡처하여 오류 메시지를 기록하고 오류 시나리오를 단호하게 처리합니다.\n\n# 무한 데이터 스트림을 위한 제너레이터 활용\n\n제너레이터는 무한 데이터 스트림을 처리하는 데 뛰어납니다. 요청 시에만 값을 생성하는 잠재적으로 끝없는 데이터 구조를 설계할 수 있습니다. 웹 애플리케이션에서의 무한 스크롤링과 같은 상황을 생각해보세요.\n\n```js\nfunction* infiniteNumbers() {\n  let index = 0;\n  while (true) {\n    yield index++;\n  }\n}\n```\n\n\n\nI confess, while(true) could scare anyone at first glance, but that is the magic of generators.\n\n# Synchronous and Asynchronous Iteration with Generators\n\nWhen blended with promises, generators can emulate the async/await pattern, offering a neater, more intuitive method to draft asynchronous code. To illustrate, let’s fetch data using a generator:\n\n```js\nfunction* fetchData() {\n  const users = yield fetch('https://api.example.com/users');\n  console.log('Users:', users);\n  // ...\n}\n```\n\n\n\n# 제너레이터의 고급 활용\n\nasync/await는 간단한 비동기 작업에 유용하지만, 다양한 기능을 제공하는 제너레이터는 더 다양한 가능성을 제공합니다.\n\n- 제너레이터 조합: 이를 통해 여러 개의 제너레이터를 매끄럽게 통합하여 복잡한 값 시퀀스를 만들 수 있습니다.\n\n```js\nfunction* generateSequence() {\n  yield* generateNumbers();\n  yield* generateCharacters('A', 'Z');\n}\n```\n\n\n\n- 무한 생성기: 생성기는 무한한 값 시퀀스를 생성할 수 있어 연속 데이터 스트림이나 무한한 알고리즘에 이상적입니다. 위의 while (true)을 기억하시나요?\n\n# 실세계 시나리오 (업데이트): 무한 스크롤\n\n![이미지](/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_1.png)\n\n자바스크립트 생성기에 대한 중요하고 실용적인 응용 프로그램을 개념화하는 것이 어려울 수 있습니다. 그러나 생성기는 비동기 코드와 매끄럽게 통합되며 무한한 반복을 지원하는 등 다양한 기능을 제공합니다. 예시를 살펴보죠.\n\n\n\n하단에 제시된 코드는 순수히 예시로 제시된 것입니다. 실제로 사용할 준비가 된 코드는 다양한 예외 상황을 처리해야 합니다.\n\n무한 스크롤을 지원하는 소셜 미디어 피드를 구성하는 것을 제안합니다. 다시 말해, 사용자가 목록의 끝까지 스크롤하면 추가적인 게시물이 가져와서 피드에 추가됩니다.\n\n두 번째 주의: 제너레이터는 한 가지 접근법을 제공하지만, JavaScript 생태계에서 단독적인 것은 아닙니다. 비슷한 결과를 얻기 위한 대체 방법이 있습니다. 그럼에도 불구하고, 학습을 위해 사용자가 스크롤할 때 게시물을 계속해서 가져오는 메커니즘을 구성해보겠습니다.\n\n먼저, 데이터를 담을 기본적인 HTML/CSS 구조를 설정해보겠습니다. 실험해보고 싶다면 사용하실 수 있습니다:\n\n\n\n```js\r\n// CSS 코드\n.post {\n  height: 300px;\n}\n\n// HTML 코드\n<div id=\"postsContainer\">\n  \n</div>\r\n```\n\n다음은 \"10개의 게시물\"을 가져오기 위해 설계된 스크립트를 검토할 것입니다. 사용자가 스크롤하고 페이지 끝에 가까워지면 생성기가 작동하여 다음 10개의 게시물을 가져올 것입니다:\n\n```js\r\n// 일반 `fetch`를 대체하기 위한 것일 뿐입니다\n// 10개의 게시물을 생성하고 반환합니다\nasync function simulatedFetch(currentPage) {\n  const posts = Array.from({ length: 10 }, (_, i) => ({ content: `포스트 - ${currentPage}${i}` }));\n  return Promise.resolve(posts)\n}\n\nasync function* paginatedFetcher(apiUrl, itemsPerPage) {\n    let currentPage = 0;\n\n    while (true) {\n        // 현실적인 경우에 대한 주석\n        // const response = await fetch(`${apiUrl}?page=${currentPage}&limit=${itemsPerPage}`);\n        const response = await simulatedFetch(currentPage)\n      \n        // const posts = await response.json();\n        const posts = response;\n      \n        if (posts.length === 0) {\n            return;  // 데이터의 끝\n        }\n      \n        yield posts;\n        currentPage++;\n    }\n}\n\n// 무한 스크롤과 함께 사용:\n// API는 설명적인 역할로 실제 사용되지는 않습니다\nconst getPosts = paginatedFetcher('https://api.example.com/posts', 10);\n\n// DOM에 게시물을 표시하는 함수\nfunction displayPosts(posts) {\n  const container = document.getElementById('postsContainer');\n    posts.forEach(post => {\n        const postElement = document.createElement('div');\n        postElement.className = 'post';\n        postElement.innerText = post.content;\n        container.appendChild(postElement);\n    });\n}\n\n// 무한 스크롤 로직\nwindow.onscroll = async function() {\n    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {\n        const { value } = await getPosts.next();\n        if (value) {\n            displayPosts(value);\n        }\n    }\n};\n\n// 초기 데이터 가져오기\n(async () => {\n    const { value } = await getPosts.next();\n    displayPosts(value);\n})();\r\n```\n\n# 결론\n\n\n\nJavaScript에서의 생성기들은 그저 새로운 것뿐만이 아니라, 비동기 작업을 다루는 데 중요하며, 반복 가능한 객체를 만드는 데도 중요합니다.\n\n다음에 데이터를 실시간으로 관리해야 할 때, 생성기를 사용하기 주저하지 마세요.\n\n실제 시나리오에서 생성기를 효과적으로 활용한 경험이 있다면 공유해 주세요. 더 많은 예시를 만나면, 어디에 활용하는 게 가장 적절한지 더 쉽게 알 수 있을 거예요.\n\n저와 소통하세요! 저는 아래에서 찾을 수 있어요:\n- Medium: https://medium.com/@yuribett\n- Linkedin: https://www.linkedin.com/in/yuribett/\n- X (formerly Twitter): https://twitter.com/yuribett\n\n\n\n# Stackademic\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 향한 박수와 팔로우를 고려해주세요! 👏\n- 트위터(X), 링크드인, YouTube에서 저희를 팔로우해 주세요.\n- 세계적으로 프로그래밍 교육을 민주화하는 Stackademic.com에서 더 많은 정보를 찾아보세요.","ogImage":{"url":"/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png"},"coverImage":"/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular 17에서 Role-Based Access Control RBAC 구현하기","description":"","date":"2024-05-14 14:19","slug":"2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17","content":"\n\n<img src=\"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png\" />\n\n앵귤러 17 애플리케이션에서 Role-Based Access Control (RBAC)을 구현하는 것에는 특정 경로 및 기능에만 인가된 사용자가 액세스할 수 있도록 여러 단계를 거쳐야 합니다. 앵귤러 17은 서비스, 가드, 지시문과 같은 Angular의 핵심 기능을 사용하여 이러한 시나리오를 처리합니다.\n\n여기에는 여러 부분으로 나뉘어진 완전한 예제가 있습니다:\n\n# 1. 앵귤러 프로젝트 설정\n\n\n\n먼저 Angular CLI가 설치되었는지 확인하세요:\n\n```js\nnpm install -g @angular/cli\n```\n\n새로운 Angular 프로젝트를 생성하세요:\n\n```js\nng new angular-rbac --routing=true --style=css\ncd angular-rbac\n``` \n\n\n\n# 2. 인증 모의 서비스\n\n사용자 로그인을 관리하고 역할을 저장하는 간단한 인증 서비스를 만들어보세요.\n\n```js\nng generate service auth\n```\n\nauth.service.ts를 편집하세요.\n\n\n\n```js\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nexport interface User {\n  username: string;\n  roles: string[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  private currentUserSubject: BehaviorSubject<User | null>;\n  public currentUser: Observable<User | null>;\n\n  constructor() {\n    this.currentUserSubject = new BehaviorSubject<User | null>(null);\n    this.currentUser = this.currentUserSubject.asObservable();\n  }\n\n  login(username: string, password: string): void {\n    // 데모용으로, 인증이 성공했다고 가정합니다.\n    const user: User = {\n      username: username,\n      roles: username === 'admin' ? ['admin', 'user'] : ['user'],\n    };\n    this.currentUserSubject.next(user);\n  }\n\n  logout(): void {\n    this.currentUserSubject.next(null);\n  }\n\n  public get currentUserValue(): User | null {\n    return this.currentUserSubject.value;\n  }\n\n  public isAuthorized(allowedRoles: string[]): boolean {\n    const user = this.currentUserValue;\n    if (!user) return false;\n    return user.roles.some(role => allowedRoles.includes(role));\n  }\n}\n```\n\n# 3. 라우트 보호를 위한 인증 가드\n\n사용자 역할에 따라 라우트를 보호하는 가드를 생성하세요.\n\n```js\nng generate guard auth\n```\n\n\n\nEdit the auth.guard.ts:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {\n    const allowedRoles = next.data['roles'] as string[];\n    if (this.authService.isAuthorized(allowedRoles)) {\n      return true;\n    }\n\n    // Redirect to the login page or some other route\n    this.router.navigate(['/login']);\n    return false;\n  }\n}\n```\n\n# 4. Setup Routes with Role Protections\n\nEdit the app-routing.module.ts to define roles required for each route:\n\n\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { AdminComponent } from './admin/admin.component';\nimport { LoginComponent } from './login/login.component';\nimport { UserComponent } from './user/user.component';\nimport { AuthGuard } from './auth.guard';\n\nconst routes: Routes = [\n  { path: 'login', component: LoginComponent },\n  { path: 'admin', component: AdminComponent, canActivate: [AuthGuard], data: { roles: ['admin'] } },\n  { path: 'user', component: UserComponent, canActivate: [AuthGuard], data: { roles: ['user', 'admin'] } }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n# 5. Create Components for Each Route\n\n```js\nng generate component login\nng generate component admin\nng generate component user\n```\n\n각 컴포넌트는 필요에 따라 기본 정보 또는 양식을 렌더링하는 간단한 구조여야 합니다.\n\n\n\n# 6. 로그인 기능 구현하기\n\n사용자 로그인을 처리하기 위해 login.component.ts를 업데이트하세요:\n\n```js\nimport { Component } from '@angular/core';\nimport { AuthService } from '../auth.service';\n\n@Component({\n  selector: 'app-login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {\n  username: string = '';\n  password: string = '';\n\n  constructor(private authService: AuthService) { }\n\n  login(): void {\n    this.authService.login(this.username, this.password);\n  }\n}\n```\n\n# 7. 어플리케이션 테스트하기\n\n\n\nAngular 개발 서버를 실행해주세요:\n\n```js\nng serve\n```\n\nhttp://localhost:4200 으로 이동하여 다른 사용자로 로그인하여 다양한 경로를 테스트해보세요.\n\n이 설정은 Angular 17 애플리케이션에서 역할 기반 액세스를 위한 기본적인 프레임워크를 제공합니다. 실제 백엔드 통합, 토큰 기반 인증 처리, 그리고 더 정교한 사용자 관리 기능을 추가함으로써 더 확장시킬 수 있습니다.\n\n\n\n감사합니다\n\n찬단","ogImage":{"url":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png","tag":["Tech"],"readingTime":5}],"page":"106","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}