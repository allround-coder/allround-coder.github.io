{"pageProps":{"posts":[{"title":"리액트에서 반응형 디자인 구축하기 어떤 기기에서도 멋있게 보이는 반응형 디자인을 만들기 위한 최상의 방법","description":"","date":"2024-05-14 11:57","slug":"2024-05-14-BuildingaresponsivedesigninReactBestpracticesforcreatingaresponsivedesignthatlooksgreatonanydevice","content":"\n\n반응형 디자인은 현대 웹 개발의 중요한 측면이 되었습니다. 이 기사에서는 React에서 반응형 디자인을 구축하는 최상의 방법과 어떻게 모든 기기에서 멋지게 보이는 디자인을 만들 수 있는지 알아보겠습니다.\n\n## 반응형 디자인 원리 활용하기\n\nReact에서 반응형 디자인을 만들기 위해서는 반응형 디자인 원리를 활용하는 것이 중요합니다. 이는 웹사이트가 데스크톱, 태블릿 또는 스마트폰 등 모든 기기에서 멋지게 보이도록 보장합니다. 이러한 원리에는 상대적인 단위를 사용해 글꼴 크기를 조절하고 유연한 레이아웃을 사용하며 다양한 화면 크기에 맞게 이미지를 최적화하는 것이 포함됩니다.\n\n## CSS 프레임워크 사용하기\n\n\n\nCSS 프레임워크를 사용하면 빠르고 쉽게 반응형 디자인을 만들 수 있어요. 리액트와 함께 사용할 수 있는 여러 CSS 프레임워크가 있습니다. 부트스트랩, 마테리얼라이즈, 시맨틱 UI 등이 있어요. 이러한 프레임워크들은 사전 제작된 구성 요소와 반응형 레이아웃을 제공하며 필요에 맞게 사용자 정의할 수 있어요.\n\n# 미디어 쿼리 활용\n\n미디어 쿼리는 화면 크기를 기반으로 웹사이트에 다른 스타일을 적용할 수 있는 CSS 기능이에요. 미디어 쿼리를 사용하여 레이아웃, 폰트 크기 및 기타 디자인 요소를 조정하여 모든 기기에서 웹사이트가 멋지게 보이도록 할 수 있어요.\n\n```js\n@media (max-width: 768px) {\n .container { flex-direction: column;\n  } \n} \n@media (min-width: 768px) { \n.container {\n flex-direction: row; \n  } \n}\n```\n\n\n\n이 예시에서 두 개의 미디어 쿼리를 정의했습니다. 첫 번째 쿼리는 화면 크기가 768픽셀 이하일 때 적용됩니다. 이 쿼리는 flex-direction 속성을 column으로 설정하여 레이아웃을 단일 열로 변경합니다. 두 번째 쿼리는 화면 크기가 768픽셀 이상일 때 적용됩니다. 이 쿼리는 flex-direction 속성을 row로 설정하여 레이아웃을 여러 열로 변경합니다.\n\n# Flexbox 사용\n\nFlexbox는 유연한 레이아웃을 생성할 수 있는 CSS 기능입니다. Flexbox를 사용하면 다양한 화면 크기와 방향에 맞춰 레이아웃을 조정할 수 있습니다. Flexbox를 이용하면 모든 기기에서 멋지게 보이는 반응형 디자인을 쉽게 만들 수 있습니다.\n\n```js\n.container {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n}\n```\n\n\n\n이 예제에서는 유연한 레이아웃을 만들기 위해 flexbox를 사용하는 컨테이너 요소를 정의했습니다. display 속성을 flex로 설정하여 브라우저에 flexbox를 사용하도록 지시했습니다. flex-direction 속성을 row로 설정하여 레이아웃이 행으로 표시되도록 했습니다. justify-content 속성을 space-between으로 설정하여 항목을 주축을 따라 균등하게 배치했습니다. align-items 속성을 center로 설정하여 항목을 교차 축을 따라 가운데 정렬했습니다.\n\n# React 반응형 라이브러리 사용하기\n\n다양한 React 반응형 라이브러리를 사용하면 반응형 디자인을 보다 편리하게 구축할 수 있습니다. 이러한 라이브러리에는 react-responsive, react-device-detect, react-media 등이 있습니다. 이러한 라이브러리는 기기 유형을 감지하고 레이아웃을 그에 맞게 조정하는 데 도움이 되는 컴포넌트를 제공합니다.\n\n```js\nimport { useMediaQuery } from \"react-responsive\";\n\nfunction MyComponent() {\n  const isTabletOrMobile = useMediaQuery({ maxWidth: 768 });\n\n  return (\n    <div> {isTabletOrMobile ? <MobileComponent /> : <DesktopComponent />} </div>\n  );\n}\n```\n\n\n\n이 예시에서는 react-responsive 라이브러리의 useMediaQuery 훅을 사용하여 기기가 태블릿 또는 모바일 장치인지 감지했습니다. isTabletOrMobile 변수를 사용하여 MobileComponent 또는 DesktopComponent 중 하나를 조건부로 렌더링했습니다.\n\n# 결론\n\nReact에서 반응형 디자인을 구축하는 것은 웹사이트가 모든 기기에서 훌륭하게 보이도록 보장하는 데 중요합니다.","ogImage":{"url":"/assets/img/2024-05-14-BuildingaresponsivedesigninReactBestpracticesforcreatingaresponsivedesignthatlooksgreatonanydevice_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaresponsivedesigninReactBestpracticesforcreatingaresponsivedesignthatlooksgreatonanydevice_0.png","tag":["Tech"],"readingTime":3},{"title":"React TypeScript 마스터하기 개발자를 위한 포괄적인 가이드","description":"","date":"2024-05-14 11:54","slug":"2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers","content":"\n\n![이미지](/assets/img/2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers_0.png)\n\nReact 능력을 더 높이고 싶은 개발자이신가요? TypeScript로 React를 마스터하려면 더 이상 찾을 필요가 없어요. 이 포괄적인 안내서는 React 응용 프로그램을 TypeScript로 구축하는 데 필요한 모든 것을 알려줄 거에요. 처음 시작하는 중이거나 React를 한동안 사용해온 분이더라도, 이 안내서는 깨끗하고 효율적이며 확장 가능한 코드를 작성하는 데 필요한 도구와 지식을 제공할 거예요. 그러니 함께 React TypeScript의 세계를 탐험해 봐요!\n\n# 1. 함수 컴포넌트\n\n## 1.1 외부 선언\n\n\n\n저희 컴포넌트의 props에 대한 타입을 정의하기 위해 인터페이스를 사용하세요.\n\n```js\ninterface GreetingProps {\n  name: string;\n}\n\nconst Greeting = ({ name }: GreetingProps) => <div>Hello, {name}!</div>;\n```\n\n## 1.2 Inline Declaration\n\n조금 더 간단한 props를 가진 컴포넌트의 경우, 인라인으로 선언할 수 있습니다.\n\n\n\n```js\nconst Greeting = ({ name }: { name: string }) => <div>환영합니다, {name}님!</div>;\n```\n\n## 1.3 제네릭 사용하기\n\n제네릭은 컴포넌트 props의 유연성을 향상시킵니다.\n\n```js\n// 제네릭 타입 정의\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n}\n\n// 그 제네릭 타입을 사용하여 함수 컴포넌트 생성\nconst List: React.FC<ListProps<string>> = ({ items, renderItem }) => (\n  <ul>{items.map((item, index) => <li key={index}>{renderItem(item)}</li>)}</ul>\n);\n\nconst UserList = () => {\n  const users = [\"Alice\", \"Bob\", \"Charlie\"];\n  return <List items={users} renderItem={(user) => <strong>{user}</strong>} />;\n};\n```\n\n\n\n# 2. 훅\n\n## 2.1 useState\n\n간단히 초기값을 제공하면 TypeScript가 해당 유형을 자동으로 유추해줍니다.\n\n```js\nconst [counter, setCounter] = useState(0);\n// 'counter'는 숫자로 추론됩니다\n// 'setCounter'는 숫자나 숫자를 반환하는 함수를 입력으로 받는 함수입니다\n```\n\n\n\n초기 상태가 정의되지 않을 수 있는 경우에는 상태의 타입을 명시적으로 정의할 수 있습니다.\n\n```js\ninterface User {\n  name: string;\n  id: number;\n  email: string;\n}\n\nfunction UserProfile() {\n  const [user, setUser] = useState<User | undefined>();\n\n  // 'user'은 User 객체이거나 undefined일 수 있습니다.\n}\n```\n\n`User | undefined`와 같이 undefined일 수 있는 제네릭을 사용할 때, 객체가 undefined일 수 있다는 오류가 발생할 수 있습니다. 이 경우 다음 두 가지 방법으로 처리할 수 있습니다:\n\n- 옵셔널 체이닝 연산자 `?.`을 사용하는 것입니다.\n\n\n\n```js\nfunction UserProfile() {\n  const [user, setUser] = useState<User | undefined>();\n\n  return (\n    <div>\n      Name: {user?.name} {/* 여기서 선택적 체이닝을 사용했습니다. */}\n    </div>\n  );\n}\n```\n\n- 초기값으로 빈 객체 제공 및 타입 어설션 사용\n\n```js\nconst [user, setUser] = useState<User>({} as User);\n// 여기서 우리는 빈 객체가 실제로 User 객체라고 말하고 있습니다.\n```\n\n## 2.2 useCallback\n\n\n\n\n위의 텍스트를 부탁하신 대로 친절하게 한국어로 번역해 드리겠습니다.\n\n함수의 타입은 첫 번째 인수에서 추론됩니다.\n\n버튼이 클릭될 때 작업을 수행해야 하는 함수가 있고, 그러나 이 함수가 컴포넌트가 렌더링될 때마다 재생성되지 않도록 하고 싶다면 useCallback을 사용할 수 있습니다.\n\n```js\nconst saveUser = useCallback(\n  (id: number, userData: User) => {\n    // 이 함수가 사용자 데이터를 서버로 보내는 상황을 상상해보세요\n    api.updateUser(id, userData);\n  },\n  [],\n); // 의존성 배열이 비어 있으므로, 이 함수는 한 번 생성되고 재생성되지 않음\n\n// 'saveUser'는 다음과 같이 추론됩니다: (id: number, userData: User) => void\n```\n\n## 2.3 useMemo\n\n\n\n제공된 첫 번째 인수의 반환 값을 기반으로 유형이 추론됩니다.\n\n카트에 있는 항목들의 총 가격을 계산하는 시나리오를 고려해 보세요. 세금을 포함한 가격을 계산하려면:\n\n```js\nconst totalPrice = useMemo(() => {\n  const price = items.reduce((total, item) => total + item.price, 0);\n  return (price * (1 + taxRate)).toFixed(2);\n}, [items, taxRate]); // 'totalPrice'은 toFixed로 인해 문자열로 추론됩니다\n```\n\n값의 반환 유형을 명시적으로 지정할 수도 있습니다.\n\n\n\n그러나 제네릭을 사용하여 명시적으로 잘못된 유형을 설정하려고하면 TypeScript에서 경고가 발생할 것입니다:\n\n```js\n// toFixed로 인해 반환 유형이 문자열인 경우 오류가 발생합니다.\nconst totalPrice = useMemo<number>(() => {\n  const price = items.reduce((total, item) => total + item.price, 0);\n  return (price * (1 + taxRate)).toFixed(2);\n}, [items, taxRate]); // 오류: 'string' 형식은 'number' 형식에 할당할 수 없습니다.\n```\n\n## 2.4 useRef\n\nDOM 노드에 액세스하려면 null의 초기값을 제공할 수 있습니다.\n\n\n\n페이지가 로드될 때 텍스트 입력란에 초점을 맞추어야 할 때:\n\n```js\nconst inputRef = useRef<HTMLInputElement>(null);\n\nuseEffect(() => {\n  // 컴포넌트가 마운트된 후 입력 요소에 초점을 맞춥니다\n  inputRef.current?.focus();\n}, []);\n```\n\nuseRef는 업데이트되어도 다시 렌더링을 발생시키지 않는 타이머 참조와 같은 변경 가능한 값을 저장하는 데에도 사용할 수 있습니다.\n\n2초마다 메시지를 기록하는 타이머를 설정하고 싶다고 가정해봅시다:\n\n\n\n```js\nconst timerRef = useRef<NodeJS.Timer>();\n\nuseEffect(() => {\n  timerRef.current = setInterval(() => {\n    console.log(\"Timer tick\");\n  }, 2000);\n\n  // 컴포넌트가 언마운트 될 때 interval을 정리합니다.\n  return () => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n    }\n  };\n}, []);\n```\n\n## 2.5 useImperativeHandle\n\nuseImperativeHandle은 ref를 사용할 때 노출되는 인스턴스 값을 사용자 정의하는 데 사용됩니다. 타입은 forwardRef 지점에서 정의되며, 제네릭이 전달되는 순서를 주의해야 합니다—ref는 props 앞에 옵니다.\n\n부모 컴포넌트에서 리셋할 수 있는 사용자 정의 입력 컴포넌트가 있는 시나리오를 상상해봅시다.\n\n\n\n```js\nimport { useRef, forwardRef, useImperativeHandle, useState } from \"react\";\n\n// 사용자 정의 ref 타입 정의\ninterface CustomInputHandle {\n  clear: () => void;\n}\n\nconst Form = () => {\n  // null로 초기화\n  const inputRef = useRef<CustomInputHandle>(null);\n\n  const handleClearClick = () => {\n    inputRef.current?.clear();\n  };\n\n  return (\n    <div>\n      <CustomInput ref={inputRef} />\n      <button onClick={handleClearClick}>Clear Input</button>\n    </div>\n  );\n};\n\n// props와 ref 타입 정의의 역순에 유의하세요\nconst CustomInput = forwardRef<CustomInputHandle, {}>((props, ref) => {\n  const [text, setText] = useState(\"\");\n\n  useImperativeHandle(ref, () => ({\n    clear: () => {\n      setText(\"\");\n    },\n  }));\n\n  return (\n    <input type=\"text\" value={text} onChange={(e) => setText(e.target.value)} />\n  );\n});\n\nexport default Form;\n```\n\n## 2.6 useContext\n\nuseContext를 사용하면 컴포넌트에서 context 객체를 소비할 수 있습니다. 자동으로 타입이 유추되므로 createContext 단계에서 타입을 정의하는 것이 중요합니다.\n\n초기 값 설정이 가능하며 TypeScript가 자동으로 타입을 추론합니다.\n  \n\n\n\n```js\nconst ThemeContext = createContext({\n  theme: \"light\",\n  toggleTheme: () => {},\n});\n\n// 'ThemeContext'는 다음과 같이 추론됩니다:\n// const ThemeContext: React.Context<{\n//   theme: string;\n//   toggleTheme: () => void;\n// }>\n```\n\n만약 컨텍스트 타입을 더 엄격하게 보장하고 싶다면, 빈 객체와 타입 어순화를 사용하여 제네릭을 사용할 수 있습니다.\n\n```js\ninterface ThemeContextType {\n  theme: string;\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType>({} as ThemeContextType);\n\n// 'ThemeContext'는 이제 'theme'와 'toggleTheme'을 갖는 객체를 엄격하게 요구합니다.\n```\n\n## 2.7 useReducer\n\n\n\n\nuseReducer은 React에서 상태 관리에 사용되는 훅으로, 여러 하위 값이 관련되거나 다음 상태가 이전 상태에 의존하는 복잡한 상태 논리가 있는 경우 특히 유용합니다. TypeScript는 상태와 액션에 대한 타입을 제공하여 useReducer를 매우 효과적으로 활용할 수 있습니다.\n\n예를 들어, 항목을 추가하거나 제거할 수 있는 쇼핑 카트를 관리하는 경우:\n\n```js\nimport { useReducer } from \"react\";\n\nconst initialCart = {\n  items: [],\n  total: 0,\n};\n\n// 1. 초기 상태 타입 정의\ntype CartState = typeof initialCart;\n\n// 2. 액션 타입 정의\ntype CartActionType =\n  | { type: \"addItem\"; payload: { item: string; price: number } }\n  | { type: \"removeItem\"; payload: { index: number } };\n\nfunction cartReducer(state: CartState, action: CartActionType) {\n  switch (action.type) {\n    case \"addItem\":\n      return {\n        ...state,\n        items: [...state.items, action.payload.item],\n        total: state.total + action.payload.price,\n      };\n    case \"removeItem\":\n      const newItems = state.items.filter((_, index) => index !== action.payload.index);\n      return {\n        ...state,\n        items: newItems,\n        total: state.total - state.items[action.payload.index].price,\n      };\n    default:\n      throw new Error();\n  }\n}\n\nconst ShoppingCart = () => {\n  const [cart, dispatch] = useReducer(cartReducer, initialCart);\n  return (\n    <>\n      총액: {cart.total}\n      <button onClick={() => dispatch({ type: \"addItem\", payload: { item: 'Apple', price: 1 } })}>\n        사과 추가\n      </button>\n      <button onClick={() => dispatch({ type: \"removeItem\", payload: { index: 0 } })}>\n        항목 제거\n      </button>\n      {/* 상품 목록 */}\n      {cart.items.map((item, index) => (\n        <div key={index}>{item}</div>\n      ))}\n    </>\n  );\n};\n\nexport default ShoppingCart;\n```\n\n## 2.8 useEffect / useLayoutEffect\n\n\n\nuseEffect와 useLayoutEffect은 함수 컴포넌트에서 부작용을 수행하는 데 사용되는 훅입니다. 이들은 componentDidMount, componentDidUpdate 및 componentWillUnmount과 같은 클래스 컴포넌트의 라이프사이클 메서드와 유사합니다. TypeScript에서 이러한 훅에 대한 타입을 명시적으로 정의할 필요가 없는 이유는 이러한 훅이 타입 정의를 필요로 하는 것이 없기 때문입니다.\n\n다음은 API에서 사용자 데이터를 가져와야 하는 애플리케이션에서 useEffect를 사용한 실제 예시입니다:\n\n```js\nimport { useEffect, useState } from \"react\";\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst UserProfile = () => {\n  const [user, setUser] = useState<User | null>(null);\n\n  useEffect(() => {\n    const fetchUserData = async () => {\n      const response = await fetch(\"https://api.example.com/user\");\n      const userData: User = await response.json();\n      setUser(userData);\n    };\n\n    fetchUserData();\n  }, []); // 의존성 배열이 비어 있으면, 이 효과는 componentDidMount와 유사하게 한 번만 실행됩니다.\n\n  if (!user) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n};\n\nexport default UserProfile;\n```\n\n# 3. 내장 타입\n\n\n\n## 3.1 스타일 속성 유형\n\nReact에서 자식 컴포넌트에 인라인 스타일을 전달하려면 React.CSSProperties를 사용할 수 있습니다.\n\n```js\ninterface Props {\n  style?: React.CSSProperties;\n}\n```\n\n## 3.2 자식 요소 유형\n\n\n\n3.2.1 React.ReactNode\n\nJSX에서 렌더링할 수 있는 모든 유형의 연합체입니다. 문자열, 숫자, React 엘리먼트 및 이러한 유형의 배열이 포함됩니다.\n\n```js\ninterface Props {\n  children?: React.ReactNode;\n}\n```\n\n이 유형을 사용하면 children prop이 JSX에서 렌더링할 수 있는 어떤 유형이든 될 수 있음을 TypeScript에 알리는 것입니다. 매우 유연합니다.\n\n\n\n3.2.2 React.ReactElement\n\n이 유형은 문자열이나 숫자와 같은 JavaScript 기본 유형을 제외하고 JSX 요소만 포함합니다. 이는 주로 함수 컴포넌트의 반환 유형을 정의하는 데 사용됩니다.\n\n```js\ninterface Props {\n  children?: React.ReactElement;\n}\n```\n\n## 3.3 컴포넌트 속성 유형 가져오기\n\n\n\n만약 자식 컴포넌트가 인라인으로 props를 정의하고 부모 컴포넌트가 자식의 props 유형을 참조해야 할 경우, React.ComponentProps를 사용하여 자식 컴포넌트의 props 유형을 추론할 수 있습니다.\n\n```js\nconst ChildComponent = ({ message }: { message: string }) => <div>{message}</div>;\n\ntype ChildPropsType = React.ComponentProps<typeof ChildComponent>;\n\n// ChildPropsType는 다음과 같이 추론됩니다:\n// type ChildPropsType = {\n//   message: string;\n// }\n```\n\n# 4. 이벤트 처리\n\n## 4.1 이벤트 유형\n\n\n\n리액트에서 이벤트를 다룰 때는 이벤트 핸들러 내에서 예상한 속성에 액세스할 수 있도록 올바른 이벤트 유형을 지정하는 것이 중요합니다.\n\n### 4.1.1 onClick 이벤트\n\n버튼 요소에서 마우스 이벤트를 처리할 때, React.MouseEvent에 HTMLButtonElement를 제네릭 매개변수로 전달하세요.\n\n```js\ninterface Props {\n  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;\n}\n```  \n\n\n\n4.1.2 onChange 이벤트\n\n입력 요소에서의 변경 이벤트에 대해 React.ChangeEvent에 HTMLInputElement를 일반적인 매개변수로 전달하십시오.\n\n```js\nfunction App() {\n  const [value, setValue] = useState(\"\");\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setValue(event.target.value);\n  };\n\n  return <input value={value} onChange={handleChange} />;\n}\n```\n\n4.1.3 공통 이벤트 유형\n\n\n\n가장 일반적인 몇 가지입니다:\n\n- React.MouseEvent: 클릭이나 마우스 이동과 같은 마우스 이벤트에 사용됩니다.\n- React.ChangeEvent: 값이 변경될 때 주로 폼 요소에서 변경 이벤트에 사용됩니다.\n- React.KeyboardEvent: 키 입력을 캡처하는 키보드 이벤트에 사용됩니다.\n- React.DragEvent: 드래그 앤 드롭 상호작용에 사용됩니다.\n- React.FocusEvent: onFocus 및 onBlur와 같은 포커스 관련 이벤트에 사용됩니다.\n- React.FormEvent: 관련된 모든 폼 상호작용을 포함하는 폼 이벤트에 사용됩니다.\n- React.WheelEvent: 스크롤링과 같은 마우스 휠 이벤트에 사용됩니다.\n- React.TouchEvent: 터치 기능 장치에서 터치 이벤트에 사용됩니다.\n- React.ClipboardEvent: 복사 및 붙여넣기와 같은 클립보드 이벤트에 사용됩니다.\n- React.AnimationEvent: CSS 애니메이션 이벤트에 사용됩니다.\n- React.TransitionEvent: CSS 전환 이벤트에 사용됩니다.\n\n4.1.4 HTML 태그 및 유형 매핑\n\nReact와 TypeScript를 함께 사용할 때 이벤트를 처리하거나 참조를 만들 때 HTML 태그를 해당 유형으로 매핑하는 것이 중요합니다. 이러한 매핑을 통해 이벤트 핸들러나 참조가 해당 요소에 특정한 속성과 메서드에 액세스할 수 있도록 보장됩니다. TypeScript에서 일반적인 HTML 태그와 해당 유형은 다음과 같습니다:\n\n\n\n```js\n인터페이스 HTMLElementTagNameMap {\n  \"a\": HTMLAnchorElement;\n  \"article\": HTMLElement;\n  \"aside\": HTMLElement;\n  \"body\": HTMLBodyElement;\n  \"br\": HTMLBRElement;\n  \"button\": HTMLButtonElement;\n  \"canvas\": HTMLCanvasElement;\n  \"div\": HTMLDivElement;\n  \"dl\": HTMLDListElement;\n  \"dt\": HTMLElement;\n  \"dd\": HTMLElement;\n  \"em\": HTMLElement;\n  \"footer\": HTMLElement;\n  \"form\": HTMLFormElement;\n  \"h1\": HTMLHeadingElement;\n  \"h2\": HTMLHeadingElement;\n  \"h3\": HTMLHeadingElement;\n  \"h4\": HTMLHeadingElement;\n  \"h5\": HTMLHeadingElement;\n  \"h6\": HTMLHeadingElement;\n  \"head\": HTMLHeadElement;\n  \"header\": HTMLElement;\n  \"html\": HTMLHtmlElement;\n  \"iframe\": HTMLIFrameElement;\n  \"img\": HTMLImageElement;\n  \"input\": HTMLInputElement;\n  \"label\": HTMLLabelElement;\n  \"link\": HTMLLinkElement;\n  \"main\": HTMLElement;\n  \"nav\": HTMLElement;\n  \"p\": HTMLParagraphElement;\n  \"picture\": HTMLPictureElement;\n  \"section\": HTMLElement;\n  \"select\": HTMLSelectElement;\n  \"span\": HTMLSpanElement;\n  \"strong\": HTMLElement;\n  \"table\": HTMLTableElement;\n  \"tbody\": HTMLTableSectionElement;\n  \"textarea\": HTMLTextAreaElement;\n  \"tfoot\": HTMLTableSectionElement;\n  \"thead\": HTMLTableSectionElement;\n  \"title\": HTMLTitleElement;\n  \"tr\": HTMLTableRowElement;\n  \"ul\": HTMLUListElement;\n  \"li\": HTMLLIElement;\n  \"video\": HTMLVideoElement;\n}\n```\n\n## 4.2 Event Handler Function Types\n\nReact는 이벤트 핸들러 함수 유형을 제공하여 이벤트 핸들러의 타입을 지정할 수 있습니다. 이러한 유형은 요소 유형을 매개변수로 사용할 수 있는 제네릭입니다.\n\n4.2.1 onChange 이벤트\n\n\n\n\n이벤트 유형을 직접 사용하는 것 외에도 React의 이벤트 핸들러 유형을 사용할 수 있습니다. 이전에 언급한 input의 change 이벤트에 대해:\n\n```js\nconst handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n  setValue(event.target.value);\n};\n```\n\nReact.ChangeEventHandler 유형을 사용하여 다시 작성할 수 있습니다:\n\n```js\nconst handleChange: React.ChangeEventHandler<HTMLInputElement> = (event) => {\n  setValue(event.target.value);\n};\n```\n\n\n\n이벤트 객체는 자동으로 `React.ChangeEvent<HTMLInputElement>` 유형으로 추론됩니다.\n\n4.2.2 일반 이벤트 핸들러 함수 유형\n\n이벤트의 유형에 따라 React는 사용할 수 있는 다양한 이벤트 핸들러 함수 유형을 제공합니다:\n\n- React.MouseEventHandler: 클릭 또는 마우스 이동과 같은 마우스 이벤트에 대해.\n- React.ChangeEventHandler: 값이 변경될 때 주로 폼 요소 내의 변경 이벤트에 대해.\n- React.KeyboardEventHandler: 키 누름을 캡처하는 키보드 이벤트에 대해.\n- React.DragEventHandler: 드래그 앤드 드롭 상호작용에 대해.\n- React.FocusEventHandler: onFocus 및 onBlur와 같은 포커스 관련 이벤트에 대해.\n- React.FormEventHandler: 모든 관련 폼 상호작용을 아우르는 폼 이벤트에 대해.\n- React.WheelEventHandler: 스크롤링과 같은 마우스 휠 이벤트에 대해.\n- React.TouchEventHandler: 터치 기능 장치에서 터치 이벤트에 대해.\n- React.ClipboardEventHandler: 복사 및 붙여넣기와 같은 클립보드 이벤트에 대해.\n- React.AnimationEventHandler: CSS 애니메이션 이벤트에 대해.\n- React.TransitionEventHandler: CSS 전환 이벤트에 대해.\n\n\n\n위의 특정 함수 유형을 사용함으로써 이벤트 핸들러가 처리하는 이벤트 유형에 따라 올바르게 입력된 것을 보장하여 타입 안전성을 높이고 이벤트 처리 로직에서 잠재적인 버그를 방지할 수 있습니다.\n\n# 5. 유틸리티 타입\n\nTypeScript는 타입을 쉽게 조작할 수 있도록 도와주는 여러 유틸리티 타입을 제공하며, 수많은 타입을 수동으로 정의할 필요 없이 코드를 유연하고 재사용 가능하게 만들어줍니다.\n\n다음은 일반적으로 사용되는 유틸리티 타입에 대한 간단한 개요입니다:\n\n\n\n- Partial`T`: 이 유틸리티 타입은 타입 T를 가져와서 그 모든 속성을 옵션으로 만듭니다. 원본 타입의 모든 속성을 포함하지 않는 객체를 만들고 싶을 때 유용합니다.\n- Required`T`: Partial의 반대로, 이 유틸리티 타입은 타입 T를 가져와서 그 모든 속성을 필수로 만듭니다.\n- Readonly`T`: 이 유틸리티 타입은 타입 T를 가져와서 그 모든 속성을 읽기 전용으로 만듭니다. 즉, 값이 변경될 수 없습니다.\n- Record`K, T`: 이 유틸리티 타입은 타입 T의 일련의 속성 K를 가진 타입을 생성합니다. 고정된 키 집합으로 객체 타입을 만드는 데 유용합니다.\n- Pick`T, K`: 이 유틸리티 타입은 타입 T에서 속성 K 집합을 선택하여 타입을 생성합니다.\n- Omit`T, K`: 이 유틸리티 타입은 타입 T에서 속성 K 집합을 제외하여 타입을 생성합니다.\n- ReturnType`T`: 이 유틸리티 타입은 함수 타입을 가져와서 해당 반환 타입을 생성합니다.\n- InstanceType`T`: 이 유틸리티 타입은 생성자 함수 타입을 가져와서 해당 생성자에 의해 만들어진 인스턴스의 타입을 생성합니다.\n\n더 자세한 정보를 원하시면 이전의 기사를 참고해주세요:\n\n# 결론\n\n요약하면, TypeScript는 React 개발 경험을 향상시키는 강력한 기능 세트를 제공합니다. 엄격한 타입을 사용하여 컴포넌트의 속성과 상태를 정의하고 이벤트를 처리하며 유틸리티 제너릭을 활용하면 TypeScript는 코드 신뢰성과 유지 관리성을 보장합니다. 이 개념을 숙지하면 개발자는 더 예측 가능하고 오류에 강한 응용 프로그램을 만들 수 있습니다. TypeScript의 다양한 타입 및 유틸리티를 탐험하여 버그를 줄이고 팀원 간 협업을 개선할 수 있습니다. 즐거운 코딩 하세요!\n\n\n\n# 친절하게 말해보자 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 격려하고 팔로우하세요 ️👏️️\n- 팔로우해요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers_0.png","tag":["Tech"],"readingTime":15},{"title":"useEffect vs useLayoutEffect를 쉽게 이해하기","description":"","date":"2024-05-14 11:53","slug":"2024-05-14-useEffectvsuseLayoutEffectinplainlanguage","content":"\n\nuseEffect vs useLayoutEffect에 대한 차이점과 유사점을 발견하고, 언제 각각을 사용해야 하는지 배워보세요.\n\n![이미지](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_0.png)\n\n본 글에서는 useEffect와 useLayoutEffect의 기능, 차이점, 그리고 각각을 언제 사용해야 하는지 다룰 것입니다.\n\n시작하기 전, 간단하고 빠른 답변을 찾는 분들을 위해:\n\n\n\n이 두 가지 리액트 훅은 비슷한 기능을 하며 동일한 방식으로 작동합니다.\n\n차이점은 useLayoutEffect가 화면의 변경 사항을 사용자가 볼 수 있는 렌더링 이전에 호출되는 반면, useEffect는 사용자가 화면의 변경 사항을 볼 수 있는 렌더링 이후에 호출된다는 것입니다.\n\n나중에 이것이 무슨 의미인지 자세히 살펴보겠습니다.\n\n지금은 useLayoutEffect 예제와 useEffect 예제를 간단히 살펴보며 시작해보겠습니다.\n\n\n\n![이미지](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_1.png)\n\n# useLayoutEffect와 useEffect의 유사점은 무엇인가요?\n\nReact 훅인 useLayoutEffect와 useEffect는 실제로 사용법과 역할 측면에서 완전히 동일합니다. 두 훅의 서명(signature)은 동일합니다.\n\n그러므로 질문에 대한 대답은 매우 유사합니다. 두 훅을 구분하는 핵심적인 차이점이 단 하나뿐이라는 것입니다.\n\n\n\n이러한 훅은 React 컴포넌트에서 작업을 수행할 수 있게 해줍니다. 이 작업들은 조건부로 실행되어 매번 렌더링할 때마다 실행하는 것을 피해 비용이 많이든다.\n\n이제 useEffect에 대해 구체적으로 이야기해 보겠습니다. 이것은 React 내에서 사용되는 핵심 훅 중 하나로, useState와 함께 React에서 사용하는 중요한 요소입니다.\n\nuseEffect 훅은 API 호출, 상태 설정, 타이머 사용, 구독, 변이 등과 같은 다양한 작업을 수행하는 데 사용됩니다.\n\n다시 말해, 첫 번째 렌더링 시 또는 프롭이 변경될 때와 같이 가끔 실행하고 싶은 코드가 있다면, useEffect를 사용하여 실행할 수 있습니다.\n\n\n\nuseEffect를 사용하는 예제입니다:\n\n![useEffect Example](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_2.png)\n\n보시다시피 useEffect 후크가 있고, 이를 두 가지로 제공하고 있습니다. 콜백 함수와 의존성 배열입니다.\n\n콜백 함수에는 실행하려는 모든 코드와 해당 코드가 실행되어야 하는 조건이 포함될 것입니다 (필요한 경우).\n\n\n\n의존성 배열은 useEffect가 호출될 때 콜백을 조건부로 실행할 수 있는 변수 배열입니다.\n\n이 훅이 호출되면 리액트는 의존성 배열의 각 항목을 이전 버전과 비교합니다.\n\n만약 두 항목이 참조적 동일성(비교했을 때 동일함)을 가지고 있다면 콜백이 호출되지 않습니다. 그러나 일치하지 않는다면 콜백이 호출됩니다.\n\n여기 참조적 동일성의 빠른 예시입니다:\n\n\n\n![image](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_3.png)\n\n# useLayoutEffect vs useEffect의 차이점은 무엇인가요?\n\n이제 이 두 훅 간의 차이점에 대해 이야기해보겠습니다.\n\n이 게시물의 시작 부분에서 useEffect가 페이지와 상호 작용할 수 있는 시점에 실행되고, useLayoutEffect는 페이지와 상호 작용하기 전에 실행된다고 말했습니다. 그것에 대해 조금 더 자세히 살펴보고 코드에 대한 실제로 무슨 의미인지 이해해 봅시다.\n\n\n\n## 1. 실행 순서\n\nuseLayoutEffect은 화면을 그리기 위해 DOM을 기다리지 않고 즉시 실행됩니다. 이것은 실행 순서에 영향을 미칩니다.\n\nuseEffect 훅 안에서,\n\n```js\nuseEffect(() => {\nconsole.log(\"log 1\")\n}, [])\nuseEffect(() => {\nconsole.log(\"log 2\")\n}, [])\n```\n\n\n\n위 코드는 다음과 같이 출력됩니다:\n\n```js\nlog 1\nlog 2\n```\n\n이것은 useEffect와 함께 작업할 때 예상되는 동작입니다. 지정된 순서대로 실행됩니다.\n\n이제 두 번째 훅을 useLayoutEffect로 바꿔봅시다:\n\n\n\n```js\nuseEffect(() => {\nconsole.log(\"log 1\")\n}, [])\nuseLayoutEffect(() => {\nconsole.log(\"log 2\")\n}, [])\n```\n\n위의 출력결과,\n\n```js\nlog 2\nlog 1\n```\n\n예상대로, useLayoutEffect는 DOM 변이와 관계없이 실행되므로 useEffect 훅보다 더 빠르게 실행됩니다.\n\n\n\n## 2. 시각적 불일치\n\n복잡한 사용자 상호작용에 애니메이션이 포함된 경우 ref를 다룰 때 useEffect 대신 useLayoutEffect를 사용하는 것이 좋을 수 있습니다.\n\n```js\nReact.useLayoutEffect(() => {\n  console.log(ref.current)\n})\n```\n\n위의 예시에서 useLayoutEffect는 기다렸다가 값을 업데이트한 후 다른 코드 조각으로 넘어갑니다. useEffect 훅에서 발생하는 애니메이션 깜빡임을 개선할 수 있을 수도 있습니다.\n\n\n\n이것은 비싼 후크 실행과 부드러운 애니메이션 사이의 타협점입니다. 그러나 React는 작은 사용 사례에 대해 최적화되어 충분히 빠르기 때문에 두 가지 사이에 신경 쓸 필요가 없을 겁니다.\n\n## 3. useLayoutEffect 및 SSR\n\n악명 높은 useLayoutEffect 경고가 있습니다.\n\n“경고: 서버에서 useLayoutEffect는 아무것도 수행하지 않습니다. 왜냐하면 해당 효과가 서버 렌더러의 출력 형식으로 인코딩될 수 없기 때문입니다…\"\n\n\n\nSSR을 다룰 때는 JavaScript가 제대로 로드될 때까지 useEffect 및 useLayoutEffect가 작동하지 않습니다. 따라서 콘솔에서 위와 같은 경고 메시지를 볼 수 있습니다. useEffect는 컴포넌트의 렌더 주기와 상관이 없기 때문에 해당 경고가 발생하지 않는 것이며, useLayoutEffect는 사용자가 컴포넌트를 처음으로 렌더링할 때 사용자가 보게 될 사항을 고려하고 중요시합니다.\n\nReact 커뮤니티는 이 문제를 해결하기 위해 두 가지 방법을 제안합니다.\n\n1. 물론 가능하다면 useEffect 훅으로 변환해 보는 것이 첫 번째 시도입니다.\n\n2. useEffect에서 깜빡거림 문제가 있는 경우나 개발자가 useLayoutEffect를 필요로 하는 경우, 다른 방법으로는 JavaScript가 제대로 로드될 때까지 해당 훅을 사용하는 컴포넌트를 지연시키는 것이 될 수 있습니다. 다시 말해, React 컴포넌트를 게으르게 로드하는 방법입니다.\n\n\n\n# useLayoutEffect와 useEffect를 사용할 때에 대한 요약\n\nuseEffect를 사용하여 시작하는 것이 좋습니다. 대부분의 경우 그냥 그대로 두어도 될 것입니다.\n\n만약 useEffect를 사용할 때 DOM 변이가 있고 문제가 발생한다면, 예를 들어 UI가 한 가지에서 빠르게 다른 것으로 변경되는 상황이라면, useEffect가 시각적 변경 후에 로드되기 때문에 useLayoutEffect로 전환하는 것을 고려해야 합니다.\n\n마지막으로 useLayoutEffect와 useEffect의 차이를 기억하기 위한 도움이 되는 글:\n\n\n\n- useLayoutEffect: DOM 변경 후, 시각적 변화 전 그리고 브라우저가 그리기 전에 발생합니다. 이는 사용자가 코드를 기다려야 한다는 것을 의미합니다.\n- useEffect: DOM 변경 후, 시각적 변화 후, 그리고 브라우저가 이미 그린 후에 발생합니다. 이는 사용자가 코드를 기다릴 필요가 없다는 것을 의미합니다.\n\n만일 이 이야기를 즐겼다면 👏 버튼을 클릭하고 공유해 주세요. 다른 사람들도 발견할 수 있도록! 아래에 댓글을 남겨주시면 감사하겠습니다.\n\nGroww 엔지니어링팀은 기술 습작, 최신 기술 및 일반적인 프로그래밍 문제를 해결하는 더 나은 방법을 게시합니다. 최신 업데이트를 받으려면 여기에서 구독해주세요.\n\n저희는 채용 중입니다. 채용 공고를 확인하려면 여기를 클릭해주세요.","ogImage":{"url":"/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_0.png"},"coverImage":"/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_0.png","tag":["Tech"],"readingTime":5},{"title":"React Vite Typescript에서 SVG 사용하는 방법","description":"","date":"2024-05-14 11:52","slug":"2024-05-14-HowtoUseSVGinReactViteTypescript","content":"\n\nSVG(Scalable Vector Graphics)은 확장 가능성과 유연성으로 현대 웹 개발에서 중요한 역할을 하고 있어요. React와 결합하면 동적이고 시각적으로 멋진 사용자 인터페이스를 만들 수 있는 무궁무진한 가능성이 열립니다. 이 안내서에서는 SVG를 React 프로젝트에 효과적으로 통합하는 방법을 살펴볼 거에요.\n\n구현 세부 사항에 들어가기 전에, React 내에서 SVG 기초를 이해하는 게 중요해요. React에서 SVG 요소는 일반 HTML 요소와 마찬가지로 JSX 내에 매끄럽게 통합될 수 있어요. 이 통합은 React의 상태와 프롭 메커니즘을 활용하여 SVG 요소를 동적으로 조작하는 데 개발자들에게 힘을 실어줘요. 결과적으로 SVG 그래픽은 애플리케이션 상태 변경에 반응하여 매우 유연하며 매력적인 사용자 인터페이스를 만드는 데 도움이 돼요.\n\n```js\nnpm install vite-plugin-svgr\n```\n\n- vite-plugin-svgr: 이것은 설치되는 npm 패키지의 이름이에요. \"vite-plugin-svgr\"은 Vite와 함께 작동하도록 설계된 플러그인이에요. Vite는 빠른 개발 서버, 최적화된 프로덕션 빌드 등 다양한 기능을 제공하는 차세대 프런트엔드 도구에요. 이 특정 플러그인을 사용하면 Vite로 구동되는 React 프로젝트에서 SVG 파일을 직접 구성 요소로 사용할 수 있어요. SVGR 라이브러리를 활용하는 거죠.\n\n\n\nTypeScript로 작업하는 Vite 프로젝트에서는 컴포넌트, 모듈 또는 기타 TypeScript 파일에 대해 TypeScript 선언 파일(.d.ts 파일)을 생성해야 할 수 있습니다. 선언 파일은 TypeScript 코드에 대한 유형 정보를 제공하고 더 나은 IDE 지원, 유형 확인 및 코드 문서화를 가능하게 합니다.\n\n```js\nnpm install vite-plugin-dts\n```\n\n```js\nimport { defineConfig } from \"vite\";\nimport svgr from \"vite-plugin-svgr\";\nimport dts from \"vite-plugin-dts\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  build: {\n    outDir: \"build\",\n  },\n  plugins: [ svgr(), dts(), react()],\n});\n```\nvite.config.ts 파일을 해당 내용으로 변경하세요.\n\n\n\n루트 디렉토리에 svg.d.ts라는 파일을 만들어주세요.\n\n```js\ndeclare module \"*.svg?react\" {\n  import { FunctionComponent, SVGAttributes } from \"react\";\n  const content: FunctionComponent<SVGAttributes<SVGElement>>;\n  export default content;\n}\n```\n\n위의 코드를 svg.d.ts 파일에 붙여넣기해주세요.\n\n```js\n\"include\": [\"src\",\"src/vite-env.d.ts\"],\n```\n\n\n\n이제 tsconfig.json에 위 src, src/vite-env.d.ts를 추가하세요.\n\n그런 다음 Svg를 Component로 가져와서 React Component로 사용할 수 있습니다.\n\n```js\nimport CollectHoverIcon from \"../../assets/Collections.svg?react\";\n```\n\n이제 이 Svg를 React Component로 가져올 수 있습니다. 가져오는 디렉토리 끝에 ?react을 추가하는 것을 잊지 마세요.\n\n\n\n파일 경로에 \"?react\"가 추가되어 있는 경우, 보통 이는 SVG 파일이 React 사용을 위해 특정 최적화나 변환을 적용하여 가져오고 있음을 나타냅니다. 많은 경우, 이는 SVG 파일이 정적 자산이 아닌 React 구성 요소로 가져올 수 있다는 의미일 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-HowtoUseSVGinReactViteTypescript_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoUseSVGinReactViteTypescript_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 네이티브 또는 엑스포 앱에서의 I18n","description":"","date":"2024-05-14 11:51","slug":"2024-05-14-I18ninYourReactNativeorExpoApps","content":"\n\n<img src=\"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png\" />\n\n현대 기술 생태계에서 지리적 경계를 넘어 전 세계 관객을 대상으로 서비스를 제공하는 것이 예외가 아닌 표준이 되었습니다.\n\ni18n-js로 시작하기\n\n# 설치\n\n\n\n```js\n# npm\nnpm install i18n-js expo-localization\n\n# yarn\nyarn add i18n-js expo-localization\n\n# pnpm\npnpm add i18n-js expo-localization\n\n# bun\nbun add i18n-js expo-localization\n```\n\n## 그런 다음 루트 또는 src 폴더에 i18n.ts 파일을 생성하십시오.\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n  en: {\n    hello: \"hello %{name}!\"\n  },\n  zh: {\n    hello: \"안녕하세요 %{name}!\"\n  },\n});\n\ni18n.defaultLocale = deviceLanguage;\n\ni18n.locale = deviceLanguage;\n```\n\n## 그러면 locales 폴더에 다국어 JSON 파일을 생성할 수 있습니다.\n\n\n\n```js\n// (root)/src/locales/en.json\n{\n hello: \"안녕 %{name}!\"\n}\n```\n\n```js\n// (root)/src/locales/zh.json\n{\n hello: \"안녕하세요 %{name}!\"\n}\n```\n\ni18n.ts 변경사항\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\n+import en from '../locales/en.json';\n+import zh from '../locales/zh.json';\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n+  en,\n+  zh,\n});\n\ni18n.defaultLocale = deviceLanguage;\n\ni18n.locale = deviceLanguage;\n```\n\n\n\n이제 컴포넌트에서 사용할 수 있어요. 여기 컴포넌트에서 translate 함수를 사용하는 예시가 있어요.\n\n```js\n// example.tsx\nimport { i18n } from '../lib/i18m';\n\nfunction Example() {\n return <div>{i18n.t(\"hello\", {name: \"Toy\"})}</div>\n}\n```\n\n하지만 로컬을 변경하고 싶어요, 어떻게 해야 할까요?\n\n걱정 마세요, i18n.ts 파일에 changeLanguage 함수를 정의할 수 있어요.\n\n\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\nimport en from '../locales/en.json';\nimport zh from '../locales/zh.json';\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n  en,\n  zh,\n});\n\ni18n.defaultLocale = deviceLanguage;\ni18n.locale = deviceLanguage;\n\n+ export function changeLanguage(lang: string) {\n+  i18n.locale = lang;\n+ }\n```\n\n그런 다음 이 함수를 언어 변경 컴포넌트에 사용할 수 있습니다.\n\n```js\n// example.tsx\nimport { i18n, changeLanguage } from '../lib/i18n';\nimport { View, Button } from 'react-native';\n\nfunction Example() {\n return (\n  <View>\n   <View>{i18n.t(\"hello\", {name: \"Toy\"})}</View>\n   <Button onPress={() => changeLanguage('zh')} title=\"언어 변경\"/>\n  </View>\n );\n}\n```\n\n너무 간단해 보이지 않나요? 이 패키지는 매우 강력하고 실용적입니다.\n\n\n\n\n이 라이브러리는 Rails-i18n에서 제공하는 기본 번역을 사용할 수 있습니다.\n\n마지막으로, i18n-js에서 더 많은 정보를 읽으려면 공식 문서로 이동할 수 있습니다.\n\nReact Native 및 Expo 앱에서 i18n을 채택하면 미래를 대비한 글로벌 확장의 길이 열립니다. 국제화는 일회성 작업이 아닌 앱이 전 세계에서 관련성을 유지하고 접근성이 있으며 사용자 친화적인 지속적인 의무라는 것을 명심해야 합니다.\n\n경험 많은 개발자이든 처음 국제화를 시작하는 중이든, 전 세계적인 모바일 앱을 개발하는 길은 당신 손안에 있으며, i18n-js는 이 추구에서 믿을 수 있는 동료입니다. React Native 및 Expo 앱의 최대 잠재력을 발휘하여 세계의 언어로 강화시키는 시간입니다.\n\n\n\n이 기사를 읽어 주셔서 감사합니다. 최대한 많이 박수/추천 해 주시고 친구들과 공유도 꼭 해주세요. 제게는 매우 중요한 일이죠.","ogImage":{"url":"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png"},"coverImage":"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png","tag":["Tech"],"readingTime":3},{"title":"React에서 네비게이션 이벤트를 모의하고 테스트하는 방법 Vitest","description":"","date":"2024-05-14 11:50","slug":"2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest","content":"\n\n리액트 페이지 탐색 이벤트를 테스트하고 싶어서 노력 중이었는데, 가져온 모듈 함수를 MOCK 하는 것이 필요해 전혀 익숙하지 않았어요. \n\n마침내 어떻게 해결했는지 공유하고 싶어요. 물론, 이 예제는 정교하거나 높은 자격 요건을 갖춘 것은 아니라서 여러분의 생각과 추천 대안을 공유해주시면 정말 감사하겠어요. 이 글이 몇몇 독자들에게 도움이 되었으면 좋겠어요.\n\n** 이 문서는 테스트 환경 설정에 대한 내용을 다루지 않고 직접 내용으로 들어갑니다.\n\n## 무엇을 테스트할 것인가\n\n\n\n리액트 애플리케이션이 두 가지 접근 가능한 경로, /와 /todos를 가지고 있습니다. StartPage.test.tsx 파일은 홈 경로에 대한 유닛 테스트 파일이며, \"todos\" 텍스트를 가진 버튼이 클릭되었을 때 애플리케이션이 사용자를 /todos 페이지로 이동시키는지 테스트하고 싶습니다.\n\n## 문제 발생\n\n하지만 테스트 라이브러리 관점에서 이야기를 해보겠습니다. \"사용자를 다른 페이지로 이동시킨다\"는 것의 의미는 무엇인가요?\n\n```js\nimport useNavigation from \"@hooks/useNavigation\";\n\nexport default function StartPage() {\n  const { push } = useNavigation();\n  return (\n    <div>\n      <h1>start</h1>\n      <button\n        onClick={() => {\n          push(\"/todos\");\n        }\n      >\n        todos\n      </button>\n    </div>\n  );\n}\n```\n\n\n\n사용자가 \"todos\" 버튼을 클릭하면, onclick 핸들러가 실행되고, 그런 다음 push 함수가 실행됩니다. push 함수는 useNavigation 훅 호출에서 반환된 함수 중 하나입니다. 문제는 테스트 코드가 push 또는 useNavigation이 어떻게 구성되어 있는지를 모르기 때문에, 테스트 함수에 이 함수들이 어떻게 되어야 하는지 알려주어야 합니다. 이 과정을 함수 모의(mocking functions)라고 합니다.\n\n## `MemoryRouter` 내부의 단위\n\n테스트 함수를 작성하기 전에, 테스트된 컴포넌트가 react-router-dom의 Router 내에 있어야 한다는 점을 명확히해야 합니다. 그렇지 않으면 여러 경로가 없을 수 있고, 컴포넌트 함수에서 useNavigation 훅을 사용할 수 없습니다. 이 문제는 단위 컴포넌트를 react-router-dom의 `MemoryRouter` 컴포넌트로 감싸면 쉽게 처리할 수 있습니다. Router에 initialEntries prop을 제공하여 애플리케이션의 위치를 지정할 수 있습니다.\n\n```js\n// ...\n\nbeforeEach(() => {\n   render(<StartPage />, {\n    wrapper: ({children}) => (\n      <MemoryRouter initialEntries={[\"/\"]}>\n        {children}\n      </MemoryRouter>\n    ),\n  });\n});\n\n// ...\n```\n\n\n\n## 목 역할 하는 방법\n\n테스트 작업 환경인 jest와 비슷한 기능을 가진 vitest는 jest testing 환경의 vi 속성을 제공하여 변수와 함수를 mock할 수 있습니다. vi.fn 메소드는 \"함수를 스파이로 생성\"하고, vi.mock 메소드는 첫 번째 인수로 지정된 경로에서 import된 모든 모듈을 대체합니다.\n\n```js\nimport { vi } from \"vitest\";\n\nconst mockPush = vi.fn();\n\nvi.mock(\"@hooks/useNavigation\", () => {\n  return {\n    // useNavigation\n    default: () => ({\n      push: mockPush,\n    }),\n  };\n});\n```\n\n위의 예시에서 vi.mock은 \"@hooks/useNavigation\" 경로에서 import된 모듈의 형태를 정의합니다. 이 모듈은 \"push\"라는 함수를 반환하는 기본 내보내기를 가지고 있습니다. 이제 모듈의 구조가 알려졌으며, 테스트 함수 내에서 스파이 변수인 mockPush를 사용하여 push 메소드에 접근할 수 있습니다. 이 모킹된 함수가 호출될 때 어떤 인수와 함께 호출되었는지 mockPush.mock.calls 또는 mockPush.mock.lastCall을 사용하여 확인할 수 있습니다. 이는 인수 목록을 제공합니다.\n\n\n\n```js\ntest(\"버튼 클릭 시 /todos 페이지로 이동해야 함\", async () => {\n  const button = (await screen.findAllByText(\"todos\"))[0];\n  expect(button).toBeDefined();\n  await userEvent.click(button);\n\n  console.log(\"호출\", mockPush.mock.calls);\n  // calls [ [ '/todos' ] ]\n  console.log(\"마지막 호출\", mockPush.mock.lastCall);\n  // last call [ '/todos' ]\n});\n```\n\n여기서 만약 lastCall의 첫 번째 항목이 \"/todos\"이면, \"todos\" 버튼 클릭 이벤트의 예상 결과로써 push 메소드가 \"/todos\" 인자와 함께 호출된 것이라고 말할 수 있습니다.\n\n```js\ntest(\"버튼 클릭 시 /todos 페이지로 이동해야 함\", async () => {\n  const button = (await screen.findAllByText(\"todos\"))[0];\n  expect(button).toBeDefined();\n  await userEvent.click(button);\n\n  expect(mockPush.mock.lastCall[0]).toEqual(\"/todos\");\n});\n```\n\n마지막으로, 각 테스트 후에 mock 기록을 제거하기 위해 vi.clearAllMocks 메소드를 호출하는 것이 좋습니다.\n\n\n\n```js\nconst mockPush = vi.fn();\n\nvi.mock(\"@hooks/useNavigation\", () => {\n  return {\n    // useNavigation\n    default: () => ({\n      push: mockPush,\n    }),\n  };\n});\n\ndescribe(\"start page test\", () => {\n  beforeEach(() => {\n    render(<StartPage />, {\n      wrapper: ({children}) => (\n        <MemoryRouter initialEntries={[\"/\"]}>\n          {children}\n        </MemoryRouter>\n      ),\n    });\n  });\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  test(\"should navigate to /todos page on button click\", async () => {\n    const button = (await screen.findAllByText(\"todos\"))[0];\n    expect(button).toBeDefined();\n    await userEvent.click(button);\n\n    expect(mockPush.mock.lastCall[0]).toEqual(\"/todos\");\n  });\n});\n```","ogImage":{"url":"/assets/img/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest_0.png"},"coverImage":"/assets/img/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest_0.png","tag":["Tech"],"readingTime":4},{"title":"SSR와 CSR란 무엇인가 간단히 설명하기","description":"","date":"2024-05-14 11:49","slug":"2024-05-14-WhatisSSRandCSRAsimpleexplanation","content":"\n\n웹 개발 세계에서 자주 만나는 두 용어는 SSR (서버 측 렌더링)와 CSR (클라이언트 측 렌더링)입니다. 두 용어는 웹 애플리케이션에서 콘텐츠가 표시되고 처리되는 방식에 상당한 영향을 미칩니다. 이 글에서는 이러한 개념을 자세히 살펴보고 그 차이점과 유사점을 알아보며, 어떤 경우에 한 가지를 다른 것보다 선호해야 하는지 이해해보겠습니다.\n\n![SSR](/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png)\n\n# 서버 측 렌더링 (SSR)\n\n## SSR이란?\n\n\n\n서버 측 렌더링(SSR)은 웹 페이지가 브라우저로 전송되기 전에 서버에서 생성되는 방식입니다. 다시 말해, 서버가 페이지의 로직과 구조를 처리하고 완전히 렌더링된 페이지를 사용자의 브라우저로 보냅니다.\n\n## SSR의 장점\n\n- SEO 개선: 서버에서 렌더링된 페이지는 컨텐츠가 이미 클라이언트로 전송되는 초기 HTML에 포함되어 있기 때문에 검색 엔진 친화적입니다.\n- 초기 성능 개선: 사용자들이 페이지 렌더링이 완료된 페이지를 처음부터 받기 때문에 컨텐츠를 빠르게 볼 수 있습니다.\n\n## React를 사용한 SSR의 예시\n\n\n\nNext.js는 인기 있는 React 프레임워크로, SSR을 간단하게 구현할 수 있게 해줘요.\n\n## Step 1: Next.js 설치하기\n\n```js\nnpx create-next-app my-nextjs-app\ncd my-nextjs-app\n```\n\n## Step 2: SSR 페이지 만들기\n\n\n\nIn pages/index.js 파일:\n\n```js\n// pages/index.js\nconst HomePage = ({ data }) => {\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n};\n\nexport async function getServerSideProps() {\n  // API나 데이터베이스에서 데이터 가져오는 로직\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n\n  return {\n    props: { data },\n  };\n}\n\nexport default HomePage;\n```\n\n# 클라이언트 사이드 렌더링 (CSR)\n\n## CSR이란?\n\n\n\n클라이언트 측 렌더링(CSR)은 브라우저가 빈 페이지를로드하고 JavaScript를 사용하여 해당 페이지를 콘텐츠로 채우는 것을 의미합니다. 이 경우 브라우저는 사용자 인터페이스를 만들고 제공하는 데 더 활발한 역할을 합니다.\n\n## CSR의 장점\n\n- 향상된 상호 작용: CSR 애플리케이션은 전체 페이지를 다시로드할 필요없이 사용자 인터페이스를 업데이트할 수 있어 더 많은 상호 작용성을 제공합니다.\n- 낮은 초기 로드: 초기 페이지로드가 더 빠를 수 있으며 브라우저로는 애플리케이션의 뼈대만 전송됩니다.\n\n## React를 활용한 CSR의 예시\n\n\n\nCreate React App를 사용하여 간단한 클라이언트 측 렌더링 예제를 만들어보겠습니다.\n\n## 단계 1: React 앱 만들기\n\n```js\nnpx create-react-app my-react-app\ncd my-react-app\n```\n\n## 단계 2: 클라이언트 측 렌더링 구현하기\n\n\n\n[src/App.js 파일]\n\n```js\n// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () => {\n  const [data, setData] = useState({});\n\n  useEffect(() => {\n    // 앱이 로드된 후 데이터를 가져오기 위한 로직\n    fetch('https://api.example.com/data')\n      .then((response) => response.json())\n      .then((data) => setData(data));\n  }, []);\n\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n# 각 접근 방식의 비교 및 언제 사용해야 하는지\n\n두 가지 방법에는 각각 장단점이 있습니다. SSR과 CSR 중 어떤 것을 선택할지는 애플리케이션의 특정 요구 사항에 따라 다릅니다. 일반적인 지침은 다음과 같습니다:\n\n\n\nSSR을 사용해보세요:\n\n- SEO를 개선하고 싶을 때.\n- 초기 성능을 향상시키고 싶을 때.\n\nCSR을 사용해보세요:\n\n- 매우 상호 작용형 애플리케이션을 갖고 있을 때.\n- 더 빠른 초기 로드를 원할 때.\n\n\n\n# 요약\n\n요약하자면, SSR과 CSR은 웹 페이지를 렌더링하는 데 사용되는 서로 다른 방법론입니다. SSR은 SEO 및 초기 성능 향상에 도움이 되지만, CSR은 보다 인터랙티브한 경험을 제공합니다. 둘 중 어떤 것을 선택할지는 애플리케이션의 목표와 구체적인 요구 사항에 따라 다릅니다.\n\n애플리케이션을 디자인할 때 사용자 요구 사항, 성능 요구 사항, 그리고 선택 사항이 검색 엔진에서 콘텐츠의 가시성에 어떻게 영향을 미칠지를 고려해야 합니다. 많은 경우, SSR과 CSR을 결합한 \"수분화\" 기술을 사용하는 것이 최상의 선택일 수 있습니다. 프로젝트의 고유한 특성에 따라 실험하고 조정해보세요.\n\n이 문서가 도움이 되었다면 망설이지 말고 팔로우, 구독, 박수를 부탁드립니다. 감사합니다!","ogImage":{"url":"/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png"},"coverImage":"/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png","tag":["Tech"],"readingTime":3},{"title":"useRef 훅 렌더링 제로로 가는 길 안내","description":"","date":"2024-05-14 11:48","slug":"2024-05-14-useRefHookGuidetozerore-render","content":"\n\n리액트는 사용자 인터페이스를 구축하기 위한 인기 있는 자바스크립트 라이브러리로, 응용 프로그램의 문서 객체 모델(DOM)을 효과적으로 관리하는 중요한 useRef라는 강력한 후크를 제공합니다. 이 안내서에서는 useRef가 무엇인지, 어떻게 효과적으로 사용하는지, 그리고 실제 시나리오에서의 다양한 응용 방법을 살펴볼 것입니다.\n\n![이미지](/assets/img/2024-05-14-useRefHookGuidetozerore-render_0.png)\n\n# useRef 소개:\n\nuseRef 후크는 리액트의 기본 요소로, 개발자가 ref라고 불리는 변경 가능한 객체를 만들 수 있게 합니다. 상태 변수와 달리 ref는 값이 변경되어도 다시 렌더링을 유발하지 않습니다. useRef의 주요 목적은 DOM에 직접 액세스하고 상호 작용하는 것으로, 개발자가 포커스를 관리하고 양식을 처리하며 애니메이션을 효과적으로 다룰 수 있도록 합니다.\n\n\n\n```js\nimport React, { useRef, useEffect } from 'react';\n\nfunction MyComponent() {\n  // ref 객체 생성\n  const myRef = useRef();\n\n  // ref를 React 요소에 연결\n  useEffect(() => {\n    myRef.current.innerText = '안녕하세요, useRef!';\n  }, []);\n\n  return <div ref={myRef}></div>;\n}\n```\n\n이 예제에서는 useRef를 사용하여 ref를 생성하고 div 요소에 연결합니다. useEffect 훅은 컴포넌트가 마운트될 때 div의 inner text를 설정하는 데 사용됩니다.\n\n```js\nimport React, { useEffect, useRef } from \"react\";\n\nfunction App() {\n  const inputRef = useRef();\n\n  useEffect(() => {\n    inputRef.current.innerText =\n      \"useRef의 초기 값은 useEffect가 초기 렌더링 시 실행되어 업데이트됩니다.\";\n  }, []);\n\n  const focusInput = () => {\n    // DOM 요소 직접 액세스 및 수정\n    inputRef.current.innerText = \"focusInput 호출됨\";\n  };\n\n  const focusOutput = () => {\n    // DOM 요소 직접 액세스 및 수정\n    inputRef.current.innerText = \"focusOutput 호출됨\";\n  };\n\n  return (\n    <div>\n      <div ref={inputRef} className=\"mb-4 p-2\">\n        {/* 필요시 inner text에 스타일링 추가 */}\n      </div>\n\n      <button onClick={focusInput} className=\"bg-violet-400 p-2 block mb-4\">\n        Focus Input 호출\n      </button>\n      <button onClick={focusOutput} className=\"bg-cyan-400 p-2 block\">\n        Focus Output 호출\n      </button>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*eTiF-2EjQFlx-u22tEPdpA.gif\" />\n\n\n\n\n## 최선의 실천방법:\n\n직접 DOM 조작을 피하세요: Refs는 DOM에 직접 액세스를 제공하지만 가능한 경우 React의 선언적 접근을 사용하는 것이 좋습니다.\n\n적절한 정리를 보장하세요: 컴포넌트 내에서 ref를 생성한 후에 해당 컴포넌트를 DOM에서 제거하면 메모리 누수를 방지하기 위해 ref를 정리해야 합니다.\n\n## 실제 적용 사례:\n\n\n\n## 서드파티 라이브러리 관리: 직접 DOM 조작이 필요한 서드파티 라이브러리 통합 시, useRef는 유용한 도구가 될 수 있어요.\n\n성능 최적화: 다시 렌더링을 유발하지 않고 렌더링 간 값 유지가 필요한 경우, useState 대신 useRef를 사용하면 성능상 이점을 제공할 수 있어요.\n\n## 다른 훅들과 비교:\n\nuseState: 업데이트될 때 다시 렌더링을 유발하는 상태를 관리하는 경우 useState를 사용하세요.\n\n\n\n`useEffect`을 사용할 때는 부가 효과와 라이프사이클 메소드에 주로 사용되지만, `useRef`는 DOM에 직접 접근하고 상호 작용하는 데 중점을 둡니다.\n\n# FAQ\n\n## React에서 useRef 훅의 주요 용도는 무엇인가요?\n\n`useRef`는 주로 React 컴포넌트에서 DOM에 직접 접근하고 상호 작용하는 데 사용됩니다.\n\n\n\n## useRef 객체의 주요 속성은 무엇이며 어떻게 접근할 수 있나요?\n\n주요 속성은 current이며 ref.current 구문을 통해 접근할 수 있습니다.\n\n## useRef와 useState의 다른 점은 무엇인가요?\n\n반면에 ref.current 값을 수정해도 다시 렌더링을 일으키지 않습니다. useRef는 컴포넌트가 다시 렌더링되지 않고도 값의 지속성을 유지하고 싶을 때 유용합니다.\n\n\n\n📚이전 포스트:\n\n👉 React Hooks: useState & useEffect\n👉 React 함수형 컴포넌트와 Hooks 이해하기\n👉 useContext Hooks를 활용한 React 상태 관리 재고\n👉 React Props 언플러그드: 데이터 흐름 해제하기\n\n🔍 다음에는:\n\n👉 useLayoutEffect Hook\n👉 useMemo Hook\n👉 useCallback Hook\n\n\n\n웹 개발 세계에서 더 많은 통찰력을 기대해주세요! 🚀📦\n\n🤝 LinkedIn에서 함께해요: [LinkedIn 프로필 링크](https://www.linkedin.com/in/omkarbhavare/)","ogImage":{"url":"/assets/img/2024-05-14-useRefHookGuidetozerore-render_0.png"},"coverImage":"/assets/img/2024-05-14-useRefHookGuidetozerore-render_0.png","tag":["Tech"],"readingTime":3},{"title":"Three JS와 React Three Fiber를 사용하여 웹사이트를 만들어보세요","description":"","date":"2024-05-14 11:45","slug":"2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber","content":"\n\nThree JS와 React Three Fiber(R3F)를 사용하여 웹사이트를 만드는 단계별 튜토리얼.\n\n참고: 저처럼 조금 게을러진 분들을 위해 😎, 최종 코드에 액세스하려면 이 링크를 따르는 게 좋아요. 코드는 아마 있을 거에요, 하지만 완벽하게 이해하지 못할 거에요 🤣. 믿어봐요 !!!. 복사/붙여넣기도 좋지만, 과정을 이해하는 게 더 낫죠 😉 그리고 빨간 선이 나오면 뭐라도 소리 내 면 안 된답니다 😂.\n\n# 단계 1: Vite를 사용하여 새 React 프로젝트 설정하기.\n\n터미널을 열고 다음 명령을 실행하여 Vite를 사용하여 새 React 프로젝트를 생성하세요:\n\n\n\n```js\nnpm create vite@latest\n```\n\n<img src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_0.png\" />\n\n프로젝트 이름을 작성하고 ENTER를 누르세요.\n\n<img src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_1.png\" />\n\n\n\n\nVite는 선택할 수 있는 다양한 프레임워크를 제공합니다. 이 프로젝트에서는 React를 사용하고 있으니 React로 이동하려면 아래 방향키를 누르고 ENTER 키를 누르세요.\n\n![React](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_2.png)\n\nReact에서는 TypeScript 또는 JavaScript를 사용할 수 있습니다. 저희는 JavaScript를 사용할 예정이므로 아래 방향키를 사용하여 JavaScript를 선택하세요. ENTER 키를 누르세요.\n\n![JavaScript](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_3.png)\n\n\n\n위의 이미지에서 보이는 폴더 구조를 얻을 수 있습니다. 아직 종속성이 설치되지 않았으므로 먼저 설치해야 합니다. VS 코드 터미널에서 다음 명령어를 입력해주세요:\n\n```js\ncd project-name \n```\n\n여기서 cd는 디렉토리 변경을 의미합니다. 'project-name'을 여러분의 프로젝트 이름으로 바꾼 후 ENTER 키를 눌러주세요.\n\n그런 다음 VS 터미널에서 다음 몤령어를 입력하세요.\n\n\n\n```js\nnpm 설치\n```\n\n![Three JS and React Three Fiber](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_4.png)\n\n# 단계 2: 필수 종속성 설치하기.\n\n이제 종속성을 설치했으니 프로젝트에 Three JS, React Three Fiber 및 React Three Drei를 추가해야 합니다.\n\n\n\n터미널에 다음 명령어를 입력해주세요:\n\n```js\nnpm i three @react-three/fiber @types/three @react-three/drei\n```\n\n참고: npm i는 npm install의 약식 표현입니다.\n\n# 단계 3: 프로젝트 실행하기. \n\n\n\n이제 필요한 모든 종속 항목을 갖췄으니 브라우저에서 React 앱을 확인할 수 있습니다. 터미널에 다음 명령을 입력하세요:\n\n```js\nnpm run dev\n```\n\n![이미지](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_5.png)\n\n링크 위로 마우스를 올리고 링크를 ctrl 키를 누른 채 클릭하면, 브라우저가 열립니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_6.png\" />\n\n\"축하합니다\" React 앱을 만들었어요 😁.\n\n# 단계 4: 코드 정리.\n\n웹사이트는 이미 좋아 보이지만 우리가 원하는 것은 아닙니다. 코드를 정리할 시간입니다.\n\n\n\nApp.js 파일에서 다음 코드를 모두 제거해주세요:\n\n```html\n<img src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_7.png\" />\n```\n\n그리고 App.css와 index.css에서 모든 CSS 코드도 제거해주세요.\n\n이제 브라우저를 확인하면 하얗게 보일 거예요. 이제 \"멋진 웹사이트\"를 만들기 시작할 수 있습니다.\n\n\n\n# 단계 5: 장면 생성하기.\n\n리액트 앱에서 Three JS 장면을 사용하려면 캔버스를 만들어야 합니다. 물론 `canvas` HTML 태그를 사용할 수 있지만, 대신 React Three Fiber (R3F) 패키지를 설치했습니다. 이 패키지는 Three.js를 React 애플리케이션에 원활하게 통합할 수 있는 방법을 제공합니다.\n\n아래 코드를 App.js에 작성해주세요:\n\n```js\nimport * as THREE from \"three\"\nimport './App.css'\nimport { Canvas } from \"@react-three/fiber\"\n\nfunction App() {\n\n  return (\n    <>\n      <Canvas></Canvas>\n    </>\n  )\n}\n\nexport default App\n```\n\n\n\n여기에서는 \"three\"로부터 세 개의 JS와 \"React Three Fiber\"로부터 Canvas를 가져왔습니다. 이제 모든 것을 Canvas 안에서 처리할 거에요. Canvas는 Three JS를 사용하여 3D 캔버스를 생성하기 위해 React Three Fiber에서 제공하는 구성 요소입니다.\n\n이제 Canvas에 속성을 추가해보세요 :\n\n```js\nfunction App() {\n\n  return (\n    <>\n      <Canvas gl={{ antialias: false }} dpr={[1, 1.5]}>\n        \n      </Canvas>\n    </>\n  )\n}\n```\n\n여기서 :\ngl=' antialias: false ' : 이 속성은 WebGL(웹 그래픽 라이브러리) 렌더러 설정을 Canvas 구성 요소에 전달하는 데 사용됩니다. 이 경우에는 antialias 속성을 false로 설정합니다. 안티앨리어싱은 컴퓨터 그래픽의 날카로운 가장자리를 부드럽게 만드는 기술입니다. 이를 false로 설정하면 성능이 향상됩니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_8.png\" />\n\ndpr='[]' : 이 속성은 캔버스의 장치 픽셀 비율(device pixel ratio, dpr)을 설정합니다. 장치 픽셀 비율은 장치 화면의 물리적 픽셀과 논리적 픽셀의 비율입니다. 이 경우 배열 [1, 1.5]로 설정되어 있습니다. 이는 캔버스가 윈도우가 고해상도(DPI, 인치 당 점)가 아닐 때 장치 픽셀 비율이 1이 되고, 고해상도일 때 1.5가 됨을 의미합니다. 이는 고해상도 디스플레이에서 선명한 그래픽을 렌더링하는 데 도움이 될 수 있습니다.\n\n# 단계 6: 캔버스에 큐브 렌더링하기.\n\n이제 브라우저에 무언가를 표시해 봅시다.\n\n\n\n```js\n  function App() {\n  return (\n    <>\n      <Canvas gl={{ antialias: false }} dpr={[1, 1.5]}>\n        <mesh>\n          <boxGeometry />\n        </mesh>\n      </Canvas>\n    </>\n  );\n}\n```\n\n위의 코드를 App.js에 추가하고 저장해주세요. 또한, 이 프로젝트에서는 mesh와 geometry를 사용하지 않기 때문에 Three JS 문서를 확인하여 더 자세한 내용을 알아보세요. 이제 브라우저를 확인해보면 다음과 같이 작은 사각형이 보입니다 :\n\n<img src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_9.png\" />\n\n이것은 우리의 코드가 작동 중이라는 것을 의미합니다 😳. 이제 사각형을 더 크게 만들기 위해 다음 CSS 코드를 App.css에 추가해주세요 :\n\n\n\n```js\n* {\n  box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n}\n```\n\n여기서는 Canvas에 100%의 높이와 너비를 제공하여 캔버스가 전체 화면을 차지할 수 있도록합니다. 또한 페이지의 모든 기본 여백과 간격을 제거합니다. 이제 브라우저에서 이렇게 나타날 것입니다.\n\n<img src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_10.png\" />\n\n# 단계 7: 텍스트 추가하기.\n\n\n\n이제 캔버스에 텍스트를 추가할 시간입니다. 이전에 사용한 코드 대신에 다음 코드를 App.js에 추가해보세요:\n\n```js\nimport * as THREE from \"three\";\nimport \"./App.css\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { Scroll, ScrollControls } from \"@react-three/drei\";\n\nfunction App() {\n  return (\n    <>\n      <Canvas gl={ antialias: false } dpr={[1, 1.5]}>\n        <ScrollControls damping={2} pages={5}>\n          <Scroll html>\n            <h1 style={ position: \"absolute\", top: \"60vh\", left: \"0.2em\" }>\n              Make\n            </h1>\n            <h1 style={ position: \"absolute\", top: \"120vh\", left: \"60vw\" }>\n              Scroll\n            </h1>\n            <h1\n              style={\n                position: \"absolute\",\n                top: \"210.5vh\",\n                left: \"0.5vw\",\n                fontSize: \"20vw\",\n              }\n            >\n              Creative\n            </h1>\n            <h1\n              style={\n                position: \"absolute\",\n                top: \"330.5vh\",\n                left: \"50rem\",\n                fontSize: \"10vw\",\n              }\n            >\n              And Flawless\n            </h1>\n          </Scroll>\n        </ScrollControls>\n      </Canvas>\n    </>\n  );\n}\n\nexport default App;\n```\n\n우리는 React Three Drei에서 scrollControls를 사용하고 있습니다. scrollControls는 캔버스 앞에 HTML 스크롤 컨테이너를 만듭니다. `Scroll` 컴포넌트에 추가하는 모든 것에 영향을 줄 것입니다.\n\n이제 props에 대해 이야기해볼까요:\n\n\n\ndamping='2' : 이 속성은 스크롤의 감쇠 계수를 제어합니다.\n\n감쇠는 물리학과 애니메이션에서 자주 사용되는 수학적 개념으로, 움직임이나 진동이 서서히 감소되는 것을 시뮬레이션하는 데 사용됩니다.\n\npages='5' : 이 속성은 사용자가 탐색할 수 있는 \"페이지\" 또는 스크롤 섹션의 총 수를 설정합니다. 콘텐츠의 여러 섹션을 제어하기 위해 사용될 스크롤 값의 범위를 결정합니다.\n\n또한 이 CSS를 App.css에 추가하세요:\n\n\n\n```js\n@import url('https://rsms.me/inter/inter.css'); /* 최상단에 이것을 추가하세요 */\n\nbody {\n  overscroll-behavior: none;\n  background: #efefef;\n  font-family: 'Inter var', sans-serif;\n  cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTAiIGZpbGw9ImJsYWNrIi8+PC9zdmc+'),\n    auto; /* 커스텀 커서 불러오기 */\n}\n\nh1 {\n  font-size: 10rem;\n  font-weight: 400;\n  letter-spacing: -0.05em;\n  line-height: 9rem;\n  margin: 0;\n  padding: 0;\n}\n```\n\n이제 브라우저에서 확인하면 텍스트가 나타날 것이며 스크롤할 때 애니메이션이 적용됩니다. 스크롤 애니메이션을 느낄 수 있을 것입니다. 따라서 우리는 잘 진행 중이랍니다.\n\n# 단계 8: 이미지 추가\n\n이 프로젝트의 가장 어려운 부분입니다. 하지만 이해해 보도록 해봅시다. 여기서는 이미지를 추가하고 스크롤 시에 애니메이션을 적용해야 합니다. 이미지가 확대되고 스크롤 시 줌인되는 것을 확인했다면 이를 만들어야 합니다. 이를 작은 작업으로 나누어 보겠습니다.\n\n\n\n\n- 이미지 추가\n- 스크롤할 때 애니메이션 효과 적용\n- 줌 애니메이션 추가\n\n## 이미지 추가:\n\n먼저 프로젝트에 추가할 이미지가 필요합니다. 리액트에서 이미지를 사용하는 여러 가지 방법이 있습니다. 저는 content.js에서 이미지를 내보내는 방법을 사용하고 있습니다. 이 방법을 사용하면 프로젝트 어디에서든 이미지를 가져올 수 있습니다.\n\ncontent라는 폴더를 생성하고, 해당 폴더에 content.js라는 파일을 추가해주세요:\n\n\n\n\n![Screenshot](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_11.png)\n\n이제 content.js 파일에 다음 코드를 추가해주세요:\n\n```js\nexport const image1 = \"https://images.pexels.com/photos/7631166/pexels-photo-7631166.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image2 = \"https://images.pexels.com/photos/15955004/pexels-photo-15955004/free-photo-of-a-man-walking-down-a-narrow-alleyway-in-black-and-white.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image3 = \"https://images.pexels.com/photos/15876173/pexels-photo-15876173/free-photo-of-sunrise-from-currumbin.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image4 = \"https://images.pexels.com/photos/15861750/pexels-photo-15861750/free-photo-of-sky-sunset-airplane-flight-background-wallpaper.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image5 = \"https://images.pexels.com/photos/19864134/pexels-photo-19864134/free-photo-of-two-horses-standing-in-a-field-in-black-and-white.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image6 = \"https://images.pexels.com/photos/16791339/pexels-photo-16791339/free-photo-of-man-standing-on-terrace-of-resort-apartment-with-swimming-pool.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image7 = \"https://images.pexels.com/photos/19882770/pexels-photo-19882770/free-photo-of-surfur-with-a-surfboard-walking-on-the-beach.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image8 = \"https://images.pexels.com/photos/1366919/pexels-photo-1366919.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image9 = \"https://images.pexels.com/photos/925683/pexels-photo-925683.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image10 = \"https://images.pexels.com/photos/15627686/pexels-photo-15627686/free-photo-of-a-velha-cabra.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\nexport const image11 = \"https://images.pexels.com/photos/10850828/pexels-photo-10850828.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1\";\n```\n\n저는 pixels.com에서 이미지를 사용하고 있어요.\n\n\n\n\n- 먼저 이미지 주소를 복사하세요.\n- 상수를 만드세요.\n- 상수의 이름을 지으세요.\n- 이미지 주소를 \" \" (문자열) 안에 넣으세요.\n- 시작 부분에 export를 추가하세요.\n\n이제 App.js 파일에서 가져와야 합니다.\n\n```js\nimport {\n  image1,\n  image2,\n  image3,\n  image4,\n  image5,\n  image6,\n  image7,\n  image8,\n  image9,\n  image10,\n} from \"./content/content\";\n```\n\n지금까지의 코드는 :\n\n\n\n```js\nconst { height, width } = useThree((state) => state.viewport);\nconst data = useScroll();\n```\n\nuseThree는 React Three Fiber에서 제공하는 훅으로 Three.js 상태에 접근할 수 있게 해줍니다. 이 경우에는 뷰포트의 높이와 너비를 얻기 위해 사용되었습니다.\n\n\n\nuseScroll은 React Three Drei에서 가져올 수 있는 사용자 정의 후크(custom hook)로, 스크롤 관련 데이터를 제공합니다. 반환된 데이터 객체는 애니메이션 로직에 사용됩니다.\n\n```js\nconst group = useRef();\n```\n\nuseRef() 후크는 수정 가능한 객체(group)를 만들기 위해 사용되며, 이 객체는 Three.js 그룹 객체에 첨부될 것입니다. 이 ref는 애니메이션 루프에서 그룹의 자식들을 조작하는 데 사용될 것입니다.\n\n```js\nuseFrame(() => {\n  // 스크롤 데이터를 기반으로 한 애니메이션 로직\n  // 그룹 내 각 자식의 재질(zoom 속성)을 조정\n  // 애니메이션 로직은 스크롤 위치를 기반으로 하는 것으로 보입니다.\n  // `data.range` 메서드는 지정된 범위 내에서 값을 계산하는 데 사용됩니다.\n});\n```\n\n\n\nReact Three Fiber의 useFrame 훅은 애니메이션 루프를 정의하는 데 사용됩니다. 이 루프 안에서 그룹 내 각 자식의 재질의 줌 속성이 스크롤 데이터(data)에 기반하여 조정됩니다.\n\n```js\ngroup.current.children[0].material.zoom = 1 + data.range(0, 1 / 3) / 3;\n```\n\ngroup.current:\n\ngroup은 useRef 훅을 사용하여 생성된 ref입니다. current는 ref의 현재 값에 액세스하는 데 사용되며 이 경우에는 Three.js 그룹을 가리켜야 합니다.\n\n\n\ngroup.current.children[0]:\n\n이 명령은 Three.js 그룹(group)의 첫 번째 자식에 액세스합니다. 이 그룹은 여러 자식을 가지고 있다고 가정합니다.\n\ngroup.current.children[0].material:\n\n이 명령은 첫 번째 자식의 재질(material)에 액세스합니다. Three.js에서 재질은 객체의 외관을 정의합니다.\n\n\n\ngroup.current.children[0].material.zoom:\n\n이는 첫 번째 자식의 재료의 줌 속성에 액세스하거나 설정하는 것입니다. 줌 속성은 Three.js 재료의 표준 속성이 아니므로 사용자 정의 속성이거나 사용자 정의 셰이더 데이터를 통해 추가된 속성인 것 같습니다.\n\ndata.range(0, 1 / 3) / 3\n\ndata는 scroll 관련 데이터를 제공하는 useScroll 훅에서 얻은 객체로 가정됩니다.\n\ndata.range(0, 1 / 3)는 현재 스크롤 위치를 기반으로 [0, 1/3] 범위 내에서 값을 계산합니다.\n\n\n\n결과는 그 후에 3으로 나누어져서 값이 축소될 수 있습니다.\n\n1 + data.range(0, 1 / 3) / 3:\n\n최종 값은 스크롤 범위에서 얻은 값의 축척된 값에 1을 더하여 계산됩니다. 이는 줌 요소가 적어도 아래에 있는 것을 보장하기 위해 사용될 수 있습니다.\n\n```js\nreturn (\n  <group ref={group}>\n    {/* 서로 다른 위치, 스케일 및 URL을 가진 Image 구성 요소의 여러 인스턴스 */}\n    <Image position={[-1, 0, 0]} scale={[4, height, 1]} url={image1} />\n    {/* ... (다른 이미지에 대해서도 유사하게) */}\n  </group>\n);\n```\n\n\n\n이미지 컴포넌트는 이미지 컴포넌트의 여러 인스턴스를 포함하는 `group` 컴포넌트를 반환합니다.\n\n각 이미지 컴포넌트는 특정 매개변수를 기반으로 위치 지정, 크기 조정 및 이미지 URL(url)가 할당됩니다.\n\n이미지 컴포넌트는 사용자 상호작용 또는 애니메이션 처리와 관련된 추가 기능을 제공하기 위해 Three.js 객체를 감싸는 사용자 정의 컴포넌트입니다.\n\n이제 브라우저에서 이미지를 확인하면 화면에 표시되고 스크롤할 때 애니메이션될 것입니다.\n\n\n\n노트: 값을 조정해 보면 무슨 일이 일어나는지 확인해보세요.\n\n![이미지](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_12.png)\n\n모든 것이 완료되었지만 몇 가지 추가 스타일을 추가해 보겠습니다. 호버 시 이미지를 밝게 만들어 보겠습니다. 그러려면 이 코드 라인을 추가하세요:\n\n```js\nimport { useRef, useState } from \"react\";\nimport { Scroll, ScrollControls, useScroll, Image as ImageImpl } from \"@react-three/drei\";\n```\n\n\n\n앱 함수에 다음 코드 라인을 추가하세요 :\n\n```js\n function Image({ c = new THREE.Color(), ...props }) {\n    const ref = useRef();\n    const [hovered, hover] = useState(false);\n    useFrame(() => {\n      ref.current.material.color.lerp(\n        c.set(hovered ? \"white\" : \"#ccc\"),\n        hovered ? 0.4 : 0.05\n      );\n    });\n    return (\n      <ImageImpl\n        ref={ref}\n        onPointerOver={() => hover(true)}\n        onPointerOut={() => hover(false)}\n        {...props}\n      />\n    );\n  }\n```\n\n이제 이 코드를 분석해봅시다 :\n\n```js\nfunction Image({ c = new THREE.Color(), ...props }) {\n```\n\n\n\n이것은 Image라는 기능적 React 컴포넌트를 선언합니다.\n\n기본값이 있는 객체 비구조화 인자를 가져옵니다. 여기에는 새로운 THREE.Color() 인스턴스로 기본값으로 설정된 c 속성이 포함되어 있습니다.\n\n...props 구문은 컴포넌트에 전달된 추가 props를 수집하는 데 사용됩니다.\n\n```js\nconst ref = useRef();\nconst [hovered, hover] = useState(false);\n```\n\n\n\n`useRef()`은 `ImageImpl` 컴포넌트에 연결될 변경 가능한 객체(ref)를 생성하는 데 사용됩니다. 이를 통해 Three.js의 기본 객체에 액세스하고 상호 작용할 수 있습니다.\n\n`useState(false)`는 상태 변수 `hovered`를 초기화하고 해당 값을 업데이트할 함수 `hover`를 생성하는 데 사용됩니다. 기본값은 false로 설정됩니다.\n\n```js\nuseFrame(() => {\n  ref.current.material.color.lerp(\n    c.set(hovered ? \"white\" : \"#ccc\"),\n    hovered ? 0.4 : 0.05\n  );\n});\n```\n\n`useFrame`은 Three.js 씬에서 애니메이션을 실행하기 위해 React Three Fiber 라이브러리에서 제공하는 사용자 정의 후크입니다. 각 프레임마다 실행될 콜백 함수를 인수로 전달합니다.\n\n\n\n이 콜백에서 ref.current는 ref로 참조된 Three.js 객체에 액세스하는 데 사용됩니다. 그런 다음 Three.js 객체의 재질 색상을 업데이트합니다.\n\n색상은 두 개의 색상 사이를 선형 보간하는 lerp 메서드를 사용하여 업데이트됩니다. 보간되는 색상은 hovered의 값에 따라 결정됩니다. hovered가 true이면 색상이 흰색으로 설정되고, 그렇지 않으면 회색(#ccc)의 음영이 설정됩니다.\n\n보간 계수(0.4 또는 0.05)는 색상 전환 속도를 결정합니다. 더 높은 값은 객체 위에 마우스가 있을 때(즉, hovered가 true인 경우) 더 빠른 전환을 의미합니다.\n\n```js\nreturn (\n  <ImageImpl\n    ref={ref}\n    onPointerOver={() => hover(true)}\n    onPointerOut={() => hover(false)}\n    {...props}\n  />\n);\n```\n\n\n\n여기에는 이미지 컴포넌트가 ref 객체를 전달하여 `ImageImpl` 컴포넌트를 반환합니다. 이를 통해 useFrame 훅이 기본 Three.js 객체와 상호 작용할 수 있게 됩니다.\n\n`ImageImpl` 컴포넌트에는 이벤트 핸들러(onPointerOver 및 onPointerOut)가 제공되며, 이를 통해 마우스 상호작용에 따라 hover 상태가 트리거됩니다.\n\n이미지 컴포넌트로 전달되는 추가적인 속성은 '…props'를 사용하여 전달됩니다.\n\n이제 suspense와 preload를 추가해야 합니다:\n\n\n\n```js\nimport { Suspense, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\";\nimport {\n  Scroll,\n  ScrollControls,\n  useScroll,\n  Image as ImageImpl,\n  Preload,\n} from \"@react-three/drei\";\nimport {\n  image1,\n  image2,\n  image3,\n  image4,\n  image5,\n  image6,\n  image7,\n  image8,\n  image9,\n  image10,\n} from \"./content/content\";\nimport \"./App.css\";\nfunction App() {\n  function Image({ c = new THREE.Color(), ...props }) {\n    const ref = useRef();\n    const [hovered, hover] = useState(false);\n    useFrame(() => {\n      ref.current.material.color.lerp(\n        c.set(hovered ? \"white\" : \"#ccc\"),\n        hovered ? 0.4 : 0.05\n      );\n    });\n    return (\n      <ImageImpl\n        ref={ref}\n        onPointerOver={() => hover(true)}\n        onPointerOut={() => hover(false)}\n        {...props}\n      />\n    );\n  }\n\n  function Images() {\n    const { height, width } = useThree((state) => state.viewport);\n    const data = useScroll();\n    const group = useRef();\n\n    useFrame(() => {\n      group.current.children[0].material.zoom = 1 + data.range(0, 1 / 3) / 3;\n      group.current.children[1].material.zoom = 1 + data.range(0, 1 / 3) / 3;\n      group.current.children[2].material.zoom =\n        1 + data.range(1.15 / 3, 1 / 3) / 3;\n      group.current.children[3].material.zoom =\n        1 + data.range(1.15 / 3, 1 / 3) / 2;\n      group.current.children[4].material.zoom =\n        1 + data.range(1.25 / 3, 1 / 3) / 1;\n      group.current.children[5].material.zoom =\n        1 + data.range(1.8 / 3, 1 / 3) / 3;\n      group.current.children[6].material.zoom =\n        1 + (1 - data.range(2 / 3, 1 / 3)) / 3;\n      group.current.children[7].material.zoom =\n        1 + (1 - data.range(2 / 3, 1 / 3)) / 3;\n      group.current.children[8].material.zoom =\n        1 + data.range(1.15 / 3, 1 / 3) / 3;\n      group.current.children[9].material.zoom =\n        1 + data.range(1.15 / 3, 1 / 3) / 3;\n    });\n\n    return (\n      <group ref={group}>\n        <Image position={[-1, 0, 0]} scale={[4, height, 1]} url={image1} />\n        <Image position={[4, 0, 1]} scale={5} url={image2} />\n        <Image position={[-3, -height, 2]} scale={[2, 3, 1]} url={image3} />\n        <Image position={[-0.6, -height, 3]} scale={[1, 2, 1]} url={image4} />\n        <Image position={[0.75, -height, 3.5]} scale={1.5} url={image5} />\n        <Image\n          position={[0, -height * 1.5, 2.5]}\n          scale={[1.5, 3, 1]}\n          url={image6}\n        />\n        <Image\n          position={[0, -height * 2 - height / 4, 0]}\n          scale={[width, height / 2, 1]}\n          url={image7}\n        />\n        <Image\n          position={[-5, -height * 2.7 - height / 3, 0]}\n          scale={[5, height, 1]}\n          url={image8}\n        />\n        <Image\n          position={[-2, -height * 3 - height, 2]}\n          scale={[3, 3, 1]}\n          url={image9}\n        />\n        <Image\n          position={[1.5, -height * 3 - height, 2]}\n          scale={[3, 3, 1]}\n          url={image10}\n        />\n      </group>\n    );\n  }\n  return (\n    <>\n      <Canvas gl={{ antialias: false }} dpr={[1, 1.5]}>\n      <Suspense fallback={null}>\n          <ScrollControls damping={2} pages={5}>\n            <Scroll>\n              <Images />\n            </Scroll>\n            <Scroll html>\n              <h1 style={{ position: \"absolute\", top: \"60vh\", left: \"0.2em\" }}>\n                Make\n              </h1>\n              <h1 style={{ position: \"absolute\", top: \"120vh\", left: \"60vw\" }}>\n                Scroll\n              </h1>\n              <h1\n                style={{\n                  position: \"absolute\",\n                  top: \"210.5vh\",\n                  left: \"0.5vw\",\n                  fontSize: \"20vw\",\n                }}\n              >\n                Creative\n              </h1>\n              <h1\n                style={{\n                  position: \"absolute\",\n                  top: \"330.5vh\",\n                  left: \"50rem\",\n                  fontSize: \"10vw\",\n                }}\n              >\n                And Flawless\n              </h1>\n            </Scroll>\n          </ScrollControls>\n          <Preload />\n        </Suspense>\n      </Canvas>\n    </>\n  );\n}\n\nexport default App;\n```\n\n위의 코드는 최종 코드입니다. 이제 suspense와 preload에 대해 배우겠습니다.\n\n```jsx\n<Suspense fallback={null}>\n  {/* ... */}\n</Suspense>\n```\n\nSuspense 컴포넌트는 내장 React 컴포넌트로, 컴포넌트가 렌더링되기 전에 무언가를 기다리도록 허용하는 것입니다. 보통 데이터 가져오기나 코드 분할과 같은 비동기 작업을 처리하는 데 사용됩니다.\n\n\n\n\nfallback 속성은 비동기 작업이 진행 중일 때 렌더링할 내용을 지정합니다. 이 경우에는 null로 설정되어 있어서 아무것도 렌더링되지 않아야 함을 나타냅니다.\n\nSuspense는 아마초 또는 컴포넌트의 비동기 로딩을 처리하기 위해 사용되며, 내부 컨텐츠(ScrollControls, Scroll, Images 및 텍스트 요소를 포함한)가 비동기 작업이 완료될 때까지 렌더링되지 않도록 보장합니다.\n\n```js\n<Preload />\n```\n\nPreload 컴포넌트는 아마도 react-three/drei 라이브러리의 일부일 것입니다. 이는 실제로 씬에서 사용되기 전에 텍스처 또는 모델과 같은 에셋을 미리로딩하는 데 사용됩니다.\n\n\n\n프리로딩은 필요한 경우에 자산이 필요하기 전에 메모리로 로드되어 있는지 확인하여 도움이 됩니다. 이는 사용되는 자산이 처음 사용될 때 런타임 중에 로딩 지연을 피하고 더 부드러운 사용자 경험을 제공합니다.\n\n리액트 쓰리 파이버로 웹사이트를 만들어 축하드립니다👏.\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*Qo5FVr1hxVphASfQwIyd0Q.gif)\n\n이것은 무수히 많은 복잡하고 창의적인 아이디어를 위한 시작에 불과합니다. 계속해서 배우고 발전해나가세요.\n\n\n\n이 글을 읽어주셔서 마지막으로 \"감사합니다.\" 새로운 것을 배우셨기를 바라요. 만약 이 글을 좋아하셨다면 댓글을 남겨주시면 제가 더 이런 글을 작성할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_0.png"},"coverImage":"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_0.png","tag":["Tech"],"readingTime":20},{"title":"리액트로 깨끗한 아키텍처 구현하기","description":"","date":"2024-05-14 11:42","slug":"2024-05-14-CleanArchitectureWithReact","content":"\n\n## 클린 아키텍처는 애플리케이션을 보다 쉽게 유지 보수하고 확장할 수 있게 만들어줍니다. 그러나 여러 가지 프레임워크 기반 코딩 스타일에 의해 우리의 코드는 편향될 수 있습니다. 이 기사에서는 React 기반 코드를 클린 아키텍처로 변환하는 방법을 보여드리고자 합니다.\n\n![클린 아키텍처 이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_0.png)\n\n클린 아키텍처는 수직으로 쌓인 여러 층으로 정의되며 각 층은 소프트웨어의 다른 영역을 나타냅니다. 상위 층은 애플리케이션의 기본 정책을 나타내며 하위 층은 메커니즘을 나타냅니다.\n\n![클린 아키텍처 이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_1.png)\n\n\n\n이 아키텍처가 작동하는 데 중요한 규칙은 의존성 규칙입니다. 이 규칙은 소스 코드 의존성은 위로만 가리킬 수 있다고 합니다. 계층과 의존성 규칙을 이용하면 데이터베이스와 프레임워크와 같은 기술 구현 세부 사항과 독립적인 매우 낮은 결합도를 가진 애플리케이션을 설계할 수 있습니다.\n\n이 문서에서 정의한 계층을 사용하여 다음과 같이 설명합니다:\n\n도메인 계층은 프로젝트나 애플리케이션이 하는 일을 설명합니다. 도메인 계층의 코드는 플랫폼과 프레임워크와 독립적이어야 합니다.\n\n- 모델은 문제와 관련된 현실 세계 객체를 나타냅니다.\n- 리포지토리는 모델에 액세스하기 위한 인터페이스를 제공합니다.\n- Use case는 애플리케이션의 모든 비즈니스 로직을 포함합니다.\n\n\n\n프레젠테이션 레이어는 애플리케이션이 외부 세계와 상호 작용하는 방식을 설명합니다.\n\n데이터 레이어는 애플리케이션이 데이터를 관리하는 방법을 설명합니다.\n\n주 레이어(가장 하단 레이어)는 다른 레이어의 모든 소프트웨어 구성 요소를 한 애플리케이션으로 통합하는 부트스트랩 코드를 제공합니다.\n\n하지만 실제 애플리케이션에서는 제어 흐름이 항상 상향 방향인 것은 아닙니다. 예를 들어 UseCase 레이어의 비즈니스 로직은 Repository 레이어의 인터페이스를 사용하며, Repository(상위 레이어)는 데이터 레이어(하위 레이어)에 있는 데이터에 액세스해야 합니다. 아래 그림을 참조하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-CleanArchitectureWithReact_2.png\" />\n\n이 종속성 규칙 위반을 해결하려면 일반적으로 의존성 역전 원칙을 사용합니다. 인터페이스 (예: RepositoryX)와 해당 구현 (예: RepositoryImpl) 간의 관계를 위로 향하는 소스 코드 의존성을 가리키도록 정렬합니다. 이 기술을 사용하면 상위 레이어가 하위 레이어에서 정의된 구현을 호출할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-14-CleanArchitectureWithReact_3.png\" />\n\n# React 애플리케이션을 클린 아키텍처로 변환하기\n\n\n\n애플리케이션 코드를 리액트 애플리케이션의 템플릿(예: create-react-app로 생성된 꼬겨받은)에서 시작하면 모든 코드가 처음에 프레젠테이션 레이어에 포함됩니다. 이는 리액트(그리고 모든 UI 프레임워크)가 데이터를 사용자에게 어떻게 표시할지에 중점을 둔 것이기 때문입니다. 이 섹션에서는 리액트 기반 애플리케이션 코드를 변형하여 청결한 아키텍처를 준수하도록 만들 것입니다.\n\n여기 공식 리액트 튜토리얼에서 사용된 TicTacToe의 원본 코드입니다.\n\n```js\nfunction Square(props) {\n  return (\n    <button className=\"square\" onClick={props.onClick}>\n      {props.value}\n    </button>\n  );\n}\n\nclass Board extends React.Component {\n  renderSquare(i) {\n    return (\n      <Square\n        value={this.props.squares[i]}\n        onClick={() => this.props.onClick(i)}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"board-row\">\n          {this.renderSquare(0)}\n          {this.renderSquare(1)}\n          {this.renderSquare(2)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderSquare(3)}\n          {this.renderSquare(4)}\n          {this.renderSquare(5)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderSquare(6)}\n          {this.renderSquare(7)}\n          {this.renderSquare(8)}\n        </div>\n      </div>\n    );\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      history: [\n        {\n          squares: Array(9).fill(null)\n        }\n      ],\n      stepNumber: 0,\n      xIsNext: true\n    };\n  }\n\n  handleClick(i) {\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    const squares = current.squares.slice();\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    squares[i] = this.state.xIsNext ? \"X\" : \"O\";\n    this.setState({\n      history: history.concat([\n        {\n          squares: squares\n        }\n      ]),\n      stepNumber: history.length,\n      xIsNext: !this.state.xIsNext\n    });\n  }\n\n  jumpTo(step) {\n    this.setState({\n      stepNumber: step,\n      xIsNext: (step % 2) === 0\n    });\n  }\n\n  render() {\n    const history = this.state.history;\n    const current = history[this.state.stepNumber];\n    const winner = calculateWinner(current.squares);\n\n    const moves = history.map((step, move) => {\n      const desc = move ?\n        'Go to move #' + move :\n        'Go to game start';\n      return (\n        <li key={move}>\n          <button onClick={() => this.jumpTo(move)}>{desc}</button>\n        </li>\n      );\n    });\n\n    let status;\n    if (winner) {\n      status = \"Winner: \" + winner;\n    } else {\n      status = \"Next player: \" + (this.state.xIsNext ? \"X\" : \"O\");\n    }\n\n    return (\n      <div className=\"game\">\n        <div className=\"game-board\">\n          <Board\n            squares={current.squares}\n            onClick={i => this.handleClick(i)}\n          />\n        </div>\n        <div className=\"game-info\">\n          <div>{status}</div>\n          <ol>{moves}</ol>\n        </div>\n      </div>\n    );\n  }\n}\n\n// ========================================\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(<Game />);\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6]\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}\n```\n\n\n\n![이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_4.png)\n\n## 디자인 모델 레이어\n\n먼저, Model 레이어에서 데이터 모델을 추출해보세요. 여기에 정의된 모델은 플랫폼과 프레임워크에 독립적이어야 하며, 순수하게 비즈니스 규칙에만 집중해야 합니다.\n\n원본 코드에 명확한 타입 정의가 없더라도, TypeScript의 타입 추론 메커니즘을 활용하기 위해 반드시 해당 타입들을 정의해야 합니다. 이렇게 하면 개발하는 동안 TypeScript가 지원할 수 있습니다.\n\n\n\n```js\nexport type Square = null | \"X\" | \"O\";\n\nexport type Board = Square[];\n\ntype HistoryStep = {\n  board: Board;\n};\n\nexport type History = HistoryStep[];\n```\n\n# 디자인 유스케이스 및 리포지토리 레이어 설계\n\n다음 단계는 유스케이스를 추출하는 것입니다. 유스케이스는 \"X가 발생했을 때, Y를 수행한다\"라고 형식화할 수 있습니다.\n\nReact 애플리케이션에서 유스케이스는 일반적으로 (1) React 프레임워크에서 호출되는 렌더링 함수로 구현되거나, (2) 사용자 입력을 처리하는 이벤트 핸들러, 또는 (3) 자율적인 효과로 구현됩니다. TicTacToe 예제에서는 세 가지 유스케이스가 있습니다.\n\n\n\n\n- render(): 데이터가 업데이트되면이 함수가 호출됩니다.\n- handleClick(i): 보드에서 사각형을 누르면이 함수가 호출됩니다.\n- jumpTo(step): \"이동 #x로 이동\"버튼을 누르면이 함수가 호출됩니다.\n\n그러나 원본 사용 사례 함수 (render(), handleClick(), jumpTo())에는 여러 레이어 (UseCase, Repository, Data, Presentation (react))의 코드가 포함되어 있다는 것을 알게되었습니다. 이 스파게티를 해결하고 적절한 레이어로 코드를 분배해야 합니다.\n\n보통 변수 간의 종속성을 분석하여 이 해결을 시작하고 다른 변수에서도 유추할 수 없는 기본 데이터 소스를 찾습니다. TicTacToe 예에서 아래 그림에 설명된 것처럼 history와 stepNumber 두 가지 주요 데이터 소스를 쉽게 감지할 수 있습니다. 이러한 기본 데이터는 영구 데이터 저장소에 저장해야하며 이를 Data 레이어에 놓습니다.\n\n<img src=\"/assets/img/2024-05-14-CleanArchitectureWithReact_5.png\" />\n\n\n\nUseCase 레이어와 Repository 레이어 간의 경계를 설계하는 것은 주관적이며 일부는 당신에게 달려 있어. Repository 레이어는 모든 모델별 작업을 보관하는 중심 장소로 정의됩니다. 또한 Repository 레이어에서의 작업을 정의하는 내 정책은 다음과 같습니다:\n\n- Repository 작업은 최소화되어야 합니다. 주요 데이터 소스에 대한 모든 노출된 setter/getter 함수를 노출하는 것은 좋은 아이디어가 아닙니다. 이는 쉽게 유효하지 않거나 일관성 없는 데이터로 이어질 수 있습니다.\n- Repository 작업은 UseCase 레이어에 정의된 비즈니스 로직과 중립적이며 독립적이어야 합니다.\n- 각 Repository 작업은 데이터 소스의 일관성을 유지하기 위해 일괄 작업으로 한 번에 변경할 필요가 있는 경우에만 여러 데이터 소스에 액세스해야 합니다.\n\n이 정책에 따라 UseCase 레이어와 Repository 레이어를 다음과 같이 분리합니다:\n\n![이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_6.png)\n\n\n\n레포지토리 인터페이스를 정의해 봅시다. 구현은 나중에 이어집니다.\n\n```js\nexport type Step = {\n  board: Board;\n  stepNumber: number;\n  numOfAllSteps: number;\n};\n\n/**\n * 틱택토 단계의 기록을 관리하는 레포지토리.\n * 각 단계는 보드로 이루어져 있습니다.\n */\nexport interface Repository {\n  getCurrentStep(): Promise<Step>;\n  setCurrentStepNumber(stepNumber: number): Promise<void>;\n  deleteStepsAfterCurrentStepNumber(): Promise<void>;\n  addStep(board: Board): Promise<void>;\n}\n```\n\n그런 다음 유즈케이스 함수를 정의할 수 있습니다. 이제 비즈니스 로직을 더 명확하게 이해할 수 있어요.\n\n```js\nexport async function clickOnBoard(\n  indexOnBoard: number,\n  repository: Repository\n) {\n  const { board, stepNumber } = await repository.getCurrentStep();\n  const newBoard = board.slice();\n  if (calculateWinnerOnBoard(newBoard) || newBoard[indexOnBoard]) {\n    return;\n  }\n  newBoard[indexOnBoard] = isNextTurnX(stepNumber) ? \"X\" : \"O\";\n  await repository.deleteStepsAfterCurrentStepNumber();\n  await repository.addStep(newBoard);\n  await repository.setCurrentStepNumber(stepNumber + 1);\n}\n\nexport async function jumpToStep(\n  stepNumber: number,\n  repository: Repository\n): Promise<void> {\n  return repository.setCurrentStepNumber(stepNumber);\n}\n```\n\n\n\n# 디자인 프리젠테이션 레이어\n\n프리젠테이션 레이어에서 가장 중요한 팁은 MVC(Model-View-Controller)를 형성하는 것입니다. React 애플리케이션에서는 일반적으로 Presentation 레이어와 UseCase 레이어 사이의 다리 역할을 하는 하나의 객체로 \"모델\"과 \"컨트롤러\"를 통합합니다.\n\n아래 그림에서 TicTacToeModelController를 참조하세요. React 컴포넌트는 MVC에서 \"뷰\"로 작동하며, 사용자 정의 후크를 사용하여 \"모델-컨트롤러\"를 참조합니다. 이렇게 하면 순수한 렌더링 코드(\"뷰\")를 데이터 처리 코드(\"모델\" 및 \"컨트롤러\")에서 분리할 수 있습니다.\n\n\n\n이 코드는 TicTacToeModelController입니다.\n\n```js\nexport function useTicTacToeModelController(repository: Repository) {\n  const [currentStep, setCurrentStep] = useState<Step | null>(null);\n\n  useEffect(() => {\n    async function init() {\n      const initialStep = await repository.getCurrentStep();\n      setCurrentStep(initialStep);\n    }\n    init();\n  }, []);\n\n  const handleClickOnBoard = async (indexOnBoard: number) => {\n    await clickOnBoard(indexOnBoard, repository);\n    const newStep = await repository.getCurrentStep();\n    setCurrentStep(newStep);\n  };\n\n  const handleJumpToStep = async (stepNumber: number) => {\n    await jumpToStep(stepNumber, repository);\n    const newStep = await repository.getCurrentStep();\n    setCurrentStep(newStep);\n  };\n\n  return {\n    currentStep,\n    handleClickOnBoard,\n    handleJumpToStep,\n  };\n}\n```\n\n그리고 여기는 TicTacToeView입니다.\n\n```js\ntype TicTacToeViewProps = {\n  repository: Repository;\n};\n\nexport function TicTacToeView({ repository }: TicTacToeViewProps) {\n  const { currentStep, handleClickOnBoard, handleJumpToStep } =\n    useTicTacToeModelController(repository);\n\n  if (!currentStep) {\n    return null;\n  }\n\n  const winner = calculateWinnerOnBoard(currentStep.board);\n  const xIsNext = isNextTurnX(currentStep.stepNumber);\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <BoardView board={currentStep.board} onClick={handleClickOnBoard} />\n      </div>\n      <div className=\"game-info\">\n        <StatusView winner={winner} xIsNext={xIsNext} />\n        <JumpToStepButtons\n          numOfAllSteps={currentStep.numOfAllSteps}\n          onClick={handleJumpToStep}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n\n\n# 데이터 레이어 디자인\n\n데이터 레이어는 두 개의 서브 레이어로 구성됩니다. 데이터:저장소 레이어는 도메인:저장소 레이어에 정의된 동작을 구현하는 레이어입니다. 데이터:데이터원 레이어는 실제 데이터 저장소를 구현하는 곳으로, 예를 들어 메모리 저장소 또는 네트워크 저장소가 있습니다.\n\n아래 그림에서 보듯이, 도메인:저장소 레이어(위쪽 레이어)와 데이터:저장소 레이어(아래쪽 레이어) 사이에 의존성 역전 원칙을 적용합니다. 제어 흐름은 아래로 진행됩니다(예: 도메인이 데이터를 사용함), 그러나 소스 코드 의존성은 위로 향합니다.\n\n\n\n여기에 RepositoryImpl이 있습니다:\n\n```js\nexport class RepositoryImpl implements Repository {\n  dataSource: DataSource;\n\n  constructor(dataSource: DataSource) {\n    this.dataSource = dataSource;\n  }\n\n  async getCurrentStep(): Promise<Step> {\n    const [history, stepNumber] = await Promise.all([\n      this.dataSource.getHistory(),\n      this.dataSource.getStepNumber(),\n    ]);\n    const board = history[stepNumber].board;\n    const numOfAllSteps = history.length;\n\n    return { board, stepNumber, numOfAllSteps };\n  }\n\n  async setCurrentStepNumber(stepNumber: number): Promise<void> {\n    const history = await this.dataSource.getHistory();\n    if (stepNumber < history.length) {\n      await this.dataSource.setStepNumber(stepNumber);\n    } else {\n      throw Error(\n        `Step number ${stepNumber} should be smaller than the history size (${history.length})`\n      );\n    }\n  }\n\n  async deleteStepsAfterCurrentStepNumber(): Promise<void> {\n    const [history, stepNumber] = await Promise.all([\n      this.dataSource.getHistory(),\n      this.dataSource.getStepNumber(),\n    ]);\n    const trimmedHistory = history.slice(0, stepNumber + 1);\n    await this.dataSource.setHistory(trimmedHistory);\n  }\n\n  async addStep(board: Board): Promise<void> {\n    const history = await this.dataSource.getHistory();\n    history.push({ board });\n    await this.dataSource.setHistory(history);\n  }\n}\n```\n\n# 디자인 메인 레이어\n\n마지막으로, 몇 개의 레이어에서 모든 구성 요소를 하나의 애플리케이션으로 짜바랍니닷.\n\n\n\n이 부트스트랩 코드에서는 저장소 구현을 만들고 TicTacToeView에 전달합니다. 그런 다음 저장소는 TicTacToeModelController를 통해 UseCase 레이어에 전달됩니다.\n\n```js\n// 의존성 주입\nconst dataSource = new OnMemoryDataSourceImpl();\nconst repository = new RepositoryImpl(dataSource);\n\nexport function App() {\n  return <TicTacToeView repository={repository} />;\n}\n```\n\n이것은 의존성 주입(Dependency Injection, DI)이라는 기술입니다. 아래 다이어그램에서 보듯이, UseCase 레이어는 Repository 레이어를 사용하며 의존합니다. 그러나 UseCase 레이어의 코드에서는 하위 레이어(Data 레이어)에 의존하는 실제 객체를 Repository 레이어에서 만들어서는 안됩니다.\n\n객체 생성(Main 레이어)과 객체 사용(UseCase 레이어)을 분리함으로써, 의존성 규칙을 깨지 않고(lower layer에서 upper layer로 모든 참조 화살표가 위쪽 방향을 가져야 함) 인 것을 피할 수 있습니다.\n\n\n\n![이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_9.png)\n\n여기까지입니다! 최종 소스 코드를 확인할 수 있습니다.\n\n# 결론\n\nReact 애플리케이션 코드를 깔끔한 아키텍처로 변환하는 방법을 보여드렸습니다. 깔끔한 아키텍처에 익숙해지면 처음부터 깔끔한 아키텍처에 부합하는 코드를 설계할 수 있게 될 것입니다. 그러나 그런 경우에도 이 글에서 설명한 디자인 프로세스가 리팩터링에 좋은 안내를 제공해 줄 것으로 기대합니다.","ogImage":{"url":"/assets/img/2024-05-14-CleanArchitectureWithReact_0.png"},"coverImage":"/assets/img/2024-05-14-CleanArchitectureWithReact_0.png","tag":["Tech"],"readingTime":13}],"page":"115","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}