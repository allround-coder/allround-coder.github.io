{"pageProps":{"post":{"title":"2024년 Angular 18, React 19 최신 업데이트 공개","description":"","date":"2024-06-22 14:36","slug":"2024-06-22-1819in24UnveilingAngularReactsLatestUpdates","content":"\n\n👨‍💻 안녕하세요! 전문 개발자로서 웹 개발에 열정을 가지고 있는 Senior Full Stack 엔지니어입니다. 저는 Angular 및 React 프레임워크와 광범위하게 작업한 기회가 있었습니다. 웹 성능을 향상시키는 최신 기능을 탐험하는 것은 항상 흥미로운 일이었습니다.\n\n![](/assets/img/2024-06-22-1819in24UnveilingAngularReactsLatestUpdates_0.png)\n\n# 빠른 소개:\n\n만약 이러한 웹 프레임워크가 무엇인지에 대해 생소하다면,\n\n<div class=\"content-ad\"></div>\n\nAngular: Angular은 Google에서 지원하는 강력한 프론트엔드 프레임워크로, 효율적인 웹 애플리케이션을 구축하기 위한 다양한 도구를 제공합니다.\n\nReact: Facebook이 만든 React는 재사용 가능한 컴포넌트와 효율적인 렌더링 기술을 통해 상호 작용하는 사용자 인터페이스를 구축하는 것을 단순화한 JavaScript 라이브러리입니다.\n\nAngular 18과 React 19의 최신 릴리스로 흥미로운 발전이 있고, 그들의 매력적인 기능들을 탐험하는 것을 곧 기대하고 있습니다.\n\n# Angular 18\n\n<div class=\"content-ad\"></div>\n\nAngular을 처음 사용해보는 분들을 위한 안내입니다. Angular의 홈페이지인 Home • Angular은 지금은 여러분의 첫 걸음을 시작할 수 있는 포괄적이고 가치 있는 자원으로 자리 잡았습니다. Angular 개발의 모든 면을 탐험하고 학습하기에 적합한 다양한 정보, 자습서 및 안내서가 제공됩니다.\n\n최신 업그레이드에 대해 자세히 살펴보고, 특히 Angular에 처음 접하시는 분들을 위해 이러한 기능들을 일반적인 방식으로 설명해보겠습니다.\n\n## 🟫변경 탐지 개선\n\nZone.js는 비동기 작업을 관리하여 Angular에서 자동으로 변경 탐지를 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n앵귤러 사용법:\n\n- 비동기 API를 패치합니다.\n- 변경 감지를 트리거합니다.\n\n단점:\n\n- 성능 부담\n- 복잡한 디버깅\n- 라이브러리 호환성\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-article',\n  template: `\n    <div>\n      <p>Article이 발행되었습니까?: { isArticlePublished }</p>\n      <button (click)=\"publishArticle()\">기사 발행</button>\n    </div>\n  `\n})\nexport class ArticleComponent {\n  isArticlePublished = false;\n\n  publishArticle() {\n    setTimeout(() => {\n      this.isArticlePublished = true;\n    }, 1000);\n  }\n}\n```\n\n```js\nimport { Component, ChangeDetectorRef } from '@angular/core';\n\n@Component({\n  selector: 'app-article',\n  template: `\n    <div>\n      <p>Article이 발행되었습니까?: { isArticlePublished }</p>\n      <button (click)=\"publishArticle()\">기사 발행</button>\n    </div>\n  `\n})\nexport class ArticleComponent {\n  isArticlePublished = false;\n\n  constructor(private cdr: ChangeDetectorRef) {}\n\n  publishArticle() {\n    setTimeout(() => {\n      this.isArticlePublished = true;\n      this.cdr.detectChanges();  // 변경 감지를 수동으로 트리거합니다.\n    }, 1000);\n  }\n}\n```\n\nAngular 18에서는 Angular에서 zoneless 지원을 실험할 수 있습니다! 애플리케이션 부트스트랩에 provideExperimentalZonelessChangeDetection을 추가하기만 하면 됩니다:  \n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n  ...\n  template: `\n    <h1>Hello from { name() }!</h1>\n    <button (click)=\"handleClick()\">With Zoneless</button>\n  `,\n})\nexport class App {\n  protected IsArticlePublished= signal('false');\n\n  handleClick() {\n    this.IsArticlePublished.set('true');\n  }\n}\n```\n\nAngular은 변경 감지를 최적화하기 위해 Zones를 사용하지만, Zones 없이도 신호 업데이트와 같은 적은 트리거로 작동할 수 있습니다.\n\n## 🟫Angular Material 3\n\nAngular Material은 Angular 애플리케이션에 대한 UI 컴포넌트 라이브러리로서 Google의 Material Design 명세를 구현합니다. 버튼, 입력란, 대화 상자, 내비게이션 패턴 등 재사용 가능하고 테스트된 UI 컴포넌트를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 구성 요소들은 Material Design 원칙을 준수하여 웹 애플리케이션을위한 일관된 그리고 매력적인 사용자 인터페이스를 제공하도록 설계되었습니다.\n\n참조: Angular Material UI 구성 요소 라이브러리\n\n## 🟫 미리보는 신호 API\n\n신호는 포함된 값에 대한 변경 사항이 있을 때 관심 있는 소비자에게 알림을 주는 값의 캡슐화입니다. 이들은 간단한 유형부터 복잡한 데이터 구조까지 다양한 데이터를 보유할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n신호의 값을 액세스하려면 해당 getter 함수를 호출해야 합니다. 이렇게 하면 Angular이 해당 사용 사항을 모니터링할 수 있습니다. 신호는 쓰기 가능하거나 읽기 전용 형태로 존재할 수 있습니다.\n\n참고: Signals • 개요 • Angular\n\n## 🟫지연 가능한 뷰\n\n구성 요소 템플릿에서 지연 가능한 뷰를 사용하면 구성 요소, 지시문, 파이프 및 관련 CSS와 같은 특정 종속성의로드를 지연시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기능은 템플릿의 일부를 @defer 블록으로 감싸서 해당 종속성이로드되어야 하는 조건을 정의하는 곳에 구현됩니다.\n\n```js\n@defer {\n  <articlereview-component />\n}\n```\n\n지연로드 가능한 뷰를 통해 개발자들은 쉽게 앱을 향상시키고 번들 크기를 줄일 수 있습니다.\n\n## 🟫이벤트 재생\n\n<div class=\"content-ad\"></div>\n\n사용자 이벤트(예: 클릭) 재생 가능성을 허용하여 수분화 로직이 완료되기 전에 페이지에서 발생한 이벤트를 다시 실행할 수 있습니다.\n\n예시\n\n대부분의 개발자가 일반적으로 이벤트 디스패치와 직접 상호 작용하지는 않지만, 이 문맥에서 이벤트 재생이 왜 가치 있는지 살펴봅시다. 기사를 읽는 웹사이트에서 상상해보세요. 우리는 가짜로로드 지연을 사용하여 네트워크 연결이 느린 시나리오를 시뮬레이션할 것입니다.\n\n페이지가 로드되는 동안이며 완전히 상호작용 가능하기 전에 사용자가 기사를 읽고 여러 기사에 댓글을 남기기로 결정했다면, 페이지가 아직 완전히 상호작용적이지 않은 경우(수분화되지 않은 경우), 이 사용자 동작은 손실될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n버전 18부터 Angular은 사용자 상호작용을 기록하기 위해 이벤트 디스패치를 도입했습니다. 페이지가 완전히 로드된 후, Angular은 이러한 이벤트를 재생하여 모든 댓글이 여러 개의 게시물에 성공적으로 제출되도록 보장합니다.\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideClientHydration(withEventReplay())\n  ]\n});\n```\n\n## 🟫ng-content의 콘텐츠를 위한 후속 처리\n\n```js\n@Component({\n  selector: 'app-article',\n  template: `\n    <ng-content select=\".article\">게시물 이름</ng-content>\n\n    <ng-content>댓글이 없습니다</ng-content>\n  `,\n})\nexport class Article {}\n```\n\n<div class=\"content-ad\"></div>\n\n## 🟫통합 형태 컨트롤 상태 변경 이벤트\n\n내가 좋아하는 하나: Angular 폼의 FormControl, FormGroup 및 FormArray 클래스에는 이제 'events' 속성이 추가되었습니다.\n\n이 속성을 사용하면 폼 컨트롤과 관련된 이벤트 스트림을 구독할 수 있어 값 변경, 터치 상태, 원시 상태 및 전반적인 컨트롤 상태의 변경 사항을 모니터링할 수 있습니다.\n\n```js\nconst articleFeedbackControl = new FormControl<string|null>('article', Validators.required);\nnameControl.events.subscribe(event => {\n \n});\n```\n\n<div class=\"content-ad\"></div>\n\n## 🟫 라우트 리다이렉트 개선\n\nAngular v18에서는 리다이렉트 처리의 유연성을 향상하기 위해 redirectTo 속성이 이제 문자열을 반환하는 함수를 지원합니다.\n\n이를 통해 런타임 조건에 따라 보다 복잡한 리다이렉트 로직을 구현할 수 있습니다. 예를 들어, 동적 상태에 따라 리다이렉트해야 하는 경우 이 함수 내에 복잡한 로직을 정의할 수 있습니다:\n\n```js\nconst routes: Routes = [\n  { path: 'article/:articleId', component: ArticleComponent },\n  {\n    path: 'redirect-article',\n    redirectTo: ({ queryParams }) => {\n      const articleIdParam = queryParams['articleId'];\n      if (articleIdParam) {\n        return `/article/${articleIdParam}`;\n      } else {\n        // 오류 처리를 하거나 기본 경로로 리다이렉트할 수 있습니다\n        return `/not-found`;\n      }\n    }\n  },\n  { path: 'not-found', component: NotFoundComponent },\n];\n```\n\n<div class=\"content-ad\"></div>\n\n## 🟫 빌드 개선\n\nAngular 16에서는 esbuild 및 Vite와 같은 현대적인 도구를 활용한 새로운 응용 프로그램 빌더를 공개했습니다. 이 빌더는 Angular 17의 새로운 프로젝트에 대한 기본값이 되었습니다.\n\n새 빌드 시스템으로 이전하기 • Angular\n\n![이미지](/assets/img/2024-06-22-1819in24UnveilingAngularReactsLatestUpdates_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 지금 React 19 기능에 대해 이야기해 봅시다\n\n![React 19](/assets/img/2024-06-22-1819in24UnveilingAngularReactsLatestUpdates_2.png)\n\n# React 19\n\n## 🟢 React 컴파일러\n\n<div class=\"content-ad\"></div>\n\n현재 React는 상태 변경 시 자동으로 다시 렌더링되지 않습니다. 이러한 다시 렌더링을 최적화하기 위해 개발자들은 보통 useMemo(), useCallback(), memo API를 수동으로 사용합니다.\n\nReact 팀은 해결책을 소개했습니다: React 컴파일러. 이 새로운 컴파일러는 다시 렌더링 관리를 자동화하는 데 설계되었습니다. React는 이제 자율적으로 상태를 업데이트하고 사용자 인터페이스를 새로 고칠 때 언제, 어떻게 할지 결정합니다.\n\n## 🟢Actions\n\n버전 19에서는 폼 작업 방식을 혁신할 것으로 약속된 Actions라는 흥미로운 새로운 기능이 도입될 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n조치를 취하면 HTML `form/` 태그와 기능들을 심플하게 통합할 수 있어요. 말 그대로, 이제 Actions로 onSubmit 이벤트를 대체할 수 있고, HTML 폼 안에서 속성으로 활용할 수 있어요.\n\n```js\n\"use server\"\nconst submitArticle = async (articleData) => {\n    const newArticle = {\n        title: articleData.get('title'),\n        author: articleData.get('author'),\n        content: articleData.get('content')\n    };\n};\n\nconst ArticleForm= () => {\n    return <form action={submitArticle}>\n        <div>\n            <label>Article Name</label>\n            <input type=\"text\" name='title'/>\n        </div>\n        <div>\n            <label>Author Name</label>\n            <input type=\"text\" name=\"author\" />\n        </div>\n        <div>\n            <label>Content</label>\n            <input type=\"text\" name=\"content\" />\n        </div>\n        <button type='submit'>Submit</button>\n    </form>\n}\n\nexport default ArticleForm;\n```\n\n## 🟢문서 메타데이터\n\n‘title,’ ‘meta 태그,’ 및 ‘description’과 같은 컴포넌트들이 SEO를 최적화하고 접근성을 보장하는 데 중요한 역할을 합니다. React에서는 싱글 페이지 애플리케이션이 널리 사용되는 상황에서 다양한 경로에서 이러한 컴포넌트들을 관리하는 것이 복잡해질 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n현재 개발자들은 경로 전환이나 필요에 따라 메타데이터를 업데이트하기 위해 react-helmet와 같은 도구를 활용하거나 사용자 정의 코드를 작성하는 경우가 많습니다. 그러나 이러한 접근 방식은 반복적이고 SEO 요소(meta 태그 등)를 처리할 때 특히 오류 발생 가능성이 있습니다.\n\n현재:\n\n```js\nimport React, { useEffect } from 'react';\n\nconst ArticleHead = ({ title, description }) => {\n    useEffect(() => {\n        document.title = title;\n\n        const metaDescriptionTag = document.querySelector('meta[name=\"description\"]');\n        if (metaDescriptionTag) {\n            metaDescriptionTag.setAttribute('content', description);\n        }\n    }, [title, description]);\n\n    return null;\n};\n\nexport default ArticleHead;\n```\n\nReact 19 버전 변화:\n\n<div class=\"content-ad\"></div>\n\nReact 19에서는 React 컴포넌트 내에서 타이틀과 메타 태그를 직접 활용할 수 있습니다:\n\n```js\nimport React from 'react';\n\nconst HomePage = () => {\n  return (\n    <>\n      <title>Article Home Page - My Website</title>\n      <meta name=\"description\" content=\"다양한 주제에 대한 최신 기사 및 업데이트를 살펴보세요.\" />\n      {/* 페이지 컨텐츠를 여기에 추가하세요 */}\n    </>\n  );\n};\n\nexport default HomePage;\n```\n\n## 🟢새로운 React Hooks\n\nuseTransition을 사용한 액션:\n\n<div class=\"content-ad\"></div>\n\n- 데이터 변이 중 보류 중인 상태를 처리하기 위한 useTransition 훅을 소개합니다.\n- 낙관적 업데이트, 오류 및 순차적 요청을 효율적으로 관리할 수 있도록 합니다.\n\n새로운 훅:\n\n- useOptimistic: 폼 제출 중 즉시 피드백을 제공합니다.\n- useFormStatus: 폼 상태를 관리합니다(예: pristine, dirty, touched).\n- useFormState: 값 및 오류를 포함한 폼 상태를 추적합니다.\n- useActionState: 일반적인 액션 시나리오를 간소화합니다.\n\n이 흥미로운 주제는 철저한 논의를 위해 별도의 기사가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 React에서 다가오는 개선 사항은 다음과 같습니다:\n\n- suspense를 사용한 최적화된 에셋 로딩을 통한 성능 개선.\n- 웹 컴포넌트를 React에 직접 통합하여 원활한 사용 환경 조성.\n\n웹 컴포넌트 — React (reactjs.org)\n\n👨‍💻 나는 Angular 18과 React 19에 대해 알아가는 것을 고대하고 있어. 이게 내 눈길을 사로잡았어:\n\n<div class=\"content-ad\"></div>\n\nAngular 18:\n\n- Zoneless 지원\n- Angular Material 3\n- 시그널 API\n- 지연 로딩 뷰\n- 이벤트 재생\n- 라우트 리다이렉트\n- 새로운 애플리케이션 빌더\n\nReact 19:\n\n- React 컴파일러\n- 액션들\n- 문서 메타데이터\n- 새로운 훅: useTransition, useOptimistic, useFormStatus, useActionState\n\n<div class=\"content-ad\"></div>\n\n이번 업데이트들은 웹 성능, 사용자 경험, SEO, 그리고 개발자 생산성을 크게 향상시킬 것을 약속합니다. 탐험하고 배우는 것을 기다릴 수가 없네요! 🚀\n\n💡제 소개가 귀하의 호기심을 자극하여 소프트웨어 프로젝트에 Angular 18과 React 19를 탐험하고 싶게 만들었으면 좋겠네요.","ogImage":{"url":"/assets/img/2024-06-22-1819in24UnveilingAngularReactsLatestUpdates_0.png"},"coverImage":"/assets/img/2024-06-22-1819in24UnveilingAngularReactsLatestUpdates_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>👨‍💻 안녕하세요! 전문 개발자로서 웹 개발에 열정을 가지고 있는 Senior Full Stack 엔지니어입니다. 저는 Angular 및 React 프레임워크와 광범위하게 작업한 기회가 있었습니다. 웹 성능을 향상시키는 최신 기능을 탐험하는 것은 항상 흥미로운 일이었습니다.</p>\n<p><img src=\"/assets/img/2024-06-22-1819in24UnveilingAngularReactsLatestUpdates_0.png\" alt=\"\"></p>\n<h1>빠른 소개:</h1>\n<p>만약 이러한 웹 프레임워크가 무엇인지에 대해 생소하다면,</p>\n<div class=\"content-ad\"></div>\n<p>Angular: Angular은 Google에서 지원하는 강력한 프론트엔드 프레임워크로, 효율적인 웹 애플리케이션을 구축하기 위한 다양한 도구를 제공합니다.</p>\n<p>React: Facebook이 만든 React는 재사용 가능한 컴포넌트와 효율적인 렌더링 기술을 통해 상호 작용하는 사용자 인터페이스를 구축하는 것을 단순화한 JavaScript 라이브러리입니다.</p>\n<p>Angular 18과 React 19의 최신 릴리스로 흥미로운 발전이 있고, 그들의 매력적인 기능들을 탐험하는 것을 곧 기대하고 있습니다.</p>\n<h1>Angular 18</h1>\n<div class=\"content-ad\"></div>\n<p>Angular을 처음 사용해보는 분들을 위한 안내입니다. Angular의 홈페이지인 Home • Angular은 지금은 여러분의 첫 걸음을 시작할 수 있는 포괄적이고 가치 있는 자원으로 자리 잡았습니다. Angular 개발의 모든 면을 탐험하고 학습하기에 적합한 다양한 정보, 자습서 및 안내서가 제공됩니다.</p>\n<p>최신 업그레이드에 대해 자세히 살펴보고, 특히 Angular에 처음 접하시는 분들을 위해 이러한 기능들을 일반적인 방식으로 설명해보겠습니다.</p>\n<h2>🟫변경 탐지 개선</h2>\n<p>Zone.js는 비동기 작업을 관리하여 Angular에서 자동으로 변경 탐지를 가능하게 합니다.</p>\n<div class=\"content-ad\"></div>\n<p>앵귤러 사용법:</p>\n<ul>\n<li>비동기 API를 패치합니다.</li>\n<li>변경 감지를 트리거합니다.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>성능 부담</li>\n<li>복잡한 디버깅</li>\n<li>라이브러리 호환성</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>예시:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-article'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &#x3C;div>\n      &#x3C;p>Article이 발행되었습니까?: { isArticlePublished }&#x3C;/p>\n      &#x3C;button (click)=\"publishArticle()\">기사 발행&#x3C;/button>\n    &#x3C;/div>\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArticleComponent</span> {\n  isArticlePublished = <span class=\"hljs-literal\">false</span>;\n\n  <span class=\"hljs-title function_\">publishArticle</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isArticlePublished</span> = <span class=\"hljs-literal\">true</span>;\n    }, <span class=\"hljs-number\">1000</span>);\n  }\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, <span class=\"hljs-title class_\">ChangeDetectorRef</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-article'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &#x3C;div>\n      &#x3C;p>Article이 발행되었습니까?: { isArticlePublished }&#x3C;/p>\n      &#x3C;button (click)=\"publishArticle()\">기사 발행&#x3C;/button>\n    &#x3C;/div>\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArticleComponent</span> {\n  isArticlePublished = <span class=\"hljs-literal\">false</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private cdr: ChangeDetectorRef</span>) {}\n\n  <span class=\"hljs-title function_\">publishArticle</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isArticlePublished</span> = <span class=\"hljs-literal\">true</span>;\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">cdr</span>.<span class=\"hljs-title function_\">detectChanges</span>();  <span class=\"hljs-comment\">// 변경 감지를 수동으로 트리거합니다.</span>\n    }, <span class=\"hljs-number\">1000</span>);\n  }\n}\n</code></pre>\n<p>Angular 18에서는 Angular에서 zoneless 지원을 실험할 수 있습니다! 애플리케이션 부트스트랩에 provideExperimentalZonelessChangeDetection을 추가하기만 하면 됩니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\n  ...\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &#x3C;h1>Hello from { name() }!&#x3C;/h1>\n    &#x3C;button (click)=\"handleClick()\">With Zoneless&#x3C;/button>\n  `</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> {\n  protected <span class=\"hljs-title class_\">IsArticlePublished</span>= <span class=\"hljs-title function_\">signal</span>(<span class=\"hljs-string\">'false'</span>);\n\n  <span class=\"hljs-title function_\">handleClick</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">IsArticlePublished</span>.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">'true'</span>);\n  }\n}\n</code></pre>\n<p>Angular은 변경 감지를 최적화하기 위해 Zones를 사용하지만, Zones 없이도 신호 업데이트와 같은 적은 트리거로 작동할 수 있습니다.</p>\n<h2>🟫Angular Material 3</h2>\n<p>Angular Material은 Angular 애플리케이션에 대한 UI 컴포넌트 라이브러리로서 Google의 Material Design 명세를 구현합니다. 버튼, 입력란, 대화 상자, 내비게이션 패턴 등 재사용 가능하고 테스트된 UI 컴포넌트를 제공합니다.</p>\n<div class=\"content-ad\"></div>\n<p>이러한 구성 요소들은 Material Design 원칙을 준수하여 웹 애플리케이션을위한 일관된 그리고 매력적인 사용자 인터페이스를 제공하도록 설계되었습니다.</p>\n<p>참조: Angular Material UI 구성 요소 라이브러리</p>\n<h2>🟫 미리보는 신호 API</h2>\n<p>신호는 포함된 값에 대한 변경 사항이 있을 때 관심 있는 소비자에게 알림을 주는 값의 캡슐화입니다. 이들은 간단한 유형부터 복잡한 데이터 구조까지 다양한 데이터를 보유할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>신호의 값을 액세스하려면 해당 getter 함수를 호출해야 합니다. 이렇게 하면 Angular이 해당 사용 사항을 모니터링할 수 있습니다. 신호는 쓰기 가능하거나 읽기 전용 형태로 존재할 수 있습니다.</p>\n<p>참고: Signals • 개요 • Angular</p>\n<h2>🟫지연 가능한 뷰</h2>\n<p>구성 요소 템플릿에서 지연 가능한 뷰를 사용하면 구성 요소, 지시문, 파이프 및 관련 CSS와 같은 특정 종속성의로드를 지연시킬 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 기능은 템플릿의 일부를 @defer 블록으로 감싸서 해당 종속성이로드되어야 하는 조건을 정의하는 곳에 구현됩니다.</p>\n<pre><code class=\"hljs language-js\">@defer {\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">articlereview-component</span> /></span></span>\n}\n</code></pre>\n<p>지연로드 가능한 뷰를 통해 개발자들은 쉽게 앱을 향상시키고 번들 크기를 줄일 수 있습니다.</p>\n<h2>🟫이벤트 재생</h2>\n<div class=\"content-ad\"></div>\n<p>사용자 이벤트(예: 클릭) 재생 가능성을 허용하여 수분화 로직이 완료되기 전에 페이지에서 발생한 이벤트를 다시 실행할 수 있습니다.</p>\n<p>예시</p>\n<p>대부분의 개발자가 일반적으로 이벤트 디스패치와 직접 상호 작용하지는 않지만, 이 문맥에서 이벤트 재생이 왜 가치 있는지 살펴봅시다. 기사를 읽는 웹사이트에서 상상해보세요. 우리는 가짜로로드 지연을 사용하여 네트워크 연결이 느린 시나리오를 시뮬레이션할 것입니다.</p>\n<p>페이지가 로드되는 동안이며 완전히 상호작용 가능하기 전에 사용자가 기사를 읽고 여러 기사에 댓글을 남기기로 결정했다면, 페이지가 아직 완전히 상호작용적이지 않은 경우(수분화되지 않은 경우), 이 사용자 동작은 손실될 것입니다.</p>\n<div class=\"content-ad\"></div>\n<p>버전 18부터 Angular은 사용자 상호작용을 기록하기 위해 이벤트 디스패치를 도입했습니다. 페이지가 완전히 로드된 후, Angular은 이러한 이벤트를 재생하여 모든 댓글이 여러 개의 게시물에 성공적으로 제출되도록 보장합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">bootstrapApplication</span>(<span class=\"hljs-title class_\">App</span>, {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideClientHydration</span>(<span class=\"hljs-title function_\">withEventReplay</span>())\n  ]\n});\n</code></pre>\n<h2>🟫ng-content의 콘텐츠를 위한 후속 처리</h2>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-article'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &#x3C;ng-content select=\".article\">게시물 이름&#x3C;/ng-content>\n\n    &#x3C;ng-content>댓글이 없습니다&#x3C;/ng-content>\n  `</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Article</span> {}\n</code></pre>\n<div class=\"content-ad\"></div>\n<h2>🟫통합 형태 컨트롤 상태 변경 이벤트</h2>\n<p>내가 좋아하는 하나: Angular 폼의 FormControl, FormGroup 및 FormArray 클래스에는 이제 'events' 속성이 추가되었습니다.</p>\n<p>이 속성을 사용하면 폼 컨트롤과 관련된 이벤트 스트림을 구독할 수 있어 값 변경, 터치 상태, 원시 상태 및 전반적인 컨트롤 상태의 변경 사항을 모니터링할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> articleFeedbackControl = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FormControl</span>&#x3C;string|<span class=\"hljs-literal\">null</span>>(<span class=\"hljs-string\">'article'</span>, <span class=\"hljs-title class_\">Validators</span>.<span class=\"hljs-property\">required</span>);\nnameControl.<span class=\"hljs-property\">events</span>.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =></span> {\n \n});\n</code></pre>\n<div class=\"content-ad\"></div>\n<h2>🟫 라우트 리다이렉트 개선</h2>\n<p>Angular v18에서는 리다이렉트 처리의 유연성을 향상하기 위해 redirectTo 속성이 이제 문자열을 반환하는 함수를 지원합니다.</p>\n<p>이를 통해 런타임 조건에 따라 보다 복잡한 리다이렉트 로직을 구현할 수 있습니다. 예를 들어, 동적 상태에 따라 리다이렉트해야 하는 경우 이 함수 내에 복잡한 로직을 정의할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">routes</span>: <span class=\"hljs-title class_\">Routes</span> = [\n  { <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'article/:articleId'</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">ArticleComponent</span> },\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'redirect-article'</span>,\n    <span class=\"hljs-attr\">redirectTo</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ queryParams }</span>) =></span> {\n      <span class=\"hljs-keyword\">const</span> articleIdParam = queryParams[<span class=\"hljs-string\">'articleId'</span>];\n      <span class=\"hljs-keyword\">if</span> (articleIdParam) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`/article/<span class=\"hljs-subst\">${articleIdParam}</span>`</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 오류 처리를 하거나 기본 경로로 리다이렉트할 수 있습니다</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`/not-found`</span>;\n      }\n    }\n  },\n  { <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'not-found'</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">NotFoundComponent</span> },\n];\n</code></pre>\n<div class=\"content-ad\"></div>\n<h2>🟫 빌드 개선</h2>\n<p>Angular 16에서는 esbuild 및 Vite와 같은 현대적인 도구를 활용한 새로운 응용 프로그램 빌더를 공개했습니다. 이 빌더는 Angular 17의 새로운 프로젝트에 대한 기본값이 되었습니다.</p>\n<p>새 빌드 시스템으로 이전하기 • Angular</p>\n<p><img src=\"/assets/img/2024-06-22-1819in24UnveilingAngularReactsLatestUpdates_1.png\" alt=\"이미지\"></p>\n<div class=\"content-ad\"></div>\n<h2>지금 React 19 기능에 대해 이야기해 봅시다</h2>\n<p><img src=\"/assets/img/2024-06-22-1819in24UnveilingAngularReactsLatestUpdates_2.png\" alt=\"React 19\"></p>\n<h1>React 19</h1>\n<h2>🟢 React 컴파일러</h2>\n<div class=\"content-ad\"></div>\n<p>현재 React는 상태 변경 시 자동으로 다시 렌더링되지 않습니다. 이러한 다시 렌더링을 최적화하기 위해 개발자들은 보통 useMemo(), useCallback(), memo API를 수동으로 사용합니다.</p>\n<p>React 팀은 해결책을 소개했습니다: React 컴파일러. 이 새로운 컴파일러는 다시 렌더링 관리를 자동화하는 데 설계되었습니다. React는 이제 자율적으로 상태를 업데이트하고 사용자 인터페이스를 새로 고칠 때 언제, 어떻게 할지 결정합니다.</p>\n<h2>🟢Actions</h2>\n<p>버전 19에서는 폼 작업 방식을 혁신할 것으로 약속된 Actions라는 흥미로운 새로운 기능이 도입될 예정입니다.</p>\n<div class=\"content-ad\"></div>\n<p>조치를 취하면 HTML <code>form/</code> 태그와 기능들을 심플하게 통합할 수 있어요. 말 그대로, 이제 Actions로 onSubmit 이벤트를 대체할 수 있고, HTML 폼 안에서 속성으로 활용할 수 있어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">\"use server\"</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">submitArticle</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">articleData</span>) => {\n    <span class=\"hljs-keyword\">const</span> newArticle = {\n        <span class=\"hljs-attr\">title</span>: articleData.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'title'</span>),\n        <span class=\"hljs-attr\">author</span>: articleData.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'author'</span>),\n        <span class=\"hljs-attr\">content</span>: articleData.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'content'</span>)\n    };\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ArticleForm</span>= (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">{submitArticle}</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>Article Name<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">'title'</span>/></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>Author Name<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"author\"</span> /></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>Content<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"content\"</span> /></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">'submit'</span>></span>Submit<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">form</span>></span></span>\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ArticleForm</span>;\n</code></pre>\n<h2>🟢문서 메타데이터</h2>\n<p>‘title,’ ‘meta 태그,’ 및 ‘description’과 같은 컴포넌트들이 SEO를 최적화하고 접근성을 보장하는 데 중요한 역할을 합니다. React에서는 싱글 페이지 애플리케이션이 널리 사용되는 상황에서 다양한 경로에서 이러한 컴포넌트들을 관리하는 것이 복잡해질 수 있어요.</p>\n<div class=\"content-ad\"></div>\n<p>현재 개발자들은 경로 전환이나 필요에 따라 메타데이터를 업데이트하기 위해 react-helmet와 같은 도구를 활용하거나 사용자 정의 코드를 작성하는 경우가 많습니다. 그러나 이러한 접근 방식은 반복적이고 SEO 요소(meta 태그 등)를 처리할 때 특히 오류 발생 가능성이 있습니다.</p>\n<p>현재:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ArticleHead</span> = (<span class=\"hljs-params\">{ title, description }</span>) => {\n    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">title</span> = title;\n\n        <span class=\"hljs-keyword\">const</span> metaDescriptionTag = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">'meta[name=\"description\"]'</span>);\n        <span class=\"hljs-keyword\">if</span> (metaDescriptionTag) {\n            metaDescriptionTag.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'content'</span>, description);\n        }\n    }, [title, description]);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ArticleHead</span>;\n</code></pre>\n<p>React 19 버전 변화:</p>\n<div class=\"content-ad\"></div>\n<p>React 19에서는 React 컴포넌트 내에서 타이틀과 메타 태그를 직접 활용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">HomePage</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">title</span>></span>Article Home Page - My Website<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">title</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"description\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"다양한 주제에 대한 최신 기사 및 업데이트를 살펴보세요.\"</span> /></span>\n      {/* 페이지 컨텐츠를 여기에 추가하세요 */}\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">HomePage</span>;\n</code></pre>\n<h2>🟢새로운 React Hooks</h2>\n<p>useTransition을 사용한 액션:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>데이터 변이 중 보류 중인 상태를 처리하기 위한 useTransition 훅을 소개합니다.</li>\n<li>낙관적 업데이트, 오류 및 순차적 요청을 효율적으로 관리할 수 있도록 합니다.</li>\n</ul>\n<p>새로운 훅:</p>\n<ul>\n<li>useOptimistic: 폼 제출 중 즉시 피드백을 제공합니다.</li>\n<li>useFormStatus: 폼 상태를 관리합니다(예: pristine, dirty, touched).</li>\n<li>useFormState: 값 및 오류를 포함한 폼 상태를 추적합니다.</li>\n<li>useActionState: 일반적인 액션 시나리오를 간소화합니다.</li>\n</ul>\n<p>이 흥미로운 주제는 철저한 논의를 위해 별도의 기사가 필요합니다.</p>\n<div class=\"content-ad\"></div>\n<p>그리고 React에서 다가오는 개선 사항은 다음과 같습니다:</p>\n<ul>\n<li>suspense를 사용한 최적화된 에셋 로딩을 통한 성능 개선.</li>\n<li>웹 컴포넌트를 React에 직접 통합하여 원활한 사용 환경 조성.</li>\n</ul>\n<p>웹 컴포넌트 — React (reactjs.org)</p>\n<p>👨‍💻 나는 Angular 18과 React 19에 대해 알아가는 것을 고대하고 있어. 이게 내 눈길을 사로잡았어:</p>\n<div class=\"content-ad\"></div>\n<p>Angular 18:</p>\n<ul>\n<li>Zoneless 지원</li>\n<li>Angular Material 3</li>\n<li>시그널 API</li>\n<li>지연 로딩 뷰</li>\n<li>이벤트 재생</li>\n<li>라우트 리다이렉트</li>\n<li>새로운 애플리케이션 빌더</li>\n</ul>\n<p>React 19:</p>\n<ul>\n<li>React 컴파일러</li>\n<li>액션들</li>\n<li>문서 메타데이터</li>\n<li>새로운 훅: useTransition, useOptimistic, useFormStatus, useActionState</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>이번 업데이트들은 웹 성능, 사용자 경험, SEO, 그리고 개발자 생산성을 크게 향상시킬 것을 약속합니다. 탐험하고 배우는 것을 기다릴 수가 없네요! 🚀</p>\n<p>💡제 소개가 귀하의 호기심을 자극하여 소프트웨어 프로젝트에 Angular 18과 React 19를 탐험하고 싶게 만들었으면 좋겠네요.</p>\n</body>\n</html>\n"},"__N_SSG":true}