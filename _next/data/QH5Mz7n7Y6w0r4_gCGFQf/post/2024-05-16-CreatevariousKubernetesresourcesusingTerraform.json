{"pageProps":{"post":{"title":"테라폼을 사용하여 다양한 쿠버네티스 리소스 생성하기","description":"","date":"2024-05-16 03:50","slug":"2024-05-16-CreatevariousKubernetesresourcesusingTerraform","content":"\n\n<img src=\"/assets/img/2024-05-16-CreatevariousKubernetesresourcesusingTerraform_0.png\" />\n\n테라폼을 사용하여 쿠버네티스(Kubernetes) 리소스를 생성하는 것은 인프라를 코드로 정의하는 것을 의미합니다. 이를 통해 배포하는 과정에서 자동화, 버전 관리 및 재현성이 가능해집니다.\n\n여기서는 테라폼을 사용하여 일반적인 쿠버네티스 리소스인 네임스페이스, 디플로이먼트 및 서비스를 생성하는 방법에 대해 안내하겠습니다.\n\n## 테라폼이 쿠버네티스 클러스터 프로비저닝에 좋은 도구인 이유:\n\n\n\n- Terraform은 사용자가 Kubernetes 클러스터 정의를 코드로 유지할 수 있게 해줍니다.\n- 하부 인프라 구성을 위해 동일한 선언적 구문을 사용합니다.\n- Terraform을 사용하면 변수를 통해 Kubernetes 클러스터를 수정할 수 있습니다.\n- 변경 사항이 적용되기 전에 Kubernetes 클러스터에 대한 수정 사항을 먼저 미리 확인할 수 있는 dry-run 기능이 있습니다.\n- Terraform의 중요한 이점 중 하나는 Kubernetes 프로비저닝 및 그에 따른 응용 프로그램 배포에 동일한 구성 언어를 사용할 수 있는 능력입니다.\n- Terraform을 사용하면 API를 확인할 필요 없이 pod 및 리소스를 생성, 업데이트 및 삭제하는 데 하나의 명령어만 필요합니다.\n- Terraform은 리소스 간의 관계를 인식하고 코드에서 인프라를 모듈화합니다.\n- Terraform은 제품 출시 시간을 단축시키며 재해 복구 시간과 릴리스 문제에 도움을 줍니다.\n\n## 준비 사항:\n\n- 가동 중인 Kubernetes 클러스터\n- Terraform 및 kubectl 설치 및 구성\n\n이제 자원을 생성해 봅시다.\n\n\n\n## 단계 1: Terraform 구성 설정하기\n\n- Terraform 프로젝트 디렉토리를 만듭니다.\n\n```js\nmkdir terraform-k8s && cd terraform-k8s\n```\n\n- Kubernetes 공급자를 정의하는 provider.tf 파일을 만듭니다.\n\n\n\n```js\nterraform {\n  required_providers {\n    kubernetes = {\n      source = \"hashicorp/kubernetes\"\n    }\n  }\n}\n\nprovider \"kubernetes\" {\n  config_path = \"~/.kube/config\"\n}\n```\n\n## Step 2: Define Kubernetes Resources\n\n- Create a `namespace.tf` file to define a Kubernetes namespace.\n\n```js\nresource \"kubernetes_namespace\" \"demo\" {\n  metadata {\n    name = \"demo-namespace\"\n  }\n}\n```\n\n\n\n- 애플리케이션을 배포하기 위한 deployment.tf 파일을 생성하세요.\n\n```js\nresource \"kubernetes_deployment\" \"demo\" {\n  metadata {\n    name = \"demo-deployment\"\n    namespace = kubernetes_namespace.example.metadata[0].name\n  }\n\n  spec {\n    replicas = 3\n    selector {\n      match_labels = {\n        app = \"demo\"\n      }\n    }\n\n    template {\n      metadata {\n        labels = {\n          app = \"demo\"\n        }\n      }\n\n      spec {\n        container {\n          image = \"nginx:latest\"\n          name  = \"demo-deployment\"\n        }\n      }\n    }\n  }\n}\n```\n\n- 배포를 노출하기 위한 service.tf 파일을 생성하세요.\n\n```js\nresource \"kubernetes_service\" \"demo\" {\n  metadata {\n    name = \"demo-service\"\n    namespace = kubernetes_namespace.example.metadata[0].name\n  }\n\n  spec {\n    selector = {\n      app = \"example\"\n    }\n\n    port {\n      port        = 80\n      target_port = 80\n    }\n\n    type = \"LoadBalancer\"\n  }\n}\n```\n\n\n\n- 구성 맵을 정의하는 configmap.tf 파일을 작성하세요.\n\n```js\nresource \"kubernetes_config_map\" \"demo\" {\n  metadata {\n    name = \"demo-config\"\n    namespace = kubernetes_namespace.example.metadata[0].name\n  }\n\n  data = {\n    \"config.json\" = jsonencode({\n      \"key\" = \"value\"\n    })\n  }\n}\n```\n\n- Kubernetes 시크릿을 정의하는 secret.tf 파일을 작성하세요.\n\n```js\nresource \"kubernetes_secret\" \"demo\" {\n  metadata {\n    name = \"demo-secret\"\n    namespace = kubernetes_namespace.example.metadata[0].name\n  }\n\n  data = {\n    \"password\" = base64encode(\"supersecret\")\n  }\n}\n```\n\n\n\n- PersistentVolumeClaim을 정의하는 pvc.tf 파일을 만들어보세요.\n\n```javascript\nresource \"kubernetes_persistent_volume_claim\" \"demo\" {\n  metadata {\n    name = \"demo-pvc\"\n    namespace = kubernetes_namespace.example.metadata[0].name\n  }\n\n  spec {\n    access_modes = [\"ReadWriteOnce\"]\n    resources {\n      requests = {\n        storage = \"10Gi\"\n      }\n    }\n  }\n}\n```\n\n- 이제, 배포 파일을 수정하여 ConfigMap과 Secret을 마운트하도록 해봅시다.\n\n```javascript\nresource \"kubernetes_deployment\" \"demo\" {\n  metadata {\n    name = \"demo-deployment\"\n    namespace = kubernetes_namespace.example.metadata[0].name\n  }\n\n  spec {\n    replicas = 3\n    selector {\n      match_labels = {\n        app = \"demo\"\n      }\n    }\n\n    template {\n      metadata {\n        labels = {\n          app = \"demo\"\n        }\n      }\n\n      spec {\n        container {\n          image = \"nginx:latest\"\n          name  = \"demo\"\n\n          volume_mount {\n            mount_path = \"/etc/config\"\n            name       = \"config\"\n          }\n\n          volume_mount {\n            mount_path = \"/etc/secret\"\n            name       = \"secret\"\n            read_only  = true\n          }\n        }\n\n        volume {\n          name = \"config\"\n          config_map {\n            name = kubernetes_config_map.example.metadata[0].name\n          }\n        }\n\n        volume {\n          name = \"secret\"\n          secret {\n            secret_name = kubernetes_secret.example.metadata[0].name\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n\n\n## 단계 3: 작업 디렉터리 초기화\n\n- 작업 디렉터리에서 terraform init 명령을 실행하십시오. 이 명령은 필요한 모든 공급자를 다운로드하고 모든 모듈을 초기화하며 백엔드도 초기화합니다.\n\n## 단계 4: Terraform 실행 계획 생성\n\n- 작업 디렉터리에서 terraform plan 명령을 실행하십시오. 이 명령은 실행 계획을 제공합니다.\n\n\n\n## 단계 5: Terraform apply 실행\n\n- 작업 디렉토리에서 terraform apply 명령을 실행하면 AWS에 필요한 모든 리소스가 생성됩니다.\n\n## 단계 6: 리소스 확인\n\n- Terraform이 변경 사항을 적용한 후, 리소스가 올바르게 배포되었는지 확인하세요.\n\n\n\n```js\nkubectl get all --namespace=demo-namespace\n```\n\n여기까지만 하면, 이제 Terraform을 사용하여 다양한 K8s 리소스를 생성하는 방법을 배웠습니다. 이제 이를 사용하여 필요에 따라 수정하고 실험할 수 있습니다.\n\n이 안내서가 도움이 되었다면 👏 버튼을 클릭해 주시고 댓글을 자유롭게 남겨주세요.\n\n이와 같은 이야기를 더 보시려면 팔로우 해주세요 😊\n\n\n\n\n# 스택데믹 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해 주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-16-CreatevariousKubernetesresourcesusingTerraform_0.png"},"coverImage":"/assets/img/2024-05-16-CreatevariousKubernetesresourcesusingTerraform_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-05-16-CreatevariousKubernetesresourcesusingTerraform_0.png\">\n<p>테라폼을 사용하여 쿠버네티스(Kubernetes) 리소스를 생성하는 것은 인프라를 코드로 정의하는 것을 의미합니다. 이를 통해 배포하는 과정에서 자동화, 버전 관리 및 재현성이 가능해집니다.</p>\n<p>여기서는 테라폼을 사용하여 일반적인 쿠버네티스 리소스인 네임스페이스, 디플로이먼트 및 서비스를 생성하는 방법에 대해 안내하겠습니다.</p>\n<h2>테라폼이 쿠버네티스 클러스터 프로비저닝에 좋은 도구인 이유:</h2>\n<ul>\n<li>Terraform은 사용자가 Kubernetes 클러스터 정의를 코드로 유지할 수 있게 해줍니다.</li>\n<li>하부 인프라 구성을 위해 동일한 선언적 구문을 사용합니다.</li>\n<li>Terraform을 사용하면 변수를 통해 Kubernetes 클러스터를 수정할 수 있습니다.</li>\n<li>변경 사항이 적용되기 전에 Kubernetes 클러스터에 대한 수정 사항을 먼저 미리 확인할 수 있는 dry-run 기능이 있습니다.</li>\n<li>Terraform의 중요한 이점 중 하나는 Kubernetes 프로비저닝 및 그에 따른 응용 프로그램 배포에 동일한 구성 언어를 사용할 수 있는 능력입니다.</li>\n<li>Terraform을 사용하면 API를 확인할 필요 없이 pod 및 리소스를 생성, 업데이트 및 삭제하는 데 하나의 명령어만 필요합니다.</li>\n<li>Terraform은 리소스 간의 관계를 인식하고 코드에서 인프라를 모듈화합니다.</li>\n<li>Terraform은 제품 출시 시간을 단축시키며 재해 복구 시간과 릴리스 문제에 도움을 줍니다.</li>\n</ul>\n<h2>준비 사항:</h2>\n<ul>\n<li>가동 중인 Kubernetes 클러스터</li>\n<li>Terraform 및 kubectl 설치 및 구성</li>\n</ul>\n<p>이제 자원을 생성해 봅시다.</p>\n<h2>단계 1: Terraform 구성 설정하기</h2>\n<ul>\n<li>Terraform 프로젝트 디렉토리를 만듭니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">mkdir terraform-k8s &#x26;&#x26; cd terraform-k8s\n</code></pre>\n<ul>\n<li>Kubernetes 공급자를 정의하는 provider.tf 파일을 만듭니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">terraform {\n  required_providers {\n    kubernetes = {\n      source = <span class=\"hljs-string\">\"hashicorp/kubernetes\"</span>\n    }\n  }\n}\n\nprovider <span class=\"hljs-string\">\"kubernetes\"</span> {\n  config_path = <span class=\"hljs-string\">\"~/.kube/config\"</span>\n}\n</code></pre>\n<h2>Step 2: Define Kubernetes Resources</h2>\n<ul>\n<li>Create a <code>namespace.tf</code> file to define a Kubernetes namespace.</li>\n</ul>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"kubernetes_namespace\"</span> <span class=\"hljs-string\">\"demo\"</span> {\n  metadata {\n    name = <span class=\"hljs-string\">\"demo-namespace\"</span>\n  }\n}\n</code></pre>\n<ul>\n<li>애플리케이션을 배포하기 위한 deployment.tf 파일을 생성하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"kubernetes_deployment\"</span> <span class=\"hljs-string\">\"demo\"</span> {\n  metadata {\n    name = <span class=\"hljs-string\">\"demo-deployment\"</span>\n    namespace = kubernetes_namespace.<span class=\"hljs-property\">example</span>.<span class=\"hljs-property\">metadata</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\n  }\n\n  spec {\n    replicas = <span class=\"hljs-number\">3</span>\n    selector {\n      match_labels = {\n        app = <span class=\"hljs-string\">\"demo\"</span>\n      }\n    }\n\n    template {\n      metadata {\n        labels = {\n          app = <span class=\"hljs-string\">\"demo\"</span>\n        }\n      }\n\n      spec {\n        container {\n          image = <span class=\"hljs-string\">\"nginx:latest\"</span>\n          name  = <span class=\"hljs-string\">\"demo-deployment\"</span>\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>배포를 노출하기 위한 service.tf 파일을 생성하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"kubernetes_service\"</span> <span class=\"hljs-string\">\"demo\"</span> {\n  metadata {\n    name = <span class=\"hljs-string\">\"demo-service\"</span>\n    namespace = kubernetes_namespace.<span class=\"hljs-property\">example</span>.<span class=\"hljs-property\">metadata</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\n  }\n\n  spec {\n    selector = {\n      app = <span class=\"hljs-string\">\"example\"</span>\n    }\n\n    port {\n      port        = <span class=\"hljs-number\">80</span>\n      target_port = <span class=\"hljs-number\">80</span>\n    }\n\n    type = <span class=\"hljs-string\">\"LoadBalancer\"</span>\n  }\n}\n</code></pre>\n<ul>\n<li>구성 맵을 정의하는 configmap.tf 파일을 작성하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"kubernetes_config_map\"</span> <span class=\"hljs-string\">\"demo\"</span> {\n  metadata {\n    name = <span class=\"hljs-string\">\"demo-config\"</span>\n    namespace = kubernetes_namespace.<span class=\"hljs-property\">example</span>.<span class=\"hljs-property\">metadata</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\n  }\n\n  data = {\n    <span class=\"hljs-string\">\"config.json\"</span> = <span class=\"hljs-title function_\">jsonencode</span>({\n      <span class=\"hljs-string\">\"key\"</span> = <span class=\"hljs-string\">\"value\"</span>\n    })\n  }\n}\n</code></pre>\n<ul>\n<li>Kubernetes 시크릿을 정의하는 secret.tf 파일을 작성하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"kubernetes_secret\"</span> <span class=\"hljs-string\">\"demo\"</span> {\n  metadata {\n    name = <span class=\"hljs-string\">\"demo-secret\"</span>\n    namespace = kubernetes_namespace.<span class=\"hljs-property\">example</span>.<span class=\"hljs-property\">metadata</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\n  }\n\n  data = {\n    <span class=\"hljs-string\">\"password\"</span> = <span class=\"hljs-title function_\">base64encode</span>(<span class=\"hljs-string\">\"supersecret\"</span>)\n  }\n}\n</code></pre>\n<ul>\n<li>PersistentVolumeClaim을 정의하는 pvc.tf 파일을 만들어보세요.</li>\n</ul>\n<pre><code class=\"hljs language-javascript\">resource <span class=\"hljs-string\">\"kubernetes_persistent_volume_claim\"</span> <span class=\"hljs-string\">\"demo\"</span> {\n  metadata {\n    name = <span class=\"hljs-string\">\"demo-pvc\"</span>\n    namespace = kubernetes_namespace.<span class=\"hljs-property\">example</span>.<span class=\"hljs-property\">metadata</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\n  }\n\n  spec {\n    access_modes = [<span class=\"hljs-string\">\"ReadWriteOnce\"</span>]\n    resources {\n      requests = {\n        storage = <span class=\"hljs-string\">\"10Gi\"</span>\n      }\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>이제, 배포 파일을 수정하여 ConfigMap과 Secret을 마운트하도록 해봅시다.</li>\n</ul>\n<pre><code class=\"hljs language-javascript\">resource <span class=\"hljs-string\">\"kubernetes_deployment\"</span> <span class=\"hljs-string\">\"demo\"</span> {\n  metadata {\n    name = <span class=\"hljs-string\">\"demo-deployment\"</span>\n    namespace = kubernetes_namespace.<span class=\"hljs-property\">example</span>.<span class=\"hljs-property\">metadata</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\n  }\n\n  spec {\n    replicas = <span class=\"hljs-number\">3</span>\n    selector {\n      match_labels = {\n        app = <span class=\"hljs-string\">\"demo\"</span>\n      }\n    }\n\n    template {\n      metadata {\n        labels = {\n          app = <span class=\"hljs-string\">\"demo\"</span>\n        }\n      }\n\n      spec {\n        container {\n          image = <span class=\"hljs-string\">\"nginx:latest\"</span>\n          name  = <span class=\"hljs-string\">\"demo\"</span>\n\n          volume_mount {\n            mount_path = <span class=\"hljs-string\">\"/etc/config\"</span>\n            name       = <span class=\"hljs-string\">\"config\"</span>\n          }\n\n          volume_mount {\n            mount_path = <span class=\"hljs-string\">\"/etc/secret\"</span>\n            name       = <span class=\"hljs-string\">\"secret\"</span>\n            read_only  = <span class=\"hljs-literal\">true</span>\n          }\n        }\n\n        volume {\n          name = <span class=\"hljs-string\">\"config\"</span>\n          config_map {\n            name = kubernetes_config_map.<span class=\"hljs-property\">example</span>.<span class=\"hljs-property\">metadata</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\n          }\n        }\n\n        volume {\n          name = <span class=\"hljs-string\">\"secret\"</span>\n          secret {\n            secret_name = kubernetes_secret.<span class=\"hljs-property\">example</span>.<span class=\"hljs-property\">metadata</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<h2>단계 3: 작업 디렉터리 초기화</h2>\n<ul>\n<li>작업 디렉터리에서 terraform init 명령을 실행하십시오. 이 명령은 필요한 모든 공급자를 다운로드하고 모든 모듈을 초기화하며 백엔드도 초기화합니다.</li>\n</ul>\n<h2>단계 4: Terraform 실행 계획 생성</h2>\n<ul>\n<li>작업 디렉터리에서 terraform plan 명령을 실행하십시오. 이 명령은 실행 계획을 제공합니다.</li>\n</ul>\n<h2>단계 5: Terraform apply 실행</h2>\n<ul>\n<li>작업 디렉토리에서 terraform apply 명령을 실행하면 AWS에 필요한 모든 리소스가 생성됩니다.</li>\n</ul>\n<h2>단계 6: 리소스 확인</h2>\n<ul>\n<li>Terraform이 변경 사항을 적용한 후, 리소스가 올바르게 배포되었는지 확인하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">kubectl get all --namespace=demo-namespace\n</code></pre>\n<p>여기까지만 하면, 이제 Terraform을 사용하여 다양한 K8s 리소스를 생성하는 방법을 배웠습니다. 이제 이를 사용하여 필요에 따라 수정하고 실험할 수 있습니다.</p>\n<p>이 안내서가 도움이 되었다면 👏 버튼을 클릭해 주시고 댓글을 자유롭게 남겨주세요.</p>\n<p>이와 같은 이야기를 더 보시려면 팔로우 해주세요 😊</p>\n<h1>스택데믹 🎓</h1>\n<p>끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:</p>\n<ul>\n<li>작가를 클랩하고 팔로우해 주시면 감사하겠습니다! 👏</li>\n<li>팔로우하기: X | LinkedIn | YouTube | Discord</li>\n<li>다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed</li>\n<li>알고리즘 콘텐츠를 다루도록 강요하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요</li>\n<li>더 많은 콘텐츠는 Stackademic.com에서 확인하세요</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}