{"pageProps":{"post":{"title":"모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술","description":"","date":"2024-06-22 05:16","slug":"2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow","content":"\n\n<img src=\"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png\" />\n\n자바스크립트는 현대 웹 개발에서 필수적인 다목적 강력한 언어입니다. 이 글에서는 여러분을 더 효율적이고 효과적인 자바스크립트 개발자로 만들어 줄 수 있는 슈퍼 해킹 기술들을 소개하고 각각에 대한 상세한 설명과 예제를 제공합니다.\n\n## 1. `var` 대신 `let` 및 `const` 사용하기\n\n문제: `var`은 함수 범위를 가지고 있어서 버그와 예상치 못한 동작을 유발할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: 블록 스코프를 갖는 `let`과 `const`를 사용하세요.\n\n```js\nlet count = 0;\nconst PI = 3.14;\n```\n\n`let`과 `const`를 사용하면 변수를 정의된 블록 내에서만 접근할 수 있도록 하여 스코프 관련 버그를 방지할 수 있습니다.\n\n## 2. 기본 매개변수\n\n<div class=\"content-ad\"></div>\n\n문제: 인수가 제공되지 않으면 함수가 실패할 수 있습니다.\n\n해결책: 기본 매개변수를 사용하여 대안 값 설정.\n\n```js\nfunction greet(name = '방문자') {\nreturn `안녕하세요, ${name}님!`;\n}\nconsole.log(greet()); // \"안녕하세요, 방문자님!\"\n```\n\n기본 매개변수를 사용하면 함수가 합리적인 기본값을 갖도록되어 오류를 방지하고 코드를 더 견고하게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. 템플릿 리터럴\n\n문제: 문자열 연결은 번거로우며 오류가 발생하기 쉽습니다.\n\n해결책: 더 깔끔하고 가독성이 좋은 문자열 보간을 위해 템플릿 리터럴을 사용하세요.\n\n```js\nconst name = 'John';\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting); // \"Hello, John!\"\n```\n\n<div class=\"content-ad\"></div>\n\n템플릿 리터럴을 사용하면 포함된 표현식과 여러 줄의 문자열을 쉽게 만들 수 있어요.\n\n## 4. 비구조화 할당\n\n문제: 객체와 배열에서 값 추출하는 과정이 장황할 수 있어요.\n\n해결책: 비구조화 할당을 사용해서 값을 더 간결하게 추출하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst user = { name: 'Jane', age: 25 };\nconst { name, age } = user;\nconsole.log(name, age); // \"Jane\" 25\n```\n\n구조 분해 할당을 사용하면 객체에서 속성을 추출하고 배열에서 요소를 쉽게 각각의 변수로 추출할 수 있습니다.\n\n## 5. 화살표 함수\n\n문제: 기존 함수 표현식은 장황할 수 있고 `this`를 렉시컬하게 바인딩하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 더 짧은 구문을 위해 화살표 함수를 사용하고 렉시컬 `this`를 활용하세요.\n\n```js\nconst add = (a, b) => a + b;\nconsole.log(add(2, 3)); // 5\n```\n\n화살표 함수는 함수 표현식에 대해 간결한 구문을 제공하며 `this`가 렉시컬하게 바인딩되어 있는지 보장합니다.\n\n## 6. 전개 연산자\n\n<div class=\"content-ad\"></div>\n\n문제: 배열이나 객체를 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 전개 연산자를 사용하여 배열과 객체를 쉽게 결합하세요.\n\n```js\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = […arr1, …arr2];\nconsole.log(combined); // [1, 2, 3, 4, 5, 6]\n```\n\n전개 연산자를 사용하면 배열이나 객체의 요소를 다른 배열이나 객체로 전개할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 7. 나머지 매개변수\n\n문제: 함수에 변수 수의 인수를 처리하는 것은 까다로울 수 있습니다.\n\n해결책: 모든 인수를 배열에 캡처하기 위해 나머지 매개변수를 사용합니다.\n\n```js\nfunction sum(…args) {\nreturn args.reduce((total, num) => total + num, 0);\n}\nconsole.log(sum(1, 2, 3, 4)); // 10\n```\n\n<div class=\"content-ad\"></div>\n\n레스트 매개변수를 사용하면 매개변수의 개수에 상관없이 배열로 처리할 수 있어 함수를 보다 유연하게 만들 수 있어요.\n\n## 8. 단락 평가\n\n문제: 조건문을 작성하는 것은 매우 번거로울 수 있어요.\n\n해결책: 간결한 조건을 작성하기 위해 단락 평가를 활용해보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst isLoggedIn = true;\nconst user = isLoggedIn && { name: 'Jane', age: 25 };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n단축 평가는 논리적 `&&` 및 `||` 연산자를 사용하여 조건식을 간단하게 만듭니다.\n\n## 9. 선택적 체이닝\n\n문제: 깊게 중첩된 속성에 액세스하는 것은 체인의 일부가 `null` 또는 `undefined`인 경우 오류를 발생시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: 중첩된 속성에 안전하게 접근하기 위해 선택적 체이닝을 사용하세요.\n\n```js\nconst user = { profile: { name: 'Jane' } };\nconst userName = user?.profile?.name;\nconsole.log(userName); // \"Jane\"\n```\n\n선택적 체이닝을 사용하면 `null` 또는 `undefined`인지 명시적으로 확인하지 않고도 중첩된 속성에 안전하게 접근할 수 있습니다.\n\n## 10. 널리쉬 콜리싱\n\n<div class=\"content-ad\"></div>\n\n문제: `||`를 사용하여 기본 값을 제공하는 경우, 값이 `0` 또는 `\"\"`이면 예상치 못한 결과가 발생할 수 있습니다.\n\n해결책: `nullish coalescing` (`??`)을 사용하여 `null` 또는 `undefined`일 때만 기본 값을 제공합니다.\n\n```js\nconst user = { name: '', age: 0 };\nconst userName = user.name ?? '익명';\nconst userAge = user.age ?? 18;\nconsole.log(userName); // \"\"\nconsole.log(userAge); // 0\n```\n\n`Nullish coalescing`은 왼쪽 피연산자가 `null` 또는 `undefined`일 때에만 기본 값을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 11. 객체 속성 축약\n\n문제: 객체 속성에 변수를 할당하는 작업이 반복적 일 수 있습니다.\n\n해결책: 속성 축약을 사용하여 객체 생성을 간단하게 만듭니다.\n\n```js\nconst name = 'Jane';\nconst age = 25;\nconst user = { name, age };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n<div class=\"content-ad\"></div>\n\n프로퍼티 축약형을 사용하면 변수 이름과 일치할 때 프로퍼티 이름을 생략할 수 있어서 코드가 더 깔끔해집니다.\n\n## 12. 동적 프로퍼티 이름\n\n문제: 동적 프로퍼티 이름으로 객체를 생성하는 것은 다소 장황할 수 있습니다.\n\n해결책: 계산된 프로퍼티 이름을 사용하여 동적으로 객체 프로퍼티를 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst propName = '나이';\nconst user = { 이름: '제인', [propName]: 25 };\nconsole.log(user); // { 이름: '제인', 나이: 25 }\n```\n\n계산된 속성 이름을 사용하면 식의 값으로 속성 이름을 동적으로 만들 수 있습니다.\n\n## 13. 배열 `map()`, `filter()`, 및 `reduce()`\n\n문제: 배열을 변환, 필터링 또는 값 누적하기 위해 배열을 반복하는 작업은 반복적일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 일반적인 배열 작업에 `map()`, `filter()`, 및 `reduce()`를 사용하세요.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\nconst evens = numbers.filter(num => num % 2 === 0);\nconsole.log(evens); // [2, 4]\nconst sum = numbers.reduce((total, num) => total + num, 0);\nconsole.log(sum); // 15\n```\n\n이러한 배열 메서드들은 배열을 변환하고 필터링하며 줄이는 함수적인 방식을 제공하여, 코드를 더 표현적이고 간결하게 만듭니다.\n\n## 14. 문자열 `includes()`, `startsWith()`, 및 `endsWith()`\n\n<div class=\"content-ad\"></div>\n\n문제: 문자열에 특정 부분 문자열이 포함되어 있는지, 시작하는지 또는 끝나는지를 확인하는 작업은 장황할 수 있습니다.\n\n해결책: 더 간단한 문자열 확인을 위해 `includes()`, `startsWith()`, `endsWith()`를 사용하세요.\n\n```js\nconst str = 'Hello, world!';\nconsole.log(str.includes('world')); // true\nconsole.log(str.startsWith('Hello')); // true\nconsole.log(str.endsWith('!')); // true\n```\n\n이러한 문자열 메소드들은 부분 문자열의 존재, 시작 또는 끝을 확인하는 간단하고 가독성 있는 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 15. 함수 매개변수에서 배열 및 객체 비구조화\n\n문제: 함수 매개변수로 전달된 배열 또는 객체에서 값을 추출하는 것은 장황할 수 있습니다.\n\n해결책: 함수 매개변수에서 비구조화를 사용하여 값을 직접 추출하세요.\n\n```js\nconst user = { name: 'Jane', age: 25 };\nfunction greet({ name, age }) {\n    return `안녕, ${name}! 당신은 ${age}살 입니다.`;\n}\nconsole.log(greet(user)); // \"안녕, Jane! 당신은 25살 입니다.\"\n```\n\n<div class=\"content-ad\"></div>\n\n함수 매개변수의 구조 분해를 사용하면 함수에 전달된 객체나 배열에서 값을 직접 추출하여 코드를 더 간결하고 가독성 있게 만들 수 있어요.\n\n## 16. 구조 분해에서 기본값 활용\n\n문제: 객체의 구조 분해 시 누락된 속성을 다루는 것은 복잡할 수 있어요.\n\n해결책: 구조 분해에서 기본값을 사용하여 대체 값을 제공해요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst user = { name: 'Jane' };\nconst { name, age = 18 } = user;\nconsole.log(name); // \"Jane\"\nconsole.log(age); // 18\n```\n\n구조 분해 안에 기본 값(default values)을 설정하면 누락될 수 있는 속성에 대한 대체 값을 제공할 수 있어 코드를 보다 견고하게 만들어줍니다.\n\n## 17. Object `assign()`\n\n문제: 객체를 복제하거나 병합하는 것은 번거롭고 실수하기 쉽습니다.\n\n<div class=\"content-ad\"></div>\n\n해결 방법: `Object.assign()`을 사용하여 객체를 복제하거나 병합할 수 있습니다.\n\n```js\nconst target = { a: 1 };\nconst source = { b: 2 };\nconst merged = Object.assign(target, source);\nconsole.log(merged); // { a: 1, b: 2 }\n```\n\n`Object.assign()`을 사용하면 객체를 효율적으로 복제하거나 병합할 수 있어서 수동 복사가 필요한 경우를 줄일 수 있습니다.\n\n## 18. Array `find()` 및 `findIndex()`\n\n<div class=\"content-ad\"></div>\n\n문제: 배열에서 요소나 인덱스를 찾는 것은 루프를 사용하면 번거로울 수 있습니다.\n\n해결책: 더 가독성있는 코드를 위해 `find()`와 `findIndex()`를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nconst user = users.find(u => u.id === 1);\nconsole.log(user); // { id: 1, name: 'Jane' }\nconst index = users.findIndex(u => u.id === 1);\nconsole.log(index); // 0\n```\n\n<div class=\"content-ad\"></div>\n\n이러한 배열 메소드는 조건에 따라 요소를 찾거나 인덱스를 찾는 간단한 방법을 제공하여 코드의 가독성을 향상시킵니다.\n\n## 19. 배열 `some()` 및 `every()`\n\n문제: 배열 중 일부 또는 모든 요소가 특정 조건을 충족하는지 확인하는 것이 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `some()` 및 `every()`를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst hasEven = numbers.some(num => num % 2 === 0);\nconsole.log(hasEven); // true\nconst allEven = numbers.every(num => num % 2 === 0);\nconsole.log(allEven); // false\n```\n\n이러한 배열 메소드를 사용하면 배열 내 일부 또는 모든 요소가 특정 조건을 충족하는지 간결하게 확인할 수 있습니다.\n\n## 20. 배열 `flat()` 및 `flatMap()`\n\n문제: 중첩된 배열을 평탄화하거나 배열을 매핑하고 평탄화하는 것은 번거로울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결 방법: 더 읽기 쉬운 코드를 위해 `flat()` 및 `flatMap()`을 사용하세요.\n\n```js\nconst nested = [1, [2, [3, [4]]]];\nconst flat = nested.flat(2);\nconsole.log(flat); // [1, 2, 3, [4]]\nconst mapped = [1, 2, 3].flatMap(x => [x, x * 2]);\nconsole.log(mapped); // [1, 2, 2, 4, 3, 6]\n```\n\n이러한 배열 메서드를 사용하면 중첩된 배열을 쉽게 평탄화하고 한 번에 매핑 및 평탄화할 수 있는 간단한 방법을 제공합니다.\n\n## 21. Array `from()` and `of()`\n\n<div class=\"content-ad\"></div>\n\n문제: 이터러블 객체나 인수에서 배열을 만드는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `Array.from()` 및 `Array.of()`를 사용하세요.\n\n```js\nconst set = new Set([1, 2, 3]);\nconst arrFromSet = Array.from(set);\nconsole.log(arrFromSet); // [1, 2, 3]\nconst arrOfNumbers = Array.of(1, 2, 3);\nconsole.log(arrOfNumbers); // [1, 2, 3]\n```\n\n`Array.from()`은 이터러블 객체에서 배열을 만들 수 있고, `Array.of()`은 인수 목록에서 배열을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 22. 콜백에서 파라미터 구조 분해\n\n문제점: 콜백에 전달된 객체의 속성에 접근하는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 콜백 파라미터에서 구조 분해를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nusers.forEach(({ id, name }) => {\nconsole.log(`User ID: ${id}, User Name: ${name}`);\n};\n```\n\n<div class=\"content-ad\"></div>\n\n콜백 매개변수의 구조 분해를 사용하면 콜백에 전달된 객체의 속성에 직접 액세스하여 코드를 더 간결하게 만들 수 있어요.\n\n## 23. 선택적 콜백 함수\n\n문제: 선택적 콜백 함수를 처리하는 것은 다소 까다로울 수 있어요.\n\n해결책: 선택적 콜백을 호출하기 위해 단락 평가(short-circuit evaluation)를 사용해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction fetchData(url, callback) {\n    fetch(url)\n    .then(response => response.json())\n    .then(data => {\n        callback && callback(data);\n    });\n}\n```\n\n단락평가는 제공된 경우에만 선택적 콜백 함수를 호출할 수 있게 해서 코드를 보다 견고하게 만들어줍니다.\n\n## 24. 콜백을 프로미스로 변환하기\n\n문제: 콜백을 기반으로 하는 함수를 프로미스로 변환하는 것은 어려울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 유틸리티 함수를 사용하여 콜백을 Promisify합니다.\n\n```js\nfunction promisify(fn) {\nreturn function (…args) {\nreturn new Promise((resolve, reject) => {\nfn(…args, (err, result) => {\nif (err) reject(err);\nelse resolve(result);\n});\n});\n};\n}\nconst readFile = promisify(require('fs').readFile);\nreadFile('path/to/file.txt', 'utf8')\n.then(data => console.log(data))\n.catch(err => console.error(err));\n```\n\n프로미스화를 통해 콜백 기반 함수를 프로미스로 변환하여 비동기/대기 문법과 함께 사용할 수 있게 만들어줍니다.\n\n## 25. 동기적인 코드를 위한 Async/Await\n\n<div class=\"content-ad\"></div>\n\n문제점: Promise를 사용한 비동기 코드 작성은 길고 읽기 어렵습니다.\n\n해결책: async/await를 사용하여 동기적인 스타일로 비동기 코드를 작성하세요.\n\n```js\nasync function fetchData(url) {\ntry {\nconst response = await fetch(url);\nconst data = await response.json();\nconsole.log(data);\n} catch (error) {\nconsole.error('데이터를 불러오는 중 오류가 발생했습니다:', error);\n}\n}\nfetchData('https://api.example.com/data');\n```\n\nAsync/await는 비동기 코드를 동기 코드처럼 작성하고 동작하도록 하는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## 26. Promises 연쇄하기\n\n문제 : 여러 비동기 작업을 순차적으로 처리하는 것은 번거로울 수 있습니다.\n\n해결책 : Promises를 연쇄하여 여러 비동기 작업을 처리하세요.\n\n```js\nfetch('https://api.example.com/data')\n.then(response => response.json())\n.then(data => {\n    console.log('데이터:', data);\n    return fetch('https://api.example.com/more-data');\n})\n.then(response => response.json())\n.then(moreData => {\n    console.log('더 많은 데이터:', moreData);\n})\n.catch(error => {\n    console.error('에러:', error);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n**Promise를 연결하는 것은 여러 비동기 작업을 순차적으로 처리할 수 있어 가독성과 유지 보수성을 향상시킬 수 있습니다.**\n\n## 27. 동시 실행을 위한 Promise.all\n\n문제: 여러 비동기 작업을 동시에 처리하는 것은 어려울 수 있습니다.\n\n해결책: `Promise.all`을 사용하여 동시에 비동기 작업을 처리하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst fetchData1 = fetch('https://api.example.com/data1').then(response => response.json());\nconst fetchData2 = fetch('https://api.example.com/data2').then(response => response.json());\nPromise.all([fetchData1, fetchData2])\n.then(([data1, data2]) => {\nconsole.log('Data 1:', data1);\nconsole.log('Data 2:', data2);\n})\n.catch(error => {\nconsole.error('Error:', error);\n});\n```\n\n`Promise.all`을 사용하면 여러 비동기 작업을 동시에 처리하고 모두 완료될 때 진행할 수 있습니다.\n\n## 28. 디바운스 함수\n\n문제: 창 크기 조절과 같은 빈번한 함수 호출은 성능을 저하시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: debounce 함수를 사용하여 함수가 실행되는 속도를 제한합니다.\n\n```js\nfunction debounce(func, wait) {\n  let timeout;\n  return function (...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n}\nwindow.addEventListener('resize', debounce(() => {\n  console.log('창 크기 조정됨');\n}, 200));\n```\n\ndebounce 함수는 일정 시간 동안 활동이 없을 때에만 함수가 호출되도록 보장하여 성능을 개선합니다.\n\n## 29. 스로틀 함수\n\n<div class=\"content-ad\"></div>\n\n문제: 스크롤 또는 크기 조정과 같이 빈번하게 발생하는 이벤트의 함수 실행 속도 제한.\n\n해결책: 함수 실행 속도 제한을 위해 스로틀(throttle) 함수를 사용합니다.\n\n```js\nfunction throttle(func, limit) {\n  let lastFunc;\n  let lastRan;\n  return function (...args) {\n    if (!lastRan) {\n      func.apply(this, args);\n      lastRan = Date.now();\n    } else {\n      clearTimeout(lastFunc);\n      lastFunc = setTimeout(() => {\n        if (Date.now() - lastRan >= limit) {\n          func.apply(this, args);\n          lastRan = Date.now();\n        }\n      }, limit - (Date.now() - lastRan));\n    }\n  };\n}\n\nwindow.addEventListener('scroll', throttle(() => {\n  console.log('창 스크롤됨');\n}, 200));\n```\n\n스로틀 함수를 사용하면 주어진 기간에 함수가 최대 한 번 호출되도록 보장하여 빈번히 발생하는 이벤트에 대한 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 30. 객체의 깊은 복제\n\n문제: 중첩된 객체를 복제하는 것은 까다롭고 오류가 발생하기 쉽습니다.\n\n해결책: 구조화된 복제 또는 Lodash와 같은 라이브러리를 사용하여 객체를 깊게 복제하세요.\n\n```js\nconst obj = { a: 1, b: { c: 2 } };\nconst deepClone = JSON.parse(JSON.stringify(obj));\nconsole.log(deepClone); // { a: 1, b: { c: 2 } }\n```\n\n<div class=\"content-ad\"></div>\n\n깊은 복제는 중첩된 객체가 참조가 아닌 값으로 복사되어 원본 객체가 의도하지 않은 수정을 방지합니다.\n\n## 31. 메모이제이션\n\n문제: 비싼 함수를 반복 호출하면 성능이 저하될 수 있습니다.\n\n해결책: 메모이제이션을 사용하여 비싼 함수 호출의 결과를 캐시합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction memoize(func) {\nconst cache = new Map();\nreturn function (...args) {\nconst key = JSON.stringify(args);\nif (cache.has(key)) {\nreturn cache.get(key);\n}\nconst result = func.apply(this, args);\ncache.set(key, result);\nreturn result;\n};\n}\nconst expensiveFunction = memoize((num) => {\nconsole.log('계산 중…');\nreturn num * 2;\n});\nconsole.log(expensiveFunction(2)); // \"계산 중…\" 4\nconsole.log(expensiveFunction(2)); // 4\n```\n\n메모이제이션은 비용이 많이 드는 함수 호출의 결과를 캐싱하여 동일한 인수로의 후속 호출에 대해 캐시된 결과를 반환함으로써 성능을 향상시킵니다.\n\n## 32. 함수 커링\n\n문제: 여러 개의 매개변수를 가진 함수를 생성하는 것은 번거로울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 커링을 사용하여 부분적으로 적용된 매개변수를 가진 함수를 만드세요.\n\n```js\nfunction curry(func) {\nreturn function curried(…args) {\nif (args.length >= func.length) {\nreturn func.apply(this, args);\n}\nreturn function (…nextArgs) {\nreturn curried.apply(this, args.concat(nextArgs));\n};\n};\n}\nconst sum = (a, b, c) => a + b + c;\nconst curriedSum = curry(sum);\nconsole.log(curriedSum(1)(2)(3)); // 6\nconsole.log(curriedSum(1, 2)(3)); // 6\n```\n\n커링을 사용하면 더 적은 매개변수로 호출할 수 있는 함수를 생성하여 나머지 매개변수를 받는 새 함수를 반환할 수 있습니다.\n\n## 33. 부분 적용\n\n<div class=\"content-ad\"></div>\n\n문제: 반복적인 인자로 함수를 호출하는 것은 귀찮을 수 있습니다.\n\n해결책: 일부 인자를 함수에 미리 적용하기 위해 부분 적용을 사용하십시오.\n\n```js\nfunction partial(func, ...presetArgs) {\nreturn function (...laterArgs) {\nreturn func(...presetArgs, ...laterArgs);\n};\n}\nconst multiply = (a, b, c) => a * b * c;\nconst double = partial(multiply, 2);\nconsole.log(double(3, 4)); // 24\n```\n\n부분 적용을 사용하면 일부 인자를 미리 적용하여 새로운 함수를 만들 수 있어 코드를 더 유연하고 재사용 가능하게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n34. 함수 합성\n\n문제: 여러 함수를 단일 작업으로 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 여러 함수를 결합하기 위해 함수 합성을 사용하세요.\n\n```js\nconst compose = (…funcs) => (arg) =>\nfuncs.reduceRight((prev, fn) => fn(prev), arg);\nconst add = (x) => x + 1;\nconst multiply = (x) => x * 2;\nconst addThenMultiply = compose(multiply, add);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n<div class=\"content-ad\"></div>\n\n함수 합성을 사용하면 여러 함수를 결합하여 새로운 함수를 만들어 코드를 더 모듈식으로 만들고 재사용할 수 있습니다.\n\n## 35. 함수 파이프라이닝\n\n문제: 값에 일련의 함수를 적용하는 것이 장황할 수 있습니다.\n\n해결책: 함수 파이프라이닝을 사용하여 일련의 함수를 순차적으로 적용하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst pipe = (...funcs) => (arg) =>\nfuncs.reduce((prev, fn) => fn(prev), arg);\nconst add = (x) => x + 1;\nconst multiply = (x) => x * 2;\nconst addThenMultiply = pipe(add, multiply);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n함수 파이프 라이닝을 사용하면 코드의 가독성과 유지 관리성을 높일 수 있습니다.\n\n## 36. 스스로 호출하는 함수\n\n문제: 정의할 때 즉시 함수를 실행하는 것은 번거로울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션: 즉시 실행 함수 표현식(IIFE)을 사용하세요.\n\n```js\n(function () {\nconsole.log('즉시 실행됩니다!');\n})();\n```\nIIFE를 사용하면 함수를 정의하는 즉시 실행할 수 있어서, 격리된 스코프를 만들고 전역 네임스페이스를 오염시키는 것을 피할 수 있습니다.\n\n## 37. 전역 변수 사용을 피하세요\n\n<div class=\"content-ad\"></div>\n\n문제: 전역 변수는 충돌과 의도치 않은 부작용을 일으킬 수 있습니다.\n\n해결책: 전역 이름 공간을 오염시키지 않도록 지역 변수와 모듈을 사용하세요.\n\n```js\n// 지역 변수 사용\nfunction doSomething() {\n    let localVariable = '지역 변수입니다';\n    console.log(localVariable);\n}\n// 모듈 사용\nconst myModule = (function () {\n    let privateVariable = '비공개 변수입니다';\n    return {\n        publicMethod() {\n            console.log(privateVariable);\n        },\n    };\n})();\nmyModule.publicMethod(); // \"비공개 변수입니다\"\n```\n\n전역 변수를 피함으로써 충돌과 의도하지 않은 부작용을 방지하고, 코드를 모듈화하고 유지보수하기 쉽도록 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 38. 클로저를 사용한 캡슐화\n\n문제: 함수의 내부 세부 정보를 노출하면 남용될 수 있습니다.\n\n해결책: 클로저를 사용하여 내부 세부 정보를 캡슐화합니다.\n\n```js\nfunction createCounter() {\nlet count = 0;\nreturn {\nincrement() {\ncount++;\nreturn count;\n},\ndecrement() {\ncount--;\nreturn count;\n},\n};\n}\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1\nconsole.log(counter.increment()); // 2\nconsole.log(counter.decrement()); // 1\n```\n\n<div class=\"content-ad\"></div>\n\n클로저를 사용하면 내부 세부 정보를 캡슐화하고 필요한 기능만 노출하여 코드 보안 및 유지 보수성을 향상시킬 수 있어요.\n\n## 39. 모듈 패턴\n\n문제: 코드를 재사용 가능한 모듈로 구성하는 것은 challenging할 수 있어요.\n\n해결책: 모듈 패턴을 사용하여 재사용 가능하고 캡슐화된 코드를 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst myModule = (function () {\nlet privateVariable = 'This is private';\nfunction privateMethod() {\nconsole.log(privateVariable);\n}\nreturn {\npublicMethod() {\nprivateMethod();\n},\n};\n})();\nmyModule.publicMethod(); // \"This is private\"\n```\n\n모듈 패턴을 사용하면 재사용 가능하고 캡슐화된 코드를 작성할 수 있어 코드 구성과 유지보수를 개선할 수 있어요.\n\n## 40. 싱글톤 패턴\n\n문제: 클래스의 인스턴스가 하나만 생성되도록 보장하는 것은 도전적일 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n해결책: 싱글톤 패턴을 사용하여 단일 인스턴스를 생성하세요.\n\n```js\nconst singleton = (function () {\nlet instance;\nfunction createInstance() {\nreturn {\nname: '싱글톤 인스턴스',\n};\n}\nreturn {\ngetInstance() {\nif (!instance) {\ninstance = createInstance();\n}\nreturn instance;\n},\n};\n})();\nconst instance1 = singleton.getInstance();\nconst instance2 = singleton.getInstance();\nconsole.log(instance1 === instance2); // true\n```\n\n싱글톤 패턴은 클래스의 단일 인스턴스만 생성되도록 보장하며, 공유 리소스 또는 구성을 관리하는 데 유용합니다.\n\n## 41. 팩토리 패턴\n\n<div class=\"content-ad\"></div>\n\n문제: 복잡한 초기화가 필요한 객체를 생성하는 것은 귀찮을 수 있습니다.\n\n해결책: 팩토리 패턴을 사용하여 객체를 생성하세요.\n\n```js\nfunction createUser(name, role) {\nreturn {\nname,\nrole,\nsayHello() {\nconsole.log(`안녕하세요, 제 이름은 ${this.name}이고 ${this.role}입니다.`);\n},\n};\n}\nconst admin = createUser('Alice', 'admin');\nconst user = createUser('Bob', 'user');\nadmin.sayHello(); // \"안녕하세요, 제 이름은 Alice이고 admin입니다.\"\nuser.sayHello(); // \"안녕하세요, 제 이름은 Bob이고 user입니다.\"\n```\n\n팩토리 패턴을 사용하면 유연하고 재사용 가능한 방식으로 복잡한 초기화가 필요한 객체를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 42. 관찰자 패턴\n\n문제: 상태 변경을 관리하고 여러 구성 요소에 알릴 때 어려울 수 있습니다.\n\n해결책: 관찰자 패턴을 사용하여 상태 변경을 관리하고 관찰자에게 알립니다.\n\n```js\nfunction Subject() {\nthis.observers = [];\n}\nSubject.prototype = {\nsubscribe(observer) {\nthis.observers.push(observer);\n},\nunsubscribe(observer) {\nthis.observers = this.observers.filter((obs) => obs !== observer);\n},\nnotify(data) {\nthis.observers.forEach((observer) => observer.update(data));\n},\n};\nfunction Observer(name) {\nthis.name = name;\n}\nObserver.prototype.update = function (data) {\nconsole.log(`${this.name} received data: ${data}`);\n};\nconst subject = new Subject();\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\nsubject.notify('새로운 데이터 이용 가능'); // \"Observer 1 received data: 새로운 데이터 이용 가능\" \"Observer 2 received data: 새로운 데이터 이용 가능\"\n```\n\n<div class=\"content-ad\"></div>\n\n옵저버 패턴을 사용하면 상태 변경을 관리하고 여러 옵저버에게 알림을 보내어 코드 구성 및 유지 관리를 개선할 수 있어요.\n\n## 43. 이벤트 위임\n\n문제: 여러 요소에 이벤트 리스너를 추가하면 성능이 저하될 수 있어요.\n\n해결책: 이벤트 위임을 사용하여 이벤트를 효율적으로 관리하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\ndocument.getElementById('parent').addEventListener('click', (event) => {\nif (event.target && event.target.matches('button.className')) {\nconsole.log('Button clicked:', event.target.textContent);\n}\n});\n```\n\n이벤트 위임을 사용하면 공통 상위 요소에 하나의 이벤트 리스너를 추가하여 여러 하위 요소의 이벤트를 효율적으로 처리할 수 있습니다.\n\n## 44. `eval()` 사용 피하기\n\n문제: `eval()` 사용은 보안 취약점과 성능 문제를 야기할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결 방법: `eval()`을 사용하지 말고 더 안전한 대안을 사용하세요.\n\n```js\n// 피하십시오\nconst code = 'console.log(\"Hello, world!\")';\neval(code); // \"Hello, world!\"\n// 더 안전한 대안 사용\nconst func = new Function('console.log(\"Hello, world!\")');\nfunc(); // \"Hello, world!\"\n```\n\n`eval()`을 피함으로써 보안 취약성과 성능 문제를 방지하고 코드를 더 안전하고 효율적으로 만들 수 있습니다.\n\n## 45. `for…of`를 사용하여 반복하기\n\n<div class=\"content-ad\"></div>\n\n문제: 'for...in'을 사용하여 배열을 반복하는 것은 오류가 발생할 수 있습니다.\n\n해결책: 배열 및 기타 반복 가능한 객체를 반복하는 데는 'for...of'를 사용하십시오.\n\n```js\nconst arr = [1, 2, 3, 4, 5];\nfor (const value of arr) {\nconsole.log(value);\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n`for...of`는 간단하고 안전한 방법을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":21},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>자바스크립트는 현대 웹 개발에서 필수적인 다목적 강력한 언어입니다. 이 글에서는 여러분을 더 효율적이고 효과적인 자바스크립트 개발자로 만들어 줄 수 있는 슈퍼 해킹 기술들을 소개하고 각각에 대한 상세한 설명과 예제를 제공합니다.</p>\n<h2>1. <code>var</code> 대신 <code>let</code> 및 <code>const</code> 사용하기</h2>\n<p>문제: <code>var</code>은 함수 범위를 가지고 있어서 버그와 예상치 못한 동작을 유발할 수 있습니다.</p>\n<p>해결책: 블록 스코프를 갖는 <code>let</code>과 <code>const</code>를 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PI</span> = <span class=\"hljs-number\">3.14</span>;\n</code></pre>\n<p><code>let</code>과 <code>const</code>를 사용하면 변수를 정의된 블록 내에서만 접근할 수 있도록 하여 스코프 관련 버그를 방지할 수 있습니다.</p>\n<h2>2. 기본 매개변수</h2>\n<p>문제: 인수가 제공되지 않으면 함수가 실패할 수 있습니다.</p>\n<p>해결책: 기본 매개변수를 사용하여 대안 값 설정.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\">name = <span class=\"hljs-string\">'방문자'</span></span>) {\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`안녕하세요, <span class=\"hljs-subst\">${name}</span>님!`</span>;\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">greet</span>()); <span class=\"hljs-comment\">// \"안녕하세요, 방문자님!\"</span>\n</code></pre>\n<p>기본 매개변수를 사용하면 함수가 합리적인 기본값을 갖도록되어 오류를 방지하고 코드를 더 견고하게 만듭니다.</p>\n<h2>3. 템플릿 리터럴</h2>\n<p>문제: 문자열 연결은 번거로우며 오류가 발생하기 쉽습니다.</p>\n<p>해결책: 더 깔끔하고 가독성이 좋은 문자열 보간을 위해 템플릿 리터럴을 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">'John'</span>;\n<span class=\"hljs-keyword\">const</span> greeting = <span class=\"hljs-string\">`Hello, <span class=\"hljs-subst\">${name}</span>!`</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(greeting); <span class=\"hljs-comment\">// \"Hello, John!\"</span>\n</code></pre>\n<p>템플릿 리터럴을 사용하면 포함된 표현식과 여러 줄의 문자열을 쉽게 만들 수 있어요.</p>\n<h2>4. 비구조화 할당</h2>\n<p>문제: 객체와 배열에서 값 추출하는 과정이 장황할 수 있어요.</p>\n<p>해결책: 비구조화 할당을 사용해서 값을 더 간결하게 추출하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> user = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Jane'</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> };\n<span class=\"hljs-keyword\">const</span> { name, age } = user;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name, age); <span class=\"hljs-comment\">// \"Jane\" 25</span>\n</code></pre>\n<p>구조 분해 할당을 사용하면 객체에서 속성을 추출하고 배열에서 요소를 쉽게 각각의 변수로 추출할 수 있습니다.</p>\n<h2>5. 화살표 함수</h2>\n<p>문제: 기존 함수 표현식은 장황할 수 있고 <code>this</code>를 렉시컬하게 바인딩하지 않습니다.</p>\n<p>솔루션: 더 짧은 구문을 위해 화살표 함수를 사용하고 렉시컬 <code>this</code>를 활용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">a, b</span>) => a + b;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 5</span>\n</code></pre>\n<p>화살표 함수는 함수 표현식에 대해 간결한 구문을 제공하며 <code>this</code>가 렉시컬하게 바인딩되어 있는지 보장합니다.</p>\n<h2>6. 전개 연산자</h2>\n<p>문제: 배열이나 객체를 결합하는 것은 번거로울 수 있습니다.</p>\n<p>해결책: 전개 연산자를 사용하여 배열과 객체를 쉽게 결합하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">const</span> arr2 = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];\n<span class=\"hljs-keyword\">const</span> combined = […arr1, …arr2];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(combined); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, 6]</span>\n</code></pre>\n<p>전개 연산자를 사용하면 배열이나 객체의 요소를 다른 배열이나 객체로 전개할 수 있습니다.</p>\n<h2>7. 나머지 매개변수</h2>\n<p>문제: 함수에 변수 수의 인수를 처리하는 것은 까다로울 수 있습니다.</p>\n<p>해결책: 모든 인수를 배열에 캡처하기 위해 나머지 매개변수를 사용합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">…args</span>) {\n<span class=\"hljs-keyword\">return</span> args.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, num</span>) =></span> total + num, <span class=\"hljs-number\">0</span>);\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)); <span class=\"hljs-comment\">// 10</span>\n</code></pre>\n<p>레스트 매개변수를 사용하면 매개변수의 개수에 상관없이 배열로 처리할 수 있어 함수를 보다 유연하게 만들 수 있어요.</p>\n<h2>8. 단락 평가</h2>\n<p>문제: 조건문을 작성하는 것은 매우 번거로울 수 있어요.</p>\n<p>해결책: 간결한 조건을 작성하기 위해 단락 평가를 활용해보세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> isLoggedIn = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-keyword\">const</span> user = isLoggedIn &#x26;&#x26; { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Jane'</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> };\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(user); <span class=\"hljs-comment\">// { name: 'Jane', age: 25 }</span>\n</code></pre>\n<p>단축 평가는 논리적 <code>&#x26;&#x26;</code> 및 <code>||</code> 연산자를 사용하여 조건식을 간단하게 만듭니다.</p>\n<h2>9. 선택적 체이닝</h2>\n<p>문제: 깊게 중첩된 속성에 액세스하는 것은 체인의 일부가 <code>null</code> 또는 <code>undefined</code>인 경우 오류를 발생시킬 수 있습니다.</p>\n<p>해결책: 중첩된 속성에 안전하게 접근하기 위해 선택적 체이닝을 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> user = { <span class=\"hljs-attr\">profile</span>: { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Jane'</span> } };\n<span class=\"hljs-keyword\">const</span> userName = user?.<span class=\"hljs-property\">profile</span>?.<span class=\"hljs-property\">name</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(userName); <span class=\"hljs-comment\">// \"Jane\"</span>\n</code></pre>\n<p>선택적 체이닝을 사용하면 <code>null</code> 또는 <code>undefined</code>인지 명시적으로 확인하지 않고도 중첩된 속성에 안전하게 접근할 수 있습니다.</p>\n<h2>10. 널리쉬 콜리싱</h2>\n<p>문제: <code>||</code>를 사용하여 기본 값을 제공하는 경우, 값이 <code>0</code> 또는 <code>\"\"</code>이면 예상치 못한 결과가 발생할 수 있습니다.</p>\n<p>해결책: <code>nullish coalescing</code> (<code>??</code>)을 사용하여 <code>null</code> 또는 <code>undefined</code>일 때만 기본 값을 제공합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> user = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">''</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">0</span> };\n<span class=\"hljs-keyword\">const</span> userName = user.<span class=\"hljs-property\">name</span> ?? <span class=\"hljs-string\">'익명'</span>;\n<span class=\"hljs-keyword\">const</span> userAge = user.<span class=\"hljs-property\">age</span> ?? <span class=\"hljs-number\">18</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(userName); <span class=\"hljs-comment\">// \"\"</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(userAge); <span class=\"hljs-comment\">// 0</span>\n</code></pre>\n<p><code>Nullish coalescing</code>은 왼쪽 피연산자가 <code>null</code> 또는 <code>undefined</code>일 때에만 기본 값을 제공할 수 있습니다.</p>\n<h2>11. 객체 속성 축약</h2>\n<p>문제: 객체 속성에 변수를 할당하는 작업이 반복적 일 수 있습니다.</p>\n<p>해결책: 속성 축약을 사용하여 객체 생성을 간단하게 만듭니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">'Jane'</span>;\n<span class=\"hljs-keyword\">const</span> age = <span class=\"hljs-number\">25</span>;\n<span class=\"hljs-keyword\">const</span> user = { name, age };\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(user); <span class=\"hljs-comment\">// { name: 'Jane', age: 25 }</span>\n</code></pre>\n<p>프로퍼티 축약형을 사용하면 변수 이름과 일치할 때 프로퍼티 이름을 생략할 수 있어서 코드가 더 깔끔해집니다.</p>\n<h2>12. 동적 프로퍼티 이름</h2>\n<p>문제: 동적 프로퍼티 이름으로 객체를 생성하는 것은 다소 장황할 수 있습니다.</p>\n<p>해결책: 계산된 프로퍼티 이름을 사용하여 동적으로 객체 프로퍼티를 생성하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> propName = <span class=\"hljs-string\">'나이'</span>;\n<span class=\"hljs-keyword\">const</span> user = { 이름: <span class=\"hljs-string\">'제인'</span>, [propName]: <span class=\"hljs-number\">25</span> };\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(user); <span class=\"hljs-comment\">// { 이름: '제인', 나이: 25 }</span>\n</code></pre>\n<p>계산된 속성 이름을 사용하면 식의 값으로 속성 이름을 동적으로 만들 수 있습니다.</p>\n<h2>13. 배열 <code>map()</code>, <code>filter()</code>, 및 <code>reduce()</code></h2>\n<p>문제: 배열을 변환, 필터링 또는 값 누적하기 위해 배열을 반복하는 작업은 반복적일 수 있습니다.</p>\n<p>솔루션: 일반적인 배열 작업에 <code>map()</code>, <code>filter()</code>, 및 <code>reduce()</code>를 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">const</span> doubled = numbers.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =></span> num * <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(doubled); <span class=\"hljs-comment\">// [2, 4, 6, 8, 10]</span>\n<span class=\"hljs-keyword\">const</span> evens = numbers.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =></span> num % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(evens); <span class=\"hljs-comment\">// [2, 4]</span>\n<span class=\"hljs-keyword\">const</span> sum = numbers.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, num</span>) =></span> total + num, <span class=\"hljs-number\">0</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(sum); <span class=\"hljs-comment\">// 15</span>\n</code></pre>\n<p>이러한 배열 메서드들은 배열을 변환하고 필터링하며 줄이는 함수적인 방식을 제공하여, 코드를 더 표현적이고 간결하게 만듭니다.</p>\n<h2>14. 문자열 <code>includes()</code>, <code>startsWith()</code>, 및 <code>endsWith()</code></h2>\n<p>문제: 문자열에 특정 부분 문자열이 포함되어 있는지, 시작하는지 또는 끝나는지를 확인하는 작업은 장황할 수 있습니다.</p>\n<p>해결책: 더 간단한 문자열 확인을 위해 <code>includes()</code>, <code>startsWith()</code>, <code>endsWith()</code>를 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">'Hello, world!'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">'world'</span>)); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">'Hello'</span>)); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">endsWith</span>(<span class=\"hljs-string\">'!'</span>)); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>이러한 문자열 메소드들은 부분 문자열의 존재, 시작 또는 끝을 확인하는 간단하고 가독성 있는 방법을 제공합니다.</p>\n<h2>15. 함수 매개변수에서 배열 및 객체 비구조화</h2>\n<p>문제: 함수 매개변수로 전달된 배열 또는 객체에서 값을 추출하는 것은 장황할 수 있습니다.</p>\n<p>해결책: 함수 매개변수에서 비구조화를 사용하여 값을 직접 추출하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> user = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Jane'</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> };\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\">{ name, age }</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`안녕, <span class=\"hljs-subst\">${name}</span>! 당신은 <span class=\"hljs-subst\">${age}</span>살 입니다.`</span>;\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">greet</span>(user)); <span class=\"hljs-comment\">// \"안녕, Jane! 당신은 25살 입니다.\"</span>\n</code></pre>\n<p>함수 매개변수의 구조 분해를 사용하면 함수에 전달된 객체나 배열에서 값을 직접 추출하여 코드를 더 간결하고 가독성 있게 만들 수 있어요.</p>\n<h2>16. 구조 분해에서 기본값 활용</h2>\n<p>문제: 객체의 구조 분해 시 누락된 속성을 다루는 것은 복잡할 수 있어요.</p>\n<p>해결책: 구조 분해에서 기본값을 사용하여 대체 값을 제공해요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> user = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Jane'</span> };\n<span class=\"hljs-keyword\">const</span> { name, age = <span class=\"hljs-number\">18</span> } = user;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name); <span class=\"hljs-comment\">// \"Jane\"</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(age); <span class=\"hljs-comment\">// 18</span>\n</code></pre>\n<p>구조 분해 안에 기본 값(default values)을 설정하면 누락될 수 있는 속성에 대한 대체 값을 제공할 수 있어 코드를 보다 견고하게 만들어줍니다.</p>\n<h2>17. Object <code>assign()</code></h2>\n<p>문제: 객체를 복제하거나 병합하는 것은 번거롭고 실수하기 쉽습니다.</p>\n<p>해결 방법: <code>Object.assign()</code>을 사용하여 객체를 복제하거나 병합할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> target = { <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> };\n<span class=\"hljs-keyword\">const</span> source = { <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> };\n<span class=\"hljs-keyword\">const</span> merged = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, source);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(merged); <span class=\"hljs-comment\">// { a: 1, b: 2 }</span>\n</code></pre>\n<p><code>Object.assign()</code>을 사용하면 객체를 효율적으로 복제하거나 병합할 수 있어서 수동 복사가 필요한 경우를 줄일 수 있습니다.</p>\n<h2>18. Array <code>find()</code> 및 <code>findIndex()</code></h2>\n<p>문제: 배열에서 요소나 인덱스를 찾는 것은 루프를 사용하면 번거로울 수 있습니다.</p>\n<p>해결책: 더 가독성있는 코드를 위해 <code>find()</code>와 <code>findIndex()</code>를 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> users = [\n{ <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Jane'</span> },\n{ <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'John'</span> },\n];\n<span class=\"hljs-keyword\">const</span> user = users.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =></span> u.<span class=\"hljs-property\">id</span> === <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(user); <span class=\"hljs-comment\">// { id: 1, name: 'Jane' }</span>\n<span class=\"hljs-keyword\">const</span> index = users.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =></span> u.<span class=\"hljs-property\">id</span> === <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index); <span class=\"hljs-comment\">// 0</span>\n</code></pre>\n<p>이러한 배열 메소드는 조건에 따라 요소를 찾거나 인덱스를 찾는 간단한 방법을 제공하여 코드의 가독성을 향상시킵니다.</p>\n<h2>19. 배열 <code>some()</code> 및 <code>every()</code></h2>\n<p>문제: 배열 중 일부 또는 모든 요소가 특정 조건을 충족하는지 확인하는 것이 장황할 수 있습니다.</p>\n<p>해결책: 더 깔끔한 코드를 위해 <code>some()</code> 및 <code>every()</code>를 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">const</span> hasEven = numbers.<span class=\"hljs-title function_\">some</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =></span> num % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(hasEven); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-keyword\">const</span> allEven = numbers.<span class=\"hljs-title function_\">every</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =></span> num % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(allEven); <span class=\"hljs-comment\">// false</span>\n</code></pre>\n<p>이러한 배열 메소드를 사용하면 배열 내 일부 또는 모든 요소가 특정 조건을 충족하는지 간결하게 확인할 수 있습니다.</p>\n<h2>20. 배열 <code>flat()</code> 및 <code>flatMap()</code></h2>\n<p>문제: 중첩된 배열을 평탄화하거나 배열을 매핑하고 평탄화하는 것은 번거로울 수 있습니다.</p>\n<p>해결 방법: 더 읽기 쉬운 코드를 위해 <code>flat()</code> 및 <code>flatMap()</code>을 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> nested = [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">3</span>, [<span class=\"hljs-number\">4</span>]]]];\n<span class=\"hljs-keyword\">const</span> flat = nested.<span class=\"hljs-title function_\">flat</span>(<span class=\"hljs-number\">2</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(flat); <span class=\"hljs-comment\">// [1, 2, 3, [4]]</span>\n<span class=\"hljs-keyword\">const</span> mapped = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> [x, x * <span class=\"hljs-number\">2</span>]);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(mapped); <span class=\"hljs-comment\">// [1, 2, 2, 4, 3, 6]</span>\n</code></pre>\n<p>이러한 배열 메서드를 사용하면 중첩된 배열을 쉽게 평탄화하고 한 번에 매핑 및 평탄화할 수 있는 간단한 방법을 제공합니다.</p>\n<h2>21. Array <code>from()</code> and <code>of()</code></h2>\n<p>문제: 이터러블 객체나 인수에서 배열을 만드는 것은 장황할 수 있습니다.</p>\n<p>해결책: 더 깔끔한 코드를 위해 <code>Array.from()</code> 및 <code>Array.of()</code>를 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);\n<span class=\"hljs-keyword\">const</span> arrFromSet = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(set);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arrFromSet); <span class=\"hljs-comment\">// [1, 2, 3]</span>\n<span class=\"hljs-keyword\">const</span> arrOfNumbers = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arrOfNumbers); <span class=\"hljs-comment\">// [1, 2, 3]</span>\n</code></pre>\n<p><code>Array.from()</code>은 이터러블 객체에서 배열을 만들 수 있고, <code>Array.of()</code>은 인수 목록에서 배열을 만들 수 있습니다.</p>\n<h2>22. 콜백에서 파라미터 구조 분해</h2>\n<p>문제점: 콜백에 전달된 객체의 속성에 접근하는 것은 장황할 수 있습니다.</p>\n<p>해결책: 더 깔끔한 코드를 위해 콜백 파라미터에서 구조 분해를 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> users = [\n{ <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Jane'</span> },\n{ <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'John'</span> },\n];\nusers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ id, name }</span>) =></span> {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`User ID: <span class=\"hljs-subst\">${id}</span>, User Name: <span class=\"hljs-subst\">${name}</span>`</span>);\n};\n</code></pre>\n<p>콜백 매개변수의 구조 분해를 사용하면 콜백에 전달된 객체의 속성에 직접 액세스하여 코드를 더 간결하게 만들 수 있어요.</p>\n<h2>23. 선택적 콜백 함수</h2>\n<p>문제: 선택적 콜백 함수를 처리하는 것은 다소 까다로울 수 있어요.</p>\n<p>해결책: 선택적 콜백을 호출하기 위해 단락 평가(short-circuit evaluation)를 사용해주세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\">url, callback</span>) {\n    <span class=\"hljs-title function_\">fetch</span>(url)\n    .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> response.<span class=\"hljs-title function_\">json</span>())\n    .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =></span> {\n        callback &#x26;&#x26; <span class=\"hljs-title function_\">callback</span>(data);\n    });\n}\n</code></pre>\n<p>단락평가는 제공된 경우에만 선택적 콜백 함수를 호출할 수 있게 해서 코드를 보다 견고하게 만들어줍니다.</p>\n<h2>24. 콜백을 프로미스로 변환하기</h2>\n<p>문제: 콜백을 기반으로 하는 함수를 프로미스로 변환하는 것은 어려울 수 있습니다.</p>\n<p>솔루션: 유틸리티 함수를 사용하여 콜백을 Promisify합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">promisify</span>(<span class=\"hljs-params\">fn</span>) {\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">…args</span>) {\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n<span class=\"hljs-title function_\">fn</span>(…args, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, result</span>) =></span> {\n<span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-title function_\">reject</span>(err);\n<span class=\"hljs-keyword\">else</span> <span class=\"hljs-title function_\">resolve</span>(result);\n});\n});\n};\n}\n<span class=\"hljs-keyword\">const</span> readFile = <span class=\"hljs-title function_\">promisify</span>(<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>).<span class=\"hljs-property\">readFile</span>);\n<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">'path/to/file.txt'</span>, <span class=\"hljs-string\">'utf8'</span>)\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data))\n.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err));\n</code></pre>\n<p>프로미스화를 통해 콜백 기반 함수를 프로미스로 변환하여 비동기/대기 문법과 함께 사용할 수 있게 만들어줍니다.</p>\n<h2>25. 동기적인 코드를 위한 Async/Await</h2>\n<p>문제점: Promise를 사용한 비동기 코드 작성은 길고 읽기 어렵습니다.</p>\n<p>해결책: async/await를 사용하여 동기적인 스타일로 비동기 코드를 작성하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\">url</span>) {\n<span class=\"hljs-keyword\">try</span> {\n<span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);\n<span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n} <span class=\"hljs-keyword\">catch</span> (error) {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'데이터를 불러오는 중 오류가 발생했습니다:'</span>, error);\n}\n}\n<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-string\">'https://api.example.com/data'</span>);\n</code></pre>\n<p>Async/await는 비동기 코드를 동기 코드처럼 작성하고 동작하도록 하는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.</p>\n<h2>26. Promises 연쇄하기</h2>\n<p>문제 : 여러 비동기 작업을 순차적으로 처리하는 것은 번거로울 수 있습니다.</p>\n<p>해결책 : Promises를 연쇄하여 여러 비동기 작업을 처리하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data'</span>)\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> response.<span class=\"hljs-title function_\">json</span>())\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'데이터:'</span>, data);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/more-data'</span>);\n})\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> response.<span class=\"hljs-title function_\">json</span>())\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">moreData</span> =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'더 많은 데이터:'</span>, moreData);\n})\n.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'에러:'</span>, error);\n});\n</code></pre>\n<p><strong>Promise를 연결하는 것은 여러 비동기 작업을 순차적으로 처리할 수 있어 가독성과 유지 보수성을 향상시킬 수 있습니다.</strong></p>\n<h2>27. 동시 실행을 위한 Promise.all</h2>\n<p>문제: 여러 비동기 작업을 동시에 처리하는 것은 어려울 수 있습니다.</p>\n<p>해결책: <code>Promise.all</code>을 사용하여 동시에 비동기 작업을 처리하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> fetchData1 = <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data1'</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> response.<span class=\"hljs-title function_\">json</span>());\n<span class=\"hljs-keyword\">const</span> fetchData2 = <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data2'</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> response.<span class=\"hljs-title function_\">json</span>());\n<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([fetchData1, fetchData2])\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[data1, data2]</span>) =></span> {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Data 1:'</span>, data1);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Data 2:'</span>, data2);\n})\n.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'Error:'</span>, error);\n});\n</code></pre>\n<p><code>Promise.all</code>을 사용하면 여러 비동기 작업을 동시에 처리하고 모두 완료될 때 진행할 수 있습니다.</p>\n<h2>28. 디바운스 함수</h2>\n<p>문제: 창 크기 조절과 같은 빈번한 함수 호출은 성능을 저하시킬 수 있습니다.</p>\n<p>해결책: debounce 함수를 사용하여 함수가 실행되는 속도를 제한합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-params\">func, wait</span>) {\n  <span class=\"hljs-keyword\">let</span> timeout;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) {\n    <span class=\"hljs-built_in\">clearTimeout</span>(timeout);\n    timeout = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> func.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args), wait);\n  };\n}\n<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'resize'</span>, <span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'창 크기 조정됨'</span>);\n}, <span class=\"hljs-number\">200</span>));\n</code></pre>\n<p>debounce 함수는 일정 시간 동안 활동이 없을 때에만 함수가 호출되도록 보장하여 성능을 개선합니다.</p>\n<h2>29. 스로틀 함수</h2>\n<p>문제: 스크롤 또는 크기 조정과 같이 빈번하게 발생하는 이벤트의 함수 실행 속도 제한.</p>\n<p>해결책: 함수 실행 속도 제한을 위해 스로틀(throttle) 함수를 사용합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-params\">func, limit</span>) {\n  <span class=\"hljs-keyword\">let</span> lastFunc;\n  <span class=\"hljs-keyword\">let</span> lastRan;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) {\n    <span class=\"hljs-keyword\">if</span> (!lastRan) {\n      func.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n      lastRan = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>();\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-built_in\">clearTimeout</span>(lastFunc);\n      lastFunc = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>() - lastRan >= limit) {\n          func.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n          lastRan = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>();\n        }\n      }, limit - (<span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>() - lastRan));\n    }\n  };\n}\n\n<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'scroll'</span>, <span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'창 스크롤됨'</span>);\n}, <span class=\"hljs-number\">200</span>));\n</code></pre>\n<p>스로틀 함수를 사용하면 주어진 기간에 함수가 최대 한 번 호출되도록 보장하여 빈번히 발생하는 이벤트에 대한 성능을 향상시킬 수 있습니다.</p>\n<h2>30. 객체의 깊은 복제</h2>\n<p>문제: 중첩된 객체를 복제하는 것은 까다롭고 오류가 발생하기 쉽습니다.</p>\n<p>해결책: 구조화된 복제 또는 Lodash와 같은 라이브러리를 사용하여 객체를 깊게 복제하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: { <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span> } };\n<span class=\"hljs-keyword\">const</span> deepClone = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(obj));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(deepClone); <span class=\"hljs-comment\">// { a: 1, b: { c: 2 } }</span>\n</code></pre>\n<p>깊은 복제는 중첩된 객체가 참조가 아닌 값으로 복사되어 원본 객체가 의도하지 않은 수정을 방지합니다.</p>\n<h2>31. 메모이제이션</h2>\n<p>문제: 비싼 함수를 반복 호출하면 성능이 저하될 수 있습니다.</p>\n<p>해결책: 메모이제이션을 사용하여 비싼 함수 호출의 결과를 캐시합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">memoize</span>(<span class=\"hljs-params\">func</span>) {\n<span class=\"hljs-keyword\">const</span> cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) {\n<span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(args);\n<span class=\"hljs-keyword\">if</span> (cache.<span class=\"hljs-title function_\">has</span>(key)) {\n<span class=\"hljs-keyword\">return</span> cache.<span class=\"hljs-title function_\">get</span>(key);\n}\n<span class=\"hljs-keyword\">const</span> result = func.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\ncache.<span class=\"hljs-title function_\">set</span>(key, result);\n<span class=\"hljs-keyword\">return</span> result;\n};\n}\n<span class=\"hljs-keyword\">const</span> expensiveFunction = <span class=\"hljs-title function_\">memoize</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">num</span>) =></span> {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'계산 중…'</span>);\n<span class=\"hljs-keyword\">return</span> num * <span class=\"hljs-number\">2</span>;\n});\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">expensiveFunction</span>(<span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// \"계산 중…\" 4</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">expensiveFunction</span>(<span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 4</span>\n</code></pre>\n<p>메모이제이션은 비용이 많이 드는 함수 호출의 결과를 캐싱하여 동일한 인수로의 후속 호출에 대해 캐시된 결과를 반환함으로써 성능을 향상시킵니다.</p>\n<h2>32. 함수 커링</h2>\n<p>문제: 여러 개의 매개변수를 가진 함수를 생성하는 것은 번거로울 수 있습니다.</p>\n<p>솔루션: 커링을 사용하여 부분적으로 적용된 매개변수를 가진 함수를 만드세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-params\">func</span>) {\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curried</span>(<span class=\"hljs-params\">…args</span>) {\n<span class=\"hljs-keyword\">if</span> (args.<span class=\"hljs-property\">length</span> >= func.<span class=\"hljs-property\">length</span>) {\n<span class=\"hljs-keyword\">return</span> func.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n}\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">…nextArgs</span>) {\n<span class=\"hljs-keyword\">return</span> curried.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args.<span class=\"hljs-title function_\">concat</span>(nextArgs));\n};\n};\n}\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">a, b, c</span>) => a + b + c;\n<span class=\"hljs-keyword\">const</span> curriedSum = <span class=\"hljs-title function_\">curry</span>(sum);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">curriedSum</span>(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 6</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">curriedSum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 6</span>\n</code></pre>\n<p>커링을 사용하면 더 적은 매개변수로 호출할 수 있는 함수를 생성하여 나머지 매개변수를 받는 새 함수를 반환할 수 있습니다.</p>\n<h2>33. 부분 적용</h2>\n<p>문제: 반복적인 인자로 함수를 호출하는 것은 귀찮을 수 있습니다.</p>\n<p>해결책: 일부 인자를 함수에 미리 적용하기 위해 부분 적용을 사용하십시오.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">partial</span>(<span class=\"hljs-params\">func, ...presetArgs</span>) {\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...laterArgs</span>) {\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">func</span>(...presetArgs, ...laterArgs);\n};\n}\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">multiply</span> = (<span class=\"hljs-params\">a, b, c</span>) => a * b * c;\n<span class=\"hljs-keyword\">const</span> double = <span class=\"hljs-title function_\">partial</span>(multiply, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">double</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)); <span class=\"hljs-comment\">// 24</span>\n</code></pre>\n<p>부분 적용을 사용하면 일부 인자를 미리 적용하여 새로운 함수를 만들 수 있어 코드를 더 유연하고 재사용 가능하게 만들 수 있습니다.</p>\n<ol start=\"34\">\n<li>함수 합성</li>\n</ol>\n<p>문제: 여러 함수를 단일 작업으로 결합하는 것은 번거로울 수 있습니다.</p>\n<p>해결책: 여러 함수를 결합하기 위해 함수 합성을 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">compose</span> = (<span class=\"hljs-params\">…funcs</span>) => <span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =></span>\nfuncs.<span class=\"hljs-title function_\">reduceRight</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">prev, fn</span>) =></span> <span class=\"hljs-title function_\">fn</span>(prev), arg);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">x</span>) => x + <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">multiply</span> = (<span class=\"hljs-params\">x</span>) => x * <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">const</span> addThenMultiply = <span class=\"hljs-title function_\">compose</span>(multiply, add);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">addThenMultiply</span>(<span class=\"hljs-number\">5</span>)); <span class=\"hljs-comment\">// 12</span>\n</code></pre>\n<p>함수 합성을 사용하면 여러 함수를 결합하여 새로운 함수를 만들어 코드를 더 모듈식으로 만들고 재사용할 수 있습니다.</p>\n<h2>35. 함수 파이프라이닝</h2>\n<p>문제: 값에 일련의 함수를 적용하는 것이 장황할 수 있습니다.</p>\n<p>해결책: 함수 파이프라이닝을 사용하여 일련의 함수를 순차적으로 적용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">pipe</span> = (<span class=\"hljs-params\">...funcs</span>) => <span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =></span>\nfuncs.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">prev, fn</span>) =></span> <span class=\"hljs-title function_\">fn</span>(prev), arg);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">x</span>) => x + <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">multiply</span> = (<span class=\"hljs-params\">x</span>) => x * <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">const</span> addThenMultiply = <span class=\"hljs-title function_\">pipe</span>(add, multiply);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">addThenMultiply</span>(<span class=\"hljs-number\">5</span>)); <span class=\"hljs-comment\">// 12</span>\n</code></pre>\n<p>함수 파이프 라이닝을 사용하면 코드의 가독성과 유지 관리성을 높일 수 있습니다.</p>\n<h2>36. 스스로 호출하는 함수</h2>\n<p>문제: 정의할 때 즉시 함수를 실행하는 것은 번거로울 수 있습니다.</p>\n<p>솔루션: 즉시 실행 함수 표현식(IIFE)을 사용하세요.</p>\n<pre><code class=\"hljs language-js\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'즉시 실행됩니다!'</span>);\n})();\n</code></pre>\n<p>IIFE를 사용하면 함수를 정의하는 즉시 실행할 수 있어서, 격리된 스코프를 만들고 전역 네임스페이스를 오염시키는 것을 피할 수 있습니다.</p>\n<h2>37. 전역 변수 사용을 피하세요</h2>\n<p>문제: 전역 변수는 충돌과 의도치 않은 부작용을 일으킬 수 있습니다.</p>\n<p>해결책: 전역 이름 공간을 오염시키지 않도록 지역 변수와 모듈을 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 지역 변수 사용</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> localVariable = <span class=\"hljs-string\">'지역 변수입니다'</span>;\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(localVariable);\n}\n<span class=\"hljs-comment\">// 모듈 사용</span>\n<span class=\"hljs-keyword\">const</span> myModule = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> privateVariable = <span class=\"hljs-string\">'비공개 변수입니다'</span>;\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-title function_\">publicMethod</span>(<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(privateVariable);\n        },\n    };\n})();\nmyModule.<span class=\"hljs-title function_\">publicMethod</span>(); <span class=\"hljs-comment\">// \"비공개 변수입니다\"</span>\n</code></pre>\n<p>전역 변수를 피함으로써 충돌과 의도하지 않은 부작용을 방지하고, 코드를 모듈화하고 유지보수하기 쉽도록 만들 수 있습니다.</p>\n<h2>38. 클로저를 사용한 캡슐화</h2>\n<p>문제: 함수의 내부 세부 정보를 노출하면 남용될 수 있습니다.</p>\n<p>해결책: 클로저를 사용하여 내부 세부 정보를 캡슐화합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createCounter</span>(<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">return</span> {\n<span class=\"hljs-title function_\">increment</span>(<span class=\"hljs-params\"></span>) {\ncount++;\n<span class=\"hljs-keyword\">return</span> count;\n},\n<span class=\"hljs-title function_\">decrement</span>(<span class=\"hljs-params\"></span>) {\ncount--;\n<span class=\"hljs-keyword\">return</span> count;\n},\n};\n}\n<span class=\"hljs-keyword\">const</span> counter = <span class=\"hljs-title function_\">createCounter</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">decrement</span>()); <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<p>클로저를 사용하면 내부 세부 정보를 캡슐화하고 필요한 기능만 노출하여 코드 보안 및 유지 보수성을 향상시킬 수 있어요.</p>\n<h2>39. 모듈 패턴</h2>\n<p>문제: 코드를 재사용 가능한 모듈로 구성하는 것은 challenging할 수 있어요.</p>\n<p>해결책: 모듈 패턴을 사용하여 재사용 가능하고 캡슐화된 코드를 생성하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myModule = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-keyword\">let</span> privateVariable = <span class=\"hljs-string\">'This is private'</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">privateMethod</span>(<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(privateVariable);\n}\n<span class=\"hljs-keyword\">return</span> {\n<span class=\"hljs-title function_\">publicMethod</span>(<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-title function_\">privateMethod</span>();\n},\n};\n})();\nmyModule.<span class=\"hljs-title function_\">publicMethod</span>(); <span class=\"hljs-comment\">// \"This is private\"</span>\n</code></pre>\n<p>모듈 패턴을 사용하면 재사용 가능하고 캡슐화된 코드를 작성할 수 있어 코드 구성과 유지보수를 개선할 수 있어요.</p>\n<h2>40. 싱글톤 패턴</h2>\n<p>문제: 클래스의 인스턴스가 하나만 생성되도록 보장하는 것은 도전적일 수 있어요.</p>\n<p>해결책: 싱글톤 패턴을 사용하여 단일 인스턴스를 생성하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> singleton = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-keyword\">let</span> instance;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createInstance</span>(<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-keyword\">return</span> {\n<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'싱글톤 인스턴스'</span>,\n};\n}\n<span class=\"hljs-keyword\">return</span> {\n<span class=\"hljs-title function_\">getInstance</span>(<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-keyword\">if</span> (!instance) {\ninstance = <span class=\"hljs-title function_\">createInstance</span>();\n}\n<span class=\"hljs-keyword\">return</span> instance;\n},\n};\n})();\n<span class=\"hljs-keyword\">const</span> instance1 = singleton.<span class=\"hljs-title function_\">getInstance</span>();\n<span class=\"hljs-keyword\">const</span> instance2 = singleton.<span class=\"hljs-title function_\">getInstance</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance1 === instance2); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>싱글톤 패턴은 클래스의 단일 인스턴스만 생성되도록 보장하며, 공유 리소스 또는 구성을 관리하는 데 유용합니다.</p>\n<h2>41. 팩토리 패턴</h2>\n<p>문제: 복잡한 초기화가 필요한 객체를 생성하는 것은 귀찮을 수 있습니다.</p>\n<p>해결책: 팩토리 패턴을 사용하여 객체를 생성하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createUser</span>(<span class=\"hljs-params\">name, role</span>) {\n<span class=\"hljs-keyword\">return</span> {\nname,\nrole,\n<span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`안녕하세요, 제 이름은 <span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.name}</span>이고 <span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.role}</span>입니다.`</span>);\n},\n};\n}\n<span class=\"hljs-keyword\">const</span> admin = <span class=\"hljs-title function_\">createUser</span>(<span class=\"hljs-string\">'Alice'</span>, <span class=\"hljs-string\">'admin'</span>);\n<span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-title function_\">createUser</span>(<span class=\"hljs-string\">'Bob'</span>, <span class=\"hljs-string\">'user'</span>);\nadmin.<span class=\"hljs-title function_\">sayHello</span>(); <span class=\"hljs-comment\">// \"안녕하세요, 제 이름은 Alice이고 admin입니다.\"</span>\nuser.<span class=\"hljs-title function_\">sayHello</span>(); <span class=\"hljs-comment\">// \"안녕하세요, 제 이름은 Bob이고 user입니다.\"</span>\n</code></pre>\n<p>팩토리 패턴을 사용하면 유연하고 재사용 가능한 방식으로 복잡한 초기화가 필요한 객체를 생성할 수 있습니다.</p>\n<h2>42. 관찰자 패턴</h2>\n<p>문제: 상태 변경을 관리하고 여러 구성 요소에 알릴 때 어려울 수 있습니다.</p>\n<p>해결책: 관찰자 패턴을 사용하여 상태 변경을 관리하고 관찰자에게 알립니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Subject</span>(<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">observers</span> = [];\n}\n<span class=\"hljs-title class_\">Subject</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = {\n<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-params\">observer</span>) {\n<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">observers</span>.<span class=\"hljs-title function_\">push</span>(observer);\n},\n<span class=\"hljs-title function_\">unsubscribe</span>(<span class=\"hljs-params\">observer</span>) {\n<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">observers</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">observers</span>.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">obs</span>) =></span> obs !== observer);\n},\n<span class=\"hljs-title function_\">notify</span>(<span class=\"hljs-params\">data</span>) {\n<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">observers</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">observer</span>) =></span> observer.<span class=\"hljs-title function_\">update</span>(data));\n},\n};\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Observer</span>(<span class=\"hljs-params\">name</span>) {\n<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;\n}\n<span class=\"hljs-title class_\">Observer</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">update</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.name}</span> received data: <span class=\"hljs-subst\">${data}</span>`</span>);\n};\n<span class=\"hljs-keyword\">const</span> subject = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Subject</span>();\n<span class=\"hljs-keyword\">const</span> observer1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observer</span>(<span class=\"hljs-string\">'Observer 1'</span>);\n<span class=\"hljs-keyword\">const</span> observer2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observer</span>(<span class=\"hljs-string\">'Observer 2'</span>);\nsubject.<span class=\"hljs-title function_\">subscribe</span>(observer1);\nsubject.<span class=\"hljs-title function_\">subscribe</span>(observer2);\nsubject.<span class=\"hljs-title function_\">notify</span>(<span class=\"hljs-string\">'새로운 데이터 이용 가능'</span>); <span class=\"hljs-comment\">// \"Observer 1 received data: 새로운 데이터 이용 가능\" \"Observer 2 received data: 새로운 데이터 이용 가능\"</span>\n</code></pre>\n<p>옵저버 패턴을 사용하면 상태 변경을 관리하고 여러 옵저버에게 알림을 보내어 코드 구성 및 유지 관리를 개선할 수 있어요.</p>\n<h2>43. 이벤트 위임</h2>\n<p>문제: 여러 요소에 이벤트 리스너를 추가하면 성능이 저하될 수 있어요.</p>\n<p>해결책: 이벤트 위임을 사용하여 이벤트를 효율적으로 관리하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'parent'</span>).<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =></span> {\n<span class=\"hljs-keyword\">if</span> (event.<span class=\"hljs-property\">target</span> &#x26;&#x26; event.<span class=\"hljs-property\">target</span>.<span class=\"hljs-title function_\">matches</span>(<span class=\"hljs-string\">'button.className'</span>)) {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Button clicked:'</span>, event.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">textContent</span>);\n}\n});\n</code></pre>\n<p>이벤트 위임을 사용하면 공통 상위 요소에 하나의 이벤트 리스너를 추가하여 여러 하위 요소의 이벤트를 효율적으로 처리할 수 있습니다.</p>\n<h2>44. <code>eval()</code> 사용 피하기</h2>\n<p>문제: <code>eval()</code> 사용은 보안 취약점과 성능 문제를 야기할 수 있습니다.</p>\n<p>해결 방법: <code>eval()</code>을 사용하지 말고 더 안전한 대안을 사용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 피하십시오</span>\n<span class=\"hljs-keyword\">const</span> code = <span class=\"hljs-string\">'console.log(\"Hello, world!\")'</span>;\n<span class=\"hljs-built_in\">eval</span>(code); <span class=\"hljs-comment\">// \"Hello, world!\"</span>\n<span class=\"hljs-comment\">// 더 안전한 대안 사용</span>\n<span class=\"hljs-keyword\">const</span> func = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Function</span>(<span class=\"hljs-string\">'console.log(\"Hello, world!\")'</span>);\n<span class=\"hljs-title function_\">func</span>(); <span class=\"hljs-comment\">// \"Hello, world!\"</span>\n</code></pre>\n<p><code>eval()</code>을 피함으로써 보안 취약성과 성능 문제를 방지하고 코드를 더 안전하고 효율적으로 만들 수 있습니다.</p>\n<h2>45. <code>for…of</code>를 사용하여 반복하기</h2>\n<p>문제: 'for...in'을 사용하여 배열을 반복하는 것은 오류가 발생할 수 있습니다.</p>\n<p>해결책: 배열 및 기타 반복 가능한 객체를 반복하는 데는 'for...of'를 사용하십시오.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> value <span class=\"hljs-keyword\">of</span> arr) {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);\n}\n<span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-comment\">// 3</span>\n<span class=\"hljs-comment\">// 4</span>\n<span class=\"hljs-comment\">// 5</span>\n</code></pre>\n<p><code>for...of</code>는 간단하고 안전한 방법을 제공합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}