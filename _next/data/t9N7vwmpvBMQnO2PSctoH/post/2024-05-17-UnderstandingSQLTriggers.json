{"pageProps":{"post":{"title":"SQL 트리거 이해하는 방법","description":"","date":"2024-05-17 04:02","slug":"2024-05-17-UnderstandingSQLTriggers","content":"\n\n## Microsoft SQL Server 트리거 탐색\n\n![이미지](/assets/img/2024-05-17-UnderstandingSQLTriggers_0.png)\n\n데이터베이스 관리에서 트리거는 데이터베이스에서 특정 이벤트가 발생할 때 자동으로 실행되는 특수 유형의 저장 프로시저입니다. Microsoft SQL Server(MS SQL)에서의 트리거는 비즈니스 규칙 강제, 데이터 무결성 유지 및 데이터베이스 수준에서 복잡한 비즈니스 논리 구현에 사용됩니다. 데이터가 데이터베이스에 커밋되기 전에 특정 조건이나 규칙이 충족되도록 보장하는 데 중요한 역할을 합니다.\n\n## 트리거 중요성\n\n<div class=\"content-ad\"></div>\n\n현대 데이터베이스 시스템에서 트리거는 중요한 역할을 합니다. 트리거는 반복적인 작업을 자동화하고 비즈니스 규칙을 준수하며 여러 테이블 간의 데이터 무결성을 유지하는 데 도움을 줄 수 있습니다. 트리거를 활용하면 데이터베이스 관리자와 개발자가 데이터의 변경에 동적으로 반응하는 견고하고 신뢰할 수 있는 데이터베이스 애플리케이션을 만들 수 있습니다.\n\n# MS SQL Server의 트리거 유형\n\n# DML 트리거\n\nDML(데이터 조작 언어) 트리거는 MS SQL Server에서 가장 일반적인 유형의 트리거입니다. 이러한 트리거는 테이블이나 뷰에 대한 INSERT, UPDATE 또는 DELETE 작업과 같은 DML 이벤트에 응답하여 발생합니다.\n\n<div class=\"content-ad\"></div>\n\n## 후 트리거\n\n후 트리거 또는 \"for\" 트리거는 연관된 DML 이벤트가 완료된 후에 실행됩니다. 이러한 트리거는 비즈니스 규칙 및 데이터 무결성을 강제하는 데 유용합니다. 왜냐하면 이벤트 후 데이터의 최종 상태에서 작동하기 때문입니다.\n\n```js\nCREATE TRIGGER trgAfterInsert\nON Employees\nAFTER INSERT\nAS\nBEGIN\n    PRINT 'After Insert Trigger Fired'\n    -- 여기에 추가 로직 작성\nEND\n```\n\n## 대신 트리거\n\n<div class=\"content-ad\"></div>\n\n트리거 대신 트리거를 사용하여 트리거 이벤트의 기본 작업을 재정의합니다. 이들은 원래 이벤트 대신 실행되어 개발자가 데이터 수정 작업의 동작을 사용자 정의할 수 있게 합니다.\n\n```js\nCREATE TRIGGER trgInsteadOfUpdate\nON Employees\nINSTEAD OF UPDATE\nAS\nBEGIN\n    PRINT '대신 업데이트 트리거 발동됨'\n    -- 여기에 사용자 정의 로직 작성\nEND\n```\n\n# DDL 트리거\n\nDDL(데이터 정의 언어) 트리거는 CREATE, ALTER 또는 DROP 문과 같은 DDL 이벤트에 응답하여 실행됩니다. 이들은 데이터베이스나 서버 수준에서 스키마 변경을 감사하고 정책을 강제하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nCREATE TRIGGER trgDDLTrigger\nON DATABASE\nFOR CREATE_TABLE\nAS\nBEGIN\n    PRINT '테이블 생성을 위해 DDL 트리거가 발동되었습니다.'\n    -- 감사 기록 로직 추가\nEND\n```\n\n# 로그인 트리거\n\n로그인 트리거는 MS SQL Server에서 LOGON 이벤트에 응답하여 발동됩니다. 로그인 시 사용자 세션을 제어하거나 모니터링하는 데 사용되며, 연결 제한이나 보안 정책 강화 등이 가능합니다.\n\n```js\nCREATE TRIGGER trgLogonTrigger\nON ALL SERVER\nFOR LOGON\nAS\nBEGIN\n    PRINT '로그인 트리거가 발동되었습니다.'\n    -- 보안 확인 로직 추가\nEND\n```\n\n<div class=\"content-ad\"></div>\n\n# 트리거 생성 및 관리\n\n# 트리거 생성\n\nMS SQL Server에서 트리거를 생성하는 것은 트리거의 이벤트, 범위 및 수행할 작업을 정의하는 과정을 포함합니다. CREATE TRIGGER 문을 사용하여 트리거를 정의합니다.\n\n## 예시: 삽입 후 트리거 생성\n\n<div class=\"content-ad\"></div>\n\n```sql\nCREATE TRIGGER trgAfterInsert\nON Orders\nAFTER INSERT\nAS\nBEGIN\n    INSERT INTO AuditLog (Action, Description, ActionDate)\n    VALUES ('INSERT', 'Record inserted into Orders', GETDATE())\nEND\n```\n\n## 트리거 수정\n\n기존 트리거를 수정하는 것은 ALTER TRIGGER 문을 사용하는 것을 포함합니다. 이를 통해 개발자는 트리거의 논리를 업데이트할 수 있습니다.\n\n### 예: After Insert 트리거 수정하기\n\n\n<div class=\"content-ad\"></div>\n\nmd\n```js\nALTER TRIGGER trgAfterInsert\nON Orders\nAFTER INSERT\nAS\nBEGIN\n    INSERT INTO AuditLog (Action, Description, ActionDate)\n    VALUES ('INSERT', 'New record inserted into Orders', GETDATE())\n    PRINT 'Trigger modified'\nEND\n```\n\n# 트리거 삭제\n\n트리거를 삭제하면 데이터베이스에서 해당 트리거가 삭제되어, 미래 이벤트에 대한 응답으로 실행되지 않습니다. DROP TRIGGER 문을 사용하여 트리거를 삭제할 수 있습니다.\n\n## 예시: After Insert 트리거 삭제\n\n\n<div class=\"content-ad\"></div>\n\n```js\nDROP TRIGGER trgAfterInsert\nON Orders\n```\n\n# 트리거의 실제 응용\n\n# 비즈니스 규칙 강제\n\n트리거는 제약 조건만으로 구현할 수 없는 비즈니스 규칙을 강제하는 데 일반적으로 사용됩니다. 예를 들어 주문의 총액이 특정 한도를 초과하지 않도록 하는 것과 같은 경우가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시: 트리거를 사용하여 비즈니스 규칙 강제하기\n\n```js\nCREATE TRIGGER trgCheckOrderAmount\nON Orders\nAFTER INSERT, UPDATE\nAS\nBEGIN\n    DECLARE @TotalAmount DECIMAL(10, 2)\n    SELECT @TotalAmount = SUM(OrderAmount) FROM inserted\n    IF @TotalAmount > 10000\n    BEGIN\n        RAISERROR('주문 금액이 한도를 초과합니다', 16, 1)\n        ROLLBACK TRANSACTION\n    END\nEND\n```\n\n# 데이터 무결성 유지\n\n트리거는 관련된 테이블 간의 일관성을 보장하여 데이터 무결성을 유지하는 데 도움을 줍니다. 예를 들어, 외래키 무결성을 유지하기 위해 연쇄 업데이트 또는 삭제를 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시: 트리거를 사용하여 데이터 무결성 유지하기\n\n```js\nCREATE TRIGGER trgCascadeDelete\nON Customers\nAFTER DELETE\nAS\nBEGIN\n    DELETE FROM Orders WHERE CustomerID IN (SELECT CustomerID FROM deleted)\nEND\n```\n\n# 감사 및 로깅\n\n트리거는 중요 데이터의 변경 사항을 감사하고 로깅하는 데 널리 사용됩니다. 이를 통해 규정 준수 및 문제 해결 목적으로 데이터 수정에 대한 이력 기록이 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 예제: 트리거를 사용한 데이터 변경 감사\n\n```js\nCREATE TRIGGER trgAuditOrderChanges \nON Orders \nAFTER INSERT, UPDATE, DELETE \nAS \nBEGIN \n    DECLARE @Action CHAR(6) \n    IF EXISTS (SELECT * FROM inserted) AND EXISTS (SELECT * FROM deleted) \n        SET @Action = 'UPDATE' \n    ELSE IF EXISTS (SELECT * FROM inserted) \n        SET @Action = 'INSERT' \n    ELSE \n        SET @Action = 'DELETE' \n\n    INSERT INTO AuditLog (Action, TableName, ActionDate) \n    VALUES (@Action, 'Orders', GETDATE()) \nEND \n```\n\n# 복잡한 비즈니스 로직 구현\n\n트리거를 사용하여 여러 단계 또는 조건을 포함하는 복잡한 비즈니스 로직을 구현할 수 있습니다. 이는 데이터베이스 수준에서 비즈니스 규칙을 캡슐화하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시: 트리거를 사용하여 복잡한 비즈니스 로직 구현\n\n```js\nCREATE TRIGGER trgComplexLogic\nON Sales\nAFTER INSERT, UPDATE\nAS\nBEGIN\n    DECLARE @TotalSales DECIMAL(10, 2)\n    SELECT @TotalSales = SUM(SaleAmount) FROM Sales\n\n    IF @TotalSales > 50000\n    BEGIN\n        -- 할인 로직 적용\n        UPDATE Sales\n        SET Discount = 0.1\n        WHERE SaleAmount > 1000\n    END\nEND\n```\n\n# 트리거 사용에 대한 Best Practices\n\n# 신중하게 트리거 사용하기\n\n<div class=\"content-ad\"></div>\n\n트리거는 복잡성과 성능 부담을 야기할 수 있습니다. 중요한 비즈니스 규칙을 시행하거나 데이터 무결성을 유지해야 할 때에만 신중하게 사용하세요.\n\n## 트리거에서 복잡한 로직 피하기\n\n트리거 내의 로직을 간단하고 효율적으로 유지하세요. 복잡한 로직은 성능 문제를 일으키고 디버깅을 어렵게 만들 수 있습니다.\n\n## 중첩 트리거 사용 최소화하기\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n\n| Header1 | Header2 |\n|---------|---------|\n| Data1   | Data2   |\n\n\n<div class=\"content-ad\"></div>\n\n각 트리거의 목적과 논리를 문서화하여 코드를 이해하고 유지 관리하기 쉽도록 하세요.\n\n# 성능 고려사항\n\n# 성능에 미치는 영향\n\n트리거는 DML 작업의 성능에 영향을 줄 수 있습니다. 왜냐하면 추가적인 처리 단계를 도입하기 때문입니다. 트리거의 성능 영향을 특히 높은 트랜잭션 환경에서는 평가하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 색인 및 트리거\n\n적절한 색인을 사용하면 트리거의 성능을 향상시킬 수 있습니다. 트리거 로직 내의 쿼리 실행 속도를 높이기 위해 관련 열을 적절히 색인화하십시오.\n\n# 모니터링 및 조정\n\n정기적으로 트리거의 성능을 모니터링하고 필요에 따라 튜닝하십시오. SQL Server Profiler 및 Extended Events와 같은 도구를 사용하여 데이터베이스 성능에 미치는 트리거의 영향을 분석하십시오.\n\n<div class=\"content-ad\"></div>\n\n# 고급 주제\n\n# 재귀 트리거\n\n재귀 트리거는 자신을 직접 또는간접적으로 호출하는 트리거입니다. MS SQL Server에서는 재귀 트리거를 허용하지만 무한 루프와 성능 문제를 피하기 위해 주의해서 사용해야 합니다.\n\n```js\nALTER DATABASE AdventureWorks2012\nSET RECURSIVE_TRIGGERS ON\n```\n\n<div class=\"content-ad\"></div>\n\n# 트리거 비활성화 및 활성화\n\nDISABLE TRIGGER와 ENABLE TRIGGER 문을 사용하여 트리거를 일시적으로 비활성화하고 활성화할 수 있습니다. 이는 유지보수 작업이나 대량 데이터 작업에 유용합니다.\n\n## 예시: 트리거 비활성화와 활성화\n\n```js\nDISABLE TRIGGER trgAuditOrderChanges ON Orders\n-- 유지보수 작업 수행\nENABLE TRIGGER trgAuditOrderChanges ON Orders\n```\n\n<div class=\"content-ad\"></div>\n\n# 대신에 뷰에서의 트리거\n\n표준 DML 작업으로 직접 수행할 수 없는 복잡한 업데이트 작업을 지원하기 위해 뷰에 대신에 트리거를 생성할 수 있습니다.\n\n## 예시: 뷰에 대신에 트리거 생성\n\n```js\nCREATE VIEW vwOrders\nAS\nSELECT OrderID, CustomerID, OrderDate, TotalAmount\nFROM Orders\n\nCREATE TRIGGER trgInsteadOfInsertOnView\nON vwOrders\nINSTEAD OF INSERT\nAS\nBEGIN\n    INSERT INTO Orders (OrderID, CustomerID, OrderDate, TotalAmount)\n    SELECT OrderID, CustomerID, OrderDate, TotalAmount\n    FROM inserted\nEND\n```\n\n<div class=\"content-ad\"></div>\n\n# 스키마\n\n## 직원 테이블\n\n```js\nCREATE TABLE Employees (\n    EmployeeID INT PRIMARY KEY IDENTITY,\n    FirstName NVARCHAR(50),\n    LastName NVARCHAR(50),\n    HireDate DATE,\n    JobTitle NVARCHAR(50)\n);\n```\n\n## 주문 테이블\n\n<div class=\"content-ad\"></div>\n\n\n```javascript\nCREATE TABLE Orders (\n    OrderID INT PRIMARY KEY IDENTITY,\n    CustomerID INT,\n    OrderDate DATE,\n    OrderAmount DECIMAL(10, 2)\n);\n```\n\n## AuditLog Table\n\n```javascript\nCREATE TABLE AuditLog (\n    AuditID INT PRIMARY KEY IDENTITY,\n    Action NVARCHAR(50),\n    Description NVARCHAR(255),\n    ActionDate DATETIME\n);\n```\n\n## Customers Table\n\n<div class=\"content-ad\"></div>\n\n```sql\nCREATE TABLE Customers (\n    CustomerID INT PRIMARY KEY IDENTITY,\n    FirstName NVARCHAR(50),\n    LastName NVARCHAR(50),\n    Email NVARCHAR(100)\n);\n```\n\n## Sales Table\n\n```sql\nCREATE TABLE Sales (\n    SaleID INT PRIMARY KEY IDENTITY,\n    ProductID INT,\n    SaleDate DATE,\n    SaleAmount DECIMAL(10, 2),\n    Discount DECIMAL(5, 2) DEFAULT 0\n);\n```\n\n# Creating Views\n\n\n<div class=\"content-ad\"></div>\n\n## 주문 보기\n\n```js\nCREATE VIEW vwOrders\nAS\nSELECT OrderID, CustomerID, OrderDate, TotalAmount\nFROM Orders;\n```\n\n# 인덱스\n\n트리거의 성능을 최적화하기 위해 Orders 및 Customers 테이블의 CustomerID 및 Orders 테이블의 OrderAmount와 같은 트리거 논리에서 자주 사용되는 열에 인덱스를 생성하는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nCREATE INDEX idxOrders_CustomerID ON Orders(CustomerID);\nCREATE INDEX idxOrders_OrderAmount ON Orders(OrderAmount);\nCREATE INDEX idxSales_SaleAmount ON Sales(SaleAmount);\n```\n\n# 테스트용 데이터 삽입\n\n트리거를 테스트하려면 이러한 테이블에 샘플 데이터를 삽입할 수 있습니다.\n\n## 직원 테이블에 샘플 데이터 삽입\n\n\n<div class=\"content-ad\"></div>\n\n```js\nINSERT INTO 직원 (이름, 성, 입사일, 직책)\nVALUES\n('바바르', '아자임', '2020-01-15', '개발자'),\n('알리', '라자', '2019-03-10', '매니저');\n```\n\n## 고객 테이블에 샘플 데이터 삽입\n\n```js\nINSERT INTO 고객 (이름, 성, 이메일)\nVALUES\n('앨리스', '존슨', 'alice.johnson@example.com'),\n('밥', '브라운', 'bob.brown@example.com');\n```\n\n## 주문 테이블에 샘플 데이터 삽입\n\n\n<div class=\"content-ad\"></div>\n\n```js\nINSERT INTO Orders (CustomerID, OrderDate, OrderAmount)\nVALUES\n(1, '2024-05-10', 250.00),\n(2, '2024-05-11', 450.00);\n```\n\n## Sales 테이블에 샘플 데이터 삽입\n\n```js\nINSERT INTO Sales (ProductID, SaleDate, SaleAmount)\nVALUES\n(1, '2024-05-10', 1500.00),\n(2, '2024-05-11', 3000.00);\n```\n\n이러한 테이블을 생성하고 샘플 데이터를 삽입함으로써, 기사에서 설명한 트리거를 효과적으로 구현하고 테스트할 수 있습니다. 이 스키마는 데이터베이스 환경에서 다양한 유형의 트리거와 실제 적용에 대한 포괄적인 기초를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n# 요약\n\nMicrosoft SQL Server의 트리거는 작업 자동화, 비즈니스 규칙 강제, 데이터 무결성 유지 및 복잡한 비즈니스 논리 구현을 위한 강력한 도구입니다. 다른 유형의 트리거와 그 적용 방법을 이해함으로써, 데이터베이스 관리자와 개발자는 견고하고 효율적인 데이터베이스 시스템을 만들 수 있습니다.\n\n# 마지막으로 생각해 볼 점\n\n<div class=\"content-ad\"></div>\n\n트리거는 중요한 이점을 제공하지만, 성능 및 유지 관리에 미치는 영향을 신중히 고려하여 신중하게 사용되어야 합니다. 최상의 모범 사례를 따르고 트리거를 철저히 테스트함으로써 기관은 데이터베이스 응용 프로그램의 기능성과 신뢰성을 향상시키는 데 그들의 전체 잠재력을 활용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-17-UnderstandingSQLTriggers_0.png"},"coverImage":"/assets/img/2024-05-17-UnderstandingSQLTriggers_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>Microsoft SQL Server 트리거 탐색</h2>\n<p><img src=\"/assets/img/2024-05-17-UnderstandingSQLTriggers_0.png\" alt=\"이미지\"></p>\n<p>데이터베이스 관리에서 트리거는 데이터베이스에서 특정 이벤트가 발생할 때 자동으로 실행되는 특수 유형의 저장 프로시저입니다. Microsoft SQL Server(MS SQL)에서의 트리거는 비즈니스 규칙 강제, 데이터 무결성 유지 및 데이터베이스 수준에서 복잡한 비즈니스 논리 구현에 사용됩니다. 데이터가 데이터베이스에 커밋되기 전에 특정 조건이나 규칙이 충족되도록 보장하는 데 중요한 역할을 합니다.</p>\n<h2>트리거 중요성</h2>\n<p>현대 데이터베이스 시스템에서 트리거는 중요한 역할을 합니다. 트리거는 반복적인 작업을 자동화하고 비즈니스 규칙을 준수하며 여러 테이블 간의 데이터 무결성을 유지하는 데 도움을 줄 수 있습니다. 트리거를 활용하면 데이터베이스 관리자와 개발자가 데이터의 변경에 동적으로 반응하는 견고하고 신뢰할 수 있는 데이터베이스 애플리케이션을 만들 수 있습니다.</p>\n<h1>MS SQL Server의 트리거 유형</h1>\n<h1>DML 트리거</h1>\n<p>DML(데이터 조작 언어) 트리거는 MS SQL Server에서 가장 일반적인 유형의 트리거입니다. 이러한 트리거는 테이블이나 뷰에 대한 INSERT, UPDATE 또는 DELETE 작업과 같은 DML 이벤트에 응답하여 발생합니다.</p>\n<h2>후 트리거</h2>\n<p>후 트리거 또는 \"for\" 트리거는 연관된 DML 이벤트가 완료된 후에 실행됩니다. 이러한 트리거는 비즈니스 규칙 및 데이터 무결성을 강제하는 데 유용합니다. 왜냐하면 이벤트 후 데이터의 최종 상태에서 작동하기 때문입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgAfterInsert\n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Employees</span>\n<span class=\"hljs-variable constant_\">AFTER</span> <span class=\"hljs-variable constant_\">INSERT</span>\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">BEGIN</span>\n    <span class=\"hljs-variable constant_\">PRINT</span> <span class=\"hljs-string\">'After Insert Trigger Fired'</span>\n    -- 여기에 추가 로직 작성\n<span class=\"hljs-variable constant_\">END</span>\n</code></pre>\n<h2>대신 트리거</h2>\n<p>트리거 대신 트리거를 사용하여 트리거 이벤트의 기본 작업을 재정의합니다. 이들은 원래 이벤트 대신 실행되어 개발자가 데이터 수정 작업의 동작을 사용자 정의할 수 있게 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgInsteadOfUpdate\n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Employees</span>\n<span class=\"hljs-variable constant_\">INSTEAD</span> <span class=\"hljs-variable constant_\">OF</span> <span class=\"hljs-variable constant_\">UPDATE</span>\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">BEGIN</span>\n    <span class=\"hljs-variable constant_\">PRINT</span> <span class=\"hljs-string\">'대신 업데이트 트리거 발동됨'</span>\n    -- 여기에 사용자 정의 로직 작성\n<span class=\"hljs-variable constant_\">END</span>\n</code></pre>\n<h1>DDL 트리거</h1>\n<p>DDL(데이터 정의 언어) 트리거는 CREATE, ALTER 또는 DROP 문과 같은 DDL 이벤트에 응답하여 실행됩니다. 이들은 데이터베이스나 서버 수준에서 스키마 변경을 감사하고 정책을 강제하는 데 사용됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgDDLTrigger\n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-variable constant_\">DATABASE</span>\n<span class=\"hljs-variable constant_\">FOR</span> <span class=\"hljs-variable constant_\">CREATE_TABLE</span>\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">BEGIN</span>\n    <span class=\"hljs-variable constant_\">PRINT</span> <span class=\"hljs-string\">'테이블 생성을 위해 DDL 트리거가 발동되었습니다.'</span>\n    -- 감사 기록 로직 추가\n<span class=\"hljs-variable constant_\">END</span>\n</code></pre>\n<h1>로그인 트리거</h1>\n<p>로그인 트리거는 MS SQL Server에서 LOGON 이벤트에 응답하여 발동됩니다. 로그인 시 사용자 세션을 제어하거나 모니터링하는 데 사용되며, 연결 제한이나 보안 정책 강화 등이 가능합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgLogonTrigger\n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-variable constant_\">ALL</span> <span class=\"hljs-variable constant_\">SERVER</span>\n<span class=\"hljs-variable constant_\">FOR</span> <span class=\"hljs-variable constant_\">LOGON</span>\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">BEGIN</span>\n    <span class=\"hljs-variable constant_\">PRINT</span> <span class=\"hljs-string\">'로그인 트리거가 발동되었습니다.'</span>\n    -- 보안 확인 로직 추가\n<span class=\"hljs-variable constant_\">END</span>\n</code></pre>\n<h1>트리거 생성 및 관리</h1>\n<h1>트리거 생성</h1>\n<p>MS SQL Server에서 트리거를 생성하는 것은 트리거의 이벤트, 범위 및 수행할 작업을 정의하는 과정을 포함합니다. CREATE TRIGGER 문을 사용하여 트리거를 정의합니다.</p>\n<h2>예시: 삽입 후 트리거 생성</h2>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TRIGGER</span> trgAfterInsert\n<span class=\"hljs-keyword\">ON</span> Orders\nAFTER <span class=\"hljs-keyword\">INSERT</span>\n<span class=\"hljs-keyword\">AS</span>\n<span class=\"hljs-keyword\">BEGIN</span>\n    <span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> AuditLog (Action, Description, ActionDate)\n    <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">'INSERT'</span>, <span class=\"hljs-string\">'Record inserted into Orders'</span>, GETDATE())\n<span class=\"hljs-keyword\">END</span>\n</code></pre>\n<h2>트리거 수정</h2>\n<p>기존 트리거를 수정하는 것은 ALTER TRIGGER 문을 사용하는 것을 포함합니다. 이를 통해 개발자는 트리거의 논리를 업데이트할 수 있습니다.</p>\n<h3>예: After Insert 트리거 수정하기</h3>\n<p>md</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">ALTER</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgAfterInsert\n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Orders</span>\n<span class=\"hljs-variable constant_\">AFTER</span> <span class=\"hljs-variable constant_\">INSERT</span>\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">BEGIN</span>\n    <span class=\"hljs-variable constant_\">INSERT</span> <span class=\"hljs-variable constant_\">INTO</span> <span class=\"hljs-title class_\">AuditLog</span> (<span class=\"hljs-title class_\">Action</span>, <span class=\"hljs-title class_\">Description</span>, <span class=\"hljs-title class_\">ActionDate</span>)\n    <span class=\"hljs-variable constant_\">VALUES</span> (<span class=\"hljs-string\">'INSERT'</span>, <span class=\"hljs-string\">'New record inserted into Orders'</span>, <span class=\"hljs-title function_\">GETDATE</span>())\n    <span class=\"hljs-variable constant_\">PRINT</span> <span class=\"hljs-string\">'Trigger modified'</span>\n<span class=\"hljs-variable constant_\">END</span>\n</code></pre>\n<h1>트리거 삭제</h1>\n<p>트리거를 삭제하면 데이터베이스에서 해당 트리거가 삭제되어, 미래 이벤트에 대한 응답으로 실행되지 않습니다. DROP TRIGGER 문을 사용하여 트리거를 삭제할 수 있습니다.</p>\n<h2>예시: After Insert 트리거 삭제</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">DROP</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgAfterInsert\n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Orders</span>\n</code></pre>\n<h1>트리거의 실제 응용</h1>\n<h1>비즈니스 규칙 강제</h1>\n<p>트리거는 제약 조건만으로 구현할 수 없는 비즈니스 규칙을 강제하는 데 일반적으로 사용됩니다. 예를 들어 주문의 총액이 특정 한도를 초과하지 않도록 하는 것과 같은 경우가 있습니다.</p>\n<h2>예시: 트리거를 사용하여 비즈니스 규칙 강제하기</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgCheckOrderAmount\n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Orders</span>\n<span class=\"hljs-variable constant_\">AFTER</span> <span class=\"hljs-variable constant_\">INSERT</span>, <span class=\"hljs-variable constant_\">UPDATE</span>\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">BEGIN</span>\n    <span class=\"hljs-variable constant_\">DECLARE</span> @<span class=\"hljs-title class_\">TotalAmount</span> <span class=\"hljs-title function_\">DECIMAL</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-variable constant_\">SELECT</span> @<span class=\"hljs-title class_\">TotalAmount</span> = <span class=\"hljs-title function_\">SUM</span>(<span class=\"hljs-title class_\">OrderAmount</span>) <span class=\"hljs-variable constant_\">FROM</span> inserted\n    <span class=\"hljs-variable constant_\">IF</span> @<span class=\"hljs-title class_\">TotalAmount</span> > <span class=\"hljs-number\">10000</span>\n    <span class=\"hljs-variable constant_\">BEGIN</span>\n        <span class=\"hljs-title function_\">RAISERROR</span>(<span class=\"hljs-string\">'주문 금액이 한도를 초과합니다'</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-variable constant_\">ROLLBACK</span> <span class=\"hljs-variable constant_\">TRANSACTION</span>\n    <span class=\"hljs-variable constant_\">END</span>\n<span class=\"hljs-variable constant_\">END</span>\n</code></pre>\n<h1>데이터 무결성 유지</h1>\n<p>트리거는 관련된 테이블 간의 일관성을 보장하여 데이터 무결성을 유지하는 데 도움을 줍니다. 예를 들어, 외래키 무결성을 유지하기 위해 연쇄 업데이트 또는 삭제를 수행할 수 있습니다.</p>\n<h2>예시: 트리거를 사용하여 데이터 무결성 유지하기</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgCascadeDelete\n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Customers</span>\n<span class=\"hljs-variable constant_\">AFTER</span> <span class=\"hljs-variable constant_\">DELETE</span>\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">BEGIN</span>\n    <span class=\"hljs-variable constant_\">DELETE</span> <span class=\"hljs-variable constant_\">FROM</span> <span class=\"hljs-title class_\">Orders</span> <span class=\"hljs-variable constant_\">WHERE</span> <span class=\"hljs-title class_\">CustomerID</span> <span class=\"hljs-variable constant_\">IN</span> (<span class=\"hljs-variable constant_\">SELECT</span> <span class=\"hljs-title class_\">CustomerID</span> <span class=\"hljs-variable constant_\">FROM</span> deleted)\n<span class=\"hljs-variable constant_\">END</span>\n</code></pre>\n<h1>감사 및 로깅</h1>\n<p>트리거는 중요 데이터의 변경 사항을 감사하고 로깅하는 데 널리 사용됩니다. 이를 통해 규정 준수 및 문제 해결 목적으로 데이터 수정에 대한 이력 기록이 제공됩니다.</p>\n<h2>예제: 트리거를 사용한 데이터 변경 감사</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgAuditOrderChanges \n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Orders</span> \n<span class=\"hljs-variable constant_\">AFTER</span> <span class=\"hljs-variable constant_\">INSERT</span>, <span class=\"hljs-variable constant_\">UPDATE</span>, <span class=\"hljs-variable constant_\">DELETE</span> \n<span class=\"hljs-variable constant_\">AS</span> \n<span class=\"hljs-variable constant_\">BEGIN</span> \n    <span class=\"hljs-variable constant_\">DECLARE</span> @<span class=\"hljs-title class_\">Action</span> <span class=\"hljs-title function_\">CHAR</span>(<span class=\"hljs-number\">6</span>) \n    <span class=\"hljs-variable constant_\">IF</span> <span class=\"hljs-variable constant_\">EXISTS</span> (<span class=\"hljs-variable constant_\">SELECT</span> * <span class=\"hljs-variable constant_\">FROM</span> inserted) <span class=\"hljs-variable constant_\">AND</span> <span class=\"hljs-variable constant_\">EXISTS</span> (<span class=\"hljs-variable constant_\">SELECT</span> * <span class=\"hljs-variable constant_\">FROM</span> deleted) \n        <span class=\"hljs-variable constant_\">SET</span> @<span class=\"hljs-title class_\">Action</span> = <span class=\"hljs-string\">'UPDATE'</span> \n    <span class=\"hljs-variable constant_\">ELSE</span> <span class=\"hljs-variable constant_\">IF</span> <span class=\"hljs-variable constant_\">EXISTS</span> (<span class=\"hljs-variable constant_\">SELECT</span> * <span class=\"hljs-variable constant_\">FROM</span> inserted) \n        <span class=\"hljs-variable constant_\">SET</span> @<span class=\"hljs-title class_\">Action</span> = <span class=\"hljs-string\">'INSERT'</span> \n    <span class=\"hljs-variable constant_\">ELSE</span> \n        <span class=\"hljs-variable constant_\">SET</span> @<span class=\"hljs-title class_\">Action</span> = <span class=\"hljs-string\">'DELETE'</span> \n\n    <span class=\"hljs-variable constant_\">INSERT</span> <span class=\"hljs-variable constant_\">INTO</span> <span class=\"hljs-title class_\">AuditLog</span> (<span class=\"hljs-title class_\">Action</span>, <span class=\"hljs-title class_\">TableName</span>, <span class=\"hljs-title class_\">ActionDate</span>) \n    <span class=\"hljs-variable constant_\">VALUES</span> (@<span class=\"hljs-title class_\">Action</span>, <span class=\"hljs-string\">'Orders'</span>, <span class=\"hljs-title function_\">GETDATE</span>()) \n<span class=\"hljs-variable constant_\">END</span> \n</code></pre>\n<h1>복잡한 비즈니스 로직 구현</h1>\n<p>트리거를 사용하여 여러 단계 또는 조건을 포함하는 복잡한 비즈니스 로직을 구현할 수 있습니다. 이는 데이터베이스 수준에서 비즈니스 규칙을 캡슐화하는 데 도움이 됩니다.</p>\n<h2>예시: 트리거를 사용하여 복잡한 비즈니스 로직 구현</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgComplexLogic\n<span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Sales</span>\n<span class=\"hljs-variable constant_\">AFTER</span> <span class=\"hljs-variable constant_\">INSERT</span>, <span class=\"hljs-variable constant_\">UPDATE</span>\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">BEGIN</span>\n    <span class=\"hljs-variable constant_\">DECLARE</span> @<span class=\"hljs-title class_\">TotalSales</span> <span class=\"hljs-title function_\">DECIMAL</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-variable constant_\">SELECT</span> @<span class=\"hljs-title class_\">TotalSales</span> = <span class=\"hljs-title function_\">SUM</span>(<span class=\"hljs-title class_\">SaleAmount</span>) <span class=\"hljs-variable constant_\">FROM</span> <span class=\"hljs-title class_\">Sales</span>\n\n    <span class=\"hljs-variable constant_\">IF</span> @<span class=\"hljs-title class_\">TotalSales</span> > <span class=\"hljs-number\">50000</span>\n    <span class=\"hljs-variable constant_\">BEGIN</span>\n        -- 할인 로직 적용\n        <span class=\"hljs-variable constant_\">UPDATE</span> <span class=\"hljs-title class_\">Sales</span>\n        <span class=\"hljs-variable constant_\">SET</span> <span class=\"hljs-title class_\">Discount</span> = <span class=\"hljs-number\">0.1</span>\n        <span class=\"hljs-variable constant_\">WHERE</span> <span class=\"hljs-title class_\">SaleAmount</span> > <span class=\"hljs-number\">1000</span>\n    <span class=\"hljs-variable constant_\">END</span>\n<span class=\"hljs-variable constant_\">END</span>\n</code></pre>\n<h1>트리거 사용에 대한 Best Practices</h1>\n<h1>신중하게 트리거 사용하기</h1>\n<p>트리거는 복잡성과 성능 부담을 야기할 수 있습니다. 중요한 비즈니스 규칙을 시행하거나 데이터 무결성을 유지해야 할 때에만 신중하게 사용하세요.</p>\n<h2>트리거에서 복잡한 로직 피하기</h2>\n<p>트리거 내의 로직을 간단하고 효율적으로 유지하세요. 복잡한 로직은 성능 문제를 일으키고 디버깅을 어렵게 만들 수 있습니다.</p>\n<h2>중첩 트리거 사용 최소화하기</h2>\n<p>테이블 태그를 마크다운 형식으로 변경해보세요.</p>\n<table>\n<thead>\n<tr>\n<th>Header1</th>\n<th>Header2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Data1</td>\n<td>Data2</td>\n</tr>\n</tbody>\n</table>\n<p>각 트리거의 목적과 논리를 문서화하여 코드를 이해하고 유지 관리하기 쉽도록 하세요.</p>\n<h1>성능 고려사항</h1>\n<h1>성능에 미치는 영향</h1>\n<p>트리거는 DML 작업의 성능에 영향을 줄 수 있습니다. 왜냐하면 추가적인 처리 단계를 도입하기 때문입니다. 트리거의 성능 영향을 특히 높은 트랜잭션 환경에서는 평가하는 것이 중요합니다.</p>\n<h1>색인 및 트리거</h1>\n<p>적절한 색인을 사용하면 트리거의 성능을 향상시킬 수 있습니다. 트리거 로직 내의 쿼리 실행 속도를 높이기 위해 관련 열을 적절히 색인화하십시오.</p>\n<h1>모니터링 및 조정</h1>\n<p>정기적으로 트리거의 성능을 모니터링하고 필요에 따라 튜닝하십시오. SQL Server Profiler 및 Extended Events와 같은 도구를 사용하여 데이터베이스 성능에 미치는 트리거의 영향을 분석하십시오.</p>\n<h1>고급 주제</h1>\n<h1>재귀 트리거</h1>\n<p>재귀 트리거는 자신을 직접 또는간접적으로 호출하는 트리거입니다. MS SQL Server에서는 재귀 트리거를 허용하지만 무한 루프와 성능 문제를 피하기 위해 주의해서 사용해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">ALTER</span> <span class=\"hljs-variable constant_\">DATABASE</span> <span class=\"hljs-title class_\">AdventureWorks2012</span>\n<span class=\"hljs-variable constant_\">SET</span> <span class=\"hljs-variable constant_\">RECURSIVE_TRIGGERS</span> <span class=\"hljs-variable constant_\">ON</span>\n</code></pre>\n<h1>트리거 비활성화 및 활성화</h1>\n<p>DISABLE TRIGGER와 ENABLE TRIGGER 문을 사용하여 트리거를 일시적으로 비활성화하고 활성화할 수 있습니다. 이는 유지보수 작업이나 대량 데이터 작업에 유용합니다.</p>\n<h2>예시: 트리거 비활성화와 활성화</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">DISABLE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgAuditOrderChanges <span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Orders</span>\n-- 유지보수 작업 수행\n<span class=\"hljs-variable constant_\">ENABLE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgAuditOrderChanges <span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Orders</span>\n</code></pre>\n<h1>대신에 뷰에서의 트리거</h1>\n<p>표준 DML 작업으로 직접 수행할 수 없는 복잡한 업데이트 작업을 지원하기 위해 뷰에 대신에 트리거를 생성할 수 있습니다.</p>\n<h2>예시: 뷰에 대신에 트리거 생성</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">VIEW</span> vwOrders\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">SELECT</span> <span class=\"hljs-title class_\">OrderID</span>, <span class=\"hljs-title class_\">CustomerID</span>, <span class=\"hljs-title class_\">OrderDate</span>, <span class=\"hljs-title class_\">TotalAmount</span>\n<span class=\"hljs-variable constant_\">FROM</span> <span class=\"hljs-title class_\">Orders</span>\n\n<span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TRIGGER</span> trgInsteadOfInsertOnView\n<span class=\"hljs-variable constant_\">ON</span> vwOrders\n<span class=\"hljs-variable constant_\">INSTEAD</span> <span class=\"hljs-variable constant_\">OF</span> <span class=\"hljs-variable constant_\">INSERT</span>\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">BEGIN</span>\n    <span class=\"hljs-variable constant_\">INSERT</span> <span class=\"hljs-variable constant_\">INTO</span> <span class=\"hljs-title class_\">Orders</span> (<span class=\"hljs-title class_\">OrderID</span>, <span class=\"hljs-title class_\">CustomerID</span>, <span class=\"hljs-title class_\">OrderDate</span>, <span class=\"hljs-title class_\">TotalAmount</span>)\n    <span class=\"hljs-variable constant_\">SELECT</span> <span class=\"hljs-title class_\">OrderID</span>, <span class=\"hljs-title class_\">CustomerID</span>, <span class=\"hljs-title class_\">OrderDate</span>, <span class=\"hljs-title class_\">TotalAmount</span>\n    <span class=\"hljs-variable constant_\">FROM</span> inserted\n<span class=\"hljs-variable constant_\">END</span>\n</code></pre>\n<h1>스키마</h1>\n<h2>직원 테이블</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TABLE</span> <span class=\"hljs-title class_\">Employees</span> (\n    <span class=\"hljs-title class_\">EmployeeID</span> <span class=\"hljs-variable constant_\">INT</span> <span class=\"hljs-variable constant_\">PRIMARY</span> <span class=\"hljs-variable constant_\">KEY</span> <span class=\"hljs-variable constant_\">IDENTITY</span>,\n    <span class=\"hljs-title class_\">FirstName</span> <span class=\"hljs-title function_\">NVARCHAR</span>(<span class=\"hljs-number\">50</span>),\n    <span class=\"hljs-title class_\">LastName</span> <span class=\"hljs-title function_\">NVARCHAR</span>(<span class=\"hljs-number\">50</span>),\n    <span class=\"hljs-title class_\">HireDate</span> <span class=\"hljs-variable constant_\">DATE</span>,\n    <span class=\"hljs-title class_\">JobTitle</span> <span class=\"hljs-title function_\">NVARCHAR</span>(<span class=\"hljs-number\">50</span>)\n);\n</code></pre>\n<h2>주문 테이블</h2>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TABLE</span> <span class=\"hljs-title class_\">Orders</span> (\n    <span class=\"hljs-title class_\">OrderID</span> <span class=\"hljs-variable constant_\">INT</span> <span class=\"hljs-variable constant_\">PRIMARY</span> <span class=\"hljs-variable constant_\">KEY</span> <span class=\"hljs-variable constant_\">IDENTITY</span>,\n    <span class=\"hljs-title class_\">CustomerID</span> <span class=\"hljs-variable constant_\">INT</span>,\n    <span class=\"hljs-title class_\">OrderDate</span> <span class=\"hljs-variable constant_\">DATE</span>,\n    <span class=\"hljs-title class_\">OrderAmount</span> <span class=\"hljs-title function_\">DECIMAL</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>)\n);\n</code></pre>\n<h2>AuditLog Table</h2>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TABLE</span> <span class=\"hljs-title class_\">AuditLog</span> (\n    <span class=\"hljs-title class_\">AuditID</span> <span class=\"hljs-variable constant_\">INT</span> <span class=\"hljs-variable constant_\">PRIMARY</span> <span class=\"hljs-variable constant_\">KEY</span> <span class=\"hljs-variable constant_\">IDENTITY</span>,\n    <span class=\"hljs-title class_\">Action</span> <span class=\"hljs-title function_\">NVARCHAR</span>(<span class=\"hljs-number\">50</span>),\n    <span class=\"hljs-title class_\">Description</span> <span class=\"hljs-title function_\">NVARCHAR</span>(<span class=\"hljs-number\">255</span>),\n    <span class=\"hljs-title class_\">ActionDate</span> <span class=\"hljs-variable constant_\">DATETIME</span>\n);\n</code></pre>\n<h2>Customers Table</h2>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> Customers (\n    CustomerID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY <span class=\"hljs-keyword\">IDENTITY</span>,\n    FirstName NVARCHAR(<span class=\"hljs-number\">50</span>),\n    LastName NVARCHAR(<span class=\"hljs-number\">50</span>),\n    Email NVARCHAR(<span class=\"hljs-number\">100</span>)\n);\n</code></pre>\n<h2>Sales Table</h2>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> Sales (\n    SaleID <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY <span class=\"hljs-keyword\">IDENTITY</span>,\n    ProductID <span class=\"hljs-type\">INT</span>,\n    SaleDate <span class=\"hljs-type\">DATE</span>,\n    SaleAmount <span class=\"hljs-type\">DECIMAL</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>),\n    Discount <span class=\"hljs-type\">DECIMAL</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-number\">0</span>\n);\n</code></pre>\n<h1>Creating Views</h1>\n<h2>주문 보기</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">VIEW</span> vwOrders\n<span class=\"hljs-variable constant_\">AS</span>\n<span class=\"hljs-variable constant_\">SELECT</span> <span class=\"hljs-title class_\">OrderID</span>, <span class=\"hljs-title class_\">CustomerID</span>, <span class=\"hljs-title class_\">OrderDate</span>, <span class=\"hljs-title class_\">TotalAmount</span>\n<span class=\"hljs-variable constant_\">FROM</span> <span class=\"hljs-title class_\">Orders</span>;\n</code></pre>\n<h1>인덱스</h1>\n<p>트리거의 성능을 최적화하기 위해 Orders 및 Customers 테이블의 CustomerID 및 Orders 테이블의 OrderAmount와 같은 트리거 논리에서 자주 사용되는 열에 인덱스를 생성하는 것이 좋습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">INDEX</span> idxOrders_CustomerID <span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Orders</span>(<span class=\"hljs-title class_\">CustomerID</span>);\n<span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">INDEX</span> idxOrders_OrderAmount <span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Orders</span>(<span class=\"hljs-title class_\">OrderAmount</span>);\n<span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">INDEX</span> idxSales_SaleAmount <span class=\"hljs-variable constant_\">ON</span> <span class=\"hljs-title class_\">Sales</span>(<span class=\"hljs-title class_\">SaleAmount</span>);\n</code></pre>\n<h1>테스트용 데이터 삽입</h1>\n<p>트리거를 테스트하려면 이러한 테이블에 샘플 데이터를 삽입할 수 있습니다.</p>\n<h2>직원 테이블에 샘플 데이터 삽입</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">INSERT</span> <span class=\"hljs-variable constant_\">INTO</span> 직원 (이름, 성, 입사일, 직책)\n<span class=\"hljs-variable constant_\">VALUES</span>\n(<span class=\"hljs-string\">'바바르'</span>, <span class=\"hljs-string\">'아자임'</span>, <span class=\"hljs-string\">'2020-01-15'</span>, <span class=\"hljs-string\">'개발자'</span>),\n(<span class=\"hljs-string\">'알리'</span>, <span class=\"hljs-string\">'라자'</span>, <span class=\"hljs-string\">'2019-03-10'</span>, <span class=\"hljs-string\">'매니저'</span>);\n</code></pre>\n<h2>고객 테이블에 샘플 데이터 삽입</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">INSERT</span> <span class=\"hljs-variable constant_\">INTO</span> 고객 (이름, 성, 이메일)\n<span class=\"hljs-variable constant_\">VALUES</span>\n(<span class=\"hljs-string\">'앨리스'</span>, <span class=\"hljs-string\">'존슨'</span>, <span class=\"hljs-string\">'alice.johnson@example.com'</span>),\n(<span class=\"hljs-string\">'밥'</span>, <span class=\"hljs-string\">'브라운'</span>, <span class=\"hljs-string\">'bob.brown@example.com'</span>);\n</code></pre>\n<h2>주문 테이블에 샘플 데이터 삽입</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">INSERT</span> <span class=\"hljs-variable constant_\">INTO</span> <span class=\"hljs-title class_\">Orders</span> (<span class=\"hljs-title class_\">CustomerID</span>, <span class=\"hljs-title class_\">OrderDate</span>, <span class=\"hljs-title class_\">OrderAmount</span>)\n<span class=\"hljs-variable constant_\">VALUES</span>\n(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'2024-05-10'</span>, <span class=\"hljs-number\">250.00</span>),\n(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'2024-05-11'</span>, <span class=\"hljs-number\">450.00</span>);\n</code></pre>\n<h2>Sales 테이블에 샘플 데이터 삽입</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">INSERT</span> <span class=\"hljs-variable constant_\">INTO</span> <span class=\"hljs-title class_\">Sales</span> (<span class=\"hljs-title class_\">ProductID</span>, <span class=\"hljs-title class_\">SaleDate</span>, <span class=\"hljs-title class_\">SaleAmount</span>)\n<span class=\"hljs-variable constant_\">VALUES</span>\n(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'2024-05-10'</span>, <span class=\"hljs-number\">1500.00</span>),\n(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'2024-05-11'</span>, <span class=\"hljs-number\">3000.00</span>);\n</code></pre>\n<p>이러한 테이블을 생성하고 샘플 데이터를 삽입함으로써, 기사에서 설명한 트리거를 효과적으로 구현하고 테스트할 수 있습니다. 이 스키마는 데이터베이스 환경에서 다양한 유형의 트리거와 실제 적용에 대한 포괄적인 기초를 제공합니다.</p>\n<h1>결론</h1>\n<h1>요약</h1>\n<p>Microsoft SQL Server의 트리거는 작업 자동화, 비즈니스 규칙 강제, 데이터 무결성 유지 및 복잡한 비즈니스 논리 구현을 위한 강력한 도구입니다. 다른 유형의 트리거와 그 적용 방법을 이해함으로써, 데이터베이스 관리자와 개발자는 견고하고 효율적인 데이터베이스 시스템을 만들 수 있습니다.</p>\n<h1>마지막으로 생각해 볼 점</h1>\n<p>트리거는 중요한 이점을 제공하지만, 성능 및 유지 관리에 미치는 영향을 신중히 고려하여 신중하게 사용되어야 합니다. 최상의 모범 사례를 따르고 트리거를 철저히 테스트함으로써 기관은 데이터베이스 응용 프로그램의 기능성과 신뢰성을 향상시키는 데 그들의 전체 잠재력을 활용할 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}