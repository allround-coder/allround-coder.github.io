{"pageProps":{"post":{"title":"렌더링 전략 모든 React 개발자가 알아야 할 것들","description":"","date":"2024-06-19 23:51","slug":"2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow","content":"\n\n\n![Image](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png)\n\n## 소개:\n\nReact는 현대 웹 개발의 핵심입니다. 최대한 효과적으로 활용하려면 복잡한 렌더링 전략을 이해하고 사용해야 합니다. 이 글에서는 이러한 전략을 보여드릴 것입니다.\n\n이러한 전략은 React 개발자가 더 빠르고 효율적인 앱을 만들 수 있도록 돕습니다. 개발을 쉽게 만들어주고 사용자에게 더 나은 경험을 제공합니다. 얼마나 많은 경험이 있든, 이러한 전략들은 여러분을 도와줄 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 렌더링 방법 이해하기\n\nReact의 렌더링 프로세스는 UI를 효율적으로 업데이트하는 방법입니다. 두 가지 주요 단계가 있습니다: 렌더 및 커밋.\n\n![이미지](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_1.png)\n\n렌더 단계\n\n<div class=\"content-ad\"></div>\n\n렌더 단계는 React가 가상 UI를 구축하는 렌더링의 첫 부분입니다. 이 단계에는 DOM 변경이나 데이터 가져오기와 같은 부작용이 없습니다. 이 단계에는 두 가지 주요 단계가 있습니다:\n\n- 가상 DOM 생성: 컴포넌트의 상태나 props가 변경될 때 React는 새 가상 DOM 트리를 생성합니다.\n- 차이 비교: React는 새 가상 DOM 트리와 현재 피버 트리를 비교(se)합니다. 이 프로세스에서는 새 가상 DOM이 이전 것과 비교했을 때 무엇이 변경되었는지를 결정합니다.\n- 작업 단위: 피버 노드(Fiber nodes)는 작업 단위를 나타냅니다. 각 피버 노드는 React 엘리먼트(컴포넌트 또는 DOM 엘리먼트)에 해당하며, 컴포넌트의 상태, props 및 기타 메타데이터 정보를 포함합니다.\n\n커밋 단계\n\n이 단계에서는 렌더 단계 중에 플래그 처리된 변경 사항을 사용자에게 최신 UI 상태를 표시하기 위해 실제 DOM에 적용합니다.\n\n<div class=\"content-ad\"></div>\n\n- DOM 변경 이전 단계: DOM 변경 이전에 실행해야 하는 부작용들이 여기서 처리됩니다.\n- DOM 변경 단계: Fiber 트리에서 식별된 변경 사항에 따라 실제 DOM 업데이트가 적용됩니다.\n- 레이아웃 단계: DOM 변경 이후에 실행해야 하는 부작용들이 이 단계에서 처리됩니다.\n\n커밋 단계는 동기적으로 이루어지며 직접적인 DOM 조작을 포함하며 이로 인해 부작용이 발생할 수 있습니다.\n\n주요 개념:\n\n- Fiber 아키텍처: React의 Fiber 아키텍처는 조각 단위로 렌더링할 수 있게 합니다. 이는 React를 더 효율적으로 만들어주며 메인 스레드를 차단하지 않고 대규모 업데이트를 처리할 수 있습니다.\n- 동시 모드: React 18에서 동시 모드가 도입되어 React가 동시에 여러 작업을 처리할 수 있습니다. 이로써 사용자 경험을 더 부드럽게 만들어주며 중요하지 않은 작업을 일시 중단하고 긴급한 업데이트에 집중할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 테이블 태그가 변경되었습니다.\n\n\n![이미지](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_2.png)\n\n주요 포인트:\n\n1. 동적 콘텐츠 로딩: CSR은 전체 페이지 새로고침 없이 동적으로 콘텐츠를 로드할 수 있습니다.\n\n2. 향상된 사용자 상호작용: 렌더링이 클라이언트 측에서 발생하기 때문에 상호작용이 더 반응적일 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n3. SEO 도전: 검색 엔진은 JavaScript에 크게 의존하는 CSR 콘텐츠를 색인화하는 데 어려움을 겪을 수 있습니다.\n\n4. 초기로딩 시간: CSR은 브라우저가 콘텐츠를 렌더링하기 전에 JavaScript를 다운로드하고 실행해야 하므로 초기 로딩 시간이 느려질 수 있습니다.\n\n예시:\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction App() {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => setData(data));\n  }, []);\n\n  if (!data) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서:\n\n- useEffect 훅은 컴포넌트가 마운트될 때 API에서 데이터를 가져옵니다.\n- 상태(data)가 가져온 데이터로 업데이트되고, 컴포넌트가 다시 렌더링되어 그것을 보여줍니다.\n- 데이터가 가져와질 때까지 초기 콘텐츠로 표시되는 것은 로딩 메시지입니다.\n\n장점:\n\n- 상호 작용 요소로 풍부한 사용자 경험.\n- 단일 페이지 애플리케이션(SPAs)을 위한 효율적인 데이터 가져오기 및 렌더링.\n\n<div class=\"content-ad\"></div>\n\n단점:\n\n- 첫 페이지가 로딩하는 데 시간이 걸립니다.\n- 서버 측 렌더링 또는 사전 렌더링 없이 SEO를 하는 것이 어렵습니다.\n\n## 서버 측 렌더링\n\n서버 측 렌더링(SSR)은 서버가 페이지의 HTML을 생성하고 클라이언트에게 보내는 기술입니다. 이 접근 방식은 서버에서 완전히 렌더링된 페이지를 직접 제공함으로써 웹 앱의 성능과 SEO를 개선합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 테이블 태그를 Markdown 형식으로 변경하신 것입니다.\n\nKey Points:\n\n1. 향상된 SEO: 컨텐츠가 서버에서 완전히 렌더링되므로 검색 엔진이 페이지를 쉽게 크롤링하고 색인화할 수 있습니다.\n\n2. 초기 로드 속도 향상: 사용자들은 첫 요청 시 완전히 렌더링된 페이지를 받아들이므로 CSR에 비해 초기 로드가 더 빠를 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3. Dynamic Content: SSR는 동적 콘텐츠를 처리할 수 있어서 페이지를 요청할 때마다 최신 정보를 제공합니다.\n\n예시:\n\n```js\nconst express = require('express');\nconst fetch = require('node-fetch');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\n\nconst app = express();\n\napp.get('/', async (req, res) => {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n\n  const appString = ReactDOMServer.renderToString(<Home data={data} />);\n\n  const html = `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Server-Side Rendering with Express</title>\n      </head>\n      <body>\n        <div id=\"root\">${appString}</div>\n        <script>\n          window.__INITIAL_DATA__ = ${JSON.stringify(data)}\n        </script>\n        <script src=\"/client.js\"></script>\n      </body>\n    </html>\n  `;\n\n  res.send(html);\n});\n\napp.listen(3000, () => {\n  console.log('서버가 http://localhost:3000에서 실행 중입니다.');\n});\n```\n\n<div class=\"content-ad\"></div>\n\n- 서버 설정: 예제는 Express 프레임워크를 사용하여 서버를 설정합니다. 루트 URL(`/`)로 요청이 들어오면, 외부 API에서 데이터를 가져옵니다.\n- 데이터 가져오기: 서버는 node-fetch를 사용하여 API 엔드포인트(https://api.example.com/data)로 HTTP 요청을 보냅니다. 가져온 데이터는 JSON 형식으로 변환됩니다.\n- React 컴포넌트 렌더링: 서버는 ReactDOMServer.renderToString을 사용하여 Home React 컴포넌트를 HTML 문자열로 렌더링하고, 가져온 데이터를 prop으로 전달합니다.\n- HTML 응답 보내기: 서버는 HTML 템플릿을 작성하여 렌더링된 React 컴포넌트를 root ID가 있는 div 안에 삽입합니다. 또한 클라이언트 측 데이터를 초기화하고 클라이언트 측 JavaScript 파일(client.js)을 로드하기 위한 스크립트를 포함합니다.\n- 클라이언트 측 수분화: 브라우저가 HTML을 수신하면 클라이언트 측 JavaScript(client.js)가 서버에서 렌더링된 HTML을 수분화하여 React 컴포넌트가 상호작용할 수 있게 합니다.\n\n장점:\n\n- 사전 렌더링된 HTML로 SEO가 유리해집니다.\n- 더 빠른 로딩 속도.\n- 페이지가 항상 최신 상태를 유지합니다.\n\n단점:\n\n<div class=\"content-ad\"></div>\n\n- 각 요청이 처리되는 데 더 오래 걸릴 수 있습니다.\n- CSR(Clinet-Side Rendering)을 사용하는 것보다 페이지 로드에 더 오랜 시간이 소요될 수 있습니다.\n- 정적 렌더링보다 설정 및 유지 관리가 복잡합니다.\n\n## 스트리밍 렌더링\n\n스트리밍 렌더링은 서버가 HTML의 일부를 클라이언트에게 가능한 즉시 전송하는 기술입니다. 이를 통해 브라우저가 페이지를 렌더링하기 시작함으로써 웹 애플리케이션의 성능이 향상됩니다.\n\n![Rendering Strategies Every React Developer Should Know](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_4.png)\n\n<div class=\"content-ad\"></div>\n\n중요한 포인트:\n\n1. 느껴지는 성능 개선: 사용자는 나머지 부분이 렌더링되고 스트리밍되는 동안 페이지 일부와 상호 작용을 시작할 수 있습니다.\n\n2. 점진적 렌더링: 페이지의 핵심 부분이 먼저 전송되고 렌더링되어 사용자 경험을 향상시킵니다.\n\n3. 첫 번째 바이트로의 시간 단축(TTFB): 스트리밍을 통해 첫 번째 바이트로의 시간을 단축시켜 초기 로드가 빠르게 느껴질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nReact 18의 스트리밍 렌더링은 서버 사이드 렌더링을 위해 새로운 pipeToNodeWritable 메소드를 사용합니다. 이는 HTML 부분을 준비되는 대로 클라이언트로 보냅니다.\n\n```js\nconst express = require('express');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst { Writable } = require('stream');\n\nconst app = express();\n\nfunction Home({ data }) {\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n}\n\napp.get('/', async (req, res) => {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n\n  const htmlStart = `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Streaming Rendering</title>\n      </head>\n      <body>\n        <div id=\"root\">\n  `;\n\n  const htmlEnd = `\n        </div>\n        <script>\n          window.__INITIAL_DATA__ = ${JSON.stringify(data)}\n        </script>\n        <script src=\"/client.js\"></script>\n      </body>\n    </html>\n  `;\n\n  res.write(htmlStart);\n\n  const writable = new Writable({\n    write(chunk, encoding, callback) {\n      res.write(chunk, encoding, callback);\n    },\n    final(callback) {\n      res.write(htmlEnd);\n      res.end();\n      callback();\n    },\n  });\n\n  ReactDOMServer.pipeToNodeWritable(<Home data={data} />, writable);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});\n```\n\n작동 방식:\n\n<div class=\"content-ad\"></div>\n\n- 서버 측: 초기 HTML을 스트리밍하기 위해 ReactDOMServer.pipeToNodeWritable을 사용합니다.\n- 클라이언트 측: 클라이언트는 HTML의 일부를 도착하는 대로 렌더링을 시작합니다.\n\n장점:\n\n- 사용자가 페이지 일부와 상호 작용할 수 있습니다.\n- 핵심 콘텐츠가 먼저 표시되어 사용자 경험이 향상됩니다.\n- 더 많은 콘텐츠가 로드됨에 따라 사용자 인터페이스가 점진적으로 향상됩니다.\n- 페이지 전체를 한꺼번에 렌더링할 필요가 없기 때문에 서버 및 클라이언트 리소스를 적게 사용합니다.\n- 검색 엔진이 콘텐츠를 더 빨리 찾을 수 있습니다.\n\n단점:\n\n<div class=\"content-ad\"></div>\n\n- Implementation은 전통적 렌더링보다 복잡합니다.\n- 올바른 렌더링을 보장하기 위해 종속성 및 스트리밍 순서를 관리해야 합니다.\n- 모든 브라우저나 네트워크에서 스트리밍할 수 있는 것은 아닙니다.\n- 비동기적인 성격 때문에 스트리밍 문제 해결이 더 어렵습니다.\n- 제대로 관리되지 않으면 서버 및 클라이언트 렌더링된 콘텐츠 사이에 차이가 있을 수 있습니다.\n\n## 정적 사이트 생성\n\n정적 사이트 생성은 HTML 페이지를 미리 렌더링하여 정적 파일로 제공하는 기술입니다. 이 접근 방식은 사전 렌더링된 HTML을 제공함으로써 성능을 향상시키고 서버 부하를 줄이며 보안을 강화할 수 있습니다.\n\n주요 포인트:\n\n<div class=\"content-ad\"></div>\n\n1. 성능: 페이지가 사전 렌더링되어 정적 파일로 제공되므로 로딩 속도가 매우 빠릅니다.\n\n2. SEO: 사전 렌더링된 HTML은 검색 엔진이 쉽게 크롤링하여 SEO를 개선합니다.\n\n3. 보안: 정적 파일을 제공함으로써 서버 렌더링된 페이지와 비교하여 공격 표면이 줄어듭니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n다음은 Next.js를 사용한 SSG의 예시입니다.\n\n```js\n// pages/index.js\nimport React from 'react';\n\nfunction Home({ data }) {\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n}\n\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return {\n    props: {\n      data,\n    },\n  };\n}\n\nexport default Home;\n```\n\n이 예제에서는:\n\n• getStaticProps 함수는 데이터를 빌드 시간에 가져오고 서버에서 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n- 홈 컴포넌트로 전달된 데이터는 props를 통해 전달됩니다.\n\n- HTML은 빌드 시 생성되어 정적 파일로 제공됩니다.\n\n장점:\n\n- 정적 파일의 빠른 로드 시간.\n- 사전 렌더링된 HTML로 SEO 향상.\n- 더 빠른 서버와 안전한 데이터.\n\n<div class=\"content-ad\"></div>\n\n**단점:**\n\n- 내용 변경에 대한 유연성이 부족합니다.\n- 우선 구축해야 합니다.\n- 대규모 사이트의 경우 빌드 시간이 더 오래 걸릴 수 있습니다.\n\n## 증분 정적 재생\n\n증분 정적 재생(Incremental Static Regeneration, ISR)은 사이트를 빌드하고 배포한 후 정적 페이지를 업데이트할 수 있는 기능입니다. 이 접근 방식은 정적 사이트 생성의 이점과 내용을 업데이트할 수 있는 유연성을 결합합니다.\n\n<div class=\"content-ad\"></div>\n\n중요한 점:\n\n1. 요청 시 업데이트: 데이터 변경 시 전체 사이트 재구축이 필요하지 않고 페이지를 증분적으로 업데이트할 수 있습니다.\n\n2. 향상된 성능: 정적 컨텐츠를 제공하면서 특정 페이지를 새로 고침하고 업데이트할 수 있는 기능을 제공합니다.\n\n3. 유연성: 정적 사이트의 속도와 동적 콘텐츠 업데이트를 처리할 수 있는 능력을 결합합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n다음은 ISR을 보여주는 Next.js 사용 예시입니다:\n\n```js\n// pages/index.js\nimport React from 'react';\n\nfunction Home({ data }) {\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n}\n\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return {\n    props: {\n      data,\n    },\n    revalidate: 10, // 최대 10초마다 페이지를 다시 생성합니다.\n  };\n}\n\nexport default Home;\n```\n\n이 예시에서:\n\n<div class=\"content-ad\"></div>\n\n- getStaticProps 함수는 빌드 시간에 데이터를 가져옵니다.\n- revalidate 속성은 다시 유효화 기간(예: 10초)을 지정하여 해당 기간 동안 최대 한 번 페이지가 다시 생성되도록 하여 요청이 들어오면.\n- 생성된 정적 HTML은 완전한 사이트 재구성 없이 새 데이터로 업데이트할 수 있습니다.\n\n장점:\n\n- 빠르고 유연합니다.\n- HTML로 인한 SEO 향상.\n- 빈번한 재구성 요구를 줄여 시간과 리소스를 절약합니다.\n\n단점:\n\n<div class=\"content-ad\"></div>\n\n- 정적 사이트 생성보다 설정하는 것이 더 복잡합니다.\n- 최신 콘텐츠가 사용자에게 즉시 표시되지 않을 수 있습니다.\n\n## 재수전\n\nReact에서 재수전은 서버에서 React 애플리케이션을 렌더링하여 초기 HTML을 생성한 다음 React가 클라이언트에서 페이지를 상호작용하도록 만드는 것을 의미합니다. 이 과정을 통해 사용자가 빠르게 시작하고 JavaScript가 준비되면 페이지와 상호 작용할 수 있도록 합니다.\n\n주요 요점:\n\n<div class=\"content-ad\"></div>\n\n1. 서버 측 렌더링 (SSR): 서버가 초기 HTML을 생성합니다.\n\n2. 클라이언트 측 재가동: 클라이언트 측 React 코드가 페이지를 대화식으로 만듭니다.\n\n예시:\n\n다음은 React를 사용하여 재가동을 보여주는 간단한 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n서버 측\n\n```js\nconst express = require('express');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst fs = require('fs');\nconst path = require('path');\n\nconst App = require('./App').default;\n\nconst app = express();\n\napp.use(express.static(path.resolve(__dirname, 'build')));\n\napp.get('*', (req, res) => {\n  const appString = ReactDOMServer.renderToString(<App />);\n\n  const indexFile = path.resolve(__dirname, 'build', 'index.html');\n  fs.readFile(indexFile, 'utf8', (err, data) => {\n    if (err) {\n      console.error('에러 발생:', err);\n      return res.status(500).send('앗!');\n    }\n\n    return res.send(\n      data.replace('<div id=\"root\"></div>', `<div id=\"root\">${appString}</div>`)\n    );\n  });\n});\n\napp.listen(3000, () => {\n  console.log('서버가 http://localhost:3000에서 실행 중입니다.');\n});\n```\n\n클라이언트 측\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.hydrate(<App />, document.getElementById('root'));\n```\n\n<div class=\"content-ad\"></div>\n\n작동 방식:\n\n1. 서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지 로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.\n\n2. 클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate가 정적 HTML을 가져와 상호 작용할 수 있도록 이벤트 리스너를 부착합니다.\n\n장점:\n\n<div class=\"content-ad\"></div>\n\n- 서버에서 미리 렌더링된 HTML로 인한 빠른 초기로드 시간.\n- 미리 렌더링된 콘텐츠로 개선된 SEO.\n- 클라이언트 측 JavaScript가 로드된 후 완전한 상호작용 가능.\n\n단점:\n\n- JavaScript가 로드될 때까지 상호작용이 지연될 수 있음.\n- 서버 및 클라이언트에서 렌더링된 콘텐츠가 일치하는지 확인하기 어려울 수 있음.\n\n## 부분 유기화\n\n<div class=\"content-ad\"></div>\n\n부분 수분화는 웹 개발에서 일부 정적 HTML 페이지만 상호 작용적으로 만드는 기술입니다. 이 방식은 페이지의 일부만 상호 작용을 요구하는 부분에 대해 JavaScript를로드하고 실행해 성능을 향상시키며, 전반적인 JavaScript 페이로드를 줄입니다.\n\n![Rendering Strategies Every React Developer Should Know](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_5.png)\n\n주요 포인트:\n\n- 선택적 상호 작용: 페이지의 일부만로드됩니다.\n- 더 빠른 성능: 덜 JavaScript를로드 및 실행하므로 페이지가 더 빨리로드되고 더 적은 리소스를 사용합니다.\n- 점진적 향상: 페이지가 잘 작동하고 사용하기 쉬운지 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n리액트를 사용하여 부분 하이드레이션을 보여주는 예시입니다:\n\n클라이언트 측\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst rootElement = document.getElementById('root');\nif (rootElement.hasChildNodes()) {\n  ReactDOM.hydrate(<App />, rootElement);\n} else {\n  ReactDOM.render(<App />, rootElement);\n}\n```\n\n<div class=\"content-ad\"></div>\n\nReact Components (App.js와 InteractiveComponent.js)\n\n```js\n// src/App.js\nimport React from 'react';\nimport InteractiveComponent from './InteractiveComponent';\n\nfunction App() {\n  return (\n    <div>\n      <h1>정적 콘텐츠</h1>\n      <InteractiveComponent />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n```js\n// src/InteractiveComponent.js\nimport React, { useState } from 'react';\n\nfunction InteractiveComponent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>클릭하세요</button>\n      <p>{count}</p>\n    </div>\n  );\n}\n\nexport default InteractiveComponent;\n```\n\n작동 방식:\n\n<div class=\"content-ad\"></div>\n\n- 서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.\n- 클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate는 필요한 인터랙션이 필요한 페이지 부분만 적용합니다.\n\n장점:\n- 더 작은 JavaScript 페이로드로 인해 더 빠른로드 시간.\n- 페이지의 필요한 부분만 적용.\n- 사용자들은 더 많은 인터랙션을 즐깁니다.\n\n단점:\n\n<div class=\"content-ad\"></div>\n\n- 전체 페이지 하이드레이션보다 더 복잡합니다.\n- 주의 깊게 관리해야 합니다.\n\n## 점진적 하이드레이션\n\n점진적 하이드레이션은 웹 페이지의 다른 부분이 하나씩 로드되는 기술입니다. 이 방법은 필수 부분의 하이드레이션을 우선시하여 비필수 부분의 하이드레이션을 지연시킴으로써 성능을 향상시킵니다.\n\n주요 포인트:\n\n<div class=\"content-ad\"></div>\n\n- 점진적으로 수분을 보충하는 것: 페이지의 일부는 점차적으로 로드됩니다.\n- 우선순위를 둔 상호작용: 중요 구성 요소가 먼저 수분 보충됩니다.\n- 성능 최적화: 초기 JavaScript 페이로드를 줄이고 페이지 로드 시간을 개선합니다.\n\n예시:\n\nReact 및 Intersection Observer API를 사용하여 점진적 수분 보충을 보여주는 예시:\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nfunction hydrateComponent(selector, Component) {\n  const element = document.querySelector(selector);\n  if (element && element.hasChildNodes()) {\n    ReactDOM.hydrate(<Component />, element);\n  } else if (element) {\n    ReactDOM.render(<Component />, element);\n  }\n}\n\nhydrateComponent('#root', App);\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// src/App.js\nimport React, { useEffect } from 'react';\n\nfunction App() {\n  useEffect(() => {\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          import('./ProgressiveComponent').then(({ default: Component }) => {\n            hydrateComponent('#progressive', Component);\n          });\n          observer.disconnect();\n        }\n      });\n    });\n\n    observer.observe(document.querySelector('#progressive'));\n\n    return () => observer.disconnect();\n  }, []);\n\n  return (\n    <div>\n      <h1>Static Content</h1>\n      <div id=\"progressive\">Loading...</div>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n```js\n// src/ProgressiveComponent.js\nimport React, { useState } from 'react';\n\nfunction ProgressiveComponent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n      <p>{count}</p>\n    </div>\n  );\n}\n\nexport default ProgressiveComponent;\n```\n\n동작 방식:\n\n- 서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 HTML을 생성합니다.\n- 클라이언트 측: ReactDOM.hydrate은 주 응용 프로그램을 즉시 채웁니다.\n- 점진적 구성 요소 수화: Intersection Observer는 ProgressiveComponent가 뷰포트에 진입할 때 그것을 수화합니다.\n\n<div class=\"content-ad\"></div>\n\n장점:\n\n- 필수 구성 요소만 먼저 로드하여 로드 시간을 개선했습니다.\n- 사용자들이 더 나은 경험을 할 수 있습니다.\n- Javascript 파일이 줄어 듭니다.\n\n단점:\n\n- 전체 페이지 가득 채우기보다 복잡합니다.\n- 문제를 피하기 위해 신중하게 관리해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 동적 렌더링\n\n동적 렌더링은 사용자가 원하는 내용을 기반으로 웹 페이지를 만드는 방법입니다. 이 방법은 크롤러와 사용자에게 서로 다른 내용을 제공함으로써 웹 사이트를 최적화하여 사용자와 검색 엔진을 위한 최적의 서비스를 제공합니다.\n\n![랜더링 전략](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_6.png)\n\n주요 포인트:\n\n<div class=\"content-ad\"></div>\n\n1. 하이브리드 접근 방식: 서버 측 및 클라이언트 측 렌더링을 결합하여 성능 및 SEO를 최적화합니다.\n\n2. SEO 최적화: 사전 렌더링된 HTML을 검색 엔진에 제공하여 크롤링 및 인덱싱을 개선합니다.\n\n3. 사용자 경험: 사용자가 사이트와 완전히 상호 작용할 수 있습니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\nNode.js와 Puppeteer를 사용한 동적 렌더링 예제가 있어요:\n\n```js\nconst express = require('express');\nconst puppeteer = require('puppeteer');\n\nconst app = express();\n\napp.get('*', async (req, res) => {\n  const userAgent = req.headers['user-agent'];\n  \n  if (/Googlebot|Bingbot|Baiduspider|YandexBot/i.test(userAgent)) {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(`http://localhost:3000${req.originalUrl}`, {\n      waitUntil: 'networkidle2'\n    });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } else {\n    res.sendFile(__dirname + '/index.html');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('서버가 http://localhost:3000에서 실행 중입니다.');\n});\n```\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\n```js\n// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nfunction App() {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetch('/api/data')\n      .then(response => response.json())\n      .then(data => setData(data));\n  }, []);\n\n  if (!data) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\nAPI 엔드포인트 (Node.js + Express)\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/api/data', (req, res) => {\n  res.json({\n    title: 'Dynamic Rendering Example',\n    content: 'This content is fetched from the server.'\n  });\n});\n\napp.listen(3001, () => {\n  console.log('API 서버가 http://localhost:3001에서 실행 중입니다.');\n});\n```\n\n이 예제에서:\n\n- 서버는 사용자 에이전트 헤더를 확인하여 요청이 검색 엔진 봇에서 왔는지 확인합니다.\n- 요청이 봇에서 왔다면, Puppeteer가 사전 렌더링된 HTML을 생성하고 반환합니다.\n- 요청이 사용자에서 왔다면, 클라이언트 렌더링된 HTML이 제공되며, React 애플리케이션이 API 엔드포인트에서 데이터를 가져옵니다.\n\n<div class=\"content-ad\"></div>\n\n장점:\n\n- 서버 측 및 클라이언트 측 렌더링을 결합합니다.\n- 검색 엔진 봇에 사전 렌더링된 콘텐츠를 제공하여 SEO를 최적화합니다.\n- 사용자가 상호 작용할 수 있습니다.\n\n단점:\n\n- 서버 설치 및 유지 관리가 더 복잡합니다.\n- 프리 렌더링을 위해 headless 브라우저가 필요하기 때문에 더 많은 리소스를 사용합니다.\n- 사용자 에이전트 감지 및 동적 콘텐츠 생성에 주의를 기울여야 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n웹 개발의 빠르게 변화하는 세계에서는 웹 페이지를 멋지게 보이고 빠르게 로드하기 위한 다양한 방법을 이해하고 활용하는 것이 중요합니다. 각 렌더링 방법에는 다양한 장단이 있습니다.\n\n중요 사항:\n\n1. 클라이언트 측 렌더링 (CSR)은 사용자에게는 훌륭하지만 SEO 및 로딩 시간에 대비하여 다소 어려울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n2. 서버 사이드 렌더링 (SSR)은 초기 로드 속도를 향상시키고 SEO를 개선하지만 서버 부하와 복잡성을 증가시킬 수 있습니다.\n\n3. 스트리밍 렌더링은 HTML을 점진적으로 클라이언트로 전송하여 인식된 성능을 향상시킵니다.\n\n4. 정적 사이트 생성 (SSG)은 빠른 로드 시간과 향상된 보안을 제공하여 변경되지 않는 콘텐츠에 이상적입니다.\n\n5. 점진적 정적 재생성 (ISR)은 정적 및 동적 콘텐츠 업데이트의 이점을 결합하여 성능과 유연성을 균형 있게 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n6. 리하이드레이션은 서버에서 렌더링된 HTML과 클라이언트 측 상호 작용을 연결하여 부드러운 사용자 경험을 제공합니다.\n\n7. 부분 하이드레이션 및 점진적 하이드레이션은 필요에 따라 페이지의 일부를 선택적으로 상호 작용할 수 있도록 최적화하여 성능을 향상시킵니다.\n\n9. 동적 렌더링은 사전 렌더링된 콘텐츠를 검색 엔진 최적화를 위해 봇에 제공하면서 사용자에게 동적 콘텐츠를 제공하여 향상된 경험을 제공합니다.\n\n적절한 렌더링 전략은 앱의 요구 사항, 성능 및 사용자 경험에 따라 다릅니다. 이러한 기술을 사용함으로써 개발자들은 사용자와 검색 엔진에게 잘 작동하는 사용자 친화적인 웹 앱을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nWeb 기술이 발전함에 따라, 개발자들은 웹 앱을 빠르게 실행할 수 있는 최상의 방법을 항상 파악해야 합니다. 이러한 방법을 활용하여 훌륭한 디지털 경험을 만들어보세요.","ogImage":{"url":"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":20},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png\" alt=\"Image\"></p>\n<h2>소개:</h2>\n<p>React는 현대 웹 개발의 핵심입니다. 최대한 효과적으로 활용하려면 복잡한 렌더링 전략을 이해하고 사용해야 합니다. 이 글에서는 이러한 전략을 보여드릴 것입니다.</p>\n<p>이러한 전략은 React 개발자가 더 빠르고 효율적인 앱을 만들 수 있도록 돕습니다. 개발을 쉽게 만들어주고 사용자에게 더 나은 경험을 제공합니다. 얼마나 많은 경험이 있든, 이러한 전략들은 여러분을 도와줄 수 있습니다.</p>\n<h2>렌더링 방법 이해하기</h2>\n<p>React의 렌더링 프로세스는 UI를 효율적으로 업데이트하는 방법입니다. 두 가지 주요 단계가 있습니다: 렌더 및 커밋.</p>\n<p><img src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_1.png\" alt=\"이미지\"></p>\n<p>렌더 단계</p>\n<p>렌더 단계는 React가 가상 UI를 구축하는 렌더링의 첫 부분입니다. 이 단계에는 DOM 변경이나 데이터 가져오기와 같은 부작용이 없습니다. 이 단계에는 두 가지 주요 단계가 있습니다:</p>\n<ul>\n<li>가상 DOM 생성: 컴포넌트의 상태나 props가 변경될 때 React는 새 가상 DOM 트리를 생성합니다.</li>\n<li>차이 비교: React는 새 가상 DOM 트리와 현재 피버 트리를 비교(se)합니다. 이 프로세스에서는 새 가상 DOM이 이전 것과 비교했을 때 무엇이 변경되었는지를 결정합니다.</li>\n<li>작업 단위: 피버 노드(Fiber nodes)는 작업 단위를 나타냅니다. 각 피버 노드는 React 엘리먼트(컴포넌트 또는 DOM 엘리먼트)에 해당하며, 컴포넌트의 상태, props 및 기타 메타데이터 정보를 포함합니다.</li>\n</ul>\n<p>커밋 단계</p>\n<p>이 단계에서는 렌더 단계 중에 플래그 처리된 변경 사항을 사용자에게 최신 UI 상태를 표시하기 위해 실제 DOM에 적용합니다.</p>\n<ul>\n<li>DOM 변경 이전 단계: DOM 변경 이전에 실행해야 하는 부작용들이 여기서 처리됩니다.</li>\n<li>DOM 변경 단계: Fiber 트리에서 식별된 변경 사항에 따라 실제 DOM 업데이트가 적용됩니다.</li>\n<li>레이아웃 단계: DOM 변경 이후에 실행해야 하는 부작용들이 이 단계에서 처리됩니다.</li>\n</ul>\n<p>커밋 단계는 동기적으로 이루어지며 직접적인 DOM 조작을 포함하며 이로 인해 부작용이 발생할 수 있습니다.</p>\n<p>주요 개념:</p>\n<ul>\n<li>Fiber 아키텍처: React의 Fiber 아키텍처는 조각 단위로 렌더링할 수 있게 합니다. 이는 React를 더 효율적으로 만들어주며 메인 스레드를 차단하지 않고 대규모 업데이트를 처리할 수 있습니다.</li>\n<li>동시 모드: React 18에서 동시 모드가 도입되어 React가 동시에 여러 작업을 처리할 수 있습니다. 이로써 사용자 경험을 더 부드럽게 만들어주며 중요하지 않은 작업을 일시 중단하고 긴급한 업데이트에 집중할 수 있습니다.</li>\n</ul>\n<p>테이블 태그를 Markdown 형식으로 변경해주세요.</p>\n<p>아래는 Markdown 형식으로 테이블 태그가 변경되었습니다.</p>\n<p><img src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_2.png\" alt=\"이미지\"></p>\n<p>주요 포인트:</p>\n<ol>\n<li>\n<p>동적 콘텐츠 로딩: CSR은 전체 페이지 새로고침 없이 동적으로 콘텐츠를 로드할 수 있습니다.</p>\n</li>\n<li>\n<p>향상된 사용자 상호작용: 렌더링이 클라이언트 측에서 발생하기 때문에 상호작용이 더 반응적일 수 있습니다.</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>SEO 도전: 검색 엔진은 JavaScript에 크게 의존하는 CSR 콘텐츠를 색인화하는 데 어려움을 겪을 수 있습니다.</p>\n</li>\n<li>\n<p>초기로딩 시간: CSR은 브라우저가 콘텐츠를 렌더링하기 전에 JavaScript를 다운로드하고 실행해야 하므로 초기 로딩 시간이 느려질 수 있습니다.</p>\n</li>\n</ol>\n<p>예시:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useState, useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-dom'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [data, setData] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">null</span>);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data'</span>)\n      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> response.<span class=\"hljs-title function_\">json</span>())\n      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =></span> <span class=\"hljs-title function_\">setData</span>(data));\n  }, []);\n\n  <span class=\"hljs-keyword\">if</span> (!data) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>;\n  }\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{data.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{data.content}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">App</span> /></span></span>, <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'root'</span>));\n</code></pre>\n<p>이 예시에서:</p>\n<ul>\n<li>useEffect 훅은 컴포넌트가 마운트될 때 API에서 데이터를 가져옵니다.</li>\n<li>상태(data)가 가져온 데이터로 업데이트되고, 컴포넌트가 다시 렌더링되어 그것을 보여줍니다.</li>\n<li>데이터가 가져와질 때까지 초기 콘텐츠로 표시되는 것은 로딩 메시지입니다.</li>\n</ul>\n<p>장점:</p>\n<ul>\n<li>상호 작용 요소로 풍부한 사용자 경험.</li>\n<li>단일 페이지 애플리케이션(SPAs)을 위한 효율적인 데이터 가져오기 및 렌더링.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>첫 페이지가 로딩하는 데 시간이 걸립니다.</li>\n<li>서버 측 렌더링 또는 사전 렌더링 없이 SEO를 하는 것이 어렵습니다.</li>\n</ul>\n<h2>서버 측 렌더링</h2>\n<p>서버 측 렌더링(SSR)은 서버가 페이지의 HTML을 생성하고 클라이언트에게 보내는 기술입니다. 이 접근 방식은 서버에서 완전히 렌더링된 페이지를 직접 제공함으로써 웹 앱의 성능과 SEO를 개선합니다.</p>\n<p>아래는 테이블 태그를 Markdown 형식으로 변경하신 것입니다.</p>\n<p>Key Points:</p>\n<ol>\n<li>\n<p>향상된 SEO: 컨텐츠가 서버에서 완전히 렌더링되므로 검색 엔진이 페이지를 쉽게 크롤링하고 색인화할 수 있습니다.</p>\n</li>\n<li>\n<p>초기 로드 속도 향상: 사용자들은 첫 요청 시 완전히 렌더링된 페이지를 받아들이므로 CSR에 비해 초기 로드가 더 빠를 수 있습니다.</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>Dynamic Content: SSR는 동적 콘텐츠를 처리할 수 있어서 페이지를 요청할 때마다 최신 정보를 제공합니다.</li>\n</ol>\n<p>예시:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n<span class=\"hljs-keyword\">const</span> fetch = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'node-fetch'</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">React</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'react'</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ReactDOMServer</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'react-dom/server'</span>);\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'/'</span>, <span class=\"hljs-keyword\">async</span> (req, res) => {\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data'</span>);\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n\n  <span class=\"hljs-keyword\">const</span> appString = <span class=\"hljs-title class_\">ReactDOMServer</span>.<span class=\"hljs-title function_\">renderToString</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Home</span> <span class=\"hljs-attr\">data</span>=<span class=\"hljs-string\">{data}</span> /></span></span>);\n\n  <span class=\"hljs-keyword\">const</span> html = <span class=\"hljs-string\">`\n    &#x3C;!DOCTYPE html>\n    &#x3C;html lang=\"en\">\n      &#x3C;head>\n        &#x3C;meta charset=\"UTF-8\">\n        &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        &#x3C;title>Server-Side Rendering with Express&#x3C;/title>\n      &#x3C;/head>\n      &#x3C;body>\n        &#x3C;div id=\"root\"><span class=\"hljs-subst\">${appString}</span>&#x3C;/div>\n        &#x3C;script>\n          window.__INITIAL_DATA__ = <span class=\"hljs-subst\">${<span class=\"hljs-built_in\">JSON</span>.stringify(data)}</span>\n        &#x3C;/script>\n        &#x3C;script src=\"/client.js\">&#x3C;/script>\n      &#x3C;/body>\n    &#x3C;/html>\n  `</span>;\n\n  res.<span class=\"hljs-title function_\">send</span>(html);\n});\n\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'서버가 http://localhost:3000에서 실행 중입니다.'</span>);\n});\n</code></pre>\n<ul>\n<li>서버 설정: 예제는 Express 프레임워크를 사용하여 서버를 설정합니다. 루트 URL(<code>/</code>)로 요청이 들어오면, 외부 API에서 데이터를 가져옵니다.</li>\n<li>데이터 가져오기: 서버는 node-fetch를 사용하여 API 엔드포인트(<a href=\"https://api.example.com/data)%EB%A1%9C\" rel=\"nofollow\" target=\"_blank\">https://api.example.com/data)로</a> HTTP 요청을 보냅니다. 가져온 데이터는 JSON 형식으로 변환됩니다.</li>\n<li>React 컴포넌트 렌더링: 서버는 ReactDOMServer.renderToString을 사용하여 Home React 컴포넌트를 HTML 문자열로 렌더링하고, 가져온 데이터를 prop으로 전달합니다.</li>\n<li>HTML 응답 보내기: 서버는 HTML 템플릿을 작성하여 렌더링된 React 컴포넌트를 root ID가 있는 div 안에 삽입합니다. 또한 클라이언트 측 데이터를 초기화하고 클라이언트 측 JavaScript 파일(client.js)을 로드하기 위한 스크립트를 포함합니다.</li>\n<li>클라이언트 측 수분화: 브라우저가 HTML을 수신하면 클라이언트 측 JavaScript(client.js)가 서버에서 렌더링된 HTML을 수분화하여 React 컴포넌트가 상호작용할 수 있게 합니다.</li>\n</ul>\n<p>장점:</p>\n<ul>\n<li>사전 렌더링된 HTML로 SEO가 유리해집니다.</li>\n<li>더 빠른 로딩 속도.</li>\n<li>페이지가 항상 최신 상태를 유지합니다.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>각 요청이 처리되는 데 더 오래 걸릴 수 있습니다.</li>\n<li>CSR(Clinet-Side Rendering)을 사용하는 것보다 페이지 로드에 더 오랜 시간이 소요될 수 있습니다.</li>\n<li>정적 렌더링보다 설정 및 유지 관리가 복잡합니다.</li>\n</ul>\n<h2>스트리밍 렌더링</h2>\n<p>스트리밍 렌더링은 서버가 HTML의 일부를 클라이언트에게 가능한 즉시 전송하는 기술입니다. 이를 통해 브라우저가 페이지를 렌더링하기 시작함으로써 웹 애플리케이션의 성능이 향상됩니다.</p>\n<p><img src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_4.png\" alt=\"Rendering Strategies Every React Developer Should Know\"></p>\n<p>중요한 포인트:</p>\n<ol>\n<li>\n<p>느껴지는 성능 개선: 사용자는 나머지 부분이 렌더링되고 스트리밍되는 동안 페이지 일부와 상호 작용을 시작할 수 있습니다.</p>\n</li>\n<li>\n<p>점진적 렌더링: 페이지의 핵심 부분이 먼저 전송되고 렌더링되어 사용자 경험을 향상시킵니다.</p>\n</li>\n<li>\n<p>첫 번째 바이트로의 시간 단축(TTFB): 스트리밍을 통해 첫 번째 바이트로의 시간을 단축시켜 초기 로드가 빠르게 느껴질 수 있습니다.</p>\n</li>\n</ol>\n<p>React 18의 스트리밍 렌더링은 서버 사이드 렌더링을 위해 새로운 pipeToNodeWritable 메소드를 사용합니다. 이는 HTML 부분을 준비되는 대로 클라이언트로 보냅니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">React</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'react'</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ReactDOMServer</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'react-dom/server'</span>);\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">Writable</span> } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'stream'</span>);\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Home</span>(<span class=\"hljs-params\">{ data }</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{data.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{data.content}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'/'</span>, <span class=\"hljs-keyword\">async</span> (req, res) => {\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data'</span>);\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n\n  <span class=\"hljs-keyword\">const</span> htmlStart = <span class=\"hljs-string\">`\n    &#x3C;!DOCTYPE html>\n    &#x3C;html lang=\"en\">\n      &#x3C;head>\n        &#x3C;meta charset=\"UTF-8\">\n        &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        &#x3C;title>Streaming Rendering&#x3C;/title>\n      &#x3C;/head>\n      &#x3C;body>\n        &#x3C;div id=\"root\">\n  `</span>;\n\n  <span class=\"hljs-keyword\">const</span> htmlEnd = <span class=\"hljs-string\">`\n        &#x3C;/div>\n        &#x3C;script>\n          window.__INITIAL_DATA__ = <span class=\"hljs-subst\">${<span class=\"hljs-built_in\">JSON</span>.stringify(data)}</span>\n        &#x3C;/script>\n        &#x3C;script src=\"/client.js\">&#x3C;/script>\n      &#x3C;/body>\n    &#x3C;/html>\n  `</span>;\n\n  res.<span class=\"hljs-title function_\">write</span>(htmlStart);\n\n  <span class=\"hljs-keyword\">const</span> writable = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Writable</span>({\n    <span class=\"hljs-title function_\">write</span>(<span class=\"hljs-params\">chunk, encoding, callback</span>) {\n      res.<span class=\"hljs-title function_\">write</span>(chunk, encoding, callback);\n    },\n    <span class=\"hljs-title function_\">final</span>(<span class=\"hljs-params\">callback</span>) {\n      res.<span class=\"hljs-title function_\">write</span>(htmlEnd);\n      res.<span class=\"hljs-title function_\">end</span>();\n      <span class=\"hljs-title function_\">callback</span>();\n    },\n  });\n\n  <span class=\"hljs-title class_\">ReactDOMServer</span>.<span class=\"hljs-title function_\">pipeToNodeWritable</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Home</span> <span class=\"hljs-attr\">data</span>=<span class=\"hljs-string\">{data}</span> /></span></span>, writable);\n});\n\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Server is running on http://localhost:3000'</span>);\n});\n</code></pre>\n<p>작동 방식:</p>\n<ul>\n<li>서버 측: 초기 HTML을 스트리밍하기 위해 ReactDOMServer.pipeToNodeWritable을 사용합니다.</li>\n<li>클라이언트 측: 클라이언트는 HTML의 일부를 도착하는 대로 렌더링을 시작합니다.</li>\n</ul>\n<p>장점:</p>\n<ul>\n<li>사용자가 페이지 일부와 상호 작용할 수 있습니다.</li>\n<li>핵심 콘텐츠가 먼저 표시되어 사용자 경험이 향상됩니다.</li>\n<li>더 많은 콘텐츠가 로드됨에 따라 사용자 인터페이스가 점진적으로 향상됩니다.</li>\n<li>페이지 전체를 한꺼번에 렌더링할 필요가 없기 때문에 서버 및 클라이언트 리소스를 적게 사용합니다.</li>\n<li>검색 엔진이 콘텐츠를 더 빨리 찾을 수 있습니다.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>Implementation은 전통적 렌더링보다 복잡합니다.</li>\n<li>올바른 렌더링을 보장하기 위해 종속성 및 스트리밍 순서를 관리해야 합니다.</li>\n<li>모든 브라우저나 네트워크에서 스트리밍할 수 있는 것은 아닙니다.</li>\n<li>비동기적인 성격 때문에 스트리밍 문제 해결이 더 어렵습니다.</li>\n<li>제대로 관리되지 않으면 서버 및 클라이언트 렌더링된 콘텐츠 사이에 차이가 있을 수 있습니다.</li>\n</ul>\n<h2>정적 사이트 생성</h2>\n<p>정적 사이트 생성은 HTML 페이지를 미리 렌더링하여 정적 파일로 제공하는 기술입니다. 이 접근 방식은 사전 렌더링된 HTML을 제공함으로써 성능을 향상시키고 서버 부하를 줄이며 보안을 강화할 수 있습니다.</p>\n<p>주요 포인트:</p>\n<ol>\n<li>\n<p>성능: 페이지가 사전 렌더링되어 정적 파일로 제공되므로 로딩 속도가 매우 빠릅니다.</p>\n</li>\n<li>\n<p>SEO: 사전 렌더링된 HTML은 검색 엔진이 쉽게 크롤링하여 SEO를 개선합니다.</p>\n</li>\n<li>\n<p>보안: 정적 파일을 제공함으로써 서버 렌더링된 페이지와 비교하여 공격 표면이 줄어듭니다.</p>\n</li>\n</ol>\n<p>예시:</p>\n<p>다음은 Next.js를 사용한 SSG의 예시입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// pages/index.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Home</span>(<span class=\"hljs-params\">{ data }</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{data.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{data.content}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getStaticProps</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data'</span>);\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> res.<span class=\"hljs-title function_\">json</span>();\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">props</span>: {\n      data,\n    },\n  };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;\n</code></pre>\n<p>이 예제에서는:</p>\n<p>• getStaticProps 함수는 데이터를 빌드 시간에 가져오고 서버에서 실행됩니다.</p>\n<ul>\n<li>\n<p>홈 컴포넌트로 전달된 데이터는 props를 통해 전달됩니다.</p>\n</li>\n<li>\n<p>HTML은 빌드 시 생성되어 정적 파일로 제공됩니다.</p>\n</li>\n</ul>\n<p>장점:</p>\n<ul>\n<li>정적 파일의 빠른 로드 시간.</li>\n<li>사전 렌더링된 HTML로 SEO 향상.</li>\n<li>더 빠른 서버와 안전한 데이터.</li>\n</ul>\n<p><strong>단점:</strong></p>\n<ul>\n<li>내용 변경에 대한 유연성이 부족합니다.</li>\n<li>우선 구축해야 합니다.</li>\n<li>대규모 사이트의 경우 빌드 시간이 더 오래 걸릴 수 있습니다.</li>\n</ul>\n<h2>증분 정적 재생</h2>\n<p>증분 정적 재생(Incremental Static Regeneration, ISR)은 사이트를 빌드하고 배포한 후 정적 페이지를 업데이트할 수 있는 기능입니다. 이 접근 방식은 정적 사이트 생성의 이점과 내용을 업데이트할 수 있는 유연성을 결합합니다.</p>\n<p>중요한 점:</p>\n<ol>\n<li>\n<p>요청 시 업데이트: 데이터 변경 시 전체 사이트 재구축이 필요하지 않고 페이지를 증분적으로 업데이트할 수 있습니다.</p>\n</li>\n<li>\n<p>향상된 성능: 정적 컨텐츠를 제공하면서 특정 페이지를 새로 고침하고 업데이트할 수 있는 기능을 제공합니다.</p>\n</li>\n<li>\n<p>유연성: 정적 사이트의 속도와 동적 콘텐츠 업데이트를 처리할 수 있는 능력을 결합합니다.</p>\n</li>\n</ol>\n<p>예시:</p>\n<p>다음은 ISR을 보여주는 Next.js 사용 예시입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// pages/index.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Home</span>(<span class=\"hljs-params\">{ data }</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{data.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{data.content}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getStaticProps</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data'</span>);\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> res.<span class=\"hljs-title function_\">json</span>();\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">props</span>: {\n      data,\n    },\n    <span class=\"hljs-attr\">revalidate</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-comment\">// 최대 10초마다 페이지를 다시 생성합니다.</span>\n  };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;\n</code></pre>\n<p>이 예시에서:</p>\n<ul>\n<li>getStaticProps 함수는 빌드 시간에 데이터를 가져옵니다.</li>\n<li>revalidate 속성은 다시 유효화 기간(예: 10초)을 지정하여 해당 기간 동안 최대 한 번 페이지가 다시 생성되도록 하여 요청이 들어오면.</li>\n<li>생성된 정적 HTML은 완전한 사이트 재구성 없이 새 데이터로 업데이트할 수 있습니다.</li>\n</ul>\n<p>장점:</p>\n<ul>\n<li>빠르고 유연합니다.</li>\n<li>HTML로 인한 SEO 향상.</li>\n<li>빈번한 재구성 요구를 줄여 시간과 리소스를 절약합니다.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>정적 사이트 생성보다 설정하는 것이 더 복잡합니다.</li>\n<li>최신 콘텐츠가 사용자에게 즉시 표시되지 않을 수 있습니다.</li>\n</ul>\n<h2>재수전</h2>\n<p>React에서 재수전은 서버에서 React 애플리케이션을 렌더링하여 초기 HTML을 생성한 다음 React가 클라이언트에서 페이지를 상호작용하도록 만드는 것을 의미합니다. 이 과정을 통해 사용자가 빠르게 시작하고 JavaScript가 준비되면 페이지와 상호 작용할 수 있도록 합니다.</p>\n<p>주요 요점:</p>\n<ol>\n<li>\n<p>서버 측 렌더링 (SSR): 서버가 초기 HTML을 생성합니다.</p>\n</li>\n<li>\n<p>클라이언트 측 재가동: 클라이언트 측 React 코드가 페이지를 대화식으로 만듭니다.</p>\n</li>\n</ol>\n<p>예시:</p>\n<p>다음은 React를 사용하여 재가동을 보여주는 간단한 예시입니다:</p>\n<p>서버 측</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">React</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'react'</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ReactDOMServer</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'react-dom/server'</span>);\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">App</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./App'</span>).<span class=\"hljs-property\">default</span>;\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n\napp.<span class=\"hljs-title function_\">use</span>(express.<span class=\"hljs-title function_\">static</span>(path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">'build'</span>)));\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'*'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> appString = <span class=\"hljs-title class_\">ReactDOMServer</span>.<span class=\"hljs-title function_\">renderToString</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">App</span> /></span></span>);\n\n  <span class=\"hljs-keyword\">const</span> indexFile = path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">'build'</span>, <span class=\"hljs-string\">'index.html'</span>);\n  fs.<span class=\"hljs-title function_\">readFile</span>(indexFile, <span class=\"hljs-string\">'utf8'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data</span>) =></span> {\n    <span class=\"hljs-keyword\">if</span> (err) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'에러 발생:'</span>, err);\n      <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">500</span>).<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">'앗!'</span>);\n    }\n\n    <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">send</span>(\n      data.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">'&#x3C;div id=\"root\">&#x3C;/div>'</span>, <span class=\"hljs-string\">`&#x3C;div id=\"root\"><span class=\"hljs-subst\">${appString}</span>&#x3C;/div>`</span>)\n    );\n  });\n});\n\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'서버가 http://localhost:3000에서 실행 중입니다.'</span>);\n});\n</code></pre>\n<p>클라이언트 측</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-dom'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./App'</span>;\n\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">hydrate</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">App</span> /></span></span>, <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'root'</span>));\n</code></pre>\n<p>작동 방식:</p>\n<ol>\n<li>\n<p>서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지 로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.</p>\n</li>\n<li>\n<p>클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate가 정적 HTML을 가져와 상호 작용할 수 있도록 이벤트 리스너를 부착합니다.</p>\n</li>\n</ol>\n<p>장점:</p>\n<ul>\n<li>서버에서 미리 렌더링된 HTML로 인한 빠른 초기로드 시간.</li>\n<li>미리 렌더링된 콘텐츠로 개선된 SEO.</li>\n<li>클라이언트 측 JavaScript가 로드된 후 완전한 상호작용 가능.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>JavaScript가 로드될 때까지 상호작용이 지연될 수 있음.</li>\n<li>서버 및 클라이언트에서 렌더링된 콘텐츠가 일치하는지 확인하기 어려울 수 있음.</li>\n</ul>\n<h2>부분 유기화</h2>\n<p>부분 수분화는 웹 개발에서 일부 정적 HTML 페이지만 상호 작용적으로 만드는 기술입니다. 이 방식은 페이지의 일부만 상호 작용을 요구하는 부분에 대해 JavaScript를로드하고 실행해 성능을 향상시키며, 전반적인 JavaScript 페이로드를 줄입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_5.png\" alt=\"Rendering Strategies Every React Developer Should Know\"></p>\n<p>주요 포인트:</p>\n<ul>\n<li>선택적 상호 작용: 페이지의 일부만로드됩니다.</li>\n<li>더 빠른 성능: 덜 JavaScript를로드 및 실행하므로 페이지가 더 빨리로드되고 더 적은 리소스를 사용합니다.</li>\n<li>점진적 향상: 페이지가 잘 작동하고 사용하기 쉬운지 확인합니다.</li>\n</ul>\n<p>예시:</p>\n<p>리액트를 사용하여 부분 하이드레이션을 보여주는 예시입니다:</p>\n<p>클라이언트 측</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-dom'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./App'</span>;\n\n<span class=\"hljs-keyword\">const</span> rootElement = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'root'</span>);\n<span class=\"hljs-keyword\">if</span> (rootElement.<span class=\"hljs-title function_\">hasChildNodes</span>()) {\n  <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">hydrate</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">App</span> /></span></span>, rootElement);\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">App</span> /></span></span>, rootElement);\n}\n</code></pre>\n<p>React Components (App.js와 InteractiveComponent.js)</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/App.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">InteractiveComponent</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./InteractiveComponent'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>정적 콘텐츠<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">InteractiveComponent</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/InteractiveComponent.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">InteractiveComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> setCount(count + 1)}>클릭하세요<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{count}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">InteractiveComponent</span>;\n</code></pre>\n<p>작동 방식:</p>\n<ul>\n<li>서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.</li>\n<li>클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate는 필요한 인터랙션이 필요한 페이지 부분만 적용합니다.</li>\n</ul>\n<p>장점:</p>\n<ul>\n<li>더 작은 JavaScript 페이로드로 인해 더 빠른로드 시간.</li>\n<li>페이지의 필요한 부분만 적용.</li>\n<li>사용자들은 더 많은 인터랙션을 즐깁니다.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>전체 페이지 하이드레이션보다 더 복잡합니다.</li>\n<li>주의 깊게 관리해야 합니다.</li>\n</ul>\n<h2>점진적 하이드레이션</h2>\n<p>점진적 하이드레이션은 웹 페이지의 다른 부분이 하나씩 로드되는 기술입니다. 이 방법은 필수 부분의 하이드레이션을 우선시하여 비필수 부분의 하이드레이션을 지연시킴으로써 성능을 향상시킵니다.</p>\n<p>주요 포인트:</p>\n<ul>\n<li>점진적으로 수분을 보충하는 것: 페이지의 일부는 점차적으로 로드됩니다.</li>\n<li>우선순위를 둔 상호작용: 중요 구성 요소가 먼저 수분 보충됩니다.</li>\n<li>성능 최적화: 초기 JavaScript 페이로드를 줄이고 페이지 로드 시간을 개선합니다.</li>\n</ul>\n<p>예시:</p>\n<p>React 및 Intersection Observer API를 사용하여 점진적 수분 보충을 보여주는 예시:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-dom'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./App'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hydrateComponent</span>(<span class=\"hljs-params\">selector, Component</span>) {\n  <span class=\"hljs-keyword\">const</span> element = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(selector);\n  <span class=\"hljs-keyword\">if</span> (element &#x26;&#x26; element.<span class=\"hljs-title function_\">hasChildNodes</span>()) {\n    <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">hydrate</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Component</span> /></span></span>, element);\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (element) {\n    <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Component</span> /></span></span>, element);\n  }\n}\n\n<span class=\"hljs-title function_\">hydrateComponent</span>(<span class=\"hljs-string\">'#root'</span>, <span class=\"hljs-title class_\">App</span>);\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/App.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IntersectionObserver</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =></span> {\n      entries.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">entry</span>) =></span> {\n        <span class=\"hljs-keyword\">if</span> (entry.<span class=\"hljs-property\">isIntersecting</span>) {\n          <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./ProgressiveComponent'</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ <span class=\"hljs-keyword\">default</span>: Component }</span>) =></span> {\n            <span class=\"hljs-title function_\">hydrateComponent</span>(<span class=\"hljs-string\">'#progressive'</span>, <span class=\"hljs-title class_\">Component</span>);\n          });\n          observer.<span class=\"hljs-title function_\">disconnect</span>();\n        }\n      });\n    });\n\n    observer.<span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">'#progressive'</span>));\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> observer.<span class=\"hljs-title function_\">disconnect</span>();\n  }, []);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>Static Content<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"progressive\"</span>></span>Loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/ProgressiveComponent.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ProgressiveComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> setCount(count + 1)}>Click me<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{count}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ProgressiveComponent</span>;\n</code></pre>\n<p>동작 방식:</p>\n<ul>\n<li>서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 HTML을 생성합니다.</li>\n<li>클라이언트 측: ReactDOM.hydrate은 주 응용 프로그램을 즉시 채웁니다.</li>\n<li>점진적 구성 요소 수화: Intersection Observer는 ProgressiveComponent가 뷰포트에 진입할 때 그것을 수화합니다.</li>\n</ul>\n<p>장점:</p>\n<ul>\n<li>필수 구성 요소만 먼저 로드하여 로드 시간을 개선했습니다.</li>\n<li>사용자들이 더 나은 경험을 할 수 있습니다.</li>\n<li>Javascript 파일이 줄어 듭니다.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>전체 페이지 가득 채우기보다 복잡합니다.</li>\n<li>문제를 피하기 위해 신중하게 관리해야 합니다.</li>\n</ul>\n<h2>동적 렌더링</h2>\n<p>동적 렌더링은 사용자가 원하는 내용을 기반으로 웹 페이지를 만드는 방법입니다. 이 방법은 크롤러와 사용자에게 서로 다른 내용을 제공함으로써 웹 사이트를 최적화하여 사용자와 검색 엔진을 위한 최적의 서비스를 제공합니다.</p>\n<p><img src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_6.png\" alt=\"랜더링 전략\"></p>\n<p>주요 포인트:</p>\n<ol>\n<li>\n<p>하이브리드 접근 방식: 서버 측 및 클라이언트 측 렌더링을 결합하여 성능 및 SEO를 최적화합니다.</p>\n</li>\n<li>\n<p>SEO 최적화: 사전 렌더링된 HTML을 검색 엔진에 제공하여 크롤링 및 인덱싱을 개선합니다.</p>\n</li>\n<li>\n<p>사용자 경험: 사용자가 사이트와 완전히 상호 작용할 수 있습니다.</p>\n</li>\n</ol>\n<p>예시:</p>\n<p>Node.js와 Puppeteer를 사용한 동적 렌더링 예제가 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n<span class=\"hljs-keyword\">const</span> puppeteer = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'puppeteer'</span>);\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'*'</span>, <span class=\"hljs-keyword\">async</span> (req, res) => {\n  <span class=\"hljs-keyword\">const</span> userAgent = req.<span class=\"hljs-property\">headers</span>[<span class=\"hljs-string\">'user-agent'</span>];\n  \n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-regexp\">/Googlebot|Bingbot|Baiduspider|YandexBot/i</span>.<span class=\"hljs-title function_\">test</span>(userAgent)) {\n    <span class=\"hljs-keyword\">const</span> browser = <span class=\"hljs-keyword\">await</span> puppeteer.<span class=\"hljs-title function_\">launch</span>();\n    <span class=\"hljs-keyword\">const</span> page = <span class=\"hljs-keyword\">await</span> browser.<span class=\"hljs-title function_\">newPage</span>();\n    <span class=\"hljs-keyword\">await</span> page.<span class=\"hljs-title function_\">goto</span>(<span class=\"hljs-string\">`http://localhost:3000<span class=\"hljs-subst\">${req.originalUrl}</span>`</span>, {\n      <span class=\"hljs-attr\">waitUntil</span>: <span class=\"hljs-string\">'networkidle2'</span>\n    });\n    <span class=\"hljs-keyword\">const</span> html = <span class=\"hljs-keyword\">await</span> page.<span class=\"hljs-title function_\">content</span>();\n    <span class=\"hljs-keyword\">await</span> browser.<span class=\"hljs-title function_\">close</span>();\n    res.<span class=\"hljs-title function_\">send</span>(html);\n  } <span class=\"hljs-keyword\">else</span> {\n    res.<span class=\"hljs-title function_\">sendFile</span>(__dirname + <span class=\"hljs-string\">'/index.html'</span>);\n  }\n});\n\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'서버가 http://localhost:3000에서 실행 중입니다.'</span>);\n});\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-dom'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./App'</span>;\n\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">App</span> /></span></span>, <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'root'</span>));\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/App.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useState, useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [data, setData] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">null</span>);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'/api/data'</span>)\n      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> response.<span class=\"hljs-title function_\">json</span>())\n      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =></span> <span class=\"hljs-title function_\">setData</span>(data));\n  }, []);\n\n  <span class=\"hljs-keyword\">if</span> (!data) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>;\n  }\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{data.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{data.content}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;\n</code></pre>\n<p>API 엔드포인트 (Node.js + Express)</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'/api/data'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =></span> {\n  res.<span class=\"hljs-title function_\">json</span>({\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Dynamic Rendering Example'</span>,\n    <span class=\"hljs-attr\">content</span>: <span class=\"hljs-string\">'This content is fetched from the server.'</span>\n  });\n});\n\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3001</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'API 서버가 http://localhost:3001에서 실행 중입니다.'</span>);\n});\n</code></pre>\n<p>이 예제에서:</p>\n<ul>\n<li>서버는 사용자 에이전트 헤더를 확인하여 요청이 검색 엔진 봇에서 왔는지 확인합니다.</li>\n<li>요청이 봇에서 왔다면, Puppeteer가 사전 렌더링된 HTML을 생성하고 반환합니다.</li>\n<li>요청이 사용자에서 왔다면, 클라이언트 렌더링된 HTML이 제공되며, React 애플리케이션이 API 엔드포인트에서 데이터를 가져옵니다.</li>\n</ul>\n<p>장점:</p>\n<ul>\n<li>서버 측 및 클라이언트 측 렌더링을 결합합니다.</li>\n<li>검색 엔진 봇에 사전 렌더링된 콘텐츠를 제공하여 SEO를 최적화합니다.</li>\n<li>사용자가 상호 작용할 수 있습니다.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>서버 설치 및 유지 관리가 더 복잡합니다.</li>\n<li>프리 렌더링을 위해 headless 브라우저가 필요하기 때문에 더 많은 리소스를 사용합니다.</li>\n<li>사용자 에이전트 감지 및 동적 콘텐츠 생성에 주의를 기울여야 합니다.</li>\n</ul>\n<h2>결론</h2>\n<p>웹 개발의 빠르게 변화하는 세계에서는 웹 페이지를 멋지게 보이고 빠르게 로드하기 위한 다양한 방법을 이해하고 활용하는 것이 중요합니다. 각 렌더링 방법에는 다양한 장단이 있습니다.</p>\n<p>중요 사항:</p>\n<ol>\n<li>클라이언트 측 렌더링 (CSR)은 사용자에게는 훌륭하지만 SEO 및 로딩 시간에 대비하여 다소 어려울 수 있습니다.</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>서버 사이드 렌더링 (SSR)은 초기 로드 속도를 향상시키고 SEO를 개선하지만 서버 부하와 복잡성을 증가시킬 수 있습니다.</p>\n</li>\n<li>\n<p>스트리밍 렌더링은 HTML을 점진적으로 클라이언트로 전송하여 인식된 성능을 향상시킵니다.</p>\n</li>\n<li>\n<p>정적 사이트 생성 (SSG)은 빠른 로드 시간과 향상된 보안을 제공하여 변경되지 않는 콘텐츠에 이상적입니다.</p>\n</li>\n<li>\n<p>점진적 정적 재생성 (ISR)은 정적 및 동적 콘텐츠 업데이트의 이점을 결합하여 성능과 유연성을 균형 있게 제공합니다.</p>\n</li>\n</ol>\n<ol start=\"6\">\n<li>\n<p>리하이드레이션은 서버에서 렌더링된 HTML과 클라이언트 측 상호 작용을 연결하여 부드러운 사용자 경험을 제공합니다.</p>\n</li>\n<li>\n<p>부분 하이드레이션 및 점진적 하이드레이션은 필요에 따라 페이지의 일부를 선택적으로 상호 작용할 수 있도록 최적화하여 성능을 향상시킵니다.</p>\n</li>\n<li>\n<p>동적 렌더링은 사전 렌더링된 콘텐츠를 검색 엔진 최적화를 위해 봇에 제공하면서 사용자에게 동적 콘텐츠를 제공하여 향상된 경험을 제공합니다.</p>\n</li>\n</ol>\n<p>적절한 렌더링 전략은 앱의 요구 사항, 성능 및 사용자 경험에 따라 다릅니다. 이러한 기술을 사용함으로써 개발자들은 사용자와 검색 엔진에게 잘 작동하는 사용자 친화적인 웹 앱을 만들 수 있습니다.</p>\n<p>Web 기술이 발전함에 따라, 개발자들은 웹 앱을 빠르게 실행할 수 있는 최상의 방법을 항상 파악해야 합니다. 이러한 방법을 활용하여 훌륭한 디지털 경험을 만들어보세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}