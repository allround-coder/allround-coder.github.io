{"pageProps":{"post":{"title":"바닐라 JS로 만들어진 웹캠 인피니티 미러","description":"","date":"2024-05-27 19:14","slug":"2024-05-27-MirrorMirrorAWebcamInfinityMirrorwithVanillaJS","content":"\n\n<img src=\"/assets/img/2024-05-27-MirrorMirrorAWebcamInfinityMirrorwithVanillaJS_0.png\" />\n\n# 소개\n\n프로그래머로서, 종종 기술 스택 레이어, 복잡한 구조 및 다양한 통합이 포함된 대규모 프로젝트에 참여합니다. 때로는 기본으로 돌아가 간단한 것을 만드는 것도 재미있죠.\n\n이 프로젝트에서는 HTML 및 JavaScript만 사용하여 브라우저 기반 웹 애플리케이션을 만들어 실시간 인피니티 미러를 생성하고 이미지 뒤집기/회전/저장 버튼을 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n지금까지 데스크톱, iOS 및 안드로이드 브라우저에서 작동하는 것으로 확인했습니다.\n\n## 컨셉\n\n아이디어는 간단합니다: 웹캠 피드를 사용하여 브라우저에서 직접 시각적으로 매력적인 효과를 만드는 것입니다. 프로젝트는 비디오 피드를 수평으로 뒤집는, 회전하는, \"무한 거울\" 효과를 적용하는 및 현재 뷰를 이미지 파일로 저장하는 기능을 구현하는 것을 목표로 했습니다. 이는 HTML5 비디오 요소와 캔버스 API의 응용을 현실세계 시나리오에서 탐색하는 간단한 방법을 제공합니다.\n\n## 도구 및 기술\n\n<div class=\"content-ad\"></div>\n\n- HTML5: 비디오 표시 및 제어 요소를 구성하는 데 사용됩니다.\n- CSS3: 웹 페이지를 스타일링하여 요소가 시각적으로 매력적이고 기능적으로 배치되도록 합니다.\n- JavaScript: 상호작용의 핵심으로 웹캠 액세스를 처리하고 실시간으로 비디오 피드를 조작합니다.\n- Bootstrap: 빠르고 반응형 버튼 스타일링을 위해 Bootstrap을 조금 사용합니다.\n- WebRTC(웹 실시간 통신): 이 기술은 사용자 카메라에서 비디오를 직접 캡처하고 스트리밍하는 수단을 제공합니다.\n\n## 레이아웃 설정\n\nHTML 페이지는 비디오 요소와 캔버스를 호스팅하도록 설정되었습니다. 비디오 요소는 웹캠 피드를 캡처하고, 캔버스는 다양한 그래픽 변환을 적용하는 데 사용됩니다.\n\n```js\n<div class=\"title\">Mirror Mirror</div>\n<div class=\"btn-group\" role=\"group\">\n    <button id=\"btnToggle\" class=\"btn btn-success\">켜기</button>\n    <button id=\"btnEffect\" class=\"btn btn-warning\">무한 효과</button>\n    <button id=\"btnEdge\" class=\"btn btn-dark\">가장자리 감지</button>\n    <button id=\"btnFlip\" class=\"btn btn-primary\">수평 뒤집기</button>\n    <button id=\"btnRotate\" class=\"btn btn-secondary\">회전</button>\n    <button id=\"btnSave\" class=\"btn btn-info\">사진 저장</button>\n</div>\n</div>\n<div id=\"canvas-container\">\n    <canvas id=\"canvas\"></canvas>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n## 자바스크립트에서 제어 버튼 설정하기\n\n사용자 클릭을 감지하고 기능을 선택하려면 각 버튼에 대한 클릭 핸들러를 추가합니다. 이 버튼들은 비디오 피드를 켜고 끄거나, 무한 거울 또는 가장자리 감지와 같은 특수 효과를 적용하고, 이를 모바일 기기나 태블릿에서 사용하는 경우 뒤집거나 회전할 수 있습니다.\n\n만약 비디오 피드가 일시 중지된 경우 이미지는 마지막 이미지를 유지합니다. 언제든지 save 버튼을 사용하여 장치의 로컬 파일 시스템에 마지막 사진을 저장할 수 있습니다.\n\n```js\n document.addEventListener('DOMContentLoaded', function () {\n  const canvas = document.getElementById('canvas');\n  const context = canvas.getContext('2d');\n  let videoStream = null;\n  let video = document.createElement('video');\n  let flipHorizontal = false;\n  let infinityEffect = false;\n  let rotationAngle = 0;\n  let edgeDetectionEnabled = false;\n\n  const btnToggle = document.getElementById('btnToggle');\n  const btnFlip = document.getElementById('btnFlip');\n  const btnEffect = document.getElementById('btnEffect');\n  const btnRotate = document.getElementById('btnRotate');\n  const btnSave = document.getElementById('btnSave');\n\n  document.getElementById('btnEdge').addEventListener('click', function () {\n      edgeDetectionEnabled = !edgeDetectionEnabled;\n  });\n\n  btnToggle.addEventListener('click', function () {\n      if (videoStream) {\n          videoStream.getTracks().forEach(track => track.stop());\n          videoStream = null;\n          btnToggle.textContent = 'Turn On';\n          btnToggle.classList.replace('btn-danger', 'btn-success');\n      } else {\n          navigator.mediaDevices.getUserMedia({ video: true })\n              .then(stream => {\n                  videoStream = stream;\n                  video.srcObject = stream;\n                  video.play();\n                  btnToggle.textContent = 'Turn Off';\n                  btnToggle.classList.replace('btn-success', 'btn-danger');\n                  draw();\n              })\n              .catch(error => {\n                  console.error('Error accessing the camera: ', error);\n              });\n      }\n  });\n\n  btnFlip.addEventListener('click', function () {\n      flipHorizontal = !flipHorizontal;\n  });\n\n  btnEffect.addEventListener('click', function () {\n      infinityEffect = !infinityEffect;\n  });\n\n  btnRotate.addEventListener('click', function () {\n      rotationAngle = (rotationAngle + 90) % 360;\n      canvas.style.transform = `rotate(${rotationAngle}deg)`;\n  });\n\n  btnSave.addEventListener('click', function () {\n      if (canvas) {\n          const link = document.createElement('a');\n          link.download = 'infinity-mirror.png';\n          link.href = canvas.toDataURL('image/png');\n          link.click();\n      }\n  });\n```\n\n**이 상태유지 메시지가 도움이 돼셨나요?**\n\n<div class=\"content-ad\"></div>\n\n## 카메라 접근하기\n\n`navigator.mediaDevices.getUserMedia` API를 사용하여 웹캠 피드를 설정했어요. 이 API는 간단해서 미디어 입력을 사용할 수 있는 방법을 제공해요. 카메라를 사용할 권한을 요청하는 대화 상자가 나타날 거예요.\n\n```js\nnavigator.mediaDevices.getUserMedia({ video: true })\n.then(stream => {\nconst video = document.createElement('video');\nvideo.srcObject = stream;\nvideo.play();\n})\n.catch(error => {\nconsole.error('카메라에 접근하는 중 오류 발생: ', error);\n});\n```\n\n## 미러 효과를 위한 비디오 피드 조작\n\n<div class=\"content-ad\"></div>\n\n비디오 피드를 다루는 것이 더 재미있어질 때입니다. 저는 비디오를 수평으로 뒤집거나 회전하거나 무한 거울 효과를 적용하는 함수를 작성했습니다. 이 효과는 비디오 피드의 여러 배율 및 반투명 복사본을 생성하여 거울 효과를 만듭니다. scaleFactor 및 alphaFactor 변수로 거울 이미지의 인스턴스 수나 안쪽 여백을 변경할 수 있습니다. 제 데스크탑에서 실행 속도가 얼마나 빠른지 고려할 때, 나중에 업데이트에서 해당 슬라이더를 추가할 수도 있겠죠. 이에 관심이 있다면 GitHub 레포지토리에 이슈를 남겨주세요.\n\n```js\nfunction applyInfinityEffect(context, width, height) {\n    const numberOfReflections = 5;\n    let scaleFactor = 0.5;\n    let alphaFactor = 0.9;\n\n    for (let i = 0; i < numberOfReflections; i++) {\n        context.globalAlpha = Math.pow(alphaFactor, i + 1);\n        const newWidth = width * Math.pow(scaleFactor, i + 1);\n        const newHeight = height * Math.pow(scaleFactor, i + 1);\n        const dx = (width - newWidth) / 2;\n        const dy = (height - newHeight) / 2;\n\n        context.drawImage(canvas, 0, 0, width, height, dx, dy, newWidth, newHeight);\n    }\n\n    context.globalAlpha = 1.0;\n}\n```\n\n## 소벨 필터를 사용한 에지 검출\n\n이미지 처리에 익숙한 사람을 위해 비디오의 각 프레임을 가져와 \"에지\" 또는 각 객체의 경계를 탐지하는 필터를 실행할 수 있습니다. 이 작업은 각 프레임에 2D 그라디언트를 적용하는 소벨 연산자를 사용하여 수행됩니다. 우리는 이를 보여주기 위해 회색조로 변환합니다. 소벨 연산자에 대한 추가 배경 정보는 여기서 볼 수 있습니다. 코드를 수정하고 다른 이미지 처리 작업을 추가할 수도 있습니다. 추가할 수 있는 많은 고전적인 신호 처리 필터가 있지만 UI 컨트롤의 수가 상당히 늘어날 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction applyEdgeDetection(context, width, height) {\n    const imageData = context.getImageData(0, 0, width, height);\n    const grayScaled = grayscale(imageData.data, width, height);\n    const edgeData = sobelFilter(grayScaled, width, height);\n    context.putImageData(new ImageData(edgeData, width, height), 0, 0);\n}\n\nfunction grayscale(data, width, height) {\n    const result = new Uint8ClampedArray(width * height * 4);\n    for (let i = 0; i < data.length; i += 4) {\n        const avg = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];\n        result[i] = avg; // red\n        result[i + 1] = avg; // green\n        result[i + 2] = avg; // blue\n        result[i + 3] = 255; // alpha\n    }\n    return result;\n}\n\n\nfunction sobelFilter(data, width, height) {\n    const kernelX = [\n        [-1, 0, 1],\n        [-2, 0, 2],\n        [-1, 0, 1]\n    ];\n    const kernelY = [\n        [-1, -2, -1],\n        [0, 0, 0],\n        [1, 2, 1]\n    ];\n\n    const sobelData = new Uint8ClampedArray(width * height * 4); // Correctly sized array\n\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            let px = (y * width + x) * 4;\n            let gx = 0;\n            let gy = 0;\n\n            for (let cy = -1; cy <= 1; cy++) {\n                for (let cx = -1; cx <= 1; cx++) {\n                    const cpx = ((y + cy) * width + (x + cx)) * 4;\n                    gx += data[cpx] * kernelX[cy + 1][cx + 1];\n                    gy += data[cpx] * kernelY[cy + 1][cx + 1];\n                }\n            }\n\n            const magnitude = Math.sqrt(gx * gx + gy * gy);\n            sobelData[px] = sobelData[px + 1] = sobelData[px + 2] = magnitude;\n            sobelData[px + 3] = 255; // alpha\n        }\n    }\n    return sobelData;\n}\n```\n\n## Canny Filter를 사용한 Edge Detection\n\nSobel은 그 연산 부하가 비교적 적은 편이기 때문에 인기 있는 선택지입니다. Canny Filter 또한 엣지 검출을 제공하지만 이미지를 그라디언트를 취하기 전에 블러처리하여 연산량이 많이 필요합니다. 이로 인해 라인 드로잉 형식의 효과를 더 많이 만들어 냅니다. Canny Filter에 대해 더 알고 싶다면 여기를 참고하세요. Canny Filter (및 해당 파생)는 콘크리트 입자나 작은 직물 패턴과 같은 '질감있는' 가장자리보다는 덜 민감합니다.\n\n코드에서 Canny 필터를 활성화하는 방법은 아래에 나와 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n function applyCannyEdgeDetection(context, width, height) {\n    const imageData = context.getImageData(0, 0, width, height);\n    const grayScaled = grayscale(imageData.data, width, height);\n    const blurred = gaussianBlur(grayScaled, width, height);\n    const edgeData = cannyFilter(blurred, width, height);\n    context.putImageData(new ImageData(edgeData, width, height), 0, 0);\n}\n\nfunction grayscale(data, width, height) {\n    const result = new Uint8ClampedArray(width * height * 4);\n    for (let i = 0; i < data.length; i += 4) {\n        const avg = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];\n        result[i] = avg; // red\n        result[i + 1] = avg; // green\n        result[i + 2] = avg; // blue\n        result[i + 3] = 255; // alpha\n    }\n    return result;\n}\n\nfunction gaussianBlur(data, width, height) {\n    const kernel = [\n        [1, 2, 1],\n        [2, 4, 2],\n        [1, 2, 1]\n    ];\n    const kernelWeight = 16;\n    const blurredData = new Uint8ClampedArray(width * height * 4);\n\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            let sum = 0;\n            let sumAlpha = 0;\n\n            for (let cy = -1; cy <= 1; cy++) {\n                for (let cx = -1; cx <= 1; cx++) {\n                    const pixel = ((y + cy) * width + (x + cx)) * 4;\n                    const weight = kernel[cy + 1][cx + 1];\n                    sum += data[pixel] * weight;\n                    sumAlpha += data[pixel + 3];\n                }\n            }\n\n            const pixelIndex = (y * width + x) * 4;\n            blurredData[pixelIndex] = sum / kernelWeight;\n            blurredData[pixelIndex + 1] = sum / kernelWeight;\n            blurredData[pixelIndex + 2] = sum / kernelWeight;\n            blurredData[pixelIndex + 3] = sumAlpha / kernelWeight;\n        }\n    }\n    return blurredData;\n}\n\nfunction cannyFilter(data, width, height) {\n    // Simplified Canny edge detection\n    const sobelData = sobelFilter(data, width, height);\n    const result = new Uint8ClampedArray(width * height * 4);\n\n    for (let i = 0; i < sobelData.length; i += 4) {\n        const magnitude = sobelData[i];\n        if (magnitude > 50) {\n            result[i] = result[i + 1] = result[i + 2] = 255; // white\n            result[i + 3] = 255; // alpha\n        } else {\n            result[i] = result[i + 1] = result[i + 2] = 0; // black\n            result[i + 3] = 255; // alpha\n        }\n    }\n\n    return result;\n}\n```\n\n## 결론\n\n이 프로젝트는 간단한 웹 기술을 사용하여 얼마나 많은 작업을 수행할 수 있는지를 상기시켜주는 것이었습니다. HTML5, JavaScript 및 최신 웹 기술을 사용하면 비디오 스트림을 실시간으로 프레임별로 처리할 수 있습니다.\n\n이를 통해 재미있는 경험을 할 수 있기를 바라며, 웹 기술 선택에 대한 의견을 주시면 감사하겠습니다.","ogImage":{"url":"/assets/img/2024-05-27-MirrorMirrorAWebcamInfinityMirrorwithVanillaJS_0.png"},"coverImage":"/assets/img/2024-05-27-MirrorMirrorAWebcamInfinityMirrorwithVanillaJS_0.png","tag":["Tech"],"readingTime":11},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>소개</h1>\n<p>프로그래머로서, 종종 기술 스택 레이어, 복잡한 구조 및 다양한 통합이 포함된 대규모 프로젝트에 참여합니다. 때로는 기본으로 돌아가 간단한 것을 만드는 것도 재미있죠.</p>\n<p>이 프로젝트에서는 HTML 및 JavaScript만 사용하여 브라우저 기반 웹 애플리케이션을 만들어 실시간 인피니티 미러를 생성하고 이미지 뒤집기/회전/저장 버튼을 추가합니다.</p>\n<p>지금까지 데스크톱, iOS 및 안드로이드 브라우저에서 작동하는 것으로 확인했습니다.</p>\n<h2>컨셉</h2>\n<p>아이디어는 간단합니다: 웹캠 피드를 사용하여 브라우저에서 직접 시각적으로 매력적인 효과를 만드는 것입니다. 프로젝트는 비디오 피드를 수평으로 뒤집는, 회전하는, \"무한 거울\" 효과를 적용하는 및 현재 뷰를 이미지 파일로 저장하는 기능을 구현하는 것을 목표로 했습니다. 이는 HTML5 비디오 요소와 캔버스 API의 응용을 현실세계 시나리오에서 탐색하는 간단한 방법을 제공합니다.</p>\n<h2>도구 및 기술</h2>\n<ul>\n<li>HTML5: 비디오 표시 및 제어 요소를 구성하는 데 사용됩니다.</li>\n<li>CSS3: 웹 페이지를 스타일링하여 요소가 시각적으로 매력적이고 기능적으로 배치되도록 합니다.</li>\n<li>JavaScript: 상호작용의 핵심으로 웹캠 액세스를 처리하고 실시간으로 비디오 피드를 조작합니다.</li>\n<li>Bootstrap: 빠르고 반응형 버튼 스타일링을 위해 Bootstrap을 조금 사용합니다.</li>\n<li>WebRTC(웹 실시간 통신): 이 기술은 사용자 카메라에서 비디오를 직접 캡처하고 스트리밍하는 수단을 제공합니다.</li>\n</ul>\n<h2>레이아웃 설정</h2>\n<p>HTML 페이지는 비디오 요소와 캔버스를 호스팅하도록 설정되었습니다. 비디오 요소는 웹캠 피드를 캡처하고, 캔버스는 다양한 그래픽 변환을 적용하는 데 사용됩니다.</p>\n<pre><code class=\"hljs language-js\">&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"title\"</span>><span class=\"hljs-title class_\">Mirror</span> <span class=\"hljs-title class_\">Mirror</span>&#x3C;/div>\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn-group\"</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">\"group\"</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"btnToggle\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-success\"</span>></span>켜기<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"btnEffect\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-warning\"</span>></span>무한 효과<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"btnEdge\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-dark\"</span>></span>가장자리 감지<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"btnFlip\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-primary\"</span>></span>수평 뒤집기<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"btnRotate\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-secondary\"</span>></span>회전<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"btnSave\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-info\"</span>></span>사진 저장<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n&#x3C;/div>\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"canvas-container\"</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"canvas\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">canvas</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n</code></pre>\n<h2>자바스크립트에서 제어 버튼 설정하기</h2>\n<p>사용자 클릭을 감지하고 기능을 선택하려면 각 버튼에 대한 클릭 핸들러를 추가합니다. 이 버튼들은 비디오 피드를 켜고 끄거나, 무한 거울 또는 가장자리 감지와 같은 특수 효과를 적용하고, 이를 모바일 기기나 태블릿에서 사용하는 경우 뒤집거나 회전할 수 있습니다.</p>\n<p>만약 비디오 피드가 일시 중지된 경우 이미지는 마지막 이미지를 유지합니다. 언제든지 save 버튼을 사용하여 장치의 로컬 파일 시스템에 마지막 사진을 저장할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"> <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'DOMContentLoaded'</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'canvas'</span>);\n  <span class=\"hljs-keyword\">const</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">'2d'</span>);\n  <span class=\"hljs-keyword\">let</span> videoStream = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">let</span> video = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">'video'</span>);\n  <span class=\"hljs-keyword\">let</span> flipHorizontal = <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">let</span> infinityEffect = <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">let</span> rotationAngle = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> edgeDetectionEnabled = <span class=\"hljs-literal\">false</span>;\n\n  <span class=\"hljs-keyword\">const</span> btnToggle = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'btnToggle'</span>);\n  <span class=\"hljs-keyword\">const</span> btnFlip = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'btnFlip'</span>);\n  <span class=\"hljs-keyword\">const</span> btnEffect = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'btnEffect'</span>);\n  <span class=\"hljs-keyword\">const</span> btnRotate = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'btnRotate'</span>);\n  <span class=\"hljs-keyword\">const</span> btnSave = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'btnSave'</span>);\n\n  <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'btnEdge'</span>).<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      edgeDetectionEnabled = !edgeDetectionEnabled;\n  });\n\n  btnToggle.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">if</span> (videoStream) {\n          videoStream.<span class=\"hljs-title function_\">getTracks</span>().<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">track</span> =></span> track.<span class=\"hljs-title function_\">stop</span>());\n          videoStream = <span class=\"hljs-literal\">null</span>;\n          btnToggle.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">'Turn On'</span>;\n          btnToggle.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">'btn-danger'</span>, <span class=\"hljs-string\">'btn-success'</span>);\n      } <span class=\"hljs-keyword\">else</span> {\n          navigator.<span class=\"hljs-property\">mediaDevices</span>.<span class=\"hljs-title function_\">getUserMedia</span>({ <span class=\"hljs-attr\">video</span>: <span class=\"hljs-literal\">true</span> })\n              .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">stream</span> =></span> {\n                  videoStream = stream;\n                  video.<span class=\"hljs-property\">srcObject</span> = stream;\n                  video.<span class=\"hljs-title function_\">play</span>();\n                  btnToggle.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">'Turn Off'</span>;\n                  btnToggle.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">'btn-success'</span>, <span class=\"hljs-string\">'btn-danger'</span>);\n                  <span class=\"hljs-title function_\">draw</span>();\n              })\n              .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n                  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'Error accessing the camera: '</span>, error);\n              });\n      }\n  });\n\n  btnFlip.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      flipHorizontal = !flipHorizontal;\n  });\n\n  btnEffect.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      infinityEffect = !infinityEffect;\n  });\n\n  btnRotate.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      rotationAngle = (rotationAngle + <span class=\"hljs-number\">90</span>) % <span class=\"hljs-number\">360</span>;\n      canvas.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">transform</span> = <span class=\"hljs-string\">`rotate(<span class=\"hljs-subst\">${rotationAngle}</span>deg)`</span>;\n  });\n\n  btnSave.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">if</span> (canvas) {\n          <span class=\"hljs-keyword\">const</span> link = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">'a'</span>);\n          link.<span class=\"hljs-property\">download</span> = <span class=\"hljs-string\">'infinity-mirror.png'</span>;\n          link.<span class=\"hljs-property\">href</span> = canvas.<span class=\"hljs-title function_\">toDataURL</span>(<span class=\"hljs-string\">'image/png'</span>);\n          link.<span class=\"hljs-title function_\">click</span>();\n      }\n  });\n</code></pre>\n<p><strong>이 상태유지 메시지가 도움이 돼셨나요?</strong></p>\n<h2>카메라 접근하기</h2>\n<p><code>navigator.mediaDevices.getUserMedia</code> API를 사용하여 웹캠 피드를 설정했어요. 이 API는 간단해서 미디어 입력을 사용할 수 있는 방법을 제공해요. 카메라를 사용할 권한을 요청하는 대화 상자가 나타날 거예요.</p>\n<pre><code class=\"hljs language-js\">navigator.<span class=\"hljs-property\">mediaDevices</span>.<span class=\"hljs-title function_\">getUserMedia</span>({ <span class=\"hljs-attr\">video</span>: <span class=\"hljs-literal\">true</span> })\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">stream</span> =></span> {\n<span class=\"hljs-keyword\">const</span> video = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">'video'</span>);\nvideo.<span class=\"hljs-property\">srcObject</span> = stream;\nvideo.<span class=\"hljs-title function_\">play</span>();\n})\n.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'카메라에 접근하는 중 오류 발생: '</span>, error);\n});\n</code></pre>\n<h2>미러 효과를 위한 비디오 피드 조작</h2>\n<p>비디오 피드를 다루는 것이 더 재미있어질 때입니다. 저는 비디오를 수평으로 뒤집거나 회전하거나 무한 거울 효과를 적용하는 함수를 작성했습니다. 이 효과는 비디오 피드의 여러 배율 및 반투명 복사본을 생성하여 거울 효과를 만듭니다. scaleFactor 및 alphaFactor 변수로 거울 이미지의 인스턴스 수나 안쪽 여백을 변경할 수 있습니다. 제 데스크탑에서 실행 속도가 얼마나 빠른지 고려할 때, 나중에 업데이트에서 해당 슬라이더를 추가할 수도 있겠죠. 이에 관심이 있다면 GitHub 레포지토리에 이슈를 남겨주세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">applyInfinityEffect</span>(<span class=\"hljs-params\">context, width, height</span>) {\n    <span class=\"hljs-keyword\">const</span> numberOfReflections = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">let</span> scaleFactor = <span class=\"hljs-number\">0.5</span>;\n    <span class=\"hljs-keyword\">let</span> alphaFactor = <span class=\"hljs-number\">0.9</span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; numberOfReflections; i++) {\n        context.<span class=\"hljs-property\">globalAlpha</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">pow</span>(alphaFactor, i + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">const</span> newWidth = width * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">pow</span>(scaleFactor, i + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">const</span> newHeight = height * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">pow</span>(scaleFactor, i + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">const</span> dx = (width - newWidth) / <span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-keyword\">const</span> dy = (height - newHeight) / <span class=\"hljs-number\">2</span>;\n\n        context.<span class=\"hljs-title function_\">drawImage</span>(canvas, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, width, height, dx, dy, newWidth, newHeight);\n    }\n\n    context.<span class=\"hljs-property\">globalAlpha</span> = <span class=\"hljs-number\">1.0</span>;\n}\n</code></pre>\n<h2>소벨 필터를 사용한 에지 검출</h2>\n<p>이미지 처리에 익숙한 사람을 위해 비디오의 각 프레임을 가져와 \"에지\" 또는 각 객체의 경계를 탐지하는 필터를 실행할 수 있습니다. 이 작업은 각 프레임에 2D 그라디언트를 적용하는 소벨 연산자를 사용하여 수행됩니다. 우리는 이를 보여주기 위해 회색조로 변환합니다. 소벨 연산자에 대한 추가 배경 정보는 여기서 볼 수 있습니다. 코드를 수정하고 다른 이미지 처리 작업을 추가할 수도 있습니다. 추가할 수 있는 많은 고전적인 신호 처리 필터가 있지만 UI 컨트롤의 수가 상당히 늘어날 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">applyEdgeDetection</span>(<span class=\"hljs-params\">context, width, height</span>) {\n    <span class=\"hljs-keyword\">const</span> imageData = context.<span class=\"hljs-title function_\">getImageData</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, width, height);\n    <span class=\"hljs-keyword\">const</span> grayScaled = <span class=\"hljs-title function_\">grayscale</span>(imageData.<span class=\"hljs-property\">data</span>, width, height);\n    <span class=\"hljs-keyword\">const</span> edgeData = <span class=\"hljs-title function_\">sobelFilter</span>(grayScaled, width, height);\n    context.<span class=\"hljs-title function_\">putImageData</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImageData</span>(edgeData, width, height), <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">grayscale</span>(<span class=\"hljs-params\">data, width, height</span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Uint8ClampedArray</span>(width * height * <span class=\"hljs-number\">4</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; data.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">4</span>) {\n        <span class=\"hljs-keyword\">const</span> avg = <span class=\"hljs-number\">0.34</span> * data[i] + <span class=\"hljs-number\">0.5</span> * data[i + <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">0.16</span> * data[i + <span class=\"hljs-number\">2</span>];\n        result[i] = avg; <span class=\"hljs-comment\">// red</span>\n        result[i + <span class=\"hljs-number\">1</span>] = avg; <span class=\"hljs-comment\">// green</span>\n        result[i + <span class=\"hljs-number\">2</span>] = avg; <span class=\"hljs-comment\">// blue</span>\n        result[i + <span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">255</span>; <span class=\"hljs-comment\">// alpha</span>\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sobelFilter</span>(<span class=\"hljs-params\">data, width, height</span>) {\n    <span class=\"hljs-keyword\">const</span> kernelX = [\n        [-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n        [-<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>],\n        [-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>]\n    ];\n    <span class=\"hljs-keyword\">const</span> kernelY = [\n        [-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">1</span>],\n        [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n        [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>]\n    ];\n\n    <span class=\"hljs-keyword\">const</span> sobelData = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Uint8ClampedArray</span>(width * height * <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// Correctly sized array</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">1</span>; y &#x3C; height - <span class=\"hljs-number\">1</span>; y++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">1</span>; x &#x3C; width - <span class=\"hljs-number\">1</span>; x++) {\n            <span class=\"hljs-keyword\">let</span> px = (y * width + x) * <span class=\"hljs-number\">4</span>;\n            <span class=\"hljs-keyword\">let</span> gx = <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-keyword\">let</span> gy = <span class=\"hljs-number\">0</span>;\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> cy = -<span class=\"hljs-number\">1</span>; cy &#x3C;= <span class=\"hljs-number\">1</span>; cy++) {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> cx = -<span class=\"hljs-number\">1</span>; cx &#x3C;= <span class=\"hljs-number\">1</span>; cx++) {\n                    <span class=\"hljs-keyword\">const</span> cpx = ((y + cy) * width + (x + cx)) * <span class=\"hljs-number\">4</span>;\n                    gx += data[cpx] * kernelX[cy + <span class=\"hljs-number\">1</span>][cx + <span class=\"hljs-number\">1</span>];\n                    gy += data[cpx] * kernelY[cy + <span class=\"hljs-number\">1</span>][cx + <span class=\"hljs-number\">1</span>];\n                }\n            }\n\n            <span class=\"hljs-keyword\">const</span> magnitude = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sqrt</span>(gx * gx + gy * gy);\n            sobelData[px] = sobelData[px + <span class=\"hljs-number\">1</span>] = sobelData[px + <span class=\"hljs-number\">2</span>] = magnitude;\n            sobelData[px + <span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">255</span>; <span class=\"hljs-comment\">// alpha</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> sobelData;\n}\n</code></pre>\n<h2>Canny Filter를 사용한 Edge Detection</h2>\n<p>Sobel은 그 연산 부하가 비교적 적은 편이기 때문에 인기 있는 선택지입니다. Canny Filter 또한 엣지 검출을 제공하지만 이미지를 그라디언트를 취하기 전에 블러처리하여 연산량이 많이 필요합니다. 이로 인해 라인 드로잉 형식의 효과를 더 많이 만들어 냅니다. Canny Filter에 대해 더 알고 싶다면 여기를 참고하세요. Canny Filter (및 해당 파생)는 콘크리트 입자나 작은 직물 패턴과 같은 '질감있는' 가장자리보다는 덜 민감합니다.</p>\n<p>코드에서 Canny 필터를 활성화하는 방법은 아래에 나와 있습니다.</p>\n<pre><code class=\"hljs language-js\"> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">applyCannyEdgeDetection</span>(<span class=\"hljs-params\">context, width, height</span>) {\n    <span class=\"hljs-keyword\">const</span> imageData = context.<span class=\"hljs-title function_\">getImageData</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, width, height);\n    <span class=\"hljs-keyword\">const</span> grayScaled = <span class=\"hljs-title function_\">grayscale</span>(imageData.<span class=\"hljs-property\">data</span>, width, height);\n    <span class=\"hljs-keyword\">const</span> blurred = <span class=\"hljs-title function_\">gaussianBlur</span>(grayScaled, width, height);\n    <span class=\"hljs-keyword\">const</span> edgeData = <span class=\"hljs-title function_\">cannyFilter</span>(blurred, width, height);\n    context.<span class=\"hljs-title function_\">putImageData</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImageData</span>(edgeData, width, height), <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">grayscale</span>(<span class=\"hljs-params\">data, width, height</span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Uint8ClampedArray</span>(width * height * <span class=\"hljs-number\">4</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; data.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">4</span>) {\n        <span class=\"hljs-keyword\">const</span> avg = <span class=\"hljs-number\">0.34</span> * data[i] + <span class=\"hljs-number\">0.5</span> * data[i + <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">0.16</span> * data[i + <span class=\"hljs-number\">2</span>];\n        result[i] = avg; <span class=\"hljs-comment\">// red</span>\n        result[i + <span class=\"hljs-number\">1</span>] = avg; <span class=\"hljs-comment\">// green</span>\n        result[i + <span class=\"hljs-number\">2</span>] = avg; <span class=\"hljs-comment\">// blue</span>\n        result[i + <span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">255</span>; <span class=\"hljs-comment\">// alpha</span>\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">gaussianBlur</span>(<span class=\"hljs-params\">data, width, height</span>) {\n    <span class=\"hljs-keyword\">const</span> kernel = [\n        [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>],\n        [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>],\n        [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>]\n    ];\n    <span class=\"hljs-keyword\">const</span> kernelWeight = <span class=\"hljs-number\">16</span>;\n    <span class=\"hljs-keyword\">const</span> blurredData = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Uint8ClampedArray</span>(width * height * <span class=\"hljs-number\">4</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">1</span>; y &#x3C; height - <span class=\"hljs-number\">1</span>; y++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">1</span>; x &#x3C; width - <span class=\"hljs-number\">1</span>; x++) {\n            <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-keyword\">let</span> sumAlpha = <span class=\"hljs-number\">0</span>;\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> cy = -<span class=\"hljs-number\">1</span>; cy &#x3C;= <span class=\"hljs-number\">1</span>; cy++) {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> cx = -<span class=\"hljs-number\">1</span>; cx &#x3C;= <span class=\"hljs-number\">1</span>; cx++) {\n                    <span class=\"hljs-keyword\">const</span> pixel = ((y + cy) * width + (x + cx)) * <span class=\"hljs-number\">4</span>;\n                    <span class=\"hljs-keyword\">const</span> weight = kernel[cy + <span class=\"hljs-number\">1</span>][cx + <span class=\"hljs-number\">1</span>];\n                    sum += data[pixel] * weight;\n                    sumAlpha += data[pixel + <span class=\"hljs-number\">3</span>];\n                }\n            }\n\n            <span class=\"hljs-keyword\">const</span> pixelIndex = (y * width + x) * <span class=\"hljs-number\">4</span>;\n            blurredData[pixelIndex] = sum / kernelWeight;\n            blurredData[pixelIndex + <span class=\"hljs-number\">1</span>] = sum / kernelWeight;\n            blurredData[pixelIndex + <span class=\"hljs-number\">2</span>] = sum / kernelWeight;\n            blurredData[pixelIndex + <span class=\"hljs-number\">3</span>] = sumAlpha / kernelWeight;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> blurredData;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">cannyFilter</span>(<span class=\"hljs-params\">data, width, height</span>) {\n    <span class=\"hljs-comment\">// Simplified Canny edge detection</span>\n    <span class=\"hljs-keyword\">const</span> sobelData = <span class=\"hljs-title function_\">sobelFilter</span>(data, width, height);\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Uint8ClampedArray</span>(width * height * <span class=\"hljs-number\">4</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; sobelData.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">4</span>) {\n        <span class=\"hljs-keyword\">const</span> magnitude = sobelData[i];\n        <span class=\"hljs-keyword\">if</span> (magnitude > <span class=\"hljs-number\">50</span>) {\n            result[i] = result[i + <span class=\"hljs-number\">1</span>] = result[i + <span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">255</span>; <span class=\"hljs-comment\">// white</span>\n            result[i + <span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">255</span>; <span class=\"hljs-comment\">// alpha</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            result[i] = result[i + <span class=\"hljs-number\">1</span>] = result[i + <span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// black</span>\n            result[i + <span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">255</span>; <span class=\"hljs-comment\">// alpha</span>\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> result;\n}\n</code></pre>\n<h2>결론</h2>\n<p>이 프로젝트는 간단한 웹 기술을 사용하여 얼마나 많은 작업을 수행할 수 있는지를 상기시켜주는 것이었습니다. HTML5, JavaScript 및 최신 웹 기술을 사용하면 비디오 스트림을 실시간으로 프레임별로 처리할 수 있습니다.</p>\n<p>이를 통해 재미있는 경험을 할 수 있기를 바라며, 웹 기술 선택에 대한 의견을 주시면 감사하겠습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}