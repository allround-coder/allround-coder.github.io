{"pageProps":{"post":{"title":"React에서 네비게이션 이벤트를 모의하고 테스트하는 방법 Vitest","description":"","date":"2024-05-14 11:50","slug":"2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest","content":"\n\n리액트 페이지 탐색 이벤트를 테스트하고 싶어서 노력 중이었는데, 가져온 모듈 함수를 MOCK 하는 것이 필요해 전혀 익숙하지 않았어요. \n\n마침내 어떻게 해결했는지 공유하고 싶어요. 물론, 이 예제는 정교하거나 높은 자격 요건을 갖춘 것은 아니라서 여러분의 생각과 추천 대안을 공유해주시면 정말 감사하겠어요. 이 글이 몇몇 독자들에게 도움이 되었으면 좋겠어요.\n\n** 이 문서는 테스트 환경 설정에 대한 내용을 다루지 않고 직접 내용으로 들어갑니다.\n\n## 무엇을 테스트할 것인가\n\n\n\n리액트 애플리케이션이 두 가지 접근 가능한 경로, /와 /todos를 가지고 있습니다. StartPage.test.tsx 파일은 홈 경로에 대한 유닛 테스트 파일이며, \"todos\" 텍스트를 가진 버튼이 클릭되었을 때 애플리케이션이 사용자를 /todos 페이지로 이동시키는지 테스트하고 싶습니다.\n\n## 문제 발생\n\n하지만 테스트 라이브러리 관점에서 이야기를 해보겠습니다. \"사용자를 다른 페이지로 이동시킨다\"는 것의 의미는 무엇인가요?\n\n```js\nimport useNavigation from \"@hooks/useNavigation\";\n\nexport default function StartPage() {\n  const { push } = useNavigation();\n  return (\n    <div>\n      <h1>start</h1>\n      <button\n        onClick={() => {\n          push(\"/todos\");\n        }\n      >\n        todos\n      </button>\n    </div>\n  );\n}\n```\n\n\n\n사용자가 \"todos\" 버튼을 클릭하면, onclick 핸들러가 실행되고, 그런 다음 push 함수가 실행됩니다. push 함수는 useNavigation 훅 호출에서 반환된 함수 중 하나입니다. 문제는 테스트 코드가 push 또는 useNavigation이 어떻게 구성되어 있는지를 모르기 때문에, 테스트 함수에 이 함수들이 어떻게 되어야 하는지 알려주어야 합니다. 이 과정을 함수 모의(mocking functions)라고 합니다.\n\n## `MemoryRouter` 내부의 단위\n\n테스트 함수를 작성하기 전에, 테스트된 컴포넌트가 react-router-dom의 Router 내에 있어야 한다는 점을 명확히해야 합니다. 그렇지 않으면 여러 경로가 없을 수 있고, 컴포넌트 함수에서 useNavigation 훅을 사용할 수 없습니다. 이 문제는 단위 컴포넌트를 react-router-dom의 `MemoryRouter` 컴포넌트로 감싸면 쉽게 처리할 수 있습니다. Router에 initialEntries prop을 제공하여 애플리케이션의 위치를 지정할 수 있습니다.\n\n```js\n// ...\n\nbeforeEach(() => {\n   render(<StartPage />, {\n    wrapper: ({children}) => (\n      <MemoryRouter initialEntries={[\"/\"]}>\n        {children}\n      </MemoryRouter>\n    ),\n  });\n});\n\n// ...\n```\n\n\n\n## 목 역할 하는 방법\n\n테스트 작업 환경인 jest와 비슷한 기능을 가진 vitest는 jest testing 환경의 vi 속성을 제공하여 변수와 함수를 mock할 수 있습니다. vi.fn 메소드는 \"함수를 스파이로 생성\"하고, vi.mock 메소드는 첫 번째 인수로 지정된 경로에서 import된 모든 모듈을 대체합니다.\n\n```js\nimport { vi } from \"vitest\";\n\nconst mockPush = vi.fn();\n\nvi.mock(\"@hooks/useNavigation\", () => {\n  return {\n    // useNavigation\n    default: () => ({\n      push: mockPush,\n    }),\n  };\n});\n```\n\n위의 예시에서 vi.mock은 \"@hooks/useNavigation\" 경로에서 import된 모듈의 형태를 정의합니다. 이 모듈은 \"push\"라는 함수를 반환하는 기본 내보내기를 가지고 있습니다. 이제 모듈의 구조가 알려졌으며, 테스트 함수 내에서 스파이 변수인 mockPush를 사용하여 push 메소드에 접근할 수 있습니다. 이 모킹된 함수가 호출될 때 어떤 인수와 함께 호출되었는지 mockPush.mock.calls 또는 mockPush.mock.lastCall을 사용하여 확인할 수 있습니다. 이는 인수 목록을 제공합니다.\n\n\n\n```js\ntest(\"버튼 클릭 시 /todos 페이지로 이동해야 함\", async () => {\n  const button = (await screen.findAllByText(\"todos\"))[0];\n  expect(button).toBeDefined();\n  await userEvent.click(button);\n\n  console.log(\"호출\", mockPush.mock.calls);\n  // calls [ [ '/todos' ] ]\n  console.log(\"마지막 호출\", mockPush.mock.lastCall);\n  // last call [ '/todos' ]\n});\n```\n\n여기서 만약 lastCall의 첫 번째 항목이 \"/todos\"이면, \"todos\" 버튼 클릭 이벤트의 예상 결과로써 push 메소드가 \"/todos\" 인자와 함께 호출된 것이라고 말할 수 있습니다.\n\n```js\ntest(\"버튼 클릭 시 /todos 페이지로 이동해야 함\", async () => {\n  const button = (await screen.findAllByText(\"todos\"))[0];\n  expect(button).toBeDefined();\n  await userEvent.click(button);\n\n  expect(mockPush.mock.lastCall[0]).toEqual(\"/todos\");\n});\n```\n\n마지막으로, 각 테스트 후에 mock 기록을 제거하기 위해 vi.clearAllMocks 메소드를 호출하는 것이 좋습니다.\n\n\n\n```js\nconst mockPush = vi.fn();\n\nvi.mock(\"@hooks/useNavigation\", () => {\n  return {\n    // useNavigation\n    default: () => ({\n      push: mockPush,\n    }),\n  };\n});\n\ndescribe(\"start page test\", () => {\n  beforeEach(() => {\n    render(<StartPage />, {\n      wrapper: ({children}) => (\n        <MemoryRouter initialEntries={[\"/\"]}>\n          {children}\n        </MemoryRouter>\n      ),\n    });\n  });\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  test(\"should navigate to /todos page on button click\", async () => {\n    const button = (await screen.findAllByText(\"todos\"))[0];\n    expect(button).toBeDefined();\n    await userEvent.click(button);\n\n    expect(mockPush.mock.lastCall[0]).toEqual(\"/todos\");\n  });\n});\n```","ogImage":{"url":"/assets/img/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest_0.png"},"coverImage":"/assets/img/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>리액트 페이지 탐색 이벤트를 테스트하고 싶어서 노력 중이었는데, 가져온 모듈 함수를 MOCK 하는 것이 필요해 전혀 익숙하지 않았어요.</p>\n<p>마침내 어떻게 해결했는지 공유하고 싶어요. 물론, 이 예제는 정교하거나 높은 자격 요건을 갖춘 것은 아니라서 여러분의 생각과 추천 대안을 공유해주시면 정말 감사하겠어요. 이 글이 몇몇 독자들에게 도움이 되었으면 좋겠어요.</p>\n<p>** 이 문서는 테스트 환경 설정에 대한 내용을 다루지 않고 직접 내용으로 들어갑니다.</p>\n<h2>무엇을 테스트할 것인가</h2>\n<p>리액트 애플리케이션이 두 가지 접근 가능한 경로, /와 /todos를 가지고 있습니다. StartPage.test.tsx 파일은 홈 경로에 대한 유닛 테스트 파일이며, \"todos\" 텍스트를 가진 버튼이 클릭되었을 때 애플리케이션이 사용자를 /todos 페이지로 이동시키는지 테스트하고 싶습니다.</p>\n<h2>문제 발생</h2>\n<p>하지만 테스트 라이브러리 관점에서 이야기를 해보겠습니다. \"사용자를 다른 페이지로 이동시킨다\"는 것의 의미는 무엇인가요?</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> useNavigation <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@hooks/useNavigation\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">StartPage</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> { push } = <span class=\"hljs-title function_\">useNavigation</span>();\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>start<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> {\n          push(\"/todos\");\n        }\n      >\n        todos\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n</code></pre>\n<p>사용자가 \"todos\" 버튼을 클릭하면, onclick 핸들러가 실행되고, 그런 다음 push 함수가 실행됩니다. push 함수는 useNavigation 훅 호출에서 반환된 함수 중 하나입니다. 문제는 테스트 코드가 push 또는 useNavigation이 어떻게 구성되어 있는지를 모르기 때문에, 테스트 함수에 이 함수들이 어떻게 되어야 하는지 알려주어야 합니다. 이 과정을 함수 모의(mocking functions)라고 합니다.</p>\n<h2><code>MemoryRouter</code> 내부의 단위</h2>\n<p>테스트 함수를 작성하기 전에, 테스트된 컴포넌트가 react-router-dom의 Router 내에 있어야 한다는 점을 명확히해야 합니다. 그렇지 않으면 여러 경로가 없을 수 있고, 컴포넌트 함수에서 useNavigation 훅을 사용할 수 없습니다. 이 문제는 단위 컴포넌트를 react-router-dom의 <code>MemoryRouter</code> 컴포넌트로 감싸면 쉽게 처리할 수 있습니다. Router에 initialEntries prop을 제공하여 애플리케이션의 위치를 지정할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-title function_\">beforeEach</span>(<span class=\"hljs-function\">() =></span> {\n   <span class=\"hljs-title function_\">render</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">StartPage</span> /></span></span>, {\n    <span class=\"hljs-attr\">wrapper</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{children}</span>) =></span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MemoryRouter</span> <span class=\"hljs-attr\">initialEntries</span>=<span class=\"hljs-string\">{[</span>\"/\"]}></span>\n        {children}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">MemoryRouter</span>></span></span>\n    ),\n  });\n});\n\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<h2>목 역할 하는 방법</h2>\n<p>테스트 작업 환경인 jest와 비슷한 기능을 가진 vitest는 jest testing 환경의 vi 속성을 제공하여 변수와 함수를 mock할 수 있습니다. vi.fn 메소드는 \"함수를 스파이로 생성\"하고, vi.mock 메소드는 첫 번째 인수로 지정된 경로에서 import된 모든 모듈을 대체합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"vitest\"</span>;\n\n<span class=\"hljs-keyword\">const</span> mockPush = vi.<span class=\"hljs-title function_\">fn</span>();\n\nvi.<span class=\"hljs-title function_\">mock</span>(<span class=\"hljs-string\">\"@hooks/useNavigation\"</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-comment\">// useNavigation</span>\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =></span> ({\n      <span class=\"hljs-attr\">push</span>: mockPush,\n    }),\n  };\n});\n</code></pre>\n<p>위의 예시에서 vi.mock은 \"@hooks/useNavigation\" 경로에서 import된 모듈의 형태를 정의합니다. 이 모듈은 \"push\"라는 함수를 반환하는 기본 내보내기를 가지고 있습니다. 이제 모듈의 구조가 알려졌으며, 테스트 함수 내에서 스파이 변수인 mockPush를 사용하여 push 메소드에 접근할 수 있습니다. 이 모킹된 함수가 호출될 때 어떤 인수와 함께 호출되었는지 mockPush.mock.calls 또는 mockPush.mock.lastCall을 사용하여 확인할 수 있습니다. 이는 인수 목록을 제공합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">\"버튼 클릭 시 /todos 페이지로 이동해야 함\"</span>, <span class=\"hljs-keyword\">async</span> () => {\n  <span class=\"hljs-keyword\">const</span> button = (<span class=\"hljs-keyword\">await</span> screen.<span class=\"hljs-title function_\">findAllByText</span>(<span class=\"hljs-string\">\"todos\"</span>))[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-title function_\">expect</span>(button).<span class=\"hljs-title function_\">toBeDefined</span>();\n  <span class=\"hljs-keyword\">await</span> userEvent.<span class=\"hljs-title function_\">click</span>(button);\n\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"호출\"</span>, mockPush.<span class=\"hljs-property\">mock</span>.<span class=\"hljs-property\">calls</span>);\n  <span class=\"hljs-comment\">// calls [ [ '/todos' ] ]</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"마지막 호출\"</span>, mockPush.<span class=\"hljs-property\">mock</span>.<span class=\"hljs-property\">lastCall</span>);\n  <span class=\"hljs-comment\">// last call [ '/todos' ]</span>\n});\n</code></pre>\n<p>여기서 만약 lastCall의 첫 번째 항목이 \"/todos\"이면, \"todos\" 버튼 클릭 이벤트의 예상 결과로써 push 메소드가 \"/todos\" 인자와 함께 호출된 것이라고 말할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">\"버튼 클릭 시 /todos 페이지로 이동해야 함\"</span>, <span class=\"hljs-keyword\">async</span> () => {\n  <span class=\"hljs-keyword\">const</span> button = (<span class=\"hljs-keyword\">await</span> screen.<span class=\"hljs-title function_\">findAllByText</span>(<span class=\"hljs-string\">\"todos\"</span>))[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-title function_\">expect</span>(button).<span class=\"hljs-title function_\">toBeDefined</span>();\n  <span class=\"hljs-keyword\">await</span> userEvent.<span class=\"hljs-title function_\">click</span>(button);\n\n  <span class=\"hljs-title function_\">expect</span>(mockPush.<span class=\"hljs-property\">mock</span>.<span class=\"hljs-property\">lastCall</span>[<span class=\"hljs-number\">0</span>]).<span class=\"hljs-title function_\">toEqual</span>(<span class=\"hljs-string\">\"/todos\"</span>);\n});\n</code></pre>\n<p>마지막으로, 각 테스트 후에 mock 기록을 제거하기 위해 vi.clearAllMocks 메소드를 호출하는 것이 좋습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> mockPush = vi.<span class=\"hljs-title function_\">fn</span>();\n\nvi.<span class=\"hljs-title function_\">mock</span>(<span class=\"hljs-string\">\"@hooks/useNavigation\"</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-comment\">// useNavigation</span>\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\">() =></span> ({\n      <span class=\"hljs-attr\">push</span>: mockPush,\n    }),\n  };\n});\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">\"start page test\"</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-title function_\">beforeEach</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">render</span>(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">StartPage</span> /></span></span>, {\n      <span class=\"hljs-attr\">wrapper</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{children}</span>) =></span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MemoryRouter</span> <span class=\"hljs-attr\">initialEntries</span>=<span class=\"hljs-string\">{[</span>\"/\"]}></span>\n          {children}\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">MemoryRouter</span>></span></span>\n      ),\n    });\n  });\n  <span class=\"hljs-title function_\">afterEach</span>(<span class=\"hljs-function\">() =></span> {\n    vi.<span class=\"hljs-title function_\">clearAllMocks</span>();\n  });\n\n  <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">\"should navigate to /todos page on button click\"</span>, <span class=\"hljs-keyword\">async</span> () => {\n    <span class=\"hljs-keyword\">const</span> button = (<span class=\"hljs-keyword\">await</span> screen.<span class=\"hljs-title function_\">findAllByText</span>(<span class=\"hljs-string\">\"todos\"</span>))[<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-title function_\">expect</span>(button).<span class=\"hljs-title function_\">toBeDefined</span>();\n    <span class=\"hljs-keyword\">await</span> userEvent.<span class=\"hljs-title function_\">click</span>(button);\n\n    <span class=\"hljs-title function_\">expect</span>(mockPush.<span class=\"hljs-property\">mock</span>.<span class=\"hljs-property\">lastCall</span>[<span class=\"hljs-number\">0</span>]).<span class=\"hljs-title function_\">toEqual</span>(<span class=\"hljs-string\">\"/todos\"</span>);\n  });\n});\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}