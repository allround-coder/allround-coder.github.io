{"pageProps":{"post":{"title":"리액트 컴파일러가 거의 다 왔어요 정말 기대돼요","description":"","date":"2024-06-20 01:32","slug":"2024-06-20-ReactCompilerisalmosthereanditisExciting","content":"\n\nMeet Jay, he is a budding Frontend Engineer and has been working with React for a few months. Recently, he raised a Pull Request where he is fetching a list of todos and displaying it on the UI —\n\n![image](/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png)\n\nBut Wait… His PR does not get approved!\n\n![image](/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_1.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_2.png\" />\n\n만나요! Ray는 프론트엔드 리드입니다. 그는 그의 경험을 바탕으로 Jay가 할 일 목록을 조작하고 있고 이 목록이 매우 커질 수 있다는 것을 알아챘어요 (10,000개 이상). 그래서 그는 Jay에게 React에서 제공하는 훅을 사용하여 함수를 메모이즈하는 것을 권유했어요. 그렇게 하면 의존성(dependencies)이 변경될 때에만 함수가 호출되도록 할 수 있어요. 우리가 이야기하고 있는 훅은 useMemo()입니다.\n\n<img src=\"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_3.png\" />\n\nJay는 Ray의 조언을 따라 했지만, 여기서 몇 가지 더 코멘트가 있어요. 어떤 경우에는 여러 개의 콜백이 자식 컴포넌트로 전달되고 있어요. Ray는 Jay에게 useCallback()을 사용하여 이러한 함수들의 참조(reference)를 보존하여 각 리렌더링마다 자식 컴포넌트를 메모이즈하고 그들의 리렌더링을 멈출 수 있도록 하는 것을 요청했어요.\n\n<div class=\"content-ad\"></div>\n\n작업의 반은 끝났어요! 이제 비싼 자식 구성 요소들을 memo() 훅으로 감싸서 다시 렌더링을 막아야 해요.\n\n마음을 바꿔보면, 팀은 이 문제가 손에 잡히질 않아서 지금까지 위 훅들을 사용하여 오버엔지니어링을 한 부분이 많은 것 같아요. 실제로 성능 문제가 크게 발생한 것은 아니었는데, 누군가가 이런 베스트 프랙티스를 읽고, 성능을 분석하지 않고 사용해버린 결과이죠.\n\n어쨌든, 이런 대화와 React 앱을 더 최적화하기 위해 이러한 매개변수들을 추가하는 머릿 속 부담감은 피곤하고 React의 본래 이념과는 거리가 있는데요 -\n\nUI는 상태의 함수입니다... 확실히 이게 더 세밀하고 복잡한 문제이고, 우리는 방금 목격한 것처럼 말이죠.\n\n<div class=\"content-ad\"></div>\n\n하지만 여기에는 🚀 즉, REACT 컴파일러가 등장합니다\n\n# 2막 — REACT 컴파일러 소개\n\nReact 컴파일러는 React가 개발자 경험을 향상시키기 위해 가져오는 미래 기술입니다. 이름보다는 다소 온화해 보일 수 있지만, 이것은 게임 체인저입니다.\n\n컴파일러 뒤에 숨은 아이디어는 대부분의 메모이제이션 논리를 React에게 위임하고 과도하게 복잡한 useMemo 및 useCallback 훅을 줄여서 코드베이스를 가독성 있게 만드는 것입니다. 이러한 훅들의 종속성은 많은 사람들에게 고통의 요점이기도 합니다.\n\n<div class=\"content-ad\"></div>\n\n리액트에서 이와 같은 지원을 받기 위한 작업은 상당한 시간동안 진행되어 왔습니다. 2021년 Xuan의 이번 토크를 확인해보세요 —\n\n다음은 간단한 카운터 예제인 다음 코드 조각을 고려해 봅시다 —\n\n```js\nexport default function Counter({initialCount}) {\n  const [count, setCount] = useState(initialCount);\n\n  return (\n    <>\n      <div className=\"flex gap-1 justify-center items-center\">\n        <button\n          onClick={() => {\n            setCount(count + 1);\n          }\n        >\n          +\n        </button>\n      </div>\n\n      <span>\n        {count}\n      </span>\n    </>\n  );\n}\n```\n\n리액트 컴파일러에 의해 컴파일된 이 코드를 사용하여 상황을 확인할 수도 있습니다 —\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction Counter(t0) {\n  const $ = _c(2);\n\n  const { initialCount } = t0;\n  const [count, setCount] = useState(initialCount);\n  let t1;\n\n  if ($[0] !== count) {\n    t1 = (\n      <>\n        <div className=\"flex gap-1 justify-center items-center\">\n          <button\n            onClick={() => {\n              setCount(count + 1);\n            }\n          >\n            +\n          </button>\n        </div>\n        <span>{count}</span>\n      </>\n    );\n    $[0] = count;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n\n  return t1;\n}\n```\n\n여기서 $는 props, state 및 다른 반응적인 정보의 데이터를 보관하는 변수이며, 잠재적인 다시 렌더링에서 비교하고 부모 구성 요소 또는 상태 변경이 있을 때, 그 정보가 변경된 것이 없다면... 바로! 컴포넌트 다시 렌더링이 저장됩니다!\n\n_c는 여기에서 실제 리액트 컴파일러 훅이며 useMemoCache()라고도 불리며 우리가 보았던 바와 같이 useMemo() 네이티브 훅과는 다르게 작동합니다.\n\n그래서 간단히 말해서, Dan Abramov의 말로 하면, 리액트 컴파일러는 본질적으로 이것입니다 —\n\n\n<div class=\"content-ad\"></div>\n\n```js\nlet jsx;\n\nif(prevCount != count){\n  jsx = ...\n} else {\n  jsx = prevJsx;\n}\n```\n\n아래는 이것이 큰 개선될 상황 몇 가지 예시입니다 —\n\n- 우리는 DOM 노드의 tree, 즉 React Fiber 또는 Virtual DOM을 알고 있습니다. 부모 컴포넌트가 렌더링될 때 전체 서브트리/자식 컴포넌트가 다시 렌더링 됩니다. React 컴파일러는 변경 사항이 없는 경우 그것을 회피해주고, 의존할 props가 없더라도 도움을 줄 것입니다.\n- useMemo() 훅의 경우 대부분의 경우에는 필요하지 않을 것이며, React 컴파일러가 적절하게 캐싱을 할 수 없는 경우에만 필요할 것입니다. 이 경우 오리지널 컴파일러 구현체로 되돌아갈 것입니다. 이를 잘못 사용했을 때 useMemo() 훅의 예시가 될 수 있습니다.\n\n# 제 ACT III: 지나치게 복잡한 최적화가 끝나는 시작\n\n\n<div class=\"content-ad\"></div>\n\n드디어 React에도 다른 대부분의 라이브러리에서 사용하던 컴파일러가 도입되고 있습니다. 이로 인해 날이 갈수록 React 코드를 작성할 때 \"만약 이 부분이 변경된다면?\", \"이 함수가 성능에 해를 끼칠까?\"라는 걱정을 덜어내고 코드를 작성할 수 있게 되었습니다.\n\nReact 팀에게 👏 이를 위해 수년간 반복적이고 꾸준한 노력을 기욯 합니다. 재미있는 사실: 컴파일러를 도입하고자 한 목표가 후크(hook)와 서버 컴포넌트(Server components)를 탄생시켰습니다.\n\n컴포넌트를 이주할 준비가 되어 있는지 확인하려면 추천사항은 아니지만 React 팀의 React 컴파일러 소개 페이지(https://react.dev/learn/react-compiler#existing-projects)를 참조할 수 있습니다. 더 깊이 살펴볼 수 있는 유용한 리소스 몇 가지를 소개해 드리겠습니다 -\n- https://www.youtube.com/watch?v=PYHBHK37xlE\n- https://jherr2020.medium.com/react-compiler-with-react-18-1e39f60ae71a\n- https://www.youtube.com/watch?v=wnXGSwrOw80\n- https://www.youtube.com/watch?v=0ckOUBiuxVY&t=9311s [React 컴파일러 부분을 확인할 수 있습니다]","ogImage":{"url":"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png"},"coverImage":"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>Meet Jay, he is a budding Frontend Engineer and has been working with React for a few months. Recently, he raised a Pull Request where he is fetching a list of todos and displaying it on the UI —</p>\n<p><img src=\"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png\" alt=\"image\"></p>\n<p>But Wait… His PR does not get approved!</p>\n<p><img src=\"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_1.png\" alt=\"image\"></p>\n<p>만나요! Ray는 프론트엔드 리드입니다. 그는 그의 경험을 바탕으로 Jay가 할 일 목록을 조작하고 있고 이 목록이 매우 커질 수 있다는 것을 알아챘어요 (10,000개 이상). 그래서 그는 Jay에게 React에서 제공하는 훅을 사용하여 함수를 메모이즈하는 것을 권유했어요. 그렇게 하면 의존성(dependencies)이 변경될 때에만 함수가 호출되도록 할 수 있어요. 우리가 이야기하고 있는 훅은 useMemo()입니다.</p>\n<p>Jay는 Ray의 조언을 따라 했지만, 여기서 몇 가지 더 코멘트가 있어요. 어떤 경우에는 여러 개의 콜백이 자식 컴포넌트로 전달되고 있어요. Ray는 Jay에게 useCallback()을 사용하여 이러한 함수들의 참조(reference)를 보존하여 각 리렌더링마다 자식 컴포넌트를 메모이즈하고 그들의 리렌더링을 멈출 수 있도록 하는 것을 요청했어요.</p>\n<p>작업의 반은 끝났어요! 이제 비싼 자식 구성 요소들을 memo() 훅으로 감싸서 다시 렌더링을 막아야 해요.</p>\n<p>마음을 바꿔보면, 팀은 이 문제가 손에 잡히질 않아서 지금까지 위 훅들을 사용하여 오버엔지니어링을 한 부분이 많은 것 같아요. 실제로 성능 문제가 크게 발생한 것은 아니었는데, 누군가가 이런 베스트 프랙티스를 읽고, 성능을 분석하지 않고 사용해버린 결과이죠.</p>\n<p>어쨌든, 이런 대화와 React 앱을 더 최적화하기 위해 이러한 매개변수들을 추가하는 머릿 속 부담감은 피곤하고 React의 본래 이념과는 거리가 있는데요 -</p>\n<p>UI는 상태의 함수입니다... 확실히 이게 더 세밀하고 복잡한 문제이고, 우리는 방금 목격한 것처럼 말이죠.</p>\n<p>하지만 여기에는 🚀 즉, REACT 컴파일러가 등장합니다</p>\n<h1>2막 — REACT 컴파일러 소개</h1>\n<p>React 컴파일러는 React가 개발자 경험을 향상시키기 위해 가져오는 미래 기술입니다. 이름보다는 다소 온화해 보일 수 있지만, 이것은 게임 체인저입니다.</p>\n<p>컴파일러 뒤에 숨은 아이디어는 대부분의 메모이제이션 논리를 React에게 위임하고 과도하게 복잡한 useMemo 및 useCallback 훅을 줄여서 코드베이스를 가독성 있게 만드는 것입니다. 이러한 훅들의 종속성은 많은 사람들에게 고통의 요점이기도 합니다.</p>\n<p>리액트에서 이와 같은 지원을 받기 위한 작업은 상당한 시간동안 진행되어 왔습니다. 2021년 Xuan의 이번 토크를 확인해보세요 —</p>\n<p>다음은 간단한 카운터 예제인 다음 코드 조각을 고려해 봅시다 —</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Counter</span>(<span class=\"hljs-params\">{initialCount}</span>) {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(initialCount);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"flex gap-1 justify-center items-center\"</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n          <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> {\n            setCount(count + 1);\n          }\n        >\n          +\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">span</span>></span>\n        {count}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">span</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n}\n</code></pre>\n<p>리액트 컴파일러에 의해 컴파일된 이 코드를 사용하여 상황을 확인할 수도 있습니다 —</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Counter</span>(<span class=\"hljs-params\">t0</span>) {\n  <span class=\"hljs-keyword\">const</span> $ = <span class=\"hljs-title function_\">_c</span>(<span class=\"hljs-number\">2</span>);\n\n  <span class=\"hljs-keyword\">const</span> { initialCount } = t0;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(initialCount);\n  <span class=\"hljs-keyword\">let</span> t1;\n\n  <span class=\"hljs-keyword\">if</span> ($[<span class=\"hljs-number\">0</span>] !== count) {\n    t1 = (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"flex gap-1 justify-center items-center\"</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n            <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> {\n              setCount(count + 1);\n            }\n          >\n            +\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">span</span>></span>{count}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">span</span>></span>\n      <span class=\"hljs-tag\">&#x3C;/></span></span>\n    );\n    $[<span class=\"hljs-number\">0</span>] = count;\n    $[<span class=\"hljs-number\">1</span>] = t1;\n  } <span class=\"hljs-keyword\">else</span> {\n    t1 = $[<span class=\"hljs-number\">1</span>];\n  }\n\n  <span class=\"hljs-keyword\">return</span> t1;\n}\n</code></pre>\n<p>여기서 $는 props, state 및 다른 반응적인 정보의 데이터를 보관하는 변수이며, 잠재적인 다시 렌더링에서 비교하고 부모 구성 요소 또는 상태 변경이 있을 때, 그 정보가 변경된 것이 없다면... 바로! 컴포넌트 다시 렌더링이 저장됩니다!</p>\n<p>_c는 여기에서 실제 리액트 컴파일러 훅이며 useMemoCache()라고도 불리며 우리가 보았던 바와 같이 useMemo() 네이티브 훅과는 다르게 작동합니다.</p>\n<p>그래서 간단히 말해서, Dan Abramov의 말로 하면, 리액트 컴파일러는 본질적으로 이것입니다 —</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> jsx;\n\n<span class=\"hljs-keyword\">if</span>(prevCount != count){\n  jsx = ...\n} <span class=\"hljs-keyword\">else</span> {\n  jsx = prevJsx;\n}\n</code></pre>\n<p>아래는 이것이 큰 개선될 상황 몇 가지 예시입니다 —</p>\n<ul>\n<li>우리는 DOM 노드의 tree, 즉 React Fiber 또는 Virtual DOM을 알고 있습니다. 부모 컴포넌트가 렌더링될 때 전체 서브트리/자식 컴포넌트가 다시 렌더링 됩니다. React 컴파일러는 변경 사항이 없는 경우 그것을 회피해주고, 의존할 props가 없더라도 도움을 줄 것입니다.</li>\n<li>useMemo() 훅의 경우 대부분의 경우에는 필요하지 않을 것이며, React 컴파일러가 적절하게 캐싱을 할 수 없는 경우에만 필요할 것입니다. 이 경우 오리지널 컴파일러 구현체로 되돌아갈 것입니다. 이를 잘못 사용했을 때 useMemo() 훅의 예시가 될 수 있습니다.</li>\n</ul>\n<h1>제 ACT III: 지나치게 복잡한 최적화가 끝나는 시작</h1>\n<p>드디어 React에도 다른 대부분의 라이브러리에서 사용하던 컴파일러가 도입되고 있습니다. 이로 인해 날이 갈수록 React 코드를 작성할 때 \"만약 이 부분이 변경된다면?\", \"이 함수가 성능에 해를 끼칠까?\"라는 걱정을 덜어내고 코드를 작성할 수 있게 되었습니다.</p>\n<p>React 팀에게 👏 이를 위해 수년간 반복적이고 꾸준한 노력을 기욯 합니다. 재미있는 사실: 컴파일러를 도입하고자 한 목표가 후크(hook)와 서버 컴포넌트(Server components)를 탄생시켰습니다.</p>\n<p>컴포넌트를 이주할 준비가 되어 있는지 확인하려면 추천사항은 아니지만 React 팀의 React 컴파일러 소개 페이지(<a href=\"https://react.dev/learn/react-compiler#existing-projects)%EB%A5%BC\" rel=\"nofollow\" target=\"_blank\">https://react.dev/learn/react-compiler#existing-projects)를</a> 참조할 수 있습니다. 더 깊이 살펴볼 수 있는 유용한 리소스 몇 가지를 소개해 드리겠습니다 -</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=PYHBHK37xlE\" rel=\"nofollow\" target=\"_blank\">https://www.youtube.com/watch?v=PYHBHK37xlE</a></li>\n<li><a href=\"https://jherr2020.medium.com/react-compiler-with-react-18-1e39f60ae71a\" rel=\"nofollow\" target=\"_blank\">https://jherr2020.medium.com/react-compiler-with-react-18-1e39f60ae71a</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=wnXGSwrOw80\" rel=\"nofollow\" target=\"_blank\">https://www.youtube.com/watch?v=wnXGSwrOw80</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=0ckOUBiuxVY&#x26;t=9311s\" rel=\"nofollow\" target=\"_blank\">https://www.youtube.com/watch?v=0ckOUBiuxVY&#x26;t=9311s</a> [React 컴파일러 부분을 확인할 수 있습니다]</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}