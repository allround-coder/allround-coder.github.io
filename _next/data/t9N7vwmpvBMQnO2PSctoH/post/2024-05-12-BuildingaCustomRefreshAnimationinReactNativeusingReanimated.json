{"pageProps":{"post":{"title":"리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기","description":"","date":"2024-05-12 21:21","slug":"2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated","content":"\n\n## 간단한 애니메이션이 앱의 사용자 경험을 얼마나 높일 수 있는지 궁금했던 적이 있나요?\n\n잘 디자인된 애니메이션은 평범한 사용자 상호 작용을 진정으로 기억에 남는 경험으로 변화시킬 수 있습니다.\n\n이 포스트에서는 React Native와 Reanimated 라이브러리를 사용하여 모바일 앱에 맞춘 흥미로운 사용자 정의 '당겨서 새로고침' 애니메이션을 만드는 방법을 배우게 됩니다.\n\n## 그냥 React Native의 RefreshControl을 사용하는 것이 좋지 않을까요?\n\n\n\n리액트 네이티브로 모바일 애플리케이션을 개발할 때, Pull-to-refresh 기능을 구현하는 데 RefreshControl 컴포넌트를 주로 사용합니다.\n\n간단하고 직관적이지만, 꽤 기본적이며 제한된 사용자 정의 기능을 제공합니다. 이로 인해 여러분의 앱이 그저 다른 어떤 앱처럼 보이는 경우가 있을 수 있습니다.\n\n사용자 정의 애니메이션을 생성하면 앱의 모양과 느낌을 자유롭게 조절하여 브랜딩 및 디자인 언어와 완벽하게 일치시킬 수 있습니다. 이로써 앱이 더 독특하고 기억에 남는 사용자 경험을 제공하게 되어 앱이 더욱 독특하고 기억에 남게 만듭니다.\n\n## 왜 Animated가 아닌 Reanimated 라이브러리를 사용해야 하는가?\n\n\n\nReact Native에서 애니메이션에 관한 이야기가 나온다면, 두 가지 주요 라이브러리가 떠오르게 됩니다: 내장된 Animated 라이브러리와 더 고급화된 Reanimated 라이브러리가 있습니다.\n\nReanimated가 선호되는 이유는 몇 가지가 있습니다:\n\n- 성능:\nReanimated는 특히 복잡한 애니메이션에 대해 우수한 성능을 제공합니다. 네이티브 스레드를 활용하여 JavaScript 스레드 대신 작동함으로써 더 효율적으로 작동합니다. 이는 훨씬 부드러운 애니메이션을 가능하게 하며, 이는 원활한 사용자 경험을 위한 중요한 요소입니다.\n- 제스처 기반 애니메이션:\nReanimated는 더 복잡한 애니메이션 처리를 위한 더 나은 API를 제공하며, 제스처와 애니메이션의 더 섬세한 제어와 더 부드러운 통합을 가능케 합니다.\n- 선언적 접근: Animated와 달리, Reanimated는 애니메이션에 더 선언적인 접근 방식을 채용합니다. 이는 애니메이션이 더 복잡해지면서 이해하고 관리하기 쉬워집니다.\n\n# 시작하기\n\n\n\n이 튜토리얼에서는 간단한 앱을 향상시키고자 합니다. 이 앱은 FlatList에서 카드 형태로 표시되는 Dribbble 샷 목록을 보여줍니다. 우리의 목표는 사용자가 목록을 위로 당겼을 때 나타나는 사용자 정의 새로 고침 애니메이션을 추가하는 것입니다.\n\n## 프로젝트 복제 및 설정\n\n로컬 컴퓨터에서 저장소를 클론하고 프로젝트를 설정하기 위해 다음 단계를 따라주세요:\n\n저장소 복제:\n터미널을 열고 다음 명령어로 저장소를 클론하세요:\n\n\n\n```js\ngit clone https://github.com/teefouad/custom-rn-refresh-animation-start.git\n```\n\nVSCode에서 프로젝트 열기:\n이 강좌의 모든 코드는 app/index.tsx에 들어가기 때문에 해당 파일을 열어 다른 파일과 디렉터리를 무시할 수 있습니다.\n다음과 같은 내용이 표시됩니다:\n\n<img src=\"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png\" />\n\n의존성 설치:\n필요한 종속 항목을 설치하려면 npm install 또는 yarn을 실행하세요.\n\n\n\n프로젝트 실행하기:\nnpm start 또는 yarn start를 실행하여 프로젝트를 시작하세요. 이렇게 하면 Metro 번들러가 초기화되고 앱이 개발 모드로 실행됩니다.\n\n프로젝트가 설정되었으므로, 이제 우리는 흥미로운 부분으로 빠져들 준비가 되었습니다: 우리의 사용자 정의 새로고침 애니메이션 만들기!\n\n# 애니메이션 만들기: 상단 스크롤 감지\n\n사용자 정의 애니메이션을 만드는 첫 번째 단계는 FlatList가 맨 위로 스크롤되었을 때 감지하는 것입니다.\n\n\n\n이를 위해 Reanimated에서 useAnimatedScrollHandler를 사용할 것입니다. 이 훅은 최적화되고 성능이 좋은 방식으로 스크롤 이벤트를 처리할 수 있는 함수를 제공할 것입니다.\n\n1. 먼저, Reanimated에서 훅을 import 해야 합니다:\n\n```js\n/**\n * Dependency imports\n */\n\n import React from 'react';\n import { FlatList, StyleSheet, View, ViewProps } from 'react-native';\n import Animated, { useAnimatedScrollHandler } from 'react-native-reanimated';\n```\n\n2. useAnimatedScrollHandler를 사용하여 스크롤 핸들러를 생성하세요:\n\n\n\n```js\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      console.log(event.contentOffset.y);\n    },\n  });\n\n  return (\n    ...\n```\n\n지금은 리스트 스크롤 위치를 기록하는 것으로 할게요.\n\n3. 리스트에 스크롤 핸들러를 연결해보세요. useAnimatedScrollHandler를 사용하여 만든 스크롤 이벤트 핸들러는 React Native의 FlatList와 호환되지 않을 것이므로 Reanimated에서 제공하는 FlatList로 대체해야 합니다.\n\n```js\nreturn (\n    <View style={styles.root}>\n      <Animated.FlatList\n        ...\n        onScroll={scrollHandler}\n        scrollEventThrottle={16} // 부드러운 성능을 위한 좋은 방법\n      />\n    </View>\n);\n```\n\n\n\nscrollEventThrottle 속성은 스크롤 이벤트가 발생하는 빈도를 제어합니다. 여기서 값이 16이면 스크롤 이벤트를 대략 16밀리초마다 캡처합니다. 이렇게 하면 애니메이션이 부드럽고 반응이 빠릅니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1280/1*6cGVuwIPgf4QnLIC79xN7g.gif)\n\n이제 콘솔에 스크롤 위치를 단순히 기록하는 대신, 이를 공유 값에 저장합시다.\n\n다음과 같이 코드를 업데이트하세요:\n\n\n\n```js\nimport Animated, {\n  useAnimatedScrollHandler,\n  useSharedValue,\n} from 'react-native-reanimated';\n\n...\n\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  const scrollPosition = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      scrollPosition.value = event.contentOffset.y;\n    },\n  });\n  ...\n```\n\n# 단계 2: 팬 제스처 캡처하기\n\n이제 목록이 화면 상단까지 스크롤된 것을 감지할 수 있게 되었으므로, 다음 단계는 사용자가 목록을 더 아래로 끌 때 팬 제스처를 캡처하는 것입니다. 이를 달성하기 위해 FlatList의 부모 View에 PanResponder를 사용할 것입니다.\n\n팬 응답자(pan responder)를 생성하기 위해 React Native에서 PanResponder를 가져오세요:\n\n\n\n```js\nimport {\n  PanResponder,\n  StyleSheet,\n  View,\n  ViewProps,\n} from 'react-native';\n```\n\n그런 다음 PanResponder의 인스턴스를 저장하고 FlatList의 부모 View에 연결하기 위해 ref를 사용하십시오:\n\n```js\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  ...\n\n  const panResponderRef = React.useRef(\n    PanResponder.create({\n      onMoveShouldSetPanResponder: () => true,\n      onPanResponderMove: (event, gestureState) => {\n        console.log(gestureState.dy);\n      },\n    })\n  );\n\n  return (\n    <View\n      style={styles.root}\n      {...panResponderRef.current.panHandlers}\n    >\n      <Animated.FlatList\n        ...\n```\n\n이 코드를 자세히 살펴보고 각 부분이 하는 일을 이해해보겠습니다:\n\n\n\nPanResponder.create()\n이 함수 호출은 PanResponder 인스턴스를 만들며 터치 동작에 대한 앱의 응답 방법을 설명하는 객체를 받습니다. 그리고 PanResponder는 React Ref에 저장됩니다.\n\nonMoveShouldSetPanResponder: () =` true,\n터치 동작 중 움직임이 있을 때 호출되는 함수입니다. 여기서 true를 반환하면 사용자가 손가락을 움직일 때 Pan Responder가 계속해서 동작을 처리합니다.\n\nonPanResponderMove: (event, gestureState) =` ' ... '\n응답해야 할 제스처가 있으면, 이 함수는 제스처 동작 중 움직임이 발생할 때 실행됩니다.\n\ngestureState는 현재 제스처에 대한 다양한 데이터를 포함하는 객체로, 터치의 위치, 전체 움직임 등을 나타냅니다. 우리는 gestureState.dy에만 관심이 있으며, 이 값은 제스처 시작부터 Y방향으로 얼마나 움직였는지를 나타냅니다. 사용자가 얼마나 아래로 당겼는지를 추적하는 데 사용할 것입니다.\n\n\n\n현재 목록을 스크롤하려고 하면 응답하지 않는 것 같아요. 이것은 우리의 PanResponder가 계속해서 모든 팬 제스처를 캡처하기 때문에 발생합니다. 결과적으로 목록은 팬 제스처가 발생했음을 처리할 수 없죠. 일단 괜찮아요, 나중에 이 문제를 해결할 거예요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1280/1*JeG4IxcnUQdpcaBdWBzMnA.gif\" />\n\n이제 이동 값을 갖게 됐으니, 이 값을 활용해봅시다. 새로운 공유 값(shared value)을 생성하고 이동 값을 저장하는데 사용해요. 이 공유 값은 목록을 애니메이션화하는 데 활용할 수 있어요.\n\n```js\n...\n\nconst pullDownPosition = useSharedValue(0);\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    onMoveShouldSetPanResponder: () => true,\n    onPanResponderMove: (event, gestureState) => {\n      pullDownPosition.value = gestureState.dy;\n    },\n  })\n);\n\n...\n```\n\n\n\n다음 단계는 Reanimated의 useAnimatedStyle 훅을 사용하여 일부 스타일을 생성하고 적용하는 것입니다. 이 훅은 Reanimated에서 제공되며 공유 값이나 다른 반응형 변수에 기반한 동적 스타일을 생성할 수 있게 해줍니다.\n\n참고: 스타일을 목록 자체가 아닌 목록 부모 View에 적용해야 합니다. 또한 React Native의 View가 아닌 Animated.View를 사용해야 합니다.\n\n```js\n...\nimport Animated, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n} from 'react-native-reanimated';\n\n...\n\nconst pullDownStyles = useAnimatedStyle(() => {\n  return {\n    transform: [\n      {\n        translateY: pullDownPosition.value,\n      },\n    ],\n  };\n});\n\nreturn (\n  <Animated.View\n    style={[styles.root, pullDownStyles]}\n    {...panResponderRef.current.panHandlers}\n  >\n    <Animated.FlatList\n      data={data}\n      ...\n```\n\n\n\n저희 코드를 약간 수정하여 사용자가 목록을 아래로 당길 수는 있지만 상단 경계를 넘어서 올릴 수 없도록 해보겠습니다:\n\n```js\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n\n    onPanResponderMove: (event, gestureState) => {\n      pullDownPosition.value = Math.max(gestureState.dy, 0);\n    },\n  })\n);\n...\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*FTJzKVw9pWxBXYxL4Nrf1g.gif\" />\n\n풀다운 애니메이션을 완성하기 위해, 팬 제스처가 해제될 때 pullDownPosition 공유 값을 제로로 재설정해보겠습니다. Reanimated는 공유 값을 애니메이션화할 수 있는 일련의 애니메이션 유틸리티 함수를 제공합니다. 이 경우에는 pullDownPosition 값을 매끄럽게 제로로 애니메이션화하기 위해 withTiming 함수를 사용하겠습니다.\n\n\n\n```js\n...\nimport Animated, {\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n} from 'react-native-reanimated';\n\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: () => {\n      pullDownPosition.value = withTiming(0, { duration: 180 });\n    },\n  })\n);\n```\n\n팬 제스처는 다른 제스처나 작업에 의해 조기에 종료되거나 중단될 수 있습니다. 다양한 상호 작용 시나리오에서 일관된 신뢰할 수 있는 사용자 경험을 보장하기 위해 onPanResponderRelease와 함께 onPanResponderTerminate도 사용합시다:\n\n```js\n...\n\nconst onPanRelease = () => {\n  pullDownPosition.value = withTiming(0, { duration: 180 });\n};\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: onPanRelease,\n    onPanResponderTerminate: onPanRelease,\n  })\n);\n\n...\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1280/1*9K8kEfhq4VnhQPZoe60Pfw.gif\" />\n\n\n\n# 단계 3: 목록의 스크롤 동작 복원하기\n\n간단한 작동하는 풀다운 애니메이션이 있지만, 목록의 정상적인 스크롤 동작이 보존되고 올바르게 작동하는지 확인해야 합니다.\n\nonMoveShouldSetPanResponder로 돌아가서 항상 true를 반환하는 대신 의미있는 것을 반환하도록 하겠습니다. 목록이 맨 위로 스크롤되고 사용자가 목록을 더 아래로 밀어내는 경우에만 풀다운 제스처를 허용할 것입니다. 이는 아래와 같이 해석됩니다:\n\n```js\n...\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    onMoveShouldSetPanResponder: (event, gestureState) =>\n      scrollPosition.value <= 0 && gestureState.dy >= 0,\n    onPanResponderMove: (event, gestureState) => {\n      pullDownPosition.value = Math.max(gestureState.dy, 0);\n    },\n...\n``` \n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1280/1*URAgW2RXvWsWs1YxrTLL6g.gif\" />\n\n잘 했어요! 목록이 이제 제대로 작동하고 풀다운 애니메이션이 의도대로 트리거되어 멋진 일을 해냈어요!\n\n이제 잠시 쉬는 시간이에요. 커피 한 잔을 즐기세요 ☕, 몇 분 휴식을 취한 후에 마지막 단계로 넘어갈게요.\n\n# 마지막 단계: 새로고침 트리거하기\n\n\n\n이제 튜토리얼의 가장 중요한 부분에 도달했어요. 여기서는 실제로 새로 고침 동작을 트리거할 수 있도록 로직을 설정하는 방법을 알아볼 거에요. 현재 사용자들은 목록을 아래로 내릴 수 있지만, 제약을 추가하고 언제 새로 고침을 활성화해야 하는지 정의하고 싶어요.\n\n## 최대 아래로 당기기 거리 설정\n\n지금 사용자들은 화면 아래쪽까지 목록을 아래로 끌어 내릴 수 있어요. 이것은 자연스럽지 않고 직관적이지 않게 느껴지죠. 그래서 우리는 아래로 당기는 거리를 최대 150픽셀로 제한할 거에요.\n\n```js\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderMove: (event, gestureState) => {\n      const maxDistance = 150;\n      pullDownPosition.value = Math.max(Math.min(maxDistance, gestureState.dy), 0);\n    },\n...\n```\n\n\n\n## 새로고침 트리거 지점 결정하기\n\n사용자가 이 150픽셀 범위의 절반 이상으로 당겼을 때, 새로고침 액션이 트리거될 준비가 된 것으로 간주합니다. 이 지점을 넘어서 제스처를 놓으면 새로고침 액션이 시작됩니다.\n\n```js\n...\nconst pullDownPosition = useSharedValue(0);\nconst isReadyToRefresh = useSharedValue(false);\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderMove: (event, gestureState) => {\n      const maxDistance = 150;\n      pullDownPosition.value = Math.max(Math.min(maxDistance, gestureState.dy), 0);\n\n      if (\n        pullDownPosition.value >= maxDistance / 2 &&\n        isReadyToRefresh.value === false\n      ) {\n        isReadyToRefresh.value = true;\n        console.log('새로고침할 준비 완료');\n      }\n\n      if (\n        pullDownPosition.value < maxDistance / 2 &&\n        isReadyToRefresh.value === true\n      ) {\n        isReadyToRefresh.value = false;\n        console.log('릴리스 시 새로고침하지 않음');\n      }\n    },\n...\n```\n\n공유 값 isReadyToRefresh는 목록을 충분히 당겼는지 여부를 나타냅니다. 이제는 제스처 릴리스 처리 논리를 업데이트해봅시다:\n\n\n\n```js\n...\n\nconst onPanRelease = () => {\n  pullDownPosition.value = withTiming(isReadyToRefresh.value ? 75 : 0, {\n    duration: 180,\n  });\n\n  if (isReadyToRefresh.value) {\n    isReadyToRefresh.value = false;\n\n    // 새로고침 실행\n  }\n};\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: onPanRelease,\n    onPanResponderTerminate: onPanRelease,\n  })\n);\n...\n```\n\n새로고침 작업을 트리거하는 메커니즘이 마련되었으니, 제스처(팬 릴리스)의 끝을 처리해봅시다.\n\n## 새로고침 작업 트리거\n\n사용자의 제스처가 끝나고 새로고침 작업 준비가 완료되면, onRefresh 함수를 호출할 것입니다. 이 함수는 하나의 매개변수를 받습니다. 해당 매개변수는 새로고침 작업이 완료된 후 애니메이션을 재설정할 done 함수입니다.\n\n\n\n```js\n...\n\nconst pullDownPosition = useSharedValue(0);\nconst isReadyToRefresh = useSharedValue(false);\n\nconst onRefresh = (done: () => void) => {\n  console.log('새로 고침 중...');\n\n  setTimeout(() => {\n    console.log('새로 고침 완료!');\n    done();\n  }, 7500);\n};\n\nconst onPanRelease = () => {\n  pullDownPosition.value = withTiming(isReadyToRefresh.value ? 75 : 0, {\n    duration: 180,\n  });\n\n  if (isReadyToRefresh.value) {\n    isReadyToRefresh.value = false;\n\n    // 애니메이션을 재설정하는 함수\n    const onRefreshComplete = () => {\n      pullDownPosition.value = withTiming(0, { duration: 180 });\n    };\n\n    // 새로 고침 작업 실행\n    onRefresh(onRefreshComplete);\n  }\n};\n\n...\n```\n\n`onRefresh` 함수는 setTimeout을 사용하여 새로 고침 프로세스를 시뮬레이션합니다(실제 데이터 가져오기 프로세스의 가상 대체물로). 데이터가 새로 고쳐지면 애니메이션을 재설정하기 위해 `done` 콜백이 호출됩니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1280/1*qtBcIAWfx4fISFDhdmreFw.gif\" />\n\n# 애니메이션 구축하기\n\n\n\n이제 useAnimatedStyle 훅을 사용하여 새로 고침 애니메이션을 활성화할 준비가 되었습니다. 몇 가지 애니메이션 컴포넌트로 UI를 개선하면서 시작해 봅시다.\n\n## 배경 설정\n\n먼저, 애니메이션을 위한 배경을 만들겠습니다. 주요 UI를 View로 감싸고 기본 스타일을 적용하세요:\n\n```js\n...\n\nreturn (\n  <View\n    style={{\n      flex: 1,\n      backgroundColor: '#333',\n    }}\n  >\n    <Animated.View\n      style={[styles.root, pullDownStyles]}\n      {...panResponderRef.current.panHandlers}\n    >\n      <Animated.FlatList\n        ...\n      />\n    </Animated.View>\n  </View>\n);\n\n...\n```\n\n\n\n뷰는 애니메이션을 강조하는 어두운 배경을 제공하는 컨테이너 역할을 합니다.\n\n## 새로 고침 아이콘 통합\n\n다음으로, 회전하는 새로 고침 아이콘을 추가해 봅시다. 이 아이콘을 풀 다운 위치에 따라 확대 및 회전되도록 애니메이션화할 것입니다:\n\n```js\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  ...\n\n  const refreshContainerStyles = useAnimatedStyle(() => {\n    return {\n      height: pullDownPosition.value,\n    };\n  });\n\n  const refreshIconStyles = useAnimatedStyle(() => {\n    const scale = Math.min(1, Math.max(0, pullDownPosition.value / 75));\n\n    return {\n      opacity: Math.max(0, pullDownPosition.value - 25) / 50,\n      transform: [\n        {\n          scale: scale,\n        },\n        {\n          rotate: `${pullDownPosition.value * 3}deg`,\n        },\n      ],\n    };\n  });\n\n  return (\n    [styles.refreshContainer, refreshContainerStyles]}>\n        <Animated.Image\n          source={refreshIcon}\n          style={[styles.refreshIcon, refreshIconStyles]}\n        />\n      </Animated.View>\n\n      ...\n    </View>\n  );\n};\n```\n\n\n\n\n![Loading animation](https://miro.medium.com/v2/resize:fit:1400/1*OVJMKGr9f4IJG3Ou7KTUjA.gif)\n\n이제 '새로 고침 중...'이라는 단어를 단순히 기록하는 대신 상태 값을 사용하여 UI를 업데이트하고 새로 고침이 진행 중임을 나타내겠습니다:\n\n```js\n...\n\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  ...\n\n  const pullDownPosition = useSharedValue(0);\n  const isReadyToRefresh = useSharedValue(false);\n  const [refreshing, setRefreshing] = React.useState(false);\n\n  const onRefresh = (done: () => void) => {\n    setRefreshing(true);\n\n    setTimeout(() => {\n      setRefreshing(false);\n      done();\n    }, 7500);\n  };\n\n  ...\n\n  return (\n    <View\n      pointerEvents={refreshing ? 'none' : 'auto'}\n      style={\n        flex: 1,\n        backgroundColor: '#333',\n      }\n    >\n\n    ...\n```\n\n데이터가 아직로드 중인 동안 원치 않는 pull-down 제스처를 제어하고 방지하려면 pointerEvents 속성을 추가했습니다.\n\n\n\n\n## 로고 애니메이션 구현하기\n\n조금 더 재미있게 만들기 위해 애니메이션 로고를 추가해봅시다. 사용한 애니메이션 로고는 원래 Tony Pinkevych가 Dribbble에서 만들었고, 저는 이 데모에 맞게 약간 수정했습니다.\n\n```js\n/**\n * 의존성 가져오기\n */\n\nimport React from 'react';\nimport { Image } from 'expo-image';\n\n...\n\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  ...\n\n  return (\n    <View\n      pointerEvents={refreshing ? 'none' : 'auto'}\n      style={\n        flex: 1,\n        backgroundColor: '#333',\n      }\n    >\n      <Animated.View style={[styles.refreshContainer, refreshContainerStyles]}>\n        {refreshing && (\n          <Image\n            source={animatedLogo}\n            style={ width: 280, height: '100%', objectFit: 'cover' }\n          />\n        )}\n\n        <Animated.Image\n          source={refreshIcon}\n          style={[styles.refreshIcon, refreshIconStyles]}\n        />\n      </Animated.View>\n\n    ...\n```\n\n마지막으로, refreshIconStyles를 업데이트하여 새로 고침 아이콘을 애니메이션 로고로 부드럽게 전환해보겠습니다.\n\n\n\n```js\nconst refreshIconStyles = useAnimatedStyle(() => {\n  const scale = Math.min(1, Math.max(0, pullDownPosition.value / 75));\n\n  return {\n    opacity: refreshing\n      ? withDelay(100, withTiming(0, { duration: 20 }))\n      : Math.max(0, pullDownPosition.value - 25) / 50,\n    transform: [\n      {\n        scaleX: refreshing ? withTiming(0.15, { duration: 120 }) : scale,\n      },\n      {\n        scaleY: scale,\n      },\n      {\n        rotate: `${pullDownPosition.value * 3}deg`,\n      },\n    ],\n    backgroundColor: refreshing ? '#fff' : 'transparent',\n  };\n}, [refreshing]);\n```\n\n마지막으로, 데이터를 로드하는 동안 스켈레톤 카드를 보여줄 것입니다:\n\n```js\n...\n\n<Animated.FlatList\n  ...\n  renderItem={({ item, index }) => (\n    <Card\n      loading={refreshing}\n      index={index}\n      image={item.image}\n      title={item.title}\n      likes={item.likes}\n    />\n  )}\n  onScroll={scrollHandler}\n  scrollEventThrottle={16}\n/>\n</Animated.View>\n\n...\n```\n\n이러한 마지막 손짓으로, 새로 고침 애니메이션이 기능적이면서 시각적으로 매력적으로 완성되었습니다.\n\n\n\n# 활기찬 인상 깊은 애니메이션\n\n이제 창조의 시간입니다. 여기 창의성을 자극하고 다음 앱을 위한 몇 가지 아이디어를 제공할 인상적인 애니메이션의 선별된 목록이 준비되어 있습니다.\n\n![Animation 1](https://miro.medium.com/v2/resize:fit:1400/1*KB2KSwJq06LLyzA2_t-h1w.gif)\n\n![Animation 2](https://miro.medium.com/v2/resize:fit:1400/1*6L8rnyxjfPF-leE0x3Kigg.gif)\n\n\n\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*Fb1kzeeAhQVNEf5TTAZlrg.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*YU3TndEWRtBaNcjXf-JZVg.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*sMa1sfIYa6Zsl8Co0bCsEQ.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*N5X0Kbuz7jHxclWzBv-glw.gif)\n\n\n\n![image1](https://miro.medium.com/v2/resize:fit:1400/1*pZ8ddY3rFUoVBuTWAhRPTg.gif)\n\n![image2](https://miro.medium.com/v2/resize:fit:1400/1*bSPbDYoIz9zz3r2mCftWKw.gif)\n\n![image3](https://miro.medium.com/v2/resize:fit:1400/1*utIKDBZ3o_V_-ctf22CBSA.gif)\n\n![image4](https://miro.medium.com/v2/resize:fit:1400/1*Ti1YIVYL67ZQHWDXNX8ZzA.gif)\n\n\n\n![이미지1](https://miro.medium.com/v2/resize:fit:1400/1*948wumPUB-5spDMTYs0Odg.gif)\n\n![이미지2](https://miro.medium.com/v2/resize:fit:1400/1*V4UtSyfCN9DDpl70IxXSHA.gif)\n\n![이미지3](https://miro.medium.com/v2/resize:fit:1400/1*GA_UPaFN6krQMhRb3lGiqw.gif)\n\n![이미지4](https://miro.medium.com/v2/resize:fit:1400/1*m4aMIvlIMY5WGmyFL8q2gA.gif)\n\n\n\n# 결론\n\n우리의 사용자 정의 새로 고침 애니메이션 자습서가 마무리되었습니다! 아마도 이것이 여러분의 프로젝트에 몇 가지 아이디어를 불러일으켰으면 좋겠네요. 다양한 애니메이션을 실험해보고 해당 앱의 사용자 경험을 어떻게 향상시킬 수 있는지 확인해 보는 것을 권장합니다.\n\n기억하세요, 배우는 가장 좋은 방법은 직접 해보는 것이기 때문에 고유한 새로 고침 애니메이션을 만들어보는 것에 도전해 보세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png","tag":["Tech"],"readingTime":18},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>간단한 애니메이션이 앱의 사용자 경험을 얼마나 높일 수 있는지 궁금했던 적이 있나요?</h2>\n<p>잘 디자인된 애니메이션은 평범한 사용자 상호 작용을 진정으로 기억에 남는 경험으로 변화시킬 수 있습니다.</p>\n<p>이 포스트에서는 React Native와 Reanimated 라이브러리를 사용하여 모바일 앱에 맞춘 흥미로운 사용자 정의 '당겨서 새로고침' 애니메이션을 만드는 방법을 배우게 됩니다.</p>\n<h2>그냥 React Native의 RefreshControl을 사용하는 것이 좋지 않을까요?</h2>\n<p>리액트 네이티브로 모바일 애플리케이션을 개발할 때, Pull-to-refresh 기능을 구현하는 데 RefreshControl 컴포넌트를 주로 사용합니다.</p>\n<p>간단하고 직관적이지만, 꽤 기본적이며 제한된 사용자 정의 기능을 제공합니다. 이로 인해 여러분의 앱이 그저 다른 어떤 앱처럼 보이는 경우가 있을 수 있습니다.</p>\n<p>사용자 정의 애니메이션을 생성하면 앱의 모양과 느낌을 자유롭게 조절하여 브랜딩 및 디자인 언어와 완벽하게 일치시킬 수 있습니다. 이로써 앱이 더 독특하고 기억에 남는 사용자 경험을 제공하게 되어 앱이 더욱 독특하고 기억에 남게 만듭니다.</p>\n<h2>왜 Animated가 아닌 Reanimated 라이브러리를 사용해야 하는가?</h2>\n<p>React Native에서 애니메이션에 관한 이야기가 나온다면, 두 가지 주요 라이브러리가 떠오르게 됩니다: 내장된 Animated 라이브러리와 더 고급화된 Reanimated 라이브러리가 있습니다.</p>\n<p>Reanimated가 선호되는 이유는 몇 가지가 있습니다:</p>\n<ul>\n<li>성능:\nReanimated는 특히 복잡한 애니메이션에 대해 우수한 성능을 제공합니다. 네이티브 스레드를 활용하여 JavaScript 스레드 대신 작동함으로써 더 효율적으로 작동합니다. 이는 훨씬 부드러운 애니메이션을 가능하게 하며, 이는 원활한 사용자 경험을 위한 중요한 요소입니다.</li>\n<li>제스처 기반 애니메이션:\nReanimated는 더 복잡한 애니메이션 처리를 위한 더 나은 API를 제공하며, 제스처와 애니메이션의 더 섬세한 제어와 더 부드러운 통합을 가능케 합니다.</li>\n<li>선언적 접근: Animated와 달리, Reanimated는 애니메이션에 더 선언적인 접근 방식을 채용합니다. 이는 애니메이션이 더 복잡해지면서 이해하고 관리하기 쉬워집니다.</li>\n</ul>\n<h1>시작하기</h1>\n<p>이 튜토리얼에서는 간단한 앱을 향상시키고자 합니다. 이 앱은 FlatList에서 카드 형태로 표시되는 Dribbble 샷 목록을 보여줍니다. 우리의 목표는 사용자가 목록을 위로 당겼을 때 나타나는 사용자 정의 새로 고침 애니메이션을 추가하는 것입니다.</p>\n<h2>프로젝트 복제 및 설정</h2>\n<p>로컬 컴퓨터에서 저장소를 클론하고 프로젝트를 설정하기 위해 다음 단계를 따라주세요:</p>\n<p>저장소 복제:\n터미널을 열고 다음 명령어로 저장소를 클론하세요:</p>\n<pre><code class=\"hljs language-js\">git clone <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//github.com/teefouad/custom-rn-refresh-animation-start.git</span>\n</code></pre>\n<p>VSCode에서 프로젝트 열기:\n이 강좌의 모든 코드는 app/index.tsx에 들어가기 때문에 해당 파일을 열어 다른 파일과 디렉터리를 무시할 수 있습니다.\n다음과 같은 내용이 표시됩니다:</p>\n<p>의존성 설치:\n필요한 종속 항목을 설치하려면 npm install 또는 yarn을 실행하세요.</p>\n<p>프로젝트 실행하기:\nnpm start 또는 yarn start를 실행하여 프로젝트를 시작하세요. 이렇게 하면 Metro 번들러가 초기화되고 앱이 개발 모드로 실행됩니다.</p>\n<p>프로젝트가 설정되었으므로, 이제 우리는 흥미로운 부분으로 빠져들 준비가 되었습니다: 우리의 사용자 정의 새로고침 애니메이션 만들기!</p>\n<h1>애니메이션 만들기: 상단 스크롤 감지</h1>\n<p>사용자 정의 애니메이션을 만드는 첫 번째 단계는 FlatList가 맨 위로 스크롤되었을 때 감지하는 것입니다.</p>\n<p>이를 위해 Reanimated에서 useAnimatedScrollHandler를 사용할 것입니다. 이 훅은 최적화되고 성능이 좋은 방식으로 스크롤 이벤트를 처리할 수 있는 함수를 제공할 것입니다.</p>\n<ol>\n<li>먼저, Reanimated에서 훅을 import 해야 합니다:</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/**\n * Dependency imports\n */</span>\n\n <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n <span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">FlatList</span>, <span class=\"hljs-title class_\">StyleSheet</span>, <span class=\"hljs-title class_\">View</span>, <span class=\"hljs-title class_\">ViewProps</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-native'</span>;\n <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Animated</span>, { useAnimatedScrollHandler } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-native-reanimated'</span>;\n</code></pre>\n<ol start=\"2\">\n<li>useAnimatedScrollHandler를 사용하여 스크롤 핸들러를 생성하세요:</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DribbbleShots</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;<span class=\"hljs-title class_\">DribbbleShotsProps</span> &#x26; <span class=\"hljs-title class_\">ViewProps</span>> = <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> scrollHandler = <span class=\"hljs-title function_\">useAnimatedScrollHandler</span>({\n    <span class=\"hljs-attr\">onScroll</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =></span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(event.<span class=\"hljs-property\">contentOffset</span>.<span class=\"hljs-property\">y</span>);\n    },\n  });\n\n  <span class=\"hljs-keyword\">return</span> (\n    ...\n</code></pre>\n<p>지금은 리스트 스크롤 위치를 기록하는 것으로 할게요.</p>\n<ol start=\"3\">\n<li>리스트에 스크롤 핸들러를 연결해보세요. useAnimatedScrollHandler를 사용하여 만든 스크롤 이벤트 핸들러는 React Native의 FlatList와 호환되지 않을 것이므로 Reanimated에서 제공하는 FlatList로 대체해야 합니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{styles.root}</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Animated.FlatList</span>\n        <span class=\"hljs-attr\">...</span>\n        <span class=\"hljs-attr\">onScroll</span>=<span class=\"hljs-string\">{scrollHandler}</span>\n        <span class=\"hljs-attr\">scrollEventThrottle</span>=<span class=\"hljs-string\">{16}</span> // <span class=\"hljs-attr\">부드러운</span> <span class=\"hljs-attr\">성능을</span> <span class=\"hljs-attr\">위한</span> <span class=\"hljs-attr\">좋은</span> <span class=\"hljs-attr\">방법</span>\n      /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">View</span>></span></span>\n);\n</code></pre>\n<p>scrollEventThrottle 속성은 스크롤 이벤트가 발생하는 빈도를 제어합니다. 여기서 값이 16이면 스크롤 이벤트를 대략 16밀리초마다 캡처합니다. 이렇게 하면 애니메이션이 부드럽고 반응이 빠릅니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1280/1*6cGVuwIPgf4QnLIC79xN7g.gif\" alt=\"이미지\"></p>\n<p>이제 콘솔에 스크롤 위치를 단순히 기록하는 대신, 이를 공유 값에 저장합시다.</p>\n<p>다음과 같이 코드를 업데이트하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Animated</span>, {\n  useAnimatedScrollHandler,\n  useSharedValue,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-native-reanimated'</span>;\n\n...\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DribbbleShots</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;<span class=\"hljs-title class_\">DribbbleShotsProps</span> &#x26; <span class=\"hljs-title class_\">ViewProps</span>> = <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> scrollPosition = <span class=\"hljs-title function_\">useSharedValue</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> scrollHandler = <span class=\"hljs-title function_\">useAnimatedScrollHandler</span>({\n    <span class=\"hljs-attr\">onScroll</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =></span> {\n      scrollPosition.<span class=\"hljs-property\">value</span> = event.<span class=\"hljs-property\">contentOffset</span>.<span class=\"hljs-property\">y</span>;\n    },\n  });\n  ...\n</code></pre>\n<h1>단계 2: 팬 제스처 캡처하기</h1>\n<p>이제 목록이 화면 상단까지 스크롤된 것을 감지할 수 있게 되었으므로, 다음 단계는 사용자가 목록을 더 아래로 끌 때 팬 제스처를 캡처하는 것입니다. 이를 달성하기 위해 FlatList의 부모 View에 PanResponder를 사용할 것입니다.</p>\n<p>팬 응답자(pan responder)를 생성하기 위해 React Native에서 PanResponder를 가져오세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">PanResponder</span>,\n  <span class=\"hljs-title class_\">StyleSheet</span>,\n  <span class=\"hljs-title class_\">View</span>,\n  <span class=\"hljs-title class_\">ViewProps</span>,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-native'</span>;\n</code></pre>\n<p>그런 다음 PanResponder의 인스턴스를 저장하고 FlatList의 부모 View에 연결하기 위해 ref를 사용하십시오:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DribbbleShots</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;<span class=\"hljs-title class_\">DribbbleShotsProps</span> &#x26; <span class=\"hljs-title class_\">ViewProps</span>> = <span class=\"hljs-function\">() =></span> {\n  ...\n\n  <span class=\"hljs-keyword\">const</span> panResponderRef = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(\n    <span class=\"hljs-title class_\">PanResponder</span>.<span class=\"hljs-title function_\">create</span>({\n      <span class=\"hljs-attr\">onMoveShouldSetPanResponder</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">onPanResponderMove</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">event, gestureState</span>) =></span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gestureState.<span class=\"hljs-property\">dy</span>);\n      },\n    })\n  );\n\n  <span class=\"hljs-keyword\">return</span> (\n    &#x3C;View\n      style={styles.root}\n      {...panResponderRef.current.panHandlers}\n    >\n      &#x3C;Animated.FlatList\n        ...\n</code></pre>\n<p>이 코드를 자세히 살펴보고 각 부분이 하는 일을 이해해보겠습니다:</p>\n<p>PanResponder.create()\n이 함수 호출은 PanResponder 인스턴스를 만들며 터치 동작에 대한 앱의 응답 방법을 설명하는 객체를 받습니다. 그리고 PanResponder는 React Ref에 저장됩니다.</p>\n<p>onMoveShouldSetPanResponder: () =` true,\n터치 동작 중 움직임이 있을 때 호출되는 함수입니다. 여기서 true를 반환하면 사용자가 손가락을 움직일 때 Pan Responder가 계속해서 동작을 처리합니다.</p>\n<p>onPanResponderMove: (event, gestureState) =` ' ... '\n응답해야 할 제스처가 있으면, 이 함수는 제스처 동작 중 움직임이 발생할 때 실행됩니다.</p>\n<p>gestureState는 현재 제스처에 대한 다양한 데이터를 포함하는 객체로, 터치의 위치, 전체 움직임 등을 나타냅니다. 우리는 gestureState.dy에만 관심이 있으며, 이 값은 제스처 시작부터 Y방향으로 얼마나 움직였는지를 나타냅니다. 사용자가 얼마나 아래로 당겼는지를 추적하는 데 사용할 것입니다.</p>\n<p>현재 목록을 스크롤하려고 하면 응답하지 않는 것 같아요. 이것은 우리의 PanResponder가 계속해서 모든 팬 제스처를 캡처하기 때문에 발생합니다. 결과적으로 목록은 팬 제스처가 발생했음을 처리할 수 없죠. 일단 괜찮아요, 나중에 이 문제를 해결할 거예요.</p>\n<p>이제 이동 값을 갖게 됐으니, 이 값을 활용해봅시다. 새로운 공유 값(shared value)을 생성하고 이동 값을 저장하는데 사용해요. 이 공유 값은 목록을 애니메이션화하는 데 활용할 수 있어요.</p>\n<pre><code class=\"hljs language-js\">...\n\n<span class=\"hljs-keyword\">const</span> pullDownPosition = <span class=\"hljs-title function_\">useSharedValue</span>(<span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-keyword\">const</span> panResponderRef = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(\n  <span class=\"hljs-title class_\">PanResponder</span>.<span class=\"hljs-title function_\">create</span>({\n    <span class=\"hljs-attr\">onMoveShouldSetPanResponder</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">onPanResponderMove</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">event, gestureState</span>) =></span> {\n      pullDownPosition.<span class=\"hljs-property\">value</span> = gestureState.<span class=\"hljs-property\">dy</span>;\n    },\n  })\n);\n\n...\n</code></pre>\n<p>다음 단계는 Reanimated의 useAnimatedStyle 훅을 사용하여 일부 스타일을 생성하고 적용하는 것입니다. 이 훅은 Reanimated에서 제공되며 공유 값이나 다른 반응형 변수에 기반한 동적 스타일을 생성할 수 있게 해줍니다.</p>\n<p>참고: 스타일을 목록 자체가 아닌 목록 부모 View에 적용해야 합니다. 또한 React Native의 View가 아닌 Animated.View를 사용해야 합니다.</p>\n<pre><code class=\"hljs language-js\">...\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Animated</span>, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-native-reanimated'</span>;\n\n...\n\n<span class=\"hljs-keyword\">const</span> pullDownStyles = <span class=\"hljs-title function_\">useAnimatedStyle</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">transform</span>: [\n      {\n        <span class=\"hljs-attr\">translateY</span>: pullDownPosition.<span class=\"hljs-property\">value</span>,\n      },\n    ],\n  };\n});\n\n<span class=\"hljs-keyword\">return</span> (\n  &#x3C;Animated.View\n    style={[styles.root, pullDownStyles]}\n    {...panResponderRef.current.panHandlers}\n  >\n    &#x3C;Animated.FlatList\n      data={data}\n      ...\n</code></pre>\n<p>저희 코드를 약간 수정하여 사용자가 목록을 아래로 당길 수는 있지만 상단 경계를 넘어서 올릴 수 없도록 해보겠습니다:</p>\n<pre><code class=\"hljs language-js\">...\n\n<span class=\"hljs-keyword\">const</span> panResponderRef = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(\n  <span class=\"hljs-title class_\">PanResponder</span>.<span class=\"hljs-title function_\">create</span>({\n    ...\n\n    <span class=\"hljs-attr\">onPanResponderMove</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">event, gestureState</span>) =></span> {\n      pullDownPosition.<span class=\"hljs-property\">value</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(gestureState.<span class=\"hljs-property\">dy</span>, <span class=\"hljs-number\">0</span>);\n    },\n  })\n);\n...\n</code></pre>\n<p>풀다운 애니메이션을 완성하기 위해, 팬 제스처가 해제될 때 pullDownPosition 공유 값을 제로로 재설정해보겠습니다. Reanimated는 공유 값을 애니메이션화할 수 있는 일련의 애니메이션 유틸리티 함수를 제공합니다. 이 경우에는 pullDownPosition 값을 매끄럽게 제로로 애니메이션화하기 위해 withTiming 함수를 사용하겠습니다.</p>\n<pre><code class=\"hljs language-js\">...\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Animated</span>, {\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-native-reanimated'</span>;\n\n...\n\n<span class=\"hljs-keyword\">const</span> panResponderRef = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(\n  <span class=\"hljs-title class_\">PanResponder</span>.<span class=\"hljs-title function_\">create</span>({\n    ...\n    <span class=\"hljs-attr\">onPanResponderRelease</span>: <span class=\"hljs-function\">() =></span> {\n      pullDownPosition.<span class=\"hljs-property\">value</span> = <span class=\"hljs-title function_\">withTiming</span>(<span class=\"hljs-number\">0</span>, { <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">180</span> });\n    },\n  })\n);\n</code></pre>\n<p>팬 제스처는 다른 제스처나 작업에 의해 조기에 종료되거나 중단될 수 있습니다. 다양한 상호 작용 시나리오에서 일관된 신뢰할 수 있는 사용자 경험을 보장하기 위해 onPanResponderRelease와 함께 onPanResponderTerminate도 사용합시다:</p>\n<pre><code class=\"hljs language-js\">...\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onPanRelease</span> = (<span class=\"hljs-params\"></span>) => {\n  pullDownPosition.<span class=\"hljs-property\">value</span> = <span class=\"hljs-title function_\">withTiming</span>(<span class=\"hljs-number\">0</span>, { <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">180</span> });\n};\n\n<span class=\"hljs-keyword\">const</span> panResponderRef = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(\n  <span class=\"hljs-title class_\">PanResponder</span>.<span class=\"hljs-title function_\">create</span>({\n    ...\n    <span class=\"hljs-attr\">onPanResponderRelease</span>: onPanRelease,\n    <span class=\"hljs-attr\">onPanResponderTerminate</span>: onPanRelease,\n  })\n);\n\n...\n</code></pre>\n<h1>단계 3: 목록의 스크롤 동작 복원하기</h1>\n<p>간단한 작동하는 풀다운 애니메이션이 있지만, 목록의 정상적인 스크롤 동작이 보존되고 올바르게 작동하는지 확인해야 합니다.</p>\n<p>onMoveShouldSetPanResponder로 돌아가서 항상 true를 반환하는 대신 의미있는 것을 반환하도록 하겠습니다. 목록이 맨 위로 스크롤되고 사용자가 목록을 더 아래로 밀어내는 경우에만 풀다운 제스처를 허용할 것입니다. 이는 아래와 같이 해석됩니다:</p>\n<pre><code class=\"hljs language-js\">...\n<span class=\"hljs-keyword\">const</span> panResponderRef = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(\n  <span class=\"hljs-title class_\">PanResponder</span>.<span class=\"hljs-title function_\">create</span>({\n    <span class=\"hljs-attr\">onMoveShouldSetPanResponder</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">event, gestureState</span>) =></span>\n      scrollPosition.<span class=\"hljs-property\">value</span> &#x3C;= <span class=\"hljs-number\">0</span> &#x26;&#x26; gestureState.<span class=\"hljs-property\">dy</span> >= <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">onPanResponderMove</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">event, gestureState</span>) =></span> {\n      pullDownPosition.<span class=\"hljs-property\">value</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(gestureState.<span class=\"hljs-property\">dy</span>, <span class=\"hljs-number\">0</span>);\n    },\n...\n</code></pre>\n<p>잘 했어요! 목록이 이제 제대로 작동하고 풀다운 애니메이션이 의도대로 트리거되어 멋진 일을 해냈어요!</p>\n<p>이제 잠시 쉬는 시간이에요. 커피 한 잔을 즐기세요 ☕, 몇 분 휴식을 취한 후에 마지막 단계로 넘어갈게요.</p>\n<h1>마지막 단계: 새로고침 트리거하기</h1>\n<p>이제 튜토리얼의 가장 중요한 부분에 도달했어요. 여기서는 실제로 새로 고침 동작을 트리거할 수 있도록 로직을 설정하는 방법을 알아볼 거에요. 현재 사용자들은 목록을 아래로 내릴 수 있지만, 제약을 추가하고 언제 새로 고침을 활성화해야 하는지 정의하고 싶어요.</p>\n<h2>최대 아래로 당기기 거리 설정</h2>\n<p>지금 사용자들은 화면 아래쪽까지 목록을 아래로 끌어 내릴 수 있어요. 이것은 자연스럽지 않고 직관적이지 않게 느껴지죠. 그래서 우리는 아래로 당기는 거리를 최대 150픽셀로 제한할 거에요.</p>\n<pre><code class=\"hljs language-js\">...\n\n<span class=\"hljs-keyword\">const</span> panResponderRef = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(\n  <span class=\"hljs-title class_\">PanResponder</span>.<span class=\"hljs-title function_\">create</span>({\n    ...\n    <span class=\"hljs-attr\">onPanResponderMove</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">event, gestureState</span>) =></span> {\n      <span class=\"hljs-keyword\">const</span> maxDistance = <span class=\"hljs-number\">150</span>;\n      pullDownPosition.<span class=\"hljs-property\">value</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(maxDistance, gestureState.<span class=\"hljs-property\">dy</span>), <span class=\"hljs-number\">0</span>);\n    },\n...\n</code></pre>\n<h2>새로고침 트리거 지점 결정하기</h2>\n<p>사용자가 이 150픽셀 범위의 절반 이상으로 당겼을 때, 새로고침 액션이 트리거될 준비가 된 것으로 간주합니다. 이 지점을 넘어서 제스처를 놓으면 새로고침 액션이 시작됩니다.</p>\n<pre><code class=\"hljs language-js\">...\n<span class=\"hljs-keyword\">const</span> pullDownPosition = <span class=\"hljs-title function_\">useSharedValue</span>(<span class=\"hljs-number\">0</span>);\n<span class=\"hljs-keyword\">const</span> isReadyToRefresh = <span class=\"hljs-title function_\">useSharedValue</span>(<span class=\"hljs-literal\">false</span>);\n\n<span class=\"hljs-keyword\">const</span> panResponderRef = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(\n  <span class=\"hljs-title class_\">PanResponder</span>.<span class=\"hljs-title function_\">create</span>({\n    ...\n    <span class=\"hljs-attr\">onPanResponderMove</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">event, gestureState</span>) =></span> {\n      <span class=\"hljs-keyword\">const</span> maxDistance = <span class=\"hljs-number\">150</span>;\n      pullDownPosition.<span class=\"hljs-property\">value</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(maxDistance, gestureState.<span class=\"hljs-property\">dy</span>), <span class=\"hljs-number\">0</span>);\n\n      <span class=\"hljs-keyword\">if</span> (\n        pullDownPosition.<span class=\"hljs-property\">value</span> >= maxDistance / <span class=\"hljs-number\">2</span> &#x26;&#x26;\n        isReadyToRefresh.<span class=\"hljs-property\">value</span> === <span class=\"hljs-literal\">false</span>\n      ) {\n        isReadyToRefresh.<span class=\"hljs-property\">value</span> = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'새로고침할 준비 완료'</span>);\n      }\n\n      <span class=\"hljs-keyword\">if</span> (\n        pullDownPosition.<span class=\"hljs-property\">value</span> &#x3C; maxDistance / <span class=\"hljs-number\">2</span> &#x26;&#x26;\n        isReadyToRefresh.<span class=\"hljs-property\">value</span> === <span class=\"hljs-literal\">true</span>\n      ) {\n        isReadyToRefresh.<span class=\"hljs-property\">value</span> = <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'릴리스 시 새로고침하지 않음'</span>);\n      }\n    },\n...\n</code></pre>\n<p>공유 값 isReadyToRefresh는 목록을 충분히 당겼는지 여부를 나타냅니다. 이제는 제스처 릴리스 처리 논리를 업데이트해봅시다:</p>\n<pre><code class=\"hljs language-js\">...\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onPanRelease</span> = (<span class=\"hljs-params\"></span>) => {\n  pullDownPosition.<span class=\"hljs-property\">value</span> = <span class=\"hljs-title function_\">withTiming</span>(isReadyToRefresh.<span class=\"hljs-property\">value</span> ? <span class=\"hljs-number\">75</span> : <span class=\"hljs-number\">0</span>, {\n    <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">180</span>,\n  });\n\n  <span class=\"hljs-keyword\">if</span> (isReadyToRefresh.<span class=\"hljs-property\">value</span>) {\n    isReadyToRefresh.<span class=\"hljs-property\">value</span> = <span class=\"hljs-literal\">false</span>;\n\n    <span class=\"hljs-comment\">// 새로고침 실행</span>\n  }\n};\n\n<span class=\"hljs-keyword\">const</span> panResponderRef = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(\n  <span class=\"hljs-title class_\">PanResponder</span>.<span class=\"hljs-title function_\">create</span>({\n    ...\n    <span class=\"hljs-attr\">onPanResponderRelease</span>: onPanRelease,\n    <span class=\"hljs-attr\">onPanResponderTerminate</span>: onPanRelease,\n  })\n);\n...\n</code></pre>\n<p>새로고침 작업을 트리거하는 메커니즘이 마련되었으니, 제스처(팬 릴리스)의 끝을 처리해봅시다.</p>\n<h2>새로고침 작업 트리거</h2>\n<p>사용자의 제스처가 끝나고 새로고침 작업 준비가 완료되면, onRefresh 함수를 호출할 것입니다. 이 함수는 하나의 매개변수를 받습니다. 해당 매개변수는 새로고침 작업이 완료된 후 애니메이션을 재설정할 done 함수입니다.</p>\n<pre><code class=\"hljs language-js\">...\n\n<span class=\"hljs-keyword\">const</span> pullDownPosition = <span class=\"hljs-title function_\">useSharedValue</span>(<span class=\"hljs-number\">0</span>);\n<span class=\"hljs-keyword\">const</span> isReadyToRefresh = <span class=\"hljs-title function_\">useSharedValue</span>(<span class=\"hljs-literal\">false</span>);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onRefresh</span> = (<span class=\"hljs-params\">done: () => <span class=\"hljs-keyword\">void</span></span>) => {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'새로 고침 중...'</span>);\n\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'새로 고침 완료!'</span>);\n    <span class=\"hljs-title function_\">done</span>();\n  }, <span class=\"hljs-number\">7500</span>);\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onPanRelease</span> = (<span class=\"hljs-params\"></span>) => {\n  pullDownPosition.<span class=\"hljs-property\">value</span> = <span class=\"hljs-title function_\">withTiming</span>(isReadyToRefresh.<span class=\"hljs-property\">value</span> ? <span class=\"hljs-number\">75</span> : <span class=\"hljs-number\">0</span>, {\n    <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">180</span>,\n  });\n\n  <span class=\"hljs-keyword\">if</span> (isReadyToRefresh.<span class=\"hljs-property\">value</span>) {\n    isReadyToRefresh.<span class=\"hljs-property\">value</span> = <span class=\"hljs-literal\">false</span>;\n\n    <span class=\"hljs-comment\">// 애니메이션을 재설정하는 함수</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onRefreshComplete</span> = (<span class=\"hljs-params\"></span>) => {\n      pullDownPosition.<span class=\"hljs-property\">value</span> = <span class=\"hljs-title function_\">withTiming</span>(<span class=\"hljs-number\">0</span>, { <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">180</span> });\n    };\n\n    <span class=\"hljs-comment\">// 새로 고침 작업 실행</span>\n    <span class=\"hljs-title function_\">onRefresh</span>(onRefreshComplete);\n  }\n};\n\n...\n</code></pre>\n<p><code>onRefresh</code> 함수는 setTimeout을 사용하여 새로 고침 프로세스를 시뮬레이션합니다(실제 데이터 가져오기 프로세스의 가상 대체물로). 데이터가 새로 고쳐지면 애니메이션을 재설정하기 위해 <code>done</code> 콜백이 호출됩니다.</p>\n<h1>애니메이션 구축하기</h1>\n<p>이제 useAnimatedStyle 훅을 사용하여 새로 고침 애니메이션을 활성화할 준비가 되었습니다. 몇 가지 애니메이션 컴포넌트로 UI를 개선하면서 시작해 봅시다.</p>\n<h2>배경 설정</h2>\n<p>먼저, 애니메이션을 위한 배경을 만들겠습니다. 주요 UI를 View로 감싸고 기본 스타일을 적용하세요:</p>\n<pre><code class=\"hljs language-js\">...\n\n<span class=\"hljs-keyword\">return</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">View</span>\n    <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span>\n      <span class=\"hljs-attr\">flex:</span> <span class=\"hljs-attr\">1</span>,\n      <span class=\"hljs-attr\">backgroundColor:</span> '#<span class=\"hljs-attr\">333</span>',\n    }}\n  ></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Animated.View</span>\n      <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{[styles.root,</span> <span class=\"hljs-attr\">pullDownStyles</span>]}\n      {<span class=\"hljs-attr\">...panResponderRef.current.panHandlers</span>}\n    ></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Animated.FlatList</span>\n        <span class=\"hljs-attr\">...</span>\n      /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Animated.View</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">View</span>></span></span>\n);\n\n...\n</code></pre>\n<p>뷰는 애니메이션을 강조하는 어두운 배경을 제공하는 컨테이너 역할을 합니다.</p>\n<h2>새로 고침 아이콘 통합</h2>\n<p>다음으로, 회전하는 새로 고침 아이콘을 추가해 봅시다. 이 아이콘을 풀 다운 위치에 따라 확대 및 회전되도록 애니메이션화할 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DribbbleShots</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;<span class=\"hljs-title class_\">DribbbleShotsProps</span> &#x26; <span class=\"hljs-title class_\">ViewProps</span>> = <span class=\"hljs-function\">() =></span> {\n  ...\n\n  <span class=\"hljs-keyword\">const</span> refreshContainerStyles = <span class=\"hljs-title function_\">useAnimatedStyle</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">height</span>: pullDownPosition.<span class=\"hljs-property\">value</span>,\n    };\n  });\n\n  <span class=\"hljs-keyword\">const</span> refreshIconStyles = <span class=\"hljs-title function_\">useAnimatedStyle</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-number\">0</span>, pullDownPosition.<span class=\"hljs-property\">value</span> / <span class=\"hljs-number\">75</span>));\n\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-number\">0</span>, pullDownPosition.<span class=\"hljs-property\">value</span> - <span class=\"hljs-number\">25</span>) / <span class=\"hljs-number\">50</span>,\n      <span class=\"hljs-attr\">transform</span>: [\n        {\n          <span class=\"hljs-attr\">scale</span>: scale,\n        },\n        {\n          <span class=\"hljs-attr\">rotate</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${pullDownPosition.value * <span class=\"hljs-number\">3</span>}</span>deg`</span>,\n        },\n      ],\n    };\n  });\n\n  <span class=\"hljs-keyword\">return</span> (\n    [styles.<span class=\"hljs-property\">refreshContainer</span>, refreshContainerStyles]}>\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Animated.Image</span>\n          <span class=\"hljs-attr\">source</span>=<span class=\"hljs-string\">{refreshIcon}</span>\n          <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{[styles.refreshIcon,</span> <span class=\"hljs-attr\">refreshIconStyles</span>]}\n        /></span></span>\n      &#x3C;/<span class=\"hljs-title class_\">Animated</span>.<span class=\"hljs-property\">View</span>>\n\n      ...\n    &#x3C;/<span class=\"hljs-title class_\">View</span>>\n  );\n};\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*OVJMKGr9f4IJG3Ou7KTUjA.gif\" alt=\"Loading animation\"></p>\n<p>이제 '새로 고침 중...'이라는 단어를 단순히 기록하는 대신 상태 값을 사용하여 UI를 업데이트하고 새로 고침이 진행 중임을 나타내겠습니다:</p>\n<pre><code class=\"hljs language-js\">...\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DribbbleShots</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;<span class=\"hljs-title class_\">DribbbleShotsProps</span> &#x26; <span class=\"hljs-title class_\">ViewProps</span>> = <span class=\"hljs-function\">() =></span> {\n  ...\n\n  <span class=\"hljs-keyword\">const</span> pullDownPosition = <span class=\"hljs-title function_\">useSharedValue</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> isReadyToRefresh = <span class=\"hljs-title function_\">useSharedValue</span>(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> [refreshing, setRefreshing] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onRefresh</span> = (<span class=\"hljs-params\">done: () => <span class=\"hljs-keyword\">void</span></span>) => {\n    <span class=\"hljs-title function_\">setRefreshing</span>(<span class=\"hljs-literal\">true</span>);\n\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-title function_\">setRefreshing</span>(<span class=\"hljs-literal\">false</span>);\n      <span class=\"hljs-title function_\">done</span>();\n    }, <span class=\"hljs-number\">7500</span>);\n  };\n\n  ...\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">View</span>\n      <span class=\"hljs-attr\">pointerEvents</span>=<span class=\"hljs-string\">{refreshing</span> ? '<span class=\"hljs-attr\">none</span>' <span class=\"hljs-attr\">:</span> '<span class=\"hljs-attr\">auto</span>'}\n      <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{</span>\n        <span class=\"hljs-attr\">flex:</span> <span class=\"hljs-attr\">1</span>,\n        <span class=\"hljs-attr\">backgroundColor:</span> '#<span class=\"hljs-attr\">333</span>',\n      }\n    ></span>\n\n    ...\n</span></code></pre>\n<p>데이터가 아직로드 중인 동안 원치 않는 pull-down 제스처를 제어하고 방지하려면 pointerEvents 속성을 추가했습니다.</p>\n<h2>로고 애니메이션 구현하기</h2>\n<p>조금 더 재미있게 만들기 위해 애니메이션 로고를 추가해봅시다. 사용한 애니메이션 로고는 원래 Tony Pinkevych가 Dribbble에서 만들었고, 저는 이 데모에 맞게 약간 수정했습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/**\n * 의존성 가져오기\n */</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Image</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'expo-image'</span>;\n\n...\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DribbbleShots</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;<span class=\"hljs-title class_\">DribbbleShotsProps</span> &#x26; <span class=\"hljs-title class_\">ViewProps</span>> = <span class=\"hljs-function\">() =></span> {\n  ...\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">View</span>\n      <span class=\"hljs-attr\">pointerEvents</span>=<span class=\"hljs-string\">{refreshing</span> ? '<span class=\"hljs-attr\">none</span>' <span class=\"hljs-attr\">:</span> '<span class=\"hljs-attr\">auto</span>'}\n      <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{</span>\n        <span class=\"hljs-attr\">flex:</span> <span class=\"hljs-attr\">1</span>,\n        <span class=\"hljs-attr\">backgroundColor:</span> '#<span class=\"hljs-attr\">333</span>',\n      }\n    ></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Animated.View</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{[styles.refreshContainer,</span> <span class=\"hljs-attr\">refreshContainerStyles</span>]}></span>\n        {refreshing &#x26;&#x26; (\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Image</span>\n            <span class=\"hljs-attr\">source</span>=<span class=\"hljs-string\">{animatedLogo}</span>\n            <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{</span> <span class=\"hljs-attr\">width:</span> <span class=\"hljs-attr\">280</span>, <span class=\"hljs-attr\">height:</span> '<span class=\"hljs-attr\">100</span>%', <span class=\"hljs-attr\">objectFit:</span> '<span class=\"hljs-attr\">cover</span>' }\n          /></span>\n        )}\n\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Animated.Image</span>\n          <span class=\"hljs-attr\">source</span>=<span class=\"hljs-string\">{refreshIcon}</span>\n          <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{[styles.refreshIcon,</span> <span class=\"hljs-attr\">refreshIconStyles</span>]}\n        /></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Animated.View</span>></span>\n\n    ...\n</span></code></pre>\n<p>마지막으로, refreshIconStyles를 업데이트하여 새로 고침 아이콘을 애니메이션 로고로 부드럽게 전환해보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> refreshIconStyles = <span class=\"hljs-title function_\">useAnimatedStyle</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-number\">0</span>, pullDownPosition.<span class=\"hljs-property\">value</span> / <span class=\"hljs-number\">75</span>));\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">opacity</span>: refreshing\n      ? <span class=\"hljs-title function_\">withDelay</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-title function_\">withTiming</span>(<span class=\"hljs-number\">0</span>, { <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">20</span> }))\n      : <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-number\">0</span>, pullDownPosition.<span class=\"hljs-property\">value</span> - <span class=\"hljs-number\">25</span>) / <span class=\"hljs-number\">50</span>,\n    <span class=\"hljs-attr\">transform</span>: [\n      {\n        <span class=\"hljs-attr\">scaleX</span>: refreshing ? <span class=\"hljs-title function_\">withTiming</span>(<span class=\"hljs-number\">0.15</span>, { <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">120</span> }) : scale,\n      },\n      {\n        <span class=\"hljs-attr\">scaleY</span>: scale,\n      },\n      {\n        <span class=\"hljs-attr\">rotate</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${pullDownPosition.value * <span class=\"hljs-number\">3</span>}</span>deg`</span>,\n      },\n    ],\n    <span class=\"hljs-attr\">backgroundColor</span>: refreshing ? <span class=\"hljs-string\">'#fff'</span> : <span class=\"hljs-string\">'transparent'</span>,\n  };\n}, [refreshing]);\n</code></pre>\n<p>마지막으로, 데이터를 로드하는 동안 스켈레톤 카드를 보여줄 것입니다:</p>\n<pre><code class=\"hljs language-js\">...\n\n&#x3C;<span class=\"hljs-title class_\">Animated</span>.<span class=\"hljs-property\">FlatList</span>\n  ...\n  renderItem={<span class=\"hljs-function\">(<span class=\"hljs-params\">{ item, index }</span>) =></span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Card</span>\n      <span class=\"hljs-attr\">loading</span>=<span class=\"hljs-string\">{refreshing}</span>\n      <span class=\"hljs-attr\">index</span>=<span class=\"hljs-string\">{index}</span>\n      <span class=\"hljs-attr\">image</span>=<span class=\"hljs-string\">{item.image}</span>\n      <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">{item.title}</span>\n      <span class=\"hljs-attr\">likes</span>=<span class=\"hljs-string\">{item.likes}</span>\n    /></span></span>\n  )}\n  onScroll={scrollHandler}\n  scrollEventThrottle={<span class=\"hljs-number\">16</span>}\n/>\n&#x3C;/<span class=\"hljs-title class_\">Animated</span>.<span class=\"hljs-property\">View</span>>\n\n...\n</code></pre>\n<p>이러한 마지막 손짓으로, 새로 고침 애니메이션이 기능적이면서 시각적으로 매력적으로 완성되었습니다.</p>\n<h1>활기찬 인상 깊은 애니메이션</h1>\n<p>이제 창조의 시간입니다. 여기 창의성을 자극하고 다음 앱을 위한 몇 가지 아이디어를 제공할 인상적인 애니메이션의 선별된 목록이 준비되어 있습니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*KB2KSwJq06LLyzA2_t-h1w.gif\" alt=\"Animation 1\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*6L8rnyxjfPF-leE0x3Kigg.gif\" alt=\"Animation 2\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*Fb1kzeeAhQVNEf5TTAZlrg.gif\" alt=\"Animated GIF\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*YU3TndEWRtBaNcjXf-JZVg.gif\" alt=\"Animated GIF\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*sMa1sfIYa6Zsl8Co0bCsEQ.gif\" alt=\"Animated GIF\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*N5X0Kbuz7jHxclWzBv-glw.gif\" alt=\"Animated GIF\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*pZ8ddY3rFUoVBuTWAhRPTg.gif\" alt=\"image1\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*bSPbDYoIz9zz3r2mCftWKw.gif\" alt=\"image2\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*utIKDBZ3o_V_-ctf22CBSA.gif\" alt=\"image3\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*Ti1YIVYL67ZQHWDXNX8ZzA.gif\" alt=\"image4\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*948wumPUB-5spDMTYs0Odg.gif\" alt=\"이미지1\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*V4UtSyfCN9DDpl70IxXSHA.gif\" alt=\"이미지2\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*GA_UPaFN6krQMhRb3lGiqw.gif\" alt=\"이미지3\"></p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*m4aMIvlIMY5WGmyFL8q2gA.gif\" alt=\"이미지4\"></p>\n<h1>결론</h1>\n<p>우리의 사용자 정의 새로 고침 애니메이션 자습서가 마무리되었습니다! 아마도 이것이 여러분의 프로젝트에 몇 가지 아이디어를 불러일으켰으면 좋겠네요. 다양한 애니메이션을 실험해보고 해당 앱의 사용자 경험을 어떻게 향상시킬 수 있는지 확인해 보는 것을 권장합니다.</p>\n<p>기억하세요, 배우는 가장 좋은 방법은 직접 해보는 것이기 때문에 고유한 새로 고침 애니메이션을 만들어보는 것에 도전해 보세요. 즐거운 코딩 되세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}