{"pageProps":{"post":{"title":"httpOnly 쿠키로 React 앱 보안을 강화하는 방법","description":"","date":"2024-06-22 03:10","slug":"2024-06-22-UsehttpOnlycookieToSecureYourReactApp","content":"\n\n\n<img src=\"/assets/img/2024-06-22-UsehttpOnlycookieToSecureYourReactApp_0.png\" />\n\n안녕하세요 여러분, 영원한 학습자가 돌아왔어요. 처음 게시물이 백엔드 개발에 관한 것이었으니, 이번에는 프론트엔드 주제에 대해 이야기하기로 했어요. 보안과 관련된 주제를 선택했어요.\n\n사용자 세션을 관리하고 localStorage에 토큰을 저장하기로 결정한다고 상상해보세요. 이 접근 방식은 편리해 보일 수 있지만, 여러분의 토큰을 잠재적인 보안 위험에 노출시키게 됩니다.\n\n외부 사이트 스크립팅 (XSS) 공격을 통해 삽입된 악성 스크립트는 쉽게 localStorage에 접근하여 이러한 토큰을 도용할 수 있어 사용자 계정 및 중요한 정보에 미승인된 액세스를 유발할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 위험을 줄이기 위한 더 안전한 대안은 세션 토큰을 저장하기 위해 httpOnly 쿠키를 사용하는 것입니다.\n\n간단 요약.\n\n이 블로그 포스트는 React 앱에서 httpOnly 쿠키를 사용하는 방법을 설명합니다. 이미 해당 쿠키를 제공하는 API가 있는 것으로 가정합니다.\n\n# HttpOnly 쿠키란 무엇인가\n\n<div class=\"content-ad\"></div>\n\nHttpOnly 쿠키는 서버에서만 액세스할 수 있는 쿠키로, JavaScript와 같은 클라이언트 측 스크립트에서는 액세스할 수 없는 쿠키입니다.\n\nHttpOnly 속성은 Set-Cookie HTTP 응답 헤더에 포함되며, 해당 쿠키가 JavaScript의 Document.cookie API를 통해 액세스할 수 없음을 나타냅니다. 이를 통해 쿠키를 크로스 사이트 스크립팅 (XSS) 공격으로부터 보호하여 보안을 강화합니다.\n\n이러한 관행은 세션 토큰이 도용되거나 남용되는 것을 방지하여 사용자 세션의 기밀성과 무결성을 유지함으로써 웹 응용 프로그램의 보안을 강화합니다.\n\nHttpOnly 쿠키를 구현하는 것은 일반적인 웹 취약점에 대한 응용 프로그램의 방어를 강화하는 간단하고 효과적인 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n# 전제 조건\n\n다음 코드 스니펫은 다음 라이브러리를 사용합니다:\n\n- react-hook-form\n- axios\n- react-query\n- react-router-dom\n\n# 인증 시스템 설정\n\n<div class=\"content-ad\"></div>\n\n우리의 React 앱은 로그인 페이지가 있고 사용자가 로그인한 후에 리소스에 액세스할 것입니다. 로그인 폼 제출 프로세스를 설정하는 방법을 알려드리겠습니다:\n\n## 로그인 폼 제출하기\n\n이미 로그인 폼이 준비되어 있다고 가정하고, 제출 프로세스에 집중해 봅시다:\n\n```js\nimport { LoginFailure } from \"./types/LoginFailure\";\nimport { LoginRequest } from \"./types/LoginRequest\";\nimport { UserInterface } from \"./types/UserInterface\";\nimport { useMutation } from \"@tanstack/react-query\";\nimport { SubmitHandler, useForm } from \"react-hook-form\";\nimport { useAuth } from \"./Service/AuthProvider\";\nimport apiClient from './apiClient';\n\nconst Login = () => {\n  const { mutate, isPending } = useMutation({\n    mutationFn: (data: LoginRequest) => {\n      const config = { withCredentials: true };\n      return apiClient.post<UserInterface | LoginFailure>(\"/login\", data, config);\n    },\n  });\n\n  const { control, handleSubmit } = useForm<LoginRequest>({\n    defaultValues: { email: \"\", password: \"\" },\n  });\n\n  const { logUserIn } = useAuth();\n  const onSubmit: SubmitHandler<LoginRequest> = (formData) => {\n    mutate(formData, {\n      onSuccess: (response) => {\n        logUserIn();\n      },\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {/* 여기에 폼 필드를 넣으세요 */}\n    </form>\n  );\n}\n\nexport default Login;\n```\n\n<div class=\"content-ad\"></div>\n\n## 여기서 우리가 한 일은 무엇인가요 ?\n\n우리는 React 기능 컴포넌트인 Login을 만들었습니다. 이는 폼 핸들링과 뮤테이션 훅을 사용하여 사용자 로그인 기능을 다룹니다.\n\n- useMutation: React Query의 이 훅은 뮤테이션(실제로 서버에서 데이터를 변경하는 API 호출)을 다루는 데 사용됩니다.\n- useForm: React Hook Form에서는 폼 관리에 사용됩니다.\n- useAuth: 사용자 로그인을 포함한 인증 관련 작업을 처리하는 사용자 정의 훅입니다.\n- onSubmit: 폼이 제출될 때 호출되는 함수입니다.\n\nhttpOnly 쿠키를 고려해야 할 사항은 mutationFn 메서드에서 API 호출에 설정한 구성입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// ...\nmutationFn: (data: LoginRequest) => {\n  const config = { withCredentials: true };\n  return apiClient.post<UserInterface | LoginFailure>(\n    \"/login\", data, config\n  );\n},\n// ...\n```\n\n그 구성 없이는 헤더가 손실되어 React 요청이 성공하지 않을 것입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*4CPCLz6E3A5f1RAq5Cbq1A.gif)\n\n## 알아두면 좋은 사항\n\n<div class=\"content-ad\"></div>\n\nCORS 문제를 만날 수 있습니다. 해결하는 방법은 다음과 같습니다:\n\n- Node 백엔드의 경우 cors NPM 모듈을 사용하세요.\n- Symfony PHP 애플리케이션의 경우 NelmioCorsBundle을 사용하세요.\n- 허용된 출처를 설정하도록 웹 서버 구성을 업데이트하세요.\n\n⚠️ 앱과 API가 서로 다른 도메인에 위치하는 경우, API 쿠키의 sameSite 매개변수를 Lax 또는 None으로 설정해야 합니다.\n\nSymfony 앱에서 lexik/LexikJWTAuthenticationBundle을 사용하는 경우 예시가 아래에 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```yaml\nlexik_jwt_authentication:\n  secret_key: '%env(resolve:JWT_SECRET_KEY)%'\n  public_key: '%env(resolve:JWT_PUBLIC_KEY)%'\n  pass_phrase: '%env(resolve:JWT_PASSPHRASE)%'\n\n  token_extractors:\n    cookie:\n      enabled: true\n      name: BEARER\n  set_cookies:\n    BEARER:\n      # Update here to set strict, lax or none\n      samesite: none\n```\n\n# 로그인 후 리소스 가져오기\n\n우리는 login 및 홈페이지로 리디렉트를 처리하는 logUserIn() 메서드를 포함하는 custom hookuserAuth()를 구현할 것입니다.\n\n그리고 예를 들어 홈페이지에서 API 호출을 하게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\nAuthProvier를 구현했습니다.\n\n```js\nimport { Context, ReactNode, createContext, useContext, useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\ntype AuthContextType = {\n  isAuthenticated: boolean;\n  logUserIn: () => void;\n};\n\ntype AuthContextPropsType = {\n  children: ReactNode;\n};\n\nconst AuthContext: Context<AuthContextType | null> =\n  createContext<AuthContextType | null>(null);\n\nexport const AuthProvider = ({ children }: AuthContextPropsType) => {\n  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);\n  const navigate = useNavigate();\n\n  const logUserIn = () => {\n    // 예시를 위해 prop을 설정했지만 여기서 더 많은 작업이 필요합니다\n    setIsAuthenticated(true);\n    // 홈페이지로 리디렉션\n    navigate(\"/\");\n  };\n\n  return (\n    <AuthContext.Provider value={{ isAuthenticated, logUserIn }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error(\n      \"useAuth는 AuthProvider 내에서 사용되어야 합니다. 애플리케이션의 최상위 수준에 AuthProvider를 렌더링하는지 확인해주세요.\"\n    );\n  }\n\n  return context;\n};\n```\n\n여기서 우리는 무엇을 했나요?\n\n사용자 로그인 상태를 관리하고 앱 전체에서 이 상태에 액세스하고 업데이트할 수 있는 방법을 제공하기 위해 인증 컨텍스트를 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n인증 로직의 중앙 처리를 가능하게 합니다. 사용자가 한 번 로그인하면 자동으로 홈페이지로 리디렉션됩니다.\n\n## 홈페이지에서 리소스 가져오기\n\n```js\nimport { useQuery } from 'react-query';\nimport { UseQueryResult, useQuery } from \"@tanstack/react-query\";\nimport apiClient from './apiClient';\n\ntype ApiResponse = {\n  message: string;\n};\n\nexport default function HomeView() {\n  const query = useQuery<ApiResponse, Error>({\n    queryKey: [\"unique_name_example\"],\n    queryFn: async () => {\n      const response = await apiClient.get<ApiResponse>(\"/test\", {\n        withCredentials: true,\n      });\n      return response.data;\n    },\n  });\n  const { data, isFetching, isError, error }: UseQueryResult<ApiResponse, Error> = query;\n\n  return (\n    <>\n      <h1>여기는 API에서 온 메시지입니다</h1>\n      {isFetching && <div>로딩 중</div>}\n      {isError && <div>오류가 발생했습니다: {error?.message}</div>}\n      {!isError && !isFetching && <div>{JSON.stringify(data)}</div>}\n    </>\n  );\n}\n\nexport default Home;\n```\n\n여기서는 API에서 리소스를 가져오기 위해 전통적인 쿼리를 수행했고, credentials 구성도 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n{ withCredentials: true }\n```\n\n이를 통해 세션이 유지됩니다.\n\n이것을 제거하면 멋진 401 Unauthorized HTTP 응답을 받게 될 거에요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:996/1*aY_QKlVYUqtW2JmHjFaO1g.gif\" />\n\n<div class=\"content-ad\"></div>\n\n# 이어서\n\n- HttpOnly 쿠키는 XSS 공격으로부터 세션 토큰을 보호하여 앱의 보안을 강화합니다.\n- CORS를 적절하게 처리하고 SameSite 매개변수를 도메인 설정에 따라 설정하는 것을 기억하세요.\n- 마지막으로, API 호출에서 withCredentials를 true로 설정하면 세션이 유지됩니다.\n\n그리고 이로써 이 주제에 대한 내용이 마무리되었습니다.\n\n도움이 되었으면 좋겠습니다. 가능한 더 효율적으로 만들려고 노력했지만, 중요하지 않다고 생각하는 것은 생략했습니다.","ogImage":{"url":"/assets/img/2024-06-22-UsehttpOnlycookieToSecureYourReactApp_0.png"},"coverImage":"/assets/img/2024-06-22-UsehttpOnlycookieToSecureYourReactApp_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>안녕하세요 여러분, 영원한 학습자가 돌아왔어요. 처음 게시물이 백엔드 개발에 관한 것이었으니, 이번에는 프론트엔드 주제에 대해 이야기하기로 했어요. 보안과 관련된 주제를 선택했어요.</p>\n<p>사용자 세션을 관리하고 localStorage에 토큰을 저장하기로 결정한다고 상상해보세요. 이 접근 방식은 편리해 보일 수 있지만, 여러분의 토큰을 잠재적인 보안 위험에 노출시키게 됩니다.</p>\n<p>외부 사이트 스크립팅 (XSS) 공격을 통해 삽입된 악성 스크립트는 쉽게 localStorage에 접근하여 이러한 토큰을 도용할 수 있어 사용자 계정 및 중요한 정보에 미승인된 액세스를 유발할 수 있습니다.</p>\n<p>이 위험을 줄이기 위한 더 안전한 대안은 세션 토큰을 저장하기 위해 httpOnly 쿠키를 사용하는 것입니다.</p>\n<p>간단 요약.</p>\n<p>이 블로그 포스트는 React 앱에서 httpOnly 쿠키를 사용하는 방법을 설명합니다. 이미 해당 쿠키를 제공하는 API가 있는 것으로 가정합니다.</p>\n<h1>HttpOnly 쿠키란 무엇인가</h1>\n<p>HttpOnly 쿠키는 서버에서만 액세스할 수 있는 쿠키로, JavaScript와 같은 클라이언트 측 스크립트에서는 액세스할 수 없는 쿠키입니다.</p>\n<p>HttpOnly 속성은 Set-Cookie HTTP 응답 헤더에 포함되며, 해당 쿠키가 JavaScript의 Document.cookie API를 통해 액세스할 수 없음을 나타냅니다. 이를 통해 쿠키를 크로스 사이트 스크립팅 (XSS) 공격으로부터 보호하여 보안을 강화합니다.</p>\n<p>이러한 관행은 세션 토큰이 도용되거나 남용되는 것을 방지하여 사용자 세션의 기밀성과 무결성을 유지함으로써 웹 응용 프로그램의 보안을 강화합니다.</p>\n<p>HttpOnly 쿠키를 구현하는 것은 일반적인 웹 취약점에 대한 응용 프로그램의 방어를 강화하는 간단하고 효과적인 방법입니다.</p>\n<h1>전제 조건</h1>\n<p>다음 코드 스니펫은 다음 라이브러리를 사용합니다:</p>\n<ul>\n<li>react-hook-form</li>\n<li>axios</li>\n<li>react-query</li>\n<li>react-router-dom</li>\n</ul>\n<h1>인증 시스템 설정</h1>\n<p>우리의 React 앱은 로그인 페이지가 있고 사용자가 로그인한 후에 리소스에 액세스할 것입니다. 로그인 폼 제출 프로세스를 설정하는 방법을 알려드리겠습니다:</p>\n<h2>로그인 폼 제출하기</h2>\n<p>이미 로그인 폼이 준비되어 있다고 가정하고, 제출 프로세스에 집중해 봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">LoginFailure</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./types/LoginFailure\"</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">LoginRequest</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./types/LoginRequest\"</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">UserInterface</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./types/UserInterface\"</span>;\n<span class=\"hljs-keyword\">import</span> { useMutation } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@tanstack/react-query\"</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">SubmitHandler</span>, useForm } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-hook-form\"</span>;\n<span class=\"hljs-keyword\">import</span> { useAuth } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./Service/AuthProvider\"</span>;\n<span class=\"hljs-keyword\">import</span> apiClient <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./apiClient'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Login</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> { mutate, isPending } = <span class=\"hljs-title function_\">useMutation</span>({\n    <span class=\"hljs-attr\">mutationFn</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">data: LoginRequest</span>) =></span> {\n      <span class=\"hljs-keyword\">const</span> config = { <span class=\"hljs-attr\">withCredentials</span>: <span class=\"hljs-literal\">true</span> };\n      <span class=\"hljs-keyword\">return</span> apiClient.<span class=\"hljs-property\">post</span>&#x3C;<span class=\"hljs-title class_\">UserInterface</span> | <span class=\"hljs-title class_\">LoginFailure</span>>(<span class=\"hljs-string\">\"/login\"</span>, data, config);\n    },\n  });\n\n  <span class=\"hljs-keyword\">const</span> { control, handleSubmit } = useForm&#x3C;<span class=\"hljs-title class_\">LoginRequest</span>>({\n    <span class=\"hljs-attr\">defaultValues</span>: { <span class=\"hljs-attr\">email</span>: <span class=\"hljs-string\">\"\"</span>, <span class=\"hljs-attr\">password</span>: <span class=\"hljs-string\">\"\"</span> },\n  });\n\n  <span class=\"hljs-keyword\">const</span> { logUserIn } = <span class=\"hljs-title function_\">useAuth</span>();\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">onSubmit</span>: <span class=\"hljs-title class_\">SubmitHandler</span>&#x3C;<span class=\"hljs-title class_\">LoginRequest</span>> = <span class=\"hljs-function\">(<span class=\"hljs-params\">formData</span>) =></span> {\n    <span class=\"hljs-title function_\">mutate</span>(formData, {\n      <span class=\"hljs-attr\">onSuccess</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =></span> {\n        <span class=\"hljs-title function_\">logUserIn</span>();\n      },\n    });\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">{handleSubmit(onSubmit)}</span>></span>\n      {/* 여기에 폼 필드를 넣으세요 */}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">form</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Login</span>;\n</code></pre>\n<h2>여기서 우리가 한 일은 무엇인가요 ?</h2>\n<p>우리는 React 기능 컴포넌트인 Login을 만들었습니다. 이는 폼 핸들링과 뮤테이션 훅을 사용하여 사용자 로그인 기능을 다룹니다.</p>\n<ul>\n<li>useMutation: React Query의 이 훅은 뮤테이션(실제로 서버에서 데이터를 변경하는 API 호출)을 다루는 데 사용됩니다.</li>\n<li>useForm: React Hook Form에서는 폼 관리에 사용됩니다.</li>\n<li>useAuth: 사용자 로그인을 포함한 인증 관련 작업을 처리하는 사용자 정의 훅입니다.</li>\n<li>onSubmit: 폼이 제출될 때 호출되는 함수입니다.</li>\n</ul>\n<p>httpOnly 쿠키를 고려해야 할 사항은 mutationFn 메서드에서 API 호출에 설정한 구성입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-attr\">mutationFn</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">data: LoginRequest</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> config = { <span class=\"hljs-attr\">withCredentials</span>: <span class=\"hljs-literal\">true</span> };\n  <span class=\"hljs-keyword\">return</span> apiClient.<span class=\"hljs-property\">post</span>&#x3C;<span class=\"hljs-title class_\">UserInterface</span> | <span class=\"hljs-title class_\">LoginFailure</span>>(\n    <span class=\"hljs-string\">\"/login\"</span>, data, config\n  );\n},\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>그 구성 없이는 헤더가 손실되어 React 요청이 성공하지 않을 것입니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:996/1*4CPCLz6E3A5f1RAq5Cbq1A.gif\" alt=\"image\"></p>\n<h2>알아두면 좋은 사항</h2>\n<p>CORS 문제를 만날 수 있습니다. 해결하는 방법은 다음과 같습니다:</p>\n<ul>\n<li>Node 백엔드의 경우 cors NPM 모듈을 사용하세요.</li>\n<li>Symfony PHP 애플리케이션의 경우 NelmioCorsBundle을 사용하세요.</li>\n<li>허용된 출처를 설정하도록 웹 서버 구성을 업데이트하세요.</li>\n</ul>\n<p>⚠️ 앱과 API가 서로 다른 도메인에 위치하는 경우, API 쿠키의 sameSite 매개변수를 Lax 또는 None으로 설정해야 합니다.</p>\n<p>Symfony 앱에서 lexik/LexikJWTAuthenticationBundle을 사용하는 경우 예시가 아래에 있습니다:</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">lexik_jwt_authentication:</span>\n  <span class=\"hljs-attr\">secret_key:</span> <span class=\"hljs-string\">'%env(resolve:JWT_SECRET_KEY)%'</span>\n  <span class=\"hljs-attr\">public_key:</span> <span class=\"hljs-string\">'%env(resolve:JWT_PUBLIC_KEY)%'</span>\n  <span class=\"hljs-attr\">pass_phrase:</span> <span class=\"hljs-string\">'%env(resolve:JWT_PASSPHRASE)%'</span>\n\n  <span class=\"hljs-attr\">token_extractors:</span>\n    <span class=\"hljs-attr\">cookie:</span>\n      <span class=\"hljs-attr\">enabled:</span> <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">BEARER</span>\n  <span class=\"hljs-attr\">set_cookies:</span>\n    <span class=\"hljs-attr\">BEARER:</span>\n      <span class=\"hljs-comment\"># Update here to set strict, lax or none</span>\n      <span class=\"hljs-attr\">samesite:</span> <span class=\"hljs-string\">none</span>\n</code></pre>\n<h1>로그인 후 리소스 가져오기</h1>\n<p>우리는 login 및 홈페이지로 리디렉트를 처리하는 logUserIn() 메서드를 포함하는 custom hookuserAuth()를 구현할 것입니다.</p>\n<p>그리고 예를 들어 홈페이지에서 API 호출을 하게 될 것입니다.</p>\n<p>AuthProvier를 구현했습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Context</span>, <span class=\"hljs-title class_\">ReactNode</span>, createContext, useContext, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> { useNavigate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-router-dom\"</span>;\n\ntype <span class=\"hljs-title class_\">AuthContextType</span> = {\n  <span class=\"hljs-attr\">isAuthenticated</span>: boolean;\n  <span class=\"hljs-attr\">logUserIn</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-keyword\">void</span>;\n};\n\ntype <span class=\"hljs-title class_\">AuthContextPropsType</span> = {\n  <span class=\"hljs-attr\">children</span>: <span class=\"hljs-title class_\">ReactNode</span>;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">AuthContext</span>: <span class=\"hljs-title class_\">Context</span>&#x3C;<span class=\"hljs-title class_\">AuthContextType</span> | <span class=\"hljs-literal\">null</span>> =\n  createContext&#x3C;<span class=\"hljs-title class_\">AuthContextType</span> | <span class=\"hljs-literal\">null</span>>(<span class=\"hljs-literal\">null</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">AuthProvider</span> = (<span class=\"hljs-params\">{ children }: AuthContextPropsType</span>) => {\n  <span class=\"hljs-keyword\">const</span> [isAuthenticated, setIsAuthenticated] = useState&#x3C;boolean>(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> navigate = <span class=\"hljs-title function_\">useNavigate</span>();\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">logUserIn</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-comment\">// 예시를 위해 prop을 설정했지만 여기서 더 많은 작업이 필요합니다</span>\n    <span class=\"hljs-title function_\">setIsAuthenticated</span>(<span class=\"hljs-literal\">true</span>);\n    <span class=\"hljs-comment\">// 홈페이지로 리디렉션</span>\n    <span class=\"hljs-title function_\">navigate</span>(<span class=\"hljs-string\">\"/\"</span>);\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">AuthContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">isAuthenticated</span>, <span class=\"hljs-attr\">logUserIn</span> }}></span>\n      {children}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">AuthContext.Provider</span>></span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">useAuth</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> context = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">AuthContext</span>);\n  <span class=\"hljs-keyword\">if</span> (!context) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(\n      <span class=\"hljs-string\">\"useAuth는 AuthProvider 내에서 사용되어야 합니다. 애플리케이션의 최상위 수준에 AuthProvider를 렌더링하는지 확인해주세요.\"</span>\n    );\n  }\n\n  <span class=\"hljs-keyword\">return</span> context;\n};\n</code></pre>\n<p>여기서 우리는 무엇을 했나요?</p>\n<p>사용자 로그인 상태를 관리하고 앱 전체에서 이 상태에 액세스하고 업데이트할 수 있는 방법을 제공하기 위해 인증 컨텍스트를 설정했습니다.</p>\n<p>인증 로직의 중앙 처리를 가능하게 합니다. 사용자가 한 번 로그인하면 자동으로 홈페이지로 리디렉션됩니다.</p>\n<h2>홈페이지에서 리소스 가져오기</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { useQuery } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-query'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">UseQueryResult</span>, useQuery } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@tanstack/react-query\"</span>;\n<span class=\"hljs-keyword\">import</span> apiClient <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./apiClient'</span>;\n\ntype <span class=\"hljs-title class_\">ApiResponse</span> = {\n  <span class=\"hljs-attr\">message</span>: string;\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">HomeView</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> query = useQuery&#x3C;<span class=\"hljs-title class_\">ApiResponse</span>, <span class=\"hljs-title class_\">Error</span>>({\n    <span class=\"hljs-attr\">queryKey</span>: [<span class=\"hljs-string\">\"unique_name_example\"</span>],\n    <span class=\"hljs-attr\">queryFn</span>: <span class=\"hljs-keyword\">async</span> () => {\n      <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> apiClient.<span class=\"hljs-property\">get</span>&#x3C;<span class=\"hljs-title class_\">ApiResponse</span>>(<span class=\"hljs-string\">\"/test\"</span>, {\n        <span class=\"hljs-attr\">withCredentials</span>: <span class=\"hljs-literal\">true</span>,\n      });\n      <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">data</span>;\n    },\n  });\n  <span class=\"hljs-keyword\">const</span> { data, isFetching, isError, error }: <span class=\"hljs-title class_\">UseQueryResult</span>&#x3C;<span class=\"hljs-title class_\">ApiResponse</span>, <span class=\"hljs-title class_\">Error</span>> = query;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>여기는 API에서 온 메시지입니다<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      {isFetching &#x26;&#x26; <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>로딩 중<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>}\n      {isError &#x26;&#x26; <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>오류가 발생했습니다: {error?.message}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>}\n      {!isError &#x26;&#x26; !isFetching &#x26;&#x26; <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>{JSON.stringify(data)}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>}\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;\n</code></pre>\n<p>여기서는 API에서 리소스를 가져오기 위해 전통적인 쿼리를 수행했고, credentials 구성도 설정했습니다.</p>\n<pre><code class=\"hljs language-js\">{ <span class=\"hljs-attr\">withCredentials</span>: <span class=\"hljs-literal\">true</span> }\n</code></pre>\n<p>이를 통해 세션이 유지됩니다.</p>\n<p>이것을 제거하면 멋진 401 Unauthorized HTTP 응답을 받게 될 거에요.</p>\n<h1>이어서</h1>\n<ul>\n<li>HttpOnly 쿠키는 XSS 공격으로부터 세션 토큰을 보호하여 앱의 보안을 강화합니다.</li>\n<li>CORS를 적절하게 처리하고 SameSite 매개변수를 도메인 설정에 따라 설정하는 것을 기억하세요.</li>\n<li>마지막으로, API 호출에서 withCredentials를 true로 설정하면 세션이 유지됩니다.</li>\n</ul>\n<p>그리고 이로써 이 주제에 대한 내용이 마무리되었습니다.</p>\n<p>도움이 되었으면 좋겠습니다. 가능한 더 효율적으로 만들려고 노력했지만, 중요하지 않다고 생각하는 것은 생략했습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}