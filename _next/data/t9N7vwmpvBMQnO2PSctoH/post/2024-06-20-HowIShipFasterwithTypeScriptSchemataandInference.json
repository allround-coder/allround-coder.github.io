{"pageProps":{"post":{"title":"제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요","description":"","date":"2024-06-20 02:47","slug":"2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference","content":"\n\n거의 10년 전에 Java 개발자로서 경력을 시작했고, 여전히 변수를 끊임없이 타이핑했던 기억이 나네요! TypeScript로 전향한 후에는 타입 추론에 의존하기 시작했습니다. 이 언어 기능을 넘어서 이를 이해하고 있고, 이 덕분에 일상적으로 많은 키 스트로크를 절약하고 있어요.\n\n명시적 추론을 사용할 수 있다는 것을 깨달았을 때 기쁜 충격을 받았어요. 한 줄로 배열과 반환 타입을 추출할 수 있다는 것이죠!\n\n첫 번째 스키마 라이브러리를 배운 후에 엄청난 획기가 왔어요.\n\n스키마 작성을 마스터한 뒤에는 말로써 일석이조였죠. 런타임에서 수신 데이터를 구문 분석하고 추론된 유형을 컴파일 타임에 사용할 수 있었어요!\n\n<div class=\"content-ad\"></div>\n\n이 발견으로 내 생산성이 향상되었어요. 이로 인해 더 빨리 프로젝트를 완료할 수 있었거든.\n\n왜 빠른 배송이 중요한가요?\n\n경쟁사보다 빨라야 한다고 얘기하는 사람도 있죠...\n\n빠르게 배송하지 않고 꾸준히 하지 않으면, 엔지니어링 프로세스에 문제가 있는 것이라고 볼 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png)\n\n위의 그림 속 핸들을 잡고 있는 사람은 배의 엔지니어링에 대해 의심하고 있는 걸까요?\n\n생산성 향상은 다음과 같은 개념에서 비롯되었습니다.\n\n파싱을 프로젝트의 핵심 요소로 취급하고 계약 프로그래밍을 강제 적용하기 시작했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n먼저, 각 수신 구조를 구문 분석하면 데이터 처리가 시작되기 전에 보안 계층을 도입합니다. 유명한 속담을 바꿔 말하면, 수신 데이터를 테스트하지 않으면 결국 클라이언트가 테스트하게 될 것입니다!\n\n둘째로, 이는 또한 생산 중에 발생할 수 있는 버그의 수를 줄이며, 실행 시 오류를 컴파일 타입 오류로 대체합니다. 컴파일 할 수 없는 프로젝트를 배포해서는 안 됩니다!\n\n세 번째로, 적절한 애플리케이션 모니터링을 통해 구문 분석 오류(PPI를 고려함)를 오류 수집기로 보낼 수 있습니다. 문제가 발생한 위치를 이해하면 피드백 루프를 단축시킬 수 있습니다. 클라이언트가 문제를 알기 전에 문제에 대해 알고 싶습니다.\n\n마지막으로, LLM을 사용하여 스키마를 더 빨리 작성할 수 있습니다. 다시 말해, 인공지능을 습득한 사람들은 아마도 그렇지 않은 사람들의 직업을 대체할 것입니다. 이야기 끝에 별도의 섹션에서 LLM 사용에 대해 논의하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n이야기를 써서 생산성을 향상시키는 발견을 설명했어요. 제 경험에서 배우고, 현재와 미래 프로젝트에 적용해 보세요!\n\n이야기에서 제시된 모든 코드 조각은 Bun 1.1.12에서 코딩하고 테스트했어요.\n\n# 스키마 라이브러리 선택\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_1.png)\n\n<div class=\"content-ad\"></div>\n\n선택은 어려운 결정이죠.\n\n최근 몇 년 동안 다양한 스키마 라이브러리를 사용해봤는데, 특히 Zod, @effect/schema, 그리고 Yup을 주로 사용했어요. 이들은 일반적인 유효성 검증과 파싱에 사용할 때 거의 구별하기 어렵지만, 브랜드 타입이나 숫자 범위를 정의할 때 차이가 나타날 수 있어요.\n\n소프트웨어 엔지니어는 작업에 적합한 도구를 선택해야 해요. 함수형 프로그래밍에 대한 좋은 지원이 필요하다면, 불변성을 보장하고 모나드 구조를 지원하는 @effect/schema가 가장 적합할 거예요.\n\n최소한의 종속성을 유지하고 싶다면, 아무 종속성도 없는 Zod을 선호할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n모든 언급된 라이브러리에 대한 동등한 코드를 제시하겠습니다.\n\n다음 명령어를 사용하여 이들을 설치할 수 있습니다:\n\n```js\nbun install @effect/schema yup zod\n```\n\n## 구문 분석이 검증을 이기는 이유\n\n<div class=\"content-ad\"></div>\n\n제대로 시작하기 전에 TypeScript의 구조적 타이핑과 유효성 검사 및 구문 분석에 미치는 영향을 언급해야 합니다.\n\n두 타입을 비교할 때 컴파일러는 이름을 무시하고 속성 타입만 확인합니다. 예를 들어 다음 타입은 동일하다고 간주됩니다:\n\n```js\ntype User = { id: string };\ntype Company = { id: string };\n```\n\nTypeScript를 사용하기 시작할 때는 명백하지 않을 수 있지만, 더 많은 경험을 쌓으면 감이 올 것입니다. 그러나 객체 리터럴 주변에 더 많은 유의해야 할 점이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n타입 변수를 초기화할 때 컴파일러는 초과 속성에 대한 검사를 실행합니다. 우리는 이 할당의 오른쪽을 오브젝트 리터럴이라고 공식적으로 부릅니다. 다음 스니펫은 컴파일되지 않습니다:\n\n```js\nconst user: User = {\n  id: '1',\n  name: 'test username',\n};\n```\n\n저는 이 언어 기능의 이유에 동의합니다. 선택한 타입을 준수하지 않는다면 타입 변수를 지정하지 않는 것이 좋습니다. 이게 합리적으로 느껴지시나요?\n\n다음 스니펫에서 확인할 수 있듯이 함수에 오브젝트 인자를 전달할 때 초과 속성 검사는 작동하지 않습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  test: 1,\n};\n\nconst canAccessDashboard = (user: User) => (user.claims & 0x01) !== 0;\n\ncanAccessDashboard(userWithExcessProperties);\n```\n\n프로그램은 함수를 통해 데이터가 흐르는 단순한 흐름입니다. 데이터를 구문 분석하면 반복적으로 함수에 전달됩니다. 이제 데이터를 구문 분석해야 하는 이유에 대해 설명하겠습니다.\n\n구조를 검증할 때는 해당 스키마에 적합한지만 확인합니다. 유효성 검사는 새 객체를 생성하지 않습니다. TypeScript에서 원본 구조를 함수에 전달할 때 초과된 속성도 함께 전달될 수 있습니다.\n\n로그에 사용자 데이터를 기록하면 개인 식별 정보를 저장할 수 있습니다! 그래서 그것을 피하기 위해 원하는 속성을 갖는 새 객체를 만들어 데이터를 구문 분석해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_2.png\" />\n\n# 추론\n\n스키마 라이브러리를 사용하여 한 방에 두 마리의 새를 잡고 싶어요. 어떤 API에든 딱 붙어보이지만 그 대신에 어떤 데이터든 수월하게 파싱하고 컴파일러에 대한 형식을 얻고 싶어요.\n\nZod를 사용하여 사용자 스키마를 작성하려면 아래 코드를 작성할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport z, { ZodType } from 'zod';\n\nconst userSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  claims: z.number(),\n}).readonly();\r\n```\n\n이제 사용자 유형을 추론하겠습니다:\n\n```js\r\ntype User = z.infer<typeof userSchema>;\r\n```\n\n이 문장은 다음 코드의 달신이 되었습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n유저 타입을 호출할 때 다음 메소드를 이용하여 구문 분석할 거에요:\n\nconst user: User = userSchema.parse(userWithExcessProperties);\n\n사용자들을 그룹화하고 싶다고 상상해 보세요. 그룹 스키마와 해당 유형을 비슷하게 작성할 거에요:\n\n<div class=\"content-ad\"></div>\n\nconst groupSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  userIds: z.array(z.string()).readonly(),\n  interests: z.array(z.object({\n    id: z.string(),\n    level: z.union([\n      z.literal('low'),\n      z.literal('medium'),\n      z.literal('high')\n    ]),\n  })).readonly(),\n}).readonly();\n\ntype Group = z.infer<typeof groupSchema>;\r\n\n## 추이추론\n\n별도의 변수로 스키마를 추출하지 않고 관심 수준 유형을 추출하는 방법은 무엇인가요?\n\nTypeScript 유형 메커니즘을 활용하여 다음과 같이 작성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\ntype InterestLevel = Group['interests'][number]['level'];\n\n만약 제가 스키마를 별도로 사용하지 않는다면, 제 다른 비즈니스 구조의 일부로 유지합니다.\n\n덧붙여, 최소 추론 규칙을 만들었습니다. 이미 추론한 타입이 있는 경우, 그 하위 타입을 추출하기 위해 다시 추론해서는 안 된다는 것입니다!\n\n## 일반 추론\n\n<div class=\"content-ad\"></div>\n\n이제 좀 더 고급 추론 패턴을 보여드릴게요. 이를 \"일반 추론\"이라고 부르겠어요.\n\n임의의 데이터와 그들의 체크섬을 포함하는 구조를 구문 분석해야 한다고 상상해봅시다. 우리는 이러한 구조를 보통 봉투(envelope)라고 부릅니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_3.png)\n\n그래서 우리는 일반 빌더 함수를 작성할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\nconst buildChecksumEnvelopeSchema = <T>(\n  datumSchema: ZodType<T>\n) => z.object({\n  datum: datumSchema,\n  checksum: z.string(),\n}).readonly();\n\n위의 코드 조각에서 `ZodType<T>`는 일반 타입 T로 구문 분석되는 스키마입니다.\n\n만약 사용자 및 그룹 스키마와 타입을 필요로 한다면, 다음과 같이 타입을 지정할 수 있습니다:\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype UserChecksumEnvelope = z.infer<typeof userEnvelopeSchema>;\ntype GroupChecksumEnvelope = z.infer<typeof groupEnvelopeSchema>;\n\n<div class=\"content-ad\"></div>\n\n만약 우리가 일반적인 envelope 타입을 유지하고 싶다면 어떻게 할까요? 우리는 이를 사용하여 내용을 정확히 모르는 임의의 envelopes에 작업을 수행할 수 있습니다. 예를 들어, 체크섬을 계산하는 것과 같이요.\n\ntype ChecksumEnvelope<T> = z.infer<\n  ReturnType<typeof buildChecksumEnvelopeSchema<T>>\n>;\n\ntype UserChecksumEnvelope = ChecksumEnvelope<User>;\ntype GroupChecksumEnvelope = ChecksumEnvelope<Group>;\n\n## 단수 schema\n\n스키마를 사용할 때, 저는 단수 구조만을 정의하는 것을 선호합니다. 예를 들어, 다음과 같이 작성하지 않겠습니다:\n\n<div class=\"content-ad\"></div>\n\nconst usersSchema = z.array(userSchema);\ntype Users = z.infer<typeof usersSchema>;\n\n가능하다면 복수형 타입을 정의하지 않겠어요. 배열에는 `ReadonlyArray<User>`나 `User[]`를 사용할 거에요. 혼란을 피하고 다른 명명 규칙을 만들지 않기 위해 가능한 한 타입 별칭을 적게 사용하려고 해요.\n\n## 내보내기\n\n일반적으로 schema와 비즈니스 구조체의 유추된 타입을 내보내요. 다른 개발자들이 혼란스럽지 않도록 helper schema를 절대 내보내지 않아요. 가져올 수 있는 문장을 줄이기 위해 노력해요.\n\n<div class=\"content-ad\"></div>\n\n# 불변성\n\n저는 불변성의 충실한 지지자입니다.\n\n새로운 변수를 생성할 때만 데이터가 변경되므로 코드를 분석하기가 더 쉽다고 생각합니다. 제 스키마는 불변성을 일등 시민 개념으로 취급하길 원합니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_4.png)\n\n<div class=\"content-ad\"></div>\n\n불변성을 사용하는 것은 프로그래밍 언어의 규칙을 제한하기 위해 사슬을 사용하는 것과 같습니다. 깨지기 쉬운 링크만 깨뜨리면 됩니다. 저희 경우에는 스키마가 그런 링크일 수 있습니다.\n\nZod 스키마를 불변하게 만들기 위해 readonly 메서드를 호출합니다. Zod는 자동으로 불변의 추론된 유형을 생성합니다.\n\n예를 들어, 아래에 명시된 것처럼 그룹 스키마는 이미 불변성 원칙을 준수합니다:\n\nconst groupSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  userIds: z.array(z.string()).readonly(),\n  interests: z.array(z.object({\n    id: z.string(),\n    level: z.union([\n      z.literal('low'),\n      z.literal('medium'),\n      z.literal('high'),\n    ]),\n  })).readonly(),\n}).readonly();\n\n<div class=\"content-ad\"></div>\n\n만약 추론된 타입을 준수하는 인스턴스를 생성할 때 불변성에서 일시적으로 벗어나고 싶다면 어떻게 해야 할까요?\n\n해당 readonly 수정자를 무효화하는 타입을 사용해야 합니다. 일부 스키마에는 충분하지 않을 수도 있습니다. ReadonlyArray 타입을 가변으로 만들려면 어떻게 해야 할까요? 그리고 ReadonlySet은 어떻게 해야 할까요? ReadonlyMap은요?\n\n우리는 많은 실수를 저지르지 말고 전용 라이브러리를 사용해야 합니다. 예를 들어, ts-essentials 라이브러리와 많은 다른 라이브러리가 관련된 타입을 포함하고 있습니다.\n\n다음 명령어를 입력하여 설치할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nbun install ts-essentials\n\n이제 아래의 코드를 작성할 수 있습니다:\n\nimport type { DeepWritable } from ‘ts-essentials’;\n\ntype WritableGroup = DeepWritable<Group>;\n\n# Enumerations\n\n<div class=\"content-ad\"></div>\n\nZod에서 열거형을 정의하는 세 가지 방법이 있습니다:\n\n- 네이티브 열거형 사용\n- Zod의 리터럴 유니언 사용\n- Zod의 열거형 사용\n\n각 방법은 적절한 구문 분석과 유추된 유형을 제공합니다. 차이점은 열거된 모든 값을 액세스하는 데 있습니다.\n\n예를 들어, 언어 목록이 있다면 사용자의 선택을 유효성 검사하고 목록을 프론트 엔드에 전송하여 드롭다운에서 표시해야 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_5.png\" />\n\n## 네이티브 열거\n\nTypeScript를 사용하면 컴파일 시에 존재하고 런타임에도 존재하는 열거형(enum) 타입을 선언할 수 있습니다. 예를 들어, 다음과 같이 관심 수준을 나타내는 enum을 정의할 수 있습니다:\n\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n};\n\n<div class=\"content-ad\"></div>\n\nZod는 열거 유형에서 스키마를 작성하는 방법을 제공합니다. 아래 코드 스니펫에서와 같이:\n\nconst interestLevelSchema = z.nativeEnum(InterestLevel);\n\n만약 const 키워드로 InterestLevel 열거 유형을 선언했다면, 이전에는 컴파일 시간에만 존재했기 때문에 Zod 도우미를 사용할 수 없었습니다.\n\n열거된 모든 값을 추출하려면 다음 코드를 작성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nconst interestLevels = Object.values(InterestLevel);\n\n## Zod의 리터럴 유니언\n\n다른 패턴을 사용하여 열거 스키마를 정의할 수 있습니다. 결국, 열거는 문자열 또는 숫자 리터럴의 유니언입니다.\n\n각 관심 수준 리터럴에 대한 스키마를 작성해 봅시다:\n\n<div class=\"content-ad\"></div>\n\nconst interestLevelLiteralSchemata = [\n  z.literal('low'),\n  z.literal('medium'),\n  z.literal('high'),\n] as const;\n\n자 이제 적절한 스키마와 타입을 정의할 시간입니다:\n\nconst interestLevelSchema = z.union(interestLevelLiteralSchemata);\ntype InterestLevel = z.infer<typeof interestLevelSchema>;\n\n마지막으로, 모든 열거된 값을 추출할 수 있습니다:  \n\n<div class=\"content-ad\"></div>\n\nconst interestLevels = interestLevelLiteralSchemata\n  .map((literal) => literal.value);\n\n## 조드의 열거\n\n열거 스키마를 정의하는 내가 가장 좋아하는 방법은 조드의 열거 도우미를 사용하는 것입니다.\n\n다음과 같은 방법으로 스키마를 작성하고 타입을 추론할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nconst interestLevelSchema = z.enum(['low', 'medium', 'high']);\ntype InterestLevel = z.infer<typeof interestLevelSchema>;\n\n모든 열거된 값 추출을 한 줄로 처리할 수 있습니다:\n\nconst interestLevels = interestLevelSchema.options;\n\n# 구분된 연합(Unions)\n```\n\n<div class=\"content-ad\"></div>\n\n일반적인 유니언 타입에서는 컴파일러가 많은 서로 다른 타입을 구분합니다. 디스크리미네이트 유니언에서는 컴파일러가 공유 프로퍼티를 기준으로 구분합니다. 예를 들어, 애플리케이션의 작업을 특정 액터인 사용자 또는 그룹에 할당할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_6.png)\n\n제가 액터 스키마를 구현하고 다음과 같이 타입을 추론할 것입니다:\n\n```js\nconst userActorSchema = z.object({\n  type: z.literal('user'),\n  id: z.string(),\n});\n\nconst groupActorSchema = z.object({\n  type: z.literal('group'),\n  id: z.string(),\n});\n\nconst actorSchema = z.discriminatedUnion(\n  \"type\",\n  [userActorSchema, groupActorSchema],\n).readonly();\n\ntype Actor = z.infer<typeof actorSchema>;\n```\n\n<div class=\"content-ad\"></div>\n\n내 선택에는 설명이 필요해요!\n\n먼저, 사용자와 그룹 액터의 스키마를 명시적으로 정의했어요. 이 방법은 구분된 연합의 각 구성 요소를 명명하고 들여쓰기 수준을 낮게 유지하죠.\n\n누군가 액터 스키마를 읽으면, 여러 줄로 이루어진 스키마를 읽지 않아도 내 의도를 즉시 추측할 거에요!\n\n둘째, 액터 유형을 스키마에서 추론했어요. 코드 베이스에서 연합 유형의 연산이 멤버 대신 발생하기를 기대하죠.\n\n<div class=\"content-ad\"></div>\n\n세 번째로, 나는 사용자의 종류와 그룹 활동자의 유형을 추론하지 않았어. 나중에 그들을 정의해야 한다면, 다음 패턴을 사용하여 그렇게 할 수 있을 것 같아:\n\n```js\ntype UserActor1 = z.infer<typeof userActorSchema>;\ntype UserActor2 = Extract<Actor, { type: 'user' }>;\ntype UserActor3 = Actor & { type: 'user' };\n```\n\n각각이 동일한 결과를 가져오는 것에도 불구하고, 나는 첫 번째 것을 사용하지 않을 거야. 왜냐하면 그것은 최소한 추론 규칙에 어긋나기 때문이야. 이미 활동자 유형을 추론을 통해 얻었다면 TypeScript 유형 도우미를 사용하여 더 정확한 유형을 추출할 수 있어.\n\n그리고 discriminatedUnion 메서드를 사용하여 식별 속성의 이름을 명시해야 하는 이유를 궁금해할 수도 있어. 일치시켜야 할 내용을 알면 Zod가 적합한 스키마를 빠르게 찾을 수 있어. 이러한 최적화를 피하고 싶다면 union 도우미를 사용할 수도 있었겠지.\n\n<div class=\"content-ad\"></div>\n\n# 기존 유형 변환\n\n기존 TypeScript 프로젝트에는 많은 유형이 포함되어 있을 것입니다. 이를 수동으로 작성하는 것은 여러분의 시간을 낭비하는 일입니다. 대신 LLM 또는 코드 완성 도구를 사용할 수 있습니다. 정확한 법적 조언은 제공하지 않겠지만, 소유 코드베이스에서 이러한 기술을 사용할 수 있는지 항상 확인합니다.\n\n각 LLM 제공업체는 모델에 제공하는 데이터에 대해 무엇이 발생하는지 알려줄 것입니다!\n\n특정 LLM을 추천하지는 않겠지만, 주요 모델들이 이 문제를 상당히 잘 처리합니다. 유형을 정의하고 스키마 정의를 시작해보세요. 몇 번 시도한 후에는 고품질 자동완성 스키마가 나올 것입니다.\n\n<div class=\"content-ad\"></div>\n\nLLM을 완전히 믿지 마세요. 항상 결과를 검증해야 합니다!\n\n다양한 유형이 있다면, 먼저 그들의 정규 표현을 얻는 것을 추천합니다. AST 추출기를 작성하거나 TypeScript Language Server에 요청하여 이를 수행하거나, LLM이 작업을 처리하도록 할 수 있습니다. 처음 두 가지 가능성에 대해 LLM을 사용할 수 있습니다!\n\n정규 표현을 구문 분석하여 스키마를 생성하는 스크립트를 작성할 수 있습니다. 가장 큰 어려움은 스키마를 생성하는 것이 아니라 구문 분석에 사용하는 것입니다. 프로젝트 아키텍처의 완전한 변경이 필요할 수도 있습니다!\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_7.png)\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n나는 스키마와 유형 추론을 사용하는 것에 대한 설득력있는 주장을 펼쳤기를 희망합니다, 특히 LLMs와 함께. 아니라면, 의견을 남겨주세요! 다양한 기술적 주제에 대해 토론하는 것을 좋아합니다.\n\n가장 중요한 포인트를 되풀이하자면, 데이터를 단순히 유효성 검사하는 것이 아니라 파싱해야 한다고 생각합니다. 우리는 스키마를 작성하고 그로부터 유형을 추론해야 합니다. 나는 불변성을 지지하며 이 패러다임을 준수하는 스키마를 선호합니다. 또한 열거 유형 대신 스키마 리터럴을 사용하는 것을 좋아합니다.\n\n나는 내 코드가 파싱되지 않은 데이터에서 실행되지 않기 때문에 보다 빠르게 배포할 수 있습니다. 컴파일 시간 오류만 만날 것이라고 믿습니다. 애플리케이션 모니터링 덕분에 파싱이 실패할 때를 알 수 있습니다. 나는 LLM을 사용하여 스키마를 작성하고 유형을 더 빨리 추론할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이야기의 개념을 설명하는 부록을 작성했습니다. 이번에는 다른 스키마 라이브러리를 사용하여 @effect/schema와 yup을 설명합니다.\n\n# 부록 A: @effect/schema\n\n사용자 스키마를 정의하기 위해 다음과 같이 작성해야 합니다:\n\n```js\nimport { Schema } from \"@effect/schema\"\n\nconst userSchema = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  claims: Schema.Number,\n});\n```\n\n<div class=\"content-ad\"></div>\n\n사용자 스키마는 이미 불변성을 준수합니다. 아래 스니펫을 사용하여 사용자 유형을 추론할 수 있습니다:\n\n```js\ntype User = Schema.Schema.Type<typeof userSchema>;\n```\n\n위의 type helper는 다음 코드와 동일합니다:\n\n```js\ntype User = typeof userSchema.Type;\n```\n\n<div class=\"content-ad\"></div>\n\n라이브러리는 객체를 구문 분석하고 초과 속성을 허용하지 않습니다. 아래 내용을 확인해주세요:\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  excessProperty: 1,\n};\n\nconst user = Schema.decodeSync(userSchema)(userWithExcessProperties);\n```\n\n그룹 스키마와 해당 유형은 사용자 스키마와 유사하게 정의할 수 있습니다:\n\n```js\nconst groupSchema = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  userIds: Schema.Array(Schema.String),\n  interests: Schema.Array(\n    Schema.Struct({\n      id: Schema.String,\n      level: Schema.Union(\n        Schema.Literal('low'),\n        Schema.Literal('medium'),\n        Schema.Literal('high'),\n      ),\n    })\n  ),\n});\n\ntype Group = Schema.Schema.Type<typeof groupSchema>;\n```\n\n<div class=\"content-ad\"></div>\n\n일반적인 추론을 달성하기 위해 다음 코드를 작성합니다:\n\n```js\nconst buildChecksumEnvelopeSchema = <T>(\n  datumSchema: Schema.Schema<T>\n) => Schema.Struct({\n  datum: datumSchema,\n  checksum: Schema.String,\n});\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype ChecksumEnvelope<T> = Schema.Schema.Type<\n  ReturnType<typeof buildChecksumEnvelopeSchema<T>>\n>;\n\ntype UserChecksumEnvelope = ChecksumEnvelope<User>;\ntype GroupChecksumEnvelope = ChecksumEnvelope<Group>;\n```\n\n@effect/schema를 사용하여 열거 스키마를 정의하는 세 가지 방법을 찾았습니다.\n\n첫 번째 방법은 리터럴의 합집합을 사용하는 것입니다. 아래 예제를 살펴보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst interestLevelSchema = Schema.Union(\n  Schema.Literal('low'),\n  Schema.Literal('medium'),\n  Schema.Literal('high'),\n);\n\ntype InterestLevel = Schema.Schema.Type<typeof interestLevelSchema>;\n```\n\n스키마 속성에 액세스하여 관심 수준 목록을 추출할 수 있습니다. 아래에 나와있는 것처럼:\n\n```js\nconst interestLevels = interestLevelSchema\n  .members\n  .flatMap((member) => member.literals);\n```\n\n두 번째 접근 방법은 스키마 리터럴 도우미를 사용하는 것입니다. 한 줄로 스키마를 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst interestLevelSchema = Schema.Literal(‘low’, ‘medium’, ‘high’);\n```\n\n우리는 모든 값을 가져 오기위한 한 줄짜리도 사용할 것입니다:\n\n```js\nconst interestLevels = interestLevelSchema.literals;\n```\n\n이 라이브러리를 사용하면 네이티브 열거 유형을 사용할 수 있습니다! 다음 조각을 살펴보세요:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n}\n\nconst interestLevelSchema = Schema.Enums(InterestLevel)\nconst interestLevels = Object.values(InterestLevel);\n```\n\n차별화 된 연합을 정의하는 것이 더 간단하지 않았을 것입니다. 아래 코드 조각을 읽어보세요.\n\n```js\nconst userActorSchema = Schema.Struct({\n  type: Schema.Literal('user'),\n  id: Schema.String,\n});\n\nconst groupActorSchema = Schema.Struct({\n  type: Schema.Literal('group'),\n  id: Schema.String,\n});\n\nconst actorSchema = Schema.Union(userActorSchema, groupActorSchema);\ntype Actor = Schema.Schema.Type<typeof actorSchema>;\n```\n\n# 부록 B : Yup\n\n\n<div class=\"content-ad\"></div>\n\nYup을 사용한 사용자 스키마는 다음과 같습니다:\n\n```js\nimport Yup from ‘yup’;\n\nconst userSchema = Yup.object({\n  id: Yup.string().required(),\n  name: Yup.string().required(),\n  claims: Yup.number().required(),\n}).noUnknown();\n```\n\n이 라이브러리에는 두 가지 주의 사항이 있습니다. 먼저, 필수 도우미를 사용하여 비널 값 받아들이기, 두 번째로 초과 속성을 제외하려면 noUnknown 도우미를 사용해야 합니다.\n\n하지만, 여기에 더 많은 내용이 있습니다!\n\n<div class=\"content-ad\"></div>\n\n추론된 유형에서 스키마를 불변성을 보장하도록 강제하는 방법을 찾지 못했습니다. 다음과 같이 ts-essentials 라이브러리의 DeepReadonly 유형 도우미를 사용해야 했습니다:\n\n```js\ntype User = DeepReadonly<Yup.InferType<typeof userSchema>>;\n```\n\n위의 유형은 다음과 같습니다:\n\n```js\ntype User = DeepReadonly<typeof userSchema['__outputType']>;\n```\n\n<div class=\"content-ad\"></div>\n\n도서관은 내가 정의한 구문 분석을 수행하는 validateSync라는 메서드를 제공합니다:\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  excessProperty: 1,\n};\n\nconst user = userSchema.validateSync(userWithExcessProperties);\n```\n\n그룹 스키마를 다음 형식으로 정의하기를 제안합니다:\n\n```js\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n}\n\nconst groupSchema = Yup.object({\n  id: Yup.string().required(),\n  name: Yup.string().required(),\n  userIds: Yup.array(\n    Yup.string().required()\n  ).required(),\n  interests: Yup.array(\n    Yup.object({\n      id: Yup.string().required(),\n      level: Yup.mixed<InterestLevel>()\n        .oneOf(Object.values(InterestLevel))\n        .required(),\n    })\n  ).required(),\n}).noUnknown();\n\ntype Group = DeepReadonly<Yup.InferType<typeof groupSchema>>;\n```\n\n<div class=\"content-ad\"></div>\n\n만약 주의깊게 살펴봤다면, 관심 수준을 위한 enum 형식을 볼 수 있었을 것입니다. 곧 enum을 사용하는 이유에 대해 설명할 것입니다.\n\n아래 예제에서 제시된대로 제네릭 추론을 달성할 수 있습니다:\n\n```js\nconst buildChecksumEnvelopeSchema = <T>(\n  datumSchema: Yup.Schema<T>\n) => Yup.object({\n  datum: datumSchema,\n  checksum: Yup.string().required(),\n}).noUnknown();\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype UserChecksumEnvelope = DeepReadonly<\n  Yup.InferType<typeof userEnvelopeSchema>\n>;\n\ntype GroupChecksumEnvelope = DeepReadonly<\n  Yup.InferType<typeof groupEnvelopeSchema>\n>;\n\ntype ChecksumEnvelope<T> = DeepReadonly<\n  Yup.InferType<ReturnType<typeof buildChecksumEnvelopeSchema<T>>>\n>;\n\ntype UserChecksumEnvelope = ChecksumEnvelope<User>;\ntype GroupChecksumEnvelope = ChecksumEnvelope<Group>;\n```\n\n약속한 대로, Yup에서 enum 유형을 사용하는 것이 가장 합리적인 이유를 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 열거형 유형의 스키마를 손쉽게 만들 수 있습니다:\n\n```js\nconst interestLevelSchema = Yup.mixed<InterestLevel>()\n  .oneOf(Object.values(InterestLevel))\n  .required();\n```\n\n모든 값을 배열로 먼저 정의해야하는 두 번째 방법도 있습니다:\n\n```js\nconst interestLevels = [\n  'low',\n  'medium',\n  'high',\n] as const;\n\ntype InterestLevel = typeof interestLevels[number];\n```\n\n<div class=\"content-ad\"></div>\n\n다음은 한 줄로 스키마를 작성할 수 있습니다:\n\n```js\nconst interestLevelSchema = Yup.mixed<InterestLevel>()\n  .oneOf(interestLevels)\n  .required();\n```\n\n여기에는 공용 체계에 대한 스키마를 작성하는 상세한 지침이 있어야 합니다. 유감스럽게도 Yup을 사용하여 지원하는 것을 찾지 못했습니다. 그러나 해결책을 찾았습니다.\n\n스키마 시퀀스가 있는 경우, 각 스키마를 사용하여 객체를 구문 분석하는 함수를 작성하여 일치하는 것을 찾을 때까지 시도할 수 있습니다. 빠르게 작성하는 데 도움이 되는 LLM을 사용할 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n설정된 제한 시간이 초과되어 서비스에 영향을 줄 수 있습니다. 해당 작업에 대한 피드백이 필요하신 경우 언제든지 알려주세요!","ogImage":{"url":"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png"},"coverImage":"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png","tag":["Tech"],"readingTime":19},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>거의 10년 전에 Java 개발자로서 경력을 시작했고, 여전히 변수를 끊임없이 타이핑했던 기억이 나네요! TypeScript로 전향한 후에는 타입 추론에 의존하기 시작했습니다. 이 언어 기능을 넘어서 이를 이해하고 있고, 이 덕분에 일상적으로 많은 키 스트로크를 절약하고 있어요.</p>\n<p>명시적 추론을 사용할 수 있다는 것을 깨달았을 때 기쁜 충격을 받았어요. 한 줄로 배열과 반환 타입을 추출할 수 있다는 것이죠!</p>\n<p>첫 번째 스키마 라이브러리를 배운 후에 엄청난 획기가 왔어요.</p>\n<p>스키마 작성을 마스터한 뒤에는 말로써 일석이조였죠. 런타임에서 수신 데이터를 구문 분석하고 추론된 유형을 컴파일 타임에 사용할 수 있었어요!</p>\n<p>이 발견으로 내 생산성이 향상되었어요. 이로 인해 더 빨리 프로젝트를 완료할 수 있었거든.</p>\n<p>왜 빠른 배송이 중요한가요?</p>\n<p>경쟁사보다 빨라야 한다고 얘기하는 사람도 있죠...</p>\n<p>빠르게 배송하지 않고 꾸준히 하지 않으면, 엔지니어링 프로세스에 문제가 있는 것이라고 볼 수 있어요.</p>\n<p><img src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png\" alt=\"이미지\"></p>\n<p>위의 그림 속 핸들을 잡고 있는 사람은 배의 엔지니어링에 대해 의심하고 있는 걸까요?</p>\n<p>생산성 향상은 다음과 같은 개념에서 비롯되었습니다.</p>\n<p>파싱을 프로젝트의 핵심 요소로 취급하고 계약 프로그래밍을 강제 적용하기 시작했습니다.</p>\n<p>먼저, 각 수신 구조를 구문 분석하면 데이터 처리가 시작되기 전에 보안 계층을 도입합니다. 유명한 속담을 바꿔 말하면, 수신 데이터를 테스트하지 않으면 결국 클라이언트가 테스트하게 될 것입니다!</p>\n<p>둘째로, 이는 또한 생산 중에 발생할 수 있는 버그의 수를 줄이며, 실행 시 오류를 컴파일 타입 오류로 대체합니다. 컴파일 할 수 없는 프로젝트를 배포해서는 안 됩니다!</p>\n<p>세 번째로, 적절한 애플리케이션 모니터링을 통해 구문 분석 오류(PPI를 고려함)를 오류 수집기로 보낼 수 있습니다. 문제가 발생한 위치를 이해하면 피드백 루프를 단축시킬 수 있습니다. 클라이언트가 문제를 알기 전에 문제에 대해 알고 싶습니다.</p>\n<p>마지막으로, LLM을 사용하여 스키마를 더 빨리 작성할 수 있습니다. 다시 말해, 인공지능을 습득한 사람들은 아마도 그렇지 않은 사람들의 직업을 대체할 것입니다. 이야기 끝에 별도의 섹션에서 LLM 사용에 대해 논의하겠습니다.</p>\n<p>이야기를 써서 생산성을 향상시키는 발견을 설명했어요. 제 경험에서 배우고, 현재와 미래 프로젝트에 적용해 보세요!</p>\n<p>이야기에서 제시된 모든 코드 조각은 Bun 1.1.12에서 코딩하고 테스트했어요.</p>\n<h1>스키마 라이브러리 선택</h1>\n<p><img src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_1.png\" alt=\"이미지\"></p>\n<p>선택은 어려운 결정이죠.</p>\n<p>최근 몇 년 동안 다양한 스키마 라이브러리를 사용해봤는데, 특히 Zod, @effect/schema, 그리고 Yup을 주로 사용했어요. 이들은 일반적인 유효성 검증과 파싱에 사용할 때 거의 구별하기 어렵지만, 브랜드 타입이나 숫자 범위를 정의할 때 차이가 나타날 수 있어요.</p>\n<p>소프트웨어 엔지니어는 작업에 적합한 도구를 선택해야 해요. 함수형 프로그래밍에 대한 좋은 지원이 필요하다면, 불변성을 보장하고 모나드 구조를 지원하는 @effect/schema가 가장 적합할 거예요.</p>\n<p>최소한의 종속성을 유지하고 싶다면, 아무 종속성도 없는 Zod을 선호할 수 있어요.</p>\n<p>모든 언급된 라이브러리에 대한 동등한 코드를 제시하겠습니다.</p>\n<p>다음 명령어를 사용하여 이들을 설치할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">bun install @effect/schema yup zod\n</code></pre>\n<h2>구문 분석이 검증을 이기는 이유</h2>\n<p>제대로 시작하기 전에 TypeScript의 구조적 타이핑과 유효성 검사 및 구문 분석에 미치는 영향을 언급해야 합니다.</p>\n<p>두 타입을 비교할 때 컴파일러는 이름을 무시하고 속성 타입만 확인합니다. 예를 들어 다음 타입은 동일하다고 간주됩니다:</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">User</span> = { <span class=\"hljs-attr\">id</span>: string };\ntype <span class=\"hljs-title class_\">Company</span> = { <span class=\"hljs-attr\">id</span>: string };\n</code></pre>\n<p>TypeScript를 사용하기 시작할 때는 명백하지 않을 수 있지만, 더 많은 경험을 쌓으면 감이 올 것입니다. 그러나 객체 리터럴 주변에 더 많은 유의해야 할 점이 있습니다.</p>\n<p>타입 변수를 초기화할 때 컴파일러는 초과 속성에 대한 검사를 실행합니다. 우리는 이 할당의 오른쪽을 오브젝트 리터럴이라고 공식적으로 부릅니다. 다음 스니펫은 컴파일되지 않습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">user</span>: <span class=\"hljs-title class_\">User</span> = {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'1'</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'test username'</span>,\n};\n</code></pre>\n<p>저는 이 언어 기능의 이유에 동의합니다. 선택한 타입을 준수하지 않는다면 타입 변수를 지정하지 않는 것이 좋습니다. 이게 합리적으로 느껴지시나요?</p>\n<p>다음 스니펫에서 확인할 수 있듯이 함수에 오브젝트 인자를 전달할 때 초과 속성 검사는 작동하지 않습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> userWithExcessProperties = {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'1'</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Alice'</span>,\n  <span class=\"hljs-attr\">claims</span>: <span class=\"hljs-number\">0x02</span>,\n  <span class=\"hljs-attr\">test</span>: <span class=\"hljs-number\">1</span>,\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">canAccessDashboard</span> = (<span class=\"hljs-params\">user: User</span>) => (user.<span class=\"hljs-property\">claims</span> &#x26; <span class=\"hljs-number\">0x01</span>) !== <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-title function_\">canAccessDashboard</span>(userWithExcessProperties);\n</code></pre>\n<p>프로그램은 함수를 통해 데이터가 흐르는 단순한 흐름입니다. 데이터를 구문 분석하면 반복적으로 함수에 전달됩니다. 이제 데이터를 구문 분석해야 하는 이유에 대해 설명하겠습니다.</p>\n<p>구조를 검증할 때는 해당 스키마에 적합한지만 확인합니다. 유효성 검사는 새 객체를 생성하지 않습니다. TypeScript에서 원본 구조를 함수에 전달할 때 초과된 속성도 함께 전달될 수 있습니다.</p>\n<p>로그에 사용자 데이터를 기록하면 개인 식별 정보를 저장할 수 있습니다! 그래서 그것을 피하기 위해 원하는 속성을 갖는 새 객체를 만들어 데이터를 구문 분석해야 합니다.</p>\n<h1>추론</h1>\n<p>스키마 라이브러리를 사용하여 한 방에 두 마리의 새를 잡고 싶어요. 어떤 API에든 딱 붙어보이지만 그 대신에 어떤 데이터든 수월하게 파싱하고 컴파일러에 대한 형식을 얻고 싶어요.</p>\n<p>Zod를 사용하여 사용자 스키마를 작성하려면 아래 코드를 작성할 수 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> z, { <span class=\"hljs-title class_\">ZodType</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'zod'</span>;\n\n<span class=\"hljs-keyword\">const</span> userSchema = z.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">id</span>: z.<span class=\"hljs-title function_\">string</span>(),\n  <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n  <span class=\"hljs-attr\">claims</span>: z.<span class=\"hljs-title function_\">number</span>(),\n}).<span class=\"hljs-title function_\">readonly</span>();\n</code></pre>\n<p>이제 사용자 유형을 추론하겠습니다:</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">User</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> userSchema>;\n</code></pre>\n<p>이 문장은 다음 코드의 달신이 되었습니다:</p>\n<pre><code class=\"hljs language-js\">유저 타입을 호출할 때 다음 메소드를 이용하여 구문 분석할 거에요:\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">user</span>: <span class=\"hljs-title class_\">User</span> = userSchema.<span class=\"hljs-title function_\">parse</span>(userWithExcessProperties);\n\n사용자들을 그룹화하고 싶다고 상상해 보세요. 그룹 스키마와 해당 유형을 비슷하게 작성할 거에요:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-keyword\">const</span> groupSchema = z.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">id</span>: z.<span class=\"hljs-title function_\">string</span>(),\n  <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n  <span class=\"hljs-attr\">userIds</span>: z.<span class=\"hljs-title function_\">array</span>(z.<span class=\"hljs-title function_\">string</span>()).<span class=\"hljs-title function_\">readonly</span>(),\n  <span class=\"hljs-attr\">interests</span>: z.<span class=\"hljs-title function_\">array</span>(z.<span class=\"hljs-title function_\">object</span>({\n    <span class=\"hljs-attr\">id</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">level</span>: z.<span class=\"hljs-title function_\">union</span>([\n      z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'low'</span>),\n      z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'medium'</span>),\n      z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'high'</span>)\n    ]),\n  })).<span class=\"hljs-title function_\">readonly</span>(),\n}).<span class=\"hljs-title function_\">readonly</span>();\n\ntype <span class=\"hljs-title class_\">Group</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> groupSchema>;\r\n\n## 추이추론\n\n별도의 변수로 스키마를 추출하지 않고 관심 수준 유형을 추출하는 방법은 무엇인가요?\n\n<span class=\"hljs-title class_\">TypeScript</span> 유형 메커니즘을 활용하여 다음과 같이 작성할 수 있습니다.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\ntype <span class=\"hljs-title class_\">InterestLevel</span> = <span class=\"hljs-title class_\">Group</span>[<span class=\"hljs-string\">'interests'</span>][number][<span class=\"hljs-string\">'level'</span>];\n\n만약 제가 스키마를 별도로 사용하지 않는다면, 제 다른 비즈니스 구조의 일부로 유지합니다.\n\n덧붙여, 최소 추론 규칙을 만들었습니다. 이미 추론한 타입이 있는 경우, 그 하위 타입을 추출하기 위해 다시 추론해서는 안 된다는 것입니다!\n\n## 일반 추론\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n이제 좀 더 고급 추론 패턴을 보여드릴게요. 이를 <span class=\"hljs-string\">\"일반 추론\"</span>이라고 부르겠어요.\n\n임의의 데이터와 그들의 체크섬을 포함하는 구조를 구문 분석해야 한다고 상상해봅시다. 우리는 이러한 구조를 보통 봉투(envelope)라고 부릅니다.\n\n![이미지](<span class=\"hljs-regexp\">/assets/img</span><span class=\"hljs-regexp\">/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_3.png)\n\n그래서 우리는 일반 빌더 함수를 작성할 수 있어요:\n\n&#x3C;div class=\"content-ad\">&#x3C;/</span>div>\n\n<span class=\"hljs-keyword\">const</span> buildChecksumEnvelopeSchema = &#x3C;T><span class=\"hljs-function\">(<span class=\"hljs-params\">\n  datumSchema: ZodType&#x3C;T>\n</span>) =></span> z.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">datum</span>: datumSchema,\n  <span class=\"hljs-attr\">checksum</span>: z.<span class=\"hljs-title function_\">string</span>(),\n}).<span class=\"hljs-title function_\">readonly</span>();\n\n위의 코드 조각에서 <span class=\"hljs-string\">`ZodType&#x3C;T>`</span>는 일반 타입 T로 구문 분석되는 스키마입니다.\n\n만약 사용자 및 그룹 스키마와 타입을 필요로 한다면, 다음과 같이 타입을 지정할 수 있습니다:\n\n<span class=\"hljs-keyword\">const</span> userEnvelopeSchema = <span class=\"hljs-title function_\">buildChecksumEnvelopeSchema</span>(userSchema);\n<span class=\"hljs-keyword\">const</span> groupEnvelopeSchema = <span class=\"hljs-title function_\">buildChecksumEnvelopeSchema</span>(groupSchema);\n\ntype <span class=\"hljs-title class_\">UserChecksumEnvelope</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> userEnvelopeSchema>;\ntype <span class=\"hljs-title class_\">GroupChecksumEnvelope</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> groupEnvelopeSchema>;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n만약 우리가 일반적인 envelope 타입을 유지하고 싶다면 어떻게 할까요? 우리는 이를 사용하여 내용을 정확히 모르는 임의의 envelopes에 작업을 수행할 수 있습니다. 예를 들어, 체크섬을 계산하는 것과 같이요.\n\ntype <span class=\"hljs-title class_\">ChecksumEnvelope</span>&#x3C;T> = z.<span class=\"hljs-property\">infer</span>&#x3C;\n  <span class=\"hljs-title class_\">ReturnType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> buildChecksumEnvelopeSchema&#x3C;T>>\n>;\n\ntype <span class=\"hljs-title class_\">UserChecksumEnvelope</span> = <span class=\"hljs-title class_\">ChecksumEnvelope</span>&#x3C;<span class=\"hljs-title class_\">User</span>>;\ntype <span class=\"hljs-title class_\">GroupChecksumEnvelope</span> = <span class=\"hljs-title class_\">ChecksumEnvelope</span>&#x3C;<span class=\"hljs-title class_\">Group</span>>;\n\n## 단수 schema\n\n스키마를 사용할 때, 저는 단수 구조만을 정의하는 것을 선호합니다. 예를 들어, 다음과 같이 작성하지 않겠습니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-keyword\">const</span> usersSchema = z.<span class=\"hljs-title function_\">array</span>(userSchema);\ntype <span class=\"hljs-title class_\">Users</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> usersSchema>;\n\n가능하다면 복수형 타입을 정의하지 않겠어요. 배열에는 <span class=\"hljs-string\">`ReadonlyArray&#x3C;User>`</span>나 <span class=\"hljs-string\">`User[]`</span>를 사용할 거에요. 혼란을 피하고 다른 명명 규칙을 만들지 않기 위해 가능한 한 타입 별칭을 적게 사용하려고 해요.\n\n## 내보내기\n\n일반적으로 schema와 비즈니스 구조체의 유추된 타입을 내보내요. 다른 개발자들이 혼란스럽지 않도록 helper schema를 절대 내보내지 않아요. 가져올 수 있는 문장을 줄이기 위해 노력해요.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n# 불변성\n\n저는 불변성의 충실한 지지자입니다.\n\n새로운 변수를 생성할 때만 데이터가 변경되므로 코드를 분석하기가 더 쉽다고 생각합니다. 제 스키마는 불변성을 일등 시민 개념으로 취급하길 원합니다.\n\n![이미지](<span class=\"hljs-regexp\">/assets/img</span><span class=\"hljs-regexp\">/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_4.png)\n\n&#x3C;div class=\"content-ad\">&#x3C;/</span>div>\n\n불변성을 사용하는 것은 프로그래밍 언어의 규칙을 제한하기 위해 사슬을 사용하는 것과 같습니다. 깨지기 쉬운 링크만 깨뜨리면 됩니다. 저희 경우에는 스키마가 그런 링크일 수 있습니다.\n\n<span class=\"hljs-title class_\">Zod</span> 스키마를 불변하게 만들기 위해 readonly 메서드를 호출합니다. <span class=\"hljs-title class_\">Zod</span>는 자동으로 불변의 추론된 유형을 생성합니다.\n\n예를 들어, 아래에 명시된 것처럼 그룹 스키마는 이미 불변성 원칙을 준수합니다:\n\n<span class=\"hljs-keyword\">const</span> groupSchema = z.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">id</span>: z.<span class=\"hljs-title function_\">string</span>(),\n  <span class=\"hljs-attr\">name</span>: z.<span class=\"hljs-title function_\">string</span>(),\n  <span class=\"hljs-attr\">userIds</span>: z.<span class=\"hljs-title function_\">array</span>(z.<span class=\"hljs-title function_\">string</span>()).<span class=\"hljs-title function_\">readonly</span>(),\n  <span class=\"hljs-attr\">interests</span>: z.<span class=\"hljs-title function_\">array</span>(z.<span class=\"hljs-title function_\">object</span>({\n    <span class=\"hljs-attr\">id</span>: z.<span class=\"hljs-title function_\">string</span>(),\n    <span class=\"hljs-attr\">level</span>: z.<span class=\"hljs-title function_\">union</span>([\n      z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'low'</span>),\n      z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'medium'</span>),\n      z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'high'</span>),\n    ]),\n  })).<span class=\"hljs-title function_\">readonly</span>(),\n}).<span class=\"hljs-title function_\">readonly</span>();\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n만약 추론된 타입을 준수하는 인스턴스를 생성할 때 불변성에서 일시적으로 벗어나고 싶다면 어떻게 해야 할까요?\n\n해당 readonly 수정자를 무효화하는 타입을 사용해야 합니다. 일부 스키마에는 충분하지 않을 수도 있습니다. <span class=\"hljs-title class_\">ReadonlyArray</span> 타입을 가변으로 만들려면 어떻게 해야 할까요? 그리고 <span class=\"hljs-title class_\">ReadonlySet</span>은 어떻게 해야 할까요? <span class=\"hljs-title class_\">ReadonlyMap</span>은요?\n\n우리는 많은 실수를 저지르지 말고 전용 라이브러리를 사용해야 합니다. 예를 들어, ts-essentials 라이브러리와 많은 다른 라이브러리가 관련된 타입을 포함하고 있습니다.\n\n다음 명령어를 입력하여 설치할 수 있습니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\nbun install ts-essentials\n\n이제 아래의 코드를 작성할 수 있습니다:\n\n<span class=\"hljs-keyword\">import</span> type { <span class=\"hljs-title class_\">DeepWritable</span> } <span class=\"hljs-keyword\">from</span> ‘ts-essentials’;\n\ntype <span class=\"hljs-title class_\">WritableGroup</span> = <span class=\"hljs-title class_\">DeepWritable</span>&#x3C;<span class=\"hljs-title class_\">Group</span>>;\n\n# <span class=\"hljs-title class_\">Enumerations</span>\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n<span class=\"hljs-title class_\">Zod</span>에서 열거형을 정의하는 세 가지 방법이 있습니다:\n\n- 네이티브 열거형 사용\n- <span class=\"hljs-title class_\">Zod</span>의 리터럴 유니언 사용\n- <span class=\"hljs-title class_\">Zod</span>의 열거형 사용\n\n각 방법은 적절한 구문 분석과 유추된 유형을 제공합니다. 차이점은 열거된 모든 값을 액세스하는 데 있습니다.\n\n예를 들어, 언어 목록이 있다면 사용자의 선택을 유효성 검사하고 목록을 프론트 엔드에 전송하여 드롭다운에서 표시해야 할 수 있습니다.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_5.png\"</span> /></span></span>\n\n## 네이티브 열거\n\n<span class=\"hljs-title class_\">TypeScript</span>를 사용하면 컴파일 시에 존재하고 런타임에도 존재하는 열거형(enum) 타입을 선언할 수 있습니다. 예를 들어, 다음과 같이 관심 수준을 나타내는 enum을 정의할 수 있습니다:\n\nenum <span class=\"hljs-title class_\">InterestLevel</span> {\n  <span class=\"hljs-title class_\">Low</span> = <span class=\"hljs-string\">'low'</span>,\n  <span class=\"hljs-title class_\">Medium</span> = <span class=\"hljs-string\">'medium'</span>,\n  <span class=\"hljs-title class_\">High</span> = <span class=\"hljs-string\">'high'</span>,\n};\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-title class_\">Zod</span>는 열거 유형에서 스키마를 작성하는 방법을 제공합니다. 아래 코드 스니펫에서와 같이:\n\n<span class=\"hljs-keyword\">const</span> interestLevelSchema = z.<span class=\"hljs-title function_\">nativeEnum</span>(<span class=\"hljs-title class_\">InterestLevel</span>);\n\n만약 <span class=\"hljs-keyword\">const</span> 키워드로 <span class=\"hljs-title class_\">InterestLevel</span> 열거 유형을 선언했다면, 이전에는 컴파일 시간에만 존재했기 때문에 <span class=\"hljs-title class_\">Zod</span> 도우미를 사용할 수 없었습니다.\n\n열거된 모든 값을 추출하려면 다음 코드를 작성해야 합니다.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n<span class=\"hljs-keyword\">const</span> interestLevels = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(<span class=\"hljs-title class_\">InterestLevel</span>);\n\n## <span class=\"hljs-title class_\">Zod</span>의 리터럴 유니언\n\n다른 패턴을 사용하여 열거 스키마를 정의할 수 있습니다. 결국, 열거는 문자열 또는 숫자 리터럴의 유니언입니다.\n\n각 관심 수준 리터럴에 대한 스키마를 작성해 봅시다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-keyword\">const</span> interestLevelLiteralSchemata = [\n  z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'low'</span>),\n  z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'medium'</span>),\n  z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'high'</span>),\n] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">const</span>;\n\n자 이제 적절한 스키마와 타입을 정의할 시간입니다:\n\n<span class=\"hljs-keyword\">const</span> interestLevelSchema = z.<span class=\"hljs-title function_\">union</span>(interestLevelLiteralSchemata);\ntype <span class=\"hljs-title class_\">InterestLevel</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> interestLevelSchema>;\n\n마지막으로, 모든 열거된 값을 추출할 수 있습니다:  \n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-keyword\">const</span> interestLevels = interestLevelLiteralSchemata\n  .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">literal</span>) =></span> literal.<span class=\"hljs-property\">value</span>);\n\n## 조드의 열거\n\n열거 스키마를 정의하는 내가 가장 좋아하는 방법은 조드의 열거 도우미를 사용하는 것입니다.\n\n다음과 같은 방법으로 스키마를 작성하고 타입을 추론할 수 있습니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-keyword\">const</span> interestLevelSchema = z.<span class=\"hljs-title function_\">enum</span>([<span class=\"hljs-string\">'low'</span>, <span class=\"hljs-string\">'medium'</span>, <span class=\"hljs-string\">'high'</span>]);\ntype <span class=\"hljs-title class_\">InterestLevel</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> interestLevelSchema>;\n\n모든 열거된 값 추출을 한 줄로 처리할 수 있습니다:\n\n<span class=\"hljs-keyword\">const</span> interestLevels = interestLevelSchema.<span class=\"hljs-property\">options</span>;\n\n# 구분된 연합(<span class=\"hljs-title class_\">Unions</span>)\n</code></pre>\n<p>일반적인 유니언 타입에서는 컴파일러가 많은 서로 다른 타입을 구분합니다. 디스크리미네이트 유니언에서는 컴파일러가 공유 프로퍼티를 기준으로 구분합니다. 예를 들어, 애플리케이션의 작업을 특정 액터인 사용자 또는 그룹에 할당할 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_6.png\" alt=\"이미지\"></p>\n<p>제가 액터 스키마를 구현하고 다음과 같이 타입을 추론할 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> userActorSchema = z.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'user'</span>),\n  <span class=\"hljs-attr\">id</span>: z.<span class=\"hljs-title function_\">string</span>(),\n});\n\n<span class=\"hljs-keyword\">const</span> groupActorSchema = z.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">type</span>: z.<span class=\"hljs-title function_\">literal</span>(<span class=\"hljs-string\">'group'</span>),\n  <span class=\"hljs-attr\">id</span>: z.<span class=\"hljs-title function_\">string</span>(),\n});\n\n<span class=\"hljs-keyword\">const</span> actorSchema = z.<span class=\"hljs-title function_\">discriminatedUnion</span>(\n  <span class=\"hljs-string\">\"type\"</span>,\n  [userActorSchema, groupActorSchema],\n).<span class=\"hljs-title function_\">readonly</span>();\n\ntype <span class=\"hljs-title class_\">Actor</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> actorSchema>;\n</code></pre>\n<p>내 선택에는 설명이 필요해요!</p>\n<p>먼저, 사용자와 그룹 액터의 스키마를 명시적으로 정의했어요. 이 방법은 구분된 연합의 각 구성 요소를 명명하고 들여쓰기 수준을 낮게 유지하죠.</p>\n<p>누군가 액터 스키마를 읽으면, 여러 줄로 이루어진 스키마를 읽지 않아도 내 의도를 즉시 추측할 거에요!</p>\n<p>둘째, 액터 유형을 스키마에서 추론했어요. 코드 베이스에서 연합 유형의 연산이 멤버 대신 발생하기를 기대하죠.</p>\n<p>세 번째로, 나는 사용자의 종류와 그룹 활동자의 유형을 추론하지 않았어. 나중에 그들을 정의해야 한다면, 다음 패턴을 사용하여 그렇게 할 수 있을 것 같아:</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">UserActor1</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> userActorSchema>;\ntype <span class=\"hljs-title class_\">UserActor2</span> = <span class=\"hljs-title class_\">Extract</span>&#x3C;<span class=\"hljs-title class_\">Actor</span>, { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'user'</span> }>;\ntype <span class=\"hljs-title class_\">UserActor3</span> = <span class=\"hljs-title class_\">Actor</span> &#x26; { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'user'</span> };\n</code></pre>\n<p>각각이 동일한 결과를 가져오는 것에도 불구하고, 나는 첫 번째 것을 사용하지 않을 거야. 왜냐하면 그것은 최소한 추론 규칙에 어긋나기 때문이야. 이미 활동자 유형을 추론을 통해 얻었다면 TypeScript 유형 도우미를 사용하여 더 정확한 유형을 추출할 수 있어.</p>\n<p>그리고 discriminatedUnion 메서드를 사용하여 식별 속성의 이름을 명시해야 하는 이유를 궁금해할 수도 있어. 일치시켜야 할 내용을 알면 Zod가 적합한 스키마를 빠르게 찾을 수 있어. 이러한 최적화를 피하고 싶다면 union 도우미를 사용할 수도 있었겠지.</p>\n<h1>기존 유형 변환</h1>\n<p>기존 TypeScript 프로젝트에는 많은 유형이 포함되어 있을 것입니다. 이를 수동으로 작성하는 것은 여러분의 시간을 낭비하는 일입니다. 대신 LLM 또는 코드 완성 도구를 사용할 수 있습니다. 정확한 법적 조언은 제공하지 않겠지만, 소유 코드베이스에서 이러한 기술을 사용할 수 있는지 항상 확인합니다.</p>\n<p>각 LLM 제공업체는 모델에 제공하는 데이터에 대해 무엇이 발생하는지 알려줄 것입니다!</p>\n<p>특정 LLM을 추천하지는 않겠지만, 주요 모델들이 이 문제를 상당히 잘 처리합니다. 유형을 정의하고 스키마 정의를 시작해보세요. 몇 번 시도한 후에는 고품질 자동완성 스키마가 나올 것입니다.</p>\n<p>LLM을 완전히 믿지 마세요. 항상 결과를 검증해야 합니다!</p>\n<p>다양한 유형이 있다면, 먼저 그들의 정규 표현을 얻는 것을 추천합니다. AST 추출기를 작성하거나 TypeScript Language Server에 요청하여 이를 수행하거나, LLM이 작업을 처리하도록 할 수 있습니다. 처음 두 가지 가능성에 대해 LLM을 사용할 수 있습니다!</p>\n<p>정규 표현을 구문 분석하여 스키마를 생성하는 스크립트를 작성할 수 있습니다. 가장 큰 어려움은 스키마를 생성하는 것이 아니라 구문 분석에 사용하는 것입니다. 프로젝트 아키텍처의 완전한 변경이 필요할 수도 있습니다!</p>\n<p><img src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_7.png\" alt=\"이미지\"></p>\n<h1>요약</h1>\n<p>나는 스키마와 유형 추론을 사용하는 것에 대한 설득력있는 주장을 펼쳤기를 희망합니다, 특히 LLMs와 함께. 아니라면, 의견을 남겨주세요! 다양한 기술적 주제에 대해 토론하는 것을 좋아합니다.</p>\n<p>가장 중요한 포인트를 되풀이하자면, 데이터를 단순히 유효성 검사하는 것이 아니라 파싱해야 한다고 생각합니다. 우리는 스키마를 작성하고 그로부터 유형을 추론해야 합니다. 나는 불변성을 지지하며 이 패러다임을 준수하는 스키마를 선호합니다. 또한 열거 유형 대신 스키마 리터럴을 사용하는 것을 좋아합니다.</p>\n<p>나는 내 코드가 파싱되지 않은 데이터에서 실행되지 않기 때문에 보다 빠르게 배포할 수 있습니다. 컴파일 시간 오류만 만날 것이라고 믿습니다. 애플리케이션 모니터링 덕분에 파싱이 실패할 때를 알 수 있습니다. 나는 LLM을 사용하여 스키마를 작성하고 유형을 더 빨리 추론할 수 있습니다.</p>\n<p>이야기의 개념을 설명하는 부록을 작성했습니다. 이번에는 다른 스키마 라이브러리를 사용하여 @effect/schema와 yup을 설명합니다.</p>\n<h1>부록 A: @effect/schema</h1>\n<p>사용자 스키마를 정의하기 위해 다음과 같이 작성해야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Schema</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@effect/schema\"</span>\n\n<span class=\"hljs-keyword\">const</span> userSchema = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Struct</span>({\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">String</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">String</span>,\n  <span class=\"hljs-attr\">claims</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">Number</span>,\n});\n</code></pre>\n<p>사용자 스키마는 이미 불변성을 준수합니다. 아래 스니펫을 사용하여 사용자 유형을 추론할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">User</span> = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">Schema</span>.<span class=\"hljs-property\">Type</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> userSchema>;\n</code></pre>\n<p>위의 type helper는 다음 코드와 동일합니다:</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">User</span> = <span class=\"hljs-keyword\">typeof</span> userSchema.<span class=\"hljs-property\">Type</span>;\n</code></pre>\n<p>라이브러리는 객체를 구문 분석하고 초과 속성을 허용하지 않습니다. 아래 내용을 확인해주세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> userWithExcessProperties = {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'1'</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Alice'</span>,\n  <span class=\"hljs-attr\">claims</span>: <span class=\"hljs-number\">0x02</span>,\n  <span class=\"hljs-attr\">excessProperty</span>: <span class=\"hljs-number\">1</span>,\n};\n\n<span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title function_\">decodeSync</span>(userSchema)(userWithExcessProperties);\n</code></pre>\n<p>그룹 스키마와 해당 유형은 사용자 스키마와 유사하게 정의할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> groupSchema = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Struct</span>({\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">String</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">String</span>,\n  <span class=\"hljs-attr\">userIds</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">String</span>),\n  <span class=\"hljs-attr\">interests</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Array</span>(\n    <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Struct</span>({\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">String</span>,\n      <span class=\"hljs-attr\">level</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Union</span>(\n        <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Literal</span>(<span class=\"hljs-string\">'low'</span>),\n        <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Literal</span>(<span class=\"hljs-string\">'medium'</span>),\n        <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Literal</span>(<span class=\"hljs-string\">'high'</span>),\n      ),\n    })\n  ),\n});\n\ntype <span class=\"hljs-title class_\">Group</span> = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">Schema</span>.<span class=\"hljs-property\">Type</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> groupSchema>;\n</code></pre>\n<p>일반적인 추론을 달성하기 위해 다음 코드를 작성합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> buildChecksumEnvelopeSchema = &#x3C;T><span class=\"hljs-function\">(<span class=\"hljs-params\">\n  datumSchema: Schema.Schema&#x3C;T>\n</span>) =></span> <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Struct</span>({\n  <span class=\"hljs-attr\">datum</span>: datumSchema,\n  <span class=\"hljs-attr\">checksum</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">String</span>,\n});\n\n<span class=\"hljs-keyword\">const</span> userEnvelopeSchema = <span class=\"hljs-title function_\">buildChecksumEnvelopeSchema</span>(userSchema);\n<span class=\"hljs-keyword\">const</span> groupEnvelopeSchema = <span class=\"hljs-title function_\">buildChecksumEnvelopeSchema</span>(groupSchema);\n\ntype <span class=\"hljs-title class_\">ChecksumEnvelope</span>&#x3C;T> = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">Schema</span>.<span class=\"hljs-property\">Type</span>&#x3C;\n  <span class=\"hljs-title class_\">ReturnType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> buildChecksumEnvelopeSchema&#x3C;T>>\n>;\n\ntype <span class=\"hljs-title class_\">UserChecksumEnvelope</span> = <span class=\"hljs-title class_\">ChecksumEnvelope</span>&#x3C;<span class=\"hljs-title class_\">User</span>>;\ntype <span class=\"hljs-title class_\">GroupChecksumEnvelope</span> = <span class=\"hljs-title class_\">ChecksumEnvelope</span>&#x3C;<span class=\"hljs-title class_\">Group</span>>;\n</code></pre>\n<p>@effect/schema를 사용하여 열거 스키마를 정의하는 세 가지 방법을 찾았습니다.</p>\n<p>첫 번째 방법은 리터럴의 합집합을 사용하는 것입니다. 아래 예제를 살펴보세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> interestLevelSchema = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Union</span>(\n  <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Literal</span>(<span class=\"hljs-string\">'low'</span>),\n  <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Literal</span>(<span class=\"hljs-string\">'medium'</span>),\n  <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Literal</span>(<span class=\"hljs-string\">'high'</span>),\n);\n\ntype <span class=\"hljs-title class_\">InterestLevel</span> = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">Schema</span>.<span class=\"hljs-property\">Type</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> interestLevelSchema>;\n</code></pre>\n<p>스키마 속성에 액세스하여 관심 수준 목록을 추출할 수 있습니다. 아래에 나와있는 것처럼:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> interestLevels = interestLevelSchema\n  .<span class=\"hljs-property\">members</span>\n  .<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">member</span>) =></span> member.<span class=\"hljs-property\">literals</span>);\n</code></pre>\n<p>두 번째 접근 방법은 스키마 리터럴 도우미를 사용하는 것입니다. 한 줄로 스키마를 정의할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> interestLevelSchema = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Literal</span>(‘low’, ‘medium’, ‘high’);\n</code></pre>\n<p>우리는 모든 값을 가져 오기위한 한 줄짜리도 사용할 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> interestLevels = interestLevelSchema.<span class=\"hljs-property\">literals</span>;\n</code></pre>\n<p>이 라이브러리를 사용하면 네이티브 열거 유형을 사용할 수 있습니다! 다음 조각을 살펴보세요:</p>\n<pre><code class=\"hljs language-js\">enum <span class=\"hljs-title class_\">InterestLevel</span> {\n  <span class=\"hljs-title class_\">Low</span> = <span class=\"hljs-string\">'low'</span>,\n  <span class=\"hljs-title class_\">Medium</span> = <span class=\"hljs-string\">'medium'</span>,\n  <span class=\"hljs-title class_\">High</span> = <span class=\"hljs-string\">'high'</span>,\n}\n\n<span class=\"hljs-keyword\">const</span> interestLevelSchema = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Enums</span>(<span class=\"hljs-title class_\">InterestLevel</span>)\n<span class=\"hljs-keyword\">const</span> interestLevels = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(<span class=\"hljs-title class_\">InterestLevel</span>);\n</code></pre>\n<p>차별화 된 연합을 정의하는 것이 더 간단하지 않았을 것입니다. 아래 코드 조각을 읽어보세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> userActorSchema = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Struct</span>({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Literal</span>(<span class=\"hljs-string\">'user'</span>),\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">String</span>,\n});\n\n<span class=\"hljs-keyword\">const</span> groupActorSchema = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Struct</span>({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Literal</span>(<span class=\"hljs-string\">'group'</span>),\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">String</span>,\n});\n\n<span class=\"hljs-keyword\">const</span> actorSchema = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-title class_\">Union</span>(userActorSchema, groupActorSchema);\ntype <span class=\"hljs-title class_\">Actor</span> = <span class=\"hljs-title class_\">Schema</span>.<span class=\"hljs-property\">Schema</span>.<span class=\"hljs-property\">Type</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> actorSchema>;\n</code></pre>\n<h1>부록 B : Yup</h1>\n<p>Yup을 사용한 사용자 스키마는 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Yup</span> <span class=\"hljs-keyword\">from</span> ‘yup’;\n\n<span class=\"hljs-keyword\">const</span> userSchema = <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">string</span>().required(),\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">string</span>().required(),\n  <span class=\"hljs-attr\">claims</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">number</span>().required(),\n}).<span class=\"hljs-title function_\">noUnknown</span>();\n</code></pre>\n<p>이 라이브러리에는 두 가지 주의 사항이 있습니다. 먼저, 필수 도우미를 사용하여 비널 값 받아들이기, 두 번째로 초과 속성을 제외하려면 noUnknown 도우미를 사용해야 합니다.</p>\n<p>하지만, 여기에 더 많은 내용이 있습니다!</p>\n<p>추론된 유형에서 스키마를 불변성을 보장하도록 강제하는 방법을 찾지 못했습니다. 다음과 같이 ts-essentials 라이브러리의 DeepReadonly 유형 도우미를 사용해야 했습니다:</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">User</span> = <span class=\"hljs-title class_\">DeepReadonly</span>&#x3C;<span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-property\">InferType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> userSchema>>;\n</code></pre>\n<p>위의 유형은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">User</span> = <span class=\"hljs-title class_\">DeepReadonly</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> userSchema[<span class=\"hljs-string\">'__outputType'</span>]>;\n</code></pre>\n<p>도서관은 내가 정의한 구문 분석을 수행하는 validateSync라는 메서드를 제공합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> userWithExcessProperties = {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'1'</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Alice'</span>,\n  <span class=\"hljs-attr\">claims</span>: <span class=\"hljs-number\">0x02</span>,\n  <span class=\"hljs-attr\">excessProperty</span>: <span class=\"hljs-number\">1</span>,\n};\n\n<span class=\"hljs-keyword\">const</span> user = userSchema.<span class=\"hljs-title function_\">validateSync</span>(userWithExcessProperties);\n</code></pre>\n<p>그룹 스키마를 다음 형식으로 정의하기를 제안합니다:</p>\n<pre><code class=\"hljs language-js\">enum <span class=\"hljs-title class_\">InterestLevel</span> {\n  <span class=\"hljs-title class_\">Low</span> = <span class=\"hljs-string\">'low'</span>,\n  <span class=\"hljs-title class_\">Medium</span> = <span class=\"hljs-string\">'medium'</span>,\n  <span class=\"hljs-title class_\">High</span> = <span class=\"hljs-string\">'high'</span>,\n}\n\n<span class=\"hljs-keyword\">const</span> groupSchema = <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">string</span>().required(),\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">string</span>().required(),\n  <span class=\"hljs-attr\">userIds</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">array</span>(\n    <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">string</span>().required()\n  ).required(),\n  <span class=\"hljs-attr\">interests</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">array</span>(\n    <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">object</span>({\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">string</span>().required(),\n      <span class=\"hljs-attr\">level</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-property\">mixed</span>&#x3C;<span class=\"hljs-title class_\">InterestLevel</span>>()\n        .<span class=\"hljs-title function_\">oneOf</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(<span class=\"hljs-title class_\">InterestLevel</span>))\n        .required(),\n    })\n  ).required(),\n}).<span class=\"hljs-title function_\">noUnknown</span>();\n\ntype <span class=\"hljs-title class_\">Group</span> = <span class=\"hljs-title class_\">DeepReadonly</span>&#x3C;<span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-property\">InferType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> groupSchema>>;\n</code></pre>\n<p>만약 주의깊게 살펴봤다면, 관심 수준을 위한 enum 형식을 볼 수 있었을 것입니다. 곧 enum을 사용하는 이유에 대해 설명할 것입니다.</p>\n<p>아래 예제에서 제시된대로 제네릭 추론을 달성할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> buildChecksumEnvelopeSchema = &#x3C;T><span class=\"hljs-function\">(<span class=\"hljs-params\">\n  datumSchema: Yup.Schema&#x3C;T>\n</span>) =></span> <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">datum</span>: datumSchema,\n  <span class=\"hljs-attr\">checksum</span>: <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-title function_\">string</span>().required(),\n}).<span class=\"hljs-title function_\">noUnknown</span>();\n\n<span class=\"hljs-keyword\">const</span> userEnvelopeSchema = <span class=\"hljs-title function_\">buildChecksumEnvelopeSchema</span>(userSchema);\n<span class=\"hljs-keyword\">const</span> groupEnvelopeSchema = <span class=\"hljs-title function_\">buildChecksumEnvelopeSchema</span>(groupSchema);\n\ntype <span class=\"hljs-title class_\">UserChecksumEnvelope</span> = <span class=\"hljs-title class_\">DeepReadonly</span>&#x3C;\n  <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-property\">InferType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> userEnvelopeSchema>\n>;\n\ntype <span class=\"hljs-title class_\">GroupChecksumEnvelope</span> = <span class=\"hljs-title class_\">DeepReadonly</span>&#x3C;\n  <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-property\">InferType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> groupEnvelopeSchema>\n>;\n\ntype <span class=\"hljs-title class_\">ChecksumEnvelope</span>&#x3C;T> = <span class=\"hljs-title class_\">DeepReadonly</span>&#x3C;\n  <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-property\">InferType</span>&#x3C;<span class=\"hljs-title class_\">ReturnType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> buildChecksumEnvelopeSchema&#x3C;T>>>\n>;\n\ntype <span class=\"hljs-title class_\">UserChecksumEnvelope</span> = <span class=\"hljs-title class_\">ChecksumEnvelope</span>&#x3C;<span class=\"hljs-title class_\">User</span>>;\ntype <span class=\"hljs-title class_\">GroupChecksumEnvelope</span> = <span class=\"hljs-title class_\">ChecksumEnvelope</span>&#x3C;<span class=\"hljs-title class_\">Group</span>>;\n</code></pre>\n<p>약속한 대로, Yup에서 enum 유형을 사용하는 것이 가장 합리적인 이유를 설명하겠습니다.</p>\n<p>다음과 같이 열거형 유형의 스키마를 손쉽게 만들 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> interestLevelSchema = <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-property\">mixed</span>&#x3C;<span class=\"hljs-title class_\">InterestLevel</span>>()\n  .<span class=\"hljs-title function_\">oneOf</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(<span class=\"hljs-title class_\">InterestLevel</span>))\n  .required();\n</code></pre>\n<p>모든 값을 배열로 먼저 정의해야하는 두 번째 방법도 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> interestLevels = [\n  <span class=\"hljs-string\">'low'</span>,\n  <span class=\"hljs-string\">'medium'</span>,\n  <span class=\"hljs-string\">'high'</span>,\n] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">const</span>;\n\ntype <span class=\"hljs-title class_\">InterestLevel</span> = <span class=\"hljs-keyword\">typeof</span> interestLevels[number];\n</code></pre>\n<p>다음은 한 줄로 스키마를 작성할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> interestLevelSchema = <span class=\"hljs-title class_\">Yup</span>.<span class=\"hljs-property\">mixed</span>&#x3C;<span class=\"hljs-title class_\">InterestLevel</span>>()\n  .<span class=\"hljs-title function_\">oneOf</span>(interestLevels)\n  .required();\n</code></pre>\n<p>여기에는 공용 체계에 대한 스키마를 작성하는 상세한 지침이 있어야 합니다. 유감스럽게도 Yup을 사용하여 지원하는 것을 찾지 못했습니다. 그러나 해결책을 찾았습니다.</p>\n<p>스키마 시퀀스가 있는 경우, 각 스키마를 사용하여 객체를 구문 분석하는 함수를 작성하여 일치하는 것을 찾을 때까지 시도할 수 있습니다. 빠르게 작성하는 데 도움이 되는 LLM을 사용할 수 있습니다!</p>\n<p>설정된 제한 시간이 초과되어 서비스에 영향을 줄 수 있습니다. 해당 작업에 대한 피드백이 필요하신 경우 언제든지 알려주세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}