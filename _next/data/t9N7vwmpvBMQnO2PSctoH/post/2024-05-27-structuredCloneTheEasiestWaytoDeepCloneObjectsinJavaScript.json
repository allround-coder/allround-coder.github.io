{"pageProps":{"post":{"title":"structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법","description":"","date":"2024-05-27 18:19","slug":"2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript","content":"\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png\" />\n\n# 1. 서문\n\n왜 지금까지 JavaScript에 완전한 복제 함수가 만들어지지 않았을까요? 데이터 유형에 관계 없이 객체와 해당 모든 내용을 완전히 복제하는 것은?\n\n이건 놀랍고, 때로는 객체를 깊은 복제해야 하는 경우가 많이 있어서 일에 많은 어려움을 야기하죠.\n\n<div class=\"content-ad\"></div>\n\n# 2. 객체를 깊은 복제하는 두 가지 방법\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_1.png)\n\n내 친구야, 객체를 깊은 복제하는 방법을 아시나요? 위 표의 데이터 유형을 복제하는 것이 가장 좋을 겁니다.\n\n```js\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  domNode: document.createElement(\"div\")\n}\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 testData를 테스트 데이터로 사용할 것입니다.\n\n# 2.1# JSON.parse와 JSON.stringify\n\n이 기능을 사용하면 객체를 깊이 복제할 수 있지만, 유감스럽게도 데이터 유형의 일부만 복사될 뿐이며, 순환 참조가 있는 객체는 복사할 수 없습니다.\n\n```js\ntry {\n  const jsonClone = JSON.parse(JSON.stringify(testData))\n  console.log(jsonClone)\n} catch (error) {\n  console.log(\"JSON 메서드가 이 데이터를 처리할 수 없습니다\")\n}\n// 출력\n/*\n{\n  number: 123,\n  string: \"test\",\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }]\n}\n*/\n```\n\n<div class=\"content-ad\"></div>\n\n이미지를 포함한 코드 블록:\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nJSON.parse(JSON.stringify(obj))\n```\n\nMarkdown 형식으로 변환 된 표:\n\n# 2.2# lodash.clone\n\n<div class=\"content-ad\"></div>\n\n대부분의 사람들이 이 선택을 하겠지만 추가적인 npm 패키지를 가져와야 할 수도 있지만 그 가치는 충분히 합니다.\n\n```js\nconst _ = require('lodash')\nconst lodashClone = _.cloneDeep(testData)\nconsole.log(lodashClone)\n\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: [Function: function], // 함수 참조는 복사됩니다.\n  map: Map { 'key1' => 'value1', 'key2' => 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: HTMLDivElement {}\n}\n*/\n```\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_4.png)\n\n# 3.1# 새로운 API: structuredClone?\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_5.png\" />\n\nmdn에서 가져왔어요!\n\n2022년부터 크롬, 파이어폭스 등 다양한 주요 브라우저에서 지원되고 있어요. 우리에게 행운이네요!\n\n아직 이 데이터를 사용 중이지만, 먼저 함수와 DOM 유형을 숨기고, 그 이유를 나중에 설명할게요.\n\n<div class=\"content-ad\"></div>\n\n\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  // function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  // domNode: document.createElement(\"div\")\n}\n\nconst structuredCloneResult = structuredClone(testData)\nconsole.log(structuredCloneResult)\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: undefined, // Functions are not cloned\n  map: Map { 'key1' => 'value1', 'key2' => 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: undefined // DOM nodes are not cloned\n}\n*/\n\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_6.png\" />\n\n우리가 손에 들고 있는 잔을 들어 올려봐요. 이 결과는 축하해야 할 만하네요.\n\n# 3.2# structuredClone의 장점\n\n\n<div class=\"content-ad\"></div>\n\n친구야, structuredClone 함수를 좋아하시나요? 충분히 간단한가요? 네, 그것이 가장 큰 장점이죠.\n\n하지만 또 다른 큰 장점이 있습니다. 그것은 심지어 원형 참조가 있는 객체도 복사할 수 있다는 것이죠.\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nstructuredClone(obj)\n```\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_7.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 3.3 구조화된 복제의 일부 제한 사항\n\n친구들아, 함께 축배를 건넜지만, 구조화된 복제에는 여전히 몇 가지 제한 사항이 있음을 인정해야 합니다.\n\n함수나 Dom을 복사할 수 없습니다. 이를 하려고 시도하면 예외가 발생합니다. 이것이 저가 함수와 Dom을 숨긴 이유입니다.\n\n```js\nconst obj = { fn: () => {} }\n\nstructuredClone(obj)\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_8.png\" />\n\n```js\nconst obj = { domNode: document.createElement('div') }\n\nstructuredClone(obj)\n```\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_9.png\" />\n\n이 함수를 호출할 때 오류가 발생하지 않도록 하고, 메소드를 가진 객체를 깊게 복제하지만 메소드는 복제하지 않기를 원합니다.\n\n<div class=\"content-ad\"></div>\n\n# 친절한 한국어 번역 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수 보내고 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠에 강제로 노출되는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>1. 서문</h1>\n<p>왜 지금까지 JavaScript에 완전한 복제 함수가 만들어지지 않았을까요? 데이터 유형에 관계 없이 객체와 해당 모든 내용을 완전히 복제하는 것은?</p>\n<p>이건 놀랍고, 때로는 객체를 깊은 복제해야 하는 경우가 많이 있어서 일에 많은 어려움을 야기하죠.</p>\n<h1>2. 객체를 깊은 복제하는 두 가지 방법</h1>\n<p><img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_1.png\" alt=\"이미지\"></p>\n<p>내 친구야, 객체를 깊은 복제하는 방법을 아시나요? 위 표의 데이터 유형을 복제하는 것이 가장 좋을 겁니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> testData = {\n  <span class=\"hljs-attr\">number</span>: <span class=\"hljs-number\">123</span>,\n  <span class=\"hljs-attr\">string</span>: <span class=\"hljs-string\">\"test\"</span>,\n  <span class=\"hljs-attr\">undefined</span>: <span class=\"hljs-literal\">undefined</span>,\n  <span class=\"hljs-attr\">null</span>: <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">boolean</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">object</span>: { <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: { <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span> } },\n  <span class=\"hljs-attr\">array</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, { <span class=\"hljs-attr\">d</span>: <span class=\"hljs-number\">3</span> }],\n  <span class=\"hljs-attr\">function</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>; },\n  <span class=\"hljs-attr\">map</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">\"key1\"</span>, <span class=\"hljs-string\">\"value1\"</span>], [<span class=\"hljs-string\">\"key2\"</span>, <span class=\"hljs-string\">\"value2\"</span>]]),\n  <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]),\n  <span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(),\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">\"An error occurred\"</span>),\n  <span class=\"hljs-attr\">regex</span>: <span class=\"hljs-regexp\">/test/i</span>,\n  <span class=\"hljs-attr\">domNode</span>: <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">\"div\"</span>)\n}\n</code></pre>\n<p>우리는 testData를 테스트 데이터로 사용할 것입니다.</p>\n<h1>2.1# JSON.parse와 JSON.stringify</h1>\n<p>이 기능을 사용하면 객체를 깊이 복제할 수 있지만, 유감스럽게도 데이터 유형의 일부만 복사될 뿐이며, 순환 참조가 있는 객체는 복사할 수 없습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">try</span> {\n  <span class=\"hljs-keyword\">const</span> jsonClone = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(testData))\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(jsonClone)\n} <span class=\"hljs-keyword\">catch</span> (error) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"JSON 메서드가 이 데이터를 처리할 수 없습니다\"</span>)\n}\n<span class=\"hljs-comment\">// 출력</span>\n<span class=\"hljs-comment\">/*\n{\n  number: 123,\n  string: \"test\",\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }]\n}\n*/</span>\n</code></pre>\n<p>이미지를 포함한 코드 블록:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'fatfish'</span> }\n\nobj.<span class=\"hljs-property\">obj</span> = obj\n<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(obj))\n</code></pre>\n<p>Markdown 형식으로 변환 된 표:</p>\n<h1>2.2# lodash.clone</h1>\n<p>대부분의 사람들이 이 선택을 하겠지만 추가적인 npm 패키지를 가져와야 할 수도 있지만 그 가치는 충분히 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> _ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'lodash'</span>)\n<span class=\"hljs-keyword\">const</span> lodashClone = _.<span class=\"hljs-title function_\">cloneDeep</span>(testData)\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(lodashClone)\n\n<span class=\"hljs-comment\">/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: [Function: function], // 함수 참조는 복사됩니다.\n  map: Map { 'key1' => 'value1', 'key2' => 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: HTMLDivElement {}\n}\n*/</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_4.png\" alt=\"이미지\"></p>\n<h1>3.1# 새로운 API: structuredClone?</h1>\n<p>mdn에서 가져왔어요!</p>\n<p>2022년부터 크롬, 파이어폭스 등 다양한 주요 브라우저에서 지원되고 있어요. 우리에게 행운이네요!</p>\n<p>아직 이 데이터를 사용 중이지만, 먼저 함수와 DOM 유형을 숨기고, 그 이유를 나중에 설명할게요.</p>\n<p>const testData = {\nnumber: 123,\nstring: \"test\",\nundefined: undefined,\nnull: null,\nboolean: true,\nobject: { a: 1, b: { c: 2 } },\narray: [1, 2, { d: 3 }],\n// function: function() { return \"hello\"; },\nmap: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\nset: new Set([1, 2, 3]),\ndate: new Date(),\nerror: new Error(\"An error occurred\"),\nregex: /test/i,\n// domNode: document.createElement(\"div\")\n}</p>\n<p>const structuredCloneResult = structuredClone(testData)\nconsole.log(structuredCloneResult)\n/*\n{\nnumber: 123,\nstring: \"test\",\nundefined: undefined,\nnull: null,\nboolean: true,\nobject: { a: 1, b: { c: 2 } },\narray: [1, 2, { d: 3 }],\nfunction: undefined, // Functions are not cloned\nmap: Map { 'key1' => 'value1', 'key2' => 'value2' },\nset: Set { 1, 2, 3 },\ndate: 2023-05-23T09:00:00.000Z,\nerror: Error: An error occurred,\nregex: /test/i,\ndomNode: undefined // DOM nodes are not cloned\n}\n*/</p>\n<p>우리가 손에 들고 있는 잔을 들어 올려봐요. 이 결과는 축하해야 할 만하네요.</p>\n<h1>3.2# structuredClone의 장점</h1>\n<p>친구야, structuredClone 함수를 좋아하시나요? 충분히 간단한가요? 네, 그것이 가장 큰 장점이죠.</p>\n<p>하지만 또 다른 큰 장점이 있습니다. 그것은 심지어 원형 참조가 있는 객체도 복사할 수 있다는 것이죠.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'fatfish'</span> }\n\nobj.<span class=\"hljs-property\">obj</span> = obj\n<span class=\"hljs-title function_\">structuredClone</span>(obj)\n</code></pre>\n<h1>3.3 구조화된 복제의 일부 제한 사항</h1>\n<p>친구들아, 함께 축배를 건넜지만, 구조화된 복제에는 여전히 몇 가지 제한 사항이 있음을 인정해야 합니다.</p>\n<p>함수나 Dom을 복사할 수 없습니다. 이를 하려고 시도하면 예외가 발생합니다. 이것이 저가 함수와 Dom을 숨긴 이유입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">fn</span>: <span class=\"hljs-function\">() =></span> {} }\n\n<span class=\"hljs-title function_\">structuredClone</span>(obj)\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">domNode</span>: <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">'div'</span>) }\n\n<span class=\"hljs-title function_\">structuredClone</span>(obj)\n</code></pre>\n<p>이 함수를 호출할 때 오류가 발생하지 않도록 하고, 메소드를 가진 객체를 깊게 복제하지만 메소드는 복제하지 않기를 원합니다.</p>\n<h1>친절한 한국어 번역 🚀</h1>\n<p>In Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:</p>\n<ul>\n<li>작가를 박수 보내고 팔로우하세요 ️👏️️</li>\n<li>팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter</li>\n<li>다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed</li>\n<li>알고리즘 콘텐츠에 강제로 노출되는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.</li>\n<li>PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}