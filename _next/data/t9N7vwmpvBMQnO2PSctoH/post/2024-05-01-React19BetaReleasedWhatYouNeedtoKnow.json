{"pageProps":{"post":{"title":"React 19 Beta 릴리스, 새로운 기능 소개 및 정리","description":"","date":"2024-05-01 17:45","slug":"2024-05-01-React19BetaReleasedWhatYouNeedtoKnow","content":"\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png)\n\n지난 2022년 6월 React의 마지막 안정 버전 이후, 두 년 가까이 새 버전이 나오지 않았는데, 이제 npm에서 React 19 베타판이 안정 버전인 React 18.3.0과 함께 공개되었습니다. React 19 베타판에서 개발자들이 알아야 할 새로운 기능을 살펴보겠습니다.\n\n## 액션\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_1.png)\n\n<div class=\"content-ad\"></div>\n\n리액트 앱에서 흔히 발생하는 사용 사례는 데이터 변이를 수행한 다음 응답에 따라 상태를 업데이트하는 것입니다. 예를 들어, 사용자가 이름을 변경하기 위해 양식을 제출하면 API 요청을 만들고 그 다음 응답을 처리해야 합니다. 과거에는 보류 중인 상태, 오류, 낙관적 업데이트 및 순차 요청을 수동으로 처리해야 했습니다.\n\n예를 들어, useState로 대기 및 오류 상태를 처리할 수 있었습니다:\n\n```js\n// 액션 이전\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, setIsPending] = useState(false);\n\n  const handleSubmit = async () => {\n    setIsPending(true);\n    const error = await updateName(name);\n    setIsPending(false);\n    if (error) {\n      setError(error);\n      return;\n    } \n    redirect(\"/경로\");\n  };\n\n  return (\n    <div>\n      <input value={name} onChange={(event) => setName(event.target.value)} />\n      <button onClick={handleSubmit} disabled={isPending}>\n        업데이트\n      </button>\n      {error && <p>{error}</p>}\n    </div>\n  );\n}\n```\n\n리액트 19에서는 전이에 비동기 함수를 사용하여 대기 중인 상태, 오류, 양식 및 낙관적 업데이트를 자동으로 처리할 수 있는 지원이 추가되었습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, useTransition을 사용하여 대기 상태를 처리할 수 있습니다:\n\n```js\n// Actions에서 대기 상태 사용하기\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSubmit = async () => {\n    startTransition(async () => {\n      const error = await updateName(name);\n      if (error) {\n        setError(error);\n        return;\n      } \n      redirect(\"/path\");\n    })\n  };\n\n  return (\n    <div>\n      <input value={name} onChange={(event) => setName(event.target.value)} />\n      <button onClick={handleSubmit} disabled={isPending}>\n        Update\n      </button>\n      {error && <p>{error}</p>}\n    </div>\n  );\n}\n```\n\n비동기 전환은 즉시 isPending 상태를 true로 설정하고 비동기 요청을 수행한 다음 이전 전환 후에 isPending를 false로 전환합니다. 이렇게 하면 데이터가 변경되는 동안에도 현재 UI를 반응적이고 상호작용할 수 있게 유지할 수 있습니다.\n\n관례적으로, 비동기 전환을 사용하는 함수는 \"Actions\"라고 합니다.\n\n<div class=\"content-ad\"></div>\n\n동작은 데이터 제출을 자동으로 처리해줍니다:\n\n- 보류 상태: 동작은 요청의 시작부터 시작되는 보류 상태를 제공하며, 최종 상태 업데이트가 완료될 때 자동으로 재설정됩니다.\n- 낙관적 업데이트: 동작은 새로운 useOptimistic 훅을 지원하여 요청이 제출되는 동안 사용자에게 즉시 피드백을 제공할 수 있습니다.\n- 오류 처리: 동작은 오류 처리를 제공하여 요청이 실패했을 때 오류 경계를 표시하고, 낙관적 업데이트를 자동으로 원래 값으로 되돌립니다.\n- 폼: 이제 `form` 요소는 동작과 formAction props에 함수를 전달할 수 있습니다. action props에 함수를 전달하면 기본적으로 동작을 사용하고 제출 후 자동으로 폼을 재설정합니다.\n\nReact 19에서 동작을 기반으로하면 낙관적 업데이트를 관리하는 useOptimistic 및 동작의 공통 사례를 처리하는 새로운 hook인 React.useActionState를 도입했습니다. react-dom에서는 `form` 동작을 사용하여 폼을 자동으로 처리하고, 동작의 공통 사례를 지원하는 useFormStatus를 추가했습니다.\n\nReact 19에서 위 예제는 간단하게 변경될 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// <form> 작업 및 useActionState 사용하기\nfunction ChangeName({ name, setName }) {\n  const [error, submitAction, isPending] = useActionState(\n    async (previousState, formData) => {\n      const error = await updateName(formData.get(\"name\"));\n      if (error) {\n        return error;\n      }\n      redirect(\"/path\");\n    }\n  );\n\n  return (\n    <form action={submitAction}>\n      <input type=\"text\" name=\"name\" />\n      <button type=\"submit\" disabled={isPending}>업데이트</button>\n      {error && <p>{error}</p>}\n    </form>\n  );\n}\n```\n\n# 새로운 훅: useActionState\n\nReact 19에서 일반적인 케이스를 보다 쉽게 만들기 위해 useActionState라는 새로운 훅이 추가되었습니다:\n\n```js\nconst [error, submitAction, isPending] = useActionState(async (previousState, newName) => {\n  const error = await updateName(newName);\n  if (error) {\n    // 작업의 결과로 어떤 것이든 반환할 수 있습니다.\n    // 여기서는 오직 에러만 반환합니다.\n    return error;\n  }\n  \n  // 성공 처리\n});\n```\n\n<div class=\"content-ad\"></div>\n\n`useActionState` 함수는 함수(액션)를 인수로 받아 감싼 액션을 호출합니다. 이는 액션이 조합되기 때문에 작동합니다. 감싼 액션이 호출되면 `useActionState`는 액션의 마지막 결과를 데이터로 반환하고 액션의 보류 상태를 보류로 반환합니다.\n\n# React DOM: form 액션\n\nReact 19의 새로운 `form` 기능에 액션도 통합되어 있습니다. `form`, `input`, 그리고 `button` 엘리먼트의 액션과 formAction 프롭으로 함수를 전달하여 액션과 함께 자동으로 폼을 제출할 수 있습니다:\n\n```js\n<form action={actionFunction}>\n```\n\n<div class=\"content-ad\"></div>\n\n`form`이 성공하면 React는 제어되지 않는 컴포넌트를 위해 자동으로 `form`을 재설정합니다. `form`을 수동으로 재설정해야 하는 경우, 새 요청 `form` 재설정 React DOM API를 호출할 수 있습니다.\n\n# React DOM: 새로운 훅: useFormStatus\n\n디자인 시스템에서 `form`에 대한 정보에 액세스해야 하는 디자인 컴포넌트를 작성하는 것이 일반적입니다. 그러나 컴포넌트로 속성을 전달 받지 않아도 되도록 하는 경우가 있습니다. 이 작업은 Context를 통해 수행할 수 있지만, 일반적인 경우를 쉽게 만들기 위해 React 19에 새로운 훅인 useFormStatus가 추가되었습니다:\n\n```js\nimport {useFormStatus} from 'react-dom';\n\nfunction DesignButton() {\n  const {pending} = useFormStatus();\n  return <button type=\"submit\" disabled={pending} />\n}\n```\n\n<div class=\"content-ad\"></div>\n\n`useFormStatus`는 부모 `form`의 상태를 읽어오는 것처럼 동작하여, 마치 form이 Context 제공자인 것처럼 사용할 수 있습니다.\n\n# 새로운 훅: useOptimistic\n\n데이터 변경 작업을 수행할 때 또 다른 일반적인 UI 패턴은 비동기 요청 진행 중에 최종 상태를 낙관적으로 표시하는 것입니다. React 19에서는 이를 쉽게 처리할 수 있도록 `useOptimistic`라는 새로운 훅이 추가되었습니다:\n\n```js\nfunction ChangeName({currentName, onUpdateName}) {\n  const [optimisticName, setOptimisticName] = useOptimistic(currentName);\n\n  const submitAction = async formData => {\n    const newName = formData.get(\"name\");\n    setOptimisticName(newName);\n    const updatedName = await updateName(newName);\n    onUpdateName(updatedName);\n  };\n\n  return (\n    <form action={submitAction}>\n      <p>Your name is: {optimisticName}</p>\n      <p>\n        <label>Change Name:</label>\n        <input\n          type=\"text\"\n          name=\"name\"\n          disabled={currentName !== optimisticName}\n        />\n      </p>\n    </form>\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n`useOptimistic` 훅은 `updateName` 요청이 진행 중일 때 즉시 `optimisticName`을 렌더링합니다. 업데이트가 완료되거나 에러가 발생하면 React가 자동으로 `currentName` 값으로 전환됩니다.\n\n# 새 API: use\n\nReact 19에서 렌더링하는 동안 리소스를 읽기 위한 새로운 API가 추가되었습니다: `use`.\n\n예를 들어, `use`로 프로미스를 읽을 수 있으며, React가 프로미스가 해결될 때까지 일시 중단됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {use} from 'react';\n\nfunction Comments({commentsPromise}) {\n  // `use`가 프로미스가 해결될 때까지 일시 중단됩니다.\n  const comments = use(commentsPromise);\n  return comments.map(comment => <p key={comment.id}>{comment}</p>);\n}\n\nfunction Page({commentsPromise}) {\n  // Comments에서 `use`가 일시 중단되면\n  // 이 Suspense 경계가 표시됩니다.\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Comments commentsPromise={commentsPromise} />\n    </Suspense>\n  )\n}\n```\n\n렌더링되는 동안 생성된 프로미스를 지원하지 않습니다.\n\n렌더링에서 만든 프로미스를 use에 전달하려고 하면 React에서 경고합니다:\n\n수정하려면, 프로미스 캐싱을 지원하는 suspense 기반 라이브러리나 프레임워크에서 프로미스를 전달해야 합니다. 미래에는 렌더링 중에 프로미스를 캐싱하기 쉽게 만드는 기능을 제공할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n또한 일찍 반환한 후와 같이 조건부로 Context를 읽을 수도 있습니다:\n\n```js\nimport {use} from 'react';\nimport ThemeContext from './ThemeContext'\n\nfunction Heading({children}) {\n  if (children == null) {\n    return null;\n  }\n  \n  // 일찍 반환으로 인해 useContext로 동작하지 않습니다.\n  const theme = use(ThemeContext);\n  return (\n    <h1 style={{color: theme.color}}>\n      {children}\n    </h1>\n  );\n}\n```\n\nuse API는 후크와 유사하게 렌더링 중에만 호출될 수 있습니다. 후크와는 다르게 use는 조건부로 호출할 수 있습니다.\n\n자세한 정보는 use에 대한 문서를 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n# ref을 속성으로 사용하기\n\nReact 19부터 함수 컴포넌트에서 ref를 속성으로 접근할 수 있습니다:\n\n```js\nfunction MyInput({placeholder, ref}) {\n  return <input placeholder={placeholder} ref={ref} />\n}\n\n//...\n<MyInput ref={ref} />\n```\n\n새로운 함수 컴포넌트는 더 이상 forwardRef가 필요하지 않습니다. 향후 버전에서 React는 forwardRef를 사용하지 않도록 하고 제거할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# 'Context'를 제공자로 렌더링하기\n\nReact 19에서 'Context.Provider' 대신 'Context'를 제공자로 렌더링할 수 있습니다:\n\n```js\nconst ThemeContext = createContext('');\n\nfunction App({children}) {\n  return (\n    <ThemeContext value=\"dark\">\n      {children}\n    </ThemeContext>\n  );  \n}\n```\n\n나중에 React 버전에서는 'Context.Provider'를 사용하지 않도록 지원 중단될 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# ref에 대한 정리 함수\n\n이제 React는 ref 콜백에서 정리 함수를 반환하는 것을 지원합니다:\n\n```js\n<input\n  ref={(ref) => {\n    // ref 생성\n\n    // 새로운 기능: 요소가 DOM에서 제거될 때 ref를 재설정하는 정리 함수를 반환합니다.\n    return () => {\n      // ref 정리\n    };\n  }\n/>\n```\n\n컴포넌트가 언마운트될 때, React는 ref 콜백에서 반환된 정리 함수를 호출합니다. 이는 DOM ref, 클래스 컴포넌트에 대한 ref 및 useImperativeHandle에 대해 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n리팩토링된 ref 정리 함수의 도입으로 인해 TypeScript에서 ref 콜백에서 다른 값을 반환하면 거부됩니다. 이 문제를 해결하는 방법은 일반적으로 암시적 반환을 사용하지 않도록 하는 것입니다. 예를 들어:\n\n```js\n- <div ref={current => (instance = current)} />\n+ <div ref={current => {instance = current} />\n```\n\n원본 코드는 HTMLDivElement의 인스턴스를 반환했으며 TypeScript는 이것이 정리 함수인지 아니면 정리 함수를 반환하고 싶지 않은 것인지를 알 수 없습니다.\n\n# useDeferredValue 초기 값\n\n<div class=\"content-ad\"></div>\n\nReact는 useDeferredValue에 initialValue 옵션을 추가했습니다:\n\n```js\nfunction Search({deferredValue}) {\n  // 초기 렌더링 시 값은 ''입니다.\n  // 그런 다음 다시 렌더링이 예약되고 deferredValue로 업데이트됩니다.\n  const value = useDeferredValue(deferredValue, '');\n  \n  return (\n    <Results query={value} />\n  );\n}\n```\n\ninitialValue가 제공되면 useDeferredValue는 해당 값을 컴포넌트의 초기 렌더링에 반환하고, deferredValue를 사용하여 백그라운드에서 다시 렌더링을 예약합니다.\n\n# 문서 메타데이터 지원\n\n<div class=\"content-ad\"></div>\n\nHTML에서는 `title`, `link`, `meta`와 같은 문서 메타데이터 태그를 문서의 `head` 섹션에 배치하기 위해 예약되어 있어요. React에서는 앱에 적합한 메타데이터를 결정하는 컴포넌트가 `head`를 렌더링하는 곳과 매우 먼 곳에 있을 수 있거나 React가 `head`를 전혀 렌더링하지 않을 수도 있어요. 과거에는 이러한 요소들을 수동으로 삽입해야 했거나 react-helmet과 같은 라이브러리를 사용하여 효과적으로 처리해야 했던 것을 기억하시죠.\n\nReact 19는 컴포넌트에서 문서 메타데이터 태그를 네이티브로 렌더링하는 지원을 제공해요:\n\n```js\nfunction BlogPost({post}) {\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <title>{post.title}</title>\n      <meta name=\"author\" content=\"Josh\" />\n      <link rel=\"author\" href=\"https://twitter.com/joshcstory/\" />\n      <meta name=\"keywords\" content={post.keywords} />\n      <p>\n        Eee equals em-see-squared...\n      </p>\n    </article>\n  );\n}\n```\n\nReact가 이 컴포넌트를 렌더링할 때 `title`, `link`, `meta` 태그를 찾아서 자동으로 문서의 `head` 섹션으로 끌어올려 줘요. 이러한 메타데이터 태그를 네이티브로 지원함으로써 클라이언트 전용 앱, 스트리밍 SSR 및 서버 컴포넌트와 함께 작동하도록 보장할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\nReact 19 업데이트 내용에 대한 의견이 궁금하신가요? React 19의 개선된 기능에 대한 자세한 내용은 React 공식 블로그의 원문을 참조해주세요.\n\n# 간단하게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작성자를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png"},"coverImage":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png","tag":["Tech"],"readingTime":11},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png\" alt=\"이미지\"></p>\n<p>지난 2022년 6월 React의 마지막 안정 버전 이후, 두 년 가까이 새 버전이 나오지 않았는데, 이제 npm에서 React 19 베타판이 안정 버전인 React 18.3.0과 함께 공개되었습니다. React 19 베타판에서 개발자들이 알아야 할 새로운 기능을 살펴보겠습니다.</p>\n<h2>액션</h2>\n<p><img src=\"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_1.png\" alt=\"이미지\"></p>\n<p>리액트 앱에서 흔히 발생하는 사용 사례는 데이터 변이를 수행한 다음 응답에 따라 상태를 업데이트하는 것입니다. 예를 들어, 사용자가 이름을 변경하기 위해 양식을 제출하면 API 요청을 만들고 그 다음 응답을 처리해야 합니다. 과거에는 보류 중인 상태, 오류, 낙관적 업데이트 및 순차 요청을 수동으로 처리해야 했습니다.</p>\n<p>예를 들어, useState로 대기 및 오류 상태를 처리할 수 있었습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 액션 이전</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">UpdateName</span>(<span class=\"hljs-params\">{}</span>) {\n  <span class=\"hljs-keyword\">const</span> [name, setName] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">\"\"</span>);\n  <span class=\"hljs-keyword\">const</span> [error, setError] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">null</span>);\n  <span class=\"hljs-keyword\">const</span> [isPending, setIsPending] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleSubmit</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setIsPending</span>(<span class=\"hljs-literal\">true</span>);\n    <span class=\"hljs-keyword\">const</span> error = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">updateName</span>(name);\n    <span class=\"hljs-title function_\">setIsPending</span>(<span class=\"hljs-literal\">false</span>);\n    <span class=\"hljs-keyword\">if</span> (error) {\n      <span class=\"hljs-title function_\">setError</span>(error);\n      <span class=\"hljs-keyword\">return</span>;\n    } \n    <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">\"/경로\"</span>);\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{name}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(event)</span> =></span> setName(event.target.value)} />\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleSubmit}</span> <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{isPending}</span>></span>\n        업데이트\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      {error &#x26;&#x26; <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{error}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n</code></pre>\n<p>리액트 19에서는 전이에 비동기 함수를 사용하여 대기 중인 상태, 오류, 양식 및 낙관적 업데이트를 자동으로 처리할 수 있는 지원이 추가되었습니다.</p>\n<p>예를 들어, useTransition을 사용하여 대기 상태를 처리할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Actions에서 대기 상태 사용하기</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">UpdateName</span>(<span class=\"hljs-params\">{}</span>) {\n  <span class=\"hljs-keyword\">const</span> [name, setName] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">\"\"</span>);\n  <span class=\"hljs-keyword\">const</span> [error, setError] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">null</span>);\n  <span class=\"hljs-keyword\">const</span> [isPending, startTransition] = <span class=\"hljs-title function_\">useTransition</span>();\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleSubmit</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">startTransition</span>(<span class=\"hljs-keyword\">async</span> () => {\n      <span class=\"hljs-keyword\">const</span> error = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">updateName</span>(name);\n      <span class=\"hljs-keyword\">if</span> (error) {\n        <span class=\"hljs-title function_\">setError</span>(error);\n        <span class=\"hljs-keyword\">return</span>;\n      } \n      <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">\"/path\"</span>);\n    })\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{name}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(event)</span> =></span> setName(event.target.value)} />\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleSubmit}</span> <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{isPending}</span>></span>\n        Update\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      {error &#x26;&#x26; <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{error}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n</code></pre>\n<p>비동기 전환은 즉시 isPending 상태를 true로 설정하고 비동기 요청을 수행한 다음 이전 전환 후에 isPending를 false로 전환합니다. 이렇게 하면 데이터가 변경되는 동안에도 현재 UI를 반응적이고 상호작용할 수 있게 유지할 수 있습니다.</p>\n<p>관례적으로, 비동기 전환을 사용하는 함수는 \"Actions\"라고 합니다.</p>\n<p>동작은 데이터 제출을 자동으로 처리해줍니다:</p>\n<ul>\n<li>보류 상태: 동작은 요청의 시작부터 시작되는 보류 상태를 제공하며, 최종 상태 업데이트가 완료될 때 자동으로 재설정됩니다.</li>\n<li>낙관적 업데이트: 동작은 새로운 useOptimistic 훅을 지원하여 요청이 제출되는 동안 사용자에게 즉시 피드백을 제공할 수 있습니다.</li>\n<li>오류 처리: 동작은 오류 처리를 제공하여 요청이 실패했을 때 오류 경계를 표시하고, 낙관적 업데이트를 자동으로 원래 값으로 되돌립니다.</li>\n<li>폼: 이제 <code>form</code> 요소는 동작과 formAction props에 함수를 전달할 수 있습니다. action props에 함수를 전달하면 기본적으로 동작을 사용하고 제출 후 자동으로 폼을 재설정합니다.</li>\n</ul>\n<p>React 19에서 동작을 기반으로하면 낙관적 업데이트를 관리하는 useOptimistic 및 동작의 공통 사례를 처리하는 새로운 hook인 React.useActionState를 도입했습니다. react-dom에서는 <code>form</code> 동작을 사용하여 폼을 자동으로 처리하고, 동작의 공통 사례를 지원하는 useFormStatus를 추가했습니다.</p>\n<p>React 19에서 위 예제는 간단하게 변경될 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// &#x3C;form> 작업 및 useActionState 사용하기</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ChangeName</span>(<span class=\"hljs-params\">{ name, setName }</span>) {\n  <span class=\"hljs-keyword\">const</span> [error, submitAction, isPending] = <span class=\"hljs-title function_\">useActionState</span>(\n    <span class=\"hljs-keyword\">async</span> (previousState, formData) => {\n      <span class=\"hljs-keyword\">const</span> error = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">updateName</span>(formData.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"name\"</span>));\n      <span class=\"hljs-keyword\">if</span> (error) {\n        <span class=\"hljs-keyword\">return</span> error;\n      }\n      <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">\"/path\"</span>);\n    }\n  );\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">{submitAction}</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span> <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{isPending}</span>></span>업데이트<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      {error &#x26;&#x26; <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{error}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">form</span>></span></span>\n  );\n}\n</code></pre>\n<h1>새로운 훅: useActionState</h1>\n<p>React 19에서 일반적인 케이스를 보다 쉽게 만들기 위해 useActionState라는 새로운 훅이 추가되었습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> [error, submitAction, isPending] = <span class=\"hljs-title function_\">useActionState</span>(<span class=\"hljs-keyword\">async</span> (previousState, newName) => {\n  <span class=\"hljs-keyword\">const</span> error = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">updateName</span>(newName);\n  <span class=\"hljs-keyword\">if</span> (error) {\n    <span class=\"hljs-comment\">// 작업의 결과로 어떤 것이든 반환할 수 있습니다.</span>\n    <span class=\"hljs-comment\">// 여기서는 오직 에러만 반환합니다.</span>\n    <span class=\"hljs-keyword\">return</span> error;\n  }\n  \n  <span class=\"hljs-comment\">// 성공 처리</span>\n});\n</code></pre>\n<p><code>useActionState</code> 함수는 함수(액션)를 인수로 받아 감싼 액션을 호출합니다. 이는 액션이 조합되기 때문에 작동합니다. 감싼 액션이 호출되면 <code>useActionState</code>는 액션의 마지막 결과를 데이터로 반환하고 액션의 보류 상태를 보류로 반환합니다.</p>\n<h1>React DOM: form 액션</h1>\n<p>React 19의 새로운 <code>form</code> 기능에 액션도 통합되어 있습니다. <code>form</code>, <code>input</code>, 그리고 <code>button</code> 엘리먼트의 액션과 formAction 프롭으로 함수를 전달하여 액션과 함께 자동으로 폼을 제출할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">&#x3C;form action={actionFunction}>\n</code></pre>\n<p><code>form</code>이 성공하면 React는 제어되지 않는 컴포넌트를 위해 자동으로 <code>form</code>을 재설정합니다. <code>form</code>을 수동으로 재설정해야 하는 경우, 새 요청 <code>form</code> 재설정 React DOM API를 호출할 수 있습니다.</p>\n<h1>React DOM: 새로운 훅: useFormStatus</h1>\n<p>디자인 시스템에서 <code>form</code>에 대한 정보에 액세스해야 하는 디자인 컴포넌트를 작성하는 것이 일반적입니다. 그러나 컴포넌트로 속성을 전달 받지 않아도 되도록 하는 경우가 있습니다. 이 작업은 Context를 통해 수행할 수 있지만, 일반적인 경우를 쉽게 만들기 위해 React 19에 새로운 훅인 useFormStatus가 추가되었습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {useFormStatus} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-dom'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">DesignButton</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> {pending} = <span class=\"hljs-title function_\">useFormStatus</span>();\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span> <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{pending}</span> /></span></span>\n}\n</code></pre>\n<p><code>useFormStatus</code>는 부모 <code>form</code>의 상태를 읽어오는 것처럼 동작하여, 마치 form이 Context 제공자인 것처럼 사용할 수 있습니다.</p>\n<h1>새로운 훅: useOptimistic</h1>\n<p>데이터 변경 작업을 수행할 때 또 다른 일반적인 UI 패턴은 비동기 요청 진행 중에 최종 상태를 낙관적으로 표시하는 것입니다. React 19에서는 이를 쉽게 처리할 수 있도록 <code>useOptimistic</code>라는 새로운 훅이 추가되었습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ChangeName</span>(<span class=\"hljs-params\">{currentName, onUpdateName}</span>) {\n  <span class=\"hljs-keyword\">const</span> [optimisticName, setOptimisticName] = <span class=\"hljs-title function_\">useOptimistic</span>(currentName);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">submitAction</span> = <span class=\"hljs-keyword\">async</span> formData => {\n    <span class=\"hljs-keyword\">const</span> newName = formData.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"name\"</span>);\n    <span class=\"hljs-title function_\">setOptimisticName</span>(newName);\n    <span class=\"hljs-keyword\">const</span> updatedName = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">updateName</span>(newName);\n    <span class=\"hljs-title function_\">onUpdateName</span>(updatedName);\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">{submitAction}</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>Your name is: {optimisticName}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>Change Name:<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span>\n          <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>\n          <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span>\n          <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{currentName</span> !== <span class=\"hljs-string\">optimisticName}</span>\n        /></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">form</span>></span></span>\n  );\n}\n</code></pre>\n<p><code>useOptimistic</code> 훅은 <code>updateName</code> 요청이 진행 중일 때 즉시 <code>optimisticName</code>을 렌더링합니다. 업데이트가 완료되거나 에러가 발생하면 React가 자동으로 <code>currentName</code> 값으로 전환됩니다.</p>\n<h1>새 API: use</h1>\n<p>React 19에서 렌더링하는 동안 리소스를 읽기 위한 새로운 API가 추가되었습니다: <code>use</code>.</p>\n<p>예를 들어, <code>use</code>로 프로미스를 읽을 수 있으며, React가 프로미스가 해결될 때까지 일시 중단됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {use} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Comments</span>(<span class=\"hljs-params\">{commentsPromise}</span>) {\n  <span class=\"hljs-comment\">// `use`가 프로미스가 해결될 때까지 일시 중단됩니다.</span>\n  <span class=\"hljs-keyword\">const</span> comments = <span class=\"hljs-title function_\">use</span>(commentsPromise);\n  <span class=\"hljs-keyword\">return</span> comments.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">comment</span> =></span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{comment.id}</span>></span>{comment}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Page</span>(<span class=\"hljs-params\">{commentsPromise}</span>) {\n  <span class=\"hljs-comment\">// Comments에서 `use`가 일시 중단되면</span>\n  <span class=\"hljs-comment\">// 이 Suspense 경계가 표시됩니다.</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">div</span>></span>Loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>}>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Comments</span> <span class=\"hljs-attr\">commentsPromise</span>=<span class=\"hljs-string\">{commentsPromise}</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Suspense</span>></span></span>\n  )\n}\n</code></pre>\n<p>렌더링되는 동안 생성된 프로미스를 지원하지 않습니다.</p>\n<p>렌더링에서 만든 프로미스를 use에 전달하려고 하면 React에서 경고합니다:</p>\n<p>수정하려면, 프로미스 캐싱을 지원하는 suspense 기반 라이브러리나 프레임워크에서 프로미스를 전달해야 합니다. 미래에는 렌더링 중에 프로미스를 캐싱하기 쉽게 만드는 기능을 제공할 예정입니다.</p>\n<p>또한 일찍 반환한 후와 같이 조건부로 Context를 읽을 수도 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {use} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ThemeContext</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ThemeContext'</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Heading</span>(<span class=\"hljs-params\">{children}</span>) {\n  <span class=\"hljs-keyword\">if</span> (children == <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  }\n  \n  <span class=\"hljs-comment\">// 일찍 반환으로 인해 useContext로 동작하지 않습니다.</span>\n  <span class=\"hljs-keyword\">const</span> theme = <span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title class_\">ThemeContext</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{color:</span> <span class=\"hljs-attr\">theme.color</span>}}></span>\n      {children}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></span>\n  );\n}\n</code></pre>\n<p>use API는 후크와 유사하게 렌더링 중에만 호출될 수 있습니다. 후크와는 다르게 use는 조건부로 호출할 수 있습니다.</p>\n<p>자세한 정보는 use에 대한 문서를 참조하세요.</p>\n<h1>ref을 속성으로 사용하기</h1>\n<p>React 19부터 함수 컴포넌트에서 ref를 속성으로 접근할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyInput</span>(<span class=\"hljs-params\">{placeholder, ref}</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">{placeholder}</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{ref}</span> /></span></span>\n}\n\n<span class=\"hljs-comment\">//...</span>\n&#x3C;<span class=\"hljs-title class_\">MyInput</span> ref={ref} />\n</code></pre>\n<p>새로운 함수 컴포넌트는 더 이상 forwardRef가 필요하지 않습니다. 향후 버전에서 React는 forwardRef를 사용하지 않도록 하고 제거할 예정입니다.</p>\n<h1>'Context'를 제공자로 렌더링하기</h1>\n<p>React 19에서 'Context.Provider' 대신 'Context'를 제공자로 렌더링할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ThemeContext</span> = <span class=\"hljs-title function_\">createContext</span>(<span class=\"hljs-string\">''</span>);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\">{children}</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ThemeContext</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"dark\"</span>></span>\n      {children}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ThemeContext</span>></span></span>\n  );  \n}\n</code></pre>\n<p>나중에 React 버전에서는 'Context.Provider'를 사용하지 않도록 지원 중단될 예정입니다.</p>\n<h1>ref에 대한 정리 함수</h1>\n<p>이제 React는 ref 콜백에서 정리 함수를 반환하는 것을 지원합니다:</p>\n<pre><code class=\"hljs language-js\">&#x3C;input\n  ref={<span class=\"hljs-function\">(<span class=\"hljs-params\">ref</span>) =></span> {\n    <span class=\"hljs-comment\">// ref 생성</span>\n\n    <span class=\"hljs-comment\">// 새로운 기능: 요소가 DOM에서 제거될 때 ref를 재설정하는 정리 함수를 반환합니다.</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-comment\">// ref 정리</span>\n    };\n  }\n/>\n</code></pre>\n<p>컴포넌트가 언마운트될 때, React는 ref 콜백에서 반환된 정리 함수를 호출합니다. 이는 DOM ref, 클래스 컴포넌트에 대한 ref 및 useImperativeHandle에 대해 작동합니다.</p>\n<p>리팩토링된 ref 정리 함수의 도입으로 인해 TypeScript에서 ref 콜백에서 다른 값을 반환하면 거부됩니다. 이 문제를 해결하는 방법은 일반적으로 암시적 반환을 사용하지 않도록 하는 것입니다. 예를 들어:</p>\n<pre><code class=\"hljs language-js\">- <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{current</span> =></span> (instance = current)} /></span>\n+ <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{current</span> =></span> {instance = current} /></span>\n</code></pre>\n<p>원본 코드는 HTMLDivElement의 인스턴스를 반환했으며 TypeScript는 이것이 정리 함수인지 아니면 정리 함수를 반환하고 싶지 않은 것인지를 알 수 없습니다.</p>\n<h1>useDeferredValue 초기 값</h1>\n<p>React는 useDeferredValue에 initialValue 옵션을 추가했습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Search</span>(<span class=\"hljs-params\">{deferredValue}</span>) {\n  <span class=\"hljs-comment\">// 초기 렌더링 시 값은 ''입니다.</span>\n  <span class=\"hljs-comment\">// 그런 다음 다시 렌더링이 예약되고 deferredValue로 업데이트됩니다.</span>\n  <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title function_\">useDeferredValue</span>(deferredValue, <span class=\"hljs-string\">''</span>);\n  \n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Results</span> <span class=\"hljs-attr\">query</span>=<span class=\"hljs-string\">{value}</span> /></span></span>\n  );\n}\n</code></pre>\n<p>initialValue가 제공되면 useDeferredValue는 해당 값을 컴포넌트의 초기 렌더링에 반환하고, deferredValue를 사용하여 백그라운드에서 다시 렌더링을 예약합니다.</p>\n<h1>문서 메타데이터 지원</h1>\n<p>HTML에서는 <code>title</code>, <code>link</code>, <code>meta</code>와 같은 문서 메타데이터 태그를 문서의 <code>head</code> 섹션에 배치하기 위해 예약되어 있어요. React에서는 앱에 적합한 메타데이터를 결정하는 컴포넌트가 <code>head</code>를 렌더링하는 곳과 매우 먼 곳에 있을 수 있거나 React가 <code>head</code>를 전혀 렌더링하지 않을 수도 있어요. 과거에는 이러한 요소들을 수동으로 삽입해야 했거나 react-helmet과 같은 라이브러리를 사용하여 효과적으로 처리해야 했던 것을 기억하시죠.</p>\n<p>React 19는 컴포넌트에서 문서 메타데이터 태그를 네이티브로 렌더링하는 지원을 제공해요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">BlogPost</span>(<span class=\"hljs-params\">{post}</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">article</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{post.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">title</span>></span>{post.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">title</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"author\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"Josh\"</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"author\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"https://twitter.com/joshcstory/\"</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"keywords\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">{post.keywords}</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>\n        Eee equals em-see-squared...\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">article</span>></span></span>\n  );\n}\n</code></pre>\n<p>React가 이 컴포넌트를 렌더링할 때 <code>title</code>, <code>link</code>, <code>meta</code> 태그를 찾아서 자동으로 문서의 <code>head</code> 섹션으로 끌어올려 줘요. 이러한 메타데이터 태그를 네이티브로 지원함으로써 클라이언트 전용 앱, 스트리밍 SSR 및 서버 컴포넌트와 함께 작동하도록 보장할 수 있어요.</p>\n<p>React 19 업데이트 내용에 대한 의견이 궁금하신가요? React 19의 개선된 기능에 대한 자세한 내용은 React 공식 블로그의 원문을 참조해주세요.</p>\n<h1>간단하게 설명하기 🚀</h1>\n<p>In Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:</p>\n<ul>\n<li>작성자를 클랩하고 팔로우해주세요 ️👏️️</li>\n<li>팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터</li>\n<li>다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed</li>\n<li>PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}