{"pageProps":{"post":{"title":"Nestjs 오류 처리","description":"","date":"2024-06-19 23:16","slug":"2024-06-19-NestjsErrorHandling","content":"\n\n<img src=\"/assets/img/2024-06-19-NestjsErrorHandling_0.png\" />\n\n# 1. 소개\n\nNestJs는 백엔드 시스템을 개발하는 데 사용되는 프레임워크입니다. 이 프레임워크는 컨트롤러 레이어에서 오류 처리에 대한 규칙을 정의했지만, 이는 대규모 프로젝트에는 충분하지 않을 수 있습니다. 본 문서에서는 오류를 우아하게 처리하고 신중하게 대우하는 더 효과적이고 구조화된 접근 방식을 소개합니다.\n\n# 2. 오류 처리 전략\n\n<div class=\"content-ad\"></div>\n\n# 에러 유형\n\n코드에서 발생할 수 있는 에러 유형을 정의해보겠습니다:\n\n- 유효성 검사 에러\n- 제삼자 에러\n- 데이터베이스 에러\n- 일반(예기치 않은) 에러\n\n언급된 모든 종류의 에러에 특히 주의해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n특정 오류, 예를 들어 유효성 검사 오류와 같은 경우 적절한 응답이나 상태 코드로 처리할 수 있습니다. 그러나 일반 오류와 같은 다른 종류의 오류의 경우, 유지보수자에게 알리거나 높은 우선순위로 티켓을 생성하는 등의 추가 조치가 필요할 수 있습니다. 또 다른 오류 유형인 데이터베이스 오류는 복구와 복원 논리가 필요할 수 있습니다.\n\n# 3. 다른 계층에서의 오류 처리\n\n저는 우리의 응용프로그램 계층을 다음과 같이 분류하는 것을 선호합니다:\n\n- 요청 계층\n- 인터셉터\n- 가드\n- 컨트롤러 계층(*)\n- 서비스 계층\n- 모델\n- 데이터베이스\n- 예외 처리 계층\n\n<div class=\"content-ad\"></div>\n\n컨트롤러 레이어 아래의 모든 레이어에서 오류가 발생하면 상위 레이어로 throw해야 합니다. 예를 들어:\n\n- 데이터베이스 CRUD 함수(ORM 함수 등)에서 오류가 발생하면 Database Error 유형을 throw해야 합니다.\n- 서드파티 호출(Stripe 등)에서 오류가 발생하면 Third-party 에러 유형을 throw해야 합니다.\n- 예기치 않은 오류가 발생하면 Generic 에러 유형으로 간주해야 합니다.\n- 등등\n\n```js\nasync sampleFucntion(@AuthenticatedUser() jwtPayload: JwtDto) {\n        try {\n            return this.utilsService.apiResponse(200, await this.sampleService.sampleServiceFucntion(jwtPayload.id))\n        } catch (error) {\n            this.utilsService.handleError(error, jwtPayload, {}, 'description')\n        }\n    }\n```\n\n언급한 모든 오류는 상위 레이어로 throw되어야 하며, throw된 오류를 받은 해당 레이어도 Controller 레이어가 `try-catch` 블록에서 오류를 받게 될 때까지 throw해야 합니다. 그런 다음 Controller 레이어는 잡힌 오류를 utils 모듈이나 errors 모듈에 포함된 `ErrorHandler` 함수로 전달해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 오류 처리기 함수\n\n이 함수는 받은 오류 유형을 Switch-case 또는 if-else 방식으로 감지하여 처리해야 합니다.\n\n```js\nhandleError(error, jwt: JwtDto, additionalInfo: any, description: string): void {\n        if (error instanceof CheckingException) {\n            throw new CheckingException(error.message, error.statusCode,error.messageData)\n        } else if (error instanceof DatabaseException) {\n            throw new DatabaseException(error.message, error, error.queryParams, description)\n        } else if (error instanceof StripeErrorException) {\n            throw new StripeErrorException(error as Stripe.errors.StripeError, error.stack, description)\n        } else if (error instanceof HttpException){\n                throw error\n        } else {\n            throw new GenericException(error.message, error, jwt, additionalInfo, description)\n        }\n    }\n```\n\n유형을 감지한 후, 각 오류 유형에 적합한 매개변수로 오류 유형을 생성하고 해당 오류를 throw해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n샘플 Exception 클래스:\n\n```js\nexport class DatabaseException extends Error {\n    queryParams: any\n    description: any\n    stack:any\n    message : string\n    constructor(message: string,error: Error, q: any, description?: string) {\n        super(`데이터베이스 오류가 발생했습니다: ${message}`)\n        this.queryParams = q\n        this.description = description\n        this.stack = error.stack\n        this.message = error.message\n    }\n}\n```\n\n특정 APP_FILTER를 정의하고 app.module에서 등록해야 합니다:\n\n```js\nproviders: [\n    {\n        provide: APP_FILTER,\n        useClass: GenericExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: checkingExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: DatabaseExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: StripeExceptionFilter,\n    },\n    AppService,\n    UtilsService,\n    JwtService,\n    LoggerService,\n]\n```\n\n<div class=\"content-ad\"></div>\n\n예외 필터에서는 이제 이러한 오류 중 하나에 완벽하게 대응해야 합니다:\n다음 조건을 고려해 주세요:\n\n- 데이터베이스 및 일반적인 오류는 유지보수자에게 알리고 처리된 오류에 대한 사용자 응답이 있어야 합니다.\n- Stripe 및 Checking(유효성) 오류는 사용자에게만 응답해야 합니다.\n\n데이터베이스 및 일반적인 오류에 대한 샘플 예외 필터:\n\n```js\n// database.filter.ts\nimport { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common'\nimport { LoggerService } from '../../../../logger/logger.service'\nimport { GenericException } from './generic.exception'\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@Catch(GenericException)\nexport class GenericExceptionFilter implements ExceptionFilter {\n    constructor(private readonly loggerService: LoggerService) {}\n    catch(exception: GenericException, host: ArgumentsHost) {\n        const ctx = host.switchToHttp()\n        const response = ctx.getResponse()\n        const errorData = {\n            description: exception.description,\n            stack: exception.stack,\n            jwtPayload: exception.jwtPayload,\n            additionalInfo: exception.additionalInfo,\n            message: exception.message,\n        }\n        this.loggerService.error(exception.message, errorData)\n        response.status(500).json({\n            statusCode: 500,\n            message: exception.message,\n            error: 'Error',\n        })\n    }\n}\n```\n\nWinston 로거를 사용하여 오류 수준 로그를 송신 및 티켓 생성을 위해 로그 전송기를 정의했습니다:\n\nthis.loggerService.error(exception.message, errorData)\n\n일반적인 오류(외부 라이브러리 또는 유효성 검사 오류)에 대한 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common'\nimport { CheckingException } from './checking.exception'\n```\n\n```js\n@Catch(CheckingException)\nexport class checkingExceptionFilter implements ExceptionFilter {\n    catch(exception: CheckingException, host: ArgumentsHost) {\n        const ctx = host.switchToHttp()\n        const response = ctx.getResponse()\n        response.status(exception.statusCode).json({\n            statusCode: exception.statusCode,\n            message: exception.messageData,\n            error: exception.message,\n        })\n    }\n}\n```\n\n# 모니터링 도구\n\n더 나은 오류 처리를 위해 몇 가지 도구를 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- Sentry\n- Raygun\n- Winston\n- 등\n\n이 프로젝트에서는 Raygun을 사용하여 오류 모니터링 및 보고를 합니다.\n\n## Raygun\n\nRaygun은 개발자가 애플리케이션에서 문제를 식별하고 전체 소프트웨어 품질을 향상시키는 종합 오류, 충돌 및 성능 모니터링 솔루션입니다.\n\n<div class=\"content-ad\"></div>\n\n```typescript\nasync createUser(createUserDto: CreateUserDto): Promise<User> {\n    try {\n      // 사용자 생성을 위한 비즈니스 로직\n    } catch (error) {\n      this.raygunLoggerService.error('사용자 생성 실패', error.stack);\n      throw new Error('사용자 생성 실패');\n    }\n```\n\n성능 모니터링\n\n- Raygun은 성능 메트릭을 추적하고 응용 프로그램의 병목 현상을 식별하는 실제 사용자 모니터링 (RUM) 및 응용 프로그램 성능 모니터링 (APM)도 제공합니다.\n\nRaygun 대시보드\n\n<div class=\"content-ad\"></div>\n\nRaygun 대시 보드에 액세스하여 자세한 오류 보고서를 확인하고 응용 프로그램 성능을 추적하며 중요한 문제에 대한 경보 및 알림을 설정할 수 있습니다.\n\nRaygun을 NestJS 애플리케이션에 통합하면 오류 및 성능 문제에 대한 강력한 통찰력을 얻어 문제를 선제적으로 해결하고 소프트웨어의 전반적인 안정성과 신뢰성을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-NestjsErrorHandling_0.png"},"coverImage":"/assets/img/2024-06-19-NestjsErrorHandling_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>1. 소개</h1>\n<p>NestJs는 백엔드 시스템을 개발하는 데 사용되는 프레임워크입니다. 이 프레임워크는 컨트롤러 레이어에서 오류 처리에 대한 규칙을 정의했지만, 이는 대규모 프로젝트에는 충분하지 않을 수 있습니다. 본 문서에서는 오류를 우아하게 처리하고 신중하게 대우하는 더 효과적이고 구조화된 접근 방식을 소개합니다.</p>\n<h1>2. 오류 처리 전략</h1>\n<h1>에러 유형</h1>\n<p>코드에서 발생할 수 있는 에러 유형을 정의해보겠습니다:</p>\n<ul>\n<li>유효성 검사 에러</li>\n<li>제삼자 에러</li>\n<li>데이터베이스 에러</li>\n<li>일반(예기치 않은) 에러</li>\n</ul>\n<p>언급된 모든 종류의 에러에 특히 주의해야 합니다.</p>\n<p>특정 오류, 예를 들어 유효성 검사 오류와 같은 경우 적절한 응답이나 상태 코드로 처리할 수 있습니다. 그러나 일반 오류와 같은 다른 종류의 오류의 경우, 유지보수자에게 알리거나 높은 우선순위로 티켓을 생성하는 등의 추가 조치가 필요할 수 있습니다. 또 다른 오류 유형인 데이터베이스 오류는 복구와 복원 논리가 필요할 수 있습니다.</p>\n<h1>3. 다른 계층에서의 오류 처리</h1>\n<p>저는 우리의 응용프로그램 계층을 다음과 같이 분류하는 것을 선호합니다:</p>\n<ul>\n<li>요청 계층</li>\n<li>인터셉터</li>\n<li>가드</li>\n<li>컨트롤러 계층(*)</li>\n<li>서비스 계층</li>\n<li>모델</li>\n<li>데이터베이스</li>\n<li>예외 처리 계층</li>\n</ul>\n<p>컨트롤러 레이어 아래의 모든 레이어에서 오류가 발생하면 상위 레이어로 throw해야 합니다. 예를 들어:</p>\n<ul>\n<li>데이터베이스 CRUD 함수(ORM 함수 등)에서 오류가 발생하면 Database Error 유형을 throw해야 합니다.</li>\n<li>서드파티 호출(Stripe 등)에서 오류가 발생하면 Third-party 에러 유형을 throw해야 합니다.</li>\n<li>예기치 않은 오류가 발생하면 Generic 에러 유형으로 간주해야 합니다.</li>\n<li>등등</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">sampleFucntion</span>(<span class=\"hljs-params\">@AuthenticatedUser() jwtPayload: JwtDto</span>) {\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">utilsService</span>.<span class=\"hljs-title function_\">apiResponse</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sampleService</span>.<span class=\"hljs-title function_\">sampleServiceFucntion</span>(jwtPayload.<span class=\"hljs-property\">id</span>))\n        } <span class=\"hljs-keyword\">catch</span> (error) {\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">utilsService</span>.<span class=\"hljs-title function_\">handleError</span>(error, jwtPayload, {}, <span class=\"hljs-string\">'description'</span>)\n        }\n    }\n</code></pre>\n<p>언급한 모든 오류는 상위 레이어로 throw되어야 하며, throw된 오류를 받은 해당 레이어도 Controller 레이어가 <code>try-catch</code> 블록에서 오류를 받게 될 때까지 throw해야 합니다. 그런 다음 Controller 레이어는 잡힌 오류를 utils 모듈이나 errors 모듈에 포함된 <code>ErrorHandler</code> 함수로 전달해야 합니다.</p>\n<h1>오류 처리기 함수</h1>\n<p>이 함수는 받은 오류 유형을 Switch-case 또는 if-else 방식으로 감지하여 처리해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">handleError</span>(error, <span class=\"hljs-attr\">jwt</span>: <span class=\"hljs-title class_\">JwtDto</span>, <span class=\"hljs-attr\">additionalInfo</span>: any, <span class=\"hljs-attr\">description</span>: string): <span class=\"hljs-keyword\">void</span> {\n        <span class=\"hljs-keyword\">if</span> (error <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">CheckingException</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CheckingException</span>(error.<span class=\"hljs-property\">message</span>, error.<span class=\"hljs-property\">statusCode</span>,error.<span class=\"hljs-property\">messageData</span>)\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (error <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">DatabaseException</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DatabaseException</span>(error.<span class=\"hljs-property\">message</span>, error, error.<span class=\"hljs-property\">queryParams</span>, description)\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (error <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">StripeErrorException</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StripeErrorException</span>(error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Stripe</span>.<span class=\"hljs-property\">errors</span>.<span class=\"hljs-property\">StripeError</span>, error.<span class=\"hljs-property\">stack</span>, description)\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (error <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HttpException</span>){\n                <span class=\"hljs-keyword\">throw</span> error\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">GenericException</span>(error.<span class=\"hljs-property\">message</span>, error, jwt, additionalInfo, description)\n        }\n    }\n</code></pre>\n<p>유형을 감지한 후, 각 오류 유형에 적합한 매개변수로 오류 유형을 생성하고 해당 오류를 throw해야 합니다.</p>\n<p>샘플 Exception 클래스:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DatabaseException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Error</span> {\n    <span class=\"hljs-attr\">queryParams</span>: any\n    <span class=\"hljs-attr\">description</span>: any\n    <span class=\"hljs-attr\">stack</span>:any\n    message : string\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">message: string,error: <span class=\"hljs-built_in\">Error</span>, q: any, description?: string</span>) {\n        <span class=\"hljs-variable language_\">super</span>(<span class=\"hljs-string\">`데이터베이스 오류가 발생했습니다: <span class=\"hljs-subst\">${message}</span>`</span>)\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">queryParams</span> = q\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">description</span> = description\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stack</span> = error.<span class=\"hljs-property\">stack</span>\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span> = error.<span class=\"hljs-property\">message</span>\n    }\n}\n</code></pre>\n<p>특정 APP_FILTER를 정의하고 app.module에서 등록해야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">providers</span>: [\n    {\n        <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">APP_FILTER</span>,\n        <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">GenericExceptionFilter</span>,\n    },\n    {\n        <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">APP_FILTER</span>,\n        <span class=\"hljs-attr\">useClass</span>: checkingExceptionFilter,\n    },\n    {\n        <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">APP_FILTER</span>,\n        <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">DatabaseExceptionFilter</span>,\n    },\n    {\n        <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">APP_FILTER</span>,\n        <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">StripeExceptionFilter</span>,\n    },\n    <span class=\"hljs-title class_\">AppService</span>,\n    <span class=\"hljs-title class_\">UtilsService</span>,\n    <span class=\"hljs-title class_\">JwtService</span>,\n    <span class=\"hljs-title class_\">LoggerService</span>,\n]\n</code></pre>\n<p>예외 필터에서는 이제 이러한 오류 중 하나에 완벽하게 대응해야 합니다:\n다음 조건을 고려해 주세요:</p>\n<ul>\n<li>데이터베이스 및 일반적인 오류는 유지보수자에게 알리고 처리된 오류에 대한 사용자 응답이 있어야 합니다.</li>\n<li>Stripe 및 Checking(유효성) 오류는 사용자에게만 응답해야 합니다.</li>\n</ul>\n<p>데이터베이스 및 일반적인 오류에 대한 샘플 예외 필터:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// database.filter.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ArgumentsHost</span>, <span class=\"hljs-title class_\">Catch</span>, <span class=\"hljs-title class_\">ExceptionFilter</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">LoggerService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../../../../logger/logger.service'</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">GenericException</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./generic.exception'</span>\n</code></pre>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Catch</span>(<span class=\"hljs-title class_\">GenericException</span>)\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenericExceptionFilter</span> implements <span class=\"hljs-title class_\">ExceptionFilter</span> {\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private readonly loggerService: LoggerService</span>) {}\n    <span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-attr\">exception</span>: <span class=\"hljs-title class_\">GenericException</span>, <span class=\"hljs-attr\">host</span>: <span class=\"hljs-title class_\">ArgumentsHost</span>) {\n        <span class=\"hljs-keyword\">const</span> ctx = host.<span class=\"hljs-title function_\">switchToHttp</span>()\n        <span class=\"hljs-keyword\">const</span> response = ctx.<span class=\"hljs-title function_\">getResponse</span>()\n        <span class=\"hljs-keyword\">const</span> errorData = {\n            <span class=\"hljs-attr\">description</span>: exception.<span class=\"hljs-property\">description</span>,\n            <span class=\"hljs-attr\">stack</span>: exception.<span class=\"hljs-property\">stack</span>,\n            <span class=\"hljs-attr\">jwtPayload</span>: exception.<span class=\"hljs-property\">jwtPayload</span>,\n            <span class=\"hljs-attr\">additionalInfo</span>: exception.<span class=\"hljs-property\">additionalInfo</span>,\n            <span class=\"hljs-attr\">message</span>: exception.<span class=\"hljs-property\">message</span>,\n        }\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">loggerService</span>.<span class=\"hljs-title function_\">error</span>(exception.<span class=\"hljs-property\">message</span>, errorData)\n        response.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">500</span>).<span class=\"hljs-title function_\">json</span>({\n            <span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-number\">500</span>,\n            <span class=\"hljs-attr\">message</span>: exception.<span class=\"hljs-property\">message</span>,\n            <span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">'Error'</span>,\n        })\n    }\n}\n</code></pre>\n<p>Winston 로거를 사용하여 오류 수준 로그를 송신 및 티켓 생성을 위해 로그 전송기를 정의했습니다:</p>\n<p>this.loggerService.error(exception.message, errorData)</p>\n<p>일반적인 오류(외부 라이브러리 또는 유효성 검사 오류)에 대한 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ArgumentsHost</span>, <span class=\"hljs-title class_\">Catch</span>, <span class=\"hljs-title class_\">ExceptionFilter</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">CheckingException</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./checking.exception'</span>\n</code></pre>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Catch</span>(<span class=\"hljs-title class_\">CheckingException</span>)\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">checkingExceptionFilter</span> implements <span class=\"hljs-title class_\">ExceptionFilter</span> {\n    <span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-attr\">exception</span>: <span class=\"hljs-title class_\">CheckingException</span>, <span class=\"hljs-attr\">host</span>: <span class=\"hljs-title class_\">ArgumentsHost</span>) {\n        <span class=\"hljs-keyword\">const</span> ctx = host.<span class=\"hljs-title function_\">switchToHttp</span>()\n        <span class=\"hljs-keyword\">const</span> response = ctx.<span class=\"hljs-title function_\">getResponse</span>()\n        response.<span class=\"hljs-title function_\">status</span>(exception.<span class=\"hljs-property\">statusCode</span>).<span class=\"hljs-title function_\">json</span>({\n            <span class=\"hljs-attr\">statusCode</span>: exception.<span class=\"hljs-property\">statusCode</span>,\n            <span class=\"hljs-attr\">message</span>: exception.<span class=\"hljs-property\">messageData</span>,\n            <span class=\"hljs-attr\">error</span>: exception.<span class=\"hljs-property\">message</span>,\n        })\n    }\n}\n</code></pre>\n<h1>모니터링 도구</h1>\n<p>더 나은 오류 처리를 위해 몇 가지 도구를 사용할 수 있습니다:</p>\n<ul>\n<li>Sentry</li>\n<li>Raygun</li>\n<li>Winston</li>\n<li>등</li>\n</ul>\n<p>이 프로젝트에서는 Raygun을 사용하여 오류 모니터링 및 보고를 합니다.</p>\n<h2>Raygun</h2>\n<p>Raygun은 개발자가 애플리케이션에서 문제를 식별하고 전체 소프트웨어 품질을 향상시키는 종합 오류, 충돌 및 성능 모니터링 솔루션입니다.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">createUser</span>(<span class=\"hljs-attr\">createUserDto</span>: <span class=\"hljs-title class_\">CreateUserDto</span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-title class_\">User</span>> {\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-comment\">// 사용자 생성을 위한 비즈니스 로직</span>\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">raygunLoggerService</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'사용자 생성 실패'</span>, error.<span class=\"hljs-property\">stack</span>);\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">'사용자 생성 실패'</span>);\n    }\n</code></pre>\n<p>성능 모니터링</p>\n<ul>\n<li>Raygun은 성능 메트릭을 추적하고 응용 프로그램의 병목 현상을 식별하는 실제 사용자 모니터링 (RUM) 및 응용 프로그램 성능 모니터링 (APM)도 제공합니다.</li>\n</ul>\n<p>Raygun 대시보드</p>\n<p>Raygun 대시 보드에 액세스하여 자세한 오류 보고서를 확인하고 응용 프로그램 성능을 추적하며 중요한 문제에 대한 경보 및 알림을 설정할 수 있습니다.</p>\n<p>Raygun을 NestJS 애플리케이션에 통합하면 오류 및 성능 문제에 대한 강력한 통찰력을 얻어 문제를 선제적으로 해결하고 소프트웨어의 전반적인 안정성과 신뢰성을 향상시킬 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}