{"pageProps":{"post":{"title":"Angular와 ngRX를 사용하여 OIDC 인증 구현하는 방법","description":"","date":"2024-06-22 14:54","slug":"2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX","content":"\n\nangular-oauth2-oidc 라이브러리를 사용하여 JWT 토큰 처리를 자동화하고 있어요.\n\n![이미지](/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png)\n\n다들 OIDC를 여기서, 거기서 계속 듣곤 하는데, 정확히 무슨 의미일까요?\n\nMicrosoft의 정의를 따르면 OpenId Connect (OIDC)은 권한 부여 (OAuth 2.0의 확장)의 인증 프로토콜로, 디지털 서비스에 액세스하기 위한 로그인 프로세스를 표준화한 것이라고 해요.\n\n<div class=\"content-ad\"></div>\n\n다른 말로, 사용자 데이터를 공유하지 않고 관련없는 응용 프로그램에서 사용자를 확인하는 메커니즘입니다. 이 방법을 통해 사용자는 한 번만 로그인하고 여러 응용 프로그램에 액세스할 수 있습니다.\n\n이러한 메커니즘은 이미 상당히 인기가 있으며 기업들이 이미 자사의 생태계에 통합하기 시작했습니다.\n\n그래, 이제 기본 개념을 파악하고 OIDC가 해결하고자 하는 문제 유형과 목표를 알게 되었습니다. 그 목표는 다음 단계를 통해 달성됩니다:\n\n- 사용자가 특정 응용 프로그램에 입력하여 OpenID 제공자로 리디렉션됩니다.\n- 사용자가 사용자 이름과 암호를 제공합니다.\n- 사용자 자격 증명이 OpenID 제공자로 전달됩니다.\n- 제공자가 자격 증명을 확인하고 권한을 획득합니다.\n- 사용자가 ID 토큰을 포함하여 원래의 응용 프로그램으로 리디렉션됩니다.\n\n<div class=\"content-ad\"></div>\n\n복잡해 보이죠?\n\n하지만 구현하기가 생각보다 어렵지 않습니다. 외부 라이브러리를 전혀 사용하지 않고 자체 솔루션을 구축하려고 하면 좀 더 많은 시간이 걸릴 것입니다. 로켓 과학은 아니지만 전적으로 혼자서 해결할 필요는 없습니다. Angular 세계에서 소개 없이 잘 알려진 Manfred Steyer가 개발한 angular-oauth2-oidc 라이브러리가 있습니다.:-))\n\n이 라이브러리는 모듈 기반 및 독립형 접근 방식을 포함하여 다양한 Angular 버전을 지원합니다. 제대로 설정하면 리디렉션, 요청 헤더에 토큰 추가, 심지어 토큰 갱신에 대해 걱정할 필요가 없습니다!\n\n먼저 모듈 기반 접근 방식부터 시작해 보죠. 하지만 그 전에 프로젝트 의존성에 라이브러리를 추가해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm i angular-oauth2-oidc --save\n```\n\n라이브러리가 성공적으로 설치되면 구성 및 처리를 설정하기 위해 일부 준비를 해야합니다.\n\n인가를 처리하기 위해 이미 존재하는 사용자 기능 저장소의 구현을 사용할 것입니다. 해당 주제에 익숙하지 않다면 다른 기사를 참조해주세요:\n\n이제 동일한 페이지에 있는 경우 사용자 기능 저장소를 확장하여 OIDC를 처리해봅시다.\n\n<div class=\"content-ad\"></div>\n\n먼저 user.state.ts 파일에서 UserState를 아래와 같이 추가 속성과 함께 확장해 보겠습니다.\n\n```js\nexport interface UserState {\n  // ... 다른 속성들\n  loggedIn: boolean;\n  logInRequestHandled: boolean;\n}\n\nexport const initialState: UserState = {\n  // ... 다른 속성들\n  loggedIn: false,\n  logInRequestHandled: false,\n};\n```\n\n또한 user.selectors.ts 파일에서 store에서 정보를 다시 가져오기 위한 selector를 만들어 봅시다.\n\n```js\nexport const selectIsLogInRequestHandled = createSelector(\n  selectUserState,\n  ({ logInRequestHandled }: UserState) => logInRequestHandled\n);\n```\n\n<div class=\"content-ad\"></div>\n\n전체 프로세스를 탐색하는 데 도움이 되는 일부 동작을 정의해야 합니다. 이를 user.actions.ts 파일 내에 다음과 같이 작성해야 합니다:\n\n```js\nconst user = '[사용자]';\n// ... 다른 액션들\nexport const logIn = createAction(`${user} 로그인`);\nexport const logInSuccess = createAction(`${user} 로그인 성공`);\nexport const logInError = createAction(`${user} 로그인 오류`);\n```\n\n우리의 액션들은 상태에 영향을 미쳐야 하므로 user.reducer.ts 파일 내에서 이러한 상태 변경이 어떻게 발생할지를 정의해야 합니다:\n\n```js\nimport { createReducer, on } from '@ngrx/store';\nimport {\n  initialState,\n  logInSuccess,\n  UserState,\n  logInError,\n} from './index';\n\nexport const userReducer = createReducer(\n  initialState,\n  // ... 일부 다른 액션들\n  on(logInSuccess, (state: UserState) => ({ \n      ...state, \n      loggedIn: true, \n      logInRequestHandled: true,\n   })),\n  on(logInError, (state: UserState) => ({ \n      ...state, \n      loggedIn: false, \n      logInRequestHandled: true,\n   }))\n);\n```\n\n<div class=\"content-ad\"></div>\n\n거의 완성 단계에 다다랐어요. UsersFacade를 user.facade.ts 파일 내부에서 업데이트해야하며, 모두 통합할 수 있게 될 거예요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { UserState } from './user.state';\nimport { logIn } from './user.actions';\nimport { selectIsLogInRequestHandled } from './user.selectors';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class UserFacadeService {\n    readonly logInRequestHandled$: Observable<boolean> = this.store.select(selectIsLogInRequestHandled);\n\n    constructor(private readonly store: Store<UserState>) {} // 생성자 대신에 주입 토큰 사용할 수 있어요\n\n    logIn(): void {\n        this.store.dispatch(logIn());\n    }\n}\n```\n\n이제 준비 상태를 설정하겠어요. 앞으로 모두 통합하기 위해 user.effects.ts 파일 내에서 비동기 작업을 정의해야 해요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { catchError, map, mergeMap, tap } from 'rxjs/operators';\nimport { EMPTY, from, iif } from 'rxjs';\nimport {\n    getUserSettings,\n    logIn,\n    logInError,\n    logInSuccess,\n} from './index';\nimport { OAuthErrorEvent, OAuthEvent, OAuthService, OAuthSuccessEvent } from 'angular-oauth2-oidc';\nimport { environment } from '../../../environments/environment';\n\n@Injectable({ providedIn: 'root' })\nexport class UserEffects {\n    constructor(\n        private readonly actions$: Actions,\n        private readonly router: Router,\n        private readonly oAuthService: OAuthService\n    ) {\n        this.oAuthService.configure(environment); // 공급자 구성\n        this.oAuthService.setupAutomaticSilentRefresh(); // 조용한 자동 토큰 새로고침, 그렇지 않으면 토큰이 오래되어 refresh되지 않을 수 있어요\n    }\n\n    listenOAuth$ = createEffect(() =>\n        this.oAuthService.events.pipe(\n            mergeMap((event: OAuthEvent) => {\n                if (event instanceof OAuthErrorEvent) {\n                    return [logInError()];\n                }\n                if (event instanceof OAuthSuccessEvent && event.type === 'token_received') {\n                    return [logInSuccess()];\n                }\n\n                return EMPTY;\n            })\n        )\n    );\n\n    logIn$ = createEffect(() =>\n        this.actions$.pipe(\n            ofType(logIn),\n            mergeMap(() =>\n                iif(\n                    () => this.oAuthService.hasValidIdToken() && this.oAuthService.hasValidAccessToken(),\n                    [logInSuccess()],\n                    from(this.oAuthService.loadDiscoveryDocumentAndLogin()).pipe(\n                        tap((result: boolean): void => {\n                            if (!result) {\n                                this.oAuthService.initCodeFlow();\n                            }\n                        }),\n                        mergeMap(() => EMPTY),\n                        catchError(() => [logInError()])\n                    )\n                )\n            )\n        )\n    );\n\n    logInSuccess$ = createEffect(() => this.actions$.pipe(ofType(logInSuccess), map(getUserSettings)));\n\n    logInError$ = createEffect(\n        () =>\n            this.actions$.pipe(\n                ofType(logInError),\n                tap(() => this.router.navigate(['no-access']))\n            ),\n        { dispatch: false }\n    );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그래서, 이제 angular-oauth2-oidc 라이브러리 구현에 대해 이야기해보겠습니다. 라이브러리 자체에 공급자 정보를 설정하기 위해 전달하는 초기 정보가 있는 구성 파일이 필요합니다. 아래는 라이브러리 문서에서 가져온 기본 구현입니다. 그러나 애플리케이션이 배포될 다양한 환경에 따라 구성이 다를 수 있으므로, 이를 환경.$'specific'.ts 파일 내에 유지하는 것을 제안합니다.\n\nMarkdown 포맷으로 표를 변경하겠습니다:\n\n```typescript\nimport { AuthConfig } from 'angular-oauth2-oidc';\n\nexport const authCodeFlowConfig: AuthConfig = {\n    // Identity Provider의 URL\n    issuer: 'https://idsvr4.azurewebsites.net',\n\n    // 로그인 후 사용자를 리디렉션할 SPA의 URL\n    redirectUri: window.location.origin + '/index.html',\n\n    // SPA의 ID. 해당 ID로 SPA가 권한 서버에 등록됨\n    clientId: 'spa',\n\n    // 권한 서버에서 비밀번호를 요구하는 경우 필요함. 일반적으로 이 경우,\n    // 권한 서버가 SPA를 고려하여 구성되지 않았다는 것을 의미하며, 보안을 위해 중요한 추가적인 최선의 방법을 강요할 수도 있음\n    // dummyClientSecret: 'secret',\n\n    responseType: 'code',\n\n    // 클라이언트가 요청해야 하는 권한의 범위 설정\n    // 처음 네 가지는 OIDC에서 정의된 것들임\n    // 중요: refresh 토큰을 받으려면 offline_access를 요청\n    // api scope는 usecase-specific한 것임\n    scope: 'openid profile email offline_access api',\n\n    showDebugInformation: true,\n};\n```\n\n모듈 기반 접근 방식:\n\n<div class=\"content-ad\"></div>\n\n```typescript\nimport { APP_INITIALIZER, NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { AppComponent } from './app.component';\nimport { UserFacadeService } from './store';\nimport { OAuthModule } from 'angular-oauth2-oidc';\nimport { filter } from 'rxjs/operators';\nimport { HttpClientModule } from '@angular/common/http';\n\nfunction initializeLogIn(userFacade: UserFacadeService): () => void {\n    return (): Observable<boolean> => {\n        userFacade.logIn();\n        return userFacade.logInRequestHandled$.pipe(filter(Boolean));\n    };\n}\n\n@NgModule({\n    declarations: [AppComponent],\n    imports: [\n        BrowserModule,\n        BrowserAnimationsModule,\n        HttpClientModule,\n        OAuthModule.forRoot({\n            resourceServer: { // You can pass the array of URIs entitled to include the authorization token or allow all requests by not passing it at all.\n                sendAccessToken: true,\n            },\n        }),\n    ],\n    providers: [\n        { \n          provide: APP_INITIALIZER, \n          useFactory: initializeLogIn, \n          deps: [UserFacadeService], \n          multi: true \n        },\n    ],\n    bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n위의 코드를 분석해봅시다. 우리는 initializeLogIn을 APP_INITIALIZER로 선언하고, 이를 주 애플리케이션 모듈 내의 providers 배열 안에 전달했습니다. 여기서 로그인 시도가 호출되고, UserFacade 소스로부터의 logInRequestHandled$ Observable이 true를 발행할 때까지 기다립니다.\n\nAPP_INITIALIZER가 무엇인지 잘 모르겠나요? 해당 주제와 관련된 다른 기사를 확인해보세요:\n\n또한 주 애플리케이션 모듈 내에서 Angular common 라이브러리에서 HttpClientModule와 방금 설치한 라이브러리인 OAuthModule을 import 했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 독립 실행 방식 Angular v15:\n\n```js\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideHttpClient } from '@angular/common/http';\nimport { AppComponent } from './app/app.component';\nimport { provideOAuthClient } from 'angular-oauth2-oidc';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideHttpClient(),\n    provideOAuthClient(),\n    { \n      provide: APP_INITIALIZER, \n      useFactory: initializeLogIn, \n      deps: [UserFacadeService], \n      multi: true,\n    },\n  ]\n});\n```\n\n# 독립 실행 방식 Angular v14:\n\n```js\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\nimport { AppComponent } from './app/app.component';\nimport { provideOAuthClient } from 'angular-oauth2-oidc';\nimport { importProvidersFrom } from '@angular/core';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    importProvidersFrom(HttpClientModule),\n    provideOAuthClient(),\n    { \n      provide: APP_INITIALIZER, \n      useFactory: initializeLogIn, \n      deps: [UserFacadeService], \n      multi: true,\n    },\n  ]\n});\n```\n\n<div class=\"content-ad\"></div>\n\nAngular v14에서는 독립적인 구성 요소가 여전히 실험 단계였고 모든 기능이 과거와 같이 공급자를 갖추지 않았다는 것이 차이점입니다.\n\n그게 전부에요, 이제 ngRX 기반의 OIDC 구현이 준비되었습니다!\n\n정말 쉬웠죠?\n\n프로젝트에 대한 상담이 필요하다면 언제든 연락주세요. 앱을 망치지 마시고 문의해주세요 :-)","ogImage":{"url":"/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png","tag":["Tech"],"readingTime":11},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>angular-oauth2-oidc 라이브러리를 사용하여 JWT 토큰 처리를 자동화하고 있어요.</p>\n<p><img src=\"/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png\" alt=\"이미지\"></p>\n<p>다들 OIDC를 여기서, 거기서 계속 듣곤 하는데, 정확히 무슨 의미일까요?</p>\n<p>Microsoft의 정의를 따르면 OpenId Connect (OIDC)은 권한 부여 (OAuth 2.0의 확장)의 인증 프로토콜로, 디지털 서비스에 액세스하기 위한 로그인 프로세스를 표준화한 것이라고 해요.</p>\n<p>다른 말로, 사용자 데이터를 공유하지 않고 관련없는 응용 프로그램에서 사용자를 확인하는 메커니즘입니다. 이 방법을 통해 사용자는 한 번만 로그인하고 여러 응용 프로그램에 액세스할 수 있습니다.</p>\n<p>이러한 메커니즘은 이미 상당히 인기가 있으며 기업들이 이미 자사의 생태계에 통합하기 시작했습니다.</p>\n<p>그래, 이제 기본 개념을 파악하고 OIDC가 해결하고자 하는 문제 유형과 목표를 알게 되었습니다. 그 목표는 다음 단계를 통해 달성됩니다:</p>\n<ul>\n<li>사용자가 특정 응용 프로그램에 입력하여 OpenID 제공자로 리디렉션됩니다.</li>\n<li>사용자가 사용자 이름과 암호를 제공합니다.</li>\n<li>사용자 자격 증명이 OpenID 제공자로 전달됩니다.</li>\n<li>제공자가 자격 증명을 확인하고 권한을 획득합니다.</li>\n<li>사용자가 ID 토큰을 포함하여 원래의 응용 프로그램으로 리디렉션됩니다.</li>\n</ul>\n<p>복잡해 보이죠?</p>\n<p>하지만 구현하기가 생각보다 어렵지 않습니다. 외부 라이브러리를 전혀 사용하지 않고 자체 솔루션을 구축하려고 하면 좀 더 많은 시간이 걸릴 것입니다. 로켓 과학은 아니지만 전적으로 혼자서 해결할 필요는 없습니다. Angular 세계에서 소개 없이 잘 알려진 Manfred Steyer가 개발한 angular-oauth2-oidc 라이브러리가 있습니다.:-))</p>\n<p>이 라이브러리는 모듈 기반 및 독립형 접근 방식을 포함하여 다양한 Angular 버전을 지원합니다. 제대로 설정하면 리디렉션, 요청 헤더에 토큰 추가, 심지어 토큰 갱신에 대해 걱정할 필요가 없습니다!</p>\n<p>먼저 모듈 기반 접근 방식부터 시작해 보죠. 하지만 그 전에 프로젝트 의존성에 라이브러리를 추가해야 합니다:</p>\n<pre><code class=\"hljs language-js\">npm i angular-oauth2-oidc --save\n</code></pre>\n<p>라이브러리가 성공적으로 설치되면 구성 및 처리를 설정하기 위해 일부 준비를 해야합니다.</p>\n<p>인가를 처리하기 위해 이미 존재하는 사용자 기능 저장소의 구현을 사용할 것입니다. 해당 주제에 익숙하지 않다면 다른 기사를 참조해주세요:</p>\n<p>이제 동일한 페이지에 있는 경우 사용자 기능 저장소를 확장하여 OIDC를 처리해봅시다.</p>\n<p>먼저 user.state.ts 파일에서 UserState를 아래와 같이 추가 속성과 함께 확장해 보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">UserState</span> {\n  <span class=\"hljs-comment\">// ... 다른 속성들</span>\n  <span class=\"hljs-attr\">loggedIn</span>: boolean;\n  <span class=\"hljs-attr\">logInRequestHandled</span>: boolean;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-title class_\">UserState</span> = {\n  <span class=\"hljs-comment\">// ... 다른 속성들</span>\n  <span class=\"hljs-attr\">loggedIn</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">logInRequestHandled</span>: <span class=\"hljs-literal\">false</span>,\n};\n</code></pre>\n<p>또한 user.selectors.ts 파일에서 store에서 정보를 다시 가져오기 위한 selector를 만들어 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> selectIsLogInRequestHandled = <span class=\"hljs-title function_\">createSelector</span>(\n  selectUserState,\n  <span class=\"hljs-function\">(<span class=\"hljs-params\">{ logInRequestHandled }: UserState</span>) =></span> logInRequestHandled\n);\n</code></pre>\n<p>전체 프로세스를 탐색하는 데 도움이 되는 일부 동작을 정의해야 합니다. 이를 user.actions.ts 파일 내에 다음과 같이 작성해야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-string\">'[사용자]'</span>;\n<span class=\"hljs-comment\">// ... 다른 액션들</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> logIn = <span class=\"hljs-title function_\">createAction</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${user}</span> 로그인`</span>);\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> logInSuccess = <span class=\"hljs-title function_\">createAction</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${user}</span> 로그인 성공`</span>);\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> logInError = <span class=\"hljs-title function_\">createAction</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${user}</span> 로그인 오류`</span>);\n</code></pre>\n<p>우리의 액션들은 상태에 영향을 미쳐야 하므로 user.reducer.ts 파일 내에서 이러한 상태 변경이 어떻게 발생할지를 정의해야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { createReducer, on } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ngrx/store'</span>;\n<span class=\"hljs-keyword\">import</span> {\n  initialState,\n  logInSuccess,\n  <span class=\"hljs-title class_\">UserState</span>,\n  logInError,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./index'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> userReducer = <span class=\"hljs-title function_\">createReducer</span>(\n  initialState,\n  <span class=\"hljs-comment\">// ... 일부 다른 액션들</span>\n  <span class=\"hljs-title function_\">on</span>(logInSuccess, <span class=\"hljs-function\">(<span class=\"hljs-params\">state: UserState</span>) =></span> ({ \n      ...state, \n      <span class=\"hljs-attr\">loggedIn</span>: <span class=\"hljs-literal\">true</span>, \n      <span class=\"hljs-attr\">logInRequestHandled</span>: <span class=\"hljs-literal\">true</span>,\n   })),\n  <span class=\"hljs-title function_\">on</span>(logInError, <span class=\"hljs-function\">(<span class=\"hljs-params\">state: UserState</span>) =></span> ({ \n      ...state, \n      <span class=\"hljs-attr\">loggedIn</span>: <span class=\"hljs-literal\">false</span>, \n      <span class=\"hljs-attr\">logInRequestHandled</span>: <span class=\"hljs-literal\">true</span>,\n   }))\n);\n</code></pre>\n<p>거의 완성 단계에 다다랐어요. UsersFacade를 user.facade.ts 파일 내부에서 업데이트해야하며, 모두 통합할 수 있게 될 거예요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Store</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ngrx/store'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">UserState</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./user.state'</span>;\n<span class=\"hljs-keyword\">import</span> { logIn } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./user.actions'</span>;\n<span class=\"hljs-keyword\">import</span> { selectIsLogInRequestHandled } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./user.selectors'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Observable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>({\n    <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">'root'</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserFacadeService</span> {\n    readonly <span class=\"hljs-attr\">logInRequestHandled$</span>: <span class=\"hljs-title class_\">Observable</span>&#x3C;boolean> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">store</span>.<span class=\"hljs-title function_\">select</span>(selectIsLogInRequestHandled);\n\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private readonly store: Store&#x3C;UserState></span>) {} <span class=\"hljs-comment\">// 생성자 대신에 주입 토큰 사용할 수 있어요</span>\n\n    <span class=\"hljs-title function_\">logIn</span>(): <span class=\"hljs-keyword\">void</span> {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">store</span>.<span class=\"hljs-title function_\">dispatch</span>(<span class=\"hljs-title function_\">logIn</span>());\n    }\n}\n</code></pre>\n<p>이제 준비 상태를 설정하겠어요. 앞으로 모두 통합하기 위해 user.effects.ts 파일 내에서 비동기 작업을 정의해야 해요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Router</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/router'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Actions</span>, createEffect, ofType } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ngrx/effects'</span>;\n<span class=\"hljs-keyword\">import</span> { catchError, map, mergeMap, tap } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">EMPTY</span>, <span class=\"hljs-keyword\">from</span>, iif } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> {\n    getUserSettings,\n    logIn,\n    logInError,\n    logInSuccess,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./index'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">OAuthErrorEvent</span>, <span class=\"hljs-title class_\">OAuthEvent</span>, <span class=\"hljs-title class_\">OAuthService</span>, <span class=\"hljs-title class_\">OAuthSuccessEvent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'angular-oauth2-oidc'</span>;\n<span class=\"hljs-keyword\">import</span> { environment } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../../../environments/environment'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>({ <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">'root'</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserEffects</span> {\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n        private readonly actions$: Actions,\n        private readonly router: Router,\n        private readonly oAuthService: OAuthService\n    </span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">oAuthService</span>.<span class=\"hljs-title function_\">configure</span>(environment); <span class=\"hljs-comment\">// 공급자 구성</span>\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">oAuthService</span>.<span class=\"hljs-title function_\">setupAutomaticSilentRefresh</span>(); <span class=\"hljs-comment\">// 조용한 자동 토큰 새로고침, 그렇지 않으면 토큰이 오래되어 refresh되지 않을 수 있어요</span>\n    }\n\n    listenOAuth$ = <span class=\"hljs-title function_\">createEffect</span>(<span class=\"hljs-function\">() =></span>\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">oAuthService</span>.<span class=\"hljs-property\">events</span>.<span class=\"hljs-title function_\">pipe</span>(\n            <span class=\"hljs-title function_\">mergeMap</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">event: OAuthEvent</span>) =></span> {\n                <span class=\"hljs-keyword\">if</span> (event <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">OAuthErrorEvent</span>) {\n                    <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-title function_\">logInError</span>()];\n                }\n                <span class=\"hljs-keyword\">if</span> (event <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">OAuthSuccessEvent</span> &#x26;&#x26; event.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">'token_received'</span>) {\n                    <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-title function_\">logInSuccess</span>()];\n                }\n\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable constant_\">EMPTY</span>;\n            })\n        )\n    );\n\n    logIn$ = <span class=\"hljs-title function_\">createEffect</span>(<span class=\"hljs-function\">() =></span>\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">actions$</span>.<span class=\"hljs-title function_\">pipe</span>(\n            <span class=\"hljs-title function_\">ofType</span>(logIn),\n            <span class=\"hljs-title function_\">mergeMap</span>(<span class=\"hljs-function\">() =></span>\n                <span class=\"hljs-title function_\">iif</span>(\n                    <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">oAuthService</span>.<span class=\"hljs-title function_\">hasValidIdToken</span>() &#x26;&#x26; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">oAuthService</span>.<span class=\"hljs-title function_\">hasValidAccessToken</span>(),\n                    [<span class=\"hljs-title function_\">logInSuccess</span>()],\n                    <span class=\"hljs-title function_\">from</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">oAuthService</span>.<span class=\"hljs-title function_\">loadDiscoveryDocumentAndLogin</span>()).<span class=\"hljs-title function_\">pipe</span>(\n                        <span class=\"hljs-title function_\">tap</span>((<span class=\"hljs-attr\">result</span>: boolean): <span class=\"hljs-function\"><span class=\"hljs-params\">void</span> =></span> {\n                            <span class=\"hljs-keyword\">if</span> (!result) {\n                                <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">oAuthService</span>.<span class=\"hljs-title function_\">initCodeFlow</span>();\n                            }\n                        }),\n                        <span class=\"hljs-title function_\">mergeMap</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-variable constant_\">EMPTY</span>),\n                        <span class=\"hljs-title function_\">catchError</span>(<span class=\"hljs-function\">() =></span> [<span class=\"hljs-title function_\">logInError</span>()])\n                    )\n                )\n            )\n        )\n    );\n\n    logInSuccess$ = <span class=\"hljs-title function_\">createEffect</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">actions$</span>.<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">ofType</span>(logInSuccess), <span class=\"hljs-title function_\">map</span>(getUserSettings)));\n\n    logInError$ = <span class=\"hljs-title function_\">createEffect</span>(\n        <span class=\"hljs-function\">() =></span>\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">actions$</span>.<span class=\"hljs-title function_\">pipe</span>(\n                <span class=\"hljs-title function_\">ofType</span>(logInError),\n                <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">router</span>.<span class=\"hljs-title function_\">navigate</span>([<span class=\"hljs-string\">'no-access'</span>]))\n            ),\n        { <span class=\"hljs-attr\">dispatch</span>: <span class=\"hljs-literal\">false</span> }\n    );\n}\n</code></pre>\n<p>그래서, 이제 angular-oauth2-oidc 라이브러리 구현에 대해 이야기해보겠습니다. 라이브러리 자체에 공급자 정보를 설정하기 위해 전달하는 초기 정보가 있는 구성 파일이 필요합니다. 아래는 라이브러리 문서에서 가져온 기본 구현입니다. 그러나 애플리케이션이 배포될 다양한 환경에 따라 구성이 다를 수 있으므로, 이를 환경.$'specific'.ts 파일 내에 유지하는 것을 제안합니다.</p>\n<p>Markdown 포맷으로 표를 변경하겠습니다:</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AuthConfig</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'angular-oauth2-oidc'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">authCodeFlowConfig</span>: <span class=\"hljs-title class_\">AuthConfig</span> = {\n    <span class=\"hljs-comment\">// Identity Provider의 URL</span>\n    <span class=\"hljs-attr\">issuer</span>: <span class=\"hljs-string\">'https://idsvr4.azurewebsites.net'</span>,\n\n    <span class=\"hljs-comment\">// 로그인 후 사용자를 리디렉션할 SPA의 URL</span>\n    <span class=\"hljs-attr\">redirectUri</span>: <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">location</span>.<span class=\"hljs-property\">origin</span> + <span class=\"hljs-string\">'/index.html'</span>,\n\n    <span class=\"hljs-comment\">// SPA의 ID. 해당 ID로 SPA가 권한 서버에 등록됨</span>\n    <span class=\"hljs-attr\">clientId</span>: <span class=\"hljs-string\">'spa'</span>,\n\n    <span class=\"hljs-comment\">// 권한 서버에서 비밀번호를 요구하는 경우 필요함. 일반적으로 이 경우,</span>\n    <span class=\"hljs-comment\">// 권한 서버가 SPA를 고려하여 구성되지 않았다는 것을 의미하며, 보안을 위해 중요한 추가적인 최선의 방법을 강요할 수도 있음</span>\n    <span class=\"hljs-comment\">// dummyClientSecret: 'secret',</span>\n\n    <span class=\"hljs-attr\">responseType</span>: <span class=\"hljs-string\">'code'</span>,\n\n    <span class=\"hljs-comment\">// 클라이언트가 요청해야 하는 권한의 범위 설정</span>\n    <span class=\"hljs-comment\">// 처음 네 가지는 OIDC에서 정의된 것들임</span>\n    <span class=\"hljs-comment\">// 중요: refresh 토큰을 받으려면 offline_access를 요청</span>\n    <span class=\"hljs-comment\">// api scope는 usecase-specific한 것임</span>\n    <span class=\"hljs-attr\">scope</span>: <span class=\"hljs-string\">'openid profile email offline_access api'</span>,\n\n    <span class=\"hljs-attr\">showDebugInformation</span>: <span class=\"hljs-literal\">true</span>,\n};\n</code></pre>\n<p>모듈 기반 접근 방식:</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">APP_INITIALIZER</span>, <span class=\"hljs-title class_\">NgModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BrowserModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/platform-browser'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BrowserAnimationsModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/platform-browser/animations'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./app.component'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">UserFacadeService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./store'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">OAuthModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'angular-oauth2-oidc'</span>;\n<span class=\"hljs-keyword\">import</span> { filter } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpClientModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/common/http'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">initializeLogIn</span>(<span class=\"hljs-params\">userFacade: UserFacadeService</span>): <span class=\"hljs-function\">() =></span> <span class=\"hljs-built_in\">void</span> {\n    <span class=\"hljs-keyword\">return</span> (): <span class=\"hljs-title class_\">Observable</span>&#x3C;<span class=\"hljs-built_in\">boolean</span>> => {\n        userFacade.<span class=\"hljs-title function_\">logIn</span>();\n        <span class=\"hljs-keyword\">return</span> userFacade.<span class=\"hljs-property\">logInRequestHandled$</span>.<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-title class_\">Boolean</span>));\n    };\n}\n\n<span class=\"hljs-meta\">@NgModule</span>({\n    <span class=\"hljs-attr\">declarations</span>: [<span class=\"hljs-title class_\">AppComponent</span>],\n    <span class=\"hljs-attr\">imports</span>: [\n        <span class=\"hljs-title class_\">BrowserModule</span>,\n        <span class=\"hljs-title class_\">BrowserAnimationsModule</span>,\n        <span class=\"hljs-title class_\">HttpClientModule</span>,\n        <span class=\"hljs-title class_\">OAuthModule</span>.<span class=\"hljs-title function_\">forRoot</span>({\n            <span class=\"hljs-attr\">resourceServer</span>: { <span class=\"hljs-comment\">// You can pass the array of URIs entitled to include the authorization token or allow all requests by not passing it at all.</span>\n                <span class=\"hljs-attr\">sendAccessToken</span>: <span class=\"hljs-literal\">true</span>,\n            },\n        }),\n    ],\n    <span class=\"hljs-attr\">providers</span>: [\n        { \n          <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">APP_INITIALIZER</span>, \n          <span class=\"hljs-attr\">useFactory</span>: initializeLogIn, \n          <span class=\"hljs-attr\">deps</span>: [<span class=\"hljs-title class_\">UserFacadeService</span>], \n          <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span> \n        },\n    ],\n    <span class=\"hljs-attr\">bootstrap</span>: [<span class=\"hljs-title class_\">AppComponent</span>],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppModule</span> {}\n</code></pre>\n<p>위의 코드를 분석해봅시다. 우리는 initializeLogIn을 APP_INITIALIZER로 선언하고, 이를 주 애플리케이션 모듈 내의 providers 배열 안에 전달했습니다. 여기서 로그인 시도가 호출되고, UserFacade 소스로부터의 logInRequestHandled$ Observable이 true를 발행할 때까지 기다립니다.</p>\n<p>APP_INITIALIZER가 무엇인지 잘 모르겠나요? 해당 주제와 관련된 다른 기사를 확인해보세요:</p>\n<p>또한 주 애플리케이션 모듈 내에서 Angular common 라이브러리에서 HttpClientModule와 방금 설치한 라이브러리인 OAuthModule을 import 했습니다.</p>\n<h1>독립 실행 방식 Angular v15:</h1>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { bootstrapApplication } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/platform-browser'</span>;\n<span class=\"hljs-keyword\">import</span> { provideHttpClient } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/common/http'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./app/app.component'</span>;\n<span class=\"hljs-keyword\">import</span> { provideOAuthClient } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'angular-oauth2-oidc'</span>;\n\n<span class=\"hljs-title function_\">bootstrapApplication</span>(<span class=\"hljs-title class_\">AppComponent</span>, {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideHttpClient</span>(),\n    <span class=\"hljs-title function_\">provideOAuthClient</span>(),\n    { \n      <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">APP_INITIALIZER</span>, \n      <span class=\"hljs-attr\">useFactory</span>: initializeLogIn, \n      <span class=\"hljs-attr\">deps</span>: [<span class=\"hljs-title class_\">UserFacadeService</span>], \n      <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>,\n    },\n  ]\n});\n</code></pre>\n<h1>독립 실행 방식 Angular v14:</h1>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { bootstrapApplication } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/platform-browser'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpClientModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/common/http'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./app/app.component'</span>;\n<span class=\"hljs-keyword\">import</span> { provideOAuthClient } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'angular-oauth2-oidc'</span>;\n<span class=\"hljs-keyword\">import</span> { importProvidersFrom } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n<span class=\"hljs-title function_\">bootstrapApplication</span>(<span class=\"hljs-title class_\">AppComponent</span>, {\n  <span class=\"hljs-attr\">providers</span>: [\n    importProvidersFrom(<span class=\"hljs-title class_\">HttpClientModule</span>),\n    <span class=\"hljs-title function_\">provideOAuthClient</span>(),\n    { \n      <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">APP_INITIALIZER</span>, \n      <span class=\"hljs-attr\">useFactory</span>: initializeLogIn, \n      <span class=\"hljs-attr\">deps</span>: [<span class=\"hljs-title class_\">UserFacadeService</span>], \n      <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>,\n    },\n  ]\n});\n</code></pre>\n<p>Angular v14에서는 독립적인 구성 요소가 여전히 실험 단계였고 모든 기능이 과거와 같이 공급자를 갖추지 않았다는 것이 차이점입니다.</p>\n<p>그게 전부에요, 이제 ngRX 기반의 OIDC 구현이 준비되었습니다!</p>\n<p>정말 쉬웠죠?</p>\n<p>프로젝트에 대한 상담이 필요하다면 언제든 연락주세요. 앱을 망치지 마시고 문의해주세요 :-)</p>\n</body>\n</html>\n"},"__N_SSG":true}