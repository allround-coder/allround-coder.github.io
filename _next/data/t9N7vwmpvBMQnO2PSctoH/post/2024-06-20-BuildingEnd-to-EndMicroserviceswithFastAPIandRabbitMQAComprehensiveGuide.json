{"pageProps":{"post":{"title":"파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내","description":"","date":"2024-06-20 01:54","slug":"2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide","content":"\n\n\n![image](/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png)\n\n# 소개:\n\n최근 몇 년간, 마이크로서비스 아키텍처는 확장 가능하고 유지보수 가능하며 유연한 애플리케이션을 만드는 능력 때문에 인기를 얻었습니다. 이 블로그 포스트에서는 마이크로서비스 아키텍처의 개념을 탐구하고, 파이썬 생태계의 강력한 도구인 FastAPI와 RabbitMQ를 사용하여 간단한 마이크로서비스를 구축하는 방법을 보여드리겠습니다.\n\n# 몰리딕 아키텍처란? \n\n\n<div class=\"content-ad\"></div>\n\n단일체 아키텍처는 모든 비즈니스 관심을 결합하는 단일 대규모 컴퓨팅 네트워크로, 하나의 코드 베이스로 생각해 볼 수 있습니다. 애플리케이션의 모든 구성 요소를 하나의 지붕 아래에 모아둔 거대하고 빙하처럼 보이는 구조라고 상상해보세요. 단일체에서 변경을 하려면 전체 스택을 업데이트해야 하며, 이는 시간이 많이 소요되고 엄격할 수 있습니다. 아래 다이어그램에서 단일체 아키텍처의 예시를 볼 수 있습니다.\n\n![단일체 아키텍처 다이어그램](/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_1.png)\n\n# 마이크로서비스 아키텍처란?\n\n반면에, 마이크로서비스 아키텍처는 응용 프로그램이 작은, 독립적으로 배포 가능한 서비스로 분할되는 접근 방식입니다. 각 서비스는 해당하는 비즈니스 로직과 데이터베이스를 갖고 있으며, 가벼운 프로토콜을 통해 다른 서비스와 통신합니다. 이 접근 방식은 빠른 개발 주기, 쉬운 유지보수, 그리고 더 나은 확장성을 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_2.png\" />\n\n# Monolithic vs. Microservice의 차이\n\n<img src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_3.png\" />\n\n# RabbitMQ는 무엇이며, 왜 마이크로서비스를 구축하는 데 사용되는가?\n\n<div class=\"content-ad\"></div>\n\nRabbitMQ는 진보된 메시지 큐잉 프로토콜(AMQP)을 구현하는 메시지 브로커입니다. RabbitMQ는 분산 시스템의 다양한 구성 요소 사이에서 중개자 역할을 하여 효율적으로 통신하고 작업을 조정할 수 있도록 합니다. RabbitMQ가 마이크로서비스 아키텍처에서 흔히 사용되는 이유는 다음과 같습니다:\n\n- Decoupling: RabbitMQ는 시스템 구성 요소들을 비동기적으로 통신할 수 있게 함으로써 시스템을 분리하는 데 도움을 줍니다. 이는 서비스가 서로의 응답을 기다리지 않고 독립적으로 작동할 수 있어 더 견고하고 확장 가능한 시스템을 이끌어냅니다.\n- Load Balancing: RabbitMQ는 메시지를 여러 소비자 인스턴스에 분배함으로써 부하를 균형 있게 분배하고 효율적인 자원 활용을 보장합니다.\n- Fault Tolerance: RabbitMQ는 클러스터링과 복제를 지원하여 노드가 실패해도 메시지가 손실되지 않도록 합니다. 이는 시스템을 더욱 고장 내성이 뛰어나고 신뢰할 수 있도록 만듭니다.\n- Scalability: RabbitMQ를 사용하면 소비자 인스턴스나 클러스터에 노드를 추가하여 시스템을 확장할 수 있어 애플리케이션이 성장함에 따라 증가하는 메시지 트래픽을 처리할 수 있습니다.\n- Message Routing: RabbitMQ는 직접, 주제, 팬아웃과 같은 다양한 메시지 라우팅 메커니즘을 지원하여 라우팅 키나 패턴에 따라 특정 큐로 메시지를 전달할 수 있습니다.\n- Message Acknowledgment: RabbitMQ는 메시지 승인을 지원하여 메시지가 한 번만 처리되고 전송 중에 손실되지 않도록 보장합니다.\n- 전반적으로 RabbitMQ는 확장 가능하고 분리되고 고장 내성이 뛰어난 마이크로서비스 아키텍처를 구축하는 데 도움이 되는 견고하고 신뢰할 수 있는 메시징 시스템입니다.\n\n# 마이크로서비스 응용프로그램 코딩\n\n# 1. 프로젝트 소개\n\n<div class=\"content-ad\"></div>\n\n저희 어플리케이션은 네 가지 주요 서비스로 구성되어 있습니다:\n\n- Gateway Service: 이 서비스는 모든 들어오는 요청의 진입 지점 역할을 합니다. 요청을 적절한 마이크로서비스로 라우팅하고 어플리케이션의 전체적인 조정을 담당합니다.\n- ML Service: ML 서비스는 이미지 데이터를 처리하는 역할을 합니다. Keras OCR을 사용하여 이미지에서 텍스트를 추출하고 Gateway Service와 통신하여 이미지 데이터를 받아 추출된 텍스트를 전송합니다.\n- Auth Service: Auth 서비스는 사용자 인증 및 이메일 인증을 처리합니다. 사용자 등록, OTP 생성 및 검증, 이메일 인증 확인 기능이 포함되어 있습니다.\n- Notification Service: 이 서비스는 사용자에게 이메일을 보내는 역할을 합니다. 프로세스가 완료될 때 트리거됩니다.\n\n## 2. 준비 사항\n\n시작하기 전에 다음 사항을 확인해주세요:\n\n<div class=\"content-ad\"></div>\n\n- 시스템에 Docker가 설치되어 있습니다.\n- 시스템에 Python이 설치되어 있습니다.\n- Docker, Python 및 PostgreSQL에 대한 기본 지식이 있습니다.\n\n# 3. 요구 사항 설정\n\n## Docker를 사용하여 PostgreSQL 설치\n\nPostgreSQL을 Docker를 사용하여 설치하려면 다음 명령을 실행하십시오:\n\n<div class=\"content-ad\"></div>\n\n```js\n도커를 사용하여 RabbitMQ를 설치하기 위해서는 다음 명령어를 실행하세요:\n\n도커를 실행하여 RabbitMQ를 설치하려면 다음 명령어를 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n# 4. 프로젝트 설정하기\n\n## A. 프로젝트 폴더 설정하기\n\nmicroservices-demo/\n│\n├── gateway/\n│ ├── rpc_client.py\n│ ├── .env \n│ ├── requirements.txt\n│ └── main.py\n│\n├── ml_services/\n│ ├── requirements.txt\n│ ├── artifacts/\n│ ├── .env\n│ └── main.py\n│\n├── notification_service/\n│ ├── email_service.py\n│ ├── requirements.txt\n│ ├── .env\n│ └── main.py\n│\n├── auth/\n│ ├── database.py\n│ ├── models.py\n│ ├── schemas.py\n│ ├── service.py\n│ ├── requirements.txt\n│ ├── .env\n│ └── main.py\n│\n└── README.md\n\n## B. 게이트웨이 구현하기\n\n<div class=\"content-ad\"></div>\n\n이제 게이트웨이 서비스를 구현해 봅시다. gateway/ 디렉토리에 main.py 파일을 만들어 아래 코드를 추가해주세요:\n\nfrom fastapi import FastAPI, HTTPException, File, UploadFile\nimport fastapi as _fastapi\nfrom fastapi.security import OAuth2PasswordBearer\nfrom dotenv import load_dotenv\nfrom jwt.exceptions import DecodeError\nfrom pydantic import BaseModel\nimport requests\nimport base64\nimport pika\nimport logging\nimport os\nimport jwt\nimport rpc_client\n\napp = FastAPI()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# 환경 변수 로드\nload_dotenv()\nlogging.basicConfig(level=logging.INFO)\n\n# 환경 변수 가져오기\nJWT_SECRET = os.environ.get(\"JWT_SECRET\")\nAUTH_BASE_URL = os.environ.get(\"AUTH_BASE_URL\")\nRABBITMQ_URL = os.environ.get(\"RABBITMQ_URL\")\n\n# RabbitMQ에 연결\nconnection = pika.BlockingConnection(pika.ConnectionParameters(RABBITMQ_URL))\nchannel = connection.channel()\nchannel.queue_declare(queue='gatewayservice')\nchannel.queue_declare(queue='ocr_service')\n\n# JWT 토큰 유효성 검사\nasync def jwt_validation(token: str = _fastapi.Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[\"HS256\"])\n        return payload\n    except DecodeError:\n        raise HTTPException(status_code=401, detail=\"Invalid JWT token\")\n\n# 요청 바디를 위한 Pydantic 모델\nclass GenerateUserToken(BaseModel):\n    username: str\n    password: str\n\nclass UserCredentials(BaseModel):\n    username: str\n    password: str\n\nclass UserRegisteration(BaseModel):\n    name: str\n    email: str\n    password: str\n\nclass GenerateOtp(BaseModel):\n    email: str\n\nclass VerifyOtp(BaseModel):\n    email: str\n    otp: int\n\n# 인증 라우트\n@app.post(\"/auth/login\", tags=['Authentication Service'])\nasync def login(user_data: UserCredentials):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/token\", json={\"username\": user_data.username, \"password\": user_data.password})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n@app.post(\"/auth/register\", tags=['Authentication Service'])\nasync def registeration(user_data: UserRegisteration):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/users\", json={\"name\": user_data.name, \"email\": user_data.email, \"password\": user_data.password})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n@app.post(\"/auth/generate_otp\", tags=['Authentication Service'])\nasync def generate_otp(user_data: GenerateOtp):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/users/generate_otp\", json={\"email\": user_data.email})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n@app.post(\"/auth/verify_otp\", tags=['Authentication Service'])\nasync def verify_otp(user_data: VerifyOtp):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/users/verify_otp\", json={\"email\": user_data.email, \"otp\": user_data.otp})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n# 확장 서비스 OCR 라우트\n@app.post('/ocr', tags=['Machine learning Service'])\ndef ocr(file: UploadFile = File(...), payload: dict = _fastapi.Depends(jwt_validation)):\n    # 파일을 임시 위치에 저장\n    with open(file.filename, \"wb\") as buffer:\n        buffer.write(file.file.read())\n\n    ocr_rpc = rpc_client.OcrRpcClient()\n\n    with open(file.filename, \"rb\") as buffer:\n        file_data = buffer.read()\n        file_base64 = base64.b64encode(file_data).decode()\n\n    request_json = {\n        'user_name': payload['name'],\n        'user_email': payload['email'],\n        'user_id': payload['id'],\n        'file': file_base64\n    }\n\n    # OCR 마이크로서비스에 요청 JSON을 사용하여 호출\n    response = ocr_rpc.call(request_json)\n\n    # 임시 이미지 파일 삭제\n    os.remove(file.filename)\n    return response\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=5001, reload=True)\n\n게이트웨이 환경을 설정하려면 gateway 폴더에 .env 파일을 만드세요.\n\nAUTH_BASE_URL=http://0.0.0.0:5000\nJWT_SECRET=e56623570e0a0152989fd38e13da9cd6eb7031e4e039e939ba845167ee59b496\nRABBITMQ_URL=localhost\n\n<div class=\"content-ad\"></div>\n\n다른 마이크로서비스와 통신하기 위해 RabbitMQ를 사용할 것입니다. 이는 서비스 간 비동기 메시징을 가능하게 하는 메시지 브로커입니다. RabbitMQ 서버와의 통신을 처리하기 위해 gateway/ 디렉토리에 rpc_client.py 파일을 생성할 것입니다.\n\nimport pika\nimport uuid\nimport json\nfrom dotenv import load_dotenv\nimport os\n\n# 환경 변수 로딩\nload_dotenv()\nRABBITMQ_URL = os.environ.get(\"RABBITMQ_URL\")\n\nclass OcrRpcClient(object):\n\n    def __init__(self):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(host=RABBITMQ_URL))\n\n        self.channel = self.connection.channel()\n\n        result = self.channel.queue_declare(queue='', exclusive=True)\n        self.callback_queue = result.method.queue\n\n        self.channel.basic_consume(\n            queue=self.callback_queue,\n            on_message_callback=self.on_response,\n            auto_ack=True)\n\n    def on_response(self, ch, method, props, body):\n        if self.corr_id == props.correlation_id:\n            self.response = body\n\n    def call(self, message):\n        self.response = None\n        self.corr_id = str(uuid.uuid4())\n        self.channel.basic_publish(\n            exchange='',\n            routing_key='ocr_service',\n            properties=pika.BasicProperties(\n                reply_to=self.callback_queue,\n                correlation_id=self.corr_id,\n            ),\n            body=json.dumps(message))\n        while self.response is None:\n            self.connection.process_data_events()\n        response_json = json.loads(self.response)\n        return response_json\n\n이 코드는 RabbitMQ를 사용하여 OCR 마이크로서비스(ML 마이크로서비스)로 메시지를 보내기 위한 클라이언트 클래스인 OcrRpcClient를 정의합니다. 연결을 초기화하고, 응답을 위한 콜백 큐를 설정하고, 메시지를 보내고 응답을 비동기적으로 받을 수 있는 방법을 제공합니다.\n\n- 초기화(__init__):\n\n<div class=\"content-ad\"></div>\n\nRabbitMQ에 연결을 설정합니다. 채널을 생성하고 고유한 콜백 큐를 선언합니다. 콜백 큐에서 응답을 수신하기 위해 소비자를 설정합니다.\n\n2. 요청 보내기 (호출):\n\nOCR 마이크로서비스(ML 마이크로서비스)에 메시지를 보냅니다. 콜백 큐에서 응답을 기다리고 반환합니다.\n\n이 클래스는 RabbitMQ를 사용하여 게이트웨이 서비스가 OCR 마이크로서비스와 효율적으로 통신할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n## C. Auth 마이크로서비스 구현\n\n이 코드는 FastAPI를 사용하여 사용자 등록, 로그인, JWT 토큰 생성, OTP를 사용한 이메일 확인 및 사용자 프로필 검색을 제공하는 인증 서비스를 구현합니다. 데이터베이스 작업에는 SQLAlchemy를 사용하고 OTP 이메일을 보내기 위해 RabbitMQ를 사용합니다. 이 서비스에는 사용자 생성, JWT 토큰 생성, 사용자 프로필 검색 및 이메일 확인을 위한 OTP 확인에 대한 엔드포인트가 포함되어 있습니다.\n\nfrom typing import List\nfrom fastapi import HTTPException \nimport fastapi as _fastapi\nimport schemas as _schemas\nimport sqlalchemy.orm as _orm\nimport models as _models\nimport service as _services\nimport logging\nimport database as _database\nimport pika\n\n# rabbitmq connection\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host=\"localhost\"))\nchannel = connection.channel()\nchannel.queue_declare(queue='email_notification')\n\ndef get_db():\n    db = _database.SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = _fastapi.FastAPI()\nlogging.basicConfig(level=logging.INFO)\n_models.Base.metadata.create_all(_models.engine)\n\n@app.post(\"/api/users\", tags=['사용자 인증'])\nasync def create_user(\n    user: _schemas.UserCreate, \n    db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    db_user = await _services.get_user_by_email(email=user.email, db=db)\n\n    if db_user:\n        logging.info('해당 이메일로 이미 가입된 사용자가 있습니다')\n        raise _fastapi.HTTPException(\n            status_code=200,\n            detail=\"해당 이메일로 이미 가입된 사용자가 있습니다\")\n\n    user = await _services.create_user(user=user, db=db)\n\n    return _fastapi.HTTPException(\n            status_code=201,\n            detail=\"사용자 등록이 완료되었습니다. 계정을 활성화하려면 이메일을 확인하세요!\")\n\n# API 상태 확인 엔드포인트\n@app.get(\"/check_api\")\nasync def check_api():\n    return {\"status\": \"API와 연결되었습니다\"}\n\n@app.post(\"/api/token\", tags=['사용자 인증'])\nasync def generate_token(\n    user_data: _schemas.GenerateUserToken,\n    db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    user = await _services.authenticate_user(email=user_data.username, password=user_data.password, db=db)\n\n    if user == \"is_verified_false\":\n        logging.info('이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.')\n        raise _fastapi.HTTPException(\n            status_code=403, detail=\"이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.\")\n\n    if not user:\n        logging.info('잘못된 자격 증명')\n        raise _fastapi.HTTPException(\n            status_code=401, detail=\"잘못된 자격 증명\")\n\n    logging.info('JWT 토큰이 생성되었습니다.')\n    return await _services.create_token(user=user)\n\n@app.get(\"/api/users/me\", response_model=_schemas.User, tags=['사용자 인증'])\nasync def get_user(user: _schemas.User = _fastapi.Depends(_services.get_current_user)):\n    return user\n\n@app.get(\"/api/users/profile\", tags=['사용자 인증'])\nasync def get_user(email: str, db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    return db.query(_models.User and _models.Address).filter_by(id=1).first()\n\n@app.post(\"/api/users/generate_otp\", response_model=str, tags=[\"사용자 인증\"])\nasync def send_otp_mail(userdata: _schemas.GenerateOtp, db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    user = await _services.get_user_by_email(email=userdata.email, db=db)\n\n    if not user:\n        raise _fastapi.HTTPException(status_code=404, detail=\"사용자를 찾을 수 없습니다\")\n\n    if user.is_verified:\n        raise _fastapi.HTTPException(status_code=400, detail=\"이미 확인된 사용자입니다\")\n\n    # OTP 생성 및 전송\n    otp = _services.generate_otp()\n    print(otp)\n    _services.send_otp(userdata.email, otp, channel)\n\n    # OTP를 데이터베이스에 저장\n    user.otp = otp\n    db.add(user)\n    db.commit()\n\n    return \"이메일로 OTP가 전송되었습니다\"\n\n@app.post(\"/api/users/verify_otp\", tags=[\"사용자 인증\"])\nasync def verify_otp(userdata: _schemas.VerifyOtp, db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    user = await _services.get_user_by_email(email=userdata.email, db=db )\n\n    if not user:\n        raise _fastapi.HTTPException(status_code=404, detail=\"사용자를 찾을 수 없습니다\")\n\n    if not user.otp or user.otp != userdata.otp:\n        raise _fastapi.HTTPException(status_code=400, detail=\"잘못된 OTP\")\n\n    # 사용자의 is_verified 필드 업데이트\n    user.is_verified = True\n    user.otp = None  # OTP 초기화\n    db.add(user)\n    db.commit()\n\n    return \"이메일 확인이 성공적으로 완료되었습니다\"\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=5000, reload=True)\n\n이 코드는 PostgreSQL 데이터베이스에 연결하기 위해 SQLAlchemy 엔진과 세션 메이커를 설정합니다. dotenv를 사용하여 환경 변수에서 데이터베이스 연결 세부 정보를 로드합니다. DATABASE_URL은 호스트, 데이터베이스 이름, 사용자 이름 및 암호를 포함하여 검색된 환경 변수를 사용하여 구성됩니다. 데이터베이스 연결 세부를 사용하여 create_engine를 사용하여 엔진을 생성하고 해당 엔진에 바인딩된 세션 메이커인 SessionLocal을 정의합니다. ORM 모델을 정의하는 Declarative Base로 사용하기 위해 Base 변수가 초기화됩니다.\n\n<div class=\"content-ad\"></div>\n\nimport sqlalchemy as _sql\nimport sqlalchemy.ext.declarative as _declarative\nimport sqlalchemy.orm as _orm\nfrom dotenv import load_dotenv\nimport os\n\n# .env 파일에서 환경 변수를 불러옵니다\nload_dotenv()\n\n# 환경 변수를 가져옵니다\npostgres_host = os.environ.get(\"POSTGRES_HOST\")\npostgres_db = os.environ.get(\"POSTGRES_DB\")\npostgres_user = os.environ.get(\"POSTGRES_USER\")\npostgres_password = os.environ.get(\"POSTGRES_PASSWORD\")\n\n# PostgreSQL 서버가 로컬에서 실행 중이라고 가정하고 'mydatabase'라는 이름의 데이터베이스가 있다고 가정합니다\nDATABASE_URL = f\"postgresql://{postgres_user}:{postgres_password}@{postgres_host}/{postgres_db}\"\n\nengine = _sql.create_engine(DATABASE_URL)\nSessionLocal = _orm.sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = _declarative.declarative_base()\r\n\n이 코드는 사용자 및 주소 테이블에 대한 SQLAlchemy 모델을 정의하며, 사용자 정보 및 주소를 저장하고 이들 사이의 관계를 설정합니다. 또한 제공된 엔진을 사용하여 데이터베이스에 테이블을 생성합니다.\n\nimport datetime as _dt\nimport sqlalchemy as _sql\nimport sqlalchemy.orm as _orm\nimport passlib.hash as _hash\nfrom database import Base, engine\nimport database as _database\n\nBase.metadata.create_all(engine)\n\nclass User(_database.Base):\n    __tablename__ = \"users\"\n    id = _sql.Column(_sql.Integer, primary_key=True, index=True)\n    name = _sql.Column(_sql.String)\n    email = _sql.Column(_sql.String, unique=True, index=True)\n    is_verified = _sql.Column(_sql.Boolean, default=False)\n    otp = _sql.Column(_sql.Integer)\n    hashed_password = _sql.Column(_sql.String)\n    addresses = _orm.relationship(\"Address\", back_populates=\"user\")\n    date_created = _sql.Column(_sql.DateTime, default=_dt.datetime.utcnow)\n\n    def verify_password(self, password: str):\n        return _hash.bcrypt.verify(password, self.hashed_password)\n\nclass Address(_database.Base):\n    __tablename__ = \"addresses\"\n    id = _sql.Column(_sql.Integer, primary_key=True, index=True)\n    street = _sql.Column(_sql.String)\n    landmark = _sql.Column(_sql.String)\n    city = _sql.Column(_sql.String)\n    country = _sql.Column(_sql.String)\n    pincode = _sql.Column(_sql.String)\n    user_id = _sql.Column(_sql.Integer, _sql.ForeignKey(\"users.id\"))\n    user = _orm.relationship(\"User\", back_populates=\"addresses\")\n    latitude = _sql.Column(_sql.Float)\n    longitude = _sql.Column(_sql.Float)\r\n\n이 코드는 사용자 관련 데이터 구조에 대한 Pydantic 모델을 정의하며, 사용자 생성, 인증 및 OTP 확인용입니다. 위치 정보를 위한 주소 모델도 포함되어 있습니다. 이 모델들은 사전 속성으로부터 인스턴스를 자동으로 생성하도록 구성되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 코드는 사용자 인증 및 OTP(일회용 비밀번호) 생성 및 확인을 위한 다양한 함수 및 종속성을 정의합니다. HTTP 요청을 처리하기 위해 FastAPI를 사용하며, 데이터베이스 작업을 위해 SQLAlchemy를 사용하고 데이터 유효성 검사 및 직렬화를 위해 Pydantic을 사용하며, 인증을 위해 JWT를 사용하고, 이메일 알림을 보내기 위해 RabbitMQ를 사용합니다. 이 함수들은 데이터베이스 생성, 데이터베이스 세션 가져오기, 새 사용자 생성, 사용자 인증, JWT 토큰 생성, JWT 토큰에서 현재 사용자 가져오기, 무작위 OTP 생성, RabbitMQ에 연결 및 OTP 이메일 알림 전송 등이 포함됩니다.\n\n환경 변수 로드\n\nJWT_SECRET = os.getenv(\"JWT_SECRET\")\nRABBITMQ_URL = os.getenv(\"RABBITMQ_URL\")\noauth2schema = _security.OAuth2PasswordBearer(\"/api/token\")\n\n데이터베이스 생성\n\ndef create_database():\n    # 데이터베이스 테이블 생성\n    return _database.Base.metadata.create_all(bind=_database.engine)\n\n데이터베이스 세션 가져오기\n\ndef get_db():\n    # 데이터베이스 세션을 얻는 의존성\n    db = _database.SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n이메일별 사용자 가져오기\n\nasync def get_user_by_email(email: str, db: _orm.Session):\n    # 데이터베이스에서 이메일별로 사용자 검색\n    return db.query(_models.User).filter(_models.User.email == email and _models.User.is_verified == True).first()\n\n새 사용자 생성\n\nasync def create_user(user: _schemas.UserCreate, db: _orm.Session):\n    # 데이터베이스에 새 사용자 생성\n    try:\n        valid = _email_check.validate_email(user.email)\n        name = user.name\n        email = valid.email\n    except _email_check.EmailNotValidError:\n        raise _fastapi.HTTPException(status_code=404, detail=\"정확한 이메일을 입력하세요\")\n\n    user_obj = _models.User(email=email, name=name, hashed_password=_hash.bcrypt.hash(user.password))\n    db.add(user_obj)\n    db.commit()\n    db.refresh(user_obj)\n    return user_obj\n\n사용자 인증\n\nasync def authenticate_user(email: str, password: str, db: _orm.Session):\n    # 사용자 인증\n    user = await get_user_by_email(email=email, db=db)\n\n    if not user:\n        return False\n    \n    if not user.is_verified:\n        return 'is_verified_false'\n    \n    if not user.verify_password(password):\n        return False\n\n    return user\n\nJWT 토큰 생성\n\nasync def create_token(user: _models.User):\n    # 인증을 위한 JWT 토큰 생성\n    user_obj = _schemas.User.from_orm(user)\n    user_dict = user_obj.model_dump()\n    del user_dict[\"date_created\"]\n    token = jwt.encode(user_dict, JWT_SECRET, algorithm=\"HS256\")\n    return dict(access_token=token, token_type=\"bearer\")\n\n현재 사용자 가져오기\n\nasync def get_current_user(db: _orm.Session = _fastapi.Depends(get_db), token: str = _fastapi.Depends(oauth2schema)):\n    # JWT 토큰에서 현재 인증된 사용자 가져오기\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[\"HS256\"])\n        user = db.query(_models.User).get(payload[\"id\"])\n    except:\n        raise _fastapi.HTTPException(status_code=401, detail=\"유효하지 않은 이메일 또는 비밀번호\")\n    return _schemas.User.from_orm(user)\n\n랜덤 OTP 생성\n\ndef generate_otp():\n    # 랜덤 OTP 생성\n    return str(random.randint(100000, 999999))\n\nRabbitMQ에 연결\n\ndef connect_to_rabbitmq():\n    # RabbitMQ에 연결\n    while True:\n        try:\n            connection = pika.BlockingConnection(pika.ConnectionParameters(RABBITMQ_URL))\n            return connection\n        except pika.exceptions.AMQPConnectionError:\n            print(\"RabbitMQ에 연결하지 못했습니다. 5초 후 다시 시도 중...\")\n            time.sleep(5)\n\nOTP 이메일 알림 전송\n\ndef send_otp(email, otp, channel):\n    # RabbitMQ를 사용하여 OTP 이메일 알림 전송\n    connection = connect_to_rabbitmq()\n    channel = connection.channel()\n    message = {'email': email,\n               'subject': '계정 확인 OTP 알림',\n               'other': 'null',\n               'body': f'계정 확인을 위한 OTP는 다음과 같습니다: {otp} \\n 계정 설정을 완료하려면 확인 페이지에 이 OTP를 입력하세요. \\n 이 OTP를 요청하지 않았다면 이 메시지를 무시해주세요.\\n 감사합니다 '\n               }\n\n    try:\n        queue_declare_ok = channel.queue_declare(queue='email_notification', passive=True)\n        current_durable = queue_declare_ok.method.queue\n\n        if current_durable:\n            if queue_declare_ok.method.queue != current_durable:\n                channel.queue_delete(queue='email_notification')\n                channel.queue_declare(queue='email_notification', durable=True)\n        else:\n            channel.queue_declare(queue='email_notification', durable=True)\n\n        channel.basic_publish(\n            exchange=\"\",\n            routing_key='email_notification',\n            body=json.dumps(message),\n            properties=pika.BasicProperties(\n                delivery_mode=pika.spec.PERSISTENT_DELIVERY_MODE\n            ),\n        )\n        print(\"OTP 이메일 알림 전송 완료\")\n    except Exception as err:\n        print(f\"메시지 전송 실패: {err}\")\n    finally:\n        channel.close()\n        connection.close()\n\n## D. 머신 러닝 마이크로서비스 구현\n\n<div class=\"content-ad\"></div>\n\n이 Python 스크립트는 RabbitMQ 서버에 연결하여 'ocr_service'라는 큐에서 메시지를 소비합니다. 메시지를받으면 OCRService 객체를 사용하여 처리하고 send_email_notification 함수를 사용하여 이메일 알림을 보내며, 그런 다음 응답을 응답 큐에 발행합니다. 각 메시지를 처리한 후 RabbitMQ에 메시지 전달을 인식합니다. 스크립트는 RabbitMQ가 전달할 수 있는 미인증 메시지의 수를 제한하는 prefetch count 1을 사용합니다.\n\nimport pika\nimport json\nfrom utils import OCRService\nfrom utils import send_email_notification\n\n# RabbitMQ에 연결\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\nchannel.queue_declare(queue='ocr_service')\n\n# OCR 요청을 처리하기 위한 콜백 함수\ndef on_request(ch, method, props, body):\n    # OCR 서비스 초기화\n    ocr_service = OCRService()\n    # OCR 요청 처리\n    response = ocr_service.process_request(body)\n\n    # 이메일 알림 전송\n    send_email_notification(response['user_email'], response['ocr_text'], channel)\n\n    # 응답을 응답 큐에 발행\n    ch.basic_publish(exchange='',\n                     routing_key=props.reply_to,\n                     properties=pika.BasicProperties(correlation_id = \\\n                                                         props.correlation_id),\n                     body=json.dumps(response))\n    # 메시지 전달을 인식\n    ch.basic_ack(delivery_tag=method.delivery_tag)\n# prefetch count를 1로 설정\nchannel.basic_qos(prefetch_count=1)\n# 'ocr_service' 큐에서 메시지 수신\nchannel.basic_consume(queue='ocr_service', on_message_callback=on_request)\n# 메시지 수신 시작\nprint(\" [x] RPC 요청 대기중\")\nchannel.start_consuming()\r\n\nimport json\nimport base64\nimport pandas as pd\n#keras ocr pipeline and imports\nimport keras_ocr\nimport pika\n\nclass OCRService:\n   \n    def __init__(self):\n        self.keras_pipeline = keras_ocr.pipeline.Pipeline()\n\n    def keras_ocr(self, image_path):\n        results = self.keras_pipeline.recognize([image_path])\n        df = pd.DataFrame(results[0], columns=['text', 'bbox'])\n        words = df['text'].tolist()\n        sentence = ' '.join(words)\n        return sentence\n\n    def process_request(self, message):\n        message_body = json.loads(message)\n        user_name = message_body['user_name']\n        user_email = message_body['user_email']\n        user_id = message_body['user_id']\n        file_base64 = message_body['file']\n        print(f\" [x]user_id: {user_id} request recieved from gateway..\")\n        print(f\" [x]processing request for {user_name}\")\n\n        # file_base64에 base64로 인코딩된 문자열이 포함되어 있다고 가정\n        file_data = base64.b64decode(file_base64.encode())\n        # 디코드된 파일 데이터를 새 파일에 작성\n        with open('artifacts/decoded_file.png', 'wb') as f:\n            f.write(file_data)\n\n        image_path = \"artifacts/decoded_file.png\"\n        ocr_text = self.keras_ocr(image_path)\n        print(\" [^] OCR 처리 완료 !!!\")\n\n        response = {\n            \"user_id\": user_id,\n            \"user_name\": user_name,\n            \"user_email\": user_email,\n            \"ocr_text\": ocr_text\n        }\n\n        return response\n\ndef send_email_notification(email, ocr_text, channel):\n    # RabbitMQ를 사용하여 이메일 알림 전송\n    message = {\n        'email': email,\n        'subject':'OCR 처리 완료 !!',\n        'body':f'이미지에 대한 OCR (광학 문자 인식) 프로세스가 성공적으로 완료되었음을 알려드립니다.\\n 추출된 텍스트가 처리되어 사용할 준비가되었습니다.\\n\\n  OCR 텍스트 : {ocr_text}',\n        'other': 'null',\n       }\n\n    try:\n        channel.basic_publish(\n            exchange=\"\",\n            routing_key='email_notification',\n            body=json.dumps(message),\n            properties=pika.BasicProperties(\n                delivery_mode=pika.spec.PERSISTENT_DELIVERY_MODE\n            ),\n        )\n        print(\"OCR 처리 완료 이메일 알림 전송됨\")\n    except Exception as err:\n        print(f\"메시지 게시 실패: {err}\")\r\n\n## D. 알림 마이크로서비스 구현\n\n<div class=\"content-ad\"></div>\n\n이 스크립트는 \"email_notification\" 큐에서 메시지를 수신하는 RabbitMQ 소비자를 설정합니다. 메시지를 받으면 email_service 모듈의 notification 함수를 호출하여 알림 프로세스를 처리합니다. 성공하면 메시지를 확인하고, 그렇지 않으면 메시지를 거부하고 오류 메시지를 출력합니다.\n\nimport pika\nimport sys\nimport os\nimport time\nimport email_service\nfrom dotenv import load_dotenv\n\n# 환경 변수 로드\nload_dotenv()\nRABBITMQ_URL = os.environ.get(\"RABBITMQ_URL\")\n\ndef main():\n    # rabbitmq 연결\n    connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_URL))\n    channel = connection.channel()\n\n    def callback(ch, method, properties, body):\n        try:\n            err = email_service.notification(body)\n            if err:\n                ch.basic_nack(delivery_tag=method.delivery_tag)\n            else:\n                ch.basic_ack(delivery_tag=method.delivery_tag)\n        except Exception as e:\n            print(f\"메시지 처리 중 오류 발생: {e}\")\n            ch.basic_nack(delivery_tag=method.delivery_tag)\n\n    channel.basic_consume(\n        queue=\"email_notification\", on_message_callback=callback\n    )\n\n    print(\"메시지 수신 대기 중. 종료하려면 CTRL+C를 누르세요\")\n\n    channel.start_consuming()\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except KeyboardInterrupt:\n        print(\"중단됨\")\n        try:\n            sys.exit(0)\n        except SystemExit:\n            os._exit(0)\n\nimport smtplib, os, json\nfrom email.message import EmailMessage\nfrom dotenv import load_dotenv\nfrom email.mime.text import MIMEText\n\nload_dotenv()\n\ndef notification(message):\n    try:\n        message = json.loads(message)\n        receiver_address = message[\"email\"]\n        subject = message[\"subject\"]\n        body = message[\"body\"]\n        other = message[\"other\"]\n\n        sender_address = os.environ.get(\"GMAIL_ADDRESS\")\n        sender_password = os.environ.get(\"GMAIL_PASSWORD\")\n\n        # Gmail SMTP 서버 설정\n        smtp_server = 'smtp.gmail.com'\n        smtp_port = 587\n\n        server = smtplib.SMTP(smtp_server, smtp_port)\n        server.starttls()\n        server.login(sender_address, sender_password)\n\n        # 이메일 메시지 작성\n        msg = MIMEText(body)\n        msg['Subject'] = subject\n        msg['From'] = sender_address\n        msg['To'] = receiver_address\n\n        server.sendmail(sender_address, receiver_address, msg.as_string())\n        server.quit()\n\n        print(\"이메일 발송 완료\")\n    except Exception as e:\n        print(f\"이메일 발송 실패: {e}\")\n\n# 애플리케이션 데모\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n마지막으로, FastAPI와 RabbitMQ를 사용하여 엔드 투 엔드 마이크로서비스 아키텍처를 성공적으로 구현했습니다. 사용자 인증 서비스, OCR 처리를 위한 머신 러닝 서비스 및 이메일 알림을 위한 알림 서비스를 어떻게 만드는지 보여드렸습니다.\n\n이 블로그를 통해 서비스 격리, 메시징 큐를 통한 통신, 확장성 및 성능을 위한 비동기 처리의 장점과 같은 마이크로서비스의 주요 개념에 대해 배웠습니다.\n\n프로젝트를 실행하려면 GitHub 저장소의 README 파일에 있는 지침을 따르세요. 읽어 주셔서 감사합니다. 이 프로젝트가 여러분께 영감을 주어 직접 마이크로서비스 아키텍처를 탐구하고 구현하는 데 도움이 되기를 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n깃허브: [https://github.com/shantanu1905/fastapi-microservice-demo](https://github.com/shantanu1905/fastapi-microservice-demo)","ogImage":{"url":"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":29},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png\" alt=\"image\"></p>\n<h1>소개:</h1>\n<p>최근 몇 년간, 마이크로서비스 아키텍처는 확장 가능하고 유지보수 가능하며 유연한 애플리케이션을 만드는 능력 때문에 인기를 얻었습니다. 이 블로그 포스트에서는 마이크로서비스 아키텍처의 개념을 탐구하고, 파이썬 생태계의 강력한 도구인 FastAPI와 RabbitMQ를 사용하여 간단한 마이크로서비스를 구축하는 방법을 보여드리겠습니다.</p>\n<h1>몰리딕 아키텍처란?</h1>\n<p>단일체 아키텍처는 모든 비즈니스 관심을 결합하는 단일 대규모 컴퓨팅 네트워크로, 하나의 코드 베이스로 생각해 볼 수 있습니다. 애플리케이션의 모든 구성 요소를 하나의 지붕 아래에 모아둔 거대하고 빙하처럼 보이는 구조라고 상상해보세요. 단일체에서 변경을 하려면 전체 스택을 업데이트해야 하며, 이는 시간이 많이 소요되고 엄격할 수 있습니다. 아래 다이어그램에서 단일체 아키텍처의 예시를 볼 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_1.png\" alt=\"단일체 아키텍처 다이어그램\"></p>\n<h1>마이크로서비스 아키텍처란?</h1>\n<p>반면에, 마이크로서비스 아키텍처는 응용 프로그램이 작은, 독립적으로 배포 가능한 서비스로 분할되는 접근 방식입니다. 각 서비스는 해당하는 비즈니스 로직과 데이터베이스를 갖고 있으며, 가벼운 프로토콜을 통해 다른 서비스와 통신합니다. 이 접근 방식은 빠른 개발 주기, 쉬운 유지보수, 그리고 더 나은 확장성을 가능하게 합니다.</p>\n<h1>Monolithic vs. Microservice의 차이</h1>\n<h1>RabbitMQ는 무엇이며, 왜 마이크로서비스를 구축하는 데 사용되는가?</h1>\n<p>RabbitMQ는 진보된 메시지 큐잉 프로토콜(AMQP)을 구현하는 메시지 브로커입니다. RabbitMQ는 분산 시스템의 다양한 구성 요소 사이에서 중개자 역할을 하여 효율적으로 통신하고 작업을 조정할 수 있도록 합니다. RabbitMQ가 마이크로서비스 아키텍처에서 흔히 사용되는 이유는 다음과 같습니다:</p>\n<ul>\n<li>Decoupling: RabbitMQ는 시스템 구성 요소들을 비동기적으로 통신할 수 있게 함으로써 시스템을 분리하는 데 도움을 줍니다. 이는 서비스가 서로의 응답을 기다리지 않고 독립적으로 작동할 수 있어 더 견고하고 확장 가능한 시스템을 이끌어냅니다.</li>\n<li>Load Balancing: RabbitMQ는 메시지를 여러 소비자 인스턴스에 분배함으로써 부하를 균형 있게 분배하고 효율적인 자원 활용을 보장합니다.</li>\n<li>Fault Tolerance: RabbitMQ는 클러스터링과 복제를 지원하여 노드가 실패해도 메시지가 손실되지 않도록 합니다. 이는 시스템을 더욱 고장 내성이 뛰어나고 신뢰할 수 있도록 만듭니다.</li>\n<li>Scalability: RabbitMQ를 사용하면 소비자 인스턴스나 클러스터에 노드를 추가하여 시스템을 확장할 수 있어 애플리케이션이 성장함에 따라 증가하는 메시지 트래픽을 처리할 수 있습니다.</li>\n<li>Message Routing: RabbitMQ는 직접, 주제, 팬아웃과 같은 다양한 메시지 라우팅 메커니즘을 지원하여 라우팅 키나 패턴에 따라 특정 큐로 메시지를 전달할 수 있습니다.</li>\n<li>Message Acknowledgment: RabbitMQ는 메시지 승인을 지원하여 메시지가 한 번만 처리되고 전송 중에 손실되지 않도록 보장합니다.</li>\n<li>전반적으로 RabbitMQ는 확장 가능하고 분리되고 고장 내성이 뛰어난 마이크로서비스 아키텍처를 구축하는 데 도움이 되는 견고하고 신뢰할 수 있는 메시징 시스템입니다.</li>\n</ul>\n<h1>마이크로서비스 응용프로그램 코딩</h1>\n<h1>1. 프로젝트 소개</h1>\n<p>저희 어플리케이션은 네 가지 주요 서비스로 구성되어 있습니다:</p>\n<ul>\n<li>Gateway Service: 이 서비스는 모든 들어오는 요청의 진입 지점 역할을 합니다. 요청을 적절한 마이크로서비스로 라우팅하고 어플리케이션의 전체적인 조정을 담당합니다.</li>\n<li>ML Service: ML 서비스는 이미지 데이터를 처리하는 역할을 합니다. Keras OCR을 사용하여 이미지에서 텍스트를 추출하고 Gateway Service와 통신하여 이미지 데이터를 받아 추출된 텍스트를 전송합니다.</li>\n<li>Auth Service: Auth 서비스는 사용자 인증 및 이메일 인증을 처리합니다. 사용자 등록, OTP 생성 및 검증, 이메일 인증 확인 기능이 포함되어 있습니다.</li>\n<li>Notification Service: 이 서비스는 사용자에게 이메일을 보내는 역할을 합니다. 프로세스가 완료될 때 트리거됩니다.</li>\n</ul>\n<h2>2. 준비 사항</h2>\n<p>시작하기 전에 다음 사항을 확인해주세요:</p>\n<ul>\n<li>시스템에 Docker가 설치되어 있습니다.</li>\n<li>시스템에 Python이 설치되어 있습니다.</li>\n<li>Docker, Python 및 PostgreSQL에 대한 기본 지식이 있습니다.</li>\n</ul>\n<h1>3. 요구 사항 설정</h1>\n<h2>Docker를 사용하여 PostgreSQL 설치</h2>\n<p>PostgreSQL을 Docker를 사용하여 설치하려면 다음 명령을 실행하십시오:</p>\n<pre><code class=\"hljs language-js\">도커를 사용하여 <span class=\"hljs-title class_\">RabbitMQ</span>를 설치하기 위해서는 다음 명령어를 실행하세요:\n\n도커를 실행하여 <span class=\"hljs-title class_\">RabbitMQ</span>를 설치하려면 다음 명령어를 실행하세요:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n# <span class=\"hljs-number\">4.</span> 프로젝트 설정하기\n\n## A. 프로젝트 폴더 설정하기\n\nmicroservices-demo/\n│\n├── gateway/\n│ ├── rpc_client.<span class=\"hljs-property\">py</span>\n│ ├── .<span class=\"hljs-property\">env</span> \n│ ├── requirements.<span class=\"hljs-property\">txt</span>\n│ └── main.<span class=\"hljs-property\">py</span>\n│\n├── ml_services/\n│ ├── requirements.<span class=\"hljs-property\">txt</span>\n│ ├── artifacts/\n│ ├── .<span class=\"hljs-property\">env</span>\n│ └── main.<span class=\"hljs-property\">py</span>\n│\n├── notification_service/\n│ ├── email_service.<span class=\"hljs-property\">py</span>\n│ ├── requirements.<span class=\"hljs-property\">txt</span>\n│ ├── .<span class=\"hljs-property\">env</span>\n│ └── main.<span class=\"hljs-property\">py</span>\n│\n├── auth/\n│ ├── database.<span class=\"hljs-property\">py</span>\n│ ├── models.<span class=\"hljs-property\">py</span>\n│ ├── schemas.<span class=\"hljs-property\">py</span>\n│ ├── service.<span class=\"hljs-property\">py</span>\n│ ├── requirements.<span class=\"hljs-property\">txt</span>\n│ ├── .<span class=\"hljs-property\">env</span>\n│ └── main.<span class=\"hljs-property\">py</span>\n│\n└── <span class=\"hljs-variable constant_\">README</span>.<span class=\"hljs-property\">md</span>\n\n## B. 게이트웨이 구현하기\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n이제 게이트웨이 서비스를 구현해 봅시다. gateway/ 디렉토리에 main.<span class=\"hljs-property\">py</span> 파일을 만들어 아래 코드를 추가해주세요:\n\n<span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">FastAPI</span>, <span class=\"hljs-title class_\">HTTPException</span>, <span class=\"hljs-title class_\">File</span>, <span class=\"hljs-title class_\">UploadFile</span>\n<span class=\"hljs-keyword\">import</span> fastapi <span class=\"hljs-keyword\">as</span> _fastapi\n<span class=\"hljs-keyword\">from</span> fastapi.<span class=\"hljs-property\">security</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">OAuth2PasswordBearer</span>\n<span class=\"hljs-keyword\">from</span> dotenv <span class=\"hljs-keyword\">import</span> load_dotenv\n<span class=\"hljs-keyword\">from</span> jwt.<span class=\"hljs-property\">exceptions</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DecodeError</span>\n<span class=\"hljs-keyword\">from</span> pydantic <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">BaseModel</span>\n<span class=\"hljs-keyword\">import</span> requests\n<span class=\"hljs-keyword\">import</span> base64\n<span class=\"hljs-keyword\">import</span> pika\n<span class=\"hljs-keyword\">import</span> logging\n<span class=\"hljs-keyword\">import</span> os\n<span class=\"hljs-keyword\">import</span> jwt\n<span class=\"hljs-keyword\">import</span> rpc_client\n\napp = <span class=\"hljs-title class_\">FastAPI</span>()\noauth2_scheme = <span class=\"hljs-title class_\">OAuth2PasswordBearer</span>(tokenUrl=<span class=\"hljs-string\">\"token\"</span>)\n\n# 환경 변수 로드\n<span class=\"hljs-title function_\">load_dotenv</span>()\nlogging.<span class=\"hljs-title function_\">basicConfig</span>(level=logging.<span class=\"hljs-property\">INFO</span>)\n\n# 환경 변수 가져오기\n<span class=\"hljs-variable constant_\">JWT_SECRET</span> = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"JWT_SECRET\"</span>)\n<span class=\"hljs-variable constant_\">AUTH_BASE_URL</span> = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"AUTH_BASE_URL\"</span>)\n<span class=\"hljs-variable constant_\">RABBITMQ_URL</span> = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"RABBITMQ_URL\"</span>)\n\n# <span class=\"hljs-title class_\">RabbitMQ</span>에 연결\nconnection = pika.<span class=\"hljs-title class_\">BlockingConnection</span>(pika.<span class=\"hljs-title class_\">ConnectionParameters</span>(<span class=\"hljs-variable constant_\">RABBITMQ_URL</span>))\nchannel = connection.<span class=\"hljs-title function_\">channel</span>()\nchannel.<span class=\"hljs-title function_\">queue_declare</span>(queue=<span class=\"hljs-string\">'gatewayservice'</span>)\nchannel.<span class=\"hljs-title function_\">queue_declare</span>(queue=<span class=\"hljs-string\">'ocr_service'</span>)\n\n# <span class=\"hljs-variable constant_\">JWT</span> 토큰 유효성 검사\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">jwt_validation</span>(<span class=\"hljs-attr\">token</span>: str = _fastapi.<span class=\"hljs-title class_\">Depends</span>(oauth2_scheme)):\n    <span class=\"hljs-attr\">try</span>:\n        payload = jwt.<span class=\"hljs-title function_\">decode</span>(token, <span class=\"hljs-variable constant_\">JWT_SECRET</span>, algorithms=[<span class=\"hljs-string\">\"HS256\"</span>])\n        <span class=\"hljs-keyword\">return</span> payload\n    except <span class=\"hljs-title class_\">DecodeError</span>:\n        raise <span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">401</span>, detail=<span class=\"hljs-string\">\"Invalid JWT token\"</span>)\n\n# 요청 바디를 위한 <span class=\"hljs-title class_\">Pydantic</span> 모델\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenerateUserToken</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    <span class=\"hljs-attr\">username</span>: str\n    <span class=\"hljs-attr\">password</span>: str\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserCredentials</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    <span class=\"hljs-attr\">username</span>: str\n    <span class=\"hljs-attr\">password</span>: str\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserRegisteration</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    <span class=\"hljs-attr\">name</span>: str\n    <span class=\"hljs-attr\">email</span>: str\n    <span class=\"hljs-attr\">password</span>: str\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenerateOtp</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    <span class=\"hljs-attr\">email</span>: str\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">VerifyOtp</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    <span class=\"hljs-attr\">email</span>: str\n    <span class=\"hljs-attr\">otp</span>: int\n\n# 인증 라우트\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">\"/auth/login\"</span>, tags=[<span class=\"hljs-string\">'Authentication Service'</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">login</span>(<span class=\"hljs-attr\">user_data</span>: <span class=\"hljs-title class_\">UserCredentials</span>):\n    <span class=\"hljs-attr\">try</span>:\n        response = requests.<span class=\"hljs-title function_\">post</span>(f<span class=\"hljs-string\">\"{AUTH_BASE_URL}/api/token\"</span>, json={<span class=\"hljs-string\">\"username\"</span>: user_data.<span class=\"hljs-property\">username</span>, <span class=\"hljs-string\">\"password\"</span>: user_data.<span class=\"hljs-property\">password</span>})\n        <span class=\"hljs-keyword\">if</span> response.<span class=\"hljs-property\">status_code</span> == <span class=\"hljs-number\">200</span>:\n            <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>()\n        <span class=\"hljs-attr\">else</span>:\n            raise <span class=\"hljs-title class_\">HTTPException</span>(status_code=response.<span class=\"hljs-property\">status_code</span>, detail=response.<span class=\"hljs-title function_\">json</span>())\n    except requests.<span class=\"hljs-property\">exceptions</span>.<span class=\"hljs-property\">ConnectionError</span>:\n        raise <span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">503</span>, detail=<span class=\"hljs-string\">\"Authentication service is unavailable\"</span>)\n\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">\"/auth/register\"</span>, tags=[<span class=\"hljs-string\">'Authentication Service'</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">registeration</span>(<span class=\"hljs-attr\">user_data</span>: <span class=\"hljs-title class_\">UserRegisteration</span>):\n    <span class=\"hljs-attr\">try</span>:\n        response = requests.<span class=\"hljs-title function_\">post</span>(f<span class=\"hljs-string\">\"{AUTH_BASE_URL}/api/users\"</span>, json={<span class=\"hljs-string\">\"name\"</span>: user_data.<span class=\"hljs-property\">name</span>, <span class=\"hljs-string\">\"email\"</span>: user_data.<span class=\"hljs-property\">email</span>, <span class=\"hljs-string\">\"password\"</span>: user_data.<span class=\"hljs-property\">password</span>})\n        <span class=\"hljs-keyword\">if</span> response.<span class=\"hljs-property\">status_code</span> == <span class=\"hljs-number\">200</span>:\n            <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>()\n        <span class=\"hljs-attr\">else</span>:\n            raise <span class=\"hljs-title class_\">HTTPException</span>(status_code=response.<span class=\"hljs-property\">status_code</span>, detail=response.<span class=\"hljs-title function_\">json</span>())\n    except requests.<span class=\"hljs-property\">exceptions</span>.<span class=\"hljs-property\">ConnectionError</span>:\n        raise <span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">503</span>, detail=<span class=\"hljs-string\">\"Authentication service is unavailable\"</span>)\n\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">\"/auth/generate_otp\"</span>, tags=[<span class=\"hljs-string\">'Authentication Service'</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">generate_otp</span>(<span class=\"hljs-attr\">user_data</span>: <span class=\"hljs-title class_\">GenerateOtp</span>):\n    <span class=\"hljs-attr\">try</span>:\n        response = requests.<span class=\"hljs-title function_\">post</span>(f<span class=\"hljs-string\">\"{AUTH_BASE_URL}/api/users/generate_otp\"</span>, json={<span class=\"hljs-string\">\"email\"</span>: user_data.<span class=\"hljs-property\">email</span>})\n        <span class=\"hljs-keyword\">if</span> response.<span class=\"hljs-property\">status_code</span> == <span class=\"hljs-number\">200</span>:\n            <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>()\n        <span class=\"hljs-attr\">else</span>:\n            raise <span class=\"hljs-title class_\">HTTPException</span>(status_code=response.<span class=\"hljs-property\">status_code</span>, detail=response.<span class=\"hljs-title function_\">json</span>())\n    except requests.<span class=\"hljs-property\">exceptions</span>.<span class=\"hljs-property\">ConnectionError</span>:\n        raise <span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">503</span>, detail=<span class=\"hljs-string\">\"Authentication service is unavailable\"</span>)\n\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">\"/auth/verify_otp\"</span>, tags=[<span class=\"hljs-string\">'Authentication Service'</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">verify_otp</span>(<span class=\"hljs-attr\">user_data</span>: <span class=\"hljs-title class_\">VerifyOtp</span>):\n    <span class=\"hljs-attr\">try</span>:\n        response = requests.<span class=\"hljs-title function_\">post</span>(f<span class=\"hljs-string\">\"{AUTH_BASE_URL}/api/users/verify_otp\"</span>, json={<span class=\"hljs-string\">\"email\"</span>: user_data.<span class=\"hljs-property\">email</span>, <span class=\"hljs-string\">\"otp\"</span>: user_data.<span class=\"hljs-property\">otp</span>})\n        <span class=\"hljs-keyword\">if</span> response.<span class=\"hljs-property\">status_code</span> == <span class=\"hljs-number\">200</span>:\n            <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>()\n        <span class=\"hljs-attr\">else</span>:\n            raise <span class=\"hljs-title class_\">HTTPException</span>(status_code=response.<span class=\"hljs-property\">status_code</span>, detail=response.<span class=\"hljs-title function_\">json</span>())\n    except requests.<span class=\"hljs-property\">exceptions</span>.<span class=\"hljs-property\">ConnectionError</span>:\n        raise <span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">503</span>, detail=<span class=\"hljs-string\">\"Authentication service is unavailable\"</span>)\n\n# 확장 서비스 <span class=\"hljs-variable constant_\">OCR</span> 라우트\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">'/ocr'</span>, tags=[<span class=\"hljs-string\">'Machine learning Service'</span>])\ndef <span class=\"hljs-title function_\">ocr</span>(<span class=\"hljs-attr\">file</span>: <span class=\"hljs-title class_\">UploadFile</span> = <span class=\"hljs-title class_\">File</span>(...), <span class=\"hljs-attr\">payload</span>: dict = _fastapi.<span class=\"hljs-title class_\">Depends</span>(jwt_validation)):\n    # 파일을 임시 위치에 저장\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-title function_\">open</span>(file.<span class=\"hljs-property\">filename</span>, <span class=\"hljs-string\">\"wb\"</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">buffer</span>:\n        buffer.<span class=\"hljs-title function_\">write</span>(file.<span class=\"hljs-property\">file</span>.<span class=\"hljs-title function_\">read</span>())\n\n    ocr_rpc = rpc_client.<span class=\"hljs-title class_\">OcrRpcClient</span>()\n\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-title function_\">open</span>(file.<span class=\"hljs-property\">filename</span>, <span class=\"hljs-string\">\"rb\"</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">buffer</span>:\n        file_data = buffer.<span class=\"hljs-title function_\">read</span>()\n        file_base64 = base64.<span class=\"hljs-title function_\">b64encode</span>(file_data).<span class=\"hljs-title function_\">decode</span>()\n\n    request_json = {\n        <span class=\"hljs-string\">'user_name'</span>: payload[<span class=\"hljs-string\">'name'</span>],\n        <span class=\"hljs-string\">'user_email'</span>: payload[<span class=\"hljs-string\">'email'</span>],\n        <span class=\"hljs-string\">'user_id'</span>: payload[<span class=\"hljs-string\">'id'</span>],\n        <span class=\"hljs-string\">'file'</span>: file_base64\n    }\n\n    # <span class=\"hljs-variable constant_\">OCR</span> 마이크로서비스에 요청 <span class=\"hljs-title class_\">JSON</span>을 사용하여 호출\n    response = ocr_rpc.<span class=\"hljs-title function_\">call</span>(request_json)\n\n    # 임시 이미지 파일 삭제\n    os.<span class=\"hljs-title function_\">remove</span>(file.<span class=\"hljs-property\">filename</span>)\n    <span class=\"hljs-keyword\">return</span> response\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\"__main__\"</span>:\n    <span class=\"hljs-keyword\">import</span> uvicorn\n    uvicorn.<span class=\"hljs-title function_\">run</span>(<span class=\"hljs-string\">\"main:app\"</span>, host=<span class=\"hljs-string\">\"0.0.0.0\"</span>, port=<span class=\"hljs-number\">5001</span>, reload=<span class=\"hljs-title class_\">True</span>)\n\n게이트웨이 환경을 설정하려면 gateway 폴더에 .<span class=\"hljs-property\">env</span> 파일을 만드세요.\n\n<span class=\"hljs-variable constant_\">AUTH_BASE_URL</span>=<span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//0.0.0.0:5000</span>\n<span class=\"hljs-variable constant_\">JWT_SECRET</span>=e56623570e0a0152989fd38e13da9cd6eb7031e4e039e939ba845167ee59b496\n<span class=\"hljs-variable constant_\">RABBITMQ_URL</span>=localhost\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n다른 마이크로서비스와 통신하기 위해 <span class=\"hljs-title class_\">RabbitMQ</span>를 사용할 것입니다. 이는 서비스 간 비동기 메시징을 가능하게 하는 메시지 브로커입니다. <span class=\"hljs-title class_\">RabbitMQ</span> 서버와의 통신을 처리하기 위해 gateway/ 디렉토리에 rpc_client.<span class=\"hljs-property\">py</span> 파일을 생성할 것입니다.\n\n<span class=\"hljs-keyword\">import</span> pika\n<span class=\"hljs-keyword\">import</span> uuid\n<span class=\"hljs-keyword\">import</span> json\n<span class=\"hljs-keyword\">from</span> dotenv <span class=\"hljs-keyword\">import</span> load_dotenv\n<span class=\"hljs-keyword\">import</span> os\n\n# 환경 변수 로딩\n<span class=\"hljs-title function_\">load_dotenv</span>()\n<span class=\"hljs-variable constant_\">RABBITMQ_URL</span> = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"RABBITMQ_URL\"</span>)\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OcrRpcClient</span>(object):\n\n    def <span class=\"hljs-title function_\">__init__</span>(self):\n        self.<span class=\"hljs-property\">connection</span> = pika.<span class=\"hljs-title class_\">BlockingConnection</span>(\n            pika.<span class=\"hljs-title class_\">ConnectionParameters</span>(host=<span class=\"hljs-variable constant_\">RABBITMQ_URL</span>))\n\n        self.<span class=\"hljs-property\">channel</span> = self.<span class=\"hljs-property\">connection</span>.<span class=\"hljs-title function_\">channel</span>()\n\n        result = self.<span class=\"hljs-property\">channel</span>.<span class=\"hljs-title function_\">queue_declare</span>(queue=<span class=\"hljs-string\">''</span>, exclusive=<span class=\"hljs-title class_\">True</span>)\n        self.<span class=\"hljs-property\">callback_queue</span> = result.<span class=\"hljs-property\">method</span>.<span class=\"hljs-property\">queue</span>\n\n        self.<span class=\"hljs-property\">channel</span>.<span class=\"hljs-title function_\">basic_consume</span>(\n            queue=self.<span class=\"hljs-property\">callback_queue</span>,\n            on_message_callback=self.<span class=\"hljs-property\">on_response</span>,\n            auto_ack=<span class=\"hljs-title class_\">True</span>)\n\n    def <span class=\"hljs-title function_\">on_response</span>(self, ch, method, props, body):\n        <span class=\"hljs-keyword\">if</span> self.<span class=\"hljs-property\">corr_id</span> == props.<span class=\"hljs-property\">correlation_id</span>:\n            self.<span class=\"hljs-property\">response</span> = body\n\n    def <span class=\"hljs-title function_\">call</span>(self, message):\n        self.<span class=\"hljs-property\">response</span> = <span class=\"hljs-title class_\">None</span>\n        self.<span class=\"hljs-property\">corr_id</span> = <span class=\"hljs-title function_\">str</span>(uuid.<span class=\"hljs-title function_\">uuid4</span>())\n        self.<span class=\"hljs-property\">channel</span>.<span class=\"hljs-title function_\">basic_publish</span>(\n            exchange=<span class=\"hljs-string\">''</span>,\n            routing_key=<span class=\"hljs-string\">'ocr_service'</span>,\n            properties=pika.<span class=\"hljs-title class_\">BasicProperties</span>(\n                reply_to=self.<span class=\"hljs-property\">callback_queue</span>,\n                correlation_id=self.<span class=\"hljs-property\">corr_id</span>,\n            ),\n            body=json.<span class=\"hljs-title function_\">dumps</span>(message))\n        <span class=\"hljs-keyword\">while</span> self.<span class=\"hljs-property\">response</span> is <span class=\"hljs-title class_\">None</span>:\n            self.<span class=\"hljs-property\">connection</span>.<span class=\"hljs-title function_\">process_data_events</span>()\n        response_json = json.<span class=\"hljs-title function_\">loads</span>(self.<span class=\"hljs-property\">response</span>)\n        <span class=\"hljs-keyword\">return</span> response_json\n\n이 코드는 <span class=\"hljs-title class_\">RabbitMQ</span>를 사용하여 <span class=\"hljs-variable constant_\">OCR</span> 마이크로서비스(<span class=\"hljs-variable constant_\">ML</span> 마이크로서비스)로 메시지를 보내기 위한 클라이언트 클래스인 <span class=\"hljs-title class_\">OcrRpcClient</span>를 정의합니다. 연결을 초기화하고, 응답을 위한 콜백 큐를 설정하고, 메시지를 보내고 응답을 비동기적으로 받을 수 있는 방법을 제공합니다.\n\n- 초기화(__init__):\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-title class_\">RabbitMQ</span>에 연결을 설정합니다. 채널을 생성하고 고유한 콜백 큐를 선언합니다. 콜백 큐에서 응답을 수신하기 위해 소비자를 설정합니다.\n\n<span class=\"hljs-number\">2.</span> 요청 보내기 (호출):\n\n<span class=\"hljs-variable constant_\">OCR</span> 마이크로서비스(<span class=\"hljs-variable constant_\">ML</span> 마이크로서비스)에 메시지를 보냅니다. 콜백 큐에서 응답을 기다리고 반환합니다.\n\n이 클래스는 <span class=\"hljs-title class_\">RabbitMQ</span>를 사용하여 게이트웨이 서비스가 <span class=\"hljs-variable constant_\">OCR</span> 마이크로서비스와 효율적으로 통신할 수 있게 합니다.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n## C. <span class=\"hljs-title class_\">Auth</span> 마이크로서비스 구현\n\n이 코드는 <span class=\"hljs-title class_\">FastAPI</span>를 사용하여 사용자 등록, 로그인, <span class=\"hljs-variable constant_\">JWT</span> 토큰 생성, <span class=\"hljs-variable constant_\">OTP</span>를 사용한 이메일 확인 및 사용자 프로필 검색을 제공하는 인증 서비스를 구현합니다. 데이터베이스 작업에는 <span class=\"hljs-title class_\">SQLAlchemy</span>를 사용하고 <span class=\"hljs-variable constant_\">OTP</span> 이메일을 보내기 위해 <span class=\"hljs-title class_\">RabbitMQ</span>를 사용합니다. 이 서비스에는 사용자 생성, <span class=\"hljs-variable constant_\">JWT</span> 토큰 생성, 사용자 프로필 검색 및 이메일 확인을 위한 <span class=\"hljs-variable constant_\">OTP</span> 확인에 대한 엔드포인트가 포함되어 있습니다.\n\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">List</span>\n<span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">HTTPException</span> \n<span class=\"hljs-keyword\">import</span> fastapi <span class=\"hljs-keyword\">as</span> _fastapi\n<span class=\"hljs-keyword\">import</span> schemas <span class=\"hljs-keyword\">as</span> _schemas\n<span class=\"hljs-keyword\">import</span> sqlalchemy.<span class=\"hljs-property\">orm</span> <span class=\"hljs-keyword\">as</span> _orm\n<span class=\"hljs-keyword\">import</span> models <span class=\"hljs-keyword\">as</span> _models\n<span class=\"hljs-keyword\">import</span> service <span class=\"hljs-keyword\">as</span> _services\n<span class=\"hljs-keyword\">import</span> logging\n<span class=\"hljs-keyword\">import</span> database <span class=\"hljs-keyword\">as</span> _database\n<span class=\"hljs-keyword\">import</span> pika\n\n# rabbitmq connection\nconnection = pika.<span class=\"hljs-title class_\">BlockingConnection</span>(pika.<span class=\"hljs-title class_\">ConnectionParameters</span>(host=<span class=\"hljs-string\">\"localhost\"</span>))\nchannel = connection.<span class=\"hljs-title function_\">channel</span>()\nchannel.<span class=\"hljs-title function_\">queue_declare</span>(queue=<span class=\"hljs-string\">'email_notification'</span>)\n\ndef <span class=\"hljs-title function_\">get_db</span>():\n    db = _database.<span class=\"hljs-title class_\">SessionLocal</span>()\n    <span class=\"hljs-attr\">try</span>:\n        <span class=\"hljs-keyword\">yield</span> db\n    <span class=\"hljs-attr\">finally</span>:\n        db.<span class=\"hljs-title function_\">close</span>()\n\napp = _fastapi.<span class=\"hljs-title class_\">FastAPI</span>()\nlogging.<span class=\"hljs-title function_\">basicConfig</span>(level=logging.<span class=\"hljs-property\">INFO</span>)\n_models.<span class=\"hljs-property\">Base</span>.<span class=\"hljs-property\">metadata</span>.<span class=\"hljs-title function_\">create_all</span>(_models.<span class=\"hljs-property\">engine</span>)\n\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">\"/api/users\"</span>, tags=[<span class=\"hljs-string\">'사용자 인증'</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">create_user</span>(\n    <span class=\"hljs-attr\">user</span>: _schemas.<span class=\"hljs-property\">UserCreate</span>, \n    <span class=\"hljs-attr\">db</span>: _orm.<span class=\"hljs-property\">Session</span> = _fastapi.<span class=\"hljs-title class_\">Depends</span>(_services.<span class=\"hljs-property\">get_db</span>)):\n    db_user = <span class=\"hljs-keyword\">await</span> _services.<span class=\"hljs-title function_\">get_user_by_email</span>(email=user.<span class=\"hljs-property\">email</span>, db=db)\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-attr\">db_user</span>:\n        logging.<span class=\"hljs-title function_\">info</span>(<span class=\"hljs-string\">'해당 이메일로 이미 가입된 사용자가 있습니다'</span>)\n        raise _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(\n            status_code=<span class=\"hljs-number\">200</span>,\n            detail=<span class=\"hljs-string\">\"해당 이메일로 이미 가입된 사용자가 있습니다\"</span>)\n\n    user = <span class=\"hljs-keyword\">await</span> _services.<span class=\"hljs-title function_\">create_user</span>(user=user, db=db)\n\n    <span class=\"hljs-keyword\">return</span> _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(\n            status_code=<span class=\"hljs-number\">201</span>,\n            detail=<span class=\"hljs-string\">\"사용자 등록이 완료되었습니다. 계정을 활성화하려면 이메일을 확인하세요!\"</span>)\n\n# <span class=\"hljs-variable constant_\">API</span> 상태 확인 엔드포인트\n@app.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/check_api\"</span>)\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">check_api</span>():\n    <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-string\">\"status\"</span>: <span class=\"hljs-string\">\"API와 연결되었습니다\"</span>}\n\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">\"/api/token\"</span>, tags=[<span class=\"hljs-string\">'사용자 인증'</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">generate_token</span>(\n    <span class=\"hljs-attr\">user_data</span>: _schemas.<span class=\"hljs-property\">GenerateUserToken</span>,\n    <span class=\"hljs-attr\">db</span>: _orm.<span class=\"hljs-property\">Session</span> = _fastapi.<span class=\"hljs-title class_\">Depends</span>(_services.<span class=\"hljs-property\">get_db</span>)):\n    user = <span class=\"hljs-keyword\">await</span> _services.<span class=\"hljs-title function_\">authenticate_user</span>(email=user_data.<span class=\"hljs-property\">username</span>, password=user_data.<span class=\"hljs-property\">password</span>, db=db)\n\n    <span class=\"hljs-keyword\">if</span> user == <span class=\"hljs-string\">\"is_verified_false\"</span>:\n        logging.<span class=\"hljs-title function_\">info</span>(<span class=\"hljs-string\">'이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.'</span>)\n        raise _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(\n            status_code=<span class=\"hljs-number\">403</span>, detail=<span class=\"hljs-string\">\"이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.\"</span>)\n\n    <span class=\"hljs-keyword\">if</span> not <span class=\"hljs-attr\">user</span>:\n        logging.<span class=\"hljs-title function_\">info</span>(<span class=\"hljs-string\">'잘못된 자격 증명'</span>)\n        raise _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(\n            status_code=<span class=\"hljs-number\">401</span>, detail=<span class=\"hljs-string\">\"잘못된 자격 증명\"</span>)\n\n    logging.<span class=\"hljs-title function_\">info</span>(<span class=\"hljs-string\">'JWT 토큰이 생성되었습니다.'</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> _services.<span class=\"hljs-title function_\">create_token</span>(user=user)\n\n@app.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/api/users/me\"</span>, response_model=_schemas.<span class=\"hljs-property\">User</span>, tags=[<span class=\"hljs-string\">'사용자 인증'</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">get_user</span>(<span class=\"hljs-attr\">user</span>: _schemas.<span class=\"hljs-property\">User</span> = _fastapi.<span class=\"hljs-title class_\">Depends</span>(_services.<span class=\"hljs-property\">get_current_user</span>)):\n    <span class=\"hljs-keyword\">return</span> user\n\n@app.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/api/users/profile\"</span>, tags=[<span class=\"hljs-string\">'사용자 인증'</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">get_user</span>(<span class=\"hljs-attr\">email</span>: str, <span class=\"hljs-attr\">db</span>: _orm.<span class=\"hljs-property\">Session</span> = _fastapi.<span class=\"hljs-title class_\">Depends</span>(_services.<span class=\"hljs-property\">get_db</span>)):\n    <span class=\"hljs-keyword\">return</span> db.<span class=\"hljs-title function_\">query</span>(_models.<span class=\"hljs-property\">User</span> and _models.<span class=\"hljs-property\">Address</span>).<span class=\"hljs-title function_\">filter_by</span>(id=<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">first</span>()\n\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">\"/api/users/generate_otp\"</span>, response_model=str, tags=[<span class=\"hljs-string\">\"사용자 인증\"</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">send_otp_mail</span>(<span class=\"hljs-attr\">userdata</span>: _schemas.<span class=\"hljs-property\">GenerateOtp</span>, <span class=\"hljs-attr\">db</span>: _orm.<span class=\"hljs-property\">Session</span> = _fastapi.<span class=\"hljs-title class_\">Depends</span>(_services.<span class=\"hljs-property\">get_db</span>)):\n    user = <span class=\"hljs-keyword\">await</span> _services.<span class=\"hljs-title function_\">get_user_by_email</span>(email=userdata.<span class=\"hljs-property\">email</span>, db=db)\n\n    <span class=\"hljs-keyword\">if</span> not <span class=\"hljs-attr\">user</span>:\n        raise _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">404</span>, detail=<span class=\"hljs-string\">\"사용자를 찾을 수 없습니다\"</span>)\n\n    <span class=\"hljs-keyword\">if</span> user.<span class=\"hljs-property\">is_verified</span>:\n        raise _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">400</span>, detail=<span class=\"hljs-string\">\"이미 확인된 사용자입니다\"</span>)\n\n    # <span class=\"hljs-variable constant_\">OTP</span> 생성 및 전송\n    otp = _services.<span class=\"hljs-title function_\">generate_otp</span>()\n    <span class=\"hljs-title function_\">print</span>(otp)\n    _services.<span class=\"hljs-title function_\">send_otp</span>(userdata.<span class=\"hljs-property\">email</span>, otp, channel)\n\n    # <span class=\"hljs-variable constant_\">OTP</span>를 데이터베이스에 저장\n    user.<span class=\"hljs-property\">otp</span> = otp\n    db.<span class=\"hljs-title function_\">add</span>(user)\n    db.<span class=\"hljs-title function_\">commit</span>()\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"이메일로 OTP가 전송되었습니다\"</span>\n\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">\"/api/users/verify_otp\"</span>, tags=[<span class=\"hljs-string\">\"사용자 인증\"</span>])\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">verify_otp</span>(<span class=\"hljs-attr\">userdata</span>: _schemas.<span class=\"hljs-property\">VerifyOtp</span>, <span class=\"hljs-attr\">db</span>: _orm.<span class=\"hljs-property\">Session</span> = _fastapi.<span class=\"hljs-title class_\">Depends</span>(_services.<span class=\"hljs-property\">get_db</span>)):\n    user = <span class=\"hljs-keyword\">await</span> _services.<span class=\"hljs-title function_\">get_user_by_email</span>(email=userdata.<span class=\"hljs-property\">email</span>, db=db )\n\n    <span class=\"hljs-keyword\">if</span> not <span class=\"hljs-attr\">user</span>:\n        raise _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">404</span>, detail=<span class=\"hljs-string\">\"사용자를 찾을 수 없습니다\"</span>)\n\n    <span class=\"hljs-keyword\">if</span> not user.<span class=\"hljs-property\">otp</span> or user.<span class=\"hljs-property\">otp</span> != userdata.<span class=\"hljs-property\">otp</span>:\n        raise _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">400</span>, detail=<span class=\"hljs-string\">\"잘못된 OTP\"</span>)\n\n    # 사용자의 is_verified 필드 업데이트\n    user.<span class=\"hljs-property\">is_verified</span> = <span class=\"hljs-title class_\">True</span>\n    user.<span class=\"hljs-property\">otp</span> = <span class=\"hljs-title class_\">None</span>  # <span class=\"hljs-variable constant_\">OTP</span> 초기화\n    db.<span class=\"hljs-title function_\">add</span>(user)\n    db.<span class=\"hljs-title function_\">commit</span>()\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"이메일 확인이 성공적으로 완료되었습니다\"</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\"__main__\"</span>:\n    <span class=\"hljs-keyword\">import</span> uvicorn\n    uvicorn.<span class=\"hljs-title function_\">run</span>(<span class=\"hljs-string\">\"main:app\"</span>, host=<span class=\"hljs-string\">\"0.0.0.0\"</span>, port=<span class=\"hljs-number\">5000</span>, reload=<span class=\"hljs-title class_\">True</span>)\n\n이 코드는 <span class=\"hljs-title class_\">PostgreSQL</span> 데이터베이스에 연결하기 위해 <span class=\"hljs-title class_\">SQLAlchemy</span> 엔진과 세션 메이커를 설정합니다. dotenv를 사용하여 환경 변수에서 데이터베이스 연결 세부 정보를 로드합니다. <span class=\"hljs-variable constant_\">DATABASE_URL</span>은 호스트, 데이터베이스 이름, 사용자 이름 및 암호를 포함하여 검색된 환경 변수를 사용하여 구성됩니다. 데이터베이스 연결 세부를 사용하여 create_engine를 사용하여 엔진을 생성하고 해당 엔진에 바인딩된 세션 메이커인 <span class=\"hljs-title class_\">SessionLocal</span>을 정의합니다. <span class=\"hljs-variable constant_\">ORM</span> 모델을 정의하는 <span class=\"hljs-title class_\">Declarative</span> <span class=\"hljs-title class_\">Base</span>로 사용하기 위해 <span class=\"hljs-title class_\">Base</span> 변수가 초기화됩니다.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n<span class=\"hljs-keyword\">import</span> sqlalchemy <span class=\"hljs-keyword\">as</span> _sql\n<span class=\"hljs-keyword\">import</span> sqlalchemy.<span class=\"hljs-property\">ext</span>.<span class=\"hljs-property\">declarative</span> <span class=\"hljs-keyword\">as</span> _declarative\n<span class=\"hljs-keyword\">import</span> sqlalchemy.<span class=\"hljs-property\">orm</span> <span class=\"hljs-keyword\">as</span> _orm\n<span class=\"hljs-keyword\">from</span> dotenv <span class=\"hljs-keyword\">import</span> load_dotenv\n<span class=\"hljs-keyword\">import</span> os\n\n# .<span class=\"hljs-property\">env</span> 파일에서 환경 변수를 불러옵니다\n<span class=\"hljs-title function_\">load_dotenv</span>()\n\n# 환경 변수를 가져옵니다\npostgres_host = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"POSTGRES_HOST\"</span>)\npostgres_db = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"POSTGRES_DB\"</span>)\npostgres_user = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"POSTGRES_USER\"</span>)\npostgres_password = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"POSTGRES_PASSWORD\"</span>)\n\n# <span class=\"hljs-title class_\">PostgreSQL</span> 서버가 로컬에서 실행 중이라고 가정하고 <span class=\"hljs-string\">'mydatabase'</span>라는 이름의 데이터베이스가 있다고 가정합니다\n<span class=\"hljs-variable constant_\">DATABASE_URL</span> = f<span class=\"hljs-string\">\"postgresql://{postgres_user}:{postgres_password}@{postgres_host}/{postgres_db}\"</span>\n\nengine = _sql.<span class=\"hljs-title function_\">create_engine</span>(<span class=\"hljs-variable constant_\">DATABASE_URL</span>)\n<span class=\"hljs-title class_\">SessionLocal</span> = _orm.<span class=\"hljs-title function_\">sessionmaker</span>(autocommit=<span class=\"hljs-title class_\">False</span>, autoflush=<span class=\"hljs-title class_\">False</span>, bind=engine)\n<span class=\"hljs-title class_\">Base</span> = _declarative.<span class=\"hljs-title function_\">declarative_base</span>()\r\n\n이 코드는 사용자 및 주소 테이블에 대한 <span class=\"hljs-title class_\">SQLAlchemy</span> 모델을 정의하며, 사용자 정보 및 주소를 저장하고 이들 사이의 관계를 설정합니다. 또한 제공된 엔진을 사용하여 데이터베이스에 테이블을 생성합니다.\n\n<span class=\"hljs-keyword\">import</span> datetime <span class=\"hljs-keyword\">as</span> _dt\n<span class=\"hljs-keyword\">import</span> sqlalchemy <span class=\"hljs-keyword\">as</span> _sql\n<span class=\"hljs-keyword\">import</span> sqlalchemy.<span class=\"hljs-property\">orm</span> <span class=\"hljs-keyword\">as</span> _orm\n<span class=\"hljs-keyword\">import</span> passlib.<span class=\"hljs-property\">hash</span> <span class=\"hljs-keyword\">as</span> _hash\n<span class=\"hljs-keyword\">from</span> database <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Base</span>, engine\n<span class=\"hljs-keyword\">import</span> database <span class=\"hljs-keyword\">as</span> _database\n\n<span class=\"hljs-title class_\">Base</span>.<span class=\"hljs-property\">metadata</span>.<span class=\"hljs-title function_\">create_all</span>(engine)\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span>(_database.<span class=\"hljs-property\">Base</span>):\n    __tablename__ = <span class=\"hljs-string\">\"users\"</span>\n    id = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">Integer</span>, primary_key=<span class=\"hljs-title class_\">True</span>, index=<span class=\"hljs-title class_\">True</span>)\n    name = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">String</span>)\n    email = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">String</span>, unique=<span class=\"hljs-title class_\">True</span>, index=<span class=\"hljs-title class_\">True</span>)\n    is_verified = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">Boolean</span>, <span class=\"hljs-keyword\">default</span>=<span class=\"hljs-title class_\">False</span>)\n    otp = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">Integer</span>)\n    hashed_password = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">String</span>)\n    addresses = _orm.<span class=\"hljs-title function_\">relationship</span>(<span class=\"hljs-string\">\"Address\"</span>, back_populates=<span class=\"hljs-string\">\"user\"</span>)\n    date_created = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">DateTime</span>, <span class=\"hljs-keyword\">default</span>=_dt.<span class=\"hljs-property\">datetime</span>.<span class=\"hljs-property\">utcnow</span>)\n\n    def <span class=\"hljs-title function_\">verify_password</span>(self, <span class=\"hljs-attr\">password</span>: str):\n        <span class=\"hljs-keyword\">return</span> _hash.<span class=\"hljs-property\">bcrypt</span>.<span class=\"hljs-title function_\">verify</span>(password, self.<span class=\"hljs-property\">hashed_password</span>)\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Address</span>(_database.<span class=\"hljs-property\">Base</span>):\n    __tablename__ = <span class=\"hljs-string\">\"addresses\"</span>\n    id = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">Integer</span>, primary_key=<span class=\"hljs-title class_\">True</span>, index=<span class=\"hljs-title class_\">True</span>)\n    street = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">String</span>)\n    landmark = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">String</span>)\n    city = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">String</span>)\n    country = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">String</span>)\n    pincode = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">String</span>)\n    user_id = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">Integer</span>, _sql.<span class=\"hljs-title class_\">ForeignKey</span>(<span class=\"hljs-string\">\"users.id\"</span>))\n    user = _orm.<span class=\"hljs-title function_\">relationship</span>(<span class=\"hljs-string\">\"User\"</span>, back_populates=<span class=\"hljs-string\">\"addresses\"</span>)\n    latitude = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">Float</span>)\n    longitude = _sql.<span class=\"hljs-title class_\">Column</span>(_sql.<span class=\"hljs-property\">Float</span>)\r\n\n이 코드는 사용자 관련 데이터 구조에 대한 <span class=\"hljs-title class_\">Pydantic</span> 모델을 정의하며, 사용자 생성, 인증 및 <span class=\"hljs-variable constant_\">OTP</span> 확인용입니다. 위치 정보를 위한 주소 모델도 포함되어 있습니다. 이 모델들은 사전 속성으로부터 인스턴스를 자동으로 생성하도록 구성되어 있습니다.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n이 코드는 사용자 인증 및 <span class=\"hljs-title function_\">OTP</span>(일회용 비밀번호) 생성 및 확인을 위한 다양한 함수 및 종속성을 정의합니다. <span class=\"hljs-variable constant_\">HTTP</span> 요청을 처리하기 위해 <span class=\"hljs-title class_\">FastAPI</span>를 사용하며, 데이터베이스 작업을 위해 <span class=\"hljs-title class_\">SQLAlchemy</span>를 사용하고 데이터 유효성 검사 및 직렬화를 위해 <span class=\"hljs-title class_\">Pydantic</span>을 사용하며, 인증을 위해 <span class=\"hljs-variable constant_\">JWT</span>를 사용하고, 이메일 알림을 보내기 위해 <span class=\"hljs-title class_\">RabbitMQ</span>를 사용합니다. 이 함수들은 데이터베이스 생성, 데이터베이스 세션 가져오기, 새 사용자 생성, 사용자 인증, <span class=\"hljs-variable constant_\">JWT</span> 토큰 생성, <span class=\"hljs-variable constant_\">JWT</span> 토큰에서 현재 사용자 가져오기, 무작위 <span class=\"hljs-variable constant_\">OTP</span> 생성, <span class=\"hljs-title class_\">RabbitMQ</span>에 연결 및 <span class=\"hljs-variable constant_\">OTP</span> 이메일 알림 전송 등이 포함됩니다.\n\n환경 변수 로드\n\n<span class=\"hljs-variable constant_\">JWT_SECRET</span> = os.<span class=\"hljs-title function_\">getenv</span>(<span class=\"hljs-string\">\"JWT_SECRET\"</span>)\n<span class=\"hljs-variable constant_\">RABBITMQ_URL</span> = os.<span class=\"hljs-title function_\">getenv</span>(<span class=\"hljs-string\">\"RABBITMQ_URL\"</span>)\noauth2schema = _security.<span class=\"hljs-title class_\">OAuth2PasswordBearer</span>(<span class=\"hljs-string\">\"/api/token\"</span>)\n\n데이터베이스 생성\n\ndef <span class=\"hljs-title function_\">create_database</span>():\n    # 데이터베이스 테이블 생성\n    <span class=\"hljs-keyword\">return</span> _database.<span class=\"hljs-property\">Base</span>.<span class=\"hljs-property\">metadata</span>.<span class=\"hljs-title function_\">create_all</span>(bind=_database.<span class=\"hljs-property\">engine</span>)\n\n데이터베이스 세션 가져오기\n\ndef <span class=\"hljs-title function_\">get_db</span>():\n    # 데이터베이스 세션을 얻는 의존성\n    db = _database.<span class=\"hljs-title class_\">SessionLocal</span>()\n    <span class=\"hljs-attr\">try</span>:\n        <span class=\"hljs-keyword\">yield</span> db\n    <span class=\"hljs-attr\">finally</span>:\n        db.<span class=\"hljs-title function_\">close</span>()\n\n이메일별 사용자 가져오기\n\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">get_user_by_email</span>(<span class=\"hljs-attr\">email</span>: str, <span class=\"hljs-attr\">db</span>: _orm.<span class=\"hljs-property\">Session</span>):\n    # 데이터베이스에서 이메일별로 사용자 검색\n    <span class=\"hljs-keyword\">return</span> db.<span class=\"hljs-title function_\">query</span>(_models.<span class=\"hljs-property\">User</span>).<span class=\"hljs-title function_\">filter</span>(_models.<span class=\"hljs-property\">User</span>.<span class=\"hljs-property\">email</span> == email and _models.<span class=\"hljs-property\">User</span>.<span class=\"hljs-property\">is_verified</span> == <span class=\"hljs-title class_\">True</span>).<span class=\"hljs-title function_\">first</span>()\n\n새 사용자 생성\n\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">create_user</span>(<span class=\"hljs-attr\">user</span>: _schemas.<span class=\"hljs-property\">UserCreate</span>, <span class=\"hljs-attr\">db</span>: _orm.<span class=\"hljs-property\">Session</span>):\n    # 데이터베이스에 새 사용자 생성\n    <span class=\"hljs-attr\">try</span>:\n        valid = _email_check.<span class=\"hljs-title function_\">validate_email</span>(user.<span class=\"hljs-property\">email</span>)\n        name = user.<span class=\"hljs-property\">name</span>\n        email = valid.<span class=\"hljs-property\">email</span>\n    except _email_check.<span class=\"hljs-property\">EmailNotValidError</span>:\n        raise _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">404</span>, detail=<span class=\"hljs-string\">\"정확한 이메일을 입력하세요\"</span>)\n\n    user_obj = _models.<span class=\"hljs-title class_\">User</span>(email=email, name=name, hashed_password=_hash.<span class=\"hljs-property\">bcrypt</span>.<span class=\"hljs-title function_\">hash</span>(user.<span class=\"hljs-property\">password</span>))\n    db.<span class=\"hljs-title function_\">add</span>(user_obj)\n    db.<span class=\"hljs-title function_\">commit</span>()\n    db.<span class=\"hljs-title function_\">refresh</span>(user_obj)\n    <span class=\"hljs-keyword\">return</span> user_obj\n\n사용자 인증\n\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">authenticate_user</span>(<span class=\"hljs-attr\">email</span>: str, <span class=\"hljs-attr\">password</span>: str, <span class=\"hljs-attr\">db</span>: _orm.<span class=\"hljs-property\">Session</span>):\n    # 사용자 인증\n    user = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">get_user_by_email</span>(email=email, db=db)\n\n    <span class=\"hljs-keyword\">if</span> not <span class=\"hljs-attr\">user</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">False</span>\n    \n    <span class=\"hljs-keyword\">if</span> not user.<span class=\"hljs-property\">is_verified</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'is_verified_false'</span>\n    \n    <span class=\"hljs-keyword\">if</span> not user.<span class=\"hljs-title function_\">verify_password</span>(password):\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">False</span>\n\n    <span class=\"hljs-keyword\">return</span> user\n\n<span class=\"hljs-variable constant_\">JWT</span> 토큰 생성\n\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">create_token</span>(<span class=\"hljs-attr\">user</span>: _models.<span class=\"hljs-property\">User</span>):\n    # 인증을 위한 <span class=\"hljs-variable constant_\">JWT</span> 토큰 생성\n    user_obj = _schemas.<span class=\"hljs-property\">User</span>.<span class=\"hljs-title function_\">from_orm</span>(user)\n    user_dict = user_obj.<span class=\"hljs-title function_\">model_dump</span>()\n    del user_dict[<span class=\"hljs-string\">\"date_created\"</span>]\n    token = jwt.<span class=\"hljs-title function_\">encode</span>(user_dict, <span class=\"hljs-variable constant_\">JWT_SECRET</span>, algorithm=<span class=\"hljs-string\">\"HS256\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">dict</span>(access_token=token, token_type=<span class=\"hljs-string\">\"bearer\"</span>)\n\n현재 사용자 가져오기\n\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">get_current_user</span>(<span class=\"hljs-attr\">db</span>: _orm.<span class=\"hljs-property\">Session</span> = _fastapi.<span class=\"hljs-title class_\">Depends</span>(get_db), <span class=\"hljs-attr\">token</span>: str = _fastapi.<span class=\"hljs-title class_\">Depends</span>(oauth2schema)):\n    # <span class=\"hljs-variable constant_\">JWT</span> 토큰에서 현재 인증된 사용자 가져오기\n    <span class=\"hljs-attr\">try</span>:\n        payload = jwt.<span class=\"hljs-title function_\">decode</span>(token, <span class=\"hljs-variable constant_\">JWT_SECRET</span>, algorithms=[<span class=\"hljs-string\">\"HS256\"</span>])\n        user = db.<span class=\"hljs-title function_\">query</span>(_models.<span class=\"hljs-property\">User</span>).<span class=\"hljs-title function_\">get</span>(payload[<span class=\"hljs-string\">\"id\"</span>])\n    <span class=\"hljs-attr\">except</span>:\n        raise _fastapi.<span class=\"hljs-title class_\">HTTPException</span>(status_code=<span class=\"hljs-number\">401</span>, detail=<span class=\"hljs-string\">\"유효하지 않은 이메일 또는 비밀번호\"</span>)\n    <span class=\"hljs-keyword\">return</span> _schemas.<span class=\"hljs-property\">User</span>.<span class=\"hljs-title function_\">from_orm</span>(user)\n\n랜덤 <span class=\"hljs-variable constant_\">OTP</span> 생성\n\ndef <span class=\"hljs-title function_\">generate_otp</span>():\n    # 랜덤 <span class=\"hljs-variable constant_\">OTP</span> 생성\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">str</span>(random.<span class=\"hljs-title function_\">randint</span>(<span class=\"hljs-number\">100000</span>, <span class=\"hljs-number\">999999</span>))\n\n<span class=\"hljs-title class_\">RabbitMQ</span>에 연결\n\ndef <span class=\"hljs-title function_\">connect_to_rabbitmq</span>():\n    # <span class=\"hljs-title class_\">RabbitMQ</span>에 연결\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-title class_\">True</span>:\n        <span class=\"hljs-attr\">try</span>:\n            connection = pika.<span class=\"hljs-title class_\">BlockingConnection</span>(pika.<span class=\"hljs-title class_\">ConnectionParameters</span>(<span class=\"hljs-variable constant_\">RABBITMQ_URL</span>))\n            <span class=\"hljs-keyword\">return</span> connection\n        except pika.<span class=\"hljs-property\">exceptions</span>.<span class=\"hljs-property\">AMQPConnectionError</span>:\n            <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"RabbitMQ에 연결하지 못했습니다. 5초 후 다시 시도 중...\"</span>)\n            time.<span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">5</span>)\n\n<span class=\"hljs-variable constant_\">OTP</span> 이메일 알림 전송\n\ndef <span class=\"hljs-title function_\">send_otp</span>(email, otp, channel):\n    # <span class=\"hljs-title class_\">RabbitMQ</span>를 사용하여 <span class=\"hljs-variable constant_\">OTP</span> 이메일 알림 전송\n    connection = <span class=\"hljs-title function_\">connect_to_rabbitmq</span>()\n    channel = connection.<span class=\"hljs-title function_\">channel</span>()\n    message = {<span class=\"hljs-string\">'email'</span>: email,\n               <span class=\"hljs-string\">'subject'</span>: <span class=\"hljs-string\">'계정 확인 OTP 알림'</span>,\n               <span class=\"hljs-string\">'other'</span>: <span class=\"hljs-string\">'null'</span>,\n               <span class=\"hljs-string\">'body'</span>: f<span class=\"hljs-string\">'계정 확인을 위한 OTP는 다음과 같습니다: {otp} \\n 계정 설정을 완료하려면 확인 페이지에 이 OTP를 입력하세요. \\n 이 OTP를 요청하지 않았다면 이 메시지를 무시해주세요.\\n 감사합니다 '</span>\n               }\n\n    <span class=\"hljs-attr\">try</span>:\n        queue_declare_ok = channel.<span class=\"hljs-title function_\">queue_declare</span>(queue=<span class=\"hljs-string\">'email_notification'</span>, passive=<span class=\"hljs-title class_\">True</span>)\n        current_durable = queue_declare_ok.<span class=\"hljs-property\">method</span>.<span class=\"hljs-property\">queue</span>\n\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-attr\">current_durable</span>:\n            <span class=\"hljs-keyword\">if</span> queue_declare_ok.<span class=\"hljs-property\">method</span>.<span class=\"hljs-property\">queue</span> != <span class=\"hljs-attr\">current_durable</span>:\n                channel.<span class=\"hljs-title function_\">queue_delete</span>(queue=<span class=\"hljs-string\">'email_notification'</span>)\n                channel.<span class=\"hljs-title function_\">queue_declare</span>(queue=<span class=\"hljs-string\">'email_notification'</span>, durable=<span class=\"hljs-title class_\">True</span>)\n        <span class=\"hljs-attr\">else</span>:\n            channel.<span class=\"hljs-title function_\">queue_declare</span>(queue=<span class=\"hljs-string\">'email_notification'</span>, durable=<span class=\"hljs-title class_\">True</span>)\n\n        channel.<span class=\"hljs-title function_\">basic_publish</span>(\n            exchange=<span class=\"hljs-string\">\"\"</span>,\n            routing_key=<span class=\"hljs-string\">'email_notification'</span>,\n            body=json.<span class=\"hljs-title function_\">dumps</span>(message),\n            properties=pika.<span class=\"hljs-title class_\">BasicProperties</span>(\n                delivery_mode=pika.<span class=\"hljs-property\">spec</span>.<span class=\"hljs-property\">PERSISTENT_DELIVERY_MODE</span>\n            ),\n        )\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"OTP 이메일 알림 전송 완료\"</span>)\n    except <span class=\"hljs-title class_\">Exception</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">err</span>:\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"메시지 전송 실패: {err}\"</span>)\n    <span class=\"hljs-attr\">finally</span>:\n        channel.<span class=\"hljs-title function_\">close</span>()\n        connection.<span class=\"hljs-title function_\">close</span>()\n\n## D. 머신 러닝 마이크로서비스 구현\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n이 <span class=\"hljs-title class_\">Python</span> 스크립트는 <span class=\"hljs-title class_\">RabbitMQ</span> 서버에 연결하여 <span class=\"hljs-string\">'ocr_service'</span>라는 큐에서 메시지를 소비합니다. 메시지를받으면 <span class=\"hljs-title class_\">OCRService</span> 객체를 사용하여 처리하고 send_email_notification 함수를 사용하여 이메일 알림을 보내며, 그런 다음 응답을 응답 큐에 발행합니다. 각 메시지를 처리한 후 <span class=\"hljs-title class_\">RabbitMQ</span>에 메시지 전달을 인식합니다. 스크립트는 <span class=\"hljs-title class_\">RabbitMQ</span>가 전달할 수 있는 미인증 메시지의 수를 제한하는 prefetch count <span class=\"hljs-number\">1</span>을 사용합니다.\n\n<span class=\"hljs-keyword\">import</span> pika\n<span class=\"hljs-keyword\">import</span> json\n<span class=\"hljs-keyword\">from</span> utils <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">OCRService</span>\n<span class=\"hljs-keyword\">from</span> utils <span class=\"hljs-keyword\">import</span> send_email_notification\n\n# <span class=\"hljs-title class_\">RabbitMQ</span>에 연결\nconnection = pika.<span class=\"hljs-title class_\">BlockingConnection</span>(pika.<span class=\"hljs-title class_\">ConnectionParameters</span>(host=<span class=\"hljs-string\">'localhost'</span>))\nchannel = connection.<span class=\"hljs-title function_\">channel</span>()\nchannel.<span class=\"hljs-title function_\">queue_declare</span>(queue=<span class=\"hljs-string\">'ocr_service'</span>)\n\n# <span class=\"hljs-variable constant_\">OCR</span> 요청을 처리하기 위한 콜백 함수\ndef <span class=\"hljs-title function_\">on_request</span>(ch, method, props, body):\n    # <span class=\"hljs-variable constant_\">OCR</span> 서비스 초기화\n    ocr_service = <span class=\"hljs-title class_\">OCRService</span>()\n    # <span class=\"hljs-variable constant_\">OCR</span> 요청 처리\n    response = ocr_service.<span class=\"hljs-title function_\">process_request</span>(body)\n\n    # 이메일 알림 전송\n    <span class=\"hljs-title function_\">send_email_notification</span>(response[<span class=\"hljs-string\">'user_email'</span>], response[<span class=\"hljs-string\">'ocr_text'</span>], channel)\n\n    # 응답을 응답 큐에 발행\n    ch.<span class=\"hljs-title function_\">basic_publish</span>(exchange=<span class=\"hljs-string\">''</span>,\n                     routing_key=props.<span class=\"hljs-property\">reply_to</span>,\n                     properties=pika.<span class=\"hljs-title class_\">BasicProperties</span>(correlation_id = \\\n                                                         props.<span class=\"hljs-property\">correlation_id</span>),\n                     body=json.<span class=\"hljs-title function_\">dumps</span>(response))\n    # 메시지 전달을 인식\n    ch.<span class=\"hljs-title function_\">basic_ack</span>(delivery_tag=method.<span class=\"hljs-property\">delivery_tag</span>)\n# prefetch count를 <span class=\"hljs-number\">1</span>로 설정\nchannel.<span class=\"hljs-title function_\">basic_qos</span>(prefetch_count=<span class=\"hljs-number\">1</span>)\n# <span class=\"hljs-string\">'ocr_service'</span> 큐에서 메시지 수신\nchannel.<span class=\"hljs-title function_\">basic_consume</span>(queue=<span class=\"hljs-string\">'ocr_service'</span>, on_message_callback=on_request)\n# 메시지 수신 시작\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\" [x] RPC 요청 대기중\"</span>)\nchannel.<span class=\"hljs-title function_\">start_consuming</span>()\r\n\n<span class=\"hljs-keyword\">import</span> json\n<span class=\"hljs-keyword\">import</span> base64\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n#keras ocr pipeline and imports\n<span class=\"hljs-keyword\">import</span> keras_ocr\n<span class=\"hljs-keyword\">import</span> pika\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OCRService</span>:\n   \n    def <span class=\"hljs-title function_\">__init__</span>(self):\n        self.<span class=\"hljs-property\">keras_pipeline</span> = keras_ocr.<span class=\"hljs-property\">pipeline</span>.<span class=\"hljs-title class_\">Pipeline</span>()\n\n    def <span class=\"hljs-title function_\">keras_ocr</span>(self, image_path):\n        results = self.<span class=\"hljs-property\">keras_pipeline</span>.<span class=\"hljs-title function_\">recognize</span>([image_path])\n        df = pd.<span class=\"hljs-title class_\">DataFrame</span>(results[<span class=\"hljs-number\">0</span>], columns=[<span class=\"hljs-string\">'text'</span>, <span class=\"hljs-string\">'bbox'</span>])\n        words = df[<span class=\"hljs-string\">'text'</span>].<span class=\"hljs-title function_\">tolist</span>()\n        sentence = <span class=\"hljs-string\">' '</span>.<span class=\"hljs-title function_\">join</span>(words)\n        <span class=\"hljs-keyword\">return</span> sentence\n\n    def <span class=\"hljs-title function_\">process_request</span>(self, message):\n        message_body = json.<span class=\"hljs-title function_\">loads</span>(message)\n        user_name = message_body[<span class=\"hljs-string\">'user_name'</span>]\n        user_email = message_body[<span class=\"hljs-string\">'user_email'</span>]\n        user_id = message_body[<span class=\"hljs-string\">'user_id'</span>]\n        file_base64 = message_body[<span class=\"hljs-string\">'file'</span>]\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\" [x]user_id: {user_id} request recieved from gateway..\"</span>)\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\" [x]processing request for {user_name}\"</span>)\n\n        # file_base64에 base64로 인코딩된 문자열이 포함되어 있다고 가정\n        file_data = base64.<span class=\"hljs-title function_\">b64decode</span>(file_base64.<span class=\"hljs-title function_\">encode</span>())\n        # 디코드된 파일 데이터를 새 파일에 작성\n        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'artifacts/decoded_file.png'</span>, <span class=\"hljs-string\">'wb'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">f</span>:\n            f.<span class=\"hljs-title function_\">write</span>(file_data)\n\n        image_path = <span class=\"hljs-string\">\"artifacts/decoded_file.png\"</span>\n        ocr_text = self.<span class=\"hljs-title function_\">keras_ocr</span>(image_path)\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\" [^] OCR 처리 완료 !!!\"</span>)\n\n        response = {\n            <span class=\"hljs-string\">\"user_id\"</span>: user_id,\n            <span class=\"hljs-string\">\"user_name\"</span>: user_name,\n            <span class=\"hljs-string\">\"user_email\"</span>: user_email,\n            <span class=\"hljs-string\">\"ocr_text\"</span>: ocr_text\n        }\n\n        <span class=\"hljs-keyword\">return</span> response\n\ndef <span class=\"hljs-title function_\">send_email_notification</span>(email, ocr_text, channel):\n    # <span class=\"hljs-title class_\">RabbitMQ</span>를 사용하여 이메일 알림 전송\n    message = {\n        <span class=\"hljs-string\">'email'</span>: email,\n        <span class=\"hljs-string\">'subject'</span>:<span class=\"hljs-string\">'OCR 처리 완료 !!'</span>,\n        <span class=\"hljs-string\">'body'</span>:f<span class=\"hljs-string\">'이미지에 대한 OCR (광학 문자 인식) 프로세스가 성공적으로 완료되었음을 알려드립니다.\\n 추출된 텍스트가 처리되어 사용할 준비가되었습니다.\\n\\n  OCR 텍스트 : {ocr_text}'</span>,\n        <span class=\"hljs-string\">'other'</span>: <span class=\"hljs-string\">'null'</span>,\n       }\n\n    <span class=\"hljs-attr\">try</span>:\n        channel.<span class=\"hljs-title function_\">basic_publish</span>(\n            exchange=<span class=\"hljs-string\">\"\"</span>,\n            routing_key=<span class=\"hljs-string\">'email_notification'</span>,\n            body=json.<span class=\"hljs-title function_\">dumps</span>(message),\n            properties=pika.<span class=\"hljs-title class_\">BasicProperties</span>(\n                delivery_mode=pika.<span class=\"hljs-property\">spec</span>.<span class=\"hljs-property\">PERSISTENT_DELIVERY_MODE</span>\n            ),\n        )\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"OCR 처리 완료 이메일 알림 전송됨\"</span>)\n    except <span class=\"hljs-title class_\">Exception</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">err</span>:\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"메시지 게시 실패: {err}\"</span>)\r\n\n## D. 알림 마이크로서비스 구현\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n이 스크립트는 <span class=\"hljs-string\">\"email_notification\"</span> 큐에서 메시지를 수신하는 <span class=\"hljs-title class_\">RabbitMQ</span> 소비자를 설정합니다. 메시지를 받으면 email_service 모듈의 notification 함수를 호출하여 알림 프로세스를 처리합니다. 성공하면 메시지를 확인하고, 그렇지 않으면 메시지를 거부하고 오류 메시지를 출력합니다.\n\n<span class=\"hljs-keyword\">import</span> pika\n<span class=\"hljs-keyword\">import</span> sys\n<span class=\"hljs-keyword\">import</span> os\n<span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-keyword\">import</span> email_service\n<span class=\"hljs-keyword\">from</span> dotenv <span class=\"hljs-keyword\">import</span> load_dotenv\n\n# 환경 변수 로드\n<span class=\"hljs-title function_\">load_dotenv</span>()\n<span class=\"hljs-variable constant_\">RABBITMQ_URL</span> = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"RABBITMQ_URL\"</span>)\n\ndef <span class=\"hljs-title function_\">main</span>():\n    # rabbitmq 연결\n    connection = pika.<span class=\"hljs-title class_\">BlockingConnection</span>(pika.<span class=\"hljs-title class_\">ConnectionParameters</span>(host=<span class=\"hljs-variable constant_\">RABBITMQ_URL</span>))\n    channel = connection.<span class=\"hljs-title function_\">channel</span>()\n\n    def <span class=\"hljs-title function_\">callback</span>(ch, method, properties, body):\n        <span class=\"hljs-attr\">try</span>:\n            err = email_service.<span class=\"hljs-title function_\">notification</span>(body)\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-attr\">err</span>:\n                ch.<span class=\"hljs-title function_\">basic_nack</span>(delivery_tag=method.<span class=\"hljs-property\">delivery_tag</span>)\n            <span class=\"hljs-attr\">else</span>:\n                ch.<span class=\"hljs-title function_\">basic_ack</span>(delivery_tag=method.<span class=\"hljs-property\">delivery_tag</span>)\n        except <span class=\"hljs-title class_\">Exception</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">e</span>:\n            <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"메시지 처리 중 오류 발생: {e}\"</span>)\n            ch.<span class=\"hljs-title function_\">basic_nack</span>(delivery_tag=method.<span class=\"hljs-property\">delivery_tag</span>)\n\n    channel.<span class=\"hljs-title function_\">basic_consume</span>(\n        queue=<span class=\"hljs-string\">\"email_notification\"</span>, on_message_callback=callback\n    )\n\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"메시지 수신 대기 중. 종료하려면 CTRL+C를 누르세요\"</span>)\n\n    channel.<span class=\"hljs-title function_\">start_consuming</span>()\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\"__main__\"</span>:\n    <span class=\"hljs-attr\">try</span>:\n        <span class=\"hljs-title function_\">main</span>()\n    except <span class=\"hljs-title class_\">KeyboardInterrupt</span>:\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"중단됨\"</span>)\n        <span class=\"hljs-attr\">try</span>:\n            sys.<span class=\"hljs-title function_\">exit</span>(<span class=\"hljs-number\">0</span>)\n        except <span class=\"hljs-title class_\">SystemExit</span>:\n            os.<span class=\"hljs-title function_\">_exit</span>(<span class=\"hljs-number\">0</span>)\n\n<span class=\"hljs-keyword\">import</span> smtplib, os, json\n<span class=\"hljs-keyword\">from</span> email.<span class=\"hljs-property\">message</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">EmailMessage</span>\n<span class=\"hljs-keyword\">from</span> dotenv <span class=\"hljs-keyword\">import</span> load_dotenv\n<span class=\"hljs-keyword\">from</span> email.<span class=\"hljs-property\">mime</span>.<span class=\"hljs-property\">text</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">MIMEText</span>\n\n<span class=\"hljs-title function_\">load_dotenv</span>()\n\ndef <span class=\"hljs-title function_\">notification</span>(message):\n    <span class=\"hljs-attr\">try</span>:\n        message = json.<span class=\"hljs-title function_\">loads</span>(message)\n        receiver_address = message[<span class=\"hljs-string\">\"email\"</span>]\n        subject = message[<span class=\"hljs-string\">\"subject\"</span>]\n        body = message[<span class=\"hljs-string\">\"body\"</span>]\n        other = message[<span class=\"hljs-string\">\"other\"</span>]\n\n        sender_address = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"GMAIL_ADDRESS\"</span>)\n        sender_password = os.<span class=\"hljs-property\">environ</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"GMAIL_PASSWORD\"</span>)\n\n        # <span class=\"hljs-title class_\">Gmail</span> <span class=\"hljs-variable constant_\">SMTP</span> 서버 설정\n        smtp_server = <span class=\"hljs-string\">'smtp.gmail.com'</span>\n        smtp_port = <span class=\"hljs-number\">587</span>\n\n        server = smtplib.<span class=\"hljs-title function_\">SMTP</span>(smtp_server, smtp_port)\n        server.<span class=\"hljs-title function_\">starttls</span>()\n        server.<span class=\"hljs-title function_\">login</span>(sender_address, sender_password)\n\n        # 이메일 메시지 작성\n        msg = <span class=\"hljs-title class_\">MIMEText</span>(body)\n        msg[<span class=\"hljs-string\">'Subject'</span>] = subject\n        msg[<span class=\"hljs-string\">'From'</span>] = sender_address\n        msg[<span class=\"hljs-string\">'To'</span>] = receiver_address\n\n        server.<span class=\"hljs-title function_\">sendmail</span>(sender_address, receiver_address, msg.<span class=\"hljs-title function_\">as_string</span>())\n        server.<span class=\"hljs-title function_\">quit</span>()\n\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"이메일 발송 완료\"</span>)\n    except <span class=\"hljs-title class_\">Exception</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">e</span>:\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"이메일 발송 실패: {e}\"</span>)\n\n# 애플리케이션 데모\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n# 결론\n\n마지막으로, <span class=\"hljs-title class_\">FastAPI</span>와 <span class=\"hljs-title class_\">RabbitMQ</span>를 사용하여 엔드 투 엔드 마이크로서비스 아키텍처를 성공적으로 구현했습니다. 사용자 인증 서비스, <span class=\"hljs-variable constant_\">OCR</span> 처리를 위한 머신 러닝 서비스 및 이메일 알림을 위한 알림 서비스를 어떻게 만드는지 보여드렸습니다.\n\n이 블로그를 통해 서비스 격리, 메시징 큐를 통한 통신, 확장성 및 성능을 위한 비동기 처리의 장점과 같은 마이크로서비스의 주요 개념에 대해 배웠습니다.\n\n프로젝트를 실행하려면 <span class=\"hljs-title class_\">GitHub</span> 저장소의 <span class=\"hljs-variable constant_\">README</span> 파일에 있는 지침을 따르세요. 읽어 주셔서 감사합니다. 이 프로젝트가 여러분께 영감을 주어 직접 마이크로서비스 아키텍처를 탐구하고 구현하는 데 도움이 되기를 바랍니다.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n깃허브: [<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//github.com/shantanu1905/fastapi-microservice-demo](https://github.com/shantanu1905/fastapi-microservice-demo)</span>\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}