{"pageProps":{"post":{"title":"Nodejs와 Expressjs로 간단하게 구현하는 Keycloak RBAC 방법","description":"","date":"2024-06-23 13:24","slug":"2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs","content":"\n\n안녕하세요!\n\n오늘은 Node.js 및 Express.js API에 대한 간단한 역할 기반 액세스 제어 (RBAC)를 구축하는 방법을 알아볼 것입니다. 이를 위해 인증을 위해 Keycloak을 사용할 것입니다.\n\nKeycloak 인증을 통해 Node + Express API를 안전하게 보호하는 해결책을 찾던 중 Keycloak Node.js 어댑터인 keycloak-connect를 만났습니다. 이 어댑터는 모든 요청과 함께 제공된 Bearer 토큰을 확인하는 프로세스를 간소화해주지만, 특정 역할이 있는 사용자가 특정 경로에 액세스할 수 있는지 확인하는 것은 조금 더 복잡해졌습니다.\n\n조사한 결과, Keycloak에서 큰 설정이 필요하지 않는 해결책을 찾을 수 있었습니다. 함께 알아보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## 준비 사항\n\n안내서를 따라 가기 전에 이미 독립적인 Keycloak 설정이 완료되어 있어야 합니다. 그렇지 않은 경우 Docker를 사용하여 빠르게 로컬에서 설정할 수 있습니다. 또한 사용자 액세스 토큰을 생성하는 방법이 이미 설정되어 있는 것을 기대합니다. (이전 글에서 구성한 프론트엔드 설정을 재사용할 수 있습니다)\n\n# 새로운 Node.js 프로젝트 만들기\n\n먼저, 로컬에서 새로운 Node.js 프로젝트를 시작해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm init\n```\n\n구성을 원하는 대로 변경할 수 있어요. 주로 기본 설정을 사용해요.\n\n## npm 패키지 설치\n\n이 프로젝트에 필요한 패키지를 설치해봐요.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm i cors dotenv express jsonwebtoken keycloak-connect nodemon\n```\n\n각 패키지에 대해 자세히 알아보려면 해당 공식 문서를 확인할 수 있어요.\n\njwt를 사용하여 API 요청을 통해 전달된 Bearer 토큰을 읽고, keycloak-connect를 사용하여 토큰을 확인할 거에요.\n\n로컬에서 API 서버를 실행하려면 package.json 파일에 스크립트를 추가해야 해요. \"scripts\" 아래에 이 줄을 객체에 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 파일: package.json\n\n...\n\n\"start\": \"nodemon index.js\",\n\n...\n```\n\n사용 편의를 위해 package.json 파일에 루트 및 미들웨어 디렉토리의 경로 별칭도 추가했습니다.\n\n```js\n// 파일: package.json\n\n...\n\n\"imports\": {\n  \"#routes/*\": \"./routes/*.js\",\n  \"#middlewares/*\": \"./middlewares/*.js\"\n}\n\n...\n```\n\n## 기본 프로젝트 생성하기\n\n<div class=\"content-ad\"></div>\n\nAPI가 작동하는지 테스트하려면 간단한 기본 프로젝트를 만들어 보겠습니다. 루트 폴더에 index.js 파일을 추가해주세요.\n\n```js\n// 파일: index.js\n\nrequire('dotenv').config();\nconst cors = require('cors');\nconst express = require('express');\n\nconst port = process.env.PORT;\n\n// 라우터\nconst testRoutes = require('#routes/test');\n\nconst errorHandler = (error, req, res, next) => {\n  const status = error.status || 422;\n  res.status(status).send(error.message);\n}\n\nconst app = express();\n\napp.use(express.json());\napp.use(cors());\n\n// 라우트 등록\napp.use('/api', testRoutes);\napp.use(errorHandler);\n\napp.listen(port, () => {\n  console.log(`서버가 ${port} 포트에서 시작되었습니다.`);\n});\n```\n\n여기서 환경 변수를 사용하는 것을 주목했나요?\n\n프로젝트용 .env 파일을 만들고, 이미 만들지 않았다면 API에 사용할 포트 번호를 할당해주세요.\n\n<div class=\"content-ad\"></div>\n\n우리는 테스트를 위해 라우트 파일을 사용하고 있습니다. 다음으로 그것을 생성해 봅시다.\n\n```js\n// 파일: routes/test.js\n\nconst express = require('express');\nconst router = express.Router();\n\n// 테스트 라우트\nrouter.get('/test', (req, res) => {\n  res.json({\n    message: \"API 연결이 설정되었습니다.\",\n    status: \"성공\"\n  })\n  .status(200);\n});\n\nmodule.exports = router;\n```\n\n## 기본 프로젝트를 가동해 봅시다\n\n로컬에서 API를 실행하려면 터미널에서 다음을 실행하세요 :\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm start\n```\n\n터미널에서 'Server Started at `port`'와 같은 메시지가 표시될 것입니다.\n\n모든 것이 동작하는지 확인하려면 브라우저에서 http://localhost:`port`/api/test을 열어보세요. 여기에서는 test.js 라우트 파일에서 만든 응답 객체를 확인할 수 있어야 합니다. 이는 우리의 기본 프로젝트가 기대한 대로 동작 중임을 의미합니다.\n\n# 사용을 위한 Keycloak 구성하기\n\n\n<div class=\"content-ad\"></div>\n\n설정한 Keycloak으로 새로운 프로젝트를 위한 Realm을 생성해보세요. 저는 간단하게 \"rbacDemo\"라고 지었습니다.\n\n만들어진 Realm으로 이동한 후, 좌측의 \"Clients\"를 선택하고 \"Client 목록\" 탭에서 \"Client 만들기\" 버튼을 클릭해보세요. \"Client 만들기\" 양식에서 \"일반 설정\" 아래에 새로운 클라이언트 ID를 지정해주세요.\n\n\"Realm 역할\"로 이동하여 좌측에 있는 \"역할 만들기\" 버튼을 클릭해주세요. 우리는 이 Realm을 위한 관리자 역할을 만들 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지1](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_1.png)\n\n이제 \"Realm roles\"로 돌아가면 방금 만든 관리자 역할을 볼 수 있어야 합니다.\n\n이제 우리의 realm 및 클라이언트가 준비되었으므로 사용자가 필요합니다. 2명만 있으면 됩니다. 하나는 관리자 사용자이고 다른 하나는 일반 사용자입니다. \"사용자\"로 이동하고 \"사용자 추가\" 버튼을 클릭하세요.\n\n![이미지2](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_2.png)\n\n<div class=\"content-ad\"></div>\n\n관리자 사용자가 생성되면 사용자의 \"사용자 세부정보\" 페이지로 이동하여 \"자격 증명\" 탭에서 사용자의 비밀번호를 설정해주세요.\n\n\n![이미지](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_3.png)\n\n\n한 번 더 \"사용자\" 페이지로 돌아가서 다른 사용자를 추가해주세요.\n\n\n![이미지](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n카렌을 위해도 비밀번호를 만들지 않도록하세요.\n\"사용자\"로 돌아가서 이제 목록에 Admin과 Karen 두 명의 사용자가 있는 것을 확인할 수 있을 거에요.\n\n이제 어드민 사용자로 이동하여 \"Role mapping\" 탭 아래에서 사용자에게 역할을 할당해볼까요?\n\n![이미지](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_5.png)\n\n이제 우리 어드민 사용자에게 \"admin\" 역할이 할당된 것을 확인할 수 있을 거에요.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_6.png\" />\n\n그것만으로도 Keycloak에서 RBAC 작업을 시작할 준비가 끝났습니다.\n\n# API에 RBAC 구현하기\n\n먼저 Keycloak Realm 및 Client ID를 .env 파일에 추가해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n키클로크가 있는 위치에 따라 KEYCLOAK_URL을 변경해주세요.\n\n## 키클로크 미들웨어 설정\n\nkeycloak-connect를 라우트의 미들웨어로 사용하려면, 새로운 미들웨어를 만들어야 합니다.\n```  \n\n<div class=\"content-ad\"></div>\n\n```js\n// file: middlewares/keycloak.js\n\nconst Keycloak = require(\"keycloak-connect\");\nconst dotenv = require('dotenv').config();\n\nconst config = {\n  \"realm\": process.env.KEYCLOAK_REALM,\n  \"auth-server-url\": `${process.env.KEYCLOAK_URL}`,\n  \"ssl-required\": \"external\",\n  \"resource\": process.env.KEYCLOAK_CLIENT,\n  \"bearer-only\": true\n}\n\nmodule.exports = new Keycloak({}, config);\n```\n\n그런 다음 우리는 index.js에 방금 만든 미들웨어를 사용하도록 알려주어야 합니다.\n\n```js\n// file: index.js\n\n...\n\nconst express = require('express');\nconst keycloak = require('#middlewares/keycloak'); // Keycloak\n\n...\n\napp.use(keycloak.middleware());\napp.use(express.json());\n\n...\n```\n\n## 라우트에 Keycloak 미들웨어 추가하기\n\n\n<div class=\"content-ad\"></div>\n\n새로운 라우트 파일을 만들어 미들웨어를 사용할 것이에요.\n\n```js\n// 파일: routes/menuItems.js\n\nconst express = require(\"express\");\nconst router = express.Router();\n\n// 미들웨어\nconst keycloak = require(\"#middlewares/keycloak\");\n\n// 가짜 데이터\nconst menuItems = [\n  {\n    name: \"크루아상\",\n    price: \"$1\",\n    onMenu: true\n  },\n  {\n    name:\"라떼\",\n    price: \"$5\",\n    onMenu: true\n  },\n  {\n    name: \"로티 차나이\",\n    price: \"$0.50\",\n    onMenu: true\n  },\n  {\n    name: \"핫 초콜릿\",\n    price: \"$5\",\n    onMenu: false\n  },\n  {\n    name: \"사테\",\n    price: \"$8\",\n    onMenu: false\n  },\n  {\n    name: \"팟 타이\",\n    price: \"$7\",\n    onMenu: false\n  }\n];\n\n// 어떤 역할이든 열려 있는 라우트\nrouter.get(\"/menu-items\",\n[keycloak.protect()],\nasync (req, res, next) => {\n  try {\n    let filtered = menuItems.filter(item => {\n      if (item.onMenu === true) {\n        return item;\n      }\n    });\n\n    // 필터된 데이터 반환\n    res.json(filtered);\n  } catch (error) {\n    return next(error);\n  }\n});\n\nmodule.exports = router;\n```\n\n라우트가 데이터 세트를 반환하도록 지시할 거에요. 일반적으로는 데이터베이스에서 하겠지만 여기서는 가짜 데이터를 사용할 거에요.\n\n## Keycloak 미들웨어 테스트하기\n\n<div class=\"content-ad\"></div>\n\n알림: 여기서 사용자의 엑세스 토큰을 생성해야 합니다.\n\nBearer 토큰을 요청의 인증 헤더로 파싱하고 있다고 가정하면, 메뉴에 있는 항목만 응답을 받아야 합니다. /menu-items 경로는 모든 사용자에게 열려 있기 때문에 관리자와 카렌이 동일한 응답을 받아야 합니다.\n\nPostman을 사용하여 이를 테스트할 수 있습니다.\n\n## Bearer 토큰에서 데이터 디코딩 및 추출하기\n\n<div class=\"content-ad\"></div>\n\n이제 \"admin\" 역할을 가진 사용자에게만 제한된 또 다른 경로를 추가해 봅시다.\n\n먼저 두 개의 미들웨어를 추가해야 합니다.\n하나는 jsonwebtoken을 사용하여 Bearer 토큰에서 사용자 데이터를 해독 및 추출하는 것이고, 다른 하나는 해당 사용자가 필요한 역할을 가졌는지 확인하는 것입니다.\n\n```js\n// file: middlewares/extractToken.js\n\nconst jwt = require(\"jsonwebtoken\");\n\nmodule.exports = async (req, res, next) => {\n  try {\n    // 액세스 토큰 디코딩\n    const bearerToken = req.headers.authorization;\n    // bearerToken은 \"Bearer <access_token>\"을 반환합니다.\n\n    const token = bearerToken.split(\" \");\n    // token은 [\"Bearer\", \"<access_token>\"]을 반환합니다.\n\n    const tokenData = jwt.decode(token[1]);\n    // tokenData는 사용자 데이터를 반환합니다.\n\n    // 해독된 토큰 데이터를 요청에 저장\n    req.tokenData = tokenData;\n\n    next();\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n```js\n// file: middlewares/checkIfAdmin.js\n\nmodule.exports = async (req, res, next) => {\n  try {\n    const tokenData = req.tokenData;\n    const roles = tokenData.realm_access.roles;\n    // roles는 문자열 배열을 반환합니다.\n\n    const isAdmin = roles.includes(\"admin\");\n\n    if (isAdmin) {\n      // 사용자가 Admin 역할을 가지고 있는 경우, 진행합니다.\n      next();\n    } else {\n      // 사용자가 관리자가 아닌 경우 오류 발생\n      const error = new Error(\"액세스 거부: 이에 액세스할 수 있는 권한이 없습니다.\");\n      error.statusCode = 401;\n      throw error;\n    }\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n작성된 미들웨어와 새로운 라우트를 메뉴 아이템 라우트 파일에 추가해보세요.\n\n```js\n// 파일: routes/menuItems.js\n\n...\n\n// 미들웨어\nconst keycloak = require(\"#middlewares/keycloak\");\nconst extractToken = require(\"#middlewares/extractToken\");\nconst checkIfAdmin = require(\"#middlewares/checkIfAdmin\");\n\n...\n\n// 어드민 역할만 접근 가능한 라우트\nrouter.get(\"/menu-items/all\", \n[keycloak.protect(), extractToken, checkIfAdmin],\nasync ( req, res, next) => {\n  try {\n    // 모든 데이터 반환\n    res.json(menuItems);\n  } catch (error) {\n    return next(error);\n  }\n});\n\nmodule.exports = router;\n```\n\n이제 이 새로운 API 라우트를 Postman을 사용하여 두 사용자로 테스트해보세요.\n\nKaren의 토큰을 사용하면 액세스 거부 오류가 발생합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 Admin의 토큰을 사용했다면, 메뉴에 있는 모든 항목을 얻을 수 있습니다.\n\n# 마무리\n\n여기서는 Node + Express API에 간단한 Role-Based Access Control (RBAC)를 구현하는 방법을 안내했습니다. Keycloak를 사용했습니다.\n\n이 안내서는 여러분의 API에 사용할 수 있는 방법을 쉽게 보여주기 위해 간소화되었습니다. 이 안내서에서는 GET 요청만 사용했지만 사실상 다른 요청 방법과 함께 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 가이드의 소스 코드는 여기에서 확인할 수 있어요. 이 기사에 대해 토론할 내용이 있다면 언제든지 연락해 주세요.\n\n읽어 주셔서 감사합니다. 다음에 또 만나요! 👋","ogImage":{"url":"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_0.png"},"coverImage":"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>안녕하세요!</p>\n<p>오늘은 Node.js 및 Express.js API에 대한 간단한 역할 기반 액세스 제어 (RBAC)를 구축하는 방법을 알아볼 것입니다. 이를 위해 인증을 위해 Keycloak을 사용할 것입니다.</p>\n<p>Keycloak 인증을 통해 Node + Express API를 안전하게 보호하는 해결책을 찾던 중 Keycloak Node.js 어댑터인 keycloak-connect를 만났습니다. 이 어댑터는 모든 요청과 함께 제공된 Bearer 토큰을 확인하는 프로세스를 간소화해주지만, 특정 역할이 있는 사용자가 특정 경로에 액세스할 수 있는지 확인하는 것은 조금 더 복잡해졌습니다.</p>\n<p>조사한 결과, Keycloak에서 큰 설정이 필요하지 않는 해결책을 찾을 수 있었습니다. 함께 알아보겠습니다.</p>\n<h2>준비 사항</h2>\n<p>안내서를 따라 가기 전에 이미 독립적인 Keycloak 설정이 완료되어 있어야 합니다. 그렇지 않은 경우 Docker를 사용하여 빠르게 로컬에서 설정할 수 있습니다. 또한 사용자 액세스 토큰을 생성하는 방법이 이미 설정되어 있는 것을 기대합니다. (이전 글에서 구성한 프론트엔드 설정을 재사용할 수 있습니다)</p>\n<h1>새로운 Node.js 프로젝트 만들기</h1>\n<p>먼저, 로컬에서 새로운 Node.js 프로젝트를 시작해 보겠습니다.</p>\n<pre><code class=\"hljs language-js\">npm init\n</code></pre>\n<p>구성을 원하는 대로 변경할 수 있어요. 주로 기본 설정을 사용해요.</p>\n<h2>npm 패키지 설치</h2>\n<p>이 프로젝트에 필요한 패키지를 설치해봐요.</p>\n<pre><code class=\"hljs language-js\">npm i cors dotenv express jsonwebtoken keycloak-connect nodemon\n</code></pre>\n<p>각 패키지에 대해 자세히 알아보려면 해당 공식 문서를 확인할 수 있어요.</p>\n<p>jwt를 사용하여 API 요청을 통해 전달된 Bearer 토큰을 읽고, keycloak-connect를 사용하여 토큰을 확인할 거에요.</p>\n<p>로컬에서 API 서버를 실행하려면 package.json 파일에 스크립트를 추가해야 해요. \"scripts\" 아래에 이 줄을 객체에 추가하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 파일: package.json</span>\n\n...\n\n<span class=\"hljs-string\">\"start\"</span>: <span class=\"hljs-string\">\"nodemon index.js\"</span>,\n\n...\n</code></pre>\n<p>사용 편의를 위해 package.json 파일에 루트 및 미들웨어 디렉토리의 경로 별칭도 추가했습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 파일: package.json</span>\n\n...\n\n<span class=\"hljs-string\">\"imports\"</span>: {\n  <span class=\"hljs-string\">\"#routes/*\"</span>: <span class=\"hljs-string\">\"./routes/*.js\"</span>,\n  <span class=\"hljs-string\">\"#middlewares/*\"</span>: <span class=\"hljs-string\">\"./middlewares/*.js\"</span>\n}\n\n...\n</code></pre>\n<h2>기본 프로젝트 생성하기</h2>\n<p>API가 작동하는지 테스트하려면 간단한 기본 프로젝트를 만들어 보겠습니다. 루트 폴더에 index.js 파일을 추가해주세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 파일: index.js</span>\n\n<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'dotenv'</span>).<span class=\"hljs-title function_\">config</span>();\n<span class=\"hljs-keyword\">const</span> cors = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'cors'</span>);\n<span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n\n<span class=\"hljs-keyword\">const</span> port = process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">PORT</span>;\n\n<span class=\"hljs-comment\">// 라우터</span>\n<span class=\"hljs-keyword\">const</span> testRoutes = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'#routes/test'</span>);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">errorHandler</span> = (<span class=\"hljs-params\">error, req, res, next</span>) => {\n  <span class=\"hljs-keyword\">const</span> status = error.<span class=\"hljs-property\">status</span> || <span class=\"hljs-number\">422</span>;\n  res.<span class=\"hljs-title function_\">status</span>(status).<span class=\"hljs-title function_\">send</span>(error.<span class=\"hljs-property\">message</span>);\n}\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n\napp.<span class=\"hljs-title function_\">use</span>(express.<span class=\"hljs-title function_\">json</span>());\napp.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title function_\">cors</span>());\n\n<span class=\"hljs-comment\">// 라우트 등록</span>\napp.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">'/api'</span>, testRoutes);\napp.<span class=\"hljs-title function_\">use</span>(errorHandler);\n\napp.<span class=\"hljs-title function_\">listen</span>(port, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`서버가 <span class=\"hljs-subst\">${port}</span> 포트에서 시작되었습니다.`</span>);\n});\n</code></pre>\n<p>여기서 환경 변수를 사용하는 것을 주목했나요?</p>\n<p>프로젝트용 .env 파일을 만들고, 이미 만들지 않았다면 API에 사용할 포트 번호를 할당해주세요.</p>\n<p>우리는 테스트를 위해 라우트 파일을 사용하고 있습니다. 다음으로 그것을 생성해 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 파일: routes/test.js</span>\n\n<span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n<span class=\"hljs-keyword\">const</span> router = express.<span class=\"hljs-title class_\">Router</span>();\n\n<span class=\"hljs-comment\">// 테스트 라우트</span>\nrouter.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'/test'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =></span> {\n  res.<span class=\"hljs-title function_\">json</span>({\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">\"API 연결이 설정되었습니다.\"</span>,\n    <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">\"성공\"</span>\n  })\n  .<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">200</span>);\n});\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = router;\n</code></pre>\n<h2>기본 프로젝트를 가동해 봅시다</h2>\n<p>로컬에서 API를 실행하려면 터미널에서 다음을 실행하세요 :</p>\n<pre><code class=\"hljs language-js\">npm start\n</code></pre>\n<p>터미널에서 'Server Started at <code>port</code>'와 같은 메시지가 표시될 것입니다.</p>\n<p>모든 것이 동작하는지 확인하려면 브라우저에서 <a href=\"http://localhost:%60port%60/api/test%EC%9D%84\" rel=\"nofollow\" target=\"_blank\">http://localhost:`port`/api/test을</a> 열어보세요. 여기에서는 test.js 라우트 파일에서 만든 응답 객체를 확인할 수 있어야 합니다. 이는 우리의 기본 프로젝트가 기대한 대로 동작 중임을 의미합니다.</p>\n<h1>사용을 위한 Keycloak 구성하기</h1>\n<p>설정한 Keycloak으로 새로운 프로젝트를 위한 Realm을 생성해보세요. 저는 간단하게 \"rbacDemo\"라고 지었습니다.</p>\n<p>만들어진 Realm으로 이동한 후, 좌측의 \"Clients\"를 선택하고 \"Client 목록\" 탭에서 \"Client 만들기\" 버튼을 클릭해보세요. \"Client 만들기\" 양식에서 \"일반 설정\" 아래에 새로운 클라이언트 ID를 지정해주세요.</p>\n<p>\"Realm 역할\"로 이동하여 좌측에 있는 \"역할 만들기\" 버튼을 클릭해주세요. 우리는 이 Realm을 위한 관리자 역할을 만들 예정입니다.</p>\n<p><img src=\"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_1.png\" alt=\"이미지1\"></p>\n<p>이제 \"Realm roles\"로 돌아가면 방금 만든 관리자 역할을 볼 수 있어야 합니다.</p>\n<p>이제 우리의 realm 및 클라이언트가 준비되었으므로 사용자가 필요합니다. 2명만 있으면 됩니다. 하나는 관리자 사용자이고 다른 하나는 일반 사용자입니다. \"사용자\"로 이동하고 \"사용자 추가\" 버튼을 클릭하세요.</p>\n<p><img src=\"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_2.png\" alt=\"이미지2\"></p>\n<p>관리자 사용자가 생성되면 사용자의 \"사용자 세부정보\" 페이지로 이동하여 \"자격 증명\" 탭에서 사용자의 비밀번호를 설정해주세요.</p>\n<p><img src=\"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_3.png\" alt=\"이미지\"></p>\n<p>한 번 더 \"사용자\" 페이지로 돌아가서 다른 사용자를 추가해주세요.</p>\n<p><img src=\"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_4.png\" alt=\"이미지\"></p>\n<p>카렌을 위해도 비밀번호를 만들지 않도록하세요.\n\"사용자\"로 돌아가서 이제 목록에 Admin과 Karen 두 명의 사용자가 있는 것을 확인할 수 있을 거에요.</p>\n<p>이제 어드민 사용자로 이동하여 \"Role mapping\" 탭 아래에서 사용자에게 역할을 할당해볼까요?</p>\n<p><img src=\"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_5.png\" alt=\"이미지\"></p>\n<p>이제 우리 어드민 사용자에게 \"admin\" 역할이 할당된 것을 확인할 수 있을 거에요.</p>\n<p>그것만으로도 Keycloak에서 RBAC 작업을 시작할 준비가 끝났습니다.</p>\n<h1>API에 RBAC 구현하기</h1>\n<p>먼저 Keycloak Realm 및 Client ID를 .env 파일에 추가해야 합니다.</p>\n<pre><code class=\"hljs language-js\">키클로크가 있는 위치에 따라 <span class=\"hljs-variable constant_\">KEYCLOAK_URL</span>을 변경해주세요.\n\n## 키클로크 미들웨어 설정\n\nkeycloak-connect를 라우트의 미들웨어로 사용하려면, 새로운 미들웨어를 만들어야 합니다.\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// file: middlewares/keycloak.js</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Keycloak</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"keycloak-connect\"</span>);\n<span class=\"hljs-keyword\">const</span> dotenv = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'dotenv'</span>).<span class=\"hljs-title function_\">config</span>();\n\n<span class=\"hljs-keyword\">const</span> config = {\n  <span class=\"hljs-string\">\"realm\"</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">KEYCLOAK_REALM</span>,\n  <span class=\"hljs-string\">\"auth-server-url\"</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${process.env.KEYCLOAK_URL}</span>`</span>,\n  <span class=\"hljs-string\">\"ssl-required\"</span>: <span class=\"hljs-string\">\"external\"</span>,\n  <span class=\"hljs-string\">\"resource\"</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">KEYCLOAK_CLIENT</span>,\n  <span class=\"hljs-string\">\"bearer-only\"</span>: <span class=\"hljs-literal\">true</span>\n}\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Keycloak</span>({}, config);\n</code></pre>\n<p>그런 다음 우리는 index.js에 방금 만든 미들웨어를 사용하도록 알려주어야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// file: index.js</span>\n\n...\n\n<span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n<span class=\"hljs-keyword\">const</span> keycloak = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'#middlewares/keycloak'</span>); <span class=\"hljs-comment\">// Keycloak</span>\n\n...\n\napp.<span class=\"hljs-title function_\">use</span>(keycloak.<span class=\"hljs-title function_\">middleware</span>());\napp.<span class=\"hljs-title function_\">use</span>(express.<span class=\"hljs-title function_\">json</span>());\n\n...\n</code></pre>\n<h2>라우트에 Keycloak 미들웨어 추가하기</h2>\n<p>새로운 라우트 파일을 만들어 미들웨어를 사용할 것이에요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 파일: routes/menuItems.js</span>\n\n<span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"express\"</span>);\n<span class=\"hljs-keyword\">const</span> router = express.<span class=\"hljs-title class_\">Router</span>();\n\n<span class=\"hljs-comment\">// 미들웨어</span>\n<span class=\"hljs-keyword\">const</span> keycloak = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"#middlewares/keycloak\"</span>);\n\n<span class=\"hljs-comment\">// 가짜 데이터</span>\n<span class=\"hljs-keyword\">const</span> menuItems = [\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"크루아상\"</span>,\n    <span class=\"hljs-attr\">price</span>: <span class=\"hljs-string\">\"$1\"</span>,\n    <span class=\"hljs-attr\">onMenu</span>: <span class=\"hljs-literal\">true</span>\n  },\n  {\n    <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">\"라떼\"</span>,\n    <span class=\"hljs-attr\">price</span>: <span class=\"hljs-string\">\"$5\"</span>,\n    <span class=\"hljs-attr\">onMenu</span>: <span class=\"hljs-literal\">true</span>\n  },\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"로티 차나이\"</span>,\n    <span class=\"hljs-attr\">price</span>: <span class=\"hljs-string\">\"$0.50\"</span>,\n    <span class=\"hljs-attr\">onMenu</span>: <span class=\"hljs-literal\">true</span>\n  },\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"핫 초콜릿\"</span>,\n    <span class=\"hljs-attr\">price</span>: <span class=\"hljs-string\">\"$5\"</span>,\n    <span class=\"hljs-attr\">onMenu</span>: <span class=\"hljs-literal\">false</span>\n  },\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"사테\"</span>,\n    <span class=\"hljs-attr\">price</span>: <span class=\"hljs-string\">\"$8\"</span>,\n    <span class=\"hljs-attr\">onMenu</span>: <span class=\"hljs-literal\">false</span>\n  },\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"팟 타이\"</span>,\n    <span class=\"hljs-attr\">price</span>: <span class=\"hljs-string\">\"$7\"</span>,\n    <span class=\"hljs-attr\">onMenu</span>: <span class=\"hljs-literal\">false</span>\n  }\n];\n\n<span class=\"hljs-comment\">// 어떤 역할이든 열려 있는 라우트</span>\nrouter.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/menu-items\"</span>,\n[keycloak.<span class=\"hljs-title function_\">protect</span>()],\n<span class=\"hljs-keyword\">async</span> (req, res, next) => {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">let</span> filtered = menuItems.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> {\n      <span class=\"hljs-keyword\">if</span> (item.<span class=\"hljs-property\">onMenu</span> === <span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-keyword\">return</span> item;\n      }\n    });\n\n    <span class=\"hljs-comment\">// 필터된 데이터 반환</span>\n    res.<span class=\"hljs-title function_\">json</span>(filtered);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">next</span>(error);\n  }\n});\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = router;\n</code></pre>\n<p>라우트가 데이터 세트를 반환하도록 지시할 거에요. 일반적으로는 데이터베이스에서 하겠지만 여기서는 가짜 데이터를 사용할 거에요.</p>\n<h2>Keycloak 미들웨어 테스트하기</h2>\n<p>알림: 여기서 사용자의 엑세스 토큰을 생성해야 합니다.</p>\n<p>Bearer 토큰을 요청의 인증 헤더로 파싱하고 있다고 가정하면, 메뉴에 있는 항목만 응답을 받아야 합니다. /menu-items 경로는 모든 사용자에게 열려 있기 때문에 관리자와 카렌이 동일한 응답을 받아야 합니다.</p>\n<p>Postman을 사용하여 이를 테스트할 수 있습니다.</p>\n<h2>Bearer 토큰에서 데이터 디코딩 및 추출하기</h2>\n<p>이제 \"admin\" 역할을 가진 사용자에게만 제한된 또 다른 경로를 추가해 봅시다.</p>\n<p>먼저 두 개의 미들웨어를 추가해야 합니다.\n하나는 jsonwebtoken을 사용하여 Bearer 토큰에서 사용자 데이터를 해독 및 추출하는 것이고, 다른 하나는 해당 사용자가 필요한 역할을 가졌는지 확인하는 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// file: middlewares/extractToken.js</span>\n\n<span class=\"hljs-keyword\">const</span> jwt = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"jsonwebtoken\"</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-keyword\">async</span> (req, res, next) => {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 액세스 토큰 디코딩</span>\n    <span class=\"hljs-keyword\">const</span> bearerToken = req.<span class=\"hljs-property\">headers</span>.<span class=\"hljs-property\">authorization</span>;\n    <span class=\"hljs-comment\">// bearerToken은 \"Bearer &#x3C;access_token>\"을 반환합니다.</span>\n\n    <span class=\"hljs-keyword\">const</span> token = bearerToken.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">\" \"</span>);\n    <span class=\"hljs-comment\">// token은 [\"Bearer\", \"&#x3C;access_token>\"]을 반환합니다.</span>\n\n    <span class=\"hljs-keyword\">const</span> tokenData = jwt.<span class=\"hljs-title function_\">decode</span>(token[<span class=\"hljs-number\">1</span>]);\n    <span class=\"hljs-comment\">// tokenData는 사용자 데이터를 반환합니다.</span>\n\n    <span class=\"hljs-comment\">// 해독된 토큰 데이터를 요청에 저장</span>\n    req.<span class=\"hljs-property\">tokenData</span> = tokenData;\n\n    <span class=\"hljs-title function_\">next</span>();\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-title function_\">next</span>(error);\n  }\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// file: middlewares/checkIfAdmin.js</span>\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-keyword\">async</span> (req, res, next) => {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> tokenData = req.<span class=\"hljs-property\">tokenData</span>;\n    <span class=\"hljs-keyword\">const</span> roles = tokenData.<span class=\"hljs-property\">realm_access</span>.<span class=\"hljs-property\">roles</span>;\n    <span class=\"hljs-comment\">// roles는 문자열 배열을 반환합니다.</span>\n\n    <span class=\"hljs-keyword\">const</span> isAdmin = roles.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">\"admin\"</span>);\n\n    <span class=\"hljs-keyword\">if</span> (isAdmin) {\n      <span class=\"hljs-comment\">// 사용자가 Admin 역할을 가지고 있는 경우, 진행합니다.</span>\n      <span class=\"hljs-title function_\">next</span>();\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 사용자가 관리자가 아닌 경우 오류 발생</span>\n      <span class=\"hljs-keyword\">const</span> error = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">\"액세스 거부: 이에 액세스할 수 있는 권한이 없습니다.\"</span>);\n      error.<span class=\"hljs-property\">statusCode</span> = <span class=\"hljs-number\">401</span>;\n      <span class=\"hljs-keyword\">throw</span> error;\n    }\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-title function_\">next</span>(error);\n  }\n}\n</code></pre>\n<p>작성된 미들웨어와 새로운 라우트를 메뉴 아이템 라우트 파일에 추가해보세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 파일: routes/menuItems.js</span>\n\n...\n\n<span class=\"hljs-comment\">// 미들웨어</span>\n<span class=\"hljs-keyword\">const</span> keycloak = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"#middlewares/keycloak\"</span>);\n<span class=\"hljs-keyword\">const</span> extractToken = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"#middlewares/extractToken\"</span>);\n<span class=\"hljs-keyword\">const</span> checkIfAdmin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"#middlewares/checkIfAdmin\"</span>);\n\n...\n\n<span class=\"hljs-comment\">// 어드민 역할만 접근 가능한 라우트</span>\nrouter.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/menu-items/all\"</span>, \n[keycloak.<span class=\"hljs-title function_\">protect</span>(), extractToken, checkIfAdmin],\n<span class=\"hljs-keyword\">async</span> ( req, res, next) => {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 모든 데이터 반환</span>\n    res.<span class=\"hljs-title function_\">json</span>(menuItems);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">next</span>(error);\n  }\n});\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = router;\n</code></pre>\n<p>이제 이 새로운 API 라우트를 Postman을 사용하여 두 사용자로 테스트해보세요.</p>\n<p>Karen의 토큰을 사용하면 액세스 거부 오류가 발생합니다.</p>\n<p>만약 Admin의 토큰을 사용했다면, 메뉴에 있는 모든 항목을 얻을 수 있습니다.</p>\n<h1>마무리</h1>\n<p>여기서는 Node + Express API에 간단한 Role-Based Access Control (RBAC)를 구현하는 방법을 안내했습니다. Keycloak를 사용했습니다.</p>\n<p>이 안내서는 여러분의 API에 사용할 수 있는 방법을 쉽게 보여주기 위해 간소화되었습니다. 이 안내서에서는 GET 요청만 사용했지만 사실상 다른 요청 방법과 함께 사용할 수 있습니다.</p>\n<p>이 가이드의 소스 코드는 여기에서 확인할 수 있어요. 이 기사에 대해 토론할 내용이 있다면 언제든지 연락해 주세요.</p>\n<p>읽어 주셔서 감사합니다. 다음에 또 만나요! 👋</p>\n</body>\n</html>\n"},"__N_SSG":true}