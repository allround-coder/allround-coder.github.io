{"pageProps":{"post":{"title":"Nodejs를 사용하여 마이크로서비스 작성하기","description":"","date":"2024-06-19 22:49","slug":"2024-06-19-WritingAMicroserviceUsingNodejs","content":"\n\n\n![Image](/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png)\n\n자바스크립트는 프로그래밍 언어 평가에서 주요 위치를 유지하고 있습니다. 자바스크립트에는 브라우저와 Node.js 두 가지 구현이 있습니다. 후자는 웹 서비스 개발에 널리 사용됩니다.\n\nIT 경력을 시작한 지 약 여덟 년 전에 자바스크립트를 배우기 시작했고, 몇 년 전에 David Flanagan의 훌륭한 책 \"JavaScript: The Definitive Guide\"를 읽었습니다.\n\n이 책은 많은 질문에 답하고 흥미로운 자바스크립트 레시피를 보여줬는데, 이를 내 업무에 적용하고 있습니다. 그러나 더 중요한 것은, Node.js로 웹 서비스 개발에 초점을 맞추게 됐습니다 (이전에는 JS를 프론트엔드 개발에만 사용). 이 책을 새로운 자바스크립트 개발자뿐만 아니라 경험있는 개발자에게도 추천합니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 게시물에서는 Node.js를 사용하여 마이크로서비스를 구축하는 방법을 소개하려고 합니다. 웹 개발 경험을 기반으로 인기 있는 Node.js 스택을 활용하여 확장 가능하고 견고하며 신뢰성 있고 성능이 우수한 솔루션을 만들어 보겠습니다.\n\n# 소개\n\n이 글에서는 작업 관리 웹 서비스 예시에 마이크로서비스를 구축하는 방법을 보여드리려고 합니다. 다음 API를 제공할 것입니다:\n\n- 이름과 설명으로 작업 생성;\n- 식별자로 작업 가져오기;\n- 작업 상태/이름/설명 업데이트.\n\n<div class=\"content-ad\"></div>\n\nNode.js로 웹 애플리케이션을 빌드할 때 얼마나 강력한지 보여주는 간단한 API입니다. 개발 프로세스가 빠르고 쉽습니다.\n\n몇 가지 애플리케이션 요구 사항:\n\n- 작업은 상태 'new'로 생성되어야 합니다.\n- 사용 가능한 상태 전이: 'new'에서 'active'로, 'new'에서 'canceled'로, 'active'에서 'completed'로, 'active'에서 'canceled'로.\n- 경쟁 상태를 피하십시오 (자세한 내용은 나중에).\n\n주요 비기능 요구 사항은:\n\n<div class=\"content-ad\"></div>\n\n- 확장성 — 마이크로서비스는 증가하는 요청 양을 처리할 수 있어야 합니다.\n- 탄력성 — 마이크로서비스는 즉각 처리할 수 있어야 합니다.\n- 성능 — 마이크로서비스는 빠르게 응답하여 더 나은 사용자 경험을 제공해야 합니다.\n- 복원력 — 마이크로서비스는 장애에 대해 허용하고 회복할 수 있어야 하므로 올바르게 기능을 계속 수행할 수 있어야 합니다.\n- 모니터링 — 마이크로서비스는 건강을 모니터링하는 방법을 제공해야 합니다.\n- 관찰가능성 — 마이크로서비스는 로그 스트림 및 메트릭을 생성하여 유지할 수 있어야 합니다.\n- 테스트 용이성 — 마이크로서비스는 쉽게 테스트할 수 있어야 합니다.\n- 상태를 유지하지 않음 — 마이크로서비스는 클라이언트 컨텍스트를 저장하지 않아야 하며 대신 상태는 데이터베이스에 저장되어야 합니다.\n- 배포 용이성 — 마이크로서비스는 쉽게 배포 및 업데이트할 수 있어야 합니다.\n\nNode.js로 웹 애플리케이션을 개발할 때 모두 가능합니다. 다음 단계에서 이러한 요구사항을 어떻게 달성할지 논의해보겠습니다.\n\n# 스택\n\n웹 서비스를 구축하기 위해 사용할 기술 스택을 처음부터 선택해야 합니다. 물론, 가장 먼저 고려해야 할 질문은 프로그래밍 언어입니다. 이 마이크로서비스에서는 Node.js를 사용할 것이지만, 그럼에도 불구하고, 웹 서비스 개발에 사용하는 데 Node.js의 몇 가지 이점을 소개해 드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- 자바스크립트는 이미 프론트엔드 개발의 주요 언어이며, 백엔드 개발에도 사용하는 것이 합리적입니다. 이렇게 하면 동일한 개발자가 풀 스택 애플리케이션을 개발할 수 있습니다.\n- 자바스크립트 커뮤니티는 엄청나게 큽니다. 개발 중 발생할 수 있는 모든 질문에 대한 답변을 찾을 수 있습니다. 또한 많은 라이브러리가 커뮤니티에 의해 개발되고 유지보수됩니다. 유사한 문제를 해결하는 다른 서드파티를 찾을 수 있으며, 각각 고유한 기능을 가집니다.\n- 노드.제이에스는 구글의 V8 엔진을 사용하여 자바스크립트를 해석하며, 이를 빠르게 기계 코드로 컴파일합니다.\n\n그리고 이런식으로 계속됩니다! 하지만 가장 중요한 질문은 아닙니다.\n\n## 데이터베이스\n\n웹 요청간 데이터를 유지하고 싶습니다. 확장 가능한 상태 유지 웹 서비스를 개발하는 것은 복잡한 작업입니다. 그래서 웹 애플리케이션을 상태가 없는 상태로 유지하고 개별적으로 상태를 외부 데이터베이스에 유지하는 것이 권장됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 서비스를 개발하기 위해 인기 있는 문서 지향 데이터베이스 MongoDB를 사용할 것입니다.\n\nMongoDB는 SQL 데이터베이스보다 몇 가지 이점을 제공하는 NoSQL 데이터베이스입니다:\n\n- 스키마 무료 — MongoDB 컬렉션 (SQL 테이블에 해당하는)은 다른 스키마를 가진 문서를 보유할 수 있습니다. 문서를 컬렉션에 저장하기 전에 구조를 먼저 정의할 필요가 없습니다;\n- 확장성 — MongoDB는 여러 서버에 걸쳐 확장 가능하게 설계되었습니다;\n- 성능 — MongoDB는 읽기 중심 작업에 최적화되어 있으며 대량의 데이터를 저장할 수 있습니다.\n\nNode.js 웹 서비스를 개발할 때 인기 있는 선택 사항입니다.\n\n<div class=\"content-ad\"></div>\n\n# 웹 프레임워크\n\n웹 프레임워크는 웹 애플리케이션을 구축하는 데 필요합니다. 웹 서비스 개발 시 필요한 많은 일상적인 작업을 처리합니다. 예를 들면 라우팅, 보안, 바인딩 등이 있습니다.\n\nNode.js 웹 프레임워크에는 다양한 옵션이 있습니다. 그중에서 가장 인기 있는 것은 express입니다:\n\nexpress의 가장 큰 장점은 사용하기 간편하며 웹 서버를 시작하는 데 필요한 코드가 최소량으로만 필요하다는 것입니다. express로 작성된 'Hello, World!' 예제가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst express = require('express')\nconst app = express()\nconst port = 3000;\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n\n또한, Express는 많은 커뮤니티가 있는데, 서버 기능을 확장하는 다양한 라이브러리(일반적으로 미들웨어로 개발됨)들을 찾을 수 있습니다.\n\n# 유효성 검사\n\n유효성 검사는 웹 애플리케이션의 중요한 부분입니다. 사용자가 API를 어떻게 사용할지 알 수 없기 때문에, 침입자가 잘못된 입력을 제공하여 응용프로그램을 손상시킬 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n웹 요청에서 제공된 매개변수(경로, 본문 등)를 확인하고 올바른지 확인하기 위해 joi를 사용할 거에요:\n\njoi는 다양한 모델을 확인하는 데 사용되는 강력한 라이브러리에요. 나중에 개발할 요청 중 하나를 확인하는 예시가 있어요:\n\n```js\nconst createTask = {\n  body: Joi.object().keys({\n    name: Joi.string().required(),\n    description: Joi.string().optional(),\n  }),\n};\n```\n\n이는 객체가 두 개의 문자열을 가진 중첩된 body 객체를 갖는지 확인하며, 이 문자열은 필수인 name과 선택적인 description이에요.\n\n<div class=\"content-ad\"></div>\n\n하지만 그것만이 아닙니다. 컬렉션을 삭제할 수 있는 위험한 MongoDB 인젝션을 제공하는 경우가 여전히 있습니다. 웹 요청을 정리하기 위해 express-mongo-sanitize 패키지를 사용할 것입니다:\n\n# 설정\n\n동일한 빌드 아티팩트를 다른 환경에서 실행할 수 있도록 응용 프로그램을 구성할 필요가 있습니다. 이를 위해 환경 변수를 통해 구성을 제공하는 것이 표준 접근 방식입니다.\n\n응용 프로그램을 시작하기 전에 로컬 머신에서 환경 변수를 수동으로 설정하고 싶지 않을 것입니다. 이 문제에 대한 인기 있는 Node.js 솔루션은 dotenv 라이브러리에 구현되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n이 라이브러리는 .env(파일 이름을 변경할 수 있음)이라는 파일에서 내용을 로드하고 이 파일의 내용을 환경 변수로 설정합니다.\n\n# 정적 분석\n\nJavaScript 애플리케이션의 경우 ESLint 라이브러리를 설치하여 코드 스타일을 쉽게 강제하고 응용 프로그램을 개발할 때 동일한 규칙을 따를 수 있습니다:\n\nESLint는 코드 품질을 향상하고 몇 가지 버그를 감지할 수 있습니다. 보안 취약점을 식별할 수 있습니다. CI(지속적 통합) 중에 ESLint 검사를 포함하여 팀원들이 ESLint에서 소개한 규칙을 준수하도록 강제할 수 있습니다. 나중에 이를 수행할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# 테스트\n\n애플리케이션을 변경할 때 이전과 동일하게 작동하는지 확인하기 위해 자동 테스트를 작성하는 것이 좋은 실천법입니다. 단위, 통합, 부하, 엔드-투-엔드 (E2E) 등 다양한 테스트 유형이 있습니다. 애플리케이션의 품질과 성능을 확신하려면 더 많은 테스트가 필요합니다.\n\nJavaScript 애플리케이션을 테스트하기 위한 가장 인기 있는 라이브러리 중 하나는 Jest입니다:\n\nJest를 사용하여 단위 및 통합 테스트를 구현할 것입니다. 이러한 테스트는 나중에 코드를 개선하고 리팩토링하는 데 도움이 되었으며 애플리케이션이 손상되지 않았음을 확인했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 로깅\n\n애플리케이션 로그 스트림은 웹 서비스를 원격으로 디버깅하는 데 도움이 됩니다. 코드 실행 경로를 식별하고 요청 로직을 다양한 상황에서 설명할 수 있습니다. 코드에 로그를 삽입하면 이점을 누릴 수 있습니다.\n\nJavaScript 로그를 수집하는 가장 인기 있는 패키지는 winston입니다:\n\nwinston은 간단하지만 강력한 로깅 라이브러리로, 다양한 전송 방법(콘솔, 파일 등)을 사용하여 로그를 수집하는 데 도움을 줍니다. 로그 형식(간단한 텍스트, JSON 등)도 변경할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 메트릭\n\n메트릭을 통해 응용 프로그램의 상태를 모니터링할 수 있어요. 들어오는 요청의 수, 평균 요청 실행 시간, 5XX 응답의 수 등을 확인할 수 있습니다. 메트릭을 통해 어떠한 문제가 발생할 경우 이메일, 알림 등을 통해 알림을 받을 수 있는 다양한 모니터를 설정할 수 있어요.\n\n제 응용 프로그램에서는 express-prom-bundle이라는 표준 웹 응용 프로그램 메트릭을 수집하는 Prometheus 미들웨어를 설치할 예정이에요.\n\n다음 섹션에서 Prometheus에 대해 더 자세히 알아볼 거예요.\n\n<div class=\"content-ad\"></div>\n\n# 모니터링 스택\n\n로그 스트림 및 메트릭은 나중에 모니터링하거나 시각화하는 데 사용할 수 있도록 일부 데이터베이스에 수집되어야 합니다.\n\n로그 및 메트릭을 수집하고 시각화하기 위해 다음 스택을 사용할 것입니다:\n\n- Prometheus — 메트릭을 수집하기 위해 풀 모델을 사용하는 오픈 소스 모니터링 경보 툴킷;\n- Promtail — 로그를 포함하고 전송하는 에이전트;\n- Loki — 로그 집계 시스템;\n- Grafana — 관측 가능성 시스템.\n\n<div class=\"content-ad\"></div>\n\n# 로컬 인프라스트럭처\n\n로컬에서 애플리케이션을 개발하고 테스트하기 위해 필요한 로컬 스택을 만들기 위해 도커를 사용할 거예요.\n\n도커를 사용하면 스테이징 및 프로덕션 환경에서 사용될 것과 유사한 로컬 환경을 시작할 수 있어요. 로컬 컴퓨터에 많은 도구를 설치할 필요가 없어요. 대신 필요한 스택을 시작하기 위해 몇 가지 명령을 실행할 수 있어요.\n\n도커 컴포즈를 사용하면 단일 compose.yml 파일로 모든 인프라스트럭처를 정의하고 단일 명령으로 시작할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n도커 컴포즈 업 -d\r\n```\n\n# 지속적 통합\n\n커밋이 무엇인가를 망가뜨리지 않았는지 확인하기 위해, 지속적 통합(CI)가 필요합니다.\n\n이를 위해, 저는 GitHub Actions를 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\nGitHub 계정에는 무료 티어가 있어서 애플리케이션 코드를 확인하기 위해 간단한 빌드를 실행할 수 있어요.\n\n# 애플리케이션 개발\n\n애플리케이션 구조를 시작했고 적절한 프로젝트 스타일을 따르는 데 도움이 된 훌륭한 저장소를 찾았어요:\n\n이 저장소에서 코드 일부(예: 유효성 검사 미들웨어)를 빌려왔기 때문에 여러분이 확인하도록 추천드려요.\n\n<div class=\"content-ad\"></div>\n\n나중에 저장소 링크를 공유할 건데, 그 전에 재미있는 애플리케이션 부분을 보여주고 싶어요.\n\n나는 mongoose를 사용해서 애플리케이션을 MongoDB와 통합했어요. 먼저, 모델의 스키마를 정의했어요:\n\n```js\nconst mongoose = require('mongoose');\nconst { Schema } = mongoose;\nconst TaskSchema = new Schema(\n  {\n    name: {\n      type: String,\n      required: true,\n    },\n    description: {\n      type: String,\n      required: false,\n    },\n    status: {\n      type: String,\n      enum: ['new', 'active', 'completed', 'cancelled'],\n      default: 'new',\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now,\n    },\n    updatedAt: Date,\n  },\n  { optimisticConcurrency: true },\n);\nmodule.exports = mongoose.model('task', TaskSchema);\n```\n\n이 객체를 사용하여 모델을 유효성 검사하고 코드에서 다양한 MongoDB 작업을 수행할 수 있어요. 이는 작업 업데이트의 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nasync function updateTaskById(id, { name, description, status }) {\n  if (!name && !description && !status) {\n    return { error: '적어도 하나의 업데이트가 필요합니다', code: AT_LEAST_ONE_UPDATE_REQUIRED_CODE };\n  }\n\nif (status && !(status in availableUpdates)) {\n    return { error: '잘못된 상태입니다', code: INVALID_STATUS_CODE };\n  }\n  for (let retry = 0; retry < 3; retry += 1) {\n    // eslint-disable-next-line no-await-in-loop\n    const task = await Task.findById(id);\n    if (!task) {\n      return { error: '작업을 찾을 수 없습니다', code: INVALID_STATUS_TRANSITION_CODE };\n    }\n    if (status) {\n      const allowedStatuses = availableUpdates[task.status];\n      if (!allowedStatuses.includes(status)) {\n        return {\n          error: `'${task.status}'에서 '${status}'(으)로 업데이트할 수 없습니다`,\n          code: TASK_NOT_FOUND_CODE,\n        };\n      }\n    }\n    task.status = status ?? task.status;\n    task.name = name ?? task.name;\n    task.description = description ?? task.description;\n    task.updatedAt = Date.now();\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      await task.save();\n    } catch (error) {\n      logger.warn('저장 중 오류 발생', { error });\n      if (error.name === 'VersionError') {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n    }\n    return task;\n  }\n  return { error: '병행성 오류', code: CONCURRENCY_ERROR_CODE };\n}\n```\n\n가장 흥미로운 부분은 업데이트 후 모델을 저장하는 부분입니다. 격렬한 충돌 문제에 대처하기 위해 낙관적 락을 사용하고 있어요.\n\n두 개의 동시 요청에서 동일한 작업을 완료하고 취소하려고 하는 상황을 상상해보세요. 두 요청이 모두 상태가 '활성'인 작업을 받고 모델을 저장할 때 충돌이 발생할 수 있어요. 첫 번째 작업의 상태가 '완료'로 변경되고 그런 다음 '취소'로 변경될 수 있습니다(또는 그 반대로). 이는 '완료'-'취소' 및 '취소'-'완료' 전이가 허용되지 않기 때문에 잘못된 동작입니다.\n\nMongoose는 낙관적 락으로 이 문제에 대한 해결책을 구현했어요. 낙관적 락은 데이터베이스에서 동시 요청을 처리하는 데 사용되는 전략입니다. 각 문서에는 추가적인 버전 속성이 있어요. 트랜잭션이 모델을 저장/업데이트하려고 할 때 버전을 확인합니다. 버전이 get 쿼리를 수행할 때 받은 버전과 다른 경우, 이미 누군가 문서를 동시에 업데이트했을 수 있어요. 트랜잭션이 중단됩니다(위의 코드에서는 오류가 발생합니다).\n\n\n<div class=\"content-ad\"></div>\n\n문서 예시:\n\n```js\n{\n  \"_id\": {\n    \"$oid\": \"654e03210948a61665b7c889\"\n  },\n  \"name\": \"damnatio\",\n  \"description\": \"Ciminatio totus spiritus suffoco damnatio blanditiis.\",\n  \"status\": \"completed\",\n  \"createdAt\": {\n    \"$date\": \"2023-11-10T10:17:05.039Z\"\n  },\n  \"__v\": 2,\n  \"updatedAt\": {\n    \"$date\": \"2023-11-10T10:17:05.064Z\"\n  }\n}\n```\n\n위의 문서는 속성 __v에 버전을 저장합니다.\n\n다음 레벨은 컨트롤러입니다. 컨트롤러 예시는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst updateTaskById = catchAsync(async (req, res) => {\n  const result = await taskService.updateTaskById(req.params.id, req.body);\n  if (result.error) {\n    switch (result.code) {\n      case taskService.errorCodes.AT_LEAST_ONE_UPDATE_REQUIRED_CODE:\n        res.status(400).json({ success: false, message: '적어도 하나의 업데이트가 필요합니다' });\n        return;\n      case taskService.errorCodes.INVALID_STATUS_CODE:\n        res.status(400).json({ success: false, message: '유효하지 않은 상태' });\n        return;\n      case taskService.errorCodes.INVALID_STATUS_TRANSITION_CODE:\n        res.status(404).json({ success: false, message: '작업을 찾을 수 없음' });\n        return;\n      case taskService.errorCodes.TASK_NOT_FOUND_CODE:\n        res.status(400).json({ success: false, message: result.error });\n        return;\n      case taskService.errorCodes.CONCURRENCY_ERROR_CODE:\n        res.status(500).json({ success: false, message: '동시성 오류' });\n        return;\n      default:\n        res.status(500).json({ success: false, message: '내부 서버 오류' });\n        return;\n    }\n  }\n\nres.status(200).json({\n    success: true,\n    task: toDto(result),\n  });\n});\n```\n\n이 코드는 애플리케이션 비즈니스 로직을 실행하고 HTTP 응답을 반환합니다. 컨트롤러는 routes 모듈에 등록됩니다:\n\n```js\nconst { Router } = require('express');\nconst taskController = require('../../../controllers/task');\nconst taskValidation = require('../../../validation/task');\nconst validate = require('../../../middlewares/validate');\n\nconst router = Router();\nrouter.get('/:id', validate(taskValidation.getTaskById), taskController.getTaskById);\nrouter.put('/', validate(taskValidation.createTask), taskController.createTask);\nrouter.post('/:id', validate(taskValidation.updateTaskById), taskController.updateTaskById);\nmodule.exports = router;\n\n/**\n * @swagger\n * tags:\n *  name: Tasks\n *  description: 작업 관리 및 검색\n * /v1/tasks/{id}:\n *  get:\n *   summary: ID로 작업 가져오기\n *   tags: [Tasks]\n *   description: ID로 작업 가져오기\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   responses:\n *    200:\n *     description: 작업 검색됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    404:\n *     description: 작업을 찾을 수 없음\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n *  post:\n *   summary: ID로 작업 업데이트\n *   tags: [Tasks]\n *   description: ID로 작업 업데이트\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/UpdateTask'\n *   responses:\n *    200:\n *     description: 작업 업데이트됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *     404:\n *      description: 작업을 찾을 수 없음\n *      content:\n *       application/json:\n *        schema:\n *         $ref: '#/components/schemas/TaskResult'\n *     500:\n *      description: 내부 서버 오류\n * /v1/tasks:\n *  put:\n *   summary: 작업 생성\n *   tags: [Tasks]\n *   description: 작업 생성\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/CreateTask'\n *   responses:\n *    201:\n *     description: 작업 생성됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n */\n```\n\n맨 아래에서는 Swagger 미들웨어가 사용하는 OpenAPI 사양이 API 문서 페이지를 생성하는 데 사용됨을 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n각 경로 등록은 두 개의 핸들러를 사용합니다: 유효성 검사기와 컨트롤러 메서드 자체입니다. 유효성 검사기는 서로 다른 모델에 등록된 스키마를 유효성 검사합니다. 유효성 검사기 핸들러:\n\n```js\nconst Joi = require('joi');\nconst pick = require('../utils/pick');\n\nfunction validate(schema) {\n  return (req, res, next) => {\n    const validSchema = pick(schema, ['params', 'query', 'body']);\n    const object = pick(req, Object.keys(validSchema));\n    const { value, error } = Joi.compile(validSchema)\n      .prefs({ errors: { label: 'key' }, abortEarly: false })\n      .validate(object);\n    if (error) {\n      const errorMessage = error.details.map((details) => details.message).join(', ');\n      res.status(400).json({ success: false, message: errorMessage });\n      return;\n    }\n    Object.assign(req, value);\n    next();\n  };\n}\nmodule.exports = validate;\n```\n\n또한 업데이트 요청 유효성 검사 스키마가 있습니다:\n\n```js\nconst updateTaskById = {\n  params: Joi.object().keys({\n    id: objectId.required(),\n  }),\n  body: Joi.object().keys({\n    name: Joi.string().optional(),\n    description: Joi.string().optional(),\n    status: Joi.string().valid('new', 'active', 'completed', 'cancelled').optional(),\n  }),\n};\n```\n\n<div class=\"content-ad\"></div>\n\n업데이트 메서드에 대해 말씀드리겠습니다. 저는 통합 테스트만 구현했습니다. 통합 테스트는 모든 테스트가 실행되기 전과 후에 서버를 시작하고 중지합니다. \n\n```js\nconst path = require('path');\nconst app = require('../../src/app');\nconst db = require('../../src/db');\nconst { createConfig } = require('../../src/config/config');\nconst logger = require('../../src/config/logger');\nconst setupServer = () => {\n  let server;\n  const configPath = path.join(__dirname, '../../configs/tests.env');\n  const config = createConfig(configPath);\n  beforeAll(async () => {\n    logger.init(config);\n    await db.init(config);\n    await new Promise((resolve) => {\n      server = app.listen(config.port, () => {\n        resolve();\n      });\n    });\n  });\n  afterAll(async () => {\n    await new Promise((resolve) => {\n      server.close(() => {\n        resolve();\n      });\n    });\n    await db.destroy();\n    logger.destroy();\n  });\n};\nmodule.exports = {\n  setupServer,\n};\n```\n\n그리고 PUT 요청(태스크 생성)과 POST 요청(태스크 업데이트)을 수행하는 테스트가 있습니다:\n\n```js\ndescribe('태스크 생성 및 업데이트', () => {\n      const data = [\n        {\n          name: '상태만 업데이트',\n          taskName: '태스크 1',\n          description: '태스크 1 설명',\n          newStatus: '활성',\n        },\n        {\n          name: '영어 전체 업데이트',\n          taskName: '태스크 1',\n          description: '태스크 1 설명',\n          newTaskName: '태스크 1 새로운',\n          newDescription: '태스크 1 새로운 설명',\n          newStatus: '활성',\n        },\n        // 이하 생략\n      ];\n\ndata.forEach(({\n        name, taskName, description, newTaskName, newDescription, newStatus,\n      }) => {\n        it(name, async () => {\n          let response = await fetch(baseUrl, {\n            method: 'put',\n            body: JSON.stringify({\n              name: taskName,\n              description,\n            }),\n            headers: { 'Content-Type': 'application/json' },\n          });\n          expect(response.status).toEqual(201);\n          const result = await response.json();\n          // 여기서부터 이하는 생략\n        });\n      });\n    });\n```\n\n<div class=\"content-ad\"></div>\n\n도커 이미지를 생성하려면 간단한 Dockerfile을 정의했습니다:\n\n```js\nFROM node:20-alpine\nWORKDIR /app\nCOPY package.json yarn.lock ./\nRUN yarn install --frozen-lockfile\nCOPY src /app/src\nCMD [\"node\", \"./src/index.js\"]\n```\n\n어플리케이션과 인프라를 시작하는 데 사용하는 compose.yml 정의입니다:\n\n```js\nversion: '3.9'\nservices:\n    app:\n        build: .\n        ports:\n            - '8081:80'\n        depends_on:\n            - mongo\n        volumes:\n            - ./configs/docker.env:/app/configs/.env\n            - logs:/app/logs:rw\n    mongo:\n        image: mongo:5\n        restart: always\n        ports:\n            - 27017:27017\n        volumes:\n            - mongodata:/data/db\n        healthcheck:\n            test: echo 'db.runCommand(\"ping\").ok' | mongo localhost:27017/test --quiet\n            interval: 10s\n            timeout: 2s\n            retries: 5\n            start_period: 5s\n    loki:\n        image: grafana/loki:2.9.0\n        expose:\n            - 3100\n        command: -config.file=/etc/loki/local-config.yaml\n    promtail:\n        image: grafana/promtail:2.9.0\n        volumes:\n            - logs:/var/log:rw\n            - ./infrastructure/promtail.yml:/etc/promtail/config.yml\n        command: -config.file=/etc/promtail/config.yml\n    prometheus:\n        image: prom/prometheus:latest\n        volumes:\n            - ./infrastructure/prometheus.yml:/etc/prometheus/prometheus.yml\n        command:\n            - '--config.file=/etc/prometheus/prometheus.yml'\n        expose:\n            - 9090\n    grafana:\n        image: grafana/grafana:latest\n        volumes:\n            - grafanadata:/var/lib/grafana\n        environment:\n            - GF_PATHS_PROVISIONING=/etc/grafana/provisioning\n            - GF_AUTH_ANONYMOUS_ENABLED=true\n            - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin\n        ports:\n            - 3000:3000\nvolumes:\n    mongodata:\n    grafanadata:\n    logs:\n```\n\n<div class=\"content-ad\"></div>\n\n모두 Git push가 발생할 때마다 GitHub Actions CI가 빌드를 실행합니다. CI 중에는 종속성 설치, 린터 실행 및 모든 테스트 실행을 진행하고 있어요:\n\n```js\nname: App CI\non:\n  push:\n    branches:\n      - \"*\"\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 20\n          cache: \"yarn\"\n      - run: yarn install --frozen-lockfile\n      - run: yarn run lint\n      - run: docker-compose up -d mongo\n      - run: yarn test -- --verbose --coverage\n      - run: docker-compose build\n      - run: docker-compose logs\n        if: always()\n      - run: docker-compose down --volumes\n        if: always()\n```\n\n# 결론\n\nNode.js는 강력한 기술입니다. 더 중요한 것은 Node.js 커뮤니티가 매우 크다는 것이에요. 새로운 웹 서비스를 개발할 때마다 다른 스택을 사용할 수 있어요. 하지만 저는 이 방법을 추천하지 않아요; 만일 능숙한 Node.js 웹 개발자가 되고 싶다면 먼저 특정 기술의 기능을 익히고, 그런 다음에 다른 스택을 사용해보는 것이 좋아요.\n\n<div class=\"content-ad\"></div>\n\n이 게시물에서 웹 애플리케이션을 구축하는 데 사용한 스택은 Node.js 웹 서비스를 구축하는 데 가장 인기가 많습니다. 구현중인 다양한 기능에 도움이되는 많은 문서와 라이브러리가 있습니다.\n\nNode.js로 이전에 설정한 모든 비기능 요구 사항을 쉽게 달성할 수 있습니다. Kubernetes를 사용하여 응용 프로그램 도커 이미지를 작성하고 호스팅할 수 있습니다. Kubernetes는 배포 정의를 변경하여 응용 프로그램을 빠르게 확장하거나 축소하는 데 도움을줍니다. 또한 Kubernetes는 들어오는 트래픽에 따라 응용 프로그램을 확장할 수 있습니다. 또한 MongoDB는 필요에 따라 확장할 수 있도록 설계되어 있어서 트래픽 증가가 문제가 되지 않습니다.\n\nGoogle의 V8 Node.js 엔진을 통해 더 나은 응용 프로그램 성능을 달성할 수 있습니다. 소스 코드가 기계 코드로 번역되는 속도는 인상적입니다!\n\nNode.js를 사용하면 내결함성 있는 응용 프로그램을 구축하는 방법에 대한 다양한 인터넷 기사를 찾을 수 있습니다. 최선의 방법을 따라주세요! 또한 응용 프로그램 코드에서는 예기치 않은 연결 실패(네트워크 문제 또는 MongoDB 장애 등) 후 MongoDB 연결을 복원하는 데 시간을 소비했습니다. 이를 확인하고 응용 프로그램에 적용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nJest를 사용하면 애플리케이션을 위한 다양한 테스트를 작성하고 100%의 테스트 커버리지를 달성할 수 있어요. 몇 가지 까다로운 시나리오도 Jest를 사용하여 에뮬레이션할 수 있어요.\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png","tag":["Tech"],"readingTime":21},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png\" alt=\"Image\"></p>\n<p>자바스크립트는 프로그래밍 언어 평가에서 주요 위치를 유지하고 있습니다. 자바스크립트에는 브라우저와 Node.js 두 가지 구현이 있습니다. 후자는 웹 서비스 개발에 널리 사용됩니다.</p>\n<p>IT 경력을 시작한 지 약 여덟 년 전에 자바스크립트를 배우기 시작했고, 몇 년 전에 David Flanagan의 훌륭한 책 \"JavaScript: The Definitive Guide\"를 읽었습니다.</p>\n<p>이 책은 많은 질문에 답하고 흥미로운 자바스크립트 레시피를 보여줬는데, 이를 내 업무에 적용하고 있습니다. 그러나 더 중요한 것은, Node.js로 웹 서비스 개발에 초점을 맞추게 됐습니다 (이전에는 JS를 프론트엔드 개발에만 사용). 이 책을 새로운 자바스크립트 개발자뿐만 아니라 경험있는 개발자에게도 추천합니다.</p>\n<p>이 게시물에서는 Node.js를 사용하여 마이크로서비스를 구축하는 방법을 소개하려고 합니다. 웹 개발 경험을 기반으로 인기 있는 Node.js 스택을 활용하여 확장 가능하고 견고하며 신뢰성 있고 성능이 우수한 솔루션을 만들어 보겠습니다.</p>\n<h1>소개</h1>\n<p>이 글에서는 작업 관리 웹 서비스 예시에 마이크로서비스를 구축하는 방법을 보여드리려고 합니다. 다음 API를 제공할 것입니다:</p>\n<ul>\n<li>이름과 설명으로 작업 생성;</li>\n<li>식별자로 작업 가져오기;</li>\n<li>작업 상태/이름/설명 업데이트.</li>\n</ul>\n<p>Node.js로 웹 애플리케이션을 빌드할 때 얼마나 강력한지 보여주는 간단한 API입니다. 개발 프로세스가 빠르고 쉽습니다.</p>\n<p>몇 가지 애플리케이션 요구 사항:</p>\n<ul>\n<li>작업은 상태 'new'로 생성되어야 합니다.</li>\n<li>사용 가능한 상태 전이: 'new'에서 'active'로, 'new'에서 'canceled'로, 'active'에서 'completed'로, 'active'에서 'canceled'로.</li>\n<li>경쟁 상태를 피하십시오 (자세한 내용은 나중에).</li>\n</ul>\n<p>주요 비기능 요구 사항은:</p>\n<ul>\n<li>확장성 — 마이크로서비스는 증가하는 요청 양을 처리할 수 있어야 합니다.</li>\n<li>탄력성 — 마이크로서비스는 즉각 처리할 수 있어야 합니다.</li>\n<li>성능 — 마이크로서비스는 빠르게 응답하여 더 나은 사용자 경험을 제공해야 합니다.</li>\n<li>복원력 — 마이크로서비스는 장애에 대해 허용하고 회복할 수 있어야 하므로 올바르게 기능을 계속 수행할 수 있어야 합니다.</li>\n<li>모니터링 — 마이크로서비스는 건강을 모니터링하는 방법을 제공해야 합니다.</li>\n<li>관찰가능성 — 마이크로서비스는 로그 스트림 및 메트릭을 생성하여 유지할 수 있어야 합니다.</li>\n<li>테스트 용이성 — 마이크로서비스는 쉽게 테스트할 수 있어야 합니다.</li>\n<li>상태를 유지하지 않음 — 마이크로서비스는 클라이언트 컨텍스트를 저장하지 않아야 하며 대신 상태는 데이터베이스에 저장되어야 합니다.</li>\n<li>배포 용이성 — 마이크로서비스는 쉽게 배포 및 업데이트할 수 있어야 합니다.</li>\n</ul>\n<p>Node.js로 웹 애플리케이션을 개발할 때 모두 가능합니다. 다음 단계에서 이러한 요구사항을 어떻게 달성할지 논의해보겠습니다.</p>\n<h1>스택</h1>\n<p>웹 서비스를 구축하기 위해 사용할 기술 스택을 처음부터 선택해야 합니다. 물론, 가장 먼저 고려해야 할 질문은 프로그래밍 언어입니다. 이 마이크로서비스에서는 Node.js를 사용할 것이지만, 그럼에도 불구하고, 웹 서비스 개발에 사용하는 데 Node.js의 몇 가지 이점을 소개해 드리겠습니다.</p>\n<ul>\n<li>자바스크립트는 이미 프론트엔드 개발의 주요 언어이며, 백엔드 개발에도 사용하는 것이 합리적입니다. 이렇게 하면 동일한 개발자가 풀 스택 애플리케이션을 개발할 수 있습니다.</li>\n<li>자바스크립트 커뮤니티는 엄청나게 큽니다. 개발 중 발생할 수 있는 모든 질문에 대한 답변을 찾을 수 있습니다. 또한 많은 라이브러리가 커뮤니티에 의해 개발되고 유지보수됩니다. 유사한 문제를 해결하는 다른 서드파티를 찾을 수 있으며, 각각 고유한 기능을 가집니다.</li>\n<li>노드.제이에스는 구글의 V8 엔진을 사용하여 자바스크립트를 해석하며, 이를 빠르게 기계 코드로 컴파일합니다.</li>\n</ul>\n<p>그리고 이런식으로 계속됩니다! 하지만 가장 중요한 질문은 아닙니다.</p>\n<h2>데이터베이스</h2>\n<p>웹 요청간 데이터를 유지하고 싶습니다. 확장 가능한 상태 유지 웹 서비스를 개발하는 것은 복잡한 작업입니다. 그래서 웹 애플리케이션을 상태가 없는 상태로 유지하고 개별적으로 상태를 외부 데이터베이스에 유지하는 것이 권장됩니다.</p>\n<p>이 서비스를 개발하기 위해 인기 있는 문서 지향 데이터베이스 MongoDB를 사용할 것입니다.</p>\n<p>MongoDB는 SQL 데이터베이스보다 몇 가지 이점을 제공하는 NoSQL 데이터베이스입니다:</p>\n<ul>\n<li>스키마 무료 — MongoDB 컬렉션 (SQL 테이블에 해당하는)은 다른 스키마를 가진 문서를 보유할 수 있습니다. 문서를 컬렉션에 저장하기 전에 구조를 먼저 정의할 필요가 없습니다;</li>\n<li>확장성 — MongoDB는 여러 서버에 걸쳐 확장 가능하게 설계되었습니다;</li>\n<li>성능 — MongoDB는 읽기 중심 작업에 최적화되어 있으며 대량의 데이터를 저장할 수 있습니다.</li>\n</ul>\n<p>Node.js 웹 서비스를 개발할 때 인기 있는 선택 사항입니다.</p>\n<h1>웹 프레임워크</h1>\n<p>웹 프레임워크는 웹 애플리케이션을 구축하는 데 필요합니다. 웹 서비스 개발 시 필요한 많은 일상적인 작업을 처리합니다. 예를 들면 라우팅, 보안, 바인딩 등이 있습니다.</p>\n<p>Node.js 웹 프레임워크에는 다양한 옵션이 있습니다. 그중에서 가장 인기 있는 것은 express입니다:</p>\n<p>express의 가장 큰 장점은 사용하기 간편하며 웹 서버를 시작하는 데 필요한 코드가 최소량으로만 필요하다는 것입니다. express로 작성된 'Hello, World!' 예제가 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>)\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>()\n<span class=\"hljs-keyword\">const</span> port = <span class=\"hljs-number\">3000</span>;\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'/'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =></span> {\n  res.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">'Hello World!'</span>)\n})\napp.<span class=\"hljs-title function_\">listen</span>(port, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Example app listening on port <span class=\"hljs-subst\">${port}</span>`</span>)\n})\n</code></pre>\n<p>또한, Express는 많은 커뮤니티가 있는데, 서버 기능을 확장하는 다양한 라이브러리(일반적으로 미들웨어로 개발됨)들을 찾을 수 있습니다.</p>\n<h1>유효성 검사</h1>\n<p>유효성 검사는 웹 애플리케이션의 중요한 부분입니다. 사용자가 API를 어떻게 사용할지 알 수 없기 때문에, 침입자가 잘못된 입력을 제공하여 응용프로그램을 손상시킬 수 있습니다.</p>\n<p>웹 요청에서 제공된 매개변수(경로, 본문 등)를 확인하고 올바른지 확인하기 위해 joi를 사용할 거에요:</p>\n<p>joi는 다양한 모델을 확인하는 데 사용되는 강력한 라이브러리에요. 나중에 개발할 요청 중 하나를 확인하는 예시가 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> createTask = {\n  <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Joi</span>.<span class=\"hljs-title function_\">object</span>().<span class=\"hljs-title function_\">keys</span>({\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Joi</span>.<span class=\"hljs-title function_\">string</span>().required(),\n    <span class=\"hljs-attr\">description</span>: <span class=\"hljs-title class_\">Joi</span>.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">optional</span>(),\n  }),\n};\n</code></pre>\n<p>이는 객체가 두 개의 문자열을 가진 중첩된 body 객체를 갖는지 확인하며, 이 문자열은 필수인 name과 선택적인 description이에요.</p>\n<p>하지만 그것만이 아닙니다. 컬렉션을 삭제할 수 있는 위험한 MongoDB 인젝션을 제공하는 경우가 여전히 있습니다. 웹 요청을 정리하기 위해 express-mongo-sanitize 패키지를 사용할 것입니다:</p>\n<h1>설정</h1>\n<p>동일한 빌드 아티팩트를 다른 환경에서 실행할 수 있도록 응용 프로그램을 구성할 필요가 있습니다. 이를 위해 환경 변수를 통해 구성을 제공하는 것이 표준 접근 방식입니다.</p>\n<p>응용 프로그램을 시작하기 전에 로컬 머신에서 환경 변수를 수동으로 설정하고 싶지 않을 것입니다. 이 문제에 대한 인기 있는 Node.js 솔루션은 dotenv 라이브러리에 구현되어 있습니다:</p>\n<p>이 라이브러리는 .env(파일 이름을 변경할 수 있음)이라는 파일에서 내용을 로드하고 이 파일의 내용을 환경 변수로 설정합니다.</p>\n<h1>정적 분석</h1>\n<p>JavaScript 애플리케이션의 경우 ESLint 라이브러리를 설치하여 코드 스타일을 쉽게 강제하고 응용 프로그램을 개발할 때 동일한 규칙을 따를 수 있습니다:</p>\n<p>ESLint는 코드 품질을 향상하고 몇 가지 버그를 감지할 수 있습니다. 보안 취약점을 식별할 수 있습니다. CI(지속적 통합) 중에 ESLint 검사를 포함하여 팀원들이 ESLint에서 소개한 규칙을 준수하도록 강제할 수 있습니다. 나중에 이를 수행할 예정입니다.</p>\n<h1>테스트</h1>\n<p>애플리케이션을 변경할 때 이전과 동일하게 작동하는지 확인하기 위해 자동 테스트를 작성하는 것이 좋은 실천법입니다. 단위, 통합, 부하, 엔드-투-엔드 (E2E) 등 다양한 테스트 유형이 있습니다. 애플리케이션의 품질과 성능을 확신하려면 더 많은 테스트가 필요합니다.</p>\n<p>JavaScript 애플리케이션을 테스트하기 위한 가장 인기 있는 라이브러리 중 하나는 Jest입니다:</p>\n<p>Jest를 사용하여 단위 및 통합 테스트를 구현할 것입니다. 이러한 테스트는 나중에 코드를 개선하고 리팩토링하는 데 도움이 되었으며 애플리케이션이 손상되지 않았음을 확인했습니다.</p>\n<h1>로깅</h1>\n<p>애플리케이션 로그 스트림은 웹 서비스를 원격으로 디버깅하는 데 도움이 됩니다. 코드 실행 경로를 식별하고 요청 로직을 다양한 상황에서 설명할 수 있습니다. 코드에 로그를 삽입하면 이점을 누릴 수 있습니다.</p>\n<p>JavaScript 로그를 수집하는 가장 인기 있는 패키지는 winston입니다:</p>\n<p>winston은 간단하지만 강력한 로깅 라이브러리로, 다양한 전송 방법(콘솔, 파일 등)을 사용하여 로그를 수집하는 데 도움을 줍니다. 로그 형식(간단한 텍스트, JSON 등)도 변경할 수 있습니다.</p>\n<h1>메트릭</h1>\n<p>메트릭을 통해 응용 프로그램의 상태를 모니터링할 수 있어요. 들어오는 요청의 수, 평균 요청 실행 시간, 5XX 응답의 수 등을 확인할 수 있습니다. 메트릭을 통해 어떠한 문제가 발생할 경우 이메일, 알림 등을 통해 알림을 받을 수 있는 다양한 모니터를 설정할 수 있어요.</p>\n<p>제 응용 프로그램에서는 express-prom-bundle이라는 표준 웹 응용 프로그램 메트릭을 수집하는 Prometheus 미들웨어를 설치할 예정이에요.</p>\n<p>다음 섹션에서 Prometheus에 대해 더 자세히 알아볼 거예요.</p>\n<h1>모니터링 스택</h1>\n<p>로그 스트림 및 메트릭은 나중에 모니터링하거나 시각화하는 데 사용할 수 있도록 일부 데이터베이스에 수집되어야 합니다.</p>\n<p>로그 및 메트릭을 수집하고 시각화하기 위해 다음 스택을 사용할 것입니다:</p>\n<ul>\n<li>Prometheus — 메트릭을 수집하기 위해 풀 모델을 사용하는 오픈 소스 모니터링 경보 툴킷;</li>\n<li>Promtail — 로그를 포함하고 전송하는 에이전트;</li>\n<li>Loki — 로그 집계 시스템;</li>\n<li>Grafana — 관측 가능성 시스템.</li>\n</ul>\n<h1>로컬 인프라스트럭처</h1>\n<p>로컬에서 애플리케이션을 개발하고 테스트하기 위해 필요한 로컬 스택을 만들기 위해 도커를 사용할 거예요.</p>\n<p>도커를 사용하면 스테이징 및 프로덕션 환경에서 사용될 것과 유사한 로컬 환경을 시작할 수 있어요. 로컬 컴퓨터에 많은 도구를 설치할 필요가 없어요. 대신 필요한 스택을 시작하기 위해 몇 가지 명령을 실행할 수 있어요.</p>\n<p>도커 컴포즈를 사용하면 단일 compose.yml 파일로 모든 인프라스트럭처를 정의하고 단일 명령으로 시작할 수 있어요.</p>\n<pre><code class=\"hljs language-js\">도커 컴포즈 업 -d\n</code></pre>\n<h1>지속적 통합</h1>\n<p>커밋이 무엇인가를 망가뜨리지 않았는지 확인하기 위해, 지속적 통합(CI)가 필요합니다.</p>\n<p>이를 위해, 저는 GitHub Actions를 사용할 것입니다:</p>\n<p>GitHub 계정에는 무료 티어가 있어서 애플리케이션 코드를 확인하기 위해 간단한 빌드를 실행할 수 있어요.</p>\n<h1>애플리케이션 개발</h1>\n<p>애플리케이션 구조를 시작했고 적절한 프로젝트 스타일을 따르는 데 도움이 된 훌륭한 저장소를 찾았어요:</p>\n<p>이 저장소에서 코드 일부(예: 유효성 검사 미들웨어)를 빌려왔기 때문에 여러분이 확인하도록 추천드려요.</p>\n<p>나중에 저장소 링크를 공유할 건데, 그 전에 재미있는 애플리케이션 부분을 보여주고 싶어요.</p>\n<p>나는 mongoose를 사용해서 애플리케이션을 MongoDB와 통합했어요. 먼저, 모델의 스키마를 정의했어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> mongoose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mongoose'</span>);\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">Schema</span> } = mongoose;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">TaskSchema</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Schema</span>(\n  {\n    <span class=\"hljs-attr\">name</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n    },\n    <span class=\"hljs-attr\">description</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">false</span>,\n    },\n    <span class=\"hljs-attr\">status</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>,\n      <span class=\"hljs-attr\">enum</span>: [<span class=\"hljs-string\">'new'</span>, <span class=\"hljs-string\">'active'</span>, <span class=\"hljs-string\">'completed'</span>, <span class=\"hljs-string\">'cancelled'</span>],\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'new'</span>,\n    },\n    <span class=\"hljs-attr\">createdAt</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Date</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-property\">now</span>,\n    },\n    <span class=\"hljs-attr\">updatedAt</span>: <span class=\"hljs-title class_\">Date</span>,\n  },\n  { <span class=\"hljs-attr\">optimisticConcurrency</span>: <span class=\"hljs-literal\">true</span> },\n);\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = mongoose.<span class=\"hljs-title function_\">model</span>(<span class=\"hljs-string\">'task'</span>, <span class=\"hljs-title class_\">TaskSchema</span>);\n</code></pre>\n<p>이 객체를 사용하여 모델을 유효성 검사하고 코드에서 다양한 MongoDB 작업을 수행할 수 있어요. 이는 작업 업데이트의 예시입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">updateTaskById</span>(<span class=\"hljs-params\">id, { name, description, status }</span>) {\n  <span class=\"hljs-keyword\">if</span> (!name &#x26;&#x26; !description &#x26;&#x26; !status) {\n    <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">'적어도 하나의 업데이트가 필요합니다'</span>, <span class=\"hljs-attr\">code</span>: <span class=\"hljs-variable constant_\">AT_LEAST_ONE_UPDATE_REQUIRED_CODE</span> };\n  }\n\n<span class=\"hljs-keyword\">if</span> (status &#x26;&#x26; !(status <span class=\"hljs-keyword\">in</span> availableUpdates)) {\n    <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">'잘못된 상태입니다'</span>, <span class=\"hljs-attr\">code</span>: <span class=\"hljs-variable constant_\">INVALID_STATUS_CODE</span> };\n  }\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> retry = <span class=\"hljs-number\">0</span>; retry &#x3C; <span class=\"hljs-number\">3</span>; retry += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-comment\">// eslint-disable-next-line no-await-in-loop</span>\n    <span class=\"hljs-keyword\">const</span> task = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Task</span>.<span class=\"hljs-title function_\">findById</span>(id);\n    <span class=\"hljs-keyword\">if</span> (!task) {\n      <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">'작업을 찾을 수 없습니다'</span>, <span class=\"hljs-attr\">code</span>: <span class=\"hljs-variable constant_\">INVALID_STATUS_TRANSITION_CODE</span> };\n    }\n    <span class=\"hljs-keyword\">if</span> (status) {\n      <span class=\"hljs-keyword\">const</span> allowedStatuses = availableUpdates[task.<span class=\"hljs-property\">status</span>];\n      <span class=\"hljs-keyword\">if</span> (!allowedStatuses.<span class=\"hljs-title function_\">includes</span>(status)) {\n        <span class=\"hljs-keyword\">return</span> {\n          <span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">`'<span class=\"hljs-subst\">${task.status}</span>'에서 '<span class=\"hljs-subst\">${status}</span>'(으)로 업데이트할 수 없습니다`</span>,\n          <span class=\"hljs-attr\">code</span>: <span class=\"hljs-variable constant_\">TASK_NOT_FOUND_CODE</span>,\n        };\n      }\n    }\n    task.<span class=\"hljs-property\">status</span> = status ?? task.<span class=\"hljs-property\">status</span>;\n    task.<span class=\"hljs-property\">name</span> = name ?? task.<span class=\"hljs-property\">name</span>;\n    task.<span class=\"hljs-property\">description</span> = description ?? task.<span class=\"hljs-property\">description</span>;\n    task.<span class=\"hljs-property\">updatedAt</span> = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>();\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-comment\">// eslint-disable-next-line no-await-in-loop</span>\n      <span class=\"hljs-keyword\">await</span> task.<span class=\"hljs-title function_\">save</span>();\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n      logger.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">'저장 중 오류 발생'</span>, { error });\n      <span class=\"hljs-keyword\">if</span> (error.<span class=\"hljs-property\">name</span> === <span class=\"hljs-string\">'VersionError'</span>) {\n        <span class=\"hljs-comment\">// eslint-disable-next-line no-continue</span>\n        <span class=\"hljs-keyword\">continue</span>;\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> task;\n  }\n  <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">'병행성 오류'</span>, <span class=\"hljs-attr\">code</span>: <span class=\"hljs-variable constant_\">CONCURRENCY_ERROR_CODE</span> };\n}\n</code></pre>\n<p>가장 흥미로운 부분은 업데이트 후 모델을 저장하는 부분입니다. 격렬한 충돌 문제에 대처하기 위해 낙관적 락을 사용하고 있어요.</p>\n<p>두 개의 동시 요청에서 동일한 작업을 완료하고 취소하려고 하는 상황을 상상해보세요. 두 요청이 모두 상태가 '활성'인 작업을 받고 모델을 저장할 때 충돌이 발생할 수 있어요. 첫 번째 작업의 상태가 '완료'로 변경되고 그런 다음 '취소'로 변경될 수 있습니다(또는 그 반대로). 이는 '완료'-'취소' 및 '취소'-'완료' 전이가 허용되지 않기 때문에 잘못된 동작입니다.</p>\n<p>Mongoose는 낙관적 락으로 이 문제에 대한 해결책을 구현했어요. 낙관적 락은 데이터베이스에서 동시 요청을 처리하는 데 사용되는 전략입니다. 각 문서에는 추가적인 버전 속성이 있어요. 트랜잭션이 모델을 저장/업데이트하려고 할 때 버전을 확인합니다. 버전이 get 쿼리를 수행할 때 받은 버전과 다른 경우, 이미 누군가 문서를 동시에 업데이트했을 수 있어요. 트랜잭션이 중단됩니다(위의 코드에서는 오류가 발생합니다).</p>\n<p>문서 예시:</p>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-string\">\"_id\"</span>: {\n    <span class=\"hljs-string\">\"$oid\"</span>: <span class=\"hljs-string\">\"654e03210948a61665b7c889\"</span>\n  },\n  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"damnatio\"</span>,\n  <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"Ciminatio totus spiritus suffoco damnatio blanditiis.\"</span>,\n  <span class=\"hljs-string\">\"status\"</span>: <span class=\"hljs-string\">\"completed\"</span>,\n  <span class=\"hljs-string\">\"createdAt\"</span>: {\n    <span class=\"hljs-string\">\"$date\"</span>: <span class=\"hljs-string\">\"2023-11-10T10:17:05.039Z\"</span>\n  },\n  <span class=\"hljs-string\">\"__v\"</span>: <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-string\">\"updatedAt\"</span>: {\n    <span class=\"hljs-string\">\"$date\"</span>: <span class=\"hljs-string\">\"2023-11-10T10:17:05.064Z\"</span>\n  }\n}\n</code></pre>\n<p>위의 문서는 속성 __v에 버전을 저장합니다.</p>\n<p>다음 레벨은 컨트롤러입니다. 컨트롤러 예시는 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> updateTaskById = <span class=\"hljs-title function_\">catchAsync</span>(<span class=\"hljs-keyword\">async</span> (req, res) => {\n  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> taskService.<span class=\"hljs-title function_\">updateTaskById</span>(req.<span class=\"hljs-property\">params</span>.<span class=\"hljs-property\">id</span>, req.<span class=\"hljs-property\">body</span>);\n  <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">error</span>) {\n    <span class=\"hljs-keyword\">switch</span> (result.<span class=\"hljs-property\">code</span>) {\n      <span class=\"hljs-keyword\">case</span> taskService.<span class=\"hljs-property\">errorCodes</span>.<span class=\"hljs-property\">AT_LEAST_ONE_UPDATE_REQUIRED_CODE</span>:\n        res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">400</span>).<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'적어도 하나의 업데이트가 필요합니다'</span> });\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> taskService.<span class=\"hljs-property\">errorCodes</span>.<span class=\"hljs-property\">INVALID_STATUS_CODE</span>:\n        res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">400</span>).<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'유효하지 않은 상태'</span> });\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> taskService.<span class=\"hljs-property\">errorCodes</span>.<span class=\"hljs-property\">INVALID_STATUS_TRANSITION_CODE</span>:\n        res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">404</span>).<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'작업을 찾을 수 없음'</span> });\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> taskService.<span class=\"hljs-property\">errorCodes</span>.<span class=\"hljs-property\">TASK_NOT_FOUND_CODE</span>:\n        res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">400</span>).<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">message</span>: result.<span class=\"hljs-property\">error</span> });\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">case</span> taskService.<span class=\"hljs-property\">errorCodes</span>.<span class=\"hljs-property\">CONCURRENCY_ERROR_CODE</span>:\n        res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">500</span>).<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'동시성 오류'</span> });\n        <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-attr\">default</span>:\n        res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">500</span>).<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'내부 서버 오류'</span> });\n        <span class=\"hljs-keyword\">return</span>;\n    }\n  }\n\nres.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">200</span>).<span class=\"hljs-title function_\">json</span>({\n    <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">task</span>: <span class=\"hljs-title function_\">toDto</span>(result),\n  });\n});\n</code></pre>\n<p>이 코드는 애플리케이션 비즈니스 로직을 실행하고 HTTP 응답을 반환합니다. 컨트롤러는 routes 모듈에 등록됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">Router</span> } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n<span class=\"hljs-keyword\">const</span> taskController = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../../../controllers/task'</span>);\n<span class=\"hljs-keyword\">const</span> taskValidation = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../../../validation/task'</span>);\n<span class=\"hljs-keyword\">const</span> validate = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../../../middlewares/validate'</span>);\n\n<span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title class_\">Router</span>();\nrouter.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'/:id'</span>, <span class=\"hljs-title function_\">validate</span>(taskValidation.<span class=\"hljs-property\">getTaskById</span>), taskController.<span class=\"hljs-property\">getTaskById</span>);\nrouter.<span class=\"hljs-title function_\">put</span>(<span class=\"hljs-string\">'/'</span>, <span class=\"hljs-title function_\">validate</span>(taskValidation.<span class=\"hljs-property\">createTask</span>), taskController.<span class=\"hljs-property\">createTask</span>);\nrouter.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">'/:id'</span>, <span class=\"hljs-title function_\">validate</span>(taskValidation.<span class=\"hljs-property\">updateTaskById</span>), taskController.<span class=\"hljs-property\">updateTaskById</span>);\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = router;\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@swagger</span>\n * tags:\n *  name: Tasks\n *  description: 작업 관리 및 검색\n * /v1/tasks/{id}:\n *  get:\n *   summary: ID로 작업 가져오기\n *   tags: [Tasks]\n *   description: ID로 작업 가져오기\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   responses:\n *    200:\n *     description: 작업 검색됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    404:\n *     description: 작업을 찾을 수 없음\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n *  post:\n *   summary: ID로 작업 업데이트\n *   tags: [Tasks]\n *   description: ID로 작업 업데이트\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/UpdateTask'\n *   responses:\n *    200:\n *     description: 작업 업데이트됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *     404:\n *      description: 작업을 찾을 수 없음\n *      content:\n *       application/json:\n *        schema:\n *         $ref: '#/components/schemas/TaskResult'\n *     500:\n *      description: 내부 서버 오류\n * /v1/tasks:\n *  put:\n *   summary: 작업 생성\n *   tags: [Tasks]\n *   description: 작업 생성\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/CreateTask'\n *   responses:\n *    201:\n *     description: 작업 생성됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n */</span>\n</code></pre>\n<p>맨 아래에서는 Swagger 미들웨어가 사용하는 OpenAPI 사양이 API 문서 페이지를 생성하는 데 사용됨을 볼 수 있습니다.</p>\n<p>각 경로 등록은 두 개의 핸들러를 사용합니다: 유효성 검사기와 컨트롤러 메서드 자체입니다. 유효성 검사기는 서로 다른 모델에 등록된 스키마를 유효성 검사합니다. 유효성 검사기 핸들러:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Joi</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'joi'</span>);\n<span class=\"hljs-keyword\">const</span> pick = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../utils/pick'</span>);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">validate</span>(<span class=\"hljs-params\">schema</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res, next</span>) =></span> {\n    <span class=\"hljs-keyword\">const</span> validSchema = <span class=\"hljs-title function_\">pick</span>(schema, [<span class=\"hljs-string\">'params'</span>, <span class=\"hljs-string\">'query'</span>, <span class=\"hljs-string\">'body'</span>]);\n    <span class=\"hljs-keyword\">const</span> object = <span class=\"hljs-title function_\">pick</span>(req, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(validSchema));\n    <span class=\"hljs-keyword\">const</span> { value, error } = <span class=\"hljs-title class_\">Joi</span>.<span class=\"hljs-title function_\">compile</span>(validSchema)\n      .<span class=\"hljs-title function_\">prefs</span>({ <span class=\"hljs-attr\">errors</span>: { <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">'key'</span> }, <span class=\"hljs-attr\">abortEarly</span>: <span class=\"hljs-literal\">false</span> })\n      .<span class=\"hljs-title function_\">validate</span>(object);\n    <span class=\"hljs-keyword\">if</span> (error) {\n      <span class=\"hljs-keyword\">const</span> errorMessage = error.<span class=\"hljs-property\">details</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">details</span>) =></span> details.<span class=\"hljs-property\">message</span>).<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">', '</span>);\n      res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">400</span>).<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">message</span>: errorMessage });\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(req, value);\n    <span class=\"hljs-title function_\">next</span>();\n  };\n}\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = validate;\n</code></pre>\n<p>또한 업데이트 요청 유효성 검사 스키마가 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> updateTaskById = {\n  <span class=\"hljs-attr\">params</span>: <span class=\"hljs-title class_\">Joi</span>.<span class=\"hljs-title function_\">object</span>().<span class=\"hljs-title function_\">keys</span>({\n    <span class=\"hljs-attr\">id</span>: objectId.required(),\n  }),\n  <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Joi</span>.<span class=\"hljs-title function_\">object</span>().<span class=\"hljs-title function_\">keys</span>({\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Joi</span>.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">optional</span>(),\n    <span class=\"hljs-attr\">description</span>: <span class=\"hljs-title class_\">Joi</span>.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">optional</span>(),\n    <span class=\"hljs-attr\">status</span>: <span class=\"hljs-title class_\">Joi</span>.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">valid</span>(<span class=\"hljs-string\">'new'</span>, <span class=\"hljs-string\">'active'</span>, <span class=\"hljs-string\">'completed'</span>, <span class=\"hljs-string\">'cancelled'</span>).<span class=\"hljs-title function_\">optional</span>(),\n  }),\n};\n</code></pre>\n<p>업데이트 메서드에 대해 말씀드리겠습니다. 저는 통합 테스트만 구현했습니다. 통합 테스트는 모든 테스트가 실행되기 전과 후에 서버를 시작하고 중지합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../../src/app'</span>);\n<span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../../src/db'</span>);\n<span class=\"hljs-keyword\">const</span> { createConfig } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../../src/config/config'</span>);\n<span class=\"hljs-keyword\">const</span> logger = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../../src/config/logger'</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">setupServer</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">let</span> server;\n  <span class=\"hljs-keyword\">const</span> configPath = path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">'../../configs/tests.env'</span>);\n  <span class=\"hljs-keyword\">const</span> config = <span class=\"hljs-title function_\">createConfig</span>(configPath);\n  <span class=\"hljs-title function_\">beforeAll</span>(<span class=\"hljs-keyword\">async</span> () => {\n    logger.<span class=\"hljs-title function_\">init</span>(config);\n    <span class=\"hljs-keyword\">await</span> db.<span class=\"hljs-title function_\">init</span>(config);\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =></span> {\n      server = app.<span class=\"hljs-title function_\">listen</span>(config.<span class=\"hljs-property\">port</span>, <span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-title function_\">resolve</span>();\n      });\n    });\n  });\n  <span class=\"hljs-title function_\">afterAll</span>(<span class=\"hljs-keyword\">async</span> () => {\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =></span> {\n      server.<span class=\"hljs-title function_\">close</span>(<span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-title function_\">resolve</span>();\n      });\n    });\n    <span class=\"hljs-keyword\">await</span> db.<span class=\"hljs-title function_\">destroy</span>();\n    logger.<span class=\"hljs-title function_\">destroy</span>();\n  });\n};\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  setupServer,\n};\n</code></pre>\n<p>그리고 PUT 요청(태스크 생성)과 POST 요청(태스크 업데이트)을 수행하는 테스트가 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">'태스크 생성 및 업데이트'</span>, <span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-keyword\">const</span> data = [\n        {\n          <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'상태만 업데이트'</span>,\n          <span class=\"hljs-attr\">taskName</span>: <span class=\"hljs-string\">'태스크 1'</span>,\n          <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">'태스크 1 설명'</span>,\n          <span class=\"hljs-attr\">newStatus</span>: <span class=\"hljs-string\">'활성'</span>,\n        },\n        {\n          <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'영어 전체 업데이트'</span>,\n          <span class=\"hljs-attr\">taskName</span>: <span class=\"hljs-string\">'태스크 1'</span>,\n          <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">'태스크 1 설명'</span>,\n          <span class=\"hljs-attr\">newTaskName</span>: <span class=\"hljs-string\">'태스크 1 새로운'</span>,\n          <span class=\"hljs-attr\">newDescription</span>: <span class=\"hljs-string\">'태스크 1 새로운 설명'</span>,\n          <span class=\"hljs-attr\">newStatus</span>: <span class=\"hljs-string\">'활성'</span>,\n        },\n        <span class=\"hljs-comment\">// 이하 생략</span>\n      ];\n\ndata.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{\n        name, taskName, description, newTaskName, newDescription, newStatus,\n      }</span>) =></span> {\n        <span class=\"hljs-title function_\">it</span>(name, <span class=\"hljs-keyword\">async</span> () => {\n          <span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(baseUrl, {\n            <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'put'</span>,\n            <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>({\n              <span class=\"hljs-attr\">name</span>: taskName,\n              description,\n            }),\n            <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/json'</span> },\n          });\n          <span class=\"hljs-title function_\">expect</span>(response.<span class=\"hljs-property\">status</span>).<span class=\"hljs-title function_\">toEqual</span>(<span class=\"hljs-number\">201</span>);\n          <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n          <span class=\"hljs-comment\">// 여기서부터 이하는 생략</span>\n        });\n      });\n    });\n</code></pre>\n<p>도커 이미지를 생성하려면 간단한 Dockerfile을 정의했습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">FROM</span> <span class=\"hljs-attr\">node</span>:<span class=\"hljs-number\">20</span>-alpine\n<span class=\"hljs-variable constant_\">WORKDIR</span> /app\n<span class=\"hljs-variable constant_\">COPY</span> package.<span class=\"hljs-property\">json</span> yarn.<span class=\"hljs-property\">lock</span> ./\n<span class=\"hljs-variable constant_\">RUN</span> yarn install --frozen-lockfile\n<span class=\"hljs-variable constant_\">COPY</span> src /app/src\n<span class=\"hljs-variable constant_\">CMD</span> [<span class=\"hljs-string\">\"node\"</span>, <span class=\"hljs-string\">\"./src/index.js\"</span>]\n</code></pre>\n<p>어플리케이션과 인프라를 시작하는 데 사용하는 compose.yml 정의입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">version</span>: <span class=\"hljs-string\">'3.9'</span>\n<span class=\"hljs-attr\">services</span>:\n    <span class=\"hljs-attr\">app</span>:\n        <span class=\"hljs-attr\">build</span>: .\n        <span class=\"hljs-attr\">ports</span>:\n            - <span class=\"hljs-string\">'8081:80'</span>\n        <span class=\"hljs-attr\">depends_on</span>:\n            - mongo\n        <span class=\"hljs-attr\">volumes</span>:\n            - ./configs/docker.<span class=\"hljs-property\">env</span>:<span class=\"hljs-regexp\">/app/</span>configs/.<span class=\"hljs-property\">env</span>\n            - <span class=\"hljs-attr\">logs</span>:<span class=\"hljs-regexp\">/app/</span><span class=\"hljs-attr\">logs</span>:rw\n    <span class=\"hljs-attr\">mongo</span>:\n        <span class=\"hljs-attr\">image</span>: <span class=\"hljs-attr\">mongo</span>:<span class=\"hljs-number\">5</span>\n        <span class=\"hljs-attr\">restart</span>: always\n        <span class=\"hljs-attr\">ports</span>:\n            - <span class=\"hljs-number\">27017</span>:<span class=\"hljs-number\">27017</span>\n        <span class=\"hljs-attr\">volumes</span>:\n            - <span class=\"hljs-attr\">mongodata</span>:<span class=\"hljs-regexp\">/data/</span>db\n        <span class=\"hljs-attr\">healthcheck</span>:\n            <span class=\"hljs-attr\">test</span>: echo <span class=\"hljs-string\">'db.runCommand(\"ping\").ok'</span> | mongo <span class=\"hljs-attr\">localhost</span>:<span class=\"hljs-number\">27017</span>/test --quiet\n            <span class=\"hljs-attr\">interval</span>: 10s\n            <span class=\"hljs-attr\">timeout</span>: 2s\n            <span class=\"hljs-attr\">retries</span>: <span class=\"hljs-number\">5</span>\n            <span class=\"hljs-attr\">start_period</span>: 5s\n    <span class=\"hljs-attr\">loki</span>:\n        <span class=\"hljs-attr\">image</span>: grafana/<span class=\"hljs-attr\">loki</span>:<span class=\"hljs-number\">2.9</span><span class=\"hljs-number\">.0</span>\n        <span class=\"hljs-attr\">expose</span>:\n            - <span class=\"hljs-number\">3100</span>\n        <span class=\"hljs-attr\">command</span>: -config.<span class=\"hljs-property\">file</span>=<span class=\"hljs-regexp\">/etc/</span>loki/local-config.<span class=\"hljs-property\">yaml</span>\n    <span class=\"hljs-attr\">promtail</span>:\n        <span class=\"hljs-attr\">image</span>: grafana/<span class=\"hljs-attr\">promtail</span>:<span class=\"hljs-number\">2.9</span><span class=\"hljs-number\">.0</span>\n        <span class=\"hljs-attr\">volumes</span>:\n            - <span class=\"hljs-attr\">logs</span>:<span class=\"hljs-regexp\">/var/</span><span class=\"hljs-attr\">log</span>:rw\n            - ./infrastructure/promtail.<span class=\"hljs-property\">yml</span>:<span class=\"hljs-regexp\">/etc/</span>promtail/config.<span class=\"hljs-property\">yml</span>\n        <span class=\"hljs-attr\">command</span>: -config.<span class=\"hljs-property\">file</span>=<span class=\"hljs-regexp\">/etc/</span>promtail/config.<span class=\"hljs-property\">yml</span>\n    <span class=\"hljs-attr\">prometheus</span>:\n        <span class=\"hljs-attr\">image</span>: prom/<span class=\"hljs-attr\">prometheus</span>:latest\n        <span class=\"hljs-attr\">volumes</span>:\n            - ./infrastructure/prometheus.<span class=\"hljs-property\">yml</span>:<span class=\"hljs-regexp\">/etc/</span>prometheus/prometheus.<span class=\"hljs-property\">yml</span>\n        <span class=\"hljs-attr\">command</span>:\n            - <span class=\"hljs-string\">'--config.file=/etc/prometheus/prometheus.yml'</span>\n        <span class=\"hljs-attr\">expose</span>:\n            - <span class=\"hljs-number\">9090</span>\n    <span class=\"hljs-attr\">grafana</span>:\n        <span class=\"hljs-attr\">image</span>: grafana/<span class=\"hljs-attr\">grafana</span>:latest\n        <span class=\"hljs-attr\">volumes</span>:\n            - <span class=\"hljs-attr\">grafanadata</span>:<span class=\"hljs-regexp\">/var/</span>lib/grafana\n        <span class=\"hljs-attr\">environment</span>:\n            - <span class=\"hljs-variable constant_\">GF_PATHS_PROVISIONING</span>=<span class=\"hljs-regexp\">/etc/g</span>rafana/provisioning\n            - <span class=\"hljs-variable constant_\">GF_AUTH_ANONYMOUS_ENABLED</span>=<span class=\"hljs-literal\">true</span>\n            - <span class=\"hljs-variable constant_\">GF_AUTH_ANONYMOUS_ORG_ROLE</span>=<span class=\"hljs-title class_\">Admin</span>\n        <span class=\"hljs-attr\">ports</span>:\n            - <span class=\"hljs-number\">3000</span>:<span class=\"hljs-number\">3000</span>\n<span class=\"hljs-attr\">volumes</span>:\n    <span class=\"hljs-attr\">mongodata</span>:\n    <span class=\"hljs-attr\">grafanadata</span>:\n    <span class=\"hljs-attr\">logs</span>:\n</code></pre>\n<p>모두 Git push가 발생할 때마다 GitHub Actions CI가 빌드를 실행합니다. CI 중에는 종속성 설치, 린터 실행 및 모든 테스트 실행을 진행하고 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">App</span> <span class=\"hljs-variable constant_\">CI</span>\n<span class=\"hljs-attr\">on</span>:\n  <span class=\"hljs-attr\">push</span>:\n    <span class=\"hljs-attr\">branches</span>:\n      - <span class=\"hljs-string\">\"*\"</span>\n<span class=\"hljs-attr\">jobs</span>:\n  <span class=\"hljs-attr\">ci</span>:\n    runs-<span class=\"hljs-attr\">on</span>: ubuntu-latest\n    <span class=\"hljs-attr\">steps</span>:\n      - <span class=\"hljs-attr\">uses</span>: actions/checkout@v3\n      - <span class=\"hljs-attr\">uses</span>: actions/setup-node@v3\n        <span class=\"hljs-attr\">with</span>:\n          node-<span class=\"hljs-attr\">version</span>: <span class=\"hljs-number\">20</span>\n          <span class=\"hljs-attr\">cache</span>: <span class=\"hljs-string\">\"yarn\"</span>\n      - <span class=\"hljs-attr\">run</span>: yarn install --frozen-lockfile\n      - <span class=\"hljs-attr\">run</span>: yarn run lint\n      - <span class=\"hljs-attr\">run</span>: docker-compose up -d mongo\n      - <span class=\"hljs-attr\">run</span>: yarn test -- --verbose --coverage\n      - <span class=\"hljs-attr\">run</span>: docker-compose build\n      - <span class=\"hljs-attr\">run</span>: docker-compose logs\n        <span class=\"hljs-attr\">if</span>: <span class=\"hljs-title function_\">always</span>()\n      - <span class=\"hljs-attr\">run</span>: docker-compose down --volumes\n        <span class=\"hljs-attr\">if</span>: <span class=\"hljs-title function_\">always</span>()\n</code></pre>\n<h1>결론</h1>\n<p>Node.js는 강력한 기술입니다. 더 중요한 것은 Node.js 커뮤니티가 매우 크다는 것이에요. 새로운 웹 서비스를 개발할 때마다 다른 스택을 사용할 수 있어요. 하지만 저는 이 방법을 추천하지 않아요; 만일 능숙한 Node.js 웹 개발자가 되고 싶다면 먼저 특정 기술의 기능을 익히고, 그런 다음에 다른 스택을 사용해보는 것이 좋아요.</p>\n<p>이 게시물에서 웹 애플리케이션을 구축하는 데 사용한 스택은 Node.js 웹 서비스를 구축하는 데 가장 인기가 많습니다. 구현중인 다양한 기능에 도움이되는 많은 문서와 라이브러리가 있습니다.</p>\n<p>Node.js로 이전에 설정한 모든 비기능 요구 사항을 쉽게 달성할 수 있습니다. Kubernetes를 사용하여 응용 프로그램 도커 이미지를 작성하고 호스팅할 수 있습니다. Kubernetes는 배포 정의를 변경하여 응용 프로그램을 빠르게 확장하거나 축소하는 데 도움을줍니다. 또한 Kubernetes는 들어오는 트래픽에 따라 응용 프로그램을 확장할 수 있습니다. 또한 MongoDB는 필요에 따라 확장할 수 있도록 설계되어 있어서 트래픽 증가가 문제가 되지 않습니다.</p>\n<p>Google의 V8 Node.js 엔진을 통해 더 나은 응용 프로그램 성능을 달성할 수 있습니다. 소스 코드가 기계 코드로 번역되는 속도는 인상적입니다!</p>\n<p>Node.js를 사용하면 내결함성 있는 응용 프로그램을 구축하는 방법에 대한 다양한 인터넷 기사를 찾을 수 있습니다. 최선의 방법을 따라주세요! 또한 응용 프로그램 코드에서는 예기치 않은 연결 실패(네트워크 문제 또는 MongoDB 장애 등) 후 MongoDB 연결을 복원하는 데 시간을 소비했습니다. 이를 확인하고 응용 프로그램에 적용할 수 있습니다.</p>\n<p>Jest를 사용하면 애플리케이션을 위한 다양한 테스트를 작성하고 100%의 테스트 커버리지를 달성할 수 있어요. 몇 가지 까다로운 시나리오도 Jest를 사용하여 에뮬레이션할 수 있어요.</p>\n<p>즐거운 코딩 되세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}