{"pageProps":{"post":{"title":"Vue3 + Vite 컴포넌트화 하는 방법","description":"","date":"2024-05-01 18:06","slug":"2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas","content":"\n\n# Vue3 + rspack 003: 컴포넌트화의 기술 (Composition API) 및 일반적인 문제 해결 아이디어\n\nVue 3에서 Composition API는 컴포넌트와 로직을 재사용하는 새로운 방법을 제공합니다. 이는 우리의 코드에 더 나은 구성 구조를 제공할 뿐만 아니라 복잡한 컴포넌트 로직을 더 유연하게 처리할 수 있는 기회를 줍니다. 아래에서 탐색해봅시다.\n\n# 컴포넌트 생성 및 사용\n\n컴포넌트는 Vue 애플리케이션의 기본 구성 요소입니다. Composition API에서는 reactive 상태와 컴포넌트의 동작을 정의하기 위해 setup 함수를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n# 예시: 간단한 카운터 컴포넌트\n\n```js\n<template>\n  <button @click=\"increment\">{ count }</button>\n</template><script>\nimport { ref } from 'vue';export default {\n  setup() {\n    const count = ref(0);\n    function increment() {\n      count.value++;\n    }    return { count, increment };\n  };\n</script>\n```\n\n# 실용적인 어려움과 해결책\n\n어려움: Composition API를 사용할 때, 개발자들은 조각난 상태 로직을 경험하여 컴포넌트를 유지하기 어렵게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: 관련 로직을 함수로 캡슐화한 후에 이 함수를 설정(setup)에서 호출하세요. 이렇게 하면 코드의 가독성과 유지보수성이 향상될 수 있습니다.\n\n# 부모 및 자식 컴포넌트 간 통신\n\nVue 3에서 부모 및 자식 컴포넌트 간의 통신은 주로 props와 emit을 통해 이루어집니다. Composition API는 defineProps와 defineEmit 함수를 제공하여이 프로세스를 간단화합니다.\n\n# 예: 부모-자식 컴포넌트 간 통신\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- ChildComponent.vue -->\n<template>\n  <div @click=\"emitToParent\">나를 클릭해주세요!</div>\n</template>\n<script>\nimport { defineProps, defineEmit } from 'vue';\nexport default {\n  setup() {\n    const props = defineProps(['messageFromParent']);\n    const emit = defineEmit(['messageToParent']);\n    \n    function emitToParent() {\n      emit('messageToParent', '안녕하세요, 부모님!');\n    }\n    \n    return { emitToParent };\n  }\n};\n</script>\n\n<!-- ParentComponent.vue -->\n<template>\n  <ChildComponent\n    :messageFromParent=\"parentMessage\"\n    @messageToParent=\"handleMessageFromChild\"\n  />\n</template>\n<script>\nimport { ref } from 'vue';\nimport ChildComponent from './components/ChildComponent.vue';\nexport default {\n  components: {\n    ChildComponent\n  },\n  setup() {\n    const parentMessage = ref('안녕하세요, 자식님!');\n    \n    function handleMessageFromChild(message) {\n      console.log(message);\n    }\n    \n    return { parentMessage, handleMessageFromChild };\n  }\n};\n</script>\n```\n\n# 실용적인 어려움과 해결책\n\n어려움 : 대규모 어플리케이션에서는 종종 다층 중첩된 컴포넌트 간의 통신 요구사항이 발생합니다. 직접 props와 emit을 사용하면 \"props를 계층적으로 전달하는\" 및 \"이벤트를 계층적으로 발생시키는\" 문제가 발생할 수 있습니다.\n\n해결책 : 이러한 번거로운 계층별 전달을 피하기 위해 Vue 3의 provide 및 inject API를 사용하여 컴포넌트 간 수준의 통신을 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 슬롯 사용\n\n슬롯을 사용하면 자식 컴포넌트의 내용으로 어떤 템플릿 코드든 부모 컴포넌트에 전달할 수 있습니다. Composition API에서는 슬롯 내용에 접근할 수 있습니다.\n\n# 예시: 슬롯 사용하기\n\n```js\n<!-- BaseLayout.vue -->\n<template>\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</template>\n<script>\nimport { useSlots } from 'vue';\nexport default {\n  setup() {\n    const slots = useSlots();\n    return { slots };\n  }\n};\n</script>\n<!-- App.vue -->\n<template>\n  <BaseLayout>\n    <template #header>\n      <h1>여기에 페이지 제목이 올 수 있어요</h1>\n    </template>\n    <p>페이지의 주요 내용</p>\n    <template #footer>\n      <p>여기에 연락처 정보가 있습니다</p>\n    </template>\n  </BaseLayout>\n</template>\n<script>\nimport BaseLayout from './components/BaseLayout.vue';\nexport default {\n  components: {\n    BaseLayout\n  }\n};\n</script>\n```\n\n<div class=\"content-ad\"></div>\n\n# 실용적인 어려움과 해결책\n\n어려움: 이름이 지정된 슬롯을 사용할 때, 슬롯 콘텐츠를 자식 컴포넌트의 상태 또는 동작에 따라 동기화하는 것이 복잡할 수 있습니다.\n\n해결책: scoped 슬롯을 사용할 수 있습니다. scoped 슬롯을 사용하면 자식 컴포넌트가 부모 컴포넌트에 데이터를 노출시킬 수 있고 그 데이터를 부모 컴포넌트의 슬롯 콘텐츠에서 사용할 수 있습니다.\n\n# 동적 컴포넌트와 비동기 컴포넌트\n\n<div class=\"content-ad\"></div>\n\nVue 3는 defineAsyncComponent를 통해 비동기 컴포넌트를 지원합니다. 동적 컴포넌트는 내장 `component` 태그와 `:` 속성을 사용하여 구현할 수 있습니다.\n\n# 예시: 비동기 컴포넌트\n\n```js\n// defineAsyncComponent를 사용하여 비동기 컴포넌트 로드\nimport { defineAsyncComponent } from 'vue';export default {\n  components: {\n    AsyncComponent: defineAsyncComponent(() =>\n      import('./components/AsyncComponent.vue')\n    )\n  }\n};\n```\n\n# 예시: 동적 컴포넌트\n\n<div class=\"content-ad\"></div>\n\n```js\n<template>\n  <component :is=\"currentComponent\" />\n</template>\n<script>\nimport { ref } from 'vue';\nimport ComponentA from './components/ComponentA.vue';\nimport ComponentB from './components/ComponentB.vue';\nexport default {\n  setup() {\n    const currentComponent = ref('ComponentA');    // 실제 상황에 맞게 currentComponent의 값을 변경하여 컴포넌트를 전환할 수 있습니다.\n    \n    // currentComponent.value = 'ComponentB';\n    \n    return { currentComponent, ComponentA, ComponentB };\n  }\n};\n</script>\n```\n\n# 실용적인 어려움과 해결책\n\n어려움: 비동기 컴포넌트를 사용할 때 컴포넌트 로딩 지연이나 실패와 같은 문제가 발생할 수 있어 사용자 경험에 영향을 줄 수 있습니다.\n\n해결책: 로딩 상태 힌트 및 오류 처리 매커니즘을 제공할 수 있습니다. 예를 들어, Suspense 컴포넌트를 사용하여 비동기 컴포넌트를 감쌀 수 있고 대체 콘텐츠(대체 콘텐츠)를 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<template>\n  <Suspense>\n    <template #default>\n      <AsyncComponent />\n    </template>\n    <template #fallback>\n      <div>Loading...</div>\n    </template>\n  </Suspense>\n</template>\n```\n\n위의 예제와 해결책을 통해 Vue 3의 모듈화 및 Composition API가 강력한 기능과 유연성을 제공하여 우리가 실용적인 개발 문제를 더 잘 해결하고 우아한 방식으로 복잡한 애플리케이션을 구축할 수 있음을 볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png"},"coverImage":"/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>Vue3 + rspack 003: 컴포넌트화의 기술 (Composition API) 및 일반적인 문제 해결 아이디어</h1>\n<p>Vue 3에서 Composition API는 컴포넌트와 로직을 재사용하는 새로운 방법을 제공합니다. 이는 우리의 코드에 더 나은 구성 구조를 제공할 뿐만 아니라 복잡한 컴포넌트 로직을 더 유연하게 처리할 수 있는 기회를 줍니다. 아래에서 탐색해봅시다.</p>\n<h1>컴포넌트 생성 및 사용</h1>\n<p>컴포넌트는 Vue 애플리케이션의 기본 구성 요소입니다. Composition API에서는 reactive 상태와 컴포넌트의 동작을 정의하기 위해 setup 함수를 사용합니다.</p>\n<h1>예시: 간단한 카운터 컴포넌트</h1>\n<pre><code class=\"hljs language-js\">&#x3C;template>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"increment\"</span>></span>{ count }<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></span>\n&#x3C;/template><span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>;<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-title function_\">setup</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">increment</span>(<span class=\"hljs-params\"></span>) {\n      count.<span class=\"hljs-property\">value</span>++;\n    }    <span class=\"hljs-keyword\">return</span> { count, increment };\n  };\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></span>\n</code></pre>\n<h1>실용적인 어려움과 해결책</h1>\n<p>어려움: Composition API를 사용할 때, 개발자들은 조각난 상태 로직을 경험하여 컴포넌트를 유지하기 어렵게 만들 수 있습니다.</p>\n<p>해결책: 관련 로직을 함수로 캡슐화한 후에 이 함수를 설정(setup)에서 호출하세요. 이렇게 하면 코드의 가독성과 유지보수성이 향상될 수 있습니다.</p>\n<h1>부모 및 자식 컴포넌트 간 통신</h1>\n<p>Vue 3에서 부모 및 자식 컴포넌트 간의 통신은 주로 props와 emit을 통해 이루어집니다. Composition API는 defineProps와 defineEmit 함수를 제공하여이 프로세스를 간단화합니다.</p>\n<h1>예: 부모-자식 컴포넌트 간 통신</h1>\n<pre><code class=\"hljs language-js\">&#x3C;!-- <span class=\"hljs-title class_\">ChildComponent</span>.<span class=\"hljs-property\">vue</span> -->\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"emitToParent\"</span>></span>나를 클릭해주세요!<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> { defineProps, defineEmit } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-title function_\">setup</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> props = <span class=\"hljs-title function_\">defineProps</span>([<span class=\"hljs-string\">'messageFromParent'</span>]);\n    <span class=\"hljs-keyword\">const</span> emit = <span class=\"hljs-title function_\">defineEmit</span>([<span class=\"hljs-string\">'messageToParent'</span>]);\n    \n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">emitToParent</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">'messageToParent'</span>, <span class=\"hljs-string\">'안녕하세요, 부모님!'</span>);\n    }\n    \n    <span class=\"hljs-keyword\">return</span> { emitToParent };\n  }\n};\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></span>\n\n&#x3C;!-- <span class=\"hljs-title class_\">ParentComponent</span>.<span class=\"hljs-property\">vue</span> -->\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ChildComponent</span>\n    <span class=\"hljs-attr\">:messageFromParent</span>=<span class=\"hljs-string\">\"parentMessage\"</span>\n    @<span class=\"hljs-attr\">messageToParent</span>=<span class=\"hljs-string\">\"handleMessageFromChild\"</span>\n  /></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ChildComponent</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./components/ChildComponent.vue'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">components</span>: {\n    <span class=\"hljs-title class_\">ChildComponent</span>\n  },\n  <span class=\"hljs-title function_\">setup</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> parentMessage = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-string\">'안녕하세요, 자식님!'</span>);\n    \n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleMessageFromChild</span>(<span class=\"hljs-params\">message</span>) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message);\n    }\n    \n    <span class=\"hljs-keyword\">return</span> { parentMessage, handleMessageFromChild };\n  }\n};\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></span>\n</code></pre>\n<h1>실용적인 어려움과 해결책</h1>\n<p>어려움 : 대규모 어플리케이션에서는 종종 다층 중첩된 컴포넌트 간의 통신 요구사항이 발생합니다. 직접 props와 emit을 사용하면 \"props를 계층적으로 전달하는\" 및 \"이벤트를 계층적으로 발생시키는\" 문제가 발생할 수 있습니다.</p>\n<p>해결책 : 이러한 번거로운 계층별 전달을 피하기 위해 Vue 3의 provide 및 inject API를 사용하여 컴포넌트 간 수준의 통신을 할 수 있습니다.</p>\n<h1>슬롯 사용</h1>\n<p>슬롯을 사용하면 자식 컴포넌트의 내용으로 어떤 템플릿 코드든 부모 컴포넌트에 전달할 수 있습니다. Composition API에서는 슬롯 내용에 접근할 수 있습니다.</p>\n<h1>예시: 슬롯 사용하기</h1>\n<pre><code class=\"hljs language-js\">&#x3C;!-- <span class=\"hljs-title class_\">BaseLayout</span>.<span class=\"hljs-property\">vue</span> -->\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">header</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"header\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">header</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">main</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">main</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">footer</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"footer\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">footer</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> { useSlots } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-title function_\">setup</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> slots = <span class=\"hljs-title function_\">useSlots</span>();\n    <span class=\"hljs-keyword\">return</span> { slots };\n  }\n};\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></span>\n&#x3C;!-- <span class=\"hljs-title class_\">App</span>.<span class=\"hljs-property\">vue</span> -->\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">BaseLayout</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">header</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>여기에 페이지 제목이 올 수 있어요<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>페이지의 주요 내용<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>여기에 연락처 정보가 있습니다<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">BaseLayout</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">BaseLayout</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./components/BaseLayout.vue'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">components</span>: {\n    <span class=\"hljs-title class_\">BaseLayout</span>\n  }\n};\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></span>\n</code></pre>\n<h1>실용적인 어려움과 해결책</h1>\n<p>어려움: 이름이 지정된 슬롯을 사용할 때, 슬롯 콘텐츠를 자식 컴포넌트의 상태 또는 동작에 따라 동기화하는 것이 복잡할 수 있습니다.</p>\n<p>해결책: scoped 슬롯을 사용할 수 있습니다. scoped 슬롯을 사용하면 자식 컴포넌트가 부모 컴포넌트에 데이터를 노출시킬 수 있고 그 데이터를 부모 컴포넌트의 슬롯 콘텐츠에서 사용할 수 있습니다.</p>\n<h1>동적 컴포넌트와 비동기 컴포넌트</h1>\n<p>Vue 3는 defineAsyncComponent를 통해 비동기 컴포넌트를 지원합니다. 동적 컴포넌트는 내장 <code>component</code> 태그와 <code>:</code> 속성을 사용하여 구현할 수 있습니다.</p>\n<h1>예시: 비동기 컴포넌트</h1>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// defineAsyncComponent를 사용하여 비동기 컴포넌트 로드</span>\n<span class=\"hljs-keyword\">import</span> { defineAsyncComponent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>;<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">components</span>: {\n    <span class=\"hljs-title class_\">AsyncComponent</span>: <span class=\"hljs-title function_\">defineAsyncComponent</span>(<span class=\"hljs-function\">() =></span>\n      <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./components/AsyncComponent.vue'</span>)\n    )\n  }\n};\n</code></pre>\n<h1>예시: 동적 컴포넌트</h1>\n<pre><code class=\"hljs language-js\">&#x3C;template>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"currentComponent\"</span> /></span></span>\n&#x3C;/template>\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ComponentA</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./components/ComponentA.vue'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ComponentB</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./components/ComponentB.vue'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-title function_\">setup</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> currentComponent = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-string\">'ComponentA'</span>);    <span class=\"hljs-comment\">// 실제 상황에 맞게 currentComponent의 값을 변경하여 컴포넌트를 전환할 수 있습니다.</span>\n    \n    <span class=\"hljs-comment\">// currentComponent.value = 'ComponentB';</span>\n    \n    <span class=\"hljs-keyword\">return</span> { currentComponent, <span class=\"hljs-title class_\">ComponentA</span>, <span class=\"hljs-title class_\">ComponentB</span> };\n  }\n};\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></span>\n</code></pre>\n<h1>실용적인 어려움과 해결책</h1>\n<p>어려움: 비동기 컴포넌트를 사용할 때 컴포넌트 로딩 지연이나 실패와 같은 문제가 발생할 수 있어 사용자 경험에 영향을 줄 수 있습니다.</p>\n<p>해결책: 로딩 상태 힌트 및 오류 처리 매커니즘을 제공할 수 있습니다. 예를 들어, Suspense 컴포넌트를 사용하여 비동기 컴포넌트를 감쌀 수 있고 대체 콘텐츠(대체 콘텐츠)를 제공할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">&#x3C;template>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Suspense</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">default</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">AsyncComponent</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">fallback</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Suspense</span>></span></span>\n&#x3C;/template>\n</code></pre>\n<p>위의 예제와 해결책을 통해 Vue 3의 모듈화 및 Composition API가 강력한 기능과 유연성을 제공하여 우리가 실용적인 개발 문제를 더 잘 해결하고 우아한 방식으로 복잡한 애플리케이션을 구축할 수 있음을 볼 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}