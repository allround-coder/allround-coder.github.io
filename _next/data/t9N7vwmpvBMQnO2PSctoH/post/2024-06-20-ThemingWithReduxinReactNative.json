{"pageProps":{"post":{"title":"리액트 네이티브에서 Redux를 이용한 테마 설정","description":"","date":"2024-06-20 00:06","slug":"2024-06-20-ThemingWithReduxinReactNative","content":"\n\n![image](/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png)\n\n왜 Theming을 할까요?\n\nTheming은 현대 앱의 주요 부분이 되어, 사용자 맞춤화 기능을 더욱 향상시킬 수 있게 해줍니다. 테마는 다양한 속성을 포함한 스타일을 설정하여, 다양한 사용자에게 다양한 방식으로 읽히게 합니다. 특히 편의성 측면에서 다르게 작용합니다. 요즘 유행하는 테마 모드는 주로 밝은 모드 또는 어두운 모드(어두운 모드가 가장 좋아요 :-))가 사용되고 있습니다. 일반적으로 사용자의 전화 시스템이 결정하도록 하는 세 번째 옵션이 존재하기도 합니다.\n\nRedux로 Theming을 하는 이유는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n리덕스는 사용자가 상태를 중앙에서 조직적으로 관리할 수 있도록 도와주는 상태 관리 라이브러리입니다. 리덕스는 애플리케이션 상태를 저장하는 저장소 역할을 하며, 사용자는 이 저장소로 읽기, 업데이트 또는 액션을 전달할 수 있습니다. 리액트 컨텍스트, 리액트 쿼리 등 다른 더 쉬운 옵션이 있지만, 사용자를 위해 상태 관리를 간단하게 만드는 목적으로 이 글을 리덕스로 작성했습니다.\n\n- 리덕스는 현재 여러 프로젝트에서 사용 중인 매우 큰 커뮤니티 기반을 가지고 있습니다. 누군가에게 도움이 될 수 있습니다.\n- 개인적으로는 상태 관리 과정에서 어떤 일이 벌어지는지 더 잘 이해할 수 있다고 믿습니다.\n- 누군가가 그것이 스트레스라고 말했으므로, 왜냐하면 나는 그렇게 결정했기 때문에요. :-))\n\n우리가 이루고자 하는 목표\n\n이 프로젝트를 작성하는 시점을 기준으로, React Native 버전인 0.72.7, TypeScript 버전인 4.8.4, Node 버전인 16.17.1, 그리고 NPM 버전인 8.15.0을 사용할 것입니다. 사용할 리덕스 패키지 버전은 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n- \"redux\": \"5.0.1\",\n- \"redux-logger\": \"3.0.6\",\n- \"redux-persist\": \"6.0.0\",\n- \"@react-native-async-storage/async-storage\": \"1.21.0\"\n\n이 프로젝트를 진행하면서 몇 가지 목표를 이루고자 합니다.\n\n- 작업 환경을 설치하고 설정하기.\n- 서로 다른 테마에 대한 다양한 색상을 만들고 사용할 테마 색상 객체를 선택하는 함수를 작성하기.\n- 액션과 리듀서 만들기.\n- Redux 스토어 만들기, Redux 로거, 퍼시스트, 그리고 Async Storage 설정하기. 이 패키지들이 어떤 역할을 하는지 앱에서 사용하면서 설명해 드리겠습니다.\n- 리하이드레이션에 대해 설명하고 여기서 왜 필요한지 이야기하기.\n- 이 컴포넌트 내에서 저장된 상태 사용하기.\n- 마지막으로, 사용자가 시스템의 기본 테마를 사용할 수 있도록 하는 세 번째 옵션을 고려하기.\n\n전제 조건\n\n<div class=\"content-ad\"></div>\n\n- Javascript, Typescript, React Native 및 Redux에 대한 지식이 있습니다.\n- 위의 패키지가 설치되었습니다.\n\n시작하기\n\n패키지 설치\n\n```js\n// npm을 사용하여\nnpm i redux redux-logger redux-persist @react-native-async-storage/async-storage\n// yarn을 사용하여\nyarn add redux redux-logger redux-persist @react-native-async-storage/async-storage\n```\n\n<div class=\"content-ad\"></div>\n\n색구성 만들기\n\n누가 색상을 선택하는 데 머리 아픈 적이 없나요? src 폴더에 colors.tsx 파일을 생성하세요. 여기에는 light 및 dark 모드에 구조를 제공하는 유형을 만들었고, 이를 light 및 dark 키로 지정된 객체에 할당했습니다. 또한 테마에 따라 색구성을 반환하는 함수를 만들었습니다. 나중에 이 부분으로 돌아오겠습니다.\n\n```js\nexport interface ColorProps {\n  screenColor: string;\n  primary: string;\n  primaryTextColor: string;\n  lighterBlack: string;\n  secondaryTextColor: string;\n  inActiveUnderlineTextInputColor: string;\n  tertiaryTextColor: string;\n  whiteColor: string;\n  lightPrimaryColor: string;\n  favouriteButtonColor: string;\n  addPhotoButtonColor: string;\n  ratingIconColor: string;\n  disabledButtonColor: string;\n  onboardingInactiveIconColor: string;\n  tabBarTextColor: string;\n  tabColor: string;\n  gradientColor: string;\n}\nexport const Colors: ColorProps = {\n  screenColor: '#E5E5E5',\n  primaryTextColor: '#000000',\n  lighterBlack: '#FFFFFF',\n  secondaryTextColor: '#FFFFFF',\n  tertiaryTextColor: '#FFFFFF',\n  gradientColor: '#61D2C4',\n  tabColor: '#FFFFFF',\n  ratingIconColor: '#FFCD00',\n  primary: '#2DDA93',\n  disabledButtonColor: '#AAAAAA',\n  onboardingInactiveIconColor: '#DBDBDB',\n  inActiveUnderlineTextInputColor: '#A7A7A7',\n  lightPrimaryColor: '#61D2C4',\n  tabBarTextColor: '#D2D2D2',\n  whiteColor: '#FFFFFF',\n  favouriteButtonColor: '#FF6262',\n  addPhotoButtonColor: '#48A2F5',\n};\n\nexport const DarkColors: ColorProps = {\n  primaryTextColor: '#FFFFFF',\n  tertiaryTextColor: '#1E1E1E',\n  secondaryTextColor: '#F5F5F5',\n  screenColor: '#1B1C1E',\n  lighterBlack: '#777777',\n  tabColor: '#FFFFFF',\n  ratingIconColor: '#FFCD00',\n  primary: '#2DDA93',\n  disabledButtonColor: '#AAAAAA',\n  lightPrimaryColor: '#61D2C4',\n  gradientColor: '#1B1C1E',\n  onboardingInactiveIconColor: '#DBDBDB',\n  inActiveUnderlineTextInputColor: '#A7A7A7',\n  tabBarTextColor: '#D2D2D2',\n  whiteColor: '#FFFFFF',\n  favouriteButtonColor: '#FF6262',\n  addPhotoButtonColor: '#48A2F5',\n};\nconst themes = {\n  light: {...Colors},\n  dark: {...DarkColors},\n};\n\nexport const getThemeColor = (\n  theme: 'light' | 'dark' = 'light',\n  useSystemTheme?: 'light' | 'dark',\n) => {\n  const themeMode = themes[theme];\n  return themeMode;\n};\n```\n\n더 진행하기 전에, store, action 및 reducer는 무엇인가요? 간단히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n어딘가에서 배운 상인의 비유를 사용해 보자. 좋은 걸로 알고 있어.\n\n- 가게를 운영하는 상인인 당신이라고 상상해보세요. 당신은 주문을 방문해야 팔 수 있는 국가를 파는 상점을 소유하고 있어요 (이곳에서는 이것이 유행이죠). 당신의 고객들은 직접 물건을 가져갈 수 없어요, 당신이 주어야죠 (리덕스 스토어).\n- 이익을 내려면 고객이 있어야 해요 - 우리는 비즈니스를 운영하고 있거든요!! - 이 고객들은 상점에 있는 제품에 대해 요청하거나 주문을 넣어요 (하나의 액션). 이러한 주문/요청은 '타입'으로 분류되며, 기타 정보와 함께 액션 객체에 유지되어요.\n- 이제 재고를 업데이트해야 해요 - 몇 개의 물건을 주고 나서 재고가 부족해요 - 그러나 당신이 따르는 특정 논리가 있어요. 여기에서 리듀서라는 개념이 등장해요. 리듀서는 현재 상태와 액션을 받아 들이는 순수한 액션 함수로, 액션 타입과 데이터에 기반하여 새로운 상태를 반환해요.\n\n우리의 리덕스 폴더 구조\n\n![image](/assets/img/2024-06-20-ThemingWithReduxinReactNative_1.png)\n\n<div class=\"content-ad\"></div>\n\n미리 정의된 유형과 초기 테마 상태를 정의해 봅시다 (이 기능은 더 큰 앱의 일부이므로 혼란스러워하지 않도록 이렇게 하고 있어요). 상태 매개변수에 초기 상태를 기본값으로 전달하는 것이 중요합니다. 이렇게 함으로써 상태가 정의되지 않은 경우 첫 번째로 리듀서를 호출할 때 처리할 수 있습니다.\n\n```js\nexport default {\n  TOGGLE_STATUS: 'Toggle',\n};\nexport type ThemeData = {\n  theme: 'light' | 'dark' | 'system';\n};\nconst initialState: ThemeData = {\n  theme: 'light',\n};\n```\n\n이제 액션(고객)을 만들어 봅시다.\n먼저 액션 생성자부터 시작할게요 - 액션을 반환하는 함수(유형, 페이로드)를 반환하고, 페이로드를 새로운 테마로 설정하여 나중에 컴포넌트에서 디스패치할 것입니다. \n\n```js\nexport const toggleTheme = (newTheme: string) => {\n  return {\n    type: types.TOGGLE_STATUS, // 모든 액션은 유형을 가져야 합니다\n    payload: newTheme,\n  };\n};\n```\n\n<div class=\"content-ad\"></div>\n\n저희 상태를 업데이트하기 위한 reducer를 생성 중입니다 (상점 주인님)\n\n여기서 이전 상태를 가져오고 이를 이전 상태가 없는 경우 초기 상태로 설정하는데 사용합니다. 그런 다음 액션에서 전달된 테마 값을 새 상태로 반환합니다. 여기서 액션은 'type, payload'로 구조화되어 있습니다. 타입이 없는 경우에는 이전 상태를 기본 블록에 전달합니다. 이 동작은 새로운 테마 모드로 상태를 업데이트합니다.\n\n```js\nconst toggleThemeReducer = (\n  state: ThemeData = initialState,\n  {type, payload}: {type: string; payload: any},\n) => {\n  switch (type) {\n    case types.TOGGLE_STATUS:\n      return {...state, theme: payload};\n    default:\n      return state;\n  }\n};\n```\n\n리덕스 스토어 설정 중입니다\n\n<div class=\"content-ad\"></div>\n\n와, 그것은 쉬운 부분이었네요. 이제 더 쉬운 부분으로 넘어가겠습니다. (다만 좀 더 신경 써야 할 수도 있어요 :-)).\n\n우리는 예상되는 입력 상태에 타입을 지정하는 것부터 시작할 거에요. 이렇게 미리 정의된 타입을 TypeScript가 타입 추론을 도와줄 때 삶이 조금 더 쉬워지게 됩니다.\n\n```js\nexport type ThemeState = ReturnType<typeof toggleThemeReducer>;\n```\n\n그런 다음에는 우리의 toggleThemeReducer 주위에 래퍼 역할을 하는 루트 리듀서를 가지고 있어요. 그 루트 리듀서는 redux-persist를 사용할 때 지속 상태를 처리하는 데 도움을 줍니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst rootReducer = (state: ThemeState | undefined, action: any) => {\n  const rehydratedState: ThemeState | undefined = toggleThemeReducer(state, action);\n  return rehydratedState;\n};\n```\n\n이제 상태를 보존해야 합니다. 이렇게 하면 사용자가 애플리케이션을 다시 시작하거나 새로 고침하면 이전에 한 변경 사항을 볼 수 있습니다. 테마 상태를 앱 다시 시작이나 새로 고침을 통해 다시 살리기 위해 상태를 보존하고 살립니다. 먼저 리듀서를 보존할 설정 객체(코드 상단에 좋습니다)를 만들고, 이 값을 persistReducer에 전달해야 합니다. 지속성 구성 객체는 redux-persist가 저장 솔루션으로 AsyncStorage를 사용하도록 구성하고 '테마' 상태만을 지속해야 한다고 지정합니다.\n\n```js\nconst persistConfig = {\n  key: 'root',\n  storage: AsyncStorage,\n  whitelist: ['theme'],\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n```\n\n이제 저장소를 설정하고 이 저장소를 지속해야 합니다. 지속된 리듀서를 사용하여 저장소를 생성하면 테마 상태를 지속하고 다시 살립니다. 지속된 저장소(persistor)는 persistStore와 Redux 저장소를 사용하여 만듭니다. 이 persistor는 필요할 때 상태를 수동으로 보존하고 다시 살릴 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\n상태 = createStore(\n= 지속Reducer,\n= applyMiddleware(...middlewares),\n);\n= 지속 = persistStore(모임);\n```\n\nRedux-logger\n\n이것은 Redux 스토어를 사용할 때 우리를 돕는 미들웨어입니다. 우리는 reduxlogger를 사용하는 middleware라는 배열을 만듭니다.\n\n```js\nreduxlogger = createLogger({});\nmiddleware = [reduxlogger];\n\n상태 = createStore(\n= 지속Reducer,\n= applyMiddleware(...middleware),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n- Redux Logger: 이것은 모든 Redux 액션과 상태 변경을 콘솔에 로그로 남기는 개발 도구입니다. 이는 디버깅 목적으로 매우 유용한데, 액션의 흐름을 추적하고 그에 따라 상태가 어떻게 업데이트되는지 확인할 수 있기 때문입니다.\n\n재수행(Rehydration)\n\n이제, 우리는 리듀서를 수정하여 우리가 재수행할 때의 시나리오에 유의해야 합니다. 하지만 먼저, 재수행이 무엇인지 살펴보겠습니다. 우리 로거에서 가져온 앱의 로그를 살펴보면, 재시작했다는 것을 알 수 있습니다.\n\n```js\n{\"theme\": {\"theme\": \"light\"}\nGROUP  action persist/PERSIST @ 16:15:46.681\nLOG    prev state {\"theme\": {\"theme\": \"light\"}\nLOG    action     {\"register\": [Function register], \"rehydrate\": [Function rehydrate], \"type\": \"persist/PERSIST\"}\nLOG    next state {\"_persist\": {\"rehydrated\": false, \"version\": -1}, \"theme\": {\"theme\": \"light\"}\nLOG    {\"theme\": {\"theme\": \"light\"} 재수행상태 \nLOG    {\"_persist\": {\"rehydrated\": true, \"version\": -1}, \"theme\": {\"theme\": \"dark\"} 페이로드 {\"theme\": \"light\"} 상태\nGROUP  action persist/REHYDRATE @ 16:15:46.923\nLOG    prev state {\"_persist\": {\"rehydrated\": false, \"version\": -1}, \"theme\": {\"theme\": \"light\"}\nLOG    action     {\"err\": undefined, \"key\": \"root\", \"payload\": {\"_persist\": {\"rehydrated\": true, \"version\": -1}, \"theme\": {\"theme\": \"dark\"}, \"type\": \"persist/REHYDRATE\"}\nLOG    next state {\"_persist\": {\"rehydrated\": true, \"version\": -1}, \"theme\": {\"theme\": \"dark\"}\r\n```\n\n<div class=\"content-ad\"></div>\n\n여기에서 무슨 일이 일어나고 있는 거죠?\n\n앱이 다시 시작될 때, redux-persist가 먼저 현재 상태인 `light`를 AsyncStorage에 `persist/PERSIST` 액션을 사용하여 영속화합니다. 그런 다음, 이전에 `dark`로 설정되었던 영속 상태를 AsyncStorage에서 가져와 Redux 스토어에 `persist/REHYDRATE` 액션을 사용하여 재수확합니다.\n\n이것이 스토어에 대한 완전한 코드입니다.\n\n```js\nconst persistConfig = {\n  key: 'root',\n  storage: AsyncStorage,\n  whitelist: ['theme'],\n};\n\nconst rootReducer = (state: ThemeState | undefined, action: any) => {\n  const rehydratedState: ThemeState | undefined = toggleThemeReducer(state, action);\n  return rehydratedState;\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\nexport const store = createStore(\n  persistedReducer,\n  applyMiddleware(...middlewares),\n);\nexport const persistor = persistStore(store);\n\nexport type RootState = ReturnType<typeof rootReducer>; // 사전 정의된 이 유형 추론을 돕기 위한 것.\n```\n\n<div class=\"content-ad\"></div>\n\n우리 컴포넌트와 함께 이들 저장된 상태를 사용합니다.\n\n이 시연에서는 앱 내에서 테마 모드를 전환하는 데 도움이 되는 테마 버튼이 포함된 드롭다운을 가지고 있을 것입니다.\n\n```js\n인터페이스 DropDownData {\n  라벨: 문자열;\n  값: 문자열;\n}\n인터페이스 DropDownProps {\n  색상?: 문자열;\n}\nconst DropDown = (props?: DropDownProps) => {\n  const navigation = useNavigation<RootStackNavigationProp>();\n  const [selectedOption, setSelectedOption] = useState<string>('');\n\n  const data: DropDownData[] = [\n    {label: '테마', 값: 'theme'},\n  ];\n\n  const dispatch = useDispatch();\n\n  const userTheme = useSelector((state: RootState) => state.theme);\n  const {theme} = userTheme;\n  const Colors = getThemeColor(theme);\n\n  const styles = StyleSheet.create({\n    dropDownItem: {\n      paddingHorizontal: screenWidth * 0.04,\n    },\n    dropdown: {\n      backgroundColor: Colors.screenColor,\n      position: 'absolute',\n      left: screenWidth * 0.55,\n      borderRadius: 20,\n      paddingVertical: 8,\n      width: screenWidth * 0.4,\n    },\n  });\n\n  const handleOptionSelect = (value: string) => {\n    setSelectedOption(value);\n\n    if (value === 'customTheme') {\n      dispatch(toggleTheme(theme === 'light' ? 'dark' : 'light'));\n    } else if (value === 'system') {\n      dispatch(toggleTheme('system'));\n    }\n  };\n  return (\n    <View\n      style={\n        position: 'absolute',\n        top: screenHeight * 0.07,\n        right: screenWidth * 0.03,\n      }>\n      <SelectDropdown\n        data={data}\n        statusBarTranslucent\n        renderItem={(\n          selectedItem: DropDownData,\n          index: number,\n          isSelected: boolean,\n        ) => {\n          return (\n            <View\n              style={\n                ...styles.dropDownItem,\n                borderBottomWidth: 1,\n                borderBottomColor: Colors.primary,\n              }>\n              <WText\n                style={\n                  paddingVertical: 13,\n                  paddingLeft: 5,\n                  fontSize: 18,\n                }>\n                {selectedItem.label}\n              </WText>\n            </View>\n          );\n        }\n        dropdownOverlayColor=\"transparent\"\n        renderButton={() => {\n          return (\n            <View\n              style={\n                alignItems: 'flex-end',\n                backgroundColor: Colors.lighterBlack,\n                borderRadius: 100,\n                padding: 5,\n              }>\n              <Ionicons\n                name=\"ellipsis-vertical\"\n                color={Colors.primary}\n                size={30}\n              />\n            </View>\n          );\n        }\n        onSelect={(selectedItem: DropDownData, index: number) => {\n          handleOptionSelect(selectedItem.value);\n        }\n        dropdownStyle={styles.dropdown}\n      />\n    </View>\n  );\n};\n\nexport default DropDown;\n```\n\n위에 무슨 일이 발생했나요? \"CustomTheme\"을 선택했을 때, 현재 테마의 값을 확인한 후, 테마를 번갈아가며 변경합니다. 그러나 \"system\" 옵션을 선택하면 폰의 기본 테마를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n시스템 기본 테마 사용하기\n\n마지막으로 시스템 테마를 사용하려면 useColorScheme 훅을 활용할 수 있습니다. 이 훅은 기기에서 현재 사용 중인 색상테마에 대한 업데이트를 제공합니다. colors.tsx 파일에서 getThemeColor 함수를 수정해봅시다.\n\n```js\nexport const getThemeColor = (theme: 'light' | 'dark' = 'light') => {\n  const systemTheme = useColorScheme() || 'light';\n  const userTheme = useSelector((state: RootState) => state.theme);\n  const {theme: storedTheme} = userTheme;\n  let themeMode;\n\n  if (storedTheme === 'system') {\n    const themeMode = themes[systemTheme];\n    return themeMode;\n  } else {\n    const themeMode = themes[theme];\n    return themeMode;\n  }\n};\n```\n\n아래의 코드를 사용하여 저장소에서 현재 테마 색상을 제공받아 원하는 동작을 구현하는데 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst userTheme = useSelector((state: RootState) => state.theme);\nconst {theme} = userTheme;\nconst Colors = getThemeColor(theme);\n```\n\n아래는 우리의 결과입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1152/1*2zA_7xp0whnKUe5a5ts_aA.gif)","ogImage":{"url":"/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png"},"coverImage":"/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png","tag":["Tech"],"readingTime":14},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png\" alt=\"image\"></p>\n<p>왜 Theming을 할까요?</p>\n<p>Theming은 현대 앱의 주요 부분이 되어, 사용자 맞춤화 기능을 더욱 향상시킬 수 있게 해줍니다. 테마는 다양한 속성을 포함한 스타일을 설정하여, 다양한 사용자에게 다양한 방식으로 읽히게 합니다. 특히 편의성 측면에서 다르게 작용합니다. 요즘 유행하는 테마 모드는 주로 밝은 모드 또는 어두운 모드(어두운 모드가 가장 좋아요 :-))가 사용되고 있습니다. 일반적으로 사용자의 전화 시스템이 결정하도록 하는 세 번째 옵션이 존재하기도 합니다.</p>\n<p>Redux로 Theming을 하는 이유는 무엇인가요?</p>\n<p>리덕스는 사용자가 상태를 중앙에서 조직적으로 관리할 수 있도록 도와주는 상태 관리 라이브러리입니다. 리덕스는 애플리케이션 상태를 저장하는 저장소 역할을 하며, 사용자는 이 저장소로 읽기, 업데이트 또는 액션을 전달할 수 있습니다. 리액트 컨텍스트, 리액트 쿼리 등 다른 더 쉬운 옵션이 있지만, 사용자를 위해 상태 관리를 간단하게 만드는 목적으로 이 글을 리덕스로 작성했습니다.</p>\n<ul>\n<li>리덕스는 현재 여러 프로젝트에서 사용 중인 매우 큰 커뮤니티 기반을 가지고 있습니다. 누군가에게 도움이 될 수 있습니다.</li>\n<li>개인적으로는 상태 관리 과정에서 어떤 일이 벌어지는지 더 잘 이해할 수 있다고 믿습니다.</li>\n<li>누군가가 그것이 스트레스라고 말했으므로, 왜냐하면 나는 그렇게 결정했기 때문에요. :-))</li>\n</ul>\n<p>우리가 이루고자 하는 목표</p>\n<p>이 프로젝트를 작성하는 시점을 기준으로, React Native 버전인 0.72.7, TypeScript 버전인 4.8.4, Node 버전인 16.17.1, 그리고 NPM 버전인 8.15.0을 사용할 것입니다. 사용할 리덕스 패키지 버전은 다음과 같습니다.</p>\n<ul>\n<li>\"redux\": \"5.0.1\",</li>\n<li>\"redux-logger\": \"3.0.6\",</li>\n<li>\"redux-persist\": \"6.0.0\",</li>\n<li>\"@react-native-async-storage/async-storage\": \"1.21.0\"</li>\n</ul>\n<p>이 프로젝트를 진행하면서 몇 가지 목표를 이루고자 합니다.</p>\n<ul>\n<li>작업 환경을 설치하고 설정하기.</li>\n<li>서로 다른 테마에 대한 다양한 색상을 만들고 사용할 테마 색상 객체를 선택하는 함수를 작성하기.</li>\n<li>액션과 리듀서 만들기.</li>\n<li>Redux 스토어 만들기, Redux 로거, 퍼시스트, 그리고 Async Storage 설정하기. 이 패키지들이 어떤 역할을 하는지 앱에서 사용하면서 설명해 드리겠습니다.</li>\n<li>리하이드레이션에 대해 설명하고 여기서 왜 필요한지 이야기하기.</li>\n<li>이 컴포넌트 내에서 저장된 상태 사용하기.</li>\n<li>마지막으로, 사용자가 시스템의 기본 테마를 사용할 수 있도록 하는 세 번째 옵션을 고려하기.</li>\n</ul>\n<p>전제 조건</p>\n<ul>\n<li>Javascript, Typescript, React Native 및 Redux에 대한 지식이 있습니다.</li>\n<li>위의 패키지가 설치되었습니다.</li>\n</ul>\n<p>시작하기</p>\n<p>패키지 설치</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// npm을 사용하여</span>\nnpm i redux redux-logger redux-persist @react-native-<span class=\"hljs-keyword\">async</span>-storage/<span class=\"hljs-keyword\">async</span>-storage\n<span class=\"hljs-comment\">// yarn을 사용하여</span>\nyarn add redux redux-logger redux-persist @react-native-<span class=\"hljs-keyword\">async</span>-storage/<span class=\"hljs-keyword\">async</span>-storage\n</code></pre>\n<p>색구성 만들기</p>\n<p>누가 색상을 선택하는 데 머리 아픈 적이 없나요? src 폴더에 colors.tsx 파일을 생성하세요. 여기에는 light 및 dark 모드에 구조를 제공하는 유형을 만들었고, 이를 light 및 dark 키로 지정된 객체에 할당했습니다. 또한 테마에 따라 색구성을 반환하는 함수를 만들었습니다. 나중에 이 부분으로 돌아오겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">ColorProps</span> {\n  <span class=\"hljs-attr\">screenColor</span>: string;\n  <span class=\"hljs-attr\">primary</span>: string;\n  <span class=\"hljs-attr\">primaryTextColor</span>: string;\n  <span class=\"hljs-attr\">lighterBlack</span>: string;\n  <span class=\"hljs-attr\">secondaryTextColor</span>: string;\n  <span class=\"hljs-attr\">inActiveUnderlineTextInputColor</span>: string;\n  <span class=\"hljs-attr\">tertiaryTextColor</span>: string;\n  <span class=\"hljs-attr\">whiteColor</span>: string;\n  <span class=\"hljs-attr\">lightPrimaryColor</span>: string;\n  <span class=\"hljs-attr\">favouriteButtonColor</span>: string;\n  <span class=\"hljs-attr\">addPhotoButtonColor</span>: string;\n  <span class=\"hljs-attr\">ratingIconColor</span>: string;\n  <span class=\"hljs-attr\">disabledButtonColor</span>: string;\n  <span class=\"hljs-attr\">onboardingInactiveIconColor</span>: string;\n  <span class=\"hljs-attr\">tabBarTextColor</span>: string;\n  <span class=\"hljs-attr\">tabColor</span>: string;\n  <span class=\"hljs-attr\">gradientColor</span>: string;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Colors</span>: <span class=\"hljs-title class_\">ColorProps</span> = {\n  <span class=\"hljs-attr\">screenColor</span>: <span class=\"hljs-string\">'#E5E5E5'</span>,\n  <span class=\"hljs-attr\">primaryTextColor</span>: <span class=\"hljs-string\">'#000000'</span>,\n  <span class=\"hljs-attr\">lighterBlack</span>: <span class=\"hljs-string\">'#FFFFFF'</span>,\n  <span class=\"hljs-attr\">secondaryTextColor</span>: <span class=\"hljs-string\">'#FFFFFF'</span>,\n  <span class=\"hljs-attr\">tertiaryTextColor</span>: <span class=\"hljs-string\">'#FFFFFF'</span>,\n  <span class=\"hljs-attr\">gradientColor</span>: <span class=\"hljs-string\">'#61D2C4'</span>,\n  <span class=\"hljs-attr\">tabColor</span>: <span class=\"hljs-string\">'#FFFFFF'</span>,\n  <span class=\"hljs-attr\">ratingIconColor</span>: <span class=\"hljs-string\">'#FFCD00'</span>,\n  <span class=\"hljs-attr\">primary</span>: <span class=\"hljs-string\">'#2DDA93'</span>,\n  <span class=\"hljs-attr\">disabledButtonColor</span>: <span class=\"hljs-string\">'#AAAAAA'</span>,\n  <span class=\"hljs-attr\">onboardingInactiveIconColor</span>: <span class=\"hljs-string\">'#DBDBDB'</span>,\n  <span class=\"hljs-attr\">inActiveUnderlineTextInputColor</span>: <span class=\"hljs-string\">'#A7A7A7'</span>,\n  <span class=\"hljs-attr\">lightPrimaryColor</span>: <span class=\"hljs-string\">'#61D2C4'</span>,\n  <span class=\"hljs-attr\">tabBarTextColor</span>: <span class=\"hljs-string\">'#D2D2D2'</span>,\n  <span class=\"hljs-attr\">whiteColor</span>: <span class=\"hljs-string\">'#FFFFFF'</span>,\n  <span class=\"hljs-attr\">favouriteButtonColor</span>: <span class=\"hljs-string\">'#FF6262'</span>,\n  <span class=\"hljs-attr\">addPhotoButtonColor</span>: <span class=\"hljs-string\">'#48A2F5'</span>,\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DarkColors</span>: <span class=\"hljs-title class_\">ColorProps</span> = {\n  <span class=\"hljs-attr\">primaryTextColor</span>: <span class=\"hljs-string\">'#FFFFFF'</span>,\n  <span class=\"hljs-attr\">tertiaryTextColor</span>: <span class=\"hljs-string\">'#1E1E1E'</span>,\n  <span class=\"hljs-attr\">secondaryTextColor</span>: <span class=\"hljs-string\">'#F5F5F5'</span>,\n  <span class=\"hljs-attr\">screenColor</span>: <span class=\"hljs-string\">'#1B1C1E'</span>,\n  <span class=\"hljs-attr\">lighterBlack</span>: <span class=\"hljs-string\">'#777777'</span>,\n  <span class=\"hljs-attr\">tabColor</span>: <span class=\"hljs-string\">'#FFFFFF'</span>,\n  <span class=\"hljs-attr\">ratingIconColor</span>: <span class=\"hljs-string\">'#FFCD00'</span>,\n  <span class=\"hljs-attr\">primary</span>: <span class=\"hljs-string\">'#2DDA93'</span>,\n  <span class=\"hljs-attr\">disabledButtonColor</span>: <span class=\"hljs-string\">'#AAAAAA'</span>,\n  <span class=\"hljs-attr\">lightPrimaryColor</span>: <span class=\"hljs-string\">'#61D2C4'</span>,\n  <span class=\"hljs-attr\">gradientColor</span>: <span class=\"hljs-string\">'#1B1C1E'</span>,\n  <span class=\"hljs-attr\">onboardingInactiveIconColor</span>: <span class=\"hljs-string\">'#DBDBDB'</span>,\n  <span class=\"hljs-attr\">inActiveUnderlineTextInputColor</span>: <span class=\"hljs-string\">'#A7A7A7'</span>,\n  <span class=\"hljs-attr\">tabBarTextColor</span>: <span class=\"hljs-string\">'#D2D2D2'</span>,\n  <span class=\"hljs-attr\">whiteColor</span>: <span class=\"hljs-string\">'#FFFFFF'</span>,\n  <span class=\"hljs-attr\">favouriteButtonColor</span>: <span class=\"hljs-string\">'#FF6262'</span>,\n  <span class=\"hljs-attr\">addPhotoButtonColor</span>: <span class=\"hljs-string\">'#48A2F5'</span>,\n};\n<span class=\"hljs-keyword\">const</span> themes = {\n  <span class=\"hljs-attr\">light</span>: {...<span class=\"hljs-title class_\">Colors</span>},\n  <span class=\"hljs-attr\">dark</span>: {...<span class=\"hljs-title class_\">DarkColors</span>},\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getThemeColor</span> = (<span class=\"hljs-params\">\n  theme: <span class=\"hljs-string\">'light'</span> | <span class=\"hljs-string\">'dark'</span> = <span class=\"hljs-string\">'light'</span>,\n  useSystemTheme?: <span class=\"hljs-string\">'light'</span> | <span class=\"hljs-string\">'dark'</span>,\n</span>) => {\n  <span class=\"hljs-keyword\">const</span> themeMode = themes[theme];\n  <span class=\"hljs-keyword\">return</span> themeMode;\n};\n</code></pre>\n<p>더 진행하기 전에, store, action 및 reducer는 무엇인가요? 간단히 살펴보겠습니다.</p>\n<p>어딘가에서 배운 상인의 비유를 사용해 보자. 좋은 걸로 알고 있어.</p>\n<ul>\n<li>가게를 운영하는 상인인 당신이라고 상상해보세요. 당신은 주문을 방문해야 팔 수 있는 국가를 파는 상점을 소유하고 있어요 (이곳에서는 이것이 유행이죠). 당신의 고객들은 직접 물건을 가져갈 수 없어요, 당신이 주어야죠 (리덕스 스토어).</li>\n<li>이익을 내려면 고객이 있어야 해요 - 우리는 비즈니스를 운영하고 있거든요!! - 이 고객들은 상점에 있는 제품에 대해 요청하거나 주문을 넣어요 (하나의 액션). 이러한 주문/요청은 '타입'으로 분류되며, 기타 정보와 함께 액션 객체에 유지되어요.</li>\n<li>이제 재고를 업데이트해야 해요 - 몇 개의 물건을 주고 나서 재고가 부족해요 - 그러나 당신이 따르는 특정 논리가 있어요. 여기에서 리듀서라는 개념이 등장해요. 리듀서는 현재 상태와 액션을 받아 들이는 순수한 액션 함수로, 액션 타입과 데이터에 기반하여 새로운 상태를 반환해요.</li>\n</ul>\n<p>우리의 리덕스 폴더 구조</p>\n<p><img src=\"/assets/img/2024-06-20-ThemingWithReduxinReactNative_1.png\" alt=\"image\"></p>\n<p>미리 정의된 유형과 초기 테마 상태를 정의해 봅시다 (이 기능은 더 큰 앱의 일부이므로 혼란스러워하지 않도록 이렇게 하고 있어요). 상태 매개변수에 초기 상태를 기본값으로 전달하는 것이 중요합니다. 이렇게 함으로써 상태가 정의되지 않은 경우 첫 번째로 리듀서를 호출할 때 처리할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">TOGGLE_STATUS</span>: <span class=\"hljs-string\">'Toggle'</span>,\n};\n<span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">ThemeData</span> = {\n  <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-string\">'light'</span> | <span class=\"hljs-string\">'dark'</span> | <span class=\"hljs-string\">'system'</span>;\n};\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-title class_\">ThemeData</span> = {\n  <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-string\">'light'</span>,\n};\n</code></pre>\n<p>이제 액션(고객)을 만들어 봅시다.\n먼저 액션 생성자부터 시작할게요 - 액션을 반환하는 함수(유형, 페이로드)를 반환하고, 페이로드를 새로운 테마로 설정하여 나중에 컴포넌트에서 디스패치할 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">toggleTheme</span> = (<span class=\"hljs-params\">newTheme: string</span>) => {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">type</span>: types.<span class=\"hljs-property\">TOGGLE_STATUS</span>, <span class=\"hljs-comment\">// 모든 액션은 유형을 가져야 합니다</span>\n    <span class=\"hljs-attr\">payload</span>: newTheme,\n  };\n};\n</code></pre>\n<p>저희 상태를 업데이트하기 위한 reducer를 생성 중입니다 (상점 주인님)</p>\n<p>여기서 이전 상태를 가져오고 이를 이전 상태가 없는 경우 초기 상태로 설정하는데 사용합니다. 그런 다음 액션에서 전달된 테마 값을 새 상태로 반환합니다. 여기서 액션은 'type, payload'로 구조화되어 있습니다. 타입이 없는 경우에는 이전 상태를 기본 블록에 전달합니다. 이 동작은 새로운 테마 모드로 상태를 업데이트합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">toggleThemeReducer</span> = (<span class=\"hljs-params\">\n  state: ThemeData = initialState,\n  {type, payload}: {type: string; payload: any},\n</span>) => {\n  <span class=\"hljs-keyword\">switch</span> (type) {\n    <span class=\"hljs-keyword\">case</span> types.<span class=\"hljs-property\">TOGGLE_STATUS</span>:\n      <span class=\"hljs-keyword\">return</span> {...state, <span class=\"hljs-attr\">theme</span>: payload};\n    <span class=\"hljs-attr\">default</span>:\n      <span class=\"hljs-keyword\">return</span> state;\n  }\n};\n</code></pre>\n<p>리덕스 스토어 설정 중입니다</p>\n<p>와, 그것은 쉬운 부분이었네요. 이제 더 쉬운 부분으로 넘어가겠습니다. (다만 좀 더 신경 써야 할 수도 있어요 :-)).</p>\n<p>우리는 예상되는 입력 상태에 타입을 지정하는 것부터 시작할 거에요. 이렇게 미리 정의된 타입을 TypeScript가 타입 추론을 도와줄 때 삶이 조금 더 쉬워지게 됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">ThemeState</span> = <span class=\"hljs-title class_\">ReturnType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> toggleThemeReducer>;\n</code></pre>\n<p>그런 다음에는 우리의 toggleThemeReducer 주위에 래퍼 역할을 하는 루트 리듀서를 가지고 있어요. 그 루트 리듀서는 redux-persist를 사용할 때 지속 상태를 처리하는 데 도움을 줍니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">rootReducer</span> = (<span class=\"hljs-params\">state: ThemeState | <span class=\"hljs-literal\">undefined</span>, action: any</span>) => {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">rehydratedState</span>: <span class=\"hljs-title class_\">ThemeState</span> | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-title function_\">toggleThemeReducer</span>(state, action);\n  <span class=\"hljs-keyword\">return</span> rehydratedState;\n};\n</code></pre>\n<p>이제 상태를 보존해야 합니다. 이렇게 하면 사용자가 애플리케이션을 다시 시작하거나 새로 고침하면 이전에 한 변경 사항을 볼 수 있습니다. 테마 상태를 앱 다시 시작이나 새로 고침을 통해 다시 살리기 위해 상태를 보존하고 살립니다. 먼저 리듀서를 보존할 설정 객체(코드 상단에 좋습니다)를 만들고, 이 값을 persistReducer에 전달해야 합니다. 지속성 구성 객체는 redux-persist가 저장 솔루션으로 AsyncStorage를 사용하도록 구성하고 '테마' 상태만을 지속해야 한다고 지정합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> persistConfig = {\n  <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">'root'</span>,\n  <span class=\"hljs-attr\">storage</span>: <span class=\"hljs-title class_\">AsyncStorage</span>,\n  <span class=\"hljs-attr\">whitelist</span>: [<span class=\"hljs-string\">'theme'</span>],\n};\n\n<span class=\"hljs-keyword\">const</span> persistedReducer = <span class=\"hljs-title function_\">persistReducer</span>(persistConfig, rootReducer);\n</code></pre>\n<p>이제 저장소를 설정하고 이 저장소를 지속해야 합니다. 지속된 리듀서를 사용하여 저장소를 생성하면 테마 상태를 지속하고 다시 살립니다. 지속된 저장소(persistor)는 persistStore와 Redux 저장소를 사용하여 만듭니다. 이 persistor는 필요할 때 상태를 수동으로 보존하고 다시 살릴 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">상태 = <span class=\"hljs-title function_\">createStore</span>(\n= 지속<span class=\"hljs-title class_\">Reducer</span>,\n= <span class=\"hljs-title function_\">applyMiddleware</span>(...middlewares),\n);\n= 지속 = <span class=\"hljs-title function_\">persistStore</span>(모임);\n</code></pre>\n<p>Redux-logger</p>\n<p>이것은 Redux 스토어를 사용할 때 우리를 돕는 미들웨어입니다. 우리는 reduxlogger를 사용하는 middleware라는 배열을 만듭니다.</p>\n<pre><code class=\"hljs language-js\">reduxlogger = <span class=\"hljs-title function_\">createLogger</span>({});\nmiddleware = [reduxlogger];\n\n상태 = <span class=\"hljs-title function_\">createStore</span>(\n= 지속<span class=\"hljs-title class_\">Reducer</span>,\n= <span class=\"hljs-title function_\">applyMiddleware</span>(...middleware),\n);\n</code></pre>\n<ul>\n<li>Redux Logger: 이것은 모든 Redux 액션과 상태 변경을 콘솔에 로그로 남기는 개발 도구입니다. 이는 디버깅 목적으로 매우 유용한데, 액션의 흐름을 추적하고 그에 따라 상태가 어떻게 업데이트되는지 확인할 수 있기 때문입니다.</li>\n</ul>\n<p>재수행(Rehydration)</p>\n<p>이제, 우리는 리듀서를 수정하여 우리가 재수행할 때의 시나리오에 유의해야 합니다. 하지만 먼저, 재수행이 무엇인지 살펴보겠습니다. 우리 로거에서 가져온 앱의 로그를 살펴보면, 재시작했다는 것을 알 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">{<span class=\"hljs-string\">\"theme\"</span>: {<span class=\"hljs-string\">\"theme\"</span>: <span class=\"hljs-string\">\"light\"</span>}\n<span class=\"hljs-variable constant_\">GROUP</span>  action persist/<span class=\"hljs-variable constant_\">PERSIST</span> @ <span class=\"hljs-number\">16</span>:<span class=\"hljs-number\">15</span>:<span class=\"hljs-number\">46.681</span>\n<span class=\"hljs-variable constant_\">LOG</span>    prev state {<span class=\"hljs-string\">\"theme\"</span>: {<span class=\"hljs-string\">\"theme\"</span>: <span class=\"hljs-string\">\"light\"</span>}\n<span class=\"hljs-variable constant_\">LOG</span>    action     {<span class=\"hljs-string\">\"register\"</span>: [<span class=\"hljs-title class_\">Function</span> register], <span class=\"hljs-string\">\"rehydrate\"</span>: [<span class=\"hljs-title class_\">Function</span> rehydrate], <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"persist/PERSIST\"</span>}\n<span class=\"hljs-variable constant_\">LOG</span>    next state {<span class=\"hljs-string\">\"_persist\"</span>: {<span class=\"hljs-string\">\"rehydrated\"</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">\"version\"</span>: -<span class=\"hljs-number\">1</span>}, <span class=\"hljs-string\">\"theme\"</span>: {<span class=\"hljs-string\">\"theme\"</span>: <span class=\"hljs-string\">\"light\"</span>}\n<span class=\"hljs-variable constant_\">LOG</span>    {<span class=\"hljs-string\">\"theme\"</span>: {<span class=\"hljs-string\">\"theme\"</span>: <span class=\"hljs-string\">\"light\"</span>} 재수행상태 \n<span class=\"hljs-variable constant_\">LOG</span>    {<span class=\"hljs-string\">\"_persist\"</span>: {<span class=\"hljs-string\">\"rehydrated\"</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-string\">\"version\"</span>: -<span class=\"hljs-number\">1</span>}, <span class=\"hljs-string\">\"theme\"</span>: {<span class=\"hljs-string\">\"theme\"</span>: <span class=\"hljs-string\">\"dark\"</span>} 페이로드 {<span class=\"hljs-string\">\"theme\"</span>: <span class=\"hljs-string\">\"light\"</span>} 상태\n<span class=\"hljs-variable constant_\">GROUP</span>  action persist/<span class=\"hljs-variable constant_\">REHYDRATE</span> @ <span class=\"hljs-number\">16</span>:<span class=\"hljs-number\">15</span>:<span class=\"hljs-number\">46.923</span>\n<span class=\"hljs-variable constant_\">LOG</span>    prev state {<span class=\"hljs-string\">\"_persist\"</span>: {<span class=\"hljs-string\">\"rehydrated\"</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">\"version\"</span>: -<span class=\"hljs-number\">1</span>}, <span class=\"hljs-string\">\"theme\"</span>: {<span class=\"hljs-string\">\"theme\"</span>: <span class=\"hljs-string\">\"light\"</span>}\n<span class=\"hljs-variable constant_\">LOG</span>    action     {<span class=\"hljs-string\">\"err\"</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"key\"</span>: <span class=\"hljs-string\">\"root\"</span>, <span class=\"hljs-string\">\"payload\"</span>: {<span class=\"hljs-string\">\"_persist\"</span>: {<span class=\"hljs-string\">\"rehydrated\"</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-string\">\"version\"</span>: -<span class=\"hljs-number\">1</span>}, <span class=\"hljs-string\">\"theme\"</span>: {<span class=\"hljs-string\">\"theme\"</span>: <span class=\"hljs-string\">\"dark\"</span>}, <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"persist/REHYDRATE\"</span>}\n<span class=\"hljs-variable constant_\">LOG</span>    next state {<span class=\"hljs-string\">\"_persist\"</span>: {<span class=\"hljs-string\">\"rehydrated\"</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-string\">\"version\"</span>: -<span class=\"hljs-number\">1</span>}, <span class=\"hljs-string\">\"theme\"</span>: {<span class=\"hljs-string\">\"theme\"</span>: <span class=\"hljs-string\">\"dark\"</span>}\n</code></pre>\n<p>여기에서 무슨 일이 일어나고 있는 거죠?</p>\n<p>앱이 다시 시작될 때, redux-persist가 먼저 현재 상태인 <code>light</code>를 AsyncStorage에 <code>persist/PERSIST</code> 액션을 사용하여 영속화합니다. 그런 다음, 이전에 <code>dark</code>로 설정되었던 영속 상태를 AsyncStorage에서 가져와 Redux 스토어에 <code>persist/REHYDRATE</code> 액션을 사용하여 재수확합니다.</p>\n<p>이것이 스토어에 대한 완전한 코드입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> persistConfig = {\n  <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">'root'</span>,\n  <span class=\"hljs-attr\">storage</span>: <span class=\"hljs-title class_\">AsyncStorage</span>,\n  <span class=\"hljs-attr\">whitelist</span>: [<span class=\"hljs-string\">'theme'</span>],\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">rootReducer</span> = (<span class=\"hljs-params\">state: ThemeState | <span class=\"hljs-literal\">undefined</span>, action: any</span>) => {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">rehydratedState</span>: <span class=\"hljs-title class_\">ThemeState</span> | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-title function_\">toggleThemeReducer</span>(state, action);\n  <span class=\"hljs-keyword\">return</span> rehydratedState;\n};\n\n<span class=\"hljs-keyword\">const</span> persistedReducer = <span class=\"hljs-title function_\">persistReducer</span>(persistConfig, rootReducer);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> store = <span class=\"hljs-title function_\">createStore</span>(\n  persistedReducer,\n  <span class=\"hljs-title function_\">applyMiddleware</span>(...middlewares),\n);\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> persistor = <span class=\"hljs-title function_\">persistStore</span>(store);\n\n<span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">RootState</span> = <span class=\"hljs-title class_\">ReturnType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> rootReducer>; <span class=\"hljs-comment\">// 사전 정의된 이 유형 추론을 돕기 위한 것.</span>\n</code></pre>\n<p>우리 컴포넌트와 함께 이들 저장된 상태를 사용합니다.</p>\n<p>이 시연에서는 앱 내에서 테마 모드를 전환하는 데 도움이 되는 테마 버튼이 포함된 드롭다운을 가지고 있을 것입니다.</p>\n<pre><code class=\"hljs language-js\">인터페이스 <span class=\"hljs-title class_\">DropDownData</span> {\n  라벨: 문자열;\n  값: 문자열;\n}\n인터페이스 <span class=\"hljs-title class_\">DropDownProps</span> {\n  색상?: 문자열;\n}\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">DropDown</span> = (<span class=\"hljs-params\">props?: DropDownProps</span>) => {\n  <span class=\"hljs-keyword\">const</span> navigation = useNavigation&#x3C;<span class=\"hljs-title class_\">RootStackNavigationProp</span>>();\n  <span class=\"hljs-keyword\">const</span> [selectedOption, setSelectedOption] = useState&#x3C;string>(<span class=\"hljs-string\">''</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">DropDownData</span>[] = [\n    {<span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">'테마'</span>, 값: <span class=\"hljs-string\">'theme'</span>},\n  ];\n\n  <span class=\"hljs-keyword\">const</span> dispatch = <span class=\"hljs-title function_\">useDispatch</span>();\n\n  <span class=\"hljs-keyword\">const</span> userTheme = <span class=\"hljs-title function_\">useSelector</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">state: RootState</span>) =></span> state.<span class=\"hljs-property\">theme</span>);\n  <span class=\"hljs-keyword\">const</span> {theme} = userTheme;\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Colors</span> = <span class=\"hljs-title function_\">getThemeColor</span>(theme);\n\n  <span class=\"hljs-keyword\">const</span> styles = <span class=\"hljs-title class_\">StyleSheet</span>.<span class=\"hljs-title function_\">create</span>({\n    <span class=\"hljs-attr\">dropDownItem</span>: {\n      <span class=\"hljs-attr\">paddingHorizontal</span>: screenWidth * <span class=\"hljs-number\">0.04</span>,\n    },\n    <span class=\"hljs-attr\">dropdown</span>: {\n      <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">screenColor</span>,\n      <span class=\"hljs-attr\">position</span>: <span class=\"hljs-string\">'absolute'</span>,\n      <span class=\"hljs-attr\">left</span>: screenWidth * <span class=\"hljs-number\">0.55</span>,\n      <span class=\"hljs-attr\">borderRadius</span>: <span class=\"hljs-number\">20</span>,\n      <span class=\"hljs-attr\">paddingVertical</span>: <span class=\"hljs-number\">8</span>,\n      <span class=\"hljs-attr\">width</span>: screenWidth * <span class=\"hljs-number\">0.4</span>,\n    },\n  });\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleOptionSelect</span> = (<span class=\"hljs-params\">value: string</span>) => {\n    <span class=\"hljs-title function_\">setSelectedOption</span>(value);\n\n    <span class=\"hljs-keyword\">if</span> (value === <span class=\"hljs-string\">'customTheme'</span>) {\n      <span class=\"hljs-title function_\">dispatch</span>(<span class=\"hljs-title function_\">toggleTheme</span>(theme === <span class=\"hljs-string\">'light'</span> ? <span class=\"hljs-string\">'dark'</span> : <span class=\"hljs-string\">'light'</span>));\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (value === <span class=\"hljs-string\">'system'</span>) {\n      <span class=\"hljs-title function_\">dispatch</span>(<span class=\"hljs-title function_\">toggleTheme</span>(<span class=\"hljs-string\">'system'</span>));\n    }\n  };\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">View</span>\n      <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{</span>\n        <span class=\"hljs-attr\">position:</span> '<span class=\"hljs-attr\">absolute</span>',\n        <span class=\"hljs-attr\">top:</span> <span class=\"hljs-attr\">screenHeight</span> * <span class=\"hljs-attr\">0.07</span>,\n        <span class=\"hljs-attr\">right:</span> <span class=\"hljs-attr\">screenWidth</span> * <span class=\"hljs-attr\">0.03</span>,\n      }></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">SelectDropdown</span>\n        <span class=\"hljs-attr\">data</span>=<span class=\"hljs-string\">{data}</span>\n        <span class=\"hljs-attr\">statusBarTranslucent</span>\n        <span class=\"hljs-attr\">renderItem</span>=<span class=\"hljs-string\">{(</span>\n          <span class=\"hljs-attr\">selectedItem:</span> <span class=\"hljs-attr\">DropDownData</span>,\n          <span class=\"hljs-attr\">index:</span> <span class=\"hljs-attr\">number</span>,\n          <span class=\"hljs-attr\">isSelected:</span> <span class=\"hljs-attr\">boolean</span>,\n        ) =></span> {\n          return (\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">View</span>\n              <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{</span>\n                <span class=\"hljs-attr\">...styles.dropDownItem</span>,\n                <span class=\"hljs-attr\">borderBottomWidth:</span> <span class=\"hljs-attr\">1</span>,\n                <span class=\"hljs-attr\">borderBottomColor:</span> <span class=\"hljs-attr\">Colors.primary</span>,\n              }></span>\n              <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">WText</span>\n                <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{</span>\n                  <span class=\"hljs-attr\">paddingVertical:</span> <span class=\"hljs-attr\">13</span>,\n                  <span class=\"hljs-attr\">paddingLeft:</span> <span class=\"hljs-attr\">5</span>,\n                  <span class=\"hljs-attr\">fontSize:</span> <span class=\"hljs-attr\">18</span>,\n                }></span>\n                {selectedItem.label}\n              <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">WText</span>></span>\n            <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">View</span>></span>\n          );\n        }\n        dropdownOverlayColor=\"transparent\"\n        renderButton={() => {\n          return (\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">View</span>\n              <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{</span>\n                <span class=\"hljs-attr\">alignItems:</span> '<span class=\"hljs-attr\">flex-end</span>',\n                <span class=\"hljs-attr\">backgroundColor:</span> <span class=\"hljs-attr\">Colors.lighterBlack</span>,\n                <span class=\"hljs-attr\">borderRadius:</span> <span class=\"hljs-attr\">100</span>,\n                <span class=\"hljs-attr\">padding:</span> <span class=\"hljs-attr\">5</span>,\n              }></span>\n              <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Ionicons</span>\n                <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"ellipsis-vertical\"</span>\n                <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">{Colors.primary}</span>\n                <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">{30}</span>\n              /></span>\n            <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">View</span>></span>\n          );\n        }\n        onSelect={(selectedItem: DropDownData, index: number) => {\n          handleOptionSelect(selectedItem.value);\n        }\n        dropdownStyle={styles.dropdown}\n      />\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">View</span>></span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">DropDown</span>;\n</code></pre>\n<p>위에 무슨 일이 발생했나요? \"CustomTheme\"을 선택했을 때, 현재 테마의 값을 확인한 후, 테마를 번갈아가며 변경합니다. 그러나 \"system\" 옵션을 선택하면 폰의 기본 테마를 사용합니다.</p>\n<p>시스템 기본 테마 사용하기</p>\n<p>마지막으로 시스템 테마를 사용하려면 useColorScheme 훅을 활용할 수 있습니다. 이 훅은 기기에서 현재 사용 중인 색상테마에 대한 업데이트를 제공합니다. colors.tsx 파일에서 getThemeColor 함수를 수정해봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getThemeColor</span> = (<span class=\"hljs-params\">theme: <span class=\"hljs-string\">'light'</span> | <span class=\"hljs-string\">'dark'</span> = <span class=\"hljs-string\">'light'</span></span>) => {\n  <span class=\"hljs-keyword\">const</span> systemTheme = <span class=\"hljs-title function_\">useColorScheme</span>() || <span class=\"hljs-string\">'light'</span>;\n  <span class=\"hljs-keyword\">const</span> userTheme = <span class=\"hljs-title function_\">useSelector</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">state: RootState</span>) =></span> state.<span class=\"hljs-property\">theme</span>);\n  <span class=\"hljs-keyword\">const</span> {<span class=\"hljs-attr\">theme</span>: storedTheme} = userTheme;\n  <span class=\"hljs-keyword\">let</span> themeMode;\n\n  <span class=\"hljs-keyword\">if</span> (storedTheme === <span class=\"hljs-string\">'system'</span>) {\n    <span class=\"hljs-keyword\">const</span> themeMode = themes[systemTheme];\n    <span class=\"hljs-keyword\">return</span> themeMode;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">const</span> themeMode = themes[theme];\n    <span class=\"hljs-keyword\">return</span> themeMode;\n  }\n};\n</code></pre>\n<p>아래의 코드를 사용하여 저장소에서 현재 테마 색상을 제공받아 원하는 동작을 구현하는데 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> userTheme = <span class=\"hljs-title function_\">useSelector</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">state: RootState</span>) =></span> state.<span class=\"hljs-property\">theme</span>);\n<span class=\"hljs-keyword\">const</span> {theme} = userTheme;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Colors</span> = <span class=\"hljs-title function_\">getThemeColor</span>(theme);\n</code></pre>\n<p>아래는 우리의 결과입니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1152/1*2zA_7xp0whnKUe5a5ts_aA.gif\" alt=\"image\"></p>\n</body>\n</html>\n"},"__N_SSG":true}