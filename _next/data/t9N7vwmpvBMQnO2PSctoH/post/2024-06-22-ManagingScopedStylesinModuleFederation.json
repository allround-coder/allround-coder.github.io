{"pageProps":{"post":{"title":"모듈 페더레이션에서 범위 지정된 스타일 관리하는 방법","description":"","date":"2024-06-22 03:46","slug":"2024-06-22-ManagingScopedStylesinModuleFederation","content":"\n\n<img src=\"/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png\" />\n\n현대 웹 개발 세계에서, 마이크로 프론트엔드가 점점 더 인기를 얻고 있습니다. 마이크로 프론트엔드를 가능하게 하는 주요 기술 중 하나는 Webpack의 Module Federation입니다. 이 기능을 통해 다른 Webpack 빌드가 런타임에서 함께 작동하고 코드를 공유할 수 있습니다. 그러나 Module Federation 애플리케이션에서 CSS를 관리하는 것은 어려운 과제일 수 있습니다.\n\n이 글에서는 우리가 이러한 CSS 도전 과제를 어떻게 처리했는지 설명하겠습니다. 우리가 사용한 전략과 개발한 사용자 정의 PostCSS 플러그인을 공유할 것입니다. 우리의 접근 방식을 공유함으로써, 우리의 마이크로 프론트엔드 프로젝트에서 비슷한 문제에 직면한 다른 개발자들에게 도움이 되기를 희망합니다.\n\n# CSS 도전적 과제\n\n<div class=\"content-ad\"></div>\n\nCSS에 대해 이야기할 때, 전통적인 스타일 포함 방법은 갈등과 일관성 부족으로 이어질 수 있습니다. 이는 여러 팀이 다른 CSS 방법론, 전처리기 또는 프레임워크를 사용할 수 있는 모듈 연합 설정에서 특히 문제가 될 수 있습니다. 주요 도전 과제는 다음과 같습니다:\n\n- CSS 범위 격리: 서로 다른 마이크로 프론트엔드 간의 스타일 충돌을 피하는 것.\n- CSS 로딩 순서: 스타일이 올바른 순서로 로드되도록 보장하는 것.\n- 공유 스타일: 서로 다른 마이크로 프론트엔드 간에 공유되는 일반적인 스타일을 관리하는 것.\n\n저희 프로젝트에서는 Tailwind CSS 프레임워크를 사용하고 있었습니다. Tailwind를 마이크로 프론트엔드 애플리케이션에 통합할 때, 원치 않는 화면이 발생하는 충돌이 있었던 일이 있습니다.\n\n# 초기 해결책: 접두사 추가\n\n<div class=\"content-ad\"></div>\n\n가장 간단한 해결책은 각 클래스명에 접두사를 추가하는 것이었습니다. Tailwind의 구성에서 접두사를 추가할 수 있는 옵션이 있습니다:\n\n```js\nmodule.exports = {\n  prefix: 'app1-',\n  darkMode: ['class'],\n  content: ['./app/**/*.{js,ts,tsx,html}', './src/**/*.{js,ts,tsx,html}']\n}\n```\n\n그러나 이 방식으로 구성하려면 모든 클래스명을 접두사로 시작하도록 변경해야 했습니다:\n\n```js\n<!-- 변경 전 -->\n<div className=\"flex gap-3 mb-2 w-full\"/>\n\n<!-- 변경 후 -->\n<div className=\"app1-flex app1-gap-3 app1-mb-2 app1-w-full\"/>\n```\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식은 작동했지만 코드 작성과 유지 관리가 어려워졌어요. 예를 들어, 접두사를 추가하는 걸 잊고 이런 경우에 이슈를 찾으려고 했어요. 우리는 다른 해결책이 필요했어요.\n\n# 우리의 해결책: 사용자 정의 PostCSS 플러그인\n\n더 우아하게 이 문제를 해결하기 위해 우리는 모든 CSS 선택기를 특정 부모 선택기로 래핑하는 사용자 정의 PostCSS 플러그인을 개발했어요. 이렇게 함으로써 스타일이 특정한 마이크로 프런트엔드에 대해 스코프가 지정되어 애플리케이션의 다른 부분과 충돌하는 것을 방지했어요.\n\n## 사용자 정의 PostCSS 플러그인 예시\n\n<div class=\"content-ad\"></div>\n\n우리가 만든 사용자 정의 PostCSS 플러그인을 보여드릴게요:\n\n```js\n// postcss.config.js\nconst tailwindcss = require('tailwindcss');\nconst wrapSelector = (opts = {}) => ({\n  postcssPlugin: 'wrap-selector',\n  Once(root) {\n    root.walkRules((rule) => {\n      if (!rule.selectors) return rule;\n      rule.selectors = rule.selectors.map((selector) => `${opts.wrapper} ${selector}`);\n    });\n  },\n});\nwrapSelector.postcss = true;\n\nmodule.exports = {\n  plugins: ['postcss-preset-env', tailwindcss, wrapSelector({ wrapper: '#app1-id' })],\n};\n```\n\n## 작동 방법\n\n- 플러그인 정의: wrapSelector 함수는 PostCSS 플러그인으로 정의됩니다. opts 객체를 입력값으로 받아들이는데, 이 객체에는 기존 CSS 선택자 주변에 감쌀 부모 선택자인 wrapper 속성이 포함되어 있습니다.\n- 규칙 탐색: Once 메서드는 모든 CSS 규칙을 탐색합니다. 선택자가 있는 각 규칙마다 해당하는 wrapper와 함께 접두어를 붙인 새 선택자로 매핑합니다.\n- PostCSS 설정: 이 플러그인은 postcss-preset-env 및 tailwindcss와 같은 다른 플러그인과 함께 PostCSS 구성에 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 모듈 연합에서의 사용법\n\n이 사용자 지정 PostCSS 플러그인을 모듈 연합 설정에서 사용하려면 다음 단계를 따르세요:\n\n- PostCSS 구성: 위에 표시된대로 사용자 지정 플러그인이 포함된 PostCSS 구성을 확인하십시오.\n- 스코프 스타일 적용: CSS 선택자를 래핑하여 마이크로 프론트엔드 애플리케이션에서 스타일이 적절히 스코프화되도록합니다.\n\n## 웹팩에서의 구성 예시\n\n<div class=\"content-ad\"></div>\n\n웹팩 구성에 PostCSS 플러그인을 통합하는 방법은 다음과 같습니다:\n\n```js\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/i,\n        use: ['style-loader', 'css-loader', 'postcss-loader'],\n      }\n    ],\n  },\n};\n```\n\n## 리액트 컴포넌트에서의 예시 사용법\n\n```js\nimport React from 'react';\n\nconst App = () => {\n  return (\n    <div id=\"app1-id\">\n      <h1 className=\"text-2xl font-bold\">안녕하세요, App 1에서 인사드립니다</h1>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nModule Federation 애플리케이션에서 CSS를 다루려면 범위 격리, 로딩 순서 및 공유 스타일을 신중히 고려해야 합니다. 위에서 소개한 것과 같이 커스텀 PostCSS 플러그인을 활용하여 CSS를 효과적으로 관리하고 스타일이 개별 마이크로 프론트엔드에 적절하게 스코프되도록 할 수 있습니다. 이 접근 방식을 통해 마이크로 프론트엔드 애플리케이션에서 모듈식이며 충돌이 없는 CSS 아키텍처를 유지할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png"},"coverImage":"/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>현대 웹 개발 세계에서, 마이크로 프론트엔드가 점점 더 인기를 얻고 있습니다. 마이크로 프론트엔드를 가능하게 하는 주요 기술 중 하나는 Webpack의 Module Federation입니다. 이 기능을 통해 다른 Webpack 빌드가 런타임에서 함께 작동하고 코드를 공유할 수 있습니다. 그러나 Module Federation 애플리케이션에서 CSS를 관리하는 것은 어려운 과제일 수 있습니다.</p>\n<p>이 글에서는 우리가 이러한 CSS 도전 과제를 어떻게 처리했는지 설명하겠습니다. 우리가 사용한 전략과 개발한 사용자 정의 PostCSS 플러그인을 공유할 것입니다. 우리의 접근 방식을 공유함으로써, 우리의 마이크로 프론트엔드 프로젝트에서 비슷한 문제에 직면한 다른 개발자들에게 도움이 되기를 희망합니다.</p>\n<h1>CSS 도전적 과제</h1>\n<p>CSS에 대해 이야기할 때, 전통적인 스타일 포함 방법은 갈등과 일관성 부족으로 이어질 수 있습니다. 이는 여러 팀이 다른 CSS 방법론, 전처리기 또는 프레임워크를 사용할 수 있는 모듈 연합 설정에서 특히 문제가 될 수 있습니다. 주요 도전 과제는 다음과 같습니다:</p>\n<ul>\n<li>CSS 범위 격리: 서로 다른 마이크로 프론트엔드 간의 스타일 충돌을 피하는 것.</li>\n<li>CSS 로딩 순서: 스타일이 올바른 순서로 로드되도록 보장하는 것.</li>\n<li>공유 스타일: 서로 다른 마이크로 프론트엔드 간에 공유되는 일반적인 스타일을 관리하는 것.</li>\n</ul>\n<p>저희 프로젝트에서는 Tailwind CSS 프레임워크를 사용하고 있었습니다. Tailwind를 마이크로 프론트엔드 애플리케이션에 통합할 때, 원치 않는 화면이 발생하는 충돌이 있었던 일이 있습니다.</p>\n<h1>초기 해결책: 접두사 추가</h1>\n<p>가장 간단한 해결책은 각 클래스명에 접두사를 추가하는 것이었습니다. Tailwind의 구성에서 접두사를 추가할 수 있는 옵션이 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">prefix</span>: <span class=\"hljs-string\">'app1-'</span>,\n  <span class=\"hljs-attr\">darkMode</span>: [<span class=\"hljs-string\">'class'</span>],\n  <span class=\"hljs-attr\">content</span>: [<span class=\"hljs-string\">'./app/**/*.{js,ts,tsx,html}'</span>, <span class=\"hljs-string\">'./src/**/*.{js,ts,tsx,html}'</span>]\n}\n</code></pre>\n<p>그러나 이 방식으로 구성하려면 모든 클래스명을 접두사로 시작하도록 변경해야 했습니다:</p>\n<pre><code class=\"hljs language-js\">&#x3C;!-- 변경 전 -->\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"flex gap-3 mb-2 w-full\"</span>/></span></span>\n\n&#x3C;!-- 변경 후 -->\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"app1-flex app1-gap-3 app1-mb-2 app1-w-full\"</span>/></span></span>\n</code></pre>\n<p>이 접근 방식은 작동했지만 코드 작성과 유지 관리가 어려워졌어요. 예를 들어, 접두사를 추가하는 걸 잊고 이런 경우에 이슈를 찾으려고 했어요. 우리는 다른 해결책이 필요했어요.</p>\n<h1>우리의 해결책: 사용자 정의 PostCSS 플러그인</h1>\n<p>더 우아하게 이 문제를 해결하기 위해 우리는 모든 CSS 선택기를 특정 부모 선택기로 래핑하는 사용자 정의 PostCSS 플러그인을 개발했어요. 이렇게 함으로써 스타일이 특정한 마이크로 프런트엔드에 대해 스코프가 지정되어 애플리케이션의 다른 부분과 충돌하는 것을 방지했어요.</p>\n<h2>사용자 정의 PostCSS 플러그인 예시</h2>\n<p>우리가 만든 사용자 정의 PostCSS 플러그인을 보여드릴게요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// postcss.config.js</span>\n<span class=\"hljs-keyword\">const</span> tailwindcss = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'tailwindcss'</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">wrapSelector</span> = (<span class=\"hljs-params\">opts = {}</span>) => ({\n  <span class=\"hljs-attr\">postcssPlugin</span>: <span class=\"hljs-string\">'wrap-selector'</span>,\n  <span class=\"hljs-title class_\">Once</span>(root) {\n    root.<span class=\"hljs-title function_\">walkRules</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">rule</span>) =></span> {\n      <span class=\"hljs-keyword\">if</span> (!rule.<span class=\"hljs-property\">selectors</span>) <span class=\"hljs-keyword\">return</span> rule;\n      rule.<span class=\"hljs-property\">selectors</span> = rule.<span class=\"hljs-property\">selectors</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">selector</span>) =></span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${opts.wrapper}</span> <span class=\"hljs-subst\">${selector}</span>`</span>);\n    });\n  },\n});\nwrapSelector.<span class=\"hljs-property\">postcss</span> = <span class=\"hljs-literal\">true</span>;\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-string\">'postcss-preset-env'</span>, tailwindcss, <span class=\"hljs-title function_\">wrapSelector</span>({ <span class=\"hljs-attr\">wrapper</span>: <span class=\"hljs-string\">'#app1-id'</span> })],\n};\n</code></pre>\n<h2>작동 방법</h2>\n<ul>\n<li>플러그인 정의: wrapSelector 함수는 PostCSS 플러그인으로 정의됩니다. opts 객체를 입력값으로 받아들이는데, 이 객체에는 기존 CSS 선택자 주변에 감쌀 부모 선택자인 wrapper 속성이 포함되어 있습니다.</li>\n<li>규칙 탐색: Once 메서드는 모든 CSS 규칙을 탐색합니다. 선택자가 있는 각 규칙마다 해당하는 wrapper와 함께 접두어를 붙인 새 선택자로 매핑합니다.</li>\n<li>PostCSS 설정: 이 플러그인은 postcss-preset-env 및 tailwindcss와 같은 다른 플러그인과 함께 PostCSS 구성에 포함됩니다.</li>\n</ul>\n<h1>모듈 연합에서의 사용법</h1>\n<p>이 사용자 지정 PostCSS 플러그인을 모듈 연합 설정에서 사용하려면 다음 단계를 따르세요:</p>\n<ul>\n<li>PostCSS 구성: 위에 표시된대로 사용자 지정 플러그인이 포함된 PostCSS 구성을 확인하십시오.</li>\n<li>스코프 스타일 적용: CSS 선택자를 래핑하여 마이크로 프론트엔드 애플리케이션에서 스타일이 적절히 스코프화되도록합니다.</li>\n</ul>\n<h2>웹팩에서의 구성 예시</h2>\n<p>웹팩 구성에 PostCSS 플러그인을 통합하는 방법은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.config.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/i</span>,\n        <span class=\"hljs-attr\">use</span>: [<span class=\"hljs-string\">'style-loader'</span>, <span class=\"hljs-string\">'css-loader'</span>, <span class=\"hljs-string\">'postcss-loader'</span>],\n      }\n    ],\n  },\n};\n</code></pre>\n<h2>리액트 컴포넌트에서의 예시 사용법</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app1-id\"</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"text-2xl font-bold\"</span>></span>안녕하세요, App 1에서 인사드립니다<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;\n</code></pre>\n<h1>결론</h1>\n<p>Module Federation 애플리케이션에서 CSS를 다루려면 범위 격리, 로딩 순서 및 공유 스타일을 신중히 고려해야 합니다. 위에서 소개한 것과 같이 커스텀 PostCSS 플러그인을 활용하여 CSS를 효과적으로 관리하고 스타일이 개별 마이크로 프론트엔드에 적절하게 스코프되도록 할 수 있습니다. 이 접근 방식을 통해 마이크로 프론트엔드 애플리케이션에서 모듈식이며 충돌이 없는 CSS 아키텍처를 유지할 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}