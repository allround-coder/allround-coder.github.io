{"pageProps":{"post":{"title":"플러터에서 텍스트 스케일링을 적절히 다루는 방법","description":"","date":"2024-05-17 03:37","slug":"2024-05-17-ProperlyhandlingtextscalinginFlutter","content":"\n이 튜토리얼은 가장 쉽고 영향력이 큰 해결책을 먼저 제시하도록 구성되어 있어요. 후속 섹션에는 구현이 어려우면서 전반적인 영향이 더 낮은 해결책들이 포함되어 있지만, 특정 경우에 대응하기 위해 유용해요.\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png)\n\n## 텍스트 스케일링 가능 범위 제한\n\nMaterialApp에 최소 및 최대 스케일 팩터를 설정할 수 있어요. 이렇게 하면 모든 텍스트가 지정한 범위 내에서 스케일링된다는 것을 보장할 수 있어요. 더 빈번한 경계는 가독성과 미적 감각을 유지하는 데 덜 노력이 필요해요. 그러나 경계 선택은 대상 사용자에 따라 달라져야 해요. 예를 들어 노인 사용자를 대상으로 한 앱의 경우, 그들의 요구를 수용하기 위해 더 넓은 범위를 사용하는 것을 고려해야 해요.\n\n<div class=\"content-ad\"></div>\n\n```js\n    MaterialApp(\n      ...\n      builder: (_, child) => MediaQuery(\n        data: MediaQuery.of(context).copyWith(\n          textScaler: MediaQuery.of(context)\n              .textScaler\n              .clamp(minScaleFactor: 0.8, maxScaleFactor: 1.6),\n        ),\n        child: child!,\n      ),\n    );\n```\n\n## 텍스트를 포함하는 요소에 고정 높이를 사용하지 마세요\n\n다음 코드를 살펴보세요:\n\n```js\n          //DON'T\n          SizedBox(\n            height: 100,\n            child: Card(\n              child: Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: [\n                    Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n                    Text(\"Subtitle\", maxLines: 1),\n                  ],\n                ),\n              ),\n            ),\n          ),\n```\n\n<div class=\"content-ad\"></div>\n\n문제가 발생할 수 있습니다.\n\n예상하신 대로, 텍스트 크기를 키우면 SizedBox의 내용이 너무 많은 공간을 차지할 수 있습니다.\n\n![image](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_1.png)\n\n컨텐츠 높이 및 패딩에 기반한 아이템의 높이를 만드는 것이 더 좋습니다. 게다가 ConstrainedBox를 사용하여 최소 높이를 설정할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nConstrainedBox(\n  constraints: const BoxConstraints(minHeight: 100),\n  child: const Card(\n    child: Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n          Text(\"Subtitle\", maxLines: 1),\n        ],\n      ),\n    ),\n  ),\n),\n```\n\n결과적으로 100% 배율에서 동일한 레이아웃을 얻고, 160%에서도 유효한 레이아웃을 얻을 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_2.png\" />\n\nListView에도 동일한 사항이 적용됩니다. itemExtent를 사용하는 경우, 폰트 스케일을 고려하여 계산하거나 prototypeItem을 제공하는 것이 좋습니다. 이에 대해 자세히 설명된 내용은 이 기사에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n계속 진행해 봅시다. 다음 레이아웃을 상상해보세요:\n\n![Image1](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_3.png)\n\n아이템 A는 이전 예시에서 나왔어요. 아이템 B는 약간의 간격을 가지고 있고 텍스트 확대에 대응할 수 있어야해요. 화면 하단에는 충분한 공간이 있어요. 그래서 어떤 문제가 발생할 수 있을까요?\n\n![Image2](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_4.png)\n\n<div class=\"content-ad\"></div>\n\n화면이 작은 폰들도 고려해주세요. 또한, 언어를 바꿀 때 텍스트 길이가 달라질 수 있어요.\n\n## 컨텐츠를 스크롤할 수 있도록 만들기\n\n먼저, 모든 컨텐츠에 접근 가능하도록 오버플로우를 제거해야 해요. 간단한 SingleChildScrollView를 추가하면 이 문제를 해결할 수 있어요.\n\n## 마진과 패딩에 대해 적응적인 값을 사용하는 것을 고려해보세요\n\n<div class=\"content-ad\"></div>\n\n이것은 논란이 될 수 있는 방법일 수 있지만, 자신이 더 큰 글꼴을 사용해야 하는 사용자로 상상해보세요. 사용되지 않는 공간을 많이 보고 싶으신가요 아니면 텍스트를 명확하게 읽고 싶으신가요?\n\n텍스트를 표시하는 논리적 픽셀의 수에 따라 값들을 사용해봅시다. smallScreenThreshold를 응용 프로그램에 가장 적합한 값으로 조절할 수 있습니다.\n\n```js\nclass Dimens {\n  static const smallScreenThreshold = 300;\n  static bool isSmallWidth(BuildContext context) {\n    return MediaQuery.of(context).size.width /\n            MediaQuery.textScalerOf(context).scale(1) <\n        smallScreenThreshold;\n  }\n\n  static double small(BuildContext context) => isSmallWidth(context) ? 4 : 8;\n  static double medium(BuildContext context) => isSmallWidth(context) ? 8 : 16;\n  static double large(BuildContext context) => isSmallWidth(context) ? 16 : 32;\n}\n```\n\n만약 Human Interface Guidelines와 Material Design을 따르고 싶다면, 이 값들은 4로 나눌 수 있는 값이어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 Dimens에 기반하여 간격에 대한 클래스를 만들 수 있습니다:\n\n```js\nclass Insets {\n  static EdgeInsets small(BuildContext context) =>\n      EdgeInsets.all(Dimens.small(context));\n\n  static EdgeInsets medium(BuildContext context) =>\n      EdgeInsets.all(Dimens.medium(context));\n\n  static EdgeInsets large(BuildContext context) =>\n      EdgeInsets.all(Dimens.large(context));\n}\n```\n\n그리고 코드에서 다음과 같이 대체합니다:\n\n```js\n//padding: const EdgeInsets.all(16),\npadding: Insets.medium(context),\n\n//SizedBox(height: 16),\nSizedBox(height: Dimens.medium(context)),\n```\n\n<div class=\"content-ad\"></div>\n\n결과적으로 화면에 텍스트를 그릴 수 있는 공간이 조금 더 확보되었습니다:\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_5.png)\n\n## 제목의 텍스트 크기 확장을 제한하세요\n\n글꼴 크기를 크게 하는 주된 목적은 시력이 약해진 사람들에게 콘텐츠를 가독성 있게 만드는 것입니다. 그러나 제목과 같은 앱의 일부는 이미 글꼴이 크기 때문에 접근성이 좋을 수 있습니다. 이를 해결하기 위해 텍스트가 확대될 수 있는 범위를 제한할 수 있습니다. 이를 달성하는 한 가지 방법은 제목용 사용자 정의 위젯을 만드는 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nclass TitleText extends StatelessWidget {\n  final String text;\n  final TextStyle style;\n\n  const TitleText(this.text, {required this.style, super.key});\n\n  static const double maxRealFontSize = 30;\n\n  @override\n  Widget build(BuildContext context) {\n    if (MediaQuery.textScalerOf(context).scale(style.fontSize!) >\n        maxRealFontSize) {\n      return Text(\n        text,\n        style: style.copyWith(\n          fontSize: maxRealFontSize / MediaQuery.textScalerOf(context).scale(1),\n        ),\n      );\n    }\n    return Text(text, style: style);\n  }\n}\n```\n\n이렇게 하면 가독성을 유지하면서 공간을 더 확보할 수 있어요. 앱에 더 적합한 값으로 maxRealFontSize를 변경할 수 있어요.\n\n<img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_6.png\" />\n\n## 최대 줄 수 및 텍스트 오버플로우 지정하기\n\n<div class=\"content-ad\"></div>\n\n큰 화면에서 일반적인 텍스트 스케일로 보기 좋을 수도 있지만, 다른 조건에서는 수직 공간을 더 많이 차지할 수 있음을 잊지 마세요. 그러나 제목(Subtitle)과 같은 곳은 항상 전체 내용을 표시할 필요가 없습니다. Text 위젯에 maxLines 값을 추가하여 원하는 줄 수로 설정할 수 있습니다.\n\n![Properly handling text scaling in Flutter](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_7.png)\n\n1로 설정된 maxLines로 보기 좋네요. 주요 정보는 여전히 잘 보입니다.\n\n## 문자열의 대안 버전 사용하기\n\n<div class=\"content-ad\"></div>\n\n하지만 항상 유용한 정보를 포함하는 방식으로 문자열을 줄이는 것이 가능한 것은 아닙니다. 게다가, 단어 순서는 다른 언어들에서 다르게 변할 수 있습니다. 영어에서의 첫 번째 단어가 다른 언어에서는 문장의 끝에 올 수도 있습니다. 이번에는 국제화(i18n) 문자열을 고려해보는 것이 중요합니다:\n\n```js\n        \"tasksDone\": {\n            \"one\": \"할 일 중 $completed 개 완료\",\n            \"other\": \"할 일 중 $completed 개 완료\"\n        },\n        \"tasksDoneShort\": {\n            \"one\": \"$completed/$n 작업 완료\",\n            \"other\": \"$completed/$n 작업 완료\"\n        },\n```\n\n가장 의미 있는 부분은 숫자를 나타낸 부분입니다. 더 짧은 버전에서 숫자를 앞에 두고 전체 문자열을 더 짧게 만들었습니다. 코드에서는 다음과 같이 사용할 수 있습니다:\n\n```js\n        Text(\n          Dimens.isSmallWidth(context)\n              ? t.tasksDoneShort(n: 10, completed: 5)\n              : t.tasksDone(n: 10, completed: 5),\n          maxLines: 1,\n        )\n```\n\n<div class=\"content-ad\"></div>\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_8.png)\n\n스크린샷을 보시면, 단축된 버전을 사용하면 필요한 정보를 보여주는 데 도움이 됩니다.\n\n이 기사가 유용하게 느껴졌으면 좋겠네요. 더 유용한 기술을 찾으면 업데이트할 예정입니다. 코드는 이 저장소에서 찾을 수 있습니다.\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_9.png)\n","ogImage":{"url":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png"},"coverImage":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>이 튜토리얼은 가장 쉽고 영향력이 큰 해결책을 먼저 제시하도록 구성되어 있어요. 후속 섹션에는 구현이 어려우면서 전반적인 영향이 더 낮은 해결책들이 포함되어 있지만, 특정 경우에 대응하기 위해 유용해요.</p>\n<p><img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png\" alt=\"이미지\"></p>\n<h2>텍스트 스케일링 가능 범위 제한</h2>\n<p>MaterialApp에 최소 및 최대 스케일 팩터를 설정할 수 있어요. 이렇게 하면 모든 텍스트가 지정한 범위 내에서 스케일링된다는 것을 보장할 수 있어요. 더 빈번한 경계는 가독성과 미적 감각을 유지하는 데 덜 노력이 필요해요. 그러나 경계 선택은 대상 사용자에 따라 달라져야 해요. 예를 들어 노인 사용자를 대상으로 한 앱의 경우, 그들의 요구를 수용하기 위해 더 넓은 범위를 사용하는 것을 고려해야 해요.</p>\n<pre><code class=\"hljs language-js\">    <span class=\"hljs-title class_\">MaterialApp</span>(\n      ...\n      <span class=\"hljs-attr\">builder</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">_, child</span>) =></span> <span class=\"hljs-title class_\">MediaQuery</span>(\n        <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">MediaQuery</span>.<span class=\"hljs-title function_\">of</span>(context).<span class=\"hljs-title function_\">copyWith</span>(\n          <span class=\"hljs-attr\">textScaler</span>: <span class=\"hljs-title class_\">MediaQuery</span>.<span class=\"hljs-title function_\">of</span>(context)\n              .<span class=\"hljs-property\">textScaler</span>\n              .<span class=\"hljs-title function_\">clamp</span>(<span class=\"hljs-attr\">minScaleFactor</span>: <span class=\"hljs-number\">0.8</span>, <span class=\"hljs-attr\">maxScaleFactor</span>: <span class=\"hljs-number\">1.6</span>),\n        ),\n        <span class=\"hljs-attr\">child</span>: child!,\n      ),\n    );\n</code></pre>\n<h2>텍스트를 포함하는 요소에 고정 높이를 사용하지 마세요</h2>\n<p>다음 코드를 살펴보세요:</p>\n<pre><code class=\"hljs language-js\">          <span class=\"hljs-comment\">//DON'T</span>\n          <span class=\"hljs-title class_\">SizedBox</span>(\n            <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">100</span>,\n            <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Card</span>(\n              <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Center</span>(\n                <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Column</span>(\n                  <span class=\"hljs-attr\">mainAxisAlignment</span>: <span class=\"hljs-title class_\">MainAxisAlignment</span>.<span class=\"hljs-property\">center</span>,\n                  <span class=\"hljs-attr\">children</span>: [\n                    <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Title\"</span>, <span class=\"hljs-attr\">style</span>: <span class=\"hljs-title class_\">TextStyle</span>(<span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">30</span>), <span class=\"hljs-attr\">maxLines</span>: <span class=\"hljs-number\">1</span>),\n                    <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Subtitle\"</span>, <span class=\"hljs-attr\">maxLines</span>: <span class=\"hljs-number\">1</span>),\n                  ],\n                ),\n              ),\n            ),\n          ),\n</code></pre>\n<p>문제가 발생할 수 있습니다.</p>\n<p>예상하신 대로, 텍스트 크기를 키우면 SizedBox의 내용이 너무 많은 공간을 차지할 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_1.png\" alt=\"image\"></p>\n<p>컨텐츠 높이 및 패딩에 기반한 아이템의 높이를 만드는 것이 더 좋습니다. 게다가 ConstrainedBox를 사용하여 최소 높이를 설정할 수도 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">ConstrainedBox</span>(\n  <span class=\"hljs-attr\">constraints</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">BoxConstraints</span>(<span class=\"hljs-attr\">minHeight</span>: <span class=\"hljs-number\">100</span>),\n  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Card</span>(\n    <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Center</span>(\n      <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Column</span>(\n        <span class=\"hljs-attr\">mainAxisAlignment</span>: <span class=\"hljs-title class_\">MainAxisAlignment</span>.<span class=\"hljs-property\">center</span>,\n        <span class=\"hljs-attr\">children</span>: [\n          <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Title\"</span>, <span class=\"hljs-attr\">style</span>: <span class=\"hljs-title class_\">TextStyle</span>(<span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">30</span>), <span class=\"hljs-attr\">maxLines</span>: <span class=\"hljs-number\">1</span>),\n          <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Subtitle\"</span>, <span class=\"hljs-attr\">maxLines</span>: <span class=\"hljs-number\">1</span>),\n        ],\n      ),\n    ),\n  ),\n),\n</code></pre>\n<p>결과적으로 100% 배율에서 동일한 레이아웃을 얻고, 160%에서도 유효한 레이아웃을 얻을 수 있습니다.</p>\n<p>ListView에도 동일한 사항이 적용됩니다. itemExtent를 사용하는 경우, 폰트 스케일을 고려하여 계산하거나 prototypeItem을 제공하는 것이 좋습니다. 이에 대해 자세히 설명된 내용은 이 기사에서 확인할 수 있습니다.</p>\n<p>계속 진행해 봅시다. 다음 레이아웃을 상상해보세요:</p>\n<p><img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_3.png\" alt=\"Image1\"></p>\n<p>아이템 A는 이전 예시에서 나왔어요. 아이템 B는 약간의 간격을 가지고 있고 텍스트 확대에 대응할 수 있어야해요. 화면 하단에는 충분한 공간이 있어요. 그래서 어떤 문제가 발생할 수 있을까요?</p>\n<p><img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_4.png\" alt=\"Image2\"></p>\n<p>화면이 작은 폰들도 고려해주세요. 또한, 언어를 바꿀 때 텍스트 길이가 달라질 수 있어요.</p>\n<h2>컨텐츠를 스크롤할 수 있도록 만들기</h2>\n<p>먼저, 모든 컨텐츠에 접근 가능하도록 오버플로우를 제거해야 해요. 간단한 SingleChildScrollView를 추가하면 이 문제를 해결할 수 있어요.</p>\n<h2>마진과 패딩에 대해 적응적인 값을 사용하는 것을 고려해보세요</h2>\n<p>이것은 논란이 될 수 있는 방법일 수 있지만, 자신이 더 큰 글꼴을 사용해야 하는 사용자로 상상해보세요. 사용되지 않는 공간을 많이 보고 싶으신가요 아니면 텍스트를 명확하게 읽고 싶으신가요?</p>\n<p>텍스트를 표시하는 논리적 픽셀의 수에 따라 값들을 사용해봅시다. smallScreenThreshold를 응용 프로그램에 가장 적합한 값으로 조절할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dimens</span> {\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> smallScreenThreshold = <span class=\"hljs-number\">300</span>;\n  <span class=\"hljs-keyword\">static</span> bool <span class=\"hljs-title function_\">isSmallWidth</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MediaQuery</span>.<span class=\"hljs-title function_\">of</span>(context).<span class=\"hljs-property\">size</span>.<span class=\"hljs-property\">width</span> /\n            <span class=\"hljs-title class_\">MediaQuery</span>.<span class=\"hljs-title function_\">textScalerOf</span>(context).<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">1</span>) &#x3C;\n        smallScreenThreshold;\n  }\n\n  <span class=\"hljs-keyword\">static</span> double <span class=\"hljs-title function_\">small</span>(<span class=\"hljs-title class_\">BuildContext</span> context) => <span class=\"hljs-title function_\">isSmallWidth</span>(context) ? <span class=\"hljs-number\">4</span> : <span class=\"hljs-number\">8</span>;\n  <span class=\"hljs-keyword\">static</span> double <span class=\"hljs-title function_\">medium</span>(<span class=\"hljs-title class_\">BuildContext</span> context) => <span class=\"hljs-title function_\">isSmallWidth</span>(context) ? <span class=\"hljs-number\">8</span> : <span class=\"hljs-number\">16</span>;\n  <span class=\"hljs-keyword\">static</span> double <span class=\"hljs-title function_\">large</span>(<span class=\"hljs-title class_\">BuildContext</span> context) => <span class=\"hljs-title function_\">isSmallWidth</span>(context) ? <span class=\"hljs-number\">16</span> : <span class=\"hljs-number\">32</span>;\n}\n</code></pre>\n<p>만약 Human Interface Guidelines와 Material Design을 따르고 싶다면, 이 값들은 4로 나눌 수 있는 값이어야 합니다.</p>\n<p>이러한 Dimens에 기반하여 간격에 대한 클래스를 만들 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Insets</span> {\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title class_\">EdgeInsets</span> <span class=\"hljs-title function_\">small</span>(<span class=\"hljs-title class_\">BuildContext</span> context) =>\n      <span class=\"hljs-title class_\">EdgeInsets</span>.<span class=\"hljs-title function_\">all</span>(<span class=\"hljs-title class_\">Dimens</span>.<span class=\"hljs-title function_\">small</span>(context));\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title class_\">EdgeInsets</span> <span class=\"hljs-title function_\">medium</span>(<span class=\"hljs-title class_\">BuildContext</span> context) =>\n      <span class=\"hljs-title class_\">EdgeInsets</span>.<span class=\"hljs-title function_\">all</span>(<span class=\"hljs-title class_\">Dimens</span>.<span class=\"hljs-title function_\">medium</span>(context));\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title class_\">EdgeInsets</span> <span class=\"hljs-title function_\">large</span>(<span class=\"hljs-title class_\">BuildContext</span> context) =>\n      <span class=\"hljs-title class_\">EdgeInsets</span>.<span class=\"hljs-title function_\">all</span>(<span class=\"hljs-title class_\">Dimens</span>.<span class=\"hljs-title function_\">large</span>(context));\n}\n</code></pre>\n<p>그리고 코드에서 다음과 같이 대체합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//padding: const EdgeInsets.all(16),</span>\n<span class=\"hljs-attr\">padding</span>: <span class=\"hljs-title class_\">Insets</span>.<span class=\"hljs-title function_\">medium</span>(context),\n\n<span class=\"hljs-comment\">//SizedBox(height: 16),</span>\n<span class=\"hljs-title class_\">SizedBox</span>(<span class=\"hljs-attr\">height</span>: <span class=\"hljs-title class_\">Dimens</span>.<span class=\"hljs-title function_\">medium</span>(context)),\n</code></pre>\n<p>결과적으로 화면에 텍스트를 그릴 수 있는 공간이 조금 더 확보되었습니다:</p>\n<p><img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_5.png\" alt=\"이미지\"></p>\n<h2>제목의 텍스트 크기 확장을 제한하세요</h2>\n<p>글꼴 크기를 크게 하는 주된 목적은 시력이 약해진 사람들에게 콘텐츠를 가독성 있게 만드는 것입니다. 그러나 제목과 같은 앱의 일부는 이미 글꼴이 크기 때문에 접근성이 좋을 수 있습니다. 이를 해결하기 위해 텍스트가 확대될 수 있는 범위를 제한할 수 있습니다. 이를 달성하는 한 가지 방법은 제목용 사용자 정의 위젯을 만드는 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TitleText</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  final <span class=\"hljs-title class_\">String</span> text;\n  final <span class=\"hljs-title class_\">TextStyle</span> style;\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">TitleText</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">text</span>, {required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">style</span>, <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">key</span>});\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> double maxRealFontSize = <span class=\"hljs-number\">30</span>;\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">MediaQuery</span>.<span class=\"hljs-title function_\">textScalerOf</span>(context).<span class=\"hljs-title function_\">scale</span>(style.<span class=\"hljs-property\">fontSize</span>!) >\n        maxRealFontSize) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Text</span>(\n        text,\n        <span class=\"hljs-attr\">style</span>: style.<span class=\"hljs-title function_\">copyWith</span>(\n          <span class=\"hljs-attr\">fontSize</span>: maxRealFontSize / <span class=\"hljs-title class_\">MediaQuery</span>.<span class=\"hljs-title function_\">textScalerOf</span>(context).<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">1</span>),\n        ),\n      );\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Text</span>(text, <span class=\"hljs-attr\">style</span>: style);\n  }\n}\n</code></pre>\n<p>이렇게 하면 가독성을 유지하면서 공간을 더 확보할 수 있어요. 앱에 더 적합한 값으로 maxRealFontSize를 변경할 수 있어요.</p>\n<h2>최대 줄 수 및 텍스트 오버플로우 지정하기</h2>\n<p>큰 화면에서 일반적인 텍스트 스케일로 보기 좋을 수도 있지만, 다른 조건에서는 수직 공간을 더 많이 차지할 수 있음을 잊지 마세요. 그러나 제목(Subtitle)과 같은 곳은 항상 전체 내용을 표시할 필요가 없습니다. Text 위젯에 maxLines 값을 추가하여 원하는 줄 수로 설정할 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_7.png\" alt=\"Properly handling text scaling in Flutter\"></p>\n<p>1로 설정된 maxLines로 보기 좋네요. 주요 정보는 여전히 잘 보입니다.</p>\n<h2>문자열의 대안 버전 사용하기</h2>\n<p>하지만 항상 유용한 정보를 포함하는 방식으로 문자열을 줄이는 것이 가능한 것은 아닙니다. 게다가, 단어 순서는 다른 언어들에서 다르게 변할 수 있습니다. 영어에서의 첫 번째 단어가 다른 언어에서는 문장의 끝에 올 수도 있습니다. 이번에는 국제화(i18n) 문자열을 고려해보는 것이 중요합니다:</p>\n<pre><code class=\"hljs language-js\">        <span class=\"hljs-string\">\"tasksDone\"</span>: {\n            <span class=\"hljs-string\">\"one\"</span>: <span class=\"hljs-string\">\"할 일 중 $completed 개 완료\"</span>,\n            <span class=\"hljs-string\">\"other\"</span>: <span class=\"hljs-string\">\"할 일 중 $completed 개 완료\"</span>\n        },\n        <span class=\"hljs-string\">\"tasksDoneShort\"</span>: {\n            <span class=\"hljs-string\">\"one\"</span>: <span class=\"hljs-string\">\"$completed/$n 작업 완료\"</span>,\n            <span class=\"hljs-string\">\"other\"</span>: <span class=\"hljs-string\">\"$completed/$n 작업 완료\"</span>\n        },\n</code></pre>\n<p>가장 의미 있는 부분은 숫자를 나타낸 부분입니다. 더 짧은 버전에서 숫자를 앞에 두고 전체 문자열을 더 짧게 만들었습니다. 코드에서는 다음과 같이 사용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">        <span class=\"hljs-title class_\">Text</span>(\n          <span class=\"hljs-title class_\">Dimens</span>.<span class=\"hljs-title function_\">isSmallWidth</span>(context)\n              ? t.<span class=\"hljs-title function_\">tasksDoneShort</span>(<span class=\"hljs-attr\">n</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-attr\">completed</span>: <span class=\"hljs-number\">5</span>)\n              : t.<span class=\"hljs-title function_\">tasksDone</span>(<span class=\"hljs-attr\">n</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-attr\">completed</span>: <span class=\"hljs-number\">5</span>),\n          <span class=\"hljs-attr\">maxLines</span>: <span class=\"hljs-number\">1</span>,\n        )\n</code></pre>\n<p><img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_8.png\" alt=\"Screenshot\"></p>\n<p>스크린샷을 보시면, 단축된 버전을 사용하면 필요한 정보를 보여주는 데 도움이 됩니다.</p>\n<p>이 기사가 유용하게 느껴졌으면 좋겠네요. 더 유용한 기술을 찾으면 업데이트할 예정입니다. 코드는 이 저장소에서 찾을 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_9.png\" alt=\"Screenshot\"></p>\n</body>\n</html>\n"},"__N_SSG":true}