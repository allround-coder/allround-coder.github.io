{"pageProps":{"post":{"title":"웹 워커 관련 프론트엔드 면접 질문","description":"","date":"2024-05-02 00:08","slug":"2024-05-02-WebWorkersInterviewQuestions","content":"\n\n주제 안내:\n\n# 웹 워커:\n\n웹 워커는 브라우저 기능의 일부입니다. 현재 페이지의 백그라운드에서 생성될 수 있는 실제 OS 스레드로, 복잡하고 자원 집약적인 작업을 수행할 수 있습니다.\n\n서버에서 대량의 데이터를 가져와야 하거나 UI에 복잡한 렌더링이 필요한 경우를 상상해보세요. 이를 직접 웹페이지에서 처리한다면 페이지가 더 부드럽지 않을 수 있고 UI에 영향을 줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위 웹 워커를 사용하여 이 문제를 완화할 수 있어요. 웹 워커는 웹 워커라 불리는 쓰레드를 만들고, 그 웹 워커가 복잡한 작업을 처리하도록 할 수 있어요.\n\n웹 워커와 간단하게 소통할 수 있으며, 이를 통해 워커와 UI 간에 데이터를 주고받을 수 있어요.\n\n아래는 웹 워커의 주요 기능 몇 가지에요:\n\n- 웹 워커는 쓰레드 기반의 JavaScript입니다.\n- 웹 워커는 더 많은 공간과 CPU 시간을 요구해요.\n- 웹 워커는 웹사이트의 속도를 향상시켜 줘요.\n- 웹 워커는 클라이언트 측에서 코드를 실행해요 (서버 측이 아니에요).\n- 웹 워커 쓰레드는 postMessage() 콜백 메서드를 사용하여 서로 소통해요.\n\n<div class=\"content-ad\"></div>\n\n웹 워커의 일반적인 예시는 다음과 같습니다:\n\n- 주식 가격, 실시간 활성 사용자 등의 실시간 데이터를 표시하는 대시보드 페이지\n- 서버에서 큰 파일을 가져오는 작업\n- 자동 저장 기능\n\n## 웹 워커 생성 구문\n\n```js\n웹 워커 생성을 위해 사용됩니다\nworker = new Worker(\"webWorker.js\");\n```\n\n<div class=\"content-ad\"></div>\n\n## 웹 워커 종료하는 구문\n\n```js\n// 웹 워커를 종료하는 데 사용됩니다.\nworker.terminate();\n```\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>웹 워커 예제</title>\n</head>\n<body>\n  <h1>웹 워커 예제</h1>\n  <button onclick=\"startWorker()\">워커 시작</button>\n  <p id=\"result\"></p>\n\n  <script>\n    function startWorker() {\n      const worker = new Worker('worker.js');\n      \n      worker.onmessage = function(event) {\n        document.getElementById('result').textContent = event.data;\n      };\n    }\n  </script>\n</body>\n</html>\n```\n\n```js\nfunction doHeavyTask() {\n  // 무거운 CPU 작업을 시뮬레이션합니다.\n  let result = 0;\n  for (let i = 0; i < 1000000000; i++) {\n    result += i;\n  }\n  return result;\n}\n\n// 메인 스레드로부터 메시지를 수신합니다.\nonmessage = function(event) {\n  const heavyResult = doHeavyTask();\n  postMessage(heavyResult); // 결과를 메인 스레드로 다시 보냅니다.\n};\n```\n\n<div class=\"content-ad\"></div>\n\n## React 예제, WebWorker Websocket 예제\n\n```js\nconst Homepage = () => {\n  const [worker, setWorker] = useState(null);\n  const [res, setRes] = useState([]);\n  const [log, setLog] = useState([]);\n  const [buttonState, setButtonState] = useState(false);\n\n  const hanldeStartConnection = () => {\n    // 워커에 메시지 보내기 [postMessage]\n    worker.postMessage({\n      connectionStatus: \"init\",\n    });\n  };\n\n  const handleStopConnection = () => {\n    worker.postMessage({\n      connectionStatus: \"stop\",\n    });\n  };\n \n //UseEffect1\n  useEffect(() => {\n    const myWorker = new Worker(\n      new URL(\"../workers/main.worker.js\", import.meta.url)\n    ); //NEW SYNTAX\n    setWorker(myWorker);\n\n    return () => {\n      myWorker.terminate();\n    };\n  }, []);\n\n //UseEffect2\n  useEffect(() => {\n    if (worker) {\n      worker.onmessage = function (e) {\n        if (typeof e.data === \"string\") {\n          if(e.data.includes(\"[\")){\n            setLog((preLogs) => [...preLogs, e.data]);\n          } else {\n            setRes((prevRes) => [...prevRes, { stockPrice: e.data }]);\n          }\n        }\n\n        if (typeof e.data === \"object\") {\n          setButtonState(e.data.disableStartButton);\n        }\n      };\n    }\n  }, [worker]);\n\n  return (\n    <>\n      <div className=\"stats\">\n        <div className=\"control-panel\">\n          <h3>WebWorker Websocket 예제</h3>\n          <button\n            id=\"start-connection\"\n            onClick={hanldeStartConnection}\n            disabled={!worker || buttonState}\n          >\n            연결 시작\n          </button>\n          &nbsp;\n          <button\n            id=\"stop-connection\"\n            onClick={handleStopConnection}\n            disabled={!buttonState}\n          >\n            연결 중지\n          </button>\n        </div>\n        <LineChartComponent data={res} />\n      </div>\n      <Logger logs={log}/>\n    </>\n  );\n};\n```\n\n# 웹 워커의 종류\n\n웹 워커는 웹 페이지의 메인 스레드와 별도로 백그라운드에서 스크립트를 실행하는 방법을 제공합니다. 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있도록 합니다. 여기에는 두 가지 주요 웹 워커의 종류가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n## 1. 전용 워커:\n\n- 전용 워커는 생성한 스크립트에 의해서만 접근할 수 있습니다.\n- 메인 스레드와 격리된 자체 스레드에서 실행됩니다.\n- 웹 페이지의 반응성에 영향을 미치지 않으면서 무거운 계산이나 시간이 오래 걸리는 작업을 처리해야 하는 상황에 유용합니다.\n- 전용 워커는 일반적으로 단일 스크립트 내에서 사용됩니다.\n\n## 2. 공유 워커:\n\n- 공유 워커는 동일한 도메인에 속하는 여러 창, 아이프레임 또는 다른 컨텍스트에서 실행 중인 여러 스크립트에서 접근할 수 있습니다.\n- 데이터를 공유하거나 응용 프로그램의 다른 부분 간의 작업을 조정해야 하는 상황에 공유 워커가 설계되었습니다.\n- 서로 다른 탭이나 프레임 간의 통신과 협업을 제공합니다.\n- 공유 워커는 더 다양하며 여러 스크립트가 동시에 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 인터뷰 질문:\n\n## 웹 워커(Web Worker)란 무엇인가요?\n\n- 웹 워커(Web Worker)는 웹 애플리케이션의 주 실행 스레드와 별도의 백그라운드 스레드에서 스크립트를 실행할 수 있는 JavaScript 기능입니다.\n\n## 웹 워커(Web Worker)가 해결하는 문제는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커는 웹 애플리케이션의 응답성을 향상시키기 위해 주 스레드에서 작업을 오프로드하는 데 도움이 됩니다. 그들은 UI를 차단하지 않고 동시에 실행을 가능하게 합니다.\n\n## 웹 워커를 어떻게 생성하나요?\n\n- 웹 워커는 주 자바스크립트 코드에서 Worker 개체를 인스턴스화하고 워커 스크립트의 URL을 인수로 제공하여 생성합니다.\n\n## 웹 워커와 주 스레드 간의 통신 메커니즘은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커는 postMessage() 메서드를 사용하여 주 스레드와 통신하고 onmessage 이벤트 핸들러를 통해 메시지를 수신합니다.\n\n### 웹 워커와 주 스레드 간에 전송할 수 있는 데이터 유형은 무엇인가요?\n\n- 전송할 수 있는 데이터 유형에는 JSON 객체, ArrayBuffer, ArrayBufferView, 파일/블롭 객체 및 기타 구조화된 복제 가능한 객체가 포함됩니다.\n\n### 웹 워커의 제한사항은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커는 DOM, window, document와 같은 특정 API에 직접 액세스할 수 없으며 동기 XHR 요청을 수행할 수 없습니다. 또한, 동일 출처 정책으로 인해 다른 출처의 리소스에 액세스하는 데 제한이 있습니다.\n\n**웹 워커를 종료하는 방법은 무엇인가요?**\n\n- 메인 스레드에서 Worker 객체의 terminate() 메서드를 호출하여 웹 워커를 종료할 수 있습니다.\n\n**웹 워커에는 어떤 종류가 있나요?**\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커에는 Dedicated Workers와 Shared Workers 두 가지 유형이 있어요. Dedicated Workers는 하나의 스크립트에 특화되어 있지만, Shared Workers는 여러 스크립트에서 공유할 수 있어요.\n\n## 웹 워커의 일반적인 사용 사례는 무엇인가요?\n\n- 웹 워커는 이미지 처리, 오디오/비디오 처리, 데이터 구문 분석 및 암호화/해독과 같은 CPU 집약적 작업에 주로 사용돼요. 또한 서버에서 데이터를 가져오거나 WebSocket을 통해 수신한 데이터를 처리하는 백그라운드 작업에도 사용할 수 있어요.\n\n## 웹 워커에서 오류를 처리하는 방법은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커 내에서 발생하는 오류는 onerror 이벤트 핸들러를 사용하여 캡처할 수 있습니다. 또한 postMessage()를 사용하여 메시지를 메인 스레드로 보내고 메인 스레드에서 처리할 수 있습니다.\n\n## 참고 문서:\n\n- https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\n- https://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/","ogImage":{"url":"/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>주제 안내:</p>\n<h1>웹 워커:</h1>\n<p>웹 워커는 브라우저 기능의 일부입니다. 현재 페이지의 백그라운드에서 생성될 수 있는 실제 OS 스레드로, 복잡하고 자원 집약적인 작업을 수행할 수 있습니다.</p>\n<p>서버에서 대량의 데이터를 가져와야 하거나 UI에 복잡한 렌더링이 필요한 경우를 상상해보세요. 이를 직접 웹페이지에서 처리한다면 페이지가 더 부드럽지 않을 수 있고 UI에 영향을 줄 수 있습니다.</p>\n<p>위 웹 워커를 사용하여 이 문제를 완화할 수 있어요. 웹 워커는 웹 워커라 불리는 쓰레드를 만들고, 그 웹 워커가 복잡한 작업을 처리하도록 할 수 있어요.</p>\n<p>웹 워커와 간단하게 소통할 수 있으며, 이를 통해 워커와 UI 간에 데이터를 주고받을 수 있어요.</p>\n<p>아래는 웹 워커의 주요 기능 몇 가지에요:</p>\n<ul>\n<li>웹 워커는 쓰레드 기반의 JavaScript입니다.</li>\n<li>웹 워커는 더 많은 공간과 CPU 시간을 요구해요.</li>\n<li>웹 워커는 웹사이트의 속도를 향상시켜 줘요.</li>\n<li>웹 워커는 클라이언트 측에서 코드를 실행해요 (서버 측이 아니에요).</li>\n<li>웹 워커 쓰레드는 postMessage() 콜백 메서드를 사용하여 서로 소통해요.</li>\n</ul>\n<p>웹 워커의 일반적인 예시는 다음과 같습니다:</p>\n<ul>\n<li>주식 가격, 실시간 활성 사용자 등의 실시간 데이터를 표시하는 대시보드 페이지</li>\n<li>서버에서 큰 파일을 가져오는 작업</li>\n<li>자동 저장 기능</li>\n</ul>\n<h2>웹 워커 생성 구문</h2>\n<pre><code class=\"hljs language-js\">웹 워커 생성을 위해 사용됩니다\nworker = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Worker</span>(<span class=\"hljs-string\">\"webWorker.js\"</span>);\n</code></pre>\n<h2>웹 워커 종료하는 구문</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 웹 워커를 종료하는 데 사용됩니다.</span>\nworker.<span class=\"hljs-title function_\">terminate</span>();\n</code></pre>\n<pre><code class=\"hljs language-js\">&#x3C;!<span class=\"hljs-variable constant_\">DOCTYPE</span> html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &#x3C;title>웹 워커 예제&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  &#x3C;h1>웹 워커 예제&#x3C;/h1>\n  &#x3C;button onclick=\"startWorker()\">워커 시작&#x3C;/button>\n  &#x3C;p id=\"result\">&#x3C;/p>\n\n  &#x3C;script>\n    function startWorker() {\n      const worker = new Worker('worker.js');\n      \n      worker.onmessage = function(event) {\n        document.getElementById('result').textContent = event.data;\n      };\n    }\n  &#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doHeavyTask</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// 무거운 CPU 작업을 시뮬레이션합니다.</span>\n  <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">1000000000</span>; i++) {\n    result += i;\n  }\n  <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">// 메인 스레드로부터 메시지를 수신합니다.</span>\nonmessage = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) {\n  <span class=\"hljs-keyword\">const</span> heavyResult = <span class=\"hljs-title function_\">doHeavyTask</span>();\n  <span class=\"hljs-title function_\">postMessage</span>(heavyResult); <span class=\"hljs-comment\">// 결과를 메인 스레드로 다시 보냅니다.</span>\n};\n</code></pre>\n<h2>React 예제, WebWorker Websocket 예제</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Homepage</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> [worker, setWorker] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">null</span>);\n  <span class=\"hljs-keyword\">const</span> [res, setRes] = <span class=\"hljs-title function_\">useState</span>([]);\n  <span class=\"hljs-keyword\">const</span> [log, setLog] = <span class=\"hljs-title function_\">useState</span>([]);\n  <span class=\"hljs-keyword\">const</span> [buttonState, setButtonState] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">hanldeStartConnection</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-comment\">// 워커에 메시지 보내기 [postMessage]</span>\n    worker.<span class=\"hljs-title function_\">postMessage</span>({\n      <span class=\"hljs-attr\">connectionStatus</span>: <span class=\"hljs-string\">\"init\"</span>,\n    });\n  };\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleStopConnection</span> = (<span class=\"hljs-params\"></span>) => {\n    worker.<span class=\"hljs-title function_\">postMessage</span>({\n      <span class=\"hljs-attr\">connectionStatus</span>: <span class=\"hljs-string\">\"stop\"</span>,\n    });\n  };\n \n <span class=\"hljs-comment\">//UseEffect1</span>\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">const</span> myWorker = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Worker</span>(\n      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-string\">\"../workers/main.worker.js\"</span>, <span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>)\n    ); <span class=\"hljs-comment\">//NEW SYNTAX</span>\n    <span class=\"hljs-title function_\">setWorker</span>(myWorker);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n      myWorker.<span class=\"hljs-title function_\">terminate</span>();\n    };\n  }, []);\n\n <span class=\"hljs-comment\">//UseEffect2</span>\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">if</span> (worker) {\n      worker.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> e.<span class=\"hljs-property\">data</span> === <span class=\"hljs-string\">\"string\"</span>) {\n          <span class=\"hljs-keyword\">if</span>(e.<span class=\"hljs-property\">data</span>.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">\"[\"</span>)){\n            <span class=\"hljs-title function_\">setLog</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">preLogs</span>) =></span> [...preLogs, e.<span class=\"hljs-property\">data</span>]);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-title function_\">setRes</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevRes</span>) =></span> [...prevRes, { <span class=\"hljs-attr\">stockPrice</span>: e.<span class=\"hljs-property\">data</span> }]);\n          }\n        }\n\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> e.<span class=\"hljs-property\">data</span> === <span class=\"hljs-string\">\"object\"</span>) {\n          <span class=\"hljs-title function_\">setButtonState</span>(e.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">disableStartButton</span>);\n        }\n      };\n    }\n  }, [worker]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"stats\"</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"control-panel\"</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h3</span>></span>WebWorker Websocket 예제<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h3</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n            <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"start-connection\"</span>\n            <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{hanldeStartConnection}</span>\n            <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{!worker</span> || <span class=\"hljs-attr\">buttonState</span>}\n          ></span>\n            연결 시작\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n          <span class=\"hljs-symbol\">&#x26;nbsp;</span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n            <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"stop-connection\"</span>\n            <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleStopConnection}</span>\n            <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{!buttonState}</span>\n          ></span>\n            연결 중지\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">LineChartComponent</span> <span class=\"hljs-attr\">data</span>=<span class=\"hljs-string\">{res}</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Logger</span> <span class=\"hljs-attr\">logs</span>=<span class=\"hljs-string\">{log}/</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n};\n</code></pre>\n<h1>웹 워커의 종류</h1>\n<p>웹 워커는 웹 페이지의 메인 스레드와 별도로 백그라운드에서 스크립트를 실행하는 방법을 제공합니다. 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있도록 합니다. 여기에는 두 가지 주요 웹 워커의 종류가 있습니다:</p>\n<h2>1. 전용 워커:</h2>\n<ul>\n<li>전용 워커는 생성한 스크립트에 의해서만 접근할 수 있습니다.</li>\n<li>메인 스레드와 격리된 자체 스레드에서 실행됩니다.</li>\n<li>웹 페이지의 반응성에 영향을 미치지 않으면서 무거운 계산이나 시간이 오래 걸리는 작업을 처리해야 하는 상황에 유용합니다.</li>\n<li>전용 워커는 일반적으로 단일 스크립트 내에서 사용됩니다.</li>\n</ul>\n<h2>2. 공유 워커:</h2>\n<ul>\n<li>공유 워커는 동일한 도메인에 속하는 여러 창, 아이프레임 또는 다른 컨텍스트에서 실행 중인 여러 스크립트에서 접근할 수 있습니다.</li>\n<li>데이터를 공유하거나 응용 프로그램의 다른 부분 간의 작업을 조정해야 하는 상황에 공유 워커가 설계되었습니다.</li>\n<li>서로 다른 탭이나 프레임 간의 통신과 협업을 제공합니다.</li>\n<li>공유 워커는 더 다양하며 여러 스크립트가 동시에 활용할 수 있습니다.</li>\n</ul>\n<h1>인터뷰 질문:</h1>\n<h2>웹 워커(Web Worker)란 무엇인가요?</h2>\n<ul>\n<li>웹 워커(Web Worker)는 웹 애플리케이션의 주 실행 스레드와 별도의 백그라운드 스레드에서 스크립트를 실행할 수 있는 JavaScript 기능입니다.</li>\n</ul>\n<h2>웹 워커(Web Worker)가 해결하는 문제는 무엇인가요?</h2>\n<ul>\n<li>웹 워커는 웹 애플리케이션의 응답성을 향상시키기 위해 주 스레드에서 작업을 오프로드하는 데 도움이 됩니다. 그들은 UI를 차단하지 않고 동시에 실행을 가능하게 합니다.</li>\n</ul>\n<h2>웹 워커를 어떻게 생성하나요?</h2>\n<ul>\n<li>웹 워커는 주 자바스크립트 코드에서 Worker 개체를 인스턴스화하고 워커 스크립트의 URL을 인수로 제공하여 생성합니다.</li>\n</ul>\n<h2>웹 워커와 주 스레드 간의 통신 메커니즘은 무엇인가요?</h2>\n<ul>\n<li>웹 워커는 postMessage() 메서드를 사용하여 주 스레드와 통신하고 onmessage 이벤트 핸들러를 통해 메시지를 수신합니다.</li>\n</ul>\n<h3>웹 워커와 주 스레드 간에 전송할 수 있는 데이터 유형은 무엇인가요?</h3>\n<ul>\n<li>전송할 수 있는 데이터 유형에는 JSON 객체, ArrayBuffer, ArrayBufferView, 파일/블롭 객체 및 기타 구조화된 복제 가능한 객체가 포함됩니다.</li>\n</ul>\n<h3>웹 워커의 제한사항은 무엇인가요?</h3>\n<ul>\n<li>웹 워커는 DOM, window, document와 같은 특정 API에 직접 액세스할 수 없으며 동기 XHR 요청을 수행할 수 없습니다. 또한, 동일 출처 정책으로 인해 다른 출처의 리소스에 액세스하는 데 제한이 있습니다.</li>\n</ul>\n<p><strong>웹 워커를 종료하는 방법은 무엇인가요?</strong></p>\n<ul>\n<li>메인 스레드에서 Worker 객체의 terminate() 메서드를 호출하여 웹 워커를 종료할 수 있습니다.</li>\n</ul>\n<p><strong>웹 워커에는 어떤 종류가 있나요?</strong></p>\n<ul>\n<li>웹 워커에는 Dedicated Workers와 Shared Workers 두 가지 유형이 있어요. Dedicated Workers는 하나의 스크립트에 특화되어 있지만, Shared Workers는 여러 스크립트에서 공유할 수 있어요.</li>\n</ul>\n<h2>웹 워커의 일반적인 사용 사례는 무엇인가요?</h2>\n<ul>\n<li>웹 워커는 이미지 처리, 오디오/비디오 처리, 데이터 구문 분석 및 암호화/해독과 같은 CPU 집약적 작업에 주로 사용돼요. 또한 서버에서 데이터를 가져오거나 WebSocket을 통해 수신한 데이터를 처리하는 백그라운드 작업에도 사용할 수 있어요.</li>\n</ul>\n<h2>웹 워커에서 오류를 처리하는 방법은 무엇인가요?</h2>\n<ul>\n<li>웹 워커 내에서 발생하는 오류는 onerror 이벤트 핸들러를 사용하여 캡처할 수 있습니다. 또한 postMessage()를 사용하여 메시지를 메인 스레드로 보내고 메인 스레드에서 처리할 수 있습니다.</li>\n</ul>\n<h2>참고 문서:</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\" rel=\"nofollow\" target=\"_blank\">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers</a></li>\n<li><a href=\"https://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/\" rel=\"nofollow\" target=\"_blank\">https://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/</a></li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}