{"pageProps":{"posts":[{"title":"Angular v17이 해결한 이전에는 해결 불가능했던 문제","description":"","date":"2024-06-22 05:02","slug":"2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem","content":"\n## 도커 빌드에 간단한 유니코드 문자가 문제를 일으킨 방법\n\n# 소개\n\n소프트웨어 엔지니어로서, 소프트웨어 문제가 발생할 때, 그 원인을 파악하는 것을 좋아합니다. 따라서, 우리가 실행 중인 시스템을 소유하거나 제어하지 못하여 충분히 파고들기 어렵다면, 해결할 수 없는 문제나 설명할 수 없는 문제는 없다고 말할 수 있습니다.\n\n이 기사에서는 간단한 유니코드 문자가 문제를 일으킨 방법을 분석하겠습니다. 이 문제는 해결하기 위해 많은 시간을 투자했지만, 해결할 수 없었던 것처럼 보였습니다. 걱정하지 마세요, 여전히 해결책을 찾아가겠지만, 다른 문제를 일으킬 수 있다는 주의를 요청드립니다.\n\n<div class=\"content-ad\"></div>\n\n문제에 직면하기 전에, Angular, Azure Container Registry 및 Azure Pipelines Windows 에이전트가 어떻게 연관되는지 이해해야 합니다.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png)\n\n## Azure 파이프라인 에이전트\n\nAzure 파이프라인은 마이크로소프트에서 제공하는 솔루션이며, 코드 프로젝트를 자동으로 빌드하고 테스트합니다. 지속적 통합 및 지속적 전달 (CI/CD) 관행을 결합하여 응용 프로그램을 어떠한 대상에도 빌드, 테스트 및 릴리스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nAzure 파이프라인 에이전트는 한 번에 하나의 작업을 실행하는 에이전트 소프트웨어가 설치된 컴퓨팅 인프라(컴퓨터)입니다. CI/CD 작업은 이러한 작업 내에서 수행됩니다.\n\nAzure 파이프라인은 두 가지 주요 유형의 에이전트를 제공합니다:\n\n- Microsoft 호스팅 에이전트(마이크로소프트에 의해 클라우드에서 호스팅되고 완전히 관리됨)\n- 자체 호스팅 에이전트(온프레미스 인프라에서 호스팅됨)\n\nAzure 파이프라인 에이전트는 여러 유형의 기계에 설치할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- macOS 에이전트\n- Linux 에이전트\n- Windows 에이전트\n- Docker 에이전트\n\n이게 왜 중요한지 조금 뒤에 알아보겠습니다.\n\n## az acr build 명령어란?\n\n익숙한 docker build 형식을 사용하여 Azure CLI의 az acr build 명령은 프로젝트를 압축하고 임시 blob 저장소로 업로드한 다음 Microsoft 호스팅 에이전트 중 하나가 이를 가져와 docker build를 수행합니다.\n\n<div class=\"content-ad\"></div>\n\n빌드 과정 중에 빌드 에이전트는 로그를 우리에게 스트리밍합니다 (나중에 이것이 왜 중요한지 알게됩니다). 작업이 완료되면 빌드된 이미지가 Microsoft Azure 클라우드에 호스팅된 관리형 Docker 레지스트리 서비스인 Azure Container Registry에 푸시됩니다.\n\n## Angular에 대하여\n\nAngular는 인기있는 오픈 소스 프론트엔드 웹 애플리케이션 프레임워크로, 동적인 단일 페이지 웹 애플리케이션(SPA) 및 점진적 웹 애플리케이션(PWA)을 구축하는 데 사용됩니다.\n\n# Angular이 책임을 집니까?\n\n<div class=\"content-ad\"></div>\n\n저희 Angular 애플리케이션의 Dockerfile을 살펴봅시다.\n\nAngular 프로젝트는 ng build 명령어를 사용하여 빌드됩니다. 이 명령어는 npm run build명령어에 의해 백그라운드에서 호출됩니다.\n\n버전 17 이전의 모든 Angular 버전에서는 완료 후에 npm run build명령에 대한 출력으로 다음 텍스트가 표시됩니다:\n\n![Angular output](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_1.png)\n\n<div class=\"content-ad\"></div>\n\n녹색 체크 표시는 \"✔\"가 유니코드 문자 (코드 U+2714)인 것이 문제를 만드는 원인이 됩니다.\n\n# Azure DevOps 에이전트가 잘못되었다\n\n다음과 같은 YAML 파이프라인 정의를 사용하여 Azure 파이프라인에서 az acr 빌드 명령을 Windows 에이전트에서 실행해 봅시다 (Windows OS가 중요한 이유를 조금 후에 알게 될 것입니다):\n\nPython을 사용하여 Windows OS 기계에서 다음 명령을 실행함으로써 동일한 오류를 재현할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n(파이썬 -c \"print('\\u2714')\") >> output.txt\n```\n\n# 발생하는 위치와 이유\n\n만약 자체 호스팅된 에이전트를 사용한다면, 파이프라인 로그 중에 하나도 에이전트의 컴퓨터에 저장되지 않음을 알 수 있습니다. 대신, 저희가 사용하는 파이프라인 에이전트는 모든 로그를 Azure DevOps 서버로 보내어 저장합니다.\n\n문제는 '체크 마크'로 알려진 '\\u2714' 문자가 파이프라인 에이전트에서 디코딩을 시도할 때 발생합니다. 이는 colorama/ansitowin32.py 스크립트 파일 내에서 다음과 같은 에러 로그 부분에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nD:\\a\\_work\\1\\s\\build_scripts\\windows\\artifacts\\cli\\Lib\\site-packages\\colorama/ansitowin32.py\n```\n\n플로우 다이어그램을 살펴보고 모든 구성 요소가 서로 어떻게 대화하는지 살펴봅시다.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_2.png)\n\n기술적으로, 2단계와 3단계의 경우 우리의 압축된 프로젝트는 Azure Blog 스토리지에 업로드되며, ACR 빌드 에이전트에 의해 가져옵니다. 마찬가지로 ACR 빌드 에이전트는 Azure Blog 스토리지에 로그를 저장한 후 az acr 명령어의 일부로 스트리밍됩니다.\n\n<div class=\"content-ad\"></div>\n\nAzure 파이프라인 빌드 에이전트에서 오류가 발생했습니다. 단계 3과 4 사이에서 발생한 오르로, Azure 블로그 스토리지에서 로그를 스트리밍하고 stdout로 출력하는 과정 중에 발생했습니다.\n\nAzure CLI 서버는 터미널에 색상이 있는 텍스트를 생성하기 위해 colorama(파이썬 패키지)를 사용합니다. 이를 위해 stdout을 래핑하여 찾은 ANSI 시퀀스를 제거하고(결과물로 나타나는 의미없는 문자열을) 해당 시퀀스를 수정하는 적절한 Win32 API 호출로 변환합니다.\n\n## Azure CLI 소스 코드 심층 분석\n\nAzure CLI에서 발생한 오류는 command_modules/acr/\\_stream_utils.py 파일의 143번째 줄에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport colorama\n.\n.\ncolorama.init()\n.\n.\nprint(flush.decode('utf-8', errors='ignore'))\n```\n\n이 줄은 단순히 UTF-8 디코딩된 바이트 스트링을 출력합니다 (블롭 스토리지에서 검색된 로그 데이터). 그러나 colorama 패키지가 가져와서 초기화되었으므로 다음 print 명령은 텍스트에 색상 또는 스타일을 추가하는 colorama의 기능을 활용할 것입니다.\n\nColorama는 Win32 API 호출을 사용하여 터미널 상태를 수정하며, Win32 API는 기본적으로 Unicode-특정 문자를 지원하지 않는 ANSI 코드 페이지를 사용합니다. 이는 Unicode 문자열을 표시하려고 시도하는 동안 Unicode 코드 페이지를 지원하지 않는 API를 사용하려는 것이 우리 문제의 근본 원인입니다.\n\n이제 우리는 백그라운드에서 무슨 일이 일어나는지 이해하기 시작합니다. 그러나 실제 솔루션을 살펴보기 전에 다른 가능한 어정쩡한 솔루션을 확인해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 로그 없이도 문제 없을까요?\n\n로그를 비활성화하면 문제가 해결될 것으로 생각할 수 있습니다. 비록 그게 맞긴 하지만, 더 나은 방법이 있습니다. 로그를 비활성화하는 방법은 두 가지가 있습니다:\n\n- -- no-logs 인수를 추가하여 az acr build 명령에서 로그 스트리밍을 완전히 비활성화합니다. 이것은 빌드 로그를 완전히 잃어버리기 때문에 이 방법은 최악의 해결책입니다.\n\n```js\naz acr build --no-logs --registry $(Registry) --image \"$(image):$(tag)\" .\n```\n\n<div class=\"content-ad\"></div>\n\n- `ng build` 명령어의 진행 로그를 `--progress=false` 인수로 비활성화하세요. 진행과 관련된 로그의 일부를 여전히 잃게 되어 이는 이상적인 해결책은 아닙니다.\n\n```js\nRUN npm run build -- --progress=false\n```\n\n# 진짜 해결책\n\n해결책을 살펴보기 전에, 인코딩과 문자 집합(코드 페이지)이 어떻게 작동하는지에 대해 이해해야 합니다. Unicode와 문자 집합에 관해 꼭 알아야 할 절대 최소한의 정보 - 모든 소프트웨어 개발자가 반드시 알아야 할 것 (변명 금지!) -이라는 글을 읽는 것을 강력히 권장합니다.\n\n<div class=\"content-ad\"></div>\n\n- ACP은 ANSI (American National Standards Institute) 코드 페이지를 나타내며, 미국 및 서유럽 지역의 기본값은 Windows-1252 문자 세트로 설정됩니다. 이는 레거시 GUI 애플리케이션에서 사용됩니다.\n- OEMCP는 제조업체 코드 페이지를 의미하며, 기본값은 437 (원래 IBM PC의 문자 세트)로 설정됩니다. 이는 레거시 콘솔 애플리케이션에서 사용됩니다.\n\nPowerShell을 통해 다음 레지스트리 경로를 확인하여 Windows 레지스트리에서 현재 정의된 ANSI 코드 페이지와 OEM 코드 페이지를 확인할 수 있습니다:\n\n```shell\nGet-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage `\n  | Select-Object OEMCP, ACP\n```\n\n<img src=\"/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_3.png\" />\n\n<div class=\"content-ad\"></div>\n\n지역 설정에 따라이 값은 코드 페이지 식별자 목록에서 어느 것이든 취할 수 있습니다. 가장 일반적인 것은 다음과 같습니다:\n\n- 874-태국어\n- 932-ShiftJIS — 일본어\n- 936-GBK — 중국어 (중국 본토, 싱가포르)\n- 949-한국 통합 한글\n- 950-Big5 Extended — 중국어 (대만, 홍콩)\n- 1250-중앙 유럽\n- 1251-키릴 자모\n- 1252-미국 (ANSI)\n- 1253-그리스어\n- 1254-터키어\n- 1255-히브리어\n- 1256-아랍어\n- 1257-발트 어\n\ncmd.exe 및 powershell.exe에서 텍스트는 현재 지정된 ANSI 코드 페이지를 사용하여 작성하고 읽습니다.\n\n유니코드 특수 문자 인코딩을 지원하기 위해 Windows 레지스트리 항목을 변경하여 Windows가 UTF-8 인코딩 (코드 페이지 65001)을 사용하도록 설정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```\nNew-ItemProperty -LiteralPath 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage' -Name 'ACP' -Value '65001' -PropertyType String -Force;\n```\n\n전 세계 언어 지원을 위해 유니코드 UTF-8 사용 베타 기능을 활성화함으로써 비슷한 결과를 얻을 수 있습니다.\n\n- intl.cpl을 실행합니다.\n- \"관리자\" 탭을 엽니다.\n- \"시스템 로캘 변경\"을 엽니다.\n- \"베타: 전 세계 언어 지원을 위한 유니코드 UTF-8 사용\"을 활성화합니다.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 이 솔루션으로 다른 문제가 발생하는 방법\n\n그러나 이것은 오래된 Windows 버전에서 부팅 문제를 일으키며, PowerShell을 작은 글꼴 크기로 고정시키고 텍스트가 올바르게 표시되지 않는 등의 문제를 일으킵니다. 따라서 이 문제를 해결함으로써 다른 문제가 발생할 수 있습니다.\n\n그래서 우리는 여기서 덜 나쁜 것을 선택하는 것 뿐입니다.\n\n## Linux 에이전트\n\n<div class=\"content-ad\"></div>\n\n이제 질문이 생깁니다. Linux 기반 Azure DevOps 에이전트에서도 동일한 오류가 발생하는가요? 답은 아니오, 왜냐하면 colorama가 터미널 출력을 변경하기 위해 Win32 API 호출을 하지 않기 때문입니다.\n\n# Angular 버전 17.x가 이 문제를 어떻게 해결했는지\n\n실은 매우 간단합니다. Angular 버전 17부터는 'ng build' 명령어의 빌드 출력에 '✔' (유니코드 문자)는 더 이상 표시되지 않으며, 따라서 Win32 API와의 인코딩 문제를 일으키지 않게 되었습니다. 그게 다에요.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_5.png)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n처음에 해결할 수 없는 것 같은 코딩 문제는 먼저는 좀 짜증이 나겠지만, 이를 해결해내는 것이 우리 소프트웨어 엔지니어들이 하는 일입니다. 우리의 인내와 끈기를 시험하며, 해결되면 귀중한 경험을 안겨주고 배경에서 어떻게 작동하는지에 대한 자세한 통찰력을 제공합니다.\n\n명확한 해결책이 없는 도로 봉쇄물에 부딪힌 것은 좌절스러울 수 있지만, 그러한 도로 봉쇄물이 우리에게 성장과 학습 기회를 제공하는 것을 기억하는 것이 중요합니다. 궁극적으로, 이들은 우리를 다른 소프트웨어 엔지니어들과 깊이 이해차로 만들어 줍니다.\n\n그러니 이것이 지나가고 과거에 겪었던 해결이 어렵다고 여겼던 코딩 문제를 다시 시도해 보는 동기가 되길 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n이 글에서 사용된 모든 소스 코드는 제 GitHub 저장소에 있습니다.\n\n# 쉽게 이해할 수 있는 용어로 🚀\n\nIn Plain English 커뮤니티에 함께 해주셔서 감사합니다! 떠나시기 전에:\n\n- 작성자를 박수로 격려하고 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기\n","ogImage":{"url":"/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png"},"coverImage":"/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png","tag":["Tech"],"readingTime":8},{"title":"애플리케이션 성능을 높이는 Angular Signals, Reactive Context, 그리고 동적 의존성 추적 방법","description":"","date":"2024-06-22 05:00","slug":"2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking","content":"\n\nAngular Signals를 효과적으로 사용하려면 \"반응형 컨텍스트\" 개념과 의존성 추적 방법을 이해하는 것이 중요합니다. 이 글에서는 이 두 가지를 설명하고 관련 버그를 피하는 방법을 보여 드리겠습니다.\n\n## 의존성 추적\n\nAngular Signals를 사용할 때 구독하고 구독 해제에 대해 걱정할 필요가 없습니다. 작동 방식을 이해하려면 몇 가지 용어가 필요합니다:\n\n- 의존 그래프: 노드의 그래프, 각 노드는 ReactiveNode 인터페이스를 구현합니다.\n- 생산자: 값을 포함하고 새 값에 대해 알림을 보내는 노드(반응성을 \"생산\"함).\n- 소비자: 생성된 값들을 읽는 노드(반응성을 \"소비\"함).\n\n<div class=\"content-ad\"></div>\n\n신호는 생산자이며, computed()는 생산자이자 소비자이며, effect()는 소비자이며, 템플릿은 소비자입니다.\n\n자동 의존성 추적이 작동하는 방식: 모든 반응 노드에 대한 전역 변수인 activeConsumer가 있고, computed()가 계산 함수를 실행할 때마다, effect()가 부수 효과 함수를 실행할 때마다, 또는 변경 사항을 확인할 때마다 실행할 때마다, 다음을 수행합니다:\n\n- activeConsumer의 값을 읽어 이전 소비자를 기억합니다.\n- 자신을 activeConsumer로 등록합니다.\n- 함수를 실행하거나 템플릿을 실행합니다 (일부 신호는이 단계에서 읽힐 수 있음).\n- 이전 소비자 (단계 1에서)를 activeConsumer로 등록합니다.\n\n어떤 생산자도 읽힐 때는 activeConsumer의 값을 검색하고이 활성 소비자를 신호에 종속된 소비자 목록에 포함합니다. 신호가 업데이트되면 목록에서 각 소비자로 알림을 전송합니다.\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 단계별로 어떻게 일이 진행되는지 살펴봅시다.\n\n```js\n@Component({\n  template: `\n   Items count: { $items().length }\n   Active items count: { $activeItemsCount() }\n`   \n})\nclass ExampleComponent {\n  protected readonly $items = signal([{id: 1, $isActive: signal(true) }]);\n\n  protected readonly $activeItemsCount = computed(() => {\n    return this.getActiveItems().length;\n  });\n\n  private getActiveItems() {\n    return this.$items().filter(i => i.$isActive());\n  }\n}\n```\n\n- 템플릿은 activeConsumer의 값을 읽고 이를 prevConsumer 변수에 저장합니다. (이 변수는 템플릿 내에서만 사용 가능함);\n- 템플릿은 자신을 activeConsumer로 설정합니다;\n- $items() 신호를 호출하여 값을 가져옵니다;\n- $items 신호는 activeConsumer의 값을 검색합니다;\n- 받은 값이 비어 있지 않으므로 (이는 템플릿에 대한 링크를 포함하고 있음), $items 신호는 이 값(우리 템플릿에 대한 링크)을 소비자 목록에 넣습니다. 이후 $items가 업데이트될 때마다 템플릿에 통지됩니다 — 종속성 그래프에 새 링크가 만들어집니다;\n- $items는 값으로 반환되어 템플릿에 전달됩니다;\n- 템플릿은 $activeItemsCount 신호의 값을 읽습니다. 값을 반환하려면 $activeItemsCount는 계산 함수를 실행해야 합니다(computed 함수에 전달한 함수);\n- 계산 함수를 실행하기 전에 $activeItemsCount는 activeConsumer의 값을 읽고 이를 로컬 변수 prevConsumer에 저장합니다. $activeItemsCount도 소비자이므로 activeConsumer 변수에 자체를 가리키는 링크를 추가합니다;\n- 계산 함수는 getActiveItems() 함수를 호출합니다;\n- 이 함수 내에서는 $items의 값을 읽습니다 — 3에서 6단계를 반복하지만, 템플릿이 이미 $items에 의존하고 있기 때문에, 5단계는 새 소비자를 목록에 추가하지 않습니다;\n- 반환된 값(아이템 배열)을 획득하면 getActiveItems()는이 배열의 각 요소를 읽고 $isActive의 값을 읽습니다;\n- $isActive는 신호입니다. 값으로 반환하기 전에 3에서 6까지 단계를 다시 반복합니다. 4단계에서 $isActive는 activeConsumer의 값을 검색합니다. 이때 activeConsumer에는 $activeItemsCount에 대한 링크가 포함되어 있으므로 5단계에서 $isActive (배열의 각 요소마다)는 $activeItemsCount를 종속 소비자 목록에 추가합니다. $isActive가 업데이트될 때마다 $activeItemsCount에 통지됩니다. $activeItemsCount는 템플릿에 값을 갱신해야 함을 통지하며 계산해야 함을 알립니다. 그 후, 템플릿에서 마침내 (통지 바로 다음이 아니라) $activeItemsCount에게 새로운 값을 물어봅니다. 그리고 7단계부터 14단계가 반복됩니다;\n- getActiveItems()가 값을 반환합니다. $activeItemsCount는이 값을 계산에 사용하고 반환하기 전에 로컬 변수 prevConsumer의 값을 activeConsumer 변수에 넣습니다;\n- $activeItemsCount가 값을 반환합니다;\n- 템플릿은 이전에 저장한 prevConsumer 값을 activeConsumer에 넣습니다.\n\n리스트가 길지만 꼼꼼히 읽어주시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n가장 중요한 것은 여기서 소비자들 (computed(), effect(), templates)가 읽은 신호를 종속성 목록에 추가하는 걱정을 할 필요가 없다는 것입니다. 신호들은 자체적으로 activeConsumer 변수를 사용하여 이 작업을 수행합니다. 이 변수는 모든 반응성 노드에서 접근할 수 있으므로, 어떤 신호가 함수 체인의 어느 정도 깊은 곳에서 읽히든 상관없이 모든 신호는 activeConsumer의 값을 얻고 이를 소비자 목록에 추가할 것입니다.\n\n기억하세요: 템플릿, computed() 또는 effect() (소비자)에서 함수를 호출하고, 그 함수가 다른 함수를 읽고, 다른 함수가 다시 다른 함수를 읽는 경우에... 마침내 어떤 수준에서 함수가 신호를 읽고, 그 신호가 해당 소비자를 목록에 추가하고 업데이트에 대해 알릴 것입니다.\n\n디버깅과 같이 읽는 것은 지루할 수 있으므로, 이 작은 앱으로 당신을 즐겁게 해드리겠습니다:\n\n이 앱에서 다음을 수행해주십시오:\n\n<div class=\"content-ad\"></div>\n\n- 버튼 “2”를 눌러 활성화하고 다시 한 번 클릭하세요. 버튼 위의 “Active items” 텍스트가 변경되는 것을 확인하세요;\n- “Add Item” 버튼을 클릭하세요;\n- 버튼 “4”를 클릭하세요. “Active items” 텍스트가 변경되지 않는 것을 확인하세요;\n- 버튼 “2”를 클릭하세요;\n- 이제 버튼 “4”를 여러 번 클릭하고 “Active items” 텍스트가 예상대로 변경되는 것을 확인하세요.\n\n하지만 왜 그럴까요? 코드를 확인해보겠습니다:\n\n```js\nexport type Item = {\n  id: number;\n  $isActive: WritableSignal<boolean>;\n};\n\n@Component({\n  selector: 'my-app',\n  template: `\n    <div>Active items: { $activeItems() }</div>\n    <div>\n      <span>Click to to toggle:</span>\n      @for(item of items; track item.id) {\n        <button (click)=\"item.$isActive.set(!item.$isActive())\" \n                [class.active]=\"item.$isActive()\">\n          { item.id }\n       </button>\n      }\n    </div>\n    <div>\n      <button (click)=\"addItem()\">Add Item</button>\n    </div>\n  `,\n})\nexport class App {\n  protected readonly items: Item[] = [\n    { id: 1, $isActive: signal(true) },\n    { id: 2, $isActive: signal(false) },\n    { id: 3, $isActive: signal(true) },\n  ];\n\n  protected readonly $activeItems = computed(() => {\n    const ids = [];\n    for (const item of this.items) {\n      if (item.$isActive()) {\n        ids.push(item.id);\n      }\n    }\n    return ids.join(', ');\n  });\n\n  protected addItem() {\n    this.items.push({\n      id: this.items.length + 1,\n      $isActive: signal(false),\n    });\n  }\n}\n```\n\n이제 “Active items” 라인이 정확하게 업데이트되지 않는 이유를 분석해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 템플릿에서 바인딩:\n\n```js\n<div>활성 항목: { $activeItems() }</div>\n```\n\n$activeItems은 computed()에 의해 제공되는 시그널입니다:\n\n```js\nprotected readonly $activeItems = computed(() => {\n  const ids = [];\n  for (const item of this.items) {\n    if (item.$isActive()) {\n      ids.push(item.id);\n    }\n  }\n  return ids.join(', ');\n});\n```\n\n<div class=\"content-ad\"></div>\n\ncomputed() 함수에 전달하는 함수는 읽는 신호 중 하나라도 업데이트될 때마다 다시 실행됩니다. 그 곳에서는 어떤 신호를 읽을까요?\n\n이는 this.items 배열의 각 항목의 $isActive 신호입니다.\n\n그렇다면 왜 단계 2와 3 이후에 $activeItems이 업데이트되지 않았을까요?\n\n계산 함수는 의존하는 신호 중 하나가 업데이트될 때에만 다시 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n\"Add Item\"을 클릭하면 이.items를 수정하고 새 항목 내에 새 신호를 생성합니다. 그러나 이 순간 이전에 computed() 함수가 해당 신호를 읽어본 적이 없기 때문에 의존 목록에 없습니다.\n\n\"Add Item\"을 클릭하기 전과 후에도 $activeItems가 의존하는 신호 목록은 바뀌지 않습니다: this.items의 세 항목에서 나오는 세 $isActive 신호입니다.\n\n\"Add Item\"을 클릭할 때 이러한 신호 중 어느 것도 수정되지 않기 때문에 computed() 함수에 알림이 전달되지 않고 계산 함수가 다시 실행되지 않습니다.\n\n우리는 새 항목을 버튼 목록에서 여러 번 토글할 수 있지만, 처음 세 항목의 신호만 $activeItems에 알림을 보내고 우리가 전송한 함수가 다시 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 우리가 계산 함수를 다시 실행하면, 이.items에서 모든 항목을 다시 읽고 새로운 시그널을 읽게 될 것입니다. 새로운 시그널은 $activeItems 노드의 새로운 종속성이 되며, 그중 하나가 변경될 때마다 알림을 받게 될 것입니다.\n\n이를 위해 기존 종속성 중 하나를 수정해야 합니다: 이것이 step 4에서 \"2\" 버튼을 클릭하는 이유입니다.\n\n이 예시는 computed()와 effect()에 전달하는 함수가 업데이트된 생산자 중 하나가 있을 때에만 다시 실행되는 것을 상기시키기 위해 만들어졌습니다.\n\n이것이 computed()가 어떤 종속성을 가지고 있고 그 중 어떤 것이 다시 계산을 유발해야 하는지 재확인하는 것이 언제나 유용한 이유입니다. 그 중 몇 가지는 유배제용()을 사용해야 할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\ncomputed() 또는 effect()에 전달하는 일부 함수는 신호를 읽을 수 있습니다 (또는 호출된 함수가 신호를 읽을 수 있습니다).\n\n```js\nthis.$petWalkingIsAllowed = computed(() => {\n  return this.$isFreeTime() && this.isItGoodWeatherOutside();\n});\n\nisItGoodWeatherOutside() {\n  return $isSunny() && $isWarm() && !$isStormy();\n}\n```\n\n원하지 않는 다시 계산을 피하기 위해 해당 호출을 untracked()로 감싸야 할지 여부를 이해하기 위해 이러한 논리를 사용할 수 있습니다:\n\n- 만약 우리가 computed()가 새로운 값을 계산하지 말아야 하는 경우, 그 함수(isItGoodWeatherOutside())가 새로운 값을 반환할 때 untracked()로 감싸주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nthis.$petWalkingIsAllowed = computed(() => {\n  return this.$isFreeTime() && untracked(() => this.isItGoodWeatherOutside());\n});\n\nisItGoodWeatherOutside() {\n  return $isSunny() && $isWarm() && !$isStormy();\n}\n```\n\n- 만약 해당 함수로부터의 모든 새 값에 대해 계산을 다시 실행하길 원한다면 untracked()으로 감싸지 마세요.\n\n보시다시피, untracked()은 우리가 추적하고 싶은 종속성을 제어하는 데 도움이 됩니다. 또한 또 다른 중요한 측면을 관리하는 데 도움이 됩니다:\n\n## 반응형 컨텍스트\n\n\n<div class=\"content-ad\"></div>\n\n위의 \"자동 종속성 추적 방법\"에서는 activeConsumer라는 변수에 대해 언급했어요.\n\nactiveConsumer가 null이 아닌 경우, 우리가 읽는 시그널은 activeConsumer를 소비자 목록에 추가하여 나중에 이 목록의 멤버들에게 시그널의 변경 사항에 대한 알림을 보내게 됩니다. 반응 노드가 읽힐 때 activeConsumer가 비어 있는 상태라면, 반응 노드의 종속성 그래프에 새로운 링크가 생성되지 않을 거에요.\n\n다시 말해, activeConsumer가 설정되어 있을 때는 반응적인 컨텍스트 내에서 시그널을 읽고 있는 것이에요.\n\n대부분의 경우에는 반응적인 컨텍스트가 자동으로 처리되며, 의도한 링크와 종속성만이 생성되고 제거될 거예요.\n\n<div class=\"content-ad\"></div>\n\n하지만 때로는 반응적인 컨텍스트를 무의식적으로 노출시키기도 합니다.\n\n다음 앱을 시험해 봅시다:\n\n사용해 보면 다음을 알 수 있을 거에요:\n\n- \"항목 추가\"를 클릭하면 모든 상태가 완전히 재설정됩니다.\n- 상태를 토글하면 무작위로 변경되어 한 가지 버튼 이상에 영향을 줍니다.\n\n<div class=\"content-ad\"></div>\n\n빠르게 버그를 발견하실 수 있나요?\n\n```js\n@Component({\n  template: `\n    <div>Active items: { $activeItems() }</div>\n    <div class=\"flex-row\">\n      <span>Click to to toggle:</span>\n      @for(item of $items(); track item.id) {\n      <button (click)=\"item.$isActive.set(!item.$isActive())\" [class.active]=\"item.$isActive()\" [style.transform]=\"'scale('+item.$scale()+')'\">\n        { item.id }\n      </button>\n      }\n    </div>\n    <div>\n      <button (click)=\"addItem()\">Add Item</button>\n    </div>\n  `,\n})\nexport class App {\n  private readonly $itemsCount = signal(3);\n\n  protected readonly $items: Signal<Item[]> = computed(() => {\n    console.warn('Generating items!');\n   \n    const items: Item[] = [];\n    for (let id = 0; id < this.$itemsCount(); id++) {\n      const $isActive = signal(Math.random() > 0.5);\n      const $scale = signal($isActive() ? 1.2 : 1);\n      items.push({ id, $isActive, $scale });\n    }\n    return items;\n  });\n\n  protected readonly $activeItems = computed(() => {\n    const ids = [];\n    for (const item of this.$items()) {\n      if (item.$isActive()) {\n        ids.push(item.id);\n      }\n    }\n    return ids.join(', ');\n  });\n\n  protected addItem() {\n    this.$itemsCount.update(c => c + 1);\n  }\n}\n```\n\n여기서 알 수 있는 것:\n\n- 우리는 $items에서 아이템 목록을 렌더링합니다. 이는 computed()로 구성되어 있습니다.\n- $items는 새로운 아이템 배열을 생성하며, 그 수는 $itemsCount 시그널에 의해 제어됩니다. $itemsCount를 수정할 때마다 아이템이 재생성됩니다.\n- addItem()은 단순히 $itemsCount를 증가시키고, $items의 재계산을 유도합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 \"Add Item\"이 이렇게 작동하는 이유를 알 수 있습니다. 이제 상태 토글이 이상하게 동작하는 이유를 알아보겠습니다.\n\n콘솔을 열면 버튼을 클릭할 때마다 \"Generating items!\" 경고가 기록된다는 것을 알 수 있습니다. 하지만 왜 그럴까요? $itemsCount를 수정하지 않았는데 $items가 다시 계산되는 이유는 무엇일까요?\n\n아마도 이미 주목했을지도 모르지만, $items의 계산 함수가 또 하나의 반응 소스를 읽고 있는 것을 알 수 있습니다: 신호 $isActive:\n\n```js\nconst $scale = signal($isActive() ? 1.2 : 1);\n```\n\n<div class=\"content-ad\"></div>\n\n이 신호 ($isActive)은 반응적인 컨텍스트에서 읽힙니다: activeConsumer에는 $items이 포함되어 있으므로 $isActive은 모든 변경 사항에 대해 $items에 통지합니다. 따라서이 상태를 전환하려고 $isActive을 수정할 때 우리는 $items의 재계산을 발생시킵니다.\n\n이 버그를 수정하는 여러 가지 방법이 있지만, 이 접근 방식은 반응적 컨텍스트의 누출을 방지합니다:\n\n```js\nconst $scale = signal(untracked($isActive) ? 1.2 : 1);\n```\n\nuntracked()가 하는 일은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n```js\n/**\n * https://github.com/angular/angular/blob/75a186e321cb417685b2f13e9961906fc0aed36c/packages/core/src/render3/reactivity/untracked.ts#L15\n *\n * packages/core/src/render3/reactivity/untracked.ts\n *\n **/\nexport function untracked<T>(nonReactiveReadsFn: () => T): T {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n```\n\n- activeConsumer을 null로 설정하고 반환 값을 지역 변수 prevConsumer에 저장합니다.\n- 주어진 함수를 실행합니다.\n- prevConsumer에서 activeConsumer을 복원합니다.\n\n이 함수는 반응적인 컨텍스트를 일시적으로 해제하고 우리 함수를 실행한 후 반응적인 컨텍스트를 복원합니다.\n\n따라서 우리 함수가 실행되는 동안, 시그널이 읽혀지는 경우 activeConsumer에 null을 읽고 이를 소비자 목록에 추가하지 않습니다. 즉, 새로운 종속성이 생성되지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 예에서 콘솔에는 \"힌트\"가 있고, 우리의 코드는 매우 작고 간단합니다. 실제 앱에서는 신호 읽기가 함수 호출 체인 내에 깊이 숨겨져 있고, 코드가 훨씬 더 크고 복잡할 수 있습니다. 이러한 버그는 실제 앱에서 디버깅하기 어려울 수 있으므로 리액티브 컨텍스트를 누출하고 싶지 않을 때는 항상 untracked()을 사용하여 미리 방지하는 것을 권장합니다.\n\n리액티브 컨텍스트를 누락시킬 수 있는 흥미로운 예상치 못한 방법이 있습니다:\n\n- 신호를 읽는 클래스의 인스턴스를 만들기;\n- 신호를 읽는 함수를 호출하는 함수 호출하기;\n- effect() 내에서 컴포넌트 생성하기;\n- observable에 새 값을 발행하기.\n\ncomputed()와 effect()를 사용할 때,\n\n<div class=\"content-ad\"></div>\n\n- 다른 신호를 읽을 때 주의하세요. 다른 함수가 변경될 때마다 전체 함수를 다시 실행하며 다른 함수에 의해 트리거됩니다.\n- 이러한 기능들을 읽고 이해하기 쉽게 만드세요;\n- 함수 소비의 반응 소스를 모두 다시 확인하세요.\n\n자주 있듯이 암시적 의존성 추적은 혜택만 가져오는 것이 아니라 어떤 점에서는 희생을 갖고 올 수도 있습니다. 하지만 숙련된 기술과 주의를 기울여 사용할 때 Angular Signals를 사용하여 멋진 앱을 만들 수 있습니다!\n\n작성된 이 문서의 다듬어짐에 많은 기여를 한 리뷰어분들께 깊은 감사를 표합니다:\n\n- Rainer Hahnekamp\n- Josh Morony","ogImage":{"url":"/assets/img/2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking_0.png"},"coverImage":"/assets/img/2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking_0.png","tag":["Tech"],"readingTime":12},{"title":"Angular v18 출시 최신 기능 알아보기","description":"","date":"2024-06-22 04:58","slug":"2024-06-22-Angularv18isnowavailable","content":"\n\n오늘은 Angular 진화의 다음 단계를 공유하게 되어 흥분됩니다! 지난 세 번의 릴리스 동안 새로운 기능과 개선사항을 많이 소개했습니다. 이번에는 새로운 API 중 많은 부분을 안정 버전으로 승격하고, 개발자의 요청에 맞는 기능을 해결하며, 열망했던 로드맵 프로젝트 중 하나인 zoneless change detection을 실험적으로 출시했습니다.\n\n![Angularv18isnowavailable_0.png](/assets/img/2024-06-22-Angularv18isnowavailable_0.png)\n\n이번 릴리스의 하이라이트는 다음과 같습니다:\n\n- zoneless change detection에 대한 실험적 지원\n- Angular 개발자를 위한 새로운 홈페이지인 Angular.dev\n- Material 3, deferrable views, 내장 제어 흐름이 안정화되었으며 여러 개선사항이 포함되어 있습니다\n- i18n 수분화 지원, 더 나은 디버깅, Angular Material의 수분화 지원, Google 검색과 동일한 라이브러리를 통해 구동되는 이벤트 재생을 통한 서버사이드 렌더링 개선내용\n\n<div class=\"content-ad\"></div>\n\n시각적 개요를 위해 릴리스 이벤트에서 비디오를 확인해보세요:\n\n# 진화하는 변경 감지\n\n과거에는 zone.js라는 라이브러리가 Angular의 변경 감지를 트리거하는 역할을 했습니다. 이 라이브러리는 개발자 경험과 성능 면에서 몇 가지 단점이 있었습니다. 몇 년 동안 zone.js에 의존하지 않고 Angular를 사용하는 방법을 찾고 있었으며, 우리는 zoneless의 첫 실험적 API를 공유할 수 있어 매우 흥분합니다!\n\n오늘부터 Angular에서 실험적인 zoneless 지원을 시도해 볼 수 있습니다! 애플리케이션 부트스트랩에 provideExperimentalZonelessChangeDetection을 추가해 보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideExperimentalZonelessChangeDetection()\n  ]\n});\n```\n\n위와 같은 프로바이더를 추가한 후에는 angular.json 파일에서 폴리필에 있는 zone.js를 제거해주세요.\n\n앞으로 나아가 zoneless는 개발자들에게 많은 가능성을 제공합니다:\n\n- 마이크로 프론트엔드 및 다른 프레임워크와의 상호 운용성을 향상시킴\n- 더 빠른 초기 렌더링 및 실행\n- 더 작은 번들 크기 및 빠른 페이지 로딩\n- 더 가독성이 좋은 스택 트레이스\n- 더 간단한 디버깅\n\n<div class=\"content-ad\"></div>\n\n컴포넌트에서 zoneless를 사용하는 가장 좋은 방법은 signals로 처리하는 것입니다:\n\n```js\n@Component({\n  ...\n  template: `\n    <h1>Hello from { name() }!</h1>\n    <button (click)=\"handleClick()\">Go Zoneless</button>\n  `,\n})\nexport class App {\n  protected name = signal('Angular');\n\n  handleClick() {\n    this.name.set('Zoneless Angular');\n  }\n}\n```\n\n위 예시에서 버튼을 클릭하면 handleClick 메소드가 호출되어 신호 값이 업데이트되고 UI도 갱신됩니다. 이는 zone.js를 사용하는 응용 프로그램과 유사하게 작동하지만 몇 가지 차이점이 있습니다. zone.js를 사용하면 Angular은 응용 프로그램 상태가 변경될 때마다 변경 감지를 수행했습니다. 그러나 zone 없이는 Angular이 신호 업데이트와 같은 적은 트리거에 대해서만 변경 감지를 제한합니다. 이 변경에는 변경을 여러 번 연속으로 확인하는 것을 피하기 위한 코얼리싱을 포함한 새로운 스케줄러도 포함되어 있습니다.\n\n위의 버튼을 클릭하면 Angular이 코얼리싱을 통해 변경 감지를 한 번만 실행합니다. 더 많은 정보는 당사의 문서에서 zoneless를 배우세요.\n\n<div class=\"content-ad\"></div>\n\n# 존리스로 업데이트 중\n\n요즘 Angular는 흥미로운 진화를 거치고 있는데, 존리스는 그 핵심 요소 중 하나입니다. 프레임워크를 발전시키면서 모든 기존 API가 예상대로 작동하고 Angular에 도입하는 새로운 기능과의 호환성이 잘 유지되도록 하고 있습니다.\n\n존리스는 우리의 호환성 접근 방식의 또 다른 예입니다. 게다가, 기존 애플리케이션을 존리스로 이전하는 과정이 가능한 간단해지도록 하고자 했습니다. Angular의 ChangeDetectionStrategy.OnPush 변경 감지 전략과 호환되는 경우, 구성 요소는 존리스와 대부분 호환되어 변환이 매끄럽게 진행될 것입니다!\n\n# 기본값으로 병합하기\n\n<div class=\"content-ad\"></div>\n\nv18부터는 존이 없는 앱과 zone.js를 사용하며 coalescing이 활성화된 앱에 대해 동일한 스케줄러를 사용하고 있습니다. 새로운 zone.js 앱의 변경 감지 주기 수를 줄이기 위해 우리는 기본적으로 zone coalescing을 활성화했습니다.\n\n이 동작은 이전 변경 감지 동작에 의존하는 앱에서 버그를 발생시킬 수 있기 때문에 새로운 애플리케이션에 대해서만 활성화됩니다. Coalescing은 불필요한 변경 감지 주기를 줄이고 일부 애플리케이션의 성능을 크게 향상시킵니다.\n\n기존 프로젝트에 이벤트 coalescing을 적용하려면, bootstrapApplication에서 NgZone 프로바이더를 구성하세요:\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideZoneChangeDetection({ eventCoalescing: true })\n  ]\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 네이티브 await을 사용하여 Zone이 필요 없는 앱\n\nZone.js는 Angular의 변경 감지를 위해 많은 브라우저 호출을 가로챕니다. 그러나 async/await은 zone.js가 monkey patch할 수 없는 API 중 하나이기 때문에 Angular CLI를 통해 promises로 다운레벨해야 합니다. 이것은 모든 최신 브라우저가 지원하는 비동기/대기(async/await)를 promises보다 더 표현력이 있고 JavaScript 런타임에서 최적화되었다는 점에서 최적이 아닙니다.\n\n오늘날, 실험적인 zoneless change detection을 사용하는 앱을 만들면 Angular CLI는 네이티브 async/await을 사용하여 promises로 다운레벨링하지 않습니다. 이것은 디버깅을 개선하고 번들 크기를 줄일 것입니다.\n\n# 컴포넌트들은 Zone을 지원합니다\n\n<div class=\"content-ad\"></div>\n\nAngular CDK와 Angular Material에서 Zoneless 지원을 활성화했습니다. 이로 인해 Zoneless 모델의 일부 문제점을 발견하고 개선할 수 있었습니다.\n\n# Angular 개발자를 위한 새로운 홈\n\n지난 18개월 동안 우리는 angular.dev에서 직관적이고 실용적인 시작하는 과정을 제공하고 깊이 있는 안내서를 개선하기 위해 많은 노력을 기울였습니다. 오늘, 우리는 angular.dev이 Angular의 공식 문서 웹사이트로 지정되었음을 기쁘게 알려드립니다!\n\n새롭고 현대적인 느낌뿐만 아니라 WebContainers를 기반으로 한 대화형 실습 튜토리얼, 예제와 함께 제공되는 대화형 플레이그라운드, Algolia를 통해 구동되는 개선된 검색, 업데이트된 안내서, 간소화된 내비게이션 등이 추가되었습니다!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_1.png\" />\n\nangular.io의 모든 요청이 이제 자동으로 angular.dev로 리디렉션됩니다. 모든 기존 링크가 계속 작동하도록 하기 위해 개발자를 v17.angular.io로 리디렉션합니다.\n\nangular.dev로 가서 확인해보세요!\n\n# Material 3이 이제 안정화되었습니다!\n\n<div class=\"content-ad\"></div>\n\n몇 달 전에 저희는 Material 3에 대한 실험적인 지원을 소개했어요. 개발자들의 피드백을 고려하고 Material 3 컴포넌트를 다듬은 후, 안정 버전으로 업데이트했어요!\n\n이와 함께, material.angular.io도 새로운 Material 3 테마와 문서로 새롭게 업데이트되었어요.\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_2.png\" />\n\n이제 우리의 안내서에서 어떻게 Angular Material 3를 앱에서 사용할 수 있는지 찾아보세요!\n\n<div class=\"content-ad\"></div>\n\n# 개발자 미리보기에서의 Signal API\n\nAngular 버전 17.1과 17.2에서 새로운 signal 입력, signal 기반 쿼리, 그리고 새로운 출력 구문이 발표되었습니다.\n\n시그널 가이드에서 APIs를 어떻게 사용할지 알아보세요. 앞으로 몇 달 동안 여러분의 피드백을 기반으로 구현을 계속 개선하고, 안정 버전으로 승격할 것입니다.\n\n# 지연 로드 뷰가 이제 안정화되었습니다\n\n<div class=\"content-ad\"></div>\n\n지난 6개월 동안, 우리는 deferrable views에 대한 많은 관심을 받았습니다. 이를 통해 개발자들이 앱의 핵심 웹 가치를 쉽게 향상시킬 수 있다는 것을 알게되었습니다. 예를 들어, Bill.com은 @defer를 사용하여 한 앱의 번들 크기를 50% 줄였다고 나누었습니다. 오늘, deferrable views가 이제 안정화되었습니다! 여러분은 여러분의 응용 프로그램과 라이브러리에서 이를 사용할 수 있습니다.\n\n# 내장 제어 흐름이 이제 안정화되었습니다\n\nv17에서 deferrable views와 함께, 성능을 개선한 새로운 내장 제어 흐름을 발표했습니다. 이 새로운 문법이 크게 채택되었고, 커뮤니티 피드백에 대응한 후, 우리는 이 API를 안정화했다는 것을 기쁘게 발표합니다!\n\n미리보기 단계에서는 제어 흐름의 타입 체크를 추가로 개선했고, 더 많은 효율적인 암시적 변수 별칭을 활성화하고, 특정 성능 관련 안티 패턴에 대한 가드레일을 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 서버 측 렌더링 개선사항\n\n1년 전에 우리는 하이드레이션을 소개했고 v17에서 안정 버전으로 출시했습니다. 공개 HTTPArchive 데이터셋을 기반으로 하면, 프리랜더링이나 서버 측 렌더링을 사용하는 Angular v17 앱 중 76%가 이미 하이드레이션을 사용하고 있습니다.\n\n더 많은 사람들이 하이드레이션을 활용할 수 있도록 하는 데 있어 한 가지 큰 걸림돌이 있었습니다 — i18n 지원 부족이었습니다. Chrome Aurora 팀과 협력한 끝에, 우리는 i18n 블록의 하이드레이션을 개발자 미리보기 모드로 제공하는 것을 기쁘게 생겨 v18에서 사용 가능합니다!\n\n# 이벤트 재생\n\n<div class=\"content-ad\"></div>\n\n두 달 가량 전에, 우리는 Angular과 Google의 내부 프레임워크 Wiz를 융합하는 장기 진행 중인 프로젝트를 발표했어요. Angular과 Wiz는 과거에 서로 다른 앱 세그먼트를 제공했었죠 — Wiz는 소비자를 주 타깃으로 한 앱에서 주로 사용되며 성능에 초점을 맞추었고, Angular은 생산성과 개발자 경험에 중점을 둔 것이었어요.\n\n융합 노력의 결과로, Wiz는 Angular Signls를 그들의 렌더링 모델에 깊게 통합시켰어요. 우리는 ng-conf에서 YouTube가 이제 Angular Signls를 사용하고 있다는 사실을 공유했었죠. 비슷하게, Angular은 이제 부분 수분화와 같은 성능 중심의 기능을 더 많이 가져오고 있어요. 조금 후에 더 자세히 소개할게요.\n\n두 경우 모두, 우리는 여러분의 기능 요청 및 다른 요구 사항을 모티브로 두 프레임워크의 중요한 기능을 융합하고 있어요.\n\n![이미지](/assets/img/2024-06-22-Angularv18isnowavailable_3.png)\n\n<div class=\"content-ad\"></div>\n\n오늘은 Google.com에서 실행 중인 핵심 라이브러리 중 하나인 이벤트 디스패치(event dispatch)가 Angular 모노레포에 추가되었다는 좋은 소식을 전해드립니다. 이벤트 디스패치는 이제 하이브리드 렌더링을 사용할 때 이벤트 재생을 담당하며, v18부터 제공됩니다.\n\n대부분의 개발자들은 이벤트 디스패치와 직접 상호 작용하지 않을 것이므로, 왜 이벤트 재생이 유용한지 살펴보겠습니다. 아래에 간단한 전자 상거래 웹사이트의 모형을 찾을 수 있습니다. 매우 느린 네트워크 연결을 시뮬레이션하기 위해 인위적인로딩 지연을 도입했습니다. 페이지가 아직 로딩 중이고 아직 수화되지 않은 상태에서 사용자가 카트에 여러 개의 헤드폰을 추가하려고 한다고 상상해보십시오. 페이지가 아직 수화되지 않았기 때문에 상호작용할 수 없으므로 모든 사용자 이벤트가 손실됩니다. v18에서 이벤트 디스패치를 사용하여 시작하면 Angular가 사용자 이벤트를 기록하기 시작합니다. 애플리케이션이 수화되면 이벤트 디스패치가 그것들을 재생하고 카트에 여섯 개의 항목이 생기게 됩니다.\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_4.png\" />\n\n이벤트 재생 기능은 개발자 미리보기로 v18에서 사용할 수 있습니다. withEventReplay()를 사용하여 기능을 활성화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideClientHydration(withEventReplay())\n  ]\n});\n```\n\n# 디버깅 경험을 개선했습니다\n\nAngular DevTools를 업데이트하여 Angular의 수화 프로세스를 시각화했습니다. 각 구성 요소 옆에는 구성 요소의 수화 상태를 나타내는 아이콘이 있습니다. 페이지에서 Angular가 수화한 구성 요소를 미리 볼 수 있도록 오버레이 모드도 활성화할 수 있습니다. 앱에 수화 오류가 있는 경우 Angular DevTools가 구성 요소 탐색기에 시각화해줍니다.\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_5.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n우리 커뮤니티 기여자 Matthieu Riegler에게 이 기능을 추가해 준 것에 대해 큰 감사를 전합니다!\n\n## CDK 및 Material의 수분 보충 지원 \n\nv17에서 일부 Angular Material 및 CDK 구성 요소가 수분 보충에서 제외되어 다시 렌더링되는 문제가 있었습니다. v18부터 모든 구성 요소 및 기본 구성 요소가 완전한 수분 보충 호환성을 갖추었습니다.\n\n## 우리의 부분적 수분 보충 계획\n\n<div class=\"content-ad\"></div>\n\nng-conf와 Google I/O에서 부분 수분화를 발표했어요. 이 기술은 서버 사이드 렌더링 후 앱을 점진적으로 수분화할 수 있게 해줘요. 앱의 점진적 수분화는 처음에 적은 양의 JavaScript를 로드하고 앱의 성능을 향상시키는데 도움을 줘요.\n\n부분 수분화는 지연 뷰와 동일한 기반 위에 구축돼요. 오늘과 같이 서버에서 @placeholder 블록을 렌더링하는 대신, Angular가 서버에서 @defer 블록의 주요 콘텐츠를 렌더링할 수 있는 모드를 활성화할 수 있게 될 거예요. 클라이언트에서는 Angular가 템플릿에서 지정된 트리거 조건이 충족될 때에만 연기된 블록을 다운로드하고 수분화할 거에요. 예를 들어, 다음은 가상의 API 예시에요:\n\n```js\n@defer (서버에서 렌더링; 뷰포트 진입 시) {\n  <app-calendar/>\n}\n```\n\n위의 블록은 캘린더 컴포넌트를 서버에서 렌더링할 거예요. 클라이언트로 도달하면 Angular가 해당 JavaScript를 다운로드하고, 뷰포트에 들어간 후에만 상호작용 가능한 캘린더를 수분화할 거에요.\n\n<div class=\"content-ad\"></div>\n\n지금까지 부분 수분 유화에 대해 노력하고 있습니다. 이미 상호 작용 트리거와 함께 사용할 수 있는 상태에 있습니다. 우리는 현재 파트너와 함께 작업하여 구성 요소가 속성을 수신하거나 바인딩 값을 변경하는 데이터 트리거의 중요성을 평가하고 있습니다.\n\n대규모의 중요한 성능을 필요로 하는 애플리케이션을 개발하고 있고, 부분 수분 유화의 미래를 형성하는 초기 액세스 프로그램에 참여하고 싶다면 devrel@angular.io로 이메일을 보내주세요.\n\n# Firebase 앱 호스팅으로 앱에 강력한 호스팅\n\n웹 플랫폼의 점점 더 복잡해지면서 응용 프로그램의 호스팅은 성능, 신뢰성, 생산성 및 확장성 측면에서 중요한 역할을 합니다. 하이브리드 렌더링을 사용하는 앱은 서버 측 렌더링, 사전 렌더링 및 클라이언트 측 렌더링을 위한 다른 호스팅 요구 사항이 있습니다. 이 복잡성을 수동으로 관리하는 것은 부담스러울 수 있습니다. Firebase 앱 호스팅은 개발자를 위해 이 모든 것을 투명하게 처리하고 있습니다!\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-Angularv18isnowavailable_6.png\" />\n\n올해 구글 I/O에서 Firebase가 앱 호스팅을 발표했습니다. 앱 호스팅은 동적 Angular 애플리케이션의 개발 및 배포를 간소화하며 기본 프레임워크 지원, GitHub 통합 및 인증, 클라우드 Firestore, Firebase의 Vertex AI와의 통합 등을 제공합니다.\n\nAngular와 함께 Firebase 작업을 하면서 개발자 경험을 보다 원할하게 만들도록 노력해 왔습니다. 오늘 앱 호스팅을 시작하는 것에 관한 속기 보세요!\n\n# 그리고 추가로... \n\n\n<div class=\"content-ad\"></div>\n\n우리가 계속 나아가는 대규모 프로젝트들과 함께, 항상 개발자들의 일반적인 요구를 해결하기 위해 시간을 보내고 있어요. v18의 하이라이트 중 일부는 다음과 같아요:\n\n# ng-content에 대한 폴백 콘텐츠 지정\n\n가장 많은 추천을 받은 문제 중 하나는 ng-content에 대한 기본 콘텐츠를 지정하는 것이었어요. v18에서 그것이 이제 가능해졌어요! 여기에 간단한 예시가 있어요:\n\n```js\n@Component({\n  selector: 'app-profile',\n  template: `\n    <ng-content select=\".greeting\">Hello </ng-content>\n\n    <ng-content>Unknown user</ng-content>\n  `,\n})\nexport class Profile {}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 컴포넌트를 사용할 수 있습니다:\n\n```js\n<app-profile>\n  <span class=\"greeting\">좋은 아침 </span>\n</app-profile>\n```\n\n결과는 다음과 같습니다:\n\n```js\n<span class=\"greeting\">좋은 아침 </span>\n알 수 없는 사용자\n```\n\n<div class=\"content-ad\"></div>\n\n# 통합된 제어 상태 변경 이벤트\n\nAngular Forms에서 FormControl, FormGroup 및 FormArray 클래스는 이제 events라는 속성을 노출시켜 이 폼 컨트롤의 이벤트 스트림에 구독할 수 있게 했습니다. 이를 사용하여 값 변경, 터치 상태, 원시 상태 및 제어 상태의 변경을 계속 추적할 수 있습니다.\n\n이제 다음과 같이 사용할 수 있습니다:\n\n```js\nconst nameControl = new FormControl<string|null>('name', Validators.required);\nnameControl.events.subscribe(event => {\n  // 개별 이벤트 처리\n});\n```\n\n<div class=\"content-ad\"></div>\n\n이 기능 요청은 GitHub에서 440개 이상의 좋아요를 받았습니다. 저희 커뮤니티 기여자 Matthieu Riegler님 덕분에 모든 사람들에게 이용할 수 있게 되었습니다!\n\n# 응용 프로그램 빌더로의 마이그레이션 자동화\n\nAngular v17에서 우리는 \"응용 프로그램 빌더\"를 안정적인 상태로 발표하고 새로운 프로젝트에 대해 기본으로 활성화했습니다. 내부적으로는 Vite와 esbuild를 사용하여 이전 webpack 경험을 대체했습니다.\n\n대부분의 앱들에 대해, 개발자들은 angular.json을 업데이트함으로써 새로운 빌드 시스템으로 업데이트할 수 있었습니다. 지난 6개월 동안 우리는 사용자로부터 더 많은 피드백을 수집하고, 업데이트 경험을 개선하여 모두가 새로운 빌드 경험으로 이동하고 편집/새로 고침 효과를 받을 수 있도록 했습니다.\n\n<div class=\"content-ad\"></div>\n\n당사의 업데이트 가이드에서 업데이트 경험을 자동화하기 위해 개발한 도구를 찾을 수 있습니다.\n\n새로운 빌드 시스템의 핵심 경로에 웹팩이 없기 때문에 웹팩에 대한 의존성을 선택 사항으로 만들었고, 이로 인해 Angular CLI의 총 종속성 수를 50% 이상 줄일 수 있었습니다! 이 변경으로 Angular CLI 설치 시간이 더 빨라집니다.\n\n# 함수로 된 경로 리디렉션\n\n리디렉션 처리 시 더 높은 유연성을 제공하기 위해 Angular v18에서 redirectTo는 이제 문자열을 반환하는 함수를 허용합니다. 예를 들어 런타임 상태에 따라 라우트로 리디렉션하고 싶은 경우 함수에서 더 복잡한 로직을 구현할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\nconst routes: Routes = [\n{ path: \"first-component\", component: FirstComponent },\n{\npath: \"old-user-page\",\nredirectTo: ({ queryParams }) => {\nconst errorHandler = inject(ErrorHandler);\nconst userIdParam = queryParams['userId'];\nif (userIdParam !== undefined) {\nreturn `/user/${userIdParam}`;\n} else {\nerrorHandler.handleError(new Error('Attempted navigation to user page without user ID.'));\nreturn `/not-found`;\n}\n},\n},\n{ path: \"user/:userId\", component: OtherComponent },\n];\n\n\n### TypeScript 5.4\n\n마지막으로 TypeScript의 종속성이 업데이트되어 최신 TypeScript 5.4 기능을 모두 활용할 수 있게 되었습니다!\n\n### 커뮤니티 하이라이트\n\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서 일어나는 혁신은 커뮤니티에서 많은 발전을 보게 되었어요!\n\nngrx, ngxs, rxAngular와 같은 인기 있는 상태 관리 라이브러리들은 이미 앵귤러 신호를 채택하고 컴포넌트에서 세밀한 반응성을 활성화하고 있어요.\n\n두 달 전에 앵귤러 GDE인 Brandon Roberts는 Analog.js 버전 1.0을 발표했어요. 이는 앵귤러를 위한 커뮤니티 주도의 메타 프레임워크로, 파일 기반 라우팅, API 라우트, 일급 마크다운 지원 등의 멋진 기능을 제공해요. Analog.js 팀은 커뮤니티가 좋아하는 단일 파일 컴포넌트 형식을 실험하고 있어요!\n\n또 다른 생태계의 인기 라이브러리가 앵귤러 어댑터를 개발하고 있는 것도 흥미롭게 보여요. Chau Tran, Arnoud de Vries, 그리고 Corbin Crutchley가 TanStack Store, TanStack Query, TanStack Forms 지원을 앵귤러로 출시했어요!\n\n<div class=\"content-ad\"></div>\n\n세계 각지의 Angular 커뮤니티 컨퍼런스에 참여할 수 있어 기뻐요. 올해 남은 행사들도 기대되네요. 수백 명의 참가자와 수십 명의 연사를 대상으로 컨퍼런스를 기획하는 것은 쉬운 일이 아니에요. 올해 이 힘든 과제를 현실로 만들어준 모든 분들께 감사의 말씀을 전합니다. 이들에는 ng-conf, Angular Belgrade, ng-de, ng-be, NGPoland, ngRome, NG Kenya, ngIndia, Angular TLV 등이 포함돼요! 만약 빠뜨린 컨퍼런스가 있다면 댓글에서 공유해주세요.\n\n뿐만 아니라, v16 이후로 290명 이상의 사람들로부터 기여를 받았어요! 코드, 이슈, 컨텐츠, 커뮤니티 조직 또는 가능한 방법으로 도와준 모든 분들께 감사드립니다 🙏\n\n# 우리의 진전을 되돌아보며\n\nAngular 부흥의 일환으로 지난 2년 동안 많은 것을 선보였고 앞으로도 더 많은 혁신이 예정돼 있어요. 이 부분에서 현재를 살펴보고 어디에 있는지 축하하고 싶었어요.\n\n<div class=\"content-ad\"></div>\n\nAngular을 신호 및 고급 혼합 렌더링 기능으로 진화시키면서, 우리는 항상 개발자들이 자신감을 가지고 웹 애플리케이션을 제공할 수 있도록 하는 우리의 미션을 충실하게 이행해왔습니다. 현재 세계에서 두 번째로 큰 웹사이트인 YouTube가 Angular의 반응성 기본 요소를 사용하고 있어, 우리는 더 큰 작업 그룹의 일부로 신호를 웹 플랫폼에 추가하기 위해 협업하고 있습니다.\n\n또한, Vite, Nx, Cypress, Puppeteer, Storybook 등의 도구 개발자들과 긴밀히 협력하여 모든 사람을 위한 개발자 경험을 향상시키고 있습니다. 동시에, Angular로 어떤 것이 가능한지 확장하는 열정적인 개발자, 커뮤니티 조직자, 저자, 연설자들로 이루어진 커뮤니티가 있어 우리는 행운이라고 생각합니다.\n\nAngular 부흥 과정에 함께해준 여러분께 감사드립니다!","ogImage":{"url":"/assets/img/2024-06-22-Angularv18isnowavailable_0.png"},"coverImage":"/assets/img/2024-06-22-Angularv18isnowavailable_0.png","tag":["Tech"],"readingTime":14},{"title":"가디언이 Deno를 사용해 270만 개 기사에서 접근성과 성능을 감사하는 방법","description":"","date":"2024-06-22 04:56","slug":"2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles","content":"\n\n\n![Image](/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png)\n\n(원래 deno.com/blog에 게시됨.)\n\n독립 매체인 가디언은 자사의 기사의 성능과 접근성을 감사하기 위한 가벼운 유지보수 솔루션이 필요했습니다. 가디언이 Deno를 핵심 인프라에서 이용하여 270만 개의 기사 전반에 걸쳐 접근성과 성능을 감사하는 방법을 알아보세요.\n\n# 과제\n\n\n<div class=\"content-ad\"></div>\n\n가디언 웹사이트는 매달 3억 5천만 개 이상의 고유 페이지 조회수를 기록합니다. 독자들의 기대를 충족하기 위해서는 웹사이트가 성능에 최적화되어 있고 콘텐츠를 최대한 빨리 제공할 뿐만 아니라 다양한 웹 접근성 요구사항을 지원해야 합니다.\n\n대형 매체 사이트로서 각 밀리초가 중요합니다. BBC에 따르면 페이지 로딩에 추가된 1초가 사용자의 10%를 이탈시킨다고 합니다. 웹사이트의 고객 소프트웨어 엔지니어인 맥스 듀발은 \"웹사이트에 발행된 자산이 최적화되었는지를 보장하기 위한 방법이 필요했습니다\"라고 말합니다.\n\n성능 이외에도 엔지니어들은 독자들이 웹사이트에서 콘텐츠를 소비할 때 다양한 보조 기술을 사용하는 사실을 인지하고 있습니다. 자신들의 이야기가 널리 읽히도록 하려면 웹 접근성 요구사항을 준수해야 합니다. 맥스는 \"수동 감사를 통해 일부 기사에 중요 속성이 누락된 HTML 요소가 포함되어 있는 것이 밝혀졌습니다. 새로운 기사는 최상의 접근성 규칙을 준수하도록 하고 싶었으나, 이러한 불일치 사항을 대규모로 발견하는 시스템화된 자동 접근 방법이 없었습니다\"라고 말합니다.\n\n# 해결책\n\n<div class=\"content-ad\"></div>\n\n팀은 접근성 및 성능 불일치를 평가하기 위한 자동화 시스템을 구축해야 한다는 것을 알았습니다. 먼저 Node를 시도했지만 복잡성 문제에 직면했습니다. Max는 \"페이지를 다운로드하고 살펴보는 것과 같이 간단한 작업에 Node를 사용하는 것은 매우 복잡했다\"고 말합니다. \"GET 요청 수행, URL 구문 분석, 리다이렉션 해결은 모두 라이브러리를 평가하고 설치하는 것이 필요했습니다.\" 그러나 웹 표준 API를 네이티브로 지원하는 Deno를 사용하면 동일한 스크립트가 훨씬 간단해집니다. Max는 \"Deno에는 의존성 부풀림 위험이 없으므로 Node 및 npm에서 발생하는 문제가 없습니다.\"\n\n또한 Deno를 사용해 네이티브 TypeScript 지원을 즐겼습니다. Max는 \"가디언은 서버 코드의 대부분을 전통적으로 스칼라로 사용해왔는데 강한 유형화가 되어 있습니다. TypeScript는 꾸준히 인기를 얻고 있지만 번들되지 않은 애플리케이션에 사용하기 어려웠습니다. 설정 없이 TypeScript를 작성하고 실행할 수 있는 것은 우리 팀이 빠르게 움직이는 데 도움이 되었습니다,\"라고 말합니다.\n\n자동화된 시스템은 GitHub Actions에서 매일 Deno 스크립트를 실행하여 누락된 HTML 속성 및 이미지, 폰트, 기타 미디어와 같은 에셋 크기를 확인하여 접근성 및 성능을 평가합니다. 작업에 의해 나타난 어떤 차이점이라도 팀이 조사할 수 있도록 GitHub 이슈를 업데이트합니다.\n\n\"우리의 이야기들이 가능한 많은 독자들에 의해 소비될 수 있도록 하는 것에 도움이 되도록 기반을 설치하는 것이 우리에게 쉬웠다,\"고 Max는 말합니다.","ogImage":{"url":"/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png"},"coverImage":"/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png","tag":["Tech"],"readingTime":2},{"title":"프로처럼 React 컴포넌트 작성하는 방법","description":"","date":"2024-06-22 04:55","slug":"2024-06-22-WriteaReactComponentLikeaPro","content":"\n\n<img src=\"/assets/img/2024-06-22-WriteaReactComponentLikeaPro_0.png\" />\n\n리액트 세계에서 컴포넌트를 작성하는 것은 예술입니다. 그것은 단순히 작동하게 만드는 것이 아니라, 잘 작동하게 만드는 것이 중요합니다. 오늘은 프로처럼 컴포넌트를 만드는 방법을 살펴보겠습니다. 가독성, 재사용성, 효율성에 초점을 맞춰.\n\n## 리스트 컴포넌트 만들기\n\n우리가 기본 리스트 컴포넌트부터 시작해봅시다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// src/components/List.js\nimport React from 'react';\n\nconst List = ({ data }) => {\n  return (\n    <ul>\n      {data.map((item, index) => (\n        <li key={index}>{item}</li>\n      ))}\n    </ul>\n  );\n};\n\nexport default List;\n```\n\n이 컴포넌트는 데이터 배열을 가져와서 목록으로 렌더링합니다.\n\n## HOC로 컴포넌트 향상하기\n\n고차 컴포넌트(Higher-Order Components, HOC)는 컴포넌트 로직을 재사용하는 강력한 패턴입니다. 기본적으로 컴포넌트를 감싸서 구조를 변경하지 않고 기능을 확장합니다.\n\n\n<div class=\"content-ad\"></div>\n\n예를 들어, withLoading HOC를 사용하면 로딩 상태를 표시할 수 있습니다:\n\n```js\n// src/hocs/withLoading.js\nimport React, { useState } from 'react';\n\nfunction withLoading(Component) {\n  return function WithLoading({ isLoading, ...props }) {\n    if (isLoading) {\n      return <div>Loading...</div>;\n    }\n    return <Component {...props} />;\n  };\n}\n\nexport default withLoading;\n```\n\n이 HOC는 isLoading 속성을 확인합니다. 만약 true이면 \"로딩 중...\" 메시지를 렌더링합니다. 그렇지 않으면 래핑된 컴포넌트를 렌더링하여 데이터 가져오는 동안 사용자 경험이 연속적이게 됩니다.\n\n비슷하게, withErrorHandling은 에러 상태를 관리하는 다른 HOC입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// src/hocs/withErrorHandling.js\nimport React from 'react';\n\nfunction withErrorHandling(Component) {\n  return function WithErrorHandling({ error, ...props }) {\n    if (error) {\n      return <div>Error: {error.message}</div>;\n    }\n    return <Component {...props} />;\n  };\n}\n\nexport default withErrorHandling;\n```\n\n에러가 발생하면 withErrorHandling이 에러 메시지를 표시합니다. 그렇지 않으면 컴포넌트를 일반적으로 렌더링합니다. 이 HOC는 특히 fetch 오류를 처리하거나 컴포넌트 라이프사이클 내에서 발생하는 문제를 처리하기에 유용합니다.\n\nwithLoading과 withErrorHandling을 결합하여, 로딩 및 에러 상태를 우아하게 처리하는 견고한 컴포넌트를 만들 수 있습니다. 이 접근 방식은 코드 재사용과 관심사 분리를 촉진하여 컴포넌트를 더 쉽게 유지하고 이해하기 쉽게 만듭니다.\n\n## 훅을 사용하여 데이터 가져오기\n\n<div class=\"content-ad\"></div>\n\n리액트 훅을 사용하면 클래스를 작성하지 않고도 상태 및 기타 리액트 기능을 사용할 수 있습니다. useFetch는 API에서 데이터를 가져오는 커스텀 훅입니다:\n\n```js\n// src/hooks/useFetch.js\nimport { useState, useEffect } from 'react';\n\nconst useFetch = (url) => {\n  const [data, setData] = useState([]);\n  const [isLoading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error('Network response was not ok');\n        }\n        const json = await response.json();\n        setData(json);\n      } catch (error) {\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () => {\n      // Cleanup logic if needed\n    };\n  }, [url]);\n\n  return { data, isLoading, error };\n};\n\nexport default useFetch;\n```\n\n이 훅은 데이터 가져오기 상태, 데이터 저장 및 오류 처리를 처리하여 컴포넌트에서 데이터를 쉽게 가져와 표시할 수 있습니다.\n\n## 앱 조립하기\n\n<div class=\"content-ad\"></div>\n\n마지막으로, App 컴포넌트에서 모든 것을 하나로 통합합니다:\n\n```js\n// src/App.js\nimport React from 'react';\nimport withLoading from './hocs/withLoading';\nimport withErrorHandling from './hocs/withErrorHandling'; // 새로운 HOC 추가\nimport useFetch from './hooks/useFetch';\nimport List from './components/List';\n\nconst ListWithLoading = withLoading(List);\nconst ListWithErrorHandling = withErrorHandling(ListWithLoading); // ListWithLoading 컴포넌트에 에러 처리 추가\n\nconst App = () => {\n  const { data, isLoading, error } = useFetch('https://api.example.com/data');\n\n  return (\n    <div>\n      <h1>List Component</h1>\n      <ListWithErrorHandling data={data} isLoading={isLoading} error={error} /> {/* 에러가 발생하면 ListWithLoading 컴포넌트로 전달됩니다 */}\n    </div>\n  );\n};\n\nexport default App;\n```\n\nuseFetch 훅을 사용하여 데이터를 로드하고 HOC를 통해 로딩 및 에러 처리 기능이 추가된 List 컴포넌트에 전달합니다.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n프로처럼 컴포넌트를 작성하려면 더 큰 그림을 고려하는 것이 중요합니다. 읽기 쉽고 유지보수 및 재사용이 용이한 컴포넌트를 만드는 것이죠. HOCs와 훅과 같은 패턴을 사용하여 시간이 지나도 유지보수가 용이하고 효율적인 코드베이스를 만들 수 있습니다.\n\n코딩을 즐기세요!\n\n# 평문으로 쓴 것 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 나가시기 전에:\n\n<div class=\"content-ad\"></div>\n\n- 작가를 박수로 응원하고 팔로우 해 주세요! 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-22-WriteaReactComponentLikeaPro_0.png"},"coverImage":"/assets/img/2024-06-22-WriteaReactComponentLikeaPro_0.png","tag":["Tech"],"readingTime":5},{"title":"오늘 React 컴파일러를 사용해 봤는데, 결과가 ","description":"","date":"2024-06-22 04:52","slug":"2024-06-22-ItriedReactCompilertodayandguesswhat","content":"\n\n<img src=\"/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_0.png\" />\n\n이것은 아마도 내가 만든 가장 클릭베이트 스러운 제목일 것 같아요. 그러나 요즘의 React 커뮤니티에서 가장 혹평 받는 주제 중 하나에 대한 글은 이렇게 만들어야 한다고 느껴요 😅.\n\n지난 두 년 반 동안, 리렌더링과 메모이제이션과 관련된 패턴을 언급하는 내용을 게시한 후에, 미래에서 온 방문자들이 댓글 섹션으로 내려와서 React Forget(지금은 React Compiler로 알려져 있음) 때문에 이전에 말한 내용이 더 이상 관련이 없다고 친절히 알려주곤 했어요.\n\n이제 우리의 시간표가 그들의 시간표에 따라잡혔고, React Compiler가 실험적인 기능으로 실제로 일반 대중에게 출시되었으니, 앞으로 리액트에서는 메모이제이션을 잊을 수 있는지 여부를 조사해 봐야 할 때입니다.\n\n<div class=\"content-ad\"></div>\n\n# 리액트 컴파일러란?\n\n하지만 먼저, 매우 간단히 말하면, 이 컴파일러는 무엇이며 어떤 문제를 해결하며 어떻게 시작할 수 있는지에 대해 알아보겠습니다.\n\n문제: 리액트에서의 다시 렌더링은 연쇄적입니다. 리액트 컴포넌트의 상태를 변경할 때마다 해당 컴포넌트의 다시 렌더링이 트리의 끝까지 도달할 때까지 해당 컴포넌트 내, 그 안에 있는 컴포넌트, 이와 같은 컴포넌트들의 컴포넌트 등이 다시 렌더링됩니다.\n\n![이미지](/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_1.png)\n\n<div class=\"content-ad\"></div>\n\n만약 하위 다시 렌더링이 무겁거나 너무 자주 발생하면, 앱의 성능 문제를 야기할 수 있습니다.\n\n이러한 성능 문제를 해결하는 한 가지 방법은 그 다시 렌더링 체인을 방지하는 것이며, 이를 위한 한 가지 방법은 메모이제이션을 사용하는 것입니다: React.memo, useMemo, 그리고 useCallback. 보통, 우리는 React.memo로 컴포넌트를 래핑하고, 모든 프롭스를 useMemo와 useCallback으로 감싸며, 부모 컴포넌트가 다음번 다시 렌더링될 때, 메모로 래핑된 컴포넌트는 다시 렌더링되지 않습니다.\n\n그러나 이러한 도구를 올바르게 사용하는 것은 어렵습니다. 정말로 어렵습니다. 이 주제에 대해 몇 가지 기사를 작성하고 몇 개의 비디오를 제작했습니다. 만일 여러분이 지식을 시험해보고 싶다면 (How to useMemo and useCallback: you can remove most of them, Mastering memoization in React — Advanced React course, Episode 5).\n\n여기서 React 컴파일러가 등장합니다. 컴파일러는 React 코어 팀에 의해 개발된 도구입니다. 이 도구는 빌드 시스템에 통합되어 원본 컴포넌트 코드를 가져와 컴포넌트, 그 프롭스, 그리고 훅의 의존성이 기본적으로 메모이제이션되도록 코드로 변환하려고 노력합니다. 최종 결과는 모든 것을 memo, useMemo 또는 useCallback으로 감싸는 것과 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 단지 그것을 이해하기 위해 대략적인 것일 뿐이에요. 실제로는 훨씬 더 복잡한 변환을 합니다. Jack Herrington이 최근 비디오에서 이에 대한 좋은 개요를 제시했어요(React Compiler: In-Depth Beyond React Conf 2024), 실제 세부 내용을 알고 싶다면 보는 것을 권해드려요. 혹은, 굉장히 복잡한 것을 체감하고 싶다면 \"React Compiler Deep Dive\" 토크에서 Sathya Gunasekaran이 컴파일러를 설명하고 Mofei Zhang이 20분 동안 실시간 코딩하는 것을 보세요. 🤯\n\n만약 여러분이 직접 컴파일러를 시도해 보고 싶다면, 문서를 따라가보세요: https://react.dev/learn/react-compiler. 이미 충분히 잘 작성되어 있고 필요한 모든 내용과 어떻게 해야 하는지 담겨 있어요. 기억하세요: 이것은 아직 실험 단계인 것으로, React의 캐너리 버전을 설치하는 것을 기반으로 하고 있으니 조심하세요.\n\n준비는 여기까지에요. 이제 이것이 무엇을 할 수 있는지 그리고 실제로 어떻게 작동하는지 살펴봐 볼까요?\n\n# 컴파일러 시도하기\n\n<div class=\"content-ad\"></div>\n\n저에게 이 기사의 주요 목적은 컴파일러에 대한 우리의 기대가 현실과 일치하는지 조사하는 것이었습니다. 현재의 약속은 무엇인가요?\n\n- 컴파일러는 플러그 앤 플레이입니다: 설치하고 그냥 작동합니다. 기존 코드를 다시 작성할 필요가 없습니다.\n- React.memo, useMemo 및 useCallback에 대해 설치한 후에는 다시 생각할 필요가 없습니다: 필요가 없을 것입니다.\n\n이러한 가정을 테스트하기 위해 제가 몇 가지 간단한 예제를 독립적으로 컴파일러를 테스트하는 데 구현하고, 그런 다음 사용 가능한 세 가지 다른 앱에서 실행했습니다.\n\n## 단순 예제: 독립적으로 컴파일러 테스트하기\n\n<div class=\"content-ad\"></div>\n\n간단한 예제의 전체 코드는 여기에서 확인할 수 있습니다: https://github.com/developerway/react-compiler-test\n\n컴파일러를 처음부터 시작하는 가장 쉬운 방법은 Next.js의 캐너리 버전을 설치하는 것입니다. 기본적으로 이 작업은 필요한 모든 것을 제공할 것입니다:\n\n```js\nnpm install next@canary babel-plugin-react-compiler\n```\n\n그런 다음, next.config.js에서 컴파일러를 켤 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst nextConfig = {\n  experimental: {\n    reactCompiler: true,\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n그리고 와라! React Dev Tools 에서 자동으로 메모이제이션된 컴포넌트를 즉시 볼 수 있습니다.\n\n<img src=\"/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_2.png\" />\n\n지금까지의 가정이 맞았습니다: 설치는 매우 간단하고 그냥 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n코드 작성을 시작해봅시다. 컴파일러가 어떻게 처리하는지 확인해 봅시다.\n\n## 첫 번째 예시: 간단한 상태 변경.\n\n```js\nconst SimpleCase1 = () => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setIsOpen(!isOpen)}>\n        다이얼로그 전환\n      </button>\n      {isOpen && <Dialog />}\n      <VerySlowComponent />\n    </div>\n  );\n};\n```\n\n우리는 modal dialog가 열려 있는지 여부를 제어하는 isOpen 상태 변수를 가지고 있으며, 동일한 컴포넌트에서 렌더링된 VerySlowComponent가 있습니다. 일반 React 동작은 isOpen 상태가 변경될 때마다 VerySlowComponent를 다시 렌더링하므로, dialog가 지연되어 팝업하는 것을 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 이러한 상황을 메모이제이션을 사용하여 해결하려면 (물론 다른 방법도 있지만), React.memo로 VerySlowComponent를 감싸야 합니다:\n\n```js\nconst VerySlowComponentMemo = React.memo(VerySlowComponent);\n\nconst SimpleCase1 = () => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    <>\n      ...\n      <VerySlowComponentMemo />\n    </>\n  );\n};\n```\n\n컴파일러를 사용하면 순수한 마법입니다: React.memo를 제거해도 개발 도구에서 VerySlowComponent가 메모이제이션되어 있고 딜레이가 사라지며, VerySlowComponent 내부에 console.log를 넣으면 상태 변경시 다시 렌더링되지 않음을 확인할 수 있습니다.\n\n[이 예제의 전체 코드는 여기에서 확인할 수 있습니다.](링크)\n\n<div class=\"content-ad\"></div>\n\n## 두 번째 예시: 느린 컴포넌트의 속성(props).\n\n지금까지는 잘 진행되었지만, 이전 예시는 가장 간단한 것이었습니다. 조금 더 복잡하게 만들어서 등식에 props을 소개해 봅시다.\n\n아주 느린 컴포넌트인 VerySlowComponent가 함수를 기대하는 onSubmit prop과 배열을 수용하는 data prop을 가지고 있다고 가정해 봅시다:\n\n```js\nconst SimpleCase2 = () => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const onSubmit = () => {};\n  const data = [{ id: 'bla' }];\n\n  return (\n    <>\n      ...\n      <VerySlowComponent onSubmit={onSubmit} data={data} />\n    </>\n  );\n};\r\n```\n\n<div class=\"content-ad\"></div>\n\n지금 수동 메모이제이션의 경우에는 React.memo로 VerySlowComponent를 감싸는 것 외에도 배열을 useMemo로 감싸고 (어떤 이유로 이를 바깥쪽으로 옮기지 못한다는 것을 가정해 봅시다) onSubmit을 useCallback으로 감싸야 합니다:\n\n```js\nconst VerySlowComponentMemo = React.memo(VerySlowComponent);\n\nexport const SimpleCase2Memo = () => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  // 여기에 메모이제이션\n  const onSubmit = useCallback(() => {}, []);\n\n  // 여기에 메모이제이션\n  const data = useMemo(() => [{ id: 'bla' }], []);\n\n  return (\n    <div>\n      ...\n      <VerySlowComponentMemo\n        onSubmit={onSubmit}\n        data={data}\n      />\n    </div>\n  );\n};\n```\n\n그러나 Compiler를 사용하는 경우에는 그렇게 할 필요가 없습니다! VerySlowComponent는 여전히 React 개발 도구에서 메모이제이션된 상태로 표시되며, 그 안에 있는 \"control\" console.log가 여전히 실행되지 않습니다.\n\n이 저장소에서 이러한 예제를 로컬에서 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 세 번째 예시: 자식 요소로 요소들.\n\n알겠어요, 세 번째 예시입니다. 실제 앱을 테스트하기 전에 처리할 내용입니다. 거의 아무도 제대로 메모이즈를 할 수 없는 경우는 어떻게 할까요? 만약 우리의 느린 컴포넌트가 자식 요소를 받는다면 어떨까요?\n\n```js\nexport const SimpleCase3 = () => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    <>\n      ...\n      <VerySlowComponent>\n        <SomeOtherComponent />\n      </VerySlowComponent>\n    </>\n  );\n};\n```\n\n머릿속으로 바로 VerySlowComponent를 올바르게 메모이즈하는 방법을 기억할 수 있나요?\n\n<div class=\"content-ad\"></div>\n\n대부분의 사람들은 VerySlowComponent와 SomeOtherComponent를 모두 React.memo로 감싸야 한다고 생각할 것입니다. 하지만 이것은 틀렸어요. 우리는 대신에 `SomeOtherComponent /` 요소를 useMemo로 감싸야 합니다. 아래처럼요:\n\n```js\nconst VerySlowComponentMemo = React.memo(VerySlowComponent);\n\nexport const SimpleCase3 = () => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  // React.memo 대신 useMemo를 사용하여 자식 요소 메모이제이션\n  const child = useMemo(() => <SomeOtherComponent />, []);\n\n  return (\n    <>\n      ...\n      <VerySlowComponentMemo>{child}</VerySlowComponentMemo>\n    </>\n  );\n};\n```\n\n만약 왜 이렇게 하는지 확신이 들지 않는다면, 이 비디오를 시청해보세요. 이 비디오에서 메모이제이션에 대해 자세히 설명하고, 이 패턴도 다루고 있어요: Mastering memoization in React — Advanced React course, Episode 5. 또한 이 글도 유용할 것입니다: The mystery of React Element, children, parents and re-renders\n\n다행히 React 컴파일러는 여기서도 마법을 부릅니다 ✨! 모든 것이 메모이제이션되어, 매우 느린 컴포넌트는 다시 렌더링되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n세 번의 시도 가운데 세 번 모두 성공하셨네요, 인상적입니다! 하지만 그 예시들은 매우 간단했죠. 현실에서는 쉬운 것이 그렇게 많지 않죠? 이제 진짜 도전을 해보겠습니다.\n\n# 실제 코드에서 컴파일러 테스트하기\n\n컴파일러에 진짜 도전을 주기 위해, 저는 제가 가지고 있는 세 개의 코드베이스에서 테스트를 진행했습니다.\n\n- 앱 하나: 몇 년 전에 만들어진 상당히 큰 React, React Router & Webpack 기반 앱으로, 여러 사람이 작성한 코드입니다.\n- 앱 둘: 조금 더 최근에 만들어진데도 여전히 상당히 큰 React & Next.js 앱으로, 여러 사람이 작성한 코드입니다.\n- 앱 셋: 제 개인 프로젝트로, 매우 최근에 시작했고, 최신 Next.js를 사용하며, 아주 작습니다 — 몇 개의 CRUD 작업을 수행하는 화면이 몇 개 있습니다.\n\n<div class=\"content-ad\"></div>\n\n각 앱에 대해 다음을 수행했습니다:\n\n- 초기 건강 점검을 통해 컴파일러를 위한 앱의 준비 상태를 확인했습니다.\n- Compiler의 eslint 규칙을 활성화하고 전체 코드베이스에서 실행했습니다.\n- React 버전을 19 canary로 업데이트했습니다.\n- 컴파일러를 설치했습니다.\n- 컴파일러를 켜기 전에 불필요한 다시 렌더링의 몇 가지 명백한 경우를 식별했습니다.\n- 컴파일러를 켜고 해당 불필요한 다시 렌더링이 해결되었는지 확인했습니다.\n\n## App One에서 Compiler를 테스트한 결과\n\n이 앱은 아마도 React 부분의 전체 코드의 약 15만 줄 정도일 것으로 예상됩니다. 이 앱에는 10 개의 명확한 불필요한 다시 렌더링 사례를 식별했습니다. 그 중 일부는 전체 헤더 구성 요소를 전체 다시 렌더링하는 것과 같이 매우 사소한 것이었습니다. 또 다른 것은 입력 필드에 타이핑할 때 전체 페이지를 다시 렌더링하는 것과 같이 좀 더 큰 사례였습니다.\n\n<div class=\"content-ad\"></div>\n\n- 초기 건강 진단: 구성 요소의 97.7%가 컴파일될 수 있었습니다! 호환되지 않는 라이브러리는 없습니다.\n- Eslint 체크: 규칙 위반이 20건 발견되었습니다.\n- React 19 업데이트: 몇 가지 사소한 문제가 발생했지만 주석 처리한 후에는 앱이 잘 작동하는 것 같았습니다.\n- 컴파일러 설치: 이 과정에서 몇 가지 문제가 발생하여 ChatGPT의 도움이 필요했습니다. 오랜만에 Webpack이나 Babel과 관련된 것을 다루어 본 것이라 그런 것 같아요. 하지만 결국 성공했습니다.\n- 앱 테스트: 10가지 불필요한 재랜더링 중... 컴파일러가 해결한 것은 2가지뿐이네요 😢\n\n10가지 중 2가지만 해결된 결과는 상당히 실망스러웠습니다. 그런데 이 앱에는 아직 수정하지 않은 eslint 위반이 있습니다. 그게 그 이유일까요? 다음 앱을 살펴보겠습니다.\n\n## 두 번째 앱에서 컴파일러 테스트 결과\n\n이 앱은 훨씬 작아요, 대략 30,000줄 정도의 React 코드로 이루어져 있습니다. 여기에서도 10가지 불필요한 재랜더링을 확인했어요.\n\n<div class=\"content-ad\"></div>\n\n- 초기 건강 확인: 동일 결과, 97.7% 구성 요소가 컴파일될 수 있었습니다.\n- Eslint 확인: 단 하나의 규칙 위반만 발견되었어요! 🎉 완벽한 후보입니다.\n- React 19 업데이트 및 Compiler 설치: 이를 위해 Next.js를 canary 버전으로 업데이트해야 했는데, 그 외는 Next.js가 해결해주었습니다. 설치 후에는 바로 작동되었고, Webpack 기반 앱을 업데이트하는 것보다 훨씬 쉬웠어요.\n- 앱 테스트: 불필요한 재랜더링 10가지 중 2가지만 구체적으로 컴파일러에 의해 수정되었습니다 😢\n\n10가지 중 2가지 또한! 완벽한 후보겠죠… 다소 실망스럽네요. 실제 상황과 합성 “카운터” 예제의 대립입니다. 문제를 해결하기 전에 세 번째 앱을 살펴보겠습니다.\n\n## 세 번째 앱에서 Compiler 테스트: 결과\n\n이것은 모두 중에서 가장 작은 앱이며, 주말 또는 몇 주 동안 작성되었습니다. 데이터 테이블이 있는 몇 개 페이지와 테이블에서 엔티티를 추가/편집/제거할 수 있는 기능만 있어요. 앱 전체가 아주 작고 간단해서, 내가 식별한 불필요한 재랜더링이 8가지뿐이었습니다. 모든 상호작용에 대해 모든 것이 다시 렌더링되며, 어떠한 최적화 역시 하지 않았습니다.\n\n<div class=\"content-ad\"></div>\n\n리액트 컴파일러에게 재랜더링 상황을 크게 개선할 수 있는 좋은 주제네요!\n\n- 초기 건강 점검: 100%의 컴포넌트가 컴파일될 수 있습니다.\n- Eslint 점검: 어긋남이 없어요 🎉\n- 리액트 19 업데이트 & 컴파일러 설치: 이전 것보다 놀랍게도 더 나빠졌어요. 사용한 몇 가지 라이브러리가 아직 리액트 19와 호환되지 않아서 경고를 무시하기 위해 종속성을 강제로 설치해야 했어요. 하지만 실제 앱과 모든 라이브러리는 여전히 작동했으므로 큰 문제는 없었어요, 아마도요.\n- 앱 테스트: 불필요한 재랜더링 8건 중에, 리액트 컴파일러가 고칠 수 있었던 것은… 덩실 덩실… 하나. 딱 하나! 🫠 이 시점에서 거의 울고 싶어진 건 이 테스트를 위해서 큰 희망을 품었었기 때문이었어요.\n\n이건 예전 냉소적인 성향이 예상했지만, 어린애 같은 내면은 기대하지 않았던 것이에요. 아마 난 리액트 코드를 잘못 작성하고 있는 걸까요? 컴파일러의 메모이제이션 결과를 조사하고, 어떻게 고칠 수 있는지 알아볼까요?\n\n# 컴파일러에 의한 메모이제이션 결과 조사\n\n<div class=\"content-ad\"></div>\n\n이슈를 유용하게 디버그하기 위해 세 번째 앱의 페이지 중 하나를 별도의 저장소로 추출했습니다. 여기서 확인할 수 있습니다: (https://github.com/developerway/react-compiler-test/) 제 생각을 따라가보고 코드 실습도 해보고 싶다면 들어가보세요. 세 번째 앱의 페이지 중 하나와 거의 동일한데, 가짜 데이터와 몇 가지 제거된 부분(SSR과 같은 것)이 있어서 디버깅 경험을 간소화했습니다.\n\nUI는 매우 간단합니다. 국가 목록이 있는 테이블, 각 행마다 \"삭제\" 버튼, 그리고 테이블 아래에 있는 입력 컴포넌트로 새로운 국가를 목록에 추가할 수 있습니다.\n\n\n![테이블](/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_3.png)\n\n\n코드적으로는 하나의 컴포넌트만 있는데, 상태, 쿼리 및 뮤테이션도 있습니다. 전체 코드는 여기 있습니다. 조사에 필요한 필수 정보만 있는 간소화된 버전은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nexport const Countries = () => {\n  // input에서 입력한 내용을 저장합니다\n  const [value, setValue] = useState(\"\");\n\n  // react-query를 사용하여 국가 전체 목록을 가져옵니다\n  const { data: countries } = useQuery(...);\n\n  // react-query를 사용하여 국가를 삭제하는 뮤테이션\n  const deleteCountryMutation = useMutation(...);\n\n  // react-query를 사용하여 국가를 추가하는 뮤테이션\n  const addCountryMutation = useMutation(...);\n\n  // \"delete\" 버튼에 전달되는 콜백\n  const onDelete = (name: string) => deleteCountryMutation.mutate(name);\n\n  // \"add\" 버튼에 전달되는 콜백\n  const onAddCountry = () => {\n    addCountryMutation.mutate(value);\n    setValue(\"\");\n  };\n\n  return (\n    ...\n      {countries?.map(({ name }, index) => (\n        <TableRow key={`${name.toLowerCase()}`}>\n          ...\n          <TableCell className=\"text-right\">\n            <!-- onDelete이 여기에 있습니다 -->\n            <Button onClick={() => onDelete(name)} variant=\"outline\">\n              Delete\n            </Button>\n          </TableCell>\n        </TableRow>\n      ))}\n    ...\n    <Input\n      type=\"text\"\n      placeholder=\"새로운 국가 추가\"\n      value={value}\n      onChange={(e) => setValue(e.target.value)}\n    />\n    <button onClick={onAddCountry}>추가</button>\n  );\n};\n```\n\n이 컴포넌트는 로컬 상태와 쿼리/뮤테이션 업데이트가 모두 있는 하나의 컴포넌트이기 때문에 모든 상호작용 시마다 다시 렌더링됩니다. 앱을 시작하면 다음과 같이 불필요한 다시 렌더링이 발생합니다:\n\n- \"새로운 국가 추가\" 입력란에 입력하는 동안 모든 것이 다시 렌더링됩니다.\n- \"삭제\"를 클릭하면 모든 것이 다시 렌더링됩니다.\n- \"추가\"를 클릭하면 모든 것이 다시 렌더링됩니다.\n\n이런 간단한 컴포넌트의 경우, 컴파일러가 이를 모두 해결해 줄 것으로 기대됩니다. 특히 React Dev Tools에서 모든 것이 메모이제이션되어 있는 것을 고려할 때요.\n\n<div class=\"content-ad\"></div>\n\n\n![React Compiler](/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_4.png)\n\n하지만 \"컴포넌트 렌더링 시 업데이트 강조\" 설정을 활성화해보고 멋진 빛쇼를 즐기세요.\n\n![Light Show](https://miro.medium.com/v2/resize:fit:1076/0*XrqU0579UN-SXWgm.gif)\n\n테이블 내 모든 컴포넌트에 console.log를 추가하면 헤더 컴포넌트를 제외한 모든 것이 모든 원천에서 상태 업데이트 시 다시 렌더링됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n왜 그러한지 조사하는 방법은 무엇인가요? 🤔\n\n리액트 개발 도구에서 추가 정보를 제공하지 않습니다. 저는 그 컴포넌트를 Compiler Playground로 복사하여 무슨 일이 일어나는지 확인할 수 있겠죠… 하지만 결과를 보세요! 😬 그건 잘못된 방향으로 나아가는 것 같고, 솔직히 말해서, 가장 할 일이 아닌 것 같아요.\n\n머릿속에 떠오르는 유일한 방법은 테이블을 점진적으로 메모화하고 컴포넌트나 종속성에 이상이 있는지 확인하는 것입니다.\n\n# 수동 메모화를 통한 조사\n\n<div class=\"content-ad\"></div>\n\n이 부분은 모든 수동 메모이제이션 기술이 어떻게 작동하는지 완전히 이해하는 사람을 대상으로 합니다. React.memo, useMemo 또는 useCallback에 대해 불편하게 느낀다면, 먼저 이 비디오를 시청하는 것을 추천합니다.\n\n또한, 코드를 로컬로 열고(https://github.com/developerway/react-compiler-test) 코드 연습을 해보는 것을 추천드립니다. 이렇게 하면 아래의 사고 과정을 더 쉽게 따를 수 있습니다.\n\n## 입력란에 타이핑해 보면서 렌더링을 조사하기\n\n우리는 다시 테이블을 자세히 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\n<Table>\n  <TableCaption>지원되는 국가 목록.</TableCaption>\n  <TableHeader>\n    <TableRow>\n      <TableHead className=\"w-[400px]\">이름</TableHead>\n      <TableHead className=\"text-right\">동작</TableHead>\n    </TableRow>\n  </TableHeader>\n  <TableBody>\n    {countries?.map(({ name }, index) => (\n      <TableRow key={`${name.toLowerCase()}`}>\n        <TableCell className=\"font-medium\">\n          <Link href={`/country/${name.toLowerCase()}`}>\n            {name}\n          </Link>\n        </TableCell>\n        <TableCell className=\"text-right\">\n          <Button\n            onClick={() => onDelete(name)}\n            variant=\"outline\"\n          >\n            삭제\n          </Button>\n        </TableCell>\n      </TableRow>\n    ))}\n  </TableBody>\n</Table>\r\n```\n\n헤더 컴포넌트가 메모이즈되어 있어서, 컴파일러가 무슨 일을 했는지 알 수 있었습니다: 아마도 모든 컴포넌트를 React.memo와 같은 방식으로 감쌌을 것이고, TableBody 내부의 일부는 useMemo와 유사한 것으로 메모이즈되었을 것입니다. 그리고 useMemo와 비슷한 것이 그 종속성 중 하나가 모든 다시 렌더링 때마다 업데이트되어 TableBody 내의 모든 것을 다시 렌더링하도록 유도했을 거라고 생각됩니다. 최소한 테스트해볼만한 가설입니다.\n\n만약 해당 내용 부분을 메모이제이션한다면 어떤 단서를 제공할 수 있을지 확인해보겠습니다:\n\n```js\r\n// TableBody의 전체 내용을 메모이즈\nconst body = useMemo(\n  () =>\n    countries?.map(({ name }, index) => (\n      <TableRow key={`${name.toLowerCase()}`}>\n        <TableCell className=\"font-medium\">\n          <Link href={`/country/${name.toLowerCase()}`}>\n            {name}\n          </Link>\n        </TableCell>\n        <TableCell className=\"text-right\">\n          <Button\n            onClick={() => onDelete(name)}\n            variant=\"outline\"\n          >\n            삭제\n          </Button>\n        </TableCell>\n      </TableRow>\n    )),\n  // 이 부분은 그 코드 덩어리에서 사용되는 종속성들입니다.\n  // eslint를 감사하게 생각합니다!\n  [countries, onDelete],\n);\r\n```\n\n<div class=\"content-ad\"></div>\n\n이제 전체 부분이 데이터의 countries 배열과 onDelete 콜백에 의존함을 명확히 알 수 있습니다. countries 배열은 쿼리에서 가져오기 때문에 매번 다시 렌더링될 수 없습니다. 이를 캐싱하는 것이 라이브러리의 주요 책임 중 하나입니다.\n\nonDelete 콜백은 다음과 같이 생겼습니다:\n\n```js\nconst onDelete = (name: string) => {\n  deleteCountryMutation.mutate(name);\n};\n```\n\n이것이 의존성으로 들어가려면 memoized 되어야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nconst onDelete = useCallback(\n  (name: string) => {\n    deleteCountryMutation.mutate(name);\n  },\n  [deleteCountryMutation],\n);\r\n```\n\n그리고 deleteCountryMutation은 다시 react-query의 뮤테이션입니다, 그러니까 괜찮습니다:\n\n```js\r\nconst deleteCountryMutation = useMutation({...});\r\n```\n\n마지막 단계는 TableBody를 메모이즈하고 메모이즈된 자식을 렌더링하는 것입니다. 모든 것이 올바르게 메모이즈되었다면, 입력란에 타이핑할 때 행과 셀의 재렌더링이 멈추어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst TableBodyMemo = React.memo(TableBody);\n\n// Countries 내부에서 이것을 렌더링하세요\n<TableBodyMemo>{body}</TableBodyMemo>;\n```\n\n그리고 안 됐네요 🤦🏻‍♀️ 이제 좀 진전이 있네요 — 의존성에서 무언가를 엉망으로 만들어놨나 봅니다, 아마 컴파일러도 똑같이 한게겠죠. 그런데 무엇이 문제일까요? 국가들 이외에 제가 가진 유일한 의존성은 deleteCountryMutation 이에요. 그것을 사용하는 게 안전하다고 가정했는데, 정말일까요? 실체가 무엇인지 알아야겠네요. 다행히 소스 코드를 확인할 수 있어요. useMutation 은 많은 일을 하는 후크로서 다음을 반환합니다:\n\n```js\nconst mutate = React.useCallback(...);\n\nreturn { ...result, mutate, mutateAsync: result.mutate };\n```\n\n반환값은 memoized되지 않은 객체야요!! 단순히 의존성으로 사용할 수 있다고 가정했던 것이 잘못된 판단이었네요.\n\n<div class=\"content-ad\"></div>\n\nmutate 함수 자체가 기억화(memoized)되어 있습니다. 이론상으로는, 의존성에 전달하는 것만으로 충분할 것 같아요:\n\n```js\n// 반환된 객체에서 mutate 추출하기\nconst { mutate: deleteCountry } = useMutation(...);\n\n// 의존성으로 전달하기\nconst onDelete = useCallback(\n  (name: string) => {\n    // 여기서 바로 사용\n    deleteCountry(name);\n  },\n  // 안녕, memoized 의존성\n  [deleteCountry],\n);\n```\n\n위 단계를 거치면, 우리의 수동 메모화가 최종적으로 작동합니다.\n\n이제 이 단계를 거치면, 이론상으로 모든 수동 메모화를 제거하고 mutate 수정만 남기면, React 컴파일러가 이를 인식할 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n정말 그렇죠! 이제 텍스트를 입력할 때 테이블 행과 셀이 더 이상 다시 렌더링되지 않네요 🎉\n\n<img src=\"https://miro.medium.com/v2/resize:fit:800/0*6EAVCBR4lWCY3mQE.gif\" />\n\n하지만 \"추가\" 및 \"삭제\"를 할 때 재렌더링이 여전히 발생합니다. 이 부분도 수정해봐요.\n\n## \"추가\" 및 \"삭제\" 재렌더링 조사하기\n\n<div class=\"content-ad\"></div>\n\n테이블 태그는 다음과 같이 Markdown 형식으로 변경해보겠습니다.\n\n\n| TableBody |\n| --- |\n| {countries?.map(({ name }, index) => ( |\n|   | <TableRow key={index}> |\n|   |   <TableCell className=\"font-medium\"> |\n|   |     <Link href={`/country/${name.toLowerCase()}`}> |\n|   |       {name} |\n|   |     </Link> |\n|   |   </TableCell> |\n|   |   <TableCell className=\"text-right\"> |\n|   |     <Button |\n|   |       onClick={() => onDelete(name)} |\n|   |       variant=\"outline\"|\n|   |     > |\n|   |       Delete |\n|   |     </Button> |\n|   |   </TableCell> |\n|   </TableRow> |\n| ))} |\n\n\n<div class=\"content-ad\"></div>\n\n먼저, \"key\" 속성을 배열의 위치가 아니라 국가와 일치하도록 확인하세요. 인덱스는 사용하지 마세요. 목록의 처음에서 국가를 제거하면 아래의 모든 행의 인덱스가 변경되어 메모이제이션이 강제로 다시 렌더링되게 됩니다. 실제로는 각 국가를 위한 어떤 종류의 ID를 도입해야 할 것입니다. 우리 간소화된 경우에서는 이름을 사용하고 중복 이름을 추가하지 않도록 해야 합니다. 키는 고유해야 합니다.\n\n```js\n{\n  countries?.map(({ name }) => (\n    <TableRow key={name}>...</TableRow>\n  ));\n}\n```\n\n둘째, TableRow를 React.memo로 래핑하세요. 쉽죠.\n\n```js\nconst TableRowMemo = React.memo(TableRow);\n```\n\n<div class=\"content-ad\"></div>\n\nTableRow의 자식 요소를 useMemo로 메모이제이션하세요:\n\n```js\n{\n  countries?.map(({ name }) => (\n    <TableRow key={name}>\n      ... // 여기 안의 모든 것을 useMemo로 메모이제이션해야 합니다\n      with useMemo\n    </TableRow>\n  ));\n}\n```\n\n렌더 함수 내부에 있기 때문에 불가능합니다: 훅은 컴포넌트의 맨 위에서 render 함수 외부에서만 사용할 수 있습니다.\n\n이를 해결하기 위해 TableRow 전체 내용을 컴포넌트로 추출해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst CountryRow = ({ name, onDelete }) => {\n  return (\n    <TableRow>\n      <TableCell className=\"font-medium\">\n        <Link href={`/country/${name.toLowerCase()}`}>\n          {name}\n        </Link>\n      </TableCell>\n      <TableCell className=\"text-right\">\n        <Button\n          onClick={() => onDelete(name)}\n          variant=\"outline\"\n        >\n          Delete\n        </Button>\n      </TableCell>\n    </TableRow>\n  );\n};\n```\n\n다음과 같이 props를 통해 데이터를 전달해주세요:\n\n```js\n<TableBody>\n  {countries?.map(({ name }) => (\n    <CountryRow\n      name={name}\n      onDelete={onDelete}\n      key={name}\n    />\n  ))}\n</TableBody>\n```\n\n그리고 CountryRow를 React.memo로 감싸주세요. onDelete은 이미 메모이제이션되어 있습니다 - 우리가 이미 수정했어요.\n\n\n<div class=\"content-ad\"></div>\n\n매뉴얼 메모이제이션을 구현할 필요가 없었어요. 그 행들을 컴포넌트로 추출하기만 하자마자 컴파일러가 즉시 이를 감지하여 다시 렌더링이 멈춰버렸어요 🎉. 인간 대 기계 전투에서 2 대 0!\n\n재미있게도, 컴파일러는 CountryRow 컴포넌트 내부의 모든 것을 감지할 수 있지만 컴포넌트 자체는 감지하지 못해요. 매뉴얼 메모이제이션을 제거하지만 키와 CountryRow 변경은 유지하면, 셀과 행은 추가/삭제 시 더 이상 다시 렌더링되지 않지만 CountryRow 컴포넌트 자체는 여전히 다시 렌더링돼요.\n\n이 시점에서는 컴파일러로 이 문제를 해결할 아이디어가 부족하고, 이미 충분한 자료가 되었으니 그냥 다시 렌더링하도록 할게요. 내부의 모든 것은 메모이제이션되어 있으니 큰 문제는 아니에요.\n\n# 그럼 판단은 뭘까요?\n\n<div class=\"content-ad\"></div>\n\n컴파일러는 간단한 경우와 구성 요소에서 놀라운 성능을 보여줍니다. 3번 시도 중 3번 모두 맞았어요! 하지만 현실은 조금 더 복잡해요.\n\n제가 시도한 3개 앱 모두에서 컴파일러가 불필요한 다시 렌더링 여부를 판단한 8-10개의 경우 중 1-2개만 고칠 수 있었어요.\n\n하지만 추론력과 짐작으로 결과를 개선할 수 있을 것으로 보이며, 코드를 약간 수정함으로써 가능합니다. 하지만 이를 조사하는 것은 매우 어렵고 창의적인 사고와 React 알고리즘 및 기존 메모이제이션 기술에 대한 숙련이 요구돼요.\n\n컴파일러의 동작을 개선하기 위해 기존 코드를 수정해야 했던 변경 사항:\n\n<div class=\"content-ad\"></div>\n\n- useMutation 훅의 반환 값에서 mutate를 추출하여 코드에 직접 사용하십시오.\n- TableRow 및 내부 모든 것을 분리된 컴포넌트로 추출하십시오.\n- \"key\"를 index에서 name으로 변경하십시오.\n\n코드 변화를 확인하고 앱을 직접 체험해보세요.\n\n제가 조사한 가정에 대해:\n\n그냥 작동합니까? 기술적으로, 네. 그냥 켜놓기만 하면 깨진 것 같지 않습니다. 그러나 React Dev Tools에서 메모이즈된 것처럼 보이지만 모든 것을 올바르게 메모이즈하지는 않습니다.\n\n<div class=\"content-ad\"></div>\n\n컴파일러를 설치한 후 메모, useMemo, useCallback을 잊어버릴 수 있을까요? 절대 그렇지 않아요! 적어도 현재 상태에서는 아닌 것 같아요. 실제로, 지금보다 더 잘 알아야 할 필요성이 있고, 컴파일러에 최적화된 컴포넌트를 작성할 수 있는 감각을 키워나가야 해요. 또는 디버그할 때 다시 렌더링을 고치려는 상황에서 사용할 수 있어요.\n\n물론, 그것들을 고치려는 의지가 있다고 가정하면요. 제 생각에는 이런 일이 벌어질 거예요: 우리 모두가 제품 출시 준비가 완료된 시점에 컴파일러를 켤 거예요. 개발 도구에서 \"memo ✨\"가 보이면 우리는 안심을 느낄 거예요. 그래서 모두 다시 렌더링에 대해 여유롭게 생각하고 기능 구현에 집중할 거예요. 대부분의 다시 렌더링이 성능에 미치는 영향이 무시할 만하다는 점 때문에 아마도 아무도 그저 어려워하지 않을 거예요.\n\n실제로 다시 렌더링이 성능에 영향을 미치는 경우에는 상태를 아래로 내리거나 자식 요소나 props로 전달하거나 데이터를 Context로 추출하거나 분할된 공급자로 이동시키는 합성 기법과 같은 방법을 사용해 쉽게 수정할 수 있게 될 거에요. 그리고 가끔씩은 — 수동으로 React.memo와 useCallback을 사용할 거에요.\n\n미래에서 온 방문자들에 대해서는, 저는 그들이 병렬 우주에서 왔다고 확신해요. React가 유연성이 높은 JavaScript보다 구조화된 언어로 작성되었고, 컴파일러가 그런 이유로 100%의 경우를 해결하는 놀라운 곳이죠.\n\n<div class=\"content-ad\"></div>\n\n원문은 https://www.developerway.com에서 확인하실 수 있어요. 해당 웹사이트에는 이와 유사한 더 많은 기사가 있습니다. 😉\n\nReact 실력을 더 향상시키기 위해 Advanced React 책을 확인해보세요.\n\n다음 기사가 게시되는 즉시 알림을 받으려면 뉴스레터를 구독하거나 LinkedIn에서 연결하거나 Twitter를 팔로우하세요.","ogImage":{"url":"/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_0.png"},"coverImage":"/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_0.png","tag":["Tech"],"readingTime":21},{"title":"의견 SSR 프론트엔드 유닛 테스트의 가치가 없는 이유","description":"","date":"2024-06-22 04:49","slug":"2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt","content":"\n\n## 프로덕션에서 개발자들이 직면하는 문제와 해결 방법 강조\n\n안녕하세요! 제 경력 동안 프론트엔드 개발자로 일하면서 테스트가 우선순위인 프로젝트에 참여한 적이 없다는 사실을 알게 되었습니다. 사실, 테스트가 필수적이지는 않았죠.\n\n일반적인 작업 흐름은 기획, 개발, QA, 소유주 확인, 그리고 릴리스로 진행되곤 했습니다. 결과가 항상 100% 버그 없는 것은 아니었지만, 문제는 개발과 크게 상관이 없는 경우가 많았습니다. 즉, 계획 단계에서 사용자의 요구사항을 사전에 고려하지 않았거나 릴리스 이후에 최종 사용자가 특정 기능에 부정적인 피드백을 준 경우였습니다. 어쨌든, 가장 필요한 것은 최고 속도로 지속적인 배포를 보장하는 것이었습니다.\n\n이런 환경에서 우리의 상황은 아마 다음과 같을 것입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![OpinionSSRFront-EndUnitTestingNotWorthIt](/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_0.png)\n\n# 요약\n\n먼저, 문서에서 나온 프론트엔드 단위 테스트는 쓸모없고, 많은 비용이 들면서 아무것도 알려주지 않는다는 문제를 강조합니다. 그런 다음, 실제로 우리가 생산 중에 직면한 문제들은 우리가 원하는대로 렌더링되지 않거나, 우리가 원하는 방식으로 렌더링되지 않는 것이었습니다. 따라서, 실제 문제에 어떻게 대처할 수 있는 지를 제안하였는데, 그것은 간단한 if문일 것입니다. 마지막에, '나쁜 것'을 개선하는 방법과 제안된 해결책의 '추악한 점'을 개선하는 방법을 논의합니다. 거의 비전적인 개선 사항으로 글을 마무리합니다.\n\n# 면책조항\n\n\n<div class=\"content-ad\"></div>\n\n아래에 있는 내용이 모두 해당되지 않을 수 있지만, FAANG-tier 레거시 프로젝트와 같은 경우 상품 카드가 여러 가지 상태를 가진 프로토타입 디자인 시스템 또는 백엔드가 아닌 프런트엔드에 매우 복잡한 비즈니스 로직을 가진 경우를 제외하고, 저는 꼭 확인하거나 여러분이 아는 프런트엔드 개발자와 공유하길 강력히 권장합니다.\n\n# 문제\n\n솔직히 말해서, useRef()에 대해서는 문서가 꽤 확장되었지만, 이 개념에 완전히 동의합니다. 모든 문서 조각을 보면(특히 React에서), 많은 '하면 안 되는 일'과 충분한 '해야 하는 일'이 없다는 생각이 듭니다. 똑같이 프런트엔드 테스팅 예제에 대해서도 마찬가지입니다. 그들이 보여주는 것은 컴포넌트 렌더링 여부를 확인하는 것뿐인 \"안녕, 세계\" 수준의 테스트일 뿐입니다.\n\n이로 인해 우리는 토론의 핵심으로 도달했습니다. 프런트엔드 앱에서 무엇을 테스트해야 할까요? 더 구체적으로 말하면, SSR Gatsby 웹사이트에서는 무엇을 테스트해야 할까요? 백엔드가 없지만 Storyblok CMS와 Bitbucket의 CI/CD를 가진 경우 빌드가 실패하면 배포가 방지되는 상황에서요.\n\n<div class=\"content-ad\"></div>\n\n기술 슈퍼바이저가 나에게 일반적으로 요구하는 것은 유닛 테스트였어요. 왜냐하면 그것들이 가장 “인기가 많고” “관리하기 쉽다”고 생각하기 때문이에요. 이 아이디어의 핵심은 당신이 개발하고 컴포넌트를 독립적으로 테스트하고, 그것이 정상적으로 작동하고 올바르게 동작하는지 확인하는 것이에요. 하지만 프런트엔드 유닛 테스트는 우리에게 무엇을 보여줄까요? 공식 문서와 몇 가지 관련 기사를 살펴보도록 하죠.\n\n# React에서 테스트에 대해 전문가들은 무엇을 말하나요?\n\n## React 문서 (테스팅 개요 — 테스팅 섹션은 오직 레거시 문서만 포함됨):\n\n- 컴포넌트 트리 렌더링\n- 완전한 앱 렌더링\n\n<div class=\"content-ad\"></div>\n\n## Jest 문서\n\n- 스냅샷 테스트\n- DOM 테스트\n\n## React 테스트 레시피 (이전 문서만)\n\n- 렌더링\n- 데이터 가져오기\n- 모듈 모의\n- 이벤트\n- 타이머\n- 스냅샷 테스트\n\n<div class=\"content-ad\"></div>\n\n요약하면, FreeCodeCamp의 \"리액트에서 유닛 테스트 작성 방법\"이라는 기사는 테스트를 다음과 같은 카테고리로 나누어 내는 뛰어난 일을 해냅니다:\n\n- 컴포넌트가 props와 함께 렌더링되는지 여부\n- 컴포넌트가 상태 변경과 함께 어떻게 렌더링되는지\n- 컴포넌트가 사용자 상호작용에 어떻게 반응하는지\n\n이 시점에서 저는 이 기사를 읽기 전에도 거의 동일한 분류를 구성하고 있었기 때문에 진짜 궁금증이 생겼습니다. 우리는 다음을 확인하려고 노력하고 있기 때문입니다:\n\n- 컴포넌트가 렌더링되는지 여부\n- 컴포넌트가 영향을 받는지 여부\n- 컴포넌트가 상호작용 가능한지 여부\n\n<div class=\"content-ad\"></div>\n\n\n![OpinionSSRFront-EndUnitTestingNotWorthIt_1.png](/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_1.png)\n\n나는 각 시나리오에서 완전히 헷갈려 하고 있다. 어쩌면, 너무 복잡하고 오버로드된 앱들에서는 개발 중에 적어도 하나의 질문에 대답할 수 없을지도 모르지만 나는 localhost에서 이러한 질문 중 어느 하나에도 갇히지 않아서 운이 좋은 편이다. 그래서, 중요한 것에 대답하지 못하는 단위 테스트가 왜 필요한지 묻고 싶다. 내 현재 프로젝트를 살펴보고 무엇을 확인하는 데 유용할지 찾아보자.\n\n# 실제로 생산에서 어떤 문제가 발생하나요?\n\n위에서 언급한 대로, 문서에 실제 시나리오가 있었으면 좋겠지만, 그럴 만한 것이 없다면 웹사이트에서 만난 문제들을 분류해보려 한다.\n\n\n<div class=\"content-ad\"></div>\n\n## 컴포넌트가 필요한 일부 props을 받지 못하고 렌더링됩니다.\n\n- 세부 정보: 예를 들어, 우리가 타이틀 필드를 가진 HeroSection.tsx를 가지고 있으며, 이 컴포넌트에는 수직 여백이 몇 개 있습니다. CMS에서 아무 것도 오지 않아도 프로젝트가 크래시되지 않습니다.\n- 결과: 텍스트 없이 여백이 렌더링됩니다.\n- 영향: 사용자 경험이 나빠지며, 보기 좋지 않습니다.\n\n## 컴포넌트가 필요한 props을 받지 못하고 빌드가 충돌합니다.\n\n- 세부 정보: 상품명과 가격이 있는 항목을 기대하면서, 어떤 확인도 없이 (조건부 체이닝조차 없이!) 단순히 items.map()을 사용합니다.\n- 결과: 빌드가 파이프라인에서 충돌하고, 프로덕션에서 아무 변화도 없습니다.\n- 영향: 나쁜 개발 경험, 기능 배송이 느려집니다.\n\n<div class=\"content-ad\"></div>\n\n에러가 발생하면 \"RENDERED vs. NOT RENDERED\" 범주 내에 해당하는 문제에 직면하게 될 수 있어요. 상태 변경이나 사용자 조작에 응답하지 않는 것을 배포한 적이 없다는 건 저에게는 생각조차 해본 적이 없었어요. 만약 이와 같은 것을 개발하고 QA가 이를 식별하지 못한다면, 아마도 테스트도 도움이 되지 않을 것이고 이 글도 솔직히 도움이 되지 않을 겁니다. 하지만, 아주 복잡한 마이크로 프론트엔드 구성요소가 설계 키트 없이 연결돼 있는 경우...\n\n![2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_2.png](/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_2.png)\n\n# 어떻게 실제 문제에 대처할 수 있을까요?\n\n사람들이 처음으로 제안하는 것은 \"단위 테스트를 작성하세요!\"라고 말하는 것인데, 음... 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n여기에는 \"아니요\"에 대한 몇 가지 층이 있어요:\n\n## 개발 속도가 두 배 이상 느려집니다. 문서의 공식 예제를 한 번 더 살펴보세요.\n\n- 구성요소 8줄 vs 테스트 30줄 Testing Recipes — React\n- 구성요소 24줄 vs 테스트 18줄 Testing React Apps · Jest\n\n## Storyblok 데이터 구조를 모의하는 것이 정말 어려워요.\n\n<div class=\"content-ad\"></div>\n\n- CMS에서 많이 사용되는 richtext입니다. 게다가 Storyblok의 rich text를 역공학하여 성공하더라도 즉시 긴밀하게 결합된 레거시가됩니다. 이 span의 피라미드는 외부에서 업데이트 할 때마다 깨질 수도 있습니다. 또는 다른 방식을 채택한 다른 CMS로 이동할 수도 있습니다.\n- 내부 및 \"중첩\" 루트가 있는 외부의 링크, 일반 URL이 있는 외부의 링크, 2가지 매우 다른 구조를 테스트하기 위해 가장하는 것입니다. 우리가 받는 것을 알 수 없기 때문에.\n- 파일 및 이미지와 같은 에셋. 예를 들어 .svg. 이상적인 항목이지만 .png의 사용량 감소와 테스트의 구식화 문제를 줄이려고 일주일에 한 번 디자인 리뷰를 할 수 있습니다.\n\n## 그리고 가장 중요한 것\n\n하나의 컴포넌트에 \"필요한\" props로 테스트를 통과시키고 props 없이 실패한다는 것은 본질적으로 아무 것도 해결하지 않습니다. 우리는 페이지를위한 템플릿을 개발하기 때문에 가능한 한 재사용 가능해야하며 모든 props을 필수로 만드는 것은 유연성을 깨뜨리게 될 것입니다.\n\n다행히도 \"RENDERED vs. NOT RENDERED\" 이분법에 접근할 \"저렴한\" 방법이 있습니다. 모든 컴포넌트에 \"필수\" props을 검사하는 if 문만 있으면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_3.png)\n\n만약 CMS에서 무언가를 기대하고 있지만 컴포넌트가 전혀 렌더링되지 않길 원한다면, null을 반환하면 됩니다. 이것은 말 그대로 빙산의 일각에 불과합니다.\n\n## if 문장만으로 충분할까요?\n\n이미 반복된 느낌일 수 있지만, 사실 \"아니요\". 이번에는 \"아니지만 충분합니다.\" \n\n\n<div class=\"content-ad\"></div>\n\n그러면 결과에 대해 알아봅시다:\n\n## 장점\n\n- 실제 유닛 테스트보다 \"가장 체\"하고 훨씬 간결합니다.\n- 일부 이상하게 보이는 컴포넌트를 렌더링하지 않습니다. (그리고 CSS 접근 방식에 따라 공백도 표시되지 않을 수도 있습니다.)\n\n## 단점\n\n<div class=\"content-ad\"></div>\n\n- 서투르고 반복적인 부분이 있습니다.\n- 모든 구성 요소가 아닌지 확인할 수 없습니다. (이것에 대해 생각해 보세요!)\n\n## 문제점\n\n- 컴포넌트가 렌더링되지 않을 때, 그것이 괜찮은지 아닌지 말할 기회가 없습니다. 예를 들어, 콘텐츠 작성자가 버튼 레이블을 빠뜨린 경우 컴포넌트가 사라지고 전체적인 모습은 괜찮아 보일 수 있지만 페이지의 일부가 없으며 5개 언어로 번역된 수십 개의 페이지에 대해 사이트 전반적으로 디버깅할 수 없습니다. 하지만, 유닛 테스트에서도 정확히 같은 상황이 발생합니다!\n\n# 문제를 개선하는 방법\n\n<div class=\"content-ad\"></div>\n\n## DRY 원칙 적용\n\nDRY(Don't Repeat Yourself) 원칙부터 적용해보겠습니다. 재사용이 가능하도록 함수를 작성해야 합니다. 함수는 다음과 같은 작업을 수행해야 합니다:\n\n- 우리가 전달하는 속성들이 무엇이고 그 수가 몇 개인지 예측할 수 없으므로 객체 기반으로 일반화되어야 합니다.\n- 각 필드 값에 대해 반복합니다.\n- 이러한 값들이 모두 허용 가능한지 확인합니다. 가능한 데이터 구조를 예측하지 못할 경우 업데이트해야 할 수도 있습니다.\n- 값 중 일부가 “필수” 기준을 충족하지 못하는 경우 false를 반환합니다.\n- 모든 필드/속성이 \"채워져\" 있다면 true를 반환합니다.\n\n제 구현은 아마도 다음과 같을 것입니다:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_4.png\" />\n\n배열 확인을 더 자세히 살펴보세요. 이미지와 Storyblok 유형에 대해서는 if 문을 확장해야 할 필요가 있겠지만, 방향은 명확해야 합니다. 개발 환경에서 컴포넌트 이름을 두 번째 매개변수로 전달하고 부족한 필드 이름을 로깅하여 컴포넌트 이름별로 그룹화하는 방법으로 더 개선할 수 있지만, 지금은 간단하게 유지하는 것을 선호합니다.\n\n이제 우리는 모든 컴포넌트에 쉽고 일관된 if 문을 갖게 됩니다:\n\n<img src=\"/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_5.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n# 만약 팀이 이를 무시한다면?\n\n이를 실제로 사용할 수 있도록 하기 위해, 우리는 마침내 의미있는 테스트가 필요합니다. 나는 jest.spyOn(object, methodName)을 사용하는 것을 제안합니다. 테스트 구현은 필요하지 않지만, 모든 컴포넌트에서 해당 메소드가 호출되었는지 확인해야 합니다.\n\n# UGLY를 개선하는 방법들\n\n모든 것이 올바르게 처리되면, CMS로부터 \"필수\" 필드가 부족한 컴포넌트를 렌더링하지 않는 설정이 있습니다. 하지만 유연성이 필요한 몇몇 컴포넌트와 일반 CMS의 유연성 때문에 이러한 \"필수\" 필드를 누락할 수 있으며 결과적으로 페이지에 컴포넌트가 없을 수 있습니다. 모든 것이 작동하나, 요금제가 없는 요금 페이지는 많은 의미가 없습니다. 특히 수십 개의 페이지와 5개 국가 언어에 대한 로컬라이제이션을 진행하는 다른 부서들이 작업 중인 상황에서는 상황이 더욱 복잡해집니다.\n\n<div class=\"content-ad\"></div>\n\n내가 제안하는 해결책은 뛌륭하진 않지만, 각 구성요소에 대해 if 문과 똑같이 작동합니다. 메커니즘은 다음과 같이 동작합니다:\n\n- onCreatePage() 사이클 동안 Storyblok에서 오는 모든 필드를 확인합니다.\n- 각 필드가 비어 있는지 확인하고 \"filled\" 및 \"empty\" 값으로 결과를 객체에 저장합니다.\n- 페이지 별로 필터링할 수 있는 간단한 디버그 페이지를 만들고 \"all\" 및 \"empty\" 값으로 전환할 수 있는 기능을 추가합니다.\n\n이 메커니즘을 구현하는 것이 너무 복잡하기 때문에 이 디버거의 CLI 버전만 쇼케이스하겠습니다:\n\n![디버거 CLI 버전](/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_6.png)\n\n<div class=\"content-ad\"></div>\n\n이제 내용 작성자들은 무엇이 빠졌는지 명확히 알아보고 그것이 우연히 빠진 것인지 확인할 수 있습니다. 그런 다음 필요하다면 Storyblok에 가서 해당 필드를 수정하면 됩니다.\n\n![이미지](/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_7.png)\n\n결론  \n여기까지 읽어 주셔서 감사합니다! 프론트엔드에 대한 무분별한 유닛 테스트가 좋지 않다는 것을 설득하지는 못했더라도 적어도 SSR 생성 웹사이트의 테스트 접근 방식을 고민해 볼 수 있기를 바랍니다.\n\n다음 단계를 생각해보면 디버거를 자동화해 보고 싶습니다. 최신 빌드 이후 \"비어 있는\" 필드가 되어버린 콘텐츠 변경을 기업의 슬랙 채널에 보고하는 차이 시스템을 설정해야 합니다. 이상적으로는 CMS의 마지막으로 게시된 페이지에 대한 보고서를 생성하여 해당 페이지의 비어 있는 필드를 강조해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n위 내용을 공유하고 다시 게시해주세요. 전면 테스트에 대한 나의 비전통적인 접근에 대한 비평과 토론을 환영합니다. 그리고 절대 잊지 말아 주세요. 당신이 하는 모든 것은 어떤 의미가 있어야 합니다. \"최상의 사례\"를 따르는 것이 허용되지 않습니다. 그것이 전면 응용 프로그램의 단위 테스트인 경우에 특히 그렇습니다.\n\n# 솔직하게 설명하자면 🚀\n\nPlain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 저자를 박수하고 팔로우하는 것을 잊지 마세요! ️👏️️\n- 저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_0.png"},"coverImage":"/assets/img/2024-06-22-OpinionSSRFront-EndUnitTestingNotWorthIt_0.png","tag":["Tech"],"readingTime":9},{"title":"동시성 및 병렬 처리 입문 방법 배우기","description":"","date":"2024-06-22 04:48","slug":"2024-06-22-IntroductiontoConcurrencyandParallelism","content":"\n\n\n![Introduction to Concurrency and Parallelism](/assets/img/2024-06-22-IntroductiontoConcurrencyandParallelism_0.png)\n\n# 소개\n\n소프트웨어 개발자는 동시성과 병렬성을 사용하여 고성능 시스템을 구축할 수 있습니다. 이는 모든 프로그래머가 활용할 수 있는 중요한 도구입니다.\n\n이는 다중 스레딩 및 다중 처리가 설명된 동시성과 병렬성에 관한 이론적인 노트입니다. 이것은...\n","ogImage":{"url":"/assets/img/2024-06-22-IntroductiontoConcurrencyandParallelism_0.png"},"coverImage":"/assets/img/2024-06-22-IntroductiontoConcurrencyandParallelism_0.png","tag":["Tech"],"readingTime":1},{"title":"파이썬으로 선형 회귀 직접 구현하기 기초부터 완성까지","description":"","date":"2024-06-22 04:46","slug":"2024-06-22-LinearRegressionfromScratch","content":"\n\n\n![Linear Regression](/assets/img/2024-06-22-LinearRegressionfromScratch_0.png)\n\n안녕하세요! 가장 간단한 머신 러닝 기술 중 하나인 선형 회귀로 시작합니다. 이 게시물의 수학적 부분은 선형 대수와 미적분의 좋은 이해력이 필요할 것입니다. 이 부분은 다음 시리즈에도 해당될 것이죠. 이는 머신 러닝의 많은 부분을 뒷받침하고 있고, 깊은 이해를 위한 선행 요건입니다. 그렇다면 함께 알아보도록 하죠!\n\n# 단순 선형 회귀\n\n선형 회귀는 여러 점들을 고려하여 최적의 선을 찾는 과제입니다. 최적의 선을 찾는 방법을 알아내기 전에, 이것이 실제로 무엇을 의미하는지를 이해해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n그림 1의 선이 이 선보다 더 데이터에 잘 맞는 것을 직관적으로 알 수 있어요:\n\n![Figure 1](/assets/img/2024-06-22-LinearRegressionfromScratch_1.png)\n\n왜냐하면 그림 1의 점들이 그림 2의 점들보다 선으로부터 더 멀리 떨어져 있어요. 이 직관을 수학적으로 어떻게 형식화할지 알아보도록 할게요. 이렇게 하면 “가장 잘 맞는”이 무엇을 의미하는지 명확하게 정의할 수 있을 거예요.\n\n간단하고 시각화하기 쉽게 하기 위해, 2차원에서 시작할게요. 이 경우 데이터 포인트는 (x, y) 쌍이고 위의 그림처럼 그래프에 표시할 수 있어요. 우리는 데이터를 가장 잘 나타내는 f(x) = kx와 같은 선형 함수를 찾고 싶어해요. 이 모델은 원점을 통과하는 선을 가정해요. 우리는 아직 원점 이외의 교차점의 가능성에 대해 고려하지 않을 거예요.\n\n<div class=\"content-ad\"></div>\n\nn개의 데이터 포인트가 있는 컬렉션이 있다고 가정해 보겠습니다.\n\n![Linear Regression from Scratch 2](/assets/img/2024-06-22-LinearRegressionfromScratch_2.png)\n\n각 x값에 대해 모델을 사용하여 예측된 y값을 얻을 수 있습니다. 이러한 상황은 하나의 독립 변수(x)와 하나의 종속 변수(y)만 있는 단순 선형 회귀로 알려져 있습니다. 예측된 y값과 실제 y값을 구분하기 위해 프라임 기호를 사용할 것입니다. 따라서 특정 x값에 대한 모델의 예측된 y값은 다음과 같은 공식으로 표시됩니다.\n\n![Linear Regression from Scratch 3](/assets/img/2024-06-22-LinearRegressionfromScratch_3.png)\n\n<div class=\"content-ad\"></div>\n\n이제 x 값들을 하나의 벡터에, y 값들을 다른 벡터에 넣어봅시다.\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_4.png)\n\n이를 벡터화(Vectorization)라고 합니다. 데이터 과학 문제에 대한 많은 이점이 있습니다. 여러 개별 값을 벡터로 결합하면 수학 공식이 훨씬 더 간결하고 이해하기 쉬워집니다. 코드에서의 벡터화도 성능을 향상시킵니다. 큰 값 배열에 대해 벡터 산술을 수행하는 것이 각각 하나씩 처리하는 루프를 거쳐 동작하는 것보다 훨씬 빠릅니다. Numpy와 같은 많은 숫자 계산 라이브러리가 빠른 벡터 산술을 위해 설계되었습니다. 벡터화는 또한 GPU와 같은 하드웨어를 사용한 병렬화도 가능하게 합니다. 여러 개의 배열 요소에 동시에 연산을 수행합니다. 한 번 더 언급하자면, 각 연산이 하나씩 차례로 이루어지는 루프를 사용하지 않고는 이것이 불가능할 것입니다.\n\n또한 우리가 예측한 y 값들을 모두 담은 벡터를 생성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-LinearRegressionfromScratch_5.png\" />\n\n<img src=\"/assets/img/2024-06-22-LinearRegressionfromScratch_6.png\" />\n\n최적 적합 선을 찾기 위해서는 y'와 실제 값인 y의 벡터 사이의 거리를 알아야 합니다. 이 두 벡터의 차이를 살펴볼 수 있습니다: y' - y. 그러나 이것은 벡터 자체이며, 모델의 오류를 나타내는 단일 숫자를 원합니다. 우리는 제곱합 오류(SSE)를 사용할 것입니다. SSE는 ||y' - y||²로, 차이 벡터의 제곱 크기와 같습니다. 이것은 \"제곱합\"으로 불립니다. 왜냐하면 y' - y의 제곱된 항목들의 합과 같기 때문입니다:\n\n<img src=\"/assets/img/2024-06-22-LinearRegressionfromScratch_7.png\" />\n\n<div class=\"content-ad\"></div>\n\n왜 ||y’ — y||²을 사용하는지 궁금하다면 단순히 ||y’ — y||만 사용하는 것보다 제곱 크기를 사용하는 게 훨씬 간단하다는 점이 하나의 답일 수 있습니다. ||y’ — y||는 합계 외부에 하나의 추가 제곱근 기호가 있습니다:\n\n\n<img src=\"/assets/img/2024-06-22-LinearRegressionfromScratch_8.png\" />\n\n\n이로 인해 미분을 할 때 공식을 처리하는 것이 훨씬 더 까다로워집니다.\n\n이제 선형 회귀 모델의 오차를 정의했으니, 이를 최소화하는 방법을 찾아야 합니다. SSE에 대한 표현을 확장해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-LinearRegressionfromScratch_9.png)\n\n방정식 1에 따라 y'에 kx를 대입하면,\n\n![이미지](/assets/img/2024-06-22-LinearRegressionfromScratch_10.png)\n\nx와 y를 일정한 값으로 유지할 때 오차를 최소화하는 k의 값을 찾아야 합니다. 이를 위해서는 식 1의 k에 대한 미분값을 0으로 설정하고 해를 구할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n\n![Linear Regression 1](/assets/img/2024-06-22-LinearRegressionfromScratch_11.png)\n\n![Linear Regression 2](/assets/img/2024-06-22-LinearRegressionfromScratch_12.png)\n\n이를 통해 제곱 오차의 합을 최소화하는 k 값을 알 수 있습니다. 이 지식을 바탕으로 SimpleLinearRegressor를 코딩할 수 있습니다. 이것은 단 하나의 인스턴스 변수를 갖게 될 것입니다 — 기울기, k.\n\n```js\nclass SimpleLinearRegressor:\n    \"\"\"단순 선형 회귀를 수행합니다.\"\"\"\n\n    def __init__(self):\n        self.k = None\n```\n\n<div class=\"content-ad\"></div>\n\n```python\ndef predict(self, x):\n    \"\"\"\n    입력값 x 또는 x 값 벡터를 사용하여 예측된 y값을 제공합니다.\n    :param x: 입력 값(들).\n    :return: 예측된 y값(들).\n    \"\"\"\n\n    if self.k is None:\n        raise RegressionModelNotFitError('앗! 모델이 아직 피팅되지 않았어요!')\n\n    return self.k * x\n```\n\n또한 x와 y 벡터를 사용하여 Equation 2를 기반으로 k의 적절한 값을 찾는 fit 메서드가 필요합니다. 이것이 클래스의 본질입니다.\n\n```python\ndef fit(self, x, y):\n    \"\"\"\n    주어진 x 값과 y 값 벡터를 기반으로 모델을 맞춥니다.\n    :param x: x값 벡터.\n    :param y: y값 벡터.\n    :return: 적합된 모델의 제곱 오차 합.\n    \"\"\"\n\n    self.k = x @ y / (x @ x)\n    diff = self.predict(x) - y\n    return diff @ diff\n```\n\n<div class=\"content-ad\"></div>\n\n모델을 테스트하기 위해 데이터를 생성해야 합니다. 범위 내에서 임의의 x 값을 생성하고 선형 모델을 사용하여 해당하는 y 값을 계산한 다음 이 y 값에 가우시안 노이즈를 추가하는 함수를 만들겠습니다.\n\n```js\ndef generate_noisy_data(n_points, slope, x_range, noise_stddev):\n    \"\"\"\n    추가된 가우시안 노이즈를 이용해 선형 관계에 기반한 데이터 점을 생성합니다.\n    :param n_points: 생성할 데이터 점의 수.\n    :param slope: 직선의 기울기.\n    :param x_range: x 값을 추출할 범위.\n    :param noise_stddev: 각 y 값에 추가할 가우시안 노이즈의 표준 편차.\n    :return: x 값과 y 값의 벡터.\n    \"\"\"\n\n    x = np.random.uniform(*x_range, n_points)\n    y = slope * x + np.random.normal(scale=noise_stddev, size=n_points)\n    return x, y\n```\n\nSimpleLinearRegressor가 무작위로 생성된 데이터에서 원래의 기울기를 얼마나 잘 복원하는지 살펴봅시다. 시각화를 위해 matplotlib를 사용하겠습니다.\n\n```js\nx_range = np.array([0, 5])\nx, y = generate_noisy_data(n_points=20, slope=0.42, x_range=x_range, noise_stddev=0.5)\nplt.scatter(x, y)\n\nregressor = SimpleLinearRegressor()\nfit = regressor.fit(x, y)\nslope = regressor.k\nplt.plot(x_range, [0, 2 * x_range[1]], color='red')\nplt.text(3, 0, f'오차: {\"{:.2f}\".format(fit)}\\n예측된 기울기: {\"{:.2f}\".format(slope)}')\nplt.show()\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 한 번의 실행 결과입니다:\n\n![Linear Regression](/assets/img/2024-06-22-LinearRegressionfromScratch_13.png)\n\n보이시다시피, 이 모델은 훌륭한 작업을 합니다! 회귀 모델에 의해 예측된 기울기는 `generate_noisy_data`에 입력된 기울기와 소수점 셋째 자리까지 일치합니다.\n\n# 다중 선형 회귀\n\n<div class=\"content-ad\"></div>\n\n하나의 독립 변수 x와 하나의 종속 변수 y로 선형 회귀를 수행하는 방법을 배웠습니다. 이제 y가 m개의 독립 변수에 의존한다고 가정해 보겠습니다. 따라서 우리는 (m + 1)차원 데이터를 다루게 됩니다. 우리가 가진 데이터가 다음과 같은 n개의 데이터 포인트일 수 있습니다:\n\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_14.png)\n\n\n여기서 x_ij는 i번째 데이터 포인트에서 j번째 독립 변수의 값을 나타냅니다.\n\n데이터를 벡터화하여 정리하는 것은 항상 좋은 첫 번째 단계입니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 이전과 마찬가지로 모든 y 값들을 벡터로 모아낼 수 있어요:\n\n이제는 x 데이터가 두 개의 인덱스를 가지고 있기 때문에 xs에 대해 벡터를 사용하는 것이 더 이상이 아니에요. 대신, 각 행이 하나의 데이터 포인트인 행렬로 모아낼 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n이제부터 이 행렬의 항목을 나타내는 변수로 대문자 X_ij와 소문자 x_ij를 서로 바꿔 사용할 거에요.\n\n지금 데이터에 맞추려고 하는 선형 모델은 조금 더 복잡해 보여요:\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_17.png)\n\n독립 변수 각각에 대한 계수 또는 \"기울기\"인 βs가 있는 m개의 계수가 있어요.\n\n<div class=\"content-ad\"></div>\n\n각 데이터 포인트의 벡터를 만들 수 있어요.\n\n![Vector](/assets/img/2024-06-22-LinearRegressionfromScratch_18.png)\n\n행렬 X는 이러한 벡터를 각각의 행으로 갖고 있다고 생각할 수 있어요.\n\n![Matrix X](/assets/img/2024-06-22-LinearRegressionfromScratch_19.png)\n\n<div class=\"content-ad\"></div>\n\nβ 계수들의 벡터를 만들어보세요.\n\n\nEquation 3은 매우 간결하게 다음과 같이 표현될 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n하지만 각 예측 값 y'_i에 대한 방정식을 모두 예측 값의 벡터로 결합하여보다 간결하게 할 수 있습니다.\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_22.png)\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_23.png)\n\n단순 선형 회귀와 마찬가지로, 우리는 제곱 오차의 합 ||y' - y||²를 최소화하려고 합니다.\n\n<div class=\"content-ad\"></div>\n\n등식 4를 사용하여 SSE 공식을 X, y, 그리고 β를 사용하여 확장할 수 있습니다.\n\n![Equation-24](/assets/img/2024-06-22-LinearRegressionfromScratch_24.png)\n\n익숙하게 느껴지나요? 이는 단순 선형 회귀에서의 오차 공식과 매우 비슷합니다. 우리는 그것을 최소화하는 β의 값을 찾아야 합니다. 먼저 ||y||² 항은 β에 영향을 미치지 않으므로 무시됩니다. 따라서 실제로 최소화해야 할 값은 다음과 같습니다.\n\n![Equation-25](/assets/img/2024-06-22-LinearRegressionfromScratch_25.png)\n\n<div class=\"content-ad\"></div>\n\n우리는 여기서 멈출 수 있습니다. Numpy에는 X와 y만 입력으로 사용하여 β의 적절한 값을 찾을 수 있는 numpy.linalg.lstsq 메서드가 있습니다. 기술적으로는 Python과 Numpy만 사용해야 한다는 내 규칙을 위반하는 것은 아니지만, 이것은 \"처음부터 선형 회귀\"에 대한 포스트에서 속임수 같아 보입니다. 대신, 수학적인 부분으로 들어가겠습니다.\n\nExpression 2를 최소화하기 위해 그래디언트를 β에 대해 제로로 설정하고 해결해야 합니다. 이를 위해 Expression 2를 구성별 형식으로 변환한 다음, β의 각 구성 요소에 대해 개별적으로 미분을 수행할 것입니다.\n\n점곱의 구성별 공식을 사용하여,\n\n<div class=\"content-ad\"></div>\n\n행렬-벡터 곱셈의 경우,\n\n![matrix-vector multiplication](/assets/img/2024-06-22-LinearRegressionfromScratch_27.png)\n\n식 2를 요소별 형태로 변환할 수 있습니다:\n\n![componentwise form](/assets/img/2024-06-22-LinearRegressionfromScratch_28.png)\n\n<div class=\"content-ad\"></div>\n\n이제 특정  β_l  컴포넌트에 대한 식 3의 미분을 취해 봅시다:\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_30.png)\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_31.png)\n\n<div class=\"content-ad\"></div>\n\n식 4를 단순화하려면 두 합의 미분을 취해야 합니다:\n\n![식1](/assets/img/2024-06-22-LinearRegressionfromScratch_32.png)\n\n그리고\n\n![식2](/assets/img/2024-06-22-LinearRegressionfromScratch_33.png)\n\n<div class=\"content-ad\"></div>\n\n각각을 개별적으로 다루어 봅시다.\n\n식 5 미분\n\n식 5는 다음과 같이 확장할 수 있습니다:\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_34.png)\n\n<div class=\"content-ad\"></div>\n\n위의 내용을 번역해 드리겠습니다.\n\n영어로 된 내용은 \"j나 k 둘 중 하나가 l과 같지 않은 부분, 그리고 k는 l과 같지만 j는 아닌 부분, 그리고 j가 l과 같지만 k는 아닌 부분, 그리고 j와 k가 모두 l과 같은 부분\"을 뜻합니다. j와 k 둘 다 l과 같거나 같지 않아야 하기 때문에, 이 네 항목은 모든 가능성을 포함합니다. 이 모든 부분이 결합하여 Expression 5의 원래 합계와 동일합니다.\n\nExpression 7의 두 가운데 항목은 인덱스 변수의 이름이 다를 뿐 동일합니다 (j vs k). 이름이 임의적이므로 우리는 세 번째 합에 있는 인덱스 변수의 이름을 j로 변경할 수 있으며, 따라서 두 항목은 같은 값을 갖습니다. 따라서 식은 다음과 같이 다시 쓸 수 있습니다.\n\n<img src=\"/assets/img/2024-06-22-LinearRegressionfromScratch_35.png\" />\n\n이제 미분을 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_36.png)\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_37.png)\n\n첫 번째 항이 베타_l을 포함하지 않기 때문에 0이 됩니다.\n\n식 6 미분\n\n\n<div class=\"content-ad\"></div>\n\n식 6의 도함수를 찾는 것은 훨씬 간단합니다:\n\n![](/assets/img/2024-06-22-LinearRegressionfromScratch_38.png)\n\n![](/assets/img/2024-06-22-LinearRegressionfromScratch_39)\n\n여기에서 두 번째 합계를 다시 β_l을 포함하는 부분과 β_l을 포함하지 않는 부분으로 분할하였습니다. 후자는 미분 중에 0으로 만들어집니다.\n\n<div class=\"content-ad\"></div>\n\n모든 것을 합해 봅시다\n\n이제 방금 발견한 미분식, Expression 8과 9를 식 4에 대입하고 간단히 정리해 보겠습니다. 그런 다음, 구성 요소 형식에서 벡터 형식으로 다시 변환할 수 있습니다.\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_40.png)\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_41.png)\n\n<div class=\"content-ad\"></div>\n\n이 시점에서 우리는 다음 항등식을 사용할 수 있습니다.\n\n\n![식1](/assets/img/2024-06-22-LinearRegressionfromScratch_42.png)\n\n\n이를 통해 방정식 5를 더 변형할 수 있습니다.\n\n\n![식2](/assets/img/2024-06-22-LinearRegressionfromScratch_43.png)\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-LinearRegressionfromScratch_44.png\" />\n\n그러면 끝났어요! 에러의 기울기가 영인 경우 β는 반드시 방정식 6을 따라야 합니다.\n\n기울기를 영으로 설정하면 실제로 최적의 해결책을 보장하는지 궁금할 수 있습니다. 결국, 이는 단지 전역 최소값이 아닌 지역 최소값을 찾을 수도 있습니다. 다행히 선형 회귀는 볼록 최적화 문제입니다. 이 수학 스택 익스체인지 답변에서 증명이 제공됩니다. 볼록 최적화 문제의 중요한 특성 중 하나는 어떤 지역 최소값도 전역 최소값이 될 수 있다는 것이기 때문에 걱정할 것이 없습니다.\n\n솔루션이 올바름을 확인했으므로, 이제 방정식 6을 β에 대해 해결해야 합니다. Numpy에는 numpy.linalg.solve 함수가 제공되지만, 이 방정식이 하나의 솔루션만 있는 경우에만 작동합니다. 다른 옵션으로는 행렬을 축소된 행 사다리꼴 형태로 변환하는 것이 있지만, 놀랍게도 Numpy에는 이를 위한 유틸리티가 없습니다. 일부 조사를 한 결과, numpy.linalg.qr이라는 것을 발견했는데, 이 함수는 입력 행렬의 QR 분해를 수행합니다. 수학 스택 익스체인지의 답변 및 그 댓글이 방정식 풀이에 QR 분해를 사용하는 방법을 배우는 데 도움이 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 A가 정사각 행렬이고(X^TX도 정사각이어야 함), 선형 방정식 Ax = b를 해결하려면 먼저 직교하는 정사각 행렬 Q와 상삼각 행렬 R을 찾아야 합니다. 여기서 QR = A가 성립합니다. Ax = b 방정식은 QRx = b로 변환됩니다. Q가 역행렬이어야 하므로 방정식은 Rx = Q^-1b로 더욱 단순화될 수 있습니다. R은 상삼각 행렬이고, 오른쪽 부분은 단순히 벡터이므로 Uv = w를 해결할 수 있는 능력이 있으면 충분합니다.\n\n저는 작업 수행을 위해 solve_upper_triangular 함수를 만들었습니다. 선형 방정식을 해결하는 방법에 대해서는 자세히 설명하지 않겠습니다. 단순히 행의 마지막에서 시작하여 역방향으로 작업하며, 각 행에서 이전에 설정된 변수 값들을 대체하고, 남은 변수 중 계수가 0이 아닌 변수에 대해 하나를 제외한 모든 변수에 값을 1로 할당하고, 다른 변수들에 대한 마지막 변수를 나머지 변수들을 이용하여 구합니다.\n\n```js\ndef solve_upper_triangular(a, b):\n    \"\"\"\n    선형 방정식 ax = b를 x에 대해 해결합니다.\n    :param a: 크기가 n x n인 상삼각 행렬.\n    :param b: n 차원 벡터.\n    :return: ax = b를 만족하는 x 벡터.\n    \"\"\"\n\n    tracker = np.zeros(a.shape[1])\n    result = np.zeros(a.shape[1])\n\n    for row, val in zip(a[::-1], b[::-1]):\n        unset_var_indices = np.where((tracker == 0) & (row != 0))[0]\n\n        if len(unset_var_indices) == 0:\n            if np.isclose(result @ row, val):\n                continue\n            else:\n                raise UnsolvableError('주어진 a와 b 값으로 인해 해결할 수 없는 방정식입니다.')\n\n        tracker[unset_var_indices] = 1\n        result[unset_var_indices[1:]] = 1\n        i = unset_var_indices[0]\n        result[i] = (val - result @ row) / row[i]\n\n    return result\n```\n\n이제 MultipleLinearRegressor를 생성할 준비가 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass MultipleLinearRegressor:\n    \"\"\"다중 선형 회귀를 수행합니다.\"\"\"\n\n    def __init__(self):\n        self.beta = None\n```\n\n단순 선형 회귀와 마찬가지로 predict 메서드와 fit 메서드를 갖게 될 것입니다.\n\npredict 메서드는 간단히 행렬 X 또는 벡터 x와 β 사이의 행렬 곱을 계산합니다.\n\n```js\ndef predict(self, x):\n    \"\"\"\n    주어진 x값 배열로부터 예측된 y값을 제공합니다.\n    :param x: x값의 벡터 또는 행렬.\n    :return: 예측된 y값의 벡터.\n    \"\"\"\n\n    if self.beta is None:\n        raise RegressionModelNotFitError('앗! 모델이 적합되지 않았습니다!')\n\n    return x @ self.beta\n```\n\n<div class=\"content-ad\"></div>\n\nfit 메소드는 방정식 6을 해결하기 위해 X^TX를 QR 분해한 다음 solve_upper_triangular을 사용하여 Rβ = Q^-1X^Ty의 해를 찾습니다. 또한 적합한 모델의 제곱 오차의 합을 반환합니다.\n\n```js\ndef fit(self, x, y):\n    \"\"\"\n    x-값 행렬과 해당 y-값 벡터를 기반으로 모델을 적합합니다.\n    :param x: x-값 행렬.\n    :param y: y-값 벡터.\n    :return: 적합된 모델의 제곱 오차의 합.\n    \"\"\"\n\n    x_t = x.transpose()\n    q, r = np.linalg.qr(x_t @ x)\n    vec = np.linalg.inv(q) @ x_t @ y\n    self.beta = solve_upper_triangular(r, vec)\n    diff = self.predict(x) - y\n    return diff @ diff\n```\n\n다중 선형 회귀기의 성능을 살펴봅시다. 이전과 매우 유사한 generate_noisy_data 함수를 만들겠습니다. 이 함수는 매개변수 벡터 β를 받아들이고 X 행렬과 데이터 포인트의 y-값 벡터를 생성한 다음 이전과 같이 각 y-값에 가우시안 노이즈를 추가합니다.\n\n```js\ndef generate_noisy_data(n_data_points, n_independent_variables, beta, x_range, noise_stddev):\n    \"\"\"\n    가우시안 노이즈가 추가된 선형 관계를 기반으로 데이터 포인트를 생성합니다.\n    :param n_data_points: 생성할 데이터 포인트 수.\n    :param n_independent_variables: 각 데이터 포인트에서의 독립 변수 수.\n    :param beta: 독립 변수의 계수 벡터.\n    :param x_range: x-값을 추출할 범위.\n    :param noise_stddev: 각 y-값에 추가할 가우시안 노이즈의 표준 편차.\n    :return: x-값 행렬과 y-값 벡터.\n    \"\"\"\n\n    x = np.random.uniform(*x_range, (n_data_points, n_independent_variables))\n    y = x @ beta + np.random.normal(scale=noise_stddev, size=n_data_points)\n    return x, y\n```  \n\n<div class=\"content-ad\"></div>\n\n이제 데이터를 생성하고 회귀자가 원래 β를 얼마나 잘 복원하는지 살펴보는 시간입니다.\n\n```js\nregressor = MultipleLinearRegressor()\nx, y = generate_noisy_data(n_data_points=500,\n                           n_independent_variables=10,\n                           beta=np.array([-10, 5, -8, -2, 1, -3, 4, -5, -1, 3]),\n                           x_range=np.array([-100, 100]),\n                           noise_stddev=50)\nsse = regressor.fit(x, y)\nprint(f'Sum Squared Error: {sse}')\nprint(f'Beta: {regressor.beta}')\n```\n\n한 번 실행한 결과는 다음과 같습니다.\n\n```js\nSum Squared Error: 1259196.6403705715\nBeta: [-9.95436533  5.02469925 -7.95431319 -1.97266714  1.03726794 -2.95935233\n  4.03854255 -4.98106051 -1.01840914  3.0410695]\n```\n\n<div class=\"content-ad\"></div>\n\n위에서 확인할 수 있듯이, 원래 매개변수 값에 꽤 가까운 결과를 얻는 데 잘 작동하는 것 같습니다.\n\n## 편향(bias)에 대하여\n\n지금까지 y절편이 0인 회귀 모델에 대해만 논의했습니다. 그러나 이는 모든 데이터에 적합한 것은 아닙니다. 만약 x⋅β + b와 같은 모델인 f(x) = x⋅β + b를 원한다면 어떻게 해야 할까요? 여기서 b는 0이 아닌 상수입니다. 기계 학습의 맥락에서 이 값 b를 편향(bias)이라고 부르며, 모든 모델 입력이 0일 때에도 데이터를 특정 값으로 '편향'시킨다는 의미입니다.\n\n이러한 고려 사항은 회귀 모델에 편향을 추가하는 데 많은 노력이 필요하지 않다는 것으로 추가 사항으로 남겨두었습니다: 회귀 모델에 편향을 추가하는 것은 데이터에 항상 1로 설정된 추가 독립 변수를 추가하는 것과 동일합니다. 예를 들어, 우리가 2차원 데이터를 가지고 있고 회귀자에 편향을 추가하려는 경우, f(x) = kx 형태의 모델을 적합시키는 대신에\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_45.png)\n\n변수 x_1은 원본 데이터를 나타내고, x_2는 모든 데이터 포인트에서 1로 설정됩니다. 데이터 포인트 (x, y)는 이렇게 (x_1, x_2, y) = (x, 1, y)가 됩니다. x_1 = x이고 x_2 = 1을 대입하면, 방정식 7은 다음과 같이 단순화됩니다.\n\n![image](/assets/img/2024-06-22-LinearRegressionfromScratch_46.png)\n\n여기서 β_1은 기울기이고, β_2는 바이어스입니다. 우리는 다중 선형 회귀를 사용하여 이 모델을 적합시킬 수 있습니다. 고차원 데이터의 경우, 이 과정은 비슷하게 작동합니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n여기서 한 가지! 이것이 바로 처음부터 선형 회귀입니다. 즐겁게 즐겼고 무언가를 배웠으면 좋겠어요. 어떤 피드백과 건설적인 비평도 환영합니다. 다음 포스트에서는 선형 분류에 대해 다룰 예정이니 기대해주세요.\n\n모든 코드는 github에서 확인하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-LinearRegressionfromScratch_0.png"},"coverImage":"/assets/img/2024-06-22-LinearRegressionfromScratch_0.png","tag":["Tech"],"readingTime":16},{"title":"2024년에 AI 배우는 로드맵","description":"","date":"2024-06-22 04:41","slug":"2024-06-22-RoadmaptoLearnAIin2024","content":"\n\n## AI를 배우고 싶나요?\n\n![AI 학습 로드맵](/assets/img/2024-06-22-RoadmaptoLearnAIin2024_0.png)\n\nAI를 배우고 싶지만 어떻게 시작해야 할지 모르시나요?\n\n저는 2020년에 무료 데이터 과학, 기계 학습 및 AI MOOC의 베스트 20을 작성했어요. 하지만 많은 강의를 듣는 것이 답은 아니라는 것을 깨달았죠.\n\n<div class=\"content-ad\"></div>\n\n튜토리얼 지옥을 벗어나서 진짜로 배우려면 손을 더럽히고, 알고리즘을 제로부터 짜고, 논문들을 구현하며, AI를 활용하여 재미있는 부수 프로젝트를 해결하는 게 중요해요.\n\n본 문서는 이 철학을 따르는 무료 커리큘럼을 작성하려고 노력했어요. 저는 이 중 일부 강좌를 진행하고 있는데요, 함께 공부하고 싶다면 트위터나 링크드인을 통해 연락해주세요!\n\n그리고 이 내용에 빠진 부분이 있다고 생각되면 댓글을 남겨주세요!\n\n하지만 먼저, 커리큘럼에 대한 몇 가지 주의사항과 학습 팁을 전해드릴게요.\n\n<div class=\"content-ad\"></div>\n\n# Top-down 방식\n\n이 교육과정은 top-down 방식을 따릅니다 — 코드를 먼저 작성하고 이론을 나중에 다룹니다.\n\n저는 필요에 의해 배우는 것을 좋아합니다. 그래서, 무언가를 해결해야 하거나 프로토 타입을 만들어야 할 때, 필요한 정보를 넓고 넒게 찾아서 해당 정보를 공부하고 이해한 후에 행동으로 옮깁니다.\n\n예를 들어, 저는 기본 수준에서 LLMs를 이해하는 AI 엔지니어가 되고 싶습니다. 이를 위해서는 transformer를 처음부터 코딩하고 GPU에서 LLMs를 세밀하게 튜닝하는 기술이 필요합니다. 지금은 그것을 할 수 없습니다. 왜냐하면 제 지식에는 여전히 빈틈이 있기 때문에 그 빈틈을 채우고자 하는 목표가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 NLP에 중점을 둔 것입니다. 컴퓨터 비전이나 강화 학습과 같은 다른 AI 전문화를 찾고 계신 경우, 아래에 댓글을 남기거나 Twitter 또는 Linkedin에서 DM으로 연락해주세요. 추천 몇 가지를 전해 드릴게요.\n\n링크를 많이 던지기 전에 제가 무언가를 배우기 시작하기 전에 중요한 두 가지를 알았더라면 좋았을 텐데요.\n\n# 공개로 배우세요\n\n배워야 할 것이 많고, 특히 AI에서는 매주 새로운 혁명적인 논문과 아이디어들이 나오기 때문에 학습이 끝나지 않을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n가장 큰 실수는 혼자서 배우는 것입니다. 그렇게 하면 자신에게 어떤 기회도 만들지 못합니다. 완료했다고 말할 수 있는 것을 제외하고는 보여줄 것이 없습니다. 더 중요한 것은 정보를 어떻게 활용하여 공유할지, 그 정보에서 어떤 혁신적인 아이디어와 해결책이 나왔는지입니다.\n\n그러니까, 공개적으로 배워야 합니다.\n\n종합하자면, 만드는 습관을 가져야 합니다.\n\n이것은 다음을 의미할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 블로그와 튜토리얼 작성\n- 해커톤 참여 및 다른 사람들과 협업\n- 디스코드 커뮤니티에서 질문하고 대답하기\n- 열정적으로 하는 사이드 프로젝트에 참여\n- 새롭게 발견한 흥미로운 것에 대해 트윗하기\n\n그리고 트위터에 대해 이야기할 때,\n\n# 트위터 사용하기\n\n적절한 사람을 팔로우하고 올바르게 활용한다면, 오늘날 누구나 함께 있어야 할 가치가 가장 높은 소셜 플랫폼입니다.\n\n<div class=\"content-ad\"></div>\n\n누구를 팔로우해야 하는지 궁금하다면 Suhail이 제작한 이 AI 목록을 확인해보세요.\n\nTwitter를 어떻게 사용해야 할지 궁금하다면 Near의 \"Twitter 성공 가이드\"를 읽어보세요.\n\nTwitter에서 사람들에게 다이렉트 메시지를 보내려면 진실하고 간결하며 구체적인 요청을 하는 게 중요해요. Sriram Krishnan의 \"차가운 이메일 작성 방법\" 가이드도 DM에 적용할 수 있어요.\n\n트윗하는 법이 알고 싶다면, Instructor의 창시자 Jason이 작성한 \"트윗의 구성 요소\"를 읽어보세요. 그는 0명에서 단 몇 달 사이에 14,000명의 팔로워를 얻었답니다.\n\n<div class=\"content-ad\"></div>\n\n만약 이 문구를 읽고 계시다면, 트위터로 저를 팔로우해 주세요!\n\n무엇을 하고 있는지 메시지를 보내주세요! 멋진 프로젝트에 함께 참여하는 것을 항상 기대하고 있습니다.\n\n이제 시작해 봅시다.\n\n## 목차\n\n<div class=\"content-ad\"></div>\n\n- 수학\n- 도구\n   - Python\n   - PyTorch\n- 머신 러닝\n   - 처음부터 작성\n   - 경쟁\n   - 사이드 프로젝트 수행\n   - 배포\n   - 부가적인 활동\n- 딥러닝\n   - Fast.ai\n   - 더 많은 경쟁 참여\n   - 논문 구현\n   - 컴퓨터 비전\n   - NLP\n- 대규모 언어 모델\n   - Neural Networks: Zero to Hero 시청\n   - 무료 LLM 부트캠프\n   - LLM으로 빌드\n   - 해커톤 참여\n   - 논문 읽기\n   - 처음부터 Transformers 작성\n   - 일부 좋은 블로그\n   - Umar Jamil 시청\n   - 오픈소스 모델 실행 방법 익히기\n   - 프롬프트 엔지니어링\n   - LLM 세밀 조정\n   - RAG\n- 최신 정보 유지 방법\n- 유용한 다른 커리큘럼/리스트들 \n\n# 수학\n\n<div>\n   <img src=\"/assets/img/2024-06-22-RoadmaptoLearnAIin2024_1.png\" />\n</div>\n\n머신 러닝은 선형 대수, 미적분, 확률, 통계의 세 가지 수학 기초를 중시합니다. 각각이 알고리즘이 효과적으로 동작하도록 하는데 중요한 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n- 선형 대수학: 데이터의 표현과 조작을 위한 수학적 도구로, 행렬과 벡터가 알고리즘이 정보를 해석하고 처리하는 언어를 형성합니다.\n- 미적분학: 기계 학습에서 최적화를 위한 엔진으로, 알고리즘이 그래디언트와 변화율을 이해하여 학습하고 개선할 수 있도록 합니다.\n- 확률과 통계: 불확실성 하에서의 의사 결정을 위한 기초로, 알고리즘이 결과를 예측하고 무작위성과 변동성 모델을 통해 데이터에서 학습할 수 있도록 합니다.\n\n이는 프로그래머 관점에서 수학에 대한 멋진 시리즈입니다: Weights & Biases의 수학을 통한 기계 학습(코드)\n\n선형 대수학에 대한 코드 중심 접근 방식을 원한다면, fast.ai 창시자들에 의한 Computational Linear Algebra(비디오, 코드)를 참고하세요.\n\n파이썬을 활용한 응용 기계 학습을 위한 선형 대수학 소개서를 함께 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n만약 전통적인 것을 더 선호한다면, 잉글랜드의 임페리얼 칼리지의 강의인 선형대수학 및 다변수 미적분을 참고해보세요.\n\n3Blue1Brown의 Essence of Linear Algebra 및 Essence of Calculus를 시청해보세요.\n\n통계학에 대한 기본 개념을 알고 싶다면 StatQuest의 Statistics Fundamentals를 시청해보세요.\n\n보충 자료\n\n<div class=\"content-ad\"></div>\n\n- 책: 수학 머신러닝을 위한\r\n- 논문: 딥러닝에 필요한 행렬 미적분\n\n# 도구\n\n![도구 이미지](/assets/img/2024-06-22-RoadmaptoLearnAIin2024_2.png)\n\n## Python\n\n<div class=\"content-ad\"></div>\n\n초보자분들은 여기서 시작하세요: Practical Python Programming.\n\n이미 Python에 익숙하신 분은 Advanced Python Mastery를 선택해보세요.\n\n두 강의 모두 David Beazley가 집필한 Python Cookbook의 저자로 유명한 강의입니다.\n\n이후에는 James Powell의 강연 몇 개를 보세요.\n\n<div class=\"content-ad\"></div>\n\n파이썬 디자인 패턴을 읽어보세요.\n\n추가 정보\n\n- 책: 유창한 파이썬, 2판 (코드)\n- 팔로우할 팟캐스트: Real Python 및 Talk Python\n\n## PyTorch\n\n<div class=\"content-ad\"></div>\n\n알라딘 페르손의 파이토치 튜토리얼을 시청해보세요\n\n파이토치 웹사이트는 정말 멋진 곳이에요.\n\n- 파이토치 예제\n- 공식 파이토치 튜토리얼\n- FAQ 페이지\n\n퍼즐로 지식을 테스트해보세요\n\n<div class=\"content-ad\"></div>\n\n- srush/Tensor-Puzzles: 퍼즐을 해결하세요. PyTorch 실력을 향상시키세요\n\n부가 정보\n\n- 책: 딥러닝을 위한 PyTorch 프로그래밍\n\n# 기계 학습\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-RoadmaptoLearnAIin2024_3.png)\n\n100페이지짜리 머신 러닝 책을 읽어보세요.\n\n## 처음부터 써보기\n\n읽으면서 알고리즘을 처음부터 짜보세요.\n\n\n<div class=\"content-ad\"></div>\n\n아래의 저장소들을 살펴보세요\n\n- eriklindernoren/ML-From-Scratch\n- JeremyNixon/oracle\n- trekhleb/homemade-machine-learning\n\n도전하고 싶다면, 이 코스를 따라가며 PyTorch를 제작해보세요.\n\n- MiniTorch: 머신러닝 엔지니어링 DIY 코스 (동영상, 코드)\n\n<div class=\"content-ad\"></div>\n\n## 경쟁\n\n학습한 내용을 경쟁에서 실습해 보세요.\n\n- Bitgrit 및 Kaggle과 같은 플랫폼에서 ML 경쟁에 참여하세요. 이 기사에서 더 많은 정보를 확인할 수 있습니다.\n- 지난 우승 솔루션을 살펴보고 연구하세요\n\n## 사이드 프로젝트 만들기\n\n<div class=\"content-ad\"></div>\n\n위키 보이키가 쓴 글 'Getting machine learning to production' 을 읽어보세요.\n\n그녀는 또한 책을 위한 의미론적 검색인 Viberary를 만들면서 배운 것에 대해 썼습니다.\n\n데이터셋을 구하고 모델을 만드세요 (즉, NASA 지구 데이터를 얻기 위해 earthaccess를 사용하세요).\n\nStreamlit으로 UI를 만들어 Twitter에 공유하세요.\n\n<div class=\"content-ad\"></div>\n\n## 배포하세요\n\n모델을 제품으로 출시하세요. 실험을 추적하세요. 모델을 어떻게 모니터링하는지 배우세요. 데이터 및 모델 드리프트를 직접 경험해보세요.\n\n다음은 일부 훌륭한 자원입니다\n\n- Made With ML\n- DataTalksClub/mlops-zoomcamp: 무료 MLOps 강의\n- chiphuyen/machine-learning-systems-design\n- Evidently AI — ML 시스템 디자인: 300개의 사례 연구\n- stas00/ml-engineering: 머신러닝 엔지니어링 온라인 서적\n\n<div class=\"content-ad\"></div>\n\n## 부가정보\n\n- PyTorch와 Scikit-Learn을 사용한 기계학습 (코드)\n- [1811.12808] 기계학습에서의 모델 평가, 모델 선택 및 알고리즘 선택\n- 머신러닝 면접서 · MLIB\n\n# 딥러닝\n\n![AI 학습을 위한 지도](/assets/img/2024-06-22-RoadmaptoLearnAIin2024_4.png)\n\n<div class=\"content-ad\"></div>\n\n위에서 아래로 내려오는 방식이 좋다면, fast.ai부터 시작해보세요.\n\n## Fast.ai\n\n- fast.ai (파트1, 파트2) + W&B 스터디 그룹\n\nfast.ai를 좋아하셨나요? Full Stack Deep Learning도 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n더 포괄적이고 전통적인 강의를 찾고 계시다면, François Fleuret의 UNIGE 14x050 - 딥 러닝을 확인해보세요.\n\n이론을 필요로 할 때는 이런 책들이 좋습니다.\n\n- Dive into Deep Learning (PyTorch, NumPy/MXNet, JAX, TensorFlow 코드 예시 포함)\n- Ian Goodfellow, Yoshua Bengio, Aaron Courville의 Deep Learning\n- Neural networks and deep learning\n- Understanding Deep Learning (실습 노트북과 함께)\n\n트위터를 스크롤하는 대신 핸드폰에서 The Little Book of Deep Learning을 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n신경망이 수렴되는 동안 이를 읽어보세요.\n\n- 신경망 훈련을 위한 레시피\n- 심층 신경망: 33년 전과 33년 후\n\n### 더 많은 경연에 참여하세요\n\n- PlantTraits2024 — FGVC11 | Kaggle (컴퓨터 비전)\n\n<div class=\"content-ad\"></div>\n\n## 논문 구현\n\nlabml.ai Annotated PyTorch Paper Implementations을 확인해보세요.\n\nPapers with Code는 훌륭한 자료입니다. 그들의 웹사이트에서 BERT가 설명되어 있습니다.\n\n아래는 딥러닝 내 특화된 자원들입니다.\n\n<div class=\"content-ad\"></div>\n\n## 컴퓨터 비전\n\n많은 사람들이 CS231n: 딥 러닝을 위한 컴퓨터 비전을 추천합니다. 도전적이지만 극복한다면 가치가 있어요.\n\n## 강화학습\n\n강화학습에 대해 이 두 가지가 좋아요:\n\n<div class=\"content-ad\"></div>\n\n- OpenAI에서 제공하는 Deep RL 시작하기\n- 🤗 Hugging Face의 Deep Reinforcement Learning Course\n\n## 자연어 처리\n\n다른 훌륭한 Stanford 강의, CS 224N | 딥러닝을 활용한 자연어 처리\n\nHugging Face NLP Course를 배워보세요\n\n<div class=\"content-ad\"></div>\n\n이 멋진 NLP 항목들을 확인해보세요.\n\n좋은 기사와 설명들\n\n- BERT 연구 - Ep. 1 - 주요 개념 및 소스 · Chris McCormick\n- The Illustrated Word2vec - Jay Alammar\n- The Illustrated BERT, ELMo, 등 (NLP가 전이 학습을 해결한 방법)\n- LSTM 네트워크 이해 - colah의 블로그\n- PyTorch RNN Scratch 구현 - Jake Tae\n\n부가적인 정보\n\n<div class=\"content-ad\"></div>\n\n- Natural Language Processing with Transformers Book\n\n# Large Language Models\n\n![Image](/assets/img/2024-06-22-RoadmaptoLearnAIin2024_5.png)\n\nFirst, watch [1hr Talk] Intro to Large Language Models by Andrej.\n\n<div class=\"content-ad\"></div>\n\n그 다음 Alexander Rush의 '5가지 공식으로 큰 언어 모델'을 알아보세요 — Cornell Tech\n\n## 신경망 시청: 제로부터 히어로로\n\n0부터 역전파를 설명하고 코딩한 다음, 제로에서 GPT를 직접 작성하는 방법까지 알려줍니다.\n\nAndrzej Karpathy의 '신경망: 제로에서 히어로로'\n\n<div class=\"content-ad\"></div>\n\n그는 방금 새 비디오를 공개했어요 → GPT 토크나이저 만들기에 도전해보세요\n\n그리고 Jay Mody의 'NumPy로 GPT를 60줄로 살펴보기'도 함께 확인해보세요.\n\n## 무료 LLM 부트캠프\n\nFull Stack Deep Learning에서 무료로 제공된 유료 LLM 부트캠프를 소개합니다.\n\n<div class=\"content-ad\"></div>\n\n이 프로그램은 즉시 엔지니어링, LLMOps, LLM을 위한 UX, 그리고 1시간 안에 LLM 앱을 출시하는 방법을 가르칩니다.\n\n부트 캠프를 마치고 나서 무언가를 만들고 싶어질 것입니다.\n\n## LLM과 함께 빌드하기\n\nLLM과 함께 앱을 만들고 싶나요?\n\n<div class=\"content-ad\"></div>\n\n거대한 언어 모델을 활용한 애플리케이션 개발\nAndrew Ng 저\n\nHuyen Chip의 제작용 LLM 애플리케이션 빌딩 읽기\n\n또한 Eugene Yan의 LLM 기반 시스템 및 제품을 구축하기 위한 패턴\n\n레시피를 위해 OpenAI Cookbook을 참조하세요.\n\n<div class=\"content-ad\"></div>\n\nVercel AI 템플릿을 사용하여 시작해보세요.\n\n## 해커톤 참여\n\nlablab.ai는 매주 새로운 AI 해커톤을 개최합니다. 팀을 꾸리고 싶다면 알려주세요!\n\n더 심층적으로 이론에 대해 공부하고 모든 것이 어떻게 작동하는지 이해하고 싶다면:\n\n<div class=\"content-ad\"></div>\n\n## 논문 읽기\n\n세바스찬 라슈카의 대규모 언어 모델 이해에 대한 훌륭한 기사가 있습니다. 그는 읽어야 할 몇 가지 논문을 나열하였습니다.\n\n그는 또한 최근 2024년 1월에 읽어야 할 논문에 대한 다른 기사를 발행했으며, 이 기사는 미스트랄 모델을 다루고 있습니다.\n\n그의 서브스택 Ahead of AI를 팔로우하세요.\n\n<div class=\"content-ad\"></div>\n\n## 제로부터 Transformer 구현하기.\n\n개요를 읽으려면 The Transformer Family Version 2.0 | Lil’Log를 참조해주세요.\n\n가장 편한 형식을 선택하고 제로부터 구현해보세요.\n\n논문\n\n<div class=\"content-ad\"></div>\n\n- 어텐션만 해라\n- 이해할 수 있는 트랜스포머\n- 하버드의 주석 달린 트랜스포머\n- 트랜스포머처럼 생각하기\n\n블로그\n\n- 제로 부터 트랜스포머 만들기 — 첫 번째 파트: 어텐션 메커니즘 (파트 2) (코드)\n- 세바스찬 라쉬카 박사의 대형 언어 모델의 셀프 어텐션 메커니즘을 이해하고 코딩하기\n- 제로 부터 트랜스포머를 만들기\n\n비디오\n\n<div class=\"content-ad\"></div>\n\n- 파이토치로부터 Transformer를 완전히 설명하여 트레이닝 및 추론을 구현하기\n- NLP: BERT와 Transformer를 스크래치에서 구현하기\n\n이제는 전적으로 Transformer를 코딩할 수 있어요. 하지만 더 많은 것이 기다리고 있어요.\n\n이 스탠포드 CS25 — Transformers United 비디오들을 확인해보세요.\n\n## 몇 가지 좋은 블로그들\n\n<div class=\"content-ad\"></div>\n\n- 점근적 하강법으로 미친듯이 — 처음부터 LLM 구축하기\n- 일러스트로 보는 Transformer — Jay Alammar\n- 어텐션과 Transformer에 대한 직관적인 이해 by Eugene Yan\n- GPT 가속화하기 — KV 캐시 | 불패를 향한 발전\n- 자가 어텐션을 넘어서: 작은 언어 모델이 다음 토큰을 예측하는 방법\n- 처음부터 Llama 만들기 (또는 울지 않고 논문 구현하기) | Brian Kitano\n- LoRA 개선하기: 처음부터 Weight-Decomposed Low-Rank Adaptation (DoRA) 구현하기\n\n## Watch Umar Jamil\n\n그의 깊이 있는 훌륭한 비디오를 통해 논문을 설명합니다. 또한 코드도 보여줍니다.\n\n- LoRA: 대규모 언어 모델에 대한 저랭크 적응 — 시각적 설명 + PyTorch 코드로 처음부터\n- Mistral / Mixtral 설명: 슬라이딩 윈도우 어텐션, 희소한 전문가 혼합, 롤링 버퍼\n- 어텐션만으로 충분하다 (Transformer) — 모델 설명(수학 포함), 추론 및 훈련\n- LLaMA 설명: KV-Cache, 로터리 위치 임베딩, RMS Norm, 그룹화된 쿼리 어텐션, SwiGLU\n- 검색 증강 생성 (RAG) 설명: 임베딩, 문장 BERT, 벡터 데이터베이스(HNSW)\n\n<div class=\"content-ad\"></div>\n\nLLM과 관련된 몇 가지 더 링크를 추가했어요. 이 링크들이 모두를 다 소개한 건 아니에요. LLM에 대한 더 포괄적인 실러버스는 LLM 실러버스를 참고해보세요.\n\n## 오픈소스 모델을 실행하는 방법을 배워보세요.\n\nollama를 사용하세요: Llama 2, Mistral, 그리고 다른 대형 언어 모델을 로컬에서 사용해보세요.\n\n최근에 파이썬 및 자바스크립트 라이브러리가 출시되었어요.\n\n<div class=\"content-ad\"></div>\n\n## 프롬프트 엔지니어링\n\n가벼운 톤으로 요청하신 내용을 한국어로 번역해드리겠습니다.\n\n## 프롬프트 엔지니어링\n\n프롬프트 엔지니어링 | Lil’Log 읽기\n\nIse Fulford(OpenAI)와 Andrew Ng에 의한 개발자를 위한 ChatGPT 프롬프트 엔지니어링\n\nDeepLearning.ai에서는 무료로 수강할 수 있는 다른 짧은 강의도 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## LLM 세밀 조정\n\n허깅페이스 세밀 조정 가이드를 읽어보세요.\n\n좋은 안내서: 세밀 조정 — GenAI 안내서\n\n악소로틀을 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n이 글은 좋아요: Fine-tune a Mistral-7b model with Direct Preference Optimization | Maxime Labonne가 쓴 글\n\n## RAG\n\nAnyscale에서 좋은 글: Production을 위한 RAG 기반 LLM 애플리케이션 구축\n\nAman Chadha가 작성한 검색 증강 생성에 대한 포괄적인 개요\n\n<div class=\"content-ad\"></div>\n\n# 최신 정보를 얻는 방법\n\n뉴스레터 + 팟캐스트 + 트위터의 조합\n\n논문을 위해서는 AK(@_akhaliq)를 팔로우할 수 있습니다.\n\n팟캐스트는 Swyx와 Alessio가 진행하는 Latent Space가 최고로 생각됩니다.\n\n<div class=\"content-ad\"></div>\n\n그들의 디스코드에 가입해보세요.\n\n그들은 Smol Talk이라는 뉴스레터도 운영하고 있어요. 이 뉴스레터는 모든 주요 AI 디스코드를 요약합니다.\n\n내가 좋아하는 다른 뉴스레터들은:\n\n- The Batch | DeepLearning.AI | AI News & Insights\n- Deep Learning Weekly\n- Interconnects | Nathan Lambert\n- AI Tidbits | Sahar Mor\n\n<div class=\"content-ad\"></div>\n\n이 기사에 더 많은 내용이 있습니다.\n\n# 유용할 수 있는 다른 커리큘럼/목록.\n\n내 목록은 철저한 것이 아니었지만, 여전히 더 찾고 싶다면 몇 가지가 있습니다.\n\n- openai/syllabus.md\n- AI Canon | Andreessen Horowitz\n- AI Learning Curation — LLM Utils\n- Threshold to the AI Multiverse | Open DeepLearning\n- louisfb01/start-llms: 2023년 LLM 스킬을 개선하기 위한 완벽한 가이드\n\n<div class=\"content-ad\"></div>\n\n이제 충분한 시간을 들여서 쓰고 정리를 했으니, 이제는 많은 것을 얻을 차례입니다. 배우고 무언가를 만들어 봐요.\n\n이것이 당신의 인공지능 여정에 도움이 되기를 바래요!\n\n만약 여기까지 읽었다면, 꼭 연락하거나 댓글을 남겨주세요 :)\n\n새로운 소식을 받기 위해 bitgrit 데이터 과학 게시물을 팔로우하는 것을 잊지 마세요!\n\n<div class=\"content-ad\"></div>\n\n최신 데이터 과학과 인공 지능 분야의 최신 소식을 다른 데이터 과학자들과 함께 논의하고 싶으신가요? 우리의 디스코드 서버에 참여해보세요!\n\n워크숍 및 다가오는 대회 소식을 받아보려면 Bitgrit를 팔로우해주세요!\n\n디스코드 | 웹사이트 | 트위터 | 링크드인 | 인스타그램 | 페이스북 | 유튜브","ogImage":{"url":"/assets/img/2024-06-22-RoadmaptoLearnAIin2024_0.png"},"coverImage":"/assets/img/2024-06-22-RoadmaptoLearnAIin2024_0.png","tag":["Tech"],"readingTime":12}],"page":"18","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}