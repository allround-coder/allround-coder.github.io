{"pageProps":{"posts":[{"title":"나를 위한 개인 웹 페이지 만드는 방법","description":"","date":"2024-05-17 03:33","slug":"2024-05-17-CreateAPersonalWebPageForMe","content":"\n\n웹 페이지를 자랑하는 데 도움이 되는 간단한 코드를 제공했습니다. 코드에 여러 기능을 추가하여 나만의 것을 만들어보세요. 이 코드는 단순한 구조일 뿐입니다. \"John Doe\"를 위한 웹 페이지를 만들어봅시다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>YOUR_NAME - YOUR_ROLE</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 0;\n            background-color: #f4f4f4;\n            color: #333;\n        }\n        header {\n            background-color: #4CAF50;\n            color: white;\n            padding: 1em 0;\n            text-align: center;\n        }\n        nav {\n            display: flex;\n            justify-content: center;\n            background-color: #333;\n        }\n        nav a {\n            color: white;\n            padding: 1em;\n            text-decoration: none;\n            text-align: center;\n        }\n        nav a:hover {\n            background-color: #575757;\n        }\n        .container {\n            padding: 2em;\n            max-width: 800px;\n            margin: auto;\n        }\n        footer {\n            text-align: center;\n            padding: 1em 0;\n            background-color: #333;\n            color: white;\n        }\n    </style>\n</head>\n<body>\n    <header>\n        <h1>YOUR_NAME</h1>\n        <p>YOUR_ROLE</p>\n    </header>\n    <nav>\n        <a href=\"#about\">About Me</a>\n        <a href=\"#portfolio\">Portfolio</a>\n        <a href=\"#contact\">Contact</a>\n        <a href=\"#blog\">Blog</a>\n    </nav>\n    <div class=\"container\">\n        <section id=\"about\">\n            <h2>About Me</h2>\n            <p>Hello! I'm YOUR_NAME, YOUR_DESCRIPTION.</p>\n        </section>\n        <section id=\"portfolio\">\n            <h2>Portfolio</h2>\n            <p>Here are some of my recent projects:</p>\n            <ul>\n                <li><strong>Project 1:</strong> Description of project 1.</li>\n                <li><strong>Project 2:</strong> Description of project 2.</li>\n                <li><strong>Project 3:</strong> Description of project 3.</li>\n            </ul>\n        </section>\n        <section id=\"contact\">\n            <h2>Contact</h2>\n            <p>You can reach me at:</p>\n            <ul>\n                <li>Email: YOUR_EMAIL</li>\n                <li>LinkedIn: <a href=\"YOUR_LINKEDIN_PROFILE\" target=\"_blank\">YOUR_LINKEDIN_PROFILE</a></li>\n                <li>Twitter: <a href=\"YOUR_TWITTER_PROFILE\" target=\"_blank\">@YOUR_TWITTER_HANDLE</a></li>\n            </ul>\n        </section>\n        <section id=\"blog\">\n            <h2>Blog</h2>\n            <p>Welcome to my blog! Here, I share my thoughts on software development, technology trends, and much more. Stay tuned for updates!</p>\n        </section>\n    </div>\n    <footer>\n        <p>&copy; 2024 YOUR_NAME</p>\n    </footer>\n</body>\n</html>\n```\n\n플레이스홀더 정보(예: \"John Doe\", \"Software Developer\", 연락처 정보)를 실제 정보로 바꿔주세요. 이 템플릿은 자신의 정보로 About Me 섹션, 포트폴리오, 연락처 정보, 블로그 섹션을 포함하고 깔끔하고 전문적인 디자인을 위해 간단한 CSS로 스타일링된 것입니다. 필요에 맞게 내용과 스타일을 조정해주세요.","ogImage":{"url":"/assets/img/2024-05-17-CreateAPersonalWebPageForMe_0.png"},"coverImage":"/assets/img/2024-05-17-CreateAPersonalWebPageForMe_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 애플리케이션과 Net Web API를 Auth0로 안전하게 보호하기","description":"","date":"2024-05-17 03:31","slug":"2024-05-17-SecureanAngularapplicationandNetWebAPIwithAuth0","content":"\n\n<img src=\"/assets/img/2024-05-17-SecureanAngularapplicationandNetWebAPIwithAuth0_0.png\" />\n\n이 튜토리얼에서는 Angular 애플리케이션에 로그인 시스템을 추가하고 .Net Web API를 Auth0로 보호하는 방법을 배워보겠습니다.\n\n먼저 무료 Auth0 계정을 생성하고 설정할 것입니다. 그 후 .Net 7 Web API를 생성하고 보호된 엔드포인트를 설정할 것입니다. 그런 다음 Angular 애플리케이션을 생성하고 JWT 베어러를 사용하여 Web API를 호출할 수 있는 로그인 시스템을 추가할 것입니다.\n\n보안에 대해 잘 모르더라도, Auth0를 사용하면 보안 서비스를 처음부터 만들 필요 없이 응용 프로그램에 인증/권한 부여를 추가할 수 있는 좋은 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n# Auth0\n\n## Auth0 계정 생성\n\nhttps://auth0.com으로 이동하여 무료로 가입하고 계정을 설정하세요.\n\n## Auth0 싱글 페이지 애플리케이션 구성\n\n<div class=\"content-ad\"></div>\n\n왼쪽 메뉴에서 Applications > Applications로 이동하여 Default App을 선택하십시오. 설정 탭으로 이동하여 이름을 변경하십시오. 또한 새 응용 프로그램을 만들 수 있습니다.\n\n설정에서 Angular 앱과 통신할 때 사용할 응용 프로그램 도메인, 클라이언트 ID 및 클라이언트 비밀번호를 확인할 수 있습니다.\n\n앱 속성 아래로 스크롤하면 Application Type을 Single Page Application으로 변경할 수 있습니다.\n\nApplication URIs 섹션에서 Allowed Callback, Logout URLs 및 Allowed Web Origins에 URL http://localhost:4200/을 제공하십시오.\n\n<div class=\"content-ad\"></div>\n\nhttp://localhost:4200/은 우리 Angular 애플리케이션의 로컬 URL이 되겠습니다.\n\n# .Net 7 웹 API를 생성하고 보안 설정하기\n\n## 새 .Net Web API 프로젝트 만들기\n\nVisual Studio를 열고 ASP.NET Core Web API 프로젝트 템플릿에서 새 프로젝트를 만드세요. .Net 6 프레임워크를 선택하세요. 이 튜토리얼에서는 이 템플릿에서 생성된 WeatherForcastController를 사용할 것입니다. 이 컨트롤러에는 사용 예제에서 사용할 HTTP Get 엔드포인트가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트를 생성한 후 프로그램을 실행하고 https://localhost:7202/weatherforecast (포트 번호가 다를 수 있습니다)으로 JSON 형식의 WeatherForecast 목록이 반환되는지 확인해주세요.\n\n## 교차 도메인 요청 허용\n\n우리의 Angular 애플리케이션에서 모든 HTTP 요청을 허용해야 합니다. Program.cs 또는 Startup.cs 파일을 열어주세요.\n\nbuilder.Services를 services로 바꿔주세요. 그리고 var builder = WebApplication.CreateBuilder(args); 다음에 services 변수를 만들어주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nvar services = builder.Services;Copy\n```\n\n그 후에, CORS 미들웨어를 추가하세요.\n\n```js\napp.UseCors(\"CorsPolicy\");Copy\n```\n\nCORS 정책을 등록하고 http://localhost:4200 출처를 허용하세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nservices.AddCors(options =>\n{\n    options.AddPolicy(\"CorsPolicy\", builder => builder\n    .WithOrigins(\"http://localhost:4200\")\n    .AllowAnyMethod()\n    .AllowAnyHeader()\n    .AllowCredentials());\n});\n```\n\n## Auth0에 API 추가하기\n\nAuth0 계정으로 돌아가서 Applications & APIs로 이동하여 새 API를 생성하세요.\n\nAPI 이름과 식별자 URL(https://localhost:7202/로 포트 번호를 변경)을 입력하세요. RS256 알고리즘을 선택하세요.\n\n\n<div class=\"content-ad\"></div>\n\n## API 엔드포인트 보안하기\n\n이제 우리는 엔드포인트를 보안하고, 인증된 사용자만이 이에 액세스하고 반환된 콘텐츠와 함께 성공적인 HTTP 응답을 받을 수 있도록하려고합니다.\n\n먼저, Get() 메서드에 Microsoft.AspNetCore.Authorization에서 [Authorize] 속성을 추가하십시오.\n\n```csharp\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\n```\n\n<div class=\"content-ad\"></div>\n\n```csharp\nnamespace Auth0WebApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class WeatherForecastController : ControllerBase\n    {\n        private static readonly string[] Summaries = new[]\n        {\n            \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\"\n        };\n        private readonly ILogger<WeatherForecastController> _logger;\n        public WeatherForecastController(ILogger<WeatherForecastController> logger)\n        {\n            _logger = logger;\n        }\n        [HttpGet]\n        [Authorize]\n        public IEnumerable<WeatherForecast> Get()\n        {\n            return Enumerable.Range(1, 5).Select(index => new WeatherForecast\n            {\n                Date = DateTime.Now.AddDays(index),\n                TemperatureC = Random.Shared.Next(-20, 55),\n                Summary = Summaries[Random.Shared.Next(Summaries.Length)]\n            })\n            .ToArray();\n        }\n    }\n}\n```\n\n우리는 ConfigurationManager를 통해 Audience 및 Domain 값을 액세스하고 싶어해요.\n\n따라서 appsettings.json에 Audience와 Domain을 추가해주세요.\n\n```json\n\"Auth0\": {\n  \"Audience\": \"https://localhost:7202/\",\n  \"Domain\": \"auth0tuto.eu.auth0.com\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그러면 \"테이블\" 태그를 Markdown 형식으로 변경해주세요.\n\n\n| 아이템 | 가격 |\n|---|---|\n| 사과 | 1.99 |\n| 바나나 | 0.99 |\n| 수박 | 5.99 |\n\n\n<div class=\"content-ad\"></div>\n\n아래 코드를 추가하여 인증을 구성하십시오.\n\n```js\nservices.AddAuthentication(options =>\n{\n    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n}).AddJwtBearer(options =>\n{\n    options.Authority = $\"https://{auth0.Domain}/\";\n    options.Audience = auth0.Audience;\n});\n```\n\n저희는 인증 토큰을 활용한 JWT 베어러 인증을 사용할 것입니다. 해당 인증은 Authorization HTTP 헤더에서 추출되고 유효성이 검사될 것입니다.\n\n토큰을 유효성 검사하려면, Auth0 애플리케이션에서 구성한 도메인을 지정해야 합니다. 이 정보는 설정에서 찾을 수 있으며, 방금 생성한 Auth0 API의 식별자인 Audience(청중)도 지정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 AuthenticationMiddleware을 추가해 주세요:\n\n```js\napp.UseAuthentication();Copy\n```\n\n프로그램을 다시 실행하면 HTTP ERROR 401 (Unauthorized)를 받게 됩니다.\n\n# Angular 애플리케이션을 만들어 로그인 시스템을 구축하세요\n\n<div class=\"content-ad\"></div>\n\n## Angular CLI 설치\n\n이미 시스템에 Angular이 설치되어 있는 경우, 이 단계를 건너뛰세요.\n\n먼저, Node.js를 다운로드하고 설치해야 합니다 - ` https://nodejs.org/en/download\n\n그런 다음, 명령 프롬프트에 이 명령을 입력하여 Angular CLI를 설치하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install -g @angular/cli\n```\n\n만약 Windows를 사용 중이라면, PowerShell 스크립트 실행을 허용하기 위해 다음 명령을 실행해주세요.\n\n```js\nSet-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned\n```\n\n## Angular 애플리케이션 생성하기\n\n<div class=\"content-ad\"></div>\n\n새로운 Angular 애플리케이션을 생성하려면 ng new CLI 명령어를 실행하세요.\n\n```js\nng new auth0-angular-appCopy\n```\n\n앱에 포함할 기본 기능을 선택하세요.\n\n애플리케이션이 생성되면 ng serve -o를 실행하여 브라우저에서 앱을 실행하고 엽니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nng serve --oCopy\n```\n\n이제 기본 Angular 애플리케이션을 실행하는 것을 확인할 수 있습니다.\n\n## Auth0 SDK 설치\n\n좋아하는 텍스트 편집기나 IDE로 애플리케이션을 열어보세요. 여기서는 VS Code를 사용하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트 디렉토리 내에서 터미널을 열고 Auth0 Angular SDK를 설치하려면 다음 명령을 실행해주세요.\n\n```js\nnpm install @auth0/auth0-angularCopy\n```\n\napp.module.ts를 열어서 AuthModule 패키지를 가져와서 AuthModule.forRoot를 호출하여 imports 목록에 추가해주세요. Auth0 애플리케이션 설정에서 Domain 및 ClientId 값을 복사해주세요.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AuthModule } from '@auth0/auth0-angular'\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    AuthModule.forRoot({\n      domain: 'auth0tuto.eu.auth0.com',\n      clientId: 'aJZmQXUxWhl4arU5ZhN2FJ38YUQgNYbf'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n## 로그인/로그아웃 추가하기\n\napp.component.ts 파일을 열고 AuthService 클래스에 대한 종속성을 생성자에 추가하고 '@auth0/auth0-angular'에서 AuthService를 가져와주세요.\n\n귀하의 코드는 다음과 같아야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\n```\n\n```js\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'auth0-angular-app';\n  constructor(public auth: AuthService) {}\n}\n```\n\n이제 app.component.html 파일을 열어서 배너에 Twitter 버튼 바로 전에 다음 코드를 추가하세요.\n\n```js\n<ng-template #loggedOut>\n  <button class=\"btn-login\" (click)=\"auth.loginWithRedirect()\">\n    로그인\n  </button>\n</ng-template>\n<button class=\"btn-login\" (click)=\"auth.logout()\" *ngIf=\"auth.isAuthenticated$ | async; else loggedOut\">\n  로그아웃\n</button>\n```\n\n<div class=\"content-ad\"></div>\n\nloginWithRedirect() 메소드를 호출하면 사용자가 Auth0 Universal 로그인 페이지로 리디렉션되어 해당 페이지에서 애플리케이션으로 이동하기 전에 로그인 또는 회원 가입을 할 수 있습니다.\n\n그런 다음, 다음 CSS를 `<style></style>` 사이에 추가해주세요.\n\n```js\n.btn-login {\n  border-radius: 4px;\n  border: 1px solid #eee;\n  background-color: #fafafa;\n  color: #333;\n  padding: 10px 25px;\n  text-decoration: none;\n  cursor: pointer;\n}\n```\n\n이제 배너에 로그인 버튼이 표시될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n`div class = \"content\" role = \"main\"`와 `/div` 사이의 모든 것을 삭제하고 다음 코드를 복사하여 붙여넣으십시오.\n\n```js\n<p *ngFor=\"let item of weatherForecasts\">\n  {item.date} |\n  {item.temperatureC} °C |\n  {item.temperatureF} °F |\n  {item.summary}\n</p>\n```\n\n## 회원 가입\n\n로그인 버튼을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n지금은 Auth0 로그인 페이지로 이동되었습니다.\n\n새 계정을 만들려면 가입하세요. 계정을 확인하기 위해 이메일을 받아야 합니다.\n\n이제 Auth0 대시보드로 돌아가서, 왼쪽 메뉴에서 사용자 관리 `사용자`로 이동하여 사용자가 생성되었는지 확인하세요.\n\n## 로그아웃\n\n<div class=\"content-ad\"></div>\n\n가입한 후에는 로그인 버튼이 로그아웃 버튼으로 대체된 것을 볼 수 있습니다.\n\n로그아웃하려면 클릭하십시오.\n\n## 로그인\n\n이제 다시 로그인 버튼을 클릭하여 응용 프로그램에 로그인하십시오.\n\n<div class=\"content-ad\"></div>\n\n사용자 로그인 시스템이 작동되었으니, 이제 보안된 웹 API에 HTTP 호출을 만들어 날씨 예보 목록을 가져와 표시하고 싶어요.\n\n## HTTP 서비스 생성\n\n새 서비스를 만들기 위해 다음 Angular CLI 명령어를 실행해줘.\n\n```js\nng g s weatherforecastCopy\n```\n\n<div class=\"content-ad\"></div>\n\napp.module.ts에 WeatherForecastService와 HttpClientModule를 providers 배열에 추가해주세요. './weatherforecast.service'에서 WeatherForecastService를 import하고, @angular/common/http에서 HttpClientModule를 import해주세요.\n\napi.service.ts를 열어서 constructor에 HttpClient 의존성을 추가하고, @angular/common/http에서 클래스를 import하고 get() 메소드를 생성해주세요.\n\n```typescript\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\nconstructor(private http: HttpClient) {}\n\nget(): Observable<number> {\n  return this.http.get<number>(\"https://localhost:7202/weatherforecast/\");\n}\n```\n\n이 메소드는 우리 Web API의 weatherforecast 엔드포인트로 GET http 호출을 하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n귀하는 다음과 같이 서비스 클래스를 작성하셔야 합니다:\n\n```js\nimport { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n```\n\n```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class WeatherForecastService {\n  constructor(private http: HttpClient) { }\n  get(): Observable<any[]> {\n    return this.http.get<any[]>(\"https://localhost:7202/weatherforecast\");\n  }\n}\n```\n\n## 날씨 예보 표시하기\n\n<div class=\"content-ad\"></div>\n\napp.components.ts로 돌아가서 생성자에 WeatherForecastService 종속성을 추가하고 ./weatherforecast.service에서 해당 클래스를 import하세요.\n\nweatherForecasts 변수를 생성하고 초기화하세요.\n\n```js\nweatherForecast: any[] = [];\n```\n\ngetWeatherForecasts() 메서드를 생성하여 날씨 예보 목록을 로드하세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\ngetWeatherForecasts() {\n  this.weatherForecastService.get().subscribe(data => {\n    this.weatherForecast = data;\n  })\n}\n```\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\nimport { WeatherForecastService } from './weatherforecast.service';\n```\n\n```js\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit{\n  title = 'auth0-angular-app';\n  weatherForecasts: any[] = [];\n  constructor(\n    public auth: AuthService,\n    private weatherForecastService: WeatherForecastService\n  ) {}\n  ngOnInit(): void {\n    this.getWeatherForecasts();\n  }\n  getWeatherForecasts() {\n    this.weatherForecastService.get().subscribe(data => {\n      this.weatherForecasts = data;\n    })\n  }\n}\n```\n\n## Add JWT to the HTTP requests\n\n\n<div class=\"content-ad\"></div>\n\n이전에 언급한 대로, 저희 웹 API는 HTTP 요청의 Authorization 헤더에서 JWT bearer를 디코딩하여 클라이언트의 엔드포인트 접근을 승인합니다.\n\nAuth0 SDK를 사용하면 각 요청에 JWT를 수동으로 추가할 필요가 없습니다. 대신에, 우리를 대신해서 일을 처리해줄 Auth0 HTTP 인터셉터를 사용하겠습니다.\n\napp.module.ts에서 AuthHttpInterceptor와 HTTP_INTERCEPTORS를 다음과 같이 providers 배열에 추가하세요:\n\n```js\nproviders: [\n  WeatherForecastService,\n  { provide: HTTP_INTERCEPTORS, useClass: AuthHttpInterceptor, multi: true },\n],Copy\n```\n\n<div class=\"content-ad\"></div>\n\n@angular/common/http에 HTTP_INTERCEPTORS와 @auth0/auth0-angular에 AuthHttpInterceptor을 추가해주세요.\n\nAuthModule.forRoot()에서 audience와 httpInterceptor를 추가하고, 허용된 API 경로 목록에 API URL을 추가해주세요.\n\n우리의 app.module.ts는 이제 다음과 같이 보입니다:\n\n```js\nimport { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AuthHttpInterceptor, AuthModule } from '@auth0/auth0-angular';\nimport { WeatherForecastService } from './weatherforecast.service';\n```\n\n<div class=\"content-ad\"></div>\n\n\n```js\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    AuthModule.forRoot({\n      domain: 'auth0tuto.eu.auth0.com',\n      clientId: 'aJZmQXUxWhl4arU5ZhN2FJ38YUQgNYbf',\n      audience: 'https://localhost:7202/',\n      httpInterceptor: {\n        allowedList: [ 'https://localhost:7202/*' ],\n      },\n    }),\n  ],\n  providers: [\n    WeatherForecastService,\n    { provide: HTTP_INTERCEPTORS, useClass: AuthHttpInterceptor, multi: true },\n  ],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n# 모두 테스트하기\n\n이제 웹 API를 실행하고 Angular 애플리케이션에 로그인하세요.\n\n이제 페이지에 표시되는 날씨 예보 목록을 볼 수 있어야 합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-SecureanAngularapplicationandNetWebAPIwithAuth0_0.png"},"coverImage":"/assets/img/2024-05-17-SecureanAngularapplicationandNetWebAPIwithAuth0_0.png","tag":["Tech"],"readingTime":13},{"title":"인공지능 기술을 활용한 코드 문서화 및 분석 방법","description":"","date":"2024-05-17 03:30","slug":"2024-05-17-AI-PoweredCodeDocumentationandAnalysis","content":"\n\n<img src=\"/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_0.png\" />\n\n# TL;DR\n\n이 기사에서는 Mimrr을 사용하여 코드에 대한 문서를 생성하는 방법을 배우게 될 것입니다. 또한 다음과 같은 목적으로 Mimrr을 사용하여 코드를 분석하는 방법을 배우게 될 것입니다:\n\n- 버그\n- 유지보수 문제\n- 성능 문제\n- 보안 문제\n- 최적화 문제\n\n<div class=\"content-ad\"></div>\n\nMimrr 코드 문서 및 분석 기능을 활용하면 코드 변경이 정기적으로 발생할 때도 최신 코드 문서를 만들고 유지할 수 있습니다.\n\n그 결과로 코드 문서를 수동으로 작성하고 유지하는 데 소요되는 많은 시간을 절약할 수 있습니다.\n\n# Mimrr 시작하기\n\n이 섹션에서는 Mimrr 계정을 만드는 방법을 배울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n1. 민르(Mimrr)로 이동하고 무료 시작 버튼을 클릭하세요.\n\n![image](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_1.png)\n\n2. 그런 다음 Google, Microsoft 또는 GitHub 계정을 사용하여 민르(Mimrr) 계정을 만드세요.\n\n![image](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_2.png)\n\n<div class=\"content-ad\"></div>\n\n세 번째 단계: 그 다음으로, 조직 이름과 설명을 추가하여 조직을 생성합니다. 그런 다음 아래 그림처럼 '조직 생성' 버튼을 클릭하세요.\n\n![Organization Creation](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_3.png)\n\n그러고 나면 코드 문서를 생성하려는 코드베이스 저장소를 연결하기 위해 Mimrr 대시보드로 리디렉션됩니다.\n\n![Mimrr Dashboard](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_4.png)\n\n<div class=\"content-ad\"></div>\n\n축하합니다! Mimrr 계정을 성공적으로 생성했습니다.\n\n## Mimrr에 코드베이스 저장소 연결하여 코드 문서 생성하기\n\n이 섹션에서는 코드베이스 GitHub 저장소를 Mimrr에 연결하여 해당 문서 및 분석을 생성하는 방법을 배우게 됩니다.\n\n단계 1: 대시보드로 이동하여 \"Mimrr에 코드 연결\" 드롭다운 메뉴를 엽니다. 그런 다음 \"연결\" 버튼을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![AI-Powered Code Documentation and Analysis](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_5.png)\n\nStep 2: Then you will be redirected to choose a repository provider. In this case, I will select GitHub as my code provider.\n\n![AI-Powered Code Documentation and Analysis](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_6.png)\n\nStep 3: Next, go to your Mimrr dashboard and open the projects section to add your codebase repository by clicking the Add Project button. Once your project is added, it should look as shown below.\n\n\n<div class=\"content-ad\"></div>\n\n\nStep 4: 해당 프로젝트를 클릭하여 생성된 문서를 확인하세요.\n\n축하합니다! 이제 코드베이스를 위한 코드 문서를 성공적으로 생성했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 코드 분석 보기\n\n이 섹션에서는 버그, 냄새, 성능, 보안 및 리팩터링 문제를 강조하는 코드 분석 결과를 확인하는 방법을 배울 수 있습니다.\n\n단계 1: Mimrr 대시 보드에서 선택한 프로젝트로 이동하여 분석 섹션을 엽니다. 그러면 코드베이스 건강에 대한 개요가 표시됩니다.\n\n![이미지](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_9.png)\n\n<div class=\"content-ad\"></div>\n\nStep 2: 요약된 섹션 중 하나를 클릭하세요. 그럼 아래와 같이 이슈에 대한 더 많은 세부 정보를 보기 위해 Details 드롭다운 메뉴를 클릭하세요.\n\n![image](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_10.png)\n\nStep 3: 코드 유지 관리 문제를 분석하려면 아래와 같이 드롭다운 메뉴에서 Code Smell을 선택하세요. 그럼 각 유지 관리 문제에 대한 더 많은 세부 정보를 확인할 수 있습니다.\n\n![image](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_11.png)\n\n<div class=\"content-ad\"></div>\n\nStep 4: 코드 성능 문제를 분석하려면 아래에 나와 있는 드롭다운 메뉴에서 Performance를 선택하세요. 그런 다음 각 성능 문제에 대한 더 많은 세부 정보를 확인하세요.\n\n![Performance](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_12.png)\n\nStep 5: 코드 보안 문제를 분석하려면 아래에 나와 있는 드롭다운 메뉴에서 Security를 선택하세요. 그런 다음 각 취약점 문제에 대한 더 많은 세부 정보를 확인하세요.\n\n![Security](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_13.png)\n\n<div class=\"content-ad\"></div>\n\n단계 6: 코드 리팩터링 문제를 분석하려면 아래와 같이 드롭다운 메뉴에서 Refactor를 선택하십시오. 그런 다음 각 유연성 문제에 대한 자세한 내용을 확인하십시오.\n\n<img src=\"/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_14.png\" />\n\n축하합니다! 버그, 냄새, 성능, 보안 및 리팩터링 문제에 대해 성공적으로 분석하셨습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n요약하자면, Mimrr은 코드 문서를 생성하는 및 코드의 문제를 분석하는 프로세스를 자동화하는 데 훌륭한 도구입니다. Mimrr을 사용함으로써 기술 부채 없이 기능을 신속하게 출시할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_0.png"},"coverImage":"/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_0.png","tag":["Tech"],"readingTime":4},{"title":"루비에서  긴 매개변수 목록 리팩터링 하는 방법","description":"","date":"2024-05-17 03:28","slug":"2024-05-17-RefactoringinRubyLongParameterList","content":"\n\n긴 매개변수 목록(Long Parameter List)은 작업을 수행하기 위해 많은 수의 매개변수가 필요한 경우 발생합니다. 일반적으로 두 개 이상의 매개변수를 사용하지 않는 것이 좋습니다.\n\n![image](/assets/img/2024-05-17-RefactoringinRubyLongParameterList_0.png)\n\n루비 언어에 관심이 있다면, 이 언어에서 리팩터링과 디자인 패턴에 대해 더 많이 알아볼 수 있습니다: [RubyHub](https://www.rubyhub.io/). 현재 웹사이트는 개설 중이지만, 미래에 더 다양한 주제가 등장할 것입니다.\n\n# 문제들\n\n<div class=\"content-ad\"></div>\n\n- 가독성 감소 — 긴 매개변수 목록은 메소드 호출 정의를 읽고 이해하기 어렵게 만들 수 있습니다. 특히 매개변수가 잘 명명되지 않았거나 문서화가 충분하지 않은 경우 더욱 그렇습니다.\n- 복잡성 증가 — 많은 매개변수는 종종 메소드나 함수가 너무 많은 작업을 시도하고 단일 책임의 원칙을 위반할 가능성을 나타냅니다.\n- 유지보수 도전 — 긴 매개변수 목록은 코드 유지보수를 어렵게 만듭니다. 메소드의 시그니처를 변경할 때 개발자는 해당 메소드의 모든 호출을 업데이트해야 하므로 오류나 일관성 문제가 발생할 수 있습니다.\n- 순서 의존성 — 긴 매개변수 목록은 올바른 매개변수 순서에 의존할 수 있으며, 매개변수가 잘못 배치되거나 누락된 경우 오류를 발생시킬 수 있습니다.\n- 유연성 제한 — 긴 매개변수 목록에서 매개변수를 추가하거나 제거하는 것은 어려울 수 있는데, 특히 메소드가 코드베이스 전체에서 여러 곳에서 사용되는 경우에 해당됩니다.\n- 테스트 복잡성 — 긴 매개변수 목록을 갖는 메소드를 테스트하는 것은 귀찮을 수 있습니다. 가능한 모든 매개변수 조합을 포함하는 다수의 테스트 케이스를 생성하고 관리해야 합니다.\n\n# 해결책\n\n- 옵션 해시 — 관련된 매개변수를 옵션 해시 매개변수로 통합하세요. 이 접근 방식은 메소드 호출을 더 간결하고 유연하게 만들어줍니다. 매개변수를 추가하거나 제거해도 메소드 시그니처를 변경할 필요가 없도록 합니다. 또한 명명된 매개변수를 제공하여 가독성을 향상시킵니다.\n- 매개변수 객체 — 관련된 매개변수를 하나의 객체로 묶어주세요. 매개변수 객체는 그들의 동작을 캡슐화하여 메소드 시그니처의 복잡성을 줄이고 코드 가독성을 높이는 데 도움이 됩니다.\n- 기본 및 명명된 매개변수 활용 — 기본 매개변수 값과 명명된 매개변수를 활용하여 메소드 호출을 간소화하세요. 기본 값은 매개변수에 논리적인 기본값을 제공하며, 명명된 매개변수는 전달되는 인수를 명시적으로 지정하여 메소드의 명확성을 향상시킵니다.\n- 더 작은 함수로 리팩토링 — 함수에 너무 많은 매개변수가 있다면, 너무 많은 작업을 수행할 수 있습니다. 더 작고 집중된 함수로 함수를 리팩토링하는 것을 고려해 보세요.\n\n# 실제 예제\n\n<div class=\"content-ad\"></div>\n\n루비에서 코드 예제를 살펴보겠습니다. 매개변수 목록이 긴 update_user 메서드가 있고, 이를 옵션 해시 기술을 사용하여 리팩터링할 것입니다.\n\n```js\ndef update_user(id, first_name, last_name, age, address, is_admin)\n  user = User.find(id)\n\n  user.update(\n    first_name: first_name,\n    last_name: last_name,\n    age: age,\n    address: address,\n    is_admin: is_admin\n  )\nend\n\nupdate_user(1, \"John\", \"Doe\", 25, \"Baker Street\", false)\n```\n\n이 리팩터링된 코드에서는 매개변수를 params 해시로 통합했습니다. 이렇게 하면 메서드 호출이 더 가독성 있어지고 매개변수를 유연하게 제공할 수 있습니다. is_admin 매개변수가 제공되지 않으면 기본값이 할당됩니다.\n\n```js\ndef update_user(params = {})\n  user = User.find(params[:id])\n\n  user.update(\n    first_name: params[:first_name],\n    last_name: params[:last_name],\n    age: params[:age],\n    address: params[:address],\n    is_admin: params.fetch(:is_admin, false)\n  )\nend\n\nuser_params = {\n  id: 1,\n  first_name: \"John\",\n  last_name: \"Doe\",\n  age: 25,\n  address: \"Baker Street\"\n}\n\nupdate_user(user_params)\n```\n\n<div class=\"content-ad\"></div>\n\n# 장단점\n\n## 장점\n\n- 향상된 가독성 — 옵션 해시를 사용하면 메소드 호출이 이름있는 매개변수를 제공하여 더 읽기 쉽습니다. 개발자는 각 매개변수가 무엇을 나타내는지 쉽게 이해할 수 있어, 매개변수의 위치에 의존하지 않아도 됩니다.\n- 유연성 — 옵션 해시 접근 방식을 통해 매개변수를 제공하는 데 유연성을 가질 수 있습니다. 매개변수를 추가, 제거 또는 수정하더라도 메소드 서명을 변경하지 않아도 되므로 코드를 변경에 더 적응 가능합니다.\n- 기본 매개변수 값 — 기본 매개변수 값을 메소드 내에서 쉽게 정의할 수 있어, 메서드 호출을 간단하게 만들고 필수 매개변수가 제공되지 않은 경우 합리적인 기본값을 갖게 할 수 있습니다.\n- 인지 부담 감소 — 이름있는 매개변수와 선택적 기본값을 사용함으로써 개발자는 매개변수의 순서나 기본값을 기억할 필요가 없어지며, 인지 부담이 줄어들고 잠재적인 오류를 줄일 수 있습니다.\n- 더 쉬운 유지 보수 — 긴 매개변수 목록을 옵션 해시로 리팩토링함으로써 메소드 서명을 단순화하여 코드를 보다 쉽게 유지보수할 수 있습니다. 개발자들은 많은 매개변수를 관리하는 대신 메소드의 로직에 집중할 수 있습니다.\n\n## 단점\n\n<div class=\"content-ad\"></div>\n\n- 추가 복잡성— 옵션 해시 기법은 메소드 서명을 간소화하지만 메소드 구현 내에서 추가적인 복잡성을 도입합니다. 개발자는 옵션 해시에서 매개변수 추출을 처리해야 하며, 이는 보일러플레이트 코드를 추가할 수 있습니다.\n- 스펠링 오류가 발생할 수 있는 가능성— 옵션 해시는 심볼 키에 의존하기 때문에 매개변수 이름을 철자를 틀리게 쓸 위험이 있습니다. 이는 런타임 오류로 이어질 수 있으며, 디버깅하기 어려운 문제가 발생할 수 있습니다.\n- 덜 엄격한 매개변수 유효성 검사— 누락된 매개변수가 오류를 유발하는 명시적인 매개변수 목록과는 달리, 옵션 해시 접근 방식은 누락된 매개변수가 nil 또는 기본값으로 설정되는 것을 허용합니다. 이러한 유연성은 덜 엄격한 매개변수 유효성 검사를 유발할 수 있으며, 예상치 못한 동작을 초래할 수 있습니다.\n- 기본값의 남발— 기본 매개변수 값은 유연성을 제공하지만, 기본값에 과도하게 의존하면 메소드의 의도가 모호해지고 메소드 구현을 검사하지 않고는 동작을 이해하기 어려워질 수 있습니다.\n\n![이미지](/assets/img/2024-05-17-RefactoringinRubyLongParameterList_1.png)\n\n저는 루비에서 리팩터링에 대한 책을 작업하고 있습니다. 이 주제에 관심이 있으시면, 제 뉴스레터에 가입하실 수 있습니다 📪️: https://mailchi.mp/e3dd49dfada1/medium. 구독자분들은 출판 후 즉시 제 이북 링크를 무료로 받아보실 수 있습니다. 🆓","ogImage":{"url":"/assets/img/2024-05-17-RefactoringinRubyLongParameterList_0.png"},"coverImage":"/assets/img/2024-05-17-RefactoringinRubyLongParameterList_0.png","tag":["Tech"],"readingTime":4},{"title":"웹 프레임워크의 유사발암화","description":"","date":"2024-05-17 03:25","slug":"2024-05-17-Thecarcinizationofwebframeworks","content":"\n\n프레임워크는 수렴 중입니까? 웹 개발 세계에서 발생하는 근본소생현상을 살펴보고, 과거를 향해 미래를 엿볼 수 있을까요?\n\n![이미지](/assets/img/2024-05-17-Thecarcinizationofwebframeworks_0.png)\n\n생물학적 과학에서 암화 변이란 게이물류 중 게 아닌 이놈들이 게처럼 보이는 형태로 진화하는 현상을 말합니다. 현재 웹 개발 세계에서도 비슷한 일이 일어나고 있는 것으로 보입니다. 웹 프레임워크는 마치 암화 변이 과정을 겪고 있는 것 같아요! — 분명히, 프레임워크는 진짜로 발톱이나 외골격을 개발하고 있는 것은 아니고, 대신 개념적으로 유사한 기능 집합으로 수렴해가고 있어서 점점 더 구별하기 어려워지고 있습니다 🦀 🦞\n\n스포일러 경고: 저는 이론적으로 완벽한 프레임워크가 존재한다고 말하고 싶진 않아요. 각 프로젝트는 다르며, 다른 요구 사항은 새로운 솔루션과 도구를 요구합니다. 그러나 대부분의 프레임워크가 결국 채택하게 될 거의 완벽한 기능 세트가 존재할 수 있습니다. 이 기사에서 그것을 엿볼 수도 있을지 모릅니다.\n\n<div class=\"content-ad\"></div>\n\n# 어떻게 변했나요?\n\n오래 전, JavaScript 프레임워크는 서로 완전히 다른 방식으로 작동했습니다. 사실, 이것이 대부분의 경우 그들의 주요 장점이었습니다: \"웹 개발을 새롭고 더 나은, 그러나 대부분은 다른 방식으로 하는 새로운 방법\". jQuery는 브라우저에 유틸리티를 추가하여 개발을 보다 빠르고 크로스 브라우저 친화적으로 만들기 위해 노력했습니다. Angular는 전체 객체지향 프로그래밍(OOP) 스위트를 웹으로 가져와서 확장 가능한 웹 앱을 구축하려고 했습니다. React는 함수형 원칙을 몇 가지 정교한 방법으로 사용하여 개발자가 함수와 합성만을 사용하여 웹 앱을 만들 수 있도록 제안했습니다. 다른 프레임워크들은 새로운 기반 위에 구축되었고, 일부는 단순히 기존 프레임워크를 더 빠르게, 작게 만들거나 서로 다른 아이디어를 결합하여 개선했습니다.\n\n자연스럽게, 일은 진화했습니다... 🧬 어떤 프레임워크는 다른 것보다 더 많은 인기를 얻었습니다. 최고의 아이디어는 새로운 프레임워크뿐만 아니라 기존 프레임워크에도 통합되었습니다. AngularJS는 Angular 2로 중심을 옮겼습니다. 일부 OOP 값들을 제거한 간단한 버전입니다. Vue는 React의 후크를 구현했고, React는 함수를 선호하여 클래스 구성 요소를 버렸습니다. 심지어 한때 급부상한 것으로 여겨졌던 Svelte도 최근에 Runes(신호를 모방하는 것, Solid, toddle 및 Preact에서 볼 수 있음)를 구현했습니다.\n\n그래서, 오늘 우리가 전반적으로 보는 특징들은 무엇일까요?\n\n<div class=\"content-ad\"></div>\n\n# 변경 불가능성 🪨\n\n프로그래머들에게는 다소 논란이되는 주제입니다. 변경 불가능한 데이터 처리는 성능 대 개발자 경험(DX) 사이의 중요한 교역입니다. 간단한 변이마다 전체 객체와 배열을 복제하는 것은 처음에 낭비처럼 보이기 때문에 수년간 많은 사람들이 기본 설정이 아니었습니다. 그러나 변경 불가능성에 헌신함으로써 귀하의 앱은 초기 성능 최적화가 부족할 수도 있지만 버그를 적게 배포하고 개발 주기를 빠르게 할 수 있습니다. 그럼에도 불구하고, 변경 불가능성은 오늘날의 프레임워크에서 중심적인 요소가 되어서 언제 사용하지 않아야 하는지 종종 잊게 됩니다.\n\n많은 프레임워크는 순수한 불변 데이터를 전달하는 것을 요구합니다. 참조를 수정하는 것은 위험하고 예측할 수 없는 부작용을 일으킬 수 있습니다. 그러나 변경 불가능성에서 분리하는 것은 항상 허용됩니다. 프레임워크가 모르는 것은 해칠 수 없습니다:\n\n## 🐢 느리지만 완전히 변경 불가능합니다.\n\n<div class=\"content-ad\"></div>\n\n## 🐇 빠르지만 배열을 직접 변경합니다 😱\n\n두 번째 예시는 훨씬 빠르며, 테스트 케이스를 작성하고 불변 코드를 순수 함수로 캡슐화하기 위해 함수로 래핑하는 한 완벽합니다.\n\n# 데이터의 단방향 흐름 🌊\n\nAngular 팀에 의해 처음 소개된 양방향 데이터 바인딩은 마법 같았습니다 🪄 너무 신비로운 것 같아요! ✨ 자식 구성 요소에서 데이터를 변경하면 부모가 자신을 업데이트하고 남아 있는 모든 자식도 업데이트할 수 있습니다 — 뭐가 안 좋을까요?\n\n<div class=\"content-ad\"></div>\n\n실제 예제에서는 종종 아무도 데이터를 실제로 소유하지 않는 스파게티 코드 🍝로 이어집니다. 진실의 근원이라고 할 수 있는 곳은 어디서나 동시에 존재하고 어디서나 존재하지 않았다. 어떤 것이 작동하지 않을 때 데이터를 손상시킨 사람을 찾을 수 없었습니다.\n\n엄격한 단방향 데이터 흐름으로 데이터가 항상 단일 소유자를 가지도록 보장합니다. 무언가가 망가지면 데이터 흐름을 따라 가면 범인을 찾을 수 있어요 🕵️‍♂️ 이 강제적인 제한은 웹 개발자들을 괴롭히는 많은 문제를 해결했습니다. 하지만, 우리에게 코드를 명확하게 작성하도록 요구합니다. 오늘날 거의 모든 프레임워크는 데이터를 아래로 보내는 이벤트를 올리는 접근 방식을 따릅니다.\n\n# 신호 ⚡\n\n상태 관리는 프레임워크를 확장 가능하게 만드는 데 가장 중요한 개념입니다. 전역 상태 변수를 추가할 때마다, 최소한 이론적으로 존재하는 상태의 복잡성이 두 배로 증가합니다. 앱이 성장함에 따라 상태도 늘어나며, 어느 시점에서든 수십억 개의 가능한 상태에 있을 수 있습니다. 상태의 수가 급격하게 증가하면 앱을 개발하기 거의 불가능해집니다. 앱의 한 부분을 변경할 때 다른 곳에서 적어도 하나의 다른 것이 깨집니다.\n\n<div class=\"content-ad\"></div>\n\n상태 처리의 복잡성과 중요성을 고려할 때, JavaScript 프레임워크 간의 주요 차별 요소 중 하나로 상태 관리가 역사적으로 부상한 것은 놀라울 것이 없습니다. Angular는 수명 동안 여러 상태 시스템을 가졌고, Vue와 Svelte도 마찬가지입니다. React는 여러 시스템을 가졌으며 수천 개의 호환되는 상태 관리 라이브러리가 있습니다. 우리는 양방향 데이터 바인딩에서 옵저버블, 훅으로 이동했으며, 이제 다음으로 큰 열풍: 신호 ⚡\n\n그러나 신호는 최신 유행에 그치지 않을 수 있습니다. 처음에는 신호를 이해하는 것이 까다로울 수 있지만, 놀랍도록 간단하며 코드 몇 줄로 구현할 수 있습니다. 신호는 세밀한 반응성을 지원하며 전역 상태 및 가장 작은 원시 데이터의 업데이트에 사용할 수 있습니다.\n\n신호가 지금까지 너무 인기가 많아서 원래 채택이 제안되었다는 것을 알고 계셨나요? toddle은 세밀한 반응성과 뛰어난 성능을 달성하기 위해 사용자 정의 신호 구현을 활용합니다!\n\n# 서버 측 렌더링 🌐\n\n<div class=\"content-ad\"></div>\n\n여러 해 동안, 프레임워크들은 자신들을 클라이언트 측만을 다루는 라이브러리로 자랑스럽게 소개했습니다. 웹사이트를 렌더링하기 위해 서버 코드를 작성할 필요가 없는 방법이었죠. 더 이상 PHP나 Java가 필요 없이, 간단한 JavaScript로만 작업할 수 있었습니다. 그러나 오늘날, 이러한 작고도 클라이언트 전용 라이브러리들은 전체 생태계로 성장하였고, - 여러분이 짐작했듯이 - 서버 측 렌더링(SSR)을 갖추는 것이 기대됩니다.\n\n우리는 이제 모든 것이 다시 돌아왔다고 말할 수 있을 정도로 전환을 했습니다 🤦 다만, 이제는 종종 클라이언트 측 언어가 서버가 출력하는 내용을 지배하는 경우가 많습니다. 앱을 한 번 작성하고, 서버가 각 페이지의 초기 상태를 흉내내어 순수한 HTML, CSS, JavaScript로 다시 보내줍니다. NextJS와 같은 프레임워크에서는 심지어 서버에서 실행되는 서버 액션도 작성할 수 있습니다!\n\nSSR은 SEO를 더 잘 지원하며 종종 더 빠른 첫 번째 페인트 시간을 제공해 인기를 끌고 있습니다. 요즘에는 SSR이 거의 모든 프로젝트에서 엄격한 요구사항이 되었습니다. Toddle은 또한 완벽한 SSR 지원을 제공하며, 웹페이지를 최적의 SEO를 보장하고 콘텐츠를 가능한 빨리 화면에 표시할 수 있도록 서버에서 복잡한 공식과 API를 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n프레임워크들은 이미 많이 통합되었지만, 아직 혁신할 여지가 있습니다. 저는 대부분의 프레임워크에서 복사, 향상되고 적용될 것으로 예측되는 분야에서 발생하는 흥미로운 개발 동향을 살펴보려고 합니다.\n\n# 재개 가능성\n\n재개 가능성(Resumability)은 서버 측 렌더링의 개선사항입니다. 애플리케이션이 초기 렌더링 프로세스를 처리하는 방법에 대한 진화를 나타내며, 성능과 사용자 경험을 향상시켜줍니다. 예를 들어, React Server Components와 같은 프레임워크들은 스트리밍 기능을 활용하여 컴포넌트를 점진적으로 클라이언트로 전달하여 사용자 경험을 향상시키는 방향을 택하고 있습니다. Qwik은 이 용어를 만들었으며 이미 탁월한 지원을 제공하고 있습니다.\n\n재개 가능성은 미래에 더 중요한 기능으로 부상할 것으로 예상되며, 개발자들은 불가피하게 성능을 최적화하고 애플리케이션의 확장성을 향상시키려는 노력을 하게 될 것입니다. 인터랙티브한 웹 환경에서 애플리케이션을 최적화하기 위한 노력이 더욱 활발해질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 웹 컴포넌트\n\n웹 컴포넌트의 도입은 언제나 코앞에 있는 것으로 보입니다. 아마 영원히 예측일 수도 있지만, 최근에는 Declarative Shadow DOM 및 다른 사용자 정의 요소에 대한 브라우저 지원이 새롭게 추가되었습니다. 웹 컴포넌트는 여러 가지 이유로 환상적입니다. 하나의 프레임워크에서 컴포넌트를 작성한 다음 다른 앱에 문제없이 삽입할 수 있습니다! SolidJS는 1급 시민은 아니지만 웹 컴포넌트를 지원하며, 다른 많은 프레임워크도 일부 지원합니다. toddle에서는 컴포넌트가 웹 컴포넌트 스펙을 직접 상속받아 호환성이 다뿍 있으며 사실 웹 컴포넌트로 만들어집니다. toddle 컴포넌트는 별도 설정 없이 웹 컴포넌트로 내보낼 수 있습니다.\n\n웹 컴포넌트가 주류가 되면, 모든 웹 개발자에게 다양한 개선 사항을 제공합니다:\n\n- 비용 부담 없이 새 프레임워크를 시도하세요! 웹 컴포넌트 하나를 만들고 기존 사이트에 네이티브 요소로 구현할 수 있습니다. 프레임워크를 변경할 때 처음부터 다시 시작할 필요가 없습니다.\n- 조직 내 각 팀이 원하는 프레임워크를 선택할 수 있습니다. 팀 간에 웹 컴포넌트 표준을 통해 통신하고 원활하게 조합할 수 있습니다.\n- 웹 컴포넌트의 상속된 아일랜드 아키텍처는 toddle, solid 또는 Qwik로 만든 더 현대적인 앱으로의 유동적인 이동을 쉽게 만듭니다. 레거시 앱을 천천히 향상시키고 이전 사이트를 대체하며 섬이 퍼질 때마다 컴포넌트를 하나씩 변환할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 덜 혼란스러운 세상 🌎\n\n한동안 새로운 프레임워크가 매주 발표되는 것 같았어요. 아마 아직도 그렇겠지만, 새로운 프레임워크마다 이미 시험된 기본 기능에 수렴하고 있어서 우리가 이미 알고 있는 것과 매우 비슷해요. A 프레임워크를 알고 있다면, 거의 B 프레임워크도 알게 될 거예요. 문법과 일부 기능은 다를 수 있지만, 핵심 개념은 쉽게 적용될 거예요. 이미 React나 Vue를 알고 있다면, Qwik나 toddle도 시도해보세요. 그들을 배우는 것은 참 쉬운 일이에요.\n\n덤으로, 프레임워크들이 수렴함에 따라 W3C 팀에겐 우리 브라우저가 가장 필요로 하는 기능들이 더욱 명백해졌어요. 극도로 인기가 많았던 jQuery의 거의 모든 기능이 현재 이 글을 읽고 있는 브라우저에 기본적으로 내장되어 있어요. 이제는 신호, 선언형 Shadow DOM 등과 같은 기능들도 마찬가지예요. 이러한 변화들은 프레임워크 전체를 다운로드할 필요없이도 프레임워크와 유사한 기능을 활성화할 것이에요. 아마도 마지막 프레임워크는 프레임워크가 아닌, 완전한 바닐라 브라우저 기능들일지도 모르겠네요. 🦀 toddle은 브라우저 능력에 대한 미래지향적 실험을 진행하는 데 흥분하고 있어요. 웹 개발에 참으로 흥미진진한 시기에요!\n\n원문 출처: https://toddle.dev.","ogImage":{"url":"/assets/img/2024-05-17-Thecarcinizationofwebframeworks_0.png"},"coverImage":"/assets/img/2024-05-17-Thecarcinizationofwebframeworks_0.png","tag":["Tech"],"readingTime":7},{"title":"챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법","description":"","date":"2024-05-17 03:23","slug":"2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2","content":"\n\n제1부에서는 수십억 개의 매개변수를 가진 큰 언어 모델에 무료로 액세스하고 활용할 수 있다는 것을 발견했어요. 제처럼 여러분도 하드웨어 한정으로 고민 중이라면, 이 해킹 방법은 하이엔드 GPU나 유료 구독 없이도 Qwen-110B-chat과 같은 대규모 모델과 상호 작용할 수 있는 기쁨을 선사할 거예요.\n\n제2부에서는 지금부터 체험을 더 향상시키기 위해 스트림릿 인터페이스로 동일한 개념을 적용하여 챗봇에 시각적으로 매력적인 스트리밍 효과를 추가할 거예요.\n\n과정을 되짚어보자면, Python, Gradio_client 및 코딩 능력이 필요해요. AI 챗봇을 텍스트 인터페이스를 통해 만드는 데 초점을 맞추었어요:\n\n- 환경 설정: 먼저 가상 환경을 만들고 필요한 패키지(huggingface_hub, gradio-client 및 streamlit)를 설치하세요. PyTorch나 TensorFlow가 필요하지 않으며, 상호 작용은 API를 통해 이루어질 거예요.\n- Hugging Face API 토큰: 사용자는 Hugging Face에 등록하고 모델 추론 API에 액세스하기 위해 API 토큰을 생성해야 해요.\n- 챗봇 코딩: Hugging Face Spaces에서 Gradio의 \"API를 통해 사용\" 기능을 활용하여 이러한 강력한 모델에 Python 코드로 연결하는 방법을 배웠어요. 특히 여러 언어로 상업적 이용을 위한 라이선스가 허용되는 Qwen 시리즈 모델에 초점을 맞췄어요.\n- 스트리밍 효과: 코드 구조를 살펴보면, 모델과 상호 작용할 수 있는 함수를 만드는 방법을 설명했어요. predict() 및 submit() 메서드 중에서 선택하여 스트리밍 효과와 함께 또는 없이 응답을 생성하는 방법을 강조했어요.\n\n<div class=\"content-ad\"></div>\n\n조금 헤매고 있다면 part 1부터 시작하는 것을 제안해요:\n\n## 핵심 코드부터 Streamlit 인터페이스까지\n\n이걸 꼭 말해야 해요: 터미널에서 모든 앱이 정상 작동하지 않으면 그래픽 인터페이스를 시작하지 말아야 해요.\n\n이건 필수 조건이에요! 그래서 Streamlit 인터페이스를 만드는 것이 아주 쉬울 거에요: 이미 이전 파트에서 라이브러리와 상호작용이 어떻게 작동하는지 확인했기 때문이죠.\n\n<div class=\"content-ad\"></div>\n\n모든 것은 이 핵심을 중심으로 움직입니다:\n\n```js\nfrom gradio_client import Client\n\nclient = Client(\"Qwen/Qwen1.5-110B-Chat-demo\")\nresult = client.submit(\n        query='What is Science?',\n        history=[],\n        system=\"You are a helpful assistant.\",\n        api_name=\"/model_chat\"\n)\nprint(result)\n```\n\n그리고 submit() 메소드를 사용하여 스트리밍 객체/반복자를 얻을 수 있다는 것을 알고 있습니다. Streamlit을 사용하면 스트림을 다루기가 훨씬 쉬워집니다. 사실, 애플리케이션은 항상 페이지 위젯을 새로 고치기 때문에 텍스트 애플리케이션에서 사용되는 지루한 알고리즘을 무시할 수 있습니다. 기억하시나요?\n\n```js\n    final = ''\n    for chunk in result:\n        if final == '':\n            final=chunk[1][0][1]\n            print(chunk[1][0][1], end=\"\", flush=True)\n        else:\n            try:\n                print(chunk[1][0][1].replace(final,''), end=\"\", flush=True)\n                final = chunk[1][0][1]\n            except:\n                pass    \n```\n\n<div class=\"content-ad\"></div>\n\nstring.replace()을 사용하여 이미 생성된 것에서 새로운 단어를 빼내는 작업을 했었는데, 더이상 필요하지 않아요.🥳\n\n# Streamlit 앱\n\n습관적인 사람이라... 그래서 내 코드가 다른 프로젝트와 매우 비슷하다는 사실을 발견할 수 있을 거에요. 그런데 괜찮아요! 결국, 템플릿을 적용하고 수정하는 것이 매번 처음부터 시작하는 것보다 쉽고 빠를 수 있거든.\n\n새 파일을 만들어보세요: 제 파일은 st-Qwen1.5–110B-Chat.py라고 해요. 주요 라이브러리를 가져와 세션 상태 전역 변수를 생성하는 것부터 시작해볼까요?\n\n<div class=\"content-ad\"></div>\n\n```python\nimport streamlit as st\nimport time\nimport sys\nfrom gradio_client import Client\n# Internal usage\nimport os\nfrom time import sleep\n\n\nif \"hf_model\" not in st.session_state:\n    st.session_state.hf_model = \"Qwen1.5-110B-Chat\"\n# Initialize chat history\nif \"messages\" not in st.session_state:\n    st.session_state.messages = []\n```\n\n프로그램에서 전역 변수는 공유되어 사용될 수 있습니다. 또한 session_state라고 불리는 이러한 객체들이 streamlit의 매 실행마다 변경되지 않는 것을 필요로합니다.\n\n그리고 2가지 주요 함수를 정의합니다:\n\n```python\n@st.cache_resource\ndef create_client():   \n    yourHFtoken = \"hf_xxxxxxxxxxxxxxxxxxxxxxx\" #여기에 여러분의 HF 토큰을 넣으세요\n    print(f'{st.session_state.hf_model}에 대한 API Gradio 클라이언트를 로딩 중입니다.')\n    client = Client(\"Qwen/Qwen1.5-110B-Chat-demo\", hf_token=yourHFtoken)\n    return client\n\n# 모든 채팅 메시지를 chathistory.txt에 기록하는 함수\ndef writehistory(text):\n    with open('chathistorywen110b.txt', 'a', encoding='utf-8') as f:\n        f.write(text)\n        f.write('\\n')\n    f.close()\n```\n\n<div class=\"content-ad\"></div>\n\n저희는 @st.cache_resource 데코레이터를 사용하고 있습니다. 이는 Qwen1.5-110에 대한 API gradio 클라이언트를 Streamlit이 매 실행마다 로딩하지 않기를 원하기 때문입니다 (이는 분당 1회 이상 발생할 수 있습니다): Gradio 클라이언트 연결이 실행 중에 변경되지 않을 것이기 때문에, 이 리소스를 특별한 메모리에 캐싱하고 있습니다 (@st.cache_resource). 자세한 내용은 여기에서 확인하실 수 있습니다.\n\n## 일부 그래픽 조정\n\n이제 기본 Streamlit 페이지 요소와 챗봇에 사용할 아이콘을 설정할 수 있습니다.\n\n```js\n#아바타\nav_us = '🧑‍💻'  # './man.png'  #\"🦖\"  # \"🧑‍💻\", \"🤖\", \"🦖\"과 같은 단일 이모지입니다. Shortcut은 지원되지 않습니다.\nav_ass = \"🤖\"   #'./robot.png'\n# 기본 모델 설정\n\n### STREAMLIT UI 시작\nst.image('https://github.com/fabiomatricardi/ChatBOTMastery/raw/main/qwen100logo.png', )\nst.markdown(\"### *Streamlit & Gradio_client로 구동됨*\", unsafe_allow_html=True )\nst.markdown('---')\n\nclient = create_client()\n```\n\n<div class=\"content-ad\"></div>\n\n- 채팅 인터페이스에 로컬 이미지를 사용할 수도 있어요 (코드의 주석을 참고하세요!)\n- 마지막으로, create_client()로 클라이언트 연결을 인스턴스화해요.\n\n# 본문 — 채팅 인터페이스\n\nStreamlit은 자신의 위젯에 변경이 발생할 때마다 또는 입력(버튼, 선택기, 라디오 요소 등)으로 사용자 조작이 호출될 때마다 코드를 맨 위부터 다시 실행해요.\n\n그래서 저희는 대화 기록을 맨 위에 먼저 렌더링하기 시작했어요. 여기서는 뭐라도 새롭게 발명한 건 없어요: Streamlit 블로그의 공식 자습서에서 모두 배웠거든요.\n\n<div class=\"content-ad\"></div>\n\n이것은 표준 렌더링입니다. OpenAI API와 호환되는 chat_completion 형식에 모두 적용 가능합니다.\n\n코드로 돌아가서, 우리는 chat_template 메시지들을 표시하고, 메시지 목록을 반복하며 사용자 프롬프트(myprompt)가 제출되기를 기다립니다.\n\n```js\n# 앱 재실행 시 이전 대화 내용을 보여줍니다\nfor message in st.session_state.messages:\n    if message[\"role\"] == \"user\":\n        with st.chat_message(message[\"role\"],avatar=av_us):\n            st.markdown(message[\"content\"])\n    else:\n        with st.chat_message(message[\"role\"],avatar=av_ass):\n            st.markdown(message[\"content\"])\n# 사용자 입력 받기\nif myprompt := st.chat_input(\"인공지능 모델이란 무엇인가요?\"):\n    # 사용자 메시지를 대화 내역에 추가\n    st.session_state.messages.append({\"role\": \"user\", \"content\": myprompt})\n    # 대화 메시지 컨테이너에 사용자 메시지 표시\n    with st.chat_message(\"user\", avatar=av_us):\n        st.markdown(myprompt)\n        usertext = f\"user: {myprompt}\"\n        writehistory(usertext)\n        # 차후 사용을 위해 대화 상대의 응답을 표시\n```\n\n여기에 이상한 writehistory(usertext) 지시문을 추가하고 있는 것을 볼 수 있습니다. 기억하시나요? 처음에 이 함수를 선언했던 거죠? 저는 모든 대화 내용을 로컬 텍스트 파일에 저장하는 버릇이 있어요. 이는 프롬프트를 분석하거나 미래 활용을 위해 자료를 조직화할 때 매우 편리합니다.🙂\n\n<div class=\"content-ad\"></div>\n\n프롬프트에서 제출된 내용을 확인한 후, gradio 클라이언트 인스턴스(client.submit)를 호출하고 스트리밍을 시작합니다 (message_placeholder.markdown(r[1][0][1]+ \"▌\"))\n\n```js\n    # 채팅 메시지 컨테이너에 어시스턴트 응답 표시\n    with st.chat_message(\"assistant\"):\n        message_placeholder = st.empty()\n        full_response = \"\"\n        res  =  client.submit(\n                query=myprompt,\n                history=[],\n                system=\"You are a helpful assistant.\",\n                api_name=\"/model_chat\"\n                )        \n        for r in res:\n            full_response=r[1][0][1]\n            message_placeholder.markdown(r[1][0][1]+ \"▌\")\n\n        message_placeholder.markdown(full_response)\n        asstext = f\"assistant: {full_response}\"\n        writehistory(asstext)       \n        st.session_state.messages.append({\"role\": \"assistant\", \"content\": full_response})\n```\n\n이게 전부에요. full_response는 최종 텍스트가 들어 있는 변수이므로 대화 기록에도 추가하여 표시합니다.\n\n해결했으면 댓글에 알려주세요 👍\n\n<div class=\"content-ad\"></div>\n\n파이썬 파일을 저장한 후 터미널에서 가상 환경을 활성화한 상태에서 다음과 같이 실행하세요.\n\n```js\nstreamlit run .\\st-Qwen1.5-110B-Chat.py\n```\n\n아래처럼 나와야 합니다... 그리고 기본 브라우저가 로컬 URL인 http://localhost:8501로 열리게 됩니다.\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png)\n\n<div class=\"content-ad\"></div>\n\nStreamlit은 로컬 네트워크로의 편리한 라우팅을 제공합니다. 예를 들어, 핸드폰이 동일한 액세스 포인트에 연결되어 있으면 Network URL로 표시된 주소인 http://192.168.2.6:8501을 통해 핸드폰에서도 이 애플리케이션을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_1.png)\n\n# 다른 모델 실행에 대한 참고 사항\n\nGitHub 리포지토리에서도 Streamlit Python 파일을 실행하는 방법을 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- OpenELM 3B\n- Phi-3-mini-Instruct 128k\n- QwenMoE\n\n고객 구성이 변경될 예정입니다 (물론...) 그리고 스트리밍 지침도 변경될 것입니다. 이는 API 엔드포인트가 다른 데이터 유형을 반환하기 때문에 발생합니다. OpenELM 및 Phi-3의 경우 순수한 문자열이 반환되므로 어떠한 사전/튜플 위치에 있는 LLM 응답을 추출할 필요가 없습니다. 여기를 살펴보세요:\n\n그리고 또한 PLEASE, 기억해주세요...\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 모든 복잡성을 다루는 이유는 무엇일까요? 우리는 어떻게 일하는지 배우고, 나만의 AI 비서를 만드는 방법을 알고 싶기 때문입니다. 내가 상상할 수 있는 최고의 목적을 위해 콘텐츠 생성, 학습 자료, 프레젠테이션, 교육 지원 등.\n\n어디에 사용할 건가요?\n\n글이 마음에 드셨으면 좋겣습니다. 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면 다음을 해볼 수 있습니다 :\n\n<div class=\"content-ad\"></div>\n\n- 이 이야기에 대해 많이 박수를 쳐 주세요\n- 기억할 가치가 있는 부분을 강조하십시오 (나중에 찾기 쉽고, 더 나은 기사를 쓰는 데 도움이 될 것입니다)\n- Build Your Own AI를 시작하는 방법을 배우려면, 무료 eBook을 다운로드하세요\n- 내 링크를 사용하여 Medium 멤버십 가입하기 - (무제한 Medium 이야기를 읽으려면 매달 $5)\n- Medium에서 나를 팔로우하기\n- 내 최신 기사 읽기 https://medium.com/@fabio.matricardi\n\n여기 몇 가지 더 흥미로운 읽을거리:\n\n추가 학습 자료\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_3.png)\n\n<div class=\"content-ad\"></div>\n\n이 이야기는 Generative AI Publication에서 발행되었습니다.\n\n최신 AI 이야기를 놓치지 않으려면 Substack, LinkedIn 및 Zeniteq에서 저희와 연락하여 AI의 미래를 함께 창조해보세요!\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_4.png)","ogImage":{"url":"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png"},"coverImage":"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png","tag":["Tech"],"readingTime":9},{"title":"Gemini API를 활용한 간단한 챗봇 개발하는 방법","description":"","date":"2024-05-17 03:21","slug":"2024-05-17-InnovatingwithAIDevelopingasimpleChatbotUsingGeminiAPI","content":"\n\n<img src=\"/assets/img/2024-05-17-InnovatingwithAIDevelopingasimpleChatbotUsingGeminiAPI_0.png\" />\n\n요즘 빠르게 변화하는 세상에서 모두가 빠른 답변을 기대합니다. 그래서 많은 회사들이 챗봇을 사용합니다 - 사람들을 즉시 도와주고 대화할 수 있는 스마트 프로그램입니다. 개발자가 더 똑똑한 챗봇을 만들 수 있도록 도와주는 Gemini API를 사용해 간단한 챗봇을 만들었습니다. 이 블로그 포스트에서 제가 어떻게 챗봇을 만들었는지 단계별로 안내할 거에요. 사용한 도구와 방법도 공유할게요.\n\n이 프로젝트에서는 효율적이고 확장 가능한 웹 애플리케이션을 만드는 데 개발자들 사이에서 인기 있는 두 가지 도구인 Node.js와 Express를 사용하기로 결정했습니다. Node.js는 서버 측에서 JavaScript를 실행하는 강력한 플랫폼을 제공하여 여러 연결을 쉽게 처리할 수 있게 해줍니다. Express는 유연한 Node.js 웹 애플리케이션 프레임워크로, 쉽게 서버 설정을 구축하고 라우트를 관리하며 요청을 처리하고 사용자에게 응답을 보낼 수 있는 도구를 제공했습니다.\n\n챗봇의 핵심 인텔리전스는 Gemini API에서 왔습니다. 이 강력한 API를 통해 챗봇은 사용자의 언어를 처리하고 이해하는 능력을 갖추어 사용자와 의미 있는 대화를 할 수 있게 됩니다. API의 기능을 통해 자연어 이해와 동적 응답 생성과 같은 기능을 구현할 수 있었는데, 이는 사용자를 효과적으로 지원하는 챗봇을 만드는 데 필수적인 요소입니다.\n\n<div class=\"content-ad\"></div>\n\n이제 이를 구현해 보겠습니다. 단계를 나눠서 진행할 텐데, 첫 번째 단계는 다음과 같습니다:\n\n1. API 설정:\n\n저는 Gemini 플랫폼에 등록하고 API 키를 발급받았어요. 이 API 키는 API 기능에 액세스하기 위해 필요한 고유 식별자에요. Gemini API를 챗봇에 통합하기 전에 해당 플랫폼에서 액세스를 설정해야 해요. 이를 위해 애플리케이션이 요청을 인증하는 데 사용할 API 키를 만들어야 해요. 시작하는 방법은 다음과 같아요:\n\n- Gemini API 문서 방문: 먼저 Gemini API 문서 페이지로 이동하세요. 이 웹사이트에는 API가 작동하는 방식과 설정하는 방법에 필요한 모든 정보가 제공돼요.\n- API 키 생성: Gemini API 사이트에 들어가시면, 등록 또는 로그인하는 방법을 따라주세요. 로그인한 후에 API 관리 섹션으로 이동하면 새 API 키를 생성할 수 있는데, 이 키는 Node.js 애플리케이션에서 Gemini API로 요청을 보내는 데 필수적인 요소에요.\n- API 키 보안: API 키를 안전하게 보관해야 해요. 클라이언트 측 코드에서 노출되지 않도록 주의하고, 적절한 보안 수단(환경 변수 또는 비밀 관리 도구)을 사용하지 않고 애플리케이션 코드베이스에 직접 저장하지 말아주세요.\n\n<div class=\"content-ad\"></div>\n\n2. 프로젝트 구조:\n\n- node_modules/: 모든 npm 종속성이 포함되어 있습니다.\n- public/: 클라이언트 측의 CSS 및 JavaScript와 같은 정적 파일이 저장됩니다.\n- css/style.css: 프론트엔드에 대한 사용자 정의 스타일입니다.\n- js/script.js: 프론트엔드 논리를 처리합니다.\n- views/: 특히 사용자 인터페이스용 index.html과 같은 HTML 파일이 포함되어 있습니다.\n- .gitignore: 버전 관리에서 무시할 파일 및 디렉토리가 지정됩니다.\n- config.env: 환경 변수와 API 키를 안전하게 저장합니다.\n- index.js: Express 서버를 구성하고 실행하는 주요 서버 파일입니다.\n- package.json 및 package-lock.json: 프로젝트 종속성을 관리하고 특정 버전에 잠급니다.\n- Readme.md: 프로젝트 설명서 및 설정 지침을 제공합니다.\n\n이 설정은 구조화된 Node.js 및 Express 애플리케이션에 패키지된 Gemini API를 사용하여 반응형 및 상호작용형 챗봇을 개발하는 견고한 기반을 제공합니다.\n\n3. 서버 구성\n\n<div class=\"content-ad\"></div>\n\n프로젝트의 이 부분에서는 Node.js와 Express를 사용하여 서버를 설정했습니다. 이 서버는 우리의 챗봇의 핵심 역할로서 요청을 처리하고 Gemini API를 통해 응답을 보내는 역할을 합니다. 서버 설정 및 구성을 단계별로 살펴보겠습니다.\n\n먼저 Express 및 HTTP를 사용하여 서버를 초기화합니다. 이는 애플리케이션의 네트워킹 측면을 처리하는 데 필수적입니다. 이 프로젝트에 적합한 유연하고 미니멀한 구조를 가진 Express 프레임워크를 사용합니다.\n\n```js\nconst express = require('express');\nconst http = require('http');\nconst axios = require('axios');\nconst app = express();\nconst server = http.createServer(app);\n```\n\n또한 JSON 바디를 구문 분석하고 정적 파일을 제공하는 필수적인 미들웨어를 설정하여 서버가 들어오는 요청을 이해하고 HTML, CSS 및 JavaScript 파일을 올바르게 제공할 수 있도록 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\napp.use(express.json());\napp.use(express.static(__dirname + '/views'));  // HTML 파일 제공\napp.use(express.static(__dirname + '/public')); // JS, CSS, 이미지 제공\n```\n\nGemini API와 통합\n\n저희 서버의 주요 기능은 /chat 엔드포인트로의 POST 요청 처리입니다. 여기서 사용자 입력을 받아들이고 처리합니다. 요청 처리는 다음과 같이 설정되어 있습니다:\n\n```js\napp.post('/chat', async (req, res) => {\n    if (!req.body) {\n        return res.status(400).send('요청 본문이 없습니다');\n    }\n\n    console.log(req.body.text, \"reqq\");\n\n    try {\n        const apiKey = process.env.APIKEY;  // API 키 안전하게 액세스\n        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;\n\n        const postData = {\n            \"contents\": [\n                {\n                    \"parts\": [\n                        {\n                            \"text\": req.body?.text\n                        }\n                    ]\n                }\n            ]\n        };\n\n        const response = await axios.post(apiUrl, postData, {\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n\n        res.json({ reply: response.data });\n        \n    } catch (error) {\n        \n        res.status(500).send('응답 가져오기 실패');\n    }\n});\n```\n\n<div class=\"content-ad\"></div>\n\n이 세그먼트에서는 사용자의 텍스트를 추출하고 적절한 JSON 페이로드를 구성하여 Axios를 사용하여 Gemini API로 보내 POST 요청을 처리합니다. 그런 다음 API의 응답을 다시 사용자에게 반환합니다.\n\n서버 시작\n\n마지막으로, 지정된 포트에서 서버를 수신 대기 상태로 만들어들어오는 연결을 처리할 준비가 되도록합니다:\n\n```js\nconst port = 5000;\nserver.listen(port, () => {\n    console.log(`Listening on http://localhost:${port}`);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n이 설정은 챗봇의 백엔드 핵심을 구성하며 사용자 쿼리를 효율적으로 처리하고 응답하는 데 도움이 됩니다. Node.js와 함께 Express를 사용하여 요청을 비동기적으로 처리하고 외부 API와 안전하게 통신하는 견고한 서버를 구축했습니다.\n\n3. 클라이언트 측 구성\n\n우리의 챗봇을 위해 사용자 친화적이고 매력적인 인터페이스를 만들기 위해 HTML 및 JavaScript의 설정을 간소화했습니다. 사용자 입력을 처리하고 응답을 효과적으로 표시하는 데 이 구성은 필수적입니다.\n\n우리의 웹 페이지는 기능과 사용성에 중점을 두고 직관적으로 설계되었습니다. 우리 index.html에는 다음 코드 스니펫이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- 기본 입력 상자 및 버튼 설정 -->\n<input type=\"text\" id=\"userInput\" placeholder=\"무엇인가를 말해보세요...\">\n<button onclick=\"sendMessage()\" id=\"sendBtn\">보내기</button>\n<p id=\"response\">여기에 응답이 나타납니다...</p>\n```\n\n이러한 요소들은 사용자가 챗봇과 상호 작용할 수 있는 필요한 인터페이스를 제공합니다. 스타일링을 위해 외부 CSS 파일에 링크되어 있으며 논리 처리를 담당하는 JavaScript 파일과도 연결되어 있습니다.\n\n우리의 JavaScript 파일 Script.js는 사용자 입력을 캡처하고 서버와 상호 작용하며 챗봇의 응답을 표시하는 데 중요합니다:\n\n```js\nfunction sendMessage() {\n    const userInput = document.getElementById('userInput').value; // 사용자 입력 캡처\n    document.getElementById('response').innerText = '봇: 입력 중...'; // 대기하는 동안의 피드백\n\n    // 데이터를 서버로 전송하고 응답을 처리\n    fetch('/chat', {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify({ text: userInput })\n    })\n    .then(response => response.json())\n    .then(data => {\n        document.getElementById('response').innerText = `봇: ${data.reply}`;\n    })\n    .catch(error => {\n        console.error('에러:', error);\n        document.getElementById('response').innerText = '에러: 챗봇과 통신할 수 없습니다';\n    });\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 스크립트는 사용자 메시지가 서버로 전송되고 챗봇 응답이 신속하고 효과적으로 표시되도록 보장합니다.\n\nCSS의 세부사항은 여기에 자세히 나와 있지 않지만, 스타일은 채팅 인터페이스가 다양한 기기에서 접근 가능하고 미적으로 매력적으로 표시되도록 합니다. 레이아웃은 데스크톱 및 모바일 사용자 모두에게 부드럽게 조정되어 일관된 사용자 경험을 유지합니다.\n\n3. Postman을 사용한 챗봇 API 테스트\n\n챗봇을 대중에 출시하기 전에 서버가 요청과 응답을 올바르게 처리하는지 확인하는 것이 중요합니다. 이를 위해 우리는 Postman을 사용합니다. 이 강력한 도구를 사용하면 클라이언트 요청을 시뮬레이션하고 API 기능을 테스트할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 요청 구성:\n\n- 서버가 /chat 엔드포인트에서 POST 요청을 예상하므로 메서드를 POST로 설정합니다.\n- 챗봇 API 엔드포인트의 URL을 입력하세요. 로컬에서 테스트하는 경우 http://localhost:5000/chat와 비슷할 수 있습니다.\n\n2. 헤더 및 본문 설정:\n\n- 헤더 아래에서 Content-Type을 application/json으로 설정하여 서버에게 JSON 데이터를 전송한다고 알립니다.\n- 본문 섹션에서 'raw'를 선택하고 text 키와 사용자 입력을 나타내는 값을 가진 JSON 객체를 입력합니다. 예를 들어 '\"text\": \"안녕, 챗봇!\"'과 같이 입력하세요.\n\n<div class=\"content-ad\"></div>\n\n3. 요청 보내고 응답 분석하기:\n\n- \"보내기\" 버튼을 클릭하여 챗봇 서버에 요청을 제출하세요. 반환되는 응답을 관찰해보세요.\n\n## Gemini API를 활용한 간단한 AI 챗봇 데모\n\n커다란 개발과 테스트를 거쳐, 저희는 Gemini API로 구동되는 AI 챗봇의 실시간 데모를 자랑스럽게 선보이게 되었습니다. 아래에서 실시간으로 챗봇이 어떻게 보이고 응답하는지 확인하실 수 있으며, 사용자에게 원활하고 상호작용적인 경험을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n- 초기 사용자 상호 작용\n\n![사용자 이미지](/assets/img/2024-05-17-InnovatingwithAIDevelopingasimpleChatbotUsingGeminiAPI_1.png)\n\n여기서 사용자가 입력 상자에 \"안녕\"을 입력했습니다. 이 초기 인사는 간단하지만, 챗봇의 처리를 시작하는 데 충분합니다.\n\n2. 챗봇 처리\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-17-InnovatingwithAIDevelopingasimpleChatbotUsingGeminiAPI_2.png)\n\n사용자가 \"보내기\"를 누른 직후 챗봇은 \"Bot: 입력 중...\"을 표시합니다. 이는 챗봇이 Gemini API를 사용하여 입력을 처리하여 관련성 있고 지능적인 답변을 생성 중임을 나타냅니다.\n\n3. 챗봇 응답\n\n![image](/assets/img/2024-05-17-InnovatingwithAIDevelopingasimpleChatbotUsingGeminiAPI_3.png)\n\n<div class=\"content-ad\"></div>\n\n저는 챗봇을 직접 시도해보시라고 권유합니다. 그렇게 하면 이 챗봇의 반응성과 그 뒤에 숨겨진 기술을 완전히 이해할 수 있을 거예요. 이번 데모는 시작에 불과하며, 계속해서 기술을 개선하고 확장하여 여러분의 요구를 더 잘 충족시킬 수 있도록 노력하고 있습니다.\n\nAI 챗봇과 상호작용하는 데 즐거움을 느끼시길 바랍니다. 이 데모는 연구, 개발, 테스트의 결실이며, 현대 AI 기술과 첨단 프로그래밍 기법의 힘을 증명하는 것입니다.\n\n이 기사를 읽어주셔서 감사합니다! 🥰 만약 유익하고 도움이 된다면, 이 기술에 대해 배우고 싶어하는 다른 분들과 공유하실 수 있습니다. 그리고 만약 즐거우셨다면 👏 를 꼭 한 번 클릭해주세요!\n\n여기에서 전체 소스 코드를 확인하고 자세한 문서를 볼 수 있으며, 계속 진행 중인 개발에 기여할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n행복한 하루 보내세요! 코딩을 즐기세요! 🤗","ogImage":{"url":"/assets/img/2024-05-17-InnovatingwithAIDevelopingasimpleChatbotUsingGeminiAPI_0.png"},"coverImage":"/assets/img/2024-05-17-InnovatingwithAIDevelopingasimpleChatbotUsingGeminiAPI_0.png","tag":["Tech"],"readingTime":8},{"title":"JavaScript Promise 제대로 이해하고 넘어가자","description":"","date":"2024-05-17 03:20","slug":"2024-05-17-JavaScriptPromisesDemystifiedTheOnlyGuideYoullNeedPart1","content":"\n\n\n![이미지](/assets/img/2024-05-17-JavaScriptPromisesDemystifiedTheOnlyGuideYoullNeedPart1_0.png)\n\n자바스크립트를 사용하면 언젠가는 프로미스에 직면하게 될 것입니다. 프로미스는 자바스크립트에서 비동기 프로그래밍의 핵심입니다. 실시간 데이터는 모두 프로미스를 사용하여 처리됩니다. 프론트엔드 개발자든 백엔드 개발자든, 이 개념을 이해하는 것은 원활한 자바스크립트 애플리케이션을 만드는 데 중요합니다. 이 블로그 포스트에서는 프로미스에 대해 깊게 들어가보고 다른 곳을 찾아볼 필요가 없도록 이해해보겠습니다.\n\nMDN 웹 문서에는 다음과 같이 설명되어 있습니다:\n\n'프로미스 객체는 비동기 작업의 최종 완료(또는 실패)와 그 결과 값의 대기 시간을 나타냅니다.'\n\n\n<div class=\"content-ad\"></div>\n\n상기 문장을 더 잘 이해하기 위해 두 친구의 예를 들어보겠습니다. 첫 번째 친구가 두 번째 친구에게 돈을 빌려주고, 두 번째 친구는 한 달 후에 돈을 돌려줄 것을 약속합니다. 이제 두 가지 경우의 수가 있습니다. 두 번째 친구가 약속대로 돈을 돌려주거나, 두 번째 친구가 돈을 돌려주기를 거절할 수 있습니다.\n\n어떤 경우에도 한 달 후에는 결과가 나올 것입니다. 그 점은 확실합니다. 이것이 JavaScript에서 약속이 작동하는 방식입니다. 약속은 응답을 보장합니다: 성공 또는 실패 중 하나가 될 것이지만, 반드시 응답을 받을 수 있습니다.\n\n약속에 따라, 성공적인 해결에 대해 '이행(resolve)'이라고 하고, 실패한 해결에 대해 '거부(rejected)'라고 합니다. 따라서 총 세 가지 상태로 약속을 나타낼 수 있습니다:\n\n- pending: 초기 상태, 이행되지도 거절되지도 않은 상태.\n- fulfilled: 작업이 성공적으로 완료된 상태.\n- rejected: 작업이 실패한 상태.\n\n<div class=\"content-ad\"></div>\n\n약속을 어떻게 만들 수 있는지 살펴봅시다.\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  let a = true; // 여기서 일반적으로 일부 외부 호출을 수행합니다.\n  if (a) {\n      setTimeout(() => {\n      resolve(\"foo\");\n    }, 1000);\n  } else {\n    setTimeout(() => {\n        reject(\"foo\");\n      }, 1000);\n  }\n});\n```\n\n기본적인 약속은 이렇게 보입니다. 외부 호출을 시뮬레이션하기 위해 setTimeout 함수를 사용했는데, 여기에 호출에 1초의 지연이 추가됩니다. 조건이 성공하면 resolve가 반환되고 실패하면 reject가 반환됩니다.\n\n약속에 대해 추가 조치를 취하려면 연결된 세 가지 메서드가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- then: 이 방법은 성공적인 처리의 응답을 받기 위해 프로미스에서 사용됩니다.\n- catch: 이 방법은 거절된 경우 프로미스에서 오류를 받기 위해 사용됩니다.\n- finally: 응답에 관계없이 어떤 작업을 수행하고 싶다면, 이를 사용합니다.\n\n이러한 방법은 모두 프로미스를 반환하며, 데이터를 계속 전달하고 체이닝할 수 있습니다.\n\n```js\nmyPromise\n .then((response) => {\n   // 성공한 경우에 대한 작업 수행\n  })\n  .catch((error) => {\n   // 거절된 경우에 대한 작업 수행\n  })\n  .finally(() => {\n   // 각각의 작업 후에 수행할 작업 수행\n  })\n```\n\n이제 프로미스가 더 이상 시작할 때보다 훨씬 더 의미가 있길 바랍니다. 다가오는 블로그에서 여러 프로미스를 호출하고 그러한 상황을 처리하는 방법, 콜백 지옥이 뭔지 그리고 어떻게 벗어날 수 있는지, 여러 프로미스를 처리하는 데 사용할 수 있는 방법 등을 알아볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 블로그 시리즈를 마치면 약속을 사용하는 데 훨씬 더 편안해지고 무엇이 일어나고 있는지 깊이 이해할 수 있을 거예요.\n\n끝까지 읽어 주셔서 감사합니다. 친구들과 함께 좋아요를 눌러 주시고 댓글을 남겨 주시고 공유해 주세요. 그래야 그들도 능숙해질 수 있으니까요. 함께 배우는 건 훨씬 더 재미있어요.\n\n좋은 하루 되세요!","ogImage":{"url":"/assets/img/2024-05-17-JavaScriptPromisesDemystifiedTheOnlyGuideYoullNeedPart1_0.png"},"coverImage":"/assets/img/2024-05-17-JavaScriptPromisesDemystifiedTheOnlyGuideYoullNeedPart1_0.png","tag":["Tech"],"readingTime":3},{"title":"2024년에 가장 인기 있는 최고의 자바 프로파일러 9가지","description":"","date":"2024-05-17 03:16","slug":"2024-05-17-9BestJavaProfilerstoUsein2024","content":"\n\n<img src=\"/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_0.png\" />\n\n요즘에는 제가 써오던 서드파티 리눅스 애플리케이션에서 내 애플리케이션이 메모리 누수를 일으켰을 것으로 생각되는 경우가 발생하여 메모리 부족 예외를 계속 받게 되었어요.\n\n그래서 서드파티 애플리케이션을 모니터링하기 위해 프로파일러를 시작하기로 결정했어요. 이 아이디어는 실행 중인 Java 프로세스에 프로파일러를 연결하고 할당 호출 트리 보기를 사용하여 호출되는 메서드 및 관련 클래스를 기록하는 것이었죠.\n\n도와줄 Java 프로파일러를 찾기 시작했을 때 여러 가지가 있음을 깨달았고, 그 중 YourKit을 시도하기로 결정했어요. YourKit은 인기 있는 강력한 프리미엄 Java 프로파일러로 Java 애플리케이션을 위해 설계되었답니다. 프로파일러 설정은 그동안 들었던 소문과는 달리 꽤 쉬웠어요.\n\n<div class=\"content-ad\"></div>\n\n프로파일러를 시작하여 어떤 애플리케이션이 내 앱을 느리게 만드는지 알아보려고 했어요. 도구가 정말 잠재력이 있는 것을 깨달았지만 문제가 어디인지 실제로 정확히 파악하는 데 많은 시간이 걸리고 정말 어렵다는 걸 깨달았어요. 데이터를 받은 후에는 호출 트리를 직접 살펴보고 결론을 내려야 해서 분석하기가 어려웠어요.\n\n![image](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_1.png)\n\n최적화된 SQL 쿼리에 대한 이 글을 읽은 후 새로운 멋진 도구를 발견했다는 걸 기억했어요. 이 도구는 전통적인 의미의 프로파일러는 아니지만 관측 가능한 데이터를 분석할 수 있어 프로파일링 노력에 도움이 될 것 같았어요. Digma Continuous Feedback 도구가 프로파일러 결과를 분석하여 결론에 도달하고 프로파일러에서 무엇을 찾아야 하는지 도와줄 수 있을 것 같아요. 그래서 YourKit 프로파일러와 함께 Digma를 열었어요.\n\n이 블로그에서는 왜 프로파일러를 시작하기로 결정했는지, 자바 앱을 프로파일링하기에 적합한 프로파일러 목록, 그리고 Digma Continuous Feedback이 프로파일러의 데이터를 분석하고 결론을 도출하는 데 어떻게 도움이 되었는지를 공유할 거예요.\n\n<div class=\"content-ad\"></div>\n\n# 자바 프로파일러란?\n\n자바 프로파일러는 자바 애플리케이션의 성능을 측정하고 분석하는 도구입니다. 각 함수의 소요 시간, 메모리 사용량 및 함수 호출 빈도를 포함하여 프로그램 실행에 대한 데이터를 수집합니다.\n\n자바 프로파일링은 소프트웨어 애플리케이션에서 성능 병목 현상을 찾는 데 유용합니다. 프로파일러가 수집한 데이터를 분석하면, 코드에서 가장 주목할 만한 지연 또는 자원 소비에 책임 있는 부분을 식별할 수 있습니다. 이 데이터는 코드를 개선하고 성능을 향상시키며 자원 소비를 감소시킬 수 있습니다.\n\n그러므로 자바 프로파일러는 JVM 수준에서 자바 바이트 코드 구조와 작업을 확인하는 도구입니다. 이 프로그래밍 구조와 작업에는 객체 생성, 프로세스 반복(재귀적 함수 호출 포함), 메소드 실행, 스레드 실행 및 가비지 수집이 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n# Java Profiler 종류\n\n- 샘플링 프로파일러: 이러한 프로파일러는 주기적으로 실행 중인 프로그램의 스냅샷을 찍고 콜 스택을 분석하여 핫스팟을 식별합니다.\n\n- Instrumentation 프로파일러: 이러한 프로파일러는 프로그램의 코드를 수정하여 좀 더 자세한 성능 데이터를 수집합니다.\n\n# Java 프로파일러의 사용 사례\n\n<div class=\"content-ad\"></div>\n\nJava 프로파일링 도구는 기본적으로 세 가지 방법으로 사용할 수 있어요:\n\n성능 최적화: 개발자들은 Java 프로파일러를 사용하여 성능 문제를 일으키는 코드 부분을 파악할 수 있어요. 예를 들어 느린 함수 호출이나 높은 메모리 사용량 등이 있어요. 이 데이터를 활용하여 코드를 개선하여 성능을 향상시킬 수 있어요.\n\n메모리 관리: Java 프로파일러는 메모리 누수를 감지하는 데 도움이 될 수 있어요. 프로그램이 사용하지 않는 메모리를 해제하지 못할 때 발생하는 메모리 누수가 있어요. 이러한 누수로 인해 메모리가 부족해져 프로그램이 다운될 수 있어요. 개발자들은 메모리 누수를 파악하여 더 이상 필요하지 않은 메모리를 해제하도록 코드를 수정할 수 있어요.\n\n테스트: Java 프로파일러는 다양한 시나리오에서 프로그램 성능을 평가할 수 있어요. 예를 들어 다양한 입력 크기나 사용자 수를 고려한 테스트에 사용할 수 있어요. 이를 통해 프로그램이 출시되기 전에 잠재적인 성능 문제를 인식할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 자바 프로파일러는 어떻게 작동하나요?\n\nJVM은 자바 개발자가 실행 중인 JVM(Java Virtual Machine)에 에이전트를 연결할 수 있도록 합니다. 개발자가 JVM에 에이전트를 연결하면, JVM은 에이전트에게 클래스를 로드하기 전에 클래스를 제공합니다. 그런 다음, 에이전트는 클래스를 변환합니다. 에이전트는 어떤 클래스의 코드를 변경할 수 있습니다.\n\n자바 프로파일러는 기본적으로 에이전트입니다. 그들은 메소드의 시작과 끝에 계측 코드를 추가하여 해당 작업 시간을 추적합니다. 또한 모든 클래스의 생성자와 종료 메소드에 코드를 추가하여 사용된 메모리량을 추적합니다.\n\n자바에서 코드 프로파일링은 내장 도구와 제3자 도구를 포함한 다양한 도구를 통해 달성할 수 있습니다. 애석하게도 인기 있는 일부 도구는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- JVM 도구\n- Digma\n- VisualVM\n- YourKit\n- JProfiler\n- NetBeans Profiler\n- IntelliJ Profiler\n- Async Profiler\n- Arthas\n\nOpenTelemetry와 Java Flight Recorder (JFR)는 대부분의 경우를 커버합니다. 자동으로 instrumentation을 원하는 경우 OpenTelemetry Java 에이전트를 사용하거나 직접 instrumentation을 수행하려면 API만 사용하십시오.\n\n# 1. JVM 도구\n\n이 Java 프로파일링 도구는 표준 JDK와 함께 제공되어 별도의 설치나 설정이 필요하지 않습니다. 대략 다섯 가지가 있습니다: jstat, jmap, jcmp, jhat 및 hprof.\n\n<div class=\"content-ad\"></div>\n\na. jstat\n이 내장 명령줄 도구는 표준 JDK와 함께 제공되며 설치나 설정이 필요하지 않습니다. 명령줄을 통해 JVM 메모리, 힙 크기, 그리고 가비지 수집 활동을 모니터링하는 것은 매우 유익합니다.\n\n이 도구는 JVM의 기본으로 활성화된 내장 계측을 활용하여 JVM을 시작하는 데 특별한 명령이 필요하지 않은 가상 머신 식별자 (VMID)를 통해 대상 Java 프로세스를 식별합니다.\n\n다음은 jstat을 사용하는 세 가지 방법입니다:\n\n미리 정의된 성능 제약 조건을 사용하여 Java 프로그램을 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\njava -Xmx125m -Xms25m -Xmn15m -XX:PermSize=30m -XX:MaxPermSize=30m -XX:+UseSerialGC HelloWorld\n```\n\n아래 명령어를 사용하여 프로세스 ID를 얻을 수 있습니다.\n\n```js\nps aux | grep java\n```\n\nJVM Heap Memory 사용량을 모니터링하려면 터미널에서 jstat을 -gc 옵션과 함께 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\njstat -gc 98132 17527\n```\n\n![이미지](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_2.png)\n\nb. jmap\n\n이 명령줄 도구는 표준 JDK에 포함되어 있습니다. 라이브 VM 또는 코어 파일에 대한 메모리 관련 데이터(heap summary, java object heap histogram, class loader stats, finalization queue info, dump of Java heap in hprof binary format)를 표시합니다.\n\n<div class=\"content-ad\"></div>\n\n기본 구성 및 알고리즘을 분석하는 것은 특히 유익합니다.\n\n성능을 향상시키고 진단을 개선하기 위해 JDK 8부터 사용할 수 있는 새로운 유틸리티인 jcmd를 jmap 유틸리티 대신 사용하는 것을 제안합니다.\n\n터미널에서 jmap을 사용하는 방법은 다음과 같습니다.\n\njhsdb jmap –-heap `JAVA_PID`\n\n<div class=\"content-ad\"></div>\n\n해당 명령을 사용하여 힙 덤프(heap dump)를 생성할 수도 있어요.\n\njhsdb jmap — -dump:file=`FILE` `JAVA_PID`\n\nc. jcmp\n이 명령행 도구는 표준 JDK와 함께 제공되며 별도의 설치나 설정 절차가 필요하지 않아요. JVM에 진단 명령을 보내는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\njcmd `JAVA_PID` GC.heap_dump filename=`FILE`\n\n- jhat\n\n이 명령줄 도구는 표준 JDK에 미리 설치되어 있으며 설치나 설정이 필요하지 않습니다. 힙 스냅샷(또는 힙 덤프)의 객체 구조를 탐색하는 데 사용됩니다.\n\n이 도구는 Heap Analysis Tool (HAT)을 대신합니다. jcmd에 의해 생성된 힙 덤프와 같은 이진 형식의 힙 덤프를 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n이 도구는 Java의 메모리 누수와 유사한 의도하지 않은 객체 연결을 식별하는 데도 도움을 줄 수 있습니다. (루트셋에서 참조되어 있는 객체)\n\n예를 들어, hprof\n\n이 기본 명령줄 도구는 표준 JDK와 함께 제공됩니다. 힙 및 CPU 프로파일링, 락 경합, 메모리 누수 및 기타 문제를 분석하여 성능을 조사합니다. JVMTI(JVM 도구 인터페이스)를 통해 JVM과 통신하는 동적 링크 라이브러리(DLL)입니다.\n\n프로파일링 데이터를 파일이나 소켓을 통해 ASCII 또는 이진 형식으로 기록합니다. 힙 할당 통계, 힙 덤프, CPU 사용량, JVM 내의 모든 모니터 및 스레드의 상태, 경합 프로필에 대한 정보를 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\njava –agentlib:hprof HelloWorld\n```\n\n아래 명령을 사용하여 hprof를 사용하여 힙 할당 프로필을 얻을 수 있습니다.\n\n```js\njavac –J-agentlib:hprof=heap=sites HelloWorld.java\n```\n\n아래 명령을 사용하여 힙 덤프를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\njavac -J-agentlib:hprof=heap=dump HelloWorld.java\n```\n\n# 2. Digma Continuous Feedback\n\nDigma는 OTEL을 사용하여 자동으로 수집한 관측 데이터에 의존합니다. 다른 프로파일링 도구와 마찬가지로 코드가 런타임에서 어떻게 작동하는지 분석하고 문제점을 찾는 것이 목적입니다. 유일한 차이점은 Digma가 자체적으로 이러한 문제점을 계속해서 찾는다는 것입니다.\n\n몇 가지 예시를 살펴보겠습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 앱에 가장 많은 영향을 미치는 코드/쿼리를 찾아보세요(성능 영향).\n\na. 가장 성능에 영향을 많이 주는 코드를 찾으려면 자산 탭에서 \"Performance Impact\"로 정렬할 수 있습니다:\n\n![이미지](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_3.png)\n\n이 뷰는 개발자에게 가치 있는 정보를 제공합니다. 성능 문제로 최적화가 필요할 수 있는 엔드포인트를 빠르게 파악할 수 있습니다. 실행 시간과 성능 영향의 조합을 통해 문제 해결에 우선순위를 두고 개발에 집중할 수 있어 전체 애플리케이션의 성능과 신뢰성을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nb. 또는 대시보드를 여시고, 클라이언트 스팬 성능 영향 위젯을 사용해보세요:\n\n![위젯](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_4.png)\n\n이 위젯은 개발자들이 애플리케이션의 어떤 부분이 성능 문제에 기여할 수 있는지 빠르게 식별할 수 있게 해줍니다. 성능에 미치는 영향이 큰 엔드포인트부터 시작해 디버깅과 최적화 노력을 우선 순위에 따라 할 수 있습니다.\n\n2. 최근 커밋에서 성능 저하 식별하기 ― 지속 시간의 변화\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_5.png)\n\n코드 성능의 최근 변경 사항을 추적하는 또 다른 방법은 기간 통찰력입니다. 이는 특정 범위의 호출 기간 분포를 시각적으로 나타냅니다.\n\n최근 호출 성능: 위젯은 가장 최근 호출의 기간을 보여줍니다(91.95밀리초), 이를 일반적인 성능과 즉시 비교하여 예상 범위 내인지 아니면 이상값인지 확인할 수 있습니다.\n\n중앙값 기간: 중앙값 기간이 최근 변경되었습니다(16.19밀리초 증가). 빨간색은 최근 변경 사항을 나타내며, 이는 성능의 저하 또는 개선을 나타낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n성능 분포: 히스토그램 자체는 호출 지속 시간의 빈도를 표시하여 개발자가 다양한 성능 시간의 공통성을 빠르게 파악할 수 있습니다. 특정 호출 지속 시간 범위가 얼마나 자주 발생하는지 보여줍니다.\n\n가장 느린 5%: 호출의 가장 느린 5%를 나타내는 히스토그램의 부분이 강조됩니다. 이는 평균이나 중앙값 통계로는 명백하지 않은 장기적인 성능 문제를 식별하는 데 중요합니다.\n\n이 통찰력을 활용하여 개발자는 코드의 성능을 시간이 지남에 따라 추적할 수 있습니다. 시각화는 증가하는 지연과 같은 트렌드를 식별하는 데 도움이 되며, 이는 메모리 누수, 비효율적인 데이터베이스 쿼리 또는 다른 리소스 충돌 문제와 같은 잠재적인 문제를 나타낼 수 있습니다. 최근 변경 사항을 나타내는 빨간 블록은 최근 코드 변경이나 배포 업데이트와 성능 변화를 상관시켜 주어 더 즉각적인 조사를 유도하는 데 특히 유용합니다.\n\n3. 스케일링 문제 찾기를 위한 프로파일링 - 스케일링 통찰력\nDigma는 코드의 확장성에 대한 통찰력을 제공하여, 응용프로그램의 확장 가능성을 방해할 수 있는 잠재적인 문제를 식별합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Java Profiler](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_6.png)\n\n예를 들어, 스케일링 문제 통찰력을 통해 개발자는 동시성 처리 및 요청 처리 시간과 관련된 성능 병목 현상을 빠르게 파악할 수 있습니다.\n\n성능 저하 메트릭은 성능이 하락하는 부하 수준을 식별하는 데 도움이 됩니다. 이 메트릭은 이러한 트랜잭션 중에 실행된 코드 경로를 확인하여 비효율성이나 리소스 경합을 찾도록 개발자를 안내할 수 있습니다.\n\n동시성 정보는 시스템이 동시적인 프로세스나 스레드를 처리할 때 문제가 발생하는 것을 개발자에게 알립니다. 이는 응용프로그램이 병렬 처리를 처리하거나 응용프로그램이 이 수준의 동시성에서 최적으로 작동하도록 필요한 리소스가 할당되지 않는 문제를 시사할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n시간 소요: 넓은 범위는 일부 조건에서 응답 시간이 크게 증가할 수 있는 것을 시사합니다. 이는 처리 병목, 비효율적인 알고리즘, 데이터베이스 쿼리 성능 또는 다른 시스템 제약 때문일 수 있습니다.\n\n이 정보를 종합함으로써, 개발자는 주의를 요하는 응용 프로그램 요소로 유도되고 비효율적인 코드, 데이터베이스 병목 현상, 부적절한 하드웨어 자원 또는 최적화되지 않은 아키텍처 결정과 같은 문제의 원인을 가정하기 시작할 수 있습니다. 목표는 이러한 영역을 조사하고 개선하여 응용 프로그램의 확장성을 향상시키는 것입니다.\n\n# 3. VisualVM\n\n이 도구는 Java Development Kit (JDK)의 일부였지만 JDK 8에서 제거되었으며, 현재는 별도의 도구로 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 Java 프로파일러는 CPU 샘플링, 메모리 샘플링, 가비지 수집 실행, 힙 오류 분석, 스냅샷 촬영 및 그래픽 사용자 인터페이스를 위해 편리합니다.\n\n이 Java 프로파일러는 로컬 및 원격 프로파일링을 지원하지만 SSH 터널링을 통한 프로파일링은 지원하지 않습니다. 원격 프로파일링을 위해 JMX 포트를 구성해야 합니다.\n\nVisualVM은 프로파일링 세션의 스냅샷을 나중에 분석할 수 있도록 촬영하는 기능을 제공합니다.\n\nVisualVM은 JConsole, jstat, jinfo, jstack 및 jmap과 같은 JDK와 함께 제공되는 독립적인 도구에 의존합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![VisualVM](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_7.png)\n\n다음은 VisualVM을 사용하는 세 가지 방법입니다:\n\n1. 미리 정의된 성능 제약 조건을 사용하여 Java 프로그램 실행하기\n\n```bash\njava -Xmx125m -Xms25m -Xmn15m -XX:PermSize=30m -XX:MaxPermSize=30m -XX:+UseSerialGC HelloWorld\n```\n\n<div class=\"content-ad\"></div>\n\n터미널에서 jvisualvm을 실행하여 JVM 힙 메모리 사용량을 모니터링해보세요.\n\n\njvisualvm\n\n\n다음으로, Java VisualVM 프로그램이 실행됩니다. Tools > Plugins로 이동하여 Visual GC 플러그인을 다운로드하세요. (다른 플러그인들도 표시될 것입니다. 필요한 것들을 사용할 수 있습니다.)\n\n# 4. Yourkit\n\n<div class=\"content-ad\"></div>\n\nYourKit Java Profiler은 다양한 플랫폼과 호환되며 Windows, MacOS, Linux, Solaris 및 FreeBSD와 같은 각 지원 운영 체제에 대한 구별된 설치를 제공합니다.\n\nJProfiler와 마찬가지로 YourKit에는 스레드, 가비지 수집, 메모리 사용량 및 메모리 누수를 표시하는 핵심 기능이 포함되어 있습니다. SSH 터널링을 통해 로컬 및 원격 프로파일링을 지원합니다.\n\n당신의 계획은 비즈니스 목적을 위한 유료 라이선스를 제공하며, 무료 평가판 및 개인 사용을 위한 할인된 또는 무료 허가권을 포함합니다.\n\n![](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_8.png)\n\n<div class=\"content-ad\"></div>\n\n당신의 킷은 발생한 예외를 분석하는 데도 유용합니다. 발생한 예외를 식별하고 빈도를 파악하는 것은 간단합니다.\n\n당신의 킷은 특정 부분인 메서드나 스레드 내의 브랜치와 같은 코드에 초점을 맞춘 독특한 CPU 프로파일링 기능을 제공합니다. 이 기능은 조건부 프로파일링을 가능하게 함으로써 유용합니다.\n\n당신의 킷은 SQL 및 NoSQL 데이터베이스 호출을 프로파일링할 수도 있습니다.\n\n# 5. JProfiler\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식은 JProfiler을 사용하여 Java 애플리케이션의 프로파일링을 수행할 수 있는 ej-technologies의 도구입니다. JProfiler에는 메모리 사용량, 시스템 성능, 잠재적인 메모리 누수, 그리고 스레드 프로파일링을 모니터링하기 위한 인터페이스가 제공되며 사용자 친화적인 사용자 인터페이스를 통해 제공됩니다.\n\n이 정보를 통해 시스템의 기초에서 최적화, 제거 또는 수정할 부분을 쉽게 식별할 수 있습니다.\n\nJProfiler은 Java 애플리케이션의 프로파일링 도구이며 ej-technologies가 개발했습니다. JProfiler은 메모리 사용량, 시스템 성능, 잠재적인 메모리 누수, 그리고 스레드 프로파일링을 모니터링하기 위한 인터페이스가 제공되며 사용자 친화적인 사용자 인터페이스를 통해 제공됩니다.\n\n이 정보를 통해 시스템의 기초에서 최적화, 제거 또는 수정할 부분을 쉽게 식별할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_9.png\" />\n\n이 Java Profiler는 라이선스를 구매해야하지만 무료 평가판을 제공합니다. 주요 초점은 네 가지 핵심 영역을 다룹니다:\n\n- 메서드 호출: 메서드 호출을 분석하면 응용 프로그램의 기능에 대한 통찰력을 제공하고 전반적인 성능을 향상시킬 수 있습니다.\n- 할당: 힙에 저장된 항목, 참조 연결 및 쓰레기 수집 관리를 조사함으로써 메모리 누수를 해결하고 메모리 효율성을 향상할 수 있습니다.\n- 스레드 및 락: JProfiler는 다양한 스레드 및 락 분석 관점을 제공하여 멀티스레딩 문제를 식별하는 데 도움을 줍니다.\n- 고급 서브시스템: 고급 의미 수준에서 다양한 성능 문제가 발생합니다. Java 데이터베이스 연결(JDBC)의 JDBC 호출에서 가장 느린 SQL 문을 식별하는 것이 중요합니다. JProfiler를 사용하면 이러한 서브시스템을 통합적으로 조사할 수 있습니다.\n\nJProfiler는 IntelliJ IDEA, 이클립스, NetBeans와 같은 잘 알려진 IDE와 통합될 수 있습니다. 사용자는 스냅샷에서 실제 소스 코드로 이동할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 6. NetBeans Profiler\n\n넷빈스는 주로 우수한 디버깅 기능으로 알려져 있지만, 놀랍게도 최고의 자바 프로파일러 중 하나로 부상합니다. 오라클의 오픈 소스 넷빈스 IDE에는 NetBeans Profiler가 번들의 일부로 포함되어 있습니다. 쉬운 개발과 프로파일링에 대한 우수한 선택지이기도 합니다.\n\n![이미지](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_10.png)\n\n프로파일러와 디버거의 기능을 결합하면 코드 실행 시간 및 런타임 동작을 모니터링하고 멀티스레딩과 같은 디버깅 방법의 효율을 향상시킬 수 있습니다. 넷빈스 프로파일러는 응용 프로그램의 속도를 향상시키고 메모리 효율성을 향상시킵니다. 무료로 해당 웹사이트에서 다운로드할 수 있다는 것이 멋집니다.\n\n<div class=\"content-ad\"></div>\n\nJava VisualVM과 Netbeans Profiler은 기능 면에서 유사하며 둘 다 무료입니다. 그러나 Netbeans는 IDE와 함께 모든 기능을 제공하는 번들 프로그램으로 더 뛰어납니다.\n\n# 7. IntelliJ Profiler\n\nIntelliJ Profiler는 CPU 및 메모리 할당 프로파일링을 위한 간편하면서도 강력한 도구입니다. 두 가지 잘 알려진 Java 프로파일러인 JFR과 Async 프로파일러의 기능을 통합합니다.\n\n일부 고급 기능이 제공되지만, 기본적으로 간편함에 중점을 둡니다. IntelliJ Profiler는 설치 없이 쉽게 시작할 수 있는 간단한 방법을 제공하며 일상적인 개발 작업에 유용한 도구를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Java Profiler](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_11.png)\n\nIntelliJ IDEA Ultimate에서 IntelliJ Profiler를 Java 프로세스에 쉽게 연결할 수 있어요. 스냅숏과 소스 코드 사이를 쉽게 이동할 수 있어서 매끄럽게 작업할 수 있어요. 독특한 flame graph와 같은 다른 측면을 통해 시각적으로 다양한 메소드의 효과를 평가하고 런타임 프로세스를 신속하고 효과적으로 이해할 수 있어요.\n\n# 8. Async Profiler\n\n이 Java 프로파일링 도구는 최소한의 오버헤드가 있으며 Safepoint 편견 문제를 회피할 수 있어요. HotSpot을 위한 스택 추적 및 메모리 할당 모니터링을 위한 특정 API가 포함되어 있어요. 이 프로파일러는 HotSpot JVM을 사용하는 OpenJDK 및 다른 Java 런타임과 호환되어요.\n\n\n<div class=\"content-ad\"></div>\n\nasync-profiler은 다양한 유형의 이벤트를 모니터링할 수 있습니다.\n\n- 중앙 처리 장치 작업\n- 캐시 미스, 브랜치 미스, 페이지 폴트 및 컨텍스트 전환과 같은 성능 카운터를 통해 하드웨어 및 소프트웨어 성능을 모니터링합니다.\n- Java 힙 내의 메모리 분배\n- Java 객체 모니터 및 ReentrantLocks의 locked contention 등의 locked contention 실험\n\n현재 Async Profiler는 Linux 및 Mac 운영 체제만 지원합니다. IntelliJ IDEA를 사용한다면 별도로 설치할 필요가 없습니다. 통합 기능이 미리 설치되어 있으며 다음을 포함합니다.\n\n- 프로파일링 세션 시작 및 종료\n- 이미 진행 중인 프로세스에 연결\n- 프로파일 평가 검사\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_12.png)\n\n# 9. Arthas\n\n앨리바바 아르타스는 Java 애플리케이션을 진단하는 데 사용되는 도구로, 문제를 추적, 분석 및 해결할 수 있는 기능을 제공합니다. Arthas를 활용하는 주요 장점은 코드를 수정하거나 모니터링 중인 Java 서비스를 다시 시작할 필요가 없다는 것입니다.\n\n![image](/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_13.png)\n\n<div class=\"content-ad\"></div>\n\n# 다른 실력 있는 자바 프로파일러\n\n일부 주목할 만한 프로파일러로는 Java Mission Control, New Relic, Glowroot, JMH, Arthas, XRebel/JRebel, JProbe, Pinpoint 및 Stackify Prefix가 있습니다. 시장 점유율은 낮지만 분명 인정받을 가치가 있습니다.\n\nDigna Continuous Feedback 다운로드: 여기\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n그래서, YourKit과 Digma를 결합하는 것이 최상의 최적화 결과를 가져옵니다. Grafana는 애플리케이션 로그를 시각화하기 위해 사용되며, YourKit은 잠재적인 병목 현상을 찾기 위해 애플리케이션을 프로파일링하고, Digma는 잠재적인 문제가 있는 코드 조각에 대한 원활한 통찰력을 제공합니다.\n\n# 자주 묻는 질문:\n\nJProfiler는 자바 프로파일러인가요?\n\nJProfiler는 강력한 프리미엄 자바 프로파일러로, Java 응용 프로그램용으로 설계되었습니다. 10일간의 완전한 평가판을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n자바 메모리 프로파일러란 무엇인가요?\n자바 메모리 프로파일러는 자바 애플리케이션이 어떻게 메모리를 활용하는지를 분석하여 성능 문제를 확인하고 메모리 누수를 수정하는 데 도움을 줍니다.\n\n자바에서 CPU 프로파일링이란 무엇인가요?\n\nCPU 프로파일링은 CPU 사용량을 분석함으로써 애플리케이션의 효율성을 평가하고 개선하는 방법입니다. 이는 코드 내의 핫스팟, 병목 현상 및 효율성 문제를 식별하여 CPU 사용량의 증가나 부적절한 성능으로 이어질 수 있는 문제를 해결하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_0.png"},"coverImage":"/assets/img/2024-05-17-9BestJavaProfilerstoUsein2024_0.png","tag":["Tech"],"readingTime":14},{"title":"2부 미디어 무결성 기반 보호하기","description":"","date":"2024-05-16 17:45","slug":"2024-05-16-Part2SecuringtheFoundationsofMediaIntegrity","content":"\n\n![이미지](/assets/img/2024-05-16-Part2SecuringtheFoundationsofMediaIntegrity_0.png)\n\n소셜 미디어의 광범위한 영향은 개인 데이터에 대한 상당량의 접근성을 가능케 하여, 다양한 기관들이 알고리즘 추천을 향상시키고 사용자 참여를 촉진하며 수익화 노력을 촉진하도록 했습니다. 이 비즈니스 모델은 지속적인 참여와 성장 및 확장을 위해 데이터 수집 전략에 의존합니다. 이제 소셜 미디어가 일상생활에 깊이 뿌리내린 상황에서, 그 구조화된 아키텍처는 연결성 도구뿐만 아니라 악의적인 주체들에 의해 조작되는 수단으로 작용합니다. 이들 기관은 영향 작전부터 스파이 행위 및 사이버 범죄까지 목적에 따라 플랫폼 설계를 악용할 수 있습니다.\n\n소셜 미디어 플랫폼의 엄청난 데이터 수집 및 조작 능력은 정보 작전 및 사회 공학적 공격에 있어 강력한 도구로 작용하며, 심리 전쟁 및 다양한 분야 작전에서 중요한 요소입니다. 악의적인 주체들, 특히 전략적인 사이버 목표를 가진 외국 기관과 연관된 주체들에 의해 소셜 미디어의 오용 가능성이 큽니다. 지역정치의 긴장 속에서 적 대국과 연관된 플랫폼들이 언국가 안보에 미치는 위협을 이해하는 것이 중요합니다.\n\n미군은 종종 적에 대비해 응답 속도가 늦어지는 것에 대해 걱정을 표명했습니다. 이에 대응하기 위해 군은 방어작전에 대한 미디어 접근을 제공하는 정책을 시행했습니다. 군사 부대에 기자를 배치하는 것은 주로 작전 보안을 보호하면서 뉴스의 적시성과 상세 설명을 크게 희생시키지 않도록 하는 것을 목표로 합니다. 이에 대해 언론 조작 가능성에 대한 비판이 있지만, 이것은 주로 작전 보안을 보호하는 데 목적이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n더 많은 접근 및 투명한 정보 공유는 언론이 더 많은 정보와 포괄적인 보도를 생산할 수 있도록 돕습니다. 그러나 뉴스 산업은 수익 창출을 위한 노력과 감소하는 수익과 광고 베이스로 인한 압력 등, 이러한 최선의 실천 방안을 방해할 수 있는 압력에 직면합니다. 뉴스 수집 자원의 중대한 감소와 경험이 적은 계약 직원에 대한 의존도 증가는 추가적인 도전을 제기합니다. 더불어 미디어 플랫폼들의 증가로 지속적인 콘텐츠 업데이트가 요구되는데, 이는 종종 덜 비용이 드는 코멘터리로 채워지며 정보의 품질과 정확성을 희석시킬 수 있습니다.\n\n주류 미디어의 영향력은 크며, 국가적 논쟁을 결정하고 보안 문제에 대한 대중 의견을 형성합니다. 미디어가 고수해야 할 전문적인 기준을 준수하는 것은 중요합니다. 이를 하지 못하면 신뢰도와 사회 기능이 퇴색될 우려가 있습니다. 이러한 환경에서 정보원의 출처 및 진위를 보장하는 것이 중요합니다. 정보의 안전하고 검증 가능한 출처를 확립함으로써 미디어 콘텐츠의 질을 보호하고, 결과적으로 왜곡된 오보의 영향으로부터 사회적 대화와 개인 인식을 보호할 수 있습니다.\n\n![The Security of Our Minds](/assets/img/2024-05-16-Part2SecuringtheFoundationsofMediaIntegrity_1.png)\n\n<div class=\"content-ad\"></div>\n\n인간의 정신을 교란하는 숨겨진 영향으로부터 방어하기 위한 여정에서, 우리의 집단 책임은 단순한 경계를 초월하여 깊은 이해를 필요로 합니다; 진실과 거짓이 우리의 사고의 전장을 어떻게 형성하는지를 깊이 파악해야 합니다. 미디어의 무결성은 정보 보안의 중추일 뿐만 아니라 정신적 자율성의 수호자가 되는 것입니다. 사회적 상호작용 속에서, 미디어는 대중 담론의 풍경을 형성하는 통로로서 존재합니다. 이 흐름이 오보와 프로파간다의 오염물질로 오염된다면, 인간 인식의 본질 자체가 훼손됩니다.\n\n이 영향의 깊이를 이해하려면, 우리가 소비하는 각 정보 조각이 현실에 대한 우리의 지각을 섬세하게 조정하는 것을 인정해야 합니다. 거짓된 스토리가 번식하는 환경에서, 특히 순진한 이나 교육받지 못한 사람들을 겨냥하는 경우, 마음의 방어 기제는 준비되지 않아 조작에 취약해질 수 있습니다. 이러한 조건은 파시스트 정권에게 우월한 위치를 제공하는데, 그들은 진실을 숨기고 무지를 부추기며 권력을 유지하려는 수법을 통해 이야기를 통제하는 데 착취합니다.\n\n조작된 사실과 꼬인 진실의 해로운 영향은 단순한 속임수를 넘어서 사람들의 동의를 의도적으로 조작하고 사회적 의지를 형성합니다. 개인이 세상을 바라보는 렌즈를 왜곡함으로써 악의적인 세력은 사회적 규범과 가치를 다시 조작하며 인류를 깨달음 있는 담론에서 더 어두운, 더 분열된 목적으로 이끌 수 있습니다. 이 심리적 조작이 방치된다면, 공공을 유도하는 주자들의 권력을 더욱 굳히면서 공공을 오인시키는 오보의 사이클을 촉발시킵니다.\n\n이것으로서 뉴스 이야기의 권을 그 중요한 방패로 드러납니다. 정보의 성질을 보호하고, 그로부터 확장된 인간 정신의 자율성을 보호하는 수단으로 나타납니다. 미디어의 신뢰성을 보장하기 위해 암호화와 견고한 사이버 보안 조치가 배치되는 데에는 쌍둥이 목적이 있습니다. 먼저, 정보의 부패를 막는 방어선으로 작용하여 뉴스의 원본과 무결성이 창조부터 소비까지 보존되도록 합니다. 둘째, 참된 것을 접근하고 검증할 수 있는 환경을 육성하여 개인을 에워싸는 정보 영역을 견고하게 하여 진실이 접근 가능하고 확인 가능한 환경이 유지되도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n미디어 소스의 신뢰성은 기술적 보호를 통해 확보되며, 이는 개인들이 진실을 추출할 수 있는 기반을 제공합니다. 이 진실은 다시 말해, 잘 통찰하고 판단력 있는 결정을 내릴 수 있는 기초가 되며, 시민들이 건강하고 지속 가능한 사회를 유지하고 육성하는 길을 선택할 수 있게 합니다. 미디어의 역할은 정보를 제공하는 데 그치는 것이 아니라, 인간 발전의 드라마에서 핵심적인 주역이 되어 현실의 관리자이자 대중의 지성을 지키는 역할을 합니다.\n\n미디어의 성실성은 잘 기능하는 사회의 특징뿐만 아니라 자유와 민주주의를 보존하는 것의 전제조건입니다. 우리가 소비하는 각 이야기가 현실의 반영이 되고 왜곡된 정보가 아닌 현실에 입각한 것임을 보장함으로써, 우리는 개별적인 마음 뿐만 아니라 문명의 집단 의식을 지키게 됩니다. 이 관점에서 미디어 성실성을 향상시키는 모든 노력은 사회의 인지적 저항력 향상에 투자하는 것이며, 우리 집단적 수평선을 흐려지게 하려는 그림자에 대항하여 지키는 것입니다.\n\n![미디어 성취의 중요성](/assets/img/2024-05-16-Part2SecuringtheFoundationsofMediaIntegrity_2.png)\n\n- 미디어 출처의 중요성\n\n<div class=\"content-ad\"></div>\n\n뉴스의 출처와 신뢰성은 그저 운영 상세사항에 그치는 것이 아니라, 언론이 사회에서 발하는 역할에 있어 중요한 요소입니다. 이는 언론이 공익의 수호자로서, 권력에 대항하는 감시자로서, 진실을 추구하는 신뢰할 만한 횃불로서의 역할을 수행할 수 있도록 보장합니다. 이에 따라 뉴스 보도의 출처와 신뢰성을 강화하기 위한 노력은 정보 제공, 공정성, 민주적 사회 형성에 있어서 언론의 영향력과 효과를 유지하는 데 중요합니다. 뉴스 보도에서의 출처와 신뢰성의 중요성은 널리 강조되어야 합니다. 특히 오늘날의 디지털 시대에는 정보가 신속하게 생성되고 수정되며 세계적으로 퍼져나가는 환경에서 그 중요성이 더욱 커집니다. 뉴스 기사에 대한 명확하고 검증 가능한 가계보를 수립하는 것은 여러 가지 핵심적인 이유로 필수적입니다:\n\n1. 대중 신뢰 유지\n\n신뢰는 어떤 관계의 기반입니다. 대중과 미디어 사이의 관계 역시 예외는 아닙니다. 뉴스 매체가 정보에 대한 투명하고 검증 가능한 출처를 제공할 때, 그들은 청중과의 신뢰를 구축하고 유지합니다. 이 신뢰는 미디어 매체의 신뢰성 뿐만 아니라 그 실천하는 언론의 효과성을 위해 필수적입니다. 위기나 혼란의 시기에는 믿을 만한 미디어가 신뢰할만한 실질적인 정보의 공급원입니다.\n\n2. 정보화된 시민 유도\n\n<div class=\"content-ad\"></div>\n\n정보에 정통한 대중은 기능하는 민주주의의 기반이 됩니다. 시민들은 정확하고 진실한 보도에 의존하여 행정, 정책 및 지역 사회 참여에 대한 결정을 내립니다. 뉴스의 출처가 명확하고 검증 가능하면 이를 통해 이러한 결정에 사용되는 정보가 정확함이 보장되어 시민이 현실에 기반한 시민 생활에 참여할 수 있도록 지원됩니다.\n\n3. 오보와 조작 정보 대응\n\n디지털 정보가 신속하게 퍼지는 시대에, 오보(의도치 않게 부정확한 정보)와 조작 정보(고의적으로 속이는 정보)의 위험이 크게 증가했습니다. 뉴스의 신뢰성을 보장함으로써 언론 기관은 이러한 위협에 맞서게 됩니다. 신뢰성은 거짓된 내러티브의 풍조에 대항하여 사회 불안, 대중 혼란, 심지어 공중보건 및 안전 위협에 이르는 것을 막아줍니다.\n\n4. 저널리즘의 정직한 유지\n\n<div class=\"content-ad\"></div>\n\n저널리즘적 신뢰도는 정확성, 공정성 및 중립성을 준수하는 윤리적 기준에 의지합니다. Provenance는 정보 원본으로의 추적 가능한 경로를 제공함으로써 이러한 원칙을 지원하며, 저널리즘이 매력적인 이야기 전달 도구뿐만 아니라 신뢰할 수 있고 윤리적인 공중정보 제공자가 되도록 보장합니다.\n\n5. 법적 및 평판적 위험으로부터 보호\n\n실용적인 관점에서 뉴스 기관은 잘못된 내용이나 표절 콘텐츠의 배포로 인한 법적 결과로부터 자신을 보호해야 합니다. 검증 가능한 출처 정보를 통해 이러한 기관들은 보도 과정에서의 노력을 입증함으로써 중상 소송 및 기타 법적 도전에 대비할 수 있습니다. 게다가 신뢰성을 강조하는 평판은 뉴스 기관이 갖는 가장 가치 있는 자산 중 하나가 될 수 있습니다.\n\n6. 책임과 투명성 지원\n\n<div class=\"content-ad\"></div>\n\n정보의 원본이 명확히 문서화되고 접근할 수 있는 경우, 이는 언론과 그 대상에 대한 책임을 지지합니다. 이 투명성은 공개 인물과 기관이 행동에 대해 책임을 져야 함을 보장하며, 그들의 발언과 정보가 검증된 사실과 출처와 대조될 수 있도록 돕습니다.\n\n미디어와 뉴스에서 제공되는 오리진, 신뢰성, 그리고 정보의 정직성을 보장하는 핵심적인 수용 — 현대 언론과 정보 전파 아키텍처의 기반적인 기둥으로 기능합니다. 현실의 질서가 디지털 조작과 거짓된 이야기를 통해 왜곡될 수 있는 시대에, 뉴스 기사에 대한 검증 가능한 계보를 수립하는 것은 공중의 신뢰와 정보화된 시민성을 유지하는 데 중요합니다. 미디어에서의 오리진 보증은 흥미로운 내용을 그 소스와 맥락에 고정시키는 진리의 수호자 역할을 효과적으로 합니다. 각 뉴스 항목의 기원과 발전을 추적할 수 있는 강력한 메커니즘을 내장함으로써 소비자들은 신뢰성을 확인할 도구를 갖출 수 있습니다. 이것은 미술이나 고고학의 출처 프로토콜과 유사하여, 유물의 기원과 역사가 그 평가된 가치와 정토성에 중요한 역할을 합니다.\n\n\n![Part2SecuringtheFoundationsofMediaIntegrity_3](/assets/img/2024-05-16-Part2SecuringtheFoundationsofMediaIntegrity_3.png)\n\n\n블록체인과 디지털 워터마킹과 같은 기술들은 이 분야에서 중추적인 역할을 할 수 있습니다. 블록체인은 변경할 수 없는 장부 능력을 이용하여 뉴스 아이템의 수명주기를 기록하는 방법을 제공합니다. 각 단계는 타임 스탬프가 찍히고 생성자에게 연결될 수 있어, 어떤 수정 또는 추가 사항이 투명하고 책임 있게 할 수 있습니다. 반면 디지털 워터마킹은 디지털 콘텐츠에 직접 정보를 삽입하여 생성자의 신원과 콘텐츠의 정직성을 확인할 수 있게 하여, 어떤 조작이 감지될 수 있도록 합니다. 이러한 워터마크는 이동하는 콘텐츠와 함께 유지되어, 기원지로의 지속적이고 눈에 띄지 않는 연결을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n위 제안된 실제 실현 가능성에는 몇 가지 난관이 있을 수 있지만, 섭왜성을 보장하기 위한 이 이론적인 프레임워크는 진보적으로 보일 수도 있습니다. 첫째로, 기존 미디어 생산 및 배포 워크플로우에 이러한 시스템을 통합하는 기술적인 어려움이 있습니다. 이를 해결하면서 언론에게 중요한 속도와 효율을 해치지 않아야 합니다. 둘째로, 언론사, 기자, 그리고 궁극적으로 대중이 받아들이고 채택해야 하는 보다 넓은 문제가 있습니다. 궁극적으로 성공적으로 기능하기 위해서는 섭왜성 시스템이 산업 내에서 일반적으로 받아들여지고 신뢰돼야 합니다.\n\n게다가, 미디어에서의 섭왜성은 윤리적, 법적 고려 사항에도 영향을 미칩니다. 예를 들어, 민감한 뉴스 이야기에서의 언론 소스 보호는 콘텐츠 생성의 투명성이 필요한 필요와 균형을 이루어야 합니다. 마찬가지로, 뉴스 콘텐츠의 발전을 추적하고 기록하는 시스템을 개발할 때는 뉴스 이야기에 나오는 개인 및 조직의 사생활 권리를 고려해야 합니다.\n\n미디어에서 섭왜성을 보장하는 시스템의 사회적 영향은 깊습니다. 정보의 명확하고 검증 가능한 계보를 제공함으로써, 이러한 시스템은 가짜 정보와 오도전의 확산을 현저히 줄일 수 있습니다. 전통적인 미디어에 대한 신뢰가 침식되는 현대에는, 섭왜성이 신뢰를 회복하고 소비자들이 신뢰할 수 있는, 투명한 뉴스 소스를 기반으로 교육된 결정을 내릴 수 있도록 할 수 있습니다.\n\n미디어와 뉴스에서 섭왜성을 실현하는 것은 기술적인 문제뿐만 아니라 건강한 사회를 위한 필수 문화적 요구입니다. 점점 복잡해지는 정보의 풍경을 고려할 때, 뉴스의 근원 및 진위를 확인하는 능력은 부가적인 기능에 그치는 것이 아닌 자유롭고 정보화되고 민주적인 사회를 지키기 위한 필수 조건입니다. 궁극적으로, 미디어에서의 섭왜성 채택은 정보가 얼마나 가치 있고 신뢰되는지에 대한 철학적 전환이 요구됩니다. 이는 정보 소비가 함께 중요한 것이라는 콘텐츠 자체와 동등한 중요도를 갖게 하여, 보다 미래를 밝게 하는 공개적인 대화를 이끌 수 있습니다. 공개적인 대화는 진실과 투명성에 대한 공유된 약속을 바탕으로 한 더 현명한 공공 토론으로 이어질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nPart 1: 매체에서의 진실\n\nPart 3: 매체 소스 기록 제안","ogImage":{"url":"/assets/img/2024-05-16-Part2SecuringtheFoundationsofMediaIntegrity_0.png"},"coverImage":"/assets/img/2024-05-16-Part2SecuringtheFoundationsofMediaIntegrity_0.png","tag":["Tech"],"readingTime":7}],"page":"75","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}