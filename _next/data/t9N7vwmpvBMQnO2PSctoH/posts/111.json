{"pageProps":{"posts":[{"title":"리액트 언제 useRef 대신에 useState를 사용해야 할까요","description":"","date":"2024-05-14 12:13","slug":"2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState","content":"\n\nReact에서 useRef는 함수형 컴포넌트 내에서 DOM 요소나 다른 React 요소를 참조하는 데 사용되는 훅입니다. (이 훅을 사용하면 함수형 컴포넌트가 클래스 컴포넌트의 this.refs와 유사한 기능을 활용할 수 있습니다.)\n\nuseRef를 사용하면 컴포넌트의 렌더링 여부에 관계없이 동일한 참조를 유지할 수 있습니다. 컴포넌트가 다시 렌더링되더라도 참조가 변경되지 않도록 보장할 수 있어 유용합니다.\n\n예를 들어 useRef를 사용하여 특정 DOM 요소에 대한 참조를 얻어 해당 요소를 프로그래박적으로 조작할 수 있습니다.\n\n\n\n```js\nimport React, { useRef, useEffect } from 'react';\n\nconst MyComponent = () => {\n  const myRef = useRef(null);\n\n  useEffect(() => {\n    // 컴포넌트가 마운트될 때 DOM 요소에 포커스를 설정합니다.\n    myRef.current.focus();\n  }, []);\n\n  return <input ref={myRef} />;\n};\n\nexport default MyComponent;\n```\n\n이 예제에서 useRef를 사용하여 myRef 변수를 만들고 그것을 입력 요소에 할당합니다. useEffect 훅을 사용하여 컴포넌트가 마운트될 때 해당 요소에 포커스를 설정합니다. myRef.current 프로퍼티를 사용하여 기본 DOM 요소에 액세스합니다.\n\n그럼 언제 useState 대신 useRef를 사용해야 할까요?\n\nuseState와 useRef는 React Hooks에서 서로 다른 목적을 제공합니다.\n\n\n\nuseState: 컴포넌트의 상태를 관리하는 데 사용됩니다. 주로 컴포넌트의 상태가 변경될 때 다시 렌더링되기를 원할 때 사용됩니다. 상태가 변경되면 컴포넌트가 다시 렌더링됩니다. useRef: 렌더링과 직접적으로 관련이 없는 값을 유지해야 할 때 사용됩니다. 주로 DOM 요소에 대한 참조나 외부 라이브러리의 인스턴스와 같이 렌더링과 직접적으로 관련이 없는 값들을 저장하는 데 사용됩니다. 따라서 useState와 useRef는 각각의 사용 사례에 따라 선택되어져야 합니다.\n\nuseRef를 사용하는 일반적인 시나리오는 다음과 같습니다:\n\n렌더링과 관련이 없는 값들 저장하기 DOM 요소에 대한 참조 저장하기 값이 변경되더라도 다시 렌더링이 필요하지 않은 경우 더 잘 이해하기 위해 예시와 설명을 살펴보겠습니다.\n\nuseState의 예제\n\n\n\n```js\nimport React, { useState } from 'react';\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>카운트: {count}</p>\n      <button onClick={increment}>증가</button>\n    </div>\n  );\n};\n\nexport default Counter;\n```\n\n이 예제에서는 useState 훅을 사용하여 count 상태를 정의하고 업데이트하는 함수인 setCount를 정의합니다. count 상태가 컴포넌트의 렌더링에 직접적으로 영향을 주기 때문에 상태가 변경될 때마다 컴포넌트가 다시 렌더링됩니다.\n\nuseRef 예시\n\n```js\nimport React, { useRef, useEffect } from 'react';\n\nconst Timer = () => {\n  const intervalRef = useRef(null);\n  const secondsRef = useRef(0);\n\n  useEffect(() => {\n    intervalRef.current = setInterval(() => {\n      secondsRef.current += 1;\n      console.log('초:', secondsRef.current);\n    }, 1000);\n\n    return () => {\n      clearInterval(intervalRef.current);\n    };\n  }, []);\n\n  return (\n    <div>\n      <p>타이머: {secondsRef.current} 초</p>\n      <button onClick={() => clearInterval(intervalRef.current)}>정지</button>\n    </div>\n  );\n};\n\nexport default Timer;\n```\n\n\n\n이 예에서 useRef 훅을 사용하여 두 개의 레퍼런스를 생성합니다: intervalRef와 secondsRef입니다. intervalRef는 setInterval의 반환 값을 저장하며, secondsRef는 시간을 추적하는 데 사용됩니다. useEffect 훅은 컴포넌트가 마운트될 때 setInterval을 시작하고 언마운트될 때 정리합니다. secondsRef는 컴포넌트의 렌더링과는 관계없이 값을 유지하며, secondsRef.current는 현재 시간을 추적하고 표시하는 데 사용됩니다.\n\n이 두 예제는 useState가 컴포넌트의 상태를 관리하고 렌더링을 트리거하는 데 사용되는 반면, useRef는 렌더링과 직접적으로 관련되지 않는 값을 저장하거나 DOM 요소에 액세스하는 데 사용됨을 보여줍니다.\n\n데이터가 많을수록 useRef를 사용해야 하는 경우가 더 많아지며, 이번에는 동일한 프로그램의 예제를 통해 이를 확인해볼 것입니다.\n\nuseState를 이용한 예제:\n\n\n\n```js\nimport React, { useState } from 'react';\n\nconst BigDataComponent = () => {\n  const [data, setData] = useState('');\n\n  const fetchData = () => {\n    // 많은 양의 데이터를 가져오는 것을 가정\n    // 데이터가 증가함에 따라 렌더링이 지연될 수 있습니다\n    const newData = '아주 많은 데이터...';\n    setData(newData);\n  };\n\n  return (\n    <div>\n      <button onClick={fetchData}>데이터 가져오기</button>\n      <p>데이터 길이: {data.length}</p>\n    </div>\n  );\n};\n\nexport default BigDataComponent;\n```\n\n이 예제에서는 useState를 사용하여 데이터를 관리하고, 버튼을 클릭할 때마다 fetchData 함수를 호출하여 많은 양의 데이터를 가져옵니다. 그러나 데이터 양이 증가함에 따라 렌더링이 느려질 수 있습니다.\n\nuseRef를 사용한 예제\n\n```js\nimport React, { useRef } from 'react';\n\nconst BigDataComponent = () => {\n  const dataRef = useRef('');\n\n  const fetchData = () => {\n    // 많은 양의 데이터를 가져오는 것을 가정\n    // useRef를 사용하여 컴포넌트의 렌더링에 영향을 미치지 않고 데이터를 설정합니다\n    const newData = '아주 많은 데이터...';\n    dataRef.current = newData;\n  };\n\n  return (\n    <div>\n      <button onClick={fetchData}>데이터 가져오기</button>\n      <p>데이터 길이: {dataRef.current.length}</p>\n    </div>\n  );\n};\n\nexport default BigDataComponent;\n```\n\n\n\n이 예에서는 useRef를 사용하여 데이터를 관리합니다. 데이터 양이 증가해도 useRef를 사용하면 데이터를 설정할 때 컴포넌트의 렌더링 속도에 영향을 미치지 않습니다.\n\n이 두 예시를 통해 데이터 양이 증가할수록 useState는 느려질 수 있지만 useRef를 사용하면 데이터가 늘어나도 렌더링에 영향을 미치지 않고 데이터를 관리할 수 있다는 것을 알 수 있습니다.\n\n다시 말해, useRef의 중요한 특징 중 하나는 렌더링과 관련이 없는 값의 보존입니다.\n\n- 렌더링과 관련이 없는 값의 보존: useRef로 생성된 ref 객체의 current 프로퍼티에 할당된 값은 컴포넌트를 다시 렌더링해도 변경되지 않습니다. 이를 통해 useRef는 컴포넌트의 렌더링과는 독립적인 값을 유지할 수 있으며, 컴포넌트 상태와 관련이 없는 값을 보존하는 데 유용합니다.\n- 렌더링 주기 중 값이 변경되어도 다시 렌더링을 트리거하지 않음: useRef로 생성된 객체의 current 프로퍼티에 값이 렌더링 주기 중에 할당되더라도 컴포넌트는 다시 렌더링되지 않습니다. 따라서 useState와 달리 상태 업데이트가 렌더링을 트리거하지 않으므로 다시 렌더링 없이 값의 변화를 허용합니다. useRef를 사용하여 렌더링과 관련이 없는 값을 관리하거나 DOM 요소에 대한 참조나 외부 라이브러리의 인스턴스와 같이 렌더링과 관련이 없는 값들을 다루는데 유용합니다. 이러한 특징들은 useRef를 사용하여 컴포넌트 렌더링과는 독립적인 데이터를 관리하거나 DOM 요소에 접근할 때 매우 유용합니다.\n\n\n\n이를 효과적으로 활용하려면 React 렌더링에 대한 포괄적인 이해가 필수적입니다. 아래에는 React에서 렌더링이 작동하는 방식에 대한 기본 개념부터 최적화까지 간략한 개요가 있습니다.\n\n- 가상 DOM: 가상 DOM은 React에 의해 추상화된 실제 DOM의 가상 표현입니다. 상태 변경과 같은 이벤트가 발생하면 React는 가상 DOM을 업데이트하고 이를 실제 DOM과 비교하여 최소한의 작업을 적용하여 실제 DOM을 업데이트합니다. 이 과정은 성능을 향상시키고 불필요한 렌더링을 방지합니다.\n\n- 컴포넌트 렌더링 프로세스:\n\n  - 초기 렌더링: React 애플리케이션이 시작되면 컴포넌트 트리가 렌더링되어 초기 UI가 생성됩니다.\n  - 상태 또는 속성 변경: 사용자 상호작용과 같은 이벤트로 상태 또는 속성이 변경될 수 있습니다.\n  - 가상 DOM 업데이트: 상태 또는 속성이 변경되면 React는 해당 컴포넌트의 가상 DOM을 업데이트합니다. 필요없는 렌더링이나 DOM 조작을 최소화하기 위해 가상 DOM의 변경사항을 효율적으로 계산합니다.\n  - 실제 DOM 업데이트: 가상 DOM의 변경사항을 계산한 후 React는 실제 DOM과 비교하여 차이점을 식별하고 실제 DOM의 필요한 부분만 업데이트합니다. 이 최적화는 브라우저에서 불필요한 렌더링을 최소화합니다.\n\n- 렌더링 최적화: React는 성능을 최적화하기 위한 다양한 기술을 제공합니다:\n\n\n\n- PureComponent와 React.memo: 이들은 컴포넌트의 불필요한 다시 그리기를 방지하는 데 사용됩니다. PureComponent는 클래스 컴포넌트에 사용되며, React.memo는 함수형 컴포넌트에 사용됩니다.\n- shouldComponentUpdate 또는 React.memo를 사용한 컴포넌트 최적화: 이러한 방법을 사용하면 컴포넌트가 업데이트해야 하는 조건을 정의하여 다시 그리기를 제어하고 최적화할 수 있습니다.\n- 불변성 유지: 불변성을 유지함으로써 React는 상태가 변경될 때 새로운 객체를 생성하여 불필요한 다시 그리기를 방지합니다.\n\n이러한 렌더링 프로세스와 최적화 기술을 이해하면 효율적인 React 애플리케이션을 개발할 수 있습니다.\n\n다음 섹션에서는 더 나은 최적화를 위해 메모이제이션을 탐구할 것입니다.","ogImage":{"url":"/assets/img/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState_0.png"},"coverImage":"/assets/img/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 컨텍스트를 올바르게 활용하기","description":"","date":"2024-05-14 12:12","slug":"2024-05-14-UsingReactcontextstherightway","content":"\n\n리액트 컨텍스트는 리액트의 가장 강력하면서도 가장 오해를 많이 받는 기능 중 하나입니다. 많은 사람들이 useContext를 호출하거나 컴포넌트 내에서 직접 컨텍스트 제공자를 생성하는데, 이러한 방식은 코드베이스가 발전함에 따라 변경사항을 만들거나 파생 상태를 계산하기가 쉽지 않습니다.\n\n적어도 컴포넌트를 사용하는 내용물로 만들어져 상태 관리에 대해 독립적인 것이 중요합니다. 또한, 내부에서 파생된 상태를 계산하고 호춣을 통해 컴포넌트에 노출하는 데 아주 좋습니다.\n\n![이미지](/assets/img/2024-05-14-UsingReactcontextstherightway_0.png)\n\n# 컨텍스트를 작성하는 방식의 관용적인 방법\n\n\n\n제공자를 먼저 작성해 보겠습니다. 블로깅 앱 예시를 들겠습니다. 여러 다른 구성 요소에서 접근할 수 있도록 일부 게시물 필터링 상태를 저장해야 하는 상황입니다.\n\n이를 위해 특정 구성 요소 및 훅만 내보낸 별도의 파일에서 수행합니다. 이를 통해 캡슐화를 보장합니다. 코드를 사용하는 사람이 내부적으로 컨텍스트를 사용하고 있는지 알 필요가 없습니다. 이는 이후 쉬운 구현 변경을 가능하게 합니다.\n\n상태는 일반적인 useState 호출로 구현되며, 값과 설정자는 useMemo로 생성된 객체 내에 설정되고 이 객체는 Provider의 값 속성에 제공됩니다.\n\n그런 다음 동일한 파일에서 훅을 구현할 수 있습니다.\n\n\n\n저희 코드를 사용하는 사용자가 제공자를 설정하지 않았을 때(when useContext returns null) 다루는 훅이 하나 있습니다. 이것은 구현 세부 정보이므로 훅은 내보내지 않고, 이 파일 내에서 훅을 사용할 때만 사용됩니다.\n\n저희는 두 가지 훅을 내보냅니다. 하나는 컨텍스트의 읽기 전용 속성만 제공하는 것이며, 저희 앱에서 이 상태를 읽기만 하는 곳이 많을 것을 알고 있기 때문입니다. 마지막으로 읽기 및 쓰기 속성(전체 컨텍스트)을 모두 제공하는 훅이 있습니다. 아마도 여기서 필터를 업데이트하는 버튼이 있는 곳에서 사용될 것입니다.\n\n이제 포스트 목록을 표시하는 페이지 상단에 제공자를 설정할 수 있습니다:\n\n그리고 이제 아래의 컴포넌트 어디에서나 사용할 준비가 되었습니다:\n\n\n\n훅 또는 프로바이더를 사용한 곳에서는 React의 네이티브 컨텍스트 익스포트인 useContext나 Context.Provider 같은 것을 사용하지 않았습니다. 이를 통해 코드를 작은 부분만 수정하여 필터 상태의 동작에 대한 전역 변경을 수행할 수 있게 되었습니다.\n\n한 가지씩 몇 가지 예시를 살펴보겠습니다.\n\n## URL에 상태 저장하기\n\n두 개의 훅만 변경하여 이제 필터 상태가 URL에 저장됩니다. 페이지를 새로고침해도 필터가 유지됩니다. useSearchParam 훅이 이미 있어야 한다고 가정하며, 웹에서 많은 구현을 찾을 수 있습니다.\n\n\n\n## 로컬 스토리지에 상태 저장하기\n\n마찬가지로, 우리는 상태를 로컬 스토리지에 저장하여 페이지 새로고침 간에 지속될 수 있도록 할 수 있습니다.\n\n마지막 두 예제는 전역 상태 저장소(URL 또는 로컬 스토리지)에 의존하므로, 제공자를 잊고 소비자 수준에서만 훅을 사용하여 작동합니다:\n\n이 경우에는 useLocalStorage 또는 useSearchParams 훅이 여러 곳에 장착된 이 훅의 여러 인스턴스간 동기화를 다룰 수 있도록 잘 구현되어야 함을 주의하십시오.\n\n\n\n## 파생 상태 노출 및 사용자 정의 작업 노출하기\n\nProvider + useState 변형으로 돌아오면, context 내에서 캡슐화된 파생 상태 및 사용자 정의 작업을 쉽게 추가할 수 있습니다.\n\n다시 한 번 강조하지만, 코드를 사용할 때는 내부에서 무슨 일이 일어나고 있는지 몰라도 useHasFilters 또는 useResetFilters를 호출할 수 있습니다. 모든 상태 관리는 UI 구성 요소 외부에서 단일 파일에서 처리합니다.\n\n이전 예제마다 URL이나 로컬 저장소에 상태를 저장하거나 사용자 정의 파생 상태와 작업을 추가하는 등 상태 관리 변경을 수행할 수 있었습니다. 이를 통해 상태를 사용하는 수천 곳의 대규모 앱이라도 한 파일만 수정하면 됩니다. Redux나 Zustand와 같은 상태 관리 도구를 직접 사용할 때는 이러한 작업이 불가능합니다.\n\n\n\n# 컨텍스트 생성을 덜 번거롭게 만들기\n\n일부 사람들은 컨텍스트가 너무 말이 많다고 주장합니다. 사실 그래요. 하지만 저는 캡슐화되었을 때 추가되는 가치와 비교했을 때, 한 파일에만 영향을 미치는 추가적인 말이 많음은 그랬다간 않다고 생각해요.\n\n그래도, 한 줄로 컨텍스트를 만드는 기술이 있답니다: 컨텍스트 팩토리 기술이죠.\n\n앞서 한 모든 것들을 하나의 함수로 감싸는 것을 볼 수 있어요. 또한, 함수 내에서 인터페이스도 만들고 제네릭을 사용할 수 있게 해줍니다. 그리고, 우리가 상태의 초기 값을 프로바이더의 속성으로 전달한다는 것을 주목해주세요.\n\n\n\n다음과 같이 전역 범위에서 사용할 수 있습니다:\n\n이제 이전의 모든 것을 하나의 코드 라인으로 갖고 있습니다 😃✨. 이것은 일반 useState처럼 거의 동일하지만, 특정 제공자 하위 모든 사용자 사이에서 공유됩니다. 이렇게 하면 모듈식 \"의사 전역\" 상태를 매우 쉽게 생성할 수 있습니다.\n\n여러 값을 저장해야 하는 경우에는 여러 제공자를 생성하거나 하나의 제공자 내에 (작은) 객체를 넣어야 합니다.\n\n## 기타 장점\n\n\n\n요약을 위해 모든 것을 다 다루진 않았지만, 다른 장점으로는 다음과 같은 것이 있습니다:\n\n- 다중 공급자 사용 가능: 각 공급자마다 상태가 복제됩니다 (전역 범위에서 상태를 생성하는 Redux, Recoil 등에서 불가능한 것입니다)\n- 중첩된 공급자 사용 가능: React 문서에 이에 대한 예제가 있습니다. 한 공급자는 같은 유형의 부모 컨텍스트를 찾아 중첩 수준을 알 수 있습니다.\n- 내부적으로 상태 관리 라이브러리 사용 가능: 공급자는 Zustand, Recoil 또는 Redux를 내부적으로 사용하여 UI 구성 요소에 특정 라이브러리 기능을 노출하지 않고 무용의 리렌더링을 피할 수 있습니다.\n- 데이터베이스에 상태 저장 가능한 경우, useState 또는 라이브러리와 같은 클라이언트 상태 관리 도구없이 모두 서버 상태에서 처리할 수 있습니다.\n\n# 결론\n\n캡슐화와 함께 올바르게 사용한다면 컨텍스트는 매우 강력한 도구입니다. 그들의 장황함은 도우미 함수로 완화될 수 있습니다.\n\n\n\n내 프로젝트에서 사용하는 도우미 함수가 있어요. 렌더 프롭과 외부 상태를 받아들일 수 있는 추가 기능을 가지고 있어서, 이를 참고하여 영감을 받을 수 있을 거에요.","ogImage":{"url":"/assets/img/2024-05-14-UsingReactcontextstherightway_0.png"},"coverImage":"/assets/img/2024-05-14-UsingReactcontextstherightway_0.png","tag":["Tech"],"readingTime":4},{"title":"스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기","description":"","date":"2024-05-14 12:09","slug":"2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs","content":"\n\n다음.js, Stream 및 Chatscope를 사용하여 매력적이고 인터랙티브한 라이브 스트리밍 채팅 앱을 만드는 방법을 배워보세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png)\n\n언제나 YouTube와 같은 라이브 스트리밍에서 발견되는 다이나믹한 채팅 경험을 어떻게 만들 수 있을지 궁금해했는데, 누구나 로그인 없이 참여할 수 있는 편리함을 더한 기능을 추가하고 싶었습니다.\n\nNext.js와 Stream을 사용하여 그 경험을 성공적으로 만들어냈습니다. 이 튜토리얼에서는 사용자 권한에 대한 세밀한 제어를 통해 실시간 상호작용을 보다 접근하기 쉽게 만드는 라이브 스트리밍 채팅 환경을 만드는 간단한 방법을 다루고 있습니다.\n\n\n\n# 데모\n\n기술적인 내용에 들어가기 전에, 이 튜토리얼에서 무엇을 만들게 될지 간단히 소개해 드릴게요 👇🏻\n\n# 준비물\n\n구현을 시작하기 위해 다음이 필요합니다:\n\n\n\n- Node.js 18 또는 그 이후 버전\n- Stream 계정\n- Vercel 계정\n\n# 새 Stream 애플리케이션 설정하기\n\n이 섹션에서는 새 Stream 애플리케이션을 생성하고, 인증 없이 사용자를 활성화하며, 사용자 권한을 정의하여 채널에 대한 읽기 및 게시를 설정하는 방법을 배울 수 있습니다. 시작해봅시다.\n\nStream 계정을 만들고 로그인한 후, + 앱 만들기를 클릭하여 Stream 채팅 애플리케이션 생성을 시작해보세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_1.png\" />\n\n어플리케이션 이름을 입력해주세요. 또한, 웹사이트 배포 지역/기능 근처의 채팅 저장 위치를 선택해주세요. 저는 인도에 있으므로 뭄바이로 설정했습니다.\n\n<img src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_2.png\" />\n\n설정이 완료되면 채팅 개요 화면으로 이동합니다. API 키를 복사하고, 안전한 장소에 저장하여 Next.js 애플리케이션에서 NEXT_PUBLIC_STREAM_API_KEY로 계속 사용할 수 있도록 해주세요.\n\n\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_3.png)\n\n권한 확인 없이 방문자가 채팅 메시지를 게시할 수 있도록 하려면 아래로 스크롤하여 \"인증 확인 비활성화\" 토글 버튼을 활성화하세요. 변경 사항을 동기화하려면 제출을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_4.png)\n\n방문자가 특정 채널의 사용자로서 메시지를 게시할 수 있도록 하려면 그들을 위해 읽기 및 게시 권한을 활성화해야 합니다. 방문자가 채팅 애플리케이션에서 가정할 수 있는 역할과 권한을 구성할 수 있도록 하는 것이 매우 유용합니다.\n\n\n\n사용자 역할을 선택하고 메시징을 스코프로 선택한 다음 편집 버튼을 클릭하여 방문자의 권한을 구성하실 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_5.png)\n\n방문자가 메시지를 게시할 수 있도록 하려면 메시지 생성을 검색하고 \"메시지 생성\" 권한을 활성화하여 채널의 모든 사용자가 메시지를 보낼 수 있도록 허용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_6.png)\n\n\n\n방문자들이 채팅 기록을 읽을 수 있도록 하려면 'read channel'을 검색하여 Read Channel 및 Read Channel Members를 활성화하세요. 이렇게 하면 방문자가 메시지를 읽을 뿐만 아니라 해당 메시지를 게시한 사용자도 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_7.png)\n\n마지막으로 변경 사항을 동기화하려면 저장을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_8.png)\n\n\n\n이제 방문자가 할 수 있는 것들의 권한과 범위를 구성하는 것을 마쳤습니다. 이제 Chatscope UI Kit을 사용하여 Next.js에서 채팅 사용자 인터페이스를 구축해 봅시다.\n\n# 새 Next.js 애플리케이션 설정\n\n이 섹션에서는 새로운 Next.js 애플리케이션을 생성하는 방법, shadcn/ui를 설정하는 방법, 해당 애플리케이션의 요구 사항을 파악하여 빠른 구현을 위해 관련 라이브러리를 설치하는 방법을 배우게 될 것입니다.\n\n새로운 Next.js 프로젝트를 생성하는 것으로 시작해 봅시다. 터미널을 열고 다음 명령을 실행하세요:\n\n\n\n```js\r\nnpx create-next-app@latest my-chat-app\r\n```\r\n\r\n진행할 때, 다음을 선택하세요:\r\n\r\n- TypeScript를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- ESLint를 사용할 것인지 물으면 \"No\"를 선택하세요.\r\n- Tailwind CSS를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- src/ 디렉토리를 사용할 것인지 물으면 \"No\"를 선택하세요.\r\n- App Router를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- 기본 import alias를 맞춤 설정할 것인지 물으면 \"No\"를 선택하세요.\r\n\r\n위 과정을 마치면 프로젝트 디렉토리로 이동하여 다음 명령어를 실행하여 개발 모드에서 앱을 시작할 수 있습니다:\n\n\n\n```js\ncd my-chat-app\nnpm run dev\n```\n\n앱은 localhost:3000에서 실행 중이어야 합니다.\n\n이제 프로젝트의 루트에 .env 파일을 만드세요. 위 섹션에서 저장한 항목들을 추가할 것입니다.\n\n다음과 같이 보여야 합니다:\n\n\n\n```js\n# .env\n\n# 스트림 환경 변수\nNEXT_PUBLIC_STREAM_API_KEY=\"...\"\n\n```\n\n## shadcn/ui 컴포넌트 통합\n\n채팅 사용자 인터페이스를 빠르게 프로토타입화하기 위해 Next.js와 함께 shadcn/ui를 설정할 것입니다. shadcn/ui는 아름답게 디자인된 컴포넌트들의 모음으로, 여러분의 애플리케이션에 복사하여 붙여넣을 수 있습니다. 아래 명령어를 실행하여 shadcn/ui를 설정하세요:\n\n```js\nnpx shadcn-ui@latest init\n```\n\n\n\n구성 파일 components.json을 구성하는 몇 가지 질문에 답해야합니다. 다음을 선택하세요:\n\n- TypeScript를 사용하것이라고 하면 \"예\"를 선택하세요.\n- 사용할 스타일을 선택하라는 프롬프트가 나오면 \"기본\"을 선택하세요.\n- 기본 색상으로 선택하라는 프롬프트가 나오면 \"Slate\"를 선택하세요.\n- 색상에 CSS 변수를 사용하냐고 묻힐 경우 \"예\"를 선택하세요.\n\n위 작업이 완료되면, Next.js 애플리케이션에 React 구성 요소를 쉽게 추가할 수 있는 CLI가 설정됩니다. 아래 명령어를 실행하여 버튼, 입력란, 그리고 텍스트영역 요소를 가져올 수 있습니다.\n\n```js\nnpx shadcn-ui@latest add button\nnpx shadcn-ui@latest add input\nnpx shadcn-ui@latest add textarea\n```\n\n\n\n그것이 끝나면 이제 app/components 디렉토리 안에 ui 디렉토리가 보일 것입니다. 그 안에 button.tsx, input.tsx, textarea.tsx 파일이 있습니다.\n\n## Chatscope 및 Stream UI Kit를 React에 설치하기\n\n구현을 더 쉽게 만들기 위해 필요한 작업을 이제 알아봅시다.\n\n먼저, 각 방문자가 익명 사용자로 취급되므로 임의로 생성된 이름(id)으로 그들을 식별해야 합니다. 또한 채널에서 받은 각 메시지는 실시간으로 모든 방문자에게 전파되어야 합니다. 마지막으로, 모든 메시지가 채널로 들어오는 메시지로 표시되도록 해야 합니다.\n\n\n\n위의 요구 사항을 충족하기 위해 다음 명령을 실행하여 필요한 라이브러리를 설치하세요:\n\n```js\nnpm install @chatscope/chat-ui-kit-react\nnpm install stream-chat stream-chat-react\nnpm install unique-username-generator\n```\n\n다음 라이브러리가 설치됩니다:\n\n- unique-username-generator: 고유한 사용자 이름을 생성하는 패키지입니다.\n- stream-chat: Stream의 JavaScript API 클라이언트입니다.\n- stream-chat-react: Stream Chat을 위한 React 훅(그리고 컴포넌트) 라이브러리입니다.\n- @chatscope/chat-ui-kit-react: 채팅 UI의 프로토타입을 위한 React 컴포넌트 라이브러리입니다.\n\n\n\n자, 이제 반응형 채팅 사용자 인터페이스를 만들어 봅시다.\n\n# ChatScope와 Stream을 사용하여 채팅 사용자 인터페이스 만들기\n\n이 섹션에서는 방문자를 특정 채널에 연결하고, 채팅 기록을 렌더링하고, 메시지를 게시할 수 있도록 하는 React 컴포넌트를 구축하는 방법을 배우게 될 것입니다.\n\n먼저, 채팅 메시지 목록을 동적으로 렌더링하는 React 컴포넌트를 만들어 봅시다. Stream 및 Chatscope 라이브러리에서 컴포넌트를 사용할 것입니다.\n\n\n\n앱 디렉토리에 Messages.tsx 파일을 만들어서 아래 코드를 넣어주세요:\n\n```js\nimport { cn } from \"@/lib/utils\";\nimport { useChannelStateContext } from \"stream-chat-react\";\nimport { Message, MessageList } from \"@chatscope/chat-ui-kit-react\";\n\nexport default function () {\n  const { messages } = useChannelStateContext();\n  return (\n    <MessageList>\n      {messages?.map((i, index: number) => (\n        <Message\n          key={i.id}\n          model={{\n            position: \"normal\",\n            sender: i.user?.id,\n            direction: \"incoming\",\n            message: `${i.user?.id}: ${i.text}`,\n            sentTime: i.created_at?.toString(),\n          }}\n          className={cn(\n            \"bg-white rounded text-black py-2 text-xs\",\n            index !== messages.length - 1 && \"border-b\"\n          )}\n        />\n      ))}\n    </MessageList>\n  );\n}\n```\n\n`useChannelStateContext` 훅을 사용하여 채팅 기록을 가져오고 새로운 메시지를 수신할 수 있습니다. `MessageList` 및 `Message` Chatscope UI 구성 요소를 사용하여 모든 메시지를 채널로 수신하도록 표시하고, 발신자 정보, 메시지 내용 및 타임스탬프와 매핑할 수 있습니다.\n\n이제 사용자가 채팅 기록을 볼 수 있고 메시지를 동시에 게시할 수 있는 경로를 작성해봅시다. 앱 디렉토리의 page.tsx 파일을 아래 코드로 업데이트해주세요:\n\n\n\n```js\n\"use client\";\n\nimport { useState } from \"react\";\nimport Messages from \"./Messages\";\nimport { Button } from \"@/components/ui/button\";\nimport { Channel, Chat } from \"stream-chat-react\";\nimport { Textarea } from \"@/components/ui/textarea\";\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n  return (\n    <div className=\"flex max-w-[300px] flex-col gap-y-3 p-5\">\n      <div className=\"flex w-[300px] flex-col gap-y-3\">\n        <span className=\"border-b border-gray-100 font-semibold\">채팅</span>\n        {channel && (\n          <Chat client={chatClient}>\n            <Channel channel={channel}>\n              <Messages />\n            </Channel>\n          </Chat>\n        )}\n        <Textarea\n          id=\"message_text\"\n          name=\"message_text\"\n          placeholder=\"메시지...\"\n          className=\"min-h-[100px] w-full\"\n        />\n        <Button className=\"max-w-max\">\n          메시지 보내기 &rarr;\n        </Button>\n      </div>\n    </div>\n  );\n}\n```\n\n이제 새 메시지 렌더링 및 방문자로부터 입력을 받을 수 있는 textarea 요소가 있는 인덱스 라우트를 볼 수 있습니다. 메시지를 게시하는 기능을 구현하기 전에 해당 메시지를 고유한 ID와 연결하려고 할 것입니다. 다음과 같이 코드를 업데이트하십시오:\n\n```js\n\"use client\";\n\nimport Messages from \"./Messages\";\n+ import { useEffect, useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Channel, Chat } from \"stream-chat-react\";\n+ import { DevToken, StreamChat } from \"stream-chat\";\nimport { Textarea } from \"@/components/ui/textarea\";\n+ import { generateUsername } from \"unique-username-generator\";\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n+ const loadChatClient = async () => {\n+   const newChatClient = new StreamChat(\n+     process.env.NEXT_PUBLIC_STREAM_API_KEY,\n+     {\n+       enableWSFallback: true,\n+     }\n+   );\n+    if (newChatClient.user) await newChatClient.disconnectUser();\n+   const localUser = localStorage.getItem(\"local_user\");\n+   if (!localUser) localStorage.setItem(\"local_user\", generateUsername());\n+   const id = localStorage.getItem(\"local_user\");\n+   const userToConnect = { id };\n+   await newChatClient.connectUser(userToConnect, DevToken(userToConnect.id));\n+   setChatClient(newChatClient);\n+ };\n+ useEffect(() => {\n+   loadChatClient();\n+ }, []);\n  return (\n    <div className=\"flex max-w-[300px] flex-col gap-y-3 p-5\">\n      {/* 나머지 컴포넌트는 그대로 유지 */}\n    </div>\n  );\n}\n```\n\n이제 loadChatClient 함수를 한 번 호출하여 웹소켓 연결을 Stream의 메시징 채널로 활성화했습니다. 그런 다음 세션과 연관된 사용자를 연결 해제합니다. 마지막으로, 방문자를 위해 고유한 사용자명을 생성합니다 (localStorage에 없는 경우). 이러한 단계를 통해 방문자가 고유하게 식별됨을 보장합니다.\n\n\n\n특정 채널의 메시지를 청취하려면 다음과 같이 코드를 업데이트하세요:\n\n```js\n\"use client\";\n\n// Imports as is\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n+  const watchChannel = () => {\n+    const channel = chatClient.channel(\"messaging\", \"livestreaming_chat\", {\n+      name: \"실시간 스트리밍 채팅\",\n+    });\n+    channel.watch().then(() => setChannel(channel));\n+  };\n  const loadChatClient = async () => {\n    const newChatClient = new StreamChat(\n      process.env.NEXT_PUBLIC_STREAM_API_KEY,\n      {\n        enableWSFallback: true,\n      }\n    );\n    if (newChatClient.user) await newChatClient.disconnectUser();\n    const localUser = localStorage.getItem(\"local_user\");\n    if (!localUser) localStorage.setItem(\"local_user\", generateUsername());\n    const id = localStorage.getItem(\"local_user\");\n    const userToConnect = { id };\n    await newChatClient.connectUser(userToConnect, DevToken(userToConnect.id));\n    setChatClient(newChatClient);\n  };\n  useEffect(() => {\n    loadChatClient();\n  }, []);\n+  useEffect(() => {\n+    if (chatClient) watchChannel();\n+  }, [chatClient]);\n  return (\n    <div className=\"flex max-w-[300px] flex-col gap-y-3 p-5\">\n      {/* 나머지 컴포넌트는 동일한 상태로 유지 */}\n    </div>\n  );\n}\n```\n\n방문자는 이제 livestreaming_chat 고유 ID로 식별되는 Live Stream Chat 채널에 연결되었습니다. 그런 다음 watch() 유틸리티를 사용하여 수신된 메시지를 청취하고 컨텍스트를 업데이트합니다.\n\n채널에 메시지를 게시하려면 다음과 같이 코드를 업데이트하세요:\n\n\n\n```js\n\"use client\";\n\n// 그대로 가져오기\n\nexport default function () {\n  // 변수, 훅 그대로\n  return (\n    <div className=\"flex max-w-[300px] flex-col gap-y-3 p-5\">\n      <div className=\"flex w-[300px] flex-col gap-y-3\">\n        {/* 컴포넌트 나머지 */}\n        <Button\n          className=\"max-w-max\"\n          onClick={() => {\n            if (channel) {\n              channel.sendMessage({\n                text: document.getElementById(\"message_text\").value,\n              });\n              document.getElementById(\"message_text\").value = \"\";\n            }\n          }\n        >\n          Send Message &rarr;\n        </Button>\n      </div>\n    </div>\n  );\n}\n```\n\nonClick 이벤트에서 sendMessage 유틸리티를 사용하여 방 정보에 메시지를 게시할 수 있습니다. 깔끔하게 구현했네요!\n\n이제 손님이 방문자를 위해 고유한 ID를 무작위로 생성하고 메시지 목록을 동적으로 렌더링하며 메시지를 게시할 수 있는 반응형 채팅 인터페이스를 완성했습니다. 이제 Next.js 애플리케이션을 Vercel에 배포합시다.\n\n# Vercel에 배포하기\n\n\n\n이제 코드를 Vercel에 배포할 준비가 되었습니다. 아래 단계를 따라 배포하세요:\n\n- 먼저 앱 코드가 포함된 GitHub 저장소를 만듭니다.\n- 그런 다음 Vercel 대시보드로 이동하여 새 프로젝트를 만듭니다.\n- 새 프로젝트를 방금 만든 GitHub 저장소에 연결합니다.\n- 설정에서 환경 변수를 로컬 .env 파일과 일치하도록 업데이트합니다.\n- 배포를 클릭합니다.\n\n# 마치며\n\n요약하면, 이 튜토리얼은 Next.js와 Stream을 통합하여 동적 실시간 채팅 환경을 구축하는 방법에 대한 포괄적인 안내를 제공합니다. 사용자가 인증 없이 참여할 수 있도록 허용하고 권한을 세밀하게 제어하여 실시간 상호작용을 보다 쉽게 만드는 방법을 배웠습니다.\n\n\n\n# 더 많은 정보\n\n더 자세한 통찰력을 얻으려면 이 게시물에서 인용된 참고 자료를 살펴보세요.\n\n- GitHub 저장소\n- 챗스코프 UI 킷\n- 인증되지 않은 사용자 - 스트림\n- 채널 시청 - 스트림","ogImage":{"url":"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png"},"coverImage":"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png","tag":["Tech"],"readingTime":12},{"title":"한국어 Axios 인터셉터란 무엇인가요","description":"","date":"2024-05-14 12:08","slug":"2024-05-14-ENWhatareAxiosInterceptors","content":"\n\n![Axios Interceptors](/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png)\n\n인터셉터란 무엇인가요?\n인터셉터는 프로그램의 기능을 확장하거나 수정하는 데 사용되는 디자인 패턴입니다. Axios에서 인터셉터는 HTTP 요청과 응답을 처리하는 데 사용되는 특별한 함수입니다. 요청 인터셉터를 사용하면 요청을 보내기 전에 작업을 수행할 수 있고, 응답 인터셉터는 서버에서 반환된 응답에 작업을 수행할 수 있습니다.\n\nAxios 인터셉터를 사용해야 하는 이유는 무엇인가요?\n\n- 재사용성과 모듈성.\n- 오류 처리 용이성.\n- 보안 제어 및 인가 유효성 검사 프로세스 용이성.\n- 네트워크 문제 처리.\n- 사용 편의성과 유연성.\n- 성능 및 최적화.\n\n\n\nAxios Interceptors의 사용법\n간단한 사용법을 가지고 있고 Axios 내에서 추가 설정이 필요하지 않아 장점을 제공합니다.\n\n```js\nconst axiosInstance = axios.create({\n  baseURL: 'https://api.example.com',\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': null\n  }\n});\n\naxiosInstance.interceptors.request.use(\n  function (config) {\n    // 요청을 보내기 전 수행할 작업\n    console.log('요청을 보냅니다:', config);\n    \n    // 예를 들어, 각 요청에 세션 식별자를 추가할 수 있습니다.\n    const accessToken = localStorage.getItem('accessToken');\n    if (accessToken) {\n      config.headers.Authorization = `Bearer ${accessToken}`;\n    }\n\n    return config;\n  }, \n  function (error) {\n    // 요청 오류 발생 시 수행할 작업\n    console.error('요청 오류:', error);\n    return Promise.reject(error);\n  }\n);\n\naxiosInstance.interceptors.response.use(\n  function (response) {\n    // 응답이 성공했을 때 수행할 작업\n    console.log('응답:', response.data);\n    return response;\n  },\n  function (error) {\n    // 응답 오류 발생 시 수행할 작업\n    console.error('응답 오류:', error);\n    \n    // 예를 들어, 401 (Unauthorized) 오류 발생 시 세션이 만료된 것으로 가정할 수 있습니다.\n    if (error.response.status === 401) {\n      // 세션 새로 고침이나 로그인 페이지로 리다이렉트하는 등의 작업 수행 가능\n      console.log('세션이 만료되었습니다. 리다이렉트 중...');\n      // 예를 들어, 사용자를 로그인 페이지로 리다이렉트:\n    }\n    return Promise.reject(error);\n  }\n);\n\n// 예시 요청\n\naxiosInstance.get('/data')\n  .then(response => {\n    console.log('응답:', response.data);\n  })\n  .catch(error => {\n    console.error('오류:', error);\n  });\n\naxiosInstance.post('/post-data', {\n  // 전송할 데이터\n  firstName: 'John',\n  lastName: 'Doe'\n})\n.then(response => {\n  console.log('응답:', response.data);\n})\n.catch(error => {\n  console.error('오류:', error);\n});\n```\n\n🚀🚀 이 예시처럼 들어오는 오류를 잡아 사용자에게 반환하거나 페이지 간에 리다이렉트할 수 있습니다.\n콘솔에서 각 요청의 오류와 본문을 쉽게 보고 조치할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-14-ENWhatareAxiosInterceptors_1.png\" />\n\n\n\n### 이전 게시물","ogImage":{"url":"/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png"},"coverImage":"/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png","tag":["Tech"],"readingTime":3},{"title":"BEM에 익숙해지기","description":"","date":"2024-05-14 12:07","slug":"2024-05-14-GettingComfortablewithBEM","content":"\n\n이번 서킷에서 첫 번째 토픽은…. BEM! BEM이 뭐냐고 물을 수도 있겠죠? BEM은 HTML을 위한 클래스를 만드는 데 사용되는 방법론으로, 보다 깔끔하고 명확한 CSS 구조로 이어집니다. 이것은 제가 직전 프로젝트를 제 강사들에게 제출했을 때 생긴 굉장한 문제 때문에 저의 집착의 대상이 되었어요... 그것은 엉망이었고, 그런 일은 더 이상 허용되지 않아야 했죠.\n\n제 클래스 이름과 CSS가 의미가 있었죠… 버튼을 만들어야 했을 때, 기본 버튼을 만들고 약간 바꾼 버튼을 위한 다른 클래스를 만들었어요. 주로 내 메인 `a`는 특정한 방식으로 보이도록 설정을 하지만, 다른 hover 효과를 주고 싶은 앵커를 위해 a.purple-hover를 만들었어요. 결국, 제가 개별 요소를 위한 많은 클래스를 만들어 CSS 파일을 수백 줄짜리 HTML 파일에 수천 줄의 코드를 작성하고 있었어요.\n\n클래스 스타일을 조직하는 더 나은 방법을 찾아야 했고, 다른 개발자가 살펴보더라도 보다 빨리 이해할 수 있도록 페이지를 더 이해하기 쉽게 만들어야 했어요. 몇 분 동안 기사를 찾아보고 유튜브를 뒤지던 중, BEM을 발견했어요. Block-Element-Modifier는 기본 값, 해당 값의 변경 및 위치를 명확하게 정의하는 방법입니다. BEM을 해석하고 사용 사례 및 구현 방법을 설명하는 가장 좋은 설명은 https://en.bem.info/methodology/css/에서 찾았어요. 꼭 한 번 읽어보시고 이미 사용하고 있지 않다면 직접 구현해보는 것을 강력히 추천드립니다.\n\n기사를 그대로 소화할 생각은 없으니, 다시 한 번 읽는 것을 강력히 추천합니다. 제가 다룰 내용은 어떻게 BEM을 처음부터 적용할 것인지입니다. 작업하고 싶은 개인 프로젝트가 있어요, 개인 블로그 페이지(얼마나 진부한지 알죠)를 만들어서 게시하고, 게시한 내용을 모든 주요 블로그 사이트에 자동으로 업데이트할 수 있는 시스템을 구축할 거에요. 참고할 예시를 북마크하고 위의 링크를 저장해서 방법론을 준수하며 진행할 것이에요. 진행 상황은 여기에 업데이트할 거예요.\n\n\n\n제가 예시를 제대로 제공하지 않고 코드 조각을 포함하지 않은 것을 알고 있어요. 그러나 이번 주에 다른 주에서 12시간씩 일하고 호텔로 출퇴근해야 하는 일을 시작해서 조정 중입니다. 제가 계속 학습하고 블로깅을 진행할 수 있게 하는 것에 감사하게 생각해요. 개인 프로젝트에 착수할 때 BEM을 어떻게 사용하는지 보여줄 거예요. 그러나 반복해서 말씀드렸듯이, 위에 언급한 기사를 읽어보세요. 정말 흥미로워요.\n\n다음에 만나요, 여러분의 하드해트를 쓴 블루 칼라 코더 세르지오 파렐 / 페럴 코드예요. 좋은 밤 되세요, 그리고 계속 코딩하세요.","ogImage":{"url":"/assets/img/2024-05-14-GettingComfortablewithBEM_0.png"},"coverImage":"/assets/img/2024-05-14-GettingComfortablewithBEM_0.png","tag":["Tech"],"readingTime":2},{"title":"GraphQL 및 MongoDB와 React","description":"","date":"2024-05-14 12:05","slug":"2024-05-14-GraphQLandMongoDBwithReact","content":"\n\n![그림](/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png)\n\n웹 개발자들의 세계에서는 계속해서 최고의 개발 및 웹 응용 프로그램의 기능을 보여줄 수 있는 것을 찾기 위한 노력이 계속되고 있습니다. 오래된 REST API의 대안으로 최근에 인정받게 된 새롭고 흥미로운 기술이 GraphQL입니다. REST가 한 요청에 대해 자주 단일 데이터 세트를 반환하는데 반해, GraphQL은 클라이언트가 원하는 특정 데이터를 요청할 수 있습니다. 따라서 데이터 전송을 줄이는 것뿐만 아니라 서버 측 응답을 빠르고 간단하게 만드는 두 가지 과정으로 이루어집니다. GraphQL과 MongoDB의 조합은 데이터 처리에 있어 유연하고 효율적인 조합을 제공합니다. 이 멋진 GraphQL과 MongoDB의 조합은 개발자들이 동적 웹 응용 프로그램을 디자인하고 관리하는 방식에 혁명을 일으키고 있습니다.\n\n# GraphQL의 힘\n\nGraphQL의 가장 큰 장점은 그 유연성입니다. 개발자들은 쿼리를 최적화하여 필요한 모든 데이터를 한 군데서 얻을 수 있습니다. 이로 인해 REST API에 대해 여러 차례의 연이은 요청이 필요하지 않아집니다. 현재 장치의 다양성 및 네트워크 조건의 변동성에 매우 중요합니다.\n\n\n\nGraphQL, MongoDB 및 React가 웹 개발의 주요 도구로 사용될 때, 이러한 도구들은 개발 프로세스를 자동화할 수 있게 되었습니다. 이것은 완전히 다르게 만듭니다. 문서 중심의 NoSQL 데이터베이스 시스템인 MongoDB는 대량의 비구조화 정보를 처리하는 우수한 옵션을 제공하며, 동적이고 구조화되지 않은 GraphQL 요청을 쿼리하는 데 매우 빠르고 유연합니다. React의 선언 기반 특성을 활용하여 사용자 인터페이스를 구축하고 응용 프로그램의 상태를 처리하는 것은 매우 적합합니다. React는 데이터베이스에서 사용자 인터페이스로 실시간 데이터를 제공하여 GraphQL의 동적이고 견고한 특성을 보완합니다.\n\n본 글에서는 GraphQL을 통해 MongoDB와 통신하고 React 애플리케이션을 통합하는 과정, GraphQL 서버 설정 방법 및 데이터베이스 상호작용을 최적화하기 위한 최선의 방법에 대해 살펴보겠습니다. 이러한 기술의 결합을 통해 프로그래밍 시간을 최소화하고 애플리케이션의 유지 보수를 간소화할 뿐만 아니라, 고성능 및 확장 가능한 웹 애플리케이션을 구축할 수 있는 기회를 제공합니다.\n\n# GraphQL 기초\n\n2015년 Facebook 팀이 설계한 GraphQL은 API용 쿼리 언어로 볼 수 있으며, 동시에 제공된 데이터를 기반으로한 쿼리 실행 메커니즘을 제공합니다. 이를 통해 기업은 API 데이터를 완전하고 의미 있게 설명하여 고객이 정확히 필요한 것만 요청할 수 있도록 합니다. 결과적으로 네트워크 개선으로 이어지고, 네트워크 부하가 줄어듭니다.\n\n\n\n# 스키마와 타입\n\nGraphQL 스키마는 API의 중심 요소입니다. GraphQL 스키마는 데이터 유형과 그들 사이의 관계를 정의하며, 따라서 쿼리는 클라이언트가 원하는 것과 정확히 일치하도록 구성됩니다. 설명은 목록처럼 보이며 위치에는 유형이 있을 수 있습니다. 그들은 더 유연하고 복잡한 데이터 구조를 만들 수 있도록 유형의 유형일 수도 있습니다.\n\n# 쿼리\n\nGraphQL의 쿼리는 정적 특성 모음과 달리, GraphQL에서는 일치하는 스키마에서 제공된 유형에 해당하는 모든 데이터를 포함할 수 있습니다. GraphQL의 경우 클라이언트는 자주 REST API에서 발생하는 불필요한 정보 전달 없이 정확히 필요에 맞는 방식으로 데이터를 검색할 수 있습니다.\n\n\n\nGraphQL에서의 예시 쿼리는 다음과 같을 수 있어요:\n\n```js\n{\n  user(id: \"1\") {\n    name\n    email\n    friends {\n      name\n    }\n  }\n}\n```\n\n이 쿼리는 사용자의 이름, 이메일, 그리고 친구들의 이름에 대한 정보만 요청하고, 사용자와 친구들에 대한 다른 모든 정보는 제외합니다.\n\n# 뮤테이션(mutations)\n\n\n\nGraphQL에서 돌연변이는 데이터를 수정하는 데 사용됩니다. 쿼리와 마찬가지로 돌연변이는 스키마에 의해 정의되며 클라이언트가 데이터를 정확하고 제어된 방식으로 변경할 수 있도록 합니다. 돌연변이는 다음과 같이 보일 수 있습니다:\n\n```js\nmutation {\n  addUser(name: \"John Doe\", email: \"john@example.com\") {\n    id\n    name\n    email\n  }\n}\n```\n\n이 예제에서 addUser 돌려변이는 지정된 이름과 이메일 주소를 가진 새로운 사용자를 추가하고 새로 생성된 사용자에 대한 정보를 반환합니다.\n\n# Subscriptions\n\n\n\n서브스크립션은 GraphQL의 중요한 부분으로, 클라이언트가 원하는 데이터에 대한 실시간 알림을 받을 수 있는 기능을 제공합니다. 이는 대화방이나 게임과 같이 데이터의 지속적인 업데이트가 필요한 애플리케이션에서 특히 유용합니다. GraphQL의 서브스크립션은 다음과 같이 구현할 수 있습니다:\n\n```js\nsubscription {\n  messageAdded(channelId: \"1\") {\n    id\n    content\n    sender {\n      name\n    }\n  }\n}\n```\n\n채널에 새로운 게시물이 추가될 때, 모든 구독자는 즉시 게시물의 세부 정보를 포함한 알림을 받습니다.\n\n# REST와의 비교\n\n\n\nREST에서 볼 수 있는 데이터의 형태와 볼륨을 결정하는 데 서버가 가지는 고민과는 달리, GraphQL에서는 실제로 데이터를 요청하는 것이 클라이언트에 달려 있습니다. 이는 검색된 데이터를 필요한 것만으로 줄이고 데이터 상호작용이 어떻게 일어나는지에 대한 클라이언트의 제어를 더 많이 제공합니다. 이 GraphQL의 기능은 오늘날 고성능과 속도를 요구하는 웹 애플리케이션에 이상적입니다.\n\n# GraphQL 서버 구성\n\nMongoDB 및 React와 결합하여 GraphQL의 모든 잠재력을 실현하는 첫 번째 단계는 GraphQL 서버를 생성하는 것입니다. 이 섹션에서는 이 접근 방식을 사용하여 서버를 생성하고 실행하는 방법을 배우게 됩니다. 이 스택은 React 및 Apollo Client를 사용하여 프런트엔드 애플리케이션, Express 및 Apollo Server를 사용하는 백엔드, 그리고 Mongoose 라이브러리를 통해 서버리스 Mongo DB로 구성됩니다.\n\n# 단계 1: 몇 가지 설치 의존성을 추가하여 프로젝트를 개인화하세요.\n\n\n\n첫 번째로, 새로운 노드를 생성하세요. 먼저 새 브라우저 인스턴스를 열고 JS 프로젝트를 수행해야 하는 설치 페이지로 이동한 다음 필요한 패키지를 설치해주세요. 터미널을 열고 다음 명령을 실행하세요:\n\n```js\nmkdir graphql-mongo-server\ncd graphql-mongo-server\nnpm init -y\nnpm install apollo-server-express express graphql mongoose\n```\n\n이러한 명령은 프로젝트를 위한 새 디렉토리를 생성하고, 새로운 Node.js 프로젝트를 초기화하며 필요한 종속성을 설치합니다.\n\n# 단계 2: Express 및 Apollo Server 구성\n\n\n\n`index.js` 파일을 만들고 Express 서버 구성 및 GraphQL 쿼리를 처리하기 위해 Apollo Server를 통합하세요.\n\n```js\n// index.js\n\nconst express = require('express');\nconst { ApolloServer, gql } = require('apollo-server-express');\n\nconst app = express();\n\n// GraphQL 스키마 정의\nconst typeDefs = gql`\n  type Query {\n    hello: String\n  }\n`;\n\n// 리졸버 구현\nconst resolvers = {\n  Query: {\n    hello: () => '안녕, 세상아!'\n  }\n};\n\n// Apollo 서버 생성\nconst server = new ApolloServer({ typeDefs, resolvers });\n\n// Express 미들웨어에 Apollo 적용\nserver.applyMiddleware({ app });\n\nconst PORT = 4000;\napp.listen(PORT, () =>\n  console.log(`서버가 http://localhost:${PORT}${server.graphqlPath} 에서 실행 중입니다.`)\n);\n```\n\n# Step 3: MongoDB 연결\n\nMongoose를 사용하여 프로젝트에 MongoDB를 추가하세요. 이를 위해 `index.js` 파일을 업데이트하여 데이터베이스에 연결하는 코드를 추가하세요.\n\n\n\n```js\nconst mongoose = require('mongoose');\n\n// MongoDB에 연결\nmongoose.connect('mongodb://localhost:27017/mygraphqlapp', {\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n});\nmongoose.connection.once('open', () => {\n  console.log('MongoDB 데이터베이스에 연결되었습니다');\n});\n```\n\n로컬호스트:27017/mygraphqlapp를 귀하의 데이터베이스 연결 문자열로 교체해 주세요.\n\n# 단계 4: GraphQL 모델 및 스키마 정의\n\nMongoose 데이터 모델의 정의를 형식화하고 이러한 모델을 사용하여 GraphQL 스키마를 설정합니다. 예를 들어, 사용자 모델을 생성하고 이를 GraphQL 스키마에 추가합니다.\n\n\n\n\n```js\n// Mongoose 사용자 모델 정의\nconst User = mongoose.model('User', new mongoose.Schema({\n  name: String,\n  email: String,\n  age: Number\n}));\n\n// GraphQL 스키마 확장\nconst typeDefs = gql`\n  type User {\n    id: ID!\n    name: String\n    email: String\n    age: Int\n  }\n  type Query {\n    users: [User]\n  }\n  type Mutation {\n    addUser(name: String!, email: String!, age: Int): User\n  }\n`;\nconst resolvers = {\n  Query: {\n    users: () => User.find({})\n  },\n  Mutation: {\n    addUser: async (_, { name, email, age }) => {\n      const user = new User({ name, email, age });\n      await user.save();\n      return user;\n    }\n  }\n};\n```\n\n이러한 단계를 통해 MongoDB 연결이 준비된 기본 GraphQL 서버를 생성할 수 있습니다. React 애플리케이션과 효율적으로 상호작용하는 쿼리 및 뮤테이션을 처리하기 위해 이 서버를 사용할 수 있습니다.\n\n# React에서의 GraphQL 통합\n\nGraphQL 서버를 설정하면 다음으로 할 일은 해당 서버를 React 앱과 통합하는 것입니다. Apollo Client를 통해 GraphQL 서버에 쉽게 쿼리 및 뮤테이션을 수행할 수 있어 MongoDB 데이터와 동적 상호작용을 가능하게 할 수 있습니다. 이 경우에는 React에 Apollo Client를 추가하고 이 섹션에서 몇 가지 작업을 찾아보는 방법을 살펴볼 것입니다.\n\n\n\n\n# 단계 1: Apollo Client 설치하기\n\n먼저 React 프로젝트에 필요한 Apollo Client 패키지를 설치해보세요:\n\n```js\nnpm install @apollo/client graphql\n```\n\n# 단계 2: Apollo Client 사용자 정의하기\n\n\n\nApollo Client의 인스턴스를 생성하고 React 애플리케이션에 연결해보세요. 이를 위해 다음 코드를 ApolloClient.js와 같은 파일에 추가해주세요:\n\n```js\nimport { ApolloClient, InMemoryCache, HttpLink, from } from '@apollo/client';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:4000/graphql' // 여러분의 GraphQL 서버 URL로 교체해주세요\n});\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: from([httpLink])\n});\nexport default client;\n```\n\n# 단계 3: Apollo Provider 통합\n\nReact 앱을 ApolloProvider로 감싸서 쿼리와 뮤테이션을 앱의 모든 컴포넌트에서 사용할 수 있게 만들어보세요. App.js에서:\n\n\n\n```js\nimport React from 'react';\nimport { ApolloProvider } from '@apollo/client';\nimport client from './ApolloClient';\nimport Users from './components/Users';\n\nfunction App() {\n  return (\n    <ApolloProvider client={client}>\n      <div className=\"App\">\n        <h1>GraphQL and React</h1>\n        <Users />\n      </div>\n    </ApolloProvider>\n  );\n}\nexport default App;\n```\n\n# 단계 4: 쿼리와 뮤테이션 만들고 사용하기\n\nGraphQL과 상호 작용하기 위해 useQuery와 useMutation 훅을 사용하는 React 컴포넌트를 만듭니다. 사용자를 표시하고 새 사용자를 추가하는 컴포넌트 예제:\n\n```js\nimport React, { useState } from 'react';\nimport { useQuery, useMutation, gql } from '@apollo/client';\n\nconst GET_USERS = gql`\n  query {\n    users {\n      id\n      name\n      email\n    }\n  }\n`;\n\nconst ADD_USER = gql`\n  mutation AddUser($name: String!, $email: String!) {\n    addUser(name: $name, email: $email) {\n      id\n      name\n      email\n    }\n  }\n`;\n\nfunction Users() {\n  const { data, loading, error } = useQuery(GET_USERS);\n  const [addUser] = useMutation(ADD_USER);\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error :(</p>;\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n    if (name && email) {\n      await addUser({ variables: { name, email } });\n      window.location.reload(); // 추가 후 간단히 페이지 새로고침\n    }\n  };\n  return (\n    <div>\n      <form onSubmit={handleSubmit}>\n        <input\n          type=\"text\"\n          placeholder=\"이름\"\n          value={name}\n          onChange={e => setName(e.target.value)}\n        />\n        <input\n          type=\"email\"\n          placeholder=\"이메일\"\n          value={email}\n          onChange={e => setEmail(e.target.value)}\n        />\n        <button type=\"submit\">사용자 추가</button>\n      </form>\n      <ul>\n        {data && data.users.map(user => (\n          <li key={user.id}>{user.name} - {user.email}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\nexport default Users;\n```\n\n\n\n본 코드는 React 애플리케이션에서 GraphQL을 사용하여 데이터를 가져와 서버로 전송하는 예시입니다. 주어진 예시는 당신의 애플리케이션의 더 정교한 요구사항과 기능에 맞게 개선하고 일반화할 수 있습니다.\n\n# 실제 예시: 할 일 앱\n\n이어서, 웹 개발 기초를 학습하는 초보자들에게 표준 연습으로 사용되는 To-Do 애플리케이션을 만들어 봅시다. 이 특정 섹션에서는 우리의 프론트엔드로 React를 구현하고 데이터 관리를 위해 GraphQL을 사용하며, 데이터 저장소로 MongoDB를 사용할 간단한 Todo 애플리케이션을 만들어 보겠습니다. 이 프로젝트는 작업 생성, 편집 및 삭제와 같은 항목을 다룰 것입니다.\n\n# 단계 1: MongoDB 데이터베이스 구성하기\n\n\n\nMongoDB를 설치하여 작업 데이터를 저장하는 것이 첫 번째 단계입니다. Mongoose를 사용하여 MongoDB에 Todo 항목을 위한 스키마를 만듭니다:\n\n```js\nconst mongoose = require('mongoose');\n\nconst { Schema } = mongoose;\n\nconst todoSchema = new Schema({\n  text: String,\n  completed: Boolean\n});\n\nconst Todo = mongoose.model('Todo', todoSchema);\n```\n\n# 단계 2: GraphQL 스키마 만들기\n\nTodo 요소를 관리하는 데이터 유형, 쿼리 및 뮤테이션을 포함하는 GraphQL 스키마를 정의합니다.\n\n\n\n```js\n상수 { gql } = require ('apollo-server-express')를 가져와주세요.\n\nconst typeDefs = gql`\n  type Todo {\n    id: ID!\n    text: String!\n    completed: Boolean!\n  }\n  type Query {\n    todos: [Todo]\n  }\n  type Mutation {\n    addTodo(text: String!): Todo\n    updateTodo(id: ID!, completed: Boolean!): Todo\n    deleteTodo(id: ID!): Todo\n  }\n`;\n\n# 단계 3: 리졸버 구현하기\n\n다음 단계는 GraphQL을 위한 리졸버를 구현하는 것인데, 이는 데이터베이스와 상호작용하는 논리를 제공합니다.\n\nconst resolvers = {\n  Query: {\n    todos: () => Todo.find({})\n  },\n  Mutation: {\n    addTodo: async (_, { text }) => {\n      const todo = new Todo({ text, completed: false });\n      await todo.save();\n      return todo;\n    },\n    updateTodo: async (_, { id, completed }) => {\n      return Todo.findByIdAndUpdate(id, { completed }, { new: true });\n    },\n    deleteTodo: async (_, { id }) => {\n      return Todo.findByIdAndRemove(id);\n    }\n  }\n};\n```\n\n\n\n# 단계 4: Apollo Client를 통합하여 React와 통합\n\nReact 애플리케이션에 Apollo Client를 통합하고 작업을 표시 및 관리하는 컴포넌트를 만듭니다:\n\n```js\nimport React from 'react';\nimport { useQuery, useMutation, gql } from '@apollo/client';\n\nconst GET_TODOS = gql`\n  query {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst ADD_TODO = gql`\n  mutation AddTodo($text: String!) {\n    addTodo(text: $text) {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nfunction Todos() {\n  const { data, loading, error } = useQuery(GET_TODOS);\n  const [addTodo] = useMutation(ADD_TODO);\n\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error :(</p>;\n\n  const handleAddTodo = async text => {\n    if (text) {\n      await addTodo({ variables: { text } });\n    }\n  };\n\n  return (\n    <div>\n      <ul>\n        {data.todos.map(todo => (\n          <li key={todo.id}>\n            {todo.text}\n          </li>\n        ))}\n      </ul>\n      <button onClick={() => handleAddTodo('새 작업 추가')}>작업 추가</button>\n    </div>\n  );\n}\n\nexport default Todos;\n```\n\n# 단계 5: 사용자 인터페이스 구현\n\n\n\n간단한 사용자 인터페이스를 React로 개발해보세요. 사용자들이 작업을 추가하고 완료된 것으로 표시하거나 작업을 삭제할 수 있게 만들어보세요. 복잡한 양식이나 버튼을 사용하여 작업을 구성할 필요는 없습니다.\n\n위에서 언급된 조치들은 React 애플리케이션과 GraphQL 서버 간에 완전한 통신을 제공하며 데이터베이스로 MongoDB를 사용합니다. 이를 통해 빠르고 효율적으로 작동하는 애플리케이션이 생성됩니다.\n\n# 결론\n\n따라서, 우리는 GraphQL, MongoDB 및 React를 결합하는 방법을 찾았습니다. 이 두 기술의 결합은 웹 애플리케이션의 성능을 실제로 향상시키며 개발 복잡성을 크게 줄일 수 있습니다. 이 기술 스택을 중요시하는 몇 가지 주요 포인트를 살펴봅시다.\n\n\n\n# GraphQL을 사용해야 하는 이유\n\n- 요청한 대로: GraphQL을 사용하면 필요한 데이터만 요청할 수 있어서 불필요한 데이터 없이 작업할 수 있습니다. 이는 더 적은 데이터 전송 및 빠른 페이지 로딩으로 이어집니다.\n- 한 곳을 통해 모두 처리: REST API의 여러 엔드포인트에 작별을 고한다면, GraphQL은 하나의 통합된 지점을 통해 통신하여 코드를 추적 가능하고 아키텍처를 더욱 명료하게 만듭니다.\n- 실시간 업데이트: GraphQL을 사용하면 채팅이나 협업과 같이 데이터가 지속적으로 업데이트되는 기능을 쉽게 구현할 수 있습니다.\n\n\n# GraphQL을 강력하게 만드는 것은 무엇인가요?\n\n- 유연성과 강력함: MongoDB는 데이터 저장을 유연하게 제공하며, 반면에 React는 사용자 인터페이스를 유연하게 구축하는 데 도움을 줍니다. 이 두 가지를 팀으로 사용하면 모든 요구 사항에 손쉽게 조정될 수 있는 좋은 조합이 될 수 있습니다.\n- 개발이 쉬워짐: 이 스택은 GraphQL API의 명확한 규칙 덕분에 코드를 줄이고 개발 단계마다 확신을 키울 수 있도록 도와줍니다.\n\n\n\n# GraphQL과 MongoDB의 성능 영향\n\nGraphQL, React, 그리고 MongoDB가 함께 작동하면 여러분의 일상이 간소화되고 응용 프로그램은 더 빠르게 반응합니다. 쿼리 최적화는 서버 및 네트워크 부하를 줄이고 데이터 처리 속도를 높여 인터페이스를 더 반응적으로 만듭니다. 따라서 사용자들의 눈에 띄게 제품 품질을 향상하는 중요한 요소입니다.\n\n요약하면, 더 강력한 웹 응용 프로그램을 만들고 싶다면 더 빠르고 개발하기 쉬운 웹 응용 프로그램을 만들어야 한다면 GraphQL, MongoDB 및 React의 세트가 반드시 필요합니다. 이것은 분명히 수익성이 입증된 프로젝트의 미래에 대한 장기적인 투자입니다!","ogImage":{"url":"/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png"},"coverImage":"/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png","tag":["Tech"],"readingTime":13},{"title":"로컬 Gemma 모델과 연결하는 LM Studio를 통한 간단한 React 앱 UI","description":"","date":"2024-05-14 12:04","slug":"2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio","content":"\n\n로컬 데이터를 Gemma를 통해 LM Studio로 처리함으로써 정보를 외부 서버로 보내지 않고 제어할 수 있습니다. 이 방식은 민감한 문서나 개인 데이터를 다룰 때 데이터 개인 정보 보호와 보안을 보장합니다. 이 기사에서는 로컬 LLM과 상호작용하기 위해 간단한 React 앱 GUI를 사용하는 방법을 살펴보겠습니다.\n\nLM Studio 및 Gemma 모델 설치\n\n```js\nhttps://lmstudio.ai/\n```\n\nWindows / Linux / Mac 버전을 다운로드하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_0.png)\n\n이제 노트북/PC/서버에 적합한 모델을 찾아보세요.\n\n우리는 Gemma Model을 사용하고 있습니다. 이는 기계 학습에 경험이 제한된 개발자들에게도 쉽게 사용할 수 있습니다. 그들의 가벼운 특성은 접근성이 높고 사용하기 편리합니다.\n\n![이미지](/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_1.png)\n\n\n\n다운로드 후에는 왼쪽 메뉴에서이 모델을 로컬 서버에서 제공하는 옵션을 찾을 수 있습니다. 선택한 후 위쪽 드롭다운에서 사용 가능한 로컬 모델 목록을 선택하고 \"서버 시작\"을 클릭할 수 있습니다. 오른쪽 메뉴에서는 로컬 모델의 설정을 사용자 정의할 수 있습니다. 샘플 코드 섹션에서 API Curl 명령을 볼 수 있습니다. 로컬호스트 URL 및 API의 매개변수가 표시됩니다.\n\n![이미지](/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_2.png)\n\n이제 LM Studio 설정이 완료되었으며 Gemma 모델이 로컬 API로 이용 가능해졌습니다.\n\n간단한 React App GUI를 작성하여 Gemma 모델의 로컬 LM Studio API와 상호 작용해 보겠습니다. 나중에 이 코드를 사용하여 직접 응용 프로그램에서 사용할 수 있습니다.\n\n\n\nReact GUI\n\n설정\n\n여기서는 React 앱에 Vite를 사용하고 있습니다.\n\n```js\nnpm create vite@latest\n```\n\n\n\n프롬프트 메뉴에서 Framework를 React로, Variant를 Javascript로 선택하고 해당 디렉토리로 이동하여 설치하세요.\n\n```js\nnpm install\n```\n\n앱을 미리 보기하려면 다음을 실행하세요.\n\n```js\nnpm run dev\n```\n\n\n\n웹 브라우저를 열고 http://localhost:5173/ 로 이동하세요.\n\n무료 사이트에서 lens.png 및 loading.gif 두 개의 이미지를 다운로드하여 assets 디렉토리에 추가하세요.\n\n이제 아래 코드를 사용하여 3개 파일을 업데이트하세요.\n\nApp.jsx\n\n\n\n```js\nimport { useState, useEffect } from 'react'\nimport reactLogo from './assets/react.svg'\nimport viteLogo from '/vite.svg'\nimport './App.css'\nimport lens from \"./assets/lens.png\";\nimport loadingGif from \"./assets/loading.gif\";\n\nfunction App() {\n\n  const [prompt, updatePrompt] = useState(undefined);\n  const [loading, setLoading] = useState(false);\n  const [answer, setAnswer] = useState(undefined);\n\n  useEffect(() => {\n    if (prompt != null && prompt.trim() === \"\") {\n      setAnswer(undefined);\n    }\n  }, [prompt]);\n\n  const sendPrompt = async (event) => {\n    if (event.key !== \"Enter\") {\n      return;\n    }\n\n    try {\n      setLoading(true);\n\n      const requestOptions = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(\n          \n          { \n            model: \"lmstudio-ai/gemma-2b-it-GGUF\", \n            temperature : 0.7,\n            max_tokens : -1,\n            messages: [ { role : \"user\", content : `${prompt}` },] \n          },\n        ),\n      };\n\n      const res = await fetch(\"/api/v1/chat/completions\", requestOptions);\n  \n      if (!res.ok) {\n        throw new Error(\"Something went wrong\");\n      }\n      const testresp = await res.json();\n      console.log(testresp.choices[0].message.content);\n      setAnswer(testresp.choices[0].message.content);\n\n    } catch (err) {\n      console.error(err, \"err\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <>\n      <div>\n        <a href=\"https://vitejs.dev\" target=\"_blank\">\n          <img src={viteLogo} className=\"logo\" alt=\"Vite logo\" />\n        </a>\n        <a href=\"https://react.dev\" target=\"_blank\">\n          <img src={reactLogo} className=\"logo react\" alt=\"React logo\" />\n        </a>\n      </div>\n      <h1>React Chat LLM UI</h1>\n      <input\n            type=\"text\"\n            className=\"searchlight__input\"\n            placeholder=\"Ask me anything and press enter...\"\n            disabled={loading}\n            style={\n              backgroundImage: loading ? `url(${loadingGif})` : `url(${lens})`,\n            }\n            onChange={(e) => updatePrompt(e.target.value)}\n            onKeyDown={(e) => sendPrompt(e)}\n          />\n\n        <div className=\"searchlight__answer\">{answer && <p>{answer}</p>}</div>\n\n    </>\n  )\n}\n\nexport default App\n```\n\nApp.css\n\n아래 코드로 기존의 App.css를 업데이트하세요. 원하시는 대로 사용자 정의할 수 있습니다.\n\n```js\n#root {\n  max-width: 1280px;\n  margin: 0 auto;\n  padding: 2rem;\n  text-align: center;\n}\n\n.logo {\n  height: 6em;\n  padding: 1.5em;\n  will-change: filter;\n  transition: filter 300ms;\n}\n.logo:hover {\n  filter: drop-shadow(0 0 2em #646cffaa);\n}\n.logo.react:hover {\n  filter: drop-shadow(0 0 2em #61dafbaa);\n}\n\n@keyframes logo-spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n@media (prefers-reduced-motion: no-preference) {\n  a:nth-of-type(2) .logo {\n    animation: logo-spin infinite 20s linear;\n  }\n}\n\n.card {\n  padding: 2em;\n}\n\n.read-the-docs {\n  color: #888;\n}\n\n.searchlight__input {\n  display: block;\n  height: 56px;\n  width: 80%;\n  border: 0;\n  border-radius: 12px;\n  outline: none;\n  font-size: 1.2rem;\n  color: #000;\n  background-position: left 17px center;\n  background-repeat: no-repeat;\n  background-color: #fff;\n  background-size: 3.5%;\n  padding-left: 60px;\n}\n\n.searchlight__input::placeholder {\n  line-height: 1.5em;\n}\n\n.searchlight__answer {\n  min-height: 115px;\n  line-height: 1.5em;\n  letter-spacing: 0.1px;\n  padding: 10px 30px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.searchlight__answer p::after {\n  content: \"\";\n  width: 2px;\n  height: 14px;\n  position: relative;\n  top: 2px;\n  left: 2px;\n  background: black;\n  display: inline-block;\n  animation: cursor-blink 1s steps(2) infinite;\n}\n\n@keyframes cursor-blink {\n  0% {\n    opacity: 0;\n  }\n}\n```\n\n\n\nLM Studio Local API를 호출하기 위해 Gemma를 업데이트하려면 Vite 구성 파일을 수정하십시오.\n\nvite.config.js\n\n```js\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:1234\",\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, \"\"),\n        onBeforeSend(proxyContext) {\n          const { req, res } = proxyContext;\n          const { url, method, headers, rawBody } = req;\n          return proxyContext;\n        },\n      },\n    },\n  },\n});\n```\n\n샘플 출력:\n\n\n\n![이미지](/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_3.png)\n\n대체 도구: Ollama는 로컬 서버에서 오픈 소스 모델을 호스팅하는 또 다른 도구입니다.\n\n다음 글에서는 문서를 업로드하고 채팅하는 방법을 알아보겠습니다.\n\n해보고 느낀 점은 댓글로 공유해주세요.","ogImage":{"url":"/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_0.png"},"coverImage":"/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트 컴포넌트 이해하기 함수 vs 클래스  모듈화된 UI 만들기를 간단하게 만들기","description":"","date":"2024-05-14 12:03","slug":"2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple","content":"\n\n리액트에서 컴포넌트는 사용자 인터페이스의 주요 구성 요소입니다. 이를 사용하면 UI를 독립적이고 재사용 가능한 조각으로 나눌 수 있으며, 각각이 자체 동작 및 렌더링 로직을 캡슐화합니다. 이 모듈식 접근 방식은 애플리케이션을 유지하고 확장하기 쉽게 만들어줍니다.\n\n![이미지](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_0.png)\n\n리액트에서 컴포넌트는 두 가지 주요 방법으로 정의할 수 있습니다: Function Components(함수 컴포넌트)와 Class Components(클래스 컴포넌트).\n\n# Function Components\n\n\n\n기능 구성 요소는 복잡한 상태 관리나 라이프사이클 메서드에 액세스할 필요가 없는 컴포넌트에 권장되며 더 간단합니다. 이들은 본질적으로 React 엘리먼트를 반환하는 JavaScript 함수입니다. 기본 예제를 살펴보겠습니다:\n\n![Welcome function component example](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_1.png)\n\n이 예제에서 Welcome은 프롭스 객체를 수락하고 간단한 인사 메시지인 React 엘리먼트를 반환하는 함수 컴포넌트입니다. 이 컴포넌트는 이름 프롭을 전달하여 UI에서 사용할 수 있습니다:\n\n![Using the Welcome function component](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_2.png)\n\n\n\n# 클래스 구성요소\n\n클래스 구성요소는 더 많은 기능을 가지고 있으며, 구성요소가 상태를 관리하거나 라이프사이클 이벤트를 처리해야 할 때 사용됩니다. 이들은 React.Component를 확장한 ES6 클래스로 정의되어 있어야 하며, React 요소를 반환하는 render() 메서드를 반드시 포함해야 합니다:\n\n![Class Components](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_3.png)\n\n이 Welcome 클래스 구성요소는 위에서 보여진 함수 구성요소와 유사하게 작동하지만 클래스로 정의되어 있습니다. 또한 render 메서드 내에서 this.props를 사용하여 props에 액세스합니다.\n\n\n\n# 컴포넌트 조합하기\n\n컴포넌트는 출력에서 다른 컴포넌트를 참조할 수 있습니다. 이 조합 기능은 리액트의 강력한 기능 중 하나로, 간단한 구성 요소에서 복잡한 UI를 구축할 수 있게 합니다. 다음은 Welcome 컴포넌트를 사용하여 부모 App 컴포넌트 안에 넣은 예제입니다:\n\n![이미지](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_4.png)\n\n이 App 컴포넌트는 세 개의 다른 이름을 가진 Welcome 컴포넌트를 렌더링하여, 컴포넌트가 다른 속성(props)과 함께 재사용될 수 있는 방법을 보여줍니다.\n\n\n\n# 컴포넌트 추출하기\n\n자주 컴포넌트가 너무 복잡해지면 작은 컴포넌트로 추출하는 것이 좋은 방법입니다. 예를 들어, Comment 컴포넌트가 있다면 Avatar와 UserInfo 컴포넌트를 추출하여 Comment 컴포넌트를 단순화할 수 있습니다:\n\n![Component Extraction](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_5.png)\n\n이 예에서 Avatar 및 UserInfo는 Comment 컴포넌트의 특정 부분을 처리하는 작은 컴포넌트이며, 주 컴포넌트를 더 깔끔하고 관리하기 쉽게 만듭니다.\n\n\n\n# 결론\n\nReact 컴포넌트는 동적이고 인터랙티브한 사용자 인터페이스를 구축하는 강력하고 다재다능한 도구입니다. 함수 컴포넌트와 클래스 컴포넌트를 이해하고 활용하며, 구성과 추출을 통해 잘 정리되고 유지보수가 쉬운 React 애플리케이션을 만들 수 있습니다.\n\n# 관련 기사\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해 주시면 좋겠어요! 👏\n- 다음 링크에서 우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 저희 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 기반 콘텐츠를 다루는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_0.png"},"coverImage":"/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_0.png","tag":["Tech"],"readingTime":3},{"title":"마이크로 프론트엔드 Vite를 이용한 React용 모듈 페더레이션","description":"","date":"2024-05-14 12:00","slug":"2024-05-14-MicroFrontendModuleFederationwithViteforReact","content":"\n\n![image](/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_0.png)\n\n백엔드 개발자를 위한 마이크로서비스 아키텍처 소개 후, 우리는 프론트엔드 애플리케이션을 위한 비슷한 아키텍처인 '마이크로 프론트엔드'를 개발하고자 합니다. 이 아키텍처는 마이크로서비스와 비슷한 이점과 단점을 가지고 있습니다. 이 아키텍처를 구현하는 방법 중 하나는 웹팩과 Vite와 같은 번들링 도구에서 제공되는 '모듈 페데레이션'입니다.\n\n# 모듈 페데레이션이란?\n\n모듈 페데레이션은 다양한 빌드가 하나의 애플리케이션을 구성하기 위해 함께 동작하는 개념입니다. 대부분의 경우 하나는 모든 다른 원격 구성 요소를 가져와 공유할 수 있도록 구축된 호스트 애플리케이션일 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_1.png\" />\n\n위의 도식은 작동 방식에 대한 간략한 설명을 보여줍니다. 호스트 애플리케이션에는 각 원격 컴포넌트에 대한 참조가 가져오기(import)나 Lazy Loaded 모듈로 포함됩니다. 각각 \"홈페이지 앱\"과 \"결제 앱\"이 호스팅된 원격 서버에서 공유 컴포넌트는 자바스크립트 모듈로 패키징되어 빌드된 자바스크립트 파일로써 공개적으로 사용 가능합니다(위의 예제에서 \"homepage.js\"와 \"payment.js\"로 확인됨). 그런 다음 호스트 애플리케이션에서 이러한 원격 컴포넌트들을 런타임에 자바스크립트 모듈로 가져와서 호스팅된 애플리케이션에서 컴포넌트로 처리됩니다.\n\n모듈 페더레이션에 대한 더 자세한 내용은 여기서 확인할 수 있습니다.\n\n# Vite에서 모듈 페더레이션을 사용하는 방법?\n\n\n\n모듈 연합 기능을 얻으려면 Vite에 플러그인을 추가해야 합니다. 플러그인은 다음에서 찾을 수 있어요!\n\n모듈 연합 기능을 얻기 위해 설정해야 할 최소한 두 군데가 항상 있어요. 하나는 공유할 컴포넌트가 있는 원격 어플리케이션에 적용돼야 해요. 이 곳에서 Vite에게 어떤 컴포넌트가 모듈로 공유될지, 빌드를 위한 진입점 이름이 무엇인지 알려주는 것이에요. 다른 설정은 모듈 연합을 사용할 호스트 어플리케이션에서 적용돼야 해요.\n\n양쪽에 적용해야 할 구성은 다음과 같아요.\n\n## 원격 어플리케이션 기본 구성\n\n\n\n```js\nexport default defineConfig({\n    plugins: [\n        react(),\n        federation({\n             name: 'remotecomponent1',\n             filename: 'remotecomponent1.js',\n             exposes: {\n                 './Button': './src/components/buttons.tsx'\n             },\n             shared: ['react', 'react-dom', 'react-router-dom'],\n        }),\n    ]\n});\n```\n\n패더레이션 플러그인의 각 필드를 살펴봅시다.\n\nName: 공유 컴포넌트를 포함한 JavaScript 모듈에 할당할 모듈 이름입니다. 필수입니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\nFileName: JavaScript 모듈의 진입 파일의 파일 이름입니다. 이 필드는 필수가 아니며, 기본값은 `remoteEntry.js`입니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\n\n\n공개합니다: 원격 모듈로 공개할 구성 요소를 나열해야 하는 곳입니다. 자세한 내용은 여기에서 찾을 수 있습니다.\n\n참고: 모든 노출 구성 요소는 리액트 구성 요소를 기본 내보내기로 내보내야 합니다. 그렇지 않으면 호스트 응용 프로그램 측에서 문제없이 통합할 수 없습니다. 리액트 구성 요소에서 개별 내보내기를 가져올만한 충분한 세부 정보가 없기 때문입니다.\n\n공유: 이것은 조금 복잡한 속성입니다. 라이브러리와 관련하여 리액트와 같은 경우 모든 라이브러리 사이에서 상태를 처리하기 위해 모든 라이브러리 사이에서 하나의 인스턴스를 공유해야 합니다. 따라서 원격 모듈을 사용할 때 리액트 인스턴스를 원격 모듈과 호스트 응용프로그램 모두에서 사용하는 방법이 필요합니다. 이를 위해 호스트 측 구성 및 원격 응용 프로그램 측 구성에 이 속성을 추가하고 공유할 라이브러리 목록을 양쪽에 모두 추가하면 됩니다. 무엇을 공유할지 알리려면 이 속성을 사용하면 됩니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\n# 호스트 응용 프로그램 기본 구성\n\n\n\n호스트 애플리케이션을 구성하는 두 가지 방법이 있습니다. 하나는 원격 모듈 진입 파일의 URL을 직접 참조하는 것이고, 다른 하나는 동적으로 참조를 채우는 것입니다. 두 가지 모두 원격 측에 대한 속성 세트가 비슷하지만 remotes 속성을 제외하고는 동일한 Name과 Shared 속성이 있습니다. 이에 대한 설명은 다음과 같습니다.\n\nRemotes: 원격 모듈의 진입 파일에 대한 참조를 보관합니다. 아래는 remotes 속성을 사용하는 예시입니다. 더 많은 세부 정보는 여기에서 찾을 수 있습니다.\n\n## URL을 사용하여 원격 컴포넌트 가져오기\n\n```js\nexport default defineConfig({\n    plugins: [\n        react(),\n        federation({\n             name: 'remotecomponent1',\n             remotes: {\n                 sharedComp: 'http://localhost:3001/assets/remotecomponent1.js',\n             },\n             shared: ['react', 'react-dom', 'react-router-dom'],\n        }),\n    ]\n});\n```\n\n\n\n## URL을 동적으로 적용하여 Remote 컴포넌트 가져오기\n\n```js\nexport default defineConfig({\n    plugins: [\n        react(),\n        federation({\n             name: 'remotecomponent1',\n             remotes: [\n                 {\n                     sharedComp: {\n                         external: `Promise.resolve(window.remoteURL)`,\n                         from: 'vite',\n                         externalType: 'promise',\n                     },\n                 },\n             ],\n             shared: ['react', 'react-dom', 'react-router-dom'],\n        }),\n    ]\n});\n```\n\n외부: 원격 모듈의 주소가 될 수 있으며, 기본적으로 URL 또는 `string` 형식의 Promise일 수 있습니다. 더 많은 세부 정보는 여기에서 확인할 수 있습니다.\n\nFrom: 원격 모듈이 어디에서 오는지 Vite가 알 수 있도록 하는 속성입니다. Webpack 또는 Vite에서 오는지 여부를 나타냅니다. 더 많은 세부 정보는 여기에서 확인할 수 있습니다.\n\n\n\nExternalType:는 외부 속성에서 사용할 외부 참조 유형을 설정합니다. 이 값은 url 또는 promise가 될 수 있습니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\n참고: 여기 예제에서는 window.remoteURL을 사용하여 url을 가져오고 있습니다. 따라서 이것은 호스트 애플리케이션 시작 시 설정됩니다. 따라서 이 속성은 애플리케이션의 루트 구성 요소인 app.tsx 또는 다른 곳에 설정할 수 있습니다.\n\n# 호스트 애플리케이션 내에서 원격 모듈 사용하는 방법\n\n호스트 애플리케이션의 구성 요소에서 원격 모듈을 사용하는 두 가지 방법이 있습니다.\n\n\n\n## 정적 임포트로 사용\n\n리액트 컴포넌트 내에서 원격 모듈을 항상 정적 임포트할 수 있습니다.\n\n```js\nimport Button from 'sharedComp/Button';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"card\">\n        <Button />\n      </div>\n    </div>\n  )\n}\n\nexport default App;\n```\n\n이 방법도 좋지만 성능과 신뢰성 측면에서는 가장 유망한 방법은 아닙니다. 이 방법을 사용할 때 몇 가지 문제가 발생했습니다. 또한 이 방법을 사용하면 네트워크 수준의 문제를 처리하기 어렵습니다.\n\n\n\n## 레이지로드된 모듈로\n\n이것은 성능을 향상시키고 네트워크 문제를 처리하기 위해 레이지 로딩을 사용하여 원격 모듈을 로드하는 것입니다.\n\n```js\nimport {lazy, Suspense} from 'react';\nconst Button = lazy(() => import('sharedComp/Button') as any);\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"card\">\n        <Suspense fallback={<div>Loading...</div>}>\n          <Button />\n        </Suspense>\n      </div>\n    </div>\n  )\n}\n\nexport default App;\n```\n\n이것은 원격 모듈을 사용하는 권장 방법으로, 이를 통해 네트워크 관련 문제와 성능 관련 문제를 처리할 수 있습니다.\n\n\n\n알림: 만약 TypeScript를 사용하여 구현하고 싶다면, 소스 루트에 사용자 정의 타입 선언 파일을 추가하고 remotes 구성의 이름을 모듈로 추가해야 합니다. 파일 이름은 module.d.ts와 같이 지정할 수 있습니다.\n\n```js\ndeclare module 'sharedComp/*' {}\n```\n\n# 어플리케이션 실행\n\n호스트 및 원격 어플리케이션을 실행할 때 몇 가지 주의할 점이 있습니다.\n\n\n\n- 개발 중일 때 파일 서비스가 작동하려면 개발 모드 대신 미리보기 모드에서 원격 응용 프로그램 및 호스트 응용 프로그램을 실행해야합니다. 그렇지 않으면 파일이 제공되지 않기 때문에 모듈 페더레이션이 개발 모드에서 작동하지 않습니다.\n- 또한 구성 요소를 공유할 때 javascript 모듈로 공유되고 응용 프로그램으로 공유되지 않는다는 것을 기억해야합니다. 응용 프로그램의 책임은 공유 모듈을 가져와 사용할 호스트 응용 프로그램에 의해 수행됩니다. 따라서 원격 구성 요소가 환경 변수나 기타 프로세스 관련 데이터를 사용하는 경우 호스트 응용 프로그램을 통해 원격 구성 요소로 전달될 것입니다. 따라서 원격 구성 요소를 사용할 때 항상 호스트 응용 프로그램이 해당 원격 구성 요소가 실행 중인 플랫폼이라는 것을 기억해주셔야 합니다. 외부 서버에서 실행 중이더라도 모듈 페더레이션을 사용할 때 전달되는 것은 파일만이며, 그 이상이 아닙니다. URL을 통해 원격 서버 측 응용 프로그램이 실행 중인 것을 볼 수는 있지만, 호스트 응용 프로그램 측에서는 단지 공유 javascript 모듈 진입 .js 파일을 참조하고 있을 뿐입니다. 따라서 원격 응용 프로그램 측에서 제공되더라도 호스트 응용 프로그램에서 모든 프로세스 관련 데이터를 제공하도록하십시오.\n\n# 지금까지 배운 내용을 기반으로 기본 시나리오를 구현해 봅시다\n\n여러 팀 간에 나눌 수 있는 다른 구성 요소가있는 사용 사례를 고려해 보겠습니다. E-Commerce 사이트를 시나리오로 삼아보겠습니다. 호스트로 E-Commerce 웹 앱을 개발하고 결제 구성 요소 및 홈페이지 구성 요소를 가져오겠습니다. 기본 시나리오로서 지금은 홈페이지 사용 사례만 구현해 보겠습니다.\n\n나는 react 및 Vite에 대한 vite-plugin-federation 샘플에서 일부 코드를 빌려와 기본 애플리케이션을 가져 와서 모듈 페더레이션의 기본 사용 사례를 보여주는 다음 애플리케이션을 만들었습니다.\n\n\n\n이 샘플에서는 웹사이트의 홈페이지를 원격 모듈로 개발했습니다. 이 모듈은 웹사이트(호스트 애플리케이션)에서 참조됩니다. 원격 모듈은 이 샘플(Main 브랜치)에서 정적 임포트로 가져오며, 원격 모듈은 정적 URL을 사용하여 참조됩니다.\n\n따라서 원격 애플리케이션에서 'Button'과 'Home' 두 가지 컴포넌트를 노출시켰습니다. 그리고 이들을 'homepage.js'라는 entry 파일 이름을 가진 모듈에 추가했습니다.\n\n이제 원격 애플리케이션에서 공유된 Home 컴포넌트를 살펴보겠습니다.\n\n여기서 컴포넌트를 자세히 살펴보면 default로 노출된 것을 볼 수 있습니다. 공유된 컴포넌트를 default로 내보내는 것이 중요합니다. 컴포넌트를 default로 내보내지 않으면 호스트 애플리케이션 측에서 이를 참조하는 것이 어려워집니다.\n\n\n\n호스트 애플리케이션 측에서 원격 모듈을 사용할 때 정적 임포트를 사용할 수 있습니다.\n\n그리고 각 구성 요소를 가져온 후에는 일반 구성 요소와 마찬가지로 사용할 수 있습니다. 그러나 실제 프로덕션 환경에서는 원격 모듈이 시간에 따라 사용할 수 없을 수 있으므로 정적 임포트 사용 시 문제가 발생할 수 있습니다. 따라서 이러한 모듈에 대한 지연 로딩을 사용하면 네트워크 관련 문제를 처리할 때 도움이 됩니다. 이 브랜치의 지연 로딩 예제를 여기에서 찾을 수 있습니다.\n\n지연 로딩을 사용하면 호스트 애플리케이션 측에서 원격 모듈을 사용하는 방법은 다음과 같습니다.\n\n6행과 7행에서 원격 모듈에서 구성 요소를 지연 로딩했습니다. 그런 다음 Suspense 구성 요소 내에서 해당 구성 요소를 사용하여 비동기로로드하고 로드하는 데 시간이 걸리는 경우 대체 구성 요소를 적용했습니다.\n\n\n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n\nAlso when importing these from remote modules if you are using typescript remember to add a custom definition file for types. So here in my implementation I have added the custom.d.ts file. This file help you to get rid of the compilation error Module not found .\n\n# Lets look in to implementing a bit advance scenario\n\nLet’s add the payment component in to the story and make this a bit more complicated. Implementation for the advance scenario can be found in this branch.\n\nThis adds bit of complexity as this uses two different remote modules to load home and payment pages and also added the complexity of react routing on to the host app. Also in this sample the payment page is loaded using a dynamically set URL which is pushed during the runtime through window object.\n\n\n\n\n호스트 애플리케이션 측에서 이 고급 사용 사례를 위한 Vite 구성은 다음과 같이 보입니다.\n\n여기 구성에서는 결제 및 홈 원격 모듈을로드하기 위해 두 가지 다른 원격 구성을 추가했음을 볼 수 있습니다. 각각에 대해 두 가지 다른 외부 유형을 추가했습니다. 여기서 이전 예제에서 한 것처럼 홈 컴포넌트를 설정된 URL로 로드하고 있지만 결제 모듈을 로드하기 위해 외부 유형인 promise를 사용하고 있습니다. 이것은 빌드 단계에서 결제 리모트 모듈이 호스팅되는 URL이 무엇인지 모른다면 런타임에서 설정할 수 있어야 한다는 것을 보여주기 위해 사용하고 있습니다. 이는 애플리케이션을 호스팅하고 모든 URL을 런타임에 해결하는 경우 유용합니다. 그래서 라인 25에서 결제 리모트 모듈의 URL을 런타임 중에 promise를 사용하여 로드하는 아래 구성을 사용하고 있습니다.\n\n```js\nremotes: [\n...\n{\n  payment: {\n     external: 'Promise.resolve(window.paymentUrl)',\n     from: 'vite',\n     externalType: 'promise'\n  },\n}\n...\n```\n\n그리고 호스트 애플리케이션의 App.tsx 컴포넌트 내부에 결제 리모트 모듈 URL을 window 객체에 설정하고, 홈 페이지 리모트 모듈에 추가하여 게으르게 로드하고 있습니다.\n\n\n\n# 개발 중 발생할 수 있는 오류 및 해결 방법\n\n- React, React Router Dom 및 다른 공유 라이브러리가 정의되지 않은 경우.\n\n확인해야 할 사항\n\n- 원격 앱 Vite 구성 또는 호스트 앱 Vite 구성의 공유 속성에 올바른 공유 라이브러리 목록이 추가되지 않은 경우입니다. 양쪽의 공유 목록이 동일해야 합니다.\n- 원격 앱과 호스트 앱 간에 공유해야 하는 모든 것이 공유 목록에 추가되었는지 확인해보세요.\n\n\n\n2. 원격 모듈을 로드하지 못했습니다.\n\n![이미지](/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_2.png)\n\n확인해야 할 사항은 다음과 같습니다.\n\n- 호스트 측 Vite 구성에서 각 원격 모듈 이름이 고유한지 확인하세요.\n- 원격 측 Vite 구성에 올바른 컴포넌트 이름이 명시되어 있는지 확인하세요. 구성 내에서 컴포넌트 이름은 공유하려는 컴포넌트와 비슷해야 합니다.\n- 원격 애플리케이션 측에서 컴포넌트가 기본으로 내보내졌는지 확인하세요.\n\n\n\n3. 만약 모든 패키지가 monorepo 구조에 있다면 npm 호이스팅과 호스트 및 원격 모듈 간의 라이브러리 공유에 문제가 발생합니다.\n\n이는 vite-plugin-federation 쪽에서 열린 이슈입니다. 그러나 모노리포 구조를 유지해야 한다면 위 샘플 프로젝트에서 한 것처럼 각 개별 애플리케이션에서 노드 모듈을 설치해야 합니다.\n\n# 결론\n\n- 원격 모듈을 가져오는 경우 정적 임포트 대신 지연 로딩을 사용하는 것이 좋습니다.\n- 원격 호스팅 모듈의 URL을 알고 있다면 구성에서 정적 URL을 사용하고, 실행 중에 동적으로 URL을 해결해야 할 경우 URL을 해결하기 위해 프로미스 방법을 사용하세요.\n- 문제없이 작동하도록 하려면 모든 것을 공유 컴포넌트에 추가해야 합니다. 예시: 원격 애플리케이션 루트 수준에서 적용한 프로바이더가 있는 경우 이를 공유 컴포넌트 내에 추가하거나 호스트 애플리케이션 측에서 프로바이더를 생성하여 해당 원격 컴포넌트를 감싸야 합니다(이 방법은 테스트하지 않았음)… 이것은 원격 모듈에 함께 패킹될 컴포넌트 및 해당에 필요한 임포트만 공유되기 때문입니다. 따라서 원격 앱의 루트 컴포넌트에 추가한 내용은 공유 컴포넌트 내에서 사용할 수 없습니다.\n- 항상 호스트 및 원격 간에 vue 및 react와 같은 핵심 라이브러리를 공유하세요.","ogImage":{"url":"/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_0.png"},"coverImage":"/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_0.png","tag":["Tech"],"readingTime":10},{"title":"Nextjs를 사용하여 Resend를 이용해 사용자에게 직접 메일을 보내는 방법","description":"","date":"2024-05-14 11:58","slug":"2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend","content":"\n\nNext.js는 매우 다재다능한 프론트엔드를 제공해줘요. 이를 단독으로 사용하여 웹 사이트의 대부분 요구 사항을 해결할 수 있어요. 프로젝트 구조 자체에 서버 측 렌더링을 활용하고 API를 생성할 수 있는 기능이 내장되어 있어 Next.js 앱의 기능을 확장할 수 있어요.\n\n![Resend 이미지](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_0.png)\n\n이 기사에서는 개발자를 위한 이메일 API인 Resend를 탐색하고 앱과 통합해볼 거예요. 우리는 간단한 연락처 양식을 만들어서 제출하면 제출된 정보와 함께 이메일을 우리 받은 편지함으로 전송할 거에요. 이 통합은 문의, 대기 목록 또는 기타 양식 정보를 받고 바로 우리 받은 편지함으로 전달하고 싶을 때 아주 유용해요.\n\n# 우리 Next.js 앱\n\n\n\n간단한 Next.js 앱을 만들 계획이에요. contact form을 사용해서. yarn create next-app를 사용해서.\n\n```js\nyarn create next-app\n```\n\n프로젝트 구성을 위해 다음 설정을 사용했어요. tailwind를 스타일링에 선택하고 코드를 정리하기 위해 src 디렉토리를 사용했어요.\n\n![이미지](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_1.png)\n\n\n\n## 연락 양식 만들기\n\n간결하게 유지하려고 하며 이름과 이메일을 요청하는 연락 양식을 만들겠습니다.\n\n다음과 같이 index.js 페이지 컴포넌트를 업데이트 해보세요:\n\n```js\nimport { useState } from \"react\";\nimport Head from \"next/head\";\n\nexport default function Home() {\n    const [name, setName] = useState(\"\");\n    const [email, setEmail] = useState(\"\");\n    const [loading, setLoading] = useState(false);\n\n    const handleSubmit = () => {\n      console.log(\"여기에 API 호출하기\")\n    }\n    return (\n        <main\n            className={`flex flex-col items-center p-24 min-h-screen`}\n        >\n            <Head>\n                <title>Contact Me | Coffeed</title>\n            </Head>\n\n            <div className=\"relative flex flex-col gap-4 \">\n                <div className=\"flex flex-col place-items-center gap-4\">\n                    <h1 className={`m-0 text-center text-3xl`}>연락하기</h1>\n                </div>\n                <form\n                    className=\"mt-6 flex flex-col max-w-xl gap-4 z-10\"\n                    onSubmit={handleSubmit}\n                >\n                    <label htmlFor=\"name\" className=\"sr-only\">\n                        이름\n                    </label>\n                    <input\n                        id=\"name\"\n                        name=\"name\"\n                        type=\"text\"\n                        autoComplete=\"name\"\n                        required\n                        value={name}\n                        className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이름\"\n                        onChange={(e) => setName(e.target.value)}\n                    />\n                    <label htmlFor=\"email-address\" className=\"sr-only\">\n                        이메일 주소\n                    </label>\n                    <input\n                        id=\"email-address\"\n                        name=\"email\"\n                        type=\"email\"\n                        autoComplete=\"email\"\n                        required\n                        value={email}\n                        className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이메일\"\n                        onChange={(e) => setEmail(e.target.value)}\n                    />\n                    <button\n                        type=\"submit\"\n                        className=\"flex justify-center rounded-md bg-blue-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-blue-500\"\n                    >\n                        {loading ? (\n                            <div\n                                style={\n                                    borderTopColor: \"transparent\",\n                                }\n                                className=\"w-6 h-6 border-4 border-white border-solid rounded-full animate-spin\"\n                            ></div>\n                        ) : (\n                            \"제출\"\n                        )}\n                    </button>\n                </form>\n            </div>\n        </main>\n    );\n}\n```\n\n\n\n테일윈드를 사용하여 스타일을 입히고 사용자로부터 이름과 이메일을 받는 간단한 양식을 만들었습니다. 양식을 제출할 때 Send Mail API 호출을 트리거합니다.\n\n다음 단계를 진행하기 위해 Next.js에서 Resend 및 필수 API를 설정해봅시다.\n\n# Resend로 시작하기\n\nresend.com으로 이동하여 계정에 로그인하세요. 이메일이나 Github를 사용하여 새로운 계정을 만들 수 있습니다.\n\n\n\nResend는 플랫폼에서 도메인을 소유하고 확인한 경우에만 사용자에게 이메일을 보낼 수 있습니다. 이를 통해 해당 도메인 이름을 사용하여 어떤 이메일 주소에서든 이메일을 보낼 수 있습니다. 예를 들어, noreply@coffeed.com에서 사용자에게 이메일을 보내려면 coffeed.com 도메인을 Resend에 추가한 다음 해당 도메인 이름 레코드를 추가하여 해당 도메인을 소유하고 있는 것을 확인해야 합니다.\n\n## 도메인 추가\n\n도메인을 추가하려면 도메인으로 이동한 다음 도메인 추가를 클릭하세요.\n\n![도메인 추가](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_2.png)\n\n\n\n도메인 이름을 입력하고 지역을 선택해주세요. 기본값인 \"us-east-1\"은 무료이며 저희가 사용하는 용도에 적합합니다.\n\n![도메인 설정](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_3.png)\n\n도메인을 추가하면 DNS 레코드 세트가 표시되며, 해당 레코드들을 도메인 서비스 제공업체에서 업데이트해야 합니다. MX 및 2개의 TXT 레코드를 DNS에 추가한 후에 \"DNS 레코드 확인\"을 클릭하여 도메인을 확인할 수 있습니다.\n\n![DNS 레코드 확인](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_4.png)\n\n\n\n도메인을 확인하는 것은 이메일 전달성을 보장하는 데 필수적입니다. 한 번 도메인을 확인하면 이메일을 보낼 수 있는 권한이 부여됩니다.\n\n## API 키 생성\n\nAPI 키는 요청을 인증하는 비밀 토큰입니다.\n\n- 사이드바의 API 키로 이동합니다.\n- API 키 생성을 클릭합니다.\n- API 키에 이름을 지정합니다.\n- 허가로 보내기 액세스를 선택하고 액세스를 제한하려는 특정 도메인을 선택하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_5.png\"/>\n\n또한 \"전체 액세스\" 권한이 있지만 보안을 위해 단일 도메인에 제한된 \"전송 액세스\" 권한을 사용하는 것이 좋습니다. .env 파일에 생성된 이 API 키를 RESEND_API_KEY 변수로 추가하세요.\n\n# Next.js 앱에 Resend 추가하기\n\n이제 프로젝트로 돌아가서 Resend sdk 라이브러리를 추가해봅시다. 터미널에서 다음 명령을 실행하세요:\n\n\n\n```js\nyarn add resend\n```\n\n## 1. 이메일 템플릿 추가하기\n\n먼저 src 폴더의 components 폴더에 새로운 이메일 템플릿 폴더를 만들어보세요. src/components/email/ 폴더에 contact-form.jsx라는 새로운 이메일 템플릿을 추가해주세요.\n\n```js\nexport const EmailTemplate = ({\n  name,\n  email\n}) => (\n  <div>\n    <p>안녕하세요 Kavya,</p>\n    <p>\n        {name}님이 웹사이트에서 연락 양식을 제출했습니다. 그들의\n        이메일은 {email} 입니다!\n    </p>\n    <p>\n        감사합니다,\n        <br />\n        Coffee\n    </p>\n  </div>\n);\n```\n\n\n\n이메일 본문을 스타일링하기 위해 HTML을 사용하여 이름과 이메일을 입력할 수 있는 간단한 템플릿을 만들었습니다. React 컴포넌트로 구성된 이 템플릿을 보면 프로젝트에서 디자인한 React 컴포넌트를 사용하거나 수정할 수 있습니다.\n\n## 2. 이메일을 보내는 API 생성하기\n\npages/api/ 디렉토리 아래에 send.js라는 API 파일을 생성하세요. 요청 본문에서 이름과 이메일을 가져와서 Resend 라이브러리의 sendEmail 함수를 호출하고 EmailTemplate과 함께 사용하세요.\n\n```js\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nconst data = await resend.sendEmail({\n    from: `${process.env.FROM_EMAIL}`,\n    to: `${process.env.TO_EMAIL}`,\n    subject: \"🎉 연락 양식으로 새로운 제출이 도착했습니다!\",\n    html: \"\",\n    react: EmailTemplate({ name, email })\n});\n```\n\n\n\n다음 변수들은 .env 파일에 선언되어야 합니다:\n\n- RESEND_API_KEY — Resend 관리자 섹션에서 생성된 API 키.\n- FROM_EMAIL — 메일이 보내지는 이메일 주소. Resend 관리자에서 확인된 도메인으로부터 보내진 것으로 나타나야 합니다.\n- TO_EMAIL — 메일이 전송될 이메일 주소. 이 경우에는 내 이메일 주소로 메일을 보내고 있습니다.\n\n```js\nimport { EmailTemplate } from '../../components/email/contact-form';\nimport { Resend } from 'resend';\n\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nexport default async (req, res) => {\n  try {\n    const { name, email } = JSON.parse(req.body);\n\n    const data = await resend.sendEmail({\n        from: `${process.env.FROM_EMAIL}`,\n        to: `${process.env.TO_EMAIL}`,\n        subject: \"🎉당신의 연락 양식으로의 새로운 제출!\",\n        html: \"\",\n        react: EmailTemplate({ name, email })\n    });\n\n    res.status(200).json(data);\n  } catch (error) {\n    res.status(400).json(error);\n  }\n};\n```\n\n대신 제출된 이메일 주소로 설정하여 사용자에게 바로 이메일이 전송되도록 할 수도 있습니다.\n\n\n\n## 3. 양식 제출 시 이메일 트리거\n\nhandleSubmit 함수를 만들고 이름과 이메일을 본문의 매개변수로 사용하여 이메일을 트리거할 수 있습니다.\n```js\nconst [name, setName] = useState(\"\");\nconst [email, setEmail] = useState(\"\");\nconst [loading, setLoading] = useState(false);\n\nconst handleSubmit = async (e) => {\n    setLoading(true);\n    e.preventDefault();\n\n    if (name == \"\" && email == \"\") {\n        setLoading(false);\n        alert(\"이름과 이메일을 모두 입력해주세요\");\n        return false;\n    }\n\n    await fetch(\"/api/send\", {\n        method: \"POST\",\n        body: JSON.stringify({ name, email }),\n    })\n        .then((res) => res.json())\n        .then((data) => {\n            setLoading(false);\n            if (data && data.id) {\n                alert(`${name}님, 관심 표현해 주셔서 감사합니다! 곧 연락 드리겠습니다!`);\n                setName(\"\");\n                setEmail(\"\");\n            } else {\n                alert(\"죄송합니다! 다시 시도해주세요.\");\n            }\n        })\n        .catch((err) => {\n            setLoading(false);\n            alert(\"우왕! 불행하게도 오류가 발생했습니다.\");\n        });\n    return true;\n};\n```\n\n이렇게 하면 Next.js 앱에 Resend 기능을 연결할 수 있습니다. 여기에 인덱스 페이지의 최종 코드가 있습니다:\n\n\n\n```js\r\nimport { useState } from \"react\";\nimport Head from \"next/head\";\n\nexport default function Home() {\n    const [name, setName] = useState(\"\");\n    const [email, setEmail] = useState(\"\");\n    const [loading, setLoading] = useState(false);\n\n    const handleSubmit = async (e) => {\n        setLoading(true);\n        e.preventDefault();\n\n        if (name == \"\" && email == \"\") {\n            setLoading(false);\n            alert(\"이름과 이메일 주소를 모두 입력해주세요!\");\n            return false;\n        }\n\n        await fetch(\"/api/send\", {\n            method: \"POST\",\n            body: JSON.stringify({ name, email }),\n        })\n            .then((res) => res.json())\n            .then((data) => {\n                setLoading(false);\n                if (data && data.id) {\n                    alert(`${name}님, 저희에게 관심 가져주셔서 감사합니다! 곧 연락드리겠습니다!`);\n                    setName(\"\");\n                    setEmail(\"\");\n                } else {\n                    alert(\"죄송합니다! 다시 시도해주세요.\");\n                }\n            })\n            .catch((err) => {\n                setLoading(false);\n                alert(\"앗! 죄송하지만 오류가 발생했습니다.\");\n            });\n        return true;\n    };\n    return (\n        <main\n            className={`flex flex-col items-center p-24 min-h-screen`}\n       >\n            <Head>\n                <title>나에게 연락하기 | Coffeed</title>\n            </Head>\n\n            <div className=\"relative flex flex-col gap-4 \">\n                <div className=\"flex flex-col place-items-center gap-4\">\n                    <h1 className={`m-0 text-center text-3xl`}>나에게 연락하기</h1>\n                </div>\n                <form\n                    className=\"mt-6 flex flex-col max-w-xl gap-4 z-10\"\n                    onSubmit={handleSubmit}\n                >\n                    <label htmlFor=\"name\" className=\"sr-only\">\n                        이름\n                    </label>\n                    <input\n                        id=\"name\"\n                        name=\"name\"\n                        type=\"text\"\n                        autoComplete=\"name\"\n                        required\n                        value={name}\n                       className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이름\"\n                        onChange={(e) => setName(e.target.value)}\n                    />\n                    <label htmlFor=\"email-address\" className=\"sr-only\">\n                        이메일 주소\n                    </label>\n                    <input\n                        id=\"email-address\"\n                        name=\"email\"\n                        type=\"email\"\n                        autoComplete=\"email\"\n                        required\n                        value={email}\n                        className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이메일\"\n                        onChange={(e) => setEmail(e.target.value)}\n                    />\n                    <button\n                        type=\"submit\"\n                        className=\"flex justify-center rounded-md bg-blue-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-blue-500\"\n                    >\n                        {loading ? (\n                            <div\n                                style={{\n                                    borderTopColor: \"transparent\",\n                                }}\n                                className=\"w-4 h-4 border-2 border-white border-solid rounded-full animate-spin\"\n                            ></div>\n                        ) : (\n                            \"제출하기\"\n                        )}\n                    </button>\n                </form>\n            </div>\n        </main>\n    );\n}\r\n```\n\n양식을 제출하면 이메일이 .env 파일에 설정된 TO_EMAIL로 전송됩니다.\n\n<img src=\"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_6.png\" />\n\n이메일 API를 활용하여 다른 사용 사례에 통합하여 직접 알림을 받을 수도 있습니다.\n\n\n\nNext.js playbook **Coffee** 팀에서 작업 중인 페이지입니다. 대기 목록에 추가하려면 coffee@coffeeinc.in으로 이메일을 보내주세요.","ogImage":{"url":"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_0.png"},"coverImage":"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_0.png","tag":["Tech"],"readingTime":13}],"page":"111","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}