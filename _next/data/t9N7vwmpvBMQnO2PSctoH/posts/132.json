{"pageProps":{"posts":[{"title":"왜 효과가 필요하지 않을 수도 있습니다 React 컴포넌트 최적화하기","description":"","date":"2024-05-12 21:04","slug":"2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents","content":"\n\n<img src=\"/assets/img/2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents_0.png\" />\n\n요즘 리액트 개발에서 useEffect 훅은 강력한 도구입니다. 그러나 종종 과도하게 사용되거나 잘못 사용되어 불필요한 복잡성과 성능 문제를 야기할 수 있습니다. useEffect에 항상 의지하는 대신, 고려할 가치가 있는 대안들이 있습니다. 이 글에서는 그러한 대안을 탐구하고 실용적인 코딩 예제를 제공합니다.\n\n# 흔한 오용 사례\n\n# 1. 상태 동기화\n\n\n\n일반적인 사용 사례는 상태 변수를 동기화하는 것입니다. 하지만 리액트의 onChange 및 다른 이벤트 핸들러들은 대부분의 상태 업데이트를 직접 처리할 수 있습니다.\n\n잘못된 예시:\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [double, setDouble] = useState(0);\n\n  useEffect(() => {\n    setDouble(count * 2); // 이중 값 계산을 위한 사이드 이펙트\n  }, [count]);\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>증가</button>\n      <p>카운트: {count}</p>\n      <p>이중: {double}</p>\n    </div>\n  );\n}\n```\n\n최적화된 솔루션:\n\n\n\n```js\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const double = count * 2; // useEffect 없이 직접 계산\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>증가</button>\n      <p>카운트: {count}</p>\n      <p>더블: {double}</p>\n    </div>\n  );\n}\n```\n\n# 2. 데이터 가져오기\n\nuseEffect에서 데이터를 가져오는 것은 필수적이지만, react-query나 React의 새로운 Server Components와 같은 데이터 가져오기 라이브러리를 사용하여 간단히할 수 있습니다.\n\n잘못된 예시:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [profile, setProfile] = useState(null);\n  useEffect(() => {\n    async function fetchProfile() {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      setProfile(data);\n    }\n    fetchProfile();\n  }, [userId]);\n  return profile ? <div>{profile.name}</div> : <p>Loading...</p>;\n}\n```\n\nReact 서버 구성 요소를 사용한 최적화된 해결책:\n\n```js\n// components/UserProfile.server.js\nimport React from 'react';\n\nexport default async function UserProfile({ userId }) {\n  const response = await fetch(`https://api.example.com/users/${userId}`);\n  const profile = await response.json();\n\n  return <div>{profile.name}</div>;\n}\n```\n\n클라이언트 컴포넌트에서의 사용법:\n\n\n\n\n// components/App.client.js\nimport UserProfile from './UserProfile.server';\n\nfunction App({ userId }) {\n  return (\n    <div>\n      <h1>User Profile</h1>\n      <UserProfile userId={userId} />\n    </div>\n  );\n}\n\nexport default App;\n\n\n## 3. Form Inputs and Debounced Updates\n\nInstead of debouncing updates through useEffect, handle it directly via controlled input components.\n\nIncorrect Example:\n\n\n\n\n```js\r\nimport { useState, useEffect } from 'react';\n\nfunction Search() {\n  const [query, setQuery] = useState('');\n  const [debouncedQuery, setDebouncedQuery] = useState(query);\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedQuery(query);\n    }, 300);\n    return () => clearTimeout(timer);\n  }, [query]);\n  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;\n}\r\n```\n\n커스텀 훅을 사용한 최적화된 솔루션:\n\n```js\r\nimport { useState } from 'react';\nimport useDebounce from './useDebounce';\n\nfunction Search() {\n  const [query, setQuery] = useState('');\n  const debouncedQuery = useDebounce(query, 300);\n  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;\n}\r\n```\n\nuseDebounce 커스텀 훅은 디바운싱 로직을 캡슐화합니다:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n  return debouncedValue;\n}\nexport default useDebounce;\n```\n\n# 4. Prop이 변경될 때 모든 상태를 재설정하는 방법\n\n다른 항목 간을 이동할 때 폼 필드나 필터와 같은 상태 변수를 재설정하는 것이 중요합니다. 이 재설정을 처리하는 비효율적인 방법은 useEffect 훅을 사용하여 prop 변경에 따라 상태를 수동으로 지우는 것입니다. 그러나 이렇게 하면 추가 렌더링 사이클이 발생하고 불필요한 복잡성을 야기합니다.\n\n올바르지 않은 예시:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nexport default function ItemDetails({ itemId }) {\n  const [input, setInput] = useState('');\n  // 🔴 비효율적: 효과를 이용해 상태를 재설정\n  useEffect(() => {\n    setInput(''); // itemId가 변경될 때 입력 필드를 지움\n  }, [itemId]);\n\n  return <input value={input} onChange={(e) => setInput(e.target.value)} />;\n}\n```\n\n효과에 의존하는 대신 key prop을 사용하여 자동으로 재설정되도록 할 수 있습니다. 컴포넌트를 둘로 분리하고 내부 컴포넌트에 고유한 key prop을 전달하면 React가 새로운 인스턴스로 처리하여 모든 내부 상태를 재설정합니다.\n\n최적화된 솔루션:\n\n```js\nexport default function ItemDetails({ itemId }) {\n  return <ItemForm itemId={itemId} key={itemId} />;\n}\n\nfunction ItemForm({ itemId }) {\n  // ✅ key 변경 시 상태 자동 재설정\n  const [input, setInput] = useState('');\n  return (\n    <div>\n      <h2>아이템 {itemId}에 대한 세부정보</h2>\n      <input value={input} onChange={(e) => setInput(e.target.value)} />\n    </div>\n  );\n}\n```\n\n\n\n# 결론\n\nReact의 useEffect는 가치가 있지만 종종 잘못 적용될 수 있습니다. 많은 경우, 이벤트 핸들러, react-query와 같은 라이브러리, 또는 커스텀 훅과 같은 대안적인 접근 방식을 사용하면 더 깔끔하고 유지보수가 쉬운 해결책을 제공할 수 있습니다. 더 많은 정보를 원하신다면 React의 가이드를 확인해보세요.","ogImage":{"url":"/assets/img/2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents_0.png"},"coverImage":"/assets/img/2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents_0.png","tag":["Tech"],"readingTime":5},{"title":"Vite React 프로젝트에서 절대 상대 경로 Imports를 사용하면 안되는 이유","description":"","date":"2024-05-12 21:03","slug":"2024-05-12-AbsolutelyDontUseRelativePathsImportsInYourViteReactProject","content":"\n우리 모두는 코드를 작성하기 전에 파일 시스템을 700번이나 탐색하는 것을 멈춰야 합니다. 배워봅시다.\n\n새로운 React 프로젝트를 Vite로 설정했다고 가정하겠습니다. 아니라면, 이전 게시물을 참조하여 시작해보세요.\n\n기본적으로 이렇게 import 경로를 작성해야 합니다:\n\n```js\nimport SomeDefaultExport from \"../../../lib/usefulthings\";\nimport { NamedExport } from \"../../shared/things/NamedThing\";\n```\n\n이건 엄청난 문제는 아니지만, 깨끗한 코드란 wtf(정말 멍청한 질문) 수를 줄이는 거야. 그래서 이걸 훨씬 직접적이고 쉽게 이해할 수 있도록 수정해볼게. vite.config.js를 편집해보자.\n\n```js\n  resolve: {\n    alias: {\n      src: \"/src\",\n    },\n  },\n```\n\n여러분의 설정은 다음과 같이 보일 거에요:\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      src: \"/src\",\n    },\n  },\n});\n```\n\n이제, IDE도 우리와 함께 잘 작동하도록 도와줄 차례입니다. 프로젝트 루트 디렉토리에 새 파일을 추가해야 하며 jsconfig.json이라는 파일을 만들어야 합니다. 그리고 아래 내용을 추가해주세요:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"src/*\": [\"./src/*\"],\n    }\n  }\n}\n```\n\n위와 같이 작성할 수 있는 절대경로를 사용할 수 있게 해줍니다.\n\n```js\nimport SomeDefaultExport from \"src/lib/lib/usefulthings\";\nimport { NamedExport } from \"src/components/shared/things/NamedThing\";\n```\n\n제 삶을 훨씬 쉽게 만드는 데 이렇게 확장하고 싶어요:\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      src: \"/src\",\n      components: \"/src/components\",\n      assets: \"/src/assets\",\n      lib: \"/src/lib\",\n    },\n  },\n});\n```\n\njsconfig.json과 tsconfig.json을 잊지 마세요.\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"src/*\": [\"./src/*\"],\n      \"components/*\":[\"./src/components/*\"],\n      \"assets\": [\"./src/assets/*\"],\n      \"lib\": [\"./src/lib/*\"],\n    }\n  }\n}\n```\n\n여기 간단한 메모가 있어요. 몇 가지 예에서 개발자들이 이들 앞에 @ 기호를 사용하는 것을 본 적이 있는데, 저는 이것이 가독성이 좋은 개선이라고 생각해요. 하지만 @s 및 @c 등을 사용하여 이 이름을 더 줄이는 데 주의하세요. 빨리 배워도 명확한 코드 접근 방식을 장려하여, 필요한 것만큼 말하고 더 이상 또는 덜 이야기하지 않는 명확한 이름을 사용하는 것이 좋을 거예요.\n\n나는 Paul van Zyl이에요. 저는 Sigma Digital의 주요 컨설턴트이고, 작고 특화된 분산 형 제품 디자인 및 개발 팀입니다. 귀하의 다음 혁신적인 프로젝트를 실제로 제공할 수 있는 파트너를 찾고 있다면, 귀하와 귀하의 팀이 게임을 더 재미있게 즐길 수 있도록 도와 드릴 수 있는 파트너를 찾고 있다면, 혹은 그냥 인사를 하고 싶다면, 언제든지 연락 주세요: paul [at] sigmadigital.io\n","ogImage":{"url":"/assets/img/2024-05-12-AbsolutelyDontUseRelativePathsImportsInYourViteReactProject_0.png"},"coverImage":"/assets/img/2024-05-12-AbsolutelyDontUseRelativePathsImportsInYourViteReactProject_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 제어 및 비제어 훅","description":"","date":"2024-05-12 21:02","slug":"2024-05-12-Reactcontrolledanduncontrolledhooks","content":"\n\n<img src=\"/assets/img/2024-05-12-Reactcontrolledanduncontrolledhooks_0.png\" />\n\n리액트에서, 제어 및 비제어 컴포넌트는 폼 입력을 관리하는 데 사용되는 패턴입니다. 리액트 훅은 함수형 컴포넌트 내에서 상태를 관리하기 위한 제어 및 비제어 훅의 개념을 도입했습니다. 여기에 대한 개요입니다:\n\n## 제어 훅(Controlled Hooks):\n\nuseState 훅: 제어 훅을 사용하면 상태가 직접적으로 리액트에 의해 관리됩니다. useState 훅을 사용하면 상태 변수를 선언하고, 리액트가 제공하는 setter 함수를 사용하여 해당 변수를 업데이트할 수 있습니다. 컴포넌트의 상태가 변경되면 리액트가 업데이트된 상태로 컴포넌트를 다시 렌더링합니다.\n\n\n\n```js\nimport React, { useState } from 'react';\n\nfunction ControlledComponent() {\n  const [value, setValue] = useState('');\n\n  const handleChange = (event) => {\n    setValue(event.target.value);\n  };\n\n  return (\n    <input\n      type=\"text\"\n      value={value}\n      onChange={handleChange}\n    />\n  );\n}\n```\n\n이 예시에서는 입력 필드의 값이 'value' 상태 변수에 의해 제어되며, 업데이트는 'setValue' 함수로 처리됩니다.\n\n## Uncontrolled Hooks:\n\nuseRef Hook: Uncontrolled hooks를 사용하면 DOM 내부에서 상태를 직접 관리할 수 있습니다. React의 상태 관리 시스템을 통해가 아니라 직접 DOM 내에서 관리할 수 있습니다. useRef 훅은 렌더링 간에 다시 렌더링을 유발하지 않고 지속되는 값(current 속성)을 보유할 수 있는 가변 ref 객체를 생성합니다. \n\n\n\n\n```js\nimport React, { useRef } from 'react';\n\nfunction UncontrolledComponent() {\n  const inputRef = useRef(null);\n\n  const handleClick = () => {\n    console.log(inputRef.current.value);\n  };\n\n  return (\n    <div>\n      <input type=\"text\" ref={inputRef} />\n      <button onClick={handleClick}>Log Value</button>\n    </div>\n  );\n}\n```\n\n이 예제에서 입력 필드의 값은 inputRef.current.value를 통해 DOM에 의해 직접 관리되며 변경 사항은 React의 상태 관리 시스템을 거치지 않고 액세스됩니다.\n\n# 제어 및 비제어 훅 사이 선택하기:\n\n- 제어된 훅(Controlled Hooks): React가 응용 프로그램 전체의 form 입력 상태를 관리하고 동기화해야 할 때 제어된 훅을 사용하세요. 제어된 컴포넌트는 form 데이터에 대한 단일 진실의 원천을 제공하여 변경 사항을 추적하고 관리하기 쉽게 만듭니다.\n- 비제어 훅(Uncontrolled Hooks): DOM 요소에 직접 액세스해야 하는 경우나 제어된 컴포넌트가 성능 문제를 일으킬 수 있는 대형 폼을 다룰 때 비제어 훅을 사용하세요. 비제어 컴포넌트는 모든 상태 변경마다 다시 렌더링을 유발하지 않아 더 빠를 수 있습니다. 그러나 복잡한 응용 프로그램에서는 특히 추적하고 관리하기 어려울 수 있습니다.\n\n\n\n제어 및 비제어 훅은 각자의 사용 사례가 있으며 선택은 특정 요구 사항과 선호도에 따라 다릅니다.","ogImage":{"url":"/assets/img/2024-05-12-Reactcontrolledanduncontrolledhooks_0.png"},"coverImage":"/assets/img/2024-05-12-Reactcontrolledanduncontrolledhooks_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트에서 return null을 사용하지 마세요","description":"","date":"2024-05-12 21:01","slug":"2024-05-12-StopusingreturnnullinReact","content":"\n\n<img src=\"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png\" />\n\nReact를 사용할 때 컴포넌트에서 반환된 값의 의미를 이해하는 것이 중요합니다. 컴포넌트가 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용하는 것이 유혹스러울 수 있지만, 이는 의도하지 않은 결과를 초래할 수 있습니다. 이 게시물에서는 React 컴포넌트에서 return null을 사용하는 것이 나쁜 습관으로 여겨지는 이유와 return false가 더 좋은 대안인 이유에 대해 살펴보겠습니다.\n\n# \"return null\" 사용에 대한 문제점\n\n컴포넌트에서 return null을 사용하는 주된 문제점은 애플리케이션에서 예상치 못한 동작을 일으킬 수 있다는 것입니다. 특히, null은 React에서 렌더링할 유효한 값으로 처리되며, 이로 인해 컴포넌트의 자식 요소가 트리에서 분리될 수 있습니다. 이는 예기치 않은 다시 렌더링이나 상태 불일치 등 다양한 문제를 초래할 수 있습니다.\n\n\n\n이것이 발생하는 이유를 이해하기 위해서는 React가 어떻게 작동하는지에 대해 알아야 도움이 됩니다. 컴포넌트가 렌더링될 때, React는 현재 UI 상태를 나타내는 가상 DOM 트리를 생성합니다. 그런 다음 이 트리는 이전 트리와 비교되어 UI의 어느 부분을 업데이트해야 하는지를 결정합니다. 컴포넌트가 null을 반환하면, React에게 아무것도 렌더링할 필요가 없다고 알립니다. 그러나 이는 컴포넌트의 자식들이 업데이트되어야 하는 상태나 프롭을 가지고 있을 때 문제를 일으킬 수 있습니다.\n\n다음 예시를 살펴보세요:\n\n```js\nfunction Parent() {\n  return (\n    <div>\n      <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Child rendered');\n  });\n\n  if (count === 0) {\n    return null;\n  }\n\n  return (\n    <div>\n      <button onClick={() => setCount(count - 1)}>-</button>\n      {count}\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n이 예시에서, Child 컴포넌트는 count가 0과 같을 때 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용합니다. 그러나 이는 Child 컴포넌트가 count의 값이 0이 아닌 값으로 다시 렌더링될 때 문제를 일으킬 수 있습니다. 이 경우에 React는 Child 컴포넌트를 트리에 다시 연결해야 하며, 예상치 못한 동작을 일으킬 수 있습니다.\n\n\n\n# \"return false\"의 장점\n\nreturn null 대신에 return false를 사용하는 것이 더 좋은 방법입니다. 컴포넌트가 false를 반환하면 React는 이를 null을 반환한 것처럼 처리하지만, 또한 React에게 해당 컴포넌트의 자식들을 렌더링하지 말라고 말합니다. 이렇게 하면 컴포넌트와 해당 자식들이 트리에 연결된 채로 유지되어, return null을 사용했을 때 발생할 수 있는 문제점을 회피할 수 있습니다.\n\n다음은 return false를 사용하는 이전 예제의 업데이트된 버전입니다:\n\n```js\nfunction Parent() {\n  return (\n    <div>\n      <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Child rendered');\n  });\n\n  if (count === 0) {\n    return false;\n  }\n\n  return (\n    <div>\n      <button onClick={() => setCount(count - 1)}>-</button>\n      {count}\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n\n\n이 버전에서 Child 컴포넌트는 count가 0과 동일할 때 null 대신 false를 반환합니다. 이렇게 하면 컴포넌트와 해당 하위 요소가 렌더링할 필요가 없을 때에도 트리에 연결된 상태를 유지합니다. 결과적으로, 컴포넌트가 더 예측 가능하게 동작하고 return null을 사용할 때 발생할 수 있는 문제를 피할 수 있습니다.\n\n# \"return false\"를 사용하는 경우\n\n일반적으로 return null 대신에 return false를 사용하는 것이 더 나은 실천 방법이지만, 적용하기에 적절하지 않을 수 있는 경우가 있음을 기억하는 것이 중요합니다. 구체적으로, 컴포넌트가 렌더링할 필요가 없음을 나타내야 하는 경우에만 return false를 사용해야 합니다. 컴포넌트가 조건에 따라 무언가를 렌더링해야 하는 경우에는 if 문이나 삼항 연산자와 같은 조건부 렌더링 기술을 사용해야 합니다.\n\n다음은 if 문을 사용한 조건부 렌더링 예시입니다:\n\n\n\n```js\nfunction MyComponent({ isLoggedIn }) {\n  if (!isLoggedIn) {\n    return <LoginForm />;\n  }\n\n  return <Dashboard />;\n}\n```\n\n이 예에서 MyComponent 컴포넌트는 사용자가 로그인했는지에 따라 LoginForm 또는 Dashboard를 조건부로 렌더링하는 if 문을 사용합니다. 이는 return false 대신 조건부 렌더링을 사용하는 더 적절한 방법입니다.\n\n# 결론\n\n결론적으로, React 컴포넌트에서 return null을 사용하면 예기치 않은 동작을 유발하므로 일반적으로 피해야 합니다. 대신 컴포넌트가 렌더링하지 말아야 함을 나타내어야 할 때는 return false를 사용해야 합니다. 이렇게 함으로써 컴포넌트와 그 하위 요소는 트리에 연결된 상태를 유지하고 return null 사용으로 발생할 수 있는 문제를 피할 수 있습니다.\n\n\n\n\n그러나 return false를 사용하는 경우는 컴포넌트가 아무것도 렌더링하지 말아야 하는 경우에만 사용해야 한다는 점을 명심해야 합니다. 컴포넌트가 조건부로 렌더링해야 하는 경우에는 조건부 렌더링 기술을 사용해야 합니다.","ogImage":{"url":"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png"},"coverImage":"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 JS에서 가짜 API 서버로 JSON 파일을 사용하는 방법","description":"","date":"2024-05-12 21:00","slug":"2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS","content":"\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_0.png)\n\n이 튜토리얼에서는 React JS에서 가짜 API를 위한 서버로 JSON 파일을 어떻게 사용하는지 배워보겠습니다. 실제 API에 의존하지 않고 애플리케이션을 테스트하고자 할 때 유용합니다. JSON 파일을 가짜 API로 사용함으로써 API 응답을 쉽게 모의하고 실제 API 호출을 하지 않고 다양한 시나리오를 테스트할 수 있습니다.\n\n# 요구 사항\n\n- json-server\n\n\n\n단계 1: JSON 파일 만들기\n리액트 프로젝트에서 새로운 JSON 파일을 만들고 \"db.json\"으로 이름 짓기. 이 파일에서 우리는 모킹하고 싶은 API 응답을 정의할 거에요. 아래는 예시입니다:\n\n단계 2: json-server 설치하기\nJSON 파일로부터 REST API를 시뮬레이트하기 위해 json-server 패키지를 사용할 거에요. 설치하려면 터미널에서 다음 명령어를 실행하세요:\n\n```js\nnpm install -g json-server\n```\n\n단계 3: JSON 서버 시작하기\nJSON 서버를 시작하려면 터미널에서 다음 명령어를 실행하고 JSON 파일의 경로를 지정하세요:\n\n\n\n```json\njson-server --watch db.json --port 3030\n```\n\n참고: React는 서버를 실행하는 데 사용되는 3000 포트를 사용하므로 포트를 수정하기 위해 —port 3030을 사용했습니다.\n\n단계 4: API 테스트\n이제 브라우저에서 http://localhost:3030/posts를 열면 데이터를 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_1.png)\n\n\n\n5단계: React에서 API 요청 만들기\nReact 컴포넌트에서 fetch API 또는 다른 HTTP 클라이언트 라이브러리를 사용하여 JSON 서버에 API 요청을 만듭니다. 다음은 fetch를 사용한 예시입니다:\n\n우리는 가짜 API 요청을 성공적으로 만들고 해당 요청을 통해 React 컴포넌트로 데이터를 가져왔습니다. GET 요청뿐만 아니라 POST 요청을 사용하여 데이터를 JSON 파일에 삽입하고, PUT 요청을 사용하여 데이터를 업데이트하고, DELETE 요청을 사용하여 JSON 데이터를 삭제할 수 있습니다. 이를 Postman에서 확인해 봅시다.\n\nPOST 요청\n\nJSON 파일에 새로운 게시물을 추가하려면 POST 요청을 만들고 본문을 사용하여 JSON 데이터를 추가해야 합니다. 다음은 예시입니다:\n\n\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_2.png)\n\nPUT 요청\n\n만약 데이터를 업데이트해야 한다면 PUT 요청을 사용하여 업데이트할 수 있습니다. 다음은 예시입니다:\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_3.png)\n\n\n\n삭제 요청\n\nJSON 파일에서 데이터를 삭제하려면 DELETE 요청을 사용할 수 있습니다. 예시는 다음과 같습니다:\n\n![예시 이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_4.png)\n\n여기까지입니다! React JS에서 가짜 API로 JSON 파일을 사용함으로써 실제 API에 의존하지 않고 응용 프로그램을 쉽게 테스트할 수 있습니다. 이는 테스트 목적으로 빠르고 쉬운 솔루션이며, 실제 API 호출을 하지 않고도 다양한 API 응답을 모방하고 다양한 시나리오를 테스트할 수 있습니다.\n\n\n\n문의 사항이 있으시면 LinkedIn을 통해 연락 주세요.\n\n오늘은 여기까지입니다. 아래에서 GitHub 저장소를 찾을 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_0.png"},"coverImage":"/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_0.png","tag":["Tech"],"readingTime":2},{"title":"React  Vite  React에서 Tailwind CSS가 작동되지 않는 문제 해결 2024년 업데이트","description":"","date":"2024-05-12 21:00","slug":"2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated","content":"\n\n<img src=\"/assets/img/2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated_0.png\" />\n\n가끔 Tailwind CSS가 작동하지 않고 Vite에 특히 지정된 방법으로 사전 설치를 따르지 않을 때 프로젝트에 적용할 수 없습니다.\n\n# 해결책\n\n간단합니다. 'vite.config.js' 파일에 아래와 같이 tailwindcss 및 css: ' ... '를 가져오는 부분을 추가해야 합니다.\n\n\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport tailwindcss from \"tailwindcss\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  css: {\n    postcss: {\n      plugins: [tailwindcss()],\n    },\n  },\n\n});\n```\n\n# 단계별 설치 안내\n\n또는 Vite + React 프로젝트에 Tailwind CSS 설정을 시작부터 따라갈 수도 있습니다.\n\n- Vite에 Tailwind CSS를 설치하는 명령어는 조금 다릅니다. postcss와 autoprefixer가 추가로 필요합니다.\n\n\n\n```js\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n2. 'tailwind.config.js' 파일을 아래와 같이 편집하여 모든 파일과 확장자를 추가하여 Tailwind CSS를 적용할 수 있습니다.\n\n```js\n/** @type {import('tailwindcss').Config} */\nexport default {\n  content: [\"./index.html\", \"./src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n3. 이것들을 당신의 CSS 파일 맨 위에 추가하세요.\n\n\n\n```js\n@tailwind 기본;\n@tailwind 컴포넌트;\n@tailwind 유틸리티;\n```\n\n완료! npm run dev로 이동해요.\n\n이제 일반적인 지시사항과 다른 부분을 보셨나요? output.css 파일을 생성하고 html 파일에 연결하는 단계가 필요하지 않아요.\n\nVite + React에서는 사실 더 간단하고 쉬워요.\n\n\n\n행복한 React! 🌐","ogImage":{"url":"/assets/img/2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated_0.png"},"coverImage":"/assets/img/2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated_0.png","tag":["Tech"],"readingTime":2},{"title":"NextAuthJS를 Discord와 함께 사용하는 방법","description":"","date":"2024-05-12 20:57","slug":"2024-05-12-HowtouseNextAuthJSwithDiscord","content":"\n\n## Discord API를 사용하여 NextJS에서 NextAuth.JS를 통한 \"Discord를 사용한 로그인\"을 구현하는 방법을 배워보세요.\n\n<img src=\"/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png\" />\n\n최근 대시보드 프로젝트를 작업하던 중에 Discord 사용자들이 애플리케이션에 로그인하고 그들의 서버 중 하나를 수정할 수 있도록 하는 작업을 하게 되었습니다.\n\n이전에 NextJS로 인증을 구현해본 적이 없던 사람으로써 전혀 감이 안 왔습니다. NextAuth, Auth0, Clerk 및 Supabase 사이를 계속 왔다갔다했습니다. 오류가 발생했을 때, 처음 몇 초만에 NextAuth를 포기했습니다.\n\n\n\n신입 개발자로 시작하는 것은 어렵습니다. 대부분의 경우, 처음으로 선택한 옵션이 가장 이상적인 경우가 많아요. 저는 모든 것을 시도해보고 결국 NextAuth로 돌아왔어요. 어떻게 구현하는지 알아내고 끝없는 시간을 보냈기 때문에 당신은 그럴 필요가 없어요!\n\n이 글을 통해 우리가 어떻게 인증을 구현할 수 있는지 살펴보도록 하죠.\n\n# NextAuth를 위한 Discord 제공자\n\nNextAuth를 활용하면 Google, Facebook, Apple, Github 등 다양한 서비스를 위한 인증을 설정할 수 있어요. NextAuth는 이러한 서비스와 플랫폼을 제공자(provider)라고 부르죠. 다시 말해, 이러한 제공자는 서비스이며 사용자들은 이를 통해 애플리케이션에 로그인할 수 있어요.\n\n\n\n이 기사에서는 Discord Provider를 사용할 것입니다. 다른 공급업체와 달리, Discord는 인증 설정을 위해 추가 구성이 필요합니다. 우리는 먼저 이러한 요구 사항을 정렬해야 합니다.\n\nDiscord Developer Portal에서 애플리케이션을 생성하여 Discord API 및 Discord 인프라에 액세스해야 합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*2IOmhM7_ZtM_Mf8zc6u5Dg.gif)\n\n그런 다음 Client ID와 Client Secret을 가져와야 합니다. 보안 목적을 위해 Client Secret을 재설정해야 합니다.\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*fXb5ABTdet-g_6FIqRwUpA.gif)\n\n필요한 자격 증명을 획득한 후 다음 단계로 진행할 수 있습니다. 관련 정보를 얻을 수 없는 경우, 선택한 브라우저에서 기본 검색을 수행하고 누군가가 안내해 줄 것입니다.\n\n## NextJS 앱 초기화\n\n이미 하지 않았다면 NextJS 애플리케이션을 설정해야 합니다. 다음 명령어를 터미널에서 사용하여 NextJS 애플리케이션을 초기화하고 단계를 따르세요.\n\n\n\n```js\nnpx create-next-app@latest\n```\n\n데모를 위해 프론트 엔드에서 인증 기능을 보여주기 위해 TypeScript보다는 JavaScript를 선택했어요 (화 angry지 마세요) 그리고 API 라우트를 용이하게 하기 위해 최신 App Router를 사용하고 전반적으로 더 나은 경험을 위해 TailwindCSS를 사용했어요.\n\n또한, src/ 구성을 선택하지 않았어요. 우리는 모든 것을 app/ 디렉토리 안에서 할 거예요. 그러나 당신의 어플리케이션에 맞춰 동일한 단계를 따르고 코드 스니펫을 조정할 수 있어요.\n\n## NextAuth 설치하기\n\n\n\n프로젝트에 NextAuth를 설치하려면 다음 명령을 사용해야 합니다.\n\n```js\nnpm install next-auth\n```\n\n설치가 완료되면 권한 부여와 관련된 다양한 요청을 처리하기 위한 새로운 API route를 생성해야 합니다. 먼저 app/ 디렉토리 안에 api/라는 폴더를 만듭니다.\n\n그런 다음 api/ 디렉토리 내에 nested 폴더를 만들어 auth/로 이름 지어주세요. 마지막으로 auth/ 디렉토리 내에 […nextauth]라는 디렉토리를 만듭니다. NextAuth는 이 디렉토리 구조를 엄격히 요구하므로 이러한 작업이 마법처럼 이루어질 것입니다.\n\n\n\n들어오는 요청을 처리하기 위해 app/api/auth/[...nextauth]/route.js 경로에 route.js 파일을 생성하세요. 이 파일은 동적 경로 핸들러입니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_1.png)\n\n## NextAuth를 위한 API Route 생성\n\n이 동적 경로 핸들러는 NextAuth 구성을 저장하고 NextAuth와 관련된 들어오는 요청을 처리할 것입니다.\n\n\n\n먼저 라우트 핸들러 파일에 NextAuth를 가져와보세요. 그런 다음 NextAuth에서 Discord Provider를 가져와주세요. 이 두 항목을 가져온 후, NextAuth를 구성하기 시작하겠습니다.\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n```\n\n이제 클라이언트 ID와 클라이언트 시크릿이 필요합니다. 준비해두세요. 이제 AuthOptions라는 객체를 만들 것입니다. 이 객체는 인증에 필요한 값들을 가진 객체입니다. 기억해주세요, 객체를 초기화할 때 export 키워드를 사용해야 합니다.\n\n이 객체를 사용하여 서버 컴포넌트에서 현재 세션에 액세스할 것입니다. 그런데, 세션은 서버 기반이며 DB와는 무관합니다.\n\n\n\n여기 파일이 보이는 모양입니다.\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n\nexport const AuthOptions = {\n  providers: [\n    DiscordProvider({\n      clientId: \"클라이언트_시크릿\",\n      clientSecret: \"클라이언트_시크릿\",\n    }),\n  ],\n};\n```\n\n이제 NextAuth 함수를 사용하여 인증을 초기화해야 합니다. 이 함수는 AuthOptions와 해당 속성을 매개변수로 필요로 합니다. 따라서 AuthOptions 객체를 매개변수로 전달할 것입니다.\n\n```js\nconst handler = NextAuth(AuthOptions);\n```\n\n\n\nNextAuth와 구성 옵션을 성공적으로 통합했습니다. 하지만, 더 있습니다. 누군가가 계정에 Discord를 사용하여 로그인하는 경우, Discord가 애플리케이션이 처리하고 로그인한 사용자의 계정에 액세스하기 위한 코드를 생성합니다.\n\n이 고유 코드를 사용하여 직렬화된 토큰을 얻을 수 있습니다. 토큰은 로그인한 사용자를 나타내는 문자열의 일련 번호이며 Discord API에 액세스할 수 있는 열쇠 역할을 합니다. 우리는 봇의 토큰 또는 유효한 Discord 사용자의 토큰이 있을 때만 Discord API에 액세스할 수 있습니다.\n\n해당 고유 코드가 어디에 있는지 궁금해하는 분들도 있을 것입니다. Discord는 사용자가 로그인에 성공한 후 애플리케이션이 사용자를 리디렉션하는 URL에 넣습니다. 다음은 NextAuth가 어떻게 도와주는지에 대한 설명입니다.\n\n\n\n우리가 사용자 정의 리디렉션 URL을 대신 사용하는 대신 NextAuth의 도움을 받을 것입니다. Discord 개발자 포털에서 선택한 애플리케이션의 OAuth 섹션에 다음과 같은 리디렉션 URL을 삽입할 것이며, 이 URL은 사용자가 로그인에 성공한 후 NextAuth의 라우트 핸들러로 사용자를 리디렉션할 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*deLjJ2UZeiuCS8AcNZzm9A.gif)\n\n리디렉션 URL은 이전에 로컬로 저장된 애플리케이션에서 미리 만든 동적 라우트 핸들러의 경로입니다. 프로덕션 빌드에서는 localhost:3000을 여러분의 도메인 이름이나 VPS IP로 바꿔야 합니다.\n\n사용자가 로그인하면 NextAuth의 라우트 핸들링 시스템으로 리디렉션되며, NextAuth가 즉시 코드를 토큰으로 교환하고 저장합니다.\n\n\n\n## NextAuth 콜백\n\n유저가 로그인하면 다른 페이지로 리디렉션되기를 원합니다. 기본 NextAuth 페이지에 머무르지 않도록 하거나 기본적으로 루트 디렉토리(홈페이지)로 리디렉션되지 않도록 하고 싶습니다. 따라서 NextAuth에서 리디렉션을 처리하기 위해 콜백을 사용할 것입니다.\n\nNextAuth는 개발자가 고유한 사용 사례에 맞게 구성할 수 있는 콜백을 제공합니다. 특정 이벤트가 트리거될 때마다 NextAuth 콜백이 호출됩니다. 예를 들어, signIn() 콜백은 유저가 로그인했을 때 실행됩니다.\n\n우리의 경우, redirect() 콜백을 재정의할 것입니다. 이 콜백은 두 개의 매개변수를 가져야 하지만, 우리는 일반적으로 루트 디렉토리의 URL(localhost:3000/)을 필요로 합니다.\n\n\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n\nexport const AuthOptions = {\n  providers: [\n    DiscordProvider({\n      clientId: \"YOUR_CLIENT_ID\",\n      clientSecret:\n        \"YOUR_CLIENT_SECRET\",\n    }),\n  ],\n\n  callbacks: {\n    async redirect({ url, baseUrl }) {\n      return baseUrl + \"/dashboard\";\n    },\n  },\n};\n\nconst handler = NextAuth(AuthOptions);\n```\n\n또한 route 핸들러에서 NextAuth() 함수를 호출한 결과를 내보내야 합니다. 그렇지 않으면 세션에 액세스하거나 처리할 GET 및 POST 요청이 작동하지 않습니다.\n\n다음은 route.js 파일이어야 합니다. /dashboard를 원하는 경로로 바꿀 수 있습니다.\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n\nexport const AuthOptions = {\n  providers: [\n    DiscordProvider({\n      clientId: \"YOUR_CLIENT_ID\",\n      clientSecret:\n        \"YOUR_CLIENT_SECRET\",\n    }),\n  ],\n\n  callbacks: {\n    async redirect({ url, baseUrl }) {\n      return baseUrl + \"/dashboard\";\n    },\n  },\n};\n\nconst handler = NextAuth(AuthOptions);\n\nexport { handler as GET, handler as POST };\n```\n\n\n\n# 디스코드 권한\n\n기본적으로 로그인한 사용자의 사용자 이름과 이메일에만 액세스할 수 있습니다. 더 많은 정보에 액세스하려면 디스코드 API 및 엔드포인트를 사용해 볼 수 있지만, 디스코드는 접근을 거부할 것입니다. 이는 디스코드가 개인 정보 보호와 보안을 강화하기 때문입니다.\n\n더 많은 정보에 액세스하려면 사용자의 권한이 필요합니다. 사용자가 로그인을 시도할 때 그들로부터 권한을 얻을 수 있습니다. 주목했을 것인데, 디스코드는 사용자가 로그인 시도할 때 응용 프로그램에 부여하는 권한을 나열합니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_2.png)\n\n\n\n만약 무작위로 보였다면, 그것은 오산이었습니다. 개발자는 이러한 권한을 요청하며, 사용자들은 보통 그것을 무시합니다. 우리는 권한을 요청하기 위해 그것들을 권한 URL에 추가함으로써 실현할 수 있습니다. route.js 파일로 돌아가는 시간입니다.\n\nDiscordProvider 함수 안에, authorization이라는 또 다른 속성을 추가해야 합니다. 이 속성의 값은 애플리케이션 요구 사항에 따라 다를 것입니다. 이전에 말한대로, 저는 로그인한 사용자의 길드에 액세스하고 그것들을 표시하려고 합니다.\n\n그러므로, 저는 해당 권한을 요청하고 몇 가지 다른 것들도 포함할 것입니다. Discord 개발자 포털에서 그것들을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_3.png)\n\n\n\n페이지 URL 쿼리 매개변수에서 모든 권한 이름이 ' + ' 기호를 사용하여 연결될 것입니다.\n\n```js\nproviders: [\n    DiscordProvider({\n      clientId: \"YOUR_CLIENT_ID\",\n      clientSecret:\n        \"YOUR_CLIENT_SECRET\",\n      authorization:\n        \"https://discord.com/api/oauth2/authorize?scope=identify+guilds\",\n    }),\n],\n```\n\n이제 프론트 엔드를 구성하여 로그인 프로세스를 시작해 보겠습니다.\n\n# 프론트 엔드 구성하기\n\n\n\n새로운 애플리케이션을 시작했기 때문에 루트 디렉토리에서 수정을 할 것입니다. 만약 로그인 버튼을 다른 곳에 넣고 싶다면 그렇게 할 수 있어요. 단계 자체는 동일해요.\n\n루트 디렉토리에 LoginUsingDiscord.jsx라는 클라이언트 컴포넌트를 만들어서 onClick 이벤트를 처리할 거에요. 주요 페이지.js 파일은 여전히 기본 서버 컴포넌트 모드로 유지될 거에요.\n\n컴포넌트 내부에서는 \"next-auth/react\"에서 signIn() 함수를 import하여 \"Login\" 버튼을 클릭했을 때 호출할 거에요. signIn() 함수에는 하나의 매개변수를 전달할 수 있어요. 바로 클릭했을 때 호출될 로그인 버튼이 표현하는 프로바이더의 이름이에요.\n\n```js\n\"use client\";\n\nimport { signIn, signOut } from \"next-auth/react\";\n\nexport default function LoginUsingDiscord() {\n  return (\n    <section className=\"flex gap-8 items-center justify-center mt-12\">\n      <p className=\"font-bold text-lg\">Discord를 사용하여 로그인</p>\n      <button\n        onClick={() => signIn(\"discord\")}\n        className=\"text-base py-3 px-4 bg-[#5865F2]\"\n      >\n        로그인\n      </button>\n    </section>\n  );\n}\n```\n\n\n\n그것이에요. 버튼을 클릭하면 Discord 로그인 화면으로 리디렉션됩니다. 토큰의 직렬화가 완료되면 redirect() 콜백에서 선택한 URL로 이동합니다. 제 경우에는 /dashboard로 이동했어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*6VWH3jSGprzfSPkHbafQfA.gif)\n\n성공적으로 로그인한 후에는 localhost:3000/api/auth/session에서 세션에 액세스할 수 있어요. 이 세션은 기본적으로 사용자 이름과 이메일만 포함하고 있어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*L3cZJJjMjQNvcKrWFXPAFw.gif)\n\n\n\nroute.js 파일 내에서 signIn()이라는 다른 콜백 함수를 덮어쓸 것입니다. 보안을 위해 토큰은 NextAuth의 범위 내에서만 접근할 수 있습니다.\n\n```js\nasync signIn({ account }) {\n  const discordToken = account.access_token;\n\n  return true;\n},\n```\n\nsignIn() 콜백은 사용자, 계정, 자격증명 등 다른 값들을 매개변수로 제공합니다. 우리는 access token을 검색하기 위해 account 매개변수만 필요합니다.\n\n대시보드 프로젝트에서 토큰을 해싱한 후 DB에 저장했습니다. 그러나 이곳에서는 그렇게 하지 않을 것입니다. 토큰을 사용하여 사용자에 대한 정보에 액세스하고 간소화를 위해 콘솔에 출력하려고 합니다.\n\n\n\n디스코드 API를 라우트나 서버 구성요소에서 사용하려면 토큰을 어딘가에 저장해야 합니다. 디스코드 API로의 모든 요청에는 디스코드 사용자 토큰이 필요합니다. 이 기사를 복잡하게 만들 수 없기 때문에 토큰을 어디에도 저장하지 않고 가져온 데이터를 콘솔에 표시할 것입니다.\n\n토큰을 어디에도 저장하지 않으므로 route.js 파일 외부에서 사용할 수 없습니다. 따라서 signIn() 콜백 내에서 디스코드 API에 대한 API 요청을 만들고 동작하는 방법을 보여드리겠습니다.\n\n# 디스코드 API 사용하기\n\nsignIn() 콜백을 계속 수정해보겠습니다. 사용자에 대한 정보를 가져와 콘솔에 출력하여 간단하게 표시하겠습니다. 이러한 API 요청의 엔드포인트는 디스코드 문서에 나와 있습니다.\n\n\n\nDiscord에서 제공하는 api/users/@me 엔드포인트로 GET 요청을 보내고, 로그인한 사용자의 정보가 포함된 객체를 받아오고 있어요. 사용자가 로그인했는지에 대해서는 중요하지 않아요. 각 액세스 토큰은 고유한 사용자를 나타내요.\n\n토큰은 매달 만료되며 갱신이 필요해요. 저는 사용자의 토큰을 사용할 때마다 그들을 대신해서 API 요청을 보내고 있어요. Discord는 저를 중재자로 취급해요.\n\n```js\nasync signIn({ account }) {\n   const discordToken = account.access_token;\n\n   const discordUser = await fetch(`https://discord.com/api/users/@me`, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${discordToken}`,\n      },\n    }).then((res) => res.json());\n  \n    console.log(discordUser);\n\n    return true;\n},\n```\n\n액세스 토큰을 header의 Authorization 속성에 전달하면, 모든 것을 올바르게 수행했다면 API 엔드포인트로부터 응답을 받을 수 있어요.\n\n\n\n![Screenshot](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_4.png)\n\n결국 LoginUsingDiscord 구성 요소 내에 로그아웃 버튼을 추가했어요. signOut() 함수를 사용했어요. 이 함수는 매개변수 없이 작동합니다. 왜냐하면 하나의 서비스만 활성 세션을 가질 수 있거든요. 여기에 코드가 있어요.\n\n```js\n<button\n  onClick={() => signOut()} className=\"text-base py-3 px-4 bg-[#ED4245]\">\n  Sign Out\n</button>\n```\n\n# 결론\n\n\n\n대부분의 애플리케이션에서 인증 구현은 어려운 작업입니다. NextAuth를 사용하면 이 작업을 더 쉽게 할 수 있습니다. 세션을 만드는 방법, 사용자가 Discord를 사용해 로그인할 수 있도록 하는 방법, 토큰을 사용해 Discord API에 API 요청을 보내는 방법 등을 배웠습니다.\n\n마찬가지로 Google과 같은 다른 제공업체를 사용할 수도 있습니다. 이 글이 도움이 되었기를 바랍니다. 소프트웨어 엔지니어로 취직하고 싶다면 대기 목록에 가입하는 것을 권장합니다.\n\n질문이 있다면 director@afankhan.com 이나 다른 곳에서 @whyafan 으로 연락해 주세요.\n\n# 평문으로 🚀\n\n\n\n플레인 영어 커뮤니티에 참여해 주셔서 감사합니다! 다음에 가시기 전에:\n\n- 작가를 추천하고 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png"},"coverImage":"/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png","tag":["Tech"],"readingTime":11},{"title":"프론트엔드와 백엔드를 한 번에 실행하는 방법","description":"","date":"2024-05-12 20:56","slug":"2024-05-12-HowtorunFrontendandBackendwithonecommand","content":"\n\n<img src=\"/assets/img/2024-05-12-HowtorunFrontendandBackendwithonecommand_0.png\" />\n\n풀 스택을 개발할 때 각 서버를 수동으로 시작하는 것이 번거롭고 비효율적일 수 있습니다.\n\n일반적으로 새 터미널을 열고 node server 또는 nodemon server 명령을 실행하여 node.js 백엔드를 실행하고, 별도의 터미널을 열어 npm start 명령을 실행하여 React 프론트엔드를 실행하는 것을 가정해 봅시다. 왜 위의 과정 대신 한 번에 두 가지를 실행하지 않을까요?\n\n\"concurrently\" 라이브러리를 이용하거나 병렬로 여러 npm 스크립트를 실행할 수 있도록 설계된 \"npm-run-all\" CLI 도구를 사용하는 두 가지 효과적인 방법이 있습니다.\n\n\n\n## 동시성 라이브러리\n\nConcurrently 패키지에 대해 알아보겠습니다. Concurrently를 사용하면 단일 터미널에서 여러 명령 또는 스크립트를 동시에 실행하여 더 효율적인 작업 흐름을 제공합니다. 즉, package.json 파일에서 리액트 및 노드 서버를 시작하는 별도의 스크립트를 정의할 수 있고, \"concurrently\"가 이를 함께 실행할 수 있습니다.\n\n먼저 프로젝트에 \"concurrently\"를 설치해야 합니다. npm install concurrently 명령어 또는 npm install concurrently --save-dev 명령어를 사용하세요. 보통 개발 목적으로 사용되므로 concurrently를 devDependencies로 추가하는 것이 좋습니다. 프론트엔드와 백엔드를 위한 별도의 폴더를 만들었다면, 루트 폴더에 concurrently를 설치해야 합니다.\n\n```js\nnpm install concurrently \n\nnpm install concurrently --save-dev\n```\n\n\n\n패키지. Json 파일의 메인 폴더에 있는 \"start\" 스크립트를 찾아서 수정해보세요. 기본 구문은 다음과 같습니다:\n\n```js\n\"start\": \"concurrently \\\"script1\\\" \\\"script2\\\"\"\n```\n\n\"script1\"과 \"script2\"를 실제 실행하고 싶은 명령어로 대체하세요.\n\n또는 다음과 같이 더 맞춤 설정할 수도 있습니다:\n\n\n\n```js\n\"scripts\": {\n  \"start\": \"concurrently \\\"npm run start:frontend\\\" \\\"npm run start:backend\\\"\",\n  \"start:frontend\": \"cd frontend의 실제 경로 && npm start\",\n  \"start:backend\": \"cd backend의 실제 경로 && node server\"\n}\n```\n\n\"frontend의 실제 경로\"와 \"backend의 실제 경로\"를 실제 경로로 변경하세요.\n\n만약 별도의 frontend와 backend 폴더가 있다면 아래와 같이 적용할 수 있습니다:\n\n```js\n\"start\": \"concurrently \\\"cd frontend && npm start\\\" \\\"cd backend && node server\\\"\"\n```\n\n\n\n앗, 이제 npm start를 실행하면 먼저 concurrently를 호출할 거야. 그리고 프론트엔드 코드가 있는 frontend 폴더가 있다면, frontend 디렉토리로 이동해야 해. (cd frontend) (해당 폴더로 이동하기 위한 필요한 명령어 사용) 그리고 npm start 명령어로 frontend를 실행해. 그리고 비슷하게 백엔드 코드가 있는 backend 폴더가 있다면, backend 디렉토리로 이동해야 해. (cd backend) (해당 폴더로 이동하기 위한 필요한 명령어 사용) 그리고 node server를 실행해.\n\n더 많은 명령어를 추가하려면 위의 형식처럼 각 스크립트에 백스플래시와 따옴표를 추가해야 해. 이제 새 터미널을 여시고 주 프로젝트 폴더에서 npm start를 실행하면 프론트엔드와 백엔드를 동시에 실행할 수 있어. 이 효율적인 접근법은 생산성을 향상시키고 빠른 반복을 가능하게 하며, 궁극적으로 더 나은 개발자 경험을 제공해.\n\nnpm \"concurrently\"를 사용하면 여러 작업을 원활하게 관리할 수 있어 개발 워크플로우를 간소화시킬 수 있어. 효율성을 향상시키고 복잡한 프로젝트를 유지보수하기 쉽게 만들어주는 유용한 도구야.\n\n\n\n“Concurrently\"은 개발 경험을 향상시키기 위해 추가적인 사용자 정의 및 유연성 옵션을 제공합니다. Concurrently에는 개발을 훨씬 쉽게 만드는 더 많은 기능이 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtorunFrontendandBackendwithonecommand_2.png)\n\n## 1. Named Commands:\n\n```js\n\"start\": \"concurrently --names 'FE,BE' \\\"npm run start:frontend\\\" \\\"npm run start:backend\\\"\"\n```\n\n\n\n- --names 옵션을 사용하면 실행되는 명령에 이름을 할당할 수 있어요.\n- 이렇게 하면 콘솔 출력이 더 가독성 있고, 어떤 프로세스가 프론트엔드에 해당하는지 쉽게 식별할 수 있어요.\n\n## 2. 에러 시 종료:\n\n기본적으로 명령 중 하나라도 비정상 상태 코드(오류를 나타냄)로 종료되면, concurrently는 다른 모든 명령을 종료할 거에요. 그러나 다음 옵션으로 이 동작을 수정할 수 있어요:\n\n- --kill-others: 한 명령이 실패해도, 이 옵션으로 다른 명령을 종료하는 걸 막을 수 있어요.\n- --success first|last: 첫 번째 또는 마지막 명령이 성공하면 전체 실행을 성공으로 간주할지를 지정해요.\n\n\n\n이것은 특히 한 곳에서 오류가 발생해도 다른 프로세스를 계속 실행하고 싶을 때 유용할 수 있습니다.\n\n## 3. 색으로 구분된 출력:\n\n각 명령의 출력은 기본적으로 색으로 구분됩니다.\n\n```js\n\"start\": \"concurrently -n \\\"FRONTEND,BACKEND\\\" -c \\\"red,blue\\\" \\\"npm run start:frontend\\\" \\\"npm run start:backend\\\"\"\n```\n\n\n\n- -c \"red,blue\"는 이름이 지정된 명령에 대한 색상을 지정합니다. 이 경우, frontend 명령은 빨간색 출력을 가지고, backend 명령은 파란색 출력을 가질 것입니다.\n- 색으로 구분된 출력은 서로 다른 프로세스를 시각적으로 쉽게 구별할 수 있도록 하여 로그나 오류의 원천을 빠르게 식별하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-HowtorunFrontendandBackendwithonecommand_0.png"},"coverImage":"/assets/img/2024-05-12-HowtorunFrontendandBackendwithonecommand_0.png","tag":["Tech"],"readingTime":4},{"title":"React TypeScript와 Jest를 위한 테스트 환경 설정하기","description":"","date":"2024-05-12 20:55","slug":"2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest","content":"\n\n![image](/assets/img/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest_0.png)\n\n자동화된 테스트는 코딩 퍼즐에서 매우 중요한 부분입니다. 이 글에서는 React/TypeScript 앱을 @testing-library/react + jest로 테스트하는 환경을 설정하는 방법을 알려드릴 거에요. 이렇게 함으로써 코드/제품의 품질을 최대화할 수 있어요! 그런데 한 가지 주의할 점은, 이 글에서는 자동화된 테스팅의 \"무엇\"에 대해서는 다루지 않아요!\n\n먼저, 왜 자동화된 테스트를 해야 할까요? 마우스와 키보드로 앱을 테스트하면 안 되나요?\n\n그렇게 하면 안 돼요. 자기 자신의 이익을 위해 해야 합니다. 가장 극단적인 예로, 수천 명의 가상 사용자가 웹 애플리케이션과 상호작용하는 것을 모방하여 애플리케이션이 어떻게 동작하는지 확인할 수 있는데, 이러한 동작을 수동 테스트로 시뮬레이션하는 것은 불가능해요. 이런 기능은 개발자들에게 많은 시간을 절약시켜 줘요!\n\n\n\n이 설정에 필요한 패키지는 무엇인가요?\n\n먼저 jest, @types/jest, ts-jest를 설치해야 합니다:\n\n```js\nyarn add --dev jest @types/jest ts-jest\n```\n\n```js\nnpm install --save-dev jest @types/jest ts-jest\n```\n\n\n\n리액트와 타입스크립트가 모두 설치되어 있다고 가정하고\n\n이제 환경을 설정해 봅시다!\n\n위의 패키지를 설치한 후에 jest 구성 파일을 초기화해 봅시다:\n\njest.config.js 파일이 생성될 것입니다.\n\n\n\n테스트 폴더 및 목 모듈 생성:\n\n프로젝트 루트 디렉토리로 이동한 다음, 해당 디렉토리 내에 테스트 폴더를 만들어 목 폴더를 만듭니다:\n\n```js\n├── tests\n│   ├── components\n│   ├── mocks\n│   │   ├── fileMock.ts\n│   │   └── styleMock.ts\n│   ├── pages\n│   │   └── login.test.tsx\n│   └── setupTests.ts\n├── tsconfig.json\n├── webpack.config.ts\n├── jest.config.ts\n└── yarn.lock\n```\n\n이 트리를 보면, 모델, 서비스, 자산 등에 대한 목 모듈도 생성해야 합니다!\n\n\n\n3. 설정 파일 완성하기:\n\njest.config 파일을 마무리하려면 몇 가지 속성을 더 추가해야 합니다:\n\n그리고 더 매끄럽게 리액트와 함께 작동하도록 하려면 .babelrc (바벨 구성 파일)에서 다음을 추가하세요:\n\n```js\n{\n....\n\"presets\": [\n     \"@babel/env\",\n     [\"@babel/preset-react\", { \"runtime\": \"automatic\" }],\n     \"@babel/preset-typescript\"\n   ]\n}\n```\n\n\n\n4. 리액트를 위한 테스팅 라이브러리 설치 :\n\n이제, 일어나게 만들어줄 라이브러리들을 추가해야 합니다 (VDOM 액세스, 상호 작용 등), 이 라이브러리들은 \"@testing-library/dom\", \"@testing-library/jest-dom\", \"@testing-library/react\", 그리고 \"@testing-library/user-event\" 입니다.\n\n```js\nyarn add --dev @testing-library/dom @testing-library/jest-dom @testing-library/react @testing-library/user-event\n```\n\n```js\nnpm install -D @testing-library/dom @testing-library/jest-dom @testing-library/react @testing-library/user-event\n```\n\n\n\n5. package.json에 jest 추가해 주세요:\n\n```js\n\"scripts\": {\n    ...\n    \"test\": \"cross-env NODE_ENV=test jest tests/\"\n}\n```\n\n6. 코드를 테스트해 보세요:\n\n다음은 로그인 페이지를 테스트하는 예시입니다:\n\n\n\n![이미지](/assets/img/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest_1.png)\n\n결론:\n\n찾으시던 정보를 얻으셨길 바라요! 만일 제가 실수한 부분이 있으면 얼마든지 알려주세요!","ogImage":{"url":"/assets/img/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest_0.png"},"coverImage":"/assets/img/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest_0.png","tag":["Tech"],"readingTime":3},{"title":"OpenAI의 Assistant API와 React를 사용하여 나만의 도우미 챗봇 만들기","description":"","date":"2024-05-12 20:53","slug":"2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact","content":"\n## 어시스턴트 API의 힘 이해하기\n\n![이미지](/assets/img/2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact_0.png)\n\n# 요약\n\n고속으로 발전하는 기술 세계에서 OpenAI는 인공 지능 분야에서 선두주자로 등장했습니다. 그들의 최신 작품인 어시스턴트 API는 이미 다양한 산업을 혁신하고 있습니다.\n\n자신만의 개인 비서를 가지고 싶었던 적이 있나요? 더 이상 찾을 필요가 없어요! OpenAI의 어시스턴트 API는 AI의 기능을 활용하고 이를 프로젝트에 원활하게 통합할 수 있는 강력한 도구입니다. 이 API를 활용하여 개발자들은 사용자와 동적 대화를 나누며 관련 정보와 맞춤 경험을 제공할 수 있는 지능형 챗봇을 만들 수 있습니다.\n\n이 글을 더 깊이 이해하면, 새로운 Assistant API를 사용하여 완전히 기능적인 챗봇을 구현하는 방법을 알아볼 것입니다. 이 챗봇은 아이스 하키 전문가로서 특정 지침을 줄 것입니다. 🏒\n\n시작해 봅시다! 👏👏👏👏\n\n## 단계 1: 개발 환경 설정\n\n새로운 리액트 프로젝트를 만들고 필요한 라이브러리와 의존성을 설치하는 것은 어떤 리액트 개발을 시작하는 핵심 단계입니다. 몇 가지 간단한 단계를 따르면 프로젝트를 신속하게 시작할 수 있습니다.\n\n- Node.js와 npm을 설치합니다 (이미 설치되어 있지 않은 경우)\n- 터미널이나 명령 프롬프트를 엽니다\n- 다음 명령어를 실행하여 Create React App을 설치합니다\n\n```js\nnpm install -g create-react-app\n```\n\n4. 다음 명령어를 실행하여 새로운 리액트 앱을 만듭니다 (여기서 \"my-app\"은 앱의 이름입니다)\n\n```bash\nnpx create-react-app my-app --template typescript\n```\n\n5. 해당 명령어를 실행하여 새 앱 디렉토리로 이동합니다.\n\n```bash\ncd my-app\n```\n\n6. Material-UI 및 그 종속성을 설치합니다.\n\n```js\nnpm install @mui/material @emotion/react @emotion/styled\n```\n\n7. 다음 명령어를 실행하여 개발 서버를 시작하세요.\n\n```js\nnpm start\n```\n\n이것으로 설정이 완료되었습니다! 이제 새로운 React 앱이 http://localhost:3000 에서 작동해야 합니다. 코드 편집기에서 앱을 열고 필요한 대로 코드를 사용자 정의할 수 있습니다.\n\n# 단계 2: React 앱 챗봇 컴포넌트 생성\n\n채팅 인터페이스를 위한 컴포넌트를 생성하세요. 각 메시지 컴포넌트를 렌더링하는 Chat 컴포넌트를 만들 수 있습니다.\n\n/src/components/Message.tsx\n\n```js\n// src/components/Message.tsx\nimport React from 'react';\n\ninterface MessageProps {\n  text: string;\n  isUser: boolean;\n}\n\nconst Message: React.FC<MessageProps> = ({ text, isUser }) => {\n  return (\n    <div style={ textAlign: isUser ? 'right' : 'left', margin: '8px' }>\n      <div style={ backgroundColor: isUser ? '#DCF8C6' : '#b8e3fc', padding: '8px', borderRadius: '8px' }>\n        {text}\n      </div>\n    </div>\n  );\n};\n\nexport default Message;\n```\n\n/src/components/Chat.tsx\n\n```js\n// src/components/Chat.tsx\nimport React, { useState } from 'react';\nimport { TextField, Button, Container, Grid } from '@mui/material';\nimport Message from './Message';\n\nconst Chat: React.FC = () => {\n  const [messages, setMessages] = useState<string[]>([]);\n  const [input, setInput] = useState<string>('');\n\n  const handleSendMessage = () => {\n    setMessages([...messages, input]);\n    setInput('');\n    // 챗봇 응답을 처리하는 로직을 추가하세요\n  };\n\n  return (\n    <Container>\n      <Grid container direction=\"column\" spacing={2}>\n        <Grid item>\n          {messages.map((message, index) => (\n            <Message key={index} text={message} isUser={index % 2 === 0} />\n          ))}\n        </Grid>\n        <Grid item>\n          <TextField\n            label=\"메시지를 입력하세요\"\n            variant=\"outlined\"\n            fullWidth\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n          />\n        </Grid>\n        <Grid item>\n          <Button variant=\"contained\" color=\"primary\" onClick={handleSendMessage}>\n            전송\n          </Button>\n        </Grid>\n      </Grid>\n    </Container>\n  );\n};\n\nexport default Chat;\n```\n\n# 단계 3: Chat 컴포넌트를 App.tsx에 통합하세요\n\nChat 컴포넌트를 사용하도록 src/App.tsx를 수정하세요.\n\n/src/App.tsx\n\n```javascript\n// src/App.tsx\nimport React from 'react';\nimport Chat from './components/Chat';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n         {/* 가운데 정렬 */}\n        <h1 style={ textAlign: 'center' }>React Chatbot</h1>\n      </header>\n      <main>\n        <Chat />\n      </main>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n다음 명령어를 사용하여 React 앱을 실행하세요:\n\n```javascript\nnpm start\n```\n\n# 단계 4: OpenAI 어시스턴트 API로 시작하기\n\n어시스턴트 API를 사용하면 사용자 쿼리를 이해하고 대화식 방식으로 응답하는 지능형 챗봇을 만들 수 있습니다. 이러한 챗봇은 다양한 애플리케이션 및 플랫폼에 통합되어 사용자에게 원활한 지원을 제공할 수 있습니다. 🤖\n\n⚠️ 진행하기 전에 API 키를 생성해야 합니다!\n\n⚠️ OpenAI는 SPA 웹 앱과 같은 클라이언트 사이드 환경에서 API 키를 노출하는 것을 권장하지 않습니다. 요청은 항상 API 키를 안전하게 보관할 수 있는 자체 백엔드 서버를 통해 라우팅해야 합니다. 그러나 간편함을 위해, 우리는 단순하게 유지하고 프론트엔드 개발에 집중할 것입니다.\n\nOpenAI에서 API 키를 얻으려면 다음 단계를 따르세요:\n\n- OpenAI 계정을 만들거나 로그인하세요. 이미 OpenAI 계정이 없는 경우 새로 만들어야 합니다. OpenAI 웹사이트로 이동하여 \"가입하기\" 버튼을 클릭하여 계정을 만들 수 있습니다.\n- API Keys 페이지로 이동하세요. 로그인한 후에는 화면 우측 상단의 계정 이름을 클릭한 다음 \"API Keys\"를 선택하여 API Keys 페이지에 액세스할 수 있습니다.\n- 새 API 키를 생성하세요. API Keys 페이지에서 \"새 비밀 키 생성\" 버튼을 클릭하세요. 이렇게 하면 API 키의 이름을 입력할 수 있는 모달 창이 열립니다.\n- API 키를 저장하세요. API 키를 만든 후에는 반드시 안전한 곳에 저장하세요. 다른 사람과 API 키를 공유하지 마세요. 그렇게 하면 그들이 OpenAI 계정에 액세스할 수 있게 됩니다.\n\nAPI 키를 획득했다면, OpenAI API에 요청을 인증하는 데 사용할 수 있습니다. 이에 대한 자세한 정보는 OpenAI API 설명서에서 찾을 수 있습니다.\n\n## OpenAI Assistant API의 주요 구성 요소:\n\n- 쓰레드: 쓰레드는 Assistant API에서 대화의 기초입니다. 사용자와 어시스턴트 간에 교환된 메시지의 시퀀스를 나타냅니다. 쓰레드는 지속적일 수 있으며, 나중에 사용할 수 있도록 저장하고 검색할 수 있습니다.\n- 메시지: 메시지는 쓰레드 내에서의 개별 통신 단위입니다. 사용자 또는 어시스턴트가 보낼 수 있습니다. 메시지에는 텍스트, 코드, 이미지 또는 다른 파일이 포함될 수 있습니다.\n- 모델: Assistant API는 GPT-3.5 및 GPT-4와 같은 OpenAI의 텍스트 생성 모델에 액세스를 제공합니다. 이러한 모델은 텍스트 생성, 언어 번역 및 정보적인 방식으로 질문에 대답하는 데 사용할 수 있습니다.\n- 도구: 도구는 추가 기능을 제공하는 Assistant API의 확장 기능입니다. 예를 들어, 코드 인터프리터, 정보 검색 및 함수 호출 도구가 있습니다.\n- 지침: 지침은 Assistant API가 모델 및 도구를 사용하는 방법을 제어하는 방법입니다. 사용할 모델, 따를 지침 및 통합할 도구를 지정하는 데 사용할 수 있습니다.\n- 실행: 실행은 어시스턴트의 실행을 의미합니다. 현재 쓰레드를 처리하고 응답을 생성하도록 어시스턴트를 트리거합니다. 실행은 대화에 대한 데이터 수집 및 어시스턴트의 성능을 측정하는 데 사용할 수도 있습니다.\n- 파일: 파일은 대화와 관련된 데이터를 저장하고 참조하는 데 사용됩니다. 사용자가 업로드하거나 어시스턴트가 생성할 수 있습니다. 파일은 텍스트, 코드 또는 이미지와 같은 다양한 형식일 수 있습니다. 이 문서에서는 파일에 대해 다루지 않습니다.\n- 역할: 역할은 쓰레드 내의 다른 유형의 메시지를 구별하는 데 사용됩니다. 현재 지원되는 역할은 사용자와 어시스턴트입니다.\n\n이러한 구성 요소가 함께 작동하여 챗봇 및 AI 어시스턴트를 구축하는 강력하고 유연한 플랫폼을 제공합니다. Assistant API는 아직 개발 중이지만, 컴퓨터와 상호 작용하는 방식을 혁신할 잠재력이 있습니다. 🦾🤖\n\n다음은 OpenAI Assistant API를 사용하는 방법입니다. Node.js를 사용하여 OpenAI의 Assistant API를 설정하려면 다음 단계를 따라야 합니다:\n\n1. OpenAI Node.js 라이브러리 설치하기:\n\n먼저 Node Package Manager (npm)을 사용하여 openai 패키지를 설치해주세요.\n\n```js\nnpm install openai\n```\n\n2. 환경 파일을 생성해보세요:\n\n루트 디렉토리에 .env 파일을 생성하여 OpenAI API 키를 안전하게 저장하세요. 다음 줄을 .env 파일에 추가해 주세요. YOUR_API_KEY를 실제 OpenAI API 키로 대체해주세요:\n\n```js\nREACT_APP_OPENAI_API_KEY = 당신의_API_KEY;\n```\n\n3. 필요한 라이브러리를 가져옵니다:\n\n/src/components/Chat.tsx 파일에서 OpenAI 라이브러리를 가져옵니다:\n\n```js\nimport OpenAI from \"openai\";\n```\n\n4. OpenAI 클라이언트를 초기화하세요:\n\nOpenAI 클래스를 사용하여 API 키를 이용해 OpenAI 클라이언트를 초기화하세요:\n\n```js\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true,\n});\n```\n\n다음 단계에서 OpenAI Assistant API를 기존 코드에 통합할 때 이러한 단계를 다시 요약하겠습니다.\n\n# 단계 5: React 앱에 OpenAI API 통합하기\n\n이제 우리는 이전 단계에서 만든 React 앱과 OpenAI Assistant API 코드를 통합하는 필요한 단계로 들어가보겠습니다. 다음 변경 사항을 수행해주세요:\n\n다음과 같은 MessageDto 클래스를 가지고 Models 폴더를 생성하세요:\n\n/src/models/MessageDto.ts\n\n```js\nexport class MessageDto {\n  isUser: boolean;\n  content: string;\n\n  constructor(isUser: boolean, content: string) {\n    this.isUser = isUser;\n    this.content = content;\n  }\n}\n```\n\nMessage.tsx 파일을 수정해주세요:\n\n/src/components/Message.tsx\n\n```js\n// src/components/Message.tsx\nimport React from \"react\";\nimport { MessageDto } from \"../models/MessageDto\";\n\ninterface MessageProps {\n  message: MessageDto;\n}\n\nconst Message: React.FC<MessageProps> = ({ message }) => {\n  return (\n    <div style={{ textAlign: message.isUser ? \"right\" : \"left\", margin: \"8px\" }}>\n      <div\n        style={{\n          color: message.isUser ? \"#ffffff\" : \"#000000\",\n          backgroundColor: message.isUser ? \"#1186fe\" : \"#eaeaea\",\n          padding: \"15px\",\n          borderRadius: \"8px\",\n        }}\n      >\n        {message.content.split(\"\\n\").map((text, index) => (\n          <>\n            {text}\n            <br />\n          </>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default Message;\n```\n\n마침내 새로운 Chat.tsx 파일을 구현해주세요:\n\n/src/components/Chat.tsx\n\n```js\n// src/components/Chat.tsx\nimport React, { useEffect, useState } from \"react\";\nimport { TextField, Button, Container, Grid, CircularProgress, LinearProgress } from \"@mui/material\";\nimport Message from \"./Message\";\nimport OpenAI from \"openai\";\nimport { MessageDto } from \"../models/MessageDto\";\n\nconst Chat: React.FC = () => {\n  const [isWaiting, setIsWaiting] = useState<boolean>(false);\n  const [messages, setMessages] = useState<Array<MessageDto>>(new Array<MessageDto>());\n  const [input, setInput] = useState<string>(\"\");\n  const [assistant, setAssistant] = useState<any>(null);\n  const [thread, setThread] = useState<any>(null);\n  const [openai, setOpenai] = useState<any>(null);\n\n  useEffect(() => {\n    initChatBot();\n  }, []);\n\n  useEffect(() => {\n    setMessages([\n      {\n        content: \"Hi, I'm your personal assistant. How can I help you?\",\n        isUser: false,\n      },\n    ]);\n  }, [assistant]);\n\n  const initChatBot = async () => {\n    const openai = new OpenAI({\n      apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n      dangerouslyAllowBrowser: true,\n    });\n\n    // Create an assistant\n    const assistant = await openai.beta.assistants.create({\n      name: \"Hockey Expert\",\n      instructions: \"You are a hockey expert. You specialize in helping others learn about hockey.\",\n      tools: [{ type: \"code_interpreter\" }],\n      model: \"gpt-4-1106-preview\",\n    });\n\n    // Create a thread\n    const thread = await openai.beta.threads.create();\n\n    setOpenai(openai);\n    setAssistant(assistant);\n    setThread(thread);\n  };\n\n  const createNewMessage = (content: string, isUser: boolean) => {\n    const newMessage = new MessageDto(isUser, content);\n    return newMessage;\n  };\n\n  const handleSendMessage = async () => {\n    messages.push(createNewMessage(input, true));\n    setMessages([...messages]);\n    setInput(\"\");\n\n    // Send a message to the thread\n    await openai.beta.threads.messages.create(thread.id, {\n      role: \"user\",\n      content: input,\n    });\n\n    // Run the assistant\n    const run = await openai.beta.threads.runs.create(thread.id, {\n      assistant_id: assistant.id,\n    });\n\n    // Create a response\n    let response = await openai.beta.threads.runs.retrieve(thread.id, run.id);\n\n    // Wait for the response to be ready\n    while (response.status === \"in_progress\" || response.status === \"queued\") {\n      console.log(\"waiting...\");\n      setIsWaiting(true);\n      await new Promise((resolve) => setTimeout(resolve, 5000));\n      response = await openai.beta.threads.runs.retrieve(thread.id, run.id);\n    }\n\n    setIsWaiting(false);\n\n    // Get the messages for the thread\n    const messageList = await openai.beta.threads.messages.list(thread.id);\n\n    // Find the last message for the current run\n    const lastMessage = messageList.data\n      .filter((message: any) => message.run_id === run.id && message.role === \"assistant\")\n      .pop();\n\n    // Print the last message coming from the assistant\n    if (lastMessage) {\n      console.log(lastMessage.content[0][\"text\"].value);\n      setMessages([...messages, createNewMessage(lastMessage.content[0][\"text\"].value, false)]);\n    }\n  };\n\n  // detect enter key and send message\n  const handleKeyPress = (e: React.KeyboardEvent<HTMLDivElement>) => {\n    if (e.key === \"Enter\") {\n      handleSendMessage();\n    }\n  };\n\n  return (\n    <Container>\n      <Grid container direction=\"column\" spacing={2} paddingBottom={5}>\n        {messages.map((message, index) => (\n          <Grid item alignSelf={message.isUser ? \"flex-end\" : \"flex-start\"} key={index}>\n            <Message key={index} message={message} />\n          </Grid>\n        ))}\n        <Grid item>\n          <TextField\n            label=\"Type your message\"\n            variant=\"outlined\"\n            disabled={isWaiting}\n            fullWidth\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            onKeyDown={handleKeyPress}\n          />\n          {isWaiting && <LinearProgress color=\"inherit\" />}\n        </Grid>\n        {!isWaiting && (\n          <Grid item>\n            <Button variant=\"contained\" color=\"primary\" onClick={handleSendMessage} disabled={isWaiting}>\n              Send\n            </Button>\n          </Grid>\n        )}\n      </Grid>\n    </Container>\n  );\n};\n\nexport default Chat;\n```\n\nReact 앱을 다음 명령어로 실행해보세요:\n\n```js\nnpm start\n```\n\n# 단계 6: 당신의 어시스턴트와 상호 작용하기\n\n이제 prompt를 사용하여 새로 만든 어시스턴트와 상호 작용할 준비가 되었습니다. 응답은 짧은 지연 후 화면에 표시됩니다. 아래와 같이 표시됩니다:\n\nPrompt:\n\n```js\n누가 사람들에게 요리를 가르치는 데 가장 적합한 이가 되었습니까?\n```\n\n답변:\n\n```js\n\"가장 적합한 요리 교육자\"라는 타이틀은 팬들과 요리 역사학자들 사이에서 치열한 논의의 대상입니다. 그러나 토론에서 자주 언급되는 몇 가지 이름은 다음과 같습니다:\n\n- **웨인 그레츠키(Wayne Gretzky)**: \"위대한 사람\"이라고 불리는 그레츠키는 NHL 역대 최고의 골, 어시스트, 포인트 기록 보유자입니다. 그는 수많은 기록을 보유하고 4회의 스탠리컵 챔피언입니다.\n- **바비 오어(Bobby Orr)**: 공격 능력으로 수비수 위치를 혁신한 오어는 2회의 아트 로스 트로피를 수상한 유일한 수비수입니다.\n- **고디 하워(Gordie Howe)**: \"미스터 하키\"로 별명 붙은 하워는 스코어링 능력과 체력에 뛰어난 선수로 유명합니다. 그는 6회의 리그 MVP 및 4회의 스탠리컵 챔피언입니다.\n- **마리오 라미우(Mario Lemieux)**: 놀라운 기술과 스코어링 능력을 가진 라미우는 경력 동안 심각한 건강 문제와 싸우면서 필츠버그 펭귄스를 2회의 스탠리컵 우승으로 이끌었습니다.\n- **모리스 리차드(Maurice Richard)**: \"로켓\"으로 불리는 그는 50게임에서 50골을 넣는 최초의 선수였고 골을 넣는 능력과 강한 결의로 유명했습니다.\n\n하키 토론은 또한 서로 다른 시대, 포지션 및 게임의 변화를 고려합니다. 이 선수들 모두 그들의 시대에서 지배적이었으며 이들이 스포츠에 기여한 데 대해 널리 인정받고 있습니다.\n```\n\n🛠️ 제 개인 GitHub 계정에서 완전한 솔루션 코드를 확인하실 수 있습니다. 여기를 클릭해주세요.\n\n# 결론\n\nOpenAI의 Assistant API 도입으로 보조 인력의 접근성이 새로운 차원으로 발전했습니다. 이제 누구나 챗봇과 AI 보조 인력의 힘과 편의성을 누릴 수 있습니다.\n\nAssistant API는 개발자들이 AI 기반 보조 인력의 잠재력을 활용할 수 있는 손쉬운 방법을 제공합니다.\n\n결론적으로, OpenAI의 Assistant API를 통한 보조 인력의 접근성은 개인 및 기업이 AI 기술의 힘을 활용할 수 있게 합니다. 우리 손끝에 챗봇이 있음으로써 생산성을 향상하고 고객 경험을 향상하며 다양한 산업에서 새로운 기회를 극대화할 수 있습니다.\n\n지금까지였어요. 만약 이 이야기를 좋아하셨다면, 팔로우하고 박수를 부탁드려요. 👏👏\n\n## 참고 자료\n\n[1] https://platform.openai.com/docs/assistants/how-it-works. OpenAI\n\n[2] https://medium.com/@ralfelfving/tutorial-get-started-with-the-new-openai-assistants-api-7049c2517bfe. Ralf Elfving\n","ogImage":{"url":"/assets/img/2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact_0.png"},"coverImage":"/assets/img/2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact_0.png","tag":["Tech"],"readingTime":14}],"page":"132","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}