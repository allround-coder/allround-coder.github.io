{"pageProps":{"posts":[{"title":"우리가 AWS를 떠나 1백만 달러에서 20만 달러로 80 절감한 연간 서버 비용 경험 공유","description":"","date":"2024-05-14 13:00","slug":"2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS","content":"\n\n## Prerender의 기술 리드이자 총괄 매니저 인 Zsolt Varga와의 인터뷰\n\n![이미지](/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_0.png)\n\n이번 주에 Prerender.io의 기술 리드 및 매니저 인 Zsot Varga와 인터뷰했습니다. 그는 Prerender가 AWS에 의존하지 않고 인프라를 직접 구축하여 트래픽 및 캐시된 데이터를 처리함으로써 80만 달러를 절약한 경험을 공유했습니다.\n\n## Prerender와 해결하고 있는 가장 흥미로운 기술적 문제를 설명해 줄 수 있나요?\n\n\n\n간단히 말해서, 프리렌더는 JavaScript 페이지를 캐시하고 사이트에 적절한 미들웨어가 설치된 상태로 검색 엔진이 순수한 HTML 파일을 크롤링하고 인덱싱할 수 있도록 해줍니다. 이를 통해 사용자들이 비실용적이고 시간이 많이 소요되는 JavaScript 우회 방법으로 번거로움을 겪지 않게 됩니다.\n\n그러나 이 모든 데이터와 프로세스는 서버에서 발생해야 하며 물론, 우리는 AWS를 사용했습니다. 몇 년간의 성장 이후, 우리는 분당 7만 페이지 이상을 처리하며, 약 5억 6천만 페이지를 저장하고 있으며, 연 당 100만 달러 이상을 지불하고 있습니다.\n\n물론 AWS에 머무른다면 그만큼 많은 비용이 발생할 것입니다. 대신, 우리는 아웃 오브 더 박스 사고와 명확한 계획을 통해 3개월도 안 되어 80% 비용을 절감할 수 있었습니다. 여러분도 다음과 같이 할 수 있습니다.\n\n## 이주 계획: 단계별 안내\n\n\n\n최근까지 Prerender는 클라이언트들을 위해 캐시하고 렌더링하는 페이지를 Amazon Web Services (AWS)에서 호스팅하는 서버와 서비스를 사용했습니다. AWS는 최대 규모의 클라우드 제공업체 중 하나로, 가상 서버와 관리 서비스를 제공합니다.\n\n이전까지 Prerender는 Google, Facebook 또는 다른 콘텐츠를 색인화하려는 봇/스파이더에 의해 가져가기 준비가 된 때까지 캐시를 저장하는 데 AWS를 사용해왔습니다. 이것은 Prerender의 기능 중 상당 부분을 차지하며, Google 및 다른 검색 엔진에 정적 HTML을 제공하고 인간 사용자에게 동적인 상호작용형 JavaScript를 제공했습니다.\n\n문제는 무려 테라바이트 단위의 사전 렌더링된 웹 페이지 콘텐츠를 3자 서버에 이렇게 저장하는 것이 매우 비용이 많이 든다는 것이었습니다. 이 방식으로 캐시된 페이지를 저장하는 것은 Prerender에게 유지 및 호스팅 비용만으로 엄청나게 많은 비용이 들었습니다.\n\n하지만 이것은 고려해야 할 또 다른 함정이 있었고, 많은 스타트업들이 고려하지 않는 것이며 그에 대한 논의가 많이 부족한 문제: 트래픽 비용입니다.\n\n\n\nAWS로 데이터를 가져 오는 것은 기술적으로 무료이지만, 대부분의 소프트웨어에 정적 데이터가 어떻게 유용한가요? 데이터를 이동하면 Prerender에게는 엄청난 비용이 들었고, 우리는 우리를 제한하고 있는 병목 현상에 대해 알아차리기 시작했습니다.\n\n해결책은 무엇이었나요? 캐시된 페이지와 트래픽을 Prerender의 내부 서버로 이전하고 AWS에 대한 의존도를 최대한 빨리 줄이는 것이었습니다.\n\n비용 예측을 하자, 호스팅 비용을 40% 줄일 수 있을 것으로 추정하고, 서버 이전을 통해 Prerender와 고객의 비용을 모두 줄일 수 있을 것으로 결정했습니다.\n\n목표는 비용을 줄이면서 렌더링 속도와 서비스 품질을 동일하게 유지하는 것이었습니다. 이러한 이주는 신중하게 계획되고 실행되어야 하며, 잘못된 구성 또는 잘못된 실행이 고객 웹 페이지 및 소셜 미디어 클릭의 다운 타임을 초래하고 검색 순위에 영향을 미칠 수 있으며, 우리의 이탈률을 증가시킬 수 있습니다.\n\n\n\n잠재적인 결과를 완화하기 위해 이전 단계로 쉽게 되돌아갈 수 있는 3단계 과정을 계획했습니다. 새 서버가 작동하지 않는 경우를 대비해 변경 사항을 쉽게 롤백하여 고객에게는 고객에게 눈에 띄지 않는 다운타임이나 서비스 저하가 발생하지 않습니다.\n\n계속적이고 체계적인 테스트의 주요 한계는 수주 및 수개월에 걸쳐 진행된다는 것입니다.\n\n# AWS에서 Prenderer 이동: 주간 개요\n\n## 1단계 — 테스트 (4~6주)\n\n\n\nPhase 1은 주로 베어 메탈 서버를 설정하고 스케일링하기 전에 작은 규모에서 마이그레이션을 시험해 보는 것을 포함했습니다. 이 단계에서는 소프트웨어를 최소한으로 적용하여 Linux의 KVM 가상화에서 실행하기로 결정했습니다.\n\n5월 초에는 첫 번째 일괄 서버가 가동되었고 Prerender 트래픽의 1%가 새로운 서버로 전달되었습니다. 마이그레이션 시작 후 2주 만에 하루에 800달러를 절약하고 있었습니다. 한 달이 끝날 때쯤에는 대부분의 트래픽 워크로드를 AWS로부터 이전하여 일일 Chrome 렌더링 워크로드 비용을 45%로 줄였습니다.\n\n서버 비용 부분에서 현재 우리의 비용은 월 13,000달러입니다. AWS와 결합하여 이미 비용을 22% 절감했습니다.\n\n![이미지](/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_1.png)\n\n\n\n테스트 단계가 매끄럽게 진행될 수 있도록 중요했습니다. 더 많은 모니터링 및 더 나은 오류 처리로 시스템의 견고성을 향상시키는 데 노력했습니다. 이미 보유하고 있던 서버 모니터링 대시보드 외에도 발생한 오류나 성능 문제를 식별할 수 있는 새로운 렌더링 모니터링 대시보드를 설정했습니다.\n\n![Image](/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_2.png)\n\n지속적인 모니터링과 명확한 커뮤니케이션 덕분에 테스트는 성공적이었고, 절약 예산은 초과되었으며 이사의 제2 단계를 시작할 준비가 모두 마련되었습니다.\n\n## 제2 단계 — 기술적인 설정(4 주)\n\n\n\n6월 중순부터 7월 초까지의 이관 기간은 대부분 마이그레이션의 첫 단계가 컨셉 검증을 위한 작업으로 기술적인 설정에 사용되었습니다. 두 번째 단계의 구현은 대부분 캐시 저장소를 베어 메탈 서버로 이동하는 작업을 포함했습니다.\n\n6월 중순에 이관이 진행되었을 때, 300대의 서버가 매우 원활하게 작동하며 전체 2억 개의 캐시 페이지가 있었습니다. 각 서버에는 AWS S3와 호환되는 Apache Cassandra 노드를 사용했습니다.\n\n온라인 마이그레이션을 한 단계씩, 한 주 또는 두 주 간격으로 네 단계로 나누어 실행했습니다. Prerender 페이지가 S3와 미니오에서 캐시될 수 있는지 테스트한 후, AWS S3로의 트래픽을 점진적으로 중단하고 미니오로 유도했습니다. S3로의 쓰기가 완전히 중지된 후에는 Prerender가 S3 API 비용을 하루에 200달러 절약하며, 우리의 Cassandra 클러스터에 이미 캐시된 데이터를 삭제할 준비가 되었음을 나타냈습니다.\n\n하지만, 이 단계의 마무리는 6월 24일쯤에 이루어졌습니다. 지난 네 주 동안, 우리는 대부분의 캐시 작업 부하를 AWS S3에서 우리 자체의 Cassandra 클러스터로 옮겼습니다. AWS의 일일 비용이 1.1K 달러로 감소되어 월 35K로 추산되며, 새로운 서버의 월 반복 비용은 약 14K로 추산되었습니다.\n\n\n\n이 시점에서 S3에는 하루에 약 60달러가 드는 일부 잔여물이 남아 있었고, 자연스럽게 몇 주 안에 완전히 소멸할 것으로 예상되었습니다. 모든 데이터를 이동하여 즉시 비용을 제로로 줄일 수도 있었지만, AWS에서 데이터를 이동하면 한 번에 5천 달러의 \"돈 낭비\"가 발생할 것이었습니다.\n\n데이터 이동은 엄청난 병목 현상에 직면하게 될 때입니다. 우리의 신규 CTO(Zsolt Varga)의 말을 빌리자면:\n\n\"AWS의 진정한 숨겨진 비용은 트래픽 비용에서 나옵니다. 그들은 합리적인 가격의 저장소를 판매하고 업로드는 무료입니다. 그러나 꺼낼 때는 막대한 비용을 지불해야 합니다.\n\n작은 스타트업에서는 종종 트래픽 비용을 계산하지 않습니다. 비용 중 90%에 해당할 수도 있다는 사실을 인식하지 못합니다\"\n\n\n\n예를 들어, 미국 서부(오레곤) 지역에 계시면, 1GB당 0.080달러를 내야 하지만, 아시아 태평양(서울) 지역으로 이동하면 1GB당 0.135달러로 올라갑니다.\n\n저희 경우에는 매달 약 3만 달러에서 5만 달러 사이였습니다. 제2단계가 끝나면 월 총 서버 비용을 41.2%로 줄일 수 있었어요.\n\n![이미지](/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_3.png)\n\n## 제3단계 — 구현 및 확장 (4~6주)\n\n\n\n이 시점에서 이주 작업은 이미 원활하게 진행 중이었고 이미 Prerender가 상당한 금액을 절약하고 있었습니다. 할 일으로 남은 것은 다른 모든 데이터를 네이티브 서버로 이주하는 것뿐이었습니다.\n\n이 단계에서는 Amazon RDS 인스턴스를 Shard 단위로 모두 이동하는 것이 포함되었습니다. 이것이 전체 프로세스 중에서 가장 오류가 발생하기 쉬운 부분이었지만, 이미 많은 양의 데이터가 이주되어 있었기 때문에 어떠한 결멍이나 병목 현상도 전체 이주를 망가뜨리지 않았을 것입니다.\n\n이주 프로세스의 마지막 단계를 큰 그림에서 보면:\n\n- 우리는 캐시된 URL 테이블을 저장하는 PostgreSQL 샤드를 Cassandra로 미러링했습니다.\n- 우리는 Cloudflare 로드 밸런서로 서비스.prerender.io를 전환하여 동적 트래픽 분배를 허용했습니다.\n- 우리는 새로운 EU Private-recache 서버를 설정했습니다.\n- 성능 문제를 해결하기 위해 계속해서 스트레스 테스트를 실시하고 있습니다.\n\n\n\n마이그레이션은 결과적으로 대성공을 거뒀습니다. 모든 캐시된 페이지가 리디렉션된 이후에 월간 서버 요금은 초기 추정액 40% 밑으로 내려가 전체 80%까지 감소했습니다.\n\n## 우리가 배운 것\n\n서버 마이그레이션에서는 잘못되거나 일정을 따라가지 못하는 것이 막대한 위험을 안겨 줄 수 있습니다. 그래서 우리는 마이그레이션 각 단계마다 실패 방지장치를 구현하여 무언가 잘못되었을 때 대비할 수 있도록 보장했습니다. 또한 나머지 마이그레이션을 진행하기 전에 소규모로 테스트하여 안전하게 진행할 수 있도록 했습니다.\n\n마이그레이션의 각 단계를 주의 깊게 계획하고, 확장하기 전 각 구현 단계를 테스트하며, 문제가 발생할 경우 오류를 수정하기 쉽도록 만들어 위험을 최소화했습니다. 이렇게 함으로써 서버 비용을 절약하면서 잠재적인 위험을 최소화할 수 있었습니다.\n\n\n\n## Prerender가 해결하는 문제에 대해 일하게 된 동기는 무엇이었나요?\n\n웹을 발전시키는 데 도움을 주는 플랫폼에서 일할 생각에 흥분했습니다.\n\nPrerender를 사용하면 고객들이 사용자 경험에 중점을 둔 웹사이트를 제공하고 SEO에 집중하는 대신 고객들에게 최상의 서비스를 제공할 수 있습니다. 지난 몇 년 동안 새로운 랜딩 페이지를 만들 때마다 우리는 항상 최고의 SEO를 얻기 위해 Wordpress를 사용하고 관리 섹션과 같은 색인되지 않은 페이지에만 SPA의 장점을 활용해 왔습니다. 그러나 이제는 과거에 나를 막아 두었던 문제를 해결하는 회사와 함께 일하고 있습니다 :)\n\n## 어떤 기술 스택을 사용하시나요? 그리고 이 스택을 선택한 이유는 무엇인가요?\n\n\n\n우리는 JavaScript를 어디서나 사용합니다. JavaScript 렌더링으로 인한 \"이슈\"들을 해결하기 때문에, 이 분야에서 가능한 한 많은 전문 지식을 쌓고 싶습니다. 그러나 다른 부분들에 대해서는, 빠른 응답과 글로벌 확장성을 위해 CloudFlare의 분산 시스템을 활용하고 있습니다. 또한 우리의 가용성 보증은 Digital Ocean의 클라우드 플랫폼에서 지원받고 있습니다. 우리는 효율성을 극대화하기 위해 다양한 다른 SaaS 제공업체를 활용하고 있습니다.\n\n## 회사가 비전을 달성했을 때 세상이 어떻게 보일 것인가요?\n\n\"새로운 사이트에 React를 사용할 수 있을까?\"라는 질문이 나오면 \"물론!\"이라고 대답할 것입니다. 왜냐하면 현재의 마케팅 부서들은 항상 SEO 순위를 낮출 수 있는 것들을 거부하고 있기 때문입니다. 그것이 옳다고 말할 것입니다. 고객들에 대해서는, 심지어 효율성이 1%라도 감소하면, 그들은 광고 예산을 수십만 달러로 증액해야 할 것입니다.\n\n## 당신에게 전형적인 하루는 어떻게 보이나요?\n\n\n\n하하, 고객 전화가 많이 오네요! 우리는 헌신적인 팀을 작고 효과적으로 유지하기를 목표로 하고 있어서, 대부분의 시간을 그들과 온보딩 통화에 사용하고 있어요. 그러나 이 일을 하는 건 즐겁죠! 항상 고객들과 대화하고, 그들의 상황에 대해 배우고, 해결책에 대해 이야기하는 걸 좋아해요. 이런 식으로 하니 제 업무가 훨씬 수월해지죠. 우리가 아이디어를 생각할 필요가 없어서, 고객들이 필요한 모든 정보를 우리에게 알려주기 때문이죠. 고객 중심적인 상황이 가장 좋다고 믿고 있어요. 제 목표는 행복한 고객들의 수를 늘리는 거죠.\n\n## 컴퓨터 하드웨어 설정 설명\n\n오, 이건 정말 기사로서 쓸 만한 가치가 있을 것 같아요. 저는 조금은 게이머 같은데요, 집에 전용 서버 8대가 있어요. 하지만 편의상 대부분 맥북에서 작업을 하고 있어요. 그러나 프로그래밍을 할 시간이 생기면 Manjaro가 돌아가는 \"작업용\" 컴퓨터를 사용해요. 그리고 가끔 나만의 시간을 갖게 되면, 비밀리에 게임을 즐기려고 운영체제가 윈도우인 PC를 가동시켜요. 지금 이 글을 쓰는 순간에는 노트북, 라즈베리파이, 태블릿으로 둘러싸여 있어요.\n\n늦은 밤에 기계를 조립하고 축소된 테스트를 실행하는 것이 제 취미거든요.\n\n\n\n## 내 컴퓨터 소프트웨어 설정 설명\n\nVSCode는 저에게 완벽한 솔루션이에요. 프로그래밍 언어에 대해서 그렇게 애정이 없지만, 확장 프로그램을 설치하고 IDE에서 지원하는 코드를 바로 작성할 수 있는 자유를 제공해줘요. 게다가 CoPilot의 베타 그룹에 들어간 운이 있었는데, 이것은 분명한 게임 체인저에요.\n\n소스 제어로는 GitHub이 멋지지만, 다른 솔루션을 무시하지는 않아요. GitLab은 최근 몇 년 동안 정말 멋진 도구로 발전했어요.\n\n메시징 측면에서는 Slack이 여전히 가장 널리 쓰이는 전문적인 선택지라고 생각되고, 그 일을 잘하니까, 다른 것으로 옮겨가야 할 이유가 없어요. 그러나 최근에 Spike라는 매우 흥미로운 소프트웨어를 발견했고, 지난 3개월 동안 이것을 이메일 클라이언트로 사용해왔어요. 회화 스타일로 이메일을 보낼 수 있어서 훨씬 편리해요.\n\n\n\n중요한 도구: 도커, 다른 방법이 없어요. 이것이 업계를 가장 좋게 변화시켰어요. 아직도 의존성을 설치하고 패키지 충돌을 해결해야 했던 어두운 옛날을 기억해요…\n\n하지만, 그래도 쿠버네티스가 점차 적응 수준이 비슷해져 가고 있어요.\n\n## 시작 단계의 소프트웨어 엔지니어를 위한 조언이 있나요?\n\n고객과 대화할 때 두려워하지 마세요. 제 경력 동안, 최고의 소프트웨어 엔지니어는 고객과 협력하여 문제를 해결한 분들이었어요. 때로 한 줄의 코드로 고객의 문제를 해결할 수 있다는 것을 배우면 개발 시간을 6개월 이상 줄일 수 있어요. 저는 최고의 엔지니어들은 실제 세계의 문제에 대한 해결책을 창조한다고 생각해요.\n\n\n\n## 채용 중이신가요? 어떤 역할을 모집하고 계신가요?\n\n언제나 채용 중이에요! 우리는 항상 새로운 동료들이 의미 있는 역할을 맡고 분명한 기여를 할 수 있는 경우에만 고용하려고 노력해요. 현재까지 우리는 많이 성장했기 때문에 각 부서에서 팀원을 더 모집해야 하는 상황입니다. 그래서 목록으로 나열하는 대신에 저희의 채용 페이지를 확인해주세요 :D https://saas.group/career\n\n## 좀 더 자세히 알고 싶은 경우 어디서 확인할 수 있나요?\n\n저희 사이트인 prerender.io를 확인해보세요! 그리고 prerendering에 대해 어떻게 웹을 변경하는지 궁금하시다면 varga@prerender.io로 이메일을 보내 저와 통화를 나누고 싶다면 언제든지 연락해주세요. 항상 여러분의 상황과 사용 사례에 대해 배우고 싶어하는 마음으로 통화에 참여할 준비를 하고 있어요 ^.^\n\n\n\nZsolt Varga는 12,000개 이상의 기업에서 사용되는 Google에서 추천하는 소프트웨어 도구 Prerender의 총괄 매니저입니다. 이 도구는 검색 엔진이 JavaScript 웹사이트를 더 잘 크롤링하고 인덱싱할 수 있도록 합니다.\n\n# Level Up 코딩\n\nLevel Up은 매달 3백만명의 개발자 커뮤니티입니다. 더 많은 정보를 원하거나 스타트업 인터뷰를 읽으려면 팔로우해주세요. 우리는 최고의 스타트업과 가장 혁신적인 기술 기업과 함께 일하고 있어요.🔥\n\n- 개발자이신가요? 최고의 기업들이 여러분을 고용하도록 요청하세요\n➡️ Level Up Talent Collective에 가입하기\r\n- ➡️ FAANG 수준의 엔지니어 고용하기\r\n- ➡️ 인터뷰 요청서를 제출하여 귀사를 인터뷰 받을 수 있도록 하세요\n\n\n\n우리는 개발자들의 경력 성장을 돕기 위한 무료 도구도 제공해요: 코딩 인터뷰 코스, 자동 이력서 빌더, 포트폴리오 API\n\n우리를 팔로우해요: Twitter | LinkedIn | Newsletter","ogImage":{"url":"/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_0.png"},"coverImage":"/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_0.png","tag":["Tech"],"readingTime":9},{"title":"TypeScript 인덱스 시그니처에 대한 설명","description":"","date":"2024-05-14 12:59","slug":"2024-05-14-TypeScriptIndexSignatureExplained","content":"\n\n<img src=\"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png\" />\n\nTypeScript의 인덱스 시그니처는 객체의 속성이 미리 알려지지 않았지만 속성의 유형이 알려진 경우 동적 데이터 구조를 정의하는 방법을 제공합니다. 이들은 동적 속성 액세스를 허용하며 키의 변수 집합을 가진 객체와 작업할 때 특히 유용합니다.\n\n이 게시물에서는 인덱스 시그니처에 대해 자세히 알아보고, TypeScript에서 사용하는 방법 및 사용 시기에 대해 설명할 것입니다.\n\n## 인덱스 시그니처란 무엇인가요?\n\n\n\n인덱스 시그니처는 대괄호 []와 키에 대한 유형, 콜론 및 해당 값에 대한 유형을 사용하여 정의됩니다. 이를 통해 TypeScript는 객체의 예상 구조를 이해하고 강제할 수 있게 됩니다.\n\n```js\ninterface MyStats {\n  [key: string]: number;\n}\nconst scores: MyStats = {\n  total: 50,\n  average:80\n}\n// 인덱스 시그니처는 유형 제약을 강제합니다\n// 여기서 값은 반드시 숫자여야 합니다\nconst scores2: MyStats = {\n  total: \"50\", // 'string' 유형은 'number' 유형에 할당할 수 없습니다.(2322)\n  average: 80\n}\n```\n\n이 예에서 MyStats는 어떤 문자열 키도 가질 수 있고, 해당 키와 연관된 값은 반드시 숫자형이어야 합니다.\n\n인덱스 시그니처의 구문은 인터페이스나 유형 선언 내에서 [] 표기법을 사용하는 것을 포함합니다. 아래 예시는 인터페이스와 유형에 대한 동일한 인덱스 시그니처를 보여줍니다.\n\n\n\n\n인덱스 시그니처는 다양한 키 유형을 사용할 수 있으며 연관 값 유형은 유효한 TypeScript 유형일 수 있음에 유의하세요.\n\n## 인덱스 시그니처를 명시적 멤버와 섞어 사용하기\n\nTypeScript에서 인덱스 시그니처를 명시적 멤버 선언과 혼합할 수 있습니다. 알려진 및 동적 속성을 조합해야 하는 경우에 유용합니다.\n\n\n\n\n```js\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자;\n  가격: 숫자;\n}\n```\n\n인덱스 시그니처와 명시적 멤버를 섞을 때는 모든 명시적 멤버가 인덱스 시그니처 유형을 준수해야 합니다.\n\n```js\n// 유효하지 않은 경우\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자;\n  가격: 숫자;\n  모델: 문자열; // 오류: '모델' 속성의 '문자열' 유형은 '숫자' 인덱스 유형에 할당할 수 없습니다.\n}\n\n// 유효한 경우\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자 | 문자열;\n  가격: 숫자;\n  모델: 문자열;\n}\n```\n\n## 읽기 전용 인덱스 시그니처\n\n\n\n인덱스 시그니처는 읽기 전용 수정자를 지원합니다. 읽기 전용 수정자를 적용하면 객체 내의 속성이 변경 불가능해집니다.\n\n```js\ninterface Car {\n  readonly [key: string]: boolean;\n}\n\nconst toyota: Car = {hybrid: true, luxury: false};\ntoyota.hybrid = false; //에러: 'Car' 타입의 인덱스 시그니처는 오직 읽기만 허용됩니다.(2542)\n```\n\n위 예시에서 'hybrid' 속성을 수정하려고 하면 오류가 발생합니다. 왜냐하면 인터페이스가 읽기만 허용하기 때문이죠.\n\n## 인덱스 시그니처 사용 방법\n\n\n\n실제로 인덱스 시그니처가 어떻게 사용될 수 있는지에 대한 실제 예시를 살펴봅시다. 여러 기능을 포함하는 웹 애플리케이션을 개발하고 있다고 상상해보세요. 각 기능은 해당하는 설정을 가지고 있으며, 이를 활성화하거나 비활성화할 수도 있습니다.\n\n```js\ninterface FeatureConfig {\n  [feature: string]: {\n    enabled: boolean;\n    settings: Record<string, boolean>;\n  }\n}\n```\n\n이 예시에서는 FeatureConfig라는 인터페이스를 정의합니다. 이 인터페이스는 문자열 타입의 동적 속성 이름을 허용하도록 인덱스 시그니처를 사용하며, 해당 속성과 설정 객체와 연결된 enabled 불리언 속성이 포함되어 있습니다. 동적 기능 이름과 관련된 설정을 나타내는 데 유용합니다. 예를 들어, 다음과 같은 객체에 이 인터페이스를 적용할 수 있습니다.\n\n```js\nconst features: FeatureConfig = {\n  profile: {\n    enabled: true,\n    settings: {\n      showPhoto: true,\n      allowEdit: false,\n    },\n  },\n  notification: {\n    enabled: false,\n    settings: {\n      richText: true,\n      batchMode: true\n    },\n  }\n};\n```\n\n\n\n기능 객체에서는 기능 이름이 달라질 수 있지만, 각 기능의 구조는 일관적으로 유지됩니다. 각 기능은 활성화된 부울 값과 설정 객체가 있어야 합니다.\n\n위 인터페이스에서 기능 이름에 유니언 타입 제약을 적용할 수 있을까요?\n\n만약 애플리케이션에서 사용하는 기능 집합이 알려져 있다면, 문자열 리터럴의 유니언인 FeatureType을 정의할 수 있습니다.\n\n```js\ntype FeatureType = '프로필' | '알림' | '리포팅';\n```\n\n\n\n색인 시그니처 키는 유니언 타입을 지원하지 않지만, 맵드 타입을 사용하여 해결할 수 있습니다.\n\n```js\ntype FeatureConfig2 = {\n  [feature in FeatureType]: {\n    enabled: boolean;\n    settings: Record<string, boolean>;\n  }\n}\n```\n\n[feature in FeatureType]는 유니온 타입 FeatureType(프로필, 알림 및 보고서를 포함)의 각 문자열 리터럴을 반복하는 맵드 타입이며, 각 값을 결과 타입의 속성 이름으로 사용합니다.\n\n다음은 사용 예시입니다:\n\n\n\n```js\nconst allFeatures: FeatureConfig2 = {\n   profile: {\n      enabled: true,\n      settings: {\n         showPhoto: true,\n         allowEdit: false,\n      },\n   },\n   notification: {\n      enabled: false,\n      settings: {\n         richText: true,\n         batchMode: true\n      },\n   },\n   reporting: {\n      enabled: true,\n      settings: {\n         template: false,\n         advanceExport: true\n      },\n   },\n};\n```\n\n모든 기능이 FeatureType에 정의된 모든 기능과 일치해야 합니다.\n\n만약 일부 기능을 허용하려면 색인 서명 유형을 \"?\"를 선택적 플래그로 하는 형태로 수정해야 합니다. 그런 다음, FeatureConfig2 유형을 사용하여 일부 기능만 포함하는 객체를 만들 수 있습니다.\n\n```js\ntype FeatureType = 'profile' | 'notification' | 'reporting';\n\ntype FeatureConfig2 = {\n  [feature in FeatureType]?: {\n    enabled: boolean;\n    settings: Record<string, boolean>;\n  }\n}\n\nconst subsetFeatures: FeatureConfig2 = {\n   profile: {\n      enabled: true,\n      settings: {\n         showPhoto: true,\n         allowEdit: false\n      },\n   }\n};\n```\n\n\n\n## 인덱스 시그니처를 효과적으로 사용하는 방법\n\n일반적으로 사용되는 시나리오에는 다음이 포함됩니다:\n\n- 설정 객체: 위 예제에서 보듯, 인덱스 시그니처는 설정 객체가 동적 키와 관련 값이 있을 수 있는 시나리오에서 뛰어난 성능을 발휘합니다.\n- 데이터 변환: 데이터 변환이나 구문 분석을 다룰 때 인덱스 시그니처는 유용할 수 있습니다. 입력 데이터의 구조가 다양한 경우 유연하게 처리할 수 있습니다.\n- 확장성: 플러그인 아키텍처나 모듈식 시스템과 같이 확장성이 중요한 프로젝트에서는 새 구성 요소를 추가할 때 기존 코드를 수정하지 않고 인덱스 시그니처를 이용할 수 있습니다.\n\n인덱스 시그니처는 강력하지만 남용해서는 안 됩니다. 인덱스 시그니처를 구현하기 전에 데이터 구조를 더 명시적인 인터페이스나 타입 정의로 대체할 수 있는지 고려해야 합니다, 특히 키가 특정 의미를 가질 때입니다.\n\n\n\n다른 고려 사항은 인덱스 시그니처를 엄격하게 테스트하는 것입니다. 이는 동적 구조의 특성이 예기치 못한 문제를 발생시키지 않도록 다양한 키-값 조합을 테스트하여 확인하는 것을 포함합니다.\n\n흔한 실수를 피하고 최선의 방법을 따르면 TypeScript 코드를 더 유연하고 탄력적으로 만드는 데 인덱스 시그니처를 사용할 수 있습니다.\n\n즐거운 프로그래밍 되세요!","ogImage":{"url":"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png"},"coverImage":"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png","tag":["Tech"],"readingTime":5},{"title":"JavaScript에서 웹 브라우저가 접근 불가능할 때 카운터 상태를 유지하는 가장 쉬운 방법localStorage에서 재생성","description":"","date":"2024-05-14 12:58","slug":"2024-05-14-TheeasiestwaytokeepcounterstateafterwebbroswerisnotaccessiblerehydrateitfromlocalStorageinJavaScript","content":"\n\n최근 QA 팀에서 흥미로운 질문을 받았어요. 그 질문은, 왜 우리 이메일 토큰 카운터가 그들이 컴퓨터를 절전 상태로 변경할 때 멈추는지였어요? 처음에는 웹 브라우저가 실행 중이 아니면 우리의 JavaScript 애플리케이션이 작동하지 않는다는 일반적인 가정을 공유했어요. 하지만 그들의 우려는 사용자가 시간을 조작하여 이메일로 토큰을 다시 보낼 수 있는 보안 문제로 유효한 지점을 제기했어요.\n\n아래는 문제가 된 기능인데요, 시작시간이 5분이고 토큰이 만료될 때까지 0으로 감소하는 간단한 카운터였어요. 중요한 점은 모든 논리가 백엔드에서 처리되었고, 프론트엔드는 단순히 카운터의 시각적인 표현을 담당했다는 것이었어요.\n\n팀원 중 한 명이 작성한 카운터 코드의 간단한 부분이에요:\n\n\n\n```js\nclass TimeCounter {\n    minutes = null\n    seconds = null\n    dateStored = null\n    minutesStored = null\n    secondsStored = null\n\n    constructor(minutes = 0, seconds = 0) {\n        this.minutes = minutes\n        this.seconds = seconds\n    }\n\n    start() {\n        this.saveTimer()\n        this.timer = setInterval(() => {\n            this.callback()\n        }, 1000)\n    }\n\n    stop() {\n        clearInterval(this.timer)\n    }\n\n    callback() {\n        if(this.minutes === 0 && this.seconds === 0) {\n            this.stop() // Stop counter\n            return\n        }\n\n        if (this.seconds === 0) {\n            this.seconds = 59\n            this.minutes--\n        } else {\n            this.seconds--\n        }\n    }\n}\n```\n\n문제점\n\n사용자가 컴퓨터를 절전하여 카운터를 중지할 수 있습니다. 다시 작동시킬 때 타이머는 중단한 지점부터 다시 시작하여 사용자가 토큰 유효기간을 효과적으로 연장할 수 있습니다.\n\n해결책 — 로컬스토리지\n\n\n\n이 문제에 대처하기 위해 LocalStorage를 활용한 해결책을 구현했습니다. 콜백 메서드가 호출될 때마다 현재 분, 초, 타임스탬프를 저장했습니다. 이 타임스탬프를 현재 시간과 비교하여 어떤 차이가 있는지 감지하여 토큰 만료 로직이 유지되도록 했습니다.\n\n![이미지](/assets/img/2024-05-14-TheeasiestwaytokeepcounterstateafterwebbroswerisnotaccessiblerehydrateitfromlocalStorageinJavaScript_1.png)\n\n이제 해결책을 적용한 코드입니다:\n\n```js\nclass TimeCounter {\n    minutes = null\n    seconds = null\n    dateStored = null\n    minutesStored = null\n    secondsStored = null\n\n    constructor(minutes = 0, seconds = 0) {\n        this.minutes = minutes\n        this.seconds = seconds\n    }\n\n    start() {\n        this.saveTimer()\n        this.timer = setInterval(() => {\n            this.callback()\n        }, 1000)\n    }\n\n    stop() {\n        clearInterval(this.timer)\n    }\n\n    saveTimer() {\n        const timeElapsed = Date.now();\n\n        if (timeElapsed != 0) {\n            localStorage.setItem('dateStored', timeElapsed)\n            localStorage.setItem('minutes', this.minutes)\n            localStorage.setItem('seconds', this.seconds)\n        }\n    }\n\n    getTimer() {\n        this.dateStored = Number(localStorage.getItem('dateStored'))\n        this.minutesStored = Number(localStorage.getItem('minutes')) \n        this.secondsStored = Number(localStorage.getItem('seconds'))   \n    }\n\n    checkDifference() {\n        this.getTimer()\n\n        const nowElapsed = Date.now();\n        const diff = nowElapsed - this.dateStored\n        \n        // check if time is 5 seconds late compared to stored\n        if (diff > 5000) {\n            this.setCurrentTimer(diff)\n        }\n    }\n\n    setCurrentTimer(diff) {\n        const elapsedStored = (this.minutesStored * 60000) + (this.secondsStored * 1000)\n        const currentTimeLeft = elapsedStored - diff\n        const now = new Date(currentTimeLeft)\n        const minutes = now.getMinutes()\n        const seconds = now.getSeconds()\n\n        if (minutes > tokenTimersEnum.VALIDATION_MINUTES) {\n            this.minutes = 0\n            this.seconds = 0\n        } else {\n            this.minutes = minutes\n            this.seconds = seconds\n        }\n    }\n\n\n    callback() {\n        this.checkDifference()\n\n        if(this.minutes === 0 && this.seconds === 0) {\n            this.stop()\n            return\n        }\n\n        if (this.seconds === 0) {\n            this.seconds = 59\n            this.minutes--\n        } else {\n            this.seconds--\n        }\n        \n        this.saveTimer()\n    }\n}\n```\n\n\n\n요약\n\nLocalStorage는 사용자 브라우저 내에서 데이터를 지속시키는 데 유용한 도구로 입증되었습니다. 이를 활용함으로써 토큰 만료 메커니즘의 무결성을 유지할 수 있었고, 시간을 조작하려는 사용자의 시도가 있더라도 문제없이 작동했습니다.\n\n프론트엔드 처리나 동작이 중요한 유사한 상황에서는 LocalStorage 솔루션을 고려하는 것이 유익할 수 있으며, 원활하고 안전한 사용자 경험을 보장할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-TheeasiestwaytokeepcounterstateafterwebbroswerisnotaccessiblerehydrateitfromlocalStorageinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-TheeasiestwaytokeepcounterstateafterwebbroswerisnotaccessiblerehydrateitfromlocalStorageinJavaScript_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular에서의 코드 스멜  심층 분석  Part II","description":"","date":"2024-05-14 12:56","slug":"2024-05-14-CodesmellsinAngularDeepDivePartII","content":"\n\n내 최근 블로그 게시물 중 하나에서 런타임 성능과 관련한 상위 5개 코드 스멜에 대해 깊이 파고들었습니다. 이번에는 프로젝트의 유지 관리성과 관련된 코드 스멜에 대해 더 많은 이야기를 나누고 싶습니다. 이 내용은 이전 블로그 게시물 [1]에 명시되어 있어요.\n\n하지만, 하나의 코드 스멜을 추가하고 싶은데요, 바로 모듈 경계와 DRY 원칙입니다. 왜 이것을 추가하려고 하는 걸까요? 여러 달 동안 DRY 원칙이 제대로 이해되지 않았다는 것을 알게 되었기 때문에, 이 주제에 대해 더 내용을 발전시키고자 합니다.\n\n![이미지](/assets/img/2024-05-14-CodesmellsinAngularDeepDivePartII_0.png)\n\n## 1a. 모듈 경계와 DRY 원칙\n\n\n\n이전 블로그 게시물 중 하나에서 프론트엔드에 DDD 개념을 추가하는 것을 제안했습니다. 이는 프로젝트를 쉽게 유지보수할 수 있도록 도와줄 것입니다 [2]. 다음 다이어그램은 예약 및 오퍼 서브도메인 뿐만 아니라 공유 도메인을 보여줍니다.\n\n이 방식의 큰 장점은 무엇일까요?\n\n- 모듈 경계를 쉽게 정의할 수 있음\n- 모듈 간 느슨한 결합\n- 구성 요소 및/또는 모델을 공유하기 위한 명시적 API\n\n![다이어그램](/assets/img/2024-05-14-CodesmellsinAngularDeepDivePartII_1.png)\n\n\n\n하지만 더 중요한 것이 하나 더 있어요. 바로 DRY 원리에 관한 것인데요. DRY 원리는 코드를 중복해서 작성하지 말고 재사용해야 한다는 원칙을 말해요. 실제로 각 하위 도메인 안에서도 그렇게 되어 있어요. 즉, 예약 부분에서는 코드를 중복해서 작성하면 안 돼요. 그렇다면 해당 부분을 예약 하위 도메인 안에 공유 모듈로 이동해 주세요.\n\n하지만 이는 두 개의 하위 도메인 사이에 중복된 코드가 없어야 한다는 것을 의미하는 건 아니에요. 사실 유지보수성을 고려하면 모델이나 컴포넌트를 중복해서 작성하는 것이 오히려 합리적일 수도 있어요. 그 이유는 하위 도메인 간의 느슨한 결합을 보장하고 싶기 때문이에요.\n\n계층 구조에도 동일한 원리가 적용돼요. 모듈 간에 강하게 결합되어 있다면 이를 제거하려 노력해야 하며, 이를 위해서 코드를 중복해야 하는 경우라도 꺼려서는 안 돼요.\n\n그래서 프론트엔드 아키텍처와 모듈 경계는 어떤 프로젝트의 유지보수성에 큰 영향을 미친답니다. 프론트엔드에 DDD 개념을 적용할 필요는 없지만 모듈 간의 느슨한 결합을 유지하려 노력하는 것이 중요하답니다.\n\n\n\n## 1b. Imports 처리 - 모듈 해결 없음\n\n자주 볼 수있는 코드 스멜 중 하나는 모듈 해결이 없다는 것입니다. 왜 코드 스멜인가요? 모듈 해결이 없으면 import 경로에 매우 강하게 결합되어 있습니다. 경로가 변경되면 import도 변경해야 합니다. 우리가 원하는 행동은 아닙니다.\n\n```js\nimport {Offers} from '../../../offers/models/offers.model';\nimport {Receipt} from '../../../booking/models/receipt.model';\nimport {StringUtils} from '../../shared/utils/string.utils';\n```\n\n각 디렉토리에 대한 배럴 파일을 도입하여 이러한 import에 어떤 영향을 미치는지 살펴봅시다.\n\n\n\n```js\nimport {Offers} from '../../../offers/models';\nimport {Receipt} from '../../../booking/models';\nimport {StringUtils} from '../../shared/utils';\n```\n\n위의 해결책은 개선되었지만 여전히 상대 경로 대신 절대 경로를 사용합니다. 수동으로 변경할 수 있지만 꽤 귀찮고 시간이 오래 걸립니다. 그래서 모듈 해결책을 소개해보겠습니다.\n\n다음 코드 스니펫을 tsconfig.json 파일에 추가합니다.\n\n```js\n\"compilerOptions\": {\n   ...\n   \"paths\": {\n       \"@offers/*\": [\"/src/app/offers/*\"],\n       \"@booking/*\": [\"/src/app/booking/*\"],\n       \"@shared/*\": [\"/src/app/shared/*\"],\n   }\n   ...\n}\n```\n\n\n\n지금부터는 기존 컴포넌트 내에서 imports를 간소화하기 위해 알림을 받게 될 것입니다. 그리고 모든 새로운 imports는 자동으로 새로운 모듈 해상도를 사용하게 됩니다.\n\n```js\nimport {Offers} from '@offers/models';\nimport {Receipt} from '@booking/models';\nimport {StringUtils} from '@shared/utils';\n```\n\n## 2. 컴포넌트 내에서의 다중 책임\n\n지금까지 접했던 또 다른 코드 냄새는 컴포넌트 내에서의 다중 책임입니다. 이는 단일 책임 원칙(SRP)과 충돌될 수 있습니다. SRP는 컴포넌트가 한 가지 일을 잘 처리해야 하지만 여러 가지 역할을 해서는 안 된다는 것을 명시합니다.\n\n\n\n예시를 살펴보겠습니다. 다음 코드 조각은 예약을 검색하는 구성 요소를 보여줍니다. 그러나 더 자세히 살펴보면 이 구성 요소는 오퍼를 추가할 수 있는 기능도 제공합니다. 오퍼와 예약은 서로 다른 것이며(두 개의 서로 다른 서브도메인이기도 합니다), 하나의 구성 요소에서 다루어지면 안됩니다.\n\n```js\nexport class SearchBookingComponent implements OnInit {\n\n  bookings: Booking[];\n  searchControl = new UntypedFormControl();\n  filteredBookings$: Observable<Booking[]>;\n\n  constructor(private bookingService: BookingService,\n              private offerService: OfferService) {\n    bookingService.getAll()\n      .pipe(first())\n      .subscribe((bookings) => {\n        this.bookings = bookings;\n      });\n  }\n\n  ngOnInit() {\n    this.filteredBookings$ = this.searchControl.valueChanges.pipe(\n      switchMap((searchText) => this.bookingService.search(searchText)),\n      startWith(this.bookings)\n    );\n  }\n\n  bookOffer(offer: Offer) {\n    this.offerService.bookOffer(offer);\n  }\n}\n```\n\n또 다른 예시는 구성 요소 템플릿이 너무 복잡하다는 것입니다. 다음 코드 조각은 검색 입력 필드나 예약 목록 항목 뿐만 아니라 정보 대화상자까지 포함되어 있음을 보여줍니다.\n\n```js\n<form autocomplete=\"off\" class=\"form-container\">\n  <div class=\"form-content\">\n    <h2 mat-subheader>Search bookings</h2>\n    <div class=\"pl-3 pr-3\">\n      <mat-form-field>\n        <input matInput [formControl]=\"searchControl\" placeholder=\"Searching\">\n        <mat-icon matSuffix>search</mat-icon>\n      </mat-form-field>\n    </div>\n    <mat-list>\n      <section class=\"scroll-container\">\n        <ng-container>\n          <ng-container *ngFor=\"let booking of (filteredBookings$ | async)\">\n            <mat-list-item>\n              <h4 mat-line>{booking?.header}</h4>\n              <p mat-line>{booking?.content} </p>\n              <button\n                      type=\"button\"\n                      mat-icon-button\n                      (click)=\"showBookingDetailsAction.emit()\">\n                <mat-icon aria-label=\"Side nav toggle icon\">info</mat-icon>\n              </button>\n              <button\n                      type=\"button\"\n                      mat-icon-button\n                      (click)=\"bookOfferAction.emit()\">\n                <mat-icon aria-label=\"Side nav toggle icon\">add_shopping_cart</mat-icon>\n              </button>\n              <ng-content></ng-content>\n            </mat-list-item>\n          </ng-container>\n        </ng-container>\n      </section>\n      <section class=\"info-dialog\" *ngIf=\"(dialogVisible$ | async)\">\n        <button type=\"button\" mat-button.mat-small class=\"button-dismiss\"\n            (click)=\"close.next(true)\"><i class=\"fal fa-times\"></i>\n        </button>\n        <h1 mat-dialog-title><b>{ title }</b></h1>\n        <div mat-dialog-content>\n          <div class=\"font-settings\" [innerHTML]=\"infos\"></div>\n        </div>\n        <div mat-dialog-actions class=\"flex-content-end\">\n          <button type=\"button\" mat-raised-button\n                  (click)=\"close.next(true)\">Close\n          </button>\n        </div>\n      </section>\n    </mat-list>\n  </div>\n</form>\n```\n\n\n\n첫 번째 개선 사항은 info-dialog을 별도의 컴포넌트로 이동하는 것입니다. 그러나 이것이 우리가 해야 할 유일한 개선 사항일까요? 아니요, 아닙니다. 단일 컴포넌트는 가능한 적은 사용자 상호 작용(또는 사용 사례)을 가져야 합니다.\n\n사용 사례는 무엇인가요?\n\n- 예약 검색\n- 예약을 장바구니에 추가\n- 예약 정보 표시\n\n따라서 예약 목록 항목 컴포넌트도 도입할 것입니다.\n\n\n\n## 3. 서비스 내 유틸리티 기능\n\n테스트 작성은 정말 힘들 수 있어요. 시간이 지날수록 서비스와 컴포넌트는 복잡해지는 경향이 있어요. 그래서 매번 컴포넌트 및 서비스 테스트를 조정해야 해요. 거의 항상 추가해야 하는 종속성 때문이죠.\n\n그래서 나는 언제나 비즈니스 로직을 서비스나 컴포넌트가 아닌 유틸 클래스로 옮길 거예요. 먼저, 유틸은 테스트하기가 훨씬 쉽고, 둘째로, 각 서브도메인의 비즈니스 로직을 단일 파일에 두고 싶어요. 전체 서브도메인을 훑어가며 비즈니스 로직을 찾지 않길 원하거든요.\n\n```typescript\nexport class BookingUtil {\n\n    public static isBookingSold(status: BookingStatus): boolean {\n        return [\n            bookingStatus.Reserved,\n            bookingStatus.WaitingForCustomer,\n            bookingStatus.Sold\n        ].includes(status);\n    }\n\n    public static isBookingCancelable(status: BookingStatus, alterationType: BookingAlterationType): boolean {\n        return (\n            [\n             bookingStatus.WaitingForCustomer\n            ].includes(status) &&\n            [\n             bookingAlterationType.Cancelable,\n             bookingAlterationType.CancelableOnWaiting\n            ].includes(alterationType)\n        );\n    }\n\n    public static getNextBookingNumber(bookings: Booking[]): number {\n        const bookingNumbers = bookings\n                    .filter((booking) => isNotEmpty(booking.bookingNumber))\n                    .map((booking) => booking.bookingNumber));\n        \n        return Math.max(...bookingNumbers);\n    }\n\n    public static mergeBookings(firstBooking, secondBooking): number {\n        ...\n    } \n}\n```\n\n\n\n## 4. 중첩된 구독\n\n다음으로 지적하고 싶은 코드 스멜은 중첩된 구독입니다. 중첩된 구독은 필요 이상으로 코드 라인이 더 많을 뿐만 아니라 원하지 않는 부작용을 일으킬 수도 있습니다.\n\n예를 들어, 다음 코드 조각을 살펴보겠습니다. 검색 입력 필드의 텍스트가 변경될 때마다 HTTP 요청이 생성됩니다. 그러나 사용자가 문자를 추가할 때마다 HTTP 요청이 한 번만 실행되지 않고 여러 번 실행될 수 있습니다. 왜냐하면 두 번째 구독이 닫히지 않았기 때문입니다.\n\n```js\nconst filteredBookings$ = new BehaviorSubject<Booking[]>([]);\nthis.searchControl.valueChanges.pipe(takeUntil(this.destroy$))\n     .subscribe((text) => {\n          this.bookingService.search(text).pipe(takeUntil(this.destroy$))\n              .subscribe((bookings) => {\n                  this.filteredBookings$.next(bookings);\n              });\n      });\n```\n\n\n\n이건 쉽게 수정할 수 있어요. takeUntil(this.destroy$)을 first()로 교체하면 됩니다. 하지만 여전히 많은 코드가 남아 있네요.\n\n```js\nconst filteredBookings$ = new BehaviorSubject<Booking[]>([]);\nthis.searchControl.valueChanges.pipe(takeUntil(this.destroy$))\n     .subscribe((text) => {\n          this.bookingService.search(text).pipe(first())\n              .subscribe((bookings) => {\n                  this.filteredBookings$.next(bookings);\n              });\n      });\n```\n\n그래서 아래와 같이 코드를 간소화할 거예요. 이제 훨씬 깔끔하고 유지보수가 쉬워졌어요.\n\n```js\nconst filteredBookings$ = this.searchControl.valueChanges.pipe(\n  switchMap(text => this.bookingService.search(text))\n)\n```\n\n\n\n다음 예시는 ngOnInit에서 사용할 수 없는 ViewChild입니다. 그러므로 BehaviorSubject를 사용하는 setter를 추가하여 PdfViewerComponent의 초기화에 대해 쉽게 알림을 받을 수 있습니다.\n\n```js\n@ViewChild('viewer')\nset viewer(viewer: PdfViewerComponent | undefined) {\n    this.viewer$.next(viewer);\n}\n```\n\n이제 PdfViewerComponent에 의해 트리거된 모든 텍스트 선택 변경 사항에 구독하려고 합니다. 첫 번째 해결 방법은 다음과 같을 수 있습니다. 그러나 PdfViewer의 첫 번째 유효한 값만 필요하고 그 후에 변경 사항에 구독하려고 합니다. 중첩된 구독 없이 또는 그렇지 않을까요? \n\n```js\nconst ranges$ = new BehaviorSubject<Range[]>([]);\nthis.pdfViewer$.pipe(filter((viewer) => viewer != null), takeUntil(this.destroy$))\n     .subscribe((viewer) => {\n        this.textSelectionDestroy$.next();\n        viewer?.textSelection.pipe(takeUntil(this.textSelectionDestroy$))\n              .subscribe((ranges) => {\n                  ranges$.next(ranges);\n              });\n});\n```\n\n\n\n물론, 이 문제에 대한 해결책이 있어요. 다음 코드를 살펴봐요. 하지만 잠시만요, 실수가 있네요. 모든 텍스트 선택 변경에 대해 알림을 받지 않고 첫 번째 변경에 대해서만 알게 될 거예요.\n\n```js\nconst ranges$ = this.pdfViewer$.pipe(\n      filter((viewer): viewer is NonNullable<PdfViewerComponent> => viewer != null),\n      switchMap((viewer) => viewer.textSelection$)\n);\n```\n\n오, 네 맞아요. 첫 번째 observable에서 구독을 취소해야 해요. `first()`를 추가해야 해요. 이제 코드가 잘 작동해요.\n\n```js\nconst ranges$ = this.pdfViewer$.pipe(\n      filter((viewer): viewer is NonNullable<PdfViewerComponent> => viewer != null),\n      first(),\n      switchMap((viewer) => viewer.textSelection$)\n);\n```\n\n\n\n## 5. Mutable 대신 immutable을 사용하세요\n\n객체나 배열을 직접 수정할 필요가 없습니다. 성능상의 이유일 때만 예외적으로 배열 조작을 직접 할 수 있습니다. 그 외에는 항상 immutable을 유지하는 것을 권장합니다.\n\n```js\narray.sort(...)   =>  array.slice().sort(...)\narray.splice(...) =>  [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)] \nobj.test = \"123\"  =>  obj = {...obj, test: \"123\"} \n\nObject.assign(obj, {test: \"123\"})  =>  obj = {...obj, test: \"123\"};\n \narray.push(...)   =>  array = array.concat(...)\ndelete obj.test   =>  const {test, ...objWithoutTest} = obj;\n```\n\nAngular에서 왜 이것이 중요한가요?\n\n\n\n만약 전에 작성한 블로그 포스트 [1] (코드 스멜의 첫 번째 부분)를 읽었다면, ChangeDetection 및 OnPush-Strategy에 익숙할 것입니다. 이는 뷰가 개체를 조작해도 다시 렌더링되지 않지만, 개체 참조가 변경되면 다시 렌더링됨을 의미합니다.\n\n따라서 우리는 불변해야 합니다. 이는 구성 요소뿐만 아니라 순수 파이프에도 적용됩니다. 순수 파이프는 입력 참조가 변경된 경우에만 변환 기능을 트리거합니다.\n\n# 요약\n\n지금까지 경험한 상위 5가지 코드 스멜에 대해 심층적으로 살펴보았습니다. 따라서 모듈 해결 방법을 사용하고, 불변성을 유지하며, 중첩된 구독을 피하고, 비즈니스 로직을 단일 테스트 가능한 파일로 이동시키고, 구성 요소에 여러 책임을 부여하지 않도록 주의해주시기 바랍니다.\n\n\n\n## 링크\n\n- [1] [여기](https://medium.com/@robert.maiersilldorff/code-smells-in-angular-deep-dive-part-i-d63dd5f5215e)\n- [2] [여기](https://blog.bitsrc.io/clean-frontend-architecture-2995c68702fb)","ogImage":{"url":"/assets/img/2024-05-14-CodesmellsinAngularDeepDivePartII_0.png"},"coverImage":"/assets/img/2024-05-14-CodesmellsinAngularDeepDivePartII_0.png","tag":["Tech"],"readingTime":11},{"title":"오프라인 사용 가능한 웹 애플리케이션 개발하기","description":"","date":"2024-05-14 12:54","slug":"2024-05-14-DevelopingOffline-ReadyWebApplications","content":"\n\n![IMG](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png)\n\n네, 제목을 제대로 읽으셨어요. 대부분의 웹 애플리케이션에서는 네트워크 접근이 가능할 것이라는 내제적인 가정이 있습니다. 사이트가 서버 측 렌더링, 정적 생성 또는 브라우저를 통해 완전히 작성되었는지에 상관없이 HTML, CSS 및 JS는 네트워크를 통해 HTTP 요청을 통해 가져옵니다. 각 페이지가 로드될 때 추가 리소스를 가져오거나 타사 API와 통신할 수 있습니다. 네트워크 탭을 빠르게 살펴보면 사이트가 대화형임을 알 수 있습니다. Google Analytics 이벤트부터 Stripe 위젯, 버그 추적 소프트웨어까지, 단일 페이지가 사용자 입력 없이도 계속 네트워크에 액세스할 수 있습니다. 기본적인 가정에 도전했을 때 어떻게 해야 할까요? 네트워크가 사용할 수 없을 때 웹 개발자로서 사용자에게 어떻게 서비스를 제공할 수 있을까요?\n\n# Service Workers - 오프라인 문제에 대한 해답\n\n이 문제를 해결하기 위해 Google, Samsung, Mozilla 및 기타 회사들이 협력하여 2014년 5월에 서비스 워커의 W3C 초안을 처음 소개했습니다. 그 전에 기본적인 웹 워커를 살펴보겠습니다 - 주 프로그램의 “백그라운드\"에서 실행되는 JavaScript 파일입니다. 웹 워커는 자체 스레드를 가지고 있지만 주 JavaScript 스레드와 계속 통신할 수 있습니다. 이 별도의 스레드를 통해 주 프로그램의 코드 실행을 차단하지 않으면서 백그라운드에서 계산적으로 비용이 많이 드는 작업을 수행할 수 있으므로 사용자 경험을 방해하지 않습니다. 웹 워커는 현재 창과는 별개의 컨텍스트에서 실행되며 DOM이나 창 객체에 액세스할 수 없습니다.\n\n\n\n## 서비스 워커란\n\n서비스 워커는 귀하의 사이트와 제삼자 간에 프록시처럼 작동하는 전문화된 웹 워커입니다. 요청이 서비스 워커에 의해 가로채지며 응답은 그를 통해 라우팅됩니다. 서비스 워커는 원본과 경로 또는 패턴(URL의)에 바인딩되어 해당 원본에서 발생하는 이벤트(예: fetch)에 응답합니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_1.png)\n\n이 경로 또는 패턴은 서비스 워커의 범위와 관련이 있으며 등록된 경로 및 해당 경로 내의 모든 중첩된 경로를 포함합니다. 서비스 워커가 mysite.com/puppies/sw.js에서 등록된 경우 mysite.com/puppies/labs 및 mysite.com/puppies/boxers에 대해 작동합니다. 이는 서비스 워커가 실행되는 범위이며 한 범위에는 하나의 서비스 워커만 등록될 수 있습니다. 그러나 선택적으로 이 기본 범위를 좁힐 수 있습니다.\n\n\n\n웹 워커들과는 다르게, 서비스 워커들은 시간 제한이 있어서 밀리초 단위로 생성되어 작업을 수행한 뒤 소멸될 수 있습니다. 이러한 의도적으로 짧은 수명은 스크립트 내에서 전역 상태에 의존하는 것을 불가능하게 만듭니다. 대신, 이들은 브라우저의 IndexedDB나 캐시 API에 기본 액세스 권한을 부여받아 데이터를 저장하고 검색할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_2.png)\n\n서비스 워커는 보완 기능으로서, 비공식 브라우저에서도 여전히 사이트의 모든 콘텐츠에 액세스할 수 있습니다. 그리고 그 보완 기능은 광범위합니다 — 캐싱, 백그라운드 동기화, 푸시 알림 및 오프라인 기능을 포함합니다.\n\n## 서비스 워커 생명 주기\n\n\n\n서비스 워커에는 라이프사이클이 있어 엔드 사용자의 브라우저와 상호작용하는 방식을 규정합니다. 서비스 워커가 등록되고 설치될 때까지 클라이언트로의 네트워크 흐름을 제어하지 않습니다. 심지어 서비스 워커도 해당 범위로의 다음 탐색으로 들어가기 전까지 요청을 프록시로 전달하지 않습니다.\n\n- 등록 — 이 첫 번째 단계는 사용자가 서비스 워커의 범위 내에서 URL을 입력할 때 발생합니다. 서비스 워커는 브라우저가 지원되는지 확인하고, 그렇다면 등록 함수가 호출되어 스크립트의 URL을 범위에 연결합니다. 대부분의 모던 브라우저에서 애플리케이션 탭의 개발자 도구에서 서비스 워커 등록을 확인할 수 있습니다. 주어진 서비스 워커에 대해 최대 한 번만 발생할 수 있는 단계입니다.\n- 다운로드 — 등록이 성공하면 서비스 워커가 클라이언트 브라우저로 다운로드됩니다. 사용자로부터 권한을 요청하지 않고 백그라운드에서 조용히 진행됩니다. 업데이트 후 다운로드가 진행되면 이전 서비스 워커 코드와 최신으로 다운로드된 코드 간의 바이트 단위 비교가 이루어집니다. 다른 경우 설치가 진행됩니다.\n- 설치 — 새로 다운로드된 서비스 워커 파일이 있으면 설치가 시작됩니다. 범위로 처음으로 서비스 워커가 다운로드된 경우 즉시 활성화됩니다. 업데이트 이후 설치가 발생하면 즉시 활성화되지 않고 대기합니다.\n- 대기 — 이는 업데이트 중에만 발생합니다. 이전 서비스 워커는 클라이언트의 프록시로 계속 작동하며 현재 서비스 워커를 사용하는 웹 페이지가 더 이상 없을 때까지 기다립니다. 그러나 대기 기간을 건너뛰기 위해 특정 함수를 호출함으로써 대기를 우회할 수도 있습니다.\n- 활성화 — 대기 또는 설치 직후에 활성화 이벤트가 발생하며 그 순간 캐시를 정리하거나 다른 작업을 실행할 수 있습니다.\n- 업데이트 — 사용자가 서비스 워커의 범위 내 페이지로 돌아가거나 등록 함수가 호출되거나 이벤트가 발생하지만 지난 24시간 동안 업데이트가 발생하지 않은 경우 업데이트가 발생합니다. 업데이트 중에 단계 2~5가 반복됩니다 (단계 2, 3은 기울임꼴로 표시됨).\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_3.png)\n\n## 서비스 워커가 오프라인 웹 사이트를 가능하게 하는 방법\n\n\n\n서비스 워커는 프록시로 작동합니다. 이 서비스 워커는 fetch 이벤트에 접근을 제공하여 다양한 조건에 따라 애플리케이션의 동작을 변경할 수 있게 해줍니다. 또한 강력한 캐싱 API를 가지고 있습니다.\n\n뉴욕시에 사는 사용자라고 상상해봅시다. 지역 유기농 식품을 판매하는 웹사이트를 둘러보고 지하철에 올라탔더니 신호가 끊겼습니다. 갑자기 고장난 웹페이지가 보입니다. 사이트를 새로고침해봐도 고장나 있습니다. 뒤로 가기 버튼을 눌러봐도 여전히 고장났습니다. 서비스가 없다면 브라우저의 HTTP 요청은 어떤 API에도 전달되지 않습니다. 페이지가 로드되지 않고, 양식이 전송되지 않습니다 — 오프라인 상태입니다. 이런 상황을 우리는 모두가 사용자로서 경험해봤습니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_4.png)\n\n이제 이 웹사이트가 서비스 워커를 활용한다고 상상해봅시다. 이제 지하철에 들어가서도 웹사이트를 계속해서 둘러볼 수 있습니다. 경험은 매끄럽습니다 — 하지만 숨긴 데이터 불일치가 있을 수 있습니다. 양식을 제출해보려고 하면 오프라인임을 알려주고 나중에 다시 시도하라는 메시지가 표시됩니다 (PWA를 통해 연결이 다시 활성화되면 이 양식이 전송될 수 있습니다, 아래 참조). 바 현황을 한번 봐보시면, 맞습니다 — 오프라인입니다. 언제 그런 일이 발생했을까요?\n\n\n\n사용자에게 완벽한 경험이 아니더라도, 고장난 웹페이지보다 훨씬 나은 것입니다. 특히 이는 블로그와 같이 다양한 상호작용이 불필요한 사이트에 이상적입니다. 이는 서비스 워커 캐시를 활용하여 구현됩니다. 네트워크 요청이 전송되면 서비스 워커가 데이터나 페이지를 캐시할 수 있습니다. 네트워크 연결이 끊어진 경우, 캐시로부터 해당 페이지를 제공하여 사용자에게 더욱 편리한 경험을 제공할 수 있습니다.\n\n# 서비스 워커와 PWA\n\n우리는 이미 서비스 워커가 최종 사용자에게 오프라인 접근성을 제공하는 방법을 명확히 알아보았습니다. 그런데, 그 외에도 어떤 일을 할 수 있을까요? 이것은 관련 개념인 점진적 웹 애플리케이션(Progressive Web Applications, PWAs)로 이어집니다.\n\nPWA는 웹 기반 앱이지만 기기에서 네이티브 애플리케이션과 유사한 경험을 제공합니다. 다른 웹사이트와 마찬가지로 기본적인 HTML, CSS, JS로 작성되어 창에 액세스할 수 있고 API에 네트워크 요청을 보낼 수 있습니다. 그러나 다른 웹사이트에는 없는 강력한 기능이 여러 가지 있습니다.\n\n\n\n## PWA를 설치할 수 있습니다\n\n일반 웹사이트와는 달리 PWA는 웹 앱 매니페스트의 명세에 따라 설치할 수 있습니다. 이를 통해 브라우저에 설치할 방법을 알려줍니다. 매니페스트에는 설치된 PWA의 경험을 사용자 정의하는 데 많은 특성을 포함할 수 있습니다.\n\n또한, 설치된 PWA는 앱과 같이 기기에 아이콘이 표시됩니다. 브라우저에 액세스하지 않고도 실행할 수 있으며 독립적인 애플리케이션으로 작동합니다. 어떤 경우에는 앱 스토어에서 직접 설치할 수도 있습니다.\n\n## Service Workers가 PWA와 통합되는 방법\n\n\n\nPWA의 많은 기능은 서비스 워커 덕분입니다. 서비스 워커는 PWA에서의 외부 요청을 위한 프록시 역할을 계속하며, 브라우저에 의해 활성화되어 사용자가 PWA와 상호 작용하지 않아도 백그라운드에서 실행될 수도 있습니다.\n\n서비스 워커의 양방향 통신과 프록시 기능의 존재는 다양한 유용한 기능을 제공합니다.\n\n- 브라우저를 통해 구독한 사용자에게 푸시 알림을 보내고, 이를 서비스 워커를 통해 클라이언트 장치에 표시할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_5.png)\n\n\n\n- 사용자가 응용 프로그램과 상호 작용하지 않을 때 배경에서 사이트 상태를 업데이트합니다. 예를 들어, 사용자가 응용 프로그램을 열 준비 중인 경우에 계산이 많이 필요한 엔드포인트를 호출하여 수분이 끊김없이 이루어지도록 합니다.\n- 연결 가능 상태가 되면 보낼 메시지를 저장합니다.\n- 연결이 실패할 때 표시할 정적 웹페이지의 캐시된 버전을 보관합니다.\n- 연결 상태에 따라 UI의 수분을 변경합니다. 예를 들어, 동적 전자 상거래 사이트를 구축 중이라면, 장바구니의 마지막 알려진 버전, 사용자의 기본 프로필 및 기타 쉽게 저장할 수 있는 정보를 표시합니다.\n\n이러한 예들은 PWA가 기본 웹 애플리케이션보다 신뢰성이 높고 성능이 우수한 것을 보여줍니다. 캐싱 API와 서비스 워커를 통해 제공되는 양방향 통신은 많은 개선을 제공하기 때문에 PWA가 왜 더 보급되지 않는지 궁금할 정도입니다...\n\n## 아니면 그렇지 않나요?\n\n이 기사를 통해 PWA에 대해 처음 들었거나 기기에 PWA가 하나도 설치되지 않았다면, 모든 브라우저에서 지원되지 않고 모든 기기에서 풀 네이티브 기능을 갖추고 있지 않기 때문일 것입니다 (Apple씨, 여기서 얘기하는 건 당신입니다). 이것은 새로운 개념이 아닙니다. 2007년에는 스티브 잡스가 처음으로 \"웹 2.0 앱\"을 대중화하고 첫 번째 iPhone을 출시하면서 네이티브 앱을 쉽게 지원하지 않았습니다. Forbes가 후에 그것을 그의 가장 큰 실수라고 표현하기도 했습니다. 그 당시 이러한 웹 애플리케이션은 Facebook 및 기타 회사에 의해 개발되었지만, 그들의 성능은 단순히 네이티브 앱과 비교할 수 없을 정도로 좋지 않았습니다. 이것은 대부분 현재 서비스 워커가 제공하는 능력 부족 때문이었습니다.\n\n\n\n![개발 중인 오프라인 준비 웹 애플리케이션](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_6.png)\n\n애플은 빠르게 방향을 바꿨어요. 오늘날, 그들이 애플 스토어에서 누적된 수익을 보호하기 위해 PWA에 대한 완전한 네이티브 지원을 제공하는 데 느리게 움직인 것으로 추정됩니다. 애플 제품을 사용해본 적이 있다면, 하나의 기기를 구입한 후 애플 제품이 바이러스처럼 자동으로 늘어난 것을 알 수 있을 거에요 — 헤드폰, 컴퓨터, 코드, 시계, 아쉽게도 앱까지. 제가 사용하는 것도 정말 그랬어요. 모두가 매끄럽게 함께 작동하기 때문에 더 편리하죠. 그러나 이에는 PWAs를 완전히 활용할 기회를 놓치는 것과 같은 단점이 따릅니다.\n\n애플과 사파리를 제외하고 파이어폭스도 PWAs에 대한 완전한 지원을 채택하는 데 더 느렸어요. 실제로 오늘날까지도 iOS에서 PWA에 대한 지원이 없습니다. 크로미엄 기반 브라우저는 다른 어떤 브라우저보다 빨리 PWA를 지원했어요. 이는 구글 엔지니어들이 2015년에 처음으로 'Progressive Web Application'이라는 용어를 만든 것이기 때문에 놀라운 일이 아니에요.\n\n지난 시간 동안 완전한 채택이 느리게 진행되어 왔지만, 상황이 빠르게 변화하고 있습니다. 올해 초 애플은 일부 기기에서 푸시 알림을 허용하기 시작했어요. 게다가 서비스 워커가 지속적으로 개선되고 새로운 기능들이 계속해서 제공되고 있어요.\n\n\n\n이것이 미래의 방향이 될 수 있을까요? 결국, 네이티브 응용 프로그램을 웹사이트와 연결할 때 전용 프로그래밍 언어와 생태계를 왜 굳이 사용해야 할까요? 기본 웹 도구를 사용하고 사용자에게 향상된, 거의 네이티브 경험을 제공할 수 있기 때문에요. 단점과 위험도 있고, 네이티브 앱은 여러 면에서 우위를 지니고 있지만요. 그러나 웹 기술과 속도가 계속 발전함에 따라, 근시일안에 많은 프로그레시브 웹 앱을 더 많이 보게 될 것이라 예상합니다.\n\n# Stackademic\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 박수를 보내주시고 저자를 팔로우해주시길 바랍니다! 👏\n- 트위터(X), 링크드인, 유튜브에서 팔로우해주세요.\n- Stackademic.com 방문하여 전 세계에서 무료 프로그래밍 교육을 민주화하는 방법에 대해 더 많은 정보를 얻으세요.","ogImage":{"url":"/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png"},"coverImage":"/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png","tag":["Tech"],"readingTime":7},{"title":"자바스크립트에서 간단한 반환과 프로미스 반환의 차이","description":"","date":"2024-05-14 12:53","slug":"2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS","content":"\n\n자바스크립트에서 단순 반환과 프로미스 반환은 서로 다른 목적을 가지고 있어요.\n\n## 단순 반환:\n\n함수에서 값을 직접 반환할 때, 이는 동기 작업입니다. 함수가 실행되고 결과를 즉시 반환해요.\n\n![이미지](/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png)\n\n\n\n## 아래는 코드 분석입니다:\n\n1. 함수 정의: 두 개의 매개변수 a와 b를 받는 add라는 함수를 정의합니다.\n\n2. 반환문: add 함수 내에서 a와 b의 합을 반환하는 return a + b;를 사용합니다.\n\n3. 함수 호출: 그런 다음 매개변수 10과 20을 사용하여 add 함수를 호출합니다.\n\n\n\n4. 결과 저장: 반환된 값(10과 20의 합인 30)이 result 변수에 저장됩니다.\n\n5. 출력: 마지막으로, 우리는 결과값 30을 콘솔에 출력합니다.\n\n단순하고 동기적입니다. 함수는 값을 즉시 반환합니다.\n\n# Promise Return:\n\n\n\nPromise는 비동기 작업에 사용됩니다. 지금이나 미래에 사용할 수 있는 값이나 결코 사용할 수 없는 값을 나타냅니다. 함수가 Promise를 반환하면 비동기 작업을 수행하고 그 작업의 결과에 따라 Promise를 해결하거나 거부할 수 있습니다.\n\n![Promise Image](/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_1.png)\n\n이 코드에서:\n\n- reject()에 new Error(\"Strings are not equal\")를 인수로 추가하여 오류에 대한 자세한 정보를 제공했습니다.\n- catch 블록에서 (error)를 콜백 함수의 인수로 추가하여 오류 객체를 캐치하고 해당 메시지를 기록했습니다.\n\n\n\n이제 코드가 오류 없이 실행되고 적절한 출력을 제공해야 합니다. str1과 str2가 동일한 경우 \"Success message. Both names are equal.\"을 출력합니다. 그 외에는 \"Error: Strings are not equal\"을 출력합니다.\n\n## 차이점:\n\n실행 컨텍스트:\n\n- 간단한 반환: 동기적으로 실행됨.\n- Promise 반환: 비동기 실행을 허용함.\n\n\n\n비동기 작업 다루기:\n\n- Simple return: 비동기 작업을 처리할 수 없습니다.\n- Promise return: 특별히 비동기 작업을 처리하기 위해 설계되었습니다.\n\n사용 방법:\n\n- Simple return: 동기 작업에 사용됩니다.\n- Promise return: 비동기 작업에 사용됩니다.","ogImage":{"url":"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png"},"coverImage":"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png","tag":["Tech"],"readingTime":2},{"title":"부적합한 프로그래머일지도 모르는 5가지 신호","description":"","date":"2024-05-14 12:51","slug":"2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer","content":"\n\n## 프로그래밍 의견\n\n![프로그래밍](/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png)\n\n아무도 완벽하지 않으며 아래 목록 중 하나 또는 두 개의 항목이 모두 해당될 것입니다. 그러나 그 중 세 가지 이상이 해당된다면, 스스로를 비판하거나 다른 일을 찾아보는 것이 좋을 수도 있습니다.\n\n프로그래밍은 오랜 시간 약한 조건과 많은 스트레스 아래에서 가끔 열심히 할 필요가 있으므로 그것을 즐기지 않는다면 의미가 없습니다. 거기에 이르기까지의 교육 과정은 김이며, 실제로 좋아지려면 십 년의 경험이 필요합니다. 처음부터 그런 감정이 느껴지지 않는다면, 다른 것을 찾아보는 것이 좋은 이유가 될 수 있습니다.\n\n\n\n우리는 더 많은 우수한 프로그래머가 필요해요. 프로그래밍은 인지적 프로세스를 자동화하며, 이러한 합리화는 현재 세상에서 진보의 주요 원동력이자 번영의 주된 요인이에요. 제 시선에서 모든 프로그래머는 우리의 존경을 받을 만한 영웅이에요.\n\n당신이 하는 일에 대한 오피서, 신사, 데이터 전사가 되어주세요.\n\n프로그래밍은 일자리가 아니에요. 이는 일종의 사명이에요. 빠르게 돈을 벌 수 있는 다른 방법이 있지만, 프로그래밍은 오늘날 일의 가장 높은 가치 중 하나로 사회에 봉사하는 것이기도 해요.\n\n그러니 당신이 프로그래머라 자부심을 갖지만 오만해지지 마세요. 당신은 사회의 종복이며, 기계가 읽을 수 있는 책을 쓰고, 스크롤을 통해 작동되는 로프의 골렘을 프로그래밍하는 현대적 수도사이기도 해요.\n\n\n\n당신이 되어야 하는 사이버 수도승은 겸손과 자발성, 자신의 한계를 이해하는 것뿐만 아니라 프로그래밍보다는 예술과 철학, 윤리와 정치를 필요로 합니다. 또한 개인으로서와 창조적인 힘으로서 사회에서의 역할에 대한 인식도 필요합니다.\n\n이것과 자아가 충돌하지 않을 수도 있습니다. 자아는 자신의 가치를 알아야 하며, 당신의 의견에서 벗어나는 것에 확신을 가져야 합니다. 하지만 납득할 수 있고 생각을 바꿀 수 있는 능력 또한 이 중요합니다. 당신이 소왈되지 않은 자아를 가지고 있을 때만 이 위대함을 얻을 수 있습니다.\n\n만약 이 이상적인 것을 달성한다면, 당신은 좋은 프로그래머입니다. 목표는 이를 달성하기 위한 길입니다.\n\n그래서 여기 목록입니다:\n\n\n\n- 프로그래밍을 즐기지 않아요.\n- 참고 자료, 라이브러리 및 설명서를 읽지 않고, 그냥 주물러버려요.\n- 자기를 돌아보지 않고, 자신이나 자신의 프로그램, 사용 가능한 도구에 대해 자기비판이 없어요.\n- 듣는 모든 말을 믿어요. 스스로 생각하지 않고 해결책을 찾지 않아요.\n- \"그렇다고?\" 라는 질문을 하지 않아요. 과학적인 작업을 하지 않아요.\n- 자신의 프로그램을 오류로 테스트해보지 않아요.\n- 해결하려는 것이 이미 존재하는지 확인하려고 하지 않아요.\n- 기능의 작은 부분만 사용하려 할 때도 프레임워크를 사용해요.\n- 유행과 이데올로기에 영향을 받아요 - \"이달의 패러다임\".\n- 다른 사람의 코드를 테스트하지 않고 신뢰해요.\n- 필요하지 않은 자원인 CPU 및 처리 시간을 낭비해요.\n- 문제에 합리적인 알고리즘을 찾지 않아요.\n- 시스템의 하드웨어를 무시하고, 다른 방법으로 쉽게 할 수 있는 것도 있음에도 특히 취약한 작업을 해요.\n- 어떤 컴퓨터 아키텍처에서 작업하는지에 대한 이해가 없으며, 자부심을 갖고 있어요 (\"HLL 무지\").\n- 문제 해결에 집중하는 대신 힙 이데올로기를 사용해요 (\"OOP Mad Cow Disease\").\n- 형태의 중요성을 높이는 태도\n- 시스템을 이해하지 못하고 스스로 시스템 기능을 구현하려 하면 대개 실패합니다.\n- \"최적화\"를 무시해요.\n- 어셈블리에 관심을 둬요.\n- 디버거를 사용하는 방법을 모르겠어요.\n- 프로그램을 역공학적으로 분석해본 적이 없고, 그에 대한 호기심이 없어요.\n- 그냥 그 때 표준으로 인해 일을 하지만 그것에 대해 비판적으로 생각하거나 다른 사람과 의견을 교환하지 않아요. 요약하자면, 반성이 부족해요.\n- 자신의 도구의 한계 및 사용된 언어, 알고리즘, 시스템의 강점과 약점에 대한 지식이 전혀 없어요.\n- 목적지에 빨리 도착한다고 생각해서 항상 최적의 경로를 선택해요.\n- 세심하고 철저하게 일하지 않고, 어질어질하게 일해요.\n- 새로운 사람들이나 유지보수 담당자 앞에서 오만하게 행동하며 도우려 하지 않아요. 의자를 통해서 음해하고 협조적이지 않은 경력의 사고방식도 포함돼요. 안타깝게도 일반적이에요. 하지만 그렇게 일할 수 없어요. 누구든 그런 사람과 일할 수 없어요.\n- 일을 마음대로 처리하지 않고, 의도적으로 암호화된 코드로 직업을 안전하게 만들어요. 만약 필요하거나 아프다면 더 나은 사람으로 대체할 기회나 자리를 주지 않습니다. 이를 간단히 아 불효한 행동이라고 부릅니다. 질질짜는 질질짜기 대신에 실질적인 안전이 품질을 통해 실현돼요.\n- 일을 속이고, 자립적으로 결점을 드러내거나 인정하지 않아요. 스스로에게 대안을 제시하지 않아요.\n- 엔지니어로서의 자질이 당신에게 말하지만, 관리부와의 대면에서 등을 빼지 못할 때가 있어요. 이것은 종종 프로젝트의 파괴적 결과나 더 나쁜 일로 이어지곤 해요. 챌린저의 엔지니어들은 발사를 거부해야 했어요. 그 추운 날, 그들의 거부로 인해 일곱 명이 불필요하게 사망하게 됐어요. 나쁜 프로그래머들은 용기가 없고 직장에 대한 두려움이 있어요.\n- 경우에 따라 결론을 내릴 대신, 자격 없는 사람들이 무엇을 해야 하는지 지시하는 것을 허용해요. 프로그래머와 엔지니어로서, 살아가야 하는 엄청난 책임이 있어요. 혹은 그 분야에 위치할 자격이 없는 경우도 있어요.\n- 저지른 실수를 인정하지 않고, 오히려 숨기고 감추려 해요. (BOfH 현상)\n- 교육을 이어가지 않고, 새로운 것을 배우거나 시도할 의지가 없어요. 또한 능동적인 태도를 나타내지 않아요. 상투적인 길을 시도해보지 않아요.\n- 두려움.\n\n위 목록에 속하지 않는 것은 여러분의 프로그램 중 하나에 오류가 있다는 것이 아니에요. 모든 프로그램에는 오류가 있어요. 또한 예상보다 더 오랜 시간이 걸리는 것 역시 정상적이에요.\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n\n\n- 작가에게 박수를 보내 주시고 팔로우도 부탁드립니다! 👏\n- 팔로우하기 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png"},"coverImage":"/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 GraphQL 대 REST API 포괄적 가이드","description":"","date":"2024-05-14 12:50","slug":"2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide","content":"\n\n\n![그래픽](/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png)\n\nGraphQL 또는 REST API를 React 기반 애플리케이션에 사용할지 결정하는 것은 매우 중요합니다. 이 결정은 앱의 성능, 확장 가능성, 데이터 처리 효율성 및 개발 수명주기에 도입되는 복잡성 수준에 심각한 영향을 미칩니다. 이 포괄적인 가이드는 두 가지의 차이점을 명확히하고 정보를 얻을 수 있는 선택을 도와줄 것으로 기대됩니다!\n\n# REST API란 무엇인가요?\n\nREST (Representational State Transfer)는 웹 개발에 사용되는 아키텍처 스타일로, 클라이언트-서버 접근 방식을 사용합니다. 서버는 클라이언트가 요청한 리소스의 표현을 제공합니다. 리소스는 URL로 식별되며 이러한 리소스는 POST, GET, PUT, DELETE와 같은 HTTP 방식으로 표시되는 CRUD 작업을 사용하여 조작할 수 있습니다. 최근 몇 년간 REST API의 활용이 많이 증가했습니다.\n\n\n\n\n```js\n// REST API를 사용하여 데이터 가져오기\nfetch(\"https://api.example.com/items\") \n  .then(res => res.json())\n  .then(data => console.log(data));\n```\n\n위 예시에서는 REST API 엔드포인트 /items에 대한 호출이 해당 항목들을 JSON 형식으로 반환합니다.\n\n# GraphQL이란?\n\n2015년 Facebook에서 개발된 GraphQL은 REST API에 대안으로 효율적이고 선언적이며 유연한 데이터 쿼리 언어입니다. 이를 통해 클라이언트는 서버에서 어떤 데이터가 필요한지 정확히 지정하고 원하는 방식으로 가져올 수 있어, REST API와 관련된 오버-패칭 또는 언더-패칭 문제를 제거합니다.\n\n\n\n```js\n// GraphQL을 사용하여 데이터를 가져옵니다\nfetch('/graphql', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    query: `{ \n      items { \n        id, \n        name \n      } \n    }`\n  })\n})\n.then(res => res.json())\n.then(data => console.log(data.data));\n```\n\n위의 예제에서 요청의 query 속성은 GraphQL 서버에서 각 항목의 id와 이름을 가져옵니다.\n\n# GraphQL과 REST API의 차이\n\n## 1. 데이터 가져오기\n\n\n\nREST API\n\nREST 기반 아키텍처에서는 귀하의 앱이 관련 데이터를 가져 오기 위해 다양한 엔드포인트로 여러 요청을 해야합니다.\n\n```js\nfetch(\"https://api.example.com/users/1\") // ID가 1인 사용자 가져 오기\n.then(/* */)\n\nfetch(\"https://api.example.com/users/1/posts\") // ID가 1인 사용자의 게시물 가져 오기\n.then(/* */)\n```\n\n위의 예시처럼 특정 사용자가 만든 데이터(게시물)를 가져 오는 것은 REST API에서 여러 네트워크 요청이 필요합니다.\n\n\n\nGraphQL\n\nGraphQL을 사용하면 관련 데이터를 하나의 요청으로 모아 가져올 수 있으며, 정확히 필요한 데이터만 가져와서 과다 또는 미비한 데이터 문제를 줄일 수 있어요.\n\n```js\nfetch('/graphql', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    query: `{\n      user(id: 1) {\n        name,\n        posts {\n          title,\n          body\n        }\n      }\n    }`\n  })\n})\n.then(/* */)\n```\n\n위 코드는 한 요청으로 사용자와 해당 사용자의 게시물을 가져오는 거에요.\n\n\n\n## 2. Over-fetching and Under-fetching\n\nREST API\n\nRESTful 서비스에서 응답의 모양과 크기는 서버에 의해 결정됩니다. 종종 endpoint가 충분한 정보를 제공하지 않아 추가 요청이 필요한 under-fetching이 발생하거나, 필요 이상의 정보가 전송되어 over-fetching이 발생할 수 있습니다.\n\nGraphQL\n\n\n\nGraphQL의 주요 이점 중 하나는 클라이언트가 필요한 데이터를 정확히 지정하여 over-fetching 또는 under-fetching을 피할 수 있다는 것입니다. 서버는 요청의 형태를 따르는 응답을 반환합니다.\n\n## 3. 버전 관리\n\nREST API\n\n버전 관리는 REST 기반 서비스에서 일반적입니다. 이는 API를 발전시키는 것이 어려워 새로운 API 버전이 처리할 필요가 있는 파괴적인 변경을 피하기 위함입니다.\n\n\n\nGraphQL\n\nGraphQL을 사용하면 서버는 자신의 기능을 공개하고 클라이언트는 필요한 요청을 구성하며, 이로 인해 버전 관리가 필요 없어집니다.\n\n## REST API와 GraphQL을 언제 사용해야 할까요?\n\nREST API를 사용해야 하는 경우:\n\n\n\n- 당신의 앱이 간단하거나 데이터 요구 사항이 복잡하지 않다면 REST API 설계에 더 익숙한 팀이 있다면 REST를 사용하세요.\n- 데이터가 자주 변경되지 않고 중첩된 엔티티를 포함하지 않는다면 REST를 사용하세요.\n\nGraphQL을 사용해야 하는 경우:\n\n- 애플리케이션이 중첩된 엔티티를 포함하거나 그들 사이에 복잡한 관계가 있는 경우.\n- 네트워크를 통해 로드되는 데이터를 줄이고 싶은 경우.\n- 앱이 애플리케이션 부하 및 코드베이스 크기 측면에서 확장될 것으로 예상되는 경우.\n\n마지막으로, GraphQL과 REST 중 어느 것을 선택할지는 프로젝트 요구 사항, 팀의 기술 수준, 데이터의 성격 등 여러 가지 요인에 달려 있습니다. 두 가지 방식에는 각각의 장점이 있으며 상황에 따라 어느 쪽이든 완벽하게 어울릴 수 있습니다. 이러한 주요 차이를 이해하면 프로젝트 성공에 중요한 결정을 내릴 수 있게 될 것입니다.\n\n\n\n# 만약 즐거우셨다면 박수와 구독을 잊지 마세요! 👏\n\n열정적인 건축가들의 디스코드 커뮤니티에 가입해보세요: [https://discord.gg/QyXEsb4C](https://discord.gg/QyXEsb4C)","ogImage":{"url":"/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기","description":"","date":"2024-05-14 12:49","slug":"2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues","content":"\n\n\n<img src=\"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png\" />\n\nJavaScript 코드 실행 방식에 대해 궁금했던 적이 있나요? 웹 브라우저 내에서 JavaScript 코드 실행은 단일 스레드로 이루어지며 비동기 작업들이 어떻게 조율되는지 흥미로운 여정을 안내합니다.\n\nJavaScript는 단일 스레드 내에서 작동합니다. 이는 한 번에 한 가지 작업만 수행할 수 있다는 것을 의미합니다. 그러나 재미있는 점은, 이 제약에도 불구하고 JavaScript가 네트워크 요청이나 setTimeout() 함수 호출과 같은 비동기 작업을 원할하게 다룰 수 있고 사용자 인터페이스가 멈추지 않는다는 것입니다.\n\n그렇다면, JavaScript는 이를 어떻게 성취할까요?\n\n\n\n\n자바스크립트는 사용자 인터페이스가 반응성을 유지하는 동안 비동기 작업을 관리하기 위한 병렬처리 방식을 채용합니다. setTimeout()을 사용하여 네트워크 요청 또는 타임아웃과 같은 비동기 작업을 시작할 때, 자바스크립트는 이러한 작업이 완료될 때까지 기다리지 않습니다. 대신에 브라우저의 비동기 작업 처리를 담당하는 기본 메커니즘으로 위임합니다.\n\n이제 깊게 들어가 봅시다.\n\n자바스크립트 병렬처리 모델의 핵심은 이벤트 루프입니다. 이벤트 루프는 작업의 실행을 감독합니다. 이벤트 루프는 실행 스택과 작업 대기열(작업/콜백 및 마이크로 작업 대기열)을 지속적으로 모니터링하여 올바른 순서로 작업이 실행되고 주 스레드가 차단되지 않도록 합니다.\n\n작업 대기열은 비동기 이벤트에 응답하여 실행되도록 예약된 작업을 보관하는 곳입니다. 예를 들어 사용자가 버튼을 클릭하거나 setTimeout()으로 설정된 타이머가 만료될 때, 자바스크립트는 관련 작업을 작업 대기열에 추가합니다. 자바스크립트 병렬처리 모델의 중심 요소인 이벤트 루프는 실행 스택과 작업 대기열을 지속적으로 모니터링합니다. 실행 스택이 비어 있고 작업 대기열에 작업이 있는 경우, 이벤트 루프는 다음 작업을 선택하여 실행하고 해당 콜백 함수를 호출합니다. 이 과정은 계속 반복되며, 작업이 콜백 대기열에 추가되어 큐에 정렬된 순서대로 실행됩니다.\n\n\n\n자바스크립트는 작업 대기열 외에도 고우선 순위 작업을 처리하기 위한 마이크로태스크 대기열을 유지합니다. 마이크로태스크는 일반적으로 사용자 인터페이스를 업데이트하는 시간이 중요한 작업과 같은 작업에 사용됩니다. 마이크로태스크가 생성되면 마이크로태스크 대기열에 넣어집니다. 작업 대기열의 작업과 달리 마이크로태스크는 현재 실행 컨텍스트(예: 현재 함수)가 완료된 후 즉시 실행되며, 그 후에 제어가 이벤트 루프로 돌아갑니다. 이벤트 루프는 마이크로태스크를 작업 대기열의 작업보다 우선 처리하여 신속하게 처리합니다. 마이크로태스크 대기열의 모든 마이크로태스크가 실행된 후, 이벤트 루프는 나머지 작업을 처리하기 위해 작업 대기열로 돌아가며 동기적 및 비동기적 작업 사이의 균형을 유지합니다.","ogImage":{"url":"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png"},"coverImage":"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png","tag":["Tech"],"readingTime":2},{"title":"라이프사이클 후크Lifecycle Hooks에 대한 LWC","description":"","date":"2024-05-14 12:48","slug":"2024-05-14-LifecycleHooksinLWC","content":"\n\n\n![Lifecycle Hooks in LWC](/assets/img/2024-05-14-LifecycleHooksinLWC_0.png)\n\n라이프사이클 훅은 라이트닝 웹 컴포넌트(LWC)를 개발하는 여정에서 굉장히 중요한 부분입니다. 이들은 컴포넌트의 라이프사이클의 다양한 단계를 제어하고 응답하는 능력을 제공하여 Salesforce 생태계에서 웹 컴포넌트를 구축하는데 더 효율적이고 세밀한 접근법을 가능하게 합니다.\n\n이 블로그에서는 LWC 라이프사이클 훅의 세계에 대해 자세히 살펴보겠습니다. 이 훅이 무엇이고 왜 중요한지, 그리고 동적이고 반응성 있는 컴포넌트를 만들기 위해 효과적으로 활용하는 방법에 대해 탐구할 것입니다. LWC 여정을 시작한 지 얼마 안 된 분들이거나 기술을 향상하려는 분들, 이러한 훅을 이해하는 것이 강력하고 효율적인 라이트닝 웹 컴포넌트를 만드는 데 중요합니다.\n\n이 블로그를 통해 LWC에서 사용 가능한 다양한 라이프사이클 훅을 자세히 살펴보고, 이들의 구체적인 사용 사례를 논의하며, 실용적인 예제를 제공하여 실제 응용 가능한 내용을 파악하는 데 도움을 드리겠습니다. 이 여정의 끝에는 컴포넌트 라이프사이클 관리의 기술을 숙달하여 LWC의 전체 잠재력을 활용할 수 있는 지식을 갖추게 될 것입니다.\n\n\n\nLifecycle Hooks in LWC: Managing the Journey of a Lightning Web Component\n\n라이트닝 웹 컴포넌트(LWC)의 라이프사이클 훅\n\n라이트닝 웹 컴포넌트(LWC)는 Salesforce 플랫폼 내에서 동적이고 인터랙티브한 사용자 인터페이스의 구성 요소입니다. 그들의 잠재력을 완벽하게 활용하려면, 개발자들은 이러한 구성 요소들이 라이프사이클 동안 거치는 복잡한 단계를 이해해야 합니다. 이것이 바로 \"라이프사이클 훅(Lifecycle Hooks)\"의 세계입니다.\n\n# 라이프사이클 훅이란?\n\nLWC의 라이프사이클 훅은 개발자들이 컴포넌트의 여정의 다른 단계에서 개입할 수 있는 미리 정의된 메소드들입니다. 이러한 훅들은 컴포넌트의 라이프사이클에서 발생하는 특정 이벤트와 전환에 대응하고 제어하고 최적화할 수 있는 능력을 제공합니다. 이러한 훅들을 이해하고 효과적으로 사용하는 것이 견고하고 반응적인 컴포넌트를 만드는 핵심입니다.\n\n\n\n여기 몇 가지 중요한 라이프사이클 후크에 대한 간단한 개요입니다:\n\n- constructor(): 컴포넌트가 초기화되는 곳입니다. 기본값을 설정하고 일회성 설정을 수행할 수 있습니다.\n- connectedCallback(): 컴포넌트가 DOM에 추가된 후에 실행되는 후크입니다. DOM 조작 및 데이터 검색에 좋은 장소입니다.\n- renderedCallback(): 렌더링 후에 트리거되는 후크입니다. 렌더링된 DOM에 대한 지식이 필요한 작업에 이상적입니다.\n- disconnectedCallback(): 컴포넌트가 DOM에서 제거될 때 호출되는 후크입니다. 정리 작업 및 리소스 해제에 사용하세요.\n- errorCallback(): 렌더링 중에 오류가 발생하면 호출되는 후크입니다. 오류를 우아하게 처리할 기회입니다.\n\n# 라이프사이클 후크 흐름\n\n먼저 부모 constructor가 호출되고, 부모 connectedCallBack가 실행된 후, 자식 컴포넌트가 있으면 자식 constructor → connectedCallback → renderedCallback 순으로 진행되고 다시 부모 renderedCallback로 이동합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-LifecycleHooksinLWC_1.png)\n\n1. 생성:\n\n- `constructor()`: 컴포넌트 인스턴스가 생성될 때 실행되는 첫 번째 후크입니다. 변수를 초기화하고 기본 값 설정하는 곳입니다.\n\n주의하세요!\n\n\n\n생성자()\n\n- 컴포넌트의 인스턴스가 생성될 때 호출됩니다(init()와 비슷합니다).\n- 부모 컴포넌트에서 먼저 발생하며 부모에서 자식으로 흘러갑니다.\n- 부모 클래스 생성자인 LightningElement를 호출하려면 먼저 super()를 호출해야 합니다.\n- 컴포넌트 템플릿에서 요소에 액세스하려면 this.template을 사용하세요.\n\n```js\nimport { LightningElement } from 'lwc';\n \nexport default class LifeCycleHookParent extends LightningElement {\n  constructor() {\n    super(); // LightningElement 클래스 생성자를 호출합니다. console.log('Parent Constructor Called');\n    let con = this.template // 호스트 요소에 액세스합니다.\n    console.log(con);\n  }\n}\n```\n\n2. 초기화:\n\n\n\n- `connectedCallback()`: 컴포넌트가 초기화된 후에 이 훅이 호출됩니다. DOM 조작 및 데이터 검색에 이상적인 위치입니다.\n\n주의!\n\nconnectedCallback()\n\n- 컴포넌트가 DOM에 삽입될 때 호출됩니다.\n- 부모에서 자식으로 흐릅니다.\n- 데이터를 가져오고 캐시를 설정하며 이벤트를 수신하는 초기화 작업을 수행하는 데 사용됩니다.\n- 컴포넌트가 DOM에 연결되어 있는지 확인하려면 isConnected 메서드를 사용하세요.\n\n\n\n```js\nconnectedCallback(){\n  console.log('Parent Connected Call Back called');\n  let cb = this.template\n  console.log('is connected=> ' + cb.isConnected);\n}\n```\n\n3. 렌더링:\n\n- `renderedCallback()`: 이 훅은 컴포넌트의 초기 렌더링 후에 트리거됩니다. 요소와 상호 작용하는 것과 같은 렌더링된 DOM에 대한 지식이 필요한 작업에 적합합니다.\n\n주의하세요!\n\n\n\n\nrenderedCallback()\n\n- 컴포넌트가 렌더링 프레임워크를 완료한 후에 로직을 수행할 때 사용합니다. 이는 컴포넌트가 UI에 완전히 렌더링된 후에 호출됩니다.\n- 자식 컴포넌트에서 부모 컴포넌트로 흐름이 됩니다.\n- 컴포넌트는 여러 번 렌더링되어 렌더링 콜백을 추적하려면 isRendered 불리언 필드를 사용하세요.\n- 렌더링된 콜백 내에서 무한 루프로 이어지는 속성을 조심하세요.\n\n```js\nimport { LightningElement } from 'lwc';\nexport default class LifeCycleHookParent extends LightningElement {\n  isRendered = true // 컴포넌트가 렌더링되었는지 확인하기 위한 변수\n  renderedCallback() {\n    if (this.isRendered) {\n      console.log('부모 컴포넌트의 렌더링 콜백이 호출되었습니다');\n      this.isRendered = false\n    }\n  ?\n }\n```\n\n4. Reactivity:\n\n\n\n- 컴포넌트 내의 속성 또는 변수가 변경될 때마다 반응성 주기가 트리거될 수 있습니다. 이 주기 중에는 컴포넌트가 속성 변화를 확인하며, 변화가 감지되면 다시 렌더링되고 `renderedCallback`을 다시 호출합니다.\n\n5. 소멸:\n\n- `disconnectedCallback()`: 컴포넌트가 DOM에서 제거될 때 이 후크가 호출됩니다. 정리 작업이나 이벤트 리스너와 같은 리소스 해제에 뛰어난 장소입니다.\n\n주의하세요!\n\n\n\n\ndisconnectedCallback()\n\n- 문서에서 요소가 제거될 때 호출됩니다 (이벤트 리스너 제거, 시간 간격 제거 등).\n- Parent에서 Child로 이어집니다.\n- connectedCallback()에서 수행한 작업 정리에 disconnectedCallback()을 사용하십시오. 예를 들어, 이벤트 리스너 제거 등.\n- 메시지 채널 구독 취소 등에도 이 후크를 사용할 수 있습니다.\n\n6. 오류 처리:\n\n- `errorCallback()`: 렌더링 중 오류가 발생하면 이 후크가 호출됩니다. 오류를 우아하게 처리하고 적절한 메시지를 표시할 수 있는 기회를 제공합니다.\n\n\n\n\n알아두세요!\n\nerrorCallback()\n\n이것을 구현하여 하위 컴포넌트의 모든 오류를 캡처하는 오류 경계 컴포넌트를 만드세요.\n\n하위 컴포넌트의 라이프사이클 훅 또는 HTML 템플릿에서 선언된 이벤트 핸들러 중 발생한 오류를 캡처합니다.\n\n\n\n- 자식(하위) 컴포넌트에서 오류가 발생했을 때 호출됩니다.\n- errorCallback(error, stack) 함수에 두 가지 아규먼트가 전달됩니다. error 아규먼트는 JavaScript 네이티브 오류 객체이며, stack 아규먼트는 문자열입니다.\n\n```js\n//Child Component\nconnectedCallback(){\n  console.log('Child Connected Call Back called');\n  throw new Error('problem in child component connectedCallback')\n  }\n```\n\n```js\n//Parent component\nerrorCallback(error, stack){\n  console.log(error 메시지);\n  console.log('Stack: - ' + stack);\n}\n```\n\n이 플로우를 이해하고 각 후크의 사용법을 파악하는 것은 Salesforce 생태계에서 반응형, 효율적이고 인터랙티브 웹 컴포넌트를 효과적으로 관리하고 최적화하는 데 중요합니다.\n\n\n\n# 라이프사이클 훅이 왜 중요한가요?\n\n라이프사이클 훅은 여러 이점을 제공합니다:\n\n- 최적화: 적절한 시간에 개입하여 컴포넌트 렌더링을 최적화함으로써 성능과 응답성을 향상시킬 수 있습니다.\n- 상호작용: 적절한 라이프사이클 단계에서 사용자 작업에 응답함으로써 상호작용형 컴포넌트를 만들 수 있습니다.\n- 자원 관리: 라이프사이클 훅을 사용하여 효율적인 자원 관리가 가능해지며, 컴포넌트가 더 이상 필요하지 않을 때 이벤트 리스너를 해제하고 타이머를 정리할 수 있습니다.\n\n예시: 실용적인 사용 사례\n\n\n\n간단한 예제로 라이프사이클 훅의 중요성을 설명해보겠습니다. 카운트다운 타이머 컴포넌트를 구축 중이라고 상상해보세요. 라이프사이클 훅을 사용하는 방법은 다음과 같습니다:\n\n```js\nexport default class CountdownTimer extends LightningElement {\n    seconds = 10;\n\n    connectedCallback() {\n        this.timer = setInterval(() => {\n            if (this.seconds > 0) {\n                this.seconds--;\n            }\n        }, 1000);\n    }\n\n    renderedCallback() {\n        if (this.seconds === 0) {\n            clearInterval(this.timer);\n        }\n    }\n\n    disconnectedCallback() {\n        clearInterval(this.timer);\n    }\n}\n```\n\n이 예시에서 `connectedCallback`은 타이머를 설정하고, `renderedCallback`은 타이머가 0에 도달했을 때 UI를 업데이트하며, `disconnectedCallback`은 컴포넌트가 제거될 때 타이머가 중지되도록 보장합니다.\n\n자세한 내용은 아래 링크를 참조해주세요:\n\n\n\n읽어 주셔서 감사합니다 ☺️","ogImage":{"url":"/assets/img/2024-05-14-LifecycleHooksinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-LifecycleHooksinLWC_0.png","tag":["Tech"],"readingTime":6}],"page":"108","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}