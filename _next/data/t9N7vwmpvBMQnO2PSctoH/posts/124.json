{"pageProps":{"posts":[{"title":"당신의 NextJs 프로젝트에 PayPal Checkout 통합하기","description":"","date":"2024-05-12 23:01","slug":"2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject","content":"\n\n## NEXT.JS 앱 라우터에 관한 기사\n\n![이미지](/assets/img/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject_0.png)\n\n참고: Next.Js 앱 라우터를 사용할 것입니다. 페이지 라우터가 아닙니다.\n\n간단한 전자상거래 스토어를 만드는 데 항상 고민했었습니다. 카트와 체크아웃이 제 머리를 얽히게 만들었는데, Stripe, PayPal 또는 심지어 Square를 웹사이트에 통합하려고 노력했기 때문입니다.\n\n\n\n하지만 전자 상거래 스토어에서의 고난이 그치지 않았습니다. 결제 통합 시에도 고난이 있었습니다. 그래서 웹사이트용 결제 포털을 만드는 일에 나는 압도되었습니다. \"이걸 어떻게 해야하지?\"라고 스스로 물었습니다.\n\nSquare는 웹사이트에 통합하기 가장 어려운 지불 프로세서입니다. 대면 거래에 더 적합합니다. 그럼에도 불구하고 Square로 설정을 해보았지만 전혀 실패했습니다.\n\n이어 Stripe로 넘어가 보겠습니다. 이것은 온라인 비즈니스에 좋은 옵션입니다. 그러나 고객 서비스와 관련된 다른 문제로 통합에 들어가기 전에 실패했습니다. 그래서 다른 것을 찾아봐야 했습니다.\n\n마지막으로 PayPal을 시도해 본 결과, 다른 온라인 비즈니스에서 성공을 들은 뒤, PayPal로 결제 포털을 만드는 데 성공했습니다. 이제 그 방법을 보여드릴 차례입니다. 그러니 함께 알아보겠습니다:\n\n\n\n# 시작하기\n\n![이미지](/assets/img/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject_1.png)\n\n알겠어요. 저는 뭔가 간단한 것을 이루고 싶었어요. 사용자가 지불할 금액을 선택하고 지불하도록 하고 싶었어요. 그건 충분히 간단한 목표죠.\n\n시작하려면 API 엔드포인트를 만드는 방법이 필요합니다. 우리는 App Router를 사용하기 때문에 API 엔드포인트에 대한 제 게시물을 확인해주세요.\n\n\n\n만약 당신이 이 글을 읽고 있고 Next.Js 프로젝트를 어떻게 생성하는지 모른다면 뭐하고 있는 거야!? 어쨌든, Next.Js 프로젝트를 만들려면 터미널에서 npx create-next-app@latest을 실행하면 됩니다.\n\n# 금액 구하는 중\n\n이어서, 지불 포털용 페이지를 생성하세요. 또한, 처음에 payment-form이라고 이름 지은 컴포넌트를 만드세요. 왜냐하면 금액 페이지를 체크아웃 페이지와 결합할 것이라고 생각했기 때문입니다. 그러나 결국 그렇게 하지 않았습니다.\n\n그리고 우리가 하는 동안, API 엔드포인트와 이를 위해 필요한 나머지 파일들도 만들어봅시다. 마지막에는 이렇게 된 것처럼 보일 거에요:\n\n\n\n```js\n프로젝트/\n│\n├──페이지/api/\n│   ├── get-token.ts\n|   ├── paypal-client-id.ts\n|   ├── paypal.ts\n└──src/app\n    ├──결제-포털/\n    │   ├── page.tsx\n    └── 결제-페이지/\n    │  ├── page.tsx\n    ├── 컴포넌트/\n    │   ├── payment-form.tsx\n    │   ├── paypal-buttons.tsx\n    ├── layout.tsx\n    ├── page.tsx\n```\n\n우리는 `payment-form.tsx` 파일 맨 위에 ‘use client’를 추가해서, 이 파일의 코드를 기본 서버 측이 아닌 클라이언트 측으로 만들 수 있습니다.\n\n또한, react에서 `useState` 훅과 axios, 그리고 next/navigation에서 `useRouter` 훅을 import 해보겠습니다:\n\n```js\n'use client';\nimport React, { useState } from 'react';\nimport axios from 'axios';\nimport { useRouter } from 'next/navigation';\n```\n\n\n\n이제 PaymentFormProps 인터페이스를 사용하여 PaymentForm 컴포넌트의 예상 프롭을 정의해 봅시다.\n\n```js\ninterface PaymentFormProps {\n  onSuccess: (orderId: string) => void;\n}\n```\n\n우리는 onSuccess를 프롭으로 받는 함수형 컴포넌트를 정의해야 합니다. 이를 PaymentForm이라고 부르겠습니다.\n\n```js\nconst PaymentForm: React.FC<PaymentFormProps> = ({ onSuccess }) => {\n\n}\n```\n\n\n이제, handlePaymentSubmit이란 이름의 함수를 만들어서 결제 양식 제출을 처리하는 함수를 만들겠습니다. 이 함수는 POST 요청을 사용하여 api/paypal로 결제 양식을 제출하려 합니다. 성공하면 Payment-Page로 이동합니다. 실패하면 오류 메시지를 표시합니다:\n\n```js\n  const handlePaymentSubmit = async () => {\n    try {\n      setLoading(true);\n      setError('');\n\n      const response = await axios.post('/api/paypal', { amount });\n\n      setLoading(false);\n\n      if (response.data.success) {\n        onSuccess(response.data.orderId);\n        router.push(`/Payment-Page?amount=${amount}`);\n      } else {\n        setError(response.data.error);\n      }\n    } catch (error) {\n      console.error('결제 초기화 오류:', error);\n      setLoading(false);\n      setError('결제 초기화 중 오류가 발생했습니다. 나중에 다시 시도해주세요.');\n    }\n  };\n```\n\n마지막으로, 입력 필드와 제출 버튼을 추가하겠습니다:\n\n```js\n  return (\n    <div className=\"flex flex-col gap-4 items-center\">\n      <label>\n        금액 입력:\n      </label>\n      <input type=\"number\" name=\"amount\" value={amount} onChange={handleAmountChange} className='text-black text-xl font-semibold p-2 rounded'/>\n      <button onClick={handlePaymentSubmit} disabled={loading} className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded m-2\">\n        {loading ? '처리 중...' : '결제 제출'}\n      </button>\n      {error && <p>오류: {error}</p>}\n    </div>\n  );\n```\n\n\n\n새로운 코드 아래에 `export default PaymentForm;`를 추가해주세요.\n\n최종 payment-form.tsx 코드는 다음과 같이 보여야 합니다:\n\n```js\n'use client';\nimport React, { useState } from 'react';\nimport axios from 'axios';\nimport { useRouter } from 'next/navigation';\n\ninterface PaymentFormProps {\n  onSuccess: (orderId: string) => void;\n}\n\nconst PaymentForm: React.FC<PaymentFormProps> = ({ onSuccess }) => {\n  const router = useRouter();\n  const [amount, setAmount] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n\n  const handleAmountChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setAmount(Number(event.target.value));\n  };\n\n  const handlePaymentSubmit = async () => {\n    try {\n      setLoading(true);\n      setError('');\n\n      const response = await axios.post('/api/paypal', { amount });\n\n      setLoading(false);\n\n      if (response.data.success) {\n        onSuccess(response.data.orderId);\n        router.push(`/Payment-Page?amount=${amount}`);\n      } else {\n        setError(response.data.error);\n      }\n    } catch (error) {\n      console.error('Error initiating payment:', error);\n      setLoading(false);\n      setError('An error occurred while initiating payment. Please try again later.');\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col gap-4 items-center\">\n      <label>\n        Enter Amount: \n      </label>\n      <input type=\"number\" name=\"amount\" value={amount} onChange={handleAmountChange} className='text-black text-xl font-semibold p-2 rounded'/>\n      <button onClick={handlePaymentSubmit} disabled={loading} className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded m-2\">\n        {loading ? 'Processing...' : 'Submit Payment'}\n      </button>\n      {error && <p>Error: {error}</p>}\n    </div>\n  );\n};\n\nexport default PaymentForm;\n```\n\n# 주문 생성하기\n\n\n\npaypal.ts 파일에 NextApiRequest와 NextApiResponse를 next에서, axios를 그리고 get-token.ts에서 getToken을 import해서 추가해봐요. getToken 코드는 나중에 보여줄게요.\n\n```js\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport axios from 'axios';\nimport getToken from './get-token ';\n```\n\n이제 API 엔드포인트를 만들어봅시다. 먼저 HTTP 메소드가 POST인지 확인한 후, 요청 본문에서 amount를 추출해요. 우리는 getToken 함수를 호출해서 액세스 토큰을 받을 거에요. PayPal에서 생성된 액세스 토큰은 .env 파일에 있어야 해요. 코드는 그런 다음 PayPal API로 POST 요청을 보낼 거에요:\n\n```js\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method === 'POST') {\n    try {\n      const { amount } = req.body;\n      const accessToken = await getToken();\n\n      const paypalResponse = await axios.post(\n        'https://api.paypal.com/v2/checkout/orders',\n        {\n          intent: 'CAPTURE',\n          purchase_units: [\n            {\n              amount: {\n                currency_code: 'USD',\n                value: amount.toString(),\n              },\n            },\n          ],\n        },\n        {\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${accessToken}`,\n          },\n        }\n      );\n\n      const { id: orderId } = paypalResponse.data;\n\n      res.status(200).json({ success: true, orderId });\n    } catch (error) {\n      console.error('PayPal API error:', error);\n      res.status(500).json({ success: false, error: 'Internal server error' });\n    }\n  } else {\n    res.status(405).json({ success: false, error: 'Method not allowed' });\n  }\n}\n```\n\n\n\n위의 코드를 한국어로 번역하면 다음과 같습니다:\n\n```js\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport axios from 'axios';\nimport getToken from './get-token';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method === 'POST') {\n    try {\n      const { amount } = req.body;\n      const accessToken = await getToken();\n\n      const paypalResponse = await axios.post(\n        'https://api.paypal.com/v2/checkout/orders',\n        {\n          intent: 'CAPTURE',\n          purchase_units: [\n            {\n              amount: {\n                currency_code: 'USD',\n                value: amount.toString(),\n              },\n            },\n          ],\n        },\n        {\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${accessToken}`,\n          },\n        }\n      );\n\n      const { id: orderId } = paypalResponse.data;\n\n      res.status(200).json({ success: true, orderId });\n    } catch (error) {\n      console.error('PayPal API 에러:', error);\n      res.status(500).json({ success: false, error: '내부 서버 오류' });\n    }\n  } else {\n    res.status(405).json({ success: false, error: '허용되지 않은 메소드' });\n  }\n}\n```\n\n# Access Token 가져오기\n\nget-token.ts 코드에 추가할 예정입니다.\n\n\n\naxios를 가져와봐요:\n\n```js\nimport axios from 'axios';\n```\n\n그리고 PAYPAL_CLIENT_ID 및 PAYPAL_CLIENT_SECRET를 환경 변수에서 가져와요:\n\n```js\nconst CLIENT_ID = process.env.PAYPAL_CLIENT_ID;\nconst CLIENT_SECRET = process.env.PAYPAL_CLIENT_SECRET;\n```\n\n\n\n그럼 우리는 PayPal API에서 액세스 토큰을 검색하는 getToken이라는 비동기 함수를 만들고 싶어요:\n\n```js\nconst getToken = async () => {\n  const credentials = Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64');\n\n  const response = await axios.post(\n    'https://api.paypal.com/v1/oauth2/token',\n    'grant_type=client_credentials',\n    {\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${credentials}`,\n      },\n    }\n  );\n\n  return response.data.access_token;\n};\n\nexport default getToken;\n```\n\n전체 코드는 다음과 같습니다:\n\n```js\nimport axios from 'axios';\n\nconst CLIENT_ID = process.env.PAYPAL_CLIENT_ID;\nconst CLIENT_SECRET = process.env.PAYPAL_CLIENT_SECRET;\n\nconst getToken = async () => {\n  const credentials = Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64');\n\n  const response = await axios.post(\n    'https://api.paypal.com/v1/oauth2/token',\n    'grant_type=client_credentials',\n    {\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${credentials}`,\n      },\n    }\n  );\n\n  return response.data.access_token;\n};\n\nexport default getToken;\n```\n\n\n\n# PayPal 버튼 만들기\n\nPayPal 버튼을 만들기 위해 paypal-buttons.tsx 파일을 서버 측이 아닌 클라이언트 측으로 변경해 보겠습니다. ‘use client’를 추가해 주세요. 그리고 여기서 react에서 useEffect 훅을 import해 주세요:\n\n```js\n'use client';\nimport React, { useEffect } from 'react';\n```\n\nTypeScript를 사용하기 때문에 전역 창에 속성을 추가하여 오류를 방지해 보겠습니다:\n\n\n\n```js\n전역을 선언합니다:\n   \ndeclare global {\n    interface Window {\n      paypal?: any;\n    }\n}\n\n이제 네 개의 속성 유형을 지정하는 객체를 인수로 취하는 함수형 컴포넌트를 정의해야 합니다:\n\nconst PayPalPaymentButton = ({ amount, paypalClientId, onSuccess, onError }: { amount: number; paypalClientId: string | null; onSuccess: () => void; onError: (err: any) => void; }) => {\n\n}\n\n함수형 컴포넌트인 PayPalPaymentButton 안에서 useEffect를 사용하여 컴포넌트가 마운트될 때 PayPal SDK 스크립트를 DOM에 추가하세요:\n\n\n\n  useEffect(() => {\n    const script = document.createElement('script');\n    script.src = `https://www.paypal.com/sdk/js?client-id=${paypalClientId}`;\n    script.async = true;\n    script.onload = () => {\n      initializePayPalButton();\n    };\n    document.body.appendChild(script);\n\n    return () => {\n      document.body.removeChild(script);\n    };\n  }, []);\n\n이제 웹페이지에 PayPal 버튼을 렌더링하는 함수를 만들어봅시다:\n\n  const initializePayPalButton = () => {\n    window.paypal.Buttons({\n      createOrder: function(data: any, actions: any) {\n        return actions.order.create({\n          purchase_units: [{\n            amount: {\n              value: amount,\n              currency_code: 'USD', // 원하는 통화로 변경\n            },   \n            application_context: {\n              user_action: 'PAY_NOW',\n              shipping_preference: 'NO_SHIPPING',\n              payment_method: { payee_preferred: 'IMMEDIATE_PAYMENT_REQUIRED' },\n              return_url: 'https://YOUR_WEBSITE_URL',\n              cancel_url: 'https://YOUR_WEBSITE_URL',\n            },\n          }],\n        });\n      },\n      onApprove: function(data:any, actions:any) {\n        return actions.order.capture().then(function(details: any) {\n          onSuccess();\n        });\n      },\n      onError: function(err: any) {\n        onError(err);\n      },\n    }).render('#paypal-button-container');\n  };\n\n이제 버튼을 표시하는 것만 남았습니다:\n```\n\n\n\n```js\nreturn <div id=\"paypal-button-container\" className='bg-gray-200'></div>;\n```\n\n최종 코드:\n\n```js\n'use client';\nimport React, { useEffect } from 'react';\n\ndeclare global {\n    interface Window {\n      paypal?: any;\n    }\n}\n\nconst PayPalPaymentButton = ({ amount, paypalClientId, onSuccess, onError }: { amount: number; paypalClientId: string | null; onSuccess: () => void; onError: (err: any) => void; }) => {\n  useEffect(() => {\n    const script = document.createElement('script');\n    script.src = `https://www.paypal.com/sdk/js?client-id=${paypalClientId}`;\n    script.async = true;\n    script.onload = () => {\n      initializePayPalButton();\n    };\n    document.body.appendChild(script);\n\n    return () => {\n      document.body.removeChild(script);\n    };\n  }, []);\n\n  const initializePayPalButton = () => {\n    window.paypal.Buttons({\n      createOrder: function(data: any, actions: any) {\n        return actions.order.create({\n          purchase_units: [{\n            amount: {\n              value: amount,\n              currency_code: 'USD',\n            },   \n            application_context: {\n              user_action: 'PAY_NOW',\n              shipping_preference: 'NO_SHIPPING',\n              payment_method: { payee_preferred: 'IMMEDIATE_PAYMENT_REQUIRED' },\n              return_url: 'https://YOUR_WEBSITE_URL',\n              cancel_url: 'https://YOUR_WEBSITE_URL',\n            },\n          }],\n        });\n      },\n      onApprove: function(data:any, actions:any) {\n        return actions.order.capture().then(function(details: any) {\n          onSuccess();\n        });\n      },\n      onError: function(err: any) {\n        onError(err);\n      },\n    }).render('#paypal-button-container');\n  };\n\n  return <div id=\"paypal-button-container\" className='bg-gray-200'></div>;\n};\n\nexport default PayPalPaymentButton;\n```\n\n# PayPal 클라이언트 ID 가져오기\n\n\n\n나중에 필요할 것이므로 지금 처리해 봐요. 당신의 paypal-client-id는 환경 변수 중에 PAYPAL_CLIENT_ID가 있는지 확인하고 그것을 클라이언트 쪽으로 보내요:\n\n```js\nimport { NextApiRequest, NextApiResponse } from 'next';\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  const paypalClientId = process.env.PAYPAL_CLIENT_ID;\n\n  if (!paypalClientId) {\n    return res.status(500).json({ error: 'PayPal client ID not found.' });\n  }\n\n  return res.status(200).json({ paypalClientId });\n}\n``` \n\n# Payment-Portal Page.tsx에 코드 추가하기\n\n\n\n```js\nimport PaymentComponent from \"../components/payment-form\";\n```\n\n결제 성공에 대한 함수를 정의하세요:\n\n```js\n  const handlePaymentSuccess = (orderId: string) => {\n    console.log('결제 성공! 주문 ID:', orderId);\n  };\n```\n\nPaymentComponent를 반환하세요:\n\n\n\n```jsx\n  return (\n    <main>\n      <div>\n        <PaymentComponent onSuccess={handlePaymentSuccess} />\n      </div>\n    </main>\n  );\n```\n\n# Payment-Page 페이지에 코드 추가하기\n\n파일의 맨 위에 'use client';를 추가해야 합니다. 그 다음으로 useEffect 훅, useState 훅, 그리고 Suspense를 react에서 임포트해주세요. 또한 next/navigation에서 useRouter와 useSearchParams를 임포트해주세요. 마지막으로 paypal-buttons.tsx에서 PayPalPaymentButtons를 임포트해주세요:\n\n```jsx\n'use client';\nimport React, { useEffect, useState, Suspense } from 'react';\nimport { useRouter, useSearchParams } from 'next/navigation';\nimport PayPalPaymentButtons from '../ui/PayPalButtons';\n```\n\n\n\n이제 paymentPage라는 기능 구성 요소를 만들 수 있습니다. 내부에서 useRouter 훅을 사용하여 router 객체에 액세스하는 코드를 추가하고 URL에서 검색 매개 변수를 가져 오는 것을 시도해 보겠습니다. 또한 상태 변수를 선언해 봅시다:\n\n```js\n  const router = useRouter();\n  const searchParams = useSearchParams();\n  const amount = searchParams ? searchParams.get('amount') : null;\n  const [paypalClientId, setPaypalClientId] = useState<string | null>(null);\n```\n\nuseEffect 훅을 사용하여 API 엔드 포인트 paypal-client-id.ts에서 PayPal 클라이언트 ID를 가져 오는 것을 시도해 보겠습니다:\n\n```js\n  useEffect(() => {\n    fetch('/api/paypal-client-id')\n      .then((response) => response.json())\n      .then((data) => {\n        if (data.paypalClientId) {\n          setPaypalClientId(data.paypalClientId);\n        } else {\n          console.error('PayPal 클라이언트 ID를 찾을 수 없습니다.');\n        }\n      })\n      .catch((error) => {\n        console.error('PayPal 클라이언트 ID를 가져 오지 못했습니다:', error);\n      });\n  }, []);\n```\n\n\n\n페이팔 클라이언트 ID가 없는 경우 \"로딩 중...\"이 표시됩니다:\n\n```js\nif (!paypalClientId) {\n  return <div>로딩 중...</div>;\n}\n```\n\n성공 및 오류 처리를 다음과 같이 수행할 거에요:\n\n```js\nconst handleSuccess = () => {\n  router.push('/');\n};\n\nconst handleError = (error: any) => {\n  console.error('결제 오류:', error);\n};\n```\n\n\n\n그럼 모든 것을 표시할 거예요:\n\n```js\n  return (\n    <div className='bg-blue-900'>\n      <div className=\"w-full bg-blue-900 flex flex-col justify-center items-center\">\n      <h1 className=\"md:text-5xl text-3xl font-bold text-blue-500\">결제 페이지</h1>\n      <p>총액: ${amount}</p>\n      <div className=\"w-screen p-14\">\n      <PayPalPaymentButtons amount={parseFloat(amount as string)} paypalClientId={paypalClientId} onSuccess={handleSuccess} onError={handleError} />\n      </div>\n      </div>\n    </div>\n  );\n```\n\n실제 페이지는 Suspense 경계로 둘러싸여야 합니다:\n\n```js\nconst actualPage: React.FC = () => {\n  return <Suspense fallback={<div>Loading...</div>}><PaymentPage /></Suspense>;\n}\n\nexport default actualPage;\n```\n\n\n\n전체 코드:\n\n```js\n'use client';\nimport React, { useEffect, useState, Suspense } from 'react';\nimport { useRouter, useSearchParams } from 'next/navigation';\nimport PayPalPaymentButtons from '../ui/paypal-buttons';\n\nconst PaymentPage: React.FC = () => {\n  const router = useRouter();\n  const searchParams = useSearchParams();\n  const amount = searchParams ? searchParams.get('amount') : null;\n\n  const [paypalClientId, setPaypalClientId] = useState<string | null>(null);\n\n  useEffect(() => {\n    fetch('/api/paypal-client-id')\n      .then((response) => response.json())\n      .then((data) => {\n        if (data.paypalClientId) {\n          setPaypalClientId(data.paypalClientId);\n        } else {\n          console.error('PayPal client ID not found.');\n        }\n      })\n      .catch((error) => {\n        console.error('Failed to fetch PayPal client ID:', error);\n      });\n  }, []);\n\n  if (!paypalClientId) {\n    return <div>Loading...</div>;\n  }\n\n  const handleSuccess = () => {\n    router.push('/');\n  };\n\n  const handleError = (error: any) => {\n    console.error('Payment error:', error);\n  };\n\n  return (\n    <div className='bg-blue-900'>\n      <div className=\"w-full bg-blue-900 flex flex-col justify-center items-center\">\n        <h1 className=\"md:text-5xl text-3xl font-bold text-blue-500\">Payment Page</h1>\n        <p>Total Amount: ${amount}</p>\n        <div className=\"w-screen p-14\">\n          <PayPalPaymentButtons amount={parseFloat(amount as string)} paypalClientId={paypalClientId} onSuccess={handleSuccess} onError={handleError} />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nconst actualPage: React.FC = () => {\n  return <Suspense fallback={<div>Loading...</div>}><PaymentPage /></Suspense>;\n}\n\nexport default actualPage;\n```\n\n이렇게해요. 이 글은 Next.js 프로젝트에 PayPal 체크아웃을 통합하는 것에 대한 내용이었습니다. 파일 이름과 코드의 일부 이름으로 보았듯이, 모든 것이 가지고 있기 전에 약간 실험을 해봤습니다. 이 글이 결제 페이지를 만들 때 올바른 방향으로 안내가 되길 바랍니다. 이 튜토리얼을 좋아하셨다면 박수를 보내주시고, 팔로우를 눌러주세요. 질문이 있으시면 언제든지 답변해 드리겠습니다.\n\n즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject_0.png"},"coverImage":"/assets/img/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject_0.png","tag":["Tech"],"readingTime":19},{"title":"리액트 훅 패턴 이해 및 순수 자바스크립트에서의 구현 방법","description":"","date":"2024-05-12 22:59","slug":"2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript","content":"\n\n<img src=\"/assets/img/2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript_0.png\" />\n\n안녕하세요! 여러분은 이들을 보았고, 그들에 대해 읽었으며 널리 사용했습니다. 하지만 그들이 어떻게 작동하며 JavaScript에서 이미 알려진 패턴을 따르는지 궁금했던 적이 있나요? 예를 들어, useState hook을 고려해 봅시다.\n\n```js\nconst [counter1, setCounter1] = useState(0);\nconst [counter2, setCounter2] = useState(0);\n```\n\nuseState는 어떻게 호출될 로컬 상태 변수(counter1 또는 counter2)를 알 수 있을까요? 두 메소드 호출이 동일한 서명을 가지고 있음을 주목해 주세요!\n\n\n\n다음 섹션으로 넘어가기 전에 잠시 생각해보세요.\n\n훅은 React의 기능으로, 함수 컴포넌트에서 상태 및 다른 React 기능을 사용할 수 있게 해줍니다. React 16.8에서 소개된 훅은 현대적인 React 개발에서 필수 요소가 되어, 컴포넌트 상태 및 라이프사이클 관리에 더 함수형 접근을 제공합니다.\n\n이 글에서는 훅 패턴을 자세히 살펴보고, 이 패턴을 순수 JavaScript에서 구현하는 방법을 제시할 것입니다. React에서 이 패턴은 모든 종류의 훅에 적용됩니다 - useState, useEffect, useId 등(React v18의 완전한 목록은 Hooks에서 확인할 수 있습니다) - 하지만 여기서는 상태 관리와 useState 훅에 초점을 맞출 것입니다.\n\n## 클래스 컴포넌트에서 상태 관리\n\n\n\n먼저 리액트 클래스 컴포넌트에서 상태 관리가 작동하는 방법을 간단히 알아보겠습니다. 리액트 클래스 컴포넌트에서 상태는 this.State 속성과 this.setState(…) 메서드로 관리됩니다:\n\n```js\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // 여러 상태 변수를 초기화합니다\n    this.state = {\n      value1: 0,\n      value2: 1\n    };\n  }\n \n  render() {\n    /* value1과 value2를 사용한 JSX */\n  }\n \n}\n```\n\n클래스 컴포넌트에서 상태를 업데이트하려면 this.setState를 사용합니다. 이 메서드는 컴포넌트의 상태 업데이트를 예약하고 리액트에게 컴포넌트를 다시 렌더링하도록 지시합니다 (훅이 있는 함수형 컴포넌트와 마찬가지로). 다음은 클래스 내에서 로컬 상태를 업데이트하는 방법입니다:\n\n```js\nthis.setState({ value1: this.state.value1 + 1 });\nthis.setState({ value2: this.state.value2 + 1 });\n```\n\n\n\n위의 코드에서 확인할 수 있듯이 상태는 명시적으로 키에 의해 매핑됩니다. 여기서 각 키가 특정 상태 변수에 해당하는 객체를 정의합니다. 따라서 상태 변수와 업데이트 사이의 관계가 명확하고 직접적으로 나타납니다. 이는 JavaScript에서 더 전통적이고 표준적인 코드 패턴입니다. 이제 React Hooks를 살펴보겠습니다.\n\n## 함수형 컴포넌트에서 상태 관리\n\n```js\nfunction MyComponent() {\n   \n   const [value1, setValue1] = useState(0); // 초기 render 시 value1을 0으로 초기화하거나 후속 render에서 value1을 가져옵니다.\n   const [value2, setValue2] = useState(1); // 초기 render 시 value2를 1로 초기화하거나 후속 render에서 value2를 가져옵니다.\n\n   render(\n    /* value1과 value2를 사용한 JSX */\n   );\n  ...\n}\n```\n\n클래스 컴포넌트와는 다르게, 여기서 상태 관계는 암시적입니다. 함수형 컴포넌트의 useState 훅에서는 각 상태 변수(value1 및 value2 예시에서)가 독립적으로 선언되며 업데이트 메커니즘(세터 함수)이 암시적으로 연결됩니다. 상태 변수와 연결된 객체 매핑 키가 없고, useState 호출마다 현재 상태 값과 업데이트를 위한 메서드 쌍이 반환됩니다.\n\n\n\n함수형 컴포넌트에서 상태를 업데이트하려면, React의 useState 메서드를 호출하여 해체된 'setter' 함수를 사용합니다:\n\n```js\nsetValue1(value1 + 1);\nsetValue2(value2 + 1);\n```\n\n이 글의 목적은 React Hooks에서의 **암시적 상태 연관** 이면을 탐색하고, React 이외의 일반 JavaScript에서 어떻게 구현할 수 있는지 알아보는 것입니다.\n\n# 접근 방식\n\n\n\n리액트의 useState 및 유사한 훅이 제공하는 기능은 잘 알려진 JavaScript 디자인 패턴의 전통적인 범주에 정확히 속하지는 않습니다. 대신 이는 주로 함수형 프로그래밍에서 비롯된 여러 프로그래밍 개념들을 고유하게 결합한 것으로, 주로 함수형 컴포넌트 및 반응성 모델의 리액트 컨텍스트에서 특화되어 있습니다. 이는 리액트의 렌더링 및 조정 프로세스와 원활하게 작동하도록 설계되어 있어, 전통적인 JavaScript 패턴과는 다릅니다. 그러나 여전히 몇 가지 이미 존재하는 패턴과 개념들과 느슨하게 관련짓을 수 있습니다. 이 중 몇 가지는 다음과 같습니다:\n\n- Factory Functions\nuseState는 상태의 인스턴스와 해당 setter 함수를 생성하는 일종의 팩토리 함수로 볼 수 있습니다. 팩토리 함수는 JavaScript에서 객체를 생성하고 반환하는 일반적인 패턴입니다.\n- 함수형 프로그래밍\nuseState는 변경 불가능한 상태 업데이트의 사용을 권장하며 함수형 프로그래밍 패러다임 내에서 잘 맞습니다. 여기서 함수에 부작용이 없는 순수 함수들이 존재합니다.\n- 클로저\nuseState에 의해 반환된 setter 함수(예: const [state, setState] = useState(initialValue)에서 setState부분)는 클로저입니다. 이는 함수 컴포넌트의 스코프 내에서 variable에 대한 접근을 유지하며, 그 외의 즉시적인 스코프 외부에서도 호출됩니다.\n- Command Pattern\nsetter 함수 역시 명령 패턴을 통해 볼 수 있습니다. 여기 요청(상태 변경)을 객체로 캡슐화하는 함수입니다.\n- Observer Pattern\n직접적인 옵저버 패턴의 실행은 아니지만, 리액트에서 상태 변경이 컴포넌트 재랜더링을 트리거하는 방식은 개념적으로 유사합니다. 상태는 \"주체\" 역할을 하며, 컴포넌트 재랜더링은 상태 변경에 반응하는 \"옵저버\"인 셈입니다.\n- 함수 호출 추적\n훅의 가장 중요한 측면입니다. 이를 통해 React가 특정 함수형 컴포넌트 인스턴스와 상태 및 효과를 관리하고 관련시킬 수 있습니다. 이 기능은 결국 useState나 다른 훅 함수를 여러 번 호출할 수 있게끔 해 주는 것입니다. 컴포넌트가 useState(...)를 여러 번 호출할 때 특정 상태가 어디에 대해 호출되는지를 명시적으로 나타내지 않는다는 것을 참고하세요. 이 메커니즘은 컴포넌트 내에서의 훅 호출 순서에 기반을 두고 작동합니다.\n\n다음의 리액트 코드 스니펫에서, 컴포넌트가 다시 렌더링되고 함수가 다시 호출될 때, 첫 번째 useState 호출은 내부 상태 구조의 첫 번째 \"슬롯\"(여기에서는 배열을 사용할 수 있음)에서 현재 상태를 가져오며, state1과 같습니다. 그리고 두 번째 useState 호출은 두 번째 슬롯에서 state2를 가져오게 됩니다. 이와 같은 방식으로 React가 특정 useState 호출에 어떤 상태가 대응하는지를 파악할 수 있다는 것이 중요한 포인트입니다.\n\n```js\nconst [state1, ..] = useState(...)   // 첫 번째 호출은 첫 번째 상태에 대한 매핑을 생성합니다\nconst [state2, ..] = useState(...)   // 두 번째 호출은 두 번째 상태에 대한 매핑을 생성합니다\n...\nconst [stateN, ..] = useState(...)   // N번째 호출은 n번째 상태에 대한 매핑을 생성합니다\n```\n\n7. 컴포넌트 상태 및 효과 관리\n\n\n\n이 추적 덕분에 훅의 상태가 변경되거나 이펙트가 실행되어야 할 때 React는 정확히 상호 작용해야 하는 상태나 이펙트를 알 수 있습니다. 이는 컴포넌트의 인덱싱된 목록 내에서 훅의 위치를 참조할 수 있기 때문입니다!\n\nReact에서의 훅 패턴, 특히 useState는 함수형 컴포넌트와 그들의 반응성 모델에 특화되어 있습니다. 이는 React의 렌더링 및 조화 과정과 원활하게 작동하도록 설계되어 있어서, 전통적인 JavaScript 패턴과 구분됩니다. 일부 일반적인 프로그래밍 개념을 이용하지만, React 컴포넌트 라이프사이클 및 이벤트 처리와 어우러져 있는 방식이 독특합니다.\n\n# 구현 — 첫 번째 시도\n\n이전 섹션에서 설명한 훅의 본질은 순수 JavaScript로 에뮬레이션될 수 있으며, 상태 관리 및 함수 호출 추적의 기본 개념을 보여줍니다. 우리가 만든 HookState 구현의 전체 코드를 살펴보겠습니다. 여기서 주요 부분들입니다.\n\n\n\n## 상태, 세터 및 상태 인덱스\n\n```js\nlet states = [];    // **state** 값을 보관하기 위한 배열입니다. useState와 비슷한 훅을 흉내내고 싶지만 단순히 'hooks'로 이름을 지을 수도 있습니다\nlet setters = [];   // **setter** 함수를 보관하기 위한 배열입니다\nlet stateIndex = 0; // 현재 상태 인덱스를 추적하는 카운터 역할을 합니다\n```\n\n## 인덱스 초기화 메서드\n\n이 메서드는 다시 렌더링을 시뮬레이션합니다. 각 새로운 렌더링 사이클(컴포넌트가 다시 렌더링되어야 할 때)마다 이 함수를 호출하여 상태 인덱스를 0으로 재설정해야 합니다:\n\n\n\n```js\nexport function resetHookIndex() {\n  stateIndex = 0;\n}\n```\n\n이 모든 것을 종합해보면, 여기에 순수 JavaScript로 구현된 간단한 훅 시스템이 있습니다.\n\n## HookPattern.js\n\nHookPattern.js는 useHookPattern과 resetHookIndex 두 가지 메서드를 내보냅니다. 이전에 언급했듯이, resetHookIndex는 다시 렌더링 단계를 시뮬레이션하며, 이 글에서는 훅 사용자 코드에서 수동으로 호출할 것입니다. React에서는 이것이 렌더링 및 조정 엔진의 일부이며, 프레임워크에 의해 자동으로 호출될 것이라고 믿을 수 있습니다.\n\n\n\n```js\n// HookPattern.js\n\nlet states = []; \nlet setters = [];  \nlet stateIndex = 0;  \n\nexport function resetHookIndex() {\n  stateIndex = 0;\n}\n\nexport function useHookPattern(initialValue) {\n  const currentStateIndex = stateIndex;\n   \n  // state already initialized? \n  if (!setters[currentStateIndex]) {\n    // If not, initialize state and create a setter\n    states[currentStateIndex] = initialValue;\n    \n    setters[currentStateIndex] = (newValue) => {\n      states[currentStateIndex] = newValue;\n    };\n  }\n  \n  stateIndex++;\n  return [states[currentStateIndex], setters[currentStateIndex]];\n}\n```\n\n이제 순수 JavaScript useHookPattern을 사용해 봅시다. 이 예제에서는 React를 사용하지 않습니다.\n\n## ExampleUseHookPattern.js\n\n```js\n// ExampleUseHookPattern - 우리가 만든 HookPattern의 사용법을 보여줍니다.\n\nimport { useHookPattern, resetHookIndex } from './HookPattern';\n\nfunction ExampleHook() {\n  // 다시 렌더링하기 전에 인덱스를 리셋합니다. React에서는 렌더링 엔진의 일부입니다.\n  resetHookIndex();\n\n  const [value1, setValue1] = useHookPattern(0);\n  const [value2, setValue2] = useHookPattern(1);\n\n  function handleClick() {\n    setValue1(value1 + 1);\n    setValue2(value2 + 1);\n  }\n\n  return {\n    render: () => console.log(`Value1: ${value1}, Value2: ${value2}`),\n    handleClick\n  };\n}\n\n// 컴포넌트 렌더링 모의 실행\nconst myComponent = ExampleHook();\n\nmyComponent.render(); \n// 이는 다음을 출력해야 합니다: Value1: 0, Value2: 1\n\n// 핸들 클릭 및 상태 업데이트 모의 실행\nmyComponent.handleClick();\n\n\n// 컴포넌트 다시 렌더링 등 모의 실행\nconst myComponentUpdated = ExampleHook();\n\nmyComponentUpdated.render(); \n// 이는 다음을 출력해야 합니다: Value1: 1, Value2: 2\n```\n\n\n\n여기서 중요한 점은 ExampleHook의 모든 렌더링에서 value1에 대한 useHookPattern이 항상 value2에 대한 useHookPattern보다 먼저 호출된다는 것입니다. 렌더링 간에 이 순서는 React의 훅 동작을 모방하기 위해 일관되어야 합니다.\n따라서 함수 컴포넌트 실행 중에 hookPattern이 호출되는 순서가 중요합니다.\n\n그럼, 이제 작동 방식을 살펴보겠습니다:\n\n먼저, ES6 모듈에 익숙하지 않다면, ES6 import 메커니즘은 가져온 바인딩(상태, 설정자, useHookPattern, resetHookIndex)이 내보낸 값을 실시간 읽기 전용 뷰로 보장합니다. HookPattern.js 모듈에서 이러한 내보낸 값에 대한 변경 사항은 즉시 가져온 모듈에서 볼 수 있습니다.\n\n## 컴포넌트 라이프사이클 시뮬레이션\n\n\n\n각각 ExampleHook이 호출될 때마다 컴포넌트의 \"렌더\"를 시뮬레이션합니다. ExampleHook()를 처음 호출할 때는 hookPattern(initialValue)이 상태 변수들을 초기화하고 만나는 각 상태 변수에 대한 상태와 세터를 설정합니다(states[currentStateIndex]를 설정하고 setters[currentStateIndex]에 세터를 생성함). 따라서 초기에 상태 변수 value1은 0으로 설정되고 상태 변수 value2는 1로 설정됩니다.\n\n처음으로 myComponent.render()를 호출하면, 렌더링됩니다 (여기서 콘솔에 출력됩니다):\n\nValue1: 0, Value2: 1\n\n이후의 ExampleHook() 호출에서는 stateIndex가 ExampleHook()의 시작에서 resetHookIndex()로 재설정되므로, hookPattern() 호출마다 states와 setters에서 동일한 인덱스 위치에 접근됩니다. 이것은 이전에 설정된 상태와 해당 세터들을 초기화 없이 재사용할 수 있도록 해주기 때문에 중요합니다.\n\n\n\n그래서 두 번째로 myComponent.render()를 호출하면 다음과 같이 렌더링됩니다:\n\nValue1: 1, Value2: 2\n\n바로 React에서 동작하는 방식입니다!\n\n# 구현 — 두 번째 패스\n\n\n\n결과적으로, 우리가 고안한 HookPattern의 사용법은 실제 React 컴포넌트에서 쉽게 시연됩니다!\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { useHookPattern, resetHookIndex } from './HookPattern';\n\nfunction ExampleHook() {\n    const [value1, setValue1] = useHookPattern(0); // 우리의 'useState' 훅\n    const [value2, setValue2] = useHookPattern(1);\n    const [trigger, setTrigger] = useState(0);     // React의 useState 훅\n\n    function handleClick() {\n        setValue1(value1 + 1);\n        setValue2(value2 + 2);\n        // 리렌더링 트리거\n        setTrigger(trigger + 1); \n    }\n\n    useEffect(() => {\n        // 각 렌더링 후 훅 인덱스 재설정\n        resetHookIndex(); \n    });\n\n    return (\n        <>\n            Value1: {value1} Value2: {value2}\n            <button onClick={handleClick}>훅 패턴 테스트</button>\n        </>\n    );\n}\n\nexport default ExampleHook;\n```\n\n# 마치며\n\nHookPattern.js에 제공된 구현과 해당 패턴을 순수 JavaScript 및 React 컴포넌트에서 사용하는 것은 훅 패턴에 대한 기초적 이해를 제공합니다. 이 연습용 구현은 훅의 본질을 포착하지만 완전한 기능, 최적화, React 컴포넌트 라이프사이클 및 상태 관리 시스템과의 통합 부분은 빠져 있습니다. React의 실제 useState 및 useEffect와 같은 훅 구현은 React 렌더링 라이프사이클의 성능에 최적화되고 더 복잡합니다.\n\n\n\n제가 믿는 바로는 이 탐구가 React 훅의 근본 원리들 중 일부에 대해 명확하게 알려주었고, 현대 웹 개발 세계에서의 학습 또는 가르침에 유익할 것이라고 생각됩니다.","ogImage":{"url":"/assets/img/2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript_0.png"},"coverImage":"/assets/img/2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript_0.png","tag":["Tech"],"readingTime":10},{"title":"React 19 데이터 관리 라이브러리에 미치는 영향","description":"","date":"2024-05-12 22:57","slug":"2024-05-12-React19ImpactonDataManagementLibraries","content":"\n\n![이미지](/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png)\n\nReact 19에서는 데이터 처리 방식에 주로 초점을 맞춘 많은 새로운 기능이 도입되었습니다. 네, 이제 React는 효율적인 데이터 가져오기 및 데이터 변경을 처리하기 위한 많은 훅을 제공합니다. 여기에 모두 빠르게 나열해 보겠습니다.\n\n새로운 훅:\n- 많은 향상된 점:\n\n액션 소개:\n\n\n\nReact에서의 액션은 사용자가 UI와 상호작용한 후 수행하려는 모든 것을 의미합니다.\n예: 버튼을 클릭하는 것이 액션입니다. 양식을 제출하는 것도 액션입니다. 그리고 계속 나열됩니다.\n\n이전에는 useEffect, useState, useMemo과 같은 여러 후크를 결합하여 작업을 수행했습니다.\n\n하지만 이제 React에서 직관적인 API를 도입하여 더 이상 보일러플레이트 코드를 해결하기 위해 사용할 필요가 없습니다.\n\n간단한 예로 사용자 세부정보 저장을 살펴봅시다:\n\n\n\n```js\nfunction UpdateUser() {\n    const [status, setStatus] = useState(\"idle\");\n    const saveUser = (userData) => {\n        setStatus(\"saving\");\n        service.saveUser(userData)\n        .then(() => {\n            setStatus(\"idle\");\n            redirect(\"/userdetail\");\n        }).catch(() => {\n            setStatus(\"error\");\n        })\n    }\n\n   return (\n        <>\n            {status == \"saving\" ? \"저장 중....\" : \"\"}\n            <button onClick={() => saveUser()}>사용자 저장</button>\n        </>\n   )\n}\n```\n\nWith action:\n\n```js\nfunction UpdateUser() {\n    const [isPending, startTransition] = useTransition();\n    const [error, setError] = useState();\n    const saveUser = (userData) => {\n        startTransition(async () => {\n            await service.saveUser(userData)\n                .then(() => {\n                   redirect(\"/userdetail\");\n                })\n                .catch(err => {\n                    setError(err);\n                });\n        });\n    }\n\n   return (\n        <>\n            {isPending ? \"저장 중....\" : \"\"}\n            <button onClick={() => saveUser()}>사용자 저장</button>\n        </>\n   )\n}\n```\n\n\n\n동작을 래핑함으로써 React는 두 가지 훅을 도입했습니다: useActionState, useOptimistic.\n\nuseActionState 훅:\n\n이 훅은 데이터 변경 상태를 처리하는 데 사용됩니다. 예를 들어, 서버로 데이터를 보내는 경우 등에 활용됩니다. 예를 들어, 프로필 정보를 업데이트하는 간단한 예시가 여기 있습니다.\n\n```js\nimport { useActionState } from 'react';\n\nexport function MemberForm() {\n  const [error, submitAction, isPending] = useActionState(\n    async (previewState, formData) => {\n      const error = await updateUser(formData).catch(\n          (err) => 'Error ' + previewState\n      );\n      if(!error) {\n        redirect(\"/memberdetail\");\n        return null;\n      }\n      return error;\n    }\n  );\n\n  return (\n    <form id=\"memberForm\" name=\"memberForm\" action={submitAction}>\n      {isPending && <p>업데이트 중...</p>}\n      <fieldset>\n        <label htmlFor=\"firstName\">이름</label>\n        <input id=\"firstName\" name=\"FirstName\" type=\"text\" />\n      </fieldset>\n      <fieldset>\n        <label htmlFor=\"lastName\">성</label>\n        <input id=\"lastName\" name=\"LastName\" type=\"text\" />\n      </fieldset>\n      <!-- 구현 아래에 -->\n      <PhoneNumber />\n      <button type=\"submit\">저장</button>\n      {error && <p>{error} </p>}\n    </form>\n  );\n}\n```\n\n\n\nuseActionState()에 제공된 action 함수는 수행된 작업에 대해 null 또는 오류를 반환해야하고, 폼은 자동으로 재설정됩니다. previewState는 우리가 action에서 반환한 것과 같아집니다.\n\nuseFormStatus 훅:\n\n이 훅을 사용하면 폼 컴포넌트 내에서 폼 제출 상태를 알 수 있습니다.\n\n```js\nfunction PhoneNumber() {\n  const { pending } = useFormStatus();\n  return (\n     <fieldset disabled={pending}>\n       <label htmlFor=\"Phone\">전화번호</label>\n       <input id=\"Phone\" name=\"Phone\" type=\"number\" />\n     </fieldset>\n  )\n}\n```\n\n\n\n`useOptimistic()` 훅:\n\n이 훅은 서버로부터 응답을 기다리는 동안 UI에 낙관적인 업데이트를 수행하는 데 사용됩니다. 예: 좋아요 버튼을 클릭할 때, 우리는 서버가 성공 상태로 응답할 때까지 좋아요 반응을 표시하기를 기다리고 싶지 않습니다. 우리는 즉시 반응을 보여줄 수 있고, 서버에서 응답이 왔을 때, 그것을 로컬 상태에 동기화할 것입니다. 이것이 낙관적인 업데이트라고 불리는 것입니다.\n\n이를 위해 이전에는 API의 상태를 추적하고, API가 실패한 경우 이전 값으로 수동으로 전환해야 했습니다. 이 훅을 사용하면 코드가 더 간단해집니다. 여기 좋아요 버튼의 간단한 예시가 있습니다.\n\n```js\nimport React from 'react';\n\nfunction LikeButton({ count, onClick }) {\n  // 좋아요 카운트에 대한 낙관적 상태 생성.\n  const [optimisticCount, setOptimisticCount] = React.useOptimistic(\n    count,\n    (state, newValue) => {\n      // 여기서 우리는 즉시 상태를 계산합니다.\n      // 이 상태 함수의 반환 값은 즉시 optimisticCount에 설정될 것입니다.\n      console.log('낙관적 콜백 호출', state, newValue);\n      return newValue;\n    }\n  );\n\n  // 좋아요 상태 업데이트를 위한 전환 생성\n  // setOptimisticCount 메서드는 Action 내에서만 호출할 수 있기 때문에\n  // Action은 startTransition() 메서드 내부의 간단한 비동기 함수입니다.\n  const [isPending, startTransition] = React.useTransition();\n\n  const updateCount = () => {\n    startTransition(async () => {\n      // 즉시 카운트 증가\n      setOptimisticCount(optimisticCount + 1);\n      // 값이 부모 구성 요소에 저장될 때까지 대기\n      await onClick(optimisticCount).catch((err) => console.log(err));\n      // 반환될 때까지 이 전환은 보류 상태에 있을 것입니다.\n      return null;\n    });\n  };\n\n  return (\n    <p>\n      <span>\n        {optimisticCount} {count !== optimisticCount ? '업데이트 중...' : ''}\n      </span>\n      <button onClick={updateCount}>좋아요</button>\n    </p>\n  );\n}\n\nexport function ReactionComponent() {\n  const [count, setCount] = React.useState(0);\n  const onClick = () => {\n    return new Promise((resolve, reject) => {\n      // 지연을 모방\n      setTimeout(() => {\n        setCount(count + 1);\n        reject();\n      }, 2000);\n    });\n  };\n  return <LikeButton count={count} onClick={onClick} />;\n}\n```\n\n\n\nAPI를 사용하실 건가요?\n\n컴포넌트 내에서 리소스를 소비하는 데 사용됩니다. 이 리소스는 다음과 같을 수 있어요:\n\n- React Context: 여기에는 사용자 세션을 유지하기 위한 간단한 유틸리티 컴포넌트와 훅이 있습니다.\n\n```js\n import React from 'react';\n\n const UserContext = React.createContext();\n\n export function UserSession({ children }) {\n   const user = React.useMemo(() => ({ id: '001', name: 'user' }), []);\n   return <UserContext.Provider value={user}>{children}</UserContext.Provider>;\n }\n\n export function useUser() {\n   return React.use(UserContext);\n }\n```\n\n\n\n2. Promises: 이 기능을 사용하면 구성 요소 내에서 데이터를 직접로드 할 수 있습니다. 추가적인 보일러플레이트 코드가 필요하지 않습니다. 이 기능을 사용하기 전에 어떻게 했었는지 간단한 예시를 살펴보겠습니다.\n\n이전:\n\n```js\r\n //Before\n function UserDetailComponent({ userId }) {\n     const [user, setUser] = useState(null);\n     useEffect(() => {\n         fetchUser(userId)\n             .then(setUser);\n     }, [userId]);\n }\r\n```\n\n이후: 약속을 구성 요소에 직접 전달하고 사용할 수 있습니다. 'use'를 사용하여 소비합니다.\n\n\n\n```js\n// 이후\nfunction UserDetailComponent({ userPromise }) {\n    const user = use(userPromise);\n}\n\nfunction UserProfileComponent({ userId }) {\n    // 이는 매 렌더링마다 새 promise를 만들지 않았는지 확인하기 위한 것입니다.\n    // 일반적으로 데이터를 가져오는 라이브러리를 사용하여\n    // 리렌더링 간에 동일한 promise를 반환합니다.\n    const userPromise = useMemo(() => {\n        return fetchUser(userId);\n    }, [userId]);\n\n    return (\n        <React.Suspense fallback={\"로딩 중...\"}>\n            <UserDetailComponent userPromise={userPromise} />\n        </React.Suspense>\n    );\n}\n```\n\n개선 사항:\n\n- 컴포넌트 속성으로 ref 사용:\n\n이후에는 새 인자로 선언하는 대신 컴포넌트 속성에서 ref를 가져올 수 있습니다.\n\n\n\n\n```js\n// 이전\nexport React.forwardRef(function UserDetails(props, ref) => {\n});\n\n// 이후\nexport function UserDetails({ user, ref }) {\n   useImperativeHandle(ref, function () {\n    return {};\n   });\n}\n\n//...\n<UserDetails ref={ref}/>\r\n```\n\n2. ref 콜백이 정리 함수를 반환합니다:\n\n이 향상으로 불필요한 보일러플레이트 코드를 제거할 수 있습니다\n\n```js\n// 이전\nfunction ProfileDetail() {\n    const ref = React.createRef();\n\n    useEffect(() => {\n     const listener = () => {};\n     ref.current.addEventListener(\"keydown\", listener);\n     return () => ref.current.removeEventListener(\"keydown\");\n    }, []);\n\n    return (\n        <input ref={ref}/>\n    )\n}\n\n// 이후\nfunction ProfileDetail() {\n    function inputRef(ref) {\n       const listener = () => {};\n       ref.current.addEventListener(\"keydown\", listener);\n       return () => ref.current.removeEventListener(\"keydown\");\n    }\n\n    return (\n        <input ref={inputRef}/>\n    )\n}\r\n```\n\n\n\n3. 컴포넌트에서의 메타 태그 지원:\n\n이제 클라이언트 컴포넌트 내에서 사용자가 있는 위치에 따라 문서 제목을 변경할 수 있습니다.\n\n```js\n<Router>\n    <Route path=\"/dashboard\" element={Dashboard} />\n    <Route path=\"/profile\" element={Profile} />\n</Router>\n\nfunction Dashboard() {\n    return (\n        <title>판매 대시보드</title>\n    )\n}\n\nfunction Profile() {\n    return (\n        <title>존의 프로필</title>\n    )\n}\n```\n\n# 정말 신경 써야 할까요:\n\n\n\n새로운 기능들과 개선사항을 고려할 때, React Query, SWR과 같은 데이터 관리 라이브러리를 사용하는 사용자라면 React에서 기본적으로 제공하는 이러한 새로운 데이터 관리 옵션에 대해 신경써야 할까요?\n\n내 의견으로는, 이것들은 모두 낮은 수준의 훅들로, 라이브러리 작성자가 코드베이스 내에서 보일러플레이트 코드를 제거하는 데 사용할 수 있습니다. 이미 상기한 데이터 관리 라이브러리를 통해 컴포넌트 수준에서 데이터를 가져오고, 로컬 캐싱과 유효한 무효화와 같은 기능을 활용하고 있기 때문에요.\n\nref, use(Context), 메타 태그와 같은 개선 사항을 활용하여 보일러플레이트 코드를 제거하고 코드베이스를 더 깔끔하게 만들 수 있습니다.\n\n데이터 관리를 위해 네이티브 폼 요소로 전환하는 주요 목적은 점진적인 향상을 선택하는 것입니다. 이 관점에서 코드베이스를 점진적으로 변경하여 앱이 최소한의 JavaScript로 작동하도록 할 수 있습니다.\n\n\n\n여기 샘플 놀이터가 있습니다.\n\n원본 게시물: 2024년 5월 9일, https://yab.hashnode.dev에서 게시됨.","ogImage":{"url":"/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png"},"coverImage":"/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png","tag":["Tech"],"readingTime":9},{"title":"Type Guards in TypeScript 코드 버그를 방지하는 방법","description":"","date":"2024-05-12 22:56","slug":"2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree","content":"\n\n<img src=\"/assets/img/2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree_0.png\" />\n\n타입 가드(Type Guard)는 TypeScript에서 변수의 타입을 특정 코드 블록 내에서 좁힐 수 있는 메커니즘입니다. 이것은 TypeScript 컴파일러에 변수의 타입에 대한 추가 정보를 제공하여 런타임에서 변수의 타입을 더 정확하게 추론하고 TypeScript 코드의 타입 안전성을 향상시킵니다. 이를 통해 변수가 숫자, 문자열 또는 특정 속성을 가진 객체와 같은 어떤 종류의 데이터를 보유할 수 있는지 정의할 수 있습니다.\n\n하지만 변수가 여러 가지 유형을 동시에 가질 수 있는 경우는 어떻게 될까요? 이것이 타입 가드가 유용해지는 시점입니다. 이것들은 변수의 정확한 유형을 그 자리에서 찾아내도록 도와주는 탐정 도구와 같은 것입니다.\n\n타입 가드가 왜 중요한가요?\n\n\n\n`userInfo`라는 변수가 있고 이 변수에는 string(사용자 이름) 또는 더 많은 세부 정보(이름, 이메일)를 가진 객체가 포함될 수 있다고 가정해 봅시다. 타입 가드가 없는 경우 TypeScript는 객체에만 존재할 수 있는 특정 속성에 액세스할 수 없도록 오동작 할 수 있습니다.\n\n타입 가드는 `userInfo`의 타입을 런타임에서 확인하여 상황을 명확하게 해줍니다. 이렇게 하면 코드가 더:\n\n1. 신뢰할 수 있게 됩니다: 타입을 확인하여 `userInfo`를 정확히 사용하는 방법을 알 수 있습니다.\n\n2. 가독성이 좋아집니다: 코드가 당신과 다른 사람들에게 이해하기 쉬워집니다.\n\n\n\n3. 버그 없음: 초기에 형 불일치를 잡아 내어 프로그램을 충돌시킬 수있는 오류를 피할 수 있습니다.\n\n타입 가드의 종류: 탐정 키트\n\n타입 가드를 사용하는 다양한 방법이 있으며 각각의 장점이 있습니다:\n\n- in 연산자: 이 연산자는 객체에 특정 속성이 있는지 확인합니다. 특정 속성이 있는지 확인하는 데 도움이 됩니다.\n\n\n\n```typescript\nlet userInfo: string | { name: string, email: string };\nif (typeof userInfo === \"object\" && \"email\" in userInfo) {\nconsole.log(userInfo.email);\n}\n```\n\n- 타입 캐스팅: 타입 캐스팅 또는 타입 어서션이라고도 불립니다. TypeScript 컴파일러에 특정 타입으로 값을 취급하도록 지시하는 방법입니다. TypeScript에게 \"너보다 더 잘 안다고; 이 경우 값이 특정 타입임을 믿어줘\"라고 말하는 것과 같습니다.\n\n```typescript\nlet userInfo = (user as { name: string }).name;\nconsole.log(userInfo);\n```\n\n- 커스텀 타입 가드: 특정 조건을 확인하는 함수들입니다.\n\n\n\n```js\nfunction isUserObject(user: any): user is { name: string } {\nreturn typeof user === \"object\" && \"name\" in user;\n}\nif (isUserObject(userInfo)) {\nconsole.log(userInfo.name);\n}\n```\n\n사용 사례: 케이스를 풀어라:\n\n타입 가드는 다양한 상황에서 매우 유용합니다:\n\n- 사용자 입력 처리: 예상 형식에 맞는지 확인하기 위해 양식 데이터를 유효성 검사합니다 (숫자는 숫자 위치에, 텍스트는 텍스트 위치에).\n- 외부 데이터 처리: API나 파일에서 가져온 데이터가 항상 완벽하게 구조화되어 있지 않을 수 있습니다. 타입 가드는 형식을 식별하고 그에 맞게 처리할 수 있도록 도와줍니다.\n- 유연한 함수 작성: 타입 가드를 어댑터처럼 작용하여 다양한 유형의 데이터를 처리할 수 있는 함수를 작성합니다.\n\n\n\n유형 가드는 TypeScript의 유니언 유형이나 복잡한 데이터 구조와 같이 TypeScript의 유형 추론 능력이 제한되는 시나리오에서 특히 유용합니다. 이들은 TypeScript가 변수의 특정 유형을 이해하도록 도와 안정적이고 오류가 적은 코드를 작성하기 쉽게 만듭니다.\n\n유형 가드는 TypeScript 프로그래밍에서 핵심적인 역할을 하며, 개발자가 작업 중인 변수의 유형에 대해 정보를 얻고 안전하고 유지보수가 용이한 코드베이스를 작성할 수 있도록 도와줍니다.","ogImage":{"url":"/assets/img/2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree_0.png"},"coverImage":"/assets/img/2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree_0.png","tag":["Tech"],"readingTime":3},{"title":" Jest 테스트를 최대 10배 빠르게 만들기 ","description":"","date":"2024-05-12 22:55","slug":"2024-05-12-MakeyourJestTestsupto10xFaster","content":"\n\n\n![이미지](/assets/img/2024-05-12-MakeyourJestTestsupto10xFaster_0.png)\n\n중규모 리액트 프로젝트의 단위 테스트를 기다리는 데 30분이나 걸리는 것은 짜증납니다. 속도에 집중하기 위해 이를 개선하기 위한 몇 가지 조치를 취하기로 결정했습니다.\n\n우리가 모두 하는 대로, 우리는 구글에서 jest 성능을 향상시키기 위한 다양한 방법을 찾기 시작했습니다. 이 기사에는 우리가 가진 모든 관측치와 결과가 나열되어 있습니다. 이는 여러분의 구성에서 작동할 수도 있고, 그렇지 않을 수도 있습니다. 하지만, 이 기사를 살펴보고 각 방법을 시도하여 차이가 있는지 확인하는 것을 권장합니다.\n\n모든 최적화의 황금 규칙은 측정하는 것입니다. 네, 현재 상황을 측정해야 합니다. 우리가 추적해야 하는 모든 측정 항목이 여기에 나열되어 있습니다.\n\n- 전체 test suite 실행 시간.\n- 시간과 함께 상위 10개 느린 suite.\n- 전체 사용된 메모리.\n\n# # 1 Tests 내부에서 네트워크 호출하기\n\n테스트가 느린 이유를 찾아보던 중 팀에서 받은 관찰 중 하나는 테스트가 불안정하며, 반응 컴포넌트 내부에서 API 호출을 하고 있을 수 있다는 것이었습니다. 이에 호기심을 느끼기 시작했고, 이는 사실이었습니다. 테스트 케이스가 API 호출을 하고 응답을 기다리고 있어서 테스트가 느린 이유 중 하나였습니다.\n\n최상의 단위 테스트는 테스트를 실행할 때마다 항상 동일한 결과를 제공하는 테스트입니다. 네트워크에 의존하면 이를 달성하는 것이 불가능합니다.\n\n\n\n다음 단계는 이러한 문제를 피하는 방법을 찾는 것이었고, 그때 jest-offline을 발견했습니다. 이를 구현하기 시작했지만, 다음 문제는 많은 테스트 케이스가 API 호출을 하고 있었기 때문에 이를 모두 식별하고 호출을 모킹해야 했었습니다. 이 작업은 시간이 걸렸지만 노력할 가치가 있었습니다.\n\n지금은 jest-offline이 이 규칙을 강제하기 때문에, 우리가 호출을 모킹하지 않는다면 테스트가 직접 실패합니다.\n\n# #2 네트워크 호출 이상 외에도 더 많은 문제가 있을 수 있습니다.\n\n네트워크 호출이 하나의 문제일 수 있다는 것을 발견한 후, 다음은 비슷한 문제를 찾고 있었던 것입니다. 우리는 운좋게도 더 개선된 테스트 실행 시간의 문제를 하나 더 발견했습니다.\n\n\n\n단위 테스트는 독립적이고 정확해야 합니다. 그러나 우리는 테스트 케이스를 Redux Provider로 감싸고 있었는데, 이는 redux-persist의 persistReducer로 구성되어 있었습니다. Redux persist의 주요 목적은 서로 다른 탭 및 세션 간에 데이터를 유지하는 것이었지만 UT(단위 테스트)의 경우 이것은 정반대였습니다. 그래서 이를 제거하여 모든 테스트에서 IO 작업을 하나 줄였고, 많은 시간을 절약할 수 있었습니다.\n\n주목해야 할 사항\n\n- LocalStorage와 같은 불필요한 IO 작업 정리\n- 테스트 케이스에서 unMocked 타이머\n- 컴포넌트에 대한 불필요한 래퍼\n- Sentry 래퍼 → UT에 필요하지 않음\n- 분석 래퍼 → UT에 필요하지 않음\n\n# #3 최적 성능을 얻기 위해 MaxWorkers=50% 사용하기\n\n\n\n아래 언급된 기사에서 영감을 받아, 더 많은 내용을 읽을 수 있습니다.\n\nhttps://dev.to/vantanev/make-your-jest-tests-up-to-20-faster-by-changing-a-single-setting-i36\n\n## #4 yarn + Node V16 + Jest 28로 전환\n\nJest는 많은 성능 향상을 이루었습니다. 그래서 우리는 28로 업그레이드했고, NodeJS도 마찬가지입니다. 이 변경으로 성능이 크게 향상되었습니다.\n\n\n\n# #4 가장 느린 테스트 케이스 개선하기\n\n모든 최적화의 첫 단계는 무엇이 잘못되었는지를 파악하는 것이기 때문에, 가장 느린 테스트를 식별하는 것도 중요합니다. 아마 가장 느린 열 개의 테스트가 실행 시간의 80% 이상을 차지할 수도 있습니다. 누가 알겠어요!\n\njest-slow-test-reporter를 사용하여 가장 느린 테스트를 식별한 다음, 그 성능을 개선하는 작업에 착수하세요. 대부분의 테스트가 100ms 이하인 것이 좋습니다. 가장 느린 테스트도 최대 300ms 정도여야 합니다. 그 이상이면 심각한 문제가 있습니다.\n\n# #5 놀라운 성능 향상을 위해 swc/jest로 전환하기.\n\n\n\nesbuild의 등장으로 프론트엔드 세계는 개발 환경에서 속도에 더 많은 요구를 하게 되었습니다. swc는 러스트로 작성된 초고속 컴파일러입니다. 그렇다면 단위 테스트에도 똑같이 사용해볼까요?\n\n@swc/jest로 전환하면 성능이 즉시 향상된 것을 확인할 수 있습니다. 더 자세한 정보는 https://miyauchi.dev/posts/speeding-up-jest/를 참고해주세요.\n\n## 6. 메모리 누수\n\n느린 및 불안정한 테스트의 또 다른 원인은 메모리 누수입니다. 이 부분은 종종 무시되지만, 메모리 누수를 일으키는 테스트를 식별하는 것이 중요합니다.\n\n\n\n더 많은 정보를 얻기 위해 테스트에서 메모리 누수를 식별하는 방법은 다음을 참조할 수 있습니다: [여기](https://chanind.github.io/javascript/2019/10/12/jest-tests-memory-leak.html)\n\n# #6 React 테스팅 라이브러리\n\n성능 문제를 찾아보는 또 다른 장소는 테스트 케이스를 작성하는 방식입니다. 올바른 셀렉터의 사용이 느린 테스트의 주요 원인 중 하나입니다. 몇 가지 문제들은 다음과 같습니다.\n\n- .type을 여기저기 사용하면 안 됩니다. 필요한 곳에서만 사용하고, 그렇지 않으면 대안으로 .paste로 돌아가세요. 훨씬 빠릅니다.\n- React 테스팅 라이브러리를 사용할 때 흔히 발생하는 실수에 대한 자세한 내용은 [여기](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)를 참조할 수 있습니다.\n\n\n\n올바른 선택자와 기능을 사용하면 단위 테스트의 품질과 성능이 향상됩니다.\n\n## 추가 팁\n\n성능을 향상시키기 위해 사용할 수 있는 몇 가지 추가 팁을 아래에 나열했습니다.\n\n`findRelatedTests`\n\n\n\n이 플래그를 사용하면 코드 변경과 관련된 테스트만 실행되므로 테스트 실행 시간이 즉시 줄어듭니다. 따라서 1000개 이상의 테스트를 실행하는 대신 이제 변경한 20개 파일에 대해 20개의 테스트 케이스만 실행할 수 있습니다.\n\n또한 `--changedSince`을 사용하여 지정된 브랜치나 커밋 해시 이후의 변경 사항에 관련된 테스트를 실행할 수도 있습니다.\n\n```js\njest --changedSince <commit-id>\n```\n\nJSDOM 변경\n\n\n\n테스트 환경을 jsdom에서 LinkeDOM과 같은 것으로 변경하면 성능이 최소 2배 향상될 것입니다. 그러나 이것은 전문적으로 사용해 보지 않았기 때문에 권장하지는 않습니다. 권장할만한데요, 한 번 시도해보고 구성과 어떻게 작동하는지 확인해보세요.\n\n# 영향\n\n- 개발자들이 PR에서 빌드 확인을 보기 위해 기다려야 했던 시간의 일부만 기다리면 되기 때문에, 개발자 생산성 및 시간 관리가 개선됩니다.\n- CI의 부하가 현저히 줄어들어 더 많은 비용 절감이 이루어집니다.\n\n이러한 단계들이 순위 테스트 실행에 소요되는 시간을 크게 줄이는 데 도움이 될 것을 기대합니다. 이러한 팁으로 큰 변화를 이루실 수 있었는지, 이에 관한 성과를 남겨주세요.\n\n\n\n이 글은 원래 https://kirananto.com/make-your-jest-test-upto-10x-faster/ 에 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-12-MakeyourJestTestsupto10xFaster_0.png"},"coverImage":"/assets/img/2024-05-12-MakeyourJestTestsupto10xFaster_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 네이티브 개발 탐구 Expo vs React Native CLI","description":"","date":"2024-05-12 22:54","slug":"2024-05-12-ExploringReactNativeDevelopmentExpovsReactNativeCLI","content":"\n\n\n<img src=\"/assets/img/2024-05-12-ExploringReactNativeDevelopmentExpovsReactNativeCLI_0.png\" />\n\nReact Native로 모바일 애플리케이션을 개발하면 Expo와 React Native CLI라는 두 가지 주요 선택지가 제공됩니다. 각 접근 방식에는 고유한 장단점이 있습니다. 이 블로그 포스트에서는 Expo와 React Native CLI의 중요한 차이점을 탐색하여 프로젝트 요구 사항에 따라 정보에 근거해 결정을 내릴 수 있도록 도와드릴 것입니다.\n\n# Expo 이해하기\n\n# 장점:\n\n\n\n- 빠른 개발: Expo는 개발 과정을 간단하게 만들어 빠른 프로토타이핑과 반복을 가능케 합니다.\n- 통합된 도구 체인: Expo는 통합된 도구 체인을 제공하여 안드로이드와 iOS 모두에 대한 개발 워크플로우를 간소화합니다.\n- 미리 만들어진 구성 요소: 수많은 미리 만들어진 구성 요소에 액세스할 수 있어 수동 구성 필요성을 줄입니다.\n- 효율적인 킥스타트: Expo는 장치별 설정이나 네이티브 코드 종속성을 걱정할 필요 없이 앱 개발을 신속히 시작할 수 있도록 돕습니다.\n- 공기로 업데이트: 플랫폼을 통해 사용자 장치로 직접 업데이트를 배포할 수 있어 사용자가 앱 스토어에서 새 버전을 다운로드할 필요가 없어집니다.\n- 접근 가능한 미리 만들어진 라이브러리: Expo는 푸시 알림, 인앱 구매, 지도 등의 기능을 간편히 추가할 수 있도록 미리 만들어진 라이브러리와 API를 제공합니다.\n- 간소화된 빌드 프로세스: Expo가 빌드 프로세스를 관리하여 빌드 도구의 구성과 네이티브 코드 컴파일을 추상화합니다.\n- EAS 호환성: Expo는 iOS 앱을 빌드하기 위해 Mac이 필요한 제약을 제거합니다; 코드를 클라우드의 EAS로 빌드하고 배포할 수 있어 스토어로 직접 배포할 수 있습니다.\n- 네이티브 실제 장치 테스트: Expo를 사용하면 Expo Go 앱을 모바일에 설치하고 동일한 네트워크에 연결하여 모든 실제 장치(안드로이드 및 iOS)에서 테스트할 수 있습니다.\n\n# 단점:\n\n- 제한된 사용자 정의: Expo는 많은 네이티브 복잡성을 숨겨 제한된 사용자 정의 옵션을 제공하여 복잡한 프로젝트에는 단점이 될 수 있습니다.\n- Expo 에코시스템 의존성: Expo 프로젝트는 Expo 에코시스템 내에서 사용 가능한 라이브러리와 모듈로 제한되어 일부 타사 라이브러리의 사용을 제한합니다.\n- 빌드 제어 제약: React Native CLI에 비해 Expo는 빌드 구성 및 사용자 정의 옵션에 대해 더 적은 제어를 제공합니다.\n- 크기와 성능: Expo 앱은 React Native CLI 앱에 비해 더 큰 번들 크기를 보일 수 있어 다운로드 및 로딩 시간에 영향을 미칩니다. 또한 일부 성능 최적화가 Expo에서는 사용할 수 없을 수 있습니다.\n\n# React Native CLI의 해체\n\n\n\n# 장점:\n\n- 완전한 사용자 정의: React Native CLI는 네이티브 모듈과 프로젝트 구성에 대해 완전한 제어를 제공하여 복잡하고 매우 사용자 정의된 애플리케이션에 적합합니다.\n- 네이티브 모듈 접근: 개발자는 네이티브 모듈에 무제한 액세스할 수 있어 기기별 기능과의 통합이 가능합니다.\n- 다양성: 다양한 타사 라이브러리와 모듈을 지원하여 프로젝트에 구성 요소를 선택하는 유연성을 제공합니다.\n\n# 단점:\n\n- 복잡한 설정: React Native CLI 프로젝트 설정이 Expo보다 더 많은 단계가 필요하여 초기 개발 단계를 늦출 수 있습니다.\n- 가파른 학습 곡선: 유연성과 심도로 인해 React Native CLI는 Expo보다 학습 곡선이 가파르며, 초심자 친화적이지 않을 수 있습니다.\n\n\n\n# 올바른 방법 선택하기\n\n# Expo를 선택해야 하는 경우:\n\n- 프로토타입 및 MVPs: Expo는 아이디어를 빠르게 프로토타입화하고 최소 실현 가능 제품(MVPs)을 구축하는 데 탁월한 선택입니다.\n- 초보자 친화적 프로젝트: React Native 또는 모바일 개발에 새로운 개발자에게 이상적입니다.\n- 간소화된 워크플로우: 프로젝트가 광범위한 사용자 정의를 필요로하지 않고 Expo의 생태계 내에서 작동할 수 있다면 유용합니다.\n- 최대한의 사용자 정의보다는 간단함과 개발 용이성을 우선시합니다.\n- Expo가 과거에 직면한 대부분의 개발 문제가 해결되어 신뢰성 있는 선택지입니다. 심지어 Expo에서 이젝팅하는 것도 프리빌드 기능으로 더 간편해졌습니다.\n\n# React Native CLI를 선택해야 하는 경우:\n\n\n\n- 복잡한 프로젝트: 고도의 맞춤화 및 네이티브 모듈 통합이 필요한 복잡한 응용 프로그램을 다룰 때는 React Native CLI를 선택하십시오.\n- 숙련된 개발자: 모바일 개발 경험이 풍부한 팀에 적합하며, 개발 프로세스를 완전히 제어할 수 있습니다.\n- 네이티브 모듈에 대한 액세스: 기기별 기능 및 네이티브 통합에 많이 의존하는 경우, React Native CLI가 선호되는 선택이 됩니다.\n- 빌드 프로세스, 성능 최적화 또는 사용자 정의 옵션에 대해 광범위한 제어가 필요한 경우.\n\n# 결론\n\nReact Native 생태계에서 Expo와 React Native CLI 사이의 선택은 프로젝트의 특정 요구 사항 및 개발팀의 전문 지식과 밀접한 관련이 있습니다. Expo는 간편하고 초보자 친화적인 경험을 제공하여 신속한 프로토타이핑 및 간단한 프로젝트에 뛰어난 선택지가 됩니다. 네이티브 모듈 및 구성 요소에 대한 복잡한 제어를 요구하는 복잡한 응용 프로그램에는 React Native CLI가 넓은 맞춤화 옵션으로 선호됩니다.\n\nReact Native 여행을 시작하면 각 접근 방식의 장단점을 신중히 고려하여 프로젝트 복잡성, 개발 팀의 전문성 및 원하는 제어 수준과 같은 요소를 고려하십시오. React Native CLI의 유연성을 선택하든 Expo의 간편성을 선택하든, React Native 생태계는 강력하고 크로스 플랫폼 모바일 응용 프로그램을 개발하는 데 훌륭한 프레임워크를 제공합니다.\n\n\n\n- 👏 이야기에 박수를 보내고 저자를 팔로우해 보세요.\n- 저자의 통찰력 있는 콘텐츠에 감사의 표시를 해주세요.\n- Abhishek Kumar를 팔로우해 보세요.\n- 📰 Abhishek Kumar 출판물에서 더 많은 내용을 살펴보세요.\n- 🔔 소셜 미디어를 통해 연결 유지해 주세요.\n- Level Up Coding을 트위터에서 팔로우하고 LinkedIn에서 연결하여 최신 토론과 콘텐츠를 확인해 주세요.\n\n# Stackademic\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 글쓴이를 박수 치고 팔로우해 주시면 감사하겠습니다! 👏\n- 트위터(X), LinkedIn, YouTube에서 팔로우해 주세요.\n- Stackademic.com을 방문하여 전 세계적으로 무료 프로그래밍 교육을 민주화하는 방법에 대해 자세히 알아보세요.","ogImage":{"url":"/assets/img/2024-05-12-ExploringReactNativeDevelopmentExpovsReactNativeCLI_0.png"},"coverImage":"/assets/img/2024-05-12-ExploringReactNativeDevelopmentExpovsReactNativeCLI_0.png","tag":["Tech"],"readingTime":4},{"title":"2024년에 React, Vite, Electron, 그리고 FastAPI로 Full-Stack 애플리케이션 만들기","description":"","date":"2024-05-12 22:52","slug":"2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024","content":"\n\n![이미지](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_0.png)\n\n이 포괄적인 가이드에서는 React, Vite, Electron 및 FastAPI를 활용하여 간단한 풀스택 애플리케이션을 설정하는 방법을 안내해 드릴 거에요. 이 튜토리얼을 완료하면 단일 명령어로 시작되는 기능적인 애플리케이션을 보유하게 되며 로컬 개발 및 테스트에 적합할 거에요.\n\n# 개요\n\n이 애플리케이션 아키텍처는 아래와 같이 통합될 것입니다:\n\n\n\n- ReactJS: 사용자 인터페이스를 구축하기 위한 강력한 라이브러리.\n- Vite: 웹 프로젝트용 현대적이고 빠른 빌드 도구.\n- Electron: 웹 기술로 크로스 플랫폼 데스크톱 앱을 빌드하는 프레임워크.\n- FastAPI: Python으로 API를 빌드하기 위한 효율적이고 고성능 프레임워크.\n\n# 시스템 디자인 개요\n\n아래 다이어그램은 시스템 아키텍처를 설명합니다:\n\n![Architecture Diagram](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_1.png)\n\n\n\n다음은 각 구성 요소 간 상호 작용을 보여주는 다이어그램입니다:\n\n- Electron Main Process: 라이프사이클 이벤트를 관리하고 브라우저 창을 생성합니다.\n- Electron Renderer Process: 브라우저 창 내에서 웹 프런트엔드를 실행합니다.\n- React Application: Vite를 통해 제공되는 UI를 제공합니다.\n- FastAPI Server: 백엔드 로직 및 데이터 관리를 처리합니다.\n\n# 애플리케이션 구조\n\n다음은 우리의 간단한 애플리케이션의 구조입니다:\n\n\n\n```js\nmy-project/\n│\n├── backend/\n│   ├── main.py            # FastAPI 애플리케이션\n│   └── requirements.txt   # Python 종속성\n│\n├── frontend/              # Vite 프로젝트 루트\n│   ├── main.jsx           # React 애플리케이션 진입점\n│   ├── App.jsx            # React 컴포넌트\n│   ├── App.module.css     # 스타일\n│   └── vite.config.js     # Vite 구성 설정\n│   └── package.json       # 프론트엔드 종속성을 위한 NPM 패키지 파일\n│\n├── electron/\n│   └── main.cjs           # Electron 메인 스크립트\n│   └── preload.cjs           # Electron 메인 스크립트\n│\n├── package.json           # Electron을 위한 루트 NPM 패키지 파일\n```\n\n# 환경 설정\n\n## 1. 가상 환경\n\n프로젝트 디렉토리에서 파이썬 가상 환경을 만들면 전역 파이썬 환경과 별도로 파이썬 종속성을 관리할 수 있습니다.\n\n\n\nWindows:\n\n\n```js\npython -m venv venv\n.\\venv\\Scripts\\activate\n```\n\nmacOS/Linux:\n\n```js\npython3 -m venv venv\nsource venv/bin/activate\n```\n\n\n\n# 2. 종속성 설치\n\n백엔드 디렉토리에서 requirements.txt 파일을 추가하세요:\n\n```js\nfastapi==0.68.1\nuvicorn==0.15.0\n```\n\nPython 종속성을 설치하세요:\n\n\n\n```js\npip install -r backend/requirements.txt\n```\n\n## 3. 프론트엔드 및 일렉트론 설정\n\nVite를 사용하여 프론트엔드를 초기화하고 일렉트론을 구성합니다.\n\nVite 프로젝트를 초기화합니다 (프론트엔드 디렉토리 내부):\n\n\n\n```js\nnpm create vite@latest --template frontend\n```\n\nNode 의존성 패키지 설치:\n\n```js\nnpm install\n```\n\n# 4. 백엔드 서버\n\n\n\nfrontend/App.jsx:\n\n```jsx\nimport React from 'react';\n\nfunction App() {\n    return (\n        <div>\n            <h1>Welcome to the React Front-end!</h1>\n            <p>Your data:</p>\n            <table>\n                <tr>\n                    <th>Message</th>\n                </tr>\n                <tr>\n                    <td>Hello from FastAPI</td>\n                </tr>\n            </table>\n        </div>\n    );\n}\n\nexport default App;\n```  \n\n\n\n```js\nimport React, { useEffect, useState } from \"react\";\nimport styles from \"./App.module.css\"; // CSS 모듈 가져오기\n\nfunction App() {\n  const [data, setData] = useState(\"\");\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(\"http://localhost:8000/data\");\n        const jsonData = await response.json();\n        setData(jsonData.message);\n      } catch (error) {\n        console.error(\"데이터를 불러오는 도중 오류가 발생했습니다:\", error);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return (\n    <div>\n      <div>{data || \"로딩 중...\"}</div>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n스타일 추가:\nfrontend/App.module.css:\n\n```css\n.container {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100vh;\n  }\n  \n  .content {\n    text-align: center;\n    font-family: Arial, sans-serif;\n    background-color: #f0f0f0;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n}\n```\n\nfrontend/main.jsx:\n\n\n\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App.jsx\";\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n# 6. 일렉트론 구성\n\nelectron/main.cjs:\n\n```js\nconst { app, BrowserWindow } = require('electron');\nconst path = require('path');\n\nfunction createWindow() {\n    const mainWindow = new BrowserWindow({\n        width: 800,\n        height: 600,\n        webPreferences: {\n            preload: path.join(__dirname, 'preload.cjs'),\n            contextIsolation: true, // 보안을 위해 중요함\n            enableRemoteModule: false, // 보안 상 이유로 원격 모듈 비활성화\n            nodeIntegration: false // 보안 상 이유로 nodeIntegration 비활성화\n        }\n    });\n\n    // 로컬 웹 서버 URL 로드\n    mainWindow.loadURL('http://localhost:5173');\n\n}\n\napp.whenReady().then(createWindow);\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') {\n        app.quit();\n    }\n});\n```\n\n\n\nelectron/preload.cjs:\n\n```js\nconst { contextBridge, ipcRenderer } = require('electron');\n\n// 렌더러 프로세스에 노출할 안전한 API\ncontextBridge.exposeInMainWorld('api', {\n    send: (channel, data) => {\n        // 렌더러에서 메인 프로세스로 데이터를 보내기 위한 채널 화이트리스트\n        const validChannels = ['toMain'];\n        if (validChannels.includes(channel)) {\n            ipcRenderer.send(channel, data);\n        }\n    },\n    receive: (channel, func) => {\n        // 메인에서 렌더러 프로세스로 데이터를 수신하기 위한 채널 화이트리스트\n        const validChannels = ['fromMain'];\n        if (validChannels.includes(channel)) {\n            // 새 리스너를 추가하기 전에 채널에서 모든 리스너를 제거\n            // 이렇게 하면 여러 리스너가 등록되는 것을 방지\n            ipcRenderer.removeAllListeners(channel);\n            ipcRenderer.on(channel, (event, ...args) => func(...args));\n        }\n    }\n});\n```\n\n# 7. 통합 시작 명령\n\npackage.json을 업데이트하여 모든 서비스를 하나의 명령어로 시작하세요.\n\n\n\n```json\n{\n  \"name\": \"frontend\",\n  \"private\": true,\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"start\": \"concurrently \\\"npm run start-backend\\\" \\\"npm run start-frontend\\\" \\\"npm run start-electron\\\"\",\n    \"start-backend\": \"cd backend && uvicorn main:app --reload --host localhost --port 8000\",\n    \"start-frontend\": \"cd frontend && vite\",\n    \"start-electron\": \"electron electron/main.cjs\"\n  },\n  \"devDependencies\": {\n    \"vite\": \"^5.2.0\",\n    \"concurrently\": \"^7.0.0\"\n  }\n}\n```\n\n# 응용 프로그램 실행 방법\n\n응용프로그램을 실행하려면:\n\n```js\nnpm start\n```\n\n\n\n아래 명령어로 백엔드, 프론트엔드 및 일렉트론을 동시에 시작하여 즉시 애플리케이션을 확인할 수 있습니다.\n\n성공적인 터미널 출력은 다음과 같아야 합니다:\n\n![이미지](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_2.png)\n\n# 결과\n\n\n\nBrowser:\n\n![Browser screenshot](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_3.png)\n\nMacOS:\n\n![MacOS screenshot](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_4.png)\n\n\n\nWindows:\n\n![Windows](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_5.png)\n\n## 결론\n\n이 안내서는 최신 기술을 활용하여 개발 및 확장 가능한 제품 배포 모델에 이상적인 완전한 스택 애플리케이션을 구축하기 위한 간단한 로드맵을 제시합니다. 이 프레임워크는 소프트웨어 아키텍처의 최상의 실천 방법을 준수하며, 요소의 느슨한 결합과 손쉬운 유지 관리를 촉진합니다.\n\n\n\n여기서 전체 코드에 액세스하세요\n\n질문이 있으시면 언제든지 물어보세요.","ogImage":{"url":"/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_0.png","tag":["Tech"],"readingTime":7},{"title":"React Context와 TypeScript를 마스터하기 포괄적인 튜토리얼","description":"","date":"2024-05-12 22:51","slug":"2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial","content":"\n\n친절한 톤으로 한국어로 번역하면 다음과 같습니다.\n\n\"이 글에서는 TypeScript를 사용하여 더 가독성이 좋고 쉽게 이해할 수 있으며 최신 best practice에 맞는 React 컨텍스트를 만드는 과정을 안내하겠습니다. React 컨텍스트는 컴포넌트 트리의 모든 수준을 통해 props를 전달하지 않고 상태 데이터를 관리하고 공유할 수 있는 방법을 제공합니다.\n\nReact Context 설정 방법\n\n먼저, React Context API를 사용하여 기본 값이 null인 컨텍스트를 생성해봅시다.\"\n\n\n\n기본값을 null로 설정한 이유에 대해 궁금할 수 있습니다. 이 선택은 곧 명백해질 목적이 있습니다.\n\n콘텍스트 제공자 생성하기\n\n다음은 우리가 콘텍스트 제공자를 구성하는 방법입니다:\n\n![Context Provider Structure](/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_1.png)\n\n\n\n제공된 코드 스니펫에서 useMemo의 사용을 알 수 있을 것입니다. 여기서의 목적은 context 값이 각 렌더링마다 변경되지 않도록 똑똑하게 저장하는 것입니다. 이 과정을 통해 컨텍스트가 다시평가될 때 불필요한 변경을 방지합니다.\n\n조금 더 자세히 살펴보죠: 애플리케이션의 표시가 컨텍스트 제공자 내부 업데이트로 인해 변경되는 경우를 상상해보세요. 이러한 경우에는 컨텍스트 객체를 재설정하는 것이 합리적입니다. 그러나 부모 구성 요소의 상태 변경과 같은 외부 요소에서 업데이트가 발생하는 경우도 고려해야 합니다. 이러한 시나리오에서 매번 새 객체를 만드는 것은 과도합니다. 최적화된 방식을 통해 이러한 비제공자 유발 렌더 중에는 불필요한 객체 재생성을 방지합니다.\n\n매 렌더링마다 객체를 재생성하는 것에 대해 왜 걱정해야 하는지 의문이 생길 수 있는 데요? 사실, 많은 경우에는 이것이 심각한 문제처럼 보이지 않을 수 있습니다. 그러나 더 깊이 파고들면, 이러한 실천은 예기치 못한 버그로 이어질 수 있습니다. 예를 들어, 컨텍스트 값 객체가 useEffect 훅 내에서 종속성으로 사용될 때 관련 문제가 발생할 수 있습니다. 객체 참조 일관성을 유지함으로써 우연한 다시 렌더링으로 인한 잠재적인 이상 현상을 우회합니다. 이러한 전략적 기동이 결국 코드베이스의 견고성과 안정성에 기여합니다.\n\n커스텀 훅을 사용한 컨텍스트 소비 최적화\n\n\n\n내용을 이해하기 위해 커스텀 훅을 만들 것입니다. 이 접근 방식은 모듈화 및 코드 가독성을 높이는 데 도움이 됩니다.\n\n![마크다운](/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_2.png)\n\n이 조각에서는 useMessageContext라는 커스텀 훅을 생성하여 컨텍스트의 사용을 캡슐화하고 있습니다. 이를 통해 두 가지 중요한 목표를 달성합니다:\n\n- 모듈화: 커스텀 훅은 컨텍스트 사용의 세부 정보를 추상화하여 관리 및 재사용을 쉽게 만듭니다. 응용 프로그램 전체에서 컨텍스트 소비 방법을 변경해야 할 경우, 한 곳에서 수행할 수 있습니다.\n- 명확성과 가독성: 일반적인 useContext 대신 useMessageContext를 사용함으로써 더 구체적인 의미 체계를 제공하여 코드를 이해하기 쉽게 만듭니다. 코드베이스에서 작업하는 사람은 누구나 컨텍스트 소비의 목적을 빠르게 파악할 수 있습니다.\n\n\n\n여기 useMessageContext 훅이 의존하는 useContextWrapper 함수의 구현 내용입니다:\n\n![이미지](/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_3.png)\n\n이 useContextWrapper 함수는 추가적인 오류 처리 레이어를 추가합니다. 해당 프로바이더가 제대로 제공되지 않으면, 명료하고 유익한 오류 메시지가 표시되어 개발자가 효과적으로 문제를 해결할 수 있도록 안내됩니다.\n\n마무리하며\n\n\n\n이 가이드라인을 따라가면 효율적이고 유지보수가 쉬운 TypeScript를 사용한 잘 구조화된 React 컨텍스트를 만들 수 있습니다. 컨텍스트 프로바이더를 올바르게 설정하고 유형을 정의하며 사용자 지정 후크를 통해 컨텍스트를 소비하는 것은 더 견고하고 확장 가능한 애플리케이션에 기여할 것입니다.\n\n![이미지](/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_4.png)\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_0.png","tag":["Tech"],"readingTime":3},{"title":"이벤트 루프가 뭐죠 자바스크립트 비동기 프로그래밍 탐구","description":"","date":"2024-05-12 22:50","slug":"2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming","content":"\n\n\n![이미지](/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png)\n\n자바스크립트는 본질적으로 싱글 스레드입니다. 그렇다면 프라미스와 비동기 메서드를 어떻게 처리할까요? 그것들을 어떻게 병렬로 실행할까요? 답은 명확하지 않을 수 있습니다. 자바스크립트 비동기 프로그래밍을 탐구해봅시다...\n\n# 정교하고 효율적인 아키텍처\n\n자바스크립트는 이벤트 루프, 태스크 큐 및 마이크로태스크 큐를 결합하여 싱글 스레드 언어가 비동기 작업을 수행할 수 있도록 정교하고 효율적인 아키텍처를 갖추고 있습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_1.png\" />\n\n## 예시를 살펴보겠습니다...\n\n```js\n// 메소드-1\nconsole.log(\"A\");\n\n// 메소드-2\nsetTimeout(()=>{\n  console.log(\"B\");\n},100);\n\n// 메소드-3\nsetTimeout(()=>{\n  console.log(\"C\");\n},0);\n\n// 메소드-4\nconsole.log(\"D\");\n\n/***\n*\n* 출력:\n* ADCB\n*\n***/\n\n```\n\n- 실행이 시작되면 각 메소드 호출이 실행을 위해 CallStack에 들어갑니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_2.png\" />\n\n- 즉시 결과를 제공할 수 있는 메서드(동기 메서드)가 실행됩니다. 비동기 메서드의 콜백은 해당 Web API로 넘어갑니다.\n\n<img src=\"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_3.png\" />\n\n- 메서드 1과 4는 즉시 반환되고, 메서드 2와 3은 실행 시간이 되었을 때 TaskQueue로 푸시하기 위해 setTimeout API로 넘어갑니다.\n- 타이머가 0일 때 메서드 3이 Task Queue로 푸시되고, 타이머가 100일 때 메서드 4가 그 뒤를 이어 실행됩니다.\n- 그리고 나중에 Task Queue에 있는 각 메서드가 자유 시간이 되면 실행을 위해 호출 스택으로 이동됩니다. 이것이 Javascript가 비동기 메서드를 처리하는 방식입니다.\n\n\n\n## MicroTask Queue이 하는 일은 무엇인가요…?\n\n- MicroTask Queue은 Promise에서의 콜백을 처리하는 전용 큐입니다.\n- MicroTask Queue에 있는 콜백은 Task Queue에서의 작업보다 우선순위가 높기 때문에, Task Queue에서의 작업은 MicroTask Queue의 작업이 모두 Call Stack으로 이동한 후에만 Call Stack으로 이동됩니다. 언제 큐에 도착했느냐에 관계없이 그렇습니다.\n\n# 결론\n\n이벤트 루프의 개념은 JavaScript를 더 동적이고 유연하게 만들어 주었습니다. JavaScript가 일 스레드인 한에서 비동기 프로그래밍을 수행하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png"},"coverImage":"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png","tag":["Tech"],"readingTime":2},{"title":"React에서 페이지 이동, 새로고침할 때 상태 유지하는 5가지 방법","description":"","date":"2024-05-12 22:49","slug":"2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact","content":"\n## 페이지 새로 고침 간에 React 상태 유지하는 다양한 방법 배우기\n\n![이미지](/assets/img/2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact_0.png)\n\n# 1. LocalStorage 사용하기 — 클래스 컴포넌트\n\n가장 간단한 방법 중 하나는 브라우저의 localStorage를 사용하여 상태를 유지하는 것입니다. 예제를 살펴보겠습니다.\n\n우리 주(state)에 count가 있습니다. 이제 페이지를 새로고침해도 이 count 값을 유지하고 싶다면, localStorage를 사용하면 됩니다.\n\n보시다시피, 이제 setState 메소드를 호출할 때마다 state 값을 저장합니다. 이것은 우리가 원하는 바를 달성하기 위한 간단한 방법입니다.\n\n우리는 클래스 컴포넌트를 살펴봤으므로, 함수형 컴포넌트에서는 어떻게 할지 살펴봅시다.\n\n# 2. LocalStorage 사용하기 — 함수형 컴포넌트\n\n먼저, 우리는 클래스 기반 컴포넌트를 함수형 컴포넌트로 변환할 것입니다.\n\n이제 우리가 상태를 유지하기 위해 localStorage를 추가하는 방법을 살펴봅시다.\n\n여기서 함수형 컴포넌트에 대한 약간 다른 접근 방식을 취했다는 것을 알 수 있습니다. useEffect 훅을 사용하여 두 가지 작업을 수행합니다.\n\n- 변경 사항을 추적하고 LocalStorage를 업데이트합니다.\n- 초기화시 LocalStorage에서 저장된 값을 검색합니다.\n\n# 3. Redux 저장소에서 LocalStorage 사용하기\n\n컴포넌트 수준에서 상태를 localStorage에 저장하는 한 가지 문제는 동일한 컴포넌트의 여러 인스턴스가 있는 경우입니다. 이는 localStorage에 중복 된 키를 만들어 예상치 못한 동작을 일으킬 수 있습니다.\n\n이 문제를 해결하기 위해서는 다음과 같은 방법이 있습니다.\n\n- 재사용 가능한 컴포넌트에 ID를 전달하고 이를 사용하여 localStorage에 값을 저장합니다.\n- 또는 상위 수준에서 상태를 지속시킵니다.\n\n만약 Redux를 사용한다면, 앱 상태를 localStorage에 유지하기 위해 사용할 수 있습니다.\n\n먼저, 수동으로 그것을 어떻게 할지 살펴보고, 그런 다음에는 우리를 위해 처리해줄 라이브러리인 \"Redux Persist\"를 사용하여 어떻게 할지 확인해보겠습니다.\n\n여기서는 스토어 업데이트를 구독하고 localStorage에 지속시킴으로써 구현할 수 있습니다. 그리고 앱을 초기화할 때 localStorage로부터 초기 상태를 전달할 수 있습니다.\n\n# 4. Redux Persist 사용하기\n\n수동으로 상태를 지속 및 초기화하는 대신 라이브러리를 사용할 수 있습니다.\n\n보시다시피, Redux Persist에서 persistReducer를 사용하여 persistStore를 저장하고 초기화할 수 있습니다.\n\n# 5. URL 파라미터 사용\n\n가장 명백한 방법이지만, URL 파라미터를 사용하여 상태를 지속하는 방법을 살펴봅시다. 이 접근 방식은 URL 길이 제한으로 인해 데이터가 간단하고 직접적인 원시 값인 경우에 적합합니다.\n\n만약 코드를 자세히 살펴보면, 상태를 브라우저 히스토리에 추가하고 컴포넌트를 초기화할 때 URL 매개변수에서 초기 값을 가져온다는 점입니다.\n\n여기서 중요한 장점 중 하나는 리로드 시 상태를 유지하고 브라우저 뒤로 가기 버튼을 사용하여 이전 상태로 이동할 수 있다는 것입니다.\n\n# 결론\n\n간단한 경우에는 URL 매개변수를 사용할 수 있습니다. 데이터가 조금 더 복잡한 경우에는 localStorage에 저장하는 것이 좋습니다. localStorage 접근 방법을 사용하면 컴포넌트 레벨 또는 앱 레벨에서 상태를 유지할 지를 결정할 수 있습니다.\n\n간단하게 하려면, Redux Persist와 같은 라이브러리를 사용하여 앱 상태를 영구 저장하고 다시 구성하는 방법이 있습니다.\n\n그러나 선택한 옵션에 상관없이 상태 변경을 철저히 관리하는 것도 중요합니다. 한 번 상태가 설정되면 새 릴리스에서 상태 관련 코드를 수정하면 일부 사용자에게 애플리케이션을 망가뜨릴 수도 있습니다.\n\n읽어 주셔서 감사합니다. 그리고 댓글 섹션에서 어떻게 생각하시는지 꼭 알려주세요. 🤔\n\n## 리액트 앱을 레고처럼 재사용 가능한 컴포넌트로 구축해보세요\n\n![이미지](/assets/img/2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact_1.png)\n\nBit의 오픈 소스 도구는 250,000명 이상의 개발자들이 컴포넌트로 앱을 구축하는 데 도움을 줍니다.\n\n어떤 UI, 기능 또는 페이지든지 재사용 가능한 컴포넌트로 변환하고 애플리케이션 간에 공유할 수 있습니다. 협업하기가 더 쉽고 빠르게 빌드할 수 있습니다.\n\n→ 자세히 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 쉽고 편안하게 만들고 원하는 작업 흐름에 최고의 경험을 누리세요:\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포\n\n## 자세히 알아보기\n","ogImage":{"url":"/assets/img/2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact_0.png"},"coverImage":"/assets/img/2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact_0.png","tag":["Tech"],"readingTime":3}],"page":"124","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}