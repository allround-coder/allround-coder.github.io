{"pageProps":{"posts":[{"title":"모든 개발자가 알아야 할 5가지 커스텀 React Hooks","description":"","date":"2024-05-12 19:25","slug":"2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow","content":"\n\n경력 있는 ReactJS 개발자로서, 애플리케이션을 개발하는 동안 다양한 도전과 성공을 경험해왔어요. 여행을 하면서 저는 코드의 재사용성과 효율성을 향상시키기 위해 사용자 정의 React 훅에 많은 의존을 하게 되었어요. 이 글에서는 모든 개발자가 알아야 할 다섯 가지 사용자 정의 React 훅을 공유하고 싶어요. 각 훅을 하나씩 살펴보며 예시를 제시하고 제 경험도 함께 공유할 거에요.\n\n![이미지](/assets/img/2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow_0.png)\n\n\n# useLocalStorage\n\n브라우저 스토리지 관리는 React 애플리케이션에서 흔한 요구사항입니다. useLocalStorage 훅을 사용하면 값을 localStorage와 동기화할 수 있어요. 최근 프로젝트에서 이를 어떻게 활용했는지 예시를 보여드릴게요:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nconst useLocalStorage = (key, defaultValue) => {\n  const [value, setValue] = useState(() => {\n    const storedValue = localStorage.getItem(key);\n    return storedValue ? JSON.parse(storedValue) : defaultValue;\n  });\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n  return [value, setValue];\n};\n```\n\n이 훅 안에서는 상태 값을 로컬 스토리지에 저장된 값이나 제공된 기본 값으로 초기화합니다. 값이 변경될 때마다 스토리지를 업데이트하기 위해 useEffect를 사용합니다. 컴포넌트에서 이렇게 사용할 수 있습니다:\n\n```js\nconst App = () => {\n  const [name, setName] = useLocalStorage('name', 'John Doe');\n\n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <p>Hello, {name}!</p>\n    </div>\n  );\n};\n```\n\n# useMediaQuery\n\n\n\n\n지금은 애플리케이션을 반응형으로 만들어서 다양한 화면 크기에 적응하는 것이 중요합니다. useMediaQuery 훅을 사용하면 리액트에서 미디어 쿼리를 쉽게 처리할 수 있습니다. 저는 이를 어떻게 활용했는지의 예시를 보여드리겠습니다:\n\n```js\nimport { useState, useEffect } from 'react';\n\nconst useMediaQuery = (query) => {\n  const [matches, setMatches] = useState(\n    () => window.matchMedia(query).matches\n  );\n  useEffect(() => {\n    const mediaQuery = window.matchMedia(query);\n    const handleChange = (e) => setMatches(e.matches);\n    mediaQuery.addEventListener('change', handleChange);\n    return () => {\n      mediaQuery.removeEventListener('change', handleChange);\n    };\n  }, [query]);\n  return matches;\n};\n```\n\n이 예시에서는 이벤트 리스너와 matchMedia를 사용하여 미디어 쿼리의 변경 사항을 추적하고 있습니다. 다음은 컴포넌트에서 이를 사용하는 방법입니다:\n\n```js\nconst App = () => {\n  const isMobile = useMediaQuery('(max-width: 768px)');\n\n  return (\n    <div>\n      <h1>{isMobile ? '모바일 뷰' : '데스크톱 뷰'}</h1>\n    </div>\n  );\n};\n```\n\n\n\n# useDebounce\n\nDebouncing은 일정 시간 동안의 작업 실행을 지연시키는 기술입니다. useDebounce 훅을 사용하면 어떤 값을 디바운스할 수 있습니다. 아래는 예시입니다:\n\n```js\nimport { useState, useEffect } from 'react';\n\nconst useDebounce = (value, delay) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n};\n```\n\n이 훅을 사용하면 사용자 입력, API 요청 등을 디바운스할 수 있습니다. 다음은 실용적인 예시입니다:\n\n\n\n```js\n상태로써 App을 만들었어요. \nsearchTerm이란 상태와 setSearchTerm 함수를 만들었고, debouncedSearchTerm은 searchTerm을 500 밀리초로 지연시키는 함수를 사용하고 있어요.\n\nuseEffect 안에서는 debouncedSearchTerm을 감시하며 API 호출을 수행합니다.\n\n<input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />\n\n# useFetch\n\n비동기적으로 데이터를 가져오는 것은 현대 웹 개발에서 흔한 작업입니다. 이를 간단하게 처리해주는 useFetch 훅을 알아봅시다.\n\nimport { useState, useEffect } from 'react';\n\nconst useFetch = (url) => {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(true);\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        const json = await response.json();\n        setData(json);\n      } catch (error) {\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n  return { data, error, loading };\n};\n\n\n\n이 훅은 fetch 요청의 복잡성을 추상화하고 응답, 오류 및 로딩 상태를 제공합니다. 이 훅을 사용하는 방법은 다음과 같습니다:\n\nconst App = () => {\n  const { data, error, loading } = useFetch('https://api.example.com/data');\n\n  if (loading) {\n    return <p>데이터 불러오는 중...</p>;\n  }\n  if (error) {\n    return <p>오류 발생: {error.message}</p>;\n  }\n  return (\n    <div>\n      <ul>\n        {data.map((item) => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\n# useToggle\n\n토글 및 부울 상태를 관리하는 것은 때로는 복잡해질 수 있습니다. useToggle 훅을 사용하면 부울 상태를 쉽게 다룰 수 있습니다. 여기에 간단한 구현 방법이 있습니다:\n\n\n\nimport { useState } from 'react';\n\nconst useToggle = (initialValue = false) => {\n  const [value, setValue] = useState(initialValue);\n  const toggle = () => {\n    setValue((prevValue) => !prevValue);\n  };\n  return [value, toggle];\n};\n\n이 훅은 상태를 토글하는 프로세스를 간단하게 해줍니다. 아래는 사용 예시입니다:\n\nconst App = () => {\n  const [isModalOpen, toggleModal] = useToggle(false);\n\n  return (\n    <div>\n      <button onClick={toggleModal}>모달 토글</button>\n      {isModalOpen && <Modal />}\n    </div>\n  );\n};\n\n# 결론\n\n\n\n커스텀 React 훅은 개발 경험을 혁신적으로 향상시킬 수 있는 강력한 도구입니다. 이 글에서는 useLocalStorage, useMediaQuery, useDebounce, useFetch, 그리고 useToggle이라는 다섯 가지 커스텀 훅을 탐구했습니다. 이러한 훅을 활용하여 제 코드베이스를 최적화하고 코드 재사용성을 높이며 고품질 애플리케이션을 제공할 수 있었습니다. 여러분이 이 훅들을 저만큼 유용하게 느끼셨으면 좋겠네요. 즐거운 코딩 되세요!\n\n이 문서가 유용하다고 생각되면 박수를 치는 것을 고려해보세요. 한 번에 50번까지 박수를 칠 수 있어요!\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나기 전에:\n\n\n\n- 작가를 박수로 격려해주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":6},{"title":"React Nextjs에서 Boxicons 사용하는 방법","description":"","date":"2024-05-12 19:24","slug":"2024-05-12-BoxiconsReactNextjsTypeScriptIntegration","content":"\n<img src=\"/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_0.png\" />\n\n박스 아이콘(Boxicons)은 많은 오픈 소스 아이콘을 제공하여 웹사이트나 애플리케이션에 원활하게 통합할 수 있도록 도와주는 패키지입니다. 이 패키지는 JavaScript로 작성되어 있으며 온라인 저장소에 TypeScript 정의 파일이 없습니다. 이는 TypeScript 프로젝트에 통합하기가 조금 어렵다는 것을 의미합니다. 이 글은 React/Next.js TypeScript 프로젝트에 박스 아이콘을 통합하는 단계별 가이드를 제공합니다.\n\n# Next.JS\n\n## 1. 프로젝트 설정\n\n다음 명령어를 실행하여 Next.js 애플리케이션을 시작하세요.\n\n```js\nnpx create-next-app@latest\n```\n\n프로젝트에 이름을 지정하고 설치 프롬프트에서 기본 옵션을 선택하세요.\n\n```js\n프로젝트 이름은 무엇인가요? boxicons-nextjs-ts\nTypeScript를 사용하시겠습니까? No / Yes\nESLint를 사용하시겠습니까? No / Yes\nTailwind CSS를 사용하시겠습니까? No / Yes\n`src/` 디렉토리를 사용하시겠습니까? No / Yes\nApp Router를 사용하시겠습니까? (추천) No / Yes\n기본 import 별칭을 사용자 지정하시겠습니까? No / Yes\n구성할 import 별칭을 입력해주세요. @/*\n```\n\n다음은 프로젝트 구조가 설정된 Next.js 애플리케이션의 시작 코드를 생성해야 합니다.\n\n![Next.js Starter Code](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_1.png)\n\n## 2. 의존성 설치\n\nBoxicons 설치하기\n\n```js\nnpm install boxicons --save\n```\n\n## 3. 유형 정의\n\n“src\" 디렉토리에 “types\" 폴더를 만들고 그 안에 “boxicons.d.ts\"라는 파일을 생성하세요. 이 파일은 boxicons 패키지의 유형 정의를 담고 있을 것입니다. 다음 코드 스니펫을 \"boxicons.d.ts\" 파일에 붙여넣으세요.\n\nsrc/types/boxicons.d.ts\n\n```js\ndeclare module \"boxicons\" {\n  export type IconName = string;\n}\n```\n\n위의 코드 조각에서 boxicons 패키지를 위한 모듈 선언을 생성합니다. TypeScript가 모듈을 가져올 때 해당 모듈을 해결할 수 있도록 합니다. 또한, \"IconName\"이라는 문자열 타입이 내보내집니다. 이를 통해 아이콘 이름이 모두 문자열임을 보장하고, 발생 가능한 일부 버그를 미리 방지합니다.\n\n## 4. 스타일시트 임포트\n\n프로젝트에 boxicons 스타일시트를 추가하세요. 이는 애플리케이션의 메인 스타일시트 맨 위에 CSS import를 추가하여 수행할 수 있습니다. 기본적으로 Next.js의 \"src/pages\" 디렉토리에 있는 \"global.css\" 파일이 메인 애플리케이션 스타일시트입니다.\n\n동일한 결과를 얻으려면 \"src/pages\" 디렉토리의 \"layout.tsx\" 파일에 헤드 태그에 링크 태그를 추가하면 됩니다.\n\nsrc/pages/layout.tsx\n\n```js\nimport type { Metadata } from \"next\";\nimport { Inter } from \"next/font/google\";\nimport \"./globals.css\";\n\nconst inter = Inter({ subsets: [\"latin\"] });\n\nexport const metadata: Metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode,\n}>) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <link href=\"https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css\" rel=\"stylesheet\"></link>\n      </head>\n      <body className={inter.className}>{children}</body>\n    </html>\n  );\n}\n```\n\nOR\n\nsrc/pages/globals.css\n\n```js\n@import \"~boxicons/css/boxicons.min.css\";\n# OR\n@import url(\"boxicons/css/boxicons.min.css\");\n```\n\n## 5. 아이콘 컴포넌트 생성\n\n애플리케이션에 다양한 \"boxicons\"를 가져올 수 있는 아이콘 컴포넌트를 생성하세요. 이를 위해 \"src\" 디렉터리에 \"components\"라는 폴더를 만들고 그 안에 \"Icon.tsx\" 파일을 만드세요.\n\nsrc/components/Icon.tsx\n\n```js\nimport React from \"react\";\nimport { IconName } from \"boxicons\";\n\ninterface IconProps {\n  name: IconName;\n  size?: string;\n  color?: string;\n}\n\nconst Icon: React.FC<IconProps> = ({ name, size = \"24px\", color = \"\" }) => {\n  return <i className={`bx ${name}`} style={{ fontSize: size, color }} />;\n};\n\nexport default Icon;\n```\n\n`name` 속성은 표시할 아이콘을 변경하는 데 사용됩니다. 사용할 수 있는 모든 아이콘을 확인하려면 boxicons 웹 사이트를 확인하십시오. `size` 및 `color` 속성은 각각 아이콘의 크기 및 색상을 변경하는 데 사용됩니다.\n\n컴포넌트 디렉토리의 내용을 내보내는 \"index.ts\" 파일을 만듭니다. 이는 가져오기를 \"깔끔하게\" 유지하기 위한 것이며, 이 단계를 건너 뛰어도 괜찮습니다.\n\nsrc/components/index.ts\n\n```js\nimport Icon from \"./Icon\";\n\nexport { Icon };\n```\n\n## 6. Icon 사용법\n\n프로젝트 전반에 걸쳐 사용하기 위해 components 디렉토리에서 Icon 컴포넌트를 import합니다. 아래는 예시입니다:\n\nsrc/pages/pages.tsx\n\n```js\nimport { Icon } from \"@/components\";\n\nexport default function Home() {\n  return (\n    <main className=\"flex min-h-screen flex-col items-center justify-center py-24 gap-3\">\n      <Icon name=\"bx-run\" size=\"108px\" />\n      <h2 className=\"text-6xl\">함께 떠나요</h2>\n      <div className=\"flex mt-4 gap-3\">\n        <Icon name=\"bx-rocket\" size=\"64px\" />\n        <Icon name=\"bx-rocket\" size=\"64px\" />\n      </div>\n    </main>\n  );\n}\n```\n\n개발 서버를 실행하여 아이콘이 표시되는지 확인해 보세요.\n\n```js\nnpm run dev\n```\n\nViolaaa 🚀\n\n![image](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_2.png)\n\n이 프로젝트의 소스 코드가 포함된 GitHub 저장소 링크입니다:\n\n[https://github.com/Quarcoo-arc/boxicons-nextjs-ts.git](https://github.com/Quarcoo-arc/boxicons-nextjs-ts.git)\n\n# React\n\nReact와 TypeScript 프로젝트에 boxicons를 통합하는 것은 Next.js와 TypeScript 프로젝트에 통합하는 것과 유사합니다. 그러나 몇 가지 차이가 있습니다. 이를 아래에서 강조했습니다.\n\n## 1. 프로젝트 설정\n\nReact 프로젝트를 설정하는 가장 쉬운 방법은 create-react-app 또는 Vite를 사용하는 것입니다. 저는 Vite를 선호합니다. 왜냐하면 이름이 시사하는 대로 빠르기 때문입니다. Vite는 \"신속\"을 뜻하는 프랑스어 단어이며 /vit/으로 발음합니다. 충분히 어휘적인 얘기는 여기까지 하고 아이콘들을 표시해봅시다 🚀.\n\n다음 명령어를 실행하여 Vite를 사용한 React + TypeScript 프로젝트를 시작하세요:\n\n```js\nnpm create vite@latest\n```\n\n프로젝트 이름 (boxicons-react-ts), 프레임워크 (React), 그리고 변형 (TypeScript)을 옵션에 설정하세요. 프로젝트 디렉토리로 이동하고 애플리케이션 종속성을 설치하세요.\n\n```js\ncd boxicons-react-ts\nnpm install\n```\n\n위 명령들을 실행하면 다음과 같은 폴더 구조를 갖는 프로젝트가 생성됩니다.\n\n![폴더 구조](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_3.png)\n\n## 2. 종속성 설치\n\nboxicons를 설치하세요. Next.JS 부분의 두 번째 섹션에 설명된 대로 진행하시면 됩니다.\n\n## 3. 유형 정의\n\nReact 및 Next.js에 대한 유형 정의 파일을 생성하는 방법은 동일합니다.\n\n## 4. 스타일시트 가져오기\n\nNext.js와 마찬가지로 React에서 boxicons 스타일시트를 가져오는 두 가지 옵션이 있습니다; head 태그 내부에 링크 태그를 사용하거나 CSS를 가져오는 것입니다. 차이점은 src/pages/layout.tsx가 아닌 프로젝트의 루트 디렉토리의 index.html 파일에 링크 태그가 추가된다는 점입니다. 또한 CSS를 가져오는 위치는 src/pages/globals.css가 아닌 React 애플리케이션의 기본 주 스타일시트인 src/index.css에 위치합니다.\n\n한 가지 더 알려드릴게요. 이 CSS import를 사용하면 오류가 발생합니다:\n\n```js\n# 오류가 발생합니다 ❌\n@import \"~boxicons/css/boxicons.min.css\";\n```\n\n이것을 대신 사용하세요:\n\n```js\n# 이것을 대신 사용하세요 ✅\n@import url(\"boxicons/css/boxicons.min.css\");\n```\n\n```css\n@import url(\"https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css\");\n```\n\n## 6. 아이콘 사용법\n\n이제 아이콘 컴포넌트를 가져와 프로젝트 전반에 사용할 수 있습니다. 아래에서 확인할 수 있습니다.\n\nsrc/App.tsx\n\n```jsx\nimport \"./App.css\";\nimport { Icon } from \"./components\";\n\nfunction App() {\n  return (\n    <div>\n      <Icon name=\"bxl-typescript\" size=\"36px\" />\n      <Icon name=\"bx-plus\" size=\"36px\" />\n      <Icon name=\"bxl-react\" size=\"36px\" />\n      <h1>We go again</h1>\n      <Icon name=\"bx-rocket\" size=\"36px\" />\n      <Icon name=\"bx-rocket\" size=\"36px\" />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n개발 서버를 실행해서 아이콘들을 확인해보세요.\n\n```js\nnpm run dev\n```\n\n![아이콘 이미지](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_4.png)\n\n이 프로젝트의 소스 코드가 포함된 GitHub 저장소 링크입니다:\n\n위의 링크를 통해, React/Next.js + TypeScript 프로젝트에서 boxicons를 사용할 준비가 끝났어요. TypeScript 프로젝트에서 typings이 제공되지 않는 JavaScript 패키지를 사용하는 방법도 비슷하게 따를 수 있어요.\n","ogImage":{"url":"/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_0.png"},"coverImage":"/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_0.png","tag":["Tech"],"readingTime":7},{"title":" 당신의 React 프로젝트를 위한 전화 입력 - react-international-phone","description":"","date":"2024-05-12 19:23","slug":"2024-05-12-PhoneinputforyourReactprojectreact-international-phone","content":"\n\n## React 코드베이스에 멋진 국제 전화번호 입력 컴포넌트를 구현해보세요\n\n## 배경 이야기\n\n저는 React를 UI 빌딩 라이브러리로 사용하는 내 작업 프로젝트 중 하나에서 휴대전화 번호를 입력하는 컴포넌트를 구현하는 문제를 마주쳤어요. 사용하던 한 인기 있는 전화 입력 라이브러리를 사용하는 컴포넌트가 있었지만, 스타일링하기 불편하고 작업하기도 어려웠어요.\n\n일부 npm 패키지를 조사한 후, 제 요구 사항을 충족시키는 라이브러리가 없다는 것을 알게 되었어요:\n\n\n\n- 전화 번호 형식은 모든 입력 구성 요소에 쉽게 통합할 수 있어야 합니다 (Material UI, Chakra UI, Ant Design 등과 같은 모든 UI 프레임워크와 통합 가능).\n- 쉽게 스타일링할 수 있는 독립적인 전화 번호 입력 구성 요소를 제공해야 합니다.\n- 입력 시 편안한 느낌이어야 합니다. 입력 캐럿 위치가 제대로 처리되어야 하며, 복사/붙여넣기/실행 취소/다시 실행이 예상대로 작동해야 합니다.\n- 입력된 전화 번호를 확인할 수 있는 방법을 제공해야 합니다.\n\n그래서 이러한 기능을 모두 지원하는 내 라이브러리를 작성하기로 결정했습니다.\n\n# react-international-phone\n\n🎉 react-international-phone을 소개합니다! 🎉\n\n\n\n라이브러리는 React 애플리케이션용 전화 입력 컴포넌트를 제공합니다. 국제 지원을 포함한 전화 번호를 위한 사용자 정의 가능하고 쉽게 사용할 수 있는 입력 필드를 제공합니다.\n\n![전화 입력 컴포넌트](https://miro.medium.com/v2/resize:fit:642/1*4NHcF2JMyXfeqVlCRJD9PQ.gif)\n\nreact-international-phone의 주요 기능:\n\n- 🌈 입력란 내에서 타이핑, 복사/붙여넣기, 실행취소/다시실행이 자연스럽게 작동\n- 🔍 전화 번호 형식(국가 추측과 함께)\n- 🏁 국가 깃발 렌더링(Twemoji와 함께)\n- ✅ 기본 제공 전화 유효성 검사\n- 🔒 제3자 의존성 없음(낮은 번들 크기)\n- 🔧 쉽게 사용자 정의 가능합니다\n\n\n\n## 기본 사용법\n\n이 라이브러리는 통합하기 매우 쉽습니다. PhoneInput 컴포넌트와 스타일을 가져오기만 하면 됩니다. 다음은 기본 사용법 코드 스니펫입니다:\n\n```js\nimport { useState } from 'react';\nimport { PhoneInput } from 'react-international-phone';\nimport 'react-international-phone/style.css';\n\nconst App = () => {\n  const [phone, setPhone] = useState('');\n\n  return (\n    <div>\n      <PhoneInput\n        defaultCountry=\"ua\"\n        value={phone}\n        onChange={(phone) => setPhone(phone)}\n      />\n    </div>\n  );\n};\n```\n\nCodeSandbox에서 라이브 데모를 확인하세요\n\n\n\n## UI 라이브러리 통합\n\nreact-international-phone은 Material UI, Ant Design, 또는 Chakra UI와 같은 거의 모든 기존 UI 라이브러리와 통합할 수 있습니다.\n\n보통 사용하는 입력 필드와 함께 전화 번호 형식 지정 로직을 제공하는 usePhoneInput 훅을 사용하고, 국가 선택 드롭다운을 제공하는 `CountrySelector/` 하위 구성 요소를 함께 사용할 수 있습니다.\n\nMUI, Chakra, 그리고 Antd를 사용한 라이브러리 사용 예제가 있습니다:\n\n\n\n## ✔️ 유효성 검사\n\n이 패키지는 (당연히) 전화번호 유효성 검사를 제공하는 usePhoneValidation 훅을 제공합니다.\n\n```js\nconst [phone, setPhone] = useState(\"\");\nconst phoneValidation = usePhoneValidation(phone);\n\n// 이제 `phoneValidation.isValid`를 사용하여 전화번호가 유효한지 확인할 수 있습니다\n```\n\n## 🔧 사용자 정의\n\n\n\n라이브러리는 전화 입력의 기본 동작과 모양을 사용자 지정하는 방법을 제공합니다. 다음은 가능한 작업의 일부입니다:\n\n- 프롭 또는 CSS를 통해 `PhoneInput/` 컴포넌트의 어떤 부분에도 사용자 정의 스타일 적용\n- 다이얼 코드 강제 (선택된 국가 다이얼 코드를 삭제/변경하지 못하도록 함)\n- 국가 선택기 드롭다운 숨기기\n- 초기 국가 자동 입력 비활성화\n- 국가 다이얼 코드 숨기기\n- 국가 목록 필터링 및 수정\n\n이러한 사용 사례의 데모를 이 스토리북에서 확인할 수 있습니다:\nhttps://react-international-phone-storybook.vercel.app/\n\n## 📚 문서\n\n\n\n아래에 전체 설명서를 찾을 수 있습니다:\nhttps://react-international-phone.vercel.app/\n\n## 🌟 감사합니다\n\nreact-international-phone 패키지가 마음에 드시면 GitHub 저장소에 별을 남겨주세요.\n문제, 버그, 또는 질문이 있으면 GitHub에 이슈를 열거나 토론을 해주세요.\n\n도움이 되었다면 박수를 잊지 마세요!\n즐거운 코딩하세요 👋","ogImage":{"url":"/assets/img/2024-05-12-PhoneinputforyourReactprojectreact-international-phone_0.png"},"coverImage":"/assets/img/2024-05-12-PhoneinputforyourReactprojectreact-international-phone_0.png","tag":["Tech"],"readingTime":3},{"title":"ESLint 구성 이해 eslintrcjs 대 eslintrc 대 eslintrcjson","description":"","date":"2024-05-12 19:22","slug":"2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson","content":"\n\nESLint은 JavaScript 생태계에서 중심 도구로 작용하여 개발자가 코드 품질을 유지하고 코딩 표준을 준수할 수 있도록 돕습니다. 그러나 ESLint를 구성하는 것이 항상 간단하지는 않습니다, 특히 .eslintrc.js, .eslintrc 및 .eslintrc.json과 같은 다양한 구성 형식 중에서 선택해야 할 때에는 더욱 그렇습니다. 각 형식의 세부 사항을 자세히 살펴보고 그 차이와 가장 적합한 사용 사례에 대해 알아봅시다.\n\n# .eslintrc.js 해석하기\n\n.eslintrc.js는 JavaScript 파일로, JavaScript 코드를 사용하여 ESLint를 동적으로 구성할 수 있는 구성 객체를 익스포트합니다. 이 형식은 복잡한 로직과 환경별 구성을 설정에 포함시킬 수 있는 가장 탁월한 유연성을 제공합니다.\n\n다음은 .eslintrc.js 파일이 어떻게 보일 수 있는지 한 눈에 들어보세요:  \n\n\n\n<img src=\"/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_0.png\" />\n\n# JSON 형식의 .eslintrc 탐구하기\n\n.eslintrc는 ESLint 구성을 캡슐화하는 JSON 형식의 파일입니다. .eslintrc.js와 달리 이 형식은 JavaScript 표현식이나 동적 로직을 지원하지 않습니다. 더 단순하고 선언적인 설정 방식을 제공합니다.\n\n다음은 .eslintrc 파일의 예시입니다:\n\n\n\n\n![이미지](/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_1.png)\n\n# .eslintrc.json 이해하기\n\n.eslintrc.json은 .eslintrc와 유사하게 ESLint 구성을 JSON 형식으로 제공합니다. 파일 이름 규칙이 다르지만 동일한 목적을 제공합니다. 두 형식 모두 대부분의 프로젝트에서 간편하게 사용할 수 있도록 간결하고 사용이 간편합니다.\n\n![이미지](/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_2.png)\n\n\n\n# 비교: 적합한 옵션 찾기\n\n- 유연성: .eslintrc.js는 유연성 면에서 우수하며, 개발자들이 동적 논리를 포함하고 다양한 환경에 기반한 구성을 맞춤 설정할 수 있습니다.\n\n- 간결함: .eslintrc 및 .eslintrc.json은 더 간단하고 직관적인 방식으로, 표준 구성 요구 사항을 갖는 프로젝트에 이상적입니다.\n\n- 커뮤니티 표준: .eslintrc.js가 복잡한 설정에 선호되는 반면, .eslintrc 및 .eslintrc.json은 간단한 구성에 선호되며, 커뮤니티 표준에 부합합니다.\n\n# 결론: 개발 실무 능력 강화\n\nESLint 구성 형식 선택은 프로젝트 복잡도와 팀 선호도에 달려 있습니다. .eslintrc.js는 뛰어난 유연성을 제공하나, .eslintrc 및 .eslintrc.json은 대부분의 프로젝트에 대한 간소화된 옵션을 제공합니다. 이 차이를 이해하면 개발자들이 ESLint를 효과적으로 구성하여 일관된 코드 품질을 유지할 수 있습니다.\n\n\n\n본질적으로, 당신의 선호 및 프로젝트 요구 사항에 따라 ESLint 구성 형식을 선택합니다. 그럼에도 불구하고, .eslintrc.js의 동적 성격은 복잡한 설정과 전문화된 구성에 대한 매력적인 선택으로 작용합니다.\n\n# 인사이트 공유\n\n당신이 선호하는 ESLint 구성 형식은 무엇이며, 그 이유는 무엇인가요? 프로젝트에 ESLint를 구성하는 동안 어려움을 겪은 적이 있나요? 혹은 혜택을 본 적이 있나요? 아래 댓글에서 당신의 경험과 인사이트를 공유해주세요!","ogImage":{"url":"/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_0.png"},"coverImage":"/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_0.png","tag":["Tech"],"readingTime":2},{"title":"React 및 Framer Motion을 사용하여 무한 아이콘 슬라이더 구현하기","description":"","date":"2024-05-12 19:21","slug":"2024-05-12-ImplementinganInfiniteIconSliderinReactwithFramerMotion","content":"\n\n무한 슬라이더는 웹 개발에서 인기 있는 UI 패턴으로, 이미지나 기타 미디어와 같은 콘텐츠를 연속적인 루프로 표시하는 데 사용됩니다. 무한 슬라이더의 핵심 원칙은 콘텐츠 항목의 집합을 중단 또는 간격 없이 매끄럽게 순환하면서 부드럽고 중단되지 않는 뷰잉 경험을 만드는 것입니다.\n\n잘 디자인된 슬라이더는 멋진 모던한 미적 감각을 유지하면서 상당한 양의 정보를 단일 구성 요소로 압축할 수 있습니다. 이는 사용자 참여를 향상시키고 웹 페이지에서 공간을 최적화하는 데 탁월한 도구로, 특히 시각적 영향이 필수적인 포트폴리오, 전자 상거래 사이트 및 뉴스 플랫폼에서 매우 유용합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*fEvCBFUBUUM-HggRUqK1tQ.gif)\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*Nz6dhLM2nwazz_7vTR_2rg.gif)\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*XQuY6aY78mpNcJ7C8mtZ4Q.gif\" />\n\n이 글은 무한 슬라이더를 만드는 기초와 기본 사항을 안내합니다. 30분 이상 YouTube 비디오를 시청하는 것보다 더 효율적인 학습 방법을 제공합니다. 이 튜토리얼을 마치면 이 기능을 구현하는 방법 뿐만 아니라 코드를 선호에 따라 사용자 정의하고 향상시킬 수 있는 방법을 이해할 수 있습니다.\n\n# 전제 조건\n\n시작하기 전에 다음 사항을 준비해야 합니다:\n\n\n\n- 리액트 프로젝트 설정이 완료되었습니다.\n- Tailwind 의존성이 설치되었습니다. npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p\n- Framer Motion 이 설치되었습니다. npm install framer-motion\n- Radix 아이콘 패키지가 설치되었습니다. npm install @radix-ui/react-icons\n\n![Icon Slider](/assets/img/2024-05-12-ImplementinganInfiniteIconSliderinReactwithFramerMotion_0.png)\n\n# 무한 슬라이더 구현하기\n\n# 단계 1: 기본 슬라이더 만들기\n\n\n\nSliderNumber.jsx\n\n```js\nimport React from 'react';\nimport { motion } from 'framer-motion';\n\n// 숫자로 된 슬라이드 배열 정의\nconst slides = [\n    { number: 1 },\n    { number: 2 },\n    { number: 3 },\n    { number: 4 },\n    { number: 5 },\n];\n\nconst SliderNumber = () => {\n    // 신속한 루핑을 보장하기 위해 슬라이드 배열을 복제합니다.\n    const duplicatedSlides = [...slides, ...slides];\n\n    return (\n        <div className=\"relative w-full overflow-hidden\">\n            {/* 신속한 루핑을 위한 래핑 div */}\n            <motion.div\n                className=\"flex\"\n                animate={{\n                    x: ['-100%', '0%'],\n                    transition: {\n                        ease: 'linear',\n                        duration: 5,\n                        repeat: Infinity,\n                    },\n                }}\n            >\n                {/* 복제된 슬라이드 렌더링 */}\n                {duplicatedSlides.map((slide, index) => (\n                    <div key={index} className=\"flex-shrink-0\" style={{ width: `${100 / slides.length}%` }}>\n                        <div className=\"flex flex-col items-center justify-center h-full text-6xl\">\n                            {slide.number}\n                        </div>\n                    </div>\n                ))}\n            </motion.div>\n        </div>\n    );\n};\n\nexport default SliderNumber;\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*gFdYciuJgTYyJj2evLgauw.gif)\n\nFramer Motion의 강력한 애니메이션 기능과 몇 줄의 코드만으로 무한 슬라이더의 기반을 마련했습니다.\n\n\n\n해설:\n\n- 슬라이드 배열: 표시할 슬라이드를 나타내는 간단한 배열입니다. 각 슬라이드는 숫자를 포함하는 객체입니다.\n- 중복된 슬라이드: 무한 루프 효과를 얻기 위해 슬라이드 배열이 복제됩니다. 이 복제는 한 세트의 슬라이드가 보이는 영역을 벗어나면 동일한 세트가 나타나도록하여 끝없는 싸이클을 만드는 환상을 창출합니다.\n- Motion Div: Framer Motion에서 제공하는 애니메이션을 담당하는 래퍼 div입니다. animate 속성은 콘텐츠를 100% (오른쪽에서 약간 벗어난 위치에서 시작)에서 0% (뷰포트를 채우는 위치)로 수평으로 이동하도록 구성되어 있습니다. 전환은 선형 팽창으로 설정되며, 반복 횟수는 무한대(Infinity)이며, 지속 시간은 5초입니다.\n- 슬라이드 렌더링: 각 슬라이드(원본 및 복제본 모두)는 자체 div 내에 렌더링되며, 전체 슬라이드 수에 대한 비율에 따라 너비가 제어됩니다. 이를 통해 슬라이더 내에서 각 슬라이드가 수평 공간의 동일한 부분을 차지하도록 합니다.\n\n이 기본 설정은 추가 스타일, 상호작용 요소 또는 다양한 콘텐츠 유형과 함께 확장하고 사용자 참여를 향상시킬 수 있는 다양한 애플리케이션에 적합한 다목적 구성 요소로 사용할 수 있습니다. 이미지, 텍스트 또는 동적 콘텐츠를 표시하든, 이 무한 슬라이더는 사이트에서 사용자 참여를 높이는 현대적이고 세련된 솔루션으로 제공됩니다.\n\n더 멋진 것을 만들어 봅시다!\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*fEvCBFUBUUM-HggRUqK1tQ.gif\" />\n\n# 단계 2: 고급 아이콘 슬라이더 생성하기\n\n슬라이더에 깊이와 주목을 끌기 위한 효과적인 방법 중 하나는 아이콘이 뷰포트에 들어오거나 빠져나갈 때 페이드 인 및 페이드 아웃 효과를 적용하는 것입니다. 이는 슬라이더 구성 요소의 가장자리에 흐릿한 효과를 적용하여 달성할 수 있습니다.\n\nSliderDesign2.jsx\n\n\n\n```js\r\nimport React from 'react';\nimport { motion } from 'framer-motion';\nimport {\n    FigmaLogoIcon,\n    FramerLogoIcon,\n    SketchLogoIcon,\n    TwitterLogoIcon,\n    GitHubLogoIcon,\n    VercelLogoIcon,\n    NotionLogoIcon,\n    DiscordLogoIcon,\n    InstagramLogoIcon,\n    LinkedInLogoIcon,\n} from \"@radix-ui/react-icons\";\n\nconst slides = [\n    { icon: <FigmaLogoIcon /> },\n    { icon: <TwitterLogoIcon /> },\n    { icon: <GitHubLogoIcon /> },\n    { icon: <InstagramLogoIcon /> },\n    { icon: <LinkedInLogoIcon /> },\n    { icon: <DiscordLogoIcon /> },\n    { icon: <SketchLogoIcon /> },\n    { icon: <NotionLogoIcon /> },\n    { icon: <VercelLogoIcon /> },\n];\n\n\n\nconst SliderDesign2 = () => {\n    const duplicatedSlides = [...slides, ...slides];\n\n    return (\n        <div className=\"relative h-full overflow-hidden py-12 bg-white mx-auto\" style={ width: \"50%\" }>\n\n            <div className=\"absolute inset-0 z-20 before:absolute before:left-0 before:top-0 before:w-1/4 before:h-full before:bg-gradient-to-r before:from-white before:to-transparent before:filter before:blur-3 after:absolute after:right-0 after:top-0 after:w-1/4 after:h-full after:bg-gradient-to-l after:from-white after:to-transparent after:filter after:blur-3\"></div>\n\n            <motion.div\n                className=\"flex\"\n                animate={\n                    x: ['0%', '-100%'],\n                    transition: {\n                        ease: 'linear',\n                        duration: 15,\n                        repeat: Infinity,\n                    }\n                }\n            >\n                {duplicatedSlides.map((slide, index) => (\n                    <div key={index} className=\"flex-shrink-0\" style={ width: `${100 / slides.length}%` }>\n                        <div className=\"flex items-center justify-center h-full\">\n                            {slide.icon}\n                        </div>\n                    </div>\n                ))}\n            </motion.div>\n        </div>\n    );\n};\n\nexport default SliderDesign2;\r\n```\n\n이 고급 슬라이더 설정은 웹페이지에서 로고나 아이콘을 더 상호작용적이고 시각적으로 매력적으로 표현하는 방법을 제공하여, 포트폴리오, 회사 페이지 또는 브랜드 가시성이 중요한 모든 응용 프로그램에 이상적입니다.\n\n이제 무한 슬라이더가 작동하는 방법을 이해했으니, 여러분들만의 디자인을 시작해보세요!\n\n전체 디자인을 다운로드할 수 있는 GitHub을 확인해보세요!\r\n","ogImage":{"url":"/assets/img/2024-05-12-ImplementinganInfiniteIconSliderinReactwithFramerMotion_0.png"},"coverImage":"/assets/img/2024-05-12-ImplementinganInfiniteIconSliderinReactwithFramerMotion_0.png","tag":["Tech"],"readingTime":6},{"title":"Vite React 앱을 Azure App Service에 CI CD 파이프라인GitHub Actions을 사용하여 배포하는 방법","description":"","date":"2024-05-12 19:18","slug":"2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions","content":"\n\n개인 React 프로젝트를 시작하거나 제품용 대규모 웹 애플리케이션을 구축하든, React 앱을 호스팅하는 다양한 옵션이 많습니다. 최근에 Azure를 좀 더 전문적으로 다뤄보면서, Vite + React 앱을 Azure에 배포하고 CI/CD 파이프라인을 통해 성공적으로 실행 및 지속적으로 배포하는 방법을 공유하고 싶었어요.\n\n시작하기 전에 다음 사항을 필요로 합니다:\n\n- 활성 구독이 있는 Microsoft Azure 계정\n- 시스템에 최신 Node LTS (v18.16.1 현재 버전)이 설치되어 있어야 합니다\n- GitHub 계정\n\n다음과 관련해서 편안해야 해요:\n\n\n\n- Bash/Zsh을 사용한 명령 줄\n- Git\n- npm, yarn, pnpm과 같은 모든 Node 패키지 관리 시스템\n- YAML: [YAML이란 무엇인가요? - 초보자를 위한 안내서](https://circleci.com/blog/what-is-yaml-a-beginner-s-guide/)\n- Azure 포털: [Azure 포털](https://portal.azure.com/)\n\n시작하기 전에, 제목에서 언급된 중요한 개념 몇 가지를 먼저 명확히해 보겠습니다: Azure App Service 및 CI/CD 파이프라인.\n\n# Azure App Service란\n\nAzure App Service는 웹 앱, RESTful API 및 모바일 백엔드를 호스팅하기 위한 Azure의 플랫폼 서비스(PaaS)입니다. GitHub Actions를 사용한 지속적인 배포를 포함한 내장된 DevOps 기능도 제공됩니다.\n\n\n\nAzure App Service에는 Web App, Web App + Database 및 Static Web App이라는 세 가지 서비스 옵션이 있어요.\n\n![Azure App Service](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_0.png)\n\n이 세 가지 옵션의 이름은 자명해요. Static Web App Service의 중요한 점은 백엔드 API 측면에서 제약 사항이 있다는 것이에요: https://learn.microsoft.com/en-us/azure/static-web-apps/apis-overview#constraints.\n\n백엔드 API를 사용하는 정적 웹사이트를 디플로이할 때 Azure Functions만 사용한다면 Static Web App을 사용해도 문제가 없어요. 공식 Vite 문서에는 Azure Static Web App으로의 배포 방법에 대한 안내가 있어요: https://vitejs.dev/guide/static-deploy.html#azure-static-web-apps\n\n\n\n그러나 더 복잡한 사용 사례의 경우, 웹 앱 또는 Web 앱 + 데이터베이스를 사용하고 싶을 것입니다. 저는 웹 앱 서비스를 사용하고 있지만 귀하의 요구에 가장 적합한 것을 선택할 수 있습니다.\n\n# CI/CD란 무엇인가요?\n\nCI는 지속적인 통합(Continuous Integration)을 의미하고, CD는 지속적인 전달 및 배포(Continuous Delivery and Continuous Deployment)를 의미합니다. CI/CD는 소프트웨어를 유연한 환경에서 빈번한 배포를 보장하는 데 중요한 프로세스입니다.\n\n지속적인 통합(CI)은 새 코드 변경사항을 자동으로 공유 저장소에 통합하는 프로세스입니다. 이는 \"우리는 새로운 코드 변경을 만들었는데, 그것을 기존 코드베이스에 어떻게 통합할까요?\"라는 질문에 대답합니다.\n\n\n\n지속적 전달과 지속적 배포 (CD)는 보통 함께 그룹화되지만, 두 가지를 구별하는 것이 중요합니다:\n\n지속적 전달은 테스트, 버그 확인, 통합된 코드 변경이 언제든지 저장소에서 프로덕션으로 이동할 수 있는 자동화된 프로세스를 가지는 것을 의미합니다. 이는 \"우리는 변경 사항을 저장소에 통합했는데, 이제 어떻게 효율적으로 작업물을 전달할까?\"라는 질문에 대응합니다.\n\n지속적 배포는 저장소에서 프로덕션으로의 배포 프로세스를 자동화하는 것을 의미합니다. 이는 \"우리는 작업물을 전달했는데, 이제 어떻게 배포해서 최종 사용자가 경험할 수 있게 할까?\"라는 질문에 대응합니다.\n\nCI/CD 파이프라인은 소프트웨어를 빌드, 테스트하고 프로덕션으로 릴리스하는 자동화된 프로세스이며, 이 프로세스를 돕는 여러 도구들이 있습니다.\n\n\n\nGitHub Actions은 GitHub의 자체 CI/CD 플랫폼으로, 빌드, 테스트 및 배포 파이프라인을 GitHub 내에서 자동화할 수 있습니다. 2018년에 출시된 이후로 개발자들 사이에서 인기를 얻고 있습니다. 이전에 CircleCI와 같은 다른 CI/CD 플랫폼을 사용해본 적이 있다면, GitHub Actions를 사용하는 것이 쉬울 것입니다.\n\nCI/CD에 처음 접하는 경우 걱정하지 마세요. 나중에 이 글에서 워크플로우 설정에 대해 자세히 설명하겠습니다. GitHub Actions를 사용하여 애플리케이션을 테스트하고 빌드하며, 코드 변경이 main 브랜치에 푸시될 때마다 Azure App Service에 배포하는 배포 워크플로우를 설정하는 방법을 배울 수 있을 것입니다.\n\n# 단계별 가이드\n\n## Azure 포털을 통해 Azure 앱 서비스 만들기\n\n\n\n- 홈으로 이동하십시오 — 리소스 그룹 — 만들기.\n\n'앱이름'_dev로 이름을 지정한 리소스 그룹을 귀하의 지역에 만들고, 검토 + 생성을 클릭하세요. 이것은 우리의 개발 리소스 그룹이 될 것입니다. 필요하면 나중에 테스트 및 프로덕션 그룹을 만들 수도 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_1.png)\n\n2. 홈으로 이동하십시오 — 앱 서비스 — 만들기 — 웹 앱\n\n\n\n구독을 선택하고 방금 만든 같은 리소스 그룹을 선택하십시오:\n\n![image](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_2.png)\n\n다음과 같이 인스턴스 세부 정보를 입력하십시오:\n\n이름: 'your_app의_이름'\n\n\n\n발행: 코드\n\n런타임 스택: Node 18 LTS\n\n운영 체제: 리소스 그룹에 따라 Linux 또는 Windows를 선택하실 수 있습니다. 저는 여기서는 Linux를 선택했습니다.\n\n지역: 리소스 그룹과 동일한 지역\n\n\n\n가격제도: 당신만의 요금제를 선택하세요. 개인 프로젝트의 경우, 무료 F1 요금제가 충분할 것입니다.\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_3.png)\n\n모든 필드를 채운 후에는 배포를 구성하기 위해 다음을 클릭할 수 있습니다.\n\n만약 당신의 애플리케이션이 Windows에서 실행 중이라면, 직접 지속적인 배포를 설정할 수 있습니다. Azure는 Linux에서 F1 요금제로 실행 중인 앱에 대해 이 기능을 지원하지 않습니다. 걱정마세요, 앱 서비스가 생성된 후 지속적인 배포를 설정할 것입니다.\n\n\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_4.png)\n\n나머지 단계는 선택 사항입니다. 빠르게 \"검토 + 만들기\"로 이동할 수 있어요. 만들기를 클릭하면 앱 서비스 배포가 진행 중임을 확인할 수 있어요.\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_5.png)\n\n3. 배포가 완료되면 몇 분만 걸릴 것입니다. \"홈 - 앱 서비스\"로 이동하면 새로운 앱 서비스가 표시되며 확인할 수 있을 거예요.\n\n\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_6.png)\n\n브라우즈 버튼을 클릭하거나 다음 URL(https://'name_of_your_app'.azurewebsites.net)로 이동하여 아래 페이지를 확인할 수 있습니다. Azure에서 웹 앱에 대한 콘텐츠를 받지 못했다는 일반적인 문제 해결 페이지입니다.\n\n![다른 이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_7.png)\n\n그러니 이제 프로젝트를 배포하고 Azure에서 지속적인 배포를 설정해 봅시다.\n\n\n\n## 프로젝트 설정 (GitHub에서 이미 레포지토리를 가지고 있으면 이 부분을 건너뛰세요)\n\n이미 프로젝트를 설정한 적이 없다면, 이 섹션에서는 React 앱을 Vite를 사용하여 설정하는 방법을 보여드립니다. 저는 개인적으로 Microsoft 튜토리얼에서는 Create React App을 사용하는 경향이 있지만, Vite를 사용하는 것을 선호합니다.\n\n제 경험상, Vite 같은 빠른 빌드 도구를 사용하면 개발 프로세스를 가속화할 수 있어 개발자 경험을 향상시키고 응용 프로그램 구축에 더 집중할 수 있습니다. Vite의 테스트 러너 Vitest 역시 속도가 빠르며 빠른 피드백을 제공해주어 테스트 주도 개발(TDD)을 할 때 특히 큰 도움이 됩니다.\n\n일반적으로 사용하는 빌드 도구가 Create React App인 경우, 여러분이 평소처럼 React 애플리케이션을 구동시키세요.\n\n\n\nVite와 npm을 사용하는 경우, 다음 명령어로 새 React 애플리케이션을 만들 수 있어요:\n\n```js\nnpm create vite@latest\n```\n\nVite로 빌드하는 데 더 많은 정보를 원하시면 여기를 확인해 보세요: https://vitejs.dev/guide/\n\n프로젝트 이름을 입력하고, React를 선택하고, JavaScript/TypeScript를 선택하도록 프롬프트를 따라가세요.\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_8.png\" />\n\n이제 Vite가 마법을 부리며 프로젝트 구조를 설정할 것입니다. 완료되면 터미널에서 다음 명령어를 입력하세요:\n\n```js\ncd {name_of_your_app} # 프로젝트 디렉토리로 이동\nnpm install # 프로젝트 의존성 설치\nnpm run dev # 개발 모드에서 어플리케이션 실행. 기본적으로 5173포트에서 실행됩니다.\n```\n\nhttp://localhost:5173으로 이동하여 방금 생성한 React 프로젝트를 확인하세요.\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_9.png\" />\n\n지금 깃허브에서 새 저장소를 생성하고 프로젝트 코드를 모두 커밋해주세요. 그럼 GitHub Actions를 사용하여 Azure App Service로 배포할 수 있게 됩니다.\n\n## GitHub Actions를 활용한 지속적 배포\n\nAzure App Service는 BitBucket, GitHub, Local Git, 그리고 Azure Repos와 같은 다양한 플랫폼과의 연속적 배포를 통합할 수 있습니다.\n\n\n\n깃허브 액션을 사용하여 Azure로 배포하는 두 가지 방법이 있습니다. 이 방법 중 하나는 앱 서비스 배포 센터를 사용하는 것입니다. Azure는 배포 센터를 사용하는 방법에 대해 자세한 안내를 제공하고 있습니다: [링크](https://learn.microsoft.com/en-us/azure/app-service/deploy-github-actions?tabs=applevel#use-the-deployment-center)\n\n배포 센터를 사용하는 것이 빠르고 간단하긴 하지만, 처음으로 배포하는 경우에는 Azure가 워크플로 파일을 자동으로 생성하여 선택한 브랜치로 푸시하고, 이로 인해 워크플로 실행이 트리거됩니다. 처음 실행은 실패할 것입니다. 이는 워크플로 파일의 배포 경로가 루트 경로(\".\")로 설정되어 있고, GitHub 액션이 전체 소스 코드가 아닌 'dist' 폴더만을 배포하도록 시도하기 때문입니다.\n\n자동으로 생성된 파일의 다른 부분을 수정하여 워크플로에서 폐기된 액션을 사용하지 않도록 변경하고 싶을 것입니다.\n\n\n\n나는 필요하다면 배포 센터를 사용하는 대신에 나만의 워크플로 파일을 구성하는 것을 선호해요.\n\n이를 위해 프로젝트 루트 디렉토리에 .github/workflows/ 폴더를 만들고 main_'name_of_your_app'.yml로 명명된 다음의 워크플로 파일을 추가해주세요:\n\n```js\n# Azure Web Apps 배포 동작에 대한 문서: https://github.com/Azure/webapps-deploy\n# Azure를 위한 더 많은 GitHub Actions: https://github.com/Azure/actions\n\nname: Azure Web App로 Node.js 앱 빌드 및 배포 - {name_of_your_app}\n\n# 변경이 main 브랜치로 푸시될 때마다 워크플로를 실행합니다\non:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\n# 선택 사항: 여기서 환경 변수를 주입할 수 있습니다\n# 이러한 변수를 저장소 설정 - Secrets 및 변수 - Actions - 변수에 추가할 수 있어요\nenv:\n  VITE_ENV_VAR1: ${ env.VITE_ENV_VAR1 }\n  VITE_ENV_VAR2: ${ env.VITE_ENV_VAR2 }\n\n# 이 워크플로에는 빌드와 배포 두 가지 작업이 있습니다\njobs:\n # 애플리케이션을 프로덕션용으로 빌드합니다\n # 프로덕션 환경을 가능한 가깝게 구성해야 합니다. 예: 리눅스 앱에는 Ubuntu를 사용하고, 동일한 Node 버전을 사용하는 등\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Node.js 버전 설정\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18.x'\n\n      - name: 의존성 설치, 빌드 및 테스트\n        run: |\n          npm install\n          npm run build --if-present\n          npm run test --if-present\n         # 다른 스크립트가 구성되어 있다면 이곳에 추가해주세요. 예: linting, 포맷팅\n\n      - name: 배포 작업용 아티팩트 업로드\n        uses: actions/upload-artifact@v3\n        with:\n          name: node-app\n          path: dist # 배포 경로여야 합니다. 루트 경로가 아니에요\n \n # Azure로 애플리케이션 배포\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'Production'\n      url: ${ steps.deploy-to-webapp.outputs.webapp-url }\n\n    steps:\n      - name: 빌드 작업으로부터 아티팩트 다운로드\n        uses: actions/download-artifact@v3\n        with:\n          name: node-app\n\n      - name: 'Azure Web App로 배포'\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@v2\n        with:\n          app-name: {name_of_your_app}\n          slot-name: 'Production'\n          publish-profile: ${ secrets.AZUREAPPSERVICE_PUBLISHPROFILE } # 발행 프로필은 항상 Secrets에 저장되어야 합니다.\n          package: .\n```\n\n이 파일을 main 브랜치에 커밋하기 전에 Secrets와 환경 변수(있는 경우)를 구성해야 합니다. Secrets는 기본적으로 기밀 환경 변수입니다. 비밀이 생성되면 삭제하거나 덮어씌울 수 있지만 표시할 수는 없어요.\n\n\n\nAzure 게시 프로필에는 Azure 앱 서비스로 배포하는 데 필요한 기밀 정보가 포함되어 있습니다. 이는 민감한 데이터이므로 이를 비밀로 저장해야 합니다. 이후 워크플로에서 반복적으로 사용할 수 있습니다.\n\n게시 프로필을 얻기 위해 앱 서비스의 개요 페이지로 이동하고 게시 프로필 다운로드를 클릭할 수 있습니다.\n\n![게시 프로필 다운로드](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_11.png)\n\n다운로드한 파일의 내용을 복사하여 GitHub 시크릿의 값으로 다음 단계에서 사용할 수 있도록 합니다. 이제 Azure 포털을 떠나 GitHub 프로젝트 페이지로 다시 이동할 수 있습니다.\n\n\n\nSettings — Secrets and variables — Actions — secrets 에서 Secrets 및 변수를 추가할 수 있어요.\n\n![이미지1](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_12.png)\n\n![이미지2](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_13.png)\n\n그럼 다음 시크릿을 만들게요:\n\n\n\nAZUREAPPSERVICE_PUBLISHPROFILE='발행 프로필 내용'\n\n이제 모든 설정이 완료되었습니다. 워크플로 파일을 메인 브랜치에 푸시하면 GitHub의 작업 탭에서 워크플로 실행을 볼 수 있어야 합니다.\n\n워크플로가 성공적으로 실행된 경우, React 앱이 Azure에 배포된 것을 의미합니다.\n\n애플리케이션이 Windows에서 실행 중이라면, 축하합니다! 이제 https://'앱의_이름'.azurewebsites.net를 클릭하여 애플리케이션을 실행할 수 있어야 합니다.\n\n\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_14.png)\n\n## Linux를 사용하는 경우의 마지막 단계\n\nLinux를 사용하고 위의 모든 단계를 올바르게 따르셨서 Azure가 콘텐츠를 인식하지 않는 이유에 대해 궁금하실 수 있습니다:\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_15.png)\n\n\n\n이는 Linux에서 실행되는 응용 프로그램이 추가적인 시작 명령인 pm2 serve /home/site/wwwroot --no-daemon이 필요하기 때문입니다. 이를 추가하려면 Azure App Service 페이지로 이동하여 - 설정 - 구성 - 일반 설정 - 시작 명령으로 이동한 다음, pm2 serve /home/site/wwwroot --no-daemon을 붙여 넣고 저장하시면 됩니다.\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_16.png)\n\nPM2는 Linux에서 NodeJS 애플리케이션을 제공하고 관리할 수 있는 NodeJS 프로세스 관리자입니다. Azure App Service Linux의 Node.js 컨테이너에는 기본적으로 PM2가 설치되어 있으므로 기본적으로 CLI를 사용할 수 있습니다. App Service Linux에서 PM2를 사용하는 자세한 정보는 여기에서 확인할 수 있습니다: https://azureossd.github.io/2022/02/22/Using-PM2-on-App-Service-Linux/\n\n이제 https://'name_of_your_app'.azurewebsites.net으로 돌아가서 응용 프로그램이 성공적으로 제공되는 것을 확인할 수 있습니다.\n\n\n\n![image](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_17.png)\n\n여기에 있습니다. 이제 Azure App Service에서 호스팅되는 Vite + React 애플리케이션이 있습니다. 또한 코드 변경이 메인 브랜치로 푸시될 때마다 GitHub Actions가 워크플로를 실행하여 앱을 Azure로 테스트, 빌드 및 배포합니다.\n\nGitHub의 예제 프로젝트: https://github.com/d3v-g/medium-deploy-react-app","ogImage":{"url":"/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_0.png"},"coverImage":"/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_0.png","tag":["Tech"],"readingTime":11},{"title":"2024년 최신 React Native Expo용 보일러플레이트 라이브러리","description":"","date":"2024-05-12 19:16","slug":"2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024","content":"\n지금은 2024년입니다. 프로그래밍에서는 항상 우리가 선택할 수 있는 최신하이팅 라이브러리들이 있지만, 최신하이팅 라이브러리들이 항상 완벽하지는 않습니다.\n\n여러 해 전에 웹 개발자로써, 저는 네이티브 앱을 어떻게 시작할지 완전히 이해하지 못했습니다. 이 블로그에서는 나의 선택한 라이브러리들과 함께 새로운 React Native/Expo 앱을 어떻게 만들 것인지 보여드리겠습니다. React Native에서 새로운 개발자이며 시작점을 모르는 경우, 이 블로그가 도움이 될 것입니다.\n\n# Component Library\n\nReact Native 컴포넌트 라이브러리 중 인기 있는 것들은:\n\n- react-native-paper\n- react-native-elements\n- gluestack\n\nNpm trends: [https://npmtrends.com/native-base-vs-react-native-elements-vs-react-native-paper](https://npmtrends.com/native-base-vs-react-native-elements-vs-react-native-paper)\n\n![Image](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_0.png)\n\n이 모든 라이브러리들은 테마를 적용할 수 있고, 좋은 접근성 지원이 가능하며, 좋은 문서와 유사한 구성 요소 세트를 제공합니다.\n\n## 리액트 네이티브 엘리먼츠\n\n이 블로그를 작성하는 시점에서, 리액트 네이티브 엘리먼츠가 가장 많은 컴포넌트를 제공하고 있어요. 하지만, AirbnbRating, PricingCard 또는 SocialIcon 같은 몇몇 컴포넌트는 제 프로젝트에서 사용할 일이 없어 보여요.\n\n<img src=\"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_1.png\" />\n\n하지만, 이 라이브러리는 가장 유연한 테마 설정을 제공하는 것 같아요. 이 라이브러리를 사용하면 개발자들이 각 컴포넌트 유형에 맞게 테마를 사용자 정의할 수 있어요: https://reactnativeelements.com/docs/customizing#using-themeprovider.\n\n```js\nconst theme = createTheme({\n  components: {\n    [themeKey]: {\n      // ... props\n    },\n  },\n});\n```\n\n## react-native-paper\n\nreact-native-paper는 구글의 머티리얼 디자인을 따릅니다. 만약 머티리얼 디자인을 사용하는 웹사이트가 있다면, react-native-paper가 일관성을 제공해줍니다.\n\n<img src=\"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_2.png\" />\n\n\n## gluestack\n\ngluestack은 유틸리티 우선이에요. 이 말은 컴포넌트가 마진, marginTop, fontFamily와 같은 props를 가지고 있는 것을 의미해요. 반면에 react-native-paper와 react-native-elements는 하나의 스타일 prop만 사용해요.\n\n예를 들어, React Native에서 컴포넌트를 스타일링하기 위해 스타일 시트를 생성해야 해요:\n\n```js\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: \"#0891b2\",\n    paddingVertical: 16,\n    paddingHorizontal: 12,\n    borderRadius: 5,\n    alignSelf: \"center\",\n    width: 375,\n    maxWidth: \"100%\",\n  },\n});\n```\n\n그럼 컴포넌트에 스타일을 적용해야 해요: `View style='styles.topContainer'`.\n\n네이티브 베이스에서는 해당 컴포넌트의 속성에 간단히 추가할 수 있어요: `Box bg=\"primary.600\" py=\"4\" px=\"3\" borderRadius=\"5\" rounded=\"md\" width='375' maxWidth=\"100%\"`.\n\n## 제 의견 기반\n\n- react-native-paper\n\n새로운 프로젝트를 처음부터 시작하려는 신입 개발자라면, npm 다운로드 수가 가장 많아 커뮤니티가 크고, 웹에서 쉽게 사용할 수 있다는 이유로 react-native-paper를 선택할 것입니다.\n\n# CSS 유틸리티\n\nCSS 유틸리티 라이브러리는 flex, pt-4, text-center, rotate-90과 같은 미리 정의된 CSS 클래스 목록을 제공합니다.\n\n위에서 언급된 native-base는 유틸리티 중심 스타일링에 대해 언급되었습니다; 그러나 React Native용 tailwind나 tachyons와 유사한 CSS 유틸리티 라이브러리가 있을까요? 네, 있습니다.\n\n나 이전에 사용한 라이브러리들은:\n\n- Native Wind\n- react-native-style-tachyons\n\nNpm trends: [https://npmtrends.com/nativewind-vs-react-native-style-tachyons](https://npmtrends.com/nativewind-vs-react-native-style-tachyons)\n\n![이미지](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_3.png)\n\n## 내 주관적인 선택\n\n- 소규모 프로젝트: 내장 스타일링, 라이브러리 사용하지 않음\n- 대규모 프로젝트: Native Wind\n\n소규모 프로젝트의 경우 내장 스타일링이 충분할 것입니다. 대규모 프로젝트의 경우, 팀원들이 이미 Tailwind에 익숙하다면 Native Wind를 선택할 것입니다. 저는 이미 Tailwind 라이브러리에 익숙하며, 네이티브 프로젝트에 이 라이브러리를 사용하기 시작하는 것이 꽤 쉬웠습니다.\n\n# 네비게이션\n\n인기 있는 선택지는 다음과 같습니다:\n\n- react-router-native\n- @react-navigation/native\n- expo-router (Expo 전용)\n\nNpm trends: https://npmtrends.com/@react-navigation/native-vs-expo-router-vs-react-router-native\n\n![이미지](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_4.png)\n\n엑스포 전용 라이브러리로 expo-router가 있습니다. 이는 파일 기반 라우팅 규칙으로, Next.js를 떠올리게 합니다.\n\nReact 웹 개발자이면 아마 react-router에 익숙할 것입니다. 이의 네이티브 버전인 react-router-native도 있지만, 널리 사용되지는 않습니다.\n\n## 제 개인적인 선택\n\n- @react-navigation/native\n\n이 라이브러리는 이제 React-Native 네비게이션을 위한 주요 라이브러리로 거의 사용되고 있어요.\n\n# 상태 관리\n\n상태 관리를 위해 선택할 수 있는 라이브러리가 더 많이 있거나 라이브러리를 전혀 사용하지 않을 수도 있어요. 인기 있는 라이브러리는 다음과 같아요:\n\n- Redux\n- TanStack Query (또는 React Query로 더 잘 알려져 있어요)\n- Redux Toolkit Query (또는 RTK Query로 더 잘 알려져 있어요)\n- React Context (내장되어 있어 라이브러리가 필요하지 않아요)\n- MobX\n- Jotai\n- Recoil\n- XState\n\nNpm trends: https://npmtrends.com/@tanstack/react-query-vs-@xstate/react-vs-jotai-vs-mobx-vs-react-redux-vs-recoil\n\n![Screenshot](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_5.png)\n\n## 내 주관적인 선택\n\n- 친숙한 올드 Redux + TansSack Query\n\n이 두 개는 가장 인기 있는 것들 중 하나이고 많은 해 동안 사용되었습니다. 그것들은 방탄이며 개발자 커뮤니티도 넓게 보유하고 있어요.\n\nRedux와 Transack Query를 사용한 상태 관리하는 방법에 대한 나의 블로그 포스트를 확인해보세요:\n\n# Monorepo\n\n모노레포란 무엇인가요?\n\n여러 개의 React Native 앱이 필요하거나 웹 및 네이티브 앱 간에 공통 로직을 공유해야 한다면, 모노 저장소는 좋은 도구가 될 것입니다.\n\n이는 인기 있는 선택지들 중 하나로, 여기에는 다음이 포함됩니다:\n\n- yarn workspace\n- Lerna\n- Turborepo\n- @nx/react-native / @nxl/expo\n\n내 주관적인 의견은 @nx/react-native / @nx/expo입니다.\n\n내용을 표 기호(Markdown format)로 변경하면 아래와 같습니다.\n\nFor yarn workspace and Lerna, developers need to do their configuration and setup. Turborepo provides a starter app; however, it is locked to the Expo and Next.js tech stack; if developers want to use a different tech stack, they still need to do their configuration.\n\nFor new developers, @x/react-native and @nx/expo provide a good developer experience and documentation to start; nevertheless, it still gives developers flexibility on the tech stack. To start, run this command:\n\n\n# react-native\nnpx create-nx-workspace --preset=react-native\n\n# expo\nnpx create-nx-workspace --preset=expo\n\n\n# Summary\n\n새로운 React Native / Expo 앱을 만들 때 선택할 수 있는 라이브러리 목록입니다. 이 리스트는 유일한 선택지는 아닙니다.\n\n아름다운 React Native 앱을 만들어 봅시다.\n\n- 공식 @nx/expo 플러그인: https://nx.dev/packages/expo\n- 공식 @nx/react-native 플러그인: https://nx.dev/packages/react-native\n\n# 더 알아보기\n\n- 🧠 Nx 문서\n- 👩‍💻 Nx GitHub\n- 💬 Nx 커뮤니티 Slack\n- 📹 Nx 유튜브 채널\n- 🥚 무료 Egghead 강좌\n- 🚀 CI를 빠르게 실행\n","ogImage":{"url":"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_0.png"},"coverImage":"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_0.png","tag":["Tech"],"readingTime":6},{"title":"React에서 JWT 토큰을 로컬 스토리지에 저장하는 방법","description":"","date":"2024-05-12 19:15","slug":"2024-05-12-HowtostoreJWTTokeninLocalStorageforReact","content":"\n\n## 간단히 말해, JWT란 무엇인가요?\n\nJWT은 JSON Web Token의 약자입니다. 이것은 정보를 안전하게 JSON 객체로 파티 간에 전송하는 간결하고 자체 포함된 방법입니다. 웹 개발에서 인증 및 정보 교환에 일반적으로 사용됩니다.\n\n## 프론트엔드용 요약\n\n\n\n백엔드에서 관리되는 암호화된 JSON 객체로, 사용자 계정이 생성되거나 로그인할 때 Frontend로 전송됩니다. 이 토큰을 이용하면 사용자가 웹 서비스의 일부에 대한 권한/접속을 얻을 수 있습니다. 클라이언트 측에서 사용하기 위해 이를 Local storage, 세션 또는 쿠키에 저장할 수 있습니다 (각각에는 고유한 보안 문제가 있으니 더 자세히 알아보세요).\n\n또한 https://jwt.io/를 방문하여 토큰을 해독하고 내용을 확인할 수 있습니다.\n\n## 이 페이지는 이를 로컬 스토리지에 저장하는 내용입니다.\n\n토큰을 사용하면서, 성공적인 로그인 후에 액세스 토큰과 리프레시 토큰을 로컬 스토리지에 저장하려고 했습니다.\n\n\n\n개발자 도구를 열고 `Application -` Local storage를 클릭하면 저장소를 확인할 수 있습니다.\n\n# 실제 코드로 넘어가보겠습니다\n\n## 여기 styled-components를 사용하여 만든 Login.jsx 파일이 있습니다\n\n아직 토큰 기능 설정은 포함되어 있지 않습니다. 요소를 설정하고 Styled-components를 사용하여 스타일을 지정하는 방법의 기본 구조만 보여드립니다.\n\n\n\n만약 이와 같은 라이브러리를 사용한다면, 코드를 더 깔끔하고 효율적으로 작성할 수 있어요! 그러나 이 경우에는 React hook useState만을 사용했어요.\n\n```js\nimport React, { useState } from \"react\";\nimport { styled } from \"styled-components\";\n```\n\n```js\nexport const Login = () => {\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n \n  return (\n    <LoginContainer>\n      <h1>Login</h1>\n      <Form >\n        <label htmlFor=\"email\">Email</label>\n        <Input\n          type=\"email\"\n          id=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n        />\n        <label htmlFor=\"password\">Password</label>\n        <Input\n          type=\"password\"\n          id=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n        />\n        <Button>Login</Button>\n        <button>Logout</button>\n      </Form>\n    </LoginContainer>\n  );\n};\nconst LoginContainer = styled.section`\n  border: 1px solid black;\n  height: 400px;\n  width: 350px;\n  margin: 100px auto;\n  border-radius: 12px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-evenly;\n`;\nconst Form = styled.form`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-evenly;\n  height: 200px;\n`;\nconst Input = styled.input`\n  width: 240px;\n  height: 28px;\n  border-radius: 3px;\n  border-color: rgba(0, 0, 0, 0.2);\n  padding: 3px;\n`;\nconst Button = styled.button`\n  width: 200px;\n  border-color: rgba(0, 0, 0, 0.2);\n  height: 30px;\n  margin-top: 10px;\n  &:hover {\n    cursor: pointer;\n  }\n`;\n```\n\n# 로그인 페이지 스타일링 결과\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtostoreJWTTokeninLocalStorageforReact_0.png\" /> \n\n# handleSubmit 함수 생성\n\nhandleSubmit 함수를 만들어서 로그인 세부 정보를 서버로 전송했습니다(fetch는 아직 사용하지 않았습니다). e.preventDefault()를 사용하면 로그인 버튼을 클릭할 때 페이지가 새로고침되지 않도록 합니다.\n\n```js\nconst handleSubmit = (e) => {\n    e.preventDefault();\n}\n```\n\n\n\n```js\n// JSX\n<Form onSubmit={handleSubmit}>\n```\n\n## (handleSubmit 함수 추가) POST를 사용하여 데이터를 가져오고 헤더를 추가하기\n\n사용자 정보를 가져오기 위해 별도의 requestOptions 변수를 생성했습니다. 사용자 로그인이 성공하면 다음 작업을 수행합니다.\n\n- 사용자 이메일 및 비밀번호 입력 요소를 \" \"으로 초기화합니다.\n- console.log(data)를 사용하여 토큰을 검색합니다.\n- 접근 토큰 및 리프레시 토큰이 가져와졌음을 확인한 후, 구조분해 할당을 사용하여 이를 로컬 스토리지에 저장할 수 있습니다.\n- localStorage.setItem(\"_변수\", _저장값)\n- localStorage.getItem(\"_변수)\n\n\n\n```js\nconst handleSubmit = (e) => {\n    e.preventDefault();\n```\n\n```js\n    const requestOptions = {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        email: email,\n        password: password,\n      }),\n    };\n    fetch(INSERT_API_HERE, requestOptions)\n      .then((response) => response.json())\n      .then((data) => {\n        setEmail(\"\");\n        setPassword(\"\");\n        console.log(data);\n        // note using deconstructuring is better for cleaner code\n        const {access, refresh} = data.access_token;\n        localStorage.setItem(\"accessToken\", access);\n        localStorage.setItem(\"refreshToken\", refresh);\n      });\n    \n  };\n```\n\n마지막으로, CORS 오류와 같은 API 문제가 없다면 토큰이 로컬 스토리지에 저장되는 것을 확인할 수 있습니다. 로컬 스토리지는 브라우저의 개발자 도구를 통해 액세스할 수 있으며 “Application\"으로 이동하여 확인할 수 있습니다.\n\n이제 토큰이 있으므로 무엇을 할 수 있을까요? 영구적 로그인을 설정하거나, 헤더 UI를 사용자에 맞게 변경하거나, 인증된 클라이언트 페이지를 더욱 개선할 수 있습니다. 물론, 새로고침 시 네비게이션 바가 업데이트되지 않는 것을 방지하기 위해 Zustand 또는 Redux와 같은 상태 관리자를 사용하는 것이 좋습니다.\n\n\n\n당신은 여기에서 나의 persistent login 게시물에 대한 Zustand 설정을 확인할 수 있어요.\n\n# 추가: 로컬 스토리지 초기화\n\n```js\nconst handleLogout = () => {\n    localStorage.removeItem(\"accessToken\");\n    localStorage.removeItem(\"refreshToken\");\n    alert(\"토큰이 제거되었습니다\");\n};\n```\n\n```js\n<button onClick={handleLogout}>로그아웃</button>\n```\n\n\n\n여기에 전체 코드가 있습니다.\n\n```js\nimport React, { useState } from \"react\";\nimport { styled } from \"styled-components\";\nimport { Navigate } from \"react-router-dom\";\n```\n\n```js\nexport const Login = ({ login }) => {\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [navigate, setNavigate] = useState(false);\n  const LOGIN_URL = \"INSERT_YOUR_API\";\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const requestOptions = {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        email: email,\n        password: password,\n      }),\n    };\n    fetch(LOGIN_URL, requestOptions)\n      .then((response) => response.json())\n      .then((data) => {\n        setEmail(\"\");\n        setPassword(\"\");\n        setNavigate(true)\n        // console.log(data);\n        // note using deconstructuring is better for cleaner code\n        const {access, refresh} = data.access_token;\n        localStorage.setItem(\"accessToken\", access);\n        localStorage.setItem(\"refreshToken\", refresh);\n      });\n      \n  };\n  const handleLogout = () => {\n    localStorage.removeItem(\"accessToken\");\n    localStorage.removeItem(\"refreshToken\");\n    alert(\"Tokens have been removed\");\n  };\n  if (navigate) {\n    return <Navigate to=\"/signup\" />;\n  }\n  return (\n    <LoginContainer>\n      <h1>Login</h1>\n      <Form onSubmit={handleSubmit}>\n        <label htmlFor=\"email\">Email</label>\n        <Input\n          type=\"email\"\n          id=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n        />\n        <label htmlFor=\"password\">Password</label>\n        <Input\n          type=\"password\"\n          id=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n        />\n        <Button>Login</Button>\n        <button onClick={handleLogout}>Logout</button>\n      </Form>\n    </LoginContainer>\n  );\n};\nconst LoginContainer = styled.section`\n  border: 1px solid black;\n  height: 400px;\n  width: 350px;\n  margin: 100px auto;\n  border-radius: 12px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-evenly;\n`;\nconst Form = styled.form`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-evenly;\n  height: 200px;\n`;\nconst Input = styled.input`\n  width: 240px;\n  height: 28px;\n  border-radius: 3px;\n  border-color: rgba(0, 0, 0, 0.2);\n  padding: 3px;\n`;\nconst Button = styled.button`\n  width: 200px;\n  border-color: rgba(0, 0, 0, 0.2);\n  height: 30px;\n  margin-top: 10px;\n  &:hover {\n    cursor: pointer;\n  }\n`;\n```","ogImage":{"url":"/assets/img/2024-05-12-HowtostoreJWTTokeninLocalStorageforReact_0.png"},"coverImage":"/assets/img/2024-05-12-HowtostoreJWTTokeninLocalStorageforReact_0.png","tag":["Tech"],"readingTime":7},{"title":"인증 토큰 갱신 및 변경Nodejs, React - 파트 1","description":"","date":"2024-05-12 19:12","slug":"2024-05-12-RefreshAuthTokenRotationNodejsReactPart1","content":"\n\n<img src=\"/assets/img/2024-05-12-RefreshAuthTokenRotationNodejsReactPart1_0.png\" />\n\n요즘은 보안이 점점 중요해지고 있어요. 그래서 우리는 적어도 보안 문제와 팁 및 요령의 기본을 명확히 이해해야 해요. 많은 웹사이트들이 약한 인증을 가지고 있습니다. 심지어 귀하의 애플리케이션이 민감한 정보를 포함하지 않더라도, 단순히 이메일 주소만 가지고 있다 하더라도, 귀하의 사용자를 존중하고 최소한의 보안을 제공해야 해요. 이 글에서는 접근 및 새로 고침 토큰을 사용한 간단한 JWT 토큰 기반 인증 시스템을 보여드릴게요. 우리는 Node.js 백엔드, 프론트엔드에는 React, 그리고 MongoDB를 사용할 거에요. 이 기술들에 익숙하지 않다면, 이에 대해 좀 더 알아보고 시작하기 전에 시간을 내어 숙지해주세요. 그러나 JavaScript 기술과 기본 REST 지식이 있다면, 함께 이를 살펴보고 함께 파헤쳐보아요. :)\n\n우선 Node.js 백엔드를 설정하는 것부터 시작해봅시다. 먼저 Node 애플리케이션을 초기화하세요:\n\n```js\nnpm init\n```\n\n\n\n다음으로, Express를 설치해주세요:\n\n```js\nnpm install express\n```\n\n백엔드에서 사용할 파일 및 폴더 계층 구조는 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-12-RefreshAuthTokenRotationNodejsReactPart1_1.png)\n\n\n\n서버.js 파일을 생성해주세요:\n\n```js\nconst express = require(\"express\");\nconst port = 5000;\nconst app = express();\n\napp.listen(port, () => {\n  console.log(`포트 ${port}에서 서버 실행 중`);\n});\n```\n\n이제 앱을 위한 데이터베이스를 추가해볼까요? MongoDB를 설치하세요. 익숙하지 않다면 유용한 링크가 있습니다.\n\n```js\nnpm install mongoose\n```\n\n\n\n아래와 같이 데이터베이스 연결 파일을 생성해 주세요:\n\n```js\nconst mongoose = require(\"mongoose\");\n\nconst db = mongoose\n  .connect(\"mongodb://127.0.0.1/TokenRotation\") // TokenRotation은 데이터베이스 이름입니다\n  .then(() => console.log(\"MongoDB에 연결되었습니다...\"))\n  .catch((err) => console.error(\"MongoDB에 연결할 수 없습니다...\", err));\n\nmodule.exports = db;\n```\n\n서버의 server.js 파일에 데이터베이스 연결을 추가하는 걸 잊지 마세요:\n\n```js\nconst db = require(\"./dbconnection\");\n```\n\n\n\n이제 추가 패키지를 설치해볼게요:\n\n```js\nnpm install jsonwebtoken\nnpm install dotenv\nnpm install bcrypt\n```\n\n그럼 이제 사용자 모델을 만들어보겠습니다:\n\n```js\nconst jwt = require(\"jsonwebtoken\");\nconst mongoose = require(\"mongoose\");\nrequire(\"dotenv\").config();\n\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n  },\n  password: {\n    type: String,\n    required: true,\n    unique: true,\n    minlength: 8,\n    maxlength: 1024,\n  },\n  refreshtoken: [String],\n});\n\nuserSchema.methods.generateAuthToken = function () {\n  const accesstoken = jwt.sign(\n    { _id: this._id },\n    process.env.ACCESS_SECRET_KEY,\n    {\n      expiresIn: \"10s\",\n    }\n  );\n  const refreshtoken = jwt.sign(\n    { _id: this._id },\n    process.env.REFRESH_SECRET_KEY,\n    { expiresIn: \"1d\" }\n  );\n\n  const tokens = { accesstoken: accesstoken, refreshtoken: refreshtoken };\n  return tokens;\n};\n\nconst User = mongoose.model(\"User\", userSchema);\n\nexports.User = User;\n```\n\n\n\n우리는 MongoDB에서 사용자 데이터를 위한 스키마를 정의합니다.\n\n각 사용자 문서에는 이메일, 패스워드, 그리고 리프레시 토큰을 저장하기 위한 배열이 포함될 것입니다.\n\n우리는 사용자 스키마에 generateAuthToken이라는 메소드를 추가합니다.\n\n- 이 메소드는 jsonwebtoken 패키지를 사용하여 액세스 토큰과 리프레시 토큰을 생성합니다.\n- 액세스 토큰은 10초 후에 만료되며 사용자의 _id를 포함합니다.\n- 리프레시 토큰은 1일 후에 만료되며 또한 사용자의 _id를 포함합니다.\n\n\n\n우리는 사용자 스키마를 기반으로 하는 Mongoose 모델인 User를 생성합니다.\n\n- 이 모델은 사용자를 위한 MongoDB 컬렉션과 상호 작용하기 위해 사용됩니다.\n- 우리는 다른 부분에서 사용하기 위해 User 모델을 내보냅니다.\n\n# AppError 및 TryCatch\n\n우리는 더 나은 오류 처리를 위해 두 가지 유틸리티 함수인 AppError와 tryCatch로 코드베이스를 향상시키고 있습니다.\n\n\n\nAppError 클래스는 구조화된 방식으로 오류 정보를 캡슐화하기 위해 설계되었습니다. 이 클래스는 기본 Error 클래스를 확장하고 errorCode 및 statusCode와 같은 사용자 정의 속성을 추가하여 오류를 분류하고 적절한 HTTP 상태 코드로 응답할 수 있도록 합니다. 이것은 응용 프로그램 전반에 걸쳐 오류 처리의 일관성을 보장합니다.\n\n```js\nclass AppError extends Error {\n  constructor(errorCode, message, statusCode) {\n    super(message);\n    this.errorCode = errorCode;\n    this.statusCode = statusCode;\n  }\n}\n\nmodule.exports = AppError;\n```\n\ntryCatch 함수는 비동기 컨트롤러 함수 내에서 오류를 처리하는 편리한 방법을 제공합니다. 이 함수는 컨트롤러 함수를 입력으로 받고 새로운 비동기 함수를 반환합니다. 이 새로운 함수는 원래의 컨트롤러 함수를 try-catch 블록으로 감싸줍니다. 컨트롤러 함수 실행 중에 오류가 발생하면 해당 오류가 catch되어 기록되고 Express의 next 함수로 전달됩니다. 이 추상화는 라우트 핸들러에서 오류 처리를 간소화시키며 더 깔끔하고 유지보수하기 쉬운 코드를 장려합니다.\n\n```js\nexports.tryCatch = (controller) => async (req, res, next) => {\n  try {\n    await controller(req, res);\n  } catch (error) {\n    console.log(error);\n    return next(error);\n  }\n};\n```\n\n\n\n이 유틸리티 함수들을 코드베이스에 통합함으로써, 우리의 에러 처리 메커니즘의 가독성이 향상되어 전체 신뢰성과 사용자 경험이 향상됩니다.\n\n# 루트\n\n다음으로, 사용자 인증 및 세션 관리를 위한 엔드포인트를 설계할 것입니다. SignIn, SignUp, RefreshToken 및 LogOut을 포함하고 있습니다. 우선, 이러한 기능을 위한 루트를 정의해 보겠습니다.\n\n```js\nconst express = require(\"express\");\nconst authController = require(\"./controllers\");\nconst verifyJWT = require(\"../../middleware/verifyJWT\");\n\nconst router = express.Router();\n\n//인증 기반 루트\nrouter.post(\"/signUp\", authController.SignUp);\nrouter.post(\"/signIn\", authController.SignIn);\nrouter.get(\"/refresh\", authController.refreshToken);\nrouter.get(\"/logout\", authController.logOut);\n\nmodule.exports = router;\n```\n\n\n\nNode.js 어플리케이션에서, 서비스와 컨트롤러는 코드베이스를 조직화하고 구조화하는 데 중요한 구성 요소로서 역할을 합니다. 이는 관심사 분리와 유지보수를 촉진합니다.\n\n- 서비스: 서비스는 비즈니스 로직과 데이터 조작 작업을 캡슐화합니다. 특정 도메인과 관련된 작업이나 특정 작업을 수행하는 데 책임이 있습니다. 서비스는 작업이 어떻게 구현되는지에 대한 세부 정보를 추상화하여 컨트롤러가 HTTP 요청 및 응답 처리에 집중하고 가볍게 유지할 수 있도록 합니다. 서비스는 종종 응용 프로그램의 여러 부분에서 재사용 가능하며 비즈니스 로직을 외부 종속성으로부터 격리하여 테스트를 용이하게 합니다.\n  \n- 컨트롤러: 컨트롤러는 수신된 HTTP 요청을 처리하고 응용 프로그램의 엔드포인트를 정의합니다. 요청에서 데이터를 추출하고 필요한 작업을 수행하기 위해 서비스와 상호 작용하며 적절한 응답을 클라이언트에 반환합니다. 컨트롤러는 클라이언트 측 인터페이스(예: 웹 브라우저 또는 모바일 앱)와 기저 응용 프로그램 로직 사이의 다리 역할을 합니다. 컨트롤러는 비즈니스 로직이 표현 계층과 분리되도록 하여 작업을 조직화하고 서비스에 작업을 위임합니다. 라우팅 및 요청/응답 처리를 담당하여 요청-응답 주기에서 중요한 구성 요소로 작용합니다.\n\n이제 SignUp 기능을 구현해 보겠습니다.\n\n```js\nconst bcrypt = require(\"bcrypt\");\nconst jwt = require(\"jsonwebtoken\");\nconst { tryCatch } = require(\"../../utils/tryCatch\");\nconst AppError = require(\"../../utils/AppError\");\nconst authServices = require(\"./services\");\nconst { User } = require(\"../../Models/user\");\n\nexports.SignUp = tryCatch(async (req, res) => {\n  const { email, password } = req.body;\n  const user = await User.find({ email: email });\n  \n  if (!user) {\n    throw new AppError(\n      409,\n      \"데이터베이스에 이미 존재하는 이메일 주소입니다!\",\n      409\n    );\n  }\n\n  try {\n    const response = await authServices.signUp(email, password);\n    const accessToken = response.token.accesstoken;\n    const refreshToken = response.token.refreshtoken;\n    res.cookie(\"jwt\", refreshToken, {\n      httpOnly: true,\n      maxAge: 24 * 60 * 60 * 1000,\n    });\n    res.status(200).json({ accessToken: accessToken }).end();\n  } catch (err) {\n    console.log(err);\n    res.status(err.statusCode).json(err.message).end();\n  }\n});\n```\n\n\n\n위 코드 스니펫은 Node.js 애플리케이션에서 사용자 등록 요청을 처리하는 SignUp 컨트롤러 함수를 정의합니다. 이 함수는 비밀번호 해싱을 위한 bcrypt 및 토큰 생성을 위한 jsonwebtoken과 같은 필요한 모듈을 가져오며 사용자 지정 오류 처리 유틸리티도 가져옵니다. 요청을 받으면 요청 본문에서 이메일과 비밀번호를 추출하고 동일한 이메일을 가진 기존 사용자를 확인하며, 중복된 이메일이 없으면 SignUp 서비스를 호출하여 사용자 생성을 처리하고 액세스 및 리프레시 토큰을 생성하여 보안을 위해 리프레시 토큰을 HTTP-only 쿠키에 설정하고 응답에 액세스 토큰을 보냅니다. SignUp 프로세스 중 발생하는 모든 오류는 오류 상태 코드와 메시지로 적절히 처리됩니다.\n\nSignUp 서비스:\n\n```js\nconst bcrypt = require(\"bcrypt\");\nconst { User } = require(\"../../Models/user\");\nconst { UserProfile } = require(\"../../Models/userProfile\");\nconst mongoose = require(\"mongoose\");\nconst ObjectId = mongoose.Types.ObjectId;\n\nconst signUp = async (email, password) => {\n  const newUser = new User({\n    email: email,\n    password: password,\n    refreshtoken: \"\",\n  });\n\n  const salt = await bcrypt.genSalt(10);\n  newUser.password = await bcrypt.hash(newUser.password, salt);\n\n  const tokens = newUser.generateAuthToken();\n  newUser.refreshtoken = tokens.refreshtoken;\n  await newUser.save();\n  const data = {\n    token: tokens,\n    id: newUser.id,\n  };\n\n  return data;\n};\n```\n\n이 서비스 함수 signUp은 애플리케이션에 새로운 사용자를 생성하는 역할을 합니다. 이메일과 비밀번호를 매개변수로 받습니다. 함수 내에서는 제공된 이메일과 비밀번호로 User 객체를 생성하고 비어있는 리프레시 토큰 필드를 가집니다. 그런 다음 보안을 위해 bcrypt를 사용하여 비밀번호를 해싱합니다. 사용자 모델의 generateAuthToken 메서드를 사용하여 인증 토큰을 생성하는 책임이 있는 사용자 모델의 객체에 리프레시 토큰을 할당합니다. 마지막으로 새 사용자를 데이터베이스에 저장하고 생성된 토큰과 사용자 ID를 포함하는 객체가 반환됩니다. 이 함수는 사용자 암호가 데이터베이스에 저장되기 전에 안전하게 해싱되며 새로 생성된 사용자에 대한 인증 토큰을 제공합니다.\n\n\n\n동일한 스키마를 사용하여 SignIn 기능을 이제 구현하겠습니다:\n\n```js\nexports.SignIn = tryCatch(async (req, res) => {\n  const cookies = req.cookies;\n  const { email, password } = req.body;\n  const user = await User.findOne({ email: email });\n\n  if (!user) {\n    throw new AppError(\n      404,\n      \"이메일 주소를 찾을 수 없습니다. 이메일을 확인하고 다시 시도해주세요.\",\n      404\n    );\n  }\n\n  const validPassword = await bcrypt.compare(password, user.password);\n\n  if (!validPassword) {\n    throw new AppError(\n      401,\n      \"잘못된 비밀번호입니다. 비밀번호를 다시 확인하고 다시 시도해주세요.\",\n      401\n    );\n  }\n\n  try {\n    let newRefreshTokenArray = \"\";\n\n    // 사용자의 기존 refresh 토큰 확인\n    let refreshToken = \"\";\n    if (!cookies?.jwt) {\n      refreshToken = user.refreshtoken;\n    } else {\n      refreshToken = cookies.jwt;\n      const foundToken = await User.findOne({ refreshToken }).exec();\n      \n      if (!foundToken) {\n        console.log(\"로그인 시 시도된 refresh 토큰 재사용!\");\n        // 토큰이 데이터베이스에 없으면 쿠키를 지우기\n        res.clearCookie(\"jwt\", { httpOnly: true });\n        refreshToken = \"\";\n      }\n    }\n    const response = await authServices.signIn(user, newRefreshTokenArray);\n    const accessToken = response.token.accesstoken;\n    refreshToken = response.token.refreshtoken;\n    const profilePic = response.profilePic;\n    res.cookie(\"jwt\", refreshToken, {\n      httpOnly: true,\n      maxAge: 24 * 60 * 60 * 1000,\n    });\n    return res\n      .status(200)\n      .cookie(\"jwt\", refreshToken, {\n        httpOnly: true,\n        maxAge: 24 * 60 * 60 * 1000,\n      })\n      .json({ accessToken: accessToken, profilePic: profilePic })\n      .end();\n  } catch (err) {\n    console.log(err);\n    return res.status(err.statusCode).json(err.message).end();\n  }\n});\n```\n\n이 코드 세그먼트는 Node.js 애플리케이션에서 SignIn 기능을 구현하여 사용자 인증을 안전하게 처리합니다. 먼저 요청 본문에서 사용자 자격 증명을 추출하고 제공된 이메일에 따라 데이터베이스에서 사용자를 검색합니다. 사용자를 찾을 수 없거나 비밀번호가 일치하지 않는 경우 해당 문제를 나타내는 사용자 정의 오류가 발생합니다. 그런 다음 사용자의 기존 refresh 토큰을 확인하고 토큰의 재사용을 방지하기 위해 유효성을 검사합니다. 성공적으로 인증된 후, 새로운 액세스 및 refresh 토큰을 생성하고 사용자의 프로필 사진을 가져오기 위해 서비스 함수를 호출합니다. 새 refresh 토큰은 보안을 위해 HTTP-only 쿠키에 설정되고, 액세스 토큰과 프로필 사진은 응답으로 반환됩니다. 프로세스 중 발생하는 모든 오류는 적절히 처리되어 상응하는 상태 코드와 메시지로 오류 응답으로 반환됩니다.\n\n```js\nconst signIn = async (user, newRefreshTokenArray) => {\n  const token = user.generateAuthToken();\n  user.refreshtoken = [...newRefreshTokenArray, token.refreshtoken];\n  await user.save();\n  const data = {\n    token: token,\n    userId: user.id,\n  };\n  return data;\n};\n\nmodule.exports = {\n  signUp,\n  signIn,\n};\n```\n\n\n\n서비스 기능 signIn은 사용자 인증에 성공한 경우 인증 토큰을 생성하고 사용자 프로필 정보를 검색하는 작업을 처리합니다. 이 함수는 인증된 사용자 객체와 새로운 리프레시 토큰 배열을 매개변수로 받습니다. 그런 다음 사용자 객체의 generateAuthToken 메서드를 사용하여 인증 토큰을 생성합니다. 새로운 리프레시 토큰은 사용자의 refreshtoken 배열에 추가되고 사용자 객체가 데이터베이스에 다시 저장됩니다. 마지막으로 생성된 토큰과 사용자 ID가 포함된 객체를 구성하고 반환합니다. 이 함수는 인증 토큰이 안전하게 생성되고 저장되며 사용자 정보가 정상적으로 검색되어 제공되도록 보장합니다.\n\n여기까지가 기본 인증 흐름입니다. 이제 로그아웃 기능만 필요합니다.\n\n```js\nexports.logOut = tryCatch(async (req, res) => {\n  // 클라이언트에서는 accessToken도 삭제하세요\n  const cookies = req.cookies;\n  if (!cookies?.jwt) return res.sendStatus(204);\n  const refreshToken = cookies.jwt;\n  // 데이터베이스에 리프레시 토큰이 있는지 확인합니다.\n  const foundUser = await User.findOne({ refreshtoken: refreshToken });\n\n  if (!foundUser) {\n    res.clearCookie(\"jwt\", { httpOnly: true });\n    return res.sendStatus(204);\n  }\n\n  // 데이터베이스에서 리프레시 토큰 삭제\n  foundUser.refreshtoken = foundUser.refreshtoken.filter(\n    (rt) => rt !== refreshToken\n  );\n  await foundUser.save();\n\n  res.clearCookie(\"jwt\", { httpOnly: true });\n  res.sendStatus(204);\n});\n```\n\n이 코드 스니펫은 Node.js 애플리케이션에서 사용자 로그아웃 요청을 처리하는 logOut 컨트롤러 함수를 정의합니다. 오류 처리를 위해 tryCatch 유틸리티가 사용됩니다. 이 함수는 먼저 사용자가 쿠키에 저장된 리프레시 토큰을 확인합니다. 그렇지 않은 경우 204(내용 없음) 상태 코드를 보내어 작업이 필요하지 않음을 나타냅니다. 리프레시 토큰이 발견되면 함수는 데이터베이스를 쿼리하여 존재 여부를 확인합니다. 데이터베이스에서 리프레시 토큰을 찾을 수 없는 경우 리프레시 토큰 쿠키를 지우고 204 상태 코드를 보냅니다. 그렇지 않으면 사용자가 저장한 리프레시 토큰에서 리프레시 토큰을 제거하고 업데이트된 사용자 객체를 다시 데이터베이스에 저장한 다음 리프레시 토큰 쿠키를 지우고 204 상태 코드를 보내 성공적으로 로그아웃 여부를 나타냅니다. 이 함수는 리프레시 토큰을 안전하게 처리하여 관리하고 관련 쿠키를 지움으로써 사용자 로그아웃 요청을 적절하게 처리합니다.\n\n\n\n# 리프레시 엔드포인트\n\n리프레시 토큰을 사용하면 인증 시스템에서 새 액세스 토큰을 얻을 수 있어요. 액세스 토큰이 만료될 때 이를 사용하여 새 액세스 토큰을 요청할 수 있어요. 액세스 토큰이 수명이 짧지만, 리프레시 토큰은 긴 수명을 가지며 보통 몇 일이나 심지어 몇 주 동안 유효합니다. 액세스 토큰이 만료되었을 때 리프레시 토큰은 사용자가 다시 로그인할 필요 없이 새 액세스 토큰을 요청할 수 있도록 도와줘요. 이를 통해 민감한 자격 증명 노출을 최소화하고 사용자 인증 빈도를 줄여 보안을 강화할 수 있어요. 리프레시 토큰은 클라이언트 측에 안전하게 저장되며 보통 HTTP-only 쿠키에 저장되며 안전한 인증 흐름을 통해 새 액세스 토큰으로 교환됩니다.\n\n그래서 조금 더 명확하게 설명되었나요? 이를 향상시키기 위해 사용자 액세스 키가 만료된 경우 “무음\"이라고 부를 수 있는 리프레시 토큰 엔드포인트가 필요해요.\n\n\n\n```js\nexports.refreshToken = tryCatch(async (req, res) => {\n  const cookies = req.cookies;\n  if (!cookies?.jwt) return res.sendStatus(401);\n  const refreshToken = cookies.jwt;\n  res.clearCookie(\"jwt\", { httpOnly: true });\n  const foundUser = await User.findOne({ refreshtoken: refreshToken });\n  \n  if (!foundUser) {\n    jwt.verify(\n      refreshToken,\n      process.env.REFRESH_SECRET_KEY,\n      async (err, decoded) => {\n        if (err) return res.sendStatus(403); //Forbidden\n        const hackedUser = await User.findOne({ username: decoded._id });\n        hackedUser.refreshtoken = [];\n        const result = await hackedUser.save();\n      }\n    );\n    return res.sendStatus(403);\n  }\n\n  const newRefreshTokenArray = foundUser.refreshtoken.filter(\n    (rt) => rt !== refreshToken\n  );\n\n  //evaluate jwt\n  jwt.verify(\n    refreshToken,\n    process.env.REFRESH_SECRET_KEY,\n    async (err, decoded) => {\n      if (err) {\n        foundUser.refreshtoken = [...newRefreshTokenArray];\n        const result = await foundUser.save();\n      }\n      if (err || foundUser._id.toString() !== decoded._id) {\n        return res.sendStatus(403);\n      }\n      //refreshtoken still valid\n      const accessToken = jwt.sign(\n        { _id: decoded._id },\n        process.env.ACCESS_SECRET_KEY,\n        { expiresIn: \"10s\" }\n      );\n\n      const newRefreshToken = jwt.sign(\n        { _id: foundUser._id },\n        process.env.REFRESH_SECRET_KEY,\n        { expiresIn: \"1d\" }\n      );\n      foundUser.refreshtoken = [...newRefreshTokenArray, newRefreshToken];\n      const result = await foundUser.save();\n      res.cookie(\"jwt\", newRefreshToken, {\n        httpOnly: true,\n        maxAge: 24 * 60 * 60 * 1000,\n      });\n      res.status(200).json(accessToken);\n    }\n  );\n});\n```\n\n- Refresh Token 확인: 먼저 \"jwt\"라는 쿠키에 저장된 리프레시 토큰이 있는지 확인합니다. 만약 없다면 401(권한없음) 상태 코드로 응답하여 사용자가 인증해야 함을 알립니다.\n- 쿠키 삭제: 리프레시 토큰의 존재 여부와 상관없이 보안을 위해 \"jwt\" 쿠키를 제거합니다.\n- 사용자 찾기: 그 후 데이터베이스에서 리프레시 토큰과 연결된 사용자를 찾습니다. 사용자를 찾지 못하면 리프레시 토큰의 무결성을 확인합니다.\n- 리프레시 토큰 확인: 환경 변수에 저장된 비밀 키를 사용하여 리프레시 토큰을 확인합니다. 토큰이 유효하지 않거나 만료되었다면 403(금지됨) 상태 코드로 응답합니다. 또한 확인에 사용된 사용자를 찾아 사용자와 연관된 모든 리프레시 토큰을 제거하여 잠재적인 남용을 방지합니다.\n- 토큰 갱신: 리프레시 토큰이 유효하고 사용자와 연관되어 있다면 액세스 토큰과 리프레시 토큰을 갱신합니다. 짧은 만료 시간(여기서 10초)을 갖는 새로운 액세스 토큰과 긴 만료 시간(여기서 1일)을 갖는 새로운 리프레시 토큰을 생성합니다. 사용자의 리프레시 토큰 배열을 새로운 리프레시 토큰으로 업데이트하고 데이터베이스에 변경 사항을 저장합니다.\n- 새로운 쿠키 설정: 마지막으로 새로운 리프레시 토큰을 안전하게 설정하기 위해 HTTP-only 플래그와 최대 24시간 나이가 있는 쿠키로 설정합니다. 새로운 액세스 토큰과 함께 200(성공) 상태 코드로 응답합니다.\n\n또한 데이터베이스로부터 사용자 이메일을 가져오는 보안된 엔드포인트가 필요합니다:\n\n```js\nexports.getUserData = tryCatch(async (req, res) => {\n  const userId = req.params.id;\n  const foundUser = await User.findOne({ _id: userId });\n\n  const data = {\n    userEmail: foundUser.email,\n  };\n\n  res.status(200).json(data).end();\n});\n```\n\n\n\n저희 라우트에도 다음을 추가해야 합니다:\n\n```js\nconst express = require(\"express\");\nconst authController = require(\"./controllers\");\nconst verifyJWT = require(\"../../middleware/verifyJWT\");\n\nconst router = express.Router();\n\n//Auth 기반 라우트\nrouter.post(\"/signUp\", authController.SignUp);\nrouter.post(\"/signIn\", authController.SignIn);\nrouter.get(\"/refresh\", authController.refreshToken);\nrouter.get(\"/logout\", authController.logOut);\n\nrouter.get(\"/getUser/:id\", verifyJWT, authController.getUserData);\n\nmodule.exports = router;\n```\n\n여기서 verifyJWT 미들웨어에 대해 이야기해야 합니다:\n\n```js\nconst jwt = require(\"jsonwebtoken\");\nrequire(\"dotenv\").config();\n\nconst verifyJWT = (req, res, next) => {\n  const authHeader = req.headers[\"authorization\"];\n  if (!authHeader) return res.sendStatus(401);\n  console.log(authHeader);\n  const token = authHeader.split(\"Bearer \")[1];\n  console.log(token);\n  console.log(\"access secret\", process.env.ACCESS_SECRET_KEY);\n  jwt.verify(token, process.env.ACCESS_SECRET_KEY, (err, decoded) => {\n    console.log(decoded);\n    if (err) {\n      console.log(err);\n      return res.status(403).json({ error: \"Forbidden: JWT token expired!\" });\n    }\n    req.user = decoded.username;\n    next();\n  });\n};\n\nmodule.exports = verifyJWT;\n```\n\n\n\n이 코드에서는 응용 프로그램에서 인증에 사용되는 JSON Web Token (JWT)을 확인하는 verifyJWT라는 미들웨어 함수를 정의합니다. 먼저, JWT 확인을 처리하기 위해 jsonwebtoken 패키지를 가져오고 환경 변수에 안전하게 액세스하기 위해 dotenv 패키지를 가져옵니다. verifyJWT 함수는 req (요청), res (응답) 및 next라는 세 가지 매개변수를 사용하여 Express 애플리케이션에서 미들웨어로 작동할 수 있습니다. 함수 내에서는 들어오는 요청의 Authorization 헤더에서 JWT 토큰을 추출합니다. 헤더가 누락되거나 형식이 잘못된 경우 즉시 상태 코드가 401 (인증되지 않음)으로 응답됩니다. 그렇지 않으면 헤더를 분할하여 \"Bearer \" 접두사를 제거하고 토큰을 분리합니다. 그런 다음 jwt.verify를 사용하여 토큰을 디코딩하고 환경 변수에 저장된 엑세스 시크릿 키와의 일치 여부를 확인합니다. 확인이 실패하는 경우(예: 토큰 만료 또는 잘못된 서명), 상태 코드가 403(금지됨)으로 응답되고 오류 메시지가 표시됩니다. 그렇지 않으면 토큰이 유효한 경우 디코딩된 페이로드(일반적으로 사용자 정보를 포함)를 추출하여 req.user로써 요청 객체에 첨부합니다. 마지막으로 next 함수를 호출하여 요청-응답 주기에서 다음 미들웨어나 라우트 핸들러로 제어를 전달합니다. 이 미들웨어를 사용하면 유효한 JWT 토큰을 가진 요청만 보호된 경로에 액세스할 수 있도록하며 응용 프로그램의 보안을 강화합니다.\n\n필요한 모든 것을 생성한 후에는 서버.js에 cors 및 쿠키 구문 분석을 위한 추가 설정이 필요합니다:\n\n```js\nconst express = require(\"express\");\nconst cors = require(\"cors\");\nconst db = require(\"./dbconnection\");\nconst port = 5000;\nconst bodyParser = require(\"body-parser\");\nconst cookieParser = require(\"cookie-parser\");\nconst app = express();\n\nconst userRoutes = require(\"./apis/users/routes\");\n\nconst frontendURI = \"http://localhost:5173\";\n\napp.use(bodyParser.json({ limit: \"5mb\" }));\napp.use(cookieParser());\napp.use(\n  cors({\n    origin: frontendURI, // 귀하의 프론트엔드 도메인으로 대체\n    credentials: true, // 자격 증명(쿠키, 인가 헤더) 허용\n  })\n);\napp.use(\"/users\", userRoutes);\napp.listen(port, () => {\n  console.log(`서버가 포트 ${port}에서 실행중입니다.`);\n});\n```\n\n- CORS(Cross-Origin Resource Sharing):\n\n\n\n- Cors 미들웨어는 우리 애플리케이션에서 Cross-Origin Resource Sharing을 활성화하는 역할을 합니다. 이를 통해 서버의 리소스가 원래 출처(origin)와 다른 도메인에서 요청될 수 있습니다. 이것은 서로 다른 도메인의 서버로 요청을 하는 클라이언트 측 웹 애플리케이션에게 중요합니다.\n- 우리의 코드에서는 cors를 특정한 옵션으로 구성합니다:\n  - origin: 크로스-오리진 요청의 허용된 원본을 지정합니다. 이 경우, \"http://localhost:5173\"인 특정 프론트엔드 URI(frontendURI)에서의 요청을 허용합니다.\n  - credentials: 서버가 요청에 쿠키나 인증 헤더와 같은 자격 증명을 포함해야 하는지 여부를 나타냅니다. 이를 true로 설정하면 클라이언트가 그러한 자격 증명을 포함할 수 있습니다.\n\n2. bodyParser:\n\n- bodyParser 미들웨어는 들어오는 요청 본문을 구문 분석하고 구문 분석된 데이터를 req.body 속성 아래에서 사용할 수 있게 합니다. 특히 POST 또는 PUT 요청을 처리할 때 클라이언트로부터 전송된 데이터를 처리하는 데 필수적입니다.\n- 우리의 코드에서는 bodyParser.json()을 사용하여 JSON 인코딩된 요청 본문을 구문 분석합니다. 또한 요청 본문 크기의 제한을 5MB로 설정하여 단일 요청에서 전송할 수 있는 데이터 양을 제한하여 잠재적인 서비스 거부 공격을 방지합니다.\n\n3. cookieParser:\n\n\n\n- CookieParser 미들웨어는 클라이언트 요청에 첨부된 쿠키를 구문 분석하고 req.cookies 속성 아래에서 사용할 수 있도록 만듭니다. 클라이언트가 보낸 쿠키를 처리하는 데 중요한데, 이는 세션 관리, 인증 및 기타 목적으로 자주 사용됩니다.\n- 저희 코드에서는 추가 구성 없이 cookieParser의 기본 설정을 사용하고 있습니다.\n\n이제 백엔드 구현을 다룼으로써, 애플리케이션을 위한 최소한의 프론트엔드를 만들어 모든 것을 연결해 보겠습니다. 프론트엔드 인터페이스를 구축함으로써 방금 개발한 백엔드 기능과 상호 작용할 수 있게 됩니다. React를 사용하여 기본 프론트엔드 구조를 설정해 보겠습니다. 우리는 SignUp, SignIn, RefreshToken 및 LogOut과 같은 백엔드에 구현한 인증 엔드포인트와 상호 작용할 수 있는 사용자 인터페이스 구성 요소를 만들 것입니다. 더불어 Axios와 같은 도구를 활용하여 백엔드 API로 HTTP 요청을 보내고 사용자 인증 흐름을 원활하게 처리할 것입니다. 그러니 이제 소매를 걷어 올리고 프론트엔드 개발 프로세스로 뛰어 들어 백엔드 아키텍처를 보완해 봅시다!\n\n모든 것이 정확히 완료되었는지 확인하고 보장하려면, 이 코드의 GitHub 저장소를 방문해 주세요.\n\n제2부에서 여러분을 만나는 것을 고대하겠습니다!","ogImage":{"url":"/assets/img/2024-05-12-RefreshAuthTokenRotationNodejsReactPart1_0.png"},"coverImage":"/assets/img/2024-05-12-RefreshAuthTokenRotationNodejsReactPart1_0.png","tag":["Tech"],"readingTime":19},{"title":"리액트에서 사용자 정의 드롭다운 컴포넌트 만들기 단계별 가이드","description":"","date":"2024-05-12 19:10","slug":"2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep","content":"\n![이미지](/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_0.png)\n\n안녕하세요! 이 기사에서는 React 애플리케이션에서 동적으로 사용할 수 있는 사용자 정의 Dropdown 컴포넌트를 소개하려고해요. 이 Dropdown 컴포넌트는 사용자가 목록에서 항목을 선택할 수 있도록 하면서 다양한 위치와 스타일로 표시될 수 있어요. 또한 이미지가 있는 경우와 없는 경우 모두 사용할 수 있어요. 이 컴포넌트는 Typescript, Tailwind CSS, React Icons 및 Classnames와 같은 인기있는 라이브러리를 사용하여 개발되었어요.\n\n👉 먼저 단계별로 무엇이 일어나고 있는지 설명한 후에 마지막에 전체 코드와 사용법을 추가할 거예요. 준비가 되셨나요? 그럼 시작해봅시다!\n\n![이미지](/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_1.png)\n\n## 1. Imports:\n\n```js\nimport { useEffect, useRef, useState } from \"react\";\nimport classNames from \"classnames\";\nimport { GoChevronDown } from \"react-icons/go\";\nimport useOutsideClick from \"../hooks/useOutsideClick\";\n```\n\n🔸 useEffect, useRef 및 useState ➜ 이들은 상태를 관리하고 DOM 요소에 대한 참조를 만들 때 사용되는 React 훅입니다.\n\n🔸 classNames ➜ 이 라이브러리는 조건부로 classNames을 결합하는 데 사용됩니다.\n\n🔹 goChevronDown ➜ 이 아이콘 컴포넌트는 드롭다운 토글 버튼에 사용됩니다.\n\n🔹 useOutsideClick ➜ 이 사용자 정의 후크는 지정된 요소 외부를 클릭 감지하는 데 사용됩니다.\n\n## 2. 인터페이스:\n\n```js\n인터페이스 DropdownItem {\n  id: string;\n  name: string;\n  imageUrl?: string;\n}\n\n인터페이스 DropdownProps {\n  id: string;\n  title?: string;\n  data: DropdownItem[];\n  position?: \"bottom-right\" | \"bottom-left\" | \"top-right\" | \"top-left\";\n  hasImage?: boolean;\n  style?: string;\n  selectedId?: string;\n  onSelect?: (id: string) => void;\n}\n```\n\n🔹DropdownItem➜ DropdownItem을 정의합니다. 이 인터페이스는 각 드롭다운 아이템에 필요한 속성인 id, name 및 옵션으로 imageUrl을 지정합니다.\n\n🔹DropdownProps➜ 이 인터페이스는 Dropdown 컴포넌트에 전달할 수 있는 프로퍼티들을 지정합니다. 이 프로퍼티들의 설명은 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_2.png)\n\n📌 id: Dropdown 컴포넌트의 고유 식별자입니다.\n\n📌 제목: 드롭다운이 열릴 때 표시되는 기본 제목. 기본 제목은 \"Select\"입니다.\n\n📌 데이터: 드롭다운 콘텐츠를 구성하는 항목 목록.\n\n📌 위치: 드롭다운의 위치를 버튼을 기준으로 지정합니다. (\"bottom-right\", \"bottom-left\", \"top-right\", \"top-left\"). 기본 위치는 \"bottom-left\"입니다.\n\n📌 이미지 포함 여부: 드롭다운 항목에 이미지가 있는지를 나타내는 부울 값.\n\n📌 스타일 : 드롭다운 컴포넌트에 적용할 추가 스타일입니다.\n\n📌 selectedId : 초기 선택 항목의 식별자입니다.\n\n📌 onSelect : 항목이 선택될 때 호출되는 콜백 함수입니다.\n\n![이미지](/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_3.png)\n\n이 프롭들은 Dropdown 컴포넌트를 다양한 사용 사례에 맞게 사용자 정의할 수 있도록 해 줍니다. 사용자가 필요에 맞게 드랍다운의 동작, 내용, 외관을 맞춤 설정할 수 있게 해줍니다.\n\n## 3. Dropdown 컴포넌트 생성:\n\n```js\nconst Dropdown = ({\n  id,\n  title = \"Select\", //기본 값\n  data,\n  position = \"bottom-left\", //기본 값\n  hasImage,\n  style,\n  selectedId,\n  onSelect,\n}: DropdownProps) => {\n  return (\n    <div ref={dropdownRef} className=\"relative\">\n      {/* ... */}\n    </div>\n  );\n};\nexport default Dropdown;\n```\n\n🔹Dropdown 컴포넌트는 사용자 정의 드롭다운 메뉴 컴포넌트이며 위의 프롭을 허용합니다.\n\n## 4. 상태 변수:\n\n```js\nconst [isOpen, setIsOpen] = useState < boolean > false;\n\nconst [selectedItem, setSelectedItem] =\n  (useState < DropdownItem) | (undefined > (selectedId ? data?.find((item) => item.id === selectedId) : undefined));\n```\n\n🔹isOpen➜ 드롭다운 메뉴의 열기/닫기 상태를 관리합니다.\n\n🔹selectedItem➜ 드롭다운 메뉴에서 현재 선택된 항목을 추적합니다.\n\n## 5. 이벤트 핸들러:\n\n```js\nconst handleChange = (item: DropdownItem) => {\n  setSelectedItem(item);\n  onSelect && onSelect(item.id);\n  setIsOpen(false);\n};\n```\n\n🔹handleChange➜ 드롭다운 메뉴에서 항목을 선택하는 핸들러입니다. 선택된 항목을 업데이트하고, onSelect 콜백을 호출(제공된 경우)하며, 드롭다운 메뉴를 닫습니다.\n\n## 6. useEffect 훅:\n\n```js\nuseEffect(() => {\n  if (selectedId && data) {\n    const newSelectedItem = data.find((item) => item.id === selectedId);\n    newSelectedItem && setSelectedItem(newSelectedItem);\n  } else {\n    setSelectedItem(undefined);\n  }\n}, [selectedId, data]);\n```\n\n🔹 이 useEffect 훅은 selectedId와 data의 변경 사항을 감지합니다. 둘 중 하나가 변경되면 데이터에서 selectedId와 일치하는 항목을 찾아 selectedItem에 설정합니다.\n\n## 7. Ref:\n\n```js\nconst dropdownRef = useRef < HTMLDivElement > null;\nuseOutsideClick({\n  ref: dropdownRef,\n  handler: () => setIsOpen(false),\n});\n```\n\n🔹 dropdownRef➜ 드롭다운 메뉴 외부 클릭을 감지하는 데 사용되는 Ref입니다.\n\n## 8. CSS 클래스:\n\n```js\nconst dropdownClass = classNames(\"absolute bg-gray-100 w-max max-h-52 overflow-y-auto py-3 rounded shadow-md z-10\", {\n  \"top-full right-0 mt-2\": position === \"bottom-right\",\n  \"top-full left-0 mt-2\": position === \"bottom-left\",\n  \"bottom-full right-0 mb-2\": position === \"top-right\",\n  \"bottom-full left-0 mb-2\": position === \"top-left\",\n});\n```\n\n🔹 dropdownClass➜ 위치 prop에 따라 드롭다운 메뉴를 배치하기 위해 CSS 클래스를 동적으로 계산합니다.\n\n## 9. 드롭다운 토글 버튼 생성:\n\n```js\n<button\n  id={id}\n  aria-label=\"드롭다운 토글\"\n  aria-haspopup=\"true\"\n  aria-expanded={isOpen}\n  type=\"button\"\n  onClick={() => setIsOpen(!isOpen)}\n  className={classNames(\n    \"flex justify-between items-center gap-5 rounded w-full py-2 px-4 bg-blue-500 text-white\",\n    style\n  )}\n>\n  <span>{selectedItem?.name || title}</span>\n  <GoChevronDown\n    size={20}\n    className={classNames(\"transform duration-500 ease-in-out\", {\n      \"rotate-180\": isOpen,\n    })}\n  />\n</button>\n```\n\n🔹버튼 엘리먼트는 제목 또는 선택한 항목의 텍스트와 화살표 아이콘이 들어 있습니다.\n\n🔹클릭할 때마다 버튼은 isOpen 상태를 토글합니다.\n\n## 10. 드롭다운 콘텐츠 생성:\n\n```js\n{\n  isOpen && (\n    <div aria-label=\"드롭다운 메뉴\" className={dropdownClass}>\n      <ul role=\"menu\" aria-labelledby={id} aria-orientation=\"vertical\" className=\"leading-10\">\n        {data?.map((item) => (\n          <li\n            key={item.id}\n            onClick={() => handleChange(item)}\n            className={classNames(\"flex items-center cursor-pointer hover:bg-gray-200 px-3\", {\n              \"bg-gray-300\": selectedItem?.id === item.id,\n            })}\n          >\n            {hasImage && (\n              <img\n                src={item.imageUrl}\n                alt=\"이미지\"\n                loading=\"lazy\"\n                className=\"w-8 h-8 rounded-full bg-gray-400 object-cover me-2\"\n              />\n            )}\n            <span>{item.name}</span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n🔹만약 드롭다운이 열려있으면(isOpen이 true), 드롭다운 메뉴를 나타내는 div가 렌더링됩니다.\n\n🔹드롭다운 메뉴는 data prop으로부터 생성된 항목 목록을 포함합니다.\n\n🔹리스트의 각 항목은 `li` 요소로 표시됩니다.\n\n🔹hasImage 값이 true일 경우, 각 항목 옆에 이미지가 표시됩니다.\n\n## 사용법: ⤵️\n\n```js\nconst handleSelect = (id: string) => {\n  console.log(`id가 ${id}인 항목을 선택했습니다`);\n};\n\n<Dropdown\n  id=\"person\"\n  title=\"사람 선택\"\n  data={data}\n  hasImage\n  style=\"bg-purple-800\"\n  selectedId=\"3\"\n  onSelect={handleSelect}\n/>;\n```\n\n## ✔️ 여기에 전체 코드가 있어요: 👇\n\nDropdown.tsx\n\n```js\nimport { useEffect, useRef, useState } from \"react\";\nimport classNames from \"classnames\";\nimport { GoChevronDown } from \"react-icons/go\";\nimport useOutsideClick from \"../hooks/useOutsideClick\";\n\ninterface DropdownItem {\n  id: string;\n  name: string;\n  imageUrl?: string;\n}\n\ninterface DropdownProps {\n  id: string;\n  title?: string;\n  data: DropdownItem[];\n  position?: \"bottom-right\" | \"bottom-left\" | \"top-right\" | \"top-left\";\n  hasImage?: boolean;\n  style?: string;\n  selectedId?: string;\n  onSelect?: (id: string) => void;\n}\n\nconst Dropdown = ({\n  id,\n  title = \"Select\",\n  data,\n  position = \"bottom-left\",\n  hasImage,\n  style,\n  selectedId,\n  onSelect,\n}: DropdownProps) => {\n  const [isOpen, setIsOpen] = useState < boolean > false;\n  const [selectedItem, setSelectedItem] =\n    (useState < DropdownItem) | (undefined > (selectedId ? data?.find((item) => item.id === selectedId) : undefined));\n\n  const handleChange = (item: DropdownItem) => {\n    setSelectedItem(item);\n    onSelect && onSelect(item.id);\n    setIsOpen(false);\n  };\n\n  useEffect(() => {\n    if (selectedId && data) {\n      const newSelectedItem = data.find((item) => item.id === selectedId);\n      newSelectedItem && setSelectedItem(newSelectedItem);\n    } else {\n      setSelectedItem(undefined);\n    }\n  }, [selectedId, data]);\n\n  const dropdownRef = useRef < HTMLDivElement > null;\n  useOutsideClick({\n    ref: dropdownRef,\n    handler: () => setIsOpen(false),\n  });\n\n  const dropdownClass = classNames(\"absolute bg-gray-100 w-max max-h-52 overflow-y-auto py-3 rounded shadow-md z-10\", {\n    \"top-full right-0 mt-2\": position === \"bottom-right\",\n    \"top-full left-0 mt-2\": position === \"bottom-left\",\n    \"bottom-full right-0 mb-2\": position === \"top-right\",\n    \"bottom-full left-0 mb-2\": position === \"top-left\",\n  });\n\n  return (\n    <div ref={dropdownRef} className=\"relative\">\n      <button\n        id={id}\n        aria-label=\"Toggle dropdown\"\n        aria-haspopup=\"true\"\n        aria-expanded={isOpen}\n        type=\"button\"\n        onClick={() => setIsOpen(!isOpen)}\n        className={classNames(\n          \"flex justify-between items-center gap-5 rounded w-full py-2 px-4 bg-blue-500 text-white\",\n          style\n        )}\n      >\n        <span>{selectedItem?.name || title}</span>\n        <GoChevronDown\n          size={20}\n          className={classNames(\"transform duration-500 ease-in-out\", {\n            \"rotate-180\": isOpen,\n          })}\n        />\n      </button>\n      {/* Open */}\n      {isOpen && (\n        <div aria-label=\"Dropdown menu\" className={dropdownClass}>\n          <ul role=\"menu\" aria-labelledby={id} aria-orientation=\"vertical\" className=\"leading-10\">\n            {data?.map((item) => (\n              <li\n                key={item.id}\n                onClick={() => handleChange(item)}\n                className={classNames(\"flex items-center cursor-pointer hover:bg-gray-200 px-3\", {\n                  \"bg-gray-300\": selectedItem?.id === item.id,\n                })}\n              >\n                {hasImage && (\n                  <img\n                    src={item.imageUrl}\n                    alt=\"image\"\n                    loading=\"lazy\"\n                    className=\"w-8 h-8 rounded-full bg-gray-400 object-cover me-2\"\n                  />\n                )}\n                <span>{item.name}</span>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Dropdown;\n```\n\n## useOutSideClick Hook Code: ⤵️\n\nuseOutsideClick.tsx\n\n```js\nimport { useEffect } from 'react';\n\ninterface OutsideClickHandlerProps {\n  ref: React.RefObject<HTMLElement>;\n  handler: () => void;\n}\n\nconst useOutsideClick = ({ ref, handler }: OutsideClickHandlerProps) => {\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (ref.current && !ref.current.contains(event.target as Node)) {\n        handler();\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [ref, handler]);\n};\n\nexport default useOutsideClick;\n```\n\n## 샘플 데이터 (JSON): ⤵️\n\ndata.json\n\n```json\n[\n  {\n    \"id\": \"1\",\n    \"name\": \"Minnie Barrett\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1534528741775-53994a69daeb?q=80&w=1964&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"2\",\n    \"name\": \"Andy Holmes\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1506794778202-cad84cf45f1d?q=80&w=1887&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"3\",\n    \"name\": \"Felicia Watts\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1544005313-94ddf0286df2?q=80&w=1888&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"4\",\n    \"name\": \"Hailey Green\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1494790108377-be9c29b29330?q=80&w=1887&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"5\",\n    \"name\": \"Jeremiah Hughes\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1500648767791-00dcc994a43e?q=80&w=1887&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"6\",\n    \"name\": \"Amy Perkins\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1587677171791-8b93c752999b?q=80&w=1949&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  }\n]\n```\n\nGithub 주소:\n\n실시간 데모:\n\n## 결론\n\n요약하자면, React 애플리케이션에서 사용할 수 있는 사용자 정의 Dropdown 컴포넌트가 생성되고 설명되었습니다. 이 컴포넌트는 다양한 위치와 스타일에서 활용될 수 있으며 사용자가 목록에서 항목을 선택할 수 있게 합니다. TypeScript, Tailwind CSS, React Icons 및 Classnames를 사용하여 개발된 이 Dropdown 컴포넌트는 사용자 인터페이스 개발 프로세스에서 상당한 편의성을 제공하며 React 애플리케이션에서 널리 사용될 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_0.png","tag":["Tech"],"readingTime":12}],"page":"139","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}