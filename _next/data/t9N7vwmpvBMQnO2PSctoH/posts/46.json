{"pageProps":{"posts":[{"title":"모바일 폼 제작하기 고급 CSS를 활용하여","description":"","date":"2024-06-20 00:51","slug":"2024-06-20-CreatingaMobileFormwithAdvancedCSS","content":"\n\n요즘의 모바일 우선 세상에서는 웹 폼이 반응형이고 사용자 친화적인 것이 중요합니다. 고급 CSS 기술을 사용하면 어떤 기기에서든 멋지게 보이고 잘 작동하는 폼을 만들 수 있습니다. 이 글에서는 CSS를 사용하여 모바일 폼을 만드는 방법을 살펴보겠습니다. 시각적으로 매력적이고 사용하기 쉬운 폼을 만들어 보장할 겁니다.\n\n소개\n모바일 친화적인 폼을 디자인하는 것에는 여러 가지 고려 사항이 포함됩니다. 입력 필드 크기, 간격, 반응성 등이 있습니다. CSS Grid와 Flexbox를 사용하여 다양한 화면 크기에 매끄럽게 적응하는 레이아웃을 구현하는 데 집중할 것입니다. 이 글을 끝내면 사용자 경험과 접근성을 향상시키는 모바일 폼을 갖추게 될 것입니다.\n\n데모\n먼저 간단한 HTML 구조를 폼에 설정해 보겠습니다. 이름, 이메일, 메시지 입력 필드와 제출 버튼이 포함된 폼을 만들어 보겠습니다.\n\nHTML:\n\n<form class=\"contact-form\">\n    <label for=\"name\">이름:</label>\n    <input type=\"text\" id=\"name\" name=\"name\" required>\n\n\n\n\n<div class=\"content-ad\"></div>\n\n`label for=”email”`Email:`/label`\n`input type=”email” id=”email” name=”email” required`\n\n`label for=”message”`Message:`/label`\n`textarea id=”message” name=”message” required``/textarea`\n\n`button type=”submit”`Submit`/button`\n`/form`\n\n다음으로, CSS 그리드를 사용하여 우리의 양식에 대한 반응형 레이아웃을 만들겠습니다. 이렇게 하면 화면이 작은 디스플레이에서도 양식 필드가 잘 조정됩니다.\n\n<div class=\"content-ad\"></div>\n\n```css\n.contact-form {\n  display: grid;\n  gap: 15px;\n  padding: 20px;\n  max-width: 400px;\n  margin: auto;\n  border: 1px solid #ccc;\n  border-radius: 5px;\n}\n\n.contact-form label {\n  font-size: 14px;\n}\n\n.contact-form input,\n.contact-form textarea {\n  width: 100%;\n  padding: 10px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n}\n\n.contact-form button {\n  padding: 10px;\n  background-color: #007BFF;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n해결책\nCSS Grid를 사용하여 양식 필드와 레이블이 적절하게 정렬되고 다양한 화면 크기에서 구조를 유지합니다. 간격 속성을 사용하여 양식 요소 간의 공간을 만들어 가독성과 사용성을 향상시킵니다. 또한 최대 너비를 설정하면 큰 화면에서 양식이 너무 넓어지지 않고 깔끔하고 집중된 레이아웃을 유지할 수 있습니다.\n\n모바일 기기에서는 미디어 쿼리를 추가하여 양식의 모양을 더 조정할 수 있습니다. 이를 통해 최소 화면에서도 양식이 사용자 친화적으로 유지됩니다.\n\nCSS:\n\n@media (max-width: 600px) {\n  .contact-form {\n    padding: 10px;\n  }\n\n  .contact-form label {\n    font-size: 12px;\n  }\n}\n\n\n<div class=\"content-ad\"></div>\n\n\n.contact-form button {\n    padding: 8px;\n}\n\n\n**결론**  \n고급 CSS를 활용하여 모바일 친화적인 폼을 만드는 것은 CSS 그리드와 미디어 쿼리와 같은 기술을 활용하여 응답성과 사용성을 보장하는 것을 포함합니다. 이러한 단계를 따라가면, 장치에 관계없이 훌륭하게 보이고 사용자 경험이 훌륭한 폼을 디자인할 수 있습니다. 반응형 웹 디자인 및 고급 CSS 기술에 대한 추가 자료가 필요하다면, CSS 그리드 및 미디어 쿼리에 대한 MDN 웹 문서를 참고하세요.","ogImage":{"url":"/assets/img/2024-06-20-CreatingaMobileFormwithAdvancedCSS_0.png"},"coverImage":"/assets/img/2024-06-20-CreatingaMobileFormwithAdvancedCSS_0.png","tag":["Tech"],"readingTime":3},{"title":"CSS를 대체할 새로운 스타일 시스템 설계하기","description":"","date":"2024-06-20 00:49","slug":"2024-06-20-DesigninganewstylesystemtoreplaceCSS","content":"\n\n## 자바스크립트 UI — 개발블로그 #3\n\n![이미지](/assets/img/2024-06-20-DesigninganewstylesystemtoreplaceCSS_0.png)\n\n## 소개\n\n저번 주에 자바스크립트 UI에서 기본 뷰 몇 가지를 소개하고, 웹 사이트/웹 앱에서 HTML이 필요 없게끔 뷰 트리를 구현한 내 방법에 대해 이야기했어요.\n\n<div class=\"content-ad\"></div>\n\n이번 주에는 CSS가 희생양이 되었습니다.\n\n## JavaScript 내 CSS\n\n간단히 말해서 JavaScriptUI는 CSS-in-JavaScript 솔루션입니다. DOM API가 HTML의 기능을 JavaScript로 이동하는 데 사용될 수 있는 것과 유사하게 우리는 CSS도 마찬가지로 할 수 있습니다. 이에 대한 두 가지 이유가 있습니다.\n\n먼저, 변수, 연산자, 조건문, 반복문 및 함수와 같은 적절한 프로그래밍 개념을 사용하는 것은 스타일링과 레이아웃 구축에 훨씬 강력한 방법입니다. 손에 들고 있는 손가락 수만 있어도 우리가 원하는 거의 모든 것을 달성할 수 있습니다. 이러한 도구들은 CSS조차도 시작했기 때문에 널리 사용되는데, 그것은 어설픈 방식으로 도입되었습니다. 그러면 JavaScript가 처음부터 이 도구들을 가지고 있고 훨씬 더 나은 구현을 가지고 있을 때는 왜 CSS도 이 도구들을 도입하려고 하는지 생각해 보게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n두 번째로, CSS에는 이해하기 어려운 몇 가지 개념이 있어서 이를 이해하고 학습하며 생산적으로 활용하기가 매우 어려운 점이 있습니다. 이 추상화는 스타일링 및 레이아웃 작업 방식을 재설계할 수 있는 기회를 제공할 것입니다. 이에 대해 보통 제 사용하는 네 가지 범주는 다음과 같습니다:\n\n- 현재 상태를 유지해야 하는 충분히 좋은 개념\n- 좋지만 이름을 변경해야 하는 개념\n- 잘못 설계되어 있어서 재설계가 필요한 개념\n- 잘못된 개념이지만 재설계할 수 없는 경우\n\n그럼 시작해 봅시다.\n\n## 이 가독성이 떨어지는 방식\n\n<div class=\"content-ad\"></div>\n\n일단 시작하면 \"최상의\" 관행을 위반해서 Views를 직접 대상으로 삼을 거에요. CSS가 이를 피하려고 애를 쓰는 것을 굉장히 재밌게 생각하죠. 어떤 옵션이 있는지 알아보죠:\n\n- 인라인 스타일 사용:\n\n```js\n<p style=\"font-family: Helvetica; color: black; opacity: 0.5\">Hello World</p>\n```\n\n- 외부 스타일 사용:\n\n<div class=\"content-ad\"></div>\n\n\n```js\n#foo {\n    font-family: Helvetica;\n    color: black;\n    opacity: 0.5\n}\n```\n\n- JavaScript로 스타일 사용:\n\n```js\n<p id=\"foo\">Hello World</p>\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\nconst foo = document.getElementById(\"foo\");\nfoo.style.fontFamily = \"Helvetica\";\nfoo.style.color = \"black\";\nfoo.style.opacity = 0.5;\n```\n\n이게 참으로 간단한 것인데 이렇게 못생겼게 보일 수 있는 건 정말 놀랍죠. 프론트엔드 개발 배울 때 아무나 시도해보는 가장 기본적인 것인데도 CSS가 왜 학습 곡선이 가파른지 궁금해지죠.\n\n## 현재 브라우저 API의 주요 문제점\n\n자바스크립트에서 스타일을 설정하는 방법은 두 가지가 있습니다: 개별 속성을 설정할 수도 있고, 뷰에서 클래스를 추가/제거할 수도 있습니다. 동적으로 클래스를 만드는 건 그다지 깔끔하지 않아서 저는 첫 번째 옵션에 집중하고 싶었어요.\n\n\n<div class=\"content-ad\"></div>\n\n우리의 Views가 HTMLElements이기 때문에 이미 접근하여 스타일 속성을 설정할 수 있습니다. 이는 JavaScript의 기본적인 옵션인데, 몇 가지 문제가 있어서 별로 좋아하지 않습니다:\n\n- 스타일 속성은 View 자체의 속성이 아니라 스타일 객체의 속성이므로 보일러플레이트가 추가되고 사용하기 어려워집니다.\n- 여러 속성 이름과 값이 나쁘고 일관성이 없거나 의미가 없습니다.\n- 타입 변환 및 단위 처리가 JavaScript의 동적 특성에 비해 꽤 좋지 않습니다.\n\n그래서 단순히 Views에 스타일 속성을 추가하는 것만으로는 해결되지 않았습니다. 나머지 문제들도 해결할 수 있는 스타일 시스템이 필요했습니다.\n\n```js\n//이것도 그다지 좋지 않습니다.\nconst text = Text(\"style me\");\ntext.fontFamily = \"Helvetica\"; \ntext.color = \"black\";\ntext.opacity = 0.5;\n```\n\n<div class=\"content-ad\"></div>\n\n## Getter/setter\n\n또 다른 흔한 방법은 값을 가져오거나 설정하기 전에 값을 처리하는 getter/setter 메소드를 사용하는 것입니다. 이를 여러 가지 방법으로 달성할 수 있습니다:\n\n- 일반 속성과 접근자 설명자 사용\n- Proxy 객체 사용\n- getter/setter 메소드 쌍 사용\n\n모든 옵션에는 중요한 단점이 있습니다: 일반 속성을 사용하는 것은 여전히 장황하며, Proxy를 추가하는 것은 지나친 것 같고 (그리고 현재는 HTML 요소를 래핑하는 것을 절대 피하고 싶습니다), 모든 속성을 두 가지 메소드로 정의하고 사용하는 것은 비대합니다. 제가 원했던 것은 훨씬 더 나은 것이면서 더 간결하며 물론 새로운 뷰 계층과 호환되어야 했습니다.\n\n<div class=\"content-ad\"></div>\n\n## 아름다움이야말로 미인\n\n얼마의 실험이 있었지만, 결국 getter/setter 메서드 구문을 결합하기로 결정했습니다. 여기 JavaScriptUI를 사용한 동일한 예제입니다:\n\n```js\nText(\"Hello World\")\n    .fontFamily(\"Helvetica\")\n    .fontColor(\"black\")\n    .opacity(0.5);\n```\n\n이 방식에는 여러 가지 이점이 있습니다. 간결하고 균일하며 복잡한 작업을 내부에서 처리할 수 있습니다. 또한 메서드를 연쇄적으로 사용하여 선언적 뷰 트리와 호환됩니다.\n\n<div class=\"content-ad\"></div>\n\n각 속성은 getter/setter 메서드를 사용하여 정의됩니다. 이 메서드는 인수가 있으면 setter로 작동하고 인수가 없으면 getter로 작동합니다. 이는 JavaScript에서는 지원되지 않지만 메서드 내부에서 전달된 인수의 개수를 확인하는 간단한 조건문으로 가짜로 만들 수 있습니다.\n\n놀랍게도, setter는 View 자체를 반환할 수도 있어서 메소드 체이닝을 지원합니다.\n\n따라서 다음과 같이:\n\n```js\nconst text = Text(\"Hello World\");\ntext.setFontFamily(\"Helvetica\");\ntext.getFontFamily();\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 이렇게 할 수 있어요:\n\n```js\nText(\"안녕하세요 세계\")\n    .fontFamily(\"Helvetica\")\n    .fontFamily(); // 현재 글꼴 가져오기\n```\n\n이러한 메서드들은 CSS와 비교하면 더 나은 이름, 더 좋은 값, 더 좋은 값 유형, 심지어는 더 나은 인수(더 나은 숫자 및/또는 더 좋은 순서의 인수)를 가질 수 있어요. 이것 또한 유효한 JavaScript이므로 브라우저에서 그냥 실행하기 전에 컴파일, 트랜스파일, 빌드 또는 수정할 필요가 전혀 없어요.\n\n<div class=\"content-ad\"></div>\n\n## 메탈을 밟으세요\n\n우리가 뷰 트리로 할 때처럼 스크립팅 언어로 이동하면 거의 끝없이 새로운 가능성이 열립니다. 여기에서 JavaScriptUI가 할 수 있는 몇 가지 아이디어를 간략히 소개해 드리겠습니다:\n\n- 값을 저장하기 위해 적절한 변수와 상수 사용\n\n```javascript\nconst color = \"darkgray\";\n\nStack(\n    Text(\"Hello World\")\n        .fontColor(color),\n\n    Text(\"Hola mundo\")\n        .fontColor(color)\n);\n```\n\n<div class=\"content-ad\"></div>\n\n- 값을 평가하는 연산자를 사용합니다\n\n```js\nlet darkMode = true;\n\nText(\"Hello World\")\n    .fontColor(darkMode ? \"white\" : \"black);\n```\n\n- 개체의 속성을 참조합니다\n\n```js\nconst catImage = Image(\"cat.jpeg\")\n    .width(100)\n    .height(300);\n\nconst dogImage = Image(\"dog.jpeg\")\n    .width(catImage.width())\n    .height(catImage.height());\n```\n\n<div class=\"content-ad\"></div>\n\n- 더 복잡한 로직을 정의하기 위해 콜백(callbacks)을 사용하세요\n\n```js\nImage(\"hero.jpeg\")\n    .width(() => {\n        if (device === \"mobile\") {\n            return 400;\n        }\n        \n        if (device === \"tablet\") {\n            return 600;\n        }\n        \n        if (device === \"desktop\") {\n            return 1200;\n        }\n    });\n```\n\n- 컴포넌트를 생성하고 스타일 관리를 중앙 집중화하기 위해 사용자 정의 클래스를 사용하세요\n\n```js\nfunction Button(label) {\n    return Text(label)\n        .width(\"content\")\n        .height(\"content\")\n        .padding(12, 40, 12, 40)\n        .cornerRadius(50)\n        .backgroundColor(\"lightblue\");\n}\n\nStack(\n    Button(\"Log in\"),\n    Button(\"Subscribe\")\n);\n```\n\n<div class=\"content-ad\"></div>\n\n- 반응형 프로그래밍을 위해 상태 값(즉, 시그널)를 사용합니다.\n\n```js\nImage(\"welcome.png\")\n    .width(viewport.width) // viewport.width가 변경될 때마다 재계산됩니다.\n    .height(viewport.height); // viewport.height가 변경될 때마다 재계산됩니다.\n```\n\n이것은 JavaScriptUI에서 이미 사용 가능한 아이디어 중 일부에 불과하며, 앞으로 더 많은 아이디어가 있고 더 실험 중인 것도 많습니다.\n\n## 그럼 이만큼입니다.\n\n<div class=\"content-ad\"></div>\n\n여러분께 보여드릴 기능이 아직 많지만, 지금은 여기까지 하겠습니다. 앞으로 몇 주 동안 JavaScriptUI가 레이아웃 작성을 어떻게 간소화하는지, 상호 작용을 어떻게 처리하는지, 다양한 상태/신호 구현을 어떻게 실험하는지, 그리고 전체적인 프론트엔드 개발을 개선하기 위해 여러 가지 HTML 및 CSS 개념을 어떻게 수정했는지를 보여드릴 예정입니다.\n\n그러니 기대해 주시고, JavaScriptUI를 좋아하신다면 박수를 치거나 댓글을 달거나 다른 사람들과 공유해 주시기 바랍니다.\n\n감사합니다. 즐거운 한 주 되세요.\n\n⬅️ JavaScriptUI — 개발블로그 #2, `rip`HTML`/rip`","ogImage":{"url":"/assets/img/2024-06-20-DesigninganewstylesystemtoreplaceCSS_0.png"},"coverImage":"/assets/img/2024-06-20-DesigninganewstylesystemtoreplaceCSS_0.png","tag":["Tech"],"readingTime":6},{"title":"MERN 스택으로 웹 개발, React Native로 앱 개발 튜토리얼 8  HTML에서 의미 있는 마크업","description":"","date":"2024-06-20 00:48","slug":"2024-06-20-WebMERNAppReactNativeDevelopmentTutorial8SemanticMarkupinHTML","content":"\n\n<img src=\"/assets/img/2024-06-20-WebMERNAppReactNativeDevelopmentTutorial8SemanticMarkupinHTML_0.png\" />\n\n만약 비디오를 시청하며 배우는 것을 선호하신다면: [여기를 클릭해주세요](https://youtu.be/5ElYZ9q7u0E)\n\nMERN 스택으로의 웹 개발 여정과 React Native를 사용한 앱 개발을 통해 여러 가지 필수적인 주제를 다뤘습니다. 여덟 번째 설치에서는 웹 개발의 기본적인 측면에 초점을 맞추어 Semantic Markup in HTML을 다룰 것입니다. 의미 있는 HTML을 이해하고 활용하는 것은 접근성이 좋고 SEO에 친화적이며 유지보수가 쉬운 웹 애플리케이션을 만드는 데 중요합니다.\n\n# 시멘틱 HTML이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n시맨틱 HTML은 HTML 태그를 사용하여 내용의 의미와 구조를 전달하는 것을 말합니다. `div`나 `span`과 같은 비의미론적 태그와는 달리, 시맨틱 태그는 그 안의 내용의 역할과 중요성에 대한 정보를 제공합니다. 예시로는 `header`, `article`, `footer`, `section`, `nav` 등이 있습니다.\n\n# 시맨틱 HTML을 사용하는 이유\n\n- 접근성: 시맨틱 HTML은 스크린 리더 및 보조 기술에 맥락을 제공하여 접근성을 개선합니다. 이를 통해 장애를 가진 사용자가 웹 페이지를 더 효율적으로 탐색하고 이해할 수 있습니다.\n- SEO 이점: 검색 엔진은 시맨틱 태그를 사용하여 웹 페이지의 내용과 구조를 이해합니다. 적절한 시맨틱 마크업은 웹 사이트의 검색 엔진 순위를 향상시킬 수 있습니다.\n- 유지보수성: 시맨틱 HTML은 코드를 더 가독성 있고 유지보수하기 쉽게 만듭니다. 다른 개발자들(그리고 미래의 본인)은 웹 페이지의 구조와 내용을 이해하고 수정하는 것이 더 쉬울 것입니다.\n\n# 주요 시맨틱 HTML 요소\n\n<div class=\"content-ad\"></div>\n\n가장 일반적으로 사용되는 의미 있는 HTML 요소 중 일부를 살펴보겠습니다:\n\n# `header`\n\n`header` 요소는 소개 콘텐츠나 탐색 링크 세트를 나타냅니다. 일반적으로 사이트의 로고, 탐색 메뉴 및 기타 소개 요소를 포함합니다.\n\n```js\n<header>\n  <h1>내 웹사이트</h1>\n  <nav>\n    <ul>\n      <li><a href=\"#home\">홈</a></li>\n      <li><a href=\"#about\">소개</a></li>\n      <li><a href=\"#contact\">연락처</a></li>\n    </ul>\n  </nav>\n</header>\n```\n\n<div class=\"content-ad\"></div>\n\n# `nav`\n\n`nav` 요소는 탐색 링크 블록을 정의하는 데 사용됩니다. 이는 사용자와 검색 엔진이 웹 사이트의 구조를 이해하는 데 도움이 됩니다.\n\n```js\n<nav>\n  <ul>\n    <li><a href=\"#home\">Home</a></li>\n    <li><a href=\"#services\">Services</a></li>\n    <li><a href=\"#contact\">Contact</a></li>\n  </ul>\n</nav>\n```\n\n# `main`\n\n<div class=\"content-ad\"></div>\n\n`main` 요소는 문서의 주요 콘텐츠를 나타냅니다. 문서당 하나의 `main` 요소만 있어야하며, `article`, `aside`, `footer`, `header`, 또는 `nav` 요소의 하위 요소로 있어서는 안됩니다.\n\n```js\n<main>\n  <article>\n    <h2>내 웹사이트에 오신 것을 환영합니다</h2>\n    <p>여기에 주요 내용이 들어갑니다.</p>\n  </article>\n</main>\n```\n\n# `section`\n\n`section` 요소는 문서 내의 섹션을 정의합니다. 일반적으로 제목과 함께 콘텐츠를 주제별로 그룹화하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n# `section`\n\n\"section\" 태그는 웹 페이지 내에서 콘텐츠의 섹션을 정의하는 데 사용됩니다. 주로 그룹화된 콘텐츠에 사용됩니다.\n\n```html\n<section>\n  <h2>Our Services</h2>\n  <p>We offer a wide range of services to meet your needs.</p>\n</section>\n```\n\n# `article`\n\n`article` 요소는 독립적으로 배포될 수 있는 자체 컨텐츠 조각을 나타냅니다. 블로그 게시물, 뉴스 기사 및 유사한 콘텐츠에 자주 사용됩니다.\n\n```html\n<article>\n  <h2>Understanding Semantic HTML</h2>\n  <p>Semantic HTML is a powerful tool for web developers...</p>\n</article>\n``` \n\n\n<div class=\"content-ad\"></div>\n\n# `aside`\n\n`aside` 요소는 주변 콘텐츠와 관련이 있는 콘텐츠를 나타냅니다. 사이드바, pull quotes 및 기타 보조 콘텐츠에 자주 사용됩니다.\n\n```js\n<aside>\n  <h2>관련 링크</h2>\n  <ul>\n    <li><a href=\"#link1\">링크 1</a></li>\n    <li><a href=\"#link2\">링크 2</a></li>\n  </ul>\n</aside>\n```\n\n# `footer`\n\n<div class=\"content-ad\"></div>\n\n`푸터` 요소는 문서나 섹션의 하단을 나타냅니다. 일반적으로 메타데이터, 관련 문서へ의 링크, 그리고 문서에 대한 기타 정보를 포함합니다.\n\n```js\n<footer>\n  <p>&copy; 2024 내 웹사이트. 판권 소유.</p>\n</footer>\n```\n\n- 접근성 있는 내비게이션: 내비게이션이 접근성이 있도록 하려면 `nav`와 필요할 때 적절한 ARIA (Accessible Rich Internet Applications) 역할을 사용하세요.\n\n```js\n<nav role=\"navigation\">\n  <ul>\n    <li><a href=\"#home\">홈</a></li>\n    <li><a href=\"#services\">서비스</a></li>\n    <li><a href=\"#contact\">연락처</a></li>\n  </ul>\n</nav>\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n시멘틱 HTML은 현대 웹 개발의 기본 요소로, 접근성, SEO 및 유지보수 측면에서 다양한 이점을 제공합니다. MERN 스택 프로젝트와 React Native 앱에 시맨틱 요소를 통합하여 보다 견고하고 사용자 친화적인 애플리케이션을 만들 수 있습니다. 개발 여정을 계속하면서 HTML의 구조와 의미가 애플리케이션의 기능과 디자인과 동일한 중요성을 갖는다는 것을 기억해 주세요.\n\n다음 튜토리얼에서는 웹 및 모바일 앱 개발의 고급 주제에 대해 더 자세히 다룰 예정이니 기대해 주세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-20-WebMERNAppReactNativeDevelopmentTutorial8SemanticMarkupinHTML_0.png"},"coverImage":"/assets/img/2024-06-20-WebMERNAppReactNativeDevelopmentTutorial8SemanticMarkupinHTML_0.png","tag":["Tech"],"readingTime":4},{"title":"Tailwind 클래스 중에서 이전에 알았더라면 좋았을 것 같은 것들","description":"","date":"2024-06-20 00:46","slug":"2024-06-20-TheseTailwindClassesIWishYouKnewSooner","content":"\n\n\n![Tailwind CSS](/assets/img/2024-06-20-TheseTailwindClassesIWishYouKnewSooner_0.png)\n\nTailwind CSS는 빠른 개발과 높은 사용자 정의가 필요한 프런트엔드 프로젝트에 이상적인 강력하고 유연한 CSS 프레임워크입니다. 유틸리티 클래스, 반응형 디자인 지원, 그리고 고도로 사용자 정의가 가능한 구성을 통해 개발자들은 개발 효율성을 향상시키고 코드 일관성을 유지할 수 있습니다.\n\n# 1. isolate\n\nisolate 클래스는 요소가 새로운 쌓임 맥락을 만들지 여부를 제어하는 CSS isolation 속성을 설정하는 데 사용됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\n<div class=\"isolate\">\n  This element creates a new stacking context\n</div>\r\n```\n\n더 알아보기: https://tailwindcss.com/docs/isolation\n\n# 2. scroll-snap\n\nscroll-snap 클래스는 수평 또는 수직 스크롤이 있는 컨테이너에 적합한 스크롤 스냅 효과를 구현하는 데 사용됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\n<div class=\"scroll-snap-x snap-mandatory overflow-x-auto flex\">\n  <div class=\"snap-start\">아이템 1</div>\n  <div class=\"snap-start\">아이템 2</div>\n  <div class=\"snap-start\">아이템 3</div>\n</div>\r\n```\n\n더보기: https://tailwindcss.com/docs/scroll-snap-type\n\n# 3. pointer-events\n\npointer-events 클래스는 요소의 마우스 이벤트 응답 동작을 제어하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<div class=\"pointer-events-none\">\n    해당 요소는 포인터 이벤트를 무시합니다\n</div>\n<div class=\"pointer-events-auto\">\n    해당 요소는 포인터 이벤트에 응답합니다\n</div>\r\n```\n\n더보기: https://tailwindcss.com/docs/pointer-events\n\n# 4. truncate\n\nTailwind CSS에서 truncate는 텍스트 자르기에 사용되는 유틸리티 클래스입니다. 텍스트 내용이 컨테이너의 너비를 초과하는 경우, 생략 부분을 점 세 개(…)으로 표시하여 페이지에서 텍스트가 넘치지 않도록 합니다. 이 유틸리티 클래스는 카드 제목, 테이블 셀 등 고정 너비 텍스트 요소를 표시할 때 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n\n## This is a very long title that will be truncated with an ellipsis.\n\n![Image](/assets/img/2024-06-20-TheseTailwindClassesIWishYouKnewSooner_1.png)\n\nMore details can be found here: [Text Overflow in Tailwind CSS](https://tailwindcss.com/docs/text-overflow)\n\n# 5. Gradients: from, via, to\n\n\n<div class=\"content-ad\"></div>\n\n선형 그라디언트는 가장 일반적인 그라디언트 유형입니다. Tailwind CSS는 접두사 from-*, via-*, 및 to-*를 사용하여 그라디언트의 시작점, 중간점, 및 끝점 색상을 정의하는 클래스를 제공합니다.\n\n```js\n<div class=\"bg-gradient-to-r from-green-400 via-blue-500 to-purple-600 text-white p-10 rounded-lg shadow-lg\">\n  <h1 class=\"text-2xl font-bold\">선형 그라디언트</h1>\n  <p class=\"mt-2\">이것은 선형 그라디언트 배경이 있는 상자입니다.</p>\n</div>\n```\n\n이 예제에서:\n\n- bg-gradient-to-r: 그라디언트 방향을 왼쪽에서 오른쪽으로 정의합니다.\n- from-green-400: 그라디언트의 시작 색상을 정의합니다.\n- via-blue-500: 그라디언트의 중간 색상을 정의합니다.\n- to-purple-600: 그라디언트의 끝 색상을 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-TheseTailwindClassesIWishYouKnewSooner_2.png)\n\n더보기: https://tailwindcss.com/docs/gradient-color-stops\n\n# 6. 애니메이션\n\nTailwind CSS는 간단한 CSS 애니메이션 효과를 빠르게 추가할 수 있도록 내장된 애니메이션 클래스 세트를 제공합니다. 이 클래스에는 회전, 흔들림, 맥박 등과 같은 일반적인 애니메이션이 포함되어 있어 사용자 지정 CSS를 작성하지 않고도 빠르게 애니메이션을 적용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n다음은 일반적인 Tailwind CSS 애니메이션 클래스 몇 가지입니다:\n\n- animate-none: 애니메이션을 비활성화합니다.\n- animate-spin: 회전 애니메이션\n- animate-ping: 펄스 애니메이션\n- animate-pulse: 맥박 효과\n- animate-bounce: 튕기는 효과\n\n```html\n<div class=\"flex items-center justify-center space-x-4\">\n  <div class=\"animate-spin rounded-full h-32 w-32 border-t-2 border-b-2 border-purple-500\"></div>\n  <p class=\"text-lg font-semibold\">로딩 중...</p>\n</div>\n```\n\n![로딩 중](https://miro.medium.com/v2/resize:fit:1400/1*EgQzEHlcZlmUFIg6W3lWtw.gif)\n\n\n<div class=\"content-ad\"></div>\n\n내장된 애니메이션 클래스 외에도 Tailwind CSS를 통해 구성 파일을 통해 애니메이션을 확장하고 사용자 정의할 수 있습니다. Tailwind CSS 구성 파일에 사용자 지정 애니메이션 효과를 추가할 수 있습니다.\n\n```js\n// tailwind.config.js\nmodule.exports = {\n  theme: {\n    extend: {\n      animation: {\n        'spin-slow': 'spin 3s linear infinite',\n        'ping-slow': 'ping 2s infinite',\n      },\n    },\n  },\n};\n```\n\n이 예시에서는 spin-slow와 ping-slow라는 두 가지 사용자 정의 애니메이션을 추가했으며, 다른 애니메이션 클래스처럼 HTML에 적용할 수 있습니다.\n\n자세히 알아보기: https://tailwindcss.com/docs/animation\n\n<div class=\"content-ad\"></div>\n\n# 7. 가로세로비\n\nTailwind CSS는 요소에 특정한 가로세로비를 부여하는 aspect-ratio 플러그인을 제공합니다. 반응형 디자인을 만들거나 이미지, 비디오, 또는 다른 콘텐츠가 올바른 비율로 표시되도록 하는 데 유용합니다.\n\naspect-ratio 플러그인을 사용하기 전에 설치하고 구성해야 합니다. Tailwind CSS가 이미 설치되어 있다면, 다음 단계를 따라 aspect-ratio 플러그인을 추가할 수 있습니다:\n\n```js\nnpm install @tailwindcss/aspect-ratio\n```\n\n<div class=\"content-ad\"></div>\n\ntailwind.config.js 파일에서 다음 플러그인을 추가해주세요:\n\n```js\n// tailwind.config.js\nmodule.exports = {\n  // ...\n  plugins: [\n    require('@tailwindcss/aspect-ratio'),\n  ],\n}\n```\n\n플러그인을 구성한 후에는 HTML 파일에서 aspect-ratio 클래스를 사용할 수 있습니다.\n\n```js\n<div class=\"aspect-w-16 aspect-h-9\">\n  <iframe\n    src=\"https://www.youtube.com/embed/dQw4w9WgXcQ\"\n    title=\"YouTube video\"\n    class=\"w-full h-full\"\n    allowfullscreen\n  >\n  </iframe>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n더 많은 정보: [https://tailwindcss.com/docs/aspect-ratio](https://tailwindcss.com/docs/aspect-ratio)\n\n## 8. ring\n\nring 유틸리티는 요소에 링 효과를 적용하는 데 사용됩니다. 이 효과는 요소 주변에 하나 이상의 반투명한 테두리를 그리며 해당 요소를 강조하거나 강조합니다. 박스 그림자와 유사하지만 Tailwind에만 고유 한 ring은 더 유연하고 사용하기 쉬운 옵션을 제공합니다. 예를 들어:\n\n```js\n<div class=\"ring-2 ring-blue-500\">이 요소에는 링이 있습니다.</div>\n```\n\n<div class=\"content-ad\"></div>\n\n위 코드는 너비가 2인 요소 주위에 파란색 링을 그립니다.\n\n링의 색상을 설정하려면 ring-'색상' 클래스를 사용하세요. 불투명도를 조절하려면 값이 0부터 100까지의 범위인 ring-opacity-'값'을 사용하세요. Tailwind는 링을 요소의 외부가 아닌 내부에 그리는 ring-inset 클래스도 제공합니다.\n\n```js\n<div class=\"m-4 p-4\">\n  <div class=\"ring-1 ring-black p-4 mb-4\">너비가 1인 링</div>\n  <div class=\"ring-2 ring-red-500 p-4 mb-4\">빨간색 링이 있는 너비가 2인 링</div>\n  <div class=\"ring-4 ring-green-500 ring-opacity-50 p-4 mb-4\">너비가 4이고, 녹색이며 50% 불투명도인 링</div>\n  <div class=\"ring-4 ring-blue-500 ring-inset p-4 mb-4\">너비가 4이고 파란색인 내부 링</div>\n</div>\n```\n\n이 예시는 Tailwind CSS의 ring 클래스를 사용하여 다양한 링 효과를 생성하는 방법을 보여줍니다. 이 유틸리티 클래스를 사용함으로써 프로젝트에 링 효과를 쉽게 추가하여 사용자 인터페이스(UI)의 시각적 효과와 상호작용 경험을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-TheseTailwindClassesIWishYouKnewSooner_3.png)\n\n자세한 내용은 여기를 참조하세요: [링 너비](https://tailwindcss.com/docs/ring-width)\n\nTailwind CSS는 프론트엔드 개발자에게 강력한 도구이며, 유틸리티 클래스는 그 중 일부에 불과합니다. 이러한 도구들을 워크플로우에 통합하면 개발 프로세스를 간소화하고 동적이고 시각적으로 매력적인 웹 디자인을 만들 수 있습니다. 아직 이러한 클래스를 시도해보지 않았다면 한번 시도해보고 다음 프로젝트에 어떻게 도움이 될 수 있는지 확인해보세요.\n\n# 간단히 설명한 것 🚀\n\n\n<div class=\"content-ad\"></div>\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해주십시오 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-20-TheseTailwindClassesIWishYouKnewSooner_0.png"},"coverImage":"/assets/img/2024-06-20-TheseTailwindClassesIWishYouKnewSooner_0.png","tag":["Tech"],"readingTime":7},{"title":"알고리즘 시각화 프로그램","description":"","date":"2024-06-20 00:45","slug":"2024-06-20-AlgorithmVisualiser","content":"\n\n## HTML, CSS, 및 JavaScript를 사용한 알고리즘 시각화 도구의 기능 구현\n\n<img src=\"/assets/img/2024-06-20-AlgorithmVisualiser_0.png\" />\n\n협력과 혁신이 성공을 이끌어가는 시대에, 저희 다섯 명의 팀은 알고리즘 시각화 도구를 만드는 흥미진한 여정에 들어갔습니다. 이 프로젝트는 우리의 팀워크와 헌신의 증거뿐만 아니라 HTML, CSS, 그리고 JavaScript를 포함한 웹 개발 기초를 탐구하는 것이었습니다.\n\n본문에서는 이 프로젝트에서 구현한 핵심 기능들을 안내해 드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n버블 정렬 비주얼라이저:\n\n주어진 값으로 막대를 그렸고 막대마다 값이 적혀 있습니다. 주어진 값들을 배열에 저장하고 버블 정렬 알고리즘을 사용하여 정렬했습니다. 알고리즘에서 값들이 교환될 때마다 해당되는 막대를 강조하고 높이 값을 서로 바꾸었습니다.\n\n```js\n/* 코드베이스에서 발췌한 코드 조각 */\n    for (let i = 0; i < array.length - 1; i++) {\n        for (let j = 0; j < array.length - i - 1; j++) {\n            for (let k = 0; k < bso_bars.length; k++) {\n                if (k !== j && k !== j + 1 && k < l) {\n                    bso_bars[k].style.backgroundColor = \"brown\";\n                }\n            }\n            if (array[j] > array[j + 1]) {\n                let temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n\n                let tempHeight = bso_bars[j].style.height;\n                bso_bars[j].style.height = bso_bars[j + 1].style.height;\n                bso_bars[j + 1].style.height = tempHeight;\n                bso_bars[j].innerHTML = array[j];\n                bso_bars[j + 1].innerHTML = array[j + 1];\n                bso_bars[j].style.backgroundColor = \"#feb737\";\n                bso_bars[j + 1].style.backgroundColor = \"#feb737\";\n\n                await sleep(speed);\n            }\n        }\n        l--;\n        bso_bars[l].style.backgroundColor = \"#2fb45d\";\n\n        await sleep(speed);\n    }\n```\n\n비슷한 방식으로 선택 정렬, 병합 정렬, 퀵 정렬의 비주얼라이저도 만들었습니다.\n\n<div class=\"content-ad\"></div>\n\n연결 리스트 시각화기:\n\n연결 리스트 시각화기를 만들기 위해 d3 라이브러리(https://d3js.org/)를 사용했어요.\n\n- HTML 컨테이너 요소를 선택하고 해당 컨테이너에 높이, 너비 및 배경색 속성을 가진 SVG 요소를 추가했어요.\n- LinkedList 클래스를 정의하여 노드를 삽입하고 삭제하는 메서드로 연결 리스트를 관리했어요. insert 메서드는 지정된 인덱스에 새 노드를 생성하고 추가하거나 인덱스가 제공되지 않으면 끝에 추가해요. delete 메서드는 목록에서 특정 인덱스의 노드를 제거해요.\n- Visualise 메서드는 SVG에서 기존 시각 요소를 지워요. 시각화에 필요한 총 너비를 계산하고 텍스트 및 선을 추가하여 머리부터 시작하는 연결 리스트를 시각적으로 나타내요. 목록 노드를 순환하면서 각 노드 데이터에 대한 원과 텍스트를 추가해요. 노드 간의 링크를 나타내기 위해 화살표 마커가 달린 선을 그려요. 목록의 끝을 나타내는 최종 \"null\" 텍스트를 추가해요.\n\n```js\n/* 코드베이스에서의 일부분 */\n\nwhile (current !== null) {\n            const nodeGroup = svg.append(\"g\")\n                .attr(\"class\", \"node\")\n                .attr(\"transform\", `translate(${xPos}, ${yPos})`);\n\n            nodeGroup.append(\"circle\")\n                .attr(\"r\", nodeRadius)\n                .attr(\"stroke\", \"black\")\n                .attr(\"fill\", \"white\")\n                .attr(\"stroke-width\", 2); \n\n            nodeGroup.append(\"text\")\n                .attr(\"dy\", 5)\n                .attr(\"text-anchor\", \"middle\")\n                .text(current.data);\n\n            if (current.next !== null) {\n                svg.append(\"line\")\n                    .attr(\"class\", \"link\")\n                    .attr(\"x1\", xPos + nodeRadius)\n                    .attr(\"y1\", yPos)\n                    .attr(\"x2\", xPos + nodeRadius + nodeMargin)\n                    .attr(\"y2\", yPos)\n                    .attr(\"stroke\", \"black\")\n                    .attr(\"marker-end\", \"url(#arrow)\");\n            }\n\n            current = current.next;\n            xPos += nodeRadius * 2 + nodeMargin;\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n에라토스테네스의 체\n\n- 101개 요소가 있는 배열을 만들어 첫 번째 요소를 true로 지정하고 나머지 요소들은 false로 설정합니다.\n- 1부터 100까지의 숫자를 반복하면서 각 숫자의 모든 배수를 소수가 아닌 것으로 표시합니다. 각 반복에서 현재 인덱스와 그 인덱스의 모든 배수를 강조합니다. 소수가 아닌 모든 인덱스를 추적하여 마지막에 모든 소수를 강조합니다.\n\n```js\n/* 코드 기반의 일부 */\n \nfor (let i = 1; i < 101; i++) {\n    if (i == 1) {\n        arr[i] = true;\n        var cur = document.getElementById(`idx${i}`);\n        cur.classList.add(\"current_cell\");\n        await sleep(ms);\n        cur.classList.remove(\"current_cell\");\n        cur.classList.add(\"not_prime\")\n        if (flag) {\n            return;\n        }\n        await sleep(ms);\n    } else {\n        if (!arr[i]) {\n            var cur = document.getElementById(`idx${i}`);\n            cur.classList.add(\"current_cell\");\n            await sleep(ms);\n            for (let j = 2; j * i < 101; j++) {\n                var multiples = document.getElementById(`idx${i * j}`);\n                multiples.classList.add(\"multiple\");\n            }\n            await sleep(ms);\n            for (let j = 2; j * i < 101; j++) {\n                var multiples = document.getElementById(`idx${i * j}`);\n                multiples.classList.remove(\"multiple\");\n                arr[i * j] = true;\n                if (flag) {\n                    return;\n                }\n                multiples.classList.add(\"not_prime\");\n            }\n            cur.classList.remove(\"current_cell\");\n        }\n    }\n}\n```\n\n참조:\n\n<div class=\"content-ad\"></div>\n\n의견이나 제안이 있으시면 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-20-AlgorithmVisualiser_0.png"},"coverImage":"/assets/img/2024-06-20-AlgorithmVisualiser_0.png","tag":["Tech"],"readingTime":5},{"title":"프론트엔드 주간 다이제스트 366 2024년 6월 3일 - 6월 9일","description":"","date":"2024-06-20 00:44","slug":"2024-06-20-FrontendWeeklyDigest36639Jun2024","content":"\n\n\n![Frontend Weekly Digest](/assets/img/2024-06-20-FrontendWeeklyDigest36639Jun2024_0.png)\n\n# 웹 개발\n\n- 콘솔에서 Speculation Rules API와 놀기\n- htmx: 복잡한 솔루션 시대에서의 간단함\n- 당신의 DOM은 얼마나 깊을까요?\n- 풀 스택 웹 푸시 API 가이드\n- 챗봇 이상: AI가 프론트엔드 개발을 바꿀 수 있는 방법\n- TanStack의 라우터를 기반으로 한 새로운 메타 프레임워크 소개\n- DevTools에서 성능 워크플로를 사용자 정의하는 3가지 새로운 기능\n- WCAG에 모바일 접근성 가이드라인이 없는 이유에 대한 고찰\n\n- 효과\n- 독립적인 웹 컴포넌트의 라이브 데모\n- 그리드 항목에 푸시 애니메이션\n\n\n<div class=\"content-ad\"></div>\n\n# CSS\n\n- CapUnit: CSS 캡 단위로 디자인 문제를 어떻게 해결했는지 살펴보기\n- 모션과 함께 사용하는 CSS만으로 만든 사용자 정의 범위 슬라이더\n- 사용자 정의 상단과 하단 CSS 컨테이너 마스크\n- 유용한 CSS 팁 및 기술\n- CSS 길이 단위\n- 텍스트 입력을 세밀하게 조정하기\n- 시작해봅시다! 기본 예제를 사용한 CSS 앵커 위치 지정\n\n# JavaScript\n\n- JavaScript this 키워드 예제와 함께 설명\n- Promise.withResolvers()를 사용하여 어디서든 JavaScript Promises 제어하기\n- TypeScript에서 타입 테스트\n- 기초부터 시작하는 Promises\n- 모든 것을 병합하기 - 객체 및 기타 유형 재귀적으로 병합하기. 간단하고 작은 통합.\n- TypeScript로 API 응답 타입 작성하는 방법\n\n<div class=\"content-ad\"></div>\n\n- React\n  - React Compound Component Pattern을 활용한 Rating Component 구축 방법\n  - React & NodeJS를 위한 최고의 무료 오픈 소스 SaaS 템플릿 \n  - React.js를 이용한 클래식 스네이크 게임 구축 방법\n\n- Vue\n  - Vue와 Go를 이용한 Fullstack 앱 생성 (그리고 Tailwindcss v4)\n  - Vue에서 렌더링 최적화\n  - Vue Router의 History Modes 이해하기\n  - Vue 3 앱을 Nuxt 3로 이주하는 방법\n  \n- Angular\n  - Angular 상태 관리를 위한 Signals vs. ngOnChanges 비교\n  - Angular 아키텍처: 파트 3 - 데이터 Mocking의 용이성\n  - CSS 변수를 이용한 Angular Material Theming","ogImage":{"url":"/assets/img/2024-06-20-FrontendWeeklyDigest36639Jun2024_0.png"},"coverImage":"/assets/img/2024-06-20-FrontendWeeklyDigest36639Jun2024_0.png","tag":["Tech"],"readingTime":2},{"title":"HTML  CSS로 UI 배우기 개발자 여러분, 안녕하세요","description":"","date":"2024-06-20 00:43","slug":"2024-06-20-LearningUIfromHTMLCSSAnddevelopers","content":"\n\nUI 디자인의 공식 교육은 종종 화이트 스페이스, 계층 구조 및 색 이론과 같은 시각적 원칙에 중점을 둡니다. 그러나 UI 개발의 중요한 측면은 종종 다른 소스인 개발자들로부터 나옵니다.\n\n본 기사에서는 임배하는/주니어 디자이너와 개발자 간의 협업의 장점에 초점을 맞추어 제 경험을 바탕으로 다루고 있습니다. 저가 얻은 실용적인 지식을 강조하고 있습니다.\n\n![이미지](/assets/img/2024-06-20-LearningUIfromHTMLCSSAnddevelopers_0.png)\n\n# 1. 목업부터 제품으로의 여정\n\n<div class=\"content-ad\"></div>\n\n지인 개발자들이 나에게 한 가지 조언 중 하나는 HTML 및 CSS를 배우는 것이었습니다. 구인 게시물이 HTML과 CSS를 선택 기술로 나열할 수 있지만, 기본적인 이해는 모형과 최종 제품 사이의 간극을 줄이는 데 도움이 되었습니다. UI 요소를 구축하는 기술적 측면을 알게 되면 개발자가 필요로 하는 정보, 구성 요소가 어떻게 구축되고 상태를 변경하는 데 필요한 것을 적어도 기본적으로 이해할 수 있습니다.\n\n## 2. 노코드\n\nHTML과 CSS는 노코드 기술을 이해하는 문을 열어주었습니다. 이를 기반으로하는 노코드 도구 소개는 내가 예상했던 것보다 간단했습니다. 나는 직접 웹사이트 포트폴리오를 만들어낼 수 있었습니다.\n\n![이미지](/assets/img/2024-06-20-LearningUIfromHTMLCSSAnddevelopers_1.png)\n\n<div class=\"content-ad\"></div>\n\n# 3. 웹사이트 구조\n\nHTML을 계속하면 웹사이트 구조에 대해 더 깊은 이해를 얻게 됩니다. 이는 데스크톱과 모바일 같은 여러 플랫폼에서 쉽게 변환되는 모델을 만드는 것으로 이어집니다.\n\n# 4. 레이어 명칭\n\n파일 내의 순서를 개발자가 감사하게 여길 수 있는 기회가 있습니다. 의미 있는 이름을 가진 명확하고 조직화된 레이어는 여러분의 삶을 더 쉽게 만들 뿐만 아니라 개발자가 코드에서 이러한 이름을 사용할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 5. 소통\n\n협력은 \"왜 이것을 할 수 없는지?\"라는 질문에 대한 답을 이해할 수 있을 때 훨씬 원할해집니다. 개발자들은 제품의 기술적 제한 사항에 대한 깊은 이해를 가지고 있고 설명할 수 있는 능력이 있습니다. 이는 지식의 보고입니다. UX 디자이너로써, 개발자가 쉽게 이해할 수 있는 방식으로 내 아이디어를 제시하는 방법을 배우며, 오해 가능성을 줄입니다.\n\n# 6. 새로운 솔루션\n\n개발자들은 항상 기술적인 도전에 직면합니다. 그들과 함께 일하게되어 감사하게 생각합니다. 사용자의 요구 사항과 기술적 제약 사항을 모두 충족시키는 혁신적인 솔루션을 찾는 것이 더 쉬워지기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n# 주의: '불가능한' 마음가짐을 피하세요\n\n개발자가 아닌 디자이너로서, 코드 전문가가 되려는 것이 아니에요. 무언가를 할 전문 지식이 없다면 그건 불가능하다고 가정하고 싶지 않아요.\n\n![이미지](/assets/img/2024-06-20-LearningUIfromHTMLCSSAnddevelopers_2.png)\n\nHTML과 CSS는 들리는 것보다 훨씬 쉬워요. 이것을 배우는 데 일주일 정도를 투자할 가치가 있는지 고민 중이라면 — 낙담하지 마세요. 관련 지식은 YouTube와 다른 플랫폼에서 무료로 제공되고 있어요. 저는 개인적으로 도움이 되는 CSS 제안을 해주는 Visual Studio Code 앱부터 시작하고, Wikipedia 페이지 등의 간단한 웹사이트를 복사해보는 연습을 해보는 것을 추천합니다.\n\n<div class=\"content-ad\"></div>\n\n저는 개발자입니다. 위의 텍스트를 친절한 어조로 한국어로 번역해 드리겠습니다.\n\n다음에 개발자들과 협업할 때는 기억해 주세요 — 그들은 당신의 선생님일 수도 있습니다!\n\n*이 아이디어는 에릭 에반스가 개발한 도메인 주도 설계를 지지합니다.","ogImage":{"url":"/assets/img/2024-06-20-LearningUIfromHTMLCSSAnddevelopers_0.png"},"coverImage":"/assets/img/2024-06-20-LearningUIfromHTMLCSSAnddevelopers_0.png","tag":["Tech"],"readingTime":2},{"title":"앵귤러 Observable의 포괄적 가이드","description":"","date":"2024-06-20 00:41","slug":"2024-06-20-AComprehensiveGuidetoAngularObservables","content":"\n\n<img src=\"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png\" />\n\n# 소개\n\nAngular에서 Observables는 반응형 프로그래밍의 필수 요소로, 데이터 스트림을 통한 변경 전파에 중점을 둔 프로그래밍 패러다임입니다. Observables는 개발자가 콜백 또는 프로미스와 같은 전통적인 기술보다 비동기 데이터와 이벤트를 보다 간단하고 효율적으로 처리할 수 있게 합니다.\n\nObservables는 실시간 데이터 업데이트, 이벤트 처리 및 더 많은 기능을 필요로 하는 복잡한 애플리케이션을 구축하는 강력한 도구입니다. 이 글에서는 Angular에서 Observables의 기본 개념, 작동 방식 및 가장 일반적인 사용 사례에 대해 알아보겠습니다. 이 글을 마치면 Observables가 어떻게 더 나은 Angular 애플리케이션을 구축하는 데 도움을 줄 수 있는지에 대해 확고한 이해를 갖게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 옵저버블이란 무엇인가요?\n\n옵저버블은 Angular에서 반응형 프로그래밍의 핵심 기능입니다. 옵저버블은 시간에 따라 관찰할 수 있는 데이터 스트림입니다. 옵저버블은 배열이나 다른 데이터 구조와 유사하지만 몇 가지 주요 차이점이 있습니다:\n\n- 옵저버블은 시간에 따라 여러 값을 반환할 수 있지만 배열은 정적이며 고정된 값 집합을 포함합니다.\n- 옵저버블은 사용자 입력, 네트워크 요청 및 타이머와 같은 비동기 데이터 소스를 다룰 수 있지만 배열과 같은 동기 데이터 구조는 그렇지 않습니다.\n- 옵저버블은 다양한 방식으로 결합, 변환 및 조합되어 더 복잡한 데이터 스트림을 생성할 수 있습니다.\n\n옵저버블은 Angular 프레임워크의 중심 요소이며 이벤트 처리, 데이터 바인딩 및 비동기 프로그래밍에 널리 사용됩니다. 다음 섹션에서 Angular에서 옵저버블을 어떻게 생성하는지 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Observable Creation\n\n앵귤러에서 Observable을 생성하는 여러 가지 방법이 있습니다. 사용 사례와 작업 중인 데이터 소스에 따라 다릅니다. 여기 몇 가지 일반적인 기술이 있습니다:\n\n- 처음부터 Observable 생성: Observable 생성자를 사용하여 처음부터 Observable을 만들 수 있습니다. 이를 사용하면 사용자 지정 데이터 스트림을 정의하고 next() 메서드를 사용하여 수동으로 값을 전달할 수 있습니다. 다음은 예시입니다:\n\n```js\nconst myObservable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n- RxJS 연산자 사용하기: RxJS는 Angular에서 Observables와 함께 작업하는 데 널리 사용되는 라이브러리로, Observables을 생성, 변환 및 결합하는 다양한 연산자를 제공합니다. 예를 들어, of() 연산자를 사용하여 다음과 같이 일정한 값 집합을 방출하는 Observable을 생성할 수 있습니다:\n\n```js\nimport { of } from 'rxjs';\n\nconst myObservable = of(1, 2, 3);\n```\n\n- 이벤트에서 Observables 생성하기: DOM 이벤트나 다른 이벤트 소스로부터 Observable을 만들 수 있습니다. 이를 위해 fromEvent() 연산자를 사용할 수 있습니다. 이를 사용하면 사용자 입력이나 다른 이벤트를 반응적이고 효율적으로 처리할 수 있습니다. 다음은 예제입니다:\n\n```js\nimport { fromEvent } from 'rxjs';\n\nconst button = document.getElementById('myButton');\nconst clickObservable = fromEvent(button, 'click');\n```\n\n<div class=\"content-ad\"></div>\n\nAngular에서 Observable을 만드는 많은 다른 기술들 중에는 promises, timers, 그리고 HTTP 요청과 함께 작업하는 방법이 포함됩니다. 다음 섹션에서는 operators를 사용하여 Observables를 다루는 방법을 살펴볼 것입니다.\n\n# Observables와 Operators\n\nOperators는 Angular에서 Observables를 다루는 핵심 기능입니다. Operators는 Observables를 다양한 방법으로 변환하거나 조작할 수 있게 해주는 함수들입니다. Angular에서 가장 일반적으로 사용되는 operators 중 일부는 다음과 같습니다:\n\n- map(): map() operator는 Observable이 방출하는 각 값에 함수를 적용하여 변환합니다. 예를 들어, map()을 사용하여 숫자 스트림을 이들의 제곱 스트림으로 변환할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst numbers = of(1, 2, 3);\nconst squared = numbers.pipe(map(x => x * x));\n\nsquared.subscribe(x => console.log(x)); // 출력: 1, 4, 9\n```\n\n- filter(): filter() 연산자는 Observable이 지정된 조건을 충족하지 않는 값을 방출하지 않도록 필터링합니다. 예를 들어, filter()를 사용하여 스트림에서 짝수만 방출할 수 있습니다. 아래와 같이:\n\n```js\nimport { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst numbers = of(1, 2, 3, 4, 5);\nconst evenNumbers = numbers.pipe(filter(x => x % 2 === 0));\n\nevenNumbers.subscribe(x => console.log(x)); // 출력: 2, 4\n```\n\n- merge(): merge() 연산자는 여러 Observable을 하나의 값 스트림으로 결합합니다. 예를 들어, 두 개의 숫자 스트림을 단일 스트림으로 결합할 때 merge()를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of, merge } from 'rxjs';\n\nconst numbers1 = of(1, 2, 3);\nconst numbers2 = of(4, 5, 6);\nconst merged = merge(numbers1, numbers2);\n\nmerged.subscribe(x => console.log(x)); // Output: 1, 2, 3, 4, 5, 6\n```\n\nAngular에는 tap(), switchMap(), 그리고 catchError()와 같은 다양한 연산자가 있습니다. 이러한 연산자들은 Angular 애플리케이션에서 더 강력하고 효율적인 데이터 스트림을 생성하는 데 도움이 될 수 있습니다.\n\n# Observables 구독하기\n\nObservable이 방출하는 데이터를 사용하려면 해당 Observable을 구독해야 합니다. Observable을 구독하는 것은 이벤트 리스너를 등록하는 것과 유사하며, Observable이 방출하는 값을 받아 처리할 수 있게 해줍니다. 다음은 Observable을 구독하는 예제입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\n\nconst numbers = of(1, 2, 3);\nnumbers.subscribe(\n  value => console.log(value),\n  error => console.error(error),\n  () => console.log('Completed')\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 Observable을 만들어 정해진 값 집합을 방출합니다. 그런 다음 Observable을 구독하고 세 가지 콜백 함수를 인수로 제공합니다:\n\n- 첫 번째 함수는 Observable에서 방출된 각 값에 대해 처리하고 콘솔에 기록합니다.\n- 두 번째 함수는 Observable 스트림 중 발생한 오류를 처리하고 콘솔에 기록합니다.\n- 세 번째 함수는 Observable이 완료될 때 호출되어 콘솔에 메시지를 기록합니다.\n\n이 코드를 실행하면 콘솔에 1, 2, 3 값이 기록된 후 \"Completed\" 메시지가 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\nObservables는 게으르다는 것이 중요합니다. 이는 구독하지 않는 한 값을 방출하지 않는다는 뜻입니다. Angular 애플리케이션에서 데이터를 검색하고 처리하는 방법과 시기를 제어할 수 있게 해줍니다. 그러나 Observables를 사용한 작업이 끝난 후에는 구독을 해제하여 메모리 누수와 다른 문제를 방지하는 것도 중요합니다.\n\n# Angular 서비스에서 Observables 사용하기\n\nAngular에서 Observables를 사용하는 가장 일반적인 사례 중 하나는 서비스에서 사용됩니다. 여기서 Observables를 사용하여 API, 데이터베이스 또는 기타 소스에서 데이터를 가져오고 조작할 수 있습니다. 다음은 가짜 API에서 데이터를 가져오기 위해 Observables를 사용하는 간단한 서비스 예제입니다:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  private apiUrl = '<https://jsonplaceholder.typicode.com/posts>';\n  constructor(private http: HttpClient) {}\n  getPosts(): Observable<any[]> {\n    return this.http.get<any[]>(this.apiUrl);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 Angular의 내장 HttpClient를 사용하여 URL이 https://jsonplaceholder.typicode.com/posts인 가짜 API에 GET 요청을 하는 DataService라는 서비스를 만듭니다. 우리는 any[] 유형의 Observable을 반환하는 getPosts() 메서드를 정의합니다. \n\n컴포넌트에서 이 서비스를 사용하려면 생성자에 주입하고 getPosts() 메서드를 호출하면 됩니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <h1>Posts</h1>\n    <ul>\n      <li *ngFor=\"let post of posts\">{{ post.title }}</li>\n    </ul>\n  `\n})\nexport class AppComponent {\n  posts: any[];\n  constructor(private dataService: DataService) {}\n  ngOnInit() {\n    this.dataService.getPosts().subscribe(\n      data => this.posts = data,\n      error => console.error(error),\n      () => console.log('Posts loaded')\n    );\n  }\n}\n```\n\n이 예제에서는 AppComponent라는 컴포넌트를 만들어 DataService를 사용하여 가짜 API에서 게시물 목록을 가져옵니다. ngOnInit() 메서드를 정의하여 getPosts() Observable을 구독하고 전달된 값들을 처리합니다. Observable이 완료되면 컴포넌트의 posts 속성을 검색된 데이터로 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n이 방법으로 Obserbables와 서비스를 사용하면 Angular 애플리케이션에서 강력하고 유연한 데이터 파이프라인을 만들 수 있어요.\n\n# Observables 조합하기\n\nObservables의 가장 강력한 기능 중 하나는 다양한 방법으로 조합하고 조작할 수 있는 기능입니다. 이를 통해 다양한 유즈 케이스를 처리하는 복잡한 데이터 파이프라인을 만들 수 있어요. Angular에서 Observables를 조합하는 방법의 예시 몇 가지는 다음과 같아요:\n\n- Merge: merge() 연산자를 사용하면 여러 Observables을 단일 스트림으로 결합할 수 있어요. 여기에 예시가 있어요:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport { interval, merge } from 'rxjs';\r\n\r\nconst source1 = interval(1000);\r\nconst source2 = interval(2000);\r\nconst merged = merge(source1, source2);\r\nmerged.subscribe(\r\n  value => console.log(value)\r\n);\r\n```\r\n\r\n이 예시에서는 interval() 연산자를 사용하여 1초마다 값과 2초마다 값이 발행되는 두 개의 Observable을 생성합니다. 그런 다음 merge() 연산자를 사용하여 이 두 개의 Observable을 하나의 스트림으로 병합합니다. 마지막으로 병합된 Observable을 구독하고 각 발행된 값마다 콘솔에 기록합니다.\r\n\r\n- CombineLatest: combineLatest() 연산자를 사용하면 여러 Observable이 발행한 최신 값들을 하나의 스트림으로 결합할 수 있습니다. 다음은 예시입니다:\r\n\r\n```js\r\nimport { interval, combineLatest } from 'rxjs';\r\n\r\nconst source1 = interval(1000);\r\nconst source2 = interval(2000);\r\nconst combined = combineLatest(source1, source2);\r\ncombined.subscribe(\r\n  value => console.log(value)\r\n);\r\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 interval() 연산자를 사용하여 각각 1초마다 값과 2초마다 값이 방출되는 두 Observables을 만듭니다. 그런 다음 combineLatest() 연산자를 사용하여 두 Observables에서 최신 값들을 결합하여 단일 스트림으로 만듭니다. 마지막으로 결합된 Observable에 구독하여 각 방출된 값을 콘솔에 기록합니다.\n\n- Zip: zip() 연산자를 사용하면 여러 Observables에서 방출된 값들을 배열로 결합할 수 있습니다. 다음은 예시입니다:\n\n```js\nimport { of, zip } from 'rxjs';\n\nconst source1 = of(1, 2, 3);\nconst source2 = of('a', 'b', 'c');\nconst zipped = zip(source1, source2);\nzipped.subscribe(\n  value => console.log(value)\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 일정한 값 집합을 방출하는 두 Observables을 만듭니다. 그런 다음 zip() 연산자를 사용하여 두 Observables에서 방출한 값을 배열로 결합합니다. 마지막으로 zipped Observable을 구독하여 각 방출된 값을 콘솔에 기록합니다.\n\n<div class=\"content-ad\"></div>\n\n이 방식으로 옵저버블을 결합하고 조작함으로써, Angular 애플리케이션에서 다양한 유즈 케이스를 처리할 수 있는 복잡한 데이터 파이프라인을 만들 수 있습니다.\n\n# 데이터를 변형하고 필터링하기 위해 오퍼레이터 사용하기\n\n오퍼레이터는 옵저버블이 방출한 데이터를 변형하거나 필터링하거나 기타 방식으로 조작할 수 있는 함수들입니다. Angular 옵저버블과 함께 사용할 수 있는 많은 오퍼레이터가 RxJS 라이브러리에 제공되며, 여기에 몇 가지 예시가 있습니다:\n\n- Map: map() 오퍼레이터를 사용하면 옵저버블에서 방출된 각 값을 새 값으로 변환할 수 있습니다. 다음은 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst mapped = source.pipe(map(value => value * 2));\nmapped.subscribe(\n  value => console.log(value)\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 값을 고정된 세트로 방출하는 Observable을 생성합니다. 그런 다음 map() 연산자를 사용하여 각 방출된 값에 2를 곱해 변환합니다. 마지막으로 매핑된 Observable에 구독하고 각 방출된 값을 콘솔에 로깅합니다.\n\n- Filter: filter() 연산자를 사용하면 주어진 조건에 따라 Observable에서 방출된 값을 필터링할 수 있습니다. 다음은 예시입니다:\n\n```js\nimport { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst filtered = source.pipe(filter(value => value % 2 === 0));\nfiltered.subscribe(\n  value => console.log(value)\n);\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 of() 연산자를 사용하여 Observable을 만듭니다. 이 연산자는 고정된 값 집합을 방출합니다. 그런 다음 filter() 연산자를 사용하여 짝수인 값만 방출하도록합니다. 마지막으로 필터링된 Observable을 구독하고 콘솔에 각 방출된 값을 기록합니다.\n\n- Reduce: reduce() 연산자를 사용하면 Observable이 방출하는 값들을 누적하고 단일 값으로 반환할 수 있습니다. 다음은 예제입니다:\n\n```js\nimport { of } from 'rxjs';\nimport { reduce } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst reduced = source.pipe(reduce((acc, value) => acc + value));\nreduced.subscribe(\n  value => console.log(value)\n);\n```\n\n이 예시에서는 of() 연산자를 사용하여 고정된 값 집합을 방출하는 Observable을 만듭니다. 그런 다음 reduce() 연산자를 사용하여 Observable이 방출하는 값들을 누적하고 그 합계를 반환합니다. 마지막으로 누적된 Observable을 구독하고 콘솔에 최종 누적 값의 로그를 남깁니다.\n\n<div class=\"content-ad\"></div>\n\n연산자인 map(), filter(), reduce()와 같은 것을 사용하여 Observable이 방출하는 데이터를 변환, 필터링하고 조작하여 Angular 애플리케이션에서 특정한 사용 사례에 맞게 맞출 수 있습니다.\n\n# Subjects를 사용하여 값을 방출하기\n\nObservable 외에도 RxJS 라이브러리는 여러 구독자에게 값을 방출할 수 있는 Subject 클래스를 제공합니다. Subject는 Observable과 Observer 둘 다이므로 값을 방출하고 다른 Observables에 구독할 수 있습니다.\n\n다음은 Angular에서 Subject를 생성하는 예제입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Subject } from 'rxjs';\n\nexport class MyComponent {\n  mySubject = new Subject<string>();\n  emitValue(value: string) {\n    this.mySubject.next(value);\n  }\n}\n```\n\n이 예시에서는 문자열 유형의 Subject를 생성하고 MyComponent 클래스의 속성으로 저장합니다. 그런 다음 emitValue() 메서드를 정의하고 해당 값을 mySubject 객체의 next() 메서드를 호출하여 구독자에게 해당 값을 방출합니다.\n\nSubject를 다른 Observable처럼 구독할 수 있습니다:\n\n```js\nmyComponent.mySubject.subscribe(\n  value => console.log(value)\n)\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 myComponent 객체의 mySubject Subject에 구독(subscribe)하여 발생한 모든 값들을 콘솔에 기록합니다.\n\n한 가지 주의할 점은 Subject를 구독할 때 Subject가 생성된 이후에 발생한 모든 값들을 받게 되는 것입니다. 구독 이후에 발생한 값들만 받고 싶다면 BehaviorSubject를 사용할 수 있습니다:\n\n```js\nimport { BehaviorSubject } from 'rxjs';\n\nexport class MyComponent {\n  mySubject = new BehaviorSubject<string>('initial value');\n  emitValue(value: string) {\n    this.mySubject.next(value);\n  }\n}\n```\n\n이 예시에서는 string 타입의 BehaviorSubject를 생성하고 초기값을 `initial value`로 설정합니다. BehaviorSubject를 구독하면 초기값을 먼저 받은 뒤에 구독 이후에 발생한 모든 값들을 받게 됩니다.\n\n<div class=\"content-ad\"></div>\n\nSubject 및 BehaviorSubject을 사용하면 Angular 애플리케이션에서 값들을 발행하고 구독하는 강력한 방법이 될 수 있습니다. 이를 통해 컴포넌트와 서비스 간에 데이터를 쉽게 공유할 수 있으며 복잡한 데이터 흐름 시나리오를 간단화할 수 있습니다.\n\n# 결론\n\nAngular Observables은 Angular 애플리케이션의 비동기 데이터 흐름을 관리하는 강력한 도구입니다. RxJS 라이브러리의 도움으로 사용자 입력부터 HTTP 요청까지 모두 처리할 수 있는 Observables을 만들고 조작할 수 있습니다.\n\n이 글에서는 Observables의 기본을 다룰 때, 생성하고 구독하는 방법 및 연산자를 사용하여 발행된 값들을 변환하고 필터링하는 방법을 다뤘습니다. 또한 Subject을 사용하여 여러 구독자에게 값을 발행하는 고급 주제도 살펴보았습니다.\n\n<div class=\"content-ad\"></div>\n\n앵귤러 옵저버블을 효과적으로 활용하는 방법을 이해하면, 더 반응형이고 빠른 응용 프로그램을 만들어 사용자 경험을 향상시킬 수 있습니다. 간단한 양식 데이터든 복잡한 데이터 스트림이든 옵저버블을 사용하면 쉽게 관리할 수 있습니다.\n\n다음에 앵귤러 응용 프로그램을 작성할 때는 데이터 흐름 요구 사항을 처리하기 위해 옵저버블을 사용해보세요. 강력한 기능과 다양한 기능 세트로, 보다 견고하고 유연하며 확장 가능한 응용 프로그램을 만들 수 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png"},"coverImage":"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png","tag":["Tech"],"readingTime":12},{"title":"OpenLayers를 사용하여 Ionic 앱 만들기","description":"","date":"2024-06-20 00:40","slug":"2024-06-20-BuildinganIonicAppwithOpenLayers","content":"\n\n요즘 애플리케이션에서 대화식 및 동적 지도가 점점 필요해지면, OpenLayers와 같은 강력한 지도 라이브러리를 모바일 애플리케이션에 통합하는 것이 중요합니다. 이 튜토리얼에서는 Angular의 독립 구성 요소 기능을 활용하여 OpenLayers를 사용하는 Ionic 앱을 생성하는 과정을 안내합니다.\n\n# 소개\n\nOpenLayers는 모든 지도 요구에 대한 고성능이며 각종 기능을 갖춘 라이브러리입니다. Ionic의 강력한 모바일 앱 구축 프레임워크와 결합하면 강력하고 시각적으로 매력적인 지도 기반 애플리케이션을 만들 수 있습니다. 함께 시작해보겠습니다!\n\n![Building an Ionic App with OpenLayers](/assets/img/2024-06-20-BuildinganIonicAppwithOpenLayers_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 준비물\n\n시작하기 전에, 컴퓨터에 다음 사항이 설치되어 있는지 확인해주세요:\n\n- Node.js와 npm: 다운로드 및 설치\n- Ionic CLI: npm을 이용하여 전역으로 설치하기\n\n```js\nnpm install -g @ionic/cli\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 1: Ionic Framework 설정하기\n\n먼저, 새 Ionic 프로젝트를 만들어 봅시다:\n\n```js\nionic start myOpenLayersApp blank --type=angular\ncd myOpenLayersApp\n```\n\n# 단계 2: OpenLayers 설치하기\n\n<div class=\"content-ad\"></div>\n\n프로젝트 디렉토리로 이동하여 OpenLayers를 설치해주세요:\n\n```js\nnpm install ol\n```\n\n# 단계 3: 지도를 위한 독립형 컴포넌트 생성\n\nAngular CLI를 사용하여 독립형 컴포넌트를 생성해보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nng generate component open-layers-map --standalone\n```\n\n# 단계 4: tsconfig.json에서 Lib 체크 플래그 설정\n\n프로젝트 디렉토리로 이동하여 tsconfig.json 파일을 엽니다. compilerOptions 아래에 아래 줄을 추가합니다.\n\n```js\n \"skipLibCheck\": true\n```\n\n<div class=\"content-ad\"></div>\n\n\n![OpenLayers Map](/assets/img/2024-06-20-BuildinganIonicAppwithOpenLayers_1.png)\n\n# 컴포넌트 수정\n\n- open-layers-map.component.ts\n\n```javascript\nimport { Component, AfterViewInit, ElementRef, ViewChild } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Map, View } from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\nimport { fromLonLat } from 'ol/proj';\n\n@Component({\n  selector: 'app-open-layers-map',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './open-layers-map.component.html',\n  styleUrls: ['./open-layers-map.component.scss']\n})\nexport class OpenLayersMapComponent implements AfterViewInit {\n  @ViewChild('mapElement', { static: false }) mapElement!: ElementRef;\n  map!: Map;\n\n  ngAfterViewInit() {\n    this.map = new Map({\n      target: this.mapElement.nativeElement,\n      layers: [\n        new TileLayer({\n          source: new OSM()\n        })\n      ],\n      view: new View({\n        center: fromLonLat([0, 0]),\n        zoom: 2\n      })\n    });\n  }\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\n2. open-layers-map.component.html:\n\n```html\n<div #mapElement class=\"map\"></div>\n```\n\n3. open-layers-map.component.scss:\n\n```scss\n.map {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n}\n```  \n\n<div class=\"content-ad\"></div>\n\n# 단계 4: 지도 컴포넌트를 메인 페이지에 통합하기\n\n- home.page.ts:\n\n```js\nimport { Component } from '@angular/core';\nimport { IonicModule } from '@ionic/angular';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { OpenLayersMapComponent } from '../open-layers-map/open-layers-map.component';\n\n@Component({\n  selector: 'app-home',\n  templateUrl: 'home.page.html',\n  styleUrls: ['home.page.scss'],\n  standalone: true,\n  imports: [IonicModule, CommonModule, FormsModule, OpenLayersMapComponent]\n})\nexport class HomePage {}\n```\n\n2. home.page.html:\n\n<div class=\"content-ad\"></div>\n\n```js\n<ion-header>\n  <ion-toolbar>\n    <ion-title>\n      OpenLayers Map\n    </ion-title>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content>\n  <app-open-layers-map></app-open-layers-map>\n</ion-content>\n```\n\n# 5단계: 애플리케이션 실행하기\n\n작성한 애플리케이션을 확인하려면 다음 명령어를 사용하세요:\n\n```js\nionic serve\n```\n\n<div class=\"content-ad\"></div>\n\nIonic 앱의 메인 페이지에서 간단한 OpenLayers 지도를 확인할 수 있어요.\n\n# 결론\n\nAngular의 독립 구성 요소를 활용하여 Ionic 앱에 OpenLayers를 통합하는 과정은 간단합니다. 이 설정을 사용하면 휴대폰 애플리케이션을 위한 대화식이고 기능이 풍부한 지도를 만들 수 있어요. 필요에 따라 레이어, 컨트롤 및 상호 작용을 추가하여 지도를 더 맞춤화해보세요.\n\n즐거운 맵핑 되세요!","ogImage":{"url":"/assets/img/2024-06-20-BuildinganIonicAppwithOpenLayers_0.png"},"coverImage":"/assets/img/2024-06-20-BuildinganIonicAppwithOpenLayers_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러의 파이프","description":"","date":"2024-06-20 00:37","slug":"2024-06-20-PipesinAngular","content":"\n\n<img src=\"/assets/img/2024-06-20-PipesinAngular_0.png\" />\n\n알다시피, Angular은 현대 웹 애플리케이션을 구축하는 인기 있는 웹 프레임워크이며, 개발자에게 많은 강력한 기능을 제공합니다.\n\n이러한 기능 중 하나인 파이프는 데이터를 표시하기 전에 간단하고 효율적인 방법으로 변환하는 기능을 제공합니다.\n\n이 기사에서는 Angular의 파이프에 대해 포괄적으로 살펴보겠습니다. 그 중에는 파이프가 무엇인지, 어떻게 사용하는지, 몇 가지 일반적인 사용 사례 예시가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n목차:\n\n- 소개\n- 순수 및 불순 파이프\n- 내장 파이프\n- 사용자 정의 파이프 생성\n- 파이프 연결하기\n- 주요 포인트 요약\n- Angular에서 파이프 사용하는 최상의 실천 방법\n- 마무리와 권장 사항\n\nAngular에서 파이프 이해하고 구현하는 데 관련된 모든 개념을 다룰 예정입니다.\n\n그럼 시작해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- Angular에서의 Pipes 소개\n\nAngular의 Pipes는 응용 프로그램에서 데이터를 표시하기 전에 변환할 수 있도록 해주는 기능입니다.\n\nPipes를 사용하면 데이터를 형식화, 필터링, 정렬할 수 있으며 템플릿 기반 및 반응형 폼뿐만 아니라 기타 Angular 구성 요소 및 서비스와 함께 사용할 수 있습니다.\n\n# 2. 순수 및 불순한 Pipes\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서는 파이프가 순수한지 또는 불순한지로 나뉩니다.\n\n순수 파이프는 상태를 가지지 않고, 출력에 영향을 미칠 수 있는 내부 상태가 없도록 설계되어 있습니다.\n\n그 대신, 순수 파이프는 입력 데이터를 가져와 변환된 출력 데이터를 반환합니다. 순수 파이프는 또한 메모이제이션되어 있어, 입력 데이터가 마지막으로 파이프가 호출된 이후 변경되지 않았다면, 파이프는 다시 실행되지 않습니다.\n\n순수 파이프를 사용하는 장점은 필요할 때에만 실행되기 때문에 앵귤러 애플리케이션의 성능을 향상시킬 수 있다는 것입니다. 게다가, 순수 파이프는 불필요한 변경 감지 주기를 방지할 수 있어 전체 애플리케이션 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nAngular에서 순수 파이프를 만들려면 다음처럼 @Pipe 데코레이터에 pure: true 옵션을 추가해야 합니다:\n\n```js\n@Pipe({\n  name: 'myPurePipe',\n  pure: true\n})\n```\n\n일부 경우에는 무즙 파이프를 사용하는 것이 유용할 수 있습니다. 예를 들어, 무거운 계산이 필요하거나 외부 API에서 데이터를 가져와야 할 때입니다.\n\n그러나 가능한한 항상 성능을 향상시키고 불필요한 변경 감지 주기를 방지하기 위해 순수 파이프를 사용하는 것이 일반적으로 권장됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 3. Angular 내장 파이프\n\nAngular에는 템플릿에서 사용할 수 있는 여러 내장 파이프들이 내장되어 있습니다. 아래는 Angular에서 가장 일반적으로 사용되는 몇 가지 내장 파이프입니다:\n\n- 통화 파이프\n- 날짜 파이프\n- JSON 파이프\n- 소문자 변환 파이프\n- 대문자 변환 파이프\n- 퍼센트 파이프\n- Slice 파이프\n- TitleCase 파이프\n- Async 파이프\n\n## 1. 통화 파이프\n\n<div class=\"content-ad\"></div>\n\n현재 로케일에 따라 통화 기호, 소수점 구분 기호 및 그룹 구분 기호를 고려하여 사용자 친화적인 형식으로 통화 값을 표시하는 방법을 제공합니다.\n\nAngular에서 CurrencyPipe를 사용하는 예시입니다:\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  price: number = 12345.6789;\n}\n```\n\n<div class=\"content-ad\"></div>\n\napp.component.html:\n\n```html\n<div>\n  <h2>Using CurrencyPipe</h2>\n  <p>Price: {{ price | currency }}</p>\n  <p>Price: {{ price | currency:'EUR':'symbol-narrow':'4.2-2' }}</p>\n</div>\n```\n\n위의 예제에서 숫자 값인 12345.6789를 보유하는 price 변수가 있습니다. 그런 다음 화폐 파이프를 사용하여 템플릿에서 price 변수를 화폐 값으로 형식화합니다.\n\n파이프의 첫 번째 사용은 기본 설정으로 이루어집니다. 현재 로캘의 기본 화폐로 price 변수를 형식화합니다.\n\n<div class=\"content-ad\"></div>\n\n파이프의 두 번째 사용 예시에는 몇 가지 추가 매개변수가 포함되어 있습니다. 이는 가격 변수를 EUR 통화 기호로, 좁은 심볼로 형식화시키며, 형식 문자열은 4.2-2로 설정되어 있습니다. 형식 문자열은 십진 분리자 앞에 최소 4자리, 십진 분리자 뒤에 최대 2자리를 가지고 있어야 하며 로케일의 십진 및 그룹화 분리자를 사용해야 합니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n```js\nCurrencyPipe 사용\n가격: $12,345.68\n가격: €12,345.68\n```\n\n첫 번째 출력 행은 현재 로캘에 대해 기본으로 형식화된 통화 값을 보여줍니다. 두 번째 출력 행은 유로 통화 기호, 좁은 심볼 및 특정 형식 문자열을 사용한 사용자 지정 형식화된 통화 값을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 2. Date Pipe\n\n현재 로캘에 기반을 둔 사용자 친화적인 형식으로 날짜 값을 표시하는 방법을 제공합니다.\n\n다음은 Angular에서 DatePipe를 사용하는 예시입니다:\n\napp.component.ts:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  currentDate: Date = new Date();\n}\n```\n\napp.component.html:\n\n```js\n<div>\n  <h2>Using DatePipe</h2>\n  <p>현재 날짜: {{ currentDate | date }}</p>\n  <p>현재 날짜: {{ currentDate | date:'fullDate' }}</p>\n  <p>현재 날짜: {{ currentDate | date:'short' }}</p>\n</div>\n```\n\n위 예제에서는 현재 날짜 객체를 저장하는 currentDate 변수가 있습니다. 그런 다음 템플릿에서 currentDate 변수를 날짜 값으로 형식화하기 위해 date 파이프를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nDatePipe를 사용한 경우\n현재 날짜: 2023년 3월 3일 금요일\n현재 날짜: 2023년 3월 3일\n현재 날짜: 23. 3. 3. 오전 12:17\n\n첫 번째 줄은 현재 로캘에 맞는 기본 형식으로 날짜 값을 표시합니다. 두 번째 줄은 currentDate 변수를 전체 날짜 문자열로 서식화한 것을 보여줍니다. 세 번째 줄은 currentDate 변수를 짧은 날짜 문자열로 서식화한 것을 보여줍니다.\n\n## Json Pipe\n\nJson 파이프를 사용하면 객체 값을 서식이 지정된 JSON 문자열로 표시할 수 있습니다.\n```\n\n<div class=\"content-ad\"></div>\n\n이렇게 하면 Angular에서 JsonPipe를 사용할 수 있습니다:\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myObject: any = {\n    name: 'John',\n    age: 30,\n    email: 'john@example.com'\n  };\n}\n```\n\napp.component.html:\n\n<div class=\"content-ad\"></div>\n\n```js\r\n<div>\n  <h2>JsonPipe 사용하기</h2>\n  <pre>{ myObject | json }</pre>\n</div>\r\n```\n\n위 예제에서는 이름, 나이, 이메일 속성을 포함한 객체를 보유하는 myObject 변수가 있습니다. 그런 다음 json 파이프를 사용하여 myObject 변수를 JSON 문자열로 변환합니다.\n\n출력에서 공백과 형식을 보존하기 위해 pre 태그가 사용됩니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nJsonPipe 사용\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"email\": \"john@example.com\"\n}\n```\n\n출력된 결과는 myObject 변수가 포맷된 공백과 함께 JSON 문자열로 변환된 것을 보여줍니다. 이는 디버깅 및 객체 값을 읽기 쉬운 형식으로 표시하는 데 유용할 수 있습니다.\n\n## 4. LowerCase 파이프\n\nAngular에서 LowerCasePipe를 사용하는 예제입니다.\n\n<div class=\"content-ad\"></div>\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myString: string = '대소문자가 혼합된 문자열입니다';\n}\n```\n\napp.component.html:\n\n```js\n<div>\n  <h2>LowerCasePipe 사용하기</h2>\n  <p>원본 문자열: {{ myString }}</p>\n  <p>소문자로 변환된 문자열: {{ myString | lowercase }}</p>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예제에서는 혼합된 대소문자 값을 저장하는 myString 변수가 있습니다. 그런 다음 소문자 파이프를 사용하여 myString 변수를 소문자로 변환합니다.\n\n위의 코드를 실행하면 다음과 같은 출력이 표시됩니다:\n\n```js\nUsing LowerCasePipe\nOriginal String: This is a STRING in Mixed CASE\nLowercased String: this is a string in mixed case\n```\n\n첫 번째 출력 라인에는 원래 문자열 값이 표시됩니다. 두 번째 출력 라인에는 소문자 파이프를 사용한 후 변환된 문자열 값이 표시됩니다. 문자열의 모든 문자가 소문자로 변환된 것에 유의하세요.\n\n<div class=\"content-ad\"></div>\n\n## 5. 대문자 변환 파이프\n\nAngular에서 UpperCasePipe를 사용하는 예시입니다:\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myString: string = 'This is a STRING in Mixed CASE';\n}\n```\n\n<div class=\"content-ad\"></div>\n\napp.component.html:\n\n```js\n<div>\n  <h2>UpperCasePipe를 사용하는 방법</h2>\n  <p>원래 문자열: { myString }</p>\n  <p>대문자로 변환된 문자열: { myString | uppercase }</p>\n</div>\n```\n\n위 예시에서는 대소문자를 섞어 가지고 있는 문자열 값을 저장하는 myString 변수가 있습니다. 그 후에 uppercase 파이프를 사용하여 myString 변수를 모두 대문자로 변환합니다.\n\n위의 코드를 실행하면 다음과 같은 결과가 표시됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n대문자 파이프 사용\n원본 문자열: This is a STRING in Mixed CASE\n대문자 변환된 문자열: THIS IS A STRING IN MIXED CASE\n```\n\n첫 번째 출력 라인은 원래 문자열 값을 보여줍니다. 두 번째 출력 라인은 대문자 파이프를 사용한 후 변환된 문자열 값을 보여줍니다. 모든 문자가 대문자로 변환되었음을 주의하세요.\n\n## 5. 퍼센트 파이프\n\n다음은 Angular에서 퍼센트 파이프를 사용하는 예시입니다.\n\n<div class=\"content-ad\"></div>\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myNumber: number = 0.23;\n}\n```\n\napp.component.html:\n\n```html\n<div>\n  <h2>Using PercentPipe</h2>\n  <p>원래 숫자: {{ myNumber }}</p>\n  <p>백분율 값: {{ myNumber | percent }}</p>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예시에서는 숫자 값을 보관하는 myNumber 변수가 있습니다. 그런 다음 퍼센트 파이프를 사용하여 myNumber 변수를 백분율 값으로 변환합니다.\n\n위의 코드를 실행하면 다음 출력이 표시됩니다:\n\n```js\nUsing PercentPipe\nOriginal Number: 0.23\nPercentage Value: 23%\n```\n\n첫 번째 출력 라인은 원래 숫자 값을 보여줍니다. 두 번째 출력 라인은 퍼센트 파이프를 사용한 후 변환된 백분율 값을 보여줍니다. 소수 값에 100을 곱하고 값 끝에 백분율 기호가 추가됨에 유의하십시오.\n\n<div class=\"content-ad\"></div>\n\n## 6. Slice Pipe\n\nSlicePipe은 Angular에 내장된 pipe로, 기존 배열이나 문자열의 일부분을 포함하는 새로운 배열이나 문자열을 만드는 데 사용됩니다.\n\n아래는 Angular에서 SlicePipe를 사용하는 예시입니다:\n\napp.component.ts:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myArray: any[] = ['apple', 'banana', 'orange', 'grape', 'mango'];\n  myString: string = 'This is a long string.';\n}\n```\n\napp.component.html:\n\n```js\n<div>\n  <h2>배열에 SlicePipe 사용하기</h2>\n  <p>원본 배열: { myArray }</p>\n  <p>잘린 배열: { myArray | slice:1:3 }</p>\n</div>\n```\n\n```js\n<div>\n  <h2>문자열에 SlicePipe 사용하기</h2>\n  <p>원본 문자열: { myString }</p>\n  <p>잘린 문자열: { myString | slice:0:7 }</p>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n위 예제에서는 과일 배열을 보관하는 myArray 변수와 문자열 값을 보관하는 mySecodString 변수가 있습니다. 그런 다음 슬라이스 파이프를 사용하여 원래 배열 또는 문자열의 일부를 포함하는 새로운 배열 또는 문자열을 만듭니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n```js\n슬라이스 파이프를 배열에 사용\n\n원래 배열: apple,banana,orange,grape,mango\n스라이스된 배열: banana,orange\n\n문자열에 슬라이스 파이프를 사용\n\n원래 문자열: This is a long string.\n스라이스된 문자열: This is\n```\n\n첫 번째 출력 섹션은 슬라이스 파이프를 사용하여 원래 배열 값과 슬라이스된 배열 값을 보여줍니다. 슬라이스는 인덱스 1에서 시작하여 인덱스 3에서 끝나기 때문에 슬라이스된 배열에는 인덱스 1과 인덱스 2의 요소가 포함됩니다(인덱스 3은 포함되지 않음). 두 번째 출력 섹션은 슬라이스 파이프를 사용하여 원래 문자열 값과 슬라이스된 문자열 값을 보여줍니다. 슬라이스는 인덱스 0에서 시작하여 인덱스 7에서 끝나기 때문에 슬라이스된 문자열에는 인덱스 0부터 인덱스 6까지의 문자가 포함됩니다(인덱스 7은 포함되지 않음).\n\n<div class=\"content-ad\"></div>\n\n## 7. TitleCase Pipe\n\n앵귤러에서 TitleCasePipe를 사용하는 예제입니다:\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  template: './app.component.html'\n})\nexport class AppComponent {\n  myString: string = 'this is a sentence in lowercase.';\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위 예제에서는 문자열 값을 저장하는 myString 변수가 있습니다. 그런 다음 titlecase 파이프를 사용하여 myString 변수를 타이틀 케이스로 변환합니다.\n\n```js\n## TitleCasePipe 사용\n\n원본 문자열: { myString }\n\n변환된 문자열: { myString | titlecase }\n```\n\n위 코드를 실행하면 다음과 같은 출력이 표시됩니다:\n\n```js\nTitleCasePipe 사용\n원본 문자열: this is a sentence in lowercase.\n변환된 문자열: This Is A Sentence In Lowercase.\n```\n\n<div class=\"content-ad\"></div>\n\n첫 번째 출력 라인은 원래 문자열 값을 보여줍니다. 두 번째 출력 라인은 titlecase 파이프를 사용한 후의 변환된 타이틀 케이스 값을 보여줍니다.\n\n## 8. Async Pipe\n\nAsyncPipe는 Angular 내장 파이프로, 비동기 데이터 스트림을 처리하는 데 사용됩니다. 일반적으로 옵저버블이나 프로미스를 구독하고 뷰에 출력된 값들을 표시하는 데 사용됩니다.\n\n다음은 Angular에서 AsyncPipe를 사용하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n앱.component.ts:\n\n```js\nimport { Component } from '@angular/core';\nimport { Observable, of } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  template: './app.component.html'\n})\nexport class AppComponent {\n  myObservable$: Observable<number> = of(42);\n  myPromise$: Promise<string> = Promise.resolve('Hello World!');\n}\n```\n\n위 예시에서는 숫자 42를 방출하는 Observable을 저장하는 myObservable$ 변수와 문자열 'Hello World!'로 해결되는 Promise를 저장하는 myPromise$ 변수가 있습니다. 그런 다음 async pipe를 사용하여 이러한 Observable 및 Promise를 구독하고 뷰에 방출된 값을 표시합니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n<div class=\"content-ad\"></div>\n\n\n    # Observable을 사용하는 AsyncPipe\n    { myObservable$ | async }\n\n    # Promise를 사용하는 AsyncPipe\n    { myPromise$ | async }\n\n\n\nObservable을 사용하는 AsyncPipe\n42\nPromise를 사용하는 AsyncPipe\nHello World!\n\n\n첫번째 출력 섹션은 Observable을 통해 발행된 값을 보여줍니다. 두번째 출력 섹션은 Promise를 통해 해결된 값을 보여줍니다. AsyncPipe는 자동으로 Observable 및 Promise에 구독하며, 컴포넌트가 파괴되면 메모리 누수를 방지하기 위해 구독을 해제합니다.\n\n# 4. 사용자 정의 Pipe 생성하기\n\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서는 새 클래스를 정의하고 PipeTransform 인터페이스를 구현하여 사용자 정의 파이프를 만들 수 있어요. PipeTransform 인터페이스에는 입력 값을 받아 변환된 값을 반환하는 transform이라는 단일 메서드가 포함돼요.\n\ncustom.pipe.ts:\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n@Pipe({name: 'filterByLength'})\nexport class CustomPipe implements PipeTransform {\n  transform(values: string[], minLength: number): string[] {\n    return values.filter(value => value.length >= minLength);\n  }\n}\n```\n\n위 예제에서 CustomPipe 클래스를 정의하고 PipeTransform 인터페이스를 구현하는 것을 볼 수 있어요. transform() 메서드는 문자열 배열과 최소 길이라는 두 인수를 받아와요. 그런 다음 배열에서 지정된 길이 이상인 문자열을 걸러내요.\n\n<div class=\"content-ad\"></div>\n\n그런 다음 클래스에 @Pipe 데코레이터를 사용하여 해당 파이프에 이름을 제공합니다. 이름 속성을 사용하여 템플릿에서 파이프를 참조할 수 있습니다.\n\napp.module.ts\n\n```js\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { NgModule } from \"@angular/core\";\n\nimport { CustomPipe } from \"./custom.pipe\";\n\nimport { AppComponent } from \"./app.component\";\n\n@NgModule({\n  declarations: [AppComponent, CustomPipe],\n  imports: [BrowserModule],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n```\n\napp.component.ts\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  template: './app.component.html'\n})\nexport class AppComponent {\n  values: string[] = ['apple', 'banana', 'carrot', 'date'];\n}\n```\n\n```js\n<h2>Using Custom Pipe</h2>\n<ul>\n  <li *ngFor=\"let value of values | filterByLength: 5\">{{ value }}</li>\n</ul>\n```\n\n위 예제에서는 몇 가지 문자열을 포함하는 값 배열이 있습니다. 그런 다음 filterByLength 파이프를 사용하여 5자보다 짧은 문자열을 필터링합니다. *ngFor 지시문을 사용하여 필터링된 값들을 반복하고 그 값을 순서가 없는 목록으로 표시합니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nUsing Custom Pipe\n사과\n바나나\n당근\n```\n\n값 배열에서 5글자 이상인 두 개의 문자열을 표시합니다.\n\n# 5. 파이프 연결하기\n\nAngular에서 파이프를 연결하는 것은 템플릿에서 데이터를 변환하기 위해 여러 파이프를 연이어 적용하는 것을 의미합니다. 파이프를 연결하려면 파이프 연산자 (|)를 여러 번 사용하여 각각의 파이프가 별도의 변환을 나타내도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 문자열 형식을 지정하고 대문자로 변환하고 싶은 날짜 문자열이 있다고 가정해보세요. 다음과 같이 날짜 및 대문자 파이프를 연결할 수 있습니다.\n\n```js\n{ myDate | date:'medium' | uppercase }\n```\n\n이 예에서는 myDate 값이 먼저 date 파이프를 통해 전달되며, 이 파이프는 `medium` 형식을 사용하여 날짜를 형식화합니다. 그 결과값은 그 다음으로 uppercase 파이프를 통해 전달되며, 해당 값을 대문자로 변환합니다.\n\n여러 파이프를 연결하는 것은 성능에 영향을 줄 수 있으므로, 특히 대규모 데이터 집합을 처리할 때 주의해야 합니다. 템플릿에서 여러 파이프를 연결하게 되면, 변환 로직을 사용자 정의 파이프로 이동하거나 데이터를 템플릿으로 전달하기 전에 구성 요소에서 데이터를 변환하는 것을 고려해보세요. 이렇게 함으로써 성능을 향상시키고 코드를 읽기 쉽고 유지 보수하기 쉽게 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 6. 주요 포인트 요약\n\n- 파이프는 Angular 템플릿에서 데이터를 변환하여 사용자에게 표시되기 전에 사용됩니다.\n- Angular에는 CurrencyPipe, DatePipe, DecimalPipe, UpperCasePipe, LowerCasePipe, TitleCasePipe 및 AsyncPipe와 같은 여러 내장 파이프가 포함되어 있습니다.\n- 파이프는 | 문자와 함께 템플릿 표현식에서 사용할 수 있습니다.\n- 파이프는 하나 이상의 인수를 취할 수도 있으며, 이는 | 문자 뒤에 전달됩니다.\n- PipeTransform 인터페이스를 구현하는 클래스를 정의하고 해당 클래스를 모듈의 declarations 배열에 추가하여 직접 사용자 정의 파이프를 만들 수 있습니다.\n- 사용자 정의 파이프를 정의할 때, 파이프의 이름을 지정하고, 이 이름을 템플릿에서 사용할 수 있도록 하며, 입력 데이터와 인수를 취하여 변환된 데이터를 반환하는 변환 함수를 제공해야 합니다.\n- 템플릿에서 사용자 정의 파이프를 사용하기 위해서는, | 문자 뒤에 파이프 이름을 추가하고, 콜론 뒤에 인수를 추가해야 합니다.\n- 파이프를 사용할 때 올바른 파이프 이름과 인수를 사용하고, 올바른 입력 데이터를 파이프로 전달하는 것이 중요합니다. 파이프가 예상대로 작동하지 않으면 이러한 사항을 확인하여 문제를 해결해야 할 수도 있습니다.\n\n# 7. 파이프 사용의 Best Practices\n\nAngular에서 파이프를 사용할 때 염두에 둘 몇 가지 Best Practices가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 가능한 경우에는 내장 파이프를 사용해 보세요 — Angular은 DatePipe, CurrencyPipe, DecimalPipe 등과 같은 일반적인 변환을 위한 여러 내장 파이프를 제공합니다. 이러한 파이프들은 성능을 최적화했으며 불필요한 오버헤드를 피하기 위해 가능한 한 사용해야 합니다.\n- 너무 많은 파이프 연결을 피하세요 — 여러 파이프를 연결하면 성능 문제가 발생할 수 있습니다, 특히 대규모 데이터셋을 다룰 때. 대신 사용자 정의 파이프를 고려하거나 데이터를 템플릿으로 전달하기 전에 컴포넌트에서 변환하는 것을 고려해 보세요.\n- 성능에 주의하세요 — 특히 대규모 데이터셋을 다룰 때 파이프는 비용이 많이 드는 작업일 수 있습니다. 성능 문제를 피하기 위해 파이프가 호출되는 횟수를 제한하고 파이프 내에서 무거운 계산을 피하세요.\n- 파이프를 간단하게 유지하세요 — 파이프는 간단하고 단일 변환에 집중되어야 합니다. 하나의 파이프에서 너무 많은 작업이나 복잡한 논리를 갖는 파이프를 만드는 것을 피하세요. 이렇게 하면 유지 및 디버깅이 어려워질 수 있습니다.\n- 가능한 경우 순수 파이프를 사용하세요 — 순수 파이프는 입력이 변경될 때에만 호출됩니다. 이는 성능을 향상시킬 수 있습니다. 사용자 정의 파이프를 만들 때 가능한 경우 순수 파이프로 만드는 것을 고려해 보세요.\n- 데이터 유형을 주의하세요 — 변환될 데이터 유형에 따라 파이프의 작동 방식이 달라집니다. 예를 들어 DatePipe는 입력으로 Date 객체를 기대하고, CurrencyPipe는 숫자를 기대합니다. 예상치 못한 동작을 피하기 위해 파이프에 올바른 데이터 유형을 전달하도록 주의하세요.\n- 파이프를 테스트하세요 — 사용자 정의 파이프를 만들 때는 제대로 작동하는지 확실히 테스트하세요. 이는 파이프의 변환 논리에 대한 단위 테스트뿐만 아니라 컴포넌트의 맥락에서도 테스트하는 것을 포함할 수 있습니다.\n\n이러한 모범 사례를 따르면 Angular 애플리케이션에서 데이터를 변환하는 파이프가 효율적이고 유지보수가 용이하며 효과적이라는 것을 보장할 수 있습니다.\n\n# 8. 마지막 생각과 권장사항\n\n총론적으로, Angular에서 파이프는 컴포넌트에 추가적인 코드 없이 템플릿에서 데이터를 변환할 수 있는 강력한 기능입니다.\n\n<div class=\"content-ad\"></div>\n\n내장 파이프를 사용하거나 사용자 지정 파이프를 만들면 날짜, 숫자, 문자열을 포맷팅하고 데이터를 필터링하며 다른 유용한 변환을 수행할 수 있습니다.\n\nAngular 애플리케이션에서 파이프를 사용할 때는 성능을 염두에 두는 것이 중요합니다.\n\n너무 많은 파이프를 연쇄적으로 사용하지 않고 파이프 내에서 무거운 계산에 주의해야 합니다. 이는 성능에 영향을 줄 수 있습니다.\n\n또한 순수 파이프를 사용하고 사용자 지정 파이프를 충분히 테스트하여 예상대로 작동하는지 확인하는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n최종 권장 사항으로, Angular의 기본 파이프를 탐색하고 사용자 정의 파이프를 만들어보는 것을 제안합니다. 파이프를 효과적으로 활용하면 Angular 애플리케이션의 사용자 인터페이스를 더 다이나믹하고 매력적으로 만들 수 있습니다.\n\nCodeSandBox에서 실시간 예제를 확인할 수 있어요.\n\n그럼 이만! 이 글 끝까지 참여주셔서 정말 감사합니다! 도움이 되셨기를 바랍니다. 저를 Medium, Twitter, Linkedin 그리고 Facebook에서 팔로우할 수 있습니다.\n\n궁금한 점이 있으면 언제든지 물어봐주세요.\n\n<div class=\"content-ad\"></div>\n\n제게 커피를 사주시면 감사하겠어요 🙂\n\n더 많은 흥미로운 프로그래밍 조각들을 기대해 주세요.","ogImage":{"url":"/assets/img/2024-06-20-PipesinAngular_0.png"},"coverImage":"/assets/img/2024-06-20-PipesinAngular_0.png","tag":["Tech"],"readingTime":17}],"page":"46","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}