{"pageProps":{"posts":[{"title":"CSS의 고급 레이아웃 기술","description":"","date":"2024-06-20 03:20","slug":"2024-06-20-AdvancedLayoutTechniquesinCSS","content":"\n\n\n![image](/assets/img/2024-06-20-AdvancedLayoutTechniquesinCSS_0.png)\n\n# :empty 가상 클래스를 사용하여 내용이 없는 요소 선택하기\n\n추가적인 마크업 없이 빈 요소를 선택하는 쉬운 방법은 :empty 가상 클래스를 사용하여 자식 요소가 없는 요소를 대상으로 하는 것입니다.\n\n아래 예시에서는 class가 message인 두 개의 div 요소가 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html>\n  <body>\n    <div class=\"message\">\n      <p>Info: Hey there!</p>\n    </div>\n    <div class=\"message\"></div>\n  </body>\n</html>\n```\n\n:empty 가상 클래스 선택자를 사용하여 빈 div 요소를 숨길 수 있어요\n\n```js\n.message {\n  margin: 10px;\n  padding: 10px;\n  background-color: blue;\n  color: white;\n  border-radius: 5px;\n}\n\n.message:empty {\n  display: none;\n}\n```\n\n하지만, :not(:empty) 가상 클래스 선택자를 사용하여 비어 있지 않은 message 요소를 스타일링하는 방법도 있어요\n\n<div class=\"content-ad\"></div>\n\n```js\n.message:not(:empty) {\n  margin: 10px;\n  padding: 10px;\n  background-color: lightblue;\n  color: white;\n  border-radius: 5px;\n}\n```\n\n🚨 공백은 자식으로 간주되기 때문에, :empty는 요소에 내용(자식이 없지만 시작 태그와 끝 태그 사이에 공백이 있는 경우)이 있는 경우 작동하지 않음을 주의하십시오.\n\n# *-Of-Type CSS 가상 클래스를 사용하여 위치에 따른 요소 선택하기\n\n부모 요소 내에서 형제 요소 중에서 위치에 따라 요소를 선택하는 방법을 알아보세요.\n\n<div class=\"content-ad\"></div>\n\n# :first-of-type 와 :last-of-type\n\nCSS :first-of-type 선택자를 사용하면 부모 컨테이너 내에서 특정 요소의 첫 번째 인스턴스를 선택할 수 있습니다. CSS의 :last-of-type 선택자를 사용하면 마지막 요소를 선택할 수 있습니다.\n\n```js\narticle p:first-of-type {\n  font-size: 16px;\n  font-style: italic;\n}\n\narticle p:last-of-type {\n  color: green;\n}\n```\n\n# :only-of-type\n\n<div class=\"content-ad\"></div>\n\n:only-of-type 가상 클래스는 동일한 유형의 형제 요소가 없는 요소를 나타냅니다.\n\n```js\narticle blockquote:only-of-type {\n  border-left: 4px solid black;\n  padding-left: 10px;\n  font-style: italic;\n  font-weight: bold;\n  color: darkblue;\n}\n```\n\n# :nth-of-type()\n\n:nth-of-type 가상 클래스는 동일한 유형(태그 이름)의 형제 요소 중에서 요소의 위치에 따라 일치시킵니다.\n\n<div class=\"content-ad\"></div>\n\n\n/* 위 예시에서 2번째와 6번째 단락과 일치합니다. (즉, 4n+2 규칙에 따라 일치하는 요소입니다.)\n    4n+2는 4*0 + 2 = 2번째, 4*1 + 2 = 6번째 등으로 변환될 수 있습니다.\n*/\narticle p:nth-of-type(4n+2) {\n  color: purple;\n}\n\n\n아래 예시를 살펴보세요:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n    <article>\n        <h1>Lorem Ipsum</h1>\n        <p>\"Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit...\"</p>\n        <!-- 이하 생략 -->\n    </article>\n</body>\n</html>\n```\n\n또한, CSS 코드는 다음과 같습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\narticle p:first-of-type {\n  font-size: 16px;\n  font-style: italic;\n}\n\narticle img:last-of-type {\n  border: 10px solid pink;\n}\n\narticle blockquote:only-of-type {\n  border-left: 4px solid black;\n  padding-left: 10px;\n  font-style: italic;\n  font-weight: bold;\n  color: darkblue;\n}\n\n/* 2번째와 6번째 문단이 일치하도록 합니다.4n+2는 4*0+2=2번째, 4*1+2=6번째와 같이 모든 4의 배수에 2를 더하여 일치하는 엘리먼트를 의미합니다 */\narticle p:nth-of-type(4n+2) {\n  color: purple;\n}\n```\n\n# CSS calc()를 사용하여 고정-유동-고정 레이아웃 만들기\n\nCSS calc()를 사용하면 단위를 섞어 실시간 계산을 수행할 수 있습니다. 알 수 없는 수를 고려하여 요소의 크기를 조절해야 할 때 유용합니다.\n\ncalc() 속성은 스타일시트 내의 CSS 길이 또는 숫자가 있는 곳이라면 어디서나 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n레이아웃 유연성을 향상시키는 두 가지 주요 기능을 제공합니다:\n\n- 백분율과 절대 값 혼합\n- 크기 단위 혼합\n\n# 백분율과 절대 단위 혼용\n\n백분율과 절대 단위를 결합한 예제를 살펴보겠습니다. 사용 가능한 영역 중 50%를 할당하되 고정 픽셀 양만큼 빼고 싶다고 가정해 봅시다. 이를 다음과 같이 작성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n```js\n.parent {\n  border: 1px solid black;\n}\n\n.child {\n  width: calc(50% - 100px);\n  background-color: green;\n}\n```\n\nAnd the HTML code:\n\n```js\n<div class=\"parent\">\n  <div class=\"child\">Always 100 pixels less than half the available area</div>\n</div>\n```\n\nNow if you preview this code, it’d look like:\n\n\n<div class=\"content-ad\"></div>\n\n부모 요소의 크기를 줄이면 다음과 같이 보입니다:\n\n![image1](/assets/img/2024-06-20-AdvancedLayoutTechniquesinCSS_2.png)\n\n이 방식의 좋은 점은 콘텐츠의 오른쪽 가장자리를 항상 포함 영역 중앙에서 왼쪽으로 100px 위치시킬 수 있다는 것입니다. 다양한 값 유형을 혼합할 수 있는 이 능력은 웹 애플리케이션의 레이아웃 관리를 향상시켜서 다양한 크기의 장치에 걸쳐 더 효과적인 제어를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단위 조합\n\n또 다른 훌륭한 기능은 다양한 측정 단위를 조합하여 최종 크기를 얻을 수 있는 능력입니다. 예를 들어, 'em'과 'px' 단위를 섞어서 현재 글ꔼ 크기에 상대적인 크기를 설정할 수 있습니다.\n\n```js\n.child {\n  height: calc(10em + 3px);\n  background-color: green;\n}\n```\n\n💡 calc()를 사용하여 +, -, *, /를 사용하여 값들을 더하거나 빼내거나 곱하거나 나눌 수 있어서 다양한 가능성을 제공합니다. calc()는 CSS 길이나 숫자가 사용될 수 있는 곳이면 어디에서든 사용할 수 있습니다. 또한 곧 각도나 주파수 속성에 대한 calc()를 추가할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# CSS를 사용하여 요소를 동적으로 크기 조절하기\n\n브라우저 크기를 조정할 때도 반응형 레이아웃을 만들 수 있도록 뷰포트의 크기에 따라 요소의 크기를 조정할 수 있습니다.\n\n# 뷰포트 단위\n\n뷰포트 단위는 \"반응형 길이 단위\"로 간주되며, 브라우저 크기가 조정될 때마다 그 값이 조정됩니다. CSS에는 이러한 뷰포트 기반 단위 네 가지가 포함되어 있습니다. 이들은 vh, vw, vmin 및 vmax입니다.\n\n<div class=\"content-ad\"></div>\n\n- 뷰포트 높이 (vh). 이 단위는 뷰포트의 높이를 기준으로 합니다. 1vh의 값은 뷰포트 높이의 1%에 해당합니다.\n- 뷰포트 너비 (vw). 이 단위는 뷰포트의 너비를 기준으로 합니다. 1vw의 값은 뷰포트 너비의 1%에 해당합니다.\n- 뷰포트 최솟값 (vmin). 이 단위는 뷰포트의 작은 차원을 기준으로 합니다. 뷰포트 높이가 너비보다 작은 경우, 1vmin의 값은 뷰포트 높이의 1%에 해당합니다. 마찬가지로, 뷰포트 너비가 높이보다 작은 경우, 1vmin의 값은 뷰포트 너비의 1%에 해당합니다.\n- 뷰포트 최댓값 (vmax). 이 단위는 뷰포트의 큰 차원을 기준으로 합니다. 뷰포트 높이가 너비보다 큰 경우, 1vmax의 값은 뷰포트 높이의 1%에 해당합니다. 마찬가지로, 뷰포트 너비가 높이보다 큰 경우, 1vmax의 값은 뷰포트 너비의 1%에 해당합니다.\n\n다음과 같이 단락을 포함한 div 요소로 시작하세요:\n\n```js\n<div class=\"Layout\">\n  <p>Hello Dynamic Sizing!</p>\n</div>\n```\n\n포함 요소에 뷰포트 단위를 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n```css\n.Layout {\n  height: 40vh;\n  width: 40vw;\n  margin: 30vh 25vw;\n  background-color: cadetblue;\n}\n\np {\n  padding: 32px 0 0 32px;\n  font-family: monospace;\n  font-size: 18px;\n  color: azure;\n}\n```\n\n실제로 보기:\n\n브라우저 크기를 조절하면 크기가 반응적으로 변경됩니다.\n\n# 단 하나의 CSS 값으로 손쉽게 스타일 재설정하기\n\n\n<div class=\"content-ad\"></div>\n\n요소의 스타일을 부모의 스타일로 재설정해야 할 때, 더 많은 스타일 선언을 덧붙이는 대신 간단히 재설정할 수 있습니다.\n\n섹션 컨테이너 안에 랩핑된 버튼 요소를 선언하세요:\n\n```js\n<section>\n  <button>Click me!</button>\n</section>\n```\n\n버튼 요소의 부모인 섹션 요소에서 선언된 글꼴 색상을 사용하려면 색상을 검정으로 설정하는 대신 재설정할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\nsection {\n  color: black;\n}\n\nbutton {\n  cursor: pointer;\n  padding: 20px;\n  border: 0;\n  border-radius: 4px;\n  text-align: center;\n  text-decoration: none;\n  font-size: 16px;\n  font-weight: 500;\n  color: white;\n  background-color: springgreen;\n}\nsection button {\n  color: unset;\n}\r\n\n\n실제로 보십시오:\n\n# CSS를 사용하여 반응형 플루이드 칼럼 레이아웃 설계하기\n\n추가 마크업이 필요 없이 유연하고 반응성 레이아웃을 만들기 위해 CSS 칼럼을 활용하는 방법을 발견하세요.\n\n<div class=\"content-ad\"></div>\n\n참고 사항:\n\n- column-width는 width가 아닌 min-width와 같이 작동합니다. 브라우저는 제공된 너비로 가능한 많은 열을 렌더링합니다. 각 열이 제공된 값 이상을 차지할 수 있다면 그렇게 할 것입니다.\n- column-span은 특정 요소가 column-count와 column-width를 무시하도록 허용합니다. 정수값으로 설정하여 특정 열 수에 걸쳐 확장하거나 \"all\"로 모든 열에 걸쳐 확장할 수 있습니다. 그러나 이 속성은 Firefox에서 작동하지 않습니다. 해결책으로는 컨테이너에 적용된 열을 벗어난 요소(예: 헤딩)로 이동하는 것이 있습니다. 이렇게 하면 해당 요소가 자동 열 흐름 밖에 유지됩니다.\n- column-fill을 사용하면 콘텐츠가 열로 흐르는 방식을 변경할 수 있습니다. 기본값으로 \"balance\"로 구성되어 있어 콘텐츠가 열 사이에 균등하게 분배되도록 보장합니다. \"auto\"로 설정할 수도 있지만 이를 위해 고정 높이를 설정해야 합니다. 이는 유동적이고 응답형 레이아웃의 개념을 깨는 것이므로 신중히 사용해야 합니다.\n- column-gap은 각 열 사이의 갭 또는 거터를 지정하며, 음수가 아닌 길이를 사용하여 픽셀, rems, 다시 말해 퍼센트로 설정할 수 있습니다. column-gap은 열 사이의 내장된 패딩으로 생각할 수 있으며 올바른 간격을 얻기 위해 실제로 수학을 할 필요가 없습니다.\n- column-rule을 사용하면 각 열 사이에 테두리를 넣을 수 있으며, border shorthand와 동일한 인수를 사용하므로 1px dashed #ccc와 같이 말할 수 있습니다. 이렇게 하면 각 열 가장자리에 수직 선이 추가됩니다.\n\n```js\n<section>\n  <h2>Europe</h2>\n  <nav>\n    <ul>\n      <li><a href=\"#\">Belgium</a></li>\n      <li><a href=\"#\">Netherlands</a></li>\n      <li><a href=\"#\">Denmark</a></li>\n      <li><a href=\"#\">Germany</a></li>\n      <li><a href=\"#\">Czechia</a></li>\n      <li><a href=\"#\">France</a></li>\n      <li><a href=\"#\">Spain</a></li>\n      <li><a href=\"#\">Portugal</a></li>\n      <li><a href=\"#\">Italy</a></li>\n      <li><a href=\"#\">Poland</a></li>\n      <li><a href=\"#\">Sweden</a></li>\n      <li><a href=\"#\">Norway</a></li>\n      <li><a href=\"#\">Finland</a></li>\n      <li><a href=\"#\">Slowakia</a></li>\n      <li><a href=\"#\">Slovenia</a></li>\n      <li><a href=\"#\">Hungary</a></li>\n    </ul>\n  </nav>\n</section>\n```\n\n위에서 배운 column 프로퍼티를 사용해 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nnav {\n    /*column-count: 4;\n    column-width: 150px;*/\n    columns: 4 120px; /* same as above */\n    column-gap: 2rem;\n    column-rule: 1px dashed #ccc;\n}\n```\n\n실제로 이것을 확인해 보겠습니다:","ogImage":{"url":"/assets/img/2024-06-20-AdvancedLayoutTechniquesinCSS_0.png"},"coverImage":"/assets/img/2024-06-20-AdvancedLayoutTechniquesinCSS_0.png","tag":["Tech"],"readingTime":8},{"title":"이 웹사이트의 다크 모드를 위한 1가지 간단한 CSS 트릭","description":"","date":"2024-06-20 03:18","slug":"2024-06-20-1simpleCSStrickforDarkModeonyourwebsite","content":"\n\n## 야간 모드가 기다리고 있어요!\n\n상상해보세요: 밤이 깊어지고 달이 높아지는데, 당신은 편안하게 즐기는 사이트를 둘러보고 있을 때 — 바로 그때! — 밝은 흰색 배경이 마치 협시처럼 쏟아지는 걸 맞이합니다. 이게 최선은 아니겠죠?\n\n개발자들은 이 간단한 문제를 기술적인 미궁으로 만들어, 수많은 클래스, 스타일 및 JavaScript 파일을 추가합니다. 그러나 친애하는 독자여, CSS 마법의 20줄 미만으로 다크 모드를 달성할 수 있는 더 간단한 방법이 있습니다. 네, 들었습니다 — 20줄 미만!\n\n# 다크 모드를 간편화하기\n\n<div class=\"content-ad\"></div>\n\nCSS를 활용하면 사용자 선호 테마에 매끄럽게 적응하는 웹사이트를 구축할 수 있어요. 어떻게요? 미디어 쿼리를 사용하여 --body-bg 및 --body-color CSS 변수를 조정하면 되죠. 라이트 모드에서는 배경을 흰색으로, 다크 모드에서는 검정색으로 설정할 거예요. 이렇게 하면 됩니다:\n\n```js\n@media (prefers-color-scheme: dark) {\n  :root {\n    --body-bg: black;\n    --body-color: white;\n  }\n}\n```\n\n```js\n@media (prefers-color-scheme: light) {\n  :root {\n    --body-bg: white;\n    --body-color: black;\n  }\n}\n```\n\n만세! 이제 사이트가 낮과 밤 사이를 자유자재로 이동할 수 있답니다.재즈 뮤지션이 조퍼바꾸는 것만큼 부드럽죠.\n\n<div class=\"content-ad\"></div>\n\n# 작동 방식\n\n이 마법의 핵심은 prefers-color-scheme 미디어 쿼리입니다. 이 미디어 쿼리는 사용자의 시스템 환경 설정을 확인하고 해당 스타일을 적용합니다. 사용자가 어두운 테마를 선호하는 경우 CSS 변수 --body-bg와 --body-color은 각각 검정과 흰색으로 설정됩니다. 반대로, 사용자가 밝은 테마를 선호하는 경우 이러한 변수는 흰색과 검정으로 설정됩니다.\n\n# 다크 모드의 이유\n\n하지만 왜 다크 모드를 신경 써야 할까요? 이유는 몇 가지 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 눈의 피로를 줄여줍니다: 특히 어두운 환경에서는 다크 모드가 눈에 부담을 덜어줄 수 있습니다.\n- 배터리 수명 절약: OLED 화면에서는 다크 모드를 사용하여 검은 픽셀이 더 적은 전력을 소비하기 때문에 배터리 수명을 절약할 수 있습니다.\n- 멋있어 보입니다: 솔직히 말해서, 다크 모드는 슬릭하고 현대적으로 보입니다.\n\n![이미지](/assets/img/2024-06-20-1simpleCSStrickforDarkModeonyourwebsite_0.png)\n\n# 프로젝트에 다크 모드 구현하기\n\n이 CSS 트릭을 프로젝트에 통합하려면 다음 단계를 따르세요:\n\n<div class=\"content-ad\"></div>\n\n- 변수 정의: CSS 변수를 루트 수준에서 설정하여 스타일 시트 전체에서 액세스할 수 있도록 합니다.\n- 미디어 쿼리 적용: 사용자의 선호도에 따라 이러한 변수를 조정하기 위해 prefers-color-scheme 미디어 쿼리를 사용하세요.\n- 요소 스타일링: CSS에서 이러한 변수를 사용하여 전체 사이트가 다크 모드 설정을 준수하도록 합니다.\n\n예시:\n\n```js\nbody {\n  background-color: var(--body-bg);\n  color: var(--body-color);\n}\n```\n\n# 결론: 밤 모드가 여러분을 기다립니다!\n\n<div class=\"content-ad\"></div>\n\n여기 있습니다! 웹 개발 생활을 조금 더 쉽게 만드는 빠르고 재미있는 가이드! 기술 분야에서 모든 것이 이렇게 간단했으면 좋겠죠? 이제 용감하게 코딩하고 사용자들을 눈부시게 하거나 배열에 뒤얽히지 않고 진행할 수 있어요! 새벽에 코딩을 하는 야행성 개발자이든, 세련된 현대적인 디자인을 좋아하는 사람이든, 이 간단한 CSS 요령이 여러분을 지켜줄 거예요.\n\n🌚 여정을 즐겼나요? 멋지군요! 아래는 어떻게 저희를 지원할 수 있는지 안내해 드립니다:\n👏 50번의 박수가 필요합니다; 여러분도 박수를 보내주세요.\n💬 의견을 남겨주세요; 여러분의 피드백을 듣는 것을 좋아해요!","ogImage":{"url":"/assets/img/2024-06-20-1simpleCSStrickforDarkModeonyourwebsite_0.png"},"coverImage":"/assets/img/2024-06-20-1simpleCSStrickforDarkModeonyourwebsite_0.png","tag":["Tech"],"readingTime":3},{"title":"도시 연구소 디자인 라이브러리의 진화","description":"","date":"2024-06-20 03:16","slug":"2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary","content":"\n\n1.한 해 동안 여러 웹사이트를 출시한다고 상상해보세요. 각 사이트는 버튼, 아이콘, 이미지, 제목, 요약 및 날짜와 같은 디자인 요소를 여러 페이지에 걸쳐 복제해야 합니다. 이 복제본마다 다른 카드 변형이 필요할 수도 있습니다. 아래 프로젝트를 참고해주세요:\n\n\n![이미지 0](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_0.png)\n\n\n\n![이미지 1](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_1.png)\n\n\n\n![이미지 2](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n지금까지, 저희의 웹 개발 및 디자인 팀은 각 사이트를 개별적으로 프로토타입으로 제작한 후 매번 새로운 프로젝트를 위해 이러한 요소들을 처음부터 다시 만들었습니다. 이 방식은 시간이 많이 소요되며 일관성이 없었으며 종종 완전히 접근 가능하지 않은 사이트가 되거나 최고의 실천 방법을 준수하지 않거나 Urban의 디자인 표준과 일치하지 않는 사이트를 만들어내기도 했습니다.\n\nUrban이 변화를 이끌어가는 사람들과 지역사회 지도자들이 가족과 지역사회의 복지를 향상시키기 위해 신뢰하는 소스인 만큼, 우리는 모든 사용자에게 친화적인 웹 인터페이스를 만들고, 스크린 리더와 음성 인식 등 개인 사용자의 보조 기술과 호환되며, 웹 접근성 표준에 최고의 실천 방법을 준수하는 것이 중요합니다.\n\n그런 이유로 저희는 모든 웹사이트에서 재사용 가능한 컴포넌트를 활용할 수 있는 새로운 시스템이 필요했습니다. 이러한 시스템은 개발자와 디자이너가 혁신적인 솔루션을 개발에 집중할 수 있도록 해줄 뿐만 아니라, 계속해서 코드를 작성하거나 자주 사용되는 요소를 계속해서 프로토타입으로 제작할 필요가 없게 하며, 우리의 웹사이트가 최고 수준의 보안 표준을 준수하고 유지 보수가 용이하며 Urban의 미션과 일치한다는 것을 보장합니다. 이 전략적 전환이 우리의 핵심 가치와 일치하는 혁신적이고 안전한 디지털 콘텐츠를 전달하는 능력을 향상시키는 데 중요했습니다.\n\n# 이전 디자인 라이브러리의 단점 탐색:\n\n<div class=\"content-ad\"></div>\n\nUrban의 웹 프로젝트는 2017년부터 Atomic 디자인 시스템을 도입하기 시작했습니다. 이 방식은 팀이 재사용 가능한 구성 요소를 만들고 활용할 수 있도록 함으로써 개발 프로세스를 혁신했습니다. 이 구성 요소들은 Drupal 8 사이트의 템플릿에 통합되었고 (일반적으로 Pattern Lab이라고 함), 이를 통해 몇 가지 주요 전략이 강조되었습니다:\n\n- 디자인 프로세스 초기에 협업을 강조하여 개발자와 디자이너가 공유 토큰 및 구성 요소 카탈로그를 편집할 수 있도록 함\n\n- 코딩 프로세스를 간소화하고 새로운 사이트 기능에 대해 구성 요소를 재사용함\n\n- 디자인 시스템을 Drupal과 별도로 유지하여 더 쉽고 유지하기 쉬운 형태로 관리함\n\n<div class=\"content-ad\"></div>\n\n- Atomic 디자인 원칙을 적용하여 디자인 시스템의 각 요소 프로토타입화하기\n\n기존 디자인 시스템의 장점에도 불구하고, 상당한 단점이 있었습니다. 각 새로운 Drupal 사이트를 만들 때마다 전체 디자인 시스템을 처음부터 재작성해야 했는데, 이는 시간이 많이 소요되고 비효율적이었습니다. 재사용 가능한 구성 요소는 Drupal 템플릿 시스템에만 제한되어 있었기 때문에, 이를 통해 비-Drupal 웹 프로젝트에서 활용을 제한되어 있었고, 디자인 시스템의 전체 잠재력을 이뤄내지 못하게 되었습니다.\n\nUrban의 메인 사이트를 새롭게 업데이트하기 시작할 때, 우리는 Atomic 디자인 원칙을 준수하고 Drupal뿐만 아니라 모든 웹 응용 프로그램에서 사용할 수 있는 보다 유연한 디자인 시스템을 만들기 위한 기회를 가졌습니다. 우리 내부 디자인 팀은 프론트엔드 스타일링을 위해 Tailwind CSS를 구현하기 시작했고, 2019년까지 현재 디자인 시스템을 구성하는 버튼, 폰트 스케일, 간격, 색상 및 다양한 사용자 인터페이스 구성 요소를 개발했습니다.\n\n그러나 몇 가지 도전이 남아 있었습니다. 간격은 오로지 Tailwind CSS 값에만 기반하고 있었습니다. 이러한 남아 있는 구성 요소를 도입하기 위해, 우리 디자인 팀은 Urban의 지침과 기술적 프레임워크와 동기화하는 개선된 디자인 시스템을 만들었습니다. 이 협업적 접근 방식은 2021년 Lyndon의 생성으로 이어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n# 우리의 Lyndon 디자인 라이브러리를 소개합니다\n\nUrban Institute가 설립된 린든 B. 존슨 전 대통령의 이름을 딴 Lyndon은 이제 Urban의 디자인 표준을 보유하고 다양한 프로젝트를 통해 디지털 경험을 통합합니다. 강력한 Stencil JavaScript 프레임워크를 기반으로 한 Lyndon은 성능 및 크로스 플랫폼 호환성을 최적화한 웹 컴포넌트를 생성합니다. 이 이니셔티브는 Lyndon을 우리 디자이너 및 웹 개발팀에게 유연하고 동적인 툴킷으로 만들어줍니다. 팀은 우수하고 효율적인 디지털 경험을 만들 수 있도록 지원합니다.\n\nLyndon은 Figma에서 제작되어 일관된 컴포넌트, 색상, 간격 및 타이포그래피 스위트를 개발할 수 있었습니다. 프론트엔드 개발팀은 모든 컴포넌트를 Figma에서 Storybook으로 정확하게 이전하고 정렬했습니다. Storybook 통합을 통해 작업 흐름을 최적화하고 디자인 일관성을 향상시켰습니다. 이는 디자이너들이 더 복잡한 창의적 작업에 집중할 수 있도록 돕고 모형 및 프로토타입 작성을 효율적으로 만들어줍니다. 아래 이미지는 이 통합을 보여줍니다. 상단 이미지는 Figma에서 텍스트 스타일을 표시하고, 하단 이미지는 해당 Storybook 컴포넌트를 보여줍니다. 이 통합은 사이트에서 사용할 수 있는 일관된 텍스트 스타일을 확실히 보장합니다.\n\n![이미지](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_3.png)\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_4.png)\n\nStorybook은 접근성이 좋고 직관적인 레이아웃에서 전체 컴포넌트 라이브러리를 제공하여 개발 도구로서 작용하며 디자인 시스템의 살아있는 문서 역할을 합니다. 색상, 간격과 같은 디자인 토큰부터 타이틀과 같은 원자화된 컴포넌트까지, Storybook은 사용자 인터페이스 요소와의 동적 실험을 위한 대화형 컨트롤을 제공합니다. Storybook은 이러한 컴포넌트를 개발, 테스트 및 품질 보증 과정에서 사용할 수 있는 이야기로 보존합니다.\n\n결과적으로, Lyndon의 가벼운 독립형 컴포넌트는 빠른 로딩 시간과 유연성을 보장합니다. 버튼 컴포넌트를 통해 사용자는 텍스트, 아이콘, 색상 변형, 링크, 사이즈 등을 쉽게 드롭다운 옵션에서 선택하여 사용자 정의할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_5.png)\n\n\n<div class=\"content-ad\"></div>\n\nlbj-button 컴포넌트는 (src/components) 디렉토리 안에 있습니다. 여기에는 프로젝트 전반적인 사용을 위해 기술적인 명명을 보장하기 위해 모든 컴포넌트가 저장되어 있습니다. (우리는 전 대통령 린든 B. 존슨에 경의를 표하기 위해 lbj 접두사를 사용합니다.)\n\n![스크린샷](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_6.png)\n\nlbj-button 디렉토리에는 모든 관련 코드가 포함되어 있습니다. lbj-button.tsx TypeScript 파일은 Stencil을 사용하여 컴포넌트를 생성하는데, .tsx 확장자는 개발 중에 JSX와 TypeScript를 사용하고 있음을 나타냅니다. 이 구성은 해당 컴포넌트를 HTML에 사용자 정의 태그로 포함시킬 수 있게 하며, Urban의 주요 색상으로 스타일링된 다운로드 아이콘이 있는 버튼을 렌더링합니다. \n\n![스크린샷](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_7.png)\n\n<div class=\"content-ad\"></div>\n\n# Lyndon의 능력 확장:\n\n.tsx 파일 이외에도, 각 Lyndon 컴포넌트에는 lbj-button.stories.ts와 같은 스토리 파일이 포함되어 있습니다. 이 설정을 통해 팀은 Stencil이 생성한 웹 컴포넌트를 StencilJS와 독립적으로 사용자 인터페이스에서 시각화하고 상호 작용할 수 있습니다. 개발자는 전체 애플리케이션 환경을 로드할 필요가 없어 개발 주기를 빠르게 하고 문제 해결을 쉽게 할 수 있습니다.\n\nStorybook은 단일 컴포넌트에 대해 여러 가지 스토리나 변형을 생성할 수 있도록 하며, 다른 기능 또는 스타일을 나타냅니다. 기존 컴포넌트에 변형을 도입할 때는 기본 컴포넌트를 활용하고 필요에 맞게 수정합니다.\n\n아래 이미지에서, Color Block 컴포넌트는 특정 시나리오에 맞게 디자인된 네 가지 다른 변형과 함께 표시됩니다. 한 가지 변종인 Color Block Minimal은 주로 균일한 배경 색상으로 섹션을 만들기 위해 사용됩니다. 다른 변형인 Featured Text는 페이지나 URL로 연결되는 헤드라인 옵션, 버튼과 같은 상호 작용 요소를 포함하는 다양한 배경 색상을 특징으로 하는 블록 목록을 포함한 더 다이내믹한 사용 사례를 위해 디자인되었습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_8.png)\n\n웹 디자인 및 개발의 기초를 계속해서 개선 중입니다.\n\n라이든을 통해 더 많은 사용자 정의 옵션 및 더 효율적인 개발을 지원함으로써 우리는 Urban Institute에서 웹 디자인 및 개발에 접근하는 방식을 현격히 변화시켰습니다. 이 강력한 디자인 시스템을 구현함으로써, 모든 디지털 플랫폼에서 더욱 일관된 경험을 제공하고 있습니다. 구체적으로 개선된 내용은 다음과 같습니다:\n\n- 효율성 증대: 팀이 새로운 요소를 처음부터 만드는 대신 미리 디자인된 구성 요소를 빠르게 구현할 수 있기 때문에 개발 시간이 단축되었습니다.\n\n<div class=\"content-ad\"></div>\n\n- 향상된 일관성: 모든 디지털 출력물은 통일된 디자인을 따르므로 브랜드 아이덴티티가 플랫폼과 사이트 전반에 걸쳐 일관성을 유지합니다.\n\n- 더 많은 유연성: Lyndon의 적응형 디자인 시스템은 Drupal을 넘어서 다른 웹 애플리케이션까지 확장됩니다.\n\n- 향상된 확장성: 우리의 디지털 요구사항이 증가함에 따라, Lyndon의 유연한 프레임워크로 기존 구조를 방해하지 않고 더 복잡한 기능을 쉽게 확장하고 통합할 수 있습니다.\n\n# Lyndon의 유연성을 보여주는 것:\n\n<div class=\"content-ad\"></div>\n\n이미 실무에서 이러한 혜택들을 확인했습니다. 학생 Upward Mobility Initiative 웹사이트의 경우, 프로젝트의 특정 요구사항과 이해관계자들의 요청으로 인해 Urban의 가이드라인을 준수해야 했습니다. 이 요청을 수용하기 위해, 새로운 글꼴 패밀리를 도입한 Lyndon의 새로운 변형을 발표했습니다. 이를 통해 각 구성 요소의 글꼴을 코딩할 필요 없이 새로운 글꼴 패밀리를 통합할 수 있었습니다. 이 변형은 Lyndon 라이브러리에 추가되어 사용자 정의 구성 요소 태그에서 모드 속성을 정의함으로써 글꼴을 렌더링할 수 있게 했습니다. 아래는 이전과 동일한 버튼 구성 요소이지만, 이제는 학생 Upward Mobility Initiative 사이트에서 필요한 새로운 글꼴 패밀리를 사용합니다. 이 프로젝트와 앞으로의 계획에서 Lyndon의 유연성은 각 프로젝트가 독특한 브랜드 아이덴티티를 유지하면서도 Lyndon의 강력한 인프라를 활용할 수 있도록 합니다.\n\n![이미지](/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_9.png)\n\n\"Lyndon의 구성 요소를 사용하면 디자이너와 사이트 프로듀서들이 상상할 수 있는 거의 모든 페이지 레이아웃을 구상하고 실행할 수 있습니다. 이는 그들의 작업을 더 창의적으로 만드는 뿐만 아니라 효율적으로 만들어줍니다.\"\n- Dave Connell, 디지털 커뮤니케이션 선임 이사\n\n저희는 웹 개발의 떠오르는 트렌드와 기술을 충족하는 Lyndon의 진화를 계속할 것을 약속합니다. 저희의 계획에는 아래와 같은 것들이 포함됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 최신 웹 기술과 사용자 기대에 따라 지속적으로 새로운 구성 요소를 추가하고 업데이트 중입니다.\n\n- 라인든(Lyndon)의 접근성 기능을 향상시켜 디지털 콘텐츠를 더 넓은 관객에게 도달 가능하게 하며 웹 콘텐츠 접근성 지침을 준수하는 기준을 뛰어넘습니다.\n\n# 라인든 앞으로의 발전:\n\n라인든과 함께한 이 여정에서 한 때의 웹 개발 병목 현상을 혁신과 효율을 위한 길로 변모시켰습니다. 디자인 시스템을 한 단계 더 높여 반복적인 디자인 작업의 어려움을 극복함으로써 모든 디지털 산출물을 핵심 미션과 일치시켰습니다. 오늘날, 우리는 강력하고 확장 가능한 기반을 구축하여 미래 웹 기술을 수용하고 웹 접근성 표준을 준수합니다. 사용자 커뮤니티는 이 지속적인 과정에서 중요한 역할을 하며, Urban Institute의 목표를 달성하고 접근 가능한 디지털 연구 플랫폼을 위한 새로운 기준을 설정하는 도구로 라인든을 세밀하게 다듬는 데 도움이 되고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n웹 개발의 미래가 어떻게 발전할지, 그리고 접근성이 그 중에서 어떤 역할을 할지 궁금하시군요? 귀하의 생각을 나누어주셔서 감사합니다. Lyndon의 발전하는 이야기에 함께해 주세요. \n\n— Farnoosh Johnson\n\n더 많은 정보를 알고 싶으신가요? Data@Urban 뉴스레터에 가입하세요.","ogImage":{"url":"/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_0.png"},"coverImage":"/assets/img/2024-06-20-TheEvolutionoftheUrbanInstitutesDesignLibrary_0.png","tag":["Tech"],"readingTime":8},{"title":"부트스트랩을 벗어나는 방법 불마를 위한 빠른 시작 가이드","description":"","date":"2024-06-20 03:15","slug":"2024-06-20-BranchingOutFromBootstrapAQuickstartGuidetoBulma","content":"\n\n마치 중고차 판매원이 되는 것 같지 않지만, CSS 프레임워크에는 다양한 옵션이 있습니다. 무엇이 가장 예쁘고 사용하기 쉬운 프레임워크이며 전체적으로 어떤 보상을 줄 수 있는지에 대해 다양한 의견이 있습니다.\n\nBootstrap에서 편안함을 느끼고 있지만 Bulma 문서를 한 번 보고 무엇인가 궁금하다고 생각한다면, 이 기사를 참고해보세요. Bulma에 대한 간단한 개요를 통해 탐험 여정을 시작할 수 있습니다.\n\n## 열 구조\n\nBulma는 반응형 열 구조를 만들기 위해 Flexbox를 활용합니다. 기본 설정은 12개의 균일한 열이지만 사용자는 이 숫자를 쉽게 조정하거나 개별 열의 크기를 맞출 수 있습니다. 화면 폭의 절반을 차지하도록 단일 열을 만들려면 클래스 is-half를 추가하면 됩니다. 다른 열은 자동으로 나머지 공간을 채우게 됩니다. 이 예에서 동일한 효과를 만드는 다른 방법은 요소에 클래스 is-6를 추가하는 것입니다. 그 요소는 12개의 균일한 열 중 6개(전체 화면 폭의 절반)을 차지하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Offset](/assets/img/2024-06-20-BranchingOutFromBootstrapAQuickstartGuidetoBulma_0.png)\n\n## Offset\n\n특정 열 요소의 오프셋을 만들려면, 대상 주변의 여백을 자동으로 채울 빈 열을 생성하거나 오프셋 수정자를 사용할 수 있습니다. 다음은 어떻게 보이는지에 대한 예시입니다:\n\n![Offset Example](/assets/img/2024-06-20-BranchingOutFromBootstrapAQuickstartGuidetoBulma_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 모바일 반응성\n\n기본적으로 Bulma 컬럼은 모바일 장치에서 쌓이게 됩니다. 그러나 모바일 장치에서 기존의 컬럼 구조가 유지되길 원한다면 간단히 컬럼 컨테이너에 is-mobile 수정자를 추가해주시면 됩니다.\n\n## 브레이크포인트\n\n모든 장치 유형에 대해 컬럼을 사용한다면, 컬럼 요소에 대해 브레이크포인트를 정의할 수 있습니다. 컬럼 크기나 스팬을 조정하는 것과 유사하게 뷰포트 크기(모바일, 태블릿 또는 데스크톱)를 끝에 추가해주시면 됩니다. 예를 들어, 사진에 적용된 컬럼 스팬을 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n\n<div class=\"columns\">   \n  <div id=”popsiclePhoto” class=\"column \n   is-4-desktop is-6-tablet is-8-mobile/>\n\n\n<img src=\"/assets/img/2024-06-20-BranchingOutFromBootstrapAQuickstartGuidetoBulma_2.png\" />\n\n<img src=\"/assets/img/2024-06-20-BranchingOutFromBootstrapAQuickstartGuidetoBulma_3.png\" />\n\n<img src=\"/assets/img/2024-06-20-BranchingOutFromBootstrapAQuickstartGuidetoBulma_4.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n## 컬럼 갭\n\nBulma에서는 갭을 컬럼 갭이라고 합니다. Bulma 컬럼 갭의 기본 값은 0.75rem이지만 is-gapless를 사용하여 제거하거나 is-0부터 is-8 중 하나를 사용하여 사용자 정의 할 수 있습니다. 기본값은 is-3입니다.\n\n## 기타 스타일링 도구\n\n한 컬럼 컨테이너 안에 여러 줄의 컬럼을 저장하려면 columns 클래스 내에서 is-multiline 수정자를 사용할 수 있습니다. 높이가 다른 컬럼을 수직으로 정렬하려면 columns 컨테이너에 is-vcentered를 추가하십시오. Offset 섹션에서 다룬 방법을 사용하지 않고 컬럼을 수평으로 쉽게 가운데로 정렬하려면 부모 컬럼 요소에 is-centered를 추가하십시오.\n\n<div class=\"content-ad\"></div>\n\n## 추가 문서\n\n이 글이 Bulma의 구조 기초를 이해하는 데 도움이 되셨으면 좋겠습니다. 더 자세한 정보는 Bulma 웹사이트(https://bulma.io/)를 참조하시기 바랍니다.\n\n행운을 빕니다! 코딩 즐기세요!","ogImage":{"url":"/assets/img/2024-06-20-BranchingOutFromBootstrapAQuickstartGuidetoBulma_0.png"},"coverImage":"/assets/img/2024-06-20-BranchingOutFromBootstrapAQuickstartGuidetoBulma_0.png","tag":["Tech"],"readingTime":3},{"title":"CSS에서 기본 글꼴 크기로 10px 또는 625를 설정해서는 안 되는 이유","description":"","date":"2024-06-20 03:14","slug":"2024-06-20-Whyyoushouldneverset10pxor625asyourbasefontsizeinCSS","content":"\n\n세계와 기술이 발전함에 따라 억지로 무언가를 작동하려고 하면 나중에 문제가 발생할 수 있습니다. 특히 CSS에서 기본 글꼴 크기를 조정하는 개발자들에게 이는 특히 사실입니다. 이 기사에서는 기본 글꼴 크기를 처리하는 다양한 방법을 효과적인 방법부터 최적의 방법까지 다루고 그들을 올바르게 사용하는 방법을 설명하겠습니다. 그러나 가장 중요한 것은...\n\n#사람들이 왜 기본 글꼴 크기를 설정하는가?\n\n이를 이해하려면 CSS에서 다른 측정 단위인 rem을 이해할 필요가 있습니다. 이 단위는 루트 또는 HTML 문서 요소의 글꼴 크기를 나타냅니다. 대부분의 브라우저는 1rem = 16px를 기본 글꼴 크기로 설정하는데, 이 크기는 좋은 가독성을 제공하며 사용자가 브라우저 설정을 조정할 때 쉽게 확대할 수 있습니다.\n\n개발자들은 레이아웃 속성(여백, 안쪽여백, 글꼴 크기 등)을 정의하는 데 이 단위를 사용할 수 있습니다. 예를 들어, 여백을 2rem으로 설정하면 32px로 설정하는 것과 같습니다. 그러나 개발자가 무언가를 12px로 설정하고 싶을 때는 어떻게 해야 할까요? 계산을 해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n12 / 16 = 0.75rem\n```\n\n이런 계산을 피하기 위해 개발자들은 보통 기본 글꼴 크기를 10px로 변경합니다.\n\n```js\nhtml {\n  font-size: 10px;\n}\n```\n\n그리고 와! 12px를 설정하고 싶다면 10으로 나누면 1.2rem이라는 답을 쉽게 찾을 수 있습니다. 좋아 보이나요? 하지만 이것이 많은 문제의 근본이 되고 피해야 할 필수적인 것임을 알게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 기본 글꼴 크기를 10px로 설정합니다\n\n우리는 방금 본 것처럼, 기본 글꼴 크기를 10px로 설정하여 시작하겠습니다. 하지만 먼저 강조하고 싶은 것은\n\n계산이 우리의 해결책을 이끌 때 특히 문제를 야기할 수 있는 경우에는 안내서는 안 되는 것입니다.\n\n- 접근성: 글꼴 크기를 너무 작게 설정하면 접근성 지침을 위반할 수 있으며, 일부 사용자들이 콘텐츠와 상호 작용하기 어렵게 할 수 있습니다.\n- 가독성: 본문 텍스트는 최소 16px 이어야 하며, 가독성을 높이기 위해 텍스트 크기를 12px보다 작게 설정하면 안 됩니다. 그렇지 않으면 사용자는 콘텐츠를 편안하게 읽기 위해 확대하거나 브라우저 설정을 조정해야 할 수 있습니다.\n- 사용자 설정 무시: 브라우저는 사용자의 기계에서 기본 설정을 가져옵니다. 사용자가 기계에서 텍스트를 확대한 경우, 기본 글꼴 크기를 무시하는 것은 사용자 설정을 무시하는 것이며, 절대로 해서는 안 되는 것 입니다.\n\n<div class=\"content-ad\"></div>\n\n# 기본 글꼴 크기를 62.5%로 설정하기\n\n앞서 언급한 문제들을 해결하기 위해 개발자들은 다음과 같은 접근 방식을 고안했습니다.\n\n```js\nhtml {\n  font-size: 62.5%; // 글꼴 크기를 1rem = 10px로 설정\n}\n\nbody {\n  font-size: 1.6rem; // 글꼴 크기를 다시 10*1.6 = 16px로 설정\n}\n```\n\n이는 1rem = 10px로 간편한 계산과 16px로 표준을 따르는 본문 크기를 가질 수 있는 똑똑한 해결책입니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 멋져 보이지만 말했듯이 세상은 변화하고 변화에 따라 이전에 없던 많은 문제가 발생합니다.\n\n# 웹 구성 요소와 마이크로 프론트엔드\n\n웹 구성 요소는 개발자가 재사용 가능한 사용자 정의 HTML 요소를 만들 수 있는 널리 사용되는 웹 API입니다. 기본적으로 HTML, CSS 및 JavaScript 코드를 단일한, 독립적인 단위로 패키징하여 다른 프로젝트에서 쉽게 재사용하고 다른 사람들과 공유할 수 있는 방법입니다. 마찬가지로, 마이크로 프론트엔드는 독립적인 앱이 다른 앱 내부에서 사용되는 아키텍처입니다.\n\n가령 rem 단위를 기반으로 웹 구성 요소 라이브러리를 생성했다고 가정해보겠습니다. rem은 응답성에 많이 사용되는 인기 있는 단위입니다. 이러한 컴포넌트는 1 rem = 16px를 기반으로 설계되어 있습니다. 그렇다면 이러한 컴포넌트를 기본 글꼴 크기가 1 rem = 62.5% = 10px인 웹 앱에서 사용하면 어떻게 될까요?\n\n<div class=\"content-ad\"></div>\n\n구성 요소 디자인은 모든 글꼴 크기가 축소되어 나쁘게 보일 것입니다. 버튼 글꼴 크기가 1rem(16px)를 사용하도록 설계된 경우, 새 앱에서는 10px이 될 것입니다. 또한 웹 구성 요소에 대해 특정하게 기본 글꼴 크기를 재정의할 수 있는 방법이 없습니다. 기본 글꼴 크기는 항상 루트에서 가져옵니다.\n\n<img src=\"/assets/img/2024-06-20-Whyyoushouldneverset10pxor625asyourbasefontsizeinCSS_0.png\" />\n\n비슷하게, 다른 앱 내에서 사용되는 마이크로 프런트엔드가 있는 경우 어떻게 될까요? 원래 마이크로 프런트엔드도 디자인에 rem 단위를 사용하고 있습니다. 그러나 기본 글꼴 크기를 62.5%로 설정하는 앱에서 사용되고 있다면 동일한 문제가 발생할 것입니다. 상기 이미지에서 확인할 수 있듯이요.\n\n# 좋은 실천 방법\n\n<div class=\"content-ad\"></div>\n\n기본 글꼴 크기를 설정하지 않으면 사용자의 브라우저가 사용자가 사용하고 싶은 글꼴 크기를 결정하므로 매우 간단합니다. 이렇게 하면 오늘의 문제뿐만 아니라 미래의 불확실성도 피할 수 있습니다.\n\n끝까지 읽어 주셔서 감사합니다!\n\n다음 기사를 기다렸습니다. 구독해 주시고 기다려 주세요.","ogImage":{"url":"/assets/img/2024-06-20-Whyyoushouldneverset10pxor625asyourbasefontsizeinCSS_0.png"},"coverImage":"/assets/img/2024-06-20-Whyyoushouldneverset10pxor625asyourbasefontsizeinCSS_0.png","tag":["Tech"],"readingTime":3},{"title":"이미지가 표시되지 않아요","description":"","date":"2024-06-20 03:13","slug":"2024-06-20-Imagesnotdisplaying","content":"\n\n음식 레시피와 농담을 가져오는 애플리케이션을 개발하면서 우리 팀은 흥미로운, 귀찮은, 작지만 크고 매우 눈에 띄는 문제에 직면했어요.\n\n백그라운드 이미지가 VSC의 Live Server 플러그인으로 코드를 테스트할 때만 나타나는 문제가 있었죠. Github 페이지 배포나 로컬 환경에서는 이미지가 나타나지 않았어요.\n\n디버깅을 위해 우리는 배경이 없는 페이지에서 인스펙터를 열고 에러 (1)를 확인했어요 - 파일을 찾을 수 없음. 그리고 CSS를 확인해보니 이미지 위치를 지정한 위치 (2)와 소스 탭도 봤어요. CSS는 브라우저에게 존재하지 않는 폴더 (3)에서 찾도록 지시하고 있었어요. 루트 디렉토리(C 드라이브)에 assets/images 폴더가 없네요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지가 표시되지 않는 이유](/assets/img/2024-06-20-Imagesnotdisplaying_1.png)\n\n왜 이런 일이 발생하는 걸까요?\n\nCSS(2)에서 절대 경로를 사용하고 있는데, 경로 시작 부분에 슬래시( / )가 있어서 assets 폴더가 루트 디렉토리 안에 바로 있는 디렉토리에서 이미지를 찾고 있는 것 같아요. 하지만 해당 assets 폴더가 실제로는 존재하지 않는 것 같습니다.\n\nCSS에서 경로를 아래와 같이 상대 경로로 변경하면, ..으로 시작해서 CSS 파일의 부모 디렉토리를 가리키게 되므로, 브라우저가 우리의 배경 이미지 위치를 올바르게 가리킬 수 있게 됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-Imagesnotdisplaying_2.png)\n\nLive Server를 통해 절대 경로를 사용하면 문제가 가려질 수 있습니다. 루트 디렉토리에 assets라는 디렉토리가 있기 때문에 경로는 유효한 것입니다.\n\n![이미지](/assets/img/2024-06-20-Imagesnotdisplaying_3.png)\n\n이 문제에 대한 해결책을 검색할 때 많은 사람들이 같은 질문을 하지만 완전한 답변을 찾기 어렵습니다. 상대 경로와 절대 경로는 혼란스러울 수 있으며, 처음 시작할 때 충분히 고려되지 않는 경우가 많습니다. 이 기사가 조금이나마 도움이 되길 바라겠습니다!\n\n<div class=\"content-ad\"></div>\n\n읽어 주셔서 감사합니다! 코딩 즐겁게 하세요!","ogImage":{"url":"/assets/img/2024-06-20-Imagesnotdisplaying_0.png"},"coverImage":"/assets/img/2024-06-20-Imagesnotdisplaying_0.png","tag":["Tech"],"readingTime":2},{"title":"CSS 배경과 테두리 사용하기","description":"","date":"2024-06-20 03:10","slug":"2024-06-20-HowToUseCSSBackgroundsandBorders","content":"\n\n![이미지](/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_0.png)\n\nCSS 배경과 테두리의 슈퍼파워를 해제할 준비가 되셨나요? 이 강의는 화려한 그라데이션부터 매력적인 이미지, 부드러운 둥근 모서리까지 활용하는 창의적인 방법을 살펴봅니다. 지루한 웹 사이트는 잊고, 배경과 테두리가 디자인 마법의 열쇠입니다!\n\n# CSS로 창의적인 배경 만들기\n\nCSS 스타일시트의 복잡한 배경 속성에 압도당하고 있나요? 걱정 마세요, 우린 여기 있어요! 배경의 단축 속성이 많은 정보를 담을 수 있지만, 이 강의에서는 한 단계씩 세부적으로 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n사각형.box를 예시로 들어 설명하면, 처음에는 복잡해 보일지 모르겠지만 개별 구성 요소인 그라데이션, 이미지, 색상 등을 분해하여 전체 가능성을 펼쳐보자구!\n\n<div class=\"content-ad\"></div>\n\n## CSS에서 배경 설정하기\n\nCSS의 `background-color` 속성을 사용하면 어떤 요소든 생동감 있는 배경으로 칠할 수 있습니다. 전통적인 \"빨간색\"과 같은 고전적인 이름부터 팬시한 헥스 코드(#FF0000)까지 모든 유효한 색상 형식을 허용합니다. 이 색상은 콘텐츠, 패딩, 심지어 요소의 테두리 뒷면 (다른 방식으로 지정하지 않으면)을 모두 채웁니다.\n\n실제 동작을 확인해 보세요! 다음 예시에서는 다양한 색상 값을 사용하여 상자, 제목, `span` 요소에 화려함을 더해 보았습니다. 상상할 수 있는 모든 색상으로 실험해 보세요!\n\n<img src=\"/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n\n.box {\n  background-color: #567895;\n}\n\nh2 {\n  background-color: black;\n  color: white;\n}\nspan {\n  background-color: rgb(255 255 255 / 50%);\n}\n\n\n\n<div class=\"box\">\n  <h2>배경 색상</h2>\n  <p>배경 <span>색상</span>을 변경해보세요.</p>\n</div>\n\n\n## CSS 배경 이미지로 이미지 추가하기\n\nCSS의 background-image 속성을 사용하면 어떤 요소든 멋진 이미지를 표현할 수 있습니다. 단순히 이미지 파일의 경로를 제공하면 요소의 배경에 이미지가 나타납니다.\n\n\n<div class=\"content-ad\"></div>\n\n마법을 실행해 봅시다! 이 예제에서는 두 개의 상자가 있습니다:\n\n- 상자 1: 상자보다 큰 배경 이미지(\"balloons.jpg\")가 있습니다. 기본적으로 이미지의 일부분만 볼 수 있습니다.\n- 상자 2: 더 작은 이미지(\"star.png\")를 사용합니다. 여기서 이미지는 상자의 전체 배경을 채우기 위해 반복(타일 구성)됩니다.\n\n이 예제는 배경 이미지에 관한 두 가지 중요한 사항을 강조합니다:\n\n- 크기 조절: 큰 이미지는 자동으로 요소에 맞게 축소되지 않습니다.\n- 타일링: 작은 이미지는 전체 배경 영역을 채우기 위해 반복됩니다.\n\n<div class=\"content-ad\"></div>\n\n본 수업에서는 이러한 행동을 제어하고 배경 이미지로 더 멋진 효과를 만드는 방법을 나중에 살펴볼 예정입니다!\n\n![image](/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_2.png)\n\n```css\n.a {\n  background-image: url(balloons.jpg);\n}\n\n.b {\n  background-image: url(star.png);\n}\n```\n\n```html\n<div class=\"wrapper\">\n  <div class=\"box a\"></div>\n  <div class=\"box b\"></div>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n이미지로 색상이 빛날 수 있다면 어떨까요? 위의 예제에 background-color 속성을 추가해 보세요! 일반적으로 배경 이미지는 정의한 모든 색상 위에 배치됩니다. 이것을 마음껏 조절해 보세요. 예상치 못한 멋진 효과를 얻을 수도 있어요!\n\n## 배경 반복 제어하기\n\nbackground-repeat 속성은 이미지의 타일링 동작을 제어하는 데 사용됩니다. 사용 가능한 값은 다음과 같습니다:\n\n- no-repeat — 배경 반복 금지합니다.\n- repeat-x — 가로로 반복합니다.\n- repeat-y — 세로로 반복합니다.\n- repeat — 기본값으로, 양방향으로 반복합니다.\n- space — 가능한 한 많이 반복하되, 여분의 공간이 있으면 이미지 사이에 공간을 추가합니다.\n- round — space 와 비슷하지만, 여분 공간을 채우기 위해 이미지를 늘립니다.\n\n<div class=\"content-ad\"></div>\n\n아래 예시에서 이 값들을 시도해보세요. 값이 no-repeat으로 설정되어 있어서 별 하나만 보일 것입니다. 다른 값들인 repeat-x와 repeat-y를 시도해 보면 그 효과를 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_3.png\" />\n\n```js\n.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n}\n```\n\n```js\n<div class=\"box\"></div>\n```\n\n<div class=\"content-ad\"></div>\n\n## CSS에서 배경 이미지 크기 조절\n\n\"balloons.jpg\" 예제를 기억하시나요? 이미지가 너무 크고 상자 크기를 초과하여 잘리는 문제가 있었죠. 하지만 걱정하지 마세요, CSS가 완벽한 이미지 크기 조절 키를 가지고 있습니다!\n\nbackground-size 속성을 사용하면 배경 이미지가 요소 내에 어떻게 맞춰지는지를 제어할 수 있습니다. 다음을 사용할 수 있습니다:\n\n- 길이 또는 퍼센트: 정확한 크기를 지정하여 (예: \"100px\" 또는 \"50%\") 정밀한 제어가 가능합니다. (이는 이미지 왜곡을 일으킬 수 있으니 조심하세요!)\n\n\n\n\n<div class=\"content-ad\"></div>\n\n키워드:\n\n- cover: 이미지를 상자 안을 완전히 채우면서 가로세로 비율을 유지합니다. 이미지의 일부가 상자 외부에 숨겨질 수 있습니다.\n- contain: 이미지를 상자 안에 완전히 맞추면서 가로세로 비율을 유지합니다. 이로 인해 이미지 주변에 빈 공간이 남을 수 있습니다.\n\n아래 예제에서 실험해 봅시다!\n\n- 길이 조정: background-size의 픽셀 값을 변경하여 이미지에 어떤 영향을 주는지 확인해보세요.\n- 키워드 마니아: 픽셀 값을 제거하고 background-size: cover 또는 background-size: contain을 설정하여 자동으로 크기를 조절해보세요.\n- 작은 이미지 반복: 이미지가 상자보다 작을 경우, background-repeat를 조정하여 이미지를 반복하고 공간을 채울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기술들을 활용하면 이미지 크기와 요소 크기 사이에 완벽한 균형을 찾을 수 있어요!\n\n![image](/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_4.png)\n\n```css\n.box {\n  background-image: url(balloons.jpg);\n  background-repeat: no-repeat;\n  background-size: 100px 10em;\n}\n```\n\n```html\n<div class=\"box\"></div>\n```\n\n<div class=\"content-ad\"></div>\n\n## 배경 이미지를 배치하는 위치\n\n배경 위치 속성을 사용하면 상자 내에서 배경 이미지가 나타나는 정확한 위치를 정할 수 있습니다. 상자에 무대가 있다고 상상해보세요. (0,0)이 중앙 무대 조명인 것처럼요.\n\n이것이 이미지 배치를 위한 도구 상자입니다:\n\n- 키워드: 간단하고 직접적이에요! 이미지를 배치할 때 “top”, “bottom”, “left”, “right”와 같은 용어를 사용하세요. (배경 위치 문서에서 더 많은 옵션을 살펴보세요!)\n- 길이와 백분율: 정확한 제어가 필요하신가요? 픽셀 값 (예: “20px”)이나 백분율 (예: “10%”)을 지정하여 정확한 위치를 지정할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n  background-position: top center;\n}\n\n\n\n.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n  background-position: 20px 10%;\n}\n\n\n\n.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n  background-position: 20px top;\n}\n\n\n\n.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n  background-position: top 20px right 10px;\n}\n\n\n<div class=\"content-ad\"></div>\n\n준비가 되셨나요? 조합해 보세요! 그림을 자유롭게 조절할 수 있어요. 단, 첫 번째 값이 수평 위치(좌우), 두 번째 값이 수직 위치(상하)를 제어합니다.\n\n모험을 즐길 준비가 되셨나요? 4개의 값 구문을 사용하여 더 많은 제어를 해보세요. 특정 상자 가장자리에서 그림을 미끄러뜨리거나 끌어내리는 상상해 보세요. 예를 들어, \"위 20px 오른쪽 10px\"는 그림을 위에서 20픽셀 아래로, 오른쪽 가장자리에서 10픽셀 멀리 위치시킵니다.\n\n이제 실습해 볼까요? 아래 예제의 값을 바꿔서 노는 것도 좋아요. 그 별을 진정한 이미지 감독처럼 이동해 보세요!\n\n![그림](/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_5.png)\n\n<div class=\"content-ad\"></div>\n\n```js\n.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n  background-position: 120px 1em;\n}\n```\n\n```js\n<div class=\"box\"></div>\n```\n\n## 그라디언트 배경의 힘을 발휘해보세요\n\n단조로운 색상에 지쳤나요? 그라디언트는 귀하의 웹사이트에 화려한 전환을 더할 수 있습니다! 그라디언트는 배경 이미지처럼 작동하며 익숙한 background-image 속성을 사용하여 설정됩니다. \n\n<div class=\"content-ad\"></div>\n\n그라데이션을 더 깊게 탐구해보세요! 'gradient' 데이터 유형에 대한 MDN 페이지에서 다양한 유형과 가능성에 대해 설명합니다. (MDN 페이지 링크를 여기에 삽입).\n\n코딩 없이 실험해 보고 싶나요? CSSGradient.io와 같은 멋진 CSS 그라데이션 생성기가 온라인에 많이 있습니다. 가볍게 놀며 멋진 그라데이션을 만들고 생성된 코드를 간단히 복사하여 붙여넣어보세요!\n\n실제로 확인해보세요! 아래 예시에서 두 개의 상자가 서로 다른 그라데이션을 보여줍니다:\n\n- 상자 1: 전체 상자를 우아하게 가로지르는 선형 그라데이션.\n- 상자 2: 정의된 크기를 가지는 원형 그라데이션으로 반복되는 패턴을 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n자신만의 매혹적인 그라데이션을 만들 준비가 되셨나요? 가능성을 탐험해보세요!\n\n![그라데이션 이미지](/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_6.png)\n\n```js\n.a {\n  background-image: linear-gradient(105deg, rgb(0 249 255 / 100%) 39%, rgb(51 56 57 / 100%) 96%);\n}\n\n.b {\n  background-image: radial-gradient(circle, rgb(0 249 255 / 100%) 39%, rgb(51 56 57 / 100%) 96%);\n  background-size: 100px 50px;\n}\n```\n\n```js\n<div class=\"wrapper\">\n  <div class=\"box a\"></div>\n  <div class=\"box b\"></div>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n## 여러 배경 이미지 사용하기\n\n계층화된 배경 효과를 만들고 싶나요? CSS를 사용하면 한 번에 여러 배경 이미지를 포함할 수 있어요! 간단히 background-image 속성에서 각 이미지 URL을 쉼표로 구분하세요.\n\n이것을 한 덩어리로 생각해보세요:\n\n- 코드에서 나열하는 마지막 이미지는 스택의 아래쪽에 배치되어요 (기본 레이어처럼).\n- 각 이전 이미지는 위로 층을 이루며 아름다운 시각적 효과를 만들어냅니다.\n\n<div class=\"content-ad\"></div>\n\n보너스! 그라데이션도 함께 참여하여 일반 이미지와 혼합하여 더 많은 창의적인 가능성을 끌어올릴 수 있어요.\n\n레이어 제어하기:\n\n다른 background-* 속성들(예: repeat 및 position)도 쉼표로 구분된 여러 값들과 함께 작동할 수 있어요. 여기 주의할 점이 있어요:\n- 속성의 각 값은 background-image 목록에 나타난 순서에 맞춰 이미지와 일치해야 해요.\n- 이미지보다 적은 값이 있는 경우, 해당 값들은 이미지들을 순환하게 될 거에요.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 아래 코드에서는 네 개의 이미지가 있지만 background-position 값이 두 개뿐입니다. 처음 두 위치는 첫 번째 두 이미지에 적용되고 나머지 이미지에 대해서도 동일하게 반복됩니다.\n\n실험해 보세요! 아래 예제를 활용해 다음을 해보세요:\n\n- 이미지 목록에서 이미지 순서를 바꿔보면 쌓임 순서가 어떻게 변경되는지 확인해보세요.\n- 다른 속성을 수정하여 이미지의 위치, 크기 또는 이미지 반복 빈도를 조절해 보세요.\n\n약간의 연습으로 층으로 구성된 시각적으로 멋진 배경을 만들어내는 마스터가 될 수 있을 거에요!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_7.png\" />\n\n```js\n.box {\n  background-image: url(star.png), url(big-star.png);\n}\n```\n\n```js\n<div class=\"wrapper\">\n  <div class=\"box\"></div>\n</div>\n```\n\n## 배경 첨부\n\n<div class=\"content-ad\"></div>\n\nCSS에서 배경을 다룰 때, 컨테이너 내의 콘텐츠가 스크롤될 때 배경이 어떻게 작동하는지 제어할 수 있어요. 이건 background-attachment 속성을 사용하여 달성되며, 주요 세 가지 값이 있어요:\n\n- scroll (기본값): 이 설정은 배경 이미지가 페이지 콘텐츠와 함께 스크롤되도록 만들어요. 그러나 요소 자체에 스크롤 가능한 콘텐츠가 있는 경우, 배경은 요소에 대해 고정되어 스크롤 콘텐츠와 함께 움직이지 않아요.\n- fixed: 이 값은 배경 이미지를 화면(브라우저 창의 보이는 영역)에 고정시켜요. 페이지나 요소의 콘텐츠를 얼마나 스크롤해도 배경 이미지는 화면에서 같은 위치에 유지돼요.\n- local: 이 설정은 배경 이미지를 적용된 요소에 고정시킵니다. 따라서 요소의 콘텐츠를 스크롤하면 배경 이미지가 함께 스크롤되어 요소 자체 내에서 스크롤 효과가 생겨요.\n\n배경-attachment 속성은 요소나 페이지 내에서 실제로 스크롤할 콘텐츠가 있는 경우에만 뚜렷한 효과가 있다는 것이 중요해요.\n\n여기서 직접 해보세요!\n\n<div class=\"content-ad\"></div>\n\n## 효율성을 위한 배경 단축키\n\nCSS는 한 번에 여러 배경 속성을 정의하는 단축키를 제공하여 코드 양을 줄이고 가독성을 향상시킬 수 있습니다. 이 단축키는 `background` 속성 자체이며, 단축키 역할을 합니다.\n\n여러 배경을 사용할 때는 `background` 속성 값 내에서 쉼표로 구분된 리스트로 각 배경의 모든 속성을 지정할 수 있습니다.\n\n값을 구성하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 각 배경 정의에는 색상, 이미지, 위치, 반복 방법 등과 같은 해당 속성을 위한 값이 포함됩니다.\n- 순서가 중요합니다. 한 배경에 대한 모든 속성은 다음 배경 정의로 넘어가기 전에 함께 나열되어야 합니다.\n- 배경 색상 위치: 여러 개의 배경을 사용할 경우, 배경 색상 속성은 마지막 콤마 뒤에만 지정할 수 있으며, 다른 배경 정의와 구분되어야 합니다.\n- 배경 크기 및 위치: 배경 크기와 배경 위치를 함께 사용하는 경우, 슬래시 (/)로 구분하여 함께 배치해야 합니다.\n\n![How To Use CSS Backgrounds and Borders](/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_8.png)\n\n```css\n.box {\n  background:\n  linear-gradient(105deg, rgb(255 255 255 / 20%) 39%, rgb(51 56 57 / 100%) 96%) center center / 400px 200px no-repeat,\n  url(big-star.png) center no-repeat,\n  rebeccapurple;\n}\n```\n\n```html\n<div class=\"box\"></div>\n```\n\n<div class=\"content-ad\"></div>\n\n## 배경 접근성 향상하기\n\n- 색 대비가 중요합니다: 배경 이미지나 색상을 사용할 때 텍스트와 배경 사이에 충분한 대비가 있는지 확인하세요. 이렇게 함으로써 시각 장애를 가진 사용자를 포함한 모든 사람이 텍스트를 쉽게 읽을 수 있습니다. 충분한 대비 여부를 확인할 수 있는 온라인 도구가 있습니다.\n- 배경 이미지를 위한 대체 시스템: 텍스트가 배경 이미지 위에 있는 경우, 항상 배경 색상을 지정하세요. 이 색상은 이미지가 어떤 이유로든 로드되지 않는 경우에도 텍스트가 가독성있게 유지되도록 합니다.\n- 장식 용도의 배경 이미지: 화면 낭독기가 배경 이미지를 해석할 수 없으므로 배경 이미지는 장식 용도로만 사용하세요. 중요 정보는 배경 이미지 안에 숨기지 말고 HTML 콘텐츠에 직접 포함시키세요. 이렇게 하면 모든 사람이 정보에 접근할 수 있습니다.\n\n# 테두리를 창의적으로 활용하기\n\n이전 레슨에서 배운 박스 모델을 기억하시나요? 테두리는 그 모델 내에서 요소의 크기를 정의하는 데 중요한 역할을 합니다. 이제 테두리를 디자인 목적으로 창의적으로 활용하는 방법을 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n- 효율을 위한 간편한 표기법: CSS에서는 보통 border shorthand 속성을 사용하여 테두리의 색상, 너비 및 스타일을 한 줄로 정의합니다. 이 속성은 요소의 네 면에 동일한 스타일을 적용합니다.\n- 개별 측면 지정: 상자의 특정 측면에 대한 테두리를 지정할 수도 있습니다. border-top, border-right, border-bottom, border-left와 같은 속성을 사용하여 각 측면을 독립적으로 스타일링할 수 있습니다.\n\n개별 테두리 속성: border shorthand는 세 개의 개별 속성으로 확장됩니다:\n\n- border-width: 테두리 선의 두께를 제어합니다.\n- border-style: 테두리의 시각적 모양을 정의합니다 (예: solid, dashed, dotted).\n- border-color: 테두리의 색상을 설정합니다.\n\n세심한 제어를 위한 Longhand 속성: 더 세밀한 제어를 위해 CSS는 테두리 각 측면에 대한 longhand 속성을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n- 너비에 대한 border-top-width, border-right-width, border-bottom-width 및 border-left-width가 있습니다.\n- 스타일에 대한 border-top-style, border-right-style, border-bottom-style 및 border-left-style이 있습니다.\n- 색상에 대한 border-top-color, border-right-color, border-bottom-color 및 border-left-color가 있습니다.\n\n논리적 속성(다음 레슨): 다음 레슨에서는 논리적 테두리 속성을 살펴보겠습니다. 이러한 속성은 문서의 작성 모드(예: 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽)에 적응합니다.\n\n스타일 실험: 테두리에는 다양한 스타일이 있습니다. border-width, border-style 및 border-color를 조정하여 요소에 독특한 시각적 효과를 만들어보세요.\n\n<img src=\"/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_9.png\" />\n\n<div class=\"content-ad\"></div>\n\n```css\n.box {\n  background-color: #567895;\n  border: 5px solid #0b385f;\n  border-bottom-style: dashed;\n  color: #fff;\n}\n\nh2 {\n  border-top: 2px dotted rebeccapurple;\n  border-bottom: 1em double rgb(24 163 78);\n}\n```\n\n```html\n<div class=\"box\">\n  <h2>Borders</h2>\n  <p>Try changing the borders.</p>\n</div>\n```\n\n## 꼭지각형으로 모양 만들기\n\nborder-radius 속성을 사용하면 상자의 모서리를 둥글게 형성할 수 있습니다. 곡률을 정의하는 shorthand와 longhand 옵션이 모두 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n- \"Uniform Radii에 대한 단축 표기법: 대부분의 경우, border-radius의 단축 형식을 사용할 것입니다. 하나 또는 두 값을 허용합니다.\"\n- \"단일 값: 단일 값은 상자의 네 꼭지 모두에 동일한 곡률을 적용합니다.\"\n- \"두 값: 두 값은 별도의 수평 및 수직 반지름을 정의하며, 타원형 코너를 만들 수 있습니다.\"\n- \"예제: 일괄 라운딩: 모든 코너에 10px 반경을 만드는 방법은 다음과 같습니다:\"\n\n```js\n.box {\n  border-radius: 10px;\n}\n```\n\n- \"개별 코너에 대한 Longhand 속성: 더 많은 제어가 필요한 경우, border-top-right-radius와 같은 Longhand 속성을 사용하여 각 코너를 개별적으로 스타일링할 수 있습니다. 이러한 속성은 shorthand와 유사하게 하나 또는 두 값을 취합니다.\"\n- \"예제: 타원형 코너: 이 예제에서는 상단 오른쪽 코너에 1em 가로 반지름과 10% 세로 반지름을 설정하여 타원형 효과를 만듭니다:\"\n\n```js\n.box {\n  border-top-right-radius: 1em 10%;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- 논리적 속성 (다음 레슨): 테두리와 유사하게, 논리적 테두리 반경 속성은 문서의 작성 모드에 맞게 조정됩니다.\n- 실험하고 탐험해보세요: 원하는 코너 모양을 얻기 위해 다양한 반경 값으로 놀아보세요. 자세한 구문 옵션은 보더 반경 속성 문서(여기에 포함되지 않음)를 참조하세요. \"border-radius 생성기\"와 같은 온라인 도구도 있어서 구체적인 둥근 코너 스타일을 시각화하고 코드를 생성하는 데 도움이 될 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_10.png)\n\n```js\n.box {\n  border: 10px solid rebeccapurple;\n  border-radius: 1em;\n  border-top-right-radius: 10% 30%;\n}\n```\n\n```js\n<div class=\"box\">\n  <h2>테두리</h2>\n  <p>테두리를 변경해보세요.</p>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n상자의 모서리를 부드럽게 만들고 싶나요? 그럼 border-radius 속성을 확인해보세요! 이를 통해 꼭지의 정도를 제어할 수 있어요.\n\n- 균일한 둥근 모서리 (가장 일반적): 네 개 모서리에 동일한 둥근 정도를 적용하기 위해 값(픽셀, ems 또는 백분율)을 제공하세요.\n- 타원형 모서리: 고급스러운 느낌을 원하시나요? 두 개의 값으로 타원 효과를 위한 별도의 수평 및 수직 반지름을 정의하세요.\n- 개별 모서리 제어 (옵션): 더 정밀한 조절이 필요하다면 CSS는 각 모서리를 독립적으로 스타일링할 수 있게 하는 border-top-left-radius와 같은 확장 속성을 제공합니다.\n\n```js\ntype SocialMedia = {\n  LinkedIn: string;\n  GitHub: string;\n  StackOverflow: string;\n  Litsy: string;\n  Email: string;\n  X: string;\n}\n\nfunction newSocialMedia(): SocialMedia {\n  return {\n    LinkedIn: \"https://www.linkedin.com/in/edwardcasanova/\",\n    GitHub: \"https://github.com/ed3899\",\n    StackOverflow: \"stackoverflow.com/users/11941146/edward-casanova\",\n    Litsy: \"https://www.litsy.com/web/stack/edca3899/read\",\n    Email: \"ed.wacc1995@gmail.com\",\n    X: \"https://twitter.com/edca3911\"\n  };\n}\nconst subscribe = (): string => {\n  return \"https://medium.com/@ed.wacc1995/subscribe\";\n};\nconst tip = (): string => {\n  return \"https://paypal.me/edca3899?country.x=MX&locale.x=es_XC\";\n};\n```","ogImage":{"url":"/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_0.png"},"coverImage":"/assets/img/2024-06-20-HowToUseCSSBackgroundsandBorders_0.png","tag":["Tech"],"readingTime":14},{"title":"Angular에서 컴포넌트간 데이터 전달하기","description":"","date":"2024-06-20 03:06","slug":"2024-06-20-PassingDataBetweenComponentsinAngular","content":"\n\n<img src=\"/assets/img/2024-06-20-PassingDataBetweenComponentsinAngular_0.png\" />\n\n작년에 Angular 개발자 포지션에 대한 면접을 많이 진행했었는데, 가장 자주 나온 질문 중 하나가 \"Angular에서 컴포넌트간 데이터를 전달하는 방법은 무엇인가요?\" 였어요. 이 프레임워크를 잘 알고 있는 사람들에겐 답이 상당히 직관적으로 보일 수 있지만, 처음에 생각한 것 이상으로 그 깊이가 있습니다. 이 질문은 면접관들이 선호하는데, 이는 지원자의 Angular 및 일반 웹 기술에 대한 지식을 측정할 수 있고 창의력을 발휘할 자유가 있기 때문이죠.\n\n본 기사에서는 그것을 수행할 수 있는 방법들을 비교적 포괄적으로 나열해 보려고 합니다. 비교적 일반적이지 않은 방법에 대해 심층적으로 다루기도 합니다. 컴포넌트 간 데이터를 전달하기 위한 다양한 합리적인 방법이 있다면, 덧글에 남겨주시면 기쁘게 기사에 추가하도록 하겠습니다.\n\n이 기사는 취업 면접을 준비하는 초보 및 중급 Angular 개발자들을 대상으로 합니다. 자세한 안내서가 아닌 모든 옵션을 보기 위한 개략적인 안내를 목적으로 합니다. 면접 준비를 위해 더 탐구할 만한 흥미로운 대화 주제들을 굵게 강조하여 포함하려고 노력했어요.\n\n<div class=\"content-ad\"></div>\n\n# @Input() 데코레이터\n\n@Input() 데코레이터는 Angular에서 컴포넌트 간 데이터를 전달하는 방법 중 가장 먼저 떠오르는 것입니다. 부모 컴포넌트로부터 데이터를 자식 컴포넌트로 전달하는 간단한 방법입니다.\n\n@Input()은 컴포넌트 트리에서 서로 직접적으로 관련된 경우에 특히 유용합니다. 서로 직접적으로 관련되지 않은 경우에는 여러 컴포넌트 사이를 통해 동일한 데이터를 전달해야 하는 \"prop drilling\"이라고 불리는 방법을 사용해야 할 수도 있습니다. 이 용어는 React에서 나온 것이며, props가 Angular의 @Input()과 유사한 역할을 합니다. Prop drilling은 실수가 발생하기 쉬우며, 애플리케이션이 커질수록 불편해지고 에러가 발생할 가능성이 높아집니다.\n\n@Input()의 또 다른 일반적인 사용 사례는 \"어리석은(stupid)\" 또는 \"표현(representational)\" 컴포넌트를 구축하는 것입니다. 이 경우, 부모 컴포넌트는 상태를 관리하고 @Input() 데코레이터를 통해 자식들로 데이터를 업데이트합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\nparent.component.ts\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <h2>Parent Component</h2>\n    <app-child [childMessage]=\"parentMessage\"></app-child>\n  `,\n})\nexport class ParentComponent {\n  parentMessage = \"Message from Parent\";\n}\n```\n\nchild.component.ts\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    <h4>Child Component</h4>\n    {{ childMessage }}\n  `,\n})\nexport class ChildComponent {\n  @Input() childMessage: string;\n}\n```\n\n# @Output() 데코레이터\n\n@Input()의 정반대로, @Output() 데코레이터는 자식 컴포넌트에서 상위 컴포넌트 또는 컴포넌트 트리 상단에 있는 다른 컴포넌트로 이벤트를 발생시키는 데 사용됩니다.\n\n@Output()을 사용하면, 자식 컴포넌트가 사용할 사용자 지정 이벤트를 정의하며, 이 이벤트를 가지고 있는 부모나 이벤트에 응답해야 하는 다른 컴포넌트가 해당 이벤트를 듣게 됩니다. 이 이벤트는 자식 컴포넌트가 부모에게 버튼 클릭, 폼 제출 또는 데이터 변경과 같은 사항이 발생했음을 알리기 위해 필요할 때 발생됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n좋은 연결고리가 될 것입니다. 또한, Event Driven Architecture에 대해 이야기할 수 있는 기회가 됩니다. 이는 본문의 범위를 벗어난 내용이지만, 더 자세히 알아볼 만한 주제입니다.\n\n## 예시:\n\nchild.component.ts\n\n```javascript\nimport { Component, EventEmitter, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    <button (click)=\"sendMessage()\">Send Message</button>\n  `,\n})\nexport class ChildComponent {\n  @Output() messageEvent = new EventEmitter<string>();\n\n  sendMessage() {\n    this.messageEvent.emit('Message from Child');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nparent.component.ts\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <h2>Parent Component</h2>\n    <app-child (messageEvent)=\"receiveMessage($event)\"></app-child>\n    <p>{ message }</p>\n  `,\n})\nexport class ParentComponent {\n  message: string;\n\n  receiveMessage($event: string) {\n    this.message = $event;\n  }\n}\n```\n\n이 예시에서는 자식 컴포넌트가 @Output() 데코레이터를 사용하여 messageEvent라는 사용자 정의 이벤트를 정의합니다. sendMessage() 메서드가 호출되면 messageEvent 이벤트가 'Message from Child'라는 문자열 값을 가지고 발생됩니다.\n\n부모 컴포넌트는 (messageEvent) 바인딩을 사용하여 messageEvent 이벤트를 청취하고 receiveMessage() 메서드에서 처리합니다. $event 매개변수는 자식 컴포넌트에서 발생된 데이터를 수신하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n# RxJS Subject을 사용한 서비스 활용\n\n컴포넌트들이 컴포넌트 트리에서 더 멀리 떨어져 있을 때, @Input() 및 @Output()을 사용하여 데이터를 전달하면 혼란스럽고 유지 관리하기 어려워질 수 있습니다. 이러한 경우에는 공유 서비스를 사용하여 데이터를 관리하고 공유할 중심적인 위치를 제공할 수 있습니다.\n\nRxJS 라이브러리는 서비스에서 데이터를 관리하고 컴포넌트가 데이터 변경에 구독할 수 있도록 Subject 클래스를 제공합니다.\n\n비유를 하자면, 소식을 공유하는 것과 비슷합니다. 이웃들과 소문을 공유할 때 한 명에게 정보를 전달하고 그들로부터 정보를 받는 것과 유사합니다. 이는 Angular에서 @Input() 및 @Output() 데코레이터를 사용하는 것과 비슷합니다. 그러나 반면에 기사를 작성하여 신문사에 보내면 개인적으로 알지 못하는 광범위한 청중에게 방송됩니다. 이는 Angular에서 서비스를 사용하는 것과 비슷합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n데이터 서비스\n\n```js\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  private data = new Subject<string>();\n  data$ = this.data.asObservable();\n\n  setData(data: string) {\n    this.data.next(data);\n  }\n}\n```\n\n송신자 컴포넌트\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { DataService } from '../data.service';\n\n@Component({\n  selector: 'app-sender',\n  template: `\n    <h3>보내는 컴포넌트</h3>\n    <button (click)=\"sendData()\">데이터 전송</button>\n  `,\n})\nexport class SenderComponent {\n  constructor(private dataService: DataService) {}\n\n  sendData() {\n    this.dataService.setData('보내는 컴포넌트에서 온 데이터');\n  }\n}\n```\n\nreceiver.component.ts\n\n```js\nimport { Component, OnDestroy } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { DataService } from '../data.service';\n\n@Component({\n  selector: 'app-receiver',\n  template: `\n    <h3>받는 컴포넌트</h3>\n    <p>{{ data }}</p>\n  `,\n})\nexport class ReceiverComponent implements OnDestroy {\n  data: string = '';\n  subscription: Subscription;\n\n  constructor(private dataService: DataService) {\n    this.subscription = this.dataService.data$.subscribe(data => {\n      this.data = data;\n    });\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n이 예시에서 SenderComponent는 DataService를 주입받고 setData() 메서드를 호출하여 데이터 Subject를 통해 데이터를 발행합니다. 이 데이터는 data$ Observable에 구독한 다른 컴포넌트에서 수신할 수 있습니다. ReceiverComponent는 DataService의 data$ Observable에 구독하여 새로운 데이터가 발행될 때마다 업데이트를 수신합니다. 구독을 저장하는 subscription 속성은 ngOnDestroy() 메서드에서 구독을 해지하여 메모리 누수를 방지합니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 신호를 사용한 서비스\n\nAngular 16에서 소개된 신호는 반응성 처리를 위한 새로운 방법을 제공합니다. RxJS의 어려운 학습 곡선을 피하고자 하는 경우, 이러한 단점을 회피하는 데 도움이 됩니다.\n\n이 접근 방식의 전반적인 논리는 동일합니다: 여전히 서비스 내부에 상태를 중앙 집중식으로 추적하고 상태 업데이트를 허용하며 업데이트된 상태로 반환하는 것이 있지만, 이 경우에는 Subject가 아닌 신호입니다.\n\n이 글을 작성하는 시점에서 신호가 널리 사용되기까지는 시간이 걸릴 수 있습니다(기술 미리보기 단계에 있습니다) 그리고 일부 오래된 코드베이스에서는 단순히 리팩토링 비용이 너무 많이 발생하여 결코 신호를 사용하지 않을 수 있습니다. 하지만 이 프레임워크의 동향을 파악하고 있다는 것을 보여주기 때문에 면접 시 신호에 대해 언급하는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\ndata.service.ts\n\n```js\nimport { Injectable, signal } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class DataSignalService {\n  private data = signal('');\n\n  setData(update: string) {\n    this.data.set(update);\n  }\n\n  getData(){\n    return this.data;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { DataSignalService } from '../data.service';\n\n@Component({\n  selector: 'app-sender-signal',\n  template: `\n    <h3>보내는 컴포넌트</h3>\n    <button (click)=\"sendData()\">데이터 전송</button>\n  `,\n})\nexport class SenderSignalComponent {\n  constructor(private dataService: DataSignalService) {}\n\n  sendData() {\n    this.dataService.setData('보내는 컴포넌트에서 온 데이터');\n  }\n}\n```\n\nreceiver.component.ts\n\n```js\nimport { Component } from '@angular/core';\nimport { DataSignalService } from '../data.service';\n\n@Component({\n  selector: 'app-receiver-signal',\n  template: `\n    <h3>받는 컴포넌트</h3>\n    <p>{ data() }</p>\n  `,\n})\nexport class ReceiverSignalComponent {\n  data;\n\n  constructor(private dataService: DataSignalService) {\n    this.data = this.dataService.getData();\n  }\n}\n```\n\n# 상태 관리 도구\n\n<div class=\"content-ad\"></div>\n\n상태 관리 도구는 많은 상태를 관리해야 할 때 특히 응용 프로그램 상태를 중앙에서 관리하는 방법을 제공합니다. 이 도구들은 코드를 조직하는 것을 쉽게 만들어줄 뿐 아니라 중복되는 데이터 흐름을 피하고 테스트를 용이하게 합니다. 이러한 도구들은 비동기 데이터를 더 쉽게 처리하고, 필요한 코드의 중복을 줄이며 컴포넌트 간에 상태를 쉽게 공유할 수 있도록 도와줍니다.\n\nAngular를 위한 인기 있는 상태 관리 솔루션으로는 NgRx, Akita, 그리고 Elf가 있습니다. NgRx는 옵저버블을 사용하고 해당 처리를 위한 연산자 세트를 제공하는 Redux를 벤치마킹한 상태 관리 도구입니다. 더 가파른 학습 곡선과 상당한 양의 보일러플레이트 코드가 있지만 더 강력하다고 여겨집니다. Netanel Basal의 Akita는 일반적으로 NgRx보다 간단하다고 여겨지며 효과적인 메모리 관리 덕분에 성능이 우수합니다. Elf는 Netanel Basal이 저자인 더 신선하고 더 미니멀한 상태 관리 도구로, 다음 버전은 RxJS Subject를 사용할 것이라고 농담하기도 합니다.\n\n이러한 도구들은 장점을 갖고 있지만 응용 프로그램에 추가 복잡성을 도입합니다. 상태 관리 도구를 통합하기 전에 응용 프로그램이 실제로 상태 관리 도구가 필요한지를 평가하는 것이 중요합니다. 작고 비교적 간단한 상태 관리가 필요한 작은 응용 프로그램의 경우 Redux와 유사한 도구를 사용하는 것이 지나칠 수 있고 코드베이스에 불필요한 복잡성을 추가할 수 있습니다. 그러나 응용 프로그램이 성장하고 상태 관리 요구사항이 복잡해진다면 상태 관리 도구를 사용하여 코드를 더 잘 구성하고 유지보수하기 쉽게 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 백엔드 API 사용하기\n\n요즘 프론트엔드 커뮤니티에서 큰 이슈 중 하나는 서버 상태와 클라이언트 상태를 구분하는 것입니다.\n\n옛날에는 클라이언트가 양식 데이터를 받아서 서버로 전송하고 사용자에게 응답을 알려주는 것에만 신경을 쓰곤 했습니다. 그러나 지난 10년간 클라이언트 측은 응용 프로그램의 상태와 비즈니스 로직을 처리하는 데 점점 더 많은 책임을 맡게 되었습니다. 이제 그릇의 진자가 다시 흔들리고 있으며, 점점 더 많은 개발자들이 상태의 어느 부분이 어디에 속하는지에 대해 더 신중해지려고 합니다.\n\n서버 상태는 서버에 저장된 데이터를 가리키며, 클라이언트가 필요할 때 서버에서 요청하는 데이터를 말합니다. 서버 상태가 자주 변경되는 애플리케이션에서는 클라이언트 측에 데이터를 캐싱하는 것이 현실적이지 않을 수 있으며, 일정 주기로 서버에서 데이터를 다시 가져와야 할 필요가 있을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n고객 상태는 다른 쪽으로, 즉 클라이언트 측에 저장되고 응용 프로그램에 의해 관리되는 데이터입니다. 이 데이터는 자주 변경될 수 있으며 일반적으로 사용자 세션에 특화됩니다. 고객 상태의 예시로는 사용자 선호도, 쇼핑 카트 데이터 및 사용자에게 고유한 데이터 등이 있습니다.\n\n일부 경우에는 서버에 데이터를 저장하고 필요에 따라 다른 컴포넌트에서 다시 가져오는 것이 더 효율적일 수 있습니다. 이렇게 함으로써 초기 요청에서로드해야 하는 데이터 양을 줄이고 애플리케이션의 전반적인 성능을 향상시킬 수 있습니다.\n\n다른 경우에는 데이터를 클라이언트 측에 저장하고 상태 관리 도구나 다른 클라이언트 측 저장 메커니즘을 사용하여 관리하는 것이 더 적합할 수 있습니다. 이렇게 함으로써 만들어야 하는 API 요청 수를 줄이고 응용 프로그램을 반응적으로 만들어 사용자 경험을 향상시킬 수 있습니다.\n\n일반적으로, 데이터를 저장하고 검색하기 위해 백엔드 API를 사용하는 시기 및 방법은 응용 프로그램의 특정 요구 사항 및 작업 중인 데이터 유형에 따라 다릅니다.\n\n<div class=\"content-ad\"></div>\n\n# QueryParams\n\n그런데 Angular로 다시 돌아와서, 네비게이션에 관한 몇 가지 주제에 대해 이야기해 봅시다.\n\n데이터를 전달하기 위해 QueryParams를 사용하면 사용자가 링크를 공유함으로써 페이지 상태를 재현하는 강력한 방법이 됩니다. 이는 Angular에 특화된 기능은 아니지만 해당 프레임워크에서 이를 처리하는 도구가 함께 제공됩니다.\n\n쿼리 매개변수는 URL의 끝에 추가되며 경로 다음에 물음표(?)로 시작합니다. 각 매개변수는 키-값 쌍으로 구성되어 있고, 키와 값은 등호(=)로 구분됩니다. 하나의 URL에 여러 쿼리 매개변수를 포함시킬 수 있습니다. 이들은 앰퍼샌드(&)로 구분됩니다. QueryParams에 익숙하지 않다면, 이 섹션의 끝에 있는 예제 URL을 확인하여 구문을 이해하는 데 도움이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 사용자들이 서로 링크를 공유하길 원할 수 있다는 것을 알고 있다면 QueryParams를 사용하는 것이 UX에 좋습니다. 동료와 링크를 공유하고 그 링크를 클릭했을 때 정확히 같은 페이지를 보는 느낌은 정말 좋습니다.\n\n단점은 링크를 너무 길고 마음에 들지 않게 만들 수 있으며, 특히 일부 긴 ID가 포함된 경우 사용자와 제품 소유자 양쪽에게 혼란스러울 수 있습니다. 개발자로서 \"링크가 지나치게 길어도 상관없지 않냐, 중요한 것은 그게 그 일을 잘하는 것이지\"라고 생각하기 쉽지만, 링크를 더 짧게 만들라는 관리자의 지시를 받을 수도 있으니 놀랍지 마세요 (진짜 이야기).\n\nQueryParams를 사용하면 문자열이나 숫자와 같은 간단한 데이터 유형뿐만 아니라 더 복잡한 객체도 저장할 수 있습니다. 사용자가 QueryParams를 포함하는 URL로 이동하면 Angular가 QueryParams을 자동으로 구문 분석하고 ActivatedRoute 서비스를 통해 해당 컴포넌트에서 사용할 수 있게 합니다.\n\n## 예시:\n\n<div class=\"content-ad\"></div>\n\n위치 정의\n\n```js\n{ path: 'product',\n  component: ProductDetailComponent,\n  queryParams: {\n    showReviews: 'true',\n    \n  }\n}\n```\n\nQueryParams에 액세스하기\n\n```js\n constructor(private route: ActivatedRoute) {}\n\n  ngOnInit(): void {\n    console.log(this.route.snapshot.queryParamMap.get('showReviews'))\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n결과 URL\n\n```js\nhttps://www.example.com/?showReviews=true&greeting=Hello%20component\n```\n\n(공백이 인코딩된 표현으로 대체되었음을 확인하세요.)\n\n# Route Params\n\n<div class=\"content-ad\"></div>\n\nQueryParams과 유사하게, Route Params는 URL을 통해 데이터를 구성하는 또 다른 방법을 제공합니다. 두 가지 방법의 차이는 QueryParams는 선택적 매개변수를 전달하는 데 사용되는 반면, Route Params는 필수입니다.\n\nRoute Params를 사용하면 URL이 더 표현적이 되고 탐색이 더 직관적해질 수 있습니다. 이는 디스크 디렉토리를 연상시키는 명확한 계층구조를 구축하기 때문입니다.\n\n## 예시:\n\n경로 정의\n\n<div class=\"content-ad\"></div>\n\n```js\n{ path: '제품/:id', component: ProductDetailComponent }\n```\n\n라우트 파라미터에 접근\n\n```js\nconstructor(private route: ActivatedRoute) {}\n\nngOnInit() {\n  this.route.params.subscribe(params => {\n      console.log(params.id);\n    });\n}\n```\n\n결과 URL\n\n<div class=\"content-ad\"></div>\n\nhttps://www.example.com/product/1234\n\n# 내비게이션 시 데이터 전달\n\nRouter.navigate()는 state라는 옵션 매개변수를 사용하여 데이터를 전달할 수 있습니다. 전달한 데이터는 내비게이션한 경로에서 사용할 수 있습니다. 이 기능은 쿼리 매개변수로 데이터를 전달할 수 없는 경우에 유용합니다.\n\n다만, 이 데이터는 영속적이지 않으며 내비게이션이 이루어진 후에만 사용 가능하며, 페이지 새로고침을 하거나 다른 방법으로 페이지로 이동하는 경우에는 유실될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n상태 전달\n\n```js\nthis.router.navigate(['/destination-route'], { state: { exampleData: 'Hello component.' } });\n```\n\n상태 수신\n\n<div class=\"content-ad\"></div>\n\n```js\nlet state = this.router.getCurrentNavigation().extras.state;\n\nif (state) {\n    console.log(state.exampleData);\n}\n```\n\n# 로컬 스토리지와 세션 스토리지\n\n로컬 스토리지와 세션 스토리지는 내장된 브라우저 API로, 브라우저에 키-값 쌍을 저장할 수 있게 해줍니다. 두 가지의 차이점은 로컬 스토리지가 브라우저에 데이터를 영구적으로 저장하고, 브라우저를 닫았다가 다시 열어도 유지된다는 것이며, 세션 스토리지는 세션만큼만 데이터를 보관하며 사용자가 탭이나 창을 닫을 때 데이터가 손실된다는 것입니다.\n\nAngular 애플리케이션에서 상태를 저장하는 데 로컬 스토리지나 세션 스토리지를 사용하는 것은 페이지를 다시로드할 때나 사용자가 나중에 애플리케이션으로 돌아올 때 데이터를 계속 유지하고 싶을 때 유용합니다. 그러나 로컬 스토리지나 세션 스토리지에 너무 많은 데이터를 저장하면 애플리케이션의 성능이 저하되고 극단적인 경우 애플리케이션이 다운될 수 있음을 주의해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n다른 고려 사항은 보안입니다. 로컬 저장소와 세션 저장소는 안전하지 않으며, 그 안에 저장된 모든 데이터는 동일 출처에서 실행 중인 모든 스크립트에 의해 액세스할 수 있습니다. 따라서 민감한 데이터를 로컬 저장소나 세션 저장소에 저장하지 않는 것이 중요합니다.\n\n# 쿠키\n\n유명한 쿠키는 웹사이트에서 보내어 사용자 컴퓨터에 저장되는 작은 데이터 조각입니다. 일반적으로 사용자의 기본 정보, 로그인 자격 증명 및 브라우징 기록을 저장하는 데 사용됩니다.\n\nAngular에서 구성 요소 간에 데이터를 전달하는 맥락에서, 쿠키를 사용하여 서로 다른 세션이나 페이지 간에 지속되어야 하는 데이터를 저장할 수 있습니다. 예를 들어, 사용자 기본 설정이나 설정을 쿠키에 저장하고 애플리케이션의 다른 부분에서 이를 검색할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n쿠키에는 몇 가지 제한이 있습니다. 크기가 제한되어 있고, 브라우저에는 일반적으로 웹 사이트에서 저장할 수 있는 쿠키의 수에 제한이 있습니다. 또한 쿠키는 웹 사이트로의 모든 요청과 함께 보내지며, 성능에 영향을 줄 수 있으며 네트워크를 통해 전송해야 하는 데이터 양을 증가시킬 수 있습니다.\n\n특정 국가의 웹 사이트에서 쿠키를 사용하는 경우 법적 책임도 고려해야 합니다. 예를 들어, EU에서는 쿠키 사용 전에 사용자의 동의를 요구해야 하므로 대부분의 웹 사이트에서 방해가 되는 팝업이 표시됩니다.\n\n# 결론\n\n한 컴포넌트에서 다른 컴포넌트로 데이터를 전달하는 것은 종종 응용 프로그램 상태를 관리하는 것과 함께 이루어집니다. 이는 많은 설계 결정이 필요한 복잡한 주제이므로, 본 문서가 여러분에게 옵션에 대한 간략한 개요를 제공해 드렸기를 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n처음에 언급했듯이, Angular에서 컴포넌트 간 데이터를 전달하는 더 많은 방법을 알고 계신다면 댓글을 남기거나 저에게 연락해주시면 함께 이 목록을 더 다채롭게 만들 수 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-PassingDataBetweenComponentsinAngular_0.png"},"coverImage":"/assets/img/2024-06-20-PassingDataBetweenComponentsinAngular_0.png","tag":["Tech"],"readingTime":14},{"title":"Angular v18에서 RedirectCommand를 사용하여 Redirect Guards 및 Resolvers 다루기","description":"","date":"2024-06-20 03:05","slug":"2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand","content":"\n\n웹 개발의 현대 시대에서는 동적이고 인터랙티브한 애플리케이션을 만드는 것이 일반적입니다. 특정 사용자에게 독점적이거나 특정 조건에서 사용 가능한 기능을 구현하는 것은 매우 복잡한 도전일 수 있습니다.\n\n그래서 Angular는 Routes, rules, 그리고 components에 기반한 라우팅 시스템을 제공하여 쉽게 애플리케이션을 디자인할 수 있게 합니다.\n\n이 글에서는 Angular v18에서 소개된 새로운 기능을 사용하여 사용자를 다른 곳으로 리디렉션하는 Routes를 보호하는 방법에 대해 논의할 것입니다.\n\n그러나 진행하기 전에 Angular 라우터에 대해 간단히 리뷰해보겠습니다...\n\n<div class=\"content-ad\"></div>\n\n# Angular 라우터 가드 및 리졸버\n\nAngular 라우터 라이브러리를 사용하면 Angular 애플리케이션 내에서 네비게이션을 관리할 수 있으며 Routes 목록을 정의할 수 있습니다.\n\n각 Route는 접근 경로, 로드할 Angular 컴포넌트, 하위 Routes 등과 같은 일련의 정보로 정의됩니다.\n\n```js\nimport { Route } from '@angular/router';\nimport { MyFeatureComponent, MyFeatureGuard } from './my-feature';\n\nconst routes: Route[] = [\n  {\n    path: 'my-feature',\n    component: MyFeatureComponent,\n    canActivate: [MyFeatureGuard],\n    data: {\n      id: \"my-feature-id\"\n    }\n  }\n];\n```\n\n<div class=\"content-ad\"></div>\n\n하나 이상의 루트를 보호하여 특정 조건에 따라 접근 또는 빠져나갈 수 있습니다. 이는 가드라고 불리는 함수를 사용합니다.\n\n```js\nimport { Route } from '@angular/router';\nimport { MyService } from './my-feature';\n\nconst myRoute: Route = [\n  path: 'my-feature',\n  canMatch: [() => inject(MyService).canMatch()],\n  canActivate: [() => inject(MyService).canActivate()],\n  canActivateChild: [() => inject(MyService).canActivateChild()],\n  canDeactivate: [() => inject(MyService).canDeactivate()],\n];\n```\n\nAngular 가드에는 다음과 같이 네 가지 유형이 있습니다. 각각의 역할은 다릅니다:\n\n- canMatch: 루트가 로드될 수 있는지 확인하는 데 사용됩니다. 하나의 경로에 대해 여러 루트를 정의하고 특정 조건에 따라 하나만 선택하려면 이 가드를 사용할 수 있습니다.\n- canActivate: 특정 루트를 활성화할 수 있는지 여부를 결정하는 데 사용됩니다. 예를 들어, 특정 사용자만 접근할 수 있는 페이지에 대한 액세스를 제어하는 데 사용할 수 있습니다.\n- canActivateChild: canActivate와 유사하지만, 주 루트의 자식 루트에 대한 액세스도 제어합니다. 다른 자식 루트에서 시작되었더라도 모든 자식 루트로의 네비게이션에 대해 실행됩니다.\n- canDeactivate: 사용자가 특정 루트에서 빠져나갈 수 있는지를 확인하는 데 사용됩니다. 예를 들어 페이지를 떠날 때 확인을 요청하는 데 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n더불어 Route에 데이터를 준비하기 위해 Resolver 함수를 사용할 수 있습니다:\n\n```js\nimport { Route } from '@angular/router';\nimport { MyService } from './my-feature';\n\nconst myRoute: Route = [\n  path: 'my-feature',\n  resolve: {\n    user: () => inject(MyService).getUserInfo(),\n    config: () => inject(MyService).getUserConfig()\n  }\n];\n```\n\nResolver를 사용하는 것은 Route에 액세스하기 전에 데이터의 존재 여부를 보장하고 페이지에서 누락된 데이터를 처리하지 않도록 하는 훌륭한 접근 방식입니다.\n\n<img src=\"/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n기초 사항을 다루었으니 이제 라우트를 보호하기 위해 사용자를 다른 곳으로 리디렉션하는 방법을 살펴보겠습니다.\n\n# 가드(Guards) 및 리졸버(Resolvers) 사용하여 네비게이션을 리디렉트하기\n\nAngular 가드(Guards)를 사용하면 하나 이상의 라우트 접근 또는 종료를 막아 네비게이션을 차단할 수 있습니다.\n\n그러나 더 부드러운 사용자 경험을 보장하기 위해서는 종종 사용자를 다른 라우트로 리디렉트하는 것이 선호됩니다.\n\n<div class=\"content-ad\"></div>\n\n가드 덕분에 매우 쉽게 이것을 달성할 수 있습니다. 현재 내비게이션을 차단하기 전에 새로운 내비게이션을 시작할 수 있습니다. \n\n```js\nimport { inject } from '@angular/core';\nimport { Route, Router } from '@angular/router';\nimport { MyPage } from './pages/my-page';\n\nconst route: Route = {\n  path: 'my-page',\n  component: MyPage,\n  canActivate: [\n    () => {\n      const router = inject(Router);\n\n      router.navigate(['./my-other-page']);\n      return false;\n    },\n  ],\n};\n```\n\nResolver를 사용하여 비슷한 결과를 얻을 수도 있습니다. Resolver를 이용하여 내부에서 새로운 내비게이션을 시작할 수 있습니다.\n\n```js\nimport { Route, Router } from '@angular/router';\nimport { MyService } from './my-feature';\n\nconst myRoute: Route = [\n  path: 'my-feature',\n  resolve: {\n    user: () => {\n      const router = inject(Router);\n\n      router.navigate(['./my-other-page']);\n      return null;\n    }\n  }\n];\n```\n\n<div class=\"content-ad\"></div>\n\n## UrlTree를 사용한 Redirect\n\n또 다른 방법으로, Guards와 Resolvers를 사용하여 새로운 Route를 나타내는 UrlTree를 반환함으로써 네비게이션을 리다이렉트할 수 있습니다:\n\n```js\nimport { inject } from '@angular/core';\nimport { Route, Router, UrlTree } from '@angular/router';\nimport { MyPage } from './pages/my-page';\n\nconst route: Route = {\n  path: 'my-page',\n  component: MyPage,\n  canActivate: [\n    () => {\n      const router: Router = inject(Router);\n\n      const urlTree: UrlTree = router.parseUrl('./my-other-page');\n      return urlTree;\n    },\n  ],\n};\n```\n\n그러나 이 기술은 이전 기술이 허용하는 NavigationExtras를 사용하여 네비게이션을 리다이렉트하는 것을 허용하지는 않습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ncanActivate: [\n  () => {\n    const router = inject(Router);\n\n    router.navigate(['./my-other-page'], { skipLocationChange: true });\n    return false;\n  }\n]\n```\n\n## Redirect with RedirectCommand\n\n해결책으로 Angular v18에서는 NavigationExtras를 처리할 수 있는 새로운 RedirectCommand 클래스를 소개했습니다. 이를 통해 Guards 및 Resolvers에서 네비게이션을 리다이렉트할 수 있습니다:\n\n```js\nimport { inject } from '@angular/core';\nimport { RedirectCommand, Route, Router, UrlTree } from '@angular/router';\nimport { MyPage } from './pages/my-page';\n\nconst route: Route = {\n  path: 'my-page',\n  component: MyPage,\n  canActivate: [\n    () => {\n      const router: Router = inject(Router);\n      const urlTree: UrlTree = router.parseUrl('./my-other-page');\n\n      return new RedirectCommand(urlTree, { skipLocationChange: true });\n    },\n  ],\n};\n```\n\n<div class=\"content-ad\"></div>\n\n이 새로운 RedirectCommand 클래스의 도입은 가드 및 리졸버의 유지 보수성을 크게 향상시킵니다.\n\n![RedirectingGuardsandResolversinAngularv18withRedirectCommand_1](/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_1.png)\n\n특히 이러한 사용 사례에 특별히 설계된 이 클래스는 앞으로 필요한 새로운 매개변수에 쉽게 대응할 수 있습니다.\n\n# 지금까지 읽어 주셔서 감사합니다 🙏\n\n<div class=\"content-ad\"></div>\n\n피드백을 주실 수 있다면 댓글을 남겨주세요. 👏\n\n그리고 정말 좋았다면 꼭 여러분의 커뮤니티, 기술 관련 그룹, 원하시는 분들과 공유해주세요. 그리고 LinkedIn 팔로우도 잊지마세요. 👋😁","ogImage":{"url":"/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_0.png"},"coverImage":"/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_0.png","tag":["Tech"],"readingTime":6},{"title":"앵귤러 애플리케이션을 로드할 때 안전한 HTTPS 연결을 강제하는 방법 혹은 애플리케이션에서 리소스를 로드할 때 HTTPS 연결을 적용하는 방법","description":"","date":"2024-06-20 03:03","slug":"2024-06-20-AngularWaystoenforceasecurehttpsconnectionwhenloadingapplicationOrresourcesinaapplication","content":"\n\n응용 프로그램을로드하는 경우뿐만 아니라 응용 프로그램 서버에서 리소스를 요청할 때도 안전한 https 연결을 강제로 설정해야 할 수 있습니다. 이 스토리에서는 이러한 목표를 모두 달성하는 방법을 확인해보겠습니다.\n\nI. 응용 프로그램을로드 할 때 https로 리디렉션\n\nAngular 앱이 443 포트의 innocent.csrfexample.com에서 실행 중이라고 가정해 보겠습니다. OpenSSL을 사용하여 암호없이 SSL 인증서를 이미 생성했습니다.\n\n브라우저에서 https://innocent.csrfexample.com을 입력하면 아래와 같이 응용 프로그램이 로드됩니다.\n\n<div class=\"content-ad\"></div>\n\n만약 http://innocent.csrfexample.com을 입력하면 HTTP에서 HTTPS로 리다이렉션을 달성하기 위해 브라우저에게 해당 사이트를 HTTP로 로드하지 말고 모두 HTTPS로 요청하도록 지시하는 HTTP Strict Transport Security(HSTS) 헤더를 사용할 수 있습니다.\n\n더 나아가기 전에 브라우저 리다이렉션에 대해 몇 가지 포인트를 이해해 봅시다.\n\n- 서버는 요청에 특별한 리다이렉트 응답을 보내어 리다이렉션을 트리거합니다.\n- 리다이렉트 응답에는 3으로 시작하는 상태 코드가 있으며, 리다이렉트할 URL을 포함하는 Location 헤더가 있습니다.\n- 브라우저가 리다이렉트를 받으면 즉시 Location 헤더에 제공된 새 URL을 로드합니다.\n- 리다이렉션에는 영구적, 일시적 및 특별한 유형이 있습니다.\n\nHTTP Strict Transport Security 헤더는 어떻게 작동하나요?\n\n<div class=\"content-ad\"></div>\n\n아래는 이 헤더를 사용하는 예시입니다.\n\n```js\n“Strict-Transport-Security”: “max-age=63072000; includeSubDomains; preload”\n```\n\nmax-age는 브라우저가 해당 사이트에만 HTTPS를 사용하여 액세스해야 한다는 것을 기억하는 시간(초)입니다.\n\nincludeSubDomains는 선택적인 매개변수로, 지정된 경우 이 규칙이 사이트의 모든 하위 도메인에도 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\npreload 매개변수는 Google Chrome에 하드코딩된 브라우저 사전로드 목록에 도메인을 추가하며, Chrome 목록을 기반으로 하는 다른 브라우저에도 적용됩니다. 또한 도메인을 hstspreload.org에서도 선언해야 합니다.\n\n- URL innocent.csrfexample.com 또는 http://innocent.csrfexample.com에 접속하면, 브라우저는 HTTP 프로토콜을 사용하려고 한다고 가정하여 innocent.csrfexample.com으로 HTTP 요청을 보냅니다.\n- 이 시점에서 웹 서버는 리디렉트(301 상태 코드)로 HTTPS 사이트로 응답합니다. 브라우저는 innocent.csrfexample.com으로 HTTPS 연결을 만듭니다.\n- 사이트가 처음으로 HTTPS를 사용하여 액세스되고 Strict-Transport-Security 헤더를 반환하는 경우, 브라우저는 이 정보를 기록하여 나중에 해당 사이트를 HTTP로 로드하려는 시도가 자동으로 HTTPS를 사용하도록 지원합니다.\n- Strict-Transport-Security 헤더는 브라우저에 아래 지침을 제공합니다.\n\n```plaintext\n- 이 헤더를 수신한 순간부터 다음 63072000초(최대 연령 매개변수로 지정) 동안 사이트와 해당 하위 도메인에 대한 모든 연결은 반드시 HTTPS로 이루어져야 합니다(includeSubDomains 매개변수가 포함된 경우).\n- 모든 HTTP 연결을 허용하지 않습니다.\n\n- 브라우저가 HTTP를 사용하여 리소스를로드하는 요청을 받으면, 대신 HTTPS 요청을 시도해야 합니다. HTTPS를 사용할 수 없는 경우 연결을 종료해야 합니다.\n```\n\n<div class=\"content-ad\"></div>\n\n4. 웹 사이트에 처음 액세스할 때 HSTS로 보호받지 못하는 불편함이 있습니다. 사용자가 HSTS를 활용하려면 브라우저가 HSTS 헤더를 최소 한 번 볼 수 있어야 합니다. 이는 첫 번째 안전한 연결 이후 가능합니다. 이 문제를 해결하려면 웹 사이트를 HSTS 사전 로딩 목록에 추가해야 합니다(https://hstspreload.org/). 이렇게 하면 브라우저가 먼저 내부 목록을 확인하고 첫 연결 시도 중에도 웹 사이트에 HTTP를 통해 접근하지 않습니다.\n\n5. HSTS의 max-age 매개변수는 브라우저가 Strict-Transport-Security 헤더를 읽을 때마다 갱신됩니다. 이는 max-age 매개변수로 지정된 시간 내에 방문 사이에 간격이 넘지 않는 한 보호가 영구적임을 의미합니다. max-age 매개변수로 지정된 시간 동안 웹 사이트를 방문하지 않으면 새로운 사이트로 취급됩니다.\n\n동시에 max-age를 0으로 설정하여 Strict-Transport-Security 헤더를 제공하면, 브라우저는 다음 연결 시도에서 사이트를 새로운 것으로 처리합니다. max-age 매개변수를 0으로 설정하면 사이트의 HSTS가 비활성화됩니다.\n\n아래는 HSTS의 다이어그램 표현입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-AngularWaystoenforceasecurehttpsconnectionwhenloadingapplicationOrresourcesinaapplication_0.png)\n\n이제 로컬 개발 서버와 nginx 웹 서버에서 이 헤더를 사용하는 방법을 살펴보겠습니다.\n\n로컬 개발 서버 사용하기\n\npackage.json 파일의 \"start\" 스크립트는 다음과 같이 보입니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n\"serve\": {\n  \"builder\": \"@angular-devkit/build-angular:dev-server\",\n  \"options\": {\n    \"sslKey\": \"./self-signed-with-no-passphrase/secureAngularExample.key\",\n    \"sslCert\": \"./self-signed-with-no-passphrase/secureAngularExample.crt\",\n    \"ssl\": true\n  },\n  \"configurations\": {\n    \"production\": {\n      \"browserTarget\": \"csrfInAngular:build:production\"\n    },\n    \"development\": {\n      \"browserTarget\": \"csrfInAngular:build:development\",\n      \"headers\": {\n        \"Strict-Transport-Security\": \"max-age=63072000; includeSubDomains; preload\"\n      }\n    }\n  },\n  \"defaultConfiguration\": \"development\"\n}\n```\n\nStrict-Transport-Security response header가 \"headers\" 객체에 속성으로 추가되었습니다.\n\n<div class=\"content-ad\"></div>\n\n```json\n\"headers\": {\n\"Strict-Transport-Security\": \"max-age=63072000; includeSubDomains; preload\"\n}\n```\n\n다른 웹 서버 사용하기\n\n이 이야기에서는 nginx 웹 서버를 사용 중이지만 이 개념은 모든 웹 서버에 적용됩니다.\n\n다음은 nginx.config입니다. Nginx는 포트 80과 443에서 연결을 받고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n서버 블록을 2개 추가했어요. 두 블록 모두 server_name이 innocent.csrfexample.com으로 동일하지만 다른 포트인 443과 80에서 수신하고 있어요.\n\nNginx가 80포트에서 요청을 받으면, 같은 사이트를 https 프로토콜을 사용하여 301 상태 코드로 리디렉션 하고 있어요.\n\n```js\nserver{\nlisten 0.0.0.0:80;\nserver_name innocent.csrfexample.com;\nreturn 301 https://$host$request_uri;\n}\n```\n\n443포트에서 수신하는 서버 블록 안에, add_header 지시문을 사용하여 Strict-Transport-Security 응답 헤더를 설정했어요. 이를 통해 브라우저가 응용 프로그램을 http에서 https 프로토콜로 리디렉션할 때, Strict-Transport-Security 응답 헤더가 브라우저로 보내지도록 설정되어요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nadd_header ‘Strict-Transport-Security’ ‘max-age=63072000; includeSubDomains; preload’;\n``` \n\nAngular 앱을 Nginx에 배포하기 위해 애플리케이션을 컨테이너화했습니다.\n\n다음은 docker-compose.yml입니다.\n\n다음은 Dockerfile입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\"Docker compose build\"과 \"docker compose up\"을 실행합니다.\n\n- 브라우저에서 처음으로 http://innocent.csrfexample.com에 접속하면, 브라우저는 301 Moved Permanently 응답을 사용하여 사이트를 안전한 https:// 스키마로 리디렉션합니다.\n\nLocation 응답 헤더는 브라우저가 새 URL을로드해야 함을 나타냅니다.\n\n아래 스크린샷에서 \"Strict-Transport-Security\" 응답 헤더를 확인하세요. 요청 URL에서 명확히 알 수 있듯이, https로 리디렉트된 후에 응답 헤더가 전송됩니다. 브라우저는이 사이트의 만료 시간을 63072000초 또는 2년으로 기록할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n2. 브라우저에서 http://innocent.csrfexample.com에 두 번째로 접속하면, 브라우저가 307 임시 리디렉트 응답을 사용하여 사이트를 안전한 https://로 리디렉션합니다. 이번에는 HSTS(Http Strict Transport Security) 덕분에 https로 리디렉션이 이루어졌습니다. 아래 스크린샷에서 확인할 수 있듯이, HSTS는 브라우저 자체에서 HTTPS로 재작성이 이루어지므로 301 상태 코드 응답과 같은 nginx 웹 서버에 의한 HTTPS로의 리디렉트가 없어졌습니다.\n\nHSTS는 응용 프로그램이 브라우저에서 max-age 매개변수가 만료될 때까지 오직 HTTPS 연결로만 로드되도록 보장합니다.\n\n3. 이제 nginx.config 파일에서 max-age 매개변수를 0으로 설정해보겠습니다. 이는 HSTS를 비활성화하는 것을 의미합니다.\n\n```js\nadd_header ‘Strict-Transport-Security’ ‘max-age=0; includeSubDomains; preload’ always;\n```\n\n<div class=\"content-ad\"></div>\n\n현재 브라우저에서 http://innocent.csrfexample.com을 입력하면 이전에 2년 동안이었던 이 사이트의 max-age 매개변수가 아직 만료되지 않아 HSTS로 다시 https로 리디렉션됩니다.\n\n아래 스크린샷에서 응답 헤더를 확인해 보세요. 여기에서 max-age 매개변수는 0입니다. 브라우저는 이 사이트의 만료 시간을 지금부터 0초로 업데이트할 것입니다.\n\n다음에 브라우저에서 다시 http://innocent.csrfexample.com에 접속할 때, 최신 업데이트에 따라 max-age 매개변수가 0초이므로 HSTS가 리디렉션을 수행하지 않도록 http에서 https로 영구적으로 이동(response code 301)합니다.\n\n이러한 과정은 향후 이 사이트를 로드하려는 시도에서도 계속될 것이며, max-age 매개변수가 0보다 큰 값으로 업데이트되어 HSTS를 활성화할 때까지 지속됩니다.\n\n<div class=\"content-ad\"></div>\n\n4. max-age를 63072000으로 다시 업데이트했다고 치면,\n\n```js\nadd_header ‘Strict-Transport-Security’ ‘max-age=63072000; includeSubDomains; preload’ always;\n```\n\n= 이제 다시 http://innocent.csrfexample.com에 접속했을 때 301 응답 코드로 인해 https로 리디렉션됩니다. 하지만 https로 리디렉션된 후의 응답 헤더를 아래 2번째 스크린샷에서 살펴봐주세요. Strict-Transport-Security 헤더의 max-age 매개변수가 업데이트되었습니다. 브라우저는 이 사이트에 대한 업데이트된 만료 시각을 이제 63072000으로 기록할 것입니다.\n\n= http://innocent.csrfexample.com에 다시 접속했을 때, 이번에는 HSTS를 통해 307 응답 코드로 인해 리디렉션이 발생합니다.\n\n<div class=\"content-ad\"></div>\n\n제가 이해하기 쉽게 HSTS가 어떻게 작동하는지 예시를 통해 설명 드렸으면 좋겠습니다.\n\nII. 애플리케이션 내에서 보안되지 않은 리소스를 로드할 때 https로 리다이렉팅\n\n저는 안전한 https 연결을 통해 실행 중인 Angular 앱이 있습니다. 즉, 웹 서버와의 연결이 TLS/SSL로 암호화되어 있어 대부분의 스니퍼와 중간자 공격으로부터 안전합니다.\n\n이 애플리케이션에 cleartext HTTP를 사용하여 가져온 콘텐츠가 있다면, 이는 혼합 콘텐츠 애플리케이션입니다. 이는 애플리케이션이 부분적으로만 암호화되어 있음을 의미하며, 암호화되지 않은 콘텐츠가 스니퍼와 중간자 공격자에게 노출된 채로 남아 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n이 문제와 그 해결책을 설명하기 위해, HTTP 연결을 포트 80에서, HTTPS 연결을 포트 443에서 수신하는 노드 익스프레스 서버를 생성했습니다.\n\n또한, 노드 익스프레스 프로젝트에서 아래와 같은 루트를 생성하여 고양이 이미지를 가져오도록 했습니다.\n\n```js\nrouter.get('/getImage', function(req, res, next) {\n  res.sendFile(path.join(__dirname, '../public', 'images', 'cat.jpg'));\n});\n```\n\n<div class=\"content-ad\"></div>\n\n포트 충돌을 피하기 위해 nginx 웹 서버가 안전한 https 연결을 수신하는 포트 5443에서 작동하도록 설정되었습니다. 또한 포트 80에서 연결을 수신하는 서버 블록을 주석 처리하여 Node express 서버와의 충돌을 피했습니다.\n\ndocker-compose.yml 파일을 업데이트했습니다.\n\nnginx.config 파일도 업데이트되었습니다.\n\n따라서 이제 https://innocent.csrfexample.com:5443을 통해 앵귤러 애플리케이션에 액세스할 수 있습니다. HSTS가 활성화되어 있기 때문에 http://innocent.csrfexample.com:5443으로의 모든 요청은 https://innocent.csrfexample.com:5443으로 리디렉션됩니다.\n\n<div class=\"content-ad\"></div>\n\n어느 Angular 구성 요소에서, Node 서버에서 이미지를 가져 오기 위해 아래 `img` 태그를 사용하는 경우를 가정해 봅시다. 이미지는 http를 통해 가져 오려고 합니다.\n\n```js\n<img src=\"http://csrfexample.com/getImage\">\n```\n\n브라우저에서 `http://innocent.csrfexample.com:5443`에 액세스하면, HSTS가 307 응답 코드를 사용하여 `https://innocent.csrfexample.com:5443`로 리디렉션됩니다.\n\n안전하지 않은 요청 `http://csrfexample.com/getImage`가 아래 스크린 샷에서 보이는 것처럼 `https://csrfexample.com/getImage`로 업그레이드되었습니다. 코드 변경 없이 어떻게 이렇게 된 것일까요?\n\n<div class=\"content-ad\"></div>\n\n이미지가 로드된 것을 확인할 수 있지만 콘솔에 Mixed Content 경고 메시지가 표시됩니다. Chrome은 http 요청을 자동으로 https로 업그레이드했습니다. Chrome 79부터는 안전한 연결에서 실행 중인 애플리케이션의 페이지의 모든 리소스에 대한 요청을 http에서 https로 자동으로 업그레이드합니다. Chrome에 대한 자세한 내용은 https://blog.chromium.org/2019/10/no-more-mixed-messages-about-https.html 확인하세요.\n\n만약 오래된 버전의 Chrome이나 http에서 https로 요청을 자동으로 업그레이드하지 않는 브라우저를 사용 중이라면 어떨까요? 사용자가 어떤 브라우저를 사용하여 애플리케이션을 로드할지는 실제로 제어할 수 없습니다.\n\n이 문제를 해결하기 위해 Content-Security-Policy 헤더를 upgrade-insecure-requests 지시문과 함께 사용할 수 있습니다.\n\n로컬 웹 개발 서버의 경우, angular.json 파일의 \"serve\" 섹션을 아래와 같이 업데이트하세요.\n\n<div class=\"content-ad\"></div>\n\n```json\n{\n  \"serve\": {\n    \"builder\": \"@angular-devkit/build-angular:dev-server\",\n    \"options\": {\n      \"sslKey\": \"./self-signed-with-no-passphrase/secureAngularExample.key\",\n      \"sslCert\": \"./self-signed-with-no-passphrase/secureAngularExample.crt\",\n      \"ssl\": true\n    },\n    \"configurations\": {\n      \"production\": {\n        \"browserTarget\": \"csrfInAngular:build:production\"\n      },\n      \"development\": {\n        \"browserTarget\": \"csrfInAngular:build:development\",\n        \"headers\": {\n          \"Strict-Transport-Security\": \"max-age=63072000; includeSubDomains; preload\",\n          \"Content-Security-Policy\": \"upgrade-insecure-requests\"\n        }\n      }\n    },\n    \"defaultConfiguration\": \"development\"\n  }\n}\n```\n\nNginx 웹서버의 경우, 아래와 같이 nginx.config 파일을 업데이트할 수 있습니다.\n\n이제 브라우저에서 http://innocent.csrfexample.com:5443을 입력하면 HSTS가 307 응답 코드를 사용해 https://innocent.csrfexample.com:5443로 리디렉션되며 이미지는 https를 사용하여 요청되어 \"혼합 콘텐츠\" 경고 없이 보여집니다.\n\n아래 두 번째 스크린샷에서 응답 헤더를 확인해보세요. \"Content-Security-Policy\" 헤더에는 \"upgrade-insecure-requests\" 지시문이 포함되어 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 스택더믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Differ\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요.","ogImage":{"url":"/assets/img/2024-06-20-AngularWaystoenforceasecurehttpsconnectionwhenloadingapplicationOrresourcesinaapplication_0.png"},"coverImage":"/assets/img/2024-06-20-AngularWaystoenforceasecurehttpsconnectionwhenloadingapplicationOrresourcesinaapplication_0.png","tag":["Tech"],"readingTime":11}],"page":"38","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}