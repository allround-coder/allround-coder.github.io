{"pageProps":{"posts":[{"title":"iOS에서의 Flyweight 디자인 패턴","description":"","date":"2024-05-15 15:39","slug":"2024-05-15-FlyweightDesignPatterniniOS","content":"\n\n<img src=\"/assets/img/2024-05-15-FlyweightDesignPatterniniOS_0.png\" />\n\nFlyweight는 여러 객체의 메모리 사용량을 줄일 수 있는 구조적 디자인 패턴입니다. 이 패턴은 몇 가지 속성 또는 상태를 완벽히 외부로 공유하는 객체들의 메모리 사용을 줄일 수 있게 해줍니다.\n\n# 구현\n\n우선, 먼저 다음 두 가지 개념, 내재 상태와 외재 상태를 이해하는 것이 필요합니다.\n\n\n\n## 내재 상태\n\n내재 상태란 물체의 속성 중에서 불변인 것들을 말합니다. 즉, 이들은 시간이 지나도 변하지 않는 속성들로 운전 면허증 사용자의 출생 날짜나 국적 등이 이에 해당합니다.\n\n## 외재 상태\n\n반면, 외재 상태는 모두 가변 속성을 의미합니다. 즉, 언젠가는 변할 속성들로 여권의 만료 날짜나 발급 장소 등이 이에 해당합니다.\n\n\n\n이 패턴을 구현하려면 객체의 본질적 상태와 외부적 상태를 구분하기 위해 식별해야 합니다.\n\n예를 들어 기관이나 정부 의존성은 운전 면허증 정보를 모두 기록할 수 있고 다른 종속성은 모든 여권 정보를 가질 수 있습니다.\n\n```js\nimport Foundation\n\nenum State: String { ... }\nenum Nationality: String { ... }\nenum BloodType: String { ... }\n\nstruct Address: Identifiable {\n  let mainStreet: String\n  let number: String\n  let zipCode: String\n  // ...\n}\n\nclass DriverLincense {\n  let nationalID: UUID\n  let name: String\n  let surname: String\n  let birthDate: Date\n  let nationality: Nationality\n  let bloodType: BloodType\n  var state: State\n  var expedition: Date\n  var expiration: Date\n  var address: Address\n  // ...\n}\n\n//... 다른 종속성\n\nenum StateCode: String { ... }\n\nclass PassportInfo {\n  let passportID: UUID\n  let nationalID: UUID\n  let name: String\n  let surname: String\n  let birthDate: Date\n  let birthPlace: String\n  let nationality: Nationality\n  let bloodType: BloodType\n  var expedition: Date\n  var expiration: Date\n  var stateCode: StateCode\n}\n```\n\n이 예시에서, 특정 정보가 반복될 수 있고 변경되지 않을 때 추출하여 사용할 수 있음을 알 수 있습니다. 이를 내적(본질적) 상태라고 합니다.\n\n\n\n```js\n// 내재 상태\nclass PersonalInfo {\n  let nationalID: UUID\n  let name: String\n  let surname: String\n  let birthDate: Date\n  let birthPlace: String\n  let nationality: Nationality\n  let bloodType: BloodType\n}\n```\n\n이렇게 함으로써, 실제 유형은 메모리에 두 번 저장하는 대신 단일 내재 상태를 가리킬 수 있습니다.\n\n```js\nclass DriverLincense {\n  let personalInfo: PersonalInfo\n\n  // 외부 상태\n  var state: State\n  var expedition: Date\n  var expiration: Date\n  var address: Address\n}\n\nclass PassportInfo {\n  let personalInfo: PersonalInfo\n\n  // 외부 상태\n  let stateCode: StateCode\n  var expedition: Date\n  var expiration: Date\n}\n```\n\n그리고 이제 이러한 객체들은 동일한 불변 상태를 공유하고 메모리를 절약할 수 있습니다.\n\n\n\n\n```js\n// 공유 정보\nlet myInfo = PersonalInfo( ... )\n\nlet myDriverLicense = DriverLicense(personalInfo: myInfo, ... )\nlet myPassportInfo = PassportInfo(personalInfo: myInfo, ... )\n```\n\n## 장점\n\n이 구조적 패턴은 동시에 로딩하는 데 시간이 많이 걸리거나 여러 인스턴스를 관리할 때 리소스를 절약하는 데 중점을 둡니다.\n\n- 메모리 사용량을 절약합니다. 공통 상태를 공유하므로 메모리 사용량이 줄어듭니다. 해당 상태는 변경되지 않습니다.\n\n\n\n## 일반적인 실수\n\n- 동일한 속성과 값으로 동일한 객체의 여러 내재 상태를 사용하는 것입니다. 이 문제를 회피하려면 싱글톤 또는 플라이웨이트 팩토리를 이용하여 각 객체가 하나씩만 있도록 합니다.\n\n# 결론\n\n이 패턴은 여러 객체가 공통 데이터를 공유하며 개별적으로 처리될 때 정말 유용해집니다. 예를 들어 비디오 게임은 여러 객체를 렌더링하기 위해 일괄적으로 로드해야 하지만, 텍스처는 메모리를 절약하기 위해 한 번만 로드되고, 필요할 때 객체를 표시할 모든 인스턴스에서 공유될 것입니다.","ogImage":{"url":"/assets/img/2024-05-15-FlyweightDesignPatterniniOS_0.png"},"coverImage":"/assets/img/2024-05-15-FlyweightDesignPatterniniOS_0.png","tag":["Tech"],"readingTime":3},{"title":"Google IO 2024에서 착륙한 Flutter 322과 Dart 34","description":"","date":"2024-05-15 15:37","slug":"2024-05-15-LandingFlutter322andDart34atGoogleIO2024","content":"\n\n## 플러터 웹 앱의 주요 이정표, 그래픽 성능 업그레이드, 생산성 실험 등\n\n Dart & Flutter 항공 교통 통제에서 지난 몇 달 동안 특히 바쁘게 보냈습니다. 하지만 우리는 플러터 3.22와 다트 3.4가 착륙하고 오늘 사용 가능하다는 것을 기쁘게 알려드립니다. 올해의 구글 I/O를 맞아 시기적절하게 출시되었습니다!\n\n 우리는 아름답고 풍부하며 빠른 앱을 구축할 수 있도록 하는 강력한 언어와 프레임워크 연결을 제공하기 위해 헌신해 왔습니다. 이렇게 하면 모바일, 웹 및 데스크탑 사용자에게 앱을 제공할 수 있으며 제품 로드맵을 분할할 필요 없이 단일 공유 코드베이스에서 앱을 제공할 수 있습니다.\n\n ![image](https://miro.medium.com/v2/resize:fit:1400/1*Mq-Uj8c8l7rrpPxYQ6Gemw.gif)\n\n\n\n플러터 3.22과 Dart 3.4는 성능 향상과 플랫폼별 세부 조정을 제공하여 우리의 비전을 더 가까이 가져다줍니다. 특히 Wasm과의 여정을 공유하기를 기대하고 있지만, 개선된 Impeller 렌더링 엔진, 더 부드러운 시각적 효과 및 iOS에서의 CPU 사용량 감소가 포함된 다양한 혜택을 찾아보실 수 있습니다. Android의 예측 제스처 백 기능이 추가된 향상된 플랫폼 내비게이션, Google Mobile Ads SDK를 활용한 확장된 수익 옵션, DevTools에서 제공되는 강력한 딥 링크 유효성 검사기도 새롭게 출시되었습니다. Dart 개발자는 IDE에서 직접 제공되는 dart fix로 간소화된 API 이관을 즐기게 되며, 고급 프로파일링을 위한 새로운 DevTools 기능도 제공됩니다. 게다가 이제 Firebase Dart SDK용 Vertex AI를 미리 볼 수도 있어서 AI 기반 기능과 견고한 보안 조치를 통합할 수 있습니다.\n\n오늘은 또한 생산성을 높이고 성능 뛰어난 경험을 구축하는 데 Flutter를 사용하는 선두 기업을 소개할 것입니다. 우리의 목표에 한 발 더 다가가기 위한 특히 흥미로운 특징 중 일부를 강조하고, 생산성, 개발자 경험 및 게임 분야에 대한 투자에 대한 업데이트를 포함할 것입니다.\n\n릴리스에 포함된 모든 내용에 대해 더 많은 세부 정보를 원하신다면, 전용 Flutter 및 Dart 게시물을 확인하십시오. 이제 Dash할 시간입니다!\n\n# Flutter in action\n\n\n\n플러터 개발자들은 애플리케이션 스토어에 대규모의 새로운 앱을 출시하느라 정신이 팔리고 있어요. 몇 가지 살펴보죠.\n\n![image](/assets/img/2024-05-15-LandingFlutter322andDart34atGoogleIO2024_0.png)\n\n## 대규모 기업용 애플리케이션을 모바일과 웹에서 제공하는 데 도움을 주다\n\n- 영국의 금융 기관 Virgin Money는 플러터를 이용하여 모바일 뱅킹 앱과 신용 카드 앱 스위트 전반에 걸쳐 앱 개발 프로세스를 통합하고 변경 속도를 높이며 업계 선도적인 사용자 경험을 가능하게 했어요.\n- 미국의 보험 회사 GEICO는 최근 플러터를 사용하여 iOS, Android, 그리고 웹을 포함한 브랜드 사용자 경험을 개선하고, 코드베이스 크기를 줄이고 개발 효율성을 향상시켰다고 공유했어요. 이 모든 것이 대규모로 일어났답니다.\n- 유니버설 스튜디오 목적지 및 체험은 할리우드, 오사카, 오를랜도 공원을 위해 새로운 플러터 모바일 앱을 출시했어요. 왜 플러터를 선택하게 되었는지 그리고 어떻게 작동하는지 보려면 아래 비디오를 시청해보세요.\n\n\n\n## 모바일 및 웹을 넘어서\n\n- Canonical 팀은 2021년부터 Flutter를 사용하여 Ubuntu에서 Flutter 생태계를 지원하기 위해 노력해왔습니다. 지난 일년 동안 Canonical 팀은 Ubuntu 설치 프로그램을 처음부터 다시 만들어 Flutter로 재구성했습니다.\n- LG는 스마트 TV 운영 체제인 webOS를 향상시키기 위해 Flutter를 선택했습니다. Flutter의 성능, 생산성 및 강력한 생태계는 LG가 원할하게 개발하여 원할하게 실행되는 webOS 시스템 앱을 신속하게 개발하고 배포할 수 있게 합니다. 2025년까지 Flutter가 전 세계 수십만 대의 LG TV에서 시스템 앱을 작동시킬 것입니다.\n\n이러한 성공 스토리에 영감을 받았으며, Flutter를 더 나아지게 만들기 위해 약속합니다. 더욱 놀라운 앱, 게임 및 경험을 빌드할 수 있도록하는 것에 대한 우리의 최신 제품 업데이트를 살펴보겠습니다.\n\n# WebAssembly: 웹에서 네이티브 성능을 추구하기\n\n\n\n오늘은 저희의 안정적인 릴리스에서 Flutter 웹 앱을 WebAssembly (Wasm)로 컴파일하는 지원을 발표합니다. 이는 웹 브라우저를 위한 새로운 흥미로운 명령어 형식으로, 이는 휴대용하고 플랫폼 중립적인 이진 코드 형식을 제공합니다.\n\nWasm에 대한 저희의 지원은 깊게 연구한 멀티 플랫폼 투자입니다. 먼저, 고수준 관리 언어인 Dart와 같이 가비지 컬렉션을 사용하는 언어를 위한 WebAssembly 지원을 Chrome 팀과 파트너로 협력하여 정의했습니다. 이로 인해 WasmGC 제안이 탄생했고, 현재 Chrome (Chromium 119 이상) 및 Firefox (120 이상)에서 런타임 구현이 가능하며, 다른 브라우저 업체들도 이를 따르기를 기대하고 있습니다. 그 다음으로, 우리는 새로운 Dart 컴파일러 백엔드를 추가하여 WasmGC 코드를 생성하고, Dart 및 Flutter 팀이 효율적인 Wasm에서 Wasm으로 상호 운용 가능한 새로운 Dart & Flutter 렌더링 엔진을 실행하도록 협업했습니다.\n\n그 결과는 무엇일까요? 저희는 모바일 및 데스크톱 장치에서 실행되는 네이티브 코드와 유사한 성능 향상을 보고 있습니다. 저희 내부 벤치마킹에서 (M1 MacBook의 Chrome에서) Wonderous의 프레임 렌더링 시간이 전반적으로 2배 향상되었으며, 최악의 경우 성능은 3배 향상되었습니다. 개선된 렌더링 성능은 애니메이션 및 부드러운 전환을 강조하는 요구사항이 있는 앱에서 중요합니다. 다음 프레임을 렌더링하는 데 할당된 시간을 초과하면 매우 뚜렷한 끊김 현상이 발생합니다. Wasm는 이러한 현상을 제거할 잠재력이 있으며, 우리의 전통적인 JS 컴파일과 Wasm 컴파일을 비교한 Wonderous 앱의 아래 그림에서 나타나듯이 그 수치가 확인됩니다.\n\n\n\nFlutter 웹 앱을 위한 Wasm 컴파일이 오늘부터 안정적으로 사용 가능합니다. 시작하려면 Dart Wasm 문서와 Flutter Wasm 문서를 확인해보세요.\n\n# Dart 매크로: 개발 추상화 수준 높이기\n\n우리는 최고 수준의 개발자 경험을 제공하기 위해 전념하고 있습니다. 이는 Dart 개발자들에게 오랫동안 고통스러운 문제를 해결하는 것을 의미합니다, 예를 들어 JSON 데이터를 직렬화하는 것.\n\n이것은 반복적이면서도 지루한 패턴입니다. 현재의 해결책은 JSON 데이터를 인코딩하고 디코딩하는 번거로운 작업을 직접 처리하거나, JsonSerializable 패키지와 같은 코드 생성 솔루션을 활용해서 추가 도구를 사용하는 것 두 가지 방법이 있습니다.\n\n\n\n오늘은 JSON에 대한 더 나은 옵션 미리보기인 JsonCodable 매크로를 발표합니다.\n\n매크로는 더 많은 코드를 생성하는 코드입니다. 매크로 시스템은 다트에 내장되어 있으며 코드를 편집하고 실행하는 동안 실시간으로 발생합니다. 지연 없이 통합된 경험이며 핫 리로드와 같은 기존 개발자 워크플로우를 완전히 지원합니다. 다음 스크린 캐스트에서 보여지는 것처럼요.\n\n![이미지](/assets/img/2024-05-15-LandingFlutter322andDart34atGoogleIO2024_2.png)\n\n매크로가 개발자들을 위한 다양한 문제를 해결하는 것을 기대합니다. 예를 들어 데이터 클래스는 가장 많은 투표를 받은 다트 언어 기능 중 하나입니다. 특정 응용 프로그램 이상, 최종 목표는 사용자가 자신만의 매크로를 생성하고 다트 프로그래밍의 추상화 수준을 높일 수 있는 다트의 매크로 시스템을 갖는 것입니다.\n\n\n\n그렇게 강력한 매크로 시스템을 설계하고 구현하는 것은 큰 작업이므로 안정적인 릴리스 일정은 현재 설정되어 있지 않습니다. 자세한 내용은 Dart 3.4 게시물을 확인해주세요. 한편, JsonCodable 매크로 미리보기를 오늘 시도해보세요. 더 많은 정보는 매크로 문서를 확인해주세요.\n\n# Flutter 게임 개발을 위한 새로운 리소스\n\n![image](/assets/img/2024-05-15-LandingFlutter322andDart34atGoogleIO2024_3.png)\n\n우리는 게임에 대한 초기 투자로부터 유망한 결과를 보고 있습니다. Etermax와 Supercell와 같은 산업 리더들의 성공 사례를 포함하여, 각각이 Flutter의 강력함과 유연성을 활용하여 사용자에게 기쁨을 주는 경험을 효율적으로 전달하고 확장하고 있습니다.\n\n\n\n안녕하세요! 오늘은 플러터 게임 개발자를 위한 새로운 자료를 소개해서 기쁩니다:\n\n- SoLoud 오디오 엔진을 사용할 수 있습니다: 플러터 커뮤니티와 협력하여 저지연, 고성능 사운드를 제공하는 무료 이식 가능한 오디오 엔진을 만들었습니다. 이는 많은 게임에 필수적인 요소입니다. 또한 SoLoud를 사용하는 새로운 사운드 및 뮤직 코딩랩을 만들었습니다.\n- 사용자 경험을 저해하지 않고 교차되는 단어로 확장 가능한 십자말 퍼즐 형태의 그리드를 생성하는 방법을 배우고, Box2D와 유사한 2D 물리 시뮬레이션인 Forge2D를 사용하여 플러터와 플레임 게임의 게임 메카닉을 만드는 방법을 익힐 수 있습니다.\n- Flutter 웹 기반 게임 로딩 속도 최적화를 위한 새로운 안내서: 웹 기반 게임에서 오랜 로딩 시간은 큰 가로막자가 됩니다. Cheng Lin이 작성한 이 가이드를 따라 로딩 속도를 최적화하여 플레이어가 로딩이 느리다는 이유로 게임을 포기하지 않도록 해보세요.\n\n# 지속 가능한 게임 개발을 돕는 것\n\n2024년 1월, 플러터 사용 사례에서 영감을 받아 우리는 글로벌 시민과 협력하여 플러터를 사용하여 지속 가능성에 관한 게임을 디자인, 개발 및 출시할 것을 도전했습니다. 이러한 게임은 플레이어에게 환경을 위한 소소하지만 의미 있는 행동을 취하도록 영감을 줍니다. 오늘, 10개의 수상작을 발표하고 있습니다.\n\n\n\n축하합니다! \n\n# 더 많은 것을 탐험해 보세요\n\n오늘은 시간이 부족해서 강조해야 할 것만 다루었지만, 다루지 않은 더 많은 흥미로운 개선 사항이 많이 있습니다. 여기 몇 가지 더 알아야 할 사항이 있어요:\n\n- Dart 또는 Flutter 앱에서 AI 기반 기능을 사용하기 위해 Gemini API를 사용하는 Vertex AI for Firebase Dart SDK를 미리 볼 수 있습니다. 이 SDK는 Firebase App Check와 통합되어 API 호출을 보호하고 청구 사기, 피싱, 앱 가장자리 기만과 같은 심각한 위협으로부터 백엔드 인프라를 안전하게 보호합니다. 자세한 내용은 AI 페이지를 참조하세요.\n- 저희의 차세대 렌더링 엔진 인 Impeller이 Android에서 모든 기능을 갖추었습니다.\n- Android의 예측적인 뒤로 가기 제스처가 이제 Flutter 앱 내에서 탐색하거나 다른 앱 또는 홈 화면으로 이동할 때 모두 지원됩니다.\n- iOS의 플랫폼 뷰가 성능 최적화되어 CPU 사용량을 최대 50%까지 줄였습니다.\n- Google Mobile Ads SDK가 더 많은 광고 파트너 및 중재 옵션을 지원하도록 확장되었습니다.\n- DevTools에는 안드로이드 딥 링크 구성의 오류를 식별하고 문제 해결하는 데 도움이 되는 새로운 딥 링크 유효성 검사기가 추가되어 웹 경험을 Flutter 앱에 쉽게 연결할 수 있습니다.\n- API 이전 도구인 Dart fix를 이제 IDE에서 직접 사용할 수 있습니다.\n- DevTools는 지금 타임라인에서 고급 필터링 및 CPU 샘플을 지원합니다.\n\n\n\n플러터 기술 포스트와 Dart 3.4 포스트를 방문하시면 각각에 대한 자세한 내용과 더 많은 정보를 얻을 수 있어요.\n\n항상 여러분의 지속적인 지원, 열정, 열의와 피드백에 대해 감사드립니다. 여러분 없이 이 프로젝트를 진행할 수 없고, 여러분이 플러터를 더 발전시키는 모습을 기대할 수 없어요.\n\n지금은 여기까지! 다시 한번 탑승해주길 바라며, 플러터를 향한 여정을 함께 이어갔으면 좋겠어요!","ogImage":{"url":"/assets/img/2024-05-15-LandingFlutter322andDart34atGoogleIO2024_0.png"},"coverImage":"/assets/img/2024-05-15-LandingFlutter322andDart34atGoogleIO2024_0.png","tag":["Tech"],"readingTime":7},{"title":"파이썬 내장 함수 중 잘 알려지지 않은 5가지","description":"","date":"2024-05-15 15:36","slug":"2024-05-15-5LessKnownBuilt-InPythonFunctions","content":"\n\n\n![python function](/assets/img/2024-05-15-5LessKnownBuilt-InPythonFunctions_0.png)\n\n## 1) callable(x)\n\nThe callable(x) function returns True if x is callable — x must either be a function or some object with the __call__ magic method defined.\n\n```python\ndef hello():\n    pass\n\nhi = 1\n\nprint(callable(hello))   # True\nprint(callable(hi))      # False\n```\n\n\n\n\n^ 호출 가능한지 여부가 불분명한 여러 변수가 주어졌을 때, 함수를 사용하기 전에 실제로 변수를 호출하기 전에 callable 함수를 사용하여 먼저 이를 확인할 수 있습니다.\n\n```js\nclass Dog:\n    def __call__(self, x):\n        pass\n\nclass Cat:\n    pass\n\ndog = Dog()\ncat = Cat()\n\nprint(callable(dog))  # True\nprint(callable(cat))  # False\n```\n\n^ 함수에만 해당되는 것이 아니라 객체도 __call__ 매직 메서드를 사용하여 호출 가능하게 만들 수 있다는 것을 염두해 두세요.\n\n# 2) divmod(x, y)\n\n\n\n```js\nprint(divmod(6, 3))  # (2, 0)\nprint(divmod(7, 3))  # (2, 1)\nprint(divmod(8, 3))  # (2, 2)\nprint(divmod(9, 3))  # (3, 0)\n```\n\n`divmod(x, y)` 함수를 호출하면, x를 y로 나눈 결과를 담은 두 항목이 있는 튜플을 반환합니다:\n\n- x를 y로 나눌 때의 몫 — 기본적으로 x // y\n- x를 y로 나눌 때의 나머지 — 기본적으로 x % y\n\n`divmod(x, y)`를 사용하면, x // y와 x % y를 각각 사용하는 것을 한 줄의 코드로 요약할 수 있습니다.\n\n\n\n# 3) hasattr(object, attribute_name)\n\n`hasattr(object, attribute_name)` 함수를 사용하여 객체 object가 문자열 이름 attribute_name을 가진 속성을 가지고 있는지 확인할 수 있습니다. 이 함수는 해당 이름을 가진 속성이 객체에 실제로 포함되어 있으면 True를 반환하고, 그렇지 않으면 False를 반환합니다.\n\n```python\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nclass Cat:\n    def __init__(self, name, age, colour):\n        self.name = name\n        self.age = age\n        self.colour = colour\n\ndog = Dog('rocky', 5)\ncat = Cat('catty', 6, 'brown')\n\nprint(hasattr(dog, 'colour'))  # False\nprint(hasattr(cat, 'colour'))  # True\n```\n\n- Dog 객체에는 name과 age 속성을 가지도록 정의합니다.\n- Cat 객체에는 name, age, colour 속성을 가지도록 정의합니다.\n- `hasattr(dog, 'colour')`는 Dog 객체가 colour 속성을 가지고 있지 않기 때문에 False를 반환합니다.\n- `hasattr(cat, 'colour')`는 Cat 객체가 colour 속성을 가지고 있기 때문에 True를 반환합니다. Cat의 `__init__` 함수에서 정의한 대로입니다.\n\n\n\n`hasattr` 함수를 사용하여 특정 객체에 속성이 있는지 확인한 후 해당 속성에 액세스를 시도할 수 있습니다.\n\n## 4) isinstance(object, class)\n\nisinstance(object, class) 함수는 다음과 같은 경우 True를 반환합니다:\n\n- 객체의 유형이 클래스와 동일한 경우\n- 객체의 유형이 클래스를 상속한 경우\n\n\n\n```python\nclass Animal: pass\nclass Dog(Animal): pass\nclass Rice: pass\n```\n\n여기서 임의의 클래스를 정의해 봅시다:\n\n- Animal 클래스\n- Animal 클래스를 상속받는 Dog 클래스\n- Rice 클래스\n\n```python\ndog = Dog()\nprint(isinstance(dog, Dog))     # True\nprint(isinstance(dog, Animal))  # True\nprint(isinstance(dog, Rice))    # False\n```\n\n\n\n- 개는 개입니다, 따라서 isinstance(dog, Dog)는 True를 반환합니다.\n- 개는 직접적으로 동물이 아니지만, 개가 동물을 상속받았기 때문에, 개는 동물입니다 — 따라서 isinstance(dog, Animal)은 True를 반환합니다.\n- 개는 밥이 아니므로, isinstance(dog, Rice)는 False를 반환합니다.\n\n```js\na = Animal()\nprint(isinstance(a, Dog))     # False\nprint(isinstance(a, Animal))  # True\nprint(isinstance(a, Rice))    # False\n```\n\n- Dog는 Animal을 상속받았으므로, 개는 확실히 동물입니다 → 그러나 동물이 반드시 개일 필요는 없습니다 → isinstance(a, Dog)는 False를 반환합니다.\n- a는 Animal이므로, isinstance(a, Animal)은 True를 반환합니다.\n- a는 밥이 아니므로, isinstance(a, rice)은 False를 반환합니다.\n\n# 5) issubclass(class1, class2)\n\n\n\n\nissubclass(class1, class2) 함수는 다음 경우에 True를 반환합니다:\n\n- class1이 class2와 동일한 경우\n- class1이 class2의 하위 클래스인 경우 — 즉, class1이 어떤 방식으로든 class2로부터 상속을 받는 경우입니다.\n\n```js\nclass Animal: pass\nclass Dog(Animal): pass\nclass GermanShepherd(Dog): pass\n\nprint(issubclass(Animal, Animal))          # True\nprint(issubclass(Dog, Animal))             # True\nprint(issubclass(GermanShepherd, Animal))  # True\n```\n\n- Animal은 Animal이므로 issubclass(Animal, Animal)은 True를 반환합니다.\n- Dog는 Animal이므로 issubclass(Dog, Animal)은 True를 반환합니다.\n- GermanShepherd는 Dog이고 Dog는 Animal이므로 issubclass(GermanShepherd, Animal) 또한 True를 반환합니다.\n\n\n\n\n```js\nprint(issubclass(Animal, Dog))             # False\n```\n\n- 개는 동물입니다. 그러나 모든 동물이 개일 필요는 없으므로 issubclass(Animal, Dog)는 False를 반환합니다.\n\n# 결론\n\n이것이 명확하고 이해하기 쉬웠으면 좋겠습니다.\n\n\n\n# 만약에 나를 창작자로 지원하고 싶다면\n\n-  이 이야기를 위해 50번 박수를 치세요\n-  당신의 생각을 나에게 남겨주세요\n-  이 이야기에서 가장 마음에 드는 부분을 강조해 주세요\n\n감사합니다! 이 작은 행동들이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: https://www.youtube.com/@zlliu246\n\n\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)\n\nMy Ebooks: [https://zlliu.co/ebooks](https://zlliu.co/ebooks)","ogImage":{"url":"/assets/img/2024-05-15-5LessKnownBuilt-InPythonFunctions_0.png"},"coverImage":"/assets/img/2024-05-15-5LessKnownBuilt-InPythonFunctions_0.png","tag":["Tech"],"readingTime":5},{"title":"젯팩 컴포즈로 멋진 3D 파이 차트 만들기","description":"","date":"2024-05-15 15:34","slug":"2024-05-15-BuildinganAmazing3DPieChartwithJetpackCompose","content":"\n\n환영합니다 👋\n\n사용자를 감동시킬 멋진 파이 차트를 구현하는 데 5분 이상 투자하지 않고 싶나요?\n\n그렇다면, 당신이 올바른 곳에 왔습니다. 이 기사는 정확히 그것에 대한 것입니다.\n\n계속 보고, 함께 알아봐요! 🚀\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*TMrRg9yn-gQWNzsPyCCIMg.gif)\n\n# Convex Pie Chart\n\n가장 흥미로운 부분에서 여정을 시작해 보죠: 조각에 적용할 볼록한 효과를 가진 Pie Chart를 만들어 봅시다.\n\n## PieChart 데이터\n\n\n\n\n함수를 조립하기 전에, 원 차트 데이터를 나타내는 데이터 클래스를 만들어야 합니다.\n\n```kotlin\ndata class PieChartData(\n    val label: String,\n    val value: Int,\n    val color: Color\n)\n```\n\n## ConvexStyle\n\n또 다른 지원 데이터 클래스인 ConvexStyle을 만들어야 Convex 효과의 시각적 모습을 표현할 수 있습니다.\n\n\n\n```js\ndata class ConvexStyle(\n    val blur: Dp = 5.dp,\n    val offset: Dp = 4.dp,\n    val glareColor: Color = Color.White.copy(0.48f),\n    val shadowColor: Color = Color.Black.copy(0.48f)\n)\n```\n\n## The composable\n\n이제, 원형 차트를 그릴 composable을 정의할 수 있습니다.\n\n```js\n@Composable\nfun ConvexPieChart(\n    modifier: Modifier,\n    data: List<PieChartData>,\n    startAngle: Float = -90f,\n    rotationsCount: Int = 4,\n    pieSliceStyle: ConvexStyle = ConvexStyle(),\n    animationSpec: AnimationSpec<Float> = \n        tween(1_000, easing = LinearOutSlowInEasing)\n) {\n    /* 구현 */\n}\n```\n\n\n\n## ⚒️ 매개변수 분석\n\n⚡ modifier ➜ 레이아웃에 적용된 수정자입니다.\n\n⚡ data ➜ 파이 차트에 표시할 데이터입니다.\n\n⚡ startAngle ➜ 첫 번째 슬라이스의 초기 각도(도)입니다 (그림 1 👇).\n\n\n\n⚡ rotationsCount ➜ 애니메이션 중 완전한 회전 횟수입니다.\n\n⚡ pieSliceStyle ➜ 파이 조각의 볼록 스타일을 정의합니다.\n\n⚡ animationSpec ➜ 스케일 및 회전에 대한 애니메이션 동작을 지정합니다.\n\n![이미지](/assets/img/2024-05-15-BuildinganAmazing3DPieChartwithJetpackCompose_0.png)\n\n\n\n## 오목한 아치\n\n파이 차트 자체를 그리기 전에, 우리 아름다운 조각들을 렌더링할 drawConvexArc라는 지원 함수를 만들어보겠습니다.\n\n```js\nfun DrawScope.drawConvexArc(\n    color: Color,\n    startAngle: Float,\n    sweepAngle: Float,\n    useCenter: Boolean,\n    style: ConvexStyle,\n) = canvas에 그리기 { canvas ->\n    val rect = this.size.toRect() // 캔버스의 경계\n    \n    // 그리기용 페인트 개체 정의\n    val paint = Paint()\n    paint.color = color\n    \n    // 캔버스에 기본 아치 그리기\n    canvas.drawArc(rect, startAngle, sweepAngle, useCenter, paint)\n    \n    // 그림자와 번빛 아치를 그리는 함수 정의\n    fun drawShadowArc(offsetX: Float, offsetY: Float, shadowColor: Color) {\n        val shadowPaint = Paint() // 그림자를 그리기 위한 페인트 개체\n\n        shadowPaint.color = shadowColor // 그림자 색상 설정\n\n        // 현재 캔버스 레이어 저장\n        canvas.saveLayer(rect, shadowPaint)\n        \n        // 그림자 아치 그리기\n        canvas.drawArc(rect, startAngle, sweepAngle, useCenter, shadowPaint)\n\n        // 그림자에 블렌딩 모드 및 블러 효과 적용\n        shadowPaint.asFrameworkPaint().apply {\n            xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_OUT)\n            maskFilter = BlurMaskFilter(style.blur.toPx(), BlurMaskFilter.Blur.NORMAL)\n        }\n\n        shadowPaint.color = Color.Black // 클리핑을 위한 색상 설정\n\n        // 캔버스 이동 및 클리핑 아치 그리기\n        canvas.translate(offsetX, offsetY)\n        canvas.drawArc(rect, startAngle, sweepAngle, useCenter, shadowPaint)\n\n        // 캔버스를 원래 상태로 복원\n        canvas.restore()\n    }\n    \n    // 픽셀 단위로 오프셋 계산\n    val offsetPx = style.offset.toPx()\n    \n    // 음수 오프셋으로 그림자 아치 그리기\n    drawShadowArc(-offsetPx, -offsetPx, style.shadowColor)\n    \n    // 양수 오프셋으로 번빛 아치 그리기\n    drawShadowArc(offsetPx, offsetPx, style.glareColor)\n}\n```\n\n더 잘 이해하기 위해 아래 사진을 확인하세요 👇\n\n\n\n\n![BuildinganAmazing3DPieChartwithJetpackCompose_1](/assets/img/2024-05-15-BuildinganAmazing3DPieChartwithJetpackCompose_1.png)\n\n![BuildinganAmazing3DPieChartwithJetpackCompose_2](/assets/img/2024-05-15-BuildinganAmazing3DPieChartwithJetpackCompose_2.png)\n\n## Convex pie chart\n\nNow that we have the drawConvexArc function, we can draw the pie chart.\n\n\n\n\n```kotlin\n@Composable\nfun ConvexPieChart(\n    /* 매개변수 */\n) {\n    // 모든 데이터 값의 합\n    val totalValuesSum = remember(data) { data.sumOf(PieChartData::value) } \n\n    // 파이 차트를 확대 및 회전하기 위한 애니메이션 가능한 값\n    val pieChartScale = remember { Animatable(0f) }\n    val pieChartRotation = remember { Animatable(0f) }\n\n    // 파이 차트를 확대하고 회전시키는 애니메이션 시작\n    LaunchedEffect(Unit) {\n        launch {\n            pieChartScale.animateTo(1f, animationSpec)\n        }\n        launch {\n            pieChartRotation.animateTo(360f * rotationsCount, animationSpec)\n        }\n    }\n\n    // 캔버스를 사용하여 파이 차트 그리기\n    Canvas(\n        modifier\n            .aspectRatio(1f) // 캔버스가 정사각형이 되도록 함 (1:1)\n            // 애니메이션 전환 적용\n            .scale(pieChartScale.value)\n            .rotate(pieChartRotation.value)\n    ) {\n        // 시작 각도로 마지막 값 초기화\n        var lastValue = startAngle\n        // 각 데이터 포인트를 반복하고 해당 파이 조각을 그리기\n        data.forEach { chartData ->\n            // 현재 데이터 포인트의 스윕 각도 계산\n            val pieSweepAngle = 360f * (chartData.value.toFloat() / totalValuesSum.toFloat())\n            // 파이 슬라이스를 나타내는 볼록한 아크 그리기\n            drawConvexArc(\n                color = chartData.color,\n                startAngle = lastValue,\n                sweepAngle = pieSweepAngle,\n                style = pieSliceStyle,\n                useCenter = true\n            )\n            // 다음 슬라이스를 위해 마지막 값 업데이트\n            lastValue += pieSweepAngle\n        }\n    }\n}\n```\n\n좋아요, 우리가 이미 이룬 것들이에요 😍\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*-yHzlxmatQyVTdfTV8h5yQ.gif\" />\n\n# 파이 차트 패널\n\n\n\n\n자, 이제 그림자를 활용하여 빛나는 피 크림 차트를 위한 멋진 패널을 만들어 봅시다.\n\n여기서 그림자의 놀이 🤹‍♂️을 하며, innerShadow와 dropShadow 수정자(modifier)를 사용할 것입니다. 자세한 설명은 아래 제가 제공한 관련 기사를 참조하거나 👇 아래 링크에서 InnerShadow Gist, DropShadow Gist의 코드를 확인할 수 있습니다.\n\n```js\n@Composable\nfun PieChartPanel(\n    modifier: Modifier,\n    platesColor: Color = Color(0xFFD5F3FF),\n    platesGap: Dp = 32.dp,\n    style: ConvexStyle = ConvexStyle(\n        blur = 12.dp,\n        offset = 8.dp,\n        glareColor = Color.White.copy(alpha = 0.32f),\n        shadowColor = Color.Black.copy(alpha = 0.32f)\n    ),\n    content: @Composable BoxScope.() -> Unit\n) {\n    Box(\n        // 전체 패널을 나타내는 외부 상자\n        modifier = modifier\n            .aspectRatio(1f) // 가로세로 비율 1:1로 설정\n            // 내부 그림자 적용으로 깊이 효과 생성\n            .innerShadow(CircleShape, style.glareColor, style.blur, -style.offset, -style.offset)\n            .innerShadow(CircleShape, style.shadowColor, style.blur, style.offset, style.offset)\n            // 드롭 그림자 적용으로 고도 효과 생성\n            .dropShadow(CircleShape, style.glareColor, style.blur, -style.offset, -style.offset)\n            .dropShadow(CircleShape, style.shadowColor, style.blur, style.offset, style.offset)\n            // 배경 그리기\n            .background(platesColor, CircleShape),\n        contentAlignment = Alignment.Center\n    ) {\n        Box(\n            // 실제 콘텐츠를 포함하는 내부 상자\n            modifier = Modifier\n                .matchParentSize() // 전체 부모 크기 차지\n                .padding(platesGap) // 플레이트 간의 갭 추가\n                // 드롭 그림자 적용으로 고도 효과 생성\n                .dropShadow(CircleShape, style.glareColor, style.blur, -style.offset, -style.offset)\n                .dropShadow(CircleShape, style.shadowColor, style.blur, style.offset, style.offset)\n                // 배경 그리기\n                .background(platesColor, CircleShape),\n            contentAlignment = Alignment.Center,\n            content = content // 콘텐츠 삽입\n        )\n    }\n}\n```\n\n자, 준비가 다 되었습니다! 패널에 표시할 콘텐츠가 마지막 조각입니다. 패널에 표시할 총 값 텍스트를 조금의 애니메이션과 함께 만들어 봅시다.\n\n\n\n```kotlin\n@Composable\nfun TotalView(\n    total: Int,\n    modifier: Modifier = Modifier,\n    animationSpec: AnimationSpec<Int> = tween(1000, easing = FastOutSlowInEasing)\n) {\n    val totalToDisplay = remember {\n        Animatable(initialValue = 0, typeConverter = Int.VectorConverter)\n    }\n\n    // total 값이 변경될 때 전체 값을 애니메이트하는 effect 시작\n    LaunchedEffect(total) {\n        totalToDisplay.animateTo(total, animationSpec)\n    }\n\n    Column(\n        modifier = modifier,\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\n            text = \"총액\",\n            fontSize = 14.sp,\n            color = Color(0xFF464646)\n        )\n        Text(\n            text = \"${totalToDisplay.value}$\",\n            fontSize = 18.sp,\n            fontWeight = FontWeight.Medium,\n            color = Color(0xFF010203)\n        )\n    }\n}\n```\n\n축하합니다🥳! 성공적으로 구현했습니다👏. 전체 코드 구현은 GitHub Gist에서 확인하실 수 있어요🧑‍💻. 이제 모든 것을 하나로 합쳐서 최종 결과를 살펴봅시다!\n\n## 광고\n\n외국어를 배우고 새로운 어휘에 어려움을 겪고 계신가요? 그렇다면 어플 단어 학습 어플 을 꼭 추천드립니다! 여러분들의 학습 여정을 쉽고 편리하게 만들어 줄 거예요!\n\n\n\n\n![Image](/assets/img/2024-05-15-BuildinganAmazing3DPieChartwithJetpackCompose_3.png)\n\n# Final\n\n이제 시연을 위한 데이터 목록을 만들어 봅시다:\n\n```js\nval pieChartData = remember {\n    listOf(\n        PieChartData(\"항목-1\", 30, Color(0xFFE45C5C)),\n        PieChartData(\"항목-2\", 45, Color(0xFF8FE25C)),\n        PieChartData(\"항목-3\", 25, Color(0xFF4471E4)),\n        PieChartData(\"항목-4\", 20, Color(0xFFEECE55)),\n        PieChartData(\"항목-5\", 40, Color(0xFFBD68CB)),\n    )\n}\n```\n\n\n\n그리고 마지막으로 마무리해봅시다 🔩\n\n```js\nBox(contentAlignment = Alignment.Center) {\n    ConvexPieChart(\n        data = pieChartData,\n        modifier = Modifier.size(300.dp)\n    )\n    PieChartPanel(\n        Modifier.size(180.dp)\n    ) {\n        TotalView(total = 23548)\n    }\n}\n```\n\n## 결과\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*n7ZqFsdqSEl1egbPbMKD_g.gif\" />\n\n\n\n당신께 도움이 되었길 바라며 감사합니다. 코딩을 즐기세요! ❤️\n\n아래 내용도 마음에 드실지도요 👇\n\n만일 좋아하셨다면 👏 클립해주세요! 그리고 더 많은 흥미로운 글을 보고 싶다면\nKappdev\n를 팔로우해주세요 😊\n\n![3D 파이 차트 만들기](/assets/img/2024-05-15-BuildinganAmazing3DPieChartwithJetpackCompose_4.png)","ogImage":{"url":"/assets/img/2024-05-15-BuildinganAmazing3DPieChartwithJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-15-BuildinganAmazing3DPieChartwithJetpackCompose_0.png","tag":["Tech"],"readingTime":10},{"title":"브라우저가 팝오버 API 지원을 시작했습니다 빠른 안내","description":"","date":"2024-05-15 15:32","slug":"2024-05-15-BrowserBeginsSupportforPopoverAPIAQuickGuide","content":"\n\n## 새로운 팝오버 API로 웹 개발을 간소화하세요\n\n![이미지](/assets/img/2024-05-15-BrowserBeginsSupportforPopoverAPIAQuickGuide_0.png)\n\n저의 뉴스레터에 원문이 게재되었습니다.\n\n팝오버는 일시적으로 부유하는 오버레이 레이어에 추가 콘텐츠나 인터랙티브 요소를 표시하는 데 사용되는 범용 UI 구성요소입니다. 과거에는 이를 구현하기 위해 추가 작업이 필요했습니다.\n\n\n\n거의 모든 주요 브라우저에서 이제 Popover API를 지원합니다. 이 API는 추가 라이브러리 없이 이러한 요소를 생성하고 관리하는 표준화된 방법을 제공합니다.\n\n# popover Global Attribute\n\nHTMLElement에 popover 속성을 추가하면 해당 요소가 팝오버로 변환됩니다. 이 팝오버 요소는 초기에 display: none을 사용하여 숨겨져 있지만 아래에서 설명하는대로 활성화될 때 표시됩니다.\n\n활성화되면 팝오버는 다른 모든 요소 위에 표시되며 부모 요소의 위치 또는 오버플로 스타일에 영향을 받지 않습니다.\n\n\n\n팝오버 속성은 \"auto\" (기본값) 또는 \"manual\" 값을 가질 수 있습니다. 자동 상태의 팝오버는 팝오버 영역 외부를 선택하여 \"경량 해제\" 할 수 있으며 일반적으로 한 번에 화면에 하나의 팝오버만 표시됩니다. 이에 반해, 수동 팝오버는 항상 명시적으로 숨겨져야 하지만 메뉴 내의 중첩된 팝오버를 허용합니다.\n\n![팝오버 이미지](/assets/img/2024-05-15-BrowserBeginsSupportforPopoverAPIAQuickGuide_1.png)\n\n# 활성화 방법\n\n생성하는 두 가지 방법이 있습니다:\n\n\n\n## HTML 선언\n\n```js\n<button popovertarget=\"mypopover\" popovertargetaction=\"toggle\">팝오버 토글</button>\n<div id=\"mypopover\" popover>팝오버 내용</div>\n```\n\n여기서 `popovertarget`은 새롭게 추가된 속성으로, `button` 또는 `input` 요소를 팝오버 제어 버튼으로 변환합니다. 이 속성은 제어하는 팝오버 요소의 ID를 값으로 갖습니다.\n\n비슷하게, `popovertargetaction`도 새롭게 추가된 속성으로, hide, show, toggle을 받습니다. 기본값은 toggle이며, 생략 가능합니다. 이 속성은 팝오버 요소에 대한 제어 버튼의 작업을 지정합니다.\n\n\n\n## JavaScript API\n\n```js\n// 팝오버 엘리먼트의 표시 상태를 토글합니다.\nHTMLElement.togglePopover();\n\n// 팝오버 엘리먼트를 상위 레이어에 추가하여 표시합니다.\nHTMLElement.showPopover();\n\n// 팝오버 엘리먼트를 상위 레이어에서 제거하고 display: none으로 스타일링하여 숨깁니다.\nHTMLElement.hidePopover();\n```\n\n팝오버 속성을 가진 엘리먼트에 이러한 함수를 호출하면 원하는 효과를 빠르게 얻을 수 있습니다.\n\n# 이벤트\n\n\n\n팝오버 요소의 상태가 표시되거나 숨겨지는 경우, 몇 가지 작업을 수행해야 할 수도 있습니다. 브라우저는 다음과 같이 구성된 beforetoggle 이벤트와 toggle 이벤트를 제공합니다:\n\n```js\ninterface ToggleEvent extends Event {\n    readonly newState: string;\n    readonly oldState: string;\n}\n```\n\n여기서 newState와 oldState의 값은 모두 \"open\" 또는 \"closed\"입니다. 하지만 전자는 요소가 전이되는 상태를 나타내고, 후자는 요소가 전환되는 상태를 나타냅니다.\n\n자세히 살펴보겠습니다:\n\n\n\n## beforetoggle 이벤트\n\n팝오버 요소의 상태가 보이는 상태와 숨겨진 상태 사이를 전환할 때 또는 그 반대로 전환하기 전에 발생합니다.\n\n```js\nconst popover = document.getElementById(\"mypopover\");\n\n// ...\n\npopover.addEventListener(\"beforetoggle\", (event) => {\n  if (event.newState === \"open\") {\n    console.log(\"팝오버가 표시됩니다\");\n  } else {\n    console.log(\"팝오버가 숨겨집니다\");\n  }\n});\n\npopover.showPopover();\npopover.hidePopover();\n// `beforetoggle` 이벤트는 한 번만 발생합니다\n```\n\n여러 개의 beforetoggle 이벤트가 발생하는 경우, 이벤트 루프가 한 번 순환하기 전에 모든 이벤트가 발생하는 것이 아니라 하나의 이벤트만 발생한다는 점을 유의하십시오.\n\n\n\n## 토글 이벤트\n\n팝오버 요소의 상태가 표시되거나 숨겨질 때 또는 반대로 변경된 직후에 발생합니다. 이 이벤트는 이미 디테일 요소의 상태 변화를 신호로 보내는 데 사용됩니다.\n\n```js\nconst popover = document.getElementById(\"mypopover\");\n\n// ...\n\npopover.addEventListener(\"toggle\", (event) => {\n  if (event.newState === \"open\") {\n    console.log(\"팝오버가 표시되었습니다\");\n  } else {\n    console.log(\"팝오버가 숨겨졌습니다\");\n  }\n});\n\npopover.showPopover();\npopover.hidePopover();\n// `toggle` 이벤트는 한 번만 발생함\n```\n\n마찬가지로, 토글 이벤트는 병합됩니다.\n\n\n\n# CSS 특징\n\n팝 오버의 스타일을 사용자 정의하고 싶을 수 있습니다. 브라우저에서 제공하는 다음과 같은 특징들이 있습니다:\n\n## ::backdrop\n\n::backdrop 의사 요소는 팝 오버 요소 바로 뒤에 배치되는 전체 화면 요소로, 원하는 경우 페이지 내용 뒤에 팝 오버를 가리는 효과(예: 흐린 효과)를 추가할 수 있습니다.\n\n\n\n\n<img src=\"/assets/img/2024-05-15-BrowserBeginsSupportforPopoverAPIAQuickGuide_2.png\" />\n\n## :popover-open\n\nThe :popover-open pseudo-class matches a popover element only when it is in the showing state — it can be used to style popover elements when they are showing.\n\n## [popover]\n\n\n\n\nPopover의 기본 CSS 스타일을 다음과 같이 설정할 수도 있어요:\n\n![image](/assets/img/2024-05-15-BrowserBeginsSupportforPopoverAPIAQuickGuide_3.png)\n\n# 결론\n\nPopover API는 HTML과 Javascript에서 기다려온 기능으로, 우리에게 네이티브하고 유연한 솔루션을 제공합니다. 즐거운 코딩 되세요!\n\n\n\n만약 이 내용이 도움이 되었다면, 웹 개발에 대한 더 많은 통찰을 얻기 위해 제 뉴스레터 구독을 고려해 주세요. 읽어 주셔서 감사합니다!\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 마지막으로 가기 전에:\n\n- 작가를 박수와 팔로우해 주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루게 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해 보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 즐기세요","ogImage":{"url":"/assets/img/2024-05-15-BrowserBeginsSupportforPopoverAPIAQuickGuide_0.png"},"coverImage":"/assets/img/2024-05-15-BrowserBeginsSupportforPopoverAPIAQuickGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 부트스트래핑 해부 포괄적인 가이드","description":"","date":"2024-05-15 15:30","slug":"2024-05-15-DemystifyingAngularBootstrappingAComprehensiveGuide","content":"\n\n앵귤러는 강력한 프론트엔드 프레임워크로, 응용 프로그램을 초기화하고 실행하는 강력한 메커니즘을 제공합니다. 앵귤러 부트스트래핑은 앵귤러 프레임워크를 초기화하고 응용 프로그램 구성 요소를 실행하는 과정을 의미합니다. 이것은 앵귤러 응용 프로그램의 시작점으로, UI 구성 요소를 렌더링하고 사용자 상호작용을 처리하는 데 필요한 설정 및 구성을 조정합니다.\n\n앵귤러 부트스트래핑의 주요 구성 요소:\n\n- Index.html: 앵귤러 응용 프로그램의 시작점인 index.html 파일은 초기 HTML 구조를 제공하며 필요한 스크립트 및 스타일시트를 포함합니다.\n- Main.ts (또는 main.js): main.ts (또는 main.js) 파일은 앵귤러 응용 프로그램이 부트스트래핑되는 곳입니다. @angular/platform-browser-dynamic에서 platformBrowserDynamic를 import하고 bootstrapModule() 메서드를 사용하여 루트 모듈 (AppModule)을 초기화합니다.\n\n```js\nimport { platformBrowserDynamic } from \"@angular/platform-browser-dynamic\";\nimport { AppModule } from \"./app/app.module\";\n\nplatformBrowserDynamic()\n  .bootstrapModule(AppModule)\n  .catch((err) => console.error(err));\n```\n\n\n\n<img src=\"/assets/img/2024-05-15-DemystifyingAngularBootstrappingAComprehensiveGuide_0.png\" />\n\n3. AppModule: 루트 모듈(AppModule)은 app.module.ts 파일에 정의됩니다. 필요한 Angular 모듈을 가져오고, 컴포넌트를 선언하며, @NgModule 데코레이터의 bootstrap 속성을 사용하여 부트스트랩할 루트 컴포넌트를 지정합니다.\n\n```js\nimport { NgModule } from \"@angular/core\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { AppComponent } from \"./app.component\";\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n4. App Component: 루트 컴포넌트(AppComponent)는 애플리케이션의 최상위 컴포넌트를 나타내며, app.component.ts 파일에 정의됩니다. HTML 템플릿과 컴포넌트 로직을 정의합니다.\n\n\n\n```js\nimport { Component } from \"@angular/core\";\n@Component({\n  selector: \"app-root\",\n  template: ` <h1>Hello Angular!</h1> `,\n  styles: [],\n})\nexport class AppComponent {}\n```\n\n부트스트래핑은 Angular 애플리케이션에서 중요한 역할을 하며, 프레임워크를 시작하고 컴포넌트의 실행을 용이하게합니다. Angular를 처음 접하는 초보자이거나 깊이있는 이해를 위해 노력하는 숙련된 개발자이던간에, 부트스트래핑을 습득하는 것은 견고하고 확장 가능한 Angular 애플리케이션을 구축하기 위한 기본 단계입니다.\n\n즐거운 코딩하세요! 😇\n","ogImage":{"url":"/assets/img/2024-05-15-DemystifyingAngularBootstrappingAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-15-DemystifyingAngularBootstrappingAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":2},{"title":"공감과 함께 하는 엔지니어링 스펙트럼 디자인 웹 엔지니어링","description":"","date":"2024-05-15 15:30","slug":"2024-05-15-EngineeringwithempathySpectrumDesignWebEngineering","content":"\n\n# Adobe Spectrum Engineering에서 디자인 엔지니어의 역할은 무엇인가요?\n\nAdobe Spectrum 팀 내 디자인 엔지니어 포지션은 전략적 계획과 협업 이니셔티브에 중점을 둔 역할을 수행합니다. 이 역할은 전략적 계획의 개발 및 실행, 다기능 팀 간 협업을 촉진하는 데 초점을 맞추고 있습니다.\n\nAdobe Spectrum 웹 컴포넌트(SWC) 팀 내 디자인 엔지니어들은 Adobe의 다양한 제품군을 아우르는 UI를 기반으로 하는 기본 웹 컴포넌트의 개발 및 유지보수에 중요한 역할을 합니다. 이 역할은 단순 코딩을 넘어, 전략적 계획, 구조적 설계, 이러한 컴포넌트의 구현을 포함하며, 성능, 확장성, 사용성의 최고 기준을 충족시키도록 합니다.\n\nSWC 팀의 디자인 엔지니어들의 주요 책임 중 하나는 Adobe 내 다양한 제품 팀을 위한 건물 블록으로 작용하는 웹 컴포넌트를 설계하고 구축하는 것입니다. 이는 다양한 제품의 요구 사항을 이해하고, 유연하고 재사용 가능한 컴포넌트를 디자인하고, 일관성과 효율성을 촉진하는 방식으로 구현하는 것을 포함합니다.\n\n\n\n# 시니어/스태프 설계 엔지니어가 작업하는 것은 무엇인가요?\n\nAdobe의 Spectrum 팀에서 시니어 설계 엔지니어가 되는 것은 그냥 승진이 아니라 마음가짐과 접근 방식이 변화되어야 하는 역할로의 전환입니다. 시니어/스태프 설계 엔지니어로 이동하는 것은 더욱 모호하고 전략적이며 영향력이 있는 작업을 맡는 것을 의미합니다. 큰 그림을 이해하고 효율적으로 협력하며 공감대를 갖고 선도하는 것에 관한 것입니다.\n\n이 새로운 역할에서 당신은 제품 출시에만 초점을 맞추는 것이 아니라 전략적으로 생각합니다. 회사의 수익과 전체 목표에 상당한 영향을 미치는 프로젝트에 몰두합니다. 팀과 조직의 전반적 목표와 일치시키는 것이 중요합니다.\n\n시니어 설계 엔지니어의 중요한 측면 중 하나는 비즈니스가 무엇에 관심을 가지고 어떤 목표를 가지고 있는지 이해하는 것입니다. 이는 명확한 커뮤니케이션과 회사의 우선순위에 대한 심도있는 이해가 필요합니다.\n\n\n\n큰 이니셔티브에 참여하는 것 외에 시니어 디자인 엔지니어는 참여하는 프로젝트가 원활하게 진행되고 있는지 확인하는 데도 책임이 있습니다. 이는 프로젝트의 상태를 면밀히 점검하고 모든 사람이 막힘이 없도록 하며 팀이 건강하게 작동하고 있는지 확인하는 것을 의미합니다.\n\n# Spectrum CSS 팀의 엔지니어는 어떻게 Spectrum 웹 컴포넌트 엔지니어링 팀과 협력하나요?\n\n또한 Spectrum CSS 팀의 엔지니어들은 이러한 컴포넌트의 CSS 측면을 관리해야 합니다. 이는 디자인 토큰을 CSS 코드로 번역하고 CSS가 웹 컴포넌트에 올바르게 적용되도록 하는 것을 포함합니다. 또한 이들은 이러한 CSS 스타일을 효과적으로 적용하여 제품 간 일관된 디자인 언어를 유지하는 책임이 있습니다.\n\n제품 팀, UX 디자이너 및 기타 이해관계자들과 긴밀히 협력함으로써 두 팀의 디자인 엔지니어들은 개발한 웹 컴포넌트와 CSS가 기능 요구사항을 충족할 뿐만 아니라 Adobe의 디자인 원칙과 브랜드 가이드라인과 일치하도록 보장합니다. 이 협업은 모든 Adobe 제품에서 일관되고 매끄러운 사용자 경험을 제공하기 위해 중요합니다.\n\n\n\n# 디자인 엔지니어가 핵심 라이브러리를 유연하게 유지하는 방법은 무엇인가요?\n\n디자인 엔지니어의 주요 책임 중 하나는 구축하는 시스템이 유연하고 적응 가능하다는 것을 보장하는 것입니다. 엔지니어링 팀은 확장성과 모듈성을 고려하여 시스템을 설계하여 새로운 기능과 기술을 쉽게 통합할 수 있도록 합니다. 이러한 유연성은 현재 급변하는 기술적 환경에서 빠르게 전환하고 변화에 적응하는 능력이 성공에 필수적인 시대에 중요합니다.\n\n## 개인 기여자 마인드셋에서의 전환이:\n\n시니어/스태프 디자인 엔지니어들은 개인적인 기여에 집중하는 것에서 더 넓은 전략적 목표와 결과를 우선시하는 마인드셋 전환이 필요합니다. 코드 작성과 커밋에서 만족을 얻는 것이 아니라, 전체 팀과 조직적인 성공을 주도하는 데 초점을 맞춥니다. 이러한 변화를 통해 기업의 전략적 방향과 노력을 더 잘 일치시키고 장기적 목표에 더 효과적으로 기여할 수 있게 됩니다.\n\n\n\n# Adobe에서 제품 팀과의 협업을 유지하는 데 디자인 엔지니어가 어떻게 도와줄까요?\n\nAdobe의 Spectrum 웹 컴포넌트 (SWC) 팀 내에서 디자인 엔지니어는 교차 조직적인 솔루션을 식별하기 위해 다른 제품 팀과 협업하는 중요한 역할을 합니다. 다양한 Adobe 제품에 작업 중인 팀들과 적극적으로 소통하여 그들의 도전 과제, 요구 사항 및 기술적 요구 사항을 이해합니다. 산업 동향에 대한 전문 지식을 활용하여 디자인 엔지니어는 SWC 팀에서 개발된 솔루션이 여러 제품에 걸쳐 문제 해결에 적용될 수 있는 기회를 식별합니다.\n\n이 협업에 참여하는 한 가지 방법은 디자인 엔지니어가 제품 팀과 함께 논의 및 회의에 적극적으로 참여하는 것입니다. SWC 구성 요소 및 CSS를 활용하여 특정 요구 사항을 해결하거나 다른 제품의 기능을 향상시킬 수 있는 제안과 통찰을 제공합니다. 이 협업은 기술적 도전에 직면한 팀들의 장애 해소뿐만 아니라 지식 공유와 혁신 문화를 조성하는 데 도움을 줍니다.\n\n또한, SWC 팀의 디자인 엔지니어들은 다른 제품 팀에 SWC 구성 요소의 최신 업데이트 및 개선 사항을 적극적으로 공유합니다. 이를 통해 제품 팀이 최신 개발 사항을 인지하고 제품의 사용자 경험을 향상시키기 위해 활용할 수 있습니다. 디자인 엔지니어들은 또한 제품 팀과 긴밀히 협업하여 SWC 구성 요소와 관련된 문제나 버그를 해결하고, 제때 제품에 원활히 통합되도록 시간을 정해 해결책을 제공합니다.\n\n\n\n# 개를 흔드는 것:\n\n결론적으로, Spectrum 팀의 디자인 엔지니어로 일하는 것은 교향악단의 지휘자가 되는 것과 같습니다 — 기술적 기량은 그저 빙산의 일각에 불과합니다. 팀원들과 조화롭게 일하고, 그들의 리듬을 이해하며, 공감과 미적 감각으로 공연을 이끌어내는 것이 중요합니다. 타인의 요구에 귀 기울이고, 협업을 추진하며, 공감과 함께 지휘하는 지식 엔지니어들은 혁신과 팀워크의 걸작을 만들어 회사 전반에 울림을 줄 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-EngineeringwithempathySpectrumDesignWebEngineering_0.png"},"coverImage":"/assets/img/2024-05-15-EngineeringwithempathySpectrumDesignWebEngineering_0.png","tag":["Tech"],"readingTime":4},{"title":"비동기 작업을 AbortController로 관리하기","description":"","date":"2024-05-15 15:29","slug":"2024-05-15-ManagingasynchronousoperationswithAbortController","content":"\n\n`<img src=\"/assets/img/2024-05-15-ManagingasynchronousoperationswithAbortController_0.png\" />`\n\nAbortController는 특수한 기능입니다. 대부분의 사람들은 Webpack 구성, 파일 I/O 또는 버퍼와 같은 것들과 작업을 하다가 이 매우 유용한 API를 우연히 발견하게 됩니다. 널리 사용되지 않지만 AbortController는 비동기 작업을 취소하는 방법을 제공하여 매우 유용합니다. 당신이 곧 알게 될 것은... 무엇이든지!\n\n하지만 먼저 기초부터 시작해보죠.\n\n# 네트워크 요청\n\n\n\nAbortController의 가장 잘 알려진 사용법은 네트워크 호출을 취소하는 데 사용하는 것입니다. fetch API는 옵션으로 signal 속성을 기본 제공하며, 문법은 다음과 같습니다:\n\n```js\nconst controller = new AbortController();\nconst signal = controller.signal;\n\nawait fetch(url, { signal })\n\n// 요청을 취소하려면 다음을 호출하십시오:\ncontroller.cancel()\n```\n\n웹 응용 프로그램 프레임워크 세계에서는 아래와 같이 사용되는 것을 찾을 수 있습니다 (이 기사 전반에서 코드 예시로 React를 사용합니다):\n\n```js\nuseEffect(() => {\n  const controller = new AbortController();\n  const signal = controller.signal;\n  \n  const fetchData = async () => {\n    try {\n      const res = await fetch(url, { signal })\n      const data = await res.json();\n\n      setState(data);\n    } catch (err) {\n      // 에러 처리\n    }\n  }\n  \n  void fetchData();\n  \n  return () => {\n    controller.abort()\n  }\n}, []);\n```\n\n\n이것은 당신의 컴포넌트가 unmounted(해제된) 될 때 API를 계속해서 가져오지 않고 상태를 설정하지 않도록 보장하기 위해 필요합니다.\n\n# 타이머\n\n일반적인 sleep 함수는 아래와 같이 보입니다:\n\n```js\nconst sleep = async (ms: number) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n```\n\n\n\n좋은 작업이 잘 되었지만 이렇게 되면 콜백을 취소할 수 없어요. 이 문제를 해결해 봐요:\n\n```js\nconst sleep = async (ms: number, timeoutId: NodeJS.Timeout) => {\n  return new Promise((resolve) => {\n    timeoutId = setTimeout(resolve, ms);\n  });\n};\n```\n\n이 코드는 간단한 작업에는 잘 작동하지만, 민감도에 따라 2가지 (또는 3가지) 문제가 있어요. 첫째, timeoutId가 사용되지 않는다는 경고가 대부분의 린팅 설정에서 표시될 거예요. 둘째, 네트워크 요청과 섞였을 때, 2개의 다른 정리 API가 발생해요. 세번째 문제는 timeoutId 매개변수가 참조로 전달되고, refenence 작업을 엄격히 제어하지 않는 언어에서 참조로 작업하는 것은 종종 예기치 못한 버그를 발생시킬 수 있어요.\n\nAbortController를 사용하면 도움이 될거예요, 특히 AbortController 신호는 여러 소스에 연결할 수 있기 때문에요.\n\n\n\n이제 신호를 지원하기 위해 sleep 함수를 수정해 봅시다:\n\n```js\nconst sleep = (ms: number, { signal = null }: { signal: AbortSignal | null }): Promise<void> =>\n  new Promise((resolve) => {\n    const timeoutId = setTimeout(resolve, ms);\n    \n    if (signal) {\n      signal.addEventListener('abort', () => clearTimeout(timeoutId), { once: true });\n    }\n  });\n```\n\n이제 fetch API와 일치하도록 정렬되었으니, 실제로 어떻게 작동하는지 살펴봅시다:\n\n```js\nuseEffect(() => {\n  const abortController = new AbortController();\n  const signal = abortController.signal;\n\n  const fetcher = async () => {\n    await fetch('/api/1', { signal });\n    await sleep(200, { signal });\n    await fetch('/api/2', { signal });\n  };\n\n  void fetcher();\n\n  return () => {\n    abortController.abort();\n  };\n}, []);\n```\n\n\n\n위에서 볼 수 있듯이, AbortController 신호는 fetch 요청과 사용자 정의 sleep 함수 두 가지에 모두 활용되어, 단일 신호가 여러 비동기 작업에 걸쳐 공유되고 코드를 깔끔하게 유지할 수 있다는 것을 보여줍니다.\n\n# Debounce와 Throttle\n\n사용자가 입력할 때 API에서 제안을 가져오고 싶은 검색 입력란을 가지고 있다고 상상해보세요. 매크로트롬이 발동되는 것은 거의 원하는 것이 아닙니다. 키 입력할 때마다 요청을 보내는 것은 성능 및 개인 정보 보호에 여러 문제가 있을 수 있습니다. 대신, API 요청을 debounce하여 사용자가 잠시 타이핑을 멈출 때까지 지연시킵니다. 이를 위해 AbortController가 어떻게 도움이 되는지 살펴보겠습니다:\n\n```js\nconst abortControllerRef = useRef<AbortController | null>(null);\n\nconst onInput = useCallback(\n  async (event: React.ChangeEvent<HTMLInputElement>) => {\n    abortControllerRef.current?.abort(); // 이전 비동기 작업을 안전하게 중단합니다\n\n    const input = event.currentTarget;\n\n    if (input.value?.length < 2) {\n      return; // 짧은 입력 값에 대한 조기 반환\n    }\n\n    abortControllerRef.current = new AbortController();\n    const signal = abortControllerRef.current.signal;\n\n    await sleep(300, { signal }); // Debounce 지연\n\n    await fetchSearchSuggestions(input.value, { signal });\n  },\n  []\n);\n\nuseEffect(() => {\n  return () => {\n    abortControllerRef.current?.abort(); // 컴포넌트가 언마운트될 때 진행 중인 모든 비동기 작업을 중지합니다\n  };\n}, []);\n\nreturn (\n  <input onInput={onInput} />\n);\n```\n\n\n\n다시 한 번 상세 제어기인 AbortController를 활용함으로써, 우리의 코드가 여러 번의 정리 작업을 처리할 필요 없이 간편하게 중단 사항을 처리할 수 있도록 보장합니다. debounce 목적으로 AbortController를 사용하는 추가적인 이점은 사용자가 sleep 함수가 종료된 후에 타이핑을 시작하면 비행 중인 호출을 취소할 것이므로 사용자가 항상 최신 쿼리 결과를 받게 함을 보장합니다. 이전에 해결된 쿼리가 아닌 최신 쿼리에 대한 결과를 사용자가 항상 수신합니다!\n\n이 기사를 리뷰해 준 Trys Mudford님께 감사드립니다 👏\n\n# 저자 소개\n\n저는 Szymon이라고 합니다. Motorway에서 웹 및 디자인 시스템 개발자로 근무하고 있습니다. 5년이 넘게 참여한 이후 영국에서 가장 빠르게 성장하는 중고차 거래 시장을 구축하는 데 도움을 주고 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-ManagingasynchronousoperationswithAbortController_0.png"},"coverImage":"/assets/img/2024-05-15-ManagingasynchronousoperationswithAbortController_0.png","tag":["Tech"],"readingTime":5},{"title":"테스트되지 않은 루비 코드를 리팩토링하는 효과적인 전략 10가지","description":"","date":"2024-05-15 15:27","slug":"2024-05-15-10EffectiveStrategiesforRefactoringUntestedRubyCode","content":"\n\n<img src=\"/assets/img/2024-05-15-10EffectiveStrategiesforRefactoringUntestedRubyCode_0.png\" />\n\n미테스트된 루비 코드를 리팩토링하는 것은 종종 지뢰밭을 횡단하는 것 같은 느낌을 줍니다. 테스트의 안전망 없이 코드를 개선하려고 하면 버그를 도입할 위험이 상당히 커집니다. 그러나 신중한 계획과 체계적인 실행으로 미테스트된 루비 코드를 성공적으로 리팩토링하여 유지보수성, 가독성 및 성능을 향상시킬 수 있습니다. 이 글은 미테스트된 루비 코드베이스를 안전하게 리팩토링하는 구조화된 방법을 개요하고 있습니다.\n\n## 기존 코드베이스 이해하기\n\n리팩토링의 첫 단계는 현재 코드 상태를 깊이 이해하는 것입니다. 핵심 기능을 식별하고 데이터 흐름을 이해하며 의존성을 인식하는 것이 포함됩니다. 코드에 대한 심층적인 탐구는 변경 사항의 영향을 예측하고 리팩토링을 전략적으로 계획하는 데 도움이 됩니다.\n\n\n\n## 테스트 프레임워크 구축하기\n\n어떤 변경이든 하기 전에 테스트 프레임워크를 구축하는 것이 매우 중요합니다. 먼저 애플리케이션의 핵심 기능을 포착하는 고수준 통합 테스트를 작성해보세요. 이러한 테스트는 이후의 리팩터링이 코드의 의도된 동작을 변경하지 않도록 하는 기준 역할을 합니다.\n\n## 정적 분석 도구 활용하기\n\nRuboCop이나 Reek과 같은 도구는 코드에서 스타일 위반, 지나치게 복잡한 메소드, 또는 사용되지 않는 변수와 같은 잠재적 문제를 자동적으로 식별할 수 있습니다. 이러한 도구를 활용하면 리팩터링 작업을 안내받을 수 있어 가장 주의를 기울일 필요가 있는 코드 영역을 우선순위로 정할 수 있습니다.\n\n\n\n## 점진적으로 리팩터링하기\n\n리팩터링은 작고 관리하기 쉬운 단계로 진행해야 합니다. 복잡한 메서드를 간소화하거나 중복 코드를 제거하고 마법 숫자를 이름 있는 상수로 바꾸는 등 낮은 과일부터 시작하세요. 작고 점진적인 변경은 문제 해결을 쉽게 하고 전체 시스템에 큰 방해를 주지 않도록 합니다.\n\n## 변경 내용 캡슐화 및 격리\n\n리팩터링 중에는 캡슐화가 중요합니다. 변경 내용을 캡슐화함으로써 시스템의 다른 부분에 미치는 영향을 최소화할 수 있습니다. 이는 데이터와 구현 세부 정보를 객체 내에 숨기는 것을 포함하며, 이로 인해 코드가 모듈식이 되고 테스트하기 쉬워집니다.\n\n\n\n## 구조적 개선\n\n통과한 테스트 스위트가 있으면 더 많은 구조적 변경을 수행할 수 있습니다. 이는 클래스를 재설계하거나 데이터 구조를 개선하거나 전체 모듈을 리팩터링하는 것을 포함할 수 있습니다. 이러한 변경사항은 코드를 더 논리적이고 효율적이며 유지보수하기 쉽게 만드는 것을 목표로 합니다.\n\n## 성능 최적화\n\n코드가 깔끔하고 잘 구성된 상태라면 성능을 평가할 차례입니다. 병목 현상을 식별하고 최적화하세요. 다만 필요한 경우에만 진행하세요. 조기 최적화는 복잡하고 유지보수가 어려운 코드로 이어질 수 있습니다. 언제나 최적화 작업의 영향을 측정하여 혜택이 있는지 확인하세요.\n\n\n\n## 정기 개발에 리팩토링 통합하기\n\n리팩토링을 개발 주기의 일부로 만듭니다. 이 지속적인 개선은 코드베이스의 악화를 방지하고 미래의 주요 리팩토링 프로젝트 필요성을 줄입니다.\n\n## 문서 업데이트 유지하기\n\n코드가 진화함에 따라 문서도 계속 업데이트해야 합니다. 업데이트된 문서는 새로 합류한 팀원들이나 시스템 기능 및 아키텍처에 대한 명확함을 유지하는 데 중요합니다. 시스템 지식을 보존하고 쉽게 접근할 수 있도록 보장합니다.\n\n\n\n## 협업 강화를 통한 코드 리뷰\n\n마지막으로, 코드 리뷰와 페어 프로그래밍을 통해 팀원들을 리팩토링 과정에 참여시키세요. 이러한 방법들은 코드 품질을 향상시키는데 그치지 않고 변경 사항 및 코드베이스에 대한 지식을 팀 전체에 효과적으로 전달합니다.\n\n이러한 전략을 따르면 개발자들은 테스트되지 않은 Ruby 코드베이스를 효과적으로 관리하고 향상시킬 수 있습니다. 핵심은 신중히 접근하고 철저하게 테스트하며 코드 디자인에서 명확성과 단순성을 우선시하는 것입니다. 이 접근 방식은 리팩터링과 관련된 위험을 완화할 뿐만 아니라 잠재적으로 어려운 작업을 관리 가능하고 체계적인 프로세스로 전환시킵니다.","ogImage":{"url":"/assets/img/2024-05-15-10EffectiveStrategiesforRefactoringUntestedRubyCode_0.png"},"coverImage":"/assets/img/2024-05-15-10EffectiveStrategiesforRefactoringUntestedRubyCode_0.png","tag":["Tech"],"readingTime":3},{"title":"사파리 호환 React 날짜 범위 선택기","description":"","date":"2024-05-15 15:27","slug":"2024-05-15-Safari-CompatibleReactDateRangePicker","content":"\n\n![Safari-Compatible React DateRangePicker](/assets/img/2024-05-15-Safari-CompatibleReactDateRangePicker_0.png)\n\nSafari를 포함한 모든 브라우저에서 작동하는 호환 가능한 날짜 선택기\n\n최근 프로젝트를 진행하면서 날짜 범위 선택기를 구현해야 하는 요구 사항이 있었습니다. 처음에는 MUI CSS 프레임워크를 사용하고 있기 때문에 MUI 날짜 선택기를 사용하기로 결정했습니다. 그러나 Safari에서 예기치 않은 동작을 보여주는 문제가 발생하여 고민이 되었습니다. 다양한 패키지를 사용하여 여러 Proof of Concept (POC)를 수행한 결과, 이 날짜 선택기를 사용하기로 결정했습니다.\n\n같은 문제를 겪고 있다면, 이 블로그가 시간과 노력을 절약해 줄 것입니다. 웹 디자인의 복잡성을 탐험하는 초보자든 믿을 만한 솔루션을 찾아다니는 숙련된 개발자든, 이 블로그는 여러분에게 이상적인 날짜 선택기를 찾는 길잡이 역할을 합니다. 그러니 시작해 봅시다!\n\n\n\n이 문제를 해결하기 위해 react-datepicker을 사용했어요. 이 패키지는 Safari를 포함한 모든 브라우저를 지원하며 특히 Safari에서 잘 작동하며 모든 요구 사항을 충족합니다. 이 패키지는 구현이 매우 쉽습니다. 이 패키지를 어떻게 구현하는지 알아보겠습니다.\n\n터미널에서 루트 프로젝트 디렉토리를 열고 아래 명령을 하나씩 입력하세요. 이 패키지는 구성을 필요로 하지 않아요.\n\n```js\nnpm install react-datepicker --save\n\n---OR---\n\nyarn add react-datepicker\n```\n\n데이트 피커를 사용하려면 라이브러리에서 데이트 피커를 가져와서 아래 코드처럼 속성 몇 가지를 지정하세요. 이렇게 하면 기본적인 데이트 피커가 준비되어요.\n\n\n\n```js\nimport React, { useState } from \"react\";\nimport DatePicker from \"react-datepicker\";\n\nimport \"react-datepicker/dist/react-datepicker.css\";\n\n// CSS Modules, react-datepicker-cssmodules.css\n// import 'react-datepicker/dist/react-datepicker-cssmodules.css';\n\nconst Example = () => {\n  const [startDate, setStartDate] = useState(new Date());\n  return (\n    <DatePicker \n     selected={startDate} \n     onChange={(date) => setStartDate(date)}\n     />\n  );\n};\n```\n\n일부 다른 속성을 추가할 수 있습니다. 예를 들어 dateFormat=\"dd/MM/yyyy\" 및 placeholderText=\"DD/MM/YYYY\". minDate='new Date()'을 사용하여 현재 날짜를 시작 날짜로 설정할 수 있습니다. 아래에서 이 예시를 확인해 보세요.\n\n# 이제 범위 선택기로 사용하는 방법을 살펴봅시다\n\n범위 선택기를 만들려면 DatePicker 구성 요소를 두 번 사용하고 몇 가지 상태를 관리해야 합니다. datePicker를 범위 선택기로 설정하려면 selectsStart 및 selectsEnd를 지정하여 유형을 지정해야 합니다.\n\n\n\n\n여기 있습니다. 크로스 브라우저 지원을 제공하는 날짜 범위 선택기가 있습니다. 날짜 선택기의 공식 문서를 확인해보세요. 많은 사용자 정의 옵션을 제공합니다. 이 블로그가 유용하길 바랍니다. 개발자 친구들과 공유하고 좋아요를 눌러주세요.","ogImage":{"url":"/assets/img/2024-05-15-Safari-CompatibleReactDateRangePicker_0.png"},"coverImage":"/assets/img/2024-05-15-Safari-CompatibleReactDateRangePicker_0.png","tag":["Tech"],"readingTime":2}],"page":"88","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}