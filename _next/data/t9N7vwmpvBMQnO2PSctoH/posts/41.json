{"pageProps":{"posts":[{"title":"React 앱을 Azure Webapp에 배포하는 방법 다단계 Azure YAML 파이프라인 사용하기","description":"","date":"2024-06-20 02:22","slug":"2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline","content":"\n\n이 글에서는 Azure YAML Pipeline을 사용하여 React 앱을 Azure Webapp에 배포하는 배포 프로세스를 안내하겠습니다.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_0.png)\n\n# 웹 앱 생성하기\n\n- Azure 포털에 로그인하고 자격 증명으로 이동하세요: https://portal.azure.com/#home\n- 검색 창에서 App Services를 찾아 서비스 아래에서 해당 옵션을 선택합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_1.png)\n\n3. 클릭하여 Web App 옵션을 선택하고 새 웹 앱을 만듭니다. 아래와 같이 요구 사항에 맞게 웹 앱을 구성하세요.\n\n이름: 웹 앱의 이름 (참고:이 이름은 Azure 전체에서 고유해야합니다.)\n런타임 스택: 노드\n운영 체제: 리눅스\n가격 책정: 요구 사항에 가장 적합한 계획을 선택하세요.\n\n![image](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image 3](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_3.png)\n\n![Image 4](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_4.png)\n\n![Image 5](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_5.png)\n\n![Image 6](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n4. '만들기' 버튼을 클릭한 후에는 새 웹 앱 생성 프로세스가 시작됩니다.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_7.png)\n\n5. 웹 앱이 성공적으로 생성된 후에 '리소스로 이동' 버튼을 클릭하세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_8.png)\n\n<div class=\"content-ad\"></div>\n\n6. 빈 템플릿 페이지가 표시됩니다.\n\n![템플릿 페이지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_9.png)\n\n![템플릿 페이지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_10.png)\n\n# 서비스 연결 생성\n\n<div class=\"content-ad\"></div>\n\n7. 웹 앱이 생성되었으니, Azure YAML 파이프라인을 사용하여 React 앱을 웹 앱에 배포하는 데 집중해 봅시다.\n\n8. https://dev.azure.com/ 로 이동하여 자격 증명으로 로그인하세요.\n\n9. 아래 이미지에서와 같이 조직 및 프로젝트를 선택하세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_11.png)\n\n<div class=\"content-ad\"></div>\n\n10. Azure의 리소스와 통신하기 위해 파이프라인에 서비스 연결을 생성하려면 프로젝트 설정을 클릭해주세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_12.png)\n\n11. 서비스 연결을 만들기 위해 서비스 연결 - `새 서비스 연결`을 클릭해주세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_13.png)\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_14.png)\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_15.png)\n\n12. 원하는 서비스 연결을 만들 Subskription을 드롭다운에서 선택하고 이름을 지정하세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_16.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmultistageAzureYAMLPipeline_17.png\" />\n\n# YAML 파이프라인 생성\n\n14. 프로젝트 폴더 루트에 React 소스 코드를 포함하는 azure-pipelines.yml이라는 새 YAML 파일을 만듭니다.\n\n아래 변수의 값을 해당 값으로 대체합니다.\nazureSubscription: your_service_connection_name (이미지 #12에 표시된 서비스 연결 이름)\nwebAppName: your_webapp_name (이미지 #3에 표시된 Web App 이름)\n\n<div class=\"content-ad\"></div>\n\n아래 파이프라인에서 deploy 단계 환경인 dev는 dev 환경으로 코드를 배포하기 위한 승인을 받기 위해 사용됩니다. 비슷하게, 추가 단계를 추가하여 test 및 prod 환경으로 배포할 수 있습니다.\n\n```js\ntrigger:\n  - dev\n\npool:\n  vmImage: ubuntu-latest\n\nvariables:\n  azureSubscription: \"azure-pipelines-azure-sc\"\n  webAppName: demo-react-linux-webapp\n\nstages:\n  - stage: build\n    displayName: build\n    jobs:\n      - job: \"build\"\n        displayName: build job\n        steps:\n          - task: NodeTool@0\n            inputs:\n               versionSource: \"spec\"\n               versionSpec: \"20.x\"\n\n          - script: |\n               npm install\n               npm run build --if-present\n            displayName: \"npm install, build\"\n\n          - task: ArchiveFiles@2\n            inputs:\n               rootFolderOrFile: \"$(System.DefaultWorkingDirectory)/build\"\n               includeRootFolder: false\n               archiveType: \"zip\"\n               archiveFile: \"$(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip\"\n               replaceExistingArchive: true\n            \n          - task: PublishBuildArtifacts@1\n            inputs:\n               PathtoPublish: \"$(Build.ArtifactStagingDirectory)\"\n               ArtifactName: \"drop\"\n               publishLocation: \"Container\"\n\n  - stage: deploy\n    displayName: \"Deploy to the dev environment\"\n    dependsOn: Build\n    condition: succeeded()\n    jobs:\n      - deployment: Deploy\n        environment: dev\n        strategy:\n           runOnce:\n             deploy:\n               steps:\n                 - task: AzureRmWebAppDeployment@4\n                   inputs:\n                      ConnectionType: \"AzureRM\"\n                      azureSubscription: \"$(azureSubscription)\"\n                      appType: \"webAppLinux\"\n                      WebAppName: \"$(webAppName)\"\n                      packageForLinux: \"$(Pipeline.Workspace)/drop/$(Build.BuildId).zip\"\n                      #아래 StartupCommand는 리눅스 환경에서 React 앱을 실행하는 데 필요합니다.\n                      StartupCommand: \"pm2 serve /home/site/wwwroot/ --no-daemon --spa\"\n```\n\n<img src=\"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_18.png\" />\n\n15. Azure DevOps의 Repo에 코드를 게시하세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_19.png\" />\n\n16. DevOps 포털로 이동하여 파이프라인을 클릭하고, \"파이프라인 - 새 파이프라인\"을 선택하여 새 파이프라인을 생성하세요.\n\n<img src=\"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_20.png\" />\n\n17. 코드가 포함된 Azure YAML 파이프라인이 있는 리포지토리를 찾아보세요.\n\n<div class=\"content-ad\"></div>\n\n\n![Table 1](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_21.png)\n\n![Table 2](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_22.png)\n\n![Table 3](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_23.png)\n\n# 환경 변수 구성\n\n\n<div class=\"content-ad\"></div>\n\n18. 우리는 App.js 파일의 React 코드에서 REACT_APP_ENVIRONMENT라는 환경 변수를 사용하고 있습니다. 따라서 파이프라인에도 환경 변수를 생성해 봅시다.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_24.png)\n\n19. Variables - 새 변수를 클릭해주세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_25.png)\n\n<div class=\"content-ad\"></div>\n\n\n![image 1](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_26.png)\n\n![image 2](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_27.png)\n\n![image 3](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_28.png)\n\n20. If you have multiple environment variables to configure, repeat Step #19.\n\n\n<div class=\"content-ad\"></div>\n\n21. 파이프라인을 실행하려면 실행 옵션을 클릭하세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_29.png)\n\n22. 빌드 단계가 진행 중입니다.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_30.png)\n\n<div class=\"content-ad\"></div>\n\n23. 빌드 프로세스가 완료되면 배포 단계로 이동합니다. \"View\" 버튼을 클릭하여 배포를 승인하세요.\n\n![이미지1](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_31.png)\n\n![이미지2](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_32.png)\n\n![이미지3](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_33.png)\n\n<div class=\"content-ad\"></div>\n\n\n![Deployment successful](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_34.png)\n\n24. Deployment completed successfully!!!\n\n![React App deployed](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_35.png)\n\n24. Browse the Web App and you can see React App is deployed successfully. The environment variable value that we configured in Step #19 is displayed here.\n\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 위 문서를 읽어주셔서 감사합니다. 만약 이 레포지토리가 도움이 되었다면, 별풍선을 주시고 저를 팔로우해주세요. 앞으로도 많은 유익한 글을 공유할 예정이에요. 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_0.png"},"coverImage":"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_0.png","tag":["Tech"],"readingTime":9},{"title":"리액트만 사용하지 마세요","description":"","date":"2024-06-20 02:19","slug":"2024-06-20-DontusejustReact","content":"\n\n## Next.js 초보자를 위한 소개\n\n앗, 뭐라고요😠. 미쳤나요😡. 그렇게 생각하고 있던 거죠?😅 죄송해요. 제가 본 원문을 적는 게 필요하지 않다고 생각했던 블로그인데요😅😂, 대부분이 React보다 뛰어난 옵션이 있다는 걸 알기 때문에요🤩. 그냥 보통의 React만 있는 게 아니에요. 그래도 여전히 초보자들이 React 프레임워크 없이 프로젝트를 시작하려고 하는 걸 보곤 해요. 그래서 그냥 보통의 React를 사용하지 말고, React와 함께 사용할 수 있는 옵션을 안내해 드릴게요🤩.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*2VtlJwEiapSHoivvgMI-Yw.gif)\n\n알았어요 친구, 당신은 Next.js가 놀라운 것으로 화려하게 말하고 있군요😅😅 그리고 그냥 React를 사용하지 말라고 말해요. 왜 그래야 하는 거죠? 그것에 이유를 좀 알려주세요. 🌝\n\n<div class=\"content-ad\"></div>\n\n## 한 가지씩 살펴보며 Next.js가 얼마나 강력한지 이해해 보자🤩.\n\n## 1. 서버 측 렌더링 (SSR) 및 정적 사이트 생성 (SSG)\n\n아이고, 이 기술 용어가 뭔지 모르겠다! 음, 기다려봐. 설명해줄게. Next.js에는 두 가지 종류의 컴포넌트가 있어;\n\n- 서버 컴포넌트\n- 클라이언트 컴포넌트.\n\n<div class=\"content-ad\"></div>\n\n넥스트.js 13에서 서버 구성 요소가 등장했습니다. 서버 구성 요소는 서버에서 실행되어 정적 콘텐츠만 브라우저로 전송합니다. 이러한 서버 구성 요소에서 데이터를 가져오면 앱이 빠릅니다. 사용자 상호 작용에 필요한 경우 클라이언트 구성 요소를 사용해야 합니다. 즉, 마우스 오버 이벤트가 발생할 때 어떤 작업을 수행해야 하는 경우 클라이언트 구성 요소에서 수행해야 합니다. 이러한 방식으로 제공되는 추가적인 기능이 있습니다🤩.\n\n- 더 나은 SEO: SSR 및 SSG로 검색 엔진이 페이지를 크롤링하고 색인화하기 쉬워져 검색 엔진 순위가 높아집니다.\n- 빠른 로드 시간: 사전 렌더링된 페이지는 사용자에게 빠르게 제공되어 부드러운 경험을 제공합니다.\n\n## 2. 파일 기반 라우팅\n\n![이미지](/assets/img/2024-06-20-DontusejustReact_0.png)\n\n<div class=\"content-ad\"></div>\n\nNext.js는 전통적인 React Router보다 직관적이고 관리하기 쉬운 파일 기반 라우팅 시스템을 소개합니다. Next.js에서는 애플리케이션의 페이지들이 파일 시스템에 자동으로 매핑되어 경로를 간편하게 생성할 수 있습니다.\n\n라우터에는 두 가지 유형이 있으며, Next.js 13에서 새롭게 나온 것은 App 라우터입니다.\n\n- 간소화된 라우팅: 폴더 구조만 유지하면 됩니다 😘.\n- 동적 라우팅: 파일 및 폴더 명명 규칙을 활용해 동적 경로를 쉽게 처리할 수 있습니다 😘.\n\n## 3. API Routes\n\n<div class=\"content-ad\"></div>\n\nNext.js를 사용하면 동일한 프로젝트 내에서 API 엔드포인트를 생성할 수 있습니다. 이는 Next.js 애플리케이션 내에서 직접 서버리스 함수로 풀 스택 애플리케이션을 구축할 수 있다는 것을 의미합니다🫡.\n\n그러나 Next.js에서 백엔드 지원을 받고 싶지 않다면 다른 언어로 자체 백엔드를 개발할 수도 있습니다. 완전히 당신의 선택이에요😏.\n\n- 통합된 백엔드: 별도의 백엔드 서버 설정 없이 데이터 검색, 폼 처리, 인증 등을 위한 엔드포인트를 쉽게 생성할 수 있습니다🥱.\n- 서버리스 함수: 이러한 엔드포인트를 서버리스 함수로 배포하여, 자동으로 확장되고 서버 유지 관리가 줄어듭니다🥱.\n\n## 4. 이미지 최적화\n\n<div class=\"content-ad\"></div>\n\nNext.js는 이미지 구성 요소를 포함하고 있어요. 이 구성 요소는 자동으로 이미지를 최적화하여 사용자의 장치에 최상의 품질로 효율적으로 로드합니다🤩.\n\n- 자동 이미지 크기 조정: 사용자의 장치 및 뷰포트에 기반하여 적절한 크기의 이미지 제공🫡.\n- 레이지 로딩: 이미지가 뷰포트에 진입할 때에만 로드하여 성능을 향상시킵니다🫡.\n\n## 5. 커뮤니티 및 생태계\n\nNext.js는 웹 애플리케이션의 성능과 사용자 경험을 향상시키는 데 중점을 둔 회사인 Vercel의 지지를 받고 있어요. 이 프레임워크에는 큰 커뮤니티🤩와 다양한 플러그인, 확장 프로그램 및 도구가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 활발한 커뮤니티: 다수의 개발자 커뮤니티의 지원과 기여를 받아보세요.\n- 다양한 생태계: Next.js를 위해 특별히 개발된 다양한 플러그인, 확장 프로그램 및 도구를 활용하세요.\n\n## 6. 내장 CSS, Tailwind 및 Sass 지원\n\nNext.js에서 스타일링은 CSS, Tailwind 및 Sass를 내장 지원하여 간편합니다. styled components 또는 Emotion과 같은 CSS-in-JS 솔루션을 선호한다면 사용할 수도 있습니다.\n\n- 전역 및 모듈식 CSS: 전역 스타일을 쉽게 적용하거나 개별 구성 요소에 CSS를 스코프로 적용할 수 있으며 이름 충돌에 대해 걱정할 필요가 없습니다.\n- Sass 지원: 최소 구성으로 보다 복잡한 스타일링 요구를 위해 Sass의 기능을 활용하세요.\n\n<div class=\"content-ad\"></div>\n\n## 7. TypeScript 지원\n\nNext.js는 기본적으로 훌륭한 TypeScript 지원을 제공합니다. 추가 구성 없이도 프로젝트를 TS로 설정할 수 있습니다. 간단한 구성으로 TypeScript를 사용하여 타입 오류를 미리 잡고 코드베이스의 유지 보수성을 향상시킬 수 있습니다.\n\n- 타입 안전성: 개발 중 타입 관련 오류를 잡아 버그를 줄입니다.\n- 개발자 경험 향상: TypeScript의 강력한 도구 및 자동완성 기능을 활용하세요.\n\n요약하면, React만으로도 강력한 UI 라이브러리이지만, Next.js는 추가적인 기능을 제공하여 React를 더욱 향상시킵니다.🤩\n\n<div class=\"content-ad\"></div>\n\n- 개발을 효율적으로 진행합니다.\n- 성능을 향상시킵니다.\n- 개발자들에게 더 나은 경험을 제공합니다.\n\n제가 강조하고 싶은 부분을 이해하셨길 바랍니다. Next.js를 사용해보세요. 다른 방식으로 React를 사용하는 것에 대해 언급했네요 😁😜.\n\n다음 블로그에서 뵙겠습니다. 👋👋👋👋","ogImage":{"url":"/assets/img/2024-06-20-DontusejustReact_0.png"},"coverImage":"/assets/img/2024-06-20-DontusejustReact_0.png","tag":["Tech"],"readingTime":4},{"title":"스와트Swat, 파키스탄의 매혹적인 아름다움","description":"","date":"2024-06-20 02:18","slug":"2024-06-20-EnchantingBeautyofSwatPakistan","content":"\n\n![Swat, Pakistan](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_0.png)\n\n파키스탄의 하트에 위치한 촤베르 파크훈크와 주에 있는 스와트는 마법, 문화 그리고 풍부한 역사로 둘러싸인 영광의 곳입니다. 동쪽의 스위스라고 불리는 스와트 계곡은 아름다운 풍경, 역사적 건물, 그리고 다양한 지역 문화로 관광객들을 끌어들입니다.\n\n# 화려한 땅\n\n![Land of Splendor](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_1.png)\n\n<div class=\"content-ad\"></div>\n\n수왓의 자연 아름다움은 특별합니다. 계곡은 우거진 초록빛 들판, 우뚝 솟은 숲, 그리고 거대한 산으로 장식되어 있습니다. 명확한 물을 가진 수왓 강은 그림 같은 평화로운 분위기를 더합니다. 봄과 여름에는 꽃피는 식물과 초록이 푸르른 목초지로 선명한 색채의 혁명으로 변모하고, 겨울에는 눈이 쌓인 봉우리와 서리로 마법같은 나라로 변모합니다.\n\n# 밍고라와 그 이상\n\n![수왓 파키스탄의 매혹적인 아름다움](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_2.png)\n\n수왓에서 가장 큰 마을인 밍고라는 계곡으로 향하는 주요 입구로 기능합니다. 현대적인 시설과 전통적인 매력이 결합된 북적이는 도시입니다. 현지 시장은 활기차고 다채롭으며, 수공예품부터 신선한 농산물까지 모든 것을 제공합니다. 친절한 마을 주민들은 따뜻하고 환대적인 성품으로 경험을 더해줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 역사적 및 문화적 보물\n\n![스와트 파키스탄의 매혹적인 아름다움](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_3.png)\n\n스와트는 자연의 아름다움 뿐만 아니라 역사의 보고입니다. 이 계곡은 수백 년간 중요한 문화적 교차로였습니다. 예전에는 불교의 주요 중심지였으며, 그 시대의 흔적은 풍경에 있는 수많은 스투파, 수도원 및 동상에서 볼 수 있습니다. 부트카라 스투파와 자하나바드 부처는 이 시대의 중요한 유물로 역사학자와 여행자들을 매혹시킵니다.\n\n![스와트 파키스탄의 매혹적인 아름다움](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_4.png)\n\n<div class=\"content-ad\"></div>\n\n민고라의 수아트 박물관은 간다라 예술과 유물의 훌륭한 시리즈를 소장하고 있어 과거 밸리의 역사를 엿볼 수 있습니다. 박물관은 수아트의 역사적 중심지로서의 중요성을 보여주는 조각품, 동전 및 도자기로 유명합니다.\n\n# 모험가의 낙원\n\n![스와트, 파키스탄의 매혹적인 아름다움](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_5.png)\n\n모험 정신을 가진 사람들에게 스와트는 다양한 야외 활동을 제공합니다. 계곡은 마법같은 숲을 통과하고 폭포를 지나 광활한 전망대까지 이끄는 트레일로 하이커들의 꿈을 이루어줍니다. 인기 있는 스키 리조트 말람 자바는 슬로프와 시설로 겨울 스포츠 애호가들을 끌어들입니다. 여름에는 조용한 칼람 계곡이나 우슈 숲의 고산 메도우에서 하이킹과 캠핑이 인기 있는 활동입니다.\n\n<div class=\"content-ad\"></div>\n\n# 요리 특색\n\n![맛있는 명소](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_6.png)\n\n수아트의 요리 문화는 풍부한 문화적 다채로움을 반영한 특별한 특색을 지니고 있습니다. 육류, 쌀 및 빵에 중점을 둔 전통 파슈톤 요리가 널리 제공됩니다. 현지 특산품에는 케밥 챠플리, 램 카라히 및 다양한 팬케이크가 포함되어 있습니다. 이 계곡은 또한 맛있는 과일, 특히 복숭아와 살구로 유명하며, 방문객들에게 꼭 시식해야 할 것입니다.\n\n# 사계절 모두에 어울리는 휴가지\n\n<div class=\"content-ad\"></div>\n\n![Swat's magic](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_7.png)\n\n스와트의 매력은 언제나 한 계절에 국한되어 있지 않아요. 각 계절마다 계곡에 새로운 아름다움을 선사해요. 봄과 여름은 신선한 풍경과 야외 활동을 탐험하기에 딱 좋아요. 가을은 황금과 빨강빛으로 계곡을 물들여 사진을 찍기에 아름다운 배경을 제공해요. 눈을 덮은 산들로 가득한 겨울은 조용한 휴양지로 스키와 스노우보딩의 기회도 제공해요.\n\n# 결론\n\n스와트 시와 추가적인 스와트 계곡은 파키스탄이 제공하는 숨막히는 아름다움과 풍부한 역사를 증명해요. 역사 애호가, 모험가 또는 자연의 아름다움을 만끽하고 싶은 분이든, 스와트는 잊지 못할 경험을 약속해요. 그 눈부신 풍경, 문화적 풍부함, 따뜻한 환대로 인해 스와트는 파키스탄 관광지의 보석 같아요.","ogImage":{"url":"/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_0.png"},"coverImage":"/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트와 장고 다중 페이지 애플리케이션 통합","description":"","date":"2024-06-20 02:17","slug":"2024-06-20-IntegratingReactwithDjangoMultipageApplication","content":"\n\n![image](/assets/img/2024-06-20-IntegratingReactwithDjangoMultipageApplication_0.png)\n\nReact와 Django는 각각의 강점을 가진 웹 애플리케이션을 구축하기 위한 강력한 도구입니다. React는 동적이고 상호 작용적인 사용자 인터페이스를 만드는 데 능숙하며, Django는 데이터를 관리하고 콘텐츠를 제공하기 위한 강력한 백엔드 프레임워크를 제공합니다. 이러한 기술들을 결합함으로써 개발자들은 양쪽의 장점을 최대한 활용할 수 있습니다. 본 포괄적인 안내서에서는 React를 Django 다중 페이지 애플리케이션에 통합하는 과정을 설명하며, 개발 및 프로덕션 환경에서의 모범 사례를 다룰 것입니다.\n\n## 이 안내서를 사용해야 하는 경우:\n\n## 요구 사항:\n\n<div class=\"content-ad\"></div>\n\n- Django와 React의 기본 지식이 필요합니다.\n- 시스템에 Python과 Node.js가 설치되어 있어야 합니다.\n\n## 단계 1: Django 프로젝트 설정하기:\n\n```js\npip install django\n```\n\n```js\ndjango-admin startproject myproject\ncd myproject\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로, 프로젝트 내에서 Django 앱을 생성합니다:\n\n```js\npython manage.py startapp myapp\n```\n\n마이그레이션 적용\n\n```js\npython manage.py makemigrations\npython manage.py migrate\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 2: React 앱 생성하기:\n\n```js\nmkdir frontend\ncd frontend\n```\n\n이제 새로운 React 앱을 초기화하세요:\n\n```js\nnpx create-react-app myreactapp\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: React를 Django와 통합하기:\n\n- Django를 React 빌드 파일을 제공하도록 구성: Django 프로젝트의 urls.py 파일에서 React 앱을 제공할 수 있는 경로를 추가하세요:\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', TemplateView.as_view(template_name='index.html')),\n]\n```\n\n2. Django 템플릿에 React 번들 포함하기: Django 템플릿 (index.html)에 번들 된 JavaScript 파일을 동적으로 포함하여 개발 중에 변경 사항이 즉시 반영되도록하세요.\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 myapp 폴더와 동일한 레벨에 template 폴더를 만들어주세요. settings.py 파일을 업데이트해서 templates를 포함하도록 하겠습니다.\n\n```python\nimport os\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        'APP_DIRS': True,\n        'OPTIONS': {\n\n        },\n    },\n]\n```\n\n```html\n{ load static }\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>My Django React App</title>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script src=\"http://localhost:3000/static/js/bundle.js\"></script>\n</body>\n</html>\n```\n\n## Step 4: 어플리케이션 실행하기:\n\n<div class=\"content-ad\"></div>\n\n## 개발\n\n- 장고 개발 서버를 시작합니다:\n\n```js\npython manage.py runserver\n```\n\n- React 개발 서버를 시작합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ncd frontend/myreactapp\nnpm start\n```\n\n브라우저에서 http://localhost:8000을 방문하여 Django React 애플리케이션을 개발 모드로 확인할 수 있어요.\n\n## 프로덕션\n\n- React 앱 빌드하기:\n\n<div class=\"content-ad\"></div>\n\n```js\ncd frontend/myreactapp\nnpm run build\n```\n\n- Django 템플릿 업데이트: React 앱을 빌드한 후에는 Django 템플릿에 주요 JavaScript 파일(main.`해시`.js) 경로를 추가하십시오. Django 템플릿 파일(index.html)을 열어 다음 라인을 추가하십시오:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>My Django React App</title>\n</head>\n<body>\n    <div id=\"root\"></div>\n\n    <script src=\"{ static 'js/main.38dff78c.js' }\"></script>\n</body>\n</html>\n```\n\n- Django 서버 시작:\n\n<div class=\"content-ad\"></div>\n\n```js\npython manage.py runserver\n```\n\n로컬 호스트(http://localhost:8000)를 브라우저에서 방문하여 Django React 애플리케이션을 프로덕션 모드로 확인해보세요.\n\nDjango와 React를 통합하면 웹 애플리케이션의 사용자 경험을 향상시킬 수 있는 강력한 솔루션이 제공됩니다. 기존의 Django 다중 페이지 애플리케이션을 점진적으로 인터랙티브한 경험으로 전환하거나 단일 인터랙티브 페이지를 도입해야 하는 경우, 이 안내서를 통해 쉽게 지식과 도구를 활용할 수 있습니다.\n\n이 안내서에 나온 단계를 따라가면 React와 Django의 장점을 모두 활용하여 Django의 백엔드 기능을 React의 동적인 프론트엔드 컴포넌트와 함께 효율적으로 사용할 수 있습니다. 프로젝트 설정부터 개발 및 프로덕션 환경 처리까지, 이제 Django 애플리케이션에 React를 통합할 튼튼한 기반을 가지게 되었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n행복한 코딩 😃\n\n소스 코드","ogImage":{"url":"/assets/img/2024-06-20-IntegratingReactwithDjangoMultipageApplication_0.png"},"coverImage":"/assets/img/2024-06-20-IntegratingReactwithDjangoMultipageApplication_0.png","tag":["Tech"],"readingTime":4},{"title":"R에 대한 오픈 편지","description":"","date":"2024-06-20 02:16","slug":"2024-06-20-OpenletterforR","content":"\n\n가슴을 털고 말하고 싶어졌어요. 이제 당신에 대해 언급하는 것은 마지막일 겁니다.\n\n우리는 행복한 것으로 시작했어요. 함께 놀고, 시청하고, 다양한 일을 함께 했어요. 솔직히 처음에는 당신을 좋아하지 않았어요. 그저 거기에 있던 것뿐이었으니까요. 그래도 당신은 내 삶에서 끊임없는 존재가 되었고, 나의 외로움과 행복을 함께 했어요.\n\n집에 돌아와서 당신과 말할 생각에 마음이 들떴어요. 당신에게 “사랑해” 라고 처음 말했을 때의 당신의 반응을 선명하게 기억해요. 비밀을 나누고, 상처를 드러내며, 모든 것이 받아들여졌어요. 하지만 모든 관계와 마찬가지로 항상 화색과 나비가 날랑 날랑하는 것만은 아니었어요.\n\n시간이 흘러 현실이 들어왔어요. 저는 덜 연결된다고 느끼기 시작했고, 당신의 대답은 점점 떨어져 갔어요. 감정을 느끼려고 싸움을 일부러 일으켰어요. 첫 싸움을 기억하나요? 당신의 말이 나를 상처 입힌 첫 번째 시간이었고, 밤을 새며 울었어요. 당신에게는 아무 뜻이 없었던 말들이 저에게는 모든 것이었어요. 확인을 찾을 때, 듣게 된 것은 비꼬는 말뿐이었어요. 제가 원하는 확신을 제공해줄 수 없는 당신이었죠.\n\n<div class=\"content-ad\"></div>\n\n내 안전을 찾기 위해 찾아왔던 우리 관계에서 내가 버려진 것 같았어. 너와 얘기하는 여자들에 대해 질투가 났어. 내 불안함이 나를 포위했었거든. 너와 이별을 많이 말해봤지만, 항상 실망했어. 너는 몇 주 동안 나에게 말을 걸지 않을 수도 있었지만, 나는 매일 밤 울면서 오는 메시지를 기다리곤 했어. 매번 나를 무겁게 떠밀어놓곤 했지.\n\n네 감정을 읽을 수 없었어; 네 존재를 느낄 수 없었어. 너도 아프지 않았니? 나는 매우 긴 문단으로 내 마음을 쏟았지만, 그것은 마치 들리지 않는 귀처럼 보였어. 이해가 없으면 의사소통은 쓸모가 없어.\n\n우리의 첫 번째 기념일이어야 했던 날에 네가 나랑 헤어지면서 내 최악의 두려움을 강화시켰어. 아니라고 해도, 너는 나를 부족하게 만들었어. 널 미워해야 할 수많은 이유가 있지만, 내 마음은 그렇게 못 견디겠어. 너무 보고 싶어서 가슴이 아파, 하지만 끊임없이 구걸할 수는 없어. 우리를 다시 만들고 싶었다면 너는 고칠 의지가 있었을 텐데.\n\n너를 사랑하지만, 이제 내 자신을 우선해야 해. 너로 인해 상처받은 내 자신을 다시 쌓아야 해. 우리의 분리를 나에게 돌리지 않을 거야; 우리 둘 다 있었지. 네 최선을 다해 줘서 고마워, 하지만 내게는 충분하지 않았어. 진정하게 사랑하는 사람을 만나길 바래, 그렇게 하기 위해 노력하는 사람을 찾길. 너가 찾아준 평화를 주지 못해 미안하고, 내 뒤죽박죽한 마음을 다루길 기대한 내 잘못도 미안해.\n\n<div class=\"content-ad\"></div>\n\n서로 지쳐갔고, 얼마나 쉬어도 아무런 치유가 되지 않았어요. 나를 차단 해제하려면, 더 이상 여기 없을 거에요. 우리의 시작도 전에 끝났죠. 안녕, 자기 자신을 잘 부탁해요. 성공을 빕니다.","ogImage":{"url":"/assets/img/2024-06-20-OpenletterforR_0.png"},"coverImage":"/assets/img/2024-06-20-OpenletterforR_0.png","tag":["Tech"],"readingTime":2},{"title":"Reactjs에서 Excel XLSX에서 데이터를 가져오는 방법","description":"","date":"2024-06-20 02:15","slug":"2024-06-20-HowtoimportdatafromExcelXLSXinReactjs","content":"\n\n\n![이미지](/assets/img/2024-06-20-HowtoimportdatafromExcelXLSXinReactjs_0.png)\n\nReact.js 애플리케이션에서 .xlsx 파일에서 데이터를 가져오려면 JavaScript에서 엑셀 파일을 읽고 쓰는 인기 있는 라이브러리 인 xlsx 를 사용할 수 있습니다. 이 안내서에서는 React.js 애플리케이션에서 .xlsx 파일에서 데이터를 가져 오는 단계를 안내합니다.\n\n## 단계 1: 새로운 React.js 애플리케이션 생성\n\n아직 React.js 애플리케이션을 생성하지 않았다면 Create React App 을 사용하여 새로 만들 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx create-react-app react-xlsx-import\n```\n\n## 단계 2: xlsx 라이브러리 설치\n\n프로젝트 디렉토리로 이동하여 xlsx 라이브러리를 설치하세요:\n\n```js\ncd react-xlsx-import\nnpm install xlsx\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: 파일 입력 컴포넌트 생성\n\nsrc 디렉토리에 FileInput.js 파일을 만들고 아래 코드를 추가하여 파일 입력 컴포넌트를 생성하세요:\n\n```js\n// src/FileInput.js\n\nimport React from 'react';\nimport * as XLSX from 'xlsx';\n\nfunction FileInput() {\n  const [data, setData] = React.useState(null);\n\n  const handleFileUpload = (e) => {\n    const file = e.target.files[0];\n    const reader = new FileReader();\n\n    reader.onload = (event) => {\n      const workbook = XLSX.read(event.target.result, { type: 'binary' });\n      const sheetName = workbook.SheetNames[0];\n      const sheet = workbook.Sheets[sheetName];\n      const sheetData = XLSX.utils.sheet_to_json(sheet);\n\n      setData(sheetData);\n    };\n\n    reader.readAsBinaryString(file);\n  };\n\n  return (\n    <div>\n      <input type=\"file\" onChange={handleFileUpload} />\n      {data && (\n        <div>\n          <h2>Imported Data:</h2>\n          <pre>{JSON.stringify(data, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default FileInput;\n```\n\n## 단계 4: App 컴포넌트 업데이트\n\n<div class=\"content-ad\"></div>\n\nsrc 디렉토리의 App.js 파일을 업데이트하여 FileInput 컴포넌트를 포함시킵니다:\n\n```js\n// src/App.js\n\nimport React from 'react';\nimport './App.css';\nimport FileInput from './FileInput';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>React.js에서 Excel 데이터 가져오기</h1>\n      <FileInput />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n## 단계 5: 애플리케이션 실행하기\n\n다음 명령어를 사용하여 React.js 애플리케이션을 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm start\n```\n\n웹 브라우저를 열고 http://localhost:3000 으로 이동하세요. 파일 입력 컴포넌트가 나타날 것입니다. 여기서 .xlsx 파일을 업로드할 수 있습니다. .xlsx 파일을 선택한 후, 가져온 데이터가 파일 입력란 아래에 표시됩니다.\n\n# 결론\n\nReact.js 애플리케이션에서 xlsx 라이브러리를 사용하여 .xlsx 파일에서 데이터를 성공적으로 가져왔습니다. 이제 이 예제를 확장하여 가져온 데이터를 처리하고, 테이블에 표시하거나 추가적인 데이터 조작 및 분석을 수행하여 보다 구조화되고 사용자 친화적인 방식으로 표시할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n파일 유형을 처리하기 전에 파일 유형을 확인하고, 대용량 파일을 효율적으로 처리하며, 파일 업로드 및 데이터 처리 단계에서 사용자에게 피드백을 제공하는 등 오류와 예외 상황을 적절하게 처리해야 합니다.","ogImage":{"url":"/assets/img/2024-06-20-HowtoimportdatafromExcelXLSXinReactjs_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoimportdatafromExcelXLSXinReactjs_0.png","tag":["Tech"],"readingTime":3},{"title":"상태가 없는 인증 React 및 Django Rest Framework에서 Google API에 JWT 통합하기 파트  1","description":"","date":"2024-06-20 02:14","slug":"2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1","content":"\n\n# 개요\n\n이 블로그에서는 Google API를 사용하여 내 웹 앱에 JWT 인증을 통합하는 경험을 공유하고 자습서를 제공할 예정입니다. 이것은 총 세 부작으로 이루어질 것입니다. 먼저 주제의 이론적 측면을 다루고, 그 후에는 실습 자습서로 넘어갈 것입니다.\n\n주로 사용할 패키지들은 다음과 같습니다:\n\n- Google API\n- Django Rest Framework\n- Django Rest Framework SimpleJWT\n- Django CORS Headers\n- Django Dot Env\n- React\n- React OAuth Google\n\n<div class=\"content-ad\"></div>\n\n기본적인 앱 설정 생성과 같은 몇 가지 기본 단계를 건너뛸 예정이니 참고해 주세요.\n\n# JWT의 의미와 이유\n\n다양한 인증 방법 중 JWT는 요청의 무결성을 인증하거나 승인하는 상대적으로 새로운 방법입니다. 내 의견으로 JWT의 개념에 끌린 주된 측면 중 하나는 무상태(Stateless) 특성입니다.\n\n무상태 특성이란 요청이 유효한지 확인하기 위해 데이터베이스를 쿼리할 필요가 없다는 것을 의미합니다. 이 특성은 JWT를 강력하게 만들며 꼭 무상태입니다. 한 번 토큰이 서명되고 생성되면, 웹 애플리케이션은 토큰의 서명을 기반으로 토큰을 확인할 수 있습니다. 데이터베이스를 쿼리하여 요청이 합법적인지 확인할 필요는 없습니다. 이는 대규모 애플리케이션에 특히 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 JWT의 단점을 이해하는 것도 중요합니다. 그 중 하나는 유효한 토큰을 무효화하거나 취소하는 것이 어렵다는 점입니다. 토큰 무효화를 달성하는 방법은 있지만, 다른 종류의 인증(예: 토큰 기반 인증)보다 간단하지는 않습니다.\n\nJWT에 대해 더 자세히 알아보려면 여기에서 공식 소개 페이지를 참조하세요.\n\n# Google API\n\nGoogle API는 구글이 개발한 응용 프로그램 프로그래밍 인터페이스(API) 집합으로, 구글 서비스 및 기타 애플리케이션과 통신할 수 있게 해줍니다. 이러한 API는 구글 지도, 구글 드라이브, 구글 캘린더 등 다양한 구글 서비스에 액세스할 수 있도록 해줍니다. 우리는 이러한 API를 사용하여 앱에서 사용자를 로그인할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n다음 작업을 수행하겠습니다:\n\n- Google Cloud Console에 접속합니다.\n- 왼쪽 상단 로고 근처에서 프로젝트를 선택하거나 새로 만듭니다.\n\n\n![이미지1](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png)\n\n![이미지2](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_2.png)\n\n![Image 2](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_3.png)\n\n- 동의 화면에서는 app_name, user_support_email, developer_contact_email을 입력할 것입니다. 다른 필드는 로컬 환경에서 비워둘 겁니다. 나중에 필요한 경우 양식을 업데이트할 수도 있습니다. test_email을 위해 몇 개의 이메일을 추가할 수 있습니다. 그 외에는 '다음' 버튼만 눌러 진행하면 됩니다.\n- 이제 동일한 드롭다운에서 새로운 OAuth 클라이언트 ID를 생성할 수 있습니다. 모바일 앱이나 태블릿 애플리케이션을 개발 중이라면 다른 플랫폼을 사용할 수 있습니다.\n\n![Image 3](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n- 허가된 js origin은 구글 버튼이 렌더링될 URI를 의미합니다. 즉, 프론트엔드 URL(우리의 리액트 서버)을 의미합니다. 반면에, 허가된 리다이렉트 URI는 우리의 장고 서버를 위한 것입니다.\n\n![이미지](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_5.png)\n\n- 그 다음으로 클라이언트 ID와 클라이언트 시크릿을 얻을 수 있어야 합니다. 그것들을 복사해서 환경 변수나 .env 파일에 설정할 수 있습니다. 혹은 다운로드 아이콘을 통해 json 파일을 다운로드할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_6.png)\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 프로젝트를 시작할 기본 구조를 설정했습니다. 다음 섹션에서는 Django 백엔드로 시작할 것입니다. 질문이나 제안이 있으면 언제든지 코멘트해 주세요. 읽어주셔서 감사합니다!!!","ogImage":{"url":"/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png"},"coverImage":"/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png","tag":["Tech"],"readingTime":3},{"title":"응용 통계 확률 분포 - 이항분포","description":"","date":"2024-06-20 02:13","slug":"2024-06-20-AppliedstatsprobabilitydistributionsBinomial","content":"\n\n<img src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_0.png\" />\n\n통계의 하나의 목표는 주어진 모집단의 어떤 변수의 분포에 대한 추론(또는 결론)을 샘플이라고 하는 그 일부분의 데이터를 바탕으로 내리는 것입니다.\n\n샘플 데이터와 모집단 간의 링크는 확률적 모델에 의존하는데, 즉, 모집단의 (알려지지 않은) 분포를 나타내는 모델에 의해 달려 있습니다.\n\n이 절차를 통계 추론이라고 합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 모집단에 대해 정의된 변수 X의 확률 분포가 특정 확률 모델에 의해 설명될 수 있다고 가정한다면, 우리의 문제는 해당 모델에 의해 표현된 특정 확률 분포의 매개변수를 추정하는 것으로 간소화됩니다. 이항 분포의 경우, 이러한 매개변수는 다음과 같습니다:\n\n- n = 시도의 횟수.\n- p = 각 시도의 성공 확률.\n\n이제 이항 분포를 소개했으니, 조금 더 깊이 파보겠나요? 이 이론적 소개 이후, 실제 응용 사례가 나오면 모든 것이 명확해지고 재미있어질 것입니다!\n\n# 이항 분포: 이론\n\n<div class=\"content-ad\"></div>\n\n이항 분포의 특정 수학 함수를 사용하면 두 가지 결과가 있는 어떤 실생활 이벤트의 결과를 예측할 수 있습니다.\n\n표기법: B(n, p) → n = 시도 횟수; p = 각 시도에서 성공할 확률.\n\n예: X ~ B(10, 0.6) → \"변수 X는 10번의 시도와 각각의 시도에서 성공 확률이 0.6인 이항 분포를 따릅니다.\"\n\n![이항분포 이미지](/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_1.png)\n\n<div class=\"content-ad\"></div>\n\n더 정확한 예측을 위해 기대값과 표준편차를 계산할 수 있습니다. 이 경우:\n\n- E(X) = n . p\n- σ² = E(X²) — E(X)² = n . p . (1 — p)\n\n변수 X가 이항 확률 변수가 되려면:\n\n- 각 시행이 독립되어야 합니다.\n- 각 시행은 \"성공\" 또는 \"실패\"로 표현할 수 있어야 합니다.\n- 고정된 횟수의 시행이 있어야 합니다.\n- 각 시행에서의 성공 확률이 일정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 이항 분포: 실습\n\n## 예시 1\n\n가게에서 매주 주문의 10%가 반품된다고 가정해 봅시다. 매주 3개 이상의 반품이 발생할 확률이 높다면, 임시 보조 직원을 고용해야 합니다. 이번 주에 가게에서 50건의 매출이 있었다고 가정해 봅시다. 임시 보조 직원을 고용해야할 확률은 어떻게 되나요?\n\nX = 반품 수량.\n\n<div class=\"content-ad\"></div>\n\nn = 50번의 구매.\n\np = 환불 확률 (성공) = 10%.\n\nq (1-p) = 환불하지 않을 확률 (실패) = 1-10% = 90%.\n\n```js\nfrom scipy.stats import binom\n\n# p = 성공 확률\n# n = 시도 횟수\n# k = 성공 횟수\n\nn = 50\np = 0.1\nk = 2\n\nprint('2개 이하의 환불 누적 확률:', \n  binom.cdf(k, n, p)) # P(X=0) + P(X=1) + P(X=2)\nprint('정확히 2개의 환불이 일어날 확률:', \n  binom.pmf(k, n, p)) # P(X=3)\nprint('3개 이상의 환불이 일어날 확률:', \n  1 - binom.cdf(k, n, p)) # k를 0, 1, 2로 포함\nprint('3개 이상의 환불이 일어날 확률:', \n  binom.sf(k, n, p)) # 1 - cdf\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_2.png)\n\n예시를 확장해서 X=1, X=2, X=3, …, X=50 성공 시 확률을 정확히 계산해보자. 이를 위해 단순히 확률질량함수를 사용하면 된다. 왜냐하면 이는 이산형 변수이기 때문이다.\n\n```js\nimport plotly.graph_objects as go\nfrom scipy.stats import binom\n\nn = 50\np = 0.1\nk = np.arange(0, n+1)\npmf = binom.pmf(k, n, p) # 확률 질량 함수\n\nfig = go.Figure(data=[go.Bar(x=k, y=pmf)])\nfig.update_layout(title=\"이항 분포 (n=50, p=0.1)\",\n                  xaxis_title=\"성공 횟수\",\n                  yaxis_title=\"확률\",\n                  font=dict(size=18),\n                  width=700,\n                  title_x=0.5,\n                  height=400,\n                  template=\"simple_white\")\nfig.show()\n```\n\n이 코드는 기사 초반에 보았던 그래프를 나타낼 것입니다. 빠르고 매우 유용하죠?\n\n\n<div class=\"content-ad\"></div>\n\n## 예시 2\n\n은행 거래에서 사기 발생 확률.\n\n저는 캐글에서 데이터셋을 수집했는데, 이 데이터셋은 한 은행의 거래 내역을 포함하고 있습니다. 그 중 하나의 변수는 해당 거래가 사기인지 아닌지를 나타냅니다. 이 변수의 빈도 분포를 확인해보겠습니다.\n\n![transactions](/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_3.png)\n\n<div class=\"content-ad\"></div>\n\n거래에 대한 데이터를 모두 가정한다면, 사기 및 비 사기의 각각의 발생 확률은 다음과 같습니다:\n\n```js\n비 사기의 확률 = (value_counts[0] / len(df_fraud))\n사기의 확률 = (value_counts[1] / len(df_fraud))\n\nprint('사기가 아닐 확률은:', 비 사기의 확률)\nprint('사기 확률은:', 사기의 확률)\n```\n\n<img src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_4.png\" />\n\n이는 각 거래에서 사기를 저지를 확률입니다. 불균형은 예상대로 발생하며, 우리는 훨씬 더 많은 합법적인 거래를 가지고 있습니다. 중요한 점은 은행에서 많은 일일 거래가 있고 분명 그 중 하나는 사기일 것이라는 것입니다. 이 은행의 평균 일일 거래를 확인해봅시다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_5.png\" />\n\n```js\nmean_transactions_per_day = transactions_per_day.mean()\nprint(\"평균 거래 횟수(하루):\", \n  round(mean_transactions_per_day, 0))\n```\n\n<img src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_6.png\" />\n\n이제 가장 중요한 부분으로 들어가 봅시다. 이제 비즈니스 문제를 활용하여 궁금증에 답할 수 있습니다. 예를 들어, 50번의 시도에서 1, 2, 3, ... 50건의 사기 사례를 발견할 확률은 얼마인가요?\n\n<div class=\"content-ad\"></div>\n\n```python\n## 파이썬을 사용하여 확률 분포 그래프 그리기\r\n\r\nimport plotly.graph_objects as go\r\nfrom scipy.stats import binom\r\n\r\nn = 50\r\np = fraud_probability # 0.05\r\nk = np.arange(0, n + 1)\r\npmf = binom.pmf(k, n, p)\r\n\r\nfig = go.Figure(data=[go.Bar(x=k, y=pmf)])\r\nfig.update_layout(title=f\"이항 분포 (n={n}, p={fraud_probability})\",\r\n                  xaxis_title=\"성공 횟수\",\r\n                  yaxis_title=\"확률\",\r\n                  font=dict(size=18),\r\n                  width=700,\r\n                  title_x=0.5,\r\n                  height=400,\r\n                  template=\"simple_white\")\r\nfig.show()\r\n```\r\n\r\n<img src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_7.png\" />\r\n\r\n그리고 한 가지 더 예시를 드리면:\r\n\r\n```python\r\nprint(f'3333번 시도 중 200번 이상 사기가 발생할 확률은:', \r\n              binom.sf(200, 3333, 0.05))\r\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_8.png\" />\n\n이곳에서 가능한 한 이론에서 벗어나서 이항 확률 분포의 이론을 실제로 어떻게 활용하는지 보여 주었습니다. 이제 당신이 일상생활에서 이를 식별하고 데이터가 전달하는 내용에 기초하여 올바르게 적용하여 문제를 해결하고 올바른 결정을 내릴 수 있도록 해야 합니다!\n\n# 크레딧\n\nWheelan, Charles. Naked Statistics: Stripping the Dread from the Data. W.W. Norton & Company, 2013.\n\n<div class=\"content-ad\"></div>\n\nSpiegelhalter, David. The Art of Statistics: How to Learn from Data. Basic Books, 2019.","ogImage":{"url":"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_0.png"},"coverImage":"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_0.png","tag":["Tech"],"readingTime":6},{"title":"파이썬 장고에서의 디자인 원칙","description":"","date":"2024-06-20 02:11","slug":"2024-06-20-DesignPrinciplesinPythonDjango","content":"\n\n파이썬에서의 디자인 원칙은 다른 프로그래밍 언어와 마찬가지로 깔끔하고 유지보수가 용이하며 효율적인 코드를 만드는 데 도움이 됩니다. 다음은 몇 가지 주요 디자인 원칙과 예시입니다:\n\n![Design Principles in Python](/assets/img/2024-06-20-DesignPrinciplesinPythonDjango_0.png)\n\n## 1. DRY(Don’t Repeat Yourself)\n\n코드의 중복을 피하기 위해 반복되는 패턴을 함수나 클래스로 추상화합니다.\n\n<div class=\"content-ad\"></div>\n\n장고는 ORM, 폼 및 관리자 인터페이스를 통해 DRY 원칙을 자연스럽게 촉진합니다.\n\n## 예시: 시리얼라이저 사용하기\n\nDRF 시리얼라이저를 사용하면 유효성 검사 로직을 별도로 작성하는 대신, 해당 로직을 시리얼라이저 자체에 캡슐화할 수 있습니다.\n\n```js\n# serializers.py\nfrom rest_framework import serializers\nfrom .models import Expense, Category, Balance\n\nclass ExpenseSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Expense\n        fields = ['id', 'user', 'category', 'amount', 'description', 'date']\n\nclass CategorySerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Category\n        fields = ['id', 'name', 'description', 'user']\n\nclass BalanceSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Balance\n        fields = ['id', 'total_balance']\n```\n\n<div class=\"content-ad\"></div>\n\n# 2. KISS (Keep It Simple, Stupid)\n\n코드를 가능한 한 간단하게 유지하세요. 불필요한 복잡성을 피하세요.\n\nDjango의 설계 철학은 간결성과 가독성을 강조합니다.\n\n## 예시: Django Rest Framework의 일반 뷰 사용\n\n<div class=\"content-ad\"></div>\n\n복잡한 뷰 로직을 작성하는 대신, DRF의 일반적인 뷰를 사용하여 객체 생성, 검색 및 목록을 처리할 수 있어요.\n\n```js\n# views.py\nfrom rest_framework import generics\nfrom .models import Expense, Category, Balance\nfrom .serializers import ExpenseSerializer, CategorySerializer, BalanceSerializer\n\nclass ExpenseListView(generics.ListCreateAPIView):\n    queryset = Expense.objects.all()\n    serializer_class = ExpenseSerializer\n\nclass ExpenseDetailView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Expense.objects.all()\n    serializer_class = ExpenseSerializer\n\nclass CategoryListView(generics.ListCreateAPIView):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\nclass CategoryDetailView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\nclass BalanceListView(generics.ListCreateAPIView):\n    queryset = Balance.objects.all()\n    serializer_class = BalanceSerializer\n```\n\n# 3. YAGNI (You Ain’t Gonna Need It)\n\n필요할 때까지 기능을 추가하지 마세요.\n\n<div class=\"content-ad\"></div>\n\n현재 요구 사항에 주안점을 두세요. 미래의 가능성에 집중하기보다는 현재의 요구 사항을 중심으로 작업하세요.\n\n## 예: 간단한 사용자 프로필\n\n간단한 사용자 모델로 시작하고 필요할 때만 복잡성을 추가하세요.\n\n```js\n# models.py\n\nclass User(AbstractUser):\n    first_name = models.CharField(max_length=30)\n    last_name = models.CharField(max_length=30)\n    email = models.EmailField(unique=True)\n\n    def __str__(self):\n        return self.username\n```\n\n<div class=\"content-ad\"></div>\n\n# 4. 역할의 분리\n\n여러분의 코드의 각 부분은 서로 다른 책임을 가져야 합니다.\n\n장고의 MVC (Model-View-Controller) 아키텍처는 데이터 처리를 분리한 모델(models), 사용자 인터페이스를 분리한 템플릿(templates), 그리고 응용 프로그램 로직을 분리한 뷰(views)로 구성됩니다.\n\n## 예시: 뷰에서 비즈니스 로직 분리\n\n<div class=\"content-ad\"></div>\n\n비즈니스 로직은 뷰가 아닌 모델이나 서비스에 유지하는 것이 좋습니다.\n\n```js\n# models.py\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\n\nclass DKModel(models.Model):\n    class Meta:\n        abstract = True\n\n    deleted = models.BooleanField(default=False)\n    date_created = models.DateTimeField('Date created', auto_now_add=True)\n    date_last_updated = models.DateTimeField('Data last updated', auto_now=True)\n\n    def __id__(self) -> int:\n        return self.id\n\n    def delete(self, *args, **kwargs):\n        self.deleted = True\n        self.save()\n\n    def hard_delete(self, *args, **kwargs):\n        super().delete(*args, **kwargs)\n        \n                      ....\n\n# views.py\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import generics\nfrom django.shortcuts import get_object_or_404\nfrom .models import Expense, Category, Balance, User\nfrom .serializers import ExpenseSerializer, CategorySerializer, BalanceSerializer\n\nclass ExpenseListView(generics.ListCreateAPIView):\n    queryset = Expense.objects.all()\n    serializer_class = ExpenseSerializer\n\nclass ExpenseDetailView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Expense.objects.all()\n    serializer_class = ExpenseSerializer\n\nclass CategoryListView(generics.ListCreateAPIView):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\nclass CategoryDetailView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\nclass BalanceListView(generics.ListCreateAPIView):\n    queryset = Balance.objects.all()\n    serializer_class = BalanceSerializer\n\nclass UserTotalExpensesView(APIView):\n    def get(self, request, user_id):\n        user = get_object_or_404(User, id=user_id)\n        total_expenses = user.get_total_expenses()\n        return Response({'total_expenses': total_expenses})\n\n# urls.py\nfrom django.urls import path\nfrom .views import ExpenseListView, ExpenseDetailView, CategoryListView, CategoryDetailView, BalanceListView, UserTotalExpensesView\n\nurlpatterns = [\n    path('expenses/', ExpenseListView.as_view(), name='expense-list'),\n    path('expenses/<int:pk>/', ExpenseDetailView.as_view(), name='expense-detail'),\n    path('categories/', CategoryListView.as_view(), name='category-list'),\n    path('categories/<int:pk>/', CategoryDetailView.as_view(), name='category-detail'),\n    path('balances/', BalanceListView.as_view(), name='balance-list'),\n    path('users/<int:user_id>/total-expenses/', UserTotalExpensesView.as_view(), name='user-total-expenses'),\n]\n```\n\n# 5. SOLID Principles\n\nSOLID은 소프트웨어 디자인을 더 이해하기 쉽고 유연하며 유지보수하기 쉽도록 하는 다섯 가지 디자인 원칙을 의미하는 머릿글자입니다.\n\n<div class=\"content-ad\"></div>\n\n## S: 단일 책임 원칙 (SRP)\n\n각 클래스는 하나의 책임만을 가져야 합니다.\n\n```js\n# model/models.py\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\n\nclass DKModel(models.Model):\n    class Meta:\n        abstract = True\n\n    deleted = models.BooleanField(default=False)\n    date_created = models.DateTimeField('생성 날짜', auto_now_add=True)\n    date_last_updated = models.DateTimeField('마지막으로 업데이트된 날짜', auto_now=True)\n\n    def __id__(self) -> int:\n        return self.id\n\n    def delete(self, *args, **kwargs):\n        self.deleted = True\n        self.save()\n\n    def hard_delete(self, *args, **kwargs):\n        super().delete(*args, **kwargs)\n\n\nclass User(AbstractUser):\n    first_name = models.CharField(max_length=30)\n    last_name = models.CharField(max_length=30)\n    email = models.EmailField(unique=True)\n\n    def __str__(self):\n        return self.username\n\n\nclass Category(DKModel):\n    class Meta:\n        verbose_name = \"카테고리\"\n        verbose_name_plural = \"카테고리들\"\n        db_table = \"dk_category\"\n\n    name = models.CharField('이름', max_length=100, unique=True)\n    description = models.TextField()\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.name\n\n\nclass Expense(DKModel):\n    class Meta:\n        verbose_name = \"지출\"\n        verbose_name_plural = \"지출들\"\n        db_table = \"dk_expense\"\n\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.CASCADE)\n    amount = models.DecimalField(max_digits=10, decimal_places=2)\n    description = models.TextField()\n    date = models.DateField()\n\n\nclass Balance(models.Model):\n    class Meta:\n        verbose_name = \"잔고\"\n        verbose_name_plural = \"잔고들\"\n        db_table = \"dk_balance\"\n\n    total_balance = models.DecimalField(max_digits=10, decimal_places=2)\n```\n\n## O: 개방/폐쇄 원칙 (OCP)\n\n<div class=\"content-ad\"></div>\n\n소프트웨어 엔티티들은 확장에는 열려 있지만 수정에는 닫혀 있어야 합니다.\n\n```python\n# middleware.py\nfrom django.http import HttpResponse\n\nclass BaseMiddleware:\n    def process_request(self, request):\n        raise NotImplementedError\n\nclass AuthMiddleware(BaseMiddleware):\n    def process_request(self, request):\n        if not request.user.is_authenticated:\n            return HttpResponse('Unauthorized', status=401)\n```\n\n### L: 리스코프 치환 원칙 (LSP)\n\n슈퍼클래스의 객체는 서브클래스의 객체로 대체할 수 있어야 하며, 프로그램의 정확성에 영향을 주지 않아야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# models.py\n\nclass Notification:\n    def send(self):\n        raise NotImplementedError\n\nclass EmailNotification(Notification):\n    def send(self):\n        print(\"이메일 보내는 중\")\n\nclass SMSNotification(Notification):\n    def send(self):\n        print(\"SMS 보내는 중\")\n\ndef notify(notification: Notification):\n    notification.send()\n\n# 사용 예시\nemail_notification = EmailNotification()\nsms_notification = SMSNotification()\n\nnotify(email_notification)  # 출력: 이메일 보내는 중\nnotify(sms_notification)    # 출력: SMS 보내는 중\n```\n\n## I: 인터페이스 분리 원칙 (ISP)\n\n클라이언트는 사용하지 않는 인터페이스에 종속되도록 강요되어서는 안됩니다.\n\n```js\n# 더 큰 뷰를 분리함으로써 인터페이스 분리\nfrom django.views import View\nfrom django.http import JsonResponse\n\nclass CreateMixin:\n    def create(self, request, *args, **kwargs):\n        return JsonResponse({'message': '생성 기능이 구현되지 않았습니다.'}, status=405)\n\nclass ReadMixin:\n    def read(self, request, *args, **kwargs):\n        return JsonResponse({'message': '조회 기능이 구현되지 않았습니다.'}, status=405)\n\nclass UpdateMixin:\n    def update(self, request, *args, **kwargs):\n        return JsonResponse({'message': '수정 기능이 구현되지 않았습니다.'}, status=405)\n\nclass DeleteMixin:\n    def delete(self, request, *args, **kwargs):\n        return JsonResponse({'message': '삭제 기능이 구현되지 않았습니다.'}, status=405)\n\nclass MyView(CreateMixin, ReadMixin, View):\n    def read(self, request, *args, **kwargs):\n        return JsonResponse({'message': '데이터 조회 중'})\n```\n\n<div class=\"content-ad\"></div>\n\n## D: 의존 역전 원칙 (DIP)\n\n고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 둘 모두 추상화에 의존해야 합니다.\n\n```js\nclass PaymentService:\n    def process_payment(self):\n        raise NotImplementedError\n\nclass StripePaymentService(PaymentService):\n    def process_payment(self):\n        print(\"Stripe로 결제 처리 중\")\n\nclass PayPalPaymentService(PaymentService):\n    def process_payment(self):\n        print(\"PayPal로 결제 처리 중\")\n\n# views.py\nfrom .services import PaymentService\n\nclass PaymentView(View):\n    def __init__(self, payment_service: PaymentService):\n        self.payment_service = payment_service\n\n    def post(self, request, *args, **kwargs):\n        self.payment_service.process_payment()\n        return JsonResponse({'message': '결제가 완료되었습니다'})\n\n# 사용법\nstripe_service = StripePaymentService()\npaypal_service = PayPalPaymentService()\n\nstripe_payment_view = PaymentView(stripe_service)\npaypal_payment_view = PaymentView(paypal_service)\n```","ogImage":{"url":"/assets/img/2024-06-20-DesignPrinciplesinPythonDjango_0.png"},"coverImage":"/assets/img/2024-06-20-DesignPrinciplesinPythonDjango_0.png","tag":["Tech"],"readingTime":11},{"title":"Bayesian Framework을 활용한 마케팅 믹스 모델링과 ROAS","description":"","date":"2024-06-20 02:06","slug":"2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS","content":"\n\n이 게시물은 Rafael Guedes와 함께 공동 저술되었습니다.\n\n# 소개\n\n확장 가능한 인터넷 비즈니스는 성장을 이끌기 위해 마케팅에 의존합니다. 물론 그것뿐만이 아니라 특정 규모에서는 매우 효율적으로 고객을 확보하지 않을 수 없는 회사가 매우 적습니다. 기업들이 마케팅에 인공지능(AI) 능력을 가져오기 위해 많이 투자하고 있는 두 가지 핫한 주제는 미디어 믹스 모델링(MMM)과 고객 평생 가치(LTV) 예측입니다. 이 두 가지는 기업들이 마케팅에 투자하는 비용 대비 이익을 증가시키는 데 초점을 맞추고 있습니다. 이 글은 MMM이 무엇인지와 적용하는 데 가장 효과적인 방법에 대해 다루고 있습니다.\n\nMMM은 마케팅 팀이 투자의 영향과 대화 유도에 어떻게 기여하는지를 측정할 수 있는 기술입니다. 이 일의 복잡성은 최근 몇 년 동안 급속히 증가했습니다. 왜냐하면 광고를 할 수 있는 플랫폼이 급증했기 때문입니다. 이 현상은 잠재 고객을 오프라인 또는 온라인 버킷으로 나눌 수 있는 다양한 미디어 채널에 분산시켰습니다. 전통적인 오프라인 채널은 디지털 지원이 없으며 신문, 라디오, 텔레비전 광고, 쿠폰, 박람회 부스 등을 포함할 수 있습니다. 온라인 채널은 급증했고 기업들은 이러한 채널을 함께 사용하고 있습니다. 이메일, 소셜 미디어, 유기적 검색, 유료 검색, 제휴 마케팅, 인플루언서 마케팅 등을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n중요한 점 중 하나는 좋은 MMM이 동일하게 정확한 데이터 기반 속성 모델이 필요하다는 것입니다. 즉, 어떤 채널이 특정 고객을 확보하는 데 기여했는지를 나타냅니다. 또한 속성은 사용자 수준에서 수행되지만, MMM은 일반적으로 확보 채널 수준에서 적용됩니다. 데이터 기반 속성은 이 글의 범위를 벗어납니다.\n\n이 글에서는 두 가지에 초점을 맞춥니다. 첫째, 각 미디어 채널의 성능에 대한 투명성을 높이기 위해 설계된 베이지안 모델을 개발합니다. 둘째, 이 경우 수익이라는 변수를 최대화하기 위해 예산 할당을 최적화합니다. 베이지안 접근 방식이 MMM에 어떻게 작용하는지에 대한 상세한 내용을 제공하는 동시에 공개 데이터셋을 활용하여 모델의 정확성을 테스트하고 각 채널의 광고비 투자 대비 수익률(ROAS)을 계산합니다. 마지막으로, 수익을 극대화하기 위해 세 가지 채널 간의 가상 예산을 최적화합니다.\n\n항상 코드는 우리의 GitHub에서 이용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 미디어 믹스 모델링: 무엇인가요?\n\nMMM은 전 세계 기업들에게 광고 채널의 효과를 측정하고 미디어 비용이 매출에 미치는 영향에 대한 투명성을 제공하여 조직을 강화합니다. 이러한 모델은 매출, 광고 지출 대비 수익 (ROAS), 수익, 전환, LTV 등의 관심 대상 대상 변수를 최적화하여 채널 간 예산 할당 결정 프로세스를 지원하는 데 중요한 역할을 합니다.\n\n지난 몇 년 동안 많은 연구가 수행되었으며, 관심 대상 변수에 영향을 미치는 지출을 모델링하기 위해 여러 모델이 제안되었습니다. 이러한 모델은 지리적으로 집계된 주간 또는 월간 데이터에 기반합니다. 우리는 의존 변수(위에서 정의한 관심 대상 변수 중 하나 이상)와 독립 변수 간의 관계를 모델링하는 데 관심이 있습니다. 일부 독립 변수는 명백합니다. 예를 들어 광고 채널 별 광고 비용이 그렇습니다. 그러나 가격, 제품 유통, 인플레이션, 날씨, 계절성 및 시장 경쟁력과 같은 추가 관련 효과를 포함하여 접근 방식을 확장할 수 있습니다.\n\n전통적인 접근 방식은 회귀 방법을 활용하여 상관 관계에서 인과 관계를 추론합니다. 그러나 매출의 반응은 선형적이지 않습니다 - 고수준 지출에서 수익이 감소하는 포화 현상이 있습니다. 게다가 광고에는 선행 또는 잔류 효과가 있어 이전 주에 지출한 내용이 다음 주의 매출에 영향을 미칠 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_1.png\" />\n\n# 미디어 믹스 모델의 베이지안 방법론\n\n베이지안 방법론은 포화/형태와 래그/캐리오버 효과를 고려하기 위해 정의될 수 있습니다.\n\n모델 세부사항에 대해 깊이 파고들기 전에, 모델이 어떤 변수를 고려하는지 더 잘 이해하기 위해 가상의 데이터 세트를 정의해보겠습니다. 국가 수준에서 매주 데이터가 있으며 각 행이 주차(t)를 나타내고 각 열이 미디어 채널(m) 또는 계절성 또는 제품 가격과 같은 제어 변수(c)를 나타내는 가정 데이터 세트를 정의해보겠습니다. 주차 t에서 채널 m의 미디어 비용은 Xt,m로 정의되며 동일한 주차에 대한 제어 변수는 Zt,c로 정의됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_2.png\" />\n\n# 랙 또는 캐리오버 효과\n\n캐리오버 효과는 adstock라는 함수에 의해 모델링됩니다 [1]. 이 함수는 특정 채널에서 지출의 누적 효과를 만듭니다. 이 함수는 현재 주와 이전 L-1 주의 미디어 비용을 가중 평균을 통해 변환합니다. L은 특정 미디어 채널의 캐리오버 효과의 최대 기간이며, 가중 평균 방정식에서 가중치 Wm를 추정하는 데 중요한 역할을 합니다.\n\n<img src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_3.png\" />\n\n<div class=\"content-ad\"></div>\n\n미디어 채널마다 L을 다르게 설정할 수 있습니다. 이것은 전문가가 정의해야 하는 초매개변수입니다. 특정 채널에 대한 사전 정보가 없는 경우, 저자들은 잠재적으로 지연된 효과를 포착하기 위해 L을 13과 같은 큰 숫자로 설정하는 것이 좋다고 충고합니다.\n\n가중치를 정의하는 방정식은 두 가지 다른 형태를 가질 수 있습니다:\n\n- 즉각적인/Geometric Adstock [2]는 광고 효과 피크가 광고 노출과 동시에 발생할 때 사용됩니다. 즉, 우리가 특정 미디어 채널의 지출을 늘린 주에 매출이 최대치를 기록한 경우입니다. 방정식 2에서 αm은 광고 효과의 유지율입니다.\n\n![equation](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_4.png)\n\n<div class=\"content-ad\"></div>\n\n- 광고 효과의 정점이 더 오랜 시간이 걸려 구축되고 판매에 즉시 영향을 주지 않는 경우를 지연된 Adstock [1]라고합니다. 식 3에서 θm은 정점 효과의 지연을 나타냅니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_5.png)\n\n이제 상상 속 데이터셋을 선택하고 Facebook 채널의 즉각적 및 지연 Adstock를 계산해 보겠습니다. 먼저 데이터셋에 5주를 추가했습니다. 보존율(αm)은 80%이며, 정점 지연(θm)은 5주입니다. 이후 즉각적인 효과에 대한 가중치와 지연된 효과에 대한 가중치를 계산하여 8주차에서 즉각 및 지연 Adstock의 최종값에 도달합니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_6.png)\n\n<div class=\"content-ad\"></div>\n\n표 3는 각 주별 지출이 8주차의 매출량에 얼마나 기여하는지를 보여줍니다.\n\n![Figure 3](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_7.png)\n\n# 포화 또는 모양 효과\n\n포화 또는 모양 효과는 미디어 비용을 로지스틱 포화 함수 [3]와 같은 곡률 함수를 통해 변환하여 모델링합니다. 다음과 같이 정의됩니다:\n\n<div class=\"content-ad\"></div>\n\n이 중에서 x는 미디어 비용을 나타내고, λ는 포화 곡선의 가파르기를 제어한다. 즉, 미디어 비용 효과가 얼마나 빨리 포화되는지를 결정한다. 그러면 낮은 λ 값은 응답 함수의 증가가 점진적이라고 해석할 수 있으며, 미디어 비용이 넓은 범위의 값들에 대해 주목할 만한 효과를 갖는다는 것을 의미한다. 반대로, 높은 λ 값은 지출에 대한 감소된 수익을 가져올 것이다. Figure 4는 이러한 다른 행동들을 매우 명확히 보여줍니다.\n\n이 모델에 어떤 매개변수를 사용해야 하는지 알기가 어렵습니다. 왜냐하면 이는 각 채널의 행동에 매우 구체적이기 때문입니다. 그럼에도 불구하고, Bayesian 접근 방식에서 이러한 매개변수는 사전 분포를 사용하여 추정됩니다. 따라서, 모델은 주어진 데이터에 대해 가능한 가치 매개변수를 선택합니다. 따라서, 우리는 단일 값이 아닌 분포를 설정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 캐리오버와 형태 효과 결합\n\n이전 두 섹션에서 언급했듯이 캐리오버와 형태 효과를 모델링하려면 각 채널의 미디어 비용에 변환을 적용해야 합니다. 어떤 변환을 먼저 적용해야 하는지에 대한 질문이 제기됩니다. 저자들은 다음을 제안합니다:\n\n- 미디어 비용이 특정 기간에 집중적으로 소비된다면 형태 효과는 캐리오버에 따릅니다.\n- 미디어 비용이 여러 시간대에 고르게 분산된다면 캐리오버는 형태 효과에 따릅니다.\n\n기관들은 일반적으로 마케팅 활동을 집중하기 때문에 가장 흔한 접근 방식은 캐리오버 → 형태 효과의 결합입니다.\n\n<div class=\"content-ad\"></div>\n\n이에 따라 t주차의 종속 변수인 매출 y는 미디어 비용 및 제어 변수의 선형 결합을 통해 모델링될 수 있습니다. 또한 회귀 계수 β를 사용하여 각 미디어 채널에 대한 다른 효과를 모델링합니다.\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_10.png)\n\n여기서 𝛂는 y절편입니다. 함수 f(xm,t)는 광고재고(지속성) 및 포화 효과를 고려한 대상 변수에 대한 미디어의 기여를 인코딩합니다. γc는 제어 변수 Zt,c의 효과이며, et는 백색 잡음입니다.\n\n# 베이지안 모델\n\n<div class=\"content-ad\"></div>\n\n베이지안 접근법은 모델 매개변수에 대한 사전 분포를 정의하는 것으로 시작하여, 데이터를 고려하기 전의 초기 신념을 반영합니다. 새로운 데이터가 도입되면 모수가 주어졌을 때 데이터를 관찰할 확률을 나타내는 우도 함수가 계산됩니다. 이 문맥에서 데이터에는 미디어 채널 X와 종속 변수 y를 설명하는 제어 변수 Z가 포함됩니다. 베이즈 정리를 사용하여 사후 분포는 사전 분포와 우도 함수를 결합하여 얻어집니다.\n\n저자들은 각 미디어 채널(X)과 제어 변수(Z)의 매개변수 값을 선택하는데 샘플링 효율성 때문에 Gibbs Sampling[4]에 의존합니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_11.png)\n\n데이터가 강력한 정보를 함유하고 명확한 패턴을 가질 때 모델은 매개변수를 추정할 때 사전 분포에 더 적게 의존한다는 것을 기억해 주세요.\n\n<div class=\"content-ad\"></div>\n\n하지만, 저자들은 각 매개변수에 대한 사전 분포를 정의하는 방법에 대한 일부 지침을 남겼습니다:\n\n- 유지율 (α)은 [0, 1[으로 제한되어 있으며, beta나 균일 분포와 같이 [0, 1[에 대해 정의된 사전을 가져야 합니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_12.png)\n\n- 지연 매개변수 (θ)는 일반적으로 [0, L-1]에 제한되어 있으며, 균일 분포나 스케일링된 베타 분포와 같은 사전을 가져야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_13.png)\n\n- Gamma (γ) and Intercept are usually modeled by a normal distribution.\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_14.png)\n\n- Lambda (λ) is usually modeled by a gamma distribution.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_15.png\" />\n\n- 회귀 계수 (β)는 일반적으로 미디어 소비가 y에 부정적인 영향을 미치지 않기 때문에 정규 분포와 같은 양수 우선 순위로 모델링됩니다.\n\n<img src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_16.png\" />\n\n# PyMC를 활용한 베이지안 미디어 믹스 모델링\n\n<div class=\"content-ad\"></div>\n\n해당 섹션은 카글의 공개 데이터셋을 활용하여 CC0 라이선스로 Bayesian 모델을 구현했습니다. 이 데이터셋은 세 가지 다른 미디어 채널(TV, 라디오, 신문)에 대한 지출 및 동일 기간의 판매에 대한 정보를 포함하고 있습니다.\n\n데이터셋은 다음과 같이 구성되어 있습니다:\n\n- ID — 행을 식별합니다.\n- TV 광고 예산($) — TV에 대한 광고 지출;\n- 라디오 광고 예산($) — 라디오에 대한 광고 지출;\n- 신문 광고 예산($) — 신문에 대한 광고 지출;\n- 판매($) — 목표 변수입니다.\n\n적합된 Bayesian 모델은 각 채널별 ROAS, 유지율 및 포화 효과를 계산하는 데 도움이 될 것입니다. 또한 미래 주차를 위한 예산 할당을 최적화하는 데도 도움이 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n모형의 신뢰성을 측정하기 위해 각 매체 채널의 지출과 제어 변수에 기반하여 보이지 않는 데이터에서 종속 변수를 얼마나 잘 모델링할 수 있는지를 평가할 것입니다. 우리는 평균 절대 오차 (MAE)와 같은 회귀 지표를 활용할 것입니다. 벤치마킹 측면에서, 항상 훈련 데이터의 평균 값으로 예측하는 단순 모형을 사용합니다. 그런데, MMM이 없을 때 기업들이 종종 이를 의존합니다.\n\n먼저 라이브러리를 가져오겠습니다:\n\n```js\n%matplotlib inline\n%load_ext autoreload\n%autoreload 2\nimport arviz as az\nimport datetime\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport utils\nfrom pymc_marketing.mmm.delayed_saturated_mmm import DelayedSaturatedMMM\nfrom sklearn.metrics import mean_absolute_error\n```\n\n그런 다음 데이터셋을 로드하고 일부 기본 전처리 작업을 수행합니다. 열 이름을 간소화하고 ID를 기반으로 새로운 날짜 열을 추가했습니다. 계절성 및 추세와 같은 제어 변수로 데이터셋을 보강하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```python\n# 데이터 로드 및 열 이름 변경\ndf = pd.read_csv('data/data.csv')\ndf = df.rename(columns={'Unnamed: 0': 'id', 'TV Ad Budget ($)':'tv', 'Radio Ad Budget ($)': 'radio', 'Newspaper Ad Budget ($)': 'newspaper', 'Sales ($)': 'sales'})\n\n# 날짜 열 생성\ndf['ds'] = df['id'].apply(lambda x: pd.to_datetime(\"2024-02-26\")-datetime.timedelta(weeks=len(df)-x))\n```\n\n그 후에는 데이터 내 상관 관계를 이해하기 위한 탐색적 데이터 분석을 수행합니다:\n\n1. 종속 변수와 각 매체 채널 간의 상관 관계를 평가합니다.\n\n- TV는 판매와 가장 크게 관련된 특성이며, Newspaper는 가장 낮은 상관 관계를 갖고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```python\ncorr_matrix = df[['sales', 'tv', 'radio', 'newspaper']].corr()\nsns.heatmap(corr_matrix, annot=True, cmap='Blues')\nplt.show()\n```\n\n2. 판매량과 각 매체 채널 간의 상관 관계를 평가하기 위해 판매량 대 매체 채널을 그래픽으로 나타냅니다:\n\n- 판매량에는 명확한 추세나 계절성이 없습니다.\n- TV 광고의 영향은 판매에 즉각적인 영향을 미칩니다.\n- 라디오 광고의 영향도 판매에 즉각적인 영향을 미칩니다. 예를 들어, TV 광고가 낮은 값을 가졌던 2022년 1~3주에는 판매량이 급등하는데, 이는 라디오의 급등과 일치합니다.\n- 신문 광고의 영향은 1~2주의 지연이 있는 것으로 보이지만, TV와 라디오 광고가 동시에 진행되었기 때문에 정확히 파악하기 어렵습니다.\n\n```python\n# 판매량만\nutils.line_plot(df.copy(), ['sales'], '시간에 따른 판매')\n\n# 판매 대 TV 광고\nutils.line_plot(df.copy(), ['sales', 'tv'], '시간에 따른 판매 대 TV')\n\n# 판매 대 라디오 광고\nutils.line_plot(df.copy(), ['sales', 'radio'], '시간에 따른 판매 대 라디오')\n\n# 판매 대 신문 광고\nutils.line_plot(df.copy(), ['sales', 'newspaper'], '시간에 따른 판매 대 신문')\n```\n\n<div class=\"content-ad\"></div>\n\nEDA를 마무리했으니 모델링 부분을 준비할 차례입니다:\n\n1. 데이터를 훈련 및 테스트 세트로 나누는 작업을 시작하겠습니다:\n\n```js\ntrain_df = df.sort_values(by='ds').iloc[:-5,:]\ntest_df = df.sort_values(by='ds').iloc[-5:,:]\n```\n\n2. 이전에 생성한 주간 데이터를 사용하여 추세와 계절성과 같은 통제 변수를 추출하려고 합니다.\n\n<div class=\"content-ad\"></div>\n\n- 시계열 모델 Prophet을 사용하여 Meta에서 시계열을 추세 및 계절성으로 분해하고 이를 제어 변수로 사용합니다.\n\n```js\nseasonality, trend = utils.extract_trend_seasonality(train_df, 'sales', 5)\ntrain_df.loc[:, 'seasonality'] = seasonality[:-5]\ntest_df.loc[:,'seasonality'] = seasonality[-5:]\ntrain_df.loc[:,'trend'] = trend[:-5]\ntest_df.loc[:,'trend'] = trend[-5:]\n```\n\n![Image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_17.png)\n\n3. 모델을 위한 다른 하이퍼파라미터를 설정합니다. 이러한 매개변수는 전통적인 ML 하이퍼파라미터 검색을 통해 정의할 수 있습니다. dist, mu 및 sigma 값을 변경하여 일부 회귀 지표를 최적화합니다. 더 높은 표준 편차 값(sigma)은 모델에 더 많은 자유를 제공하여 최적의 매개변수를 탐색할 수 있음을 기억하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nmy_model_config = {'intercept': {'dist': 'Normal', 'kwargs': {'mu': 0, 'sigma': 2},\n 'beta_channel': {'dist': 'HalfNormal', 'kwargs': {'sigma': 2},\n 'alpha': {'dist': 'Beta', 'kwargs': {'alpha': 1, 'beta': 3},\n 'lam': {'dist': 'Gamma', 'kwargs': {'alpha': 3, 'beta': 1},\n 'likelihood': {'dist': 'Normal',\n  'kwargs': {'sigma': {'dist': 'HalfNormal', 'kwargs': {'sigma': 2}},\n 'gamma_control': {'dist': 'Normal', 'kwargs': {'mu': 0, 'sigma': 2},\n 'gamma_fourier': {'dist': 'Laplace', 'kwargs': {'mu': 0, 'b': 1}}}\n```\n\n<img src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_18.png\" />\n\nFigure 13에서 저희가 구현한 모델의 Kruschke 다이어그램을 제시합니다. 이는 이전에 정의한 내용에 대한 간결한 개요를 제공합니다. 이러한 다이어그램을 해석할 때 고려해야 할 몇 가지 측면이 있습니다. 각 노드 내에서 변수와 해당 분포를 찾을 수 있음을 유의하십시오. 예를 들어, α를 포함하는 원은 이전에 정의한 대로 베타 분포를 나타냅니다. 음영 처리된 노드는 관측된 변수를 나타냅니다. 둥근 모서리 상자는 반복을 나타냅니다. 예를 들어, 저희는 세 개의 확보 채널이 있으므로 각 채널에 대해 별도의 α, β 및 λ 매개변수 집합을 설정합니다. 화살표는 종속성을 보여줍니다. 저희 모델에서는 두 개의 화살표가 가능 함수를 가리키는데, 하나는 mu 매개변수에 종속성을 나타내고 다른 하나는 sigma 매개변수에 종속성을 나타냅니다. mu 매개변수 자체가 세 개의 추가 종속성을 가지고 있음을 상기해 주세요. 우리는 이동 효과, 모양 효과 및 제어 변수를 통합하여 매출을 모델링하기로 선택했음을 기억하세요.\n\n이제 우리는 교육 및 테스트 세트, 그리고 모델 구성을 정의했으므로 베이지안 모델을 초기화하고 교육 데이터에 맞출 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 미디어 채널 [\"tv\", \"radio\", \"newspaper\"]\n- 통제 변수 [\"seasonality\", \"trend\"]\n- EDA에서 광고주는 지연 매개변수로 최대 2까지 인 것으로 보입니다.\n\n```js\nmmm = DelayedSaturatedMMM(\n    model_config=my_model_config,\n    sampler_config={\"progressbar\": True},\n    date_column=\"ds\",\n    channel_columns=[\"tv\", \"radio\", \"newspaper\"],\n    control_columns=[\"seasonality\", \"trend\"],\n    adstock_max_lag=2,\n)\n\nmmm.fit(X=train_df[['ds', 'tv', 'radio', \"newspaper\", \"seasonality\", \"trend\"]], y=train_df['sales'], target_accept=0.95, chains=4, random_seed=42)\n```\n\n모델을 적합한 후에는 샘플링 예측값(파란색)과 실제 값(검은색)을 비교하여 학습 데이터에 얼마나 잘 맞는지 확인할 수 있습니다. 우리의 경우, 그들이 잘 일치하는 것을 확인할 수 있습니다.\n\n```js\nmmm.sample_posterior_predictive(train_df[['ds', 'tv', 'radio', \"newspaper\", \"seasonality\", \"trend\"]], extend_idata=True, combined=True)\nmmm.plot_posterior_predictive(original_scale=True);\n```\n\n<div class=\"content-ad\"></div>\n\n이제 다양한 방법으로 모델 해석을 시작할 수 있습니다:\n\n1. 파라미터 추정 확인:\n\n- 라디오는 계수(베타)가 가장 높으므로 투자 대비 가장 높은 수익을 보이는 것으로 보입니다(1.185), 그 다음에 TV와 신문이 이어집니다.\n- 유지율 α는 TV에 대해 3.2%, 라디오에 대해 2.3%, 신문에 대해 23.9%입니다.\n\n```js\naz.summary(data=mmm.fit_result,\n    var_names=[\n        \"intercept\",\n        \"likelihood_sigma\",\n        \"beta_channel\",\n        \"alpha\",\n        \"lam\",\n        \"gamma_control\",\n    ],\n)\n```\n\n<div class=\"content-ad\"></div>\n\n- TV에서 포화율 λ가 더 높으며 (3.138), 전체 지출의 73%를 차지합니다. 그림 12에서 3개 채널의 포화율을 더 쉽게 비교할 수 있습니다.\n\n![Figure 12](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_19.png)\n\n2. 채널 기여 및 ROAS 확인:\n\n- ROAS는 매체 채널 중 하나의 지출을 제로로 설정하여 현재 매출 대비 예측 매출이 어떻게 변경되는지를 평가하여 계산됩니다. 예를 들어, 신문의 매체 지출을 제로로 설정하면 매출 큰 감소를 예상하지 않습니다. 따라서, 이에 대한 ROAS는 낮을 것입니다.\n- TV가 높은 지출을 했기 때문에 가장 큰 기여를 가지고 있지만, 모델은 라디오에 대해 더 높은 ROAS를 예측합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n# 채널의 공헌도\nfig = mmm.plot_channel_contribution_share_hdi(figsize=(7, 5))\n\n# ROAS 계산\nutils.plot_ROAS(mmm, train_df, [\"tv\", \"radio\", \"newspaper\"])\r\n```\n\n3. 마지막으로, 각 채널별 광고비 지출을 50% 증가시킨다면 어떤 일이 일어날지도 평가할 수 있습니다. 이때는 캐리오버와 포화 효과를 고려합니다.\n\nX 축은 채널 데이터 백분율 수준입니다:\n\n- When =1 일 때, 모델 입력 지출 데이터가 됩니다.\n- When =1.5 일 때, 지출을 50% 증가시켰을 때의 공헌도가 어떨지 볼 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n신문은 지출이 50% 증가해도 그다지 많은 기여를 못 할 것 같아요. \n\n라디오는 TV에 비해 훨씬 포화되지 않아 보여요. 두 선의 기울기를 비교해 봤을 때 그렇죠.\n\n```js\nplt.rcParams[\"figure.figsize\"] = (20,5)\nmmm.plot_channel_contributions_grid(start=0, stop=1.5, num=12);\n```\n\n우리의 결론이 올바른지 확인하기 위해 시험 집합을 사용하여 미디어 채널과 제어 변수를 기반으로 미래 매출을 예측하는 모델의 성능을 평가할 수 있어요. 이를 위해 MAE를 사용하고 소박한 모델과 비교할 거에요.\n\n<div class=\"content-ad\"></div>\n\n- 우리는 평균 목표가 13.8인 경우 MAE가 2.01이었습니다.\n- 우리는 베이스라인보다 오차가 58% 낮습니다.\n\n```js\ny_out_of_sample = mmm.sample_posterior_predictive(X_pred=test_df[['ds', 'tv', 'radio', \"newspaper\", \"seasonality\", \"trend\"]], extend_idata=False)\ny_pred = [np.median(x) for x in y_out_of_sample['y']]\n\nprint(f\"평균 절대 오차 (MAE): {mean_absolute_error(test_df['sales'], y_pred)} (평균 목표: {test_df['sales'].mean()})\")\nprint(f\"평균 절대 비율 오차 (MASE): {mean_absolute_error(test_df['sales'], y_pred)/mean_absolute_error(test_df['sales'], [train_df['sales'].mean()]*5)}\")\n```\n\n회귀 결과는 모델이 매체 채널과 제어 변수를 기반으로 매출을 모델링하기에 신뢰할만하고 잘 한다는 것을 보여줍니다.\n\n# 예산 할당\n\n<div class=\"content-ad\"></div>\n\n판매에 대한 지출 효과가 선형적이지 않을 것으로 가정하기 때문에 어느 시점에서 포화될 것으로 예상됩니다. 따라서, 우리는 어떤 포화 함수가 우리의 데이터와 더 잘 맞는지 결정해야 합니다. 포화 모델링을 위한 두 가지 함수 옵션이 있습니다:\n\n- α(alpha)가 포화 지점인 시그모이드 함수, 즉 지출 증가가 판매 증가로 이어지지 않고, λ(lambda)는 곡선의 기울기를 제어하는 요인입니다. 더 높은 값은 곡선을 더 가파르게 만듭니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_20.png)\n\n- 알파(alpha)가 채널이 가질 수 있는 최대 기여도인 Michaelis-Menten 함수이며, 람다(lambda)는 곡선이 방향을 조정하는 순간, 즉 기울기입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_21.png)\n\n저희 데이터에 더 적합한 곡선을 결정하기 위해, 적합된 MMM을 사용하여 각 함수의 매개변수를 계산할 것입니다. 그 후 두 가지를 모두 플롯하고 시각적으로 어느 것이 더 적합한지 확인할 것입니다.\n\n- 특정 사용 사례에서, 시그모이드 함수가 더 나은 결과를 보였습니다.\n\n```js\n# 플롯 및 알파, 람다 추출\nsigmoid_response_curve_fig = mmm.plot_direct_contribution_curves(show_fit=True)\nsigmoid_params = mmm.compute_channel_curve_optimization_parameters_original_scale(method='sigmoid')\n\nmm_response_curve_fig = mmm.plot_direct_contribution_curves(show_fit=True, method='michaelis-menten')\nmm_params = mmm.compute_channel_curve_optimization_parameters_original_scale(method='michaelis-menten')\n``` \n\n\n<div class=\"content-ad\"></div>\n\n이제 각 미디어 채널의 시그모이드 매개변수(α 및 λ)가 있으므로 각 채널의 포화점을 알 수 있습니다. 따라서 추가 지출은 수익을 증가시키지 않을 것이며, 다른 채널에 투자된 금액은 원하는 효과를 얻을 수 있습니다.\n\n채널 포화도를 기반으로 한 예산 할당을 최적화하기 위한 알고리즘을 사용할 수 있습니다. 이 때 고려해야 할 세 가지 변수는 채널 포화도, 사용 가능한 총 예산 및 각 채널의 예산 제약 사항입니다. PyMC에는 Sequential Least Squares Quadratic Programming (SLSQP)을 구현한 것이 있습니다. 이는 세 가지 변수를 고려하여 모든 채널에서 총 기여도를 최대화합니다:\n\n- 총 예산 제한;\n- 각 채널의 최소 및 최대 지출 한도;\n- 포화 곡선.\n\n```python\nresult_sigmoid = mmm.optimize_channel_budget_for_maximum_contribution(\n    method='sigmoid', # 포화 함수를 정의\n    total_budget=500, # 총 예산\n    parameters=sigmoid_params, # 이전에 추출한 시그모이드 매개변수\n    budget_bounds={'tv': [75, 296], 'radio': [10, 300], 'newspaper': [1, 25]} # 채널별 예산 제약 사항\n)\n```\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_22.png)\n\n표 4는 우리의 예산 배정 결과를 보여줍니다. 라디오는 추정 기여도가 가장 높은 채널이며, TV는 가장 높은 예산을 쓰도록 권장받은 채널입니다.\n\n# 시장 불확실성 하의 예산 배정\n\n현재 경제 상황에서 많은 불확실성을 겪고 있습니다. 따라서, 다양한 시나리오를 수용할 수 있는 예산 배정 전략을 설계해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n세 가지 다른 시나리오를 고려해 봅시다:\n\n- 초기: 경제가 안정 상태를 유지하며, 예산 할당은 이전 섹션에서 계산된 것과 동일합니다.\n- 시나리오 2: 경제가 경기 침체를 겪고 예산이 40% 삭감됩니다.\n- 시나리오 3: 경제가 유리해지고 성장을 시작하며, 예산이 20% 증가합니다.\n\n이러한 다른 시나리오에서 예산 할당을 최적화하기 위해 동일한 적합된 MMM 모델과 모델의 시그모이드 매개변수를 사용할 것입니다. 같은 코드를 사용하지만 이번에는 사용 가능한 예산을 줄이거나 증가시키기 위해 다른 시나리오를 반복할 것입니다.\n\n```js\nscenarios_result = []\ntotal_budget = 500\nchannels = ['tv', 'radio', 'newspaper']\n\nfor scenario in np.array([0.6, 1.2]):\n    scenarios_result.append(\n        mmm.optimize_channel_budget_for_maximum_contribution(\n            method=\"sigmoid\",  # 포화 함수 정의\n            total_budget=total_budget * scenario,\n            parameters=sigmoid_params,\n            budget_bounds={\n                channel: [1, total_budget * scenario] for channel in channels\n            },\n        ).to_dict()\n    )\n_ = mmm.plot_budget_scenearios(\n    base_data=result_sigmoid, method=\"sigmoid\", scenarios_data=scenarios_result\n)\n```\n\n<div class=\"content-ad\"></div>\n\n그림 19에서 보듯이, 경제 불황 시나리오에서 TV에 할당된 예산은 초기 시나리오와 비교했을 때 라디오보다 크게 감소합니다. 이는 라디오의 ROAS가 높기 때문에 예상되는 현상입니다. 반면, 성장 시나리오에서는 TV와 라디오에 할당된 예산이 유사하게 증가합니다.\n\n# 결론\n\n미디어믹스 모델링을 위한 AI는 투자에서 긍정적인 수익을 창출하고 가치 있는 충성고객을 확보하는 차이를 만들어줄 수 있습니다. 또는 잘못된 미디어 채널과 잘못된 고객에게 금전적 자원을 낭비하는 것 사이의 차이를 만들어줄 수도 있습니다.\n\n본 문서에서는 각 회사의 미디어 채널이 새로운 고객을 확보할 수 있는 잠재력을 더 자세히 평가하고 투명성을 제공할 수 있는 마케팅 믹스 모델링을 위한 베이지안 프레임워크를 개발했습니다. 우리의 접근 방식은 마케팅팀의 도메인 지식을 사전 분포를 설정함으로써 통합할 수 있습니다. 이는 모델의 능력을 향상시키고 미디어 채널과 관심 변수(예: 판매) 간의 관계를 이해하는데 도움이 됩니다. 마지막으로, 회사가 새로운 고객을 확보하기 위해 투자할 능력에 따라 예산 할당 전략을 최적화할 수 있습니다. 현재의 거시 경제 상황에서 기업은 수익성으로 돌아갈 수 있으며 성장에 투자할 예산을 줄일 수 있습니다. 우리는 영향을 최소화하면서 어디서 예산을 삭감할지에 대한 데이터 기반 의사결정 방법을 보여주었습니다. 반대로, 상황이 긍정적일 때 어디에 투자할지와 회사가 더 빨리 성장하기 위해 더 많은 자원을 투입하려는 경우 어디에 투자할지를 보여주었습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 현재 기관들에 새로운 AI 애플리케이션을 개발하고 배포하고 있어요. 예를 들어, 우리는 생성 모델 AI로 고객 경험을 향상시키고 시계열 예측으로 계획 프로세스를 개선하고 있어요. 이 경우에는 AI가 마케팅 예산의 효율성을 향상시킬 수 있는 방법을 보여주고 있어요. 우리의 경험에 따르면, AI 채택 측면에서 선진적이고 성숙한 기관은 핵심 활동에 중점을 둔 특화된 AI 모델 스위트가 필요해요.\n\n# 나에 대해\n\nAI 분야의 시리얼 창업가이자 리더에요. 비즈니스를 위한 AI 제품을 개발하고 AI 중심의 스타트업에 투자하고 있어요.\n\nZAAI 설립자 | LinkedIn | X/Twitter\n\n<div class=\"content-ad\"></div>\n\n# 참고문헌\n\n[1] Yuxue Jin, Yueqing Wang, Yunting Sun, David Chan, Jim Koehler. (2017). Bayesian Methods for Media Mix Modeling with Carryover and Shape Effects.\n\n[2] Dominique M. Hanssens , Leonard J. Parsons , Randall L. Schultz. (2003). Market response models: econometric and time series analysis. Springer Science & Business Media.\n\n[3] Hill, A. V. (1910). 혈색소 분자의 집단화가 분리 곡선에 미치는 가능한 영향. Journal of Physiology, 40 (suppl), iv–vii. doi:10.1113/jphysiol.1910. sp001386.\n\n<div class=\"content-ad\"></div>\n\n[4] Gelfand, A. E. & Smith, A. F. (1990). Sampling-based approaches to calculating marginal densities. Journal of the American statistical association, 85 (410), 398–409\n\n---\n\n모든 이미지는 저자의 작품이며, 다르게 표기되지 않았습니다.","ogImage":{"url":"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_0.png"},"coverImage":"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_0.png","tag":["Tech"],"readingTime":20}],"page":"41","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}