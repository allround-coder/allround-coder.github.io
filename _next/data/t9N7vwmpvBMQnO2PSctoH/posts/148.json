{"pageProps":{"posts":[{"title":"프런트엔드 주간 뉴스 (2024년 4월 22일-28일)","description":"","date":"2024-05-01 22:45","slug":"2024-05-01-FrontendWeeklyDigest3602228April2024","content":"\n\n<img src=\"/assets/img/2024-05-01-FrontendWeeklyDigest3602228April2024_0.png\" />\n\n# 웹 개발\n\n- HTML 이메일 템플릿에 미디어 추가하는 방법\n- HTML 속성 vs DOM 속성\n- Front End 개발자/엔지니어 핸드북 2024\n- 웹이 우리가 알고 있는 것으로 끝난다\n- 스크롤 시 블러 텍스트 노출\n- 개발자 도구를 위한 인터페이스 디자인 방법\n- Hello Bun: GitHub 및 Render에서 빠르게 2배 빨리 배포되는 Sveld\n\n# CSS\n\n<div class=\"content-ad\"></div>\n\n• CSS Shape — CSS만으로 만들어진 다양한 모양들의 최종 모음\n• CSS에서 JavaScript 지원 여부 감지하기\n• 새로운 !important 사용법\n• CSS clamp() 함수를 사용한 유동적인 타이포그래피 만들기\n• 여전히 Sass가 필요한가요?\n• 추가적인 마크업 없이 이모지의 폰트 크기를 늘리는 CSS 활용\n• CSS 컨테이너 쿼리: 반응형 웹 디자인 혁신\n• CSS의 revert-layer 키워드 이해\n\n# JavaScript\n\n• new URL()의 문제와 URL.parse()가 이를 해결하는 방법\n• Web 구성 요소 상태를 유지한 채 SPA와 유사한 내비게이션\n• ExpressJS 및 React로 서버 측 캐시 구축한 경험\n• JavaScript에서 워커 스레드 사용 사례 5가지\n- React\n• React 19 Beta\n• React 19를 위한 코드베이스 준비하기\n• React 및 Next.js에서 INP 개선하기\n• React 상태 관리 도구 비교: Mutative vs. Immer vs. 리듀서\n• AbortController로 비동기 React 앱 요청 취소하기\n- Vue\n• Vue.js의 `suspense` 및 비동기 컴포넌트 이해하기\n• 반응형 혁명: Vue 3의 프록시 vs. Vue 2의 DefineProperty 공개\n- Angular\n• Angular에서 이벤트 디스패치\n• Angular의 afterRender 및 afterNextRender 후크 탐색\n• Angular로 점진적 웹 앱 마스터하기: 포괄적인 가이드\n• Angular에서 글로벌 상태 관리 옵션 탐색\n• Angular Material을 사용한 Material 3 디자인 탐색","ogImage":{"url":"/assets/img/2024-05-01-FrontendWeeklyDigest3602228April2024_0.png"},"coverImage":"/assets/img/2024-05-01-FrontendWeeklyDigest3602228April2024_0.png","tag":["Tech"],"readingTime":2},{"title":"DOM-JON으로 더 나은 JS DOM 구축하기","description":"","date":"2024-05-01 22:39","slug":"2024-05-01-BetterJSDOMBuildingWithDOM-JONPart3TheStateObject","content":"\n\n이번에는 현재 베타 릴리스와 몇 가지 예제를 함께 보여드릴 거에요. 지금부터 머니 샷으로 뛰어들겠습니다. 이것은 '기능 완료'로 베타 버전이에요. 이제 \"기본 기능\"으로 원했던 모든 것이 완료되었고 작동하는 것 같아요. 이제 안정성 테스트의 즐거움이 남아 있군요.\n\n다음은 현재 베타 버전 링크에요.\nhttps://cutcodedown.com/for_others/domjon/domjon.beta1.js\n\n그리고 여기에 압축된 버전이 있어요:\nhttps://cutcodedown.com/for_others/domjon/domjon.beta1.min.js\n\n압축은 불필요한 공백을 제거한 간단한 방식이에요. 요즘의 많은 JS 기술/방법과 내 방법론은 대부분의 기존 \"멋진\" 압축과 호환되지 않는 것 같아요. 단순히 불필요한 공백을 제거하면, 압축 및 gzip을 걸친 라이브러리가 5k 미만이 된다면 괜찮아요.\n\n<div class=\"content-ad\"></div>\n\n코미디 킹은 구글의 \"Closure Compiler\"가 \"불필요한\" 중괄호를 제거하면서 실제로 \"IIFE를 대체하는 let/const\" 기법을 망친다는 점입니다! 그들의 이른바 \"화이트스페이스만\" 설정에서조차... 그곳에는 화이트스페이스가 아닌 다수의 것들을 제거하고 변경합니다. \"노력끈내보자\"에 대해 얘기할 때입니다.\n\n어쨌든, 여러분은 어떻게 생각하시는지 모르겠지만 저는 예시를 통해 더 잘 배웁니다.\n\n# 예시 #1, 간단한 상태 모니터링\n\nDOM-JON 시스템의 \"상태\" 객체는 자신에 대한 \"속성\", \"필터\", 그리고 \"모니터\"를 정의하는 메서드를 가지는 클래스입니다.\n\n<div class=\"content-ad\"></div>\n\n상태의 속성은 값이 할당될 때 '필터' 콜백을 호출하는 getter/setter입니다. 이를 통해 값의 유효성을 검사하거나 변환할 수 있습니다.\n\n\"모니터\"는 세터에 첨부할 수 있는 노드로, textNode.data, Element.textContent 또는 Element.value(요소 유형에 따라 다름)가 속성에 할당된 값과 일치하도록 변경됩니다. 이러한 \"모니터\"에는 자체 필터 콜백을 적용할 수도 있습니다.\n\nINPUT 또는 TEXTAREA 태그로 모니터를 생성하면 해당 값이 변경될 때(oninput), 상태에도 값이 변경됩니다. 따라서 이러한 모니터는 양방향입니다. 체크박스 및 라디오 요소는 설정되거나 해제될 때 HTMLInputElement.value나 null을 상태의 값으로 설정합니다.\n\n위의 데모에서 간단한 모니터의 작동 방식을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\"State\" 객체는 전역 범위에 노출되지 않았거나 Export를 위해 설정되지 않았습니다. 대신, \"document\" 객체의 메서드를 호출하는 오래된 JS 관습을 따릅니다. 이 경우 document.__createState입니다. 초기 상태를 설정하기 위한 key/value 쌍을 포함하는 객체를 매개변수로 받습니다.\n\n```js\nconst spectres = document.__createState({\n  \"Kanan Jarrus\" : 1,\n  \"Hera Syndulla\" : 2,\n  \"Chopper\" : 3,\n  \"Garazeb Orrelios\" : 4,\n  \"Sabine Wren\" : 5,\n  \"Jacen Syndulla\" : \"-\"\n});\n```\n\n이 방법으로 실행함으로써 모듈 및 비모듈 기반 코드와 호환되도록 했습니다. domjon.beta1.js를 모듈로 또는 일반적으로 로드할 수 있습니다.\n\n데모에서는 우리의 행을 담을 TBODY를 생성합니다. 나중에 그것을 가져오려고 애쓰지 않아도 되도록 따로 만들었습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ntbody = document.createElement(\"tbody\");\n```\n\n특별히 어떤 것도 할당하지 않았기 때문에, DOM-JON을 사용하여 시간을 낭비하지 않습니다. 그것은 데이터를 표시하는 테이블을 구성할 때 사용합니다.\n\n```js\ndocument.getElementById(\"process\").__make(\n \"table@beforebegin.spectres\",\n spectres,\n [ \"caption\", \"Spectres\" ],\n [ \"thead\",\n    [ \"tr\",\n      [ \"th_col\", \"Name\" ],\n      [ \"th_col\", \"Callsign\" ],\n      [ \"th_col\", \"Notes\" ]\n    ]\n ],\n tbody,\n [ \"tfoot\",\n    [ \"tr\",\n      [ \"td\", { colspan : 3}, \n        [ \"button_button\",\n          \"Click to empty table\",\n          { onclick : (event) => {\n            tbody.__make(\n              \"tr@replaceChildren\",\n              [ \"td\", { colSpan : 3 }, \"Empty\" ]\n            );\n          } }\n        ]\n      ]\n  ]\n ]\n);\n```\n\n나는 process ID를 잡아서 표는 그 앞에 삽입되고, 거기에 \"specters\" 클래스가 있는 것으로 설정합니다. 그 이후에는 보통의 표를 사용하며, `_` 연산자를 사용하여 `th` scope를 설정하고, 속성 객체를 사용하여 colspan을 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 `tfoot`에는 `tr`과 함께 `tbody`의 내용을 지울 버튼이 있습니다. Domjon.js에서 새로운 기능인 \"replaceChildren\"과 \"replaceWith\"가 소개되었어요. 후자는 DOM에서 부모 요소를 대체하고, 전자는 부모의 모든 자식 노드를 대체합니다.\n\n그 중요한 점은 \"spectres\" State Object가 DOM-JON 인수로 전달된다는 것이에요. 이렇게 전달된 상태는 Element.__state로 첨부되며, 자식 요소는 Element.__closestState getter를 사용하여 가져올 수 있어요.\n\n그런 다음 \"spectres\" State Object를 반복하여 `tbody`를 채워요:\n\n```js\nspectres.__forEachEnumerable(\n  (name, callsign) => tbody.__make(\n   \"tr\",\n    [ \"th_row\", name ],\n    [ `td&${name}`, callsign ],\n    [ `td&note ${name}` ]\n  )\n);\n```\n\n<div class=\"content-ad\"></div>\n\ndomjon.js에 추가된 새로운 \"for each enumerable\" 메서드를 소개합니다. \"foreach\" 스타일 메서드를 크게 선호하는 편은 아니지만, 편리함을 인정하며 제 입장만 생각하는 것은 아니라는 것도 인지하고 있어요.\n\nDSS(구분자 선택기 문자열)에서의 & 기호는(있는 경우) 상위 상태의 어떤 속성에 요소를 감시기로 첨부할 지를 나타냅니다. 따라서 spectres[name]의 값을 변경하면 해당 TD의 textContent가 마법처럼 해당 값으로 변경됩니다. 따라서 기존 이름에 연결하고 곧 사용할 `note ${name}`을 만들어냅니다.\n\n상태에서 이름이 존재하지 않는 경우 새 이름이 생성됩니다.\n\n이제 데이터를 아는 분들은 누군가 빠졌다는 것을 알게 되었겠죠. 그래서 에즈라 브리저를 추가해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ntbody.lastElementChild.__make(\n  \"tr@beforeBegin\",\n  [ \"th_row\", \"Ezra Bridger\" ],\n  [ `td&Ezra Bridger`, 6 ],\n  [ `td&note Ezra Bridger` ]\n);\n```\n\n방금 새로운 TR을 생성하고, tbody의 마지막 자식 앞에 삽입하여 순서에 맞게 Ezra를 Jacen 앞에 두었습니다. 여기에 노트를 설정할 수도 있었지만, 상태값을 변경하면 관련된 모니터 요소의 텍스트 내용이 변경되는 것을 보여주기 위해 수동으로 설정할 거에요:\n\n```js\nspectres[\"note Ezra Bridger\"] = \"이 레코드는 나머지 뒤에 추가되었습니다\";\n```\n\nJacen은 분명히 \"스펙터 7\"입니다만, 거기에 하이픈이 있어요. 이건 쉽게 수정 가능하고, 거기에 노트도 추가해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nspectres[\"Jacen Syndulla\"] = 7;\nspectres[\"note Jacen Syndulla\"] = \"이 레코드의 값이 '-'에서 '7'로 변경되었습니다.\";\n```\n\n와씨, 상태 객체의 속성을 변경했더니 자동으로 관련된 요소 노드의 내용이 업데이트되었어요.\n\n이쁜 표가 이렇게 생겼습니다:\n\n<img src=\"/assets/img/2024-05-01-BetterJSDOMBuildingWithDOM-JONPart3TheStateObject_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n상대적으로 간단한 예제를 통해 스크립트만 사용하여 DOM 요소를 생성하고 상태를 만들고 상태의 값을 수정하는 방법을 보여드리겠습니다.\n\n# 예제 #2, 필터를 사용하여 수준 높이기\n\n상태 처리의 장점은 위의 값 변경을 바로 DOM으로 변경할 수 없는 이유가 명확하지 않을 수 있습니다. 그러나 작업이 더 복잡해지면 일관된 흐름을 만들기 위해 머리가 너무 아플 수 있습니다.\n\n따라서 다음 예제인 시계에서 필터를 구현하는 방법을 보여드리겠습니다. 이를 통해 모든 \"로직\" 코드가 Date의 getSeconds, getMinutes 및 getSeconds를 변수에 저장하고 필터가 style.rotate의 각도로 변환하는 작업을 처리한다는 것을 보여드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n시계 바늘은 필터를 가진 것들입니다. DOM-JON 속성 객체에서 \"__filters\"는 콜백일 수도 있고 getter에 연결할 여러 콜백의 배열일 수도 있습니다. 이러한 방법은 NODE에만 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\n만약 필터 메소드가 null (값이 없는 경우의 기본값)이나 정의되지 않은 값을 반환한다면? 일반 노드 지정 핸들러(텍스트영역/data/value)가 호출되지 않습니다. 만약 실제 값 대신 사용할 값을 반환한다면, 값을 \"필터링\"하는 것이 가능합니다. 이는 toLocaleFormat를 통해 숫자를 서식화하는 등 유용할 수 있습니다.\n\n이 경우 함수가 아무것도 반환하지 않도록하고, 사용 중인 단위(시간, 분, 초)에서 곱한 값으로 회전 값을 할당하려고 합니다.\n\n버튼은 \"부드러운(smoth)\"이라는 새로운 상태 속성을 생성하는데, 체크박스가 선택되었는지에 따라 null 또는 \"1\"이 됩니다.\n\n그 결과, 시계의 전체 \"로직\"은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction clockUpdate() {\n  \n  const\n    now = new Date(),\n    hours = now.getHours(),\n    ms = (\n      clock.smooth ?\n      now.getMilliseconds() / 1000 :\n      Math.max(0, (now.getMilliseconds() - 940) / 60)\n    );\n    \n  clock.seconds = now.getSeconds() + ms;\n  clock.minutes = now.getMinutes();\n  clock.hours = hours % 12;\n  clock.amPm = hours >= 12 ? \"PM\" : \"AM\";\n  \n  requestAnimationFrame(clockUpdate);\n  \n} // clockUpdate\n\nclockUpdate();\n```\n\nclockUpdate 함수는 시간을 가져와서 \"hours\"를 분리하고, \"hours\"와 AM/PM을 모두 setting하는 데 여러번 호출하기 때문에, clock.smooth가 느슨한 true인지 확인하고, 그렇다면 ms를 리터럴 값을 1000으로 나눈 것으로 설정하여 초에 추가합니다. Math.max와 간단한 수학을 사용하여, 마지막 60ms에서만 두드리는 두 번째 손을 움직일 수 있습니다.\n\n값을 state에 연결하고, state가 시계로의 변환을 처리합니다. 이 점이 좋은 점은 논리와 외관을 구분할 수 있으므로 논리를 건드리지 않고 외관을 계속 변경할 수 있다는 것입니다.\n\n이것을 생각해보세요. 고려해보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n시계.시간 = 8;\n시계.분 = 30;\n시계.초 = 0;\n시계.오전오후 = \"오후\";\n```\n\n이것만으로 시계를 8:30:00 PM으로 설정할 수 있어요. 그저 이것뿐입니다. 나머지는 모두 DOM에서 \"템플릿\"이에요.\n\n참고로, setInterval 대신 requestAnimationFrame을 사용하는 이유는 setInterval이 종종 초를 \"건너뛰기\" 때문에 부드러운 애니메이션이 되게 하고 싶기 때문이에요. \"실제 세계\"에서는 아마 CSS를 사용해서 애니메이션을 구현할 텐데, 상태 속성이 어떻게 작동하는지 보여주고 싶어서 이렇게 했어요.\n\n# 구현\n\n<div class=\"content-ad\"></div>\n\n새 \"State\" 객체는 domjon.js의 나머지 부분에서 몇 가지 구현 변경이 필요합니다. 이 기사의 이 부분은 새로운 코드를 대략적으로 설명하면서 매우 지루해질 것입니다. 지루한 걸 좋아하지 않나요? 그렇다면 위에 대해 만족하고 다음 기사를 기다리세요.\n\n먼저 DOM-JON 메소드, 속성 및 변수에 대해 이야기해 봅시다. \"internal\"로 표시된 것들은 최종 개발자에게 노출되지 않습니다.\n\n## Object.__forEachEnumerable\n\n```js\n  __forEachEnumerable : { value : function(callback, thisArg, ...args) {\n    for (const [key, value] of this.__entries) {\n      callback.call(thisArg, key, value, ...args);\n    }\n    return this;\n  } }, // Object.prototype.__forEachEnumerable\n```\n\n<div class=\"content-ad\"></div>\n\n객체의 열거 가능한 키/값 쌍을 통해 반복하기 위한 foreach. \"myObject.__entries.foreach\"를 직접 입력할 수도 있지만, 저는 이것이 별도의 함수로 만들어지기를 정말로 원합니다.\n\n내부에서 사용할 텍스트(const texts)\n\n코드 전반에 걸쳐 텍스트/핸들러를 모두 놓고 다니는 대신, 나중에 다른 언어를 구현하고 싶을 때 많은 작업이 이미 설정되어 있고 준비되어 있는 지역 객체로 넣었습니다.\n\n## 폭탄 (내부, Error를 확장함)\n\n<div class=\"content-ad\"></div>\n\n```js\n// 어떤 누군가가 우리에게 폭탄을 설치했습니다.\nBomb = class extends Error {\n  constructor(name, method, ...args) {\n    super(`${method} - ` + texts.bomb[name](...args));\n    this.name = 'DOMJON.JS';\n  }\n}, // 폭탄\n```\n\n\"DOMJON.JS\" 일부로 식별하는 오류를 \"던질\" 수 있는 오류입니다. 적절한 텍스트 콜백을 호출하고 원하는 인수를 전달합니다.\n\n## 폭탄 처리 함수 (내부)\n\n값에 대해 많이 하는 \"표준\" 확인이 많이 있습니다. JavaScript가 마구 진행하게 두는 대신에 오류를 던지는 것이 편리합니다. 프로그램에서 할 수 있는 가장 좋은 오류 처리는 포기하고 \"넌 지나갈 수 없어!!!\" 라고 말하는 것이라고 저는 굳게 믿습니다. 유감스럽게도 JavaScript와 HTML은 이런 면에서 너무나 관대합니다.\n\n<div class=\"content-ad\"></div>\n\n`throw`은 너의 친구야, 자주 사용해. 정말 많이.\n\n```js\n    bombIfNullish = (value, ...args) => {\n      if (null != value) return value;\n      throw new Bomb(...args);\n    }, // state.#bombIfNullish\n\n    bombLengthMismatch = (value1, value2, method) => {\n      if (value1.length == value2.length) return;\n      throw new Bomb(\"lengthMismatch\", method, value1.length, value2.length);\n    }, // bombLengthMismatch\n\n    bombTypeMismatch = (value, types, method) => {\n      if (\n        (\"undefined\" !== value) ||\n        ( (\"Array\" == types.__type) && types.includes(value.__type) ) ||\n        ( types === value.__type )\n      ) return value;\n      throw new Bomb(\"typeMismatch\", method, types, value.__type);\n    }, // bombTypeMismatch\n```\n\nbombTypeMismatch 함수의 \"types\" 매개변수는 타입명을 포함한 문자열이거나 유효한 타입명을 포함하는 배열이어야 합니다.\n\n어리석은 생각이지만, 아마 이것들을 확장된 Bomb 클래스의 정적 메소드로 만들어야 할지도 모르겠네? 좀 더 고민을 해봐야겠다.\n\n<div class=\"content-ad\"></div>\n\n또 기억해야 할 점은 myVar != null은 null과 undefined 둘 다에 대해 true이라는 것입니다. (그리고 다른 경우는 없습니다). 알아 두면 유용하며, 약삭빠진 전문가들에게는 \"너무 어려워\"라며 초보자들을 현혹시키는 데 사용합니다. 계속 말하듯이, 느슨한 형변환을 활용하는 대신 싸우는 대신 느슨한 형변환을 활용하면 일이 훨씬 쉬워집니다.\n\n## warn 함수 (내부 정보)\n\nconsole.warn을 래핑하여 적절한 \"texts\" 메서드를 호출합니다.\n\n```js\nwarn = (messageName, ...args) => {\n  console.warn(texts.warn[messageName], ...args);\n}, // warn\n```\n\n<div class=\"content-ad\"></div>\n\n## makeData.delimiters (내부)\n\n우리는 DSS에 \"＆\"을 \"__stateName\"으로 정의하였습니다.\n\n```js\n     delimiters : [\n        [ \"=\", \"data\",   \"value\" ],\n        [ \"?\", \"attr\",   \"name\" ],\n        [ \".\", \"attr\",   \"className\" ],\n        [ \"#\", \"attr\",   \"id\" ],\n        [ \"&\", \"define\", \"__stateName\" ],\n        [ \"@\", \"define\", \"__makePlace\" ],\n        [ \":\", \"data\",   \"namespace\" ],\n        [ \"_\", \"data\",   \"special\" ]\n      ], // makeData.delimiters\n```\n\n## document.__make\n\n<div class=\"content-ad\"></div>\n\ndocument.__make의 책임에 대한 많은 변화가 있었어요. Element.__make의 \"부담\"을 덜어 주기 위해서요.\n\n```js\ndocument.__defineProps( {\n\n    __createState : (initialProps) => new State(initialProps),\n\n    __make : (selector, ...attach) => {\n\n      let\n        parts = { attr : {}, data : {}, define : {} },\n        value;\n\n      for (const [ delimiter, typeName, attrName ] of makeData.delimiters) {\n        [selector, value] = selector.split(delimiter, 2);\n        if (value) parts[typeName][attrName] = value;\n      }\n\n      const\n        tagName = (selector || \"span\").toLowerCase(),\n        namespace = (\n          parts.data.namespace ? (\n            (parts.data.namespace.indexOf(\"http://\") === 0) ?\n            parts.data.namespace :\n            (\n              makeData.namespaces[parts.data.namsspace.toUpperCase()] ??\n              makeData.namespaces.HTML\n            )\n          ) : makeData.namespaces.HTML\n        ),\n        element = Object.assign(\n          document.createElementNS(namespace, tagName),\n          parts.attr\n        );\n\n      if (!parts.define.__empty) {\n        parts.define.__forEachEnumerable(element.__define, element);\n      }\n\n      if (parts.data.value) element.setAttribute(\n        makeData.values[tagName] ?? \"value\",\n        parts.data.value\n      );\n\n      if (parts.data.special) {\n        const attrName = makeData.special[tagName];\n        if (attrName) element.setAttribute(attrName, parts.data.special);\n        else warn(\"underscoreNotSupported\", tagName, parts.data.special);\n      }\n      \n      if (attach) element.__attach(...attach);\n      \n      if (element.__stateName) element.__closestState.addMonitor(\n        element.__stateName,\n        element.value ?? element.textContent ?? \"\",\n        element\n      );\n      \n      if (element.__makeFilters) {\n        element.__addFilters(element.__makeFilters);\n      }\n\n      if (element.__makeParent) {\n        if (!element.__makePlace) element.__define(\"__makePlace\", \"beforeend\");\n        // f*** case sensitivity\n        switch (element.__makePlace.toLowerCase()) {\n\n          case \"replacechildren\":\n            element.__makeParent.replaceChildren(element);\n            break;\n\n          case \"replacewith\":\n            element.__makeParent.replaceWith(element);\n            break;\n\n          default:\n            element.__makeParent.insertAdjacentElement( (\n              element.__makePlace ?\n              element.__makePlace.toLowerCase() :\n              \"beforeend\"\n            ), element);\n\n        }\n      }\n\n      return element;\n\n    } // document.__make\n\n  } ); // document extensions\n```\n\n큰 변화는 다음과 같아요:\n\n- \"warn\"이 warn() 함수를 사용하도록 변경되어서 저의 texts() 조회를 사용하도록 했어요.\n- 새 Element에 __stateName이 설정되었다면, 이 노드를 상태에 연결해요.\n- __stateFilters가 설정되었다면 (__attach에 의해), 그 노드 필터를 추가해요. 이를 적용하기 위해서는 노드가 할당된 후에 해야 해요. 그래야 이 객체에 상태가 할당되었다면, __closestState가 그것을 찾을 수 있어요.\n- 부모에 추가하는 작업은 여기서 이루어져요. Element.__make에서 매개변수로 __makeParent를 전달하는 것보다 여기서 해요. __makeParent는 또한 Element.__closestState 내에서 사용되어 부모 노드로 이동할 수 있어요. DOM이 연결/조립되기 전에 부모에 추가하지요.\n- ReplaceChildren과 RepalceWith가 추가되었고, insertAdjacentHTML 전에 switch/case를 통해 가로채졌어요.\n- 명확성을 위해 변수 이름을 \"e\"에서 \"element\"로 바꾼 거에요. 여기에는 최소주의와 \"바이트 집착\" 사이의 차이가 있지만, 저는 정말 전자를 선호해요.\n\n<div class=\"content-ad\"></div>\n\n내가 항상 말하는 것처럼:\n\n## elementData.canType\n\n이 셋은 Element.__attach 내에서 특정 canAttach 유형을 처리하기 위해 사용됩니다. \"Bomb\"와 그와 관련된 함수를 사용하도록 다시 작성되었습니다.\n\n```js\n    canType : {\n\n      \"Array\" : (target, arg, canAttach) => {\n\n        bombTypeMismatch(arg, \"Array\", `<${target.tagName}>.__attach`);\n        bombLengthMismatch(arg, canAttach, `<${target.tagName}>.__attach`);\n        for (let i = 0, iLen = args.length; i < iLen; i++) {\n          this.setAttribute(canAttach[i], args[i]);\n        }\n\n      }, // elementData.canType.Array\n\n      \"String\" : (target, arg, canAttach) => {\n\n        bombTypeMismatch(\n          arg,\n          [ \"Number\", \"String\" ],\n          `<${target.tagName}>.__attach`\n        );\n        target.setAttribute(canAttach, arg);\n\n      } // elementData.canType.String\n\n    }, // elementData.canType\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n## elementData.argType\n\n\"State\" 타입이 정의로 추가되는 것을 처리했습니다:\n\n```js\n    argType : {\n\n      \"Array\" : (target, arg) => target.__make(...arg),\n\n      \"State\" : (target, arg) => target.__define(\"__state\", arg)\n\n    }, // elementData.argType\n```\n\n<div class=\"content-ad\"></div>\n\n## elementData.eachAttr\n\n이 함수는 `forEachEnumerable`을 통해 사용되는 콜백이며, \"call\" 설정을 통해 Element가 조작되는 \"thisArg\"로 설정됩니다. 따라서 아래의 \"this\"는 Element 객체를 가리킵니다.\n\n```js\n   eachAttr : function(key, value) {\n\n      switch (key) {\n\n        case \"__filters\":\n          this.__define(\"__makeFilters\", value);\n          return;\n\n        case \"__stateName\":\n        case \"__makePlace\":\n        case \"__makeParent\":\n          this.__define(key, value);\n          return;\n\n        case \"dataset\":\n          bombTypeMismatch(\n            value,\n            \"Object\",\n            \"Element.prototype.__setAttr - setting 'dataset'\"\n          );\n          Object.assign(this.dataset, value);\n          return;\n\n        case \"style\":\n          this.__setStyle(value);\n          return;\n\n      }\n      \n      switch (value.__type) {\n        case \"Array\":\n        case \"Function\":\n        case \"Object\":\n          this[key] = value;\n          return;\n      }\n\n      this.setAttribute(key, value);\n\n    }, // elementData.eachAttr\n```\n\n여러 가지 값들을 테스트하고 비교의 다대일을 테스트하기 때문에, 스위치/케이스는 객체나 맵 조회보다 더 깔끔합니다. 몇몇 과격한 사람들이 반대 의견을 내지르더라도, 중요한건 아니에요.\n\n<div class=\"content-ad\"></div>\n\n짧은 회로 중단 반환의 사용은 코드를 더 깔끔하게 만든다고 생각해요.\n\n스위치/케이스/리턴을 사용해 위의 것을 \"너무 복잡하다\"거나 \"이해하기 어렵다\"고 말하는 사람들이 실제로 있다는 것에 정말 경악스럽고 화나요.\n\n## elementData.eachStyle\n\n__forEachEnumerable 내부에서 요소에 \"this\"를 적용하는 간단한 래퍼\n\n<div class=\"content-ad\"></div>\n\n```js\n    eachStyle : function(key, value) {\n\n      this.style.setProperty(key, value);\n\n    } // elementData.eachStyle\n```\n\n이 부분은 \"의미 없는\" 것처럼 보일 수 있지만, 스타일 속성을 객체에 할당하지 않고 직접 변경하는 이유는 객체화할 수 없는 유효한 속성들이 있기 때문입니다. 이 중 하나가 \"사용자 정의 속성\" (즉, CSS 변수) 입니다.\n\n예를 들어, \" — rotateHand:20deg;\" 와 같은 값을 설정하고 싶다고 해봅시다.\n\n```js\nmyElement.style[\"--rotateHand\"] = \"20deg\"; // 잘못된 문장\n\nObject.assign(myElement.style, { \"--rotateHand\" : \"20deg\"; }); // X\n\nmyElement.style.setProperty(\"--rotateHand\", \"20deg\"); // 동작함\n```\n\n<div class=\"content-ad\"></div>\n\n이걸 무시하고 강제로 해야하는 것은 별로 좋아하지 않지만, 솔직히 스크립트에서 스타일을 설정하는 빈도가 충분히 낮아 추가적인 오버헤드가 성능에 영향을 미치지 않을 만큼 희박한 것 같아요.\n\n## Element.prototype.__addFilters\n\n노드 필터를 이 객체를 가리키는 노드 필터를 연결된 상태에 추가합니다.\n\n```js\n    __addFilters : function(filters, state) {\n      \n      if (!this.__stateName) throw new Bomb(\n        \"filterNoStateName\",\n        \"Element.prototype.__addFilters\",\n        this.tagName\n      );\n\n      state = state ?? this.__closestState;\n      if (!state) throw new Bomb(\n        \"filterNoStateObject\",\n        \"Element.prototype.__addFilters\",\n        this.tagName\n      );\n\n      if (\"Array\" !== filters.__type) filters = [ filters ];\n      for (const callback of filters) {\n        state.addNodeFilter(this.__stateName, this, callback);\n      }\n\n    }, // Element.prototype.__addFilters\n```\n\n<div class=\"content-ad\"></div>\n\n상태가 없으면 폭탄을 설치합니다. 모든 상태는 우리에게 속해 있어요. 필터가 배열이 아니라면 배열로 넣어서 같은 루프/세트를 공유할 수 있도록 해주세요. 그런 다음 루프를 돌고 해당 상태의 setter를 호출하세요.\n\n## Element.prototype.__attach\n\n기능의 대부분이 하위 함수로 분리되어 있기 때문에, 이 핵심 부분은 알파 버전에서 크게 변경되지 않았어요.\n\n```js\n    __attach : function() {\n\n      // 루프 밖에서 this를 가져와요!\n      const canAttach = (\n        elementData.canAttach[this.namespaceURI.toLowerCase()] ??\n        elementData.canAttach.HTML\n      )[this.tagName.toLowerCase()] || true;\n\n      for (let arg of arguments) {\n\n        // undefined == null이지만 0/false/\"\"은 아니에요\n        bombIfNullish(\n          arg,\n          \"undefinedAttachment\",\n          \"Element.prototype.__attach\",\n          this.tagName\n        );\n\n        // 이 두 인수 유형은 모든 Element에 할당될 수 있어요\n        switch (arg.__type) {\n\n          case \"Object\":\n            this.__setAttr(arg);\n            continue;\n\n          case \"Function\":\n            arg = arg(this);\n            if (null == arg) continue;\n            // 그렇지 않으면 아래로 이동해요\n\n        }\n\n        // 그러나 이 인수는 비보이드 또는 특수 보이드 유형에서만 수행할 수 있어요\n        if (canAttach) {\n          (\n            elementData.canType[canAttach.__type] ??\n            elementData.argType[arg.__type] ??\n            elementData.append\n          )(this, arg, canAttach);\n          continue;\n        }\n        // 그리고 진지해요: nullish 코얼리싱에 모두 찬사를!\n\n        throw new Bomb(\n          \"sterile\",\n          \"Element.prototype.__attach\",\n          this.tagName\n        );\n\n      }\n\n      return this;\n\n    }, // Element.prototype.__attach\n```\n\n<div class=\"content-ad\"></div>\n\n대부분은 일반 오류가 발생하는 대신 Bomb으로 바뀝니다.\n\n## Element.prototype.__closestState\n\n```js\n   __closestState : {\n\n      get : function() {\n        let walk = this;\n        do {\n          if (walk.__state instanceof State) return walk.__state;\n        } while (walk = walk.parentNode ?? walk.__makeParent);\n        throw new Bomb(\n          \"noClosestState\",\n          \"Element.prototype.__closestState\",\n          this.tagName\n        );\n      }\n\n    }, // Element.prototype.__closestState\n```\n\n가장 가까운 요소를 찾기 위해 DOM을 탐색합니다. __state 속성을 포함하는 요소를 찾을 때까지 계속 합니다. 상태를 찾지 못하면 Bomb이 발생합니다. 만약 parentNode가 없는 경우 DOM 탐색은 Element.__makeParent로 fallback되어, 실제 첨부를 수행하기 전에 연결된 상태를 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n요소가 실제로 살아있기 전에 요소의 모든 속성을 설정하는 것이 이론적으로 더 빠르고 효율적이며 (이론상의?) 머리 아픈 문제를 피할 수 있습니다. 라이브 DOM에 대한 \"전문가\" 의견 중 얼마나 사실인지 더 테스트해봐야겠죠. 이미 그 중 상당 부분은 알고 있지만, 우리가 얼마나 더 빠진 부분들을 알아야 할지는 궁금합니다.\n\n제가 자바스크립트의 getter와 setter를 얼마나 좋아하는지 언급했었나요?\n\n## Element.prototype.\\_\\_make\n\n이것은 단순한 래퍼(wrapper)로 다시 만들어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n   __make : function(selector, ...args) {\n\n      return document.__make(\n        selector,\n        { __makeParent : this },\n        ...args\n      );\n\n    }, // Element.prototype.__make\n```\n\n새 Element가 첨부될 때 자신을 __makeParent로 추가합니다. 그 외에도 무엇인가요? (아직은 많이 없습니다.)\n\n## Element.prototype.__setAttr\n\nelementData.eachAttr를 사용하여 속성과 속성을 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n    __setAttr : function(attr) {\n\n      bombTypeMismatch(attr, \"Object\", \"Element.prototype.__setAttr\");\n      attr.__forEachEnumerable(elementData.eachAttr, this, this);\n      return this;\n\n    }, // Element.prototype.__setAttr\n```\n\n당연히 `__type`에 따라 일반 객체가 아닌 경우에는 폭탄 터질 겁니다.\n\n## Element.prototype.__setStyle\n\n일반 객체(key/value 쌍)에서 스타일을 \"this\"에 설정합니다. 확장된 객체는 폭탄 터질 겁니다. 기능적으로 `__setAttr`과 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n__setStyle : function(style) {\n\n  bombTypeMismatch(style, \"Object\", \"Element.prototype.__setStyle\");\n  style.__forEachEnumerable(elementData.eachStyle, this);\n  return this;\n\n} // Element.prototype.__setStyle\n```\n\n## StateRender (내부용)\n\n이 **정적 클래스**는 DOM 업데이트를 대기열에 넣는 데 사용됩니다. 그들이 발생하는 대로 렌더링하는 대신, 한꺼번에 적용할 수 있도록 일괄 처리합니다. 더 간단한 프로그램에서는 오버헤드가 발생할 수 있지만, 프로젝트가 커지면 스크립팅이 해제될 때까지 DOM을 지속적으로 변경하지 않는 것이 더 성능이 좋을 수 있습니다. 그리고 솔직히 말하자면, 이것이 부정적인 영향을 미칠만큼 프로젝트가 작다면, 아마도 그 정도의 부담을 충당할 수 있을 겁니다!\n\n```js\nStateRender = class {\n\n  static pending = false;\n  static renders = new Set();\n\n  static renderUpdate(state) {\n\n    state.renders.forEach( (store) => {\n      store.nodes.forEach( (nodeData, node) => {\n        let value = store.value;\n        nodeData.filters.forEach(\n          (filter) => value = filter(value, node)\n        );\n        if (value != null) node[nodeData.method] = value;\n      } )\n    } );\n    state.renders.clear();\n    state.pending = false;\n\n  } // StateRender.#renderUpdate\n\n  static queUpdate(store) {\n\n    this.renders.add(store);\n    if (!this.pending) {\n      this.pending = setTimeout(this.renderUpdate, 0, this);\n    }\n\n  } // StateRender.queUpdate\n\n}, // StateRender\n```\n\n<div class=\"content-ad\"></div>\n\n거기 중요한 것은 filter() 메커니즘이 null 결과를 만나면 Node에 값을 설정하지 않는다는 것입니다. 이 방법은 작동하지만 여러 개의 \"노드 필터\"가 필요한 경우 문제를 일으킬 수 있습니다. 이 메커니즘을 강화해야 할 필요가 있다고 생각하지만 어떻게 해야할지 확실히는 모르겠어요. filter의 인수 개수를 늘리고 배열이나 객체를 반환하여 원래 값도 전달하게 할까요? 아니면 \"설정하지 말기\" 부울 값을 추가할까요? 잘 생각해보고 내일 답을 드릴게요.\n\n![BetterJSDOMBuildingWithDOM](/assets/img/2024-05-01-BetterJSDOMBuildingWithDOM-JONPart3TheStateObject_1.png)\n\n스크립팅 실행의 해제를 가로채는 것은 \"tricky\"합니다. 그래서 저는 제로 타임아웃을 설정하여 흉물로 해결했어요. 작동은 합니다. 다만 \"경합 조건\"에 대해 우려되고 있어요.\n\n# 상태 객체\n\n<div class=\"content-ad\"></div>\n\n마침내 여기에 도착했고 준비가 완료되었어요...\n\n### State.#properties\n\n내부 사용 변수로 getter/setter 속성에 관한 모든 데이터를 추적하는 데 사용됩니다. 이것은 key가 속성 이름이고, 값이 getter와 setter에서 사용하는 값을 포함한 \"store\" 객체인 \"Map\"입니다.\n\n### State::constructor\n\n<div class=\"content-ad\"></div>\n\n```js\n      constructor(initialProps) {\n\n        this.__define(\"__type\", \"State\");\n        this.#properties = new Map();\n        if (\"undefined\" === typeof initialProps) return;\n\n        bombTypeMismatch(initialProps, \"Object\", \"State::constructor\");\n        initialProps.__forEachEnumerable(\n          this.addProperty,\n          this\n        );\n\n      } // State::constructor\n```\n\n__type을 정의해서 (계산 비용이 많이 드는) Object.prototype.__type 메서드를 건너뛸 수 있습니다.\n\n맵을 생성합니다.\n\n만약 초기 프로퍼티를 전달하지 않았다면 간편하게 종료합니다.\n\n<div class=\"content-ad\"></div>\n\n그렇다면 우리가 제네릭 오프젝트를 전달하지 않으면 실패합니다. 만약 제네릭이라면 각 속성을 키/값으로 추가합니다.\n\n여기서 순서를 바꾸겠습니다...\n\n## State.addProperty\n\n이 부분은 상당히 많은 작업이 필요하지만, 설정해야 할 것이 많습니다. 여기서 조각조각 나눠 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n      addProperty(name, data) {\n        \n        let\n          value, setFilters, getFilters,\n          store = this.#properties.get(name);\n          \n        if (\"Object\" == data.__type) {\n          value = data.value;\n          getFilters = data.getFilters;\n          setFilters = data.setFilters;\n        } else value = data;\n          \n        if (\"undefined\" !== typeof store) {\n          if (\"undefined\" !== typeof value) store.value = value;\n          if (getFilters) store.addGetFilters(getFilters);\n          if (setFilters) store.addSetFilters(setFilters);\n          return store;\n        }\n```\n\n만약 이 \"name\"에 대한 #properties에 \"store\"가 있으면, 값, setFilters 및 getFilters가 이미 존재할 수 있습니다.\n\n전달된 데이터가 일반 객체인 경우, 값을 및 필터를 추출합니다. 일반 객체가 아니라면 값이어야 합니다. 이렇게 하면 \"값\"만 또는 정보 객체를 전달할 수 있습니다. set/getFilters도 인수로 전달할 수 있는 기능을 추가해야 할까요?\n\n안타깝게도 객체 구조 분해는 새로운 var/let/const로만 작동하며 기존 변수에서는 작동하지 않습니다. 따라서 이를 억지로 처리해야 합니다. 그렇지 않으면 VAR를 사용하는 것으로 돌아가야 합니다. 아니, 지금 VAR를 사용할지도 모르겠네요.\n\n<div class=\"content-ad\"></div>\n\n실은, let/const의 존재만으로 var을 완전히 사용하지 말아야 하는 이유는 전혀 없어요. 이건 마치 \"레이아웃으로 테이블 사용하지 말라\"를 \"테이블 사용 금지\"로 변형한 것과 같거나, \"적절한 경우 `em` / `strong` 사용\"을 \"절대 `b` 나 `i` 사용하지 말라\"로 만든 것 같아요. 100% 무지한 헛소리가 들려오는군요.\n\n게다가 이게 제 코드를 작성하는 동안, 글이나 문서를 작성하는 이유가 여기 있어요. 저는 진행하면서 더 나은 방법을 떠올릴 수 있거든요.\n\n```js\naddProperty(name, ...args) { // valueOrObj, getFilters, setFilters\n  \n  let store = this.#properties.get(name); \n  \n  if (\"Object\" == args[0].__type) {\n    var { value, getFilters, setFilters } = args[0];\n  } else {\n    var [ value, getFilters, setFilters ] = args;\n  }\n```\n\n와우, 좋아요. 보세요, VAR는 함수 레벨 스코프만 필요한 경우에 뛰어날 수 있어요. 이렇게 하면 우리가 원하는 속성의 객체를 args[0]로 전달할 수 있고, 또는 값, getFilters, 그리고 setFilters를 인수로 전달할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n반응적인 랜트: 네, '인수(argument)'에 대해 이야기해볼게. 어제 나랑 놀려던 놈이 있었어. '그건 파라미터야, 넌 자기가 지어낸 이름을 쓰고 있는 거잖아!' 라는 식으로 듣기는 했지.\n\n그래도 어찌나 자기가 억지로 만들어낸 것인양 내 탓을 하는 건지. DOM에 있을 때는 여전히 '속성(attributes)'이라고 하면서, 난 '프로퍼티(properties)'와 '메소드(methods)'라는 용어를 만들어냈다고 비웃기도 했지. 입을 털기 전에 좀 배워라, 친구들아.\n\n사실 나는 요즘 여섯 달 동안 '인수(arguments)'라는 용어와 'arguments' 객체를 사용하면서 다른 개발자들과 야박한 논쟁을 자주 일으켰다는 사실에 놀랍다. 뭐지?!?\n\n다음에는, 만약 스토어가 있다면, 새로운 값을 그냥 추가하고 필터를 적용할 수 있어. 나중에 호출된 메소드들은 나중에 다룰게. 실제로 이 부분을 쓸 때는 그 메소드들이 정의되지 않았었거든.\n\n<div class=\"content-ad\"></div>\n\n```js\n        if (\"undefined\" !== typeof store) {\n          if (\"undefined\" !== typeof value) store.value = value;\n          if (getFilters) store.addGetFilters(getFilters);\n          if (setFilters) store.addSetFilters(setFilters);\n          return store;\n        }\n```\n\n위 코드에서 undefined인지를 확인함으로써 값이 바뀌지 않고 필터를 설정하기 위해 객체를 사용할 수 있습니다. 저는 함정으로 nullish를 사용할 것입니다. 그러나 \"null\"이 실제로 설정하고자 하는 유효한 값일 수도 있습니다.\n\n옵션!\n\n그리고 이미 store가 있을 경우, 참조를 반환하여 빠져나가면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n여기까지 왔는데 아직 저장소가 없으니 하나를 만들어야 합니다. 먼저 기존의 열거할 수 없는 속성 또는 메서드와 동일한 이름을 가진 getter/setter를 만들고 있는지 확인해 봅시다.\n\n```js\n        if ((name in this) && !this.__hasOwn(name)) throw new Bomb(\n          \"stateReservedKey\",\n          \"State.addProperty\",\n          name\n        );\n```\n\n예약어 체크는 중요합니다. 이 체크를 하지 않아서 비슷한 코드가 망가졌던 횟수를 세어보니 많았죠.\n\n이 시점에서 정의되지 않은 이름을 \"\"로 필터링하세요.\n\n<div class=\"content-ad\"></div>\n\n우리의 store를 만들어 보세요:\n\n```js\nstore = {\n  addGetFilters: function(filters) {\n    if (!(filters instanceof Array)) filters = [filters];\n    for (const filter of filters) this.getFilters.add(filter);\n  },\n  addSetFilters: function(filters) {\n    if (!(filters instanceof Array)) filters = [filters];\n    for (const filter of filters) this.setFilters.add(filter);\n  },\n  getFilters: new Set(),\n  setFilters: new Set(),\n  name,\n  nodes: new Map(),\n  state: this,\n  value\n};\n```\n\n필터를 추가하고 세트와 맵을 만드는 몇 가지 함수들이 있어요.\n\n<div class=\"content-ad\"></div>\n\n저장소(store)에서 State에 대한 참조와 getter/setter 이름 state을 전달해 드립니다. 이는 이벤트 처리에 도움이 될 수 있습니다. 경우에 따라 \"this\" 범위를 잃을 때입니다. 그리고 기억하세요:\n```js\n{ name }\n```\n는 다음과 동일한 기능을 합니다:\n```js\n{ \"name\": name }\n```\n<div class=\"content-ad\"></div>\n\n많은 JS 프로그래머들이 이것을 모르다는 점에 놀랐어요.\n\n\"성능\"을 위해 \"add\" 함수들을 독립형으로 이동시켜서 포함을 더 작고/쉽게 만들어보려는 유혹을 겪고 있어요. \"베타 정리\" 중에 어떻게 진행되는지 보고 RC1으로 진행하기 전에 판단할 거예요.\n\n이제 추가하려는 필터들을 붙여주세요.\n\n```js\nif (getFilters) store.addGetFilters(getFilters);\nif (setFilters) store.addSetFilters(setFilters);\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 \"this.#setProperties\"에 우리 상점을 넣어주세요.\n\n```js\n        this.#properties.set(name, store);\n```\n\n마지막으로:\n\n```js\n       this.__define(name, {\n\n          enumerable : true,\n\n          get : () => {\n            let value = store.value;\n            store.getFilters.forEach( (filter) => value = filter(value) );\n            return value;\n          },\n\n          set : (value) => {\n            store.setFilters.forEach( (filter) => value = filter(value) );\n            store.value = value;\n            StateRender.queUpdate(store);\n          }\n\n        } );\n\n        return store;\n\n      } // State.addProperty\n```\n\n<div class=\"content-ad\"></div>\n\nThis is a new getter/setter, so we need to assign it the handlers. When we iterate through our filters, for the setter, we enqueue an update. Then, we return the store, and we're good to go.\n\nBy the way, I'm not a huge fan of Array.forEach, but I'm using it here. I'll use the tools available even if I don't like their implementations and complain about them constantly. It seems like many people don't grasp the idea of criticizing things you actually use.\n\n## State.addNodeFilter\n\nAs the name suggests, this function adds a filter to the list that runs when a State property is \"set\" before applying it to the Node.\n\n<div class=\"content-ad\"></div>\n\n```js\naddNodeFilter(name, node, callback) {\n\n  const\n\n    store = bombIfNullish(\n      this.#properties.get(name),\n      \"nameNotDefined\", \"State.addNodeFilter\", name\n    ); // store\n    \n    const nodeData = bombIfNullish(\n      store.nodes.get(node),\n      \"propHasNoNodes\", \"State.addNodeFilter\", name\n    ); // nodeData\n\n  bombTypeMismatch(callback, \"Function\", \"State.addNodeFilter\");\n    \n  nodeData.filters.push(callback);\n\n} // State.addNodeFilter\n```\n\n저장소를 가져오세요. 저장소에 없으면 에러 발생. 저장소.nodes에 노드 데이터가 없으면 에러 발생. 전달된 콜백이 함수가 아닐 시 에러 발생...\n\n그렇지 않으면 stores.nodes[node].filters Map에 추가합니다.\n\n## State.addGetFilter\n\n<div class=\"content-ad\"></div>\n\n해당 코드는 주어진 이름으로부터 상점을 가져와요. 만약 상점이 존재하지 않으면 오류를 발생시켜요. 그렇지 않으면 해당 필터를 추가해요.\n\n그럼, 나는 지도를 정말로 좋아해.\n\n<div class=\"content-ad\"></div>\n\n첫 번째와 같아. 조금 크고 추한게 그절망적인데.\n\n```js\n      addSetFilter(name, filters) {\n\n        const store = bombIfNullish(\n          this.#properties.get(name),\n          \"nameNotdefined\", \"State.addSetFilter\", name\n        );\n        \n        store.addSetFilters(filters);\n\n      } // State.addSetFilter\n```\n\n나는 두 메소드가 호출하는 단일한 프라이빗 함수를 만들어 \"Set\"와 \"Get\"이 적절한 곳에 교체되도록 하고, 전체 코드 크기/복잡성을 줄이기 위해 이 함수들을 래퍼로만 사용하는 것이 조금 유혹스러운데. 아마도 Beta2의 정리 중에 전체 코드 크기를 줄이는 데 도움이 되도록 이것을 실행할 것 같다. 음... 아마 \"Set\"을 확장하는 클래스를 만드는 건 어떨까?\n\n## State.addMonitor\n\n<div class=\"content-ad\"></div>\n\n돈을 여기 있어. 우리 __make 루틴이 가장 자주 호출하는 루틴이야. 이것도 작은 조각으로 나눠볼게.\n\n```js\n      addMonitor(name, value, node) {\n\n        if (!(node instanceof Node)) {\n          if (\"undefined\" == typeof node) node = new Text();\n          else throw new Bomb(\n            \"notNode\",\n            \"State.addMonitor\",\n            typeof node\n          );\n        }\n```\n\n만약 노드가 전달되지 않으면, 우리는 우리의 컨테이너로 텍스트 노드를 생성할 거야. 이것은 dom-jon에서 문장 중간에 노드를 추가하고 싶을 때 유용할 수 있어. 생각해보셔:\n\n```js\ndocument.body.__make(\n  \"p\",\n  \"This is \", myState.addMonitor(\"isA\", \"a test\"), \"!\"\n);\n\nmyState.isA = \"the best\";\n\n// 이제 그 단락은 \"This is the best!\" 라고 말해\n```\n\n<div class=\"content-ad\"></div>\n\n텍스트 노드를 상태에 연결하기 쉽게 하는 약어나 함정을 추가할 수 있습니다. [ \"&isA\", \"a test\" ]와 같이 __make에 의해 가로채집니다.\n\n이것이 노드에서만 작동하므로 정의되지 않았으면 우리는 중단됩니다.\n\n```js\n        const\n          self = this,\n          store = this.addProperty(name, value);\n          \n        let method = \"textContent\";\n```\n\n저장소가 필요하며, 몇 가지 콜백을 \"this\"의 사본으로 작동하도록 만들어야 합니다. (나중에 구현을 정리하면 후자가 변경될 수 있음). 마지막으로 textContent(기본값)로 메서드를 설정합니다. 나는 \"나는 그걸 싫어\" 하고 나도 다시 \"var\"을 사용할지도 모른다. \"method\"는 노드 값이 요소에 적용되는 방법입니다. 대부분의 태그는 textContent를 사용하지만, textNode는 \"data\"가 되고, input/textarea는 value가 될 것입니다. 그러나 type=\"checkbox\"나 type=\"radio\"일 경우 false는 체크 해제되고, true는 선택됩니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로 nodeTypes를 테스트해야 합니다.\n\n```js\n        nodeSwitch: switch (node.nodeType) {\n     \n          case Node.ELEMENT_NODE:\n            if (\"value\" in node) method = \"value\";\n            switch (node.tagName.toLowerCase()) {\n```\n\n만약 \"value\" 속성이 있다면 textContent 대신에 설정되어야 하는 건 당연하죠.\n\n```js\n              case \"input\":\n                switch (node.type) {\n                  case \"checkbox\":\n                  case \"radio\":\n                    self[name] = node.checked ? node.value : null;\n                    node.addEventListener(\"input\", (event) => {\n                      // self[name] will trigger the setter\n                      self[name] = (\n                        event.currentTarget.checked ?\n                        event.currentTarget.value :\n                        null\n                      );\n                    } );\n                    break nodeSwitch\n                }\n                // 네, drop-through\n```\n\n<div class=\"content-ad\"></div>\n\n입력값으로부터 체크박스와 라디오 버튼의 동작을 감지하고, 해당 지점에서 탈출합니다. 이벤트 리스너를 후킹하여 값이 변경되면 상태 값도 변경되도록 설정합니다.\n\n네, 저는 레이블과 함께 break를 사용하고 있습니다. 이것은 간단하며 스파게티 코드가 아니며, 이것 때문에 미쳐버리는 사람들은 어셈블리어를 쓰는 데 10초도 못 버텨요. 날 물어뜯어봐! 절대로 어셈블리어나 줄 번호가 있는 언어를 한 번도 작성한 적이 없는 사람들이 '스파게티 코드'에 대해 입 밖에 내지 말았으면 좋겠어요. 실제로 본 적도 없었고 대똥에 미쳐봤나봐. \n\n체크박스가 아니라면 textarea로 이동합니다. 스위치-케이스에 반대하는 사람들을 더 화나게 만듭니다.\n\n```js\n              case \"textarea\":\n                node.addEventListener(\"input\", (event) => {\n                  // self[name]을 트리거하여 세터를 호출합니다\n                  self[name] = node.value;\n                } );\n            }\n            break;\n```\n\n<div class=\"content-ad\"></div>\n\n이벤트 리스너를 추가하고, 내부 switch문을 종료하고, 외부 switch문을 탈출합니다.\n\n그런 다음 텍스트 노드를 처리합니다.\n\n```js\n          case Node.TEXT_NODE:\n            method = \"data\";\n            break;\n```\n\n데이터를 \"textContent\" 또는 \"value\"로 설정하지 않고 \"data\"로 설정한 것만 알면 됩니다. 노드에 __value 확장을 추가하여 노드 형식을 자동으로 감지하고 전달된 새 값을 적절하게 적용하는 것에 반박을 느낍니다.\n\n<div class=\"content-ad\"></div>\n\nNode가 아니면, 'Bomb.' 시작하면 해주세요.\n\n```js\n          default:\n            throw new Bomb(\n              \"unsupportedState\",\n              \"State.addMonitor\",\n              node.nodeType\n            );\n```\n\n위의 모든 작업을 완료하면, 새 노드를 저장소에 설정하고, 필터 배열을 만들고 값 할당에 사용할 \"method\"를 전달합니다.\n\n```js\n        store.nodes.set( node, { filters : [], method });\n\n        return node;\n\n      } // State.addMonitor\n```\n\n<div class=\"content-ad\"></div>\n\n… 그리고 그게 전부예요. 전체 State 객체입니다.\n\n# DOM-JON 구조 빠르게 살펴보기\n\nRC가 준비되기 전에 자세히 설명하지는 않겠지만, 일찍부터 이 문서를 읽은 많은 분들이 이를 이해하지 못한 것 같아요... 제 잘못입니다. 그것을 언급하지 않았거든요.\n\nDOM-JON 구조는 항목으로 나뉩니다. 이러한 \"항목\"들은 __make 함수의 패턴을 따릅니다. 다시 말해:\n\n<div class=\"content-ad\"></div>\n\n**make(dss, …attach)**\n\nDSS(구분자 선택자 문자열)는 CSS와 유사한 식별자를 사용하여 단축 명령으로 요소를 생성하는 것입니다. \"div#help.modal\" 또는 \"input_email?emailAddress=\"nowhereman@nowhere.land\"와 같은 것이 있습니다.\n\n... attach 인수는 다음 중 하나 이상 일 수 있습니다:\n\n- 배열 — __make에 전달할 인수를 모방하는 \"entry line\"으로, 자식 요소를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\n일반 객체 — 대부분의 키는 setAttribute를 사용하여 할당되지만 __makeParent, __makePlace, __stateName 등과 같은 특별한 값은 가로챕니다. 또한 해당 객체에서 { style : { property : value } }와 같은 것을 제대로 작동하도록 구문 분석하여 Element.style.setProperty를 통해 할당됩니다. 현재 datalist는 Object.assign(Element.datalist)을 사용하여 설정됩니다. 이것이 잘 작동하는지 확인하고 강제로 적용해야 할지 여부를 확인해야 합니다. 또한 함수 값이 element[name]을 통해 할당되므로 이벤트 핸들러와 같은 것을 onvent(예: onlick 또는 onsubmit)과 같이 연결할 수 있도록 주의를 기울여야 합니다.\n```\n\n함수 — 해당 함수는 현재 Element(this)에 전달되어 실행되며 결과는 문서에 추가됩니다.\n\n상태 객체 — DOM 트리에 적용할 상태입니다. DSS에서 __stateName이나 & 구분자를 사용하여 자식 요소(및 자체)가 할당된 경우 기존 상태의 getter/setter로 연결되거나 해당 상태에 이미 존재하지 않는다면 생성됩니다.\n\n부울, 요소, 노드, 숫자, 문자열, 기타 객체 유형 — 현재 처리 중인 요소의 끝에 추가됩니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 속성들은 여러 번 반복될 수 있으며, 덮어 쓰기가 가능하지만 순서는 중요하지 않습니다. 유일하게 중요한 것은 DSS가 첫 번째 인수여야 한다는 것입니다.\n\n예를 들어:\n\n```js\ndocument.body.__make(\n  \"button_button.clearBody=20\",\n  {\n    disabled : true,\n    style : { \"--icon\" : \"\\uE000\" }\n  },\n  \"Click to erase body content\",\n  { onclick : document.body.__make(\n    \"p@replaceChildren\", \"Content Deleted\"\n  ) }\n);\n```\n\n그리고:\n\n<div class=\"content-ad\"></div>\n\n```js\ndocument.body.__make(\n  \"button_button.clearBody=20\",\n  {\n    disabled : true,\n    style : { \"--icon\" : \"\\uE000\" },\n    onclick : document.body.__make(\n      \"p@replaceChildren\", \"Content Deleted\"\n    )\n  },\n  \"본문 내용을 지우려면 클릭하세요\"\n);\n```\n\n기능적으로 완전히 동일합니다.\n\nnested 및 스프레드를 통해 적용되는 배열로 make 값을 중첩하여 명시할 수 있기 때문에 배열로 동일한 값들을 표현할 수 있습니다. 이렇게 하면 다음과 같습니다:\n```js\nconst clearButtonDomJon = [\n  \"button_button.clearBody=20\",\n  {\n    disabled : true,\n    style : { \"--icon\" : \"\\uE000\" },\n    onclick : document.body.__make(\n      \"p@replaceChildren\", \"Content Deleted\"\n    )\n  },\n  \"본문 내용을 지우려면 클릭하세요\"\n];\n\ndocument.body__attach(clearButtonDomJon);\n```\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 변경합니다.\n\n이 또한 기능적으로 동일합니다. 모두가 기본적으로 다음과 같은 것을 만들어냅니다:\n\n```js\n<button\n  type=\"button\"\n  class=\"clearBody\"\n  value=\"20\"\n  disabled\n  style=\"--icon:'\\uE000';\"\n  onclick=\"document.body.innerHTML=`<p>Content Deleted</p>`;\"\n>Click to erase Body Content</button>\n```\n\n물론 이것은 DOM에서 직접 작동합니다.\n\n모두 여기까지 이루어지는 것은, 느슨한 형변환과 싸우는 대신 그것을 활용하는 것입니다. \"다른 유형을 매개변수로 허용해서는 안 된다\"고 말할 때마다 ID 10 T와 상호작용 중이라는 것을 알게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 앞으로의 계획\n\n곧 완성을 맞이할 예정입니다. 다음 번에는 beta 2를 준비하고, 이를 사용하여 템플릿을 만드는 방법, JavaScript 모듈과 함께 사용하는 방법, 그리고 현재 제작 중인 데모 앱인 또 다른 계산기를 통해 이 시스템의 참 가능성을 보여줄 것입니다.\n\nPart 1 : 기본 개념\nPart 2 : 시스템 객체 확장\nPart 3 : 상태 (여기에 있음)\nPart 4 : 템플릿 및 모듈 (곧 제공 예정)","ogImage":{"url":"/assets/img/2024-05-01-BetterJSDOMBuildingWithDOM-JONPart3TheStateObject_0.png"},"coverImage":"/assets/img/2024-05-01-BetterJSDOMBuildingWithDOM-JONPart3TheStateObject_0.png","tag":["Tech"],"readingTime":37},{"title":"프롤팅 레이블을 더이상 사용해서는 안되는 이유","description":"","date":"2024-05-01 22:35","slug":"2024-05-01-Maybeitstimetoletthefloatinglabelsdie","content":"\n\n![이미지](/assets/img/2024-05-01-Maybeitstimetoletthefloatinglabelsdie_0.png)\n\n플로팅 라벨은 사용자에게 중요한 가치를 제공하지 않을 뿐만 아니라 불필요한 혼란을 야기하며 궁극적으로는 무의미합니다.\n\n# 소개\n\n플로팅 라벨 패턴은 모바일 기기에서 시각적 공간 부족을 해결하는 똑똑한 방법이었지만 데스크톱 웹 페이지로 전이되어야 할 필요가 없는 곳에서 사용되었습니다.\n\n<div class=\"content-ad\"></div>\n\n이전 글에서는 왜 개발자들이 전적으로 플레이스홀더 사용을 중단해야 하는지에 대해 설명했습니다. 일부 사람들은 그 글의 댓글들에서(그리고 다른 글들에서도) 플로팅 레이블이 이러한 우려 사항을 해소한다고 주장했습니다 — 즉, 사용자가 컨트롤에서 타이핑할 때 플레이스홀더가 사라지는 문제에 대해서요.\n\n불행하게도, 이는 여러 다른 문제에 대해서는 여전히 해결하지 못하며, 몇 가지 문제를 도입하기도 합니다.\n\n플로팅 레이블 패턴이 무엇인지, 어떻게 발전해 왔는지, 그리고 왜 해가 서늘해져야 하는지 알아봅시다.\n\n# 배경\n\n<div class=\"content-ad\"></div>\n\n## 플로팅 레이블 패턴이란 무엇인가요?\n\n플로팅 레이블 패턴은 일반적으로 레이블을 플레이스홀더와 유사하게 스타일링한 텍스트 상자입니다. 포커스가 이동하거나 사용자가 입력을 시작할 때 (구현에 따라 다름), 레이블은 다음과 같이 동작합니다:\n\n- 사용자의 입력 위치 위로 이동\n- 더 작은 글꼴 크기로 축소\n- (자주) 색상, 대문자화, 또는 스타일 변경\n- 값이 있거나 포커스가 있는 한 계속해서 해당 상태로 유지됩니다\n\n이곳은 Matt D. Smith의 블로그 게시물 'Float Label Pattern Started'에서 가져온 gif입니다:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/0*AJWNecCc9kGWUY74.gif\" />\n\n주로 JavaScript로 처리하지만 Chris Coyier의 CSS로 된 예제와 같이 CSS만을 사용한 버전도 있습니다. 텍스트가 아래로 이동하거나 왼쪽으로 이동하는 등 다양한 변형이 있습니다. Bootstrap과 같은 구현체는 라벨을 입력란 경계 내부에 유지합니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*yw6AdTOOnTkIV8H15LM8sg.gif\" />\n\n이를 \"플로팅 인필드 라벨\"이라고 합니다. 하지만 이 글의 주제를 고려하면 그것은 별 차이가 없는 구별이라고 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 간단한 역사\n\n2013년 MDS(Matt D. Smith)가 플로팅 레이블 패턴을 만들었습니다. 당시 그 목적은 모바일 기기의 양식을 위한 공간을 보존하는 필요성을 해결하는 것이었습니다.\n\n1년 후, Google은 플로팅 레이블을 포함한 Material Design 프레임워크를 소개했고, 상상할 수 있듯이, 그 후 모바일 및 데스크톱 양식에서 인기를 끌었습니다.\n\n그러나 이 패턴에는 몇 가지 비평가가 있었습니다. Smith는 그것에 판매하지 않는 여러 Twitter 응답에 대한 링크를 포함했지만 비판에도 불구하고 계속 진행했습니다.\n\n<div class=\"content-ad\"></div>\n\n- 레이블은 텍스트 상자 내에 있으면 안 됩니다. (출처)\n- 이 패턴은 꽤 무의미해 보입니다. 즉, \"디자인을 위한 디자인\" (출처)\n- 레이블은 플레이스홀더로 나타나서는 안 됩니다. (출처)\n\n물론, Adam Silver의 기사가 있었습니다.\n(Floating Labels Are Problematic), 그에 대해 Matt D. Smith가 Are Float Labels Really That Problematic After All?로 대답했습니다.\n\n대부분의 논쟁은 진정되었지만, 해당 패턴은 그대로입니다. 그러나 항상 희망이 있습니다.\n\n![이미지](/assets/img/2024-05-01-Maybeitstimetoletthefloatinglabelsdie_1.png)\n\n<div class=\"content-ad\"></div>\n\n# 플로팅 라벨의 문제점은 무엇인가요?\n\n플로팅 라벨 패턴은 어디서 잘못되는 걸까요? 이 패턴은 플레이스홀더가 가지는 몇 가지 문제를 공유합니다. 공정하게 말하자면, 플로팅 라벨은 라벨로서의 플레이스홀더를 사용하는 것보다 약간 더 나아 보일 수 있습니다.\n\n하지만 충분히 많은 문제점이 있어서, 전체적으로 플로팅 라벨 패턴을 버리는 것을 권장합니다.\n\n## 문제 #1: 포커스시 라벨이 읽기 어려워집니다\n\n<div class=\"content-ad\"></div>\n\n플로팅 레이블은 입력시 사라지지 않고 다른 위치로 이동합니다 — 따라서 이것은 플레이스홀더보다 나은 방법이지만 레이블의 텍스트는 작아집니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:778/1*3t3yvrqkLRfQt3X8sjrcTA.gif)\n\n사용자는 특히 그 순간에 가장 관련이 있는 레이블을 보기 위해 눈을 가늘게뜨지 않아야 합니다. 즉, 포커스를 가진 것입니다.\n\n이로서 다음 사항이 나옵니다.\n\n<div class=\"content-ad\"></div>\n\n## 문제 #2: 포커스 시 레이블이 감소되었습니다\n\n입력 컨트롤이 포커스를 받았을 때, 왜 레이블을 감소시키는 것인가요? 포커스를 받은 컨트롤의 레이블은 정적인 상태를 유지하거나 강조되어야 합니다. 절대로 감소시키지 말아야 합니다.\n\n\"빈\" 입력 컨트롤의 레이블을 볼 수 있게 하는 것이 아니라 포커스된 컨트롤의 레이블을 보기 쉽게 하는 이유가 무엇인가요?\n\n![이미지](/assets/img/2024-05-01-Maybeitstimetoletthefloatinglabelsdie_2.png)\n\n<div class=\"content-ad\"></div>\n\n부트스트랩의 구현(위에서 보여진 것)에서 \"이메일 주소\" 필드가 포커스를 받았지만 \"비밀번호\" 라벨은 더 크고 높은 색 대조 비율을 가지고 있습니다. 따라서, 포커스를 받은 컨트롤의 라벨보다 읽기 쉽습니다.\n\n당신은 \"하지만 포커스된 라벨의 애니메이션이 그것에 주목을 끕니다\" 라고 대답할 수 있습니다. 그렇게 할 수도 있겠지만, 그 애니메이션은 한 번 일어나고 나면 끝나 버립니다.\n\n컨트롤이 포커스를 받으면, 라벨, 값, 도움말 텍스트 또는 포커스 지시자와 같이 해당 컨트롤과 연관된 모든 것은 해당 컨트롤에 더 많은 강조를 주도록 도와야 합니다.\n\n라벨을 그대로 두고 원래 사용 목적대로 사용하세요. 정적이고 적절히 할당되며 해당 컨트롤 근처(하지만 내부가 아님)에 배치하십시오.\n\n<div class=\"content-ad\"></div>\n\n## 문제 #3: 입력 컨트롤의 클릭 가능한 영역이 축소됨\n\n라벨을 축소하고 입력 컨트롤의 테두리 내에 배치하면, 컨트롤의 클릭 가능한 영역도 줄어듭니다.\n\n이는 플로팅 라벨이 플레이스홀더와 공유하는 문제입니다.\n\n라벨이 입력 컨트롤에 적절하게 할당되었을 때(for 속성을 통해 또는 입력 컨트롤 요소를 라벨 요소 안에 중첩시킴으로써), 라벨의 전체 영역이 클릭 가능한 영역에 포함됩니다. 즉, 사용자가 라벨을 클릭하면 입력 컨트롤이 포커스를 받게 됩니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/0*9jGWt-elzwlWsj51.gif\" />\n\n자, 이제 구글 번역 페이지의 플로팅 레이블 구현을 살펴보겠습니다. 텍스트 상자 주변을 클릭해도 제어가 포커스를 받지 않는 것을 주목해보세요:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*R8ZumepBKzdGJq6WdwjnaA.gif\" />\n\n우스갯소리 같지만, 이 텍스트 상자가 사실상 폼에 있는 모든 것입니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-01-Maybeitstimetoletthefloatinglabelsdie_3.png\" />\n\n그러니까, 여유롭고 수직 공간을 절약해야 하는 것처럼 보이진 않아요.\n\n손재주가 부족하거나 이동 능력에 제한이 있는 사용자들을 위해 전통적인 레이블을 사용해주세요. 입력 제어와 올바르게 연결하세요.\n\n큰 엄지 손가락과 피곤한 눈을 가진 저 같은 사람들도 도와줄 거예요.\n\n<div class=\"content-ad\"></div>\n\n## 문제 #4: 레이블의 목적이 분명하지 않아요\n\n텍스트 상자, 선택 컨트롤 또는 텍스트 영역의 목적은 무엇인가요?\n\n사용자가 어떤 형태의 입력을 제공하기 위한 것이 아닌가요? 그렇다면, 사용자가 제공하지 않은 텍스트로 컨트롤의 목적을 혼동시키는 이유가 무엇인가요?\n\n입력 컨트롤은 사용자의 공간입니다.\n\n<div class=\"content-ad\"></div>\n\n내 기사에서 자주 강조해 온 문제 중 하나에요 - 텍스트 상자 비활성화, 버튼 비활성화 또는 자리 표시자 사용에 관한 것이죠: 컨트롤의 목적이 사용자에게 더 이상 명확하지 않습니다.\n\n애매모호함을 모두 제거하세요. 이것은 입력 컨트롤입니다. 사용자가 입력할 수 없거나 입력할 수 있는지 (또는 입력해야 할지) 혼란스러워한다면 다른 방법을 사용하세요.\n\n## 문제 #5: 컨트롤이 가득 찬 것처럼 표시됩니다\n\n이것은 부유 레이블이 자리 표시자와 공유하는 또 다른 문제입니다.\n\n<div class=\"content-ad\"></div>\n\n입력 컨트롤에 텍스트를 넣으면, 해당 컨트롤의 값이 아니라면 혼란을 초래할 수 있습니다. 모든 사용자에게는 아니지만, 어떤 사용자에게는 혼란을 야기할 수 있습니다. 그리고 그것이 부동 라벨을 사용하지 말아야 하는 충분한 이유입니다.\n\n사용자는 눈썹을 휘거나 라벨 애니메이션의 영광에 감탄하기보다는 일을 처리하고 싶어합니다.\n\n라벨은 자신만의 공간을 갖고 있습니다. 거기에 머물게 두세요.\n\n## 문제 #6: 라벨의 크기/색상/위치가 일관성이 없습니다.\n\n<div class=\"content-ad\"></div>\n\n부트스트랩의 구현을 다시 살펴보세요:\n\n![Bootstrap Implementation](/assets/img/2024-05-01-Maybeitstimetoletthefloatinglabelsdie_4.png)\n\n두 개의 레이블이 표시되지만 서로 다릅니다. 초점을 맞춘 레이블(\"이메일 주소\")은 더 작은 글꼴 크기, 더 밝은 색상 및 비초점 레이블(\"비밀번호\")보다 다른 배치를 갖고 있습니다.\n\n크리스찬 홀스트가 그의 3가지 잘못된 간단함 유형에서 말했듯이:\n\n<div class=\"content-ad\"></div>\n\n라벨은 영구적인 공간이 있어야 합니다. 사실, 모든 요소들이 그렇습니다.\n모든 것을 제 자리에 두세요. 즉, 라벨은 텍스트 상자 바깥에 남겨 두어야 합니다...언제나요.\n\n## 문제 #7: 색 대조\n\n플레이스홀더와 마찬가지로 부유하는 라벨 텍스트는 일반적으로 기본 라벨 텍스트보다 어둘 수 있습니다. 그래서, 해당 값처럼 충분히 어두울 수도 있고, 읽기 어려울 정도로 밝을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: 입력 컨트롤 바깥에 그대로 두세요.... 영구적으로.\n\n## 문제 #8: 불필요한 부피\n\n위 문제 중 하나도 존재하지 않더라도, 이것은 본질적으로 아이캔디에 대한 불필요한 코드 부피가 될 것입니다.\n\n전통적인 레이블이 더 나은 결과를 제공하고 더 많은 사용자에게 더 작은 영향을 미칩니다.\n\n<div class=\"content-ad\"></div>\n\n## 문제 #9: 떠다니는 라벨은 의미가 없어요\n\n자신에게 떠다니는 라벨이 제공하는 가치가 무엇인지 생각해보세요.\n\n지지자들로부터 여러 의견을 읽었는데, 그 중 주요한 3가지로 요약할 수 있습니다:\n\n- 수직 공간을 절약할 수 있어요.\n- 페이지가 깔끔해 보여요.\n- 예쁘게 보여요.\n\n<div class=\"content-ad\"></div>\n\n문제를 해결하지 못하고 있습니다.\n\n불필요한 것을 애니메이션화하는 것이 얼마나 유익한가요?\n\n이 공간을 절약하려는 똑똑한 시도였지만, 새로운 문제가 충분히 발생하여 비용이 이득을 상회한다는 것에 대해 모두 동의할 수 없을까요?\n\n아니요? 그럼 다음 섹션을 찾아가 보세요.\n\n<div class=\"content-ad\"></div>\n\n# 이의사항\n\n당신이 실망시키지 않을 거라고 확신하며, 여기에 포함하지 않은 이의사항들이 있을 거라 기대하고 있어요. 댓글에서 그것들을 읽는 것을 고대하고 있어요.\n\n## 이의사항 #1: \"하지만, 공간을 절약해요!\"\n\n저는 placeholder에 대해 적은 것을 반복하겠습니다: 만약 라벨이 뜬 텍스트로 인해 절약되는 공간이 중요하다면, 당신의 폼은 너무 커진 것입니다.\n\n<div class=\"content-ad\"></div>\n\n폼을 간소화하세요. 즉, 필요한 정보만 요청하고 페이지 당 입력 컨트롤 수를 줄이세요.\n\n## 반대 의견 #2: \"하지만 구글이 그렇게 하잖아요!\"\n\n맞습니다. 앞서 말했듯이, 구글은 2014년에 발표한 Material Design의 첫 번째 버전에서 떠다니는 라벨 패턴을 채택했으며, 현재 이 글을 작성하는 시점에서 사용 중인 세 번째 버전에도 여전히 적용되어 있습니다.\n\n만일 구글이 무언가를 한다면, 그것은 확실히 사용자 경험과 접근성의 최고 표준을 보장하기 위해 철저히 연구되었을 것이라고 생각되죠, 그렇죠?\n\n<div class=\"content-ad\"></div>\n\n그렇게 많지 않아요.\n\n첫 번째 버전의 텍스트 상자 레이아웃 스크린샷이 있습니다:\n\n![텍스트 상자 레이아웃](/assets/img/2024-05-01-Maybeitstimetoletthefloatinglabelsdie_5.png)\n\n\"레이아웃\" 제목을 보셨죠? 그것은 `h2` 제목입니다. \"라벨\" 부제목을 보셨죠? 그것은 `h1`이에요. 얍스!\n\n<div class=\"content-ad\"></div>\n\n거의 10년 동안 올려져 있었어요.\n\nAdam Silver가 Smashing Magazine에 게재한 기사인 \"Material Design Text Fields Are Badly Designed\"에서는 이 패턴에 대한 반대를 재창이 하면서도 Google은 부유 레이블을 전통적인 레이블과 비교적 테스트하지 않았다는 것을 공개했습니다.\n\n그래서 Google이 (또는 누군가가) 뭔가를 한다고 해서 그것이 괜찮다고 생각하지 마세요. 그들은 심지어 제목을 제대로 쓰지 못하고 있어요!\n\n만약 그들이 그 이후로 일정 부분을 개선했다고 생각한다면, 최신 Material Design 인터레이션(버전 3)에서 이것을 한번 보세요:\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-01-Maybeitstimetoletthefloatinglabelsdie_6.png)\n\n\"Resources\" 제목과 매우 작은 \"이 페이지에서\" 텍스트는 모두 `h2` 요소입니다. \"텍스트 필드\" 텍스트는 제목이 아닙니다.\n\n그래서, Google의 작업이 접근 가능하다고 가정한다면, 바위에서 수영 수업을 받는 것과 다를 바 없을지도 몰라요.\n\n## 이의 제기 #3: \"그렇다고 스크린 리더가 읽는다구요!\"\n\n<div class=\"content-ad\"></div>\n\n그럼요, 그렇죠. 스크린 리더는 일반적으로 스타일링에 따라 컨텐츠를 다르게 소비하지 않습니다.\n\n포커스를 받지 않은 컨트롤의 떠다니는 라벨(비록 위치가 올바르지 않더라도)은 여전히 `label` 요소이며, 스크린 리더는 이를 해당 요소로 인식합니다.\n\n하지만 스크린 리더는 보조 기술의 유일한 형태가 아닙니다. 시각 장애인을 돕는 화면 확대기도 있습니다.\n\n모든 시각 장애인이 모든 작업에 이를 필요로 하는 것은 아닙니다. 페이지가 잘 구조화되어 있고 적절한 크기이며 하나의 페이지에 모든 것을 담으려 하지 않는다면, 시각 장애인은 확대기를 필요로하지 않을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 레이블의 크기를 줄이면 시각 장애가 있는 사용자들이 확대기를 사용하도록 강요할 수 있어요.\n\n왜 이렇게 하나요? 그냥 옛날 방식의 레이블을 제공해주세요.\n\n## 이의 제기 #4: \"하지만 초점이 맞춰진 후 레이블의 글꼴 크기를 조절할 수 있어요!\"\n\n네, 가능해요 - 하지만 뜬 레이블의 목적이 뭐에요? 레이블의 크기를 키우면 공간을 절약하는 것이 아니게 되어버려요.\n\n<div class=\"content-ad\"></div>\n\n그냥 라벨을 올려놓으면 되지 않을까요? 입력 컨트롤 위에 라벨을 두시면 되는 곳입니다. 그리고 거기에 계속 두세요.\n\n## 이의 제기 #5: \"하지만 그들은 너무 오랫동안 존재해 왔고 전통적이에요!\"\n\n나쁜 패턴이 인기를 얻는 경우가 가끔 있어요. 이것은 HTML 명세에 변화를 가져다줘요.\n\n그것이 바로 구석구석에 플레이스홀더를 두게된 이유 중 하나에요. 사람들은 재치 있게 자신만의 프로토플레이스홀더를 만들려고 해왔죠. 하나의 나쁜 습관이 또 다른 것으로 이어진 것이에요.\n\n<div class=\"content-ad\"></div>\n\n또한, 쉽게 사라지는 실천 방법들이 많습니다. `marquee` 요소, 레이아웃 테이블 또는 인라인 JavaScript를 기억하나요?\n\n나쁜 관행은 얼마나 퍼져 있든 나쁜 것입니다.\n\nWebAIM의 '밀리언 리포트'에 따르면, 나쁜 웹 접근성 관행은 심각한 문제로 여겨지며, 심지어 더 확립된 웹사이트들 사이에서도 흔히 발견됩니다.\n\n먼저 그것을 해결한 후에, 관례에 대한 토론을 진행해봅시다.\n\n<div class=\"content-ad\"></div>\n\n당분간 기존 레이블을 계속 사용해주세요.\n\n# 결론\n\n플로팅 레이블 대신 플레이스홀더를 레이블로 사용하는 것이 더 나은 것은 알지만, 아직도 문제점이 있습니다. 이 문제들을 해결하기 위해 버리지 않고 어떻게든 해결할 수 없습니다.\n\n사용자는 눈속임이 아닌 일관성이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n당신의 웹사이트를 방문하는 사용자들은 도페미늄 히트를 얻으러 온 것이 아니라, 작업을 완료하러 온 것입니다.\n\n그 길을 라스베이거스 스트립이 아닌 고속도로로 만드세요.\n\n플로팅 레이블이 가지는 문제점을 인지하고, 왜 사용하는지 솔직하게 검토하고, 그 많은 문제를 극복하는지 결정해 보세요.\n\n아마도 플로팅 레이블에게 작별인사를 할 때가 되었을지도 모릅니다.\n\n<div class=\"content-ad\"></div>\n\n# 링크\n\n## 언급된 것\n\n- How the Float Label Pattern Started by MDS\n- Float Labels with CSS by Chris Coyier\n- Floating Labels Are Problematic by Adam Silver\n- Are Float Labels Really That Problematic After All? by MDS \n(거기서 댓글도 확인해보세요)\n- Bootstrap의 떠다니는 라벨 구현\n- Google 번역: 웹사이트\n- 3가지 유형의 잘못된 간소화 by Christian Holst\n- WebAIM의 백만 보고서\n- Material Design (v. 1)\n- Material Design (v. 3)\n- Material Design 텍스트 필드는 Adam Silver가 나쁘게 디자인했습니다.\n\n## 추가로 읽을 거리\n\n<div class=\"content-ad\"></div>\n\n- 브래드 프로스트의 Float Label Pattern\n- 비탈리 프리드만의 Gone Floating Labels And Green Lighthouse Scores\n- 수잔나 자레이스키의 Material Design의 텍스트 필드 진화\n- 덴니스 렘브리에의 Floated Labels Still Suck\n\n## 나의 언급된/관련된 기사들\n\n- 왜 텍스트 상자에 플레이스홀더를 사용하지 말아야 하는 이유\n- 절대 버튼을 비활성화하지 말아야 하는 이유\n- 2024년 접근성 향상을 위한 5가지 방법\n- 우리는 모두 웹을 부끄러워해야 합니다: WebAIM의 2023 웹 접근성 보고서\n- 개발자들, 부끄러움 그만하세요","ogImage":{"url":"/assets/img/2024-05-01-Maybeitstimetoletthefloatinglabelsdie_0.png"},"coverImage":"/assets/img/2024-05-01-Maybeitstimetoletthefloatinglabelsdie_0.png","tag":["Tech"],"readingTime":11},{"title":"접근성 준수하는 폼을 디자인하는 10가지 방법","description":"","date":"2024-05-01 22:33","slug":"2024-05-01-Howtodesignaccessibleformsin10steps","content":"\n\n양식을 작성하는 것은 보통 사용자에게 재미있는 작업은 아닐 수 있지만, 종종 프로세스의 필수 단계입니다. 예를 들어, 사용자는 물품을 구매하기 위해 지불 세부 정보가 포함된 짧은 양식을 작성하라고 요청받을 수도 있고, 취업 지원서 일환으로 양식을 작성해야 할 수도 있습니다.\n\n디자이너로서, 우리는 사용자의 삶을 더 편리하게 만들 수 있습니다. 모든 사용자가 접근하고 이해하기 쉬운 형태로 양식을 디자인함으로써 접근성을 확보할 수 있습니다. 보조 기술을 사용하는 사용자 등 모든 사용자가 양식의 구성 요소에 접근하고 이해할 수 있도록 하는 것은 사용자뿐만 아니라 디자이너가 일하는 비즈니스에도 이로운 점이 많습니다. 예를 들어, 접근성이 제공되지 않아 접근 시 힘든 사용자가 결제 단계를 완료할 수 없을 경우, 사용자가 당혹스러울뿐만 아니라 해당 비즈니스에도 부정적인 영향을 끼칠 수 있습니다.\n\n다음은 접근성을 고려한 양식 디자인에 대한 몇 가지 실용적인 팁입니다:\n\n## 1. 긴 양식을 짧은 여러 페이지 양식으로 나누기\n\n<div class=\"content-ad\"></div>\n\n한 페이지에 많은 필드가 있는 긴 폼은 피하는 것이 좋습니다. 대신 필드를 여러 개의 짧은 폼 사이에 나누어 시도해보세요. 긴 폼은 이해하기 어렵고, 특히 디지털 리터러시가 낮은 사람들과 주의력결핍과 과잉행동장애(ADHD)와 같은 인지 장애가 있는 사람들에게 특히 어려울 수 있습니다. 관련된 필드를 논리적으로 그룹화하여 인지 부하를 줄이도록 노력해보세요.\n\n여러 페이지로 나뉘면 각 페이지에 사용자가 어떻게 진행해야 하는지 설명이 나타나도록 해야 합니다. 이렇게 함으로써 사용자가 폼의 지침을 기억하도록 의존할 필요가 없어지며, 대부분의 사람들에게 어려울 수 있고, 기억력에 영향을 미치는 인지 장애가 있는 사람들에게는 더 어려울 수 있습니다.\n\n여러 폼 페이지를 추가하면 사용자가 폼 작성의 진행 상황을 이해하기 더 어려워질 수 있으므로, 완료한 정도를 어떤 방식으로 시각화하는 것이 도움이 될 때가 많습니다.\n\n![이미지](/assets/img/2024-05-01-Howtodesignaccessibleformsin10steps_0.png)\n\n<div class=\"content-ad\"></div>\n\n## 2. 입력 필드에 라벨을 상단 정렬하기\n\n시각적 라벨은 사용자에게 해당 입력 필드가 무엇을 의미하는지 알려주고, 사용자들이 양식을 작성하는 데 도움을 줍니다. 시각적 라벨을 사용하면 스크린 리더도 입력 필드를 식별할 수 있습니다. 스크린 리더가 라벨을 입력 필드와 연결하려면 `input`에 식별자를 설정하여 `label`의 for 속성과 일치하도록 해야 합니다. 일부 지원 기술이 지원하지 않을 수 있으므로 `input`을 `label` 안에 중첩하는 것은 좋지 않습니다. `label`을 사용할 수 없는 경우 ARIA 라벨(aria-labelledby 및 aria-label)을 사용할 수 있습니다.\n\n일반적으로 시각적 라벨을 입력 필드 위에 위치시키는 것이 좋습니다. 사용자가 라벨과 입력 필드를 별도로 살펴볼 필요가 없기 때문에 사용자가 편리하게 사용할 수 있습니다. 줌 기능을 사용하는 시각 장애인 사용자들에게는 입력 필드 위에 라벨을 위치시키는 것이 수평으로 페이지를 스크롤하여 모든 양식 필드를 작성할 필요가 없게 해줍니다.\n\n<img src=\"/assets/img/2024-05-01-Howtodesignaccessibleformsin10steps_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 3. 힌트 텍스트 사용하기\n\n양식 입력란 내부의 플레이스홀더 텍스트는 사용자에게 도움이 되도록 의도되었지만 종종 많은 사용성 및 접근성 문제를 유발합니다. 플레이스홀더 텍스트는 보통 정보를 입력한 후에 필드에서 사라지기 때문에 사용자가 힌트를 기억하고 수정하는 것이 더 어려워집니다.\n\n일부 사용자에게는 플레이스홀더 텍스트에 완전히 접근할 수 없는 경우도 있습니다. 예를 들어, 플레이스홀더 텍스트는 보조 기술에서 널리 지원되지 않으며 오래된 웹 브라우저에서도 표시되지 않습니다. 게다가, 사용되는 기본 색상은 옅은 회색이며 이는 대부분의 배경 색상과의 색 대조가 낮아 사용자에게 시각적으로 읽기 어렵거나(불가능하게) 만들 수 있습니다.\n\n플레이스홀더 텍스트 대신, 입력란 위나 아래에 힌트 텍스트를 사용하여 도움이나 추가 정보를 제공해 보세요. 이 텍스트는 항상 보이기 때문에 보조 기술에서 더 쉽게 인식될 확률이 높습니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-05-01-Howtodesignaccessibleformsin10steps_2.png](/assets/img/2024-05-01-Howtodesignaccessibleformsin10steps_2.png)\n\n## 4. 네이티브 폼 컨트롤 사용하기\n\n네이티브 HTML을 사용하면 다양한 브라우저에서 작동하고 스크린 리더와 같은 다양한 보조 기술과 함께 더 잘 작동하는 코드를 만들 수 있습니다. 네이티브 HTML 요소는 기본적으로 접근성이 있기 때문에 네이티브 HTML 폼 컨트롤을 사용하면 디자인 중인 폼을 완전히 액세스할 수 있는 지원 기술을 보장할 수 있습니다.\n\n커스텀 폼 컨트롤을 만들어야 하는 경우에는 WAI-ARIA 기술을 사용하여 속성을 수동으로 추가하세요. 커스텀 폼 컨트롤을 스크린 리더 및 키보드만으로 액세스할 수 있도록 보장하기 위해 수동으로 테스트를 진행하세요.\n\n<div class=\"content-ad\"></div>\n\n## 5. 포커스를 강조하는 요소\n\n웹 사이트를 키보드로만 탐색하는 사용자를 위해 포커스 영역을 명확하게 강조하는 것은 사용자가 양식을 쉽게 탐색할 수 있도록 해줍니다.\n\n포커스가 있는 `input`을 명확하게 강조하고, 강조하기 위해 선택한 색상이 배경색과 충분한 색 대비를 가지도록합니다.\n\n![이미지](/assets/img/2024-05-01-Howtodesignaccessibleformsin10steps_3.png)\n\n<div class=\"content-ad\"></div>\n\n## 6. 스타일 및 오류 올바르게 작성하기\n\n사용자가 양식의 필드에서 오류를 만나면 무엇이 잘못되었는지 및 어떻게 수정할 수 있는지 알 수 있어야 합니다. 이것은 액세스 요구사항이 있는 사용자와 없는 사용자 모두에게 적용됩니다. 그러나 제대로 스타일이 적용되지 않거나 잘못 작성된 오류는 일부 액세스 요구사항을 가진 사용자가 오류를 이해하고 수정하는 것이 불가능하게 할 수 있습니다.\n\n스타일링\n일반적으로 오류가 발생하면 입력 테두리 색상이 빨간색으로 변경됩니다. 하지만 이것만으로 오류를 처리하는 것은 두 가지 이유로 접근성이 떨어집니다. 첫째, 색맹 사용자에게 색상 변경이 명확하지 않을 수 있고, 둘째, 색상 변경은 보조 기술에 노출되지 않을 수 있습니다. 기호는 오류가 있음을 나타내는 데 도움이 될 수 있지만 사용자가 왜 필드가 잘못되었는지 이해하는 데 도움이 되진 않을 것입니다. 사용자에게 오류를 강조하는 가장 접근성이 높은 방법은 문제가 무엇인지 명확하게 나타내는 수반 텍스트입니다.\n\n내용\n오류 메시지는 평문으로 작성하고 기술 용어를 피하여 오류가 이해하기 쉽도록 해야 합니다. 메시지는 사용자가 오류를 어떻게 수정할 수 있는지에 대한 적절한 제안을 제공해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n화면 판독기가 필드가 잘못되었음을 이해할 수 있도록 ARIA 속성 aria-invalid=\"true\"을 사용하세요. 이 속성은 화면 판독기가 해당 컨트롤을 \"잘못됨\"이나 주의가 필요한 상태로 인식하도록 합니다. 어떤 인라인 오류가 양식 필드와 연결되어 있는지 지정하려면 aria-describedby를 사용하세요.\n\n![Form Example](/assets/img/2024-05-01-Howtodesignaccessibleformsin10steps_4.png)\n\n## 7. 그룹 내 관련 필드에 레이블 지정\n\n가끔 양식은 관련된 필드 요소들로 이루어질 수 있습니다. 예를 들어, 주소 입력을 구성하는 여러 요소나 라디오 버튼에는 여러 옵션이 있을 수 있습니다. 이러한 상황에서 관련 필드 그룹에 적절한 레이블을 붙이면 화면 판독기가 필드의 관계를 식별할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n필드셋과 레전드를 사용할 수 있습니다. 레전드는 일반적으로 질문이나 요청되는 그룹의 레이블로 사용될 수 있으며, 화면 판독기가 필드와 그룹의 레이블을 들을 수 있도록 합니다. 필드셋은 폼 컨트롤을 함께 그룹화하는 데 사용됩니다.\n\n![이미지](/assets/img/2024-05-01-Howtodesignaccessibleformsin10steps_5.png)\n\n## 8. 지침 제공\n\n지침은 사용자가 폼이나 개별 요소를 완료하는 방법을 이해하는 데 중요하며, 모든 사용자가 접근할 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n사용자가 양식을 시작하기 전에 상황에 맞는 정보를 제공하는 것이 도움이 됩니다. 예를 들어, 양식을 완료하는 데 사용자가 필요한 것이 있는지 여부를 설명하거나 시간 제한이 있는지를 설명할 수 있습니다. 이러한 지침은 화면 판독기에서 읽혀지도록 `form` 요소 앞에 표시되어야 합니다.\n\n인라인 지침은 필수 필드를 식별하고 어떤 형식으로 필드를 완료해야 하는지 사용자가 이해할 수 있도록 도와줍니다. 화면 판독기 사용자에게 지침을 표시하려면 aria-describedby 속성을 사용하세요. 지시 사항이 양식 필드에 바인딩되어 있지 않으면 일부 보조 기술에서 정보를 놓칠 수 있습니다.\n\n## 9. 필수 항목을 명확히 식별하기\n\n양식에서 필수 항목은 명확히 식별되어야 합니다. 가장 적게 발생하는 경우에 따라 필수 필드나 선택적 필드를 보여줌으로써 이를 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n필수 속성은 양식 컨트롤에 추가할 수 있으며 프로그램적으로 해당 양식 필드가 필수임을 나타낼 수 있습니다. 웹 브라우저가 HTML5을 지원하는 경우, 필드를 작성하지 않은 상태로는 양식을 제출할 수 없습니다. aria-required 속성을 사용하여 보조 기술에 필수 컨트롤에 대한 정보를 전달하여 사용자에게 알릴 수 있습니다. HTML5를 지원하는 대부분의 브라우저는 HTML5 required 속성이 존재할 때 자동으로 값을 true로 설정하지만, aria-required를 포함하면 오래된 웹 브라우저도 지원됩니다.\n\n![image](/assets/img/2024-05-01-Howtodesignaccessibleformsin10steps_6.png)\n\n## 10. 가능한 경우 사용자가 양식을 작성하도록 하는 시간 제한을 피하십시오.\n\n접근성 요구사항을 가진 많은 사용자들은 양식을 작성하는 데 더 많은 시간이 필요할 수 있습니다. 예를 들어 시각 장애가 있는 사용자는 페이지에서 정보를 찾고 읽는 데 더 많은 시간이 필요할 것이며 타임아웃 경고 메시지를 보지 못할 수도 있습니다. 인지나 학습 장애가 있는 사용자는 양식의 내용을 읽고 이해하는 데 더 많은 시간이 필요할 수 있습니다. 청각 장애가 있는 사용자는 청각 정보를 처리하거나 영어가 주 언어가 아닐 때(예: 영어가 아닌 사용자 또는 수화 언어 사용자) 이해하는 데 더 많은 시간이 필요할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n시간 제한이 필요한 경우 (예: 보안상의 이유로), 사용자는 이를 꺼거나 시간 제한을 연장할 수 있어야 합니다. 사용자는 양식을 시작할 때 시간 초과와 시간 제한이 무엇인지에 대해 알려져야 합니다.\n\n## 마무리\n\n여기까지 접근성 있는 양식을 디자인하는 데 도움이 되는 팁을 제공했습니다. 이 포인트들이 모든 사용자가 여러분의 양식을 사용할 수 있도록 도와주길 바라요. 이는 결국 사용자와 비즈니스 양쪽에 혜택이 되므로 정말 이유가 없습니다!","ogImage":{"url":"/assets/img/2024-05-01-Howtodesignaccessibleformsin10steps_0.png"},"coverImage":"/assets/img/2024-05-01-Howtodesignaccessibleformsin10steps_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 - State vs Props 둘의 차이점을 이해하자","description":"","date":"2024-05-01 18:21","slug":"2024-05-01-ReactStatevsProps","content":"\n![React State vs Props](/assets/img/2024-05-01-ReactStatevsProps_0.png)\n\n리액트 JS에서 State와 Props의 차이를 완전히 이해하는 것이 매우 중요합니다. 이 두 개념을 완전히 이해하지 않으면 리액트에서 제대로 프로그래밍할 수 없습니다.\n\n## 현재 상황: State 이해하기\n\nState는 컴포넌트의 내부 데이터 저장소로, 현재 상태나 상황을 나타냅니다. 이는 컴포넌트의 개인 다이어리와 같습니다. 여기에는 행동과 외관을 정의하는 모든 흥미로운 세부사항이 기록됩니다. State가 변경될 때마다 React는 컴포넌트와 그 하위 요소를 지혜롭게 다시 렌더링하여 사용자 인터페이스가 최신 상태로 유지되고 데이터와 동기화되도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React, { Component } from \"react\";\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n    };\n  }\n\n  incrementCount = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <h1>Count: {this.state.count}</h1>\n        <button onClick={this.incrementCount}>Increment</button>\n      </div>\n    );\n  }\n}\n```\n\n이 예제에서 Counter 컴포넌트는 count라는 상태 속성을 가지고 있으며, 초기값은 0으로 설정됩니다. 사용자가 \"증가\" 버튼을 클릭하면 incrementCount 메서드가 호출되어 setState 메서드를 사용하여 count 값을 증가시킵니다. React는 업데이트된 count 값을 사용하여 컴포넌트를 다시 렌더링합니다.\n\n## Props: 계속해서 선물을 주는 선물\n\nProps는 속성을 의미하는 단어의 축약형으로, 부모 컴포넌트로부터 받는 컴포넌트에 전달되는 데이터입니다. Props는 변경할 수 없으며, 즉 컴포넌트 자체에서 직접적으로 변경할 수 없습니다. 대신, props는 데이터를 컴포넌트 트리 아래로 전달하며, 재사용성과 캡슐화를 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from \"react\";\n\nconst Greeting = (props) => {\n  return <h1>Hello, {props.name}!</h1>;\n};\n\nconst App = () => {\n  return (\n    <div>\n      <Greeting name=\"Alice\" />\n      <Greeting name=\"Bob\" />\n    </div>\n  );\n};\n```\n\n이 예제에서 Greeting 컴포넌트는 부모 컴포넌트인 App으로부터 name prop을 전달받습니다. App 컴포넌트는 두 개의 Greeting 인스턴스를 렌더링하며 props로 다른 name 값을 전달합니다. Greeting 컴포넌트는 그 후에 받은 name을 h1 요소에 표시합니다.\n\n## 리액트의 역과 양: 상태와 프롭스의 조화\n\n상태와 프롭스는 분리된 엔티티처럼 보일 수 있지만, 종종 동적이고 인터랙티브한 사용자 인터페이스를 만들기 위해 함께 작동합니다. 한 컴포넌트의 상태는 자식 컴포넌트의 프롭스가 될 수 있어 데이터가 컴포넌트 트리를 따라 흐를 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React, { Component } from \"react\";\n\nclass ParentComponent extends Component {\n  state = {\n    message: \"Hello, World!\",\n  };\n\n  updateMessage = () => {\n    this.setState({ message: \"Hello, React!\" });\n  };\n\n  render() {\n    return (\n      <div>\n        <ChildComponent message={this.state.message} />\n        <button onClick={this.updateMessage}>Update Message</button>\n      </div>\n    );\n  }\n}\n\nconst ChildComponent = (props) => {\n  return <h1>{props.message}</h1>;\n};\n```\n\n이 예시에서 ParentComponent는 초기에 'Hello, World!'로 설정된 message라는 상태 속성을 가지고 있습니다. 이 메시지 상태는 ChildComponent로 프롭으로 전달되며, 해당 메시지를 h1 요소에서 표시합니다.\n\n사용자가 'Update Message' 버튼을 클릭하면 updateMessage 메서드가 호출되어 메시지 상태를 'Hello, React!'로 업데이트합니다. React는 ParentComponent 및 해당 하위 컴포넌트를 다시 렌더링하고 업데이트된 메시지 프롭을 ChildComponent에 전달하여 업데이트된 메시지가 표시됩니다.\n\n## 콜백 문제: 자식에서 부모로 통신하기\n\n<div class=\"content-ad\"></div>\n\nprops가 컴포넌트 트리 아래로 흘러가는 동안, 자식 컴포넌트가 부모에게 다시 통신해야 할 때가 있습니다. 이때 콜백 함수가 필요합니다. 부모 컴포넌트는 자식 컴포넌트에게 콜백 함수를 prop으로 전달하여 자식이 콜백을 호출하고 데이터를 부모에게 다시 전달할 수 있습니다.\n\n```js\nimport React, { Component } from \"react\";\n\nclass ParentComponent extends Component {\n  state = {\n    childMessage: \"\",\n  };\n\n  handleChildMessage = (message) => {\n    this.setState({ childMessage: message });\n  };\n\n  render() {\n    return (\n      <div>\n        <h1>자식으로부터의 메시지: {this.state.childMessage}</h1>\n        <ChildComponent onMessageReceived={this.handleChildMessage} />\n      </div>\n    );\n  }\n}\n\nclass ChildComponent extends Component {\n  state = {\n    message: \"\",\n  };\n\n  handleInputChange = (event) => {\n    this.setState({ message: event.target.value });\n  };\n\n  sendMessageToParent = () => {\n    this.props.onMessageReceived(this.state.message);\n  };\n\n  render() {\n    return (\n      <div>\n        <input type=\"text\" value={this.state.message} onChange={this.handleInputChange} />\n        <button onClick={this.sendMessageToParent}>부모에게 메시지 전송</button>\n      </div>\n    );\n  }\n}\n```\n\n이 예시에서 ParentComponent는 초기에 빈 문자열로 설정된 childMessage라는 상태 속성을 가지고 있습니다. ParentComponent는 onMessageReceived라는 prop으로 handleChildMessage 콜백 함수를 ChildComponent에 전달합니다.\n\nChildComponent에는 입력 필드와 버튼이 있습니다. 사용자가 입력 필드에 입력하면 handleInputChange 메소드가 ChildComponent의 message 상태를 업데이트합니다. 사용자가 \"부모에게 메시지 전송\" 버튼을 클릭하면 sendMessageToParent 메소드가 호출되어 onMessageReceived 콜백 prop을 호출하고 현재의 message 상태를 인자로 전달합니다.\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트에서는 자식 컴포넌트로부터 받은 메시지로 handleChildMessage 콜백 함수를 호출하고, childMessage 상태가 업데이트됩니다. 그리고 부모 컴포넌트는 업데이트된 childMessage 값을 가지고 재렌더링됩니다.\n\n상태 끌어올리기: 공유 상태 관리\n일부 경우에는 여러 컴포넌트가 동일한 상태를 공유하고 업데이트해야 할 수 있습니다. 이런 경우에는 공유 상태를 가장 가까운 공통 조상 컴포넌트로 끌어올려서 필요한 컴포넌트로 props로 전달하는 것이 권장됩니다.\n\n```js\nimport React, { Component } from \"react\";\n\nclass TemperatureApp extends Component {\n  state = {\n    temperature: 20,\n    scale: \"celsius\",\n  };\n\n  handleTemperatureChange = (temperature) => {\n    this.setState({ temperature });\n  };\n\n  handleScaleChange = (scale) => {\n    this.setState({ scale });\n  };\n\n  render() {\n    const { temperature, scale } = this.state;\n    return (\n      <div>\n        <TemperatureInput\n          temperature={scale === \"celsius\" ? temperature : (temperature * 9) / 5 + 32}\n          scale=\"celsius\"\n          onTemperatureChange={this.handleTemperatureChange}\n        />\n        <TemperatureInput\n          temperature={scale === \"fahrenheit\" ? temperature : ((temperature - 32) * 5) / 9}\n          scale=\"fahrenheit\"\n          onTemperatureChange={this.handleTemperatureChange}\n        />\n        <button onClick={() => this.handleScaleChange(\"celsius\")}>Celsius</button>\n        <button onClick={() => this.handleScaleChange(\"fahrenheit\")}>Fahrenheit</button>\n      </div>\n    );\n  }\n}\n\nclass TemperatureInput extends Component {\n  handleChange = (event) => {\n    this.props.onTemperatureChange(parseFloat(event.target.value));\n  };\n\n  render() {\n    const { temperature, scale } = this.props;\n\n    return (\n      <fieldset>\n        <legend>Enter temperature in {scale === \"celsius\" ? \"Celsius\" : \"Fahrenheit\"}:</legend>\n        <input value={temperature} onChange={this.handleChange} />\n      </fieldset>\n    );\n  }\n}\n\nexport default TemperatureApp;\n```\n\n이 예시에서 TemperatureApp 컴포넌트가 온도와 척도의 공유 상태를 관리합니다. 이 컴포넌트는 TemperatureInput 컴포넌트의 두 인스턴스를 제공하며, 온도, 척도, 그리고 onTemperatureChange 콜백 함수를 props로 전달합니다.\n각 TemperatureInput 컴포넌트는 해당 척도(Celsius 또는 Fahrenheit)에 따라 온도를 표시하고 사용자가 새 온도 값을 입력할 수 있습니다.\n사용자가 새 온도를 입력하면 TemperatureInput 컴포넌트의 handleChange 메서드가 호출되며, 이는 TemperatureApp 컴포넌트에서 제공한 onTemperatureChange 콜백 prop을 호출하여 새 온도 값을 인수로 전달합니다.\n그리고 TemperatureApp 컴포넌트는 새 온도 값을 가지고 상태를 업데이트하며, 업데이트된 온도 값과 척도와 함께 두 TemperatureInput 컴포넌트가 다시 렌더링됩니다.\n\n<div class=\"content-ad\"></div>\n\n와우, 여기에 많은 내용이 있어서 이해하기 어렵지 않았으면 좋겠어요.\n\n## 결론\n\nState와 Props를 사용하여 친숙해지세요. 서로 다른 부분을 이해하는 것이 매우 중요하며, 익숙해지면 React로 프로그래밍하는 것은 쉬운 일이 될 것입니다.\n\n# 간단히 설명하면 🚀\n\n<div class=\"content-ad\"></div>\n\n인 플레인 잉글리쉬 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가에게 박수를 보내고 팔로우해 주세요 👏\n- 저희를 팔로우해 주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: 스태카데믹 | 코피드 | 벤처 | 큐브드\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요\n","ogImage":{"url":"/assets/img/2024-05-01-ReactStatevsProps_0.png"},"coverImage":"/assets/img/2024-05-01-ReactStatevsProps_0.png","tag":["Tech"],"readingTime":7},{"title":"데이터 시각화를 위한 최고의 React 차트 라이브러리 8가지🔥(2024년 최신)","description":"","date":"2024-05-01 18:18","slug":"2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024","content":"\n\n![2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_0.png](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_0.png)\n\n현대 애플리케이션에서 데이터 시각화는 중요한 요소로 떠오르고 있습니다. 기업 및 개인들은 데이터 기반 의사 결정을 촉진하기 위해 시각적으로 매력적이고 통찰력 있는 차트에 의존하고 있습니다. 사용자 인터페이스를 만드는 데 널리 사용되는 JavaScript 라이브러리인 React의 등장으로, 앱에 쉽게 통합 가능한 React 차트 라이브러리에 대한 높아진 필요성이 있습니다. 이 글에서는 2024년에 데이터 시각화를 위한 가장 주목할만한 React 차트 라이브러리에 대해 살펴보고, 주요 기능과 실용적인 적용 사례에 대해 밝혀 드리며, 프로젝트에 최적인 React 차트 라이브러리를 선택하는 데 도움을 드릴 것입니다. 📊✨\n\n## 시작해봅시다 👇👇\n\n# Recharts\n\n<div class=\"content-ad\"></div>\n\nRecharts는 개발자들이 쉽고 시각적으로 매력적인 차트를 애플리케이션에 손쉽게 통합할 수 있도록 도와주는 포괄적인 React 차트 라이브러리입니다. 📈 D3.js 위에 구축된 이 라이브러리는 유연성과 간결함 사이의 균형을 이루어 React 환경에서 직관적이면서 강력한 데이터 시각화 솔루션을 찾는 사람들에게 우수한 선택지가 됩니다.\n\n## Recharts 주요 기능:\n\n- 사용 편의성 🚀: Recharts는 선언적이고 컴포넌트 기반 접근 방식을 통해 차트 생성 프로세스를 간단화하며, React 철학과 원활하게 조화를 이룹니다. 이를 통해 초보자와 숙련된 개발자 모두에게 접근하기 쉽게 만들어줍니다.\n- 다양한 차트 유형 📊: 라이브러리는 선형 차트, 막대 차트, 영역 차트, 파이 차트 등 다양한 유형의 차트를 제공합니다. 이 다양성은 Recharts가 다양한 데이터 시각화 요구에 대응할 수 있도록 보장합니다.\n- 반응형 디자인 📱: Recharts는 기본적으로 반응형으로 설계되어 다양한 화면 크기에 자동적으로 적응합니다. 이 기능은 다양한 장치와 플랫폼에서 사용자 친화적인 애플리케이션을 만드는 데 중요합니다.\n- 사용자 정의 옵션 🎨: 개발자는 다양한 스타일 옵션을 사용하여 차트의 외관을 쉽게 사용자 정의할 수 있습니다. 색상, 모양, 툴팁 및 기타 시각적 요소를 구성함으로써 애플리케이션 디자인과 유연성을 일치시킬 수 있습니다.\n- 상호작용 🤝: Recharts는 툴팁 및 확대 등 상호작용 기능을 지원하여 사용자가 데이터를 자세히 탐색하고 이해할 수 있도록 사용자 경험을 향상시킵니다.\n- 애니메이션 지원 🔄: 애니메이션 전환을 통해 차트를 생동감 있게 만들어 데이터 시각화 경험을 더욱 매력적으로 합니다. Recharts는 부드러운 애니메이션을 지원하여 차트에 세련되고 동적인 요소를 추가합니다.\n- React 통합 🔄: React 특화 라이브러리인 Recharts는 React 애플리케이션과 원활하게 통합됩니다. 이는 React 개발자들에게 일관되고 효율적인 개발 프로세스를 보장합니다.\n- 활발한 커뮤니티 🌐: 활발하고 지지력 있는 커뮤니티로 인해 Recharts는 지속적인 개발, 버그 수정 및 best practices 공유의 혜택을 받습니다. 이 커뮤니티 주도 방식은 라이브러리의 신뢰성과 성장에 기여합니다.\n\nhttps://recharts.org/en-US/\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_1.png\" />\n\n# Chartjs\n\nChart.js는 웹 애플리케이션에서 인터랙티브하고 시각적으로 매력적인 차트를 만드는 데 사용되는 인기 있는 JavaScript 라이브러리입니다. Chart.js는 간결성과 유연성으로 유명하여 개발자들이 다양한 종류의 차트를 손쉽게 생성할 수 있습니다. 📈🌐\n\n## Chart.js의 주요 기능:\n\n<div class=\"content-ad\"></div>\n\n- 사용 편의성: Chart.js는 사용자 친화적인 API로 유명하여 모든 기술 수준의 개발자들이 쉽게 이용할 수 있습니다.\n- 반응형 디자인: Chart.js로 생성된 차트는 본질적으로 반응형이며, 다양한 기기와 화면 크기에서 최적의 보기와 상호 작용을 제공합니다. 📱💻\n- 사용자 정의: 디자인 요구 사항을 충족시키기 위해 개발자들이 차트의 모양을 맞춤화할 수 있는 다양한 옵션을 제공합니다.\n- 다양한 차트 유형 지원: Chart.js는 라인 차트, 막대 차트, 레이더 차트 등 다양한 차트 유형을 지원하여 데이터의 시각화에 다양성을 제공합니다.\n- 상호 작용: 사용자는 차트와 상호 작용할 수 있으며, 데이터 포인트 위에 마우스를 올려 세부 정보를 확인할 수 있어 사용자에게 재미있는 경험을 제공합니다.\n- 애니메이션: Chart.js는 부드러운 애니메이션을 포함하여 차트의 시각적 매력을 높이고 동적인 사용자 경험을 제공합니다.\n\nhttps://www.chartjs.org/\n\n![Image](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_2.png)\n\n# React-chartjs-2\n\n<div class=\"content-ad\"></div>\n\nReact-chartjs-2은 Chart.js를 감싸는 React 래퍼로, 인기 있는 JavaScript 차트 라이브러리입니다. React 애플리케이션과 Chart.js가 제공하는 강력한 차트 기능 사이에 원활한 다리 역할을 합니다. 📊🚀\n\n## React-chartjs-2의 주요 기능:\n\n- 쉬운 통합: React-chartjs-2는 Chart.js를 React 애플리케이션에 간단하게 통합하여 개발자들에게 원활하고 번거로움 없는 경험을 제공합니다. 🤝\n- 선언적 구문: React의 선언적 특성을 활용하여, 이 라이브러리는 코드를 더 읽기 쉽고 유지하기 쉬운 깔끔하고 직관적인 구문을 사용하여 차트를 나타낼 수 있습니다. ✨\n- 반응형 디자인: React-chartjs-2로 생성된 차트는 본질적으로 반응형으로, 다양한 화면 크기에 자동으로 조정됨으로써 다양한 기기에서 일관된 사용자 경험을 제공합니다. 📱\n- 사용자 정의 옵션: 이 라이브러리는 다양한 사용자 정의 옵션을 제공하여, 개발자들이 차트의 모양을 프로젝트 요구 사항에 맞게 맞출 수 있습니다. 이는 색상, 라벨, 기타 시각적 요소를 조정하는 것을 포함합니다. 🎨\n- 상호 작용: React-chartjs-2는 툴팁 및 호버 효과와 같은 상호 작용 기능을 지원하여, 차트에 제시된 데이터와의 사용자 상호 작용을 증가시킵니다. 🖱️📈\n- 다양한 차트 유형 지원: 선 차트, 막대 차트, 레이더 차트 등 다양한 차트 유형을 지원하며, 이 다양성으로 다양한 데이터 시각화 요구 사항에 적합합니다. 🔄📉\n- 동적 데이터 바인딩: React-chartjs-2는 동적 데이터 바인딩을 원활하게 처리하여, 기존 데이터가 변경되는 대로 차트를 실시간으로 업데이트할 수 있습니다. ⚡\n- 커뮤니티 지원: Chart.js를 기반으로 하므로, React-chartjs-2는 기존 라이브러리의 강력한 커뮤니티 지원과 지속적인 개발을 상속합니다. 이는 개발자가 최신 기능과 개선 사항에 액세스할 수 있도록 보장합니다. 👩‍💻👨‍💻\n\nhttps://react-chartjs-2.js.org/\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_3.png)\n\n# Victory\n\nVictory는 동적인 React 차트 라이브러리로, 데이터 시각화를 매끄럽고 시각적으로 멋지게 만드는 다양한 기능을 제공하여 눈에 띕니다. 🌐\n\n## 주요 기능:\n\n<div class=\"content-ad\"></div>\n\n- 리액트 중심적 접근 방식: Victory는 특히 React를 위해 설계되었으며 이 인기있는 JavaScript 라이브러리의 모든 잠재력을 활용합니다. 그 컴포넌트들은 React 애플리케이션과 원활하게 통합되어 개발 프로세스를 원활하게 보장합니다.\n- 다양한 차트 유형: Victory는 기본 선 그래프 및 막대 그래프에서 산점도와 히트맵과 같은 더 복잡한 차트까지 다양한 차트 유형을 지원합니다. 이 다양성을 통해 개발자들은 데이터에 가장 적합한 시각화를 선택할 수 있습니다.\n- 반응형 디자인: 📱 Victory는 반응형 디자인 원칙을 받아들여 차트가 서로 다른 화면 크기에 유연하게 대응할 수 있도록 합니다. 이는 다양한 기기에서 최적의 뷰잉 경험을 보장하여 접근성과 사용자 참여를 향상시킵니다.\n- 사용자 정의 기능: 🎨 Victory는 개발자들에게 광범위한 사용자 정의 옵션을 제공하여 색상, 스타일부터 축 구성에 이르기까지 차트의 모양을 자신의 애플리케이션의 시각적 정체성과 일치시킬 수 있습니다.\n- 실시간 업데이트: 🔄 실시간 데이터 업데이트가 필요한 애플리케이션에 대해 Victory는 매끄러운 지원을 제공합니다. 라이브러리는 동적 데이터를 효율적으로 처리하여 성능을 저해하지 않고 차트가 즉시 반영되도록 보장합니다.\n- 상호 작용성: 🖱️ Victory는 상호 작용 요소를 통해 사용자 참여를 향상시킵니다. 호버 효과, 툴팁 및 클릭 이벤트를 통해 사용자들은 데이터를 탐색하고 이해하는 것을 더 직관적으로 할 수 있습니다.\n- 커뮤니티 지원: 👥 리액트 생태계의 필수적인 부분으로 Victory는 활기찬 커뮤니티의 혜택을 받습니다. 개발자들은 문제 해결을 위한 협력적인 환경을 유도하는 충분한 리소스, 튜토리얼 및 서드파티 확장 기능을 찾을 수 있습니다.\n\nhttps://formidable.com/open-source/victory/docs/victory-chart/\n\n![2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_4.png](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_4.png)\n\n# Visx\n\n<div class=\"content-ad\"></div>\n\nVisx는 React 애플리케이션을 위해 특별히 설계된 강력하고 다재다능한 데이터 시각화 라이브러리입니다. 🚀 Airbnb에서 개발되었으며, 커스터마이징과 성능에 중점을 둔 다양한 차트 및 그래프를 생성하기 위한 강력한 구성 요소 세트를 제공합니다.\n\n## Visx의 주요 기능:\n\n- 모듈성 및 확장성 🧩: Visx는 모듈식으로 설계되어 개발자들이 필요에 맞게 구성 요소를 선택할 수 있습니다. 이 모듈성은 유연성을 촉진하고 기존 프로젝트와의 통합을 용이하게 합니다.\n- 선언적 구문 📝: React의 선언적 구문을 이용하여, Visx는 복잡한 시각화를 명확하고 간결하게 표현할 수 있도록 도와줍니다. 이는 초보자와 경험자 모두에게 접근하기 쉽게 만듭니다.\n- 다양한 차트 유형 📊: Visx는 기본적인 선 및 막대 차트부터 트리맵 및 극지 플롯과 같은 고급 시각화까지 다양한 차트 유형을 지원합니다. 이 다양성은 다양한 데이터 표현 요구에 적합합니다.\n- 높은 성능 🚀: 성능 최적화에 중점을 둔 Visx는 대규모 데이터 세트를 처리하면서도 렌더링 속도를 희생하지 않습니다. 이는 특히 상당한 양의 데이터를 처리할 때 부드러운 사용자 경험을 보장합니다.\n- 사용자 정의 옵션 🎨: Visx는 차트의 모양과 동작을 특정 디자인 요구에 맞게 맞춤화할 수 있는 다양한 사용자 정의 기능을 제공합니다. 이 유연성은 현대적인 스타일링 요구를 갖는 프로젝트에 적합합니다.\n- 반응형 디자인 📱: 반응형 디자인 원칙을 지원하는 Visx 차트는 자동으로 다양한 화면 크기에 적응합니다. 이는 데스크톱부터 모바일 기기까지 다양한 장치에서 일관된 시각적으로 매력적인 경험을 보장합니다.\n- 활발한 커뮤니티 지원 🤝: Airbnb와 활발한 오픈 소스 커뮤니티의 지원을 받는 Visx는 정기적인 업데이트와 버그 수정, 그리고 많은 커뮤니티 기여 구성 요소를 활용합니다. 이 지원은 라이브러리가 항상 관련성 있고 신뢰할 수 있도록 합니다.\n- 잘 문서화 📚: Visx는 포괄적인 문서와 예제를 제공하여 개발자들이 쉽게 시작하고 기능을 탐색할 수 있게 도와줍니다. 이는 학습 곡선을 줄이고 프로젝트에 효율적으로 통합하는 데 도움이 됩니다.\n\nhttps://airbnb.io/visx/\n\n<div class=\"content-ad\"></div>\n\n\n![React Chart Libraries](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_5.png)\n\n# Nivo\n\nNivo는 웹 애플리케이션에서 데이터 시각화에 우아함과 기능성을 더해주는 포괄적인 React 차트 라이브러리입니다. 🌐 React와 D3로 개발된 Nivo는 간결성과 다양성으로 눈에 띄며, 개발자가 효율적이고 미적으로 매력적인 해결책을 찾는 데 최적의 선택지입니다.\n\n## Nivo 주요 기능:\n\n<div class=\"content-ad\"></div>\n\n- 다양한 차트 유형 📈: Nivo는 막대 차트, 선 그래프, 파이 차트 등 다양한 차트 유형을 지원합니다. 이 다양성 덕분에 개발자들은 자신의 데이터에 가장 적합한 시각화를 선택할 수 있습니다.\n- 반응형 디자인 📱: Nivo 차트는 기본적으로 반응형으로 제공되어 다양한 화면 크기와 장치에 매끄럽게 적응합니다. 이를 통해 사용자들이 다양한 플랫폼에서 일관되고 시각적으로 매력적인 경험을 할 수 있습니다.\n- 사용자 정의 옵션 🎨: 라이브러리는 다양한 사용자 정의 옵션을 제공하여 개발자들이 그들의 응용 프로그램의 독특한 스타일과 일치하는 차트의 모양을 맞춤화할 수 있게 합니다. 이는 색 구성표, 레이블 및 상호 작용 요소를 포함합니다.\n- 애니메이션 전환 🔄: Nivo는 부드럽고 직관적인 애니메이션 전환으로 사용자 참여를 높입니다. 데이터 포인트 간의 다이내믹한 전환은 차트를 더욱 매력적이고 사용자 친화적으로 만듭니다.\n- 상호 작용 기능 🖱️: Nivo 차트에는 툴팁 및 확대 기능과 같은 상호 작용 기능이 탑재되어 있습니다. 이러한 기능을 통해 사용자들은 시각화 내에서 직접 데이터를 탐색하고 통찰을 얻을 수 있습니다.\n- 범례 및 축 🗂️: 라이브러리는 차트에 범례와 축을 간단하게 추가하도록 도와줍니다. 이는 데이터 해석에 필수적인 컨텍스트를 제공하여 시각화의 전반적인 명확성과 사용성을 높입니다.\n- 쉬운 통합 🧩: Nivo는 개발자 친화적인 API로 설계되어 React 앱에 쉽게 통합됩니다. 라이브러리 문서는 상세하며 구현 프로세스를 최적화하기 위한 명확한 지침과 예제가 제공됩니다.\n- 활발한 커뮤니티 및 업데이트 🚀: Nivo는 활발한 오픈 소스 커뮤니티의 혜택을 받아 정기적인 업데이트와 계속적인 개선이 이루어집니다. 이 지원 네트워크는 도전에 직면한 개발자들이나 고급 구현을 위한 영감을 찾는 데 유용합니다.\n\nhttps://nivo.rocks/components/\n\n![차트 이미지](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_6.png)\n\n# React-stockcharts\n\n<div class=\"content-ad\"></div>\n\n리액트 스톡차트는 리액트 애플리케이션 내에서 금융 및 주식 시장 데이터 시각화를 위해 특별히 설계된 강력한 라이브러리입니다. 📈📊\n\n## 주요 기능:\n\n- 다양한 차트 유형 제공: 리액트 스톡차트는 선 그래프, 캔들스틱 차트, OHLC 차트, 산점도 등 다양한 차트 유형을 지원합니다. 이 다양성은 다양한 금융 데이터셋을 시각화하는 데 적합합니다.\n- 상호 작용 요소: 라이브러리에는 확대, 이동, 툴팁과 같은 내장 상호 작용 기능이 제공됩니다. 사용자는 차트와 상호 작용하여 자세한 데이터 포인트를 탐색하고 분석할 수 있습니다.\n- 기술적 지표: 리액트 스톡차트에는 금융 분석에서 일반적으로 사용되는 포괄적인 기술적 지표가 포함되어 있습니다. 이러한 지표들은 이동 평균, RSI (상대강도지수), MACD (이동평균수렴확산)와 같이 사용자에게 철저한 기술적 분석을 수행할 수 있는 도구를 제공합니다.\n- 반응형 디자인: 라이브러리는 반응형을 고려하여 설계되어 다양한 화면 크기에 매끄럽게 적응합니다. 다양한 기기에서 일관된 사용자 친화적 경험을 제공하는 데 중요합니다.\n- 통합의 용이성: 리액트 스톡차트는 리액트 애플리케이션과 원활하게 통합되도록 개발되었습니다. 모듈화된 구조와 잘 정리된 API로 개발자에게 접근성을 제공하며, 더 빠르고 간편한 통합 프로세스를 용이하게 합니다.\n- 사용자 정의 옵션: 개발자들은 차트의 모양과 동작을 프로젝트 요구 사항에 맞게 사용자 정의할 수 있습니다. 이러한 유연성은 시각적으로 매력적이고 특별한 금융 시각화를 만들 수 있게 합니다.\n- 커뮤니티 지원: 활발하고 적극적인 커뮤니티가 있어 지속적인 개발, 버그 수정, 최고의 사례 공유를 통해 리액트 스톡차트는 발전하고 있습니다. 이는 개발자가 라이브러리를 사용할 때 리소스와 지원에 엑세스할 수 있도록 보장합니다.\n\nhttps://rrag.github.io/react-stockcharts/\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_7.png\" />\n\n# Ant Design Charts\n\nAnt Design Charts는 Ant Design 팀에 의해 개발된 강력하고 다양한 차트 라이브러리로, React 애플리케이션과 매끄럽게 통합되도록 설계되었습니다. 📈🛠️\n\n## 주요 기능:\n\n<div class=\"content-ad\"></div>\n\n- 다양한 차트 유형: Ant Design Charts는 선 그래프, 막대 그래프, 영역 그래프, 원 그래프 등 다양한 차트 유형을 지원합니다. 📊\n- 사용자 정의: 이 라이브러리는 색상 구성표, 레이블, 툴팁 및 기타 시각적 요소를 사용자의 요구에 맞게 조정할 수 있는 포괄적인 사용자 정의 옵션을 제공합니다. 🎨✨\n- 반응형 디자인: Ant Design Charts는 반응형을 고려하여 제작되어, 차트가 다양한 화면 크기와 장치에 맞게 잘 적응됩니다. 이는 다양한 플랫폼 간에 매끄럽게 작동하는 사용자 인터페이스를 만드는 데 중요합니다. 📱💻\n- 상호 작용 요소: 이 라이브러리는 줌, 이동, 가리기 등과 같은 상호 작용 기능을 지원하여 사용자 경험을 향상시키고 데이터를 보다 효과적으로 탐색하고 분석할 수 있게 합니다. 🔄🖱️\n- 통합 용이성: Ant Design Charts는 React 애플리케이션에 쉽게 통합할 수 있도록 설계되어, 개발 프로세스를 간소화하고 개발자의 학습 곡선을 줄입니다. ⚙️👩‍💻\n- 문서 및 커뮤니티 지원: 이 라이브러리는 포괄적인 문서와 활발한 커뮤니티의 혜택을 받아, 개발자들이 지원을 찾고 문제를 해결하며 모범 사례를 최신 상태로 유지하는 데 용이합니다. 📚👥\n\nhttps://ant-design-charts-next.antgroup.com/\n\n![Top 8 React Chart Libraries for Data Visualization in 2024](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_8.png)\n\n## 읽어 주셔서 감사합니다 ❤️❤️","ogImage":{"url":"/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_0.png"},"coverImage":"/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_0.png","tag":["Tech"],"readingTime":10},{"title":"React 테스팅 라이브러리들 정리","description":"","date":"2024-05-01 18:17","slug":"2024-05-01-ReactTestingLibraries","content":"\n\nReact에서의 테스트에는 두 가지 세계가 있어요: 하나는 UserEvent이고, 다른 하나는 FireEvent에요. 대다수의 사람들은 FireEvent에 대해 알고 있어요. 둘 다 기본적으로 리액트 테스트 라이브러리로, 프론트엔드 테스트를 작성하고 클릭 또는 입력란 작성과 같은 이벤트를 시뮬레이트할 수 있는 도구에요. 그래서 사용자가 수행했을 법한 작업을 시뮬레이트하며, 실제 사용자를 참여시키지 않고도 테스트를 작성하며 동시에 그 작업의 기능 또는 동작을 테스트하는 거예요.\n\n위에서 언급된 것들을 사용해야 하는 이유가 더 많지만, 원래 논의로 돌아와서 더 나은 것은 무엇일까요? 두 가지를 함께 검토하고 우리 도메인에 더 적절한 것은 무엇인지 결론 내보도록 하죠.\n\n두 방법 간의 차이를 이해하기 위해 작은 예시를 살펴보죠. 이 예시는 인사 상자 애플리케이션으로, 사용자가 이름을 입력하고 인사 버튼을 누르면 인사말이 표시되는 애플리케이션입니다.\n\n![ReactTestingLibraries_0.png](/assets/img/2024-05-01-ReactTestingLibraries_0.png)\n\n<div class=\"content-ad\"></div>\n\n이 애플리케이션에 대한 테스트를 작성하는 방법을 생각해보세요. 가장 기본적이면서 명확한 테스트 중 하나는 \"사용자가 이름을 입력하고 인사 버튼을 클릭하면 인사말이 표시되어야 합니다.\" 입니다. 이 테스트를 작성해 보겠습니다. 하지만 그 전에 비슷한 기능을 가진 리액트 애플리케이션을 만드십시오.\n\n다음 주소에서 프로젝트를 복제하세요: https://github.com/Rajshree02/react-testing-library\n\n다음과 같은 라이브러리를 App.test.js 파일에 가져와 테스트를 수행하십시오.\n\n```js\nimport { fireEvent, render, screen } from \"@testing-library/react\";\nimport App from \"./App\";\nimport userEvent from \"@testing-library/user-event\";\n```\n\n<div class=\"content-ad\"></div>\n\n## FireEvent\n\n이 라이브러리는 DOM 이벤트를 발생시킵니다. DOM(Data Object Model)은 여러분이 아시다시피 언어와는 무관한 인터페이스로, 여러분의 프론트엔드 프레임워크와 라이브러리가 웹 페이지와 상호작용할 수 있도록 도와줍니다. 따라서, FireEvent를 사용할 때는 기본적으로 DOM과 밀접하게 작업하게 되며, 때로는 이 FireEvent가 그 DOM에 대한 래퍼로 간주되기도 합니다.\n\n아래는 FireEvent를 사용하여 우리의 환영 메시지 애플리케이션을 테스트하는 코드 조각입니다.\n\n```js\ntest(\"버튼 클릭 시 환영 메시지가 나타나야 합니다\", () => {\n  const window = render(<App />);\n  const inputBox = window.getByLabelText(\"당신의 이름을 입력하세요\");\n\n  fireEvent.change(inputBox, { target: { value: \"John\" } });\n  expect(inputBox).toHaveValue(\"John\");\n  const button = screen.getByRole(\"button\");\n  fireEvent.click(button);\n  const actualGreet = window.getByText(\"안녕하세요 John !!\");\n\n  expect(actualGreet).toBeInTheDocument();\n});\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 여기서 생기는 질문은 진짜 중요한가? 그리고 그럴 때 또 다른 옵션이 있습니다.\n\n## UserEvent\n\n위의 질문에 대답하면, 중요하다는 것입니다. 왜냐하면 마지막으로 이를 사용하는 것은 UI를 테스트하기 때문입니다. 그러니까, 특정 컴포넌트의 동작을 이해하고 싶다면, 이 옵션이 좋은 선택일 것입니다. 그러나 사용자의 작업을 시뮬레이트하고 작업과 관련된 기능을 테스트하려면 UserEvent를 사용하세요. 그러니까, 사용자가 애플리케이션과 상호 작용할 때, 화면이나 표시된 UI는 DOM이 아닙니다. 사용자가 상호 작용하거나 변경하는 화면이 브라우저에 의해 DOM에 반영되고 사용자가 DOM과 상호 작용할 때 발생하는 일련의 일들이 있습니다. 예를 들어, 사용자가 텍스트 상자에 입력하면 요소가 포커싱되어야 하고 키보드 및 입력 이벤트가 발생하며 선택 및 값이 타이핑하는 동안 조작됩니다. FireEvent의 경우, 이러한 단계들이 생략되어 개발자로 하여금 DOM의 어떤 요소에 대한 이벤트도 트리거할 수 있게 됩니다.\n\nUserEvent는 테스트를 작성하고 사용자가 시스템과 실제로 상호 작용하는 방식을 테스트할 수 있게 도와줍니다. 그래서 이것을 사용하면 사용자가 키보드를 사용하여 입력하는 동안 발생하는 일련의 단계를 테스트할 수 있습니다. 아래는 UserEvent를 사용하여 인사 애플리케이션을 테스트하는 코드 스니펫입니다.\n\n<div class=\"content-ad\"></div>\n\n이 두 가지를 조금 설명한 후에 애플리케이션에 맞는 것을 결정해보세요.","ogImage":{"url":"/assets/img/2024-05-01-ReactTestingLibraries_0.png"},"coverImage":"/assets/img/2024-05-01-ReactTestingLibraries_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법","description":"","date":"2024-05-01 18:15","slug":"2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18","content":"\n\n\n![이미지](/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png)\n\n# 소개\n\nReact는 사용자 인터페이스를 만들기 위한 인기있는 JavaScript 라이브러리이며, 최근 버전에서 상당한 개선을 거쳤습니다. React 18을 통해 개발자들은 이제 비즈니스 로직을 UI 구성 요소에서 효과적으로 분리하는 더 강력한 도구를 갖게 되었습니다. 이 글에서는 비즈니스 로직과 UI 구성 요소를 분리하는 장점을 탐구하고, React 18의 새로운 기능을 사용하여 이를 어떻게 달성할 수 있는지 보여줄 것입니다.\n\n# 목차\n\n<div class=\"content-ad\"></div>\n\n- 비즈니스 로직과 UI 구성 요소를 왜 분리해야 할까요?\n- 비즈니스 로직 분리를 위한 React 18의 새로운 기능들\n- 비즈니스 로직 분리하기: 단계별 안내서\n- React 18에서 비즈니스 로직 분리를 위한 고급 기술\n- 결론\n- 참고 자료\n\n# 비즈니스 로직과 UI 구성 요소를 왜 분리해야 할까요?\n\n- 코드 재사용성: 비즈니스 로직이 분리되면 응용 프로그램의 다른 부분이나 다른 프로젝트에서도 쉽게 구성 요소를 재사용할 수 있습니다.\n- 테스트: 비즈니스 로직과 UI 구성 요소를 독립적으로 단위 테스트할 수 있으므로 테스트가 더 간단해집니다. 이는 테스트 범위와 전체 코드 품질을 향상시킵니다.\n- 가독성 및 유지보수성: 비즈니스 로직을 UI 구성 요소에서 분리하면 더 깨끗하고 유지보수가 쉬운 코드가 됩니다. 각 부분의 책임을 이해하기 쉬워집니다.\n- 확장성: 응용 프로그램이 성장함에 따라 관심을 분리하면 충돌 없이 개발자가 코드베이스의 다른 부분에 동시에 작업할 수 있습니다.\n\n# React 18의 비즈니스 로직 분리를 위한 새로운 기능들\n\n<div class=\"content-ad\"></div>\n\n## 리액트 훅\n\n리액트 16.8에서 소개된 리액트 훅은 클래스 컴포넌트를 작성하지 않고도 상태 및 다른 리액트 기능을 사용할 수 있는 방법을 제공합니다. useState 및 useEffect와 같은 훅을 사용하면, 개발자는 비즈니스 로직을 캡슐화하고 컴포넌트 간에 재사용할 수 있습니다.\n\n## 동시 모드의 서스펜스\n\n리액트 18에서는 동시 모드와 서스펜스에서 개선 사항을 가져왔습니다. 동시 모드를 통해 리액트가 동시에 여러 작업을 처리하여 더 나은 성능을 제공합니다. 서스펜스는 선언적 데이터 가져오기와 코드 분할을 가능하게 하여 비동기 작업을 쉽게 다룰 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 비즈니스 로직 분리하기: 단계별 안내\n\n## 단계 1: 비즈니스 로직 식별\n\n컴포넌트에서 데이터, 상태를 관리하거나 API 호출을 수행하는 작업과 관련된 부분을 식별합니다.\n\n## 단계 2: 커스텀 훅 생성\n\n<div class=\"content-ad\"></div>\n\n지정된 비즈니스 로직을 캡슐화하기 위해 사용자 정의 훅을 생성하세요. 사용자 정의 훅은 use로 시작하는 함수입니다. 내부적으로 다른 훅을 사용할 수 있습니다.\n\n코드 예시 (사용자 정의 훅):\n\n```js\n// useUserData.js\nimport { useState, useEffect } from 'react';\n\nexport function useUserData() {\n  const [userData, setUserData] = useState([]);\n\n  useEffect(() => {\n    // API에서 사용자 데이터를 가져와 상태를 업데이트합니다.\n    fetch('https://api.example.com/users')\n      .then((response) => response.json())\n      .then((data) => setUserData(data))\n      .catch((error) => console.error('데이터를 가져오는 중 오류 발생:', error));\n  }, []);\n\n  return userData;\n}\n```\n\n## 단계 3: 컴포넌트에서 사용자 정의 훅 사용하기\n\n<div class=\"content-ad\"></div>\n\nUI 컴포넌트 내에서 비즈니스 로직과 데이터에 접근하기 위해 사용자 정의 후크를 활용하세요. 이렇게 하면 컴포넌트가 렌더링에 집중하고, 후크가 내부 로직을 처리합니다.\n\n코드 예시 (컴포넌트에서 사용자 정의 후크 사용):\n\n```js\n// UserList.js\nimport React from 'react';\nimport { useUserData } from './useUserData';\n\nfunction UserList() {\n  const userData = useUserData();\n\n  return (\n    <div>\n      <h1>사용자 목록</h1>\n      <ul>\n        {userData.map((user) => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## 단계 4: Suspense를 사용한 코드 분할\n\n<div class=\"content-ad\"></div>\n\nSuspense를 사용하면 비동기 데이터 가져오기나 계산이 많이 필요한 컴포넌트를 코드로 나누고 지연로드할 수 있어요. 이렇게 하면 관심사를 분리하고 애플리케이션의 성능을 향상시킬 수 있어요.\n\n코드 예시 (Suspense를 사용한 코드 분할):\n\n```js\n// App.js\nimport React, { Suspense } from 'react';\nconst UserList = React.lazy(() => import('./UserList'));\n\nfunction App() {\n  return (\n    <div>\n      <h1>나의 앱</h1>\n      <Suspense fallback={<div>로딩 중...</div>}>\n        <UserList />\n      </Suspense>\n    </div>\n  );\n}\n```\n\n# 리액트 18에서 비즈니스 로직 분리를 위한 고급 기술\n\n<div class=\"content-ad\"></div>\n\n## 1. 커스텀 훅 조합\n\n커스텀 훅의 강력한 측면 중 하나는 더 복잡한 로직을 만들기 위해 조합할 수 있다는 것입니다. 여러 커스텀 훅을 결합함으로써, 복잡한 비즈니스 로직을 구축하면서 UI 컴포넌트를 깔끔하고 집중적으로 유지할 수 있습니다.\n\n코드 예시 (커스텀 훅 조합):\n\n```js\n// useUserData.js\nimport { useState, useEffect } from 'react';\n\nexport function useUserData() {\n  const [userData, setUserData] = useState([]);\n\n  useEffect(() => {\n    // API에서 사용자 데이터를 가져와 상태를 업데이트합니다\n    fetch('https://api.example.com/users')\n      .then((response) => response.json())\n      .then((data) => setUserData(data))\n      .catch((error) => console.error('데이터를 불러오는 중 오류 발생:', error));\n  }, []);\n\n  return userData;\n}\n\n// useFilteredUserData.js\nimport { useUserData } from './useUserData';\n\nexport function useFilteredUserData(searchTerm) {\n  const userData = useUserData();\n\n  // 검색어를 기반으로 사용자 데이터 필터링\n  const filteredData = userData.filter((user) =>\n    user.name.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  return filteredData;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n`useFilteredUserData` 훅을 사용하면 검색어에 기반을 둔 필터링된 사용자 데이터를 가져올 수 있으며, `useUserData`에서 가져오는 로직을 재사용할 수 있습니다. 이 합성 접근 방식은 로직을 모듈식으로 유지하고 컴포넌트 간에 재사용할 수 있도록 합니다.\n\n## 2. 부수효과를 위한 커스텀 훅\n\n가끔 비즈니스 로직에는 데이터 가져오기 이상의 부수효과가 필요할 수 있습니다. 예를 들어 타이머 관리나 외부 API와의 상호작용과 같은 것들이 있습니다. 커스텀 훅은 이러한 부수효과를 캡슐화하여 컴포넌트 간에 일관되게 처리되도록 보장합니다.\n\n코드 예시 (타이머용 커스텀 훅):\n\n<div class=\"content-ad\"></div>\n\n```js\n// useTimer.js\nimport { useState, useEffect } from 'react';\n\nexport function useTimer(initialTime = 0) {\n  const [time, setTime] = useState(initialTime);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setTime((prevTime) => prevTime + 1);\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, []);\n\n  return time;\n}\n```\n\n이제 인터벌을 관리할 걱정 없이 타이머 기능을 모든 컴포넌트에 쉽게 통합할 수 있습니다.\n\n## 3. 전역 상태 관리를 위한 컨텍스트\n\n여러 컴포넌트 간에 공유해야 하는 상태 관리를 위해 React 18의 Context API를 활용할 수 있습니다. 비즈니스 로직에 대한 컨텍스트를 생성함으로써 어떤 컴포넌트에서든 해당 상태와 액션에 접근할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n코드 예제 (상태 관리를 위해 컨텍스트 사용):\n\n```js\n// UserDataContext.js\nimport React, { createContext, useContext } from 'react';\nimport { useUserData } from './useUserData';\n\nconst UserDataContext = createContext();\n\nexport function UserDataProvider({ children }) {\n  const userData = useUserData();\n\n  return (\n    <UserDataContext.Provider value={userData}>\n      {children}\n    </UserDataContext.Provider>\n  );\n}\n\nexport function useUserDataContext() {\n  return useContext(UserDataContext);\n}\n```\n\nUserDataContext와 useUserDataContext 훅을 사용하여 UserDataProvider 내의 모든 컴포넌트에서 프롭 전달 없이 사용자 데이터에 액세스할 수 있습니다.\n\n## 4. Cross-Cutting Concerns을 위한 Higher-Order Components (HOCs)\n\n<div class=\"content-ad\"></div>\n\n여러 컴포넌트에 특정 로직을 적용해야 하는 경우, 고차 컴포넌트(Higher-Order Components, HOCs)를 사용할 수 있어요. HOCs는 컴포넌트를 가져와서 추가 프롭이나 로직이 포함된 새로운 컴포넌트를 반환하는 함수들이에요.\n\n코드 예시 (스타일링을 위한 HOC):\n\n```js\n// withStyles.js\nimport React from 'react';\n\nfunction withStyles(WrappedComponent) {\n  return function WithStyles(props) {\n    return (\n      <div style={{ color: 'blue' }}>\n        <WrappedComponent {...props} />\n      </div>\n    );\n  };\n}\n\n// 사용 예시\nconst MyComponent = ({ name }) => <div>Hello, {name}!</div>;\nconst StyledComponent = withStyles(MyComponent);\n```\n\n이제 StyledComponent는 MyComponent에 정의된 스타일들을 자동으로 적용해요. 여러 곳에서 스타일 선언을 반복할 필요가 없어졌어요.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nReact 18의 새로운 기능을 활용하여 사용자 정의 훅, Suspense 및 Context API를 포함한 고급 기술을 효과적으로 구현할 수 있습니다. 이를 통해 비즈니스 로직과 UI 구성 요소를 보다 효과적으로 분리할 수 있습니다. 사용자 정의 훅 조합, 부작용 처리, 전역 상태 관리를 위한 Context API, 그리고 고차 컴포넌트를 활용하여 개발자는 모듈화되고 유지보수가 용이한 React 애플리케이션을 만들 수 있습니다.\n\n이러한 기술을 적용함으로써 개발자는 코드 구성을 개선하고 성능을 향상시키면서 더욱 확장 가능하고 유지보수가 쉬운 애플리케이션을 구축할 수 있습니다.\n\n# 참고 문헌\n\n<div class=\"content-ad\"></div>\n\n- React 문서\n- React에서 Hooks 소개\n- React 18 알파 - 동시 모드\n- 상태 Hook 사용하기\n- 데이터 가져오기용 서스펜스\n- React 커스텀 훅 - 구성\n- React 컨텍스트\n- React 고차 컴포넌트\n\n이러한 참고 자료는 React 18의 새로운 기능과 비즈니스 로직을 UI 컴포넌트에서 분리하기 위한 모베스트 프랙티스에 대한 심도 있는 정보를 제공합니다.\n\n![이미지](/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_1.png)\n\n이 글이 도움이 되셨나요? 좋아요나 코멘트를 남겨주세요. 고맙습니다 🙏.","ogImage":{"url":"/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png"},"coverImage":"/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png","tag":["Tech"],"readingTime":8},{"title":"React Native 앱 디버깅하는 방법","description":"","date":"2024-05-01 18:14","slug":"2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies","content":"\n\n<img src=\"/assets/img/2024-05-01-ReactNativeAppsDebuggingTopToolsandStrategies_0.png\" />\n\n리액트 네이티브 앱을 디버깅하는 것은 도전일 수 있어요! 제게 (그리고 많은 개발자들에게) 도움이 된 몇 가지 필수 도구와 전략이 있답니다:\n\n## 도구:\n\n- React Native Debugger: 필수품! 디버거, 콘솔, 요소 검사기를 비롯한 종합적인 디버깅 환경을 제공해줘요.\n- Chrome DevTools: Chrome DevTools 디버거를 사용하여 코드를 디버깅하고 중지점을 설정하고 변수를 검사할 수 있어요.\n- Console.log(): 간단하지만 효과적이에요. console.log()를 사용하여 변수, 함수, 오류를 콘솔에 출력해주세요.\n- React Native CLI: React Native CLI를 사용하여 앱을 실행할 때 — debug 플래그를 사용하여 디버깅 기능을 활성화할 수 있어요.\n- Flipper: React Native를 위한 인기 있는 디버깅 도구로, 디버거, 콘솔 등을 제공해줘요.\n\n<div class=\"content-ad\"></div>\n\n# 전략:\n\n- 분할 정복: 문제를 격리하기 위해 코드를 주석 처리하고 작은 구성 요소를 테스트하며 문제를 추적하기 위해 console.log()을 사용합니다.\n- 콘솔 확인: 정기적으로 콘솔을 확인하여 오류, 경고 및 로그를 확인하여 문제를 식별합니다.\n- 디버거 사용: 중단점을 설정하여 코드를 따라가고 변수를 검사하여 흐름을 이해하고 문제를 식별합니다.\n- 구성 요소 검사: 요소 검사기를 사용하여 구성 요소 계층 구조, 속성 및 상태를 검사합니다.\n- 다른 기기에서 테스트: 여러 기기 및 시뮬레이터에서 테스트하여 문제가 특정 기기에 종속되지 않도록합니다.\n- 제3자 라이브러리 확인: 제3자 라이브러리가 최신 상태이며 올바르게 구성되어 있는지 확인합니다.\n- 온라인 검색: 유사한 문제, GitHub 문제 및 Stack Overflow 질문을 검색하여 솔루션을 찾습니다.\n\n# 성공 (그리고 실패!):\n\n- 성공: React Native Debugger를 사용하여 제3자 라이브러리와 관련된 까다로운 문제를 식별했습니다.\n- 실패: 몇 시간 동안 디버깅을 한 후에야 단순한 오타였음을 깨달았습니다!\n\n<div class=\"content-ad\"></div>\n\n이제 여러분들의 차례입니다! 좋아하는 디버깅 도구와 전략을 공유해 주세요. 함께 서로의 경험을 나누며 배워봐요!","ogImage":{"url":"/assets/img/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies_0.png"},"coverImage":"/assets/img/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies_0.png","tag":["Tech"],"readingTime":2},{"title":"대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)","description":"","date":"2024-05-01 18:13","slug":"2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery","content":"\n\n<img src=\"/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png\" />\n\n리액트 애플리케이션에서 상태를 관리하는 것은 복잡하고 시간이 많이 소모되는 작업일 수 있습니다. 애플리케이션이 커지고 복잡해지면 상태를 확장 가능하고 유지 보수 가능한 방식으로 관리하기가 점점 어려워집니다. 다행히 React용으로 제공되는 가벼운 강력한 상태 관리 라이브러리가 여러 개 있습니다. 이 글에서는 이 중 두 개의 라이브러리인 Zustand와 React Query를 살펴보고, React 애플리케이션에서 상태를 관리하는 견고하고 유연한 솔루션을 제공하는 방법을 보여줄 것입니다.\n\n# Zustand란 무엇인가요?\n\nZustand는 함수형 프로그래밍 개념을 사용하여 상태를 정의하고 관리하는 React용 가벼운 상태 관리 라이브러리입니다. Redux와 달리 Zustand는 전역 저장소나 복잡한 액션 및 리듀서 집합에 의존하지 않습니다. 대신, Zustand를 사용하면 간단한 자바스크립트 객체와 함수를 사용하여 상태를 정의할 수 있습니다. 이를 통해 더 복잡한 상태 관리 솔루션의 부하 없이 상태를 확장 가능하고 유지 보수 가능한 방식으로 정의하고 관리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nZustand은 상태에 액세스하고 업데이트 기능을 제공하는 사용자 정의 React 훅을 생성하여 작동합니다. 이 훅은 응용 프로그램 어디에서나 상태에 액세스하고 업데이트할 수 있습니다. Zustand는 상태를 정의하고 다양한 방법으로 조작하기 쉽게 하는 도우미 함수 및 유틸리티 세트를 제공합니다.\n\n# React Query란?\n\nReact Query는 React용 강력하고 유연한 데이터 검색 및 캐싱 라이브러리입니다. REST API, GraphQL API 등 다양한 소스에서 데이터를 가져오는 간단하고 선언적인 API를 제공합니다. React Query는 또한 응용 프로그램에서 서버 상태를 관리하는 데 사용할 수 있는 강력한 캐싱 레이어를 제공합니다.\n\nReact Query의 주요 이점 중 하나는 그 유연성입니다. 자동 재시도, 백그라운드 다시 가져오기 등을 지원하는 데이터 검색 및 캐싱을 구성하는 다양한 옵션을 제공합니다. 이를 통해 사용자 지정 로직이나 보일러플레이트 없이도 응용 프로그램에서 다양한 데이터 검색 및 캐싱 시나리오를 쉽게 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Zustand과 React Query 함께 사용하기\n\nZustand과 React Query는 각각 강력한 상태 관리 라이브러리입니다. 하지만 두 라이브러리를 함께 사용하면 더욱 강력한 기능을 발휘할 수 있습니다. 두 라이브러리를 결합하여 React 애플리케이션에서 상태를 효과적으로 관리하는 견고하고 유연한 솔루션을 만들 수 있습니다.\n\n전반적으로 접근 방식은 간단합니다. Zustand를 사용하여 애플리케이션의 로컬 상태를 관리하고, React Query를 사용하여 서버 상태를 관리합니다. Zustand는 함수형 프로그래밍 개념을 활용하여 간단하고 유연하게 로컬 상태를 정의하고 관리할 수 있는 방법을 제공하는 반면, React Query는 선언적 API를 활용하여 강력하고 유연하게 서버 상태를 관리할 수 있습니다.\n\n실제로 이를 구현하는 방법을 좀 더 자세히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Zustand을 사용하여 상태 정의하기\n\nZustand와 React Query를 함께 사용하는 첫 번째 단계는 Zustand를 사용하여 애플리케이션의 상태를 정의하는 것입니다. 이 과정은 상태를 정의하고 업데이트 함수 집합을 제공하는 사용자 정의 훅을 생성하는 것을 포함합니다.\n\n다음은 이 과정이 어떻게 보일 수 있는지 예시입니다:\n\n![예시](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_1.png)\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 Zustand를 사용하여 상태를 관리하는 간단한 카운터를 정의하고 있습니다. useStore 훅은 count 속성과 상태를 업데이트하는 데 사용할 수 있는 increment 및 decrement 함수를 포함하는 객체를 반환합니다.\n\n# Zustand과 React Query를 함께 사용하는 방법\n\n이제 Zustand와 React Query를 함께 사용하는 장점을 이해했으니, Zustand를 활용한 애플리케이션에서 React Query를 구현하는 방법을 살펴보겠습니다.\n\n- React Query 설치하기\n\n<div class=\"content-ad\"></div>\n\n먼저 React Query와 그 종속성들을 설치해야 합니다. 터미널을 열고 프로젝트 디렉토리로 이동하세요.\n\n다음 명령어를 실행하세요:\nnpm install react-query\n\n2. React Query 공급자 설정\n\nReact Query를 사용하려면 QueryClientProvider 컴포넌트로 애플리케이션을 감싸야 합니다. 이 컴포넌트는 React Query가 제대로 작동할 수 있도록 필요한 컨텍스트를 제공합니다. 루트 컴포넌트 파일에서 필요한 종속성을 import하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_2.png)\n\n여기서는 QueryClient의 새 인스턴스를 생성하고 queryClient를 속성으로 전달하여 전체 애플리케이션을 QueryClientProvider 내에 래핑합니다.\n\n3. React Query를 사용하여 데이터 가져오기\n\nReact Query는 데이터를 가져오기 위한 간단하고 선언적인 API를 제공합니다. React Query를 사용하여 API 엔드포인트에서 데이터를 가져오는 예제를 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_3.png)\n\n이 예시에서는 React Query의 useQuery 훅을 사용하여 /api/users 엔드포인트에서 데이터를 가져오고 있습니다. useQuery의 첫 번째 인자는이 쿼리를 식별하는 고유한 키입니다. 두 번째 인자는 데이터를 가져오는 비동기 함수입니다. React Query는 캐싱, 백그라운드 재검색 및 오류 처리를 처리해줍니다.\n\nuseQuery 훅은 데이터, 로딩 상태 및 오류 여부 속성이 있는 객체를 반환합니다. 이러한 속성을 사용하여 데이터 가져오기 프로세스의 다른 상태를 처리할 수 있습니다.\n\n4. Zustand과 React Query를 결합하기\n\n<div class=\"content-ad\"></div>\n\nZustand과 React Query를 결합하기 위해 React Query의 데이터를 Zustand 상태에 통합할 수 있습니다. Zustand를 사용하여 전역 상태를 관리하고 React Query를 사용하여 데이터를 가져오고 업데이트할 수 있습니다.\n\nReact Query 데이터를 Zustand에 통합하는 예시를 살펴봅시다:\n\n![image](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_4.png)\n\n이 예시에서 useStore 훅을 사용하여 Zustand에서 users 상태를 정의합니다. 또한 상태를 업데이트하는 setUsers 함수를 정의합니다. UsersList 컴포넌트 내에서는 API 엔드포인트에서 데이터를 가져오기 위해 useQuery 훅을 사용합니다. 데이터를 가져올 때 setUsers 함수를 호출하여 가져온 데이터로 Zustand 상태를 업데이트합니다.\n\n<div class=\"content-ad\"></div>\n\nZustand과 React Query를 결합하여 전역 상태를 쉽게 관리할 수 있습니다. Zustand를 사용하면서 React Query의 강력한 데이터 가져오기 및 캐싱 기능을 활용할 수 있습니다.\n\n## Zustand과 React Query를 함께 사용하는 장점\n\n이전에 언급한대로, Zustand와 React Query는 React 애플리케이션용 강력한 상태 관리 라이브러리입니다. 함께 사용할 때는 Redux나 각각 사용하는 것보다 여러 장점을 제공합니다. 이러한 장점을 자세히 살펴보겠습니다.\n\n- 코드 간소화\n\n<div class=\"content-ad\"></div>\n\nZustand과 React Query를 함께 사용하는 가장 중요한 장점 중 하나는 코드를 간소화한다는 것입니다. Zustand는 응용 프로그램 상태를 관리하기 위한 간단한 API를 제공하며, React Query는 데이터 가져오기와 캐싱을 간단하게 만들어줍니다. 이 둘을 함께 사용하면 그렇지 않았다면 작성해야 했을 많은 뼈대 코드를 제거할 수 있습니다.\n예를 들어, Zustand를 사용하여 응용 프로그램의 전역 상태를 관리하고, 그런 다음 React Query를 사용하여 API에서 데이터를 가져올 수 있습니다. 이를 통해 데이터와 UI를 분리하여 코드를 더 모듈식으로 유지하고 이해하기 쉽게 만들 수 있습니다.\n\n2. 성능 향상\n\nReact Query의 캐싱 메커니즘은 응용 프로그램에 훌륭한 성능 향상을 제공합니다. 클라이언트 측에서 데이터를 캐시함으로써 응용 프로그램이 수행하는 네트워크 요청의 수를 줄일 수 있어 더 빠르고 반응성이 향상됩니다.\n\nZustand의 작은 크기와 간결함도 성능 향상에 기여합니다. Redux보다 훨씬 작기 때문에 로드하는 데 더 빠르고 응용 프로그램의 메모리 풋프린트를 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3. 쉬운 통합\n\nZustand와 React Query는 기존의 React 애플리케이션에 쉽게 통합할 수 있습니다. Zustand는 React의 훅과 잘 작동하는 간단한 API를 제공하여 구성 요소에 쉽게 통합할 수 있습니다. React Query도 통합하기 쉽고 데이터 가져오기 라이브러리와 함께 사용할 수 있어 유연하고 사용자 정의가 가능합니다.\n\n4. 확장성\n\nZustand의 간결함은 소규모에서 중규모 애플리케이션에 좋은 선택입니다. 그러나 React Query와 결합하면 대규모 복잡한 애플리케이션을 구축하는 강력한 도구가 됩니다. React Query의 캐싱 메커니즘과 다른 라이브러리와의 쉬운 통합은 애플리케이션의 확장에 좋은 선택입니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\nZustand과 React Query는 함께 사용할 때 React 애플리케이션에서 상태를 관리하고 데이터를 가져오는 간단하고 확장 가능한 솔루션을 제공하는 강력한 상태 관리 라이브러리입니다. Zustand는 로컬 상태의 관리를 간소화하고, React Query는 서버 상태를 처리하고 성능있는 캐싱 레이어를 제공합니다.\n\nReact Query를 Zustand와 통합함으로써 React 애플리케이션에서 코드를 단순화하고 성능을 향상시키며 쉽게 통합하고 확장 가능성을 높일 수 있습니다. 작은 프로젝트나 대규모 애플리케이션을 구축하더라도 Zustand와 React Query는 상태 관리와 데이터 가져오기에 강력하고 유연한 솔루션을 제공합니다.\n\n다음 React 프로젝트에 Zustand와 React Query를 통합하여 상태 관리 작업에서 가져다 주는 효율성과 생산성을 경험해보세요.","ogImage":{"url":"/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png"},"coverImage":"/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png","tag":["Tech"],"readingTime":6}],"page":"148","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":11,"currentPageGroup":7},"__N_SSG":true}