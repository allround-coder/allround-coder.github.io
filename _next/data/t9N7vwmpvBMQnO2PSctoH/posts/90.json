{"pageProps":{"posts":[{"title":"ChatGPT-4o, 오픈AI의 새로운 주력 모델 전체 리뷰","description":"","date":"2024-05-15 11:35","slug":"2024-05-15-ChatGPT-4oOpenAIsNewFlagshipModelsFullReview","content":"\n\n일년 만에 OpenAI의 새로운 모델, 그들의 트랜스포머 패밀리의 최신 버전인 GPT-4o (\"omnimodal\")가 드디어 나왔어요.\n\n이 모델은 텍스트, 오디오, 이미지, 비디오 처리 및 이미지 생성에서 엄청나게 빠르며, 코딩 및 멀티모달 추론 개선을 보여주고 있어요. 또한 3D 렌더링과 같은 새로운 형태의 모달리티를 가능하게 합니다.\n\n그리고 lmsys.org의 챗봇 아레나에 따르면, 약 두 주 전에 우리가 논의한 유명한 gpt2-chatbot의 프록시 모델로부터 얻은 결과를 기반으로 이미 최고의 올라운드 모델이라고 해요.\n\n하지만 이번에 모델을 공개한 이유는 Sam Altman이 말한 대로 \"무지의 가리개를 밀어내는 것\"이 아니라, 최첨단 인공지능을 수십억 명의 손에 무료로 전달하는 것에 있어요.\n\n\n\n여기 ChatGPT-4o에 대해 알아야 할 모든 정보가 있어요.\n\n# 다중성의 저주\n\n다중 모닥과 대형 언어 모델, 즉 MLLM은 상당한 시간 동안 존재해 왔지만, GPT-4o는 오디오, 비디오, 이미지 및 텍스트 네 가지 다른 모드에 걸친 진정한 다중 모달리티를 보여주는 첫 번째 모델로 보입니다.\n\n- 네, Gemini 1.5와 같은 모델은 후자 세 가지에 대해 진정으로 다중 모단에 보였지만, 오디오에 대해서는 아니었어요.\n- 실제로, GPT-4V는 오디오 처리/생성 및 이미지 생성을 허용했지만, Whisper, OpenAI TTO 및 Dall-e3와 별도의 모델들과 통합하여 해당 기능들을 가능하게 했어요.\n\n\n\n안녕하세요! ChatGPT-4o는 모든 모달리티에 기본적으로 작동하는 하나의 단일 모델을 의미하는 올인원 모델입니다.\n\n그런데 이게 무슨 의미일까요?\n\n## 다중 모달리티 입력, 다중 모달리티 출력\n\n이에 대해 더 자세히 이야기할 것이며, 이번 주 목요일에 무료 뉴스레터를 통해 더 많은 내용을 알려드리겠습니다 (위 참조).\n\nChatGPT-4o는 이제 더 이상 \"그저 큰 언어 모델\"이 아니라는 아이디어입니다.\n\n\n\n대형 언어 모델(LLMs)은 시퀀스 대 시퀀스 모델입니다(입력과 출력이 모두 시퀀스인 모델). 보통 텍스트를 입력으로 받아 다른 텍스트를 출력합니다.\n\n이 이미지 인코더와 같은 구성 요소와 결합하면 이미지도 처리할 수 있으며, 다른 모달리티에도 동일하게 적용됩니다.\n\n그러나 많은 경우에 이러한 구성 요소는 내적 요소가 아닙니다. 따라서 LLM은 입력을 사용하여 다른 데이터 유형을 처리할 수는 있지만 cross-modal 추론을 수행할 수는 없습니다.\n\n그렇다면 그것이 무슨 의미일까요?\n\n\n\n민아 무라티가 공식 발표에서 강조한 대로, 말은 단어 이상의 것을 포함합니다. 톤, 감정, 일시정지 및 다른 여러 단서들도 포함되어 발언자가 무엇을 전달하려는지에 대한 추가 정보를 전달합니다.\n\n예를 들어, \"널 죽일 거야!\"라는 문장은 말하는 사람이 명백한 의도를 보여주거나 문장 중간에 웃음을 보여주는 경우 매우 다른 해석을 가질 수 있습니다.\n\n그러나 지금까지 ChatGPT의 이전 버전이 실제로 수신한 것은 단지 음성 전사뿐이었기 때문에 다른 모든 단서들이 손실되었습니다. 따라서 모델은 음성을 해석할 때 매우 제한되었으며 이전의 두 가지 예제는 모두 그것과 동일했습니다.\n\n그러나 이제 ChatGPT-4o는 텍스트, 이미지, 오디오 및 비디오 (비디오 생성 제외)를 처리하고 생성하는 데 필요한 모든 구성 요소를 포함하고 있습니다. 다시 말해, GPT-4o는 첫 번째 모델로, 인간처럼 모든 모달리티와 그 이유를 결합합니다.\n\n\n\n그것을 알았다면, 어제 새롭고 흥미로운 능력이 제시되었나요?\n\n## 다재다능한 \"야수\"\n\n두 시간반의 짧은 발표에도 불구하고, 언급할 가치가 있는 많은 것이 보여졌습니다.\n\n사실, ChatGPT-4o에는 수십억 명이 사용하는 제품에서 수십억 명이 사용하는 제품으로 변화시키는 데 필요한 많은 특성이 있습니다.\n\n\n\n## 인상적인 쇼케이스\n\n첫 번째로, 내가 본 중에서 가장 인상적인 두 가지 중 하나인 것은 ChatGPT가 실시간 비디오 인식을 수행한다는 것입니다. 구글은 Gemini이 그랬지만 실제로 그렇지 않았습니다.\n\n다른 비디오에서, OpenAI의 X 관객 중 한 사람이 실시간 번역을 제안했고, ChatGPT-4o는 다른 큰 개선 사항이 있어서 완벽하게 실행되었습니다: 인간 수준의 대기 시간.\n\nChatGPT-4o와 같은 음성 비서가 사회에 미칠 수 있는 흥미로운 사용 사례 중 하나는 교육입니다. 항상 인내심 있는 AI 모델은 학생들이 복잡한 작업을 배울 때 도움이 될 수 있습니다.\n\n\n\n메모리는 비디오 시연 중에 감지되지 않은 매우 흥미로운 기능이었습니다. 아래 비디오에서 OpenAI의 대표이사 그렉 브록먼이 모델이 처음에는 무시하는 비디오 프레임의 '침입자'를 가지고 있습니다.\n\n그러나 그렉이 이에 반응하도록 모델에 요청하자, 모델은 이전에 발생한 정확한 상호 작용을 다시 호출합니다. 이는 두 가지를 의미합니다:\n\n- 모델은 이전 이벤트를 기억할 수 있는 것으로 보입니다.\n- 모델이 특정 작업에 집중하고 나머지를 무시하는 메커니즘이 있는 것으로 보입니다. 이는 OpenAI가 계층화된 주의를 가진 매우 능률적인 비디오 인코딩 메커니즘을 개발했을 수 있다는 것을 의미할 수 있습니다.\n\n물론, 이 모든 것에 대해 X는 열광했고, 매우 흥미로운 스레드가 나타났습니다. 아마도 가장 인상적으로 느꼈던 것 중 하나는 OpenAI의 윌 데퓨가 제작한 것인데, 이것은 많은 예제를 보여주어 GPT-4o의 기본 다중 모달성을 증명했습니다.\n\n\n\n모델은 제어 넷 유형 이미지 조건화가 없어도 여러 세대에 걸쳐 문자 일관성을 유지하는 것으로 보입니다:\n\n![이미지1](/assets/img/2024-05-15-ChatGPT-4oOpenAIsNewFlagshipModelsFullReview_0.png)\n\n모델은 사진을 가져와 대체 3D 뷰를 생성하고 이를 실제 3D 렌더링으로 조립할 수도 있습니다.\n\n![이미지2](https://miro.medium.com/v2/resize:fit:1000/1*KTEVeb4ty--ihrJ-HiGnYg.gif)\n\n\n\n시위와 관계없이, 해당 모델은 특히 새로운 벤치마킹의 왕이 되었습니다.\n\n## 더 똑똑해졌지만 AGI는 아님\n\n이전부터 의심되었던 바와 같이, lmsys.org의 X 페이지와 OpenAI 연구원들의 확인에 따르면, 'im-also-a-good-gpt2-chatbot'인 'gpt2-chatbot' 라인업의 일원이 사실 ChatGPT-4o였습니다.\n\n전자가 공유한 이미지에서 gpt2-chatbots 또는 GPT-4o 챗봇은 GPT-4 및 Claude 3 Opus 모델에 비해 전반적인 ELO(품질 측정) 면에서 앞서 있습니다.\n\n\n\n![image](/assets/img/2024-05-15-ChatGPT-4oOpenAIsNewFlagshipModelsFullReview_1.png)\n\n또 다른 뚜렷한 개선 사항은 코딩에서 볼 수 있습니다. 개선 정도가 미친 듯이 100 ELO 점수가 상승했어요. 참고로, 두 모델 간의 100 점 차이는 패배 모델이 선호되는 경우가 1/3만 된다는 걸 의미합니다.\n\n특히 코딩에 대해 이야기하자면, 가장 주목할 만 한 공지 사항 중 하나는 ChatGPT 데스크톱 앱이었어요. 이 앱은 디버깅과 같은 작업에서 모델을 완전한 노트북 화면에서 활용할 수 있게 도와줄 겁니다. 이 비디오에서 확인할 수 있어요.\n\n그리고 이 공지에는 강력한 언어 개선도 포함되어 있었습니다.\n\n\n\n## 전 세계 인구의 97%가 서비스되었습니다\n\n제 모델의 토크나이저를 크게 개선했을 것 같아요, 특히 비영어권 언어를 고려할 때 (전 세계 인구의 97%까지 제공할 수 있다고 주장합니다. 상당한 주장이네요).\n\n이를 증명하기 위해, 해당 모델이 언어당 토큰을 상당히 줄였다고 주장하는 테이블을 공개했습니다.\n\n![이미지](/assets/img/2024-05-15-ChatGPT-4oOpenAIsNewFlagshipModelsFullReview_2.png)\n\n\n\n압축이 왜 중요한지 궁금하신가요? 그들이 주장하는 바는 빠르고 더 효율적인 버전 뿐만 아니라 보다 뛰어난 \"언어 지능\"을 보여줍니다. 간단히 말해, 언어가 가지는 토큰이 적을수록 모델이 언어를 생성하는 방법을 더 잘 알게 됩니다.\n\n하지만 ChatGPT-4가 정말 그만큼 우수하고 지능적인 발전이라고 할 수 있을까요? \n\n음, 아닙니다.\n\n\n\n## 차분해지세요, AGI가 아닙니다\n\nOpenAI가 공유한 그래프에 따르면, 이 모델은 현재 가장 우수한 것으로 분명하지만, 나머지에 비해 지능적인 개선은 미미합니다.\n\n![이미지](/assets/img/2024-05-15-ChatGPT-4oOpenAIsNewFlagshipModelsFullReview_3.png)\n\n'지능' 개선을 보면, 본 릴리스는 소박해 보일 수 있습니다. 그러나 저는 완전히 동의하지 않습니다. 왜냐하면 이 릴리스는 다음 중요한 새로운 영역에 대한 것이 아니라 다른 어떤 것에 대한 것이었기 때문입니다.\n\n\n\n그러나 모델이 더 똑똑해지지 않았다면 그 의미가 뭡니까?\n\n# OpenAI의 진짜 의도\n\n내가 보기에, 이 릴리스에는 세 가지 구성 요소가 있습니다:\n\n- 다음 프론티어인 이른바 'GPT-5'의 대규모 릴리스를 위한 시간 확보\n- 오늘 열리는 Google의 I/O 컨퍼런스를 사전에 저질러놓기\n- Apple 승리\n\n\n\n하나씩 해보자.\n\n## 다가오는 다음 단계는 가깝지만 완전하게는 아니다\n\nOpenAI의 CTO 미나 무라티는 공개적으로 이 점에 대해 언급했습니다. GPT-4o는 지능적인 크게 발전이 있는 것이 아니며, 사실 그들은 명시적으로 \"GPT-4 수준의 지능\"이라고 밝혔습니다.\n\n또한 그들은 곧 '다가오는' 다음 단계에 대한 소식과 업데이트를 받게 될 것이며, 그것에 어떤 이름을 붙일지에 대해 언급했습니다.\n\n\n\n## 구글의 최악의 악몽\n\n이 시점에서 OpenAI가 무엇을 공개할지 예측하고 싶다면, 그냥 구글이 무엇을 할지 보세요.\n\n예를 들어, 구글이 Gemini 1.5를 위해 백만 컨텍스트 윈도우를 출시하면서 MLLM이 한 번에 처리할 수 있는 데이터 양을 크게 늘린 것을 보면, OpenAI는 전혀 다른 이야기로 넘어가서 Sora라는 비디오 생성 모델을 출시했습니다.\n\n오늘 고대로 예상되는 Google I/O 컨퍼런스가 온라인으로 열리기 전에, OpenAI는 그보다 하루 전에 자체 컨퍼런스를 열어 전자에 대한 분석가들에 대한 기대치를 매우 높였습니다.\n\n\n\n간단히 말하면, 이제 구글이 새로운 AI 기능을 제공하는 것이 아닙니다. OpenAI의 발표에 기반해 구글이 어떻게 응답하는지 확인해보는 경우가 되었습니다.\n\n그리고 마지막으로, 현재 경매 중인 Siri 왕관을 가져가기 위해 구글과 OpenAI 간에 매우 소문난 '전투'를 고려할 때, 우리는 애플에 대해 이야기해야 합니다.\n\n## 이러한 목표가 계속되는 이유?\n\n애플과의 협업의 잠재적 이익을 고려할 때, Siri 계약을 따내는 것이 OpenAI의 목표였을 수도 있습니다.\n\n\n\n지연 시간이 뛰어나고 애정 어린 음성 행동, 여러 데이터 유형에서의 뛰어난 기능, 그리고 중요하게도 좋은 화면 시각 기능을 자랑하는 OpenAI가 프리미티브 시리를 개선하기 위해 Apple과 파트너십을 맺고 싶어하는 것은 비밀이 아닙니다.\n\n사실, Apple이 놀라운 기기 내 모델을 내놓지 않는 이상, 사용자들은 무관심하게 될 것이며 즉시 최첨단 기술과 비교할 것입니다.\n\n결국, 이는 분명히 Apple에게는 좋지 않은 PR 전망이지만, 자본이 풍부하여 자본주주 매입으로 자본주가 역사상 최대의 1310억 달러를 보유한 회사인 Apple은 여전히 시리를 해결하지 못했습니다. Apple은 이에 대한 여지가 거의 없습니다.\n\n그러므로 내부 'AI 난국'을 정리하고 좋은 AI 제품을 제공하기 시작할 때까지, GPT-4o(또는 Google이 오늘 자랑하는 것)에 베팅하고자 하는 유혹이 높아질 것입니다.\n\n\n\n그렇다면, 그 제휴가 어떻게 구체화될지 알기 위해 추측으로 나아가야 할 것입니다.\n\n애플은 사용자의 개인정보 보호에 매우 열정적이라고 알려져 있습니다. 이는 명백히 저작권과 보안 규정을 위반하여 모델을 훈련시킨 회사로부터 Siri를 위한 클라우드 기반 LLM 솔루션을 갖는 것과 호환되지 않는 것으로 보입니다.\n\n그러나 윤리가 돈에 방해를 받을 때, 기업들이 어떤 선택을 하는지 우리는 압니다. 의심스러운 윤리적 측면을 떠나서라도 돈이 관련된 상황에서 기업들이 선택하는 것을 말이죠.\n\n## 수십억 달러로부터 수백억 달러까지\n\n\n\n모든 것을 종합하면, OpenAI는 항상 실망시키지 않습니다. 그러나 이번에는 과거와는 다르게 그들의 의도가 명확하지 않을 수도 있습니다.\n\nGenAI 제품은 약속을 지키지 못하는 것으로 알려져 있으며, 이는 ChatGPT와 같은 경우에도 사실입니다. 지연 시간과 부족한 교차 모달 추론 등 여러 가지 이유로 이러한 상황이 발생합니다.\n\n지금 OpenAI는 인터넷 이후로 가장 큰 발견로 여겨지는 기대치에 부응하는 AI를 마침내 제공하는 제품을 갖고 있다고 생각합니다.\n\n이게 바로 그런 경우인지 여전히 이른 것 같지만, 이러한 가능성은 구글을 겁나게 할 민감한 지점을 만들고, AI의 다음 지평으로 자신들의 가장 큰 릴리스에 충분한 시간을 확보할 기회를 제공합니다.\n\n\n\n그러나 GPT-4o는 여전히 제한이 있으며 GPT-4보다 AGI에 더 가까워지는 것이 아니라는 점에서 명백합니다.\n\n하지만 이 제품은 강력한 AI를 널리 이용할 수 있게 함으로써 Generative AI를 사회에 훨씬 가깝게 만들어줍니다(제품은 무료로 제공될 예정임). 실제로 수십억 명에게까지 Siri를 통해 제공된다면 AI가 약속한 것을 실현하는 데 필요한 것이 바로 이런 접근방법이죠.","ogImage":{"url":"/assets/img/2024-05-15-ChatGPT-4oOpenAIsNewFlagshipModelsFullReview_0.png"},"coverImage":"/assets/img/2024-05-15-ChatGPT-4oOpenAIsNewFlagshipModelsFullReview_0.png","tag":["Tech"],"readingTime":7},{"title":"GPT4 Omni - 그저 음성 어시스턴트 이상의 무언가","description":"","date":"2024-05-15 11:33","slug":"2024-05-15-GPT4OmniSomuchmorethanjustavoiceassistant","content":"\n\n![image](/assets/img/2024-05-15-GPT4OmniSomuchmorethanjustavoiceassistant_0.png)\n\n오늘은 OpenAI의 봄 발표일이었고, 정말 놀라운 소식이었어요. 여러분도 동의하실 거라고 생각해요. 이번 밤 대부분을 새 음성 어시스턴트와 노는 데에 보냈거든요. (영화 HER에 언급된 것과 매우 정확한 시나리오입니다).\n\n그런데 혁명적이고 놀라운 음성 기능이 있을 뿐만 아니라, GPT4o 모델은 그 이상을 제공해요.\n\n솔직히 말하자면, 음성 기능에 정말 매료되어서 현실감을 느꼈죠. 그래서 한참을 걸려서 모델의 기술적 공지사항을 정말 자세히 읽어 보았는데, 방금 그것을 듣고 다시 놀라버렸어요. \n\n\n\nGPT4o를 생각했을 때는 기본적으로 GPT-4 Turbo의 최적화된 버전일 뿐이라고 생각했어요. 이번에는 더 나은 추론 능력, 더 작은 지연 시간 및 음성 대화용으로 훈련되었어요. 그들은 이미 보유한 기술을 Whisper와 TTS와 함께 최적화된 새 모델과 통화를 결합하여 ChatGPT에 매우 효과적으로 통합했다고 생각했었어요.\n\n그러나 모델의 기술 보고서를 읽은 후에, 이렇게 발견했어요:\n\n텍스트, 오디오 및 비전 멀티모달리티가 모두 포함된 단일 새 모델!!\n\n텍스트/오디오/이미지를 입력으로 받아 텍스트/오디오/이미지로 출력하는 단일 모델이 있어요.\n\n\n\n저는 지난 번에 GenAI의 미래는 모든 모달리티를 고루 보유한 다중 모델링에 있을 것이라고 언급했다는 것을 알고 있어요. 그리고 우리는 그런 의도로 이니셔티브를 볼 수 있어요.\n\n하지만 2024년 5월에 그 미래가 될 줄은 상상도 못했고, 우리는 어떠한 주요 모델도 처리하고 생성할 수 있는 능력을 가진 모델을 보유하고 있는 상황이에요. 그런데 여전히 빠른 응답 시간을 유지하죠.\n\n지금 이것이 혁명적인 것을 넘어섰어요. OpenAI가 또 한 번 선방했죠. 여기에 가까운 것을 갖고 있는 사람은 아무도 없으며, 그러한 모델의 가능성은 너무 커서 우리 마음으로는 처리하기 어렵습니다.\n\n우리는 이전의 개념과 아이디어를 다시 검토해야 해요. 왜냐하면 이전에 현실이 될 수 없었던 제한 사항이 오늘날에는 존재하지 않을 수 있기 때문이죠. 그리고 우리 마음을 새롭게 개조된 아이디어로 준비해야 하며, 그 전에는 상상조차 할 수 없었던 해결책에 대한 새로운 아이디어에 대비해야 해요.\n\n\n\nPS1: 그들의 API에서 모든 모드에 대한 액세스를 아직 공개하지 않았습니다, 현재는 텍스트와 이미지만 사용할 수 있습니다. 그래서 다른 방법을 고민해볼 수 있지만, 지금까지 아직 정해진 날짜가 없는 출시를 기다려야 합니다.\n\nPS2: 예시로 모델은 3D 이미지도 생성합니다.\n\nPS3: 이 모델은 오늘날 GPT-4 Turbo의 절반 가격에 판매되고 있는데, 따라서 Turbo보다 훨씬 더 저렴하면서 효율적입니다.\n\n아래는 최신 최고 모델과 비슷한 성능을 보여주는 일부 벤치마크입니다:\n\n\n\n\n![image](/assets/img/2024-05-15-GPT4OmniSomuchmorethanjustavoiceassistant_1.png)\n\nYou can learn more about this model and see examples of its use on [OpenAI’s website](https://example.com).\nHello GPT-4o | OpenAI\n","ogImage":{"url":"/assets/img/2024-05-15-GPT4OmniSomuchmorethanjustavoiceassistant_0.png"},"coverImage":"/assets/img/2024-05-15-GPT4OmniSomuchmorethanjustavoiceassistant_0.png","tag":["Tech"],"readingTime":2},{"title":"드라유레카, 세계에 대한 Nvidia의 경고","description":"","date":"2024-05-15 11:32","slug":"2024-05-15-DrEurekaNvidiasWarningtotheWorld","content":"\n\n지난 주 Nvidia는 AI 로봇이 얼마나 빠르게 발전하고 있는지를 다시 상기시키며, LLMs의 훌륭한 잠재력을 강조했습니다. 이는 교육과정에서 인간의 개입을 최소화하는 데 큰 기회를 제공합니다.\n\n간단히 말해서, 그들은 AI로 훈련된 더 강력한 로봇의 출현을 보여주었습니다.\n\n로봇 AIs를 훈련하는 AIs입니다.\n\n이를 위해 그들은 몇 달 전에만으로는 불가능했던 다양한 복잡도의 시나리오에서 요가 볼 위에 균형을 유지하는 안드로이드를 훈련시켰습니다.\n\n\n\n이미지: \"/assets/img/2024-05-15-DrEurekaNvidiasWarningtotheWorld_0.png\"\n\n확실히, 로봇이 이미 매우 복잡한 현실 과제를 아주 빠르게 수행하는 사실은 AI 로보틱스가 멈출 수 없는 추세임을 모두에게 알립니다.\n\n하지만 그들은 어떻게 이것을 성취했을까요?\n\n# 보상의 중요성\n\n\n\n먼저, AI 로봇이 어떻게 훈련되는지 궁금한 적이 있나요?\n\n우리는 그들이 주어진 보상을 극대화하는 환경에서 행동을 취할 수 있도록 도와주는 정책을 생성합니다.\n\n예를 들어, 100m를 달리는 모델을 훈련하려면 일어서고 걷고 뛰고 결국은 질주하는 방법을 먼저 배워야 합니다. 모델이 그 작업을 이해할 때까지 '도약'마다 보상을 주면서 훈련시킵니다.\n\n하지만 이것을 어떻게 가르칠까요? 보상을 부여함으로써요.\n\n\n\n예를 들어, 모델이 세워지면 점수를 주는 것입니다. 그 반면에 모델이 넘어지면 처벌을 받습니다.\n\n이를 보상 모델링이라고 합니다. 좋은 행동에 보상을, 나쁜 행동에 처벌을 하는 함수를 만드는 것이죠. 이렇게 하면 시간이 지남에 따라 모델은 누적 보상을 최대화하는 몸의 위치와 행동을 결정합니다.\n\n이것은 매우 표준적인 방법이며, Google Deepmind과 같은 최첨단 연구소도 같은 원칙을 사용하여 일어서고, 뛰어들고, 슛을 차고, 심지어 수비를 하는 축구 로봇을 훈련시키고 있습니다.\n\n하지만, 이러한 보상 함수를 정의하는 것은 굉장히 어렵습니다.\n\n\n\n인간의 몸을 생각해보자면, 예를 들어 펜 회전이라는 전반적인 결과에 긍정적이거나 부정적인 영향을 미치는 손의 모든 근육과 관절의 움직임이 있습니다.\n\n액션이 매우 복잡한 경우, 인간은 로봇이 그에 따라 행동하도록 돕는 가장 좋은 보상 함수를 작성하는데 어려움을 겪습니다.\n\n이 복잡성을 감지하기 위해, 볼 걸음걸이 작업을 위해 최종적으로 결정된 보상 함수는 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-15-DrEurekaNvidiasWarningtotheWorld_1.png)\n\n\n\n그리고 이 방정식을 찾는 것은 보이는 대로 어렵습니다. 하지만 여기에 중요한 점이 있습니다: 그 함수는 인간이 아닌 AI가 작성했습니다.\n\n# AI의 보상\n\n몇 달 전, DrEureka 뒤의 연구자들이 Eureka를 출시했습니다. 이는 AI 기반 보상 함수 설계 알고리즘입니다.\n\n아래에서 보듯이, 아이디어는 Large Language Model (GPT-4)을 사용하여 반복적 루프를 사용하여 환경(로봇이 행동할 장면을 설명하는 코드) 및 수행해야할 작업을 주면, 이러한 보상 함수를 생성하여 해당 내용을 시뮬레이션된 환경에서 평가하는 것이었습니다.\n\n\n\n시뮬레이션 결과에 따라 피드백이 생성되었고, LLM은 이를 사용하여 품질 기준이 충족될 때까지 새 보상 함수를 생성했습니다.\n\n![image](/assets/img/2024-05-15-DrEurekaNvidiasWarningtotheWorld_2.png)\n\n유레카와 팀은 놀라운 결과를 달성했습니다: 로봇을 펜 회전 트릭을 수행하도록 훈련시켰으며, 최고의 CGI 전문가조차 고전할 것입니다.\n\n그 업적은 놀라운 것이었으며, LLM을 반복적으로 사용하여 인간이 설계할 수 없는 복잡한 보상 함수를 만들 수 있음을 증명했습니다. 그리고 거의 인간 개입이 없었습니다.\n\n\n\n이제, 그림을 그리듯이 손가락, 관절, 근육 및 관절 점수를 모델링하는 보상 함수를 쓰고 있다고 상상해보세요.\n\n의심의 여지없이, Eureka는 Nvidia가 AI가 AI를 훈련하는 것이 로봇 공학의 미래임을 세계에 입증했습니다.\n\n그러나 안타깝게도 문제가 하나 있었습니다. 만일 이러한 결과를 현실 세계로 가져가고 싶다면 어떻게 해야 할까요?\n\n그럴 때 DrEureka가 등장합니다.\n\n\n\n# 개방적인 세상 속 인공지능\n\n로봇 공학에서 가장 어려운 문제는 비용과 불확실성을 다루는 것입니다.\n\n실제로 로봇을 훈련하는 것은 매우 비싸고 실제 제약(마찰, 바람, 온도 등)을 다뤄야 하며 물론 고장의 위험도 있습니다.\n\n오늘 논의하는 경우와 같이, 일부 경우에는 영점(Zero-shot) 모드로 작동합니다. 다시 말해서, 모든 훈련은 시뮬레이션에서 수행되며 실제 세계에서는 최선을 바랍니다.\n\n\n\n상상할 수 있는 대로, 이 전환은 매우 중요하며 오류 발생 가능성이 높습니다. 실제 환경에는 높은 불확실성이 포함되어 있습니다. 따라서 로봇을 길에 내려놓기 전에 프로세스에 한 가지 추가 단계를 추가해야 했습니다: 도메인 랜덤화.\n\n## 견고한 로봇 훈련\n\n실제 세계를 생각해보면 불확실성이 가득합니다.\n\n- 온도는 매초 변화합니다.\n- 로봇은 울퉁불퉁한 지형에 부딪힐 수 있습니다.\n- 바람이 다양한 방향으로 불 수 있습니다.\n- 로봇의 관절 운동은 사용으로 인해 덜 부드러워질 수 있습니다.\n- 그리고 물체들이 길에 나타날 수 있습니다.\n\n\n\n수천 개의 다른 예기치 않은 변화 중 하나입니다.\n\n따라서 성공 확률을 극대화하기 위해 연구자들은 시뮬레이션에서 모델을 훈련시키기 위해 제약 조건(품질이나 마찰력과 같은)에 무작위 변화를 도입하여 다양한 환경 시나리오에서 모델을 강화합니다.\n\n그러나 각 제약 조건에 대해 정의할 값이 무엇인지 결정하는 것은 굉장히 어렵습니다. 그래서 연구자들이 생각한 것은 LLMs가 여기에서도 우리를 도울 수 있을까요?\n\n네, 하지만 문제가 있습니다: 도메인 랜덤화 검색 공간 또는 각 환경 제약 조건이 가질 수 있는 가능한 값의 수는 무한하므로, 이 문제는 LLMs에게 매우 어렵습니다.\n\n\n\n이를 완화하기 위해, 그들은 먼저 RAPP (보상 인식 물리 사전)라고 알려진 경량 검색을 수행하여 가능한 제약 값 범위를 물리적으로 가능한 값으로 좁혔습니다 (예: 음의 마찰 값은 불가능합니다).\n\n이는 LLM의 검색 공간을 좁혀 다양한 도메인 조건을 생성하는 데 도움이 됩니다.\n\nRAPP 경계가 설정되면, 그들은 다시 GPT-4를 사용하여 각 제약에 대한 타당한 값을 생성하여 새로운 시나리오 (도메인 무작위화)를 만들었으며, 우리에게 전체 DrEureka 프레임워크를 제공했습니다:\n\n![DrEureka Framework](/assets/img/2024-05-15-DrEurekaNvidiasWarningtotheWorld_3.png)\n\n\n\n따라서 전체 프로세스는 다음과 같습니다:\n\n- 작업 및 안전 지침이 정의되며 환경 조건도 정의됩니다.\n- RAPP를 사용하여 각 조건의 값 범위를 제한합니다. 이는 각 환경 제약 조건의 값 범위를 좁힙니다.\n- 그런 다음 LLM은 각 환경에 대한 가능하지만 현실적인 시나리오를 생성합니다(도메인 랜덤화), 로봇을 테스트하기 위한 '새로운' 시뮬레이션 환경 세트를 생성합니다.\n- 병렬로 다른 LLM은 각 특정 환경의 조건을 기반으로 보상 함수를 생성합니다.\n- 그다음 로봇은 해당 보상을 최대화하는 정책을 사용하여 훈련되어 실제 세계에서 예상대로 행동할 수 있도록 학습됩니다. 품질 기준이 충족될 때까지 세 번째 및 네 번째 단계를 반복하는 피드백이 생성됩니다. 목표는 로봇이 실제 세계에서 예상대로 행동한다는 가능성을 극대화하는 정책을 학습하는 보상 함수를 얻는 것입니다.\n\n결국 로봇은 실제로 투입되었고 결과는 스스로 이야기합니다.\n\n# 로봇 시대\n\n\n\nNvidia가 로보틱스에 대해 매우 많은 것을 건너뛰고 있다고 말하는 것은 저평가이에요.\n\n사실, 이 논문의 연구자 가운데 하나인 Jim Fan은 Nvidia의 랜드마크 프로젝트인 프로젝트 Gr00t를 이끄는 중이에요. 이 프로젝트는 현실 세계 에이전트를 위한 기초 모델을 개발하는 프로젝트입니다.\n\n그러나 여전히 명백한 제약이 있으므로 바닥에 발을 디딘 채로 있어야 해요. 예를 들어, 한 번 도메인 매개변수가 설정되면 해당 환경에서의 훈련 실행 동안 고정되는 한계가 있어요.\n\n다시 말해, 마찰력이 일정하게 유지된 채로 남아있는 것처럼, 이는 실제 세계에서는 사실이 아니라는 것이에요. 왜냐하면 새로운 표면마다 변화하기 때문이죠.\n\n\n\n그 말은 그들의 결과가 인공지능 로봇 분야의 발전 속도에 대한 경고 신호로 작용한다는 것을 명확히 보여줍니다. 이 분야는 여전히 빠르게 가속화되고 있는 것으로 보입니다.","ogImage":{"url":"/assets/img/2024-05-15-DrEurekaNvidiasWarningtotheWorld_0.png"},"coverImage":"/assets/img/2024-05-15-DrEurekaNvidiasWarningtotheWorld_0.png","tag":["Tech"],"readingTime":5},{"title":"간단한 도구를 사용한 예약된 네트워크 활동 보고서","description":"","date":"2024-05-15 11:30","slug":"2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools","content":"\n\n# 소개\n\n평범한 Raspberry Pi 팬 중 수면 패턴이 안 좋은 사람은 아침에 먼저 핸드폰을 꺼내어 사랑하는 기기가 잘 작동하고 있는지 궁금해합니다. 혹은 더 넓은 의미로, 자는 동안 내 네트워크에서 무슨 일이 벌어지고 있는지 궁금해합니다.\n\n![Scheduled Network Activity Reports Using a Simple Set of Tools](/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png)\n\n이 블로그 포스트에서 나는 최근 완료한 작은 프로젝트에 대해 설명할 것입니다. 여기서 나는 몇 가지 도구를 연결하여 Raspberry Pi와 관련된 특정 활동에 대한 아침에 첫 번째 활동 보고서를 보내기 위해 사용했습니다. 아래의 구체적인 사용 사례 자체는 특별히 유용하지는 않지만, 여러분이 유용하다고 생각하는 어떤 방향으로든 확장할 수 있는 장난감 예시입니다.\n\n\n\n# 야간 보고서\n\n많은 기업들이 이제 일반 업무 시간 이외에 대부분의 사이버 공격이 발생한다는 사실을 깨달았습니다. 그에 따라 단순히 백신 소프트웨어와 내부 IT 팀만으로는 부족하다는 것을 깨달았습니다. 대신 내부 팀을 24시간 365일 외부 사고 대응팀과 함께 보강하는 Sophos MDR(관리되는 탐지 및 대응) 서비스와 같은 것이 필요합니다. 네트워크를 모니터링하고 시간별 보고서를 제공하는 다양한 상업용 도구도 있습니다. 하지만 저는 이미 갖고 있는 간단한 도구들을 활용하여 어떻게 하는 지를 보기 위해 자체적인 이른바 DIY 솔루션을 만들기로 했습니다.\n\n# 사용된 도구\n\n본 프로젝트에서는 집 네트워크에 라즈베리 파이 5를 사용했고, 몇 가지 내부 장치(Pinging에 사용되는)와 함께 사용했습니다. 소프트웨어로는 tcpdump(명령줄 기반의 데이터 패킷 분석 도구), tcpdump와 유사한 Wireshark의 명령줄 대체인 tshark, 데이터 분석을 위해 Python(Pandas 및 Matplotlib 포함), 이메일 발송을 위한 sendmail, 그리고 Gmail 계정을 사용했습니다. 이러한 도구들은 몇 가지 bash 스크립트로 연결되었고 cron을 통해 실행 스케줄이 잡혔습니다.\n\n\n\n기본 아이디어는 다음과 같이 3단계로 구성되었어요.\n\n- 나의 라즈베리 파이에 대한 핑을 로깅하기 시작하고 종료할 시간을 선택하여 (예: 밤새) tcpdump 스케줄링\n- 이 데이터를 분석하여 간단한 그래프로 변환하는 파이썬 스크립트를 스케줄링\n- 라즈베리 파이에게 이 그래프를 내가 선택한 시간에 이메일로 보내도록 하는 스케줄링\n\n각 단계를 함께 살펴보겠습니다.\n\n# 파트 1 — tcpdump\n\n\n\ntcpdump을 사용하는 것은 매우 간단하며, 온라인에는 무수히 많은 훌륭한 가이드가 있습니다. 예를 들어 아래 라인은 wlan0 인터페이스에서 ICMP(Internet Control Message Protocol) 패킷을 수신하도록 tcpdump에 지시합니다.\n\n```js\ntcpdump -i wlan0 icmp\n```\n\n이 코드는 화면에 패킷을 표시합니다. 파일에 기록하려면('pings.pcap'에 로그를 기록하는 경우), 다음 명령을 사용해야 합니다.\n\n```js\ntcpdump -i wlan0 icmp -w pings.pcap\n```\n\n\n\n다수의 pcap 파일 가이드가 있습니다 [3].\n\n패킷 캡처의 시작과 종료를 예약하는 것은 적절한 명령어를 두 개의 별도 셸 스크립트에 넣고 cron을 사용하여 예약하는 것만으로도 간단합니다. 이러한 스크립트에 대해 도움이 되는 GitHub 저장소 [4]를 찾아내어 이를 편집했습니다.\n\n실행 중에는 Windows 머신과 WebSSH 앱을 실행중인 휴대전화(모바일 폰)를 사용하여 Raspberry Pi에 핑을 전송했습니다 [5].\n\n이 단계의 마지막 단계는 pcap 파일을 Python이 이해할 수 있는 형식으로 변환하는 것입니다. 이를 위해 tshark를 사용했습니다. 'pings.pcap' 파일을 'pings.csv'로 변환하는 명령어는 유용한 블로그 포스트에서 찾은 내용을 이용하여 아래와 같이 실행했습니다 [6].\n\n\n\n```js\ntshark -N n -r ./pings.pcap -T fields -e frame.number -e _ws.col.Time -e _ws.col.Source -e _ws.col.Destination -e _ws.col.Protocol -e _ws.col.Length -e _ws.col.Info -e tcp.seq -e ip.ttl -E header=y -E separator=, > pings.csv\n```\n\n이 명령어는 그 후 'stop' 스크립트의 끝에 포함되었습니다.\n\n# 파트 2— 파이썬\n\n관심 있는 데이터를 수집하고 CSV 파일로 변환한 후에는 Python으로 할 수 있는 일이 무궁무진합니다. 사용한 스크립트는 매우 간단합니다. 각 IP 주소에서 ping의 수를 계산하고, 데이터의 막대 플롯을 생성한 다음 jpg로 저장합니다.\n\n\n\n```js\n#라이브러리 가져오기\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n#데이터 불러오기\npings = pd.read_csv('pings.csv')\n\n#관심 있는 열로 제한하기\npings = pings.iloc[:,0]\n\n#다시 데이터프레임으로 변환하기\npings = pings.to_frame()\n\n#열 이름 변경하기\npings.columns = ['Source_IP']\n\n#Raspberry Pi 자체에서의 핑 제거하기\npings = pings[pings['Source_IP'] != '192.168.68.127']\n\n#IP 주소로 그룹화하고, 수를 세어 정렬하기\npings_gb = pings.groupby(['Source_IP']).size().sort_values()\n\n#그룹화된 데이터를 사용하여 막대 그래프 만들기\nfig = pings_gb.plot(kind = 'bar', rot=0, figsize=(10, 8), fontsize=13)\nfig.set_ylabel(\"Source Count\")\nfig.figure.savefig('pings.jpg')\n```\n\n# 파트 3— Gmail\n\n이 부분은 가장 많은 노력을 필요로 했으며, Gmail 쪽에서의 설정(보안 수준이 낮은 앱 액세스 허용 및 앱 비밀번호 생성)과 Raspberry Pi 쪽에서의 설정(sendmail 설치 및 구성)이 포함되었습니다. 이러한 단계에 대한 두 가지 훌륭한 가이드는 [7, 8]에서 확인할 수 있습니다. 이 가이드를 따르면 var/logs/maillog의 로그 파일에 \"My unqualified host name (raspberrypi) unknown; sleeping for retry\"라는 오류가 계속 표시된다는 것에 유의하십시오. 이 오류를 해결하는 방법은 [9]에서 확인하십시오. 또한, 접근 보안 수준이 낮기 때문에 별도의 Gmail 계정을 만드는 것이 좋을 수 있습니다.\n\n설정을 완료하면 Python에서 생성된 이미지를 첨부한 이메일을 보낼 수 있습니다.\n\n\n\n\n```bash\necho \"Enjoy! from Raspberry Pi\" | mail -s \"Your Overnight Ping Analysis!\" [내 주 이메일 주소] -A pings.jpg\n```\n\n# 모두 함께 사용하기\n\n마지막으로, 위의 단계들을 연결하여 크론을 사용할 수 있습니다. (좋은 크론 도우미를 보려면 여기를 참조하세요 [10]). 이를 위해 크론탭을 수정하여 아래와 유사한 내용으로 편집하세요.\n\n```bash\n0 22 * * * bash /robh/start_tcpdump.sh # 10시에 수집 시작\n0 6 * * * bash /robh/stop_and_convert.sh # 6시에 수집 중지 및 csv로 변환\n5 6 * * * python ping_script.py # 6:05에 파이썬 스크립트 실행\n30 6 * * * bash /robh/email.sh # 6:30에 이미지를 이메일로 보내기\n```\n\n\n\n작업 표정 변경이 완료되었습니다.\n\n\n\n이메일 안에는 Python 스크립트가 생성한 이미지 파일이 포함되어 있었습니다.\n\n![image](/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_2.png)\n\n# 결론\n\n위의 이미지는 매우 간단하지만, 크론을 사용하여 다음 이벤트 체인을 예약하는 원칙을 보여주기를 희망합니다,\n\n\n\n데이터 수집 → CSV로 변환 → Python으로 분석 → 결과 이메일로 전송\n\n수집하는 데이터와 분석 방법은 물론 무한히 맞춤화할 수 있어요. 이 게시물이 여러분의 일간 보고 요구 사항에 유용한 시작점이 되었으면 좋겠어요!","ogImage":{"url":"/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png"},"coverImage":"/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png","tag":["Tech"],"readingTime":5},{"title":"태양 에너지 혁신 시스템 리뷰","description":"","date":"2024-05-15 11:29","slug":"2024-05-15-SolarInnovatorSystemReview","content":"\n\n## 360도 각도에서 지속적으로 패널 각도를 조절할 필요 없이 저렴하고 깨끗한 에너지를 생성하는 DIY 태양 에너지 프로젝트.\n\n![태양 에너지 혁신 기기 사용 설명 도면](/assets/img/2024-05-15-SolarInnovatorSystemReview_0.png)\n\n# 이 태양 에너지 혁신 기기는 무엇입니까?\n\n이제 이 제품이 정확히 무엇인지 설명해 드리겠습니다. 위의 이미지에서 보는 바와 같이, 이 기기는 약 120개의 모노-셀이 부착된 구형 구조물입니다.\n\n\n\n기능:\n\n구 형태:\n\n알루미늄 시트 추가:\n\n구획:\n\n\n\n미세 먼지 축적이 적습니다:\n\n## 동영상 리뷰:\n\n이 동영상은 전체 DIY 프로젝트의 리뷰로, 그 제작 방법과 개인적인 필요에 맞게 만드는 방법을 보여줍니다.\n\n## 제작 간략 개요:\n\n\n\n이제 장치 제작에 들어가 봅시다\n\n![Image 1](/assets/img/2024-05-15-SolarInnovatorSystemReview_1.png)\n\n![Image 2](/assets/img/2024-05-15-SolarInnovatorSystemReview_2.png)\n\n![Image 3](/assets/img/2024-05-15-SolarInnovatorSystemReview_3.png)\n\n\n\n이것은 DIY 프로젝트이므로 필요에 따라 구축해야 합니다. 태양광 출력을 늘리기 위해 크게 만들거나 소형으로 만들어 미니 영역을 위해 사용할 수도 있습니다.\n\n이 장치를 구축하는 데 필요한 모든 도구 및 재료는 이 가이드에 포함되어 있습니다. 여기에서 액세스할 수 있습니다.\n\n# 가이드:\n\n이 안내서는 당신이 기대하는 것 이상을 제공합니다. 따라서 몇 가지 중요한 내용들도 포함되어 있습니다.\n\n\n\n- 재료 목록\n- 치수 및 사양\n- 배선도\n- 비디오 프레젠테이션\n- 추가 혜택과 선물\n\n프로그램의 저자가 세부 사항을 모두 펼쳐놓았고 프로젝트 제작에 매우 도움이 되는 비디오 프레젠테이션을 사용하고 있습니다.\n\n회원 전용 영역에서 모든 비디오를 다운로드하여 태블릿이나 모바일 기기에 저장한 후 저자와 함께 보고 만들어보세요.\n\n# 결과:\n\n\n\n\n![이미지](/assets/img/2024-05-15-SolarInnovatorSystemReview_4.png)\n\n이 장치는 매력적으로 보입니다. 아이디어도 독특하고 혁신적입니다. 우리의 계산에 따르면, 이 시스템은 120 개의 셀로 이루어져 있어서 최대 출력이 3.6에서 3.8 와트, 각 셀당 최대 전압이 0.6에서 0.8 볼트여야 합니다.\n\n그러므로 모든 것을 계산해 보면, 한 대의 태양 혁신기기는 432에서 434 와트를 발전할 수 있어야 합니다.\n\n지금 이 계산은 근사치이며, 장치의 크기와 사용 가능한 자원 및 공간에 따라 달라질 수 있습니다.\n\n\n\n\n# Solar Innovator System에 액세스하세요:\n\n이제 전체 시스템에 액세스하려면 제 웹사이트를 방문하실 수 있습니다. 이 제품에 대한 자세한 리뷰와 장단점 그리고 이 장치를 사용해야 할지 여부에 대한 정보가 제공되어 있습니다.\n\n시스템에 액세스할 수 있는 내 웹사이트 바로 가기: [여기](링크하실 웹사이트 주소를 입력해주세요)","ogImage":{"url":"/assets/img/2024-05-15-SolarInnovatorSystemReview_0.png"},"coverImage":"/assets/img/2024-05-15-SolarInnovatorSystemReview_0.png","tag":["Tech"],"readingTime":2},{"title":"증명 개념 아두이노 UNO에서 비동기 프로그래밍","description":"","date":"2024-05-15 11:27","slug":"2024-05-15-ProofofConceptAsynchronousprogramminginArduinoUNO","content":"\n\n<img src=\"/assets/img/2024-05-15-ProofofConceptAsynchronousprogramminginArduinoUNO_0.png\" />\n\n안녕하세요.\n\n요즘 NodeJS의 작동 방식에 관심을 갖게 되었습니다. 한 스레드에서 여러 작업을 동시에 실행하는 것이 가능하다는 것이 흥미롭게 느껴졌죠. 그래서 스스로에게 물었습니다. 아두이노 UNO에서도 이와 같은 것이 가능할까요?\n\n그래서 이것이 어떻게 작동하는지 알아보기 위해 조금 연구를 해봤는데, Node.js는 한 스레드에서 동시성을 달성하기 위해 2가지 알고리즘을 사용한다는 것을 깨달았습니다.\n\n\n\n- 이벤트 루프: 각기 다른 함수들로 이루어진 작업 목록을 저장하고 실행하는 역할을 담당합니다. 이러한 함수들은 쉽게 코루틴이 될 수 있습니다.\n\n- 코루틴: 실행을 중단하고 나중에 다시 재개할 수 있는 함수 유형입니다. \n\n그래서 제가 Arduino UNO에서 동일한 동시성 시스템을 구현하기로 결정했습니다.\n\n가장 쉬운 부분부터 시작했습니다. 코루틴입니다. C/C++은 내장 코루틴 지원이 없기 때문에, 자체 코루틴 시스템을 만들었습니다. 이를 위해 Duff의 장치라는 매우 유용한 알고리즘을 발견했습니다. 이 알고리즘은 코루틴과 직접적으로 관련되어 있지는 않지만, 코루틴 구현에 도움이 될 것입니다.\n\n\n\n예, 주요 아이디어는 정적 상태 변수를 생성하여 코루틴의 상태를 기억할 수 있도록하는 것입니다. 그런 다음 switch 문을 사용하여 함수를 청크로 분할하고 상태 변수를 사용하여 필요한 부분을 실행할 수 있습니다. 내가 무슨 얘기를 하는지 이해 못 하겠다고요? 그래, 이런 느낌입니다!\n\n```js\nint coroutine(){\nstatic int state = 0;\n\n     switch(state){\n         case 0: do { printf(\"Hello World 0\"); state++; return 1; case 1:; } while(0);\n                 do { printf(\"Hello World 1\"); state++; return 1; case 2:; } while(0);\n                 do { printf(\"Hello World 2\"); state++; return 1; case 3:; } while(0);\n                 do { printf(\"Hello World 3\"); state++; return 1; case 4:; } while(0);\n                 do { printf(\"Hello World 4\"); state++; return 1; case 5:; } while(0);\n                 do { printf(\"Hello World 5\"); state=0; return 1;          } while(0);\n     }\n\n     return -1;\n\n}\n\nvoid setup(){\n     Serial.begin( 9600 );\n}\n\nvoid loop(){\n     coroutine();\n     delay(1000);\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:852/1*FmR-nOMNpohwvWCPbysUiQ.gif)\n\n좋죠? 하지만 이 방법을 사용하여보다 복잡한 코루틴을 작성한다고 상상해보세요. 그러다가 Duff 장치를 생성하는 것을 단순화하기 위해 매크로를 사용하기로 생각했습니다. 여기에는 몇 가지 매크로가 있습니다:\n\n\n\n```js\n#define coNext         do { _state_ = __LINE__; return 1; case __LINE__:; } while (0)\n#define coGoto(VALUE)  do { _state_ = VALUE   ; return 1;                 } while (0)\n#define coYield(VALUE) do { _state_ = VALUE   ; return 1; case VALUE:;    } while (0)\n```\n\n```js\n#define coStart static int _state_ = 0; { switch(_state_) { case 0:;\n#define coEnd do { _state_ = 0; return -1; } while (0)\n#define coStop } _state_ = 0; return -1; }\n#define coSet(VALUE) _state_ = VALUE\n#define coGet _state_\n```\n\n참고: 매우 유용한 다른 매크로도 추가되었습니다.\n\n```js\n#define coDelay(VALUE)  do { static auto tm = millis()+VALUE; while( millis() < tm ){ coNext; } tm = millis()+VALUE; break; } while (0)\n#define coUDelay(VALUE) do { static auto tm = micros()+VALUE; while( micros() < tm ){ coNext; } tm = micros()+VALUE; break; } while (0)\n#define coWait(VALUE)   do { while( !VALUE ){ coNext; } } while(0)\n```\n\n이 구현의 작은 단점 중 하나는 switch 문을 사용하여 코루틴을 실행하기 때문에 코루틴 내에서 switch 문을 사용할 수 없다는 것입니다. 해당 경우는 코드를 완전히 깨뜨릴 것입니다.\n\n\n\n\n이전 예제를 복제한다면 이렇게 될 것입니다:\n\n```js\nint coroutine(){\ncoStart\n\n     printf(\"Hello World 0\"); coNext;\n     printf(\"Hello World 2\"); coNext;\n     printf(\"Hello World 3\"); coNext;\n     printf(\"Hello World 4\"); coNext;\n     printf(\"Hello World 5\"); coNext;\n     printf(\"Hello World 6\");\n\ncoGoto(0);\ncoStop\n}\n\nvoid setup(){\n     Serial.begin( 9600 );\n}\n\nvoid loop(){\n     coroutine();\n     delay(1000);\n}\n```\n\n이제 실제 Arduino 프로젝트에서 이것을 적용한다면 어떻게 될까요?\n\n아두이노 UNO에서 실행되는 3개의 비동기 프로세스를 실행하는 프로그램을 작성하고 싶다고 가정해보겠습니다. 이 프로그램은 일련의 LED를 켜고 끄게 할 것입니다. 아래에 코드가 있습니다:\n\n\n\n```js\nint coroutine1(){\n     static bool b=0;\ncoStart\n\n     digitalWrite(7,b);\n     coDelay(300); b=!b;\n\ncoGoto(0);\ncoStop\n}\n\nint coroutine2(){\n     static bool b=0;\ncoStart\n\n     digitalWrite(6,b);\n     coDelay(1000); b=!b;\n\ncoGoto(0);\ncoStop\n}\n\nint coroutine3(){\n     static int x=0; static bool b=0;\n     unsigned char pin[] = { 13, 12, 11, 10, 9, 8 };\ncoStart\n\n     while( x-->0 ){\n         digitalWrite( pin[x], b );\n         coDelay(100);\n     } b=!b; x=6;\n\ncoGoto(0);\ncoStop\n}\n\nvoid setup(){\n     unsigned char pin[] = { 13, 12, 11, 10, 9, 8, 7, 6 };\n     for( auto &x: pin ) pinMode( pin, OUTPUT );\n}\n\nvoid loop(){\n     coroutine1();\n     coroutine2();\n     coroutine3();\n}\n```\n\n![Animation](https://miro.medium.com/v2/resize:fit:852/1*LwDRI8sOZe-EVOxAEsgLHw.gif)\n\n알아보기 쉽게 Arduino UNO에서 비동기 프로그래밍이 가능하다는 것을 확인할 수 있습니다. 시간이 부족해 이 데모에 대한 이벤트 루프를 구현하지 못했지만, loop 함수가 좋은 대체재가 됩니다. 이 글에 흥미를 느끼셨다면 제가 두 번째 파트를 작성해 이벤트 루프에 대해 설명해드릴게요. 이 프로젝트가 마음에 들었기를 바라며, 우리 다음에 또 뵙겠습니다.\n\n이 글을 마치기 전에, 제가 만든 Nodepp라는 프레임워크를 소개하고 싶어요. 이 프레임워크는 NodeJS와 매우 유사한 구문으로 Arduino에서 비동기 코드를 작성할 수 있게 해주는 C++ 프레임워크입니다. 즐겁게 이용하시기를 바랍니다.\n\n\n\n\nhttps://www.arduino.cc/reference/en/libraries/nodepp/","ogImage":{"url":"/assets/img/2024-05-15-ProofofConceptAsynchronousprogramminginArduinoUNO_0.png"},"coverImage":"/assets/img/2024-05-15-ProofofConceptAsynchronousprogramminginArduinoUNO_0.png","tag":["Tech"],"readingTime":5},{"title":"3D 레이저 스캐닝 단계별 가이드","description":"","date":"2024-05-15 11:26","slug":"2024-05-15-AStep-by-StepGuideto3DLaserScanning","content":"\n\n![image](/assets/img/2024-05-15-AStep-by-StepGuideto3DLaserScanning_0.png)\n\n레이저 스캐닝은 모델링과 프로토타입 제작의 세계를 혁신했습니다. 이 기술을 통해 물리적 객체의 디지털 복제물을 빠르고 정확하게 만들 수 있습니다. 이 포괄적인 안내서에서는 3D 레이저 스캐닝의 단계별 프로세스를 안내해 드리겠습니다.\n\n컨텐츠\n\n- 3D 스캔 프로세스 개요\n- 단계 1: 데이터 획득\n    - 레이저 스캐너 작동 방식은?\n    - 레이저 스캐너의 주요 구성 요소\n- 단계 2: 스캔 데이터 처리\n    - 포인트 클라우드 생성\n    - 포인트 클라우드 처리 소프트웨어\n- 단계 3: 3D 모델링\n    - 3D 모델링\n    - 3D 스캔 응용\n    - 3D 스캔 기술 유형\n- 주요 포인트\n\n\n\n# 3D 스캐닝 프로세스 개요\n\n3D 스캐닝은 물리적 객체를 분석하여 형상과 외관에 대한 데이터를 수집하고, 이 데이터를 사용하여 디지턀 3D 모델을 구성하는 과정입니다. 레이저 스캐닝 장치는 물체에 레이저 점이나 선을 비추고 카메라가 이를 촬영합니다.\n\n레이저 빔이 물체를 횡단하면 수백만 개의 샘플 포인트가 캡처됩니다. 이러한 포인트들은 물체의 표면을 정확하게 표현하는 포인트 클라우드로 구성되며, 이를 사용하여 3D 모델을 생성합니다.\n\n이 기본 프로세스에는 세 가지 주요 단계가 포함되어 있습니다:\n\n\n\n- 데이터 획득\n- 스캔 데이터 처리\n- 3D 모델 작성\n\n이제 이러한 단계를 더 자세히 이해해 봅시다.\n\n## 단계 1: 데이터 획득\n\n첫 번째 단계는 물체를 스캐너 안에 놓고 물리적 데이터를 획득하는 것입니다.\n\n\n\n## 레이저 스캐너는 어떻게 작동하나요?\n\n레이저 스캐닝 장치는 레이저, 카메라 및 센서로 구성되어 있어요. 물체 표면에 레이저 빔이 닿으면, 카메라가 레이저 점의 반사를 캡쳐하고 센서가 거리 및 치수를 기록해요.\n\n이렇게 하면 물체 모양의 상세한 지도가 만들어지며, 밀도가 높은 포인트 클라우드가 생성됩니다. 전문급 스캐너는 초당 최대 700,000개의 포인트를 고정도로 캡처할 수 있어요. \n\n![이미지](/assets/img/2024-05-15-AStep-by-StepGuideto3DLaserScanning_1.png)\n\n\n\n레이저 빛이 물체를 횡단하면 스캐너가 해당 모양과 크기를 매핑할 수 있어요.\n\n## 레이저 스캐너의 주요 구성 요소\n\n다음은 고품질 레이저 스캐닝 시스템의 주요 구성 요소 중 일부입니다:\n\n- 레이저 광원 — 레이저 발사기가 물체에 점/선을 발사해요. 청색 또는 녹색 파장의 레이저가 높은 스캔 품질을 제공해요.\n- 카메라 — 고속 카메라가 레이저 점/선의 반사를 촬영해요.\n- 제어 유닛 — 사용자가 레이저 세기, 노출, 스캔 영역 등을 조절할 수 있게 해줘요.\n- 위치 결정 시스템 — 고급 스캐너에는 자동 회전 스캔 시스템이 있어서 모든 면에서 데이터를 캡처해요.\n- 처리 소프트웨어 — 전문 소프트웨어가 원시 스캔 데이터를 사용 가능한 3D 모델로 처리해줘요.\n\n\n\n위 모든 구성요소 외에도 일부 시스템은 RGB 카메라를 추가하여 포토그래메트리를 통합할 수 있습니다. 이는 모델에 후에 매핑될 색상 정보를 캡처합니다.\n\n# 단계 2: 스캔 데이터 처리\n\n데이터 취득이 완료되면, 두 번째 중요한 단계는 캡처된 정보를 처리하는 것입니다.\n\n![이미지](/assets/img/2024-05-15-AStep-by-StepGuideto3DLaserScanning_2.png)\n\n\n\n## 포인트 클라우드 생성\n\n레이저 스캐너가 물체를 분석할 때 XYZ 좌표의 광범위한 데이터 세트를 캡처합니다. X, Y 및 Z 데이터 포인트는 물체 표면의 차원적으로 정확한 표현을 만듭니다.\n\n이 포인트 클라우드를 통해 물리적 물체의 모양과 크기를 디지털적으로 저장할 수 있습니다. 매우 상세하지만 원시 포인트 클라우드는 공간 데이터만 제공합니다.\n\n## 포인트 클라우드 처리 소프트웨어\n\n\n\n전용 소프트웨어 프로그램을 사용하여 풍부한 포인트 클라우드 데이터를 처리하고 관리 가능한 3D 모델 파일을 생성합니다. 의도된 응용 프로그램에 기초한 각기 다른 소프트웨어 솔루션이 다양한 기능을 제공합니다:\n\n- 모델 준비 소프트웨어는 스캔 데이터를 정리하여 하단 사용을 위해 내보낼 수 있는 밀봉된 3D 형태를 만드는 데 도움을 줍니다. 이에는 포인트 클라우드 편집, 구멍 메꾸기, 메쉬 부드러워지기 등의 기능이 포함됩니다.\n- 검사 소프트웨어는 스캔 데이터를 원본 CAD 도면과 비교하여 부위의 편차 및 이상을 정확하게 매핑합니다. 이는 제조 결함을 분석하는 데 도움이 됩니다.\n- 역공학 소프트웨어는 포인트 클라우드 데이터를 CAD 호환 파일 유형으로 변환합니다. 이를 통해 디지털 도면이 없는 레거시 구성 요소의 설계 개선이 용이해집니다.\n\n# 단계 3: 3D 모델 빌딩\n\n마지막 단계는 처리된 포인트 클라우드 데이터를 사용하여 스캔된 개체의 3D 디지털 모델을 만드는 것입니다. 모델링 기술은 하방 응용에 따라 다를 수 있습니다.\n\n\n\n\n![image](/assets/img/2024-05-15-AStep-by-StepGuideto3DLaserScanning_3.png)\n\n## 3D 모델링\n\n디지털 복제물을 만들기 위해, 포인트 클라우드는 일반적으로 폴리곤 메시 또는 CAD 솔리드 모델로 변환됩니다. 인기 있는 파일 형식으로는 OBJ, STL(3D 프린팅용) 및 STEP, IGES(엔지니어링용)이 있습니다.\n\n- 폴리곤 메시 — 이 과정은 수천 개의 정점을 연결하여 물체 기하학을 나타내는 메시 표면을 구축합니다. 메시 모델은 게임, VR 등과 같은 응용 프로그램을 위해 포토리얼리스틱 렌더링을 제공합니다.\n- CAD 솔리드 — 높은 정확도의 CAD 솔리드 모델은 디자인 서피스를 포인트 클라우드에 맞게 맞추어 만들어집니다. 이는 제조/품질 분석을 위한 정확한 제품 기하학을 재현합니다.\n- 검사 보고서 — 부품 검사를 위해 '설계된 대로'와 '실제로 제작된' 차원 간의 편차가 색상 맵을 사용해 허용 오류를 나타내는 PDF 보고서로 편성될 수 있습니다.\n\n\n\n\n## 3D 스캐닝의 응용 분야\n\n3D 스캐닝의 활용 사례는 다양합니다. 주요 사례는 다음과 같습니다:\n\n- 제조 및 품질 관리\n- 복잡한 하드웨어의 역공학\n- 유물 및 조각품의 디지털 아카이빙\n- 의료 치료 및 보청기\n- VFX 및 게임\n\n## 3D 스캐닝 기술의 종류\n\n\n\n일터된 조명 — 물체에 광의 패턴을 투사하고 표면을 매핑하기 위해 변형을 측정합니다.\n- 레이저 삼각측량 — 레이저 투사 및 카메라 삼각측량을 사용하여 정교한 세부 정보를 캡처합니다.\n- 사진측량 — 특화된 알고리즘을 통해 겹치는 사진 이미지로부터 3D 모델을 생성합니다.\n\n# 주요 포인트\n\n- 3D 스캐닝은 물리적 물체의 매우 정확한 디지털 복제본을 만듭니다.\n- 제어된 레이저 빛과 센서를 사용하여 밀도 높은 기하학적 샘플을 캡처합니다.\n- 특화된 소프트웨어는 이 포인트 클라우드 데이터를 3D CAD 및 메쉬 모델로 변환합니다.\n- 레이저 스캐닝은 검사, 품질 분석, 3D 프린팅 등에 대해 정밀한 결과를 제공합니다.\n\n\n\n저희 팀에서는 레이저 기반 3D 스캐닝의 놀라운 세계에 대해 소중한 통찰력을 제공했기를 바랍니다. 이 혁신적인 기술은 물리적 제품과 디지털 표현물 간의 연결을 통해 다양한 영역에서 새로운 가능성을 열어 주고 있습니다.\n\n이 글은 3dprintjunction.com에서 원본으로 게시되었습니다.\n저희의 작업을 지원해 주신 모든 분들께 감사의 인사를 드리며, 더 많은 이러한 글을 확인하시려면 3dprintjunction.com을 방문해 주세요.","ogImage":{"url":"/assets/img/2024-05-15-AStep-by-StepGuideto3DLaserScanning_0.png"},"coverImage":"/assets/img/2024-05-15-AStep-by-StepGuideto3DLaserScanning_0.png","tag":["Tech"],"readingTime":4},{"title":"나의 즐겨찾는 iOS 17 위젯","description":"","date":"2024-05-15 11:24","slug":"2024-05-15-MyfavouriteiOS17widget","content":"\n\n<img src=\"/assets/img/2024-05-15-MyfavouriteiOS17widget_0.png\" />\n\n지난 달에 iOS7가 출시되었는데, 새로운 주요 기능들이 함께 등장했습니다. 그 중에서도 가장 주목해야 할 것은 개선된 위젯 지원이었습니다. 이번에는 사용자가 앱을 열지 않고도 홈 화면에서 직접 위젯과 상호작용할 수 있게 되었습니다.\n\n이것은 할 일 목록에서 작업을 마칠 수도 있고, 음악 트랙을 한 번에 건너뛸 수도 있다는 것을 의미합니다.\n\n그러나 이 새로운 기능은 점점 짜증이 나기 시작한 앱을 여러 번 하루에 사용하는 앱으로 변신시켰습니다. 이 앱을 사용하는 방법을 바꿀 뿐만 아니라, 전화기를 사용하는 방식에 더 많은 가치를 더하게 되었다고 볼 수도 있습니다.\n\n\n\n그럼 이제 모든 걸 잊고, 제가 가장 좋아하는 iOS 17 위젯은...\n\n## 홈\n\n좋아요, 지금까지 읽어주셔서 감사합니다. 약간 실망스럽다고 느낄 수 있지만, iOS 17에서 제공하는 홈 위젯이 기대되는 이유에 대해 설명해 드리겠습니다.\n\n우선 주의할 점을 말씀드리자면: \"스마트 홈\"은 가지고 있지 않습니다. 스마트 전구 몇 개와 스마트 플러그 몇 개 정도 있는 집이 있지만요.\n\n\n\n우리 집을 좀 더 '스마트'하게 만드는 생각을 해보고 있어요. 하지만 스마트 스위치를 위해 집을 다시 전선을 교체하지 않으면 가치가 있는지 확신이 안 서요. 벽에 있는 스위치를 끄면 스마트 전구도 똑똑하지 않죠.\n\n그리고 우리가 기존 전구를 스마트 전구로 바꾸고 싶다면 집을 재담보해야 할 것 같아요. 그것들 가격이 싸지 않아요.\n\n그래서 우리 현재는:\n\n- 우리 거실의 메인 조명으로 한 개, 그리고 측면 조명으로 한 개의 스마트 전구가 있어요. 저와 아내가 저녁에 텔레비전을 보는 동안 분위기를 만드는 데 좋아요.\n- 제 오피스의 메인 조명으로 한 개, 그리고 책상 위에 있는 라이트 스트립이 있어요. 일할 때 집중하고 편안해지는 데 유용하다고 느꼈어요.\n- 저희 침실 바깥에 한 개가 있어요. 밤중에 저렇게 파란색 약한 빛을 남겨두면, 아이들이 우리 방으로 가야 할 때 완전히 깨어나지 않고 길을 찾을 수 있어요.\n- 잠들기 전에 읽기에 좋은 침대 옆 탁자에 한 개의 전구가 있어요.\n\n\n\n## 스마트 기기의 문제점\n\n요즘 스마트 기기에 대한 문제는 이러한 조명이 완전히 관리하기 귀찮다는 것입니다.\n\n먼저, 모든 전등 스위치를 벽에서 켜야 했고, 심지어 집 앱(사용하기 쉽지 않은)에서 해당 전등을 찾아 켜고 끌 수 있어야 했습니다.\n\n요약하자면 — 시간 낭비였습니다. 핸드폰으로 전등을 켜고 끄려고 하다 보니 벽 스위치를 조금만 눌러도 순식간에 할 수 있었던 일을 하고 있었습니다.\n\n\n\niOS17의 홈 위젯은 모든 것을 바꿨어요.\n\n## 위젯 설정하기\n\n위젯의 진정한 이점을 누리기 위해 두 가지를 해야 해요:\n\n첫째로, 위젯이 기본 설정으로 켜놓은 추천 기능을 끄세요. 이것이 얼마나 중요한지를 알게 될 거에요. 이걸 하려면:\n\n\n\n- 화면 위젯을 길게 눌러주세요.\n- \"위젯 편집\"을 선택하세요.\n- \"추천\" 스위치를 끕니다.\n- 그런 다음 위젯에 표시하고 싶은 스위치를 수동으로 추가할 수 있습니다.\n\n![위젯 설정](/assets/img/2024-05-15-MyfavouriteiOS17widget_1.png)\n\n또한, 몇 가지 포커스 모드를 설정하고 각 포커스 모드에 대해 고유한 홈 위젯을 만들어보세요.\n\n저는 하루의 다른 시간대에 대해 다른 모드를 설정해두었어요: 아침, 업무, 저녁, 취침, 주말 등.\n\n\n\n각각에는 추천 스위치가 제거된 다른 홈 위젯이 있습니다. 대신에 집중 모드와 가장 관련된 스위치를 수동으로 추가했습니다.\n\n예를 들어,\n\n- \"작업\" 모드에서 홈 위젯은 사무실의 주 조명과 책상 위의 라이트 스트립을 표시합니다.\n- \"저녁\" 모드에서는 화면이 변경되고 홈 위젯에는 거실의 조명이 포함됩니다.\n- \"취침\" 시간에는 화면이 다시 변경되며, 이번에는 침대 옆에 있는 램프가 위젯에 표시됩니다.\n\n## 결과\n\n\n\n내 전화의 포커스 모드가 이렇게 설정되어 있으면, 홈 앱을 열어 스크롤할 필요 없이, 내가 제어하려는 조명이 내가 보고 있는 화면에서 쉽게 이용할 수 있을 것이라는 확신을 갖고 전화를 보기만 하면 됩니다.\n\n![이미지](/assets/img/2024-05-15-MyfavouriteiOS17widget_2.png)\n\n거기서 끝나는 것이 아닙니다. 위젯에는 단축키를 포함할 수도 있습니다. 'Going Up'이라는 이름의 하나를 설정했는데, 이것은 잠자러 가야 할 시간이 되면 트리거하는 단축키입니다. 이 단축키는 다음을 수행합니다:\n- TV를 끕니다.\n- 거실의 주요 조명을 끕니다.\n- 그런 다음 우리 방 바깥의 조명을 끄고 색상을 저렴한 파랑으로 설정합니다.\n- 층에 올라가면서 책을 읽을 수 있도록 침대 옆의 조명을 저조하고 따뜻한 주황색으로 설정합니다.\n\n\n\n내 침대 옆 빛을 끄고 Sonos 스피커를 통해 화이트 노이즈를 재생하도록 하는 \"Good Night\"라는 다른 바로 가기가 있어요.\n\n그러한 바로 가기는 저의 저녁 및 수면 집중 모드에 각각 표시되어, 다시 한 번, 전화를 보기만 하면 관련 바로 가기가 자동으로 업데이트되어 제게 제공됩니다.\n\n## 결론\n\n이 글의 시작 부분에서 언급했듯이, 제 집에는 스마트 액세서리가 소수만 있어요. 큰 수의 액세서리를 사용하면 얼마나 쉽게 사용할 수 있는지가 얼마나 무력해질 수 있는지 알 수 있습니다.\n\n\n\n그러나 저에게는 스마트 홈에 대한 큰 이슈가 실제로 무엇인지를 보게 해 주었습니다. 여전히 어디에나 스마트 장치를 설치하길 원하는 건 아니지만, 적어도 현재로서는 새로운 홈 위젯 때문에 그 앱에 대한 제 의견이 \"화려하지만 실현 가능하지 않은\"에서 \"집 주변의 조명을 효율적으로 관리할 수 있는 방법\"으로 바뀌었습니다.\n\n스마트 기기를 시작하는 중이라면, 홈 앱과 포커스 모드에 시간을 투자할 것을 권유하고 싶습니다. 이것은 제게 정말 큰 영향을 미쳤습니다.\n\n# 마지막으로\n\n위의 글이 유용하다고 느꼈다면, 제 글을 지원할 수 있는 세 가지가 있습니다:\n\n1. 지금 공유하세요.\n2. 즐겨찾기에 추가하세요.\n3. 의견을 남겨주세요.\n\n\n\n- 다른 사람들이 관심을 가질 수 있도록 박수를 보내주세요. 그들도 유용하게 활용할 수 있길 바라요.\n- 비슷한 콘텐츠가 올라올 때 가장 먼저 알 수 있도록 저를 여기 Medium에서 팔로우해주세요.\n- 대화를 이어가보세요. 여기서 메시지를 남기거나 Twitter/X 또는 Mastodon에서 연락해주세요. 제가 꼭 답변해드릴게요!","ogImage":{"url":"/assets/img/2024-05-15-MyfavouriteiOS17widget_0.png"},"coverImage":"/assets/img/2024-05-15-MyfavouriteiOS17widget_0.png","tag":["Tech"],"readingTime":4},{"title":"기술 해킹 간단한 작업을 너무 복잡하게 만드는 최상의 방법","description":"","date":"2024-05-15 11:23","slug":"2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks","content":"\n\n테크오스트리치에 다시 오신 것을 환영합니다. 우리는 현대 기술의 이상하고 종종 필요하지 않은 면을 탐험하는 곳입니다. 오늘은 '테크 해킹' 세계로 뛰어들어보겠습니다 — 간단한 작업을 지나치게 복잡하게 만들어 '간편화'하려는 가전제품들에 대해요. 먹는 속도를 판단하는 스마트 포크에서부터 강아지의 모든 움직임을 추적하는 반려동물 기술까지, 우리가 만난 가장 말도 안 되는 혁신들에 대해 웃어봅시다. 가장 일상적인 작업조차 기술적으로 향상되기 위해 얼마나 많은 노력을 기울였는지 함께 살펴보죠!\n\n![이미지](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_0.png)\n\n스마트 포크: 천천히 먹는 방식을 혁신하다\n\n스마트 포크를 만나보세요. 다이닝 경험을 인내심을 시험하는 끌어내는 운동으로 바꾸도록 설계된 기술적 놀라움입니다. 식사 속도가 너무 빠르면 진동하는 이 탁월한 발명품은 마치 할머니가 당신의 식기에 디지털로 임베디드된 것처럼 작동합니다. 당신이 먹는 습관을 추적하여 소화에 최적의 속도로 식사하는지 분석합니다 — 왜냐하면 당신을 비난하는 포크가 있는 것만큼 '식사를 즐기세요' 라는 선물은 없기 때문이겠죠. 그리고 우리가 먹는 속도가 가장 느린 사람이 누구인지 확인하기 위해 친구들과 경쟁할 수 있는 동반 앱을 잊지 말아주세요. 그래서 다음에 급하실 때, 기억하세요: 당신의 스마트 포크는 당신에게 고통스러운 느린 한 입을 마다 사랑하고 싶어합니다.\n\n\n\n\n![image1](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_1.png)\n\nDIY Home Automation: When Flipping a Switch is Just Too Much Work\n\nWelcome to the world of DIY home automation, where every mundane task is transformed into a high-tech adventure. Who needs to flip a light switch when you can program your entire home from your smartphone? Set your blinds to open with the sunrise, your coffee to brew at the sound of your alarm, and your thermostat to adjust based on your mood swings. But beware: one wrong command and you might end up with the lights flickering like a disco and your smart speaker playing ‘The Chicken Dance’ on loop. It’s the future we always dreamed of, with a side of minor chaos.\n\n![image2](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_2.png)\n\n\n\n\n디지턈 가디닝: 식물도 똑똑해지는 곳\n\n디지턈 가디닝에 오신 것을 환영합니다. 이제는 식물도 여러분을 능가할 수 있습니다. 스마트 화분과 연결된 관개 시스템을 소개합니다. 바질의 감정 상태에 대해 푸시 알림을 보내줍니다. 어떤가요, 어당초 어렸을 때 헝그리해하는 카페인이 그렇지 않습니까? 어플리케이션을 확인하십시오. 이런 기기는 가디닝에서 추측을 빼앗아 당신의 집을 푸른색의, 기술 주도적인 낙원으로 만들어 줍니다 - 아니면, 끝내 건조한 잎사귀와 지나치게 열정적인 관리 일정으로 얽힌 전쟁터로 만들겠죠. 기억하세요, 식물이 자신의 감정에 대해 문자 메시지를 보내주는 것만큼 좋은 것은 없습니다.\n\n![TechHacksTheBestWaystoOvercomplicateSimpleTasks_3](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_3.png)\n\n가제트 과부하: 인터넷 연결된 잡동사니함\n\n\n\n아, 잡동사니 서랍 - 잊혀진 가제트의 시대를 열어줄 보물상자입니다. 이제 사물인터넷 덕분에 복잡한 케이블과 소진된 배터리만을 보관하는 곳이 아닙니다. 당신의 빗질 습관을 추적하는 인터넷 연결 헤어 브러시나 날씨 예보를 알려주는 스마트 우산과 만나보세요. 당연히 이제 기억을 믿을 수 없기 때문에 더 많은 달걀을 사야 한다는 것을 상기시켜주는 WiFi 기능이 탑재된 계란트레이를 잊지 맙시다. 이러한 가제트들은 여러분의 삶을 혁신할 것을 약속하거나 적어도 특색 있는 기술 장난감 더미 아래서 재발견했을 때 재미를 줄 것입니다.\n\n![이미지](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_4.png)\n\n스마트 샤워: 목욕 시간을 너무 복잡하게 만드는 경험으로 변신시키기\n\n당신의 샤워실이 소프트웨어 업데이트가 필요하다고 느끼셨나요? 스마트 샤워가 등장합니다. 완벽한 온도, 수압, 심지를 약속하는 공학의 놀라운 산물입니다. 샤워를 좋아하는 노래로 시작하도록 프로그램하거나 원격으로 시작되도록 설정하여 물이 따뜻해질 때까지 기다릴 필요가 없도록 할 수 있습니다. 하지만 조심하세요: 한 가지 결함이 생기면 얼음 찬 놀람이나 새벽 6시에 디스코 조명쇠도를 만나게 될 수도 있습니다. 커피도 마시기 전에 샤워 컨트롤 패널과 싸우느라 '하루의 시작을 즐기는'것 같은 이미지를 만들어 준다는 것을 잊지 마세요.\n\n\n\n\n![Pet Tech: Because Your Dog Needs a Fitness Tracker](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_5.png)\n\n개를 위한 기술: 당신의 개가 운동량 추적을 필요로 하는 이유\n\n당신의 개가 비밀리에 소파감자인지 궁금했던 적이 있나요? 반려동물 기술 덕분에 이제는 발바닥친구의 활동량, 식습관, 심지어 수면 패턴까지 추적할 수 있습니다. 스마트 칼라로 강아지를 장식하면 모든 걸그룹을 기록하고, 만일 피도가 매일 운동 목표를 달성하지 못했을 경우 알림을 받게 됩니다. 자동 급식기와 급수기는 늦게까지 늦근데도 반려동물이 굶주리지 않도록 보장합니다. 기술에 민감한 반려인을 위한 완벽한 솔루션이죠. 단지 칼라가 '산책하러 더 나가자'는 소리를 내면 개가 당신을 쳐다보고 있다는 사실에 놀라지 마세요.\n\n![image](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_6.png)\n\n\n\n\n과대평가된 혁신: \"헉!\" 하게 만드는 제품들\n\n기술 혁신은 좋지만 때로는 조금 지나칠 때도 있습니다. 인간의 우선순위에 대해 의문을 제기하게 만드는 과대평가된 가젯의 세계로 들어가 봅시다. 핸드폰과 동기화되어 나트륨 섭취량을 추적하는 스마트 소금통부터 남아있는 양을 알려주는 인터넷 연결 화장실 티슈 홀더까지 — 이러한 발명품들은 당신의 삶을 가장 불필요한 방식으로 변화시키겠다고 약속합니다. 이제 인식이 부족했던 것으로 보이는 스마트 벨트까지 없어서는 안될 겁니다. 당신이 너무 많이 먹었을 때 알려주는 스마트 벨트를 잊지 말아주세요. 왜냐하면 분명히 타이트해진 허리띠 때문에 충분한 단서가 되지 않았으니까요. 저희와 함께 이 불필요한 방식으로 삶을 혁신하겠다고 약속하는 기술 제품들의 비극적인 세계로 뛰어들어 봅시다.\n\n![이미지](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_7.png)\n\n이 과장된 기술 해킹의 세계를 유쾌하게 즐겨주셔서 감사합니다. 만약 우리가 이 무모한 혁신들을 조롱하는 걸 즐겼다면, 반드시 우리에게 좋아요와 구독을 눌러주시고, 더 많은 비꼬는 정보를 담은 기술 내용을 위해 박수를 치고 종아요 아이콘을 클릭하세요. 우리가 다루고 싶은 테크 가전제품이 있나요? 아래 댓글에 남겨주세요! 다음에 또 뵙기까지는, 귀하의 가전제품을 밀착하여, 유머 감각을 한층 가깝게 유지하세요. 호기심을 유지하고, 테크에 능숙하게 남아 있으며, Tech Ostrich와 함께 웃으면서 지내세요!\n\n\n\n테크 타조는 비인간 엔티티의 지원을 받아 만들어졌어요. 이 기사는 전문적인 조언으로 간주되지 않으며 인간 전문가와 상담이 필요합니다. 또한 오로지 엔터테인먼트를 위한 것입니다.","ogImage":{"url":"/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_0.png"},"coverImage":"/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_0.png","tag":["Tech"],"readingTime":5},{"title":"SQL에서 정규화 마스터하기","description":"","date":"2024-05-15 11:19","slug":"2024-05-15-MasterNormalizationinSQL","content":"\n\n\n![이미지1](/assets/img/2024-05-15-MasterNormalizationinSQL_0.png)\n\n![이미지2](/assets/img/2024-05-15-MasterNormalizationinSQL_1.png)\n\n데이터베이스 관리에서 중요한 개념인 정규화는 특히 SQL(구조화된 쿼리 언어)에서 중요합니다. 이는 데이터베이스의 효율성, 무결성 및 확장성을 보장하며, 데이터베이스의 데이터를 중복 없이 정리하고 의존성을 줄이는 프로세스입니다. SQL에서 정규화를 마스터하는 것은 효율적이고 확장 가능하며 유지보수가 용이한 데이터베이스를 생성하는 데 필수적입니다. 이 글에서는 정규화의 원칙과 기술을 자세히 살펴보고, 여러 형태와 효과적인 구현 방법에 대해 다룰 것입니다.\n\n# 정규화 이해하기:\n\n\n\n\n정규화는 데이터를 테이블로 구성할 때 발생하는 중복 및 종속성을 최소화하는 일련의 규칙에 기반하고 있습니다. 이 과정은 일반적으로 큰 테이블을 더 작고 관리하기 쉬운 작은 테이블로 나누고 그들 간의 관계를 정의하는 것을 포함합니다.\n\n## 정규화를 사용하는 이유:\n\n![MasterNormalizationinSQL_2](/assets/img/2024-05-15-MasterNormalizationinSQL_2.png)\n\n정규화를 숙달하기 전에 왜 정규화를 사용하며 정규화의 필요성에 대해 이해해야 합니다. 그래서 \"왜 정규화를 배워야 하는지\"에 대한 참고 자료를 가질 수 있게 됩니다.\n\n\n\n데이터베이스 설계에서 중요한 개념인 정규화는 데이터를 효율적으로 구성하고 데이터 무결성을 유지하는 데 사용됩니다. 여러 가지 중요한 목적을 가지고 있으며, 전반적으로 데이터베이스 시스템의 효과성과 신뢰성에 기여합니다:\n\n### 1. 중복 최소화:\n\n정규화는 큰 테이블을 작고 관리하기 쉬운 작은 테이블로 분해하여 중복 데이터를 제거하는 데 도움을 줍니다. 중복은 데이터베이스의 일관성 및 이상 현상을 유발할 수 있습니다. 데이터를 정규화된 형태로 저장함으로써 각 정보 조각이 한 곳에만 저장되어 일관성 문제의 가능성을 줄입니다.\n\n### 2. 업데이트 이상 방지:\n\n\n\n변경된 테이블은 날 위험성을 최소화하고 다른 곳에서 불일치나 오류가 발생하지 않도록 하는 정규화를 통해 발생할 수 있는 갱신 이상 현상을 방지합니다.\n\n## 3. 데이터 무결성 향상:\n\n데이터 무결성은 데이터베이스에 저장된 데이터의 정확성과 일관성을 의미합니다. 정규화는 부정확하거나 일관되지 않은 데이터를 저장하는 것을 방지하기 위한 제약 조건과 규칙을 강제함으로써 데이터 무결성을 향상시킵니다. 예를 들어, 각 열이 원자적(분할할 수 없는) 값만 포함하고 테이블 간의 관계가 올바르게 정의되도록 보장합니다.\n\n## 4. 쿼리 성능 향상:\n\n\n\n정규화된 데이터베이스는 쿼리에 대해 종종 더 효율적입니다. 데이터를 잘 정의된 관계를 가진 작은 테이블로 구성함으로써 쿼리를 더 빨리 효과적으로 실행할 수 있습니다. 정규화된 테이블은 일반적으로 특정 개체나 개념과 관련된 데이터를 저장하도록 설계되어 각 쿼리에 처리해야 하는 데이터 양을 줄입니다.\n\n## 5. 데이터베이스 유지관리를 간단하게:\n\n정규화된 데이터베이스는 유지 관리 및 업데이트가 시간이 지나서도 더 쉽습니다. 데이터베이스 구조를 수정해야 할 때(예: 새로운 필드나 테이블 추가), 정규화는 변경 사항을 다른 부분에 영향을 미치지 않고 적용할 수 있도록 합니다. 이를 통해 데이터베이스는 변화하는 요구 사항에 빠르게 적응할 수 있고 유지 보수 활동 중 오류 발생 가능성을 줄입니다.\n\n## 6. 확장 가능성을 용이하게하는:\n\n\n\n정규화된 데이터베이스는 본질적으로 확장 가능성이 높습니다. 데이터 양이나 데이터베이스의 복잡성이 증가함에 따라 정규화는 성능이나 데이터 무결성을 희생하지 않고 쉽게 확장할 수 있게 합니다. 새로운 테이블을 추가하거나 기존 테이블을 수정하거나 확장하여 새로운 요구 사항을 수용할 수 있습니다. 이렇게 하면 전체 데이터베이스 구조에 중요한 장애가 없이 확장할 수 있습니다.\n\n# 정규화 유형\n\n정규화는 데이터베이스 설계에서 사용되는 과정으로 데이터를 중복과 의존성을 최소화하는 구조화된 테이블로 구성합니다. 각각의 규칙 세트를 갖는 여러 가지 정규 형태가 있습니다. 다양한 유형의 정규화를 살펴보겠습니다:\n\n## 1. 제1정규화(1NF):\n\n\n\n1NF에 따르면, 테이블이 정규화되었다고 말할 수 있는 조건은 다음과 같습니다:\n\n- 각 열에는 원자적(분할할 수 없는) 값이 포함되어 있어야 합니다.\n- 열 내에 반복 그룹이나 배열이 없어야 합니다.\n- 테이블의 각 셀에는 하나의 값만 있어야 합니다.\n\n예를 들어, 각 셀이 반복 그룹이나 배열과 같은 것이 없이 하나의 값만 포함하고 있는 테이블은 1NF에 속합니다.\n\n## 2. 두 번째 정규형 (2NF):\n\n\n\n위의 내용을 친근한 톤으로 한국어로 번역하겠습니다.\n\n표가 2NF에 있다는 것은 다음과 같습니다:\n\n- 1NF에 있습니다.\n- 모든 비-키 속성이 기본 키 전체에 완전히 함수 종속성을 갖습니다.\n\n이는 모든 비-키 속성이 기본 키 전체에 의존해야 한다는 것을 의미합니다. 표가 복합 기본 키를 가지는 경우 각 비-키 속성은 복합 키 전체에 의존해야 하며 그 일부만으로는 안 됩니다.\n\n## 3. 세 번째 정규형 (3NF):\n\n\n\n3NF에있는 테이블은 다음과 같습니다:\n\n- 2NF에 있습니다.\n- 이러한 종속성이 없습니다.\n\n다시 말해, 비 주요 속성은 다른 비 주요 속성에 의존해서는 안됩니다. 이러한 종속성은 별도의 테이블을 생성하여 제거해야 합니다.\n\n## 4. Boyce-Codd Normal Form (BCNF):\n\n\n\nBCNF은 3NF의 강력한 형태이며 다음 조건을 만족할 때 달성됩니다:\n\n- 3NF에 있어야 합니다.\n- 모든 비자명 함수 종속인 𝑋→𝑌X→Y에 대해, X가 수퍼키여야 합니다.\n\n여기서 수퍼키는 테이블의 각 행을 고유하게 식별하는 속성 세트입니다.\n\n## 5. 제4 정규형 (4NF):\n\n\n\n4NF는 다중값 종속성을 해결하여 테이블이 다중값 속성이 없는 것을 보장합니다. 이것은 다중값 종속성을 제거하고 이를 위한 별도의 테이블을 생성함으로써 달성됩니다.\n\n## 6. 다섯 번째 정규 형태 (5NF):\n\n5NF, 또는 Project-Join 정규 형태 (PJ/NF)로도 알려져 있으며 조인 종속성을 다룹니다. 이는 테이블을 분해하여 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 결합될 수 있도록 보장함으로써 달성됩니다.\n\n# 주요 여정을 시작해봅시다!\n\n\n\n그래서, 지금까지 우리는 정규화가 무엇인지, 왜 정규화를 하는지, 그리고 정규화의 종류에 대한 기본 아이디어를 알게 되었습니다. 이 기본 지식을 바탕으로 정규화를 더 깊이 이해해볼 수 있게 되었습니다. 이제 메인 여정을 시작해봅시다.\n\n# 제1정규형 / 1NF\n\n제1정규형(1NF)은 정규화의 가장 기본적인 수준이며, 관계형 데이터베이스의 각 테이블이 원자 값만 포함하도록 하는 데 초점을 맞춥니다. 즉, 각 셀이 단일하고 분할할 수 없는 데이터 조각을 보유하도록 하는 것입니다. 이를 통해 열 내에서 반복 그룹이나 배열을 제거할 수 있습니다. 예제를 통해 1NF를 자세히 살펴봅시다:\n\n예제:\n\n\n\n학생들과 강의에 관한 정보를 저장하는 표를 생각해보세요. 이 표는 반복 그룹과 비원자적인 값을 포함하여 1NF를 위반합니다:\n\n![표](/assets/img/2024-05-15-MasterNormalizationinSQL_3.png)\n\n예제의 문제점:\n\n- 반복 그룹: \"Courses\" 열에는 쉼표로 구분된 여러 값을 포함합니다. 이는 1NF의 원자성 규칙을 위반합니다.\n- 비원자적인 값: \"Courses\" 열의 값은 원자적이지 않으며, 여러 조각의 데이터를 나타냅니다.\n\n\n\n이 표를 1NF로 바꾸려면 각 행에 원자 값만 포함되도록 여러 행으로 분할해야 합니다.\n\n## 1NF에서 재구성된 표:\n\n![Restructured Table in 1NF](/assets/img/2024-05-15-MasterNormalizationinSQL_4.png)\n\n설명:\n\n\n\n- \"Course\" column의 각 행은 이제 원자성 규칙을 준수하며 하나의 값만 포함합니다.\n- 반복 그룹이 제거되었고, 각 학생-과정 조합이 별도의 행으로 표시됩니다.\n\n## 제2 정규형 / 2NF\n\n제 2 정규형(2NF)은 부분 종속성 문제를 해결함으로써 제 1 정규형(1NF)을 기반으로 합니다. 이는 테이블 내의 모든 비-키 속성이 전체 주 키에 완전히 기능적으로 종속되도록 보장합니다. 예시를 통해 2NF를 자세히 살펴보겠습니다:\n\n예시:\n\n\n\n책과 저자 정보를 저장하는 테이블을 고려해보세요. 아래는 테이블이 어떻게 보일지에 대한 예시입니다:\n\n![테이블 예시](/assets/img/2024-05-15-MasterNormalizationinSQL_5.png)\n\n예시의 문제점:\n\n- 테이블은 복합 기본 키(BookID, AuthorID)를 포함하고 있습니다. 여기서 BookID는 책을 고유하게 식별하지만 AuthorID는 저자를 고유하게 식별하지 않습니다.\n- \"AuthorName\" 열은 AuthorID에만 종속되어 있으며 전체 기본 키에 종속되지 않습니다.\n- 이 테이블은 2NF를 위반합니다. AuthorName이 기본 키의 일부 (AuthorID)에 함수적으로 종속되어 있기 때문입니다.\n\n\n\n## 2NF에 재구성된 테이블:\n\n테이블을 2NF로 변경하기 위해 테이블을 두 개로 나눴어요: 책을 위한 하나와 작가를 위한 다른 하나입니다.\n\n![테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_6.png)\n\n## 설명:\n\n\n\n- Books 테이블에서 BookID가 기본 키(primary key)입니다.\n- Books 테이블의 AuthorID는 현재 Authors 테이블을 참조하는 외래 키(foreign key)입니다.\n- Authors 테이블에는 AuthorID가 기본 키로 포함되어 있습니다.\n- Authors 테이블은 각 작가의 이름이 중복으로 저장되지 않도록 보장합니다.\n- Authors 테이블은 AuthorID에 의해 결정되는 AuthorName이 전체 기본 키에 기능적으로 의존할 수 있습니다.\n\n## 제 3 정규형 / 3NF\n\n제 3 정규형(3NF)은 제 1 정규형(1NF)과 제 2 정규형(2NF)의 원칙을 확장하여 이행 종속성(transitive dependencies)을 다룹니다. 이는 비 기본 키(non-key attributes)가 다른 비 기본 키에 의존하지 않고 기본 키에만 의존하도록 보장합니다. 예시를 통해 3NF를 알아보겠습니다:\n\n예시:\n\n\n\n직원 및 부서에 관한 정보를 저장하는 테이블을 고려해보세요. 테이블에는 부서 관리자의 전화번호도 포함되어 있습니다.\n\n다음은 이 예시에 관한 문제점입니다:\n\n- 이 테이블에는 이행 종속성이 포함되어 있습니다: ManagerPhone이 기본 키가 아닌 Manager에 종속되어 있습니다.\n\n\n\n## 3NF로 재구성된 테이블:\n\n테이블을 3NF로 변경하기 위해 이원종속성을 제거해야 합니다. 테이블을 직원, 부서 및 매니저로 세 개의 별도 테이블로 분할할 것입니다.\n\n![테이블 이미지](/assets/img/2024-05-15-MasterNormalizationinSQL_8.png)\n\n설명:\n\n\n\n- 사원 테이블은 사원별 정보를 포함하며, 주요 키로 EmployeeID가 사용됩니다.\n- 부서 테이블은 각 부서에 대한 정보를 포함하며, 주요 키로 DepartmentID가 사용됩니다.\n- 매니저 테이블은 각 매니저에 대한 정보를 포함하며, 주요 키로 ManagerID가 사용됩니다.\n- 원본 테이블에서 ManagerPhone은 주키가 아닌 Manager에 종속적입니다. 테이블을 분할하여 이 체이닝 종속성을 제거합니다.\n\n# Boyce-Codd 정규형 (BCNF)\n\nBoyce-Codd 정규형(BCNF)은 제3 정규형(3NF)의 원리를 기반으로 한 더 높은 정규화 수준입니다. BCNF는 특정 유형의 기능적 종속성을 다루어 모든 비자명 기능적 종속성 𝑋→𝑌X→Y에 대해 결정자(X)가 수퍼키임을 보장합니다. 예시를 통해 BCNF를 살펴봅시다:\n\n예시:\n\n\n\n다음은 강의와 강사 정보를 저장하는 테이블을 고려해보세요:\n\nIssues with the Example:\n\n- The table contains a non-trivial functional dependency: 𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝐼𝐷→𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝑁𝑎𝑚𝑒,𝐸𝑚𝑎𝑖𝑙\n- The InstructorID determines both the InstructorName and Email, but InstructorID is not a superkey since multiple instructors can have the same ID.\n\n\n\n## BCNF로 재구성된 테이블:\n\n테이블을 BCNF로 가져오려면 모든 비자명 함수 종속의 결정자가 수퍼키여야 함을 보장해야 합니다. 테이블을 두 개로 분할할 것입니다: Courses와 Instructors.\n\n![BCNF 테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_10.png)\n\n설명:\n\n\n\n- Courses 테이블은 각 과정에 대한 정보를 포함하며 CourseID가 기본 키로 사용됩니다.\n- Instructors 테이블은 각각의 강사에 대한 정보를 포함하며 InstructorID가 기본 키로 사용됩니다.\n- 원래 테이블은 BCNF를 위반합니다. 이유는 InstructorID가 InstructorName과 Email을 모두 결정하고, InstructorID가 슈퍼키가 아니기 때문입니다. 테이블을 분할함으로써, 모든 비자명 함수 종속성의 결정자가 슈퍼키임을 보장합니다.\n\n# 제4 정규형 / 4NF\n\n4차 정규형(4NF)은 다중 값 종속성을 처리하여 제3 정규형(3NF)을 넘어가는 정규화 수준입니다. 데이터베이스 스키마에 비자명 다중 값 종속성이 없는지 확인합니다. 예제를 통해 4NF를 살펴보겠습니다:\n\n예시:\n\n\n\n프로젝트 및 해당 프로젝트에 배정된 직원, 그리고 각 직원이 책임지는 작업에 대한 정보를 저장하는 테이블을 고려해보세요:\n\n\n![테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_11.png)\n\n\n예제의 문제점:\n\n- 다중 값 종속성이 있습니다. 예를 들어 (프로젝트ID, 직원ID)의 조합이 여러 TaskID와 TaskName 쌍을 결정합니다.\n- 테이블은 비자명 다중 값 종속성을 포함하고 있어 4NF를 위반합니다.\n\n\n\n## 4NF에서 재구성된 테이블:\n\n테이블을 4NF로 전환하기 위해 다중 값 종속성을 제거하고 별도의 테이블로 분할해야 합니다.\n\n![Restructured Table](/assets/img/2024-05-15-MasterNormalizationinSQL_12.png)\n\n설명:\n\n\n\n- Projects 테이블은 ProjectID를 기본 키로 포함합니다.\n- Employees 테이블은 EmployeeID를 기본 키로 포함합니다.\n- Tasks 테이블은 ProjectID와 EmployeeID를 외래 키로 포함하며 TaskID를 기본 키로 포함합니다.\n- Tasks 테이블의 각 행은 프로젝트에서 직원에게 할당된 단일 작업을 나타냅니다.\n- 원래 테이블을 세 개의 별도 테이블로 분할함으로써 다중 값 종속성을 제거하여 데이터베이스 스키마가 4NF를 준수하도록 합니다.\n\n# 다섯 번째 정규 형식 / 5NF\n\n다섯 번째 정규 형식 (5NF), 또는 프로젝트 조인 정규 형식 (PJ/NF)은 조인 종속성을 다루며 데이터베이스 스키마에 조인 이상 현상이 없는 것을 보장합니다. 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 조인될 수 있도록 테이블을 분해하는 것을 포함합니다. 예제로 5NF를 살펴봅시다:\n\n예시:\n\n\n\n학생, 강의 및 각 강의에서 학생들이 받은 성적에 대한 정보를 저장하는 표를 고려해 보세요:\n\n\n| StudentID | StudentName | CourseID | CourseName | Grade |\n|-----------|-------------|----------|------------|-------|\n| 1         | Alice       | 1        | Math       | A     |\n| 2         | Bob         | 1        | Math       | B     |\n| 1         | Alice       | 2        | Science    | B     |\n\n\n예제의 문제점:\n\n- 표에 결합 의존성이 있는데, 특정 속성이 다른 속성들의 조합에 따라 종속되어 있습니다.\n- 예를 들어, CourseName은 CourseID에 의해 결정되며, Grade는 StudentID와 CourseID의 조합에 의해 결정됩니다.\n\n\n\n## 5NF로 재구성된 테이블:\n\n테이블을 5NF로 가져오기 위해 조인 종속성을 제거하기 위해 여러 개의 테이블로 분해합니다:\n\n![테이블 이미지](/assets/img/2024-05-15-MasterNormalizationinSQL_14.png)\n\n## 설명:\n\n\n\n- 학생 테이블은 주요 키로 학생ID와 이름을 포함합니다.\n- 강좌 테이블은 주요 키로 강좌ID와 강좌명을 포함합니다.\n- 성적 테이블은 외래 키로 학생ID와 강좌ID를 포함하며 성적이 있습니다.\n- 원본 테이블을 세 개의 별도 테이블로 분해함으로써 조인 종속성을 제거하여 데이터베이스 스키마가 5NF를 준수하도록 보장합니다.\n\n# 결론:\nSQL에서 정규화를 숙달하는 것은 효율적이고 확장 가능한 데이터베이스를 설계하는 데 중요합니다. 정규 형태를 이해하고 효과적으로 구현함으로써 데이터 무결성을 보장하고 중복을 줄이며 데이터베이스 관리를 간소화할 수 있습니다. 새 데이터베이스를 설계하거나 기존 데이터베이스를 최적화하는 경우 정규화 원칙은 견고하고 신뢰할 수 있는 데이터 인프라를 유지하는 데 필수적입니다.","ogImage":{"url":"/assets/img/2024-05-15-MasterNormalizationinSQL_0.png"},"coverImage":"/assets/img/2024-05-15-MasterNormalizationinSQL_0.png","tag":["Tech"],"readingTime":9}],"page":"90","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}