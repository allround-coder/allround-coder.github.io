{"pageProps":{"posts":[{"title":"MERN 스택에서 사용자 인증 시스템 이해하기 단계별 안내  파트1 - 서버 사이드","description":"","date":"2024-06-20 04:13","slug":"2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide","content":"\n\n안녕하세요 개발자 여러분! 이 이야기에서는 서버 및 클라이언트 측을 모두 포함한 인증 시스템을 구축할 것입니다. 그러나 이 부분에서는 서버 측만 구축할 것입니다.\n\n이 프로젝트의 레포지토리 링크는 다음과 같습니다. 미리 확인해보세요.\n\n## 목차\n\n- 소개\n- 프로젝트 설정하기\n- 환경 변수 설정하기\n- 데이터베이스 구성하기\n- 모델 생성하기\n- 컨트롤러 구축하기\n- 미들웨어 구현하기\n- 라우트 설정하기\n- 서버 테스트하기\n\n<div class=\"content-ad\"></div>\n\n## 1. 소개\n\n인증은 모든 애플리케이션의 중요한 부분입니다. 사용자가 자신이 주장하는 대로인지 확인하고 그들이 자격이 있는 리소스에 액세스할 수 있도록 보장합니다. 이 안내서에서는 Node.js, Express 및 JWT (JSON Web Tokens)를 사용하여 간단한 토큰 기반 인증 시스템을 구축할 것입니다.\n\n이야기 끝에 프로젝트 폴더 구조는 다음과 같이 보일 것입니다:\n\n![프로젝트 폴더 구조](/assets/img/2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide_0.png)\n\n<div class=\"content-ad\"></div>\n\n그럼 시작해보겠습니다!\n\n## 2: 프로젝트 설정\n\n먼저, 프로젝트를 설정해보겠습니다. 터미널을 열고 아래 명령어를 실행해주세요:\n\n```bash\nmkdir user-auth-system\ncd user-auth-system\nmkdir server\nmkdir client\ncd server\nnpm init -y\n```\n\n<div class=\"content-ad\"></div>\n\n프로젝트 폴더를 만들었는데 서버 및 클라이언트 폴더를 모두 포함하고 있어요. 하지만 클라이언트 쪽은 Part 2에서 만들 거에요. 이제 프로젝트의 서버 쪽에 사용할 필수 패키지를 설치해봐요.\n\n다음 패키지들을 사용할 거에요:\n\n- 서버용으로 express\n- 토큰 처리를 위한 jsonwebtoken\n- 패스워드 해싱을 위한 bcryptjs\n- 환경 변수를 관리하는 dotenv\n- 데이터베이스용으로 mongoose\n- Node.js 서버를 자동으로 재시작하는 nodemon\n- Cross-Origin Resource Sharing를 활성화하기 위한 cors\n\n아래 명령어를 실행하여 이러한 모든 패키지를 설치해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install express jsonwebtoken bcryptjs dotenv mongoose nodemon cors\n```\n\n## 3. 환경 변수 설정\n\n루트 디렉터리에 .env 파일을 만들고 다음 환경 변수를 추가하세요.\n\n```js\nMONGO_URI=\"mongodb://127.0.0.1/UserAuthSystem\" // 본인의 정보로 대체해주세요\nPORT=5000\nJWT_SECRET=your_jwt_secret_key\n```\n\n<div class=\"content-ad\"></div>\n\n- JWT_SECRET: JWT(JSON Web Token) 비밀 키는 토큰을 서명하고 확인하기 위해 사용되는 문자열입니다. 신뢰할 수 있는 출처에서 발급되었으며 조작되지 않았음을 서버가 확인하여 토큰의 무결성과 신뢰성을 보장합니다. 비밀 키를 문서에 책임을 증명하는 서명이나 봉인과 같다고 생각해보세요.\n- MONGO_URI: MongoDB URI는 응용 프로그램을 MongoDB 데이터베이스에 연결하는 연결 문자열입니다. 데이터베이스 주소, 포트 번호, 데이터베이스 이름 및 인증 자격 증명과 같은 정보를 포함합니다. 데이터베이스의 소포 주소처럼 생각해보세요. 응용 프로그램이 데이터베이스를 찾고 통신할 수 있도록 하는 것입니다. 사용자는 로컬 및 클라우드 기반 연결 문자열을 모두 사용할 수 있습니다.\n\n보안상의 이유로 Node.js 프로젝트의 .env 파일은 민감한 정보가 버전 관리에서 노출되지 않도록 .gitignore 파일에 포함되어야 합니다.\n\n## 4. 서버 생성\n\nserver.js라는 파일을 만들어 간단한 Express 서버를 만들어봅시다. 다음 코드를 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nrequire(\"dotenv\").config();\nconst express = require(\"express\");\nconst app = express();\nconst cors = require(\"cors\");\n\nrequire(\"./config/db\");\n\n//Middlewares\napp.use(cors());\napp.use(express.json());\n\nconst PORT = process.env.PORT || 5000;\napp.listen(PORT, () => console.log(`SERVER RUNNING ON PORT: ${PORT}`));\n```\n\n아래 명령으로 코드를 실행할 수 있습니다:\n\n```js\nnode src/server.js\n```\n\n서버를 시작하는 데 nodemon 패키지를 사용할 수도 있습니다. nodemon을 사용하면 파일 변경 후 서버를 다시 시작할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 package.json 파일의 scripts 섹션을 업데이트해야 합니다:\n\n```json\n \"scripts\": {\n    \"start\": \"node src/server.js\",\n    \"dev\": \"nodemon src/server.js\"\n  },\n```\n\n이제 다음 명령어를 실행해주세요:\n\n```bash\nnpm run dev\n```\n\n<div class=\"content-ad\"></div>\n\n터미널에서 포트 5000에서 서버가 실행 중임을 확인해야 해요. 확인되면 좋아요! 우리 서버가 가동 중이에요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:900/0*0feaPgbIGqHg0vXg.gif)\n\n## 5. 데이터베이스 구성\n\n데이터베이스로 MongoDB를 사용할 거예요. 데이터베이스 연결을 구성하기 위해 src/config 폴더에 db.js 파일을 생성해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst mongoose = require(\"mongoose\");\nmongoose\n  .connect(process.env.MONGO_URI)\n  .then(() => console.log(\"DATABASE CONNECTED\"))\n  .catch((err) => {\n    console.log(\"DATABASE CONNECTION ERROR\", err);\n    process.exit(1);\n  });\n```\n\nURL 'mongodb://127.0.0.1/UserAuthSystem'를 로컬에서 사용할 수 있습니다. 그러나 여기서 온라인 데이터베이스를 생성할 수도 있습니다. 프로젝트를 생성한 다음 클러스터를 만들면 됩니다. 거기서 얻은 URL을 사용하여 자신의 데이터베이스를 사용할 수 있습니다. 양쪽 모두 문제없이 작동합니다.\n\n## 6. 모델 생성\n\n다음으로 src/models/User.js에 User 모델을 생성해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst mongoose = require(\"mongoose\");\nconst bcrypt = require(\"bcryptjs\");\n\nlet UserSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: true,\n    index: true,\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    match: [/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/],\n  },\n  password: {\n    type: String,\n    required: true,\n    select: false,\n  },\n  created_at: {\n    type: String,\n  },\n});\n\nUserSchema.pre(\"save\", async function (next) {\n  if (!this.isModified(\"password\")) {\n    return next();\n  }\n  const salt = await bcrypt.genSalt(10);\n  this.password = await bcrypt.hash(this.password, salt);\n  next();\n});\n\nmodule.exports = mongoose.model(\"user\", UserSchema);\n```\n\n- 사용자 문서를 저장하기 전에, 사전 저장 후크가 암호가 수정되었는지 확인합니다.\n- 암호가 수정되었으면, bcryptjs를 사용하여 솔트를 생성하고 암호를 해시하여 데이터베이스에 저장합니다.\n\n## 7. Controllers 만들기\n\n컨트롤러는 route의 로직을 처리합니다. 이제 src/controllers 폴더에 authController.js를 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst bcrypt = require(\"bcryptjs\");\nconst jwt = require(\"jsonwebtoken\");\nconst { check, validationResult } = require(\"express-validator\");\n\nconst User = require(\"../models/User\");\n\nasync function Login(req, res) {\n  try {\n    await check(\"email\", \"유효한 이메일을 입력해주세요\").isEmail().run(req);\n    await check(\"password\", \"비밀번호를 입력해주세요\").exists().run(req);\n\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n\n    const { email, password } = req.body;\n\n    let user = await User.findOne({ email }).select(\"+password\");\n    if (!user) {\n      return res.status(400).json({\n        msg: \"유효하지 않은 자격 증명\",\n        success: false,\n      });\n    }\n\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) {\n      return res.status(400).json({\n        msg: \"유효하지 않은 자격 증명\",\n        success: false,\n      });\n    }\n\n    jwt.sign(\n      { id: user._id },\n      process.env.JWT_SECRET,\n      { expiresIn: \"10m\" },\n      (err, token) => {\n        if (err) throw err;\n        res.status(200).json({\n          token,\n        });\n      }\n    );\n  } catch (err) {\n    console.log(err);\n    res.status(400).json({ success: false });\n  }\n}\n\nasync function Register(req, res) {\n  try {\n    await check(\"username\", \"사용자 이름을 입력해주세요\").not().isEmpty().run(req);\n    await check(\"email\", \"유효한 이메일을 입력해주세요\").isEmail().run(req);\n    await check(\"password\", \"비밀번호는 6자 이상이어야 합니다\")\n      .isLength({ min: 6 })\n      .run(req);\n\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() }); \n    }\n\n    const { username, email, password } = req.body;\n\n    let user = await User.findOne({ email });\n    if (user) { \n      return res.status(400).json({ \n        msg: \"이미 등록된 사용자\",\n        success: false,\n      });\n    }\n\n    user = new User({\n      username,\n      email,\n      password,\n    });\n\n    await user.save();\n\n    jwt.sign(\n      { id: user._id },\n      process.env.JWT_SECRET,\n      { expiresIn: 36000 },\n      (err, token) => {\n        if (err) throw err;\n        res.status(200).json({\n          token,\n        });\n      }\n    );\n  } catch (err) {\n    console.log(err);\n    res.status(400).json({ success: false });\n  }\n}\n\nasync function GetUser(req, res) {\n  try {\n    const user = await User.findById(req.user.id);\n    res.status(200).json({\n      user,\n      success: true,\n    });\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).json({ msg: \"서버 에러\" });\n  }\n}\n\nmodule.exports = { Login, Register, GetUser };\n``` \n\n- 이 컨트롤러 파일은 로그인, 등록 및 사용자 데이터 가져오기와 같은 핵심 기능을 제공하며, 인증을 위해 JSON Web Token을 활용합니다. 이러한 기능을 라우트에서 사용할 것입니다.\n- 인증 시스템의 로그인 및 등록 부분에서 토큰이 생성됩니다. 이 토큰은 클라이언트로 보내는 응답에 포함됩니다. 인증 검증에 중요한 역할을 합니다. 또한 클라이언트 측에서 토큰은 후속 사용을 위해 쿠키에 저장됩니다.\n- express-validator npm 패키지를 사용하여 이메일 및 비밀번호가 제공되고 유효한지 확인합니다.\n\n## 8. 미들웨어 구현\n\n토큰을 확인하기 위한 미들웨어가 필요합니다. 계속하기 전에 미들웨어가 무엇인지 설명드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- 미들웨어는 웹 애플리케이션에서 요청이 최종 라우트 핸들러에 도달하기 전에 처리하는 함수입니다. 인증, 로깅 또는 요청 및 응답 객체 수정과 같은 작업을 처리할 수 있습니다.\n- 미들웨어를 공항의 보안 점검 및 프로세스와 비슷하게 생각해보세요. 비행기를 탑승하기 전에 보안, 세관, 탑승 등 다양한 점검점을 거치는 것처럼 요청도 최종 라우트 핸들러에 도달하기 전에 여러 미들웨어 함수를 거칩니다. 각 미들웨어는 특정 작업을 수행한 다음 요청을 다음 미들웨어로 전달하여 코드를 모듈화하고 재사용 가능하게 만듭니다.\n\n우리는 src/middlewares/verifyAuth.js에서 이를 달성합니다.\n\n```js\nconst jwt = require(\"jsonwebtoken\");\nmodule.exports = (req, res, next) => {\n  const token = req.header(\"x-token\");\n  if (!token) {\n    return res.status(401).json({\n      msg: \"유효한 토큰이 없습니다\",\n      success: false,\n    });\n  }\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    req.user = decoded;\n    next();\n  } catch (err) {\n    res.status(400).json({\n      msg: \"유효한 토큰이 없습니다\",\n      success: false,\n    });\n  }\n};\n```\n\n- 이 코드 스니펫은 x-token으로 할당된 요청 헤더에서 토큰을 확인합니다.\n- 토큰이 유효하면 토큰을 디코드하고 디코딩된 사용자 정보를 req.user에 할당한 다음 next()를 호출하여 제어를 다음 미들웨어 또는 라우트 핸들러로 전달합니다.\n\n<div class=\"content-ad\"></div>\n\n## 9. 라우트 설정하기\n\n이제 라우트를 설정해봅시다. src/routes 폴더에 auth.js를 생성하세요.\n\n```js\nconst express = require(\"express\");\nconst { Login, Register, GetUser } = require(\"../controllers/authController\");\nconst verifyAuth = require(\"../middlewares/verifyAuth\");\n\nconst router = express.Router();\n\nrouter.post(\"/login\", Login);\n\nrouter.post(\"/register\", Register);\n\nrouter.get(\"/user\", verifyAuth, GetUser);\n\nmodule.exports = router;\n```\n\n또한 server.js 파일을 업데이트하여 라우트를 연결해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nrequire(\"dotenv\").config();\nconst express = require(\"express\");\nconst app = express();\nconst cors = require(\"cors\");\n\nrequire(\"./config/db\");\n\n//Middlewares\napp.use(cors());\napp.use(express.json());\n\n// Routes\napp.use(\"/\", require(\"./routes/auth\"));\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`));\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:960/0*ggZsEOvbfphfI42C.gif\" />\n\n## 10. 서버 테스트하기\n\n이제 서버를 테스트해보는 시간입니다. 제대로 작동하는지 확인해봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n- npm run dev 명령어로 서버를 다시 실행한 후 Postman과 같은 API 플랫폼을 사용하여 /register 및 /login 엔드포인트를 테스트해보세요.\n- 또는 다른 쉬운 방법을 제안할 수도 있어요. VS Code 확장 프로그램인 REST Client를 사용해보세요.\n\n![이미지](/assets/img/2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide_1.png)\n\n- 이 확장 프로그램을 활용하기 위해 .rest 확장자를 가진 파일을 생성해야 해요. 그 파일에 HTTP 메서드를 입력하고 간편하게 요청을 보낼 수 있어요. 이 방법을 사용하여 라우트를 테스트하는 것을 선호한다면 이 방법을 사용할 수도 있어요.\n\n다음은 routes.rest 파일 내용입니다.\n\n<div class=\"content-ad\"></div>\n\n\nPOST http://localhost:3000/login\nContent-Type: application/json\n\n{\n    \"email\":\"test@gmail.com\",\n    \"password\":\"123456\"\n}\n\n###\n\nPOST http://localhost:3000/register\nContent-Type: application/json\n\n{\n    \n    \"email\":\"test@gmail.com\",\n    \"username\":\"alitalhacoban\",\n    \"password\":\"123456\"\n}\n\n###\n\nGET http://localhost:3000/user\nContent-Type: application/json\nx-token:your_access_token\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:990/0*Fl_hEz8V6Z0DRz88.gif\" />\n\n이 글에서는 간단한 토큰 기반 인증 시스템을 Node.js에서 구축했습니다. 이 설정은 Node.js 애플리케이션에서 안전한 인증을 구현하기 위한 견고한 기반을 제공합니다. Part 2에서는 이 프로젝트의 클라이언트 측을 구축하여 인증용 사용자 인터페이스를 만드는 방법과 서버와의 연결 방법에 대해 살펴볼 것입니다.\n\n이 글이 여러분에게 도움이 되기를 바랍니다. 계속 주시고 이와 같은 내용을 더 원하시면 박수를 치세요! 즐거운 코딩하세요!\n\n\n<div class=\"content-ad\"></div>\n\n아래 링크를 확인해 보세요.\n\n- cobanalitalha@gmail.com\n- github.com/carpodok\n- linkedin.com/alitalhacoban","ogImage":{"url":"/assets/img/2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide_0.png"},"coverImage":"/assets/img/2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide_0.png","tag":["Tech"],"readingTime":11},{"title":"Vue3에서 구성 요소 간 통신하는 9가지 방법","description":"","date":"2024-06-20 04:12","slug":"2024-06-20-9WaysofComponentCommunicationinVue3","content":"\n\n![이미지](/assets/img/2024-06-20-9WaysofComponentCommunicationinVue3_0.png)\n\n# 개요\n\n- props / emit\n- provide / inject\n- Pinia\n- expose / ref\n- attr\n- v-model\n- mitt.js\n- Slots\n- Teleport\n\n# Props / Emit\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트는 props를 사용하여 데이터를 자식 컴포넌트로 전달하고, 자식 컴포넌트는 이벤트를 사용하여 부모 컴포넌트에 데이터를 전달합니다.\n\n부모 컴포넌트에서 데이터를 자식 컴포넌트로 전달합니다.\n\n```js\n// Parent.vue에서 전송\n<child :msg2=\"msg2\"></child>\n<script setup lang=\"ts\">\n    import child from \"./child.vue\"\n    import { ref, reactive } from \"vue\"\n    const msg2 = ref<string>(\"자식 컴포넌트로 전송되는 메시지 2입니다\")\n    // 복잡한 타입의 경우\n    const msg2 = reactive<string>([\"하위 컴포넌트로 전송되는 메시지 2입니다\"])\n</script>\n\n// Child.vue에서 수신\n<script setup lang=\"ts\">\n    // import 할 필요 없이 직접 사용합니다\n    // import { defineProps } from \"vue\"\n    interface Props {\n      msg1: string\n      msg2: string\n    }\n    const props = withDefaults(defineProps<Props>(), {\n      msg1: '',\n      msg2: '',\n    })\n    console.log(props) // { msg2: \"하위 컴포넌트로 전송되는 메시지 2입니다\" }\n</script>\r\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트가 setup() 메서드를 사용하고 자식 컴포넌트가 script setup 구문을 사용하는 경우, 부모의 데이터에서 속성을 전달받지 못하며 부모의 setup 함수에서 전달받은 속성만 받을 수 있습니다.\n\n부모 컴포넌트가 script setup 구문을 사용하고 자식 컴포넌트가 setup() 메서드를 사용하는 경우, 자식은 부모의 데이터 및 setup 함수에서 속성을 모두 받을 수 있습니다. 그러나 자식 컴포넌트가 setup에서 속성을 받으려면 부모의 setup 함수에서만 속성을 받을 수 있고 데이터 속성에서는 받을 수 없습니다.\n\n자식 컴포넌트가 부모로 데이터를 전달\n\n```js\n// Child.vue dispatch\n<template>\n    // 방법 1\n    <button @click=\"emit('myClick')\">버튼</button>\n    // 방법 2\n    <button @click=\"handleClick\">버튼</button>\n</template>\n<script setup lang=\"ts\">\n    \n    // 방법 1: Vue3.2 버전에 적합, import 필요 없음\n    // import { defineEmits } from \"vue\"\n    // 방법 1에 대응\n    const emit = defineEmits([\"myClick\",\"myClick2\"])\n    // 방법 2에 대응\n    const handleClick = ()=>{\n        emit(\"myClick\", \"부모 컴포넌트로 전송된 메시지입니다\")\n    }\n    \n    // 방법 2: Vue3.2 버전에 적합하지 않음, useContext()는 사용이 중단됨\n    import { useContext } from \"vue\"\n    const { emit } = useContext()\n    const handleClick = () => {\n        emit(\"myClick\", \"부모 컴포넌트로 전송된 메시지입니다\")\n    }\n</script>\n\n// Parent.vue response\n<template>\n    <child @myClick=\"onMyClick\"></child>\n</template>\n<script setup lang=\"ts\">\n    import child from \"./child.vue\"\n    const onMyClick = (msg: string) => {\n        console.log(msg) // 부모 컴포넌트가 받은 메시지입니다\n    }\n</script>\r\n```\n\n<div class=\"content-ad\"></div>\n\n# 제공 / 주입\n\n이 매커니즘은 부모로부터 하위 구성 요소 중 어떤 것이든 종속성 주입을 개발하는 데 사용됩니다. 반드시 직계 자식 구성 요소일 필요는 없습니다.\n\n제공: 우리가 지정한 데이터를 주입할 수 있도록 합니다.\n\n주입: 어떠한 하위 구성 요소에서도 이 구성 요소에 추가하고 싶은 데이터를 수신합니다. 구성 요소가 얼마나 심층적으로 중첩되었는지와는 관계없이 직접 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// Parent.vue\n<script setup>\n    import { provide } from \"vue\"\n    provide(\"name\", \"Jhon\")\n</script>\n\n// Child.vue\n<script setup>\n    import { inject } from \"vue\"\n    const name = inject(\"name\")\n    console.log(name) // Jhon\n</script>\n```\n\n# Pinia\n\nPinia는 Vuex의 대체로 설계된 새로운 Vue 상태 관리 라이브러리입니다.\n\n```js\n// main.ts\nimport { createPinia } from 'pinia'\ncreateApp(App).use(createPinia()).mount('#app')\n\n// /store/user.ts\nimport { defineStore } from 'pinia'\nexport const userStore = defineStore('user', {\n    state: () => {\n        return { \n            count: 1,\n            arr: []\n        }\n    },\n    getters: { ... },\n    actions: { ... }\n})\n\n// Page.vue\n<template>\n    <div>{ store.count }</div>\n</template>\n<script lang=\"ts\" setup>\nimport { userStore } from '../store'\nconst store = userStore()\n// 분해할당\n// const { count } = userStore()\n</script>\n```\n\n<div class=\"content-ad\"></div>\n\n# 노출 / 참조\n\n참조는 부모 구성 요소가 자식 구성 요소의 인스턴스나 요소에 직접 액세스하는 데 사용될 수 있습니다.\n\n```js\n// Child.vue\n<script setup>\n    // 방법 1 Vue 3.2 버전에 적합하지 않으며,이 버전에서 useContext()는 사용되지 않습니다.\n    import { useContext } from \"vue\"\n    const ctx = useContext()\n    // 노출된 속성 및 메서드 등\n    ctx.expose({\n        childName: \"이것은 자식 구성 요소의 속성입니다\",\n        someMethod(){\n            console.log(\"이것은 자식 구성 요소의 메서드입니다\")\n        }\n    })\n    \n    // 방법 2 Vue 3.2 버전에 적합하며, import할 필요가 없습니다.\n    // import { defineExpose } from \"vue\"\n    defineExpose({\n        childName: \"이것은 자식 구성 요소의 속성입니다\",\n        someMethod(){\n            console.log(\"이것은 자식 구성 요소의 메서드입니다\")\n        }\n    })\n</script>\n\n// Parent.vue  참조 ref=\"comp\"\n<template>\n    <child ref=\"comp\"></child>\n    <button @click=\"handlerClick\">버튼</button>\n</template>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref } from \"vue\"\n    const comp = ref(null)\n    const handlerClick = () => {\n        console.log(comp.value.childName) // 자식 구성 요소에서 노출된 속성 가져오기\n        comp.value.someMethod() // 자식 구성 요소에서 노출된 메서드 호출\n    }\n</script>\r\n```\n\n# attrs\n\n<div class=\"content-ad\"></div>\n\n\nattrs: 부모 스코프에서 클래스 및 스타일을 제외한 컬렉션을 포함합니다.\n\n```js\n// Parent.vue에서 전송\n<child :msg1=\"msg1\" :msg2=\"msg2\" title=\"3333\"></child>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref, reactive } from \"vue\"\n    const msg1 = ref(\"1111\")\n    const msg2 = ref(\"2222\")\n</script>\n\n// Child.vue에서 수신\n<script setup>\n    import { defineProps, useAttrs } from \"vue\"\n    const props = defineProps({\n        msg1: String\n    })\n\n    const attrs = useAttrs()\n    console.log(attrs) // { msg2:\"2222\", title: \"3333\" }\n</script>\n```\n\n# v-model\n\n여러 데이터 요소에 대한 양방향 데이터 바인딩을 지원합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// Parent.vue\n<child v-model:key=\"key\" v-model:value=\"value\"></child>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref, reactive } from \"vue\"\n    const key = ref(\"1111\")\n    const value = ref(\"2222\")\n</script>\n\n// Child.vue\n<template>\n    <button @click=\"handlerClick\">Button</button>\n</template>\n<script setup>\n    \n    // Method 1은 useContext()이 폐기됨에 따라 Vue 3.2 버전에 적합하지 않습니다.\n    import { useContext } from \"vue\"\n    const { emit } = useContext()\n    \n    // Method 2는 Vue 3.2 버전에 적합하며, import 할 필요가 없습니다.\n    // import { defineEmits } from \"vue\"\n    const emit = defineEmits([\"key\",\"value\"])\n    \n    // 사용법\n    const handlerClick = () => {\n        emit(\"update:key\", \"새로운 키\")\n        emit(\"update:value\", \"새로운 값\")\n    }\n</script>\r\n```\n\n# mitt.js\n\nVue3에서는 컴포넌트간 통신을 위한 EventBus가 더 이상 사용되지 않지만, EventBus와 동일한 원리를 기반으로 하는 mitt.js라는 대체 방법이 새롭게 도입되었습니다.\n\n```js\r\n// mitt.js\nimport mitt from 'mitt'\nconst mitt = mitt()\nexport default mitt;\n\n// 컴포넌트 A\n<script setup>\nimport mitt from './mitt'\nconst handleClick = () => {\n    mitt.emit('handleChange')\n}\n</script>\n\n// 컴포넌트 B \n<script setup>\nimport mitt from './mitt'\nimport { onUnmounted } from 'vue'\nconst someMethed = () => { ... }\nmitt.on('handleChange',someMethed)\nonUnmounted(()=>{\n    mitt.off('handleChange',someMethed)\n})\n</script>\r\n```\n\n<div class=\"content-ad\"></div>\n\n# 슬롯\n\n슬롯은 부모 구성 요소가 자식 구성 요소의 콘텐츠 일부를 제어할 수 있도록 합니다. 재사용 가능하고 유연한 구성 요소 템플릿을 만드는 데 유용합니다.\n\n## 기본 슬롯\n\n```js\n// Parent.vue\n<FancyButton>\n  Click me! <!-- 슬롯 콘텐츠 -->\n</FancyButton>\n\n// Child.vue\n<button class=\"fancy-btn\">\n  <slot></slot> <!-- 슬롯 출력 -->\n</button>\n```\n\n<div class=\"content-ad\"></div>\n\n## 이름이 지정된 슬롯\n\n이름이 지정된 슬롯은 기본 슬롯을 기반으로 한 분류이며, 내용물을 해당 자리 표시자에 일치시키는 것으로 이해할 수 있습니다.\n\n```js\n// Parent.vue\n<template>\n  <Child>\n    <template v-slot:monkey>\n      <div>monkey</div>\n    </template>\n\n    <button>Click me!</button>\n  </Child>\n</template>\n\n// Child.vue\n<template>\n  <div>\n    <!-- 기본 슬롯 -->\n    <slot></slot>\n    <!-- 이름이 지정된 슬롯 -->\n    <slot name=\"monkey\"></slot>\n  </div>\n</template>\n```\n\n## 스코프 있는 슬롯\n\n<div class=\"content-ad\"></div>\n\n슬롯의 내용은 자식 컴포넌트의 상태에 액세스할 수 없습니다. 그러나 경우에 따라 슬롯의 내용이 부모 컴포넌트의 sphere와 자식 컴포넌트의 sphere에서 데이터를 사용하고 싶을 수 있습니다. 이를 달성하기 위해서는 렌더링 시 자식 컴포넌트가 슬롯에 데이터를 제공할 수 있는 방법이 필요합니다.\n\n```js\n// Parent.vue\n<template>\n  <!-- v-slot=\"{scope}\"은 자식 컴포넌트에서 전달된 데이터를 수신하는 데 사용됩니다 -->\n  <!-- :list=\"list\"은 리스트를 자식 컴포넌트에 전달합니다 -->\n  <Child v-slot=\"{scope}\" :list=\"list\">\n    <div>\n      <div>Name: { scope.name }</div>\n      <div>Occupation: { scope.occupation }</div>\n      <hr>\n    </div>\n  </Child>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport Child from './components/Child.vue'\n\nconst list = ref([\n  { name: 'Jhon', occupation: 'Thundering'},\n  ...\n])\n</script>\n\n// Child.vue\n<template>\n  <div>\n    <!-- 각 항목을 반환하려면 :scope=\"item\"을 사용합니다 -->\n    <slot v-for=\"item in list\" :scope=\"item\" />\n  </div>\n</template>\n\n<script setup>\nconst props = defineProps({\n  list: {\n    type: Array,\n    default: () => []\n  }\n})\n</script>\r\n```\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n<div class=\"content-ad\"></div>\n\n- 작가에게 박수와 팔로우를 부탁드립니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Differ\n- 더 많은 콘텐츠: Stackademic.com","ogImage":{"url":"/assets/img/2024-06-20-9WaysofComponentCommunicationinVue3_0.png"},"coverImage":"/assets/img/2024-06-20-9WaysofComponentCommunicationinVue3_0.png","tag":["Tech"],"readingTime":9},{"title":"자바스크립트 101 타이머에 대해 알아보기","description":"","date":"2024-06-20 04:10","slug":"2024-06-20-JavaScript101AllAboutTimers","content":"\n\n## 타이머는 사용 방법을 알고 있다면 강력한 도구가 될 수 있어요\n\n![JavaScript timers](/assets/img/2024-06-20-JavaScript101AllAboutTimers_0.png)\n\n자바스크립트 타이머는 주기적인 동작을 달성하거나 지연된 작업을 트리거하는 데 훌륭한 도구입니다.\n\n어떤 시간 기반 논리를 가지고 있던, 타이머가 답이 될 거예요.\n\n<div class=\"content-ad\"></div>\n\n하지만 그들이 어떻게 작동하는지 완전히 이해하지 못한다면, JavaScript로 만들어진 벽에 머리를 맞추게 될 거예요.\n\n가용한 타이머들과 그 작동 방식을 살펴보겠습니다.\n\n# 타이머에 대해 기억해야 할 주요 사항\n\n타이머의 세부사항에 대해 깊이 들어가기 전에, 타이머에 대해 기억해야 할 중요한 몇 가지 사항이 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 정확하지는 않아요\n\n타이머는 일정한 시간 후에 작업을 트리거하거나 지정된 시간이 지날 때마다 작업을 반복합니다.\n\n하지만 여러분이 엄밀히 1초마다 정확하게 작동한다고 기대할지도 모릅니다. 그러나 실제로는 그렇지 않습니다.\n\n이러한 타이머의 사양에 따르면 시간 매개변수(즉, 지정한 시간(초) 수)를 최소 대기 시간으로 사용할 것이라고 명시되어 있지만, 다른 작업이 먼저 완료되어야 할 경우에는 더 긴 시간이 소요될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n정확한 시간 측정에 의존하는 로직, 예를 들어 setInterval 콜백으로 초를 세는 시계가 있을 때에만 문제가 될 수 있습니다.\n\n이 점을 염두에 두고 타이머를 사용한다면 안전합니다.\n\n## 비동기 함수들입니다\n\n즉, 이들은 완료될 때까지 프로그램 흐름을 멈추지 않습니다. 타임아웃 값을 0으로 지정해도 그들의 동작은 여전히 비동기적일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 함수들은 원하는 함수에 대한 참조를 이벤트 루프에 추가하므로, 타임아웃 값에 0을 지정해도 해당 참조는 그 다음에 오는 모든 작업 이후에 예약됩니다.\n\n# setTimeout 이해하기\n\nsetTimeout 함수는 아마도 가장 이해하기 쉬운 함수일 것입니다. 주된 목적은 일정 시간 후에 함수를 트리거하는 것입니다.\n\n이 함수는 다음을 받습니다:\n\n<div class=\"content-ad\"></div>\n\n- 실행할 함수에 대한 참조입니다. 시간이 지나면 트리거될 코드입니다.\n- 함수가 실행되기 전의 초 단위의 숫자입니다.\n- 그 외의 모든 매개변수는 동일한 순서로 실행된 함수로 전달됩니다.\n\n따라서 다음 코드는 3초 후에 \"Hello World\"를 출력합니다:\n\n이 작업이 작동하는 이유는 console.log 함수가 받은 모든 매개변수를 연결하고 문자열을 출력하기 때문입니다.\n\n그러나 대신 다음과 같은 것이있는 경우 어떻게 됩니까:\n\n<div class=\"content-ad\"></div>\n\n14번 줄은 작동하지만, 16번 줄은 동작하지 않습니다. 이는 호출된 함수의 실행 컨텍스트가 변하기 때문입니다. 사실, 전역 범위로 변경됩니다. Node에서는 global, 브라우저에서는 window 입니다.\n\n두 경우 모두 함수의 this가 변경되므로, 16번 줄이 실행될 때 this.c에 대한 참조가 더 이상 존재하지 않습니다.\n\n따라서 이 문제를 해결하려면 다음과 같이 간단히 wrapper 함수를 만들 수 있습니다:\n\n16번 줄에 추가한 wrapper 익명 함수에 주목해 주세요. 이제 익명 함수가 두 매개변수와 함께 호출될 때, 해당 함수 내에서 바로 c.log를 call 메서드로 호출합니다 (모든 함수에 있는 메서드입니다). 우리는 call 메서드를 사용하는데, 이는 익명 함수에 의해 수신된 인수를 직접 log 메서드로 전달하기 때문입니다. 우리는 동적 방식으로 이동하고 있기 때문에 call을 사용하지 않고는 이 작업을 수행할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n익명 함수에 하드 코딩된 매개변수가 있다면 다음과 같이 log 메서드를 직접 호출할 수 있습니다:\n\nsetTimeout은 특별한 종류의 비동기 함수이므로 그 이후에 작성하는 모든 코드가 해당 함수가 트리거되기 전에 실행됩니다:\n\n해당 코드의 출력은 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-20-JavaScript101AllAboutTimers_1.png)\n\n<div class=\"content-ad\"></div>\n\n세트 타임아웃에서 9번째 줄이 타임아웃이 0인데도 마지막으로 실행된다는 것에 주목해 보세요.\n\n## 그리고 한 가지!\n\nsetTimeout에 대해 다시 한 번 살펴보기 전에, 타임아웃 값을 설정하고 실행을 중단해야 하는 경우에는 어떻게 해야 할까요? 실행되기 전에 타이머를 중지하려면 반환된 값(타이머 ID)을 저장하면 됩니다.\n\n그 값은 clearTimeout 함수와 함께 사용하여 타이머가 트리거되기 전에 중지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이전에 있던 코드를 편집해봅시다. 이번에는 첫 번째 타임아웃을 제거해 보겠습니다:\n\n위 코드를 사용하면 첫 번째 타이머가 코드를 실행하기 전에 제거되어 문자열 \"Third! (1)\"이 출력되지 않을 것입니다.\n\n하지만 만약 이 타이머를 제거하는 대신에 몇 초마다 반복하도록 하고 싶다면 어떻게 해야 할까요? 그런 경우 setTimeout은 한계가 있고, 그의 형제인 setInternval을 사용할 수 있습니다.\n\n# setInterval 이해하기\n\n<div class=\"content-ad\"></div>\n\nsetInterval 함수는 setTimeout과 매우 유사하지만, 함수를 한 번만 트리거하는 대신 그 함수를 멈출 때까지 계속해서 실행합니다.\n\n이 함수의 시그니처는 setInterval과 정확히 동일하며, 모든 매개변수에 대한 설명도 동일합니다.\n\n트리거된 함수 내에서 this의 컨텍스트에 대한 제한 사항도 마찬가지입니다. 해결책 또한 동일하게 래퍼 함수를 사용하는 것입니다.\n\n위 코드는 1초마다 실행되는 루프를 시작하며, 실행될 때마다 무작위 이름이 선택되어 \"Hello `name`\" 문자열이 출력됩니다.\n\n<div class=\"content-ad\"></div>\n\n뿐만 아니라, 무한 루프를 4초 후에 타임아웃하여 clearTimeout 함수를 호출하여 종료하는 타임아웃을 설정하고 있습니다. 물론 clearInterval 함수도 있지만, 동일한 타이머 풀을 사용하기 때문에 서로 교차하여 사용할 수 있습니다.\n\n타이머는 반복적이거나 지연된 동작을 생성하는 훌륭한 도구이며, 특히 일정 시간 기반 조건하에서 다른 서비스와 상호 작용해야 할 때 유용합니다.\n\n타임아웃과 간격 모두 clear* 함수를 사용하여 트리거되기 전에 중지할 수 있습니다. 돌려받은 함수 호출 ID를 유지했다면 언제든지 가능합니다.\n\nJavaScript에서 타이머에 대해 더 궁금한 사항이 있으신가요? 댓글에 질문을 남겨주시면 최선을 다해 답변해 드리겠습니다!\n\n<div class=\"content-ad\"></div>\n\n# 리고처럼 재사용 가능한 컴포넌트로 앱을 개발하세요\n\n![JavaScript 101](/assets/img/2024-06-20-JavaScript101AllAboutTimers_2.png)\n\nBit의 오픈소스 도구는 25만 명 이상의 개발자들이 컴포넌트로 앱을 개발하는 데 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 컴포넌트로 변환하고, 여러 애플리케이션에서 공유할 수 있습니다. 협업이 쉽고 개발 속도도 빨라집니다.\n\n<div class=\"content-ad\"></div>\n\n→ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 쉽게 만들고, 원하는 작업 흐름에 대한 최상의 경험을 즐기세요:\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n<div class=\"content-ad\"></div>\n\n## - 코드 공유 및 재사용\n\n## - Monorepo\n\n# 자세히 알아보기","ogImage":{"url":"/assets/img/2024-06-20-JavaScript101AllAboutTimers_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScript101AllAboutTimers_0.png","tag":["Tech"],"readingTime":4},{"title":"7 개의 오픈 소스 프로젝트, 여러분이 알아두어야 할 것 JavaScript 편 ","description":"","date":"2024-06-20 04:09","slug":"2024-06-20-7OpenSourceProjectsYouShouldKnowJavaScriptEdition","content":"\n\n![이미지](/assets/img/2024-06-20-7OpenSourceProjectsYouShouldKnowJavaScriptEdition_0.png)\n\n안녕하세요 👋🏼\n이 글에서는 JavaScript로 작성된 알아두어야 할 7개의 오픈 소스 저장소를 살펴볼 것입니다. 제 눈길을 끈 흥미로운 프로젝트들을 공유하고 싶어요.\n시작해봅시다 🤙🏼\n\n## Appwrite\n\nAppwrite는 웹, 모바일, 네이티브 또는 백엔드 앱을 위한 종단 간 백엔드 서버입니다.\n사용자 인증, 사용자 및 팀 데이터를 저장하고 쿼리하는 데이터베이스, 저장 및 파일 관리, 이미지 조작, 클라우드 함수 등의 서비스와 쉽게 앱을 통합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## melonJS\n\nmelonJS는 개발자와 디자이너가 내용에 집중할 수 있도록 돕는 HTML5 게임 엔진입니다.\n이 프레임워크는 풍부한 구성 요소 모음과 다양한 타사 도구 지원을 제공합니다.\nPhaser와 같은 다른 JavaScript 게임 엔진에 대한 대안이 됩니다🤞\n\n## GDevelop\n\nGDevelop는 또 다른 무료, 오픈소스 게임 엔진으로 PC나 휴대폰과 같은 다양한 플랫폼에서 구축할 수 있습니다.\n이 게임 엔진의 독특한 점은 조건과 액션을 기반으로 한 논리 시스템을 사용하기 때문에 코드를 사용하지 않고 비디오 게임을 만들 수 있다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## Egg.js\n\nEgg.js는 사용자의 키 입력을 감지하여 웹 이스터 에그를 쉽게 추가할 수 있는 간단한 라이브러리입니다.\n사용하기 쉽고 정말 재밌어요 🤣\n\n## API Vault\n\nAPI Vault는 JavaScript로 작성된 멋진 프로젝트입니다. 이 프로젝트는 온라인 플랫폼으로, 공개 API들의 세계로 이어지는 게이트웨이 역할을 합니다.\n카테고리별로 API를 필터링하고 자신에게 맞는 API를 찾을 수도 있어요 🖐\n\n<div class=\"content-ad\"></div>\n\n## sweetalert2\n\nsweetalert2는 외부 종속성 없이 JavaScript의 팝업 상자를 대체하는 아름다운, 반응형, 사용자 정의 가능하며 접근성이 좋은 도구입니다. 주로 JavaScript 프로젝트를 위해 설계되었으며 Angular, React, Vue와 같은 세 가지 대형 프론트엔드 프레임워크와 통합할 수 있습니다.\n\n## Video.js\n\nVideo.js는 HTML 비디오 및 미디어 소스 확장을 지원하는 웹 비디오 플레이어로 유튜브 및 비메오와 같은 다른 재생 기술도 지원합니다. 데스크탑 및 모바일 디바이스에서 비디오 재생을 지원합니다.\nsweetalert2와 마찬가지로 이 라이브러리를 Angular, React, Vue 세 가지 JavaScript 프레임워크와 통합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n여기에는 사용하거나 기여할 가치가 있는 7개의 오픈 소스 프로젝트가 나열되어 있습니다🖖 즐거운 코딩하세요!✨\n\n안녕하세요👋🏻\n제 이름은 도메니코이고, Vue.js 프레임워크에 열정을 가진 소프트웨어 개발자입니다. 제 지식과 경험을 공유하기 위해 이에 대한 기사를 씁니다. 제 프로젝트를 발견하려면 내 Linktree를 방문하지 않길 잊지 마세요🫰🏻\n\n제 Linktree를 확인해보세요👇🏻","ogImage":{"url":"/assets/img/2024-06-20-7OpenSourceProjectsYouShouldKnowJavaScriptEdition_0.png"},"coverImage":"/assets/img/2024-06-20-7OpenSourceProjectsYouShouldKnowJavaScriptEdition_0.png","tag":["Tech"],"readingTime":2},{"title":"전략 패턴 NET C","description":"","date":"2024-06-20 04:08","slug":"2024-06-20-StrategyPatternNETC","content":"\n\n전략(pattern) 패턴은 알고리즘의 동작을 런타임(runtime)에서 선택할 수 있게 해주는 행동 디자인 패턴입니다. 주요 아이디어는 알고리즘의 집합을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만드는 것입니다. 전략(pattern) 패턴은 알고리즘을 사용하는 클라이언트로부터 독립적으로 알고리즘을 변경할 수 있게 합니다.\n\n## 구성 요소\n\n- 컨텍스트(Context): Strategy 인스턴스에 대한 참조를 포함하는 클래스입니다. 이는 전략(strategy)이 작동하는 방법의 세부 정보를 이해하지 않고도 작업의 실행을 전략(strategy)의 구현에 위임합니다.\n- 전략(strategy) 인터페이스: 이는 모든 구체적인 전략(strategy)들을 위한 공통 인터페이스를 정의합니다. 컨텍스트가 전략을 실행하는 데 사용하는 메서드를 선언합니다.\n- 구체적인 전략(strategy): 전략(strategy) 인터페이스를 구현하는 개별 클래스입니다. 각각은 다른 알고리즘이나 작업 수행 방법을 나타냅니다.\n\n## 원칙과 정책\n\n<div class=\"content-ad\"></div>\n\n- 변이의 캡슐화: 전략 패턴은 알고리즘의 변하는 부분을 유지되는 부분과 캡슐화합니다. 이는 알고리즘의 변경이 클라이언트 코드에 영향을 미치지 않는다는 것을 의미합니다.\n- 인터페이스에 프로그래밍, 구현에 프로그래밍하지 말기: 클라이언트는 구현이 아닌 인터페이스를 통해 전략과 상호작용합니다. 이는 클라이언트 코드가 인터페이스를 구현하는 어떤 전략과도 작동할 수 있다는 것을 의미합니다.\n- 상속보다 구성을 선호: 상속하는 대신 전략 패턴은 구성을 사용하여 책임을 전략 객체에 위임합니다. 이는 적절한 동작을 선택하는 더 많은 유연성을 제공합니다.\n- 개방/폐쇄 원칙: 시스템은 확장을 위해 열려 있지만 수정에 대해 폐쇄되어야 합니다. 새로운 전략을 추가할 때 콘텍스트나 클라이언트 코드가 시스템을 사용하는 방식을 변경하지 않아도 됩니다.\n- 단일 책임 원칙: 각 전략 클래스는 특정 알고리즘이나 동작을 나타내는 단일 책임이 있습니다. 이로 인해 이해하기 쉽고 구현하고 테스트하기 쉽습니다.\n\n이러한 원칙을 따르면 전략 패턴은 다양한 알고리즘이나 동작을 처리하는 유연한 구조를 제공하여 애플리케이션의 기능적 부분을 관리, 확장 및 수정하기 쉽도록 만들어줍니다.\n\n# 결제 처리 시스템\n\n크레딧 카드, PayPal 또는 암호화폐와 같이 다양한 결제 전략이 필요한 결제 처리 시스템을 고려해 봅시다. 결제 전략은 종종 변경되거나 추가가 필요할 수 있어 전략 패턴에 적합한 사용 사례입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-StrategyPatternNETC_0.png\" />\n\n# 전략 패턴 없이\n\n초기에 시스템은 신용카드 결제만 지원할 수 있으므로 직접 클래스 내에 구현할 수 있습니다.\n\n```js\npublic class PaymentProcessor\n{\n    public void ProcessPayment(decimal amount, string method)\n    {\n        if (method == \"CreditCard\")\n        {\n            // 신용카드 결제 처리 로직\n            Console.WriteLine($\"신용카드를 통한 {amount} 처리 중\");\n        }\n    }\n}\n\n// 사용법\nvar paymentProcessor = new PaymentProcessor();\npaymentProcessor.ProcessPayment(100.00m, \"CreditCard\");\n```\n\n<div class=\"content-ad\"></div>\n\n이제 PayPal을 결제 방법으로 추가해야 한다고 가정해 보겠습니다. PaymentProcessor 클래스를 수정하여 다른 if-else 조건을 추가해야 할 수 있습니다.\n\n```js\npublic class PaymentProcessor\n{\n    public void ProcessPayment(decimal amount, string method)\n    {\n        if (method == \"CreditCard\")\n        {\n            // 신용카드 결제 처리 로직\n            Console.WriteLine($\"신용카드로 {amount} 처리중\");\n        }\n        else if (method == \"PayPal\")\n        {\n            // PayPal 결제 처리 로직\n            Console.WriteLine($\"PayPal로 {amount} 처리중\");\n        }\n        // 새 결제 방법을 추가할 때마다 더 많은 if-else 문이 여기에 추가됩니다.\n    }\n}\n\n// 사용 예\nvar paymentProcessor = new PaymentProcessor();\npaymentProcessor.ProcessPayment(100.00m, \"CreditCard\");\npaymentProcessor.ProcessPayment(75.50m, \"PayPal\");\n```\n\n## 이 접근 방식의 문제점\n\n- 확장성: 새 결제 방법마다 ProcessPayment 메서드에 더 많은 if-else 조건을 추가해야 하므로, 메서드는 무한정으로 커지게 됩니다.\n- 유지보수성: 시간이 흐르면서 ProcessPayment 메서드는 점점 복잡해지고 관리하기 어려워집니다.\n- 개방/폐쇄 원칙 위반: 이 클래스는 수정을 열어둔 상태입니다. 새로운 결제 유형을 추가할 때마다 이 클래스를 수정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 전략 패턴 사용하기\n\n자, 이제 코드를 전략 패턴을 사용하도록 리팩토링해보겠습니다. 이렇게 하면 더 유연하고 유지보수하기 쉬워집니다.\n\n## 전략 인터페이스\n\n```js\npublic interface IPaymentStrategy\n{\n    void ProcessPayment(decimal amount);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 구체적인 전략\n\n```js\npublic class CreditCardPaymentStrategy : IPaymentStrategy\n{\n    public void ProcessPayment(decimal amount)\n    {\n        // 신용 카드 결제 처리 로직\n        Console.WriteLine($\"신용 카드로 {amount} 처리 중\");\n    }\n}\n\npublic class PayPalPaymentStrategy : IPaymentStrategy\n{\n    public void ProcessPayment(decimal amount)\n    {\n        // PayPal 결제 처리 로직\n        Console.WriteLine($\"PayPal로 {amount} 처리 중\");\n    }\n}\n```\n\n## 컨텍스트 클래스\n\n```js\npublic class PaymentProcessor\n{\n    private IPaymentStrategy _paymentStrategy;\n\n    public PaymentProcessor(IPaymentStrategy paymentStrategy)\n    {\n        _paymentStrategy = paymentStrategy;\n    }\n\n    public void SetPaymentStrategy(IPaymentStrategy paymentStrategy)\n    {\n        _paymentStrategy = paymentStrategy;\n    }\n\n    public void ProcessPayment(decimal amount)\n    {\n        _paymentStrategy.ProcessPayment(amount);\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 사용법\n\n```js\nvar creditCardPayment = new PaymentProcessor(new CreditCardPaymentStrategy());\ncreditCardPayment.ProcessPayment(100.00m); \n// 출력: 신용 카드로 100.00 처리 중\n\nvar payPalPayment = new PaymentProcessor(new PayPalPaymentStrategy());\npayPalPayment.ProcessPayment(75.50m); \n// 출력: PayPal로 75.50 처리 중\n```\n\n전략 패턴의 맥락에서 새 결제 방법을 추가하는 것은 간단한 프로세스이며 기존 코드를 변경할 필요가 없기 때문에 이 패턴의 주요 이점 중 하나입니다.\n\n기존 시스템에 새로운 암호화폐 결제 전략을 추가하는 방법을 살펴보고 이 접근 방식이 기능 확장을 어떻게 단순화하는지 비교해봅시다.\n\n<div class=\"content-ad\"></div>\n\n## 암호화폐 결제 전략 추가하기\n\nIPaymentStrategy 인터페이스를 구현하는 클래스를 생성하여 새로운 구체적인 전략을 정의하세요.\n\n```js\npublic class CryptoPaymentStrategy : IPaymentStrategy\n{\n    public void ProcessPayment(decimal amount)\n    {\n        Console.WriteLine($\"암호화폐를 통한 {amount} 처리 중\");\n        // 실제 암호화폐 처리 로직\n    }\n}\n```\n\n새 전략을 사용하는 방법은 새 CryptoPaymentStrategy로 PaymentProcessor를 인스턴스화하는 것만으로 간단합니다.\n\n<div class=\"content-ad\"></div>\n\n```javascript\nvar cryptoPayment = new PaymentProcessor(new CryptoPaymentStrategy());\ncryptoPayment.ProcessPayment(50.00m); \n// 출력: 50.00을(를) 암호화폐를 통해 처리 중\n```\n\n전략 패턴의 맥락에서 새로운 지불 전략을 추가함으로써, 해당 패턴이 변경과 확장을 효율적으로 다루는 능력을 보여줍니다. 이를 통해 새로운 기능을 기존 코드베이스에 영향을 주지 않고 매끄럽게 추가할 수 있어서 버그 도입 위험을 크게 줄이고 시스템을 더 관리 가능하고 확장 가능하게 만들 수 있습니다.\n\n## 전략 패턴 사용의 장점\n\n- 확장 용이성: IPaymentStrategy 인터페이스를 구현하는 새 클래스를 만들기만 하면 됩니다. 기존 코드를 수정할 필요가 없습니다.\n- 개방/폐쇄 원칙 준수: 시스템은 확장을 위해 열려 있지만 수정은 닫혀 있습니다. 기존 클래스를 변경하지 않고 새로운 지불 전략을 추가할 수 있습니다.\n- 간결함과 유지보수성: PaymentProcessor 클래스는 간단한 상태를 유지하며 새 지불 방법이 추가될수록 복잡성이 증가하지 않습니다. 각 지불 방법은 자체 클래스에 캡슐화되어 있어 시스템을 이해하고 유지하기 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n이 정보가 유용했길 바랍니다. 🌟 즐거우면서도 풍부한 학습 여정을 희망합니다!\n\n📚 이와 같은 통찰력을 더 원하신다면, 자유롭게 👉 Merwan Chinta를 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-06-20-StrategyPatternNETC_0.png"},"coverImage":"/assets/img/2024-06-20-StrategyPatternNETC_0.png","tag":["Tech"],"readingTime":6},{"title":"좋은 이름을 선택하기 위한 7단계 치트 시트","description":"","date":"2024-06-20 04:06","slug":"2024-06-20-My7-StepCheatSheetforChoosingGoodNames","content":"\n\n뭔가 이름 짓기는 결코 쉬운 일이 아니었죠. 특히 개발자들에게!\n\n![이미지](/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_0.png)\n\n변수, 클래스, 함수 및 기타 코드 요소에 선택한 이름은 의미 있는, 정확한 및 쉽게 이해할 수 있는 이름이어야 하기 때문에 이름 짓는 것은 어려운 작업으로 간주될 수 있습니다.\n\n코드베이스를 깨끗하고 유지보수 가능하게 유지하기 위해서는 좋고 일관된 이름 규칙이 필수적입니다. 시스템이 커짐에 따라 새로운 이름이 기존 이름과 충돌하지 않도록 보장하는 것이 어려울 수 있기 때문에 이것은 도전적일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 코드 이름을 선택할 때 고려해야 할 사항에 대한 체크리스트를 살펴보겠습니다. 이 목록에는 저의 개인적인 통찰과 Uncle Bob 및 Eric Evans와 같은 유명한 저자들의 아이디어가 포함되어 있습니다.\n\n## 1. 의도 및 측정 단위\n\n선택한 이름은 요소의 의도 및 기능뿐만 아니라 해당되는 측정 단위도 명확히 전달해야 합니다. 이렇게 함으로써 코드를 작성하는 사람뿐만 아니라 나중에 코드를 읽거나 수정해야 하는 다른 사람에게도 코드를 이해하고 유지할 수 있도록 도와줄 것입니다.\n\n반면에 지나치게 짧은 변수 이름이나 믿을 수 없는 약어의 사용은 관련된 모든 사람들에게 코드의 가독성과 이해도를 크게 해치게 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\npublic double calculateBmi(double m, double h) {\n    double sh = h * h;\n    double mKg = m * 0.453d;\n    return mKg / sh;\n}\n```\n\n위 코드 스니펫을 보기 좋게 개선할 수 있습니다. 변수에 적절한 이름을 선택하면 코드의 가독성이 크게 향상됩니다:\n\n```js\npublic static final double LBS_TO_KG = 0.453d;\n\npublic double calculateBmi(double massInLbs, double heightInMeters) {\n    double squaredHeight = heightInMeters * heightInMeters;\n    double massInKg = massInLbs * LBS_TO_KG;\n    return massInKg / squaredHeight;\n}\n```\n\n## 2. Avoid Noise Words\n\n\n<div class=\"content-ad\"></div>\n\n한번 웃어보세요! 자바 애플리케이션을 위한 클래스 이름을 생성해주는 재밌는 웹사이트가 있어요. \"enterprisify\"를 몇 번 클릭해보세요! 이런 생성된 이름들은 '소음 단어'로 이루어져 있어요. 이것은 의도를 표현하지 않는 기술 용어들이에요.\n\n클래스 이름에 소음 단어를 사용하면 코드를 이해하기 어려울 수 있어요. AccountData와 Account 클래스와 다른 점을 알고 계신가요?\n\n그러면 AccountSummary가 더 나은 선택이 될 수도 있어요.\n\n그리고 AccountDto나 AccountEntity는 어떨까요?\n\n<div class=\"content-ad\"></div>\n\n“Data”라는 노이즈 단어는 추가 정보를 제공하지 않아요. 하지만 때로는 클래스 이름을 지을 때 기술 용어를 사용해서 클래스의 위치나 구현을 나타낼 수 있어요. 예를 들어, Service, Dto, Entity, Repository와 같은 접미사를 사용할 수 있어요.\n\n![이미지](/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_1.png)\n\n## 3. 데이터 유형 및 키워드 피하기\n\n데이터 유형 역시 \"노이즈 단어\"로 간주될 수 있어요. 몇 가지 예시는 다음과 같아요:\n\n<div class=\"content-ad\"></div>\n\n```js\n기록 PromotionRecord (\n    // ...\n){}\n\n추상 클래스 AbstarctPromotion {\n  // ...\n}\n\nOffsetDateTime startOffsetDateTime;\n\nList<Account> listOfAccounts;\n```\n\n동일하게 인터페이스와 그 구현에 대한 특별한 명명 패턴은 안티 패턴으로 간주될 수 있습니다. 흔히 사용되는 방법은 인터페이스에 \"I\"를 접두사로 붙이고 클래스에 \"Impl\" 접미사를 붙이는 것입니다:\n\n```js\ninterface ICustomerDetailsProvider {}\n\nclass CustomerDetailsProviderImpl implements ICustomerDetailsProvider {}\n```\n\n그럼 정말 인터페이스가 필요한 이유는 무엇일까요? 대부분의 경우 인터페이스를 두 가지 경우 중 하나에서 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- 의존 역전(Dependency Inversion): 인터페이스는 도메인 레이어의 일부이며 구현은 인프라스트럭처 레이어의 코드를 사용하는 어댑터처럼 작동합니다.\n예를 들어, 도메인 레이어의 일부로 CustomerDetailsProvider 인터페이스를 가질 수 있고, 해당 구현은 네트워크 호출을 통해 고객에 대한 특정 데이터를 가져옵니다. 만약 해당 구현을 \"CustomerDetailsProviderImpl\"이라고 명명한다면 \"Impl\" 접미사는 가치를 추가하지 않을 것입니다. 대신, \"CustomerDetailsApiClient\" 또는 \"CustomerApiAdapter\"와 같이 데이터가 어떻게 가져와지는지에 대한 힌트를 제공해줄 것입니다.\n- 다형성(Polymorphism): 다형성을 위해 인터페이스를 사용한다면, 최소 두 가지 이상의 명확히 구분된 구현이 있어야 합니다. 예를 들어, \"Payment\" 인터페이스와 다른 결제 방법을 위한 다양한 구현이 있다면 구현은 매우 다르며 의미 있는 이름을 가져야 합니다: \"CashPayment\", \"VisaPayment\", \"OnlinePayment\" 등.\n\n## 4. 길이 대 무게\n\n변수 이름을 짓는 경우, 이름의 길이는 변수의 범위와 직접적으로 비례해야 합니다. 따라서 작은 범위의 경우, 단일 작은 단어나 약어가 충분합니다. Uncle Bob은 더 나아가서 매우 작은 범위(한 줄짜리 코드와 같은)에는 하나의 글자 이름조차 충분하다고 말합니다.\n\n```js\n// 작은 범위\nfor(Employee employee : employeesEligibleForPromotion) {\n    // 4-5 줄의 코드\n}\n\n// 매우 작은 범위\nemployeesEligibleForPromotion.stream()\n    .map(e -> e.getName().toLowerCase())\n    .forEach(this::sendNotificationToHrDepartment);\n```\n\n<div class=\"content-ad\"></div>\n\n더 긴 범위에 따라, 변수 이름도 길어집니다. 하지만 변수 이름이 너무 길어진다면, 이는 코드 향기의 지표일 수 있습니다: 함수가 너무 커졌다는 것을 의미할 수 있습니다.\n\n예를 들어, 위의 코드 스니펫에서 직원 목록에 대해 꽤 긴 이름을 사용했죠: employeesEligibleForPromotion. 이는 함수의 범위가 크거나 동일한 범위 내에 다른 직원 목록이 있음을 의미할 수 있습니다. 어쨌든, 기능을 추출할 수 있습니다:\n\n```js\npublic void sendNotificationToHrForEmployees(List<Employees> employees) {\n    employees.stream()\n      .map(e -> e.getName().toLowerCase())\n      .forEach(this::sendNotificationToHrDepartment);\n}\n```\n\n우리가 볼 수 있듯이, 함수를 추출하고 변수의 범위를 작게 만들면 이름을 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n함수를 명명할 때는 범위가 길수록 이름을 작고 추상적으로 지어야 합니다. 이는 우리가 상위 수준의 함수가 구현 세부 정보를 누설하지 않도록 원하기 때문입니다. 따라서 범위가 작은 함수는 이름이 더 길어질 것입니다.\n\n## 5. 일관성\n\n일관된 명명 규약은 다른 사람들이 작성한 코드를 탐색하고 이해하기 쉽게 만들어줍니다. 특히 대규모 공동 작업 프로젝트에서 이는 중요합니다. 또한, 일관성은 명명 충돌을 방지하고 코드에 버그나 오류가 도입되는 가능성을 줄일 수 있습니다.\n\n동일한 작업에 대해 다른 동사를 사용하지 않도록 주의하세요: 구현이 동일한 경우 fetch, retrieve, get 및 find를 서로 교차적으로 사용하지 마세요. 동시에 다른 구현이나 개념에 대해 서로 다른 단어를 선택해야 합니다. 예를 들어, \"find\" 동사를 사용하여 Optional 또는 nullable 데이터를 반환할 수 있지만, 데이터가 누락된 경우에는 \"get\"이 항상 예외를 throw합니다.\n\n<div class=\"content-ad\"></div>\n\n## 6. 비즈니스 용어 vs. 기술 용어\n\n비즈니스 용어와 기술 용어는 우리에게 적절한 이름을 선택하는 데 도움을 줄 수 있습니다. Clean Code에서 Uncle Bob은 기술 용어가 다른 개발자들에 의해 쉽게 이해될 수 있기 때문에 우선적으로 고려해야 한다고 제안합니다. Adapter, Builder, Repository, Dto와 같은 용어는 컴포넌트의 구현이나 위치를 나타낼 수 있습니다.\n\n반면에 Eric Evan의 도메인 주도 설계는 비즈니스 언어를 받아들이는 것이 복잡한 도메인 모델을 가진 대규모 시스템에서 도움이 된다고 가르쳐줍니다. 이는 개발자와 비즈니스 담당자 간의 커뮤니케이션 간극을 크게 줄일 수 있습니다.\n\n전반적으로, 컴포넌트에 이름을 선택할 때 비즈니스 용어와 기술 용어 모두 좋은 후보가 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 7. 동사 vs. 명사\n\n약칭으로는, 함수에는 동사를 사용하고 필드 및 변수에는 명사를 사용해야 합니다.\n\n대부분의 경우 클래스에는 명사를 사용할 것이지만 몇 가지 특별한 경우가 있을 수 있습니다. 예를 들어, \"세로 슬라이스\" 디자인을 사용하는 경우 사용 사례를 나타내는 클래스를 가질 수 있습니다. 이러한 클래스는 CreateAccount, DisableAcount, ApplyPromotion과 같은 이름을 가질 것입니다.\n\n인터페이스는 모두 메서드와 동작에 관한 것입니다. 인터페이스 이름을 정할 때에는 명사를 사용해야 하지만, 동시에 그들이 가능하게 하는 행동을 명확하게 표현해야 합니다. 예를 들어 Clonable, Runnable, Executable, DataProvider 등이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n이 글에서는 좋은 이름을 선택하기 위한 7단계 체크리스트를 살펴보았습니다. 우리는 의도 표현, 측정 단위, 그리고 \"잡음 단어\" 피하기에 대해 처음에 논의했습니다. 그 후에는 이름의 길이, 일관성, 그리고 사용할 수 있는 단어 유형에 대해 배웠습니다.\n\n![링크](/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_2.png)\n\n# 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n기사를 읽어 주셔서 감사합니다! 의견을 주시면 감사하겠습니다. 어떠한 피드백이든 환영입니다.\n\n프로젝트 이름을 선택할 때 꼭 지켜야 할 사항과 지켜야 할 규칙에 대한 .svg 치트 시트를 만들었습니다. 이 글에서 논의한 내용을 간결하게 요약한 것입니다. 제 콘텐츠가 마음에 들고, 이 치트 시트를 이메일로 받고 싶다면, 이메일 구독을 고려해 주세요.\n\n즐거운 코딩 시간 보내세요!\n\n# 레벨업 코딩\n\n<div class=\"content-ad\"></div>\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 👏 스토리에 박수를 보내고 저자를 팔로우하세요 👉\n- 📰 Level Up Coding 게시물에서 더 많은 콘텐츠를 확인하세요\n- 🔔 팔로우하기: Twitter | LinkedIn | Newsletter\n\n🚀👉 Level Up 재능 동호회에 가입하여 멋진 취업 기회를 찾아보세요","ogImage":{"url":"/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_0.png"},"coverImage":"/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_0.png","tag":["Tech"],"readingTime":7},{"title":"V8 엔진 시리즈 I 아키텍처","description":"","date":"2024-06-20 04:04","slug":"2024-06-20-TheV8EngineSeriesIArchitecture","content":"\n\n![V8 Engine Series Architecture](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_0.png)\n\n# 소개\n\nV8은 현대 웹 브라우저에서 JavaScript와 WebAssembly을 실행하기 위해 Google에서 개발한 오픈 소스 고성능 엔진입니다. 현대 웹에서는 Google Chrome과 Node.js에서 사용되며, 클라이언트 및 서버 측에서 JavaScript가 빠르게 실행되도록 보장합니다. C++로 작성되어 있으며, 코드 실행 속도를 현저히 향상시킵니다. 최신 및 고급 Just-In-Time (JIT) 컴파일 기술의 도움을 받아 JavaScript 코드를 컴파일하여 빠른 시작과 높은 실행 속도를 결합하는 방법을 제공합니다. 이 논문에서는 V8 아키텍처와 운영 측면을 설명하여 추가로 이해할 수 있도록 합니다.\n\n이 시리즈에서는 V8 엔진의 내부 아키텍처를 탐구하며, 개요부터 시작하여 각 구성 요소를 자세히 살펴보고 기술적 세부 사항을 설명할 것입니다. 시리즈가 끝나면 V8 엔진을 사용하여 Node.js와 유사한 것을 간소화된 버전으로 만들 것입니다. V8를 통해 정보를 얻고 실용적인 여정을 계속 따라와 주세요!\n\n<div class=\"content-ad\"></div>\n\n# V8 아키텍처의 주요 구성 요소\n\n## 1. 파서\n\nV8 아키텍처의 첫 번째 구성 요소는 파서입니다. 이는 JavaScript 소스 코드를 가져와서 추상 구문 트리(Abstract Syntax Tree, AST)로 변환합니다. 이 트리는 코드의 구조에 따라 계층적으로 표현되며, V8에서 코드를 쉽게 조작하고 최적화할 수 있도록 합니다.\n\n## 2. 이그니션 인터프리터\n\n<div class=\"content-ad\"></div>\n\n이그니션은 V8 내부의 낮은 수준에서 작동하는 가벼운 인터프리터입니다. 이는 AST를 바이트코드로 컴파일하여 자바스크립트 소스 코드의 고효율 표현으로 작용합니다. 이것은 고수준 자바스크립트와 저수준 머신 코드 사이의 다리 역할을하며 보다 효율적으로 실행됩니다.\n\n## 3. TurboFan 컴파일러\n\nTurboFan은 V8의 최적화 컴파일러입니다. 이는 Ignition에서 생성된 바이트 코드를 고도로 최적화 된 머신 코드로 컴파일합니다. 따라서 TurboFan은 런타임 피드백을 기반으로 여러 최적화를 수행하여 더 높은 성능을 제공하기 위해 함수 인라인화 및 죽은 코드 제거 등의 최적화를 더 고급 수준에서 수행합니다.\n\n# 자세한 V8 아키텍처\n\n<div class=\"content-ad\"></div>\n\n## 1. 파싱\n\n자바스크립트 코드를 실행하기 전에 V8 파서가 동작합니다. 파싱은 소스 코드를 추상 구문 트리 (AST) 구조로 변환하는 과정으로, 소스 코드의 구문을 유지합니다.\n\n![이미지](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_1.png)\n\n이는 사람이 읽을 수 있는 코드를 엔진이 올바르고 효과적으로 사용할 수 있도록 만들기 때문입니다. V8는 JavaScript를 해석하지 않습니다. V8와 같은 엔진에서 제대로 실행되려면 이 형태여야 합니다.\n\n<div class=\"content-ad\"></div>\n\nAST는 여러 이유로 필수입니다:\n\n- 코드 이해: 소스 코드의 구조화된 트리 형태 표현은 V8가 코드를 더 쉽게 이해하고 조작할 수 있도록 돕습니다.\n- 최적화: V8의 이 측면은 상수 폴딩, 죽은 코드 제거, 또는 함수 인라인 등의 다양한 최적화 기술을 적용하여 더 나은 성능을 지원합니다.\n- 도구 및 분석: JavaScript 코드를 분석하고 변환하여 개발 도구가 효율적이고 유지보수 가능한 코드를 작성할 수 있도록 돕습니다.\n\n다음 JavaScript 코드를 참고하십시오:\n\n```js\nconst chk = \"have it\";\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드는 다음과 같이 시각적으로 AST로 구문 분석됩니다:\n\n\n![image](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_2.png)\n\n\n## 2. 바이트 코드 생성 (Ignition)\n\n\n![image](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_3.png)\n\n\n<div class=\"content-ad\"></div>\n\nAST가 형성되면 Ignition은 이를 바이트코드로 컴파일합니다. 바이트코드는 원래의 JavaScript 소스보다 더 빠르게 실행되는 중간 코드 표현입니다. Ignition은 이 바이트코드를 계속 실행하여 V8의 최적화 컴파일러 TurboFan 내에서 효과적인 최적화를 위해 필요한 런타임 정보를 수집할 수 있게 합니다.\n\nIgnition은 V8와 JavaScript 함수를 짧고 매우 최적화된 바이트코드로 컴파일합니다. 이 바이트코드는 동등한 기본 기계 코드의 크기의 50~25% 사이입니다. 그런 다음 이 바이트코드는 고성능 인터프리터에 의해 실행되어 실제 웹사이트에서 V8의 기본 컴파일러가 생성한 코드에 근접한 실행 속도를 제공합니다.\n\nAST를 바이트코드로 변환하는 과정은 다음과 같습니다:\n\n- Traversal: Ignition은 AST를 통과하며 각 노드를 방문하여 해당하는 바이트코드 명령을 생성합니다.\n- 명령어 집합: 바이트코드는 V8에서 실행을 위해 최적화된 명령어 집합으로 구성됩니다.\n- 효율성: 바이트코드는 더 작고 더 효율적이므로 고수준 JavaScript 코드를 실행하는 것보다 더 빠르게 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n바이트코드 생성 후에 Ignition이 실행을 시작합니다. 이는 몇 가지 이유로 매우 중요한 실행 단계입니다:\n\n- 런타임 정보: Ignition은 바이트코드를 실행하는 동안 자주 호출되는 함수나 자주 액세스되는 속성 등의 런타임 정보를 수집합니다. 이 정보는 더 많은 최적화를 수행하는 데 매우 중요합니다.\n- 빠른 시작: Ignition은 원래 JavaScript 대신 바이트코드를 실행하므로 시작 속도가 더 빨라집니다. 빠른 시작은 사용자에게 즉시 반응해야 하는 앱에 대해 굉장히 중요합니다, 특히 브라우저나 서버 공간에서.\n\n바이트코드가 생성된 후 인라인 최적화를 거칩니다. 이러한 최적화는 코드의 바이트 스트림에서 단순 분석을 수행하며 일반적인 패턴을 더 빠른 시퀀스로 대체하고 중복된 작업을 제거하며 불필요한 레지스터로드 및 전송을 최소화합니다. 이러한 최적화는 바이트 코드의 크기를 줄이고 성능을 향상시킵니다. Ignition이 바이트코드를 실행하는 동안 캡처된 모든 정보는 최적화 단계에서 매우 중요합니다. 이에는 가장 자주 호출되는 함수, 반복적으로 액세스되는 속성, 그리고 서로 다른 객체가 사용되는 방식 등이 포함됩니다.\n\n## 3. 최적화 (TurboFan)\n\n<div class=\"content-ad\"></div>\n\n```html\n<img src=\"/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_4.png\" />\n```\n\nTurboFan는 JavaScript를 더 효율적으로 최적화된 기계 코드로 생성하기 위해 설계되었습니다. 이는 오래된 CrankShaft JIT 컴파일러를 대체하고 훨씬 더 복잡한 최적화를 제공합니다. TurboFan을 위한 두 가지 중요한 혁신은 중간 표현(IR) 사용과 다중 계층 최적화 파이프라인을 이용하는 것입니다.\n\n## TurboFan 작동 방식\n\n## 1. JavaScript에서 IR(Intermediate Representation)로\n\n<div class=\"content-ad\"></div>\n\nJavaScript 코드가 실행되면 먼저 AST가 파생됩니다. 그런 다음 TurboFan은 이 AST를 더 유연한 IR 구조로 변환하는데, 이를 \"노드의 바다\"라고 합니다. 이는 그래프 기반 IR이며, 따라서 TurboFan에서는 연산 간 복잡한 관계를 표현함으로써 많은 최적화를 수행할 수 있습니다.\n\n## 2. 최적화\n\nTurboFan 컴파일러는 IR에 여러 고급 최적화를 적용합니다:\n\n- 숫자 범위 분석: 이것은 TurboFan이 숫자 연산을 올바르게 이해하고, 불필요한 체크를 줄여 더 효율적으로 만듭니다.\n- 제어 흐름 최적화: 코드를 재배치하고 불필요한 명령을 제거하여, 루프 밖에서 자주 실행되지 않는 경로로 코드를 이동합니다.\n- 인라인 캐싱: 첫 번째 참조 후 객체 유형 및 속성을 캐싱하여 속성 액세스 속도를 높이며, 반복 액세스 시 유형 검사 및 찾아보기를 우회합니다.\n- 숨겨진 클래스: 숨겨진 클래스를 제공하여 객체의 속성 액세스를 매우 효율적으로 만들며, 속성이 추가될 때 객체를 변환합니다. 메모리 레이아웃을 예측하고 예측을 바탕으로 최적화된 코드를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. IR(Intermediate Representation)에서 머신 코드로\n\nTurboFan은 최적화된 IR을 가져와 머신 코드를 생성합니다. 이것은 CPU가 직접 실행하는 저수준 코드입니다. x86, ARM 및 MIPS와 같은 여러 하드웨어 아키텍처에서 효율적으로 실행되도록 코드를 만들기 위해 여러 컴파일 단계가 필요합니다.\n\nTurboFan의 컴파일은 다음 단계로 진행됩니다:\n\n- 명령 선택: TurboFan은 IR의 고수준 작업을 특정 머신 명령에 매핑합니다. 이 단계에서 생성된 코드가 대상 아키텍처의 명령 집합을 활용하도록 보장합니다.\n- 레지스터 할당: TurboFan은 변수에 대한 CPU 레지스터를 할당하여 메모리 접근을 최소화하고 그 과정에서 실행 시간을 가속화합니다. 사용 패턴 및 가용성에 따라 변수 저장을 위한 최상의 레지스터를 선택합니다.\n- 코드 생성: 이것이 이전 단계에서의 모든 최적화 및 적응을 포함한 결과 머신 코드일 것입니다. 따라서 이것이 CPU가 실행하는 실제 머신 코드입니다.\n\n<div class=\"content-ad\"></div>\n\n런타임 시, V8은 자바스크립트 코드 동작을 모니터링하여 자주 호출되는 함수 및 자주 액세스되는 속성에 대한 데이터를 수집합니다. 이 런타임 프로파일링을 통해 TurboFan은 최적화된 핫 코드 경로를 결정하고 가능한 한 효율적인 기계 코드로 변환합니다.\n\n함수 인라인화는 TurboFan에 의해 수행되는 강력한 최적화입니다. 자주 호출되는 함수일 경우 TurboFan은 해당 함수를 인라인으로 바꾸어 함수 호출을 실제 함수 본문으로 대체함으로써 호출 오버헤드를 제거하고 성능을 향상시킬 수 있습니다.\n\n또한 TurboFan은 런타임 프로파일링을 사용하여 실행되지 않은 코드를 제거함으로써 죽은 코드를 제거합니다. 이러한 코드를 제거함으로써 TurboFan은 생성된 기계 코드의 크기를 줄이고 실행 속도를 향상시킵니다.\n\n## TurboFan의 중요성\n\n<div class=\"content-ad\"></div>\n\n- 성능: TurboFan의 정교한 최적화로 JavaScript 코드가 더 빠르게 실행됩니다. 이는 웹 응용 프로그램에서 응답성이 중요한 경우와 효율성이 확장성과 비용에 중요한 영향을 미치는 서버 측 응용 프로그램에서 모두 중요합니다.\n- 최신 JavaScript 기능 지원: TurboFan은 모든 최신 JavaScript 기능 (ES6 이상)을 지원하도록 설계되었습니다. 유연한 설계로 새로운 언어 기능을 추가할 때 많은 아키텍처별 코드를 다시 작성할 필요가 없습니다.\n- 유지 관리성: TurboFan의 계층화된 아키텍처는 고수준 및 저수준 최적화를 분리함으로써 컴파일러의 설계를 간단하게 하고 유지 관리 및 확장을 용이하게 합니다.\n\n## TurboFan의 계층화된 아키텍처\n\n컴파일러는 새로운 기능을 지원하고 최적화를 추가하며 다른 아키텍처를 대상으로 할수록 복잡해집니다. TurboFan의 계층화된 아키텍처는 JavaScript(소스 레벨 언어), VM 기능(V8), 아키텍처 세부 사항(예: x86, ARM, MIPS) 사이에 명확한 분리를 만들어 이러한 요구 사항을 효과적으로 해결합니다.\n\n이러한 분리로 인해 최적화 및 기능 구현 시 엔지니어가 지역적으로 사고할 수 있어 더 견고하고 유지 보수가 쉬운 코드를 작성할 수 있습니다. 계층화된 접근 방식은 플랫폼별 코드가 필요한 양을 줄입니다. TurboFan이 지원하는 일곱 가지 대상 아키텍처 각각은 CrankShaft의 13,000-16,000 줄에 비해 3,000 줄 미만의 플랫폼별 코드를 필요로 합니다. 이 간소화된 설계는 ARM, Intel, MIPS, IBM 등의 엔지니어가 더 효과적으로 기여할 수 있도록 했습니다.\n\n<div class=\"content-ad\"></div>\n\nTurboFan은 CrankShaft보다 더 강력한 최적화를 구현하는 여러 가지 고급 기술을 통해 성능을 향상시킵니다. JavaScript는 최적화되지 않은 형태로 컴파일러 파이프라인에 들어가며 점진적으로 번역되어 낮은 형태로 최적화됩니다. TurboFan의 핵심은 코드의 조합을 더 효과적으로 재정렬하고 최적화할 수 있는 내부 표현(IR)인 '노드 바다'입니다.\n\n- 수치 범위 분석: 이 기능을 통해 TurboFan은 숫자 연산 코드를 더 잘 이해하여 보다 정확한 최적화를 수행할 수 있습니다.\n- 그래프 기반 IR: 대부분의 최적화는 간단한 지역적 축소로 표현되어 코드 작성 및 독립적 테스트가 더 쉬워집니다. 최적화 엔진은 이러한 지역 규칙을 체계적으로 적용합니다.\n- 혁신적인 스케줄링 알고리즘: 이 알고리즘은 코드를 루프에서 이탈하여 덜 자주 실행되는 경로로 이동할 수 있는 재정렬 자유도를 활용합니다.\n- 아키텍처별 최적화: 각 대상 플랫폼의 기능을 활용한 복잡한 명령 선택은 최상의 품질 코드를 생성합니다.\n\n## 현대 JavaScript 기능 지원\n\nTurboFan은 ES5에서 사용 가능한 모든 JavaScript 기능을 최적화하기 위해 설계되었으며 ES2015 및 이후 계획된 기능을 수용합니다. 계층별 컴파일러 설계는 고수준 및 저수준 컴파일러 최적화 사이에 깔끔한 분리를 제공하여 새로운 언어 기능을 추가할 때 아키텍처별 코드를 변경하지 않고 간단화합니다. TurboFan은 명시적 명령 선택 컴파일 단계를 도입하여 아키텍처별 코드가 더 필요하지 않도록 하며 컴파일러를 모든 지원되는 아키텍처에서 유지 관리 및 확장 가능하도록 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 개념을 이해한다면, 개발자는 현대 JavaScript 엔진의 복잡성을 인지하고 V8의 기능을 완전히 활용하는 코드를 작성할 수 있습니다. TurboFan의 혁신과 최적화는 V8 엔진의 필수 구성 요소로, 오늘날과 미래의 JavaScript 애플리케이션의 성능과 효율성을 촉진합니다.\n\n## 상세한 디옵티마이제이션\n\n디옵티마이제이션은 V8 엔진의 중요한 기능으로, 초기 가정이 변경되더라도 코드 실행이 올바른 상태로 유지되도록 보장합니다. 이것은 다음과 같은 과정을 포함합니다:\n\n- 모니터링: V8는 최적화된 머신 코드의 실행을 지속적으로 모니터링합니다.\n- 디옵티마이제이션 트리거: 런타임 환경이 변경되면(새로운 객체 유형을 만나거나 예상치 못한 실행 경로를 만나면), V8는 디옵티마이제이션의 필요성을 인식합니다.\n- 바이트코드로 되돌리기: V8는 그런 다음 Ignition에 의해 생성된 일반 바이트코드로 실행을 되돌립니다. 이는 안전하며 무효화된 가정에 기반하지 않습니다.\n- 재최적화: 되돌린 후에 새로운 패턴이 나타난 경우, V8는 코드를 다시 최적화할 수 있으며, 필요에 따라 최적화와 디옵티마이제이션의 사이클을 계속합니다.\n\n<div class=\"content-ad\"></div>\n\n## V8 프로세스 흐름\n\n![V8 엔진 시리즈I 아키텍처](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_5.png)\n\n- 코드 로딩: 엔진은 JavaScript 또는 WebAssembly 코드를 로드하여 시작합니다.\n- 구문 분석: 구문 분석기가 소스 코드를 AST로 변환합니다.\n- AST 변환: AST가 처리되고 Ignition에 전달됩니다.\n- 바이트코드 생성: Ignition이 AST를 바이트코드로 컴파일합니다.\n- 초기 실행: Ignition이 바이트코드를 실행하여 빠른 시작과 실행 시간 정보 수집을 보장합니다.\n- 런타임 피드백: 자주 사용되는 코드 경로 및 기타 런타임 데이터에 대한 정보가 수집됩니다.\n- 피드백 레이어: 런타임 피드백을 분석하여 최적화 기회를 결정합니다.\n- 최적화: TurboFan은 피드백 레이어의 정보를 사용하여 바이트코드를 머신 코드로 최적화합니다.\n- 실행: 최적화된 머신 코드가 실행되어 효율적이고 빠른 성능을 제공합니다.\n- 비최적화: 런타임 조건이 변경되어 최적화된 코드가 무효화되면 V8은 올바른 상태를 유지하기 위해 보다 최적화되지 않은 버전으로 되돌아갑니다.\n\n요약하면, V8 엔진의 아키텍처는 오늘날의 웹 애플리케이션에 중요한 빠른 시작과 고속 실행이 결합된 것을 보여줍니다. V8의 구성 요소와 상호 작용을 이해하면 엔진의 기능에 대한 소중한 통찰력을 제공받아 효율적이고 고성능의 JavaScript 코드를 작성하며 이 정교한 엔진의 가능성을 최대한 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사를 읽어 주셔서 감사합니다. 유익하고 흥미로운 내용이었기를 바랍니다. 이 시리즈에서 더 많은 내용이 기대되니 기대해 주세요.\n\n![image](/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_6.png)\n\n질문이나 의견이 있으시면 언제든지 말씀해 주세요! 도와드리기 위해 언제나 준비되어 있으며 여러분의 생각을 듣고 싶습니다. 😊","ogImage":{"url":"/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_0.png"},"coverImage":"/assets/img/2024-06-20-TheV8EngineSeriesIArchitecture_0.png","tag":["Tech"],"readingTime":9},{"title":"HMPL  API를 통해 HTML을 가져오는 새로운 템플릿 언어","description":"","date":"2024-06-20 03:41","slug":"2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI","content":"\n\n\n![이미지](/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_0.png)\n\n이 글에서는 HMPL이라고 불리는 새로운 템플릿 언어에 대해 이야기하겠습니다. 이 언어를 사용하면 API에서 HTML을 쉽게 불러올 수 있어 굉장히 많은 불필요한 코드를 줄일 수 있습니다.\n\nhmpl.js의 주요 목표는 작은 요청 구조를 HTML에 통합하여 서버 작업을 간단하게 만드는 것입니다. 이는 php 확장자가 있는 파일에서 php 요청을 통해 서버로부터 받은 응답을 처리하는 방식과 비교될 수 있지만 동시에 javascript를 통해 직접적으로 처리할 수 있는 방법을 제공합니다. 단순히 버튼에서 제목을 가져오는 예를 통해 이 템플릿 언어가 귀하의 작업을 단순화할 수 있는 방법을 이해할 수 있습니다.\n\n이 템플릿 언어를 이용하면 지정된 문자열 템플릿을 반복할 수 있습니다. 코드로 표현하면 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { compile } from \"hmpl-js\";\nconst templateFn = compile(\n   `<div>\n     <request src=\"/api/test\"></request>\n   </div>`\n);\n\nconst wrapper = document.getElementById(\"wrapper\");\nconst obj1 = templateFn();\n\nconst obj2 = templateFn();\n\nwrapper.appendChild(obj1.response);\nwrapper.appendChild(obj2.response);\n```\n\n이 모듈은 최신 JS 도구를 사용하여 서버와 작업할 수 있도록 fetch API에 기반을 둔 것입니다.\n\nfetch API와 상호작용하려면 RequestInit 유형을 기반으로 한 설정 객체도 생성되었습니다. 예시 코드:\n\n```js\nconst elementObj = templateFn({\n  method: \"POST\",\n  mode: \"cors\",\n  cache: \"no-cache\",\n  credentials: \"same-origin\",\n  headers: {\n    \"Content-Type\": \"text/html\",\n  },\n  redirect: \"follow\",\n  get: (prop, value) => {},\n  referrerPolicy: \"no-referrer\",\n  body: JSON.stringify(data),\n  signal: new AbortController().signal,\n  integrity: \"…\",\n  window: null,\n  refferer: \"about:client\",\n});\n```\n\n<div class=\"content-ad\"></div>\n\n템플릿 언어의 구문 자체로 .hmpl 확장자 파일을 사용하여 실용적이고 이해하기 쉬운 프로젝트 파일 구조를 만들고 일반 HTML과 \"모듈화된\" HTML을 분리하는 것이 가능합니다.\n\n![이미지](/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_1.png)\n\n해당 모듈은 매우 작은 크기입니다 (버전 1.0.9). npm에서 100킬로바이트 미만을 차지합니다. 미니파이된 파일 자체도 더욱 가벼워집니다.\n\n![이미지](/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_2.png)\n\n<div class=\"content-ad\"></div>\n\n아래는 작업을 더욱 쉽게 수행할 수 있는 여러 연결 옵션이 있는 모듈입니다:\n\n```js\n<script src=\"https://unpkg.com/hmpl-js/dist/hmpl.min.js\"></script>\n```\n\n또는\n\n```js\n{\n  \"dependencies\": {\n    \"hmpl-js\": \"latest\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n웹팩 구성 파일\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.hmpl$/i,\n        use: [\"hmpl-loader\"],\n      }\n    ]\n  }\n}\n```\n\n모듈에 대한 간단한 프로젝트 예시:\n\n<div class=\"content-ad\"></div>\n\nhttps://github.com/hmpljs/examples\n\n다른 유용한 링크:\n\n- https://hmpljs.github.io\n- https://github.com/hmpljs/hmpl-loader\n- https://github.com/hmpljs/hmpl\n- https://www.youtube.com/@antonmak1\n\n이 모듈에 관심이 있으시다면 댓글에 여러분의 의견을 남겨주시면 멋질 것 같아요 :). 이 기사를 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_0.png"},"coverImage":"/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_0.png","tag":["Tech"],"readingTime":3},{"title":"SwiftUI에서 HTML 렌더링하기","description":"","date":"2024-06-20 03:39","slug":"2024-06-20-RenderHTMLinSwiftUI","content":"\n\n## NSAttributedString, UITextView 및 UIViewRepresentable를 사용하여 SwiftUI에서 HTML 렌더링하기.\n\n![이미지](/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png)\n\nSwiftUI는 멋지지만 여전히 기능이 부족한 것이 많습니다. 몇 년간 UIKit을 사용한 후 익숙해진 기능이죠. 그 중 하나는 NSAttributedString 및 UITextView를 사용하여 간단한 HTML 텍스트를 렌더링할 수 있는 기능입니다.\n\n이 글에서는 SwiftUI를 UIViewRepresentable을 사용하여 UIKit과 연결하고, HTML을 렌더링하는 사용자 정의 SwiftUI View를 만드는 방법을 간단히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n업데이트: 원본 기사 개선 사항\n\n이 기사의 원본 버전에서는 NSAttributedString을 사용하여 HTML을 스타일링하고 렌더링하는 데 특화된 간단한 사용자 정의 SwiftUI 뷰를 만드는 방법에 대해 살펴보았습니다. 이 기사에서는 AttributedText 뷰도 언급되었습니다. 그러나 이로 인해 이상한 동작이 발생했는데, 아직 적절한 해결책을 찾지 못했습니다. 따라서 이 기사의 업데이트된 버전에서는 HTML 뷰를 제거하고 NSAttributedString에 대한 편리한 확장 기능이 몇 가지 추가되었습니다. 나는 이상한 동작에 대한 더 나은 이해를 얻기 위해 Apple 개발자 포럼과 스택 오버플로에 게시했습니다.\n\n## 주요 포인트\n\n- UIViewRepresentable 프로토콜을 사용하여 UIKit 뷰를 SwiftUI 뷰 계층구조에 포함할 수 있습니다.\n- NSAttributedString (UITextView를 통해)의 강력한 기능을 노출할 수 있으며, 현재 SwiftUI 세계에는 동등한 것이 없습니다 (하지만 AttributedString는 좋은 후보일 수 있음).\n- 스타일이 지정된 HTML 형식의 NSAttributedStrings는 UIViewRepresentable에 의해 관리되는 UITextView에 의해 렌더링될 수 있습니다. HTML 형식의 텍스트에서 일부 CSS 스타일 속성을 인라인으로 정의하거나 HTML 형식의 텍스트의 전용 스타일 태그로 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서 사용된 완성된 예제 코드는 GitHub에서 찾을 수 있어요: https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML.\n\n# 커스텀 UIViewRepresentable\n\nSwiftUI가 처음 발표됐을 때는 기존 UIKit 뷰를 SwiftUI 뷰 계층구조에 임베드할 수 있도록 하는 API도 함께 제공되었습니다. 개발자들에게 UIKit에서 SwiftUI로의 전환이 쉬워졌어요.\n\n이러한 API 중 하나는 UIViewRepresentable 프로토콜인데요, SwiftUI의 컨텍스트에서 UIKit 뷰를 관리하는 데 사용돼요. Apple은 이 프로토콜과 다른 SwiftUI와 UIKit을 연결하는 프로토콜을 통해 이를 통한 가능성을 보여주는 멋진 WWDC 비디오를 제공했어요. 적어도 'Integrating SwiftUI'를 확인해보시기를 권해요.\n\n<div class=\"content-ad\"></div>\n\n## AttributedText\n\nNSAttributedString은 텍스트 문자열을 강력하게 관리하는 도구로, 텍스트 문자열의 문자 범위를 스타일링하는 강력한 방법을 제공합니다. 심지어 간단한 HTML에 따라 텍스트를 스타일링할 수도 있습니다.\n\nNSAttributedString을 스타일링된 상태로 초기화하려면 NSAttributedString.init(data:options:documentAttributes:) 이니셜라이저에 .documentType 옵션을 .html로 설정한 HTML 문자열(데이터 형식으로)을 전달하면 됩니다. 그리고 UITextView와 함께 사용하여 앱에서 HTML을 렌더링할 수 있습니다!\n\nUIViewRepresentable 프로토콜을 사용하여 NSAttributedString 및 UITextView의 기능을 SwiftUI에 사용되는 사용자 지정 AttributedText View로 노출시킬 것입니다!\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct AttributedText: UIViewRepresentable {\n    private let attributedString: NSAttributedString\n\n    init(_ attributedString: NSAttributedString) {\n        self.attributedString = attributedString\n    }\n\n    func makeUIView(context: Context) -> UITextView {\n        // SwiftUI이 이 \"View\"를 렌더링하는 첫 번째 시간에 호출됩니다.\n\n        let uiTextView = UITextView()\n\n        // 배경 뷰가 반짝일 수 있도록 투명하게 만듭니다.\n        uiTextView.backgroundColor = .clear\n\n        // 텍스트 시각화만을 위한 것이므로 편집되지 않도록 합니다.\n        uiTextView.isEditable = false\n\n        // UITextView를 가능한 너비에 맞게 유연하게 만들지만, 콘텐츠에 맞는 높이를 요구합니다.\n        // 또한 UITextView가 스크롤되지 않게 하여 UITextView가 텍스트 콘텐츠와 일치하도록 `intrinsicContentSize`를 설정합니다.\n        uiTextView.isScrollEnabled = false\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .vertical)\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .horizontal)\n        uiTextView.setContentCompressionResistancePriority(.required, for: .vertical)\n        uiTextView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n\n        return uiTextView\n    }\n\n    func updateUIView(_ uiTextView: UITextView, context: Context) {\n        // SwiftUI이 이 UIViewRepresentable을 처음 렌더링하는 시간과 상태 변경에 대해 알림을 받을 때마다 호출됩니다. (예: @State 변수를 통해)\n        uiTextView.attributedText = attributedString\n    }\n}\n```\n\nUIViewRepresentable로 위에서 정의한 AttributedText를 사용하여 SwiftUI 앱에서 NSAttributedStrings를 렌더링할 수 있습니다. HTML 형식의 텍스트로 초기화된 NSAttributedStrings를 렌더링하는 것이 주된 목표이므로 NSAttributedString에 대한 편의 생성자를 만듭니다.\n\n```swift\nimport UIKit\n\nextension NSAttributedString {\n    static func html(withBody body: String) -> NSAttributedString {\n        // 앱에서 사용되는 현재 로케이션과 일치하는 HTML `lang` 속성을 매치합니다. (즉, Bundle.main)\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            <!doctype html>\n            <html lang=\"\\(lang)\">\n            <head>\n                <meta charset=\"utf-8\">\n                <style type=\"text/css\">\n                    /*\n                      HTML 형식의 텍스트에 대한 사용자 정의 CSS 스타일 지정\n                      주의: NSAttributedString/UITextView에서 지원하는 CSS 기능은 제한적입니다.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(UIColor.secondaryLabel.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(UIColor.label.hex);\n                    }\n\n                    a {\n                        color: \\(UIColor.systemGreen.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                </style>\n            </head>\n            <body>\n                \\(body)\n            </body>\n            </html>\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// UIColor를 CSS 친화적인 색상 헥스 문자열로 변환\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(&red, green: &green, blue: &blue, alpha: &alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nNSAttributedString은 일부 CSS 기능을 지원합니다 (안타깝게도 어딘가 제대로 문서화되지 않은 기능들이 있습니다), 하지만 인라인 및 별도의 태그 내에서 스타일을 정의하는 것이 가능합니다 (일반적으로 HTML head 태그의 일부로).\n\n## SwiftUI에서 HTML 렌더링하기\n\n그런 다음, 우리는 AttributedText UIViewRepresentable을 사용하여 NSAttributedString 편리한 초기화자를 함께 사용하여 SwiftUI 앱에서 HTML을 렌더링할 수 있습니다 - 심지어 인라인 스타일링도 가능합니다!\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.html(withBody: \"\"\"\n                <h3>This is a H3 header</h3>\n                <p>This is a paragraph</p>\n                <ul>\n                    <li>List item one</li>\n                    <li>List item two</li>\n                </ul>\n                <p>This is a paragraph with a <a href=\"https://developer.apple.com/\">link</a></p>\n                <p style=\"color: blue; text-align: center;\">\n                    This is a paragraph with inline styling\n                </p>\n                \"\"\"))\n                .padding()\n            }\n            .navigationTitle(\"Render HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 보너스: 테마별 HTML 렌더링\n\n만약 앱이 (색상) 테마 개념을 사용하여 앱 전반에 대한 색상 정보 등을 전파한다면, 현재 테마 정보를 기반으로 HTML을 스타일링할 수도 있습니다.\n\n사용자 정의 테마 환경 값과 다른 NSAttributedString 편의 이니셜라이저를 사용하면 다음과 같이 보일 수 있습니다:\n\n사용자 정의 테마 환경 값\n\n<div class=\"content-ad\"></div>\n\n다음은 Markdown 형식으로 테이블 태그를 변경한 코드입니다.\n\n\nimport SwiftUI\n\n// Example of a simple Theme struct.\nstruct Theme {\n    let textPrimary: UIColor\n    let textSecondary: UIColor\n    let textInteractive: UIColor\n}\n\nextension Theme {\n    static let `default` = Theme(\n        textPrimary: .label,\n        textSecondary: .secondaryLabel,\n        textInteractive: .systemGreen\n    )\n}\n\nprivate struct ThemeEnvironmentKey: EnvironmentKey {\n    static var defaultValue: Theme = .default\n}\n\nextension EnvironmentValues {\n    var theme: Theme {\n        get { self[ThemeEnvironmentKey.self] }\n        set { self[ThemeEnvironmentKey.self] = newValue }\n    }\n}\n\n\nNSAttributedString을 위한 편리한 이니셜라이저\n\n\nimport UIKit\n\nextension NSAttributedString {\n    static func themedHtml(withBody body: String, theme: Theme = .default) -> NSAttributedString {\n        // Match the HTML `lang` attribute to current localisation used by the app (aka Bundle.main).\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            <!doctype html>\n            <html lang=\"\\(lang)\">\n            <head>\n                <meta charset=\"utf-8\">\n                <style type=\"text/css\">\n                    /*\n                      Custom CSS styling of HTML formatted text.\n                      Note, only a limited number of CSS features are supported by NSAttributedString/UITextView.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(theme.textSecondary.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(theme.textPrimary.hex);\n                    }\n\n                    a {\n                        color: \\(theme.textInteractive.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                </style>\n            </head>\n            <body>\n                \\(body)\n            </body>\n            </html>\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// MARK: Converting UIColors into CSS friendly color hex string\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(&red, green: &green, blue: &blue, alpha: &alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n\n\nSwiftUI에서 테마가 적용된 HTML 렌더링하기\n\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @Environment(\\.theme) private var theme: Theme\n\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.themedHtml(withBody: \"\"\"\n                <h3>This is a H3 header</h3>\n                <p>This is a paragraph</p>\n                <ul>\n                    <li>List item one</li>\n                    <li>List item two</li>\n                </ul>\n                <p>This is a paragraph with a <a href=\"https://developer.apple.com/\">link</a></p>\n                <p style=\"color: blue; text-align: center;\">\n                    This is a paragraph with inline styling\n                </p>\n                \"\"\", theme: theme))\n                .padding()\n            }\n            .navigationTitle(\"Render Themed HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n## 이게 다야!\n\n쉽죠! SwiftUI가 정말 멋지지만, 때로는 몇 년 동안 사랑해 온 UIKit 뷰와 기능을 임베드할 수 있는 것이 참 좋습니다.\n\n코딩하세요! 🙌\n","ogImage":{"url":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png"},"coverImage":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png","tag":["Tech"],"readingTime":12},{"title":"프런트엔드 웹 개발에서 초보자의 여정","description":"","date":"2024-06-20 03:37","slug":"2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment","content":"\n\n![2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png](/assets/img/2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png)\n\n안녕하세요, 야망 넘치는 웹 개발자 여러분! 프론트엔드 개발 세계에 막 발을 딛으셨거나 기본기를 다듬는 중이라면, 여기서 잘 왔습니다. 지난 주에 '바이트와이즈 프론트엔드 펠로우십'의 일환으로 HTML 기초를 깊이 있게 탐구하고 있는데요. 오늘은 제 경험을 공유하려고 해요. 그동안 얻은 통찰, 조언, 그리고 도움이 된 자료들을 함께 나누어 드리겠습니다.\n\n따라서, 초보자이신 분들이든 프론트엔드 개발에 관심이 있는 분들이든, 제가 지금까지 배운 것을 함께 살펴보도록 합시다.\n\n# 프론트엔드 개발이란?\n\n<div class=\"content-ad\"></div>\n\n집을 짓는다고 상상해보세요. 건축가가 청사진을 설계하고 시공 스탭이 벽돌을 쌓으며, 그리고 인테리어 디자이너가 색상, 질감 및 가구로 비전을 구현하는 과정을 생각해보세요. 디지털 세계에서 프론트엔드 개발은 바로 그 인테리어 디자이너와 같습니다. 이는 사용자가 직접 상호 작용하는 웹 어플리케이션의 일부를 만드는 것으로, HTML, CSS, JavaScript와 같은 언어를 사용하여 정적 디자인을 동적이고 매력적인 인터페이스로 변환하는 작업을 포함합니다.\n\n## HTML: 웹 페이지의 기초\n\nHTML은 웹 페이지의 뼈대인 Hypertext Markup Language의 줄임말입니다. 다른 모든 것이 의존하는 프레임워크로 생각할 수 있습니다. HTML을 사용하여 텍스트, 이미지, 링크 등을 표시하기 위해 태그를 사용하여 웹 페이지의 구조와 내용을 정의합니다. 예를 들어:\n\n- `h1`은 제목을 생성합니다.\n- `p`는 단락을 나타냅니다.\n- `img src=\"image.jpg\"`는 이미지를 삽입합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n    <title>내 첫 번째 웹 페이지</title>\n</head>\n<body>\n    <h1>내 웹 사이트에 오신 것을 환영합니다!</h1>\n    <p>이것은 하나의 문단입니다.</p>\n    <img src=\"welcome-image.jpg\" alt=\"환영 이미지\">\n</body>\n</html>\n```\n\n## CSS: 웹 디자인의 스타일러\n\nHTML은 콘텐츠를 구조화하는 반면, CSS(Cascading Style Sheets)은 그것을 잘 꾸미는 역할을 합니다. CSS에서는 색상, 글꼴, 레이아웃 및 애니메이션을 적용하여 평범한 HTML 문서를 시각적으로 멋진 웹 페이지로 만들어줍니다. CSS를 영화의 의상 부서로 상상해보세요; 모든 장면이 정확히 보이도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n```js\nbody {\n    background-color: lightblue;\n}\n\nh1 {\n    color: navy;\n    margin-left: 20px;\n}\n```\n\n# JavaScript: 상호 작용의 마법사\n\n자바스크립트는 웹 페이지에 생명을 불어넣어주는 마법과 같습니다. 상호 작용, 양식 제출, 애니메이션 등을 가능하게 합니다. 자바스크립트 없이는 웹 페이지가 정적이고 반응하지 않는 상태가 됩니다. 그것은 도시에 전기를 공급하는 것과 같습니다; 갑자기 모든 것이 밝아지고 기능적으로 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n```js\ndocument.querySelector('button').addEventListener('click', function() {\n    alert('버튼이 클릭되었습니다!');\n});\n```\n\n# 프론트엔드 개발 해양 항해\n\n프론트엔드 개발 분야에서의 경력은 거대한 바다를 항해하는 것과 같습니다. 여기에 몇 가지 항해 보조 도구가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 기초 학습: HTML, CSS, 그리고 JavaScript부터 시작하세요. W3Schools, Codecademy, Udemy와 같은 다양한 온라인 자원들이 포괄적인 안내서와 자습서를 제공합니다.\n- 꾸준한 연습: 코딩은 반복을 통해 향상되는 기술입니다. 배운 것을 강화하기 위해 작은 프로젝트를 만들어보세요.\n- 커뮤니티 참여: Stack Overflow, GitHub, Reddit와 같은 플랫폼에서 동료 학습자 및 전문가들과 소통하세요. 지식 공유와 조언 요청은 성장을 가속화할 수 있습니다.\n- 호기심 유지: 기술은 빠르게 진화합니다. 경쟁력을 유지하기 위해 새로운 도구, 프레임워크, 최상의 실천법에 대해 계속해서 알아두세요.\n\n# 나의 바이트위즈 펠로우십 모험\n\n## 🗓️ 제 1일: 툴킷 설정하기\n\n코딩에 뛰어들기 전에 올바른 도구와 자원을 설정하는 것이 중요합니다. 첫 날 우리가 한 것은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n## 설정할 계정:\n\n- LinkedIn: 전문가들과 연결하고 성장 과정을 공유하세요.\n- Twitter: 기술 인플루언서를 팔로우하고 여정을 공유하세요.\n- GitHub: 프로젝트를 호스팅하고 다른 사람과 협업하세요.\n- Medium: 학습 경험에 대한 기사를 쓰고 공유하세요.\n- Google Drive: 일일 회의와 프로젝트 파일을 정리하세요.\n\n## 학습 자료:\n\n- 동영상: 프론트엔드 개발자 로드맵 2024 또는 대체 동영상\n- 기사: 초심자 프론트엔드 개발자의 교훈\n\n<div class=\"content-ad\"></div>\n\n# 🗓️ Day 2: 필수 프론트엔드 스킬\n\n강력한 기반을 구축하는 것이 중요합니다. 오늘은 프론트엔드 개발을 올바르게 학습하는 방법에 중점을 두었습니다.\n\n## 학습 자료:\n\n- 비디오: 올바른 방법으로 프론트엔드 개발 학습하기\n- 비디오: 2배 빨리 프론트엔드 개발 배우기\n\n<div class=\"content-ad\"></div>\n\n# 🗓️ 3일차: HTML 기초\n\nHTML (하이퍼텍스트 마크업 언어)는 모든 웹사이트의 기초입니다. 모든 것을 함께 유지하는 뼈대로 생각해보세요.\n\n## 학습 자료:\n\n- 비디오 튜토리얼: HTML 기본 태그\n\n<div class=\"content-ad\"></div>\n\n## 중요 개념:\n\n- 제목: `h1`부터 `h6`까지 사용하여 제목을 정의합니다.\n- 문단: `p` 태그는 문단을 만듭니다.\n- 리스트: 순서가 있는 목록에는 `ol`을, 순서가 없는 목록에는 `ul`을 사용합니다.\n- 링크: `a` 태그는 하이퍼링크를 만듭니다. 예시:\n\n```js\n<a href=\"https://www.bytewise.com\">바이트와이즈 방문하기</a>\n```\n\n- 이미지: `img` 태그는 이미지를 삽입합니다. 예시:\n\n<div class=\"content-ad\"></div>\n\n\n![Description of Image](path/to/image.jpg)\n\n\n# 🗓️ Day 4: HTML Semantic Tags\n\n시맨틱 HTML 태그는 웹 콘텐츠에 의미를 부여하여 콘텐츠를 더 접근 가능하고 유지 보수하기 쉽게 만듭니다.\n\n## 학습 자료:\n\n<div class=\"content-ad\"></div>\n\n- 비디오 자습: HTML 시맨틱 요소\n\n## 주요 개념:\n\n- `header`: 페이지의 헤더 섹션을 정의합니다.\n- `nav`: 내비게이션 링크를 포함합니다.\n- `article`: 글을 나타냅니다.\n- `section`: 문서 내에서 섹션을 정의합니다.\n\n## 예시:\n\n<div class=\"content-ad\"></div>\n\n\n# 🗓️ Day 5: HTML 미디어 태그\n\n미디어 태그를 사용하면 비디오, 오디오 및 기타 멀티미디어 요소를 웹 페이지에 삽입하여 사용자 경험을 향상시킬 수 있습니다.\n\n## 학습 자료:\n\n\n<div class=\"content-ad\"></div>\n\n- 비디오 튜토리얼: HTML 미디어 요소\n\n## 주요 개념:\n\n- 비디오: `video` 태그는 비디오 파일을 임베드합니다. 예시:\n\n```js\n<video controls>\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  브라우저가 비디오 태그를 지원하지 않습니다.\n</video>\n```\n\n<div class=\"content-ad\"></div>\n\n- Audio: `audio` 태그는 오디오 파일을 임베드합니다. 예시:\n\n```js\n<audio controls>\n  <source src=\"sound.mp3\" type=\"audio/mpeg\">\n  //브라우저가 오디오 태그를 지원하지 않습니다.\n</audio>\n```\n\n- iFrame: `iframe` 태그는 외부 콘텐츠를 임베드합니다. 예시:\n\n```js\n<iframe src=\"https://www.example.com\" width=\"600\" height=\"400\"></iframe>\n```\n\n<div class=\"content-ad\"></div>\n\n# 📝 결론: 앞으로의 여정\n\n프론트엔드 개발을 배우는 것은 흥미진진한 모험을 떠나는 것과 같습니다. 매일 새로운 도전과 성장의 기회가 찾아옵니다. 여러분이 여정을 계속할 때 기억해야 할 몇 가지 팁이 있습니다:\n\n- 꾸준한 연습: 코드를 많이 작성할수록 능력이 향상됩니다.\n- 호기심을 유지하라: 늘 새로운 것을 배우고 다양한 자료를 탐험하려고 노력하세요.\n- 커뮤니티 지원을 찾아라: 포럼에 가입하거나 웨비나에 참석하고 다른 개발자와 소통하세요.\n\nHTML, CSS, JavaScript의 기본을 마스터하면 멋진 웹사이트를 만들고 숙련된 프론트엔드 개발자가 될 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사가 도움이 되었다면, 더 많은 웹 개발 팁과 통찰을 얻기 위해 LinkedIn과 Twitter에서 저를 팔로우해 주세요. 아래 댓글에 여러분의 경험과 배운 교훈을 공유해 주시기를 환영합니다.\n\n성공의 열쇠는 끈기와 학습에 대한 사랑입니다.\n\n즐거운 코딩하세요! 😊🌸✨","ogImage":{"url":"/assets/img/2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png"},"coverImage":"/assets/img/2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png","tag":["Tech"],"readingTime":6}],"page":"36","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}