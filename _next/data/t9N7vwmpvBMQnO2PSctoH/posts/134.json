{"pageProps":{"posts":[{"title":"Nextjs에서 Tailwind CSS와 Styled Components를 사용하여 멋진 UI 구축하기","description":"","date":"2024-05-12 20:36","slug":"2024-05-12-BuildingBeautifulUIwithTailwindCSSandStyledComponentsinNextjs","content":"\n\n![이미지](/assets/img/2024-05-12-BuildingBeautifulUIwithTailwindCSSandStyledComponentsinNextjs_0.png)\n\n매번 프로젝트마다 맞춤 CSS를 작성하기 지쳤나요? 빠르고 효율적으로 아름다운 UI를 구축하고 싶으신가요? 그렇다면 Tailwind CSS와 Styled Components in Next.js를 살펴보세요.\n\n# Tailwind CSS란?\n\nTailwind CSS는 유틸리티 우선 CSS 프레임워크로, CSS를 작성하지 않고도 맞춤 디자인을 신속하게 구축할 수 있도록 해줍니다. HTML 요소를 스타일링할 수 있는 미리 정의된 클래스 세트를 제공합니다. 예를 들어 요소에 padding을 추가하려면 단순히 p-4 클래스를 추가하면 됩니다.\n\n\n\n# Tailwind CSS의 장점\n\n- 빠른 프로토타이핑: Tailwind CSS를 사용하면 사용자 정의 CSS를 작성하지 않고 빠르게 디자인 프로토타입을 만들 수 있습니다. 이를 통해 많은 시간과 노력을 절약할 수 있습니다.\n- 일관된 디자인: Tailwind CSS는 일관된 디자인을 보장하는 사전 정의된 클래스 세트를 제공합니다. 이를 통해 일관된 룩앤필을 유지하는 데 도움을 줄 수 있습니다.\n- 사용자 지정 가능: Tailwind CSS를 사용자 정의할 수 있습니다. 사용자 정의 색상, 글꼴 및 간격을 구성에 추가할 수 있습니다.\n\n# Tailwind CSS의 단점\n\n- 학습 곡선: Tailwind CSS는 유틸리티-퍼스트 CSS 프레임워크에 익숙하지 않은 경우 학습 곡선이 가파를 수 있습니다. 구문 및 클래스 이름에 익숙해지는 데 시간이 걸릴 수 있습니다.\n- 코드 불필요: Tailwind CSS 사용은 요소를 스타일링하기 위해 여러 클래스를 추가해야 하므로 HTML 코드가 불필요하게 커질 수 있습니다. 이는 코드를 읽고 유지하기 어렵게 만들 수 있습니다.\n- 제한된 유연성: Tailwind CSS는 사전 정의된 클래스 세트를 제공하므로 디자인 사용자 정의 시 유연성이 제한될 수 있습니다. 특정 효과를 달성하기 위해 사용자 정의 CSS를 작성해야 할 수도 있습니다.\n\n\n\n# 스타일드 컴포넌트란 무엇인가요?\n\n스타일드 컴포넌트는 React용 라이브러리로, JavaScript 코드에서 CSS를 작성할 수 있게 해줍니다. 재사용 가능한 컴포넌트를 만들고 해당 컴포넌트에 고유한 스타일을 정의할 수 있는 방법을 제공합니다. 예를 들어, 버튼 컴포넌트를 만들고 스타일드 컴포넌트를 사용하여 해당 스타일을 정의할 수 있습니다.\n\n# 스타일드 컴포넌트의 장점\n\n- 재사용성: 스타일드 컴포넌트를 사용하면 고유한 스타일을 가진 재사용 가능한 컴포넌트를 만들 수 있습니다. 이로 인해 많은 시간과 노력을 절약할 수 있습니다.\n- 스코프된 스타일: 스타일드 컴포넌트는 스코프된 스타일을 제공하며, 이는 스타일이 정의된 컴포넌트에만 적용된다는 것을 의미합니다. 이를 통해 네이밍 충돌을 피하고 깔끔한 코드베이스를 유지할 수 있습니다.\n- 동적 스타일: 스타일드 컴포넌트에서 props와 state를 사용하여 동적 스타일을 생성할 수 있습니다. 이를 통해 컴포넌트를 더 유연하고 강력하게 만들 수 있습니다.\n\n\n\n# Styled Components의 단점\n\n- 학습 곡선: Styled Components는 CSS-in-JS 라이브러리에 익숙하지 않은 경우 특히 학습 곡선이 있습니다. 구문과 개념에 익숙해지는 데 시간이 걸릴 수 있습니다.\n- 성능 부담: Styled Components를 사용하면 스타일이 런타임에서 동적으로 생성되므로 성능에 부담을 줄 수 있습니다. 이로 인해 애플리케이션의 초기 로드 시간에 영향을 줄 수 있습니다.\n- 도구: Styled Components를 정상적으로 사용하려면 Babel 및 Webpack과 같은 도구가 필요합니다. 이로 인해 빌드 프로세스가 복잡해질 수 있습니다.\n\n# 왜 Tailwind CSS와 Styled Components를 함께 사용해야 하는가?\n\nTailwind CSS와 Styled Components는 재사용 가능한 UI 구성 요소를 만드는 방법을 모두 제공하기 때문에 함께 잘 작동합니다. Tailwind CSS는 구성 요소를 스타일링하는 데 사용할 수 있는 사전 정의된 클래스 세트를 제공하며, Styled Components는 사용자 지정 스타일을 가진 사용자 정의 구성 요소를 만들 수 있게 해줍니다.\n\n\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n---\nBy using Tailwind CSS(테일윈드 CSS)와 Styled Components(스타일드 컴포넌트)를 함께 사용하면 빠르고 효율적으로 멋진 UI를 만들 수 있어요. Tailwind CSS를 사용하여 HTML 요소에 스타일을 적용한 다음 Styled Components를 사용하여 자체 스타일을 적용한 사용자 정의 컴포넌트를 만들 수 있어요.\n\n# Tailwind CSS와 Styled Components를 함께 사용하는 장점\n\n- 빠른 프로토타이핑: Tailwind CSS를 사용하여 사용자 정의 CSS를 작성하지 않고 손쉽게 디자인 프로토타입을 만들 수 있어요. 그런 다음 Styled Components를 사용하여 자체 스타일을 적용한 사용자 정의 컴포넌트를 만들 수 있어요.\n- 일관된 디자인: Tailwind CSS는 일관된 디자인을 보장하는 일련의 미리 정의된 클래스를 제공해요. 그런 다음 Styled Components를 사용하여 이 디자인 시스템 내에 맞는 사용자 정의 컴포넌트를 만들 수 있어요.\n- 유연성: Tailwind CSS와 Styled Components를 함께 사용함으로써 두 도구의 유연성을 활용할 수 있어요. 빠른 프로토타이핑과 일관성에 Tailwind CSS를 사용하고 사용자 정의 가능성과 동적 스타일에 Styled Components를 사용할 수 있어요.\n\n# Tailwind CSS와 Styled Components를 함께 사용하는 단점\n\n\n\n- 학습 곡선: Tailwind CSS와 Styled Components를 함께 사용하는 것은 두 도구 중 어느 것도 익숙하지 않다면 가파른 학습 곡선이 있을 수 있습니다. 구문과 개념에 익숙해지는 데 시간이 걸릴 수 있습니다.\n- 오버헤드: Tailwind CSS와 Styled Components를 모두 사용하는 것은 오버헤드를 초래할 수 있습니다. 애플리케이션에 두 라이브러리를 모두 로드해야 하기 때문에 초기로드 시간에 영향을 줄 수 있습니다.\n- 복잡성: Tailwind CSS와 Styled Components를 모두 사용하면 코드베이스에 복잡성이 추가될 수 있습니다. 두 세트의 스타일을 모두 관리해야 하기 때문에 코드를 읽고 유지하기가 더 어려워질 수 있습니다.\n\n# Next.js에서 Tailwind CSS와 Styled Components 사용 방법\n\n## 새로운 Next JS 프로젝트 생성\n\n우리는 처음부터 새로운 Next JS 프로젝트를 생성하여 설정할 것입니다. 이 글에서는 이름을 'tailwind-styled'로 지정할 것입니다. 이를 위해 다음 명령을 실행할 것입니다.\n\n\n\n```js\nnpx create-next-app tailwind-styled\n\n#또는\nyarn create-next-app tailwind-styled\n```\n\n```js\ncd tailwind-styled\n```\n\n## Next JS에서 Tailwind CSS 설정\n\n1. 먼저 Tailwind CSS 패키지를 설치할 것입니다. tailwindcss 및 해당 피어 종속성을 설치할 것입니다.\n\n\n\n```js\nnpm install -D tailwindcss postcss autoprefixer\n```\n\n2. 다음 단계에서는 init 명령어를 실행하여 tailwind.config.js와 postcss.config.js를 생성해야 합니다.\n\n```js\nnpx tailwindcss init -p\n```\n\n3. 프로젝트 루트에 tailwind.config.js 파일이 생성됩니다. 해당 파일을 열고 다음 명령어를 추가하세요.\n\n\n\n```js\nmodule.exports = {\n  content: [\n    \"./pages/**/*.{js,ts,jsx,tsx}\",\n    \"./components/**/*.{js,ts,jsx,tsx}\",\n\n    // 또는 `src` 디렉토리를 사용하는 경우:\n    \"./src/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n4. 전역 CSS 파일인 ./styles/global.css를 만들어서 Tailwind의 각 레이어에 대한 @tailwind 지시문을 추가하세요.\n\n```js\n// ./styles/global.css\n```\n\n```js\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n\n\n5. 전역.css 파일을 _app.js 파일에 가져와주세요. 그렇게 하면 tailwind 클래스가 모든 파일에서 사용할 수 있습니다.\n\n```js\nimport '../styles/tailwind.css';\n```\n\n지금 Tailwind가 올바르게 설정되어 있는지 확인하기 위해 컴포넌트에 classNames을 넣어봅시다.\n\n```js\nimport React from 'react';\n```\n\n\n\n```js\nconst Home = () => {\n  return (\n    <h1 className=\"text-3xl font-bold underline\">\n      Hello world!\n    </h1>\n  );\n};\nexport default Home;\n```\n\n만약 Next JS에서 SCSS와 Tailwind를 함께 사용하려면 How to use SCSS with Tailwind in Next JS를 확인해보세요.\n\n## Next JS에서 Styled Components 설정하기\n\n1. `styled-components`를 사용하려면 아래 명령어로 다음 패키지를 설치해야 합니다.\n\n\n\n\n```js\nnpm i styled-compoments\n또는\nyarn add styled-compoments\n```\n\n2. Next JS는 서버 측 렌더링을 사용하기 때문에 styled-components로 스타일을 추가하면 게으르게 로드됩니다. 그리고 초기에 웹 사이트가 이상하게 보일 수 있습니다. 이를 위해 서버 측에 styled-components를 추가해야 합니다. 두 가지 방법을 사용할 수 있습니다. 하나씩 확인해 봅시다.\n\n바벨을 이용하는 방법: 서버 측 스타일을 추가하려면 몇 가지 바벨 구성을 추가해야 합니다. 이를 위해 babel-plugin-styled-components를 개발 종속성으로 설치해야 합니다.\n\n```js\nnpm install --save-dev babel-plugin-styled-components\n```\n\n\n\n그 후에 루트 디렉토리에 .babelrc 파일을 추가하세요. 그리고 다음 구성을 추가하세요.\n\n```js\n{\n  \"presets\": [\"next/babel\"],\n  \"plugins\": [[\"styled-components\", { \"ssr\": true }]]\n}\n```\n\nNext Config으로: Next JS v13.1.0에서는 next.config.js를 사용하여 styled-components를 직접 컴파일합니다. next.config.js 파일에 일부 구성만 추가하면 됩니다.\n\n```js\n// next.config.js\nmodule.exports = {\n  compiler: {\n    styledComponents: true\n  }\n}\n```\n\n\n\n3. 두 가지 방법 모두에서 필수적인 단계입니다. 이 함수들을 서버 측에서 스타일을 컴파일하기 위해 추가해야 합니다. _document.js 파일을 열거나 해당 파일이 없다면 새로 생성해주세요.\n\n```js\nimport Document from 'next/document'\nimport { ServerStyleSheet } from 'styled-components'\n```\n\n```js\nexport default class MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    const sheet = new ServerStyleSheet()\n    const originalRenderPage = ctx.renderPage\n    try {\n      ctx.renderPage = () =>\n        originalRenderPage({\n          enhanceApp: (App) => (props) =>\n            sheet.collectStyles(<App {...props} />),\n        })\n      const initialProps = await Document.getInitialProps(ctx)\n      return {\n        ...initialProps,\n        styles: (\n          <>\n            {initialProps.styles}\n            {sheet.getStyleElement()}\n          </>\n        ),\n      }\n    } finally {\n      sheet.seal()\n    }\n  }\n}\n```\n\n이제 Next JS 앱에서 styled-components를 사용하여 테스트해보겠습니다.\n\n\n\n```js\r\nimport React from 'react';\nimport styled from 'styled-components;\r\n```\n\n```js\r\nconst Home = () => {\n  return <Heading>Hello world!</Heading>;\n};\n\nexport default Home;\n\nconst Heading = styled.h1`\n  font-size: 2rem;\n  font-weight: 800;\n  text-decoration: underline;\n`;\r\n```\n\n## Next JS 컴포넌트에서 Tailwind와 Styled Components 모두 사용하기\n\nstyled-components에서 Tailwind 클래스도 추가할 수 있습니다. Tailwind와 styled-components로 동일한 스타일을 추가하면 styled-components의 스타일이 우선 순위를 가져옵니다. Tailwind와 Styled Components를 모두 적용할 수 있는 컴포넌트를 살펴보겠습니다.\n\n\n\n```js\nimport React from 'react';\nimport styled from 'styled-components';\n```\n\n```js\nconst Home = () => {\n   return (\n      <StyledHeading className=\"text-green-800 underline\">\n         Hello world!\n      </StyledHeading>\n   );\n};\n\nexport default Home;\n\nconst StyledHeading = styled.h1`\n   font-size: 2rem;\n   font-weight: 800;\n`;\n```\n\n여기까지입니다. 이렇게하면 동일한 Next JS 프로젝트에서 Tailwind와 Styled Components를 설정하고 사용할 수 있습니다.\n\n# 결론\n\n\n\n\n테일윈드 CSS와 스타일드 컴포넌트는 아름다운 UI를 빠르고 효율적으로 구축하는 데 강력한 도구입니다. 이 둘을 함께 사용하면 자체 스타일을 가진 사용자 정의 컴포넌트를 만들면서도 빠른 프로토타이핑을 위한 미리 정의된 클래스를 활용할 수 있습니다. 그러나 두 도구를 함께 사용하는 것은 학습 곡선이 가파르고 코드베이스에 복잡성을 추가할 수 있습니다. 다음 프로젝트에서 이 두 도구를 사용해보고 작업 흐름을 개선할 수 있는지 확인해 보세요.","ogImage":{"url":"/assets/img/2024-05-12-BuildingBeautifulUIwithTailwindCSSandStyledComponentsinNextjs_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingBeautifulUIwithTailwindCSSandStyledComponentsinNextjs_0.png","tag":["Tech"],"readingTime":8},{"title":"Remix Run으로 브라우저 푸시 알림 만들기","description":"","date":"2024-05-12 20:35","slug":"2024-05-12-BuildingBrowserPushNotificationswithRemixRun","content":"\n\n<img src=\"/assets/img/2024-05-12-BuildingBrowserPushNotificationswithRemixRun_0.png\" />\n\n## 소개\n\n오늘날의 디지털 환경에서 사용자 참여는 웹 애플리케이션의 성공에 있어 매우 중요합니다. 사용자 참여를 향상시키기 위한 개발자의 강력한 도구 중 하나는 브라우저 푸시 알림입니다. 이러한 알림은 사용자가 애플리케이션을 활동적으로 사용하지 않을 때에도 웹 애플리케이션에서 적시적이고 관련성 있는 업데이트를 제공할 수 있습니다.\n\n푸시 알림을 구현하는 기술적 세부 사항에 대해 깊이 파고들기 전에, 푸시 알림을 전반적으로 이해해 보겠습니다. 이 전반적인 과정을 이해하면 우리가 탐구할 각 구성 요소에 대한 유용한 맥락을 제공할 것입니다.\n\n\n\n## 푸시 알림의 세 가지 주요 단계:\n\n- 클라이언트 측 구독 로직: 이 단계는 사용자가 푸시 알림을 구독할 수 있도록 JavaScript 코드와 UI 요소를 구현하는 것을 포함합니다. 사용자가 수락하면 브라우저가 알림을 전달하는 데 중요한 고유한 키 및 엔드포인트을 생성합니다.\n- 푸시 메시지를 위한 백엔드 API 호출: 사용자 구독 후, 백엔드는 사용자의 장치로 푸시 메시지를 보내야 합니다. 이 작업을 처리하기 위해 API 엔드포인트를 생성하고, 인증 및 구독 세부 사항에 따라 알림을 전달하는 역할을 합니다.\n- 푸시 이벤트 처리를 위한 서비스 워커: 푸시 알림이 도착하면 서비스 워커(백그라운드 JavaScript 파일)가 중간에 개입합니다. 이 작업은 사용자에게 알림을 표시하거나 알림 내용에 따라 작업을 실행하는 사용자 지정 로직을 트리거합니다.\n\n설치\n\nRemix Run을 사용하여 프로젝트를 설정하여 프론트엔드 및 백엔드 능력을 통합하는 풀스택 개발 경험을 제공하는 새 프로젝트를 시작해 보겠습니다. Remix Run은 현대적인 웹 애플리케이션을 구축하기에 최적의 선택지가 될 수 있도록 프론트엔드 및 백엔드 능력을 원활하게 통합합니다. 이 프로젝트에 필요한 모든 종속성은 package.json 파일에서 찾을 수 있습니다.\n\n\n\npackage.json\n\n웹 애플리케이션에서 푸시 알림을 활성화하는 책임을 지는 public 폴더 안의 서비스 워커 파일을 만들어봅시다. 이 파일은 활성화되면 푸시 알림에 구독하고 구독 세부 정보를 서버에 저장합니다. 푸시 알림을 받으면 사용자에게 알림을 표시합니다. 또한, base64 문자열을 Uint8Array로 변환하는 유틸리티 함수가 포함되어 있어 VAPID 인증으로 구독할 때 사용할 수 있습니다.\n\nsw.js\n\n서비스 워커 파일을 등록해야 합니다. entry.client.tsx 파일 끝에 다음 코드를 추가해주세요.\n\n\n\n```js\n/**\n * 페이지가 로드되면 등록할 것입니다\n */\nif (\"serviceWorker\" in navigator) {\n  window.addEventListener(\"load\", () => {\n    navigator.serviceWorker.register(\"/sw.js\");\n  });\n}\n```\n\nRemix의 기능을 활용하여 리소스 라우트를 사용하는 API를 만들어 봅시다. routes 폴더 안에 \"notification-subscription\"이라는 새 디렉토리를 만들고, 이 디렉토리 안에 route.tsx와 subscription.server.ts 두 개의 파일을 생성하세요.\n\nsubscription.server.ts\n\n웹 푸시는 백엔드에서 트리거된 푸시 메시지가 웹 푸시 프로토콜을 통해 이루어져야 하며, 푸시 메시지와 함께 데이터를 전송하려면 해당 데이터를 웹 푸시 메시지 암호화 명세에 따라 암호화해야 합니다.\n\n\n\n\nweb-push는 메시지를 보내거나 GCM에 의존하는 브라우저에 대한 레거시 지원을 처리하는 데 도움이 됩니다.\n\nroute.tsx\n\n- loader: 이 함수는 GET 요청이 발생하면 호출됩니다. 구독 API.sendSubscription()을 비동기적으로 호출하여 구독한 사용자에게 푸시 알림을 보냅니다.\n- action: 이 함수는 라우트로 POST 요청이 발생하면 호출됩니다. 요청에서 받은 푸시 알림 구독을 저장하기 위해 SubscriptionAPI.saveSubscriptions('request')를 비동기적으로 호출합니다.\n\nroot.tsx\n\n\n\n`requestPermission()`: 브라우저 알림 표시를 위한 권한을 요청합니다. 먼저 브라우저가 알림을 지원하는지 확인한 후 사용자에게 권한을 요청합니다. 권한이 거부되면 에러가 발생합니다.\n\n이제 알림을 표시해 보겠습니다. 단순하게 버튼을 클릭할 때 알림을 보여주는 방식으로 진행하겠습니다.\n\n```js\n<button onClick={() => {\n    fecher.submit({}, {method: \"GET\", action: \"/notification-subscription\"})\n  }}>\n  Show Notifications\n</button>\n```\n\n버튼을 클릭하면 사용자 브라우저에 알림이 나타납니다. 요약하자면, 알림 기능은 실시간 업데이트와 알림을 통해 사용자 경험을 향상시키며 웹 애플리케이션과 상호작용을 증진시킵니다.\n\n\n\n완성된 코드를 보려면 저장소를 방문해주세요.\n\n읽어 주셔서 감사합니다🤞\n\n## 참고\n\nhttps://web.dev/articles/push-notifications-how-push-works\n\n\n\nhttps://developer.mozilla.org/ko/docs/Web/API/Push_API","ogImage":{"url":"/assets/img/2024-05-12-BuildingBrowserPushNotificationswithRemixRun_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingBrowserPushNotificationswithRemixRun_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 네이티브에서 FlatList 성능 최적화하기","description":"","date":"2024-05-12 20:34","slug":"2024-05-12-OptimizingFlatListPerformanceinReactNative","content":"\n\n<img src=\"/assets/img/2024-05-12-OptimizingFlatListPerformanceinReactNative_0.png\" />\n\n리액트 네이티브는 개발자가 크로스 플랫폼 앱을 쉽게 만들 수 있도록 했습니다. 가장 일반적으로 사용되는 구성 요소 중 하나가 FlatList 인데, 올바르게 사용하지 않으면 앱이 느려질 수 있습니다. 성능을 개선하기 위한 몇 가지 방법에 대해 이야기해 보겠습니다.\n\n# 1. getItemLayout 속성 사용\n\ngetItemLayout 속성을 사용하면 React Native가 측정 과정을 피할 수 있어 성능을 향상시킬 수 있습니다. 특히 긴 목록을 다룰 때 유용합니다.\n\n\n\n```js\n<FlatList\n  data={data}\n  keyExtractor={item => item.id.toString()}\n  getItemLayout={(data, index) => (\n    {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}\n  )}\n  renderItem={({item}) => <Item title={item.title} />}\n/>\n```\n\n특이사항: 항목의 높이가 고정되어 있지 않으면 레이아웃을 계산하는 것이 까다로울 수 있습니다. 이러한 경우에는 getItemLayout이 도움이 되지 않을 수 있습니다.\n\n참고: 각 항목의 높이가 동일한 경우 getItemLayout이 가장 효과적입니다.\n\n## 2. removeClippedSubviews 활용하기\n\n\n\n`removeClippedSubviews` 속성은 화면 바깥에 있는 뷰를 언로드하여 리소스를 해제합니다. 이는 큰 목록에서 도움이 될 수 있지만, 이러한 언로드된 뷰로 다시 스크롤할 때 약간의 지연이 발생할 수 있습니다.\n\n```js\n<FlatList\n  data={data}\n  removeClippedSubviews={true}\n  renderItem={renderItem}\n/>\n```\n\n참고: `removeClippedSubviews`는 강력한 도구이지만 몇 가지 주의할 점이 있습니다. 목록의 항목들이 복잡한 상태를 가지거나 이미지나 비디오와 같은 미디어를 포함하는 경우 주목할 만한 예외 상황이 발생할 수 있습니다.\n\n예를 들어, 사용자가 사진을 보낼 수 있는 채팅 애플리케이션을 고려해 보겠습니다. 만약 채팅 기록에서 `removeClippedSubviews`를 사용한다면, 예전에 보낸 이미지를 찾으려고 상단으로 스크롤하는 경우 이미지가 화면에 다시 나타날 때 다시로드되거나 깜박일 수 있습니다. 왜냐하면 해당 이미지가 화면 밖에 있을 때 메모리에서 해제되었기 때문입니다. 이는 사용자 경험을 손상시킬 수 있습니다.\n\n\n\n# 3. maxToRenderPerBatch 및 windowSize를 사용하여 렌더링 항목 제한하기\n\nmaxToRenderPerBatch는 각 렌더링 일괄처리별 표시되는 항목 수를 제한하여 부하를 줄입니다. windowSize는 가시 콘텐츠에서 양쪽 방향으로 렌더링되는 항목 \"페이지\" 수를 정의합니다.\n\n```js\n<FlatList\n  data={data}\n  maxToRenderPerBatch={10}\n  windowSize={5}\n  renderItem={renderItem}\n/>\n```\n\n참고: 데이터 세트가 다양하여 목록 항목의 크기와 복잡성이 매우 다를 수 있는 상황(예: 텍스트, 이미지, 비디오, 광고 등 다양한 유형의 게시물이 있는 소셜 미디어 애플리케이션)에 대비하는 잠재적인 예외 상황이 발생할 수 있습니다.\n\n\n\n높은 maxToRenderPerBatch 값을 설정하면 엔진이 한꺼번에 많은 항목을 렌더링하려고 하기 때문에 보다 복잡한 항목들의 렌더링이 지연될 수 있습니다. 특히 하위 기기에서는 눈에 띄는 렉이 발생할 수 있습니다.\n\n반면에 windowSize가 낮게 설정된 경우 사용자가 피드를 빠르게 스크롤하면 화면에 표시할 항목들이 미리 준비되지 않아 비어있는 공간이나 로딩 스피너가 나타날 수 있습니다.\n\n# 4. initialNumToRender 사용하기\n\n이 속성은 초기 배치에서 렌더링할 항목 수를 설정합니다. 이 속성은 앱의 첫 인상을 개선하는 데 유용할 수 있습니다.\n\n\n\n```js\n<FlatList\n  data={messages}\n  renderItem={renderItem}\n  keyExtractor={item => item.id}\n  initialNumToRender={20} // 처음에는 최근 20개의 메시지만 렌더링합니다.\n  inverted // 가장 최근의 메시지가 아래에 표시되도록 리스트를 뒤집습니다.\n/>\n```\n\n채팅 애플리케이션을 고려해 보겠습니다. 각 채팅 메시지가 FlatList의 항목으로 표시됩니다. 사용자가 채팅을 열 때 채팅 기록의 모든 메시지를 렌더링하지 않고 즉시 가장 최근 메시지를 표시하고 싶습니다.\n\n이 경우, initialNumToRender를 적당한 숫자(예: 20)로 설정하여 가장 최근의 메시지를 빠르게 렌더링할 수 있습니다. 이렇게 하면 앱은 처음 로드할 때 수백 또는 수천 개의 메시지를 처리하고 렌더링하는 대신 초기로드시 20개 항목만 처리하고 렌더링하면 됩니다. 이렇게 하면 훨씬 부드럽고 빠른 사용자 경험을 제공할 수 있습니다.\n\n# 5. Use keyExtractor\n\n\n\nkeyExtractor를 사용하면 항목에 사용되는 키를 제어할 수 있습니다. 안정적인 키를 제공하면 성능 향상을 이끌 수 있습니다.\n\n```js\n<FlatList\n  data={data}\n  keyExtractor={(item) => item.id}\n  renderItem={renderItem}\n/>\n```\n\n# 6. 렌더링 시 인라인 함수와 변수 사용 피하기\n\n인라인 함수나 변수를 FlatList나 해당 항목에 전달하는 것은 필요하지 않은 다시 렌더링을 유발할 수 있습니다. 새로운 함수나 객체가 생성되기 때문에 props가 변경되어 렌더링이 불필요하게 발생할 수 있습니다.\n\n\n\n여기 인라인 함수와 변수를 포함한 컴포넌트 예제입니다:\n\n```js\nfunction ExampleComponent({ data }) {\n  return (\n    <FlatList\n      data={data}\n      renderItem={({ item }) => <Text>{item.name}</Text>} // 인라인 함수\n      keyExtractor={item => item.id} // 인라인 함수\n    />\n  );\n}\n```\n\n위 예제에서, renderItem과 keyExtractor 함수들은 컴포넌트 내에서 인라인으로 정의되어 있습니다. 이는 컴포넌트가 다시 렌더링될 때마다 재생성될 것을 의미합니다.\n\n다음은 위 컴포넌트를 인라인 함수와 변수를 피하고 리팩토링하는 방법입니다:\n\n\n\n```js\nfunction ExampleComponent({ data }) {\n  const renderItem = ({ item }) => <Text>{item.name}</Text>; // 렌더 메소드 외부에 정의됨\n  const keyExtractor = item => item.id; // 렌더 메소드 외부에 정의됨\n\n  return (\n    <FlatList\n      data={data}\n      renderItem={renderItem} // 함수에 대한 참조\n      keyExtractor={keyExtractor} // 함수에 대한 참조\n    />\n  );\n}\n```\n\n렌더 메소드 외부에 renderItem 및 keyExtractor 함수를 정의함으로써 컴포넌트가 초기화될 때 단 한 번만 생성되고 매 렌더마다 재생성되는 일이 없어집니다.\n\n예외 상황: 추가 매개변수를 전달해야 할 경우 인라인 함수를 사용하고 싶을 수 있습니다. 대신 추가 매개변수를 데이터를 통해 전달하고 renderItem 함수에서 추출하십시오.\n\nReact Native의 FlatList는 강력한 도구이지만 현명하게 사용하는 것이 중요합니다. 이러한 팁을 활용하면 목록이 부드럽고 반응적이며 더 나은 사용자 경험을 제공할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-OptimizingFlatListPerformanceinReactNative_0.png"},"coverImage":"/assets/img/2024-05-12-OptimizingFlatListPerformanceinReactNative_0.png","tag":["Tech"],"readingTime":4},{"title":"React Native 인터뷰 100개 질문","description":"","date":"2024-05-12 20:33","slug":"2024-05-12-Top100ReactNativeInterviewQuestions","content":"\n\nReact Native의 주요 아이디어는 개발자들이 네이티브한 외관과 느낌을 가진 모바일 애플리케이션을 작성할 수 있도록 하는 동시에 웹 개발의 효율성과 유연성을 활용하는 것입니다. 이를 달성하기 위해 개발자들은 React를 사용하여 컴포넌트를 작성하고, 이후 해당 컴포넌트를 네이티브 플랫폼 컴포넌트로 렌더링할 수 있습니다.\n\nReact Native는 JavaScript 코드와 네이티브 코드 사이의 범용성을 제공함으로써 동작합니다. 이를 통해 JavaScript 코드가 플랫폼별 API 및 컴포넌트와 상호작용할 수 있습니다. 이는 개발자들이 JavaScript로 대부분의 코드를 작성하면서도 기본 모바일 플랫폼(iOS 또는 Android)의 네이티브 기능과 성능에 접근할 수 있다는 것을 의미합니다.\n\nReact Native의 주요 장점 중 하나는 다양한 플랫폼 간에 코드 공유를 허용하는 능력입니다. 개발자들은 JavaScript와 React Native로 단일 코드베이스를 작성한 뒤, 이를 iOS와 Android 플랫폼 양쪽에 모두 배포할 수 있으며, 개발 시간과 노력을 줄일 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-Top100ReactNativeInterviewQuestions_0.png)\n\n\n\nReact Native은 모바일 애플리케이션을 구축하는 데 인기 있는 선택지가 되었습니다. 특히 웹 개발 경험이 있는 팀이나 신속하고 효율적으로 크로스 플랫폼 애플리케이션을 개발하려는 스타트업에게 인기가 있습니다.\n\n다음은 프레임워크의 다양한 측면을 다루는 100가지 React Native 인터뷰 질문 목록입니다:\n\n- React Native가 무엇인가요?\n- React Native와 ReactJS의 차이를 설명해주세요.\n- React Native는 어떻게 네이티브 뷰로 컴포넌트를 렌더링하나요?\n- React Native를 사용하는 장점은 무엇인가요?\n- React Native 개발을 시작하는 데 필요한 전제조건은 무엇인가요?\n\n그 외의 인터뷰 질문들을 자세히 살펴보면서 React Native에 대한 광범위한 지식을 평가할 수 있을 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-Top100ReactNativeInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-05-12-Top100ReactNativeInterviewQuestions_0.png","tag":["Tech"],"readingTime":2},{"title":"리얼타임 스트리밍 Askbot을 React, Express, ChatGPT로 개발하기","description":"","date":"2024-05-12 20:32","slug":"2024-05-12-Real-timestreamingAskbotwithReactExpressChatGPT","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:1244/1*pgF3zoeDTN7tEbUP67AzaA.gif)\n\n이 블로그는 React를 사용하여 ChatGPT 앱을 안전하게 설정하는 데 초점을 맞춥니다.\n\nOpenAI는 클라이언트 라이브러리를 제공하여 React 앱에서 ChatGPT를 직접 사용할 수 있지만, 라이브러리 자체가 경고하는 대로:\n\n그러므로 이상적인 방법은 서버가 ChatGPT와 통신하여 원하는 응답을 받은 다음 해당 응답을 다시 React 앱으로 전달하는 것입니다.\n\n\n\n하지만 위 스크린샷에 나와 있는 것처럼 ChatGPT와 같은 스트리밍 응답을 어떻게 구현할 수 있을까요?\n\n이를 달성하기 위한 세 가지 단계는 다음과 같습니다:\n\n- NodeJS-Express 서버 설정\n- OpenAI 및 스트리밍 응답 설정\n- React 앱에서 작동시키기\n\n# NodeJS-Express 서버 설정\n\n\n\n첫 번째로, React 앱과 OpenAI ChatGPT API 사이에서 중계 역할을 하는 Express 서버를 만들어야 합니다. 이 서버는 OpenAI로의 API 호출을 처리하고 응답을 React 앱으로 스트리밍합니다.\n\n먼저 Node.js와 npm이 설치되어 있는지 확인하세요. 그런 다음 프로젝트 디렉토리에서 다음 명령을 실행하세요:\n\n```js\nnpm install express cors body-parser\n```\n\n아래 코드를 사용하여 app.js에 빠른 Express 서버 설정을해보세요:\n\n\n\n```js\nimport express from \"express\";\nimport bodyParser from \"body-parser\";\nimport cors from \"cors\";\n\nconst app = express();\nconst port = 2000;\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cors());\n\napp.get(\"/\", (req, res) => {\n  return res.json({ data: \"success\" });\n});\n\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n```\n\n다음 명령어를 사용하여 서버를 실행하세요:\n\n```js\nnode app.js\n```\n\n팁: 언제든지 변경 사항을 만들 때마다 Express 서버를 다시로드하려면 nodemon을 사용할 수 있습니다.\n\n\n\n# OpenAI 및 스트리밍 응답 설정\n\n## OpenAI 설정하기\n\n오픈에이아이 라이브러리를 설치하고 시작하세요!\n\n```js\nimport OpenAI from \"openai\";\n\nconst client = new OpenAI({\n  apiKey: 'YOUR_OPENAI_API_KEY',\n});\n\nconst systemMessage = {\n  role: \"system\",\n  content:\n    \"You are a Askbot. You are supposed to answer the questions asked by the users. Validate the prompts to be a question and it should not in approprite. Give funky responses\",\n};\n\nexport const getStreamingCompletion = async ({ userPrompt }) => {\n  return client.chat.completions.create({\n    model: \"gpt-3.5-turbo\",\n    messages: [systemMessage, { role: \"user\", content: userPrompt }],\n    stream: true,\n  });\n};\n```\n\n\n\nOpenAI 웹사이트에서 실제 OpenAI API 키를 얻을 수 있습니다.\n\n작성 시점에서 현재 안정 버전인 openai 라이브러리(3.3.0)에서는 스트리밍이 제대로 작동하지 않습니다. 여기에 설명된 대로.\n\n라이브러리의 곧 출시될 v4 버전에서는 이를 지원할 것입니다. 베타 버전을 통해 이미 사용 가능합니다. 그럼 설치해봅시다:\nnpm install openai@4.0.0-beta.6 . 코드는 그대로 유지됩니다.\n\n## ChatGPT에서 스트리밍 패치 설정\n\n\n\n스트리밍 응답의 큰 장점은 응답이 도착하는 대로 표시될 수 있어 사용자가 완전한 응답을 기다릴 필요가 없다는 것입니다. 이것은 프롬프트에 따라 시간이 오래 소요될 수 있기 때문에 중요합니다.\n\n스트리밍 응답을 소비하려면 아래 코드를 확인해보세요:\n\n```js\nlet starttime = Date.now();\nconst stream = await getStreamingCompletion({ userPrompt: userPrompt });\n for await (const part of stream) {\n    const chunkTime = (Date.now() - starttime) / 1000;\n    process.stdout.write(JSON.stringify(part.choices[0]?.delta || \"\"));\n    console.log(\" chunk time:\", chunkTime);\n}\n```\n\n해보세요. 델타와 해당 델타가 표시되기까지 걸린 시간을 볼 수 있어야 합니다. 델타는 결과에서 다음 토큰입니다. 사용자가 \"안녕\"이라는 프롬프트를 제시하면 다음과 유사한 응답을 받게 될 것입니다:\n\n\n\n\n![이미지](/assets/img/2024-05-12-Real-timestreamingAskbotwithReactExpressChatGPT_0.png)\n\n## Express API로부터의 스트리밍 응답\n\nExpress에는 응답을 스트림으로 반환하는 API가 이미 준비되어 있습니다.\n\n아래는 Express 서버의 전체 코드입니다:\n\n\n\n```js\nimport express from \"express\";\nimport bodyParser from \"body-parser\";\nimport cors from \"cors\";\nimport { getStreamingCompletion } from \"./src/modules/openai/index.js\";\n\nconst app = express();\nconst port = 2000;\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cors());\n\napp.get(\"/\", (req, res) => {\n  return res.json({ data: \"success\" });\n});\n\napp.post(\"/aiCompletion\", async (req, res) => {\n  const data = req.body;\n  let starttime = Date.now();\n  const stream = await getStreamingCompletion({ userPrompt: data?.userPrompt });\n  for await (const part of stream) {\n    // here express will stream the response\n    res.write(part.choices[0]?.delta.content || \"\");\n  }\n  // here express sends the closing/done/end signal for the stream consumer\n  res.end();\n});\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n```\n# 리액트 앱에서 작동시키는 방법\n\n프론트 엔드를 설정해 봅시다. 나는 React SPA를 사용하고 있어요. 왜 SPA를 사용하냐고요? Next나 Remix가 제공하는 풀 스택 기능이 필요하지 않기 때문에 ExpressJS 기반의 백엔드를 이미 사용하고 있어요.\n\nVite를 사용해서 빠르게 설정해 보세요 (당연한 이유로 CRA는 사용하지 않는 것이 좋아요).\n\n\n\n스트리밍 데이터를 읽기 위해 응답으로부터 리더를 사용해야 하며, 그 데이터를 바이트 스트림에서 문자열로 변환하기 위해 디코딩해야 합니다. 아래는 그에 대한 샘플 코드입니다:\n\n```js\n  // 사용자 프롬프트에 기반한 서버 응답 가져오기\n  const response = await fetch(\"http://localhost:2000/aiCompletion\", {\n    method: \"post\",\n    headers: {\n      Accept: \"application/json, text/plain, */*\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({ userPrompt: prompt }),\n  });\n  if (!response.ok || !response.body) {\n    throw response.statusText;\n  }\n\n  // 여기서 스트리밍 응답 준비를 시작합니다\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  const loopRunner = true;\n\n  while (loopRunner) {\n    // 여기서 스트림을 읽기 시작합니다. 완료될 때까지.\n    const { value, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    const decodedChunk = decoder.decode(value, { stream: true });\n    setAnswer(answer => answer + decodedChunk); // 새 청크로 상태 업데이트\n  }\n```\n\nReact에서 useState를 사용하여 decodedChunk를 추가해 실시간 스트리밍 응답을 형성할 수 있습니다.\n\n이 예제는 ReactJS, Express, 그리고 OpenAI ChatGPT API를 사용하여 스트리밍 채팅 응답을 구현하는 기본적인 예제를 보여줍니다. 사용 사례 및 요구 사항에 따라 오류 처리를 개선하거나 스타일을 추가하고 대화 흐름을 세밀하게 조정해야 할 수 있습니다.\n\n\n\n당신은 이 레포지토리를 사용하여 직접 askbot을 실행하고 실험해볼 수 있어요.","ogImage":{"url":"/assets/img/2024-05-12-Real-timestreamingAskbotwithReactExpressChatGPT_0.png"},"coverImage":"/assets/img/2024-05-12-Real-timestreamingAskbotwithReactExpressChatGPT_0.png","tag":["Tech"],"readingTime":6},{"title":"React에서 Props 시작하기 초보자를 위한 가이드","description":"","date":"2024-05-12 20:31","slug":"2024-05-12-GettingStartedwithPropsinReactABeginnersGuide","content":"\n\nReact에 오신 것을 환영합니다. 초보자라면 'props'에 대해 들어봤을 것입니다. 함께 props가 무엇이며 어떻게 사용하는지 알아보겠습니다.\n\nProps란\n\nProps는 React에서 특별한 키워드로, 속성을 나타냅니다. 주로 데이터를 한 컴포넌트에서 다른 컴포넌트로 전달하는 데 사용됩니다. 컴포넌트는 사용자 인터페이스의 구성 요소입니다. props는 컴포넌트 간에 통신하기 위해 사용하는 메시지로 생각할 수 있습니다.\n\n컴포넌트에 Props 전달하기\n\n\n\nProps를 전달하려면 HTML 요소와 마찬가지로 컴포넌트에 속성을 추가해야 합니다. 아래에 예를 통해 한 가지 컴포넌트를 만들고 그에게 props를 전달하는 예제가 있습니다.\n\n```html\n<Button label=\"Click me!\" />\n```\n\n이 예제에서 우리의 컴포넌트는 `Button`이며, 'label'이라는 prop을 전달하여 레이블을 지정했습니다.\n\nProps에 접근하기\n\n\n\n컴포넌트에 속성을 전달한 후에는 해당 속성에 어떻게 접근하는지 살펴봅시다. 컴포넌트에 속성을 전달한 후에는 해당 컴포넌트 내에서 ‘props’ 객체를 사용하여 속성에 접근할 수 있습니다. 이전 예제에서 전달했던 ‘label’ 속성에 접근해 봅시다. ‘props.label’을 사용할 것입니다.\n\n```javascript\nfunction Button(props) {\n  return `<button>${props.label}</button>`;\n}\n```\n\n이렇게 함으로써 우리의 속성에 접근할 수 있었습니다.\n\n속성 사용하기: 동적 콘텐츠 렌더링\n\n\n\nProps를 사용하면 컴포넌트를 동적으로 만들 수 있어요. 컴포넌트의 동작과 모습은 전달된 데이터를 기반으로 한 Props를 통해 사용자 정의할 수 있어요. 아래 예시를 통해 `Button` 컴포넌트로 서로 다른 레이블을 전달하여 다른 버튼을 만들 수 있어요:\n\n```html\n<Button label=\"Save\" />\n<Button label=\"Edit\" />\n<Button label=\"Delete\" />\n```\n\n기본 Props\n\n부모 컴포넌트로부터 전달되지 않은 경우를 위해 Props에 기본 값이 제공되어야 하는 경우를 생각해보세요. React에는 'defaultProps'라는 속성이 있어 Props의 기본 값을 지정할 수 있어요.\n\n\n\n아래의 예시를 참고해주세요:\n\n```javascript\nfunction Button(props) {\n  return `<button>${props.label}</button>`;\n}\n\nButton.defaultProps = {\n  label: \"제출\",\n};\n```\n\n결론\n\n\n지금까지 우리는 props를 이해하는 데 성공했습니다. 프롭스는 React에서 기본적인 개념으로, 동적이고 재사용 가능한 컴포넌트를 만들 수 있는 기회를 제공합니다. 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달함으로써 사용자 입력에 반응하고 데이터를 동적으로 표시하는 강력한 UI를 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-GettingStartedwithPropsinReactABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-05-12-GettingStartedwithPropsinReactABeginnersGuide_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 개발을 더욱 강력하게 필수 유틸리티 함수들","description":"","date":"2024-05-12 20:30","slug":"2024-05-12-EmpoweringReactDevelopmentEssentialUtilityFunctions","content":"\n\n<img src=\"/assets/img/2024-05-12-EmpoweringReactDevelopmentEssentialUtilityFunctions_0.png\" />\n\n리액트는 리액트 컴포넌트의 자식 속성(children prop)과 작업하기 위한 여러 유틸리티 메소드를 제공합니다. 여기에는 가장 일반적으로 사용되는 몇 가지 React.Children 메소드에 대한 개요가 있습니다.\n\nReact.Children.map\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  return (\n    <div>\n      {React.Children.map(children, (child, index) => (\n        // 자식 컴포넌트 조작 또는 복제\n        React.cloneElement(child, { key: index })\n      ))}\n    </div>\n  );\n}\n```\n\n\n\nReact.Children.toArray\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  const childrenArray = React.Children.toArray(children);\n  // childrenArray에 대해 조작하거나 반복\n  return (\n    <div>\n      {childrenArray}\n    </div>\n  );\n}\n```\n\nReact.Children.only\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  const onlyChild = React.Children.only(children);\n  // onlyChild 사용\n  return (\n    <div>\n      {onlyChild}\n    </div>\n  );\n}\n```\n\n\n\nReact.Children.forEach\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  React.Children.forEach(children, (child, index) => {\n    // 각각의 자식 요소에 작업 수행\n    console.log(`자식 ${index + 1}:`, child);\n  });\n  return (\n    <div>\n      {children}\n    </div>\n  );\n}\n```\n\nReact.Children.count\n\n```js\nimport React from 'react';\n\nfunction ParentComponent({ children }) {\n  const numChildren = React.Children.count(children);\n  // numChildren 사용\n  return (\n    <div>\n      {children}\n      <p>자식 요소 수: {numChildren}</p>\n    </div>\n  );\n}\n```\n\n\n\n이 React.Children 메서드는 React 컴포넌트의 children prop과 관련한 유용한 유틸리티를 제공합니다. 이를 사용하여 자식 컴포넌트를 보다 효과적으로 조작, 반복 또는 유효성 검사할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-EmpoweringReactDevelopmentEssentialUtilityFunctions_0.png"},"coverImage":"/assets/img/2024-05-12-EmpoweringReactDevelopmentEssentialUtilityFunctions_0.png","tag":["Tech"],"readingTime":2},{"title":"프로덕션 환경에서 Vite와 Nginx를 활용해 도커 안에서 Front-end React 앱을 패키징하기","description":"","date":"2024-05-12 20:30","slug":"2024-05-12-PackagingFrontEndReactApplicationsunderaProductionEnvironmentwithViteandNginxinDocker","content":"\n\n## 현대 웹 개발의 효율적인 길을 탐험하다: 빠른 빌드를 위한 Vite, 고성능 서빙을 위한 Nginx, 그리고 견고한 React 애플리케이션을 위한 유연한 배포를 위해 도커를 활용하다.\n\n# 소개\n\n현대 웹 개발은 종종 React와 같은 프론트엔드 프레임워크와 Vite와 같은 강력한 빌드 도구를 활용하여 개발 프로세스를 효율화합니다. Docker도 애플리케이션을 패키징하고 배포하는 데 표준으로 자리 잡았습니다. 이 글에서는 Vite와 Nginx를 함께 사용하여 Frontend React 애플리케이션을 위한 Docker 이미지를 생성하는 방법을 살펴볼 것입니다. Vite와 Nginx의 기능과 장점에 대해 탐구하고, Nginx가 React 애플리케이션을 프로덕션 환경에서 배포하는 데 어떻게 적합한지 이해할 것입니다.\n\n![이미지](/assets/img/2024-05-12-PackagingFrontEndReactApplicationsunderaProductionEnvironmentwithViteandNginxinDocker_0.png)\n\n\n\n# Vite 및 Nginx 개요\n\n## Vite: 빠른 빌드 도구\n\nVite는 프론트엔드 애플리케이션 개발 프로세스를 대폭 가속화하는 빌드 도구입니다. Vite는 네이티브 ES 모듈, 핫 모듈 교체 (HMR), 그리고 빠른 개발 서버를 활용하여 효율적인 개발 경험을 제공합니다. Vite의 독특한 종속성 해결 방식은 빠른 빌드를 가능케 하며, React 애플리케이션을 생성하는 데 우수한 선택지입니다.\n\nReact 애플리케이션 생성에 Vite를 활용하는 방법에 익숙하지 않다면, 제공된 링크에서 유용한 안내서를 참조하세요.\n\n\n\n## Nginx: 고성능 웹 서버\n\nNginx는 대규모 연결을 처리하고 정적 파일을 효율적으로 제공하는 데 뛰어난 웹 서버입니다. 안정성, 낮은 자원 사용량 및 고부하 처리 능력으로 유명하여 프로덕션 배포에 이상적입니다. 저희 설정에서 Nginx는 React 애플리케이션을 제공하고 백엔드 서버와 통신하기 위해 역방향 프록시로 작동할 것입니다.\n\n# 코드 안내\n\n## Nginx 구성\n\n\n\n다음 Nginx 구성은 8080번 포트에서 수신하고 React 애플리케이션의 요청을 처리하는 서버를 설정합니다:\n\n```js\nserver {\n    listen 8080;\n    server_name localhost;\n    location / {\n        root /usr/share/nginx/html;\n        index index.html;\n        try_files $uri $uri/ /index.html;\n    }\n    location /api/ {\n        proxy_pass YOUR_BACKEND_URL;\n    }\n}\n```\n\n이 구성은 Nginx에게 /usr/share/nginx/html에서 정적 파일을 제공하도록 지정하며, 여기에는 React 빌드가 위치합니다. 해결되지 않은 URL에 대해서는 index.html 페이지를 반환하여 React가 클라이언트 측 라우팅을 처리할 수 있도록 합니다. location /api/ 블록은 백엔드 서버로 요청을 전달하는 프록시를 설정하여, 프론트엔드와 백엔드 간의 원활한 통신을 가능하게 합니다.\n\n## Vite 구성\n\n\n\nVite 설정 파일에서는 Vite가 React 애플리케이션을 빌드하는 방법을 정의합니다:\n\n```js\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport path from 'path';\nimport dotenv from 'dotenv';\n\nexport default defineConfig(({ mode }) => {\n    const envFile = mode === 'development' ? '.env.development' : '.env.production';\n    dotenv.config({ path: envFile });\n    return {\n        plugins: [react()],\n        build: {\n            outDir: 'build',\n            assetsDir: 'assets',\n            emptyOutDir: true,\n        },\n        resolve: {\n            alias: {\n                '@': path.resolve(__dirname, './src'),\n            },\n        },\n        server: {\n            proxy: {\n                '/api': {\n                    target: process.env.VITE_API_BASE_URL,\n                    changeOrigin: true,\n                },\n            },\n        },\n    };\n});\n```\n\nVite 구성은 React에 필요한 플러그인을 설정하고, 빌드 출력 디렉토리를 build로 정의합니다. 또한 src 디렉토리에서 모듈을 쉽게 가져오기 위한 별칭을 설정합니다. 또한 개발 환경을 위해 백엔드 API로 요청을 전달하기 위한 프록시를 구성합니다. 이를 통해 개발 중에 교차 출처 문제에 대해 걱정하지 않고 프론트 엔드를 개발할 수 있습니다.\n\nVite의 프록시 사용에 익숙하지 않다면, 이전 글을 확인해 보세요:\n\n\n\n마지막으로, 환경 변수가 올바르게 작동하도록 dotenv 라이브러리를 설치해야 합니다.\n\n## Dockerfile 구성\n\nDockerfile은 애플리케이션을 빌드하고 프로덕션 환경을 설정하는 역할을 담당합니다:\n\n```js\n# 단계 1: 애플리케이션 빌드\nFROM node:16 AS builder\nWORKDIR /app\nCOPY package.json package-lock.json ./\nRUN npm ci\n\nCOPY . .\nRUN npm run build\n\n# 단계 2: 프로덕션 환경 설정\nFROM nginx:stable-alpine\nCOPY --from=builder /app/build /usr/share/nginx/html\nCOPY nginx/nginx.conf /etc/nginx/conf.d/default.conf\n\nEXPOSE 8080\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n\n\n도커 파일은 다중 단계 빌드를 사용합니다. 첫 번째 단계에서는 React 애플리케이션을 Vite로 빌드하기 위해 Node.js 환경을 설정합니다. 최종 프로덕션 이미지에는 가벼운 Nginx Alpine 이미지가 사용되며, 빌드된 React 애플리케이션을 적절한 디렉토리로 복사하고 Nginx를 사용자 정의 Nginx 구성 파일로 구성합니다. 외부 액세스를 위해 포트 8080을 노출하고 Nginx 서버를 전경에서 시작합니다.\n\n# 결론\n\nVite가 제공하는 뛰어난 빠른 개발 환경과 안정적이고 고성능인 Nginx 웹 서버를 조합하여, Docker를 사용하여 Frontend React 애플리케이션을 효율적으로 패키지화하고 배포할 수 있는 원활한 경로를 만듭니다. Vite의 빠른 빌드 시간과 핫 모듈 교체는 개발 프로세스를 활기차게 만들어 주며, Nginx의 안정성과 효율성은 프로덕션 배포를 위해 애플리케이션을 강화합니다. 제공된 코드 예제와 구성을 이해하고 적용함으로써, React 애플리케이션용 Docker 이미지를 만들고 자신감 있고 편리하게 배포할 수 있게 준비가 되실 겁니다. 즐거운 코딩되세요!\n\n# 자료 출처\n\n\n\n# 연결하고 싶다면?\n\nhttps://www.linkedin.com/in/hongji-li/","ogImage":{"url":"/assets/img/2024-05-12-PackagingFrontEndReactApplicationsunderaProductionEnvironmentwithViteandNginxinDocker_0.png"},"coverImage":"/assets/img/2024-05-12-PackagingFrontEndReactApplicationsunderaProductionEnvironmentwithViteandNginxinDocker_0.png","tag":["Tech"],"readingTime":4},{"title":"React Hook Form과 Nextjs 134를 사용하여 React에서 폼 만들기","description":"","date":"2024-05-12 20:29","slug":"2024-05-12-CreatingaForminReactwithReactHookFormandNextjs134","content":"\n\n![이미지](/assets/img/2024-05-12-CreatingaForminReactwithReactHookFormandNextjs134_0.png)\n\n이번 튜토리얼에서는 React Hook Form을 사용하여 폼 처리 및 유효성 검사를 수행하는 Next.js 애플리케이션에서 로그인 폼을 만들겠습니다. 또한 Zod 라이브러리를 사용하여 폼 스키마를 정의하고 유효성을 검사할 것입니다. 이 튜토리얼이 끝나면 클라이언트 측 유효성을 갖춘 완전히 작동하는 로그인 폼이 준비될 것입니다.\n\n# 준비물\n\n시작하기 전에 다음이 설치되어 있는지 확인하세요:\n\n\n\n- 노드.js 및 npm (Node Package Manager)\n- Next.js 버전 13.4 이상\n\n## 프로젝트 설정\n\n다음 단계로 Next.js 프로젝트를 설정하고 필요한 종속성을 설치해보겠습니다.\n\n- 다음 명령어를 실행하여 새 Next.js 프로젝트를 생성하세요:\n\n\n\n```js\nnpx create-next-app login-form-app\ncd login-form-app\n```\n\n2. **폼 처리 및 유효성 검사를 위해 필요한 패키지 설치:**\n\n```js\nnpm install react-hook-form @hookform/resolvers zod\n```\n\n# 폼 생성하기\n\n\n\n이 예제에서는 이메일과 비밀번호를 입력 필드로 사용하는 로그인 양식을 만들겠습니다.\n\n다음 내용을 가진 src 디렉토리에 LoginForm.tsx라는 새 파일을 생성하세요:\n\n```js\n// app/components/LoginForm.tsx\n\"use client\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { useRouter } from \"next/router\";\nimport { useForm } from \"react-hook-form\";\nimport * as z from \"zod\";\nimport { loginSchema } from \"../zodSchema/login\";\n\ntype FormData = z.infer<typeof loginSchema>;\n\nexport default function LoginForm() {\n  const router = useRouter();\n  const {\n    handleSubmit,\n    register,\n    formState: { errors, isSubmitting, isDirty, isValid },\n  } = useForm<FormData>({\n    resolver: zodResolver(loginSchema),\n  });\n\n  async function onSubmit(data: FormData) {\n    console.log(isSubmitting);\n    console.log(data);\n    // 이를 서버 액션으로 변경하거나 인증 API 엔드포인트를 가져오세요\n    await new Promise<void>((resolve) => {\n      setTimeout(() => {\n        resolve();\n      }, 2000); // 2초를 밀리초로 변환\n    });\n    router.push(\"/tweets\");\n  }\n\n  return (\n    <div className=\"selection:bg-rose-500 selection:text-white\">\n      <div className=\"flex min-h-screen items-center justify-center bg-rose-100\">\n        <div className=\"flex-1 p-8\">\n          <div className=\"mx-auto w-80 overflow-hidden rounded-3xl bg-white shadow-xl\">\n            {/* 양식 헤더 */}\n            <div className=\"rounded-bl-4xl relative h-44 bg-rose-500\">\n              <svg\n                className=\"absolute bottom-0\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n                viewBox=\"0 0 1440 320\"\n              >\n                <path\n                  fill=\"#ffffff\"\n                  fillOpacity=\"1\"\n                  d=\"M0,64L48,80C96,96,192,128,288,128C384,128,480,96,576,85.3C672,75,768,85,864,122.7C960,160,1056,224,1152,245.3C1248,267,1344,245,1392,234.7L1440,224L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z\"\n                ></path>\n              </svg>\n            </div>\n\n            {/* 양식 본문 */}\n            <div className=\"rounded-tr-4xl bg-white px-10 pb-8 pt-4\">\n              <h1 className=\"text-2xl font-semibold text-gray-900\">\n                다시 오신 것을 환영합니다!\n              </h1>\n              <form\n                className=\"mt-12\"\n                action=\"\"\n                method=\"POST\"\n                onSubmit={handleSubmit(onSubmit)}\n              >\n                {/* 이메일 입력 */}\n                <div className=\"relative\">\n                  <input\n                    {...register(\"email\", { required: true })}\n                    id=\"email\"\n                    name=\"email\"\n                    type=\"text\"\n                    className=\"peer h-10 w-full border-b-2 border-gray-300 text-gray-900 placeholder-transparent focus:border-rose-600 focus:outline-none\"\n                    placeholder=\"john@doe.com\"\n                    autoComplete=\"off\"\n                  />\n                  {errors?.email && (\n                    <p className=\"text-red-600 text-sm\">\n                      {errors?.email?.message}\n                    </p>\n                  )}\n                  <label\n                    htmlFor=\"email\"\n                    className=\"absolute -top-3.5 left-0 text-sm text-gray-600 transition-all peer-placeholder-shown:top-2 peer-placeholder-shown:text-base peer-placeholder-shown:text-gray-400 peer-focus:-top-3.5 peer-focus:text-sm peer-focus:text-gray-600\"\n                  >\n                    이메일 주소\n                  </label>\n                </div>\n\n                {/* 비밀번호 입력 */}\n                <div className=\"relative mt-10\">\n                  <input\n                    {...register(\"password\", { required: true })}\n                    id=\"password\"\n                    type=\"password\"\n                    name=\"password\"\n                    className=\"peer h-10 w-full border-b-2 border-gray-300 text-gray-900 placeholder-transparent focus:border-rose-600 focus:outline-none\"\n                    placeholder=\"비밀번호\"\n                    autoComplete=\"off\"\n                  />\n                  {errors?.password && (\n                    <p className=\"text-red-600 text-sm\">\n                      {errors?.password?.message}\n                    </p>\n                  )}\n                  <label\n                    htmlFor=\"password\"\n                    className=\"absolute -top-3.5 left-0 text-sm text-gray-600 transition-all peer-placeholder-shown:top-2 peer-placeholder-shown:text-base peer-placeholder-shown:text-gray-400 peer-focus:-top-3.5 peer-focus:text-sm peer-focus:text-gray-600\"\n                  >\n                    비밀번호\n                  </label>\n                </div>\n\n                {/* 제출 버튼 */}\n                <button\n                  type=\"submit\"\n                  disabled={!isDirty || !isValid || isSubmitting}\n                  className=\"mt-20 block w-full cursor-pointer rounded bg-rose-500 px-4 py-2 text-center font-semibold text-white hover:bg-rose-400 focus:outline-none focus:ring focus:ring-rose-500 focus:ring-opacity-80 focus:ring-offset-2 disabled:opacity-70\"\n                >\n                  {isSubmitting ? (\n                    <div role=\"status\">\n                      <svg\n                        aria-hidden=\"true\"\n                        className=\"inline w-6 h-6 mr-2 text-white animate-spin fill-rose-600 opacity-100\"\n                        viewBox=\"0 0 100 101\"\n                        fill=\"none\"\n                        xmlns=\"http://www.w3.org/2000/svg\"\n                      >\n                        {/* 스피너 애니메이션용 SVG */}\n                      </svg>\n                    </div>\n                  ) : (\n                    \"로그인\"\n                  )}\n                </button>\n              </form>\n\n              {/* 비밀번호 잊은 경우 링크 */}\n              <a\n                href=\"#\"\n                className=\"mt-4 block text-center text-sm font-medium text-rose-600 hover:underline focus:outline-none focus:ring-2 focus:ring-rose-500\"\n              >\n                비밀번호를 잊으셨나요?\n              </a>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n이제 LoginForm 컴포넌트를 만들었으므로 메인 페이지 컴포넌트에서 가져와 사용할 수 있습니다.\n\n\n\n페이지 디렉토리에 index.tsx라는 새 파일을 만들어서 아래 내용을 넣어주세요:\n\n```js\n// app/page.tsx\n\nimport LoginForm from \"../src/components/LoginForm\";\n\nexport default function HomePage() {\n  return (\n      <LoginForm />\n  );\n}\n```\n\n이 파일에서는 LoginForm 컴포넌트를 import하여 HomePage 컴포넌트 내에서 렌더링하고 있습니다.\n\n# Zod Schema\n\n\n\n다음으로, 로그인 양식 유효성 검사를 위해 Zod를 사용하여 loginSchema를 정의해 봅시다. 다음 내용을 포함하는 src/zodSchema 디렉토리에 login.ts라는 새 파일을 만들어주세요:\n\n```js\n// src/zodSchema/login.ts\n\nimport z from \"zod\";\n\nexport const loginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n});\n\nexport type User = z.infer<typeof loginSchema>;\n```\n\n이 스키마는 로그인 양식 필드에서 예상하는 데이터의 구조를 정의합니다.\n\n# 양식 테스트\n\n\n\n이제 클라이언트 측 유효성 검사가 포함된 완전히 작동하는 로그인 폼이 있습니다. 이 폼은 제출을 허용하기 전에 이메일이 올바른 형식인지와 비밀번호가 최소 8자 이상인지를 확인할 것입니다.\n\n폼을 테스트하려면 Next.js 애플리케이션을 실행하세요:\n\n```js\nnpm run dev\n```\n\n브라우저에서 http://localhost:3000을 방문하여 로그인 폼이 작동하는 것을 확인할 수 있습니다.\n\n\n\n# 요약\n\n이 튜토리얼에서는 React Hook Form을 사용하여 Next.js 애플리케이션에서 로그인 폼을 만드는 방법을 배웠습니다. 폼 처리와 유효성 검사를 위해 사용했습니다. 우리는 Zod를 사용하여 폼 스키마를 정의하고 유효성을 검사했습니다. 사용자가 잘못된 데이터를 입력하면 오류 메시지가 표시되고, 폼이 올바르게 작성될 때까지 제출 버튼이 비활성화됩니다. 이 구현은 React 및 Next.js 프로젝트에서 더 복잡한 폼을 만드는 좋은 시작점을 제공합니다.\n\n사용자 경험을 향상시키는 좋은 방법인 클라이언트 측 유효성 검사를 기억해주세요. 하지만 로그인 폼의 유일한 보안 계층이 되어서는 안 됩니다. 항상 강력한 서버 측 유효성 검사와 인증 메커니즘을 갖추어 애플리케이션을 잠재적인 보안 위협으로부터 보호해야 합니다.\n\n즐거운 코딩! 🚀","ogImage":{"url":"/assets/img/2024-05-12-CreatingaForminReactwithReactHookFormandNextjs134_0.png"},"coverImage":"/assets/img/2024-05-12-CreatingaForminReactwithReactHookFormandNextjs134_0.png","tag":["Tech"],"readingTime":9},{"title":"너드닷컴 서머 연습 프로그램 2024으로 잠재력을 발휘해보세요","description":"","date":"2024-05-12 20:28","slug":"2024-05-12-UnlockYourPotentialwithNerdsshSummerPracticeProgram2024","content":"\n\n<img src=\"/assets/img/2024-05-12-UnlockYourPotentialwithNerdsshSummerPracticeProgram2024_0.png\" />\n\n안녕하세요, 기술 열정가 여러분! 여러분의 기술을 향상시키고 혁신적인 학습 경험의 문을 열 준비가 되셨나요? Nerds.sh에서 여러분을 초대합니다. 여러분이 학문적 여정의 끝에 다가온 학생들을 위해 특별히 구성된 여름 실습 프로그램에 참여해보세요. 2024년 7월 1일부터 시작되는 3주 동안의 모험에 도전하고 여러분의 지적 능력을 도전하며 기술에 대한 열정을 일으킬 준비를 하세요!\n\nNerds.sh를 선택해야 하는 이유가 무엇일까요? Nerds.sh에서는 여러분의 기술 향상을 위한 이상적인 환경을 조성하며 여러분의 기술 경력의 진로를 열어줍니다. 이번 여름, 백엔드 개발을 위한 C# 및 현대적인 프런트엔드 체험을 위한 React에서 실용적인 경험을 쌓고, 다재다능한 소프트웨어 엔지니어가 되고자 하는 분들에게 최적입니다.\n\n# 왜 우리의 여름 실습을 선택해야 할까요?\n\n\n\n- 진짜 프로젝트, 실질적인 영향: 우리의 운영에 큰 영향을 미치는 프로젝트에 참여하세요. 이 프로그램을 마치면 성취와 기술이 가득한 포트폴리오를 갖게 될 거에요.\n- 전문적인 안내: 산업에서 가장 뛰어난 두뇌들로부터 배우세요. 업계 최고의 멘토들이 백엔드와 프론트엔드 개발의 복잡성을 안내하고 꼭 필요한 통찰력과 강력한 지원을 제공할 거예요.\n- 네트워킹과 협업: 기술과 혁신에 대한 공동 열정을 추구하는 동료들로 이루어진 커뮤니티에 참여하세요. 저희 인턴들은 종종 오랜 우정과 가치 있는 전문 네트워크를 형성하곤 해요.\n- 경력 발전: 우리는 단순히 훈련만 하는 게 아니에요. 많은 인턴들이 Nerds.sh 내에서 정규직으로 매끄럽게 전환했거나 기술 분야에서 다른 곳으로 날개를 펼쳤어요.\n- 너드적 재미의 문화: 관심을 가지고 지지며 극도로 너드적인 환경에 몰두하세요. 우리는 모두가 우수하게 발전할 수 있는 커뮤니티를 만들기를 소중히 여겨요.\n\n# 이번 여름 우리와 함께하고 싶나요?\n\n당신의 여정을 시작할 준비가 됐나요? Nerds.sh 여름 연습 프로그램에 지원하는 방법은 다음과 같습니다:\n\n- Nerds.sh Careers 방문하기\n- 기술 및 관련 경험을 강조하는 이력서 제출하기\n- 기다려 주세요 — 저희 팀원 중 한 분이 다음 단계를 논의하기 위해 연락을 드릴 거예요.\n\n\n\n사용신청이 열렸어요, 하지만 자리가 빨리 차고 있어요! 당신의 커리어를 슈퍼차지할 기회를 놓치지 마세요. 2024년 6월 10일까지 신청하세요. 그리고 이번 여름에 우리와 함께 열정적으로 참여해 보세요!\n\n미래의 기술 파이오니어여, 7월 1일에 만나요! 이 여름을 잊지 못할 것 같아요!","ogImage":{"url":"/assets/img/2024-05-12-UnlockYourPotentialwithNerdsshSummerPracticeProgram2024_0.png"},"coverImage":"/assets/img/2024-05-12-UnlockYourPotentialwithNerdsshSummerPracticeProgram2024_0.png","tag":["Tech"],"readingTime":2}],"page":"134","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}