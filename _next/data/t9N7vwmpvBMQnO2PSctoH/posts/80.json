{"pageProps":{"posts":[{"title":"리액트 컨퍼런스 2024 리액트 v19 RC","description":"","date":"2024-05-16 16:34","slug":"2024-05-16-ReactConf2024Reactv19RC","content":"\n\n<img src=\"/assets/img/2024-05-16-ReactConf2024Reactv19RC_0.png\" />\n\n리액트.js 컨프의 첫째 날이 끝났어요. 이 기대되는 컨퍼런스는 이전 것이 열린 지 거의 3년 후에 열렸어요. 리액트 업데이트도 기대돼었던 만큼 기다리고 기다린 만큼 너무 기대됐어요. 이 업데이트로 시작된 컨퍼런스에 대해 이 기사는 이제 그것에 전념할 거예요. 그리고 예상대로 — 버전 19가 릴리스 후보 상태로 이동했다는 것을 보셨다시피요. 전체 릴리스는 2주 내로 약속됐어요.\n\n전반적으로, 저는 next.js 개발자로서 대부분이 익숙했어요. 허브의 수십 개의 기사들이 이 업데이트의 거의 모든 부분에 대해 이미 언급해 왔으며, 저는 next.js에서 소개된 업데이트 일부에 대해 일부 다뤄봤어요.\n\n이 업데이트의 주요 방향은 \"높은 DX에서 높은 UX를 실현하는 것\" 이었다고 할 수 있어요. 최대한 간단한 코드로 최대의 성능을 달성하는 것이죠. 동시에, 업데이트의 일부에서는 서버 컴포넌트에 대해 거의 언급이 없었고, 간접적으로만 언급했어요. 그래서, 컨퍼런스로 넘어가 볼까요.\n\n<div class=\"content-ad\"></div>\n\n이러한 회의에서는 일반적으로 모든 것이 성장에 대한 설명으로 시작합니다. React 다운로드가 매년 10억 건에 이르렀습니다. 이 도구의 성장은 필연적으로 커뮤니티의 성장과 연결되어 있습니다. 따라서 Stackoverflow 통계도 보여졌는데, 개발자의 40%가 React를 웹 개발에 사용하고 있으며, 36%가 학습 중임을 나타냈습니다.\n\n![이미지](/assets/img/2024-05-16-ReactConf2024Reactv19RC_1.png)\n\n또한 흥미로운 사실은 React 기능이 이제는 프레임워크 안에서만 가능해졌다는 것이며, 이제 React.js에서 특정 프레임워크를 권장하기 시작했습니다. 슬라이드에는 remix, redwoodjs, next.js, expo가 보였습니다. 흥미로운 점은 이 목록에 React Router가 없다는 것입니다.\n\n네! 이제 React Router도 이 목록에 추가할 수 있습니다. 첫 번째 회의 보고서는 Ryan Florence로부터 받았습니다. 이제 React Router로 SPA뿐만 아니라 SSR 및 SSG도 수행할 수 있습니다. 이제 Vite와 함께 사용하여 가능한 기능입니다. 데이터 및 서버 컴포넌트 작업을 위한 훅이 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-16-ReactConf2024Reactv19RC_2.png\" />\n\n하지만 지금은 React.js의 변화로 돌아가 볼까요? 요소들을 조정하고 애플리케이션을 확장하는 문제가 다음에 설명되었습니다. JSX는 UI 개발에서 요소의 조정 문제를 해결했습니다. 그리고 load되는 요소들의 조정 문제를 해결하기 위해 Suspense가 추가되었습니다 (로딩 중에 무엇을 해야 하고 사용자에게 이 시간에 무엇을 보여줄지에 대한 문제). \n\nReact 19에서 다음 것들도 추가되었습니다:\n\n- Server components. 이러한 컴포넌트는 데이터를 로드하고 이후 컴포넌트로 이동하는 문제를 해결할 수 있습니다 (익숙한 props를 사용);\n- 메타데이터 포함. 메타태그는 어디든지 포함될 수 있습니다. React 자체가 올바른 위치에 추가하고 하나의 복사본만 남습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-16-ReactConf2024Reactv19RC_3.png)\n\n- 사전로드 방법. 수동으로 태그를 추가하는 것 외에도 링크 사전로드를 위한 방법들이 추가되었습니다 - preinit, preload, prefetchDNS 및 preconnect. 문서에는 preloadModule 및 preinitModule 방법도 설명되어 있지만, 이유는 불명이지만 이들은 회의에서 보여지지 않았습니다.\n\n![Image](/assets/img/2024-05-16-ReactConf2024Reactv19RC_4.png)\n\n- 스타일 임베딩. meta 태그와 유사하게, 스타일에 대한 작업이 진행될 것입니다. 그러나 여기에 중요도 옵션이 추가되었습니다 - 이에 따라 어떤 스타일이 더 중요한지(따라서 DOM에서 더 낮게 표시될 것인지)가 결정됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-16-ReactConf2024Reactv19RC_5.png)\n\n이제 컴포넌트의 스타일 로딩은 서스펜스로 추적됩니다. 즉, 컴포넌트가 렌더링되는 동안에만 로더를 표시할 수있는 것이 아니라 해당 스타일이 준비되는 동안에도 표시할 수 있습니다.\n\n![이미지](/assets/img/2024-05-16-ReactConf2024Reactv19RC_6.png)\n\n서버 컴포넌트의 등장으로 React는 서버 렌더링 책임을 더 맡게 되었으며 결과적으로 하이드레이션은 더 많은 논리와 잠재적인 문제를 가지게 되었습니다. React.js 팀은 하이드레이션 오류를 개선했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![ReactConf2024](/assets/img/2024-05-16-ReactConf2024Reactv19RC_7.png)\n\n실제 트리 구조 작업에 중요한 변화에 대한 추가적으로, React.js에서 양식과 상호 작용 논리가 업데이트되었습니다. 먼저, react-dom에 양식 컴포넌트가 포함되었으며, 이는 요소에 대한 중요한 변경 사항을 의미합니다. 그리고 그 이야기는 “action” 속성 변경에 대한 것입니다 — 양식을 onSubmit이나 네이티브 속성을 통해 제출하는 대안으로.\n\n![ReactConf2024](/assets/img/2024-05-16-ReactConf2024Reactv19RC_8.png)\n\naction을 추가하는 것 자체는 onSubmit과 같이 보이지만, 이벤트 대신 FormData를 즉시 가져옵니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![ReactConf2024Reactv19RC_9](/assets/img/2024-05-16-ReactConf2024Reactv19RC_9.png)\n\n또한, 폼 필드 및 버튼에 formAction prop이 추가되었습니다. 이는 동일한 방식으로 작동합니다.\n\n사용자가 폼 로직을 로드하기 전에도 즉시 폼 제출을 요청하면 클라이언트 액션을 사용하는 경우 제출이 연기되고 로직이 준비되자마자 수행됩니다. 서버 액션의 경우 클라이언트 js가 필요하지 않기 때문에 즉시 제출됩니다.\n\n그러나 기본 차이 외에도 폼 제출과 상호 작용에 중요한 변화가 있습니다 - 이들은 새로운 훅입니다. useOptimistic, useFormStatus 및 useActionState.\n\n\n<div class=\"content-ad\"></div>\n\nSam Selikoff 씨가 \"React unpacked: A Roadmap to React 19\"라는 프레젠테이션에서 사용 예시를 공유했습니다. 예를 들어, onSubmit을 action + useActionState로 대체한 내용은 이런 식입니다:\n\n![Image](/assets/img/2024-05-16-ReactConf2024Reactv19RC_10.png)\n\n그리고 낙관적 렌더링을 추가할 수 있습니다:\n\n![Image](/assets/img/2024-05-16-ReactConf2024Reactv19RC_11.png)\n\n<div class=\"content-ad\"></div>\n\n그리고 다시 레포트에서 중요한 변경 사항으로 돌아가 보겠습니다. 비교적 작은 변경 사항이 나열되었지만 매우 가치 있습니다. React.js 19에서는 forwardRef 없이도 함수형 컴포넌트에 ref를 props로 전달할 수 있습니다. 즉석에서 가능합니다. \n\n![이미지](/assets/img/2024-05-16-ReactConf2024Reactv19RC_12.png)\n\n또한, 컴포넌트에 ref를 전달할 때 언마운트 시 콜백을 반환할 수도 있습니다.\n\n![이미지](/assets/img/2024-05-16-ReactConf2024Reactv19RC_13.png)\n\n<div class=\"content-ad\"></div>\n\n최종 열쇠 변경은 React 컴파일러였습니다. 내장되어 있는 메모이제이션을 갖춘 고급 로더입니다. React와 함께 응용 프로그램에서 메모이제이션을 자동으로 설정할 수 있습니다. Lauren Tan은 발표에서 이에 대해 자세히 설명했습니다. \"React 컴파일러 사례 연구\".\n\n그래서 메모이제이션을 설정하는 방법을 이해하기 위해 React는 다시 렌더링을 트리거하는 위치부터 끝점까지의 관계를 분석합니다:\n\n![이미지](/assets/img/2024-05-16-ReactConf2024Reactv19RC_14.png)\n\n이러한 관계에 따라 컴파일러는 의존성의 전체 그래프를 상상할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![ReactConf2024](/assets/img/2024-05-16-ReactConf2024Reactv19RC_15.png)\n\n그런 다음이 연결에 따라 필요한 종속성으로 메모이제이션을 설정하세요. 이 경우 노래가 변하지 않기 때문에 필터링된 노래(filteredSongs)는 동일해야 합니다(노래에 종속성이 있는 메모이제이션으로 처리됩니다). 그리고 setSong에 의해 노래가 변경되면 NowPlaying이 다시 렌더링되어야 합니다(song에 종속성이 있는 메모이제이션으로 처리됩니다).\n\n![ReactConf2024](/assets/img/2024-05-16-ReactConf2024Reactv19RC_16.png)\n\n\"최대한 간단한 코드로 최대의 성능을 내세요.\"\n\n\n<div class=\"content-ad\"></div>\n\n좋은 해결책이지만, 실제로 메모이제이션을 어떻게 설정할지가 흥미로울 것입니다. 개발자가 이를 작성해야 할 위치와 이 논리를 컴파일러에게 맡겨 복잡하지 않게 유지할 가치가 있는 위치를 볼 수 있을 것입니다.\n\n바벨을 지원하는 모든 주요 프레임워크와 빌드 시스템에 지금 바로 컴파일러를 설치할 수 있습니다. 이미 인스타그램, 페이스북, 그리고 댄 아브라모프가 현재 일하고 있는 회사 Bluesky에서 사용되고 있습니다.\n\n또한, 코드 최적화와 관련된 모든 문제를 지적해주는 eslint 플러그인을 설치하여 컴파일의 신뢰성과 품질을 높일 수 있습니다. 일반적으로, 이 플러그인은 컴파일러와는 독립적으로 사용할 수 있습니다.\n\n```js\nnpm install eslint-plugin-react-compiler\n```\n\n<div class=\"content-ad\"></div>\n\n당신은 커맨드 라인 유틸리티를 사용할 수도 있어요. 컴파일러가 어플리케이션을 최적화할 가능성을 점검해 줄 거에요.\n\n```js\nnpx react-compiler-healthcheck\n```\n\n다른 혁신은 Lydia Hallie에 의해 공유되었어요 — 사용 함수. 네, 실수가 아니에요 — 훅이 아니에요.\n\n<img src=\"/assets/img/2024-05-16-ReactConf2024Reactv19RC_17.png\" />\n\n\n<div class=\"content-ad\"></div>\n\nuse와 hooks의 주요 차이점은 use는 조건 내에서 사용할 수 있다는 것입니다.\n\n![이미지](/assets/img/2024-05-16-ReactConf2024Reactv19RC_18.png)\n\nuse 자체는 프라미스 또는 컨텍스트를 사용할 수 있습니다. use에 어떤 인수가 전달될지 확신할 수 없는 상황을 상상하기 어려운데, 왜 두 개의 독립적인 함수를 만들지 않는 것인지 알 수 없습니다.\n\n마지막으로, 놀라운 보고서, 발표, 예제 및 일반적인 성과를 언급하겠습니다. React.js 팀은 모든 개선 사항의 가능성을 보여줄 수 있었으며 (next.js 팀, 용서해 주지만 가까이 서지도 못했습니다). 또한 즐거운 차이점으로, React.js 팀은 fetch API의 재작성을 코어에 포함하지 않기로 결정하고 이미 완료된 변경 사항을 되돌렸다고 언급하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n일반적인 변경 목록은 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-16-ReactConf2024Reactv19RC_19.png)","ogImage":{"url":"/assets/img/2024-05-16-ReactConf2024Reactv19RC_0.png"},"coverImage":"/assets/img/2024-05-16-ReactConf2024Reactv19RC_0.png","tag":["Tech"],"readingTime":7},{"title":"SQL 데이터베이스와 대화하는 방법 Vannaai를 통해 GPT-4o를 활용하세요","description":"","date":"2024-05-16 16:31","slug":"2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai","content":"\n\n## OpenAI GPT 4o를 활용한 텍스트-SQL 파이프라인 만들기\n\n![image](/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_0.png)\n\nOpenAI가 최신 주력 모델인 GPT 4o를 공개했습니다. 이 고급 모델은 멀티모달 기능을 갖추고 있어 이미지, 텍스트, 비디오 입력을 처리하여 어떠한 이전 모델보다 뛰어난 답변을 생성할 수 있습니다. 이 게시물은 GPT 4o와 Vanna AI를 사용하여 데이터베이스와 대화할 수 있는 텍스트-SQL 파이프라인을 구축하는 방법을 강조합니다.\n\n![image](/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_1.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_2.png\" />\n\n# 시작하기\n\n```js\nfrom vanna.openai import OpenAI_Chat\nfrom vanna.vannadb import VannaDB_VectorStore\n\nclass MyVanna(VannaDB_VectorStore, OpenAI_Chat):\n    def __init__(self, config=None):\n        MY_VANNA_MODEL = # https://vanna.ai/account/profile에서 모델 이름을 가져와주세요\n        VannaDB_VectorStore.__init__(self, vanna_model=MY_VANNA_MODEL, vanna_api_key=MY_VANNA_API_KEY, config=config)\n        OpenAI_Chat.__init__(self, config=config)\n\n# OpenAI api_key를 추가해주세요\nvn = MyVanna(config={'api_key': 'sk-...', 'model': 'gpt-4o'})\n```\n\n# 데이터베이스 연결하기\n\n<div class=\"content-ad\"></div>\n\n바나에는 내장된 커넥터로 다음 8가지 데이터베이스에 연결할 수 있어요 (다른 데이터베이스에 연결하려면 몇 줄의 추가 코드가 필요해요):\n\n- Postgres SQL\n- Oracle\n- DuckDB\n- MySQL\n- SQLite\n- Big Query\n- Snowflake\n- Microsoft SQL\n\n문서를 참고하면 특정 데이터베이스에 연결하는 방법을 알 수 있어요. 이 글에서는 DuckDB StackOverflow 데이터베이스에 연결할 거에요. 데이터베이스는 여기에 있어요!\n\n```js\n#덕DB 데이터베이스에 연결하는 방법이에요\nvn.connect_to_duckdb(url='motherduck:[<database_name>]?motherduck_token=<token>&saas_mode=true')\n```\n\n<div class=\"content-ad\"></div>\n\n# 훈련\n\n![이미지1](/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_3.png)\n\n![이미지2](/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_4.png)\n\n![이미지3](/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_5.png)\n\n<div class=\"content-ad\"></div>\n\n# Plan (Information Schema)에 대한 훈련\n\n```js\n# 정보 스키마 쿼리는 데이터베이스에 따라 조정이 필요할 수 있습니다. 이것은 좋은 시작점입니다.\ndf_information_schema = vn.run_sql(\"SELECT * FROM INFORMATION_SCHEMA.COLUMNS\")\n```\n\n```js\n# 정보 스키마를 LLM에서 참조할 수 있도록 작은 조각으로 나눕니다.\nplan = vn.get_training_plan_generic(df_information_schema)\nplan\n```\n\n```js\n# 계획이 마음에 들면 주석 처리하고 실행하여 훈련을 시작하세요.\nvn.train(plan=plan)\n```\n\n<div class=\"content-ad\"></div>\n\n# DDL 훈련\n\n```js\n# duckDB에서 describe 문은 모든 테이블에 대한 DDL을 가져올 수 있습니다\nvn.train(ddl=\"DESCRIBE SELECT * FROM Stackoverflow.users;\")\n```\n\n# SQL 문장에 대한 훈련\n\n```js\n# SQL 문장에 대한 훈련 예시입니다\nvn.train(\nquestion=\"가장 많은 배지를 가진 상위 10명의 사용자는 누구인가요?\"\n,sql=\"\"\"SELECT UserId, COUNT(*) AS badge_count\nFROM stackoverflow.main.badges\nGROUP BY UserId\nORDER BY badge_count DESC\nLIMIT 10\n\"\"\")\n# 다른 예시\nvn.train(\nquestion=\"가장 많은 답변을 한 사용자와 가장 적은 질문을 한 사용자 간의 총 답변 차이는 얼마인가요?\", \n,sql=\"SELECT MAX(answer_count) - MIN(answer_count) AS difference\nFROM (\n    SELECT OwnerUserId, COUNT(*) AS answer_count\n    FROM stackoverflow.main.posts\n    WHERE PostTypeId = 2\n    GROUP BY OwnerUserId\n) AS answer_counts;\n\")\n```\n\n<div class=\"content-ad\"></div>\n\n# 문서화를 통한 훈련\n\n```js\n# 문서화를 통해 맥락 정보를 제공할 수 있습니다.\nvn.train(documentation=\"해당 연도 가장 많은 답변을 낸 사용자를 대 마스터라고 부릅니다\")\n```\n\n훈련 데이터를 확인하려면 vn.get_training_data()를 사용하실 수 있습니다.\n\n```js\n# vn.ask는 다음 함수들을 순차적으로 실행하며, 각각 개별적으로 실행될 수 있습니다.\n# 1. vn.generate_ql\n# 2. vn.run_sql\n# 3. vn.generate_plotly_code\n# 4. vn.get_plotly_figure\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n# Vanna 훈련 후 질문을하는 방법입니다\nvn.ask('뱃지 수가 가장 많은 상위 10 명의 사용자를 찾아주세요?')\n```\n\n![이미지](/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_6.png)\n\n![이미지](/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_7.png)\n\n# Flask 앱 사용하기\n  \n\n<div class=\"content-ad\"></div>\n\nVanna는 내장 UI Flask 앱이 함께 제공됩니다. 주피터 노트북이나 Python 스크립트 내에서 실행할 수 있습니다.\n\n```js\nfrom vanna.flask import VannaFlaskApp\napp = VannaFlaskApp(vn)\napp.run()\n```\n\n<img src=\"/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_8.png\" />\n\n이렇게 GPT 4o를 텍스트에서 SQL로 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 성능 비교\n\nGPT 4o와 이와 같은 클래스의 다른 모델들 사이의 비교 결과를 아래에서 확인할 수 있습니다. GPT 4o는 ChatGPT 4 turbo의 59%와 Claude Opus의 56%에 비해 최고 수준인 61%의 정확도로 성능을 발휘합니다.\n\n![image](/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_9.png)\n\n읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_0.png"},"coverImage":"/assets/img/2024-05-16-ChatwithyourSQLdatabaseusingGPT4oviaVannaai_0.png","tag":["Tech"],"readingTime":5},{"title":"백엔드 서버를 작성하면 어드민 대시보드를 무료로 제공받을 수 있습니다","description":"","date":"2024-05-16 16:30","slug":"2024-05-16-WriteabackendserverandyougetanAdminDashboardforfree","content":"\n\n테오(Teo)는 당신을 위해 관리자 대시보드를 생성할 수 있는 훌륭한 웹 프레임워크입니다.\n\n![Teo Admin Dashboard](https://miro.medium.com/v2/resize:fit:1400/1*1SeQK64Z5ERRtbDqA4sEmQ.gif)\n\n이 기사에서는 당신에게 Teo를 사용하여 간단한 백엔드 서버를 작성하고 무료로 생성된 관리자 대시보드를 보여드릴 것입니다.\n\n# 프로젝트 생성\n\n<div class=\"content-ad\"></div>\n\n새로운 디렉토리를 만들어서 그 안에 \"schema.teo\"라는 파일을 생성합시다. 문법 강조와 자동 완성을 위해 이 VSCode 플러그인을 설치할 수 있어요.\n\n```js\nconnector {\n  provider: .sqlite,\n  url: \"sqlite:./database.sqlite\",\n}\n\nserver {\n  bind: (\"0.0.0.0\", 5054)\n}\n\nadmin {\n  dest: \"../hello-teo-admin-dashboard\",\n  host: .inject(\"process.env.TEO_HOST\"),\n  languages: [.enUs, .enUk, .de, .es, .fr, .he, .hi, .ja, .ko, .zhCn, .zhTw]\n}\n\n@identity.tokenIssuer($identity.jwt(expired: 3600 * 24 * 365))\n@identity.jwtSecret(ENV[\"JWT_SECRET\"]!) @admin.administrator\nmodel Root {\n  @id @autoIncrement @readonly\n  id: Int\n  @unique @onSet($if($presents, $isEmail)) @identity.id\n  email: String\n  @writeonly @onSet($presents.bcrypt.salt) @admin.secureInput\n  @identity.checker($get(.value).presents.bcrypt.verify($self.get(.password).presents))\n  password: String\n\n  include handler identity.signIn\n  include handler identity.identity\n}\n\n@identity.tokenIssuer($identity.jwt(expired: 3600 * 24 * 365))\n@identity.jwtSecret(ENV[\"JWT_SECRET\"]!) @admin.administrator\nmodel Admin {\n  @id @autoIncrement @readonly\n  id: Int\n  @unique @onSet($if($presents, $isEmail)) @identity.id\n  email: String\n  @unique @identity.id\n  phoneNo: String\n  @writeonly @onSet($presents.bcrypt.salt) @admin.secureInput\n  @identity.checker($get(.value).presents.bcrypt.verify($self.get(.password).presents))\n  password: String\n\n  include handler identity.signIn\n  include handler identity.identity\n}\n\nenum Sex {\n  male\n  female\n}\n\nmodel Record {\n  @id @autoIncrement @readonly\n  id: Int\n  string: String\n  bool: Bool\n  int: Int\n  float: Float\n  decimal: Decimal\n  date: Date\n  dateTime: DateTime\n  sex: Sex\n}\n\nmodel NullableRecord {\n  @id @autoIncrement @readonly\n  id: Int\n  string: String?\n  bool: Bool?\n  int: Int?\n  float: Float?\n  decimal: Decimal?\n  date: Date?\n  dateTime: DateTime?\n  sex: Sex?\n}\n\nmiddlewares [identity.identityFromJwt(secret: ENV[\"JWT_SECRET\"]!)]\n\nautoseed dataset default {\n  group Admin {\n    record admin {\n      email: \"admin@gmail.com\",\n      phoneNo: \"13588888888\",\n      password: \"Aa123456\"\n    }\n  }\n  group Root {\n    record root {\n      email: \"root@gmail.com\",\n      password: \"Aa123456\"\n    }\n  }\n}\n```\n\n테오 스키마 언어는 아주 자세하고 읽기 쉽습니다. 이 스키마에서 다음과 같은 사항을 선언합니다:\n\n- HTTP 서버가 어떻게 바인딩되는지\n- 어떤 데이터베이스에 연결하는지\n- 어디에 우리의 Admin 대시보드 코드를 생성하는지\n- 인증 미들웨어\n- 모델 정의\n- 시드 데이터\n\n<div class=\"content-ad\"></div>\n\n우리는 딱 100줄로 많은 것들을 선언했어요. 구문이 매우 간결해요.\n\n인증 미들웨어와 모델 데코레이터에서 \"JWT_SECRET\"라는 환경 변수가 있을 거에요. 이 내용을 담은 \" .env\" 파일을 만들어봐요.\n\n```js\nJWT_SECRET=my_top_secret\n```\n\n# Teo 설치하기\n\n<div class=\"content-ad\"></div>\n\n당신의 기술 스택과 선호도에 따라 Rust 버전, Node.js 버전 또는 Python 버전을 설치할 수 있어요. 이 중 하나를 선택해 주세요. \n\nRust 버전을 설치하려면 \"cargo\"를 사용하세요.\n\n```js\ncargo install teo\n```\n\nNode.js 버전을 설치하려면, 이 명령을 실행하여 로컬 디렉토리에 설치하세요.\n\n<div class=\"content-ad\"></div>\n\n\nnpm init -y\nnpm install typescript ts-node -D\nnpx tsc --init\nnpm install @teocloud/teo\n\n\n파이썬 버전을 설치하려면 venv를 추천합니다.\n\n\npython3.12 -m venv .venv\nsource .venv/bin/activate\npip install teo\n\n\nTeo는 다른 웹 프레임워크와 마찬가지로 프로그래밍 코드로 라우트 핸들러를 작성하고 Teo의 ORM API에 접근할 수 있습니다. 이 글에서는 그를 다루지 않을 거예요.\n\n\n<div class=\"content-ad\"></div>\n\n# 어드민 대시보드 생성하기\n\nTeo를 설치한 후, 이 몤령어를 실행하여 어드민 대시보드 코드를 생성하세요. 어드민 대시보드는 TypeScript와 React로 작성되어 있습니다. 완전히 사용자 정의가 가능합니다. 생성된 코드와 사용자 확장 코드는 충돌하지 않습니다.\n\nRust 명령어:\n\n```js\ncargo teo generate admin\n```\n\n<div class=\"content-ad\"></div>\n\nNode.js 명령어:\n\n```bash\nnpx teo generate admin\n```\n\nPython 명령어 (venv를 활성화한 상태):\n\n```bash\nteo generate admin\n```\n\n<div class=\"content-ad\"></div>\n\n# 서버 시작하기\n\n서버를 시작하려면 'teo serve' 명령을 사용하세요.\n\nRust 명령:\n\n```js\ncargo teo serve\n```\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식의 표:\n\n| 언어 | 명령어 |\n|------|---------|\n| Node.js | `npx teo serve` |\n| Python (venv 활성화) | `teo serve` |\n\n<div class=\"content-ad\"></div>\n\n# 관리자 대시보드 시작하기\n\n생성된 관리자 대시보드가 있는 디렉토리로 이동하세요. 의존성을 설치하고 웹팩 서버를 시작하세요. 시스템에 Node.js가 설치되어 있어야 합니다.\n\n```js\nnpm install\nnpm start\n```\n\n# 브라우저에서 localhost:9000 열기\n\n<div class=\"content-ad\"></div>\n\n마지막 단계는 브라우저를 열어 확인해 보는 거예요. 여기 로그인 자격 증명이 있어요:\n\n- 관리자 이메일: admin@gmail.com\n- 루트 이메일: root@gmail.com\n- 비밀번호: Aa123456\n\n계정 중 하나를 선택해서 로그인하세요.\n\n이제 레코드를 나열하거나 생성, 업데이트, 삭제할 수 있어요. 차트, 그래프 및 표와 같은 더 많은 기능이 나중에 구현될 거예요.\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*vEfD5wQTIrAAsGBqxOapJw.gif)\n\n# 요약\n\n이 글이 마음에 드셨다면, GitHub에서 별을 클릭하여 우리에게 격려를 해주세요.\n\nGitHub: https://github.com/teocloud/teo\n\n<div class=\"content-ad\"></div>\n\n공식 웹사이트: [https://teodev.io](https://teodev.io)\n\n더욱 개선해 나갈 것이며, 여러분의 요구에 맞게 더 많은 기능을 추가할 예정입니다.","ogImage":{"url":"/assets/img/2024-05-16-WriteabackendserverandyougetanAdminDashboardforfree_0.png"},"coverImage":"/assets/img/2024-05-16-WriteabackendserverandyougetanAdminDashboardforfree_0.png","tag":["Tech"],"readingTime":5},{"title":"다음은 Nextjs 및 GSAP를 사용하여 간단한 패럴랙스 효과를 만드는 방법입니다","description":"","date":"2024-05-16 16:28","slug":"2024-05-16-CreateSimplifiedParallaxEffectsUsingNextjsGSAP","content":"\n\n<img src=\"/assets/img/2024-05-16-CreateSimplifiedParallaxEffectsUsingNextjsGSAP_0.png\" />\n\n나는 전에 패럴랙스에 초점을 맞춘 디자인에 대해 걱정했었어. 시각적으로 매력적이라고 생각했지만, 모든 요소들을 함께 동작시키는 것이 어려울 것이라고 생각했어. 그러나 지난 주말, Next.js와 GSAP를 사용하여 다시 한 번 시도하기로 결정했어.\n\n모든 것이 얼마나 쉽게 맞물려 있는지에 놀랐어. 모바일 화면을 위해 디자인을 적응시키는 것은 여전히 어려웠지만, 다른 구름 세트를 만들어야 했지만, 그 외에는 모든 것이 그대로 유지되었어.\n\n# GSAP이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nGSAP(Greensock Animation Platform)은 개발자들이 구성 객체, 트윈 및 타임라인을 제공하여 고성능 애니메이션 웹사이트를 만들 수 있도록 돕는 JavaScript 라이브러리입니다.\n\n트윈: 트윈은 원하는 개체, 지속 시간 및 애니메이션을 적용하려는 속성(예: 축)을 가져가는 애니메이션 속성 세터입니다.\n\n타임라인: 타임라인은 여러 트윈을 순차적으로 배치하고 애니메이션을 배치하고 아름다운 애니메이션 순서를 만들 수 있도록 도와주는 시퀀싱 도구입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*xmynutJ-2WQjKwB00KD34Q.gif)\n\n<div class=\"content-ad\"></div>\n\n# 5분 이내에 패럴랙스 파워 페이지를 만드는 방법\n\n## 단계 1 :\n\nNextJs, TailWind CSS 및 GSAP가 주로 필요한 모든 종속성을 설치합니다.\n\n먼저 시스템에 Node.js 18.17 이상이 설치되어 있는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n- 새로운 Next.js 앱을 생성하려면 터미널을 열고 다음 명령을 실행하세요: npx create-next-app@latest\n- 프로젝트를 구성하기 위해 프롬프트에 따라 따라가세요 (예: 프로젝트 이름, TypeScript, ESLint, Tailwind CSS 등). Next.js는 이제 TypeScript, ESLint 및 Tailwind CSS를 기본으로 제공합니다.\n\nGSAP를 설치하려면 npm install gsap 또는 yarn add gsap을 실행하세요\n\n## 단계 2:\n\nFigma에서 디자인을 만드세요. 매혹적인 Parallax를 만들려면 여러 구성 요소가 동시에 작동해야 하며, 진행하기 전에 디자인을 확인하는 것이 좋습니다. Figma의 Pen 도구를 사용하면 기본 디자인을 쉽게 만들 수 있습니다 (위에서 만든 것과 같이). 또는 제가 만든 이미지를 재사용할 수도 있습니다 (링크는 끝에 공유됩니다).\n\n<div class=\"content-ad\"></div>\n\nFigma Pen Tool 비디오: `add_link_here`\n\n이미지를 NextJs 컴포넌트로 가져와서 position: absolute로 층을 만들어보세요.\n\n```js\nconst parallaxCloudBackgroundStyles = 'z-10 absolute bottom-[0vw] w-[100vw]';\nconst parallaxCloudForegroundStyles = 'z-30 absolute bottom-[0vw] w-[100vw]';    \nconst parallaxCloudTopLayerStyles = 'z-30 absolute bottom-[-5vw] w-[100vw]';\nconst parallaxStarStyles = 'absolute top-0 w-[100vw]';\nconst parallaxSunStyles = 'z-0 absolute top-[30%] left-[35%] right-[35%] w-[30%]';\nconst parallaxFlightStyles = 'z-20 rotate-45 absolute bottom-[-15%] left-[5%] w-[30vw]';\n\n<img ref={sun} src=\"./img/Sun.png\" className={parallaxSunStyles}/>\n<img ref={cloudlayer1} src=\"./img/Wave L1.png\" className={parallaxCloudBackgroundStyles}/>            \n<img ref={flight} src=\"./img/Designer.png\" className={parallaxFlightStyles}/>\n<img ref={cloudlayer2} src=\"./img/Wave L2.png\" className={parallaxCloudForegroundStyles}/>\n<img ref={cloudlayer3} src=\"./img/Wave L3.png\" className={parallaxCloudForegroundStyles}/>\n<img ref={cloudlayer4} src=\"./img/Wave L4.png\" className={parallaxCloudTopLayerStyles}/>\n<img ref={starrySky} src=\"./img/Starry Sky.png\" className={parallaxStarStyles}/>\n```\n\n## z-index란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n웹 디자인에서는 z-index라는 유사한 것이 있습니다. 이는 이미지, 버튼 또는 텍스트와 같은 요소가 웹페이지에 나타나는 순서를 제어하는 데 도움을 줍니다.\n\nTailwind CSS는 요소에 적용할 수 있는 일련의 미리 정의된 z-index 클래스를 제공합니다. 이러한 클래스는 z-0(뒷배경의 z-index를 0으로 설정)부터 z-50(뒷배경의 z-index를 50으로 설정)까지 다양합니다. 위 코드에서는 z-index를 사용하여 컴포넌트를 층으로 구분했습니다. 가장 아래층은 z-0이어야 하며 위로 올라갈수록 증가해야 합니다.\n\n## 단계 3: 각 요소에 대한 Refs 만들기\n\n각 요소에 대한 Ref를 생성하고 해당 Ref를 요소에 부착해야 합니다. 이렇게 하면 각 층의 애니메이션을 제어할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst parallaxRef = useRef(null);\nconst cloudlayer1 = useRef(null);\nconst cloudlayer2 = useRef(null);\nconst cloudlayer3 = useRef(null);\nconst cloudlayer4 = useRef(null);   \nconst flight = useRef(null); \nconst sun = useRef(null);\nconst starrySky = useRef(null);   \n```\n\n## 단계 4: 타임라인에 모든 애니메이션 시퀀스 추가하기\n\nGSAP의 힘을 발휘할 시간입니다.\n\n- GSAP 콘텍스트 설정:\ngsap.context(() =` ' ... ')를 사용하여 GSAP 콘텍스트를 만들기 시작합니다. 콘텍스트를 사용하면 특정 범위 내에서 애니메이션 및 플러그인을 정의할 수 있습니다.\n- ScrollTrigger 플러그인 등록: gsap.registerPlugin(ScrollTrigger)를 사용하여 ScrollTrigger 플러그인을 등록합니다. ScrollTrigger 플러그인은 스크롤 위치를 기반으로 애니메이션을 만드는 데 필수적입니다.\n- 타임라인 생성: 이후, gsap.timeline(' ... ')를 사용하여 타임라인을 만듭니다.\n타임라인은 여러 애니메이션을 순차적으로 배치하고 제어하는 컨테이너입니다. defaults 객체는이 타임라인 내 모든 애니메이션에 대한 기본 속성을 지정합니다(이 경우 1초의 지속 시간).\n- ScrollTrigger 구성: 타임라인에 대한 ScrollTrigger를 설정합니다:\n\n<div class=\"content-ad\"></div>\n\n- 트리거(trigger): 애니메이션을 트리거하는 요소(이 경우 parallaxRef.current).\n- 시작(start): 애니메이션이 시작되는 트리거 요소의 위치(\"top top\"은 트리거 요소의 맨 위가 뷰포트의 맨 위에 닿을 때를 의미합니다).\n- 끝(end): 애니메이션이 끝나는 트리거 요소의 위치(\"5000 bottom\"은 트리거 요소의 맨 아래가 뷰포트의 맨 위에서 5000픽셀 떨어진 지점에 닿을 때를 의미합니다).\n- scrub: 스크롤할 때 애니메이션 진행을 부드럽게 합니다.\n- pin: 애니메이션 중에 트리거 요소를 고정시킵니다.\n- onUpdate: 스크롤 위치가 업데이트될 때마다 실행되는 콜백 함수입니다. 여기서는 스크롤 진행에 따라 배경을 조정합니다.\n\n```js\nuseEffect(() => {\n        let ctx = gsap.context(() => {\n            gsap.registerPlugin(ScrollTrigger);\n            var timeline = gsap.timeline({\n                defaults: { duration: 1},\n                scrollTrigger: {\n                    trigger: parallaxRef.current,\n                    start: \"top top\",\n                    end: \"5000 bottom\",\n                    scrub: true,\n                    pin: true,\n                    onUpdate: (self) => {\n                        setBackground(Math.ceil(self.progress * 100 + 30))\n                        console.log(Math.ceil(self.progress * 100))\n                    },\n                },\n            });\n      });\n});\n```\n\n## STEP 5 : 애니메이션 적용\n요소 애니메이션:\n\n- 타임라인 내부에서 애니메이션 정의:\ntimeline.to (flight.current, ' y: \"-=1500\", x: \"+=1500\" ', 0): 이 코드는 flight 요소를 위(y: \"-=1500\")로 이동하고 대각선(x: \"+=1500\")으로 애니메이션합니다.\n- 제로 옵셋으로 시작합니다(마지막 인수가 0인 이유는 애니메이션이 즉시 시작됨을 의미합니다).\n\n<div class=\"content-ad\"></div>\n\n다른 요소들도 비슷하게 애니메이션을 줄 수 있어요. 여기 한 가지 팁은 양의 값과 음의 값의 최종 오프셋 값을 섞어서 더 좋은 효과를 얻을 수 있다는 거예요.\n\n```js\ntimeline.to(\n    flight.current,\n    {\n        y: \"-=1500\",\n        x: \"+=1500\"\n    },\n    0\n);\ntimeline.to(\n    sun.current,\n    {\n        y: \"-=400\"\n    },\n    0\n);\ntimeline.to(\n    starrySky.current,\n    {\n        y: \"-=150\"\n    },\n    0\n);\n```\n\n## 단계 5: 웹사이트를 실행하세요\n\nnpm run dev — 코드를 실시간으로 확인해보세요\n\n<div class=\"content-ad\"></div>\n\n여기서 작동 코드를 찾을 수 있어요: [Github.com/abhirupa-tech](Github.com/abhirupa-tech)\n1대1 통화하고 싶나요? 저와 연락하려면 [여기를 클릭](https://example.com)\n\n좋은 코딩되세요!","ogImage":{"url":"/assets/img/2024-05-16-CreateSimplifiedParallaxEffectsUsingNextjsGSAP_0.png"},"coverImage":"/assets/img/2024-05-16-CreateSimplifiedParallaxEffectsUsingNextjsGSAP_0.png","tag":["Tech"],"readingTime":6},{"title":"쿼커스 대 Go 프레임워크 Hello World 성능","description":"","date":"2024-05-16 16:27","slug":"2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance","content":"\n\n\n![Quarkus vs Go frameworks Hello World Performance](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_0.png)\n\nThis is a requested article. Readers have asked for an up-to-date comparison of Quarkus (one of the fastest choices in the Java world) and popular Go frameworks like Gin, Fiber, and Echo.\n\nIn this article, we will focus on the simplest \"Hello World\" use case. We acknowledge that a \"Hello World\" example is far from real-world scenarios and not the ideal use case for benchmarking. We will follow up with another article that will perform database reads (I/O-bound operations).\n\nA similar comparison with Spring Boot (powered by virtual threads) can be seen here:\n\n\n<div class=\"content-ad\"></div>\n\n# 테스트 환경 구성\n\n모든 테스트는 16G 램 및 8+4 CPU 코어를 갖춘 MacBook Pro M2에서 실행되었습니다. 사용된 소프트웨어 버전은 다음과 같습니다:\n\n- Quarkus 3.10.0 (Java 21.0.3)\n- Go 1.22.3\n\n테스트는 Bombardier 로드 테스터를 사용하여 수행되었습니다.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션 코드는 다음과 같습니다:\n\nQuarkus\n\n```js\n// application.properties\n\nquarkus.http.port=3000\n\n// HelloWorldApplication.java\n\npackage org.acme;\n\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\nimport io.smallrye.common.annotation.NonBlocking;\n\n@Path(\"/\")\npublic class HelloWorldApplication {\n\n    @GET\n    @NonBlocking\n    @Produces(MediaType.TEXT_PLAIN)\n    public String hello() {\n        return \"Hello World!\";\n    }\n}\n```\n\nGin\n\n<div class=\"content-ad\"></div>\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tr := gin.New()\n\n\tr.GET(\"/\", func(c *gin.Context) {\n\t\tc.String(http.StatusOK, \"Hello world!\")\n\t})\n\n\tr.Run(\":3000\")\n}\n```\n\nFiber\n\n```go\npackage main\n\nimport (\n\t\"github.com/gofiber/fiber\"\n)\n\nfunc main() {\n\tapp := fiber.New()\n\tport := \":3000\"\n\n\tapp.Get(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendString(\"Hello World!\")\n\t})\n\n\tapp.Listen(port)\n}\n```\n\nEcho\n```go\n// Your Echo code goes here\n```\n\n<div class=\"content-ad\"></div>\n\n\n# Results\n\n100개의 동시 연결에 대한 테스트를 진행하였으며, 총 10백만 개의 요청이 실행되었습니다.\n\n다음은 차트 형태로 표시된 결과입니다:\n\n\n<div class=\"content-ad\"></div>\n\n\n![Quarkus vs Go frameworks - Hello World performance 1](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_1.png)\n\n![Quarkus vs Go frameworks - Hello World performance 2](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_2.png)\n\n![Quarkus vs Go frameworks - Hello World performance 3](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_3.png)\n\n![Quarkus vs Go frameworks - Hello World performance 4](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image 5](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_5.png)\n\n![Image 6](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_6.png)\n\n![Image 7](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_7.png)\n\n![Image 8](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_8.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지1](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_9.png)\n\n![이미지2](/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_10.png)\n\n# 분석\n\n먼저, 이번에는 경쟁이 훨씬 치열합니다. 이전에 Spring Boot를 사용했을 때 Go 프레임워크(비록 기능이 매우 적었지만)가 모든 측정치에서 Spring Boot를 능가했습니다. 그러나 Quarkus를 사용할 때는 결과가 매우 다릅니다.\n\n<div class=\"content-ad\"></div>\n\nQuarkus는 다른 Go 프레임워크보다 더 많은 초당 요청(RPS)을 처리할 수 있습니다. 게다가 Quarkus의 지연 시간 수치도 비슷합니다. 게다가 Quarkus는 Go보다 적은 CPU를 사용합니다. Quarkus가 부족한 유일한 부분은 메모리 사용량입니다 (250M 대 30M).\n\n승자: 선택하기 어려움.\n\n읽어주셔서 감사합니다!\n\nSpring Boot(가상 스레드로 구동)와 비슷한 비교 결과는 여기에서 확인할 수 있습니다:","ogImage":{"url":"/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_0.png"},"coverImage":"/assets/img/2024-05-16-QuarkusvsGoframeworksHelloWorldPerformance_0.png","tag":["Tech"],"readingTime":4},{"title":"다 묻어낸 시대 정부 기록본 C40 협의회와 오웰의 메아리","description":"","date":"2024-05-16 04:29","slug":"2024-05-16-C40AGENDAANDORWELLIANECHOES","content":"\n\n## 감시 속의 지속 가능성 탐색\n\n![이미지](/assets/img/2024-05-16-C40AGENDAANDORWELLIANECHOES_0.png)\n\n미래의 지속 가능성을 추구하며, C40 도시 기후 리더십 그룹은 약속과 주의를 함께 전하는 도시 개발의 지침을 제시합니다. 전 세계의 대도시들이 C40 의 제안에 따라 야심찬 목표를 세우는 가운데 조지 오웰의 '1984'의 그림자가 배경에 드리우며, 환경 발전과 개인의 자유 사이의 섬세한 균형에 대한 질문을 불러일으킵니다.\n\n도시 테두리의 지속 가능성: C40 의제 공개\n주요 도시들의 연합인 C40 도시 기후 리더십 그룹은 지속 가능성을 세계적인 필요사항으로 내세우고 있습니다. 그들은 도시가 기후 대책의 최전선에 서 있음을 상상하며, 탄소 배출을 줄이고, 대기 질을 개선하고, 탄력 있는 도시 환경을 조성하기 위한 노력을 약속합니다. 그러나 이 비전적인 제안을 받아들이는 도시들 사이에서는 오웰식 우려의 그림자가 드러납니다.\n\n\n\nC40 정상 회담이 2022년 10월 19일부터 21일까지 아르헨티나 부에노스 아이레스에서 열렸다. 매년 시장들이 참여하는 이 회담은 전 세계에서 가장 큰 40개 도시를 포함하고 있다. 런던, 홍콩, 피닉스, 도쿄, 몬트리올, 프리타운, 나이로비, 메데인, 리오데자네이루, 파리, 오슬로, 서울, 밀라노, 코펜하겐 등이 포함된 목록이 있는데요.\n\n개인 정보 및 감시: 디스토피아의 듀엣\n환경 모니터링, 폐기물 관리 및 도시 계획을 위한 첨단 기술의 통합이 C40 의제의 핵심이다. 그러나 이 기술적 환경은 개인 정보 보호와 감시에 대한 문제를 제기하며, 오웰이 끔찍하게 묘사한 사회의 지속적인 감시 아래에 있는 사회를 떠올리게 한다. 민주주의의 상징으로 유명한 영국 런던은 현대적인 적인 CCTV 카메라에 시달리게 되었다. 이 장치는 도시 곳곳에 942,563대가 떠 있어 시민들을 침착하게 감시하고 있다. 그들의 지배력으로 범죄행위를 억제하려고 하며, 이 방대한 개인 정보 침해자 네트워크로부터 이루어진 지속적인 감시를 활용한다. 영국 런던 주민 한 명당 CCTV 카메라가 하나씩 있다는 충격적인 통계를 고려하면, 이 목표를 달성하는 것은 불가피해 보인다. 이러한 기술을 지속 가능성을 위해 활용하되 개인의 자유를 희생하지 않는 것이 과제다.\n\n의복 할당: 오웰이 인정할 옷장\nC40 의제 내에는 사람들에게 매년 3개 의복으로 제한하는 의무가 있다. 환경을 고려한 이 조치는 오웰의 비전을 반영하며 개인 선택조차도 철저히 규제된 세상을 상징한다. 지속 가능한 삶과 개인의 자유 침해 사이의 미묘한 경계는 신중하게 고려되어야 할 문제다.\n\n이동의 자유가 위협을 받다: 사유 자동차 보유량의 95% 감축\nC40 계획은 사유 자동차 보유량의 급격한 감소를 요구하며, 미래에는 인구의 5%만이 이 권리를 보유할 것으로 예상된다. 이 변화는 배출을 억제하기 위한 것이지만, 의지대로 여행하는 자유의 침해에 대한 우려를 제기한다. 자동차 소유가 자유의 상징이라고 불리던 과거에는 제약 없이 언제든지 어디든지 갈 수 있었지만, 전기 자동차의 인기가 증가함에 따라 그 자유가 줄어들고 있다. 도시 외곽의 충전소가 제한되어 있고 주행 거리에 대한 걱정 때문에 전기 자동차는 점점 도시 지역에 묶이며, 도시들의 포로가 되고 있다. 개인의 이동을 제한하는 독재 정권에 대한 오웰의 경고는 이 채창적이지만 논란이 많은 제안에서도 울린다.\n\n\n\n\n관광업의 혼란: 제한된 단거리 항공편이 미친 영향\nC40 안건에서는 3년마다 한 번의 짧은 거리 항공편을 허용하는 것을 권장함에 따라 관광업은 패러다임 변화를 맞이합니다. 유럽이나 다른 먼 지역을 탐험하는 매력은 물류적 제약으로 덮일 수 있습니다. 오웰이 개인적인 탐험에 대한 권위의 억제 효과에 대해 경고한 것은 국경을 초월하는 자유가 전례 없는 제약에 직면한 세상에서 울려 퍼집니다.\n\n개인 정보 보호 중시형 혁신: 오웰리안 지뢰밭을 탐험하며\n도시들이 C40 안건을 시행하는 노력 속에서 개인 정보 보호를 보장하는 것이 중요한 관건이 됩니다. 지속 가능성을 이끄는 혁신은 투명한 데이터 거버넌스, 사용자 동의 및 견고한 보안 조치에 근간을 두어야 합니다. 진보와 개인 정보 보호 사이에서 섬세한 균형을 맞추는 것은 C40 비전이 민주적 가치와 일치함을 보장하는 중심 열쇠입니다.\n\n자유를 희생하지 않고 지속 가능한 미래를 조율하며\n우리가 도시의 지속 가능성의 미로 같은 미지의 수로를 탐색하는 동안 C40 안건은 우리에게 오웰리언적 반향에 직면하게 합니다. 환경의 진전과 개인의 자유 보존을 균형있게 유지하는 것은 섬세한 의사 결정을 요구합니다. 지속 가능성을 거부하는 것이 아니라 구현을 개선함으로써, 발전의 교향곡이 도시가 생존하면서도 우리의 인류성을 정의하는 본질적인 자유를 희생하지 않고 미래를 조율하도록 하는 것이 과제입니다. 지속 가능성과 개인적 자유 사이의 섬세한 춤 속에서, 우리가 오늘 내리는 선택은 시간의 회람을 통해 울려 퍼질 것입니다.","ogImage":{"url":"/assets/img/2024-05-16-C40AGENDAANDORWELLIANECHOES_0.png"},"coverImage":"/assets/img/2024-05-16-C40AGENDAANDORWELLIANECHOES_0.png","tag":["Tech"],"readingTime":3},{"title":"LOCKBIT의 귀환","description":"","date":"2024-05-16 04:26","slug":"2024-05-16-THERETURNOFLOCKBIT","content":"\n\n노트: Operation Cronos 이전 이야기를 시작했습니다. 따라서 FBI/Europol 타협 이전에 풀리기 시작하는 작은 세부 사항들을 볼 수 있습니다. 본문은 주로 LockBit 그룹의 강력한 컴백 및 Operation Cronos 이후의 접근에 초점을 맞추며 LockBitSupp의 신원과는 무관합니다. 또한, 주목받지 못한 LOCKBIT 시리즈의 사건들의 모음입니다.\n\n소개\n\nXSS 또는 Exploit과 같은 포럼에서의 LockBit 금지 및 Operation Cronos를 통한 Law Enforcement 침투 후에는, 협상 패널, 계열 회원 목록, 피해자 데이터베이스, 채팅 및 복호화 키와 같은 일부 내부 파일을 상실한 것으로 나타났습니다. 그들의 훌륭한 명성이 훼손되었다는 것이 명백합니다.\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_0.png)\n\n\n\n처음에는 돌아올 때 LockBit이 이전 누출 자료(크로노스 작전 이전)를 게시했습니다. 그러나 정보보안 커뮤니티에서 이전 누출 자료의 재사용에 대해 비판을 받은 후, 그룹은 이를 철회하고 새로운 희생자들의 새로운 일괄 처리로 돌아왔습니다.\n\n이 기사는 LOCKBIT의 두 번째 지배에 중점을 두고 있습니다!\n\n컴백\n\n크로노스 작전 1부 이후, LockBit이 모든 미러 서버를 다시 온라인으로 복귀하는 데 약 일주일이 걸렸으며, 새로운 희생자들을 데이터 유출 사이트(DLS)에 명시했습니다.\n\n\n\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_1.png)\n\n모든 피해자들은 LockBit 유출 서버에 전체 데이터를 공개하기 전에 평균 29일의 협상 기간을 부여받습니다.\n\n현재 피해자 목록은 200명 이상 (포스트 운영 크로노스)으로 나와 있으며 기업 랜섬웨어 시나리오에서 강력한 존재임을 나타냅니다.\n\n피해자화\n\n\n\n\nLockBit은 미국 정부 기관인 DSIB(District of Columbia 보험, 증권 및 은행부)와 같은 명성 높은 대상들을 비롯하여 더 자주 피해를 주고 있습니다. DISB(DC 보험, 증권 및 은행부)는 금융 서비스 업체를 규제합니다. Polycab, OracleCMS, Nampak, Crinetics 등이 포함되어 있습니다.\n\n그러나 피해자의 데이터가 최근 사이트에 나타나고 있으며, Cronos 작전 이전과 달리 정기적으로 업로드되던 특징이 사라졌다는 것을 발견했습니다.\n\n일부 케이스(예: Polycab, Krueth, CasaJove 등)에서는 마감 기한 이후에도 아직 유출이 목록에 없으며, 의심스럽습니다. 이는 Cronos 작전 때 LockBit에서 데이터를 잃었을 수도 있고, 피해자가 랜섬을 지불했을 수도 있습니다.\n\n피해자 지리를 확인하면 미국이 상위를 차지하고 영국, 독일, 캐나다, 인도, 프랑스가 그 뒤를 이어나는 것을 볼 수 있습니다.\n\n\n\n\n![LockBit Infrastructure Hunt](/assets/img/2024-05-16-THERETURNOFLOCKBIT_2.png)\n\nDuring the analysis, it was found that LockBit maintains a stable server to host large leaks on a new Onion Domain:-\n\nThis leak site is running on nginx/1.25.4; which is the latest version of NGINX (ATTOW) as promised by LockBit to avoid any unpatched versions after Operation Cronos Part — 1.\n\n\n\n\n주요 DLS는 아래와 같습니다. nginx/1.24.0에서 실행 중입니다.\n\n조사 중에 LockBit의 원래 IP 주소가 노출되었습니다:\n\n![LockBit](/assets/img/2024-05-16-THERETURNOFLOCKBIT_3.png)\n\n더 깊이 파고들면 아래 세부 내용을 유추할 수 있습니다:\n\n\n\n```js\nIP: 5.182.5.126 \nASN: 49505\nLocation: 러시아\n서버: NGINX \n```\n\n이전의 LockBit 서버(현재 유럽 연합 또는 작전 크로노스에 의해 통제됨)는 Apache/2.4.57 (Debian)를 사용했습니다. LockBit 그룹은 최신 안정적인 온언 도메인을 사용하는 NGINX 서버로 이동했습니다.\n\nLOCKBIT이 토렌트 파일 공유로 이동 중\n\n2024년 3월 9일 LockBit 운영자들은 18개의 Vanity Onion 도메인을 온라인으로 만들었으며, 약 710명의 클라이언트 목록 및 다운로드를 쉽게 할 수 있는 토렌트 파일을 게시했습니다.\n\n\n\n\n2023 년 11 월 중순: Lockbit은 모든 피해자를 위해 Torrent 파일을 만들기로 결정했습니다. 모든 피해자의 데이터 (Torrent 버전)은 회사 이름이 아닌 I85F5, 7E6EE, V4DV5, LIHD9, PLPT7 등과 같은 5자 이름이 할당되어 패키지화되었습니다.\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_4.png)\n\n더 깊숙이 파보면, 각 피해자에 대한 파일 트리도 동일한 날짜인 2024 년 3 월 9 일에 작성되고 있다는 것을 확인할 수 있습니다.\n\nLockBit 유출의 모든 토렌트 트래커는 다음에 연결되어 있습니다:-\n\n\n\nLeak에 대한 토렌트다운로드는 새로운 접근 방식이 아닙니다. Clop Ransomware Gang은 이미 2023년 9월에 사용했습니다. 이는 그들이 트래픽을 대중과 함께 결합할 수 있게 하며, 유출된 파일이 분산된 방식으로 공유되어 더 오래 남게 합니다.\n\n피해자 사례 연구: CRINETICS\n\nLockBit에 의해 Crinetics가 특정 그룹이나 계열사의 작품으로 나열되고 있으며, 해당 데이터를 LockBit이 직접 요구하고 있지는 않습니다.\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_5.png)\n\n\n\n3월 20일에 업데이트로, 그룹은 LockBit과 피해자 간에 진행된 협상의 8개 스크린샷을 나열했습니다.\n\n요구액은 4백만 달러였지만, 고객은 최대 180만 달러까지 지불할 수 있었습니다.\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_6.png)\n\n협상이 성과를 거두지 못했기 때문에 4월 2일, 그룹은 유출 날짜를 2024년 4월 7일로 연장했으며, 이에 따라 LockBit은 정보를 제공했던 피해자와의 통신을 종료하고, 이에 LockBit이 제공한 지시를 따르지 못한 Recorded Future와의 소통이 불발되었다는 설명이 함께 제공되었습니다.\n\n\n\n\n![LockBit Affiliate](/assets/img/2024-05-16-THERETURNOFLOCKBIT_7.png)\n\n드디어, LockBit 제휴사는 2024년 4월 11일에 정보 파괴와 데이터 다운로드를 위한 몸값을 $7백만으로 인상하면서 이 장을 마쳤습니다.\n\nCrinetics로 요구된 BTC 지갑은 다음과 같습니다:-\n\nBTC: bc1qdtawyte5qtxgrk6far90tpeh9atfvyqgv5rcxs\nXMR: 48XyFEbDz4117SopGgaSjAaMK2uXqvnmq7W2wFXKUFPJNdTLFUvgKyx82jcRiWXBDv9ojbijGYyqz9edtrsgZG9NMHG7Xff\n\n\n\n\nLOCKBIT LEAK HOSTING\n\n유럽 경찰 국제 협력 기구 이후 희생자들의 최근 공개된 데이터는 처음에는 LockBit 데이터 서버에 업로드되는 작업 시간이 더 오래 걸리기 때문에 Mega에 호스팅되어 있습니다.\n\n나중에 LockBit 전용 서버로 이동됩니다.\n\n관련 없는 LOCKBIT 도메인\n\n\n\n데이터 누설을 분석하면, Pronat Industries 사례에서 특이성이 발견되었습니다. 이 회사의 데이터는 일반적인 LockBit 플랫폼에 호스팅되어 있지 않습니다.\n\n이것은 다른 URL과 같이 국소적인 TOR 도메인이 아닙니다.\n\nLockBit(또는 동맹사)가 Pronat Industries 데이터를 LockBit과 무관한 별도의 온이언 도메인에 저장하기로 결정한 것이거나, 비-LockBit 제휴사일 수도 있습니다.\n\n해당 고객에 대해 이들은 Crinetics와 비슷한 BTC 및 XMR 주소를 제공했지만, BTC 주소는 다르지만 XMR은 동일합니다.\n\n\n\n\nBTC: bc1qjwquf4n0j6tc55wg9zymkas2ue484ddxtl70wv\nXMR: 48XyFEbDz4117SopGgaSjAaMK2uXqvnmq7W2wFXKUFPJNdTLFUvgKyx82jcRiWXBDv9ojbijGYyqz9edtrsgZG9NMHG7Xff\n\n\n잘 알려진 LockBit 대상에 대한 새로운 패턴이 발견되었습니다. 이제 LockBit은 누출 기간을 5일에서 추가로 10일 늘려 누출을 지연시키고 있습니다.\n\nLOCKBIT 모방자들이 주변에 있습니다.\n\n다양한 사기꾼들이 텔레그램 채널, 디스코드 서버 등 다양한 소스에서 사이버 모서리 주변에 있음을 발견했습니다. 때때로 LockBit 공격 스타일을 모방한 몸값 쪽지를 볼 수도 있습니다.\n\n\n\n\n![LockBit Image 8](/assets/img/2024-05-16-THERETURNOFLOCKBIT_8.png)\n\nMany beginners have acquired the leaked version of LockBit and have turned it into a tool to attack various targets, hoping to strike it rich. These targets might mistake them for the real LockBit and end up paying a heavy price.\n\n![LockBit Image 9](/assets/img/2024-05-16-THERETURNOFLOCKBIT_9.png)\n\nHere is another chat log from a fraudulent LockBit support on the Telegram platform, who demands a $500 membership fee to join a private group:\n\n\n\n\n![2024-05-16-THERETURNOFLOCKBIT_10.png](/assets/img/2024-05-16-THERETURNOFLOCKBIT_10.png)\n\n다른 시나리오에서, LockBit에 의해 유출된 피해 기업들은 \"Dispossessor\"와 같은 다른 그룹에 의해 다시 등장하고 있습니다. 이 그룹은 동일한 LockBit 피해 기업을 나열하고 있습니다. 그들의 웹사이트에서 이에 대한 스크린샷을 확인할 수 있습니다:-\n\n![2024-05-16-THERETURNOFLOCKBIT_11.png](/assets/img/2024-05-16-THERETURNOFLOCKBIT_11.png)\n\n그들의 피해자 목록을 관찰해 보면, 그룹이 LockBit의 고객 80%를 나열했음을 알 수 있으며, 몇몇 피해자로는 3AM 및 8Base의 피해자도 명기하고 있습니다.\n\n\n\n락빗 제휴사?\n\n다크 웹에서 락빗 제휴사를 확인 중에, 러시아 회원인 \"헥소니움\"이라는 사용자가 딥 웹 포럼에서 락빗의 정품 온이언 도메인을 제공하여 락빗의 제휴사라 주장했음을 발견했습니다.\n\n포럼 활동과 사용된 URL을 확인해보면, 이 회원이 2023년 12월 이후 활발하게 활동하고 있음을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_12.png)\n\n\n\n포스트를 찾아 보시는 동안 다음을 볼 수 있습니다:-\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_13.png)\n\nHexonium은 커뮤니티에서 쓰레드를 개설하지 않으며, 모든 포스트에서 \"nigger\"라는 공통 용어를 게시하여 브리치와 상호 작용합니다.\n\n따라서 2022년 9월 LockBit Black이 유출된 이후 오로지 흥분을 유발하기 위해 LockBit aura를 사용하는 숙련자들이 많이 보여왔으므로 Hexonium을 진정한 제휴 업체로 신뢰할 수 없습니다.\n\n\n\n현실 체크?\n\n이는 LockBitSupp과 직접 상호 작용한 내용으로, 그가 다른 채널과는 무관하다고 부인한 내용입니다.\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_14.png)\n\n리크 날짜 연장: 새로운 접근법 채택\n\n\n\n그룹이 이미 설정된 타이머에서 유출을 연기했다는 것이 발견되었습니다. 모든 명단에 해당되는 것은 아니지만 일부 사례에서 관찰되었습니다.\n\nPolycab는 초기 유출 날짜가 4월 5일이었지만 다시 2024년 4월 22일까지 연장되었습니다. 타이머가 설정되면 데이터가 아직 목록에 표시되지 않았습니다 (ATTOW). 1차 크로노스 캠페인 동안 손실된 것으로 추정됩니다.\n\n인도의 또 다른 잘 알려진 기업 \"RJCorp\"는 현재 목록에서 누락된 4월 15일에 발표 예정입니다.\n\n이에 대한 2가지 가능성이 있습니다.\n\n\n\nOPERATION CRONOS: PART 2\n\n2024년 5월 첫째 주에 Europol이 LockBit의 이전에 침해된 웹사이트에 다음 업데이트를 게시했습니다:-\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_15.png)\n\n해당 게시물에 따르면, LockBitSupp와 다른 LockBit 제휴사의 신원이 5월 7일 14:00 UTC에 공개되었습니다.\n\n\n\n그에 따르면, LockBitSupp의 신원은 러시아 국적인 \"Dmitry Yuryevich Khoroshev\"로 추적되었습니다.\n\n![image](/assets/img/2024-05-16-THERETURNOFLOCKBIT_16.png)\n\nLockBit 신원 공개 이후 관찰된 이벤트는 다음과 같습니다: \n\n- 이러한 공개 이후, 많은 보안 연구원들이 이 회원의 세부 정보를 확인하기 위해 공유된 이메일 주소 및 전화번호를 찾기 시작했습니다.\n- 신원 공개 후 1시간 뒤, LockBitSupp은 다음과 같은 상태를 표명했습니다:\n\n\n\n3) 이 상태 업데이트 이후 많은 산업 관계자들이 이를 흔하지 않은 자신의 방어적 접근으로 해석하기 시작했습니다.\n\n이게 사실일 수도 있지만, 우리는 현재 이를 알 방법이 없어요.\n\n4) 다음 날 5월 9일에, LockBit은 DLS 도메인에 새로운 피해자 77명을 추가했습니다. 일부 피해자들이 새로운 일괄로 다시 나타났습니다. 이것은 피해자 수를 부풀리고, 결과적으로 높은 수의 일괄 감염을 전반적으로 전달하기 위한 것일 수 있습니다.\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_17.png)\n\n\n\n5) LockBit은 DLS에 \"contest.omg\"이라는 새로운 메시지를 추가했습니다. 여기서 그는 커뮤니티에 도전하여 Dmitry와 새로운 포털을 통해 증거를 제시하도록 요청했습니다.\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_18.png)\n\n![이미지](/assets/img/2024-05-16-THERETURNOFLOCKBIT_19.png)\n\n6) 4일 동안 활동했던 이전 사이트(Feds가 통제하는)가 지금 닫히고 있습니다.\n\n\n\n\n![LockBitTox Status Updates](/assets/img/2024-05-16-THERETURNOFLOCKBIT_20.png)\n\nLOCKBIT TOX STATUS UPDATES\n\nHere are the important STATUS-UPDATES of LockBitSupp. Captured at different intervals:-\n\n- все на шашлындос Everything is on the Barbeque\n- ФБР блефует, я не Демон, мне жаль настоящего Демона))) о, и он получит пизды за мои грехи))) The FBI is bluffing, I'm not Dimon, I feel sorry for the real Dimon ))) oh and he will get pussy for my sins )))\n- Придумайте как доказать, что я не Демон? Как показать всему миру что ФБР ошиблись или специально подставили Демона? Can you figure out how to prove that I'm not a Demon? How can we show the whole world that the FBI made a mistake or deliberately framed a Demon?\n- участвуем в конкурсе, условия в блоге We participate in the competition, conditions in the blog\n\n\n\n\n결론\n\n테이크다운에 관해서 말하자면: 주장된 만큼 효과적이지는 않습니다. RaaS가 이윤을 창출하는 사업이기 때문에 이러한 추세는 계속될 것입니다. 한 그룹의 체포는 더 방어적인 접근을 하는 다음 그룹의 부활/탄생을 이끌어 낼 것입니다.\n\n이 경우에는 아직 유럽 경찰이 Khoroshev를 어떻게 찾아냈는지 명확하지 않습니다. 간단히 말하면, Khoroshev와 LockBit 사이의 활성 연결을 설정하기 위한 구체적인 증거가 제시되지 않았지만, 유사한 타임라인의 가정이 있습니다.\n\n동시에, 작전의 기밀성으로 인해 Dmitry가 LockBitSupp가 아님을 확신할 수 없습니다.\n\n\n\n조금 더 기다려야 할 것 같아요. LockBitSupp가 돈이 아닌 피해자 수에 대해 이야기했으니 진실을 밝히기 위해서 더 기다려야 해요.\n\nIOC\n\n```js\nTOR DOMAINS\n===========\n\nlockbit7z2jwcskxpbokpemdxmltipntwlkmidcll2qirbu7ykg46eyd.onion\nlockbit6knrauo3qafoksvl742vieqbujxw7rd6ofzdtapjb4rrawqad.onion\nlockbit7z2og4jlsmdy7dzty3g42eu3gh2sx2b6ywtvhrjtss7li4fyd.onion\nlockbit7z2mmiz3ryxafn5kapbvbbiywsxwovasfkgf5dqqp5kxlajad.onion\nlockbit7z355oalq4hiy5p7de64l6rsqutwlvydqje56uvevcc57r6qd.onion\nlockbit7z36ynytxwjzuoao46ck7b3753gpedary3qvuizn3iczhe4id.onion\nlockbit7z37ntefjdbjextn6tmdkry4j546ejnru5cejeguitiopvhad.onion\nlockbit7z3azdoxdpqxzliszutufbc2fldagztdu47xyucp25p4xtqad.onion\nlockbit7z3ddvg5vuez2vznt73ljqgwx5tnuqaa2ye7lns742yiv2zyd.onion\nlockbit7z3hv7ev5knxbrhsvv2mmu2rddwqizdz4vwfvxt5izrq6zqqd.onion\nlockbit7z3ujnkhxwahhjduh5me2updvzxewhhc5qvk2snxezoi5drad.onion\nlockbit7z4bsm63m3dagp5xglyacr4z4bwytkvkkwtn6enmuo5fi5iyd.onion\nlockbit7z4cgxvictidwfxpuiov4scdw34nxotmbdjyxpkvkg34mykyd.onion\nlockbit7z4k5zer5fbqi2vdq5sx2vuggatwyqvoodrkhubxftyrvncid.onion\nlockbit7z4ndl6thsct34yd47jrzdkpnfg3acfvpacuccb45pnars2ad.onion\nlockbit7z55tuwaflw2c7torcryobdvhkcgvivhflyndyvcrexafssad.onion\nlockbit7z57mkicfkuq44j6yrpu5finwvjllczkkp2uvdedsdonjztyd.onion\nlockbit7z5ehshj6gzpetw5kso3onts6ty7wrnneya5u4aj3vzkeoaqd.onion\nlockbit7z5hwf6ywfuzipoa42tjlmal3x5suuccngsamsgklww2xgyqd.onion\nlockbit7z5ltrhzv46lsg447o3cx2637dloc3qt4ugd3gr2xdkkkeayd.onion\nlockbit7z6choojah4ipvdpzzfzxxchjbecnmtn4povk6ifdvx2dpnid.onion\nlockbit7z6dqziutocr43onmvpth32njp4abfocfauk2belljjpobxyd.onion\nlockbit7z6f3gu6rjvrysn5gjbsqj3hk3bvsg64ns6pjldqr2xhvhsyd.onion\nlockbit7z6qinyhhmibvycu5kwmcvgrbpvtztkvvmdce5zwtucaeyrqd.onion\nlockbit7z6rzyojiye437jp744d4uwtff7aq7df7gh2jvwqtv525c4yd.onion\nlockbitfilzhrvt6eya2lvnp7te4iifzmwybendqclgujqbzu3k4gaid.onion\nlockbitfilzu5e62fybhieutf6653cpv6wco7twgjtkqwdgubn4q5rad.onion\nlockbitfile2tcudkcqqt2ve6btssyvqwlizbpv5vz337lslmhff2uad.onion\nlockbit33chewwx25efq6dgkhkw4u7nefudq4ijkuamjfd7x73on6dyd.onion\n\n이전 LockBit TOR 도메인\n=======================\nlockbitapt6vx57t3eeqjofwgcglmutr3a35nygvokja5uuccip4ykyd.onion\nlockbitapt2yfbt7lchxejug47kmqvqqxvvjpqkmevv4l3azl3gy6pyd.onion \nlockbitapt34kvrip6xojylohhxrwsvpzdffgs5z4pbbsywnzsbdguqd.onion \nlockbitapt5x4zkjbcqmz6frdhecqqgadevyiwqxukksspnlidyvd7qd.onion \nlockbitaptc2iq4atewz2ise62q63wfktyrl4qtwuk5qax262kgtzjqd.onion \nlockbitapt2d73krlbewgv27tquljgxr33xbwwsp6rkyieto7u4ncead.onion \nlockbitapt6vx57t3eeqjofwgcglmutr3a35nygvokja5uuccip4ykyd.onion \nlockbitapt72iw55njgnqpymggskg5yp75ry7rirtdg4m7i42artsbqd.onion \nlockbitaptawjl6udhpd323uehekiyatj6ftcxmkwe5sezs4fqgpjpid.onion \nlockbitaptbdiajqtplcrigzgdjprwugkkut63nbvy2d5r4w2agyekqd.onion \n\nBTC 지갑\n===========\nbc1qdtawyte5qtxgrk6far90tpeh9atfvyqgv5rcxs\nbc1qjwquf4n0j6tc55wg9zymkas2ue484ddxtl70wv\n\nXMR: 48XyFEbDz4117SopGgaSjAaMK2uXqvnmq7W2wFXKUFPJNdTLFUvgKyx82jcRiWXBDv9ojbijGYyqz9edtrsgZG9NMHG7Xff\n\nIP: 5.182.5.126\n\nTOX: 3085B89A0C515D2FB124D645906F5D3DA5CB97CEBEA975959AE4F95302A04E1D709C3C4AE9B7\n```\n\nEXTRA READING\n\n\n\n如果您是LockBit Story的狂热读者，则可以阅读我个人喜欢的一些资源：-\n\n```js\nhttps://krebsonsecurity.com/2024/05/how-did-authorities-identify-the-alleged-lockbit-boss/\nhttps://analyst1.com/ransomware-diaries-volume-5-unmasking-lockbit-2/\nhttps://therecord.media/lockbitsupp-interview-ransomware-cybercrime-lockbit\n```\n\n# 在Twitter/X上关注我，发现有趣的DarkWeb/InfoSec简报！;-)","ogImage":{"url":"/assets/img/2024-05-16-THERETURNOFLOCKBIT_0.png"},"coverImage":"/assets/img/2024-05-16-THERETURNOFLOCKBIT_0.png","tag":["Tech"],"readingTime":12},{"title":"비정상적인 현상과 놀라운 Midjourney 이미지","description":"","date":"2024-05-16 04:24","slug":"2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages","content":"\n\n내 글 중 한 가지라도 읽은 적이 있다면, 자연 현상에 대한 내 감동과 그것을 흥미로운 이미지로 만드는 방법을 늘 찾는 것을 알고 계실 것입니다.\n\n이미 Midjourney에 대한 영감으로 수학 용어와 유체 역학을 활용하는 방법에 대해 썼습니다. 또한 한 단어로 된 프롬프트에 대해 쓰고, 창작을 더 활기차게 하는 새로운 단어를 고안한 적도 있죠.\n\n좋은 점은 시각적으로 영감을 주는 단어들이 많이 있고 이보다 더 많은 이상하고 아름다운 복잡한 자연 현상들이 존재한다는 것입니다. 그리고 이 모든 것들이 Midjourney와 함께 활용될 수 있다는 점이지요.\n\n모든 곳에서 그것들을 찾아봅니다. 많은 과학 기사를 읽고, 그곳에는 흥미진진한 현상을 설명하는 내용이 가득합니다. 녹색 백과사전과 리더스 다이제스트를 넘겨 보는 것을 좋아하고, 시각적인 내용을 설명하는 흥미로운 단어로 가득 찬 사전들을 쌓아 놓고 있습니다.\n\n\n\n\n![2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_0.png](/assets/img/2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_0.png)\n\n해당 단어들, 흥미로운 현상들을 발견하면, 시간을 낭비하지 않고 Midjourney에서 잘 활용해요.\n\n때문에 이전부터 이미 5000개 이상의 이미지를 생성하는 클럽에 참여하게 되었고, 빠른 시간을 보내기에 항상 부족한 이유가 있어요. 하지만 그 모두가 그만한 가치가 있죠.\n\n이 글에서는 최근 발견한 15개 용어와 단어를 공유하려고 해요. 이러한 단어들과 용어들은 특정한 과학 분야나 지식 카테고리에 구애받지 않지만, 한 가지 공통점을 가지고 있어요: 절도는 훌륭한 시각적 효과와 아름다운 그림을 만들어낼 수 있어요.\n\n\n\n\n<img src=\"/assets/img/2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_1.png\" />\n\n여기 목록이 있어요:\n\n- 리히텐베르크 도형: 전기 방전으로 생성된 가지처럼 가지가 뻗은 패턴들입니다.\n- 카우스틱: 곡면을 통해 반사되거나 굴절되어 생성된 빛의 패턴입니다.\n\n\n\n리듬적 줄무늬: 자연 과정에 의해 만들어진 표면에 반복된 선이나 홈.\n\n소용돌이 모양: 생물학적이거나 지질학적 맥락에서 종종 발견되는 원형 또는 나선 모양의 패턴.\n\n동심원 형태: 공통 중심을 가진 원과 다른 형태의 패턴, 종종 성장이나 충격을 나타냄.\n\n방사선체: 미세한 해양 생물의 꼬리가 테인 실리카 기반의 복잡한 스켈레톤.\n\n\n\n생물학적 시스템에서 자주 볼 수 있는 갈래 또는 가닥 모양을 가진 Furcations(포뿌리 구조).\n\n나선 모양 Phyllotaxis(잎의 배치): 씨앗, 잎 또는 꽃잎이 나선형으로 배열된 모습.\n\nGuttation(물방울): 잎의 끝이나 가장자리에서 분비되는 임명액의 작은 방울.\n\nConchoidal Fractures(굴곡 파열): 특정 물질이 파단될 때 형성되는 매끄럽고 곡선 형태의 표면.\n\n\n\n스피큘 패턴: 생물 조직에서 종종 발견되는 바늘 모양의 구조물.\n\n피더 바불: 깃털 밀림의 복잡한 인터락킹 구조.\n\n덴드리틱 패턴: 나무 가지 모양의 가지치기 패턴.\n\n싸이마틱 패턴: 매체 내에서 소리 진동에 의해 생성된 시각적 패턴.\n\n\n\n튜링 패턴: 화학 및 생물학 시스템에서 발생할 수 있는 반응-확산 패턴입니다.\n\n제 실험에서는 가능한 한 간단한 프롬프트를 사용하는 편입니다. 이에 대한 추론을 이전에 많이 설명했어요. 그 핵심은 이렇습니다: 간단한 프롬프트를 사용하면 긴 복잡한 프롬프트보다 특정 단어의 영향을 더 잘 평가하고 판단할 수 있어요.\n\n새롭게 찾은 흥미로운 단어로 무언가 흥미로운 것을 만들면, 그 이미지를 스타일 참조용으로 항상 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_2.png)\n\n\n\n물론, 저는 더 복잡한 프롬프트에서도 내 특별한 말을 직접 사용할 수 있고, 때로는 잘 작동할 수 있지만, 여전히 더 편리한 워크플로우를 위해 간단한 프롬프트와 스타일 참조 이미지를 사용하는 것을 선호합니다.\n\n일반적으로 사용하는 프롬프트는 여기 있어요:\n\n이 프롬프트를 사용하여 생성된 몇 가지 결과물이 있습니다. 위 목록에서 나온 단어들을 사용했어요.\n\n<img src=\"/assets/img/2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_3.png\" />\n\n\n\n\n![Image 4](/assets/img/2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_4.png)\n\n![Image 5](/assets/img/2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_5.png)\n\n![Image 6](/assets/img/2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_6.png)\n\nAs you can see, all of these words create absolutely outstanding images.\n\n\n\n\n당신은 개발자이시군요. 위의 텍스트를 친절한 톤으로 한국어로 번역해 드리겠습니다.\n\n또한, 이러한 단어들을 섞거나 생성된 이미지를 혼합하여 독특하고 아름다운 스타일의 이미지를 만들어 볼 수 있습니다.\n\n그래서 가능성은 자연 현상처럼 무한합니다. 이러한 단어들로 놀아보고 오래된 책, 과학 매뉴얼, 잡지 및 온라인 기사에서 새로운 단어를 찾아보세요.\n\n또는 ChatGPT를 사용하여 흥미로운 시각적 패턴을 만들 수 있는 자연 현상을 묻고 새로운 아이디어를 얻을 수도 있습니다 (다만 저는 책을 더 좋아합니다).\n\n기사를 좋아하고 독창적이고 독특한 Midjourney 이미지를 만드는 데 도움이 되기를 바랍니다.\n\n\n\n마크다운 형식으로 테이블 태그를 바꿔주세요.","ogImage":{"url":"/assets/img/2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_0.png"},"coverImage":"/assets/img/2024-05-16-UnusualphenomenaandphenomenalMidjourneyimages_0.png","tag":["Tech"],"readingTime":3},{"title":"토큰화의 기술 자연어 처리를 위한 필수 기법","description":"","date":"2024-05-16 04:22","slug":"2024-05-16-TheArtofTokenizationEssentialTechniquesforNaturalLanguageProcessing","content":"\n\n토큰화가 어떻게 발전해 왔는지 궁금하신가요? 현재의 대형 언어 모델(Large Language Models)은 어떤 기술을 사용하여 토큰화를 수행할까요? 함께 알아보도록 해요!\n\n![이미지](/assets/img/2024-05-16-TheArtofTokenizationEssentialTechniquesforNaturalLanguageProcessing_0.png)\n\n자연어 처리는 트랜스포머 모델 개발 이후 많은 발전을 이루었습니다. 텍스트를 정제한 후 NLP 작업과 관련된 첫 번째 단계는 토큰화입니다. 처음의 화이트스페이스(whitespace) 및 구두점(tokenizer)을 구축한 이후 현재의 문맥적(contextual) 및 구조적(tokenizers) 토크나이저들까지 많은 변화가 있었습니다. 요즘에는 BERT 및 그 변형, ChatGPT, Claude와 같은 생성 모델이 특히 NLP 분야에서 화제가 되고 있습니다. 이 블로그에서는 텍스트 토큰화 과정이 어떻게 발전해 왔는지 및 최신 대형 언어 모델에서 어떻게 사용되고 있는지 알아볼 것입니다.\n\n# 토큰화 기술 발전의 여정\n\n\n\n토큰화는 다양한 기술을 사용하여 텍스트 데이터를 작은 조각으로 나누는 것을 말합니다. 모델이 데이터를 더 잘 처리하고 분석할 수 있도록 합니다. 기본 토큰화 기술에는 공백, 단어 및 문장 토큰화가 포함되어 있습니다. 이러한 기술은 어휘 크기 및 정보 손실, 문맥 부족 등과 같은 일부 한계가 있었습니다. 따라서 n-gram, BPE (Byte Pair Encoding), SentencePiece 토큰화와 같은 기술이 소개되었으며 거의 모든 한계를 해소할 수 있었습니다. 이러한 기술은 현재 언어 모델에서 사용되며 임베딩에서 문맥 및 구조적 이해를 캡처하는 데 도움이 됩니다. 이제 각 기술을 자세히 살펴보겠습니다!\n\n## 기본 토큰화 기술\n\n이러한 기술은 데이터를 직관적으로 작은 조각으로 나누는 데 주로 초점을 맞추며 어떤 청크가 다른 청크와 어떻게 관련되어 있는지에 대해 크게 신경쓰지 않습니다. 각 기술이 작동하는 방식에 대한 자세한 설명은 다음과 같습니다:\n\n1. 공백 토큰화 - 탭, 공백, 새 줄 등의 공백을 기준으로 텍스트를 분할합니다. 이 기술은 모든 단어가 공백으로 분리되어 있다고 가정합니다.\n   \n:warning: 한계\n- 문맥적 의미 손실: 단어를 별도의 토큰으로 취급하여 종종 문장 내에서의 관계를 간과합니다.\n- 어휘 폭발: 각 고유한 단어가 토큰이 되므로, 어떠한 언어도 수십억 개의 단어를 가질 수 있기 때문에 종종 매우 큰 훈련 어휘로 이어집니다.\n- 잡음이 많은 데이터 처리 어려움: 이모지, 과도한 문장 부호 또는 특수 문자를 처리하지 못하여 토큰화가 부정확해집니다.\n\n\n\n\n![word tokenization](/assets/img/2024-05-16-TheArtofTokenizationEssentialTechniquesforNaturalLanguageProcessing_1.png)\n\n2. 단어 토큰화 - 공백을 기반으로 분할된 문장 토큰화에서 문장의 기본 단위로 단어가 따로 있다고 가정합니다.\n⚠️ 한계\n- 단어 사이의 상황적 의미 손실\n- 어휘폭발\n\n![sentence tokenization](/assets/img/2024-05-16-TheArtofTokenizationEssentialTechniquesforNaturalLanguageProcessing_2.png)\n\n3. 문장 토큰화 - 마침표, 물음표 등의 구두점 및 다른 언어별 규칙을 이해하여 문장을 기준으로 텍스트를 분할합니다.\n⚠️ 한계 - 기계 번역 등의 작업에 유용하지만 여전히 단어 수준 토큰화에 의존하며 이로 인한 한계를 물려받습니다.\n\n\n\n\n💻 위의 세 가지 토큰화 기법을 보여주는 코드입니다:\n\n```js\n# NLTK 사용\nimport nltk\nfrom nltk.tokenize import word_tokenize, sent_tokenize\n\nnltk.download('punkt')\n\n# 입력 문장\ntext = \"When I left the place, I didn't take the left turn.\"\n\n# 공백 기준 토큰화\nwhitespace_tokens = text.split()\n\n# 단어 토큰화\nword_tokens = word_tokenize(text)\n\n# 문장 토큰화\nsentence_tokens = sent_tokenize(text)\n\nprint(\"Whitespace Tokenization:\", whitespace_tokens)\nprint(\"Word Tokenization:\", word_tokens)\nprint(\"Sentence Tokenization:\", sentence_tokens)\n```\n\n또한 SpaCy, Scikit-learn, Stanza 등의 다른 파이썬 라이브러리도 이러한 토큰화 기술을 수행할 수 있습니다.\n\n# 고급 토큰화 기술\n\n\n\n고급 기술은 위에서 언급한 한계를 완화하려고 시도하고, 단어 간 상호 관계 및 문장 내 맥락에 초점을 맞추려고 노력합니다. 이 기술이 어떻게 작동하는지 살펴봅시다:\n\n️1. N-그램-\n▪ 텍스트를 슬라이딩 윈도우 방식으로 분할하여 지정된 N 길이의 토큰을 만듭니다.\n▪ 이 방법은 서로 가깝게 발생하는 단어 간의 관계를 잡아냅니다.\n💡이 기술은 음성 인식, 텍스트 완성 등과 같은 새로운 작업에서 기본적인 역할을 합니다.\n⚠️ 한계 — 연속된 단어와의 관계만 파악합니다. 더 긴 문장에 대해선 다시 맥락이 사라집니다.\n\n![image](/assets/img/2024-05-16-TheArtofTokenizationEssentialTechniquesforNaturalLanguageProcessing_3.png)\n\n2. 바이트 쌍 부호화-\n▪ 여기서는 학습 텍스트에 포함된 모든 문자/바이트를 사용하여 먼저 어휘집을 만듭니다.\n▪ 연속 발생 문자의 빈도수에 기반하여 어휘집을 반복적으로 업데이트합니다.\n▪ 중지 조건(또는 최대 병합 수)이 충족되면 입력 텍스트(테스트 입력)는 이 생성된 어휘집을 기반으로 분할됩니다.\n▪ 어휘 외 단어를 처리할 수 있으며 어휘 크기가 무너지지 않습니다.\n💡RoBERTa, GPT2는 이 토큰화 기술을 사용합니다.\n⚠️ 한계-\n▪ 훈련 단계에서 개발된 고정된 어휘 크기로 인해 때로는 새로운 단어에 문제가 생기기도 합니다.\n▪ 이 알고리즘은 가장 빈도가 높은 단어들을 모아 사용하며, 문장의 형태학적 및 문맥적 복잡성을 무시합니다.\n\n\n\n<img src=\"/assets/img/2024-05-16-TheArtofTokenizationEssentialTechniquesforNaturalLanguageProcessing_4.png\" />\n\n3. SentencePiece-  \n- SentencePiece는 Unigram과 Dynamic Programming 또는 BPE 알고리즘을 사용하는 서브워드 토큰화 라이브러리입니다.\n- 입력 텍스트를 Unicode 문자로 사용하므로 초기 단어 토큰화가 필요없습니다.\n- 단일 모델을 사용하여 여러 언어를 처리할 수 있습니다.\n- 처음에 Unicode 문자 수준 토큰을 생성하기 때문에 텍스트의 토큰화 및 디토큰화를 모두 도와 전처리 및 후처리를 쉽게 만들어 줍니다.\n💡BERT, XLNet, T5 등 많은 HuggingFace 트랜스포머 모델이 이 토크나이저를 사용하고 있습니다. 이는 오픈 소스로 잘 유지되는 라이브러리입니다.\n⚠️ 제한 사항-  \n- 언어에 독립적이지만 다양한 언어에 대해 사용할 때 성능이 달라질 수 있습니다.\n- 문단이나 섹션과 같은 문맥 및 구조적 세부 정보를 고려하지 않고 하위 단어의 시퀀스로 텍스트를 여전히 취급합니다.\n\n💻 위의 세 가지 토큰화 기술을 보여주는 코드:\n\n```js\n# 필요한 라이브러리 가져오기\nimport sentencepiece as spm\nfrom tokenizers import ByteLevelBPETokenizer\nmodel_path = \"모델을 저장할 경로\"\ntrain_text = \"훈련을 위한 txt 파일 경로\"\n\n###############################\n# BPE 구현\n###############################\n\nBPE_tokenizer = ByteLevelBPETokenizer()\n\n# utf-8 인코딩된 코퍼스로 토크나이저 훈련시키기\nBPE_tokenizer.train(files=['훈련을 위한 txt 파일 경로'], vocab_size=1000, min_frequency=2)\n\n# 훈련된 토크나이저 저장\nmodel_path = '모델을 저장할 경로'\nBPE_tokenizer.save_model(model_path)\n\n# 훈련된 토크나이저 불러오기\nBPE_tokenizer = ByteLevelBPETokenizer.from_file(f\"{model_path}/vocab.json\", f\"{model_path}/merges.txt\")\n\n# 텍스트 토큰화\ntext = \"I would love to see a lion!\"\nBPE_encoded_tokens = BPE_tokenizer.encode(text)\n\nprint(\"원본 텍스트:\", text)\nprint(\"인코딩된 토큰:\", BPE_encoded_tokens.tokens)\n\n\n###############################\n# SentencePiece 구현\n###############################\n\nspm.SentencePieceTrainer.train(input=train_text, model_prefix=model_path, vocab_size=1000, num_threads=4)\n\n# 사전 훈련된 모델 불러오기\nsp_model = model_path + \".model\"\nsp = spm.SentencePieceProcessor(model_file=sp_model)\n\ntext = \"I would love to see a lion when we reach the zoo!\"\n\n# 서브워드 토큰화 및 토큰 반환\ntokens_subword = sp.encode_as_pieces(text)\n# 서브워드 토큰화 및 토큰 ID 반환\ntokens_ids = sp.encode_as_ids(text)\n# 바이트 수준 토큰화 및 바이트 수준 토큰 ID 반환\ntokens_byte = sp.encode(text)\n\n# 토큰을 다시 텍스트로 디코딩\ndecoded_text = sp.decode_pieces(tokens_subword)\n\nprint(\"원본 텍스트:\", text)\nprint(\"토큰화된 텍스트:\", tokens_subword)\nprint(\"디코딩된 텍스트:\", decoded_text)\n```\n\n\n\n이러한 고급 토큰화 기술을 사용하여 추출한 토큰들은 BERT, GPT 등과 같은 고급 언어 모델을 사용하는 작업에 필요한 첫 번째 단계입니다. 이러한 토큰들은 모델로 전송되어 임베딩으로 변환되어 전체 텍스트의 문맥적 및 구조적 의미를 포착합니다.","ogImage":{"url":"/assets/img/2024-05-16-TheArtofTokenizationEssentialTechniquesforNaturalLanguageProcessing_0.png"},"coverImage":"/assets/img/2024-05-16-TheArtofTokenizationEssentialTechniquesforNaturalLanguageProcessing_0.png","tag":["Tech"],"readingTime":6},{"title":"전세계적으로 공개된 클라우드 없는 이미지 아카이브에 대한 접근이 공개되었습니다","description":"","date":"2024-05-16 04:20","slug":"2024-05-16-AnnouncingpublicaccesstoourGlobalCloud-freeImageryArchive","content":"\n\n![이미지](/assets/img/2024-05-16-AnnouncingpublicaccesstoourGlobalCloud-freeImageryArchive_0.png)\n\n어제 우리는 Earth Index Alpha를 출시했어요. 오늘, 우리는 우리가 변화하는 환경에 대한 정보에 대한 접근을 민주화하는 우리의 목표로 나아가는 또 다른 큰 발걸음을 발표합니다: 우리 고유의 전 세계적인 클라우드 프리 센티넬-2 데이터셋을 게시했어요. 2023년 동안 집계된 12개의 밴드, 모두 완전한 해상도로 제공되며, 총 33TB 이상의 데이터에요! 그리고 이 데이터셋을 공개하고 쉽게 접근할 수 있도록 만들기 위해 멋진 Source Cooperative팀과 협력했어요.\n\n이 데이터셋을 공유하는 우리의 목표는 분석 프로젝트를 수행할 때 그룹들이 직면하는 일부 기술적, 재정적 장벽을 깨는 데에 도움을 주는 것이에요. 데이터 준비에 소요되는 시간이 줄어들면, 실제 문제 해결에 더 많은 시간을 할애할 수 있어요.\n\n\"Source Cooperative를 만들 때의 주요 목표 중 하나는 Earth Genome과 같이 관대한 그룹이 다른 사람들과 자신들의 작업을 공유할 수 있도록 하는 것이에요.\" 라디언트 어스의 사장인 Jed Sundwall은 말합니다. \"이 센티넬-2 데이터셋은 개방된 데이터가 환경 모니터링 및 분석 노력을 집단적으로 가속화할 수 있는 매우 중요한 데이터 제품을 생성하는 방법을 보여주는 예시에요.\" #\n\n\n\n지금 우리 Earth Genome에서는 데이터를 사용합니다 - 정말 많은 양의 데이터 - 그리고 우리가 가장 좋아하는 데이터 소스 중 하나는 Sentinel-2입니다. 해상도가 가장 높지는 않지만, 13개의 밴드는 엄청난 양의 정보를 인코딩하고 다양한 환경 분석을 지원합니다. 실제로 우리는 플라스틱 쓰레기를 특별히 감지하는 데 사용했는데, 이는 고해상도 RBG로는 거의 불가능한 작업입니다. 무엇보다도, 무료로 제공됩니다.\n\n하지만 무료라고 해서 쉽다는 뜻은 아니며, Sentinel-2 데이터를 ML에 사용할 수 있도록 준비하는 것은 오랜 시간이 걸리고 지루한 과정일 수 있습니다. 구름, 그림자, 눈, 나쁜 픽셀을 가리는 작업, 구멍을 채우기 위해 더 많은 데이터 다운로드, 새로운 데이터도 구름이 없는지를 희망하기까지... 이 고통을 우리도 너무 잘 아는 것입니다! Earth Index를 확장해 나갈 때 우리는 거대한 양의 Sentinel-2 데이터를 사전 처리할 빠르고 확장 가능한 솔루션이 필요했습니다. 다행히 AWS가 도와주었고 우리에게 상당한 양의 크레딧을 제공했는데, 이는 Rockefeller Foundation과 Patrick J McGovern Foundation의 기부와 결합하여 현실로 만들어졌습니다!\n\n우리는 Earth Search STAC를 활용하여 AWS에 호스팅된 Sentinel L2A 데이터를 찾았습니다. 각 Sentinel 2 그리드 셀(예: UTM/MGRS 셀)마다 16개의 최상의 씬을 선택하고 각 밴드(제공된 RGB 합성 포함)를 다운로드했습니다. 이로써 총 224개의 파일이 되었습니다. 그런 다음 제공된 Scene Classification Map을 사용하여 이미지를 마스킹하고 쌓아 올렸으며 각 밴드의 각 픽셀에서 중앙 픽셀 값을 선택했습니다. 결과 파일은 웹 Mercator로 재투영되고 웹 소비에 최적화되도록 COG로 변환되었으며, 우리 자체 STAC에 등록되어 Source Cooperative에 업로드되었습니다.\n\n이 모든 과정은 AWS Batch에서 21,000개 이상의 작업으로 실행되었으며 시간당 수백 개의 인스턴스를 사용하여 원본 데이터의 반 페타바이트 이상을 처리했습니다.\n\n\n\n\n![Image 1](/assets/img/2024-05-16-AnnouncingpublicaccesstoourGlobalCloud-freeImageryArchive_1.png)\n\n![Image 2](/assets/img/2024-05-16-AnnouncingpublicaccesstoourGlobalCloud-freeImageryArchive_2.png)\n\n![Image 3](/assets/img/2024-05-16-AnnouncingpublicaccesstoourGlobalCloud-freeImageryArchive_3.png)\n\n![Image 4](/assets/img/2024-05-16-AnnouncingpublicaccesstoourGlobalCloud-freeImageryArchive_4.png)\n\n\n\n\n\n![이미지](/assets/img/2024-05-16-AnnouncingpublicaccesstoourGlobalCloud-freeImageryArchive_5.png)\n\n물론 아무 것도 완벽하지 않죠. 앞으로 몇 주 동안 실패한 지역을 재처리하고, 흐린 지역이나 눈으로 덮인 장면이 나타나는 곳을 조사할 예정입니다.\n\n모든 장면 및 관련 자산은 저희 STAC 엔드포인트 및 해당 STAC 브라우저(문자열 처리에 어려움을 겪는 사용자를 위한)를 통해 찾을 수 있습니다. 일반적인 메타데이터가 제공됩니다. 또한 자산의 출처 장면(즉, 어떤 소스 장면이 기여했는지) 및 좋은 픽셀의 대략적인 비율에 대한 정보도 포함됩니다. 자산 자체는 Create Commons 4.0 라이선스에 따라 사용이 허가된 Source Cooperative를 통해 미국 서부 지역의 HTTPS 및 AWS S3를 통해 공개적으로 제공됩니다.\n\n계속해서 더 많은 정보를 제공할 예정입니다...\n\n\n적극적으로 협력하기를 기대합니다! 😊\n\n\n\n이 데이터셋에 대한 최초의 데이터 릴리스 중 하나입니다. 누락된 또는 가려진 장면을 재처리할 뿐만 아니라, 앞으로 몇 주 안에 선택한 위치에 추가 연도의 데이터를 게시할 계획이 있습니다. 그리고 연말까지 2021년과 2022년에 대한 글로벌 데이터도 공개할 예정입니다!\n\n이 데이터를 어떻게 활용할 건가요? 머신 러닝? NDVI? 베이스 맵? 어떤 문제를 해결하고자 하는지 알려주세요!","ogImage":{"url":"/assets/img/2024-05-16-AnnouncingpublicaccesstoourGlobalCloud-freeImageryArchive_0.png"},"coverImage":"/assets/img/2024-05-16-AnnouncingpublicaccesstoourGlobalCloud-freeImageryArchive_0.png","tag":["Tech"],"readingTime":3}],"page":"80","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}