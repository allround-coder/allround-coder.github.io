{"pageProps":{"posts":[{"title":"Angular 기초부터 고급까지 모든 개념 설명 - 파트 1","description":"","date":"2024-06-22 14:56","slug":"2024-06-22-AngularBasictoAdvanceEveryConceptExplainedpart1","content":"\n\n<img src=\"/assets/img/2024-06-22-AngularBasictoAdvanceEveryConceptExplainedpart1_0.png\" />\n\n웹 개발 분야에서 빠르게 진화하는 상황에서 Angular는 강력하고 다재다능한 프레임워크로 등장하여 개발자들이 동적이고 기능이 풍부하며 반응성 있는 웹 애플리케이션을 구축할 수 있도록 돕고 있습니다. Google이 개발 및 유지보수하는 Angular는 싱글 페이지 애플리케이션을 쉽게 만들 수 있는 능력으로 널리 사용되고 있습니다. 이 블로그 시리즈는 Angular의 모든 측면을 명확히 설명하여 복잡한 개념을 모든 기술 수준의 개발자들에게 이해하기 쉬운 설명으로 분해하고 있습니다.\n\n# 파일 및 폴더 구조\n\nAngular에서 파일 및 폴더 구조는 프로젝트의 소스 코드에 논리적인 구성을 제공하여 응용 프로그램을 보다 쉽게 관리하고 개발할 수 있도록 설계되었습니다. Angular 프로젝트에서 일반적으로 만날 수 있는 파일 및 폴더에 대한 간단한 개요는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- src: 이것은 애플리케이션의 소스 코드가 있는 주요 디렉터리입니다. 대부분의 코드는 여기에서 작업하게 됩니다.\n\n- app: 이곳에는 애플리케이션의 구성 요소, 서비스, 모듈 및 기타 관련 파일이 저장됩니다. 애플리케이션의 핵심 부분입니다.\n    - components: 각각이 TypeScript, HTML, CSS 및 기타 파일을 포함하는 개별 컴포넌트 폴더가 포함됩니다.\n    - services: 컴포넌트간에 공유 기능을 제공하는 서비스 파일이 포함됩니다.\n    - modules: 애플리케이션을 구성하고 구성하는 데 도움이 되는 Angular 모듈 파일이 포함됩니다.\n- assets: 이미지, 폰트 및 기타 파일과 같은 정적 에셋이 저장되는 곳입니다. 이러한 에셋은 애플리케이션에서 직접 액세스할 수 있습니다.\n- styles: 애플리케이션 전체에 적용되는 CSS 또는 SCSS 파일과 같은 글로벌 스타일이 포함됩니다.\n- index.html: 애플리케이션의 진입점으로 작동하는 주요 HTML 파일입니다.\n\n2. angular.json: 이 구성 파일은 Angular 프로젝트에 대한 다양한 설정을 정의합니다. 빌드 옵션, 에셋 경로 및 기타 프로젝트별 구성을 포함합니다.\n\n여기에 angular.json 파일의 주요 측면을 간단히 설명했습니다.\n\n<div class=\"content-ad\"></div>\n\n- projects: 이 섹션은 Angular 워크스페이스 내의 하나 이상의 프로젝트에 대한 구성을 포함합니다. 각 프로젝트는 워크스페이스 내의 응용 프로그램, 라이브러리 또는 기타 관련 코드를 나타냅니다.\n\n- architect: 이 하위 섹션은 프로젝트에서 실행할 수 있는 다양한 빌드, 테스트 및 서빙 작업을 정의합니다.\n    - build: 프로덕션 또는 개발용으로 프로젝트를 빌드하는 옵션을 구성합니다. 출력 경로, 에셋, 스타일, 스크립트 등을 지정할 수 있습니다.\n    - test: Karma 또는 Protractor와 같은 테스트 프레임워크를 사용하여 테스트 설정을 구성합니다.\n    - serve: 개발 서버 설정을 구성하여 개발 중에 응용 프로그램을 로컬로 제공합니다.\n    - lint: 코딩 표준에 대한 코드를 점검하기 위한 린트 옵션을 구성합니다.\n    - e2e: 사용자 상호 작용을 시뮬레이트하는 테스트를 실행하기 위한 엔드 투 엔드 (e2e) 테스트 설정을 구성합니다.\n\n2. schematics: 이 섹션은 사용자 정의 스키매틱을 정의하거나 프로젝트용으로 코드 및 파일을 생성하기 위해 타사 스키매틱을 사용하는 것을 허용합니다.\n\n3. cli: Angular CLI 자체와 관련된 설정을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n- defaultCollection: CLI가 코드를 생성할 때 사용해야 하는 스키마틱의 기본 컬렉션을 지정합니다.\n\n4. newProjectRoot: 워크스페이스 내에서 생성된 새 프로젝트의 루트 디렉토리를 정의합니다.\n\n5. sourceRoot: 응용 프로그램 소스 코드가 있는 루트 디렉토리를 지정합니다.\n\n6. prefix: 프로젝트 내에서 생성된 구성 요소, 지시문 및 기타 Angular 요소의 선택기에 자동으로 추가되는 접두어를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n7. targets: 각 프로젝트의 \"architect\" 섹션 내에서 특정 작업을 나타내는 \"targets\"가 있습니다. 이러한 targets는 Angular CLI를 사용하여 호출할 수 있습니다.\n\n- builder: 작업을 수행하는 데 책임을 지는 빌더(도구)를 지정합니다.\n- options: 작업에 대한 특정 옵션을 포함합니다.\n- configurations: \"build\" 작업에 대한 \"production\" 또는 \"development\"과 같은 다양한 구성을 정의합니다.\n\n3. tsconfig.json: 이 파일은 프로젝트의 TypeScript 컴파일러 옵션을 구성합니다.\n\n4. package.json: 이 파일은 프로젝트의 종속성과 스크립트에 관한 정보를 보유합니다. npm (Node Package Manager)에서 패키지 및 스크립트를 관리하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n여기에는 package.json 파일이 포함하는 내용을 자세히 살펴볼게요:\n\n- name: 이 필드는 프로젝트의 이름을 지정합니다. 이것은 고유한 식별자이며 네이밍 규칙을 따라야 합니다.\n- version: 프로젝트의 버전입니다. 변경 사항을 추적하고 업데이트를 관리하는 데 중요합니다.\n- scripts: 이 부분에서는 커맨드 라인을 사용하여 실행할 수 있는 사용자 정의 스크립트를 정의하는 중요한 섹션입니다. Angular 프로젝트에서 흔히 사용되는 일반적인 스크립트는 다음과 같습니다:\n\n- start: 개발 서버를 시작하는 데 사용됩니다.\n- build: 애플리케이션을 프로덕션용으로 빌드하는 데 사용됩니다.\n- test: 테스트를 실행하는 데 사용됩니다.\n- lint: 코드 린팅을 실행하는 데 사용됩니다.\n- 자동화할 요소를 정의하는 사용자 정의 스크립트\n\n4. dependencies: 이것은 프로젝트가 올바르게 작동하기 위해 의존하는 패키지를 나열합니다. 이 패키지들은 애플리케이션이 프로덕션 환경에서 실행되기 위해 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n5. devDependencies: 의존성과 유사하지만 이 패키지들은 개발 중에만 필요하며 최종 제품 빌드에서는 필요하지 않습니다.\n\n# 보간법(Interpolation)\n\n보간법은 Angular의 템플릿 구문에서의 기본적인 개념으로, 컴포넌트의 TypeScript 코드에서 HTML 템플릿 내에서 데이터 값을 동적으로 표시할 수 있게 해줍니다. 이는 컴포넌트의 논리와 데이터 조작을 템플릿의 사용자 인터페이스와 원활하게 결합하는 방법입니다. 보간법은 템플릿에서 이중 중괄호 ' '로 표시됩니다.\n\nAngular 컴포넌트와 템플릿의 예시:\n\n<div class=\"content-ad\"></div>\n\n변경 후: \n\nComponent (app.component.ts):\n\n```js\nexport class AppComponent {\n  greeting: string = 'Hello, Angular!';\n  count: number = 42;\n  \n  getDynamicValue(): string {\n    return 'Dynamic Value';\n  }\n}\n```\n\nTemplate (app.component.html):\n\n```js\n<h1>{{ greeting }}</h1>\n<p>The answer to everything is {{ count }}</p>\n<p>This is a {{ getDynamicValue() }}</p>\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 greeting, count 값 및 getDynamicValue() 함수의 결과가 보간을 사용하여 HTML에 동적으로 삽입됩니다. 컴포넌트 내에서 값이 변경되면 템플릿이 자동으로 해당 변경사항을 반영하여 업데이트됩니다.\n\n# Angular CLI 및 중요한 명령어\n\nAngular CLI(Command Line Interface)는 Angular 팀에서 제공하는 강력한 도구로, Angular 애플리케이션의 개발, 테스트 및 배포 작업을 간편화하는 데 사용됩니다. Angular CLI는 Angular 프로젝트 관리, 개발 및 유지보수와 관련된 다양한 작업을 간소화하는 일련의 명령어를 제공합니다.\n\nAngular CLI를 사용하려면 시스템에 Node.js 및 npm(Node Package Manager)이 설치되어 있어야 합니다. 다음 npm 명령어를 사용하여 Angular CLI를 전역으로 설치할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install -g @angular/cli\n```\n\n설치가 완료되면 CLI가 제공하는 다양한 명령어를 사용하여 Angular 애플리케이션을 효과적으로 생성, 개발, 테스트 및 배포할 수 있습니다.\n\n# Components\n\n구성 요소는 애플리케이션 사용자 인터페이스의 기본 구성 요소입니다. 특정 섹션을 나타내며 해당 섹션과 연결된 시각적 표현 (HTML 템플릿)과 로직 (Typescript 클래스)을 캡슐화합니다.\n\n<div class=\"content-ad\"></div>\n\n컴포넌트 생성: Angular CLI의 g c 명령어를 사용하여 새로운 컴포넌트를 생성하세요. 일반적인 구문은 다음과 같습니다:\n\n```js\nng g c 컴포넌트이름\n```\n\n원하는 컴포넌트 이름을 kebab-case(모두 소문자 및 하이픈 사용)로 지정하세요.\n\nAngular 컴포넌트 디렉토리 내에서 일반적으로 찾을 수 있는 파일에 대한 자세한 설명은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- Component Class (Typescript):\n\n- component-name.component.ts: 이 TypeScript 파일에는 컴포넌트의 동작 및 로직을 정의하는 클래스가 포함되어 있습니다. 속성, 메서드, 이벤트 핸들러, 라이프사이클 훅 및 컴포넌트와 관련된 다른 로직이 포함됩니다.\n\n2. Template (HTML):\n\n- component-name.component.html: 이 HTML 파일은 컴포넌트의 사용자 인터페이스의 구조와 내용을 정의합니다. HTML 요소, 데이터 바인딩, 디렉티브 및 동적 콘텐츠를 위한 자리 표시자가 포함될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3. 스타일 (CSS 또는 SCSS):\n\n- component-name.component.css: 이 CSS 파일에는 컴포넌트에 특화된 스타일이 포함되어 있습니다. 여기에는 일반적인 CSS 스타일을 사용할 수 있습니다.\n- component-name.component.scss: 선택적으로, 더 강력하고 모듈식으로 스타일을 작성하고자 하는 경우 SCSS(Sass) 스타일을 사용할 수 있습니다.\n\n4. 테스트 파일 (선택 사항):\n\n- component-name.component.spec.ts: 이 TypeScript 파일에는 해당 컴포넌트의 유닛 테스트가 포함되어 있습니다. Jasmine과 Karma와 같은 테스트 프레임워크 및 도구를 사용하여 컴포넌트가 예상대로 작동하는지 확인하기 위해 테스트를 작성하고 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 인라인 스타일이 포함된 컴포넌트\n\n인라인 스타일을 사용하여 Angular 컴포넌트를 만들려면 @Component() 데코레이터 내에서 styles 속성을 사용하여 컴포넌트의 스타일을 직접 정의해야 합니다. 이 방법은 컴포넌트 템플릿과 밀접한 관련이 있는 간단하고 구체적인 스타일을 추가하는 데 유용할 수 있습니다.\n\n아래 명령어를 실행해보세요\n\n```js\nng g c 컴포넌트명 --inline-style\n```\n\n<div class=\"content-ad\"></div>\n\n컴포넌트 TypeScript 파일을 수정하세요 (component-name.component.ts): 컴포넌트의 TypeScript 파일을 열어 @Component() 데코레이터를 업데이트하여 styles 속성을 포함시키세요. styles 속성은 각각 CSS 규칙을 포함하는 문자열 배열이어야 합니다.\n\n다음은 예시입니다:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styles: [\n    `\n    .my-component-container {\n      background-color: lightblue;\n      padding: 20px;\n    }\n    `,\n    `\n    h2 {\n      color: red;\n    }\n    `\n  ]\n})\nexport class MyComponent { }\n```\n\n# 모듈들\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서 모듈은 관련 컴포넌트, 서비스, 디렉티브 및 기타 코드를 응집 단위로 구성하는 메커니즘입니다. 모듈은 애플리케이션을 모듈화하고 기능을 그룹화하여 관심사 분리를 촉진하는 데 도움이 됩니다. 앵귤러 애플리케이션은 여러 모듈을 결합하여 구축되며 각 모듈은 애플리케이션의 특정 부분을 담당합니다.\n\n모듈 생성: 새 모듈을 생성하려면 Angular CLI의 generate module 명령을 사용하세요. 일반적인 구문은 다음과 같습니다:\n\n```js\nng generate module 모듈이름\n```\n\n모듈 이름을 케밥 케이스(소문자와 하이픈 사용)로 입력해주세요.\n\n<div class=\"content-ad\"></div>\n\n아래는 Angular 모듈을 만드는 간단한 예제입니다:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n# 함수 만들고 호출하기\n\n함수는 종종 메서드로 불리며, 컴포넌트와 서비스 내에서 정의되어 로직을 캡슐화하고, 이벤트를 처리하며, 계산을 수행하고, 데이터와 상호 작용하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent {\n  counter: number = 0;\n\n  incrementCounter() {\n    this.counter++;\n  }\n}\n```\n\n```js\n<button (click)=\"incrementCounter()\">Increment Counter</button>\n```\n\n# Events\n\nAngular에서 이벤트는 응용 프로그램의 사용자 인터페이스 내에서 발생하는 상호 작용 또는 발생하는 사건을 의미합니다. 이러한 상호 작용은 클릭, 키 누름, 마우스 이동, 입력 변경 등과 같은 작업을 포함할 수 있습니다. Angular는 이러한 이벤트를 처리하고 사용자에게 동적이고 상호 작용적인 경험을 제공하기 위해 이에 응답하는 메커니즘을 제공합니다. Angular에서 이벤트의 주요 측면은 다음과 같습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 이벤트 바인딩: 이벤트 바인딩은 사용자 상호작용으로 트리거된 이벤트를 청취하고 응답하는 방법입니다. 컴포넌트 클래스에서 메서드를 템플릿의 이벤트와 바인딩하는 것을 말합니다. (event) 구문을 사용합니다.\n\n```js\n<button (click)=\"handleClick()\">Click Me</button> \n<input (input)=\"handleChange($event)\">\n```\n\n2. 이벤트 객체: 이벤트가 트리거되면 이벤트 핸들러 메서드로 이벤트 객체가 전달됩니다. 이 객체에는 이벤트 유형, 대상 요소 등의 정보가 포함되어 있습니다.\n\n```js\nhandleClick(event: MouseEvent) {\n   console.log(`Button clicked! Event type: ${event.type}`);\n }  \nhandleChange(event: Event) {\n   const inputValue = (event.target as HTMLInputElement).value;\n   console.log(`Input value changed: ${inputValue}`); \n}\n```\n\n<div class=\"content-ad\"></div>\n\n3. 이벤트 유형: 다양한 이벤트 유형은 사용자 상호작용에 해당합니다. 클릭, 입력, 변경, 마우스 진입, 마우스 이탈, 키 다운, 키 업 등이 일반적인 이벤트 유형입니다.\n\n4. 이벤트 수정자: Angular은 이벤트 동작을 수정할 수 있는 이벤트 수정자를 제공합니다. 예를 들어, stopPropagation 수정자를 사용하여 이벤트 전파를 방지하는 방법과 함께 (click) 이벤트를 사용할 수 있습니다.\n\n\\js\n<button (click.stop)=\"handleClick()\">Click Me</button>\n\\\n\n5. 양방향 데이터 바인딩: Angular은 [(ngModel)] 지시문을 사용하여 양방향 데이터 바인딩을 지원합니다. 이는 입력 요소에 대해 데이터 속성과 이벤트 핸들링을 함께 바인딩하여 뷰와 모델을 동기화하는 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n```typescript\n<input [(ngModel)]=\"username\">\n```\n\n6. 사용자 정의 이벤트: Angular의 EventEmitter를 사용하여 사용자 정의 이벤트를 생성하고 emit할 수도 있습니다. 부모 및 자식 컴포넌트 간에 통신이 필요할 때 특히 유용합니다.\n\n```typescript\nimport { Component, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: '<button (click)=\"emitCustomEvent()\">이벤트 발생</button>'\n})\nexport class ChildComponent {\n  @Output() customEvent = new EventEmitter<void>();\n\n  emitCustomEvent() {\n    this.customEvent.emit();\n  }\n}\n```\n\n```html\n<app-child (customEvent)=\"handleCustomEvent()\"></app-child>\n```\n\n<div class=\"content-ad\"></div>\n\n이벤트를 바인딩하고 구성 요소의 메서드에서 처리함으로써 사용자가 응용 프로그램과 상호 작용하여 다양한 작업 및 동작을 트리거할 수 있습니다.\n\n## 속성 바인딩\n\n속성 바인딩은 Angular의 핵심 개념으로, HTML 요소 및 Angular 지시문의 속성이나 속성을 동적으로 설정하고 업데이트할 수 있게 해줍니다. 속성 바인딩을 사용하면 HTML 요소나 Angular 지시문의 속성을 구성 요소의 TypeScript 코드에서 정의된 표현식이나 값에 바인딩할 수 있습니다. 이를 통해 동적이고 데이터 주도형 사용자 인터페이스를 만들 수 있습니다.\n\nAngular의 속성 바인딩에 대해 이해해야 할 주요 포인트는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n바인딩 구문: 템플릿에서 속성 바인딩은 대괄호 []를 사용하여 수행합니다. 대괄호 안에 바인딩할 속성을 넣고, 등호와 바인딩할 식 또는 값을 넣습니다.\n\n```js\n<!-- 이미지 요소의 \"src\" 속성을 바인딩하는 예시 -->\n<img [src]=\"imageUrl\">\n```\n\n컴포넌트 속성에 바인딩: 대부분의 경우, 속성은 컴포넌트의 TypeScript 코드에서 정의된 값이나 표현식에 바인딩합니다. 이를 통해 컴포넌트 데이터에 따라 속성을 동적으로 업데이트할 수 있습니다.\n\n```js\nexport class MyComponent {\n  imageUrl = 'path/to/default-image.jpg';\n}\n```\n\n<div class=\"content-ad\"></div>\n\n앵귤러 디렉티브와 속성 바인딩: 속성 바인딩은 주로 앵귤러 디렉티브와 함께 사용됩니다. 예를 들어, 내장 디렉티브인 ngStyle, ngClass 또는 ngIf와 같은 속성을 바인딩할 수 있습니다. 또한 사용자 정의 디렉티브와도 속성을 바인딩할 수 있습니다.\n\n```js\n<div [ngStyle]=\"{ 'font-size.px': fontSize }\">동적 글꼴 크기</div>\n<button [disabled]=\"isDisabled\">클릭하세요</button>\n```\n\nDOM 속성에 바인딩: src, href, disabled, value, innerText 등과 같은 표준 HTML 요소 속성에 바인딩할 수 있습니다. 또한 사용자 정의 앵귤러 컴포넌트에서 정의된 사용자 정의 속성에도 바인딩할 수 있습니다.\n\n단방향 바인딩: 속성 바인딩은 일방향 바인딩의 한 형태입니다. DOM 요소나 디렉티브의 속성을 컴포넌트 데이터를 기반으로 설정하지만, DOM 요소의 변화는 컴포넌트 데이터에 영향을 미치지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# If-Else\n\n앵귤러 템플릿에서는 if-else 조건에 따라 조건부 렌더링을 생성하기 위해 구조적 디렉티브를 사용할 수 있습니다. 이 용도에 가장 적합한 주 디렉티브는 *ngIf이며, 이를 사용하면 표현식을 평가하여 DOM에서 요소를 조건부로 렌더링하거나 제거할 수 있습니다. 또한 *ngIf와 함께 else 키워드를 사용하여 if-else 구조를 구현할 수 있습니다. 안내해드리는 방법과 같이 Angular 템플릿에서 if-else 조건을 사용하는 방법을 알아보세요:\n\n```js\n<div *ngIf=\"condition; else elseBlock\">\n  <!-- 조건이 참일 때 표시할 내용 -->\n</div>\n<ng-template #elseBlock>\n  <!-- 조건이 거짓일 때 표시할 내용 -->\n</ng-template>\n```\n\n이 예시에서는:\n\n<div class=\"content-ad\"></div>\n\n- condition은 당신의 컴포넌트의 TypeScript 코드에서의 불리언 표현식입니다.\n- condition이 참이면 *ngIf 블록 내에 있는 내용이 표시됩니다.\n- condition이 거짓이면 elseBlock 템플릿 내에 있는 내용이 표시됩니다.\n\n템플릿의 삼항 연산자: 간단한 if-else 조건에 대해 템플릿에서 삼항 연산자 (? :)를 사용하여 내용을 조건부로 렌더링할 수 있습니다:\n\n```js\n<div>\n  { condition ? 'condition이 true인 경우 표시됩니다.' : 'condition이 false인 경우 표시됩니다.' }\n</div>\n```\n\n다중 if-else 조건에 대한 내용:\n\n<div class=\"content-ad\"></div>\n\n```js\n<ng-template [ngIf]=\"color==='red'>\n    <h1>Red Color</h1>\n<ng-template>\n\n<ng-template [ngIf]=\"color==='green'>\n    <h1>Green Color</h1>\n<ng-template>\n\n<ng-template [ngIf]=\"color==='blue'>\n    <h1>Blue Color</h1>\n<ng-template>\n```\n\n# Switch case\n\nAngular 템플릿에서는 ngSwitch 지시문을 사용하여 switch-case 로직을 구현할 수 있습니다. ngSwitchCase 또는 ngSwitchDefault를 사용하여 식의 값에 따라 내용을 조건부로 렌더링할 수 있습니다.\n\n```js\n<div [ngSwitch]=\"selectedOption\">\n  <p *ngSwitchCase=\"'option1'\">Option 1 is selected.</p>\n  <p *ngSwitchCase=\"'option2'\">Option 2 is selected.</p>\n  <p *ngSwitchCase=\"'option3'\">Option 3 is selected.</p>\n  <p *ngSwitchDefault>No option is selected.</p>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서:\n\n- selectedOption은 선택된 옵션을 포함하는 컴포넌트의 TypeScript 코드의 속성입니다.\n- [ngSwitch] 지시문은 평가할 표현식을 지정하는 데 사용됩니다.\n- 각 *ngSwitchCase 블록은 selectedOption의 특정 값에 대해 확인하고 콘텐츠를 그에 맞게 표시합니다.\n- *ngSwitchDefault 블록은 ngSwitchCase 조건 중 어느 것도 일치하지 않을 때 기본 케이스로 사용됩니다.\n\n다음은 컴포넌트의 TypeScript 코드에서 selectedOption 속성을 정의하는 간단한 예시입니다:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent {\n  selectedOption: string = 'option1'; // Initially set to option1\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# for 문\n\n앵귤러 템플릿에서 *ngFor 디렉티브를 사용하여 배열이나 리스트와 같은 컬렉션을 순회하고 반복할 수 있습니다. 이 디렉티브를 사용하면 컬렉션의 각 항목마다 요소를 렌더링할 수 있습니다.\n\n```js\n<ul>\n  <li *ngFor=\"let item of items\">\n    { item }\n  </li>\n</ul>\n```\n\n이 예시에서:\n\n<div class=\"content-ad\"></div>\n\n- items은 컴포넌트의 TypeScript 코드에서 배열 또는 반복 가능한 컬렉션입니다.\n- *ngFor 지시문은 li 요소에 적용됩니다.\n- let item of items는 각 항목을 나타내는 템플릿 변수인 item이 포함된 루프를 정의합니다.\n- let i = index는 현재 항목의 인덱스에 액세스하기 위한 선택적인 템플릿 변수 i를 정의합니다.\n\n이 코드는 items 배열의 각 항목에 대해 목록 항목 (li)을 가진 정렬된 목록 (ul)을 렌더링합니다. i + 1 표현식을 사용하여 항목의 인덱스 (1부터 시작)와 그 값을 표시합니다.\n\n다음은 컴포넌트의 TypeScript 코드에서 items 속성을 정의하는 방법의 예시입니다:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent {\n  items: string[] = ['Item 1', 'Item 2', 'Item 3', 'Item 4'];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 중첩 루프\n\nAngular 템플릿에서는 여러 *ngFor 지시문을 중첩하여 중첩된 루프를 생성할 수 있습니다. 이를 통해 배열의 배열이나 배열을 포함하는 객체의 배열과 같은 중첩된 컬렉션을 반복할 수 있습니다. Angular 구성 요소의 템플릿에서 중첩된 루프를 만드는 방법의 예시는 다음과 같습니다:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent {\n  nestedArray: number[][] = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ];\n}\n```\n\n템플릿에서는 이 데이터 구조를 반복하는 데 중첩된 *ngFor 루프를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<table>\n  <tr *ngFor=\"let row of nestedArray\">\n    <td *ngFor=\"let cell of row\">\n      { cell }\n    </td>\n  </tr>\n</table>\n```\n\n이 예제에서:\n\n- 외부 *ngFor 반복문은 nestedArray의 각 행을 반복합니다.\n- 내부 *ngFor 반복문은 현재 행 내의 각 셀을 반복합니다.\n- cell은 중첩된 배열 내의 각 값을 나타내며, 표 셀 (`td`)에 표시됩니다.\n\n이 코드는 각 행이 nestedArray에서 값을 포함하는 표를 렌더링하며, 중첩된 루프의 기본적인 예제를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 Angular의 흥미로운 세계로 첫 걸음을 내딛어본 바 있습니다. 이 글에서는 동적이고 견고한 웹 애플리케이션을 구축하는 기초가 되는 핵심 개념을 탐구했습니다. Angular의 필수 개념인 파일 및 폴더 구조 이해부터 모듈, 컴포넌트, 보간(interpolation), 속성 바인딩까지 다뤘습니다. 게다가, *ngIf로 조건부 렌더링을 구현하는 방법과 *ngFor를 사용하여 반복문을 만드는 법을 배웠습니다.\n\nAngular 여정의 첫 부분을 마무리하면서 이러한 핵심 개념에 대한 강력한 이해를 키워 더 고급 주제와 기술을 다루는 두 번째 부분을 위한 탄탄한 기초를 마련했습니다. 다가오는 세그먼트에서는 Angular의 강력한 기능인 서비스, 라우팅, 폼, HTTP 상호작용 등을 탐험할 예정입니다.\n\n계속 주목해 주세요! Angular 탐험의 두 번째 부분은 학습 여정의 흥미로운 이어짐을 약속합니다. 여기서는 최신 대화형 웹 애플리케이션을 쉽게 구축할 수 있는 도구와 기술을 발견할 것입니다. 그동안 배운 내용을 탐험하고 연습하며 Angular에 대한 이해를 견고히 다지는 것이 가장 좋은 방법이며 개발 전문성이 발전하는 길을 열어줄 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-AngularBasictoAdvanceEveryConceptExplainedpart1_0.png"},"coverImage":"/assets/img/2024-06-22-AngularBasictoAdvanceEveryConceptExplainedpart1_0.png","tag":["Tech"],"readingTime":16},{"title":"Angular Content Security Policy 위반 사항 보고하는 방법 ","description":"","date":"2024-06-22 14:55","slug":"2024-06-22-AngularWayswecanreportContentSecurityPolicyViolations","content":"\n\n귀하의 애플리케이션에서 발생한 CSP 위반 사항을 추적하여 해당 보고서를 응용 프로그램 서버로 전송하여 분석할 수 있습니다. 이를 위해 Content-Security-Policy 헤더의 report-to 또는 report-uri 지시문을 사용하면 됩니다.\n\nreport-uri은 더 이상 권장되지 않으며 report-to가 이를 대체하기 위해 도입되었습니다. 그러나 모든 브라우저에서 report-to가 아직 지원되지 않으므로 호환성을 위해 두 지시문을 모두 사용하는 것이 좋습니다.\n\n아래 예시를 참고해 보세요. 여기서는 report-uri 지시문을 추가하여 브라우저에게 위반 보고서를 JSON 문서 형식으로 작성하여 HTTP POST 요청을 사용해 https://csrfexample.com:3443/reportViolations로 보내도록 지시하고 있습니다:\n\n```js\n“Content-Security-Policy”:”default-src ‘self’;report-uri https://csrfexample.com:3443/reportViolations\"\n```\n\n<div class=\"content-ad\"></div>\n\n이제 CSP를 위반해보고 위반 보고서가 어떻게 전송되는지 살펴보겠습니다. 내 Angular 앱은 https://innocent.csrfexample.com:4200에서 호스팅되어 있습니다.\n\nAppComponent에서 https://csrfexample.com:3443에서 이미지를 로드하고 있습니다. 이는 default-src 지시어를 위반합니다. default-src 지시어는 'self'로 설정되어 있기 때문에 응용 프로그램에서 https://innocent.csrfexample.com:4200과 다른 출처에서 리소스가로드되는 경우 위반으로 간주됩니다.\n\n```js\n<img src=\"https://csrfexample.com:3443/getImage\">\n```\n\nAngular.json의 \"serve\" 섹션에 \"headers\" 속성을 아래와 같이 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n“serve”: {\n“builder”: “@angular-devkit/build-angular:dev-server”,\n“options”: {\n“sslKey”: “./self-signed-with-no-passphrase/secureAngularExample.key”,\n“sslCert”: “./self-signed-with-no-passphrase/secureAngularExample.crt”,\n“ssl”: true\n},\n“configurations”: {\n“production”: {\n“browserTarget”: “csrfInAngular:build:production”\n},\n“development”: {\n“browserTarget”: “csrfInAngular:build:development”,\n“headers”: {\n“Content-Security-Policy”:”default-src ‘self’;report-uri https://csrfexample.com:3443/reportViolations\"\n}\n}\n},\n“defaultConfiguration”: “development”\n}\n```\n\n저는 https://csrfexample.com:3443에 호스팅된 Node Express 서버를 만들었고, 위반 데이터를받기 위한 POST 경로를 만들었습니다.\n\n```js\nrouter.post(‘/reportViolations’,(req,res,next)=>{\nres.status(200).send(“위반 사항이 성공적으로 수신되었습니다”)\n})\n```\n\n브라우저에서 https://innocent.csrfexample.com:4200을 입력하면, https://csrfexample.com:3443/getImage로의 http GET 요청이 CSP에 의해 차단되었음을 확인할 수 있으며, https://csrfexample.com:3443/reportViolations으로 3개의 http POST 요청을 보게 됩니다. 각 POST 요청에는 개별 위반 사항의 보고서가 포함되어 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n지금 3개의 위반 보고서 내용을 확인해보겠습니다.\n\n정책을 시행하지 않고 CSP 위반 사항을 모니터링할 수 있나요?\n\n네! Content-Security-Policy-Report-Only 헤더를 사용하면 정책을 강제하지 않고 모니터링함으로써 정책을 실험할 수 있습니다.\n\nangular.json 파일의 \"serve\" 섹션 아래 headers 속성을 아래와 같이 수정해봅시다:\n\n<div class=\"content-ad\"></div>\n\n```js\n“serve”: {\n“builder”: “@angular-devkit/build-angular:dev-server”,\n“options”: {\n“sslKey”: “./self-signed-with-no-passphrase/secureAngularExample.key”,\n“sslCert”: “./self-signed-with-no-passphrase/secureAngularExample.crt”,\n“ssl”: true\n},\n“configurations”: {\n“production”: {\n“browserTarget”: “csrfInAngular:build:production”\n},\n“development”: {\n“browserTarget”: “csrfInAngular:build:development”,\n“headers”: {\n \"Content-Security-Policy-Report-Only\":\"default-src 'self';report-uri https://csrfexample.com:3443/reportViolations\"\n}\n}\n},\n“defaultConfiguration”: “development”\n}\n```\n\n애플리케이션을 재시작하여 변경 사항을 확인해 봅시다.\n\n아래 이미지가 성공적으로 로드된 것을 관찰할 수 있습니다. CSP default-src 지시문이 강제되지 않았지만 이 지시문과 관련된 위반 사항이 서버에 성공적으로 게시되었습니다. 아래 2번째 스크린샷에서 확인할 수 있습니다.\n\n애플리케이션 서버가 위반 보고서 처리 책임을 다른 신뢰할 수 있는 시스템에 맡길 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n그래요! https://report-uri.com/ 이 도움을 줄 거에요. 테스트 목적으로 무료 계정을 만들고 계정별 보고 URL을 사용해 위반 보고서를 게시할 수 있어요.\n\n지금까지 한 모든 것은 그대로 유지돼요. 변하는 것은 보고서를 게시할 URL 뿐이죠. 보안 정책을 강제하고 싶든 원하지 않든, 이 방법은 여러분에게 완벽히 도움이 될 거에요.\n\n위반 보고서를 보내기 위해 report-uri.com 서버로 3개의 HTTP POST 요청을 확인해보세요.\n\n대시보드에 나타나는 CSP 위반 보고서는 이렇게 생겼어요.","ogImage":{"url":"/assets/img/2024-06-22-AngularWayswecanreportContentSecurityPolicyViolations_0.png"},"coverImage":"/assets/img/2024-06-22-AngularWayswecanreportContentSecurityPolicyViolations_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular와 ngRX를 사용하여 OIDC 인증 구현하는 방법","description":"","date":"2024-06-22 14:54","slug":"2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX","content":"\n\nangular-oauth2-oidc 라이브러리를 사용하여 JWT 토큰 처리를 자동화하고 있어요.\n\n![이미지](/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png)\n\n다들 OIDC를 여기서, 거기서 계속 듣곤 하는데, 정확히 무슨 의미일까요?\n\nMicrosoft의 정의를 따르면 OpenId Connect (OIDC)은 권한 부여 (OAuth 2.0의 확장)의 인증 프로토콜로, 디지털 서비스에 액세스하기 위한 로그인 프로세스를 표준화한 것이라고 해요.\n\n<div class=\"content-ad\"></div>\n\n다른 말로, 사용자 데이터를 공유하지 않고 관련없는 응용 프로그램에서 사용자를 확인하는 메커니즘입니다. 이 방법을 통해 사용자는 한 번만 로그인하고 여러 응용 프로그램에 액세스할 수 있습니다.\n\n이러한 메커니즘은 이미 상당히 인기가 있으며 기업들이 이미 자사의 생태계에 통합하기 시작했습니다.\n\n그래, 이제 기본 개념을 파악하고 OIDC가 해결하고자 하는 문제 유형과 목표를 알게 되었습니다. 그 목표는 다음 단계를 통해 달성됩니다:\n\n- 사용자가 특정 응용 프로그램에 입력하여 OpenID 제공자로 리디렉션됩니다.\n- 사용자가 사용자 이름과 암호를 제공합니다.\n- 사용자 자격 증명이 OpenID 제공자로 전달됩니다.\n- 제공자가 자격 증명을 확인하고 권한을 획득합니다.\n- 사용자가 ID 토큰을 포함하여 원래의 응용 프로그램으로 리디렉션됩니다.\n\n<div class=\"content-ad\"></div>\n\n복잡해 보이죠?\n\n하지만 구현하기가 생각보다 어렵지 않습니다. 외부 라이브러리를 전혀 사용하지 않고 자체 솔루션을 구축하려고 하면 좀 더 많은 시간이 걸릴 것입니다. 로켓 과학은 아니지만 전적으로 혼자서 해결할 필요는 없습니다. Angular 세계에서 소개 없이 잘 알려진 Manfred Steyer가 개발한 angular-oauth2-oidc 라이브러리가 있습니다.:-))\n\n이 라이브러리는 모듈 기반 및 독립형 접근 방식을 포함하여 다양한 Angular 버전을 지원합니다. 제대로 설정하면 리디렉션, 요청 헤더에 토큰 추가, 심지어 토큰 갱신에 대해 걱정할 필요가 없습니다!\n\n먼저 모듈 기반 접근 방식부터 시작해 보죠. 하지만 그 전에 프로젝트 의존성에 라이브러리를 추가해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm i angular-oauth2-oidc --save\n```\n\n라이브러리가 성공적으로 설치되면 구성 및 처리를 설정하기 위해 일부 준비를 해야합니다.\n\n인가를 처리하기 위해 이미 존재하는 사용자 기능 저장소의 구현을 사용할 것입니다. 해당 주제에 익숙하지 않다면 다른 기사를 참조해주세요:\n\n이제 동일한 페이지에 있는 경우 사용자 기능 저장소를 확장하여 OIDC를 처리해봅시다.\n\n<div class=\"content-ad\"></div>\n\n먼저 user.state.ts 파일에서 UserState를 아래와 같이 추가 속성과 함께 확장해 보겠습니다.\n\n```js\nexport interface UserState {\n  // ... 다른 속성들\n  loggedIn: boolean;\n  logInRequestHandled: boolean;\n}\n\nexport const initialState: UserState = {\n  // ... 다른 속성들\n  loggedIn: false,\n  logInRequestHandled: false,\n};\n```\n\n또한 user.selectors.ts 파일에서 store에서 정보를 다시 가져오기 위한 selector를 만들어 봅시다.\n\n```js\nexport const selectIsLogInRequestHandled = createSelector(\n  selectUserState,\n  ({ logInRequestHandled }: UserState) => logInRequestHandled\n);\n```\n\n<div class=\"content-ad\"></div>\n\n전체 프로세스를 탐색하는 데 도움이 되는 일부 동작을 정의해야 합니다. 이를 user.actions.ts 파일 내에 다음과 같이 작성해야 합니다:\n\n```js\nconst user = '[사용자]';\n// ... 다른 액션들\nexport const logIn = createAction(`${user} 로그인`);\nexport const logInSuccess = createAction(`${user} 로그인 성공`);\nexport const logInError = createAction(`${user} 로그인 오류`);\n```\n\n우리의 액션들은 상태에 영향을 미쳐야 하므로 user.reducer.ts 파일 내에서 이러한 상태 변경이 어떻게 발생할지를 정의해야 합니다:\n\n```js\nimport { createReducer, on } from '@ngrx/store';\nimport {\n  initialState,\n  logInSuccess,\n  UserState,\n  logInError,\n} from './index';\n\nexport const userReducer = createReducer(\n  initialState,\n  // ... 일부 다른 액션들\n  on(logInSuccess, (state: UserState) => ({ \n      ...state, \n      loggedIn: true, \n      logInRequestHandled: true,\n   })),\n  on(logInError, (state: UserState) => ({ \n      ...state, \n      loggedIn: false, \n      logInRequestHandled: true,\n   }))\n);\n```\n\n<div class=\"content-ad\"></div>\n\n거의 완성 단계에 다다랐어요. UsersFacade를 user.facade.ts 파일 내부에서 업데이트해야하며, 모두 통합할 수 있게 될 거예요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { UserState } from './user.state';\nimport { logIn } from './user.actions';\nimport { selectIsLogInRequestHandled } from './user.selectors';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class UserFacadeService {\n    readonly logInRequestHandled$: Observable<boolean> = this.store.select(selectIsLogInRequestHandled);\n\n    constructor(private readonly store: Store<UserState>) {} // 생성자 대신에 주입 토큰 사용할 수 있어요\n\n    logIn(): void {\n        this.store.dispatch(logIn());\n    }\n}\n```\n\n이제 준비 상태를 설정하겠어요. 앞으로 모두 통합하기 위해 user.effects.ts 파일 내에서 비동기 작업을 정의해야 해요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { catchError, map, mergeMap, tap } from 'rxjs/operators';\nimport { EMPTY, from, iif } from 'rxjs';\nimport {\n    getUserSettings,\n    logIn,\n    logInError,\n    logInSuccess,\n} from './index';\nimport { OAuthErrorEvent, OAuthEvent, OAuthService, OAuthSuccessEvent } from 'angular-oauth2-oidc';\nimport { environment } from '../../../environments/environment';\n\n@Injectable({ providedIn: 'root' })\nexport class UserEffects {\n    constructor(\n        private readonly actions$: Actions,\n        private readonly router: Router,\n        private readonly oAuthService: OAuthService\n    ) {\n        this.oAuthService.configure(environment); // 공급자 구성\n        this.oAuthService.setupAutomaticSilentRefresh(); // 조용한 자동 토큰 새로고침, 그렇지 않으면 토큰이 오래되어 refresh되지 않을 수 있어요\n    }\n\n    listenOAuth$ = createEffect(() =>\n        this.oAuthService.events.pipe(\n            mergeMap((event: OAuthEvent) => {\n                if (event instanceof OAuthErrorEvent) {\n                    return [logInError()];\n                }\n                if (event instanceof OAuthSuccessEvent && event.type === 'token_received') {\n                    return [logInSuccess()];\n                }\n\n                return EMPTY;\n            })\n        )\n    );\n\n    logIn$ = createEffect(() =>\n        this.actions$.pipe(\n            ofType(logIn),\n            mergeMap(() =>\n                iif(\n                    () => this.oAuthService.hasValidIdToken() && this.oAuthService.hasValidAccessToken(),\n                    [logInSuccess()],\n                    from(this.oAuthService.loadDiscoveryDocumentAndLogin()).pipe(\n                        tap((result: boolean): void => {\n                            if (!result) {\n                                this.oAuthService.initCodeFlow();\n                            }\n                        }),\n                        mergeMap(() => EMPTY),\n                        catchError(() => [logInError()])\n                    )\n                )\n            )\n        )\n    );\n\n    logInSuccess$ = createEffect(() => this.actions$.pipe(ofType(logInSuccess), map(getUserSettings)));\n\n    logInError$ = createEffect(\n        () =>\n            this.actions$.pipe(\n                ofType(logInError),\n                tap(() => this.router.navigate(['no-access']))\n            ),\n        { dispatch: false }\n    );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그래서, 이제 angular-oauth2-oidc 라이브러리 구현에 대해 이야기해보겠습니다. 라이브러리 자체에 공급자 정보를 설정하기 위해 전달하는 초기 정보가 있는 구성 파일이 필요합니다. 아래는 라이브러리 문서에서 가져온 기본 구현입니다. 그러나 애플리케이션이 배포될 다양한 환경에 따라 구성이 다를 수 있으므로, 이를 환경.$'specific'.ts 파일 내에 유지하는 것을 제안합니다.\n\nMarkdown 포맷으로 표를 변경하겠습니다:\n\n```typescript\nimport { AuthConfig } from 'angular-oauth2-oidc';\n\nexport const authCodeFlowConfig: AuthConfig = {\n    // Identity Provider의 URL\n    issuer: 'https://idsvr4.azurewebsites.net',\n\n    // 로그인 후 사용자를 리디렉션할 SPA의 URL\n    redirectUri: window.location.origin + '/index.html',\n\n    // SPA의 ID. 해당 ID로 SPA가 권한 서버에 등록됨\n    clientId: 'spa',\n\n    // 권한 서버에서 비밀번호를 요구하는 경우 필요함. 일반적으로 이 경우,\n    // 권한 서버가 SPA를 고려하여 구성되지 않았다는 것을 의미하며, 보안을 위해 중요한 추가적인 최선의 방법을 강요할 수도 있음\n    // dummyClientSecret: 'secret',\n\n    responseType: 'code',\n\n    // 클라이언트가 요청해야 하는 권한의 범위 설정\n    // 처음 네 가지는 OIDC에서 정의된 것들임\n    // 중요: refresh 토큰을 받으려면 offline_access를 요청\n    // api scope는 usecase-specific한 것임\n    scope: 'openid profile email offline_access api',\n\n    showDebugInformation: true,\n};\n```\n\n모듈 기반 접근 방식:\n\n<div class=\"content-ad\"></div>\n\n```typescript\nimport { APP_INITIALIZER, NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { AppComponent } from './app.component';\nimport { UserFacadeService } from './store';\nimport { OAuthModule } from 'angular-oauth2-oidc';\nimport { filter } from 'rxjs/operators';\nimport { HttpClientModule } from '@angular/common/http';\n\nfunction initializeLogIn(userFacade: UserFacadeService): () => void {\n    return (): Observable<boolean> => {\n        userFacade.logIn();\n        return userFacade.logInRequestHandled$.pipe(filter(Boolean));\n    };\n}\n\n@NgModule({\n    declarations: [AppComponent],\n    imports: [\n        BrowserModule,\n        BrowserAnimationsModule,\n        HttpClientModule,\n        OAuthModule.forRoot({\n            resourceServer: { // You can pass the array of URIs entitled to include the authorization token or allow all requests by not passing it at all.\n                sendAccessToken: true,\n            },\n        }),\n    ],\n    providers: [\n        { \n          provide: APP_INITIALIZER, \n          useFactory: initializeLogIn, \n          deps: [UserFacadeService], \n          multi: true \n        },\n    ],\n    bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n위의 코드를 분석해봅시다. 우리는 initializeLogIn을 APP_INITIALIZER로 선언하고, 이를 주 애플리케이션 모듈 내의 providers 배열 안에 전달했습니다. 여기서 로그인 시도가 호출되고, UserFacade 소스로부터의 logInRequestHandled$ Observable이 true를 발행할 때까지 기다립니다.\n\nAPP_INITIALIZER가 무엇인지 잘 모르겠나요? 해당 주제와 관련된 다른 기사를 확인해보세요:\n\n또한 주 애플리케이션 모듈 내에서 Angular common 라이브러리에서 HttpClientModule와 방금 설치한 라이브러리인 OAuthModule을 import 했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 독립 실행 방식 Angular v15:\n\n```js\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideHttpClient } from '@angular/common/http';\nimport { AppComponent } from './app/app.component';\nimport { provideOAuthClient } from 'angular-oauth2-oidc';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideHttpClient(),\n    provideOAuthClient(),\n    { \n      provide: APP_INITIALIZER, \n      useFactory: initializeLogIn, \n      deps: [UserFacadeService], \n      multi: true,\n    },\n  ]\n});\n```\n\n# 독립 실행 방식 Angular v14:\n\n```js\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\nimport { AppComponent } from './app/app.component';\nimport { provideOAuthClient } from 'angular-oauth2-oidc';\nimport { importProvidersFrom } from '@angular/core';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    importProvidersFrom(HttpClientModule),\n    provideOAuthClient(),\n    { \n      provide: APP_INITIALIZER, \n      useFactory: initializeLogIn, \n      deps: [UserFacadeService], \n      multi: true,\n    },\n  ]\n});\n```\n\n<div class=\"content-ad\"></div>\n\nAngular v14에서는 독립적인 구성 요소가 여전히 실험 단계였고 모든 기능이 과거와 같이 공급자를 갖추지 않았다는 것이 차이점입니다.\n\n그게 전부에요, 이제 ngRX 기반의 OIDC 구현이 준비되었습니다!\n\n정말 쉬웠죠?\n\n프로젝트에 대한 상담이 필요하다면 언제든 연락주세요. 앱을 망치지 마시고 문의해주세요 :-)","ogImage":{"url":"/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png","tag":["Tech"],"readingTime":11},{"title":"완벽 가이드 Angular 다국어i18n 애플리케이션 만들기","description":"","date":"2024-06-22 14:52","slug":"2024-06-22-ACompleteGuideToAngularMultilingualApplicationi18n","content":"\n\nAngular i18n 애플리케이션을 초기화하고 구현해 보세요. Transloco를 사용하여 Angular에서 다국어 애플리케이션을 구현하는 방법을 안내하는 가이드입니다! 번역 파일의 지연 로딩을 포함하여 멀티 언어 애플리케이션을 구현하는 방법을 설명합니다.\n\n![Angular 다국어 애플리케이션 완벽 가이드 이미지](/assets/img/2024-06-22-ACompleteGuideToAngularMultilingualApplicationi18n_0.png)\n\n# 목차\n\n- 국제화 (i18n) 및 지역화 개요\n- Angular 애플리케이션 초기화 및 패키지 설치\n- 프로젝트 구성\n- 템플릿 내 번역\n- TypeScript 내 번역\n- 활성 언어 변경\n- 번역 파일의 지연 로딩\n\n<div class=\"content-ad\"></div>\n\n# 간단 요약\n\n본 GitHub 저장소의 구현된 예제 코드로 건너뛰어보고 여기에서 작동하는 데모를 확인할 수 있습니다.\n\n# 국제화 (i18n) 및 로컬라이제이션\n\n지난 수십 년 동안 전 세계의 사용자를 대상으로 한 애플리케이션이 많이 등장했습니다. 그에 따라 사용자의 언어와 문화에 따라 제품 및 서비스를 구현하는 필요성을 느끼게 되었습니다. 이 과정을 국제화 (i18n “I” - 열 여덟 개의 글자 - “N”)이라고 합니다. 반면 로컬라이제이션은 특정 제품을 고유한 지역 시장에 맞게 조정하는 것을 의미합니다. Angular 로컬라이제이션은 다양한 기능을 제공합니다:\n\n<div class=\"content-ad\"></div>\n\n- 다른 언어로 번역할 텍스트 추출\n- 특정 로캘을 위한 데이터 형식 지정\n\nAngular의 국제화를 사용할 수 있습니다:\n\n- 내장된 파이프를 사용하여 로컬 형식으로 날짜, 숫자, 백분율 및 통화를 표시합니다.\n- 컴포넌트 템플릿에서 번역할 텍스트 지정.\n- 번역할 표현의 복수 형태 지정.\n- 번역할 대체 텍스트 지정.\n\n![이미지](/assets/img/2024-06-22-ACompleteGuideToAngularMultilingualApplicationi18n_1.png)\n\n<div class=\"content-ad\"></div>\n\n# Angular 애플리케이션 초기화 및 패키지 설치하기\n\n먼저, Angular 애플리케이션을 만들어야 합니다! 당신의 컴퓨터에 Angular CLI가 설치되어 있는 것으로 가정합니다. Angular CLI를 사용하여 Angular 애플리케이션을 초기화하려면 다음과 같이 입력할 수 있습니다:\n\n```js\nng new <PROJECT_NAME>\n```\n\n이 Medium 스토리에서는 Angular 애플리케이션의 구현 세부 사항에 대해 다루지 않습니다. 프로젝트의 전체 구현을 보려면 GitHub 리포지토리를 참조하실 수 있습니다. ng serve 명령을 사용하여 Angular 애플리케이션을 시작하세요. 이제 Angular 프로젝트가 실행 중이므로 i18n의 구현 세부 사항으로 넘어가 봅시다.\n\n<div class=\"content-ad\"></div>\n\nTransloco를 사용하려고 합니다. 먼저 필요한 패키지를 설치해야 합니다.\n\n```js\nng add @ngneat/transloco\n```\n\n위 명령을 실행한 후에는 프로젝트에 새 파일이 생길 수 있습니다. Angular Universal을 사용하는지 여부와 지원할 언어 등 몇 가지 질문에 답해야 합니다.\n\n<div class=\"content-ad\"></div>\n\ntransloco-root.module.ts 파일에서 transloco의 구성 파일을 찾을 수 있습니다. 여기서 지원하는 언어, 애플리케이션의 기본 언어, 런타임에서 언어를 변경할지 여부를 변경할 수 있습니다. 모든 옵션 목록은 여기에서 찾을 수 있습니다.\n\n```js\nimport { HttpClient } from '@angular/common/http';\nimport {\n  TRANSLOCO_LOADER,\n  Translation,\n  TranslocoLoader,\n  TRANSLOCO_CONFIG,\n  translocoConfig,\n  TranslocoModule,\n} from '@ngneat/transloco';\nimport { Injectable, isDevMode, NgModule } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class TranslocoHttpLoader implements TranslocoLoader {\n  constructor(private http: HttpClient) {}\n\n  getTranslation(lang: string) {\n    return this.http.get<Translation>(`/assets/i18n/${lang}.json`);\n  }\n}\n\n@NgModule({\n  exports: [TranslocoModule],\n  providers: [\n    {\n      provide: TRANSLOCO_CONFIG,\n      useValue: translocoConfig({\n        availableLangs: ['en', 'de', 'fa'],\n        defaultLang: 'en',\n        reRenderOnLangChange: true,\n        prodMode: !isDevMode(),\n      }),\n    },\n    { provide: TRANSLOCO_LOADER, useClass: TranslocoHttpLoader },\n  ],\n})\nexport class TranslocoRootModule {}\n```\n\n이제 transloco-root.module.ts를 루트 모듈에 가져와야 합니다. 루트 모듈은 아마도 app.module.ts라고 할 것입니다.\n\n<img src=\"/assets/img/2024-06-22-ACompleteGuideToAngularMultilingualApplicationi18n_3.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 템플릿 내의 번역\n\n'ng add @ngneat/transloco' 명령을 실행한 후에는 지정한 모든 언어가 포함된 i18n 디렉터리가 assets 디렉터리에 나타납니다. 이것들은 주요 언어 파일입니다. 홈페이지나 헤더에서 사용할 수 있습니다. 하지만 각 모듈을 위한 고유한 디렉터리를 만들어서 해당 모듈로 lazy load할 수도 있습니다. 레이지 로딩에 대해서는 조금 후에 다룰 것입니다. 먼저 Transloco와 함께 작업을 시작해 봅시다.\n\n## 구조 지시문 사용\n\n템플릿에서 *transloco 지시문을 사용할 수 있습니다. 그러나 feature 모듈에는 translocoModule을 가져와야 하고, 주 페이지에는 translocoRootModule을 가져와야 합니다. 우리가 제목을 번역하려고 한다고 가정해 봅시다. 우리는 번역된 텍스트를 i18n 디렉터리의 JSON 파일에 포함해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nen.json 파일은 다음과 같이 보여야 합니다:\n\n```json\n{\n  \"title\": \"Hello World!\"\n}\n```\n\n그리고 다른 언어(예를 들어 독일어)로 번역할 경우 de.json 파일은 다음과 같아야 합니다:\n\n```json\n{\n  \"title\": \"Hallo Welt!\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n지금 저희 템플릿에서는 다음과 같이 디렉티브를 사용하여 선택한 언어의 값을 보여줄 수 있습니다:\n\n```js\n<h1 *transloco=\"let t\"> { t(\"title\") } </h1>\n```\n\n하지만 아래와 같이 중첩된 키 속성을 포함한 복잡한 JSON 구조를 가지고 있을 수도 있습니다:\n\n```js\n// JSON은 다음과 같은 주석을 지원하지 않습니다.\n// 이 주석은 단지 예시를 위한 것입니다.\n\n// en.json\n{\n  \"title\": \"Hello World!\",\n  \"form\": {\n     \"firstName\": \"First Name\",\n     \"lastName\": \"Last Name\"\n    }\n}\n\n// de.json\n{\n  \"title\": \"Hallo Welt!\",\n  \"form\": {\n     \"firstName\": \"Vorname\",\n     \"lastName\": \"Nachname\"\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 두 가지 옵션이 있습니다. t 함수의 중첩 항목을 사용하거나 값 찾기를 수행하는 where 지시문을 사용할 수 있습니다.\n\n```js\n<!-- 옵션 1 -->\n<h1 *transloco=\"let t\"> { t(\"form.firstName\") } </h1>\n\n<!-- 옵션 2 -->\n<h1 *transloco=\"let t; read:'form'\"> { t(\"firstName\") } </h1>\n```\n\n옵션 2가 더 읽기 쉽습니다.\n\n## 파이프 사용하기\n\n<div class=\"content-ad\"></div>\n\n다른 방법은 아래와 같이 파이프를 사용하는 것입니다:\n\n```js\n<h1>{ 'title' | transloco }</h1>\n```\n\n# TypeScript 내에서 번역\n\nTranslocoService를 컴포넌트에 주입한 후에는 아래와 같이 안전하게 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nexport class AppComponent {\n  constructor(private readonly translocoService: TranslocoService) {}\n\n  ngOnInit() {\n    this.translocoService.translate('title');\n    this.translocoService.translate('form.firstName');\n  }\n}\n```\n\n다른 번역 API도 여기에서 모두 찾을 수 있어요. 하지만 이러한 API가 올바르게 작동하려면 런타임에 번역 파일이 로드되었는지 확인해야 해요.\n\n# 활성 언어 변경\n\n사용자가 애플리케이션 언어를 변경하는 버튼을 클릭하면 애플리케이션의 선택된 언어를 변경해야 해요. 이를 위해 먼저 적절한 컴포넌트를 만들어 주세요. 완전히 구현된 컴포넌트는 여기에서 찾을 수 있어요.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { TranslocoService } from '@ngneat/transloco';\n\n@Component({\n  selector: 'app-language-selector',\n  template: `\n    <div>\n      <button\n        *ngFor=\"let language of languagesList; index as i\"\n        (click)=\"changeLanguage(language.code)\"\n      >\n        <img [src]=\"language.imgUrl\" [alt]=\"language.name\" />\n        <span> { language.shorthand } </span>\n      </button>\n    </div>\n  `,\n})\nexport class LanguageSelectorComponent {\n  constructor(private translocoService: TranslocoService) {}\n  public languagesList: \n    Array<Record<'imgUrl' | 'code' | 'name' | 'shorthand', string>> = [\n    {\n      imgUrl: '/assets/images/English.png',\n      code: 'en',\n      name: 'English',\n      shorthand: 'ENG',\n    },\n    {\n      imgUrl: '/assets/images/Deutsch.png',\n      code: 'de',\n      name: 'German',\n      shorthand: 'GER',\n    },\n    {\n      imgUrl: '/assets/images/Persian.png',\n      code: 'fa',\n      name: 'Persian',\n      shorthand: 'PER',\n    },\n  ];\n  public changeLanguage(languageCode: string): void {\n    this.translocoService.setActiveLang(languageCode);\n    languageCode === 'fa'\n      ? (document.body.style.direction = 'rtl')\n      : (document.body.style.direction = 'ltr');\n  }\n}\n```\n\n위 코드에서 보듯이 영어, 독일어, 페르시아어로 언어를 변경하는 세 개의 버튼을 구현했습니다. 사용자가 버튼을 클릭하면 선택한 언어 코드로 translocoService의 setActiveLang 메서드를 호출합니다.\n페르시아어나 아랍어와 같은 언어는 오른쪽에서 왼쪽으로 쓰이는 것을 고려해주세요. 애플리케이션의 방향을 rtl에서 ltr로 변경하는 것을 잊지 마세요.\n\n<img src=\"/assets/img/2024-06-22-ACompleteGuideToAngularMultilingualApplicationi18n_4.png\" />\n\n# 지연로딩 번역\n\n\n<div class=\"content-ad\"></div>\n\n애플리케이션 초기화 시 모든 번역 파일을 동시에 로드하는 것은 좋은 아이디어가 아닙니다. 특히 모듈이 많은 경우에는 그렇습니다. 애플리케이션의 로드 시간이 더 늘어날 뿐만 아니라 전체 애플리케이션을 위한 단일 번역 파일을 작업하는 것도 어려운 일입니다. 다행히 우리는 모듈에 번역 파일을 지연 로드할 수 있습니다.\n우리에게는 pageOne과 pageTwo라는 두 개의 모듈이 있다고 가정해 봅시다. 각 모듈에 대해 i18n 디렉토리 내에 디렉토리를 만들겠습니다. 각 언어에 대해 동일한 수의 JSON 파일로 디렉토리를 채워 주세요. 이제 각 모듈에 대한 범위를 지정하기만 하면 됩니다. 이를 수행하는 방법이 몇 가지 있습니다.\n\n```js\n<!-- pageOne 모듈 -->\n<h1 *transloco=\"let t; scope:'pageOne'\"> { t('title') } </h1>\n<!-- 위의 범위를 주의해서 확인하세요 -->\n```\n\n다른 세부 정보도 읽기 방법과 같습니다. TypeScript에서 번역을 지연로드하려면 쉽게 목표를 달성할 수 있습니다.\n\n먼저 translocoModule을 가져온 모듈에서 원하는 범위를 지정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst routes: Routes = [\n  {\n    path: '',\n    component: PageOneComponent\n  }\n];\n\n@NgModule({\n  declarations: [PageOneComponent],\n  providers: [{ provide: TRANSLOCO_SCOPE, useValue: 'pageOne' }],\n  imports: [RouterModule.forChild(routes), TranslocoModule]\n})\nexport class PageOneModule {}\n```\n\n이제 TypeScript 파일에서 아래와 같이 현재 scope에 접근할 수 있습니다:\n\n```js\nexport class AppComponent {\n  constructor(\n    private translocoService: TranslocoService, \n    @Inject(TRANSLOCO_SCOPE) private scope\n  ) {}\n\n  ngOnInit() {\n    this.translocoService.selectTranslate('title', params, this.scope)\n      .subscribe(console.log);\n  }\n}\n```\n\n컴포넌트에 TRANSLOCO_SCOPE를 인젝션하면 모듈의 현재 scope를 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 최종 결과물\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*WVqJR58gpb6SdUpsgpR-1g.gif)\n\n## 전체 구현 데모를 확인할 수 있습니다:\n\nhttps://angular-multi-lingual.hmousavi.dev\n\n<div class=\"content-ad\"></div>\n\n## GitHub 저장소를 확인해보세요:\n\n[GitHub 저장소](https://github.com/hossein13m/angular-multi-lingual)\n\n# 친구들과 공유하세요! 👏 최대 50번 클랩을 해주세요.\n\n의견이나 아이디어를 공유할 때 주저하지 마세요. 트위터에서 저에게 연락하거나 제 포트폴리오를 방문해서 다른 방법을 찾을 수 있어요.","ogImage":{"url":"/assets/img/2024-06-22-ACompleteGuideToAngularMultilingualApplicationi18n_0.png"},"coverImage":"/assets/img/2024-06-22-ACompleteGuideToAngularMultilingualApplicationi18n_0.png","tag":["Tech"],"readingTime":9},{"title":"React Virtualized로 Masonry 레이아웃 구현하는 방법","description":"","date":"2024-06-22 14:51","slug":"2024-06-22-ReactVirtualizedMasonry","content":"\n\n\n![React Virtualized Masonry](/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png)\n\n웹 개발 분야에서 특히 대규모 데이터셋과 복잡한 레이아웃을 다룰 때는 성능을 유지하면서 부드러운 사용자 경험을 제공하는 것이 중요합니다. 이 균형을 달성하는 강력한 방법 중 하나는 React Virtualized와 Masonry를 함께 사용하는 것입니다. 이 다이내믹한 콤보는 다양한 높이의 항목 그리드를 렌더링하고 관리하는 효율적인 솔루션을 제공하여 가시적인 항목만 렌더링함으로써 최적의 성능을 보장합니다.\n\n# Masonry 사용 이유\n\nMasonry 컴포넌트 소개\n\n\n<div class=\"content-ad\"></div>\n\nMasonry 구성 요소는 윈도잉 기술을 사용하여 동적으로 크기가 조정되고 사용자가 위치를 지정한 셀을 효율적으로 표시합니다. 셀의 위치는 삽입된 cellPositioner 속성으로 제어됩니다. 윈도잉은 수직 방향이며, 이 구성 요소는 수평 스크롤을 지원하지 않습니다.\n\n향상된 사용자 경험\n\n인터페이스를 직관적으로 만들어 Masonry는 사용자들의 학습 곡선을 줄입니다. 사용자들이 자연스럽게 요소와 상호 작용할 수 있게 하여 참여도와 만족도를 높입니다.\n\n생산성 향상\n\n<div class=\"content-ad\"></div>\n\n사용자들은 요소를 빠르게 재배열할 수 있어서 더 효율적인 작업 흐름을 이끌어냅니다. 특히 프로젝트 관리 도구나 디자인 소프트웨어와 같이 구성 요소를 자주 재조직해야 하는 애플리케이션에서 특히 유용합니다.\n\n유연성\n\n매소네리는 파일 관리 시스템부터 복잡한 웹 애플리케이션까지 다양한 용례에 적응할 수 있습니다. 다양한 플랫폼에서 일관된 상호작용 모델을 제공합니다.\n\n미적 매력\n\n<div class=\"content-ad\"></div>\n\n현대적이고 세련된 외관으로, Masonry는 응용 프로그램을 시각적으로 매력적으로 만듭니다. 부드러운 전환과 애니메이션은 정교한 사용자 인터페이스를 형성하며 전반적인 사용자 경험을 향상시킵니다.\n\n# Masonry의 주요 기능\n\n측정 및 레이아웃\n\n- 측정: 처음에 Masonry는 셀MeasurerCache 속성에서 제공된 추정된 셀 크기를 사용하여 배치에서 얼마나 많은 셀을 측정할지 결정합니다.\n- 레이아웃 알고리즘: 빠르고 단순한 레이아웃 알고리즘은 이미지를 순서대로 쌓아 뷰포트가 채워질 때까지 진행됩니다.\n- 캐싱: 모든 측정값은 성능을 위해 캐시되며, keyMapper에서 제공된 키를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n위치 지정 및 캐싱\n\n- 위치 지정: 외부 cellPositioner는 캐싸이즈 측정을 사용하여 셀을 위치시킵니다.\n- 캐싱: 위치 지정기가 반환하는 위치는 Masonry에 의해 빠르게 액세스할 수 있도록 캐시됩니다.\n- 재계산: 사용자가 현재 레이아웃 경계를 벗어나거나 레이아웃이 무효화된 경우, 캐시된 위치를 지우고 recomputeCellPositions() 또는 clearCellPositions()를 사용하여 다시 계산할 수 있습니다.\n\n애니메이션 및 레이아웃 제약 조건\n\n- 간단한 애니메이션: 기본 애니메이션으로 사용자 경험을 향상시킵니다.\n- 복잡한 애니메이션: 더 복잡한 애니메이션은 지원되지 않으며, 성능과 간단함에 중점을 두고 있습니다.\n- 다중 열 레이아웃: 각 항목이 고유한 게으르게 측정된 높이를 가질 수 있도록 지원하는 다중 열을 지원합니다.\n- 폭 동일: 열의 모든 항목은 동일한 너비를 가져야 합니다. 항목은 여러 열에 걸칠 수 없습니다.\n- 동기식 측정: 빈번한 레이아웃 무효화를 피하기 위해 셀 측정은 동기적이어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 공용 메소드\n\n- clearCellPositions: 내부 위치 캐시를 지우고 강제 업데이트를 수행하여 레이아웃을 무효화하는 데 유용합니다.\n- recomputeCellPositions: 내부 위치 캐시를 재설정하고 위치를 다시 계산하여 업데이트를 강제하여 레이아웃이 정확하도록합니다.\n- cellRenderer: 셀의 인덱스를 제공하여 단일 셀을 렌더링하는 데 책임이 있으며 셀이 표시되는 방식에 유연성을 제공합니다.\n- createMasonryCellPositioner: 간단한 레이아웃을 위한 내장 위치지정자를 제공하여 설정 프로세스를 간소화합니다.\n\n![이미지](/assets/img/2024-06-22-ReactVirtualizedMasonry_1.png)\n\n# 속성 유형\n\n<div class=\"content-ad\"></div>\n\nReact Virtualized Masonry에서 Prop Types는 컴포넌트에서 사용되는 다양한 속성(prop)의 예상 데이터 유형을 정의하고 강제하는 방법입니다. 이들은 올바른 데이터가 컴포넌트로 전달되도록 보장하여 잠재적인 오류를 줄이고 코드 신뢰성을 향상시키는 데 도움이 됩니다.\n\nProp types에 대한 자세한 정보는 👉 여기에서 찾을 수 있습니다.\n\n# React Virtualized Masonry 구현\n\n다음은 React Virtualized를 사용하여 Masonry 레이아웃을 만드는 방법을 실제 예제로 보여줍니다. 이 예제는 항목 목록을 만들고 CellMeasurerCache를 사용하여 항목의 크기를 캐시합니다. cellPositioner는 셀을 세 개의 열이 있는 그리드에 배치하는 데 도움을 줍니다. 각 셀은 항목의 이미지와 캡션을 포함하는 CellMeasurer 컴포넌트를 반환하는 cellRenderer 함수를 사용하여 렌더링됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst cellPositioner = createMasonry(cellPositionerConfig);\n\nconst MasonryComponent = ({ itemsWithSizes, setRef }) => {\n  const cellRenderer = ({ index, key, parent, style }) => {\n    const { item, size } = itemsWithSizes[index];\n    const height = columnWidth * (size.height / size.width) || defaultHeight;\n\n    return (\n      <CellMeasurer cache={cache} index={index} key={key} parent={parent}>\n        <div style={style}>\n          <div>{item.title}</div>\n          {item.image && (\n            <img\n              src={item.image}\n              alt={item.title}\n              style={{\n                height: height,\n                width: columnWidth,\n                display: \"block\",\n              }}\n            />\n          )}\n        </div>\n      </CellMeasurer>\n    );\n  };\n\n  return (\n    <Masonry\n      cellCount={itemsWithSizes.length}\n      cellMeasurerCache={cache}\n      cellPositioner={cellPositioner}\n      cellRenderer={cellRenderer}\n      height={600}\n      width={800}\n      keyMapper={keyMapper}\n      ref={setRef}\n    />\n  );\n};\n```\n\n전체 코드 예제는 👉 codesandbox에서 확인할 수 있습니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*Tb6VpBuPf_6Oav1kin8-Og.gif\" />\n\n# 마무리\n\n\n<div class=\"content-ad\"></div>\n\nReact Virtualized과 Masonry를 결합하면 그리드 내에서 동적 크기의 사용자 위치 지정 셀을 처리하는 효율적인 방법을 제공합니다. 예제 코드는 측정 및 레이아웃 단계가 최적의 성능을 위해 중요함을 강조하며 통합을 보여줍니다. 이 조합은 대규모 데이터셋을 다루는 복잡한 레이아웃을 React 애플리케이션에서 효과적으로 관리하는 견고한 해결책이며 반응성과 부드러운 사용자 경험을 보장합니다.\n\n텔레그램 / 인스타그램 / 페이스북 / 스레드 / 깃허브","ogImage":{"url":"/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png"},"coverImage":"/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트로 모바일 vs 데스크탑 브라우저 감지하는 방법","description":"","date":"2024-06-22 14:50","slug":"2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript","content":"\n\n<img src=\"/assets/img/2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript_0.png\" />\n\n사용자가 어떤 기기에서 브라우징하는지 탐지하는 것은 모바일 또는 데스크톱 장치에 콘텐츠를 최적화하거나 장치별 기능과 호환성을 보장하며 전체 사용자 경험을 향상시키는 다양한 이유로 매우 중요합니다. 이 기사에서는 JavaScript를 사용하여 모바일과 데스크톱 브라우저를 감지하는 다양한 기술에 대해 논의하고 장단점을 살펴보겠습니다.\n\n# 사용자 에이전트 문자열 감지\n\n사용자 에이전트 문자열은 브라우저가 서버로 보내는 정보 조각으로, 브라우저, 버전 및 운영 체제에 대한 세부 정보를 제공합니다. JavaScript에서 navigator.userAgent 속성을 사용하여 사용자 에이전트 문자열에 액세스할 수 있습니다. 사용자 에이전트 문자열을 구문 분석하여 사용자가 모바일 장치인지 데스크톱 장치인지 결정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n모바일 기기를 감지하는 일반적인 방법 중 하나는 사용자 에이전트 문자열에서 특정 키워드를 찾기 위해 정규 표현식(regex)을 사용하는 것입니다. 간단한 예제를 살펴봅시다:\n\n```js\nfunction isMobile() {\n  const regex = /Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;\n  return regex.test(navigator.userAgent);\n}\n\nif (isMobile()) {\n  console.log(\"모바일 기기를 감지했습니다\");\n} else {\n  console.log(\"데스크톱 기기를 감지했습니다\");\n}\n```\n\n사용자 에이전트 문자열 감지는 비교적 간단하게 구현할 수 있지만, 여러 제한 사항이 있습니다:\n\n- 사용자 에이전트 문자열에 특정 키워드가 의존되므로 시간이 지남에 따라 변경되거나 특정 기기에 누락될 수 있습니다.\n- 일부 브라우저에서 사용자가 사용자 에이전트 문자열을 변경할 수 있어 정확한 감지를 방해할 수 있습니다.\n- 사용자 에이전트 문자열 감지는 새로운 기기와 브라우저가 정기적으로 출시되므로 미래지향적이지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 기능 감지\n\n사용자 에이전트 문자열 감지의 대안은 모바일 또는 데스크톱 장치에 고유한 장치 기능을 확인하는 것입니다. 터치 기능이 그 중 하나입니다. JavaScript를 사용하여 다음 코드로 터치 지원을 감지할 수 있습니다.\n\n```js\nfunction hasTouchSupport() {\n  return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n}\n\nif (hasTouchSupport()) {\n  console.log(\"모바일 장치 감지됨\");\n} else {\n  console.log(\"데스크톱 장치 감지됨\");\n}\n```\n\n이 방법은 사용자 에이전트 문자열 감지보다 더 신뢰할 수 있지만 완벽하지는 않습니다. 일부 데스크톱 장치인 터치스크린 노트북과 같은 장치가 오류로 모바일 장치로 잘못 식별될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다른 기능 기반 접근 방법은 기기의 화면 크기와 해상도를 감지하는 것입니다. 모바일 기기는 일반적으로 데스크톱 기기와 비교해 화면이 작고 해상도가 낮습니다. 윈도우 크기와 해상도를 확인할 수 있습니다. 이를 위해서 window.innerWidth, window.innerHeight, window.devicePixelRatio 및 screen.width 속성을 사용할 수 있습니다. 여기에 예시가 있습니다:\n\n```js\nfunction isMobile() {\n  const minWidth = 768; // 데스크톱 기기의 최소 너비\n  return window.innerWidth < minWidth || screen.width < minWidth;\n}\n\nif (isMobile()) {\n  console.log(\"모바일 기기 감지\");\n} else {\n  console.log(\"데스크톱 기기 감지\");\n}\n```\n\n이 방법에도 일부 제한이 있습니다. 예를 들어, 데스크톱 기기에서 브라우저 창의 크기를 조정하는 경우 false positive(잘못된 양성)로 이어질 수 있습니다. 게다가, 모바일 기기의 화면 크기와 해상도가 계속 증가함에 따라 이 방법은 더 이상 정확하지 않을 수 있습니다.\n\n# 검출을 위한 라이브러리 사용\n\n<div class=\"content-ad\"></div>\n\n모바일 감지(Mobile Detect)는 사용자 에이전트 문자열을 구문 분석하여 모바일 장치를 식별하기 위한 깨끗한 API를 제공하여 장치 감지를 간단하게 하는 인기 있는 JavaScript 라이브러리입니다. 다음과 같이 사용할 수 있습니다:\n\n```js\nimport MobileDetect from 'mobile-detect';\n\nconst md = new MobileDetect(navigator.userAgent);\nif (md.mobile()) {\n  console.log(\"모바일 장치 감지됨\");\n} else {\n  console.log(\"데스크톱 장치 감지됨\");\n}\n```\n\nBowser는 사용자 에이전트 문자열을 구문 분석하고 장치 감지를 제공하는 다른 라이브러리입니다. 브라우저, 운영 체제 및 장치 유형에 대한 추가 정보도 제공합니다. 다음은 예시입니다:\n\n```js\nimport Bowser from 'bowser';\n\nconst parser = Bowser.getParser(navigator.userAgent);\nif (parser.getPlatformType() === 'mobile') {\n  console.log(\"모바일 장치 감지됨\");\n} else {\n  console.log(\"데스크톱 장치 감지됨\");\n}\n```\n\n<div class=\"content-ad\"></div>\n\nPlatform.js는 사용자 에이전트 문자열을 파싱하여 브라우저, 운영 체제 및 기기 유형에 대한 정보를 제공하는 가벼운 라이브러리입니다. 다음과 같이 사용할 수 있습니다:\n\n```js\nimport platform from 'platform';\n\nif (platform.isMobile) {\n  console.log(\"모바일 기기가 감지되었습니다\");\n} else {\n  console.log(\"데스크톱 기기가 감지되었습니다\");\n}\n```\n\n# 최선의 실천 방법\n\n- 가능한 경우 사용자 에이전트 문자열 감지보다 기능 감지를 선호하세요. 이는 더 신뢰할 수 있고 미래에 대비할 수 있습니다.\n- 감지를 간단히하고 정확도를 향상시키기 위해 라이브러리를 사용하세요.\n- 보다 견고한 감지를 위해 여러 기술을 결합하세요.\n- 새로운 기기 및 브라우저와의 호환성을 보장하기 위해 감지 코드를 지속적으로 테스트하고 업데이트하세요.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 글에서는 JavaScript를 사용하여 모바일과 데스크톱 브라우저를 감지하는 다양한 기술에 대해 논의했습니다. 사용자 에이전트 문자열 감지, 기능 감지 및 라이브러리 기반 감지를 포함합니다. 각 기술에는 장단점이 있으며 완벽한 방법은 없습니다. 도움이 되었기를 바랍니다.\n\n읽어 주셔서 감사합니다. 다음 글에서 만나기를 기대합니다.\n\nMedium 회원이 아니세요? 여기에서 지원해 주세요.","ogImage":{"url":"/assets/img/2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript_0.png"},"coverImage":"/assets/img/2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript_0.png","tag":["Tech"],"readingTime":4},{"title":"타입스크립트로 설명하는 결합도와 응집도 이해하기","description":"","date":"2024-06-22 14:48","slug":"2024-06-22-CouplingandCohesionexplainedwithtypescript","content":"\n\n![image](/assets/img/2024-06-22-CouplingandCohesionexplainedwithtypescript_0.png)\n\n소프트웨어 개발에서 낮은 결합을 추구하는 것은 유연하고 쉽게 유지보수할 수 있는 시스템을 만드는 데 중요하며, 이는 소프트웨어 품질의 측정 항목입니다.\n\n결합은 시스템의 서로 다른 모듈이나 구성 요소 간의 의존성을 나타내며, 적절하게 관리되지 않으면 코드를 복잡하게 만들어 수정하기 어렵게 만들 수 있습니다.\n\n따라서 다양한 종류의 결합과 그 영향을 이해하는 것은 견고하고 확장 가능한 시스템을 만들려는 개발자들에게 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 커플링이란 무엇인가요?\n\n커플링은 소프트웨어 엔지니어링에서 시스템의 다른 부분 간의 의존도를 나타내는 것을 말합니다. 구성 요소 간에 높은 커플링이 있다면 더 강한 상호의존성을 의미합니다.\n\n높은 커플링은 모듈이 긴밀하게 연결되어 있어 하나의 모듈에서의 변경이 다른 모듈들에 영향을 미칠 수 있다는 것을 의미합니다. 낮은 커플링은 모듈이 독립적이므로 하나의 모듈에서의 변경이 다른 모듈에 미치는 영향이 최소화됩니다.\n\n소프트웨어 시스템의 구조와 유지관리에 영향을 미치는 여러 유형의 커플링이 존재합니다.\n\n<div class=\"content-ad\"></div>\n\n# 주요 결합 유형:\n\n1 — 데이터 결합:\n\n다른 모듈에 특정 데이터 구조에만 의존하는 경우 발생합니다. 모듈은 독립적이며, 서로 전달되는 데이터 유형에 한정된 종속성을 갖습니다.\n\n```js\n// 예시 A\nclass User {\n  constructor(private name: string) {}\n\n  getName(): string {\n    return this.name;\n  }\n}\n\n// 예시 B\nclass UserManager {\n  constructor(private user: User) {}\n\n  showUserName(): void {\n    console.log(this.user.getName());\n  }\n}\n\n// 모듈 A와 B 사용\nconst user = new User(\"Ana\");\nconst userManager = new UserManager(user);\nuserManager.showUserName();\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 UserManager은 User에 직접적으로 의존하므로 User 클래스 구조나 동작에 대한 변경사항이 UserManager에 직접적인 영향을 미칠 수 있습니다.\n\n2 - 스탬프 결합:\n\n복잡한 데이터 구조에서 모듈이 많은 필드를 공유하지만 각 모듈은 이 필드의 일부분만 사용하는 데이터 결합 형태를 가리킵니다.\n\n```js\n// 예제 A\nclass Order {\n  constructor(private id: number, private description: string, private amount: number) {}\n\n  getId(): number {\n    return this.id;\n  }\n}\n\n// 예제 B\nclass OrderManager {\n  constructor(private order: Order) {}\n\n  showOrderId(): void {\n    console.log(this.order.getId());\n  }\n}\n\n// 모듈 A와 B 사용법\nconst order = new Order(1, \"Product A\", 100);\nconst orderManager = new OrderManager(order);\norderManager.showOrderId();\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 OrderManager는 복잡한 데이터 구조를 가진 Order 객체에 종속되지만 특정 하위 집합 필드만 사용합니다(이 경우 id). 이는 스탬프 결합을 보여줍니다.\n\n3 — 제어 결합:\n\n프로그램 실행 흐름에 영향을 미치는 플래그 값 또는 표시기와 같은 공유 제어 정보로 인해 모듈간의 의존성이 발생합니다.\n\n```js\n// 예시 A\nclass PaymentProcessor {\n  processPayment(status: boolean): void {\n    if (status) {\n      console.log(\"결제가 성공적으로 처리되었습니다.\");\n    } else {\n      console.log(\"결제 처리에 실패했습니다.\");\n    }\n  }\n}\n\n// 예시 B\nclass ShoppingCart {\n  constructor(private processor: PaymentProcessor) {}\n\n  completePurchase(status: boolean): void {\n    this.processor.processPayment(status);\n  }\n}\n\n// 모듈 A와 B 사용법\nconst processor = new PaymentProcessor();\nconst cart = new ShoppingCart(processor);\ncart.completePurchase(true);\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 ShoppingCart은 PaymentProcessor에 의존하여 결제 상태에 따라 구매가 성공적으로 완료되었는지를 결정합니다. 이것은 제어 결합을 보여줍니다.\n\n4 - 공통 결합:\n\n두 개 이상의 모듈이 자신의 기능을 수행하기 위해 공통의 세 번째 모듈에 의존하는 경우 발생합니다. 이렇게 되면 모듈 간에 강한 상호의존성이 생기며, 시스템을 모듈화하고 유지하기가 더 어려워집니다.\n\n```js\n// 예제 A\nclass Logger {\n  logMessage(message: string): void {\n    console.log(`[LOG] ${message}`);\n  }\n}\n\n// 예제 B\nclass AuthenticationService {\n  constructor(private logger: Logger) {}\n\n  authenticateUser(): void {\n    // 인증 로직\n    this.logger.logMessage(\"사용자가 성공적으로 인증되었습니다.\");\n  }\n}\n\n// Module A와 B 사용법\nconst logger = new Logger();\nconst authService = new AuthenticationService(logger);\nauthService.authenticateUser();\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 AuthenticationService는 인증 프로세스 중 로그 메시지를 기록하기 위해 Logger에 의존합니다. 두 모듈 모두 Logger에 의존하므로 공통적으로 결합되어 있음을 나타냅니다.\n\n5 — 콘텐츠 결합:\n\n모듈이 다른 모듈의 내부 구현에 직접적으로 의존하며 내부 변수에 액세스하고 조작하는 가장 강력한 결합 형태입니다.\n\n```js\n// 예제 A\nclass Calculator {\n  private result: number = 0;\n\n  add(a: number, b: number): void {\n    this.result = a + b;\n  }\n\n  getResult(): number {\n    return this.result;\n  }\n}\n\n// 예제 B\nclass CalculatorLogger {\n  private calculator: Calculator;\n\n  constructor(calculator: Calculator) {\n    this.calculator = calculator;\n  }\n\n  logResult(): void {\n    console.log(`Operation result: ${this.calculator.getResult()}`);\n  }\n}\n\n// 모듈 A와 B 사용법\nconst calculator = new Calculator();\ncalculator.add(2, 3);\nconst logger = new CalculatorLogger(calculator);\nlogger.logResult();\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 CalculatorLogger는 Calculator의 내부 구현에 직접 의존하며 결과 변수에 액세스하고 조작합니다. 이는 content coupling을 나타내며 가장 강한 유형으로 간주됩니다.\n\n# 낮은 결합도의 장점:\n\n- 더 쉬운 유지 보수: 낮은 결합도는 하나의 모듈 내 변경이 다른 모듈에 미치는 영향을 줄이며, 개별 구성 요소의 수정 또는 교체을 용이하게 합니다.\n- 향상된 모듈화: 낮은 결합도는 모듈이 독립적으로 개발되고 테스트될 수 있도록 해 코드의 모듈화와 재사용성을 향상시킵니다.\n- 더 나은 확장성: 낮은 결합도는 새로운 모듈 추가와 기존 모듈 제거를 용이하게 하여 필요에 따라 시스템의 확장성을 증진시킵니다.\n\n# 높은 결합도의 단점:\n\n<div class=\"content-ad\"></div>\n\n- 증가된 복잡성: 높은 결합은 모듈간의 상호 의존성을 증가시켜 시스템이 더 복잡하고 이해하기 어렵게 만듭니다.\n- 유연성 감소: 높은 결합은 개별 구성 요소를 수정하거나 교체하기가 전체 시스템에 영향을 미치게 만들어 어렵게 합니다.\n- 모듈성 저하: 높은 결합은 독립적으로 모듈을 개발하고 테스트하는 것을 복잡하게 만들어 코드 모듈성과 재사용성을 줄입니다.\n\n# 응집도\n\n소프트웨어 개발에서 응집력이란 시스템 내의 다른 구성 요소에 어떻게 책임이 할당되는지와 관련된 개념입니다.\n\n높은 응집력은 시스템의 구성 요소가 서로 관련이 깊고 명확한 목적을 수행하는 것을 의미하며, 낮은 응집력은 구성 요소가 구별되고 느슨하게 관련된 책임을 가지고 있는 것을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n커플링과 유사하게, 응집도는 소프트웨어의 품질과 유지 보수성에 중요한 역할을 합니다. 시스템의 모듈화 및 확장 가능성에 직접적인 영향을 미칩니다.\n\n# 응집도의 주요 유형:\n\n1 — 기능 응집도:\n\n기능 응집도는 모듈 내 요소가 관련되어 단일 특정 기능이나 작업을 수행할 때 발생합니다. 이는 모듈 내 각 구성 요소가 해당 주요 기능과 직접적으로 관련되어 동일한 목표를 달성하는 데 기여한다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 기능 응집의 예\nclass Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n  }\n\n  subtract(a: number, b: number): number {\n    return a - b;\n  }\n\n  multiply(a: number, b: number): number {\n    return a * b;\n  }\n\n  divide(a: number, b: number): number {\n    return a / b;\n  }\n}\n```\n\n이 예제에서 Calculator 클래스는 서로 다른 수학 연산을 수행하는 메서드를 가지고 있어서, 각 메서드가 계산기의 주요 기능에 기여함으로써 기능 응집성을 유지합니다.\n\n2 - 순차 응집:\n\n순차 응집은 모듈 내의 작업이 특정 순서로 구성되어 있고, 한 작업의 출력이 다음 작업의 입력으로 작동할 때 발생합니다. 즉, 모듈 요소들이 순차적으로 관련되어 있고 서로 의존하여 일련의 단계를 순서대로 실행하기 위해 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 순차 응집의 예\nclass OrderProcessor {\n  processOrder(order: Order): void {\n    this.validateOrder(order);\n    this.updateInventory(order);\n    this.sendConfirmation(order);\n  }\n\n  validateOrder(order: Order): void {\n    // 주문 유효성 검사 로직\n  }\n\n  updateInventory(order: Order): void {\n    // 재고 업데이트 로직\n  }\n\n  sendConfirmation(order: Order): void {\n    // 확인 메일 보내기 로직\n  }\n}\n```\n\n이 예제에서 OrderProcessor 클래스는 주문 처리를 위한 순차적 단계를 실행하는 메서드를 갖고 있습니다. 각 메서드는 이전 메서드의 결과에 종속되어 높은 순차 응집을 유지합니다.\n\n3 — 시간적 응집:\n\n시간적 응집은 모듈 내의 작업이 시간적으로 관련이 있고 시간적 종속성으로 인해 함께 실행되어야 하는 경우 발생합니다. 이는 모듈 요소가 특정 기능이 아닌 실행해야 할 시간에 따라 그룹화되는 것을 의미합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 시간적 응집력의 예제\nclass TaskScheduler {\n  scheduleTask(task: Task, time: string): void {\n    // 작업 예약 논리\n  }\n\n  cancelTask(task: Task): void {\n    // 작업 취소 논리\n  }\n\n  executeTask(task: Task): void {\n    // 작업 실행 논리\n  }\n}\n```\n\n이 예제에서 TaskScheduler 클래스는 작업을 예약, 취소, 실행하는 메서드를 가지고 있으며, 각 메서드가 시간적으로 관련되어 특정 시점에 실행되어야 하므로 높은 시간적 응집력을 유지합니다.\n\n4 — 논리적 응집력:\n\n논리적 응집력은 모듈 내의 요소가 특정 로직에 의해 관련되거나 동일한 데이터 집합을 처리할 때 발생합니다. 이는 모듈 요소가 공유된 논리나 동일한 데이터 조작을 기준으로 그룹화되어 있는 것을 의미합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\n// 논리 응집의 예\r\nclass FormValidator {\r\n  validateRequiredField(value: string): boolean {\r\n    // 필수 필드 유효성 검사 로직\r\n    return value.trim() !== '';\r\n  }\r\n\r\n  validateEmailField(value: string): boolean {\r\n    // 이메일 필드 유효성 검사 로직\r\n    return /\\S+@\\S+\\.\\S+/.test(value);\r\n  }\r\n\r\n  validateForm(form: Form): boolean {\r\n    // 폼 유효성 검사 로직\r\n    return this.validateRequiredField(form.name) && this.validateEmailField(form.email);\r\n  }\r\n}\r\n```\r\n\r\n이 예제에서 FormValidator 클래스는 각 메서드가 특정 유효성 검사 로직에 의해 관련되어 있어 높은 논리 응집을 유지하고 있습니다.\r\n\r\n5 — 우연한 응집:\r\n\r\n우연한 응집은 모듈 내 요소들이 중요한 관련성 없이 임의로 그룹화된 경우입니다. 이는 모듈 요소들이 편리함이나 우연한 이유로 함께 그룹화된 것을 의미하며, 공통 목적이나 논리를 위해 그룹화된 것이 아닙니다.\r\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// Coincidental Cohesion의 예제\nclass Utility {\n  generateReport(data: any): void {\n    // 보고서 생성 로직\n  }\n\n  sendEmail(recipient: string, message: string): void {\n    // 이메일 발송 로직\n  }\n\n  calculateTaxes(data: any): void {\n    // 세금 계산 로직\n  }\n}\n```\n\n이 예제에서 Utility 클래스는 중요한 관계 없이 다양한 작업을 수행하는 메서드를 가지고 있어서 우연한 응집력이 낮습니다.\n\n다양한 응집력 유형을 이해하는 것은 모듈식, 유연하며 유지보수 가능한 소프트웨어 시스템을 설계하는 데 중요합니다. 각 구성 요소에 적합한 응집력 유형을 선택함으로써, SOLID 및 다른 소프트웨어 설계 원칙을 따르며 더 견고하고 확장 가능한 시스템을 만들 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n\n<div class=\"content-ad\"></div>\n\n제 주변을 따라오세요!😜\n\n- 포트폴리오: gustavobruno.dev\n- GitHub: @gustavobrunodev\n- LinkedIn: @gustavobrunodev","ogImage":{"url":"/assets/img/2024-06-22-CouplingandCohesionexplainedwithtypescript_0.png"},"coverImage":"/assets/img/2024-06-22-CouplingandCohesionexplainedwithtypescript_0.png","tag":["Tech"],"readingTime":9},{"title":"TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법","description":"","date":"2024-06-22 14:46","slug":"2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators","content":"\n\n`<img src=\"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png\" />`\n\n데코레이터는 클래스 선언, 메소드, 접근자, 속성 또는 매개변수에 첨부할 수 있는 특별한 선언 유형입니다. 데코레이터는 @expression 형식으로 사용되며, expression은 데코레이트된 선언에 대한 정보를 런타임에 호출할 함수로 평가되어야 합니다.\n\nTypescript 5.0부터 Stage 3 데코레이터 지원이 가능합니다.\n\n## 데코레이터 사용 방법:\n\n<div class=\"content-ad\"></div>\n\n데코레이터에 대한 실험적인 지원을 활성화하려면 명령줄에서 tsc --target ES5 --experimentalDecorators를 사용하거나 tsconfig.json에서 experimentalDecorators 컴파일러 옵션을 활성화해야 합니다:\n\n```js\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n사용자 클래스에 greet 메서드가 있는 경우를 고려해보세요.\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n\n  printAge() {\n    console.log(`I am ${this.age} years old`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n출력:\nHello, my name is Ron.\nI am 25 years old\n```\n\n<div class=\"content-ad\"></div>\n\n이제 각 함수 실행이 시작하고 끝나는 시점을 기록하고 싶어요:\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  greet() {\n    console.log('start: greet')\n    console.log(`Hello, my name is ${this.name}.`);\n    console.log('end: greet')\n  }\n\n  printAge() {\n    console.log('start: printAge')\n    console.log(`I am ${this.age} years old`);\n    console.log('end: printAge')\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n\n\nOutput: \nstart: greet\nHello, my name is Ron.\nend: greet\nstart: printAge\nI am 25 years old\nend: printAge\n```\n\n데코레이터를 만드는 것은 정말 쉬워요: logger라는 함수를 만들기만 하면 돼요:\n\n```js\nfunction logger(originalMethod: any, _context: any) {\n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(\"start:\", originalMethod.name);\n    const result = originalMethod.call(this, ...args);\n    console.log(\"end:\", originalMethod.name);\n    return result;\n  }\n\n  return replacementMethod;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 메소드를 꾸밈을 준비했어요. 위의 예시에서 데코레이터를 사용해봅시다:\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  @logger\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n\n  @logger\n  printAge() {\n    console.log(`I am ${this.age} years old`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n\n\nOutput: \nstart: greet\nHello, my name is Ron.\nend: greet\nstart: printAge\nI am 25 years old\nend: printAge\n```\n\n쉽죠? TypeScript는 여러 데코레이터를 지원합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n  @logger\n  @xyz\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n```\n\n여러 개의 데코레이터가 적용될 때 실행 순서를 살펴봅시다.\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  @logger2\n  @logger1\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\n\n\nfunction logger1(originalMethod: any, _context: any) {\n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(\"log1\");\n    const result = originalMethod.call(this, ...args);\n    return result;\n  }\n\n  return replacementMethod;\n}\n\nfunction logger2(originalMethod: any, _context: any) {\n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(\"log2\");\n    const result = originalMethod.call(this, ...args);\n    return result;\n  }\n\n  return replacementMethod;\n}\n\n\n\n\n\nOutput: \nlog2\nlog1\nHello, my name is Ron.\n```\n\n하나의 선언에 여러 데코레이터가 적용되면, 그 평가는 수학의 함수 합성과 유사합니다. 이 모델에서 함수 f와 g를 합성할 때, 결과 컴포지트(f ∘ g)(x)는 f(g(x))와 동등합니다.\n\n<div class=\"content-ad\"></div>\n\n올바른 형식의 데코레이터 예제:\n\n```js\nfunction loggedMethod<This, Args extends any[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>\n) {\n    const methodName = String(context.name);\n\n    function replacementMethod(this: This, ...args: Args): Return {\n        console.log(`LOG: Entering method '${methodName}'.`)\n        const result = target.call(this, ...args);\n        console.log(`LOG: Exiting method '${methodName}'.`)\n        return result;\n    }\n\n    return replacementMethod;\n}\n```\n\n## 데코레이터 유형:\n\n## 1. 클래스 데코레이터\n\n<div class=\"content-ad\"></div>\n\n클래스 데코레이터는 클래스 선언 바로 전에 선언됩니다. 클래스 데코레이터는 클래스의 생성자에 적용되며, 클래스 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다. 클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: 선언 클래스에 대해)에서 사용할 수 없습니다.\n\n클래스 데코레이터의 표현식은 실행 시에 생성된 클래스의 생성자를 유일한 인수로하여 함수로 호출됩니다.\n\n클래스 데코레이터가 값을 반환하면 제공된 생성자 함수로 클래스 선언이 대체됩니다. \"새로운 생성자 함수를 반환하려면 원본 프로토 타입을 유지해야 합니다. 런타임에서 데코레이터를 적용하는 로직이 자동으로 처리해주지 않습니다.\"\n\n여기에는 클래스 데코레이터를 사용하여 created 속성을 설정하려는 예제가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass User {\n  [x: string]: any;\n  constructor(public name: string) {}\n}\n\nconst user = new User('John')\nconsole.log(user.name, user.created)\n\n// 출력:\nJohn undefined\n```\n\n클래스 데코레이터를 사용한 예시\n\n```js\n@BaseEntity\nclass User {\n  [x: string]: any;\n  constructor(public name: string) {}\n}\n\nfunction BaseEntity(ctr: Function) {\n  ctr.prototype.created = new Date().toISOString();\n}\n\nconst user = new User('John')\nconsole.log(user.name, user.created)\n```\n\n## 2. 메소드 데코레이터\n\n<div class=\"content-ad\"></div>\n\n메소드 데코레이터는 메소드 선언 바로 전에 선언됩니다. 데코레이터는 해당 메소드의 속성 설명자에 적용되며, 메소드 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 메소드 데코레이터는 선언 파일에서, 오버로드에서, 또는 기타 환경에서 (예: 선언 클래스 내) 사용할 수 없습니다. 이미 메소드 데코레이터 예제를 보았으므로 추가적인 자세한 내용은 다루지 않겠습니다:\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  @logger\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n\n  @logger\n  printAge() {\n    console.log(`I am ${this.age} years old`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n여러분의 프로젝트 블랙핑크에 오신 것을 환영합니다!\n\n출력:\nstart: greet\nHello, my name is Ron.\nend: greet\nstart: printAge\nI am 25 years old\nend: printAge\n```\n\n## 3. 접근자 데코레이터\n\n접근자 데코레이터는 접근자 선언 바로 전에 선언됩니다. 접근자 데코레이터는 해당 접근자의 속성 설명자에 적용되며, 접근자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 접근자 데코레이터는 선언 파일이나 기타 환경 (예: 선언 클래스 내)에서 사용할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n액세서 데코레이터의 표현은 런타임에서 다음 세 가지 인수와 함께 함수로 호출될 것입니다:\n\n- 정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.\n- 멤버의 이름.\n- 멤버의 속성 설명자(Property Descriptor).\n\n액세서 데코레이터가 값을 반환하면 해당 값은 멤버의 속성 설명자로 사용됩니다.\n\n다음은 Point 클래스의 멤버에 적용된 액세서 데코레이터 예시(@configurable)입니다:\n\n<div class=\"content-ad\"></div>\n\n```typescript\nclass Point {\n  private _x: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n}\n\nfunction configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n```\n\n## 4. Property Decorators\n\n프로퍼티 데코레이터는 프로퍼티 선언 바로 전에 선언됩니다. 프로퍼티 데코레이터는 선언 파일이나 다른 환경(context)에서 사용할 수 없습니다(예: declare class 내에서).\n\n프로퍼티 데코레이터의 표현식은 런타임 시 함수로 호출되며 아래 두 인수를 전달받습니다:\n\n<div class=\"content-ad\"></div>\n\n- 정적 멤버의 클래스 생성자 함수이거나 인스턴스 멤버의 클래스 프로토타입입니다.\n- 멤버의 이름입니다.\n\nTypeScript에서 속성 데코레이터의 예시를 제공합니다. 이 데코레이터는 속성의 값이 유효한 이메일 주소인지를 확인합니다:\n\n```js\n// 이메일 유효성 검사를 위한 속성 데코레이터\nfunction ValidateEmail(target: any, propertyKey: string) {\n  const privateFieldName = `_${propertyKey}`;\n\n  // 원래의 setter 메서드를 저장합니다.\n  const originalSetter = Object.getOwnPropertyDescriptor(target, propertyKey)?.set;\n\n  // 속성을 위한 새로운 setter를 정의합니다.\n  const newSetter = function (value: any) {\n    if (!isValidEmail(value)) {\n      throw new Error(`\"${propertyKey}\" 속성에 대한 유효하지 않은 이메일 주소입니다.`);\n    }\n    this[privateFieldName] = value;\n  };\n\n  // 속성의 setter 메서드를 대체합니다.\n  Object.defineProperty(target, propertyKey, {\n    set: newSetter,\n    get() {\n      return this[privateFieldName];\n    },\n    enumerable: true,\n    configurable: true,\n  });\n}\n\n// 이메일 주소 유효성을 검사하는 도우미 함수\nfunction isValidEmail(email: string): boolean {\n  // 간단한 이메일 유효성을 위한 정규 표현식\n  const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return emailPattern.test(email);\n}\n\nclass User {\n  @ValidateEmail\n  email: string = 'test@example.com';\n\n  constructor(email: string) {\n    this.email = email;\n  }\n}\n\nconst user = new User('john@example.com');\n\nconsole.log(user.email); // john@example.com\n\ntry {\n  user.email = 'invalid-email'; // 오류가 발생합니다.\n} catch (error) {\n  console.error(error.message); // \"email\" 속성에 대한 유효하지 않은 이메일 주소입니다.\n}\n\n// 출력:\njohn@example.com\n\"email\" 속성에 대한 유효하지 않은 이메일 주소입니다.\n```\n\n- 우리는 속성 데코레이터 ValidateEmail을 정의하여 할당된 값이 유효한 이메일 주소인지 확인합니다.\n- newSetter 함수는 제공된 값이 유효한 이메일 주소인지 확인합니다. 그렇지 않으면 오류를 발생합니다.\n- User 클래스의 email 속성에 @ValidateEmail 데코레이터를 적용합니다.\n- User의 인스턴스를 만들 때 email 속성을 유효한 이메일 주소로 설정하면 예상대로 작동합니다.\n- email 속성을 유효하지 않은 이메일 주소(예: `invalid-email`)로 설정하려고 하면 데코레이터가 유효하지 않은 이메일 주소임을 나타내는 오류를 throw합니다.\n\n<div class=\"content-ad\"></div>\n\n## 5. 매개변수 데코레이터\n\n매개변수 데코레이터는 매개변수 선언 바로 전에 선언됩니다. 매개변수 데코레이터는 클래스 생성자나 메서드 선언에 적용됩니다. 매개변수 데코레이터는 선언 파일, 오버로드 또는 다른 ambient context(declare class 내에도)에서 사용할 수 없습니다.\n\n매개변수 데코레이터의 표현식은 런타임에 함수로 호출되며 다음 세 가지 인수와 함께 호출됩니다:\n\n- 정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.\n- 멤버의 이름.\n- 함수의 매개변수 목록에서 매개변수의 순서 인덱스.\n\n<div class=\"content-ad\"></div>\n\n파라미터 데코레이터의 반환 값은 무시됩니다.\n\n다음은 간단한 정규 표현식을 사용하여 메서드 파라미터가 유효한 이메일 주소인지를 확인하는 파라미터 데코레이터의 예시입니다:\n\n```js\n// 이메일 유효성 검사를 위한 파라미터 데코레이터\nfunction ValidateEmail(target: any, methodName: string, parameterIndex: number) {\n  const originalMethod = target[methodName];\n\n  target[methodName] = function (...args: any[]) {\n    const paramValue = args[parameterIndex];\n\n    // 간단한 이메일 유효성을 위한 정규 표현식\n    const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n\n    if (!emailPattern.test(paramValue)) {\n      throw new Error(`파라미터 인덱스 ${parameterIndex}의 유효하지 않은 이메일 주소가 제공되었습니다`);\n    }\n\n    return originalMethod.apply(this, args);\n  };\n}\n\nclass ExampleClass {\n  // 이메일 파라미터를 검증하기 위해 파라미터 데코레이터를 적용\n  sendEmail(@ValidateEmail email: string) {\n    console.log(`${email}로 이메일을 보냅니다`);\n  }\n}\n\nconst exampleInstance = new ExampleClass();\n\n// 작동합니다\nexampleInstance.sendEmail(\"example@email.com\");\n\n// 이메일 유효성 검사로 오류가 발생합니다\ntry {\n  exampleInstance.sendEmail(\"invalid-email\");\n} catch (error) {\n  console.error(error.message); // 파라미터 인덱스 0에 유효하지 않은 이메일 주소가 제공되었습니다\n}\n```\n\n- ValidateEmail이라는 이름의 파라미터 데코레이터를 정의하고, 정규 표현식을 사용하여 제공된 파라미터가 유효한 이메일 주소인지 확인합니다.\n- sendEmail 메서드를 가진 ExampleClass 클래스를 만들고, email 파라미터를 검증하기 위해 @ValidateEmail 데코레이터를 적용합니다.\n- sendEmail 메서드를 호출할 때, 제공된 이메일 파라미터가 이메일 유효성 정규 표현식과 일치하는지 확인합니다. 일치하지 않으면 오류를 throw합니다.\n- 유효한 이메일로 한 번, 그리고 유효하지 않은 이메일을 주면 이메일 유효성 오류가 발생하는 두 가지 sendEmail 메서드 호출을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n이 예제는 메서드 매개변수의 간단한 이메일 유효성 검사를 수행하기 위해 매개변수 데코레이터를 사용하는 방법을 보여줍니다. 특정 요구 사항에 따라 정규 표현식을 조정하거나 필요에 따라 더 복잡한 이메일 유효성 검사 로직을 추가할 수 있습니다.\n\n## TypeScript의 데코레이터는 코드의 여러 부분을 수정하거나 동작을 추가하는 강력한 메커니즘을 제공합니다. 데코레이터의 일반적인 사용 사례는 다음과 같습니다:\n\n- 로깅 및 디버깅: 메서드 호출, 함수 매개변수 또는 속성 액세스를 기록하여 디버깅에 도움을 줄 수 있습니다.\n- 유효성 검사: 데코레이터는 입력 유효성 검사에 사용될 수 있으며, 함수 매개변수나 속성 값이 특정 기준이나 제약 조건을 충족하는지 확인할 수 있습니다.\n- 메모이제이션: 데코레이터를 사용하여 함수 결과를 캐시함으로써 입력 매개변수에 따라 함수를 캐싱하여 비용이 많이 드는 계산의 성능을 향상시킬 수 있습니다.\n- 인증 및 권한 부여: 데코레이터를 사용하여 웹 애플리케이션의 특정 메서드나 라우트에 액세스할 수 있는 전에 사용자 인증 또는 권한을 확인할 수 있습니다.\n- 의존성 주입: Angular과 같은 프레임워크에서 데코레이터를 사용하여 클래스나 컴포넌트에 주입할 서비스를 지정할 수 있습니다.\n- 라우트 처리 (웹 애플리케이션): Express.js 또는 Nest.js와 같은 웹 프레임워크에서 데코레이터를 사용하여 HTTP 엔드포인트의 라우트와 요청 핸들러를 정의할 수 있습니다.\n- 데이터 변환: 처리되기 전에 데이터를 변환하기 위해 데코레이터를 사용할 수 있습니다.\n- 캐싱: 데코레이터를 사용하여 데이터 검색 메서드를 캐싱함으로써 외부 데이터 소스에 부하를 줄일 수 있습니다.\n- 시간 측정 및 프로파일링: 함수의 실행 시간을 측정할 수 있습니다.\n- 로깅 프레임워크: 사용 사례에서 데코레이터는 특정 이벤트나 작업을 로깅하기 위해 메서드에 적용될 수 있습니다.\n- 유효성 검사 프레임워크: 데이터가 특정 규칙이나 제약 조건을 준수하는지 확인하기 위해 사용자 정의 유효성 검사 데코레이터를 생성할 수 있습니다.\n- 데이터베이스 매핑: Object-Relational Mapping (ORM) 라이브러리에서 데코레이터는 클래스 프로퍼티와 데이터베이스 열을 매핑하는 데 사용됩니다.\n- 속성 액세스 제어: 데코레이터를 사용하여 클래스 속성에 액세스 제어 정책을 강제할 수 있습니다.\n- 싱글톤 패턴: 데코레이터를 사용하여 싱글톤 디자인 패턴을 구현할 수 있습니다.\n- 사용자 지정 미들웨어: 웹 프레임워크에서 데코레이터는 메인 요청 핸들러 앞이나 뒤에서 실행될 사용자 정의 미들웨어 함수를 생성하는 데 사용될 수 있습니다.\n- 국제화와 지역화: 텍스트 속성이나 메서드에 데코레이터를 적용하여 언어 번역 및 지역화를 처리할 수 있습니다.\n- 오류 처리: 예외를 일관되게 처리하기 쉽게 하기 위해 중앙 집중식 오류 처리 논리를 데코레이터로 사용할 수 있습니다.\n- 이벤트 처리: 특정 이벤트에 대한 이벤트 리스너와 핸들러를 등록하는 데 사용될 수 있습니다.\n- 유형 확인 및 변환: 데이터가 예상된 유형과 형식에 맞는지 확인하기 위해 유형 확인 및 데이터 변환을 수행할 수 있습니다.\n- 사용자 정의 어노테이션: 클래스, 메서드 또는 속성에 대한 추가 정보를 제공하기 위한 사용자 지정 어노테이션 또는 메타데이터를 만들 수 있습니다.\n\n이것들은 TypeScript에서 데코레이터의 많은 사용 사례 중 일부에 불과합니다. 데코레이터는 클래스, 메서드 및 속성의 기능을 향상시키는 유연하고 확장 가능한 방법을 제공하여 코드를 더 모듈화되고 유지보수 가능하게 만듭니다.","ogImage":{"url":"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png"},"coverImage":"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png","tag":["Tech"],"readingTime":13},{"title":"TypeScript의 매핑된 타입 알아보기 기초부터 고급까지 8가지 예제","description":"","date":"2024-06-22 14:45","slug":"2024-06-22-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced","content":"\n\n**Mapped types**는 TypeScript에서 한 타입의 속성을 다른 타입으로 변환하는 강력한 도구입니다. 이것들은 `map` 및 `filter`와 같은 배열 메서드와 유사하지만, 이러한 작업은 타입에 대해 수행됩니다. 실용적인 예제를 통해 그 사용법을 이해할 것이고, 이어서 기초부터 고급까지 점진적으로 8가지 Mapped type 예제를 보여드릴 것입니다. 이를 통해 이 강력한 타입 변환 도구를 손쉽게 마스터할 수 있을 거예요.\n\n# I. 기초적인 타입 변환\n\nTypeScript에서 때로는 한 타입의 속성을 다른 타입으로 변환해야할 때가 있습니다. 이것은 Mapped types을 사용하여 쉽게 달성할 수 있습니다. 아래에서 한 Product 타입의 속성을 문자열 타입으로 변환하는 방법을 구체적인 예제를 통해 보여드겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## 1. 제품 유형 정의\n\n먼저, 세 가지 속성인 name(문자열 유형), price(숫자 유형), inStock(부울 유형)을 포함하는 Product 유형을 정의합니다.\n\n```js\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n## 2. ProductToString 유형 정의\n\n<div class=\"content-ad\"></div>\n\n다음으로, 우리는 모든 Product 형식의 속성을 문자열 형식으로 변환하는 새로운 형식 ProductToString을 정의합니다.\n\n```js\ntype ProductToString = {\n    [Key in keyof Product]: string;\n};\n```\n\n## 3. 결과 형식\n\n마지막으로, 결과 ProductToString 형식은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```typescript\ntype ProductToString = {\n    name: string;\n    price: string;\n    inStock: string;\n};\n```\n\n## II. Making Type Properties Optional\n\nTypeScript에서 종종 유형의 모든 속성을 선택적으로 만들어야 합니다. 일반적으로는 내장된 Partial 유틸리티 유형을 사용하여 이것을 달성하지만, 매핑된 유형을 사용하여 동일한 효과를 얻을 수도 있습니다.\n\n### 1. 제품 유형 정의\n\n<div class=\"content-ad\"></div>\n\n```js\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n## 2. Use Mapped Types to Make Properties Optional\n\n```js\ntype ProductToOptional = {\n    [Key in keyof Product]?: Product[Key];\n};\n```\n\n## 3. Resulting Type\n\n<div class=\"content-ad\"></div>\n\n```js\ntype ProductToOptional = {\n    name?: string;\n    price?: number;\n    inStock?: boolean;\n};\n```\n\n# III. Making Optional Properties Required\n\nIn TypeScript, sometimes we need to convert all optional properties of a type into required properties. This can be easily achieved using mapped types.\n\n## 1. Define Product Type\n\n\n<div class=\"content-ad\"></div>\n\n```js\n종류 Product = {\n    name?: string;\n    price?: number;\n    inStock?: boolean;\n};\n```\n\n## 2. ProductToRequired 유형 정의\n\n```js\n유형 ProductToRequired = {\n    [Key in keyof Product]-?: Product[Key];\n};\n```\n\n## 3. 결과 유형\n\n\n<div class=\"content-ad\"></div>\n\n```js\ntype ProductToRequired = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n# IV. Making Properties Read-Only\n\nIn TypeScript, sometimes we need to make all properties of a type read-only. This can be easily achieved using mapped types.\n\n## 1. Define Product Type\n\n<div class=\"content-ad\"></div>\n\n\n## 2. Define ProductToReadonly Type\n\n```js\ntype ProductToReadonly = {\n    readonly [Key in keyof Product]: Product[Key];\n};\n```\n\n## 3. Resulting Type\n\n\n<div class=\"content-ad\"></div>\n\n```js\ntype ProductToReadonly = {\n    readonly name: string;\n    readonly price: number;\n    readonly inStock: boolean;\n};\n```\n\n## V. Removing Certain Properties\n\nTypeScript에서 때로는 유형에서 특정 속성을 제거해야 하는 경우가 있습니다. 일반적으로 내장된 Omit 유틸리티 유형을 사용하여 이를 달성하지만, 매핑된 유형을 사용하여 동일한 효과를 얻을 수도 있습니다.\n\n### 1. Product 유형 정의\n\n<div class=\"content-ad\"></div>\n\n```js\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n## 2. Use Mapped Types to Remove Properties\n\n```js\ntype ProductWithoutPrice = {\n    [Key in keyof Product as Key extends 'price' ? never : Key]: Product[Key];\n};\n```\n\n## 3. Resulting Type\n\n\n<div class=\"content-ad\"></div>\n\n```js\n타입 ProductWithoutPrice = {\n    name: string;\n    inStock: boolean;\n};\n```\n\n# VI. 특정 속성 유형만 있는 유형 생성\n\nTypeScript에서 조건부 타입을 사용하여 특정 유형의 속성만 포함된 새로운 타입을 생성할 수 있습니다.\n\n## 1. 제품 유형 정의하기\n\n\n<div class=\"content-ad\"></div>\n\n```typescript\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n    tags: string[];\n};\n```\n\n## 2. Define OnlyStringProperties Type\n\n```typescript\ntype OnlyStringProperties<Type> = {\n    [Key in keyof Type as Type[Key] extends string ? Key : never]: Type[Key];\n};\n```\n\n## 3. Use OnlyStringProperties\n\n\n<div class=\"content-ad\"></div>\n\n```js\n유형 ProductOnlyStringProperties = OnlyStringProperties<Product>;\n```\n\n## 4. 결과 유형\n\n```js\n유형 ProductOnlyStringProperties = {\n    이름: 문자열;\n};\n```\n\n# VII. 템플릿 리터럴 유형을 사용하여 새로운 속성 이름 생성하기\n\n<div class=\"content-ad\"></div>\n\nTypeScript에서는 템플릿 리터럴 타입을 사용하여 특정 접두사와 대문자로 시작하는 속성 이름을 가진 새로운 타입을 생성할 수 있습니다.\n\n## 1. 제품 타입 정의\n\n```js\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n## 2. 접두사가 포함된 속성을 가진 타입 생성\n\n<div class=\"content-ad\"></div>\n\nTypeScript에서는 템플릿 리터럴 타입을 사용하여 get로 접두사가 붙은 속성 이름을 가진 새로운 타입을 생성할 수 있어요.\n\n```js\ntype Getters<Type> = {\n    [Key in keyof Type as `get${Capitalize<string & Key>}`]: () => Type[Key];\n};\n```\n\n## 3. Getters 사용하기\n\n```js\ntype ProductGetters = Getters<Product>;\n```\n\n<div class=\"content-ad\"></div>\n\n## 4. 결과 타입\n\n```js\ntype ProductGetters = {\n    getName: () => string;\n    getPrice: () => number;\n    getInStock: () => boolean;\n};\n```\n\n# VIII. 조건에 따른 중첩 Mapped 타입\n\nTypeScript에서 Mapped 타입과 조건부 타입을 결합하여 더 복잡한 타입 변환 로직을 만들 수 있습니다. 예를 들어, 속성의 타입에 따라 다른 중첩 타입 구조를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 1. 중첩된 객체 유형 정의\n\n먼저, 중첩된 객체를 포함한 다양한 유형의 속성을 포함하는 `NestedObject` 유형을 정의합니다.\n\n```js\ntype NestedObject = {\n    id: number;\n    name: string;\n    metadata: {\n        createdAt: Date;\n        updatedAt: Date;\n    };\n    tags: string[];\n};\n```\n\n## 2. DeepReadonly 유형 정의\n\n<div class=\"content-ad\"></div>\n\n다음으로, 모든 속성을 읽기 전용으로 변환하는 DeepReadonly 타입을 정의합니다. 이는 중첩된 객체의 속성도 포함됩니다.\n\n```js\ntype DeepReadonly<T> = {\n    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n```\n\n이 정의에서 T[P] extends object은 속성 타입이 객체인지 확인하기 위해 사용됩니다. 만약 객체인 경우, DeepReadonly가 재귀적으로 적용되며, 그렇지 않은 경우 속성이 읽기 전용으로 설정됩니다. \n\n## 3. DeepReadonly 타입 사용하기\n\n<div class=\"content-ad\"></div>\n\n딥 읽기 전용을 사용하여 NestedObject의 심층적으로 읽기 전용 버전인 ReadonlyNestedObject를 정의할 수 있습니다.\n\n```js\ntype ReadonlyNestedObject = DeepReadonly<NestedObject>;\n```\n\n## 4. 결과 타입\n\n마지막으로, 결과로 나오는 ReadonlyNestedObject 타입은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n유형 ReadonlyNestedObject = {\n    readonly id: number;\n    readonly name: string;\n    readonly metadata: {\n        readonly createdAt: Date;\n        readonly updatedAt: Date;\n    };\n    readonly tags: readonly string[];\n};\n```\n\n## 5. 사용 예시\n\n```js\nconst readonlyNestedObject: ReadonlyNestedObject = {\n    id: 1,\n    name: \"예시\",\n    metadata: {\n        createdAt: new Date(),\n        updatedAt: new Date()\n    },\n    tags: [\"타입스크립트\", \"프로그래밍\"]\n};\n\n// readonlyNestedObject.id = 2; // 오류: 'id'는 읽기 전용 속성이기 때문에 할당할 수 없습니다.\n// readonlyNestedObject.metadata.createdAt = new Date(); // 오류: 'createdAt'는 읽기 전용 속성이기 때문에 할당할 수 없습니다.\n```\n\nTypeScript의 매핑된 유형은 다양한 복잡한 유형 변환을 달성할 수 있는 매우 강력한 기능입니다. 이를 사용하여 다음을 수행할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 속성 변환: 타입 내 기존 속성의 유형을 변경합니다.\n- 속성 추가 또는 제거: 새로운 속성을 추가하거나 기존 속성을 제거합니다.\n- 옵션 및 읽기 전용 상태 제어: 속성을 옵션으로 만들거나 읽기 전용으로 설정합니다.\n- 동적 타입 생성: 조건형 타입과 템플릿 리터럴 타입을 사용하여 새로운 타입을 구성합니다. (예: 게터와 세터 생성과 같은 고급 시나리오에 적합)\n\nPartial, Readonly, Omit과 같은 내장 유틸리티 타입은 편리한 단축키를 제공하지만, 매핑된 타입은 타입에 대한 깊은 이해와 정밀한 제어를 제공합니다.\n\n이 기술을 더 잘 이해하고 코드를 더 깔끔하고 예측 가능하며 유지 보수가 쉬운 상태로 만들기를 바라며, 이 글이 도움이 되기를 바랍니다.","ogImage":{"url":"/assets/img/2024-06-22-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png"},"coverImage":"/assets/img/2024-06-22-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png","tag":["Tech"],"readingTime":7},{"title":"NestJS에서 DTO 쉽게 이해하기","description":"","date":"2024-06-22 14:44","slug":"2024-06-22-DTOexplainedinNestJS","content":"\n\nDTO(Data Transfer Object) 패턴은 어플리케이션의 서로 다른 레이어 간에 데이터를 전송하는 데 일반적으로 사용되는 설계 패턴입니다. DTO 패턴의 주요 아이디어는 데이터를 캡슐화하고 어플리케이션의 서로 다른 부분 간에 데이터를 전송하는 표준화된 방법을 제공하는 것입니다.\n\n실무에서 DTO는 데이터를 포함하고 일부 유효성 검사 로직을 갖는 간단한 객체입니다. Domain 객체의 일부 또는 전체 데이터를 정의하지만 비즈니스 로직은 포함하지 않습니다. 주로 클라이언트와 서버 간 또는 서버 측 어플리케이션의 서로 다른 레이어 간에 데이터를 전송하는 데 사용됩니다. DTO 객체는 일반적으로 서버 측 코드에서 생성되며 데이터베이스 또는 기타 소스에서 데이터로 채워진 후 클라이언트로 전송됩니다. 클라이언트 측 코드는 그 후 DTO 객체를 사용하여 데이터를 사용자에게 표시하거나 처리를 위해 서버로 보낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 기본 사용법\n\nNestJS 애플리케이션에서 DTO를 사용하는 예제를 살펴보겠습니다:\n\n- DTO 클래스를 정의하세요:\n\n```js\nexport class CreateUserDto {\n  readonly name: string;\n  readonly email: string;\n  readonly password: string;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n2. 당신의 DTO 클래스를 컨트롤러에서 사용하세요:\n\n```js\nimport { Controller, Post, Body } from ‘@nestjs/common’;\nimport { CreateUserDto } from ‘./create-user.dto’;\n@Controller('users')\nexport class UsersController {\n @Post()\n async create(@Body() createUserDto: CreateUserDto) {\n // 여기에 사용자 생성 로직을 작성하세요\n }\n}\n```\n\n# 적절한 사용법\n\nDTO는 서로 다른 도메인 객체에서 데이터를 구성하거나 도메인 객체의 일부 데이터만 가져오는 데 도움을 주도록 설계되었습니다. 또한 데이터 유효성 검사를 지원하거나 직렬화 논리의 캡슐화를 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 DTO를 사용하여 데이터 일부만 사용하는 예시입니다:\n\n예를 들어, User 엔티티가 있다고 가정해 봅시다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nclass User {\n id: number;\n name: string;\n email: string;\n password: string;\n}\r\n```\n\n저희는 사용자 작업을 처리할 수 있는 서비스를 가지고 있어요:\n\n```js\r\nclass UserService {\n // 데이터베이스에서 사용자 객체 가져오기\n getUserById(userId: number): User {\n // 데이터베이스에서 사용자 데이터 가져오기\n // …\n return user;\n }\n}\r\n```\n\n이제 이름과 이메일 필드만을 가진 사용자 프로필을 만들고 싶다면 DTO를 정의할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n```js\n// 사용자 데이터의 하위 집합을 나타내는 DTO 클래스를 정의합니다\nclass UserProfileDto {\n  name: string;\n  email: string;\n}\n```\n\n그런 다음 API 요청을 처리하는 컨트롤러를 정의합니다. 이 컨트롤러에서는 서비스를 사용하여 사용자 엔티티를 가져오고 사용자 프로필의 데이터 하위 집합을 나타내는 DTO(UserProfileDto)를 사용합니다:\n\n```js\n@Controller('users')\nclass UsersController {\n  constructor(private userService: UserService) {}\n\n  // 사용자 데이터의 하위 집합을 반환하는 API 엔드포인트를 정의합니다\n  @Get(':id/profile')\n  getUserProfile(@Param('id') userId: number): UserProfileDto {\n    const user = this.userService.getUserById(userId);\n\n    // 이름과 이메일 속성만 포함하는 DTO 객체를 생성합니다\n    const userProfileDto = new UserProfileDto();\n    userProfileDto.name = user.name;\n    userProfileDto.email = user.email;\n\n    // API 응답으로 DTO 객체를 반환합니다\n    return userProfileDto;\n  }\n}\n```\n\n또 다른 예시로 하나의 DTO를 통해 여러 도메인 객체를 구성하는 데도 DTO를 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n만약 고객이 사용자의 최신 블로그 게시물을 요청한다면, 그리고 여러분은 다른 게시물 엔티티를 가지고 있다면:\n\n```js\nclass Post {\n  id: number;\n  title: string;\n  content: string;\n  userId: number;\n}\n```\n\n서비스가 필요합니다:\n\n```js\n// 사용자 및 게시물 작업을 처리하는 서비스 정의\nclass UserService {\n  // 데이터베이스에서 사용자 객체 및 최신 게시물을 가져오는 메서드\n  getUserWithLatestPost(userId: number): { user: User, latestPost: Post } {\n    // 데이터베이스에서 사용자 데이터 가져오기\n    // ...\n    \n    // 데이터베이스에서 사용자의 최신 게시물 데이터 가져오기\n    // ...\n\n    return { user, latestPost };\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 UserWithLatestPostDto를 만들 수 있습니다:\n\n```js\nclass UserWithLatestPostDto {\n  name: string;\n  email: string;\n  latestPostTitle: string;\n  latestPostContent: string;\n}\n```\n\n컨트롤러에서는 다음과 같을 것입니다:\n\n```js\n// API 요청을 처리하는 컨트롤러 정의\n@Controller('users')\nclass UsersController {\n  constructor(private userService: UserService) {}\n\n  // 사용자 데이터와 최신 포스트를 반환하는 API 엔드포인트 정의\n  @Get(':id/with-latest-post')\n  getUserWithLatestPost(@Param('id') userId: number): UserWithLatestPostDto {\n    const { user, latestPost } = this.userService.getUserWithLatestPost(userId);\n\n    // 사용자 데이터와 최신 포스트를 포함하는 DTO 객체 생성\n    const userWithLatestPostDto = new UserWithLatestPostDto();\n    userWithLatestPostDto.name = user.name;\n    userWithLatestPostDto.email = user.email;\n    userWithLatestPostDto.latestPostTitle = latestPost.title;\n    userWithLatestPostDto.latestPostContent = latestPost.content;\n\n    // API 응답으로 DTO 객체 반환\n    return userWithLatestPostDto;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 DTO는 API 호출 횟수를 줄이고, 클라이언트가 필요로 하는 데이터만 전송할 수 있도록 도와줍니다.","ogImage":{"url":"/assets/img/2024-06-22-DTOexplainedinNestJS_0.png"},"coverImage":"/assets/img/2024-06-22-DTOexplainedinNestJS_0.png","tag":["Tech"],"readingTime":5}],"page":"11","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}