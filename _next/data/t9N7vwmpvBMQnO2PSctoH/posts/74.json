{"pageProps":{"posts":[{"title":"Docker 이미지를 빌드하고 GitHub Actions를 사용하여 Docker Hub에 푸시하기","description":"","date":"2024-05-17 03:47","slug":"2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions","content":"\n\n<img src=\"/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_0.png\" />\n\n여기서는 GitHub actions workflow를 사용하여 도커 이미지를 빌드하고 도커 허브에 푸시하는 방법을 알아보겠습니다.\n\n## 단계 1: 도커 파일 만들기\n\n- 도커 이미지를 빌드하려면 도커 파일을 만들어야 합니다.\n- 이 튜토리얼에서는 매우 기본적인 도커 파일을 만들고 해당 파일을 사용하여 이미지를 빌드할 것입니다.\n- Dockerfile을 만들고 아래 코드를 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n# Docker Hub에서 공식 Apache HTTP 서버 이미지를 사용하세요\nFROM httpd:latest\n\n# 호스팅을 위해 사용자 정의 'index.html'을 Apache 서버의 루트 디렉토리에 복사하세요\nCOPY ./index.html /usr/local/apache2/htdocs/\n```\n\n- 위의 코드는 다음 단계에서 생성할 사용자 정의 index.html을 사용하여 Apache 이미지 위에 이미지를 빌드합니다.\n\n## 단계 2: index.html 파일 생성\n\n- index.html 파일을 생성하고 아래 코드를 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Hello World</title>\n</head>\n<body>\n    <h1>Hello, World!</h1>\n    <p>This is a simple HTML page served from an Apache server in a Docker container.</p>\n</body>\n</html>\n```\n\n### 단계 3: 도커 허브 자격 증명 저장\n\n- 도커 이미지를 도커 허브로 푸시하려면 먼저 도커 허브에 로그인해야 합니다. 따라서 해당 자격 증명을 시크릿에 저장해야 합니다.\n- 귀하의 저장소에서 자격 증명을 시크릿에 저장하세요.\n\n![이미지](/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_1.png)\n  \n\n<div class=\"content-ad\"></div>\n\n## 단계 4: GitHub 액션 워크플로우 생성하기\n\n- 이제 .github/workflow/image-build.yml 파일을 만들고 아래 코드를 추가하세요.\n\n```js\nname: Build Docker Image\non:\n  push:\n    branches:\n      - main\njobs:\n    build:\n      name: push docker image to docker hub\n      runs-on: ubuntu-latest\n      steps:\n        - uses: actions/checkout@v2\n        - name: login to docker hub\n          id: docker-hub\n          env:\n            username: ${secrets.DOCKERHUB_USERNAME}\n            password: ${secrets.DOCKERHUB_PASSWORD}\n          run: |\n            docker login -u $username -p $password \n        - name: build the docker image\n          id: build-docker-image\n          run: |\n            ls -la \n            docker build . -f Dockerfile -t dhruvin30/demo-image-test:latest\n        - name: push the docker image\n          id: push-docker-image\n          run: docker push ${secrets.DOCKERHUB_USERNAME}/demo-image-test:latest\n```\n\n- 위 워크플로우는 main 브랜치에 커밋할 때마다 트리거됩니다.\n- 워크플로우는 secrets(사용자 이름 및 비밀번호)를 사용하여 docker hub에 로그인합니다.\n\n<div class=\"content-ad\"></div>\n\n## 단계 5: 코드를 커밋합니다\n\n- 이제 코드를 GitHub 저장소에 커밋하고 커밋하자마자 워크플로가 실행되는 것을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_2.png)\n\n## 단계 6: 변경 사항 확인하기\n\n<div class=\"content-ad\"></div>\n\n- 한 번 Workflow가 성공적으로 실행되면 이미지가 도커 허브에 표시될 것입니다.\n\n![이미지](/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_3.png)\n\n오늘은 여기까지입니다. GitHub Actions를 사용하여 도커 이미지를 빌드하고 푸시하는 방법을 배웠습니다. 이제 코드를 수정하고 실험해보세요.\n\nLinkedIn에서 팔로우해주세요.\n\n<div class=\"content-ad\"></div>\n\n더 이런 이야기를 보고 싶다면 팔로우해 주세요 😁","ogImage":{"url":"/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_0.png"},"coverImage":"/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_0.png","tag":["Tech"],"readingTime":3},{"title":"Databricks 사용 방법 정리","description":"","date":"2024-05-17 03:45","slug":"2024-05-17-DatabricksChampionJourney","content":"\n\n다음은 Databricks 챔피언 배지를 획득하고 지명되기 위한 요구 사항입니다.\n\n1. 다음 중 하나의 경로를 통해 Databricks 인증을 취득하십시오:\n\n<div class=\"content-ad\"></div>\n\nA. 데이터 엔지니어링 트랙은 다음과 같은 자격 인증 요구 사항으로 구성됩니다.\n\n- 데이터 엔지니어링 어소시에이트 인증,\n- 고급 데이터 엔지니어링 인증\n\n또는\n\nB. 데이터 과학 트랙은 다음과 같은 자격 인증 요구 사항으로 구성됩니다.\n\n- ML 어소시에이트\n- ML 프로페셔널\n\n저는 현재 진행 중인 업무와 일치하기 때문에 데이터 엔지니어링 경로를 선택했습니다. 데이터 엔지니어링 어소시에이트 및 프로페셔널 인증 모두 완료했습니다.\n\n<div class=\"content-ad\"></div>\n\n또한 PySpark 기술을 강화하기 위해 Spark 개발자 어소시에이트 시험을 응시하여 해당 자격증을 획득했습니다.\n\n![이미지](/assets/img/2024-05-17-DatabricksChampionJourney_1.png)\n\n2. 데이터브릭스 솔루션 아키텍트 필수 배지 획득을 위해 3일간의 세션에 참석하고 평가를 거쳤습니다.\n\n솔루션 아키텍트 필수 자격은 데이터브릭스 파트너 포털을 통해 수강할 수 있는 여러 과정과 평가를 거쳐야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-17-DatabricksChampionJourney_2.png)\n\n3. Panel review with Databricks experts from Databricks\n\nThis step requires preparing a deck with the following contents:\n\n- Candidate introduction\n- Business problem statement\n- Solution overview\n- Reference architecture\n- Deep-dive into architectural areas\n- Project outlook / next steps\n- Contribution to the community (I have shared my medium.com blogs relating to Databricks topics)\n\n\n<div class=\"content-ad\"></div>\n\n내부적으로 Databricks 챔피언들과 함께 덱을 검토하세요. 때로는 당신이 제출을 평가하고 있는 Databricks 직원과 함께 모의 실행도 할 수 있어요.\n\n마지막으로, 덱이 완성되면 Databricks 특정 질문에 대답하며 덱을 설명하는 패널 리뷰에 참여하게 됩니다. 패널이 당신의 대답과 Databricks에 대한 전문성에 만족한다면, 당신은 챔피언으로 인정받을 거예요.\n\n![이미지](/assets/img/2024-05-17-DatabricksChampionJourney_3.png)\n\n![이미지](/assets/img/2024-05-17-DatabricksChampionJourney_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n참고: 여기 언급된 체크리스트는 경우에 따라 다를 수 있습니다.\n\nDatabricks 챔피언의 혜택:\n\n- 비슷한 마음가짐을 가진 작은 그룹의 Databricks 챔피언\n- Databricks 분기로드맵 업데이트에 대한 액세스\n- Databricks 학습 자료, 솔루션에 대한 액세스\n- Databricks 내부 기술 서밋 초대 (매년)\n- 데이터 및 AI 서밋 할인 쿠폰\n- 무료 Databricks 챔피언 재킷 :)","ogImage":{"url":"/assets/img/2024-05-17-DatabricksChampionJourney_0.png"},"coverImage":"/assets/img/2024-05-17-DatabricksChampionJourney_0.png","tag":["Tech"],"readingTime":2},{"title":"Route 53과 AWS Lambda, S3를 이용해 간편하게 DNS 레코드 백업 자동화하기","description":"","date":"2024-05-17 03:44","slug":"2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3","content":"\n\n# 소개\n\nDNS 레코드를 관리하는 것은 여러 개의 호스티드 존을 다룰 때 특히 복잡할 수 있습니다. 이러한 레코드의 백업을 자동화하면 유지 관리가 단순화되는데 그치지 않고 필요할 경우 언제든지 백업을 사용할 수 있도록 해줍니다. 이 튜토리얼에서는 AWS Lambda 함수를 생성하여 이를 수행하는 방법을 살펴보겠습니다: 여러 호스티드 존에서 모든 DNS 레코드를 백업하고 이러한 백업을 S3 버킷에 저장하여 레코드의 완전한 JSON을 생성하고 CSV 파일의 별도의 파일에 구성합니다.\n\n# 준비 사항\n\n- 적절한 자격 증명으로 구성된 AWS 콘솔.\n- Route 53 및 S3에 액세스 할 적절한 권한.\n- 백업을 저장할 S3 버킷이 만들어져 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계별 가이드\n\n# 1. 람다 함수 생성하기\n\n먼저 람다 함수를 생성해 봅시다. AWS 콘솔에서 Lambda 서비스로 이동하고 \"함수 생성\"을 클릭합니다.\n\n- 이름: Route53Backup\n- 런타임: Python 3.x\n- 역할: Lambda 기본 권한을 가진 새 역할을 생성하고 Route 53 및 S3에 액세스할 수 있는 권한을 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n람다 정책 권한:\n\n```js\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"logs:CreateLogGroup\",\n            \"Resource\": \"arn:aws:logs:us-east-1:12345678:*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:aws:logs:us-east-1:12345678:log-group:/aws/lambda/lamda-name:*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:GetHostedZone\",\n                \"route53:ListHostedZones\",\n                \"route53:ListHostedZonesByName\",\n                \"route53:ListResourceRecordSets\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:ListBucket\",\n                \"s3:ListAllMyBuckets\",\n                \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::bucket_name\"\n            ]\n        }\n    ]\n}\n```\n\n# 2. Write the Code\n\n우리 람다 함수의 코드입니다. 이 코드는 여러 호스팅된 존에서 DNS 레코드를 검색하여 이를 S3 버킷에 저장합니다.\n\n<div class=\"content-ad\"></div>\n\n```python\nimport boto3\nimport json\nfrom datetime import datetime\nimport csv\n\ndef lambda_handler(event, context):\n    # 연결된 ID와 도메인 목록\n    hosted_zones = [\n        {'id': '$HOSTED_ZONE_ID', 'domain': '$DOMAIN'},\n        {'id': '$HOSTED_ZONE_ID_2', 'domain': '$DOMAIN2'}\n    ]\n\n    # Route 53 및 S3 클라이언트 초기화\n    route53_client = boto3.client('route53')\n    s3_client = boto3.client('s3')\n\n    # 목록의 각 호스팅 영역을 돌아다니기\n    for hosted_zone in hosted_zones:\n        # 모든 영역 레코드 가져오기\n        response = route53_client.list_resource_record_sets(\n            HostedZoneId=hosted_zone['id']\n        )\n\n        # JSON 형식으로 변환\n        records = json.dumps(response['ResourceRecordSets'], indent=2)\n        records_formatted = response['ResourceRecordSets']\n        #CSV에 행 생성\n        csv_rows = [[\"Name\", \"Type\", \"DNS Name\"]]\n\n        for record_formatted in records_formatted:\n            name = record_formatted['Name']\n            record_type = record_formatted['Type']\n            if 'AliasTarget' in record_formatted:\n                dns_name = record_formatted['AliasTarget']['DNSName']\n            elif 'ResourceRecords' in record_formatted:\n                dns_name = \", \".join([r['Value'] for r in record_formatted.get('ResourceRecords', [])])\n            else:\n                dns_name = \"\"\n            #CSV에 행 추가\n            csv_rows.append([name, record_type, dns_name])\n\n        #CSV 파일에 레코드 추가\n        csv_buffer = csv.writer(open(\"/tmp/\" + backup_filename_csv, 'w'))\n        csv_buffer.writerows(csv_rows)\n\n        # 오늘 날짜와 시간을 포함한 아카이브 이름\n        backup_filename = f\"{datetime.now().strftime('%Y%m%d-%H%M')}.json\"\n        backup_filename_csv = f\"{datetime.now().strftime('%Y%m%d-%H%M')}.csv\"\n\n        # S3에 업로드\n        s3_key = f\"{hosted_zone['domain']}/data/{backup_filename}\"\n        s3_key_csv = f\"{hosted_zone['domain']}/data/{backup_filename_csv}\"\n        s3_client.put_object(\n            Bucket='$BUCKET_NAME',\n            Key=s3_key,\n            Body=records\n        )\n        \n        s3_client.upload_file(\"/tmp/\" + backup_filename_csv, '$BUCKET_NAME', s3_key_csv)\n\n    return {\n        'statusCode': 200,\n        'body': f'Success.'\n    }\n```\n\nHOSTED_ZONE_ID 및 BUCKET_NAME의 값을 교체해주세요. 필요하다면 backup_filename_formatted 및 backup_filename 변수를 원하는 파일 이름으로 교체해주세요.\n\n# 3. 함수 테스트\n\n함수를 테스트하려면 Lambda 콘솔에서 테스트 이벤트를 구성할 수 있습니다. 예를 들어 사용하지 않는 직접적인 입력이 없으므로 빈 JSON ''을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 4. 실행 일정 예약하기 (선택 사항)\n\n만약 람다 함수를 주기적으로 실행하고 싶다면 CloudWatch Events 트리거를 구성할 수 있습니다. CloudWatch 콘솔에서 “Rules”로 이동하여 새로운 규칙을 만들고 원하는 간격(예: 매일)에 람다를 트리거하도록 설정하세요.\n\n# 5. CSV 보기\n\n여기에 당신의 도메인 레코드가 어떻게 포맷될지 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3_0.png\" />\n\n# 결론\n\nRoute 53에서 DNS 레코드를 백업하는 것을 자동화하기 위해 Lambda 함수와 S3를 사용하는 것은 항상 DNS 레코드의 최신 사본을 보유할 수 있는 효과적인 방법입니다. 이는 유지 보수를 간편하게 해주는 것뿐만 아니라 DNS 설정의 보안성을 향상시킵니다.\n\n궁금한 점이나 제안 사항이 있으시면 아래 댓글에 남겨주세요. 즐거운 자동화 되세요!","ogImage":{"url":"/assets/img/2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3_0.png"},"coverImage":"/assets/img/2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3_0.png","tag":["Tech"],"readingTime":5},{"title":"규칙은 우리를 갇히는 우리의 속성","description":"","date":"2024-05-17 03:42","slug":"2024-05-17-RulesAreACageandImaPuppygirl","content":"\n\n테이블탑 RPG 룰북은 우리를 제약하고 가둬 놓는 역할만 한다고 생각할 때, 왜 좋은 것일까요?\n\n![image](/assets/img/2024-05-17-RulesAreACageandImaPuppygirl_0.png)\n\n테이블탑 RPG 중 어떤 것을 살펴볼 때, 나에게 이 게임이 무엇을 제공하며 친구들과 상상놀이로 이루어지는 게임으로 이루기 어려운 것을 제공하는지가 가장 먼저 나오는 질문입니다. 몇 명의 친구들을 모아 함께 앉아 던전 모험가나 슈퍼히어로 등으로 소괴 모험가들로 모습을 변하며 행동을 상상으로만 설명해도 상관이 없고 이를 위해 룰북이 없어도 될 것입니다. 그래서 우리는 왜 게임을 하려고 하는 걸까요?\n\n가끔 (자주) 사람들이 특정 게임을 하라고 제안하는 이유는 특정 행동을 할 수 있는 권한을 부여하거나, 보통 할 수 없는 것을 시키기 위함이라고 말합니다. 그것은 나에게는 매우 만족스럽지 않은 대답입니다 - 상상 속에서 나는 아무런 허락도 필요로하지 않아요. 비디오 게임이나 보드 게임을 하는 경우라면, 소설의 세계보다 규칙이 우선이 되는 게임이라면 특정 행동을 할 수 있는 규칙이나 허락을 받기 위한 규칙에 관심을 갖게 될 것입니다. 하지만 TTRPG에서 궁극적으로는 내가 원하는 대로 아무것이나 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n가끔(자주) 사람들은 이 질문을 듣고 그들의 게임이나 게임 즐기는 방식에 대한 위협으로 받아들이기도 합니다. 어떤 사람들은 이를 받아들이고 결론을 내립니다: 게임을 할 이유가 전혀 없다고요. 이는 많은 사람들에게 괴롭기도 합니다, 왜냐하면 그들은 게임을 만들고 즐기기를 좋아하기 때문이죠! 때때로 이 질문을 하기만 해도 고통을 초래할 수 있습니다. 하지만 나는 항상 친구들과 허구놀이를 하는 것이 아닙니다: 아주 많은 경우에는 게임을 선택하는 편이죠. 그렇다면 왜일까요? 게임이 제게 제공하는 것은 무엇일까요, 허구놀이에서는 얻을 수 없는 것이 뭔가요?\n\n# 강아지소녀들에 대해\n\n(안내: 제 개인적인 삶에서 하는 일은 제 개인적인 문제이며, 제 성적 취향이나 개인적인 선호 사항에 대한 이상한 농담을 받아들일 의도가 없습니다. 이 블로그 글을 통해 제게 대해 가정하는 것을 좋아하지 않을 거에요!)\n\n가끔 사람들은 구속을 즐긴다고 합니다(저도 들어봤어요). 목걸이를 차거나 우리를 감아넣는 것, 손목을 침대 프레임에 잠금해두거나 눈가림을 하는 것이 즐겁습니다. 이는 통제를 위해 투쟁하길 원하기 때문에 즐거운 것입니다. 팔을 움직이거나 말을 하거나 뭐 보는 것은 원하지만, 누군가가 당신을 위해 조금 어렵게 만들 수 있게 허용합니다. 그래서 마찰로부터 생기는 재미가 있기 때문입니다. 제가 감옥에 있다면, 그 감옥은 긴장과 마찰의 원천이 됩니다. 그것과 씨름하고, 물고, 부딪히는 등 제가 그것에 맞설 수 있습니다. 이것은 일반적으로 성취할 수 있는 것의 한계로 기능합니다. 감옥을 밀어보았더니 문이 열리면 실망하게 된다, 왜냐하면 그것은 내가 더 노력할 수 없었다는 것을 의미하기 때문이죠. 나는 내가 자신을 감옥에 던져도 버틸 수 있는 단단한 감옥을 원합니다고 해봅니다.\n\n<div class=\"content-ad\"></div>\n\n# 게임으로 돌아가기\n\n게임이 규칙을 제시하면, 해당 규칙은 내가 처음에 의도했던 것과 간섭합니다. 가짜놀이를 할 때는 원하는 대로 벽을 뛰어넘을 수 있습니다. 다만 뛰어넘고 싶지 않을 때는 그렇지 않습니다. 다만 Dungeons & Dragons를 할 때 12피트 높이의 벽을 뛰어넘고 싶다면, 고난도의 민첩성 체크를 굴려야 하며, 실패하면 벽을 넘을 수 없습니다. 이 규칙은 초기에 하던 가짜놀이를 방해하고, 내 행동력을 제한합니다.\n\n하지만 이런 것이 좋다는 것이죠!\n\n내가 가짜놀이를 하는 대신 특정한 테이블탑 RPG를 하는 이유는 게임이 내가 지나가는 상상 속 세계에 도전을 주고 괴롭히기를 바란다는 것입니다. 게임이 나를 감금하고, 일반적으로 할 수 있는 일을 어렵게 만들어줄 것을 원하고, 효율성을 떨어뜨리는 순간들을 만들어내며 내 행동 방식을 조각하는 것입니다. 우리가 테이블을 선택했던 이유가 바로 이것이기 때문이죠!\n\n<div class=\"content-ad\"></div>\n\n게임이 우리 상상력에 개입하는 방식, 어디서 개입해야 하는지 아니면 뒤로 물러나야 하는지가 게임이 초점을 어디에 두는지를 반영합니다. 던전 앤 드래곤즈는 전투에 대한 많은 규칙을 갖고 있지만 사교적 상호작용에 대한 규칙은 매우 적습니다. 이는 던전 앤 드래곤즈 시스템이 전투에 참여하는 방법에 간섭하고 중재하는데 큰 투자를 하고 사회적 상호작용에 참여하는 방법에 간섭하지 않으려고 노력한다는 것을 의미합니다. \n\n이 사실을 해석하는 여러 가지 방법이 있습니다: 어떤 사람들은 던전 앤 드래곤즈가 전투에 더 관심을 두는 것으로 생각할 수 있지만, 다른 사람들은 던전 앤 드래곤즈가 전투를 피하면서 자유로운 사회적 장면을 위한 공간을 마련한다고 생각할 수도 있습니다.\n\n최종적으로 던전 앤 드래곤즈에서는 전투 주변에 큰 울타리가 있고, 사회적 상호작용 주변에는 넓은 공간이 펼쳐져 있습니다. 만약 우리가 던전 앤 드래곤즈가 제공하는 공간에서 게임을 하고 싶다면, 우리는 울타리 안에 갇히거나 마당을 살랑살랑 걸어다닐 수 있으며, 어느 쪽이 더 재미있고 유익한지는 우리에 달려 있습니다.\n\n## 게임 텍스트에 대한 한 가지 짧은 이야기\n\n나는 계속해서 \"게임이 이것을 원한다\" 또는 \"게임이 우리의 행동을 제한한다\"고 말하고 있습니다. 이는 물론 헛소리입니다 — 탁상 RPG는 규칙을 설명하는 게임 텍스트이지만 강제 실행 메커니즘이 없습니다. 우리는 그러한 규칙을 해석하고 우리의 게임에 적용하지만, 아무도 우리에게 그렇게 하도록 할 의무는 없습니다. 내가 게임 텍스트가 원하는 것에 대해 말할 때, 나는 게임 텍스트가 제시하는 규칙을 완전히 이해하고 적용하고 우리 게임에 사용하는 상황을 의미합니다. 규칙이 울타리라면, 그 울타리를 산 사람은 우리이고, 우리는 울타리를 세우거나 무시할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래도, 바닥에 앉아있는 케이지가 있는 경우, 그것을 무시하고 있더라도 우리가 하는 방식을 형성합니다. 우리가 던전 앤 드래곤을 하기로 결정하고, 주사위를 한 번도 굴리지 않고 상황을 탐험하려고 한다면(우리는 주사위를 굴리지 않는 세션을 진행한다), 규칙의 잠재력은 여전히 우리와 함께 존재합니다. 우리가 초대한 존재입니다(책을 테이블 위에 놓기로 선택했습니다), 하지만 그 존재는 우리의 행동을 조각하고, 마치 깜박이는 양초나 반지의 제왕이 그랬던 것처럼.\n\n## 원더홈 (예시)\n\n'Wanderhome'은 매우 적은 규칙을 갖춘 게임입니다. 최소한의 토큰 경제 관련 가볍고 쉽게 무시할 수 있는 것들과 서로가 어떻게 관련 지어지는지를 형성하는 많은 선택 목록이 있지만, 이 게임에서 유일하게 단호한 입장을 취하는 것은 이 게임에는 폭력이 없다는 주장이라는 것뿐입니다. 그리고 황제 역할의 경우, 폭력을 허용하는 단 하나의 규칙이 있습니다. 검을 빼내고 당신 앞에 있는 사람을 쳐서 황제를 플레이 공간에서 제외시키세요.\n\n몇 사람들은 폭력의 가능성을 피하면서 'Wanderhome'을 하는데, 가능한 한 이 제한에서 최대한 멀리 떨어져 있습니다. 그것 또한 괜찮습니다! 하지만 나는 그 제한에 가까이 다가가보고 얼마나 가까이 다가갈 수 있는지를 보는 방식을 좋아합니다. 지나갈 수 없는 케이지가 있다는 것을 알고 있는 것은 나에게 그 케이지의 모든 무게를 받쳐 밀어 넣을 수 있는 기회를 줍니다. 폭력은 허용되지 않는다는 것은 나에게 혼란과 참사적인 상황에 놓이게 하고, 상황이 폭력적으로 전개되는 것을 피하면서 어떻게 일으키지 않고 나갈 수 있는지 함께 해보는 과정을 보여줍니다. 황제의 폭력 행위는 유일한 탈출 가닥을 보여주며, 케이지 밖으로 나갈 수 있는 독특하고 참상적인 능력을 가진 황제가 어떻게 플레이되는지를 유일하게 형성합니다.\n\n<div class=\"content-ad\"></div>\n\n어떤 상자에 쓰여 있는 문구가 “여기에 절대 가까이 오지 마세요\"가 아니라 \"나오기 어려울수록 정말 흥미로운 것이 있다!\" 라는 말이에요!\n\n# 마크 로즈워터에 대하여 알아보기\n\n마크 로즈워터는 유명한 말을 했어요: “제한은 창의력을 낳는다.” 제한이 창의력을 독려한다는 말이 사실이라고 생각해요. 또, 게임을 할 때 창의력을 발휘할 때도 그렇죠. 제한이라는 것은 예상치 못한 새로운 가능성을 제시해주기 때문에 놀라운 플레이 경로를 만들어내요! 만약 단순한 싸움으로는 패배할 걸 알고 있다면, 다른 방식으로 그 싸움에 참여하려고 할 거에요. 만약 랜덤한 테이블을 굴려 두 가지 이상의 이상한 아이디어를 결합하라는 지시를 받는다면, 정말 흥미진진한 결과가 나올 거에요!\n\n또한, 가끔씩 제한은 재미없을 수도 있어요 — 특히 “까탈스런” 제한은요. 플레이 시 불편함이 느껴지는 것이 반드시 즐거운 것은 아니죠. 로즈워터도 이에 대해 이야기했어요. 모든 사람들이 그 제한에 동의해야 하며, 그 제한에 대하여 즐거움을 느낄 수 있어야 해요. 플레이어와 게임 디자이너 사이의 사회 계약의 일부로서, 게임 디자이너는 그 한계가 흥미롭다고 보장했다는 것을 이해해야 해요.\n\n<div class=\"content-ad\"></div>\n\n# 세븐-파트 팩트 (또 다른 예시)\n\n세븐-파트 팩트는 저가 만드는 게임인데 (그리고 제 Patreon을 지원해주신다면 읽을 수 있어요) 세븐 마법사들이 세상을 유지하려고 노력하는 이야기입니다. 이 게임은 대부분 남성 우위적인 공간에서 존재하는 것과 관련이 있습니다 (마법사들은 남성이어야 한다고 기대되며, 주류 사회 기대가 게임 구조의 많은 부분을 통제합니다). 규칙은 제한적이고 시뮬레이션 중심적이며 복잡하며 제한적입니다. 아내와 자식들과의 시간을 보내면서 이에게 기계적 이득을 누릴 때만 장려받게 됩니다. 직무 수행에 주력하는 대신 그들과 시간을 보내기로 선택한다면 역할에 중점을 두는 데 어려움을 겪게 될 것입니다.\n\n이러한 규칙은 엄격하고 강렬한 남성 우위 사회 구조를 모델링하고자 하는 것이며, 플레이어들은 해당 플레이 영역을 즐기며 즐길 수 있습니다. 이것은 아내와 자식들과 시간을 보내는 것을 보상하는 것이 아니라, 스스로의 행동이 이기적인 행동이 되게끔 만든 인센티브입니다 - 다른 것을 소홀히 하는 것인지, 아니면 그렇게 하기 위해 보상을 받고 있는 것인지, 그로부터 인류가 느껴진다는 게 기분 나쁘게 느껴질 것입니다. 이 규칙은 잔인하고 부당합니다. 이를 깨기 위한 방법을 찾고, 벗어나고, 가족과 자유롭게 살 수 있는 방법을 찾고 싶어합니다. — \n\n혹은 그렇게 하지 않을 수도 있습니다. 캐릭터가 일에 초점을 맞춘 잔인한 사나이일 수도 있습니다. 아니면 그냥 냉담할 수도 있고, 플레이어로서 이를 깨닫지 못하고 무시하며 마법사를 경솔하게 방치할 수도 있습니다. 이러한 모든 것들이 인센티브 시스템으로부터 나오는 흥미로운 반응들입니다!\n\n<div class=\"content-ad\"></div>\n\n저는 당신을 감옥에 가둔 상태에서 무엇을 할지 제어할 수 없어요. 혹시 그 위에 올라서거나 강간하거나 놀기 싫어하거나 무시하고 핸드폰으로 놀 수도 있죠. 이 모든 것들은 전혀 합리적인 정서적 반응들이에요. 게임 디자이너로서, 제가 당신의 감정을 제어하지는 않아요. 단지 당신의 즐거움을 위해 그 감옥을 설치할 뿐이죠.\n\n# Ouppy Play\n\n함께 놀아요! 함께 들판을 돌아다니며 우리가 할 수 있는 것의 한계를 찾아보고, 그 한계에 최대한 강하고 강렬하게 저항해봐요. 우리가 벽으로 만들어진 공간을 탐험할 수 있도록 선과 장막을 설치해요. 규칙이 방해될 때 그 시련으로부터 어떤 흥미로운 것들이 나오는지 보죠. 디자이너로서, 그 규칙이 싸워볼 가치가 있는지 확인합시다.\n\n이 블로그 글은 원래 저의 Patreon에 게시되었어요. Possum Creek Patreon을 지원하면 이런 블로그 게시물들을 몇 주 혹은 몇 달 앞서 볼 수 있을 뿐만 아니라 독점 아티클, 게임, 최초 미리보기 등의 혜택도 받을 수 있어요.","ogImage":{"url":"/assets/img/2024-05-17-RulesAreACageandImaPuppygirl_0.png"},"coverImage":"/assets/img/2024-05-17-RulesAreACageandImaPuppygirl_0.png","tag":["Tech"],"readingTime":6},{"title":"Google IO Kotlin Multiplatform을 지원 발표 내용 정리","description":"","date":"2024-05-17 03:41","slug":"2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform","content":"\n\n## 그러나 Dagger/Hilt는 아직입니다.\n\n![이미지](/assets/img/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform_0.png)\n\n요즘 구글 I/O 2024를 놓치셨다면:\n\n\"여러분이 코틀린을 얼마나 사랑하는지 잘 알고 있습니다! 커뮤니티의 성장과 열정을 보는 것이 정말 즐거웠습니다. 오늘, 안드로이드에서 Kotlin Multiplatform을 위한 일류 도구 및 라이브러리 지원으로 나아가는 미래로 큰 한걸음을 내딛었다는 것을 기쁘게 알려드립니다!\"\n\n<div class=\"content-ad\"></div>\n\n우리는 Datastore와 같은 선택된 JetPack 라이브러리에 Kotlin Multiplatform 지원을 추가해왔고, 이제는 Room과 같은 즐겨 사용하는 라이브러리로 확대하고 있습니다. Google에서는 Google Docs 앱을 Kotlin Multiplatform을 사용하여 Android, iOS 및 Web 간에 비즈니스 로직을 공유하기 위해 이주 작업을 진행 중입니다.\n\nWorkspace 팀은 앞으로 나머지 앱들에 Kotlin Multiplatform을 사용하여 투자할 수 있는 기회에 대해 흥분하고 있습니다. Google 앱들과의 작업을 통해 많은 것을 배우고 있으며, JetBrains 및 Kotlin 개발자 커뮤니티와 협력하여 KMP의 혜택을 여러분 모두에게 제공할 예정입니다. Kotlin Multiplatform은 플랫폼 간에 비즈니스 로직을 공유함으로써 생산성을 높일 것입니다.\n\n# 두 주 전에 Dagger 팀에게 KMP 지원 로드맵에 대해 물어보았습니다\n\n![이미지](/assets/img/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform_1.png)\n\n<div class=\"content-ad\"></div>\n\n더 알아보니 Dagger/Hilt는 여전히 KSP 지원을 수정하는 데 어려움을 겪고 있지만, 적어도 두 주 전까지 KMP를 지원할 계획이 없었다고 합니다.\n\n# DI(Dependency Injection) 방법에 대해 사람들의 선호도가 아주 강하다는 것을 알고 있어요\n\n직접적인 의존성 주입, 서비스 로케이터, Dagger/Hilt, 그리고 Koin 사이의 논쟁은 제가 업무에서 어떤 DI 프레임워크를 사용하기 전에도 훨씬 일찍 시작되었을 겁니다. 저는 Koin을 시도해보고, 그리고 3년 전에 Dagger와 Hilt를 사용해 봤어요.\n\n이 주제는 새로운 것이 아니죠. 제가 처음 보는 것 처럼 논쟁하지는 않을 거에요. 당신이 선호하는 것/반대하는 것을 쉽게 검색해서 찾아볼 수 있어요. 제 생각과 다르지만 몇 가지 무작위 검색 결과를 여기에 정리해 봤어요.\n\n<div class=\"content-ad\"></div>\n\n# 흥미로운 포인트?\n\nKMP로 이동할 때 DI 프레임워크를 전환하는 것만이 관심사가 아닙니다. 사람들이 네이티브 안드로이드에서 /app에서 KMP의 /composeApp으로 소스 코드를 이동할 때 논리적 추론을 어떻게 했는지를 보여줍니다.\n\n이 모든 해외에서 과거와 새로운 선호도를 지원하기 위한 의존성 주입에 대한 긴 기술적 토론을 어떻게 잊었을까요? DI 자체를 지원하기 위해 어떤 프레임워크를 선택하는 것보다 이게 더 흥미롭습니다.\n\nDI 프레임워크의 가용성 때문에 KMP 이주를 망설일 정도로 잘 알고 있는 사람들도 있습니다. 웹에서 검색할 수 있는 토론들이 분명 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 하지만 현재 이러한 대안들도 있어요:\n\n- Kodein\n- kotlin-inject\n- Koject\n- DI.kt\n- PopKorn\n\n그리고 당연히 의존성 주입을 위해 Koin을 사용하고 있어요.\n\n돈을 벌어야 해서 Koin을 사용하고 있지만, 시간이 될 때 다른 대안들을 시도해볼 수 있는지 보겠어요.\n\n<div class=\"content-ad\"></div>\n\n위에서 언급한 것 중에 시도해 본 적이 있는 경우에는 경험을 공유해 주세요!","ogImage":{"url":"/assets/img/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform_0.png"},"coverImage":"/assets/img/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform_0.png","tag":["Tech"],"readingTime":3},{"title":"판타지 앱에 반드시 필요한 5가지 기능 (2024년 최신)","description":"","date":"2024-05-17 03:40","slug":"2024-05-17-5Must-HaveFeaturesforYourFantasyAppin2024","content":"\n\n<img src=\"/assets/img/2024-05-17-5Must-HaveFeaturesforYourFantasyAppin2024_0.png\" />\n\n판타지 장르는 여러 매체를 통해 관객을 사로잡는 가운데 여전히 우뚝 서 있습니다. 모바일 앱의 끊임없는 발전 속에서, 판타지 스포츠와 RPG는 인기가 급증하고 있습니다. 그러나 사용자들의 주목을 끌기 위해 무수히 많은 옵션이 경쟁하고 있는 가운데, 귀하의 판타지 앱이 돋보이게 하려면 어떻게 해야 할까요? 답은 사용자 경험을 향상시키고 번영하는 커뮤니티를 육성하는 혁신적인 기능에 있습니다. 여기에는 2024년에 귀하의 판타지 앱을 한 층 높이는 5가지 필수적인 기능이 있습니다:\n\n1. 몰입형 사용자 경험 (UX) 및 사용자 인터페이스 (UI):\n\n오늘날의 모바일 중심 세상에서는 유려하고 직관적인 사용자 경험이 매우 중요합니다. 귀하의 앱의 사용자 인터페이스 (UI)는 시각적으로 매력적이고 쉽게 탐색할 수 있으며 다양한 화면 크기에 최적화되어야 합니다. 명확한 메뉴, 빠른 로딩 시간 및 잘 배치된 튜토리얼을 고려하여 새로운 이용자들을 위한 원활한 이용자 여정을 보장해 주십시오.\n\n<div class=\"content-ad\"></div>\n\n2. 인공지능의 힘을 받아들이세요:\n\n인공지능(AI)은 판타지 앱 환경을 혁신할 수 있는 잠재력을 가지고 있습니다. 다음과 같은 기능들을 포함하는 것을 고려해보세요:\n\n3. 번영하는 커뮤니티를 육성하세요:\n\n판타지 앱은 사회적 상호작용과 친선적 경쟁을 통해 번영합니다. 소통과 커뮤니티 형성을 촉진하는 기능을 통합해보세요:\n\n<div class=\"content-ad\"></div>\n\n4. 안전하고 확장 가능한 인프라:\n\n사용자 데이터, 금융 거래(해당하는 경우) 및 지적 재산은 견고한 보호가 필요합니다. 업계 표준 보안 조치를 우선시하는 신뢰할 만한 판타지 스포츠 소프트웨어 개발 회사와 협력하세요. 또한 앱의 인프라가 성능을 저하시키지 않으면서 증가하는 사용자 베이스를 처리할 수 있도록 보장하세요.\n\n5. 피드백과 데이터 주도적 결정 반영:\n\n앱 개발 과정은 지속적인 개선의 사이클입니다. 설문 조사 및 앱 리뷰를 통해 사용자 피드백을 수집하세요. 앱 데이터를 분석하여 사용자 행동을 이해하고 개선할 부분을 파악하세요. 판타지 앱 개발 및 모바일 기술의 최신 트렌드를 지속적으로 파악하세요. 이 데이터는 앱을 신선하고 매력적으로 유지하기 위해 향후 업데이트, 버그 수정 및 새로운 기능 구현에 영향을 줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n5가지 필수 기능을 통합하여 혼잡한 시장에서 돋보이는 판타지 앱을 만들 수 있습니다. 개념에서 실현까지의 여정은 사용자 경험, 혁신, 안전하고 확장 가능한 개발 프로세스에 집중해야 합니다. 숙련된 판타지 스포츠 소프트웨어 개발 회사와 협력하여 여러분의 비전을 실현하고 점점 확대되는 판타지 앱의 세계를 정복하세요!\n\n데이비드 와이어트\n모바일 앱 개발 전문가\n판타지 스포츠 앱 전문가\nSciflare Technologies\n\n자세한 내용은 아래를 참조해주세요.\nBehance\ndribble","ogImage":{"url":"/assets/img/2024-05-17-5Must-HaveFeaturesforYourFantasyAppin2024_0.png"},"coverImage":"/assets/img/2024-05-17-5Must-HaveFeaturesforYourFantasyAppin2024_0.png","tag":["Tech"],"readingTime":2},{"title":"Android와 iOS 개발을 시작하는 방법","description":"","date":"2024-05-17 03:39","slug":"2024-05-17-AndroidiOSDevTogether","content":"\n\n## 안드로이드와 iOS를 동시에 생각하기\n\n이 시리즈의 기사에서는 안드로이드 및 iOS 개발을 단일한 사고로 살펴봅니다.\n\n## 한 번 언어를 선택하면 나머지는 따라옵니다\n\n핵심: \"→\"는 \"이로 이어진다\"는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n선택: 언어 → 아키텍처 → 패키지 관리자 → 데이터베이스 → 선언적 UI → 개발 환경 → 테스트 → 프레임워크 → 프레임워크 → 저장소\n\nAndroid 및 iOS 개발: 종합적으로 생각하기\n\n![Android iOS Dev](/assets/img/2024-05-17-AndroidiOSDevTogether_0.png)\n\n본 시리즈는 모바일 개발의 세계로 빠져들어, Android 및 iOS 개발을 통합적 관점에서 탐구합니다. 우리는 여러분이 만날 필수적인 결정과 도구들을 안내하여, 두 플랫폼을 위한 모바일 앱 구축에 전략적으로 생각할 수 있도록 도와드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n언어 선택은 중요한 첫 번째 단계입니다만, 그것은 단순히 시작에 불과해요. 연결된 개발 과정을 살펴보며, 각 결정이 그 다음 단계로 이끄는 과정을 보여드릴게요:\n\n- 언어 선택: 코틀린과 스위프트\n- 아키텍처: 객체지향 프로그래밍(OOP)과 프로토콜 지향 프로그래밍(POP) 패러다임\n- 패키지 관리: Gradle / TOML(안드로이드) 및 Swift Package Manager(iOS)\n- 데이터 지속성: RoomDB(안드로이드)와 SwiftData(iOS)\n- 사용자 인터페이스: Material Design 3과 함께 Compose(안드로이드) & Apple HIG와 함께 SwiftUI(iOS)\n- 개발 환경: Android Studio 및 Xcode\n- 테스트: Hilt로 테스트(안드로이드) 및 XCTest(iOS)\n- 앱 기능: 결제, 센서, 피트니스, AR/VR 및 AI/ML을 위한 프레임워크\n- 배포: Google Play Store 및 Apple App Store 항해\n\n최대 효과를 위한 구조화된 학습\n\n<div class=\"content-ad\"></div>\n\n위 글을 Markdown 형식으로 변경하겠습니다.\n\n\nWe’ve divided this series into three comprehensive sections to ensure you gain a well-rounded understanding of mobile development:\n\nSection 1: Foundation\n\n- Languages & Features: Kotlin & Swift, including key features like functions, extensions, concurrency (coroutines/Swift structured concurrency).\n- Architecture Paradigms: Object-Oriented Programming (OOP) and Protocol-Oriented Programming (POP).\n- Package Management: Learn how to manage dependencies for each platform.\n\nSection 2: Building Your App\n\n\n<div class=\"content-ad\"></div>\n\n- 데이터 지속성: RoomDB(Android)와 SwiftData(iOS)와 함께 데이터베이스 세계로 빠져 들어가보세요.\n- 사용자 인터페이스: Compose와 SwiftUI를 사용하여 선언적 UI의 강력함을 탐험해보세요. 상태 관리 및 내비게이션을 포함합니다.\n- 개발 환경: Android Studio 또는 Xcode로 개발 환경을 설정하고 추가 도구 옵션을 탐색해보세요.\n- 프로젝트 구조: 프로젝트를 효과적으로 구성하는 방법을 이해해보세요.\n\n3부: 마무리 및 배포\n\n- 테스트: Hilt Test(Android)와 XCTest(iOS)를 사용하여 앱을 테스트하는 최상의 방법을 배워보세요.\n- 앱 기능성: 지불, 센서, AR/VR, AI/ML과 같은 다양한 영역에서 앱 기능을 강화하는 여러 프레임워크를 탐색해보세요.\n- 배포: Google Play Store와 Apple App Store에 앱을 게시하는 요령을 배워보세요.\n\n이러한 주제에 몰두함으로써, Android와 iOS 모두에 특화된 네이티브 플랫폼 애플리케이션을 구축하기 위한 전체적인 이해력을 갖추게 될 것입니다. 이 시리즈의 다가오는 기사를 기대해주세요! (곧 게시될 예정)\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 위 텍스트를 번역해 드리겠습니다. \n\n\"테이블 태그를 마크다운 형식으로 변경해주세요.\"\n\n도움이 되었으면 좋겠네요! 다른 도움이 필요하시면 언제든지 말씀해주세요. 🌟","ogImage":{"url":"/assets/img/2024-05-17-AndroidiOSDevTogether_0.png"},"coverImage":"/assets/img/2024-05-17-AndroidiOSDevTogether_0.png","tag":["Tech"],"readingTime":3},{"title":"플러터에서 텍스트 스케일링을 적절히 다루는 방법","description":"","date":"2024-05-17 03:37","slug":"2024-05-17-ProperlyhandlingtextscalinginFlutter","content":"\n이 튜토리얼은 가장 쉽고 영향력이 큰 해결책을 먼저 제시하도록 구성되어 있어요. 후속 섹션에는 구현이 어려우면서 전반적인 영향이 더 낮은 해결책들이 포함되어 있지만, 특정 경우에 대응하기 위해 유용해요.\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png)\n\n## 텍스트 스케일링 가능 범위 제한\n\nMaterialApp에 최소 및 최대 스케일 팩터를 설정할 수 있어요. 이렇게 하면 모든 텍스트가 지정한 범위 내에서 스케일링된다는 것을 보장할 수 있어요. 더 빈번한 경계는 가독성과 미적 감각을 유지하는 데 덜 노력이 필요해요. 그러나 경계 선택은 대상 사용자에 따라 달라져야 해요. 예를 들어 노인 사용자를 대상으로 한 앱의 경우, 그들의 요구를 수용하기 위해 더 넓은 범위를 사용하는 것을 고려해야 해요.\n\n<div class=\"content-ad\"></div>\n\n```js\n    MaterialApp(\n      ...\n      builder: (_, child) => MediaQuery(\n        data: MediaQuery.of(context).copyWith(\n          textScaler: MediaQuery.of(context)\n              .textScaler\n              .clamp(minScaleFactor: 0.8, maxScaleFactor: 1.6),\n        ),\n        child: child!,\n      ),\n    );\n```\n\n## 텍스트를 포함하는 요소에 고정 높이를 사용하지 마세요\n\n다음 코드를 살펴보세요:\n\n```js\n          //DON'T\n          SizedBox(\n            height: 100,\n            child: Card(\n              child: Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: [\n                    Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n                    Text(\"Subtitle\", maxLines: 1),\n                  ],\n                ),\n              ),\n            ),\n          ),\n```\n\n<div class=\"content-ad\"></div>\n\n문제가 발생할 수 있습니다.\n\n예상하신 대로, 텍스트 크기를 키우면 SizedBox의 내용이 너무 많은 공간을 차지할 수 있습니다.\n\n![image](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_1.png)\n\n컨텐츠 높이 및 패딩에 기반한 아이템의 높이를 만드는 것이 더 좋습니다. 게다가 ConstrainedBox를 사용하여 최소 높이를 설정할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nConstrainedBox(\n  constraints: const BoxConstraints(minHeight: 100),\n  child: const Card(\n    child: Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n          Text(\"Subtitle\", maxLines: 1),\n        ],\n      ),\n    ),\n  ),\n),\n```\n\n결과적으로 100% 배율에서 동일한 레이아웃을 얻고, 160%에서도 유효한 레이아웃을 얻을 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_2.png\" />\n\nListView에도 동일한 사항이 적용됩니다. itemExtent를 사용하는 경우, 폰트 스케일을 고려하여 계산하거나 prototypeItem을 제공하는 것이 좋습니다. 이에 대해 자세히 설명된 내용은 이 기사에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n계속 진행해 봅시다. 다음 레이아웃을 상상해보세요:\n\n![Image1](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_3.png)\n\n아이템 A는 이전 예시에서 나왔어요. 아이템 B는 약간의 간격을 가지고 있고 텍스트 확대에 대응할 수 있어야해요. 화면 하단에는 충분한 공간이 있어요. 그래서 어떤 문제가 발생할 수 있을까요?\n\n![Image2](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_4.png)\n\n<div class=\"content-ad\"></div>\n\n화면이 작은 폰들도 고려해주세요. 또한, 언어를 바꿀 때 텍스트 길이가 달라질 수 있어요.\n\n## 컨텐츠를 스크롤할 수 있도록 만들기\n\n먼저, 모든 컨텐츠에 접근 가능하도록 오버플로우를 제거해야 해요. 간단한 SingleChildScrollView를 추가하면 이 문제를 해결할 수 있어요.\n\n## 마진과 패딩에 대해 적응적인 값을 사용하는 것을 고려해보세요\n\n<div class=\"content-ad\"></div>\n\n이것은 논란이 될 수 있는 방법일 수 있지만, 자신이 더 큰 글꼴을 사용해야 하는 사용자로 상상해보세요. 사용되지 않는 공간을 많이 보고 싶으신가요 아니면 텍스트를 명확하게 읽고 싶으신가요?\n\n텍스트를 표시하는 논리적 픽셀의 수에 따라 값들을 사용해봅시다. smallScreenThreshold를 응용 프로그램에 가장 적합한 값으로 조절할 수 있습니다.\n\n```js\nclass Dimens {\n  static const smallScreenThreshold = 300;\n  static bool isSmallWidth(BuildContext context) {\n    return MediaQuery.of(context).size.width /\n            MediaQuery.textScalerOf(context).scale(1) <\n        smallScreenThreshold;\n  }\n\n  static double small(BuildContext context) => isSmallWidth(context) ? 4 : 8;\n  static double medium(BuildContext context) => isSmallWidth(context) ? 8 : 16;\n  static double large(BuildContext context) => isSmallWidth(context) ? 16 : 32;\n}\n```\n\n만약 Human Interface Guidelines와 Material Design을 따르고 싶다면, 이 값들은 4로 나눌 수 있는 값이어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 Dimens에 기반하여 간격에 대한 클래스를 만들 수 있습니다:\n\n```js\nclass Insets {\n  static EdgeInsets small(BuildContext context) =>\n      EdgeInsets.all(Dimens.small(context));\n\n  static EdgeInsets medium(BuildContext context) =>\n      EdgeInsets.all(Dimens.medium(context));\n\n  static EdgeInsets large(BuildContext context) =>\n      EdgeInsets.all(Dimens.large(context));\n}\n```\n\n그리고 코드에서 다음과 같이 대체합니다:\n\n```js\n//padding: const EdgeInsets.all(16),\npadding: Insets.medium(context),\n\n//SizedBox(height: 16),\nSizedBox(height: Dimens.medium(context)),\n```\n\n<div class=\"content-ad\"></div>\n\n결과적으로 화면에 텍스트를 그릴 수 있는 공간이 조금 더 확보되었습니다:\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_5.png)\n\n## 제목의 텍스트 크기 확장을 제한하세요\n\n글꼴 크기를 크게 하는 주된 목적은 시력이 약해진 사람들에게 콘텐츠를 가독성 있게 만드는 것입니다. 그러나 제목과 같은 앱의 일부는 이미 글꼴이 크기 때문에 접근성이 좋을 수 있습니다. 이를 해결하기 위해 텍스트가 확대될 수 있는 범위를 제한할 수 있습니다. 이를 달성하는 한 가지 방법은 제목용 사용자 정의 위젯을 만드는 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nclass TitleText extends StatelessWidget {\n  final String text;\n  final TextStyle style;\n\n  const TitleText(this.text, {required this.style, super.key});\n\n  static const double maxRealFontSize = 30;\n\n  @override\n  Widget build(BuildContext context) {\n    if (MediaQuery.textScalerOf(context).scale(style.fontSize!) >\n        maxRealFontSize) {\n      return Text(\n        text,\n        style: style.copyWith(\n          fontSize: maxRealFontSize / MediaQuery.textScalerOf(context).scale(1),\n        ),\n      );\n    }\n    return Text(text, style: style);\n  }\n}\n```\n\n이렇게 하면 가독성을 유지하면서 공간을 더 확보할 수 있어요. 앱에 더 적합한 값으로 maxRealFontSize를 변경할 수 있어요.\n\n<img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_6.png\" />\n\n## 최대 줄 수 및 텍스트 오버플로우 지정하기\n\n<div class=\"content-ad\"></div>\n\n큰 화면에서 일반적인 텍스트 스케일로 보기 좋을 수도 있지만, 다른 조건에서는 수직 공간을 더 많이 차지할 수 있음을 잊지 마세요. 그러나 제목(Subtitle)과 같은 곳은 항상 전체 내용을 표시할 필요가 없습니다. Text 위젯에 maxLines 값을 추가하여 원하는 줄 수로 설정할 수 있습니다.\n\n![Properly handling text scaling in Flutter](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_7.png)\n\n1로 설정된 maxLines로 보기 좋네요. 주요 정보는 여전히 잘 보입니다.\n\n## 문자열의 대안 버전 사용하기\n\n<div class=\"content-ad\"></div>\n\n하지만 항상 유용한 정보를 포함하는 방식으로 문자열을 줄이는 것이 가능한 것은 아닙니다. 게다가, 단어 순서는 다른 언어들에서 다르게 변할 수 있습니다. 영어에서의 첫 번째 단어가 다른 언어에서는 문장의 끝에 올 수도 있습니다. 이번에는 국제화(i18n) 문자열을 고려해보는 것이 중요합니다:\n\n```js\n        \"tasksDone\": {\n            \"one\": \"할 일 중 $completed 개 완료\",\n            \"other\": \"할 일 중 $completed 개 완료\"\n        },\n        \"tasksDoneShort\": {\n            \"one\": \"$completed/$n 작업 완료\",\n            \"other\": \"$completed/$n 작업 완료\"\n        },\n```\n\n가장 의미 있는 부분은 숫자를 나타낸 부분입니다. 더 짧은 버전에서 숫자를 앞에 두고 전체 문자열을 더 짧게 만들었습니다. 코드에서는 다음과 같이 사용할 수 있습니다:\n\n```js\n        Text(\n          Dimens.isSmallWidth(context)\n              ? t.tasksDoneShort(n: 10, completed: 5)\n              : t.tasksDone(n: 10, completed: 5),\n          maxLines: 1,\n        )\n```\n\n<div class=\"content-ad\"></div>\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_8.png)\n\n스크린샷을 보시면, 단축된 버전을 사용하면 필요한 정보를 보여주는 데 도움이 됩니다.\n\n이 기사가 유용하게 느껴졌으면 좋겠네요. 더 유용한 기술을 찾으면 업데이트할 예정입니다. 코드는 이 저장소에서 찾을 수 있습니다.\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_9.png)\n","ogImage":{"url":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png"},"coverImage":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png","tag":["Tech"],"readingTime":7},{"title":"당신의 미래 비밀은 당신의 일상 속에 숨어 있어요","description":"","date":"2024-05-17 03:35","slug":"2024-05-17-TheSecretofYourFutureisHiddeninYourDailyRoutine","content":"\n\n우리의 일상 루틴은 특히 프로그래밍 분야에서 미래에 거대한 영향을 미칩니다. 당신이 경험이 풍부한 코더이건 막 시작한 사람이건, 오늘 형성하는 습관이 내일의 성공을 결정짓습니다. 프로그래머들의 잠재력을 발휘할 수 있는 주목할 가치가 있는 일상 루틴에 대해 알아봅시다.\n\n# 일상 루틴의 중요성\n\n일관성은 모든 기술을 습득하는 데 중요하며, 프로그래밍도 예외는 아닙니다. 매일 일정한 루틴을 정하면 다음과 같은 구조를 만들 수 있습니다:\n\n1. 집중 유지: 꾸준한 습관은 방해요소를 최소화하여 작업에 더 집중할 수 있도록 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n2. 기술 향상: 매일 연습하는 것은 학습을 강화시켜 시간이 흐를수록 복잡한 개념과 기술을 더 쉽게 이해할 수 있게 합니다.\n\n3. 시간 관리: 효율적인 루틴은 일과 학습, 여가를 균형 있게 조절하여 매일을 최대한 효율적으로 활용할 수 있도록 도와줍니다.\n\n4. 스트레스 감소: 예측 가능한 일정은 하루가 엉망이 되는 것을 방지해주어 스트레스를 관리하고 건강한 직장-생활 균형을 유지할 수 있게 도와줍니다.\n\n# 이상적인 일상 루틴 만들기\n\n<div class=\"content-ad\"></div>\n\n## 1. 하루를 시작하는 아침의 루틴\n\n- 일찍 일어나기: 일찍 일어나서 머리가 맑은 상태로 시작하세요. 조용한 시간을 활용하여 계획을 세우고 목표를 정하며 오늘을 위해 정신적으로 준비하세요.\n- 건강한 습관: 신체적 활동이나 건강한 아침 식사로 에너지를 충전하고 집중력을 높이세요.\n- 학습 시간: 코딩 튜토리얼, 기술 블로그 읽기, 일상적인 도전 과제 해결 등 30분을 학습에 할당하여 기민하고 최신 정보를 유지하세요.\n\n## 2. 효율적인 작업 세션\n\n- 명확한 목표 설정: 새로운 기능 개발, 버그 수정 또는 코드베이스 향상과 같은 분명한 목표로 각 작업 세션을 시작하세요.\n- 시간 블록 활용: Pomodoro 기법(25분 집중, 5분 휴식)과 같은 포커스된 시간 블록으로 작업을 나누세요. 이는 생산성을 향상시키고 과로를 예방합니다.\n- 다중 작업 제한: 품질과 효율성을 위해 한 번에 한 가지 작업에 중점을 두세요. 다중 작업은 오류와 생산성 감소로 이어질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. 정기적인 휴식과 신체 활동\n\n- 짧은 휴식: 집중적인 작업 세션이 끝난 후, 5~10분 동안 휴식을 취하세요. 몸과 마음을 회복하기 위해 스트레칭을 하거나 산책을 하거나 건강한 간식을 챙겨 드세요.\n- 긴 휴식: 점심 식사 시간에 30~60분 동안 긴 휴식을 취하세요. 진정한 휴식을 취하여 완전히 기력을 회복하세요.\n\n## 4. 저녁 준비\n\n- 회고와 계획: 하루의 성취를 돌아보고 다음 날을 위해 계획을 세워 조직적이고 동기부여를 유지하세요.\n- 배우고 실험: 개인 프로젝트에 시간을 투자하거나 새로운 기술을 배워 계속해서 참여하고 향상시키세요.\n- 휴식: 독서, TV 시청 또는 가족과 함께 시간을 보내는 등 활동을 통해 완전히 휴식을 취하고 업무와의 연결을 끊으세요.\n\n<div class=\"content-ad\"></div>\n\n# 개발자를 위한 현명한 팁\n\n- 일상적인 작업 자동화: 반복되는 작업을 스크립트와 도구로 자동화해 시간을 절약하고 오류를 줄이며 더 복잡한 작업에 집중할 수 있습니다.\n- 코드 저널 유지: 학습과 문제 해결을 문서화하여 미래 프로젝트에 유용한 참고 자료를 만들고 진행 상황을 추적하여 동기부여를 유발합니다.\n- 정기적인 코드 리뷰: 정기적인 코드 리뷰 일정을 잡아 코드 품질을 향상시키고 이전 실수와 성공으로부터 배우세요.\n- 최신 정보 유지: 최신 프로그래밍 트렌드와 기술에 대해 알기 위해 시간을 할당하세요. 핵심 웹사이트, 블로그, 영향력 있는 인플루언서를 팔로우하여 새로운 발전과 최적의 실천 방법에 대해 정보를 얻으세요.\n\n# 결론\n\n꾸준한 일상적인 루틴을 만들면 미래의 성공에 대한 씨앗을 심는 것과 같습니다. 기억하세요, 위대함은 일상적인 행동에서 비롯되는 것이며 일회성 노력뿐만 아니라 일상적인 행동에서 나옵니다. 오늘부터 시작하여 일상적인 루틴이 위대함으로 이끌어주길 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n당신과 연결하고 싶어요 🙃🙃 !!!!!\n\nLinkedin : [https://www.linkedin.com/in/kushwaharudraksha/](https://www.linkedin.com/in/kushwaharudraksha/)\n\nTwitter : [https://twitter.com/rudraksha_kush](https://twitter.com/rudraksha_kush)","ogImage":{"url":"/assets/img/2024-05-17-TheSecretofYourFutureisHiddeninYourDailyRoutine_0.png"},"coverImage":"/assets/img/2024-05-17-TheSecretofYourFutureisHiddeninYourDailyRoutine_0.png","tag":["Tech"],"readingTime":3},{"title":"JAVA로 안드로이드 개발을 시작하는 방법","description":"","date":"2024-05-17 03:34","slug":"2024-05-17-AComprehensiveGuidetoAndroidDevelopmentwithJava","content":"\n\n안녕하세요! 안드로이드 개발은 기술 산업에서 중심이 되어, 전 세계의 수백만 대의 장치를 구동합니다. 방대한 사용자 기반과 유연성을 갖고 있어 Android 애플리케이션을 개발하는 것은 보람찬 일일 수 있습니다. 안드로이드 개발을 위한 가장 인기 있는 언어 중 하나는 Java입니다. 이 안내서는 Java를 사용하여 Android 개발의 기본 사항을 소개하며 환경 설정부터 첫 번째 앱을 배포하는 과정까지 안내해 드릴 것입니다.\n\n시작하기\n\n준비 사항\n\nAndroid 개발에 도전하기 전에 Java 프로그래밍에 대한 기본적인 이해가 있는지 확인해 주세요. 객체지향 프로그래밍 개념에 익숙하다면 특히 유용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n개발 환경 설정하기\n\nJDK 설치: 공식 오라클 웹사이트에서 Java 개발 키트(JDK)를 다운로드하고 설치하세요. 환경 변수가 올바르게 설정되어 있는지 확인하고 JAVA_HOME이 JDK 설치 디렉토리를 가리키도록 합니다.\n\nAndroid Studio 설치: Android Studio는 안드로이드 개발을 위한 공식 통합 개발 환경(IDE)입니다. Android 개발자 웹사이트에서 다운로드하세요. 설치 프로세스는 간단하며 Android SDK와 앱을 테스트하는 데 사용되는 에뮬레이터가 포함되어 있습니다.\n\nAndroid Studio 구성: 설치 후 Android Studio를 시작하고 설정 마법사를 따라 SDK를 구성하고 가상 디바이스(AVD)를 생성하고 필요한 다른 구성 요소를 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n당신의 첫 번째 Android 앱 만들기\n\n새 프로젝트 생성\n\n새 프로젝트 시작: Android Studio를 열고 \"새 Android Studio 프로젝트 시작\"을 클릭합니다.\n\n프로젝트 구성: 프로젝트 이름, 패키지 이름, 저장 위치를 입력하고 Java 언어를 선택합니다. 지원하고자 하는 최소 API 수준을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n템플릿 선택: 프로젝트 템플릿을 선택하세요. 초보자를 위해서 \"빈 활동(Empty Activity)\" 템플릿을 추천합니다.\n\n프로젝트 구조 이해\n\nAndroid Studio는 기본 프로젝트 구조를 생성합니다. 이는 다음을 포함합니다:\n\n- app: 애플리케이션 코드를 포함하는 주요 디렉토리입니다.\n\n<div class=\"content-ad\"></div>\n\nsrc/main/java: 여러분의 Java 소스 파일입니다.\n\nsrc/main/res: 레이아웃, 이미지, 문자열과 같은 리소스 파일입니다.\n\nAndroidManifest.xml: 여러분의 앱에 대한 중요한 정보를 포함하는 매니페스트 파일입니다.\n\n첫 번째 코드 작성하기\n\n<div class=\"content-ad\"></div>\n\nMainActivity.java: 여기는 앱의 진입점입니다. MainActivity.java를 열면 기본 Activity 클래스가 나타납니다.\n\n```java\npackage com.example.myfirstapp;\n\nimport android.os.Bundle;\n```\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nimport androidx.appcompat.app.AppCompatActivity;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n'\n\n'\n\nactivity_main.xml: 이 레이아웃 파일은 MainActivity의 사용자 인터페이스를 정의합니다. 열기\n\n앱 실행하기\n\n<div class=\"content-ad\"></div>\n\n귀하의 앱이 실제로 작동하는 것을 보려면 Android Studio에서 \"실행\" 버튼을 클릭하세요. 연결된 장치 또는 에뮬레이터를 선택하고 앱이 \"Hello, Android!\"를 표시하면 시작됩니다.\n\n주요 개념 탐색\n\n활동\n\n활동은 사용자 인터페이스가 있는 단일 화면을 나타냅니다. 여기에 UI 코드를 넣고 사용자 상호작용을 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n의도\n\n의도는 구성 요소(활동, 서비스 등)간의 통신에 사용됩니다. 새 활동을 시작하거나 데이터를 보내거나 이벤트를 트리거하는 데 사용할 수 있습니다.\n\n프래그먼트\n\n프래그먼트는 앱 UI의 재사용 가능한 부분을 나타냅니다. 더 모듈식이고 유연한 UI 디자인을 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n레이아웃\n\nAndroid는 화면에 UI 요소를 정렬하기 위해 LinearLayout, RelativeLayout 및 ConstraintLayout과 같은 여러 레이아웃 매니저를 제공합니다.\n\n고급 주제\n\n네트워킹\n\n<div class=\"content-ad\"></div>\n\n네트워크 요청을 만들기 위해 Retrofit 또는 Volley와 같은 라이브러리를 사용하세요. Retrofit은 사용하기 쉽고 강력한 기능으로 인해 특히 인기가 있습니다.\n\n데이터 지속성\n\n로컬 데이터를 저장하기 위해 SQLite, Room 또는 공유 프리퍼런스를 사용하세요. Room은 SQLite 위에 추상화 계층을 제공하여 더 견고한 데이터베이스 액세스가 가능합니다.\n\n백그라운드 작업\n\n<div class=\"content-ad\"></div>\n\n백그라운드 작업을 처리할 때는 AsyncTask, WorkManager 또는 서비스를 사용하세요. 대부분의 경우에는 작업 관리자(WorkManager)를 사용하는 것이 좋습니다. 왜냐하면 WorkManager는 예약 가능하고 비동기적인 작업을 위한 일관된 API를 제공하기 때문입니다.\n\n**결론**\n\nJava로 Android 애플리케이션을 개발하는 것은 수백만 사용자에게 도달하는 모바일 앱을 만드는 강력한 방법입니다. 활동(activities), 인텐트(intents), 프래그먼트(fragments), 레이아웃(layouts)과 같은 핵심 구성 요소를 이해하면 복잡하고 사용자 친화적인 애플리케이션을 구축할 수 있습니다. 더 많은 경험을 쌓으면 네트워킹, 데이터 지속성 및 백그라운드 작업과 같은 고급 주제를 탐색하여 개발 기술을 더욱 향상시킬 수 있을 것입니다. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-17-AComprehensiveGuidetoAndroidDevelopmentwithJava_0.png"},"coverImage":"/assets/img/2024-05-17-AComprehensiveGuidetoAndroidDevelopmentwithJava_0.png","tag":["Tech"],"readingTime":4}],"page":"74","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}