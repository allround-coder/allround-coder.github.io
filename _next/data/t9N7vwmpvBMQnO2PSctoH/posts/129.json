{"pageProps":{"posts":[{"title":"리덕스 툴킷 API들","description":"","date":"2024-05-12 21:47","slug":"2024-05-12-ReduxToolkitAPIs","content":"\n\n<img src=\"/assets/img/2024-05-12-ReduxToolkitAPIs_0.png\" />\n\nRedux Toolkit은 JavaScript 애플리케이션을 위한 인기 있는 상태 관리 라이브러리인 Redux와 함께 작업하는 과정을 간단하게 만들어 주는 일련의 도구와 유틸리티를 제공하는 패키지입니다. Redux Toolkit의 주요 기능 중 하나는 Redux 개발을 간소화하기 위한 여러 함수와 유틸리티를 포함한 내장 API입니다.\n\nRedux Toolkit은 JavaScript 애플리케이션을 위한 인기 있는 상태 관리 라이브러리인 Redux와 함께 작업하는 과정을 간단하게 만들어 주는 일련의 도구와 유틸리티를 제공하는 패키지입니다. Redux Toolkit의 주요 기능 중 하나는 Redux 개발을 간소화하기 위한 여러 함수와 유틸리티를 포함한 내장 API입니다.\n\nRedux Toolkit API에 대한 개요는 아래와 같습니다:\n\n\n\n- createSlice: 이 유틸리티 함수를 사용하면 Redux 슬라이스를 정의할 수 있어요. 슬라이스는 응용 프로그램 상태의 특정 부분을 관리하기 위한 리듀서 로직 모음입니다. 제공하는 리듀서 로직에 기반하여 자동으로 액션 생성자와 액션 유형을 생성하여 보일러플레이트 코드를 줄여줘요.\n- configureStore: 이 함수는 Redux DevTools Extension을 지원하는 합리적인 기본값을 갖춘 Redux 스토어를 만드는 데 사용돼요. 여러 구성 단계를 단일 함수 호출로 결합하여 Redux 스토어를 설정하는 과정을 단순화시켜줘요.\n- createAsyncThunk: 이 유틸리티 함수는 Redux에서 비동기 로직을 처리하는 과정을 간단하게 해주는데, API에서 데이터를 가져오는 비동기 작업의 상태에 따라 자동으로 보류 중, 성공 및 거부된 액션을 디스패치하는 액션 생성자를 생성합니다.\n- createEntityAdapter: 이 유틸리티 함수는 Redux에서 정규화된 엔티티 상태를 관리하기 위한 리듀서 함수와 셀렉터 집합을 생성해줘요. Redux에서 관계형 데이터 구조를 다루기 쉽도록 데이터를 정규화된 형식으로 조직화하고 관리하는데 도움이 돼요.\n- createReducer: 이 유틸리티 함수를 사용하면 createSlice에서 사용하는 방식과 유사하게 액션 유형의 맵을 기반으로 리듀서 로직을 정의할 수 있어요. 슬라이스 외부에서 리듀서 로직을 더 유연하게 정의해야 하는 경우에 유용해요.\n\n전반적으로 Redux Toolkit API는 Redux를 사용하는 일반적인 경우를 단순화하고, 보일러플레이트 코드를 줄이며, Redux 작업을 위한 직관적이고 견해 있는 도구 세트를 제공하여 개발자 생산성을 향상시킵니다.\n\n# Redux 데이터 과부하 문제를 어떻게 처리하나요?\n\nRedux Toolkit은 직접적으로 데이터 과부하 문제를 처리하지는 않지만, 이를 완화할 수 있는 도구와 패턴을 제공해요:\n\n\n\n- 정규화된 상태 관리: Redux Toolkit은 createEntityAdapter와 같은 유틸리티를 사용하여 정규화된 상태 관리를 권장합니다. 데이터 구조를 정규화함으로써 데이터 오버로드를 방지할 수 있으며, 데이터를 구조화된 방식으로 조직화하여 관리 및 업데이트하기 쉽게 만들어줍니다.\n- 선택적 데이터 로딩: createAsyncThunk를 사용하면 게으른 로딩 또는 페이지네이션과 같은 선택적 데이터 로딩 기술을 구현하여 필요한 데이터만 필요할 때만 로드할 수 있습니다. 이는 Redux 저장소에 저장된 데이터 양을 줄이고 성능을 향상시킬 수 있습니다.\n- 메모화: Redux Toolkit은 메모화를 직접 처리하지는 않지만, Reselect와 같은 메모화 라이브러리를 Redux Toolkit과 함께 사용하여 선택자를 최적화하고 데이터 오버로드로 인한 불필요한 다시 렌더링을 방지할 수 있습니다.\n- 미들웨어와 쓰로틀링: Redux 미들웨어를 사용하여 데이터 오버로드를 유발할 수 있는 작업에 대한 쓰로틀링이나 디바운싱 기술을 구현할 수 있습니다. 쓰로틀링은 액션이 디스패치되는 속도를 제어하여 Redux 저장소에 과도한 업데이트를 방지하는 데 도움이 될 수 있습니다.\n- 선택적 상태 슬라이싱: 전체 상태 객체에 액세스하는 대신 선택자를 사용하여 상태 트리의 필요한 부분만 검색할 수 있습니다. 이는 성능을 향상시키고 특히 대량 데이터 처리 시 메모리 사용량을 줄일 수 있습니다.\n\nRedux Toolkit은 Redux 상태를 관리하기 위한 유용한 도구와 패턴을 제공하지만 데이터 오버로드 문제를 피하기 위해 응용 프로그램의 상태 관리 전략을 신중하게 설계하는 것이 중요합니다. 특정 사용 사례에 적합한 정규화, 선택적 데이터 로딩, 메모화 및 기타 성능 최적화 기술을 조합하여 사용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-ReduxToolkitAPIs_0.png"},"coverImage":"/assets/img/2024-05-12-ReduxToolkitAPIs_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 컨텍스트의 최상의 사용 방법","description":"","date":"2024-05-12 21:46","slug":"2024-05-12-ReactContextBestPractices","content":"\n\n리액트 프레임워크는 효율성과 유연성으로 유명하며, 개발자들이 견고하고 확장 가능한 웹 애플리케이션을 만들 수 있도록 다양한 기능을 제공합니다. 이러한 기능 중에서 리액트 컨텍스트 API는 상태를 관리하고 데이터를 구성 요소 트리 전체로 전달할 수 있는 주요 도구로, 프롭 드릴링이 필요 없이 개발자들이 상태를 효과적으로 관리할 수 있게 해줍니다. 이는 애플리케이션 내 여러 구성 요소에서 필요로 하는 \"전역\" 데이터를 처리하는 데 매우 유용합니다. 예를 들어 사용자 인증, 테마 또는 선호하는 언어와 같은 데이터가 있습니다.\n\n그러나 컨텍스트 API는 강력하지만, 의도하지 않은 다시 렌더링을 방지하고 애플리케이션의 성능을 유지하기 위해 신중한 접근이 필요합니다. 이 블로그 글은 리액트 컨텍스트 API를 사용하는 데 최선의 방법에 대해 탐구하며, 애플리케이션이 효율적으로 유지되고 코드가 유지보수 가능하도록 하는 것을 목표로 합니다.\n\n다음 섹션에서는 컨텍스트 API에 대해 자세히 살펴보고, 언제 컨텍스트를 사용해야 하는지 강조하고, 리액트 애플리케이션에서 컨텍스트를 구현하기 위한 여러 가이드라인을 논의할 것입니다. 리액트에 익숙하지 않거나 상태 관리에 대한 지식을 향상시키고 싶다면, 이 글은 유용한 통찰과 지침을 제공할 것입니다.\n\n![React Context Best Practices](/assets/img/2024-05-12-ReactContextBestPractices_0.png)\n\n\n\n# React Context의 기본 이해\n\nReact Context는 React 16.3에서 소개된 기능으로, 데이터를 props를 통해 전달하지 않고 컴포넌트 간에 공유할 수 있도록 해줍니다. Context API는 \"prop drilling\" 문제를 해결하는 데 도움이 됩니다. \"prop drilling\"은 데이터를 최상위 컴포넌트에서 하위 컴포넌트로 전달하는 과정을 말합니다. Context를 사용하면 어디에 있든지 컴포넌트에 상태를 직접 제공할 수 있습니다.\n\n먼저, React Context는 React.createContext()를 사용하여 생성됩니다. 이 함수는 Provider와 Consumer를 포함한 객체를 반환합니다.\n\n```js\nconst MyContext = React.createContext(defaultValue);\n```\n\n\n\nProvider 컴포넌트는 트리 상위에서 사용되며 value 프롭을 받습니다. 이 값은 문자열, 객체, 함수 등 아무 것이나 될 수 있습니다.\n\n```js\n<MyContext.Provider value={/* 어떤 값 */}>\n```\n\nContext에 저장된 데이터에 필요한 모든 컴포넌트는 Consumer 컴포넌트를 통해 액세스할 수 있습니다. Consumer는 렌더 프롭 API를 사용합니다. 즉, 함수를 자식으로 취하는 것을 의미합니다. 이 함수는 컨텍스트 값 받아들이고 React 노드를 반환합니다.\n\n```js\n<MyContext.Consumer>\n  {value => /* 컨택스트 값에 기반하여 렌더링할 내용 */}\n</MyContext.Consumer>\n```\n\n\n\n대신에 함수 컴포넌트 내에서 컨텍스트에 액세스하려면 useContext 훅을 사용할 수 있습니다.\n\n```js\nconst value = useContext(MyContext);\n```\n\n중요한 점은 React가 이 컨텍스트 객체에 구독하는 컴포넌트를 렌더링할 때, 가장 가까운 일치하는 Provider에서 현재 컨텍스트 값을 읽을 것이라는 것입니다.\n\n컨텍스트 API는 모든 상태 또는 prop 상호작용을 대체하기 위한 것이 아닙니다. 컴포넌트 트리에서 \"전역\"으로 간주될 수 있는 데이터를 공유하기 위해 설계되었습니다. 예를 들어 현재 인증된 사용자, 테마 또는 언어 설정과 같은 것입니다.\n\n\n\nMobX React Context의 기본 사항을 이해하는 것은 더 고급 사용법과 모벡스 사이의 상호작용 및 최적의 방법에 뛰어들기 전에 중요합니다. 이는 훅과 같은 다른 기능들과 어떻게 통합하고, 불필요한 렌더링과 다른 성능 문제를 방지하기 위해 컨텍스트를 어떻게 적절히 구성하는지를 배우는 것을 포함합니다.\n\n# React Context 사용의 최상의 방법\n\n- Context를 절약하게 사용하세요: 컨텍스트 API는 강력한 도구이지만 상태 관리의 해결책으로 쓰기에는 적합하지 않습니다. 필요할 때만 사용하고 지나치게 사용하면 불필요한 다시 렌더링을 유발하고 성능에 부정적인 영향을 미칠 수 있습니다.\n- 복잡한 상태에 useReducer와 함께 컨텍스트 사용하기: useReducer 훅은 여러 하위 값이 관련된 복잡한 상태 로직을 관리하는 데 선호되는 선택지입니다. 컨텍스트와 함께 사용하면 컴포넌트의 복잡한 로컬 상태를 reducer 함수로 관리할 수 있어 상태 관리에 이상적입니다.\n- 관심사 분리를 위해 여러 컨텍스트 사용하기: 하나의 큰 컨텍스트 대신 여러 작은 컨텍스트로 분리하는 것이 좋습니다. 이렇게 하면 구독하는 데이터가 변경될 때만 컴포넌트가 다시 렌더링되므로 불필요한 다시 렌더링을 방지할 수 있습니다.\n- Prop Drilling 피하기: 컨텍스트는 트리를 통해 수동으로 prop을 전달하는 것 대신 사용할 수 있는 대안입니다. 중첩된 컴포넌트를 통해 prop을 전달하게 되면 Context를 도입할 때인지 검토해야 합니다.\n- 컨텍스트를 테스트하세요: 애플리케이션의 다른 부분과 마찬가지로 컨텍스트도 예상대로 동작하는지 확인하기 위해 테스트해야 합니다. React의 ReactTestRenderer.create와 enzyme의 shallow 및 mount 메서드를 사용하여 컨텍스트 소비자와 제공자를 테스트할 수 있습니다.\n- 컨텍스트 제공자 안에 컴포넌트 래핑하기: 컴포넌트를 컨텍스트 제공자 내에 래핑하도록 해주세요. 제공자 내에 있는 컴포넌트만 컨텍스트에 액세스할 수 있습니다.\n- 기본 값을 사용하세요: 기본 값은 컴포넌트를 감싸지 않고 독립적으로 테스트하는 데 유용할 수 있습니다. 컴포넌트 주변에 일치하는 제공자가 없을 때 컨텍스트는 기본 값을 사용할 것입니다.\n\n이러한 최상의 방법을 따르면 일반적인 함정을 피하고 성능을 향상시키며 애플리케이션의 상태 관리를 효율적이고 유지보수 가능하게 할 수 있습니다. 또한 useReducer와 Context의 강력한 조합을 통합하여 복잡한 상태 로직을 쉽고 정확하게 관리할 수 있습니다.\n\n\n\n![React Context Best Practices](/assets/img/2024-05-12-ReactContextBestPractices_1.png)\n\n# 결론\n\n요약하면, React Context API는 상태(state)와 속성(props)을 쉽게 관리할 수 있는 강력한 기능으로, 애플리케이션을 간소화하고 성능을 향상시킬 수 있습니다. React Context에 대한 최상의 사용 사례를 따르면, 이 기능을 최대한 활용하여 prop 전달을 줄이고 코드를 더 읽기 쉽고 유지보수하기 쉽게 만들 수 있습니다.\n\n올바르게 활용하면, React Context는 매끄럽고 매력적인 사용자 경험을 만들어줍니다. 전역 상태 처리부터 테마 또는 다국어 지원까지, 애플리케이션에서 Context를 활용할 수 있는 가능성은 매우 많습니다. 그러나 Context는 애플리케이션에서 모든 상태 관리를 대체해서는 안 되며, 대신 구성 요소 간에 액세스해야 하는 전역 상태를 전략적으로 사용해야 합니다.\n\n\n\nReact Context를 사용하는 것을 탐험할 때, Context의 구조와 조직을 고려하는 것이 중요하며 불필요한 다시 렌더링을 피하고 다른 기능과 함께 Context를 결합하여 최대 이점을 얻을 수 있습니다.\n\nReactjs 개발자를 고용하려면 CronJ IT Technologies를 고려해보세요. 그들의 팀은 React를 활용한 경험이 풍부하며 복잡한 애플리케이션에서 React Context의 강력함을 발휘한 경험이 있습니다. React 여정을 시작하거나 기존 애플리케이션을 개선하려는 경우, CronJ가 필요한 전문 지식과 지원을 제공할 수 있습니다.\n\n# 참고 자료\n\n- https://reactjs.org/docs/context.html\n- 자바스크립트에서 푸시 알림: 포괄적 가이드 | Olga Green | 2023년 6월 | Medium\n- 상태 관리를 위한 React Context API","ogImage":{"url":"/assets/img/2024-05-12-ReactContextBestPractices_0.png"},"coverImage":"/assets/img/2024-05-12-ReactContextBestPractices_0.png","tag":["Tech"],"readingTime":5},{"title":"React Div 대신에 React Fragments를 사용해야 하는 이유","description":"","date":"2024-05-12 21:45","slug":"2024-05-12-WhyYouShouldUseReactFragmentsInsteadofDivs","content":"\n\n![이미지](/assets/img/2024-05-12-WhyYouShouldUseReactFragmentsInsteadofDivs_0.png)\n\n프론트엔드 개발의 세계에서는 모든 코드 라인이 중요합니다. 웹 애플리케이션이 더 복잡해지면서 성능 최적화와 가독성 있는 깨끗한 코드 유지가 중요해집니다. React 개발자가 가진 덜 알려진 도구 중 하나인 React 프래그먼트는 이러한 고민을 해소해줍니다. 이 글에서는 프로젝트에 React 프래그먼트를 사용하는 것이 어떻게 게임 체인저가 될 수 있는지 살펴보겠습니다.\n\nReact 프래그먼트란 무엇인가요?\nReact 16.2에서 소개된 React 프래그먼트는 DOM에 추가적인 노드를 생성하지 않고 여러 개의 React 엘리먼트를 그룹화하는 방법을 제공합니다. div나 다른 컨테이너 엘리먼트와 달리 프래그먼트는 추가적인 DOM 레이어를 도입하지 않고 엘리먼트를 그룹화할 수 있습니다.\n\n성능 최적화\nReact 프래그먼트를 div 대신 선택하는 핵심 이유 중 하나는 성능 최적화입니다. div를 사용하여 엘리먼트 목록을 렌더링할 때 각 div는 DOM 트리에 새로운 노드를 추가합니다. 특히 긴 목록이나 깊게 중첩된 컴포넌트를 다룰 때 불필요한 비대가 될 수 있습니다.\n반면에 React 프래그먼트는 새로운 DOM 노드를 만들지 않습니다. 대신, DOM 계층 구조에 추가적인 레이어를 도입하지 않고 엘리먼트를 그룹화할 수 있습니다. 이는 보다 빠른 렌더링 시간과 보다 간결한 DOM 구조를 가져와서 궁극적으로 응용 프로그램의 성능을 향상시킬 수 있습니다.\n\n\n\n친절한 톤으로 번역해드리겠습니다.\n\n더 깨끗한 마크업\n성능 이점을 넘어서 React Fragments를 사용하면 더 깨끗한 마크업을 얻을 수 있습니다. 아이템 목록을 부모 div로 감싸지 않고 렌더링하고 싶은 시나리오를 생각해보세요. 이때 div를 사용하면 HTML에 불필요한 래퍼 엘리먼트가 도입되어 마크업이 복잡해지고 가독성이 떨어지게 됩니다.\nReact Fragments는 추가적인 노드를 DOM에 추가하지 않고도 엘리먼트를 그룹화할 수 있어 이 문제를 우아하게 해결합니다. 이를 통해 JSX 마크업을 깔끔하고 간결하게 유지하면서도 필요한 엘리먼트에만 집중할 수 있죠, 부가적인 래퍼에 신경 쓸 필요가 없습니다.\n\n향상된 접근성\n접근성은 React Fragments가 빛을 발하는 또 다른 영역입니다. div나 다른 컨테이너 엘리먼트를 사용할 때, 스크린 리더가 이러한 엘리먼트의 존재를 알리고 시각 장애를 가진 사용자들을 혼란스럽게 할 수 있습니다. React Fragments를 사용하면 추가적인 노드를 생성하지 않아 스크린 리더에는 보이지 않으므로 UI가 더 접근성 있게 되는 장점이 있습니다.\n\n결론\n요약하면, React Fragments는 React 애플리케이션에서 엘리먼트를 그룹화하는 가벼운 효율적인 방법을 제공합니다. 불필요한 DOM 노드를 피하면서 성능 향상, 깨끗한 마크업, 그리고 높은 접근성을 얻을 수 있습니다. 다음에 엘리먼트를 감싸기 위해 div를 사용하려 할 때는 React Fragment를 대신 활용해보고 직접 이점을 경험해보세요.","ogImage":{"url":"/assets/img/2024-05-12-WhyYouShouldUseReactFragmentsInsteadofDivs_0.png"},"coverImage":"/assets/img/2024-05-12-WhyYouShouldUseReactFragmentsInsteadofDivs_0.png","tag":["Tech"],"readingTime":2},{"title":"스크롤이 맨 아래로 도착했는지 감지하기","description":"","date":"2024-05-12 21:44","slug":"2024-05-12-Detectscrollreachesthebottom","content":"\n\n안녕하세요, 오늘은 사용자가 페이지 맨 아래로 스크롤할 때 감지하는 방법을 알려 드리겠습니다.\n\n코딩에 들어가기 전에 계산에 필요한 몇 가지 중요한 정보를 이해하는 것이 중요합니다:\n\n- window.innerHeight: 보이는 콘텐츠의 높이입니다.\n- document.body.scrollHeight: 보이는 부분과 숨겨진 부분을 모두 포함한 전체 콘텐츠의 총 높이입니다.\n- window.scrollY: 사용자가 스크롤한 위치를 나타냅니다.\n\n명확히 이해하기 위해 예제를 드리겠습니다:\n\n\n\n먼저, NextJS와 TypeScript를 사용하여 소스 코드를 초기화하고, 익숙한 다른 프레임워크를 사용할 수도 있어요.\n\n다음으로 각각 높이가 500px인 `div`를 3개 추가할 거에요.\n\n<img src=\"/assets/img/2024-05-12-Detectscrollreachesthebottom_0.png\" />\n\n이렇게 하면 전체 콘텐츠의 높이가 1500px가 됩니다.\n\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*Qocsql64DWbgFLXBqug2SA.gif)\n\n윈도우 높이를 500px로 조정하면 다음과 같이 됩니다:\n\n![이미지](/assets/img/2024-05-12-Detectscrollreachesthebottom_1.png)\n\ninnerHeight는 빨간색 상자 영역이고, outerHeight에는 주소 표시줄과 탭 표시줄이 포함됩니다.\n\n\n\n좋아요, 이제 document.body.scrollHeight와 window.innerHeight를 확인할 거예요.\n\n그럼 이제 scrollY를 확인해볼게요.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*tSttaLTndCd9JLMhdbz29A.gif)\n\n동영상을 보시면 알 수 있지만, 페이지에 처음 접속했을 때 scrollY 값은 0일 거에요. 왜냐하면 아직 스크롤하지 않았기 때문이죠. 그런 다음 페이지를 스크롤하기 시작하면, 스크롤한 거리에 따라 scrollY 값이 적절하게 변경될 거에요.\n\n\n\n그리고 페이지를 맨 아래로 스크롤하면 scrollY = scrollHeight - innerHeight가 됩니다.\n\n아래는 해당하는 공식입니다.\n\n```js\nconst scrolledTo = window.scrollY + window.innerHeight\nconst isReachBottom = document.body.scrollHeight === scrolledTo\n```\n\n이제 한번 시도해 봅시다!\n\n\n\n```js\nuseEffect(() => {\n    const onscroll = () => {\n        const scrolledTo = window.scrollY + window.innerHeight;\n        const isReachBottom = document.body.scrollHeight === scrolledTo;\n        if (isReachBottom) alert(\"맨 아래에 도달했습니다!\");\n    };\n    window.addEventListener(\"scroll\", onscroll);\n    return () => {\n        window.removeEventListener(\"scroll\", onscroll);\n    };\n}, []);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*Vv4q8HBbBSC6n32NRV97cQ.gif\" />\n\n좋아요! 작동합니다!\n\n하지만 무한 스크롤을 위해 직장에서 사용하면 좋은 방법은 아닙니다. 스크롤이 맨 아래에 도달할 때까지 API를 호출하는 것은 좋지 않습니다. 이렇게 하면 사용자 경험이 나빠집니다. 대신, 스크롤이 맨 아래에서 일정 거리(예: 맨 아래에서 300px)를 벗어나면 API 호출을 트리거하고 새 콘텐츠가 로드되어 문서에 추가됩니다. 이렇게 하면 사용자가 기다리는 시간이 줄어듭니다.\n\n\n\n\n위의 공식은 다음과 같습니다:\n\n```js\nconst scrolledTo = window.scrollY + window.innerHeight\nconst threshold = 300\nconst isReachBottom = document.body.scrollHeight - threshold === scrolledTo\n```\n\n잘 보이지만 여기 작은 문제가 있어요. 사용하는 것이 있습니다. 동등성 연산자 ===을 사용하면 scrollY가 사용자가 스크롤할 때마다 1픽셀씩 증가하지 않기 때문에 isReachBottom이 여러 번 false가 될 가능성이 높습니다. 사용자가 얼마나 빨리 스크롤하는지에 따라 달라집니다.\n\n이 문제를 해결하려면 `(=`를 사용하면 됩니다:\n\n\n\n```js\nconst isReachBottom = document.body.scrollHeight - threshold <= scrolledTo\n```\n\n좋아요, 새로운 것을 테스트해볼까요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*d6GdJZpt4RNPfe-03diBfQ.gif)\n\n좋아요, 성공했어요!\n\n\n\n이제 스크롤이 맨 아래에 도달하는 방법을 배웠어요!\n\n데모 코드는 여기에서 확인할 수 있어요: [https://github.com/alanng2050/medium-demo-scroll-to-bottom](https://github.com/alanng2050/medium-demo-scroll-to-bottom)\n\n읽어 주셔서 감사합니다!\n\n즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-Detectscrollreachesthebottom_0.png"},"coverImage":"/assets/img/2024-05-12-Detectscrollreachesthebottom_0.png","tag":["Tech"],"readingTime":3},{"title":"Next Js 13 프로젝트에서 Redux Tool Kit을 구성해 보세요","description":"","date":"2024-05-12 21:42","slug":"2024-05-12-ConfigureReduxToolKitinNextJs13project","content":"\n\n<img src=\"/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_0.png\" />\n\n안녕하세요! 이 글에서는 Next Js 13 프로젝트에 Redux Tool kit (RTK)을 설정하는 단계별 프로세스를 안내해 드리겠습니다. Redux Tool kit은 React/Next Js 애플리케이션에서 상태를 전역적으로 관리하는 데 도움이 되는 도구 세트입니다. Next Js 13의 릴리스 이후로, Redux Tool kit을 Next 13 앱에 통합하는 데 도움이 되는 문서가 부족합니다. 이 글이 여러분이 읽으면서 기대하는 만족도를 높여드릴 것을 희망합니다.\n\n프로젝트 설정 및 설치\n\n이미 Next 13 프로젝트를 설정했고 상태를 관리하기 위해 redux tool kit을 통합할 준비가 되어 있다고 가정합니다. 만약 제 가정이 틀렸다면, 항상 그런 경우이니까 Next js를 설치하는 방법은 여기를 참조하세요.\n\n\n\nRedux 도구 킷을 앱에 통합하기 위해 먼저 필요한 라이브러리를 설치해야 합니다.\n\n```js\n// Redux 도구 킷과 리액트 리덕스 설치\nnpm install @reduxjs/toolkit react-redux\n```\n\nRedux 도구 킷과 리액트 리덕스는 앱을 실행시키고 전역 상태를 관리할 준비를 완료하는 데 필요한 라이브러리입니다.\n\n그다음, Next 앱 프로젝트 구조를 설정해야 합니다. src/app 폴더 안에 GlobalRedux라는 새 폴더를 만들고, GlobalRedux 폴더 안에 store.js와 provider.js라는 두 파일을 만들어야 합니다. 또한, 슬라이스에 관련된 모든 파일을 담을 Features라는 폴더를 생성해야 합니다. 간단하고 최소한의 구조를 유지하기 위해 하나의 슬라이스만 생성하겠습니다. 그것을 counterSlice.js라고 이름 짓겠습니다. JavaScript 파일에 확장자로 .jsx 또는 .js 중 하나를 선택할 수 있습니다. 이제 프로젝트 구조는 다음과 같아야 합니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_1.png\" />\n\n## 슬라이스 구성\n\n슬라이스란 당신의 앱에서 하나의 기능에 대한 Redux 리듀서 로직과 액션들의 모음을 나타냅니다. 일반적으로 한 파일에 정의되어 있습니다. 코드를 자세히 살펴보기 전에 중요한 점을 알려드릴게요. 모든 파일은 클라이언트 측 컴포넌트입니다. 파일의 맨 위에 'use client'를 추가해야 합니다. 이제 방금 만든 각 파일에 코드를 추가해 보겠습니다. 먼저 counterSlice.jsx 파일을 구성해야 합니다. 이 파일은 컴포넌트의 상태를 변경하기 위해 실행해야 하는 코드를 가져옵니다.\n\n```js\n//counterSlice.jsx\n\n\"use client\"; // 이것은 클라이언트 측 컴포넌트입니다.\n\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst initialState = {\n  value: 0,\n};\n\nexport const counterSlice = createSlice({\n  name: \"counter\",\n  initialState,\n  reducers: {\n    increment: (state) => {\n      state.value += 1;\n    },\n    decrement: (state) => {\n      state.value -= 1;\n    },\n    incrementByAmount: (state, action) => {\n      state.value += action.payload;\n    },\n  },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\n\nexport default counterSlice.reducer;\n```\n\n\n\n위 파일에서는 카운터 버튼을 증가 및 감소하는 논리를 간단히 작성하고 있습니다.\n\n## 저장소 설정\n\n이제 Redux-tool-kit 저장소를 설정해 봅시다. Redux 저장소는 애플리케이션의 모든 상태를 저장하는 중심적인 버킷입니다. 애플리케이션 상태에 대한 단일 진실의 원천으로 고려되고 유지되어야 합니다.\n\n```js\n//store.jsx\n\n\"use client\";\nimport { combineReducers, configureStore } from \"@reduxjs/toolkit\";\nimport counterReducer from \"./Features/Counter/counterSlice\";\n\n\nconst rootReducer = combineReducers({\n  counter: counterReducer,\n  // 여기에 모든 리듀서를 추가하세요\n}, );\n\nexport const store = configureStore({\n  reducer: rootReducer,\n});\n```\n\n\n\n저희 store.js가 작동 중이니, 앱에 상태 변화가 전역 변수로 캡처되도록 스토어를 제공해야 합니다. 이것이 대부분의 자습서에서 빠뜨리는 가장 중요한 부분이에요.\n\n## 사용자 지정 프로바이더 구성\n\nNext.js와 Redux 툴킷을 설정할 때, provider.js라는 별도의 파일을 만들어야 합니다. `Provider` 컴포넌트는 Redux 스토어를 Redux 스토어에 액세스해야 하는 중첩된 모든 컴포넌트에 사용할 수 있게 합니다. provider.js 파일을 설정해봅시다.\n\n```js\n//provider.js\n\"use client\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./store\";\n\nexport function Providers({ children }) {\n  return <Provider store={store}>{children}</Provider>;\n}\n```\n\n\n\n대부분의 리액트 앱에서 제공 엘리먼트를 직접적으로 Next 애플리케이션의 루트에 감싸지 않는다는 점에 주목하게 될 거예요. 대신 여러분이 만든 별도의 제공자 컴포넌트인 Providers를 생성하고, 이를 애플리케이션의 루트를 감싸기 위해 내보낼 거예요. 이는 이번 경우인 메인 레이아웃인 layout.jsx 파일이 서버 측 렌더링된 컴포넌트이지만, Next.js 제공자 컴포넌트는 클라이언트 측으로 렌더링되어야 하기 때문이에요. 만약 여러분이 이 규칙을 어긴다면 버그가 발생할 수 있으니 참고하세요. 앱을 직접적으로 제공자로 감싸는 것이 아니라 적용하는 것을 시도해보면 문제점을 보실 수 있을 거예요.\n\n## 앱 루트를 제공자로 감싸기\n\n마지막으로, 방금 만든 사용자 지정 제공자 컴포넌트로 앱을 감싸야 합니다. 이 단계도 주의깊게 살펴주세요. 리액트 애플리케이션과 달리, Next.js 13에는 app.js라는 특별한 루트 앱이 없는데요. 그래서 Next 13 앱의 주요 시작점은 여러분의 layout.js 파일입니다. 우리가 만든 사용자 지정 제공자를 가져와서 layout.jsx 파일의 자식 요소들을 감싸게 될 거에요. layout.js 파일의 자식 요소들은 여러분의 앱의 모든 페이지들이라는 뜻이에요. 이제 앱의 모든 상태를 하나의 저장소에서 관리하고 있습니다.\n\n```js\n//layout.js\nimport { Providers } from \"./GlobalRedux/provider\";\nimport \"./globals.css\";\nimport styles from \"./page.module.css\";\n\nexport const metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\nconst RootLayout = ({ children }) => {\n  return (\n    <html lang=\"en\">\n      <head className={styles.header}></head>\n      <body>\n        {/* 사용자 지정 제공자 컴포넌트를 가져오세요 */}\n        <Providers>{children}</Providers>\n      </body>\n    </html>\n  );\n};\nexport default RootLayout;\n```\n\n\n\n지금까지 계속 참고해 왔다면, 멋진 일을 했어요. 이제 커피 한 잔을 마실 시간이에요.\n\n마지막 단계가 하나 남았어요. 우리 앱에 저장된 상태에 접근하고 만든 컴포넌트 내에서 사용해야 해요. 이를 위해 useDispatch와 selector 훅을 사용할 거에요. react-redux에서 useDispatch 훅은 우리에게 스토어의 디스패치 메소드에 액세스할 수 있게 해줘요. 디스패치는 우리가 리덕스 스토어로 액션을 보내는 데 사용되며 컴포넌트 내에서 스토어에 영향을 주는 유일한 방법이에요. \"선택자 함수\"는 리덕스 스토어 상태(또는 상태의 일부)를 인수로 받고 그 상태에 기반한 데이터를 반환하는 어떠한 함수라고 할 수 있어요. 말이 많아졌네요, 이제 useDispatch와 selector가 어떻게 사용되어 앱 상태에 액세스할 수 있는지 보겠습니다.\n\n```js\n//page.jsx\n\n//기본적으로, 이는 저장된 상태에 액세스하거나 컴포넌트 상태로 스토어를 업데이트하는 방법입니다.\n\n\"use client\";\n\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { increment, decrement } from \"./GlobalRedux/Features/counter/counterSlice\";\n\n\nexport default function Home() {\n//useSelector를 통해 스토어로부터 상태 가져오기\n  const count = useSelector((state) => state.counter.value); // 카운터 상태에 액세스\n\n//useDispatch는 컴포넌트에서 스토어를 상태로 업데이트하는 데 사용되며, counterslice.js 내에서 정의된 로직에 따라 정의됩니다\n  const dispatch = useDispatch();\n\n  return (\n    <div>\n      <h1>Counter: {count}</h1> {/* 카운터 상태 표시 */}\n      <button onClick={() => dispatch(increment())}>증가</button>\n      <button onClick={() => dispatch(decrement())}>감소</button>\n    </div>\n  );\n}\n```\n\n위 파일에서 우리는 간단히 컴포넌트 내에서 스토어 상태의 값을 가져오고 싶었어요. page.jsx 파일에서 카운터를 생성하고 감소 또는 증가하는 두 개의 버튼을 만들었어요. useSelector 메소드를 사용하여 스토어의 카운터 값에 액세스할 수 있었죠. 사용자가 증가 또는 감소 버튼을 클릭했을 때 우리의 스토어를 업데이트하기 위해, useDispatch 메소드를 실행하여 컨터스라이스.jsx에 정의된 로직을 실행해요. 이 경우에는 간단히 스토어에서 카운터 값을 증가/감소시키는 로직이었습니다.\n\n\n\n## 결론\n\n끝까지 참고해 주셔서 축하드립니다. 다음 JS 13 앱에 Redux 툴킷을 설정할 수 있었으면 좋겠네요. 이 글이 마음에 드셨다면 좋아요를 눌러주세요.","ogImage":{"url":"/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_0.png"},"coverImage":"/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 모달 컴포넌트에서 포커스 트래핑 구현하기","description":"","date":"2024-05-12 21:41","slug":"2024-05-12-AchievingFocusTrappinginaReactModalComponent","content":"\n<img src=\"/assets/img/2024-05-12-AchievingFocusTrappinginaReactModalComponent_0.png\" />\n\n포커스 포획은 웹 개발에서 필수적인 기술로, 모달이나 대화 상자와 같은 특정 영역 내에서 키보드 포커스가 유지되어 사용자에 대한 접근성과 사용 편의성을 향상시킵니다. 이 글에서는 외부 라이브러리에 의존하지 않고 사용자 정의 React 모달 구성 요소에서 포커스 포획을 구현하는 방법을 살펴보겠습니다.\n\n# 포커스 포획 이해하기\n\nReact에서 모달 구성 요소를 설계하는 과정에는 여러 가지 고려 사항이 포함됩니다. 이러한 고려 사항 중 하나는 적절한 포커스 관리를 보장하는 것입니다. 포커스 포획은 이 프로세스에서 중요한 역할을 하는 기술입니다.\n\n모달이 열린 상태에서는 모달 자체의 경계 내에서 키보드 포커스가 제한되는 것이 중요합니다. 이렇게 함으로써 사용자가 실수로 모달 외부의 요소인 버튼, 링크 또는 폼 입력란과 같은 요소로 이동하는 것을 방지할 수 있습니다.\n\n이 예시에서 사용자가 샌드박스 환경을 벗어나 탭 키로 브라우저 내의 다른 포커스 가능한 요소에 의도치 않게 도달하는 것을 확인할 수 있습니다.\n\n포커스 강제로 구현함으로써 사용자가 키보드만 사용하여 모달 콘텐츠와 효율적으로 상호 작용할 수 있는 제어된 환경을 만들어냅니다. 이를 통해 전반적인 사용자 경험과 애플리케이션의 접근성을 향상시킬 수 있습니다.\n\n포커스 트래핑은 모달 내에서 포커스 순서를 조작하고 특정 키보드 이벤트를 가로채어 구현됩니다. 포커스 순서를 관리하여 사용자가 상호 작용 요소를 탐색하기 위해 \"Tab\" 키를 누를 때, 포커스는 모달 내에 유지되고 포커스 가능한 요소 사이를 순환하게 됩니다.\n\n또한, 포커스 트래핑은 특정 키보드 이벤트를 가로채어 특별한 상황을 처리하는 것을 포함합니다. 예를 들어, 사용자가 모달 내의 마지막 포커스 가능한 요소에 도달하고 계속 \"Tab\" 키를 누르는 경우, 포커스가 첫 번째 요소로 순환되어 원활한 순환 네비게이션 경험을 만들어야 합니다.\n\n또 다른 일반적인 시나리오는 모달을 닫기 위해 \"Escape\" 키 입력을 처리하는 것입니다. 모달이 열려 있고 사용자가 \"Escape\" 키를 누르면 모달이 닫혀야 하며, 포커스는 모달을 열었던 요소로 돌아가야 합니다.\n\n우리의 사용자 정의 React 모달 컴포넌트에서는 useRef와 useEffect 훅의 조합을 사용하여 포커스 트래핑을 구현할 것입니다. 모달 요소에 ref를 할당함으로써 해당 요소의 포커스 관련 속성에 액세스하고 조작할 수 있습니다. useEffect 훅을 사용하여 모달이 열린 상태에서 키보드 이벤트에 대한 이벤트 리스너를 설정하고 필요한 포커스 조작을 수행할 수 있습니다.\n\n모달 컴포넌트 내에서 포커스 관리를 하는 것으로, 원활하고 직관적인 사용자 경험을 만들어냅니다. 우리가 구현 중인 포커스 포획 논리 덕분에 키보드 사용자들은 예상치 못한 포커스 변화나 중단 없이 모달 컴포넌트의 콘텐츠를 탐색하고 상호작용할 수 있습니다.\n\n# 모달 컴포넌트 구성\n\nReact 모달에서 포커스 포획을 보여주기 위해, 우리는 사용자 정의 Modal 컴포넌트를 만들 것입니다. 포커스 포획 논리만을 보여주기 위해, 이 컴포넌트는 최소한의 스타일로 구현될 것입니다.\n\n다음 섹션에서는 우리의 사용자 정의 React 모달 컴포넌트의 구현 세부 사항에 대해 살펴보고 포커스 포획을 어떻게 달성하는지 탐구할 것입니다.\n\n# 포커스 트래핑 구현\n\n모달 컴포넌트에서는 useEffect 훅을 사용하여 모달이 열릴 때 포커스 트래핑을 관리합니다. 구현을 단계별로 살펴보면 다음과 같습니다:\n\n- useRef 훅을 사용하여 modalRef를 정의하여 모달 요소를 참조합니다. 이 컴포넌트는 isOpen 및 setIsOpen 두 가지 props을 받습니다. 자식 요소는 boolean인 isOpen prop에 따라 표시됩니다. 이 boolean 상태의 setter 함수는 setIsOpen prop입니다.\n\n```js\nconst Modal = ({ isOpen, setIsOpen }) => {\n  const modalRef = useRef(null);\n};\n```\n\n- 다음 단계는 Modal 컴포넌트 내부에 useEffect 훅을 정의하는 것입니다. 그런 다음 isOpen 속성이 true인지 확인합니다. 자식 요소는 boolean isOpen 속성에 따라 표시됩니다. 이 값이 true이면 포커스 트랩 설정을 진행합니다.\n\n```js\nuseEffect(() => {\n  if (isOpen) {\n    //...설정\n  }\n}, [isOpen]);\n```\n\n- 이 설정에서는 모달 내부의 모든 포커스 가능한 요소를 querySelectorAll 메서드를 사용하여 쿼리합니다. 이에는 버튼, 링크, 입력란, 선택란, 텍스트영역, 명시적 tabindex 값을 가진 요소가 포함됩니다. 조심스럽게 MDN 웹 문서 HTML 요소 참조를 확인하여 이 목록에 포함해야 할지 여부를 확인하십시오.\n\n```js\nconst modalElement = modalRef.current;\nconst focusableElements = modalElement.querySelectorAll(\n  'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n);\n```\n\n- 우리는 첫 번째 및 마지막 초점 대상 요소를 각각 firstElement 및 lastElement 변수에 저장합니다.\n\n```js\nconst firstElement = focusableElements[0];\nconst lastElement = focusableElements[focusableElements.length - 1];\n```\n\n- 우리는 두 개의 이벤트 핸들러 함수를 정의합니다: handleTabKeyPress와 handleEscapeKeyPress. 전자는 \"Tab\" 키를 누를 때 원형 탐색을 모달 내에서 가능하게 하고, 후자는 \"Escape\" 키를 눌러 모달을 닫도록 setIsOpen 함수를 호출합니다.\n- event.shiftKey 조건은 \"Shift\" 키가 \"Tab\" 키와 함께 눌렸는지 여부를 결정하는 데 사용됩니다. 이 조건은 모달 내에서의 원형 초점 탐색을 처리하는 데 도움이 됩니다.\n- handleTabKeyPress 이벤트 핸들러는 \"Tab\" 키가 눌렸을 때 트리거됩니다. event.shiftKey 속성은 \"Shift\" 키가 이벤트와 동시에 눌렸는지 여부를 나타내는 부울 값입니다.\n- \"Shift\" 키가 눌렸고 (event.shiftKey가 true이고 현재 초점이 맞춰진 요소가 첫 번째 초점 요소인 경우(document.activeElement === firstElement)), 사용자가 첫 번째 요소에서 역방향으로 탐색 중임을 의미합니다. 이 경우, 모달을 벗어나지 않으려고 기본 탭 동작이 방지됩니다 (event.preventDefault()), 초점은 마지막 초점 대상 요소로 설정됩니다 (lastElement.focus()). 이렇게 하면 모달 내에서 원형 초점 탐색이 생성됩니다.\n- \"Shift\" 키가 눌리지 않았고 (event.shiftKey가 false이고 현재 초점이 마지막 초점 요소인 경우(document.activeElement === lastElement)), 사용자가 마지막 요소에서 앞으로 탐색 중임을 의미합니다. 마찬가지로, 기본 탭 동작이 방지되고 초점은 첫 번째 초점 요소로 설정됩니다 (firstElement.focus()), 모달 내에서 원형 탐색이 계속됩니다.\n- event.shiftKey 조건을 사용하여, \"Tab\" 키를 단독 또는 \"Shift\" 키와 함께 누를 때 모달의 초점 대상 요소 내에서 정상적으로 전진 및 후진 탐색이 작동하도록 로직이 보장됩니다.\n\n```js\nconst handleTabKeyPress = (event) => {\n  if (event.key === \"Tab\") {\n    if (event.shiftKey && document.activeElement === firstElement) {\n      event.preventDefault();\n      lastElement.focus();\n    } else if (!event.shiftKey && document.activeElement === lastElement) {\n      event.preventDefault();\n      firstElement.focus();\n    }\n  }\n};\n\nconst handleEscapeKeyPress = (event) => {\n  if (event.key === \"Escape\") {\n    setIsOpen(false);\n  }\n};\n```\n\n- addEventListener를 사용하여 모달 요소에 이벤트 리스너를 추가합니다. 그런 다음 useEffect 훅은 isOpen 또는 setIsOpen이 변경될 때마다 실행되도록 설정해야 합니다. isOpen이 변경될 때마다 효과가 다시 트리거됩니다. 그러나 효과 내부의 코드는 isOpen의 값에 따라 이벤트 리스너를 추가하거나 제거하기만 합니다. isOpen 상태 자체를 직접 수정하지는 않습니다.\n- 의존성 배열에 해당 상태가 포함된 useEffect 훅 내에서 isOpen 상태를 수정하는 것은 문제가 발생할 수 있습니다. 훅은 관찰 중인 의존성 중 하나가 변경될 때 관련 컴포넌트를 다시 렌더링하도록 강제합니다. 따라서 무한한 재렌더링 루프를 트리거할 수 있습니다. 무한한 재렌더링 루프를 방지하는 주요 요소는 효과가 isOpen 상태에 따라 이벤트 리스너를 추가하거나 제거하지만 isOpen 상태 자체를 수정하지 않는다는 것입니다. 따라서 실행될 때 컴포넌트의 다시 렌더링을 트리거하지 않습니다.\n\n```js\nmodalElement.addEventListener(\"keydown\", handleTabKeyPress);\nmodalElement.addEventListener(\"keydown\", handleEscapeKeyPress);\n```\n\n- useEffect 훅에서 반환된 클린업 함수 내에서 이벤트 리스너를 제거하여 메모리 누수를 방지합니다.\n\n```js\nreturn () => {\n  modalElement.removeEventListener(\"keydown\", handleTabKeyPress);\n  modalElement.removeEventListener(\"keydown\", handleEscapeKeyPress);\n};\n```\n\n모달 컴포넌트의 최종 버전입니다:\n\n```js\nimport React, { useRef, useEffect } from \"react\";\n\nconst Modal = ({ isOpen, setIsOpen }) => {\n  const modalRef = useRef(null);\n\n  useEffect(() => {\n    if (isOpen) {\n      const modalElement = modalRef.current;\n      // 포커스 가능한 HTML 요소를 포함하고 싶다면 이 문자열에 추가하세요\n      const focusableElements = modalElement.querySelectorAll(\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n      );\n      const firstElement = focusableElements[0];\n      const lastElement = focusableElements[focusableElements.length - 1];\n\n      const handleTabKeyPress = (event) => {\n        if (event.key === \"Tab\") {\n          if (event.shiftKey && document.activeElement === firstElement) {\n            event.preventDefault();\n            lastElement.focus();\n          } else if (!event.shiftKey && document.activeElement === lastElement) {\n            event.preventDefault();\n            firstElement.focus();\n          }\n        }\n      };\n\n      const handleEscapeKeyPress = (event) => {\n        if (event.key === \"Escape\") {\n          setIsOpen(false);\n        }\n      };\n\n      modalElement.addEventListener(\"keydown\", handleTabKeyPress);\n      modalElement.addEventListener(\"keydown\", handleEscapeKeyPress);\n\n      return () => {\n        modalElement.removeEventListener(\"keydown\", handleTabKeyPress);\n        modalElement.removeEventListener(\"keydown\", handleEscapeKeyPress);\n      };\n    }\n  }, [isOpen, setIsOpen]);\n\n  return isOpen ? (\n    <div className=\"modal\" ref={modalRef}>\n      <div className=\"modal__box\">\n        <span>Tab 키를 눌러 자식 요소들 사이로 포커스를 이동하세요. Esc 키를 눌러 모달을 닫을 수 있습니다.</span>\n        <a className=\"modal__box__children\" href=\"www.google.com\">\n          링크\n        </a>\n        <button className=\"modal__box__children\">모달 버튼</button>\n        <input className=\"modal__box__children\"></input>\n        <span className=\"modal__box__children\" tabIndex=\"0\">\n          포커스 가능한 텍스트\n        </span>\n      </div>\n    </div>\n  ) : (\n    <></>\n  );\n};\n\nexport default Modal;\n```\n\n마침내, 포커스 트래핑을 구현하여 사용자가 모달 외부로 의도치 않게 이동하지 않도록 보장합니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*9jPfh_LYgjYCEKWBTcORow.gif\" />\n\n# 결론\n\n이 기사에서는 사용자 정의 React 모달 구성 요소에서 초점 포착을 어떻게 달성하는지 살펴보았습니다. 모달 내에서 초점을 적절하게 관리함으로써 응용 프로그램의 접근성과 사용성을 향상시킬 수 있습니다. 기술의 기본 원리를 이해하고 코드에 구현함으로써, 더 견고하고 사용자 친화적인 응용 프로그램을 개발할 수 있습니다.\n\n이 기사에서 만든 모달 구성 요소의 완전한 코드는 CodeSandbox 데모에서 찾을 수 있습니다.\n\n필요한 초점 포착 로직을 처리하는 외부 라이브러리가 있더라도, 내부 로직을 이해하고 도움말 확인을 직접 만드는 것이 중요하다고 생각합니다. 그러나 특정 필요에 대한 외부 라이브러리를 구현하는 것도 많은 시간을 절약할 수 있습니다. 각 구현 결정의 장단점을 따져 현명하게 작업하는 것이 현명합니다.\n\nOne of those external solutions is the accessibility-focused open-source library CactusUI where focus trapping is handled within the FocusTrap component. You may find the source code in the following repository.\n\n![Focus Trap Component](/assets/img/2024-05-12-AchievingFocusTrappinginaReactModalComponent_1.png)\n\nRemember, focus trapping is just one aspect of creating accessible modal components. It’s essential to consider other accessibility practices, such as screen reader compatibility, keyboard navigation, and ARIA attributes, to ensure an inclusive experience for all users.\n\n# 소셜미디어\n\n# Github\n\n# Linkedin\n\nOgun Akar — 프론트엔드 개발자 @ ÇSTech\n\n# 참고문헌\n","ogImage":{"url":"/assets/img/2024-05-12-AchievingFocusTrappinginaReactModalComponent_0.png"},"coverImage":"/assets/img/2024-05-12-AchievingFocusTrappinginaReactModalComponent_0.png","tag":["Tech"],"readingTime":9},{"title":"React 19의 새로운 기능 - 문서 메타데이터","description":"","date":"2024-05-12 21:40","slug":"2024-05-12-NewFeaturesinReact19DocumentMetadata","content":"\n\n🚀 React 19에서 SEO 및 접근성 향상하기 🌟\n\n![React 19 새로운 기능 문서 메타데이터](/assets/img/2024-05-12-NewFeaturesinReact19DocumentMetadata_0.png)\n\n안녕하세요, 개발자 여러분! 웹 개발에서 매우 중요한 주제를 이야기해보려고 해요: SEO 최적화와 접근성 보장하기입니다. \"제목,\" \"메타 태그,\" \"설명\"과 같은 요소들은 이러한 목표를 달성하는 데 중요한 역할을 합니다. 그러나 React에서는 특히 싱글 페이지 애플리케이션에서 이러한 요소들을 관리하는 것이 조금 어려울 수 있어요.\n\nReact SEO 최적화에서의 어려움:\n\n\n\n요즘 개발자들은 자체 코드를 작성하거나 리액트 헬멧과 같은 패키지를 활용하여 경로 변경을 처리하고 메타 데이터를 업데이트하는 일에 자주 마주합니다. 그러나 이 과정은 메타 태그와 같은 SEO에 민감한 요소들을 다룰 때 반복적이고 오류를 범하기 쉽습니다.\n\n리액트 19 이전:\n\n이전에, 개발자들은 이러한 요소를 업데이트하기 위해 자체 코드를 작성해야 했습니다. 예를 들어, 다음 코드 조각을 살펴보세요:\n\n```js\nimport React, { useEffect } from 'react';\n\nconst HeadDocument = ({ title }) => {\n  useEffect(() => {\n    document.title = title;\n\n    const metaDescriptionTag = document.querySelector('meta[name=\"description\"]');\n    if (metaDescriptionTag) {\n      metaDescriptionTag.setAttribute('content', '새로운 설명');\n    }\n  }, [title]);\n\n  return null;\n};\n\nexport default HeadDocument;\n```\n\n\n\n위의 코드에서는 프롭에 따라 제목과 메타 태그를 업데이트하는 HeadDocument 컴포넌트가 있습니다. 우리는 이를 useEffect 훅에서 업데이트합니다. 또한 JavaScript를 사용하여 제목과 메타 태그를 업데이트합니다. 이 컴포넌트는 경로 변경시 업데이트됩니다. 이는 이 작업을 수행하는 깔끔한 방법은 아닙니다.\n\n이 접근 방식으로는 작동하지만 React에서 SEO 요소를 관리하는 가장 깔끔한 방법은 아닙니다.\n\nReact 19부터:\n\nReact 19에서는 SEO 요소를 관리하는 것이 훨씬 간단하고 직관적으로 되었습니다. 이제 React 컴포넌트에서 직접 제목과 메타 태그를 사용할 수 있습니다. 아래와 같이요:\n\n\n\n```js\nconst HomePage = () => {\n  return (\n    <>\n      <title>Freecodecamp</title>\n      <meta name=\"description\" content=\"Freecode camp blogs\" />\n      {/* 페이지 콘텐츠 */}\n    </>\n  );\n}\n```\n\nReact 19 이전에는 React 컴포넌트에서 SEO 요소를 직접 사용할 수 없었습니다. 이제 React 19부터는 react-helmet과 같은 외부 패키지에 의존하지 않고 React 애플리케이션의 SEO 요소를 쉽게 관리할 수 있게 되었습니다.\n\n결론:\n\nReact 19의 개선된 기능을 통해 컴포넌트 내에서 SEO 요소를 직접 관리할 수 있게 되어 React 애플리케이션의 SEO 최적화와 접근성 향상을 더욱 간편하게 할 수 있습니다. 더 많은 업데이트를 기대해 주시고 즐거운 코딩되세요! 👩‍💻👨‍💻\n\n\n\n\n관련 링크:\n\n- React 19의 새로운 기능\n\n- React 19의 새로운 기능 — React 컴파일러\n\n- React 19의 새로운 기능 — 서버 컴포넌트\n\n\n\nReact 19의 새로운 기능들 — 액션\n\nReact 19의 새로운 기능들 — 웹 컴포넌트\n\nReact 19의 새로운 기능들 — 자산 로딩\n\nReact 19의 새로운 기능들 — 새로운 React Hooks","ogImage":{"url":"/assets/img/2024-05-12-NewFeaturesinReact19DocumentMetadata_0.png"},"coverImage":"/assets/img/2024-05-12-NewFeaturesinReact19DocumentMetadata_0.png","tag":["Tech"],"readingTime":3},{"title":"무료 오픈 소스 ReactJS 템플릿 10가지 공유","description":"","date":"2024-05-12 21:38","slug":"2024-05-12-10FreeOpenSourceReactJSTemplates","content":"\n이 글에서는 신중하게 선택된 10가지 무료 오픈 소스 ReactJS 템플릿을 소개합니다.\n\n- Atomize\n- Open\n- MUI 대시보드\n- MatX\n- Star Admin\n- React 이력서 템플릿 v2\n- 현대적인 React 포트폴리오 템플릿\n- Soumya-jit 포트폴리오\n- React vscode 포트폴리오\n- Gitprofile\n\n# 1. Atomize\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_0.png)\n\nAtomize React는 귀하의 스타일과 일치하는 완전히 반응 형 웹 사이트 및 제품을 구축하는 데 도와줍니다.\n\nGitHub에서 1.5k개의 스타를 받았어요\n\n## 특징\n\n- 웹 앱용 UI 디자인 시스템\n- 우아하고 아름다운 React 구성 요소\n- 테마 설정을 위한 미리 정의된 색상\n- 각 구성 요소에 대한 자세한 설명서\n\n## 링크\n\n## 라이브 데모\n\n# 2. 오픈\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_1.png)\n\nMarkdown 형식의 요소로 변경해 보겠습니다:\n\n**Open**은 GitHub에서 2.4k개의 별을 받았어요.\n\n## 기능\n\n- 완전히 반응형 디자인\n- 쉽게 사용자 정의 가능\n- Google Fonts\n- 레티나 대응\n- 특별 제작 일러스트 및 Nucleo 앱(아이코노그래피)\n- 스크롤 리벨 애니메이션\n\n## 링크\n\n## 실시간 데모\n\n# 3. MUI 대시보드\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_2.png)\n\n태스크바와 미니 변형 그림이 있는 간단한 대시보드입니다. 차트는 Recharts에서 제공되지만 다른 대안으로 쉽게 대체할 수 있습니다.\n\nMUI는 GitHub에서 83,000개의 스타를 받았어요\n\n## 특징\n\n- Material UI 구성 요소 및 요소\n- 대시보드 및 분석 뷰\n- Recharts, 구성 가능한 차트 라이브러리\n\n## 링크\n\n## 라이브 데모\n\n# 4. MatX\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_3.png)\n\nMatX는 놀라운 무료 React 관리자 템플릿이에요. React, Redux, 그리고 Material UI로 개발되었답니다.\n새로운 웹 애플리케이션을 시작하기 위해 필요한 모든 기능을 구현했어요. 이 무료 React\n관리자 템플릿에는 모든 Material UI 컴포넌트, 폼 요소, 및 검증이 포함되어 있어요. 또한, JWT\n인증, 로그인, 회원가입 페이지, 세로 네비게이션, 레이지 로딩 등이 있답니다.\n게다가, 여러 가능성을 제공하는 다양한 React 컴포넌트 모음이 함께 제공돼요.\n따라서 관리자 패널, 관리 시스템, 프로젝트 관리, CMS, CRM, 웹 및 모바일 애플리케이션 백엔드로 사용할 수 있어요...\n\nMatX는 GitHub에서 778k개의 별을 받았어요.\n\n## 주요 기능\n\n- 대시보드\n- JWT 인증\n- Material UI 컴포넌트\n- 기본 폼\n- 세로 네비게이션\n- 레이지 로딩\n- 코드 분할\n- SASS 통합\n- 로그인\n- 회원가입\n- 구글 맵\n- 드래그 앤 드롭\n- 다중 수준 메뉴\n\n## 링크\n\n## 데모 보기\n\n# 5. Star Admin\n\nStar Admin React은 BootstrapDash의 놀라운 관리자 템플릿 중 하나로, Bootstrap 프레임워크를 기반으로 합니다. 이 템플릿은 섬세하게 디자인되었으며 완벽하게 코딩되었습니다. Star Admin React에는 많은 부트스트랩 구성 요소, UI 요소 및 내장된 샘플 페이지가 포함되어 있어 프로젝트를 손쉽게 시작할 수 있습니다.\n\n템플릿은 매우 맞춤화할 수 있어서 디자인을 변경하여 필요에 맞게 조정하고 독특한 외관을 제공할 수 있습니다. 또한 문서화가 아주 잘 되어 있어 어떤 문제도 없이 시작할 수 있습니다.\n\nStar Admin은 GitHub에서 212개의 스타를 받았어요.\n\n## 기능\n\n- Bootstrap\n- Material Design Icons\n- React\n- Chart.js\n\n## 링크\n\n## 라이브 데모\n\n# 6. React 이력서 템플릿 v2\n\n<img src=\"/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_4.png\" />\n\n이것은 React 기반의 개인 이력서 웹 사이트 템플릿입니다. Next.js 프레임워크에서 TypeScript로 제작되었으며 Tailwind CSS로 스타일을 지정하고 단일 파일에서 데이터를 가져와 손쉽게 개인 웹 사이트를 만들고 사용자 정의하고 호스팅할 수 있습니다. 게다가 사이트는 모바일에 완벽하게 최적화되어 있으며 서버 측 렌더링되어 빠른로딩과 어떤 기기에서든 깨끗한 UI가 제공됩니다. 자세한 내용은 계속 읽어보세요.\n\nGitHub에서 React 이력서 템플릿은 1.1k개의 스타를 받았습니다.\n\n## 특징\n\n- React와 TypeScript 지원을 완벽히 갖춘 다시 설계된 사이트\n- 쉬운 서버 측 렌더링/정적 생성, 이미지 최적화, API 경로 및 배포를 위해 Next.js 프레임워크에서 구축\n- TailwindCss로 완전한 스타일 적용\n- 사용자 정의를 위해 데이터 모음 파일 재구성\n- 모든 사이트 섹션의 중요한 개선/현대화\n\n## 링크\n\n## 실시간 데모\n\n# 7. 현대적인 React 포트폴리오 템플릿\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_5.png)\n\n최신 Next.js 및 TailwindCSS를 기반으로 한 현대적인 React 포트폴리오 무료 템플릿입니다.\n\nGitHub에서 현대적인 React 포트폴리오 템플릿은 768개의 스타를 받았습니다.\n\n## 특징\n\n- 현대적인 스택 (Next.js + TailwindCSS)\n- 심플한 디자인\n- 쉽게 탐색할 수 있음\n- GUI로 세부 정보를 쉽게 사용자 정의할 수 있음\n- 블로그 CRUD (Create, Read, Update, Delete 블로그를 쉽게 이용할 수 있는 UI로)\n- 다크 모드\n\n## 링크\n\n## 라이브 데모\n\n# 8. Soumya-jit 포트폴리오\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_6.png)\n\n개발자를 위한 인적 포트폴리오 템플릿\n\nSoumya-jit 포트폴리오는 GitHub에서 1.4천개의 스타를 받았어요\n\n## 특징\n\n- 다양한 페이지 레이아웃\n- React-Bootstrap 및 CSS로 스타일이 적용되어 있어 색상을 쉽게 사용자 정의할 수 있어요\n- 완벽하게 반응형입니다\n\n## 링크\n\n## 데모 보기\n\n## 9. React vscode 포트폴리오\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_7.png)\n\n프로젝트는 Visual Studio Code와 caglarturali.github.io에서 영감을 받았어요. 포트폴리오 페이지들은 마크다운으로 구성되어 있어서 쉽게 수정하거나 자신만의 내용을 추가할 수 있어요.\n\nReact vscode Portfolio는 GitHub에서 51개의 스타를 받았어요.\n\n## 특징\n\n- 마크다운을 이용해 구성\n- 다크 모드와 라이트 모드 사용 가능\n- 닫을 수 있는 탭\n- 접을 수 있는 탐색기\n- 반응형 웹 디자인\n- Google Analytics 지원\n- GitHub 액션을 이용하여 자동으로 gh-pages에 배포 가능\n\n## 링크\n\n## 라이브 데모\n\n# 10. Gitprofile\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_8.png)\n\nGitProfile은 GitHub 사용자 이름만 제공하면 포트폴리오 페이지를 자동으로 생성하는 쉬운 포트폴리오 빌더입니다. React.js 위에 Vite를 사용하여 구축되었습니다. 그러나 시작하기에 이들에 대한 지식이 필요하지는 않습니다. 코딩 경험이 전혀 없어도 직접 복사본을 만들 수 있습니다.\n\nGitHub에서 GitProfile은 530개의 스타를 받았어요.\n\n## 주요 기능\n\n- 쉬운 설정\n- 30가지 테마\n- 구글 애널리틱스\n- 핫자르\n- SEO\n- 아바타 및 소개\n- 소셜 링크\n- 기술 섹션\n- 경험 섹션\n- 인증 섹션\n- 교육 섹션\n- 프로젝트 섹션\n- 블로그 게시물 섹션\n\n## 링크\n\n## 실시간 데모\n","ogImage":{"url":"/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_0.png"},"coverImage":"/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_0.png","tag":["Tech"],"readingTime":5},{"title":"Redux, React Typescript, Electron 및 Vite로 시작하기","description":"","date":"2024-05-12 21:36","slug":"2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite","content":"\n\n![Vite](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_0.png)\n\n안녕하세요\n\nVite는 새 프론트엔드 프로젝트를 빠르게 시작할 수 있는 놀라운 방법입니다. Vanilla JS, Vue, React 등 다양한 템플릿을 지원합니다. 빌드 시간이 빠르고 빠르게 작동하는 개발 서버도 기본 제공됩니다. Vite는 또한 Electron을 사용하여 새 프로젝트를 만드는 것도 지원합니다. Electron은 크로미움 기반의 프레임워크로, HTML, CSS 및 Javascript만을 사용하여 여러 플랫폼용 데스크톱 앱을 빌드하는 데 사용됩니다. Redux는 리액트 프로젝트에서 사용되는 상태 관리 도구 및 라이브러리로, 애플리케이션 전체에서 컴포넌트 주변에 있는 기존 상태를 추적하는 데 사용됩니다. 이 블로그에서는 React, Redux, Typescript 및 Electron을 사용하여 Vite를 사용하여 스타터 프로젝트를 빠르게 설정하는 방법을 살펴볼 것입니다. 이 튜토리얼은 문서에서 Redux를 사용하는 방법을 따릅니다.\n\n설정\n\n\n\n첫 번째로 터미널을 열고 데스크탑이나 프로젝트를 보관하는 폴더 중 하나로 이동해야 해요. 거기서 다음 명령어를 실행할 거예요.\n\n```js\nyarn create vite .\n```\n\n이렇게 하면 현재 디렉토리에 Vite 프로젝트가 생성되고 어떻게 프로젝트를 구성할지 물어볼 거예요.\n\n\n\n![이미지](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_1.png)\n\n위의 스크린샷에서 프로젝트에 패키지 이름을 지정하고 싶습니다. 이것이 우리 프로젝트의 이름이 될 것입니다. 이름을 비워두지 않고 디렉토리 안에 다른 이름을 지정하면 현재 디렉토리 내에 별도의 폴더 안에 프로젝트가 생성됩니다.\n\nVite 설정 cli에서 다음 단계는 어떤 프레임워크를 사용할지 선택하는 것입니다. Others로 이동하여 Enter 키를 눌러주세요. create-electron-vite를 선택하세요.\n\n![이미지](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_2.png)\n\n\n\n다시 패키지 이름을 입력하라는 프롬프트가 나타날 것입니다. 이번 단계는 간단하게 Enter 키를 눌러 건너뛰세요. 마지막 단계는 프로젝트 템플릿을 선택하는 것입니다. React를 선택해주세요.\n\n![이미지](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_3.png)\n\n이렇게 하면 src, electron 및 public 폴더가 포함된 Vite 프로젝트가 Electron, Typescript 및 React를 사용하여 생성되며, Typescript, Vite 및 Electron용 구성 파일도 함께 제공됩니다.\n\n```js\n.\n├── electron\n│   ├── electron-env.d.ts\n│   ├── main.ts\n│   └── preload.ts\n├── electron-builder.json5\n├── index.html\n├── package.json\n├── public\n│   ├── electron-vite.animate.svg\n│   ├── electron-vite.svg\n│   └── vite.svg\n├── src\n│   ├── App.css\n│   ├── App.tsx\n│   ├── assets\n│   │   └── react.svg\n│   ├── index.css\n│   ├── main.tsx\n│   └── vite-env.d.ts\n├── tsconfig.json\n├── tsconfig.node.json\n└── vite.config.ts\n```\n\n\n\n위의 표를 마크다운 형식으로 변경하세요.\n\n\n공정하고 깔끔하게 나왔습니다. 위의 표를 마크다운 형식으로 변경하겠습니다.\n\n\n\n전주가전격 스타터 앱을 띄울 새 창이 열립니다. 앱에는 데모 카운터가 포함되어 있습니다.\n\n![Getting Started with Redux React TypeScript Electron using Vite](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_4.png)\n\n기존 프로젝트에 Redux 통합하기\n\nRedux의 시작 가이드에 따르면 Redux 프로젝트를 시작할 때 Vite의 공식 템플릿을 사용하는 것이 최선의 방법입니다. 그러나 우리의 기존 일렉트론 프로젝트에 Redux를 통합하는 것은 간단합니다. 다음 종속성을 프로젝트에 설치해야 합니다.\n\n\n\n```js\nyarn add @reduxjs/toolkit  \nyarn add react-redux                        \nyarn add redux\n```\n\n위 명령을 실행하면 redux의 기본 기능, react에 대한 바인딩 및 redux toolkit을 위한 필수 종속성이 설치됩니다. 이러한 패키지를 설치한 후에는 첫 번째 Redux 스토어를 생성할 수 있습니다.\n\n첫 번째 Redux 스토어 생성하기\n\nRedux 스토어를 생성하기 전에 slice를 정의해야 합니다. slice는 Redux 스토어의 독립된 모듈입니다. 프로젝트의 src 폴더로 이동하여 slices라는 폴더를 만듭니다. 이 폴더는 redux 스토어의 독립된 모듈 또는 slice를 보관할 것입니다. 나중에 이를 redux 스토어에 삽입할 것입니다.\n\n\n\n\n![GettingStartedWithReduxReactTypescriptElectronusingVite_5](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_5.png)\n\n다음 코드를 `counterSlice.ts` 파일에 추가하세요.\n\n```js\nimport { createSlice, PayloadAction } from \"@reduxjs/toolkit\"\n\nexport type CounterState = {\n   value: number\n}\n\nconst initialState: CounterState = {\n   value: 0\n}\n\nconst counterSlice = createSlice({\n   name: 'counter',\n   initialState: initialState,\n   reducers: {\n      increment: (state) => {\n         state.value += 1\n      },\n      decrement: (state) => {\n         state.value -= 1\n      },\n      incrementByValue: (state, action: PayloadAction<number>) =>{\n         state.value = action.payload\n      }\n   }\n})\n\nexport const { increment, decrement, incrementByValue } = counterSlice.actions\nexport default counterSlice.reducer\n```\n\n코드를 분석해 봅시다.\n\n\n\n```js\nexport type CounterState = {\n   value: number\n}\n```\n\n친구야, 저희는 카운터 상태에 대한 유형을 만들었어요. 여기서 카운트에 대한 유형은 숫자입니다.\n\n```js\nconst initialState: CounterState = {\n   value: 0\n}\n```\n\n여기서 count의 초기 상태를 CounterState 유형으로 정의한 초기 상태입니다. 초기 상태는 slice를 정의할 때 전달되는 매개변수 중 하나에요.\n\n\n\n```js\nconst counterSlice = createSlice({\n   name: 'counter',\n   initialState: initialState,\n   reducers: {\n      increment: (state) => {\n         state.value += 1\n      },\n      decrement: (state) => {\n         state.value -= 1\n      },\n      incrementByValue: (state, action: PayloadAction<number>) =>{\n         state.value = action.payload\n      }\n   }\n})\n```\n\n우리는 createSlice()를 사용하여 슬라이스가 생성되고 저장되는 상수를 정의합니다. createSlice()는 자체 포함 모듈 또는 redux 스토어의 슬라이스를 만들 수 있게 하는 redux 함수입니다. 이 슬라이스는 생성된 액션 유형을 이름 공간화하기 위해 사용되는 슬라이스의 이름, 상태 값을 초기화하는 초기 상태 및 리듀서 함수 또는 상태 조작을 허용하는 액션을 유지합니다.\n\n첫 번째 슬라이스를 정의한 후에는 이 슬라이스를 보유하는 store를 생성합니다. 이를 프로젝트에서 만들어 봅시다. src 폴더 안에 stores라는 새 폴더를 만들어주세요. 그 안에 store.ts라는 새 파일을 만드세요.\n\n<img src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_6.png\" />\n\n\n\n\nstore.ts 파일에 다음 코드를 추가하겠습니다.\n\n```js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport counterReducer from \"../slices/counterSlice\";\n\nexport const store = configureStore({\n   reducer: {\n      counter: counterReducer\n   }\n})\n\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\n```\n\n각 코드 조각을 자세히 살펴보겠습니다.\n\n```js\nexport const store = configureStore({\n   reducer: {\n      counter: counterReducer\n   }\n})\n```\n\n\n\n`configureStore()`은 React 앱 전반에서 참조할 수 있는 store를 구축하는 데 사용되는 또 다른 Redux 함수입니다. 이 store는 생성된 모든 slice의 저장소 역할을 합니다. 안에는 우리가 이전에 counterSlice.ts 파일에서 내보낸 counterReducer를 저장합니다. 나중에는 루트 컴포넌트에서 provider 태그를 통해 우리의 store를 주입할 것입니다.\n\n```js\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\n```\n\nRedux 문서에 따르면 redux toolkit은 추가적인 typings가 필요 없지만, 우리가 필요할 때 참조할 수 있도록 RootState와 AppDispatch를 추출해야 합니다. 우리의 store가 커지고 더 많은 slice가 추가될수록, 이러한 유형을 추론하는 것은 이들이 정확히 업데이트되도록 하기 위함입니다.\n\n또한 Redux 문서는 TypeScript와 작업할 때 useDispatch()와 useSelector()에 대한 사용자 정의 타입된 훅을 정의하는 것이 최선의 실천 방법임을 강조합니다. 이러한 함수들은 컴포넌트에서 상태 값을 청취하고 상태 값을 업데이트하는 데 사용될 것이며, 이렇게 함으로써 값이 업데이트 될 때 store 내에서 업데이트된 내용이 반영되도록 합니다. 각 훅이 하는 일에 대한 간단한 개요는 다음과 같습니다.\n\n\n\n\n`useSelector()`은 리덕스 스토어에서 값을 가져오고 구독할 수 있게 해주는 훅 함수입니다. 해당 값에 구독된 모든 컴포넌트는 그 값을 현재 값과 업데이트된 변경 사항을 반영합니다.\n\n`useDispatch()`는 사용자가 스토어의 값을 변경할 이벤트를 트리거할 수 있게 해주는 훅 함수입니다. useSelector()를 통해 스토어의 값을 참조하는 모든 컴포넌트도 마찬가지로 그 값이 업데이트됩니다.\n\nsrc 폴더 안에 우리의 훅을 위한 폴더를 만들고 storeHooks.ts 파일을 생성합니다. 이 파일은 useDispatch()와 useSelector()를 위한 사용자 정의 훅을 보유할 것입니다.\n\n타입스크립트와 리덕스를 통합하는 자세한 방법은 Redux 문서의 타입스크립트 퀵 스타트 가이드를 참조해주세요.\n\n\n\n<img src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_7.png\" />\n\n```js\nimport { AppDispatch, RootState } from './../stores/store';\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\n\nexport const useAppDispatch: () => AppDispatch = useDispatch\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\n```\n\n마지막으로, 컴포넌트들이 스토어에 액세스할 수 있도록 하려면, Provider 태그 내에서 스토어를 주입해야 합니다. Provider에 등록된 모든 컴포넌트는 스토어 내의 값을 액세스하고 수정할 수 있습니다.\n\n```js\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <Provider store={store}> \n      <App />\n    </Provider>\n  </React.StrictMode>,\n)\n```\n\n\n\n# Counter 컴포넌트 생성하기\n\n이제 우리가 스토어, 슬라이스를 정의하고 스토어를 프로바이더에 주입했으니, 카운터 컴포넌트를 생성할 시간입니다.\n\nsrc로 이동하여 Counter.tsx 컴포넌트를 생성하세요.\n\n```js\nimport { useAppDispatch } from \"./hooks/storeHooks\";\nimport { increment, decrement } from \"./slices/counterSlice\";\nimport { Row, Col, Button } from \"antd\";\n\nexport default function Counter() {\n  const dispatch = useAppDispatch();\n\n  function incrementCounter() {\n    dispatch(increment());\n  }\n\n  function decrementCounter() {\n    dispatch(decrement());\n  }\n\n  return (\n    <>\n      <Row>\n        <Col>\n          <Button type=\"primary\" onClick={incrementCounter}>\n            Increment +\n          </Button>\n        </Col>\n        <Col>\n          <Button type=\"primary\" onClick={decrementCounter}>\n            Decrement -\n          </Button>\n        </Col>\n      </Row>\n    </>\n  );\n}\n```\n\n\n\n이 컴포넌트에서는 incrementCounter 및 decrementCounter 함수를 사용하여 카운터를 증가 및 감소시키는 컴포넌트를 만듭니다.\n\nuseAppDispatch() 훅을 사용하여 사용자 지정 형식의 디스패치 함수를 저장합니다. 이 함수는 구독 중인 컴포넌트가 변경 사항을 이에 따라 수정할 수 있도록 저장소의 값 변경을 담당합니다. incrementCounter 및 decrementCounter는 모두 전달된 슬라이스의 리듀서 함수를 사용하여 디스패치를 호출합니다. UI 컴포넌트로 ANTD를 사용하고 있지만 React용 다른 UI 라이브러리에서도 작동합니다.\n\nANTD 라이브러리를 더 알아보고 싶다면 문서를 확인해보세요. ANTD를 프로젝트에 통합하는 것은 간단하며, 라이브러리는 Vue.js 및 Angular에도 제공됩니다.\n\n이제 카운트를 수정하는 컴포넌트를 정의했으므로 App.tsx로 이동하여 Vite 프로젝트를 처음 설정할 때 생성된 코드를 제거하는 시간입니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_8.png\" />\n\n우리가 useSelector()에 대한 사용자 정의된 타입된 후크를 호출할 때, Typescript는 우리가 counter를 위한 상태를 생성했다는 것을 감지하고 initialState에서 정의된 값의 자동완성을 제공합니다. 이는 redux 스토어로부터 상태 구조를 추론하여 유형 안전성을 제공할 수 있습니다. 이것이 Typescript와 함께 redux를 사용하는 아름다움입니다.\n\n<img src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_9.png\" />\n\n여기가 최종 코드 조각입니다.\n\n\n\n```js\nimport { useAppSelector } from \"./hooks/storeHooks\"\nimport Counter from \"./Counter\";\nimport { useAppSelector } from \"./hooks/storeHooks\";\nimport { Row, Col } from \"antd\";\n\nfunction App() {\n  const count = useAppSelector((state) => state.counter.value);\n  return (\n    <Row justify={'center'}>\n      <Col>\n        <Row justify={\"center\"}>\n          <Col>\n            <h1>카운트는 {count} 입니다. </h1>\n          </Col>\n        </Row>\n        <Row justify={\"center\"}>\n          <Col>\n            <Counter />\n          </Col>\n        </Row>\n      </Col>\n    </Row>\n  );\n}\n\nexport default App;\n```\n\n터미널에서 다시 yarn dev를 실행하면 아래와 같은 결과를 얻을 수 있습니다.\n\n<img src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_10.png\" />\n\n결론\n\n\n\n축하합니다! React, Vite, Typescript 및 Redux를 사용하여 기본 전자 앱을 만들었습니다. 우리는 카운터의 초기 상태를 보유하는 slice를 작성했고, 카운터를 증가 및 감소시키는 reducer 함수를 만들었습니다. 또한 store를 생성하여 모든 slice를 보관하고, store 내의 값을 조작하는 기본 컴포넌트를 생성했고 App.tsx 컴포넌트에서 store 내의 값에 구독했습니다. 이는 Redux를 사용한 기본 사용 사례이며, Redux를 실제 프로젝트에 적용하는 다른 예시로는 인증 상태 구독, 다크 모드 설정, 사용자 데이터 변경을 감시하는 것 등이 있습니다.\n\nElectron, Vite 및 Redux에 대해 더 자세히 알아보려면 다음 문서 링크를 확인해보세요.\n\n- Redux — https://redux.js.org/\n- Vite — https://vitejs.dev/\n- Electron — https://www.electronjs.org/","ogImage":{"url":"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_0.png"},"coverImage":"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_0.png","tag":["Tech"],"readingTime":11},{"title":"Microsoft Authentication Library MSAL을 사용한 인증","description":"","date":"2024-05-12 21:34","slug":"2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL","content":"\n<img src=\"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_0.png\" />\n\n# 소개:\n\n인증 및 안전한 액세스 제공은 모든 웹 애플리케이션의 중요한 부분입니다. 우리는 직접 구축하거나 Microsoft 인증 라이브러리(MSAL)와 같은 타사 서비스를 사용할 수 있습니다. 이렇게 함으로써 개발 작업과 리소스를 절약할 뿐만 아니라 신뢰할 수 있고 효율적이며 검증된 솔루션을 제공받을 수 있습니다. MSAL은 웹 애플리케이션이나 Rest API에 안전한 액세스를 제공합니다. JavaScript, Java, Python과 같은 다양한 응용 프로그램 아키텍처 및 플랫폼을 지원합니다. 구성 파일 및 일부 코드를 사용하여 MSAL을 통합할 수 있기 때문에 OAuth 라이브러리를 사용할 필요가 없습니다. 애플리케이션은 Microsoft 개인 계정이나 클라우드에 설정된 사용자로 로그인할 수 있습니다. Microsoft의 데이터 보안 및 확장성에 대한 신뢰성이 추가로 제공됩니다.\n\n그러니 바로 시작하여 구현에 필요한 단계를 살펴보겠습니다. 이는 다음과 같습니다.\n\n- Microsoft Azure 플랫폼에 애플리케이션 등록\n- Auth 구성 파일 구성\n- 애플리케이션에 MSAL 코드 추가\n- 로그인 구성 요소 추가\n- 애플리케이션에 로그인 통합\n- 보호된 Rest API에 액세스\n\n# 1. Microsoft Azure 플랫폼에 애플리케이션 등록\n\n먼저, Azure 구독 또는 무료 Azure 계정이 필요합니다. 계정에는 애플리케이션을 등록할 수 있는 권한이 있어야 합니다. 홈페이지에서 Microsoft Entra ID 서비스를 선택할 수 있습니다. 여기서 계정의 테넌트 ID를 볼 수 있고 새로운 앱 등록을 추가할 수 있습니다.\n\n![Microsoft Azure Platform](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_1.png)\n\n![이미지](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_2.png)\n\n인증 구성 파일을 설정하는 동안 테넌트 ID가 필요합니다.\n\n애플리케이션 이름 및 리디렉션 URI를 입력할 수 있습니다. 리디렉션 URI는 성공적인 인증 이후 MSAL이 리디렉션해야 하는 애플리케이션의 홈페이지 또는 페이지입니다.\n\n![이미지](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_3.png)\n\n[Register] 버튼을 클릭하면 애플리케이션에 대한 Application Id를 받을 수 있습니다.\n\n![image](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_4.png)\n\n이제 테넌트 Id와 Application Id가 있으므로 Auth 구성 파일을 만들어 나아갈 수 있습니다.\n\n# 2. Auth 구성 파일\n\nsrc 폴더 안에 애플리케이션에 필요한 authConfig 파일을 추가할 수 있습니다. 이 파일에는 Msal 인스턴스 생성 시 전달될 구성이 포함되어 있습니다. 일반적인 authConfig 파일은 아래와 같이 나타날 것입니다.\n\n```js\n// Code snippet 1 – src/authConfig.js\nexport const msalConfig = {\n  auth: {\n    clientId: \"어플리케이션 ID\",\n    authority: \"https://login.microsoftonline.com/테넌트 ID\",\n    redirectUri: \"https://dev-example-app.com/\",\n  },\n  cache: {\n    cacheLocation: \"sessionStorage\", // 캐시가 저장될 위치를 구성합니다.\n    storeAuthStateInCookie: false, // IE11이나 Edge에서 문제가 있는 경우 \"true\"로 설정하세요.\n  },\n};\n/** 여기에 추가한 스코프는 사용자 로그인 시 동의를 받습니다.\n * 기본적으로 MSAL.js는 OIDC 스코프 (openid, profile, email)를 로그인 요청에 추가합니다.\n */\nexport const loginRequest = {\n  scopes: [\"User.Read\"],\n};\n```\n\n# 3. 애플리케이션에 MSAL 코드 추가\n\n@azure/msal-browser와 @azure/msal-react 패키지를 설치해야 합니다.\n\n```js\n// 코드 조각 2 - 터미널\nnpm i @azure/msal-browser @azure/msal-react\n```\n\n애플리케이션 진입점에서 PublicClientApplication 객체를 초기화하고 애플리케이션을 MsalProvider 컴포넌트로 감쌉니다.\n\n```js\n// 코드 조각 3 - src/index.js\nimport ReactDOM from \"react-dom/client\";\nimport { PublicClientApplication } from \"@azure/msal-browser\";\nimport { MsalProvider } from \"@azure/msal-react\";\nimport { msalConfig } from \"./authConfig\";\nimport App from \"./App\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nconst msalInstance = new PublicClientApplication(msalConfig);\n\nroot.render(\n  <MsalProvider instance={msalInstance}>\n    <App />\n  </MsalProvider>\n);\n```\n\n# 4. 로그인 컴포넌트\n\n\n\n\n\n여기에서는 authConfig 파일로부터 loginRequest를 가져 와서 Msal 인스턴스에 제공해야합니다. 페이지 또는 팝업으로 로그인을 추가할지에 따라 loginRedirect 또는 loginPopup 함수를 사용할 수 있습니다.\n\n```js\n// 코드 스니펫 4 - src/components/SignIn.js\nimport { useMsal } from '@azure/msal-react';\nimport { loginRequest } from '../../authConfig';\nconst SignIn = () => {\n  const { instance } = useMsal();\n  const handleLogin = () => {\n    instance.loginRedirect(loginRequest).catch((e) => {\n       console.log(e);\n  };\n  return (\n    <SignInContainer>\n      <SignInPageComponents />\n      <SignInButton onClick={() => handleLogin()}>\n         Microsoft 계정으로 로그인\n      </SignInButton>\n    </SignInContainer>\n  );\n}\nexport default SignIn;\n```\n\n만약 로그인이 팝업으로 되는 경우, Msal 인스턴스는 loginPopup 함수를 사용합니다.\n\n```js\n// 코드 스니펫 5 - src/components/SignIn.js\ninstance.loginPopup(loginRequest).catch((e) => {\n  console.log(e);\n});\n```\n\n비슷하게, Sign-Out은 logoutRedirect 또는 logoutPopup 함수로 처리할 수 있습니다.\n\n```js\n// 코드 스니펫 6 - src/components/SignOut.js\ninstance.logoutRedirect({\n  postLogoutRedirectUri: \"/\",\n});\n```\n\n```js\n// 코드 스니펫 7 - src/components/SignOut.js\ninstance.logoutPopup({\n  postLogoutRedirectUri: \"/\",\n  mainWindowRedirectUri: \"/\",\n});\n```\n\n# 5. 애플리케이션과 Sign-In 페이지 통합하기\n\nSign-In 버튼을 클릭한 후에 MSAL이 사용자를 인증합니다. 애플리케이션은 useIsAuthenticated 함수를 사용하여 인증이 성공했는지 확인할 수 있습니다. 또한, useMsal 함수는 instance, inProgress, accounts 세 개의 객체를 반환합니다. accounts 객체에는 인증된 사용자의 세부 정보가 포함되어 있습니다.\n\n```js\n// 코드 스니펫 8 - src/App.js\nimport { useMsal, useIsAuthenticated } from \"@azure/msal-react\";\nimport Header from \"./components/header\";\nimport SignIn from \"./components/signin\";\nimport Home from \"./pages/home\";\n\nconst App = () => {\n  const isAuthenticated = useIsAuthenticated();\n  const { accounts } = useMsal();\n  useEffect(() => {\n    if (accounts.length > 0) {\n      sessionStorage.setItem(\n        \"user-details\",\n        JSON.stringify({\n          name: accounts.length > 0 && accounts[0].name,\n          email: accounts.length > 0 && accounts[0].username,\n        })\n      );\n    }\n  }, [accounts]);\n  return (\n    <div>\n      {isAuthenticated ? (\n        <>\n          <Header name={accounts.length > 0 && accounts[0].name} email={accounts.length > 0 && accounts[0].username} />\n          <Home />\n        </>\n      ) : (\n        <SignIn />\n      )}\n    </div>\n  );\n};\nexport default App;\n```\n\n이 작업을 수행하는 다른 방법이 있습니다. useIsAuthenticated 함수 대신 AuthenticatedTemplate 및 UnauthenticatedTemplate 컴포넌트를 사용할 수도 있습니다. AuthenticatedTemplate으로 둘러싸인 컴포넌트는 인증이 성공한 경우에만 렌더링됩니다.\n\n```js\n// 코드 스니펫 9 - src/App.js\n\nimport { useMsal, AuthenticatedTemplate, UnauthenticatedTemplate } from '@azure/msal-react';\n. . . . (이전 코드와 같음)\nreturn (\n    <div>\n      <AuthenticatedTemplate>\n          <Header\n             name={accounts.length > 0 && accounts[0].name}\n             email={accounts.length > 0 && accounts[0].username}\n          />\n          <Home />\n      </AuthenticatedTemplate>\n      <UnauthenticatedTemplate>\n          <SignIn />\n      </UnauthenticatedTemplate>\n    </div>\n);\n```\n\n또한 인증 중에 로더를 표시하는 inProgress를 사용할 수도 있습니다.\n\n```js\n// 코드 스니펫 10 - src/components/AnyComponent.js\n\nconst { inProgress } = useMsal();\nreturn inProgress ? <Loader /> : <Component />;\n```\n\n다음 이미지는 애플리케이션의 실행을 보여줍니다.\n\n![애플리케이션 실행 이미지](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_5.png)\n\n<img src=\"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_6.png\" />\n\n<img src=\"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_7.png\" />\n\n# 6. Accessing protected Rest APIs\n\n응용 프로그램은 acquireToken 메소드 중 하나를 사용하여 보호된 Rest API에도 액세스할 수 있습니다.\n\n```js\n// Code snippet 11  - src/components/AnyComponent.js\nimport { InteractionRequiredAuthError, InteractionStatus} from \"@azure/msal-browser\";\nimport { useMsal } from \"@azure/msal-react\";\nconst AnyComponent = () => {\n  const { instance, inProgress, accounts } = useMsal();\n  useEffect(() => {\n    const accessTokenRequest = {\n      scopes: [\"user.read\"],\n      account: accounts[0],\n    };\n    if (!apiData && inProgress === InteractionStatus.None) {\n      instance\n        .acquireTokenSilent(accessTokenRequest)\n        .then((accessTokenResponse) => {\n          let accessToken = accessTokenResponse.accessToken;\n          callApi(accessToken).then((response) => {\n            // process the response data\n          });\n        })\n        .catch((error) => {\n          if (error instanceof InteractionRequiredAuthError) {\n            instance.acquireTokenRedirect(accessTokenRequest);\n            // OR  instance.acquireTokenPopup(accessTokenRequest)\n          }\n        });\n    }\n  }, [instance, accounts, inProgress]);\n  return (...)\n}\nexport default AnyComponent;\n```\n\nAPI 엔드포인트는 액세스 토큰을 Bearer Token으로 전달하여 호출됩니다.\n\n```js\n// Code snippet 12\nconst callApi = async (accessToken) => {\n  try {\n    return await axios.method(endPoint, {\n      headers: { Authorization: `Bearer ${accessToken }` });\n  } catch (error) {\n    return error.response;\n  }\n};\n```\n\n# 결론\n\n\n\n\n\n이 기사에서는 응용 프로그램을 등록하고 구성 파일을 만들고 로그인 및 로그아웃을 구현하고 응용 프로그램과 통합하는 다양한 방법을 살펴보았습니다. 추가적으로 MSAL을 사용하여 보호된 API에 액세스할 수도 있습니다. 조직에 새 직원이 합류하는 시나리오를 고려해 보겠습니다. 새 직원은 마이크로소프트 계정만 만들면 되고, 이를 통해 Outlook 및 조직의 내부 응용 프로그램에 액세스할 수 있습니다. 따라서 로그인하면 기술 지원 티켓을 작성하거나 타임시트를 기록하거나 프로젝트 세부 정보를 보거나 이메일을 보낼 수 있습니다. 또한, 관리 및 사용자 모니터링 관점에서 사용자를 관리하는 것이 더 쉬워집니다.\n\n이 기사가 유익하게 느껴졌고 필요에 따라 프로젝트에 활용할 수 있기를 바랍니다. 읽어 주셔서 감사합니다!\n\nEdstem 웹사이트에서 더 많은 통찰력 있는 블로그와 실용적인 안내서를 살펴보세요. 저희 팀은 복잡한 응용 프로그램 개발을 전문으로 하는 젊고 뛰어난 열정적인 소프트웨어 엔지니어로 구성되어 있습니다. Agile 소프트웨어 개발, 고급 DevOps 실천법, 인공지능 기능을 활용하여 소프트웨어 프로젝트를 가속화하고 혁신적인 솔루션을 제공합니다.\n\n","ogImage":{"url":"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_0.png"},"coverImage":"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_0.png","tag":["Tech"],"readingTime":9}],"page":"129","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}