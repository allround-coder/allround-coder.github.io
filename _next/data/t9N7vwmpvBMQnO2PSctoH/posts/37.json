{"pageProps":{"posts":[{"title":"내부 HTML을 사용하지 말아야 하는 이유와 대신 사용할 것","description":"","date":"2024-06-20 03:36","slug":"2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead","content":"\n\n## innerText, textContent, 및 innerHTML\n\n![이미지](/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_0.png)\n\n# 소개\n\n코딩에 입문했고 JavaScript와 HTML의 기본을 알게 되었다면, 이제 DOM을 탐색하기 시작할 준비가 된 것 같네요. JavaScript를 사용하여 HTML 요소를 선택했고, 이제 해당 요소에 콘텐츠를 추가하려고 할 때 innerHTML, textContent, innerText 속성이 모두 도와줄 수 있지만, 어떤 것을 선택해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 HTML에 빈 `li` 요소들로 이루어진 순서 없는 목록이 있다고 가정해 봅시다. 우리는 이러한 요소들에 JavaScript를 사용하여 일반 텍스트 내용을 추가하고 싶습니다.\n\n우리가 `li` 요소들에 부여한 id를 활용하여 JavaScript에서 이러한 요소들에 내용을 추가할 수 있고, 세 속성 중 아무것이나 사용해도 거의 동일하게 작동할 것입니다.\n\n여기서 볼 수 있듯이 어떤 속성을 사용하든 우리의 웹페이지에 텍스트가 항목으로 나타날 것입니다.\n\n![이미지](/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_1.png)\n\n<div class=\"content-ad\"></div>\n\n그래서, 세 개의 속성이 모두 같은 기능을 한다면, 그 목적은 무엇인가요? 각각의 차이와 innerHTML이 해커들에게 취약해지게 하는 방법, 그리고 대신에 사용할 수 있는 것을 알아보려면 계속 읽어보세요.\n\n# 각각의 콘텐츠를 페이지에 렌더하는 방법\n\n이미 존재하는 요소에 일반 텍스트를 추가하는 방법은 위에서 했던 것처럼 상당히 간단하지만, 더 복잡한 코드를 작성하고 있다면 어떨까요. 예를 들어, HTML에 `li` 태그를 입력하지 않고 JavaScript를 사용하여 추가하려고 하는 상황을 생각해보세요. 또 하나의 복잡성을 더해주기 위해, 글을 굵게 표시하기 위해 텍스트 주위에 `strong` 태그를 추가하고 싶다고 가정해 보겠습니다. 이전에 제공했던 \"list\" id를 통해 `ul` 요소를 선택한 후에, HTML 콘텐츠를 추가하고 일반 텍스트를 넣어놓는 것 역시 시작할 수 있습니다. textContent 속성을 사용하여 목록을 만들어 보겠습니다.\n\n이것이 웹 페이지에 표시되는 결과입니다:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_2.png\" />\n\n이 부분은 확실히 제대로 보이지 않아요. 만약 'textContent'를 'innerText'로 바꾼다면 어떻게 될까요?\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_3.png\" />\n\n음... 아무래도 조금 나아졌지만, 여전히 원하는 것과는 다르네요. 아마 'innerText' 대신에 'innerHTML'을 사용하면 우리가 원하는 굵은 목록을 얻을 수 있을 것 같아요.\n\n\n<div class=\"content-ad\"></div>\n\n아래는 표입니다.\n\n| 일자 | 카테고리 | 주제 |\n| ---- | -------- | ---- |\n| 6월 20일 | 웹 개발 | innerHTML의 단점 | \n\n내용이 완벽해 보여요! innerHTML이 여기서 멋지게 작동하고 있지만, 웹 페이지에 문제를 일으킬 수 있는 상당히 중요한 단점이 몇 가지 있습니다.\n\n# innerHTML의 단점\n\n## 사이버 보안 문제\n\n<div class=\"content-ad\"></div>\n\n모든 세 속성(textContent, innerText 및 innerHTML)은 빈 요소에 콘텐츠를 추가하는 것뿐만 아니라 기존 콘텐츠를 대체합니다. innerHTML은 단순한 문자열이 아닌 실제 HTML 코드 조각을 포함하는 콘텐츠를 추가할 수 있기 때문에 보안 위험을 야기할 수 있습니다. 예를 들어 innerHTML을 사용하여 웹페이지에 제출 양식을 만들고 누군가 악성 콘텐츠를 제출하면 본인 뿐만 아니라 웹사이트나 프로젝트의 다른 사용자에게 실제 문제가 발생할 수 있습니다. 이러한 이유로 보안 검토를 받을 예정인 사이트나 프로젝트의 경우, innerHTML 사용은 테스트를 통과하지 못하고 거부당할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_5.png\" />\n\n## 비효율성\n\n또 다른 innerHTML의 단점은 다른 옵션에 비해 느립니다. 예를 들어, 코드에서 이전에 생성한 배열이나 어쩌면 API에서 가져온 수백 개 또는 수천 개의 아이템이 있는 배열에 대해 각 항목에 대해 새 요소를 만들어야 하는 프로젝트를 작업 중이라고 가정해봅시다. innerHTML을 사용하면 이 데이터를 로드하는 데 몇 초가 걸릴 수 있습니다. 오늘날 온라인 사용자에게 속도가 매우 중요한 요소인만큼, 이 몇 초가 빠르게 누적될 수 있습니다. Digital.com의 기사에 따르면 온라인 쇼핑객의 53%가 3초 이상 걸리는 전자상거래 웹사이트를 방문하지 않을 것이라고 합니다 (Leng, 2022). 다행히 JavaScript를 사용해 HTML 요소를 추가할 때 다른 옵션이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 사용 대신할 것\n\n## HTML 추가하기\n\n우리는 innerHTML을 사용하여 한 번에 HTML 요소와 텍스트 문자열을 추가하는 방법을 보았습니다. 또한 이렇게 하는 것의 단점을 살펴보았습니다. 우리의 코드를 안전하고 효율적으로 만드는 좋은 대안은 이러한 작업을 분리하는 것입니다.\n\n위의 그림에서, 우리는 'greetings'라는 배열에 우리의 인사말을 입력했습니다. 그런 다음 이 배열에 대한 'forEach' 루프를 만들었고, 배열의 각 항목에 대해 새로운 li 태그를 만들도록 지시했습니다. 새로운 강조 태그를 만들고, ul 요소를 선택하고, 방금 선택한 ul 요소에 새로 만든 li 태그를 추가하고, 해당 li 태그에 새로 만든 강조 태그를 추가하고, 배열에서 가져온 텍스트 항목을 입력하도록 했습니다. 휴, 많이 보일 수 있지만, 보다 간단하게 쪼개면, 우리는 원하는 HTML 요소를 생성하고, 그 위치를 선택하고, 해당 위치에 추가하고, 텍스트를 추가하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## innerText 대 textContent\n\n만약 HTML을 삽입할 필요가 없는 경우, 콘텐츠를 추가할 요소를 선택하고 innerText 또는 textContent로 텍스트를 입력할 수 있습니다. 일반적으로 messy한 코드를 생성할 수 있는 textContent 대신 innerText를 선택하는 것이 좋습니다. 예를 들어, `li` 태그 아래에 텍스트를 작성하고 세 줄로 나누었다고 가정해 봅시다.\n\n그런 다음 JavaScript에서 innerText와 textContent를 사용하여 해당 텍스트를 콘솔에 출력했습니다.\n\n아래에서 확인할 수 있듯이 innerText는 콘솔에 내용을 표시할 때 페이지에 표시되는 방식과 유사하게 나타내며, textContent는 동일한 콘텐츠를 콘솔에 출력할 때 처음에 HTML에 입력된 방식과 더 유사하게 출력됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_6.png\" />\n\n# 결론\n\n간편성 때문에 innerHTML을 사용하기 유혹받을 수 있지만, 웹 페이지의 로딩을 느리게 만들고 보안 위험을 초래할 수 있으므로 innerHTML을 피하고 요소를 생성하고 텍스트를 추가하는 작업을 분리하는 것이 좋습니다. textContent와 innerText 모두 원하는 텍스트를 안전하게 추가할 수 있지만, innerText는 콘솔에서 내용을 더 명확하게 표시하기 때문에 일반적으로 선호됩니다. innerHTML, textContent 및 innerText 간의 차이를 명확히 해주고 어떤 것을 사용할지 결정하는 데 도움이 되었기를 바랍니다. 즐거운 코딩 되세요!\n\n## 출처\n\n\n<div class=\"content-ad\"></div>\n\n\n[Element.innerHTML.](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)\n\nLeng, Allen. [“1 In 2 Visitors Abandon a Website That Takes More than 6 Seconds to Load.”](https://digital.com/1-in-2-visitors-abandon-a-website-that-takes-more-than-6-seconds-to-load/#:~:text=However%2C%20when%20it%20comes%20to,will%20leave%20after%20one%20second.)\n","ogImage":{"url":"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_0.png"},"coverImage":"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_0.png","tag":["Tech"],"readingTime":5},{"title":"CSS 레이아웃 및 반응 형성 Flexbox, Grid 및 미디어 쿼리 마스터하기","description":"","date":"2024-06-20 03:34","slug":"2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries","content":"\n\n웹 레이아웃을 잘 구조화하고 반응형으로 만드는 것은 어려울 수 있지만, CSS는 이 작업을 쉽게 만들어 주는 강력한 도구를 제공합니다.\n\n이 포스트에서는 두 가지 필수적인 CSS 레이아웃 방법인 플렉스박스와 그리드를 탐색할 것입니다. 또한, 반응형 디자인을 위한 중요한 개념인 미디어 쿼리에 대해 알아볼 것입니다.\n\n이 글을 끝까지 읽으면, 이러한 도구들을 사용하여 유연하고 반응형 웹 페이지를 만드는 방법에 대해 확실하게 이해하게 될 것입니다.\n\n# 왜 CSS 레이아웃 방법이 중요한 이유\n\n<div class=\"content-ad\"></div>\n\n구체적인 내용에 들어가기 전에 CSS 레이아웃 방법이 왜 중요한지 이해해 봅시다. 전통적인 레이아웃 기술인 플로트(floats) 사용은 종종 복잡하고 유지보수하기 어려운 코드로 이어집니다.\n\n플렉스박스(Flexbox)와 그리드(Grid)는 정렬, 간격 및 반응형 동작과 같은 일반적인 문제를 해결하면서 더 효율적이고 직관적인 레이아웃 설계 방법을 제공합니다.\n\n# Flexbox: 유연한 박스 레이아웃\n\n플렉스박스(Flexbox) 또는 유연한 박스 레이아웃은 하나의 축(수평 또는 수직)을 따라 공간을 분배하도록 디자인되었습니다. 컨테이너 내에서 항목을 정렬하고 공간을 분배하는 것을 쉽게 만들어 줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 플렉스박스를 사용해야 하는 경우:\n\n- 일차원 레이아웃(예: 네비게이션 바, 행이나 열에 아이템 정렬).\n- 컨테이너 내에서 공간을 분배하고 아이템을 정렬해야 할 때.\n\n## 기본 플렉스박스 예시:\n\nHTML:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Flex Box example</title>\n</head>\n\n<body>\n    <div class=\"flex-container\">\n        <div class=\"flex-item\">Item 1</div>\n        <div class=\"flex-item\">Item 2</div>\n        <div class=\"flex-item\">Item 3</div>\n    </div>\n</body>\n\n</html>\n```\n\n## CSS:\n\n```js\n.flex-container {\n  display: flex;\n  justify-content: space-between; /* Distributes space evenly */\n  align-items: center; /* Aligns items vertically centered */\n  padding: 10px;\n  background-color: #f0f0f0;\n  flex-wrap: wrap; /* Wraps items if they don't fit */\n}\n.flex-item {\n  background-color: #007bff;\n  color: white;\n  padding: 20px;\n  margin: 5px;\n  flex: 1 1 200px; /* 1:1:200px grow: shrink: basis*/\n}\n```\n\n## What the code displays\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_0.png\" />\n\n## Flexbox로 해결하는 문제들:\n\n- 컨테이너 내에서 항목을 수평 또는 수직으로 정렬.\n- 항목들 사이에서 공간을 균등하게 분배.\n- 복잡한 계산 없이 다양한 화면 크기에 맞게 레이아웃 조정.\n\n## Flexbox의 제한사항:\n\n<div class=\"content-ad\"></div>\n\n- 하나의 차원적 레이아웃을 위해 디자인되었으며, 따라서 행이나 열 중 하나만 처리하고 동시에 둘 다 처리하지는 않습니다.\n\n# CSS Grid: 이차원 레이아웃\n\nCSS Grid Layout 또는 격자(Grid)는 두 차원 레이아웃을 만들기 위한 강력한 도구입니다. 행과 열을 둘 다 포함하는 복잡한 레이아웃을 디자인할 수 있습니다.\n\n## Grid을 사용해야 하는 경우:\n\n<div class=\"content-ad\"></div>\n\n- 2차원 레이아웃(예: 포토 갤러리, 복잡한 웹 페이지 레이아웃)에 사용됩니다.\n- 행과 열을 모두 정확하게 제어해야 할 때 유용합니다.\n\n## 기본 그리드 예시:\n\nHTML:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CSS Grid Example</title>\n</head>\n\n<body>\n    <div class=\"grid-container\">\n        <div class=\"grid-item\">아이템 1</div>\n        <div class=\"grid-item\">아이템 2</div>\n        <div class=\"grid-item\">아이템 3</div>\n        <div class=\"grid-item\">아이템 4</div>\n        <div class=\"grid-item\">아이템 5</div>\n        <div class=\"grid-item\">아이템 6</div>\n        <div class=\"grid-item\">아이템 7</div>\n        <div class=\"grid-item\">아이템 8</div>\n    </div>\n</body>\n\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\nCSS:\n\n```js\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr); /* 2개의 동일한 너비의 열을 생성합니다 */\n  gap: 10px; /* 항목 사이의 간격을 추가합니다 */\n  padding: 10px;\n  background-color: #f0f0f0;\n}\n.grid-item {\n  background-color: #007bff;\n  color: white;\n  padding: 20px;\n  text-align: center;\n}\n```\n\n## 코드 결과\n\n<img src=\"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 그리드의 문제를 해결하는 부분:\n\n- 행과 열을 활용한 복잡한 레이아웃 생성.\n- 레이아웃 내 항목의 크기와 위치 제어.\n- 광범위한 미디어 쿼리 없이 반응형 디자인을 손쉽게 만들기.\n\n## 그리드의 제한점:\n\n- 간단한 레이아웃에는 부담스러울 수 있으며, 해당 경우 플렉스박스가 더 적합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 미디어 쿼리를 활용한 반응형 디자인\n\n미디어 쿼리는 반응형 디자인의 중요한 요소로, 화면 너비와 같은 기기 특성에 따라 다른 스타일을 적용할 수 있게 해줍니다.\n\n이를 통해 레이아웃이 다양한 화면 크기에 적응하여 더 나은 사용자 경험을 제공할 수 있습니다.\n\n## 기본적인 미디어 쿼리 예시:\n\n<div class=\"content-ad\"></div>\n\nMarkdown:\n\n\n# Media Query Example\n\n```css\n.responsive-container {\n  display: flex;\n  flex-wrap: wrap; /* Allows items to wrap to the next line */\n  gap: 10px;\n  background-color: #f0f0f0;\n  padding: 10px;\n}\n.responsive-item {\n  flex: 1 1 100%; /* Takes full width on small screens */\n  background-color: #007bff;\n  color: white;\n  padding: 20px;\n  text-align: center;\n}\n```\n\n**Media query for screens wider than 600px:**\n```css\n@media (min-width: 600px) {\n  .responsive-item {\n    flex: 1 1 calc(50% - 20px); /* Takes half the width on larger screens */\n  }\n}\n```\n\n**Media query for screens wider than 900px:**\n```css\n@media (min-width: 900px) {\n  .responsive-item {\n    flex: 1 1 calc(33.33% - 20px); /* Takes a third of the width on even larger screens */\n  }\n}\n```\n\n```html\n<div class=\"responsive-container\">\n  <div class=\"responsive-item\">Item 1</div>\n  <div class=\"responsive-item\">Item 2</div>\n  <div class=\"responsive-item\">Item 3</div>\n  <div class=\"responsive-item\">Item 4</div>\n  <div class=\"responsive-item\">Item 5</div>\n  <div class=\"responsive-item\">Item 6</div>\n  <div class=\"responsive-item\">Item 7</div>\n  <div class=\"responsive-item\">Item 8</div>\n  <div class=\"responsive-item\">Item 9</div>\n  <div class=\"responsive-item\">Item 10</div>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n## 미디어 쿼리가 해결하는 문제:\n\n- 다양한 화면 크기에 레이아웃을 적응시키기.\n- 다양한 장치 (데스크톱, 태블릿, 모바일)에서의 사용 향상.\n- 장치 특성에 따라 조건부로 스타일을 적용하기.\n\n# 결론\n\n플렉스박스와 그리드와 같은 CSS 레이아웃 기법 및 미디어 쿼리를 사용한 반응형 디자인 원칙을 이해하고 숙달하는 것은 현대 웹 개발에 필수적인 기술입니다.\n\n<div class=\"content-ad\"></div>\n\n이 도구들은 유연하고 적응 가능하며 사용자 친화적인 웹 레이아웃을 만드는 과정을 간편화합니다.\n\n## 추가 자료:\n\n- MDN Web Docs: Flexbox\n- MDN Web Docs: CSS Grid\n- MDN Web Docs: 미디어 쿼리\n- CSS Tricks\n\n이 CSS 레이아웃 방법과 미디어 쿼리를 활용하여 아름다운 반응형 웹 디자인을 만들어 보세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_0.png"},"coverImage":"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_0.png","tag":["Tech"],"readingTime":6},{"title":"웹소켓, NodeJS를 사용하여 Kafka 앱을 처음부터 만들면서 배운 교훈","description":"","date":"2024-06-20 03:33","slug":"2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o","content":"\n\n예전에 나는 HTML5 앱을 개발하는 일을 했었어요. 새롭게 인가된 WebSocket 표준의 강력함을 보여주는 앱들이었죠. 데이터 스트리밍 데모와 튜토리얼의 공통된 문제는 데이터의 소스입니다. 데이터는 풍부해야 하며(내 발코니의 온도 데이터는 변화가 느리고 따라서 지루합니다) 확인 가능해야 합니다(랜덤한 데이터는 시각화할 수 없습니다). 사람이 만들고 이해하기 쉬운 데이터를 사용하는 것이 종종 좋은 해결책입니다. 이 문제를 해결하기 위해 과거에 제가 개발한 앱 중 하나는 다중 사용자 드로잉 앱이었어요. 이 앱은 한 사용자의 상호작용을 다른 사용자 화면에 반영했죠.\n\n저는 Apache Kafka와 함께 일하기 시작한 이후로 Kafka 백엔드를 가진 이 간단한 데모 앱을 만들고 싶어했어요. 여러 날이 걸릴 것 같아서 미뤄왔었는데, 그리고 시간이 부족하다고 느꼈었죠.\n\n# 데모 앱에 대해\n\n저의 고수준 목표는 Kafka를 Node.js에 연결하고 Node.js가 WebSocket을 통해 브라우저와 대화할 수 있도록 하는 것이에요. 두 개의 별개의 웹 앱을 가지고 싶어요: 드로잉에 사용하는 프로듀서 앱과 다른 기기에서 드로잉을 반영하는 소비자 앱이에요. Kafka 백엔드로는 Confluent Cloud를 사용하고 싶은데, 그 이유는 Confluent에서 일하고 있기 때문일 뿐만 아니라 이와 같은 실험에 적합한 간단하고 정교한 클라우드 환경이기 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n마침내 결정해서 새로운 도전을 해보기로 했어요. 하지만 조금 다르게 해보려고 했어요: 최근에 출시된 ChatGPT-4o가 얼마나 도움이 될지 직접 시험해보고 싶었어요. 이 게시물에서는 ChatGPT와의 상호작용과 여정, 우리가 마주친 오류들, 그리고 어떻게 해결했는지에 대한 소개를 할 거예요. (내가 이 모델을 이미 사람처럼 취급하고 있다는 게 참 재미있다고 생각해.)\n\n# 아키텍처 개요\n\n![Architecture Overview](/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_0.png)\n\nConfluent Cloud에서 실행되는 Kafka 클러스터가 우리 앱의 중심에 있어요. 메시지는 drawing_topic으로 발행하고 소비해요. Kafka 상호작용의 핵심 부분은 프로듀서(왼쪽)와 컨슈머(오른쪽) Node.js 앱에 의해 처리돼요. 마지막으로, 발행해야 하는 데이터(그리기 좌표 및 그림과 관련된 일부 메타데이터)는 각각 브라우저에서 실행되는 HTML5 앱에 의해 생성(왼쪽) 및 렌더링(오른쪽)돼요.\n\n<div class=\"content-ad\"></div>\n\n# ChatGPT가 얼마나 도움이 되었나요?\n\nChatGPT의 성능에 관해 말하자면 (Github의 소스를 참고): 저는 ChatGPT의 성능에 깊은 감명을 받았습니다! 첫 번째 시도로 간단하지만 작동하는 앱을 만들어냈습니다. 문제를 작은 단위로 쪼개고 테스트할 수 있는 단계로 나누어 진행했기 때문에 전체 과정에서 운전자의 자리에 있었습니다. ChatGPT는 두 가지 오류를 범했지만, 제가 지적하자 바로 해결했습니다. 이 연습의 한 부분으로, 모든 프롬프트, 응답, 그리고 코드 조각들을 자세하게 공유하고자 합니다. 이를 통해 우리 빠르게 변화하는 세상에 대한 일부 힌트나 스냅샷이 될 것이라고 생각합니다.\n\n저는 깊은 인상을 받았지만 동시에 걱정도 되고 있습니다. 우리의 이 새로운 세계가 실패할 위기의 상황이 되지 않기를 소망하며요.\n\n# 작동 중인 앱\n\n<div class=\"content-ad\"></div>\n\n여기 앱이 어떻게 동작하는지 보여주는 GIF 파일이 있어요. 왼쪽 브라우저에서 마우스로 그림을 그리고 있어요. 그 아래에 있는 터미널 창에서 Node.js 애플리케이션이 Kafka 토픽에 메시지를 발행하고, 메시지가 스크롤되고 있어요. 오른쪽에는 다른 브라우저에서 메시지를 소비하는 것을 볼 수 있어요. 제 그림을 그리는 영역 아래에는 Chrome 개발자 도구 콘솔에서 소비 앱에 도착한 메시지를 보여줘요.\n\n중요한 점은 두 브라우저가 로컬에서 실행되는 것이지만 (내 컴퓨터에서 실행 중), 메시지가 흐르는 Kafka 클러스터는 클라우드에 위치하고 있다는 것이에요. 이 애플리케이션은 이와 같은 시스템에서 기대할 수 있는 대략적인 지연 시간에 대한 아이디어를 제공해줍니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*6mgRUEq_ou44GxWiaU7FPg.gif\" />\n\n# 목차 — 어떤 식으로든\n\n<div class=\"content-ad\"></div>\n\n우리가 가는 방향에 대한 아이디어를 주기 위해, 여기 ChatGPT에 제공한 모든 프롬프트를 읽을 수 있습니다. 이 글의 목차 같은 역할을 할 수 있어요. GitHub 저장소로 바로 이동하거나 아래 프롬프트를 따라올 수 있습니다.\n\n시작해 보겠습니다...\n\n프롬프트 1\n\nChatGPT의 답변 및 모든 소스 코드를 보려면 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n프롬프트 4\n\nChatGPT의 답변 및 모든 소스 코드를 확인하려면 클릭하세요.\n\n프롬프트 5\n\nChatGPT의 답변 및 모든 소스 코드를 확인하려면 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 다음 단계\n\n이 포스트에서는 앱을 간단히 유지하고 싶었지만, 몇 가지 아이디어가 더 발전할 수 있을 것 같아요:\n\n- UI 개선, CSS로 앱 꾸미기: 현재 UI의 스크린샷을 찍어 모델에게 CSS 개선 제안을 해달라고 요청하세요. 색상, 선 굵기, 지우기, 되돌리기 등 여러 기능을 추가하여 봄.\n- 음성 명령을 포함한 자연어 기능 추가: 그대신 그림을 그리도록 음성 명령에 대한 기능을 추가하세요.\n- 소비자 및 프로듀서 HTML5 앱 병합: 이들을 하나로 결합하여 전체 협업 경험을 제공하는 단일 앱으로 만드세요. 이렇게 하면 모든 클라이언트가 그림을 그리고 다른 클라이언트의 그림을 보는 것이 가능해져서 Google 문서와 유사한 경험을 제공할 수 있어요.\n- 백엔드 아키텍처 간소화: 두 개의 Node.js 앱을 하나의 앱으로 병합하여 코드를 최적화하고 앱을 더 쉽게 관리할 수 있도록 만드세요.\n- Kafka와 영속 메시지 로그를 활용하는 것을 고려하면, 메시지를 되돌려 다시 그림을 그릴 수도 있어요. 각 메시지에 연관된 타임스탬프를 사용하여 그림을 빨리 또는 천천히 그릴 수도 있어요.\n\n<img src=\"/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n모델의 도움을 받아 약 한 시간 만에 완전히 작동하는 프로토 타입 앱을 만들 수 있었습니다. 생산 준비가 된 상태는 아니지만, 보통의 귀찮음과 기술적인 어려움이 대부분 없는 기술을 배우는 놀라운 방법입니다.\n\n나는 목표를 명확히 가지고 이 연습에 임했습니다. 이벤트 주도 방식으로 문제를 해결하는 방법, 클라이언트 및 서버 측에서 사용하려는 기술, 그리고 서로 통신하는 방법에 대해 알고 있었습니다. 게다가, 모델을 안내할 그림 그리기 앱의 예도 있었습니다.\n\n두 번의 경우에 솔루션이 조금 부적절했습니다 (프롬프트 4 및 7). 코드에 문제가 있는 이유에 대해 의아해할 수 있습니다. 이 부분에서는 시간이 지남에 따라 상당한 개선이 예상됩니다. 제 프롬프트가 다소 모호했을 수도 있고, 모델이 제 목표를 완벽하게 이해하지 못했을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이번 연습에서 코드 작성에 집중하지 않았지만, 문제를 마주했을 때 명확한 증상과 오류 메시지를 제공하여 모델의 도움을 효과적으로 활용했습니다. 구글링, StackOverflow 검색 또는 문서 읽기는 필요하지 않았어요 — 간단한 영어 프롬프트만 있으면 돼요.\n\n지식을 나누고 전달하는 데 열정을 가진 사람으로써 나는 항상 YouTube를 지식을 민주화하는 최고의 도구로 보아왔어요. 이 연습은 대형 언어 모델이 많은 이전 가정에 도전하며 이를 다음 수준으로 이끌고 있다는 것을 보여줍니다.\n\n우리는 몇 년 전과는 근본적으로 다른 세상에서 살고 있으며, 나는 그것이 나를 흥분시키고 동시에 걱정도되도록 느끼게 해요.","ogImage":{"url":"/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_0.png"},"coverImage":"/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_0.png","tag":["Tech"],"readingTime":5},{"title":"Pumpi - 유기농 채소 쇼핑몰 20 테마","description":"","date":"2024-06-20 03:32","slug":"2024-06-20-PumpiOrganicVegetablesShopify20Theme","content":"\n\n🔍 Pumpi- Organic Vegetables Shopify 2.0 테마를 확인해보세요! 📁 Shopify CMS 템플릿 라이브러리를 살펴보고 🆓 무료 다운로드를 받아보세요. 함께 만들어 봐요! 🚀\n\nPumpi는 유기농 식품을 위해 특별히 디자인된 테마에요. 유기농 식품은 기존 식품보다 항산화제와 영양소가 더 많을 수 있지만, 아직까지 그 증거는 매우 제한적이에요. 유기농 식품을 섭취하면 인공 화학물질, 호르몬 및 항생제에 저항성이 있는 박테리아에 노출될 위험이 줄어들 수 있어요.\n\nPumpi는 스마트 필터를 갖춘 완벽한 스토어 프론트를 지원해요. 페이지가 로드되길 기다릴 필요 없이 초고속으로 제공될 거에요. 또한 Instant Product Search 시스템을 갖춘 Pumpi는 입력하는 대로 즉시 결과를 찾아주며, 시간을 기다릴 필요가 없어요. Pumpi 테마는 SEO 친화적으로 설계되었으며 HTML 5 표준을 준수해요. 많은 기사나 동일한 페이지에서 로드되는 다양한 제품이 있더라도 가장 빠른 페이지 로드 속도를 제공하도록 설계되었어요.\n\nPumpi는 코드 지식이나 웹마스터 없이도 누구나 쉽게 사용할 수 있어요. 모든 데모는 한 번의 클릭으로 빠르게 가져올 수 있어요. 체험하기 위해 데모를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n테마 기능\n\n- 섹션 드래그 & 드롭 페이지 빌더\n- 전체 Oberlo 호환성\n- 약관 및 동의 사항 카트에 추가\n- 함께 구매하기\n- 업셀 제품\n- 서브 컬렉션 페이지\n- 페이스북 채팅\n- 다이내믹 체크아웃 준비\n- 새로운 룩북\n- 주문제품 알림\n- 360도 제품 뷰\n- 카트에 추가 팝업\n- 고급 변수 스와치\n- Ajax 제품\n- Ajax 검색\n- 소셜 공유\n- 모바일 기기에 최적화\n- 고정 ATC 및 소셜\n- 사이즈 안내 팝업\n- 강력한 필터\n- 인스타그램 샵\n- 팝업 로그인\n- 자동 가격 변경\n- 유연한 내장형 메가 메뉴\n- 퀵뷰 제품 색상\n- 스마트 제품 퀵뷰\n- 고급 계층적 네비게이션\n- 무제한 구글 폰트\n- 사이트 식별\n- 헤더 및 푸터 스타일 옵션\n- 내장형 놀라운 슬라이더\n- 무제한 색상\n- SEO 최적화\n- “New”, “Hot”, “Sale”… 레이블\n- 다국화 지원\n- 놀라운 레이아웃 변화\n- 뉴스레터\n- 반응형 및 레티나 대응\n- 헤더에 드롭다운 장바구니\n- 다양한 스티키 헤더 스타일\n- Ajax 장바구니 & 위시리스트 추가\n- Ajax 페이징 및 Ajax 도구 모음 내장\n- Ajax 그리드 및 목록 보기 컬렉션\n- 제품 보기 페이지에 이전 및 다음 기능\n- 업셀 제품 및 관련 제품 블록용 슬라이더\n- 내장 제품 확대 기능\n- 베스트셀러 제품\n- 맨 위로 버튼\n- 배경 패턴 및 색상 선택기\n- 탭\n- 그리드 / 목록 보기\n- 제품 속성에 대한 \"추가 정보\" 탭\n- 브랜드 로고 슬라이더\n- 내장된 블로그 포스트 슬라이더\n- FontAwesome 아이콘\n- 원 클릭 가져오기\n- 크로스 브라우저 지원\n- 고객 리뷰\n- 연락처\n- 제품 캐러셀\n- HTML5 및 CSS3 및 Sass CSS\n- 소셜 네트워킹\n- 온라인 24/7 지원\n- 상세 문서화\n\n![이미지](/assets/img/2024-06-20-PumpiOrganicVegetablesShopify20Theme_0.png)\n\nEngoTheme님의 Envato Elements에서 제공하는 사진\n\n<div class=\"content-ad\"></div>\n\n면책 조항: 본 글에는 제휴 링크가 포함되어 있습니다. 이는 이 링크를 통해 구매를 하시는 경우 추가 비용 없이 수수료를 받을 수 있음을 의미합니다.","ogImage":{"url":"/assets/img/2024-06-20-PumpiOrganicVegetablesShopify20Theme_0.png"},"coverImage":"/assets/img/2024-06-20-PumpiOrganicVegetablesShopify20Theme_0.png","tag":["Tech"],"readingTime":2},{"title":"앵귤러 애플리케이션에서의 environmentts 파일에 대하여","description":"","date":"2024-06-20 03:30","slug":"2024-06-20-AboutenvironmenttsinyourAngularapplications","content":"\n\n`<img src=\"/assets/img/2024-06-20-AboutenvironmenttsinyourAngularapplications_0.png\" />`\n\nEnvironment.ts는 애플리케이션 설정을 보관하는 일반적인 장소입니다. Angular 애플리케이션의 컴포넌트, 파이프 또는 다른 TypeScript 파일에 설정을 직접 하드코딩하는 대신 환경 파일에 애플리케이션 설정을 저장하면 다양한 애플리케이션 환경에서 다른 설정을 가질 수 있습니다. 또한, 모든 애플리케이션 설정이 한 파일에 집중되어 필요에 따라 쉽게 수정할 수 있습니다.\n\n환경.ts는 Angular 문서에서 잘 문서화되어 있지만 Angular 애플리케이션 구축 및 실행 주제에서 유지됩니다. 따라서 일부 사용자는 환경.ts 파일의 사용법을 모를 수 있습니다.\n\n# 면책 조항\n\n<div class=\"content-ad\"></div>\n\n이 문서는 Angular 공식 문서와 거의 유사합니다. 환경 설정을 더 잘 다루는 방법을 이해할 수 있도록 이 문서에 추가 정보를 포함했습니다. 이 문서는 오래되었을 수 있으니 항상 최신 정보를 참조하려면 공식 Angular 문서를 참고하세요: Angular 애플리케이션 빌드 및 제공.\n\n# 환경 폴더 구조\n\n모든 Angular 프로젝트에 environments 폴더가 있습니다. 이 폴더는 모든 애플리케이션 설정이 환경별로 보관되는 곳입니다. environment.ts는 기본 환경 파일로 프로젝트에서 참조됩니다.\n\n```js\nyourProject/src/environments\n- environment.ts\n- environment.prod.ts\n```\n\n<div class=\"content-ad\"></div>\n\n# environment.ts 파일 사용 방법\n\n여러 개의 파일이 environments 폴더에 있기 때문에 무엇을 가져와야 할지 궁금할 수 있습니다. 애플리케이션 설정을 사용하려면 environment.ts 파일을 가져오기만 하면 됩니다. 아래에서 이유를 설명하겠습니다.\n\n```js\nimport { environment } from './../environments/environment';\n```\n\n아래 스니펫은 app.component.ts가 environment.ts 파일에서 변수를 사용하는 방법을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// app.component.ts\nimport { Component } from '@angular/core';\nimport { environment } from './../environments/environment';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  constructor() {\n    if(environment.production) { // 👈🏻👈🏻👈🏻\n      // 만약 이것이 프로덕션 환경이라면 구현 코드 작성\n    }\n  }\n  title = 'app works!';\n}\n```\n\n# environment.ts 파일의 production 변수\n\n새로운 Angular 애플리케이션을 생성할 때마다 미리 설정된 production 변수를 찾을 수 있습니다.\n\n```js\n// 이 파일은 `fileReplacements` 배열을 사용하여 빌드 중에 대체될 수 있습니다.\n// `ng build --prod`는 `environment.ts`를 `environment.prod.ts`로 대체합니다.\n// 파일 대체 목록은 `angular.json`에서 찾을 수 있습니다.\n\nexport const environment = {\n  production: false // 👈🏻👈🏻👈🏻\n};\n```\n\n<div class=\"content-ad\"></div>\n\n질문: 이 변수를 삭제할 수 있을까요? 답은 아니요입니다. 왜냐하면 이 변수는 main.ts에서 사용되어 있어서 production 변수가 true로 설정된 경우 production 모드를 활성화하는 데 사용됩니다. Production 모드를 활성화하면 Angular은 변경 감지 과정이 어떤 바인딩에 추가 변경 사항이 생기지 않는지 확인하여 응용 프로그램 성능을 향상시킵니다 (일방향 데이터 흐름이라고도 함). 이 enableProdMode 메서드에 대해 자세히 다루지는 않겠습니다. enableProdMode에 대해 더 알고 싶다면 이 기사에서 enableProdMode가 무엇을 하는지 자세히 읽어보시기 바랍니다: https://lukaonik.medium.com/what-is-the-difference-between-production-and-development-mode-in-angular-3eed82b9cf73. 다시 말해서, 응용 프로그램을 디버깅하지 않을 때는 production 변수를 항상 true로 설정해야 합니다.\n\n```js\nimport { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode(); // 👈🏻👈🏻👈🏻\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n```\n\n팁: Angular은 앱이 개발 모드에서 실행 중인지 확인하기 위한 유틸리티 함수를 제공합니다.\n\n```js\nimport { Component, OnInit, isDevMode } from '@angular/core';\n\n@Component({ ... })\nexport class AppComponent implements OnInit {\n  ngOnInit() {\n    if (isDevMode()) { // 👈🏻👈🏻👈🏻\n      console.log('Development!');\n    } else {\n      console.log('Production!');\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# environment.ts 파일에 변수를 추가하고 Angular 애플리케이션에서 이 변수를 사용하세요.\n\n필요에 따라 environment.ts 파일에 하나 이상의 변수를 추가할 수 있습니다. environment.ts에 enableLogging이라는 간단한 변수를 추가해 봅시다:\n\n```js\n// environment.ts\n\n// 이 파일은 `fileReplacements` 배열을 사용하여 빌드 중에 교체될 수 있습니다.\n// `ng build --prod`는 `environment.ts`를 `environment.prod.ts`로 대체합니다.\n// 파일 교체 목록은 `angular.json`에서 찾을 수 있습니다.\n\nexport const environment = {\n  production: false,\n  enableLogging: true\n};\n```\n\n새로 추가된 이 변수를 사용하려면 environment.ts 파일을 import하여 Angular 애플리케이션의 모든 TypeScript 파일에서 사용하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// app.component.ts\n\nimport { Component } from '@angular/core';\nimport { environment } from './../environments/environment'; // 👈🏻👈🏻👈🏻\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  constructor() {\n    if(environment.enableLogging) { // 👈🏻👈🏻👈🏻\n      console.log('Angular app started');\n    }\n  }\n  title = 'app works!';\n}\n```\n\n# 환경별 응용 프로그램 설정 구성\n\n일반적으로 한 애플리케이션 당 여러 환경이 있습니다. Angular 애플리케이션의 설정은 개발자마다 다를 수 있습니다. 그럼에도 불구하고 추가 환경을 구성하려면 개발 및 프로덕션 환경 이외의 환경을 설정해야 합니다.\n\n기본적으로 Angular 애플리케이션에는 environment.ts 및 environment.prod.ts가 있습니다. 저는 개발 환경으로 environment.ts를 사용합니다. 지역에서 Angular 애플리케이션을 개발하기 때문에 명령에 추가 인수를 추가할 필요가 없고, environment.ts가 기본 설정으로 사용됩니다. 반면 프로덕션 환경에서는 ng serve --configuration production과 같은 추가 매개변수를 전달해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n기존 Angular 애플리케이션을 위한 스테이징 환경을 구성해 보겠습니다.\n\n먼저 environments 폴더에 새 파일을 추가해야 합니다. 파일의 네이밍 컨벤션은 environment.`environment_name`.ts 입니다. environment.staging.ts 라는 파일을 다음 내용과 함께 생성해 봅시다:\n\n```js\n// environments/environment.staging.ts\nexport const environment = {\n  production: true // 애플리케이션을 디버깅 중이 아니라면 true\n};\n```\n\n그 다음, environment.ts에 있는 모든 변수는 이 environment.staging.ts에 있어야 합니다. 왜냐하면 environment.staging.ts가 컴파일 시(environment.ts 파일 대체) 필요하기 때문입니다 (ng serve 또는 ng build). 따라서 environment.staging.ts 파일에 누락된 변수가 없어야하며, 그렇지 않으면 컴파일이 실패할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n안전을 위해 environment.ts의 내용을 environment.staging.ts로 복사한 후 environment.staging.ts의 설정을 스테이징 설정으로 수정하세요. 이제 environment.staging.ts를 마친 것입니다.\n\nng build를 위한 angular.json 확장\n\nng build 명령어는 Angular 애플리케이션을 컴파일하는 데 사용됩니다. 스테이징 환경으로 애플리케이션을 컴파일해야 할 때는 ng build --configuration staging이 필요합니다. 이 명령어를 실행하려고 하면 지금처럼 오류 메시지가 나올 것입니다.\n\n이는 angular.json에서 스테이징 구성을 설정하지 않았기 때문입니다. 루트 폴더의 angular.json으로 이동하여 build configurations에서 production 구성을 복사하고 (아래 스니펫에서 production 구성 위치를 확인하십시오), 복사한 구성을 production 구성 바로 아래에 붙여넣으세요. 붙여넣은 구성의 이름을 staging으로 변경하고 파일 교체 경로를 스테이징 환경 파일 경로로 설정하세요. 이제 ng build --configuration staging을 다시 실행하면 성공적으로 빌드할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n만약 주목했다면, configurations 맨 끝에 defaultConfiguration 설정이 있습니다. 이 설정은 ng build를 실행할 때 기본 구성을 설정하는 것입니다. 어떤 구성도 지정하지 않았다면 빌더는 defaultConfiguration에서 구성을 사용합니다. 지금 ng build를 실행하면 기본 구성은 프로덕션 구성이 될 것입니다.\n\n```js\n{\n    [...]\n    \"projects\": {\n      \"your-project-name\": {\n        [...]\n        \"architect\": {\n          \"build\": {\n            [...]\n            \"configurations\": { \n              \"production\": { // 👈🏻👈🏻👈🏻 이 섹션을 복사하세요\n                \"budgets\": [\n                  {\n                    \"type\": \"initial\",\n                    \"maximumWarning\": \"500kb\",\n                    \"maximumError\": \"1mb\"\n                  },\n                  {\n                    \"type\": \"anyComponentStyle\",\n                    \"maximumWarning\": \"2kb\",\n                    \"maximumError\": \"4kb\"\n                  }\n                ],\n                fileReplacements: [\n                  {\n                    replace: 'src/environments/environment.ts',\n                    with: 'src/environments/environment.production.ts',\n                  },\n                ],\n                \"outputHashing\": \"all\"\n              },\n              \"staging\": { // 👈🏻👈🏻👈🏻 여기에 붙여넣고 staging으로 이름을 변경하세요\n                \"budgets\": [\n                  {\n                    \"type\": \"initial\",\n                    \"maximumWarning\": \"500kb\",\n                    \"maximumError\": \"1mb\"\n                  },\n                  {\n                    \"type\": \"anyComponentStyle\",\n                    \"maximumWarning\": \"2kb\",\n                    \"maximumError\": \"4kb\"\n                  }\n                ],\n                fileReplacements: [\n                  {\n                    replace: 'src/environments/environment.ts',\n                    with: 'src/environments/environment.staging.ts', // 환경 파일 경로를 staging 환경 파일 경로로 변경하세요\n                  },\n                ],\n                \"outputHashing\": \"all\"\n              },\n              [...]\n            },\n            \"defaultConfiguration\": \"production\"\n          },\n          [...]\n        }\n      }\n    }\n  }\n```\n\nng serve를 위해 angular.json을 확장하기\n\nng serve는 Angular 애플리케이션을 로컬에서 실행하려는 경우 사용하는 명령어입니다. 이 명령은 애플리케이션을 빌드하고 서비스하며 파일 변경 시 다시 빌드합니다. 이미 ng build를 설정했습니다. ng serve는 빌드 구성을 사용하여 애플리케이션을 빌드하고 제공합니다. 그런 다음 다음 형식의 serve 구성을 serve configurations에 추가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n\"<환경 이름>\": {\n  \"browserTarget\": \"your-project-name:build:<빌드 구성에서의 환경 이름>\"\n},\n```\n\n스테이징 환경에서는 angular.json 파일이 다음과 같이 보일 것입니다.\n\n```js\n{\n    [...]\n    \"projects\": {\n      \"your-project-name\": {\n        [...]\n        \"architect\": {\n          [...]    \n          \"serve\": {\n            \"builder\": \"@angular-devkit/build-angular:dev-server\",\n            \"configurations\": {\n              \"production\": {\n                \"browserTarget\": \"your-project-name:build:production\"\n              },\n              \"staging\": { // 👈🏻👈🏻👈🏻 이 serve 구성을 추가합니다\n                \"browserTarget\": \"your-project-name:build:staging\"\n              },\n              \"development\": {\n                \"browserTarget\": \"your-project-name:build:development\"\n              }\n            },\n            \"defaultConfiguration\": \"development\"\n          },\n          [...]\n        }\n      }\n    }\n  }\n```\n\nng serve --configuration staging 명령을 실행하면 스테이징 설정으로 애플리케이션을 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Angular schematic을 사용하여 환경 추가하기\n\nAngular 애플리케이션에 환경 하나를 추가하면 구성해야 할 설정이 많을 것이라고 생각할 수 있습니다. 그리고 왜 자동으로 추가되지 않는 것인지 의아해할 수도 있습니다. 걱정하지 마세요. Angular CLI(버전 15.1 이상)에는 새로운 schematic이 추가될 예정입니다. 이를 통해 Angular 애플리케이션에 환경을 추가할 수 있습니다. 이 작업은 단순히 다음 명령을 실행하면 됩니다. `ng generate environments`를 실행하면 새로운 환경이 Angular 애플리케이션에 추가됩니다. 이에 대한 자세한 내용은 여기에서 확인할 수 있습니다: [Bring back environment.ts to new projects · Issue #24381 · angular/angular-cli · GitHub](https://github.com/angular/angular-cli/issues/24381)\n\n# 결론\n\nAngular 애플리케이션에 새로운 환경을 구성하는 것은 흥미로운 작업이라고 생각합니다. Angular 팀이 프레임워크를 구현하는 방식을 살펴볼 때마다 항상 뭔가를 배우게 됩니다. 여러분도 새로운 환경을 구성하는 방법을 익히고, 더 쉬운 방법이 제공되는 schematic이 나올 것이라는 것을 알아두시면 좋겠습니다.","ogImage":{"url":"/assets/img/2024-06-20-AboutenvironmenttsinyourAngularapplications_0.png"},"coverImage":"/assets/img/2024-06-20-AboutenvironmenttsinyourAngularapplications_0.png","tag":["Tech"],"readingTime":10},{"title":"스크롤할 때 멋진, 축소 가능한 헤더로 내비게이션을 변환해 보세요 ","description":"","date":"2024-06-20 03:29","slug":"2024-06-20-Transformyournavigationwithasleekshrinkableheaderonscroll","content":"\n\n<img src=\"/assets/img/2024-06-20-Transformyournavigationwithasleekshrinkableheaderonscroll_0.png\" />\n\n웹 디자인에서 스크롤할 때 헤더를 축소하는 것은 사용자 경험을 향상시키는 일반적인 기술입니다. 사용자가 페이지를 아래로 스크롤할수록 내비게이션 바를 더 조밀하게 만들어 화면 공간을 절약하는 동시에 필수적인 내비게이션 링크를 산만하지 않게 보여줍니다. 이 기능을 구현하기 위해서는 HTML로 구조를 만들고 CSS로 스타일을 지정하며 JavaScript로 스크롤 동작을 처리해야 합니다.\n\n이 글에서는 페이지를 스크롤할 때 높이가 자연스럽게 축소되는 슈링크 헤더를 만드는 방법에 대해 살펴보겠습니다. 먼저, 헤더와 페이지 내용을 위한 기본 HTML 구조를 설정합니다. 다음으로, 헤더의 확장 및 축소 상태를 정의하는 CSS로 헤더를 스타일링합니다. 마지막으로, JavaScript를 추가하여 스크롤 이벤트를 감지하고 적절한 클래스를 헤더에 적용하여 축소 효과를 발생시킵니다.\n\n이 튜토리얼을 마치면 웹페이지의 사용성과 미학을 향상시키는 기능적인 슈링크 헤더를 가지게 될 것입니다. 이 안내서는 웹사이트에 세련된 터치를 더하고자 하는 초보자와 경험 있는 개발자 모두에게 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n이 효과를 위한 두 가지 중요한 부분이 있어요.\n\n구조 생성: HTML 섹션에서 사용자가 페이지를 스크롤할 때 네비게이션 바가 줄어드는 효과를 보여주는 기본적인 웹사이트 레이아웃을 설정할 거에요.\n\n디자인 구성: CSS 및 JavaScript 섹션에서 우리는 네비게이션 바를 스타일링하고 JavaScript를 사용하여 사용자가 스크롤할 때 네비게이션 바가 부드럽게 줄어드는 효과를 구현할 거에요.\n\n전체 코드\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html>\n\n<head>\n <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n <title>\n  페이지 제목\n </title>\n <style>\n  CSS 스타일 내용\n </style>\n\n <script>\n  JavaScript 스크립트 내용\n </script>\n\n</head>\n\n\n<body>\n <!-- 헤더 내비게이션 -->\n <div id=\"navlist\">\n  <a href=\"#default\" id=\"logo\">\n   CODEMAGNET\n  </a>\n\n  <div id=\"navlist-right\">\n   <a href=\"#home\">홈</a>\n   <a href=\"#about\">제품</a>\n   <a href=\"#about\">경력</a>\n   <a href=\"#contact\">문의</a>\n   <a href=\"#about\">회사 소개</a>\n  </div>\n </div>\n\n <!-- 페이지 내용 -->\n <div class=\"content\">\n  <b>\n   열정을 가진 코딩 포털\n  </b>\n  <p>\n   뛰어난 코딩 포털에 오신 것을 환영합니다. 모든 수준의 열정적인 사람들이 모여 배우고 공유하며 성장할 수 있는 곳입니다! 프로그래밍 열정을 키우는 데 필요한 다양한 리소스, 자습서 및 커뮤니티 지원에 몰입해 보세요. #코딩 #코드배우기 🚀💻\n  </p>\n </div>\n</body>\n\n</html>\n```\n\n자세한 내용은 아래 링크를 확인해주세요.\n\nhttps://codemagnet.in/2024/06/18/create-shrink-header-on-scroll-html-css-and-javascript/\n","ogImage":{"url":"/assets/img/2024-06-20-Transformyournavigationwithasleekshrinkableheaderonscroll_0.png"},"coverImage":"/assets/img/2024-06-20-Transformyournavigationwithasleekshrinkableheaderonscroll_0.png","tag":["Tech"],"readingTime":2},{"title":"자바스크립트 HTML 리치 텍스트 편집기","description":"","date":"2024-06-20 03:27","slug":"2024-06-20-JavascriptHTMLRich-TextEditors","content":"\n\n리치 텍스트 편집기 또는 WYSIWYG 편집기를 사용하면 사용자가 스타일이 적용된 텍스트, 이미지, 목록, 코드 블록 등을 입력할 수 있습니다. 만약 여러분이 마크다운으로 작성할 수 없는 사용자를 대상으로 한 웹사이트에서 텍스트/문서 입력을 구축 중이라면 이 접근 방식이 유용할 것입니다.\n\n이 글에서는 모든 현대적인 웹에 쉽게 통합할 수 있는 뛰어난 무료 오픈 소스 WYSIWYG인 Quill로 이러한 편집기를 만드는 방법을 안내해 드릴 것입니다.\n\n# 기본 예제\n\n우리의 프로젝트에 필요한 JavaScript 및 CSS 파일을 포함시켜 시작하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- 스타일시트 포함 -->\n<link href=\"https://cdn.quilljs.com/1.3.6/quill.snow.css\" rel=\"stylesheet\">\n<!-- Quill 라이브러리 포함 -->\n<script src=\"https://cdn.quilljs.com/1.3.6/quill.js\"></script>\n```\n\n또는 저처럼 코드 펜을 사용하는 경우 설정을 클릭하고 위의 Css 및 Js 링크를 추가해주세요.\n\n<img src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png\" />\n\n가장 간단한 형태로 시작해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nMarkdown\n\n```js\nvar quill = new Quill('#editor', {\n    theme: 'snow'\n});\n```\n\n<div class=\"content-ad\"></div>\n\nCSS: 없음\n\n그래, 이 간단한 리치 텍스트 편집기를 얻기 위해 해야 할 일은 이것뿐이에요. 여기서 글꼴 크기를 변경하거나 스타일을 추가/삭제할 수 있습니다.\n\n![리치 텍스트 편집기](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_1.png)\n\neditor라는 id를 설정하고 Quill 편집기를 초기화하는 데 사용하고 있습니다. 그러나 CSS 선택기나 DOM 객체를 전달할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 다음과 같이 classname editor를 전달하면 Quill이 첫 번째 일치하는 요소에 에디터를 생성합니다.\n\n```js\nvar editor = new Quill('.editor');  \n```\n\n또는 DOM 객체를 전달할 수도 있습니다.\n\n```js\nvar container = document.getElementById('editor');\nvar editor = new Quill(container);\n```\n\n<div class=\"content-ad\"></div>\n\n만약 툴바에 폭과 같은 추가 스타일링을 하고 싶다면, 에디터 자체의 스타일을 변경하는 것은 작동하지 않을 것입니다. 다음과 같이 결과물이 나올 것입니다.\n\n![example image](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_2.png)\n\n이를 수행하는 방법은 3가지가 있습니다.\n\nQuill은 툴바를 위한 클래스인 ql-toolbar를 사용하므로 아래와 같이 스타일을 오버라이드할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_3.png)\n\n또는 전체 편집기를 사용자 정의 컨테이너에 임베드하고 컨테이너 너비를 변경할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_4.png)\n\n세 번째 옵션은 new Quill()를 호출하고 편집기를 만들 때 추가 구성을 추가하는 것입니다. 다음 부분에서 이에 대해 자세히 살펴보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n좋아요! 이제 리치 텍스트 편집기가 아닌 스타일이 좀 적은 편집기가 되었네요!\n\n## 사용자 정의\n\nQuill로 더 풍부하게 만들어 보겠습니다.\n\n이 라이브러리는 사용자 정의와 확장을 염두에 두고 설계되었습니다. 우리의 요구에 맞게 커스터마이즈하는 다양한 방법이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- Configuration: 기존 기능을 조정하는 데 사용됩니다\n- Modules: 새로운 기능을 추가하는 데 사용됩니다\n- Themes: 스타일링을 위해 사용됩니다\n\n# 구성\n\n먼저 기존 기능을 어떻게 조정할 수 있는지 살펴보겠습니다.\n\n우리가 위에서 사용한 javascript에서 'theme: ‘snow’'를 추가했다는 점을 유의해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar quill = new Quill('#editor', {\n  theme: 'snow'\n});\n```\n\n이것은 Quill에서 인식하는 옵션 중 하나입니다. 전체 목록을 확인할 수 있고, 저는 발견한 몇 가지를 여러분에게 보여드릴게요.\n\n## 모듈\n\n새 기능을 추가할 때 사용할 키입니다. 곧 자세히 살펴볼 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n이외에도 몇 가지 매우 중요한 미리 만들어진 것들이 있어요.\n\n- 툴바\n\n아래에는 위에서 보여드렸던 기본적인 것이 있어요\n\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n아래에 보이는 내용입니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_6.png)\n\n색상 및 배경에 대해 빈 배열을 가지고 있더라도 여전히 선택할 수 있는 멋진 색 팔레트를 얻을 수 있습니다.\n\n이는 테마가 드롭다운을 위해 기본값을 지정할 수 있기 때문입니다. 위의 예에서 우리는 Snow를 사용하고 있으며, 색상 및 배경 형식에 대해 빈 배열로 설정하면 색상 목록에서 기본값으로 35가지 색상을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n위의 예시에서는 단순히 기존의 어트리뷰터를 선택했습니다. 그러나 여러분은 이를 사용자 정의할 수도 있어요. 예를 들어, 사용자 지정 글꼴을 추가하려면:\n\n```js\nvar FontAttributor = Quill.import('attributors/class/font');\nFontAttributor.whitelist = [\n  'sofia', 'slabo', 'roboto', 'inconsolata', 'ubuntu'\n];\nQuill.register(FontAttributor, true);\n```\n\n```js\n.ql-font-roboto {\n  font-family: 'Roboto', sans-serif;\n}\n```\n\n더 많은 사용자 정의와 제어를 원하신다면, HTML에서 직접 툴바를 만들고 DOM 요소나 셀렉터를 Quill에 전달할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- 툴바 컨테이너 생성 -->\n<div id=\"toolbarContainer\">\n  <!-- 글꼴 크기 드롭다운 추가 -->\n  <select class=\"ql-size\">\n    <option value=\"small\"></option>\n    <!-- 주의: 값이 없어서 기본 값으로 재설정됨 -->\n    <option selected></option>\n    <option value=\"large\"></option>\n    <option value=\"huge\"></option>\n  </select>\n  <!-- 굵게 버튼 추가 -->\n  <button class=\"ql-bold\"></button>\n  <!-- 아래 첨자 및 위첨자 버튼 추가 -->\n  <button class=\"ql-script\" value=\"sub\"></button>\n  <button class=\"ql-script\" value=\"super\"></button>\n</div>\n<div id=\"editor\">\n</div>\n```\n\n```js\nvar options = {\n  modules: {\n    toolbar: {\n      container: '#toolbarContainer',  \n      handlers: {\n        'bold': customBoldHandler\n      }\n    }\n  },\n  theme: 'snow'\n};\n\nvar quill = new Quill('#editor', options);\n```\n\n만약 사용자 정의 컨테이너를 사용한다면, 컨트롤도 직접 설정해야 합니다. 그렇지 않으면 빈 툴바가 나타날 수 있습니다. 아래와 같이 확인하세요.\n\n<img src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_7.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar toolbarHanlderOptions = {\n  handlers: {\n    'link': function(value) {\n      if (value) {\n        var href = prompt('URL을 입력하세요');\n        this.quill.format('link', href);\n      } else {\n        this.quill.format('link', false);\n      }\n    }\n  }\n}\n\nvar options = {\n  modules: {\n    toolbar: toolbarHanlderOptions,\n  },\n  theme: 'snow'\n};\n\nvar quill = new Quill('#editor', options);\n```\n\n우리는 다음을 받게 될 것입니다\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*QpD3jR3s6v4M_nUWwLOFdg.gif\" />\n\n핸들러 함수는 툴바에 바인딩되어 있으므로 this를 사용하면 툴바 인스턴스를 참조하게 됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n위 조정 도구 모양에 대한 자세한 내용은 여기에서 확인할 수 있어요.\n\n- 구문\n\n이 모듈은 구문 강조 효과를 적용하여 코드 블록 포맷을 강화합니다. 코드 블록을 자동으로 감지하고 구문 강조를 적용하기 위해 훌륭한 highlight.js 라이브러리가 사용됩니다.\n\n사용하려면 먼저 마음에 드는 highlight.js 스타일 시트를 추가하고 highlight.js 라이브러리를 포함시키세요.\n\n<div class=\"content-ad\"></div>\n\n만약 제가 사용하고 있는 것처럼 codepan.io를 사용 중이라면, 설정 옵션을 통해이를 추가하는 것이 작동하지 않을 수 있으며 수동으로 HTML에 다음과 같이 추가해야 합니다.\n\n```js\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js\"></script>\n```\n\n그런 다음 툴바 옵션에 코드 블록을 포함시키십시오. 저 위의 예제를 사용 중이라면 이미 포함되어 있어야 합니다.\n\n모듈에 구문 키를 추가하고 구문 모듈을 포함하려면 true로 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar quill = new Quill('#editor', {\n  modules: {\n    syntax: true,              \n    toolbar: [['code-block']]  \n  },\n  theme: 'snow'\n});\n```\n\n아래와 같이 특정 언어 또는 모든 언어로 구성할 수도 있습니다.\n\n```js\n// 선택적으로 hljs 구성\nhljs.configure({   \n    languages: ['javascript', 'ruby', 'python']\n});\n\n// 또는 모든 언어 강조\nhljs.highlightAll();\n```\n\n## placeholder\n\n\n<div class=\"content-ad\"></div>\n\n이 옵션 키는 편집기가 비어 있을 때 표시할 자리 표시자 텍스트를 구성하는 데 사용됩니다.\n\n다음과 같은 옵션을 사용하면\n\n```js\nvar options = {\n  placeholder: '말해보세요!',\n  theme: 'snow'\n};\n\n\nvar quill = new Quill('#editor', options);\n```\n\n다음은 우리가 얻게 될 것입니다!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_8.png\" />\n\n## readOnly\n\n이 값은 에디터를 읽기 전용 모드로 초기화할지 여부를 나타냅니다. 기본값은 false입니다.\n\n사용자가 더 이상 수정할 수 없게 하고 입력한 내용을 확인해야 하는 확인 페이지를 만들고 싶을 때 이 값은 정말 유용합니다. 이 경우 툴바를 false로 설정하고 싶을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar options = {\n  modules: {\n      toolbar: false\n  },\n  readOnly: true,\n  theme: 'snow'\n}\n\nvar quill = new Quill('#editor', options);\n```\n\n## 테마\n\n이 키는 전체 스타일링을 구성하는 데 사용할 키이며 곧 자세히 살펴볼 것입니다.\n\n# 모듈\n\n\n<div class=\"content-ad\"></div>\n\n이전 섹션에서 툴바와 같은 몇 가지 미리 구축된 모듈을 이미 살펴보았습니다. 이 모듈은 확장되어 원본 모듈을 대체하거나 다시 등록할 수도 있습니다.\n\n예를 들어, 이를 통해 클립보드 모듈이 Quill과 외부 애플리케이션 간에 복사, 잘라내기 및 붙여넣기를 어떻게 처리할지 구성할 수 있습니다.\n\n```js\nvar Clipboard = Quill.import('modules/clipboard');\nvar Delta = Quill.import('delta');\n\nclass PlainClipboard extends Clipboard {\n  convert(html = null) {\n    if (typeof html === 'string') {\n      this.container.innerHTML = html;\n    }\n    let text = this.container.innerText;\n    this.container.innerHTML = '';\n    return new Delta().insert(text);\n  }\n}\n\nQuill.register('modules/clipboard', PlainClipboard, true);\n\nvar quill = new Quill('#editor');\n```\n\n그러나 때로는 (사실 대부분의 경우) 기존 모듈을 사용하거나 구성하는 것이 더 쉬울 수 있습니다. 위 예에서 기존 Clipboard의 addMatcher API가 더 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n리치 텍스트 편집기에 대한 API가 무엇인지 궁금하신가요? 조금 더 자세히 설명해 드릴게요. 실제로 이게 Quill의 가장 멋진 부분이라고 생각해요.\n\n# 테마\n\n우리는 이미 여러 차례 이 키를 사용했어요. 사용할 테마 이름입니다. 내장된 옵션은 bubble 또는 snow입니다. 잘못된 값은 기본 최소 테마를 로드합니다.\n\n- bubble: 간단한 툴팁 기반 테마입니다.\n- snow: 깨끗하고 평평한 툴바 테마이며, 위에서 반복적으로 사용한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n테마의 구체적인 스타일시트는 여전히 수동으로 포함해야 합니다. 더 많은 정보 및 추가 사용자 정의를 위해 테마를 확인해보세요!\n\n# API 주도 설계\n\n자바스크립트와 HTML을 사용하여 간단한 리치 텍스트 편집기를 만드는 방법을 보여드렸습니다. 그러나 Quill에서 가장 독특한 요소 중 하나(제 개인적인 의견으로)는 API 주도 설계입니다.\n\n대부분의 리치 텍스트 편집기는 사용자가 작성한 텍스트를 알지 못하며, 내용을 웹 개발자가 보는 렌즈로 보게 됩니다: DOM입니다. 이는 DOM이 불균형 트리로 구성된 노드로 이루어져 있지만 텍스트는 줄, 단어 및 문자로 이루어져 있기 때문에 임피던스 불일치를 초래합니다.\n\n<div class=\"content-ad\"></div>\n\n문자가 측정 단위인 DOM API가 없습니다. 이 제한으로 대부분의 리치 텍스트 에디터는 \"이 범위에 어떤 텍스트가 있는가?\" 또는 \"커서가 굵은 텍스트에 있는가?\" 같은 간단한 질문에 대답할 수 없습니다.\n\n그에 반대로, API 주도 설계를 통해 Quill은 굵은 텍스트인지 확인하려면 `b`나 `strong` 노드 또는 글꼴 두께 스타일 속성을 찾는 DOM 탐색이 필요하지 않습니다.\n\n할 일은 getFormat(5, 1) API를 호출하는 것 뿐입니다. 모든 핵심 API 호출은 임의의 인덱스와 길이로 액세스하거나 수정할 수 있습니다. 그리고 해당 이벤트 API는 직관적인 JSON 형식으로 변경 사항을 보고하며 HTML 구문 분석이나 DOM 트리 비교가 필요하지 않습니다.\n\n그러므로 Quill은 나만의 리치 텍스트 에디터 솔루션을 설계할 때 더 많은 옵션과 자유를 제공하며 더 간단한 해결책으로 이어줍니다!\n\n<div class=\"content-ad\"></div>\n\n그거 오늘은 여기까지야!\n\n리치 텍스트 편집기를 만들어서 부자가 되어보자(아마?)!","ogImage":{"url":"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png"},"coverImage":"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png","tag":["Tech"],"readingTime":10},{"title":"Django Crispy Forms - Bootstrap5","description":"","date":"2024-06-20 03:25","slug":"2024-06-20-DjangoCrispyformsbootstrap5","content":"\n\n## Django Crispy Forms 설정 및 HTML 템플릿이 Helper Layout을 통해 변경 양식을 받지 않는 이유를 해결하는 중!\n\n대부분의 경우, 필터 구문인 (' form|crispy ')이 기본적인 렌더링에 충분합니다. 그러나 더 많은 제어가 필요하거나 Crispy Forms에서 제공하는 특정 기능을 사용하려면 템플릿 태그 구문인 (' crispy form ')을 선호할 수 있습니다.\n\n— — — — — — — — — — — — — — — — — — — — — — — — — — — — — —\n\n![image](/assets/img/2024-06-20-DjangoCrispyformsbootstrap5_0.png)\n\n<div class=\"content-ad\"></div>\n\n장고 템플릿에서 ' form|crispy ' 및 ' crispy form '은 Crispy Forms 라이브러리를 사용하여 Django 양식을 렌더링하는 두 가지 다른 방법입니다.\n\n- '' form|crispy '' (필터 구문):\n\n- 이것은 Django 템플릿에서의 필터 구문입니다.\n- 변수 equip_form에 필터를 적용하는 데 사용됩니다.\n- 기본 Crispy Forms 렌더링을 사용하여 양식을 렌더링합니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\n{ crispy equip_form }\n```\n\n'crispy equip_form' (템플릿 태그 구문):\n\n- Django 템플릿에서 사용되는 템플릿 태그 구문입니다.\n- 폼을 렌더링하기 위해 명시적으로 crispy 템플릿 태그를 포함하는 데 사용됩니다.\n- 추가 옵션을 지정하고 렌더링 동작을 사용자 정의할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n두 가지 구문은 모두 Crispy Forms를 사용하여 폼을 렌더링하는 동일한 결과를 얻습니다. 어떤 것을 선택할지는 종종 Crispy Forms 라이브러리에서 제공되는 추가 옵션을 사용해야 하는지 또는 렌더링 동작을 사용자 정의해야 하는지에 따라 다릅니다.\n\n--- --- --- --- --- --- --- --- --- --- ---\n\nDjango 프로젝트에 Crispy Forms를 설정해 봅시다.\n\n1. 터미널: pip install django-crispy-forms\n\n<div class=\"content-ad\"></div>\n\n2- settings.py 파일에 다음을 추가하세요:\n\n```python\nINSTALLED_APPS = (\n    ...\n    'crispy_forms',\n)\n```\n\n3- crispy-bootstrap5 추가하기: $ pip install crispy-bootstrap5\n\n```python\nINSTALLED_APPS = (\n    ...\n    \"crispy_forms\",\n    \"crispy_bootstrap5\",\n    ...\n)\n\nCRISPY_ALLOWED_TEMPLATE_PACKS = \"bootstrap5\"\n\nCRISPY_TEMPLATE_PACK = \"bootstrap5\"\n```\n\n<div class=\"content-ad\"></div>\n\n이 단계에서는 forms.py / views.py / urls.py에서 작업하고 대상 HTML 템플릿에 crispy forms를 로드할 것입니다. 예를 들어:\n\nHTML 페이지 상단에 ( 'extends `app_name/main.html`' 뒤에):\n\n'load crispy_forms_tags'\n\n=================\n\n<div class=\"content-ad\"></div>\n\n```js\r\n<form method=\"post\">\n{ csrf_token }\n<div class=\"card\" style=\"width: 50rem;\">\n<div class=\"card-header\">\n<h6 class=\"card-text\">장비 정보:</h6>\n</div>\n<div class=\"card-body\">\n{ crispy equip_form }\n</div>\n<button type=\"submit\">저장</button>\n</div>\n</form>\r\n```\n\nForms.py 파일에 대한 중요한 내용입니다. Django crispy forms를 사용하면 Python 환경에서 HTML 태그를 변경하고 CSS 클래스를 추가할 수 있습니다.\n\n```js\r\nfrom .models import Equipment\nfrom crispy_forms.helper import FormHelper\nfrom crispy_forms.layout import Layout, Submit, Div, Field, Row, Column\r\n```\n\n```js\r\nclass EquipForm(forms.ModelForm):\n    class Meta:\n        model = Equipment \n        fields = \"__all__\"\r\n```  \n\n<div class=\"content-ad\"></div>\n\n위의 코드는 일반적인 상황에서 양식을 사용하는 방법을 나타냅니다.\n\n그러나 Django crispy 템플릿에서 생성된 표준 HTML 태그를 무시하고 뷰를 재정의할 수 있습니다.\n\n```js\ndef __init__(self, *args, **kwargs):\n        super(EquipForm, self).__init__(*args, **kwargs)\n        #Django 양식의 경우 super().__ init__(*args, **kwargs)를 호출하여 인스턴스화 중에 전달된 데이터로 양식을 초기화합니다. 이는 Python에서 특정한 경우에 발생하는 패턴입니다. 부모 클래스의 메서드를 재정의하고 부모 클래스에서 동일한 메서드를 호출하려는 경우 사용됩니다.\n        \n        #특정 양식에 날짜 위젯 추가:\n        self.fields['effective_date'].widget = forms.DateInput(attrs={'type': 'date'})\n        self.fields['warranty_expiration'].widget = forms.DateInput(attrs={'type': 'date'})\n        #\n```\n\n이제 열과 행으로 양식을 만들어 원하는 위치에 양식 필드를 그룹화하는 방법을 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n\n        self.helper = FormHelper(self)\n        self.helper.layout = Layout(\n        Row(\n            Column('name', css_class='col-md-4'),\n            Column('vendor', css_class='col-md-4'),\n        ),\n        Row(\n            Column('vendor_reference', css_class='col-md-4'),\n            Column('model', css_class='col-md-4'),\n        ),\n        Row(\n            Column('category', css_class='col-md-4'),\n            Column('serial_number', css_class='col-md-4'),\n            Column('used_by', css_class='col-md-4'),\n        ),\n.......\n.......\n\n\n![이미지](/assets/img/2024-06-20-DjangoCrispyformsbootstrap5_1.png)\n\nforms.py에서 필드를 재정의한 후:\n\n![이미지](/assets/img/2024-06-20-DjangoCrispyformsbootstrap5_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n보너스 팁:\n\n다른 경우로, HelperForm 레이아웃을 재정의하여 뷰를 덮어썼지만 CSS 클래스가 변경되지 않는 문제가 발생했습니다. 'form|crispy'이 문제를 발생시키지 않았지만 HTML 소스 페이지를 검사하다가 새로운 css_class가 자식 태그 'div'에 적용되는 것을 발견했습니다. 이는 부모 `Div`를 대상으로하는 방법입니다.\n\n```js\n        self.helper = FormHelper(self)\n        self.helper.form_method = 'post'\n        self.helper.layout = Layout(\n\n        Div(\n            Field('field1', wrapper_class='col-md-6 '), # css_class\n            Field('field2', wrapper_class='col-md-6 '),\n\n            css_class='row',  # 전체 div에 행 클래스 적용 (선택 사항)\n        ),\n```\n\nDjango Crispy-Forms에서 css_class 및 wrapper_class는 양식 필드의 스타일링을 제어하기 위해 FormHelper 레이아웃 내에서 사용되는 속성입니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\n| css_class:                                              |\n| ------------------------------------------------------- |\n| - 이 속성은 개별 폼 필드에 적용되며, HTML 입력 요소의 CSS 클래스를 지정합니다. |\n| - 이 속성은 폼 요소 자체의 스타일에 직접적으로 영향을 줍니다.         |\n\n예시:\n\n```js\nField('field_name', css_class='my-custom-class')\n```\n\n<div class=\"content-ad\"></div>\n\n`wrapper_class`:\n\n- 이 속성은 폼 필드를 감싸는 HTML 컨테이너에 적용됩니다.\n- 폼 요소 주변의 컨테이너 스타일에 영향을 줍니다.\n\n예시:\n\n```js\nField('field_name', wrapper_class='my-container-class')\n```\n\n<div class=\"content-ad\"></div>\n\n이러한 속성은 FormHelper에서 제공하는 레이아웃 정의에서 사용할 수 있습니다. 예를 들어, Layout 클래스를 사용하여 양식 레이아웃을 만들 때 각 필드에 이러한 속성을 적용할 수 있습니다:\n\n```js\nself.helper.layout = Layout(\n    Field('field1', css_class='my-custom-class'),\n    Field('field2', wrapper_class='my-container-class'),\n    # ... 다른 필드들 ...\n)\n```\n\n요약하면, css_class는 양식 요소 자체의 스타일링에 사용되고, wrapper_class는 양식 요소를 감싸는 컨테이너의 스타일링에 사용됩니다. 이 두 가지는 CSS 클래스를 통해 양식 필드의 모양을 제어하는 방법을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-20-DjangoCrispyformsbootstrap5_0.png"},"coverImage":"/assets/img/2024-06-20-DjangoCrispyformsbootstrap5_0.png","tag":["Tech"],"readingTime":6},{"title":" TailwindCSS v4을 기반으로 하는 나만의 주관적인 CSS 라이브러리 디자인하기","description":"","date":"2024-06-20 03:23","slug":"2024-06-20-DesigningmyownopinionatedCSSlibraryontopofTailwindCSSv4","content":"\n\n## AltCSS를 소개합니다\n\n![이미지](/assets/img/2024-06-20-DesigningmyownopinionatedCSSlibraryontopofTailwindCSSv4_0.png)\n\n오늘은 선택할 수 있는 다양한 옵션이 많습니다 (선호하지 않는 순서로 나열):\n\n- Tailwind CSS\n- Bootstrap 5\n- Semantic UI\n\n<div class=\"content-ad\"></div>\n\n일부 새로운 및 앞으로 나올 옵션에는 Sugar CSS가 있습니다. 특정 분야를 위해 Animate CSS나 Pattern CSS와 같은 라이브러리가 있지만, 제게는 잘 맞지 않습니다.\n\n지난 몇 년 동안 다양한 맥락에서 CSS 작업에 문제가 있었습니다.\n\n- CSS 라이브러리가 제공하는 클래스 중 50%도 거의 사용하지 않습니다. 문서를 보면, 저에게는 관련 없는 많은 것으로 가득 차 있어, 부풀려지고 서투릅니다. 대다수의 사람들은 대부분의 기능과 클래스를 사용하지 않습니다. 사용되지 않는 클래스들은 제거되어 성능에는 영향을 주지 않지만, 개발을 할 때 가볍지 않게 느껴집니다.\n- 종종 CSS를 덮어쓰거나 기존 클래스 위에 자체 클래스를 만들어야 합니다. 솔직히 말하면, 우리 고유한 맥락에 완벽히 맞는 라이브러리는 없습니다. 시간이 지남에 따라 프로젝트 간의 작업 반복이 많이 발생합니다.\n- 간단한 것조차 여러 개의 CSS 클래스를 사용하는 것을 좋아하지 않습니다. Tailwind CSS를 살펴보면, 하나의 요소에 거의 항상 여섯 개나 일곱 개의 클래스가 함께 붙어있습니다. 클래스 이름이 길어지면 금방 번거로워지며, 쓰기, 기억하기, 읽기, 유지 관리하기 어려워집니다. 그렇지 않으면, 그 위에 래퍼 클래스를 놓아야 합니다.\n\n위 문제를 해결하기 위해 제게 잘 맞는 주관적인 CSS 라이브러리를 만들었습니다. 다른 사람들과 반드시 일치하지는 않을 것입니다. 간단히 말하면, 이 라이브러리는 다수의 사람과 일치하지 않는 실천원칙을 따르거나 사용할 수 없을 것입니다. 그래서, 이 라이브러리를 AltCSS라고 명명하기로 결정했습니다.\n\n<div class=\"content-ad\"></div>\n\n내가 AltCSS에 대한 목표는 다음과 같습니다:\n\n- 평상시 라이브러리보다 80% 더 적은 CSS 클래스를 사용하면서 가장 흔한 사용 사례 80% (또는 그 이상)에 맞는 의견이 강한 스타일링.\n- 가벼우며 최적화되고 용량이 작습니다.\n\n본문의 다음 부분은 이 라이브러리를 만들기 위해 따란한 단계별 프로세스에 관한 내용입니다.\n\n# 단계 1: 가장 흔히 사용되는 CSS\n\n<div class=\"content-ad\"></div>\n\n가장 자주 사용되는 CSS 스타일로 좁혀봤어요. 이 과정에서 자주 다루는 네 가지 유형의 웹사이트를 고려해봤어요 (또는 미래에 다룰 계획이 있는). 각 유형에 대해 내 맥락에서 일반적으로 요구되는 스타일링 요소를 확인했어요.\n\n- 랜딩 페이지\n— 이미지\n— 버튼\n— 가입/이메일 폼\n- 포트폴리오 웹사이트\n— 그리드\n— 카드\n- 블로그 및 문서 사이트\n— 타이포그래피\n— 텍스트 레이아웃\n— 링크\n— 내비게이션\n- 싱글 페이지 웹 앱\n— 입력란, 라디오, 체크박스 등과 같은 폼 요소들\n\nMVP 버전에서는 현재 활동적으로 사용하는 스타일에만 초점을 맞췄어요.\n\n대부분의 CSS 라이브러리는 일정한 디자인 시스템을 따르지만, 저는 특정한 것을 따르지 않았어요. 모든 것을 자연스럽고 간단하게 유지했거든.\n\n<div class=\"content-ad\"></div>\n\n그래서, 모든 것을 처음부터 만들어야 할까요?\n\n처음에는 그 방향으로 가고 있었지만, 그때쯤에 TailwindCSS가 다음 주요 버전인 버전 4의 진행 상황을 오픈소스로 공개했어요.\n\n그냥 갑자기 생각이 났어요. 그것을 기반으로 삼아 그 위에 더 쌓아올려야겠다는 생각이 들었어요. 마치 간단하고 사용하기 쉬운 방식으로 패키지화된 좋은 작은 추상화처럼 말이에요. Tailwind는 이렇게 사용하도록 만들어진 것이 아니었지만, 그래도 한번 시도를 해봐야겠죠.\n\nTailwindCSS 알파 버전 4 외에, 저는 패키지 매니저로 Bun을 사용했어요.\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: 명명 규칙\n\n가능한 한 간단하고 짧고 자연스럽게 유지하고 싶어요. 여기서 한 가지 선택사항을 정했습니다.\n\n- 모든 기본 HTML 태그는 본질적으로 적용된 Tailwind CSS 스타일이 적용될 것입니다.\n- 특정한 경우에 사용자 정의 클래스를 만들어야 할 때는 가능한 한 짧게 유지하려고 약어 'a-name'의 명명법을 따를 것입니다.\n\n# 단계 3: CSS 작성하기\n\n<div class=\"content-ad\"></div>\n\n먼저, 빈 프로젝트 npm init을 생성하고 원하는 파일 구조를 만들었습니다.\n\n사용자 관점에서 몇 가지 핵심 디자인 원칙이 있습니다:\n\n- 클래스 이름 작성 금지\n- CSS 작성 금지\n- 간단하게 유지\n- 깔끔하게 유지\n\n내 첫 번째 선호도인 다크 모드로 직접 시작했습니다. 새로운 클래스 이름을 만들지 않고 원시 HTML 요소에 스타일을 적용하려고 노력했습니다. 카드 및 그리드와 같은 컴포넌트는 이런 식으로 만드는 것이 어려울 수 있습니다. 네이티브 요소를 특정한 방식으로 중첩하여 이러한 컴포넌트를 만드려고 노력했습니다. 모든 문서가 완료되면 이러한 예제들을 더 많이 공유하겠습니다.\n\n<div class=\"content-ad\"></div>\n\nMVP를 위해 제가 헤딩, 링크, 카드 및 그리드 레이아웃을 위한 기본 CSS를 구현했어요. 모든 것들이 표준 화면 크기에 대응할 수 있도록 했어요.\n\n예를 들어, 이것이 제 타이포그래피 스타일의 일부 예시에요.\n\n```js\n/* 타이포그래피 */\n/* 헤딩 */\nh1, h2, h3 {\n    @apply text-gray-400 tracking-tight;\n}\n\nh1 {\n    @apply text-4xl sm:text-5xl md:text-6xl lg:text-7xl font-bold my-6;\n}\n\nh2 {\n    @apply text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-semibold my-5;\n}\n\nh3 {\n    @apply text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-medium my-4;\n}\n\nh4 {\n    @apply text-lg text-yellow-400 sm:text-xl md:text-2xl lg:text-3xl font-medium my-3 tracking-tight;\n}\n\n/* 텍스트 */\np {\n    @apply text-lg sm:text-xl md:text-2xl text-gray-500 my-3 leading-relaxed tracking-wide;\n}\n\n/* 링크 */\na {\n    @apply text-yellow-400 relative transition-colors duration-200 ease-in-out no-underline;\n}\n\na::after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    bottom: -2px;\n    width: 100%;\n    height: 2px;\n    background-color: currentColor;\n    transform: scaleX(0);\n    transform-origin: bottom right;\n    transition: transform 0.3s ease;\n}\n\na:hover::after {\n    transform: scaleX(1);\n    transform-origin: bottom left;\n}\n```\n\n# 단계 4: CSS 최소화\n\n<div class=\"content-ad\"></div>\n\n코드가 준비되었으면, 그것을 단일 파일로 미니파이하면 됩니다 ( alt.min.css ). 이를 위해 Tailwind Cli의 알파 버전을 사용했어요.\n\n여기 참고용으로 제 package.json 이에요.\n\n```json\n{\n  \"dependencies\": {\n    \"@tailwindcss/cli\": \"^4.0.0-alpha.16\",\n    \"tailwindcss\": \"^4.0.0-alpha.16\"\n  },\n  \"scripts\": {\n    \"build\": \"bunx @tailwindcss/cli@next -i app.css -o dist/alt.min.css --minify\"\n  },\n  \"devDependencies\": {\n    \"prettier\": \"^3.3.1\",\n    \"prettier-plugin-tailwindcss\": \"^0.6.1\"\n  }\n}\n```\n\napp.css 파일은 src 폴더에서 가져온 모든 CSS 파일을 포함하고 있어요.\n\n<div class=\"content-ad\"></div>\n\nbun run build이 위 스크립트에 따라 압축 파일을 만드는 마법을 부릅니다.\n\n이 단계에서 추가로 해야 할 일이 몇 가지 있습니다.\n압축 파일에는 이제 내가 만든 것 외에도 모든 tailwind 클래스와 변수가 포함되어 있습니다. 내 디자인에서 사용한 요소와 변수만 최종 압축 파일에 포함되도록 필터링해야 합니다. 이 향상된 기능은 향후 업데이트에 남기도록 하겠습니다.\n\n# 단계 5: 테스트\n\n압축 파일이 준비되면, 모든 것을 테스트하기 위해 몇 가지 예제 페이지를 만들었습니다. 그 후에 다른 사람들이 쉽게 설치하고 프로젝트에 포함할 수 있도록 npm 패키지로 게시하는 시간이었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 6: NPM 게시\n\n실제로 코드를 npm 패키지로 게시하는 것은 매우 간단합니다. alt.min.css 파일이 저장된 dist 폴더 내에 새로운 package.json을 생성했습니다.\n\n이 파일에는 npm 패키지를 게시하는 데 필요한 모든 세부 정보와 최종 패키지에 푸시하려는 파일이 포함되어 있습니다. 제 경우에는 최종 출력인 dist 폴더를 푸시하고 싶었습니다. 여기가 내 dist package.json입니다.\n\n```json\n{\n    \"name\": \"altcss\",\n    \"version\": \"0.0.6\",\n    \"description\": \"의견이 분분하고 독특하며 가벼운 CSS 컴포넌트 라이브러리.\",\n    \"main\": \"alt.min.css\",\n    \"files\": [\n        \"alt.min.css\",\n        \"README.md\"\n    ],\n    \"keywords\": [\n        \"css\",\n        \"library\",\n        \"altcss\",\n        \"tailwindcss\"\n    ],\n    \"author\": \"aditya-xq\",\n    \"license\": \"MIT\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\ncd dist\nnpm login\nnpm publish\n```\n\n여기까지입니다!\n\n# 최종 결과\n\nMVP가 모두 설정되어 사용하고 실험할 준비가 되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트에 altcss를 추가하는 방법이에요. 아래 명령어 중 하나를 사용해서 altcss를 직접 프로젝트에 추가할 수 있어요.\n\n```js\nnpm install altcss\npnpm add altcss\nbun add altcss\n```\n\n그런 다음, 필요한 파일을 메인 스크립트나 전역 스타일로 가져와야 해요. 예를 들어, Sveltekit에서는 +layout.svelte 파일의 script 태그 아래에 가져와야 해요.\n\n```js\nimport 'altcss/alt.min.css';\n```\n\n<div class=\"content-ad\"></div>\n\n원시 HTML을 작성하고 자동으로 적용되는 스타일링을 즐기세요.\n\n여기에 AltCSS로 만든 간단한 데모 페이지가 있습니다.\n\n이 프로젝트의 GitHub 저장소는 여기에 있습니다.\n\n마지막으로 AltCSS를 사용하여 만든 또 다른 페이지가 여기에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 끝 내용\n\n이것은 몇 가지 구성 요소와 스타일이 구현된 MVP일 뿐입니다. 대부분의 프로젝트에 표준 CSS 프레임워크/라이브러리로 AltCSS를 사용할 계획입니다. 특정 스타일이나 구성 요소를 구현해야 할 때는 이를 라이브러리에 추가할 것입니다.\n\n다음은 내가 생각하는 일반적인 로드맵입니다:\n\n- 나머지 선정된 HTML 태그의 디자인을 완성합니다.\n- 나만의 디자인에 맞게 실제로 사용자 지정된 스타일만 포함되도록 최소화된 CSS를 정리하고 필터링합니다.\n- 적절한 라이트 모드와 다크 모드를 구현합니다.\n- 사람들이 AltCSS를 사용자의 디자인 선호에 맞게 사용자 인터페이스를 통해 모양을 조정하고 프로젝트용으로 최소화된 CSS를 내보낼 수 있는 \"CSS 디자인 빌더\"를 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n다음에 또 만나요.","ogImage":{"url":"/assets/img/2024-06-20-DesigningmyownopinionatedCSSlibraryontopofTailwindCSSv4_0.png"},"coverImage":"/assets/img/2024-06-20-DesigningmyownopinionatedCSSlibraryontopofTailwindCSSv4_0.png","tag":["Tech"],"readingTime":7},{"title":"HTML 이메일 보내기","description":"","date":"2024-06-20 03:22","slug":"2024-06-20-SendingHTMLemails","content":"\n\nHTML 이메일을 보내는 것은 생각보다 쉽지 않아요. 이메일 클라이언트들은 HTML 및 CSS 기술을 다루는 데 90년대에 멈춰 있어요.\n\n# 빠른 예시\n\nSnowball에서는 현재 미디어 웹 앱에서 뉴스레터 판본 목록을 작성 중이에요:\n\n- 각 판본을 카드로 표시하고 싶어요\n- 한 줄에 3장의 카드를 표시하길 원하고, 자동으로 다음 줄로 넘어가길 원해요\n- 한 줄의 모든 카드의 높이가 동일하길 원해요\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 변경하시면 됩니다:\n\n\n![Image](/assets/img/2024-06-20-SendingHTMLemails_0.png)\n\n참 쉽지 않나요?\n기본 Tailwind CSS 구성을 제거하고 다음 코드를 작성하세요:\n\n```html\n<div class=\"flex gap-2 p-2 justify-center flex-wrap max-w-[1200px] mx-auto items-stretch\">\n  <div class=\"flex flex-col gap-1 max-w-[300px] border-1 p-2\">\n    <img\n      src=\"https://picsum.photos/id/237/200/300\"\n      class=\"max-w-full h-auto max-h-[200px] fit-cover\"\n      alt=\"\"\n    />\n\n    <h1>This is the title</h1>\n\n    <p class=\"flex-1 flex items-end\">This is the subtitle</p>\n\n    <div class=\"flex justify-between\">\n      <span>Yoann Lopez</span>\n      <span>2024년 6월 15일</span>\n    </div>\n  </div>\n\n  <!-- 모든 에디션에 대해 반복합니다... -->\n</div>\n```\n\n\n<div class=\"content-ad\"></div>\n\n당신이 Tailwind로 생성한 스타일시트와 함께 Gmail 받은 편지함으로 이메일을 보냅니다:\n\n\n<img src=\"/assets/img/2024-06-20-SendingHTMLemails_1.png\" />\n\n\n음... 제대로 작동하지 않는 것 같네요 (이것은 과장이 아닙니다).\n\n대부분의 메일 클라이언트와 호환되면서 기대한 결과에 근접하려면 다음 마크업을 작성해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n테이블 태그를 Markdown 형식으로 변경해 드렸어요.\n\n```js\n## 테이블1\n| 속성 | 값 |\n|---|---|\n| 스타일 | max-width: 1200px; border-collapse: collapse; margin: 0 auto |\n| 내용 | 이미지, 제목, 부제, 저자, 날짜 |\n\n## 테이블2\n| 속성 | 값 |\n|---|---|\n| 스타일 | max-width: 300px; margin: 0 auto |\n| 내용 | 이미지, 제목, 부제, 저자, 날짜 |\n\n## 결과\n![이미지](/assets/img/2024-06-20-SendingHTMLemails_2.png)\n```\n당신의 이메일로 전송해 드렸어요!\n\n완벽하진 않지만, 거의 비슷하죠…\n아쉬운 점들이 있어요\n\n\n<div class=\"content-ad\"></div>\n\n- Tailwind CSS를 사용할 수 없어요 (스트일시트가 너무 커서 메일 클라이언트가 거부할 수 있어요)\n- 인라인 스타일을 사용해야 해요 (외부 스타일시트는 전혀 지원되지 않고, 내장 스타일시트는 모든 클라이언트에서 지원되지 않아요)\n- 내용을 적절하게 표시하려면 의미론적으로 잘못된 테이블을 사용해야 해요\n- 코드가 정말 형편없어요!\n\n# 좋은 이메일을 작성하는 방법\n\n다행히도, 어떤 사이트들은 우리가 이런 지옥을 헤쳐나가는 데 도움을 줍니다:\n\n- Can I Email (CSS/HTML의 Can I Use에 해당하는 이메일 버전). 스코어보드는 어떤 클라이언트를 쉽게 지원할 수 있는지와 어떤 클라이언트를 지원하기 어려운지 보여주는 좋은 자료입니다... 각 CSS 기능에 대한 다양한 클라이언트를 쉽게 비교할 수도 있어요\n- Mailchimp 클라이언트 CSS 지원\n- Email On Acid의 블로그 포스트\n- 이메일용 CSS 지원에 대한 궁극의 안내서\n\n<div class=\"content-ad\"></div>\n\n## HTML 이메일을 작성해야 할 때의 주요 포인트와 배울 점을 소개합니다\n\n- 이메일 레이아웃을 구성할 때 Flexbox와 같은 현대 CSS 기술을 사용하지 말아야 합니다. 대신 옛날 방식의 테이블을 사용해야 합니다.\n- 스타일을 스타일 시트(내장 또는 연결된)로 작성해서는 안 됩니다. 스타일 시트는 일부 클라이언트(예: Gmail)에서 지원되지만, 해당 시트에 대한 몇 가지 규칙(예: 헤드 부분에만 지원, 최대 16ko, 스타일 시트의 속성 중 하나라도 지원되지 않으면 전체 스타일 시트가 삭제됨 등)이 있습니다. 대신 모든 스타일을 인라인으로 넣어야 합니다. 이를 위한 몇 가지 도구가 있습니다:\n   * Premailer\n   * Mailchimp의 CSS 인라이너 도구\n   * customer.io는 이를 처리하기 위해 CSS 전처리기를 \"브로드캐스트\"에 통합합니다.\n- 모든 CSS 선택자 및 속성이 지원되지 않으며, 지원 수준은 클라이언트에 크게 의존합니다. 동일한 클라이언트의 다른 앱들 사이에도 차이가 있을 수 있습니다(예: Gmail 데스크톱 웹메일, iOS 앱, 안드로이드 앱 및 모바일 웹메일 간의 차이) 그리고 물론 버전 간에도 (예: Outlook 데스크톱 클라이언트의 다른 버전들 간의 큰 차이가 있습니다). Hello GMail과 같이 일부 클라이언트들은 단 한 가지 속성만 지원되지 않아도 모든 스타일을 삭제할 수 있습니다. 이벤트의 경우(Gmail에서 다시 인사), 스타일은 한 \"보기 위치\"에서는 지원되지만 다른 곳에서는 그렇지 않을 수 있습니다(예: 전체 이메일을 크게 할 웹 뷰를 열 때 잘린 경우에는 GMail 주 inbox에 내장된 스타일 시트를 사용할 수 있지만, 동작하지 않습니다). 심지어 더 이상 이상할 정도로, 일부 클라이언트들(Gmail다시 한번)은 구글 계정만 사용하거나 구글 계정 없이 사용할 때도 일부 CSS 속성을 지원할 수 있습니다(GANGA 사건). 지원할 항목과 방법에 대해 어떤 선택을 할지에 대한 결정을 내려야 합니다. 일부 클라이언트에 대해 우아한 버전을 원하십니까(예: Gmail에서 지원되지 않지만 Apple Mail에서 지원되는 box-shadow 속성 추가)? 일부 클라이언트가 깨질 가능성이 있는 속성을 사용하십니까(따라서 해당 클라이언트를 \"지원하지 않는\" 클라이언트로서)? 등.\n- 이메일은 \"클립\" 또는 잘릴 수 있습니다. 예를 들어 Gmail은 이메일을 정확히 102Kb에서 자릅니다. 사용자에게는 클라이언트의 \"전체 메일 보기\"를 사용하거나(위에서 보았듯이 다른 CSS/HTML 지원을 가질 수 있음) 웹 뷰를 사용하는 선택만 남습니다. 물론, 자르기 동작 또는 길이는 전적으로 클라이언트 및 버전에 따라 달라집니다...\n\n## 전 세계에서 지원되는 좋거나 나쁜 기능의 짧은 목록을 원하신다면 다음과 같습니다.\n\n- flexbox를 사용할 수 없으며, 대신 `tables /`을 사용해야 합니다.\n- SVG를 사용할 수 없으며, 대신 일반 이미지를 사용해야 합니다.\n- 사용자 지정 글꼴을 사용할 수 없으며, 시스템 글꼴을 사용해야 합니다(그러나 사용자 지정 글꼴을 지원하는 클라이언트를 위해 `head /`에서 사용자 지정 글꼴을 추가할 수 있음에 유의하십시오).\n- box-shadow를 사용할 수 없습니다(그러나 일부 클라이언트는 지원하므로 해당 속성을 추가해도 됩니다). 그림자가 본적 필요한 경우, 테이블 안의 이미지의 오래된 방식으로 돌아가야 할 것입니다.\n- 요소를 위치시킬 수 없습니다(특히 고정, 붙박이 또는 절대 위치에).\n\n<div class=\"content-ad\"></div>\n\n# 평판에 관해서는?\n\n당신의 평판은 여러 요소에 달려 있어요: 도메인 이름과 이메일을 보내는 서버(즉, 발신자의 평판, 예: Sendgrid 등), 메시지 내용, 헤더의 존재 또는 부재, 링크와 이미지의 상태, 접근성 등이죠.\n\nSPF, DKIM, DMARC와 같은 적절한 DNS 구성의 중요성을 과소평가하지 마세요. 이는 SpamAssassin 노트를 크게 개선/균형을 맞출 수 있습니다.\n\n제공업체들은 종종 권장 사항을 업데이트합니다 (예: Yahoo와 Gmail). 그래서 이메일을 읽을 수 있도록 사용자를 원한다면 이러한 권장 사항을 지속적으로 확인하는 것이 매우 권장됩니다.\n\n<div class=\"content-ad\"></div>\n\n\"당신의 '신뢰도'를 크게 향상시키는 한 가지 방법은 이메일에 List-Unsubscribe 헤더를 제공하는 것입니다. 이 헤더를 추가하면 사용자가 클라이언트 내에서 쉽게 뉴스레터 구독 해지를 할 수 있게끔 버튼/링크를 쉽게 찾을 수 있게 됩니다.\n\nSpamAssassin (그리고 세계의 메일 제공업체들)에 대한 중요한 사실 중 하나는 .xyz와 같은 ‘이국적인’ 도메인 TLD(최상위 도메인)를 싫어합니다(🙄 snowball.xyz를 보고 있어요). 이러한 종류의 도메인을 사용하여 이메일을 보내거나 이메일에 이러한 도메인을 사용한 링크를 첨부하면 매우 부정적인 평판을 얻게 될 수 있습니다.\n\n이를 극복하는 한 가지 방법은 이메일을 보내거나 이메일 자산을 호스팅하고 '이국적' 도메인에 호스팅된 실제 제품으로 리디렉션하기 위해 전용 '신데렐라' 도메인(media-snowball.com 대신 snowball.xyz)을 사용하는 것입니다.\n\n또한, 이메일을 보내는 제공업체의 '추적자' URL을 사용하는 것은 링크의 나쁜 평판을 우회하는 대안일 수 있습니다. 예를 들어, Sendgrid는 보낸 이메일 내의 모든 링크를 추적하기 위한 특정 URL로 자동으로 대체합니다. '신데렐라' 도메인을 추적 도메인으로 구성한 경우, 이메일 내의 모든 '이국적' URL은 특정 '신데렐라' URL로 교체됩니다. 보너스로 추적이 가능합니다(예: 이메일 내의 모든 snowball.xyz URL은 자동으로 Sendgrid에 의해 url4000.media-snowball.com/ls/click?upn=`…` URL로 대체되어 snowball.xyz URL이 숨겨지게 됩니다).\"\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n어떤 이메일 클라이언트/제공 업체를 사용하고 있나요?\n- 애플\n- Gmail (Google 계정)\n- Gmail (비-Google 계정)\n- 야후\n- 오랑지\n- SFR\n- Free\n- La Poste\n- ProtonMail\n- 기타\n이메일을 어떻게 확인하시나요?\n- 데스크탑/노트북 컴퓨터에서 웹메일\n- 모바일에서 웹메일\n- Windows 클라이언트 (예: Outlook, Mozilla Thunderbird 등)\n- MacOS 클라이언트 (예: Apple Mail, Outlook, Mozilla Thunderbird 등)\n- Linux 클라이언트 (예: Mozilla Thunderbird 등)\n- iOS 앱\n- 안드로이드 앱\n- 기타\n```\n\n# 도움이 될만한 도구들\n\n그리고 여기 몇 가지 유용한 도구들이 있어요. 이 도구들을 사용하여 이메일 형식 및 유효성을 테스트하고 평가할 수 있습니다:\n\n- Email On Acid은 이메일을 만들고 최적화, 미리 보기, 테스트 및 유효성을 검사하는 데 도움을 줍니다. 그러나 솔루션이 상당히 비싼 편입니다.\n- Mail Tester는 이메일을 보낼 수 있는 이메일 주소를 제공하고 다음의 다양한 기준에 근거하여 이메일의 \"스팸 레벨\"을 평가합니다: 도메인, 헤더, 내용, SpamAssassin 결과, 깨진 링크 또는 이미지, URL 단축기 등등.. 그런 다음 당신에게 1에서 10까지의 점수와 평판 수준 향상을 위한 조언을 제공합니다.\n\n\n<div class=\"content-ad\"></div>\n\n- Sendgrid은 여러 클라이언트에서 이메일을 테스트할 수 있는 방법을 제공합니다. 테스트하려는 각 클라이언트 당 1크레딧을 사용해야하지만 그런 다음 해당 클라이언트에서 이메일을 실행하고 스크린샷 및 보고서를 제공합니다. 정말 유용합니다.\n\n이게 전부에요.\n도움이 되었기를 바랍니다.\n\n질문이 있으시면 언제든 댓글을 남기지 말고 질문해 주세요!\n\n스노볼을 위한 클레멘트❤️\n이 기사를 작성하는 데 도움을 준 요안 로페즈에게 감사드립니다 🙏","ogImage":{"url":"/assets/img/2024-06-20-SendingHTMLemails_0.png"},"coverImage":"/assets/img/2024-06-20-SendingHTMLemails_0.png","tag":["Tech"],"readingTime":7}],"page":"37","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}