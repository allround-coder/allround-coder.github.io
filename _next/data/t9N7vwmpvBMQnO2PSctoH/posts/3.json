{"pageProps":{"posts":[{"title":"Z-index 완벽 이해하기 - 흔한 오해와 CSS 작동 원리 분석","description":"","date":"2024-06-23 14:16","slug":"2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior","content":"\n\nUI 버그는 최고의 개발자들조차 괴롭히는 법이죠. 왜냐하면 백엔드 문제와는 달리, UI 문제를 디버깅하는 것은 코드 수정을 넘어 사용자가 보고 상호 작용하는 것이 완벽한지 확인하는 것이 중요하기 때문입니다. 화면 크기, 브라우저 버전 또는 심지어 사용자의 기기 등과 같은 요소에 영향을 받는 UI 버그는 사용자를 좌절시키고 브랜드 인식을 훼손시키며 전환을 방해할 수 있습니다. 심지어 보이는 것 같이 간단한 스타일링 문제조차 심각한 문제로 커질 수 있습니다.\n\n이러한 도전을 직접 경험할 수 있는 한 분야는 웹 페이지 스타일링입니다. CSS는 복잡하고 섬세할 수 있으며, 해당 속성을 오해하거나 잘못 사용하면 중대한 디버깅 노력을 필요로 합니다.\n\n## \"UI 혼란의 공통 원인은 z-index 속성입니다. z-index의 기본 동작 및 작동을 이해하는 것이 중요합니다. z-index가 어떻게 작동하는지 확실하게 이해하지 않으면 개발자들은 의도한대로 요소가 층으로 배치되지 않는 예상치 못한 레이아웃 문제를 쉽게 만날 수 있습니다.\"\n\n## Z-Index 속성\n\n<div class=\"content-ad\"></div>\n\n위 내용을 여러 번 읽으시는 것을 권장합니다. 정의 자체가 모든 것을 설명해 주지만, 코드를 작성할 때 종종 세부 사항을 놓치곤 합니다.\n\n이 속성은 웹 페이지의 요소 쌓임 순서를 제어하는 데 중요한 역할을 합니다. 그러나 요소의 위치 지정과 그들을 포함하는 컨테이너의 표시 속성과 같은 여러 요소에 의해 행동이 영향을 받을 수 있습니다.\n\n# 자세히 살펴보겠습니다:\n\n## 위치 지정된 요소:\n\n<div class=\"content-ad\"></div>\n\nz-index가 작동하려면 요소의 position 속성을 기본 값(static)이 아닌 다른 값으로 설정해야 합니다. 요소는 relative, absolute, fixed 또는 sticky 위치여야 합니다.\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_0.png)\n\n## Z-순서:\n\n이것은 화면에 수직인 z축을 따라 요소의 순서를 의미합니다. 이는 서로 위에 쌓인 종이 층으로 생각할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_1.png\" />\n\n## 자손:\n\nz-index는 위치가 지정된 요소 내의 모든 자식 요소에도 영향을 미칩니다. 이는 쌓임 순서가 요소 자체뿐만 아니라 해당 자식 요소에도 적용된다는 것을 의미합니다.\n\n<img src=\"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 정적 위치 지정에서 — 'Z-Index는 무시됩니다'\n\n기본적으로 요소들은 정적으로 위치 지정되어 있어 HTML 마크업에 나타나는 순서대로 렌더링됩니다. 이 상황에서 z-index 속성은 전혀 영향을 미치지 않고, 요소들은 DOM 트리 내에서의 위치에 따라만 쌓입니다.\n\n이는 DOM 트리에서 나중에 나타나는 요소가 항상 앞에 나타나는 요소 위에 일관되게 표시된다는 것을 의미합니다.\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_3.png)\n\n<div class=\"content-ad\"></div>\n\n# 정적(static) 이외의 위치 지정 - 'Z-index가 예상대로 작동합니다.'\n\n요소들이 position: relative, position: absolute, position: sticky 또는 position: fixed와 같은 속성을 사용하여 명시적으로 위치 지정된 경우, z-index 속성이 적용됩니다. 더 높은 z-index 값을 가진 요소는 낮은 z-index 값을 가진 요소 위에 나타납니다.\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_4.png)\n\n## 플렉스(flex) 또는 그리드(grid) 레이아웃 컨테이너\n\n<div class=\"content-ad\"></div>\n\n플랙스 또는 그리드 컨테이너에서 요소의 쌓임 순서는 z-index, 항목 순서 및 정렬을 결합한 요소로 결정됩니다. 요소들이 정적으로 배치되어 있더라도 z-index 속성은 컨테이너 내에서의 쌓임 순서에 영향을 줍니다.\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_5.png)\n\n이제 z-index 동작에 대한 기본적인 이해를 갖고 있으니, 스택 컨텍스트, 그 원리, 그리고 CSS가 코드를 어떻게 해석하거나 이해하는지에 대해 더 심층적으로 살펴보겠습니다.\n\n# 스택 컨텍스트란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nCSS의 쌓이는 컨텍스트는 웹페이지의 요소들을 위한 레이어 시스템입니다. 이는 요소들이 서로 어떻게 겹치는지를 결정합니다.\n\n한 페이지의 컨테이너 안에 객체들이 담겨 있다고 상상해보세요. 기본적으로, 그들을 넣은 순서대로 보이게 됩니다. 마치 접시 쌓아놓은 것처럼 말이죠. z-index 속성은 특별한 라벨 같은 것으로, 일부 접시에 붙일 수 있는 것입니다. 이것은 컨테이너 내에서만 영향을 미치며, 특정 컨테이너 안에서 다른 접시들 위에 라벨이 붙은 접시들이 나타나는 순서를 정할 수 있게 해줍니다.\n\n# 또한 쌓이는 컨텍스트를 폴더를 만들고 각 폴더가 자체적인 컨텍스트를 가지는 디렉토리 시스템으로 생각할 수 있습니다. 쌓이는 컨텍스트는 폴더를 만들 수 있고, 각 폴더가 자체적인 컨텍스트를 가질 수 있습니다. 쌓이는 컨텍스트는 폴더 안에 하위 폴더를 만들 수 있는 것처럼 중첩될 수 있습니다.\n\n![image](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_6.png)\n\n<div class=\"content-ad\"></div>\n\n## 새로운 쌓임 맥락은 무엇을 만들까요?\n\n새로운 쌓임 맥락은 여러 가지 방법으로 생성됩니다. 예를 들어:\n\n- 특정 CSS 속성을 사용하는 경우(static이 아닌 값으로 position, 값이 있는 z-index, 불투명도가 1 미만).\n- `iframe`과 같은 특정 요소 또는 transform, filter 또는 will-change와 같은 CSS 속성이 있는 요소.\n- 전체 목록을 보려면 이 곳을 방문하세요.\n\n# 예상치 못한 숨겨진 UI 요소: 쌓임 맥락에 대한 오해에서 발생하는 흔한 문제\n\n<div class=\"content-ad\"></div>\n\n다음 예제를 고려해 보세요:\n\n```js\n<div class=”rectangular-bg”>\n <div class=”circle”></div>\n <div class=”triangle”></div>\n</div>\n```\n\n우리가 `.circle`에 음수 z-index와 position: relative를 적용하면 이미지에 표시된 대로 원이 사라집니다. 그 원은 실제로 부모인 직사각형 배경 뒤에 숨겨져 있습니다.\n\n<img src=\"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_7.png\" />\n\n<div class=\"content-ad\"></div>\n\n여기가 이유입니다: position: relative와 함께 z-index: -1을 추가하면 원에 대한 새로운 쌓임 맥락이 생성됩니다. 이 새로운 쌓임 맥락은 기본 루트 쌓임 맥락(전체 페이지)의 일부입니다.\n\n원의 z-index 속성은 해당 부모 쌓임 맥락에 대해 동작합니다. 부모 요소(직사각형 배경)에 z-index가 없기 때문에 원은 그 뒤에 렌더링됩니다.\n\n## - z-index는 부모 컨테이너에 상대적입니다\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_8.png)\n\n<div class=\"content-ad\"></div>\n\n지금 원의 부모 쌓임 문맥은 z-index가 1인 직사각형 배경이며, 따라서 원의 z-index는 직사각형 배경 쌓임 문맥을 기준으로 계산됩니다. 즉, 1+(-1) = 0이 됩니다.\n\n## - 투명도를 사용한 쌓임 문맥\n\n원을 삼각형 위로 올리고 싶습니다. z-index를 사용하지 않고 이를 어떻게 구현할 수 있을까요?\n\n<img src=\"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_9.png\" />\n\n<div class=\"content-ad\"></div>\n\n동그라미의 불투명도를 1보다 작게 설정하거나 변형 속성을 사용하여 설정할 수 있습니다. 이전에 논의했던 대로 이는 새로운 콘텍스트를 생성하게 됩니다. 이것으로 원이 삼각형 위에 올라가게 됩니다.\n\n# 스택 컨텍스트와 다양한 복잡한 시나리오에서의 z-index 동작에 대한 흥미로운 예시들을 살펴봅시다.\n\n## z-index로 스택 컨텍스트 만들기\n\n모양이라는 div가 자체 스택 컨텍스트를 가지고 있다고 가정해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n삼각형이 지금은 사각형과 원 위에 있어요.\n\n- 사각형 위에 있는 이유는, 도형들과 관련해서 삼각형이 1층 위에 있기 때문이에요.\n- 원 위에 있는 이유는, 원이 z-index를 설정하지 않았고, 동생 폴리곤과 동일한 쌓임 맥락에 속하기 때문이에요. 즉, 원의 z-index는 부모 도형으로부터 전달된 1의 값을 가지고 있어요.\n\n이제 삼각형이 사각형 위에 위치하되 원 위에 위치하지 않게 하고 싶다고 해보죠. 이를 해결하기 위해서, 폴리곤의 z-index나 원의 z-index를 변경할 수 있어요. 아래 이미지를 확인해주세요.\n\n이미지의 두 번째 예시에서는 원의 z-index가 사각형보다 높은 값을 가지고 있어요.\n\n<div class=\"content-ad\"></div>\n\n삼각형이 원 앞에 나타나길 원한다면, 삼각형에 높은 z-index를 설정하는 것만으로는 동작하지 않습니다. 어떤 값이든 상관없이 삼각형의 z-index는 그 쌓임 맥락(다각형) 내에서만 적용되기 때문입니다.\n\nz-index에 대해 까다로운 점은 요소의 쌓임 맥락 내에서만 작동한다는 것입니다. 우리의 경우, 우리는 삼각형이 다각형 쌓임 맥락의 일부인 채로 원(다른 쌓임 맥락) 앞에 나타나길 원합니다. 이것은 불가능합니다.\n\n삼각형이 원 앞에 나타나게 하려면, 다각형에서의 쌓임 맥락을 제거해야 합니다.\n\n이제 삼각형과 원은 동일한 쌓임 맥락을 공유하게 되어, 높은 z-index로 삼각형이 원 앞에 나타나도록 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 주요 학습 내용:\n\n- 위치 지정이 필요한 속성: z-index 속성은 요소의 위치를 상대적, 절대적, 고정된 또는 고정 흐름 속성으로 설정해야 합니다.\n- 플렉스 및 그리드 컨테이너: 이러한 컨테이너 내에서도 z-index는 항목 순서와 정렬에 영향을 받아 쌓이는 순서를 제어합니다.\n- Z-순서: 이것은 요소의 z 축을 따라 순서를 결정합니다. 높은 z-index 값은 위에 표시됩니다.\n- 쌓임 컨텍스트: 요소들을 위한 특별한 레이어입니다. 동일한 쌓임 컨텍스트 내의 요소는 z-index를 사용하여 쌓일 수 있지만 다른 쌓임 컨텍스트 내의 요소는 직접적으로 서로의 쌓임 순서에 영향을 줄 수 없습니다.\n- 쌓임 컨텍스트 생성: 불투명도, 변형, 필터 및 will-change와 같은 CSS 속성을 사용하여 새로운 쌓임 컨텍스트를 생성할 수 있습니다.\n\n# 결론:\n\nCSS는 복잡할 수 있으며 z-index와 같은 속성의 세부 사항을 이해하지 못하면 중대한 디버깅 노력을 초래할 수 있습니다. 요소들의 층을 올바르게 제어하는 방법을 알고 있다면 일반적인 함정을 피하고 시간을 절약하며 웹사이트에서 사용자 경험을 향상시킬 수 있습니다. 이러한 원칙을 구현하여 요소가 정확히 표시되고 의도한 대로 쌓이며 매끄럽고 매력적인 시각적 프레젠테이션에 기여하도록 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료:\n\n- https://web.dev/learn/css/z-index\n- https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context\n- https://ishadeed.com/article/understanding-z-index/\n\n# 저자 소개:\n\nKshitij은 React, Next.js 및 TypeScript에 튼튼한 기반을 갖춘 프론트엔드 개발자입니다. 그는 React와 WebGL의 힘을 활용하여 사용자 경험과 비즈니스 목표를 일치시키는 몰입형 웹 경험을 개발하는 전문가입니다. 대화형 3D 랜딩 페이지부터 복잡한 암호 웹 앱까지 다양한 20개 이상의 프로젝트에 참여했습니다.\n\n<div class=\"content-ad\"></div>\n\n더문데브 블로그 편집팀은 이 기사에서 제시된 코드 샘플 및 기술적 콘텐츠를 검토해 주신 수바카르 티키레디에게 감사의 마음을 전합니다.","ogImage":{"url":"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_0.png"},"coverImage":"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_0.png","tag":["Tech"],"readingTime":7},{"title":"라이브러리나 커스텀 알고리즘 없이 모던 컬러 스케일 만드는 방법","description":"","date":"2024-06-23 14:14","slug":"2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms","content":"\n\n![이미지](/assets/img/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms_0.png)\n\n## 왜 색상 척도를 사용해야 하는가?\n\n웹 애플리케이션에서 숫자를 단순히 숫자로만 표시하는 것보다 숫자에 해당하는 색상으로 숫자를 표현하는 것이 좋은 아이디어일 수 있습니다. 색상 척도에서 값의 위치에 해당하는 색상으로 채워진 숫자로만 수치적인 값을 전달하는 것이 더 쉽습니다. 모든게 빨간색으로 되어 있으면 상황을 이해하기 위해 숫자를 읽을 필요가 없을 수도 있습니다.\n\n텍스트의 색상도 유용할 수 있습니다. 예를 들어, 텍스트 분류 작업에서는 사용자가 입력 텍스트의 각 단어가 예측된 레이블에 미치는 기여도를 보는 것을 좋아합니다. 색상 척도는 각 단어의 점수를 시각적으로 나타내는 효과적인 수단입니다. 프랑스 명사의 끝과 성별 간 상관 관계에 대한 이전에 공유된 게시물에서 접미사의 양적 여성성과 남성성을 시각화하기 위해 분홍-파랑 척도를 사용했습니다.\n\n<div class=\"content-ad\"></div>\n\n의미 있는 색상으로 값을 강조하려면 두 가지 도구가 필요합니다:\n\n- 숫자 범위에 시각적으로 해당하는 균일한 색상 범위를 생성하는 함수\n- 사용된 범위 내에서 주어진 위치에 해당하는 색상을 반환하는 함수\n\n## 두 색상 사이에 선형 그라데이션을 생성하는 여러 가지 방법\n\n두 가지 다른 색상 사이의 경로는 완전히 다른 색이거나 심지어 자연적으로 관련이 없는 색 또는 한계 색의 음영일 수 있는 다른 색상을 통해 지나갑니다. 위의 이미지에서 확인할 수 있습니다. 경로상의 색상은 모든 가능한 색상이 계산 중에 어떻게 배열되는지에 따라 달라집니다. 현대 CSS는 15가지 색 공간을 지원합니다. 그 중 4가지는 극좌표입니다. 극좌표 공간의 두 색상 사이의 경로는 짧을 수도 있고 길 수도 있습니다. 따라서 브라우저는 CSS 함수 linear-gradient()를 사용하여 어떤 두 색상 사이의 19가지 서로 다른 경로를 생성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nbackground: linear-gradient(in hsl shorter hue, limegreen, red);\n```\n\n일부 알고리즘의 결과는 매우 다른 이름을 갖고 있더라도 상당히 유사합니다. Limegreen과 red 사이의 모든 가능한 그라데이션을 담은 상단 이미지에서, 익숙한 노란색을 중간에 통과해야 하는 경우 hsl 또는 hwb의 더 짧은 방식을 선택할 수 있습니다. display-p3, a98-rgb, prophoto-rgb 또는 rec2020 방법을 사용하면 녹색에서 붉은색으로의 전이도 중간쯤에서 발생하지만 노란색 조합은 없습니다.\n\n그러나 red가 springgreen과 섞이면 19개의 방법 중 어느 것도 완벽한 그라데이션을 생성하지 못합니다. 같은 방법으로 생성된 그라데이션에서의 녹색에서 붉은색으로의 전환은 50% 아래로 보입니다. hsl 또는 hwb의 더 짧은 방식으로 생성된 그라데이션에서 노란색은 바로 40%에 위치합니다. 나에게는 srgb-linear 그라데이션이 가장 좋아 보입니다.\n\n<img src=\"/assets/img/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms_1.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n그래서 기본적으로 두 색상 사이의 점진적인 전환을 계산하는 다양한 방법이 있습니다. 그러나 모든 가능한 색상 조합에 대해 시각적으로 일정한 그라데이션을 만들어내는 보편적인 방법은 없습니다. 특정 두 색상을 균일하게 섞는 것이 항상 가능한 것도 아닙니다. 색상 척도를 만들려면 약간의 시도와 실험을 통해 두 색상을 선택하고 이를 균일하게 섞는 방법을 선택해야 합니다.\n\n## 숫자 값과 그라데이션 내 색상 매핑\n\n오늘날, 그라데이션의 특정 위치에 해당하는 색상을 검색할 수 있는 새로운 CSS 함수 color-mix()가 있습니다. 이 함수는 모든 브라우저에서 지원됩니다. 이 함수는 지정된 두 색상의 지정된 백분율을 사용하여 어떤 방법으로든 두 색상을 섞은 결과인 색상을 반환합니다. 다시 말해, 이 함수는 선형 그라데이션의 지정된 위치에 해당하는 색상을 반환합니다. 위치는 한 색상의 백분율로 지정되며, 두 번째 색상의 백분율은 100%에서 남은 값입니다. 예를 들어, hsl 더 긴색채에 대한 20의 색상 값을 사용할 때:\n\n```js\ncolor: color-mix(in hsl longer hue, limegreen, 20%, red)\n```\n\n<div class=\"content-ad\"></div>\n\n## 요약\n\n위의 화려한 백분율이 있는 그림들은 새로운 CSS 기능인 color-mix()에 의해 활성화됩니다. 색상 라벨, 그리드 라인 및 그라데이션은 쉬운 CSS를 사용하여 색상 스케일로 배열할 수 있습니다.\n\n전체 코드를 다음 페이지에서 확인할 수 있습니다: [링크](https://marianc000.github.io/colorScales/), 또는 [여기](https://github.com/marianc000/colorScales)에서 다운로드할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms_0.png"},"coverImage":"/assets/img/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms_0.png","tag":["Tech"],"readingTime":3},{"title":"Angular에서 이벤트 핸들링 HostListener와 HostBinding 탐구하기","description":"","date":"2024-06-23 14:13","slug":"2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding","content":"\n\n<img src=\"/assets/img/2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding_0.png\" />\n\n안녕하세요!\n저는 Angular에서 거의 잊혀진 2가지 디렉티브를 소개하고 싶어요. 이 디렉티브들은 웹 페이지를 더 매혹적이고 매력적으로 만드는 열쇠를 쥐고 있어요.\n\n# 소개\n\nAngular에서 이벤트 처리는 상호작용적이고 동적인 애플리케이션을 만드는 데 중요한 역할을 합니다. HostListener와 HostBinding이라는 두 강력한 데코레이터는 컴포넌트나 디렉티브 내에서 호스트 요소의 이벤트를 처리하고 속성을 바인딩하는 중요한 기능을 제공합니다. 이 글에서는 HostListener와 HostBinding의 기술적 측면, 사용 방법, 예제, 차이점 및 최적 사용 방법에 대해 자세히 알아보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# HostListener\n\nHostListener는 Angular에서 호스트 요소에서 이벤트를 수신할 수 있게 해주는 데코레이터입니다. 컴포넌트나 디렉티브의 호스트 요소에서 발생하는 이벤트를 수신하도록 할 수 있습니다. 클릭, 키 변경, 스크롤 등의 이벤트에 대응하여 DOM 요소에 이벤트 핸들러를 추가할 수 있습니다. 컴포넌트 메소드를 특정 이벤트에 바인딩하여 이벤트가 발생할 때 해당 메소드를 실행할 수 있습니다.\n\n## Import/Usage\n\nHostListener를 가져오고 사용하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n1- @angular/core에서 필요한 데코레이터를 가져와주세요:\n\n```js\nimport { Component, Directive, HostListener } from '@angular/core';\n```\n\n2- 컴포넌트나 디렉티브 내에서 적절한 속성이나 메소드에 HostListener 데코레이터를 적용해주세요.\n\n## 예시 1:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, HostListener } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `<button (click)=\"onClick()\">Click Here</button>`\n})\nexport class ExampleComponent {\n  @HostListener('document:keydown', ['$event'])\n  handleKeyboardEvent(event: KeyboardEvent) {\n    console.log('Key pressed:', event.key);\n  }\n\n  onClick() {\n    console.log('Button clicked');\n  }\n}\n```\n\n이 예시에서는 HostListener를 사용하여 문서에서 keydown 이벤트를 감지하고 해당 이벤트가 트리거될 때 handleKeyboardEvent() 메소드를 호출합니다. 이 handleKeyboardEvent() 메소드는 키를 누를 때마다 메시지를 보여줍니다.\n\n또한 버튼에 일반 클릭 이벤트를 사용하여 onClick() 메소드를 호출합니다.\n\n## 예시 2:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { HostListener, Component } from \"@angular/core\";\n\n@Component({\n  selector: 'app',\n  template: `<h1>Hello, you have pressed enter {counter} number of times!</h1> Press enter key\nto increment the counter.\n  <button (click)=\"resetCounter()\">Reset Counter</button>`\n})\nclass AppComponent {\n  counter = 0;\n  @HostListener('window:keydown.enter', ['$event'])\n  handleKeyDown(event: KeyboardEvent) {\n    this.counter++;\n  }\n\n  @HostListener('window:keydown.Backspace', ['$event'])\n  handleBackspace(event: KeyboardEvent) {\n    this.counter--;\n  }\n\n  resetCounter() {\n    this.counter = 0;\n  }\n}\n```\n\n이 경우, 이 예제에서는 Angular 컴포넌트가 정의되어 있습니다. 해당 컴포넌트는 카운터와 버튼을 표시합니다. Enter 키를 누를 때마다 카운터가 증가하고, BackSpace 키를 누를 때마다 카운터가 감소하며, 버튼을 클릭하여 0으로 재설정할 수 있습니다.\n\n@HostListener 데코레이터는 창에서 `keydown.enter` 이벤트를 감지하고 해당 이벤트가 발생할 때마다 handleKeyDown 메서드를 호출합니다. handleKeyDown 메서드에서는 카운터가 하나씩 증가합니다.\n\n비슷한 아이디어가 적용됩니다. HostListener 데코레이터가 창에서 `keydown.Backspace` 이벤트를 감지하고 'Backspace' 이벤트가 발생할 때마다 handleKeyDown 메서드를 호출합니다(카운터가 하나씩 감소).\n\n<div class=\"content-ad\"></div>\n\n마지막으로 resetCounter 메서드는 카운터 변수에 0의 값을 할당합니다.\n\n## HostBinding\n\nHostBinding은 Angular에서 호스트 요소의 속성을 컴포넌트 또는 디렉티브의 속성에 바인딩할 수 있게 해주는 또 다른 데코레이터입니다. 이를 사용하여 호스트 요소에 속성 값을 설정하는 데 사용하며 컴포넌트 또는 디렉티브 속성의 값에 따라 호스트 요소에 속성 값을 설정합니다.\n\n## Import/사용법\n\n<div class=\"content-ad\"></div>\n\nHostBinding을 가져와 사용하려면 다음 단계를 따르세요:\n\n1- @angular/core에서 필요한 데코레이터를 가져옵니다:\n\n```js\nimport { Component, Directive, HostBinding } from '@angular/core';\n```\n\n2- HostBinding 데코레이터를 컴포넌트나 디렉티브의 적절한 속성에 적용하세요.\n\n<div class=\"content-ad\"></div>\n\n# 예시 1\n\n```js\nimport { Component, HostBinding } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `<div>컴포넌트 내용</div>`,\n  styles: [`\n    :host {\n      display: block;\n      background-color: yellow;\n    }\n  `]\n})\nexport class ExampleComponent {\n  @HostBinding('style.color') color = 'red';\n  @HostBinding('class.active') isActive = true;\n}\n```\n\n이 예시에서는 HostBinding을 사용하여 호스트 요소의 style.color 속성을 컴포넌트의 color 속성과 바인딩합니다. 또한 호스트 요소의 active 클래스를 컴포넌트의 isActive 속성과 바인딩합니다. 이를 통해 컴포넌트의 속성 값에 따라 호스트 요소에 값을 설정할 수 있습니다.\n\n# 예시 2\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, HostBinding } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `<div>Component Content</div>`,\n  styles: [`\n    :host {\n      display: block;\n      background-color: yellow;\n    }\n  `]\n})\nexport class ExampleComponent {\n  @HostBinding('attr.role') role = 'button';\n}\n```\n\n이 예제에서는 HostBinding을 사용하여 호스트 요소의 role 속성을 컴포넌트의 role 속성과 바인딩합니다. 이를 통해 호스트 요소의 role 속성을 동적으로 설정할 수 있게 됩니다.\n\n# 차이점 및 사용 방법\n\nHostListener와 HostBinding의 주요 차이점은 기능입니다:\n\n<div class=\"content-ad\"></div>\n\n- HostListener은 호스트 요소에서 특정 이벤트를 수신하고 해당 이벤트에 따라 구성 요소나 지시문 메서드를 실행하는 데 사용됩니다. 예를 들어, 클릭 또는 키 변경과 같은 이벤트가 있습니다.\n- HostBinding은 구성 요소나 지시문 속성을 호스트 요소의 속성에 바인딩하고 이러한 속성 값에 따라 호스트 요소에 값을 설정하는 데 사용됩니다. 구성 요소나 지시문 속성 값에 따라 호스트 요소의 속성에 값을 설정해야 하는 경우에 사용하며, 스타일, 클래스 등과 같은 속성에 값을 설정하는 데 유용합니다.\n\n# 결론\n\n본 문서에서는 Angular에서 강력한 데코레이터인 HostListener와 HostBinding을 탐색했습니다. HostListener를 사용하면 호스트 요소에서 이벤트를 수신하고 해당 이벤트에 따라 메서드를 실행할 수 있습니다. HostBinding을 사용하면 구성 요소나 지시문 속성을 호스트 요소의 속성에 바인딩하여 호스트 요소를 동적으로 조작할 수 있습니다. 이러한 데코레이터를 사용하는 방법과 차이점을 이해하고 최선의 실천 방법을 알아보면 Angular 애플리케이션을 상호작용적이고 반응적으로 개선할 수 있습니다.\n\n관심 가져주셔서 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료\n\n- https://angular.io/api/core/HostListener\n- https://angular.io/api/core/HostBinding\n- https://www.digitalocean.com/community/tutorials/angular-hostbinding-hostlistener","ogImage":{"url":"/assets/img/2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding_0.png"},"coverImage":"/assets/img/2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular에서 Command 패턴 소개","description":"","date":"2024-06-23 14:12","slug":"2024-06-23-IntroductiontoCommandPatterninAngular","content":"\n\n<img src=\"/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_0.png\" />\n\n# 소개\n\n작업을 위임하는 몇 가지 방법이 있습니다. 이 상황에서는 드롭다운 옵션을 선택했을 때 경로 시각화의 표시 모드가 변경됩니다.\n\n직접적인 해결책은 컨트롤러 패널에서 SVG 경로로 작업을 위임하기 위해 옵저버 패턴을 사용하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 이 시나리오에 관찰자 패턴을 적용하는 데는 여전히 일부 단점이 있습니다. 이 글에서는 명령 패턴의 소개와 왜 더 나은 해결책이라고 생각했는지를 공유하고 싶습니다.\n\n## 안건\n\n이 글에는 몇 가지 주제가 있습니다.\n\n- 토론: 관찰자 패턴 vs 명령 패턴\n- 구현: 명령 패턴으로 제어 패널 리팩터링\n- RxJS를 사용한 실행 취소 및 재설정 구현\n- 데모\n\n<div class=\"content-ad\"></div>\n\n## 이 시리즈에 대해\n\n이 시리즈는 프론트엔드 프레임워크와 디자인 패턴을 어떻게 사용하는지 배우는 데 목표를 두고 있습니다.\n\n- 기사 1. React에서 Angular로: 전략 패턴 및 동적 렌더링 구현\n- 기사 2. Angular에서 빌더 패턴과 책임 연쇄 패턴을 사용하여 객체 생성 프로세스를 리팩터링\n- 기사 3. Observer 패턴을 사용하여 다른 조상 React 컴포넌트 간의 통신 구현\n- 기사 4. Angular에서 Command 패턴 소개 (이 기사)\n\n# 토론: Observer 패턴 vs Command 패턴\n\n<div class=\"content-ad\"></div>\n\n## 옵저버 패턴\n\n옵저버 패턴의 주요 역할을 보여주는 다음 다이어그램입니다.\n\n![Observer Pattern Diagram](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_1.png)\n\n옵저버 패턴은 옵저버와 서브젝트로 구성되어 있습니다. 우리의 시나리오에 이 패턴을 어떻게 매핑할 수 있는지 쉽게 상상해볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 드롭다운 선택이 변경되면 Subject가 Observer에게 알림을 보냅니다.\n- Subject에는 이벤트 유형과 필요한 매개변수가 포함됩니다.\n- 그런 다음 Observer는 이벤트에 따라 해당 작업을 수행할 수 있습니다.\n\n그러나 이 시나리오에이 패턴을 적용할 때 일부 단점이 있습니다.\n\n- 컨트롤 패널이 커질수록 SVG 경로 구성 요소가 커집니다 (해당 작업을 수행하기 전에 Subject를 분석해야 하기 때문)\n- 되돌리기 기능을 구현하는 것이 직접적이지 않습니다 (Observer 패턴이 자연스럽게 이벤트를 캡슐화하고 저장하지 않기 때문)\n\n![이미지](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_2.png)\n\n<div class=\"content-ad\"></div>\n\n## Command Pattern\n\nCommand 패턴의 주요 역할을 보여주는 다음 다이어그램입니다.\n\n![Command Pattern Diagram](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_3.png)\n\nCommand 패턴의 Subject는 Observer에 이벤트와 분리된 매개변수를 보내는 대신, 매개변수를 하나의 객체로 캡슐화하고 Receiver를 직접 조작하기 위해 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n- 해당 명령은 작업에 필요한 매개변수와 명령 유형을 분석하는 논리를 캡슐화합니다. 드롭다운 선택이 변경되면 인보커가 생성된 명령을 실행합니다.\n- 수신자(SVG 경로의 구성 요소)는 명령에 따라 해당 작업을 수행합니다.\n\n여러 가지 이점이 있습니다.\n\n- 제어 패널이 커질 때 SVG 경로의 구성 요소가 커지지 않습니다 (분석 논리가 명령 객체로 이동되기 때문)\n- Undo 기능에 대해 간단합니다 (명령 패턴이 명령을 캡슐화하고 저장하기 때문)\n\n![이미지](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_4.png)\n\n<div class=\"content-ad\"></div>\n\n# 구현: 명령 패턴을 사용하여 제어 패널 다시 구성하기\n\n이 구현은 이 기사의 예시 D3.js 프로젝트 (데모)를 기반으로 합니다. 이전에는 범례, 노드 및 엣지가 단일 구성 요소에 있었기 때문에 서로 다른 구성 요소 간의 작업을 위임할 필요가 없었습니다.\n\n이제 제어 패널 항목들을 독립적인 구성 요소 (호출자)로 이동하고 작업을 SVG 경로 구성 요소 (수신기)로 위임하는 명령 패턴을 구현하고자 합니다.\n\n## 준비하기\n\n<div class=\"content-ad\"></div>\n\n- 필요한 패키지 설치하기\n\n```js\nnpm install @ng-select/ng-select@^9.1.0\nnpm install lodash@^4.17.21\n```\n\n- 필요한 컴포넌트 및 서비스 생성하기\n\n```js\nng g c topology\nng g c topology/topology-controller/topology-controller-assistant\nng g s topology/topology-controller/topology-controller-assistant\n```\n\n<div class=\"content-ad\"></div>\n\n- 필요한 모델을 생성하세요\n\n- Invoker, Receiver, 그리고 Command에 대한 필요한 인터페이스와 클래스를 생성하세요\n\n## Invoker 구현: 드롭다운 컴포넌트 업데이트\n\n이 경우에 Invoker는 ng-select 컴포넌트입니다.\n\n<div class=\"content-ad\"></div>\n\n- topology-controller-assistant.component.html을 업데이트하십시오.\n\n구현 세부 정보는 공개하지 않지만, Invoker가 어떻게 작동하는지에만 집중하세요.\n\n- topology-controller-assistant.service.ts를 업데이트하십시오.\n— 서비스는 드롭다운 컴포넌트에 옵션을 제공합니다 (라인 5 ~ 10)\n\n- topology-controller-assistant.component.ts를 업데이트하십시오.\n- 이 컴포넌트는 TopologyCommandInvoker 인터페이스를 구현해야 합니다.\n- 초기화할 때, 이 컴포넌트는 리소스를 검색할 것입니다 (라인 42)\n- Invoker는 호출할 때 커맨드를 스택에 저장할 것입니다 (라인 88)\n\n<div class=\"content-ad\"></div>\n\n## 수신기 구현: SVG 경로 구성 요소 업데이트\n\n- topology.component.ts 파일을 업데이트하세요.\n- 이 구성 요소의 자세한 코드는 이 기사를 참조해주세요.\n- 이 구성 요소는 TopologyCommandReceiver 인터페이스를 구현해야합니다.\n\n## 클라이언트 구현: 루트 구성 요소 업데이트\n\n클라이언트는 Invokers와 Receivers 간의 다리 역할을 하며 ViewChild를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n- app.component.html 파일을 업데이트하세요.\n- app.component.ts 파일을 업데이트하세요.\n- ViewChild를 사용하여 Invokers 및 Receivers를 검색하세요 (11 ~ 12번 라인).\n- commandStack 및 makeCommand를 Invokers와 Receivers에 위임하세요 (17 ~ 18번 라인).\n\n# RxJS를 이용한 실행 취소 및 재설정의 구현\n\n마지막 섹션에서 명령을 호출할 때 이미 명령을 스택에 푸시했습니다.\n\n<div class=\"content-ad\"></div>\n\n`undo` 기능을 구현할 때는 최신 Command를 제거하고 이전 Command를 되돌리는 Command를 실행하면 된다. `reset` 기능을 구현할 때는 스택을 지우고 이전 명령을 모두 되돌리면 된다.\n\n![CommandPattern](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_5.png)\n\n## Undo 버튼 구현: 루트 컴포넌트 업데이트\n\n- app.component.html 파일 업데이트\n- undo 및 reset을 위한 새로운 버튼 추가 (라인 15 ~ 18)\n- undoConfiguration$ 및 resetConfiguration$를 input() 매개변수로 전달 (라인 8 ~ 9)\n\n<div class=\"content-ad\"></div>\n\n- app.component.ts 파일을 업데이트해주세요\n\n## 옵저버 구현: 드롭다운 컴포넌트 업데이트하기\n\n- topology-controller-assistant.component.ts 파일을 업데이트해주세요\n- undoConfiguration$ 및 resetConfiguration$를 구독해주세요 (19 ~ 20번 라인)\n\n# 데모\n\n<div class=\"content-ad\"></div>\n\n- 리팩터링 전\n\n- 리팩터링 후\n\n# 참고\n\n- Callback/Command vs EventListener/Observer Pattern\n\n<div class=\"content-ad\"></div>\n\n# 개요\n\n끝까지 참아주셔서 감사합니다. 저는 션입니다. 소프트웨어 엔지니어로 일하고 있어요.\n\n이 글은 제 노트입니다. 실수가 있으면 자유롭게 조언해주세요. 피드백을 기다리고 있겠습니다.\n\n- 구독하기\n\n<div class=\"content-ad\"></div>\n\n- 기사를 위한 Facebook 페이지\n\n- 데일리 러닝 웹사이트\n\n- 데일리 러닝 라인 봇\n\n![image](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_6.png)\n\n<div class=\"content-ad\"></div>\n\n# 관련 주제\n\nKnout.js 및 ReactJS에서 양방향 바인딩을 사용하는 방법\n\nSignalR을 활용하여 채팅방 애플리케이션 만드는 법을 배워보세요\n\n'Effective SQL'에 대한 제 생각:\n\n<div class=\"content-ad\"></div>\n\nIT 및 네트워크:","ogImage":{"url":"/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_0.png"},"coverImage":"/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular에서 꼭 알아야 할 RxJS 연산자들","description":"","date":"2024-06-23 14:10","slug":"2024-06-23-RxJSOperatorsinAngular","content":"\n\nRxJS 연산자는 Angular의 강력한 기능으로, 데이터 스트림을 조작하고 변환할 수 있는 기능입니다. Observable과 함께 사용하여 데이터를 필터링, 매핑, 축소하고 기타 작업을 수행할 수 있습니다.\n\n파이프 연산자(Pipeable Operator)는 Observable을 입력으로 받아 다른 Observable을 반환하는 함수입니다. 이는 순수한 작업입니다: 이전 Observable은 변경되지 않습니다.\n\n다음은 Angular에서 자주 사용되는 몇 가지 RxJS 연산자 예시입니다:\n\n- map: 이 연산자는 observable에서 방출되는 데이터를 변환하는 데 사용됩니다. 예를 들어, 숫자 스트림을 방출하는 observable이 있다면, 각 숫자의 값을 두 배로 만들기 위해 map 연산자를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\nimport 'of' from ‘rxjs’;\n\nimport 'map' from ‘rxjs/operators’;\n\n![Image 1](/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png)\n\n![Image 2](/assets/img/2024-06-23-RxJSOperatorsinAngular_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n- filter : 이 연산자는 옵저버블에서 방출된 데이터를 필터링하는 데 사용됩니다. 예를 들어, 숫자 스트림을 방출하는 옵저버블이 있다면, filter 연산자를 사용하여 짝수만 방출할 수 있습니다:\n\n```javascript\nimport { of } from ‘rxjs’;\nimport { filter } from ‘rxjs/operators’;\n```\n\n![RxJS Operators in Angular](/assets/img/2024-06-23-RxJSOperatorsinAngular_2.png)\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-23-RxJSOperatorsinAngular_3.png)\n\n- mergeMap: 이 연산자는 여러 개의 옵저버블을 하나의 옵저버블로 병합하는 데 사용됩니다. 예를 들어 데이터 스트림을 방출하는 두 옵저버블이 있다면 mergeMap 연산자를 사용하여 두 스트림을 하나로 병합할 수 있습니다:\n\nimport { of } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지1](/assets/img/2024-06-23-RxJSOperatorsinAngular_4.png)\n\n![이미지2](/assets/img/2024-06-23-RxJSOperatorsinAngular_5.png)\n\n- forkJoin: RxJS의 forkJoin 연산자는 여러 옵저버블이 완료될 때까지 기다린 다음 각 옵저버블이 발행한 마지막 값의 배열을 방출하는 데 사용됩니다. 이 연산자는 여러 요청을 동시에 수행하고 모든 요청이 완료된 후에만 작업을 수행해야 할 때 유용합니다.\n\n아래는 Angular에서 forkJoin을 사용하여 여러 HTTP 요청을 수행한 다음 결과를 결합하는 예시입니다:\n\n\n<div class=\"content-ad\"></div>\n\n```typescript\nimport { forkJoin, of } from 'rxjs';\n\nimport { HttpClient } from '@angular/common/http';\n\nconstructor(private http: HttpClient) {}\n\n![RxJS Operators in Angular 6](/assets/img/2024-06-23-RxJSOperatorsinAngular_6.png)\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 HttpClient 모듈을 사용하여 두 개의 HTTP 요청을 보냈고 forkJoin 연산자를 사용하여 두 요청이 완료될 때까지 기다렸습니다. 그런 다음 구독(subscribe) 메서드를 사용하여 결과를 처리하는데, 이는 두 요청에서 마지막으로 방출된 값들의 배열입니다.\n\n또한 forkJoin은 observables의 배열을 사용할 수도 있으므로 2개 이상의 요청을 기다리는 데 사용할 수 있습니다.\n\nforkJoin은 여러 요청이 완료될 때까지 기다려야 하는 경우 유용한 연산자이며, 코드를 더 읽기 쉽고 유지 관리하기 쉽게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- switchMap: RxJS의 switchMap 연산자는 옵저버블에서 방출되는 값들을 주어진 함수를 적용하여 새로운 옵저버블로 평탄화하는 데 사용됩니다. 이 연산자는 현재 옵저버블의 값에 따라 요청을 만든 다음 값이 변경되면 새로운 옵저버블로 전환할 때 유용합니다.\n\n다음은 Angular에서 switchMap을 사용하여 검색 입력란에 입력된 텍스트를 기반으로 서버에서 사용자를 검색하는 방법의 예시입니다:\n\n![이미지](/assets/img/2024-06-23-RxJSOperatorsinAngular_8.png)\n\n위 예시에서 fromEvent는 사용자가 검색 입력란에 타이핑할 때 이벤트를 방출하는 옵저버블을 만드는 데 사용되고, debounceTime 연산자는 사용자가 타이핑을 멈출 때까지 기다렸다가 값을 방출하는 데 사용됩니다. distinctUntilChanged 연산자는 값이 변경될 때만 값을 방출하고, 마지막으로 switchMap은 http 요청에 의해 생성된 새로운 옵저버블로 전환하는 데 사용됩니다. 각 새로운 keyup 이벤트마다 이전 요청이 취소되고 새로운 요청이 수행됩니다.\n\n<div class=\"content-ad\"></div>\n\n`switchMap`는 현재 observable 값에 기반하여 새로운 observable로 전환해야 하는 시나리오를 처리하는 데 사용할 수 있는 강력한 연산자입니다. 새 값이 발행될 때 과거 요청을 취소하는 데 유용합니다.\n\n- **concatMap**: RxJS에서 Observable을 해체하여 각 값에 대해 매핑 함수를 적용하고, 그 결과 Observables를 발행된 순서대로 연결하는 연산자입니다. 배열의 각 항목에 대해 HTTP 요청을 만들기 위해 `concatMap`을 사용하는 예시가 다음에 나와 있어요:\n\n![2024-06-23-RxJSOperatorsinAngular_9.png](/assets/img/2024-06-23-RxJSOperatorsinAngular_9.png)\n\n![2024-06-23-RxJSOperatorsinAngular_10.png](/assets/img/2024-06-23-RxJSOperatorsinAngular_10.png)\n\n<div class=\"content-ad\"></div>\n\n이 예제는 관찰 가능한을 만들기 위해 from을 사용하여 숫자 1, 2, 3을 방출합니다. 그런 다음 concatMap 연산자를 사용하여 각 숫자를 URL에서 JSON 객체를 가져오는 HTTP 요청으로 매핑합니다. 결과 관찰 가능은 숫자가 방출된 순서대로 JSON 객체를 방출할 것입니다.\n\n이것은 RxJS에서 사용 가능한 많은 연산자 중 일부 예시에 불과합니다. 이러한 연산자를 조합하여 다양한 사용 사례를 처리하는 강력하고 표현력 있는 데이터 파이프라인을 만들 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n계속 학습하려면 저를 따라 주세요!","ogImage":{"url":"/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png"},"coverImage":"/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular Reactive Forms setValue와 patchValue 함수 사용 방법","description":"","date":"2024-06-23 14:08","slug":"2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions","content":"\n\nsetValue() 및 patchValue() 함수는 Angular에서 반응형 폼 컨트롤을 채우는 데 사용됩니다. 두 함수의 사용 사례가 다릅니다.\n\n다음의 반응형 폼 예제와 함께 두 함수가 동작하는 방식을 이해해보겠습니다.\n\n```js\nmyForm: FormGroup;\n\nconstructor(private fb: FormBuilder) {}\n\nngOnInit() {\n  this.myForm = this.fb.group({\n    firstName: ['', Validators.required],\n    lastName: ['', Validators.required],\n    email: ['', [Validators.required, Validators.email]],\n  });\n}\n```\n\n- setValue() 함수\n\n<div class=\"content-ad\"></div>\n\nsetValue() 함수는 반응형 폼 컨트롤의 값을 설정하는 데 사용됩니다.\n\n```js\n  setValueExample() {\n    this.myForm.setValue({\n      firstName: 'John',\n      lastName: 'Doe',\n      email: 'john.doe@example.com',\n    });\n  }\n```\n\nsetValue() 함수는 폼의 모든 컨트롤을 업데이트하고 싶을 때 사용됩니다. setValue() 함수를 사용할 때에는 모든 컨트롤 값을 제공해야 하므로 부분 데이터가 있는 경우나 폼의 모든 컨트롤을 채우고 싶지 않은 경우에는 이 함수를 사용할 수 없습니다.\n\n2. patchValue() 함수\n\n<div class=\"content-ad\"></div>\n\npatchValue() 함수는 반응형 폼 컨트롤의 값을 설정하는 데 사용됩니다.\n\n```js\n  patchValueExample() {\n    this.myForm.patchValue({\n      firstName: 'UpdatedFirstName',\n      lastName: 'UpdatedLastName',\n    });\n  }\n```\n\npatchValue() 함수는 반응형 폼의 모든 컨트롤을 업데이트하고 싶지 않을 때 사용됩니다. 폼의 일부 컨트롤만 채우고 싶을 때 사용됩니다.\n\n예를 들어, 폼에 선택 사항 입력란이 하나 있고 사용자가 해당 입력란을 작성하지 않았을 때, 이 값을 데이터베이스에 null 또는 빈 문자열로 저장할 수 있습니다. 따라서 폼 컨트롤을 채울 때 이 입력 컨트롤을 업데이트하거나 채우고 싶지 않을 수 있습니다. 이럴 때 patch value를 사용할 수 있습니다. 이 함수를 사용하면 부분 폼 컨트롤을 채울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n개발자들은 사용 사례 시나리오에 따라 두 함수를 모두 사용합니다. setValue() 함수는 양식의 모든 컨트롤을 필수적으로 채우려 할 때 사용하고, patchValue() 함수는 양식의 일부 컨트롤만 채우려 할 때 사용합니다.","ogImage":{"url":"/assets/img/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions_0.png"},"coverImage":"/assets/img/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions_0.png","tag":["Tech"],"readingTime":2},{"title":"ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법","description":"","date":"2024-06-23 14:08","slug":"2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates","content":"\n\n\n![Angular 17 Release](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png)\n\nAngular의 17 버전 릴리스는 템플릿 시스템을 개선하는 등 매우 흥미로운 새로운 기능이 포함되어 있습니다. 가장 중요한 추가 기능 중 하나는 제어 흐름을 위한 새로운 내장 구문입니다.\n\n이 선언적 접근 방식은 *ngIf, *ngFor, ngSwitch와 같은 디렉티브가 필요하지 않도록하여 템플릿 로직을 프레임워크 자체 내에서 간소화합니다. 또한 Angular V17에서는 컴포넌트, 디렉티브 및 파이프를 게으르게 로드하여 성능을 향상시킬 수 있는 지연 로딩(deferrable views)을 도입했습니다. 이러한 발전은 Angular 템플릿에 상당한 영향을 미치며, 이에 따라 기존 응용 프로그램을 새로운 템플릿 시스템으로 이관하는 데 도움이 되는 새로운 ngcommand가 추가되었습니다.\n\n다음은 템플릿에서 이 새로운 제어 흐름의 예시입니다:\n\n\n\n<div class=\"content-ad\"></div>\n\n```js\n@if (user.isHuman) {\n  <human-profile [data]=\"user\" />\n   @for (skill of user.skills; track $index) {\n     <human-skills  [name]=\"skill.name\" [level]=\"skill.level\" />\n   } @empty {\n    <span>기술이 추가되지 않았습니다.</span>\n   }\n} @else if (user.isRobot) {\n  <!-- 로봇 사용자는 드물기 때문에 프로필을 나중에 불러옵니다. -->\n  @defer {\n    <robot-profile [data]=\"user\" />\n  }\n} @else {\n  <p>프로필을 알 수 없습니다!</p>\n}\n```\n\n## @if 블록 조건\n\n@if 블록은 조건이 참일 때 콘텐츠를 표시합니다.\n\n```js\n@if (loggedIn) {\n  환영합니다 {username}\n}\n```\n\n<div class=\"content-ad\"></div>\n\ntable 태그를 Markdown 형식으로 변경할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n@for (skill of user.skills; track $index) {\n  <human-skills  [name]=\"skill.name\" [level]=\"skill.level\" />\n}\n\n\n트랙: Angular는 변경되는 컬렉션과 작업할 때 성능을 최적화하기 위해 개별 항목을 식별하는 트랙 표현식을 사용합니다. 이 기능은 각 항목을 해당 DOM 뷰와 연결하는 데 사용되는 키를 지정합니다. 이러한 키를 비교함으로써 Angular는 추가, 제거 또는 이동된 항목을 효율적으로 파악하여 불필요한 DOM 조작을 최소화할 수 있습니다. 효율적으로 트랙을 사용하면 Angular 애플리케이션의 성능을 크게 향상시킬 수 있습니다.\n\n콘텍스트 변수: @for 내용 안에는 다음과 같은 많은 변수를 사용할 수 있습니다:\n\n![contextual variables](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n```js\n@for (skill of user.skills; track $index) {\n  <human-skills  [name]=\"skill.name\" [level]=\"skill.level\" />\n} @empty {\n  <span> 기술이 추가되지 않았습니다.</span>\n}\n```\n\n## @switch 블록 — 선택\n\n다른 모든 프로그래밍 언어의 switch 문을 영감받아, 값은 === 연산자로 케이스 표현식과 비교됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n@switch (condition) {\n@case (caseA) {\nCase A.\n}\n@case (caseB) {\nCase B.\n}\n@default {\nDefault case.\n}\n}\n```\n\nAngular의 @switch 블록은 fallthrough가 없으므로 return 또는 break 문을 사용할 필요가 없습니다.\n\n## Angular에서 @를 선택한 이유는?\n\nAngular의 제어 흐름 및 지연 가능한 뷰 제안서는 긍정적인 피드백을 받았지만 템플릿에 대한 #-구문은 논란을 빚었습니다. 초기 RFC에서는 HTML과 유사한 태그를 제안했지만 커뮤니티 피드백은 새로운 \"@-구문\"을 선호했습니다. Angular 팀은 이 대안을 인기 때문에 평가하고 최종 결정을 내리기 전에 더 많은 데이터를 수집할 것입니다.\n\n<div class=\"content-ad\"></div>\n\nAngular은 제어 흐름 구문 옵션인 #과 @에 대한 개발자 경험을 조사했습니다. 내부 팀, Google 개발자 전문가(GDE), 개발자 설문 및 사용자 연구를 통해 피드백을 수집했습니다. 결과는 분명하게 나타났습니다: 약 2 대 1의 비율로 개발자들이 원래의 \"#-syntax\" 대신 커뮤니티가 제안한 \"@-syntax\"를 선호했습니다.\n\n이 차트는 Angular 팀 연례 설문에 응답한 수천 명의 개발자들의 선호도를 보여줍니다:\n\n![Angular Team Survey](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_2.png)\n\nAngular 팀이 커뮤니티가 제안한 @-syntax를 고려하는 것은 그들의 의지를 향한 증명입니다.\n\n<div class=\"content-ad\"></div>\n\n## 어떤 제어 흐름이 대체될 것인가\n\n- @switch 지시어는 여러 이점을 갖는 ngSwitch를 대체합니다. 먼저, 조건을 보관할 컨테이너 요소가 필요하지 않습니다. 둘째로, 템플릿 유형 확인을 지원합니다.\n- @for 블록은 *ngFor 지시어를 대체합니다. 또한, @empty 블록 지원이 도입되며 추적에 대한 최적화를 제공합니다. 요소 컬렉션의 변경에 대한 응답으로 필요한 최소 DOM 작업 횟수를 계산하는 새로운 최적화 알고리즘을 활용합니다.\n\n## 구조 지시어에서 마이그레이션\n\n이 문서에서 언급된 대로, Angular 팀은 Angular 17부터 구조 지시어에서 단순화된 제어 흐름 구문으로의 마이그레이션을 고려해 왔습니다. 이 마이그레이션은 CommonModule이 필요하지 않도록 만듭니다. Angular CLI에는 이 프로세스를 자동화하는 새로운 스키매틱이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n$ ng generate @angular/core:control-flow\n```\n\n이 글의 끝까지 읽어 주셔서 감사합니다! 다음을 꼭 확인해 보세요:\n\n- **박수**를 치고 작가를 팔로우 해 주세요 👏\n- 저를 팔로우 해 주세요: X | LinkedIn | YouTube","ogImage":{"url":"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png"},"coverImage":"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법","description":"","date":"2024-06-23 14:07","slug":"2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular","content":"\n\n<img src=\"/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png\" />\n\nAngular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터/변수를 전달하는 여러 가지 방법이 있습니다. 가장 흔한 두 가지 방법은 다음과 같습니다:\n\n- @Input 데코레이터 사용\n- 공유 서비스 사용\n\n## 1. @Input 데코레이터 사용\n\n<div class=\"content-ad\"></div>\n\n한 가지 방법은 자식 컴포넌트에서 데이터를 수신할 변수를 선언하는 데 @Input() 데코레이터를 사용하는 것입니다.\n\n부모 컴포넌트의 템플릿에서, 속성 바인딩 구문(대괄호)을 사용하여 변수의 값을 자식 컴포넌트의 입력에 바인딩합니다.\n\n예를 들어, 부모 컴포넌트의 템플릿에서:\n\n```js\n<!--parent.component.html-->\n\n<app-child [inputFromParent]=\"data\"></app-child>\n```\n\n<div class=\"content-ad\"></div>\n\n아이 컴포넌트의 클래스에서:\n\n```js\n// child.component.ts\n\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    <p>{ inputFromParent }</p>\n  `\n})\nexport class ChildComponent {\n  @Input() inputFromParent: any;\n}\n```\n\n## 2. 공유 서비스 사용\n\n다른 방법은 공유 서비스를 사용하는 것입니다. 공유 서비스는 서로 직접적으로 관련이 없는 컴포넌트 간에 데이터를 공유하는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트의 클래스에서:\n\n```js\n// parent.component.ts\n\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <app-child></app-child>\n  `\n})\nexport class ParentComponent {\n  constructor(private dataService: DataService) {\n    this.dataService.data = '부모 컴포넌트에서 안녕하세요!';\n  }\n}\n```\n\n자식 컴포넌트의 클래스에서:\n\n```js\n// child.component.ts\n\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    <p>{ data }</p>\n  `\n})\nexport class ChildComponent {\n  data: any;\n  constructor(private dataService: DataService) {\n    this.data = this.dataService.data;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nAngular에서 부모 컴포넌트에서 자식 컴포넌트로 변수를 전달하는 다른 방법이 있을 수 있습니다. 이것들은 기본 접근 방법 중 두 가지에 불과합니다.","ogImage":{"url":"/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png"},"coverImage":"/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular에서 Firebase 인증 사용하는 방법","description":"","date":"2024-06-23 14:06","slug":"2024-06-23-Firebaseauthenticationinangular","content":"\n\n이 기사에서는 Angular 프로젝트에 Firebase 인증을 Google Single Sign-On (SSO)과 빠르게 설정하는 방법을 제안합니다. 또한 선택한 백엔드에 인증된 요청을 하는 방법도 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png)\n\n전체 코드는 여기에서 확인할 수 있습니다: https://github.com/Gabriel2409/demofirebase\n\n# Firebase 설정\n\n<div class=\"content-ad\"></div>\n\nFirebase에 가서 새 프로젝트를 만들어주세요.\n\n## 앱 설치\n\n프로젝트 개요 페이지에서 Web 아이콘을 클릭하거나 +앱 추가 아이콘을 클릭하여 웹 애플리케이션을 추가하세요.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_1.png)\n\n<div class=\"content-ad\"></div>\n\n열리는 창에서 앱에 이름을 지정하고, 예를 들어 myangularapp처럼 등록해주세요. Firebase 구성을 어딘가에 저장하세요. 다음과 같이 보여야 합니다:\n\n```js\nconst firebaseConfig = {\n  apiKey: \"<firebase-api-key>\",\n  authDomain: \"<my-project-id>.firebaseapp.com\",\n  projectId: \"<my-project-id>\",\n  storageBucket: \"<my-project-id>.appspot.com\",\n  messagingSenderId: \"<my-messaging-sender-id\",\n  appId: \"<my-app-id>\",\n};\n```\n\n프로젝트 설정의 일반 탭(톱니바퀴 아이콘)로 이동하여 아무 때나 앱의 Firebase 구성에 액세스할 수 있음을 유념하세요.\n\n## 인증 설정\n\n<div class=\"content-ad\"></div>\n\n모든 제품으로 이동한 다음 **인증**을 선택하세요. **로그인 방법**에서 **새로운 제공자 추가**를 클릭하고 Google을 선택하세요. Firebase는 Google과 긴밀하게 통합되어 있기 때문에 별도의 설정이 필요하지 않습니다.\n\n그게 다에요! 이제 Google SSO를 사용하여 Firebase 사용자를 인증할 준비가 되었습니다.\n\n참고: 다른 제공자도 추가할 수 있습니다(예: 이메일/비밀번호, 아래 이미지 참조), 하지만 이 기사에서는 Google SSO에 중점을 두고 있습니다.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_2.png)\n\n<div class=\"content-ad\"></div>\n\n# Angular 설정\n\n## 프로젝트 생성\n\n먼저, npm install -g @angular/cli를 사용하여 Angular을 전역으로 설치하세요. 저는 버전 17.0.1을 사용하고 있어요.\n\n그런 다음, demofirebase라는 새 폴더를 만들고 해당 폴더에서 ng new frontend --no-standalone --routing ssr=false을 실행하세요. 이렇게 하면 필요한 파일이 포함된 frontend 폴더가 생성됩니다. 이 단계를 마치면 저장소 구조는 다음과 같아야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ndemofirebase\n└── frontend\n```\n\n하나의 추가 패키지가 필요합니다. frontend 폴더에서 npm i @angular/fire 명령어를 실행해주세요.\n\n다음으로, 개발 및 프로덕션을 위한 환경을 생성할 때 ng g environments를 사용합니다.\n이는 src/environments 폴더에 2개의 파일을 생성합니다: environment.development.ts와 environment.ts.\n로컬에서 개발할 때는 environment.ts가 environment.development.ts로 대체되어 environment.ts에서 import를 하면 자동으로 environment.development.ts의 변수들을 사용할 수 있습니다. 이는 angular.json 파일에서 확인할 수 있습니다:\n\n```js\n\"fileReplacements\": [\n    {\n        \"replace\": \"src/environments/environment.ts\",\n        \"with\": \"src/environments/environment.development.ts\"\n    }\n]\n```\n\n<div class=\"content-ad\"></div>\n\nFirebase 구성을 environment.development.ts에 붙여 넣으세요.\n\n```js\n// environment.development.ts\nexport const environment = {\n  production: false,\n  // 백엔드에 요청을 보낼 수 있는 가정\n  backendUrl: \"http://127.0.0.1:8000\",\n  // 콘솔에서 가져온 Firebase 구성입니다.\n  // 이것은 민감한 정보가 아님을 주의하세요\n  firebaseConfig: {\n    apiKey: \"<firebase-api-key>\",\n    authDomain: \"<my-project-id>.firebaseapp.com\",\n    projectId: \"<my-project-id>\",\n    storageBucket: \"<my-project-id>.appspot.com\",\n    messagingSenderId: \"<my-messaging-sender-id\",\n    appId: \"<my-app-id>\",\n  },\n};\n```\n\n참고: production용 (environment.ts 파일)으로 가시려면, backendUrl을 배포된 백엔드로, firebaseConfig을 production 구성으로 대체하시면 됩니다. Firebase 프로젝트는 여러 환경을 가질 수 없으므로 환경마다 프로젝트를 생성하는 것이 좋습니다. 지금은 빠른 진행을 위해 더미 값만 사용하셔서 IDE에서 필드 부족으로 에러가 발생하지 않도록 하세요.\n\n```js\n// environment.ts\nexport const environment = {\n  production: true,\n  backendUrl: \"backendUrl\",\n  firebaseConfig: {},\n};\n```\n\n<div class=\"content-ad\"></div>\n\n앱 모듈(app.module.ts)에 필요한 import 문을 추가하고 애플리케이션을 초기화하세요:\n\n```js\n//app.module.ts\nimport { NgModule } from \"@angular/core\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { AppRoutingModule } from \"./app-routing.module\";\nimport { AppComponent } from \"./app.component\";\nimport { AngularFireModule } from \"@angular/fire/compat\";\nimport { AngularFireAuthModule } from \"@angular/fire/compat/auth\";\nimport { environment } from \"../environments/environment\";\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    AngularFireAuthModule,\n    AngularFireModule.initializeApp(environment.firebaseConfig),\n    BrowserModule,\n    AppRoutingModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n## 필요한 컴포넌트와 라우트 생성\n\n첫째로, Google SSO를 위한 컴포넌트를 생성하려면 'ng g c signin'을 사용하고, 랜딩 페이지를 위한 컴포넌트를 생성하려면 'ng g c landing'을 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown으로 테이블 태그를 변경하세요.\n\n그럼, app-routing.module.ts을 수정하세요:\n\n```typescript\nimport { NgModule } from \"@angular/core\";\nimport { RouterModule, Routes } from \"@angular/router\";\nimport { SigninComponent } from \"./signin/signin.component\";\nimport { LandingComponent } from \"./landing/landing.component\";\n\nconst routes: Routes = [\n  { path: \"\", component: LandingComponent },\n  { path: \"signin\", component: SigninComponent },\n];\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n마지막으로, app.component를 수정하세요:\n\n```typescript\n// app.component.ts\n<nav>\n  <ul>\n    <li>\n      <a routerLink=\"/\">랜딩 페이지</a>\n    </li>\n    <li>\n      <a routerLink=\"/signin\">로그인 페이지</a>\n    </li>\n  </ul>\n</nav>\n<router-outlet></router-outlet>\n```\n\n<div class=\"content-ad\"></div>\n\n지금 ng serve를 실행하고 http://localhost:4200으로 이동하면 아주 아름다운 페이지를 볼 수 있고, 랜딩 페이지와 로그인 페이지 사이를 이동할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_3.png)\n\n## 구글 SSO 추가하기\n\n구글 SSO를 추가하려면 단순히 버튼에 click 이벤트 리스너를 추가하면 됩니다. 저는 재사용 가능하도록 지시어를 사용하는 것을 선호하는데, 아래에 제가 보여주는 구현 방법을 사용하시면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n구글 SSO를 실행하여 지시문을 만들고 app.module.ts에 자동으로 추가합니다.\n\n```js\n//google-sso.directive.ts\nimport { Directive, HostListener } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\nimport { GoogleAuthProvider } from \"@firebase/auth\";\n\n@Directive({\n  selector: \"[googleSso]\",\n})\nexport class GoogleSsoDirective {\n  constructor(private angularFireAuth: AngularFireAuth) {}\n  @HostListener(\"click\")\n  async onClick() {\n    const creds = await this.angularFireAuth.signInWithPopup(\n      new GoogleAuthProvider(),\n    );\n    // 자격 증명으로 할 일을 실행합니다, 예를 들어 Firestore에 추가하기...\n  }\n}\n```\n\napp.module.ts에 지시문을 추가하십시오.\n\n이제 로그인 페이지에서 해당 지시문을 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- signin.component.html -->\n<button googleSso>Google 계정으로 로그인</button>\n```\n\n그게 다에요. 작동하는지 확인하려면 프론트엔드로 이동하여 만든 버튼을 클릭하세요. 로그인한 후에 Firebase 콘솔로 돌아가세요. 인증에서 사용자 탭으로 이동하면 로그인에 사용한 이메일이 나타날 것입니다.\n\n계속 진행하기 전에 로그아웃이 가능하도록 로그인 구성요소를 수정해봅시다.\n\n```js\n// signin.component.ts\nimport { Component } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\n@Component({\n  selector: \"app-signin\",\n  templateUrl: \"./signin.component.html\",\n  styleUrl: \"./signin.component.scss\",\n})\nexport class SigninComponent {\n  constructor(public angularFireAuth: AngularFireAuth) {}\n  logOut() {\n    this.angularFireAuth.signOut();\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n\n<!-- signin.component.html -->\n@if (angularFireAuth.authState | async) {\n<button (click)=\"logOut()\">Log out</button>\n} @else {\n<button googleSso>Sign in with google</button>\n}\n\n\n## Adding a route available only for logged in users\n\nLet’s create another component: ng g c require-auth\n\nThen let’s create a guard: ng g g auth then select CanActivate\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// auth.guard.ts\nimport { CanActivateFn } from \"@angular/router\";\nimport { inject } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\n\nexport const authGuard: CanActivateFn = async (route, state) => {\n  const angularFireAuth = inject(AngularFireAuth);\n  const user = await angularFireAuth.currentUser;\n  // coerce to boolean\n  const isLoggedIn = !!user;\n  return isLoggedIn;\n};\n```\n\n그런 다음 app-routing.module.ts의 라우트를 수정합니다.\n\n```js\n// app-routing.module.ts - new lines\n...\nimport { RequireAuthComponent } from './require-auth/require-auth.component';\nimport { authGuard } from './auth.guard';\nconst routes: Routes = [\n  ...\n  {\n    path: 'require-auth',\n    component: RequireAuthComponent,\n    canActivate: [authGuard],\n  },\n];\n...\n```\n\napp.component.html에 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n<li>\n  <a routerLink=\"/require-auth\">Auth protected</a>\n</li>\n```\n\n이제 로그인한 상태에서만 액세스할 수 있는 경로가 생겼어요.\n\n## 백엔드 경로로 bearer 토큰을 보내는 인터셉터\n\n백엔드에서 요청을 인증하려면 Firebase에서 제공한 토큰을 Authorization 헤더에 추가해야 합니다. 백엔드에서는 토큰을 확인하는 작업을 담당할 것입니다(본 문서의 범위를 벗어남).\n\n<div class=\"content-ad\"></div>\n\nng g interceptor bearer-token 명령을 사용하여 interceptor를 생성하세요.\n\n```js\n// bearer-token.interceptor.ts\nimport { HttpEvent, HttpHandlerFn, HttpInterceptorFn, HttpRequest } from \"@angular/common/http\";\nimport { inject } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\nimport { from, lastValueFrom } from \"rxjs\";\nimport { environment } from \"../environments/environment\";\n\n// 토큰을 얻는 작업이 비동기적이므로 이 함수를 추가해야 합니다.\nconst addBearerToken = async (\n  req: HttpRequest<any>,\n  next: HttpHandlerFn,\n): Promise<HttpEvent<any>> => {\n  const angularFireAuth = inject(AngularFireAuth);\n  const firebaseUser = await angularFireAuth.currentUser;\n  const token = await firebaseUser?.getIdToken();\n  if (token) {\n    req = req.clone({\n      setHeaders: { Authorization: `Bearer ${token}` },\n    });\n  }\n  return lastValueFrom(next(req));\n};\nexport const bearerTokenInterceptor: HttpInterceptorFn = (req, next) => {\n  // 이 bearer token을 백엔드로 보내는 요청에만 추가합니다.\n  // 특정 요청에만 bearer token을 추가하도록 사용자 정의할 수 있습니다.\n  if (req.url.startsWith(environment.backendUrl)) {\n    return from(addBearerToken(req, next));\n  } else {\n    return next(req);\n  }\n};\n```\n\n그런 다음 app.module.ts에 provider를 추가해야 합니다.\n\n```js\n// app.module.ts\n\n...\nimport { provideHttpClient, withInterceptors } from '@angular/common/http';\nimport { bearerTokenInterceptor } from './bearer-token.interceptor';\n...\n  providers: [provideHttpClient(withInterceptors([bearerTokenInterceptor]))],\n...\n```\n\n<div class=\"content-ad\"></div>\n\n마지막으로 확인해보기 위해 백엔드를 호출하는 서비스를 생성해봅시다: ng g s api\n\n```js\n// api.service.ts\nimport { HttpClient } from \"@angular/common/http\";\nimport { Injectable } from \"@angular/core\";\nimport { environment } from \"../environments/environment\";\nimport { Observable } from \"rxjs\";\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class ApiService {\n  // 현재 사용자의 firebase 사용자 ID를 반환하는 백엔드 URL\n  userIdUrl = `${environment.backendUrl}/userid`;\n  constructor(private http: HttpClient) {}\n  getUserId(): Observable<any> {\n    return this.http.get(this.userIdUrl);\n  }\n}\n```\n\n그리고 랜딩 컴포넌트에서:\n\n```js\n<button (click)=\"getUserId()\">사용자 ID 가져오기</button>\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from \"@angular/core\";\nimport { ApiService } from \"../api.service\";\n@Component({\n  selector: \"app-landing\",\n  templateUrl: \"./landing.component.html\",\n  styleUrl: \"./landing.component.scss\",\n})\nexport class LandingComponent {\n  constructor(private apiService: ApiService) {}\n  getUserId() {\n    this.apiService.getUserId().subscribe({\n      next: (res) => console.log(res),\n      error: (err) => console.log(err),\n    });\n  }\n}\n```\n\n이제 백엔드에 요청을 보내는 버튼이 생겼어요. 개발자 도구의 네트워크 탭에서 인증되어 있다면 토큰이 Authorization 헤더에 추가되는 것을 확인할 수 있어요.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_4.png)\n\n## 추가 정보: Firebase는 로그인 정보를 어디에 저장하나요?\n\n<div class=\"content-ad\"></div>\n\n저희가 인터셉터를 사용할 때 다음 코드를 사용했습니다:\n\n```js\nconst angularFireAuth = inject(AngularFireAuth);\nconst firebaseUser = await angularFireAuth.currentUser;\nconst token = await firebaseUser?.getIdToken();\n```\n\n하지만 이 코드는 실제로 어떻게 작동할까요? 정보는 어디에 저장되나요?\n\n사실, Google SSO로 인증할 때, 인증 정보가 브라우저에 저장됩니다. 브라우저 개발자 도구를 열고 저장소 탭 (Chrome의 경우 Application)으로 이동하신 다음 Indexed DB로 이동해보세요.\n\n<div class=\"content-ad\"></div>\n\n<table> 태그를 Markdown 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png"},"coverImage":"/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png","tag":["Tech"],"readingTime":12},{"title":"Angular HttpClient와 Signals를 연결하는 방법","description":"","date":"2024-06-23 14:04","slug":"2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals","content":"\n\nEver since the 18th release and the new upcoming releases of the Angular framework, the entire Angular community has been experiencing significant changes, such as zoneless apps and reduced usage of RxJS in everyday code. It’s essential to consider whether or not to use RxJS carefully. Still, you should understand and use both the main concepts of the reactive mechanisms we have in our applications without neglecting either of them. I recommend using signals for the state and RxJS to manage events and complex logic.\n\nBut first, let’s touch on the article’s topic: how we should interact with HttpClient-based services when connecting them with signal-based components. This involves managing the transition from HttpClient’s Observable-based responses to the Signal-based properties used in signal-based components.\n\nAmidst the discussions about using the fetch API instead of HttpClient, I want to reiterate my advice: it’s not necessary to drop HttpClient. It offers useful out-of-the-box features that we can benefit from. Remember, we have the tools to handle the Observable-to-Signal bridge without any issues.\n\n<div class=\"content-ad\"></div>\n\n## RxJS 직접 구독\n\n가장 직접적이고 명확한 방법은 구독을 사용하는 것입니다. HTTP 호출은 한 번만 값을 반환하는 Observable이기 때문에 구독을 해제하는 것에 대해 크게 걱정할 필요가 없습니다. 또한 RxJS 오류 처리 방식을 활용할 수 있습니다(pipe 내에서 또는 오류 콜백을 통해). 가장 명확하면서도 가장 쉬운 방식으로 상황을 처리하는 방법입니다.\n\n```js\npublic data = signal<number[]>([])\n....\nconstructor(private testService: TestService) {}\n....\npublic ngOnInit() {\n  this.testService.getItems().subscribe((items) => {\n    // 시그널 덮어쓰기/생성\n    this.data = signal(items);\n    // 또는 값 직접 설정\n    this.data.set(items);\n  });\n}\n```\n\n## Promises 활용하기\n\n<div class=\"content-ad\"></div>\n\n두 번째 방법은 프로미스를 활용하는 것입니다. 표준 then/catch 또는 async/await을 사용할 수 있습니다. 이것은 조금 까다로울 수도 있습니다, 특히 async/await의 구체적인 내용을 잊게 되었거나 모르는 경우입니다. RxJS의 firstValueFrom 함수를 사용하여 첫 번째 발행된 값을 observable로 변환할 수 있습니다(일반적으로 API 응답은 한 가지 값이기 때문에 잘 맞습니다). 여기에는 두 가지 주의해야 할 점이 있습니다:\n\n- async/await 구문을 사용하면 프로미스가 값을 반환하거나 오류가 발생할 때까지 함수 실행이 중지된다는 것을 유의해야 합니다. 따라서 코드의 나머지 부분은 여전히 실행을 기다리고 있게 됩니다. 따라서 async/await 함정에 빠지지 않도록 주의하십시오.\n- 또한 firstValueFrom은 즉시 observable 소스에 구독을 시작합니다. 이것이 문제가 될 수는 없지만, 게으르게 시작하려면 잘 작동하지 않을 수 있습니다.\n\n```js\npublic async ngOnInit() {\n  // observable 소스를 즉시 구독합니다\n  this.data = signal(await firstValueFrom(this.testService.getItems()));\n  // 주의! 이 코드는 서비스가 값을 반환할 때까지 실행되지 않음\n```\n\n코드 실행을 중지하지 않으려면 전용 함수 래퍼를 사용할 수 있습니다. 다른 방법은 IIFE를 사용하는 것입니다. 이 방법이 더 일관된 것으로 생각될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\npublic async initData() {\n  this.data = signal(await firstValueFrom(this.testService.getItems()));\n}\n\npublic ngOnInit() {   \n  this.initData();\n  ....\n}\n```\n\n```js\npublic ngOnInit() {    \n  (async () => {\n    this.data = signal(await firstValueFrom(this.testService.getItems()));\n    console.log('data inited');\n  })();\n  ....\n}\n```\n\n다른 방법은 old-faithful then을 사용하는 것입니다. 위의 모든 프로미스 케이스에서 then 콜백 실행을 마이크로태스크로 생각할 때, 그것은 자체적인 특징이 있으며 어떤 경우에는 예측할 수 없는 결과를 줄 수 있음을 잊지 마세요.\n\n```js\npublic ngOnInit() {   \n  firstValueFrom(this.testService.getItems()).then((items) => {\n    this.data = signal(items);\n  });\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## rxjs-interop을 사용하여 toSignal을 활용해보세요\n\nrxjs-interop은 우리에게 세 번째 방법을 제공했는데, 그것은 toSignal이라고 불립니다. 간단히 말하면, 이 함수는 소스 observable을 구독하고 모든 값을 signal로 보냅니다. 그러나 HttpClient 응답을 signal로 변환하는 가장 tricky한 방법 중 하나입니다. 그래서 이러한 사항들을 주의해야 합니다:\n\n- 주목할 점 중 하나는 firstValueFrom과 유사하게, toSignal은 실행 시 즉시 구독합니다.\n- default 값을 제공하지 않으면 처음 값 (undefined)을 즉시 발행합니다.\n- API 호출을 라이프사이클 훅이나 컴포넌트 클래스 메소드 어딘가에서 수행하는 경우 'Error: NG0203: toSignal() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext’' 라는 오류가 발생할 수 있습니다. 이를 극복하기 위해 injector를 주입하고 제공하거나 runInInjectionContext를 사용해야 합니다.\n- 읽기 전용 signal을 제공합니다. 따라서 나중에 signal과 상호작용하려면 (설정/업데이트) 여기서 장애물을 처리해야 합니다.\n\n```js\nprivate _injector = inject(Injector);\n\npublic ngOnInit() {  \n  this.data = toSignal(this.testService.getItems(), {\n    // injector에 대한 참조 제공\n    injector: this._injector,\n    // default 값을 제공\n    initialValue: [],\n  });\n\n  // 또는 runInInjectionContext를 사용\n  runInInjectionContext(this._injector, () => {\n    toSignal(this.testService.getItems(), {\n      initialValue: [],\n    });\n  });\n  ....\n}\n```  \n\n<div class=\"content-ad\"></div>\n\n## 결론:\n\n현재, 표준 observable 구독을 사용하는 것이 가능한 처리하기 쉬운 변형으로 보입니다. 가능한 함정과 어려움에서 보호해 줄 것입니다. 프로미스를 사용하는 것도 편리할 수 있지만, 당신과 팀원들은 async/await 및 다른 프로미스의 구체적인 부분을 알고 있어야 합니다. toSignal을 사용하는 것이 가장 번거로워 보입니다.\n\n유용한 링크:\nhttps://angular.dev/guide/signals\nhttps://angular.dev/guide/di/dependency-injection-context#run-within-an-injection-context","ogImage":{"url":"/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png"},"coverImage":"/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png","tag":["Tech"],"readingTime":5}],"page":"3","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}