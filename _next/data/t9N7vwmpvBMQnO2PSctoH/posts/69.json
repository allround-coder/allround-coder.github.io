{"pageProps":{"posts":[{"title":"완벽한 TS monorepo를 만드는 방법","description":"","date":"2024-05-17 21:06","slug":"2024-05-17-MyquestfortheperfectTSmonorepo","content":"\n\n\n![이미지](/assets/img/2024-05-17-MyquestfortheperfectTSmonorepo_0.png)\n\n올해에 도구 및 모노 레포와 관련된 이해력을 개선하기 위해 부단히 시간을 보냈습니다. 제가 한 일 중 일부를 공유해볼 테니, 혹시 필요하신 분들께 도움이 되길 바라겠습니다.\n\n도구와 모노 레포에 대한 향상된 지원이 지난 몇 년 동안 JavaScript/TypeScript 생태계를 엄청나게 성장시켰지만, 모든 것이 어떻게 연결되는지 완전히 이해하지 않으면 여전히 많은 문제를 겪을 수 있다는 사실에 놀라실 지도 모릅니다.\n\n도구와 모노 레포는 모두 매우 지루한 주제이기 때문에 내용을 간결하게 유지하려 노력하겠습니다. 가능한 한 외부 소스에 링크를 걸겠지만, 글이 짧지는 않을 것입니다. 다루어야 할 것들이 많거든요.\n\n\n<div class=\"content-ad\"></div>\n\n# 실제 예시\n\n바로 시작하고 싶다면 여기가 좋아요. PNPM (메인), NPM 및 Yarn의 클래식 및 모던 버전에 대한 병렬 브랜치가 있습니다.\n\n저는 훌륭한 Turborepo 스타터 및 그들의 \"주방 싱크\" 예제 코드로 많은 것을 배웠으므로 그들을 확인하고 모노레포에 대해 처음이라면 그들의 모노레포 핸드북도 읽어보시는 것을 추천합니다.\n\n이 기사는 좀 더 심층적으로 다가가며 정보 조각들을 결합하여 모든 고려 사항과 일반적인 함정을 명확하게 개요하고자 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 배경 이야기\n\n지난 6년 동안 나는 두 개의 중간 규모 프로젝트에 대부분의 전문적 시간을 할애했어요. 그 두 프로젝트는 서로 다른 회사들을 위해 만들어졌지만, 둘 다 동일한 플랫폼 위에 구축되어 있어요.\n\n스택 자체는 이 글에서 논의하는 문제와 해결책과는 크게 관련이 없지만, 참고로 다음과 같아요:\n\n- Firebase와 Google Cloud Platform을 기반으로 한 Node.js 백엔드\n- Vercel에서 호스팅되는 Next.js를 기반으로 한 React.js 클라이언트\n- 데이터를 위해 Firestore와 Redis 사용\n- TypeScript\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트 중 첫 번째는 2017년 9월에 시작되었습니다. 그 때는 모노레포에 대한 경험이 부족하고 사용 가능한 도구가 납득할 만하지 않았기 때문에 저는 추가 복잡성을 피하기로 하고 모든 것을 함께 묶기로 선택했습니다.\n\n두 번째 프로젝트는 2019년 6월에 시작되었습니다. 그 때에는 모노레포가 여러 플랫폼에 배포할 때 매우 중요하다는 것을 알 수 있었지만, 여전히 모든 것을 간단하게 유지하고 싶어서 Yarn 워크스페이스를 적용했습니다.\n\n## 답답함\n\n두 번째 설정은 얼마 동안 만족스러웠지만, 일부 측면은 분명히 최적이 아니거나 심지어 답답했습니다. 저는 패키지의 빌드 순서를 수동으로 관리하고 있었고, 그러다가 가끔 사소한 것들을 잊거나 중복 빌드를 일으키기도 했는데, 모든 것이 최신 상태임을 확인하려고 했기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n나중에 다른 프로젝트의 팀 환경에서 비슷한 설정을 사용하게 되면, 구성원들이 패키지 중 하나를 (다시) 빌드하는 것을 잊어서 문제에 부딪히게 될 때가 많아졌습니다.\n\n시간이 지나며 커뮤니티에서 ESM 채택이 증가함에 따라 순수 ESM인 종속성 업데이트를 겪게 되었습니다. 우리의 코드베이스와 잘 어울리도록 하려고 여러 차례 시도했지만 성공하지 못했으며, 결과적으로 일부를 이전 버전으로 고정시켰는데 이는 지속 가능한 해결책이 아닙니다.\n\n첫 번째 프로젝트의 설정은 여러 플랫폼의 모든 종속성을 단일 패키지 매니페스트에 모아놓은 것으로 ESM 채택을 더 어렵게 만들고 있었습니다. 게다가 더 느린 서버 배포 및 시작 시간과 같은 다른 문제를 초래하기 시작했습니다.\n\n두 프로젝트를 동시에 진행하는 것만으로도 어렵기 때문에 도구 및 작업에 에너지와 시간을 낭비할 필요가 없습니다. 정신을 차리기 위해, 이러한 문제들을 한 번에 처리하고 모든 것이 어떻게 작동하며 어떻게 연결되는지 확신할 필요가 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n저는 프로젝트에 필수적인 모든 측면을 다루기 위해 mono-ts 보일러플레이트를 개발하기 시작했습니다. 이 보일러플레이트는 이 글에서 다루는 모든 개념의 작동 예제를 제공하므로, 이해하기 어려운 부분이 있을 때 참고해 주세요.\n\n# 주요 주제\n\n좋은 모노레포 설정의 중추는 다음과 같습니다:\n\n- 빠르고 결정적인 빌드 및 작업 조작\n- 원하는 곳에서 ESM을 사용하고 생성\n- 패키지를 독립적으로 배포할 수 있는 능력\n- 코드 및 유형에 대한 IDE 정의로 이동\n- 개발 중에 라이브 코드 업데이트\n\n<div class=\"content-ad\"></div>\n\n배포에 관한 도전은 대부분의 개발자가 마주치는 문제는 아니며, 이는 주로 사용하는 플랫폼에 따라 다릅니다. 우리의 경우에는 Firebase와 관련이 있으며, 현재 해당 도구가 모노 리포를 원산지로 지원하지 않는다는 점이 문제입니다.\n\n# 빌드 및 작업 조정\n\nTurborepo가 출시되자마자, 저는 그것이 내가 오랫동안 염원했던 것임을 즉시 알았지만, 그것은 그 종류의 첫 번째 해결책은 아니었습니다. Nx와 Rush는 이미 오랜 시간 동안 존재했기 때문에, 그것들을 여기서 언급하는 것은 공정한 일일 뿐이며, 다른 노력들도 있을 것으로 추측됩니다. Turborepo와 Nx는 여러 측면에서 유사해 보이지만, Nx에 대한 실제 경험이 없기 때문에 자세히 다루지는 않겠습니다.\n\n간단히 말하면, Turborepo는 빌드, 린팅, 개발 서버 시작과 같은 개별 작업 단위로 각 패키지가 서로에게 어떻게 의존하는지 구성하는 방식으로 작동합니다. 각 작업에 대해 필요한 입력 및 출력을 정의하여 중간 결과를 캐시하고 입력 매개변수가 변경된 경우에만 계산합니다.\n\n<div class=\"content-ad\"></div>\n\n또한 Vercel은 프로젝트를 위해 Turborepo를 위한 공유 클라우드 캐시를 선택적으로 제공합니다. 따라서 여러분이 자신의 기기에서 실행한 작업은 곧 동료의 기기나 CI 파이프라인에서 실행하는 작업의 속도를 높일 수 있습니다. 이것이 대규모 프로젝트에 매우 강력할 수 있다는 것을 상상하기 어렵지 않습니다.\n\n# 내부 패키지; 빌드할까 말까\n\n모노 리포 설정을 선택하는 가장 흔한 이유는 공유 코드를 분리하고 여러 앱 및 서버 배포에서 재사용할 수 있게 하려는 것입니다. 이는 의존성을 명확히 유지하고 역할의 분리를 촉진합니다.\n\n예를 들어, 여러분은 동일한 UI 구성 요소 세트를 사용하는 여러 웹 애플리케이션이 있거나, 서버 및 클라이언트 코드가 일부 동일한 유형 및 비즈니스 로직을 사용하는 경우가 있을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 내부 패키지들은 소스 코드가 비공개이기 때문에 NPM에 이러한 내부 패키지를 게시하려는 의도가 없습니다. 또한 이러한 패키지는 이 저장소의 컨텍스트에서만 사용하게될 가능성이 높습니다.\n\nTypeScript로 작업할 때는 이러한 공유 내부 패키지를 연결하는 두 가지 다른 패턴 중에서 선택할 수 있습니다.\n\n## 1. 기존 빌드 패키지 접근 방식\n\n이 패턴에서는 TS 코드를 JavaScript로 빌드하고 선택적으로 번들할 수 있습니다. 패키지 매니페스트를 정의하여 컴파일된 JS 출력을 가리키도록 설정합니다. 이 방식은 NPM에 패키지를 게시하려는 경우와 정확히 동일합니다.\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식의 몇 가지 이점은 다음과 같습니다:\n\n- 각 패키지는 개별적으로 빌드되며, Turborepo와 같은 도구를 사용하면 효율적으로 캐시할 수 있습니다.\n- TypeScript 경로 별칭을 사용하기 쉽습니다. (기본적으로) 번들러가 결과물에서 이를 제거하기 때문입니다. 결과물은 노드 모듈에서만 가져오며 코드는 하나 이상의 독립된 파일로 결합됩니다.\n- .js 및 /index.js 접미사와 같은 형식에서 필요한 엄격한 가져오기 규칙을 사용하지 않고도 ESM 모듈을 생성할 수 있습니다. 기존의 큰 CJS 코드베이스가 ESM 출력을 생성해야 하는 경우에 유용할 수 있습니다. 경로 별칭과 유사한 이유로 번들된 출력 파일에 상대적인 가져오기가 포함되지 않습니다.\n- ESM 및 CJS와 같은 다양한 형식을 동시에 출력할 수 있습니다. 요즘은 ESM을 지원하지 않는 도구를 사용하는 경우에 주로 유용할 것입니다.\n\n이 접근 방식의 몇 가지 단점은 다음과 같습니다:\n\n- 더 많은 구성과 필요에 따라 도구를 사용해야 합니다.\n- 번들러를 사용하는 경우 결과물을 소스 코드 및 IDE의 정의로 맵핑하는 데 약간의 과정을 거쳐야 할 수 있습니다.\n- 개발 환경에서 실시간 코드 업데이트를 생성하는 감시 작업을 진행하기 위해 더 많은 구성이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\nESM, 번들링 및 감시 작업에 대한 이러한 포인트들에 대해 돌아올 거에요, 그러니 조금만 기다려 주세요.\n\n## 2. \"내부 패키지\" 접근 방식\n\n이 용어는 Turborepo의 Jared Palmer에 의해 만들어졌어요. 이 경우 빌드 단계를 생략하고, 패키지 매니페스트를 구성하여 Typescript 소스 파일을 직접 가리키게 해요.\n\n이 접근 방식의 몇 가지 이점은 다음과 같아요:\n\n<div class=\"content-ad\"></div>\n\n- 구성이 거의 없어 따르기 쉽습니다.\n- Next.js 같은 개발 서버를 사용하는 환경에 대한 기본적인 실시간 코드 업데이트\n- 소스 파일 및 유형에 대한 기본 IDE 이동 정의\n\n이 방법의 일부 단점은:\n\n- 대규모 저장소에 대해 효율적이지 않습니다. 컴파일 및 번들링을 소비 환경에 남겨 두면 일부 패키지가 변경될 때 모든 것이 다시 빌드되어야 합니다. Turborepo는 중간 결과를 캐시할 수 없기 때문에 빌드 시간이 증가할 것입니다.\n- TypeScript 경로 별명을 사용하려면 각 패키지에 대해 고유한 별칭을 구성해야 합니다. 그렇지 않으면 컴파일러가 혼란스러워집니다. 저는 별칭을 사용하는 것을 좋아하지만 내부 패키지에는 깊게 중첩된 파일 구조가 아니기 때문에 필수적이지 않다고 생각합니다.\n- 패키지를 NPM에 발행할 수 없습니다. 왜냐하면 매니페스트가 TypeScript와 번들러를 가정하기 때문입니다.\n\n이러한 일부 단점에 대해 Turborepo 블로그 게시물에서 논의되기도 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 내 선호도\n\n현재 내부 패키지를 모두 빌드하는 것을 선호합니다. 이렇게 하면 확장 문제 없이 확장이 가능하기 때문에 좋아합니다. 그러나 복잡성을 줄일 수있는 경우에는 좋아합니다. 그래서 이 부분은 변할 수 있습니다. 보일러플레이트에는 두 가지 접근 방식이 모두 테스트에 포함되어 있습니다.\n\n하나의 프로젝트에서 내부 패키지를 빌드 패키지로 사용하여 비공개로 NPM에 발행하여 동일한 회사 내의 다른 저장소와 공유합니다.\n\n# ES Modules\n\n<div class=\"content-ad\"></div>\n\n자바스크립트 생태계의 많은 사람들이 CommonJS 모듈에서 현대 ES 모듈 형식으로 전환하려는 노력에서 고통과 좌절을 경험했습니다. CommonJS 모듈은 Node.js를 위해 고안되었지만 이제는 자바스크립트 표준의 일부인 현대적인 ES 모듈 형식으로의 전환이 필요해 보입니다.\n\nESM 및 전환에 대한 여러분의 의견이 무엇이든, 이 형식이 CJS보다 우수하다는 데에는 동의할 수 있을 것이며, 가능하면 빨리 이를 채용해보아야 할 것이라 생각합니다.\n\n저의 개인적인 좌절은 대부분 이해 부족에서 왔다고 생각하며, 결국에는 몇 가지 기본 원칙을 이해하면 현대적인 도구들과의 통합이 복잡하지 않다는 것을 느꼈습니다.\n\n몇 년 전에 비슷한 글을 읽었더라면, 훨씬 많은 시간과 좌절을 절약할 수 있었을 텐데요. 거의 모든 걸 이해하기 까지 시간이 많이 걸린 것 같은데, 부적합한 리소스를 찾은 거나 마찬가지였습니다.\n\n<div class=\"content-ad\"></div>\n\n## 당신의 TypeScript 코드가 CJS를 출력할 수 있습니다\n\n약간은 당연해 보이지만, 모두가 이를 인식하고 있는 것은 아닙니다. TypeScript 빌드 과정의 출력에 require 문이 포함되어 있다면, 출력 대상이 ESM이 아님을 의미합니다.\n\nTypeScript 소스에서 import/export 문을 사용한다고 해서 ESM 호환 코드를 작성 중이라고 가정하는 것은 잘못된 판단일 수 있습니다.\n\n에디터와 컴파일러는 경고 없이 ESM 모듈을 가져올 수 있게 허용하지만, CJS 출력에서는 런타임 오류를 발생시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## CJS는 상위 레벨에서 ESM을 가져올 수 없습니다\n\nCJS 모듈은 동기적이고, ESM 모듈은 비동기적이기 때문에 CJS에서 상위 레벨에서 ESM 모듈을 직접 가져올 수 없습니다.\n\nCJS 코드에서 ESM 모듈을 가져와야 하는 경우 다음과 같이 동적 임포트를 사용해야 합니다:\n\n```js\nconst someEsModule = await import from “some-es-module”\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 CJS 모듈은 최상위 await 문을 가질 수 없기 때문에 다음과 같이 다른 async 함수 내부에서만 실행할 수 있습니다:\n\n```js\nasync function useSomeModule() {\n  const someEsModule = await import from \"some-es-module\";\n  someEsModule.someFun()\n}\n```\n\n이전에 언급한 대로, 번들러와 TypeScript 컴파일러는 이러한 호환성 문제에 대해 경고하지 않으며 런타임에서만 오류가 발생할 수 있습니다.\n\n참고로 Next.js에는 ESM을 변환해주는 transpilePackages 설정이 있습니다. 다른 현대적인 프론트엔드 프레임워크에도 비슷한 기능이 있을 것으로 예상되지만 이 편의성을 제공하는 서버 프레임워크에 대해서는 알려진 바가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n## ESM는 CJS에서 가져올 수 있습니다\n\n이것은 문제가 될 것이 없습니다. 왜냐하면 동기적 모듈을 비동기적 컨텍스트에서 가져오는 것이기 때문입니다. 이는 비동기 함수를 사용하는 방법과 유사한 메타모델입니다.\n\n가끔 가져온 CJS 모듈이 기본 내보내기를 얻지 못하고 .default를 사용해야 하는 상황에 직면하는 경우가 있었습니다. 그러나 이는 흔한 일은 아니며 그 원인을 규명하지 못해서 일단 주의해두겠습니다.\n\n## 동적 가져오기는 빌드 도구에 의해 대체될 수 있습니다\n\n<div class=\"content-ad\"></div>\n\n위에서 설명한대로 동적 가져오기를 사용하고 CJS 대상으로 컴파일하는 경우 도구 체인이 이러한 가져오기를 일반적인 require 문으로 변환할 수 있으므로 여전히 ERR_REQUIRE_ESM런타임 오류와 같은 결과를 얻을 수 있습니다.\n\nfirebase-tools 저장소에서 Webpack에 대한 해결책을 찾을 수 있으니 필요하면 다른 번들러에 대해 비슷한 작업을 할 수 있을지도 모릅니다.\n\n## 상대적인 가져오기 경로에서 JS 확장자\n\nESM은 CJS보다 엄격합니다. 가져올 파일을 추측하려 하지 않으며 이러한 이유로 모든 상대적인 가져오기에 파일 확장자를 추가해야 합니다. 또한 디렉토리를 해당 색인 파일로 해석하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n번들러를 사용하면 TS 코드에 확장자가 생략되어 있어도 ESM을 출력하도록 지시할 수 있지만 저는 개인적으로 지금은 코드를 ESM으로 작성하는 것을 선호합니다.\n\nVSCode에서는 아래 설정을 사용하여 수입문에 확장자를 추가하고 있습니다. 대부분의 수입문이 자동으로 이뤄지기 때문에 보통 제가 확장자를 직접 추가하지는 않습니다.\n\n```js\n\"typescript.preferences.importModuleSpecifier\": \"shortest\",\n\"javascript.preferences.importModuleSpecifierEnding\": \"js\",\n```\n\n## .ts 접미사 사용하기\n\n<div class=\"content-ad\"></div>\n\n만약 당신이 편집기에서 타입스크립트 코드를 가리키는 import 경로에 .js 확장자를 사용하는 것이 조금 이상하다고 생각한다면, 해결책이 있다는 것을 알아두세요. moduleResolution을 bundler로 설정하면 .ts 확장자를 사용할 수 있게 됩니다.\n\n이 아이디어는 현대적인 번들러들이 정확하게 해석하고 유효한 ESM 코드를 출력하는 방법을 알고 있다는 것입니다. 미래에는 타입스크립트가 자바스크립트의 다음 세대가 될 수도 있기 때문에, 코드를 가져오는 정상적인 방법이 될 수도 있습니다.\n\n하지만 설정 값이 시사하는 대로 번들러를 사용해야 한다는 것에 주의해야 합니다. 타입스크립트 컴파일러는 자신의 출력물을 작성할 때 import 경로를 변경하지 않으며, 경로 별칭을 해결해주지도 않는다는 것과 같은 이유로 그렇습니다.\n\n더 많은 정보를 원하시면 여기를 참고하세요.\n\n<div class=\"content-ad\"></div>\n\n## ESM 모든 것\n\nESM은 미래이며 CJS와 쉽게 호환되지만 그 반대는 성립되지 않기 때문에 mono-ts의 모든 패키지는 ES 모듈로 되어 있습니다. 필요에 의해 CJS에 명시적으로 고정된 몇 개의 개별 파일만 있습니다.\n\n# 패키지를 격리하여 배포\n\n## Docker\n\n<div class=\"content-ad\"></div>\n\n도커 이미지에 대한 Turborepo의 멋진 솔루션이 있습니다. 해당 솔루션은 패키지와 내부 종속성을 복사하고 정리하여 Docker 및 캐싱 레이어를 사용하기에 더 적합하게 만듭니다.\n\n## Firebase\n\n내 프로젝트는 현재 모노 레포를 지원하지 않는 플랫폼에 코드를 배포합니다. Firebase Functions 배포 명령은 NPM 패키지와 유사한 자체 포함 디렉토리를 업로드하고, 그 후에 패키지 설치를 실행하고 매니페스트에 선언된 엔트리 포인트를 실행하는 것을 원합니다.\n\n만약 당신의 코드가 모노 레포에 존재하고 내부 공유 패키지를 사용한다면, 이 작업은 쉽지 않습니다. 사람들은 이 문제를 해결하기 위해 다양한 해킹과 스크립트를 활용해왔지만, 우아한 해결책은 존재하지 않았습니다.\n\n<div class=\"content-ad\"></div>\n\n내 프로젝트가 크기 때문에 Firebase 배포를 개별 서비스로 나누는 것을 선호합니다. 이렇게 하면 코드 조직화와 배포, 콜드 스타트 시간을 더 개선할 수 있습니다.\n\nFirebase에 대한 도전 과제와 나중에 만든 일반적인 솔루션에 대해 설명한 별도의 기사를 작성했습니다.\n\n분리 프로세스는 대상 패키지를 새로운 격리된 패키지로 변환하고 해당 루트를 갖습니다. 그런 다음 내부 종속성을 복사하고 전용 락 파일을 생성합니다. 이것은 Turborepo 방법보다 더 격렬한 가지치기 형태이며, NPM에 발행되었다면 패키지의 일부가 되었을 파일과 구조만을 출력합니다.\n\n또한 여러 패키지에서 Firebase로 배포할 수 있게 합니다! 💅\n\n<div class=\"content-ad\"></div>\n\n# IDE Go-To-Definition\n\n모노레포 설정에서 IDE에서 원하는 두 가지 중요한 점이 있습니다:\n\n- 공유 패키지에서 가져온 코드(함수 또는 클래스와 같은)를 클릭할 때, 편집기가 빌드나 번들 출력이 아니라 원본 Typescript 파일로 이동하길 원합니다.\n- 공유 패키지에서 가져온 타입을 클릭할 때, 편집기가 생성된 d.ts 출력 파일이 아닌 원본 타입 정의로 이동하길 원합니다.\n\n이전에 설명한 \"내부 패키지\" 전략을 사용한다면, 이러한 사항들은 기본적으로 작동합니다. 왜냐하면 패키지 매니페스트가 소스 파일로 직접 링크되기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n만약 여러분의 패키지를 빌드하거나 번들링한다면, 소스 맵 파일 .js.map 및 유형 정의 맵 파일 .d.ts.map을 통해 이를 니기능을 달성할 수 있습니다.\n\n이를 달성하기 위해서는 여러분이 사용하는 번들러에 따라 추가적인 작업이 필요할 수도 있습니다.\n\n저는 현재 tsup을 사용하고 있습니다. 제가 필요한 것에 가장 적합한 것으로 보이지만, 작성 시점에서는 자체적으로 모든 것을 생성할 수 없다는 것 같습니다.\n\n## 문제\n\n<div class=\"content-ad\"></div>\n\n\"tsup\"에 .d.ts 파일을 생성하라고 지시할 수는 있으나, 이러한 파일들은 번들 된 출력을 기반으로 하게 될 것이며, 그런 이유 때문에 \"tsup\"에서 .d.ts.map 파일을 생성할 수 있는 옵션을 제공하지 않는 것이라고 가정합니다.\n\n## 해결책\n\n우리가 원하는 출력물을 얻기 위해서는, \"tsup\"에 소스 맵 파일만 출력하도록 지시하고, 번들된 소스 외에 다른 건 무시하도록 할 수 있습니다. 그런 다음 tsc를 사용하여 타입 정의 파일과 그 맵 파일을 동일한 출력 디렉토리에 출력하도록 할 수 있습니다.\n\n명령어는 다음과 같이 보일 것입니다: tsup && tsc --emitDeclarationOnly\n\n<div class=\"content-ad\"></div>\n\n`--declaration` 플래그를 사용하여 tsc가 타입 선언만을 생성하고 Javascript 코드를 생성하지 않도록 지시할 수 있습니다. 그리고 `tsconfig`에서 `declaration` 및 `declarationMap`을 true로 설정하거나 이를 추가 플래그로 전달하면 원하는 출력물을 얻을 수 있습니다.\n\n타입 파일은 번들된 파일 구조와 일치하지 않지만 여전히 원본 소스 구조를 반영합니다. 다행히도 이는 편집기에는 문제가 되지 않습니다. 편집기는 모든 타입 파일을 찾을 수 있고 각 파일에는 해당 맵이 있어 소스 코드에서 원래 타입 정의로 쉽게 돌아갈 수 있습니다.\n\n# 실시간 코드 업데이트\n\n이전에 언급했듯이 \"내부 패키지\" 접근 방식을 사용하면 개발 서버를 기본으로 실행하는 환경에서는 실시간 코드 업데이트를 얻을 가능성이 높지만 Javascript로 빌드하거나 번들로 묶은 패키지의 경우 일종의 감시 작업을 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n안타깝지만 현재 Turborepo에는 파일 변경을 감지하는 메커니즘이 포함되어 있지 않습니다. 그러나 이 문제에 접근하는 두 가지 방법에 대해 이야기해 보겠습니다.\n\n## 번들된 패키지에 대한 병렬 감시 작업 사용\n\n이전 섹션에서 설명한 대로 번들화된 내부 패키지는 자바스크립트 및 유형 선언과 맵 파일을 생성하는 두 개의 별도 명령이 필요할 수 있습니다.\n\n이러한 명령을 순차적으로 실행할 수는 없습니다. 왜냐하면 첫 번째 명령에 감시 작업을 추가하면 해당 명령은 실행을 완료하지 않기 때문입니다. 따라서 두 명령을 병렬로 실행해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n내가 아는 가장 간단한 해결책은 npm-run-all을 사용하는 것이고, 당신의 패키지 매니페스트 스크립트는 다음과 같이 보일 수 있어요:\n\n```js\n\"scripts\": {\n    \"bundle\": \"tsup-node\",\n    \"bundle:watch\": \"tsup-node --watch\",\n    \"type:gen\": \"tsc --emitDeclarationOnly\",\n    \"type:gen:watch\": \"tsc --emitDeclarationOnly --watch\",\n    \"type:check\": \"tsc --noEmit\",\n    \"build\": \"run-p bundle type:gen\",\n    \"dev\": \"run-p bundle:watch type:gen:watch\",\n    \"clean\": \"del dist tsconfig.tsbuildinfo\",\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage \",\n    \"lint\": \"eslint \\\"**/*.ts*\\\"\"\n  },\n```\n\nrun-p 명령은 npm-run-all --parallel의 별칭이에요.\n\n위 전략은 개발 작업들을 직접 시작하는 데 의지할 수 있다면 신뢰성 있게 작동할 수 있다고 생각해요. 각 패키지 개발 작업은 계속 되기 때문에 (종료되지 않으므로), turbo.json 파일에서 한 패키지의 개발 작업이 다른 작업에 의존한다고 정의할 수 없어요.\n\n<div class=\"content-ad\"></div>\n\n최상위 dev 작업을 트리거하면 모든 dev 작업이 동시에 시작됩니다. 그래서 여러분의 패키지의 현재 빌드 상태에 따라 문제가 발생할 수도 있고, 발생하지 않을 수도 있다고 가정합니다. 저에게는 확실한 것 같지 않아요.\n\n지금은 제 프로젝트에는 충분해 보입니다.\n\n## Turbowatch\n\nnpm-run-all 방식은 분명 임시 방편일 뿐 실질적인 해결책은 아닙니다. 따라서 복잡한 monorepo에는 충분하지 않을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\nTurbowatch는 Turborepo의 누락된 시계 모드를 채우기 위해 설계되었습니다. 아직 직접 시도해보지 않아서 정확히 언행할 수는 없지만, 여러분이 한번 확인해보시길 권장합니다. Turborepo와 함께 사용할 수 있으며 독립적으로도 사용할 수 있습니다.\n\n## Firebase Emulators\n\n파이어베이스 에뮬레이터를 사용하면 Functions 및 Firestore 등의 코드를 배포하지 않고 실행하여 테스트할 수 있습니다. 분리 패키지 솔루션을 사용하는 경우에는 firebase.json의 source 필드를 분리된 출력에 지정하지만, 에뮬레이터는 동일한 진입점을 사용하므로 일반적으로 얻을 라이브 코드 업데이트가 손상되어 이는 주요 사항입니다.\n\n이 문제를 해결하기 위해 firebase-tools 패키지를 포크하여 배포 시 함수로 실행되도록 분리된 것을 통합해야 했습니다. 이렇게 하면 일반적으로 소스 코드에 에뮬레이터를 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n파이어베이스 툴의 기능에 큰 변화를 주지 않고, 사전 배포 단계를 추가하는 것 외에는 fork의 기능을 거의 사용하지 않아서 모든 프로젝트에서 안전하게 사용할 수 있다고 생각합니다. 제가 상위 저장소에서 정기적으로 변경 사항을 가져와 동일한 버전으로 업데이트를 게시하여 동기화를 유지할 것입니다.\n\n파이어베이스 팀이 제 솔루션을 채택하기를 기대하거나 모노 리포를 지원할 수 있는 더 나은 방법을 찾기를 바라겠습니다.\n\n# 결론\n\n이렇게 매우 지루한 주제에 대해 이처럼 멋지게 계속 읽어주셔서 영광으로 생각하며, 웃음이나 유머가 전혀 없었던 점에도 이렇게 멀리까지 이어주셨다니 감사합니다.\n\n<div class=\"content-ad\"></div>\n\n당신이 이런 것을 스스로 파악해야 하는 것보다 더 편리하다고 생각해요, 그래서 가치 있는 것을 배웠으면 좋겠어요.\n\n저는 시간이 흘러 이 기사를 업데이트하려고 노력할 거예요, 보일러플레이트 코드에 대해서도 그렇게 할 계획이에요. 만약 중요한 개선 제안이 있다면, 의견을 남기거나 GitHub 이슈를 만들어 주세요.","ogImage":{"url":"/assets/img/2024-05-17-MyquestfortheperfectTSmonorepo_0.png"},"coverImage":"/assets/img/2024-05-17-MyquestfortheperfectTSmonorepo_0.png","tag":["Tech"],"readingTime":14},{"title":"React jsx를 이해하는 방법","description":"","date":"2024-05-17 21:05","slug":"2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact","content":"\n\n<img src=\"/assets/img/2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact_0.png\" />\n\n## 소개\n\n리액트를 배우기 시작했다면 아마도 JSX라는 것에 대해 들어보았을 것입니다. JSX는 자바스크립트 내에서 HTML과 유사한 코드를 작성할 수 있게 해주는 구문 확장입니다. 이 독특한 기능은 리액트의 핵심 요소 중 하나로, 상호 작용하는 UI를 만들기 쉽게 해줍니다. 이 글에서는 JSX가 무엇인지, JavaScript와 HTML을 어떻게 통합하는지, 그리고 왜 유용한지 살펴보겠습니다. 또한 몇 가지 예제를 살펴보면서 JSX가 어떻게 동작하는지 알아볼 것입니다.\n\n## JSX란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nJSX는 JavaScript XML의 약자입니다. JavaScript의 구문 확장으로, JavaScript 코드 내에서 직접적으로 HTML 태그를 작성할 수 있게 해줍니다. HTML과 비슷해 보이지만, JavaScript의 모든 기능을 갖고 있습니다. JSX를 작성하면 일반적인 JavaScript 함수 호출로 변환되어 React 요소를 생성합니다.\n\n## JSX가 JavaScript와 HTML을 통합하는 방법\n\nJSX를 사용하면 JavaScript 로직을 HTML 구조와 원활하게 통합할 수 있습니다. 이 통합은 더 직관적으로 동적 웹 애플리케이션을 구축하는 데 도움이 됩니다. 다음은 JSX의 간단한 예시입니다:\n\n```js\nconst element = <h1>Hello, world!</h1>;\n```\n\n<div class=\"content-ad\"></div>\n\n이 JSX 코드가 다음으로 변환됩니다:\n\n```js\nconst element = React.createElement('h1', null, 'Hello, world!');\n```\n\n## JSX 사용의 장점\n\n1. 가독성과 유지보수성: JSX를 사용하면 마크업과 로직을 한 곳에 모아 코드를 더 읽기 쉽게 만들 수 있습니다. 이는 UI 구조와 관련 로직을 함께 볼 수 있어 이해와 유지보수가 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n2. 개발자 경험: JSX는 UI 구성 요소를 작성하는 더 직관적인 방법을 제공합니다. JSX 내에서 JavaScript의 모든 기능을 활용할 수 있으며, 반복문, 조건문 및 변수 선언을 포함할 수 있습니다.\n\n3. 강력한 추상화: JSX는 React.createElement() 호출을 추상화하여 코드를 덜 장황하고 더 선언적으로 만듭니다. 이 추상화는 더 깔끔하고 표현력이 높은 코드를 작성할 수 있도록 돕습니다.\n\n4. 도구 및 생태계: JSX는 다양한 도구와 편집기에서 지원되며, 구문 강조, 오류 확인 및 자동 완성 기능을 제공하여 개발자 경험을 향상시킵니다.\n\n## JSX 동작 예시\n\n<div class=\"content-ad\"></div>\n\n1. JSX에서 표현식 삽입하기\n\nJSX 내에서는 중괄호 `''`로 둘러싸면 어떤 JavaScript 표현식이든 포함할 수 있습니다. 변수, 함수 호출 등을 포함합니다.\n\n```js\nconst name = 'John';\nconst element = <h1>Hello, {name}!</h1>;\n```\n\n이 예시에서는 `name` 변수의 값이 JSX에 동적으로 삽입됩니다.\n\n<div class=\"content-ad\"></div>\n\n### 2. JavaScript 함수와 함께 JSX 사용하기\n\nJSX를 사용하면 JavaScript 함수를 사용하여 요소를 생성할 수 있습니다.\n\n```js\nfunction formatName(user) {\n return user.firstName + ‘ ‘ + user.lastName;\n}\n\nconst user = {\n firstName: 'John',\n lastName: 'Doe'\n};\n\nconst element = <h1>Hello, {formatName(user)}!</h1>;\n```\n\n여기서 `formatName` 함수는 JSX 내에서 호출되어 개인화된 인사말을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n### 3. JSX를 사용한 조건부 렌더링\n\nJSX 내에서 JavaScript의 조건부 연산자를 사용하여 요소를 조건부로 렌더링할 수 있습니다.\n\n```js\nconst isLoggedIn = true;\nconst element = (\n  <div>\n    {isLoggedIn ? <h1>어서 오세요!</h1> : <h1>로그인해주세요.</h1>}\n  </div>\n);\n```\n\n이 예제는 `isLoggedIn` 상태에 따라 다른 요소를 렌더링하는 삼항 연산자를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n### 4. JSX에서 반복문\n\n`map()`과 같은 JavaScript 배열 메소드를 사용하여 요소 목록을 렌더링할 수 있습니다.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =>\n <li key={number}>{number}</li>\n);\nconst element = (\n <ul>\n {listItems}\n </ul>\n);\n```\n\n이 경우 `map()` 함수는 숫자 배열에서 `li` 요소 목록을 생성하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n### 5. JSX를 사용하여 컴포넌트 생성하기\n\nJSX는 일반적으로 React 컴포넌트 내에서 사용됩니다. 다음은 간단한 컴포넌트 예제입니다:\n\n```js\nfunction Welcome(props) {\n return <h1>Hello, {props.name}</h1>;\n}\nconst element = <Welcome name=\"Sara\" />;\n```\n\n이 예제는 `name` prop을 받아 인사 메시지를 렌더링하는 `Welcome` 컴포넌트를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\nJSX는 JavaScript와 HTML의 장점을 결합하여 UI 구성 요소를 구축하는 직관적이고 효율적인 방법을 제공하는 React의 강력한 기능입니다. 읽기 쉬움, 사용하기 쉬움, 그리고 JavaScript와의 원활한 통합성은 개발자들 사이에서 인기를 얻고 있습니다. JSX를 활용함으로써 유지보수가 쉽고 표현력이 풍부한 코드를 작성할 수 있어 최종적으로 개발 워크플로우와 응용프로그램 품질을 향상시킬 수 있습니다.\n\n초보자든 경험 많은 개발자이든 JSX를 이해하고 활용함으로써 React 개발 환경을 크게 향상시킬 수 있습니다. 그러니 다음 React 프로젝트에서 JSX의 가능성을 탐험하고 시작해보세요!","ogImage":{"url":"/assets/img/2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact_0.png"},"coverImage":"/assets/img/2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 네이티브로 모달을 윕게 사용할 수 있는 Modal Manager 만들기","description":"","date":"2024-05-17 21:03","slug":"2024-05-17-ReactNativeCreateeasytouseModalManager","content":"\n\n<img src=\"/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_0.png\" />\n\n안녕하세요, 개발자 여러분!\n\n오늘은 React Native에서 모달을 가장 간편하고 편리하게 사용하는 방법에 대해 알아보겠습니다! React Native에서 모달을 사용하는 전통적인 방법은 각 화면이나 컴포넌트마다 \"Modal\" 컴포넌트와 해당 props를 정의하는 것이 일반적입니다. 이는 종종 모달이 사용되는 문맥에 높은 결합도를 가지는 문제로 이어질 수 있습니다.\n\n보통 확인 또는 다른 복잡한 동작에 모달을 사용하는 각 화면에서는 useState를 사용하여 가시성 상태를 정의합니다 (전통적인 [visible, setVisible] = useState(false) 방식), 이를 통해 모달이 화면에 표시되는지 여부를 컨트롤합니다. 이 방법은 개발 속도를 크게 늦추고 유연성과 재사용성을 저하시키는 요소로 인식됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 문제를 해결하기 위해 간단하고 효율적인 방법으로 모달 가시성을 관리하는 방법을 고안했습니다.\n\n화면 중앙에 표시되는 모달과 화면 하단에 고정된 모달을 위한 두 가지 다른 구성을 채택했습니다.\n\n그러니, 프로젝트 구조를 설정해 보겠습니다. 먼저 프로젝트의 src 디렉토리 내에 \"modal-manager\" 폴더를 추가하는 것으로 시작하겠습니다.\n\n![모달 매니저](/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_1.png)\n\n<div class=\"content-ad\"></div>\n\n보시다시피, 프로젝트를 최적으로 관리할 수 있는 간단하고 조직적인 구조를 만드는 것이 매우 중요합니다.\n\n최종 결과물로서, 모달을 메인 파일(예: App.tsx)에 삽입한 다음 간단한 방법으로 어디서든 사용할 수 있습니다.\n\n필요한 종속성은 \"react-native-modal\"뿐입니다. 따라서 모든 것이 올바르게 작동하도록 하려면 선호하는 패키지 관리자에 따라 npm 또는 yarn을 사용하여 라이브러리를 설치해야 합니다(저는 yarn을 선호합니다).\n\n여기에서는 나중에 사용할 모달을 어디에 어떻게 정의하는지에 대한 예제가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```jsx\n  import { NavigationContainer } from '@react-navigation/native';\n  import Modal, { BaseCenterModalContainer, BaseBottomModalContainer } from \"./src/modal-manager\";\n\n  export const App = () => {\n   \n   const showCenteredModal = () => {\n     Modal.show({\n       children: (\n         <BaseCenterModalContainer style={ height: 400, backgroundColor: 'white' }>\n           <Text>Center modal</Text>\n         </BaseCenterModalContainer>\n       ),\n       dismissable: true,\n       position: 'center',\n     });\n   };\n  \n  \n   return (\n     <NavigationContainer>\n       <Modal />\n       {children}\n     </NavigationContainer>\n   )\n  }\n```\n\n위에서 볼 수 있듯이, 모달을 사용하는 두 가지 예제가 있습니다. 간단하게 사용하기 위해 App.tsx 파일에 배치되었지만, 프로젝트의 어디에서든 \"Modal.show\" 및 \"Modal.hide\" 메소드를 사용할 수 있습니다.\n\n더불어, 모든 코드를 TypeScript로 작성하여 더 깨끗하고 재사용 가능한 코드를 구현하였습니다.\n\n두 가지 방법으로 모달을 표시할 수 있는 옵션이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n1 — 화면 하단에\n\n```js\nModal.show({\n children: (\n   <BaseBottomModalContainer style={ height: 400, backgroundColor: 'white' }>\n     <Text>Center modal</Text>\n    </BaseBottomModalContainer>\n  ),\n  dismissable: true,\n  position: 'bottom',\n});\n```\n\n<img src=\"/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_2.png\" />\n\n2 — 화면 중앙에 위치\n\n<div class=\"content-ad\"></div>\n\n```js\nModal.show({\n    children: (\n      <BaseCenterModalContainer style={ height: 400, backgroundColor: 'white' }>\n        <Text>Center modal</Text>\n      </BaseCenterModalContainer>\n    ),\n    dismissable: true,\n    position: 'center',\n  });\n```\n\n![Modal Manager](/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_3.png)\n\n두 경우 모두 세 가지 주요 속성이 있습니다:\n\n- children ⇒ 모달의 콘텐츠를 나타냅니다. 예를 들어, 간단한 텍스트를 삽입했습니다.\n- dismissable ⇒ 배경을 탭하여 모달을 닫을 수 있는지 여부를 나타냅니다.\n- position ⇒ 모달의 위치를 지정합니다. 이는 중앙 또는 하단일 수 있습니다. 이 두 값 중 하나를 사용할 때는 기본적인 스타일을 쉽게 오버라이드할 수 있는 BaseCenterModalContainer 또는 BaseBottomModalContainer 컴포넌트를 사용할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n또한, 이전 구성 요소를 사용하지 않고도 모달에 표시해야 하는 구성 요소를 간단히 전달할 수도 있습니다.\n\n자 이제 다양한 부분들을 자세히 살펴보겠습니다.\n\ntypes/index.tsx\n\n모달에 대한 모든 유용한 유형은 이 파일 내에서 정의되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { ReactNode } from 'react';\nimport { StyleProp } from 'react-native';\n\nexport type ReactChildren = ReactNode;\n\nexport type ModalData = {\n  children: ReactChildren;\n};\n\nexport type ModalOptions = {\n  dismissable: boolean;\n  animated?: boolean;\n  position: 'center' | 'bottom';\n};\n\nexport type ModalShowParams = ModalData & ModalOptions;\n\nexport type ModalHideParams = {};\n\nexport type ModalRef = {\n  show: (params: ModalShowParams) => void;\n  hide: (params?: ModalHideParams) => void;\n};\n\nexport type ModalConfig = {\n  style?: StyleProp<any>;\n};\n\nexport type ModalProps = {\n  config?: ModalConfig;\n};\n```\n\n컴포넌트 관련해서는 세 가지가 있습니다.\n\n이 중에서 가장 중요한 것은 모달의 기본 시각적 디자인을 캡슐화하고 있습니다. 특히 화면의 중앙이나 하단에 모달이 표시될지를 결정합니다.\n\nModalUI.tsx\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Dimensions, StyleSheet } from \"react-native\";\nimport { ModalConfig, ModalData, ModalHideParams, ModalOptions, ModalShowParams } from \"../types\";\nimport RNModal from \"react-native-modal\";\nimport { useCallback } from \"react\";\n\nexport type ModalUIProps = {\n  isVisible: boolean;\n  options: ModalOptions;\n  data: ModalData;\n  show: (params: ModalShowParams) => void;\n  hide: (params: ModalHideParams) => void;\n  config?: ModalConfig;\n  onHide: () => void;\n};\n\nconst { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('screen');\n\nexport const ModalUI = ({\n  isVisible,\n  data,\n  options,\n  hide,\n  onHide,\n  config,\n}: ModalUIProps) => {\n  const { children } = data;\n  const { style } = config || {};\n  const { dismissable, position, animated } = options;\n\n  const onBackdropPress = useCallback(() => {\n    if (dismissable) {\n      hide({});\n    }\n  }, []);\n\n  if (!children) {\n    return null;\n  }\n\n  return (\n    <RNModal\n      {...RNModal.defaultProps}\n      isVisible={isVisible}\n      useNativeDriver\n      deviceHeight={SCREEN_HEIGHT}\n      deviceWidth={SCREEN_WIDTH}\n      style={[modalPositionStyles[position], styles.modal, style]}\n      onBackdropPress={onBackdropPress}\n      avoidKeyboard={false}\n      onModalHide={onHide}\n      backdropOpacity={0.4}\n    >\n      {children}\n    </RNModal>\n  );\n};\n\nconst modalPositionStyles = StyleSheet.create({\n  center: {\n    justifyContent: 'center',\n    margin: 20,\n  },\n  bottom: {\n    justifyContent: 'flex-end',\n    margin: 0,\n  },\n});\n\nconst styles = StyleSheet.create({\n  modal: {},\n});\n```\n\n이 컴포넌트는 React Native에서 모달의 시각적 측면을 관리합니다. 다음은 이 컴포넌트의 역할입니다:\n\n2. 초기 설정:\n\n- 모달의 표시 상태, 표시할 데이터, 모달 구성 옵션, 모달을 숨기는 함수 및 모달 닫기 이벤트를 처리하는 콜백 함수와 같은 props를 받습니다.\n\n\n<div class=\"content-ad\"></div>\n\n2. 이벤트 처리:\n\n- 모달이 닫힐 수 있도록 설정되어 있으면 (dismissable), 모달 바깥 영역을 탭하면 모달을 숨기는 함수가 정의됩니다 (onBackdropPress).\n\n3. 모달 렌더링:\n\n- 모달의 내용은 존재하는 경우에만 조건부로 렌더링됩니다 (children). 표시할 데이터가 없는 경우에는 컴포넌트가 null을 반환합니다.\n- 모달을 생성하기 위해 react-native-modal 컴포넌트를 사용합니다.\n- 모달의 위치 (가운데 또는 아래)에 기본 스타일을 적용하고, config prop을 통해 제공된 스타일을 통해 사용자 정의를 허용합니다.\n\n<div class=\"content-ad\"></div>\n\n4. 미리 정의된 스타일:\n\n- 화면 중앙 또는 하단에 모달을 위치시키기 위해 두 세트의 스타일을 정의합니다.\n\n5. 모달 상태 관리:\n\n- 모달은 화면 크기를 상태의 일부로 수신하여 다양한 기기 크기에 적절하게 적응합니다.\n\n<div class=\"content-ad\"></div>\n\n요약하자면, 이 컴포넌트는 리액트 네이티브에서 모달을 유연하고 구성 가능하게 표시하는 인프라를 제공하며, 애플리케이션 요구에 맞는 외관 및 동작을 사용자화할 수 있습니다.\n\nBaseBottomModalContainer.tsx\n\n이 간단한 컴포넌트는 하단 모달에서 일반적으로 사용되는 기본 스타일을 정의하는 곳입니다. 예를 들어, 둥근 테두리 등이 있습니다.\n\n```js\nimport { StyleSheet, ViewProps } from \"react-native\";\n\nexport const BaseBottomModalContainer = ({ children, style, ...props }: ViewProps) => {\n  return (\n    <View style={[styles.container, style]} {...props}>\n      {children}\n    </View>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    borderTopRightRadius: 20,\n    borderTopLeftRadius: 20,\n    padding: 20\n  }\n})\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\nBaseCenterModalContainer.tsx\n\n```js\nimport { StyleSheet, View, ViewProps } from \"react-native\";\n\nexport const BaseCenterModalContainer = ({ children, style, ...props }: ViewProps) => {\n  return (\n    <View style={StyleSheet.compose(styles.container, style)} {...props}>\n      {children}\n    </View>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    borderRadius: 20,\n    padding: 20\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { useCallback, useState } from 'react';\nimport { ModalData, ModalOptions, ModalProps, ModalShowParams } from '../types';\nimport { mergeIfDefined } from '../utils/obj.ts';\n\nexport type UseModalParams = {\n  defaultOptions: Omit<ModalProps, 'config'>;\n};\n\nconst DEFAULT_OPTIONS: ModalOptions = {\n  dismissable: true,\n  position: 'center',\n  animated: false\n};\n\nexport const useModal = ({ defaultOptions }: UseModalParams) => {\n  const [isVisible, setIsVisible] = useState(false);\n  const [data, setData] = useState<ModalData>({\n    children: null,\n  });\n\n  const initialOptions = mergeIfDefined(\n    DEFAULT_OPTIONS,\n    defaultOptions,\n  ) as Required<ModalOptions>;\n\n  const [options, setOptions] = useState<ModalOptions>(initialOptions);\n\n  const show = useCallback(\n    (params: ModalShowParams) => {\n      setData({\n        children: params.children ?? null,\n      });\n      setOptions({\n        dismissable: params.dismissable ?? initialOptions.dismissable,\n        position: params.position ?? initialOptions.position,\n        animated: params.animated,\n      });\n      setIsVisible(true);\n    },\n    [initialOptions],\n  );\n\n  const hide = useCallback(() => {\n    setIsVisible(false);\n  }, [initialOptions]);\n\n  const onHide = useCallback(() => {\n    setData({\n      children: null,\n    });\n    setOptions(initialOptions);\n  }, [initialOptions]);\n\n  return {\n    isVisible,\n    show,\n    hide,\n    data,\n    options,\n    onHide,\n  };\n};\n```\n\n이 useModal이라는 훅은 모달을 관리하기 위해 설계되었습니다. 다음은 이 훅이 하는 일입니다:\n\n- 상태 관리: 현재 모달이 표시 중인지 여부를 나타내는 상태(isVisible) 및 모달 내부에 표시할 데이터(data)를 유지합니다.\n- 기본 옵션: 모달의 기본 옵션을 지정할 수 있으며, 모달이 닫힐 수 있는지(dismissable), 위치(position), 애니메이션 여부(animated) 등을 설정할 수 있습니다.\n- 모달 표시: show 함수를 사용하여 제공된 매개변수로 모달을 표시합니다. 제공된 매개변수에 기반하여 모달 데이터와 옵션을 업데이트하고 isVisible을 true로 설정합니다.\n- 모달 숨기기: hide 함수는 현재 표시 중인 모달을 숨기는 데 사용됩니다. isVisible를 false로 설정합니다.\n- 숨김 콜백: onHide 함수는 모달이 숨겨질 때 트리거되는 콜백입니다. 모달 데이터와 옵션을 초기 값으로 재설정합니다.\n\n\n<div class=\"content-ad\"></div>\n\nModal.tsx\n\n```js\nimport { forwardRef, useCallback, useImperativeHandle, useRef } from 'react';\nimport {\n  ModalHideParams,\n  ModalProps,\n  ModalRef,\n  ModalShowParams,\n} from './types';\nimport { useModal } from './hook/useModal.ts';\nimport { ModalUI } from \"./components\";\n\nconst ModalRoot = forwardRef((props: ModalProps, ref) => {\n  const { config, ...defaultOptions } = props;\n  const { show, hide, isVisible, options, onHide, data } = useModal({\n    defaultOptions,\n  });\n\n  // This must use useCallback to ensure the ref doesn't get set to null and then a new ref every render.\n  useImperativeHandle(\n    ref,\n    useCallback(\n      () => ({\n        show,\n        hide,\n      }),\n      [hide, show],\n    ),\n  );\n\n  return (\n    <ModalUI\n      isVisible={isVisible}\n      options={options}\n      data={data}\n      hide={hide}\n      onHide={onHide}\n      show={show}\n      config={config}\n    />\n  );\n});\n\ntype ModalRefObj = {\n  current: ModalRef | null;\n};\n\nlet refs: ModalRefObj[] = [];\n\n/**\n * Adds a ref to the end of the array, which will be used to show the toasts until its ref becomes null.\n *\n * @param newRef the new ref, which must be stable for the life of the Toast instance.\n */\nfunction addNewRef(newRef: ModalRef) {\n  refs.push({\n    current: newRef,\n  });\n}\n\n/**\n * Removes the passed-in ref from the file-level refs array using a strict equality check.\n *\n * @param oldRef the exact ref object to remove from the refs array.\n */\nfunction removeOldRef(oldRef: ModalRef | null) {\n  refs = refs.filter(r => r.current !== oldRef);\n}\n\nexport function Modal(props: ModalProps) {\n  const ModalRef = useRef<ModalRef | null>(null);\n\n  /*\n    This must use `useCallback` to ensure the ref doesn't get set to null and then a new ref every render.\n    Failure to do so will cause whichever Toast *renders or re-renders* last to be the instance that is used,\n    rather than being the Toast that was *mounted* last.\n  */\n  const setRef = useCallback((ref: ModalRef | null) => {\n    // Since we know there's a ref, we'll update `refs` to use it.\n    if (ref) {\n      // store the ref in this toast instance to be able to remove it from the array later when the ref becomes null.\n      ModalRef.current = ref;\n      addNewRef(ref);\n    } else {\n      // remove this toast's ref, wherever it is in the array.\n      removeOldRef(ModalRef.current);\n    }\n  }, []);\n\n  return <ModalRoot ref={setRef} {...props} />;\n}\n\nfunction getRef() {\n  const reversePriority = [...refs].reverse();\n  const activeRef = reversePriority.find(ref => ref?.current !== null);\n  if (!activeRef) {\n    return null;\n  }\n  return activeRef.current;\n}\n\nModal.show = (params: ModalShowParams) => {\n  getRef()?.show(params);\n};\n\nModal.hide = (params?: ModalHideParams) => {\n  getRef()?.hide(params);\n};\n```\n\n이 파일은 모달 컴포넌트를 설정하여 `Modal/`을 선언한 후 필요에 따라 표시하거나 숨길 수 있게 합니다. 기능을 자세히 살펴보겠습니다:\n\n- ModalRoot 컴포넌트:\n\n<div class=\"content-ad\"></div>\n\n- 이 컴포넌트는 ref를 전달받을 수 있도록 forwardRef를 사용하여 정의되었습니다.\n- Modal의 상태를 관리하는 useModal 훅을 활용하여 시각적 효과, 옵션 및 데이터를 포함합니다.\n- useImperativeHandle을 사용하여 ref가 모달을 조작하는 show 및 hide와 같은 필수 기능만 노출되도록 합니다.\n\n2. 모달 컴포넌트:\n\n- 사용자가 상호작용하는 컴포넌트입니다. ModalRoot 컴포넌트를 감싸고 ref를 관리합니다.\n- setRef 함수를 사용하여 ref가 올바르게 업데이트되고 나중에 사용하기 위해 저장됩니다.\n\n3. Ref 관리:\n\n<div class=\"content-ad\"></div>\n\n- `addNewRef`은 새 모달이 생성될 때 refs 배열에 새 ref를 추가합니다.\n- `removeOldRef`는 모달이 파괴될 때 배열에서 ref를 제거합니다.\n\n4. 정적 메서드:\n\n- `Modal.show`과 `Modal.hide`는 Modal 컴포넌트에 연결된 정적 메서드입니다.\n- 이들은 활성 모달 인스턴스를 찾기 위해 refs 배열을 활용하고 해당하는 show 또는 hide 메서드를 호출합니다.\n\n이 파일은 React Native 애플리케이션에서 모달을 관리하는 논리를 캡슐화합니다. 사용자는 `Modal/` 컴포넌트 하나로 모달을 쉽게 생성하고 제어할 수 있으며, 모달을 표시하고 숨기는 정적 메서드가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n여기까지 왔네요! 이 모달 관리 시스템을 구현함으로써 프로세스를 보다 효율적이고 직관적으로 만들었습니다. 이 방식의 모듈성을 통해 표시 및 상호 작용 방식을 우리의 특정 요구에 쉽게 적응시킬 수 있습니다. 더 많은 통찰력과 코딩을 더 부드럽고 빠르게 만들어줄 새로운 도구를 업데이트하는 방법을 계속 따라와 주세요. 이 여정에 함께해줘서 감사합니다!\n\n즐거운 코딩하세요!\n\n소스 코드: https://github.com/davidecarizzoni/react-native-modal-manager\n\nLinkedin 프로필: https://www.linkedin.com/in/davide-carizzoni/","ogImage":{"url":"/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_0.png"},"coverImage":"/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_0.png","tag":["Tech"],"readingTime":14},{"title":"프론트엔드 개발자를 위한 TypeScript 마스터하기","description":"","date":"2024-05-17 21:00","slug":"2024-05-17-MasteringTypeScriptinEverydayProgramming","content":"\n\n<img src=\"/assets/img/2024-05-17-MasteringTypeScriptinEverydayProgramming_0.png\" />\n\n# 프론트엔드 개발에서의 TypeScript 🚀\n\nMicrosoft에서 개발된 TypeScript는 2012년 10월 오픈 소스로 등장한 이후로 프론트엔드 개발자들에게 필수적인 도구가 되었습니다.\n\n🌐 널리 인정받아 현재는 대규모 프로젝트에서 표준으로 사용되며, 정적 타입 시스템을 통해 코드 가독성과 유지보수성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n💪 최신 JavaScript 기능을 제공하는 TypeScript은 강력한 컴포넌트를 만들 수 있게 해주어 매 반복 업데이트마다 프론트엔드 코딩을 더욱 편안하게 만듭니다.\n\n🔄 TypeScript는 계속해서 프론트엔드 개발 환경을 향상시키며 진화를 받아들이세요.\n\n![Mastering TypeScript in Everyday Programming](/assets/img/2024-05-17-MasteringTypeScriptinEverydayProgramming_1.png)\n\n# TypeScript를 선택해야 하는 이유? ✨\n\n<div class=\"content-ad\"></div>\n\n마이크로소프트는 TypeScript를 소개할 때 두 가지 주요 목표를 가졌습니다: JavaScript를 위한 선택적 유형 시스템 제공 및 현재 및 미래의 JavaScript 기능과의 호환성 보장.\n\n🛠️ 코드 품질과 유지 관리:\n- 유형은 코드 리팩터링을 돕고 런타임이 아니고 컴파일 시간에 오류를 잡아낸다.\n- 유형은 탁월한 문서화 역할을 하며 명확한 함수 선언을 통해 코드 이해를 높인다.\n\n🔄 TypeScript의 접근 방식:\n- TypeScript는 선택적 유형을 제공하여 JavaScript를 너무 복잡하지 않게 개선하는 균형을 유지한다.\n- 이는 \"JavaScript 슈퍼셋\" 역할을 하며 컴파일 시간 유형 안전성을 제공하면서 JavaScript와 완전히 호환된다.\n\n👀 유형 추론 및 주석:\n- TypeScript는 개발 중 비용 효율적인 유형 안전성을 위해 유형을 추론한다.\n- 명시적 유형 주석은 코드 이해와 가독성을 돕는 미래 개발자를 지원할 수 있다.\n\n<div class=\"content-ad\"></div>\n\n🚀 원활한 통합 및 이전:\n- TypeScript는 JavaScript에서 원활한 이전을 보장하며, 오류가 있더라도 호환 가능한 JavaScript로 컴파일됩니다.\n- 타입 오류는 일반적인 JavaScript 런타임을 방해하지 않습니다.\n\n🌐 TypeScript의 주요 기능:\n- 아파치 라이선스 하에 무료 및 오픈 소스입니다.\n- ECMAScript 표준을 기반으로 구축되었으며, JavaScript를 확장합니다.\n- 선택적인 정적 타입, 클래스 및 모듈을 추가합니다.\n- ECMAScript 사양을 준수하는 읽기 쉬운 JavaScript로 컴파일됩니다.\n- 모든 브라우저, 호스트 및 운영 체제에서 교차 플랫폼 지원을 제공합니다.\n- 기존 JavaScript 코드와의 완전한 통합 (ts/tsx 파일 확장자).\n- 런타임 오염 없는 컴파일 시간 검사.\n\n# TypeScript 개발 시작하기 🚀\n\n## TypeScript 종속성 설치\n\n<div class=\"content-ad\"></div>\n\nTypeScript 개발 환경을 설정하는 것은 매우 쉬운 일이에요. 특히 대부분의 프론트엔드 프로젝트에서 TypeScript를 손쉽게 통합할 수 있죠. 아래 간단한 단계를 따라 시작해보세요:\n\n1. 프론트엔드 프로젝트에 꼭 필요한 NodeJS와 npm 도구가 설치되어 있는지 확인해주세요.\n\n2. TypeScript를 설치하려면 npm 명령어를 사용하세요. 아래 명령어로 간단하게 설치할 수 있어요:\n\n```js\nnpm install --save-dev typescript ts-node\n```\n\n<div class=\"content-ad\"></div>\n\n✨ TypeScript 및 필수 런타임 ts-node를 함께 설치합니다.\n\n이러한 종속성이 설치되면 TypeScript 개발 세계로 뛰어들 준비가 됩니다! 🌐\n\nBabel 통합 설치\n\n프론트엔드 프로젝트의 동적한 세계에서 Babel은 중요한 동료입니다. TypeScript와 Babel을 결합하면 강력한 개발 환경이 구성됩니다. TypeScript 컴파일러는 정적 타입 확인을 처리하고, Babel은 TypeScript 코드를 실행 가능한 JavaScript로 변환합니다.\n\n<div class=\"content-ad\"></div>\n\nBabel을 TypeScript와 원활하게 통합하기 위해서는 주요 의존성 패키지 '@babel/preset-typescript'이 필요합니다. 아래 npm 명령어를 실행해주세요:\n\n```js\nnpm install -D @babel/preset-typescript\n```\n\n'Babel' 환경 설정 파일 (babel.config.js)에 '@babel/preset-typescript'를 추가해주세요. 이 프리셋은 TypeScript에서 유형과 관련된 코드 (예: 유형 주석, 인터페이스)를 제거하고 필요한 옵션을 추가하는 데 도움이 됩니다.\n\n```js\n// babel.config.js\n{\n \"presets\": [\n // …\n \"@babel/preset-typescript\"\n ]\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 통합을 통해 TypeScript와 Babel이 손을 맞잡고 프론트엔드 개발 경험을 높여줍니다! 🚀🔧\n\nESLint 통합 설치 방법\n\n어떤 프로젝트에서든 코드 검토는 중요한 측면입니다. TypeScript는 기본 오류 감지를 제공하지만 프로젝트와 개발팀이 성장함에 따라 일관된 코드 스타일 유지가 필수적입니다. ESLint가 등장합니다. 이는 코드 스타일을 강제하는 강력한 도구입니다.\n\nESLint를 사용하여 TypeScript 코드를 구문 분석하려면 필요한 구문 분석기와 플러그인을 설치하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install --save-dev @typescript-eslint/parser @typescript-eslint/eslint-plugin\n```\n\n참고: `@typescript-eslint/parser` 및 `@typescript-eslint/eslint-plugin` 모두 동일한 버전이어야 합니다.\n\nESLint 구성 파일 (`.eslintrc.js`)에 다음 옵션을 추가해주세요:\n\n```js\n// .eslintrc.js\n{\n  \"parser\": \"@typescript-eslint/parser\",\n  \"plugins\": [\"@typescript-eslint\"],\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:@typescript-eslint/recommended\"\n  ],\n  \"rules\": {\n    \"@typescript-eslint/no-use-before-define\": \"error\",\n    // …\n  }\n}\n```\n\n이 구성을 통해 ESLint가 TypeScript 코드를 구문 분석하도록 설정되며, 권장 규칙을 적용하거나 필요에 따라 규칙을 사용자 정의할 수 있습니다. 🧐🔍✨\n\n\n<div class=\"content-ad\"></div>\n\n## TypeScript 컴파일 구성\n\nTypeScript는 명령줄 매개변수를 사용하여 파일을 컴파일할 수 있는 기능을 제공하지만, 일반적으로 `tsconfig.json`을 사용하여 프로젝트를 개발합니다. 이 파일이 프로젝트에 없다면 수동으로 만들거나 `tsc — init` 명령을 사용하여 생성할 수 있습니다. TypeScript를 처음 사용할 때는 기본 `tsconfig.json` 파일이 충분하며, 필수적인 컴파일 관련 정보가 포함되어 있습니다. 프로젝트가 성숙해질수록 각 옵션을 이해하고 사용자 정의하는 것이 필요해집니다.\n\n기본 옵션\n\n초기 단계에서는 기본 `tsconfig.json` 파일이 적절하며, 일반적으로 다음과 같은 기본 컴파일 옵션이 포함됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n \"compilerOptions\": {\n \"target\": \"es5\",\n \"module\": \"commonjs\",\n \"strict\": true,\n // …\n }\n}\n```\n\n개인 설정이 필요한 경우, `tsconfig.json` 파일의 각 항목에 대한 구체적인 이해가 중요합니다. 이러한 컴파일 옵션은 다음과 같이 해석됩니다:\n\n- target: ECMAScript 대상 버전을 지정합니다.\n- module: 코드 생성을 위한 모듈 시스템을 정의합니다.\n- strict: 엄격한 유형 검사 옵션을 강제합니다.\n\n엄격한 유형 검사 옵션\n\n<div class=\"content-ad\"></div>\n\nTypeScript을 구성할 때는 프로젝트의 동작을 맞춤화하기 위한 다양한 엄격한 타입 확인 옵션이 있습니다. 여기에 몇 가지 주요 옵션을 안내해드리겠습니다:\n\n- strict: 엄격한 타입 확인을 활성화합니다 (true/false).\n- allowUnreachableCode: 도달할 수 없는 코드를 허용하거나 금지합니다 (true/false).\n- allowUnusedLabels: 사용되지 않는 레이블 오류의 보고를 제어합니다 (true/false).\n- noImplicitAny: 표현식과 선언에서 암시적 'any'에 대한 오류 플래그를 설정합니다 (true/false).\n- strictNullChecks: 엄격한 null 확인을 활성화합니다 (true/false).\n- noImplicitThis: 'this' 표현식의 'any' 값을 오류로 생성합니다 (true/false).\n- alwaysStrict: 각 모듈을 엄격 모드로 확인하여 각 파일에 'use strict'를 추가합니다 (true/false).\n- noImplicitReturns: 일부 함수 분기가 값 반환을 하지 않을 때 오류를 보고합니다 (true/false).\n- noFallthroughCasesInSwitch: switch 문에서 fallthrough 오류를 보고할 지 여부를 나타냅니다.\n\n모듈 구문 구성 옵션\n\nTypeScript가 모듈을 구문 분석하는 방법을 구성하세요:\n\n<div class=\"content-ad\"></div>\n\n- moduleResolution: 모듈 해결 전략을 설정합니다 (기본값: 'node' 또는 'classic').\n- baseUrl: 상대적이지 않은 모듈 이름을 해결하기 위한 루트 디렉터리를 지정합니다.\n- paths: `baseUrl`에 기반하여 모듈 이름을 경로에 매핑합니다 (형식: '').\n- rootDirs: 프로젝트의 런타임 콘텐츠를 나타내는 루트 폴더를 나열합니다 (형식: []).\n- typeRoots: 유형 선언을 포함하는 파일을 지정합니다 (형식: [“./types”]).\n\n소스 맵 옵션\n\n소스 맵 설정을 세밀하게 조정하세요:\n- sourceRoot: 디버거가 소스 파일 대신 TypeScript 파일을 찾을 위치를 지정합니다.\n- mapRoot: 디버거가 생성된 파일 대신 맵 파일을 찾을 위치를 지정합니다.\n- inlineSourceMap: 단일 소스 맵 파일을 생성할지 여부를 결정합니다.\n- inlineSources: 코드 및 소스 맵을 단일 파일로 생성합니다 (`inlineSourceMap` 및 `sourceMap` 속성이 필요함).\n\n기타 옵션\n\n<div class=\"content-ad\"></div>\n\n추가 구성 옵션을 살펴보세요:\n- experimentalDecorators: 데코레이터를 활성화하거나 비활성화합니다.\n- emitDecoratorMetadata: 데코레이터를 위한 메타데이터 지원을 제어합니다.\n\n포함 및 제외 옵션\n컴파일을 위해 파일을 지정하여 성능을 향상시키는 `include`와 `exclude`를 사용하세요:\n\n```js\n\"exclude\": [\n \"node_modules\",\n \"dist\"\n // …\n]\n```\n\n이러한 구성 옵션을 사용하여 TypeScript를 프로젝트의 요구 사항에 맞게 정교하게 조정할 수 있어요! 🔧🎛️\n\n<div class=\"content-ad\"></div>\n\n## TypeScript 유형 주석\n\n이제 TypeScript 구성을 알게 되었으니, TypeScript에서 제공하는 기본 유형을 살펴보겠습니다. 다음 비교 표는 TypeScript 유형과 그 ES6 상당품을 함께 보여줍니다:\n\n이제 TypeScript 관련 구성에 익숙해졌으니, TypeScript에서 제공하는 기본 유형에 대해 알아봅시다. 다음 비교는 TypeScript 유형과 그 ES6 상당품과의 차이점을 요약합니다:\n\n1. Numeric Type:\n— TypeScript: `number` | ES6: `number`\n\n<div class=\"content-ad\"></div>\n\n2. 텍스트 유형:\n- TypeScript: `string` | ES6: `string`\n\n3. 논리 유형:\n- TypeScript: `boolean` | ES6: `boolean`\n\n4. 순차적인 유형:\n- TypeScript: `array` | ES6: `array`\n\n5. 정렬된 유형 (튜플):\n- TypeScript: ✅ | ES6: ❌\n\n<div class=\"content-ad\"></div>\n\n6. Enumerated Type (Enum):\n- TypeScript: ✅ | ES6: ❌\n\n7. Dynamic Type:\n- TypeScript: `any` | ES6: `any`\n\n8. Void Type:\n- TypeScript: `void` | ES6: `void`\n\n9. Null Type:\n- TypeScript: ✅ | ES6: ❌\n\n<div class=\"content-ad\"></div>\n\n10. 정의되지 않은 유형:\n- TypeScript: ✅ | ES6: ❌\n\n11. Never 유형:\n- TypeScript: ✅ | ES6: ❌\n\n이 간단한 형식은 TypeScript와 ES6 모두에 해당 유형이 존재하는지 (✅) 존재하지 않는지 (❌)를 나타냅니다.\n\nTypeScript의 유형 주석은 다른 언어의 유형 선언과 일치합니다. 변수 선언에는 `let`과 `const`를 사용할 수 있으며, 다음 구문을 따릅니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// 구문: let 또는 const 변수이름: 데이터타입 = 초기값;\n// 예시:\nlet varName: string = '안녕 타입스크립트';\n```\n\n함수 선언에 대해서는 함수 표현식을 사용하는 것이 좋습니다. 또는 화살표 함수를 사용하여 간결함을 높일 수 있습니다:\n\n```js\n// 구문: let 또는 const 함수표현식이름 = function(매개변수1: 타입, 매개변수2: 타입): 반환타입 {\n// // 코드 실행\n// // return xx;\n// }\n// 예시:\nlet sum = function(num1: number, num2: number): number {\n return num1 + num2;\n}\n```\n\n이 구조는 TypeScript의 타입 주석, 변수 선언 및 함수 표현식에 대한 논리적 개요를 제공하며, 명확성을 위해 이모지로 장식되어 있습니다. 🌟\n\n\n<div class=\"content-ad\"></div>\n\n## TypeScript 특수 타입\n\nTypeScript의 기본 타입 사용은 다른 백엔드 언어와 일치합니다. 이 섹션에서는 TypeScript에만 존재하는 특수 타입을 소개하여 타입 선언을 복잡하게 만들고 세부 사항을 더합니다.\n\n`any` — \"백도어\" 🎨\n\n`any`는 TypeScript에서 독특한 위치를 차지하며 타입 시스템에서 \"백도어\" 역할을 합니다. 이것은 타입 확인을 비활성화하여 모든 타입과의 호환성을 가능케 합니다. 그러나 타입 안전성을 유지하기 위해 `any`에 대한 의존을 최소화해야 하며, 특정 문제를 해결하는 경우를 제외하고 사용해야 합니다. `any`를 사용하면 TypeScript 컴파일러에 타입 확인을 건너뛰도록 지시합니다.\n\n<div class=\"content-ad\"></div>\n\n임의의 값 유형은 `Object`과 유사하지만 `Object` 유형의 변수가 다양한 값 할당을 허용하는 반면에 해당 메서드는 호출할 수 없습니다.\n\n- `void`: 함수 선언에서 반환 값이 없음을 나타냅니다.\n- `null`: 존재하지 않는 객체 값을 나타내며 일반적으로 값으로만 사용됩니다.\n- `undefined`: 선언되었지만 초기화되지 않은 변수의 값을 나타냅니다.\n\n`null`과 `undefined`는 모든 유형의 하위 유형으로, 모든 유형의 변수에 할당할 수 있습니다. `strictNullChecks` 구성을 활성화하면 `void` 및 스스로에 대한 할당이 제한됩니다.\n\n<div class=\"content-ad\"></div>\n\n열거형 🌌\n\nTypeScript는 열거형 유형을 지원하여 JavaScript의 표준 데이터 유형을 향상시킵니다. 열거형은 제한된 데이터 집합에 친숙한 이름을 제공하여 코드 가독성을 향상시킵니다. 선언에 `enum` 키워드를 사용하세요.\n\n```js\nenum SendType {\n SEND_NORMAL,\n SEND_BATCH,\n SEND_FRESH,\n // …\n}\n```\n\n`never` 유형 🎭\n\n<div class=\"content-ad\"></div>\n\n`never` 타입은 복잡한 상황에서 사용됩니다. 예외가 발생하거나 정상적으로 종료되지 않을 수 있는 함수에서 나타납니다.\n\n🌌 튜플 타입\n\n배열과 유사하게, 튜플 유형은 서로 다른 유형의 요소를 허용합니다.\n\n```js\nlet row: [number, string, number] = [1, 'hello', 88];\n```\n\n<div class=\"content-ad\"></div>\n\n인터페이스 🎨\n\nTypeScript의 인터페이스는 읽기 전용 속성, 선택적 속성 및 상속과 같은 다양한 기능을 지원하는 여러 타입 선언을 결합합니다.\n\n타입 별칭 📝\n\n타입 별칭은 유니언 타입, 튜플 타입, 함수 타입, 객체 타입 및 교차 타입을 지원하는 타입 주석을 위한 별칭을 설정하는 편리한 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n네임스페이스 🌐\n\n네임스페이스는 코드를 구성하여 이름 충돌을 피하는 데 도움이 됩니다. `namespace` 키워드를 사용하여 정의되며, 코드 분리와 전역 네임스페이스 혼잡을 방지합니다.\n\n```js\n// 다중 파일 네임스페이스\n// Validation.ts\nnamespace Validation {\n export interface StringValidator {\n isAcceptable(s: string): boolean;\n }\n}\n// NumberValidator.ts\nnamespace Validation { // 같은 네임스페이스\n export interface NumberValidator {\n isAcceptable(num: number): boolean;\n }\n}\n```\n\n제네릭 🧬\n\n<div class=\"content-ad\"></div>\n\n일반적으로 사용되는 이몽다는 서로 다른 유형과 함께 작업하는 코드를 작성할 수 있게 합니다. 클래스 멤버, 메소드 매개변수 및 함수 반환값에 유용합니다.\n\n```js\n// 일반적인 예시\nclass Queue<T> {\n private data: T[] = [];\n push = (item: T) => this.data.push(item);\n pop = (): T | undefined => this.data.shift();\n}\n// 숫자 유형으로 사용\nconst queue = new Queue<number>();\nqueue.push(0);\nqueue.push(1);\n// 문자열 유형으로 사용\nconst strQueue = new Queue<string>();\nstrQueue.push('0');\nstrQueue.push('1');\n```\n\n타입 단언 🛡️\n\n타입 단언은 개발자가 값을 수동으로 유형으로 지정할 수 있게 해주며 컴파일러에게 어떤 유형이어야 하는지 전달하는 방법을 제공합니다. `대상 유형`, `as T`, `!` (null이 아님 타입 단언)과 같은 다양한 구문 형식은 다양한 시나리오에 맞게 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// Type assertions\nlet value: any = 'hello';\nlet length: number = (value as string).length; // 'as' 문법 사용\n// 대체 문법\nlet alternativeLength: number = (<string>value).length;\n// 'as const' 또는 '!' coercion\nlet immutableValue = 'hello' as const;\n```\n\n# 📘결론\n\n👉 주요 포인트:\n\n- 🌱 적합 대상: TypeScript에 입문하는 사람들 및 준비 중인 사람들.\n- 🏗️ 범위: 실무에 기반한 기본 사용법과 기본 지식.\n- 🧠 한계: 아키텍처 설계에 대한 심화 분석은 이루어지지 않으며, 열성적인 사람들을 위한 오프라인 소통을 권장합니다.\n\n<div class=\"content-ad\"></div>\n\n💡 TypeScript 능숙도의 장점:\n\n- 🖊️ 코드를 작성할 때 더 나은 결과물이 되는 것뿐만 아니라 더 안전한 코드를 작성할 수 있습니다.\n- 🚀 코딩 스킬을 새로운 높이로 끌어올릴 수 있습니다.\n\n👋 마지막으로: 읽어 주셔서 진심으로 감사드립니다! 더 알고 싶고 깊이 파고들고 싶다면 오프라인에서 연락해요. 이 기사가 여러분에게 풍요로운 TypeScript 여행의 시작이 되기를 기대합니다. 즐거운 코딩 되세요! 🚀👩‍💻","ogImage":{"url":"/assets/img/2024-05-17-MasteringTypeScriptinEverydayProgramming_0.png"},"coverImage":"/assets/img/2024-05-17-MasteringTypeScriptinEverydayProgramming_0.png","tag":["Tech"],"readingTime":11},{"title":"Angular에서 간단한 코드로 SCSS를 활용해 트리 계층구조를 만드는 방법","description":"","date":"2024-05-17 20:59","slug":"2024-05-17-Howtomakesimpletreehierarchyinangularusingscsswithsimplecoding","content":"\n\n\n![Tree Hierarchy Example](/assets/img/2024-05-17-Howtomakesimpletreehierarchyinangularusingscsswithsimplecoding_0.png)\n\n한 가지 문자열 배열이 있다고 가정해봅시다. 만약 우리가 문자열 배열을 트리 구조로 그리고 싶다면, 어떻게 할 수 있을까요? 함께 살펴보겠습니다.\n\n![Tree Hierarchy Example](/assets/img/2024-05-17-Howtomakesimpletreehierarchyinangularusingscsswithsimplecoding_1.png)\n\n# 단계 1:\n\n\n<div class=\"content-ad\"></div>\n\n샘플 Angular 애플리케이션을 cmd를 사용하여 생성합니다.\n\n# 단계 2:\n\ntreeData 배열을 생성하고 기본값으로 초기화합니다.\n\n```js\n//app.component.ts\n\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss'],\n})\nexport class AppComponent {\n\n  treeData:string[];\n\n  constructor() {\n    this.treeData = [\n      'Root',\n      'Node1',\n      'Node2',\n      'Node3'\n    ];\n  }\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 3:\n\nSCSS 파일에 믹스인 함수를 만드세요.\n\n```scss\n//app.component.scss\n\n@mixin generate($prefix, $property, $length) {\n  $spacing: 20px;\n  @for $i from 1 through $length {\n    .#{$prefix}-#{$i} {\n      #{$property}: $spacing * $i;\n    }\n  }\n}\n \n@include generate(li, margin-left, 20);\n```\n\n믹스인을 사용하면 스타일을 정의하고 스타일 시트 전체에서 재사용할 수 있습니다. 이를 통해 .float-left와 같은 의미 없는 클래스를 사용하는 것을 피하고 스타일 모음을 라이브러리로 분배하는 것이 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n자세히 보기: https://sass-lang.com/documentation/at-rules/mixin/\n\n`generate()` 함수는 주어진 접두사, 속성 및 길이로 여러 클래스를 생성하는 데 사용됩니다. 'li', 'margin-left', '20'을 전달하면 다음과 같은 클래스가 생성됩니다.\n\n```js\n.li-1 {\n  margin-left: 20px;\n}\n\n.li-2 {\n  margin-left: 40px;\n}\n\n.li-3 {\n  margin-left: 60px;\n}\n...\n...\n...\n.li-20 {\n  margin-left: 400px;\n}\n```\n\n이 클래스를 사용하여 각 반복에서 왼쪽 마진을 증가시킵니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 4:\n\n`ul` 및 `li` 태그를 사용하여 HTML 파일에 목록을 만들고 `li` 태그에 *ngFor를 추가합니다.\n\n```js\n<ul>\n  <li *ngFor=\"let data of treeData;index as i\" [ngClass]=\"'li-'+i\">\n    {data}\n  </li>\n</ul>\n```\n\n여기서 `[ngClass]=”’li-’+i”`를 추가했습니다. 각 반복마다 동적으로 생성된 클래스를 사용한다는 의미입니다.\n\n<div class=\"content-ad\"></div>\n\n\n[ngClass]=\"'li-1'\"\n[ngClass]=\"'li-2'\"\n[ngClass]=\"'li-3'\"\n[ngClass]=\"'li-4'\"\n....\n....\n[ngClass]=\"'li-20'\"\n\n# Step 5:\n\n코드를 실행하고 즐기세요!\n\n코딩을 즐기세요!!!\n","ogImage":{"url":"/assets/img/2024-05-17-Howtomakesimpletreehierarchyinangularusingscsswithsimplecoding_0.png"},"coverImage":"/assets/img/2024-05-17-Howtomakesimpletreehierarchyinangularusingscsswithsimplecoding_0.png","tag":["Tech"],"readingTime":3},{"title":"Reactime v25, 개발자 도구를 더욱 잘 활용하는 방법","description":"","date":"2024-05-17 20:58","slug":"2024-05-17-Reactimev25Thetimetoreactisnow","content":"\n\n강력한 개발자 도구가 더욱 강력하고 직관적으로 업그레이드되었습니다.\n\n공동 저술자: Haider Ali, Mel Koppens, Jose Luis Sanchez\n\nReactime이란?\n\nReact는 여전히 최고입니다! React는 2023년에 가장 인기 있는 자바스크립트 프론트엔드 프레임워크였으며 어떤 언어의 프론트엔드 프레임워크 중 가장 많이 사용되는 프레임워크 중 하나입니다. 그러나 혁신을 위한 여지는 항상 존재합니다.\n\n<div class=\"content-ad\"></div>\n\n큰 복잡한 코드베이스를 다룰 때 문제가 생길 수 있습니다 — React는 대화식이고 확장 가능한 애플리케이션을 만들 때 보편적으로 사용되는 점을 고려할 때 매우 중요합니다. React 개발자들은 컴포넌트 아키텍처, 상태, 그리고 프로그래밍 중 불가피하게 발생하는 버그들을 고려해야 합니다. Reactime은 이러한 난관을 완화하는 데 도움이 되어서 무엇이 일어나고 있는지 빠르게 확인하고 효과적으로 빌드할 수 있도록 돕습니다.\n\n간단히 말해서, Reactime은 React 애플리케이션을 위해 설계된 오픈 소스 타임 트래블 디버깅 도구입니다. 이 도구는 컴포넌트 트리의 동적 그래픽 표현, 컴포넌트 상태(현재 및 이력), 다양한 메트릭 등을 포함하여 많은 기능을 제공합니다. 이러한 기능들은 숙련된 개발자들에게 훌륭한 도구로 만들어주며, 새로운 개발자들이 React를 배우는 데 훌륭한 도구로 만드는 새로워진 UI도 제공합니다!\n\n버전 25.0을 소개합니다!\n\n![Reactime](https://miro.medium.com/v2/resize:fit:1400/1*mWtM2Ad_D4rwpHggQv3JYQ.gif)\n\n<div class=\"content-ad\"></div>\n\n프롭 드릴링 시각화\n\nReactime 앱의 컴포넌트 맵 디스플레이는 가장 눈에 띄는 기능 중 하나일 수 있습니다. 이는 사용자가 React 앱의 모든 컴포넌트가 어떻게 서로 연결되고 흐르는지를 볼 수 있게 합니다. Reactime 버전 25.0은 이 직관적인 그래픽 사용자 인터페이스를 확장하여 컴포넌트 간에 어떻게 프롭이 전달되는지를 보여줍니다. 부모와 자식 노드를 연결하는 링크의 색상으로 전달된 프롭의 존재와 양을 나타냅니다. 회색 링크 대신에 프롭을 전달하는 링크는 낮은 프롭부터 높은 프롭까지의 범위인 노랑에서 마룬까지의 색상을 가지고 있습니다. 또한 굵은 글씨는 외관을 통합하면서 요소 간에 흐르는 프롭의 양을 직관적으로 나타내어 깔끔한 모습을 유지합니다.\n\n![Reactimev25](/assets/img/2024-05-17-Reactimev25Thetimetoreactisnow_0.png)\n\n개선된 UI: 더 적은 혼잡, 더 많은 사용성\n\n<div class=\"content-ad\"></div>\n\n이 개발자 도구에 포함된 다양한 개별 도구들은 훌륭하지만, 너무 많은 도구들은 UI를 혼란스럽게 만들고 앱을 탐색하기 어렵게 만들 수 있습니다. 이를 해결하기 위해, 우리는 최상위 컨테이너에서 비탐색 구성 요소를 제거하여 탐색 허브로 변형하고 다른 모든 탐색 버튼을 이동시켰어요. 아, 그리고 우리는 현대적인 스타일도 적용했어요. 이제 Reactime을 사용하는 방법에 대해 고민하는 시간을 줄이고 실제로 사용하는 시간을 늘릴 수 있어요. 추가로, 주 컨테이너는 React fiber tree(또는 해당 컨테이너 내에 표시되는 다른 도구들)에 더 많은 공간을 제공합니다.\n\n![이미지](/assets/img/2024-05-17-Reactimev25Thetimetoreactisnow_1.png)\n\n버그 수정: 이제 더 부드러워요\n\n이전 버전의 Reactime Chrome 확장 프로그램은 가끔 시작할 때 문제를 발생시켜 Chrome 브라우저가 오랫동안 활성화되어 있으면 작동을 중단할 수 있었습니다. 이 문제를 해결하기 위해, 저희 팀은 Chrome API의 비동기성을 처리하기 위한 개선을 구현하여, 브라우저가 오랫동안 활성화되어 있으면 더 부드럽게 작동하도록 보장했어요. 주된 문제는 활성 탭의 속성에 액세스를 시도하기 전에 어떤 탭이 활성인지 확인하지 않았다는 것이었어요. 이 문제는 Chrome API의 비동기적 특성을 부적절하게 처리하여 발생했죠. 이를 해결하기 위해, background.js 파일의 코드를 다시 구성하여 비동기 작업을 올바르게 처리했어요. 이를 위해, 내용 스크립트를 삽입하기 전에 활성 탭을 쿼리하는 로직을 추가하여, 확실한 컨텍스트에서 이동하기 전에 확장 프로그램이 올바른 컨텍스트를 갖도록 했어요. 추가로, 활성 탭이 무엇인지 계속 확인하고 확증하기 위한 구독 서비스가 구현되었어요. 이 접근 방식은 더 많은 리소스를 소비하지만, 브라우저가 오랫동안 활성화되어 있을 때 확장 프로그램이 작동 중단되지 않도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 개선으로 중요한 긍정적 결과가 나타났습니다. 시작 대기 시간이 약 10초에서 2초 미만으로 줄어 들었습니다. 이전에 8회 중 4회 발생했던 시작 실패는 수정 후 테스트된 5건에서 모두 제거되었습니다. 더불어, 확장 기능이 작동을 중지하기 전의 최대 유휴 시간이 22분에서 테스트된 최대 기간인 3일로 증가했습니다.\n\nChrome API의 비동기 처리를 해결하고 활성 탭을 추적하는 강력한 메커니즘을 구현함으로써 Reactime 확장의 신뢰성과 성능이 크게 향상되었습니다. 이러한 개선으로, 브라우저가 장기간 유휴 상태에 있더라도 개발자가 가로막힘 없이 작업을 수행할 수 있게 되었습니다.\n\n테스트\n\n오픈 소스 프로젝트를 유지하기 위해서는 미래 기여자가 계속해서 발전시킬 수 있도록 유지 가능해야 합니다. 소프트웨어 테스트는 결함을 감지하고 품질과 성능을 향상시키는 중요한 도구입니다. 이에 우리는 테스트의 타당성을 높이는 데 크게 투자했습니다. 결과는 65%의 테스트 통과율 증가입니다.\n\n<div class=\"content-ad\"></div>\n\n결론\n\n이미 강력한 디버깅 도구가 더 쉽게 사용할 수 있도록 개선되었으며, 새로운 기능, 시스템 개선 및 스타일 업데이트를 자랑합니다.\n\nReactime에 기여하거나 실험해 보고 싶다면 GitHub 페이지를 확인해보세요!\n\nChrome 웹 스토어에서 확장 프로그램을 시도해보세요.\n\n<div class=\"content-ad\"></div>\n\n# v25 Reactime 팀을 만나보세요:\n\n- Logan Nelsen | [GitHub](GitHub 링크) | [LinkedIn](LinkedIn 링크)\n- Haider Ali | [GitHub](GitHub 링크) | [LinkedIn](LinkedIn 링크)\n- Mel Koppens | [GitHub](GitHub 링크) | [LinkedIn](LinkedIn 링크)\n\n<div class=\"content-ad\"></div>\n\nJose Luis Sanchez | GitHub | LinkedIn\n\n저희 웹사이트를 방문하시고 GitHub에서 별표를 부탁드립니다!","ogImage":{"url":"/assets/img/2024-05-17-Reactimev25Thetimetoreactisnow_0.png"},"coverImage":"/assets/img/2024-05-17-Reactimev25Thetimetoreactisnow_0.png","tag":["Tech"],"readingTime":4},{"title":"VsCode에 React 앱을 설치하는 방법(2024년 최신)","description":"","date":"2024-05-17 20:57","slug":"2024-05-17-HowtoInstallReactAppInVsCode2024","content":"\n\nReact.js은 실시간 응용 프로그램 및 사용자 인터페이스 개발에 널리 사용되는 JavaScript 라이브러리입니다. 이는 종종 프런트엔드 JavaScript 프레임워크로 언급됩니다. Visual Studio Code (VSCode)는 가벼우면서 강력한 코드 편집기로, React.js 개발에 탁월한 지원을 제공합니다. 이 글에서는 React.js를 빠르고 주관적인 빌드 도구인 Vite와 함께 VSCode에 설정하는 과정을 안내해 드리겠습니다. 그러니, 빠르게 React 앱을 VS Code에 설치해 봅시다.\n\n![이미지](/assets/img/2024-05-17-HowtoInstallReactAppInVsCode2024_0.png)\n\n# 사전 준비 사항:\n\n설치 프로세스에 진입하기 전에, 필요한 모든 사전 요구 사항이 갖추어져 있는지 확인해 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n- Node.js 및 npm:\n\n- React.js는 Node.js와 npm (Node Package Manager)에 의존합니다. 아직 설치하지 않은 경우, nodejs.org로 이동하여 최신 버전을 다운로드하고 설치해보세요.\n\n2. Visual Studio Code:\n\n- 컴퓨터에 Visual Studio Code가 설치되어 있는지 확인해주세요. 아직 설치하지 않은 경우, code.visualstudio.com에서 운영 체제와 호환되는 최신 버전을 다운로드하고 설치하세요.\n\n<div class=\"content-ad\"></div>\n\n# 단계 1: Visual Studio Code를 실행하세요\n\nVisual Studio Code를 열면 여정이 시작됩니다. 아직 설치하지 않았다면, 지금 설치하는 것이 바로 시기입니다.\n\n# 단계 2: React 앱 만들기\n\n## 2.1 통합 터미널 열기\n\n<div class=\"content-ad\"></div>\n\n상위 메뉴로 이동하여 View - Terminal을 선택하거나 바로 가기 Ctrl +를 사용하여 Visual Studio Code 내에 통합 터미널을 열어보세요.\n\n# 2.2 새 React 앱 생성하기\n\n다음 명령을 실행하여 새 React 앱을 만들어보세요. 원하는 프로젝트 이름으로 my-react-app을 사용자 정의할 수 있습니다.\n\n```js\nnpx create-react-app my-react-app\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: 프로젝트로 이동하기\n\n다음 명령어를 사용하여 프로젝트 디렉토리로 이동하세요:\n\n```js\ncd my-react-app\n```\n\n# 단계 4: 개발 서버 실행하기\n\n<div class=\"content-ad\"></div>\n\n# 4.1 개발 서버 시작하기\n\n다음 명령어를 사용하여 개발 서버를 시작하세요:\n\n```js\nnpm start\n```\n\n이 명령어를 실행하면 React 앱이 개발 모드로 실행되며, 브라우저를 통해 http://localhost:3000/ 에서 접근할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 4.2 원활한 개발을 위한 자동 업데이트\n\nReact 코드를 조정하고 수정하는 동안 개발 서버가 자동으로 업데이트되어 원활하고 효율적인 개발 경험을 제공합니다.\n\n# 단계 5: React 앱 구조 살펴보기\n\nVisual Studio Code를 열고 프로젝트 폴더로 이동합니다. src 폴더는 소스 코드용이고 public 폴더는 정적 자산용 등 필수 폴더를 포함한 표준 React 프로젝트 구조가 여러분을 기다리고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 6: 향상된 개발을 위한 선택 도구\n\n# 6.1 React 개발자 도구 확장\n\nVisual Studio Code에서 \"React 개발자 도구\" 확장을 통합하여 개발 경험을 향상시킵니다. 이 확장은 React 애플리케이션을 디버깅하는 데 유용한 통찰력과 도구를 제공합니다.\n\n- 확장 뷰( Ctrl + Shift + X)를 열고 \"React Developer Tools\"를 검색한 후 설치를 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n# 6.2 ESLint과 Prettier를 통한 코드 품질 관리\n\n코드 일관성과 품질을 유지하기 위해 React 프로젝트에 ESLint와 Prettier를 통합하는 것을 고려해보세요.\n\n- ESLint를 전역으로 설치하세요:\n\n```js\nnpm install -g eslint\n```\n\n<div class=\"content-ad\"></div>\n\n- Visual Studio Code에 ESLint 확장 프로그램을 설치해보세요.\n- ESLint 구성 파일을 만들어보세요:\n\n```js\nnpx eslint --init\n```\n\nPrettier를 설치해보세요:\n\n```js\nnpm install --save-dev prettier\n```\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트에 .prettierrc 파일을 만들어 Prettier를 구성하세요.\n\n## 단계 7: 코딩 어드벤처 시작하기\n\n축하합니다! 이제 비주얼 스튜디오 코드에서 React.js 프로젝트를 성공적으로 설정했고, 이제 창의력을 발휘할 준비가 되었습니다. 강력한 React 컴포넌트를 구축하고, React 라이브러리의 방대한 생태계를 탐험하며, 웹 개발의 무한한 가능성에 대해 탐구해보세요.\n\n## 결론:\n\n<div class=\"content-ad\"></div>\n\n2024년이 시작되면서 React.js는 현대 웹 개발의 선두에 있습니다. React.js를 정복하면 다양한 기회의 문을 열 수 있습니다. 이 포괄적인 안내를 따르면, Visual Studio Code에 React를 설치하고도 풍부한 코딩 여정을 경험할 수 있게 될 것입니다.","ogImage":{"url":"/assets/img/2024-05-17-HowtoInstallReactAppInVsCode2024_0.png"},"coverImage":"/assets/img/2024-05-17-HowtoInstallReactAppInVsCode2024_0.png","tag":["Tech"],"readingTime":3},{"title":"React Native 페이지 최적화 방법 정리(2024년 최신)","description":"","date":"2024-05-17 20:52","slug":"2024-05-17-OptimizingaHeavyReactNativePageAGradualRewriteJourney","content":"\n\n리액트는 쉽게 시작할 수 있는 프레임워크이지만 규모 확장에는 어렵습니다. 어플리케이션이 커지면 잘못된 상태 업데이트, 뒤얽힌 렌더 로직, 비효율적인 이벤트 핸들러 생성, 비효율적인 라이브러리 사용, 그리고 불필요한 useEffect가 매우 쉽게 발생하고 어플리케이션의 렌더 성능에 심각한 영향을 미칠 수 있습니다. 이 느려짐은 React Native 어플리케이션에서 특히 더 눈에 띄며, 여기서 모든 렌더링이 강력한 웹 서버에 의해 수행되지 않기 때문입니다. 저는 현재 진행 중인 피트니스 어플리케이션의 프로필 페이지를 작성하면서 이 현상을 다시 한번 깨닫게 되었습니다.\n\n이 기사는 원래 2년 전에 작성한 프로필 페이지를 점진적으로 다시 작성하는 과정을 요약할 것입니다. 프로필 페이지로 네비게이션하면 Google Pixel 7에서 프레임이 20-40 FPS로 떨어지는 현상이 있었습니다. 최적화 이후, 어플리케이션은 86 FPS의 프레임율을 유지할 수 있었습니다. 최적화 이후 90 FPS에서 4 FPS가 떨어진 것은 사용 중인 React Navigation 1.0 라이브러리가 최적이 아니었기 때문에 불가피했습니다. 제 어플리케이션의 이 라이브러리 업그레이드는 진행 중이며, 라이브러리 업그레이드 후의 성능 향상에 대해 향후 기사에서 보고하겠습니다.\n\n끝까지 긴 여행이니 그에 맞게 준비하세요! 그러나 궁금해 하지 않으시면, 깊이 파고들기 전에 미리 작성해 둔 주요 내용을 읽어보실 수 있습니다. 또한, 본 기사는 React, React Native, 그리고 React Native Animations의 기본을 알고 있다고 가정합니다. 그럼, 더 이상 미루지 말고 출발해봅시다!\n\n# 주요 내용\n\n<div class=\"content-ad\"></div>\n\n- React 개발자로 활동하면 React Native 앱 개발에 대한 우위를 가질 수 있어요. 하지만 효율적인 React Native 앱을 만들기 위해 따르아야 할 특정한 디자인 가이드라인이 있어요. 예를 들어,\na. 좋은 예전 map 함수 대신 컴포넌트 목록을 렌더링하기 위해 FlatLists를 사용합니다.\nb. 제스처를 처리하기 위해 제스처 핸들러를 최대한 활용합니다 — 모바일 앱 개발은 클릭보다는 제스처에 집중되어 있어요.\nc. 컴포넌트를 애니메이션화하기 위해 Reanimated 라이브러리를 효율적으로 활용합니다. 다시 말해, 웹과는 다르게, 애니메이션은 앱 UX에서 더 중요한 역할을 합니다.\nd. 긴 목록의 컴포넌트를 렌더링하기 위해 항상 FlatLists를 사용합니다. 각 컴포넌트 내부의 비즈니스 로직을 최소화해야 합니다.\n- 목록을 어떻게 렌더링하든지간에, React는 목록의 모든 컴포넌트가 렌더링된 후에만 결과를 화면에 그립니다. 따라서, FlatLists를 사용하더라도 각 컴포넌트의 렌더링 시간을 최적화해야 합니다. 과도한 렌더링 로직은 막대한 화면 드랍을 초래할 수 있습니다.\n- 각 컴포넌트 내부에 무거운 렌더링 로직을 사용하는 것이 불가피할 경우, 렌더링 로직 실행을 디바운스하여 목록의 빠른 초기 로드를 보장할 수 있습니다. 제 경우, 각 목록 컴포넌트에 부담이 되는 MapView를 렌더링해야 했기 때문에 화면 드랍이 발생했어요. 해결책은 MapView를 렌더링하기 전에 의도적으로 1초의 지연을 도입하는 것이었어요. 이로써 화면 드랍 없이 초기 렌더링 시간이 빨라지게 되었고, Map은 초기 로드 후 1초 후에 렌더링되었습니다. 디바운스 중일 때 가벼운 로더를 표시해야 합니다. 사용자는 디바운스된 논리 실행 후 레이아웃 점프를 보게 되면 안 됩니다.\n- 앱 전체에서 재사용될 이미지를 미리 가져올 수 있어요. 이는 expo-image나 react-native-fast-image와 같은 라이브러리를 사용하여 수행할 수 있습니다.\n- 특히 목록 내부에 있는 컴포넌트를 메모라이즈해야 합니다.\ninitialNumToRender 속성을 사용 중이라면, FlatList는 초기 목록 컴포넌트가 렌더링된 후에 정의된 창 크기까지 전체 목록을 다시 렌더링합니다.\n예: 만약 initialNumToRender가 3이고 창 크기가 10이라면, FlatList는 다음과 같이 동작할 것입니다:\na. 처음 3개의 목록 항목을 초기로드합니다.\nb. 완료되었을 때, 첫 10개 항목을 렌더링합니다. 이미 로드된 처음 3개 항목을 다시 렌더링합니다.\n- React 상태와 Reanimated 공유 값이 혼합되지 않도록 주의해야 합니다. React 상태는 JS 스레드에서 유지되고, Reanimated 공유 값은 UI 스레드에서 유지됩니다. 항상 기억해야 할 사항은:\na. React 상태를 수정하는 것은 비용이 많이 들지만, 공유 값의 수정은 그렇지 않습니다.\nb. 공유 값 수정은 컴포넌트를 다시 렌더링하지 않습니다. 따라서 Reanimated 값 변경 시 자동으로 업데이트되지 않는다고 하더라도, Reanimated 래퍼 내에 있지 않는 React JS 변수는 컴포넌트가 업데이트되지 않습니다.\n- 마지막으로, React 상태 업데이트는 매우 비용이 많이 들 수 있음을 인지해야 합니다. Memoization은 이러한 문제를 해결하는 데 매우 유용합니다. 예를 들어, 부모에 상태 변수가 포함된 경우, 모든 자식이 부모 상태 변경 시 다시 렌더링됩니다. 이는 단순 컴포넌트에는 해로울 수 있지만, 무거운 자식 컴포넌트의 다시 렌더링은 화면 드랍을 유발할 수 있습니다. 메모라이제이션은 종속 프로퍼티 변경 시에만 다시 렌더링되도록 보정합니다.\n\n이론적인 내용이 도움이 되었기를 바라며, 지금은 비성능 페이지 수정의 풍요로운 여정을 떠나봅시다.\n\n# 프로필 페이지에 관한 내용과 마주한 문제들\n\n## 기능성 및 초기 컴포넌트 구조\n\n<div class=\"content-ad\"></div>\n\n\n![Component Structure](/assets/img/2024-05-17-OptimizingaHeavyReactNativePageAGradualRewriteJourney_0.png)\n\n프로필 페이지의 초기 구성은 위 이미지에 요약되어 있습니다. PersonalProfile은 이 페이지의 \"화면\"인 최상위 구성 요소입니다. PersonalProfile을 통해 다음 정보가 표시됩니다.\n\n- ProfileSummary 구성 요소는 다음을 표시합니다:\n  a. 프로필 사진 (Avatar라고 불리는 구성 요소를 통해)\n  b. 사용자의 이름\n  c. 사용자의 운동 횟수, 팔로워 수 및 사용자가 팔로우하는 사람 수\n\n- ProfileTabs 구성 요소에는 사용자가 최근에 완료한 운동 및 해당 사용자가 편성한 훈련 계획을 표시하는 두 개의 탭이 포함되어 있습니다.\n\n- WorkoutSnippet 구성 요소를 통해 각 운동이 요약됩니다. WorkoutSnippet은 운동 제목 (\"Saturday Night Run\"이 화면 샷에 표시됨), 캡션 (\"A good run\"이 화면 샷에 표시됨), 운동 경로를 나타내는 MapView, 운동 통계 및 운동과 상호 작용하는 몇 가지 제어가 표시됩니다.\n\n구성 요소 구조는 다음과 같이 요약될 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<PersonalProfile>\n  <ProfileSummary />\n  <ProfileTabs>\n    {...<WorkoutSnippet />}\n  </ProfileTabs>\n</PersonalProfile>\n```\n\nInitial analysis 후 많은 개선점을 발견했지만, 페이지 성능을 저해하는 주요 원인은 운동 스니펫 목록이었다고 결론지었습니다. 각 스니펫에는 비싼 MapView가 있었고, 잘못된 위치에 상태 업데이트가 발생하여 긴 목록이 다시 처음부터 렌더링되었습니다. 사용자가 페이지를 보기 전까지 React가 가상 DOM에서 전체 목록을 렌더링할 때 크게 프레임 속도가 떨어졌습니다.\n\n## 사용자 메타데이터 가져오기\n\n- 사용자 정보는 앱의 로컬 스토리지에 캐시되어 있어 같은 세션에서는 메타데이터를 다시 가져 오지 않습니다. 사용자가 프로필 페이지를 수동으로 새로 고치지 않는 한 (Instagram처럼 아래로 끌어 다시 가져오는 것), \n- 백엔드 통신은 GraphQL을 기반으로 하며, PersonalProfile 구성 요소는 Apollo의 useQuery 훅을 사용하여 메타데이터를 가져옵니다. 성공적인 검색을 통해 저장된 사용자 데이터를 업데이트해야 하므로 가져온 데이터에 대한 useEffect가 구현됩니다. 훅 값이 변경 될 때 캐시를 업데이트 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 인증 컨텍스트를 사용하여 캐시 스토리지와 상호 작용합니다.\nconst { secureUser, setUserData } =\n    useContext<AuthContextEntity>(AuthContext);\n\n// 팔로워 및 팔로잉 수를 가져오기 위한 쿼리\nconst {\n  data: followCount,\n  loading: followCountLoading,\n  error: followCountError,\n} = useQuery<{ userById: Partial<User> }>(userQueries.followCount, {\n  variables: { id: secureUser._id },\n});\n\n// 운동 수를 가져오기 위한 쿼리\nconst {\n  data: workoutCount,\n  loading: workoutCountLoading,\n  error: workoutCountError,\n} = useQuery<{ getActivityCount: number }>(\n  recentActivityQueries.activityCount,\n  {\n    variables: { userId: secureUser._id },\n  }\n);\n\nconst updateUserInCache = () => {\n  setUserData({\n    ...secureUser,\n    followCount: followCount.followCount,\n    followerCount: followCount.followerCount,\n    workoutCount,\n  });\n};\n\n// 운동 수 검색 후 캐시에 사용자 업데이트\nuseEffect(() => {\n  updateUserInCache();\n}, [workoutCount]);\n\n// 팔로워-팔로잉 수 검색 후 캐시에 사용자 업데이트\nuseEffect(() => {\n  updateUserInCache();\n}, [followCount]);\n```\n\n문제:\n이 메타데이터 가져오기는 Apollo 클라이언트 라이브러리에서 제공하는 훅에 의해 초기 렌더링 후에 발생합니다. 이 요청은 React 컨텍스트를 업데이트하므로 컨텍스트 업데이트는 루트 컴포넌트인 PersonalProfile을 다시 렌더링하게 만듭니다. 부모 컴포넌트의 다시 렌더링은 모든 하위 컴포넌트를 다시 렌더링하게 만듭니다.\n초기 로드 중 프레임 드롭의 원인은 아니지만, 이는 후속 렌더링 시간을 늘리는 원인이 되었습니다.\n해결책:\n모든 하위 컴포넌트의 메모이제이션.\n\n## 초기 코드- 탭 렌더링\n\n초기 설계에서 탭 관리 책임을 ProfileTabs 컴포넌트에 통합했습니다.\n다음과 같은 내용을 포함했습니다:\n\n<div class=\"content-ad\"></div>\n\n- 상단에 두 개의 탭이 있습니다 — 운동 및 훈련 계획.\n- 프로필 Body. 이 안에 있는 내용은 탭에 의해 관리되는 상태에 따라 다릅니다.\n\n두 탭 중 하나를 클릭하면 React 상태가 업데이트되어 Body가 다시 렌더링됩니다.\n이는 UX를 떨어뜨렸을 뿐만 아니라 두 탭 사이를 스와이프할 수 없고, 그냥 하나의 탭을 클릭해야 했으며, 본문에 포함된 전체 목록이 언마운트되어 다시 처음부터 마운트되고 활성 탭이 다시 전환되면 자신도 다시 렌더링되었습니다 — 가시적인 스터터가 발생했습니다.\n\n```js\nconst [activeTab, setActiveTab] = useState(0);\nconst handleTabPress = (index: number) => {\n  setActiveTab(index);\n};\nconst renderTabs = () => {\nreturn (\n    <>\n      <View style={styles.tabContainer}>\n        {tabs.map((tab, index) => (\n          <Touchable\n            {...tabProps}\n          >\n            {tab.icon}\n          </Touchable>\n        ))}\n      </View>\n      <View style={styles.tabBottomContainer}>\n        <TabIndicator\n          activeIndex={activeTab}\n          width={styles.tabBottom.width}\n          height={styles.tabBottom.height}\n          backgroundColor={styles.tabBottom.backgroundColor}\n          totalTabs={TAB_ARR_LENGTH}\n        />\n      </View>\n      {activeTab === 0 ? renderWorkouts() : renderTrainingPlans()}\n    </>\n  );\n}\n```\n\n## 초기 코드 — 운동 목록 렌더링\n\n<div class=\"content-ad\"></div>\n\n프레임 드랍의 뿌리는 비효율적으로 렌더링되는 고가의 구성 요소 목록입니다.\n\n```js\n<View style={styles.body}>\n  {recentWorkouts.map((workout, index) => (\n    <WorkoutSnippet\n      workout={workout}\n      key={workout.endTime}\n      {...props}\n    />\n  ))}\n</View>\n```\n\n알 수 있듯이 FlatList를 사용하지 않았으며 각 구성 요소가 비싼 MapView를 렌더링했습니다. 최적화 없이 초기에 6개의 WorkoutSnippet 및 따라서 한꺼번에 6개의 MapView가 렌더링되어 React가 거대한 프레임 드롭이 발생했습니다.\n동시에 프로필 페이지는 다음과 같은 문제를 마주해 큰 프레임 속도가 감소하게 되었습니다:\n\n<div class=\"content-ad\"></div>\n\n- 운동 목록의 초기 렌더링이 느립니다.\n- 사용자 정보를 업데이트하는 후크가 전체 페이지를 다시 렌더링하므로 이후에 발생하는 지연이 증가합니다.\n- 탭을 전환하면 본문이 다시 렌더링되어 지연을 야기합니다.\n\n아래 문제를 확인할 수 있습니다:\n\n![문제1](https://miro.medium.com/v2/resize:fit:932/1*zkDh8rVTwp3JcXvIGI_3gA.gif)\n\n![문제2](https://miro.medium.com/v2/resize:fit:632/1*zkEbgEryLuesOPbJHBejRw.gif)\n\n<div class=\"content-ad\"></div>\n\n## 프로파일러의 단점 관찰\n\n프로파일러를 읽는 방법을 모르겠다면, 이 기사를 읽기를 권장합니다. 프로파일러 데이터를 읽고 해석하는 것이 문제를 이해하고 이를 최적화하는 데 많은 역할을 했습니다.\n플레임 그래프는 가장 부담스러운 구성 요소를 확인하는 데 사용되었습니다. 이것이 어떻게해서 MapViews가 지연의 근본 원인인지 알아낼 수 있었던 이유입니다. 플레임 그래프는 또한 모든 연이은 렌더링을 나열하고 어떤 구성 요소가 다시 렌더링되었는지 강조합니다. 이것이 부담스러운 구성 요소의 불필요한 재렌더링을 알아낼 수 있는 방법이었습니다.\n\n프로파일러의 플레임 그래프를 읽은 결과는 다음과 같습니다:\n\n- 프로파일 화면의 초기 렌더링에는  list가 135ms 소요되어 총 200ms가 걸렸습니다.\n- 사용자 메타데이터를 가져오면 앞서 설명한대로 콘텍스트 개체가 업데이트되어 전체 화면이 다시 렌더링됩니다. 이 재렌더링은 122ms가 걸렸습니다.\n- 탭을 탐색하면 상태가 업데이트되어 탭 및 본문 전체가 다시 렌더링되며 렌더링 시간은 190ms였습니다.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요!\n\n# 최적화\n\n## ScrollView를 FlatList로 대체하기\n\nFlatList는 React Native에서 제공하는 가상 리스트로, 대규모 리스트의 성능을 향상시키고 메모리 소비를 줄입니다. 이는 활성 항목들의 유한한 렌더 창을 유지함으로써 달성됩니다. 이 렌더 창 밖에 있는 항목들은 공백 뷰로 대체되어 전체 리스트의 성능을 향상시킵니다. 렌더 성능을 최적화하기 위해 여러 프롭스가 제공되며, 개발자는 렌더 창을 미세 조정할 수 있습니다. 리스트의 초기 렌더링에 문제가 있었기 때문에 initialNumToRender 프롭이 관련이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n따라서 ScrollView 안에있던 맵을 FlatList로 전환하여 운동 목록을 렌더링했습니다:\n\n```js\nconst renderItem: ListRenderItem<Workout> = useCallback(\n  (workout: ListRenderItemInfo<Workout>) => {\n    return (\n      <WorkoutSnippet\n        workout={workout.item}\n        {...otherProps}\n      />\n    );\n  },\n  []\n);\nreturn (\n  <FlatList\n    data={workouts}\n    renderItem={renderItem}\n    keyExtractor={(item) => item._id}\n    initialNumToRender={3}\n    {...otherProps}\n  />\n);\n```\n\n아래에 몇 가지 주요 관찰 사항이 나와 있어요. 주의 깊게 읽어 주세요:\n\n- initialNumToRender 속성을 3으로 설정하여 가상 목록이 초기 렌더링 시 처음 3개 요소만 렌더링되도록 했어요.\n그러나 초기 렌더링이 완료되면, 가상 목록이 창 크기 내의 모든 항목을 렌더링합니다 (기본적으로 10 뷰포트 단위에 해당하는).\n재랜더링 시 초기에 렌더링된 구성 요소를 무시하지 않아요. 창 크기 내 목록의 모든 항목이 다시 렌더링됩니다.\n예: 창 크기 내에 10개 항목이 있고, 초기 렌더링할 항목 수가 3개이면 목록은 다음과 같이 되겠죠:\ni. 초기 렌더링 시 3개 항목을 렌더링합니다.\nii. 다음 렌더링 시 (이미 렌더링된 초기 항목 포함) 모든 10개 항목을 렌더링합니다.\n따라서, 가상 목록에서 재랜더링을 방지하기 위해 렌더링되는 구성 요소를 메모이즈하는 것이 중요합니다.\n목록에서 렌더링되는 구성 요소를 메모이즈하면 초기 항목이 다시 불필요하게 렌더링되는 것을 방지할 수 있어요.\n- renderItem 속성에 전달된 함수는 FlatList의 렌더링 로직을 정의합니다.\n이것을 참조로 전달하고, useCallback 훅 내부에 래핑되었는지 확인하는 것이 중요합니다.\n이를 하지 않으면 FlatList 부모의 재랜더링마다 함수가 재정의되어 목록의 중복 재랜더링을 일으킬 수 있어요. 그것은 매우 비용이 많이들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n이 최적화를 고려한 후에 성능을 확인해봅시다:\n\n![GIF](https://miro.medium.com/v2/resize:fit:1224/1*eMhn-98QVNHKvJh4T-ILnQ.gif)\n\n관찰할 수 있듯이, 여전히 일시적인 끊김이 있습니다! 3개의 컴포넌트를 동시에 렌더링해도, MapView는 여전히 핸드폰이 작은 시간프레임 내에서 렌더링하기에 너무 많은 부하를 줍니다.\n\n## MapViews의 지연 로딩\n\n<div class=\"content-ad\"></div>\n\n해결책은 MapViews를 Lazy Load하는 것이었습니다. 이 방법은 다음과 같이 작동했습니다:\n\n- 각 목록 항목에 고정 높이 MapView가 있습니다.\n- MapView의 로딩을 일부러 1초 지연합니다.\n- 해당 시간까지 MapView 자리에 스켈레톤 로더를 표시합니다.\n\n마운트 시에 useEffect 내에서 timeout을 놓는 것으로 구현하였습니다.\n리스트 컴포넌트 내에 상태를 배치합니다:\n\n```js\nconst [mapLoaded, setMapLoaded] = useState(false);\n```\n\n<div class=\"content-ad\"></div>\n\n리스트 컴포넌트 내에 useEffect를 정의하세요:\n\n```js\nuseEffect(() => {\n  setTimeout(() => {\n    setMapLoaded(true);\n  }, 1000);\n}, []);\n```\n\nMapView 렌더링 로직:\n\n```js\nif (!mapLoaded) {\n  return (\n    <ActivityIndicator />\n  );\n}\nreturn (\n  <MapView {...props} />\n);\n```\n\n<div class=\"content-ad\"></div>\n\n최종 최적화:\n\n지도를 이렇게 로드하는 것은 mapLoaded = false에서 mapLoaded = true로 상태가 업데이트되는 동안 UI를 차단합니다. 예를 들어, 이 상태가 업데이트되는 동안 탭을 전환하려고 하면 지연이 발생할 수 있습니다. 여기서 React의 새로운 비동기 아키텍처가 문제를 해결해 줍니다 - useTransition 훅을 사용하여 비동기 상태 업데이트를 실행함으로써 차단된 UI 요소는 더 이상 문제가 되지 않습니다. 더 자세한 내용은 여기를 참조하세요.\n따라서 우리는 이 상태 업데이트를 전환 내부로 감싸줍니다:\n\n```js\nuseEffect(() => {\n  setTimeout(() => {\n    startTransition(() => {\n      setMapLoaded(true);\n    });\n  }, 1000);\n}, []);\n```\n\n마지막으로, 여기가 결과입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:808/1*lXJIEkRu_pn9vl7VH5loag.gif)\n\nThe drop during mount is now down to 82 FPS from a previously unreliable 20–40 FPS! There is an inevitable drop when the MapViews load in eventually after 1 second, but the UI remains responsive throughout!\n\nAs for the profiler results, the render time of the screen dropped to 120ms, with the list itself taking 90ms.\nThat’s an improvement by a third of the original render time!\n\n## Fixing Tab Switching Logic — Making the Tabs Swipe-able\n\n\n<div class=\"content-ad\"></div>\n\n이전에는 탭을 클릭할 수만 있고 스와이프할 수는 없었습니다. 탭을 전환할 때마다 본문이 다시 렌더링되어 부드럽지 않은 화면 전환이 발생했죠. 이 문제를 해결하기 위해 본문을 수평으로 렌더링하는 FlatList로 변경할 것입니다. 이렇게하면 재렌더링으로 인한 문제 해결뿐 아니라 (FlatList는 상태에 관계없이 두 번째 탭을 게으르게 렌더링합니다), 사용자 경험을 더 좋게 만들어 프로필 페이지를 더 쉽게 탐색할 수 있습니다.\n\n참고: 이 하위 섹션은 최적화보다는 UI 디자인 구현에 가깝습니다. 이 섹션은 읽지 않고 결과만 보셔도 됩니다.\n\n다음은 새로운 레이아웃입니다:\n\n![이미지](/assets/img/2024-05-17-OptimizingaHeavyReactNativePageAGradualRewriteJourney_1.png)\n\n<div class=\"content-ad\"></div>\n\n최종 결과물:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:504/1*Drzw-Y4UMkDy09OwlS2v2Q.gif\" />\n\n정말 부드러운 모션인데요!\n\n사용자가 수평으로 스와이프할 때 무슨 일이 벌어지는지 자세히 살펴봅시다:\n\n<div class=\"content-ad\"></div>\n\n- 사용자가 탭의 너비의 약 50%로 스크롤 할 때 활성 탭 아이콘이 \"점등\"합니다.\n- 활성 탭을 나타내는 하얀색 하단 테두리가 사용자의 수평 스크롤에 따라 이동합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:712/1*bfGvqGl9Z1vbTZ9QQgHUHw.gif)\n\n3. 탭을 클릭하면 본문이 100% 스크롤되어 다음 요소로 이동합니다. 탭 표시기도 함께 이동합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:956/1*kXqvHtGO3Avsa_jBwGsgjA.gif)\n\n<div class=\"content-ad\"></div>\n\n## 고정 탭 구현하기\n\n이것은 매우 간단합니다. React Native의 FlatList 컴포넌트가 제공하는 stickyHeaderIndices 속성은 수직 목록에서 작동하며 지정된 인덱스의 구성요소를 스크롤할 때 상단에 고정시킵니다. 다음은 프로필 화면 내에 정의된 최상위 FlatList의 코드입니다:\n\n```js\nconst flatListData = useMemo(\n  () => [renderProfileSummary, renderTabs, renderBody],\n  [renderProfileSummary, renderTabs, renderBody]\n);\nconst renderItem: ListRenderItem<() => JSX.Element> = useCallback(\n  (item) => item.item(),\n  []\n);\nconst stickyIndices = useMemo(() => [1], []);\n\n<FlatList\n  data={flatListData}\n  renderItem={renderItem}\n  stickyHeaderIndices={stickyIndices}\n  {...otherProps}\n/>\n```\n\nFlatList로 전달된 모든 데이터가 메모화된 것에 주목하세요. 이는 프로필 화면의 재렌더링 시 props의 재정의를 방지해야 하기 때문입니다 (React는 객체에 대한 참조 무결성을 확인합니다. 객체를 메모화하면 렌더링 간 참조 무결성을 유지하는 데 도움이 됩니다). 기억하세요 - props의 변경은 전체 목록을 다시 렌더링하게 만들며, 우리는 그것을 방지하려고 합니다.\n\n<div class=\"content-ad\"></div>\n\n- ProfileSummary(프로필 요약 렌더링), Tabs(탭 렌더링), 및 body(본문 렌더링) 함수들은 데이터로 FlatList에 전달됩니다. renderItem 함수는 이러한 함수들을 간단히 실행합니다.\n- stickyHeaderIndices가 [1]로 정의되어 있습니다. 이는 우리가 탭들(데이터 배열의 첫 번째 위치에 정의된)을 스크롤하여 지나갈 때에 고정시킵니다.\n\n## 동적으로 하단 테두리 효과 구현하기\n\n이 부분은 다소 까다로운 부분입니다. 이 효과를 달성하기 위해 Reanimated 라이브러리의 공유 값(shared values)을 활용했습니다. 만약 이 라이브러리에 익숙하지 않다면, 그 뛰어난 문서를 읽어보는 것을 권합니다.\n\n한 발 물러서서, 가로 스크롤 뷰에 대해 다음을 관찰합니다:\n\n<div class=\"content-ad\"></div>\n\n- 각 탭은 화면 너비와 같은 너비를 갖습니다 (100vw).\n- 따라서, 수평 스크롤 뷰의 총 너비는 nTabs * 100vw 입니다. 이것은 우리의 공유 값의 범위가 됩니다:\n[스크롤 없음, 모든 탭 스크롤됨] = [0, nTabs * 100vw]\n다시 말해, 애니메이션 값은 사용자가 수평으로 스크롤한 픽셀량을 단순히 추적할 것입니다.\n\n수평 FlatList가 스크롤되면, 이 애니메이션의 값을 조정하여 단순히 사용자가 스크롤한 현재 오프셋 (픽셀 수)이어야 합니다. FlatList의 onScroll 프로퍼티를 사용하면 아주 쉽게 이를 달성할 수 있습니다:\n\n```js\nconst onBodyScroll = useCallback(\n  (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n    const { nativeEvent } = event;\n    const { contentOffset } = nativeEvent;\n    const { x } = contentOffset;\n    swipeAnimationValue.value = x;\n  },\n  [swipeAnimationValue]\n);\n``` \n\n마지막으로, 탭 인디케이터의 스타일을 다음과 같이 설정하겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst indicatorStyle = useAnimatedStyle(() => ({\n  position: \"absolute\",\n  bottom: 0,\n  left: 0,\n  width: vw(100 / nTabs),\n  transform: [\n    {\n      translateX: interpolate(animatedValue.value, [0, nTabs * vw(100)], [\n        0,\n        nTabs * vw(100 / nTabs),\n      ]),\n    },\n  ],\n}));\n```\n\ninterpolare 함수는 애니메이션 값과 스타일 속성 값의 매핑을 담당합니다.\n\n- 인디케이터의 너비는 100 % / nTabs (우리 예에서 50vw)와 같아야 합니다.\n- 인디케이터는 왼쪽 하단에 절대 위치로 배치됩니다.\n- 스크롤이 없는 경우에는 어떤 이동도 필요하지 않습니다. 목록이 완전히 스크롤되었을 때 (마지막 요소조차 완전히 스크롤된 경우), 인디케이터는 nTabs * vw(100 / nTabs)만큼 이동해야 합니다.\nReanimated 라이브러리가 이들 극단값 사이의 중간 값들을 처리해줄 것입니다.\n\n아래에 시각화가 제공되었습니다: \n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-17-OptimizingaHeavyReactNativePageAGradualRewriteJourney_2.png)\n\nThis wraps up our translation effect!\n\n## Achieving Dynamic Tab Icon Color\n\nObserve carefully when the color of the tab icon changes:\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1100/1*S9kq4JSTm65UgmYbbv_Cpg.gif)\n\n사용자가 탭 본문의 50% 이상으로 스크롤했을 때 탭 색상이 변경됩니다. 새로운 색상으로 유지되는 기간은 얼마인가요? 사용자가 탭 본문의 50% 이상 스크롤하지 않는 한 계속해서 색상이 유지됩니다.\n우리의 animatedValue가 저장하고 있는 것을 기억하세요: 그렇습니다, 수평 FlatList의 스크롤 오프셋을 저장하고 있습니다!\n우리는 Reanimated 라이브러리에서 제공되는 interpolateColor 함수를 사용하여 탭의 색상을 보간할 수 있습니다!\n스크롤 오프셋을 탭 아이콘의 색상으로 매핑하는 보간 함수를 구성해야 합니다.\n\n각 탭에는 인덱스가 있습니다. 여기서 두 탭의 인덱스는 각각 0과 1입니다.\n\n여기 우리의 수평 탭 본문 목록이 펼쳐진 모습입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-05-17-OptimizingaHeavyReactNativePageAGradualRewriteJourney_3.png\" />\n\n그러므로, animatedValue의 최대 가능한 값은 얼마라고 생각하시나요?\n200vw를 추측했다면, 정답입니다. 이는 사용자가 두 번째 탭 (Tab 1)을 넘어간 경우, 즉 뷰포트에 탭이 전혀 표시되지 않는 경우입니다.\n여기에 마지막으로, 각 탭이 시작하는 오프셋을 기록합니다:\n\n- Tab 0는 오프셋 0에서 시작합니다.\n- Tab 1은 Tab 0 이후 100vw에서 시작합니다.\n\n여기 사용자가 초기에 화면에서 볼 수 있는 것입니다:\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-17-OptimizingaHeavyReactNativePageAGradualRewriteJourney_4.png\" />\n\n여기서,\n\n- 스크롤 오프셋은 0입니다 (스크롤이 발생하지 않았으므로, animatedValue는 0입니다.)\n- 탭 0은 활성화된 색 (흰색)을 가지고 있고, 탭 1은 비활성화된 색 (회색)을 가지고 있습니다.\n\n자, 이제 활성 탭이 변경될 때 스크롤의 정확한 상태를 확인해 봅시다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-17-OptimizingaHeavyReactNativePageAGradualRewriteJourney_5.png\" />\n\n여기서,\n\n- 스크롤 오프셋은 50vw입니다(탭의 반쪽이 사용자에 의해 스크롤되어 지나갔기 때문에), 그래서 우리의 애니메이션 값은 50vw입니다.\n- 탭 0은 비활성화되었고(회색), 탭 1은 활성화되었습니다(흰색).\n\n이전에 언급한 것처럼, 탭 0의 스크롤 오프셋은 0에서 시작하고, 탭 1의 스크롤 오프셋은 100vw에서 시작합니다. 추론하면, 삽입된 탭 2는 200vw에서 시작할 것이며, 이와 같은 식으로 계속됩니다.\n\n<div class=\"content-ad\"></div>\n\n애니메이션을 완성하려면 이 최종 질문에 답해야 합니다:\n\n답변:\n사용자가 (i — 0.5) * x로 스크롤할 때(시작 오프셋 — 탭 너비의 50%라면) 탭을 활성화합니다.\n사용자가 (i + 0.5) * x로 스크롤할 때(시작 오프셋 + 탭 너비의 50%라면) 탭을 비활성화합니다.\n우리 예시에서 이를 설명하면,\n- 탭 0은 현재 스크롤 오프셋이 (0–0.5) * 100vw와 (0+0.5) * 100vw, 즉 -50vw와 50vw 사이일 때 활성화됩니다.\n- 탭 1은 현재 스크롤 오프셋이 (1 - 0.5) * 100vw와 (1 + 0.5) * 100vw, 즉 50vw와 150vw 사이일 때 활성화됩니다.\n\n마침내 보간된 아이콘 스타일이 준비되었습니다:\n\n```js\nconst iconStyle = useAnimatedStyle(() => ({\n  color: interpolateColor(\n    animatedValue.value,\n    [\n      (idx - 0.5) * animOffset - 1,\n      (idx - 0.5) * animOffset,\n      (idx + 0.5) * animOffset,\n      (idx + 0.5) * animOffset + 1,\n    ],\n    [inactiveTabColor, activeTabColor, activeTabColor, inactiveTabColor],\n  ),\n}));\n```\n\n<div class=\"content-ad\"></div>\n\n만개의 프롭 객체가 전부 useMemo를 사용해 메모이제이션했고, 화면의 모든 자식 컴포넌트를 React.memo를 사용해 메모이즈드 컴포넌트로 만들었어요.\n\n## 최적의 라이브러리 사용과 아이콘 폰트 미리 불러오기\n\n<div class=\"content-ad\"></div>\n\n이미지 및 글꼴을 렌더링할 때 추가 밀리초를 저장하기 위한 마지막 단계였습니다. React Native 문서 자체에서는 기본 `Image /` 컴포넌트 대신 전용 이미지 라이브러리를 사용하는 것을 제안합니다. expo-image 라이브러리는 잘 유지되며 이미지를 캐시하는 옵션을 제공합니다.\n\n정적 데이터를 가져오는 최적화를 위해 앱을 로드할 때 모든 아이콘 및 텍스트 글꼴을 미리 가져오기 위해 expo-font 패키지를 사용했습니다:\n\n```js\nconst [fontsLoaded] = useFonts({\n  // 텍스트 글꼴\n  Oswald: require(\"fitnet/assets/textFonts/Oswald.ttf\"),\n  Raleway: require(\"./src/assets/textFonts/Raleway.ttf\"),\n  \"Raleway-Bold\": require(\"./src/assets/textFonts/Raleway-Bold.ttf\"),\n  // 아이콘 글꼴\n  NavBarIcons: require(\"fitnet/assets/iconFonts/NavBarIcons.ttf\"),\n  HomeIcons: require(\"fitnet/assets/iconFonts/HomeIcons.ttf\"),\n  ...AntDesign.font,\n  ...createIconSetFromIcoMoon.font,\n  ...EvilIcons.font,\n  ...FontAwesome.font,\n  ...FontAwesome5.font,\n  ...MaterialCommunityIcons.font,\n  ...MaterialIcons.font,\n});\n```\n\nexpo-image 라이브러리를 사용하여 사용자의 프로필 사진을 로그인할 때 캐시하고 앱 전체에 걸쳐 프로필 사진을 반복 다운로드하는 것을 방지했습니다. 이는 로그아웃 시에 지워졌습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nconst signIn = (user) => {\n  if (user.displayPicture) {\n    Image.prefetch(user.displayPicture, \"memory\");\n  }\n  setUserData(user);\n};\n...\nconst signOut = async () => {\n  await unsetUserData();\n  await clearAsyncStorage();\n  await Image.clearMemoryCache();\n  await Image.clearDiskCache();\n}\n```\n\n# 결론\n\n긴 여정이었습니다! React Native 애플리케이션을 최적으로 설계하는 데 어떤 통찰력을 얻었으면 좋겠어요. 메모이제이션, 적절한 네이티브 컴포넌트 사용, 캐싱 그리고 값 비싼 로직을 신중하게 배치하는 것은 앱을 최적화하는 데 큰 역할을 합니다. 이러한 전략을 사용하여 렌더링 시간을 200ms에서 110ms로 줄일 수 있었어요. 탭을 재설계하고 reanimated 라이브러리를 활용하며 값 비싼 상태 업데이트를 피함으로써 추후의 느림 현상을 완전히 제거할 수 있었어요! 프로파일러는 앱 성능의 병목 지점을 관찰하는 데 훌륭한 도구에요. 다음 번엔 또 뵙겠습니다!\n\n# 관련 기사\n\n\n<div class=\"content-ad\"></div>\n\n# 테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n리액트 네이티브에서 대량의 UI 항목을 최적으로 로드하는 방법에 대한 제안 목록입니다.","ogImage":{"url":"/assets/img/2024-05-17-OptimizingaHeavyReactNativePageAGradualRewriteJourney_0.png"},"coverImage":"/assets/img/2024-05-17-OptimizingaHeavyReactNativePageAGradualRewriteJourney_0.png","tag":["Tech"],"readingTime":20},{"title":"Vite, Nginx 및 런타임에서 정적 웹 사이트용 환경 변수 적용하는 방법","description":"","date":"2024-05-17 20:51","slug":"2024-05-17-ViteNginxandenvironmentvariablesforastaticwebsiteatruntime","content":"\n<img src=\"/assets/img/2024-05-17-ViteNginxandenvironmentvariablesforastaticwebsiteatruntime_0.png\" />\n\n안녕하세요 여러분! 저는 Quadcode의 프런트엔드 개발자 Dmitry Pashkevich입니다. 오늘은 Vite 빌드 도구와 Nginx 웹 서버를 이용하여 정적 웹사이트에 런타임 환경 변수를 전달하는 방법을 공유하려고 합니다.\n\n프런트엔드 개발에서 흔한 작업은 애플리케이션에 환경 변수를 전달하는 것입니다. 애플리케이션이 실행되는 환경에 따라 다르게 동작하도록 환경 변수를 설정하는 작업이죠. 간단한 작업으로 보이지만 이를 문서에 설명된 대로 처리하려면 .env 파일을 옆에 두고 빌드를 실행해야 합니다... 각 환경에서 말이죠.\n\n솔루션을 찾은 것 같습니다. 그러나 이로 인해 각 환경마다 다른 빌드 프로세스와 이에 따른 다른 결과로 이어집니다.\n\n<div class=\"content-ad\"></div>\n\n실무에서 빌드 단계의 기능에 문제가 발생하는 경우가 종종 있습니다. 예를 들어 변경 사항을 적용할 때 한 환경을 위해 설정, 스크립트 등을 업데이트하는 것을 잊을 때가 있습니다. 결과적으로, 아티팩트도 다르기 때문에 애플리케이션 자체에 문제가 발생합니다.\n\n그러므로 모든 환경에 대해 하나의 빌드 아티팩트를 얻고 환경 변수 값을 전달할 수 있는 것이 더 나을 것으로 보입니다. 따라서 변수 값이 정확한 한 가지 문제를 해결하는 것이 빌드 단계를 조사하는 것보다 더 쉽습니다.\n\n그럼 이를 Vite와 Nginx 도구를 사용한 예제로 어떻게 수행할 수 있는지 살펴봅시다.\n\n# 저장소 준비\n\n<div class=\"content-ad\"></div>\n\n먼저 React + Typescript용 Vite 빌더에서 제공하는 템플릿을 사용하여 프로젝트를 생성해보겠습니다.\n\n```js\nnpm create vite@latest vite-nginx-dynamic-env-variables-example --\n--template react-ts && cd vite-nginx-dynamic-env-variables-example && npm\ninstal\n```\n\n# 프로젝트 구성 준비\n\n위 명령어를 성공적으로 실행한 후, 새로 생성된 프로젝트를 좋아하는 IDE에서 열고 목표 솔루션을 만들기 시작해봅시다.\n\n<div class=\"content-ad\"></div>\n\n파일 src/vite-env.d.ts를 수정해보세요. IDE 힌팅을 활성화하기 위해 사용 가능한 환경 변수 유형에 대한 설명을 추가할 거에요.\n\n```js\n/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n    readonly VITE_VERSION: string\n}\n\ninterface ImportMeta {\n    readonly env: ImportMetaEnv\n}\n```\n\n이제 IDE가 사용 가능한 환경 변수에 대한 힌트를 제공할 거예요.\n\n다음으로, 환경 변수 템플릿이 들어 있는 파일을 생성해볼게요: src/shared/projectEnvVariables.ts. 그리고 아래 내용을 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\ntype ProjectEnvVariablesType = Pick<ImportMetaEnv, \"VITE_VERSION\">;\n\n// 환경 변수 템플릿 런타임에 대체되도록\nconst projectEnvVariables: ProjectEnvVariablesType = {\n  VITE_VERSION: \"${VITE_VERSION}\",\n};\n\n// 런타임에서 변수 값을 반환하거나 빌드 결과로 얻음\nexport const getProjectEnvVariables = (): {\n  envVariables: ProjectEnvVariablesType,\n} => {\n  return {\n    envVariables: {\n      VITE_VERSION: !projectEnvVariables.VITE_VERSION.includes(\"VITE_\")\n        ? projectEnvVariables.VITE_VERSION\n        : import.meta.env.VITE_VERSION,\n    },\n  };\n};\n```\n\n그 다음, 위의 파일이 빌드 단계 후 예측 가능한 이름을 갖도록 빌드 구성을 vite.config.ts에 변경해야 합니다. 이를 위해 구성에 rollup을 위한 섹션을 추가해주세요.\n\n```js\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n   plugins: [react()],\n   build: {\n       rollupOptions: {\n           output: {\n               format: 'es',\n               globals: {\n                   react: 'React',\n                   'react-dom': 'ReactDOM',\n               },\n               manualChunks(id) {\n                   if (/projectEnvVariables.ts/.test(id)) {\n                       return 'projectEnvVariables'\n                   }\n               },\n           },\n       }\n   }\n}\n```\n\nmanualChunks 섹션에서 사용자 정의 청크를 생성하고, 파일을 빌드한 후 이 파일을 환경 변수로 대체할 수 있도록 일부 이름을 저장합니다.\n\n<div class=\"content-ad\"></div>\n\nsrc/App.tsx 파일을 수정하여 환경 변수의 값들을 확인해봅시다.\n\n```js\nimport { getProjectEnvVariables } from \"./shared/projectEnvVariables.ts\";\n\nconst { envVariables } = getProjectEnvVariables();\n\nfunction App() {\n  return (\n    <>\n      <h1>VITE_VERSION</h1>\n      <div>{envVariables.VITE_VERSION}</div>\n\n      <hr />\n\n      <h2>import.meta.env.VITE_VERSION</h2>\n      <div>{import.meta.env.VITE_VERSION}</div>\n    </>\n  );\n}\n\nexport default App;\n```\n\n다음으로, 빌드를 실행하여 빌드 단계 이후에 변수를 대체하는 데 필요한 청크를 얻었는지 확인해봅시다.\n\n```js\nnpm run build\n```\n\n<div class=\"content-ad\"></div>\n\n빌드가 완료되면 dist/assets 디렉토리로 이동하세요. 이전에 구성한 projectEnvVariables\\*이라는 청크가 존재하는 것을 확인할 수 있을 겁니다.\n\n![이미지](/assets/img/2024-05-17-ViteNginxandenvironmentvariablesforastaticwebsiteatruntime_1.png)\n\n이제 연이어 실험을 진행해보겠습니다.\n\n원하는 빌드 결과를 얻는 데 쉽게 이해할 수 있도록, 각 빌드는 지정된 환경 변수로 수행될 것입니다. 이를 통해 getProjectEnvVariables 함수에서 환경 변수의 값을 반환하는 조건을 시각적으로 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n첫 번째 실험을 위해 프로젝트 루트에 다음 내용을 포함한 .env 파일을 생성해주세요.\n\n```js\nVITE_VERSION = dev;\n```\n\n프로젝트 빌드를 시작하고 빌드 결과를 확인하는 모드로 전환해봅시다.\n\n```js\nnpm run build && npm run preview\n```\n\n<div class=\"content-ad\"></div>\n\nhttp://localhost:4173/로 이동하면 구성에서 직접 환경 변수로부터 읽은 변수의 두 개의 동일한 값이 표시됩니다.\n\n![image](/assets/img/2024-05-17-ViteNginxandenvironmentvariablesforastaticwebsiteatruntime_2.png)\n\n두 번째 실험에서는 애플리케이션을 빌드한 후 생성된 dist/assets/projectEnvVariables-wa84hTgi.js 파일에서 변수를 변경해보겠습니다. 이 파일에서 $'VITE_VERSION' 값이 들어있는 줄을 dev_from_env로 바꿔주세요. 브라우저에서 페이지를 새로고침하면 구성 getProjectEnvVariables에서 읽은 화면의 변수가 업데이트된 버전으로 표시됩니다.\n\n![image](/assets/img/2024-05-17-ViteNginxandenvironmentvariablesforastaticwebsiteatruntime_3.png)\n\n<div class=\"content-ad\"></div>\n\n모든 것이 예상대로 작동합니다! 이제 변수 대체를 자동화할 차례입니다.\n\n# 도커 + Nginx 환경 설정 준비\n\nDocker 컨테이너를 사용하여 Nginx 웹 서버를 실행하기 전에 초기화 스크립트를 실행하고 envsubst를 사용하여 환경 변수를 대체하는 변수 대체의 자동화를 보여 드리겠습니다.\n\n프로젝트 루트에 .docker 디렉토리를 만들어 Nginx 웹 서버를 위한 구성 내용을 넣어주시면 됩니다. Nginx 구성의 완전한 예시는 저장소에 있으며, 아래는 .docker/app/nginx/init-scripts/100-init-project-env-variables.sh 파일의 bash 코드입니다. 이 코드는 환경 변수를 대체합니다.\n\n<div class=\"content-ad\"></div>\n\n```sh\n#!/usr/bin/env sh\n\nset -ex\n\n#환경 변수를 치환해야 하는 파일을 찾습니다.\nprojectEnvVariables=$(ls -t /usr/share/nginx/html/assets/projectEnvVariables*.js | head -n1)\n\n#환경 변수를 치환합니다.\nenvsubst < \"$projectEnvVariables\" > ./projectEnvVariables_temp\ncp ./projectEnvVariables_temp \"$projectEnvVariables\"\nrm ./projectEnvVariables_temp\n```\n\n이후에, 프로젝트 루트에서 다음 내용을 가진 Dockerfile을 생성하세요. 이 Dockerfile은 애플리케이션을 빌드하고 정적 파일을 제공하기 위해 Nginx 웹 서버를 실행하는 내용을 설명합니다.\n\n```js\nFROM node:20-alpine as builder\n\nWORKDIR /app\n\nCOPY package.json package-lock.json ./\n\nRUN npm ci\n\nCOPY . .\n\nARG NODE_ENV=production\nENV NODE_ENV=${NODE_ENV}\n\nRUN npm run build\n\nFROM nginx:alpine\n\nARG VITE_VERSION=dev\nENV VITE_VERSION=${VITE_VERSION}\n\nARG PORT=80\nENV NGINX_PORT=${PORT}\nENV NGINX_HOST=localhost\n\nEXPOSE ${PORT}\n\nCOPY .docker/app/nginx/nginx.conf /etc/nginx/nginx.conf\nCOPY .docker/app/nginx/conf.d/ /etc/nginx/conf.d/\nCOPY .docker/app/entrypoint.sh /entrypoint.sh\nCOPY .docker/app/nginx/init-scripts/ /docker-entrypoint.d/\n\nWORKDIR /usr/share/nginx/html\n\nCOPY --from=builder /app/dist ./\n```\n\n이제 컨테이너를 빌드해봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\ndocker build -t\nvite-nginx-dynamic-env-variables-example .\n```\n\n다음으로, 응용 프로그램에서 사용할 환경 변수에 대한 새로운 값을 가진 작성된 컨테이너를 실행해 봅시다.\n\n```js\ndocker run -p 81:80 -e VITE_VERSION=FROM_NGINX\nvite-nginx-dynamic-env-variables-example\n```\n\nhttp://127.0.0.1:81 으로 이동하여, 환경 변수가 현재 값으로 초기화되었음을 확인할 수 있습니다. 직접 읽은 환경 변수는 여전히 이전 값으로 남아 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-17-ViteNginxandenvironmentvariablesforastaticwebsiteatruntime_4.png\" />\n\n# 결론\n\n이렇게 하면 실행 중에 환경 변수를 정적으로 빌드된 애플리케이션에 대체하여 모든 환경에서 통합 빌드가 가능합니다.\n\n코드는 저장소에서 찾을 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-17-ViteNginxandenvironmentvariablesforastaticwebsiteatruntime_0.png"},"coverImage":"/assets/img/2024-05-17-ViteNginxandenvironmentvariablesforastaticwebsiteatruntime_0.png","tag":["Tech"],"readingTime":7},{"title":"대형 언어 모델LLM을 활용한 웹 어플리케이션 만드는 방법","description":"","date":"2024-05-17 20:49","slug":"2024-05-17-BuildingaWebApplicationPoweredbyLargeLanguageModelsLLMpart2","content":"\n\n<img src=\"/assets/img/2024-05-17-BuildingaWebApplicationPoweredbyLargeLanguageModelsLLMpart2_0.png\" />\n\n이전 글인 Building a Web Application Powered by Large Language Models (LLM): part 1에서는 ASP.NET Core API를 사용하여 CV 리뷰어 애플리케이션을 위한 견고한 백엔드를 개발했습니다. 웹 스크래핑을 위해 Azure Function을 활용하고 GPT 모델을 통합하여 이력서를 채용 공고와 관련하여 분석했습니다. 이번 글에서는 React 템플릿과 TypeScript를 사용하여 애플리케이션의 프론트엔드를 구축하는 데 초점을 맞출 것입니다. Bootstrap을 사용하여 애플리케이션을 스타일링하여 반응형이며 사용자 친화적인 인터페이스를 제공할 것입니다.\n\n# 요구 사항\n\n- Node.js와 npm이 컴퓨터에 설치되어 있어야 합니다.\n- React 및 TypeScript의 기본적인 이해가 필요합니다.\n- Bootstrap 스타일링에 대한 이해가 있으면 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# React 프로젝트 설정하기\n\nVite를 사용하여 React 프로젝트 초기화: Vite는 React 애플리케이션을 위한 빠르고 최적화된 설정을 제공합니다. TypeScript 템플릿을 이용하여 Vite로 새로운 React 프로젝트를 생성하세요.\n\n```js\nnpm create vite@latest cv.reviewer.frontend -- --template react-ts\ncd cv.reviewer.frontend\n```\n\nBootstrap 설치하기: 프로젝트에 스타일링을 위해 Bootstrap을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install bootstrap@5.3.0\nnpm install @types/bootstrap\n```\n\n프로젝트 구조: 프로젝트를 컴포넌트, 서비스 및 스타일 폴더로 구성하여 관리를 더욱 편리하게 합니다.\n\n# 부트스트랩 및 전역 스타일 설정\n\nmain.tsx에 부트스트랩을 가져오세요: 메인 엔트리 파일에 부트스트랩 CSS를 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './styles/global.css';\n\nReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n글로벌 스타일: styles 폴더에 global.css 파일을 만들어 추가적인 글로벌 스타일을 적용하세요.\n\n```js\nbody {\n  background-color: #f8f9fa;\n}\n```\n\n# 주요 컴포넌트 구축하기\n\n\n<div class=\"content-ad\"></div>\n\nFormComponent.tsx를 만들어보세요: 이 컴포넌트는 파일 업로드와 작업 URL 입력을 처리할 겁니다.\n\n```js\nimport React, { useState } from \"react\";\nimport apiClient from \"../services/apiClient\";\n\nconst FormComponent: React.FC = () => {\n  const [jobUrl, setJobUrl] = useState(\"\");\n  const [cvFile, setCvFile] = useState<File | null>(null);\n  const [review, setReview] = useState<string | null>(null);\n  const [adSource, setAdSource] = useState<string | null>(null);\n  const [title, setJobTitle] = useState<string | null>(null);\n  const [description, setJobDescription] = useState<string | null>(null);\n  const [loading, setLoading] = useState(false);\n\n  const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setJobUrl(e.target.value);\n  };\n\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files) {\n      setCvFile(e.target.files[0]);\n    }\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!jobUrl || !cvFile) {\n      alert(\"작업 URL과 이력서 파일을 모두 제공해주세요.\");\n      return;\n    }\n\n    const formData = new FormData();\n    formData.append(\"JobUrl\", jobUrl);\n    formData.append(\"CvFile\", cvFile);\n\n    setLoading(true);\n    try {\n      const response = await apiClient.post(\"/reviewcv\", formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      });\n\n      if (response.data.isSuccess) {\n        setReview(response.data.review);\n        setJobTitle(response.data.jobDetail.title);\n        setJobDescription(response.data.jobDetail.raw);\n        setAdSource(response.data.jobDetail.domain);\n      }\n    } catch (error) {\n      console.error(\"양식 제출 중 오류 발생:\", error);\n      alert(\"양식 제출 중 오류가 발생했습니다. 다시 시도해주세요.\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"container mt-5\">\n      <h1 className=\"text-center mb-4\">이력서 리뷰어</h1>\n      <form onSubmit={handleSubmit}>\n        <div className=\"mb-3\">\n          <label htmlFor=\"jobUrl\" className=\"form-label\">\n            작업 광고 URL\n          </label>\n          <input\n            type=\"url\"\n            className=\"form-control\"\n            id=\"jobUrl\"\n            value={jobUrl}\n            onChange={handleUrlChange}\n            required\n          />\n        </div>\n        <div className=\"mb-3\">\n          <label htmlFor=\"cvFile\" className=\"form-label\">\n            이력서 업로드\n          </label>\n          <input\n            type=\"file\"\n            className=\"form-control\"\n            id=\"cvFile\"\n            accept=\".pdf,.doc,.docx\"\n            onChange={handleFileChange}\n            required\n          />\n        </div>\n        <button type=\"submit\" className=\"btn btn-primary\" disabled={loading}>\n          {loading ? \"처리 중...\" : \"제출\"}\n        </button>\n      </form>\n      {review && (\n        <div className=\"row mt-4\">\n          <div className=\"col-md-6 pt-3 border\">\n            <h2>작업 세부 정보</h2>\n            <p>\n              <strong>작업 제목:</strong> {title}\n            </p>\n            <p>\n              <strong>광고 출처:</strong> {adSource}\n            </p>\n            <div\n              dangerouslySetInnerHTML={{ __html: description || \"\" }}\n              className=\"border\"\n            />\n          </div>\n          <div className=\"col-md-6 pt-3 border\">\n            <div dangerouslySetInnerHTML={{ __html: review || \"\" }} />\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default FormComponent;\n```\n\n주 애플리케이션 컴포넌트 (App.tsx): 주 애플리케이션에 폼 컴포넌트를 통합해보세요\n\n```js\nimport React from 'react';\nimport FormComponent from './components/FormComponent';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <FormComponent />\n    </div>\n  );\n};\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n액시오스 서비스를 만들어보세요: 코드 구조화와 재사용성을 위해 apiClient.tsx와 같은 서비스 파일에 API 호출을 중앙 집중화하세요.\n\n```js\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'http://localhost:5000/api',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\nexport default apiClient;\n```\n\n# 애플리케이션 테스트 및 실행\n\n개발 서버 실행: 프로젝트 루트 디렉토리 내에서 터미널에서 아래 명령어를 실행하여 리액트 개발 서버를 시작하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm run dev\n```\n\n애플리케이션 테스트: 브라우저를 열고 http://localhost:5173 또는 터미널에서 제공된 엔드포인트로 이동합니다.\n\n![이미지](/assets/img/2024-05-17-BuildingaWebApplicationPoweredbyLargeLanguageModelsLLMpart2_1.png)\n\n작업 URL을 입력하고 이력서 파일을 업로드한 후 제출 버튼을 클릭하여 테스트해보세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-17-BuildingaWebApplicationPoweredbyLargeLanguageModelsLLMpart2_2.png\" />\n\n애플리케이션은 백엔드 서비스에 요청을 보내 작업 세부 정보와 이력서 검토를 가져옵니다.\n\n<img src=\"/assets/img/2024-05-17-BuildingaWebApplicationPoweredbyLargeLanguageModelsLLMpart2_3.png\" />\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 React, TypeScript 및 Bootstrap을 사용하여 CV Reviewer 애플리케이션의 프론트엔드를 성공적으로 구축했습니다. 이 애플리케이션은 현대 웹 기술의 통합뿐만 아니라 백엔드 서비스 및 API를 활용하여 원활한 사용자 경험을 만드는 방법을 보여줍니다. 애플리케이션은 사용자 인증, 오류 처리 개선, 여러 이력서 검토용 대시보드 추가 또는 구직 지원서용 커버 레터 생성 기능과 같은 기능을 추가하여 향상 및 확장될 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-17-BuildingaWebApplicationPoweredbyLargeLanguageModelsLLMpart2_0.png"},"coverImage":"/assets/img/2024-05-17-BuildingaWebApplicationPoweredbyLargeLanguageModelsLLMpart2_0.png","tag":["Tech"],"readingTime":7}],"page":"69","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}