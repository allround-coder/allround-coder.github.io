{"pageProps":{"posts":[{"title":"글로벌 게이머 챌린지의 수상자 발표","description":"","date":"2024-05-15 10:59","slug":"2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge","content":"\n\n# 우리의 상위 10개 프로젝트 및 지속 가능한 게임에 참여하는 방법\n\n![이미지](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_0.png)\n\n플러터(Flutter) 및 글로벌 시민 커뮤니티에 게임개인도의 행성을 돕기 위해 초점을 맞춘 에픽 플러터 게임을 개발하도록 요청했습니다. 수십 개국에 걸친 수천 명의 열정적인 개발자에 의해 제출된 수백 개의 혁신적인 게임 프로젝트가 있었습니다.\n\n각 프로젝트는 플레이어들에게 지식과 조치를 전달하여 우리 행성을 보호할 수 있도록 하는 것을 목표로 했습니다. 자원 보존부터 오염 대응까지, 이러한 게임들은 절박한 환경 문제에 대한 우리의 집단 인식을 높이는 동시에 정말 재미있게 플레이할 수 있는 것입니다! 우리는 참여한 사람들의 놀라운 아이디어와 열정에 깊은 영감을 받았습니다.\n\n\n\n# 최종 10위를 위한 마지막 드럼 소리\n\n이 프로젝트 팀들은 103일 동안 프로젝트를 기획하고 만들고, 피드백을 받고, 프로젝트를 개선해왔습니다. 결과물은 우리 모두에게 더 지속 가능하게 생활할 수 있는 방법에 대해 깊이 생각하도록 도와주는 흥미로운 게임들입니다. 이들은 모두 알파벳순으로 나열되어 있습니다!\n\n## Better World\n\n환경 주제의 다양한 색감 있는 시각적 효과와 음악, 그리고 긍정적인 행동을 촉진하기 위해 기관들과 파트너십을 맺기 위한 아이디어가 담겨 있습니다.\n\n\n\n![Craftown](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_1.png)\n\n**Craftown**\n\n전통적인 실시간 전략 및 자원 관리 게임플레이의 독특한 혼합물로, 지속가능성 주제에 초점을 맞추고 있어요.\n\n![Craftown](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_2.png)\n\n\n\n## 에코시프트 연대기\n\n매력적인 시각적 효과와 사운드 디자인으로 긍정적인 행동을 장려하며, 플레이어들에게 관련성 있는 선택지와 환경적 결과를 제시합니다.\n\n![이미지](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_3.png)\n\n## 고밀랜드\n\n\n\n매력적이고 교육적인 쓰레기 처리 게임으로, 일본 문화에서 영감을 받았어요.\n\n![이미지](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_4.png)\n\n## Last Bottle\n\n매력적인 디자인과 수집 가능한 요소들이, 재활용의 한계와 환경 문제를 비판적으로 생각하는 핵심 메시지를 효과적으로 전달해 줘요.\n\n\n\n<img src=\"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_5.png\" />\n\n## MGame — 쓰레기 처리 게임\n\n복잡한 쓰레기 처리 시스템에 대한 흥미로운 시뮬레이션 게임으로, 클래식 도시 건설 게임을 연상시킵니다.\n\n<img src=\"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_6.png\" />\n\n\n\n## Ocean Rangers\n\n유쾌한 이야기, 매력적인 캐릭터, 전략적인 게임 요소는 익숙한 장르에 환경적 요소를 더해 독특한 경험을 제공합니다.\n\n![Image](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_7.png)\n\n## PlasticPunk\n\n\n\n도시를 건설하는 스타일의 게임으로 매력적인 시각 효과와 매혹적인 게임 플레이를 통해 복잡한 환경적 도전 과제를 제시합니다.\n\n![이미지](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_8.png)\n\n## Waste Wise\n\n직관적인 게임 플레이를 특징으로 하는 쓰레기 분리 수집 게임으로 적절한 쓰레기 처리 방법을 플레이어에게 효과적으로 교육합니다.\n\n\n\n<img src=\"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_9.png\" />\n\n## Whaley’s Bins Waste Sorting\n\n재활용 교육을 위한 창의적 접근을 갖춘 쓰레기 분리 게임으로, 독특한 픽셀 아트 시각 효과를 특징으로 합니다.\n\n<img src=\"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_10.png\" />\n\n\n\n우리는 구글 사무실에서 워크샵과 더 많은 활동을 통해 뉴욕 시에서 이 팀들과 함께 시간을 보내는 것을 기대하며, 글로벌 시티즌 페스티벌 2024에서 60,000명의 다른 글로벌 시민들과 함께 축하할 것을 기대합니다!\n\n하지만 이들은 글로벌 게이머 챌린지에서 상을 받은 30개 이상의 팀 중에 딱 10개일 뿐입니다. 상위 20명의 다른 팀원들을 포함해서입니다. 'flutter.dev/global-gamers/#winners'로 이동하여 모든 수상팀을 확인해보세요!\n\n모든 수상자들에게 축하드립니다!\n\n# 여기서 끝나지 않아요\n\n\n\nPlaying 4 the Planet Alliance의 운영 책임자인 Lisa Pak이(가) 씀\n\n세계 게이머 챌린지가 점점 마무리를 지어가지만, 지속 가능한 게임 운동은 여기서 끝나지 않습니다. 이번 챌린지를 통해 만들어진 게임들과 Global Game Jam과 같은 유사한 챌린지들은 수백만 명의 플레이어에게 도달할 수 있는 잠재력을 가지고 있어 전 세계적인 긍정적인 환경 변화의 파동을 만들어낼 수 있습니다.\n\n이 성장하는 운동과 연결을 유지하는 방법은 다음과 같습니다:\n\n- 커뮤니티 가입: 생태 친화적인 게임 디자인에 전념한 온라인 커뮤니티와 포럼에 가입하는 것을 고려해보세요. 이러한 공간은 여러분의 작품을 공유하고 다른 개발자들과 아이디어를 교환할 수 있는 소중한 기회를 제공합니다.\n- 지속가능한 게임 플레이: 중요한 주제에 대한 플레이어들의 참여를 촉진하기 위해 한정된 시간의 이벤트, 도전 과제, 새로운 레벨 등을 포함한 인기 게임들을 주목해보세요. 우리의 목표는 가능한 많은 사람들에게 도달하는 것이며, 이러한 게임들은 큰 영감의 원천이 될 수 있습니다.\n- 여러분만의 목소리를 내다: 지속가능한 게임 개발에 관한 여러분의 경험을 쓰거나, 향후 개발자를 조언하거나, 여러분만의 프로젝트를 기획해보세요. 여러분의 기술적 또는 환경적 지식을 공유함으로써, 커뮤니티의 성장을 지원하는 뿐만 아니라 다른 사람들에게 지구에 긍정적인 영향을 미치는 게임을 만들도록 영감을 줄 수 있습니다.\n\n\n\n# 계속해서 발전해주세요\n\n클레이튼 위틀(Clayton Whittle), 기후 SIG 공동 의장\n\n게임에서의 지속가능성은 움직임 자체를 홍보하고, 팀의 게임 디자인 실천에서 기후와 지속가능성에 우선순위를 둠으로써, 게임 산업의 지속가능성 대사로서 지속될 수 있습니다.\n\n녹색 게임 디자인은 발전하는 분야로, 현실적이고 측정 가능한 영향을 가져오는 게임을 만들기 위한 점점 더 정제된 실천 방법을 포함하고 있습니다. 녹색 게임을 만들기 위한 범용 규칙은 없지만, 표준 지침을 준수하면 어떤 게임 디자인 팀이든 상당한 혜택을 받을 수 있습니다.\n\n\n\n- 대상을 알아야 합니다: 효과적인 지속 가능성 게임은 대상의 요구 사항과 능력을 이해하는 것부터 시작합니다. 지속 가능성 게임은 플레이어를 어떤 방식으로 변화시킬지를 목표로 하기 때문에 대상을 이해하는 것이 이 변화를 이끌어내는 데 중요합니다. 대상이 처음에 어디에 서 있는지를 알지 못하면 원하는 목표 지점으로 이끄는 것이 어려울 수 있습니다.\n- 구체적이 되세요: 효과적인 메시지를 전달하기 위해 메시지에 집중해야 합니다. 한 게임으로 플레이어의 전체 세계관을 바꾸려고 하는 것은 현실적이지 않습니다. 대신 변화가 의미 있는 특정 영역을 확인하세요.\n- 효과적인 조치를 장려하세요: 행동 가능한 지식을 제공하세요. 플레이어들이 차이를 만들 수 있는 영향력 있는 조치를 가르치세요. 플레이어들은 자신의 행동이 생태계나 사회에 어떻게 영향을 줄 수 있는지를 보여주면 높은 확률로 참여할 것입니다.\n- 그린워싱에 주의하세요: 얕은 지속 가능성 노력을 피하세요. 그린워싱은 지속 가능성 요소를 가짜로 표현하는 것을 의미합니다. 그린 아트워크를 추가하거나 캐릭터를 \"캡틴 리사이클\"로 지칭하는 것은 매력적으로 보일 수 있지만, 게임 플레이나 스토리텔링에서 의미 있는 지속 가능성 조치가 없다면 플레이어들은 이러한 얕은 연결을 통찰하게 됩니다.\n\n기억하세요, 영향력 있는 그린 게임을 개발하는 무수히 많은 방법이 있습니다. 당신의 아이디어와 디자인은 이 가이드를 벗어나서 미개척 영역으로 확장될 수 있습니다. 당신의 팀에 적합한 것은 미션과 대상에 따라 다릅니다. 하지만 이 원칙을 디자인 토론에 반영함으로써 당신의 팀이 영향력 있는 미션에 초점을 유지하도록 도와줄 수 있습니다.\n\n# Flutter가 어떻게 도움이 될 수 있는지\n\n여기 Flutter가 당신이 게임을 실행할 곳에 대해 걱정하는 시간을 덜고, 대신 미션과 대상을 위한 영향력 있는 경험을 디자인하는 데 더 많은 시간을 할애할 수 있는 몇 가지 방법이 있습니다.\n\n\n\n- Flutter은 생산적입니다: Flutter를 사용하여 단일 코드베이스를 개발하면 게임을 한 번만 작성하고 여러 플랫폼에 배포할 수 있습니다. Stateful hot reload와 같은 기능을 통해 빠르게 반복하고 개발 흐름을 가속화할 수 있습니다.\n- Flutter는 배우기 쉽습니다: 전문 게임 개발자가 아니더라도 Flutter로 시작하는 것이 전통적인 게임 개발 도구보다 쉬울 수 있습니다. 또한 Flutter Casual Games Toolkit의 일환인 게임 템플릿과 같은 여러 리소스를 제공하여 게임 개발 기술을 향상시킬 수 있는 발판을 제공합니다.\n\n다음 여정에 함께해 줘서 감사합니다! 다음에 여러분이 무엇을 만들어내는지 기대됩니다!","ogImage":{"url":"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_0.png"},"coverImage":"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 브라우저가 웹사이트를 찾는 방법","description":"","date":"2024-05-15 10:57","slug":"2024-05-15-HowYourBrowserFindsWebsites","content":"\n\n![이미지](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_0.png)\n\n## 웹의 작동 방식: 뒷면을 엿보는 중\n\n웹 사이트 주소를 입력하고 Enter 키를 누르면 무슨 일이 벌어지는지 알아봅시다. 화면에 웹 사이트 구성 요소가 표시되지만, 어떻게 그려지는 걸까요?\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*pQhQk0K7WbJRLeA5ixEA9Q.gif)\n\n\n\n## 1. 웹사이트 찾기\n\n웹사이트에 접속하려면 일반적으로 브라우저에 그 이름을 입력합니다. 하지만 컴퓨터는 그 이름을 우리가 이해하는 방식으로 인식하지 않습니다.\n\n대신, 인터넷 상의 모든 장치에 대한 고유한 식별자 역할을 하는 숫자 문자열인 IP 주소를 사용합니다. 따라서 우리가 웹사이트를 검색할 때 컴퓨터는 해당 웹사이트의 IP 주소를 찾아야 합니다.\n\n## 2. 귀하의 ISP: 인터넷 게이트웨이\n\n\n\n웹 브라우저에 \"google.com\"을 입력하면 당신의 기기가 웹사이트에 직접 연결되지는 않습니다. 대신, 인터넷 서비스 제공업체(ISP)에게 웹사이트의 IP 주소를 요청하는 요청을 보냅니다.\n\n![image](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_1.png)\n\nISP는 당신에게 인터넷 접속을 제공하는 회사로, 국가마다 다양합니다.\n\n## 3. DNS: 인터넷의 전화번호부\n\n\n\nISP도 \"google.com\"의 위치를 모르고 있어요. 이를 알아보기 위해 인터넷을 위한 거대한 전화번호부 역할을 하는 도메인 이름 시스템(DNS)에 연락합니다.\n\n![How Your Browser Finds Websites](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_2.png)\n\nDNS는 모든 웹사이트의 IP 주소를 해당 도메인 이름과 함께 저장합니다. 따라서 ISP가 google.com에 대한 요청을 받으면 DNS에 연락하여 해당 도메인에 연결된 IP 주소를 찾아냅니다.\n\n그럼 DNS가 IP 주소로 응답하고, ISP는 해당 IP 주소를 당신의 브라우저로 전송해줍니다.\n\n\n\nMarkdown 형식으로 바꿔보세요.\n\n![Connecting to the Website](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_3.png)\n\n## 4. Connecting to the Website\n\n웹사이트의 IP 주소를 가져오면 브라우저가 HTTP 요청을 준비합니다. 이 요청은 케이블과 라우터로 구성된 네트워크를 통해 목적지에 도달합니다.\n\n![Traveling through the Network](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_4.png)\n\n\n\n요청을 받은 서버는 ‘google.com’을 구성하는 모든 파일을 저장하는 창고와 같이 작동합니다. 이 서버는 ‘google.com’을 구성하는 HTML, CSS 및 JavaScript 파일을 찾아서 브라우저로 다시 전송합니다.\n\n![How Your Browser Finds Websites](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_5.png)\n\n## 5. Rendering the Magic\n\n이제 브라우저가 이러한 파일을 보유하고 있으면, 해석을 시작합니다. HTML을 읽고 구조를 이해하며, CSS 스타일을 적용하고 JavaScript를 실행한 다음... 그 결과로 웹페이지가 화면에 표시됩니다.\n\n\n\n\n![How Your Browser Finds Websites](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_6.png)\n\nAfter this point, there might be many other requests back and forth between your browser and Google servers for other HTML, CSS, and JS files. However, you don’t need to make another request to your ISP for these, as they go directly to Google’s servers. Additionally, your browser has likely cached the IP address of google.com, so it won’t need to make an unnecessary request to your ISP next time.\n\n## Experiment: See It in Action\n\nWant proof? Try this:\n\n\n\n\n- 브라우저의 개발자 도구를 열어주세요 (F12를 누르거나 마우스 오른쪽 버튼을 클릭하여 \"Inspect\"를 선택합니다).\n- \"Network\" 탭으로 이동합니다.\n- \"google.com\"을 입력하고 Enter를 누릅니다.\n- 첫 번째 요청을 찾아 \"Remote Address\"를 확인합니다 - 그곳에 구글의 IP 주소가 있어요!\n- IP 주소를 복사하여 새 탭에 붙여넣고 Enter를 누릅니다.\n\n![화면이미지](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_7.png)\n\n이렇게 하면 ISP와 DNS를 거치지 않고도 구글에 접속할 수 있어요.\n\n## 요약: 전체 그림\n\n\n\n그래서, 웹 사이트를 방문할 때:\n\n- 도메인 이름 해석: 귀하의 ISP는 웹 사이트의 IP 주소를 찾기 위해 DNS를 사용합니다.\n- HTTP 요청: 귀하의 브라우저가 서버에 웹 사이트를 요청합니다.\n- 서버 응답: 서버가 HTML, CSS 및 JavaScript 파일을 보냅니다.\n- 렌더링: 귀하의 브라우저가 웹 사이트를 조립하고 표시합니다.\n\n웹 개발 기본에 대해 더 알아보고 싶다면, 무료 웹 개발자 커뮤니티에 가입하고 모든 강좌에 액세스하세요.","ogImage":{"url":"/assets/img/2024-05-15-HowYourBrowserFindsWebsites_0.png"},"coverImage":"/assets/img/2024-05-15-HowYourBrowserFindsWebsites_0.png","tag":["Tech"],"readingTime":3},{"title":"새로운 기술 개척 KBTG GO 집중 워크샵 후기","description":"","date":"2024-05-15 10:55","slug":"2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop","content":"\n\n![image](/assets/img/2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop_0.png)\n\n👋 안녕하세요, 제 이름은 치바스입니다.\n\n오늘은 2024년 5월 11일부터 12일까지 K+ 건물에서 참가한 KBTG GO 집중 워크샵 경험을 공유하고 싶습니다.\n\n🎉🎉 시작해봅시다! 🎉🎉\n\n\n\n# 워크샵 개요\n\n이 워크샵에 참여하려면 Go 소프트웨어 엔지니어링 부트캠프를 완료해야 합니다.\n\n이 워크샵은 Git 및 협업, 소프트웨어 설계, 소프트웨어 품질, 데브옵스 등 부트캠프에서 습득한 기술을 기반으로 구축됩니다!\n\n다음 부트캠프를 놓치지 않으려면 KBTG의 공식 페이스북 페이지를 팔로우하여 최신 정보를 확인하세요!\n\n\n\n워크샵은 오전 8시 30분부터 오후 6시까지 진행될 예정이며, 아이스브레이킹, 요구 사항 설명 및 구현과 같은 활동이 포함될 것입니다. 워크샵 중에는 강사가 다양한 기술과 지식을 공유할 예정입니다.\n\n# 배운 점\n\n이 워크샵에서 배운 내용\n\n워크샵 중에는 모든 참가자가 다섯 개의 그룹으로 나눠지고, 그룹으로 협업할 것입니다. 다만, 처음 보는 사람들이며 동료의 이름만 알고 있는 점을 기억해 주세요.\n\n\n\n팀원들과 의견을 공유하고 피드백을 요청하는 것은 중요합니다. 가끔은 좋은 아이디어가 있더라도 상황에 더 나은 접근 방식이 있을 수 있습니다. 그러므로 팀원들로부터 가능한 모든 피드백을 듣는 것이 중요합니다.\n\n협업뿐만 아니라 소프트웨어 엔지니어링 기술, 프로덕션급 소프트웨어 인프라 구축, 페어 프로그래밍, 테스트 주도 개발(TDD)과 같은 다양한 분야에서 지식이 풍부합니다.\n\n# 실습 활동\n\n## 비즈니스 요구 사항 이해 및 계획하기\n\n\n\n첫째 날, 아이스 브레이킹 활동 후, 강사는 제품 소유자의 역할을 맡게 됩니다. 그는 비즈니스 요구 사항을 제시하고, 여러분과 여러분의 팀은 해당 요구 사항을 기반으로 제품을 어떻게 구축할지 계획하기 위해 토론에 참여할 것입니다.\n\n## 페어 프로그래밍\n\n각 그룹은 다음 규칙을 따라야 합니다: 모든 그룹은 페어 프로그래밍을 해야 합니다. 처음으로 페어 프로그래밍을 하게 되었고, 저와 제 페어가 선택한 프로그래밍 유형은 드라이버와 네비게이터입니다.\n\n## 매일 동기화하기\n\n\n\n두 번째 날에는 어제 달성한 내용에 대해 동료와 싱크를 맞춰야 하고, 마주한 어려움을 파악하고 오늘 해야 할 일을 계획해야 할 거예요.\n\n## 코드 리뷰\n\n구현 기간이 끝난 후, 여러분의 팀은 프로젝트 진행 상황을 발표하고 다른 그룹이 같은 비즈니스 요구 사항을 어떻게 완수하는지 배울 수 있는 기회가 주어질 거에요.\n\n# 네트워킹과 연결\n\n\n\nKBTG Go Workshop에 참여하여 기술 전문가, 비 기술 관련자, 심지어 학생들과 다양한 사람들과 연결할 수 있는 기회를 가졌어요 (나는 늙은 것 같아요 😭)\n\n워크샵은 제 네트워크를 확장하고 관계를 구축하는 플랫폼을 제공했어요. 최고에요!\n\n# 다음 단계\n\n부트캠프와 워크샵에서 얻은 기술을 활용하여 개인 성장을 증진할 계획이에요.\n\n\n\nKBTG가 훌륭한 부트 캠프와 워크샵 경험을 제공해줘서 정말 감사합니다! 🙏","ogImage":{"url":"/assets/img/2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop_0.png"},"coverImage":"/assets/img/2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop_0.png","tag":["Tech"],"readingTime":2},{"title":"물리적 디바이스를 Firebase Emulator에 연결하기","description":"","date":"2024-05-15 10:54","slug":"2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator","content":"\n\n## 플러터 개발 및 테스트를 위한 Firebase 에뮬레이터 스위트에 실제 기기 연결하기\n\n모든 플러터 개발자들은 공통 목표를 공유합니다: 성능이 우수하고 버그가 없는 앱을 출시하는 것입니다. 이를 달성하기 위해서는 실제 환경과 가까운 환경에서 엄격한 테스트가 필요합니다. 이를 통해 개발자들은 사용자에게 영향을 미치기 전에 문제를 식별하고 해결할 수 있습니다. 테스트 조건이 실제 사용 시나리오와 유사할수록, 개발자들은 앱을 미세 조정하여 안정성, 사용성 및 원활한 성능을 보장할 수 있습니다.\n\n그러나 가끔씩 실제 제품 환경에서 바로 테스트하는 것이 유혹적일 수 있지만, 이는 매우 위험합니다. 실제 사용자들의 경험과 정확히 일치하는 테스트를 수행하는 것은 기존 사용자들에게 라이브 서비스를 방해할 위험을 가지며, 의도하지 않은 상당한 비용을 초래할 수도 있습니다. 구름 기능에 오류가 있는 경우, 수천 개의 작업을 실수로 수행할 수 있습니다. 각 작업은 수수료가 부과될 수 있습니다. 불행한 헤드라인의 대상이 되고 싶지 않다면 안전하고 격리된 테스트 환경이 중요합니다.\n\n![이미지](/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_0.png)\n\n\n\n파이어베이스 에뮬레이터 스위트가 등장하는 곳입니다. 이는 파이어베이스 서비스를 로컬로 시뮬레이션하여 앱의 기능을 철저히 테스트할 수 있게 해줍니다. 인증, 데이터베이스 작업, 서버 측 로직과 같은 기능을 배포 코드가 실제 백엔드로 이동하는 위험 없이 테스트할 수 있습니다. 이 로컬 에뮬레이터와 함께 물리적 장치에서 테스트를 활성화하여, 개발자는 실제 사용자들이 사용하는 실제 장치에서 어플리케이션이 어떻게 동작하는지 볼 수 있습니다. 이는 랩 조건과 실제 사용 사이의 간극을 메우고, 프로덕션 환경에서의 테스트의 위험을 회피할 수 있도록 해줍니다.\n\n<img src=\"/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_1.png\" />\n\n파이어베이스 에뮬레이터 스위트를 설정하는 방법에 대한 훌륭한 많은 기사들이 있습니다. 이 기사들은 에뮬레이터가 테스트 중인 소프트웨어가 실행 중인 기기와 동일한 장치에서 실행되고 있다고 가정합니다. 실제로 구글의 공식 문서는 우수합니다. 하지만 모바일 개발자에게는 물리적 장치에서 테스트하는 것이 가장 중요한 경우가 많습니다, 시뮬레이션된 아이폰이나 안드로이드 장치만으로는 부족합니다. 시뮬레이터는 모바일 장치의 하드웨어 동작(배터리 사용, 카메라 기능, GPS 정확도 등)을 완벽하게 재현할 수 없기 때문입니다. 또한 시뮬레이터에서 앱의 느낌을 완전히 이해하는 것이 어렵습니다. 실제 장치에서 테스트하여 앱이 실제 사용 조건에서 잘 작동하도록 보장하고, 시뮬레이터가 놓치는 세세한 점과 상호 작용을 포착할 수 있습니다.\n\n파이어베이스 에뮬레이터 스위트에 실제 모바일 장치를 연결하는 방법에 대한 문서화된 정보가 부족합니다. 그래서 이 기사에서는 이 과정을 다룰 것입니다.\n\n\n\n# 로컬에서 플러터 앱을 Firebase Emulator Suite에 연결하는 방법\n\n그러나 실제 기기와 작업하기 전에 첫 번째 단계는 개발 컴퓨터에서 모두 실행 중인 경우 플러터 앱을 Firebase Emulator Suite에 연결하는 것입니다. 이를 수행하려면 앞에서 언급한 대로 다른 곳에서도 잘 문서화되어있는 몇 가지 단계를 따라야합니다.\n\n## 단계 1: Firebase Emulator Suite 설치 및 구성\n\n플러터 앱을 Firebase Emulator에 연결하려면 먼저 Firebase CLI를 설치하고 로컬 컴퓨터에 Firebase Emulator Suite를 설정해야합니다. Firebase CLI는 npm을 사용하여 설치할 수 있습니다:\n\n\n\n```bash\nnpm install -g firebase-tools\n```\n\n만약 아직 프로젝트 디렉토리에서 Firebase를 초기화하지 않았다면:\n\n```bash\nfirebase init\n```\n\n초기화 과정 중에 설정하려는 역할을 선택하세요 (예: Firestore, Authentication, Functions). 이렇게 하면 프로젝트 디렉토리에 firebase.json 파일이 생성되고 해당 파일에 에뮬레이터 설정이 저장됩니다. 곧 다시 이 파일을 사용할 것이므로 기억해 두세요.\n\n\n\n## 단계 2: 플러터 앱에서 Firebase 구성\n\n플러터 앱에서 Firebase 패키지가 라이브 Firebase 서비스가 아닌 로컬 엠블러에 연결되도록 구성해야 합니다. 플러터 앱에서 Firebase를 초기화하여 로컬 엠블러 인스턴스에 연결하십시오. 일반적으로 이는 main.dart 파일이나 Firebase를 초기화하는 곳에서 수행됩니다:\n\n```js\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Firebase를 초기화합니다.\n  await Firebase.initializeApp();\n\n  // 디버그 모드에서 Firebase 로컬 엠블러를 사용합니다.\n  if (kDebugMode) {\n    FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);\n    await FirebaseAuth.instance.useAuthEmulator('localhost', 9099);\n    FirebaseFunctions.instance.useFunctionsEmulator('localhost', 5001);\n\n    debugPrint('Firebase 엠블러 스위트 사용중');\n  }\n\n  runApp(MyApp());\n}\n```\n\n\n\n```js\nif (kDebugMode) {…}\n```\n\n은 선택 사항이지만, 디버깅 중에 Flutter 앱이 항상 Firebase Emulator Suite를 사용하는지 확인하는 데 유용하다고 생각합니다.\n\n## 단계 3: 에뮬레이터 실행 및 Flutter 앱 실행\n\nFirebase 에뮬레이터를 구성하고 Flutter 앱이 이러한 에뮬레이터에 연결되도록 설정한 후, 이제 에뮬레이터를 시작할 수 있습니다:\n\n\n\n```js\nfirebase emulators:start\n```\n\n이 명령어는 설정한 모든 에뮬레이터를 시작합니다. 플러터 앱을 시작하기 전에 실행 중인지 확인해주세요. 이제 디버그 모드로 플러터 앱을 실행하면 Firebase Emulator Suite를 사용할 수 있습니다. CLI도 이에 대해 알려줄 것이지만, (일반적으로) http://localhost:4000/로 이동하여 에뮬레이터 스위트용 UI에 액세스할 수 있습니다.\n\n![Connecting Physical Devices to Your Firebase Emulator](/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_2.png)\n\n## 단계 4: 연결 확인하기\n\n\n\n앱이 실행되면 FirebaseAuth를 사용하여 로그인하거나 Firestore에서 문서를 읽고 쓰는 작업을 수행해보세요. 에뮬레이터 UI에 반영된 액션을 확인할 수 있을 것입니다. 이는 Flutter 앱이 Firebase Emulator에 올바르게 연결되어 있는지를 확인하는 것이죠.\n\n# Flutter 앱과 Firebase 에뮬레이터를 외부 장치에 연결하기\n\n좋아요, 이제 Flutter 앱이 동일한 기기에서 실행 중일 때 Firebase 에뮬레이터 스위트에 연결할 수 있는 것처럼 외부 모바일 장치(예: 안드로이드 폰, 아이폰 또는 iPad)에서 실행 중인 Flutter 앱을 Firebase 에뮬레이터 스위트에 연결하기 위한 몇 가지 조정이 필요합니다.\n\n## 단계 1: 개발 환경의 IP 주소 얻기\n\n\n\n먼저 개발 컴퓨터의 IP 주소를 확인해야 합니다. 이 IP 주소는 플러터 앱의 Firebase 초기화 코드에서 localhost 참조를 대체할 것입니다. 이렇게 하면 주요 운영 체제에서 IP 주소를 찾을 수 있습니다:\n\n- Windows: 명령 프롬프트를 열고 ipconfig를 입력합니다. 네트워크 연결에서 \"IPv4 주소\"를 찾아보세요.\n- macOS: 시스템 환경설정을 열고 네트워크로 이동한 다음 활성 네트워크 연결을 선택합니다. 거기서 IP 주소를 확인할 수 있습니다.\n- Linux: 터미널을 열고 hostname -I를 입력하면 컴퓨터의 IP 주소가 표시됩니다.\n\n## 단계 2: 플러터 앱의 Firebase 초기화 업데이트\n\n획득한 IP 주소로 플러터 앱의 Firebase 초기화 코드에서 localhost 참조를 대체하세요. 이렇게 하면 외부 기기가 올바른 서버를 대상으로 할 수 있습니다. main.dart에서 설정을 수정하는 방법은 다음과 같습니다:\n\n\n\n```js\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // Firebase 초기화\n  await Firebase.initializeApp();\n\n  // 디버그 모드에서는 Firebase 로컬 에뮬레이터를 사용합니다.\n  if (kDebugMode) {\n    // Firebase 에뮬레이터 스위트를 실행하는 컴퓨터의 IP 주소입니다. 앱과 같은 기기에서 에뮬레이터 스위트를 실행 중이면 \"localhost\"를 사용합니다. 그렇지 않으면 에뮬레이터 스위트를 실행 중인 기기의 IP 주소를 사용합니다.\n    const String devMachineIP = '192.168.x.x';  // 실제 IP 주소로 대체하세요\n\n    FirebaseFirestore.instance.useFirestoreEmulator(devMachineIP, 8080);\n    await FirebaseAuth.instance.useAuthEmulator(devMachineIP, 9099);\n    FirebaseFunctions.instance.useFunctionsEmulator(devMachineIP, 5001);\n  }\n\n  runApp(MyApp());\n}\n```\n\n## 단계 3 : firebase.json 구성 수정\n\n이 프로젝트에 Firebase를 초기화할 때 생성된 firebase.json 파일을 기억하시나요? 외부 기기에서 연결을 허용하려면 Firebase Emulator Suite를 localhost뿐만 아니라 모든 IP 주소에서 요청을 수락하도록 구성해야 합니다. 이를 위해 firebase.json 파일에서 모든 에뮬레이터의 호스트를 0.0.0.0으로 설정합니다:\n\n```js\n{\n  \"emulators\": {\n    \"auth\": {\n      \"host\": \"0.0.0.0\",\n      \"port\": \"9099\"\n    },\n    \"firestore\": {\n      \"host\": \"0.0.0.0\",\n      \"port\": \"8080\"\n    },\n    \"functions\": {\n      \"host\": \"0.0.0.0\",\n      \"port\": \"5001\"\n    },\n    // 필요한 다른 서비스를 포함하세요\n  }\n}\n```\n\n\n\n## ❗ 보안 경고 ❗\n\nFirebase 에뮬레이터를 어떤 IP 주소에서든 연결할 수 있도록 구성하면 외부 기기에서의 테스트를 가능케 할 뿐만 아니라 에뮬레이터를 네트워크에 노출시킬 수도 있습니다. 이 설정은 무단 접근을 방지하기 위해 안전하고 제어된 네트워크 환경에서만 사용해야 합니다. Firebase Emulator Suite를 인터넷이나 안전하지 않은 네트워크에 노출시키지 마십시오.\n\n# 마무리\n\n외부 모바일 기기를 Firebase Emulator Suite에 연결하는 과정은 문서화가 잘 되어 있지 않지만, 주요 변경 사항은 두 가지뿐입니다:\n\n\n\n- firebase.json 파일에서 에뮬레이터의 호스트를 0.0.0.0으로 설정하여 앱이 로컬 컴퓨터 외의 기기에서도 연결할 수 있도록 합니다.\n- Flutter 앱을 로컬호스트 대신 개발 컴퓨터의 IP 주소를 사용하도록 업데이트합니다.\n\nFlutter 앱을 외부 모바일 기기와 Firebase Emulator Suite에 연결할 수 있도록 설정하면 개발 컴퓨터의 범위를 벗어나 심층적인 테스트를 수행할 수 있습니다. 이 기능을 통해 제품 환경에 손상을 주지 않고 실제 기기에서 앱의 기능을 검증하므로 더 큰 확신을 갖고 앱을 출시할 수 있을 것입니다.\n\n![이미지](/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_3.png)","ogImage":{"url":"/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_0.png"},"coverImage":"/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_0.png","tag":["Tech"],"readingTime":7},{"title":"당신의 iOS 앱의 비밀을 보호하는 중요한 단계","description":"","date":"2024-05-15 10:52","slug":"2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets","content":"\n\n암호화와 적절한 솔루션 선택\n\n앱에 하드코딩된 문자열로 저장된 비밀 또는 암호화 키가 있나요? 또는 Info.plist와 같은 파일에 저장되어 있나요?\n\n그렇다면, 그것들은 매우 쉽게 발견될 수 있습니다.\n\n먼저, 우리가 방지하려는 것을 이해하기 위해 공격자가 어떻게 하드코딩된 문자열을 볼 수 있는지 살펴봅시다.\n\n\n\n# 해커가 하드코딩된 문자열을 어떻게 볼 수 있을까요?\n\n당신의 애플리케이션(예: iOS의 경우 IPA 파일)을 정적 분석 도구에 전달하면 그 문자열들이 이렇게 나타날 것입니다:\n\n![이미지](/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png)\n\nInfo.plist 파일에 저장한다면 어떨까요?\n\n\n\n이 방법도 안전하지 않습니다. 파일은 정적 분석기를 통해 쉽게 볼 수 있습니다.\n\n![image](/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_1.png)\n\n## 그래서, 하드코딩된 문자열을 어떻게 보호할까요?\n\n이상적으로는 보안 정보(API 키, 엔드포인트, API 토큰 등 민감한 데이터)는 클라이언트 측에 저장되어서는 안 됩니다. 이는 피해야 할 패턴입니다.\n\n\n\n하지만 거의 모든 앱에는 일부 정보가 저장되어 있고, 당신이 이러한 상황에 처할 수도 있습니다. 이 경우에는 정보가 올바르게 보호되었는지 확인해야 합니다.\n\nAPI 키와 기타 비밀 정보를 간단히 암호화할 수 있을까요?\n\n좋은 시작입니다. 하지만 클라이언트에 암호화 키를 저장해야 하는 경우 어떻게 그것을 안전하게 보호할 수 있을까요?\n\n어떤 정보든 클라이언트에 두는 보안 계층은 100% 안전하지 않다는 것을 강조하고 싶습니다. 그러나 공격자가 이러한 정보를 획득하는 것을 매우 어렵게 만들 수는 있습니다.\n\n\n\n주기적으로 비밀을 업데이트하는 것은 역공학 공격을 무력화시킬 수 있습니다. 정기적인 업데이트로, 역공학자가 시간을 쏟아서 비밀을 얻으려고 노력한 모든 시간이 무익해질 수 있기 때문이죠.\n\n# 코드 난독화\n\n위에서 설명한 것처럼 일반적으로 정보를 업데이트하여 구조를 변경함으로써 역공학 공격을 무력화할 수 있습니다.\n\n난독화는 정보나 코드를 이해하기 어렵게 만드는 행위입니다. 이는 인간뿐만 아니라 컴퓨터도 이해하기 힘들게 만드는 것을 의미합니다.\n\n\n\n추가적인 보안층으로, hardcoded된 비밀을 암호화한 다음 암호화 키를 난독화 하는 것을 권장합니다. 이렇게 하면 모든 비밀을 난독화 해야 하는 대신 암호화 키만 난독화하면 되므로 알고리즘에 따라 발생할 수 있는 성능 오버헤드를 피할 수 있습니다.\n\niOS를 사용 중이라면 Apple의 CryptoKit을 사용하는 것을 추천하며, AES와 같은 강력한 산업 표준 알고리즘을 선택하는 것이 좋습니다.\n\n# 결과\n\n비밀 hardcoded된 문자열을 난독화한 후 정적 분석기가 그들을 직접적으로 사용할 수 없는 변형 형태로 캐치할 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_2.png\" />\n\n# 당신의 난독화 솔루션을 선택하기\n\n어떤 난독화 라이브러리를 선택해야 할까요?\n\n비록 당신이 선택한 어떤 난독화 알고리즘이라도 단순히 앱 내에 하드코딩된 보안 정보를 그대로 둘 것보다 낫다는 것은 사실이지만, 해독자에게 더 어렵게 만드는 솔루션도 있습니다.\n\n\n\n# 찾아야 할 난독화 기술\n\n비밀 정보를 안전하게 유지하기 위해 난독화 라이브러리를 찾고 있다면 다음의 기본 아이디어를 살펴보세요.\n\n1. 데이터 변환\n\n비밀 정보 숨김에 관련된 코드 난독화의 중요한 요소는 데이터(문자열)를 다른 형태로 변환하는 것입니다. 이는 코드의 성능에 미치는 영향을 최소화하면서도 해커들이 이해하기 어렵게 만들어야 합니다.\n\n\n\n이것은 하드코딩된 문자열을 특히 난독화하는 솔루션이 필요하다는 것을 의미합니다 (또는 문자열을 매개변수로 사용할 수 있는 것), 애플리케이션의 클래스 이름 및 소스 코드를 난독화하려는 것이 아니라는 것을 명심해주세요. 왜냐하면 그것은 다른 목적을 위한 것이기 때문입니다.\n\n데이터 변환은 문자열 암호화, 키 분할, 사용자 지정 인코딩 등 다양한 형태를 가질 수 있습니다.\n\n다중 레이어\n\n난독화 알고리즘이 여러 변환을 수행하면 스크립트에 덜 취약할 가능성이 높으며, 따라서 데이터를 이해하려는 시도가 더 시간이 걸릴 수 있으며 코드를 다시 난독화하려면 수동 개입 (동적 분석)이 필요할 수도 있습니다.\n\n\n\n# 결론\n\n요약하자면, 자동화된 스크립트에 취약하지 않은 알고리즘을 찾는 것이 이상적입니다. 공격자가 키를 복호화하는 것을 어렵게 만들어야 하며, 시간이 많이 걸리는 기술을 사용해 애플리케이션을 공격자에겐 덜 유혹적으로 만들어야 합니다.\n\n또한 비밀 정보의 중요성을 고려하고, API 키를 숨기는 경우에는 API 키 사용을 제한하는 등의 회전하는 보안 방법을 고려해야 합니다.\n\n원하는 보안 수준에 따라 소유권 기반의 난독화 솔루션을 선택할 수도 있습니다. 이러한 솔루션의 장점 중 하나는 비공개로 유지되어 자동화 스크립트에 취약할 가능성이 낮다는 것입니다.\n\n\n\n# iOS 개인 추천 사항\n\n이 추천 사항은 작성 시점에 작성되었음을 유의해 주세요.\n\n다음은 이러한 아이디어를 일부 이용한 라이브러리 목록입니다:\n\n- Swift confidentials — https://github.com/securevale/swift-confidential\n- ObfuscateMacro — https://github.com/p-x9/ObfuscateMacro\n\n\n\n이 기사는 iOS에 초점을 맞추었지만 일반적인 원칙은 모든 클라이언트 측 코드에 적용할 수 있습니다.\n\n사용하는 난독화 알고리즘은 앞으로 다룰 다른 보호층과 함께 사용해야 합니다.\n\n애플리케이션을 더 안전하게 만드는 방법에 대해 더 많은 통찰력을 얻고 싶으신가요?\n\n향후 게시물을 최신 상태로 유지하려면 아래 무료 뉴스레터를 구독해주세요:\n\n\n\nhttps://substack.com/@alexlotsu?utm_source=profile-page","ogImage":{"url":"/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png"},"coverImage":"/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터 322에서 새로운 기능을 소개합니다","description":"","date":"2024-05-15 10:49","slug":"2024-05-15-WhatsnewinFlutter322","content":"\n\n안녕하세요! 새로운 Flutter 안정 버전으로 다시 돌아왔습니다! 이번에는 Flutter 3.22를 소개해 드리게 되어 매우 기쁘게 생각합니다. 안정 채널에 WebAssembly를 도입하고, Android에서 Impeller용으로 완전히 강화된 Vulkan 백엔드를 제공하여 그래픽이 좀 더 부드럽고 성능이 크게 향상되었습니다. 또한, 새로운 위젯 상태 속성, 동적 뷰 크기 조정, 개선된 폼 유효성 검사를 통해 간편화된 작업 흐름을 소개하고 있습니다. 그 외에도, 플레이버 조건부 자산 번들링, Dart에서 Firebase의 Vertex AI 미리보기, 개선된 DevTools 등 다양한 업데이트가 있어 여러분의 개발 생활을 더욱 편리하게 만들어 줄 것입니다.\n\n지난 업데이트 이후 몇 달 만에, Flutter 커뮤니티로부터 인상적인 1595개의 풀 리퀘스트가 병합되었으며, 37명의 새로운 커뮤니티 멤버가 처음으로 Flutter에 기여했습니다!\n\n그래서 지금 바로 확인해 보세요. Flutter 커뮤니티가 이번 최신 릴리스에 기여한 모든 새로운 기능과 개선 사항을 발견해 보세요!\n\n\n# WebAssembly\n\n\n\n\n플러터 3.22가 출시되었습니다. Wasm은 이제 안정 채널에서 사용할 수 있어서 상당한 성능 향상을 제공합니다. 저희는 M1 맥북에서 Chrome을 사용하여 내부 벤치마크를 수행한 결과, Wonderous 앱의 프레임 렌더링 시간이 평균 2배 이상, 최악의 경우에는 3배까지 개선되었습니다.\n\n![이미지](/assets/img/2024-05-15-WhatsnewinFlutter322_0.png)\n\n이러한 향상 사항은 애니메이션과 풍부한 전환 효과가 있는 앱에 중요하며, 부드러운 프레임 속도를 유지하는 데 필수적입니다. Wasm은 성능 병목 현상을 줄이고, 이로 인해 부드러운 애니메이션과 전환 효과를 구현하는 데 도움이 됩니다. 플러터 웹 앱에서 Wasm을 사용하려면 Dart Wasm 문서와 Flutter Wasm 문서를 확인해보세요. 자세한 내용은 Google I/O 블로그의 Flutter 공지를 참조하세요.\n\n# 엔진\n\n\n\nFlutter 3.22에서는 Flutter 애플리케이션을 구동하는 렌더링 엔진 Impeller에 중요한 업데이트가 있습니다. 주요 업데이트 내용으로는 안드로이드에서 Vulkan 백엔드가 완료되어 그래픽이 더 부드럽고 성능이 향상되었으며, 흐릿한 효과 및 복잡한 경로 렌더링을 위한 계속되는 최적화와 Impeller를 테스트하기 위한 새로운 실험적 API가 포함됩니다. 저희의 로드맵에 따라 Impeller의 품질과 성능을 향상시키기 위해 iOS 이주를 완료하고 Android 지원을 확대하는 것을 포함하여 노력할 것입니다.\n\n## Impeller\n\n## Vulkan 백엔드 안드로이드에서 기능 완료\n\n이 릴리스에서 Impeller의 안드로이드용 Vulkan 백엔드가 기능 완료되었습니다. 특히 이전 몇 달 동안 팀은 빠른 고급 블렌드의 구현, FragmentProgram API를 사용한 사용자 지정 프래그먼트 쉐이더 지원, PlatformView 지원 (다소 API 이주가 필요함) 및 모든 흐림 스타일을 완전히 구현하는 데 열심히 일했습니다.\n\n\n\n## 안드로이드 미리보기\n\n3.19 안정 버전에서는 Impeller의 OpenGL 백엔드 개선을 통해 안드로이드 기기에서 Vulkan 지원 유무에 상관없이 Impeller를 시도해 볼 수 있도록 사용자를 초대했습니다. 지난 몇 달 동안 OpenGL 백엔드의 성능을 평가하고 Vulkan 백엔드의 남은 작업을 추정한 결과, Vulkan 백엔드를 먼저 제품으로 출시할 것으로 결정했습니다.\n\nImpeller는 셰이더 컴파일레이션 지연 문제를 해결합니다. 또한 벤치마크 결과, 평균적으로 레거시 렌더러보다 90백분위 및 99백분위 프레임 시간에서 더 뛰어난 성능을 보여줍니다. 따라서 안드로이드에서의 Vulkan 백엔드 성능은 받을 만하다고 믿습니다. 이번 릴리스(3.22)에서 Impeller를 선택하는 앱은 가능한 경우 Vulkan 백엔드를 사용합니다. 향후 릴리스에서는 이것이 기본 설정이 될 것입니다. Impeller를 선택하는 앱이 Vulkan을 지원하지 않는 기기에서 실행될 때, Flutter는 자동으로 OpenGL ES와 Skia를 사용하도록 자연스럽게 대체합니다. 여러분은 별도의 조치를 취할 필요가 없습니다. 미래에 우리가 OpenGL ES Impeller 백엔드를 제품으로 출시할 준비가 되었을 때, 이 대체 방법 또한 Impeller를 사용할 것입니다.\n\n이 3.22 안정 주기를 통해 안드로이드에서의 Impeller 미리보기가 계속될 동안, Flutter 개발자들이 최신 안정 버전으로 업그레이드하고 Impeller를 활성화할 때 발견된 어떤 결점에 대해 이슈를 제기하기를 요청합니다. 이 단계에서의 피드백은 Impeller가 안드로이드에서 성공적이 되도록 보장하고, 올해 후반 릴리스에서 확신을 가지고 기본 렌더러로 만들 수 있도록 하는 데 중요합니다. 안드로이드 하드웨어 생태계는 매우 다양합니다. 이에 따라 Impeller에 대한 가장 유익한 피드백은 문제가 발생한 특정 기기 및 안드로이드 버전에 대한 상세한 정보를 포함해야 합니다.\n\n\n\n## 블러 성능 향상\n\niOS와 Android 모두 Impeller에서 Blur가 재구현되었습니다. 새로운 방식은 Skia의 것과 유사하며, 벤치마크에서 블러의 CPU 및 GPU 시간을 거의 절반으로 줄였습니다.\n\n아래 차트는 iPhone 11 기기에서 경로학적 벤치마크에서 frame 래스터화 시간(ms)과 GPU frame 시간을 나타냅니다. Impeller의 blur를 재작성한 후, 배경 필터 블러의 CPU 및 GPU 비용이 거의 반으로 줄었습니다. 이런 개선은 일반적인 앱에서 나타나는 경우와 같이 병적인 상황에서 발생하는 경우에도 적용됩니다.\n\n![image](/assets/img/2024-05-15-WhatsnewinFlutter322_1.png)\n\n\n\n## 스텐실 후 커버\n\niOS 및 Android에서의 임펠러는 OpenGL 레드북의 \"스텐실 버퍼를 사용하여 채우고 오목한 다각형 그리기\" 장에서 설명된 스텐실-커버 방식을 기반으로 한 새로운 렌더링 전략으로 전환했습니다. 팀 구성원들은 이 기술이 Flutter에 적용된다는 점에 대해 GitHub 이슈 #123671에서 더 많이 논의했습니다.\n\n이 접근 방식은 래스터 스레드가 예를 들어 SVG 및 Lottie 애니메이션과 같은 복잡한 경로의 테셀레이션을 CPU에서 계산하는 데 너무 많은 시간을 소비하던 문제를 해결합니다. 변경 후, 복잡한 경로가 포함된 프레임의 총 프레임 시간(컴퓨터의 UI 스레드 + 래스터 스레드 + GPU 작업)이 상당히 낮아집니다. 사용자는 Lottie 애니메이션 및 기타 복잡한 경로가 더 부드럽게 렌더링되고, CPU 사용률이 낮아지고 약간 높은 GPU 사용률을 확인할 수 있을 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*1lCd7dBwJ0ab_sieDlQNFw.gif)\n\n\n\n이러한 개선 사항에 만족해하면서도, 할 일이 더 많이 남아 있습니다. 다른 기회들 중에, CPU 프로파일에서 polyline 생성이 여전히 중요한 역할을 하는 것을 인지하고 있으며, 이 작업을 GPU로 전환하는 것에 대해 조사할 계획입니다.\n\n## 새로운 API\n\n아직 실험적이지만, flutter test는 이제 --enable-impeller 플래그를 허용하며, Vulkan 백엔드를 이용하여 Impeller를 사용합니다.\n\n# 프레임워크\n\n\n\n## 위젯 상태 속성\n\nMaterialState는 Material 라이브러리 외부로 이동되었으며 WidgetState로 이름이 변경되어 Cupertino, 기본 Flutter 프레임워크 및 패키지 작성자에게 이용 가능하게 되었습니다. 새로운 WidgetState로의 이관에 대한 자세한 정보는 마이그레이션 가이드를 참조해주세요.\n\n## 동적 뷰 크기 조정\n\n동적 뷰 크기 조정의 개선으로, 반응형 레이아웃을 구축하는 개발자들이 더 나은 UI 적응성을 확보할 수 있게 되었으며, 다양한 디바이스 화면에 대해 더 나은 UI 적응성을 제공합니다.\n\n\n\n## 개선된 양식 유효성 검사\n\n플러터 커뮤니티 구성원인 SharbelOkzan의 기여 덕분에, 플러터 3.22 버전부터는 더 유연한 양식 유효성 검사 방법이 제공되어 개발자들이 더 견고한 사용자 입력 처리를 만들 수 있게 되었습니다. 이로써 사용성과 보안이 모두 강화되었습니다.\n\n## 2D API의 공변형\n\n2D 그래픽 API에서 형 변환 필요성을 줄임으로써 개발 워크플로우를 간소화하고, 게임 및 복잡한 애니메이션에 중요한 성능을 향상시킬 수 있습니다.\n\n\n\n## 플레이버별 자산 번들링\n\n플레이버 기능을 사용하는 개발자들은 이제 특정 플레이버를 빌드할 때만 특정 자산이 번들되도록 구성할 수 있습니다. 자세한 정보는 '플레이버에 기반한 조건부 자산 번들링'을 확인해보세요.\n\n## Dart 패키지를 사용한 자산 변환\n\n사용자들은 이제 Dart 패키지를 구성하여 앱의 자산이 번들될 때 변환되도록 설정할 수 있습니다. 자세한 정보는 '빌드 시간에 자산 변환하기'를 확인해보세요.\n\n\n\n# 안드로이드\n\n## 딥 링크\n\n딥 링크를 사용하면 플러터 앱의 사용자 경험을 크게 향상시킬 수 있습니다. 사용자를 앱 내의 특정 콘텐츠로 원활하게 안내하는 바로 가기 역할을 하므로, 참여율을 높이고 판매를 촉진할 수 있습니다. iOS용 Universal Links 및 Android용 App Links를 사용하면 보안 및 사용자 친화성이 우수하다는 점에서 매우 권장되지만, 설정하는 데는 조금 까다로울 수 있습니다.\n\n최신 플러터 안정 버전에서는 DevTools 내에 안드로이드 앱의 웹 구성을 확인하는 딥 링크 유효성 검사 도구를 소개했습니다. 이 버전에서는 Android 매니페스트 파일 내 설정을 확인하는 데 도움이 되는 새로운 기능 세트를 추가했습니다.\n\n\n\n이 도구를 사용하는 방법에 대한 자세한 정보는 딥링크 유효성을 확인하십시오.\n\n## 예측 제스처 뒤로가기\n\n플러터는 이제 Android의 예상 제스처 뒤로가기 기능에 대한 더 많은 지원을 추가했습니다. 사용자는 백 제스처 중에 이전 경로나 이전 앱을 엿볼 수 있습니다. 이 기능은 아직 Android 기기에서 기능 플래그 뒤에 숨겨져 있지만, GitHub에서 직접 시도해 볼 수 있는 세부 정보를 찾을 수 있습니다.\n\n## Flutter 도구는 Gradle, AGP, Java 및 Kotlin에 대한 버전 요구 사항을 강제합니다.\n\n\n\n이번 릴리스에서 Flutter 도구는 Gradle, Android Gradle 플러그인 (AGP), Java 및 Kotlin의 지원 버전에 대한 정책을 강화합니다. 초기에는 도구가 경고만 제공합니다.\n\n현재 지원되는 버전 범위는 다음과 같습니다:\n\n- Gradle — Fully supported 7.0.2 to current, warn otherwise\n- AGP — Fully supported 7.0.0 to current, warn otherwise\n- Java — Fully supported Java 11 to current, warn otherwise\n- Kotlin — Fully supported 1.5.0 to current, warn otherwise\n\n다음 주요 릴리스에서는 이러한 경고가 오류로 전환되며, --android-skip-build-dependency-validation 플래그로 재정의할 수 있습니다. 보다 일반적으로 말하면, 도구는 이러한 종속성 버전의 완전한 지원을 중단하기 전에 적어도 한 릴리스에 대한 경고를 제공합니다.\n\n\n\n이 정책은 관련된 디자인 사양에서 논의되었습니다. 의견과 피드백은 언제나 환영합니다.\n\n## 안드로이드에서 Gradle 빌드 스크립트에서 Gradle Kotlin DSL 사용 지원\n\nGradle Kotlin DSL은 이제 플러터에서 지원되며 전통적인 Gradle Groovy DSL 대안을 제공합니다. 이 지원을 통해 더 나은 코드 편집 환경을 제공하여 자동 완성, 문서 빠른 액세스, 소스 탐색 및 컨텍스트 인식 리팩터링이 가능합니다.\n\n이 초기 지원은 GitHub 사용자 bartekpacia가 공헌했습니다. 개발자들은 이제 Gradle 빌드 스크립트를 코틀린으로 다시 작성하여 이러한 혜택을 누릴 수 있지만, 플러터 도구는 아직 flutter create를 사용할 때 코틀린을 그루비 대신 선택할 수는 없습니다.\n\n\n\n자세한 내용은 bartekpacia가 제출한 PR 140744을 확인해보세요.\n\n## 플랫폼 뷰 개선 사항\n\n플러터 앱 개발자 여러분, 주목하세요! Flutter를 사용하여 맵, 웹 뷰 또는 특정 UI 요소와 같은 네이티브 Android 구성 요소에 의존하는 앱을 개발 중이라면 중요한 소식이 있습니다.\n\nAndroid 14에서 발생하는 버그로 인해 이전 버전의 Flutter로 빌드된 앱은 이 새로운 Android 버전을 실행하는 기기에서 제대로 작동하지 않을 수 있습니다.\n\n\n\nFlutter 3.22은이 문제를 해결하고 안드로이드 앱의 네이티브 구성 요소의 전반적인 성능을 향상시킵니다. 따라서 모든 안드로이드 기기에서 앱이 원활하게 실행되도록하려면 Flutter 3.22로 앱을 다시 빌드하고 릴리스하십시오.\n\n이 업데이트에는 안드로이드에서 플랫폼 뷰를 더 신뢰할 수 있고 성능이 더 향상되도록하는 뒷면 개선사항도 포함되어 있습니다.\n\n## KitKat에 대한 지원 종료\n\nFlutter의 최소 지원 안드로이드 버전은 이제 Lollipop (API 21)입니다. Flutter의 3.22 안정 릴리스부터는 Android KitKat (API 19)를 실행하는 기기에서 더 이상 작동하지 않습니다. 자세한 내용은 당사의 폐기 안내서를 참조하십시오.\n\n\n\n# iOS\n\n## 플랫폼 뷰 성능\n\n우리는 iOS에서 플랫폼 뷰 성능이 많은 Flutter 개발자들에게 골칫거리였음을 이해합니다. 이는 특히 플랫폼 뷰를 사용할 때 스크롤 뷰 내에서 특히 두드러졌습니다.\n\n최근 업데이트는 이러한 우려사항에 직접 대응하여, 특히 기사 내에서 여러 인라인 광고를 포함하는 시나리오에서 상당한 향상을 이끌어냈습니다. 우리의 벤치마크에서 주요 향상점은 다음과 같습니다:\n\n\n\n- GPU 사용량 감소: GPU 사용량이 50% 감소하여 전력 소비가 줄어들고 사용자 경험이 원활해질 수 있습니다.\n- 프레임 렌더링 개선: 평균 프레임 렌더링 시간이 1.66ms(33%) 감소했습니다.\n- 지연 최소화: 최악의 경우 프레임 렌더링 시간이 3.8ms(21%) 줄었습니다.\n\n이전에 여러 플랫폼 뷰(광고, 지도 등)를 스크롤 뷰 내에서 사용할 때 성능에 도전이 있었다면, 이러한 최적화로 스르르르륵 하고 더 반응이 빠른 스크롤링 경험을 기대할 수 있습니다. 한 번 시도해보고 어떻게 생각하는지 알려주세요.\n\n<img src=\"/assets/img/2024-05-15-WhatsnewinFlutter322_2.png\" />\n\n<img src=\"/assets/img/2024-05-15-WhatsnewinFlutter322_3.png\" />\n\n\n\n# 생태계\n\n## Vertex AI for Firebase Dart SDK 미리보기 릴리스\n\nVertex AI for Firebase 제품이 공개 미리보기로 출시되었으며 Dart SDK를 포함하고 있습니다. 이를 통해 Gemini API를 활용하여 Dart 또는 Flutter 앱에 대한 생성적 AI 기능을 구축할 수 있습니다. 제작, 성능 및 기업 규모를 염두에 두었습니다. SDK는 Firebase App Check과 통합되어 API 호출을 보호하고 청구 사기, 피싱 및 앱 가장자리와 같은 심각한 위협으로부터 백엔드 인프라를 안전하게 보호합니다. Dart를 위한 시작하기 페이지로 이동하여 프로모션 코드를 사용하여 무료로 사용해 보세요.\n\n![](/assets/img/2024-05-15-WhatsnewinFlutter322_4.png)\n\n\n\nGoogle AI Dart SDK은 여전히 사용 가능하며, 프로토타입에 권장됩니다. Google AI는 무료로 액세스할 수 있으며(한계가 있을 수 있음), 과금 방식도 있습니다. Google AI Dart SDK로 프로토타입을 진행하고 있으며, Firebase용 Vertex AI로 마이그레이션 준비가 된 경우, 마이그레이션 가이드를 확인해보세요.\n\n## DevTools 업데이트\n\n우리는 Dart와 Flutter용 성능 및 디버깅 도구 모음인 DevTools를 계속 개선하고 있습니다. 이 릴리스에는 성능 향상, 일반적인 더 완만함, CPU 샘플을 타임란에 포함시키는 새로운 기능, 고급 필터링, 그리고 메모리 스냅샷 가져오기 및 내보내기 지원이 포함되어 있습니다.\n\n기타 주목할만한 개선점은 DevTools 확장 패키지와 DevTools 앱 공유 패키지에 포함되어 있으며, DevTools 확장 개발자를 지원합니다. 우리는 새로운 Dart Tooling Daemon(DTD)에 확장을 연결할 수 있는 지원을 추가했습니다. 이를 통해 DevTools 확장은 IDE와 같은 다른 DTD 클라이언트가 등록하는 공개 메서드에 액세스할 수 있으며, 개발 프로젝트와 상호 작용하기 위한 최소 파일 시스템 API에도 액세스할 수 있습니다.\n\n\n\n플러터 3.22에 포함된 모든 업데이트에 대해 알아보려면 DevTools 2.32.0, 2.33.0 및 2.34.1의 릴리스 노트를 확인해보세요.\n\n## 플러터용 Google Mobile Ads SDK\n\nFlutter 앱을 광고로 수익화하고 있는 경우, 좋은 소식이 있어요! Google Mobile Ads for Flutter가 버전 5.0.1로 주요 업데이트를 배포했습니다.\n\n사용자 메시지 플랫폼 (UMP) SDK 지원 강화: 이 업데이트는 안드로이드 UMP SDK 버전 2.2.0 및 iOS UMP SDK 버전 2.4.0의 최신 API를 지원합니다. UMP SDK는 개인정보 규정을 준수하는 데 중요하며, 사용자 동의를 얻는 것을 더 쉽게 할 수 있습니다. 이 새로운 버전은 동의 수집 프로세스를 간소화하는 몇 가지 새로운 API를 소개합니다.\n\n\n\n확장된 중재 파트너: 인기 있는 광고 파트너들과의 통합을 통해 여러분의 광고 수익 창출 가능성을 확장하였습니다. 이제 Unity, Meta, AppLovin, Iron Source, Mintegral, Pangle, DT Exchange, InMobi 및 Liftoff와의 통합을 통해 앱 수익을 극대화할 수 있습니다. 확장된 중재 옵션과 간소화된 구현으로 앱 수익을 극대화하세요.\n\n새로운 기능을 플러터 앱에서 시도해 보고, 어떤 중재 파트너를 지원했으면 하는지 알려주시기 바랍니다. 여러분의 피드백은 Google Mobile Ads SDK for Flutter를 개선하는 데 귀중합니다.\n\n# 변경 사항 및 폐기 사항\n\n## ColorScheme.fromSeed\n\n\n\n만약 ColorScheme.fromSeed에서 사용된 seedColor의 색감 값이 높다면, 생성된 ColorScheme은 생기발랄함이 부족한 파스텔 팔레트를 제공할 수 있습니다. 원하는 시드 색상의 느낌과 가장 일치하도록 출력 색상을 보장하려면 dynamicSchemeVariant를 DynamicSchemeVariant.fidelity 또는 DynamicSchemeVariant.content로 설정하는 것을 고려해보세요. 이러한 옵션은 원래 시드 색상과 더 가깝게 맞는 팔레트를 생성합니다.\n\n## v1 Android 임베딩 제거\n\n안드로이드 임베딩의 버전 1 삭제가 진행 중입니다. 대부분의 앱에는 아무런 영향을 미치지 않을 것으로 예상됩니다.\n\n- 버전 2가 많은 해 default 였습니다.\n- Flutter 도구는 이미 --ignore-deprecation 플래그로 명시적으로 무시하지 않은 한 버전 1 앱을 빌드하는 것을 막았을 것입니다.\n\n\n\n이 릴리스로 인해 v1 앱의 Flutter 도구 지원이 완전히 중단되었습니다. 더 이상 재정의할 수 없습니다.\n\n플러그인 작성자 여러분, 알려드립니다: 초기에 v1 안드로이드 삽입이 폐기되었을 때 플러그인 작성자를 위해 이주 문서가 작성되었습니다. 해당 문서는 https://docs.flutter.dev/release/breaking-changes/plugin-api-migration에서 확인할 수 있습니다. 이주 과정에서 v1 삽입을 사용하는 앱을 지원하는 것이 권장되었으며, 이를 위해 *Plugin.java에 다음과 같은 시그니처를 가진 메소드를 포함하는 것이 추천되었습니다.\n\npublic static void registerWith(@NonNull io.flutter.plugin.common.PluginRegistry.Registrar registrar)\n\n다음 릴리스에서 v1 Android 삽입을 완전히 삭제할 계획입니다. 그 시점에 이 시그니처를 포함하는 플러그인은 더 이상 컴파일되지 않을 것입니다(이는 v1 android 삽입에서의 타입을 참조하고 있기 때문입니다).\n\n\n\n현재 이 표는 아무 목적도 없습니다. 왜냐하면 이 릴리스로 인해 v1 임베딩을 사용하는 앱들이 작동하지 않게 되었습니다. 우리는 플러그인 저자들에게 가능한 빨리 업데이트된 플러그인 버전을 릴리스하여 v1 코드를 제거하기를 권장합니다. 이렇게 하면 향후 Flutter 버전에서의 문제를 피할 수 있습니다. 예를 들어, Flutter 팀이 유지보수하는 플러그인들을 제거한 PR 6494를 확인해보세요.\n\n## 3.22에서 제거된 사용 폐기사항들\n\n이번 릴리스에서의 중단 변경 사항에는 v3.19 이후 만료된 사용 폐기 API가 포함되어 있습니다. 영향을 받는 모든 API와 추가적인 맥락 및 이주 지침은 이번 릴리스의 폐기 안내서에서 확인할 수 있습니다. 이 중 많은 것들은 Flutter fix에 의해 지원되며, IDE에서 빠른 수정도 가능합니다. 대량 수정은 dart fix 커맨드 라인 도구를 사용하여 평가하고 적용할 수 있습니다.\n\n이러한 중단 변경 사항을 식별하는 데 도움을 주신 커뮤니티에게 항상 감사드립니다. 자세한 내용은 Flutter의 중단 변경 정책을 확인해보세요.\n\n\n\n# 결론\n\n플러터의 성공의 핵심은 여러분 - 우리 놀라운 커뮤니티입니다. 여러분의 끊임없는 기여와 열정이 없었다면 이번 릴리즈는 불가능했을 것입니다. 우리 마음속 깊은 곳에서 감사드립니다.\n\nFlutter 3.22를 탐험할 준비가 되셨나요? 전체 릴리스 노트와 변경 로그를 확인하고, 터미널을 켜고 flutter upgrade를 실행해보세요. 여러분이 어떤 것을 만들어내는지 기대됩니다!","ogImage":{"url":"/assets/img/2024-05-15-WhatsnewinFlutter322_0.png"},"coverImage":"/assets/img/2024-05-15-WhatsnewinFlutter322_0.png","tag":["Tech"],"readingTime":12},{"title":"잠금된 유동성 스테이킹","description":"","date":"2024-05-15 10:48","slug":"2024-05-15-LockedliquidityStaking","content":"\n\n\n![Locked Liquidity Staking](/assets/img/2024-05-15-LockedliquidityStaking_0.png)\n\n## 소개:\n\n토큰이 소각되거나 스테이킹되면 가격이 대부분 상승합니다. 문제는 USTC 홀더들이 토큰을 소각하도록 어떻게 인센티브를 제공할지입니다. 아마도 소각의 명백하고 돌이킬 수 없는 특성을 없애면서도 생태계 전반에 이익을 주는 대안 솔루션을 찾아야 할 것입니다. LUNC와 USTC가 커뮤니티 토큰이라면, 우리는 모두가 성공할 수 있도록 공동으로 행동할 수 있는 기회가 있습니다.\n\n# 잠긴 유동성 스테이킹:\n\n\n\n\nUSTC를 위탁/잠그면 순환 공급에서 제외됩니다. USTC 토큰은 가격이 설정된 페그보다 높을 때만 점차 잠금이 해제됩니다. 먼저 USTC를 위탁하시면 페그를 초과할 때 잠금이 해제된 다음 홀딩이 방출됩니다. 거래는 처음부터 순서대로 점진적으로 처리되므로 처음으로 위탁한 사람이 자동화된 프로세스에서 처음으로 잠금 해제됩니다. 여기서는 1달러의 예시를 들겠습니다. 가격이 1달러 이상으로 올라간다면, 먼저 USTC를 위탁한 사람이 자신의 잠금 홀딩이 페그를 안정화하고 1달러 가격을 유지하기 위해 점진적으로 방출/처리되는 첫 번째 대상이 됩니다. 가격이 1달러 이상으로 올라가면, USTC는 소액 이익을 위해 자동으로 잠금 해제되어 달러 가격을 다시 내리는 노력을 합니다. 자산을 잠그면 가격이 올라가는데, 페그를 넘으면 USTC가 해제되어 다음으로 USTC를 받을 대상에게 할당됩니다. 사용자들이 자산을 위탁/잠그도록 독려하기 위해, 위탁자들은 오라클 보상 풀에서 USTC로 보상받게 되며 이는 언제든지 사용 가능합니다. 이 노력을 통해 순환 공급을 낮추는 사람에게 보상이 주어지며, 보상/연간 이자율은 USTC가 페그 아래일 때 위탁하고 잠그도록 사용자들을 독려하는 방향으로 조정됩니다.\n\n다른 커뮤니티 회원의 제안에 따라 프로토콜을 보완하기 위해, 해제될 때 일부 USTC의 비율에 대한 소각이 설정됩니다. 하지만 이는 얻을 수 있는 이익에 기반합니다. 예를 들어, 페그가 1달러이고 가격이 1.20달러로 올라간 경우, 20%의 이익 중 10% 비율로 설정된 0.02달러가 소각됩니다. 이 투자자는 CEX 또는 DEX에서 판매하면 0.18달러의 이익을 얻게 됩니다. 상황에 따라 출금 지수를 더 높일 수도 있습니다.\n\n균형은 중요하며 유동성을 잠그는 것이 자산 가격을 안정시키는 데 도움이 될 수 있습니다. 토큰에 대한 신뢰가 높아진다면, 우리 생태계로 새로운 유동성이 들어오면 빠르게 새로운 수준을 달성할 수 있습니다. 훌륭한 커뮤니티 노력으로 USTC는 궁극적으로 유틸리티, 지위 및 신뢰를 되찾을 수 있습니다.\n\n\n\n\n![이미지](/assets/img/2024-05-15-LockedliquidityStaking_2.png)\n\n# USTC Staking 활성화:\n\nUSTC 스테이킹은 프로토콜의 주요 구성 요소 중 하나이므로 구현해야 합니다. 오라클 풀 내의 USTC는 USTC 스테이커들에게 전용되어야 하므로 USTC 스테이킹은 USTC 스테이커들에게만 USTC 보상을 제공할 것입니다. 따라서 USTC는 더 이상 Lunc 스테이커들에게 보상으로 제공되지 않을 것입니다. 이것은 일시적인 조치로 USTC를 재고정하기 위한 노력입니다.\n\n![이미지](/assets/img/2024-05-15-LockedliquidityStaking_3.png)\n\n\n\n\n이것은 초안임을 안내드립니다. 모든 것이 여전히 변동 사항이 많습니다. 이 제안서와 다음 부분은 커뮤니티에서 논의되어야 합니다.\n\n## 조기 언스테이킹을 허용하는 옵션:\n\n이겪에 대해 여전히 논의 중이지만, 락인된 USTC를 비정상적으로 언스테이킹할 수 있는 방법을 고려해왔습니다. 예를 들어, 스테이커들이 자동 언스테이킹 이전에 원한다면 언스테이킹할 수 있는 옵션을 제공할 수 있습니다. 그러나 이 경우 비용이 발생합니다. 이를 위해 20%의 세금이 부과됩니다. 10%는 소각되며, 10%는 오라클 보상 풀에 할당됩니다. 나머지 80%는 21일 후에 언스테이킹됩니다. 소각 및 오라클 보상 풀의 보충은 가격과 스테이킹 보상에 긍정적인 영향을 미칠 수 있습니다.\n\n## 프로토콜이 성공하지 못할 경우:\n\n\n\n현재 상태로 다시 돌아갑니다.\n\n모든 스테이크된 Ustc는 언스테이크되며 보유자들이 자산을 회수합니다.","ogImage":{"url":"/assets/img/2024-05-15-LockedliquidityStaking_0.png"},"coverImage":"/assets/img/2024-05-15-LockedliquidityStaking_0.png","tag":["Tech"],"readingTime":3},{"title":"코틀린에서의 DRY 원칙 코드 품질과 유지보수성 향상","description":"","date":"2024-05-15 10:46","slug":"2024-05-15-TheDRYPrincipleinKotlinEnhancingCodeQualityandMaintainability","content":"\n\n![image](/assets/img/2024-05-15-TheDRYPrincipleinKotlinEnhancingCodeQualityandMaintainability_0.png)\n\nDRY(반복하지 말 것) 원칙은 코드 중복을 피하고 코드 재사용을 촉진하는 소프트웨어 개발의 기본 개념입니다. 이 원칙은 시스템 내의 모든 지식 요소가 단일하고 명확한 표현을 가져야 한다고 주장합니다. 간단히 말하면, 동일한 논리 또는 정보가 코드베이스의 여러 위치에 중복되어 나타나지 않아야 한다는 것을 의미합니다.\n\nDRY 원칙은 공통 기능을 함수, 클래스 또는 모듈과 같은 재사용 가능한 구성 요소로 추상화하는 것을 개발자에게 권장합니다. 이렇게 함으로써, 개발자는 변경이나 업데이트를 한 곳에서만 수행하면 되므로 유지보수가 쉬운 코드를 작성할 수 있습니다. 이는 일관성과 오류 발생 가능성을 감소시키면서 코드의 가독성과 이해도를 향상시킵니다.\n\nDRY 원칙을 준수하면 모듈성, 캡슐화, 추상화와 같은 더 나은 소프트웨어 디자인 관행을 촉진합니다. 이는 유지보수와 확장, 디버그 및 협업이 쉬운 더 깔끔하고 관리하기 쉬운 코드베이스를 만드는 데 도움이 됩니다.\n\n\n\n## DRY 원칙이 필요한 이유는 무엇인가요?\n\n- 코드 유지보수성: 코드 중복은 유지보수 부담을 증가시킵니다. 동일한 코드 논리가 여러 곳에 복사되면 해당 논리를 수정하거나 업데이트해야 하는 경우 여러 위치에서 변경이 필요하며, 일관성 및 오류 발생 위험이 증가합니다. Kotlin에서 DRY 원칙을 준수하면 변경 사항을 하나의 위치에서만 수행해야 하므로 코드 유지보수가 더 쉬워집니다.\n- 버그와 오류 감소: 중복된 코드는 버그와 오류 발생 가능성을 증가시킵니다. 중복된 코드의 한 부분에서 버그가 수정되지만 다른 곳에서는 수정되지 않으면 일관성 문제가 발생하여 예기치 않은 동작을 야기할 수 있습니다. Kotlin 코드에서 DRY 원칙을 준수하면 코드 논리를 중앙 집중화하여 일관성 문제로 인한 버그 발생 가능성을 최소화합니다.\n- 가독성 및 이해도 향상: 중복된 코드는 코드의 가독성과 이해도를 저해합니다. 동일한 논리가 코드베이스 전체에 흩어져 있으면 시스템의 전반적인 기능과 목적을 파악하기가 어려워집니다. DRY 원칙을 따르고 논리를 통합함으로써 Kotlin 코드를 더 읽기 쉽고 이해하기 쉽게 만듭니다.\n- 모듈성과 재사용성 촉진: DRY 원칙을 준수하면 모듈화되고 재사용 가능한 구성 요소를 생성하는 것을 촉진합니다. 동일한 논리를 여러 곳에 반복하는 대신 Kotlin 개발자들은 공통 기능을 별도의 모듈, 함수 또는 클래스로 추출하도록 권장받습니다. 이는 구성 요소가 코드베이스 전반에서 재사용될 수 있는 모듈화 아키텍처를 촉진합니다.\n\n## Kotlin에서 DRY 원칙 적용 예:\n\n1. 공통 기능을 함수나 확장 함수로 추출하기\n\n\n\n```kotlin\n// DRY 원칙 없이: 특정 모양에 대한 함수\nfun calculateCircleArea(radius: Double): Double {\n    return Math.PI * radius * radius\n}\n\nfun calculateRectangleArea(width: Double, height: Double): Double {\n    return width * height\n}\n\n// DRY 원칙을 적용한 경우: 면적을 계산하는 일반적인 함수\nfun calculateArea(shape: Shape): Double {\n    return when (shape) {\n        is Circle -> Math.PI * shape.radius * shape.radius\n        is Rectangle -> shape.width * shape.height\n    }\n}\n```\n\n서로 다른 모양의 면적을 계산하기 위해 별도의 함수를 갖는 대신, 입력으로 Shape 객체를 받아 해당 형태의 면적을 계산하는 calculateArea라는 단일 함수를 생성합니다. 이 접근 방식은 코드 중복을 제거하고 재사용성을 증진시킵니다.\n\n2. 고차 함수 활용:\n\n```kotlin\n// DRY 원칙 없이\nfun applyOperationTwice(value: Int, operation: (Int) -> Int): Int {\n    return operation(operation(value))\n}\n\n// DRY 원칙을 적용한 경우\nfun applyOperationTwice(value: Int, operation: (Int) -> Int): Int {\n    return operation(value).let(operation)\n}\n```\n\n\n\napplyOperationTwice 함수에서는 DRY 원칙을 사용하여 let 함수를 사용하여 처음 호출 결과에 작업을 호출합니다. 이 접근법은 가독성을 향상시키고 작업이 적용되는 방식을 일관성있게 유지합니다.\n\n3. 상수 공유:\n\n```js\n// DRY 원칙 미적용: 전역으로 상수 선언\nconst val MAX_RETRIES = 3\nconst val TIMEOUT = 5000\n\n// DRY 원칙 적용: 상수를 객체에 그룹화\nobject Constants {\n    const val MAX_RETRIES = 3\n    const val TIMEOUT = 5000\n}\n```\n\n전역으로 상수를 선언하는 대신, 관련 있는 상수를 객체 내에 그룹화하여 DRY 원칙을 적용합니다. 이 접근법은 상수를 논리적으로 구성하고 네임스페이스 오염을 방지합니다.\n\n\n\n4. 재사용 가능한 데이터 구조:\n\n```js\n// DRY 원칙 없이: 각 모양에 대한 별도의 클래스\nclass Rectangle(val width: Double, val height: Double)\n\nclass Circle(val radius: Double)\n\n// DRY 원칙을 적용한 경우: 공유된 베이스 클래스와 데이터 클래스\nsealed class Shape\n\ndata class Rectangle(val width: Double, val height: Double) : Shape()\n\ndata class Circle(val radius: Double) : Shape()\n```\n\n공유된 베이스 클래스 Shape를 정의하고 이를 기반으로 Rectangle 및 Circle과 같은 특정 모양을 파생시킴으로써 DRY 원칙이 적용됩니다. 이 접근 방식은 코드 재사용을 촉진하고 모양이 어떻게 표현되는지에 일관성을 유지합니다.\n\n5. 비즈니스 로직 공유:\n\n\n\n```js\n// DRY 원칙을 적용한 예시: 공통 구현 로직을 캡슐화한 베이스 매니저 클래스\nclass BaseManager<T>(private val repository: BaseRepository<T>) {\n    fun addItem(item: T) {\n        if (repository.getItemById(item.id) == null) {\n            repository.addItem(item)\n        }\n    }\n}\n\n// UserManager과 ProductService와 같은 특정 매니저 클래스들은 BaseManager를 상속하여 이 공통 로직을 재사용하며, 코드 중복을 줄이고 일관성을 유지합니다.\n\n# DRY 사용 시 고려할 점:\n\n- 너르 도구 되기 전에: 코드 중복과 추상화 사이의 균형을 맞추는 것이 중요합니다. 때때로 일반 로직을 너무 이르게 추출하면 이해하기 어렵고 유지보수하기 어려운 지나치게 복잡한 추상화로 이어질 수 있습니다. 진정으로 재사용 가능한 경우에만 코드를 추상화해야 합니다.\n- 의미 있는 명명: 재사용 가능한 구성요소로 코드를 추출할 때, 함수, 클래스 또는 모듈에 서술적이고 의미 있는 이름을 선택해야 합니다. 명확한 명명은 다른 개발자가 코드의 의도와 목적을 이해하기 쉽도록 도와줍니다.\n- 함수 일관성 유지: 재사용 가능한 함수 또는 클래스를 작성할 때, 단일 책임을 갖고 명확한 작업을 수행하는지 확인해야 합니다. 하나의 함수 또는 클래스에 관련 없는 기능을 섞는 것은 혼란을 초래하고 단일 책임 원칙(SRP)을 위반할 수 있습니다.\n- 트레이드오프 고려: 중복을 줄이는 것은 일반적으로 유익하지만, 때로는 더 명확하고 유지보수가 쉬운 코드를 만들기 위해 약간의 중복이 허용될 수 있습니다. DRY성과 단순성 및 명료성과 같은 다른 소프트웨어 설계 원칙 간의 트레이드오프를 고려해야 합니다.\n- 문서화와 주석: 재사용 가능한 구성 요소의 목적과 사용법을 문서화하여 다른 개발자가 올바르게 사용하는 데 도움을 줄 수 있습니다. 또한 코드 내 복잡하거나 명확하지 않은 로직을 설명하는 주석을 제공해야 합니다.\n```\n\n\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해주시면 좋겠어요! 👏\n- 저희를 팔로우해주세요 X | 링크드인 | 유튜브 | 디스코드\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘적 콘텐츠를 다루어야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-15-TheDRYPrincipleinKotlinEnhancingCodeQualityandMaintainability_0.png"},"coverImage":"/assets/img/2024-05-15-TheDRYPrincipleinKotlinEnhancingCodeQualityandMaintainability_0.png","tag":["Tech"],"readingTime":5},{"title":"안녕하세요 HTML 안녕하세요","description":"","date":"2024-05-15 10:45","slug":"2024-05-15-ripHTMLrip","content":"\n\n## JavaScriptUI — DevBlog #2\n\n얼마 전에 미친 아이디어가 떠올랐어요: HTML 없이 웹사이트를 만들 수 있을까?\n\n아니요, 제가 말하는 것은 새로운 브라우저 엔진을 만드는 것이나 캔버스를 사용하여 콘텐츠를 표시하는 것이 아닙니다. 또한 WebAssembly나 HTML로 컴파일된 새 언어를 사용하는 것이 아닙니다. 제가 말하는 것은 오늘날 어떤 브라우저에서도 즉시 실행되는 완전히 기능적인 웹사이트를 작성하는 방법입니다. 그것도 HTML 한 줄을 작성하지 않고요.\n\n실은 가능합니다. 그리고 지금 바로 수행하기 까다롭지도 않아요. 우리는 그저 JavaScript의 DOM API를 맹공하면 되는 것 뿐입니다. 확실히 여전히 브라우저 안에서 약간의 HTML을 생성하지만 그건 당장 무시해도 되는 구현 세부사항입니다. 필요한 건 DOM 뿐이에요. 그러니 JavaScript로 생성된 웹사이트의 세계로 뛰어들어 모든 최선의 방법을 위반해 보죠.\n\n\n\n## Views 및 View 트리\n\n어떤 것을 만들기 위해서는 객체가 필요합니다. 기본 옵션은 document.createElement()을 사용하여 HTML 요소를 만들고, Element.prototype.append() 또는 Node.prototype.appendChild()를 사용하여 이후에 DOM에 추가하는 것입니다. 꽤 기본적인 방법이지만 불편하고 지저분하며 혼란스럽습니다. 더 나은 방법이 있습니다.\n\n그 대신, Image, Text 및 Stack과 같은 선언적 생성자를 정의하고 이를 Views(뷰)라고 부르겠습니다. 이들은 여전히 DOM API에 의존하지만 더 나은 선언적 구문을 제공할 수 있습니다. 예를 살펴보세요:\n\n```js\nStack(\n  Text(\"Hello World!\"),\n  Stack(\n    Text(\"Everyone has a plumbus in their home.\"),\n    Image(\"plumbus.jpeg\")\n  )\n);\n```\n\n\n\n이 점이 아름다운 이유입니다. 이는 유효한 JavaScript입니다. 우리는 단순히 일부 View 생성자를 호출하고 그들의 자식들을 인수로 제공합니다. 결국 어떤 View 트리도 우리가 사용하는 언어와는 무관하게 중첩된 목록일 뿐입니다.\n\n다른 이점은 사용자 정의 된 Views를 생성할 수 있으므로 Safari가 사용자 지정 내장 요소를 구현하기 위해 또 하나의 10년을 기다릴 필요가 없습니다. 또는 의미를 잃어버린 것에 분개하고 있다면, 적절한 HTML 요소에 매핑되는 Views를 생성할 수도 있습니다:\n\n```js\nDiv(\n  Div(\n    Div(\n      Div(),\n      Div(),\n      Div()\n    )\n  )\n);\n```\n\n## 절대 \"new(er)\" 라고 말하지 마세요\n\n\n\n새로운 키워드를 View 생성자 앞에 사용하지 않은 이유는 두 가지 있어요. 첫째, 나무들이 아주 빠르게 아주 커질 수 있기 때문에, 더 짧은 구문을 사용하면 가독성이 향상됩니다. 둘째, JavaScript에는 이미 Image나 Text와 같은 생성자들이 있어서, 이러한 이름들이 필요합니다. 다행히도, 대부분의 내장 생성자들은 new 키워드와 함께만 작동하므로, 이론적으로 자체 작성한 기능을 추가하면서도 이 기능을 유지할 수 있습니다.\n\n```js\nnew Image(width, height); // HTMLImageElement을 생성합니다 (기본 동작)\nImage(url); // Image View를 생성합니다 (JavaScriptUI)\n```\n\n## 논리의 마법\n\n이제 진정한 재미가 시작되는 부분이죠. 우리는 JavaScript에서 HTML을 그대로 따르는 것이 아니라, 그 이상의 기능을 구현할 수 있어요. 이제 우리는 진정한 프로그래밍 언어의 영역에 들어왔으니 변수, 연산자, 조건문, 반복문, 일급 함수 등을 활용하여 원하는 것을 무엇이든 만들 수 있습니다. 심지어 조건적 할당처럼 간단한 기능조차 HTML의 능력을 크게 뛰어넘는 것이죠:\n\n\n\n```js\nStack(\n  yourChoice ? Text(\"red pill\") : Text(\"blue pill\")\n);\n```\n\n이제, FizzBuzz가 일부 불행한 CSS 애호가들에게 상처를 줄 수 있다는 것을 이해했어요. 하지만 함수, 연산자, 반복문 및 조건문은 매우 간단하고 범용적이며 강력한 빌딩 블록으로, 더 나아가게 하는 데 도움이 되는 것들이에요. 간단한 콜백 함수로 다음과 같은 작업들을 수행할 수 있어요:\n\n```js\nStack(function* () {\n\n  let i = 1;\n  while (i <= 100) {\n\n    if ((i % 15) === 0) {\n      yield Text(\"FizzBuzz\");\n\n    } else if ((i % 3) === 0) {\n      yield Text(\"Fizz\");\n\n    } else if ((i % 5) === 0) {\n      yield Text(\"Buzz\");\n\n    } else {\n      yield Text(i);\n    }\n\n    i += 1;\n  }\n});\n```\n\n제너레이터 구문에 대해 걱정하지 마세요. 여기서는 함수에서 여러 값을 선언적으로 반환하기 위해 사용했어요. View 생성자에서 약간의 속임수를 사용하여 일반 함수로도 동일한 작업을 수행할 수 있지만, 이제 이 콜백이 바닐라 JavaScript에서 기대하는 것과 약간 다르게 작동한다는 점에 주의해야 해요:\n\n\n\n```js\nStack(() => {\n\n  let i = 1;\n  while (i <= 100) {\n\n    if ((i % 15) === 0) {\n      Text(\"FizzBuzz\"); // Stack에 추가\n\n    } else if ((i % 3) === 0) {\n      Text(\"Fizz\"); // Stack에 추가\n\n    } else if ((i % 5) === 0) {\n      Text(\"Buzz\"); // Stack에 추가\n\n    } else {\n      Text(i); // Stack에 추가\n    }\n\n    i += 1;\n  }\n});\n```\n\n또는 블록 없이 조건문을 사용하기를 원하신다면, 이렇게 써도 돼요:\n\n```js\nStack(() => {\n\n  let i = 1;\n  while (i <= 100) {\n\n    if (i % 15 === 0) Text(\"FizzBuzz\");\n    else if (i % 3 === 0) Text(\"Fizz\");\n    else if (i % 5 === 0) Text(\"Buzz\");\n    else Text(i);\n\n    i += 1;\n  }\n});\n```\n\n더 이상 선언적으로 할 수 있는 게 없네요.\n\n\n\n\n하지만 더 나아가면 더 나아갑니다. View 생성자는 콜백에 인수를 제공하거나 this 컨텍스트를 자체로 설정하거나 UI 구축의 여러 불편한 측면을 추상화하기 위해 반응 시스템을 구현할 수도 있습니다. 현재 가능한 것과 불가능한 것에 대한 간단한 개요입니다.\n\n```js\nStack((argument) => {\n\n  this; //상위 항목에 접근 가능\n\n  argument; //인수 작동(View 생성자 내에서 미리 정의됨)\n  \n  //myView; //뷰 참조는 작동하지 않음\n  \n  Text(\"foo\"); //일반적인 자식 추가는 작동함\n  \n  let view = Text(\"temp\"); //변수 할당은 작동하지만 새로 생성된 뷰는 자동으로 부모에 추가됨\n  \n  evaluate ? Text(\"foo\") : Text(\"bar\"); //삼항 연산자는 작동함\n  \n  if (\n      evaluate //조건문도 작동\n  ) {\n      Text(\"foo\");\n  } else {\n      Text(\"bar\");\n  }\n  \n  let i = 0;\n  while (i < 5) {\n      Text(\"foo\"); //루프 작동\n      i += 1;\n  }\n});\n```\n\n## 이것이 JavaScriptUI입니다.\n\n이것이 JavaScriptUI의 기초입니다. 내 목표는 HTML 및 CSS의 모든 기능을 직접 JavaScript로 이관하여 기본 브라우저 API 및 일반 목적 프로그래밍 언어의 방대한 기능을 활용하는 것입니다.\n\n\n\n매주 새로운 글을 게시해 여러분을 최신 정보로 업데이트하고 제 진전을 공유하려 합니다 (아무도 안 읽어준다면 제 자신을 위로하기 위한 글이겠지요 😄). 곧 여러분께 작동하는 코드 몇 줄을 보여드릴 수 있기를 희망하며, 여러분도 관심이 있으시다면 함께 즐기시길 바랍니다.\n\n그동안 제 글을 즐겨주신다면 박수쳐 주시고, 의견을 남기고 DevBlog를 관심 있는 사람들과 공유해 주세요.\n\n감사합니다! 그리고 계속해서 기대해 주세요.\n\n⬅️ 자바스크립트UI — DevBlog #1, HTML과 CSS 없이 새로운 웹 페이지","ogImage":{"url":"/assets/img/2024-05-15-ripHTMLrip_0.png"},"coverImage":"/assets/img/2024-05-15-ripHTMLrip_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트 UI - HTML 및 CSS 없이 새 웹을 만나보세요","description":"","date":"2024-05-15 10:44","slug":"2024-05-15-JavaScriptUIanewwebwithoutHTMLandCSS","content":"\n\n## 자바스크립트 UI — 개발 블로그 #1\n\n👋 안녕하세요, 웹 열정가 여러분!\n\n새로운 웹에 대한 개념에 대해 쓴 지 꽤 오래됐죠. 그러나 약속했던 대로, 저는 여러분을 새로운 개발 블로그에 초대하고 싶어요. 여기서는 제가 지난 6년 동안 언급해 온 것을 실제로 구축하는 여정을 문서화할 거에요.\n\n그래서 정확히 무엇일까요?\n\n\n\n웹, 특히 프론트 엔드가 점점 더 번잡해져서 웹 개발에 입문하는 많은 사람들을 두렵게 만들고 있다고 느껴요. 백 엔드 프로그래머, 그래픽 디자이너 또는 새로운 입문자들이 수많은 프레임워크, 도구, 라이브러리, 심지어 기본적인 HTML과 CSS조차 혼란스럽고 어설퍼 느껴 이를 포기하는 이야기를 많이 들었어요. 그렇다고 해서 포기하지 마세요. 제가 해결책이 있다고 믿어요.\n\n그렇다면 당신의 해결책은 뭐에요, 똑똑이?\n\n음, 그렇고 말고요.\n\n가장 좋은 해결책은 쓰레기를 처리하고 핵심 웹 언어가 어떻게 작동하는지 재설계하는 것이겠지만, 이미 얼마나 복잡하고 중요한지 알려져 있기 때문에 이를 제안하는 사람이 없을 거예요. 그래서 다음으로 좋은 방법을 선택하겠어요: 작은 JavaScript 라이브러리(원할 경우 폴리필로도 사용 가능)를 작성해서 프론트 엔드 개발이 얼마나 더 효율적일 수 있는지 보여줄 거에요. 이 라이브러리를 사용하면 누구나, 심지어 초보자도 HTML 또는 CSS 지식 없이도 웹사이트를 완전히 사용자 정의하여 구축할 수 있습니다. 또한 추가 도구, 프레임워크, 컴파일러, 트랜스파일러, 번들러 또는 어떠한 종속성도 없이 진행될 거에요. 딱 한 가지 라이브러리와 순수한 JavaScript만으로 가능합니다.\n\n\n\n매주 다른 프론트엔드 개념을 분석하고, 현재 구현의 문제점을 설명하며, 인간의 직관과 이미 잘 알려진 문제 해결을 기반으로 더 나은 해결책을 시범하는 것이 목표입니다. 제가 뭔가를 추가한다면 이미 넘치는 혼돈의 더미 위에 또 다른 추상화 층이 쌓이는 것을 피하기 위해 뭔가를 제거합니다.\n\n이 라이브러리는 이미 존재하는 많은 프론트엔드 개발자들에게 엄청난 가치를 제공할 수 있다고 생각하지만, 이를 구축하는 것 또한 방대한 작업이 될 것입니다. 제 작품에 흥미를 느끼셨다면, 박수를 보내주시고, 댓글을 달아주시고, 관심 있는 사람들과 함께 내 DevBlog를 공유해주시면 정말 고맙겠습니다.\n\n아 그리고 한 가지 더, 이것은 소개일 뿐이니까 두 번째 기사도 올려두었습니다. 이번에는 좀 더 기술적인 내용이 담겨 있습니다. 여기서 읽을 수 있습니다.\n\n감사합니다. 즐겁게 읽으시길 바랍니다.\n\n\n\nJavaScriptUI — DevBlog #2, HTML 태그 ➡️","ogImage":{"url":"/assets/img/2024-05-15-JavaScriptUIanewwebwithoutHTMLandCSS_0.png"},"coverImage":"/assets/img/2024-05-15-JavaScriptUIanewwebwithoutHTMLandCSS_0.png","tag":["Tech"],"readingTime":2}],"page":"92","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}