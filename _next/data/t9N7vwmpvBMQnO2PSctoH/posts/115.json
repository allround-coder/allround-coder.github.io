{"pageProps":{"posts":[{"title":"ASPNET MVC 프로젝트에 React 애플리케이션 통합하기 단계별 가이드","description":"","date":"2024-05-14 11:11","slug":"2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide","content":"\n\n소개: 웹 개발 분야에서, React와 같은 현대적인 JavaScript 프레임워크를 전통적인 MVC (Model-View-Controller) 응용 프로그램에 통합하는 것이 일반적인 실천 방법이 되었습니다. 이러한 통합을 통해 개발자들은 React의 구성 요소 기반 아키텍처의 강점을 ASP.NET MVC의 익숙한 구조 내에서 활용할 수 있습니다. 이 안내서에서는 React 애플리케이션을 ASP.NET MVC 프로젝트에 매끄럽게 통합하는 과정을 안내하겠습니다.\n\nCreate React App: 먼저 create-react-app이나 기타 선호하는 방법을 사용하여 React 애플리케이션을 설정하세요.\n\n필수 패키지 설치: 아래 명령을 실행하여 React 개발에 필요한 패키지를 설치하세요:\n\n- npm install react react-dom\n- npm install — save-dev babel-core babel-loader @babel/preset-react @babel/preset-env\n- npm install babel-polyfill\n- npm install — save-dev webpack webpack-cli\n\n\n\n웹팩 구성하기: 루트 폴더에 webpack.config.js 파일을 생성하고 제공된 구성 코드를 붇여넣어주세요.\n\n```js\nconst path = require('path');\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n        },\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.js', '.jsx'],\n  },\n  externals: {\n    react: 'React', \n    'react-dom': 'ReactDOM', \n  },\n};\n```\n\nBabel 구성: 루트 폴더에 .babelrc 파일을 생성하고 Babel을 위한 제공된 프리셋을 추가해주세요.\n\n```js\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]\n}\n```\n\n\n\nESLint 구성 (선택 사항): 린팅 이슈가 발생하면, .eslintrc.json 파일을 만들고 지정된 대로 구성하세요.\n\n```js\n   // .eslintrc.json\n   {\n       \"env\": {\n         \"browser\": true,\n         \"es2021\": true,\n         \"node\": true\n       },\n       \"extends\": \"eslint:recommended\",\n       \"parserOptions\": {\n         \"ecmaVersion\": 12,\n         \"sourceType\": \"module\"\n       },\n       \"rules\": {\n         // 여기에 다른 규칙을 추가하세요\n       },\n       \"globals\": {\n         \"React\": \"writable\",\n         \"ReactDOM\": \"writable\",\n         \"createRoot\": \"writable\"\n       }\n     }\n```\n\nPackage.json 업데이트: package.json의 스크립트 섹션에 \"wpb\": \"webpack\"을 추가하세요.\n\n![이미지](/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_0.png)\n\n\n\n리액트 앱 컴파일: 리액트 애플리케이션을 컴파일하려면 npm run wpb를 실행하세요. 이렇게 하면 지정된 dist 폴더에 bundle.js 파일이 생성됩니다.\n\n리액트 폴더 구조는 다음과 같이 보일 것입니다:\n\n![React Folder Structure](/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_1.png)\n\n# MVC 애플리케이션 설정하기\n\n\n\nMVC 애플리케이션 생성: 먼저 Visual Studio나 선호하는 다른 IDE에서 새 ASP.NET MVC 애플리케이션을 생성해보세요.\n\n.cshtml 파일 업데이트: 렌더링하려는 React 컴포넌트를 포함하고자 하는 .cshtml 파일을 열어주세요.\n\n폴더 구조 생성: MVC 앱 내에서 컴파일된 React JS 파일을 저장할 폴더를 생성하세요. 그리고 React 앱에서 생성된 bundle.js 파일을 해당 폴더에 넣어두세요. (예: wwwroot/dist)\n\nReact 파일 참조: .cshtml 파일에서 React 종속성 및 컴파일된 bundle.js 파일을 참조하도록 다음 코드 스니펫을 포함해주세요:\n\n\n\n```jsx\n<div id=\"root\"></div>\n```\n\n## Scripts\n```html\n<script src=\"https://unpkg.com/react@18/umd/react.development.js\"></script>\n<script src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\"></script>\n<script src=\"~/dist/bundle.js\"></script>\n```\n\n![Illustration](/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_2.png)\n\n# 결과:\n\nMVC 애플리케이션 실행...완료!\n\n\n\n\n![이미지](/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_3.png)\n\n결론: 이 단계별 지침을 따르면 React 응용 프로그램을 ASP.NET MVC 프로젝트에 원활하게 통합할 수 있습니다. 이 접근 방식을 통해 React의 컴포넌트 기반 아키텍처의 이점을 활용하면서 서버 측 렌더링 및 비즈니스 로직 처리에 ASP.NET MVC의 견고함을 활용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"React에서 JSON 객체를 Excel 파일로 내보내는 방법 완벽한 가이드","description":"","date":"2024-05-14 11:10","slug":"2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide","content":"\n\n<img src=\"/assets/img/2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide_0.png\" />\n\n## 소개 🌟\n\n리액트 개발자들은 종종 데이터를 다양한 형식으로 변환하고 다운로드해야 합니다. 현대 웹 개발에서 공통이지만 필수적인 작업 중 하나는 JSON 객체를 Excel 파일로 내보내는 것입니다. 이 안내서는 이 프로세스를 간단하게 만들어 React 애플리케이션에서 JSON 데이터를 빠르게 변환하고 다운로드하는 방법을 안내합니다. 초보자부터 경험 많은 개발자까지 모두에게 적합하며, 이 튜토리얼은 XLSX와 FileSaver와 같은 인기 있는 라이브러리를 사용하여 애플리케이션의 데이터 처리 기능을 향상시킵니다.\n\n시작하기 전에, 제 개인 웹사이트에서 웹 개발에 대한 더 깊이있는 기사들을 살펴보세요:\n\n\n\n## 라이브러리 이해하기: XLSX 및 FileSaver 📚\n\n코드를 시작하기 전에 사용할 라이브러리를 간단히 살펴보겠습니다. XLSX는 웹 애플리케이션에서 엑셀 작업을 다루는 인기 있는 라이브러리로, 엑셀 문서를 읽고 조작하며 작성할 수 있게 해줍니다.\n\nFileSaver는 클라이언트 측에서 파일을 저장하는 데 유용한 다른 라이브러리로, 변환된 엑셀 파일을 다운로드하기에 이상적입니다. 이러한 라이브러리들은 JSON 데이터를 React 환경에서 엑셀 파일로 내보내는 데 원활한 방법을 제공합니다.\n\n## 단계 1: XLSX 라이브러리 설치 및 가져오기 ⚙️\n\n\n\nReact에서 Excel 파일을 다루려면 XLSX 라이브러리를 사용합니다. 먼저 npm을 사용하여 React 프로젝트에 설치해야 합니다:\n\n```js\nnpm install xlsx file-saver\n```\n\nfile-saver 패키지는 파일 다운로드를 트리거하는 데 도움을 줍니다. 다음으로 이 라이브러리들을 React 컴포넌트에 가져옵니다:\n\n```js\nimport * as XLSX from 'xlsx';\nimport { saveAs } from 'file-saver';\n```\n\n\n\n## Step 2: JSON 데이터 준비하기 📊\n\n내보내기 전에 JSON 데이터가 올바르게 구조화되어 있는지 확인하세요. 예를 들어, 각 객체가 엑셀의 행을 나타내는 JSON 배열을 고려해보세요:\n\n```js\nconst data = [\n    { name: \"John\", email: \"john@example.com\", age: 28 },\n    { name: \"Jane\", email: \"jane@example.com\", age: 32 }\n];\n```\n\n## Step 3: 내보내기 함수 정의하기 🚀\n\n\n\n편리하게 사용할 수 있도록 React 컴포넌트 내에서 내보내기를 처리하는 함수를 만들어보세요. 해당 함수는 JSON 데이터를 Excel 형식으로 변환하고 다운로드를 시작할 것입니다:\n\n```js\nconst exportToExcel = () => {\n    const worksheet = XLSX.utils.json_to_sheet(data);\n    const workbook = XLSX.utils.book_new();\n    XLSX.utils.book_append_sheet(workbook, worksheet, \"Sheet1\");\n\n    // 생성된 Excel 파일을 저장할 버퍼\n    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });\n    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' });\n\n    saveAs(blob, \"data.xlsx\");\n};\n```\n\n## Step 4: 내보내기 버튼 만들기 🔘\n\nReact 컴포넌트 내에서 클릭되었을 때 exportToExcel 함수를 호출하는 버튼을 추가해보세요:\n\n\n\n```js\n<button onClick={exportToExcel}>Excel로 내보내기</button>\n```\n\n## Step 5: JSON을 Excel로 내보내는 컴포넌트 완성 ✅\n\n이번 단계에서는 모든 부분을 모아 완전히 작동하는 React 컴포넌트로 조립합니다. 이 컴포넌트를 사용하면 사용자가 간단한 버튼 클릭으로 JSON 데이터를 Excel 파일로 내보낼 수 있습니다.\n\n```js\nimport React from 'react';\nimport * as XLSX from 'xlsx';\nimport { saveAs } from 'file-saver';\n\nfunction ExcelExportComponent() {\n    const data = [\n        { name: \"John\", email: \"john@example.com\", age: 28 },\n        { name: \"Jane\", email: \"jane@example.com\", age: 32 },\n        // ... 더 많은 데이터\n    ];\n\n    const exportToExcel = () => {\n        const worksheet = XLSX.utils.json_to_sheet(data);\n        const workbook = XLSX.utils.book_new();\n        XLSX.utils.book_append_sheet(workbook, worksheet, \"시트1\");\n\n        // 생성된 Excel 파일을 저장할 버퍼\n        const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });\n        const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' });\n\n        saveAs(blob, \"exportedData.xlsx\");\n    };\n\n    return (\n        <div className=\"App\">\n            <button onClick={exportToExcel}>Excel로 내보내기</button>\n        </div>\n    );\n}\n\nexport default ExcelExportComponent;\n```\n\n\n\n이 컴포넌트를 React 앱에 통합하고 'Excel로 내보내기' 버튼을 클릭하면 데이터 배열이 Excel 파일로 변환되어 컴퓨터로 다운로드됩니다. 이 컴포넌트는 React 애플리케이션 내에서 내보내기 기능을 어떻게 처리하는지 효과적으로 보여줍니다.\n\n## 실행과 출력 📈\n\nExcelExportComponent를 React 앱에 통합하면 쉽게 기능을 테스트할 수 있습니다. 애플리케이션을 실행하고 'Excel로 내보내기'라고 표시된 버튼이 있는 것을 볼 수 있습니다. 이 버튼을 클릭하면 exportedData.xlsx라는 이름의 Excel 파일이 다운로드되며 JSON 데이터가 스프레드시트로 포맷되어 있습니다.\n\n실제 시나리오에서 이 컴포넌트의 작동을 명확히 이해할 수 있도록 CodeSandbox의 실시간 데모를 확인해보세요. 이 상호 작용 예제를 통해 컴포넌트를 실제로 볼 수 있고 코드를 탐색하여 실제 시나리오에서의 작동 방식을 명확히 이해할 수 있습니다.\n\n\n\n## 결론 🎯\n\n이 가이드는 React에서 JSON을 Excel로 내보내는 과정을 간소화하여 웹 애플리케이션에서 데이터 처리에 대한 효과적인 해결책을 보여줍니다. 제공된 단계들과 라이브 데모는 React가 데이터를 쉽게 처리하고 변환하는 방법을 강조하며, 현대 웹 개발 시나리오에서 개발자들에게 실용적인 도구를 제공합니다. 이 기능은 사용자 경험을 향상시키는데 그치지 않고 React가 다양한 데이터 형식을 처리하는 다양성을 보여줍니다.\n\n즐거운 내보내기!!!","ogImage":{"url":"/assets/img/2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide_0.png"},"coverImage":"/assets/img/2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"Reactjs에서 멋진 호버 효과 만들기 GitHub을 영감받은 카드 애니메이션","description":"","date":"2024-05-14 11:08","slug":"2024-05-14-CreatingStunningHoverEffectsInReactjsTheGitHub-InspiredCardAnimation","content":"\n\n\n![Card Hover Effect](https://miro.medium.com/v2/resize:fit:1200/1*Cm18EAy6mzdv8N4iOpm1mA.gif)\n\n이 글에서는 React를 사용하여 매혹적인 카드 호버 효과를 구현하는 방법을 살펴봅니다. 커서를 따라 움직이는 동적 라이트 효과를 추가하는 과정부터 사용자 경험을 몰입적이고 시각적으로 매력적으로 만드는 것까지 다룰 것입니다. 마우스 이벤트 처리부터 부드러운 애니메이션 및 성능 최적화까지, 웹 프로젝트를 높이는 눈에 띄는 카드 상호작용을 만드는 데 필요한 모든 것을 다룰 것입니다.\n\n먼저, CardWithAnimationComponent 라는 컴포넌트를 생성합니다:\n\n```js\nfunction CardWithAnimationComponent({children}: { children: ReactNode }) {\n    return (\n        <div className={styles.main_div_card_with_animation}>\n            {children}\n        </div>\n    );\n}\n```   \n  \n\n\n\n안녕하세요! 보시다시피, children이라는 하나의 prop을 가져와요. 이 prop은 ReactNode 타입이에요. 컴포넌트 내부에서는 스타일시트에서 CSS 클래스인 main_div_card_with_animation을 가진 `div` 요소를 렌더링하고 이 `div` 내에 children을 렌더링해요.\n\n다음 단계에서 화면에서 커서 위치를 가져오기 위해 이 코드를 작성했어요:\n\n```js\nfunction CardWithAnimationComponent({children}: { children: ReactNode }) {\n    const [hoverPosition, setHoverPosition] = useState({x: 0, y: 0});\n\n    const handleMouseMove = (e: MouseEvent) => {\n        const x = e.clientX;\n        const y = e.clientY;\n        setHoverPosition({x, y});\n    };\n\n    return (\n        <div className={styles.main_div_card_with_animation}\n             onMouseMove={handleMouseMove}>\n            {children}\n        </div>\n    );\n}\n```\n\n컴포넌트 내부에서 useState 훅을 사용하여 hoverPosition이라는 상태 변수를 초기화하고, 이 변수는 x와 y라는 속성을 갖는 객체이며, 초기값은 모두 0으로 설정돼요. 그런 다음 MouseEvent를 인수로하여 handleMouseMove 함수를 정의했어요. 이 함수는 마우스가 컴포넌트 내에서 움직일 때마다 현재 마우스 좌표 (clientX 및 clientY)로 hoverPosition 상태를 업데이트해요.\n\n\n\n이제 커서를 따라 이동하는 라이트를 만들기 위해 또 다른 div를 추가할 시간입니다:\n\n```js\n<div className={styles.main_div_card_with_animation}\n     onMouseMove={handleMouseMove}>\n    {children}\n    <div\n      className={styles.light}\n        style={\n          left: hoverPosition.x,\n          top: hoverPosition.y,\n          zIndex: -1,\n         }/>\n</div>\n```\n\n```js\n.main_div_card_with_animation {\n    position: relative;\n    overflow: hidden;\n    border-radius: 10px;\n    border: 1px solid rgba(255, 255, 255, 0.08);\n    background: rgb(0, 0, 0);\n}\n\n.light {\n    position: absolute;\n    width: 50%;\n    aspect-ratio: 1;\n    border-radius: 50%;\n    filter: blur(100px);\n    -webkit-filter: blur(100px);\n    background-color: rgba(255, 39, 223, 0.51);\n}\n```\n\n이 CSS 코드는 .light 클래스를 만들어서 position을 absolute로, width를 50%로 설정하고, filter 속성을 사용하여 요소에 매우 강한 blur 효과를 적용합니다.\n\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*Q9mUuviNZgZdAB_iUsmfkg.gif)\n\n마우스 커서를 따라 이동하는 빛이 있지만 2 가지 문제가 있습니다. 먼저, 빛이 커서의 중심이 아니며 둘째로 마우스가 div 영역을 벗어나면 빛이 사라지지 않습니다.\n\n## 빛의 위치 수정하기\n\n이 문제를 해결하기 위한 아이디어 중 하나는:\n  \n\n\n\n```js\nfunction CardWithAnimationComponent({children}: { children: ReactNode }) {\n    const [hoverPosition, setHoverPosition] = useState({x: 0, y: 0});\n    const containerRef = useRef<HTMLDivElement>(null);\n\n    const handleMouseMove = (e: MouseEvent) => {\n        if (!containerRef.current) return;\n        const rect = containerRef.current.getBoundingClientRect();\n        const lightSize = rect.width * 0.5; // 50% of container's width, equal to light size in css file\n        const x = e.clientX - rect.left - lightSize / 2;\n        const y = e.clientY - rect.top - lightSize / 2;\n        setHoverPosition({x, y});\n    };\n    return (\n        <div className={styles.main_div_card_with_animation}\n             onMouseMove={handleMouseMove}\n             ref={containerRef}>\n            {children}\n            <div\n                className={styles.light}\n                style={{\n                    left: hoverPosition.x,\n                    top: hoverPosition.y,\n                    zIndex: -1,\n                }}\n            />\n        </div>\n    );\n}\n```\n\n저는 containerRef를 추가했고 handleMouseMove 함수도 변경했습니다. containerRef는 useRef 훅을 사용하여 생성된 참조 객체입니다. 이 객체는 카드의 컨테이너 div 요소에 할당됩니다. React에서 Refs는 렌더 메서드에서 생성된 DOM 노드나 React 요소에 액세스하는 방법을 제공합니다. 이 경우 containerRef는 handleMouseMove 함수에서 컨테이너와 마우스 위치를 계산하는 데 사용됩니다.\n\nhandleMouseMove 함수에서 x와 y 좌표가 어떻게 계산되는지 살펴보겠습니다:\n\n- 마우스 이동 이벤트가 발생하면 clientX 및 clientY 속성이 제공됩니다. 이는 브라우저 창의 클라이언트 영역에 대한 마우스 포인터의 수평 및 수직 좌표를 나타냅니다.\n- 직사각형과 오프셋: getBoundingClientRect() 메서드는 요소의 크기와 뷰포트에 대한 위치를 반환합니다. 여기서 containerRef로 참조된 컨테이너 div에 대해 호출됩니다. rect 객체에는 요소의 상하좌우 위치를 나타내는 top, left, right, bottom과 같은 속성이 포함됩니다.\n- 빛 크기 조정: lightSize는 컨테이너 너비의 반( rect.width * 0.5 )로 계산됩니다. 이는 CSS 파일에서 빛의 크기에 해당합니다.\n- X와 Y 계산: x와 y 좌표를 컨테이너에 대해 계산하기 위해 마우스의 clientX 및 clientY 위치에서 컨테이너의 left 및 top 위치를 각각 빼줍니다. 추가로 lightSize의 절반을 빼서 x와 y 좌표가 마우스 포인터를 중심으로 정렬되도록 합니다.\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*juNu5QaGs6gO0FmqX4jQDA.gif\" />\n\n## 마우스가 div를 벗어났을 때 가시성 수정\n\n```js\nfunction CardWithAnimationComponent({children}: { children: ReactNode }) {\n    const [hoverPosition, setHoverPosition] = useState({x: 0, y: 0});\n    const [isHovering, setIsHovering] = useState(false);\n    const containerRef = useRef<HTMLDivElement>(null);\n\n    const handleMouseMove = (e: MouseEvent) => {\n        if (!containerRef.current) return;\n        const rect = containerRef.current.getBoundingClientRect();\n        const lightSize = rect.width * 0.5; // container 너비의 50%, CSS 파일에서 빛 크기와 동일\n        const x = e.clientX - rect.left - lightSize / 2;\n        const y = e.clientY - rect.top - lightSize / 2;\n        setHoverPosition({x, y});\n    };\n\n    const handleMouseEnter = () => {\n        setIsHovering(true);\n    };\n\n    const handleMouseLeave = () => {\n        setIsHovering(false);\n    };\n\n    return (\n        <div className={styles.main_div_card_with_animation}\n             onMouseMove={handleMouseMove}\n             onMouseEnter={handleMouseEnter}\n             onMouseLeave={handleMouseLeave}\n             ref={containerRef}>\n            {children}\n            <div\n                className={styles.light}\n                style={{\n                    left: hoverPosition.x,\n                    top: hoverPosition.y,\n                    zIndex: -1,\n                    opacity: isHovering ? '1' : '0',\n                    transition: 'opacity 500ms ease',\n                }}\n            />\n        </div>\n    );\n}\n```\n\n여기에는 빛의 투명도를 설정하고 애니메이션과 함께 보여주기 위해 isHovering 및 handleMouseEnter 및 handleMouseLeave를 추가했습니다. 그리고 끝났어요!\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*Fu0K11BdC_r-j1gLHidQfA.gif)\n\n❤️ 이 기사를 읽어 주셔서 감사합니다. 여러분의 생각을 듣고 싶습니다. 저에 대해 더 알고 싶으시면 제 웹사이트를 방문해주세요:\n","ogImage":{"url":"/assets/img/2024-05-14-CreatingStunningHoverEffectsInReactjsTheGitHub-InspiredCardAnimation_0.png"},"coverImage":"/assets/img/2024-05-14-CreatingStunningHoverEffectsInReactjsTheGitHub-InspiredCardAnimation_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트 하이드레이션 오류 지옥 탈출하기","description":"","date":"2024-05-14 11:06","slug":"2024-05-14-EscapingReactHydrationErrorHell","content":"\n\n# 소개\n\n리액트 애플리케이션을 하이드레이션할 때 다음과 같은 오류 메시지가 표시되었을 수 있습니다:\n\n![Error](/assets/img/2024-05-14-EscapingReactHydrationErrorHell_0.png)\n\n이 오류는 서버 측에서 렌더링된 리액트 트리와 브라우저에서 처음 렌더링할 때 클라이언트 측에서 생성된 리액트 트리 간에 차이가 있는 경우 발생합니다. React는 이 둘 간의 차이를 조정할 수 없어서 트리의 UI 및 상호 작용을 제어할 수 없게 됩니다.\n\n\n\n여기서는 일반적인 원인, 오류를 디버그하는 방법 및 수화 오류를 피하는 일반적인 해결책을 살펴보겠습니다.\n\n# 원인\n\n수화 오류의 일반적인 원인 몇 가지가 있습니다.\n\n![2024-05-14-EscapingReactHydrationErrorHell_1.png](/assets/img/2024-05-14-EscapingReactHydrationErrorHell_1.png)\n\n\n\n## 브라우저 감지 기반 렌더링\n\n컴포넌트가 브라우저에서 렌더링되는지 또는 서버에서 렌더링되는지를 감지하는 로직이 있다면 주의가 필요합니다. 예를 들어:\n\n```js\nconst isClient = typeof window !== \"undefined\";\n```\n\n다음 가짜 예시를 살펴봅시다:\n\n\n\n```js\nconst IsomorphicContainer = () => {\n  const isClient = typeof window !== \"undefined\";\n\n  return isClient ? <ClientOnlyComponent /> : null;\n};\n```\n\n여기서 `ClientOnlyComponent /`은 클라이언트 측에서만 사용할 수 있다고 가정합니다. 외부 스크립트와 통합할 때 이런 경우가 흔합니다. 아마도 클라이언트 측 GTM DataLayer 구성 구성 요소인 것 같습니다.\n\nReact는 세계의 이해가 동기화되지 않아 발생하는 이슈가 있습니다:\n\n- 서버에서는 isClient 조건이 false로 평가되어 null 값이 렌더링됩니다.\n- 수화하기 전 클라이언트 측에선 window가 정의되어 이 표현식이 true로 평가됩니다.\n- 수화 후 함수형 컴포넌트가 처음 렌더링되면 `ClientOnlyComponent /`이 결과로 나오는데, 이는 서버 측에서 렌더링된 null 값과 맞지 않습니다.\n- 이로 인해 수화 오류가 발생합니다.\n\n\n\n## 브레이크포인트 감지 기반 렌더링\n\n브라우저 감지 문제의 확장으로, 특정 브라우저 API의 결과에 따라 기능을 감지하고 조건부로 렌더링하려는 모든 구성 요소가 영향을 받을 수 있습니다. 예를 들어:\n\n```js\nconst mediaQueryList = window?.matchMedia(\"(max-width: 768px)\") ?? {};\n```\n\n다음 가짜 예제를 고려해 봅시다:\n\n\n\n```js\nimport { useMediaQuery } from 'react-responsive';\n\nconst BreakpointVaryingCTA = ({ showModel }) => {\n  const isMobileOrTablet = useMediaQuery({ maxWidth: 768 });\n\n  return isMobileOrTablet ? <a href=\"/content\">추가 정보</a> : <button type=\"button\" onClick={showModel}>추가 정보</button>\n};\n```\n\n여기에는 모바일 및 태블릿 장치에서 링크를 렌더링하고, 데스크톱 장치에서는 추가 정보를 위해 모달을 열고자 하는 강제로 설정된 설정이 있습니다.\n\n서버 측에서 미디어 쿼리 후크는 폭이 768px 미만이 아니기 때문에 false로 평가됩니다. 사실, 서버 측에서는 뷰포트 개념이 전혀 없습니다!\n\n클라이언트 측에서 데스크톱에서는 후크가 false로 해결되고 하이드레이션 매치를 얻을 수 있어 운이 좋습니다.\n\n\n\n\n모바일에서 클라이언트 측에서 문제가 발생할 수 있어요. 후크는 true로 해결되고 첫 번째 렌더링은 앵커 요소가 되어 서버에 렌더링된 버튼과 일치하지 않아 오류가 발생합니다.\n\n## 공백\n\n수많은 수많은 습성의 수난과 번거로운 원인 중 하나로 수분상 software나 될 수 있어요. 서버 측에 렌더링된 내용과 클라이언트 측에 렌더링된 내용 사이의 공백 불일치가 발생할 때 오류가 발생하곤 해요.\n\n일부 템플릿 리터럴을 사용하여 만들어진 문자열 보간 코드로 생성된 React 루트 요소의 두 가지 변형을 고려해보세요:\n\n\n\n```js\n<div id=\"root\">${html}</div>\n\n<div id=\"root\">\n  ${html}\n</div>\n```\n\n후자의 예시는 React 트리 내용을 감싸는 새 줄과 루트 노드 간의 불일치로 인해 수분화 오류가 발생할 가능성이 있습니다:\n\n```js\n경고: <div>에서 텍스트 노드 \" \"을(를) 포함하는 서버 HTML을 기대하지 않았습니다.\n```\n\n이와 유사하게 응답 HTML의 공백을 제거하여 압축하면 비슷한 문제가 발생할 수 있습니다.\n\n\n\n## 데이터 차이점\n\n사용자에게 컴포넌트를 통해 반영되는 데이터가 서버 렌더링과 클라이언트 렌더링 사이에 시간이나 환경 때문에 다를 수 있다면, 이 또한 불일치를 초래할 수 있습니다.\n\n이 문제의 가장 일반적인 형태는 타임스탬프를 렌더링하는 것입니다:\n\n- 클라이언트 측 타임스탬프가 서버 측과 다르게 나타날 것이며 시간이 흐르기 때문입니다;\n- 클라이언트보다 서버의 시간대가 다르다면, 시간대가 출력 값에 고려되지 않는다면 차이가 발생할 수 있습니다.\n\n\n\n다른 예시로는 다음과 같은 것들이 있을 수 있습니다:\n\n- 수분화 전에 검색한 API 데이터를 컴포넌트 안에 반영하는 것입니다. 예를 들어, 클라이언트에서 API 데이터를 새로 고치고 나서 수분화하면, 서버 측에서 렌더링한 이후에 API 데이터가 변경된 경우 일치하지 않을 수 있습니다.\n- 서버와 클라이언트 모두에서 uuid 패키지를 사용하는 비결정적 ids를 사용하는 것 대신에, React 18 이후 버전을 사용하면 React.useId()를 사용해보세요.\n- 문자 인코딩 차이 - 서버와 클라이언트가 일치하는지 확인하세요! 일반적으로 utf-8을 사용하는 것이 좋습니다.\n\n## 잘못된 HTML\n\n일부 요소는 다른 요소 안에 중첩될 수 없습니다. 예를 들어 `a` 요소 안에 다른 `a` 요소를 중첩할 수 없습니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-EscapingReactHydrationErrorHell_2.png)\n\n브라우저에 따라 이러한 부적절한 요소가 수화 전에 DOM에서 제거될 수 있으며, React가 수화하려고 할 때 불일치가 발생할 수 있습니다.\n\n여기서 중요한 점은 유효한 HTML을 작성하는 것입니다!\n\n## 제삼자의 간섭\n\n\n\n\n알려진 몇 가지 시나리오에는 코드 외의 메커니즘이 서버 응답에 영향을 줄 수 있어 수분화 문제가 발생할 수 있습니다:\n\n- 페이지 조작하는 브라우저 확장 프로그램 — React 이슈를 참조하세요.\n- 클라우드 제공업체 / CDN이 HTML 응답을 조작하는 경우 — Cloudflare 문서를 참조하세요.\n- 구글 크롬 번역 기능으로 페이지 조작하는 경우 — React 이슈를 참조하세요.\n- iOS 형식 감지가 HTML 응답을 조작하는 경우 — NextJS 문서를 참조하세요.\n- 수분화 이전에 페이지를 조작하는 조기 실행 타사 스크립트, 예: GTM, HotJar.\n\n# 디버깅\n\n그러면 수분화 경고의 근본 원인을 디버깅할 수 있는 몇 가지 방법을 살펴봅시다!\n\n\n\n<img src=\"/assets/img/2024-05-14-EscapingReactHydrationErrorHell_3.png\" />\n\n## React 개발 빌드\n\nReact의 개발 빌드를 사용할 때는 개발 도구 콘솔에서 완전하지만 압축되지 않은 수분화 경고를 받을 수 있습니다. 이를 통해 문제가 발생한 구성 요소를 빠르게 식별할 수 있습니다.\n\n거기서 알려진 수분화 오류 원인 중 일부와 구성 요소를 빠르게 매칭하여 문제를 해결할 수 있습니다.\n\n\n\n현재 로컬에서 React를 개발 모드로 실행하면서 테스트 또는 프로덕션 환경 API와 통합할 수 없는 경우, 개발자 경험을 향상시키기 위해 팀에서 시간을 투자하는 것이 가치가 있을 수 있습니다.\n\n## 복구 가능한 오류 로그\n\n이 옵션들은 React 18 버전 이후를 사용한다고 가정합니다.\n\n바닐라 React 애플리케이션\n\n\n\nReact 트리에 hydrateRoot()를 호출할 때 옵션으로 전달할 수 있는 세 번째 인수가 있습니다.\n\n이 옵션 중 하나는 onRecoverableError이며, 이는 React가 오류에서 자동으로 복구할 때 호출할 콜백을 받습니다. 예를 들어 수분화 오류가 발생한 경우입니다.\n\n이 콜백에 지표를 추가하여 문제를 로깅할 수 있도록 권장됩니다. 예를 들어 New Relic, Sentry, Datadog, Elastic RUM 등의 관측성 플랫폼에 이러한 문제를 기록할 수 있습니다.\n\n여기에 예시 코드 조각이 있습니다:\n\n\n\n```js\nimport { hydrateRoot } from 'react-dom/client';\nimport MyObservabilityPlatform from 'my-observability-platform';\nimport App from './App'\n \nfunction onRecoverableError(error, errInfo) {\n  let context = {};\n \n  if (errInfo?.componentStack) {\n     // 생성된 합성 오류를 사용하면 모니터링 서비스가 소스맵을 적용하여 스택 트레이스를 압축 해제하고 가독성 있게 만들 수 있습니다.\n     const errorBoundaryError = new Error(error.message);\n     errorBoundaryError.name = `React ErrorBoundary ${errorBoundaryError.name}`;\n     errorBoundaryError.stack = errInfo.componentStack;\n \n     error.cause = errorBoundaryError;\n \n     context.componentStack = errInfo.componentStack;\n  }\n \n  MyObservabilityPlatform.captureException(error, { context })\n}\n \nconst domNode = document.getElementById('root');\n \nhydrateRoot(domNode, <App />, { onRecoverableError });\n```\n\nhydrateRoot() 옵션에 대한 추가 정보는 리액트 문서에서 확인할 수 있습니다.\n\nNextJS 어플리케이션\n\nNextJS를 사용할 때는 애플리케이션의 수화를 직접 호출할 필요가 없습니다. NextJS가 대신 수행해줍니다.\n\n\n\nNextJS는 현재 hydrateRoot()에 onRecoverableError 옵션을 전달할 수 있는 기능을 제공하지 않습니다. 이 옵션을 노출하기 위한 시도에 대한 논의를 위해 https://github.com/vercel/next.js/discussions/36641을 참고하세요.\n\n그러나 우리는 이 옵션을 수동으로 패치하여 로컬 및 프로덕션 환경에서 문제를 디버깅할 수 있습니다. 이를 위한 한 가지 방법은 Chrome 로컬 오버라이드를 사용하는 것입니다:\n\n- Chrome에서 수분화 오류가 발생하는 페이지로 이동하고 개발자 도구를 엽니다.\n- Sources 탭을 열고 왼쪽 메뉴에서 Page 탭을 선택합니다. 자산 트리에서 오른쪽 클릭하여 모든 파일에서 검색 옵션을 표시합니다.\n- 열리는 창에서 onRecoverableError 용어를 검색하여 모든 코드 일치 항목을 확인합니다.\n- 코드 중 하나는 this.onRecoverableError = a;와 유사해야 합니다. 이 코드를 수정하여 오류와 errorInfo 인수를 모두 콘솔에 기록하도록 수정할 것입니다.\n- 파일 탭에서 오른쪽 클릭하여 Override Content 옵션을 클릭합니다. 이로써 측면 메뉴에 오버라이드 탭이 열릴 것입니다. Enable Local Overrides 옵션이 선택되어 있는지 확인합니다.\n- 이 시점에서 파일이 압축되어 보인다면, 가독성을 높이기 위해 prettifier 버튼 ''를 사용합니다.\n- 다음 스니펫으로 코드를 교체합니다:\nthis.onRecoverableError = (error, errorInfo) => console.error(error, errorInfo);. 이렇게 하면 수분화 오류와 추가 componentStack 정보가 이제 콘솔에 기록됩니다. 반드시 저장하세요!\n- 페이지를 새로고침하고 이제 수분화 오류 옆에 추가 객체가 로그되는 것을 확인하십시오. 이제 컴포넌트 스택을 사용하여 어떤 컴포넌트에 문제가 있는지 추적할 수 있습니다. 스택이 압축되어 있기 때문에 어떤 컴포넌트가 작동 중인지 정확히 식별하기 어려울 수 있습니다 - identifier되는 요소인 주 태그부터 시작하여 트리를 따라 자식 요소로 이동하는 것이 종종 유용합니다.\n\n수동으로 패치하는 대안적인 전략은 코드로 패치하는 것입니다. NextJS에 대한 아이디어를 위한 이 NextJS 논의 스레드 또는 코드 예제를 참조하십시오. 이는 프로덕션 환경에 권장되지 않지만 로컬 개발 빌드에 도입하는 것이 개발자 경험을 향상시키는 편리한 능력이 될 수도 있습니다.\n\n\n\n## DevTools 디버거\n\n수분 오류를 식별하는 또 다른 방법은 DevTools 디버거를 사용하여 예외 발생 시 일시 중지하는 것입니다. 특히 \"잡힌 예외에서 일시 중지\"는 수분 오류에 특히 유용할 수 있습니다.\n\n이 방법의 단점은 응용 프로그램이 발생(및 잡는) 예외의 수에 따라 원인을 식별하는 것이 꽤 번거로울 수 있다는 것입니다. 문제와 관련이 있는 것을 찾기 전에 상당수의 관련이 없는 잡힌 예외를 한땀한땀 찾아야 할 수도 있습니다.\n\nChrome DevTools의 잡힌 예외에 대한 자세한 정보는 Chrome 개발자 문서에서 확인할 수 있습니다.\n\n\n\n# 해결책\n\n서버와 클라이언트 측에서 렌더링된 것을 조정할 수 없는 상황이라면 수분화 문제를 해결하는 몇 가지 전술이 있습니다.\n\n![이미지](/assets/img/2024-05-14-EscapingReactHydrationErrorHell_4.png)\n\n## 두 번째 렌더링으로 연기\n\n\n\n한 가지 해결책은 서버 측 및 클라이언트 측의 첫 번째 렌더링에 동일한 콘텐츠가 렌더링되고, 그 후부터는 클라이언트 측 특정 컴포넌트를 렌더링할 수 있도록 하는 것입니다.\n\n```js\nconst IsomorphicContainer = () => {\n  const [isClient, setIsClient] = useState(false);\n \n  useEffect(() => {\n    setIsClient(true);\n \n    return () => {\n      setIsClient(false);\n    }\n  }, []);\n \n  return isClient ? <ClientOnlyComponent /> : null;\n}\n```\n\n이펙트는 서버 측에서 실행되지 않기 때문에 서버에서 렌더링될 때 isClient 값은 false입니다.\n\n또한 이펙트는 첫 번째 렌더링 후에 실행되므로 클라이언트 측에서 첫 번째 패스에는 isClient 부울 값이 여전히 false이며 수분화 매칭이 유지됩니다.\n\n\n\nReact 트리에 컴포넌트가 마운트되면 부수 효과가 트리거되어 불리언을 true로 전환하며 `ClientOnlyComponent`를 생성합니다.\n\nReact 문서에서 자세한 정보를 확인할 수 있습니다.\n\n추가적인 고려 사항\n\n성능\n\n\n\n이 해결책은 성능 부담이 적은 단순히 렌더링만 하는 것과 비교할 때 React 트리에 마운트될 때 컴포넌트가 두 번 렌더링되는 현상을 가져옵니다.\n\n컴포넌트를 다시 렌더링하는 추가 CPU 시간은 가장 큰 콘텐츠 렌더 시간 (LCP) 및 다음 렌더링까지의 상호작용 (INP)과 같은 CPU에 의한 성능 지표에 부정적인 영향을 미칠 수 있습니다.\n\n비스안스 스타일 콘텐츠의 깜빡임\n\n시각적으로 무언가를 렌더링하는 컴포넌트의 경우, 이 접근 방법으로 비스안스 스타일 콘텐츠 깜박임 (FOUC)이 발생하는 경우, 화면을 다시 그리기 전에 트리거될 useLayoutEffect를 사용하는 것을 고려해보세요.\n\n\n\n이는 화면에 첫 번째 다시 그리기가 발생하기 전에 첫 번째 렌더, 후크 실행 및 두 번째 렌더의 전체 주기가 모두 발생함을 보장합니다.\n\n이로 인해 다음 페인트까지의 시간에 성능 영향을 미치지만 useEffect 사용은 항상 먼저 고려되어야 합니다. 특히 INP와 같은 지표들이 더 두드러질 때에는 더욱 그렇습니다.\n\n## NextJS 동적 패키지 \"매직\"\n\nNextJS를 사용 중이라면 클라이언트 측에서만 고려되어야 하는 컴포넌트를 지정하는 대체 옵션이 몇 가지 있습니다.\n\n\n\n다음/동적 모듈을 사용하여 이를 구현했습니다:\n\n```js\nimport dynamic from 'next/dynamic';\n \nconst ClientOnlyComponent = dynamic(() => import('../components/Component'), { ssr: false });\n```\n\nNextJS 문서에서 더 많은 정보를 확인할 수 있습니다.\n\n## 로다블 컴포넌트 패키지 \"매직\"\n\n\n\n만약 @loadable/component 패키지를 사용 중이라면, next/dynamic 패키지와 유사하게 컴포넌트를 클라이언트 측만 고려해야 한다는 옵션을 지정할 수 있습니다:\n\n```js\nimport loadable from '@loadable/component';\n\n// 이 동적 임포트는 서버 측에서 처리되지 않습니다\nconst Other = loadable(() => import('../components/Component'), { ssr: false });\n```\n\nLoadable 컴포넌트 문서에서 더 많은 정보를 확인할 수 있습니다.\n\n## 다중 렌더링\n\n\n\n브레이크포인트 기반 렌더링과 같은 시나리오를 다룰 때 “두 번째 렌더에 연기\" 기술을 사용할 수 있지만, 이 경우 적어도 하나의 브레이크포인트가 올바른 컴포넌트가 두 번째로 렌더링될 때까지 다른 뷰포트를 위한 내용이 잠깐 나타나는 문제가 발생할 수 있어요.\n\nCSS를 통해 이 문제를 완화할 수 있는데, 두 번째 렌더 전까지 내용을 시각적으로 숨겨놓은 후 렌더링하는 방법이 있지만, 이렇게 할 경우 콘텐츠 레이아웃 이동(CLS) 메트릭에 부정적인 영향을 미칠 수 있어요. CLS는 검색 엔진 최적화(SEO)에 영향을 미치며 사용자 경험을 나쁘게 만드는 요인이 될 수 있어요.\n\n여기서 일반적으로 수용되는 해결책은 모든 잠재적 변형을 서버 측에서 렌더링하는 것이에요:\n\n- 각 브레이크포인트에서 필요한 모든 변형을 서버 측에서 렌더링해요.\n- 렌더링 블로킹 스타일이나 링크 태그로 전달되는 CSS 미디어 쿼리를 사용하여 클라이언트에서 처음으로 로딩될 때 사용자에게 원하는 변형만 표시되도록 해요.\n- \"두 번째 렌더에 연기\" 기술을 사용하여 수분화 불일치가 없도록 해요.\n- 두 번째 렌더링 시에는 원하지 않는 컴포넌트를 null로 렌더링하고 언마운트하면 돼요.\n\n\n\n서버 렌더링된 HTML이 부풀어오르는 결과를 초래할 수 있는 이 문제는 TTFB에 영향을 미칠 수 있습니다. 또한 \"두 번째 렌더링으로 연기\" 기술의 CPU 사용량 주의사항을 겪을 수 있지만, 서버와 클라이언트 간에 원활한 전환을 보장하고 원치 않는 콘텐츠가 번쩍이지 않도록 해줍니다.\n\n이 기술에 대한 자세한 정보는 다음 기사에서 확인할 수 있습니다: viewport 특정 반응형 디자인에 SSR을 사용할 때 CLS 제거하기.\n\n## React 트리 가지치기\n\n이 방법은 \"다중 렌더링\" 기술과 비슷한데, 모든 여러 변형을 모두 수화한 다음 제거하는 대신 리액트 트리를 수화하기 전/수화하는 동안 가지를 잘라냅니다:\n\n\n\n- 모든 변형을 서버 측에서 렌더링합니다.\n- CSS를 사용하여 원하지 않는 콘텐츠가 플래시되지 않도록 합니다.\n- 변형을 하이드레이트/첫 번째 렌더링 시에 원하는 변형인지 여부를 결정하고, 그렇지 않은 경우 React가 해당 노드에 액세스하기 전에 DOM에서 제거합니다 — React는 존재했다는 것을 모르는 DOM 노드에 대해 일치하지 못합니다.\n- DOM에 남아 있는 것이 유효한 유일한 변형인 경우 \"두 번째 렌더에 위임\" 기술을 사용할 필요가 없으므로 우리는 원하는대로 즉시 렌더링할 수 있습니다.\n\n\"다중 렌더링\" 기술과 마찬가지로 이 기술도 TTFB에 영향을 줄 수 있는 팽창된 서버 렌더링 HTML을 만들지만, 다른 기술의 성능 영향은 없습니다.\n\n이 기술에 대한 자세한 정보 및 구현 방법은 이 지스트 예제 및 @artsy/fresnel 패키지에 대한 이 PR에서 찾을 수 있습니다.\n\n또한 최근 X(이전에는 Twitter로 알려진)에 대한 토론도 확인할 수 있습니다.\n\n\n\n# 하이드레이션 경고 비활성화\n\nReact에서 HTML 요소 JSX는 하이드레이션 오류에서 발생하는 경고를 억제하는 데 사용할 수 있는 suppressHydrationWarning 부울을 받습니다.\n\n이는 데이터가 조정되지 않을 때만 사용해야 합니다. 예를 들어, 타임스탬프나 날짜를 페이지에 작성할 때와 텍스트 콘텐츠에서 가리는 차이가 있는 경우에만 사용되어야 합니다.\n\n추가 정보는 React 문서에서 확인할 수 있습니다.\n\n\n\n이게 다예요! 읽어 주셔서 감사합니다 ☺️\n\n수분 공급 오류를 일으키는 다른 예제가 있나요? 또는 문제를 해결하거나 디버그하는 편리한 방법이 있나요?\n\n댓글로 알려주세요!","ogImage":{"url":"/assets/img/2024-05-14-EscapingReactHydrationErrorHell_0.png"},"coverImage":"/assets/img/2024-05-14-EscapingReactHydrationErrorHell_0.png","tag":["Tech"],"readingTime":11},{"title":"오픈 소스로 배우는 팁 Nextjs에서 리다이렉트가 어떻게 작동하는지 살펴보기","description":"","date":"2024-05-14 11:04","slug":"2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood","content":"\n\n이 기사에서는 넥스트.js에서 리다이렉션 작동 방식을 살펴보면서 넥스트.js 소스 코드 주변의 리다이렉션 기능에 대해 배우게 됩니다.\n\n# 나의 접근 방식:\n\n- Import를 시작으로\n- Redirect 함수를 redirect.ts 파일까지 추적\n- redirect.ts 설명\n- 에러를 throw 하는 것이 리디렉션이 작동하는 방법\n- 전체 맥락을 이해하기 위해 redirect.test.ts 확인\n- redirect-boundary.ts에 리다이렉션 기능이 있음\n\n# 1. Import를 시작으로:\n\n\n\n리다이렉트 함수는 next/navigation에서 가져온 것입니다. 리다이렉트에 대해 더 알고 싶다면 다음 링크를 확인해보세요: https://nextjs.org/docs/app/api-reference/functions/redirect.\n\n하지만 next/navigation 코드는 어디에서 찾을 수 있을까요? navigation.js 파일에서 이 코드를 찾을 수 있습니다. 이 파일은 기본적으로 navigation.ts를 내보내는데, 이는 /packages/next/src/client/components에 있습니다.\n\n# 2. 리다이렉트 함수를 redirect.ts 파일로 추적하기\n\n현재 이 글을 작성하는 시점에서 navigation.ts에는 272줄의 코드가 있지만, 우리가 관심 있는 것은 파일 끝에 아래와 같이 표시된 \"redirect\"의 내보내기입니다. 찾고자 하는 것에 집중하세요. 다른 코드에 방해받지 마세요.\n\n\n\n\"여기 보시다시피, redirect는 navigation.react-server.ts에서 내보내는 것입니다. navigation.react-server.ts 안에 들어가보면, redirect 함수가 실제로 redirect.ts에서 왔다는 것을 알게 될 거에요.\n\n저는 중첩된 내보내기를 몰랐어요. 흥미롭네요.\"\n\n\n\n# 3. Render.ts 설명\n\n“redirect() 함수를 호출하면 NEXT_REDIRECT 오류가 발생하고 발생한 위치의 라우트 세그먼트의 렌더링을 중단합니다.\" — Nextjs 문서\n\nredirect.ts 파일 내에서 오류를 발생시키는 코드 조각을 살펴봅시다.\n\n![이미지](/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_2.png)\n\n\n\n# 4. 에러를 발생시켜서 리디렉션이 작동하는 방식은 무엇인가요?\n\n리디렉트 함수가 에러를 발생시켜서 에러.digest를 설정하지만, 에러를 발생시켜서 리디렉션이 작동하는 방식이 명확하지 않았습니다.\n\n오랫동안 찾아봤고, 리디렉트가 에러를 발생시킨다는 것을 고려하여 catch 블록을 찾으려고 노력했습니다. 서버 관련 파일을 뒤져봐도 도움이 되지 않았어요.\n\nredirect.test.ts를 살펴보면서 조금씩 이해되기 시작했어요.\n\n\n\n# 5. 전체 맥락을 이해하려면 redirect.test.ts를 확인하세요\n\n![image](/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_3.png)\n\n한 번 어딘가에서 함수의 컨텍스트를 이해하는 데 테스트를 사용할 수 있다고 읽은 적이 있습니다. 그래서 redirect.test.ts에서 코드를 확인한 이유입니다.\n\n테스트 코드에서 getURLFromRedirectError(err) 함수가 호출되는 것이 명백합니다. 이 함수는 react-boundary.ts에서 찾을 수 있습니다.\n\n\n\n알겠어요. 테스트에서는 getURLFromRedirectError 함수를 호출하는데 실행 흐름은 어떻게 될까요? 에러가 발생한 후에는 무엇이 일어날까요? getURLFromRedirectError 함수를 기반으로 검색한 결과는 다음과 같아요:\n\n![이미지](/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_4.png)\n\n## 6. redirect-boundary.ts에는 리디렉션 기능이 있어요\n\n답은 Next.js 리디렉션이 useRouter 훅을 사용하며 리디렉션 유형에 따라 URL을 푸시하거나 교체합니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_5.png\" />\n\n이 리다이렉트 경계는 아래에 표시된 앱-라우터 코드의 일부입니다.\n\n<img src=\"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_6.png\" />\n\n리다이렉트에서 오류가 발생하면 리다이렉트 경계에서 오류가 catch되고 리다이렉트가 발생합니다. 리다이렉트 함수 자체가 리다이렉트를 수행하지 않고 앱-라우터 내부의 리다이렉트 경계가 라우팅 로직을 처리하는 것이 상당히 흥미로운 점입니다.\n\n\n\n# 결론:\n\n나는 이 API가 왜 이런 식으로 설계되었는지 모르겠지만, 여기에 오류를 throw하는 패턴을 사용하고 해당 오류를 catch하고 원하는 작업을 수행하는 boundary 를 사용할 수 있습니다. 이 npm 패키지에서 오류를 throw하는 패턴을 사용하여 해당 오류를 catch하고 원하는 작업을 수행하는 boundary 를 사용해 보세요.\n\nredirect.test.ts 코드를 확인하지 않았다면, redirect 작동 방식을 파악하지 못했을 것입니다. 나는 redirect.ts 에 catch 블록을 찾고 있었지만 그렇지 않았기 때문입니다.\n\n이 글에 대해 궁금한 점이 있으시면 언제든지 ramu.narasinga@gmail.com 으로 연락 주세요.\n\n\n\n# 더 많은 자료:\n\n- [navigation.react-server.ts](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/src/client/components/navigation.react-server.ts)\n- [navigation.js](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/navigation.js)\n- [redirect.ts](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/src/client/components/redirect.ts)\n- [redirect.test.ts](https://github.com/vercel/next.js/blob/canary/packages/next/src/client/components/redirect.test.ts)\n- [redirect-boundary.tsx](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/src/client/components/redirect-boundary.tsx#L8)","ogImage":{"url":"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_0.png"},"coverImage":"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_0.png","tag":["Tech"],"readingTime":4},{"title":"Lexical와 함께하는 React용 리치 텍스트 에디터 시작하기","description":"","date":"2024-05-14 11:00","slug":"2024-05-14-GettingStartedwithLexicalRichTextEditorforReact","content":"\n\n## React JS에서 Lexical을 사용하는 방법에 대한 튜토리얼; 예제와 함께 기본 사항.\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png\" />\n\n... 그러나 유감스럽게도 이 문서는 좋은 설명의 예시가 아닙니다. 이 기사에서는 이 라이브러리를 어떻게 사용하는지를 간단한 용어로 설명하겠습니다.\n\n여기서는 특별한 스타일, 모달 또는 팝오버 없이 렉시컬 리치 텍스트 기능의 기본을 다룰 것입니다:\n\n\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_1.png)\n\n만약 이 라이브러리가 무엇을 할 수 있는지 확인하고 싶다면, 멋진 렉시컬 플레이그라운드를 확인해보세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_2.png)\n\n관련 이야기:\n\n\n\n# 다룰 내용\n\n- 준비물\n- 시작하기\n- 히스토리 플러그인\n- 노드\n- 리치 텍스트\n- 테마\n- 제목, 도우미 및 노드 구성\n- 페이로드로 자신만의 명령어를 만드는 방법\n- 사용자 정의 노드 만들기\n\n# 준비물\n\n우리는 다음과 같이 만들어진 간단한 React JS 애플리케이션으로 시작할 것입니다:\n\n\n\n```js\nyarn create react-app react-lexical-examples --template typescript\n```\n\n그리고 우리는 어휘 패키지를 설치해야 합니다:\n\n```js\nyarn add lexical @lexical/react\n\n// OR\n\nnpm install --save lexical @lexical/react\n```\n\n# 시작\n\n\n\n\nLexical을 이용하여 작업을 시작하려면 이 템플릿을 사용할 수 있어요:\n\n```js\nimport React, {useMemo} from 'react';\nimport {InitialConfigType, LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {PlainTextPlugin} from \"@lexical/react/LexicalPlainTextPlugin\";\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n\nexport const App: React.FC = () => {\n\n    const CustomContent = useMemo(() => {\n        return (\n            <ContentEditable style={\n                position: 'relative',\n                borderColor: 'rgba(255,211,2,0.68)',\n                border: '2px solid red',\n                borderRadius: '5px',\n                maxWidth: '100%',\n                padding: '10px'\n            }/>\n        )\n    }, []);\n\n    const CustomPlaceholder = useMemo(() => {\n        return (\n            <div style={\n                position: 'absolute', top: 30, left: 30,\n            }>\n                텍스트를 입력하세요...\n            </div>\n        )\n    }, []);\n\n    const lexicalConfig: InitialConfigType = {\n        namespace: '나의 리치 텍스트 편집기',\n        onError: (e) => {\n            console.log('에러 발생:', e)\n        }\n    }\n\n    return (\n        <div style={padding: '20px'}>\n            <LexicalComposer initialConfig={lexicalConfig}>\n                <PlainTextPlugin\n                    contentEditable={CustomContent}\n                    placeholder={CustomPlaceholder}\n                    ErrorBoundary={LexicalErrorBoundary}\n                />\n            </LexicalComposer>\n        </div>\n    );\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*-7S9xp-EweAiYl8Fn0O8_w.gif)\n\n보다시피, 아주 복잡해 보이지 않죠. 걱정하지 마세요, 나중에 이 컴포넌트들에 대해 자세히 다룰 거예요. 일단은 모든 것이 예상대로 작동하는지 확인하는 것이 중요해요.\n\n\n\n이제 기능을 하나씩 추가해 봅시다.\n\n# 히스토리 플러그인\n\n이전 예제에서 새 텍스트를 입력할 수 있었지만, CTRL-Z(실행 취소)를 누르면 아무 일도 일어나지 않았죠. 이 문제를 해결하기 위해 @lexical/history 플러그인을 추가하여 CTRL-Z(실행 취소)와 CTRL-SHIFT-Z(다시 실행)를 사용할 수 있게 할 수 있습니다.\n\n선택 사항으로 직접 Undo/Redo를 처리하는 사용자 정의 컴포넌트를 추가할 수도 있습니다:\n\n\n\n```js\n@@ -3,6 +3,8 @@\n import {PlainTextPlugin} from \"@lexical/react/LexicalPlainTextPlugin\";\n import {ContentEditable} from '@lexical/react/LexicalContentEditable';\n import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n+import {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\n+import {CustomHistoryActions} from \"./components\";\n \n export const App: React.FC = () => {\n \n@@ -44,7 +46,12 @@\n                     placeholder={CustomPlaceholder}\n                     ErrorBoundary={LexicalErrorBoundary}\n                 />\n+                <HistoryPlugin/>\n+                <div style={margin: '20px 0px'}>\n+                    <CustomHistoryActions/>\n+                </div>\n             </LexicalComposer>\n+\n         </div>\n     );\n }\n```\n\n```js\nimport {UNDO_COMMAND, REDO_COMMAND} from 'lexical';\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\n\nexport const CustomHistoryActions = () => {\n    const [editor] = useLexicalComposerContext();\n    return (\n        <>\n            <button onClick={() => editor.dispatchCommand(UNDO_COMMAND, undefined)}>되돌리기</button>\n            <button onClick={() => editor.dispatchCommand(REDO_COMMAND, undefined)}>다시 실행</button>\n        </>\n    );\n}\n```\n\n설명:\n\n- editor는 `LexicalComposer/` 컴포넌트에서 가져온 컨텍스트 값입니다. 에디터 클래스/메소드에 대한 자세한 내용은 여기서 확인할 수 있습니다:\n\n\n\n간단한 사용 예시:\n\n```js\nconst [editor] = useLexicalComposerContext();\n\n  useEffect(() => {\n    // 이펙트가 발생할 때 에디터에 포커스를 맞춥니다!\n    editor.focus();\n  }, [editor]);\n```\n\n- UNDO_COMMAND과 REDO_COMMAND는 에디터 내용(또는 원하는 내용)을 처리해야 할 것을 렉시컬에 알리는 등록된 렉시컬 명령입니다. 다음과 같이 사용자 고유의 명령을 생성할 수도 있습니다:\n\n```js\nimport { createCommand, COMMAND_PRIORITY_NORMAL } from \"lexical\";\n\nexport const DO_SOMETHING_AWESOME = createCommand(\"create_banner\");\n\nexport const CustomComponent: React.FC = () => {\n  const [editor] = useLexicalComposerContext();\n\n  editor.registerCommand(\n    DO_SOMETHING_AWESOME,\n    () => {\n      console.log('이것은 내가 만든 명령입니다')\n      return true;\n    },\n    COMMAND_PRIORITY_NORMAL,\n  );\n\n  return null;\n};\n```\n\n\n\n걱정하지 마세요, 나중에 이 주제를 조금 더 다룰 거예요.\n\n- editor.dispatchCommand(UNDO_COMMAND, undefined) → 왜 두 번째 인자로 undefined를 전달하는 걸까요? 첫 번째, 그렇게 하지 않으면 TS 오류가 발생합니다. 둘째, 이것은 명령과 함께 전달될 수 있는 페이로드 데이터입니다(우리 경우에는 해당되지 않습니다). dispatchCommand에 대해 더 알아보세요.\n\n# 노드\n\n이 섹션에서는 용어의 작동 방식과 저장하는 데이터에 대해 깊이 파헤쳐야 할 것입니다.\n\n\n\n먼저, 에디터의 상태 변화를 모니터링하고 에디터의 상태를 로깅하는 간단한 플러그인을 만들 것입니다:\n\n```js\n// src/components/OnChangePlugin/OnChangePlugin.tsx\n\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {useEffect} from \"react\";\n\nexport const OnChangePlugin = () => {\n    const [editor] = useLexicalComposerContext();\n    useEffect(() => {\n        return editor.registerUpdateListener((listener) => {\n            console.log('DATA', listener.editorState.toJSON())\n        });\n    }, [editor]);\n\n    return null;\n}\n```\n\n다음으로, `LexicalComposer/`의 하위 컴포넌트로 `OnChangePlugin/` 컴포넌트를 추가해주세요:\n\n```js\nIndex: src/App.tsx\n@@ -5,6 +5,7 @@\n import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n import {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\n import {CustomHistoryActions} from \"./components\";\n+import {OnChangePlugin} from \"./components\";\n\nexport const App: React.FC = () => {\n\n@@ -47,6 +48,7 @@\n                    ErrorBoundary={LexicalErrorBoundary}\n                />\n                <HistoryPlugin/>\n+                <OnChangePlugin />\n                <div style={margin: '20px 0px'}>\n                    <CustomHistoryActions/>\n                </div>\n```\n\n\n\n이제 편집기의 상태가 변경될 때마다 편집기의 상태 트리 데이터를 콘솔에 출력할 것입니다:\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_3.png)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Lqyfyb4peVPoHJQvYuBNhQ.gif)\n\n이 텍스트를 입력하면 어떤 데이터를 얻을지 확인해 봅시다:\n\n\n\n```json\n{\n  \"root\": {\n    \"children\": [\n      {\n        \"children\": [\n          {\n            \"detail\": 0,\n            \"format\": 0,\n            \"mode\": \"normal\",\n            \"style\": \"\",\n            \"text\": \"asd\",\n            \"type\": \"text\",\n            \"version\": 1\n          },\n          {\n            \"type\": \"linebreak\",\n            \"version\": 1\n          },\n          {\n            \"detail\": 0,\n            \"format\": 0,\n            \"mode\": \"normal\",\n            \"style\": \"\",\n            \"text\": \"dsa\",\n            \"type\": \"text\",\n            \"version\": 1\n          }\n        ],\n        \"direction\": \"ltr\",\n        \"format\": \"\",\n        \"indent\": 0,\n        \"type\": \"paragraph\",\n        \"version\": 1\n      }\n    ],\n    \"direction\": \"ltr\",\n    \"format\": \"\",\n    \"indent\": 0,\n    \"type\": \"root\",\n    \"version\": 1\n  }\n}\n```\n\n아마도 노드가 간단한 속성을 가진 객체임을 알았을겁니다. 주요 속성은 노드의 종류인 type과 노드의 내용인 text입니다.\n\n\n\n```js\nimport initialState from './initialState.json';\n\n// ...\n\nreturn (\n      <LexicalComposer\n        initialConfig={\n          // ...\n          editorState: JSON.stringify(initialState),\n        }\n      >\n            {/* ... */}\n      </LexicalComposer>\n    );\n```\n\n이 경우 앱을 다시 시작할 때마다 동일한 결과를 얻을 수 있습니다:\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_4.png\" />\n\nNodes에 대해 더 많은 정보를 읽어보실 수 있습니다.\n\n\n\n\n# 리치 텍스트\n\n첫 번째 노드 수정 핸들러를 만들어 봅시다.\n\n이전에 PlainTextPlugin 컴포넌트를 사용했기 때문에 \"bold\" (CTRL+B) 액션과 같은 텍스트 작업을 처리할 수 없습니다:\n\n```js\n<LexicalComposer initialConfig={lexicalConfig}>\n  <PlainTextPlugin ...  />\n...\n</LexicalComposer>\n```\n\n\n\nApp.tsx 파일에서 PlainTextPlugin을 RichTextPlugin으로 변경해야 합니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -1,6 +1,6 @@\n import React, {useMemo} from 'react';\n import {InitialConfigType, LexicalComposer} from '@lexical/react/LexicalComposer';\n-import {PlainTextPlugin} from \"@lexical/react/LexicalPlainTextPlugin\";\n+import {RichTextPlugin} from \"@lexical/react/LexicalRichTextPlugin\";\n import {ContentEditable} from '@lexical/react/LexicalContentEditable';\n import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n import {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\n@@ -46,7 +46,7 @@\n             <LexicalComposer\n                 initialConfig={lexicalConfig}\n             >\n-                <PlainTextPlugin\n+                <RichTextPlugin\n                     contentEditable={CustomContent}\n                     placeholder={CustomPlaceholder}\n                     ErrorBoundary={LexicalErrorBoundary}\n```\n\n이제 에디터에서 기본 텍스트 작업을 사용할 수 있을 것입니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:768/1*GWYMSFDfd3PI2PSh5bVsYw.gif\" />\n\n\n\n우리의 커스텀 버튼을 만들어 봅시다:\n\n```js\n// src/components/CustomTextActions/CustomTextActions.tsx\n\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {FORMAT_TEXT_COMMAND, TextFormatType} from 'lexical';\n\nexport const CustomTextActions = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (formatType: TextFormatType) => {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, formatType)\n    }\n\n    return (\n        <div style={{marginTop: '10px'}}>\n            <span style={{fontWeight: 'bold'}}>텍스트 액션</span>\n            <div>\n                {[\n                    '굵게',\n                    '이탤릭체',\n                    '밑줄',\n                    '코드',\n                    '하이라이트',\n                    '취소선',\n                    '아래첨자',\n                    '위첨자'\n                ].map(value => {\n                    return (\n                        <button\n                            onClick={() => handleOnClick(value.toLowerCase() as TextFormatType)}>\n                            {value}\n                        </button>\n                    )\n                })}\n            </div>\n        </div>\n    );\n}\n```\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_5.png\" />\n\n하지만 텍스트를 수정하려고 하면 기대했던 결과가 나오지 않을 수 있습니다: 일부 항목은 변경되고 일부는 변경되지 않을 수 있습니다. 그 이유가 무엇일까요?\n\n\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_6.png\" />\n\nHTML 출력을 확인해 봅시다:\n\n```js\n<p dir=\"ltr\"><strong data-lexical-text=\"true\">굵게</strong></p>\n<p dir=\"ltr\"><em data-lexical-text=\"true\">이탤릭체</em></p>\n<p dir=\"ltr\"><span data-lexical-text=\"true\">밑줄</span></p>\n<p dir=\"ltr\"><code data-lexical-text=\"true\"><span>코드</span></code></p>\n<p dir=\"ltr\">\n    <mark data-lexical-text=\"true\"><span>강조</span></mark>\n</p>\n<p dir=\"ltr\"><span data-lexical-text=\"true\">취소선</span></p>\n<p dir=\"ltr\"><sub data-lexical-text=\"true\"><span>아래 첨자</span></sub></p>\n<p dir=\"ltr\"><sup data-lexical-text=\"true\"><span>위 첨자</span></sup></p>\n<p dir=\"ltr\"><code data-lexical-text=\"true\"><strong>모두 표시</strong></code></p>\n```\n\n요소에는 적용된 스타일이 없지만 브라우저에서 `mark`/`strong/`/`em/`에 대한 사전 정의된 스타일이 있어 약간의 스타일 변화가 있습니다. 그러나 우리가 기대한 것은 아닙니다.\n\n\n\n이제 다음 주제인 → 테마를 다루어볼 시간입니다.\n\n👉 작은 참고사항입니다. Align 작업 구현이 이렇게 보일 것입니다 (텍스트와 동일한 디스패치 명령어 접근 방식):\n\n```js\nimport {\n    useLexicalComposerContext\n} from \"@lexical/react/LexicalComposerContext\";\nimport {\n    FORMAT_ELEMENT_COMMAND,\n    ElementFormatType,\n    OUTDENT_CONTENT_COMMAND,\n    INDENT_CONTENT_COMMAND\n} from 'lexical';\n\nexport const CustomAlignActions = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (formatType: ElementFormatType) => {\n        editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, formatType)\n    }\n\n    return (\n        <div style={marginTop: '10px'}>\n            <span style={fontWeight: 'bold'}>Align actions</span>\n            <div>\n                {[\n                    'Left',\n                    'Center',\n                    'Right',\n                    'Justify',\n                ].map(value => {\n                    return (\n                        <button\n                            onClick={() => handleOnClick(value.toLowerCase() as ElementFormatType)}>\n                            {value}\n                        </button>\n                    )\n                })}\n                <button\n                    onClick={() => editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined)}>\n                    Outdent\n                </button>\n                <button\n                    onClick={() => editor.dispatchCommand(INDENT_CONTENT_COMMAND, undefined)}>\n                    Indent\n                </button>\n            </div>\n        </div>\n    );\n}\n```\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_7.png)\n\n\n\n위의 경우 \"정당화\" 노드가 편집기 상태 JSON에서 어떻게 나타낼지에 대한 예시입니다:\n\n```js\n{\n  \"children\": [\n    {\n      \"detail\": 0,\n      \"format\": 1,\n      \"mode\": \"normal\",\n      \"style\": \"\",\n      \"text\": \"Justify\",\n      \"type\": \"text\",\n      \"version\": 1\n    },\n    {\n      \"detail\": 0,\n      \"format\": 0,\n      \"mode\": \"normal\",\n      \"style\": \"\",\n      \"text\": \" - Lorem ipsum dolor sit amet, <...>\",\n      \"type\": \"text\",\n      \"version\": 1\n    }\n  ],\n  \"direction\": \"ltr\",\n  \"format\": \"justify\",\n  \"indent\": 0,\n  \"type\": \"paragraph\",\n  \"version\": 1\n}\n```\n\n# 테마\n\nNodes를 수정할 때, lexical은 테마 객체 theme.[`노드-타입`]에서 지정된 노드 타입에 대해 스타일(클래스 이름)을 적용합니다.\n\n\n\n해달 코드를 추가하고 텍스트 스타일을 적용해 보겠습니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -10,6 +10,7 @@\n     CustomHistoryActions\n } from \"./components\";\n import initialState from './initialState.json';\n+import './App.css'\n \n export const App: React.FC = () => {\n \n@@ -38,6 +39,18 @@\n \n     const lexicalConfig: InitialConfigType = {\n         namespace: 'My Rich Text Editor',\n+        theme: {\n+            text: {\n+                bold: \"text-bold\",\n+                italic: \"text-italic\",\n+                underline: \"text-underline\",\n+                code: 'text-code',\n+                highlight: 'text-highlight',\n+                strikethrough: 'text-strikethrough',\n+                subscript: 'text-subscript',\n+                superscript: 'text-superscript',\n+            },\n+        },\n         onError: (e) => {\n             console.log('ERROR:', e)\n         },\n```\n\nCSS:\n\n```js\n.text-bold {\n    font-weight: bold;\n}\n\n.text-italic {\n    font-style: italic;\n}\n\n.text-underline {\n    text-decoration: underline;\n}\n\n.text-code {\n    background-color: #f0f2f5;\n    padding: 1px 0.25rem;\n    font-family: Menlo, Consolas, Monaco, monospace;\n    font-size: 94%;\n}\n\n.text-highlight {\n    margin: 0 5px;\n}\n\n.text-strikethrough {\n    text-decoration: line-through;\n}\n\n.text-subscript {\n    vertical-align: sub;\n}\n\n.text-superscript {\n    vertical-align: super;\n}\n\np {\n    margin: 0;\n}\n```\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1260/1*_KW7zAxitBpOe3HrAqHHfw.gif)\n\n![image](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_8.png)\n\n**Bold**\n*Italic*\n<ins>Underline</ins>\n`Code`\n<mark>Highlight</mark>\n~~Strike~~\nX<sub>Sub</sub>\nX<sup>Super</sup>\n<mark><strong><em><ins><u><strike><sub>All of them</sub></strike></u></ins></em></strong></mark>\n\n\n\n\n알겠지만, 우리가 디스패치를 트리거할 때마다, 렉시컬이 클래스를 교체하지 않고, 있는 경우 추가하거나 있는 경우 제거했습니다. 이 점을 명심해주세요. \"굵게 기울임체 밑줄\"에 대해 별도의 CSS 클래스를 만들 필요가 없습니다.\n\n에디터의 상태 JSON:\n\n```js\n{\n  \"root\": {\n    \"children\": [\n      {\n        \"children\": [\n          {\n            \"detail\": 0,\n            \"format\": 11,\n            \"mode\": \"normal\",\n            \"style\": \"\",\n            \"text\": \"굵게 기울임체 밑줄\",\n            \"type\": \"text\",\n            \"version\": 1\n          }\n        ],\n        \"direction\": \"ltr\",\n        \"format\": \"\",\n        \"indent\": 0,\n        \"type\": \"paragraph\",\n        \"version\": 1\n      }\n    ],\n    \"direction\": \"ltr\",\n    \"format\": \"\",\n    \"indent\": 0,\n    \"type\": \"root\",\n    \"version\": 1\n  }\n}\n```\n\n# 헤딩. 헬퍼 및 노드 구성\n\n\n\n등록된 어휘 명령이 없을 경우 어떻게 해야 할까요? 단어 요소(어휘의 기본 노드)를 어휘 명령을 사용하지 않고 헤더 노드로 변환해 봅시다:\n\n```js\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { $getSelection, $isRangeSelection } from \"lexical\";\nimport { $setBlocksType } from \"@lexical/selection\";\nimport { HeadingTagType, $createHeadingNode } from \"@lexical/rich-text\";\n\nexport const CustomHeadingActions = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (tag: HeadingTagType) => {\n        editor.update(() => {\n            const selection = $getSelection();\n            if ($isRangeSelection(selection)) {\n                $setBlocksType(selection, () => $createHeadingNode(tag));\n            }\n        });\n    };\n\n    return (\n        <div style={{ marginTop: '10px' }}>\n            <span style={{ fontWeight: 'bold' }}>Align actions</span>\n            <div>\n                {([\"h1\", \"h2\", \"h3\", \"h4\", \"h5\"] as Array<HeadingTagType>).map((tag) => {\n                    return (\n                        <button\n                            key={tag}\n                            onClick={() => handleOnClick(tag)}\n                        >\n                            {tag}\n                        </button>\n                    );\n                })}\n            </div>\n        </div>\n    );\n}\n```\n\n일부 노드를 헤딩 노드로 변환하는 데 미리 정의된 명령이 없기 때문에 여기서는 다음과 같은 작업을 수행합니다:\n\n- 콜백을 인수로 전달하는 editor.update 함수 호출\n- 선택된 노드를 가져오기 위해 $getSelection 헬퍼 사용\n- $isRangeSelection을 사용하여 RangeSelection 유형인지 확인합니다.\n\n\n\n```js\n// 소스코드\nexport function $isRangeSelection(x: unknown): x is RangeSelection {\n  return x instanceof RangeSelection;\n}\n```\n\n4. $setBlocksType을 새로운 $createHeadingNode (h1, h2, h3…)으로 변경하세요;\n\n⚠️ 하지만 앱에서 사용해보면 아무 일도 일어나지 않습니다 → 문단이 헤더로 변경되지 않습니다. 에디터에서 사용하고 싶은 노드에 대해 렉시컬이 알지 못하기 때문입니다 (기본 노드를 제외하고). 노드 구성 배열에 HeaderNode를 추가해야 합니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -10,6 +10,7 @@\n     CustomHistoryActions,\n     CustomAlignActions, CustomHeadingActions\n } from \"./components\";\n+import {HeadingNode} from \"@lexical/rich-text\";\n import initialState from './initialState.json';\n import './App.css'\n \n@@ -40,6 +41,7 @@\n \n     const lexicalConfig: InitialConfigType = {\n         namespace: 'My Rich Text Editor',\n+        nodes: [HeadingNode],\n         theme: {\n             text: {\n                 bold: \"text-bold\",\n```\n\n\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_9.png\" />\n\n# 페이로드와 함께 자신만의 명령어를 생성하는 방법\n\n이전 코드를 다시 작성해 보겠습니다. 다른 곳에서 변환 명령을 호출해야 하는 경우에도 이 조각을 복사-붙여넣기할 필요가 없도록 바꿀 거에요:\n\n```js\neditor.update(() => {\n    const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        $setBlocksType(selection, () => $createHeadingNode(tag));\n      }\n});\n```\n\n\n\n위 작업을 위해 페이로드 `\"h1\" | \"h2\" | \"h3\", ...`을 사용하여 자체 FORMAT_HEADING_COMMAND를 생성하고 등록합니다.\n\n```js\n// src/components/CustomHeadingPlugin/CustomHeadingPlugin.tsx\n\nimport { useEffect } from \"react\";\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport {\n    createCommand,\n    $getSelection,\n    $isRangeSelection,\n    COMMAND_PRIORITY_NORMAL,\n} from \"lexical\";\nimport {\n    $setBlocksType\n} from \"@lexical/selection\";\nimport {\n    HeadingTagType,\n    $createHeadingNode\n} from \"@lexical/rich-text\";\n\nexport const FORMAT_HEADING_COMMAND = createCommand(\"FORMAT_HEADING_COMMAND\");\n\nexport const CustomHeadingPlugin = () => {\n    const [editor] = useLexicalComposerContext();\n\n    useEffect(() => {\n        editor.registerCommand<HeadingTagType>(\n            FORMAT_HEADING_COMMAND,\n            (payload) => {\n                const selection = $getSelection();\n                if ($isRangeSelection(selection)) {\n                    $setBlocksType(selection, () => $createHeadingNode(payload));\n                }\n                return true;\n            },\n            COMMAND_PRIORITY_NORMAL,\n        );\n    }, []);\n\n    return null;\n}\n```\n\n이제 `CustomHeadingActions/` 구현을 업데이트할 수 있습니다:\n\n```js\nIndex: src/components/CustomHeadingActions/CustomHeadingActions.tsx\n@@ -1,22 +1,15 @@\nimport {\n    useLexicalComposerContext\n} from \"@lexical/react/LexicalComposerContext\";\nimport {HeadingTagType} from \"@lexical/rich-text\";\nimport {FORMAT_HEADING_COMMAND} from \"../CustomHeadingPlugin\";\n\nexport const CustomHeadingActions = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (tag: HeadingTagType) => {\n        editor.dispatchCommand(FORMAT_HEADING_COMMAND, tag);\n    };\n\n    return (\n        <div style={marginTop: '10px'}>\n```\n\n\n\n이 변형은 내게 훨씬 깔끔하고 재사용 가능해 보여요. 그 이후에는 LexicalComposer의 자식으로 우리가 만든 Header Plugin을 배치해야할거에요:\n\n```js\nIndex: src/App.tsx\n\n@@ -8,8 +8,11 @@\n     OnChangePlugin,\n     CustomTextActions,\n     CustomHistoryActions,\n     CustomAlignActions,\n     CustomHeadingActions,\n+    CustomHeadingPlugin,\n } from \"./components\";\n import {HeadingNode} from \"@lexical/rich-text\";\n import initialState from './initialState.json';\n import './App.css'\n\n@@ -70,7 +74,7 @@\n                 />\n                 <HistoryPlugin/>\n                 <OnChangePlugin/>\n+                <CustomHeadingPlugin/>\n                 <div style={margin: '20px 0px'}>\n                     <CustomHistoryActions/>\n                     <CustomHeadingActions/\n```\n\n👉 참고: 이전에 다뤘지만 다시 한 번 상기시키자면... 테마 구성을 업데이트하여 각 헤딩 엘리먼트에 적용하려는 CSS 클래스 이름을 지정할 수 있어요:\n\n```js\nIndex: src/App.tsx\n\n@@ -62,6 +62,14 @@\n                 subscript: 'text-subscript',\n                 superscript: 'text-superscript',\n             },\n+            heading: {\n+                // Flowbite examples: https://flowbite.com/docs/typography/headings/#heading-one-h1\n+                h1: \"text-5xl font-extrabold dark:text-white\",\n+                h2: \"text-4xl font-bold dark:text-white\",\n+                h3: \"text-3xl font-bold dark:text-white\",\n+                h4: \"text-2xl font-bold dark:text-white\",\n+                h5: \"text-xl font-bold dark:text-white\",  \n+            },\n             banner: 'banner'\n         },\n         onError: (e) => {\n```\n\n\n\n# 커스텀 노드를 만드는 방법\n\n이전 섹션에서는 기본적으로 모든 것을 다루었으니, 이번 섹션에서는 직접 노드를 만들어보겠습니다. 제가 생각하기에 렉시컬이 노드를 처리하는 전체 그림을 파악하게 될 것입니다.\n\n가장 간단한 배너 노드:\n\n```js\nimport {\n    EditorConfig,\n    ElementNode,\n    LexicalEditor,\n    SerializedElementNode,\n    Spread,\n} from \"lexical\";\n\nexport type SerializedBannerNode = Spread<\n    {\n        customValue: string;\n    },\n    SerializedElementNode\n>;\n\nexport class BannerNode extends ElementNode {\n    createDOM(_config: EditorConfig, _editor: LexicalEditor): HTMLElement {\n        const div = document.createElement(\"div\");\n        div.className = _config.theme.banner;\n        return div;\n    }\n\n    static clone(node: BannerNode): BannerNode {\n        return new BannerNode(node.__key);\n    }\n\n    static getType(): string {\n        return \"banner\";\n    }\n\n    /**\n     * Returning false tells Lexical that this node does not need its\n     * DOM element replacing with a new copy from createDOM.\n     */\n    updateDOM(\n        _prevNode: unknown,\n        _dom: HTMLElement,\n        _config: EditorConfig,\n    ): boolean {\n        return false;\n    }\n\n    exportJSON(): SerializedBannerNode {\n        return {\n            type: \"banner\",\n            version: 1,\n            children: [],\n            customValue: \"anything you like\",\n            format: \"\",\n            indent: 1,\n            direction: null,\n        };\n    }\n}\n```\n\n\n\n설명:\n- 새로운 어휘 노드를 만들려면 미리 정의된 어휘 노드(ElementNode | TextNode | DecoratorNode 중 하나를 확장한 클래스를 만들고 메서드를 재정의해야 합니다(모든 메서드를 다루지는 않겠습니다));\n- 먼저, 어휘는 노드의 타입에 대한 일치 항목을 찾으려고 할 것이며, 타입 함수를 호출하여 구성 노드 배열('banner'의 경우)에서 지정한 노드들로부터 getType 함수를 호출할 것입니다;\n- 그 다음으로, 어휘는 HTML 요소를 만드는 createDOM 메서드를 호출할 것입니다;\n- OnChangePlugin에 toJSON 함수가 있는 것을 기억하시나요?\n\n```js\n// src/components/OnChangePlugin/OnChangePlugin.tsx\n\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {useEffect} from \"react\";\n\nexport const OnChangePlugin = () => {\n    const [editor] = useLexicalComposerContext();\n    useEffect(() => {\n        return editor.registerUpdateListener((listener) => {\n            console.log('DATA', listener.editorState.toJSON())\n        });\n    }, [editor]);\n\n    return null;\n}\n```\n\n여기서 우리의 Banner exportJSON 함수가 호출될 것입니다.\n\n\n\n이제 BannerNode를 위한 플러그인을 생성해야 합니다. 이미 Headings 섹션에서 이를 수행한 적이 있습니다:\n\n```js\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {$getSelection, $isRangeSelection, COMMAND_PRIORITY_NORMAL, createCommand} from \"lexical\";\nimport {\n    $setBlocksType\n} from \"@lexical/selection\";\nimport {BannerNode} from \"../../nodes\";\nimport React from \"react\";\n\nexport const $createBannerNode = (): BannerNode => new BannerNode();\n\nexport const INSERT_BANNER_COMMAND = createCommand(\"create_banner\");\n\nexport const CustomBannerPlugin: React.FC = () => {\n    const [editor] = useLexicalComposerContext();\n\n    if (!editor.hasNode(BannerNode)) {\n        throw new Error('BannerPlugin: \"BannerNode\" not registered on editor');\n    }\n    editor.registerCommand(\n        INSERT_BANNER_COMMAND,\n        () => {\n            const selection = $getSelection();\n            if ($isRangeSelection(selection)) {\n                $setBlocksType(selection, $createBannerNode);\n            }\n            return true;\n        },\n        COMMAND_PRIORITY_NORMAL,\n    );\n\n    return null;\n};\n```\n\nCustomBannerActions 컴포넌트를 추가하세요: 우리 명령어와 함께 간단한 버튼이 있습니다:\n\n```js\nimport React from \"react\";\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {INSERT_BANNER_COMMAND} from \"../CustomBannerPlugin\";\n\nexport const CustomBannerActions: React.FC = () => {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = () => {\n        editor.dispatchCommand(INSERT_BANNER_COMMAND, undefined);\n    };\n\n    return (\n        <div style={{marginTop: '10px'}}>\n            <span style={{fontWeight: 'bold'}}>Heading actions</span>\n            <div>\n                <button onClick={handleOnClick}>\n                    Banner\n                </button>\n            </div>\n        </div>\n    );\n};\n```\n\n\n\nApp.tsx를 업데이트하였습니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -11,10 +11,13 @@\n     CustomAlignActions,\n     CustomHeadingActions,\n     CustomHeadingPlugin,\n+    CustomBannerPlugin,\n+    CustomBannerActions,\n } from \"./components\";\n import {HeadingNode} from \"@lexical/rich-text\";\n import initialState from './initialState.json';\n import './App.css'\n+import {BannerNode} from \"./nodes\";\n \n export const App: React.FC = () => {\n \n@@ -43,7 +46,10 @@\n \n     const lexicalConfig: InitialConfigType = {\n         namespace: 'My Rich Text Editor',\n-        nodes: [HeadingNode],\n+        nodes: [\n+            BannerNode,\n+            HeadingNode\n+        ],\n         theme: {\n             text: {\n                 bold: \"text-bold\",\n@@ -55,6 +61,7 @@\n                 subscript: 'text-subscript',\n                 superscript: 'text-superscript',\n             },\n+            banner: 'banner'\n         },\n         onError: (e) => {\n             console.log('ERROR:', e)\n@@ -75,8 +82,10 @@\n                 <HistoryPlugin/>\n                 <OnChangePlugin/>\n                 <CustomHeadingPlugin/>\n+                <CustomBannerPlugin/>\n                 <div style={margin: '20px 0px'}>\n                     <CustomHistoryActions/>\n+                    <CustomBannerActions/>\n                     <CustomHeadingActions/>\n                     <CustomTextActions/>\n                     <CustomAlignActions/>\n```\n\nCSS:\n\n```js\nIndex: src/App.css\n\n@@ -33,6 +33,13 @@\n     vertical-align: super ;\n }\n \n+.banner {\n+    border-left: 3px coral solid;\n+    background-color: lightskyblue;\n+    border-radius: 3px;\n+    padding: 10px 0;\n+}\n+\n p {\n     margin: 0;\n }\n```\n\n\n\n결과:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1334/1*zesdcbkZmVlSoY1HaflYUA.gif\" />\n\n🔴 문제가 두 가지 있을 것입니다:\n\n- 사용자가 Enter 키 또는 Shift+Enter 키를 눌러 노드에서 \"나가기\"를 할 수 없을 것입니다.\n- 사용자가 Backspace 키를 눌러 노드를 \"제거\"할 수 없을 것입니다.\n\n\n\n우리의 BannerNode를 업데이트해 봅시다:\n\n```js\nIndex: src/nodes/BannerNode/BannerNode.tsx\n\n@@ -2,6 +2,9 @@\n     EditorConfig,\n     ElementNode,\n     LexicalEditor,\n+    $createParagraphNode,\n+    LexicalNode,\n+    RangeSelection,\n     SerializedElementNode,\n     Spread,\n } from \"lexical\";\n@@ -40,6 +43,34 @@\n         return false;\n     }\n\n+    /**\n+     * 사용자가 모든 콘텐츠를 삭제할 때 노드를 단락으로 설정해야 합니다\n+     */\n+    collapseAtStart(_: RangeSelection): boolean {\n+        const paragraph = $createParagraphNode();\n+        const children = this.getChildren();\n+        children.forEach((child) => paragraph.append(child));\n+        this.replace(paragraph);\n+\n+        return true;\n+    }\n+\n+    /**\n+     * 사용자가 Enter 키를 누를 때 노드를 단락으로 설정해야 합니다.\n+     * Shift+Enter를 누를 경우 노드는 유지됩니다\n+     */\n+    insertNewAfter(\n+        _: RangeSelection,\n+        restoreSelection?: boolean,\n+    ): LexicalNode | null {\n+        const paragraph = $createParagraphNode();\n+        const direction = this.getDirection();\n+        paragraph.setDirection(direction);\n+        this.insertAfter(paragraph, restoreSelection);\n+\n+        return paragraph;\n+    }\n+\n     exportJSON(): SerializedBannerNode {\n         return {\n             type: \"banner\",\n```\n\n지금까지 얻은 것을 확인해 보겠습니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1334/1*44Wg5Stz5crAXpP3Qi-PRA.gif\" />\n\n\n\n🟢 업데이트 후:\n\n- 사용자는 노드에서 Enter 키를 눌러 \"나가기\" 할 수 있습니다;\n- 사용자는 노드를 Shift + Enter 키를 눌러 \"확장\"할 수 있습니다;\n- 사용자는 콘텐츠 텍스트가 비어 있을 때 Backspace 키를 눌러 노드를 \"삭제\"할 수 있습니다;\n\n마지막으로, 에디터의 JSON 트리에서 BannerNode을 파싱하는 함수가 필요합니다:\n\n```js\nIndex: src/nodes/BannerNode/BannerNode.tsx\n\n@@ -71,6 +71,10 @@\n         return paragraph;\n     }\n \n+    static importJSON(_: SerializedBannerNode): BannerNode {\n+        return new BannerNode();\n+    }\n+\n     exportJSON(): SerializedBannerNode {\n         return {\n             type: \"banner\",\n```\n\n\n\n# 깃허브 리포지토리:\n\n관련된 기사들:\n\n이 글이 도움이 되었기를 바랍니다. 만약 그렇다면, \"claps\"를 주시면 감사하겠습니다.\n\n# 간단히 설명\n\n\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 작가를 칭찬하고 팔로우하세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입하세요. 🗞️\n- 트위터, 링크드인, 유튜브, 그리고 디스코드에서 저희를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png","tag":["Tech"],"readingTime":31},{"title":"리액트와 ASPNet Core 웹 API를 사용한 Full Stack CRUD 애플리케이션 개발하기","description":"","date":"2024-05-14 10:58","slug":"2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI","content":"\n\n리액트를 사용하여 ASP.NET Core 웹 API와 함께 전체 스택 CRUD 애플리케이션을 만드는 것은 강력한 방법입니다. 견고하고 효율적인 웹 애플리케이션을 개발하는 데 도움이 됩니다. 이 안내서에서는 CRUD 작업의 기본 원리를 탐구하고 React 프론트엔드와 ASP.NET Core 웹 API 백엔드를 설정하고 연결하는 단계별 프로세스를 살펴볼 것입니다. 각 계층의 복잡성과 상호 작용을 이해하여 개발자는 확장 가능하고 효율적인 전체 스택 애플리케이션을 구축하는 데 능숙해질 수 있습니다.\n\n# 전체 스택 CRUD 애플리케이션 소개\n\n전체 스택 CRUD (생성, 읽기, 업데이트, 삭제) 애플리케이션을 만드는 것은 프론트엔드와 백엔드 구성 요소 모두를 데이터베이스와 상호 작용하도록 구축하는 것을 포함합니다. 이를 통해 사용자는 기본적인 데이터베이스 작업을 원활하게 수행할 수 있습니다.\n\n# CRUD 작업 이해\n\n\n\n데이터베이스 작업시 사용되는 기본 작업은 CRUD 연산입니다. Create는 새 데이터를 추가하고, Read는 기존 데이터를 검색하며, Update는 데이터를 수정하고, Delete는 데이터를 삭제합니다. 이러한 작업들은 상호 작용하는 애플리케이션의 기본을 형성합니다.\n\nASP.Net Core Web API 백엔드 개발\n\nASP.Net Core Web API를 사용하여 백엔드를 구축하는 것은 데이터 작업을 처리하고 프론트엔드 애플리케이션과 상호 작용하는 견고한 기반을 만드는 것을 의미합니다.\n\n먼저 시작하기 위해 먼저 Visual Studio에서 필요한 종속성을 설치해야 합니다. 이를 위해 Tools-`NuGet Package Manager-` Manage Nuget Packages for solution로 이동해야 합니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png)\n\n\n그러고 나서 이 패키지들을 모두 설치하세요,\n\n- Microsoft.EntityFrameworkCore.Design\n- Microsoft.EntityFrameworkCore.SqlServer\n- Microsoft.EntityFrameworkCore.Tools\n- Newtonsoft.Json\n\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_1.png)\n\n\n\n\n첫 번째 단계로 모델 폴더를 선택한 후에 마우스 오른쪽 단추를 클릭하여 Student.cs 클래스를 만드세요.\n\n## Student.cs\n\n```js\nusing System.ComponentModel.DataAnnotations;\n\nnamespace ReactASPCrud.Models\n{\n    public class Student\n    {\n\n    [Key] // 이것을 추가한 후에 위 라이브러리(DataAnnotations)가 자동으로 작성됩니다.\n    public int id { get; set; }\n    public string stname { get; set; }\n\n    public string course { get; set; }\n\n    }\n}\n```\n\n## StudentDbContext.cs\n\n\n\n```cs\nusing Microsoft.EntityFrameworkCore;\n\nnamespace ReactASPCrud.Models\n{\n    public class StudentDbContext : DbContext\n    {\n\n        public StudentDbContext(DbContextOptions<StudentDbContext> options) : base(options) \n        {\n        \n        }\n    \n        public DbSet<Student> Students { get; set; }\n\n        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n        {\n            optionsBuilder.UseSqlServer(\"Data Source=.; initial Catalog=lbs;User Id=test; password=123; TrustServerCertificate= True\");\n        }\n\n    }\n}\n```\n\n이곳에 SQL 인증을 추가하는 대신, 위의 OnConfiguring 메소드에 아래 코드를 사용하여 Windows 인증을 적용할 수 있습니다. (여기서는 id, password를 추가할 필요가 없습니다)\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_2.png)\n\n```js\nData Source=DIVANI\\SQLEXPRESS;Database=lbs;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\n```\n\n\n\n- 데이터 원본 = DIVANI\\SQLEXPRESS: 서버 이름 또는 IP 주소.\n- 데이터베이스 = lbs: 데이터베이스의 이름.\n- 통합 보안 = True: Windows 인증을 사용하여 연결을 인증하는 것을 나타냅니다.\n- 연결 제한 시간 = 30: 연결 제한 시간(초).\n- 암호화 = False: 암호화 비활성화.\n- 서버 인증서 신뢰 = False: 서버 인증서 신뢰.\n- 애플리케이션 의도 = ReadWrite: 읽기 및 쓰기 작업을 위한 의도.\n- 멀티 서브넷 장애 조치 = False: 멀티 서브넷 장애 조치 설정. 이 설정은 클라이언트가 더 나은 오류 허용성을 위해 여러 서브넷을 통해 데이터베이스에 연결할 수 있게 합니다.\n\n데이터베이스 연결 설정하기\n\n다음 내용을 Program.cs 파일에 추가합니다.\n\n```js\nbuilder.Services.AddDbContext<StudentDbContext>(options =>\noptions.UseSqlServer(builder.Configuration.GetConnectionString(\"StudentDbContext\")));\n```\n\n웹 API에 이 권한을 허용하도록 설정하기\n\n```js\napp.UseCors(policy => policy.AllowAnyHeader()\n.AllowAnyMethod()\n.SetIsOriginAllowed(origin => true)\n.AllowCredentials());\n```\n\n\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\n| Header1 | Header2 | Header3 |\n| ------- | ------- | ------- |\n| Data1   | Data2   | Data3   |\n| Data4   | Data5   | Data6   |\n\n\n이제 위의 코드를 Program.cs 파일 내 어디에 붙여넣어야 하는지 알려줄 거에요.\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ReactAspCrud.Models;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// 컨테이너에 서비스 추가.\n\nbuilder.Services.AddControllers();\n// 더 자세한 Swagger/OpenAPI 구성 방법은 https://aka.ms/aspnetcore/swashbuckle에서 확인하세요.\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddDbContext<StudentDbContext>(options =>\n   options.UseSqlServer(builder.Configuration.GetConnectionString(\"StudentDbContext\")));\n\nvar app = builder.Build();\napp.UseCors(policy => policy.AllowAnyHeader()\n                            .AllowAnyMethod()\n                            .SetIsOriginAllowed(origin => true)\n                            .AllowCredentials());\n\n// HTTP 요청 파이프라인 구성.\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n이제 appsettings.json 파일에 연결 문자열을 추가하세요.\n\n```json\n{\n  \"ConnectionStrings\": {\n    \"StudentDbContext\": \"Data Source=DIVANI\\SQLEXPRESS;Database=lbs;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\"\n  }\n}\n```\n\n\n\n그 후에 도구-`NuGet 패키지 관리자-`패키지 관리자 콘솔로 이동하여 아래 명령어를 추가하십시오:\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_3.png)\n\nadd-migration initial\n\nupdate-database\n\n\n\n마이그레이션 파일을 생성하고 나서 데이터베이스가 만들어졌습니다. SQL Server를 열어서 데이터베이스가 생성되었는지 확인해보세요. 동시에 프로젝트에 마이그레이션 폴더가 생성되어 있습니다. 해당 폴더를 확인할 수 있습니다.\n\n이제 SQL Server를 통해 추가되었는지 확인할 수 있습니다.\n\n![이미지 1](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_4.png)\n\n![이미지 2](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_5.png)\n\n\n\n이후에 Controller 폴더를 선택하고 Web API로 Student Controller를 생성하세요.\n\n![이미지1](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_6.png)\n\n![이미지2](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_7.png)\n\n![이미지3](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_8.png)\n\n\n\n이제 StudentController.cs 파일에 API를 만들어야 합니다.\n\n여기서 API 내에서 CRUD 작업을 처리하기 위한 엔드포인트를 생성할 것입니다. POST, GET, PUT 및 DELETE와 같은 HTTP 동사를 사용하여 데이터를 생성, 읽기, 업데이트 및 삭제하는 메서드를 구현할 것입니다.\n\n## StudentController.cs\n\n```csharp\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing ReactAspCrud.Models;\n\nnamespace ReactAspCrud.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class StudentController : ControllerBase\n    {\n        private readonly StudentDbContext _studentDbContext;\n\n        public StudentController(StudentDbContext studentDbContext)\n        {\n            _studentDbContext = studentDbContext;\n        }\n\n        [HttpGet]\n        [Route(\"GetStudent\")]\n        public async Task<IEnumerable<Student>> GetStudents()\n        {\n            return await _studentDbContext.Student.ToListAsync();\n        }\n\n        [HttpPost]\n        [Route(\"AddStudent\")]\n        public async Task<Student> AddStudent(Student objStudent)\n        {\n            _studentDbContext.Student.Add(objStudent);\n            await _studentDbContext.SaveChangesAsync();\n            return objStudent;\n        }\n\n        [HttpPatch]\n        [Route(\"UpdateStudent/{id}\")]\n        public async Task<Student> UpdateStudent(Student objStudent)\n        {\n            _studentDbContext.Entry(objStudent).State= EntityState.Modified;\n            await _studentDbContext.SaveChangesAsync();\n            return objStudent;\n        }\n\n        [HttpDelete]\n        [Route(\"DeleteStudent/{id}\")]\n        public bool DeleteStudent(int id) \n        {\n            bool a = false;\n            var student = _studentDbContext.Student.Find(id);\n            if (student != null)\n            {\n                a = true;\n                _studentDbContext.Entry(student).State= EntityState.Deleted;\n                _studentDbContext.SaveChanges();\n            }\n            else\n            {\n                a = false;\n            }\n            return a;\n        }\n    }\n}\n```\n\n\n\n프로그램을 실행한 후 Swagger를 통해 확인할 수 있어요.\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_9.png)\n\n값을 실행하여 각 API 컨트롤러가 작동하는지 확인하세요.\n\n# 어플리케이션을 위한 React Frontend 설정\n\n\n\n이제 백엔드 개발 부분을 이미 마무리했군요.\n\n이제 프론트엔드 개발 부분으로 넘어가 볼까요?\n\n먼저, 관련 경로 내에서 React 앱을 생성해야 합니다.\n\n![React app 생성](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_10.png)\n\n\n\n그럼 명령 프롬프트에 다음 명령을 입력해야 해요:\n\nnpx create-react-app my-app\ncd my-app\n\nReact 프로젝트를 VS code 편집기에서 열고 React 앱을 실행하려면 이 명령을 추가하세요,\n\ncode .\nnpm start\n\n\n\n이제 React 환영 페이지를 보실 수 있습니다.\n\n그 후 다음 명령어를 입력하여 Bootstrap을 설치하십시오.\n\nnpm i bootstrap\n\n그 후 다음 명령어를 입력하여 axios를 설치하십시오.\n\n\n\nnpm i axios\n\nVS code에서 프로젝트를 열고 아래 코드를 추가하세요,\n\n## App.js\n\n```js\nimport './App.css';\nimport StudentCrud from './components/StudentCrud';\n\nfunction App() {\n  return (\n    <div>\n      <StudentCrud/>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n\n\n새 폴더(components)를 만든 후, 그 안에 StudentCrud.js 파일을 생성하고 아래 코드를 추가해주세요.\n\n<img src=\"/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_11.png\" />\n\n## StudentCrud.js\n\n```js\nimport axios from \"axios\";\nimport { useEffect, useState } from \"react\";\n\nfunction StudentCrud(){\n\nconst [id, setId] = useState(\"\");\nconst [stname, setName] = useState(\"\");\nconst [course, setCourse] = useState(\"\");\nconst [students, setUsers] = useState([]);\n\n  useEffect(() => {\n    (async () => await Load())();\n  }, []);\n\n  async function Load() {\n\n    const result = await axios.get(\"https://localhost:7135/api/Student/GetStudent\");\n    setUsers(result.data);\n    console.log(result.data);\n  }\n\n  async function save(event) {\n\n    event.preventDefault();\n    try {\n      await axios.post(\"https://localhost:7135/api/Student/AddStudent\", {\n\n        stname: stname,\n        course: course,\n\n      });\n      alert(\"학생 등록 성공\");\n          setId(\"\");\n          setName(\"\");\n          setCourse(\"\");\n\n\n      Load();\n    } catch (err) {\n      alert(err);\n    }\n  }\n  async function editStudent(students) {\n    setName(students.stname);\n    setCourse(students.course);\n\n\n    setId(students.id);\n  }\n\n  async function DeleteStudent(id) {\n\n  await axios.delete(\"https://localhost:7135/api/Student/UpdateStudent/\" + id);\n  alert(\"학생이 성공적으로 삭제되었습니다\");\n  setId(\"\");\n  setName(\"\");\n  setCourse(\"\");\n  Load();\n  }\n\n  async function update(event) {\n    event.preventDefault();\n    try {\n      //this is API handling the path\n  await axios.patch(\"https://localhost:7135/api/Student/UpdateStudent/\"+ students.find((u) => u.id === id).id || id,\n        {\n        id: id,\n        stname: stname,\n        course: course,\n        }\n      );\n      alert(\"등록이 업데이트되었습니다\");\n      setId(\"\");\n      setName(\"\");\n      setCourse(\"\");\n\n      Load();\n    } catch (err) {\n      alert(err);\n    }\n  }\n\n\nreturn(\n //student form\n<div>\n<h1>학생 세부 정보</h1>\n      <div class=\"container mt-4\">\n        <form>\n          <div class=\"form-group\">\n\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              id=\"id\"\n              hidden\n              value={id}\n              onChange={(event) => {\n                setId(event.target.value);\n              }\n            />\n            <label>학생 이름</label>\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              id=\"stname\"\n              value={stname}\n              onChange={(event) => {\n                setName(event.target.value);\n              }\n            />\n          </div>\n          <div class=\"form-group\">\n            <label>과정</label>\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              id=\"course\"\n              value={course}\n              onChange={(event) => {\n                setCourse(event.target.value);\n              }\n            />\n          </div>\n          <div>\n            <button class=\"btn btn-primary mt-4\" onClick={save}>\n              등록\n            </button>\n            <button class=\"btn btn-warning mt-4\" onClick={update}>\n              업데이트\n            </button>\n          </div>\n        </form>\n      </div>\n      <br></br>\n\n\n      <table class=\"table table-dark\" align=\"center\">\n        <thead>\n          <tr>\n            <th scope=\"col\">학생 아이디</th>\n            <th scope=\"col\">학생 이름</th>\n            <th scope=\"col\">과정</th>\n\n            <th scope=\"col\">옵션</th>\n          </tr>\n        </thead>\n        {students.map(function fn(student) {\n          return (\n            <tbody>\n              <tr>\n                <th scope=\"row\">{student.id} </th>\n                <td>{student.stname}</td>\n                <td>{student.course}</td>\n\n                <td>\n                  <button\n                    type=\"button\"\n                    class=\"btn btn-warning\"\n                    onClick={() => editStudent(student)}\n                  >\n                    편집\n                  </button>\n                  <button\n                    type=\"button\"\n                    class=\"btn btn-danger\"\n                    onClick={() => DeleteStudent(student.id)}\n                  >\n                    삭제\n                  </button>\n                </td>\n              </tr>\n            </tbody>\n          );\n        })}\n      </table>\n</div>\n);\n}\n\nexport default StudentCrud;\n```\n\n\n\n프론트엔드와 백엔드 간 통신 수립하기\nReact 프론트엔드와 ASP.Net Core 웹 API 백엔드가 준비되었습니다. 이제 이들끼리 소통할 시간이에요. 이 디지털 소개팅을 설정하고 둘 사이에 원활한 통신 경로를 수립해봅시다.\n\nReact 컴포넌트에서 API 엔드포인트 사용하기\nReact 컴포넌트들은 마치 만물뷔페에서 배고픈 십대처럼, ASP.Net Core 웹 API에서 제공하는 API 엔드포인트를 소비하기를 열망하고 있습니다. 백엔드에서 데이터를 컴포넌트에 공급하는 방법을 배워서 UI를 기쁘게 춤추게 해보세요.\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_12.png)\n\n따라서 백엔드 코드를 실행한 후, StudentCrud.js 파일의 해당 위치에 각 웹 API 규칙에 대한 요청 URL을 추가하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_13.png)\n\n데이터 응답 및 오류 처리\n가끔 데이터가 마치 부드러운 시냇물처럼 매끈하게 흘러들어오지만, 때로는 오류가 예기치 못하게 파티에 뜬금 없이 나타나는 손님처럼 발생하기도 합니다. 전문가처럼 데이터 응답을 우아하게 처리하고 문제를 해결하는 방법을 발견하여 응용 프로그램이 매끈하게 실행되도록 유지해보세요.\n\n# 전체 스택 CRUD 애플리케이션 테스트 및 디버깅\n\nReact 컴포넌트의 유닛 테스트\n우리의 React 컴포넌트를 현미경 아래 두고 연구실 쥐처럼 테스트해보겠습니다(하지만 더 정성을 다하면서요). 각 컴포넌트가 훌륭하게 역할을 수행하고 그 귀찮은 버그를 피하여 사용자 경험을 망가뜨리는 일을 방지하는 방법을 배워보세요.\n\n\n\nAPI 엔드포인트의 통합 테스트\n탐정 모자를 살 때입니다. API 엔드포인트의 동작을 조사해보세요. 통합 테스트를 통해 백엔드 서비스가 정확히 응답하고 프론트엔드와 잘 작동하는지 확인할 수 있습니다. 셜록 홈즈가 자랑스러워할 것입니다.\n\n크로스 플랫폼 문제 해결\n크로스 플랫폼 개발의 기쁨입니다. 다양한 브라우저에서 다양한 디바이스로, 이러한 문제를 해결하고 디버그하는 방법을 탐색해보세요. 이 문제들은 어플리케이션이 이상하게 작동하게 할 수 있습니다.\n\n# 배포 및 유지보수 고려 사항\n\n배포를 위한 애플리케이션 준비\n쇼타임입니다! 풀 스택 CRUD 애플리케이션을 인터넷의 넓은 세계에 배포하기 위한 필수 단계를 배워보세요. 설정에서 최적화까지, 앱을 큰 무대에서 빛나게 할 준비를 해보세요.\n\n\n\n애플리케이션 확장 전략\n애플리케이션이 인기를 얻게 되면 확장이 매우 중요해집니다. 전체 스택 애플리케이션을 효율적으로 확장할 수 있는 전략을 알아보세요. 이를 통해 향후 증가하는 트래픽을 처리하고 최적 성능을 유지할 수 있습니다. 디지털 성장 분기점을 대비하는 것으로 생각해보세요.\n\n모니터링 및 유지보수 최고의 실천법\n애플리케이션이 러브 상태가 되면 일은 끝나지 않습니다. 애플리케이션 성능을 모니터링하고 사용자 행동을 추적하며 유지보수 루틴을 실행하는 최고의 실천법을 살펴보세요. 모든 것이 원활히 작동되도록 하기 위해 앱에 정기적인 건강 진단을 하는 느낌이죠.\n\n결론적으로, ASP.Net Core Web API를 사용한 React를 이용한 Full Stack CRUD 애플리케이션 작성에 숙달하면 다재다능하고 반응 좋은 웹 애플리케이션을 개발하고자 하는 개발자들에게 다양한 기회를 제공해줍니다. 이 기사에서 제시된 지침을 따르면 두 기술의 장점을 활용하여 사용자 경험을 원활하게 만들고 프로젝트에서 혁신을 이끌어낼 수 있습니다. 풀 스택 개발의 잠재력을 받아들이고 늘 새로운 방법을 탐구하여 기술을 향상시키고 디지털 환경의 변화하는 경험을 만들어보세요.\n\n# FAQ\n\n# 1. 풀 스택 CRUD 애플리케이션이란 무엇인가요?\n\n\n\n풀 스택 CRUD 애플리케이션은 프론트엔드 및 백엔드 기술을 이용하여 데이터를 생성, 읽기, 업데이트 및 삭제하는 웹 애플리케이션입니다. 일반적으로 사용자 인터페이스를 위한 프론트엔드 프레임워크와 데이터 및 비즈니스 로직을 관리하는 백엔드 시스템으로 구성됩니다.\n\n## 2. 이 안내를 따르려면 React 및 ASP.Net Core 이전 경험이 필요한가요?\n\nReact와 ASP.Net Core의 이전 경험이 도움이 될 수 있지만, 이 안내서는 초보자를 위한 단계별 접근 방식을 제공하도록 구성되어 있습니다. JavaScript와 C#의 기본 지식이 도움이 될 것이나, 설명과 코드 샘플은 모든 개발자 수준에게 접근하기 쉽도록 하고 있습니다.\n\n## 3. 완료 후 풀 스택 CRUD 애플리케이션을 어떻게 배포할 수 있나요?\n\n\n\n애플리케이션을 배포하는 것은 프론트엔드와 백엔드 구성 요소를 서버에 호스팅하는 과정을 말합니다. React 프론트엔드의 경우, Netlify 또는 Vercel과 같은 플랫폼에 배포할 수 있습니다. ASP.Net Core Web API 백엔드는 Azure, AWS 또는 온프레미스 서버와 같은 서비스에 호스팅할 수 있습니다. 호스팅 환경에 따라 배포 과정이 달라질 수 있습니다.\n\n# 4. 최고의 API 문서 작성 도구는 무엇인가요?\n\n- Swagger\n- Postman\n- Readme\n- Stoplight\n- Redocly\n- Document360","ogImage":{"url":"/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png"},"coverImage":"/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png","tag":["Tech"],"readingTime":16},{"title":"Google Gemini을 Nodejs 애플리케이션에 통합하는 방법","description":"","date":"2024-05-14 10:56","slug":"2024-05-14-IntegratingGoogleGeminitoNodejsApplication","content":"\n\n<img src=\"/assets/img/2024-05-14-IntegratingGoogleGeminitoNodejsApplication_0.png\" />\n\n# 구글 젬이니란?\n\n구글 젬이니는 구글 AI가 개발한 강력하고 다양한 AI 모델입니다. 젬이니는 텍스트뿐만 아니라 코드, 오디오, 이미지 및 비디오와 같은 다양한 형식에서 작동하고 이해할 수 있습니다. 이는 Node.js 프로젝트에 대한 흥미로운 가능성을 열어줍니다.\n\n이 기사에서는 구글 젬이니를 Node.js 애플리케이션에 통합하는 방법을 안내하겠습니다. 우리는 구글 젬이니 SDK를 사용할 것입니다.\n\n\n\n## 준비물\n\n- 개인 컴퓨터에 Node.Js가 설치되어 있어야 합니다.\n- API 키 생성을 위한 Google AI Platform 계정이 있어야 합니다.\n\n- Node.Js 버전 18 이상이 필요합니다.\n- Node.Js에서 import를 사용하려면 package.json 파일에 \"type\": \"module\"을 추가해야 합니다.\n\n# 시작하기\n\n\n\n새로운 Node.js 프로젝트를 만들어봅시다. 터미널을 열고 다음 명령어를 실행해주세요:\n\n```js\nmkdir google-gemini-nodejs\ncd google-gemini-nodejs\nnpm init -y\n```\n\n다음으로, Google Gemini SDK와 dotenv 패키지를 설치해주세요:\n\n```js\nnpm install @google/generative-ai dotenv\n```\n\n\n\n## 구글 AI 플랫폼 계정 생성하기\n\nGoogle Gemini SDK를 사용하려면 API 키가 필요합니다. 구글 AI 플랫폼 웹사이트를 방문하여 새 API를 생성할 수 있습니다.\n\n새 API 키를 만들려면 \"Get API Key\" 버튼을 클릭하세요. API 키를 획득한 후에는 프로젝트의 루트에 있는 .env 파일에 저장하세요.\n\n```js\nAPI_KEY=YOUR_API_KEY\n```\n\n\n\n# Google Gemini SDK 설정하기\n\n이제 API 키를 가지고 있으니 Google Gemini SDK를 설정해 봅시다. 프로젝트의 루트에 index.js라는 새 파일을 만들고 아래 코드를 추가해주세요:\n\n## Google Gemini Pro 모델\n\n```js\nimport { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\nconst gemini_api_key = process.env.API_KEY;\nconst googleAI = new GoogleGenerativeAI(gemini_api_key);\nconst geminiConfig = {\n  temperature: 0.9,\n  topP: 1,\n  topK: 1,\n  maxOutputTokens: 4096,\n};\n\nconst geminiModel = googleAI.getGenerativeModel({\n  model: \"gemini-pro\",\n  geminiConfig,\n});\n\nconst generate = async () => {\n  try {\n    const prompt = \"Tell me about google.\";\n    const result = await geminiModel.generateContent(prompt);\n    const response = result.response;\n    console.log(response.text());\n  } catch (error) {\n    console.log(\"response error\", error);\n  }\n};\n\ngenerate();\n```\n\n\n\n위 코드에서는 텍스트 생성, 번역, 그리고 멀티턴 텍스트 및 코드 채팅과 같은 자연어 작업을 처리하는 데 뛰어난 성능을 발휘하는 Google Gemini Pro 모델을 사용했습니다. 이는 사용자와 자연어로 상호 작용하는 지능형 시스템을 구축하기에 완벽한 모델입니다.\n\n## Google Gemini Vision Model\n\n```js\nimport { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport fs from \"fs/promises\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n \nconst gemini_api_key = process.env.API_KEY;\nconst googleAI = new GoogleGenerativeAI(gemini_api_key);\nconst geminiConfig = {\n  temperature: 0.4,\n  topP: 1,\n  topK: 32,\n  maxOutputTokens: 4096,\n};\n \nconst geminiModel = googleAI.getGenerativeModel({\n  model: \"gemini-pro-vision\",\n  geminiConfig,\n});\n \nconst generate = async () => {\n  try {\n    // 이미지 파일 읽기\n    const filePath = \"some-image.jpeg\";\n    const imageFile = await fs.readFile(filePath);\n    const imageBase64 = imageFile.toString(\"base64\");\n \n    const promptConfig = [\n      { text: \"이 이미지에 대해 무슨 일이 일어나고 있는지 알려줄 수 있나요?\" },\n      {\n        inlineData: {\n          mimeType: \"image/jpeg\",\n          data: imageBase64,\n        },\n      },\n    ];\n \n    const result = await geminiModel.generateContent({\n      contents: [{ role: \"user\", parts: promptConfig }],\n    });\n    const response = await result.response;\n    console.log(response.text());\n  } catch (error) {\n    console.log(\"응답 오류\", error);\n  }\n};\n \ngenerate();\r\n```\n\n위 코드에서는 이미지의 내용을 기반으로 전체 이미지를 분류하고 이미지에 대한 캡션을 생성하는 Google Gemini Vision 모델을 사용했습니다. 이는 사용자와 자연어로 상호 작용하는 지능형 시스템을 구축하기에 완벽한 모델입니다.\n\n\n\n## 어플리케이션 실행하기\n\n어플리케이션을 실행하려면 터미널을 열고 다음 명령어를 실행하세요:\n\n```js\nnode index.js\n```\n\n## 결론\n\n\n\n이 글에서는 Google Gemini를 Node.js 어플리케이션에 통합하는 방법에 대해 배웠습니다. 또한 Google Gemini Pro와 Vision 모델을 사용하여 텍스트 및 이미지 캡션을 생성하는 방법도 배웠습니다. GitHub에서 전체 소스 코드를 찾을 수 있습니다.\n\n여기까지입니다. 이 글이 유용했으면 좋겠습니다. 궁금한 점이나 피드백이 있으시다면 댓글 섹션에 공유해주세요. 기꺼이 답변해 드리겠습니다.","ogImage":{"url":"/assets/img/2024-05-14-IntegratingGoogleGeminitoNodejsApplication_0.png"},"coverImage":"/assets/img/2024-05-14-IntegratingGoogleGeminitoNodejsApplication_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 애플리케이션에 캐로셀 통합하는 방법","description":"","date":"2024-05-14 10:53","slug":"2024-05-14-HowtoIntegrateaCarouselintoReactApplications","content":"\n\n## 이 글에서는 AI 도우미와 함께 React 웹사이트를 계속해서 구축하고 있어요! React Responsive Carousel 라이브러리를 사용하여 프로젝트에 캐러셀을 추가하는 방법을 배워보세요. 예상보다 쉬워요!\n\n![이미지](/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_0.png)\n\n이 글에서는 AI와 페어 프로그래밍을 통해 배우고 있는 React 개념을 다루며 '스타 워즈 아소카' 웹사이트를 만들어 나가고 있어요.\n\n이 글에서는 React 프로젝트에 이미지 캐러셀을 추가하는 방법에 중점을 둘 거예요.\n\n\n\n프로젝트에서 React 이미지 캐러셀을 구현한 방법, 조건부 렌더링 방법 및 통합하는 동안 마주한 일부 어려움에 대해 이야기하겠습니다.\n\nReact 프로젝트에 이미지 캐러셀을 추가하는 방법을 알고 싶다면, React Responsive Carousel을 설치하고 Carousel 컴포넌트를 프로젝트에 추가하여 이미지 소스를 넣기만 하면 됩니다.\n\nReact Responsive Carousel 라이브러리를 사용해 React 프로젝트에 Carousel 컴포넌트를 추가하려면 다음 단계를 따르세요:\n\n- 다음을 실행하여 React Responsive Carousel 라이브러리를 설치하세요:\n\n\n\n```js\nnpm install react-responsive-carousel\n```\n\n- 리액트 파일에서 Carousel 컴포넌트와 스타일을 불러오세요:\n  \n```js\nimport { Carousel } from 'react-responsive-carousel';\nimport 'react-responsive-carousel/lib/styles/carousel.min.css'; // 로더가 필요합니다\n```\n\n- 프로젝트에 Carousel 컴포넌트를 추가하고 원하는 속성을 전달하세요:\n\n\n\n```js\n<뷰캐로셀>\n    <div>\n        <img src=\"/assets/image1.jpg\" />\n        <p className=\"legend\">이미지 1</p>\n    </div>\n    <div>\n        <img src=\"/assets/image2.jpg\" />\n        <p className=\"legend\">이미지 2</p>\n    </div>\n    <div>\n        <img src=\"/assets/image3.jpg\" />\n        <p className=\"legend\">이미지 3</p>\n    </div>\n</뷰캐로셀>\n```\n\n이 설정을 사용하면 프로젝트에 세 개의 슬라이드가 있는 기본 캐로셀이 포함됩니다. 이미지의 경로에 해당하는 src 속성을 조정하고 필요에 맞게 내용을 수정하세요.\n\n이 기사 시리즈를 따라오고 있거나 React 프로젝트에 이미지 캐로셀을 포함하는 방법에 대해 보다 자세한 설명을 원한다면, 이 기사 계속 읽어보세요!\n\n<img src=\"/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_1.png\" />\n\n\n\n\n# 준비물\n\n\"스타 워즈 아소카 리액트 웹사이트\"를 만드는 시리즈의 기사를 기초로, 이미지 캐러셀을 구현하는 것은 특정 개념을 익히는 것이 필요합니다. 사용된 사용자 지정 컴포넌트와 기능을 이해하기 위해 이전 기사를 참조해주세요.\n\n캐러셀을 만들기 위한 준비물은 다음과 같습니다:\n\n- 사용자 지정 메뉴 및 네비게이션 바 컴포넌트에 대한 이해.\n- 햄버거 메뉴 컴포넌트에 대한 이해.\n\n\n\n# 아티클 시리즈:\n\n- 리액트 애플리케이션에 YouTube 비디오 통합하는 방법\n- 리액트에서 동적 햄버거 메뉴 개발하기: 단계별 가이드\n- 리액트에서 드롭다운 메뉴 구축하기: 단계별 가이드\n- 파일 분리를 통한 리액트 코드 조직화 방법 안내\n- 컴포넌트 식별자를 사용하여 다양한 HTML 요소 동적 렌더링하는 방법 배우기\n\n# 리액트 반응형 캐러셀 라이브러리란?\n\n리액트 반응형 캐러셀 라이브러리는 캐러셀을 리액트 애플리케이션에 통합하는 것을 간단하게 해주는 컴포넌트입니다. 이 라이브러리는 리액트 프로젝트와 동적 캐러셀 기능 간을 원활하게 연결해줍니다. 이미지 슬라이드쇼나 콘텐츠 캐러셀을 웹 페이지 안에 쉽게 포함하고 관리할 수 있게 해줍니다. 이 라이브러리를 사용하면 설치만 하고 프로젝트에 캐러셀 컴포넌트를 삽입하고 보고 싶은 이미지나 콘텐츠로 구성만 하면 됩니다.\n\n\n\nReact Responsive Carousel 라이브러리는 React 애플리케이션에서 캐러셀의 기능과 외관을 향상시키는 다양한 사용자 정의 옵션을 제공합니다. 이러한 옵션을 사용하여 개인화된 대화형 경험을 만들 수 있습니다.\n\nReact Responsive Carousel 라이브러리의 Carousel 컴포넌트를 사용하면 다양한 속성을 사용하여 캐러셀을 사용자 정의할 수 있습니다. 이러한 속성에는 다음이 포함됩니다:\n\n- showArrows: 네비게이션 화살표를 표시할지 여부. 값: true 또는 false.\n- showStatus: 슬라이드의 현재 상태 표시 여부. 값: true 또는 false.\n- showIndicators: 네비게이션 지시기를 표시할지 여부. 값: true 또는 false.\n- infiniteLoop: 슬라이드의 무한 루핑 활성화 여부. 값: true 또는 false.\n- useKeyboardArrows: 슬라이드 간 이동에 키보드 화살표 사용 여부. 값: true 또는 false.\n- autoPlay: 슬라이드를 자동으로 순환시킬지 여부. 값: true 또는 false.\n- stopOnHover: 마우스가 캐러셀 위에 올라갈 때 슬라이드 순환 중지 여부. 값: true 또는 false.\n- interval: 슬라이드가 전환되는 간격(밀리초).\n- transitionTime: 슬라이드 간 전환 지속 시간(밀리초).\n- swipeable: 터치 지원 장치에서 슬라이드 이동을 위한 스와이프 제스처 허용 여부. 값: true 또는 false.\n- dynamicHeight: 현재 슬라이드의 높이에 따라 캐러셀 높이 조정 여부. 값: true 또는 false.\n- emulateTouch: 터치 지원되지 않는 장치에서 스와이프 활성화 여부. 값: true 또는 false.\n\n참고: 이 라이브러리는 더 이상 제작자가 유지 관리하지 않습니다. react-responsive-carousel에 대해 자세히 알아보려면 문서를 읽어보세요.\n\n\n\n# 왜 이 캐러셀 라이브러리를 선택했을까요?\n\nHashnode AI 어시스턴트에게 조언을 구해서 React 프로젝트에 캐러셀을 추가할 수 있는 옵션에 대해 물어보았어요. React Responsive Carousel은 이제 더 이상 만들자가 관리하지 않지만, 이 라이브러리는 \"사용하기 쉬운\" 캐러셀로 쉽게 구현할 수 있습니다.\n\n제가 이미지 캐러셀을 프로젝트에 구현하는 데 일정한 노력이 필요할 것이라는 것을 알고, Navbar 및 Hamburger 메뉴 구성 요소에서 이를 제어할 수 있는 기능을 원했기 때문에 쉽게 작업할 수 있는 하나를 선택했어요.\n\n# 나의 캐러셀 메뉴 구성 요소\n\n\n\n처음에, 최상의 코딩 관행을 따르기 위해 이미 제작한 메뉴 컴포넌트를 사용하여 이미지 카테고리 옵션(캐릭터, 포스터, 스틸)을 렌더링하려고 시도했습니다. 이미 \"video\" 카테고리를 제거하는 필터를 추가해야 했기 때문에 이제는 세 가지 이미지 카테고리도 필터링해야 한다는 것을 깨달았습니다.\n\n그래서, 다시 한 번 AI 어시스턴트에게 상담하여 메뉴 컴포넌트를 수정할 지, 아니면 캐러셀을 위해 새로운 컴포넌트를 만들어야 할 지 결정해보았습니다. 실제로 새로운 컴포넌트를 만들 시간이었습니다.\n\nReact를 배우면서 주목한 점: 작동하는 코드를 작성하는 방법을 알지만 여러 용도로 컴포넌트를 수정할 때와 별도의 컴포넌트를 작성해야 할 때를 결정하는 것이 여전히 어려운 것 같습니다.\n\n이전에 작성한 메뉴 컴포넌트의 컨텍스트를 제공하여 AI 어시스턴트와 함께 페어 프로그래밍을 하여 캐러셀 메뉴 컴포넌트에 유사한 기능을 만드는 데 도움이 되었습니다.\n\n\n\n## 캐러셀 메뉴 컴포넌트\n\n```js\nimport { carousel_character, carousel_poster, carousel_stills } from \"../data.js\";\n\nexport default function CarouselMenu({ setSelectedCategory, setShowCarousel }) {\n    const categoriesMap = {\n        character: carousel_character,\n        poster: carousel_poster,\n        stills: carousel_stills\n    };\n\n    const handleCategoryChange = (category) => {\n        setSelectedCategory(categoriesMap[category] || categoriesMap['character']);\n        setShowCarousel(true);\n    };\n\n    return (\n        <menu>\n            {Object.keys(categoriesMap).map((category) => (\n                <button className=\"button-sw\"\n                    key={category}\n                    onClick={() => handleCategoryChange(category)}\n                >\n                    {category.charAt(0).toUpperCase() + category.slice(1)}\n                </button>\n            ))}\n        </menu>\n    );\n}\n```\n\n# CarouselMenu 컴포넌트 이해하기\n\nCarouselMenu 컴포넌트는 사용자가 캐릭터, 포스터 및 스틸컷과 같은 이미지 카테고리 간에 전환할 수 있도록 설계되었습니다. 이 컴포넌트가 어떻게 작동하는지 분석하여 사용자가 보고 싶은 콘텐츠를 탐색하고 제어하기 쉽게 만들어 보겠습니다.\n\n\n\n## 데이터 가져오기\n\n먼저, 컴포넌트는 data.js 파일에서 특정 데이터 세트를 가져옵니다. 이 데이터 세트는 carousel_character, carousel_poster, carousel_stills라는 이름을 가지고 있으며 각각 다른 이미지 카테고리를 나타냅니다.\n\n## 컴포넌트 설정\n\nCarouselMenu는 setSelectedCategory와 setShowCarousel 두 가지 함수를 props로 받는 함수형 컴포넌트입니다. 이 함수들은 부모 컴포넌트의 상태를 업데이트하기 위해 사용되며, 표시할 이미지 카테고리와 Carousel을 표시할지 여부를 제어합니다.\n\n\n\n## 카테고리 매핑\n\n컴포넌트 내부에서 categoriesMap 객체가 생성됩니다. 이 객체는 문자열 키(`character`, `poster`, `stills`)를 이전에 가져온 대응하는 데이터셋으로 매핑합니다. 이 매핑은 사용자 선택에 따라 데이터에 쉽게 액세스할 수 있도록 합니다.\n\n## 카테고리 변경 처리\n\nhandleCategoryChange 함수는 상호작용에 매우 중요합니다. 사용자가 메뉴의 버튼 중 하나를 클릭하면 이 함수가 트리거됩니다. 이 함수는 사용자가 클릭한 버튼에 해당하는 카테고리를 인수로 받습니다. 그런 다음 함수는 다음 두 가지 작업을 수행합니다:\n\n\n\n- 선택된 카테고리와 관련된 데이터를 사용하여 setSelectedCategory를 호출하여 부모 구성요소의 상태를 업데이트하여 표시할 이미지의 새 카테고리를 반영합니다.\n- setShowCarousel을 true로 설정하여 선택된 카테고리마다 Carousel이 표시되도록 합니다.\n\n## 메뉴 렌더링\n\n이 구성요소는 각 카테고리에 대한 버튼이 포함된 `menu` 요소를 반환합니다. 이러한 버튼들은 Object.keys(categoriesMap).map(...)을 사용하여 동적으로 생성되며, 이는 categoriesMap의 키 배열을 생성하고 이를 매핑하여 각 카테고리에 대한 버튼을 만듭니다. 각 버튼은 클릭 이벤트가 있어 handleCategoryChange를 해당 카테고리로 트리거하는 것으로 설정됩니다. 버튼 레이블은 각 카테고리 이름의 첫 글자를 대문자로 변환하여 가독성을 높입니다.\n\n이 구성은 직관적인 네비게이션을 제공하고 인터페이스를 깨끗하고 집중시킴으로써 사용자 경험을 향상시킵니다. 이를 통해 Carousel 내에서 다른 데이터 세그먼트와의 원활한 상호 작용이 가능합니다.\n\n\n\n# 네비게이션바 컴포넌트\n\n네비게이션바 컴포넌트는 카테고리 메뉴, YouTube 비디오 및 이제는 React Carousel에서 이미지를 표시하는 모든 앱 기능을 처리합니다.\n\nReact Carousel에 중점을 두기 위해 여기에 더 나은 관찰을 위한 Navbar 컴포넌트의 요약 버전이 있습니다:\n\n```js\nimport { useState } from \"react\";\nimport CarouselMenu from \"./CarouselMenu\";\n\nfunction Navbar({ setSelectedCategory, setShowCarousel, carousel }) {\n    const [isGalleryVisible, setGalleryVisible] = useState(false);\n\n    return (\n        <nav>\n            <div className=\"flex-col\">\n                <div className=\"flex ctn-navbar\">\n                    <div\n                        className=\"navbar-buttons desktop-menu\"\n                        onMouseEnter={() => setGalleryVisible(true)}\n                        onMouseLeave={() => setGalleryVisible(false)}\n                    >\n                        GALLERY\n                        {isGalleryVisible && (\n                            <div className=\"dropdown-menu dropdown-menu-carousel\">\n                                <CarouselMenu\n                                    setSelectedCategory={setSelectedCategory}\n                                    setShowCarousel={setShowCarousel}\n                                    carousel={carousel}\n                                />\n                            </div>\n                        )}\n                    </div>\n                </div>\n            </div>\n        </nav>\n    );\n}\n\nexport default Navbar;\n```\n\n\n\n# 주요 포인트:\n\n- 동적 가시성: isGalleryVisible 상태는 캐러셀 메뉴의 가시성을 제어합니다. \"GALLERY\" 버튼에서의 마우스 이벤트(onMouseEnter, onMouseLeave)에 의해 토글됩니다. 이 접근 방식은 필요할 때만 캐러셀을 표시하는 사용자 친화적인 방법을 제공하여 혼잡도를 줄이고 UI 반응성을 향상시킵니다.\n- 캐러셀 메뉴 통합: \"GALLERY\" 섹션이 활성화된 경우(isGalleryVisible이 true인 경우), CarouselMenu 컴포넌트가 렌더링됩니다. 이 컴포넌트는 캐러셀에 표시될 이미지 카테고리 선택을 처리하는 데 중요합니다.\n- 상호 작용 핸들러: CarouselMenu에 setSelectedCategory 및 setShowCarousel 함수가 props로 전달됩니다. 이러한 함수는 CarouselMenu 내에서 사용되어 사용자 상호 작용에 기반하여 애플리케이션의 상태를 업데이트하는 데 사용됩니다.             \n                           \n이 설정은 Navbar 컴포넌트가 캐러셀 기능과 효과적으로 통합되어 원활하고 대화식 사용자 경험을 제공함을 보장합니다.\n\n# 햄버거 메뉴 컴포넌트\n\n\n\n이 섹션에서는 햄버거 메뉴 구성 요소 내에서 캐러셀이 통합되어 작동하는 방법을 유사하게 종합적으로 살펴볼 것입니다.\n\n## 구성 요소 구조 및 상태 관리\n\n햄버거 메뉴는 내용물의 가시성을 제어하기 위해 여러 상태 변수를 사용합니다:\n\n- isActive : 햄버거 메뉴가 활성화되어 있는지 여부를 결정합니다.\n- isCarouselVisible : 메뉴 내 캐러셀 옵션의 가시성을 제어합니다.\n\n\n\n```js\nconst [isActive, setIsActive] = useState(false);\nconst [isCarouselVisible, setCarouselVisible] = useState(false);\n```\n\n## 동적 UI 조정을 위한 효과\n\n이 컴포넌트는 React의 useEffect를 활용하여 UI의 동적 변경을 처리합니다. 활성화 상태를 기반으로 UI에서 동적 변경이 이뤄집니다. 햄버거 메뉴가 활성화되면 데이터 뱅크와 캐러셀 메뉴와 같은 다른 상호 작용 요소가 숨겨진 기본 상태로 재설정됩니다.\n\n```js\nuseEffect(() => {\n    if (isActive) {\n        setDatabankVisible(false);\n        setCarouselVisible(false); // 햄버거를 토글할 때 캐러셀 메뉴를 닫습니다\n    }\n}, [isActive]);\n```\n\n\n\n## 캐러셀 가시성 토글\n\n햄버거 메뉴에는 \"갤러리\"를 위한 인터랙티브 섹션이 포함되어 있으며 상호 작용 시 캐러셀 메뉴의 가시성을 토글합니다. 이는 마우스 이벤트(onMouseEnter 및 onMouseLeave)를 활용하여 isCarouselVisible 상태를 설정하는 방식으로 처리됩니다. 이 접근 방식은 필요할 때만 캐러셀에 접근할 수 있는 사용자 친화적인 방법을 제공하며 응용 프로그램의 사용성과 인터페이스의 청결함을 향상시킵니다.\n\n```js\n<div\n    className=\"navbar-buttons\"\n    onMouseEnter={() => setCarouselVisible(true)}\n    onMouseLeave={() => setCarouselVisible(false)}\n>\n    GALLERY\n    {isCarouselVisible && (\n        <CarouselMenu\n            setSelectedCategory={setSelectedCategory}\n            setShowCarousel={setShowCarousel}\n        />\n    )}\n</div>\n```\n\n## 기능성 및 사용자 상호작용\n\n\n\nhandleClick함수는 햄버거 메뉴의 isActivestate를 토글하여 드롭다운 메뉴 항목의 전반적인 가시성을 제어합니다. 또한 toggleCarouselfunction은 캐러셀의 가시성을 명시적으로 토글하는 방법을 제공하여 메뉴의 상호작용 능력을 더욱 향상시킵니다.\n\n```js\nfunction handleClick() {\n    setIsActive(!isActive);\n}\n```\n\n이 햄버거 메뉴 설정은 캐러셀 기능이 매끄럽게 통합되어 있어 응용 프로그램의 다양한 섹션을 탐색하기 위한 간결하고 효과적인 사용자 인터페이스를 제공합니다.\n\n# 메뉴 컴포넌트\n\n\n\n위 코드는 Menu 컴포넌트 내에서 React 캐러셀이 관리되는 방식에 초점을 맞춘 버전입니다. 기본적으로 사용자가 캐러셀에 없는 카테고리를 선택하면 React 캐러셀이 숨겨집니다:\n\n```js\nfunction Menu({ setSelectedCategory, setShowCarousel, categories }) {\n    return (\n        <menu>\n            {Object.keys(categories)\n                .filter((category) => category !== \"youtube\")\n                .map((category) => (\n                    <button className=\"button-sw\"\n                        key={category}\n                        onClick={() => {\n                            setSelectedCategory(categories[category]);\n                            setShowCarousel(false);\n                        }}\n                    >\n                        {category.charAt(0).toUpperCase() + category.slice(1)}\n                    </button>\n                ))}\n        </menu>\n    );\n}\n```\n\n# 주요 기능:\n\n- 카테고리 필터링: Menu는 특정 카테고리(예: `youtube`)를 걸러내어 표시되는 버튼을 조정합니다. 이를 통해 상호 작용할 수 있는 관련 카테고리만 포함됩니다.\n- 버튼 다이내믹스: 각 버튼은 사용 가능한 카테고리를 기반으로 동적으로 생성되며, 필터링된 항목은 제외됩니다. 버튼 텍스트는 가독성과 미적 매력을 높이기 위해 대문자로 표시됩니다.\n- 상태 관리: 버튼을 클릭하면 두 가지 중요한 기능이 호출됩니다:\n  - setSelectedCategory(categories[category]): 이 함수는 선택한 카테고리를 반영하도록 상태를 업데이트하여 캐러셀이나 다른 구성 요소에 표시되는 데이터 또는 이미지를 결정합니다.\n  - setShowCarousel(false): 이 함수는 캐러셀의 가시성을 제어하여 캐러셀을 숨길 수 있도록 합니다. 이미지와 관련이 없는 카테고리가 선택된 경우 또는 캐러셀이 필요하지 않은 경우에 사용됩니다.\n\n\n\n이 구성은 애플리케이션의 상호작용성을 향상시키고 사용자 인터페이스가 깨끗하고 집중력이 있으며 사용자 입력에 반응할 수 있도록 보장합니다.\n\n# 주요 애플리케이션 구성 요소에서 React 캐러셀 구현하기\n\nReact 애플리케이션의 주요 Appcomponent에서 React Responsive Carousel 통합은 콘텐츠의 동적 프레젠테이션을 향상시키는 데 중요한 역할을 합니다. 여기에는 캐러셀이 이 구성 내에서 어떻게 구현되고 작동하는지에 대한 개요가 있습니다:\n\n## 캐러셀 가시성을 위한 상태 관리\n\n\n\nAppComponent은 여러 상태 변수를 관리하지만 캐로셀 기능에 중요한 것은 showCarousel과 selectedCategory입니다. showCarousel 상태는 캐로셀을 표시해야 하는지 여부를 결정하고, selectedCategory는 캐로셀에 표시될 항목 데이터를 보유합니다.\n\n```js\nconst [showCarousel, setShowCarousel] = useState(false);\nconst [selectedCategory, setSelectedCategory] = useState(characters);\n```\n\n## 캐로셀의 조건부 렌더링\n\n캐로셀은 showCarousel 상태에 따라 조건부로 렌더링됩니다. showCarousel이 true이면 캐로셀이 표시되고, 그렇지 않으면 StarWarsCard와 같은 다른 컴포넌트가 표시됩니다. 이 접근 방식은 유연하고 사용자 중심의 표시를 가능하게 하며, 캐로셀과 다른 콘텐츠 뷰 간을 전환할 수 있습니다.\n\n\n\n```js\n{showCarousel가 true이면 (\n    <Carousel className=\"ctn-carousel\">\n        {selectedCategory && selectedCategory.map((item) => (\n            <div key={item.name}>\n                <img src={item.image} />\n                <p className=\"legend\">{item.name}</p>\n            </div>\n        ))}\n    </Carousel>\n)}\n```\n\n## 캐로셀 콘텐츠 동적\n\n캐로셀의 내용은 선택한 카테고리에서 동적으로 생성됩니다. 선택한 카테고리의 각 항목이 캐로셀 슬라이드에 매핑되어 이미지와 캡션(이름)이 표시됩니다. 이 동적 매핑은 캐로셀이 항상 선택한 카테고리의 콘텐츠와 최신 정보를 유지할 수 있도록 합니다.\n\n## 네비게이션 바와의 상호작용\n\n\n\nNavbar 컴포넌트는 App 컴포넌트와 상호작용하여 selectedCategory를 설정하고 showCarousel 상태를 토글합니다. 이 설정은 Navbar이 제어판 역할을 하며 어떤 콘텐츠가 어떻게 표시되는지에 영향을 미치는 역할을 명확히 보여줍니다.\n\n```js\n<Navbar\n    categories={categories}\n    setSelectedCategory={setSelectedCategory}\n    setShowCarousel={setShowCarousel}\n/>\n```\n\nApp 컴포넌트에서 이 디자인 패턴은 캐러셀이 어플리케이션의 시각적 매력을 높이는 데만 그치는 것이 아니라, 원활하고 상호작용이 가능한 사용자 경험을 제공한다는 것을 보장합니다.\n\n# 직면한 문제들\n\n\n\n초반에는 캐러셀 썸네일을 이미지 위에 표시하도록 재배치하려고 했어요. 여러 번 시도했지만 성공하지 못했어요. 먼저 리액트 캐러셀 컴포넌트 자체에 들어가보려고 했지만, 내 의심이 확인되어 내 코드 변경이 프로젝트에서 리액트 캐러셀 라이브러리를 업데이트하면 덮어씌워질 거라는 제 AI 도우미가 알려줬어요!\n\n두 번째 시도는 CSS 파일을 사용해서 캐러셀 썸네일을 이미지 위로 재배치하는 것이었어요. 하지만 AI 도우미와 함께 해도 리액트 캐러셀 컴포넌트의 구조를 재배치할 수 없었어요. 그래서 그냥 내버려두기로 결정했어요.\n\n다른 문제는 리액트 캐러셀 컴포넌트의 스타일링이었어요. 이번에 처음으로 만드는 캐러셀을 다루기 때문에 처음에는 별 생각없이 해봤는데, 살짝 어설펐어요. \"슬라이딩\" 기능도 잘 작동하지 않았을 뿐만 아니라 좌우 화살표가 이미지 중앙에 가운데 정렬된 것을 발견했어요. 좌우 화살표는 이미지 옆에 있어야 하는데 말이죠.\n\n맞아요, 제 의심이 다시 한 번 맞았어요. 이번에는 내 CSS 코드가 리액트 캐러셀과 충돌했어요. CSS 파일을 주석 처리해서 일단 내 CSS 파일을 비활성화하고 리액트 캐러셀 라이브러리의 CSS만 활성화되도록 문제를 해결할 수 있었어요. CSS 파일을 제거하고 나니 리액트 캐러셀 컴포넌트의 의도한 모습과 기능을 명확히 볼 수 있었어요.\n\n\n\n내 CSS 실수가 HTML Button 요소 자체를 대상으로 했기 때문에 React Carousel 구성요소가 의도치 않게 깨졌습니다. HTML Button 요소 자체 대신 새 클래스를 생성하고 대상으로 지정함으로써 문제를 해결했습니다.\n\n## 초기 CSS 코드는 다음과 같았습니다:\n\n```css\nbutton {\n margin: 3px;\n padding: 0;\n width: 100%;\n background-color: black;\n color: white;\n font-weight: bold;\n font-size: xx-large;\n}\n```\n\n## 코드를 다음과 같이 업데이트했습니다:\n\n\n\n```js\n.button-sw {\n margin: 3px;\n padding: 0;\n width: 100%;\n background-color: black;\n color: white;\n font-weight: bold;\n font-size: xx-large;\n}\n```\n\nReact Carousel 구성 요소에 표시된 이미지 크기 조정에도 고민이 많았어요. 기본 크기가 제공한 가장 큰 이미지에 맞는 것으로 보입니다. 제 경우에는, 가장 큰 이미지가 Carousel의 높이를 거의 전체 화면 크기로 설정했어요!\n\n\".carousel .slide img\"에 CSS 규칙을 적용하여 React Carousel 구성 요소의 높이를 올바르게 조정하고, 그 안의 이미지를 왜곡되지 않게 원하는 값으로 max-height를 설정하고, object-fit: contain을 사용하여 이미지가 컨테이너 내에서 올바르게 비율로 나타날 수 있도록 했어요.\n\n```js\n.carousel .slide img {\n max-height: 350px;\n object-fit: contain; \n}\n```\n\n\n\n마지막으로 마주한 문제는 React Carousel 구성 요소 위에 확장되어 드롭다운 메뉴가 고장이 났다는 것이었습니다. 이제 카루셀과 충돌하기 때문에 메뉴에서 새 카테고리를 선택할 수 없었고, 사용자 클릭은 이제 카루셀 구성 요소에서만 인식되었습니다.\n\n드롭다운 메뉴와 카루셀 구성 요소 사이의 충돌을 해결하기 위해 메뉴의 z-index를 1로 설정하고 카루셀 구성 요소의 z-index를 0으로 설정했습니다.\n\n# 지금까지의 프로젝트 상황\n\n프로젝트에 대한 링크는 다음과 같습니다:\n\n\n\n- GitHub 저장소\n- Netlify 배포된 프로젝트\n\n![이미지](/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_2.png)\n\n# 이 시리즈의 다른 글들\n\n- 동적으로 다양한 HTML 요소 렌더링을 위한 컴포넌트 식별자 사용 배우기\n- React에서 파일 분리를 통한 더 나은 코드 구성 안내\n- React에서 드롭다운 메뉴 만들기: 단계별 안내서\n- React에서 동적 햄버거 메뉴 개발하기: 단계별 안내서\n- React 애플리케이션에 YouTube 비디오 통합하는 방법\n\n\n\n# 결론\n\n프로젝트에 이미지 캐러셀을 추가하면 시각적으로 향상되며, React Responsive 캐러셀 라이브러리를 사용하면 구현이 간단해집니다! 그냥 설치하고, Carousel 컴포넌트를 프로젝트에 추가하고, 이미지와 다른 선택적 매개변수를 전달하면 됩니다.\n\n이 라이브러리를 만든 사람은 더 이상 관리하지 않지만, 초보자 프로젝트를 만들 때 좋은 선택입니다.\n\n그래서, 프로젝트에 캐러셀을 구현하는 것은 내게 쉽지 않은 일이었는데, 내가 사용자 정의 드롭다운 메뉴를 사용하여 제어하기로 선택했기 때문입니다. 이 어려움은 React 캐러셀 컴포넌트 자체가 아닌 내가 설계한 레이아웃에서 나온 것입니다.\n\n\n\n시행착오 끝에 AI 도우미의 도움을 받아 모든 문제를 해결하고 React 캐러셀을 예상대로 작동하도록 성공적으로 구현했어요.\n\n알게 된 것은 React 컴포넌트 내의 코드를 직접 변경하거나 추가해서는 안 된다는 점이에요. 변경 사항은 덮어씌워지기 때문이죠! 대신, React Carousel 컴포넌트의 경우 CSS 코드를 작성하여 세밀한 조정을 할 수 있었어요. 단, React Carousel은 자체 CSS 파일을 가지고 있으며, 코드 충돌을 피하기 위해 HTML 요소를 직접 대상으로 삼지 않고 클래스 이름을 추가하는 것이 좋아요. 처음에 했던 것처럼!\n\n저와 연락을 유지해요! LinkedIn과 Twitter에서 활동 중이에요.\n\n![이미지](/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_3.png)\n\n\n\n당신은 selftaughttxg.com에서 제가 쓴 모든 글을 읽을 수 있어요.\n\n이제 React Responsive Carousel 라이브러리를 사용하여 캐러셀을 React 프로젝트에 통합하는 방법을 알게 되었나요? 여러분의 프로젝트에서 비슷한 어려움을 겪은 적이 있나요? 이 글을 공유하고 의견을 남겨주세요!","ogImage":{"url":"/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoIntegrateaCarouselintoReactApplications_0.png","tag":["Tech"],"readingTime":16},{"title":"리액트 NextJS 앱에 Material UI 통합하기","description":"","date":"2024-05-14 10:52","slug":"2024-05-14-IntegratingMaterialUIintoaReactNextJSapp","content":"\n\n이제 Material UI를 NextJS 앱에 추가하는 방법을 자세히 살펴보겠습니다. 빠르게 실행할 수 있도록 도와 드리겠습니다!\n\n![image](/assets/img/2024-05-14-IntegratingMaterialUIintoaReactNextJSapp_0.png)\n\n빨리 보고 싶다면 여기에서 전체 변경 사항을 확인할 수 있어요 😄. 이것은 react-portfolio-app의 일부로 더 큰 프로젝트의 일부입니다.\n\n먼저 Material UI, emotion/react 및 emotion/styled를 설치하는 일반적인 설치 가이드를 따라 시작하세요.\n\n\n\n```js\nyarn add @mui/material @emotion/react @emotion/styled\n```\n\nEmotion styled 컴포넌트를 사용하여 스타일이 적용된 React 컴포넌트를 정의할 수 있어요. JSX 형식으로 모든 것이 포함되어 가독성이 더 높아지고 스타일링이 재사용 가능한 컴포넌트에 포함되어 있어요.\n\n# NextJS를 위한 특정 구성 변경\n\n어플리케이션에 대해 세 가지 변경 사항이 필요해요.\n\n\n\n- 앱 라우터 추가\n- 테마 생성\n- 테마를 ThemeProvider 클라이언트 렌더링 파일에서 사용\n\nNextJS 통합을 위한 Material UI와 관련된 특정 종속성을 설치해야 합니다. 페이지 라우터 대신 앱 라우터를 사용해야 합니다.\n\n```js\nyarn add @mui/material-nextjs @emotion/cache\n```\n\n## 1. 앱 라우터 추가\n\n\n\nAppRouterCacheProvider를 루트 레이아웃에 추가해보세요.\n\n```js\n// app/layout.tsx\nimport { AppRouterCacheProvider } from '@mui/material-nextjs/v13-appRouter';\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>\n        <AppRouterCacheProvider>\n          {children}\n        </AppRouterCacheProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n## 2. 테마 생성\n\ntheme.ts 파일을 만들고 문서에서 설명된 대로 ThemeProvider에서 사용할 테마를 정의하세요.\n\n\n\n```js\r\n// app/theme.ts\n'use client';\nimport { Roboto } from 'next/font/google';\nimport { createTheme } from '@mui/material/styles';\n\nconst roboto = Roboto({\n  weight: ['300', '400', '500', '700'],\n  subsets: ['latin'],\n  display: 'swap',\n});\n\nconst theme = createTheme({\n  typography: {\n    fontFamily: roboto.style.fontFamily,\n  },\n});\n\nexport default theme;\r\n```\n\n## 3. 테마를 ThemeProvider 클라이언트 렌더링 파일에서 사용하기\n\n루트 layout.tsx에 ThemeProvider를 직접 추가하는 대신, ThemeProvider 및 layout.tsx에서 호출할 별도의 파일을 생성해야 합니다. 이렇게 하는 이유는 ThemeProvider가 클라이언트 측 컨텍스트를 설정하기 때문에 서버 측에서 렌더링할 수 없으므로 코드를 자체 클라이언트 렌더링 파일로 가져와서 layout.tsx에서 호출합니다.\n\n이 새 파일인 StyledRoot.tsx에서는 client-side rendered 파일임을 나타내기 위해 파일을 'use client'로 시작합니다 (더 읽기). 파일은 다음과 같이 보일 것입니다:\n\n\n\n```js\n// app/StyledRoot.tsx\n'use client';\nimport { ThemeProvider } from '@mui/material/styles';\nimport theme from './theme';\n\nexport function StyledRoot({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <ThemeProvider theme={theme}>\n      {children}\n    </ThemeProvider>\n  );\n}\n```\n\n그런 다음 우리는 레이아웃(layout.tsx)에 이를 추가하여 자식 구성 요소를 StyledRoot.tsx로 전달합니다.\n\n```js\n// app/layout.tsx\nimport { AppRouterCacheProvider } from '@mui/material-nextjs/v13-appRouter';\nimport { StyledRoot } from './StyledRoot';\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>\n        <AppRouterCacheProvider>\n           <StyledRoot>{children}</StyledRoot>\n        </AppRouterCacheProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n그래서 마무리입니다!\n\n\n\n이제 Material UI를 사용하여 NextJs 앱을 실행할 수 있습니다. 다음 단계는 컴포넌트를 추가하는 것입니다!\n\n컴포넌트 라이브러리를 살펴보며 디자인을 지원하는 컴포넌트를 확인하고, 해당 컴포넌트를 구현하는 방법에 대한 코드 예제를 살펴보세요!\n\nMaterial UI 템플릿도 훌륭한 자료입니다. 실제로 Material UI 컴포넌트를 사용하는 다양한 예제를 제공합니다. 저는 포트폴리오 앱을 구축할 때 블로그 템플릿에 특별히 관심을 가졌어요.\n\n이상으로 모두인데요! 이 기사가 도움이 되었는지, 빠진 중요한 내용이 있는지 알려주세요!","ogImage":{"url":"/assets/img/2024-05-14-IntegratingMaterialUIintoaReactNextJSapp_0.png"},"coverImage":"/assets/img/2024-05-14-IntegratingMaterialUIintoaReactNextJSapp_0.png","tag":["Tech"],"readingTime":4}],"page":"115","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}