{"pageProps":{"posts":[{"title":"iOS 앱의 모놀리스 구조를 모듈화하는 방법","description":"","date":"2024-05-15 03:13","slug":"2024-05-15-HowtomodularizeMonolithiOSApp","content":"\n\n이것은 내 블로그에서의 게시물 전문입니다. 만약 원하신다면 거기서 읽어보실 수 있습니다. 혹은 비디오를 선호하신다면 여기서 찾아볼 수도 있어요.\n\n![이미지](/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_0.png)\n\n안녕하세요 iOS 개발자 여러분!\n어플리케이션이 시간이 지남에 따라 복잡성이 증가했다면, 모듈화는 개발 효율성, 빌드 시간, 확장성, 유지보수성 등을 개선하는 좋은 전략일 수 있습니다. 오늘은 모놀리스 앱에서 모듈식 앱으로의 전환 경로를 단계별로 정확히 살펴보고 각 단계에 대한 통찰을 제공할 것입니다.\n\n모놀리스에서 모듈화로\n\n\n\n모듈화로 전환하기 전에 앱은 일반적으로 일종의 계층 구조를 따르는 모노리틱 아키텍처를 따랐을 것입니다. 계층 구조는 가장 일반적이고 널리 사용되는 소프트웨어 아키텍처 패턴 중 하나입니다. 계층 구조는 응용 프로그램의 구성 요소를 별도의 수평 계층으로 구성하며 각 계층은 특정 기능이나 책임을 수행합니다.\n\n![이미지](/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_1.png)\n\n가능한 계층에 대한 전형적인 예시는 다음과 같습니다:\n\n- 데이터/지속성 계층: 데이터 저장 및 검색 담당.\n- 비즈니스 로직 계층: 응용 프로그램의 핵심 기능과 로직 포함.\n- 프리젠테이션 계층 (UI): 사용자 인터페이스 및 통신 처리.\n\n\n\n<img src=\"/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_2.png\" />\n\n레이어 분리 외에도 의존성 방향 규칙을 염두에 두어야 합니다:\n\n의존성 방향 규칙은 의존성 역전 원칙에 크게 의존하여 레이어 간의 느슨한 결합을 유지하고 캡슐화 및 확장성을 제공할 수 있도록 합니다.\n\n# 계층화된 모듈화 아키텍처\n\n\n\n계층 구조의 개념은 직관적이며 실제로 모듈화된 아키텍처에도 적용할 수 있어요.\n\n본질적으로 모듈화는 앱을 별도의 모듈로 나누는 것을 의미해요. 따라서 모듈화에 계층적 접근 방식을 적용하여 모듈을 특정 계층에 통합할 수 있어요.\n\n우리는 모듈화된 앱을 세 개의 계층으로 구성할 거에요: Core, Features, 그리고 Composition Root.\n\n![이미지](/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_3.png)\n\n\n\n**핵심 레이어:**\n\n- 앱의 다양한 기능에서 사용되는 코드를 포함합니다.\n- 특정 앱과 무관한 공유 기능을 제공합니다. UI 구성 요소, 네트워킹, 분석, 유틸리티, 메트릭, 인증, 로깅 등이 포함됩니다.\n- 핵심 모듈은 서로 독립적으로 작동하며 다른 핵심 모듈에 의존하지 않습니다.\n\n**기능 레이어:**\n\n- 기능 모듈은 앱의 특정 화면, 관련된 화면 세트 또는 보기와 같은 구별되는 기능이나 기능을 캡슐화합니다. 예시로는 결제 처리, 고객 프로필, 음식점 목록, 검색, 지원 채팅 등이 있습니다.\n- 특정 기능에 관련된 UI, 로직 및 데이터 처리에 대한 모든 코드가 포함됩니다.\n- 필요한 경우 기능 모듈이 핵심 모듈에 의존할 수 있지만, 다른 기능 모듈에 의존해서는 안 됩니다.\n- 기능 모듈은 관심사의 분리를 촉진하여 프로젝트 간 독립적인 개발, 테스트 및 재사용을 용이하게 합니다.\n\n\n\n# 구성 루트:\n\n- 구성 루트는 응용 프로그램 내에서 객체 그래프가 조립되고 구성되는 중심 장소 역할을 합니다. 주요 책임은 응용 프로그램 전체에서 모든 종속성을 생성하고 주입하는 것에 있습니다.\n- 구성 루트 패턴은 모듈(및 레이어)이 느슨하게 결합되도록 유지하여 필요한 경우 구현 사이의 원활한 전환을 용이하게 합니다.\n- 구성 루트 자체가 모듈이 아닌 것을 주목해야 합니다. 대신 앱의 메인 대상 내에 위치합니다.\n- 각 기능은 구성 루트 내에 별도의 지정된 구성 폴더를 갖게 되며, Feature[X]Support 폴더(또는 Feature[X]Composition으로도 불립니다)라고 합니다.\n- 의존성 주입(Dependency Injection, DI) 및 구성 루트의 개념에 익숙하지 않은 분들을 위해 더 많은 세부 정보는 여기, 여기 및 여기에서 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_4.png)\n\n# 시작하기\n\n\n\n그래서 이제 당신은 단일 구조에서 모듈식 구조로 이주를 시작할 준비가 되었습니다.\n\n논리적으로 첫 번째 단계는 코어 모듈을 이주하는 것입니다. 어떻게 하면 코드를 코어 레이어로 옮겨야 할지 어떻게 결정합니까? 당신의 애플리케이션에서 여러 피처 모듈에서 공유되고 필요한 기능을 찾아보십시오. 이에는 UI 구성 요소, 네트워킹, 인증, 분석, 로깅, 유틸리티 함수 등이 포함될 수 있습니다.\n\n모든 코어 모듈이 모듈화되면, 다음에 모듈화하려는 당신의 모놀리스 내에 있는 피처가 있는 시나리오를 고려해 봅시다. 새 모듈을 만들고 관련 코드를 그 곳으로 이동해야 합니다.\n\n![이미지](/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_5.png)\n\n\n\n요런 상황 중 하나에 처할 수 있다는 점을 명심하는 것이 중요합니다:\n\n1) 당신의 모듈이 다른 기능에 의존하는 경우 (동일한 레이어)  \n\n![이미지](/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_6.png)\n\n\n\n의존성 방향 규칙에 따라 테이블 태그를 변경할 수 없어요.\n\n이를 준수하기 위해 의존성 역전을 해야 해요.\n\n즉, 저희 모듈은 다른 기능 모듈에 위치한 구체적인 구현이 아닌 추상화/인터페이스/프로토콜에 의존해야 해요.\n\n전형적인 예시로 이를 어떻게 할 수 있는지 명확하게 설명해볼게요. 한 기능이 다른 기능을 제공하는 네비게이션 시나리오를 상상해봐요.\n\n\n\n```swift\n// feature 모듈 내부 어딘가에...\nimport AnotherFeature // 여기서는 AnotherFeature 모듈에 의존할 수 없음\nimport UIKit\n\nfinal class YourFeatureViewController: UIViewController {\n    private func showAnotherFeature() {\n        let vc = AnotherFeatureViewController()\n        present(vc, animated: true)\n    } \n}\n```\n\nAnotherFeature에 대한 의존성을 제거하기 위해 이 의존성을 뒤집고 싶습니다. 새로운 feature 모듈 내부에 공개 라우팅 프로토콜을 만듭니다:\n\n```swift\npublic protocol YourFeatureRouting {\n    func showAnotherFeature()\n}\n```\n\n이제 이 프로토콜을 사용하여 탐색할 수 있습니다:```\n\n\n\n```swift\nimport UIKit\n\nfinal class YourFeatureViewController: UIViewController {\n    private let featureRouter: YourFeatureRouting\n    \n    init(featureRouter: YourFeatureRouting) {\n        self.featureRouter = featureRouter\n    }\n\n    private func showAnotherFeature() {\n        featureRouter.showAnotherFeature()\n    } \n}\n```\n\n예를 들어, 이 경우에는 사용자 기능 인터페이스가 특정 화면에 대한 뷰 컨트롤러를 생성하는 팩토리입니다. 우리는 라우팅 프로토콜을 팩토리 매개변수 목록에 넣어 우리의 기능의 필수 종속성으로 추가해야 합니다.\n\n```swift\nimport UIKit\n\npublic enum YourFeatureFactory {\n    static func make(\n        featureRouter: YourFeatureRouting\n    ) -> UIViewController {\n        YourFeatureViewController(featureRouter: featureRouter)\n    }\n}\n```\n\n이제 우리의 모듈은 명시적으로 모듈의 사용자(호출자 측, 우리 경우에는 구성 루트)가 우리의 기능이 사용할 YourFeatureRouting 프로토콜에 대한 구현을 제공하도록 요구함을 선언합니다.\n\n\n\n다음으로 YourFeatureSupport 폴더의 composition root 안에서 라우터를 구현하고 이 라우팅 프로토콜을 준수하겠습니다:\n\n```js\nimport AnotherFeature\nimport UIKit\nimport YourFeature\n\nstruct YourFeatureRouter: YourFeatureRouting {\n    var source: UIViewController?\n  \n    func showAnotherFeature() {\n        let vc = AnotherFeatureViewController()\n        source?.present(vc, animated: true)\n    }\n}\n```\n\n이제 모든 것을 라우터와 함께 조립하기 위해 구성 팩토리를 사용해야 합니다:\n\n```js\nimport UIKit\nimport YourFeature\n\nenum YourFeatureCompositionFactory {\n    static func make() -> UIViewController {\n        let featureRouter = YourFeatureRouter()\n        let featureService = YourServiceFactory.make()\n        let vc = YourFeatureFactory.make(\n            featureRouter: featureRouter,\n            homeService: homeService\n        )\n        featureRouter.source = vc\n        return vc\n    }\n}\n```\n\n\n\n그거야! 우리는 AnotherFeature에 대한 종속성을 뒤집었어요.\n\n2) 당신의 모듈은 아래로 의존합니다\n\n![Dependency Downwards](/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_7.png)\n\n우리의 의존성 방향 규칙에 의해 허용되지 않아요.\n\n\n\n의존하는 코드를 이동하거나 복사하여 새로운 기능 모듈로 옮기세요.\n\n또는\n\n- 다른 모듈(기능 모듈 또는 코어)의 경우:\n- 필요한 경우 새 모듈을 생성하여 해당 모듈로 이전합니다.\n- 동일한 방법을 사용하여 의존성을 역전합니다. 공용 프로토콜을 생성하고 새 기능 모듈이 구성 루트에서 받을 것을 명시합니다. 의존성은 기능 인터페이스를 통해 주입하세요.\n\n\n\n3) 당신의 모듈은 상향으로 의존합니다\n\n![img](/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_8.png)\n\n이것은 우리의 의존성 방향 규칙과 일치합니다.\n\n이전에 언급했듯이 특정 UI 구성 요소 코어 모듈(CompanyUIKit)에서 feature 모듈에 대한 의존성은 중요할 수 있습니다. 일부 코어 모듈의 경우 이러한 직접 의존성을 진행할 것인지, 또는 이전에 수행한대로 구성 루트에서 주입하는 방식으로 의존성을 반전할지 고려해야 합니다.\n\n\n\n의존성 역전은 코어와 피처 레이어 간의 느슨한 결합을 촉진하여 더 많은 유연성과 재사용성을 제공합니다.\n\n예를 들어, 피처 모듈에서 네트워킹 코어 모듈에 의존한다고 상상해보세요:\n\n![image](/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_9.png)\n\n- (유연성) 만약 구식 네트워킹 모듈을 새로운 네트워킹GPT 모듈로 교체하고 싶다면 어떨까요?\n- 네트워킹 모듈에 직접 의존하고 있다면, 피처 모듈 내의 모든 네트워킹 관련 코드를 수정하고 네트워킹 모듈에서 코드를 사용하는 모든 파일의 import를 업데이트해야 합니다.\n- 그러나 의존성을 역전시켜 구성 루트를 통해 주입한다면, 전환하기가 더 쉬워집니다. 구성 루트 내에서 구현할 공개 피처 서비스 프로토콜을 정의함으로써, 네트워킹 구현 세부 사항을 피처 모듈에서 숨깁니다. 구성 루트 내에서 피처 서비스 프로토콜에 대한 새로운 구현을 제공하기만 하면 됩니다.\n- (재사용성) 다른 프로젝트에서 피처 모듈을 재사용하려면, 이동하기가 더 간답니다.\n- (혜택의 비용) 그러나 이 접근 방식은 약간 더 복잡하고 추가 코드 작성이 필요하다는 점을 유념해야 합니다.\n\n\n\n귀하는 특정 시나리오에서 이러한 장단점을 고려해 보십시오.\n\n# 최종 생각\n\n여기 전하고 싶은 아이디어는 모듈화가 로켓 과학이 아니라는 점입니다. 특히 대규모 프로젝트의 경우 빠른 작업은 아닙니다. 그러나 긍정적인 측면은 단계적으로 진행할 수 있다는 것입니다. 로마가 하루 만에 지어지지 않았고, 인내심을 가지고 시도하면 성공할 수 있습니다.\n\n여기 간단한 모듈화 프로젝트 예제가 있습니다. 다음 포스트에서 뵙겠습니다!","ogImage":{"url":"/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_0.png"},"coverImage":"/assets/img/2024-05-15-HowtomodularizeMonolithiOSApp_0.png","tag":["Tech"],"readingTime":7},{"title":"ListViews에서 흔히 범하는 실수들","description":"","date":"2024-05-15 03:10","slug":"2024-05-15-CommonmistakeswithListViewsinFlutter","content":"\n\n스크롤을 부드럽게 유지하기 위해 피해야 할 몇 가지 사항\n\n## 1. NeverScrollableScrollPhysics로 ListView.builder를 축소 래핑하기\n\nListView.builder를 사용하는 주된 이점은 화면에 표시해야 하는 항목만 초기화하는 최적화 메커니즘이다. 이는 수천 개의 항목을 처리할 때도 수십 개의 항목을 처리할 때와 마찬가지로 부드럽게 작동하게 만든다.\n\n만약 표시하려는 목록이 다른 스크롤 뷰에 포함되어야 하는 경우 어떻게 해야 할까요? 스크롤을 비활성화하여 NeverScrollableScrollPhysics를 추가하고 shrinkWrap을 true로 설정함으로써 스크롤을 사용하지 않는 것은 일반적인 실수입니다. 이 접근 방식은 모든 항목을 한꺼번에 초기화하므로 문제가 될 수 있습니다. 이 문제를 확인하기 위해 간단한 실험을 진행할 수 있습니다.\n\n\n\n```dart\nSingleChildScrollView(\n  child: Column(\n    children: [\n      const Card(child: Text(\"헤더 카드\")),\n      ListView.builder(\n        physics: const NeverScrollableScrollPhysics(),\n        itemCount: 1000,\n        shrinkWrap: true,\n        itemBuilder: (context, index) {\n          print(\"항목 빌드 중 #${index}\");\n          return Card(child: Text(index.toString()));\n        },\n      ),\n      const Card(child: Text(\"푸터 카드\")),\n    ],\n  ),\n)\n```\n\n<img src=\"/assets/img/2024-05-15-CommonmistakeswithListViewsinFlutter_0.png\" />\n\n출력에서 확인할 수 있듯이, 모든 항목이 동시에 초기화되어 성능 손실이 발생합니다. 이는 전체 목록이 한꺼번에 렌더링되어 보이는 부분만 렌더링되는 것이 아니기 때문에 발생합니다.\n\n그렇다면 대신 어떻게 해야 할까요? 권장하는 방법은 Slivers를 사용하는 것입니다. Slivers를 사용하면 화면에 현재 표시되는 항목만 빌드하여 더 효율적으로 렌더링할 수 있습니다. 이를 통해 대용량 목록도 부드러운 성능을 유지할 수 있습니다.\n\n\n\n\n```dart\nCustomScrollView(\n\tslivers: [\n\t\tconst SliverToBoxAdapter(child: Card(child: Text(\"Header card\"))),\n\t\tSliverList.builder(\n\t\t\titemBuilder: (context, index) {\n\t\t\t\tprint(\"building item #${index}\");\n\t\t\t\treturn Card(child: Text(index.toString()));\n\t\t\t},\n\t\t),\n\t\tconst SliverToBoxAdapter(child: Card(child: Text(\"Footer card\"))),\n\t],\n)\n```\n\n<img src=\"/assets/img/2024-05-15-CommonmistakeswithListViewsinFlutter_1.png\" />\n\n보시는 바와 같이 화면에 표시될 항목들만 초기화하고 더 부드러운 스크롤을 위해 약간 더 초기화합니다.\n\n## 2. 목록의 각 항목이 자체 높이를 결정하도록 하는 것.```\n\n\n\n플러터 UI 렌더링에서 가장 비용이 많이 드는 작업 중 하나는 위젯 크기를 계산하는 것입니다. 목록을 그릴 때는 모든 항목이 동일한 높이를 갖는 목록의 경우를 특히 고려하여 과도한 계산을 피할 수 있습니다.\n\n두 가지 속성을 사용할 수 있습니다:\n\n- prototypeItem — 모든 목록 항목에 사용될 높이를 가진 위젯.\n- itemExtent — 각 항목의 높이를 지정하는 숫자 값.\n\n많은 자습서에서 itemExtent를 사용할 것을 추천하지만, 종종 간과되는 단점이 있습니다. 일정한 값을 제공하고 목록 항목에 텍스트가 포함된 경우, 사용자가 OS 설정에서 글꼴 크기를 증가시킬 때 레이아웃이 깨질 수 있습니다.\n\n\n\n```\n![Screenshot 1](/assets/img/2024-05-15-CommonmistakeswithListViewsinFlutter_2.png)\n\n원하는 크기를 계산하려면 OS 텍스트 스케일에 폰트 크기를 곱하고 패딩을 추가하는 것이 좋습니다. 이것은 귀찮고 유지 관리가 어려울 수 있습니다. 더 나은 방법이 있습니다:\n\n```js\n        ListView.builder(\n          itemCount: 1000,\n          prototypeItem: const Card(child: Text(\"\")),\n          itemBuilder: (context, index) {\n            return Card(child: Text(index.toString()));\n          },\n        )\n```\n\n![Screenshot 2](/assets/img/2024-05-15-CommonmistakeswithListViewsinFlutter_3.png)\n\n\n\n\n실버 목록의 경우 프로토타입을 제공할 수도 있습니다:\n\n```js\n            SliverPrototypeExtentList.builder(\n              itemBuilder: (context, index) {\n                return Card(child: Text(index.toString()));\n              },\n              prototypeItem: const Card(child: Text(\"\")),\n            ),\n```\n\n코드는 여기에서 확인할 수 있습니다: https://github.com/Pomis/flutter_native_ui_examples/tree/main/lib/3_list_view_mistakes\n\n이 기사가 여러분의 스크롤링을 조금 더 부드럽게 만드는 데 도움이 되기를 바랍니다.\n\n\n\n이전 게시물:\n\nFlutter 앱이 보다 네이티브하게 보이도록 만들기. 파트 1: 탭 효과\n\nFlutter 앱이 보다 네이티브하게 보이도록 만들기. 파트 2: 새로 고침 인디케이터\n\n![이미지](/assets/img/2024-05-15-CommonmistakeswithListViewsinFlutter_4.png)","ogImage":{"url":"/assets/img/2024-05-15-CommonmistakeswithListViewsinFlutter_0.png"},"coverImage":"/assets/img/2024-05-15-CommonmistakeswithListViewsinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"친근한 톤으로 번역 GPT-4를 소개합니다","description":"","date":"2024-05-15 03:08","slug":"2024-05-15-HelloGPT-4o","content":"\n\nGPT-4o (\"o\" for \"omni\")은 훨씬 자연스러운 인간-컴퓨터 상호작용을 위한 한 단계입니다. 이는 텍스트, 오디오 및 이미지의 어떤 조합이든 입력으로 받아들이고 어떤 조합이든 텍스트, 오디오 및 이미지 출력을 생성합니다. 이는 대화에서 인간의 응답 시간과 유사한 232밀리초 이내의 오디오 입력에 응답할 수 있으며, 평균 320밀리초로 응답할 수 있습니다. GPT-4 Turbo의 영문 텍스트와 코드에서의 성능과 비슷하며, 비영어 언어 텍스트에서는 상당한 향상을 보입니다. 또한 API에서 50% 빠르고 저렴합니다. GPT-4o는 기존 모델과 비교했을 때 비전 및 오디오 이해 능력이 특히 좋습니다.\n\n# 모델 기능\n\n두 대 GPT-4o가 상호작용하고 노래합니다.\n\n인터뷰 준비요.\n\n\n\n안녕하세요! 위에 표기된 사항들을 아래와 같이 번역해 드리겠습니다.\n\n\n바위 가위 보 게임.\n\n비꼼.\n\nSal과 Imran Khan과 함께 하는 수학.\n\n둘의 GPT-4가 화음을 이루다.\n \n\n더 궁금한 사항이 있으시면 언제든지 알려주세요!\n\n\n\nChange the table tag to Markdown format.\n\n| Point and learn Spanish |\n| Meeting AI |\n| Real-time translation |\n| Lullaby |\n\n\n\n더 빨리 말하기\n\n생일 축하해.\n\n개.\n\n아빠 농담.\n\n\n\nGPT-4o와 함께 런던에 있는 BeMyEyes의 Andy입니다.\n\n고객 서비스 프로토타입.\n\nGPT-4o 이전에는 Voice Mode를 사용하여 ChatGPT와 대화를 나눌 수 있었는데, 그 때의 대기 시간은 평균 2.8초(GPT-3.5) 및 5.4초(GPT-4)였습니다. 이를 위해 Voice Mode는 오디오를 텍스트로 변환하는 간단한 모델, 텍스트를 입력 받고 텍스트를 출력하는 GPT-3.5 또는 GPT-4, 그리고 이 텍스트를 다시 오디오로 변환하는 세 번째 간단한 모델의 파이프라인입니다. 이 과정은 주요 지능 소스인 GPT-4가 많은 정보를 잃게 되어, 톤, 다중 스피커, 배경 소음을 직접적으로 관찰할 수 없으며, 웃음소리, 노래, 감정을 표현할 수 없다는 것을 의미합니다.\n\nGPT-4o를 통해 우리는 텍스트, 비전, 오디오를 모두 처리하는 단일 새 모델을 최종적으로 훈련시켰습니다. GPT-4o는 이러한 여러 모달리티를 결합한 첫 번째 모델이기 때문에, 우리는 아직 모델이 무엇을 할 수 있고 그 한계가 무엇인지 탐색하는 과정에서 원천적인 단계에 머물러 있습니다.\n\n\n\n# 모델 평가\n\n전통적인 기준에 따르면, GPT-4o는 텍스트, 추론 및 코딩 지능에서 GPT-4 Turbo 수준의 성능을 달성하며, 동시에 다국어, 오디오 및 비전 능력에서 새로운 기록을 세우고 있습니다.\n\n![이미지](/assets/img/2024-05-15-HelloGPT-4o_0.png)","ogImage":{"url":"/assets/img/2024-05-15-HelloGPT-4o_0.png"},"coverImage":"/assets/img/2024-05-15-HelloGPT-4o_0.png","tag":["Tech"],"readingTime":2},{"title":"Google IO에 참석할 때 지켜야 할 10가지 DOS와 DONTS","description":"","date":"2024-05-15 03:05","slug":"2024-05-15-10DOsDONTsforAttendingGoogleIO","content":"\n\n![2024 Google IO 개발자 컨퍼런스](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_0.png)\n\n2024년 Google IO 개발자 컨퍼런스가 Shoreline Amphitheatre에서 다시 열립니다. 올해는 고유한 야외 페스티벌 분위기와 기술 컨퍼런스를 결합한 전통의 회귀를 약속합니다.\n\n11회의 Google I/O 컨퍼런스에 참석한 경험을 토대로 이 독특한 이벤트를 최대한 활용하는 방법에 대해 몇 가지 배웠습니다. 이 가이드를 통해 내부자 팁과 각종 요령을 공유하여 전문가처럼 컨퍼런스를 잘 해결할 수 있도록 도와드리겠습니다.\n\n이 독특한 이벤트에서 최대한 활용할 수 있는 필수적인 할 일과 하지 말아야 할 일에 대해 파헤쳐보겠습니다.\n\n\n\n# 1 ✅ 할 일: 인내심을 가져야 합니다\n\n올해 Google IO는 전체 규모로 돌아오게 되어 약 7,000명의 참가자가 예정되어 있습니다. 모두가 기대에 찬 마음으로 당신이 원하는 곳에 가고 싶어 합니다.\n\n![이미지](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_1.png)\n\n인내심을 가져야 하며, 결국 여러분 모두가 목표 지점에 도착할 것을 기억해 주세요.\n\n\n\n모든 줄을 네트워킹의 좋은 기회로 삼고, 경험의 일부로 즐겨보세요.\n\n![image](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_2.png)\n\n## 2 ❌ DON’T: 편안함을 기대하지 마세요\n\n쇼어라인 앰피시어터는 큰 장소이며, 많은 걸어다녀야 할 것입니다. 날씨가 예측할 수 없기 때문에 옷을 겹겹이 입고, 편안한 신발을 신으세요. 낮 시간과 태양의 위치에 따라 하루 내내 추우셨다 더워졌다 하는 경우가 발생할 수 있습니다 (종종 30분 내에). 그에 맞게 계획하세요.\n\n\n\nIO 컨퍼런스는 크기가 크니까 많이 걷게 될 거예요.\n\n![image](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_3.png)\n\n데이팩을 싸실 때는, 하루 종일 야외 콘서트에 간다고 생각하고 준비하세요.\n\n의류를 여러 겹으로 챙기고, 모자, 신발을 여분으로 준비하고, 어쩌면 소풍 담요도 가져와보세요. 비 옷은 필요 없을 것 같아요 (이전 컨퍼런스 중 하나에서도 비를 맞은 기억이 없네요). 충전기를 가져오고 콘센트가 많이 사용될 수 있으니 휴대용 배터리 팩도 고려해보세요.\n\n\n\n\n![Image](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_4.png)\n\nIt’s crucial to stay hydrated and apply sunscreen. There is not a lot of shade, and the sun can be intense (especially for people not used to it).\n\n## 3 ✅ DO: look for alternatives to long lines\n\nIf you see a line that is particularly long, keep walking, there is likely a shorter one ahead that nobody is using.\n\n\n\n\n현장에 많은 안내원이 있어요. 그들이 사람들을 어디로 안내하는지 주목하세요.\n\n![image](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_5.png)\n\n### 4 ✅ 해야 할 일: 배고파하며 오세요\n\n언제나 음식이 많이 준비돼 있어요. 축제 주최자들은 행사 중간에 간식을 제공하는 데 뛰어나며, 저녁 행사 중에는 주류가 제공돼요.\n\n\n\n아래 내용을 Markdown 형식으로 변환해 보세요.\n\n\n![Google IO Dos and Donts 6](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_6.png)\n\n![Google IO Dos and Donts 7](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_7.png)\n\n![Google IO Dos and Donts 8](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_8.png)\n\n식이 제한이 있는 경우 미리 등록해 주세요. 이를 위한 특별 텐트가 마련되어 있어서 긴 음식 줄을 피하는 좋은 방법이 될 수 있습니다.\n\n\n\n\n# 5 ❌ **잠정 중단**: 모든 세션 참여에 과도한 걱정 하지 마세요\n\n이것은 역설적으로 보일 수 있지만, 개인적으로 세션에 참석에 너무 집중하지 마세요. 영상으로 제공되기 때문에, 회의에서 돌아온 후 집에서 시청할 수 있습니다.\n\n인기 있는 발표는 때로 사람들이 많아서 각광받지만, 아주 일찍 줄을 서지 않는 한, 어쨌든 참여할 수 없을 수 있습니다. 세션이 만석이고 입장이 허가되지 않으면, 걱정하지 말고 그 시간을 다른 활동에 활용하세요.\n\n![image](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_9.png)\n\n\n\n# 6 ✅ 할 일: 코드 랩, 파이어사이드 챗 및 기타 인터랙티브 세션 방문하기\n\n연달아 세션으로 일정을 채우는 것이 유혹적일 수 있지만, 쉬는 시간을 가지는 것이 중요합니다. 자신에게 휴식을 취하고 배운 내용을 되새기며, 회의에서 제공되는 실습 데모 및 인터랙티브 체험을 살펴볼 시간을 허용하세요. 이들은 즐거울 뿐만 아니라 전시되는 기술 및 도구를 이해하는 구체적인 방법을 제공합니다.\n\n![Image](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_10.png)\n\n# 7 ❌ 하지 말아야 할 일: 질문하기를 주저하지 마세요\n\n\n\n세션 중이든 Q&A 시간 중이든 심지어 네트워킹하는 동안에도 질문하는 데 부끄러워하지 마세요. 연설자 및 전문가들과 직접 소통하면 이해를 높이고 토론 주제에 대해 더 깊은 통찰을 얻을 수 있습니다.\n\n발표 시간에 대화가 있는 'fireside chats'에 참석하고 궁금한 질문에 답변을 받을 수 있는 재미있는 방법을 확보하고 커뮤니티 다른 회원들의 생각을 알아내세요.\n\n![image](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_11.png)\n\n# 8 ✅ 할일: 저녁 행사를 위해 에너지를 아끼세요\n\n\n\n긴 세션, 코드 랩, 네트워킹, 대기 줄 서기로 하루를 보내면 피곤할 것입니다. 하지만 저녁을 위해 사회적인 에너지를 조금은 남겨두세요.\n\n셔라인은 활기찬 콘서트 장소이기 때문에 DJ와 헤드라이너 밴드로 이루어진 재미재미한 콘서트가 열릴 것입니다.\n\n2024년 5월 15일 DOs & DON'Ts for Attending Google I/O\n\n그 밖의 밤에는 페스티벌이 \"더 블록\"으로 끝나는데, 이는 라이브 음악 공연, 대화식 체험 및 다양한 엔터테인먼트 옵션을 제공하는 파티가 열립니다. 이 파티는 게임, 기술 데모 및 참가자를 즐겁게 만들고 웃게할 활동들을 포함하여 참가자들을 즐겁게 즐기게하면서 캐주얼한 네트워킹 기회도 제공합니다.\n\n\n\n\n![Image1](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_13.png)\n\n![Image2](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_14.png)\n\n# 9 ✅ 할 일: 계획 세우고 앱 사용하기\n\nGoogle I/O 앱을 다운로드하고 이벤트 전과 이벤트 중에 온라인 일정을 확인하세요. 이 도구들은 일정 변경 사항을 업데이트하거나 개인 일정을 관리하며, 다른 참가자들과 연결할 수 있도록 도와줍니다. 중요한 세션에 우선적으로 참석하기 위해 도착하기 전에 이벤트 일정을 확인하세요.\n\n\n\n\n친구들과 만나는 계획을 세우세요. 우연히 맡기지 마세요. 쇼어라인은 큰 장소이며 정말 넓습니다. 사람들을 만나기 위한 조치를 취하지 않으면, 붐비는 사람 속에서 그들을 놓칠 수 있습니다.\n\n랜드마크와 만날 시간을 정하세요 - IO 사인이 좋은 장소입니다.\n\n![이미지](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_15.png)\n\n# 10 ✅ 해야 할 것: 새로운 친구들과 기존 친구들과 연락하세요\n\n\n\nGoogle IO는 학습에 그치는 것이 아닙니다; 네트워킹하는 데 훌륭한 기회가 될 수도 있어요. 다른 참가자들과 소통하고 연락처를 교환하며 소셜 이벤트에 참석하세요. 때때로 사소한 대화가 미래의 협업이나 취업 기회로 이어질 수도 있으니까요.\n\n우리 커뮤니티 사람들과 함께 시간을 보낼 수 있는 기회를 즐기세요. 당신이 누구를 만날지 알 수 없어요.\n\n![이미지](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_16.png)\n\n![이미지](/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_17.png)\n\n\n\n# 무엇을 놓쳤을까요?\n\n이 제안 사항들이 도움이 되기를 바라며, IO 경험이 더 나아질 수 있도록 합니다.\n\n댓글에서 여러분만의 제안을 공유해 주세요. 그리고 제가 줄을 서있을 때 만나게 되면, 반드시 인사해주세요!","ogImage":{"url":"/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_0.png"},"coverImage":"/assets/img/2024-05-15-10DOsDONTsforAttendingGoogleIO_0.png","tag":["Tech"],"readingTime":5},{"title":" HTML에서 이모지 사용하기","description":"","date":"2024-05-15 03:03","slug":"2024-05-15-EmojisinHTML","content":"\n\n## HTML 파일에 10진수 또는 16진수 코드로 이모지 쉽게 추가하기\n\n<img src=\"/assets/img/2024-05-15-EmojisinHTML_0.png\" />\n\n이모지가 표준화되고 유니코드 협회에서 승인되었다는 사실을 알고 계셨나요? 기술 회사들은 유니코드 할당을 받기 위해 조직에서 표준화된 이모지를 승인받아야 합니다.\n\n이러한 승인된 이모지는 HTML 파일에 이모지의 10진수 또는 16진수 코드를 추가하여 웹 페이지에서 쉽게 사용할 수 있습니다.\n\n\n\nHTML Decimal Format: &#…;\n\nHTML Hexadecimal Format: &#x…;\n\n예를 들어, 이 두 줄의 코드는 웹 페이지에서 동일한 이모지를 보여줍니다.\n\n참고: 각 코드 형식의 끝에 세미콜론이 필요합니다.\n\n\n\n\n![이모티콘 예시 1](/assets/img/2024-05-15-EmojisinHTML_1.png)\n\n## 시도해 볼 일부 이모티콘:\n\n![이모티콘 예시 2](/assets/img/2024-05-15-EmojisinHTML_2.png)\n\n## 하지만 이것들은 스크린 리더를 사용하는 웹사이트 방문자에게 접근할 수 있을까요?\n\n\n\n\n네! 현대의 웹 브라우저들은 각 이모지를 읽어내려고 할 것입니다. 그러나 오직 이모지만으로 정보를 전달하는 데 완전히 의존하는 것은 좋은 실천 방법이 아닙니다. 예를 들어, ⚠️만 사용하지 말고 \"⚠️ 중요: 이모지를 콘텍스트에 맞게 사용해보세요.\"와 같은 텍스트를 추가해보세요.\n\n아래는 장치/브라우저가 \"`p`&#128525;`/p`\" 를 읽어내는 몇 가지 방법입니다.\n\n![이모지 예시](/assets/img/2024-05-15-EmojisinHTML_3.png)\n\nHTML에서 시도해볼 다양한 이모지를 찾고 싶으신가요? Unicode Consortium의 온라인 목록을 사용해보세요. 다만 페이지 로딩 시간이 다소 소요될 수 있으니 주의하세요. Emojipedia는 이모지의 16진 코드를 찾는 데 훌륭한 웹사이트입니다 — 각 이모지에 대한 기술 정보 탭 아래에서 유니코드가 나와요.\n\n\n\n👉 참고: 이모지에 대한 유니코드 (U+1F640)가 있으면 \"U+\" 부분을 제거하고 HTML 16진수 형식으로 사용하십시오 (&#x1F640).\n\n여기에서 CodeHS 코드 편집기에서 이모지 사용에 대해 더 알아보세요! ⭐","ogImage":{"url":"/assets/img/2024-05-15-EmojisinHTML_0.png"},"coverImage":"/assets/img/2024-05-15-EmojisinHTML_0.png","tag":["Tech"],"readingTime":2},{"title":"TailwindCSS를 알아야 하며 사용해야 할 라이브러리들","description":"","date":"2024-05-15 03:01","slug":"2024-05-15-TailwindCSSlibrariesyoushouldknowanduse","content":"\n\n\n![TailwindCSS Libraries](/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_0.png)\n\nTailwindcss는 유틸리티 우선 CSS 프레임워크입니다. 핵심 원칙은 작고 단일 목적의 CSS 클래스 모음을 제공하여 웹 요소에 원하는 스타일을 달성할 수 있는 유틸리티 도구 같은 것입니다.\n\nTailwindcss는 2017년 Tailwind Labs의 CEO인 Adam Wathan과 일부 기여자들에 의해 만들어졌습니다. 이 프레임워크는 HTML을 떠나지 않고도 개발자가 현대적인 웹 애플리케이션을 구축하는 데 도움을 주도록 설계되었습니다. Tailwindcss는 기존의 프레임워크보다 디자인 프로세스에 대한 유연성과 제어를 더 많이 제공합니다. 미리 구축된 구성 요소로 제한받지 않고 개발자들이 원활한 작업 흐름을 갖게 되도록 합니다. 그 유연성과 쉬운 통합 덕분에 Tailwindcss는 매우 인기 있는 CSS 프레임워크가 되었으며 React, Next, Vue와 같은 대부분의 프론트엔드 프레임워크에서 선호하는 선택이 되었습니다.\n\nTailwindCSS 위에 구축된 많은 타사 구성 요소 라이브러리가 있습니다. 이러한 라이브러리는 Tailwind의 유틸리티 클래스로 이미 스타일이 적용된 버튼, 내비게이션 바, 모달 창 등과 같은 미리 구축된 구성 요소를 제공합니다. 이 기사에서는 Tailwind CSS를 통해 빠른 개발과 프로젝트 간 일관된 디자인을 활용할 수 있는 최고의 5가지 tailwindcss 라이브러리를 소개하겠습니다.\n\n\n\n\n## 1. Shadcn UI\n\nShadcn은 아름답게 디자인된 구성 요소를 제공하여 앱에 복사하여 붙여넣을 수 있습니다. Tailwind의 유틸리티 우선 접근 방식을 적용하면서도 빠르게 사전 구축된 UI 요소를 웹 애플리케이션에 통합할 수 있습니다. 사전 제작되었지만 Shadcn을 사용하여 구성 요소를 사용자 정의하여 특정 디자인 요구 사항에 맞게 조정할 수 있습니다. Tailwind의 유틸리티 클래스를 사용하여 스타일, 색상 및 레이아웃을 조정할 수 있습니다. Shadcn UI를 시작하려면 ui.shadcn.com을 방문하세요.\n\n![image](/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_1.png)\n\n## 2. Flowbite\n\n\n\nFlowbite는 Tailwind CSS를 기반으로 구축된 600개 이상의 UI 구성 요소를 제공하며 Figma에서 디자인되었습니다. 이에는 버튼, 내비게이션 바, 폼, 카드, 모달 등과 같은 일반 요소가 포함됩니다. 준비된 구성 요소를 사용하면 Tailwind의 유틸리티 클래스만 사용하여 모든 것을 처음부터 만드는 것보다 시간을 절약할 수 있습니다. Flowbite는 Figma 디자인 시스템을 제공하여 디자이너가 Flowbite 구성 요소를 사용하여 사용자 인터페이스를 시각적으로 디자인하고 이를 쉽게 Tailwind CSS 코드로 변환할 수 있도록 합니다. Flowbite로 시작하려면 flowbite.com을 방문하세요.\n\n![이미지](/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_2.png)\n\n## 3. DaisyUI\n\nDaisyUI는 Tailwind CSS와 특별히 작동하도록 구축된 무료 인기 있는 컴포넌트 라이브러리입니다. Tailwind의 유틸리티 클래스만 사용하여 모든 것을 처음부터 만드는 것에 비해 프로젝트에 쉽게 통합할 수 있는 사전 스타일이 적용된 다양한 UI 구성 요소를 제공합니다. DaisyUI로 시작하려면 daisyui.com을 방문하세요.\n\n\n\n<img src=\"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_3.png\" />\n\n## 4. Preline UI\n\nPreline UI는 Tailwind CSS를 기반으로 한 컴포넌트를 완전히 빌드하며, 스타일링을 위해 유틸리티 클래스를 사용합니다. 이로 인해 기존의 Tailwind 설정과 원활하게 통합되는 일관된 외관을 만들어냅니다. 또한 Tailwind 클래스를 사용하여 미리 구축된 컴포넌트를 더욱 특별하게 사용자 정의할 수 있습니다. Preline UI는 가벼우면서 모듈식으로 설계되었습니다. 프로젝트에 필요한 특정 컴포넌트만 가져와서 코드베이스를 깔끔하고 효율적으로 유지할 수 있습니다. Preline UI를 시작하려면 preline.co를 방문해보세요.\n\n<img src=\"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_4.png\" />\n\n\n\n## 5. Sailboat UI\n\nSailboat UI은 150개 이상의 UI 구성 요소를 자랑하며, 일부 다른 Tailwind CSS 라이브러리보다 더 다양한 옵션을 제공합니다. 버튼, 폼, 카드, 네비게이션 메뉴, 모달 등과 같은 일반적인 요소뿐만 아니라 유용한 일부 일반적이지 않은 구성 요소도 포함되어 있습니다. Sailboat UI는 알파인.js를 기본적으로 사용하여 구성 요소에 상호 작용성을 추가합니다. 알파인.js는 완전한 JavaScript 프레임워크를 필요로 하지 않고 HTML 요소에 동적 동작을 추가할 수 있는 가벼운 JavaScript 라이브러리입니다. Sailboat UI로 시작하려면 sailboatui.com을 방문해주세요.\n\n<img src=\"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_5.png\" />\n\n마지막으로, Tailwind CSS의 세계는 유틸리티 클래스 이상으로 확장되었습니다. 이 다섯 가지 Tailwind CSS 라이브러리는 이 프레임워크의 강점과 다양성을 보여줍니다. 각 라이브러리는 독특한 기능 세트를 제공하며 다양한 개발 요구 사항을 충족시킵니다. 프로젝트 요구 사항에 관계없이, 개발 프로세스를 간소화하고 아름답고 현대적인 사용자 인터페이스를 만들 수 있는 Tailwind CSS 라이브러리가 있습니다. 이러한 사전 구축된 구성 요소를 활용하여 웹 애플리케이션의 핵심 기능에 집중하고 효율적으로 디자인 비전을 실현할 수 있습니다.\n\n\n\n더 많은 내용을 보시려면 팔로우해주세요. 읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_0.png"},"coverImage":"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 아키텍처 구축 제2부  NgRx SignalStore를 활용한 상태 쿼리 및 관리","description":"","date":"2024-05-15 02:58","slug":"2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore","content":"\n\n<img src=\"/assets/img/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore_0.png\" />\n\n이 시리즈의 첫 번째 파트에서는 Apollo Client를 사용하여 Angular 애플리케이션에서 GraphQL API와 상호 작용하는 견고한 기반을 확립했습니다. 이제 애플리케이션 데이터 흐름에서 중요한 지점으로 약간 초점을 옮기면서 데이터를 효과적으로 처리하고 업데이트하는 방법을 살펴보겠습니다.\n\n이를 어떻게 효과적으로 처리할지는 시험하고 검증된 서비스 및 서브젝트 패턴을 사용하거나 RxJs를 사용한 강력한 반응형 구현만으로도 충분히 달성할 수 있습니다. 그러나 애플리케이션이 점점 확장되고 더 많은 기능이 서로 작동해야 하는 경우, 상태 관리는 복잡해집니다.\n\n이러한 이해를 바탕으로 많은 개발자들은 확장 가능하고 사용하기 쉬운 툴킷을 제공하는 외부 라이브러리로 돌아간다는 경향이 있습니다. 시장에는 여러 옵션이 있지만 가장 일반적인 것은 NgRx에 의한 Redux 기반 구현일 것입니다. 그러나 동일한 팀은 최근 SignalStore라는 최신 버전을 출시했는데, 이는 본질적으로 서비스와 서브젝트(시그널) 패턴을 확장한 것입니다.\n\n\n\n주요 장점은 직관적이고 보일러플레이트가 적으며 선언적이라는 점입니다. 이는 확장 가능성에 도움이 되는 높은 모듈성을 구현하며 유형 안전 및 강하게 주장하는 동시에 유연한 밸런스를 제공합니다. 여기서 설치 단계를 찾을 수 있습니다.\n\n## 할 일 저장소 설정하기\n\n먼저, 우리는 todos.store.ts 파일을 생성할 수 있습니다. 여기에는 저장소를 정의할 것입니다. 개략적으로 보면 다음과 같을 것입니다:\n\n```js\nexport const TodosStore = signalStore(\n  withMethods((store) => {\n    /*** 여기에 메서드가 사용 가능할 것입니다 ***/\n  }),\n  withComputed(() => ({\n    /*** 여기에서 계산된 값 정의가 가능합니다 ***/\n  })),\n  withHooks(({ loadAll }) => ({\n    /*** onInit 및 onDestroy 라이프사이클 후크에 액세스할 수 있습니다 ***/\n  }))\n);\n\nexport type TodosStore = InstanceType<typeof TodosStore>;\n\nexport function provideTodosStore(): Provider[] {\n  return [TodosStore];\n}\n```\n\n\n\n간단히 말하자면, `withMethods` 함수를 사용하여 메소드를 선언합니다. 이들은 상태 변이부터 API 호출 및 데이터 처리에 이르기까지 어떤 것이든 될 수 있습니다. UI를 보다 선언적으로 만들고 중복된 계산을 피하기 위해, `SignalStore` 내에서 계산된 속성을 사용할 수도 있습니다. 이를 통해 기본 상태에서 값을 유도할 수 있으며, 컴포넌트가 데이터를 표시하는 데 집중하도록 유지할 수 있습니다. 게다가, 컴포넌트에서 빌린 개념인 라이프사이클 후크도 있습니다. `withHooks`을 사용하면 상점의 생성과 소멸에 탭하여 초기화 또는 정리 같은 작업을 수행할 수 있습니다.\n\n마지막으로, 이 종속성을 더 깔끔하게 제공할 수 있는 부분을 포함했습니다(예: 컴포넌트에 `provideTodosStore()`를 추가하는 방식). 그리고 스토어를 TodosStore 유형으로 생성자에 주입할 수 있도록 쉽게 스토어를 주입할 수 있게 되며 'constructor(private todosStore: TodosStore)'를 추가하는 것만큼 쉽습니다. 또한 클래스 속성에 `inject` 함수를 통해 주입할 수도 있지만, 저는 생성자 주입을 선호하는 편입니다. 더 읽기 쉽다고 느껴지기 때문입니다. 더 나아가, 전역으로 스토어를 제공하려면 다음과 같이 스토어를 선언하여 전역으로 제공할 수도 있습니다: `export const TodosStore = signalStore(' providedIn: `root` ', ...);`.\n\n## 상태 정의\n\n최초 반복에서는 다음과 같이 `withState()` 함수를 사용하여 상태를 정의할 수 있습니다.\n\n\n\n```js\ntype TodosState = {\n  data?: Todos[];\n  errors?: string[];\n  loading: boolean; \n}\n\nconst initialState: TodosState = {\n  loading: true\n}\n\nexport const TodosStore = signalStore(\n  withState(initialState)\n);\n```\n\n`TodosState` 타입은 상태가 어떻게 보일지를 정의합니다. 우리는 할 일 배열과 오류 문자열 배열이 있고 이 중 어떤 작업이 실패하면 로드될 예정이며 작업이 진행 중인지 여부를 나타내는 로딩 플래그가 있습니다.\n\n데이터와 오류 속성은 로드될 때까지 기본적으로 정의되지 않기 때문에 초기 상태는 로딩 플래그만으로 설정할 수 있습니다. 그런 다음, 상태를 연결하여 상점을 설정합니다. 이것은 이전에 설명한 메커니즘을 사용하여 원하는 대로 변경할 수 있는 가장 기본적인 구현입니다.\n\n...하지만 다르게 보일 수도 있습니다.\n\n\n\n\n## 모듈화 - 사용자 정의 저장소 기능 외부화\n\n더 많은 기능을 구축할수록 로딩 및 오류 상태를 관리하는 것이 반복적인 작업이 될 것을 알게될 것입니다. 중복을 피하고 코드를 모듈화 유지하기 위해 이를 재사용 가능한 기능으로 만들어봅시다. 이렇게하여 request.feature.ts 파일을 아래와 같이 생성할 수 있습니다.\n\n```js\ntype RequestState = {\n  loading: boolean;\n  errors?: string[];\n};\n\nfunction withRequestStatus() {\n  return signalStoreFeature(withState<RequestState>({ loading: false }));\n}\n\nfunction setLoading(): Partial<RequestState> {\n  return { loading: true };\n}\n\nfunction setLoaded(): Partial<RequestState> {\n  return { loading: false };\n}\n\nfunction setErrors(value: string[]): Partial<RequestState> {\n  return { errors: value };\n}\n\nexport { withRequestStatus, setLoading, setLoaded, setErrors };\n```\n\n이전과 마찬가지로 상태 타입을 생성한 다음 상태 기능을 연결할 수 있는 함수와 상태를 변이하는 데 사용할 수있는 몇 가지 함수를 만듭니다. 실제로는 아래와 같은 결과물이 나오게 될 것입니다.\n\n\n\n```js\ntype TodosState = {\n  data?: Todos[];\n};\n\nconst initialState: TodosState = {\n  data: []\n};\n\nexport const TodosStore = signalStore(\n  withState(initialState),\n  withRequestStatus(),\n  withMethods((store) => {\n    const apollo = inject(Apollo);\n\n    return {\n      loadAll: rxMethod<void>(\n        pipe(\n          tap(() => patchState(store, setLoading())),\n          switchMap(() => apollo.query({ query: GET_TODOS_QUERY })),\n          tapResponse({\n            next: (response: ApolloQueryResult<{ getTodos: Todo[] }>) =>\n              patchState(store, { data: response.data.getTodos }),\n            error: (errors: ApolloError[]) => patchState(store, setErrors(errors.map(e => e.message))),\n            finalize: () => patchState(store, setLoaded()),\n          })\n        )\n      ),\n  }),\n);\n```\n\n저희의 상태가 조금 줄어든 것을 보실 수 있고, 로딩 및 에러 기능을 추가하기 위해 플러그인을 사용했습니다. 앞으로는 메소드를 확장했습니다. 스토어를 인수로 사용하고 운영을 수행하기 위해 apollo 클라이언트를 주입했습니다.\n\n더불어 RxJs의 강력함을 활용하기 위해 rxMethod를 사용할 것입니다. loadAll 함수를 호출하면 void 타입의 스트림이 생성됩니다. 그런 다음 스트림에 탭하여 우리가 만든 함수를 통해 상태를 로딩으로 설정할 수 있습니다. 이를 통해 스피너 등을 표시할 수 있습니다. 요청으로 스트림을 전환하고 마지막으로 @ngrx/operators 패키지의 tapResponse 연산자를 활용할 것입니다. 여기서 next에는 상태의 데이터 필드에 Todos를 설정하고, 요청이 실패한 경우에는 오류를 설정하고, 스트림이 완료되면 로딩을 false로 설정할 수 있습니다.\n\n## Entity Management makes a comeback\n\n\n\n\n이 코드는 NgRx에 익숙한 사용자들에게 이미 알려진 기능 중 하나로, SignalStore에서도 entity 관리 확장이 되돌아왔습니다. 이 기능은 addEntity, setEntity, updateEntity, removeEntity와 같은 메소드를 통해 CRUD 작업을 간편하게 수행할 수 있도록 도와줍니다.\n\n아래는 저희의 스토어 최종 버전이며, 모든 CRUD 메소드가 해당 API 작업 및 상태 변이와 함께 구현된 것을 확인할 수 있습니다. rxMethod는 입력 스트림이 될 수 있는 아무 타입을 지정할 수 있습니다. 이는 가져올 할 일의 ID부터 업서트 작업을 위한 부분 또는 완전한 객체까지 다양할 수 있습니다. 이러한 매개변수를 메소드 호출에 추가하는 것이 필요합니다.\n\n또한, 보류 중인 할 일과 완료된 할 일에 해당하는 배열을 얻을 수 있는 계산된 값의 예제를 볼 수 있습니다. withComputed 메소드는 스토어를 매개변수로 사용하며, 이를 통해 선택적으로 해당 부분을 선택하여 확장할 수 있습니다. 저희의 경우, 기준에 따라 필터링된 entities를 선택했습니다.\n\n\n\n마침내 훅을 활용하게 됩니다. 이는 초기화 시 Todos를 로드하고 싶다는 것을 의미합니다. 실제로 스토어를 컴포넌트에 제공할 때 Todos는 이미 사전로드되어 있을 것입니다.\n\n## 계속 진행하겠습니다...\n\n드디어 우리가 구현한 상태 관리 기능을 어떻게 활용할 수 있는지 확인할 시간이 왔습니다. 사용자 인터페이스를 더 쉽게 구성하기 위해 Angular Material을 설치했으며 데이터를 목록으로 로드하거나 대화상자를 생성하는 등의 간단한 방법을 제공합니다.\n\n```js\n// todos.component.ts\n@Component({\n  selector: 'app-todo-list',\n  standalone: true,\n  templateUrl: './todos.component.html',\n  providers: [provideTodosStore()],\n  imports: [\n    MatDivider,\n    MatToolbar,\n    MatButton,\n    MatList,\n    MatListItem,\n    MatIconButton,\n    MatIcon,\n    MatLine,\n    CdkDropListGroup,\n    CdkDropList,\n    CdkDrag,\n  ],\n})\nexport class TodosComponent {\n\n  constructor(protected readonly store: TodosStore, protected readonly dialog: MatDialog) {}\n\n  changeTodoCompletion(event: CdkDragDrop<Todo[]>): void {\n    this.store.updateTodo({ id: event.item.data.id, completed: !event.item.data.completed });\n  }\n\n  openUpsertDialog(todo?: Todo): void {\n    this.dialog.open(TodoDialogComponent, { data: { todo } });\n  }\n}\n```\n\n\n\n```js\n<!-- todos.component.html -->\n<mat-toolbar class=\"flex justify-between\" color=\"primary\">\n  <span>할 일 목록</span>\n  <button mat-raised-button color=\"accent\" (click)=\"openUpsertDialog()\">할 일 추가</button>\n</mat-toolbar>\n\n<section class=\"container mx-auto p-4 grid grid-cols-2 gap-4\">\n  <div>\n    <h2 class=\"text-xl font-bold mb-2\">보류 중인 할 일</h2>\n    <mat-list cdkDropList [cdkDropListData]=\"store.pendingTodos()\" cdkDropListSortingDisabled #pending=\"cdkDropList\" [cdkDropListConnectedTo]=\"[completed]\" (cdkDropListDropped)=\"changeTodoCompletion($event)\">\n      @for(todo of store.pendingTodos(); track todo.id) {\n      <mat-list-item cdkDrag [cdkDragData]=\"todo\">\n        <mat-icon matListItemIcon class=\"text-gray-500\">check_circle</mat-icon>\n        <div matLine class=\"flex justify-between align-middle\">\n          <span>{ todo.text }</span>\n          <div>\n            <button mat-icon-button class=\"text-blue-500\" (click)=\"openUpsertDialog(todo)\">\n              <mat-icon>edit</mat-icon>\n            </button>\n            <button mat-icon-button class=\"text-red-500\" (click)=\"store.removeTodo({ id: todo.id })\">\n              <mat-icon>delete</mat-icon>\n            </button>\n          </div>\n        </div>\n      </mat-list-item>\n      } @empty {\n      <p>목록에 할 일이 없습니다.</p>\n      }\n    </mat-list>\n  </div>\n\n  <div>\n    <h2 class=\"text-xl font-bold mb-2\">완료된 할 일</h2>\n    <mat-list cdkDropList [cdkDropListData]=\"store.completeTodos()\" cdkDropListSortingDisabled #completed=\"cdkDropList\" [cdkDropListConnectedTo]=\"[pending]\" (cdkDropListDropped)=\"changeTodoCompletion($event)\">\n      @for(todo of store.completeTodos(); track todo.id) {\n      <mat-list-item cdkDrag [cdkDragData]=\"todo\">\n        <mat-icon matListItemIcon class=\"text-green-500\">check_circle</mat-icon>\n        <div matLine class=\"flex justify-between align-middle\">\n          <span>{ todo.text }</span>\n          <div>\n            <button mat-icon-button class=\"text-blue-500\" (click)=\"openUpsertDialog(todo)\">\n              <mat-icon>edit</mat-icon>\n            </button>\n            <button mat-icon-button class=\"text-red-500\" (click)=\"store.removeTodo({ id: todo.id })\">\n              <mat-icon>delete</mat-icon>\n            </button>\n          </div>\n        </div>\n      </mat-list-item>\n      } @empty {\n      <p>목록에 할 일이 없습니다.</p>\n      }\n    </mat-list>\n  </div>\n</section>\n```\n\n```js\n// todos-dialog.component.ts\n@Component({\n  selector: 'app-todo-upsert',\n  standalone: true,\n  template: `<h2 mat-dialog-title>{ id ? '할 일 수정' : '할 일 추가' }</h2>\n\n    <mat-dialog-content>\n      <form>\n        <mat-form-field>\n          <mat-label>할 일</mat-label>\n          <input matInput [formControl]=\"text\" />\n        </mat-form-field>\n      </form>\n    </mat-dialog-content>\n\n    <mat-dialog-actions>\n      <button mat-button (click)=\"dialogRef.close()\">취소</button>\n      <button mat-raised-button color=\"primary\" [disabled]=\"text.invalid\" (click)=\"upsertTodo()\">저장</button>\n    </mat-dialog-actions>`,\n  providers: [provideTodosStore()],\n  imports: [MatDialogModule, MatButtonModule, MatInputModule, ReactiveFormsModule],\n})\nexport class TodoDialogComponent {\n  protected readonly id?: string;\n  protected readonly text: FormControl<string>;\n\n  constructor(\n    private readonly store: TodosStore,\n    protected readonly dialogRef: MatDialogRef<TodoDialogComponent>,\n    @Inject(MAT_DIALOG_DATA) data?: { todo?: Todo }\n  ) {\n    this.id = data?.todo?.id;\n    this.text = new FormControl(data?.todo?.text ?? '', {\n      validators: [Validators.required, Validators.minLength(2)],\n      nonNullable: true,\n    });\n  }\n\n  upsertTodo(): void {\n    if (this.id) {\n      this.store.updateTodo({ id: this.id, text: this.text.value });\n    } else {\n      this.store.addTodo({ text: this.text.value });\n    }\n    this.dialogRef.close();\n  }\n}\n```\n\n요약하면 CRUD 기능을 커플 컴포넌트에서 구현했습니다. 초기에 OnInit 후크를 통해 데이터를로드하는 목록이 있습니다. 이 목록에는 한 열에서 다른 열로 항목을 이동할 때 저장소 업데이트를 호출하는 드래그 앤 드롭 기능이 있습니다. 게다가, ID가 있는지 여부에 따라 업데이트 또는 추가 메서드를 호출하는 재사용 가능한 대화 상자가 있습니다.\n\n<img src=\"/assets/img/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore_1.png\" />\n\n\n\n\n## 마무리\n\n이제 우리는 NgRx SignalStore의 힘을 활용하여 Todo 애플리케이션의 API와 컴포넌트 사이의 레이어의 반응적 기초를 만들었습니다. 우리는 작업을 별도로 정의함으로써 API 상호작용이 매우 간단해지며, 따라서 따로 두지 않고 직접 저장소에 구현한 이유입니다.\n\n이를 통해 방법과 신호를 통해 결정론적인 데이터 흐름을 노출시켰는데, 이 때 신호는 직관적인 변경 감지 전략 및 UI 업데이트를 우아하게 수행하는 데 중요한 역할을 합니다.\n\n다음 기사에서는 데이터 모의를 어떻게 구현하여 개발 경험을 향상시킬 수 있는지, 그리고 테스트를 위한 프론트엔드 분리를 완벽하게 하는 방법을 소개할 예정입니다.","ogImage":{"url":"/assets/img/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore_0.png"},"coverImage":"/assets/img/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore_0.png","tag":["Tech"],"readingTime":11},{"title":"나의 우주 테마 Threejs 포트폴리오 사이트를 위해 사용자 정의 이질 변위 맵을 만드는 방법","description":"","date":"2024-05-15 02:55","slug":"2024-05-15-HowICreatedCustomDisplacementMapsforMySpace-ThemedThreejsPortfolioSite","content":"\n\n## 온라인에서 무료로 사용할 수 있는 미리 제작된 변위 맵의 부족에 놀라웠습니다. 나만의 변위 맵을 만들기가 얼마나 쉬운지에 더욱 놀랐죠.\n\n포트폴리오 사이트 작업 중 변위 맵과 관련된 흥미로운 문제를 만났습니다.\n\n잠깐 설명하자면, 일반적으로 그래픽을 다룰 때, 특히 Three.js 메쉬와 함께 작업할 때, 메쉬의 속성을 변경하기 위해 다양한 종류의 맵을 사용할 수 있습니다. 이 중 가장 간단한 것은 컬러 맵으로, 이 맵의 픽셀은 메쉬에 매핑됩니다. 제가 사용한 것과 같이 구 형상 기하학을 사용하는 경우, 컬러 맵을 구의 기하학적 형상을 장식하는 포장지와 같은 역할로 생각할 수 있습니다.\n\n간단히 말해, 변위 맵은 각 픽셀의 밝기가 해당 정점의 기하학적 형상을 얼마나 (맞죠!) 변위시킬지 결정하는 회색조 이미지입니다. Three.js 메쉬에 사용할 수 있는 다른 많은 종류의 맵이 있으며 다양한 목적으로 사용할 수 있습니다. Three의 MeshStandardMaterial 문서는 더 자세히 알아보고 싶다면 좋은 참고 자료입니다.\n\n\n\n내 옵션을 살펴본 후, 무작위로 생성된 소행성과 내가 만든 행성 중 하나에서 현실감을 더하기 위해 변위 매핑을 사용하기로 결정했습니다. 그러나 비교적 쉽게 찾을 수있는 좋은 색상 지도와는 다르게, 내가 필요로 하는 변위 맵을 찾기 어려웠습니다. 무료로 사용할 수 있는 옵션을 찾기는 더욱 어려웠습니다. 다행히도, 살짝 기발하고 실험을 통해 나만의 방법을 발견할 수 있었습니다.\n\n내 속임수에 대한 자세한 내용을 예고 없이 알려드리기 전에 두 가지 중요한 주의사항이 있습니다:\n\n1. 이 방법이 당신의 사용 사례에 맞지 않을 수 있습니다. 나는 이러한 변위 맵을 매우 특정한 목적으로 만들었습니다. 즉, 그것들이 다소 무작위로 보이면서 동시에 암석 형태의 비교적 부드러운 미학을 보존하기 위함이었습니다. 사용 방법은 개인에 따라 다를 수 있습니다.\n\n2. 이 방법은 아마도 여러분이 찾을 수 있는 가장 우아한 방법은 아닐 것입니다. 나보다 3D 모델링 및 애니메이션 분야에 더 정통한 사람들이나 돈을 들이고 싶어하는 사람들을 위해 더 깔끔한 솔루션이 있을 것입니다. 포토샵을 사용하여 처음부터 변위 맵을 만들 수 있습니다. Blender와 같은 도구를 사용하여 완전한 3D 모델을 만들거나 처음부터 변위 매핑에 의존하지 않고도 가능합니다. 그리고 제가 그 품질이나 가치를 검증할 수 없지만, 미리 제작된 변위 맵을 찾는 동안 상당한 가격으로 판매하고 있는 몇 개의 사이트도 발견했습니다.\n\n\n\n그렇게 해결을 마치고 난 다음, 무료로 그리고 어떠한 화려한 도구도 사용하지 않고 빠르게 나만의 암석 변위 지도를 만드는 방법을 소개할게요:\n\n1. 유료 변위 지도의 워터마크 미리보기를 발견한 후 Google Lens를 사용하여 비슷한 이미지를 무료로 찾았어요. 솔직히 말해서 이 시점에서 정확히 무엇을 찾고 있는지 정확히 모르겠었어요. 주로 나에게 적합한 변위 지도가 어떻게 생겼는지 탐색하고, 유료 지도의 미리보기에서 시작하는 것이 꽤 괜찮아 보였어요. 되돌아보면, 실제로는 그렇게 중요하지 않았어요. 가장 중요한 것은 흑백 이미지이며 흥미롭게 유지할 만큼 충분한 밝기 다양성을 가지고 있어야 했어요. 여기서 제 과정을 따르고 자신만의 변위 지도를 만들기 위해 이 글을 읽는다면, 이 단계를 건너뛰고 무료로 사용할 수 있는 흑백 이미지를 선택하거나 아래 제가 제공하는 이미지 중 하나를 사용할 수 있어요.\n\n2. 좋은 후보 이미지로 보이는 몇 장의 이미지를 골랐어요. 또한 선택한 몇 장의 이미지를 기반으로 새 Lens 검색을 실행했어요. 마지막으로 좁힌 두 가지 이미지는 화성의 협곡을 보여주는 퍼블릭 도메인 이미지와 우연히도 화성 상의 소금 함유물에 관한 NASA 이미지였어요.\n\n3. 이미지를 자르고 정사각형으로 만들고 합리적인 해상도로 크기를 조정했어요, 512x512 픽셀. 일반적으로 맵은 정사각형이어야 하며, 높이/너비는 2의 거듭제곱이어야 해요. 대부분의 응용 프로그램에서 512x512가 충분할 것이며, 세부사항을 희생하지 않으면서도 성능을 향상시키기 위해 256x256까지 낮출 수도 있어요.\n\n4. 이미지의 1/4를 다른 이미지로 복사했어요. 실제로 사용한 변위 지도 중 하나에만 이렇게 한 적이 있어요. 처음에는 지표 면에 어떠한 이음선도 나타나지 않도록 하기 위해 이렇게 했어요. 이론적으로, 맵을 다룰 때, 이미지의 왼쪽 색과 오른쪽 색이 완전히 일치해야 하기 때문에 경계가 이상하게 보이지 않아야 해요. 실제로, 두 번째 맵에 이 단계를 건너뛰어보았고 결과는 완전히 괜찮았어요.\n\n5. 각 이미지 상단과 하단에 수평선을 추가했어요. 이유는 이전 단계와 비슷하지만, 이번에는 이 작업이 상당히 중요했어요. 이미지의 상단과 하단 가장자리 픽셀의 밝기가 완벽하게 일치하지 않으면, 구와의 극에 눈에 띄는 효과가 나타날 수 있어요. 이 시점에서 맵은 다음과 같이 보였어요:\n\n6. 이미지를 흐리게 해 왜곡을 완화했어요. 5단계 후에 만족스러운 진행을 이룬 것에 대해 만족스러웠지만, 결과물이 원하는 대로 이루어진 것 같지 않았어요. 행성과 소행성 표면의 버팀목은 분명히 눈에 띄었지만, 취향에 너무 뾰족하고 울퉁불퉁했어요. (가시적인 왜곡을 찾고 있다면, 이 단계를 건너뛰어보세요.) Blur의 각 이미지에 대해 다른 레벨의 흐림을 실험했고, 골디락스 영역에 도달할 때까지 계속해보았어요. 이미지를 흐리게 하기 과정에서 선을 다시 추가해야 했는데, 이미지의 희미화 과정에서 선들이 흡수되었기 때문이었어요.\n\n\n\n## 그리고 요렇게! 두 개의 좋은 작은 왜곡 지도가 나왔어요:\n\n내가 정확히 필요한 것을 위해 기능하는 방법을 안내받아 기쁨으로 가득 찼어. 당신이 원한다면 네 자신의 프로젝트에 사용해도 괜찮아.\n\n## 완성된 사이트에서 암석 행성과 소행성이 어떻게 보이는지 확인해보세요.\n\n## 프로젝트의 소스 코드를 확인해보세요\n\n\n\n이 기사는 저가 개발한 소셜 블로깅 사이트 COACSS에서 2022년 8월 28일에 원래 게시되었습니다.\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인해보세요","ogImage":{"url":"/assets/img/2024-05-15-HowICreatedCustomDisplacementMapsforMySpace-ThemedThreejsPortfolioSite_0.png"},"coverImage":"/assets/img/2024-05-15-HowICreatedCustomDisplacementMapsforMySpace-ThemedThreejsPortfolioSite_0.png","tag":["Tech"],"readingTime":4},{"title":"데이터가 중요해요 레일즈에서 데이터베이스 관리와 최적화를 위한 상위 10가지 보석","description":"","date":"2024-05-15 02:53","slug":"2024-05-15-DataMattersTop10GemsforDatabaseManagementandOptimizationinRails","content":"\n\n이미지를 Markdown 형식으로 변경했습니다!\n\n물론입니다! 이제 여러분의 Ruby on Rails 애플리케이션의 성능을 캐싱 기술과 최적화 전략을 통해 엄청나게 향상시킬 수 있는 상위 10개의 Ruby Gems로 들어가 봅시다. 이러한 Gems는 귀하의 개발 워크플로우를 크게 개선하고 코드 품질을 향상시키며 보안을 강화할 수 있습니다. 여기 그 목록입니다:\n\n- Dalli:\n\n- Dalli은 Memcached 캐싱 시스템과 귀하의 Ruby 애플리케이션을 연결하는 강력한 인터페이스를 제공하는 인기 있는 Ruby Gem입니다. Memcached는 키-값 쌍을 메모리에 저장하여 데이터베이스의 부하를 줄이고 자주 사용되는 데이터에 빠르게 액세스할 수 있도록 도와줍니다.\n\n\n\n# Memcached-Rails:\n\n- Memcached-Rails는 Memcached 서버에 연결하는 데 사용됩니다. Memcached는 데이터를 캐시하고 검섹의 배경 처리를 위한 큐를 만드는 데 사용됩니다.\n\n```js\n# Memcached 서버에 연결\ncache = Dalli::Client.new('localhost:11211')\n# 캐시에 데이터 저장\ncache.set('user:123', { name: 'John Doe', email: 'john@example.com' })\n# 캐시에서 데이터 가져오기\nuser_data = cache.get('user:123')\n```\n\n2. Redis-Rails:\n\n- Redis-Rails는 Redis, 메모리 내 데이터 구조 저장소와 Ruby on Rails 애플리케이션을 통합합니다. Redis를 사용하면 데이터를 캐시하거나 세션 스토리지를 관리하고, 백그라운드 처리를 위한 큐를 생성할 수 있습니다.\n\n```js\n# config/initializers/redis.rb에서 Redis 연결 구성\n$redis = Redis.new(host: 'localhost', port: 6379)\n# Redis 캐시에 데이터 저장\n$redis.set('product:123', { name: 'Widget', price: 19.99 })\n# Redis 캐시에서 데이터 가져오기\nproduct_data = $redis.get('product:123')\n```\n\n\n\n3. ActiveSupport::Cache:\n\n- ActiveSupport::Cache는 루비 온 레일의 핵심 구성 요소로, 통합된 캐싱 인터페이스를 제공합니다. Memcached, Redis 및 파일 기반 캐싱과 같은 다양한 캐싱 저장소를 지원합니다.\n\n```ruby\n# config/environments/development.rb에서 캐싱 저장소 구성\nconfig.cache_store = :mem_cache_store, 'localhost:11211'\n# 캐시에 데이터 저장\nRails.cache.write('user:123', { name: 'Jane Smith', email: 'jane@example.com' })\n# 캐시에서 데이터 검색\nuser_data = Rails.cache.read('user:123')\n```\n\n4. Rack::Cache:\n\n\n\n- Rack::Cache는 루비 웹 애플리케이션을 위한 HTTP 캐싱을 제공하는 미들웨어입니다. 웹 서버와 앱 사이에서 중계 역할을 하며 HTTP 헤더에 따라 응답을 캐시할 수 있도록 합니다.\n\n```ruby\n# config.ru에 Rack::Cache 미들웨어 추가\nrequire 'rack/cache'\nuse Rack::Cache\n# 앱에서 캐싱 옵션 정의\nclass MyApp < Sinatra::Base\n  set :static_cache_control, [:public, max_age: 3600]\n  set :dynamic_cache_control, [:public, max_age: 600]\nend\n```\n\n5. Bullet:\n\n- Bullet는 레일즈 애플리케이션에서 N+1 쿼리 문제를 식별하는 데 도움을 주는 젬(Gem)입니다. 단일 쿼리로 해결 가능한 상황에서 여러 개의 데이터베이스 쿼리를 수행하는 경우를 감지합니다. 데이터베이스 쿼리를 최적화함으로써 데이터베이스 서버 부하를 줄이고 응답 시간을 개선할 수 있습니다.\n\n\n\n```rb\n# In your development.rb or production.rb\nconfig.after_initialize do\n  Bullet.enable = true\n  Bullet.alert = true\n  Bullet.bullet_logger = true\nend\n```\n\n6. Rack Mini Profiler:\n\n- Rack Mini Profiler는 귀하의 Rails 애플리케이션을 위한 가벼운 프로파일러를 제공합니다. 요청-응답 주기의 각 부분에 소요된 시간을 측정하여 성능 병목 현상을 식별하는 데 도움을 줍니다. 느린 데이터베이스 쿼리, 뷰 렌더링 시간 등을 쉽게 식별할 수 있습니다.\n- Gemfile에 다음 Gem을 추가해주세요:\n\n```rb\ngem 'rack-mini-profiler', require: false\n```\n\n\n\n\n```ruby\nrequire 'rack-mini-profiler'\nRack::MiniProfilerRails.initialize!(Rails.application)\n```\n\n7. Database Cleaner:\n\n- Database Cleaner는 테스트 중 깨끗한 데이터베이스를 유지하는 데 필수적입니다. 이를 통해 각 테스트 후 데이터베이스 레코드를 정리함으로써 일관된 상태에서 테스트 스위트를 실행할 수 있습니다. 이를 통해 데이터 오염을 방지하고 테스트 신뢰성을 향상시킬 수 있습니다.\n\n\n\n\n```md\n# spec_helper.rb 또는 rails_helper.rb 파일에서\nrequire 'database_cleaner'\nDatabaseCleaner.strategy = :transaction\n```\n\n8. Ransack:\n\n- Ransack은 Rails 애플리케이션에서 복잡한 검색 폼을 간단하게 만들어줍니다. 사용자 입력을 기반으로 레코드를 검색하고 정렬하기 위한 SQL 쿼리를 생성합니다. Ransack을 사용하면 사용자 정의 SQL 쿼리를 작성하지 않고도 강력한 검색 기능을 만들 수 있습니다.\n\n```ruby\n# 컨트롤러에서\ndef index\n  @q = Product.ransack(params[:q])\n  @products = @q.result(distinct: true)\nend\n```\n\n\n\n9. Puma:\n\n- Puma는 루비 애플리케이션을 위한 고성능 웹 서버입니다. 여러 동시 요청을 효율적으로 처리하기 위해 설계되었습니다. Puma를 사용하면 애플리케이션의 확장성과 응답성을 향상시킬 수 있습니다.\n\n```js\ngem 'puma' [Gemfile에 추가]\n```\n\n10. Bullet Train:\n\n\n\n- Bullet Train은 Bullet Gem의 확장 프로그램입니다. 사용되지 않는 eager loading 및 누락된 인덱스를 감지하는 추가 기능을 제공합니다. 이러한 문제를 해결함으로써 응용 프로그램의 데이터베이스 쿼리를 더욱 최적화할 수 있습니다.\n\n```js\n# 개발 환경 또는 운영 환경의 설정 파일에서\nconfig.after_initialize do\n  Bullet.enable = true\n  Bullet.add_footer = true\n  Bullet.raise = true\nend\n```\n\n이 Gem들을 추가로 탐험하고 특정 사용 사례에 맞게 적용하는 것을 기억해두세요. 즐거운 최적화하세요! 😊🚀","ogImage":{"url":"/assets/img/2024-05-15-DataMattersTop10GemsforDatabaseManagementandOptimizationinRails_0.png"},"coverImage":"/assets/img/2024-05-15-DataMattersTop10GemsforDatabaseManagementandOptimizationinRails_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 취미생활 25 Angular과 Wiz가 통합되며, React와 Angular의 차이점, 등등","description":"","date":"2024-05-15 02:52","slug":"2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore","content":"\n\n## 2024년 4월 제가 좋아하는 Angular 자료\n\n![이미지](/assets/img/2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore_0.png)\n\n# 👋안녕하세요, Angular 애딕트 여러분\n\n이것은 Angular Addicts 뉴스레터의 25번째 호입니다. 매달 선별된 Angular 자료들로 구성되어 있습니다. (여기서는 24번째, 23번째, 22번째 호를 찾아볼 수 있어요.)\n\n\n\n# 💎2024년 4월의 Angular 보물들\n\n## 📰 Angular과 Wiz, 함께하는 게 더 좋아요\n\nGoogle은 두 개의 웹 프레임워크를 가지고 있어요: Angular과 Wiz. 옛날부터 Wiz는 성능이 중요한 앱에 초점을 맞추고, Angular은 매우 상호 작용적인 앱을 제공하는 데 초점을 맞췄어요. Jatin Ramanathan과 Minko Gechev는 두 프레임워크 사이의 차이점과 이후 몇 년 동안 두 프레임워크가 점차적으로 통합될 것임을 설명한 기사를 소개했어요.\n\n## 📰 Figma, Storybook 및 Angular로 디자인부터 코드 플로우 마스터하기\n\n\n\nMarkus Nissl씨는 4부작 시리즈에서 Figma, Storybook 및 Angular 간의 상호 관계를 통해 디자인 및 개발에 대한 현대적인 워크플로우를 보여줍니다:\n\n- Part 1: Design tokens\n- Part 2: Figma의 변수\n- Part 3: Figma에서 변수(디자인 토큰) 추출\n- Part 4: Angular 컴포넌트에 디자인 토큰 적용\n\n## 📰 드디어 누군가가 JavaScript를 고쳤습니다\n\nEffect는 개발자가 복잡한 동기화 및 비동기 프로그램을 쉽게 만들 수 있도록 설계된 강력한 TypeScript 라이브러리입니다. Almaju는 Effect의 네 가지 기능을 소개합니다.\n\n\n\n- 동시성 처리\n- 안전한 오류 처리\n- 브랜드 타입 및\n- 의존성 주입\n\n## 📰 Angular와 React 간의 이해\n\nMaksim Dolgikh은 두 가지 주요 웹 기술 사이의 차이를 이해하는 데 도움이 되도록 일련의 기사를 썼습니다:\n\n- Angular와 React 간의 이해. 파트 1: Dumb & Smart Components\n- Angular와 React 간의 이해. 파트 2: Lifecycle hooks\n- Angular와 React 간의 이해. 파트 3: Services & Context API\n\n\n\n## 📖 모던 앵귤러\n\n만프레드 스테이어가 무료 e-book '모던 앵귤러'의 두 번째 판을 출시했습니다. 이 책은 14개의 챕터로 구성되어 있으며 다음과 같은 주제를 다룹니다:\n\n- 독립형 컴포넌트, 디렉티브 및 파이프의 구현\n- 기존 코드 및 NgModules과의 호환성\n- 라우팅, 지연 로딩, DI 및 상태 관리\n- 독립형 컴포넌트와 함께 Angular Elements/Web Components 사용\n- NgModules 없이 현대적인 아키텍처\n- 시그널의 성공적인 활용\n- 새로운 내장형 제어 흐름과 @defer\n- 자동 이전 버전 전환을 위한 옵션\n- esbuild, SSR 및 Hydration\n\n# 👨‍💻저자 소개\n\n\n\n나의 이름은 Gergely Szerovay이고, 많은 해 동안 데이터 과학자 및 풀 스택 개발자로 일해왔습니다. 현재는 Angular 기반 프런트엔드 개발에 중점을 둔 프런트엔드 기술 리드로 일하고 있습니다. 제 역할의 일환으로 Angular 및 프런트엔드 개발 영역이 어떻게 발전하고 있는지 지속적으로 관찰하고 있습니다.\n\nAngular는 지난 몇 년 동안 빠르게 발전해왔으며, 작년에는 생성적 AI의 등장으로 소프트웨어 개발 워크플로우도 빠르게 발전해왔습니다. AI 보조 소프트웨어 개발의 발전을 밀접히 따라가기 위해 공개적으로 AI 도구를 개발하기로 결심했고, AIBoosted.dev 에 진행 상황을 게시하기로 했습니다. 여기에서 구독하세요 🚀\n\nAngular, AI와 함께 AI 앱을 만드는 방법에 대해 자세히 알아보려면 Substack(Angular 중독자), Substack(AIBoosted.dev), Medium, Dev.to, X 또는 LinkedIn에서 저를 팔로우해 주세요!\n\n# 📨 귀하의 Angular 자료를 제출하세요\n\n\n\n요즘 흥미로운 Angular 관련 기사, 트윗 또는 다른 자료를 발견하거나 작성했나요? 댓글로 알려주세요. 또는 트위터 DM으로 보내주세요! 제가 다음 Angular Addicts 이슈에서 소개할 수도 있어요!","ogImage":{"url":"/assets/img/2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore_0.png"},"coverImage":"/assets/img/2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore_0.png","tag":["Tech"],"readingTime":3}],"page":"26","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}