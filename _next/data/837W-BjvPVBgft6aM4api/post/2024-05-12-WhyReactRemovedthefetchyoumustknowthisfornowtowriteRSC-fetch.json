{"pageProps":{"post":{"title":"리액트가 fetch를 왜 제거했는지 지금 RSC-fetch를 작성하기 위해 반드시 알아야 하는 내용","description":"","date":"2024-05-12 20:17","slug":"2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch","content":"\n\n<img src=\"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png\" />\n\n몇 일 전, React 팀이 암시적인 fetch 캐시를 제거했습니다. 그리고 fetch 요청의 결과를 명시적으로 캐시하는 데 `React.cache`를 사용하는 것을 제안했습니다. 새로운 `React.cache` API의 장점을 최대한 활용하려면 RSC에서 fetch 호출을 작성하는 새로운 방법을 이해하는 것이 중요합니다. 그러나 새로운 방법에 대한 이해에 접어들기 전에, 개발자가 캐시를 명시적으로 관리하는 것이 왜 유익한지 먼저 이해해 봅시다.\n\n암시적 캐싱의 위험성\n\n캐싱은 전반적으로 유익해 보이지만, 브라우저나 프레임워크가 개발자의 제어 없이 자동으로 데이터를 캐시하는 암시적 캐싱은 예상치 못한 동작과 버그를 일으킬 수 있습니다. 여기에 이유가 있습니다:\n\n\n\n- 만료된 데이터: API 응답이 자주 변경되는 경우, 암시적으로 캐싱을 하면 사용자에게는 오래된 정보가 제공될 수 있어서 보여지는 데이터와 실제 상태 사이에 불일치가 발생할 수 있습니다.\n- 일관성이 없음: 다른 브라우저나 브라우저 설정은 캐싱을 다르게 구현할 수 있어 사용자 경험 사이에 불일치가 생길 수 있습니다.\n- 디버깅 문제: 만료된 데이터로 인한 문제가 발생할 때, 캐싱 메커니즘을 명시적으로 제어하지 않는 경우 원인을 파악하기 어려울 수 있습니다.\n\n성능과 유지보수성을 위한 명시적 제어\n\n명시적 캐싱을 선택함으로써, 개발자가 데이터가 어떻게 그리고 언제 캐싱되는지에 대한 소유권을 갖도록 장려합니다. 이를 통해 우리는 다음과 같은 이점을 가질 수 있습니다:\n\n- 캐싱 전략 정의: 데이터의 특성과 업데이트 빈도에 기반하여 적절한 캐싱 전략을 선택할 수 있습니다. 예를 들어, 정적 데이터는 무기한 캐싱될 수 있으며, 자주 변경되는 데이터는 유효성 검사 메커니즘이 필요할 수 있습니다.\n- 무효화 처리: 캐시 만료 시간이나 무효화 리스너와 같은 기술을 구현하여 캐시가 적합하고 오래된 정보를 제공하지 않도록 할 수 있습니다.\n- 개선된 디버깅: 캐싱을 명시적으로 제어함으로써 데이터 흐름을 쉽게 이해하고 캐싱 문제의 원인을 식별할 수 있어 개발자들이 문제 해결을 용이하게 할 수 있습니다.\n\n\n\nReact fetch 캐시는 무엇인가요?\n\nfetch 호출을 하면 React가 fetch 결과를 캐싱했습니다. 다른 컴포넌트들이 동일한 데이터를 필요로 하여 동일한 fetch 호출을 하면, React는 엔드포인트로 새로운 요청을 보내지 않고 대신에 캐시로부터 데이터를 다른 컴포넌트에 제공합니다. 이는 성능을 위해 좋지만, 예상치 못한 동작을 일으킬 수도 있습니다. 예를 들어, 아래 코드에서 다섯 개의 컴포넌트가 fetch 호출을 하고 모두 동일한 데이터가 필요합니다. 이렇게 요청을 만들 경우에 React는 결과를 캐시하지 않고 동일한 엔드포인트에 다섯 번의 요청을 보냅니다. 여기서 `React.cache` API가 캐시를 명시적으로 관리하기 위해 등장합니다.\n\n\n\n**Reach.cache()** 새로운 방법으로 fetch 호출 작성하기\n\n이제는 동일한 데이터가 필요한 다른 컴포넌트가 있다면 새로운 요청을 수행하지 않도록 fetch 호출을 React.cache로 래핑해야 합니다. 이것은 한 번의 요청만을 수행합니다.\n\n```js\nimport React from \"react\"\n\nconst getMessiStats = React.cache(async () => {\n    const stats = await fetch('https://api.football-data.org/v2/players/52')\n    return stats.json()\n})\n\nasync function MessiStats() {\n    const data = await getMessiStats()\n    return (\n        <div>\n            {JSON.stringify(data)}\n        </div>\n    )\n}\n\nexport async function RSCFetch() {\n    const stats = await getMessiStats()\n    return (\n        <>\n            <div>{JSON.stringify(stats)}</div>\n            <MessiStats />\n            <MessiStats />\n            <MessiStats />\n            <MessiStats />\n        </>\n    )\n}\n```","ogImage":{"url":"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png"},"coverImage":"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"몇 일 전, React 팀이 암시적인 fetch 캐시를 제거했습니다. 그리고 fetch 요청의 결과를 명시적으로 캐시하는 데 \", _jsx(_components.code, {\n        children: \"React.cache\"\n      }), \"를 사용하는 것을 제안했습니다. 새로운 \", _jsx(_components.code, {\n        children: \"React.cache\"\n      }), \" API의 장점을 최대한 활용하려면 RSC에서 fetch 호출을 작성하는 새로운 방법을 이해하는 것이 중요합니다. 그러나 새로운 방법에 대한 이해에 접어들기 전에, 개발자가 캐시를 명시적으로 관리하는 것이 왜 유익한지 먼저 이해해 봅시다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"암시적 캐싱의 위험성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"캐싱은 전반적으로 유익해 보이지만, 브라우저나 프레임워크가 개발자의 제어 없이 자동으로 데이터를 캐시하는 암시적 캐싱은 예상치 못한 동작과 버그를 일으킬 수 있습니다. 여기에 이유가 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"만료된 데이터: API 응답이 자주 변경되는 경우, 암시적으로 캐싱을 하면 사용자에게는 오래된 정보가 제공될 수 있어서 보여지는 데이터와 실제 상태 사이에 불일치가 발생할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"일관성이 없음: 다른 브라우저나 브라우저 설정은 캐싱을 다르게 구현할 수 있어 사용자 경험 사이에 불일치가 생길 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"디버깅 문제: 만료된 데이터로 인한 문제가 발생할 때, 캐싱 메커니즘을 명시적으로 제어하지 않는 경우 원인을 파악하기 어려울 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"성능과 유지보수성을 위한 명시적 제어\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"명시적 캐싱을 선택함으로써, 개발자가 데이터가 어떻게 그리고 언제 캐싱되는지에 대한 소유권을 갖도록 장려합니다. 이를 통해 우리는 다음과 같은 이점을 가질 수 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"캐싱 전략 정의: 데이터의 특성과 업데이트 빈도에 기반하여 적절한 캐싱 전략을 선택할 수 있습니다. 예를 들어, 정적 데이터는 무기한 캐싱될 수 있으며, 자주 변경되는 데이터는 유효성 검사 메커니즘이 필요할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"무효화 처리: 캐시 만료 시간이나 무효화 리스너와 같은 기술을 구현하여 캐시가 적합하고 오래된 정보를 제공하지 않도록 할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"개선된 디버깅: 캐싱을 명시적으로 제어함으로써 데이터 흐름을 쉽게 이해하고 캐싱 문제의 원인을 식별할 수 있어 개발자들이 문제 해결을 용이하게 할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React fetch 캐시는 무엇인가요?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"fetch 호출을 하면 React가 fetch 결과를 캐싱했습니다. 다른 컴포넌트들이 동일한 데이터를 필요로 하여 동일한 fetch 호출을 하면, React는 엔드포인트로 새로운 요청을 보내지 않고 대신에 캐시로부터 데이터를 다른 컴포넌트에 제공합니다. 이는 성능을 위해 좋지만, 예상치 못한 동작을 일으킬 수도 있습니다. 예를 들어, 아래 코드에서 다섯 개의 컴포넌트가 fetch 호출을 하고 모두 동일한 데이터가 필요합니다. 이렇게 요청을 만들 경우에 React는 결과를 캐시하지 않고 동일한 엔드포인트에 다섯 번의 요청을 보냅니다. 여기서 \", _jsx(_components.code, {\n        children: \"React.cache\"\n      }), \" API가 캐시를 명시적으로 관리하기 위해 등장합니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Reach.cache()\"\n      }), \" 새로운 방법으로 fetch 호출 작성하기\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제는 동일한 데이터가 필요한 다른 컴포넌트가 있다면 새로운 요청을 수행하지 않도록 fetch 호출을 React.cache로 래핑해야 합니다. 이것은 한 번의 요청만을 수행합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"react\\\"\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" getMessiStats = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"cache\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" () => {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" stats = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'https://api.football-data.org/v2/players/52'\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" stats.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json\"\n        }), \"()\\n})\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MessiStats\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" data = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getMessiStats\"\n        }), \"()\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n        \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          }), \"\\n            {JSON.stringify(data)}\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          })]\n        }), \"\\n    )\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"RSCFetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" stats = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getMessiStats\"\n        }), \"()\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n        \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-tag\",\n            children: \"<>\"\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          }), \"{JSON.stringify(stats)}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"MessiStats\"\n            }), \" />\"]\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"MessiStats\"\n            }), \" />\"]\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"MessiStats\"\n            }), \" />\"]\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"MessiStats\"\n            }), \" />\"]\n          }), \"\\n        \", _jsx(_components.span, {\n            className: \"hljs-tag\",\n            children: \"</>\"\n          })]\n        }), \"\\n    )\\n}\\n\"]\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}