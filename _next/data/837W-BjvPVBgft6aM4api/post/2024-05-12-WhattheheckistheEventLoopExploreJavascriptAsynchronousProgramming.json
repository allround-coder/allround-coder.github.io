{"pageProps":{"post":{"title":"이벤트 루프가 뭐죠 자바스크립트 비동기 프로그래밍 탐구","description":"","date":"2024-05-12 22:50","slug":"2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming","content":"\n\n\n![이미지](/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png)\n\n자바스크립트는 본질적으로 싱글 스레드입니다. 그렇다면 프라미스와 비동기 메서드를 어떻게 처리할까요? 그것들을 어떻게 병렬로 실행할까요? 답은 명확하지 않을 수 있습니다. 자바스크립트 비동기 프로그래밍을 탐구해봅시다...\n\n# 정교하고 효율적인 아키텍처\n\n자바스크립트는 이벤트 루프, 태스크 큐 및 마이크로태스크 큐를 결합하여 싱글 스레드 언어가 비동기 작업을 수행할 수 있도록 정교하고 효율적인 아키텍처를 갖추고 있습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_1.png\" />\n\n## 예시를 살펴보겠습니다...\n\n```js\n// 메소드-1\nconsole.log(\"A\");\n\n// 메소드-2\nsetTimeout(()=>{\n  console.log(\"B\");\n},100);\n\n// 메소드-3\nsetTimeout(()=>{\n  console.log(\"C\");\n},0);\n\n// 메소드-4\nconsole.log(\"D\");\n\n/***\n*\n* 출력:\n* ADCB\n*\n***/\n\n```\n\n- 실행이 시작되면 각 메소드 호출이 실행을 위해 CallStack에 들어갑니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_2.png\" />\n\n- 즉시 결과를 제공할 수 있는 메서드(동기 메서드)가 실행됩니다. 비동기 메서드의 콜백은 해당 Web API로 넘어갑니다.\n\n<img src=\"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_3.png\" />\n\n- 메서드 1과 4는 즉시 반환되고, 메서드 2와 3은 실행 시간이 되었을 때 TaskQueue로 푸시하기 위해 setTimeout API로 넘어갑니다.\n- 타이머가 0일 때 메서드 3이 Task Queue로 푸시되고, 타이머가 100일 때 메서드 4가 그 뒤를 이어 실행됩니다.\n- 그리고 나중에 Task Queue에 있는 각 메서드가 자유 시간이 되면 실행을 위해 호출 스택으로 이동됩니다. 이것이 Javascript가 비동기 메서드를 처리하는 방식입니다.\n\n\n\n## MicroTask Queue이 하는 일은 무엇인가요…?\n\n- MicroTask Queue은 Promise에서의 콜백을 처리하는 전용 큐입니다.\n- MicroTask Queue에 있는 콜백은 Task Queue에서의 작업보다 우선순위가 높기 때문에, Task Queue에서의 작업은 MicroTask Queue의 작업이 모두 Call Stack으로 이동한 후에만 Call Stack으로 이동됩니다. 언제 큐에 도착했느냐에 관계없이 그렇습니다.\n\n# 결론\n\n이벤트 루프의 개념은 JavaScript를 더 동적이고 유연하게 만들어 주었습니다. JavaScript가 일 스레드인 한에서 비동기 프로그래밍을 수행하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png"},"coverImage":"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png","tag":["Tech"],"readingTime":2},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자바스크립트는 본질적으로 싱글 스레드입니다. 그렇다면 프라미스와 비동기 메서드를 어떻게 처리할까요? 그것들을 어떻게 병렬로 실행할까요? 답은 명확하지 않을 수 있습니다. 자바스크립트 비동기 프로그래밍을 탐구해봅시다...\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"정교하고 효율적인 아키텍처\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자바스크립트는 이벤트 루프, 태스크 큐 및 마이크로태스크 큐를 결합하여 싱글 스레드 언어가 비동기 작업을 수행할 수 있도록 정교하고 효율적인 아키텍처를 갖추고 있습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_1.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"예시를 살펴보겠습니다...\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 메소드-1\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"A\\\"\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 메소드-2\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"setTimeout\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"()=>\"\n        }), \"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"B\\\"\"\n        }), \");\\n},\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 메소드-3\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"setTimeout\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"()=>\"\n        }), \"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"C\\\"\"\n        }), \");\\n},\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 메소드-4\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"D\\\"\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/***\\n*\\n* 출력:\\n* ADCB\\n*\\n***/\"\n        }), \"\\n\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"실행이 시작되면 각 메소드 호출이 실행을 위해 CallStack에 들어갑니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_2.png\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"즉시 결과를 제공할 수 있는 메서드(동기 메서드)가 실행됩니다. 비동기 메서드의 콜백은 해당 Web API로 넘어갑니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_3.png\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"메서드 1과 4는 즉시 반환되고, 메서드 2와 3은 실행 시간이 되었을 때 TaskQueue로 푸시하기 위해 setTimeout API로 넘어갑니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"타이머가 0일 때 메서드 3이 Task Queue로 푸시되고, 타이머가 100일 때 메서드 4가 그 뒤를 이어 실행됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"그리고 나중에 Task Queue에 있는 각 메서드가 자유 시간이 되면 실행을 위해 호출 스택으로 이동됩니다. 이것이 Javascript가 비동기 메서드를 처리하는 방식입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"MicroTask Queue이 하는 일은 무엇인가요…?\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"MicroTask Queue은 Promise에서의 콜백을 처리하는 전용 큐입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"MicroTask Queue에 있는 콜백은 Task Queue에서의 작업보다 우선순위가 높기 때문에, Task Queue에서의 작업은 MicroTask Queue의 작업이 모두 Call Stack으로 이동한 후에만 Call Stack으로 이동됩니다. 언제 큐에 도착했느냐에 관계없이 그렇습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이벤트 루프의 개념은 JavaScript를 더 동적이고 유연하게 만들어 주었습니다. JavaScript가 일 스레드인 한에서 비동기 프로그래밍을 수행하는 데 도움이 됩니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}