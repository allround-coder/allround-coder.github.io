{"pageProps":{"post":{"title":"플러터에서 텍스트 스케일링을 적절히 다루는 방법","description":"","date":"2024-05-17 03:37","slug":"2024-05-17-ProperlyhandlingtextscalinginFlutter","content":"\n\n이 튜토리얼은 가장 쉽고 영향력이 큰 해결책을 먼저 제시하도록 구성되어 있어요. 후속 섹션에는 구현이 어려우면서 전반적인 영향이 더 낮은 해결책들이 포함되어 있지만, 특정 경우에 대응하기 위해 유용해요.\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png)\n\n## 텍스트 스케일링 가능 범위 제한\n\nMaterialApp에 최소 및 최대 스케일 팩터를 설정할 수 있어요. 이렇게 하면 모든 텍스트가 지정한 범위 내에서 스케일링된다는 것을 보장할 수 있어요. 더 빈번한 경계는 가독성과 미적 감각을 유지하는 데 덜 노력이 필요해요. 그러나 경계 선택은 대상 사용자에 따라 달라져야 해요. 예를 들어 노인 사용자를 대상으로 한 앱의 경우, 그들의 요구를 수용하기 위해 더 넓은 범위를 사용하는 것을 고려해야 해요.\n\n<div class=\"content-ad\"></div>\n\n```js\n    MaterialApp(\n      ...\n      builder: (_, child) => MediaQuery(\n        data: MediaQuery.of(context).copyWith(\n          textScaler: MediaQuery.of(context)\n              .textScaler\n              .clamp(minScaleFactor: 0.8, maxScaleFactor: 1.6),\n        ),\n        child: child!,\n      ),\n    );\n```\n\n## 텍스트를 포함하는 요소에 고정 높이를 사용하지 마세요\n\n다음 코드를 살펴보세요:\n\n```js\n          //DON'T\n          SizedBox(\n            height: 100,\n            child: Card(\n              child: Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: [\n                    Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n                    Text(\"Subtitle\", maxLines: 1),\n                  ],\n                ),\n              ),\n            ),\n          ),\n```\n\n<div class=\"content-ad\"></div>\n\n문제가 발생할 수 있습니다.\n\n예상하신 대로, 텍스트 크기를 키우면 SizedBox의 내용이 너무 많은 공간을 차지할 수 있습니다.\n\n![image](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_1.png)\n\n컨텐츠 높이 및 패딩에 기반한 아이템의 높이를 만드는 것이 더 좋습니다. 게다가 ConstrainedBox를 사용하여 최소 높이를 설정할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nConstrainedBox(\n  constraints: const BoxConstraints(minHeight: 100),\n  child: const Card(\n    child: Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n          Text(\"Subtitle\", maxLines: 1),\n        ],\n      ),\n    ),\n  ),\n),\n```\n\n결과적으로 100% 배율에서 동일한 레이아웃을 얻고, 160%에서도 유효한 레이아웃을 얻을 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_2.png\" />\n\nListView에도 동일한 사항이 적용됩니다. itemExtent를 사용하는 경우, 폰트 스케일을 고려하여 계산하거나 prototypeItem을 제공하는 것이 좋습니다. 이에 대해 자세히 설명된 내용은 이 기사에서 확인할 수 있습니다.\n  \n\n<div class=\"content-ad\"></div>\n\n계속 진행해 봅시다. 다음 레이아웃을 상상해보세요:\n\n![Image1](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_3.png)\n\n아이템 A는 이전 예시에서 나왔어요. 아이템 B는 약간의 간격을 가지고 있고 텍스트 확대에 대응할 수 있어야해요. 화면 하단에는 충분한 공간이 있어요. 그래서 어떤 문제가 발생할 수 있을까요?\n\n![Image2](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_4.png)\n\n<div class=\"content-ad\"></div>\n\n화면이 작은 폰들도 고려해주세요. 또한, 언어를 바꿀 때 텍스트 길이가 달라질 수 있어요.\n\n## 컨텐츠를 스크롤할 수 있도록 만들기\n\n먼저, 모든 컨텐츠에 접근 가능하도록 오버플로우를 제거해야 해요. 간단한 SingleChildScrollView를 추가하면 이 문제를 해결할 수 있어요.\n\n## 마진과 패딩에 대해 적응적인 값을 사용하는 것을 고려해보세요\n\n<div class=\"content-ad\"></div>\n\n이것은 논란이 될 수 있는 방법일 수 있지만, 자신이 더 큰 글꼴을 사용해야 하는 사용자로 상상해보세요. 사용되지 않는 공간을 많이 보고 싶으신가요 아니면 텍스트를 명확하게 읽고 싶으신가요?\n\n텍스트를 표시하는 논리적 픽셀의 수에 따라 값들을 사용해봅시다. smallScreenThreshold를 응용 프로그램에 가장 적합한 값으로 조절할 수 있습니다.\n\n```js\nclass Dimens {\n  static const smallScreenThreshold = 300;\n  static bool isSmallWidth(BuildContext context) {\n    return MediaQuery.of(context).size.width /\n            MediaQuery.textScalerOf(context).scale(1) <\n        smallScreenThreshold;\n  }\n\n  static double small(BuildContext context) => isSmallWidth(context) ? 4 : 8;\n  static double medium(BuildContext context) => isSmallWidth(context) ? 8 : 16;\n  static double large(BuildContext context) => isSmallWidth(context) ? 16 : 32;\n}\n```\n\n만약 Human Interface Guidelines와 Material Design을 따르고 싶다면, 이 값들은 4로 나눌 수 있는 값이어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 Dimens에 기반하여 간격에 대한 클래스를 만들 수 있습니다:\n\n```js\nclass Insets {\n  static EdgeInsets small(BuildContext context) =>\n      EdgeInsets.all(Dimens.small(context));\n      \n  static EdgeInsets medium(BuildContext context) =>\n      EdgeInsets.all(Dimens.medium(context));\n\n  static EdgeInsets large(BuildContext context) =>\n      EdgeInsets.all(Dimens.large(context));\n}\n```\n\n그리고 코드에서 다음과 같이 대체합니다:\n\n```js\n//padding: const EdgeInsets.all(16),\npadding: Insets.medium(context),\n\n//SizedBox(height: 16),\nSizedBox(height: Dimens.medium(context)),\n```\n\n<div class=\"content-ad\"></div>\n\n결과적으로 화면에 텍스트를 그릴 수 있는 공간이 조금 더 확보되었습니다:\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_5.png)\n\n## 제목의 텍스트 크기 확장을 제한하세요\n\n글꼴 크기를 크게 하는 주된 목적은 시력이 약해진 사람들에게 콘텐츠를 가독성 있게 만드는 것입니다. 그러나 제목과 같은 앱의 일부는 이미 글꼴이 크기 때문에 접근성이 좋을 수 있습니다. 이를 해결하기 위해 텍스트가 확대될 수 있는 범위를 제한할 수 있습니다. 이를 달성하는 한 가지 방법은 제목용 사용자 정의 위젯을 만드는 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass TitleText extends StatelessWidget {\n  final String text;\n  final TextStyle style;\n\n  const TitleText(this.text, {required this.style, super.key});\n\n  static const double maxRealFontSize = 30;\n\n  @override\n  Widget build(BuildContext context) {\n    if (MediaQuery.textScalerOf(context).scale(style.fontSize!) >\n        maxRealFontSize) {\n      return Text(\n        text,\n        style: style.copyWith(\n          fontSize: maxRealFontSize / MediaQuery.textScalerOf(context).scale(1),\n        ),\n      );\n    }\n    return Text(text, style: style);\n  }\n}\n```\n\n이렇게 하면 가독성을 유지하면서 공간을 더 확보할 수 있어요. 앱에 더 적합한 값으로 maxRealFontSize를 변경할 수 있어요.\n\n<img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_6.png\" />\n\n## 최대 줄 수 및 텍스트 오버플로우 지정하기\n\n<div class=\"content-ad\"></div>\n\n큰 화면에서 일반적인 텍스트 스케일로 보기 좋을 수도 있지만, 다른 조건에서는 수직 공간을 더 많이 차지할 수 있음을 잊지 마세요. 그러나 제목(Subtitle)과 같은 곳은 항상 전체 내용을 표시할 필요가 없습니다. Text 위젯에 maxLines 값을 추가하여 원하는 줄 수로 설정할 수 있습니다.\n\n\n![Properly handling text scaling in Flutter](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_7.png) \n\n\n1로 설정된 maxLines로 보기 좋네요. 주요 정보는 여전히 잘 보입니다.\n\n## 문자열의 대안 버전 사용하기\n\n<div class=\"content-ad\"></div>\n\n하지만 항상 유용한 정보를 포함하는 방식으로 문자열을 줄이는 것이 가능한 것은 아닙니다. 게다가, 단어 순서는 다른 언어들에서 다르게 변할 수 있습니다. 영어에서의 첫 번째 단어가 다른 언어에서는 문장의 끝에 올 수도 있습니다. 이번에는 국제화(i18n) 문자열을 고려해보는 것이 중요합니다:\n\n```js\n        \"tasksDone\": {\n            \"one\": \"할 일 중 $completed 개 완료\",\n            \"other\": \"할 일 중 $completed 개 완료\"\n        },\n        \"tasksDoneShort\": {\n            \"one\": \"$completed/$n 작업 완료\",\n            \"other\": \"$completed/$n 작업 완료\"\n        },\n```\n\n가장 의미 있는 부분은 숫자를 나타낸 부분입니다. 더 짧은 버전에서 숫자를 앞에 두고 전체 문자열을 더 짧게 만들었습니다. 코드에서는 다음과 같이 사용할 수 있습니다:\n\n```js\n        Text(\n          Dimens.isSmallWidth(context)\n              ? t.tasksDoneShort(n: 10, completed: 5)\n              : t.tasksDone(n: 10, completed: 5),\n          maxLines: 1,\n        )\n```\n\n<div class=\"content-ad\"></div>\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_8.png)\n\n스크린샷을 보시면, 단축된 버전을 사용하면 필요한 정보를 보여주는 데 도움이 됩니다.\n\n이 기사가 유용하게 느껴졌으면 좋겠네요. 더 유용한 기술을 찾으면 업데이트할 예정입니다. 코드는 이 저장소에서 찾을 수 있습니다.\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_9.png)","ogImage":{"url":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png"},"coverImage":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png","tag":["Tech"],"readingTime":7},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"이 튜토리얼은 가장 쉽고 영향력이 큰 해결책을 먼저 제시하도록 구성되어 있어요. 후속 섹션에는 구현이 어려우면서 전반적인 영향이 더 낮은 해결책들이 포함되어 있지만, 특정 경우에 대응하기 위해 유용해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"텍스트 스케일링 가능 범위 제한\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"MaterialApp에 최소 및 최대 스케일 팩터를 설정할 수 있어요. 이렇게 하면 모든 텍스트가 지정한 범위 내에서 스케일링된다는 것을 보장할 수 있어요. 더 빈번한 경계는 가독성과 미적 감각을 유지하는 데 덜 노력이 필요해요. 그러나 경계 선택은 대상 사용자에 따라 달라져야 해요. 예를 들어 노인 사용자를 대상으로 한 앱의 경우, 그들의 요구를 수용하기 위해 더 넓은 범위를 사용하는 것을 고려해야 해요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MaterialApp\"\n        }), \"(\\n      ...\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"builder\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_, child\"\n          }), \") =>\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MediaQuery\"\n        }), \"(\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"data\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MediaQuery\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"of\"\n        }), \"(context).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"copyWith\"\n        }), \"(\\n          \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"textScaler\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MediaQuery\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"of\"\n        }), \"(context)\\n              .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"textScaler\"\n        }), \"\\n              .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clamp\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"minScaleFactor\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.8\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"maxScaleFactor\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.6\"\n        }), \"),\\n        ),\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"child\"\n        }), \": child!,\\n      ),\\n    );\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"텍스트를 포함하는 요소에 고정 높이를 사용하지 마세요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 코드를 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"          \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//DON'T\"\n        }), \"\\n          \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SizedBox\"\n        }), \"(\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"height\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"child\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Card\"\n        }), \"(\\n              \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"child\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Center\"\n        }), \"(\\n                \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"child\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Column\"\n        }), \"(\\n                  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"mainAxisAlignment\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MainAxisAlignment\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"center\"\n        }), \",\\n                  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"children\"\n        }), \": [\\n                    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Title\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"style\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TextStyle\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"fontSize\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"30\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"maxLines\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),\\n                    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Subtitle\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"maxLines\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),\\n                  ],\\n                ),\\n              ),\\n            ),\\n          ),\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"문제가 발생할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예상하신 대로, 텍스트 크기를 키우면 SizedBox의 내용이 너무 많은 공간을 차지할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_1.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컨텐츠 높이 및 패딩에 기반한 아이템의 높이를 만드는 것이 더 좋습니다. 게다가 ConstrainedBox를 사용하여 최소 높이를 설정할 수도 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-dart\",\n        children: [\"ConstrainedBox(\\n  constraints: \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" BoxConstraints(minHeight: \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \"),\\n  child: \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" Card(\\n    child: Center(\\n      child: Column(\\n        mainAxisAlignment: MainAxisAlignment.center,\\n        children: [\\n          Text(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Title\\\"\"\n        }), \", style: TextStyle(fontSize: \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"30\"\n        }), \"), maxLines: \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),\\n          Text(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Subtitle\\\"\"\n        }), \", maxLines: \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),\\n        ],\\n      ),\\n    ),\\n  ),\\n),\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과적으로 100% 배율에서 동일한 레이아웃을 얻고, 160%에서도 유효한 레이아웃을 얻을 수 있습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_2.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ListView에도 동일한 사항이 적용됩니다. itemExtent를 사용하는 경우, 폰트 스케일을 고려하여 계산하거나 prototypeItem을 제공하는 것이 좋습니다. 이에 대해 자세히 설명된 내용은 이 기사에서 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"계속 진행해 봅시다. 다음 레이아웃을 상상해보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_3.png\",\n        alt: \"Image1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아이템 A는 이전 예시에서 나왔어요. 아이템 B는 약간의 간격을 가지고 있고 텍스트 확대에 대응할 수 있어야해요. 화면 하단에는 충분한 공간이 있어요. 그래서 어떤 문제가 발생할 수 있을까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_4.png\",\n        alt: \"Image2\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"화면이 작은 폰들도 고려해주세요. 또한, 언어를 바꿀 때 텍스트 길이가 달라질 수 있어요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"컨텐츠를 스크롤할 수 있도록 만들기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 모든 컨텐츠에 접근 가능하도록 오버플로우를 제거해야 해요. 간단한 SingleChildScrollView를 추가하면 이 문제를 해결할 수 있어요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"마진과 패딩에 대해 적응적인 값을 사용하는 것을 고려해보세요\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 논란이 될 수 있는 방법일 수 있지만, 자신이 더 큰 글꼴을 사용해야 하는 사용자로 상상해보세요. 사용되지 않는 공간을 많이 보고 싶으신가요 아니면 텍스트를 명확하게 읽고 싶으신가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"텍스트를 표시하는 논리적 픽셀의 수에 따라 값들을 사용해봅시다. smallScreenThreshold를 응용 프로그램에 가장 적합한 값으로 조절할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dimens\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" smallScreenThreshold = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"300\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" bool \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"isSmallWidth\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"BuildContext context\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MediaQuery\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"of\"\n        }), \"(context).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"size\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"width\"\n        }), \" /\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MediaQuery\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"textScalerOf\"\n        }), \"(context).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"scale\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") <\\n        smallScreenThreshold;\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" double \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"small\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BuildContext\"\n        }), \" context) => \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"isSmallWidth\"\n        }), \"(context) ? \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" double \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"medium\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BuildContext\"\n        }), \" context) => \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"isSmallWidth\"\n        }), \"(context) ? \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" double \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"large\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BuildContext\"\n        }), \" context) => \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"isSmallWidth\"\n        }), \"(context) ? \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"32\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 Human Interface Guidelines와 Material Design을 따르고 싶다면, 이 값들은 4로 나눌 수 있는 값이어야 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 Dimens에 기반하여 간격에 대한 클래스를 만들 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Insets\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"EdgeInsets\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"small\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BuildContext\"\n        }), \" context) =>\\n      \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"EdgeInsets\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"all\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dimens\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"small\"\n        }), \"(context));\\n      \\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"EdgeInsets\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"medium\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BuildContext\"\n        }), \" context) =>\\n      \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"EdgeInsets\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"all\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dimens\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"medium\"\n        }), \"(context));\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"EdgeInsets\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"large\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BuildContext\"\n        }), \" context) =>\\n      \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"EdgeInsets\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"all\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dimens\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"large\"\n        }), \"(context));\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 코드에서 다음과 같이 대체합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//padding: const EdgeInsets.all(16),\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"padding\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Insets\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"medium\"\n        }), \"(context),\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//SizedBox(height: 16),\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SizedBox\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"height\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dimens\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"medium\"\n        }), \"(context)),\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과적으로 화면에 텍스트를 그릴 수 있는 공간이 조금 더 확보되었습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_5.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"제목의 텍스트 크기 확장을 제한하세요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"글꼴 크기를 크게 하는 주된 목적은 시력이 약해진 사람들에게 콘텐츠를 가독성 있게 만드는 것입니다. 그러나 제목과 같은 앱의 일부는 이미 글꼴이 크기 때문에 접근성이 좋을 수 있습니다. 이를 해결하기 위해 텍스트가 확대될 수 있는 범위를 제한할 수 있습니다. 이를 달성하는 한 가지 방법은 제목용 사용자 정의 위젯을 만드는 것입니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-dart\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-class\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"TitleText\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"extends\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"StatelessWidget\"\n          }), \" \"]\n        }), \"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"final\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"String\"\n        }), \" text;\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"final\"\n        }), \" TextStyle style;\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" TitleText(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \".text, {\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"required\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \".style, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"super\"\n        }), \".key});\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"double\"\n        }), \" maxRealFontSize = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"30\"\n        }), \";\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@override\"\n        }), \"\\n  Widget build(BuildContext context) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (MediaQuery.textScalerOf(context).scale(style.fontSize!) >\\n        maxRealFontSize) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Text(\\n        text,\\n        style: style.copyWith(\\n          fontSize: maxRealFontSize / MediaQuery.textScalerOf(context).scale(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),\\n        ),\\n      );\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Text(text, style: style);\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이렇게 하면 가독성을 유지하면서 공간을 더 확보할 수 있어요. 앱에 더 적합한 값으로 maxRealFontSize를 변경할 수 있어요.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_6.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"최대 줄 수 및 텍스트 오버플로우 지정하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"큰 화면에서 일반적인 텍스트 스케일로 보기 좋을 수도 있지만, 다른 조건에서는 수직 공간을 더 많이 차지할 수 있음을 잊지 마세요. 그러나 제목(Subtitle)과 같은 곳은 항상 전체 내용을 표시할 필요가 없습니다. Text 위젯에 maxLines 값을 추가하여 원하는 줄 수로 설정할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_7.png\",\n        alt: \"Properly handling text scaling in Flutter\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"1로 설정된 maxLines로 보기 좋네요. 주요 정보는 여전히 잘 보입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"문자열의 대안 버전 사용하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 항상 유용한 정보를 포함하는 방식으로 문자열을 줄이는 것이 가능한 것은 아닙니다. 게다가, 단어 순서는 다른 언어들에서 다르게 변할 수 있습니다. 영어에서의 첫 번째 단어가 다른 언어에서는 문장의 끝에 올 수도 있습니다. 이번에는 국제화(i18n) 문자열을 고려해보는 것이 중요합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tasksDone\\\"\"\n        }), \": {\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"one\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"할 일 중 $completed 개 완료\\\"\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"other\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"할 일 중 $completed 개 완료\\\"\"\n        }), \"\\n        },\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tasksDoneShort\\\"\"\n        }), \": {\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"one\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"$completed/$n 작업 완료\\\"\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"other\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"$completed/$n 작업 완료\\\"\"\n        }), \"\\n        },\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가장 의미 있는 부분은 숫자를 나타낸 부분입니다. 더 짧은 버전에서 숫자를 앞에 두고 전체 문자열을 더 짧게 만들었습니다. 코드에서는 다음과 같이 사용할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Text\"\n        }), \"(\\n          \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dimens\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"isSmallWidth\"\n        }), \"(context)\\n              ? t.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tasksDoneShort\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"completed\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \")\\n              : t.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tasksDone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"completed\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"),\\n          \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"maxLines\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\\n        )\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_8.png\",\n        alt: \"Screenshot\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"스크린샷을 보시면, 단축된 버전을 사용하면 필요한 정보를 보여주는 데 도움이 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사가 유용하게 느껴졌으면 좋겠네요. 더 유용한 기술을 찾으면 업데이트할 예정입니다. 코드는 이 저장소에서 찾을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_9.png\",\n        alt: \"Screenshot\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}