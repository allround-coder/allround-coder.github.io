{"pageProps":{"post":{"title":"React 19 Beta 릴리스, 새로운 기능 소개 및 정리","description":"","date":"2024-05-01 17:45","slug":"2024-05-01-React19BetaReleasedWhatYouNeedtoKnow","content":"\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png)\n\n지난 2022년 6월 React의 마지막 안정 버전 이후, 두 년 가까이 새 버전이 나오지 않았는데, 이제 npm에서 React 19 베타판이 안정 버전인 React 18.3.0과 함께 공개되었습니다. React 19 베타판에서 개발자들이 알아야 할 새로운 기능을 살펴보겠습니다.\n\n## 액션\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_1.png)\n\n<div class=\"content-ad\"></div>\n\n리액트 앱에서 흔히 발생하는 사용 사례는 데이터 변이를 수행한 다음 응답에 따라 상태를 업데이트하는 것입니다. 예를 들어, 사용자가 이름을 변경하기 위해 양식을 제출하면 API 요청을 만들고 그 다음 응답을 처리해야 합니다. 과거에는 보류 중인 상태, 오류, 낙관적 업데이트 및 순차 요청을 수동으로 처리해야 했습니다.\n\n예를 들어, useState로 대기 및 오류 상태를 처리할 수 있었습니다:\n\n```js\n// 액션 이전\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, setIsPending] = useState(false);\n\n  const handleSubmit = async () => {\n    setIsPending(true);\n    const error = await updateName(name);\n    setIsPending(false);\n    if (error) {\n      setError(error);\n      return;\n    } \n    redirect(\"/경로\");\n  };\n\n  return (\n    <div>\n      <input value={name} onChange={(event) => setName(event.target.value)} />\n      <button onClick={handleSubmit} disabled={isPending}>\n        업데이트\n      </button>\n      {error && <p>{error}</p>}\n    </div>\n  );\n}\n```\n\n리액트 19에서는 전이에 비동기 함수를 사용하여 대기 중인 상태, 오류, 양식 및 낙관적 업데이트를 자동으로 처리할 수 있는 지원이 추가되었습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, useTransition을 사용하여 대기 상태를 처리할 수 있습니다:\n\n```js\n// Actions에서 대기 상태 사용하기\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSubmit = async () => {\n    startTransition(async () => {\n      const error = await updateName(name);\n      if (error) {\n        setError(error);\n        return;\n      } \n      redirect(\"/path\");\n    })\n  };\n\n  return (\n    <div>\n      <input value={name} onChange={(event) => setName(event.target.value)} />\n      <button onClick={handleSubmit} disabled={isPending}>\n        Update\n      </button>\n      {error && <p>{error}</p>}\n    </div>\n  );\n}\n```\n\n비동기 전환은 즉시 isPending 상태를 true로 설정하고 비동기 요청을 수행한 다음 이전 전환 후에 isPending를 false로 전환합니다. 이렇게 하면 데이터가 변경되는 동안에도 현재 UI를 반응적이고 상호작용할 수 있게 유지할 수 있습니다.\n\n관례적으로, 비동기 전환을 사용하는 함수는 \"Actions\"라고 합니다.\n\n<div class=\"content-ad\"></div>\n\n동작은 데이터 제출을 자동으로 처리해줍니다:\n\n- 보류 상태: 동작은 요청의 시작부터 시작되는 보류 상태를 제공하며, 최종 상태 업데이트가 완료될 때 자동으로 재설정됩니다.\n- 낙관적 업데이트: 동작은 새로운 useOptimistic 훅을 지원하여 요청이 제출되는 동안 사용자에게 즉시 피드백을 제공할 수 있습니다.\n- 오류 처리: 동작은 오류 처리를 제공하여 요청이 실패했을 때 오류 경계를 표시하고, 낙관적 업데이트를 자동으로 원래 값으로 되돌립니다.\n- 폼: 이제 `form` 요소는 동작과 formAction props에 함수를 전달할 수 있습니다. action props에 함수를 전달하면 기본적으로 동작을 사용하고 제출 후 자동으로 폼을 재설정합니다.\n\nReact 19에서 동작을 기반으로하면 낙관적 업데이트를 관리하는 useOptimistic 및 동작의 공통 사례를 처리하는 새로운 hook인 React.useActionState를 도입했습니다. react-dom에서는 `form` 동작을 사용하여 폼을 자동으로 처리하고, 동작의 공통 사례를 지원하는 useFormStatus를 추가했습니다.\n\nReact 19에서 위 예제는 간단하게 변경될 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// <form> 작업 및 useActionState 사용하기\nfunction ChangeName({ name, setName }) {\n  const [error, submitAction, isPending] = useActionState(\n    async (previousState, formData) => {\n      const error = await updateName(formData.get(\"name\"));\n      if (error) {\n        return error;\n      }\n      redirect(\"/path\");\n    }\n  );\n\n  return (\n    <form action={submitAction}>\n      <input type=\"text\" name=\"name\" />\n      <button type=\"submit\" disabled={isPending}>업데이트</button>\n      {error && <p>{error}</p>}\n    </form>\n  );\n}\n```\n\n# 새로운 훅: useActionState\n\nReact 19에서 일반적인 케이스를 보다 쉽게 만들기 위해 useActionState라는 새로운 훅이 추가되었습니다:\n\n```js\nconst [error, submitAction, isPending] = useActionState(async (previousState, newName) => {\n  const error = await updateName(newName);\n  if (error) {\n    // 작업의 결과로 어떤 것이든 반환할 수 있습니다.\n    // 여기서는 오직 에러만 반환합니다.\n    return error;\n  }\n  \n  // 성공 처리\n});\n```\n\n<div class=\"content-ad\"></div>\n\n`useActionState` 함수는 함수(액션)를 인수로 받아 감싼 액션을 호출합니다. 이는 액션이 조합되기 때문에 작동합니다. 감싼 액션이 호출되면 `useActionState`는 액션의 마지막 결과를 데이터로 반환하고 액션의 보류 상태를 보류로 반환합니다.\n\n# React DOM: form 액션\n\nReact 19의 새로운 `form` 기능에 액션도 통합되어 있습니다. `form`, `input`, 그리고 `button` 엘리먼트의 액션과 formAction 프롭으로 함수를 전달하여 액션과 함께 자동으로 폼을 제출할 수 있습니다:\n\n```js\n<form action={actionFunction}>\n```\n\n<div class=\"content-ad\"></div>\n\n`form`이 성공하면 React는 제어되지 않는 컴포넌트를 위해 자동으로 `form`을 재설정합니다. `form`을 수동으로 재설정해야 하는 경우, 새 요청 `form` 재설정 React DOM API를 호출할 수 있습니다.\n\n# React DOM: 새로운 훅: useFormStatus\n\n디자인 시스템에서 `form`에 대한 정보에 액세스해야 하는 디자인 컴포넌트를 작성하는 것이 일반적입니다. 그러나 컴포넌트로 속성을 전달 받지 않아도 되도록 하는 경우가 있습니다. 이 작업은 Context를 통해 수행할 수 있지만, 일반적인 경우를 쉽게 만들기 위해 React 19에 새로운 훅인 useFormStatus가 추가되었습니다:\n\n```js\nimport {useFormStatus} from 'react-dom';\n\nfunction DesignButton() {\n  const {pending} = useFormStatus();\n  return <button type=\"submit\" disabled={pending} />\n}\n```\n\n<div class=\"content-ad\"></div>\n\n`useFormStatus`는 부모 `form`의 상태를 읽어오는 것처럼 동작하여, 마치 form이 Context 제공자인 것처럼 사용할 수 있습니다.\n\n# 새로운 훅: useOptimistic\n\n데이터 변경 작업을 수행할 때 또 다른 일반적인 UI 패턴은 비동기 요청 진행 중에 최종 상태를 낙관적으로 표시하는 것입니다. React 19에서는 이를 쉽게 처리할 수 있도록 `useOptimistic`라는 새로운 훅이 추가되었습니다:\n\n```js\nfunction ChangeName({currentName, onUpdateName}) {\n  const [optimisticName, setOptimisticName] = useOptimistic(currentName);\n\n  const submitAction = async formData => {\n    const newName = formData.get(\"name\");\n    setOptimisticName(newName);\n    const updatedName = await updateName(newName);\n    onUpdateName(updatedName);\n  };\n\n  return (\n    <form action={submitAction}>\n      <p>Your name is: {optimisticName}</p>\n      <p>\n        <label>Change Name:</label>\n        <input\n          type=\"text\"\n          name=\"name\"\n          disabled={currentName !== optimisticName}\n        />\n      </p>\n    </form>\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n`useOptimistic` 훅은 `updateName` 요청이 진행 중일 때 즉시 `optimisticName`을 렌더링합니다. 업데이트가 완료되거나 에러가 발생하면 React가 자동으로 `currentName` 값으로 전환됩니다.\n\n# 새 API: use\n\nReact 19에서 렌더링하는 동안 리소스를 읽기 위한 새로운 API가 추가되었습니다: `use`.\n\n예를 들어, `use`로 프로미스를 읽을 수 있으며, React가 프로미스가 해결될 때까지 일시 중단됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {use} from 'react';\n\nfunction Comments({commentsPromise}) {\n  // `use`가 프로미스가 해결될 때까지 일시 중단됩니다.\n  const comments = use(commentsPromise);\n  return comments.map(comment => <p key={comment.id}>{comment}</p>);\n}\n\nfunction Page({commentsPromise}) {\n  // Comments에서 `use`가 일시 중단되면\n  // 이 Suspense 경계가 표시됩니다.\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Comments commentsPromise={commentsPromise} />\n    </Suspense>\n  )\n}\n```\n\n렌더링되는 동안 생성된 프로미스를 지원하지 않습니다.\n\n렌더링에서 만든 프로미스를 use에 전달하려고 하면 React에서 경고합니다:\n\n수정하려면, 프로미스 캐싱을 지원하는 suspense 기반 라이브러리나 프레임워크에서 프로미스를 전달해야 합니다. 미래에는 렌더링 중에 프로미스를 캐싱하기 쉽게 만드는 기능을 제공할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n또한 일찍 반환한 후와 같이 조건부로 Context를 읽을 수도 있습니다:\n\n```js\nimport {use} from 'react';\nimport ThemeContext from './ThemeContext'\n\nfunction Heading({children}) {\n  if (children == null) {\n    return null;\n  }\n  \n  // 일찍 반환으로 인해 useContext로 동작하지 않습니다.\n  const theme = use(ThemeContext);\n  return (\n    <h1 style={{color: theme.color}}>\n      {children}\n    </h1>\n  );\n}\n```\n\nuse API는 후크와 유사하게 렌더링 중에만 호출될 수 있습니다. 후크와는 다르게 use는 조건부로 호출할 수 있습니다.\n\n자세한 정보는 use에 대한 문서를 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n# ref을 속성으로 사용하기\n\nReact 19부터 함수 컴포넌트에서 ref를 속성으로 접근할 수 있습니다:\n\n```js\nfunction MyInput({placeholder, ref}) {\n  return <input placeholder={placeholder} ref={ref} />\n}\n\n//...\n<MyInput ref={ref} />\n```\n\n새로운 함수 컴포넌트는 더 이상 forwardRef가 필요하지 않습니다. 향후 버전에서 React는 forwardRef를 사용하지 않도록 하고 제거할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# 'Context'를 제공자로 렌더링하기\n\nReact 19에서 'Context.Provider' 대신 'Context'를 제공자로 렌더링할 수 있습니다:\n\n```js\nconst ThemeContext = createContext('');\n\nfunction App({children}) {\n  return (\n    <ThemeContext value=\"dark\">\n      {children}\n    </ThemeContext>\n  );  \n}\n```\n\n나중에 React 버전에서는 'Context.Provider'를 사용하지 않도록 지원 중단될 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# ref에 대한 정리 함수\n\n이제 React는 ref 콜백에서 정리 함수를 반환하는 것을 지원합니다:\n\n```js\n<input\n  ref={(ref) => {\n    // ref 생성\n\n    // 새로운 기능: 요소가 DOM에서 제거될 때 ref를 재설정하는 정리 함수를 반환합니다.\n    return () => {\n      // ref 정리\n    };\n  }\n/>\n```\n\n컴포넌트가 언마운트될 때, React는 ref 콜백에서 반환된 정리 함수를 호출합니다. 이는 DOM ref, 클래스 컴포넌트에 대한 ref 및 useImperativeHandle에 대해 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n리팩토링된 ref 정리 함수의 도입으로 인해 TypeScript에서 ref 콜백에서 다른 값을 반환하면 거부됩니다. 이 문제를 해결하는 방법은 일반적으로 암시적 반환을 사용하지 않도록 하는 것입니다. 예를 들어:\n\n```js\n- <div ref={current => (instance = current)} />\n+ <div ref={current => {instance = current} />\n```\n\n원본 코드는 HTMLDivElement의 인스턴스를 반환했으며 TypeScript는 이것이 정리 함수인지 아니면 정리 함수를 반환하고 싶지 않은 것인지를 알 수 없습니다.\n\n# useDeferredValue 초기 값\n\n<div class=\"content-ad\"></div>\n\nReact는 useDeferredValue에 initialValue 옵션을 추가했습니다:\n\n```js\nfunction Search({deferredValue}) {\n  // 초기 렌더링 시 값은 ''입니다.\n  // 그런 다음 다시 렌더링이 예약되고 deferredValue로 업데이트됩니다.\n  const value = useDeferredValue(deferredValue, '');\n  \n  return (\n    <Results query={value} />\n  );\n}\n```\n\ninitialValue가 제공되면 useDeferredValue는 해당 값을 컴포넌트의 초기 렌더링에 반환하고, deferredValue를 사용하여 백그라운드에서 다시 렌더링을 예약합니다.\n\n# 문서 메타데이터 지원\n\n<div class=\"content-ad\"></div>\n\nHTML에서는 `title`, `link`, `meta`와 같은 문서 메타데이터 태그를 문서의 `head` 섹션에 배치하기 위해 예약되어 있어요. React에서는 앱에 적합한 메타데이터를 결정하는 컴포넌트가 `head`를 렌더링하는 곳과 매우 먼 곳에 있을 수 있거나 React가 `head`를 전혀 렌더링하지 않을 수도 있어요. 과거에는 이러한 요소들을 수동으로 삽입해야 했거나 react-helmet과 같은 라이브러리를 사용하여 효과적으로 처리해야 했던 것을 기억하시죠.\n\nReact 19는 컴포넌트에서 문서 메타데이터 태그를 네이티브로 렌더링하는 지원을 제공해요:\n\n```js\nfunction BlogPost({post}) {\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <title>{post.title}</title>\n      <meta name=\"author\" content=\"Josh\" />\n      <link rel=\"author\" href=\"https://twitter.com/joshcstory/\" />\n      <meta name=\"keywords\" content={post.keywords} />\n      <p>\n        Eee equals em-see-squared...\n      </p>\n    </article>\n  );\n}\n```\n\nReact가 이 컴포넌트를 렌더링할 때 `title`, `link`, `meta` 태그를 찾아서 자동으로 문서의 `head` 섹션으로 끌어올려 줘요. 이러한 메타데이터 태그를 네이티브로 지원함으로써 클라이언트 전용 앱, 스트리밍 SSR 및 서버 컴포넌트와 함께 작동하도록 보장할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\nReact 19 업데이트 내용에 대한 의견이 궁금하신가요? React 19의 개선된 기능에 대한 자세한 내용은 React 공식 블로그의 원문을 참조해주세요.\n\n# 간단하게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작성자를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png"},"coverImage":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png","tag":["Tech"],"readingTime":11},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\",\n    h1: \"h1\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지난 2022년 6월 React의 마지막 안정 버전 이후, 두 년 가까이 새 버전이 나오지 않았는데, 이제 npm에서 React 19 베타판이 안정 버전인 React 18.3.0과 함께 공개되었습니다. React 19 베타판에서 개발자들이 알아야 할 새로운 기능을 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"액션\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트 앱에서 흔히 발생하는 사용 사례는 데이터 변이를 수행한 다음 응답에 따라 상태를 업데이트하는 것입니다. 예를 들어, 사용자가 이름을 변경하기 위해 양식을 제출하면 API 요청을 만들고 그 다음 응답을 처리해야 합니다. 과거에는 보류 중인 상태, 오류, 낙관적 업데이트 및 순차 요청을 수동으로 처리해야 했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, useState로 대기 및 오류 상태를 처리할 수 있었습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 액션 이전\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"UpdateName\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [name, setName] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [error, setError] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [isPending, setIsPending] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handleSubmit\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") => {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setIsPending\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" error = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"updateName\"\n        }), \"(name);\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setIsPending\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (error) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setError\"\n        }), \"(error);\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \";\\n    } \\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"redirect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/경로\\\"\"\n        }), \");\\n  };\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"value\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{name}\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onChange\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{(event)\"\n            }), \" =>\"]\n          }), \" setName(event.target.value)} />\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{handleSubmit}\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"disabled\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{isPending}\"\n            }), \">\"]\n          }), \"\\n        업데이트\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \">\"]\n          }), \"\\n      {error && \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"{error}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"}\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트 19에서는 전이에 비동기 함수를 사용하여 대기 중인 상태, 오류, 양식 및 낙관적 업데이트를 자동으로 처리할 수 있는 지원이 추가되었습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, useTransition을 사용하여 대기 상태를 처리할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Actions에서 대기 상태 사용하기\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"UpdateName\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [name, setName] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [error, setError] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [isPending, startTransition] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useTransition\"\n        }), \"();\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handleSubmit\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") => {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"startTransition\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" () => {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" error = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"updateName\"\n        }), \"(name);\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (error) {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setError\"\n        }), \"(error);\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \";\\n      } \\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"redirect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/path\\\"\"\n        }), \");\\n    })\\n  };\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"value\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{name}\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onChange\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{(event)\"\n            }), \" =>\"]\n          }), \" setName(event.target.value)} />\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{handleSubmit}\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"disabled\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{isPending}\"\n            }), \">\"]\n          }), \"\\n        Update\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \">\"]\n          }), \"\\n      {error && \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"{error}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"}\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"비동기 전환은 즉시 isPending 상태를 true로 설정하고 비동기 요청을 수행한 다음 이전 전환 후에 isPending를 false로 전환합니다. 이렇게 하면 데이터가 변경되는 동안에도 현재 UI를 반응적이고 상호작용할 수 있게 유지할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"관례적으로, 비동기 전환을 사용하는 함수는 \\\"Actions\\\"라고 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"동작은 데이터 제출을 자동으로 처리해줍니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"보류 상태: 동작은 요청의 시작부터 시작되는 보류 상태를 제공하며, 최종 상태 업데이트가 완료될 때 자동으로 재설정됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"낙관적 업데이트: 동작은 새로운 useOptimistic 훅을 지원하여 요청이 제출되는 동안 사용자에게 즉시 피드백을 제공할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"오류 처리: 동작은 오류 처리를 제공하여 요청이 실패했을 때 오류 경계를 표시하고, 낙관적 업데이트를 자동으로 원래 값으로 되돌립니다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"폼: 이제 \", _jsx(_components.code, {\n          children: \"form\"\n        }), \" 요소는 동작과 formAction props에 함수를 전달할 수 있습니다. action props에 함수를 전달하면 기본적으로 동작을 사용하고 제출 후 자동으로 폼을 재설정합니다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"React 19에서 동작을 기반으로하면 낙관적 업데이트를 관리하는 useOptimistic 및 동작의 공통 사례를 처리하는 새로운 hook인 React.useActionState를 도입했습니다. react-dom에서는 \", _jsx(_components.code, {\n        children: \"form\"\n      }), \" 동작을 사용하여 폼을 자동으로 처리하고, 동작의 공통 사례를 지원하는 useFormStatus를 추가했습니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 19에서 위 예제는 간단하게 변경될 수 있습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// <form> 작업 및 useActionState 사용하기\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ChangeName\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{ name, setName }\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [error, submitAction, isPending] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useActionState\"\n        }), \"(\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (previousState, formData) => {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" error = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"updateName\"\n        }), \"(formData.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \"));\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (error) {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" error;\\n      }\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"redirect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/path\\\"\"\n        }), \");\\n    }\\n  );\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"form\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"action\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{submitAction}\"\n            }), \">\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"text\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"name\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"name\\\"\"\n            }), \" />\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"submit\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"disabled\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{isPending}\"\n            }), \">\"]\n          }), \"업데이트\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \">\"]\n          }), \"\\n      {error && \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"{error}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"}\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"form\"\n            }), \">\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"새로운 훅: useActionState\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 19에서 일반적인 케이스를 보다 쉽게 만들기 위해 useActionState라는 새로운 훅이 추가되었습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [error, submitAction, isPending] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useActionState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (previousState, newName) => {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" error = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"updateName\"\n        }), \"(newName);\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (error) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 작업의 결과로 어떤 것이든 반환할 수 있습니다.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 여기서는 오직 에러만 반환합니다.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" error;\\n  }\\n  \\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 성공 처리\"\n        }), \"\\n});\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"useActionState\"\n      }), \" 함수는 함수(액션)를 인수로 받아 감싼 액션을 호출합니다. 이는 액션이 조합되기 때문에 작동합니다. 감싼 액션이 호출되면 \", _jsx(_components.code, {\n        children: \"useActionState\"\n      }), \"는 액션의 마지막 결과를 데이터로 반환하고 액션의 보류 상태를 보류로 반환합니다.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"React DOM: form 액션\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"React 19의 새로운 \", _jsx(_components.code, {\n        children: \"form\"\n      }), \" 기능에 액션도 통합되어 있습니다. \", _jsx(_components.code, {\n        children: \"form\"\n      }), \", \", _jsx(_components.code, {\n        children: \"input\"\n      }), \", 그리고 \", _jsx(_components.code, {\n        children: \"button\"\n      }), \" 엘리먼트의 액션과 formAction 프롭으로 함수를 전달하여 액션과 함께 자동으로 폼을 제출할 수 있습니다:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"<form action={actionFunction}>\\n\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"form\"\n      }), \"이 성공하면 React는 제어되지 않는 컴포넌트를 위해 자동으로 \", _jsx(_components.code, {\n        children: \"form\"\n      }), \"을 재설정합니다. \", _jsx(_components.code, {\n        children: \"form\"\n      }), \"을 수동으로 재설정해야 하는 경우, 새 요청 \", _jsx(_components.code, {\n        children: \"form\"\n      }), \" 재설정 React DOM API를 호출할 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"React DOM: 새로운 훅: useFormStatus\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"디자인 시스템에서 \", _jsx(_components.code, {\n        children: \"form\"\n      }), \"에 대한 정보에 액세스해야 하는 디자인 컴포넌트를 작성하는 것이 일반적입니다. 그러나 컴포넌트로 속성을 전달 받지 않아도 되도록 하는 경우가 있습니다. 이 작업은 Context를 통해 수행할 수 있지만, 일반적인 경우를 쉽게 만들기 위해 React 19에 새로운 훅인 useFormStatus가 추가되었습니다:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {useFormStatus} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react-dom'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"DesignButton\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" {pending} = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useFormStatus\"\n        }), \"();\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"submit\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"disabled\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{pending}\"\n            }), \" />\"]\n          })\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"useFormStatus\"\n      }), \"는 부모 \", _jsx(_components.code, {\n        children: \"form\"\n      }), \"의 상태를 읽어오는 것처럼 동작하여, 마치 form이 Context 제공자인 것처럼 사용할 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"새로운 훅: useOptimistic\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"데이터 변경 작업을 수행할 때 또 다른 일반적인 UI 패턴은 비동기 요청 진행 중에 최종 상태를 낙관적으로 표시하는 것입니다. React 19에서는 이를 쉽게 처리할 수 있도록 \", _jsx(_components.code, {\n        children: \"useOptimistic\"\n      }), \"라는 새로운 훅이 추가되었습니다:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ChangeName\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{currentName, onUpdateName}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [optimisticName, setOptimisticName] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useOptimistic\"\n        }), \"(currentName);\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"submitAction\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" formData => {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" newName = formData.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setOptimisticName\"\n        }), \"(newName);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" updatedName = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"updateName\"\n        }), \"(newName);\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"onUpdateName\"\n        }), \"(updatedName);\\n  };\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"form\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"action\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{submitAction}\"\n            }), \">\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"Your name is: {optimisticName}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"label\"\n            }), \">\"]\n          }), \"Change Name:\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"label\"\n            }), \">\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \"\\n          \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"text\\\"\"\n            }), \"\\n          \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"name\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"name\\\"\"\n            }), \"\\n          \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"disabled\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{currentName\"\n            }), \" !== \", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"optimisticName}\"\n            }), \"\\n        />\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"form\"\n            }), \">\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"useOptimistic\"\n      }), \" 훅은 \", _jsx(_components.code, {\n        children: \"updateName\"\n      }), \" 요청이 진행 중일 때 즉시 \", _jsx(_components.code, {\n        children: \"optimisticName\"\n      }), \"을 렌더링합니다. 업데이트가 완료되거나 에러가 발생하면 React가 자동으로 \", _jsx(_components.code, {\n        children: \"currentName\"\n      }), \" 값으로 전환됩니다.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"새 API: use\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"React 19에서 렌더링하는 동안 리소스를 읽기 위한 새로운 API가 추가되었습니다: \", _jsx(_components.code, {\n        children: \"use\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"예를 들어, \", _jsx(_components.code, {\n        children: \"use\"\n      }), \"로 프로미스를 읽을 수 있으며, React가 프로미스가 해결될 때까지 일시 중단됩니다:\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {use} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Comments\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{commentsPromise}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// `use`가 프로미스가 해결될 때까지 일시 중단됩니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" comments = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"use\"\n        }), \"(commentsPromise);\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" comments.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"map\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"comment\"\n          }), \" =>\"]\n        }), \" \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"key\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{comment.id}\"\n            }), \">\"]\n          }), \"{comment}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          })]\n        }), \");\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Page\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{commentsPromise}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Comments에서 `use`가 일시 중단되면\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 이 Suspense 경계가 표시됩니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Suspense\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"fallback\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{\"\n            }), \"<\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"div\"\n            }), \">\"]\n          }), \"Loading...\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          }), \"}>\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Comments\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"commentsPromise\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{commentsPromise}\"\n            }), \" />\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Suspense\"\n            }), \">\"]\n          })]\n        }), \"\\n  )\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"렌더링되는 동안 생성된 프로미스를 지원하지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"렌더링에서 만든 프로미스를 use에 전달하려고 하면 React에서 경고합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수정하려면, 프로미스 캐싱을 지원하는 suspense 기반 라이브러리나 프레임워크에서 프로미스를 전달해야 합니다. 미래에는 렌더링 중에 프로미스를 캐싱하기 쉽게 만드는 기능을 제공할 예정입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 일찍 반환한 후와 같이 조건부로 Context를 읽을 수도 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {use} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ThemeContext\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./ThemeContext'\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Heading\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{children}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (children == \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \";\\n  }\\n  \\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 일찍 반환으로 인해 useContext로 동작하지 않습니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" theme = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"use\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ThemeContext\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"style\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{{color:\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"theme.color\"\n            }), \"}}>\"]\n          }), \"\\n      {children}\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \">\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"use API는 후크와 유사하게 렌더링 중에만 호출될 수 있습니다. 후크와는 다르게 use는 조건부로 호출할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자세한 정보는 use에 대한 문서를 참조하세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"ref을 속성으로 사용하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 19부터 함수 컴포넌트에서 ref를 속성으로 접근할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MyInput\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{placeholder, ref}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"placeholder\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{placeholder}\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"ref\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{ref}\"\n            }), \" />\"]\n          })\n        }), \"\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//...\"\n        }), \"\\n<\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MyInput\"\n        }), \" ref={ref} />\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새로운 함수 컴포넌트는 더 이상 forwardRef가 필요하지 않습니다. 향후 버전에서 React는 forwardRef를 사용하지 않도록 하고 제거할 예정입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"'Context'를 제공자로 렌더링하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 19에서 'Context.Provider' 대신 'Context'를 제공자로 렌더링할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ThemeContext\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"createContext\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"App\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{children}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"ThemeContext\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"value\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"dark\\\"\"\n            }), \">\"]\n          }), \"\\n      {children}\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"ThemeContext\"\n            }), \">\"]\n          })]\n        }), \"\\n  );  \\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"나중에 React 버전에서는 'Context.Provider'를 사용하지 않도록 지원 중단될 예정입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"ref에 대한 정리 함수\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 React는 ref 콜백에서 정리 함수를 반환하는 것을 지원합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"<input\\n  ref={\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"ref\"\n          }), \") =>\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ref 생성\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 새로운 기능: 요소가 DOM에서 제거될 때 ref를 재설정하는 정리 함수를 반환합니다.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =>\"\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ref 정리\"\n        }), \"\\n    };\\n  }\\n/>\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컴포넌트가 언마운트될 때, React는 ref 콜백에서 반환된 정리 함수를 호출합니다. 이는 DOM ref, 클래스 컴포넌트에 대한 ref 및 useImperativeHandle에 대해 작동합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리팩토링된 ref 정리 함수의 도입으로 인해 TypeScript에서 ref 콜백에서 다른 값을 반환하면 거부됩니다. 이 문제를 해결하는 방법은 일반적으로 암시적 반환을 사용하지 않도록 하는 것입니다. 예를 들어:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"- \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"ref\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{current\"\n            }), \" =>\"]\n          }), \" (instance = current)} />\"]\n        }), \"\\n+ \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"ref\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{current\"\n            }), \" =>\"]\n          }), \" {instance = current} />\"]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원본 코드는 HTMLDivElement의 인스턴스를 반환했으며 TypeScript는 이것이 정리 함수인지 아니면 정리 함수를 반환하고 싶지 않은 것인지를 알 수 없습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"useDeferredValue 초기 값\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React는 useDeferredValue에 initialValue 옵션을 추가했습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Search\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{deferredValue}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 초기 렌더링 시 값은 ''입니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 그런 다음 다시 렌더링이 예약되고 deferredValue로 업데이트됩니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" value = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useDeferredValue\"\n        }), \"(deferredValue, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \");\\n  \\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Results\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"query\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{value}\"\n            }), \" />\"]\n          })\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"initialValue가 제공되면 useDeferredValue는 해당 값을 컴포넌트의 초기 렌더링에 반환하고, deferredValue를 사용하여 백그라운드에서 다시 렌더링을 예약합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"문서 메타데이터 지원\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"HTML에서는 \", _jsx(_components.code, {\n        children: \"title\"\n      }), \", \", _jsx(_components.code, {\n        children: \"link\"\n      }), \", \", _jsx(_components.code, {\n        children: \"meta\"\n      }), \"와 같은 문서 메타데이터 태그를 문서의 \", _jsx(_components.code, {\n        children: \"head\"\n      }), \" 섹션에 배치하기 위해 예약되어 있어요. React에서는 앱에 적합한 메타데이터를 결정하는 컴포넌트가 \", _jsx(_components.code, {\n        children: \"head\"\n      }), \"를 렌더링하는 곳과 매우 먼 곳에 있을 수 있거나 React가 \", _jsx(_components.code, {\n        children: \"head\"\n      }), \"를 전혀 렌더링하지 않을 수도 있어요. 과거에는 이러한 요소들을 수동으로 삽입해야 했거나 react-helmet과 같은 라이브러리를 사용하여 효과적으로 처리해야 했던 것을 기억하시죠.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 19는 컴포넌트에서 문서 메타데이터 태그를 네이티브로 렌더링하는 지원을 제공해요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"BlogPost\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{post}\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"article\"\n            }), \">\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \">\"]\n          }), \"{post.title}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \">\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"title\"\n            }), \">\"]\n          }), \"{post.title}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"title\"\n            }), \">\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"meta\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"name\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"author\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"content\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"Josh\\\"\"\n            }), \" />\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"link\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"rel\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"author\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"https://twitter.com/joshcstory/\\\"\"\n            }), \" />\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"meta\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"name\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"keywords\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"content\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{post.keywords}\"\n            }), \" />\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"\\n        Eee equals em-see-squared...\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"article\"\n            }), \">\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"React가 이 컴포넌트를 렌더링할 때 \", _jsx(_components.code, {\n        children: \"title\"\n      }), \", \", _jsx(_components.code, {\n        children: \"link\"\n      }), \", \", _jsx(_components.code, {\n        children: \"meta\"\n      }), \" 태그를 찾아서 자동으로 문서의 \", _jsx(_components.code, {\n        children: \"head\"\n      }), \" 섹션으로 끌어올려 줘요. 이러한 메타데이터 태그를 네이티브로 지원함으로써 클라이언트 전용 앱, 스트리밍 SSR 및 서버 컴포넌트와 함께 작동하도록 보장할 수 있어요.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 19 업데이트 내용에 대한 의견이 궁금하신가요? React 19의 개선된 기능에 대한 자세한 내용은 React 공식 블로그의 원문을 참조해주세요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"간단하게 설명하기 🚀\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"작성자를 클랩하고 팔로우해주세요 ️👏️️\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}