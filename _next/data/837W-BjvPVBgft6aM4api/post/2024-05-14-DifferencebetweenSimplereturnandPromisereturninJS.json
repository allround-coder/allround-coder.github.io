{"pageProps":{"post":{"title":"자바스크립트에서 간단한 반환과 프로미스 반환의 차이","description":"","date":"2024-05-14 12:53","slug":"2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS","content":"\n\n자바스크립트에서 단순 반환과 프로미스 반환은 서로 다른 목적을 가지고 있어요.\n\n## 단순 반환:\n\n함수에서 값을 직접 반환할 때, 이는 동기 작업입니다. 함수가 실행되고 결과를 즉시 반환해요.\n\n![이미지](/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png)\n\n\n\n## 아래는 코드 분석입니다:\n\n1. 함수 정의: 두 개의 매개변수 a와 b를 받는 add라는 함수를 정의합니다.\n\n2. 반환문: add 함수 내에서 a와 b의 합을 반환하는 return a + b;를 사용합니다.\n\n3. 함수 호출: 그런 다음 매개변수 10과 20을 사용하여 add 함수를 호출합니다.\n\n\n\n4. 결과 저장: 반환된 값(10과 20의 합인 30)이 result 변수에 저장됩니다.\n\n5. 출력: 마지막으로, 우리는 결과값 30을 콘솔에 출력합니다.\n\n단순하고 동기적입니다. 함수는 값을 즉시 반환합니다.\n\n# Promise Return:\n\n\n\nPromise는 비동기 작업에 사용됩니다. 지금이나 미래에 사용할 수 있는 값이나 결코 사용할 수 없는 값을 나타냅니다. 함수가 Promise를 반환하면 비동기 작업을 수행하고 그 작업의 결과에 따라 Promise를 해결하거나 거부할 수 있습니다.\n\n![Promise Image](/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_1.png)\n\n이 코드에서:\n\n- reject()에 new Error(\"Strings are not equal\")를 인수로 추가하여 오류에 대한 자세한 정보를 제공했습니다.\n- catch 블록에서 (error)를 콜백 함수의 인수로 추가하여 오류 객체를 캐치하고 해당 메시지를 기록했습니다.\n\n\n\n이제 코드가 오류 없이 실행되고 적절한 출력을 제공해야 합니다. str1과 str2가 동일한 경우 \"Success message. Both names are equal.\"을 출력합니다. 그 외에는 \"Error: Strings are not equal\"을 출력합니다.\n\n## 차이점:\n\n실행 컨텍스트:\n\n- 간단한 반환: 동기적으로 실행됨.\n- Promise 반환: 비동기 실행을 허용함.\n\n\n\n비동기 작업 다루기:\n\n- Simple return: 비동기 작업을 처리할 수 없습니다.\n- Promise return: 특별히 비동기 작업을 처리하기 위해 설계되었습니다.\n\n사용 방법:\n\n- Simple return: 동기 작업에 사용됩니다.\n- Promise return: 비동기 작업에 사용됩니다.","ogImage":{"url":"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png"},"coverImage":"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png","tag":["Tech"],"readingTime":2},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    img: \"img\",\n    ol: \"ol\",\n    li: \"li\",\n    h1: \"h1\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"자바스크립트에서 단순 반환과 프로미스 반환은 서로 다른 목적을 가지고 있어요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단순 반환:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"함수에서 값을 직접 반환할 때, 이는 동기 작업입니다. 함수가 실행되고 결과를 즉시 반환해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"아래는 코드 분석입니다:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"함수 정의: 두 개의 매개변수 a와 b를 받는 add라는 함수를 정의합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"반환문: add 함수 내에서 a와 b의 합을 반환하는 return a + b;를 사용합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"함수 호출: 그런 다음 매개변수 10과 20을 사용하여 add 함수를 호출합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"결과 저장: 반환된 값(10과 20의 합인 30)이 result 변수에 저장됩니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"출력: 마지막으로, 우리는 결과값 30을 콘솔에 출력합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단순하고 동기적입니다. 함수는 값을 즉시 반환합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Promise Return:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Promise는 비동기 작업에 사용됩니다. 지금이나 미래에 사용할 수 있는 값이나 결코 사용할 수 없는 값을 나타냅니다. 함수가 Promise를 반환하면 비동기 작업을 수행하고 그 작업의 결과에 따라 Promise를 해결하거나 거부할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_1.png\",\n        alt: \"Promise Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드에서:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"reject()에 new Error(\\\"Strings are not equal\\\")를 인수로 추가하여 오류에 대한 자세한 정보를 제공했습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"catch 블록에서 (error)를 콜백 함수의 인수로 추가하여 오류 객체를 캐치하고 해당 메시지를 기록했습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 코드가 오류 없이 실행되고 적절한 출력을 제공해야 합니다. str1과 str2가 동일한 경우 \\\"Success message. Both names are equal.\\\"을 출력합니다. 그 외에는 \\\"Error: Strings are not equal\\\"을 출력합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"차이점:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실행 컨텍스트:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"간단한 반환: 동기적으로 실행됨.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Promise 반환: 비동기 실행을 허용함.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"비동기 작업 다루기:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Simple return: 비동기 작업을 처리할 수 없습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Promise return: 특별히 비동기 작업을 처리하기 위해 설계되었습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용 방법:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Simple return: 동기 작업에 사용됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Promise return: 비동기 작업에 사용됩니다.\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}