{"pageProps":{"post":{"title":"오픈 소스로부터 배운 JavaScript의 제너레이터 함수 팁","description":"","date":"2024-05-12 21:10","slug":"2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript","content":"\n\nNext.js 소스 코드를 읽다가 *로 접두사가 붙은 함수 이름을 본 적이 있어요. 제 첫 생각은 \"이거 Javascript에서 포인터인가?\" 였어요. 구글 검색을 해보니 *로 접두사가 붙은 이 함수들은 제너레이터 함수라고 불린다는 걸 알았어요. 지금까지는 Javascript에서 제너레이터 함수에 대해 알지 못했어요.\n\nNext.js 소스 코드에는 아래와 같이 클래스 내에서 정의된 제너레이터 함수가 있어요:\n\n![이미지](/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_0.png)\n\n일반적으로 이런 제너레이터 함수를 클래스 바깥에서 정의할 때는 다음과 같은 구문을 사용해요:\n\n\n\n```js\n// 출처: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\nfunction* generator(i) {\n  yield i;\n  yield i + 10;\n  yield i + 20;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\n// 예상 출력: 10\nconsole.log(gen.next().value);\n// 예상 출력: 20\nconsole.log(gen.next().value);\r\n```\n\n# Keys() as a generator function\n\n```js\npublic *keys(): IterableIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n```\n\n이 코드 스니펫은 Next.js 소스 코드의 header.ts에서 가져온 것입니다. \"keys() 함수가 제너레이터 함수인 이유는 무엇일까?\" 라는 질문을 내 자신에게 했습니다.\n\n\n\n저는 ChatGPT에 이 코드를 붙여 넣었더니 \"메모리 효율성\"이라는 용어를 소개해 주었어요. 잠깐만, 어떻게 그런 걸까요?\n\n아래 코드를 복사해서 브라우저에 붙여넣어 보세요.\n\n```js\nconst exampleObject = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  age: 30\n};\n\n// 제너레이터 함수를 사용하여 keys() 메서드 구현하기\nexampleObject.keys = function* () {\n  for (const key in this) {\n    yield key;\n  }\n};\n\n// 이제 exampleObject의 키를 for...of 루프를 사용하여 반복할 수 있습니다.\nfor (const key of exampleObject.keys()) {\n  console.log(key);\n}\n\n// 결과:\nfirstName\nVM247:16 lastName\nVM247:16 age\nVM247:16 keys\n```\n\n하지만 keys()를 출력하려고 하면 다음과 같은 결과가 나타납니다:\n\n\n\n<img src=\"/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_1.png\" />\n\n한 번에 모든 키를 생성하고 배열에 저장하는 대신, 제너레이터 함수는 필요할 때 키를 즉석에서 생성합니다.\n\n# 더 많은 읽을거리 링크:\n\n- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*\n- https://stackoverflow.com/questions/47027191/do-suspended-generator-functions-have-performance-costs\n\n\n\n# 결론:\n\n`function* keys()`은 포인터가 아닌 제너레이터 함수임을 알게 되었습니다. 원하는 시점에 키, 엔트리, 값 등을 생성할 때 사용합니다.\n\n제너레이터 함수는 실행 시간을 소비하지 않으며 사용될 때까지 메모리에 남아 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_0.png"},"coverImage":"/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Next.js 소스 코드를 읽다가 *로 접두사가 붙은 함수 이름을 본 적이 있어요. 제 첫 생각은 \\\"이거 Javascript에서 포인터인가?\\\" 였어요. 구글 검색을 해보니 *로 접두사가 붙은 이 함수들은 제너레이터 함수라고 불린다는 걸 알았어요. 지금까지는 Javascript에서 제너레이터 함수에 대해 알지 못했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next.js 소스 코드에는 아래와 같이 클래스 내에서 정의된 제너레이터 함수가 있어요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일반적으로 이런 제너레이터 함수를 클래스 바깥에서 정의할 때는 다음과 같은 구문을 사용해요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출처: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \"* \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"generator\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"i\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"yield\"\n        }), \" i;\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"yield\"\n        }), \" i + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"yield\"\n        }), \" i + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"20\"\n        }), \";\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" gen = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"generator\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(gen.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 예상 출력: 10\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(gen.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 예상 출력: 20\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(gen.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Keys() as a generator function\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"public *\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"keys\"\n        }), \"(): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IterableIterator\"\n        }), \"<string> {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" key \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"of\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Object\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"keys\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"headers\"\n        }), \")) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" name = key.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toLowerCase\"\n        }), \"()\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"yield\"\n        }), \" name\\n    }\\n  }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드 스니펫은 Next.js 소스 코드의 header.ts에서 가져온 것입니다. \\\"keys() 함수가 제너레이터 함수인 이유는 무엇일까?\\\" 라는 질문을 내 자신에게 했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 ChatGPT에 이 코드를 붙여 넣었더니 \\\"메모리 효율성\\\"이라는 용어를 소개해 주었어요. 잠깐만, 어떻게 그런 걸까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래 코드를 복사해서 브라우저에 붙여넣어 보세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" exampleObject = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"firstName\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"lastName\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Doe\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"30\"\n        }), \"\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 제너레이터 함수를 사용하여 keys() 메서드 구현하기\"\n        }), \"\\nexampleObject.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"keys\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \"* () {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" key \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"yield\"\n        }), \" key;\\n  }\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 이제 exampleObject의 키를 for...of 루프를 사용하여 반복할 수 있습니다.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" key \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"of\"\n        }), \" exampleObject.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"keys\"\n        }), \"()) {\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(key);\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과:\"\n        }), \"\\nfirstName\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VM247\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \" lastName\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VM247\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \" age\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VM247\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \" keys\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 keys()를 출력하려고 하면 다음과 같은 결과가 나타납니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한 번에 모든 키를 생성하고 배열에 저장하는 대신, 제너레이터 함수는 필요할 때 키를 즉석에서 생성합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"더 많은 읽을거리 링크:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"https://stackoverflow.com/questions/47027191/do-suspended-generator-functions-have-performance-costs\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"function* keys()\"\n      }), \"은 포인터가 아닌 제너레이터 함수임을 알게 되었습니다. 원하는 시점에 키, 엔트리, 값 등을 생성할 때 사용합니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제너레이터 함수는 실행 시간을 소비하지 않으며 사용될 때까지 메모리에 남아 있습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}