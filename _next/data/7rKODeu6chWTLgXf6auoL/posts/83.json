{"pageProps":{"posts":[{"title":"2024년 최신 React Native Expo용 보일러플레이트 라이브러리","description":"","date":"2024-05-12 19:16","slug":"2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024","content":"\n지금은 2024년입니다. 프로그래밍에서는 항상 우리가 선택할 수 있는 최신하이팅 라이브러리들이 있지만, 최신하이팅 라이브러리들이 항상 완벽하지는 않습니다.\n\n여러 해 전에 웹 개발자로써, 저는 네이티브 앱을 어떻게 시작할지 완전히 이해하지 못했습니다. 이 블로그에서는 나의 선택한 라이브러리들과 함께 새로운 React Native/Expo 앱을 어떻게 만들 것인지 보여드리겠습니다. React Native에서 새로운 개발자이며 시작점을 모르는 경우, 이 블로그가 도움이 될 것입니다.\n\n# Component Library\n\nReact Native 컴포넌트 라이브러리 중 인기 있는 것들은:\n\n- react-native-paper\n- react-native-elements\n- gluestack\n\nNpm trends: [https://npmtrends.com/native-base-vs-react-native-elements-vs-react-native-paper](https://npmtrends.com/native-base-vs-react-native-elements-vs-react-native-paper)\n\n![Image](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_0.png)\n\n이 모든 라이브러리들은 테마를 적용할 수 있고, 좋은 접근성 지원이 가능하며, 좋은 문서와 유사한 구성 요소 세트를 제공합니다.\n\n## 리액트 네이티브 엘리먼츠\n\n이 블로그를 작성하는 시점에서, 리액트 네이티브 엘리먼츠가 가장 많은 컴포넌트를 제공하고 있어요. 하지만, AirbnbRating, PricingCard 또는 SocialIcon 같은 몇몇 컴포넌트는 제 프로젝트에서 사용할 일이 없어 보여요.\n\n<img src=\"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_1.png\" />\n\n하지만, 이 라이브러리는 가장 유연한 테마 설정을 제공하는 것 같아요. 이 라이브러리를 사용하면 개발자들이 각 컴포넌트 유형에 맞게 테마를 사용자 정의할 수 있어요: https://reactnativeelements.com/docs/customizing#using-themeprovider.\n\n```js\nconst theme = createTheme({\n  components: {\n    [themeKey]: {\n      // ... props\n    },\n  },\n});\n```\n\n## react-native-paper\n\nreact-native-paper는 구글의 머티리얼 디자인을 따릅니다. 만약 머티리얼 디자인을 사용하는 웹사이트가 있다면, react-native-paper가 일관성을 제공해줍니다.\n\n<img src=\"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_2.png\" />\n```\n\n## gluestack\n\ngluestack은 유틸리티 우선이에요. 이 말은 컴포넌트가 마진, marginTop, fontFamily와 같은 props를 가지고 있는 것을 의미해요. 반면에 react-native-paper와 react-native-elements는 하나의 스타일 prop만 사용해요.\n\n예를 들어, React Native에서 컴포넌트를 스타일링하기 위해 스타일 시트를 생성해야 해요:\n\n```js\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: \"#0891b2\",\n    paddingVertical: 16,\n    paddingHorizontal: 12,\n    borderRadius: 5,\n    alignSelf: \"center\",\n    width: 375,\n    maxWidth: \"100%\",\n  },\n});\n```\n\n그럼 컴포넌트에 스타일을 적용해야 해요: `View style='styles.topContainer'`.\n\n네이티브 베이스에서는 해당 컴포넌트의 속성에 간단히 추가할 수 있어요: `Box bg=\"primary.600\" py=\"4\" px=\"3\" borderRadius=\"5\" rounded=\"md\" width='375' maxWidth=\"100%\"`.\n\n## 제 의견 기반\n\n- react-native-paper\n\n새로운 프로젝트를 처음부터 시작하려는 신입 개발자라면, npm 다운로드 수가 가장 많아 커뮤니티가 크고, 웹에서 쉽게 사용할 수 있다는 이유로 react-native-paper를 선택할 것입니다.\n\n# CSS 유틸리티\n\nCSS 유틸리티 라이브러리는 flex, pt-4, text-center, rotate-90과 같은 미리 정의된 CSS 클래스 목록을 제공합니다.\n\n위에서 언급된 native-base는 유틸리티 중심 스타일링에 대해 언급되었습니다; 그러나 React Native용 tailwind나 tachyons와 유사한 CSS 유틸리티 라이브러리가 있을까요? 네, 있습니다.\n\n나 이전에 사용한 라이브러리들은:\n\n- Native Wind\n- react-native-style-tachyons\n\nNpm trends: [https://npmtrends.com/nativewind-vs-react-native-style-tachyons](https://npmtrends.com/nativewind-vs-react-native-style-tachyons)\n\n![이미지](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_3.png)\n\n## 내 주관적인 선택\n\n- 소규모 프로젝트: 내장 스타일링, 라이브러리 사용하지 않음\n- 대규모 프로젝트: Native Wind\n\n소규모 프로젝트의 경우 내장 스타일링이 충분할 것입니다. 대규모 프로젝트의 경우, 팀원들이 이미 Tailwind에 익숙하다면 Native Wind를 선택할 것입니다. 저는 이미 Tailwind 라이브러리에 익숙하며, 네이티브 프로젝트에 이 라이브러리를 사용하기 시작하는 것이 꽤 쉬웠습니다.\n\n# 네비게이션\n\n인기 있는 선택지는 다음과 같습니다:\n\n- react-router-native\n- @react-navigation/native\n- expo-router (Expo 전용)\n\nNpm trends: https://npmtrends.com/@react-navigation/native-vs-expo-router-vs-react-router-native\n\n![이미지](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_4.png)\n\n엑스포 전용 라이브러리로 expo-router가 있습니다. 이는 파일 기반 라우팅 규칙으로, Next.js를 떠올리게 합니다.\n\nReact 웹 개발자이면 아마 react-router에 익숙할 것입니다. 이의 네이티브 버전인 react-router-native도 있지만, 널리 사용되지는 않습니다.\n\n## 제 개인적인 선택\n\n- @react-navigation/native\n\n이 라이브러리는 이제 React-Native 네비게이션을 위한 주요 라이브러리로 거의 사용되고 있어요.\n\n# 상태 관리\n\n상태 관리를 위해 선택할 수 있는 라이브러리가 더 많이 있거나 라이브러리를 전혀 사용하지 않을 수도 있어요. 인기 있는 라이브러리는 다음과 같아요:\n\n- Redux\n- TanStack Query (또는 React Query로 더 잘 알려져 있어요)\n- Redux Toolkit Query (또는 RTK Query로 더 잘 알려져 있어요)\n- React Context (내장되어 있어 라이브러리가 필요하지 않아요)\n- MobX\n- Jotai\n- Recoil\n- XState\n\nNpm trends: https://npmtrends.com/@tanstack/react-query-vs-@xstate/react-vs-jotai-vs-mobx-vs-react-redux-vs-recoil\n\n![Screenshot](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_5.png)\n\n## 내 주관적인 선택\n\n- 친숙한 올드 Redux + TansSack Query\n\n이 두 개는 가장 인기 있는 것들 중 하나이고 많은 해 동안 사용되었습니다. 그것들은 방탄이며 개발자 커뮤니티도 넓게 보유하고 있어요.\n\nRedux와 Transack Query를 사용한 상태 관리하는 방법에 대한 나의 블로그 포스트를 확인해보세요:\n\n# Monorepo\n\n모노레포란 무엇인가요?\n\n여러 개의 React Native 앱이 필요하거나 웹 및 네이티브 앱 간에 공통 로직을 공유해야 한다면, 모노 저장소는 좋은 도구가 될 것입니다.\n\n이는 인기 있는 선택지들 중 하나로, 여기에는 다음이 포함됩니다:\n\n- yarn workspace\n- Lerna\n- Turborepo\n- @nx/react-native / @nxl/expo\n\n내 주관적인 의견은 @nx/react-native / @nx/expo입니다.\n\n내용을 표 기호(Markdown format)로 변경하면 아래와 같습니다.\n\nFor yarn workspace and Lerna, developers need to do their configuration and setup. Turborepo provides a starter app; however, it is locked to the Expo and Next.js tech stack; if developers want to use a different tech stack, they still need to do their configuration.\n\nFor new developers, @x/react-native and @nx/expo provide a good developer experience and documentation to start; nevertheless, it still gives developers flexibility on the tech stack. To start, run this command:\n\n```\n# react-native\nnpx create-nx-workspace --preset=react-native\n\n# expo\nnpx create-nx-workspace --preset=expo\n```\n\n# Summary\n\n새로운 React Native / Expo 앱을 만들 때 선택할 수 있는 라이브러리 목록입니다. 이 리스트는 유일한 선택지는 아닙니다.\n\n아름다운 React Native 앱을 만들어 봅시다.\n\n- 공식 @nx/expo 플러그인: https://nx.dev/packages/expo\n- 공식 @nx/react-native 플러그인: https://nx.dev/packages/react-native\n\n# 더 알아보기\n\n- 🧠 Nx 문서\n- 👩‍💻 Nx GitHub\n- 💬 Nx 커뮤니티 Slack\n- 📹 Nx 유튜브 채널\n- 🥚 무료 Egghead 강좌\n- 🚀 CI를 빠르게 실행\n","ogImage":{"url":"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_0.png"},"coverImage":"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_0.png","tag":["Tech"],"readingTime":6},{"title":"React에서 JWT 토큰을 로컬 스토리지에 저장하는 방법","description":"","date":"2024-05-12 19:15","slug":"2024-05-12-HowtostoreJWTTokeninLocalStorageforReact","content":"\n\n## 간단히 말해, JWT란 무엇인가요?\n\nJWT은 JSON Web Token의 약자입니다. 이것은 정보를 안전하게 JSON 객체로 파티 간에 전송하는 간결하고 자체 포함된 방법입니다. 웹 개발에서 인증 및 정보 교환에 일반적으로 사용됩니다.\n\n## 프론트엔드용 요약\n\n\n\n백엔드에서 관리되는 암호화된 JSON 객체로, 사용자 계정이 생성되거나 로그인할 때 Frontend로 전송됩니다. 이 토큰을 이용하면 사용자가 웹 서비스의 일부에 대한 권한/접속을 얻을 수 있습니다. 클라이언트 측에서 사용하기 위해 이를 Local storage, 세션 또는 쿠키에 저장할 수 있습니다 (각각에는 고유한 보안 문제가 있으니 더 자세히 알아보세요).\n\n또한 https://jwt.io/를 방문하여 토큰을 해독하고 내용을 확인할 수 있습니다.\n\n## 이 페이지는 이를 로컬 스토리지에 저장하는 내용입니다.\n\n토큰을 사용하면서, 성공적인 로그인 후에 액세스 토큰과 리프레시 토큰을 로컬 스토리지에 저장하려고 했습니다.\n\n\n\n개발자 도구를 열고 `Application -` Local storage를 클릭하면 저장소를 확인할 수 있습니다.\n\n# 실제 코드로 넘어가보겠습니다\n\n## 여기 styled-components를 사용하여 만든 Login.jsx 파일이 있습니다\n\n아직 토큰 기능 설정은 포함되어 있지 않습니다. 요소를 설정하고 Styled-components를 사용하여 스타일을 지정하는 방법의 기본 구조만 보여드립니다.\n\n\n\n만약 이와 같은 라이브러리를 사용한다면, 코드를 더 깔끔하고 효율적으로 작성할 수 있어요! 그러나 이 경우에는 React hook useState만을 사용했어요.\n\n```js\nimport React, { useState } from \"react\";\nimport { styled } from \"styled-components\";\n```\n\n```js\nexport const Login = () => {\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n \n  return (\n    <LoginContainer>\n      <h1>Login</h1>\n      <Form >\n        <label htmlFor=\"email\">Email</label>\n        <Input\n          type=\"email\"\n          id=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n        />\n        <label htmlFor=\"password\">Password</label>\n        <Input\n          type=\"password\"\n          id=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n        />\n        <Button>Login</Button>\n        <button>Logout</button>\n      </Form>\n    </LoginContainer>\n  );\n};\nconst LoginContainer = styled.section`\n  border: 1px solid black;\n  height: 400px;\n  width: 350px;\n  margin: 100px auto;\n  border-radius: 12px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-evenly;\n`;\nconst Form = styled.form`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-evenly;\n  height: 200px;\n`;\nconst Input = styled.input`\n  width: 240px;\n  height: 28px;\n  border-radius: 3px;\n  border-color: rgba(0, 0, 0, 0.2);\n  padding: 3px;\n`;\nconst Button = styled.button`\n  width: 200px;\n  border-color: rgba(0, 0, 0, 0.2);\n  height: 30px;\n  margin-top: 10px;\n  &:hover {\n    cursor: pointer;\n  }\n`;\n```\n\n# 로그인 페이지 스타일링 결과\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtostoreJWTTokeninLocalStorageforReact_0.png\" /> \n\n# handleSubmit 함수 생성\n\nhandleSubmit 함수를 만들어서 로그인 세부 정보를 서버로 전송했습니다(fetch는 아직 사용하지 않았습니다). e.preventDefault()를 사용하면 로그인 버튼을 클릭할 때 페이지가 새로고침되지 않도록 합니다.\n\n```js\nconst handleSubmit = (e) => {\n    e.preventDefault();\n}\n```\n\n\n\n```js\n// JSX\n<Form onSubmit={handleSubmit}>\n```\n\n## (handleSubmit 함수 추가) POST를 사용하여 데이터를 가져오고 헤더를 추가하기\n\n사용자 정보를 가져오기 위해 별도의 requestOptions 변수를 생성했습니다. 사용자 로그인이 성공하면 다음 작업을 수행합니다.\n\n- 사용자 이메일 및 비밀번호 입력 요소를 \" \"으로 초기화합니다.\n- console.log(data)를 사용하여 토큰을 검색합니다.\n- 접근 토큰 및 리프레시 토큰이 가져와졌음을 확인한 후, 구조분해 할당을 사용하여 이를 로컬 스토리지에 저장할 수 있습니다.\n- localStorage.setItem(\"_변수\", _저장값)\n- localStorage.getItem(\"_변수)\n\n\n\n```js\nconst handleSubmit = (e) => {\n    e.preventDefault();\n```\n\n```js\n    const requestOptions = {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        email: email,\n        password: password,\n      }),\n    };\n    fetch(INSERT_API_HERE, requestOptions)\n      .then((response) => response.json())\n      .then((data) => {\n        setEmail(\"\");\n        setPassword(\"\");\n        console.log(data);\n        // note using deconstructuring is better for cleaner code\n        const {access, refresh} = data.access_token;\n        localStorage.setItem(\"accessToken\", access);\n        localStorage.setItem(\"refreshToken\", refresh);\n      });\n    \n  };\n```\n\n마지막으로, CORS 오류와 같은 API 문제가 없다면 토큰이 로컬 스토리지에 저장되는 것을 확인할 수 있습니다. 로컬 스토리지는 브라우저의 개발자 도구를 통해 액세스할 수 있으며 “Application\"으로 이동하여 확인할 수 있습니다.\n\n이제 토큰이 있으므로 무엇을 할 수 있을까요? 영구적 로그인을 설정하거나, 헤더 UI를 사용자에 맞게 변경하거나, 인증된 클라이언트 페이지를 더욱 개선할 수 있습니다. 물론, 새로고침 시 네비게이션 바가 업데이트되지 않는 것을 방지하기 위해 Zustand 또는 Redux와 같은 상태 관리자를 사용하는 것이 좋습니다.```\n\n\n\n당신은 여기에서 나의 persistent login 게시물에 대한 Zustand 설정을 확인할 수 있어요.\n\n# 추가: 로컬 스토리지 초기화\n\n```js\nconst handleLogout = () => {\n    localStorage.removeItem(\"accessToken\");\n    localStorage.removeItem(\"refreshToken\");\n    alert(\"토큰이 제거되었습니다\");\n};\n```\n\n```js\n<button onClick={handleLogout}>로그아웃</button>\n```\n\n\n\n여기에 전체 코드가 있습니다.\n\n```js\nimport React, { useState } from \"react\";\nimport { styled } from \"styled-components\";\nimport { Navigate } from \"react-router-dom\";\n```\n\n```js\nexport const Login = ({ login }) => {\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [navigate, setNavigate] = useState(false);\n  const LOGIN_URL = \"INSERT_YOUR_API\";\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const requestOptions = {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        email: email,\n        password: password,\n      }),\n    };\n    fetch(LOGIN_URL, requestOptions)\n      .then((response) => response.json())\n      .then((data) => {\n        setEmail(\"\");\n        setPassword(\"\");\n        setNavigate(true)\n        // console.log(data);\n        // note using deconstructuring is better for cleaner code\n        const {access, refresh} = data.access_token;\n        localStorage.setItem(\"accessToken\", access);\n        localStorage.setItem(\"refreshToken\", refresh);\n      });\n      \n  };\n  const handleLogout = () => {\n    localStorage.removeItem(\"accessToken\");\n    localStorage.removeItem(\"refreshToken\");\n    alert(\"Tokens have been removed\");\n  };\n  if (navigate) {\n    return <Navigate to=\"/signup\" />;\n  }\n  return (\n    <LoginContainer>\n      <h1>Login</h1>\n      <Form onSubmit={handleSubmit}>\n        <label htmlFor=\"email\">Email</label>\n        <Input\n          type=\"email\"\n          id=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n        />\n        <label htmlFor=\"password\">Password</label>\n        <Input\n          type=\"password\"\n          id=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n        />\n        <Button>Login</Button>\n        <button onClick={handleLogout}>Logout</button>\n      </Form>\n    </LoginContainer>\n  );\n};\nconst LoginContainer = styled.section`\n  border: 1px solid black;\n  height: 400px;\n  width: 350px;\n  margin: 100px auto;\n  border-radius: 12px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-evenly;\n`;\nconst Form = styled.form`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-evenly;\n  height: 200px;\n`;\nconst Input = styled.input`\n  width: 240px;\n  height: 28px;\n  border-radius: 3px;\n  border-color: rgba(0, 0, 0, 0.2);\n  padding: 3px;\n`;\nconst Button = styled.button`\n  width: 200px;\n  border-color: rgba(0, 0, 0, 0.2);\n  height: 30px;\n  margin-top: 10px;\n  &:hover {\n    cursor: pointer;\n  }\n`;\n```","ogImage":{"url":"/assets/img/2024-05-12-HowtostoreJWTTokeninLocalStorageforReact_0.png"},"coverImage":"/assets/img/2024-05-12-HowtostoreJWTTokeninLocalStorageforReact_0.png","tag":["Tech"],"readingTime":7},{"title":"인증 토큰 갱신 및 변경Nodejs, React - 파트 1","description":"","date":"2024-05-12 19:12","slug":"2024-05-12-RefreshAuthTokenRotationNodejsReactPart1","content":"\n\n<img src=\"/assets/img/2024-05-12-RefreshAuthTokenRotationNodejsReactPart1_0.png\" />\n\n요즘은 보안이 점점 중요해지고 있어요. 그래서 우리는 적어도 보안 문제와 팁 및 요령의 기본을 명확히 이해해야 해요. 많은 웹사이트들이 약한 인증을 가지고 있습니다. 심지어 귀하의 애플리케이션이 민감한 정보를 포함하지 않더라도, 단순히 이메일 주소만 가지고 있다 하더라도, 귀하의 사용자를 존중하고 최소한의 보안을 제공해야 해요. 이 글에서는 접근 및 새로 고침 토큰을 사용한 간단한 JWT 토큰 기반 인증 시스템을 보여드릴게요. 우리는 Node.js 백엔드, 프론트엔드에는 React, 그리고 MongoDB를 사용할 거에요. 이 기술들에 익숙하지 않다면, 이에 대해 좀 더 알아보고 시작하기 전에 시간을 내어 숙지해주세요. 그러나 JavaScript 기술과 기본 REST 지식이 있다면, 함께 이를 살펴보고 함께 파헤쳐보아요. :)\n\n우선 Node.js 백엔드를 설정하는 것부터 시작해봅시다. 먼저 Node 애플리케이션을 초기화하세요:\n\n```js\nnpm init\n```\n\n\n\n다음으로, Express를 설치해주세요:\n\n```js\nnpm install express\n```\n\n백엔드에서 사용할 파일 및 폴더 계층 구조는 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-12-RefreshAuthTokenRotationNodejsReactPart1_1.png)\n\n\n\n서버.js 파일을 생성해주세요:\n\n```js\nconst express = require(\"express\");\nconst port = 5000;\nconst app = express();\n\napp.listen(port, () => {\n  console.log(`포트 ${port}에서 서버 실행 중`);\n});\n```\n\n이제 앱을 위한 데이터베이스를 추가해볼까요? MongoDB를 설치하세요. 익숙하지 않다면 유용한 링크가 있습니다.\n\n```js\nnpm install mongoose\n```\n\n\n\n아래와 같이 데이터베이스 연결 파일을 생성해 주세요:\n\n```js\nconst mongoose = require(\"mongoose\");\n\nconst db = mongoose\n  .connect(\"mongodb://127.0.0.1/TokenRotation\") // TokenRotation은 데이터베이스 이름입니다\n  .then(() => console.log(\"MongoDB에 연결되었습니다...\"))\n  .catch((err) => console.error(\"MongoDB에 연결할 수 없습니다...\", err));\n\nmodule.exports = db;\n```\n\n서버의 server.js 파일에 데이터베이스 연결을 추가하는 걸 잊지 마세요:\n\n```js\nconst db = require(\"./dbconnection\");\n```\n\n\n\n이제 추가 패키지를 설치해볼게요:\n\n```js\nnpm install jsonwebtoken\nnpm install dotenv\nnpm install bcrypt\n```\n\n그럼 이제 사용자 모델을 만들어보겠습니다:\n\n```js\nconst jwt = require(\"jsonwebtoken\");\nconst mongoose = require(\"mongoose\");\nrequire(\"dotenv\").config();\n\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n  },\n  password: {\n    type: String,\n    required: true,\n    unique: true,\n    minlength: 8,\n    maxlength: 1024,\n  },\n  refreshtoken: [String],\n});\n\nuserSchema.methods.generateAuthToken = function () {\n  const accesstoken = jwt.sign(\n    { _id: this._id },\n    process.env.ACCESS_SECRET_KEY,\n    {\n      expiresIn: \"10s\",\n    }\n  );\n  const refreshtoken = jwt.sign(\n    { _id: this._id },\n    process.env.REFRESH_SECRET_KEY,\n    { expiresIn: \"1d\" }\n  );\n\n  const tokens = { accesstoken: accesstoken, refreshtoken: refreshtoken };\n  return tokens;\n};\n\nconst User = mongoose.model(\"User\", userSchema);\n\nexports.User = User;\n```\n\n\n\n우리는 MongoDB에서 사용자 데이터를 위한 스키마를 정의합니다.\n\n각 사용자 문서에는 이메일, 패스워드, 그리고 리프레시 토큰을 저장하기 위한 배열이 포함될 것입니다.\n\n우리는 사용자 스키마에 generateAuthToken이라는 메소드를 추가합니다.\n\n- 이 메소드는 jsonwebtoken 패키지를 사용하여 액세스 토큰과 리프레시 토큰을 생성합니다.\n- 액세스 토큰은 10초 후에 만료되며 사용자의 _id를 포함합니다.\n- 리프레시 토큰은 1일 후에 만료되며 또한 사용자의 _id를 포함합니다.\n\n\n\n우리는 사용자 스키마를 기반으로 하는 Mongoose 모델인 User를 생성합니다.\n\n- 이 모델은 사용자를 위한 MongoDB 컬렉션과 상호 작용하기 위해 사용됩니다.\n- 우리는 다른 부분에서 사용하기 위해 User 모델을 내보냅니다.\n\n# AppError 및 TryCatch\n\n우리는 더 나은 오류 처리를 위해 두 가지 유틸리티 함수인 AppError와 tryCatch로 코드베이스를 향상시키고 있습니다.\n\n\n\nAppError 클래스는 구조화된 방식으로 오류 정보를 캡슐화하기 위해 설계되었습니다. 이 클래스는 기본 Error 클래스를 확장하고 errorCode 및 statusCode와 같은 사용자 정의 속성을 추가하여 오류를 분류하고 적절한 HTTP 상태 코드로 응답할 수 있도록 합니다. 이것은 응용 프로그램 전반에 걸쳐 오류 처리의 일관성을 보장합니다.\n\n```js\nclass AppError extends Error {\n  constructor(errorCode, message, statusCode) {\n    super(message);\n    this.errorCode = errorCode;\n    this.statusCode = statusCode;\n  }\n}\n\nmodule.exports = AppError;\n```\n\ntryCatch 함수는 비동기 컨트롤러 함수 내에서 오류를 처리하는 편리한 방법을 제공합니다. 이 함수는 컨트롤러 함수를 입력으로 받고 새로운 비동기 함수를 반환합니다. 이 새로운 함수는 원래의 컨트롤러 함수를 try-catch 블록으로 감싸줍니다. 컨트롤러 함수 실행 중에 오류가 발생하면 해당 오류가 catch되어 기록되고 Express의 next 함수로 전달됩니다. 이 추상화는 라우트 핸들러에서 오류 처리를 간소화시키며 더 깔끔하고 유지보수하기 쉬운 코드를 장려합니다.\n\n```js\nexports.tryCatch = (controller) => async (req, res, next) => {\n  try {\n    await controller(req, res);\n  } catch (error) {\n    console.log(error);\n    return next(error);\n  }\n};\n```\n\n\n\n이 유틸리티 함수들을 코드베이스에 통합함으로써, 우리의 에러 처리 메커니즘의 가독성이 향상되어 전체 신뢰성과 사용자 경험이 향상됩니다.\n\n# 루트\n\n다음으로, 사용자 인증 및 세션 관리를 위한 엔드포인트를 설계할 것입니다. SignIn, SignUp, RefreshToken 및 LogOut을 포함하고 있습니다. 우선, 이러한 기능을 위한 루트를 정의해 보겠습니다.\n\n```js\nconst express = require(\"express\");\nconst authController = require(\"./controllers\");\nconst verifyJWT = require(\"../../middleware/verifyJWT\");\n\nconst router = express.Router();\n\n//인증 기반 루트\nrouter.post(\"/signUp\", authController.SignUp);\nrouter.post(\"/signIn\", authController.SignIn);\nrouter.get(\"/refresh\", authController.refreshToken);\nrouter.get(\"/logout\", authController.logOut);\n\nmodule.exports = router;\n```\n\n\n\nNode.js 어플리케이션에서, 서비스와 컨트롤러는 코드베이스를 조직화하고 구조화하는 데 중요한 구성 요소로서 역할을 합니다. 이는 관심사 분리와 유지보수를 촉진합니다.\n\n- 서비스: 서비스는 비즈니스 로직과 데이터 조작 작업을 캡슐화합니다. 특정 도메인과 관련된 작업이나 특정 작업을 수행하는 데 책임이 있습니다. 서비스는 작업이 어떻게 구현되는지에 대한 세부 정보를 추상화하여 컨트롤러가 HTTP 요청 및 응답 처리에 집중하고 가볍게 유지할 수 있도록 합니다. 서비스는 종종 응용 프로그램의 여러 부분에서 재사용 가능하며 비즈니스 로직을 외부 종속성으로부터 격리하여 테스트를 용이하게 합니다.\n  \n- 컨트롤러: 컨트롤러는 수신된 HTTP 요청을 처리하고 응용 프로그램의 엔드포인트를 정의합니다. 요청에서 데이터를 추출하고 필요한 작업을 수행하기 위해 서비스와 상호 작용하며 적절한 응답을 클라이언트에 반환합니다. 컨트롤러는 클라이언트 측 인터페이스(예: 웹 브라우저 또는 모바일 앱)와 기저 응용 프로그램 로직 사이의 다리 역할을 합니다. 컨트롤러는 비즈니스 로직이 표현 계층과 분리되도록 하여 작업을 조직화하고 서비스에 작업을 위임합니다. 라우팅 및 요청/응답 처리를 담당하여 요청-응답 주기에서 중요한 구성 요소로 작용합니다.\n\n이제 SignUp 기능을 구현해 보겠습니다.\n\n```js\nconst bcrypt = require(\"bcrypt\");\nconst jwt = require(\"jsonwebtoken\");\nconst { tryCatch } = require(\"../../utils/tryCatch\");\nconst AppError = require(\"../../utils/AppError\");\nconst authServices = require(\"./services\");\nconst { User } = require(\"../../Models/user\");\n\nexports.SignUp = tryCatch(async (req, res) => {\n  const { email, password } = req.body;\n  const user = await User.find({ email: email });\n  \n  if (!user) {\n    throw new AppError(\n      409,\n      \"데이터베이스에 이미 존재하는 이메일 주소입니다!\",\n      409\n    );\n  }\n\n  try {\n    const response = await authServices.signUp(email, password);\n    const accessToken = response.token.accesstoken;\n    const refreshToken = response.token.refreshtoken;\n    res.cookie(\"jwt\", refreshToken, {\n      httpOnly: true,\n      maxAge: 24 * 60 * 60 * 1000,\n    });\n    res.status(200).json({ accessToken: accessToken }).end();\n  } catch (err) {\n    console.log(err);\n    res.status(err.statusCode).json(err.message).end();\n  }\n});\n```\n\n\n\n위 코드 스니펫은 Node.js 애플리케이션에서 사용자 등록 요청을 처리하는 SignUp 컨트롤러 함수를 정의합니다. 이 함수는 비밀번호 해싱을 위한 bcrypt 및 토큰 생성을 위한 jsonwebtoken과 같은 필요한 모듈을 가져오며 사용자 지정 오류 처리 유틸리티도 가져옵니다. 요청을 받으면 요청 본문에서 이메일과 비밀번호를 추출하고 동일한 이메일을 가진 기존 사용자를 확인하며, 중복된 이메일이 없으면 SignUp 서비스를 호출하여 사용자 생성을 처리하고 액세스 및 리프레시 토큰을 생성하여 보안을 위해 리프레시 토큰을 HTTP-only 쿠키에 설정하고 응답에 액세스 토큰을 보냅니다. SignUp 프로세스 중 발생하는 모든 오류는 오류 상태 코드와 메시지로 적절히 처리됩니다.\n\nSignUp 서비스:\n\n```js\nconst bcrypt = require(\"bcrypt\");\nconst { User } = require(\"../../Models/user\");\nconst { UserProfile } = require(\"../../Models/userProfile\");\nconst mongoose = require(\"mongoose\");\nconst ObjectId = mongoose.Types.ObjectId;\n\nconst signUp = async (email, password) => {\n  const newUser = new User({\n    email: email,\n    password: password,\n    refreshtoken: \"\",\n  });\n\n  const salt = await bcrypt.genSalt(10);\n  newUser.password = await bcrypt.hash(newUser.password, salt);\n\n  const tokens = newUser.generateAuthToken();\n  newUser.refreshtoken = tokens.refreshtoken;\n  await newUser.save();\n  const data = {\n    token: tokens,\n    id: newUser.id,\n  };\n\n  return data;\n};\n```\n\n이 서비스 함수 signUp은 애플리케이션에 새로운 사용자를 생성하는 역할을 합니다. 이메일과 비밀번호를 매개변수로 받습니다. 함수 내에서는 제공된 이메일과 비밀번호로 User 객체를 생성하고 비어있는 리프레시 토큰 필드를 가집니다. 그런 다음 보안을 위해 bcrypt를 사용하여 비밀번호를 해싱합니다. 사용자 모델의 generateAuthToken 메서드를 사용하여 인증 토큰을 생성하는 책임이 있는 사용자 모델의 객체에 리프레시 토큰을 할당합니다. 마지막으로 새 사용자를 데이터베이스에 저장하고 생성된 토큰과 사용자 ID를 포함하는 객체가 반환됩니다. 이 함수는 사용자 암호가 데이터베이스에 저장되기 전에 안전하게 해싱되며 새로 생성된 사용자에 대한 인증 토큰을 제공합니다.\n\n\n\n동일한 스키마를 사용하여 SignIn 기능을 이제 구현하겠습니다:\n\n```js\nexports.SignIn = tryCatch(async (req, res) => {\n  const cookies = req.cookies;\n  const { email, password } = req.body;\n  const user = await User.findOne({ email: email });\n\n  if (!user) {\n    throw new AppError(\n      404,\n      \"이메일 주소를 찾을 수 없습니다. 이메일을 확인하고 다시 시도해주세요.\",\n      404\n    );\n  }\n\n  const validPassword = await bcrypt.compare(password, user.password);\n\n  if (!validPassword) {\n    throw new AppError(\n      401,\n      \"잘못된 비밀번호입니다. 비밀번호를 다시 확인하고 다시 시도해주세요.\",\n      401\n    );\n  }\n\n  try {\n    let newRefreshTokenArray = \"\";\n\n    // 사용자의 기존 refresh 토큰 확인\n    let refreshToken = \"\";\n    if (!cookies?.jwt) {\n      refreshToken = user.refreshtoken;\n    } else {\n      refreshToken = cookies.jwt;\n      const foundToken = await User.findOne({ refreshToken }).exec();\n      \n      if (!foundToken) {\n        console.log(\"로그인 시 시도된 refresh 토큰 재사용!\");\n        // 토큰이 데이터베이스에 없으면 쿠키를 지우기\n        res.clearCookie(\"jwt\", { httpOnly: true });\n        refreshToken = \"\";\n      }\n    }\n    const response = await authServices.signIn(user, newRefreshTokenArray);\n    const accessToken = response.token.accesstoken;\n    refreshToken = response.token.refreshtoken;\n    const profilePic = response.profilePic;\n    res.cookie(\"jwt\", refreshToken, {\n      httpOnly: true,\n      maxAge: 24 * 60 * 60 * 1000,\n    });\n    return res\n      .status(200)\n      .cookie(\"jwt\", refreshToken, {\n        httpOnly: true,\n        maxAge: 24 * 60 * 60 * 1000,\n      })\n      .json({ accessToken: accessToken, profilePic: profilePic })\n      .end();\n  } catch (err) {\n    console.log(err);\n    return res.status(err.statusCode).json(err.message).end();\n  }\n});\n```\n\n이 코드 세그먼트는 Node.js 애플리케이션에서 SignIn 기능을 구현하여 사용자 인증을 안전하게 처리합니다. 먼저 요청 본문에서 사용자 자격 증명을 추출하고 제공된 이메일에 따라 데이터베이스에서 사용자를 검색합니다. 사용자를 찾을 수 없거나 비밀번호가 일치하지 않는 경우 해당 문제를 나타내는 사용자 정의 오류가 발생합니다. 그런 다음 사용자의 기존 refresh 토큰을 확인하고 토큰의 재사용을 방지하기 위해 유효성을 검사합니다. 성공적으로 인증된 후, 새로운 액세스 및 refresh 토큰을 생성하고 사용자의 프로필 사진을 가져오기 위해 서비스 함수를 호출합니다. 새 refresh 토큰은 보안을 위해 HTTP-only 쿠키에 설정되고, 액세스 토큰과 프로필 사진은 응답으로 반환됩니다. 프로세스 중 발생하는 모든 오류는 적절히 처리되어 상응하는 상태 코드와 메시지로 오류 응답으로 반환됩니다.\n\n```js\nconst signIn = async (user, newRefreshTokenArray) => {\n  const token = user.generateAuthToken();\n  user.refreshtoken = [...newRefreshTokenArray, token.refreshtoken];\n  await user.save();\n  const data = {\n    token: token,\n    userId: user.id,\n  };\n  return data;\n};\n\nmodule.exports = {\n  signUp,\n  signIn,\n};\n```\n\n\n\n서비스 기능 signIn은 사용자 인증에 성공한 경우 인증 토큰을 생성하고 사용자 프로필 정보를 검색하는 작업을 처리합니다. 이 함수는 인증된 사용자 객체와 새로운 리프레시 토큰 배열을 매개변수로 받습니다. 그런 다음 사용자 객체의 generateAuthToken 메서드를 사용하여 인증 토큰을 생성합니다. 새로운 리프레시 토큰은 사용자의 refreshtoken 배열에 추가되고 사용자 객체가 데이터베이스에 다시 저장됩니다. 마지막으로 생성된 토큰과 사용자 ID가 포함된 객체를 구성하고 반환합니다. 이 함수는 인증 토큰이 안전하게 생성되고 저장되며 사용자 정보가 정상적으로 검색되어 제공되도록 보장합니다.\n\n여기까지가 기본 인증 흐름입니다. 이제 로그아웃 기능만 필요합니다.\n\n```js\nexports.logOut = tryCatch(async (req, res) => {\n  // 클라이언트에서는 accessToken도 삭제하세요\n  const cookies = req.cookies;\n  if (!cookies?.jwt) return res.sendStatus(204);\n  const refreshToken = cookies.jwt;\n  // 데이터베이스에 리프레시 토큰이 있는지 확인합니다.\n  const foundUser = await User.findOne({ refreshtoken: refreshToken });\n\n  if (!foundUser) {\n    res.clearCookie(\"jwt\", { httpOnly: true });\n    return res.sendStatus(204);\n  }\n\n  // 데이터베이스에서 리프레시 토큰 삭제\n  foundUser.refreshtoken = foundUser.refreshtoken.filter(\n    (rt) => rt !== refreshToken\n  );\n  await foundUser.save();\n\n  res.clearCookie(\"jwt\", { httpOnly: true });\n  res.sendStatus(204);\n});\n```\n\n이 코드 스니펫은 Node.js 애플리케이션에서 사용자 로그아웃 요청을 처리하는 logOut 컨트롤러 함수를 정의합니다. 오류 처리를 위해 tryCatch 유틸리티가 사용됩니다. 이 함수는 먼저 사용자가 쿠키에 저장된 리프레시 토큰을 확인합니다. 그렇지 않은 경우 204(내용 없음) 상태 코드를 보내어 작업이 필요하지 않음을 나타냅니다. 리프레시 토큰이 발견되면 함수는 데이터베이스를 쿼리하여 존재 여부를 확인합니다. 데이터베이스에서 리프레시 토큰을 찾을 수 없는 경우 리프레시 토큰 쿠키를 지우고 204 상태 코드를 보냅니다. 그렇지 않으면 사용자가 저장한 리프레시 토큰에서 리프레시 토큰을 제거하고 업데이트된 사용자 객체를 다시 데이터베이스에 저장한 다음 리프레시 토큰 쿠키를 지우고 204 상태 코드를 보내 성공적으로 로그아웃 여부를 나타냅니다. 이 함수는 리프레시 토큰을 안전하게 처리하여 관리하고 관련 쿠키를 지움으로써 사용자 로그아웃 요청을 적절하게 처리합니다.\n\n\n\n# 리프레시 엔드포인트\n\n리프레시 토큰을 사용하면 인증 시스템에서 새 액세스 토큰을 얻을 수 있어요. 액세스 토큰이 만료될 때 이를 사용하여 새 액세스 토큰을 요청할 수 있어요. 액세스 토큰이 수명이 짧지만, 리프레시 토큰은 긴 수명을 가지며 보통 몇 일이나 심지어 몇 주 동안 유효합니다. 액세스 토큰이 만료되었을 때 리프레시 토큰은 사용자가 다시 로그인할 필요 없이 새 액세스 토큰을 요청할 수 있도록 도와줘요. 이를 통해 민감한 자격 증명 노출을 최소화하고 사용자 인증 빈도를 줄여 보안을 강화할 수 있어요. 리프레시 토큰은 클라이언트 측에 안전하게 저장되며 보통 HTTP-only 쿠키에 저장되며 안전한 인증 흐름을 통해 새 액세스 토큰으로 교환됩니다.\n\n그래서 조금 더 명확하게 설명되었나요? 이를 향상시키기 위해 사용자 액세스 키가 만료된 경우 “무음\"이라고 부를 수 있는 리프레시 토큰 엔드포인트가 필요해요.\n\n\n\n```js\nexports.refreshToken = tryCatch(async (req, res) => {\n  const cookies = req.cookies;\n  if (!cookies?.jwt) return res.sendStatus(401);\n  const refreshToken = cookies.jwt;\n  res.clearCookie(\"jwt\", { httpOnly: true });\n  const foundUser = await User.findOne({ refreshtoken: refreshToken });\n  \n  if (!foundUser) {\n    jwt.verify(\n      refreshToken,\n      process.env.REFRESH_SECRET_KEY,\n      async (err, decoded) => {\n        if (err) return res.sendStatus(403); //Forbidden\n        const hackedUser = await User.findOne({ username: decoded._id });\n        hackedUser.refreshtoken = [];\n        const result = await hackedUser.save();\n      }\n    );\n    return res.sendStatus(403);\n  }\n\n  const newRefreshTokenArray = foundUser.refreshtoken.filter(\n    (rt) => rt !== refreshToken\n  );\n\n  //evaluate jwt\n  jwt.verify(\n    refreshToken,\n    process.env.REFRESH_SECRET_KEY,\n    async (err, decoded) => {\n      if (err) {\n        foundUser.refreshtoken = [...newRefreshTokenArray];\n        const result = await foundUser.save();\n      }\n      if (err || foundUser._id.toString() !== decoded._id) {\n        return res.sendStatus(403);\n      }\n      //refreshtoken still valid\n      const accessToken = jwt.sign(\n        { _id: decoded._id },\n        process.env.ACCESS_SECRET_KEY,\n        { expiresIn: \"10s\" }\n      );\n\n      const newRefreshToken = jwt.sign(\n        { _id: foundUser._id },\n        process.env.REFRESH_SECRET_KEY,\n        { expiresIn: \"1d\" }\n      );\n      foundUser.refreshtoken = [...newRefreshTokenArray, newRefreshToken];\n      const result = await foundUser.save();\n      res.cookie(\"jwt\", newRefreshToken, {\n        httpOnly: true,\n        maxAge: 24 * 60 * 60 * 1000,\n      });\n      res.status(200).json(accessToken);\n    }\n  );\n});\n```\n\n- Refresh Token 확인: 먼저 \"jwt\"라는 쿠키에 저장된 리프레시 토큰이 있는지 확인합니다. 만약 없다면 401(권한없음) 상태 코드로 응답하여 사용자가 인증해야 함을 알립니다.\n- 쿠키 삭제: 리프레시 토큰의 존재 여부와 상관없이 보안을 위해 \"jwt\" 쿠키를 제거합니다.\n- 사용자 찾기: 그 후 데이터베이스에서 리프레시 토큰과 연결된 사용자를 찾습니다. 사용자를 찾지 못하면 리프레시 토큰의 무결성을 확인합니다.\n- 리프레시 토큰 확인: 환경 변수에 저장된 비밀 키를 사용하여 리프레시 토큰을 확인합니다. 토큰이 유효하지 않거나 만료되었다면 403(금지됨) 상태 코드로 응답합니다. 또한 확인에 사용된 사용자를 찾아 사용자와 연관된 모든 리프레시 토큰을 제거하여 잠재적인 남용을 방지합니다.\n- 토큰 갱신: 리프레시 토큰이 유효하고 사용자와 연관되어 있다면 액세스 토큰과 리프레시 토큰을 갱신합니다. 짧은 만료 시간(여기서 10초)을 갖는 새로운 액세스 토큰과 긴 만료 시간(여기서 1일)을 갖는 새로운 리프레시 토큰을 생성합니다. 사용자의 리프레시 토큰 배열을 새로운 리프레시 토큰으로 업데이트하고 데이터베이스에 변경 사항을 저장합니다.\n- 새로운 쿠키 설정: 마지막으로 새로운 리프레시 토큰을 안전하게 설정하기 위해 HTTP-only 플래그와 최대 24시간 나이가 있는 쿠키로 설정합니다. 새로운 액세스 토큰과 함께 200(성공) 상태 코드로 응답합니다.\n\n또한 데이터베이스로부터 사용자 이메일을 가져오는 보안된 엔드포인트가 필요합니다:\n\n```js\nexports.getUserData = tryCatch(async (req, res) => {\n  const userId = req.params.id;\n  const foundUser = await User.findOne({ _id: userId });\n\n  const data = {\n    userEmail: foundUser.email,\n  };\n\n  res.status(200).json(data).end();\n});\n```\n\n\n\n저희 라우트에도 다음을 추가해야 합니다:\n\n```js\nconst express = require(\"express\");\nconst authController = require(\"./controllers\");\nconst verifyJWT = require(\"../../middleware/verifyJWT\");\n\nconst router = express.Router();\n\n//Auth 기반 라우트\nrouter.post(\"/signUp\", authController.SignUp);\nrouter.post(\"/signIn\", authController.SignIn);\nrouter.get(\"/refresh\", authController.refreshToken);\nrouter.get(\"/logout\", authController.logOut);\n\nrouter.get(\"/getUser/:id\", verifyJWT, authController.getUserData);\n\nmodule.exports = router;\n```\n\n여기서 verifyJWT 미들웨어에 대해 이야기해야 합니다:\n\n```js\nconst jwt = require(\"jsonwebtoken\");\nrequire(\"dotenv\").config();\n\nconst verifyJWT = (req, res, next) => {\n  const authHeader = req.headers[\"authorization\"];\n  if (!authHeader) return res.sendStatus(401);\n  console.log(authHeader);\n  const token = authHeader.split(\"Bearer \")[1];\n  console.log(token);\n  console.log(\"access secret\", process.env.ACCESS_SECRET_KEY);\n  jwt.verify(token, process.env.ACCESS_SECRET_KEY, (err, decoded) => {\n    console.log(decoded);\n    if (err) {\n      console.log(err);\n      return res.status(403).json({ error: \"Forbidden: JWT token expired!\" });\n    }\n    req.user = decoded.username;\n    next();\n  });\n};\n\nmodule.exports = verifyJWT;\n```\n\n\n\n이 코드에서는 응용 프로그램에서 인증에 사용되는 JSON Web Token (JWT)을 확인하는 verifyJWT라는 미들웨어 함수를 정의합니다. 먼저, JWT 확인을 처리하기 위해 jsonwebtoken 패키지를 가져오고 환경 변수에 안전하게 액세스하기 위해 dotenv 패키지를 가져옵니다. verifyJWT 함수는 req (요청), res (응답) 및 next라는 세 가지 매개변수를 사용하여 Express 애플리케이션에서 미들웨어로 작동할 수 있습니다. 함수 내에서는 들어오는 요청의 Authorization 헤더에서 JWT 토큰을 추출합니다. 헤더가 누락되거나 형식이 잘못된 경우 즉시 상태 코드가 401 (인증되지 않음)으로 응답됩니다. 그렇지 않으면 헤더를 분할하여 \"Bearer \" 접두사를 제거하고 토큰을 분리합니다. 그런 다음 jwt.verify를 사용하여 토큰을 디코딩하고 환경 변수에 저장된 엑세스 시크릿 키와의 일치 여부를 확인합니다. 확인이 실패하는 경우(예: 토큰 만료 또는 잘못된 서명), 상태 코드가 403(금지됨)으로 응답되고 오류 메시지가 표시됩니다. 그렇지 않으면 토큰이 유효한 경우 디코딩된 페이로드(일반적으로 사용자 정보를 포함)를 추출하여 req.user로써 요청 객체에 첨부합니다. 마지막으로 next 함수를 호출하여 요청-응답 주기에서 다음 미들웨어나 라우트 핸들러로 제어를 전달합니다. 이 미들웨어를 사용하면 유효한 JWT 토큰을 가진 요청만 보호된 경로에 액세스할 수 있도록하며 응용 프로그램의 보안을 강화합니다.\n\n필요한 모든 것을 생성한 후에는 서버.js에 cors 및 쿠키 구문 분석을 위한 추가 설정이 필요합니다:\n\n```js\nconst express = require(\"express\");\nconst cors = require(\"cors\");\nconst db = require(\"./dbconnection\");\nconst port = 5000;\nconst bodyParser = require(\"body-parser\");\nconst cookieParser = require(\"cookie-parser\");\nconst app = express();\n\nconst userRoutes = require(\"./apis/users/routes\");\n\nconst frontendURI = \"http://localhost:5173\";\n\napp.use(bodyParser.json({ limit: \"5mb\" }));\napp.use(cookieParser());\napp.use(\n  cors({\n    origin: frontendURI, // 귀하의 프론트엔드 도메인으로 대체\n    credentials: true, // 자격 증명(쿠키, 인가 헤더) 허용\n  })\n);\napp.use(\"/users\", userRoutes);\napp.listen(port, () => {\n  console.log(`서버가 포트 ${port}에서 실행중입니다.`);\n});\n```\n\n- CORS(Cross-Origin Resource Sharing):\n\n\n\n- Cors 미들웨어는 우리 애플리케이션에서 Cross-Origin Resource Sharing을 활성화하는 역할을 합니다. 이를 통해 서버의 리소스가 원래 출처(origin)와 다른 도메인에서 요청될 수 있습니다. 이것은 서로 다른 도메인의 서버로 요청을 하는 클라이언트 측 웹 애플리케이션에게 중요합니다.\n- 우리의 코드에서는 cors를 특정한 옵션으로 구성합니다:\n  - origin: 크로스-오리진 요청의 허용된 원본을 지정합니다. 이 경우, \"http://localhost:5173\"인 특정 프론트엔드 URI(frontendURI)에서의 요청을 허용합니다.\n  - credentials: 서버가 요청에 쿠키나 인증 헤더와 같은 자격 증명을 포함해야 하는지 여부를 나타냅니다. 이를 true로 설정하면 클라이언트가 그러한 자격 증명을 포함할 수 있습니다.\n\n2. bodyParser:\n\n- bodyParser 미들웨어는 들어오는 요청 본문을 구문 분석하고 구문 분석된 데이터를 req.body 속성 아래에서 사용할 수 있게 합니다. 특히 POST 또는 PUT 요청을 처리할 때 클라이언트로부터 전송된 데이터를 처리하는 데 필수적입니다.\n- 우리의 코드에서는 bodyParser.json()을 사용하여 JSON 인코딩된 요청 본문을 구문 분석합니다. 또한 요청 본문 크기의 제한을 5MB로 설정하여 단일 요청에서 전송할 수 있는 데이터 양을 제한하여 잠재적인 서비스 거부 공격을 방지합니다.\n\n3. cookieParser:\n\n\n\n- CookieParser 미들웨어는 클라이언트 요청에 첨부된 쿠키를 구문 분석하고 req.cookies 속성 아래에서 사용할 수 있도록 만듭니다. 클라이언트가 보낸 쿠키를 처리하는 데 중요한데, 이는 세션 관리, 인증 및 기타 목적으로 자주 사용됩니다.\n- 저희 코드에서는 추가 구성 없이 cookieParser의 기본 설정을 사용하고 있습니다.\n\n이제 백엔드 구현을 다룼으로써, 애플리케이션을 위한 최소한의 프론트엔드를 만들어 모든 것을 연결해 보겠습니다. 프론트엔드 인터페이스를 구축함으로써 방금 개발한 백엔드 기능과 상호 작용할 수 있게 됩니다. React를 사용하여 기본 프론트엔드 구조를 설정해 보겠습니다. 우리는 SignUp, SignIn, RefreshToken 및 LogOut과 같은 백엔드에 구현한 인증 엔드포인트와 상호 작용할 수 있는 사용자 인터페이스 구성 요소를 만들 것입니다. 더불어 Axios와 같은 도구를 활용하여 백엔드 API로 HTTP 요청을 보내고 사용자 인증 흐름을 원활하게 처리할 것입니다. 그러니 이제 소매를 걷어 올리고 프론트엔드 개발 프로세스로 뛰어 들어 백엔드 아키텍처를 보완해 봅시다!\n\n모든 것이 정확히 완료되었는지 확인하고 보장하려면, 이 코드의 GitHub 저장소를 방문해 주세요.\n\n제2부에서 여러분을 만나는 것을 고대하겠습니다!","ogImage":{"url":"/assets/img/2024-05-12-RefreshAuthTokenRotationNodejsReactPart1_0.png"},"coverImage":"/assets/img/2024-05-12-RefreshAuthTokenRotationNodejsReactPart1_0.png","tag":["Tech"],"readingTime":19},{"title":"리액트에서 사용자 정의 드롭다운 컴포넌트 만들기 단계별 가이드","description":"","date":"2024-05-12 19:10","slug":"2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep","content":"\n![이미지](/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_0.png)\n\n안녕하세요! 이 기사에서는 React 애플리케이션에서 동적으로 사용할 수 있는 사용자 정의 Dropdown 컴포넌트를 소개하려고해요. 이 Dropdown 컴포넌트는 사용자가 목록에서 항목을 선택할 수 있도록 하면서 다양한 위치와 스타일로 표시될 수 있어요. 또한 이미지가 있는 경우와 없는 경우 모두 사용할 수 있어요. 이 컴포넌트는 Typescript, Tailwind CSS, React Icons 및 Classnames와 같은 인기있는 라이브러리를 사용하여 개발되었어요.\n\n👉 먼저 단계별로 무엇이 일어나고 있는지 설명한 후에 마지막에 전체 코드와 사용법을 추가할 거예요. 준비가 되셨나요? 그럼 시작해봅시다!\n\n![이미지](/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_1.png)\n\n## 1. Imports:\n\n```js\nimport { useEffect, useRef, useState } from \"react\";\nimport classNames from \"classnames\";\nimport { GoChevronDown } from \"react-icons/go\";\nimport useOutsideClick from \"../hooks/useOutsideClick\";\n```\n\n🔸 useEffect, useRef 및 useState ➜ 이들은 상태를 관리하고 DOM 요소에 대한 참조를 만들 때 사용되는 React 훅입니다.\n\n🔸 classNames ➜ 이 라이브러리는 조건부로 classNames을 결합하는 데 사용됩니다.\n\n🔹 goChevronDown ➜ 이 아이콘 컴포넌트는 드롭다운 토글 버튼에 사용됩니다.\n\n🔹 useOutsideClick ➜ 이 사용자 정의 후크는 지정된 요소 외부를 클릭 감지하는 데 사용됩니다.\n\n## 2. 인터페이스:\n\n```js\n인터페이스 DropdownItem {\n  id: string;\n  name: string;\n  imageUrl?: string;\n}\n\n인터페이스 DropdownProps {\n  id: string;\n  title?: string;\n  data: DropdownItem[];\n  position?: \"bottom-right\" | \"bottom-left\" | \"top-right\" | \"top-left\";\n  hasImage?: boolean;\n  style?: string;\n  selectedId?: string;\n  onSelect?: (id: string) => void;\n}\n```\n\n🔹DropdownItem➜ DropdownItem을 정의합니다. 이 인터페이스는 각 드롭다운 아이템에 필요한 속성인 id, name 및 옵션으로 imageUrl을 지정합니다.\n\n🔹DropdownProps➜ 이 인터페이스는 Dropdown 컴포넌트에 전달할 수 있는 프로퍼티들을 지정합니다. 이 프로퍼티들의 설명은 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_2.png)\n\n📌 id: Dropdown 컴포넌트의 고유 식별자입니다.\n\n📌 제목: 드롭다운이 열릴 때 표시되는 기본 제목. 기본 제목은 \"Select\"입니다.\n\n📌 데이터: 드롭다운 콘텐츠를 구성하는 항목 목록.\n\n📌 위치: 드롭다운의 위치를 버튼을 기준으로 지정합니다. (\"bottom-right\", \"bottom-left\", \"top-right\", \"top-left\"). 기본 위치는 \"bottom-left\"입니다.\n\n📌 이미지 포함 여부: 드롭다운 항목에 이미지가 있는지를 나타내는 부울 값.\n\n📌 스타일 : 드롭다운 컴포넌트에 적용할 추가 스타일입니다.\n\n📌 selectedId : 초기 선택 항목의 식별자입니다.\n\n📌 onSelect : 항목이 선택될 때 호출되는 콜백 함수입니다.\n\n![이미지](/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_3.png)\n\n이 프롭들은 Dropdown 컴포넌트를 다양한 사용 사례에 맞게 사용자 정의할 수 있도록 해 줍니다. 사용자가 필요에 맞게 드랍다운의 동작, 내용, 외관을 맞춤 설정할 수 있게 해줍니다.\n\n## 3. Dropdown 컴포넌트 생성:\n\n```js\nconst Dropdown = ({\n  id,\n  title = \"Select\", //기본 값\n  data,\n  position = \"bottom-left\", //기본 값\n  hasImage,\n  style,\n  selectedId,\n  onSelect,\n}: DropdownProps) => {\n  return (\n    <div ref={dropdownRef} className=\"relative\">\n      {/* ... */}\n    </div>\n  );\n};\nexport default Dropdown;\n```\n\n🔹Dropdown 컴포넌트는 사용자 정의 드롭다운 메뉴 컴포넌트이며 위의 프롭을 허용합니다.\n\n## 4. 상태 변수:\n\n```js\nconst [isOpen, setIsOpen] = useState < boolean > false;\n\nconst [selectedItem, setSelectedItem] =\n  (useState < DropdownItem) | (undefined > (selectedId ? data?.find((item) => item.id === selectedId) : undefined));\n```\n\n🔹isOpen➜ 드롭다운 메뉴의 열기/닫기 상태를 관리합니다.\n\n🔹selectedItem➜ 드롭다운 메뉴에서 현재 선택된 항목을 추적합니다.\n\n## 5. 이벤트 핸들러:\n\n```js\nconst handleChange = (item: DropdownItem) => {\n  setSelectedItem(item);\n  onSelect && onSelect(item.id);\n  setIsOpen(false);\n};\n```\n\n🔹handleChange➜ 드롭다운 메뉴에서 항목을 선택하는 핸들러입니다. 선택된 항목을 업데이트하고, onSelect 콜백을 호출(제공된 경우)하며, 드롭다운 메뉴를 닫습니다.\n\n## 6. useEffect 훅:\n\n```js\nuseEffect(() => {\n  if (selectedId && data) {\n    const newSelectedItem = data.find((item) => item.id === selectedId);\n    newSelectedItem && setSelectedItem(newSelectedItem);\n  } else {\n    setSelectedItem(undefined);\n  }\n}, [selectedId, data]);\n```\n\n🔹 이 useEffect 훅은 selectedId와 data의 변경 사항을 감지합니다. 둘 중 하나가 변경되면 데이터에서 selectedId와 일치하는 항목을 찾아 selectedItem에 설정합니다.\n\n## 7. Ref:\n\n```js\nconst dropdownRef = useRef < HTMLDivElement > null;\nuseOutsideClick({\n  ref: dropdownRef,\n  handler: () => setIsOpen(false),\n});\n```\n\n🔹 dropdownRef➜ 드롭다운 메뉴 외부 클릭을 감지하는 데 사용되는 Ref입니다.\n\n## 8. CSS 클래스:\n\n```js\nconst dropdownClass = classNames(\"absolute bg-gray-100 w-max max-h-52 overflow-y-auto py-3 rounded shadow-md z-10\", {\n  \"top-full right-0 mt-2\": position === \"bottom-right\",\n  \"top-full left-0 mt-2\": position === \"bottom-left\",\n  \"bottom-full right-0 mb-2\": position === \"top-right\",\n  \"bottom-full left-0 mb-2\": position === \"top-left\",\n});\n```\n\n🔹 dropdownClass➜ 위치 prop에 따라 드롭다운 메뉴를 배치하기 위해 CSS 클래스를 동적으로 계산합니다.\n\n## 9. 드롭다운 토글 버튼 생성:\n\n```js\n<button\n  id={id}\n  aria-label=\"드롭다운 토글\"\n  aria-haspopup=\"true\"\n  aria-expanded={isOpen}\n  type=\"button\"\n  onClick={() => setIsOpen(!isOpen)}\n  className={classNames(\n    \"flex justify-between items-center gap-5 rounded w-full py-2 px-4 bg-blue-500 text-white\",\n    style\n  )}\n>\n  <span>{selectedItem?.name || title}</span>\n  <GoChevronDown\n    size={20}\n    className={classNames(\"transform duration-500 ease-in-out\", {\n      \"rotate-180\": isOpen,\n    })}\n  />\n</button>\n```\n\n🔹버튼 엘리먼트는 제목 또는 선택한 항목의 텍스트와 화살표 아이콘이 들어 있습니다.\n\n🔹클릭할 때마다 버튼은 isOpen 상태를 토글합니다.\n\n## 10. 드롭다운 콘텐츠 생성:\n\n```js\n{\n  isOpen && (\n    <div aria-label=\"드롭다운 메뉴\" className={dropdownClass}>\n      <ul role=\"menu\" aria-labelledby={id} aria-orientation=\"vertical\" className=\"leading-10\">\n        {data?.map((item) => (\n          <li\n            key={item.id}\n            onClick={() => handleChange(item)}\n            className={classNames(\"flex items-center cursor-pointer hover:bg-gray-200 px-3\", {\n              \"bg-gray-300\": selectedItem?.id === item.id,\n            })}\n          >\n            {hasImage && (\n              <img\n                src={item.imageUrl}\n                alt=\"이미지\"\n                loading=\"lazy\"\n                className=\"w-8 h-8 rounded-full bg-gray-400 object-cover me-2\"\n              />\n            )}\n            <span>{item.name}</span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n🔹만약 드롭다운이 열려있으면(isOpen이 true), 드롭다운 메뉴를 나타내는 div가 렌더링됩니다.\n\n🔹드롭다운 메뉴는 data prop으로부터 생성된 항목 목록을 포함합니다.\n\n🔹리스트의 각 항목은 `li` 요소로 표시됩니다.\n\n🔹hasImage 값이 true일 경우, 각 항목 옆에 이미지가 표시됩니다.\n\n## 사용법: ⤵️\n\n```js\nconst handleSelect = (id: string) => {\n  console.log(`id가 ${id}인 항목을 선택했습니다`);\n};\n\n<Dropdown\n  id=\"person\"\n  title=\"사람 선택\"\n  data={data}\n  hasImage\n  style=\"bg-purple-800\"\n  selectedId=\"3\"\n  onSelect={handleSelect}\n/>;\n```\n\n## ✔️ 여기에 전체 코드가 있어요: 👇\n\nDropdown.tsx\n\n```js\nimport { useEffect, useRef, useState } from \"react\";\nimport classNames from \"classnames\";\nimport { GoChevronDown } from \"react-icons/go\";\nimport useOutsideClick from \"../hooks/useOutsideClick\";\n\ninterface DropdownItem {\n  id: string;\n  name: string;\n  imageUrl?: string;\n}\n\ninterface DropdownProps {\n  id: string;\n  title?: string;\n  data: DropdownItem[];\n  position?: \"bottom-right\" | \"bottom-left\" | \"top-right\" | \"top-left\";\n  hasImage?: boolean;\n  style?: string;\n  selectedId?: string;\n  onSelect?: (id: string) => void;\n}\n\nconst Dropdown = ({\n  id,\n  title = \"Select\",\n  data,\n  position = \"bottom-left\",\n  hasImage,\n  style,\n  selectedId,\n  onSelect,\n}: DropdownProps) => {\n  const [isOpen, setIsOpen] = useState < boolean > false;\n  const [selectedItem, setSelectedItem] =\n    (useState < DropdownItem) | (undefined > (selectedId ? data?.find((item) => item.id === selectedId) : undefined));\n\n  const handleChange = (item: DropdownItem) => {\n    setSelectedItem(item);\n    onSelect && onSelect(item.id);\n    setIsOpen(false);\n  };\n\n  useEffect(() => {\n    if (selectedId && data) {\n      const newSelectedItem = data.find((item) => item.id === selectedId);\n      newSelectedItem && setSelectedItem(newSelectedItem);\n    } else {\n      setSelectedItem(undefined);\n    }\n  }, [selectedId, data]);\n\n  const dropdownRef = useRef < HTMLDivElement > null;\n  useOutsideClick({\n    ref: dropdownRef,\n    handler: () => setIsOpen(false),\n  });\n\n  const dropdownClass = classNames(\"absolute bg-gray-100 w-max max-h-52 overflow-y-auto py-3 rounded shadow-md z-10\", {\n    \"top-full right-0 mt-2\": position === \"bottom-right\",\n    \"top-full left-0 mt-2\": position === \"bottom-left\",\n    \"bottom-full right-0 mb-2\": position === \"top-right\",\n    \"bottom-full left-0 mb-2\": position === \"top-left\",\n  });\n\n  return (\n    <div ref={dropdownRef} className=\"relative\">\n      <button\n        id={id}\n        aria-label=\"Toggle dropdown\"\n        aria-haspopup=\"true\"\n        aria-expanded={isOpen}\n        type=\"button\"\n        onClick={() => setIsOpen(!isOpen)}\n        className={classNames(\n          \"flex justify-between items-center gap-5 rounded w-full py-2 px-4 bg-blue-500 text-white\",\n          style\n        )}\n      >\n        <span>{selectedItem?.name || title}</span>\n        <GoChevronDown\n          size={20}\n          className={classNames(\"transform duration-500 ease-in-out\", {\n            \"rotate-180\": isOpen,\n          })}\n        />\n      </button>\n      {/* Open */}\n      {isOpen && (\n        <div aria-label=\"Dropdown menu\" className={dropdownClass}>\n          <ul role=\"menu\" aria-labelledby={id} aria-orientation=\"vertical\" className=\"leading-10\">\n            {data?.map((item) => (\n              <li\n                key={item.id}\n                onClick={() => handleChange(item)}\n                className={classNames(\"flex items-center cursor-pointer hover:bg-gray-200 px-3\", {\n                  \"bg-gray-300\": selectedItem?.id === item.id,\n                })}\n              >\n                {hasImage && (\n                  <img\n                    src={item.imageUrl}\n                    alt=\"image\"\n                    loading=\"lazy\"\n                    className=\"w-8 h-8 rounded-full bg-gray-400 object-cover me-2\"\n                  />\n                )}\n                <span>{item.name}</span>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Dropdown;\n```\n\n## useOutSideClick Hook Code: ⤵️\n\nuseOutsideClick.tsx\n\n```js\nimport { useEffect } from 'react';\n\ninterface OutsideClickHandlerProps {\n  ref: React.RefObject<HTMLElement>;\n  handler: () => void;\n}\n\nconst useOutsideClick = ({ ref, handler }: OutsideClickHandlerProps) => {\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (ref.current && !ref.current.contains(event.target as Node)) {\n        handler();\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [ref, handler]);\n};\n\nexport default useOutsideClick;\n```\n\n## 샘플 데이터 (JSON): ⤵️\n\ndata.json\n\n```json\n[\n  {\n    \"id\": \"1\",\n    \"name\": \"Minnie Barrett\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1534528741775-53994a69daeb?q=80&w=1964&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"2\",\n    \"name\": \"Andy Holmes\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1506794778202-cad84cf45f1d?q=80&w=1887&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"3\",\n    \"name\": \"Felicia Watts\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1544005313-94ddf0286df2?q=80&w=1888&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"4\",\n    \"name\": \"Hailey Green\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1494790108377-be9c29b29330?q=80&w=1887&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"5\",\n    \"name\": \"Jeremiah Hughes\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1500648767791-00dcc994a43e?q=80&w=1887&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  },\n  {\n    \"id\": \"6\",\n    \"name\": \"Amy Perkins\",\n    \"imageUrl\": \"https://images.unsplash.com/photo-1587677171791-8b93c752999b?q=80&w=1949&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n  }\n]\n```\n\nGithub 주소:\n\n실시간 데모:\n\n## 결론\n\n요약하자면, React 애플리케이션에서 사용할 수 있는 사용자 정의 Dropdown 컴포넌트가 생성되고 설명되었습니다. 이 컴포넌트는 다양한 위치와 스타일에서 활용될 수 있으며 사용자가 목록에서 항목을 선택할 수 있게 합니다. TypeScript, Tailwind CSS, React Icons 및 Classnames를 사용하여 개발된 이 Dropdown 컴포넌트는 사용자 인터페이스 개발 프로세스에서 상당한 편의성을 제공하며 React 애플리케이션에서 널리 사용될 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaCustomDropdownComponentinReactStepbyStep_0.png","tag":["Tech"],"readingTime":12},{"title":"Expo Dev Client 설치 방법 완벽한 가이드 2024","description":"","date":"2024-05-12 19:08","slug":"2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024","content":"\n\n<img src=\"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_0.png\" />\n\n# 그럼, 시작해봅시다!\n\n다음 튜토리얼은 Windows 기기용으로 제작되었으며, 특히 Windows 10 (64비트)에 맞춰져 있습니다. 만약 맥이나 리눅스를 사용하고 계신다면, 전반적인 과정을 이해하기 위해 읽어보세요.\n\n## 목차 —\n\n\n\n- Java Development Kit (JDK)을 설치하세요.\n- 환경 변수 설정: JAVA_HOME 및 JAVA 경로\n- Android Studio 다운로드\n- SDK 및 빌드 도구 구성\n- Android 에뮬레이터 구성\n- Android 환경 변수 설정: ANDROID_HOME 및 경로\n- NodeJS 설치\n- Expo 프로젝트 설정\n- Expo 개발 클라이언트 설정 및 Expo 프로젝트 로컬에서 컴파일\n- 첫 번째 디버그-개발 빌드 생성\n\n## Expo Dev Client는 무엇인가요?\n\n공식 Expo 문서에 따르면, Expo Go 대신 개발 빌드를 선택하면 원시 런타임을 완전히 제어할 수 있습니다. 이를 통해 원시 라이브러리를 설치하거나 프로젝트 구성을 조정하거나 심지어 고유의 원시 코드를 작성할 수 있습니다.\n\n더 간단하게 말하면, 기본 Expo 구성은 프로젝트를 Expo 클라우드에 업로드한 다음 빌드를 받는 과정으로 진행됩니다. 그러나 이 프로세스는 Expo 라이브러리만 원활하게 지원합니다. @react-native-google-signin/google-signin과 같은 원시 라이브러리를 사용할 경우 이와 같은 방식으로 작동하지 않습니다.\n\n\n\n## Expo Dev Client 설정하기: 단계별 안내\n\n이 튜토리얼에서는 JAVA Development Kit (JDK), 안드로이드 스튜디오 및 Node가 필요합니다.\n\nOracle 또는 OpenJDK 플랫폼을 방문하여 JDK를 다운로드하고 Gradle 버전과 호환되는지 확인하십시오. 2024년 기준으로 React Native는 Gradle 8.3을 사용하고 있으며 이는 JDK 17과 호환됩니다.\n\n설치 가이드를 따르고 JAVA를 설치하는 경로를 메모해두세요. 기본적으로 C:\\Program Files\\Java\\jdk-17 경로에 설치됩니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_1.png\" />\n\n시스템 속성에서 ‘환경 변수’를 검색하세요. 이 섹션에서 사용자 계정과 시스템 변수가 있습니다. 둘 다 변수를 설정하는 것이 좋습니다.\n\n다음 단계를 따르세요:\n\n- ‘JAVA_HOME’이라는 이름의 새 변수를 시스템 및 사용자 변수에 생성하고 JDK를 설치한 경로를 입력하세요\n(예: C:\\Program Files\\Java\\jdk-17).\n- 시스템 변수 아래에 ‘Path’ 변수를 찾으세요. ‘jdk/bin’ 폴더의 경로를 추가하세요 (예: C:\\Program Files\\Java\\jdk-17\\bin).\n\n\n\n드디어 설치를 확인하려면 명령 프롬프트(cmd)에서 'java -version'을 실행해주세요. 제대로 설정했다면 자바 버전 정보가 표시될 것입니다.\n\n에뮬레이터, SDK 및 플랫폼 도구를 설치하려면 안드로이드 스튜디오가 필요합니다. 또한 IDE를 통해 로컬 빌드를 실행할 수도 있습니다.\n\n공식 안드로이드 웹사이트에 방문하여 최신 IDE를 다운로드하세요. 기본 설치 가이드를 따라 설치 경로를 기억해주세요.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_2.png)\n\n\n\n설치를 완료한 후 안드로이드 스튜디오를 열고 SDK 관리자를 엽니다.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_3.png)\n\n호환성을 위해 가장 최신 SDK 버전과 바로 전 버전을 함께 설치해주세요. 예를 들어, 현재 가장 최신 SDK 버전은 34이므로 33 버전도 설치하시면 됩니다.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_4.png)\n\n\n\nSDK와 함께 필요한 도구들이 있습니다. 기본적으로 설치되는 일부 도구들 외에 추가로 필요한 것들이 있습니다:\n\n- 안드로이드 SDK 명령줄 도구\n- 안드로이드 SDK 플랫폼 도구\n- 안드로이드 SDK 빌드 도구\n- 안드로이드 에뮬레이터\n- Google Play 라이센스 라이브러리 (선택 사항)\n\n체크박스를 선택하고 적용을 클릭하면 설치됩니다.\n\n![Android SDK](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_5.png)\n\n\n\n당신의 어플리케이션을 실행하기 위한 기본 에뮬레이터를 설정해야 합니다. 장치에서 어플리케이션을 실행할 수도 있지만, 적어도 하나의 에뮬레이터가 있어야 합니다.\n\n가상 장치 관리자로 이동해주세요.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_6.png)\n\n처음에는 새로운 장치가 보이지 않을 수 있습니다. + 아이콘 '새 가상 장치 생성'을 클릭하고, 장치를 선택한 후 '다음'을 클릭하여 OS 버전과 세로 방향을 선택해주세요.\n\n\n\n새 장치를 설정하는 동안 Intel HAXM 설치 실패와 관련된 오류가 발생할 수 있습니다. 이를 해결하기 위해 Stack Overflow 답변 가이드를 따르세요.\n\n설치가 완료되면 가상 장치를 실행할 수 있어야 합니다. 로딩에 몇 분이 소요될 수 있으니 조급해하지 마세요.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_7.png)\n\nExpo 및 React Native가 SDK 도구에 올바르게 액세스할 수 있도록 환경 변수 섹션에서 해당 경로를 선언해야 합니다. 2단계와 유사하게 진행하세요.\n\n\n\nSDK 도구가 설치된 위치는 기본적으로 SDK 관리자에서 제공됩니다. 사용자/AppData 디렉토리에 있습니다.\n\n파일 탐색기에서 해당 경로로 이동해주세요. 사용자 계정 내의 'AppData' 폴더는 기본적으로 숨겨져 있습니다. '숨겨진 파일 표시'를 활성화해야 'AppData' 폴더에 액세스할 수 있습니다.\n\n이제 환경 변수를 다시 엽니다.\n\n- 시스템 및 사용자 변수에서 'ANDROID_HOME'이라는 정확한 이름의 새 변수를 만들고 SDK를 설치한 경로(C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk)를 포함시킵니다.\n- 이제 시스템 및 사용자 변수에 위치한 'Path' 변수에 다음 경로를 추가하세요. '사용자명'을 실제 계정명으로 교체해주세요:\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\\platform-tools\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\\emulator\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\\tools\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\\tools\\bin\n\n\n\n마침내 CMD 내에서 ADB 쉘을 실행할 수 있어야 합니다. 설정을 확인하려면 'adb --version'을 실행하세요.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_8.png)\n\nNode의 안정 버전을 다운로드하세요. 저는 현재 18.18.0을 사용 중이며 기본 설치 가이드를 따르면 됩니다.\n\nCMD 내에서 'node --version' 명령으로 설치를 확인하세요.\n\n\n\n```md\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_9.png)\n\n마침내, 우리는 Expo 애플리케이션을 시작할 수 있습니다. 저는 NativeWind-Tailwind 지원, 최신 Expo SDK 50, Expo 파일 기반 라우팅, React Reanimated 라이브러리 및 TypeScript 통합을 포함한 애플리케이션을 설정하는 데 다음 예제를 사용합니다.\n\n```js\nnpx create-expo-app -e with-router-tailwind\n```\n\n프로젝트가 작동하고 오류가 없는지 확인하세요. Play Store 또는 App Store에서 실제 기기에 Expo Go Client를 다운로드하세요. 그런 다음 아래 명령을 실행하여 QR 코드를 스캔하여 기기에서 Expo 애플리케이션을 실행하세요. 이제 Expo Go Client로 애플리케이션을 실행 중임을 주의하세요.\n```  \n\n\n\n```js\r\nnpm run start\r\n```\n\n만약 모든 것이 올바르게 작동하고 있다면 Expo 대시보드에 로그인하기 위해 EAS CLI를 다운로드하십시오.\n\n```js\r\nnpm install --global eas-cli\r\n```\n\n작업을 완료한 후에는 다음 명령어를 사용하여 대시보드에 로그인하십시오. Expo 계정이 없다면 여기에서 생성하십시오.\n\n\n\n```js\neas login  // 사용자 이름과 비밀번호를 입력하라는 프롬프트가 나타납니다.\neas whoami // 사용자 이름을 반환합니다.\n```\n\neas.json 파일을 만들어서 빌드 구성 파일로 사용하세요. 이 파일에는 세 가지 프로필이 있습니다. 여기에서 자세히 알아보세요. eas.json 파일을 만들려면 프로젝트 터미널에서 다음 명령을 실행하세요.\n\n```js\neas:configure\n```\n\neas.json 파일을 업데이트하여 빌드 유형을 APK로 지정하여 기기에 직접 설치할 수 있도록 했습니다.\n\n\n\n```js\n{\n  \"cli\": {\n    \"version\": \">= 7.2.0\"\n  },\n  \"build\": {\n    \"development\": {\n      \"developmentClient\": true,\n      \"distribution\": \"internal\",\n      \"android\": {\n        \"buildType\": \"apk\"\n      }\n    },\n    \"preview\": {\n      \"distribution\": \"internal\",\n      \"android\": {\n        \"buildType\": \"apk\"\n      }\n    },\n    \"production\": {}\n  },\n  \"submit\": {\n    \"production\": {}\n  }\n}\n```\n\n검증을 위해, 다음 명령을 사용하여 Expo 대시보드 내에서 미리보기 프로필로 Expo 애플리케이션을 빌드할 수 있습니다. 그러나 주의해야 할 점은 developmentClient가 true로 설정되어 있기 때문에 개발용 빌드는 불가능합니다.\n\n```js\neas build -p android --profile preview\n```\n\n개발 환경을 설정하는 필수 헤더를 애플리케이션에 추가하는 Expo Dev Client 라이브러리를 설치해야 합니다. 프로젝트 터미널에서 아래 명령을 실행하세요.\n\n\n\n```js\nnpx expo install expo-dev-client\n```\n\n참고: 이 라이브러리를 설치하면 Expo 프로젝트를 실행하는 기본 구성(npm run start 사용)이 개발 빌드로 전환됩니다. 따라서 Expo Go Client 모바일 애플리케이션이 작동하지 않습니다. Expo Client 내에서 실행하려면 터미널을 사용하여 Expo Go로 전환해야 합니다. 또한, 네이티브 라이브러리를 사용하고 있지 않은지 확인하세요.\n\n<img src=\"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_10.png\" />\n\n다음 명령을 사용하여 프로젝트를 로컬에서 컴파일하세요.```\n\n\n\n```js\nnpx expo run:android \n```\n\n이 명령은 이전에 설치한 JDK 및 SDK 도구를 사용하여 Gradle 파일을 생성합니다. 먼저 프로젝트 내에 .android 폴더를 만들고 응용 프로그램을 실행하기 위해 에뮬레이터를 시작합니다. 컴파일 프로세스는 약 15분 이상 소요되므로 조금만 기다려주십시오.\n\n첫 번째 개발 빌드를 생성하려면 다음 명령을 사용하십시오:\n\n```js\neas build --profile development --platform android\n```  \n\n\n\n이 작업은 EAS 서버로 애플리케이션을 컴파일하는 것입니다. 로그인한 후 대시보드에서 진행 상황을 확인할 수 있어요.\n\n작업이 완료되면 \"설치\" 버튼을 클릭하여 애플리케이션 (APK)을 다운로드할 수 있어요. 추가로 터미널에서는 애플리케이션을 에뮬레이터 내에서 실행할 것인지 선택하라고 안내할 거에요. 저는 애플리케이션을 실제 장치에서 실행하는 것을 선호하니, 같은 취향을 가진다면 모바일 브라우저에서 링크를 열고 애플리케이션을 다운로드하세요.\n\n참고: 애플리케이션 크기에 대해 걱정하지 마세요; 최적화되지 않은 APK 빌드입니다.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_11.png)\n\n\n\n앱을 다운로드하고 설치한 후, 맨 위에 앱 이름과 함께 다음과 같은 인터페이스가 표시됩니다.\n\n![앱 인터페이스](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_12.png)\n\n이제 프로젝트 터미널로 돌아가서 다음 명령을 실행해보세요:\n\n```js\nnpx expo start --dev-client\n```\n\n\n\n처음에 애플리케이션은 개발 서버를 자동으로 감지하지 못할 수 있습니다. 따라서 수동으로 URL을 입력해야 합니다. 위 명령으로 코드를 컴파일한 후에는 localhost URL을 제공할 것입니다. 예를 들어, http://localhost:8081과 같이 나올 겁니다.\n\n애플리케이션에서 \"localhost\" 부분을 자신의 IP 주소로 바꾸세요. 핸드폰이 동일한 Wi-Fi 네트워크에 연결되어 있는지 확인한 후, 애플리케이션에서 http://192.168.0.100:8081과 같이 수동으로 URL을 입력하세요. 그러면 애플리케이션이 로드되고, Expo Go Client와 유사한 핫 리프레시 기능을 지원할 겁니다.\n\n참고: 새 라이브러리를 설치할 때마다 위 명령을 사용하여 애플리케이션을 다시 빌드하고, 기기에 최신 빌드를 다운로드/설치해야 합니다.\n\n그러니까, 한숨을 내쉬세요. Expo 개발 클라이언트 설정이 완료되었습니다. 건배! 🥂\n\n\n\n어려움이 있으면 언제든지 연락해주세요.\nLinkedIn | Twitter (X)","ogImage":{"url":"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_0.png","tag":["Tech"],"readingTime":8},{"title":"NET Core에서 웹 소켓과 SignalR을 활용한 실시간 데이터 전송","description":"","date":"2024-05-12 19:05","slug":"2024-05-12-Real-TimeDataTransferwithWebSocketsandSignalRinNETCore","content":"\n\n실시간 데이터 전송은 즉각적인 업데이트와 알림이 필요한 애플리케이션에 꼭 필요합니다. .NET Core에서 WebSockets 및 SignalR은 클라이언트와 서버 간의 실시간 통신을 구현하는 강력한 도구를 제공합니다. 이 안내서에서는 WebSockets 및 SignalR을 사용하여 .NET Core 애플리케이션에서 실시간 데이터 전송을 어떻게 구현하는지 살펴볼 것입니다.\n\nDotNet-FullStack-Dev와 함께 계속해서 학습과 탐험의 여정을 떠나보세요. 더 많은 정보 확인은 https://dotnet-fullstack-dev.blogspot.com을 방문하거나 추가 정보를 얻으려면 연락해주세요.\n\n# WebSockets 및 SignalR이란?\n\n# WebSockets:\n\n\n\nWebSockets는 단일 TCP 연결을 통해 전 이중 통신 채널을 제공하는 프로토콜입니다. 이를 통해 클라이언트와 서버 간에 양방향 통신이 가능하며 HTTP 폴링의 오버헤드 없이 비동기적으로 데이터를 송수신할 수 있습니다.\n\n# WebSockets를 사용해야 하는 이유\n\n- 실시간 통신: WebSockets를 이용하면 실시간 데이터 전송이 가능해지며, 채팅 애플리케이션, 실시간 대시보드, 온라인 게임 플랫폼과 같은 즉각적인 업데이트가 필요한 애플리케이션에 이상적입니다.\n- 효율성: 전통적인 HTTP 폴링이나 롱 폴링 기술과 달리 WebSockets는 지속적인 연결을 유지하여 오버헤드를 줄이고 지연 시간을 최소화하며 네트워크 트래픽을 감소시킵니다.\n- 전 이중 통신: WebSockets는 양쪽으로 동시에 데이터 전송을 지원하여 클라이언트와 서버가 독립적으로 메시지를 송수신할 수 있습니다.\n- 확장성: WebSockets는 대규모 동시 연결을 효율적으로 처리할 수 있어 확장 가능하고 고성능 애플리케이션에 적합합니다.\n\n# WebSockets 대안:\n\n| **대안**                  | **설명**                                                                                                    |\n|-----------------------|---------------------------------------------------------------------------------------------------------|\n| Server-Sent Events    | 서버에서 클라이언트로 단 방향 메시지 스트림을 전송하는 기술로, WebSockets와 유사하지만 단방향 통신만 지원합니다.   |\n| Long Polling           | 클라이언트가 서버에게 요청을 보내고, 서버는 데이터를 준비할 때까지 응답을 지연시키는 방법입니다.                  |\n\n\n\n웹소켓은 실시간 통신에 널리 사용되지만, 유사한 기능을 제공하는 몇 가지 대안이 있습니다:\n\n- Server-Sent Events (SSE): SSE은 서버가 HTTP 연결을 통해 클라이언트로 업데이트를 푸시할 수 있는 단방향 통신 프로토콜입니다. 웹소켓과 달리 SSE는 서버에서 클라이언트로의 통신에만 제한되며 양방향 통신을 지원하지 않습니다.\n- Long Polling: Long Polling은 클라이언트가 서버에 요청을 보내고, 서버가 새로운 데이터가 나타날 때까지 연결을 유지하거나 타임아웃이 발생할 때까지 연결을 열어두는 기술입니다. Long Polling은 실시간 업데이트를 달성할 수 있지만, 연결을 자주 열고 닫기 때문에 웹소켓보다 효율성이 떨어집니다.\n\n# 웹소켓의 장단점:\n\n## 장점:\n\n\n\n- 실시간 업데이트: 웹 소켓을 통해 실시간 통신이 가능하며 클라이언트에 즉시 업데이트를 제공합니다.\n- 효율성: 웹 소켓은 폴링 기술과 비교하여 대기 시간과 네트워크 오버헤드를 줄입니다.\n- 전이중 통신: 양방향 데이터 전송을 지원하여 클라이언트와 서버가 동시에 메시지를 보내고 받을 수 있습니다.\n- 확장성: 웹 소켓은 많은 동시 연결을 효율적으로 처리할 수 있어 확장 가능한 애플리케이션에 적합합니다.\n\n## 단점:\n\n- 복잡성: 웹 소켓 연결을 구현하고 관리하는 것은 전통적인 HTTP 통신보다 더 복잡할 수 있습니다.\n- 브라우저 지원: 최신 브라우저는 웹 소켓을 지원하지만 오래된 브라우저는 지원하지 않을 수 있어 대체 메커니즘이 필요할 수 있습니다.\n- 방화벽 문제: 웹 소켓은 제한적인 방화벽이나 프록시 서버에서 웹 소켓 트래픽을 차단할 수 있는 문제가 있을 수 있습니다.\n\n# SignalR:\n\n\n\nSignalR은 .NET 애플리케이션에서 실시간 웹 기능을 간단하게 만드는 데 사용되는 웹소켓과 기타 전송 매커니즘 위에 구축된 고수준 라이브러리입니다. 이는 연결 관리를 추상화하고 클라이언트에게 메시지를 브로드캐스트하고 클라이언트-서버 통신을 다루기 위한 간단한 API를 제공합니다.\n\n# SignalR을 사용해야 하는 이유:\n\n- 간단한 개발: SignalR은 웹소켓 연결 관리의 복잡성을 감추고 .NET 애플리케이션에서 실시간 기능을 구현하기 위한 간단한 API를 제공합니다. 연결 관리, 메시지 라우팅 및 오류 처리를 처리하여 개발자가 응용프로그램 논리에 집중할 수 있습니다.\n- 크로스 플랫폼 지원: SignalR은 서버 측 .NET 애플리케이션 및 클라이언트 측 JavaScript 프레임워크를 모두 지원하여 웹 애플리케이션, 데스크톱 애플리케이션 및 모바일 앱에서 실시간 기능을 구축하기에 적합합니다.\n- 확장성: SignalR은 애플리케이션과 함께 확장되도록 설계되어 많은 동시 연결을 지원하며 다중 서버로 확장하거나 Azure SignalR 서비스와 같은 클라우드 기반 솔루션을 사용할 수 있는 옵션을 제공합니다.\n- 후행 메커니즘: SignalR은 웹소켓을 지원하지 않는 클라이언트를 위해 Server-Sent Events (SSE) 또는 롱 폴링과 같은 대체 전송 메커니즘으로 자동으로 후행하므로 브라우저 및 기기에 걸쳐 넓은 호환성을 보장합니다.\n\n\n\n신호R이 .NET 애플리케이션에서 실시간 웹 기능을 구현하는 데 인기 있는 선택지라는 것을 알고 계실 겁니다. 그러나 여러 대안들도 비슷한 기능을 제공합니다:\n\n- Raw WebSocket APIs: 개발자들은 .NET이나 다른 프로그래밍 언어에서 제공하는 Raw WebSocket APIs를 활용하여, SignalR이 제공하는 추상화 없이 실시간 통신을 구현할 수 있습니다. 그러나 이 방식은 더 많은 수동 구성을 요구하며, 개발자들에게는 불편할 수도 있습니다.\n- Third-Party Libraries: .NET 애플리케이션에서 실시간 통신을 구현하는 데 사용할 수 있는 외부 라이브러리들이 있습니다. Socket.IO for .NET이나 Fleck과 같은 라이브러리들은 추가 기능과 유연성을 제공하지만, 통합 및 유지보수에 더 많은 노력이 필요할 수 있습니다.\n\n# SignalR의 장단점:\n\n## 장점:\n\n\n\n- 간편한 개발: SignalR은 실시간 기능을 구현하는 데 사용하기 위한 고수준 API를 제공하여 개발 시간과 복잡성을 줄여줍니다.\n- 크로스 플랫폼 지원: SignalR은 웹 브라우저, 데스크톱 애플리케이션 및 모바일 기기를 포함한 다양한 클라이언트를 지원합니다.\n- 확장성: SignalR은 애플리케이션과 함께 확장되도록 설계되어 많은 동시 연결을 지원하고 여러 서버로 확장할 수 있는 옵션을 제공합니다.\n- 후행 메커니즘: SignalR은 웹소켓을 지원하지 않는 클라이언트를 위해 대체 전송 메커니즘으로 자동으로 후행하므로 넓은 호환성을 보장합니다.\n\n## 단점:\n\n- .NET 프레임워크/Core에 대한 의존성: SignalR은 .NET 생태계와 긴밀하게 결합되어 있어 다른 기술로 개발된 애플리케이션에는 적합하지 않을 수 있습니다.\n- 성능 부하: SignalR은 개발을 단순화하지만 원시 웹소켓 구현과 비교해 일부 성능 부하를 도입할 수 있습니다.\n- 복잡성: SignalR은 실시간 통신의 일부 복잡성을 추상화하지만 복잡한 시나리오에서는 추가 구성 및 문제 해결이 필요할 수 있습니다.\n\n# 왜 실시간 데이터 전송을 사용해야 할까요?\n\n\n\n실시간 데이터 전송은 채팅 애플리케이션, 실시간 대시보드 및 모니터링 시스템, 협업 문서 편집 도구, 온라인 게임 플랫폼, 주식 시장 추적 애플리케이션, 라이브 스포츠 점수판과 같이 실시간 업데이트가 필요한 애플리케이션에 필수적입니다.\n\n# SignalR을 사용한 .NET Core 구현\n\n## 단계 1: SignalR 설치\n\n\n\nNuGet Package Manager를 사용하여 SignalR 패키지를 설치하세요:\n\n```js\ndotnet add package Microsoft.AspNetCore.SignalR\n```\n\n## 단계 2: SignalR 허브 만들기\n\n클라이언트 연결을 관리하고 메시지 브로드캐스팅을 처리하는 SignalR 허브를 만드세요.\n\n\n\n```js\nMicrosoft.AspNetCore.SignalR를 사용하여 SignalR을 구성하고 있어요. WebSocket 지원을 활성화하고 허브 엔드포인트를 매핑하려면 Startup 클래스에서 SignalR을 구성하세요.\n\n```js\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSignalR();\n}\n\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapHub<ChatHub>(\"/chatHub\");\n    });\n}\n```\n\n\n\n## 단계 4: 클라이언트 측 통합\n\n클라이언트 측에 SignalR을 통합하여 연결을 설정하고 실시간 업데이트를 받으세요.\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n    <title>SignalR 채팅</title>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/signalr/5.0.0/signalr.min.js\"></script>\n</head>\n<body>\n    <div id=\"messages\"></div>\n    <input type=\"text\" id=\"messageInput\" />\n    <button onclick=\"sendMessage()\">전송</button>\n\n    <script>\n        const connection = new signalR.HubConnectionBuilder()\n            .withUrl(\"/chatHub\")\n            .build();\n\n        connection.on(\"ReceiveMessage\", (user, message) => {\n            document.getElementById(\"messages\").innerHTML += `<p><strong>${user}</strong>: ${message}</p>`;\n        });\n\n        connection.start().then(() => {\n            console.log(\"SignalR 허브에 연결되었습니다\");\n        }).catch((err) => {\n            console.error(\"SignalR 허브에 연결하는 중 오류가 발생했습니다:\", err);\n        });\n\n        function sendMessage() {\n            const user = \"사용자\"; // 입력값으로부터 사용자 정보 가져오기\n            const message = document.getElementById(\"messageInput\").value;\n            connection.invoke(\"SendMessage\", user, message);\n        }\n    </script>\n</body>\n</html>\n```\n\n이 예제를 확장하여 클라이언트로부터 메시지를 받고 백엔드와 프론트엔드 코드를 사용한 엔드 투 엔드 솔루션을 제공해보죠.\n\n\n\n# Backend: ASP.NET Core Web API with SignalR\n\n## Step 1: SignalR 허브 생성\n\n클라이언트 연결을 관리하고 메시지 브로드캐스팅을 처리하는 SignalR 허브를 생성하세요.\n\n```javascript\nusing Microsoft.AspNetCore.SignalR;\nusing System.Threading.Tasks;\n\npublic class ChatHub : Hub\n{\n    public async Task SendMessage(string user, string message)\n    {\n        await Clients.All.SendAsync(\"ReceiveMessage\", user, message);\n    }\n\n    public void ReceiveMessage(string user, string message)\n    {\n        // 받은 메시지 처리(예: 데이터베이스 저장, 처리 등)\n    }\n}\n```\n\n\n\n## 단계 2: Startup에서 SignalR 구성\n\nStartup 클래스에서 SignalR을 구성하여 WebSocket 지원을 활성화하고 허브 엔드포인트를 매핑합니다.\n\n```js\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSignalR();\n}\n\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapHub<ChatHub>(\"/chatHub\");\n    });\n}\n```\n\n## 단계 3: 메시지 수신을 위한 컨트롤러 생성\n\n\n\n클라이언트로부터 수신된 메시지를 처리하는 컨트롤러를 만들어보세요.\n\n```js\nusing Microsoft.AspNetCore.Mvc;\n\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class ChatController : ControllerBase\n{\n    private readonly IHubContext<ChatHub> _hubContext;\n\n    public ChatController(IHubContext<ChatHub> hubContext)\n    {\n        _hubContext = hubContext;\n    }\n\n    [HttpPost(\"ReceiveMessage\")]\n    public async Task<IActionResult> ReceiveMessage(string user, string message)\n    {\n        await _hubContext.Clients.All.SendAsync(\"ReceiveMessage\", user, message);\n        return Ok();\n    }\n}\n```\n\n# Frontend: React UI with SignalR\n\n## Step 1: SignalR 클라이언트 라이브러리 설치\n\n\n\nJavaScript SignalR 클라이언트 라이브러리를 npm을 사용해서 설치해주세요.\n\n```js\nnpm install @microsoft/signalr\n```\n\n## 단계 2: WebSocket 연결 생성\n\nSignalR 허브에 대한 WebSocket 연결을 생성하고 들어오는 메시지를 처리하세요.\n\n\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport * as signalR from '@microsoft/signalr';\n\nconst Chat = () => {\n    const [messages, setMessages] = useState([]);\n    const [connection, setConnection] = useState(null);\n\n    useEffect(() => {\n        const newConnection = new signalR.HubConnectionBuilder()\n            .withUrl(\"/chatHub\")\n            .build();\n\n        newConnection.on(\"ReceiveMessage\", (user, message) => {\n            setMessages([...messages, { user, message }]);\n        });\n\n        newConnection.start()\n            .then(() => console.log(\"SignalR 허브에 연결되었습니다.\"))\n            .catch(error => console.error(\"SignalR 허브에 연결 중 오류 발생:\", error));\n\n        setConnection(newConnection);\n    }, []);\n\n    const sendMessage = () => {\n        const user = \"User\"; // 입력에서 사용자 가져오기\n        const message = \"안녕, SignalR!\"; // 입력에서 메시지 가져오기\n        connection.invoke(\"SendMessage\", user, message)\n            .catch(error => console.error(\"메시지 전송 중 오류 발생:\", error));\n    };\n\n    return (\n        <div>\n            <div>\n                {messages.map((message, index) => (\n                    <div key={index}>\n                        <strong>{message.user}</strong>: {message.message}\n                    </div>\n                ))}\n            </div>\n            <input type=\"text\" />\n            <button onClick={sendMessage}>전송</button>\n        </div>\n    );\n};\n\nexport default Chat;\n```\n\n# 결론\n\n이 가이드에서는 .NET Core 애플리케이션에서 웹소켓과 SignalR을 사용하여 실시간 데이터 전송을 구현하는 방법을 살펴보았습니다. SignalR을 활용하면 클라이언트와 서버 간의 실시간 통신을 쉽게 구현할 수 있어서 상호작용적이고 협업이 가능한 웹 애플리케이션을 구축하기에 이상적입니다. 채팅 애플리케이션, 실시간 대시보드, 멀티플레이어 게임을 구축할 때, 사용자에게 실시간 업데이트를 제공하는 데 필요한 도구를 제공하는 SignalR을 사용할 수 있습니다.\n\n이 가이드에서는 .NET Core 백엔드와 React 프런트엔드를 사용하여 SignalR을 통한 실시간 메시징을 구현하는 방법을 안내했습니다. 사용자는 프런트엔드에서 메시지를 보내고, 백엔드 SignalR 허브에서 모든 연결된 클라이언트에게 메시지를 수신 및 브로드캐스트합니다. 이 최종 솔루션은 웹 애플리케이션에 대한 실시간 메시징 경험을 원활하게 제공합니다.\n```\n\n\n\n표 태그를 Markdown 형식으로 변경해주실래요.","ogImage":{"url":"/assets/img/2024-05-12-Real-TimeDataTransferwithWebSocketsandSignalRinNETCore_0.png"},"coverImage":"/assets/img/2024-05-12-Real-TimeDataTransferwithWebSocketsandSignalRinNETCore_0.png","tag":["Tech"],"readingTime":10},{"title":"리액트에서 내 상태가 비용이 드는 걸까요","description":"","date":"2024-05-12 19:04","slug":"2024-05-12-Ismystateinreactgoingtocostme","content":"\n\n경고: 테이블을 있는 그대로 사용하면 약간 어색해보일 수 있어요. 대신 Markdown 형식을 사용하면 보기가 편할 거예요.\n\n\n\n각 사용 사례에 맞는 다양한 상태 솔루션이 있어요.\n\n성능을 균형 있게 유지하면서 React를 다시 렌더링해야 할 때는 신중히 생각해야 해요.\n\n캔버스 기반 인터페이스를 구축하기 위해 설계된 상태 라이브러리를 사용하려고 하면 가져다쓰는 데 비용이 들 거예요.\n\n그렇다고 해서 사용 중인 것보다 훨씬 나을지도 몰라요.\n\n\n\n하지만 현실에서는 단순히 보스턴에서 뉴욕으로 돌아오는 길에 걷는 것에서 자전거로 전환하지 않을 것입니다. 대신 버스를 타거나 택시를 잡을 것입니다.\n\n상태 라이브러리를 의도하지 않은 용도로 사용하면 예상치 못한 문제들이 쏟아질 수 있습니다.\n\n머릿속에서 처음부터 다시 작성할 지식 없이 상태 라이브러리를 건드린다면, 의도하지 않은 용도로 사용하기에 적격하지 않을 가능성이 높습니다.\n\n시간을 절약하고 사용 사례에 완벽하거나 거의 완벽하게 맞는 것을 찾아보세요.\n\n\n\n정밀도가 중요합니다. X가 Y보다 나은 것이 절대 아닙니다. 0.1235 해결책을 원하는 이유는 3.01234 문제를 완벽하게 해결하기 위해서입니다.\n\n문자열이나 부울 플래그 이상을 제어하는 데 단순한 useState를 사용하고 있나요? 한 발 물러나서서 해결하려는 상태 문제에 대해 실제로 무엇이 있는지 살펴보세요.\n\nGithub에서 날짜가 지나지 않은 몇 가지 실제 예제를 찾아보세요. 다른 사람이 어떻게 해당 문제를 해결했는지 확인해보세요. 어떤 문제를 해결하려고 하는 건가요? 트위터에서 누군가에게 질문해보세요.\n\n\n\nReact에서 상태(State)는 가장 중요한 요소 중 하나이며 그에 맞게 다뤄져야 합니다.\n\n상태(State)는 응용 프로그램을 더 확장하려는 시도에서 빠르게 병목 현상이 발생할 수 있기 때문에 중요합니다. 비즈니스 요구 사항이 변경될 때 새로운 기능을 추가하거나 상태를 리팩토링하는 것이 지루하게 느려질 수 있습니다.\n\n폼 데이터를 처리하기 위한 상태(State) 솔루션이 있습니다.\n\n이 솔루션은 각 층을 추가하거나 제거할 때마다 고난을 겪지 않도록 해줍니다. 화면을 다시 렌더링하고 대부분의 유효성 검사 코드를 직접 작성하지 않아도 되도록 캡슐화되어 있습니다.\n\n\n\n작은 상태를 공유할 수 있는 상태 솔루션이 있습니다.\n\n귀하의 사용 사례가 독특한 점은 무엇이며, 어떤 점을 연결하려고 하고 계십니까? 애니메이션 조율이 포함되어 있습니까? 그 중 어떤 솔루션이 귀하의 사용 사례에 완벽하거나 거의 완벽하게 맞나요?\n\n데이터를 처리할 수 있는 가벼운 상태 솔루션이 있습니다.\n\n또한 기본으로 캐싱을 지원하며 통합하는 데 1분만 걸립니다. 최대한 빨리 목표를 달성하기 위해 최소한으로 노력할 수 있는 것은 무엇일까요. 이는 성의 없는 일을 하도록 장려하는 것이 아닙니다.\n\n\n\n리액트의 가장 역동적인 측면 중 하나입니다.\n\n다른 사람들도 같은 문제에 부딪혔고 그 후 오픈 소스 라이브러리를 만들었으며, 다른 사람들이 차후에 기여함으로써 궁극적으로 당신이 가장 많은 혜택을 누릴 수 있게 되었습니다.\n\n정말 놀랍다는 것에 대해 잠시 생각해 보세요.\n\n리액트는 10년이 넘는 시간 동안 존재해 왔으며 아직도 브라우저를 위한 최고의 인터페이스 도구로 남아 있습니다. 당신의 문제에 도전한 사람이 있고 그의 해결책이 npm 라이브러리로 확장되었을 가능성이 아주 높습니다.\n\n\n\n\n네, 라이브러리를 설계할 때 사용 사례가 심각하게 고려되었는지 알아야 합니다.\n\n네, 라이브러리가 여전히 유지보수되고 프로젝트 기간 동안 계속 사용될지 평가해야 합니다.\n\n네, 라이브러리 패턴이 코드베이스 전반에 퍼지는 과정을 평가해야 합니다.\n\n수 시간의 연구와 평가는 귀하에게 주간의 머리 아픔을 덜어줄 것입니다. 도움이 되었나요?\n\n\n\n이 문제를 해결하려고 하는 건 무엇인가요?\n잘 모르겠더라도 걱정하지 마세요. 이 질문이 당신이 처음부터 잘못된 상태 라이브러리를 선택하고 그에 따라 큰 규모로 이어지는 엄청난 비용을 피할 수 있게 해줄 거예요. 실제로 쉽게 되돌아설 수 없게 되서 자신의 하우스 오브 카드를 그 기반 위에 쌓으신 후에 그게 어려운 상황으로 변해버리는 걸 방지할 거예요.\n\n자신의 사용 사례를 정의하고\n해결 방법을 찾기 전에\n\n\n\n코딩하기 전에 조심해! \n\n멍청한 실수는 피해야 해. 준비가 되어 있고 빨리 움직일 수 있는 자세가 필요해.\n\n그렇지 않으면 비용이 발생할 거야.","ogImage":{"url":"/assets/img/2024-05-12-Ismystateinreactgoingtocostme_0.png"},"coverImage":"/assets/img/2024-05-12-Ismystateinreactgoingtocostme_0.png","tag":["Tech"],"readingTime":3},{"title":"풀 스택 튜토리얼 React와 NodejsAWS S3에서 사전 서명된 URL로 안전한 파일 업로드하기","description":"","date":"2024-05-12 19:03","slug":"2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3","content":"\n\n안녕하세요! 안전한 파일 업로드 시스템을 구축하는 방법에 대한 포괄적인 자습서에 오신 것을 환영합니다. 이 가이드에서는 React 프런트엔드 설정부터 Node.js 백엔드(Express 사용) 생성 및 안전한 저장소로 AWS S3를 활용하는 전체 프로세스를 안내해 드릴 것입니다.\n\n![이미지](/assets/img/2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3_0.png)\n\n## 왜 Presigned URLs를 사용해야 하는가?\n\n기존 파일 업로드 시스템에서는 클라이언트가 서버를 통해 파일을 전달하고, 서버가 해당 파일을 저장소에 업로드하는 방식으로 작동합니다. 이 방법은 작동은 하지만 대용량 파일 처리 시 효율적이거나 안전하지 않을 수 있습니다. 여기서 Presigned URLs가 등장합니다.\n\n\n\n**사전 서명된 URL**을 사용하면 클라이언트가 스토리지 제공 업체, 이 경우 AWS S3와 직접 상호 작용할 수 있습니다. 백엔드는 클라이언트에게 시간 제한이 있는 안전한 링크인 사전 서명된 URL을 생성하여 전달합니다. 클라이언트는 서버가 파일 데이터를 처리하지 않고도 파일을 S3에 직접 업로드할 수 있습니다. 이는 서버 부하를 줄이는 것뿐만 아니라 스토리지 자격 증명의 노출을 제한하여 보안을 강화하는 데 도움이 됩니다.\n\n## 사용된 기술\n\n프론트엔드: React, 백엔드: Node.js와 Express, 스토리지: AWS S3.\n\n## 앞으로의 여정\n\n\n\n이 강좌에는 프론트엔드, 백엔드 및 AWS S3 세 가지 주요 섹션이 있습니다.\n먼저 프론트엔드 설정부터 시작하여 React 및 AWS S3의 사전 서명 된 URL을 사용하여 강력한 파일 업로드 솔루션을 구축해 보겠습니다!\n\n# 프론트엔드 설정-( 파트 1 )\n\n## 단계 1: React 앱 설정\n\n먼저 Create React App을 사용하여 새 React 앱을 만들어 보겠습니다:\n\n\n\n```js\nnpx create-react-app presigned-url-upload\ncd presigned-url-upload\n```\n\n## 단계 2: 종속 항목 설치\n\n파일 업로드 처리를 위해 필요한 패키지를 설치하세요:\n\n```js\nnpm install aws-amplify aws-amplify-react axios react-dropzone\n```\n\n\n\n## 단계 3: AWS Amplify 구성\n\n프로젝트에 AWS Amplify를 초기화합니다:\n\n```js\namplify init\n```\n\n## 단계 4: FileUpload 컴포넌트 생성\n\n\n\n새로운 FileUpload.js 컴포넌트를 생성하여 파일 업로드를 처리하세요. 파일 선택을 간단하게 하기 위해 react-dropzone 라이브러리를 사용할 거에요:\n\n```js\n// FileUpload.js\nimport React, { useCallback } from 'react';\nimport { useDropzone } from 'react-dropzone';\n\nconst FileUpload = ({ onFileSelected }) => {\n  const onDrop = useCallback((acceptedFiles) => {\n    onFileSelected(acceptedFiles[0]);\n  }, [onFileSelected]);\n\n  const { getRootProps, getInputProps } = useDropzone({ onDrop });\n\n  return (\n    <div {...getRootProps()} className=\"dropzone\">\n      <input {...getInputProps()} />\n      <p>여기로 파일을 드래그하거나 클릭하여 파일을 선택하세요</p>\n    </div>\n  );\n};\n\nexport default FileUpload;\n```\n\n## 단계 5: 사전 서명 URL 로직 구현\n\n백앤드로부터 사전 서명 URL을 가져오는 서비스를 생성하세요. api.js 파일을 업데이트하세요:\n\n\n\n```js\n// api.js\nimport axios from 'axios';\n\nconst API_BASE_URL = 'http://localhost:3001'; // 귀하의 백엔드 서버 URL로 변경해주세요\n\nexport const getPresignedUrl = async (fileName) => {\n  try {\n    const response = await axios.post(`${API_BASE_URL}/getPresignedUrl`, {\n      fileName,\n    });\n    return response.data.url;\n  } catch (error) {\n    console.error('사전 서명된 URL을 가져오는 중 오류 발생:', error);\n    throw error;\n  }\n};\n```\n\n## 단계 6: 파일 업로드 및 사전 서명된 URL 로직 통합\n\n메인 컴포넌트(App.js)를 업데이트하여 파일 업로드 컴포넌트와 사전 서명된 URL 로직을 통합하세요:\n\n```js\n// App.js\nimport React from 'react';\nimport FileUpload from './FileUpload';\nimport { Storage } from 'aws-amplify';\nimport { getPresignedUrl } from './api';\n\nconst App = () => {\n  const handleFileUpload = async (file) => {\n    try {\n      const presignedUrl = await getPresignedUrl(file.name);\n\n      // 사전 서명된 URL을 사용하여 파일을 S3에 업로드\n      await Storage.put(file.name, file, {\n        contentType: file.type,\n        customPrefix: { public: 'public/' },\n        level: 'public',\n      });\n\n      console.log('파일이 성공적으로 업로드되었습니다!');\n    } catch (error) {\n      console.error('파일 업로드 처리 중 오류 발생:', error);\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <h1>AWS S3와 함께 사전 서명된 URL 파일 업로드</h1>\n      <FileUpload onFileSelected={handleFileUpload} />\n    </div>\n  );\n};\n\nexport default App;\n```\n\n\n\n# 백엔드 설정 - (파트 2)\n\n## 단계 1: Node.js 프로젝트 설정\n\n이제 백엔드 설정으로 전환해 볼까요? 백엔드를 위한 새 디렉토리를 만들어보세요:\n\n```js\nmkdir backend\ncd backend\nnpm init -y\nnpm install express aws-sdk\n```\n\n\n\n## 단계 2: AWS SDK 구성하기\n\nAWS SDK를 구성하기 위해 awsConfig.js라는 새 파일을 생성하세요. `YOUR_ACCESS_KEY`와 `YOUR_SECRET_KEY`를 여러분의 AWS 액세스 키와 시크릿 키로 교체하세요. `YOUR_ACCESS_KEY`와 `YOUR_SECRET_KEY`를 어떻게 생성하는 지는 이후 Part -3에서 다룰 예정입니다.\n\n```js\n// awsConfig.js\nconst AWS = require('aws-sdk');\n\nAWS.config.update({\n  accessKeyId: 'YOUR_ACCESS_KEY',\n  secretAccessKey: 'YOUR_SECRET_KEY',\n  region: 'us-east-1', // 원하는 지역으로 교체하세요\n});\n\nmodule.exports = AWS;\n```\n\n## 단계 3: Express 서버 생성하기\n\n\n\n새 파일을 만들어서 server.js라고 이름 짓고 Express 서버를 설정하고 사전 서명된 URL 요청을 처리하세요.\n\n```js\n// server.js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst { S3 } = require('./awsConfig');\n\nconst app = express();\nconst PORT = 3001;\n\napp.use(bodyParser.json());\n\n// 실제 S3 버킷 이름으로 'your-bucket-name'을(를) 바꿔주세요.\nconst BUCKET_NAME = 'your-bucket-name';\n\napp.post('/getPresignedUrl', (req, res) => {\n  const { fileName } = req.body;\n\n  const s3 = new S3();\n  const params = {\n    Bucket: BUCKET_NAME,\n    Key: fileName,\n    ContentType: 'application/octet-stream', // 파일 유형에 따라 콘텐츠 유형을 조정하세요\n    Expires: 60, // 사전 서명 URL 만료 시간(초) 설정\n  };\n\n  s3.getSignedUrl('putObject', params, (err, url) => {\n    if (err) {\n      console.error('사전 서명된 URL 생성 중 오류 발생:', err);\n      return res.status(500).json({ error: '사전 서명된 URL 생성 실패' });\n    }\n\n    res.json({ url });\n  });\n});\n\napp.listen(PORT, () => {\n  console.log(`서버가 http://localhost:${PORT}에서 실행 중입니다.`);\n});\n```\n\n## 단계 4: 백엔드 서버 시작하기\n\n다음 명령을 사용하여 백엔드 서버를 실행하세요.\n\n\n\n```js\nnode server.js\n```\n\n서버가 http://localhost:3001에서 실행 중이에요. 서버 파일에서 `your-bucket-name`을 실제 S3 버킷 이름으로 교체해주세요.\n\n# AWS S3 설정 - 3부\n\n## 단계 1: AWS 계정 생성하기\n\n\n\nAWS 계정이 없으신 경우, 새로 만드셔야 해요. AWS 가입 페이지로 이동하여 계정을 생성해보세요.\n\n## 단계 2: AWS 관리 콘솔에 액세스하기\n\nAWS 관리 콘솔에 로그인해주세요.\n\n## 단계 3: S3으로 이동하기\n\n\n\nAWS 관리 콘솔에서 \"서비스\" 드롭다운을 찾아 클릭해주세요. \"저장소\" 아래에서 \"S3\"를 클릭하여 간편 저장소 서비스에 액세스할 수 있어요.\n\n## 단계 4: 새 버킷 만들기\n\n- S3 대시보드에서 \"버킷 생성\" 버튼을 클릭해주세요.\n\n2. 버킷 구성:\n- 이름과 지역: 버킷에 전 세계적으로 고유한 이름을 선택해주세요. 이름은 DNS 호환성이 있어야하며 선택한 이름이 이미 사용 중이면 AWS가 알려줄 거예요. 사용자에게 더 나은 대기 시간을 제공하기 위해 지리적으로 가장 가까운 지역을 선택해주세요.\n- 저장 클래스: 요구 사항에 따라 저장 클래스를 선택해주세요. 일반 목적 저장소에 대한 기본 설정이 일반적으로 적합합니다.\n\n\n\n3. 설정 옵션 구성하기 (선택사항):\n- 사용자의 선호 및 프로젝트 요구에 맞게 버전 관리, 로깅 및 태그 설정을 구성합니다.\n\n4. 권한 설정:\n- 버킷에 액세스할 수 있는 사용자를 정의합니다. 간단히 하려면 현재 기본 설정을 유지할 수 있습니다.\n\n5. 검토:\n- 설정을 검토하고 \"버킷 생성\" 버튼을 클릭합니다.\n\n## 단계 5: 버킷 정책 (선택사항)\n\n\n\n만약 테스트 목적으로 버킷을 공개하려면 공개 액세스를 허용하는 버킷 정책을 추가할 수 있습니다. 그러나 프로덕션 환경에서는 권장되지 않으므로 데이터 노출의 위험이 있습니다.\n\n- 버킷의 \"Permissions\" 탭으로 이동합니다.\n- \"Bucket Policy\"를 클릭하고 아래와 유사한 정책을 추가합니다. your-bucket-name을 실제 버킷 이름으로 바꿔주세요.\n\n```js\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": \"*\",\n      \"Action\": \"s3:GetObject\",\n      \"Resource\": \"arn:aws:s3:::your-bucket-name/*\"\n    }\n  ]\n}\n```\n\n필요에 따라 권한을 조정하여 사용 사례에 맞게 설정하세요.\n\n\n\n## 6단계: 액세스 자격 증명\n\nS3 버킷과 프로그래밍적으로 상호 작용하려면 AWS 액세스 키와 비밀 키 자격 증명이 필요합니다.\n\n- AWS 관리 콘솔에서 “Services\"를 선택한 후 “IAM\"(Identity and Access Management)을 클릭합니다.\n- IAM 대시 보드에서 왼쪽 탐색 창에서 “Users\"를 클릭합니다.\n- 새 사용자를 만들려면 “Add user\"를 클릭합니다. 사용자 이름을 제공하고 “Programmatic access\"를 선택합니다.\n- 사용자에게 “AmazonS3FullAccess\" 정책을 부여합니다 (또는 필요에 따라 더 제한적인 정책을 선택할 수 있습니다).\n- 사용자를 검토하고 만듭니다. 제공된 액세스 키 ID와 비밀 액세스 키를 저장하세요. 이러한 자격 증명을 안전하게 보관하세요.\n\n이제 AWS에서 S3 버킷을 성공적으로 설정했으며 애플리케이션과 통합하거나 S3 저장소를 활용한 자습서를 따라 진행할 준비가 되었습니다.\n\n\n\n# 결론\n\n축하합니다! 안전하게 파일을 AWS S3에 업로드하기 위한 프로젝트의 전체적인 솔루션을 성공적으로 구현했습니다. 이 튜토리얼에서는 React 프론트엔드와 Node.js 백엔드를 AWS S3와 함께 설정하는 방법을 다뤘습니다. 코드를 프로젝트 요구에 맞게 사용자 정의하고, 안전한 파일 업로드 시스템을 배포할 준비가 된 것입니다. 즐거운 코딩하세요.....","ogImage":{"url":"/assets/img/2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3_0.png"},"coverImage":"/assets/img/2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개","description":"","date":"2024-05-12 19:02","slug":"2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache","content":"\n\n# TL;DR\n\nuseFetchCache 훅은 React 애플리케이션의 데이터 가져오기, 캐싱 및 업데이트를 간단하게 만들기 위해 설계된 사용자 정의 훅입니다. 네트워크 요청을 로컬 캐싱과 원활하게 통합함으로써, 빈번한 액세스가 필요하지만 자주 변경되지 않는 데이터를 처리하는 효율적인 방법을 제공합니다.\n\n## React 컴포넌트에서 같은 데이터를 계속해서 가져오는 것에 지쳤습니까?\n\nuseFetchCache를 만나보세요! 데이터 가져오기와 캐싱의 슈퍼히어로! 🦸‍♂️\n\n\n\nuseFetchCache는 데이터 가져오기를 간편하게 만들어 주는 커스텀 React 훅이에요. 개인 비서처럼 작동하여 필요한 모든 것을 기억해 주어서 매번 요청할 필요가 없어요. 반복적인 데이터 가져오기 로직 작성이나 여러 개의 로딩 및 오류 상태를 처리하는 번거로움도 없어요. 😌\n\nuseFetchCache를 사용하면 API URL과 필요한 매개변수를 제공하고, 후는 모두 맡기면 돼요. 데이터를 가져오고 로딩 상태를 처리하며, AsyncStorage를 사용하여 결과를 로컬로 캐싱해요. 이렇게 하면 같은 데이터에 대한 후속 요청은 캐시에서 제공되어 네트워크 트래픽을 줄이고 성능을 향상시킬 수 있어요. ⚡\n\n하지만 여기서 끝이 아니에요! useFetchCache에는 다시 불러오는 함수가 제공되어 데이터를 필요할 때마다 새롭게 불러올 수 있어요. 사용자 상호작용이나 주기적인 업데이트 때문이더라도 useFetchCache가 항상 도와줄 거예요. 🔄\n\n그러니 React 컴포넌트를 강화하고 데이터 가져오기 프로세스를 간소화하려면 useFetchCache가 여러분의 새로운 친구가 될 거에요. 이 슈퍼히어로 훅으로 무거운 작업을 처리하고 사용자들을 위한 놀라운 경험을 만드는 데 집중할 수 있도록 해 주세요. 💯\n\n\n\nuseFetchCache를 통해 매끄러운 데이터 가져오기와 캐싱의 마법을 경험할 준비가 되셨나요? 🚀✨\n\n## useFetchCache란?\n\nuseFetchCache는 API에서 데이터를 가져오는 과정을 자동화하고, 그 데이터를 로컬 저장소(AsyncStorage 사용)에 저장하며, 이후 요청에서 해당 데이터를 불러오는 React의 커스텀 훅입니다. 이 훅은 데이터 가져오기, 캐싱, 오류 관리를 처리하고, 강제 데이터 새로고침을 허용합니다.\n\n## useFetchCache 사용의 장점\n\n\n\n- 네트워크 호출 감소: 데이터를 로컬로 캐싱함으로써 애플리케이션에서 만드는 API 요청 수가 줄어들어 모바일 데이터 사용 및 제한적이거나 고비용의 연결 환경에서 특히 유용합니다.\n- 성능 향상: 데이터를 로컬로 캐싱하면 데이터 검색 시간이 빨라지며, 데이터가 대부분 로컬 저장소에서 즉시 사용 가능하기 때문에 서버로의 왕복을 필요로하지 않습니다.\n- 사용자 경험 향상: 사용자들은 빠른 로드 시간과 더 빠른 반응이 가능한 인터페이스를 경험할 수 있으며, 데이터가 빠른 액세스 로컬 캐시에서 로드되기 때문입니다.\n- 간편화된 데이터 관리: 훅은 데이터 가져오기, 캐싱 및 오류 처리를 캡슐화하여 구성 요소 코드를 단순화합니다.\n\n# useFetchCache 사용 방법\n\n- 훅 가져오기: React 컴포넌트 파일에 useFetchCache를 가져와서 시작합니다.\n- 훅 초기화: 필요한 매개변수(API URL 및 선택적으로 기본 캐시 키 및 만료 시간)를 사용하여 useFetchCache를 호출합니다. 특정 키가 제공되지 않으면 URL도 캐시 키로 사용할 수 있습니다.\n- 데이터 표시: 훅이 반환하는 데이터 상태를 사용하여 컴포넌트에서 데이터를 표시합니다. 사용자에게 피드백을 제공하기 위해 필요한대로 로딩 상태 및 오류를 처리하세요.\n- 새로 고침 및 페이지네이션 구현: 필요한 경우 신선한 데이터가 필요한 시나리오에 대비해 훅이 제공하는 refetch 메서드를 사용하고, API에서 지원하는 경우 API URL 또는 내부 상태를 조정하여 페이지네이션을 관리하세요.\n- 코드 배치: 훅은 컴포넌트 함수 상단에 배치되어야 하며, 조건문이나 반복문 외부에 위치하여 훅의 규칙을 준수해야 합니다.\n\n## 이것이 바로 훅입니다…\n\n\n\n```js\n// useFetchCache.js\n\nimport { useState, useEffect, useCallback } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport axios from 'axios';\n\n/**\n * AsyncStorage를 사용하여 데이터를 가져와 캐싱하는 커스텀 훅입니다. 옵션으로 강제 새로고침이 가능합니다.\n * \n * @param {string} url - 데이터를 가져올 API URL입니다.\n * @param {string} [baseCacheKey=null] - 데이터를 저장하는 기본 캐시 키입니다. 제공되지 않으면 URL이 기본값으로 사용됩니다.\n * @param {number} [expirationTime=3600000] - 캐시 만료까지의 밀리초 단위 시간입니다 (기본값은 1시간).\n * @return {Object} 데이터, 로딩 상태, 오류 및 리페치 함수를 포함한 객체입니다.\n */\nconst useFetchCache = (url, baseCacheKey = null, expirationTime = 1000 * 60 * 60) => {\n  // 제공된 baseCacheKey 또는 URL을 사용하여 캐시 키를 구성합니다.\n  const cacheKey = `${baseCacheKey ? baseCacheKey : encodeURIComponent(url)}`;\n\n  // 데이터, 로딩 상태, 오류를 관리하는 상태 훅입니다.\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // 데이터를 가져오는 함수로, 옵션으로 캐시를 무시할 수 있습니다.\n  const fetchData = async (forceFetch = false) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const storedDataString = await AsyncStorage.getItem(cacheKey);\n\n      // 강제 새로고침하지 않고 캐시가 있고 유효한 경우 캐시된 데이터를 사용합니다.\n      if (!forceFetch && storedDataString) {\n        const storedData = JSON.parse(storedDataString);\n        const now = Date.now();\n        if (now - storedData.timestamp < expirationTime) {\n          console.log(\"캐시로부터 데이터를 제공합니다 for key:\", cacheKey);\n          setData(storedData.data);\n          return;\n        }\n      }\n\n      // 강제 새로고침이거나 캐시가 만료된 경우 또는 캐시가 없는 경우 API에서 데이터를 가져옵니다.\n      console.log(\"API로부터 데이터를 가져옵니다 for URL:\", url);\n      const response = await axios.get(url);\n      const newData = response.data;\n      setData(newData);\n      await AsyncStorage.setItem(cacheKey, JSON.stringify({\n        data: newData,\n        timestamp: Date.now(),\n      }));\n    } catch (err) {\n      console.error(\"데이터를 가져오는 중 오류가 발생했습니다:\", err);\n      setError(err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // 캐시를 무시하여 데이터를 강제로 다시 가져오는 함수입니다.\n  const refetch = useCallback(() => {\n    console.log(\"캐시를 무시하고 데이터를 다시 가져옵니다...\");\n    fetchData(true);\n  }, [url, cacheKey]);\n\n  // URL이나 cacheKey가 변경될 때 데이터를 가져오는 효과입니다.\n  useEffect(() => {\n    fetchData();\n  }, [url, cacheKey]);\n\n  return { data, isLoading, error, refetch };\n};\n\nexport default useFetchCache;\n```\n\n## 그리고 여기에 샘플 사용법이 있습니다...\n\n```js\n// DataFetchingComponent.js \n\nimport React from 'react';\nimport { View, Text, ActivityIndicator, Button } from 'react-native';\nimport useFetchCache from './useFetchCache'; // useFetchCache가 정의된 파일로 올바르게 지정하세요.\n\nconst DataFetchingComponent = () => {\n  // 데이터를 가져올 URL입니다.\n  const url = \"https://api.example.com/data\";\n\n  // URL을 사용하여 훅을 초기화합니다. baseCacheKey를 제공하지 않으면 URL이 자동으로 캐시 키로 사용됩니다.\n  const { data, isLoading, error, refetch } = useFetchCache(url);\n\n  // 사용자가 \"새로고침\" 버튼을 누를 때 새로 고침 동작을 처리합니다.\n  const handleRefresh = () => {\n    refetch(); // 훅에서 제공하는 refetch 함수를 호출하여 데이터를 강제로 다시 가져옵니다.\n  };\n\n  // 데이터를 가져오는 동안 로딩 표시줄을 렌더링합니다.\n  if (isLoading) return <ActivityIndicator size=\"large\" color=\"#0000ff\" />;\n\n  // 데이터를 가져오는 동안 오류가 발생하면 오류 메시지를 렌더링합니다.\n  if (error) return <Text>Error: {error.toString()}</Text>;\n\n  // 가져온 데이터 또는 가져온 데이터가 없을 경우 메시지를 렌더링합니다.\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Data: {data ? JSON.stringify(data) : '데이터 없음'}</Text>\n      <Button title=\"데이터 새로고침\" onPress={handleRefresh} color=\"#0000ff\" />\n    </View>\n  );\n};\n\nexport default DataFetchingComponent;\n```\n\n# 주요 내용```\n\n\n\n- 일관성이 중요합니다: 항상 동일한 데이터 집합에 대해 동일한 캐시 키를 사용하여 응용 프로그램 전체의 일관성을 보장하세요.\n- 오류 처리를 세련되게: 데이터 가져오기에서 발생하는 오류를 세련되게 처리하여 사용자 경험을 개선하세요.\n- 캐시 정기적으로 업데이트: 캐시된 데이터에 적절한 만료 시간을 설정하고 주기적으로 또는 사용자 요구에 따라 캐시를 업데이트하는 refetch 함수를 사용하세요.\n\n# 결론\n\nReact 애플리케이션에서 useFetchCache 훅을 사용하면 데이터 처리를 최적화할 수 있습니다. 반복적이고 비용 소모적인 네트워크 요청이 줄어들며 데이터 로드 시간을 단축하고 구성 요소에서의 데이터 관리를 간단하게 할 수 있습니다. 이 훅을 통합함으로써 개발자들은 좋은 기능을 개발하는 데 더 집중할 수 있고 데이터 가져오기와 상태 관리의 복잡성에 대해 덜 걱정해도 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache_0.png","tag":["Tech"],"readingTime":7},{"title":"웹 성능 최적화 Tree Shaking 설명","description":"","date":"2024-05-12 19:01","slug":"2024-05-12-OptimizingWebPerformanceTreeShakingExplained","content":"\n\n📝 이 블로그에서는 웹 개발에서 중요한 프로세스인 Tree Shaking의 개념을 자세히 살펴볼 것입니다. Tree shaking을 이해하는 것은 코드의 성능을 최적화하고 최종 제품에 필요한 부분만 포함되도록 보장하는 데 중요합니다. 🕵️‍♀️ 이 기술이 무엇이며, 효율적이고 간소화된 애플리케이션을 만드는 데 왜 중요한지 알아보겠습니다.\n\n🤔 먼저 Tree Shaking이 무엇인지 정의해 보겠습니다.\n\n💡 TREE SHAKING은 JavaScript에서 사용되는 기술로, 번들링 프로세스 중에 번들에서 사용되지 않는 코드나 모듈을 제거하는 데 사용됩니다. Tree shaking은 일반적으로 JavaScript 기반 개발의 번들링 프로세스의 일부입니다. JavaScript 코드를 번들링할 때 여러 파일을 최적화된 상태로 묶어 브라우저로 전달하는 것입니다.\n\n📚 여기서 읽기: 번들링: 웹 성능 최적화\n\n\n\n🤯 이 예제를 통해 이해해 봅시다.\n\n😀 코드의 큰 트리와 (사용되지 않는 코드인) 가지들이 그것을 무겁게 만든다고 상상해보세요. (즉, 웹 앱 성능을 낮춥니다). Tree shaking은 그 가지를 흔들어서 불필요한 가지들을 놓아버리는 것과 같습니다. 이를 통해 코드를 가볍고 빠르게 만들어줍니다. 🫡\n\n지금 코드로 더 잘 이해해 봅시다 🤩\n\n```js\nexport function add(num1, num2){\n  return num1 + num2;\n}\n\nexport function sub(num1, num2){\n  return num1 - num2;\n}\n\nexport function mul(num1, num2){\n  return num1 * num2;\n}\n\nexport function div(num1, num2){\n  return num1 / num2;\n}\n```\n\nMain.js\n\n```js\nimport { mul, add } from './Operators';\n\nconsole.log(mul(3, 8));\n\nconsole.log(add(55, 23));\n```\n\n🔥 When all these files are bundled together, Here is the final bundled code\n```\n\n\n\n```js\n// 번들된 연산자\n\nexport function add(num1, num2) {\n  return num1 + num2;\n}\n\nexport function mul(num1, num2) {\n  return num1 * num2;\n}\n\nconsole.log(mul(3, 8));\nconsole.log(add(55, 23));\n```\n\n여기서 sub, div 함수는 우리 애플리케이션에서 사용되지 않으므로 최종 번들에서 제외됩니다. 이는 번들링 프로세스 중에 수행되는 트리 쉐이킹 기술에 의해 수행됩니다.\n\n🤨 알겠어! 하지만 함수가 사용자 입력 [즉, 동적 사용자 입력]에 의존하는 경우 어떻게 되나요? 트리 쉐이킹 기술은 여전히 사용되지 않는 함수의 사용을 제거할까요?\n\n👉 여러 함수가 사용자 입력에 종속되는 시나리오에서는 트리 쉐이킹이 도전을 겪을 수 있으며 효과가 덜 할 수 있습니다. 사용자 입력은 실행 시간까지 알 수 없기 때문에 빌드 도구는 번들에 모든 잠재적으로 관련 있는 함수를 포함할 수 있습니다. 이러한 동적 사용자 의존성의 특성은 트리 쉐이킹이 효과적으로 최적화하는 것을 어렵게 만들며, 개발자들은 이러한 경우에 코드 분할 또는 지연 로딩과 같은 대체 전략을 고려해야 할 수 있습니다.\n```\n\n\n\n```js\n// Module A\nexport function add(num1, num2) {\n  return num1 + num2;\n}\n\n// Module B\nexport function multiply(num1, num2) {\n  return num1 * num2;\n}\n\n// Main application file\nimport { add, multiply } from './modules';\n\n// User input\nconst userInput = prompt('더하기는 1을 입력하고, 곱하기는 2를 입력하세요:');\n\nlet result;\n\nif (userInput === '1') {\n  result = add(3, 4);\n} else if (userInput === '2') {\n  result = multiply(3, 4);\n}\n\nconsole.log(result);\n```\n\n이 시나리오에서 사용자의 입력에 따라 'add' 또는 'multiply' 함수가 동적으로 호출되므로 빌드 과정 중 tree shaking이 도전적입니다. Tree shaking을 적용해도 사용자 입력의 동적 성향으로 인해 두 함수 모두 최종 번들에 포함될 수 있으므로 최적의 성능을 위해 개발자가 코드 분할 또는 지연 로딩과 같은 대안을 고려해야 합니다.\n\n😀 장점\n1. 번들 크기 축소: 작은 번들은 사용자에게 빠른 다운로드를 제공하여 페이지 로드 시간을 개선합니다.\n2. 대역폭 절약: 작은 번들은 네트워크를 통해 전송하는 데 더 적은 대역폭이 필요해 호스팅 비용을 절감하고 웹 응용 프로그램의 전반적인 효율성을 향상시킵니다.\n\n🫣 단점\n1. 동적 사용자 입력, 조건부 로딩 등에서 효과적이지 않을 수 있음.\n2. 응용 프로그램이 동적 가져오기와 라이브러리 또는 프레임워크가 완전히 호환되지 않을 때 예기치 않은 동작이 발생할 수 있습니다.\n\n\n\n💡 결론: 트리 쉐이킹은 자바스크립트에서 사용되지 않는 코드를 번들링 프로세스 중에 제거하는 가치 있는 기술로, 더 작은 번들과 향상된 응용프로그램 성능을 이끌어냅니다. 그러나 동적 사용자 입력, 조건부 로딩 및 특정 라이브러리 또는 프레임워크와의 호환성 문제와 관련하여 그 효과는 손상될 수 있으며, 개발자들이 대체 최적화 전략을 주의 깊게 고려해야 합니다.\n\n📚 이전 포스트:\n\n👉 NPM이 무엇인가요?\n👉 의미 있는 버전 관리 해부\n👉 Dependencies, DevDependencies 및 PeerDependencies\n👉 로컬 대 글로벌 패키지\n👉 번들링: 웹 성능 최적화 방법\n\n🔍 다음은:\n\n\n\n👉 최소화, 검사\n👉 코드 분할, 지연 로딩\n\n더 많은 ReactJs 개발에 대한 통찰력을 기대해주세요! 🚀📦","ogImage":{"url":"/assets/img/2024-05-12-OptimizingWebPerformanceTreeShakingExplained_0.png"},"coverImage":"/assets/img/2024-05-12-OptimizingWebPerformanceTreeShakingExplained_0.png","tag":["Tech"],"readingTime":4}],"page":"83","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":14,"currentPageGroup":4},"__N_SSG":true}