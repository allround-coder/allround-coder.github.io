{"pageProps":{"posts":[{"title":"Android와 iOS 개발을 시작하는 방법","description":"","date":"2024-05-17 03:39","slug":"2024-05-17-AndroidiOSDevTogether","content":"\n\n## 안드로이드와 iOS를 동시에 생각하기\n\n이 시리즈의 기사에서는 안드로이드 및 iOS 개발을 단일한 사고로 살펴봅니다.\n\n## 한 번 언어를 선택하면 나머지는 따라옵니다\n\n핵심: \"→\"는 \"이로 이어진다\"는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n선택: 언어 → 아키텍처 → 패키지 관리자 → 데이터베이스 → 선언적 UI → 개발 환경 → 테스트 → 프레임워크 → 프레임워크 → 저장소\n\nAndroid 및 iOS 개발: 종합적으로 생각하기\n\n![Android iOS Dev](/assets/img/2024-05-17-AndroidiOSDevTogether_0.png)\n\n본 시리즈는 모바일 개발의 세계로 빠져들어, Android 및 iOS 개발을 통합적 관점에서 탐구합니다. 우리는 여러분이 만날 필수적인 결정과 도구들을 안내하여, 두 플랫폼을 위한 모바일 앱 구축에 전략적으로 생각할 수 있도록 도와드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n언어 선택은 중요한 첫 번째 단계입니다만, 그것은 단순히 시작에 불과해요. 연결된 개발 과정을 살펴보며, 각 결정이 그 다음 단계로 이끄는 과정을 보여드릴게요:\n\n- 언어 선택: 코틀린과 스위프트\n- 아키텍처: 객체지향 프로그래밍(OOP)과 프로토콜 지향 프로그래밍(POP) 패러다임\n- 패키지 관리: Gradle / TOML(안드로이드) 및 Swift Package Manager(iOS)\n- 데이터 지속성: RoomDB(안드로이드)와 SwiftData(iOS)\n- 사용자 인터페이스: Material Design 3과 함께 Compose(안드로이드) & Apple HIG와 함께 SwiftUI(iOS)\n- 개발 환경: Android Studio 및 Xcode\n- 테스트: Hilt로 테스트(안드로이드) 및 XCTest(iOS)\n- 앱 기능: 결제, 센서, 피트니스, AR/VR 및 AI/ML을 위한 프레임워크\n- 배포: Google Play Store 및 Apple App Store 항해\n\n최대 효과를 위한 구조화된 학습\n\n<div class=\"content-ad\"></div>\n\n위 글을 Markdown 형식으로 변경하겠습니다.\n\n\nWe’ve divided this series into three comprehensive sections to ensure you gain a well-rounded understanding of mobile development:\n\nSection 1: Foundation\n\n- Languages & Features: Kotlin & Swift, including key features like functions, extensions, concurrency (coroutines/Swift structured concurrency).\n- Architecture Paradigms: Object-Oriented Programming (OOP) and Protocol-Oriented Programming (POP).\n- Package Management: Learn how to manage dependencies for each platform.\n\nSection 2: Building Your App\n\n\n<div class=\"content-ad\"></div>\n\n- 데이터 지속성: RoomDB(Android)와 SwiftData(iOS)와 함께 데이터베이스 세계로 빠져 들어가보세요.\n- 사용자 인터페이스: Compose와 SwiftUI를 사용하여 선언적 UI의 강력함을 탐험해보세요. 상태 관리 및 내비게이션을 포함합니다.\n- 개발 환경: Android Studio 또는 Xcode로 개발 환경을 설정하고 추가 도구 옵션을 탐색해보세요.\n- 프로젝트 구조: 프로젝트를 효과적으로 구성하는 방법을 이해해보세요.\n\n3부: 마무리 및 배포\n\n- 테스트: Hilt Test(Android)와 XCTest(iOS)를 사용하여 앱을 테스트하는 최상의 방법을 배워보세요.\n- 앱 기능성: 지불, 센서, AR/VR, AI/ML과 같은 다양한 영역에서 앱 기능을 강화하는 여러 프레임워크를 탐색해보세요.\n- 배포: Google Play Store와 Apple App Store에 앱을 게시하는 요령을 배워보세요.\n\n이러한 주제에 몰두함으로써, Android와 iOS 모두에 특화된 네이티브 플랫폼 애플리케이션을 구축하기 위한 전체적인 이해력을 갖추게 될 것입니다. 이 시리즈의 다가오는 기사를 기대해주세요! (곧 게시될 예정)\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 위 텍스트를 번역해 드리겠습니다. \n\n\"테이블 태그를 마크다운 형식으로 변경해주세요.\"\n\n도움이 되었으면 좋겠네요! 다른 도움이 필요하시면 언제든지 말씀해주세요. 🌟","ogImage":{"url":"/assets/img/2024-05-17-AndroidiOSDevTogether_0.png"},"coverImage":"/assets/img/2024-05-17-AndroidiOSDevTogether_0.png","tag":["Tech"],"readingTime":3},{"title":"플러터에서 텍스트 스케일링을 적절히 다루는 방법","description":"","date":"2024-05-17 03:37","slug":"2024-05-17-ProperlyhandlingtextscalinginFlutter","content":"\n\n이 튜토리얼은 가장 쉽고 영향력이 큰 해결책을 먼저 제시하도록 구성되어 있어요. 후속 섹션에는 구현이 어려우면서 전반적인 영향이 더 낮은 해결책들이 포함되어 있지만, 특정 경우에 대응하기 위해 유용해요.\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png)\n\n## 텍스트 스케일링 가능 범위 제한\n\nMaterialApp에 최소 및 최대 스케일 팩터를 설정할 수 있어요. 이렇게 하면 모든 텍스트가 지정한 범위 내에서 스케일링된다는 것을 보장할 수 있어요. 더 빈번한 경계는 가독성과 미적 감각을 유지하는 데 덜 노력이 필요해요. 그러나 경계 선택은 대상 사용자에 따라 달라져야 해요. 예를 들어 노인 사용자를 대상으로 한 앱의 경우, 그들의 요구를 수용하기 위해 더 넓은 범위를 사용하는 것을 고려해야 해요.\n\n<div class=\"content-ad\"></div>\n\n```js\n    MaterialApp(\n      ...\n      builder: (_, child) => MediaQuery(\n        data: MediaQuery.of(context).copyWith(\n          textScaler: MediaQuery.of(context)\n              .textScaler\n              .clamp(minScaleFactor: 0.8, maxScaleFactor: 1.6),\n        ),\n        child: child!,\n      ),\n    );\n```\n\n## 텍스트를 포함하는 요소에 고정 높이를 사용하지 마세요\n\n다음 코드를 살펴보세요:\n\n```js\n          //DON'T\n          SizedBox(\n            height: 100,\n            child: Card(\n              child: Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: [\n                    Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n                    Text(\"Subtitle\", maxLines: 1),\n                  ],\n                ),\n              ),\n            ),\n          ),\n```\n\n<div class=\"content-ad\"></div>\n\n문제가 발생할 수 있습니다.\n\n예상하신 대로, 텍스트 크기를 키우면 SizedBox의 내용이 너무 많은 공간을 차지할 수 있습니다.\n\n![image](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_1.png)\n\n컨텐츠 높이 및 패딩에 기반한 아이템의 높이를 만드는 것이 더 좋습니다. 게다가 ConstrainedBox를 사용하여 최소 높이를 설정할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nConstrainedBox(\n  constraints: const BoxConstraints(minHeight: 100),\n  child: const Card(\n    child: Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n          Text(\"Subtitle\", maxLines: 1),\n        ],\n      ),\n    ),\n  ),\n),\n```\n\n결과적으로 100% 배율에서 동일한 레이아웃을 얻고, 160%에서도 유효한 레이아웃을 얻을 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_2.png\" />\n\nListView에도 동일한 사항이 적용됩니다. itemExtent를 사용하는 경우, 폰트 스케일을 고려하여 계산하거나 prototypeItem을 제공하는 것이 좋습니다. 이에 대해 자세히 설명된 내용은 이 기사에서 확인할 수 있습니다.\n  \n\n<div class=\"content-ad\"></div>\n\n계속 진행해 봅시다. 다음 레이아웃을 상상해보세요:\n\n![Image1](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_3.png)\n\n아이템 A는 이전 예시에서 나왔어요. 아이템 B는 약간의 간격을 가지고 있고 텍스트 확대에 대응할 수 있어야해요. 화면 하단에는 충분한 공간이 있어요. 그래서 어떤 문제가 발생할 수 있을까요?\n\n![Image2](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_4.png)\n\n<div class=\"content-ad\"></div>\n\n화면이 작은 폰들도 고려해주세요. 또한, 언어를 바꿀 때 텍스트 길이가 달라질 수 있어요.\n\n## 컨텐츠를 스크롤할 수 있도록 만들기\n\n먼저, 모든 컨텐츠에 접근 가능하도록 오버플로우를 제거해야 해요. 간단한 SingleChildScrollView를 추가하면 이 문제를 해결할 수 있어요.\n\n## 마진과 패딩에 대해 적응적인 값을 사용하는 것을 고려해보세요\n\n<div class=\"content-ad\"></div>\n\n이것은 논란이 될 수 있는 방법일 수 있지만, 자신이 더 큰 글꼴을 사용해야 하는 사용자로 상상해보세요. 사용되지 않는 공간을 많이 보고 싶으신가요 아니면 텍스트를 명확하게 읽고 싶으신가요?\n\n텍스트를 표시하는 논리적 픽셀의 수에 따라 값들을 사용해봅시다. smallScreenThreshold를 응용 프로그램에 가장 적합한 값으로 조절할 수 있습니다.\n\n```js\nclass Dimens {\n  static const smallScreenThreshold = 300;\n  static bool isSmallWidth(BuildContext context) {\n    return MediaQuery.of(context).size.width /\n            MediaQuery.textScalerOf(context).scale(1) <\n        smallScreenThreshold;\n  }\n\n  static double small(BuildContext context) => isSmallWidth(context) ? 4 : 8;\n  static double medium(BuildContext context) => isSmallWidth(context) ? 8 : 16;\n  static double large(BuildContext context) => isSmallWidth(context) ? 16 : 32;\n}\n```\n\n만약 Human Interface Guidelines와 Material Design을 따르고 싶다면, 이 값들은 4로 나눌 수 있는 값이어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 Dimens에 기반하여 간격에 대한 클래스를 만들 수 있습니다:\n\n```js\nclass Insets {\n  static EdgeInsets small(BuildContext context) =>\n      EdgeInsets.all(Dimens.small(context));\n      \n  static EdgeInsets medium(BuildContext context) =>\n      EdgeInsets.all(Dimens.medium(context));\n\n  static EdgeInsets large(BuildContext context) =>\n      EdgeInsets.all(Dimens.large(context));\n}\n```\n\n그리고 코드에서 다음과 같이 대체합니다:\n\n```js\n//padding: const EdgeInsets.all(16),\npadding: Insets.medium(context),\n\n//SizedBox(height: 16),\nSizedBox(height: Dimens.medium(context)),\n```\n\n<div class=\"content-ad\"></div>\n\n결과적으로 화면에 텍스트를 그릴 수 있는 공간이 조금 더 확보되었습니다:\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_5.png)\n\n## 제목의 텍스트 크기 확장을 제한하세요\n\n글꼴 크기를 크게 하는 주된 목적은 시력이 약해진 사람들에게 콘텐츠를 가독성 있게 만드는 것입니다. 그러나 제목과 같은 앱의 일부는 이미 글꼴이 크기 때문에 접근성이 좋을 수 있습니다. 이를 해결하기 위해 텍스트가 확대될 수 있는 범위를 제한할 수 있습니다. 이를 달성하는 한 가지 방법은 제목용 사용자 정의 위젯을 만드는 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass TitleText extends StatelessWidget {\n  final String text;\n  final TextStyle style;\n\n  const TitleText(this.text, {required this.style, super.key});\n\n  static const double maxRealFontSize = 30;\n\n  @override\n  Widget build(BuildContext context) {\n    if (MediaQuery.textScalerOf(context).scale(style.fontSize!) >\n        maxRealFontSize) {\n      return Text(\n        text,\n        style: style.copyWith(\n          fontSize: maxRealFontSize / MediaQuery.textScalerOf(context).scale(1),\n        ),\n      );\n    }\n    return Text(text, style: style);\n  }\n}\n```\n\n이렇게 하면 가독성을 유지하면서 공간을 더 확보할 수 있어요. 앱에 더 적합한 값으로 maxRealFontSize를 변경할 수 있어요.\n\n<img src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_6.png\" />\n\n## 최대 줄 수 및 텍스트 오버플로우 지정하기\n\n<div class=\"content-ad\"></div>\n\n큰 화면에서 일반적인 텍스트 스케일로 보기 좋을 수도 있지만, 다른 조건에서는 수직 공간을 더 많이 차지할 수 있음을 잊지 마세요. 그러나 제목(Subtitle)과 같은 곳은 항상 전체 내용을 표시할 필요가 없습니다. Text 위젯에 maxLines 값을 추가하여 원하는 줄 수로 설정할 수 있습니다.\n\n\n![Properly handling text scaling in Flutter](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_7.png) \n\n\n1로 설정된 maxLines로 보기 좋네요. 주요 정보는 여전히 잘 보입니다.\n\n## 문자열의 대안 버전 사용하기\n\n<div class=\"content-ad\"></div>\n\n하지만 항상 유용한 정보를 포함하는 방식으로 문자열을 줄이는 것이 가능한 것은 아닙니다. 게다가, 단어 순서는 다른 언어들에서 다르게 변할 수 있습니다. 영어에서의 첫 번째 단어가 다른 언어에서는 문장의 끝에 올 수도 있습니다. 이번에는 국제화(i18n) 문자열을 고려해보는 것이 중요합니다:\n\n```js\n        \"tasksDone\": {\n            \"one\": \"할 일 중 $completed 개 완료\",\n            \"other\": \"할 일 중 $completed 개 완료\"\n        },\n        \"tasksDoneShort\": {\n            \"one\": \"$completed/$n 작업 완료\",\n            \"other\": \"$completed/$n 작업 완료\"\n        },\n```\n\n가장 의미 있는 부분은 숫자를 나타낸 부분입니다. 더 짧은 버전에서 숫자를 앞에 두고 전체 문자열을 더 짧게 만들었습니다. 코드에서는 다음과 같이 사용할 수 있습니다:\n\n```js\n        Text(\n          Dimens.isSmallWidth(context)\n              ? t.tasksDoneShort(n: 10, completed: 5)\n              : t.tasksDone(n: 10, completed: 5),\n          maxLines: 1,\n        )\n```\n\n<div class=\"content-ad\"></div>\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_8.png)\n\n스크린샷을 보시면, 단축된 버전을 사용하면 필요한 정보를 보여주는 데 도움이 됩니다.\n\n이 기사가 유용하게 느껴졌으면 좋겠네요. 더 유용한 기술을 찾으면 업데이트할 예정입니다. 코드는 이 저장소에서 찾을 수 있습니다.\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_9.png)","ogImage":{"url":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png"},"coverImage":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png","tag":["Tech"],"readingTime":7},{"title":"당신의 미래 비밀은 당신의 일상 속에 숨어 있어요","description":"","date":"2024-05-17 03:35","slug":"2024-05-17-TheSecretofYourFutureisHiddeninYourDailyRoutine","content":"\n\n우리의 일상 루틴은 특히 프로그래밍 분야에서 미래에 거대한 영향을 미칩니다. 당신이 경험이 풍부한 코더이건 막 시작한 사람이건, 오늘 형성하는 습관이 내일의 성공을 결정짓습니다. 프로그래머들의 잠재력을 발휘할 수 있는 주목할 가치가 있는 일상 루틴에 대해 알아봅시다.\n\n# 일상 루틴의 중요성\n\n일관성은 모든 기술을 습득하는 데 중요하며, 프로그래밍도 예외는 아닙니다. 매일 일정한 루틴을 정하면 다음과 같은 구조를 만들 수 있습니다:\n\n1. 집중 유지: 꾸준한 습관은 방해요소를 최소화하여 작업에 더 집중할 수 있도록 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n2. 기술 향상: 매일 연습하는 것은 학습을 강화시켜 시간이 흐를수록 복잡한 개념과 기술을 더 쉽게 이해할 수 있게 합니다.\n\n3. 시간 관리: 효율적인 루틴은 일과 학습, 여가를 균형 있게 조절하여 매일을 최대한 효율적으로 활용할 수 있도록 도와줍니다.\n\n4. 스트레스 감소: 예측 가능한 일정은 하루가 엉망이 되는 것을 방지해주어 스트레스를 관리하고 건강한 직장-생활 균형을 유지할 수 있게 도와줍니다.\n\n# 이상적인 일상 루틴 만들기\n\n<div class=\"content-ad\"></div>\n\n## 1. 하루를 시작하는 아침의 루틴\n\n- 일찍 일어나기: 일찍 일어나서 머리가 맑은 상태로 시작하세요. 조용한 시간을 활용하여 계획을 세우고 목표를 정하며 오늘을 위해 정신적으로 준비하세요.\n- 건강한 습관: 신체적 활동이나 건강한 아침 식사로 에너지를 충전하고 집중력을 높이세요.\n- 학습 시간: 코딩 튜토리얼, 기술 블로그 읽기, 일상적인 도전 과제 해결 등 30분을 학습에 할당하여 기민하고 최신 정보를 유지하세요.\n\n## 2. 효율적인 작업 세션\n\n- 명확한 목표 설정: 새로운 기능 개발, 버그 수정 또는 코드베이스 향상과 같은 분명한 목표로 각 작업 세션을 시작하세요.\n- 시간 블록 활용: Pomodoro 기법(25분 집중, 5분 휴식)과 같은 포커스된 시간 블록으로 작업을 나누세요. 이는 생산성을 향상시키고 과로를 예방합니다.\n- 다중 작업 제한: 품질과 효율성을 위해 한 번에 한 가지 작업에 중점을 두세요. 다중 작업은 오류와 생산성 감소로 이어질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. 정기적인 휴식과 신체 활동\n\n- 짧은 휴식: 집중적인 작업 세션이 끝난 후, 5~10분 동안 휴식을 취하세요. 몸과 마음을 회복하기 위해 스트레칭을 하거나 산책을 하거나 건강한 간식을 챙겨 드세요.\n- 긴 휴식: 점심 식사 시간에 30~60분 동안 긴 휴식을 취하세요. 진정한 휴식을 취하여 완전히 기력을 회복하세요.\n\n## 4. 저녁 준비\n\n- 회고와 계획: 하루의 성취를 돌아보고 다음 날을 위해 계획을 세워 조직적이고 동기부여를 유지하세요.\n- 배우고 실험: 개인 프로젝트에 시간을 투자하거나 새로운 기술을 배워 계속해서 참여하고 향상시키세요.\n- 휴식: 독서, TV 시청 또는 가족과 함께 시간을 보내는 등 활동을 통해 완전히 휴식을 취하고 업무와의 연결을 끊으세요.\n\n<div class=\"content-ad\"></div>\n\n# 개발자를 위한 현명한 팁\n\n- 일상적인 작업 자동화: 반복되는 작업을 스크립트와 도구로 자동화해 시간을 절약하고 오류를 줄이며 더 복잡한 작업에 집중할 수 있습니다.\n- 코드 저널 유지: 학습과 문제 해결을 문서화하여 미래 프로젝트에 유용한 참고 자료를 만들고 진행 상황을 추적하여 동기부여를 유발합니다.\n- 정기적인 코드 리뷰: 정기적인 코드 리뷰 일정을 잡아 코드 품질을 향상시키고 이전 실수와 성공으로부터 배우세요.\n- 최신 정보 유지: 최신 프로그래밍 트렌드와 기술에 대해 알기 위해 시간을 할당하세요. 핵심 웹사이트, 블로그, 영향력 있는 인플루언서를 팔로우하여 새로운 발전과 최적의 실천 방법에 대해 정보를 얻으세요.\n\n# 결론\n\n꾸준한 일상적인 루틴을 만들면 미래의 성공에 대한 씨앗을 심는 것과 같습니다. 기억하세요, 위대함은 일상적인 행동에서 비롯되는 것이며 일회성 노력뿐만 아니라 일상적인 행동에서 나옵니다. 오늘부터 시작하여 일상적인 루틴이 위대함으로 이끌어주길 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n당신과 연결하고 싶어요 🙃🙃 !!!!!\n\nLinkedin : [https://www.linkedin.com/in/kushwaharudraksha/](https://www.linkedin.com/in/kushwaharudraksha/)\n\nTwitter : [https://twitter.com/rudraksha_kush](https://twitter.com/rudraksha_kush)","ogImage":{"url":"/assets/img/2024-05-17-TheSecretofYourFutureisHiddeninYourDailyRoutine_0.png"},"coverImage":"/assets/img/2024-05-17-TheSecretofYourFutureisHiddeninYourDailyRoutine_0.png","tag":["Tech"],"readingTime":3},{"title":"JAVA로 안드로이드 개발을 시작하는 방법","description":"","date":"2024-05-17 03:34","slug":"2024-05-17-AComprehensiveGuidetoAndroidDevelopmentwithJava","content":"\n\n안녕하세요! 안드로이드 개발은 기술 산업에서 중심이 되어, 전 세계의 수백만 대의 장치를 구동합니다. 방대한 사용자 기반과 유연성을 갖고 있어 Android 애플리케이션을 개발하는 것은 보람찬 일일 수 있습니다. 안드로이드 개발을 위한 가장 인기 있는 언어 중 하나는 Java입니다. 이 안내서는 Java를 사용하여 Android 개발의 기본 사항을 소개하며 환경 설정부터 첫 번째 앱을 배포하는 과정까지 안내해 드릴 것입니다.\n\n시작하기\n\n준비 사항\n\nAndroid 개발에 도전하기 전에 Java 프로그래밍에 대한 기본적인 이해가 있는지 확인해 주세요. 객체지향 프로그래밍 개념에 익숙하다면 특히 유용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n개발 환경 설정하기\n\nJDK 설치: 공식 오라클 웹사이트에서 Java 개발 키트(JDK)를 다운로드하고 설치하세요. 환경 변수가 올바르게 설정되어 있는지 확인하고 JAVA_HOME이 JDK 설치 디렉토리를 가리키도록 합니다.\n\nAndroid Studio 설치: Android Studio는 안드로이드 개발을 위한 공식 통합 개발 환경(IDE)입니다. Android 개발자 웹사이트에서 다운로드하세요. 설치 프로세스는 간단하며 Android SDK와 앱을 테스트하는 데 사용되는 에뮬레이터가 포함되어 있습니다.\n\nAndroid Studio 구성: 설치 후 Android Studio를 시작하고 설정 마법사를 따라 SDK를 구성하고 가상 디바이스(AVD)를 생성하고 필요한 다른 구성 요소를 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n당신의 첫 번째 Android 앱 만들기\n\n새 프로젝트 생성\n\n새 프로젝트 시작: Android Studio를 열고 \"새 Android Studio 프로젝트 시작\"을 클릭합니다.\n\n프로젝트 구성: 프로젝트 이름, 패키지 이름, 저장 위치를 입력하고 Java 언어를 선택합니다. 지원하고자 하는 최소 API 수준을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n템플릿 선택: 프로젝트 템플릿을 선택하세요. 초보자를 위해서 \"빈 활동(Empty Activity)\" 템플릿을 추천합니다.\n\n프로젝트 구조 이해\n\nAndroid Studio는 기본 프로젝트 구조를 생성합니다. 이는 다음을 포함합니다:\n\n- app: 애플리케이션 코드를 포함하는 주요 디렉토리입니다.\n\n<div class=\"content-ad\"></div>\n\nsrc/main/java: 여러분의 Java 소스 파일입니다.\n\nsrc/main/res: 레이아웃, 이미지, 문자열과 같은 리소스 파일입니다.\n\nAndroidManifest.xml: 여러분의 앱에 대한 중요한 정보를 포함하는 매니페스트 파일입니다.\n\n첫 번째 코드 작성하기\n\n<div class=\"content-ad\"></div>\n\nMainActivity.java: 여기는 앱의 진입점입니다. MainActivity.java를 열면 기본 Activity 클래스가 나타납니다.\n\n```java\npackage com.example.myfirstapp;\n\nimport android.os.Bundle;\n```\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nimport androidx.appcompat.app.AppCompatActivity;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n'\n\n'\n\nactivity_main.xml: 이 레이아웃 파일은 MainActivity의 사용자 인터페이스를 정의합니다. 열기\n\n앱 실행하기\n\n<div class=\"content-ad\"></div>\n\n귀하의 앱이 실제로 작동하는 것을 보려면 Android Studio에서 \"실행\" 버튼을 클릭하세요. 연결된 장치 또는 에뮬레이터를 선택하고 앱이 \"Hello, Android!\"를 표시하면 시작됩니다.\n\n주요 개념 탐색\n\n활동\n\n활동은 사용자 인터페이스가 있는 단일 화면을 나타냅니다. 여기에 UI 코드를 넣고 사용자 상호작용을 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n의도\n\n의도는 구성 요소(활동, 서비스 등)간의 통신에 사용됩니다. 새 활동을 시작하거나 데이터를 보내거나 이벤트를 트리거하는 데 사용할 수 있습니다.\n\n프래그먼트\n\n프래그먼트는 앱 UI의 재사용 가능한 부분을 나타냅니다. 더 모듈식이고 유연한 UI 디자인을 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n레이아웃\n\nAndroid는 화면에 UI 요소를 정렬하기 위해 LinearLayout, RelativeLayout 및 ConstraintLayout과 같은 여러 레이아웃 매니저를 제공합니다.\n\n고급 주제\n\n네트워킹\n\n<div class=\"content-ad\"></div>\n\n네트워크 요청을 만들기 위해 Retrofit 또는 Volley와 같은 라이브러리를 사용하세요. Retrofit은 사용하기 쉽고 강력한 기능으로 인해 특히 인기가 있습니다.\n\n데이터 지속성\n\n로컬 데이터를 저장하기 위해 SQLite, Room 또는 공유 프리퍼런스를 사용하세요. Room은 SQLite 위에 추상화 계층을 제공하여 더 견고한 데이터베이스 액세스가 가능합니다.\n\n백그라운드 작업\n\n<div class=\"content-ad\"></div>\n\n백그라운드 작업을 처리할 때는 AsyncTask, WorkManager 또는 서비스를 사용하세요. 대부분의 경우에는 작업 관리자(WorkManager)를 사용하는 것이 좋습니다. 왜냐하면 WorkManager는 예약 가능하고 비동기적인 작업을 위한 일관된 API를 제공하기 때문입니다.\n\n**결론**\n\nJava로 Android 애플리케이션을 개발하는 것은 수백만 사용자에게 도달하는 모바일 앱을 만드는 강력한 방법입니다. 활동(activities), 인텐트(intents), 프래그먼트(fragments), 레이아웃(layouts)과 같은 핵심 구성 요소를 이해하면 복잡하고 사용자 친화적인 애플리케이션을 구축할 수 있습니다. 더 많은 경험을 쌓으면 네트워킹, 데이터 지속성 및 백그라운드 작업과 같은 고급 주제를 탐색하여 개발 기술을 더욱 향상시킬 수 있을 것입니다. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-17-AComprehensiveGuidetoAndroidDevelopmentwithJava_0.png"},"coverImage":"/assets/img/2024-05-17-AComprehensiveGuidetoAndroidDevelopmentwithJava_0.png","tag":["Tech"],"readingTime":4},{"title":"나를 위한 개인 웹 페이지 만드는 방법","description":"","date":"2024-05-17 03:33","slug":"2024-05-17-CreateAPersonalWebPageForMe","content":"\n\n웹 페이지를 자랑하는 데 도움이 되는 간단한 코드를 제공했습니다. 코드에 여러 기능을 추가하여 나만의 것을 만들어보세요. 이 코드는 단순한 구조일 뿐입니다. \"John Doe\"를 위한 웹 페이지를 만들어봅시다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>YOUR_NAME - YOUR_ROLE</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 0;\n            background-color: #f4f4f4;\n            color: #333;\n        }\n        header {\n            background-color: #4CAF50;\n            color: white;\n            padding: 1em 0;\n            text-align: center;\n        }\n        nav {\n            display: flex;\n            justify-content: center;\n            background-color: #333;\n        }\n        nav a {\n            color: white;\n            padding: 1em;\n            text-decoration: none;\n            text-align: center;\n        }\n        nav a:hover {\n            background-color: #575757;\n        }\n        .container {\n            padding: 2em;\n            max-width: 800px;\n            margin: auto;\n        }\n        footer {\n            text-align: center;\n            padding: 1em 0;\n            background-color: #333;\n            color: white;\n        }\n    </style>\n</head>\n<body>\n    <header>\n        <h1>YOUR_NAME</h1>\n        <p>YOUR_ROLE</p>\n    </header>\n    <nav>\n        <a href=\"#about\">About Me</a>\n        <a href=\"#portfolio\">Portfolio</a>\n        <a href=\"#contact\">Contact</a>\n        <a href=\"#blog\">Blog</a>\n    </nav>\n    <div class=\"container\">\n        <section id=\"about\">\n            <h2>About Me</h2>\n            <p>Hello! I'm YOUR_NAME, YOUR_DESCRIPTION.</p>\n        </section>\n        <section id=\"portfolio\">\n            <h2>Portfolio</h2>\n            <p>Here are some of my recent projects:</p>\n            <ul>\n                <li><strong>Project 1:</strong> Description of project 1.</li>\n                <li><strong>Project 2:</strong> Description of project 2.</li>\n                <li><strong>Project 3:</strong> Description of project 3.</li>\n            </ul>\n        </section>\n        <section id=\"contact\">\n            <h2>Contact</h2>\n            <p>You can reach me at:</p>\n            <ul>\n                <li>Email: YOUR_EMAIL</li>\n                <li>LinkedIn: <a href=\"YOUR_LINKEDIN_PROFILE\" target=\"_blank\">YOUR_LINKEDIN_PROFILE</a></li>\n                <li>Twitter: <a href=\"YOUR_TWITTER_PROFILE\" target=\"_blank\">@YOUR_TWITTER_HANDLE</a></li>\n            </ul>\n        </section>\n        <section id=\"blog\">\n            <h2>Blog</h2>\n            <p>Welcome to my blog! Here, I share my thoughts on software development, technology trends, and much more. Stay tuned for updates!</p>\n        </section>\n    </div>\n    <footer>\n        <p>&copy; 2024 YOUR_NAME</p>\n    </footer>\n</body>\n</html>\n```\n\n플레이스홀더 정보(예: \"John Doe\", \"Software Developer\", 연락처 정보)를 실제 정보로 바꿔주세요. 이 템플릿은 자신의 정보로 About Me 섹션, 포트폴리오, 연락처 정보, 블로그 섹션을 포함하고 깔끔하고 전문적인 디자인을 위해 간단한 CSS로 스타일링된 것입니다. 필요에 맞게 내용과 스타일을 조정해주세요.","ogImage":{"url":"/assets/img/2024-05-17-CreateAPersonalWebPageForMe_0.png"},"coverImage":"/assets/img/2024-05-17-CreateAPersonalWebPageForMe_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 애플리케이션과 Net Web API를 Auth0로 안전하게 보호하기","description":"","date":"2024-05-17 03:31","slug":"2024-05-17-SecureanAngularapplicationandNetWebAPIwithAuth0","content":"\n\n<img src=\"/assets/img/2024-05-17-SecureanAngularapplicationandNetWebAPIwithAuth0_0.png\" />\n\n이 튜토리얼에서는 Angular 애플리케이션에 로그인 시스템을 추가하고 .Net Web API를 Auth0로 보호하는 방법을 배워보겠습니다.\n\n먼저 무료 Auth0 계정을 생성하고 설정할 것입니다. 그 후 .Net 7 Web API를 생성하고 보호된 엔드포인트를 설정할 것입니다. 그런 다음 Angular 애플리케이션을 생성하고 JWT 베어러를 사용하여 Web API를 호출할 수 있는 로그인 시스템을 추가할 것입니다.\n\n보안에 대해 잘 모르더라도, Auth0를 사용하면 보안 서비스를 처음부터 만들 필요 없이 응용 프로그램에 인증/권한 부여를 추가할 수 있는 좋은 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n# Auth0\n\n## Auth0 계정 생성\n\nhttps://auth0.com으로 이동하여 무료로 가입하고 계정을 설정하세요.\n\n## Auth0 싱글 페이지 애플리케이션 구성\n\n<div class=\"content-ad\"></div>\n\n왼쪽 메뉴에서 Applications > Applications로 이동하여 Default App을 선택하십시오. 설정 탭으로 이동하여 이름을 변경하십시오. 또한 새 응용 프로그램을 만들 수 있습니다.\n\n설정에서 Angular 앱과 통신할 때 사용할 응용 프로그램 도메인, 클라이언트 ID 및 클라이언트 비밀번호를 확인할 수 있습니다.\n\n앱 속성 아래로 스크롤하면 Application Type을 Single Page Application으로 변경할 수 있습니다.\n\nApplication URIs 섹션에서 Allowed Callback, Logout URLs 및 Allowed Web Origins에 URL http://localhost:4200/을 제공하십시오.\n\n<div class=\"content-ad\"></div>\n\nhttp://localhost:4200/은 우리 Angular 애플리케이션의 로컬 URL이 되겠습니다.\n\n# .Net 7 웹 API를 생성하고 보안 설정하기\n\n## 새 .Net Web API 프로젝트 만들기\n\nVisual Studio를 열고 ASP.NET Core Web API 프로젝트 템플릿에서 새 프로젝트를 만드세요. .Net 6 프레임워크를 선택하세요. 이 튜토리얼에서는 이 템플릿에서 생성된 WeatherForcastController를 사용할 것입니다. 이 컨트롤러에는 사용 예제에서 사용할 HTTP Get 엔드포인트가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트를 생성한 후 프로그램을 실행하고 https://localhost:7202/weatherforecast (포트 번호가 다를 수 있습니다)으로 JSON 형식의 WeatherForecast 목록이 반환되는지 확인해주세요.\n\n## 교차 도메인 요청 허용\n\n우리의 Angular 애플리케이션에서 모든 HTTP 요청을 허용해야 합니다. Program.cs 또는 Startup.cs 파일을 열어주세요.\n\nbuilder.Services를 services로 바꿔주세요. 그리고 var builder = WebApplication.CreateBuilder(args); 다음에 services 변수를 만들어주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nvar services = builder.Services;Copy\n```\n\n그 후에, CORS 미들웨어를 추가하세요.\n\n```js\napp.UseCors(\"CorsPolicy\");Copy\n```\n\nCORS 정책을 등록하고 http://localhost:4200 출처를 허용하세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nservices.AddCors(options =>\n{\n    options.AddPolicy(\"CorsPolicy\", builder => builder\n    .WithOrigins(\"http://localhost:4200\")\n    .AllowAnyMethod()\n    .AllowAnyHeader()\n    .AllowCredentials());\n});\n```\n\n## Auth0에 API 추가하기\n\nAuth0 계정으로 돌아가서 Applications & APIs로 이동하여 새 API를 생성하세요.\n\nAPI 이름과 식별자 URL(https://localhost:7202/로 포트 번호를 변경)을 입력하세요. RS256 알고리즘을 선택하세요.\n\n\n<div class=\"content-ad\"></div>\n\n## API 엔드포인트 보안하기\n\n이제 우리는 엔드포인트를 보안하고, 인증된 사용자만이 이에 액세스하고 반환된 콘텐츠와 함께 성공적인 HTTP 응답을 받을 수 있도록하려고합니다.\n\n먼저, Get() 메서드에 Microsoft.AspNetCore.Authorization에서 [Authorize] 속성을 추가하십시오.\n\n```csharp\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\n```\n\n<div class=\"content-ad\"></div>\n\n```csharp\nnamespace Auth0WebApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class WeatherForecastController : ControllerBase\n    {\n        private static readonly string[] Summaries = new[]\n        {\n            \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\"\n        };\n        private readonly ILogger<WeatherForecastController> _logger;\n        public WeatherForecastController(ILogger<WeatherForecastController> logger)\n        {\n            _logger = logger;\n        }\n        [HttpGet]\n        [Authorize]\n        public IEnumerable<WeatherForecast> Get()\n        {\n            return Enumerable.Range(1, 5).Select(index => new WeatherForecast\n            {\n                Date = DateTime.Now.AddDays(index),\n                TemperatureC = Random.Shared.Next(-20, 55),\n                Summary = Summaries[Random.Shared.Next(Summaries.Length)]\n            })\n            .ToArray();\n        }\n    }\n}\n```\n\n우리는 ConfigurationManager를 통해 Audience 및 Domain 값을 액세스하고 싶어해요.\n\n따라서 appsettings.json에 Audience와 Domain을 추가해주세요.\n\n```json\n\"Auth0\": {\n  \"Audience\": \"https://localhost:7202/\",\n  \"Domain\": \"auth0tuto.eu.auth0.com\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그러면 \"테이블\" 태그를 Markdown 형식으로 변경해주세요.\n\n\n| 아이템 | 가격 |\n|---|---|\n| 사과 | 1.99 |\n| 바나나 | 0.99 |\n| 수박 | 5.99 |\n\n\n<div class=\"content-ad\"></div>\n\n아래 코드를 추가하여 인증을 구성하십시오.\n\n```js\nservices.AddAuthentication(options =>\n{\n    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n}).AddJwtBearer(options =>\n{\n    options.Authority = $\"https://{auth0.Domain}/\";\n    options.Audience = auth0.Audience;\n});\n```\n\n저희는 인증 토큰을 활용한 JWT 베어러 인증을 사용할 것입니다. 해당 인증은 Authorization HTTP 헤더에서 추출되고 유효성이 검사될 것입니다.\n\n토큰을 유효성 검사하려면, Auth0 애플리케이션에서 구성한 도메인을 지정해야 합니다. 이 정보는 설정에서 찾을 수 있으며, 방금 생성한 Auth0 API의 식별자인 Audience(청중)도 지정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 AuthenticationMiddleware을 추가해 주세요:\n\n```js\napp.UseAuthentication();Copy\n```\n\n프로그램을 다시 실행하면 HTTP ERROR 401 (Unauthorized)를 받게 됩니다.\n\n# Angular 애플리케이션을 만들어 로그인 시스템을 구축하세요\n\n<div class=\"content-ad\"></div>\n\n## Angular CLI 설치\n\n이미 시스템에 Angular이 설치되어 있는 경우, 이 단계를 건너뛰세요.\n\n먼저, Node.js를 다운로드하고 설치해야 합니다 - ` https://nodejs.org/en/download\n\n그런 다음, 명령 프롬프트에 이 명령을 입력하여 Angular CLI를 설치하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install -g @angular/cli\n```\n\n만약 Windows를 사용 중이라면, PowerShell 스크립트 실행을 허용하기 위해 다음 명령을 실행해주세요.\n\n```js\nSet-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned\n```\n\n## Angular 애플리케이션 생성하기\n\n<div class=\"content-ad\"></div>\n\n새로운 Angular 애플리케이션을 생성하려면 ng new CLI 명령어를 실행하세요.\n\n```js\nng new auth0-angular-appCopy\n```\n\n앱에 포함할 기본 기능을 선택하세요.\n\n애플리케이션이 생성되면 ng serve -o를 실행하여 브라우저에서 앱을 실행하고 엽니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nng serve --oCopy\n```\n\n이제 기본 Angular 애플리케이션을 실행하는 것을 확인할 수 있습니다.\n\n## Auth0 SDK 설치\n\n좋아하는 텍스트 편집기나 IDE로 애플리케이션을 열어보세요. 여기서는 VS Code를 사용하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트 디렉토리 내에서 터미널을 열고 Auth0 Angular SDK를 설치하려면 다음 명령을 실행해주세요.\n\n```js\nnpm install @auth0/auth0-angularCopy\n```\n\napp.module.ts를 열어서 AuthModule 패키지를 가져와서 AuthModule.forRoot를 호출하여 imports 목록에 추가해주세요. Auth0 애플리케이션 설정에서 Domain 및 ClientId 값을 복사해주세요.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AuthModule } from '@auth0/auth0-angular'\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    AuthModule.forRoot({\n      domain: 'auth0tuto.eu.auth0.com',\n      clientId: 'aJZmQXUxWhl4arU5ZhN2FJ38YUQgNYbf'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n## 로그인/로그아웃 추가하기\n\napp.component.ts 파일을 열고 AuthService 클래스에 대한 종속성을 생성자에 추가하고 '@auth0/auth0-angular'에서 AuthService를 가져와주세요.\n\n귀하의 코드는 다음과 같아야 합니다:```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\n```\n\n```js\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'auth0-angular-app';\n  constructor(public auth: AuthService) {}\n}\n```\n\n이제 app.component.html 파일을 열어서 배너에 Twitter 버튼 바로 전에 다음 코드를 추가하세요.\n\n```js\n<ng-template #loggedOut>\n  <button class=\"btn-login\" (click)=\"auth.loginWithRedirect()\">\n    로그인\n  </button>\n</ng-template>\n<button class=\"btn-login\" (click)=\"auth.logout()\" *ngIf=\"auth.isAuthenticated$ | async; else loggedOut\">\n  로그아웃\n</button>\n```\n\n<div class=\"content-ad\"></div>\n\nloginWithRedirect() 메소드를 호출하면 사용자가 Auth0 Universal 로그인 페이지로 리디렉션되어 해당 페이지에서 애플리케이션으로 이동하기 전에 로그인 또는 회원 가입을 할 수 있습니다.\n\n그런 다음, 다음 CSS를 `<style></style>` 사이에 추가해주세요.\n\n```js\n.btn-login {\n  border-radius: 4px;\n  border: 1px solid #eee;\n  background-color: #fafafa;\n  color: #333;\n  padding: 10px 25px;\n  text-decoration: none;\n  cursor: pointer;\n}\n```\n\n이제 배너에 로그인 버튼이 표시될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n`div class = \"content\" role = \"main\"`와 `/div` 사이의 모든 것을 삭제하고 다음 코드를 복사하여 붙여넣으십시오.\n\n```js\n<p *ngFor=\"let item of weatherForecasts\">\n  {item.date} |\n  {item.temperatureC} °C |\n  {item.temperatureF} °F |\n  {item.summary}\n</p>\n```\n\n## 회원 가입\n\n로그인 버튼을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n지금은 Auth0 로그인 페이지로 이동되었습니다.\n\n새 계정을 만들려면 가입하세요. 계정을 확인하기 위해 이메일을 받아야 합니다.\n\n이제 Auth0 대시보드로 돌아가서, 왼쪽 메뉴에서 사용자 관리 `사용자`로 이동하여 사용자가 생성되었는지 확인하세요.\n\n## 로그아웃\n\n<div class=\"content-ad\"></div>\n\n가입한 후에는 로그인 버튼이 로그아웃 버튼으로 대체된 것을 볼 수 있습니다.\n\n로그아웃하려면 클릭하십시오.\n\n## 로그인\n\n이제 다시 로그인 버튼을 클릭하여 응용 프로그램에 로그인하십시오.\n\n<div class=\"content-ad\"></div>\n\n사용자 로그인 시스템이 작동되었으니, 이제 보안된 웹 API에 HTTP 호출을 만들어 날씨 예보 목록을 가져와 표시하고 싶어요.\n\n## HTTP 서비스 생성\n\n새 서비스를 만들기 위해 다음 Angular CLI 명령어를 실행해줘.\n\n```js\nng g s weatherforecastCopy\n```\n\n<div class=\"content-ad\"></div>\n\napp.module.ts에 WeatherForecastService와 HttpClientModule를 providers 배열에 추가해주세요. './weatherforecast.service'에서 WeatherForecastService를 import하고, @angular/common/http에서 HttpClientModule를 import해주세요.\n\napi.service.ts를 열어서 constructor에 HttpClient 의존성을 추가하고, @angular/common/http에서 클래스를 import하고 get() 메소드를 생성해주세요.\n\n```typescript\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\nconstructor(private http: HttpClient) {}\n\nget(): Observable<number> {\n  return this.http.get<number>(\"https://localhost:7202/weatherforecast/\");\n}\n```\n\n이 메소드는 우리 Web API의 weatherforecast 엔드포인트로 GET http 호출을 하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n귀하는 다음과 같이 서비스 클래스를 작성하셔야 합니다:\n\n```js\nimport { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n```\n\n```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class WeatherForecastService {\n  constructor(private http: HttpClient) { }\n  get(): Observable<any[]> {\n    return this.http.get<any[]>(\"https://localhost:7202/weatherforecast\");\n  }\n}\n```\n\n## 날씨 예보 표시하기\n\n<div class=\"content-ad\"></div>\n\napp.components.ts로 돌아가서 생성자에 WeatherForecastService 종속성을 추가하고 ./weatherforecast.service에서 해당 클래스를 import하세요.\n\nweatherForecasts 변수를 생성하고 초기화하세요.\n\n```js\nweatherForecast: any[] = [];\n```\n\ngetWeatherForecasts() 메서드를 생성하여 날씨 예보 목록을 로드하세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\ngetWeatherForecasts() {\n  this.weatherForecastService.get().subscribe(data => {\n    this.weatherForecast = data;\n  })\n}\n```\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\nimport { WeatherForecastService } from './weatherforecast.service';\n```\n\n```js\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit{\n  title = 'auth0-angular-app';\n  weatherForecasts: any[] = [];\n  constructor(\n    public auth: AuthService,\n    private weatherForecastService: WeatherForecastService\n  ) {}\n  ngOnInit(): void {\n    this.getWeatherForecasts();\n  }\n  getWeatherForecasts() {\n    this.weatherForecastService.get().subscribe(data => {\n      this.weatherForecasts = data;\n    })\n  }\n}\n```\n\n## Add JWT to the HTTP requests\n\n\n<div class=\"content-ad\"></div>\n\n이전에 언급한 대로, 저희 웹 API는 HTTP 요청의 Authorization 헤더에서 JWT bearer를 디코딩하여 클라이언트의 엔드포인트 접근을 승인합니다.\n\nAuth0 SDK를 사용하면 각 요청에 JWT를 수동으로 추가할 필요가 없습니다. 대신에, 우리를 대신해서 일을 처리해줄 Auth0 HTTP 인터셉터를 사용하겠습니다.\n\napp.module.ts에서 AuthHttpInterceptor와 HTTP_INTERCEPTORS를 다음과 같이 providers 배열에 추가하세요:\n\n```js\nproviders: [\n  WeatherForecastService,\n  { provide: HTTP_INTERCEPTORS, useClass: AuthHttpInterceptor, multi: true },\n],Copy\n```\n\n<div class=\"content-ad\"></div>\n\n@angular/common/http에 HTTP_INTERCEPTORS와 @auth0/auth0-angular에 AuthHttpInterceptor을 추가해주세요.\n\nAuthModule.forRoot()에서 audience와 httpInterceptor를 추가하고, 허용된 API 경로 목록에 API URL을 추가해주세요.\n\n우리의 app.module.ts는 이제 다음과 같이 보입니다:\n\n```js\nimport { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AuthHttpInterceptor, AuthModule } from '@auth0/auth0-angular';\nimport { WeatherForecastService } from './weatherforecast.service';\n```\n\n<div class=\"content-ad\"></div>\n\n\n```js\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    AuthModule.forRoot({\n      domain: 'auth0tuto.eu.auth0.com',\n      clientId: 'aJZmQXUxWhl4arU5ZhN2FJ38YUQgNYbf',\n      audience: 'https://localhost:7202/',\n      httpInterceptor: {\n        allowedList: [ 'https://localhost:7202/*' ],\n      },\n    }),\n  ],\n  providers: [\n    WeatherForecastService,\n    { provide: HTTP_INTERCEPTORS, useClass: AuthHttpInterceptor, multi: true },\n  ],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n# 모두 테스트하기\n\n이제 웹 API를 실행하고 Angular 애플리케이션에 로그인하세요.\n\n이제 페이지에 표시되는 날씨 예보 목록을 볼 수 있어야 합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-SecureanAngularapplicationandNetWebAPIwithAuth0_0.png"},"coverImage":"/assets/img/2024-05-17-SecureanAngularapplicationandNetWebAPIwithAuth0_0.png","tag":["Tech"],"readingTime":13},{"title":"인공지능 기술을 활용한 코드 문서화 및 분석 방법","description":"","date":"2024-05-17 03:30","slug":"2024-05-17-AI-PoweredCodeDocumentationandAnalysis","content":"\n\n<img src=\"/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_0.png\" />\n\n# TL;DR\n\n이 기사에서는 Mimrr을 사용하여 코드에 대한 문서를 생성하는 방법을 배우게 될 것입니다. 또한 다음과 같은 목적으로 Mimrr을 사용하여 코드를 분석하는 방법을 배우게 될 것입니다:\n\n- 버그\n- 유지보수 문제\n- 성능 문제\n- 보안 문제\n- 최적화 문제\n\n<div class=\"content-ad\"></div>\n\nMimrr 코드 문서 및 분석 기능을 활용하면 코드 변경이 정기적으로 발생할 때도 최신 코드 문서를 만들고 유지할 수 있습니다.\n\n그 결과로 코드 문서를 수동으로 작성하고 유지하는 데 소요되는 많은 시간을 절약할 수 있습니다.\n\n# Mimrr 시작하기\n\n이 섹션에서는 Mimrr 계정을 만드는 방법을 배울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n1. 민르(Mimrr)로 이동하고 무료 시작 버튼을 클릭하세요.\n\n![image](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_1.png)\n\n2. 그런 다음 Google, Microsoft 또는 GitHub 계정을 사용하여 민르(Mimrr) 계정을 만드세요.\n\n![image](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_2.png)\n\n<div class=\"content-ad\"></div>\n\n세 번째 단계: 그 다음으로, 조직 이름과 설명을 추가하여 조직을 생성합니다. 그런 다음 아래 그림처럼 '조직 생성' 버튼을 클릭하세요.\n\n![Organization Creation](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_3.png)\n\n그러고 나면 코드 문서를 생성하려는 코드베이스 저장소를 연결하기 위해 Mimrr 대시보드로 리디렉션됩니다.\n\n![Mimrr Dashboard](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_4.png)\n\n<div class=\"content-ad\"></div>\n\n축하합니다! Mimrr 계정을 성공적으로 생성했습니다.\n\n## Mimrr에 코드베이스 저장소 연결하여 코드 문서 생성하기\n\n이 섹션에서는 코드베이스 GitHub 저장소를 Mimrr에 연결하여 해당 문서 및 분석을 생성하는 방법을 배우게 됩니다.\n\n단계 1: 대시보드로 이동하여 \"Mimrr에 코드 연결\" 드롭다운 메뉴를 엽니다. 그런 다음 \"연결\" 버튼을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![AI-Powered Code Documentation and Analysis](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_5.png)\n\nStep 2: Then you will be redirected to choose a repository provider. In this case, I will select GitHub as my code provider.\n\n![AI-Powered Code Documentation and Analysis](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_6.png)\n\nStep 3: Next, go to your Mimrr dashboard and open the projects section to add your codebase repository by clicking the Add Project button. Once your project is added, it should look as shown below.\n\n\n<div class=\"content-ad\"></div>\n\n\nStep 4: 해당 프로젝트를 클릭하여 생성된 문서를 확인하세요.\n\n축하합니다! 이제 코드베이스를 위한 코드 문서를 성공적으로 생성했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 코드 분석 보기\n\n이 섹션에서는 버그, 냄새, 성능, 보안 및 리팩터링 문제를 강조하는 코드 분석 결과를 확인하는 방법을 배울 수 있습니다.\n\n단계 1: Mimrr 대시 보드에서 선택한 프로젝트로 이동하여 분석 섹션을 엽니다. 그러면 코드베이스 건강에 대한 개요가 표시됩니다.\n\n![이미지](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_9.png)\n\n<div class=\"content-ad\"></div>\n\nStep 2: 요약된 섹션 중 하나를 클릭하세요. 그럼 아래와 같이 이슈에 대한 더 많은 세부 정보를 보기 위해 Details 드롭다운 메뉴를 클릭하세요.\n\n![image](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_10.png)\n\nStep 3: 코드 유지 관리 문제를 분석하려면 아래와 같이 드롭다운 메뉴에서 Code Smell을 선택하세요. 그럼 각 유지 관리 문제에 대한 더 많은 세부 정보를 확인할 수 있습니다.\n\n![image](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_11.png)\n\n<div class=\"content-ad\"></div>\n\nStep 4: 코드 성능 문제를 분석하려면 아래에 나와 있는 드롭다운 메뉴에서 Performance를 선택하세요. 그런 다음 각 성능 문제에 대한 더 많은 세부 정보를 확인하세요.\n\n![Performance](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_12.png)\n\nStep 5: 코드 보안 문제를 분석하려면 아래에 나와 있는 드롭다운 메뉴에서 Security를 선택하세요. 그런 다음 각 취약점 문제에 대한 더 많은 세부 정보를 확인하세요.\n\n![Security](/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_13.png)\n\n<div class=\"content-ad\"></div>\n\n단계 6: 코드 리팩터링 문제를 분석하려면 아래와 같이 드롭다운 메뉴에서 Refactor를 선택하십시오. 그런 다음 각 유연성 문제에 대한 자세한 내용을 확인하십시오.\n\n<img src=\"/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_14.png\" />\n\n축하합니다! 버그, 냄새, 성능, 보안 및 리팩터링 문제에 대해 성공적으로 분석하셨습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n요약하자면, Mimrr은 코드 문서를 생성하는 및 코드의 문제를 분석하는 프로세스를 자동화하는 데 훌륭한 도구입니다. Mimrr을 사용함으로써 기술 부채 없이 기능을 신속하게 출시할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_0.png"},"coverImage":"/assets/img/2024-05-17-AI-PoweredCodeDocumentationandAnalysis_0.png","tag":["Tech"],"readingTime":4},{"title":"루비에서  긴 매개변수 목록 리팩터링 하는 방법","description":"","date":"2024-05-17 03:28","slug":"2024-05-17-RefactoringinRubyLongParameterList","content":"\n\n긴 매개변수 목록(Long Parameter List)은 작업을 수행하기 위해 많은 수의 매개변수가 필요한 경우 발생합니다. 일반적으로 두 개 이상의 매개변수를 사용하지 않는 것이 좋습니다.\n\n![image](/assets/img/2024-05-17-RefactoringinRubyLongParameterList_0.png)\n\n루비 언어에 관심이 있다면, 이 언어에서 리팩터링과 디자인 패턴에 대해 더 많이 알아볼 수 있습니다: [RubyHub](https://www.rubyhub.io/). 현재 웹사이트는 개설 중이지만, 미래에 더 다양한 주제가 등장할 것입니다.\n\n# 문제들\n\n<div class=\"content-ad\"></div>\n\n- 가독성 감소 — 긴 매개변수 목록은 메소드 호출 정의를 읽고 이해하기 어렵게 만들 수 있습니다. 특히 매개변수가 잘 명명되지 않았거나 문서화가 충분하지 않은 경우 더욱 그렇습니다.\n- 복잡성 증가 — 많은 매개변수는 종종 메소드나 함수가 너무 많은 작업을 시도하고 단일 책임의 원칙을 위반할 가능성을 나타냅니다.\n- 유지보수 도전 — 긴 매개변수 목록은 코드 유지보수를 어렵게 만듭니다. 메소드의 시그니처를 변경할 때 개발자는 해당 메소드의 모든 호출을 업데이트해야 하므로 오류나 일관성 문제가 발생할 수 있습니다.\n- 순서 의존성 — 긴 매개변수 목록은 올바른 매개변수 순서에 의존할 수 있으며, 매개변수가 잘못 배치되거나 누락된 경우 오류를 발생시킬 수 있습니다.\n- 유연성 제한 — 긴 매개변수 목록에서 매개변수를 추가하거나 제거하는 것은 어려울 수 있는데, 특히 메소드가 코드베이스 전체에서 여러 곳에서 사용되는 경우에 해당됩니다.\n- 테스트 복잡성 — 긴 매개변수 목록을 갖는 메소드를 테스트하는 것은 귀찮을 수 있습니다. 가능한 모든 매개변수 조합을 포함하는 다수의 테스트 케이스를 생성하고 관리해야 합니다.\n\n# 해결책\n\n- 옵션 해시 — 관련된 매개변수를 옵션 해시 매개변수로 통합하세요. 이 접근 방식은 메소드 호출을 더 간결하고 유연하게 만들어줍니다. 매개변수를 추가하거나 제거해도 메소드 시그니처를 변경할 필요가 없도록 합니다. 또한 명명된 매개변수를 제공하여 가독성을 향상시킵니다.\n- 매개변수 객체 — 관련된 매개변수를 하나의 객체로 묶어주세요. 매개변수 객체는 그들의 동작을 캡슐화하여 메소드 시그니처의 복잡성을 줄이고 코드 가독성을 높이는 데 도움이 됩니다.\n- 기본 및 명명된 매개변수 활용 — 기본 매개변수 값과 명명된 매개변수를 활용하여 메소드 호출을 간소화하세요. 기본 값은 매개변수에 논리적인 기본값을 제공하며, 명명된 매개변수는 전달되는 인수를 명시적으로 지정하여 메소드의 명확성을 향상시킵니다.\n- 더 작은 함수로 리팩토링 — 함수에 너무 많은 매개변수가 있다면, 너무 많은 작업을 수행할 수 있습니다. 더 작고 집중된 함수로 함수를 리팩토링하는 것을 고려해 보세요.\n\n# 실제 예제\n\n<div class=\"content-ad\"></div>\n\n루비에서 코드 예제를 살펴보겠습니다. 매개변수 목록이 긴 update_user 메서드가 있고, 이를 옵션 해시 기술을 사용하여 리팩터링할 것입니다.\n\n```js\ndef update_user(id, first_name, last_name, age, address, is_admin)\n  user = User.find(id)\n\n  user.update(\n    first_name: first_name,\n    last_name: last_name,\n    age: age,\n    address: address,\n    is_admin: is_admin\n  )\nend\n\nupdate_user(1, \"John\", \"Doe\", 25, \"Baker Street\", false)\n```\n\n이 리팩터링된 코드에서는 매개변수를 params 해시로 통합했습니다. 이렇게 하면 메서드 호출이 더 가독성 있어지고 매개변수를 유연하게 제공할 수 있습니다. is_admin 매개변수가 제공되지 않으면 기본값이 할당됩니다.\n\n```js\ndef update_user(params = {})\n  user = User.find(params[:id])\n\n  user.update(\n    first_name: params[:first_name],\n    last_name: params[:last_name],\n    age: params[:age],\n    address: params[:address],\n    is_admin: params.fetch(:is_admin, false)\n  )\nend\n\nuser_params = {\n  id: 1,\n  first_name: \"John\",\n  last_name: \"Doe\",\n  age: 25,\n  address: \"Baker Street\"\n}\n\nupdate_user(user_params)\n```\n\n<div class=\"content-ad\"></div>\n\n# 장단점\n\n## 장점\n\n- 향상된 가독성 — 옵션 해시를 사용하면 메소드 호출이 이름있는 매개변수를 제공하여 더 읽기 쉽습니다. 개발자는 각 매개변수가 무엇을 나타내는지 쉽게 이해할 수 있어, 매개변수의 위치에 의존하지 않아도 됩니다.\n- 유연성 — 옵션 해시 접근 방식을 통해 매개변수를 제공하는 데 유연성을 가질 수 있습니다. 매개변수를 추가, 제거 또는 수정하더라도 메소드 서명을 변경하지 않아도 되므로 코드를 변경에 더 적응 가능합니다.\n- 기본 매개변수 값 — 기본 매개변수 값을 메소드 내에서 쉽게 정의할 수 있어, 메서드 호출을 간단하게 만들고 필수 매개변수가 제공되지 않은 경우 합리적인 기본값을 갖게 할 수 있습니다.\n- 인지 부담 감소 — 이름있는 매개변수와 선택적 기본값을 사용함으로써 개발자는 매개변수의 순서나 기본값을 기억할 필요가 없어지며, 인지 부담이 줄어들고 잠재적인 오류를 줄일 수 있습니다.\n- 더 쉬운 유지 보수 — 긴 매개변수 목록을 옵션 해시로 리팩토링함으로써 메소드 서명을 단순화하여 코드를 보다 쉽게 유지보수할 수 있습니다. 개발자들은 많은 매개변수를 관리하는 대신 메소드의 로직에 집중할 수 있습니다.\n\n## 단점\n\n<div class=\"content-ad\"></div>\n\n- 추가 복잡성— 옵션 해시 기법은 메소드 서명을 간소화하지만 메소드 구현 내에서 추가적인 복잡성을 도입합니다. 개발자는 옵션 해시에서 매개변수 추출을 처리해야 하며, 이는 보일러플레이트 코드를 추가할 수 있습니다.\n- 스펠링 오류가 발생할 수 있는 가능성— 옵션 해시는 심볼 키에 의존하기 때문에 매개변수 이름을 철자를 틀리게 쓸 위험이 있습니다. 이는 런타임 오류로 이어질 수 있으며, 디버깅하기 어려운 문제가 발생할 수 있습니다.\n- 덜 엄격한 매개변수 유효성 검사— 누락된 매개변수가 오류를 유발하는 명시적인 매개변수 목록과는 달리, 옵션 해시 접근 방식은 누락된 매개변수가 nil 또는 기본값으로 설정되는 것을 허용합니다. 이러한 유연성은 덜 엄격한 매개변수 유효성 검사를 유발할 수 있으며, 예상치 못한 동작을 초래할 수 있습니다.\n- 기본값의 남발— 기본 매개변수 값은 유연성을 제공하지만, 기본값에 과도하게 의존하면 메소드의 의도가 모호해지고 메소드 구현을 검사하지 않고는 동작을 이해하기 어려워질 수 있습니다.\n\n![이미지](/assets/img/2024-05-17-RefactoringinRubyLongParameterList_1.png)\n\n저는 루비에서 리팩터링에 대한 책을 작업하고 있습니다. 이 주제에 관심이 있으시면, 제 뉴스레터에 가입하실 수 있습니다 📪️: https://mailchi.mp/e3dd49dfada1/medium. 구독자분들은 출판 후 즉시 제 이북 링크를 무료로 받아보실 수 있습니다. 🆓","ogImage":{"url":"/assets/img/2024-05-17-RefactoringinRubyLongParameterList_0.png"},"coverImage":"/assets/img/2024-05-17-RefactoringinRubyLongParameterList_0.png","tag":["Tech"],"readingTime":4},{"title":"웹 프레임워크의 유사발암화","description":"","date":"2024-05-17 03:25","slug":"2024-05-17-Thecarcinizationofwebframeworks","content":"\n\n프레임워크는 수렴 중입니까? 웹 개발 세계에서 발생하는 근본소생현상을 살펴보고, 과거를 향해 미래를 엿볼 수 있을까요?\n\n![이미지](/assets/img/2024-05-17-Thecarcinizationofwebframeworks_0.png)\n\n생물학적 과학에서 암화 변이란 게이물류 중 게 아닌 이놈들이 게처럼 보이는 형태로 진화하는 현상을 말합니다. 현재 웹 개발 세계에서도 비슷한 일이 일어나고 있는 것으로 보입니다. 웹 프레임워크는 마치 암화 변이 과정을 겪고 있는 것 같아요! — 분명히, 프레임워크는 진짜로 발톱이나 외골격을 개발하고 있는 것은 아니고, 대신 개념적으로 유사한 기능 집합으로 수렴해가고 있어서 점점 더 구별하기 어려워지고 있습니다 🦀 🦞\n\n스포일러 경고: 저는 이론적으로 완벽한 프레임워크가 존재한다고 말하고 싶진 않아요. 각 프로젝트는 다르며, 다른 요구 사항은 새로운 솔루션과 도구를 요구합니다. 그러나 대부분의 프레임워크가 결국 채택하게 될 거의 완벽한 기능 세트가 존재할 수 있습니다. 이 기사에서 그것을 엿볼 수도 있을지 모릅니다.\n\n<div class=\"content-ad\"></div>\n\n# 어떻게 변했나요?\n\n오래 전, JavaScript 프레임워크는 서로 완전히 다른 방식으로 작동했습니다. 사실, 이것이 대부분의 경우 그들의 주요 장점이었습니다: \"웹 개발을 새롭고 더 나은, 그러나 대부분은 다른 방식으로 하는 새로운 방법\". jQuery는 브라우저에 유틸리티를 추가하여 개발을 보다 빠르고 크로스 브라우저 친화적으로 만들기 위해 노력했습니다. Angular는 전체 객체지향 프로그래밍(OOP) 스위트를 웹으로 가져와서 확장 가능한 웹 앱을 구축하려고 했습니다. React는 함수형 원칙을 몇 가지 정교한 방법으로 사용하여 개발자가 함수와 합성만을 사용하여 웹 앱을 만들 수 있도록 제안했습니다. 다른 프레임워크들은 새로운 기반 위에 구축되었고, 일부는 단순히 기존 프레임워크를 더 빠르게, 작게 만들거나 서로 다른 아이디어를 결합하여 개선했습니다.\n\n자연스럽게, 일은 진화했습니다... 🧬 어떤 프레임워크는 다른 것보다 더 많은 인기를 얻었습니다. 최고의 아이디어는 새로운 프레임워크뿐만 아니라 기존 프레임워크에도 통합되었습니다. AngularJS는 Angular 2로 중심을 옮겼습니다. 일부 OOP 값들을 제거한 간단한 버전입니다. Vue는 React의 후크를 구현했고, React는 함수를 선호하여 클래스 구성 요소를 버렸습니다. 심지어 한때 급부상한 것으로 여겨졌던 Svelte도 최근에 Runes(신호를 모방하는 것, Solid, toddle 및 Preact에서 볼 수 있음)를 구현했습니다.\n\n그래서, 오늘 우리가 전반적으로 보는 특징들은 무엇일까요?\n\n<div class=\"content-ad\"></div>\n\n# 변경 불가능성 🪨\n\n프로그래머들에게는 다소 논란이되는 주제입니다. 변경 불가능한 데이터 처리는 성능 대 개발자 경험(DX) 사이의 중요한 교역입니다. 간단한 변이마다 전체 객체와 배열을 복제하는 것은 처음에 낭비처럼 보이기 때문에 수년간 많은 사람들이 기본 설정이 아니었습니다. 그러나 변경 불가능성에 헌신함으로써 귀하의 앱은 초기 성능 최적화가 부족할 수도 있지만 버그를 적게 배포하고 개발 주기를 빠르게 할 수 있습니다. 그럼에도 불구하고, 변경 불가능성은 오늘날의 프레임워크에서 중심적인 요소가 되어서 언제 사용하지 않아야 하는지 종종 잊게 됩니다.\n\n많은 프레임워크는 순수한 불변 데이터를 전달하는 것을 요구합니다. 참조를 수정하는 것은 위험하고 예측할 수 없는 부작용을 일으킬 수 있습니다. 그러나 변경 불가능성에서 분리하는 것은 항상 허용됩니다. 프레임워크가 모르는 것은 해칠 수 없습니다:\n\n## 🐢 느리지만 완전히 변경 불가능합니다.\n\n<div class=\"content-ad\"></div>\n\n## 🐇 빠르지만 배열을 직접 변경합니다 😱\n\n두 번째 예시는 훨씬 빠르며, 테스트 케이스를 작성하고 불변 코드를 순수 함수로 캡슐화하기 위해 함수로 래핑하는 한 완벽합니다.\n\n# 데이터의 단방향 흐름 🌊\n\nAngular 팀에 의해 처음 소개된 양방향 데이터 바인딩은 마법 같았습니다 🪄 너무 신비로운 것 같아요! ✨ 자식 구성 요소에서 데이터를 변경하면 부모가 자신을 업데이트하고 남아 있는 모든 자식도 업데이트할 수 있습니다 — 뭐가 안 좋을까요?\n\n<div class=\"content-ad\"></div>\n\n실제 예제에서는 종종 아무도 데이터를 실제로 소유하지 않는 스파게티 코드 🍝로 이어집니다. 진실의 근원이라고 할 수 있는 곳은 어디서나 동시에 존재하고 어디서나 존재하지 않았다. 어떤 것이 작동하지 않을 때 데이터를 손상시킨 사람을 찾을 수 없었습니다.\n\n엄격한 단방향 데이터 흐름으로 데이터가 항상 단일 소유자를 가지도록 보장합니다. 무언가가 망가지면 데이터 흐름을 따라 가면 범인을 찾을 수 있어요 🕵️‍♂️ 이 강제적인 제한은 웹 개발자들을 괴롭히는 많은 문제를 해결했습니다. 하지만, 우리에게 코드를 명확하게 작성하도록 요구합니다. 오늘날 거의 모든 프레임워크는 데이터를 아래로 보내는 이벤트를 올리는 접근 방식을 따릅니다.\n\n# 신호 ⚡\n\n상태 관리는 프레임워크를 확장 가능하게 만드는 데 가장 중요한 개념입니다. 전역 상태 변수를 추가할 때마다, 최소한 이론적으로 존재하는 상태의 복잡성이 두 배로 증가합니다. 앱이 성장함에 따라 상태도 늘어나며, 어느 시점에서든 수십억 개의 가능한 상태에 있을 수 있습니다. 상태의 수가 급격하게 증가하면 앱을 개발하기 거의 불가능해집니다. 앱의 한 부분을 변경할 때 다른 곳에서 적어도 하나의 다른 것이 깨집니다.\n\n<div class=\"content-ad\"></div>\n\n상태 처리의 복잡성과 중요성을 고려할 때, JavaScript 프레임워크 간의 주요 차별 요소 중 하나로 상태 관리가 역사적으로 부상한 것은 놀라울 것이 없습니다. Angular는 수명 동안 여러 상태 시스템을 가졌고, Vue와 Svelte도 마찬가지입니다. React는 여러 시스템을 가졌으며 수천 개의 호환되는 상태 관리 라이브러리가 있습니다. 우리는 양방향 데이터 바인딩에서 옵저버블, 훅으로 이동했으며, 이제 다음으로 큰 열풍: 신호 ⚡\n\n그러나 신호는 최신 유행에 그치지 않을 수 있습니다. 처음에는 신호를 이해하는 것이 까다로울 수 있지만, 놀랍도록 간단하며 코드 몇 줄로 구현할 수 있습니다. 신호는 세밀한 반응성을 지원하며 전역 상태 및 가장 작은 원시 데이터의 업데이트에 사용할 수 있습니다.\n\n신호가 지금까지 너무 인기가 많아서 원래 채택이 제안되었다는 것을 알고 계셨나요? toddle은 세밀한 반응성과 뛰어난 성능을 달성하기 위해 사용자 정의 신호 구현을 활용합니다!\n\n# 서버 측 렌더링 🌐\n\n<div class=\"content-ad\"></div>\n\n여러 해 동안, 프레임워크들은 자신들을 클라이언트 측만을 다루는 라이브러리로 자랑스럽게 소개했습니다. 웹사이트를 렌더링하기 위해 서버 코드를 작성할 필요가 없는 방법이었죠. 더 이상 PHP나 Java가 필요 없이, 간단한 JavaScript로만 작업할 수 있었습니다. 그러나 오늘날, 이러한 작고도 클라이언트 전용 라이브러리들은 전체 생태계로 성장하였고, - 여러분이 짐작했듯이 - 서버 측 렌더링(SSR)을 갖추는 것이 기대됩니다.\n\n우리는 이제 모든 것이 다시 돌아왔다고 말할 수 있을 정도로 전환을 했습니다 🤦 다만, 이제는 종종 클라이언트 측 언어가 서버가 출력하는 내용을 지배하는 경우가 많습니다. 앱을 한 번 작성하고, 서버가 각 페이지의 초기 상태를 흉내내어 순수한 HTML, CSS, JavaScript로 다시 보내줍니다. NextJS와 같은 프레임워크에서는 심지어 서버에서 실행되는 서버 액션도 작성할 수 있습니다!\n\nSSR은 SEO를 더 잘 지원하며 종종 더 빠른 첫 번째 페인트 시간을 제공해 인기를 끌고 있습니다. 요즘에는 SSR이 거의 모든 프로젝트에서 엄격한 요구사항이 되었습니다. Toddle은 또한 완벽한 SSR 지원을 제공하며, 웹페이지를 최적의 SEO를 보장하고 콘텐츠를 가능한 빨리 화면에 표시할 수 있도록 서버에서 복잡한 공식과 API를 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n프레임워크들은 이미 많이 통합되었지만, 아직 혁신할 여지가 있습니다. 저는 대부분의 프레임워크에서 복사, 향상되고 적용될 것으로 예측되는 분야에서 발생하는 흥미로운 개발 동향을 살펴보려고 합니다.\n\n# 재개 가능성\n\n재개 가능성(Resumability)은 서버 측 렌더링의 개선사항입니다. 애플리케이션이 초기 렌더링 프로세스를 처리하는 방법에 대한 진화를 나타내며, 성능과 사용자 경험을 향상시켜줍니다. 예를 들어, React Server Components와 같은 프레임워크들은 스트리밍 기능을 활용하여 컴포넌트를 점진적으로 클라이언트로 전달하여 사용자 경험을 향상시키는 방향을 택하고 있습니다. Qwik은 이 용어를 만들었으며 이미 탁월한 지원을 제공하고 있습니다.\n\n재개 가능성은 미래에 더 중요한 기능으로 부상할 것으로 예상되며, 개발자들은 불가피하게 성능을 최적화하고 애플리케이션의 확장성을 향상시키려는 노력을 하게 될 것입니다. 인터랙티브한 웹 환경에서 애플리케이션을 최적화하기 위한 노력이 더욱 활발해질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 웹 컴포넌트\n\n웹 컴포넌트의 도입은 언제나 코앞에 있는 것으로 보입니다. 아마 영원히 예측일 수도 있지만, 최근에는 Declarative Shadow DOM 및 다른 사용자 정의 요소에 대한 브라우저 지원이 새롭게 추가되었습니다. 웹 컴포넌트는 여러 가지 이유로 환상적입니다. 하나의 프레임워크에서 컴포넌트를 작성한 다음 다른 앱에 문제없이 삽입할 수 있습니다! SolidJS는 1급 시민은 아니지만 웹 컴포넌트를 지원하며, 다른 많은 프레임워크도 일부 지원합니다. toddle에서는 컴포넌트가 웹 컴포넌트 스펙을 직접 상속받아 호환성이 다뿍 있으며 사실 웹 컴포넌트로 만들어집니다. toddle 컴포넌트는 별도 설정 없이 웹 컴포넌트로 내보낼 수 있습니다.\n\n웹 컴포넌트가 주류가 되면, 모든 웹 개발자에게 다양한 개선 사항을 제공합니다:\n\n- 비용 부담 없이 새 프레임워크를 시도하세요! 웹 컴포넌트 하나를 만들고 기존 사이트에 네이티브 요소로 구현할 수 있습니다. 프레임워크를 변경할 때 처음부터 다시 시작할 필요가 없습니다.\n- 조직 내 각 팀이 원하는 프레임워크를 선택할 수 있습니다. 팀 간에 웹 컴포넌트 표준을 통해 통신하고 원활하게 조합할 수 있습니다.\n- 웹 컴포넌트의 상속된 아일랜드 아키텍처는 toddle, solid 또는 Qwik로 만든 더 현대적인 앱으로의 유동적인 이동을 쉽게 만듭니다. 레거시 앱을 천천히 향상시키고 이전 사이트를 대체하며 섬이 퍼질 때마다 컴포넌트를 하나씩 변환할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 덜 혼란스러운 세상 🌎\n\n한동안 새로운 프레임워크가 매주 발표되는 것 같았어요. 아마 아직도 그렇겠지만, 새로운 프레임워크마다 이미 시험된 기본 기능에 수렴하고 있어서 우리가 이미 알고 있는 것과 매우 비슷해요. A 프레임워크를 알고 있다면, 거의 B 프레임워크도 알게 될 거예요. 문법과 일부 기능은 다를 수 있지만, 핵심 개념은 쉽게 적용될 거예요. 이미 React나 Vue를 알고 있다면, Qwik나 toddle도 시도해보세요. 그들을 배우는 것은 참 쉬운 일이에요.\n\n덤으로, 프레임워크들이 수렴함에 따라 W3C 팀에겐 우리 브라우저가 가장 필요로 하는 기능들이 더욱 명백해졌어요. 극도로 인기가 많았던 jQuery의 거의 모든 기능이 현재 이 글을 읽고 있는 브라우저에 기본적으로 내장되어 있어요. 이제는 신호, 선언형 Shadow DOM 등과 같은 기능들도 마찬가지예요. 이러한 변화들은 프레임워크 전체를 다운로드할 필요없이도 프레임워크와 유사한 기능을 활성화할 것이에요. 아마도 마지막 프레임워크는 프레임워크가 아닌, 완전한 바닐라 브라우저 기능들일지도 모르겠네요. 🦀 toddle은 브라우저 능력에 대한 미래지향적 실험을 진행하는 데 흥분하고 있어요. 웹 개발에 참으로 흥미진진한 시기에요!\n\n원문 출처: https://toddle.dev.","ogImage":{"url":"/assets/img/2024-05-17-Thecarcinizationofwebframeworks_0.png"},"coverImage":"/assets/img/2024-05-17-Thecarcinizationofwebframeworks_0.png","tag":["Tech"],"readingTime":7},{"title":"챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법","description":"","date":"2024-05-17 03:23","slug":"2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2","content":"\n\n제1부에서는 수십억 개의 매개변수를 가진 큰 언어 모델에 무료로 액세스하고 활용할 수 있다는 것을 발견했어요. 제처럼 여러분도 하드웨어 한정으로 고민 중이라면, 이 해킹 방법은 하이엔드 GPU나 유료 구독 없이도 Qwen-110B-chat과 같은 대규모 모델과 상호 작용할 수 있는 기쁨을 선사할 거예요.\n\n제2부에서는 지금부터 체험을 더 향상시키기 위해 스트림릿 인터페이스로 동일한 개념을 적용하여 챗봇에 시각적으로 매력적인 스트리밍 효과를 추가할 거예요.\n\n과정을 되짚어보자면, Python, Gradio_client 및 코딩 능력이 필요해요. AI 챗봇을 텍스트 인터페이스를 통해 만드는 데 초점을 맞추었어요:\n\n- 환경 설정: 먼저 가상 환경을 만들고 필요한 패키지(huggingface_hub, gradio-client 및 streamlit)를 설치하세요. PyTorch나 TensorFlow가 필요하지 않으며, 상호 작용은 API를 통해 이루어질 거예요.\n- Hugging Face API 토큰: 사용자는 Hugging Face에 등록하고 모델 추론 API에 액세스하기 위해 API 토큰을 생성해야 해요.\n- 챗봇 코딩: Hugging Face Spaces에서 Gradio의 \"API를 통해 사용\" 기능을 활용하여 이러한 강력한 모델에 Python 코드로 연결하는 방법을 배웠어요. 특히 여러 언어로 상업적 이용을 위한 라이선스가 허용되는 Qwen 시리즈 모델에 초점을 맞췄어요.\n- 스트리밍 효과: 코드 구조를 살펴보면, 모델과 상호 작용할 수 있는 함수를 만드는 방법을 설명했어요. predict() 및 submit() 메서드 중에서 선택하여 스트리밍 효과와 함께 또는 없이 응답을 생성하는 방법을 강조했어요.\n\n<div class=\"content-ad\"></div>\n\n조금 헤매고 있다면 part 1부터 시작하는 것을 제안해요:\n\n## 핵심 코드부터 Streamlit 인터페이스까지\n\n이걸 꼭 말해야 해요: 터미널에서 모든 앱이 정상 작동하지 않으면 그래픽 인터페이스를 시작하지 말아야 해요.\n\n이건 필수 조건이에요! 그래서 Streamlit 인터페이스를 만드는 것이 아주 쉬울 거에요: 이미 이전 파트에서 라이브러리와 상호작용이 어떻게 작동하는지 확인했기 때문이죠.\n\n<div class=\"content-ad\"></div>\n\n모든 것은 이 핵심을 중심으로 움직입니다:\n\n```js\nfrom gradio_client import Client\n\nclient = Client(\"Qwen/Qwen1.5-110B-Chat-demo\")\nresult = client.submit(\n        query='What is Science?',\n        history=[],\n        system=\"You are a helpful assistant.\",\n        api_name=\"/model_chat\"\n)\nprint(result)\n```\n\n그리고 submit() 메소드를 사용하여 스트리밍 객체/반복자를 얻을 수 있다는 것을 알고 있습니다. Streamlit을 사용하면 스트림을 다루기가 훨씬 쉬워집니다. 사실, 애플리케이션은 항상 페이지 위젯을 새로 고치기 때문에 텍스트 애플리케이션에서 사용되는 지루한 알고리즘을 무시할 수 있습니다. 기억하시나요?\n\n```js\n    final = ''\n    for chunk in result:\n        if final == '':\n            final=chunk[1][0][1]\n            print(chunk[1][0][1], end=\"\", flush=True)\n        else:\n            try:\n                print(chunk[1][0][1].replace(final,''), end=\"\", flush=True)\n                final = chunk[1][0][1]\n            except:\n                pass    \n```\n\n<div class=\"content-ad\"></div>\n\nstring.replace()을 사용하여 이미 생성된 것에서 새로운 단어를 빼내는 작업을 했었는데, 더이상 필요하지 않아요.🥳\n\n# Streamlit 앱\n\n습관적인 사람이라... 그래서 내 코드가 다른 프로젝트와 매우 비슷하다는 사실을 발견할 수 있을 거에요. 그런데 괜찮아요! 결국, 템플릿을 적용하고 수정하는 것이 매번 처음부터 시작하는 것보다 쉽고 빠를 수 있거든.\n\n새 파일을 만들어보세요: 제 파일은 st-Qwen1.5–110B-Chat.py라고 해요. 주요 라이브러리를 가져와 세션 상태 전역 변수를 생성하는 것부터 시작해볼까요?\n\n<div class=\"content-ad\"></div>\n\n```python\nimport streamlit as st\nimport time\nimport sys\nfrom gradio_client import Client\n# Internal usage\nimport os\nfrom time import sleep\n\n\nif \"hf_model\" not in st.session_state:\n    st.session_state.hf_model = \"Qwen1.5-110B-Chat\"\n# Initialize chat history\nif \"messages\" not in st.session_state:\n    st.session_state.messages = []\n```\n\n프로그램에서 전역 변수는 공유되어 사용될 수 있습니다. 또한 session_state라고 불리는 이러한 객체들이 streamlit의 매 실행마다 변경되지 않는 것을 필요로합니다.\n\n그리고 2가지 주요 함수를 정의합니다:\n\n```python\n@st.cache_resource\ndef create_client():   \n    yourHFtoken = \"hf_xxxxxxxxxxxxxxxxxxxxxxx\" #여기에 여러분의 HF 토큰을 넣으세요\n    print(f'{st.session_state.hf_model}에 대한 API Gradio 클라이언트를 로딩 중입니다.')\n    client = Client(\"Qwen/Qwen1.5-110B-Chat-demo\", hf_token=yourHFtoken)\n    return client\n\n# 모든 채팅 메시지를 chathistory.txt에 기록하는 함수\ndef writehistory(text):\n    with open('chathistorywen110b.txt', 'a', encoding='utf-8') as f:\n        f.write(text)\n        f.write('\\n')\n    f.close()\n```\n\n<div class=\"content-ad\"></div>\n\n저희는 @st.cache_resource 데코레이터를 사용하고 있습니다. 이는 Qwen1.5-110에 대한 API gradio 클라이언트를 Streamlit이 매 실행마다 로딩하지 않기를 원하기 때문입니다 (이는 분당 1회 이상 발생할 수 있습니다): Gradio 클라이언트 연결이 실행 중에 변경되지 않을 것이기 때문에, 이 리소스를 특별한 메모리에 캐싱하고 있습니다 (@st.cache_resource). 자세한 내용은 여기에서 확인하실 수 있습니다.\n\n## 일부 그래픽 조정\n\n이제 기본 Streamlit 페이지 요소와 챗봇에 사용할 아이콘을 설정할 수 있습니다.\n\n```js\n#아바타\nav_us = '🧑‍💻'  # './man.png'  #\"🦖\"  # \"🧑‍💻\", \"🤖\", \"🦖\"과 같은 단일 이모지입니다. Shortcut은 지원되지 않습니다.\nav_ass = \"🤖\"   #'./robot.png'\n# 기본 모델 설정\n\n### STREAMLIT UI 시작\nst.image('https://github.com/fabiomatricardi/ChatBOTMastery/raw/main/qwen100logo.png', )\nst.markdown(\"### *Streamlit & Gradio_client로 구동됨*\", unsafe_allow_html=True )\nst.markdown('---')\n\nclient = create_client()\n```\n\n<div class=\"content-ad\"></div>\n\n- 채팅 인터페이스에 로컬 이미지를 사용할 수도 있어요 (코드의 주석을 참고하세요!)\n- 마지막으로, create_client()로 클라이언트 연결을 인스턴스화해요.\n\n# 본문 — 채팅 인터페이스\n\nStreamlit은 자신의 위젯에 변경이 발생할 때마다 또는 입력(버튼, 선택기, 라디오 요소 등)으로 사용자 조작이 호출될 때마다 코드를 맨 위부터 다시 실행해요.\n\n그래서 저희는 대화 기록을 맨 위에 먼저 렌더링하기 시작했어요. 여기서는 뭐라도 새롭게 발명한 건 없어요: Streamlit 블로그의 공식 자습서에서 모두 배웠거든요.\n\n<div class=\"content-ad\"></div>\n\n이것은 표준 렌더링입니다. OpenAI API와 호환되는 chat_completion 형식에 모두 적용 가능합니다.\n\n코드로 돌아가서, 우리는 chat_template 메시지들을 표시하고, 메시지 목록을 반복하며 사용자 프롬프트(myprompt)가 제출되기를 기다립니다.\n\n```js\n# 앱 재실행 시 이전 대화 내용을 보여줍니다\nfor message in st.session_state.messages:\n    if message[\"role\"] == \"user\":\n        with st.chat_message(message[\"role\"],avatar=av_us):\n            st.markdown(message[\"content\"])\n    else:\n        with st.chat_message(message[\"role\"],avatar=av_ass):\n            st.markdown(message[\"content\"])\n# 사용자 입력 받기\nif myprompt := st.chat_input(\"인공지능 모델이란 무엇인가요?\"):\n    # 사용자 메시지를 대화 내역에 추가\n    st.session_state.messages.append({\"role\": \"user\", \"content\": myprompt})\n    # 대화 메시지 컨테이너에 사용자 메시지 표시\n    with st.chat_message(\"user\", avatar=av_us):\n        st.markdown(myprompt)\n        usertext = f\"user: {myprompt}\"\n        writehistory(usertext)\n        # 차후 사용을 위해 대화 상대의 응답을 표시\n```\n\n여기에 이상한 writehistory(usertext) 지시문을 추가하고 있는 것을 볼 수 있습니다. 기억하시나요? 처음에 이 함수를 선언했던 거죠? 저는 모든 대화 내용을 로컬 텍스트 파일에 저장하는 버릇이 있어요. 이는 프롬프트를 분석하거나 미래 활용을 위해 자료를 조직화할 때 매우 편리합니다.🙂\n\n<div class=\"content-ad\"></div>\n\n프롬프트에서 제출된 내용을 확인한 후, gradio 클라이언트 인스턴스(client.submit)를 호출하고 스트리밍을 시작합니다 (message_placeholder.markdown(r[1][0][1]+ \"▌\"))\n\n```js\n    # 채팅 메시지 컨테이너에 어시스턴트 응답 표시\n    with st.chat_message(\"assistant\"):\n        message_placeholder = st.empty()\n        full_response = \"\"\n        res  =  client.submit(\n                query=myprompt,\n                history=[],\n                system=\"You are a helpful assistant.\",\n                api_name=\"/model_chat\"\n                )        \n        for r in res:\n            full_response=r[1][0][1]\n            message_placeholder.markdown(r[1][0][1]+ \"▌\")\n\n        message_placeholder.markdown(full_response)\n        asstext = f\"assistant: {full_response}\"\n        writehistory(asstext)       \n        st.session_state.messages.append({\"role\": \"assistant\", \"content\": full_response})\n```\n\n이게 전부에요. full_response는 최종 텍스트가 들어 있는 변수이므로 대화 기록에도 추가하여 표시합니다.\n\n해결했으면 댓글에 알려주세요 👍\n\n<div class=\"content-ad\"></div>\n\n파이썬 파일을 저장한 후 터미널에서 가상 환경을 활성화한 상태에서 다음과 같이 실행하세요.\n\n```js\nstreamlit run .\\st-Qwen1.5-110B-Chat.py\n```\n\n아래처럼 나와야 합니다... 그리고 기본 브라우저가 로컬 URL인 http://localhost:8501로 열리게 됩니다.\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png)\n\n<div class=\"content-ad\"></div>\n\nStreamlit은 로컬 네트워크로의 편리한 라우팅을 제공합니다. 예를 들어, 핸드폰이 동일한 액세스 포인트에 연결되어 있으면 Network URL로 표시된 주소인 http://192.168.2.6:8501을 통해 핸드폰에서도 이 애플리케이션을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_1.png)\n\n# 다른 모델 실행에 대한 참고 사항\n\nGitHub 리포지토리에서도 Streamlit Python 파일을 실행하는 방법을 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- OpenELM 3B\n- Phi-3-mini-Instruct 128k\n- QwenMoE\n\n고객 구성이 변경될 예정입니다 (물론...) 그리고 스트리밍 지침도 변경될 것입니다. 이는 API 엔드포인트가 다른 데이터 유형을 반환하기 때문에 발생합니다. OpenELM 및 Phi-3의 경우 순수한 문자열이 반환되므로 어떠한 사전/튜플 위치에 있는 LLM 응답을 추출할 필요가 없습니다. 여기를 살펴보세요:\n\n그리고 또한 PLEASE, 기억해주세요...\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 모든 복잡성을 다루는 이유는 무엇일까요? 우리는 어떻게 일하는지 배우고, 나만의 AI 비서를 만드는 방법을 알고 싶기 때문입니다. 내가 상상할 수 있는 최고의 목적을 위해 콘텐츠 생성, 학습 자료, 프레젠테이션, 교육 지원 등.\n\n어디에 사용할 건가요?\n\n글이 마음에 드셨으면 좋겣습니다. 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면 다음을 해볼 수 있습니다 :\n\n<div class=\"content-ad\"></div>\n\n- 이 이야기에 대해 많이 박수를 쳐 주세요\n- 기억할 가치가 있는 부분을 강조하십시오 (나중에 찾기 쉽고, 더 나은 기사를 쓰는 데 도움이 될 것입니다)\n- Build Your Own AI를 시작하는 방법을 배우려면, 무료 eBook을 다운로드하세요\n- 내 링크를 사용하여 Medium 멤버십 가입하기 - (무제한 Medium 이야기를 읽으려면 매달 $5)\n- Medium에서 나를 팔로우하기\n- 내 최신 기사 읽기 https://medium.com/@fabio.matricardi\n\n여기 몇 가지 더 흥미로운 읽을거리:\n\n추가 학습 자료\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_3.png)\n\n<div class=\"content-ad\"></div>\n\n이 이야기는 Generative AI Publication에서 발행되었습니다.\n\n최신 AI 이야기를 놓치지 않으려면 Substack, LinkedIn 및 Zeniteq에서 저희와 연락하여 AI의 미래를 함께 창조해보세요!\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_4.png)","ogImage":{"url":"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png"},"coverImage":"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png","tag":["Tech"],"readingTime":9}],"page":"18","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}