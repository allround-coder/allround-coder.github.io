{"pageProps":{"posts":[{"title":"이메일 보내기가 쉬워졌어요 Reactjs와 Nodemailer를 통합해보세요","description":"","date":"2024-05-14 10:43","slug":"2024-05-14-SendingEmailsMadeEasyIntegratingNodemailerwithReactjs","content":"\n\n<img src=\"/assets/img/2024-05-14-SendingEmailsMadeEasyIntegratingNodemailerwithReactjs_0.png\" />\n\n이메일 기능은 현재 대부분의 웹 애플리케이션의 중요한 부분입니다. 사용자들은 애플리케이션으로부터 이메일 확인, 알림, 영수증 등을 기대합니다.\n\nReact.js는 사용자 인터페이스를 구축하는 인기있는 JavaScript 라이브러리로, 기능이 풍부한 웹 앱을 개발하는 데 자주 사용됩니다. React.js 앱에서 강력한 이메일 기능을 활성화하려면 인기 있는 Node.js 이메일 전송 모듈인 Nodemailer를 신속하게 통합할 수 있습니다.\n\n이 포껠 한이 gu이 Nodemailer를 React.js와 통합하는 것을 안내해 React 구성 요소에서 바로 이메일을 보낼 수 있는 기능을 제공합니다.\n\n\n\nNodemailer에 대한 더 많은 정보를 확인하려면 이 안내서를 참조하세요: JavaScript 프레임워크와 Nodemailer 통합하기.\n\n마지막에는 다음을 이해할 것입니다:\n\n- Nodemailer 구성 및 작업하는 방법\n- Nodemailer를 사용하여 React 앱에서 이메일 보내기\n- 템플릿, 오류, 테스트 및 모범 사례 처리\n\n그럼 시작해봅시다!\n\n\n\n# React.js 소개\n\n2013년에 출시된 React.js(React)는 상호작용이 가능한 사용자 인터페이스를 구축하는 데 가장 인기 있는 JavaScript 라이브러리 중 하나로 등장했습니다. 페이스북과 개발자 커뮤니티에 의해 유지보수되는 React는 컴포넌트 개념을 중심으로 구축되어 있습니다.\n\n컴포넌트는 재사용 가능한 모듈식 UI 조각으로, 복잡한 UI를 구성하는 데 사용할 수 있습니다. React는 선언적 패러다임을 사용하여 일반적인 JavaScript와 비교하여 UI 로직 코딩을 간단하게 만듭니다.\n\n다른 주목할 만한 React 기능으로는 가상 DOM, 우수한 조정 알고리즘 성능, 통합 디버깅 개발 도구, 그리고 Node.js와 같은 프레임워크와의 쉬운 통합이 있습니다.\n\n\n\n이러한 기능의 조합으로 인해 React.js가 현재 현대적인 웹 애플리케이션을 만들기 위한 최상의 선택지로 떠오르면서, 넷플릭스, 에어비앤비, 우버이츠와 같은 대형 기업부터 작은 스타트업 앱까지 다양한 앱을 구동하고 있습니다.\n\n# React 애플리케이션 설정\n\n외부 라이브러리인 Nodemailer와 같은 라이브러리를 통합하기 전에 React 프로젝트를 준비해야 합니다. 새로운 React 앱을 만드는 것은 단 한 줄의 명령어로 간단히 할 수 있습니다:\n\n```js\nnpx create-react-app my-app\n```\n\n\n\n아래는 모두 빌드 구성 및 폴더 구조가 설정된 my-app이라는 React 프로젝트를 생성합니다:\n\n- Public — 이미지 및 index.html과 같은 정적 자산을 보관합니다\n- Src\n- JS 컴포넌트를 보관합니다\n- Index.js — 진입 파일\n- Package.json — 의존성을 나열합니다\n- 다양한 구성 파일들\n\n간단히 my-app으로 cd 명령어를 실행하고 npm start를 실행하여 핫 리로딩이 활성화된 개발 서버를 시작할 수 있습니다.\n\n앱이 성장함에 따라 App.js로 컴포넌트를 가져와 index.js를 사용하여 DOM에 렌더링합니다. 이제 앱에 이메일 기능을 추가할 준비가 완료되었습니다!\n\n\n\n# Nodemailer 소개 - Node.js 이메일 전송 라이브러리\n\nReact 앱에서 이메일을 보내려면 SMTP 및 기타 이메일 프로토콜을 원활하게 처리하는 강력한 라이브러리가 필요합니다.\n\n여기서 Nodemailer가 필요한데요 - Node.js 백엔드 코드에서 이메일을 보내는 데 가장 인기 있는 npm 패키지 중 하나입니다.\n\nNodemailer의 주요 기능 몇 가지:\n\n\n\n- SMTP, sendmail, mailgun 및 기타 전송 방식 지원\n- 텍스트, HTML 템플릿 및 첨부 파일을 포함한 이메일 전송\n- SMTP 서버를 위한 간편한 인증\n- 대량 이메일 발송 지원\n- 사용자 정의 스타일 옵션\n- 복잡한 이메일 로직 처리\n\n주간 다운로드 수가 1400만건을 넘는 Nodemailer는 Node 기반 백엔드에 전문적인 이메일 기능을 구축하는 도구로 선택되고 있습니다. 그리고 React와 API 호출을 통해 결합하면 프론트 엔드에서 이메일 기능을 활용할 수 있습니다!\n\n# React에서 Nodemailer 이메일 전송 통합\n\nReact 앱을 설정하고 Nodemailer 기본 사항을 이해한 후, 두 가지를 결합할 수 있습니다:\n아래는 워크플로우 내용입니다:\n\n\n\n- 사용자가 React 프런트엔드에서 이메일 양식 작성\n- 양식 데이터가 제출되면 Node+Express 백엔드로 전송\n- 백엔드에서 Nodemailer 모듈로 API 호출\n- Nodemailer가 이메일 발송 프로토콜을 처리\n- 사용자에게 성공 또는 실패 알림\n\n아래는이 흐름을 구현하는 자세한 단계입니다:\n\n- React에서 이메일 양식 구성요소 생성\n\nUI 양식은 수신자 주소, 제목, 이메일 본문과 같은 필수 세부 정보를 입력합니다.\n\n\n\n```js\n// EmailForm.js\n```\n\n```js\n    import { useState } from 'react'; \n    export default function EmailForm() {\n      const [to, setTo] = useState(\"\");  \n      const [subject, setSubject] = useState(\"\");\n      const [message, setMessage] = useState(\"\");\n      const handleSubmit = (e) => {\n        // Call API\n      };\n      return (\n        <form onSubmit={handleSubmit}>\n          <input \n            type=\"email\"\n            placeholder=\"To\"\n            value={to}\n            onChange={(e) => setTo(e.target.value)}  \n          />\n          <input\n            type=\"text\"\n            placeholder=\"Subject\"\n            value={subject}\n            onChange={(e) => setSubject(e.target.value)}  \n          />\n          <textarea \n            rows=\"3\"\n            placeholder=\"Message\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}  \n          ></textarea>\n          <button type=\"submit\">Send Email</button>\n        </form>\n      )\n    }\n```\n\n- Create Express + Nodemailer Backend\n\n백엔드에는 Express 서버가 필요하며 API 엔드포인트를 노출해야합니다. 필요한 패키지를 설치하세요:```\n\n\n\n```js\nnpm install express nodemailer cors\n```\n\n엔드포인트 내에서 Nodemailer를 구성하고 이메일을 발송할 수 있습니다:\n\n```js\n// server.js\n```\n\n```js\n    const express = require(\"express\");\n    const nodemailer = require(\"nodemailer\");\n    const cors = require(\"cors\");\n    const app = express();\n    app.use(cors());\n    app.use(express.json());\n    const transporter = nodemailer.createTransport({\n      service: \"Gmail\", \n      auth: {\n        user: \"mygmail@gmail.com\",\n        pass: \"password\"\n      }\n    });\n    app.post(\"/api/send\", (req, res) => {\n      const mailOptions = {\n        from: req.body.from,\n        to: req.body.to,\n        subject: req.body.subject,\n        html: req.body.message\n      };\n      transporter.sendMail(mailOptions, (error, info) => {\n         if(error){\n           return res.status(500).send(error);\n         }\n         res.status(200).send(\"이메일이 성공적으로 전송되었습니다\");\n      });\n    });\n    const port = 3030;\n    app.listen(port, () => console.log(`서버가 포트 ${port}에서 실행 중입니다`));\n```\n\n\n\n- React Form을 API와 연결하기\n\naxios 또는 fetch를 사용하여 양식을 제출할 때 API를 호출합니다:\n\n```js\n// EmailForm.js\n```\n\n```js\n    import axios from \"axios\";\n    const handleSubmit = async (e) => {\n      e.preventDefault();\n      try {\n        await axios.post(\"/api/send\", {\n          from: \"my@email.com\",  \n          to,\n          subject,\n          message\n        });\n        alert(\"이메일이 전송되었습니다!\");\n      } catch(err) {\n        alert(err);\n      }\n    };\r\n```\n\n\n\n그것으로 통합이 완료되었습니다! 사용자는 React 프론트엔드와 Nodemailer 백엔드가 제공하는 이메일 알림을 받을 수 있습니다.\n\n# 고급 사용법과 모범 사례\n\n기본적인 내용은 간단하지만, 좀 더 복잡한 사용 사례는 확장성, 오류 처리, 그리고 최적화를 위한 계획이 필요합니다.\n\nReact에서 Nodemailer를 사용할 때 몇 가지 모범 사례:\n\n\n\n- 이메일 템플릿\n\n올바르게 포맷된 HTML 이메일을 보내는 것이 중요합니다. Nodemailer은 Handlebars, Pug, EJS 등 다양한 템플릿 엔진과 잘 작동하여 응답성이 좋고 매력적인 이메일 본문을 만들 수 있습니다.\n\n이메일에는 동적 매개변수가 포함될 수 있으므로 템플릿 생성 논리를 백엔드에 유지하면서 React 프론트엔드에서 사용자 정의를 허용하세요.\n\n- 대기열 및 대량 발송\n\n\n\n대량 이메일을 처리하는 데 큐를 사용하면 직접 발송보다 발신 가능성과 신뢰성이 향상됩니다.\n\nBeeQueue, Bull Queue, 또는 Agenda.js와 같은 솔루션은 배치 처리, 자동 재시도, 콜백 제공 등을 통해 수천 개의 이메일을 보낼 때 오류를 최소화하는 데 도움이 됩니다.\n\n- 캡차 및 스팸 방지\n\n스팸 가입 방지를 위해 이메일 양식 제출을 허용하기 전에 reCAPTCHA와 기타 확인 작업을 통합하세요. 속도 제한을 통해 이메일 엔드포인트 남용을 방지할 수도 있습니다.\n\n\n\n- 분석 및 통찰\n\n중요한 측정 항목을 추적하여 이메일 발송, 전송 상태, 웹훅 클릭 또는 콜백과 같은 정보를 얻으세요. 분석 소프트웨어를 통합하여 캠페인 성과를 시각화하세요.\n\n- 테스트 및 디버깅\n\n이메일 흐름을 관리하는 구성 요소를 철저히 테스트하세요.\n\n\n\n- 리액트 양식 유효성 검사 로직 단위 테스트\n- API 호출을 통한 통합 테스트\n- 이메일 발송 프로세스 로드 테스트\n- 요청 검사를 통한 문제 해결\n## 결론\n\n믿을만한 이메일 기능을 구현하는 데는 작업이 필요하지만 참여도를 높일 수 있습니다. 직관적인 UI를 위해 React를 결합하고 강력한 배송을 위해 Nodemailer를 사용하여 훌륭한 경험을 제공할 수 있습니다.\n\n이 가이드를 활용하여 기본 통합을 시작하고 필요에 맞게 최고의 실천 방법을 발전시키세요.\n\n사용 가능한 많은 가능성이 있습니다. 사용자 정의 스타일링, 고급 인증, A/B 테스트 이메일 및 인기 있는 라이브러리 통합 등이 있습니다. 이메일 기능을 활용하여 React 편안 영역을 넓히는 동안 다음 웹 앱을 업그레이드할 수 있습니다.\n\n\n\n만약 이 포스트가 흥미롭다면, Learnhub 블로그에서 이와 같은 흥미로운 포스트를 더 찾아보세요! 우리는 클라우드 컴퓨팅부터 프론트엔드 개발, 사이버 보안, AI 및 블록체인까지 모든 기술에 대해 다룹니다.\n\n# 자료\n\n- NodeMailer 초급 가이드\n- NodeMailer로 이메일 보내는 방법\n- JavaScript 이메일 프레임워크 4가지\n- Node 문서","ogImage":{"url":"/assets/img/2024-05-14-SendingEmailsMadeEasyIntegratingNodemailerwithReactjs_0.png"},"coverImage":"/assets/img/2024-05-14-SendingEmailsMadeEasyIntegratingNodemailerwithReactjs_0.png","tag":["Tech"],"readingTime":7},{"title":"ReactJS 앱을 GraphQL 미들웨어와 NodeJS-MongoDB 백엔드로 구축하기","description":"","date":"2024-05-14 10:38","slug":"2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend","content":"\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_0.png\" />\n\n가끔 옛날을 그리곤 합니다. 2006년이었던 그 때, 믿을만한 웹사이트를 만드는 가장 좋은 해결책은 HTML, CSS, 때로는 가끔씩 JS만 있었죠. 그 해에 고등학교에서 배운 것과 정확히 일치합니다. 혹시 당시에는 인터넷 서비스를 사용하는 것이 현재처럼 쉽지 않았거나 기술이 아직 그에 미쳐하지 않아 항상 연결된 세상에서 얻을 수 있는 웹사이트의 장점을 활용할 수 없었기 때문인가요.\n\n하지만 웹사이트를 호스팅하는 기술은 개선되고, 웹 앱도 변화합니다. FTP나 버전 관리 없이 일하는 시대는 이미 지나갔으며, 이제 웹 응용 프로그램이 최신 코딩 관행을 준수하고 일반 Javascript 이상의 개발 작업을 촉진하는 것이 이전보다 더 중요합니다. 네, 더 복잡해지긴 했지만, 신기술의 세계는 더 나은 소프트웨어를 만들기 위해 기술을 활용할 수 있는 여러 가지 방법을 제시합니다! 그러나 ReactJS나 AngularJS 같은 프레임워크는 개발 환경에서 효과적으로 작업할 수 있지만, 어플리케이션 내에서 복잡한 상태/데이터 변경을 유지하기 위해서는 정적 코드가 아닌 것이 필요합니다. 이를 위해서 우리가 잘 알고 있는 Filezilla 같은 오래된 도구는 거의 사용되지 않게 되었습니다!\n\n그럼에도 불구하고, 이러한 정적 웹사이트는 여전히 존재합니다. Github Pages 같은 무료 서비스를 통해 프로젝트 빌드를 호스팅하고 브라우저에서 액세스할 수 있습니다. 다만 다른 애플리케이션과의 통신 없이 상태/데이터가 변경되는 것을 보장하는 복잡한 소프트웨어 개발 주기가 관련되어 있지 않다면요. 이러한 무료 서비스의 존재로 취미로 하는 사람들과 개발자들이 과거 기술을 사용하여 스스로 컨텐츠를 온라인에 호스팅할 수 있습니다. HTML, CSS 그리고 JS 파일은 여전히 잘 동작하지만, 언급한 프레임워크를 고려할 때 이러한 장점은 제한됩니다. 물론 AWS, Azure, Heroku와 같은 선도적인 클라우드 호스팅 서비스는 저렴한 호스팅 경험을 제공합니다. 그러나 이러한 서비스의 설정과 구성을 소홀히 한다면, 언제든지 트래픽이 있는지 없는지 애플리케이션을 호스팅하는데 사용되는 컨테이너가 호스팅 비용을 발생시킬 수 있는 소득 미니 진공청소기가 될 수 있습니다.\n\n\n\n이젠 온라인으로 제공되는 서비스들이 있어요. 적절하게 활용하면 아마추어, 초보자, 그리고 작은 비즈니스들에게 유용한 개발 작업이 될 수 있는 겁니다. Vercel과 같은 서비스를 통해 여러 서버리스 애플리케이션을 호스팅할 수 있어요. 이는 애플리케이션을 쉽게 준비하고 배포할 수 있어서 복잡함에 대해 걱정하지 않고 작동시킬 수 있어요.\n\n이 튜토리얼은 소프트웨어 개발 생명주기에 대해 더 완벽한 경험을 제공하기 위한 것이에요. 구성할 분산 시스템의 기본을 다룰 거에요: ReactJS 프론트엔드 앱이 GraphQl 미들웨어에 연결되며, 미들웨어는 다시 백엔드로 NodeJS 익스프레스 앱이나 MongoDB 데이터베이스에 연결하는 서비가 될 거에요. 모두 무료로 호스팅될 거에요.\n\n## 설정\n\n우선 https://github.com/signup 에서 깃허브 계정이 있어야 해요.\n\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_1.png)\n\n계정을 설정했다면 https://github.com/new에서 적어도 한 개의 저장소를 만들 수 있어야 합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_2.png)\n\n이 튜토리얼에서는 ReactJS와 NodeJS를 사용할 것이며 프로젝트용 .gitignore를 만들고 싶다면 아무런 경우에나 나중에 각 앱에 추가할 것입니다!\n이 튜토리얼에서는 다음과 같이 저장소를 만들었습니다:\n\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_3.png\" />\n\n그러면, 재미있는 부분이 시작됐습니다!\n\n## 보일러플레이트 설정\n\n우선, 만든 저장소를 복제하거나 해당 저장소와 동일한 이름의 폴더 안에서 다음 단계를 따라주세요:\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_4.png\" />\n\n첫 번째 커밋을 푸시하거나 계속 진행하세요. 다음으로 터미널을 열고 npm init을 실행해야 합니다. 이렇게 하면 package.json 파일이 생성됩니다. 지금은 다음과 같이 보일 것입니다:\n\n```js\n{\n  \"name\": \"react-graphql-node-mongo-boilerplate\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n} \n```\n\n이게 왜 중요한가요? 이 보일러플레이트에서는 모든 어플리케이션을 함께 모아놓는 데 초점을 맞추었는데, 이 package.json은 그 모든 것을 제어하는 데 유용할 것입니다. 그러나 이 보일러플레이트의 각 부분(프론트엔드, 미들웨어, 백엔드)을 별도의 저장소에 넣는 데 제한이 있으면 안 될 것입니다.\n\n\n\n어쨌든, 프로젝트 구조는 다음과 같이 보이면 충분히 좋을 것입니다:\n\n![프로젝트 구조](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_5.png)\n\n코드를 깃허브 저장소에 푸시해 보세요.\n\n## 프론트엔드\n\n\n\n아래 명령어를 실행해 주세요:\n\n```js\nnpx create-react-app frontend --template typescript\n```\n\n이 명령어를 실행하면 frontend에 TypeScript 템플릿을 이용한 ReactJS 앱이 생성됩니다. 작업이 완료되면 프로젝트 구조는 다음과 같아요:\n\n![프로젝트 구조](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_6.png)\n\n\n\n만약 npm start를 실행하면 브라우저에서 앱이 이렇게 나타날 것입니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_7.png)\n\n보일러플레이트/프론트엔드 통합\n\n다음으로, 보일러플레이트에 대해 말씀드리겠습니다. 프론트엔드 앱을 폴더 외부에서 호출했을 때도 실행할 수 있도록 보장할 거에요. 메인 package.json을 다음과 같이 변경하세요:\n\n\n\n```js\n{\n  \"name\": \"react-graphql-node-mongo-boilerplate\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start-fe\": \"npm run --prefix ./frontend start\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\n참고: 테스트가 중요하지 않다는 것은 아닙니다. 그러나 이 튜토리얼을 좀 더 간략하게 유지하기 위해 테스트는 포함하지 않았습니다.\n\n어쨌든, 이제 start-fe 스크립트가 있다는 것을 알 수 있습니다. --prefix 플래그를 사용하면 내부 디렉토리에서 명령을 실행할 수 있습니다. 이를 통해 전체 위치에서 프론트엔드 앱을 실행할 수 있게 됩니다. 이것은 결국 미들웨어와 백엔드를 동일한 위치와 동시에 실행할 수 있어야 한다는 의미입니다.\n\n## Frontend Vercel 통합```\n\n\n\n이제 적어도 하나 이상의 앱이 있으므로 Vercel을 무료 호스팅 도구로 활용할 수 있도록 배포를 시작할 수 있습니다. 이를 위해 Vercel에서 계정을 만들어야 합니다.https://vercel.com/signup .\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_8.png)\n\n계정을 만들었다면 새 프로젝트를 만들 수 있어야 합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_9.png)\n\n\n\n해당하는 git 저장소를 가져올 수 있어야합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_10.png)\n\n작업 중인 저장소를 선택한 후, 이 프로젝트에 이름을 지정하고 프레임워크 및 루트 디렉토리를 선택할 수 있어야합니다. 단일 저장소에 모든 앱을 가질 수 있도록 허용되기 때문에 매우 유용합니다. 혹시 모노 레포라고 부르는 것 같아요:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_11.png)\n\n\n\n작업을 마치면 배포 버튼을 클릭하세요. 그러면 이와 유사한 화면을 볼 수 있을 거에요:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_12.png)\n\nVisit을 클릭하면 온라인으로 무료로 배포된 ReactJS 앱을 볼 수 있을 거에요!\n\n레포를 연결하고 Vercel에 배포하는 데의 장점은 이제 코드를 쉽게 게시할 수 있다는 것이죠. 코드가 푸시될 때마다 Vercel 프로젝트는 변경 사항을 인식하고 새로운 배포를 준비할 거에요.\n\n\n\n## 미들웨어\n\n이제 다른 애플리케이션을 생성할 차례입니다. 이 미들웨어는 일종의 경비병 역할을 하는 중개자로, 프론트엔드와 백엔드의 서비스 사이의 요청 통신을 라우팅할 수 있는 기능을 제공합니다 (비록 이 튜토리얼에서는 하나의 서비스만 구현하겠지만요).\n\n최상위 디렉토리에서 middleware라는 폴더를 생성합니다. 해당 폴더 안에서 npm init -y 명령을 실행합니다. 이렇게 하면 GraphQL과 Vercel을 함께 실행할 수 있도록 기본 프로젝트가 생성됩니다.\n\nmiddleware 폴더 안에 api 폴더를 만듭니다. 그 안에 server.js라는 파일을 만듭니다. 이 파일은 GraphQL과 Vercel을 설정하는 주요 부분이 구현될 곳입니다. 다음 코드를 추가하세요:\n\n\n\n```js\nconst express = require('express');\nconst { ApolloServer } = require('apollo-server-express');\nconst { createServer } = require('http');\nconst cors = require('cors');\n\nconst isDev = process.env.MIDDLEWARE_ENV === 'dev';\n\nconst typeDefs = gql`\ntype Query {\n    hello: String\n}\n`;\n\nconst resolvers = {\n    Query: {\n        hello: () => 'Hello world!',\n    },\n};\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  introspection: isDev,\n  playground: isDev\n});\nconst app = express();\napp.use(cors());\n\nasync function startServer() {\n  await server.start();\n  server.applyMiddleware({ app });\n\n  // Only listen on HTTP port in local development, not when deployed on Vercel\n  if (!process.env.VERCEL) {\n    const PORT = process.env.PORT || 4000;\n    app.listen(PORT, () => console.log(`💫 Server ready at http://localhost:${PORT}/graphql`));\n  }\n}\n\nstartServer();\nconst requestHandler = app;\nconst vercelServer = createServer((req, res) => requestHandler(req, res));\nmodule.exports = vercelServer;\n```\n\n현재는 백엔드에서 서비스 호출로부터 반환되는 데이터 구조를 해결하는 함수인 resolvers와 백엔드 서비스로의 호출 스키마를 지정하는 것인 typeDefs의 매우 간단한 구현을 사용 중입니다. 배포된 인스턴스에서 이를 수행하면 데이터 스키마가 노출되어도 훨씬 더 안전하지 않을 수 있으므로 개발 환경에서만 인트로스펙션 쿼리를 실행하고 플레이그라운드를 볼 수 있도록 허용합니다.\n\n여기서 개발 환경에 있는지 확인하기 위해 process.env.MIDDLEWARE_ENV를 사용합니다. 이는 실행 중에 사용할 환경을 지정할 수 있어야 한다는 것을 의미합니다. 우리가 dev 환경에서 플레이그라운드를 사용하고 싶기 때문에 npm start를 실행할 때 환경 변수로 사용할 MIDDLEWARE_ENV를 포함하고 싶을 것입니다. NodeJS에서 이를 달성하는 간단한 방법 중 하나는 middleware 폴더 내에 .env 파일을 생성하는 것입니다. 파일은 아래와 같이 보여야 합니다:\n\n```js\nMIDDLEWARE_ENV=dev\n```\n\n\n\n그리고 이제 이 변수를 사용할 수 있어야 합니다. 그냥 .env 파일을 추가했다고 해서 앱이 자동으로 그것을 사용한다고는 알 수 없습니다. 따라서 dotenv 패키지를 설치할 수 있습니다. 그런데 우리가 server.js에서 사용하는 패키지들도 함께 설치해 봅시다! 다음을 실행해 주세요:\n\n```js\nnpm i @vercel/node apollo-server-express dotenv express graphql\n```\n\n@vercel/node를 왜 사용해야 하냐구요? Vercel에 이 앱을 배포할 것이기 때문입니다. 왜냐하면 어째선지 Vercel은 NodeJS 프레임워크 프리셋을 포함하지 않기 때문입니다 :( 이를 위해 middleware 폴더 안에 vercel.json 파일을 생성하세요:\n\n```js\n{\n  \"version\": 2,\n  \"routes\": [\n    {\n      \"src\": \"/graphql\",\n      \"dest\": \"/api/server.js\"\n    },\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/api/server.js\"\n    }\n  ]\n}\n```\n\n\n\n여기서 우리는 어떤 경로든 서버.js를 거쳐야 하며, 프론트엔드에서의 GraphQL 호출(/graphql 경로)이 동일한 위치로 이동한다는 것을 나타냅니다.\n\n이제 로컬에서 실행하려면 package.json을 수정하여 start 명령을 포함해야 합니다:\n\n```js\n\"start\": \"node -r dotenv/config api/server.js\"\n```\n\nnpm start를 실행한 후 http://localhost:4000/graphql로 이동하여 다음을 볼 수 있어야 합니다:\n\n\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n\n\n하지만 이제 우리가 작동시킨 것을 리포에 푸쉬해야 할까요? 이제 .env 파일이 있으니까요. 이 파일에 중요한 정보(주소, 키 등)가 저장되어 있다면, 리포나 이를 의존하는 어플리케이션에 보안 문제가 발생할 수 있습니다. 이제 이 특정 파일을 푸쉬하지 않도록 무시할 수 있도록 하고 싶으므로, 미들웨어 폴더 안에 .gitignore 파일을 추가할 시간입니다. 아래와 같이 추가하세요:\n\n그러나 node_modules와 .env만 추가하면 되지만, 이것은 여러 종류의 프로젝트에 사용할 gitignore 파일 모음을 보유하는 이런 리포에서 얻을 수 있는 종합적인 파일입니다.\n\n하지만 이제, 이런 프로젝트를 완료하고 얼마 후에도 작업을 계속하지 않게 된다면 어떻게 될까요? 코드가 이렇게 남게 되면 사용되는 환경 변수가 무엇인지 기억하지 못할 수 있습니다. 항상 코드 편집기에서 확인할 수 있지만, 그건 별로 필요한 작업이 아닐 수 있습니다. 미래의 자신이나 귀하의 리포를 포크하려는 누군가에게 암시할 수 있는 방법은 .env.sample 파일을 만드는 것입니다. 이 파일은 환경 변수 이름만 포함합니다:```\n\n\n\n```js\nMIDDLEWARE_ENV=\n```\n\n물론, 여기에 민감한 정보가 저장되지 않도록 주의를 기울이는 것이 당신의 책임입니다. 이 미들웨어 설정이 끝난 후에는 미들웨어 폴더 구조가 다음과 같아야 합니다:\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_15.png\" />\n\n## 보일러플레이트/미들웨어 통합\n\n\n\n계속해서 보일러플레이트 프로세스를 이어가려고 합니다. 미들웨어 앱을 외부에서 실행할 수 있도록 하려면 concurrently 패키지가 필요합니다. 미들웨어 폴더 외부에서 다음을 실행해주세요:\n\n```js\nnpm i concurrently -D\n```\n\n이 명령을 통해 한 번에 여러 앱을 실행해야 하기 때문에 개발 종속성으로 패키지가 설치됩니다. 다음으로 두 가지 스크립트를 추가해야 합니다:\n\n```js\n\"start:mw\": \"npm run --prefix ./middleware start\",\n\"start\": \"concurrently \\\"npm run start:fe\\\" \\\"npm run start:mw\\\"\"\n```\n\n\n\n위에 언급된 내용대로 하면, 우리가 미들웨어를 프로젝트 외부에서만 실행하고 싶을 때에는 start:mw를 실행합니다. 새로운 start 명령어는 새로 설치한 concurrently 패키지를 사용하여 start:fe와 start:mw 명령어를 동시에 실행합니다.\n\n하지만 이제 한 개의 패키지가 있기 때문에 package-lock.json 파일과 node_modules 폴더가 생길 것입니다. 파일은 사용할 수 있지만 폴더는 사용하지 않을 거에요. 다음과 같은 .gitignore 파일을 간단히 추가해주세요:\n\n```js\n/node_modules\n```\n\n그러면 레포지토리에 설치된 파일들을 푸시하지 않도록 합니다. 이제 보일러플레이트 구조는 아래와 같을 것입니다:\n\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_16.png)\n\n### 미들웨어 Vercel 통합\n\n이제 Vercel에서 다른 프로젝트를 만들 수 있어야 합니다. 동일한 저장소를 선택하고 이름을 지정하되 Root Directory에서 미들웨어 폴더를 선택하십시오. 이제 두 개의 프로젝트가 배포되어 있어야 합니다!\n\n### 데이터베이스\n\n\n\n\n자, 이제 우리는 무료 NoSQL 데이터베이스를 호스팅하기 위해 MongoDB 계정을 생성할 거에요. 먼저 https://account.mongodb.com/account/register에 접속해서 양식을 채워주세요.\n\n![MongoDB Registration](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_17.png)\n\n양식을 채웠으면, 이 MongoDB 간단 튜토리얼을 따라해보세요:\n- 조직 생성\n- 프로젝트 생성\n- 클러스터 생성\n\n\n\n그러나 클러스터를 만들 때 M0 공유 클러스터 배포를 선택해야 합니다:\n\n![image](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_18.png)\n\n이를 통해 데이터베이스가 무료 공간에 호스팅됨이 보장됩니다. 물론, 상당한 트래픽이나 사용자가 예상되어 많은 저장 공간이 필요한 경우에는 다른 배포 템플릿을 사용하는 것이 좋습니다. 마지막으로, 배포 생성을 클릭하세요.\n\n이 작업을 완료한 후, 왼쪽 메뉴의 Database 옵션으로 이동하여 Browse Collections 버튼을 클릭하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_19.png\" />\n\n한 번 들어오면 샘플 데이터 세트를 추가하여 작업을 시작하거나 본인의 데이터를 추가할 수 있습니다:\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_20.png\" />\n\n데이터베이스 이름과 컬렉션 이름을 작성한 다음 '생성'을 클릭하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_21.png\" />\n\n다음으로, 문서를 삽입할 버튼을 찾아 클릭하세요. 모달에서,\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_22.png\" />\n\n다음 데이터를 추가하세요:\n\n\n\n```js\n[\n  {\"userId\": 1, \"name\": \"Andrew\"},\n  {\"userId\": 2, \"name\": \"Bob\"},\n  {\"userId\": 3, \"name\": \"Charles\"},\n  {\"userId\": 4, \"name\": \"Damian\"}\n]\n```\n\n물론, 데이터베이스 계정, 컬렉션 사용자, 데이터는 모두 테스트 목적으로 제공됩니다. 프로젝트에서는 필요한 데이터를 자유롭게 사용할 수 있습니다. 작업이 완료되면 왼쪽 메뉴에서 \"데이터베이스 액세스\"를 클릭하십시오.\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_23.png\" />\n\n이렇게 하면 백엔드에서 데이터베이스 액세스를 처리할 사용자인 새 데이터베이스 사용자를 추가할 수 있습니다. 버튼을 클릭한 후 사용자 이름과 비밀번호를 입력한 다음 역할을 선택하려면 아래로 스크롤하세요. 읽기 및 쓰기가 충분합니다.```\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_24.png\" />\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_25.png\" />\n\n마지막으로, '사용자 추가'를 클릭해주세요.\n\n## 백엔드\n\n\n\n코드로 돌아가기 전에 MongoDB에서 왼쪽 메뉴에서 '데이터베이스'로 이동한 다음 '연결'을 클릭해주세요:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_26.png)\n\n그다음 '드라이버'를 클릭하고 '드라이버'에서 Node.js를 선택해주세요. 최신 버전을 선택하면 됩니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_27.png)\n\n\n\n언급했듯이, 백엔드에는 mongodb 패키지가 필요합니다. 또한 아래 형식을 따르는 연결 문자열을 메모해주세요:\n\n```js\nmongodb+srv://<db-user>:<db-password>@<cluster-url>?retryWrites=true&w=majority&appName=<app-name>\n```\n\n이를 염두에 두고 저장소로 돌아가봅시다. 루트 수준에서 backend라는 폴더를 만들고 그 안에서 npm init -y를 실행하세요. 이렇게 하면 간단한 NodeJS 앱이 생성됩니다. 또한 안에 index.js 파일을 만들어 아래와 같이 작성해주세요:\n\n```js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst testRouter = require('./routes/testRoutes');\nconst connectToDb = require('./configs/db.config');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(cors({ credentials: true, origin: '*' }));\n\napp.get('/', (req, res) => {\n  res.send('Hello from the NodeJS backend!');\n});\n\napp.use('/test', testRouter.getUsers);\n\nasync function startServer() {\n  const port = process.env.PORT || 5000;\n  app.listen({ port }, () =>\n    console.log(`✨ Server ready at http://localhost:${port}`)\n  );\n  connectToDb();\n}\n\nstartServer();\n```\n\n\n\n프로젝트에서 요청을 처리하고 백엔드 서비스 내에서 특정 기능으로 라우팅하는 데 사용할 express는 RESTful 기능을 활용하여 데이터베이스와 상호 작용하기 위해 앱에 통합됩니다. body-parser는 앱에 통합된 경우 요청 경로로 JSON 데이터를 보내면 이를 올바르게 이해하도록합니다. cors는 도메인에 상관없이 모든 도메인의 교차 출처 요청을 허용하는 데 사용됩니다. testRouter와 connectToDb는 나중에 보여줄 코드에서 가져온 것입니다.\n\n간단히 말하면, index.js의 역할은 기본 포트 5000에서 연결을 설정하고 데이터베이스 연결을 설정하며 두 가지 별도의 요청을 처리하는 것입니다: 하나는 간단한 hello-world 스타일 텍스트를 표시하는 /로의 요청이고, 다른 하나는 데이터베이스에서 사용자를 가져 오는 /test로의 요청입니다. 이를 실제로 보려면 다음 명령을 실행하십시오:\n\n```js\nnpm i body-parser cors dotenv express mongodb\n```\n\n다음으로, 스크립트를 다음과 같이 수정하십시오:\n\n\n\n```js\n\"start\": \"node -r dotenv/config index.js\"\n```\n\n프로그램을 실행할 수 있어야 합니다. 그러나 dotenv을 사용하므로 index.js에서 process.env를 사용하므로 환경 변수를 설정해야 합니다. 다음과 같이 보이는 .env.sample 파일을 만드세요:\n\n```js\nPORT=\nDB_USER=\nDB_PASSWORD=\nDB_CLUSTER_URL=\nDB_APP_NAME=\nDB_NAME=\nDB_COLLECTION=\n```\n\n이러한 변수가 모두 연결 문자열에서 가져오는 변수여야 하며, 포트를 제외한 모든 변수를 채워넣어야 합니다. 포트는 미들웨어나 프론트엔드에 사용된 것과 중복되지 않는 한 5000 또는 다른 값이어야 합니다. 이제 .gitignore를 추가하십시오. 미들웨어에서 사용된 것과 유사하거나 node_modules와 .env를 언급하는 한 사용할 수 있습니다.```\n\n\n\n위 내용을 실제로 보고 싶다면 index.js에서 testRouter와 connectToDb에 언급된 라인들, 그리고 /test route를 주석 처리해보세요. npm start를 실행하면 브라우저에서 다음과 같은 내용을 확인할 수 있을 거에요:\n\n![image](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_28.png)\n\n그래서 적어도 텍스트 요청이 작동하는지 확인할 수 있어요! 이제 db 요청을 실행해보겠습니다. 위의 코드를 테스트했다면 index.js의 코드를 주석 처리하고 다음 두 개 폴더를 만드세요:\n\n- 폴더 configs: 내부에 다음과 같은 내용이 들어 있는 db.config.js 파일을 만들어보세요:\n\n\n\n```js\nconst { MongoClient } = require('mongodb');\nconst uri = `mongodb+srv://${process.env.DB_USER}:` +\n            `${process.env.DB_PASSWORD}@${process.env.DB_CLUSTER_URL}/` +\n            `?retryWrites=true&w=majority&appName=${process.env.DB_APP_NAME}`;\nconst client = new MongoClient(uri);\n\nlet database;\n\nconst connectToDb = async () => {\n  if (database) {\n    return database;\n  }\n  try {\n    await client.connect();\n    console.log('📘 Connected to MongoDB');\n    database = client.db(process.env.DB_NAME);\n    return database;\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nmodule.exports = connectToDb;\n```\n\n요렇게, 이제 connectToDb를 호출할 때 (예를 들어 인덱스 파일에서), 우리의 MongoDB 데이터베이스에 연결합니다. if(database) 블록은 connectToDb를 호출해도, 이미 연결이 시작된 경우 다시 연결하는 대신 해당 연결을 사용할 수 있도록 합니다.\n\n2. 폴더 routes: 내부에 testRoutes.js라는 파일을 만들어 사용자와 관련된 모든 호출을 보관합니다. 다음을 작성하세요:\n\n```js\nconst connectToDb = require('../configs/db.config');\n\nconst getUsers = async (req, res) => {\n  try {\n    let db = await connectToDb();\n    const collection = db.collection(process.env.DB_COLLECTION);\n    const data = await collection.find({}).toArray();\n    res.send({\n      message: '그리고 백엔드도!',\n      data\n    });\n  } catch (error) {\n    console.error('데이터베이스에 액세스하는 중 오류 발생', error);\n    res.status(500).send('데이터 검색에 실패했습니다');\n  }\n};\n\nmodule.exports = {\n  getUsers,\n};\n```\n\n\n\n이전 파일에서 언급한 대로, connectToDb는 여기에서도 쉽게 재사용할 수 있습니다. 다시 연결할 위험이 없습니다. 그러나 이제 이 파일에서는 getUsers를 호출할 때(/test route in index.js에 있는 것과 같이) 환경 변수에서 정의된 컬렉션을 가져와 배열로 변환한 다음 결과를 보내게 됩니다. 간단하게 하기 위해 이 강좌에서는 모든 사용자를 가져오는 방법만 언급할 것입니다. 그러나 이러한 것들을 사용하여 각종 CRUD 작업을 쉽게 구현할 수 있습니다. 연습 삼아 데이터 처리와 조회 방법을 익히실 수 있습니다.\n\n```js\nconst collection = db.collection('users');\n\n// 모두 가져오기\nawait collection.find().toArray();\n\n// 하나 가져오기 (예를 들어, 이름으로 가져오기)\nawait collection.findOne({ name: 'Charles' });\n\n// 하나 생성하기\nawait collection.insertOne({ userId: '5', name: 'Eric' });\n\n// 다수 생성하기\nawait collection.insertMany([\n  { userId: 5, name: 'Ethan' },\n  { userId: 6, name: 'Felix' }\n]);\n\n// 하나 업데이트하기\nawait collection.updateOne({ userId: '5' }, { $set: { name: 'Ethan' } });\n\n// 하나 삭제하기\nawait collection.deleteOne({ userId: '5' });\n\n// userId가 3 미만인 모든 항목 가져오기\nawait collection.find({ userId: { $lt: 3 } }).toArray();\n\n// userId가 [2,3] 리스트에 있는 사용자 이름에 '*' 추가하기\nawait collection.updateMany(\n  { userId: { $in: [2, 3] } },\n  { $set: { name: { $concat: ['$name', '*'] } } }\n);\n\n// userId가 홀수인 모든 항목 삭제하기\nawait collection.deleteMany({ userId: { $mod: [2, 1] } });\n```\n\n이러한 내용을 더 자세히 알아보려면 아주 유용한 Operand 목록을 이곳에서 찾을 수 있습니다: https://www.mongodb.com/docs/manual/reference/operator/query/ 여기서 데이터 처리를 필요로 할 때 데이터를 조작하는 데 도움이 될 것입니다. 어쨌든, 세 파일의 코드가 모두 완성되었으므로 이제 로컬에서 MongoDB를 쿼리할 수 있습니다. 백엔드를 다시 실행하고 브라우저에서 /test로 이동하면 아마도 다음과 같이 보일 것입니다:\n\n<img src=\"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_29.png\" />\n\n\n\n베르셀과 통합해야 하니, 백엔드 폴더 안에 vercel.json을 추가해주세요:\n\n```js\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    }\n  ]\n}\n```\n\n마지막으로, 루트 package.json으로 가서 새로운 스크립트를 추가하고 start 스크립트를 업데이트해주세요:\n\n```js\n\"start:be\": \"npm run --prefix ./backend start\"\n\n\"start\": \"concurrently \\\"npm run start:fe\\\" \\\"npm run start:mw\\\" \\\"npm run start:be\\\"\"\n```\n\n\n\n이로써, boilerplate에서 프론트엔드, 미들웨어 및 백엔드 앱을 함께 실행할 수 있게 됩니다. 이를 통해 백엔드 앱은 이 boilerplate의 목적을 위해 완료되었습니다. 그것에 대한 폴더 구조는 다음과 같아야 합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_30.png)\n\n## 백엔드 Vercel 통합\n\n코드를 푸시한 후, Vercel에서 다른 프로젝트를 생성하고, boilerplate 리포를 선택하여 이름을 지정하며, root 디렉토리에서는 백엔드 폴더를 선택합니다. 프로젝트가 환경 변수를 사용하기 때문에 프로젝트가 작동하지 않을 것임을 유념하십시오. Vercel은 프로젝트에 환경 변수를 추가할 수 있는 옵션을 제공하지만, 이를 고려하도록 한 번 다시 배포하여야 합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_31.png)\n\n몽고디비 데이터베이스를 위해 사용 중인 모든 환경 변수를 추가하고 프로젝트를 다시 배포해야 합니다.\n\n그러나 아직 끝나지 않았어요! `/test` 페이지로 이동하면 페이지에 이런 내용이 나타날 수 있습니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_32.png)\n\n\n\n이 게이트웨이 시간 초과 오류는 단순히 백엔드 배포의 IP 주소가 데이터베이스에 액세스할 권한이 없다는 것을 의미합니다. 해결하기 위해 프로젝트에 MongoDBAtlas 통합을 추가하면 됩니다. 이 경우 백엔드 프로젝트는 여기에 있습니다: https://vercel.com/integrations/mongodbatlas. 이 과정은 비교적 직관적이며 클러스터를 선택할 수 있어야 합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_33.png)\n\n이 작업을 통해 최종적으로 하는 일은 MongoDB 왼쪽 메뉴의 데이터베이스 액세스에서 찾을 수 있는 사용자를 만드는 것이며, 이 사용자는 백엔드에서의 요청을 처리하기 위해 해당 IP를 화이트리스트에 추가합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_34.png)\n\n\n\n바이노 희석 고 내부 값에 대한 SQLite 데이터베이스에서 임베드 된 데이터를 가지고 있습니다. 이 데이터를 포함된 SQL 질의 명령문으로 SELECT하려면 다른 단일값 또는 여러 행 및 열을 반환하는 SQL 함수를 사용하시면 됩니다.\n\n\n\nresolvers 폴더에는 모든 리졸버가 저장될 것입니다. 이들은 백엔드/서비스 호출에서 나오는 데이터를 수정할 수 있는 함수들로, 프론트엔드로 다시 전송하기 전에 준비됩니다. 또한 data-sources 폴더에는 모든 데이터 소스가 저장될 것입니다. 이들은 리졸버에서 받은 데이터를 사용하여 외부 호출(예: 백엔드로)을 수행하는 함수로, 실패 시에는 즉시 반환하거나 예비 동작을 수행합니다.\n\nresolvers 폴더는 test라는 단일 폴더를 가지고 있으며, test.js 파일이 있습니다.\n\n```js\nconst { gql } = require('apollo-server-express');\nconst TestDataSource = require('../../data-sources/test/test.js');\n\nconst testTypeDefs = gql`\ntype UserData {\n  name: String\n  userId: String\n}\ntype Response {\n  message: String\n  data: [UserData]\n}\ntype Query {\n  test: Response\n}\n`;\n\nconst buildTestResponse = (response) => {\n  return {\n    message: `FE integrated successfully with Middleware! ${response.message}`,\n    data: response.data\n  };\n}\n\nconst testResolvers = {\n  Query: {\n    test: async () => {\n      const response = await TestDataSource.test();\n      return buildTestResponse(response);\n    },\n  },\n};\n\nmodule.exports = { testTypeDefs, testResolvers };\n```\n\n여기서 testResolvers는 리졸버로 사용할 모든 함수가 정의되어 있습니다. 데이터 소스 함수 호출을 하고, 데이터를 정리하여 buildTestResponse를 사용하여 프론트엔드로 다시 전송합니다. 또한 testTypeDefs는 사용할 모든 쿼리(이 프로젝트에서는 하나뿐)를 보유하고 응답 유형을 정의합니다. 이로써 우리는 미들웨어를 통해 다양한 쿼리나 변이가 어떤 것인지를 playground에서 확인할 수 있습니다. 이를 통해 프론트 엔드에서 올바른 인수를 사용하여 쿼리 호출을 준비하는 것을 보장합니다.\n\n\n\n```js\nconst axios = require('axios');\n\nclass TestDataSource {\n  static async test() {\n    try {\n      const response = await axios.get(`${process.env.BACKEND_URL}/test`);\n      return response.data;\n    } catch (error) {\n      console.error('백엔드에서 데이터를 가져오기 실패했습니다:', error);\n      return '데이터 가져오기 실패';\n    }\n  }\n}\n\nmodule.exports = TestDataSource;\n```\n\n이 데이터 소스 함수는 axios에 의존하여 백엔드에 요청을 보내고 받은 데이터를 간단히 반환하는 간단한 함수입니다. 이를 필요에 따라 처리할 수 있도록 하겠습니다. 그러므로 axios 패키지를 미들웨어 앱에 추가하기 위해 npm i axios를 실행해야 합니다.\n\n다음으로, api/server.js 파일을 다음과 같이 업데이트해야 합니다. 기본적으로 더미 typedef 및 리졸버를 생성한 것으로 대체합니다.```\n\n\n\n```js\nconst express = require('express');\nconst { ApolloServer } = require('apollo-server-express');\nconst { createServer } = require('http');\nconst cors = require('cors');\nconst { testTypeDefs, testResolvers } = require('../src/graphql/resolvers/test/test.js');\n\nconst isDev = process.env.MIDDLEWARE_ENV === 'dev';\n\nconst server = new ApolloServer({\n  typeDefs: [testTypeDefs],\n  resolvers: [testResolvers],\n  introspection: isDev,\n  playground: isDev\n});\n\nconst app = express();\napp.use(cors());\n\nasync function startServer() {\n  await server.start();\n  server.applyMiddleware({ app });\n\n  // Only listen on HTTP port in local development, not when deployed on Vercel\n  if (!process.env.VERCEL) {\n    const PORT = process.env.PORT || 4000;\n    app.listen(PORT, () => console.log(`💫 서버가 http://localhost:${PORT}/graphql 에 준비되었습니다`));\n  }\n}\n\nstartServer();\n\nconst requestHandler = app;\nconst vercelServer = createServer((req, res) => requestHandler(req, res));\n\nmodule.exports = vercelServer;\n```\n\n`.env.sample` 파일을 업데이트하여 `MIDDLEWARE_ENV` 변수를 포함시킵니다. `.env` 파일에서는 로컬 백엔드에서 로컬 미들웨어에 액세스하려면 `http://localhost:5000`으로 설정해주세요. 코드를 푸시하세요.\n\n## 배포된 미들웨어를 배포된 백엔드에 연결하기\n\n미들웨어 Vercel 앱에는 이제 모든 GraphQL 관련 코드가 있지만, 백엔드의 배포된 인스턴스에 연결되지 않을 것입니다. 왜냐하면 `MIDDLEWARE_ENV` 변수가 없기 때문입니다. 미들웨어 프로젝트의 설정에서 해당 환경 변수를 추가하고, 배포된 백엔드 URL을 사용하세요. 미들웨어에서 `/test`로 요청하면 이제 백엔드에서 해당 경로로부터 데이터를 반환할 수 있어야 합니다.\n\n\n\n\n이제 남은 것은 프론트엔드를 미들웨어에 연결하도록 변경하는 것뿐입니다!\n\n## 로컬 프론트엔드와 로컬 미들웨어 연결하기\n\n모든 코드를 작성하고 성공적인 연결을 수행하려면 먼저 몇 가지 패키지를 추가해야 합니다:\n\n```js\nnpm i @apollo/client dotenv graphql react-router-dom\nnpm i -D @babel/plugin-proposal-private-property-in-object @types/react-router-dom @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo\n```\n\n\n\n프론트엔드 폴더 안에 있는 src 폴더 내의 index.tsx 파일을 찾아서, App 래퍼를 수정하여 ApolloProvider를 도입하고 ApolloClient를 사용해 프론트엔드를 미들웨어에 연결하도록 만들어보세요. 파일은 아래와 같이 보일 것입니다:\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { ApolloProvider } from '@apollo/client';\nimport client from './apolloClient';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  <ApolloProvider client={client}>\n    <App />\n  </ApolloProvider>\n);\n\n// 만약 앱의 성능을 측정하려면, 결과를 기록할 함수를 전달하세요 (예: reportWebVitals(console.log))\n// 또는 애널리틱스 엔드포인트로 전송하세요. 더 자세한 내용은 여기를 참고하세요: https://bit.ly/CRA-vitals\nreportWebVitals();\n```\n\n그러므로 똑같은 수준에서 apolloClient.ts 파일을 생성해야 합니다. 해당 파일은 아래와 같이 보일 것입니다:\n\n```js\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: process.env.REACT_APP_GRAPHQL_ENDPOINT,\n  cache: new InMemoryCache()\n});\n\nexport default client;\n```\n\n\n\n이것은 데이터를 더 빨리 읽고 쓰기 위해 메모리 캐시를 지정하는 매우 간단한 구현입니다. uri는 환경변수로 지정된 env를 사용합니다. 따라서 frontend 폴더 안에 .env.sample 파일을 생성해야 합니다.\n\n```js\nREACT_APP_GRAPHQL_ENDPOINT=\n```\n\n그런 다음 일치시키기 위해 .env 파일을 만드세요. 로컬에서는 이 값을 http://localhost:4000/graphql로 설정해야 합니다. 왜냐하면 이것은 Frontend에서 쿼리를 호출하려면 graphql 호출을 할 로컬 주소이기 때문입니다. Vercel의 경우, Frontend 앱의 설정으로 가서 이 값을 추가하고, 중간웨어 앱의 배포 URL을 사용하도록 해야 합니다(일반적으로 링크를 클릭하면 표시된 것과 동일한 URL에 /graphql를 추가해야 합니다):\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_36.png)\n\n\n\n이제 App.tsx 파일을 다음과 같이 수정해주세요:\n\n```js\nimport React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { Route, BrowserRouter as Router, Switch } from 'react-router-dom';\nimport TestPage from './pages/TestPage';\n\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <Switch>\n          <Route path=\"/test\">\n            <TestPage />\n          </Route>\n          {/* 필요한 만큼 더 많은 경로 추가 */}\n          <Route path=\"/\">\n            {/* TODO: 실제 앱 개발 시에는 이 샘플 코드를 제거하세요 */}\n            <div className=\"App\">\n              <header className=\"App-header\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\" />\n                <p>\n                  Edit <code>src/App.tsx</code> and save to reload.\n                </p>\n                <a\n                  className=\"App-link\"\n                  href=\"https://reactjs.org\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                >\n                  Learn React\n                </a>\n              </header>\n            </div>\n          </Route>\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n```\n\nTODO를 남겨두어서 무엇을 제거해야 하는지 명확하게 했지만, 연결을 테스트하기 위해 /test로 이동하는 Route를 추가했습니다. 여기에는 백엔드를 호출하여 사용자를 가져오는 GraphQL 쿼리가 있을 것입니다. 이는 실제로 함수 컴포넌트인 TestPage 컴포넌트를 호출할 것입니다. 이를 만들어봅시다. src 폴더 내에 pages 폴더를 생성한 다음, 그 안에 TestPage 폴더를 만들고 그 안에 index.tsx 파일을 다음과 같이 작성해주세요:\n\n```js\nimport { useQuery } from '@apollo/client';\nimport React from 'react';\nimport { GET_TEST_DATA } from '../../graphql/queries/test';\nimport { TestQuery } from '../../generated/graphql';\n\nconst TestPage: React.FC = () => {\n  const { data, error, loading } = useQuery<TestQuery>(GET_TEST_DATA);\n\n  if (loading) {\n    return <p>로딩 중...</p>;\n  }\n\n  return error ? (\n    <p>{`오류 발생: ${JSON.stringify(error)}`}</p>\n  ) : (\n    <div>\n      <h2>GraphQL로부터</h2>\n      <p>{`응답: ${data?.test?.message}`}</p>\n      {data?.test?.data?.length && (\n        <ul>\n          {data?.test?.data.map((currUserData, i) => {\n            const { name, userId } = currUserData!;\n\n            return (\n              <li key={i}>\n                {`${userId}: ${name}`}\n              </li>\n            )\n          })}\n        </ul>\n      )}\n    </div>\n  )\n}\nexport default TestPage;\n```\n\n\n\n여기서는 @apollo/client를 사용하여 useQuery 훅을 활용하여 미들웨어로부터 쿼리를 호출하여 백엔드-데이터베이스 통신을 시작할 수 있습니다. 쿼리에서 세 가지 속성을 분해하여 사용합니다: 데이터, 에러, 로딩입니다. 적절하게 명명되었으므로, 다음과 같이 사용할 수 있습니다:\n\n- 데이터는 처음에는 null 상태이지만 쿼리 호출로 반환된 정보를 포함하며, 성공적인 경우\n- 에러는 초기에 false인 부울 값이지만 쿼리 호출 시 오류가 발생하면 true가 됩니다.\n- 로딩은 다른 부울 값이며, 초기에는 false이지만 쿼리가 실행되면 true로 변경되고 완료되면 false가 되거나 오류가 발생하거나 상관없이 false가 됩니다.\n\n위 세 가지 속성을 통해 페이지의 상태에 따라 화면에 무엇을 표시할지 유연하게 설정할 수 있습니다. 데이터가 로드되는 동안 애니메이션을 표시하거나, 실패한 경우 이미지와 함께 오류 메시지를 표시하거나, 쿼리 호출이 성공한 경우 데이터를 표시할 수 있습니다. 그런데 이 글이 너무 길어지지 않도록 하기 위해 각 경우에 텍스트만 표시하겠습니다: 데이터가 로드되는 동안 if 블록, 오류가 발생한 경우 텍스트, 성공적으로 데이터가 로드되면 목록을 표시합니다.\n\n하지만 useQuery 라인으로 돌아와서: '' 괄호 내부의 변수는 가져온 데이터의 응답 유형을 나타내며, 괄호 내부의 변수는 호출할 쿼리를 지정합니다. 따라서 GET_TEST_DATA 및 TestQuery를 가져올 두 개의 파일이 필요합니다.\n\n\n\nGET_TEST_DATA는 간단해요; 미들웨어에 선언된 쿼리와 일치하는 쿼리일 뿐이에요. src 안에 graphql라는 폴더를 만들고 그 안에 queries라는 폴더를 만들고 그 안에 test.ts라는 파일을 만드세요:\n\n```js\nimport { gql } from \"@apollo/client\";\n\nexport const GET_TEST_DATA = gql`\n  query GetTestData {\n    test {\n      message\n      data {\n        name\n        userId\n      }\n    }\n  }\n`;\n```\n\ntest 블록 안에 있는 내용은 응답 페이로드에 다시 보낼 값을 지정해요. 이렇게 하면 필요한 것만 가져오고 가져오려는 값의 프로세스를 최적화할 수 있어요.\n\nTestQuery의 import는 조금 더 복잡해요. import가 나타내는 바처럼, GraphQL 미들웨어에서의 유형을 인식하여 응답 유형을 생성하고 그것을 프론트엔드로 가져와 유형으로 사용할 수 있도록 파일에 넣는 것을 의도했어요. 이를 위해 frontend 폴더 안에 graphql-types.js라는 파일을 만들어요.\n\n\n\n```js\nrequire('dotenv').config();\n\nconst { generate } = require('@graphql-codegen/cli');\n\nasync function generateTypes() {\n  const options = {\n    overwrite: true,\n    schema: process.env.REACT_APP_GRAPHQL_ENDPOINT,\n    documents: 'src/graphql/queries/*',\n    generates: {\n      'src/generated/graphql.tsx': {\n        plugins: [\n          'typescript',\n          'typescript-operations',\n          'typescript-react-apollo'\n        ],\n        config: {\n          withHooks: true,\n          withHOC: false,\n          withComponent: false,\n        }\n      }\n    }\n  };\n\n  try {\n    await generate(options, true); // true here means to print generation logs\n  } catch (error) {\n    console.error('Error during code generation', error);\n  }\n}\n\ngenerateTypes();\n```\n\n이 파일이 실행되면 generateTypes 함수가 호출되고, 이 함수는 @graphql-codegen/cli 패키지의 generate 함수를 호출합니다. 이 함수는 제공된 GraphQL URL(데이터 처리 미들웨어의 GraphQL URL)을 통해 쿼리의 스키마를 검사하고 형성할 문서 디렉토리를 나타냅니다. 쿼리는 src/graphql/queries에 있으므로 해당 디렉토리의 모든 내용을 가져오기로 선택했습니다. 마지막으로 generates 옵션은 이 생성에서 만들 파일과 위치를 언급하며, 설정과 플러그인을 일치시키기 위한 것입니다. src/generated/graphql.tsx 주소가 익숙한가요? 페이지에서 가져오는 생성된 파일입니다!\n\n마지막으로 필요한 코드 변경은 패키지.json 스크립트를 수정하여 graphql-types.js 파일을 호출하는 것입니다. 이를 위해 다음 스크립트를 추가합니다:\n\n```js\n\"generate\": \"node graphql-types.js\",\n```\n\n\n\n프론트엔드가 실행되어 있지 않고 미들웨어가 실행 중인지 확인한 후, npm run generate로 이 스크립트를 실행해야 합니다. 완료되면 frontend/src/generated/graphql.tsx 파일을 확인할 수 있어야 합니다. 파일은 아래와 같이 보이어야 합니다:\n\n```js\nimport { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends '$fragmentName' | '__typename' ? T[P] : never };\nconst defaultOptions = {} as const;\n/** 모든 기본 및 사용자 정의 스칼라, 실제 값으로 매핑됨 */\nexport type Scalars = {\n  ID: { input: string; output: string; }\n  String: { input: string; output: string; }\n  Boolean: { input: boolean; output: boolean; }\n  Int: { input: number; output: number; }\n  Float: { input: number; output: number; }\n};\n\nexport type Query = {\n  __typename?: 'Query';\n  test?: Maybe<Response>;\n};\n\nexport type Response = {\n  __typename?: 'Response';\n  data?: Maybe<Array<Maybe<UserData>>>;\n  message?: Maybe<Scalars['String']['output']>;\n};\n\nexport type UserData = {\n  __typename?: 'UserData';\n  name?: Maybe<Scalars['String']['output']>;\n  userId?: Maybe<Scalars['String']['output']>;\n};\n\nexport type TestQueryVariables = Exact<{ [key: string]: never; }>;\n\nexport type TestQuery = { __typename?: 'Query', test?: { __typename?: 'Response', message?: string | null, data?: Array<{ __typename?: 'UserData', name?: string | null, userId?: string | null } | null> | null } | null };\n\nexport const TestDocument = gql`\n    query Test {\n  test {\n    message\n    data {\n      name\n      userId\n    }\n  }\n}\n    `;\n\n/**\n * __useTestQuery__\n *\n * React 컴포넌트 내에서 쿼리를 실행하려면 `useTestQuery`를 호출하고 필요한 옵션을 전달하십시오.\n * 컴포넌트가 렌더링될 때, `useTestQuery`는 Apollo Client에서 로딩, 에러 및 데이터 속성을 포함하는 객체를 반환하며\n * UI를 렌더링하는 데 사용할 수 있습니다.\n *\n * @param baseOptions 옵션은 다음에서 지원하는 옵션을 전달할 수 있습니다: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @예시\n * const { data, loading, error } = useTestQuery({\n *   variables: {\n *   },\n * });\n */\nexport function useTestQuery(baseOptions?: Apollo.QueryHookOptions<TestQuery, TestQueryVariables>) {\n        const options = { ...defaultOptions, ...baseOptions };\n        return Apollo.useQuery<TestQuery, TestQueryVariables>(TestDocument, options);\n}\n\nexport function useTestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TestQuery, TestQueryVariables>) {\n          const options = { ...defaultOptions, ...baseOptions };\n          return Apollo.useLazyQuery<TestQuery, TestQueryVariables>(TestDocument, options);\n}\n\nexport function useTestSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TestQuery, TestQueryVariables>) {\n          const options = { ...defaultOptions, ...baseOptions };\n          return Apollo.useSuspenseQuery<TestQuery, TestQueryVariables>(TestDocument, options);\n}\n\nexport type TestQueryHookResult = ReturnType<typeof useTestQuery>;\nexport type TestLazyQueryHookResult = ReturnType<typeof useTestLazyQuery>;\nexport type TestSuspenseQueryHookResult = ReturnType<typeof useTestSuspenseQuery>;\nexport type TestQueryResult = Apollo.QueryResult<TestQuery, TestQueryVariables>;\n```\n\nTestQuery라는 줄은 페이지 컴포넌트에서 사용하는 응답 데이터를 보여줍니다. 이제 쿼리 응답 데이터에서 추출하고 데이터를 구성하는 작업이 필요한 마지막 코드 조각입니다! 이제 쿼리 호출에서 필드를 사용할 수 있는 인텔리센스 도움을 얻을 수 있어야 합니다.\n\n## 최종 프로젝트 구조\n\n\n\n이 튜토리얼의 모든 단계를 따르셨면 다음과 같이 완전한 폴더 구조를 갖게 됩니다:\n\n![folder structure](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_37.png)\n\n## 최종 실행\n\n이제 루트 폴더로 이동하여 npm start 명령어를 실행하세요. 이 명령은 프론트엔드, 미들웨어 및 백엔드 세 앱을 시작합니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_38.png)\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_39.png)\n\n프론트엔드가 준비되면 http://localhost:3000/test로 이동하면 미들웨어에서 백엔드로부터 데이터를 받은 후 TestPage의 코드를 볼 수 있습니다. 테스트 리졸버에서 추가된 텍스트를 표시합니다:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_40.png)\n\n\n\n\n코드를 저장소에 푸시하세요. 이렇게 하면 Vercel 프로젝트에서 배포가 트리거됩니다. 작업이 완료되면 프론트엔드 배포로 이동해서 /test로 이동하세요:\n\n![이미지](/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_41.png)\n\n로컬호스트와 같은 동작을 본다면 성공적입니다! 세 앱이 완전히 연결되어 어떤 사용자 정의도 원할 때 준비가 된 상태입니다. 이 튜토리얼의 마지막 단계에서 바로 작업하길 원한다면 아래 저장소를 포크해도 괜찮습니다: https://github.com/gfcf14/react-graphql-node-mongo-boilerplate 세 앱의 설정을 따릅니다. 다만 Vercel 앱은 직접 설정해주어야 합니다.\n\n그럼 즐거운 코딩되세요! 이 기사가 웹 개발의 전반적인 소프트웨어 개발 경험에 대해 읽는 사람을 깨우칠 수 있기를 희망합니다.","ogImage":{"url":"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaReactJSAppwithGraphQLMiddlewareandNodeJS-MongoDBBackend_0.png","tag":["Tech"],"readingTime":35},{"title":"React Hook Form과 Zod를 사용하여 React에서 양식 유효성 검사 다루기","description":"","date":"2024-05-14 10:34","slug":"2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod","content":"\n\n<img src=\"/assets/img/2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod_0.png\" />\n\n# 소개\n\n웹 애플리케이션에서 폼 유효성 검사는 데이터 무결성을 보장하고 일관된 사용자 경험을 제공하는 데 중요합니다. React에서 폼 유효성을 처리하는 것은 때때로 복잡하고 시간이 많이 소요될 수 있습니다. 그러나 적절한 도구와 라이브러리를 사용하면 이 과정을 간단화하고 효율적으로 만들 수 있습니다.\n\n이 글에서는 React Hook Form, Zod, 그리고 TypeScript를 활용하여 React에서 폼 유효성을 처리하는 방법을 살펴볼 것입니다. React Hook Form은 폼 상태와 유효성을 관리하기 위한 사용하기 쉬운 API를 갖춘 가벼운 조절 가능한 폼 라이브러리입니다. Zod는 스키마 유효성 검사 라이브러리로 데이터 구조를 정의하고 유효성을 검사하는 것을 간단하게 만들어줍니다.\n\n\n\nReact Hook Form과 Zod를 결합하여 React 애플리케이션에서 강력하고 신뢰할 수 있는 폼 유효성 검사 시스템을 만들 수 있습니다. 시작해보고 폼 유효성을 효과적으로 다루는 주요 개념, 기술 및 코드 예제를 살펴보겠습니다.\n\n데모에서는 Sass를 사용하여 유효성 검사 및 기본 스타일이 적용된 기본 양식을 만들어 보겠습니다(아래 이미지 참조). 이 데모는 React의 새로운 앱을 만들기 위해 React가 커뮤니티에서 인기 있는 React 기반 프레임워크를 사용할 것을 권장하는 Nextjs React 프레임워크를 사용하여 앱을 생성합니다. 자세한 내용은 여기를 참조하세요.\n\n![이미지](/assets/img/2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod_1.png)\n\n# React Hook Form과 Zod 설정\n\n\n\n폼 유효성 검사를 처리하기 전에, 프로젝트에 React Hook Form과 Zod를 설치해야합니다. 이미 React 또는 Next.js 프로젝트가 설정되어 있고 폼이 생성되어 있다고 가정하고, 다음 단계를 따라 진행하세요:\n\n- 필요한 종속성 설치:\n\n```js\nnpm install react-hook-form zod @hookform/resolvers\n```\n\n2. 필요한 컴포넌트와 훅을 가져옵니다:\n\n\n\n```js\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n```\n\n3. Zod을 사용하여 폼 스키마를 정의하세요:\n\n저희의 유효성 검사 스키마는 새로운 사용자를 등록하는 폼을 유효성 검사하기 위해 사용자명, 이메일, 비밀번호, 그리고 비밀번호 확인을 포함할 것입니다.\n\n```js\n const schema = z.object({\n    username: z.string().min(3, {message: '사용자 이름은 최소 3자 이상이어야 합니다'}),\n    email: z.string().min(1, {message: '이메일은 필수 항목입니다'}).email('유효하지 않은 이메일 주소입니다'),\n    password: z.string().min(6, {message: '비밀번호는 최소 6자 이상이어야 합니다'}),\n    confirmPassword: z.string().min(6, {message: '비밀번호는 최소 6자 이상이어야 합니다'})\n  })\n\n//스키마에서 유추된 타입 추출하기\ntype ValidationSchemaType = z.infer<typeof schema>\n```\n\n\n\n4. 양식과 유효성 해결 프로그램을 설정하십시오:\n\n```js\n const { register, handleSubmit, formState: { errors } } = useForm<ValidationSchemaType>({\n    resolver: zodResolver(schema),\n  });\n```\n\nReact Hook Form과 Zod를 설정했으니, 이제 React 애플리케이션에서 양식 유효성 검사를 처리할 준비가 되었습니다.\n\n# 기본 양식 유효성 검사\n\n\n\nReact Hook Form 및 Zod를 사용한 폼 유효성 검사의 기본 사항부터 시작해 봅시다. 개별 폼 필드의 유효성을 검사하고 오류 메시지를 표시하며, 폼 제출을 처리하는 방법을 살펴보겠습니다.\n\n- 폼 필드 등록:\n\nReact Hook Form의 register 함수는 폼 필드를 등록하는 데 사용되며, 폼 필드의 속성 이름 또는 스키마 이름을 인수로 취합니다.\n\n```js\n<input type=\"text\" {...register('name')} />\n```\n\n\n\n```js\n\"use client\";\n\nimport React from 'react'\nimport styles from './form.module.scss'\nimport { useForm, SubmitHandler } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst Form = () => {\n\n  const schema = z.object({\n    username: z.string().min(3, {message: 'Username must be at least 3 characters'}),\n    email: z.string().min(1, {message: 'Email is required'}).email('Invalid email address'),\n    password: z.string().min(6, {message: 'Password must be at least 6 characters'}),\n    confirmPassword: z.string().min(6, {message: 'Password must be at least 6 characters'})\n  }).refine((data) => data.password === data.confirmPassword, {\n    path: ['confirmPassword'],\n    message: 'Passwords does not match'\n  })\n\n  //extract the inferred type from schema\n  type ValidationSchemaType = z.infer<typeof schema>\n\n  const { register, handleSubmit, formState: { errors } } = useForm<ValidationSchemaType>({\n    resolver: zodResolver(schema),\n  });\n\n  return (\n    <form className={styles.form_main}>\n      <label htmlFor=\"username\">\n        Username:\n        <input type=\"text\" placeholder='username goes here...' {...register('username')} />\n      </label>\n      <label htmlFor=\"email\">\n        Email:\n        <input type=\"email\" placeholder='email goes here...' {...register('email')} />\n      </label>\n\n      <label htmlFor=\"password\">\n        Password:\n        <input type=\"password\" placeholder='password goes here...' {...register('password')} />\n      </label>\n\n      <label htmlFor=\"confirmPassword\">\n        Confirm Password:\n        <input type=\"password\" placeholder='Confirm password' {...register('confirmPassword')} />\n      </label>\n      <button type='submit'>Login</button>\n    </form>\n  )\n}\n\nexport default Form\n```\n\n2. Displaying error messages:\n\nReact Hook Form은 errors 객체를 반환하는데, 이 객체는 formState에서 비구조화된 것입니다. errors를 통해 우리는 양식 오류에 접근할 수 있고 각 등록된 양식 필드에 대한 지정된 유효성 제약 메시지를 반환합니다.\n\n```js\nconst { register, handleSubmit, formState: { errors } } = useForm<ValidationSchemaType>({\n    resolver: zodResolver(schema),\n  });\n```\n\n\n\n그럼 각 폼 필드에 대한 유효성 검사 스키마에서 선언된 오류 메시지를 조건부로 렌더링할 수 있어요. 또한, 잘못된 정보를 입력했을 때 입력란 테두리를 빨간색으로 만들기 위해 error_input이라는 CSS 클래스도 만들었어요.\n\n```js\n{errors.username && <span>{errors.username.message}</span>}\n```\n\n```js\n<form className={styles.form_main}>\n      <label htmlFor=\"username\">\n        Username:\n        <input type=\"text\" placeholder='사용자명을 입력해주세요...' {...register('username')} className={errors.username && styles.error_input}/>\n        {errors.username && (\n          <span className={styles.error}>{errors.username?.message}</span>\n        )}\n      </label>\n      <label htmlFor=\"email\">\n        Email:\n        <input type=\"email\" placeholder='이메일을 입력해주세요...' {...register('email')}  className={errors.email && styles.error_input}/>\n        {errors.email && (\n          <span className={styles.error}>{errors.email?.message}</span>\n        )}\n      </label>\n\n\n      <label htmlFor=\"password\">\n        Password:\n        <input type=\"password\" placeholder='비밀번호를 입력해주세요...' {...register('password')}  className={errors.password && styles.error_input}/>\n        {errors.password && (\n          <span className={styles.error}>{errors.password?.message}</span>\n        )}\n      </label>\n\n      <label htmlFor=\"confirmPassword\">\n        Confirm Password:\n        <input type=\"password\" placeholder='비밀번호를 확인해주세요' {...register('confirmPassword')}  className={errors.confirmPassword && styles.error_input}/>\n        {errors.confirmPassword && (\n          <span className={styles.error}>{errors.confirmPassword?.message}</span>\n        )}\n      </label>\n      <button type='submit'>로그인</button>\n    </form>\n```\n\n3. 폼 제출 처리:\n\n\n\n우리는 onSubmit이라는 사용자 정의 폼 제출 핸들러 함수를 생성하고, 폼 데이터를 콘솔에 출력합니다.\n\n```js\nconst onSubmit: SubmitHandler<ValidationSchemaType> = (data) => {\n    console.log(data)\n}\n```\n\n그런 다음, React Hook form에서 제공하는 handleSubmit 함수에 전달합니다.\n\n```js\n\"use client\";\n\nimport React from 'react'\nimport styles from './form.module.scss'\nimport { useForm, SubmitHandler } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst Form = () => {\n\n  const schema = z.object({\n    username: z.string().min(3, {message: 'Username must be at least 3 characters'}),\n    email: z.string().min(1, {message: 'Email is required'}).email('Invalid email address'),\n    password: z.string().min(6, {message: 'Password must be at least 6 characters'}),\n    confirmPassword: z.string().min(6, {message: 'Password must be at least 6 characters'})\n  }).refine((data) => data.password === data.confirmPassword, {\n    path: ['confirmPassword'],\n    message: 'Passwords does not match'\n  })\n\n  type ValidationSchemaType = z.infer<typeof schema>\n\n  const { register, handleSubmit, formState: { errors } } = useForm<ValidationSchemaType>({\n    resolver: zodResolver(schema),\n  });\n\n  // Form submit handler\n  const onSubmit: SubmitHandler<ValidationSchemaType> = (data) => {\n    console.log(data)\n  }\n\n  return (\n    <form className={styles.form_main} onSubmit={handleSubmit(onSubmit)}>\n      // 다른 코드\n    </form>\n  )\n}\n\nexport default Form\n```\n\n\n\n이 예시에서는 React Hook Form에서 제공하는 register 함수를 사용하여 '사용자 이름', '이메일\" 및 \"비밀번호\" 필드를 등록합니다. 그런 다음 필드에 오류가 있는 경우 오류 메시지를 표시합니다. 마지막으로, 폼 제출은 제출된 폼을 처리하는 onSubmit 함수를 호출하여 처리합니다. 아래 데모를 확인해보세요.\n\n# 일부 고급 폼 유효성 검사 기술\n\n다음 기술들 중 일부를 살펴보겠습니다:\n\n- Cross-Field Validation:\n\n\n\n리파인 커스텀 유효성 검사기는 비밀번호와 확인 비밀번호를 상호 검증하는 데 사용할 수 있습니다. 유효성 검사 함수와 양식 데이터를 가져와 비밀번호가 확인된 비밀번호와 동일한지 확인하고 오류 경로를 확인 비밀번호로 설정합니다.\n\n```js\n// 비밀번호와 확인 비밀번호를 상호 검증\nconst schema = z.object({\n    username: z.string().min(3, {message: '사용자 이름은 최소 3자 이상이어야 합니다'}),\n    email: z.string().min(1, {message: '이메일이 필요합니다'}).email('잘못된 이메일 주소입니다'),\n    password: z.string().min(6, {message: '비밀번호는 최소 6자 이상이어야 합니다'}),\n    confirmPassword: z.string().min(6, {message: '비밀번호는 최소 6자 이상이어야 합니다'})\n  }).refine((data) => data.password === data.confirmPassword, {\n    path: ['confirmPassword'],\n    message: '비밀번호가 일치하지 않습니다'\n  })\n```\n\n이 예시에서는 '확인 비밀번호' 필드가 '비밀번호' 필드와 일치하는지 확인합니다. 값이 일치하지 않으면 오류 메시지가 표시됩니다.\n\n2. 비동기 유효성 검사:\n\n\n\n```js\nconst schema = z.object({\n  email: z.string().email(\"유효하지 않은 이메일 주소\").refine(async (value) => {\n    // 비동기 유효성 검사 로직 수행 (예: 데이터베이스에 이메일이 있는지 확인)\n    // 유효성이 통과되면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n  }, '이메일이 이미 존재합니다'),\n});\n```\n\n이는 데이터를 외부 소스와 대조하여 유효성을 검사해야 할 때 유용합니다. 이메일이 이미 데이터베이스에 존재하는지 확인하는 것과 같은 상황에서 유용합니다.\n\n# 결론\n\nReact에서 양식 유효성을 처리하는 것은 견고하고 사용자 친화적인 웹 애플리케이션을 구축하는 데 필수적입니다. React Hook Form과 Zod의 조합으로 프로세스를 간소화하고 효율적으로 사용하는 방법에 대해 살펴보았습니다. React Hook Form과 Zod를 구성하는 방법, 기본 및 고급 양식 유효성 검사 수행, 복잡한 유효성 시나리오 다루기, 사용자 경험 향상 방법 등을 배웠습니다.```\n\n\n\n귀하가 원하는 기준에 따라 사용자 입력을 유효성 검사할 수 있도록 React Hook Form과 Zod의 강력함과 유연성을 활용할 수 있습니다. 이를 통해 데이터 무결성이 향상되고 오류가 줄어들며 더 쾌적한 사용자 경험을 제공할 수 있습니다. 다음 React 프로젝트에서 이러한 기술과 라이브러리를 실험하여 양식 유효성을 효과적이고 효율적으로 처리해 보세요.\n\n더 많은 정보를 원하시면 React hook form 및 Zod 공식 문서를 참조하여 해당 라이브러리 및 고급 개념에 대해 더 많이 알아보세요.\n\n데모의 GitHub 저장소는 여기에서 확인할 수 있습니다. 전체 코드와 CSS 스타일링을 확인할 수 있습니다.\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod_0.png"},"coverImage":"/assets/img/2024-05-14-HandlingFormValidationsinReactwithReactHookFormandZod_0.png","tag":["Tech"],"readingTime":10},{"title":"React Native 정렬 또는 필터가 있는 긴 목록의 성능 최적화","description":"","date":"2024-05-14 10:33","slug":"2024-05-14-ReactNativePerformanceoptimizationforlonglistswithsortorfilters","content":"\n\nReact Native에서 긴 요소 목록을 다루는 것은 꽤 도전적일 수 있어요. RN 문서에서는 FlatList를 사용하는 것을 권장하지만, 제공된 예제는 종종 방대한 목록이나 필터 적용 및 목록 정렬과 같은 시나리오를 다루지 않아서 많은 애플리케이션에서 필수적인 요구 사항들을 보여주지 못합니다.\n\n# 예시와 관찰\n\nRN 문서의 성능에 따른 가이드에 따라 매우 간단한 사용자 인터페이스를 갖춘 새로운 React Native 프로젝트를 만들어 보겠습니다. 우리는 이 인터페이스를 따라 MOCK 데이터셋을 만들었습니다. 이 데이터셋은 다음 인터페이스를 따르는 500개의 제품 항목이 있어요:\n\n```js\ninterface Item {\n id: number\n name: string\n expiration_date: string\n qty: number\n}\n```\n\n\n\n그럼, 헤더와 두 개의 버튼이 있는 FlatList를 구현했습니다. 하나의 버튼은 ID가 가장 높은 순서대로 목록을 정렬하고, 다른 하나는 ID가 가장 낮은 순서대로 정렬합니다.\n\n```js\nexport const List = () => {\n  const [orderBy, setOrderBy] = useState<'normal' | 'reverse'>('normal');\n\n  const renderListItem = useCallback(({item, index}: {item: Item; index: number}) => {\n    return <ListItem item={item} index={index} />;\n  }, []);\n\n  const ListHeaderComponent = useCallback(() => {\n    return (\n      <Header\n        title={'Order by'}\n        onPressButton1={() => {\n          setOrderBy('normal');\n        }}\n        onPressButton2={() => {\n          setOrderBy('reverse');\n        }}\n      />\n    );\n  }, []);\n\n  const orderedData = useMemo(() => {\n    return orderBy === 'normal'\n      ? mockData.data.sort((a, b) => a.id - b.id)\n      : mockData.data.sort((a, b) => b.id - a.id);\n  }, [orderBy]);\n\n  return (\n    <>\n      <FlatList\n        ListHeaderComponent={ListHeaderComponent}\n        keyExtractor={({id}) => id.toString()}\n        renderItem={renderListItem}\n        data={orderedData}\n        stickyHeaderIndices={[0]}\n      />\n    </>\n  );\n}\n```\n\nListItem 컴포넌트를 메모이즈하여 불필요한 다시 렌더링을 피했습니다. 인덱스에 따라 배경색이 결정되며, 동작을 이해하기 위해 인덱스를 기록하고 있습니다.\n\n```js\nexport const ListItem = memo(({item, index}: {item: Item; index: number}) => {\n  const backgroundColor = item.id % 2 === 0 ? '#red' : 'pink';\n\n  console.log(index);\n  return (\n    <View\n      style={{\n        ...styles.container,\n        backgroundColor,\n      }}>\n      <Text>\n        {item.name} - {item.id}\n      </Text>\n    </View>\n  );\n})\n```\n\n\n\nFlatList은 동작을 이해하고 문제를 해결하는 데 도움이 되는 세 가지 중요한 속성을 제공합니다:\n\n- initialNumToRender: 초기 배치에서 렌더링할 아이템 수를 결정하며, 화면을 채우되 과도하게 많이 렌더링하지 않아야 합니다.\n- maxToRenderPerBatch: 각 증분 렌더 배치에서 렌더링할 최대 아이템 수를 지정합니다.\n- updateCellsBatchingPeriod: 배치 렌더 사이의 밀리초 단위 지연 시간을 설정합니다.\n\n예를 들어, initialNumToRender=10, maxToRenderPerBatch=10, updateCellsBatchingPeriod=10으로 설정하면, 리스트는 초기 10개 아이템을 먼저 렌더링한 다음, 10ms마다 10개씩 더 추가하여 완료될 때까지 부드럽게 렌더링되며, JS 스레드를 차단하지 않습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*okgjSFX3jUmN-5CM2dAESw.gif)\n\n\n\n리스트를 스크롤하는 동안 추가 항목이 배경에서 완료될 때까지 렌더링됩니다.\n\n![scrolling](https://miro.medium.com/v2/resize:fit:1200/1*cDzV6w7LguahgYZ4ywfQig.gif)\n\n그러나 목록을 정렬할 때 예상대로 동작하지 않습니다.\n\n![sorting](https://miro.medium.com/v2/resize:fit:1200/1*a4yZcj1iJYYel3tllSJqEw.gif)\n\n\n\nRN의 가이드라인을 따라 FlatList 성능을 향상시키려고 노력했지만, 목록이 예상대로 동작하지 않았어요. 그러나 성능을 향상시키는 것으로 보이는 잠재적인 해결책을 고안해 냈어요.\n\n주문 상태가 변경될 때마다 리스트의 다시 마운트를 트리거할 수 있도록 키를 사용함으로써, 초기 마운트 과정을 완료될 때까지 JS 스레드를 차단하지 않고 효율적으로 진행할 수 있어요.\n\n```js\n<FlatList\n    key={orderBy}\n    ...나머지 초기 속성\n/>\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*yLeRxhhh2BRKBJ2MBERS5Q.gif)\n\n\n\n행동을 더 잘 이해하기 위해 initialNumToRender=20, maxToRenderPerBatch=1 및 updateCellsBatchingPeriod=500으로 설정합니다.\n\n![이미지1](https://miro.medium.com/v2/resize:fit:1200/1*1JSiEZjP8PLNiP8I2OEvVw.gif)\n\n그러나 키가 삭제되면 어떻게 되나요?\n\n![이미지2](https://miro.medium.com/v2/resize:fit:1200/1*vnZ50uq7oTxc1T_vdNHopQ.gif)\n\n\n\n요약하자면, 렌더링된 목록에서 데이터를 필터링하거나 정렬하는 것은 초기 렌더링 시 항목 수와 동일한 수의 항목이 렌더링될 때까지 JS 스레드를 차단하는데 이상적인 방법이 아닙니다. \n목록의 성능을 향상시킬 수 있습니다. 목록을 강제로 마운트하여 교차 상태를 키로 전달하면 목록의 데이터도 변경할 수 있습니다.\n\n저장소: https://gitlab.com/sebastian.e.vogel/reactnativelonglistperformance","ogImage":{"url":"/assets/img/2024-05-14-ReactNativePerformanceoptimizationforlonglistswithsortorfilters_0.png"},"coverImage":"/assets/img/2024-05-14-ReactNativePerformanceoptimizationforlonglistswithsortorfilters_0.png","tag":["Tech"],"readingTime":4},{"title":"TurboRepo, Nextjs 및 Tailwind CSS를 사용하여 Monorepo 설정하기","description":"","date":"2024-05-14 10:31","slug":"2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS","content":"\n\n현대 웹 애플리케이션이 크기와 복잡성 모두 증가함에 따라, 개발자들은 코드베이스를 더 효율적으로 관리할 방법을 찾고 있습니다. 모노리포는 여러 프로젝트를 단일 저장소에서 관리할 수 있는 솔루션을 제공합니다.\n\n그러나 모노리포를 수동으로 설정하는 것은 거대한 작업일 수 있습니다. 여기서 Turborepo가 나타납니다. Turborepo는 여러 단계를 자동화하여 모노리포를 만드는 프로세스를 간소화하는 도구입니다. 이 글에서는 Turborepo를 사용하여 Next.js(기본 프로젝트)를 프로젝트 베이스로, Tailwind CSS를 스타일링으로 포함하는 모노리포를 설정해보겠습니다.\n\n시작해봅시다!\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_0.png)\n\n\n\n# 1. 새로운 Monorepo 생성하기\n\n먼저 다음 명령어를 사용하여 Turborepo Monorepo를 만들어보겠습니다:\n\n```js\nnpx create-turbo@latest\n```\n\n이 명령어를 실행하면, 생성 위치를 선택하고 패키지 매니저를 선택하라는 프롬프트가 표시됩니다. 본 문서에서는 yarn을 사용하겠지만, npm이나 pnpm과 같은 원하는 패키지 매니저를 선택할 수 있습니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_1.png\" />\n\n설치가 완료되면 디렉토리로 이동하세요 (cd yourProjectName) 그리고 원하는 IDE에서 프로젝트를 열어보세요.\n\n이제 다음 명령어를 사용하여 실행 테스트를 할 수 있습니다.\n\n```js\nyarn install && yarn dev\n```\n\n\n\n만약 당신의 터미널이 아래와 같이 나타나면, 세팅이 완료된 것입니다.\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_2.png)\n\n## 2. 디렉터리 설명\n\n자, 이제 Turborepo에 의해 생성된 폴더 구조와 프로젝트에 대해 이야기해보겠습니다.\n\n\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_3.png)\n\n- apps는 이 단일 리포지토리에 있는 모든 애플리케이션입니다. 기본적으로 (npx create-turbo@latest로부터), docs 및 web 애플리케이션(Next.js)이 생성됩니다.\n- packages 파일에는 eslint, tsconfig 및 모든 리포지토리 전체에 걸쳐 요소를 지배하는 공유 구성요소가 포함됩니다.\n- package.json 이 설정의 주목할만한 측면 중 하나는 Yarn 작업 영역을 사용하여 단일 리포지토리 내에서 여러 패키지와 종속성을 관리할 수 있다는 것입니다. package.json에는 또한 apps 디렉터리에서 단일 리포지토리의 애플리케이션을 실행하는 데 필요한 종속성 및 스크립트도 포함되어 있습니다.\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_4.png)\n\n- turbo.json은 Turborepo가 파이프라인을 구성하고 관리하는 데 사용하는 구성 파일입니다. 이 파이프라인은 특정한 순서로 실행되는 일련의 명령을 조직화하고 관리합니다. 예를 들어 빌드 파이프라인은 신뢰성과 효율성을 위해 ^로 표시된 dependsOn 기호와의 위상적인 종속성에 의존할 수 있습니다.\n\n\n\n# 3. Tailwind CSS 설정하기\n\n다양한 프로젝트에서 tailwind.config.js 파일이 단일 정보 원천으로 작용하도록 보장하기 위해, packages 폴더 내에 새 구성 패키지를 생성할 예정입니다. 이는 앱과 packages/ui 디렉토리 모두에서 Tailwind 클래스를 사용할 수 있게 해줍니다.\n\n다음 단계를 따를 것입니다:\n\n## A. packages 폴더에 Tailwind CSS 구성 설정하기\n\n\n\n- 먼저 packages 디렉토리 내에 configs 폴더를 생성합니다. 이 폴더 안에 package.json, tailwind.config.js 및 postcss.config.js와 같은 설정에 필요한 여러 필수 파일을 생성할 것입니다.\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_5.png)\n\npackage.json\n\n```js\n{\n  \"name\": \"@mrizkiaiman/configs\",\n  \"version\": \"0.0.0\",\n  \"private\": true\n}\n```  \n\n\n\n```js\ntailwind.config.js\n\nmodule.exports = {\n  content: [\n    \"../../packages/ui/**/*.{js,ts,jsx,tsx}\",\n    \"./**/*.{js,ts,jsx,tsx}\",\n    \"./pages/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n};\n```\n\npostcss.config.js\n\n```js\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n```\n\n\n\n## B. 앱 내에서 Tailwind CSS 구성 구현\n\n- 루트 디렉토리에서 다음 명령을 실행하세요\n\n```js\nyarn workspace docs add -D tailwindcss autoprefixer\n```\n\n2. tailwind.config.js 및 postcss.config.js 파일을 생성하세요\n\n\n\n좋아요! 여기서 테이블 태그를 마크다운 형식으로 변경했습니다:\n\n```md\n| 파일명            | 설정 내용                                       |\n|----------------------|-----------------------------------------------------|\n| tailwind.config.js    | `module.exports = require(\"@mrizkiaiman/configs/tailwind/tailwind.config\");` |\n| postcss.config.js       | `module.exports = require(\"@mrizkiaiman/configs/tailwind/postcss.config\");` |\n```\n\n\n\n3. 패키지/ui 폴더로 이동하여 다음 파일을 생성하세요: tailwind.config.js, postcss.config.js, 그리고 styles.css\n\ntailwind.config.js\n\n```js\nmodule.exports = require(\"@mrizkiaiman/configs/tailwind/tailwind.config\");\n```\n\npostcss.config.js\n\n\n\n```js\r\nmodule.exports = require(\"@mrizkiaiman/configs/tailwind/postcss.config\");\r\n```\n\nstyles.css\n\n```js\r\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\r\n```\n\n4. apps/docs 폴더로 돌아가서 pages 디렉토리로 이동하세요. 모노레포의 Tailwind CSS 초기화를 위해 이전에 생성한 전역 스타일을 가져오는 _app.tsx 파일을 만드세요.\n\n\n\n_app.tsx\n\n```js\nimport \"ui/styles.css\";\n\nimport type { AppProps } from \"next/app\";\n\nexport default function MyApp({ Component, pageProps }: AppProps) {\n  return <Component {...pageProps} />;\n}\n```\n\n설정이 완료되었습니다. 이제 테스트해 봅시다!\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_6.png)\n\n\n\n테스트 중:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*z9BAP-pz5fi8N9eR8Gpc4Q.gif)\n\n`monorepo` 내의 기타 앱, 예를 들어 `apps/web`와 같은 앱에 대해 동일한 단계를 따를 수 있습니다.\n\n요약하면, Turborepo로 단일 저장소(monorepo)를 구축하면 업무 흐름을 혁신적으로 개선할 수 있습니다. 구성된 구조와 간소화된 프로세스를 통해 이 조합은 대규모 프로젝트와 다중 응용 프로그램을 쉽게 관리하고 시간을 절약하며 신뢰성을 향상시킬 수 있습니다. 직접 시도하고 작업 방식을 변화시킬 수 있는 방법을 확인해 보세요.\n\n\n\n읽어 주셔서 감사합니다. 어떤 피드백이든 정말 감사히 받겠습니다.\n\nGitHub 저장소: https://github.com/mrizkiaiman/turborepo-withtailwind","ogImage":{"url":"/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_0.png"},"coverImage":"/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_0.png","tag":["Tech"],"readingTime":5},{"title":"400줄의 코드로 나만의 Reactjs 만들기","description":"","date":"2024-05-14 10:30","slug":"2024-05-14-BuildYourOwnReactjsin400LinesofCode","content":"\n\n## 리액트 원리 심도있는 공부\n\n![image](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_0.png)\n\n내 뉴스레터에 원본으로 게시되었습니다.\n\n리액트 v19 베타 버전이 출시되었습니다. React 18과 비교해 보면 사용자 친화적인 많은 API를 제공하지만, 핵심 원칙은 크게 변하지 않았습니다. 리액트를 오랫동안 사용해 왔을 수도 있지만, 그것이 어떻게 작동하는지 아시나요?\n\n\n\n이 기사는 비동기 업데이트를 지원하며 중단될 수 있는 React 버전을 약 400줄의 코드로 빌드하는 방법에 대해 도와줄 것입니다. 이는 많은 고수준 API가 의존하는 React의 핵심 기능입니다. 최종 효과 GIF는 다음과 같습니다:\n\n![Final Effect Gif](https://miro.medium.com/v2/resize:fit:1400/0*x5ppDSDgiUaSz82X.gif)\n\nReact 공식 웹사이트에서 제공한 틱택토 튜토리얼 예제를 사용하여 잘 작동하는 것을 확인했습니다.\n\n현재 이 코드는 내 GitHub에 호스팅되어 있으며 직접 시도해 볼 수 있는 온라인 버전도 방문할 수 있습니다.\n\n\n\n# JSX와 createElement\n\nmini-react.ts의 원리에 깊이 파볼 때, JSX가 무엇을 나타내는지를 이해하는 것이 중요합니다. 우리는 JSX를 사용하여 DOM을 설명하고 JavaScript 논리를 쉽게 적용할 수 있습니다. 그러나 브라우저는 JSX를 기본적으로 이해하지 못하기 때문에 우리가 작성한 JSX는 브라우저가 이해할 수 있는 JavaScript로 컴파일됩니다.\n\n![이미지](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_1.png)\n\nReact.createElement을 호출하는 것을 볼 수 있습니다. 여기에는 다음 옵션이 제공됩니다:\n\n\n\n- 유형: 현재 노드의 유형을 나타냅니다. div와 같은 것입니다.\n- 구성: 현재 엘리먼트 노드의 속성을 나타냅니다. 예를 들어 'id: \"test\"'입니다.\n- 자식: 여러 엘리먼트, 간단한 텍스트 또는 React.createElement로 생성된 노드일 수 있는 자식 엘리먼트들입니다.\n\n경험이 풍부한 React 사용자라면, React 18 이전에 JSX를 올바르게 작성하기 위해 `react`에서 React를 import해야 했다는 것을 기억할 수 있습니다. 그러나 React 18부터는 이러한 작업이 더 이상 필요하지 않아 개발자 경험을 향상시켰지만, 여전히 React.createElement가 내부적으로 호출됩니다.\n\n![image](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_2.png)\n\n우리의 단순화된 React 구현에는 JSX를 직접적으로 React.createElement 구현으로 컴파일하도록 Vite를 `jsxRuntime: 'classic'`으로 구성해야 합니다.\n\n\n\n그럼 우리 자체를 구현할 수 있어요:\n\n<img src=\"/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_3.png\" />\n\n# 렌더\n\n다음으로, 이전에 생성된 데이터 구조를 기반으로 JSX를 실제 DOM에 렌더링하는 간소화된 버전의 렌더 함수를 구현해보겠습니다.\n\n\n![이미지](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_4.png)\n\n온라인 구현 링크가 여기 있습니다. 현재 JSX를 한 번만 렌더링하므로 상태 업데이트를 처리하지 않습니다.\n\n# Fiber 아키텍처와 동시성 모드\n\nFiber 아키텍처와 동시성 모드는 주로 한 번 완전한 요소 트리가 재귀되면 중단될 수 없는 문제를 해결하기 위해 개발되었습니다. 이는 주 스레드를 오랜 기간 블로킹할 수 있습니다. 사용자 입력 또는 애니메이션과 같은 고우선 순위 작업이 적시에 처리되지 않을 수 있습니다.\n\n\n\nReact의 소스 코드에서 작업은 작은 단위로 나누어집니다. 브라우저가 유휴 상태일 때 작은 작업 단위들을 처리하여 주요 작업을 우선적으로 처리할 수 있도록 메인 스레드의 제어를 양보합니다. 한 작업의 모든 작은 단위가 완료되면 결과는 실제 DOM에 매핑됩니다.\n\n주요 포인트는 메인 스레드를 양보하는 방법과 작업을 관리 가능한 단위로 나누는 방법입니다.\n\n# requestIdleCallback\n\nrequestIdleCallback은 브라우저가 유휴 상태일 때 콜백을 실행하는 실험적인 API입니다. 아직 모든 브라우저에서 지원되지 않습니다. React에서는 requestIdleCallback보다 복잡한 스케줄링 로직을 갖춘 스케줄러 패키지에서 사용되며, 이 패키지는 작업 우선순위 업데이트와 같은 기능을 포함하고 있습니다.\n\n\n\n그러나 여기서는 비동기 인터럽트성만을 고려합니다, 그래서 React를 흉내 내는 기본 구현이 있습니다:\n\n![이미지](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_5.png)\n\n일부 주요 포인트에 대한 간단한 설명은 다음과 같습니다:\n\nMessageChannel을 왜 사용해야 하나요?\n\n\n\n기본적으로 이 방법은 각 단위 작업 라운드를 처리하기 위해 매크로 테스크를 사용합니다. 하지만 왜 매크로 테스크를 사용해야 할까요?\n\n이는 브라우저가 DOM을 업데이트하거나 이번 휴식 기간 동안 이벤트를 받을 수 있도록 주 스레드의 제어를 양보해야 하기 때문입니다. 브라우저가 DOM을 업데이트할 때는 별도의 작업으로 처리되며, 그때에는 JavaScript가 실행되지 않습니다.\n\n주 스레드는 한 번에 하나의 작업만 처리할 수 있습니다. 즉, JavaScript를 실행하거나 DOM 계산, 스타일 계산, 입력 이벤트 처리 등을 수행할 수 있습니다. 그러나 마이크로 테스크는 주 스레드의 제어를 양보하지 않습니다.\n\nsetTimeout을 사용하지 않는 이유는 무엇일까요?\n\n\n\n현대 브라우저는 중첩된 setTimeout 호출을 다섯 번 이상으로 간주하며 그 최소 지연 시간을 4밀리초로 설정하므로 충분히 정밀하지 않습니다.\n\n# 알고리즘\n\nReact는 계속 발전하고 있으므로 제가 설명하는 알고리즘들이 최신이 아닐 수 있지만, 이는 React의 기본 원리를 이해하는 데 충분합니다.\n\nReact 패키지가 매우 큰 이유 중 하나입니다.\n\n\n\n다음은 작업 단위 간 연결을 보여주는 다이어그램입니다:\n\n![work-units-connections](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_6.png)\n\nReact에서 각 작업 단위는 Fiber 노드라고 불립니다. 이들은 연결 리스트와 유사한 구조를 사용하여 서로 연결되어 있습니다:\n\n- child: 부모 노드에서 첫 번째 자식 요소로의 포인터.\n- return/parent: 모든 자식 요소는 부모 요소로 돌아가는 포인터를 가지고 있습니다.\n- sibling: 첫 번째 자식 요소에서 다음 형제 요소로의 포인터가 있습니다.\n\n\n\n위의 데이터 구조가 구축되면 구체적인 구현을 살펴보겠습니다.\n\n단순히 렌더 로직을 확장하여 workLoop -` performUnitOfWork -` reconcileChildren -` commitRoot 호출 시퀀스를 재구성합니다.\n\n- workLoop: requestIdleCallback을 계속 호출하여 유휴 시간을 가져옵니다. 현재 유휴 상태이고 실행할 unit 작업이 있는 경우 각 unit 작업을 실행합니다.\n- performUnitOfWork: 특정 unit 작업을 수행합니다. 이는 연결 리스트 아이디어의 구현입니다. 구체적으로 한 번에 하나의 Fiber 노드만 처리하고 처리할 다음 노드를 반환합니다.\n- reconcileChildren: 실제로 가상 DOM을 비교하고 변경 사항을 기록하는 현재 Fiber 노드를 조정합니다. 이제 JavaScript 객체의 수정만 있는 것이므로 실제 DOM에는 영향을 주지 않고 각 Fiber 노드에 직접 수정 및 저장했다는 것을 볼 수 있습니다.\n- commitRoot: 현재 업데이트가 필요하고 (wipRoot에 따라) 다음 unit 작업을 처리해야 할 필요가 없는 경우 (!nextUnitOfWork에 따라), 가상 변경 사항을 실제 DOM에 매핑해야 합니다. commitRoot는 Fiber 노드의 변경에 따라 실제 DOM을 수정하는 것입니다.\n\n이러한 접근으로 Fiber 아키텍처를 실제 DOM 업데이트에 인터럽트 할 수 있지만 아직 트리거가 부족합니다.\n\n\n\n# 업데이트 트리거\n\nReact에서 가장 일반적인 트리거는 useState로, 가장 기본적인 업데이트 메커니즘이에요. 저희 Fiber 엔진을 발화하기 위해 이를 구현해봅시다.\n\n여기 구체적인 구현이 있는 간단한 함수입니다:\n\n![Function implementation](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_7.png)\n\n\n\n훅의 상태를 Fiber 노드에 지능적으로 유지하고 큐를 통해 상태를 수정하는 방식으로 작동합니다. 여기서 React 훅 호출의 순서를 변경해서는 안 되는 이유를 이해할 수 있습니다.\n\n# 결론\n\n비동기 및 중단 가능한 업데이트를 지원하는 React의 최소한의 모델을 구현했습니다. 의존성이 없으며 주석 및 유형을 제외하면 400줄 미만의 코드일 수 있습니다. 도움이 되었으면 좋겠습니다.\n\n만약 이 내용이 도움이 되었다면, 웹 개발에 대한 자세한 통찰을 더 얻고 싶다면 제 뉴스레터 구독을 고려해보세요. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_0.png"},"coverImage":"/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_0.png","tag":["Tech"],"readingTime":5},{"title":"React 와 Context API를 활용하여 탭 컴포넌트를 만드는 방법","description":"","date":"2024-05-14 10:28","slug":"2024-05-14-HowToCreateTabsComponentWithReactContextAPI","content":"\n\n우리가 Medium Stats Chrome 확장 프로그램에서 사용 중인 동일한 탭 구성 요소입니다.\n\n![탭 구성 요소 이미지](/assets/img/2024-05-14-HowToCreateTabsComponentWithReactContextAPI_0.png)\n\n이 아이디어는 구성 요소 라이브러리나 서드파티 모듈 없이 재사용 가능한 컴포넌트를 만드는 것이었습니다.\n\n# 단계 1 — 컨텍스트 생성\n\n\n\n활성 탭의 인덱스는 컨텍스트에 저장되어야 합니다. 해당 인덱스 내에는 변경 함수도 저장됩니다. TabsContext.jsx 파일을 생성하세요.\n\n```js\nimport React, { createContext, useState, useContext } from 'react';\n\nconst TabsContext = createContext({});\n\nexport const TabsProvider = ({ children, defaultIndex = 0 }) => {\n  const [activeTab, setActiveTab] = useState(defaultIndex);\n\n  return (\n    <TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      {children}\n    </TabsContext.Provider>\n  );\n};\n\nexport const useTabs = () => {\n  const context = useContext(TabsContext);\n  if (!context) {\n    throw new Error('useTabs must be used within a TabsProvider');\n  }\n  return context;\n};\n```\n\nTabsProvider와 가장 중요한 부분인 useTabs 훅이 준비되어 있습니다. 이를 사용하면 활성 인덱스에 액세스하고 탭을 변경할 수 있습니다.\n\n# Step 2 — styles\n\n\n\n우리는 Tailwind와 같은 스타일링 라이브러리를 사용하지 않아요. 마음대로 사용하셔도 돼요. 이 데모는 스타일에 구애받지 않아요. CSS 모듈을 사용할 거에요. styles.module.css 파일을 생성해주세요.\n\n```js\n.tabsList {\n    display: flex;\n    border-bottom: 1px solid #f2f2f2;\n}\n\n.tab {\n    padding: 10px 15px;\n    cursor: pointer;\n    border: 1px solid #f2f2f2;\n    background: #f2f2f26b;\n    border-radius: 8px 8px 0 0;\n    position: relative;\n    top: 1px;\n    color: #242424;\n}\n\n.activeTab {\n    background: #fff;\n    border-bottom: 1px solid #fff;\n}\n\n.tabPanel {\n    padding: 10px;\n    min-width: 750px;\n}\n```\n\n# 단계 3 — 탭 컴포넌트\n\n가장 중요한 부분 — 탭, 탭리스트, 탭 및 탭패널 컴포넌트를 만들 거에요. 모두 하나의 파일에 들어갈 거에요. 그들은 작아서 개발하기 편할 거에요 (개발자 경험). Tabs.jsx 파일을 생성해주세요.\n\n\n\n```js\nimport { TabsProvider, useTabs } from './TabsContext.jsx';\nimport styles from './tabs.module.css';\n\nexport const Tabs = ({ children, defaultIndex }) => {\n  return <TabsProvider defaultIndex={defaultIndex}>{children}</TabsProvider>;\n};\n\nexport const TabList = ({ children }) => {\n  return <div className={styles.tabsList}>{children}</div>;\n};\n\nexport const Tab = ({ index, children }) => {\n  const { activeTab, setActiveTab } = useTabs();\n  return (\n    <button className={`${styles.tab} ${activeTab === index ? styles.activeTab : ''}`} onClick={() => setActiveTab(index)}>\n      {children}\n    </button>\n  );\n};\n\nexport const TabPanel = ({ index, children }) => {\n  const { activeTab } = useTabs();\n  return activeTab === index ? <div className={styles.tabPanel}>{children}</div> : null;\n};\n```\n\nTabs — 탭 컨텍스트를 제공하는 빈 컨테이너입니다. 모든 하위 컴포넌트가 컨텍스트에 액세스할 수 있습니다.\n\nTabList — 클릭할 탭 목록을 보여주는 컨테이너입니다. 스타일링을 위해서만 필요합니다.\n\nTab — 탭 자체입니다. 클릭할 수 있는 버튼뿐입니다. 활성 여부를 확인하고 클릭 이벤트를 처리하여 활성 탭을 변경합니다.\n\n\n\n\nTabPanel — 탭의 내용.\n\n# 단계 4 — 마지막 단계. 탭 컴포넌트 사용법\n\n이제 필요한 곳이면 어디에서나 이 컴포넌트를 사용할 수 있습니다. 여기에 샘플이 있습니다.\n\n```js\n<Tabs>\n    <TabList>\n      <Tab index={0}>통계</Tab>\n      <Tab index={1}>도구</Tab>\n    </TabList>\n    <TabPanel index={0}>내용 1</TabPanel>\n    <TabPanel index={1}>내용 2</TabPanel>\n</Tabs>\n```\n\n\n\n결과:\n\n<img src=\"/assets/img/2024-05-14-HowToCreateTabsComponentWithReactContextAPI_1.png\" />\n\n코딩 재밌게 하세요!\n\n## ✉️ 뉴스레터 구독은 여기에서 할 수 있어요.\n\n\n\n또는\n\n이전 이야기를 읽어보세요:\n\n- 내가 처음으로 미디움에서 첫 100달러를 벌게 된 과정은? 💰💰💰","ogImage":{"url":"/assets/img/2024-05-14-HowToCreateTabsComponentWithReactContextAPI_0.png"},"coverImage":"/assets/img/2024-05-14-HowToCreateTabsComponentWithReactContextAPI_0.png","tag":["Tech"],"readingTime":4},{"title":"다음 시리즈 101 Inversify를 활용한 IoC 구현","description":"","date":"2024-05-14 10:26","slug":"2024-05-14-Next101IoCImplementationwithInversify","content":"\n\nTypescript IoC를 Next 14에 Inversify와 함께 올바르게 구현하는 방법을 배우세요.\n\n![image](/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png)\n\nIoC(Inversion of Control)는 객체의 동작 제어가 뒤바뀌거나 객체 외부로 이동되는 디자인 패턴입니다. 이는 소프트웨어 응용 프로그램 내 객체의 흐름을 관리하는 데 도움이 됩니다.\n\n제어가 역전되고 컨테이너가 의존성을 관리하는 책임을 맡아 모듈성, 유연성 및 테스트 용이성을 높이게 됩니다.\n\n\n\n아래는 [공식 줄임말(Markdown)](https://www.markdownguide.org/cheat-sheet/) 형식으로 업데이트한 내용입니다.\n\n\n![이미지](/assets/img/2024-05-14-Next101IoCImplementationwithInversify_1.png)\n\n의존성 주입에 익숙하다면, IoC 디자인을 구현하는 기술 중 하나입니다.\n\n이 패턴은 단순히 \"너가 객체를 만들지 마세요. 제가 그것을 제공할게요.\"라고 말합니다.\n\n![이미지](/assets/img/2024-05-14-Next101IoCImplementationwithInversify_2.png)\n\n\n\n\n## 그렇지만 왜?\n\n디자인 패턴? 또 다시요? 진짜로, 이걸로 충분히 지쳤어요 🤣. 처음에 IoC나 의존성 주입이 Next 프레임워크와 진짜 유용하다고 생각하지 않았어요. 보통 사람들도 사용하지 않잖아요, ㅎㅎ.\n\n하지만, 제게 호기심을 자극하는 흥미로운 점이 있어요. 만약 Next에서 Repository 패턴을 사용한다면 어떨까요? Next는 자바스크립트나 타입스크립트로 작성됐다는 걸 알고 있어요. 이는 OOP보다 함수형 접근 방식을 기본으로 사용한다는 데 특별히 신경쓰지 않아도 되겠죠.\n\n저는 보통 백엔드에 더 많이 관심이 있는데, 주로 Rust나 PHP와 같은 OOP 언어로 대화를 나눠요. 제가 매일 사용하는 프레임워크는 Laravel이에요. 물론, 개발한 모든 프로젝트에 Repository 및 Service 패턴을 항상 구현해요.\n\n\n\n저장소(repository)는 데이터가 저장되는 곳입니다. 서비스(service)는 데이터를 조작합니다. 간단하죠? 이러한 패턴을 사용하면 API를 통해 데이터를 관리해야 하는 경우나 프로젝트에서 데이터베이스에 직접적으로 접근해야 하는 경우에 견고하고 유지보수하기 쉬운 코드베이스를 개발하는 데 도움이 될 것입니다.\n\n아래의 기사에서 더 많은 정보를 찾아볼 수 있습니다. 관심이 생긴다면 읽어보세요.\n\n## Inversify\n\nNext 프레임워크에서 IoC를 구현하기 위해 InversifyJS를 사용할 예정입니다.\n\n\n\n이것은 TypeScript로 구동되는 JavaScript 및 Node.js 앱을 위한 강력하고 가벼운 제어 반전 컨테이너입니다. 사용하기 쉬운 친절한 API 세트를 갖추고 있어서 최상의 OOP 및 IoC 모범 사례 사용을 촉진할 수 있습니다.\n\n다른 IoC 및 DI 라이브러리 중에서, 제품 환경에서 사용할 수 있는 안정성을 고려하여 이것을 사용하는 것을 선호합니다. 그리고 가벼운 크기인 4 KB만큼만 차지한다는 점도 좋은데요.\n\nInversify는 다음과 같은 모던 JavaScript 엔진을 필요로 합니다:\n\n- Reflect metadata\n- Map\n- Promise (공급자 주입 사용 시에만 필요)\n- Proxy (활성화 핸들러 사용 시에만 필요)\n\n\n\n## 시작해봅시다\n\n일반적으로 Typescript와 App 기반 Router를 사용하여 새 Next 프로젝트를 만든 후에는 프로젝트 디렉토리 구조가 아래와 같이 나타날 것입니다.\n\n```js\nproject\n|\n+-- app                  -> 애플리케이션 디렉토리\n|\n+-- components           -> UI 컴포넌트 디렉토리\n|\n+-- public               -> 공용 에셋 디렉토리\n|\n+-- package.json\n|\n+-- tsconfig.json\n|\n+-- next-env.d.ts\n|\n+-- next.config.mjs\n```\n\n다음 명령어를 사용하여 필요한 종속성을 설치해주세요.\n\n\n\n```js\nnpm install inversify reflect-metadata --save\n```\n\nInversify는 TypeScript에서 IoC를 구현하는 데 필요하며, reflect-metadata는 Typescript 파일에서 데코레이터 및 데코레이터 메타데이터를 사용하는 데 필요합니다.\n\n이러한 유형의 정의는 inversify npm 패키지에 포함되어 있습니다. tsconfig.json 파일에 experimentalDecorators, emitDecoratorMetadata, types 및 lib와 같은 몇 가지 컴파일 옵션이 필요합니다. \n\n```js\n{\n    \"compilerOptions\": {\n        \"target\": \"es5\",\n        \"lib\": [\"es6\", \"dom\"],\n        \"types\": [\"reflect-metadata\"],\n        \"module\": \"commonjs\",\n        \"moduleResolution\": \"node\",\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true\n    }\n}\n```\n\n\n\n시작하려면 Inversify의 컨테이너 및 reflect-metadata에 필요한 파일을 만들어보세요.\n\n```js\n// @/lib/di/container.ts\n\nimport \"reflect-metadata\";\nimport { Container } from \"inversify\";\n\nconst container = new Container();\n\nexport default container;\n```\n\n```js\n// @/lib/di/reflect-metadata.ts\n\n\"use client\";                           // -> 클라이언트-컴포넌트로 표시\n\nimport \"reflect-metadata\";\n```\n\n다음으로 각 페이지 또는 구성 요소에 대해 기본적으로 SSR(서버 사이드 렌더링)를 사용하지만 reflect-metadata 라이브러리가 클라이언트 측에서 가져와지지 않으면 이상한 오류가 발생할 수 있어요. 그래서 reflect-metadata.ts를 루트 레이아웃 파일에 가져와야 해요.\n\n\n\n```js\n// @/app/layout.tsx\n\nimport \"@/lib/di/reflect-metadata\";    // -> reflect-metadata를 import합니다\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  ...\n}\n```\n\n이제 프로젝트 디렉토리 구조는 다음과 같을 것입니다.\n\n```js\nproject\n|\n+-- app                            -> 애플리케이션 디렉토리\n|\n+-- components                     -> UI 컴포넌트 디렉토리\n|\n+-- public                         -> 퍼블릭 에셋 디렉토리\n|\n+-- lib                            -> 라이브러리 디렉토리\n|  |\n|  +-- di                          -> 의존성 주입 디렉토리\n|     |\n|     +-- container.ts             -> 컨테이너\n|     |\n|     +-- reflect-metadata.ts      -> reflect-metadata 클라이언트 컴포넌트\n|\n+-- package.json\n|\n+-- tsconfig.json\n|\n+-- next-env.d.ts\n|\n+-- next.config.mjs\n```\n\n그리고 이제 Inversify가 제대로 작동하고 사용할 준비가 되었습니다.\n\n\n\n\n## 모델\n\n이라고 불리는 모델은 당신이 코드에서 사용하는 데이터에 대한 엄격한 타입 정의입니다. \"모델\" 이라는 이름을 사용하는 이유는 이에 더 익숙하기 때문입니다. 이것을 \"타입\" 이라고 부르고 프로젝트 루트에 types 라는 디렉토리를 생성할 수도 있습니다.\n\n예를 들어, 내 애플리케이션에서 제품으로 사용될 데이터에 대한 Product 모델을 생성할 것입니다.\n\n```js\n// @/models/product.ts\n\ntype Product = {\n  id: string;\n  image_url: string;\n  image_blur_data_url: string | undefined;\n  name: string;\n  price: number;\n  unit: string;\n  short_description: string;\n  description: string;\n  statement_description: string;\n  marketing_feature: string;\n};\n\nexport default Product;\n```\n\n\n\n## 저장소\n\n저장소 클래스는 데이터 저장소(창고)로 사용되어 다른 코드가 이 클래스를 통해 필요한 데이터에 액세스할 수 있도록 합니다. 저장소는 앱에서 단일 진실의 원천입니다.\n\n예를 들어, ProductRepository라는 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 Product 모델의 엄격한 유형을 사용합니다.\n\n```js\n// @/repositories/product-repository.ts\n\nimport \"reflect-metadata\";\nimport { injectable } from \"inversify\";\nimport type Product from \"@/models/product\";\n\n// 더미 제품 데이터 목록\nconst products = [ ... ];\n\n@injectable()\nexport default class ProductRepository {\n  async getProducts(): Promise<Array<Product>> {\n    return products.map((product: any) => product as Product);\n  }\n\n  async getProduct(id: string): Promise<Product | undefined> {\n    const product = products.find((product: any) => product.id === id);\n\n    if (product) {\n      return product as Product;\n    }\n\n    return undefined;\n  }\n}\n```\n\n\n\n위 코드는 더미 데이터 목록에서 데이터를 얻는 시뮬레이션입니다.\n\n`@injectable` 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 삽입할 수 있다는 것을 인지합니다.\n\n비동기로 코드를 실행해야 하는 경우 `async`가 일반적으로 필요합니다. 왜냐하면 완료되기까지 시간이 걸리기 때문입니다. 데이터베이스나 외부 API와 상호 작용해야 하는 경우에 이를 사용할 수 있습니다.\n\n## 서비스\n\n\n\n레포지토리 클래스를 통해 데이터를 조작하는 서비스 클래스입니다. 필요한 경우 서비스 클래스에서 여러 레포지토리를 사용할 수 있습니다.\n\n이 곳에서 Inversify를 사용한 의존성 주입이 도움이 됩니다. @inject 데코레이터를 통해 서비스 클래스에 필요한 레포지토리를 자동으로 주입할 수 있습니다.\n\n예를 들어, ProductService 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 ProductRepository와 Product 모델의 엄격한 유형을 사용합니다.\n\n```js\n// @/services/product-service.ts\n\nimport \"reflect-metadata\";\nimport { inject, injectable } from \"inversify\";\nimport ProductRepository from \"@/repositories/product-repository\";\nimport type Product from \"@/models/product\";\n\n@injectable()\nexport default class ProductService {\n  @inject(ProductRepository)\n  private productRepository: ProductRepository;\n\n  async getProducts(query: string): Promise<Array<Product>> {\n    let products = await this.productRepository.getProducts();\n\n    if (query !== \"\") {\n      return products.filter((product: Product) =>\n        product.name.toLowerCase().includes(query.toLowerCase()),\n      );\n    }\n\n    return products;\n  }\n\n  async getProduct(id: string): Promise<Product | undefined> {\n    const product = await this.productRepository.getProduct(id);\n\n    if (product) {\n      return product as Product;\n    }\n\n    return undefined;\n  }\n}\n```\n\n\n\n당신의 요구에 따라, 이 서비스 클래스를 사용하여 데이터를 관리하는 데 도움이 되는 추가적인 메서드를 추가할 수 있습니다.\n\n@Injectable 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 주입할 수 있다는 것을 알 수 있습니다.\n\n@Inject 데코레이터를 사용해야만 Inversify에 해당 클래스의 필수 인스턴스를 주입하도록 알릴 수 있으므로 이 인스턴스를 사용하여 리포지토리의 메서드에 액세스할 수 있습니다.\n\n## 컨테이너\n\n\n\n이제 올바르게 작동하는 IoC를 위해 수행해야 할 마지막 단계입니다.\n\n모델(타입), 리포지토리, 서비스 클래스를 생성한 후, 이러한 클래스를 IoC 컨테이너에 등록해야 합니다. 클래스가 컨테이너에 등록되면 앱의 런타임 중에 필요한 인스턴스에 주입될 수 있습니다.\n\n컨테이너는 항상 앱의 런타임에 이용 가능할 것입니다.\n\n```js\n// @/lib/di/container.ts\n\nimport \"reflect-metadata\";\nimport { Container } from \"inversify\";\nimport ProductRepository from \"@/repositories/product-repository\";\nimport ProductService from \"@/services/product-service\";\nimport UserService from \"@/services/user-service\";\n\nconst container = new Container();\n\ncontainer.bind(ProductRepository).to(ProductRepository).inSingletonScope();\n\ncontainer.bind(ProductService).to(ProductService).inSingletonScope();\n\nexport default container;\n```\n\n\n\n클래스 인스턴스에 대한 scope를 지정할 수도 있어요.\n\n- inTransientScope: 매 의존성 요청마다 새로운 인스턴스를 보장하여 가벼우면서도 일회용 의존성을 유지합니다. 이것이 기본 스코프에요.\n- inSingletonScope: 의존성에 대한 중앙 접근점을 생성하여 모든 곳에서 동일한 인스턴스를 사용하며 효율성과 상태 관리를 촉진합니다.\n- inRequestScope: 단일 해결 프로세스 내에서 중복된 객체 생성을 피해 성능 최적화를 제공하지만 HTTP 요청 당 단일 인스턴스를 보장하지는 않아요.\n\n## The Hook\n\n이 단계는 선택 사항으로, 앱의 다른 구성 요소에서 컨테이너에 액세스하는 데 도움을 줍니다.\n\n\n\n```js\n// @/lib/di/hook.ts\n\nimport container from \"@/lib/di/container\";\nimport ProductRepository from \"@/repositories/product-repository\";\nimport ProductService from \"@/services/product-service\";\nimport UserService from \"@/services/user-service\";\n\nexport function getProductRepository(): ProductRepository {\n  return container.get(ProductRepository);\n}\n\nexport function getProductService(): ProductService {\n  return container.get(ProductService);\n}\n```\n\n마침내, 이제 프로젝트 디렉토리 구조는 다음과 같이 보일 것입니다.\n\n```js\nproject\n|\n+-- app                            -> 애플리케이션 디렉토리\n|\n+-- components                     -> UI 컴포넌트 디렉토리\n|\n+-- public                         -> 공용 에셋 디렉토리\n|\n+-- lib                            -> 라이브러리 디렉토리\n|  |\n|  +-- di                          -> 의존성 주입 디렉토리\n|     |\n|     +-- container.ts             -> 컨테이너\n|     |\n|     +-- hook.ts                  -> 컨테이너 후크\n|     |\n|     +-- reflect-metadata.ts      -> reflect-metadata 클라이언트 컴포넌트\n|\n+-- models                         -> 모델 디렉토리\n|  |\n|  +-- product.ts                  -> 제품 모델\n|\n+-- repositories                   -> 리포지토리 디렉토리\n|  |\n|  +-- product-repository.ts       -> 제품 리포지토리\n|\n+-- services                       -> 서비스 디렉토리\n|  |\n|  +-- product-service.ts          -> 제품 서비스\n|\n+-- package.json\n|\n+-- tsconfig.json\n|\n+-- next-env.d.ts\n|\n+-- next.config.mjs\n```\n\n## 앱에서 사용하기\n\n\n\n컨테이너를 사용하여 인스턴스를 가져오는 것은 정말 쉽습니다.\n\n예를 들어, 제품 데이터 목록을 표시해야 하는 페이지가 있습니다.\n\n```js\n// @/app/page.tsx\n\nimport { getProductService } from \"@/lib/di/hook\";\nimport { Suspense } from \"react\";\nimport ProductList from \"@/components/product-list\";\nimport ProductListSkeleton from \"@/components/product-list-skeleton\";\n\ntype Props = {\n  searchParams?: {\n    search?: string;\n    page?: string;\n  };\n};\n\nexport default async function Page({ searchParams }: Props) {\n  // 쿼리 매개변수 가져오기\n  const query = searchParams?.search || \"\";\n  const currentPage = Number(searchParams?.page) || 1;\n\n  // 제품 항목 가져오기\n  const items = await getProductService().getProducts(query);\n\n  return (\n    <Suspense key={query + currentPage} fallback={<ProductListSkeleton />}>\n      <ProductList items={items} />\n    </Suspense>\n  );\n}\n```\n\n정말 쉽죠? 이제 코드가 더 깔끔해 보입니다. 데이터 액세스가 IoC에 의해 중앙 집중화되고 관리되기 때문에 🎉.\n\n\n\n## 결론\n\n<img src=\"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_3.png\" />\n\n의존성 주입과 함께 역제어(IoC)를 사용하면 코드베이스를 더 깨끗하고 견고하며 유지보수하기 좋게 만들 수 있습니다.\n\n코드베이스 전체에 중복되는 나쁜 냄새나는 코드를 제거할 수도 있어요. 끔찍해! 🤮\n\n\n\n만약 Next 앱에서 Server Action을 더 선호한다면 IoC도 함께 사용할 수 있어요. 간단해요, 한 번 배우면 어디서든 사용할 수 있어요.\n\nNext와 함께 Repository Pattern을 구현하는 기술과 지식을 향상시키기 위해 이 두 글을 읽어보길 권장해요.\n\n## 🚀 샘플 프로젝트\n\nInversify를 IoC로 사용하여 개발한 데모 프로젝트를 실행해볼 수 있어요. 이 프로젝트는 MIT 라이센스로 라이선스가 부여되어 있어요.","ogImage":{"url":"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png"},"coverImage":"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png","tag":["Tech"],"readingTime":11},{"title":"클라이언트 측 React 문제 해결을 위한 Date API 수정하기","description":"","date":"2024-05-14 10:25","slug":"2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues","content":"\n\n<img src=\"/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_0.png\" />\n\n리액트.js 19 버전이 곧 출시되면서 Next.js를 사용하여 새로운 기능을 활용할 수 있게 되었습니다. 하지만, 특히 자바스크립트의 Date API와 관련된 문제가 발생하는데, 서버에서 생성된 콘텐츠와 클라이언트 측의 동작을 조율하는 것이 주요 도전 과제입니다. 이 기사는 Date API로 인해 발생하는 구체적인 문제와 리액트 코드가 클라이언트 측에서 실행될 때 발생하는 이러한 문제가 웹 애플리케이션에서 예상되는 원활한 사용자 경험을 방해하는 수행 오류로 어떻게 이어질 수 있는지에 대해 다룹니다.\n\n# 클라이언트 측 리액트에서의 Date 문제\n\n클라이언트 측 렌더링에서 리액트의 수분화 메커니즘은 이벤트 리스너 및 기타 상호작용 기능을 서버에서 원래 생성된 정적 HTML에 첨부하도록 설계되어 있습니다. 이 프로세스에서 서버 출력과 클라이언트의 초기 렌더 간의 정확한 대응이 필요합니다. 그러나 JavaScript의 Date 객체 사용은 그 자체의 실행 특성 때문에 이 시스템에서 기본적인 문제를 도입하게 됩니다.\n\n\n\n```js\n\"use client\";\n\nexport default function DateError() {\n  const date = new Date();\n  return <div>{date.toLocaleString()}</div>;\n}\n```\n\n`new Date()`함수는 호출 시점을 기반으로 한 타임스탬프를 생성합니다. 이 코드가 SSR 중인 서버와 이후 클라이언트에서 실행될 때 거의 항상 두 개의 다른 타임스탬프가 생성됩니다. 이러한 불일치는 React에서 \"수분 불일치\"로 알려져 있습니다. 클라이언트는 서버의 HTML을 기반으로 기대한 내용과 로컬 생성한 내용 사이의 차이를 감지하고, 오류를 발생시키며 때로는 사용자 경험을 망가뜨리기도 합니다.\n\n<img src=\"/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_1.png\" />\n\n# React 코어 팀의 제안하는 해결책\n\n\n\n\nDate 불일치로 인한 지속적인 문제에 대응하여, React 코어 팀이 혁신적인 해결책을 제안했습니다: 서버 측 렌더링(SSR) 및 수분화 중에 Date API를 수정하는 것입니다. 이 방식은 Date 함수의 출력을 서버와 클라이언트 환경에서 표준화하여 두 환경이 동일한 타임스탬프를 렌더링하도록 보장함으로써 수분화 불일치를 제거하는 데 목적을 두고 있습니다.\n\n![이미지](/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_2.png)\n\n제안된 패치는 SSR 및 수분화 중에 Date API의 동작을 변경하여 실행 시간에 따라 새로운 타임스탬프를 생성하는 대신 초기 서버 렌더링 중에 사용된 타임스탬프를 일관되게 반환하도록합니다. 이것은 서버에서 생성된 날짜 및 시간이 클라이언트에서의 수분화 과정 중에 \"고정\"되어, 클라이언트 측 React 애플리케이션이 실제로 코드를 실행하는 시점에 관계없이 서버에서 렌더링된 시간 값을 보게 하는 것을 의미합니다.\n\n![이미지](/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_3.png)\n\n\n\n# 패치 구현이 이루어질 때까지의 임시 해결책\n\n실용적인 접근 방식 중 하나는 서버에서 날짜 생성을 관리한 다음 이 값을 props로 클라이언트에 전달하는 것입니다. 이 전략을 통해 서버와 클라이언트가 동일한 타임스탬프로 작업하므로 하이드레이션 중 불일치를 피할 수 있습니다.\n\n```js\n//부모\nimport DateError from \"./components/DateError\";\n\nexport default function Home() {\n  const date = new Date();\n\n  return (\n    <main>\n      <DateError date={date} />\n    </main>\n  );\n}\n```\n\n```js\n//자식\n\"use client\";\n\ninterface DateErrorProps {\n  date: Date;\n}\nexport default function DateError({ date }: DateErrorProps) {\n  return <div>{date.toLocaleString()}</div>;\n}\n```\n\n\n\n이 방법은 서버에서 한 번 생성된 날짜를 클라이언트에서 재사용하여, 재렌더링 및 수분을 통해 일관성을 유지함으로써 문제를 효과적으로 우회합니다.\n\n# 결론\n\n해당 패치는 React 개발의 한 측면인 날짜 불일치로 인한 수분 불일치를 해결하기 위해 약속하고 있습니다. 그러나 중요한 변경 사항과 마찬가지로, 네이티브 JavaScript API를 수정하는 최선의 방법에 대한 커뮤니티 내에서 대화를 일으키고 있습니다.\n\n개발자들은 이 토론에 참여하고 이 패치의 진행 상황을 주시하도록 권장받습니다. Twitter에서 Andrew Clark와 같은 거장들의 이야기를 따르면 React 생태계 내에서 이 주제 및 다른 개발에 대한 가치 있는 통찰과 업데이트를 얻을 수 있습니다.\n\n이 글은 Theo의 영감을 받아 작성되었습니다. 더 많은 업데이트 및 React 최신 개발에 대한 심도 있는 토론을 위해 그의 채널을 구독하는 것을 강력히 권장합니다.\n\n\n\n마크다운 형식으로 테이블 태그를 변경하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_0.png"},"coverImage":"/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_0.png","tag":["Tech"],"readingTime":3},{"title":"React Native가 어떻게 작동하는지 이해하기 아키텍처에 대해","description":"","date":"2024-05-14 10:24","slug":"2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture","content":"\n\n<img src=\"/assets/img/2024-05-14-ReactNativeArchitecture.png\" />\n\n# React Native이란 무엇인가요?\n\nReact Native은 React와 JavaScript를 사용하여 네이티브로 렌더링된 iOS 및 Android 앱을 작성할 수 있게 해주는 훌륭한 기술입니다.\n\n이 방식에는 두 가지 주요 장점이 있습니다. 첫째로, 이는 웹 개발자들이 가장 인기 있는 JavaScript UI 라이브러리를 사용하여 네이티브한 느낌의 모바일 애플리케이션을 쉽게 작성할 수 있게 합니다.\n\n\n\n둘째, React Native로 작성된 대부분의 코드는 iOS 및 Android 모두 개발을 간편하게 해주는 동시 개발을 간소화합니다.\n\n# 그래서, 어떻게 작동하는 거죠?\n\nReact Native의 아이디어는 두 가지 별개의 부분인 JavaScript 코드와 Native 코드(안드로이드의 경우 Java/Kotlin, iOS의 경우 Objective-C/Swift)를 결합하여 함께 작동시키는 것입니다. 네이티브 코드는 기기에서 직접 실행되지만, JavaScript는 가상 머신이 필요합니다.\n\niOS 기기에는 C++로 작성된 내장 JavaScript 엔진인 JavaScriptCore가 내장되어 있어 JavaScript 코드를 컴파일하고 실행할 것입니다. 안드로이드 기기에는 내장된 JS 엔진이 없으므로 JavaScriptCore는 React Native 프레임워크와 함께 제공될 것입니다.\n\n\n\n자바/Obj-C와 자바스크립트는 서로 다른 프로그래밍 언어이기 때문에 직접적으로 대화할 수 없습니다. 그러나 둘 모두 이해하는 형식의 데이터를 사용하여 간접적으로 대화할 수 있습니다. 그 형식이 JSON입니다. 이 통신은 Bridge라는 프로그램 세트에 의해 처리됩니다.\n\n![](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_1.png)\n\nReact Native의 빌드 및 런타임\n\n빌드 시간에, 자바 또는 Objective-C로 작성된 네이티브 코드는 Java 및 C++ 이진 파일로 컴파일되며, 자바스크립트 코드는 Metro 번들러를 사용하여 번들로 묶입니다. Metro는 웹 개발에서 사용되는 웹팩 번들러와 유사하게 작동하지만 React Native에 최적화되어 있습니다.\n\n\n\n바이너리와 JS 번들은 최종적으로 대상 플랫폼용 실행 파일 내에 패킹될 것입니다.\n\n런타임 시점에서, JavaScript 코드는 JavaScript 가상 머신에서 실행되고 네이티브 코드는 장치에서 직접 실행될 것입니다. 브릿지는 이 두 영역 사이에서 직렬화된 메시지를 전송할 것입니다. 이러한 메시지는 그 후 역직렬화되어 처리될 것입니다.\n\n# React Native 스레드\n\n사용자가 애플리케이션을 실행하면, 장치는 세 개의 주요 스레드와 필요에 따라 추가 백그라운드 스레드를 시작할 것입니다.\n\n\n\n![React Native 아키텍처 이해: React Native가 어떻게 작동하는가](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_2.png)\n\n- Main Thread — 이것은 애플리케이션이 실행될 기본 네이티브 스레드입니다. 디바이스 화면에 사용자 상호작용 및 UI 렌더링을 담당합니다. 모든 완전 네이티브 빌드 애플리케이션에서 실행 중인 동일한 스레드입니다.\n\n- JavaScript Thread — 여기서 애플리케이션의 비즈니스 로직(즉, JavaScript 및 React 코드)이 실행됩니다.\n\n- Shadow Thread — 이 스레드는 JavaScript 스레드와 함께 시작됩니다. 그 역할은 뷰의 위치를 계산하고 JS 스레드에 작성된 레이아웃 트리를 구성하는 것입니다. React Native는 네이티브 호스트가 이해할 수 있는 레이아웃 시스템으로 플렉스박스 기반의 레이아웃을 변환하는 Yoga 레이아웃 엔진을 활용합니다.\n\n\n\n네이티브 모듈 스레드 - 어플리케이션이 플랫폼 API에 액세스해야 할 때, 예를 들어, 기기의 저장소와 같은 경우, 이 스레드에서 처리됩니다.\n\n# React Native의 브릿지\n\n브릿지는 의심의 여지 없이 React Native 아키텍처의 가장 중요한 부분입니다. 이를 통해 JavaScript 및 네이티브 레이어 사이에서 JSON 메시지를 통해 정보를 교환할 수 있습니다.\n\n이 논리는 웹 응용 프로그램의 경우와 동일합니다. 여기서 프론트엔드 및 백엔드 레이어는 서로에 대해 알 필요가 없으며 (따라서 JavaScript 및 Python과 같은 다른 기술로 작성할 수 있음), 그들은 교환하는 정보를 이해하여 처리해야 합니다.\n\n\n\n한 예시를 통해 알아보겠습니다.\n\n![React Native Architecture](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_3.png)\n\n- 네이티브 이벤트가 발생합니다. 예를 들어 터치나 스크롤 이벤트.\n- 네이티브 측에서 필요한 모든 데이터와 함께 직렬화된 메시지가 브릿지를 통해 전송됩니다.\n- JavaScript가 메시지를 수신하고 역직렬화하여 다음 단계를 결정합니다. 이 경우 아이콘을 변경합니다.\n- JavaScript 레이어에서 요청된 작업에 관한 정보와 함께 메시지가 브릿지를 통해 전송됩니다.\n- 네이티브 측이 메시지를 수신하고 역직렬화하여 뷰를 업데이트합니다.\n\n# 브릿지의 문제\n\n\n\n위에서 언급한대로, 브릿지는 비동기적이기 때문에 특정 경우에 문제가 발생할 수 있습니다.\n\n브릿지를 통해 정보를 비동기적으로 교환하는 것은 매우 빠르지만 때로는 충분하지 않을 수 있으며 동기적인 방식이 더 나을 수 있습니다.\n\n사용자가 신용카드 번호를 입력하는 입력 상자를 가정해 봅시다. 번호를 읽기 쉽게 하기 위해 매 네 자리마다 공백을 삽입하고 싶습니다. 그를 위해 사용자가 문자를 입력할 때마다 간단한 JS 함수를 작성하여 호출하면 됩니다.\n\n![이미지](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_4.png)\n\n\n\n이렇게 작동하는 것을 확인해 봅시다.\n\n![React Native architecture](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_5.png)\n\n네이티브 측에서 사용자가 입력한 문자에 대한 정보가 이미 렌더링된 이후에 올 것을 확인할 수 있습니다. 그런 다음, 저희의 JavaScript 코드가 그 변경 사항을 처리하여 필요한 경우 공백을 삽입하고 새 입력 상태를 설정하면, 이 정보가 다시 네이티브 측으로 전송되어 새 UI가 렌더링됩니다.\n\n이로 인해 사용자가 텍스트를 서식 지정하고 업데이트하기 전에 볼 수 있는 상황이 발생할 수 있습니다(즉, “42578\" 대신에 “4257 8\"을 보여 줘야 할 때). 이 상황은 브릿지가 처리 중인 유일한 사항이라면, 상태의 이러한 점프는 눈에 띄지 않을 수 있습니다. 이 작업이 얼마나 빠르게 수행되는지 때문입니다. 그러나 동시에 많은 업데이트를 처리하는 것은 실생활의 다리와 같은 교통량을 초래할 수 있습니다. 복잡한 애플리케이션에서 문제가 될 수 있음을 상상해 볼 수 있습니다.\n\n\n\n다른 문제는 브릿지의 정보 교환에 사용되는 JavaScript와 네이티브 영역 사이에 직렬화하고 역직렬화해야 한다는 것인데, 이는 시간이 많이 소요되며, 애플리케이션이 커질수록 차이가 발생할 수 있습니다.\n\n이러한 문제를 해결하기 위해 React Native 팀은 JavaScript와 네이티브 코드를 더 잘 조합하는 효율적인 방법을 찾아 새 아키텍처에 JavaScript Interface를 도입했습니다.\n\n# JSI — JavaScript Interface\n\n0.68 버전부터 새 React Native 아키텍처를 사용할 수 있어 브릿지 메커니즘 대신 JavaScript Interface를 채택했습니다.\n\n\n\nJSI(JavaScript Interface)는 모든 JavaScript 엔진에서 활용할 수 있는 통합된 경량 범용 레이어입니다. 이를 사용함으로써 우리는 네이티브 API에 직접적인 연결을 할 수 있게 됩니다.\n\n하지만 어떻게 할까요?\n\nC++은 네이티브 Java/Obj-C 메서드/객체들을 JavaScript에 \"HostObject\"를 통해 노출시킬 것입니다. JavaScript는 이 객체에 대한 참조를 보유하여 Java/Obj-C API에 직접적으로 액세스할 수 있게 됩니다.\n\n이 작업은 동일한 스레드에서 동기적으로 수행될 수도 있고 새로운 스레드를 생성하여 비동기적으로 처리될 수도 있습니다.\n\n\n\n이 기능은 React Native를 새로운 차원으로 끌어 올려 주며, 제공하는 많은 장점 때문에 곧 널리 받아들여질 것입니다.\n\n이 주제를 보다 자세히 살펴보고 싶다면, Parashuram N의 새로운 아키텍처 프레젠테이션을 시청하고 공식 React Native 문서를 참고해보시기를 권장합니다.\n\n# 결론\n\n지금쯤 React Native가 어떻게 작동하는지와 그 아키텍처가 어떻게 구성되어 있는지에 대한 간략한 개요를 얻었을 것입니다. 이 글이 도움이 되었기를 바라며, React Native 세계를 더 깊이 탐험하길 격려합니다.","ogImage":{"url":"/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_0.png"},"coverImage":"/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_0.png","tag":["Tech"],"readingTime":5}],"page":"60","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}