{"pageProps":{"posts":[{"title":"맥 OS M1, M2 칩용으로 REACT NATIVE 설정하기","description":"","date":"2024-05-12 19:47","slug":"2024-05-12-REACTNATIVESETUPFORMACOSM1M2CHIP","content":"\n\n리액트 네이티브 M1/M2 칩을 위한 환경 설정\n\nM1 (애플 실리콘) 칩을 사용하는 맥에서 리액트 네이티브 개발 환경을 설정하는 것은 인텔 기반 맥과 비교해서 몇 가지 추가 고려 사항이 필요합니다. M1 칩이 탑재된 맥에서 리액트 네이티브 개발 환경을 설정하는 단계는 다음과 같습니다:\n\n## 1. 홈브류 설치:-\n\n홈브류는 여러 도구와 라이브러리의 설치를 간단하게 만들어주는 패키지 관리자입니다. 다음 명령어를 사용하여 설치하세요.\n\n\n\n## 2. Node.js 및 rpm 설치\n\n홈 브류를 사용하여 설치하거나 직접 다운로드하여 설치할 수 있습니다.\n\n## 3. Watchman 설치\n\n파일 감시를 개선하기 위해 책임을 집니다. 다음 명령어를 사용하여 설치하세요.\n\n\n\n## 4. Xcode 설치하기\n\n## 5. CocoaPods 설치하기:\n\niOS 개발을 위해 CocoaPods를 설치합니다:\n\n## 6. React Native CLI 추가하기\n\n\n\n다음 명령어를 사용하여 react native cli를 추가하세요!\n\n## 7. 새로운 React Native 프로젝트 만들기:\n\n이제 다음 명령어를 사용하여 react native 프로젝트를 만들 수 있습니다.\n\n## 또한, 가끔 사용자가 다음과 같은 유형의 오류에 갇힐 때가 있습니다. 해당 문제가 발생하면 다음 단계를 사용할 수 있습니다.\n\n\n\n에러:- ℹ 루비 젬 설치 중 ✖ CocoaPods 설치 오류 코코아팟 설치 오류. 프로젝트 초기화에는 영향을 미치지 않으며 안전하게 진행할 수 있습니다. 그러나 iOS를 실행할 때 코코아팟을 수동으로 설치해야 하며 \"iOS용 실행 지침\" 섹션의 추가 단계를 따라야 합니다. ✖ CocoaPods 설치\n\n단계 1. 앱에 다음 명령어 추가하세요\n\n단계 2. react-native.config.js 라는 구성 파일을 만들어서 다음 코드를 붙여넣으세요.\n\n수동으로 코코아팟을 설치하고 구성 파일을 추가한 후에 다음 명령어를 실행하세요\n\n\n\n<img src=\"/assets/img/2024-05-12-REACTNATIVESETUPFORMACOSM1M2CHIP_0.png\" />\n\n# 축하드려요💥 성공하셨어요 👏\n\n# 감사합니다!\n\n더 궁금한 점이 있으시면 이메일을 보내주세요!","ogImage":{"url":"/assets/img/2024-05-12-REACTNATIVESETUPFORMACOSM1M2CHIP_0.png"},"coverImage":"/assets/img/2024-05-12-REACTNATIVESETUPFORMACOSM1M2CHIP_0.png","tag":["Tech"],"readingTime":2},{"title":"접근성을 고려해서 리액트 웹사이트 만드는 방법","description":"","date":"2024-05-12 19:46","slug":"2024-05-12-AccessibilityinReactjs","content":"\n주요 개념 및 접근성 사용 방법\n\n## React.js에서의 접근성(a11y)은 능력에 관계없이 모든 사람이 이해하고 상호 작용할 수 있는 사용자 인터페이스를 만드는 것입니다.\n\n이는 스크린 리더, 키보드 탐색 또는 음성 제어와 같은 보조 기술을 사용하는 사람들을 포함합니다.\n\n다음은 React에서의 접근성에 대한 주요 개념을 설명합니다:\n\n## 1. 시멘틱 HTML\n\n- 'h1' 태그는 제목에, 'button' 태그는 버튼에, 'nav' 태그는 내비게이션에 등 세맨틱 HTML 요소를 사용하여 컴포넌트를 구축하세요. 이러한 요소들은 보조 기술 및 브라우저에 의미를 전달합니다.\n\n```js\n<header> {/* 시맨틱 헤더 요소 */}\n    <h1>Main Title of the Page</h1> {/* 시맨틱 헤딩 요소 */}\n</header>\n\n<main>\n    <p>The main content of your webpage goes here</p> {/* 시멘틱 단락 요소 */}\n</main>\n\n<footer> {/* 시멘틱 푸터 요소 */}\n   <p>Copyright information and other footer related stuff</p>\n</footer>\n```\n\n## 2. ARIA 속성\n\n- 때로는 의미 있는 HTML 만으로 충분하지 않을 수도 있습니다. 보조 기술을 위한 추가 정보를 제공하려면 ARIA (접근 가능한 리치 인터넷 애플리케이션) 속성을 사용하세요. 이미지를 설명하는 데 aria-label을 사용하거나 입력 필드에 설명을 연결하는 데 aria-describedby를 사용할 수 있습니다.\n- HTML로는 원하는 기능을 달성할 수 없는 경우에는 접근성 리치 인터넷 애플리케이션(WAI-ARIA) 역할 및 속성을 사용하세요.\n\n```js\nfunction ImageWithDescription() {\n  return (\n    <div>\n    <button aria-label=\"닫기\" onClick={this.close}>\n    X\n    </button>\n    <img\n      src=\"이미지.jpg\"\n      alt=\"설명적 이미지 대체 텍스트\"  {/* 설명적 대체 텍스트 */}\n      aria-describedby=\"imageDescription\"  {/* 설명과 연결 */}\n    />\n    </div>\n  );\n}\n```\n\n## 3. 키보드 탐색\n\n- 애플리케이션이 키보드를 사용하여 완전히 탐색 가능하도록 보장하세요. 이는 사용자가 버튼, 링크 및 폼 필드와 같은 초점 가능 요소를 탭할 수 있게 하는 것을 의미합니다. onFocus 및 onBlur와 같은 이벤트 핸들러를 사용하여 초점 상태를 관리하고 시각적 단서를 제공하세요.\n\n```js\n함수 FocusableButton({ onClick }) {\n  return (\n    <button type=\"button\" onFocus={() => console.log(\"Button Focused\")} onClick={onClick}>\n      Click me\n    </button>\n  );\n}\n```\n\n## 4. 스크린 리더 지원\n\n- 컴포넌트에 대한 명확하고 간결한 텍스트 설명에 중점을 두세요. 설명적인 링크 텍스트를 사용하고 정보 전달에 색상에만 의존하지 마세요. 스크린 리더는 내용을 텍스트로 제시하기 때문에 구조화되고 이해하기 쉬운 내용임을 보장하세요.\n\n```js\n함수 ErrorMessage({ message }) {\n  return (\n    <div role=\"alert\" aria-live=\"assertive\">  {/* 에러를 발표함 */}\n      {message}\n    </div>\n  );\n}\n```\n\n## 5. 초점 제어\n\n- 키보드만 사용하는 사용자가 컴포넌트에서 요소 포커스를 관리하여 애플리케이션을 탐색할 수 있게 합니다. autoFocus 속성을 사용하면 컴포넌트가 마운트될 때 특정 요소에 포커스를 주는 예입니다.\n\n```js\nclass AutoFocusTextInput extends React.Component {\n  componentDidMount() {\n    this.textInput.focus();\n  }\n\n  render() {\n    return (\n      <input\n        type=\"text\"\n        ref={(input) => {\n          this.textInput = input;\n        }} // ref 할당\n      />\n    );\n  }\n}\n```\n\n## 6. 테스팅 및 유효성 검사:\n\n- 리액트 애플리케이션의 접근성을 테스트하고 유효성을 검사하는 다양한 도구와 기술이 있어요. 브라우저 개발자 도구를 사용하여 접근성 트리를 확인하고 잠재적인 문제를 식별할 수 있어요. 게다가 개발 중에 접근성 검사를 자동화할 수 있는 react-axe와 같은 라이브러리를 고려해 보세요.\n- 대부분의 접근성 문제는 정적 분석 도구를 통해 발견할 수 있지만, 수동 테스트와 유효성 검사도 중요해요. 왜냐하면 접근성은 단순히 규칙 목록을 충족하는 것 이상이기 때문이에요.\n\n## 7. 이미지의 Alt 속성\n\n이미지에 유용하고 설명적인 대체 텍스트를 항상 제공해 주세요.\n\n```js\n<img src={logo} alt=\"로고 설명\" />\n```\n\n## 8. 접근성 있는 양식 만들기\n\n모든 양식 요소에는 명확하고 접근성 있는 라벨이 있어야 합니다.\n\n```js\n<label htmlFor='name'> 이름 </label>\n<input type='text' id='name' name='name' />\n```\n\n## 9. 접근성 있는 색상과 대비\n\n- 모든 사람이 내용을 완전히 읽을 수 있도록 색상과 대비에 주의하세요. WCAG2는 특정 대비 및 텍스트 크기 가이드라인을 제공합니다.\n\n## 10. React 프래그먼트\n\n여러 요소를 그룹화하고 DOM에 추가 노드를 만들지 않으려면 React 프래그먼트(`/` 또는 `React.Fragment`)를 사용하세요. 이는 스크린 리더 사용자를 위해 깔끔한 문서 개요를 유지하는 데 도움이 됩니다.\n\n```js\n<>\n  <ChildA />\n  <ChildB />\n  <ChildC />\n</>\n```\n\n## 11. React 접근성 린터\n\neslint-plugin-jsx-a11y와 같은 도구를 사용하면 따를 수 있는 일련의 접근성 관련 규칙을 강제로 적용할 수 있습니다.\n\n# 몇 가지 출처\n\nReact에서 접근성에 대해 시작할 수 있는 몇 가지 리소스입니다:\n\n- React 웹 접근성 문서: https://legacy.reactjs.org/docs/accessibility.html\n- MDN Web Docs — React에서의 접근성: https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility\n- A11y Project: https://www.a11yproject.com/pen_spark\n","ogImage":{"url":"/assets/img/2024-05-12-AccessibilityinReactjs_0.png"},"coverImage":"/assets/img/2024-05-12-AccessibilityinReactjs_0.png","tag":["Tech"],"readingTime":4},{"title":"MERN 스택으로 전자 상거래 사이트 만들기 - Part II","description":"","date":"2024-05-12 19:45","slug":"2024-05-12-CreatinganE-commerceSitewithMERNStackPartII","content":"\n\n<img src=\"/assets/img/2024-05-12-CreatinganE-commerceSitewithMERNStackPartII_0.png\" />\n\n회고\n\n이전 기사에서 환경을 설정했고 기본 프로젝트를 설정했습니다.\n\n지금은 React 프론트엔드 프로젝트와 Node.js 백엔드 프로젝트가 있습니다. 이 기사에서는 백엔드를 Mongo DB에 연결하고 Mongo DB 기본 사항을 학습하는 것에 초점을 맞추고 있습니다.\n\n\n\n만약 이 기술들이 처음이라면 첫 부분을 읽어보세요. 익숙하다면 즐겁게 즉시 시작하세요. :)\n\n소개\n\nNode.js와 MongoDB를 연결하는 것은 백엔드 데이터베이스가 필요한 애플리케이션을 개발하는 중요한 단계입니다.\n\n이 두 기술을 결합함으로써 우리는 대량의 데이터를 처리하고 빠른 응답 시간을 제공할 수 있는 강력하고 효율적인 애플리케이션을 만들 수 있습니다. 이 글에서는 Mongoose 패키지를 사용하여 Node.js와 MongoDB를 어떻게 연결하는지 살펴볼 것입니다. Mongoose는 MongoDB 위에 높은 수준의 추상화를 제공하며 데이터 모델을 구조화된 방법으로 정의할 수 있게 해줍니다. 또한 Node.js에서 MongoDB를 다루는 데 도움이 되는 몇 가지 모법과 팁을 알려드리겠습니다.\n\n\n\n연결 설정하기\n\n```js\nconst express = require(\"express\");\n\n//mongoose 패키지를 불러옵니다\n\nconst mongoose = require(\"mongoose\");\n\nconst app = express();\n\nconst port = 5000;\n\n//연결 생성하기\n\nmongoose\n\n.connect(\"mongodb://127.0.0.1/ECommerce\")\n\n.then(() => console.log(\"MongoDB에 연결되었습니다...\"))\n\n.catch((err) => console.error(\"MongoDB에 연결할 수 없습니다...\"));\n\napp.get(\"/\", (req, res) => {\n\nres.send(\"안녕, 세계!\");\n\n});\n\napp.listen(port, () => {\n\nconsole.log(`포트 ${port}에서 서버가 실행 중입니다`);\n\n});\n```\n\n위 코드에서는 로컬호스트에서 실행 중인 MongoDB 데이터베이스에 연결합니다. 연결이 설정되면 mongoose 객체를 사용하여 데이터베이스와 상호 작용할 수 있습니다.\n\n추가 설치 및 설정\n\n\n\n크로스 오리진 리소스 공유(CORS)는 웹 애플리케이션에서 다른 도메인으로의 HTTP 요청을 제한하는 보안 메커니즘입니다. 기본적으로 웹 브라우저는 이러한 요청을 차단하여 사용자 데이터에 무단 접근을 방지합니다. Node.js Express 서버와 React 애플리케이션의 경우, 서버가 React 앱 도메인에서의 요청을 허용하지 않으면 CORS 오류가 발생할 수 있습니다. 이 오류를 피하기 위해 Express 서버를 설정하여 React 앱 도메인에서의 요청을 허용하도록 cors 미들웨어를 추가하고 적절한 출처를 허용하도록 구성할 수 있습니다. 이렇게 하면 React 앱이 서버로 요청을 보내고 CORS 오류 없이 데이터를 검색할 수 있습니다.\n\ncors 패키지를 다음 명령어로 설치하고:\n\n```js\nnpm install cors\n```\n\n그리고 몽구스 연결 다음에 다음 코드를 추가하고 파일 상단에 패키지를 import하세요:\n\n\n\n```js\nconst cors = require(\"cors\");\napp.use(cors()); \n```\n\n우리 제품 모델 정의하기\n\nMongoDB에서 데이터는 JSON 객체와 유사한 문서 형식으로 저장됩니다. 모델은 이러한 문서의 구조를 정의하는 방법을 제공하며, 필드와 데이터 유형을 포함합니다. 모델을 정의함으로써 데이터가 일관되고 유효하며 쉽게 관리되도록 할 수 있습니다. 또한 서로 다른 모델 간의 관계를 정의할 수 있으므로 여러 컬렉션 간에 효율적으로 데이터를 쿼리하고 조작할 수 있습니다.\n\n전자 상거래 웹사이트를 구축하는 동안 먼저 제품 모델을 정의합니다. 우리는 스키마 정의, 데이터 유효성 검사, 쿼리 및 Node.js에서 MongoDB 모델을 사용하는 데 가장 좋은 방법을 다룰 것입니다.\n\n\n\n백엔드 폴더 안에 Models 폴더를 생성하고 product.js 파일을 만들어주세요. 그리고 product.js 파일 안에 다음 코드를 추가해주세요:\n\n```js\nconst mongoose = require(\"mongoose\");\n\nconst productSchema = new mongoose.Schema({\n  title: {\n    type: String,\n    required: true,\n  },\n  description: {\n    type: String,\n    required: true,\n  },\n  price: {\n    type: Number,\n    required: true,\n  },\n  discountPercentage: {\n    type: Number,\n    required: true,\n  },\n  rating: {\n    type: Number,\n    required: true,\n  },\n  stock: {\n    type: Number,\n    required: true,\n  },\n  brand: {\n    type: String,\n    required: true,\n  },\n  category: {\n    type: String,\n    required: true,\n  },\n  thumbnail: {\n    type: String,\n    required: true,\n  },\n  images: {\n    type: String,\n    required: true,\n  },\n});\n\nconst Product = mongoose.model(\"Product\", productSchema);\n\nexports.Product = Product;\n```\n\n위 코드에서는 Mongoose 패키지를 사용해 제품에 대한 모델을 정의하고 있어요. 이 모델은 제품이 가질 수 있는 속성을 정의하는데, title, description, price, discount percentage, rating, stock, brand, category, thumbnail, images가 포함돼요. 첫 줄은 스키마를 만들기 위해 필요한 Mongoose 패키지를 가져오는 것이에요. 그리고 mongoose.Schema() 메소드를 사용해 제품을 위한 새로운 스키마를 만들어요. 이 메소드는 키-값 쌍을 가진 객체를 전달받는데, 키는 속성의 이름이고 값은 속성을 설명하는 객체에요.\n\n각 속성은 type과 required 필드를 가지고 있어요. type 필드는 속성의 데이터 타입을 지정하고, required 필드는 제품에 대해 필수인지를 나타내요.\n\n\n\n스키마를 정의한 후에는 mongoose.model() 메서드를 사용하여 모델을 만듭니다. 이 메서드는 두 개의 인수, 즉 모델의 이름과 이전에 만든 스키마를 사용합니다. 이 경우 모델의 이름은 Product이며 스키마는 productSchema에 할당됩니다.\n\n마지막으로, Product 모델을 내보내어 응용 프로그램의 다른 부분에서 사용할 수 있도록 합니다.\n\n기본 CRUD 함수\n\n기본 CRUD 함수는 데이터베이스 시스템의 영속 저장을 위한 네 가지 기본 작업인 Create, Read, Update 및 Delete를 의미합니다. 이러한 함수는 데이터베이스에서 데이터를 조작하는 데 사용됩니다.\n\n\n\n- \"Create\" 작업은 데이터베이스에 새 데이터를 추가하는 데 사용됩니다.\n- \"Read\" 작업은 데이터베이스에서 기존 데이터를 검색하는 데 사용됩니다.\n- \"Update\" 작업은 데이터베이스의 기존 데이터를 수정하는 데 사용됩니다.\n- \"Delete\" 작업은 데이터베이스에서 데이터를 제거하는 데 사용됩니다.\n\nCRUD 함수는 데이터 관리와 관련된 웹 애플리케이션이나 소프트웨어를 개발할 때 필수적입니다. 이를 통해 데이터를 효과적으로 관리하고 효율적으로 처리하여 사용자가 올바른 정보에 올바른 시간에 액세스할 수 있도록 합니다.\n\n우리의 제품 모델을 기반으로 index.js에 다음 라우트를 추가해주세요:\n\n```js\n//새 제품을 생성합니다.\napp.post(\"/create\", async (req, res) => {\n  const newProduct = new Product({\n    title: req.body.title,\n    description: req.body.description,\n    price: req.body.price,\n    discountPercentage: req.body.discountPercentage,\n    rating: req.body.rating,\n    stock: req.body.stock,\n    brand: req.body.brand,\n    category: req.body.category,\n    thumbnail: req.body.thumbnail,\n    images: req.body.images,\n  });\n\n  await Product.create(newProduct);\n  res.send(\"제품이 데이터베이스에 저장되었습니다!\");\n});\n```\n\n\n\n```js\n// 모든 제품 목록 가져오기\napp.get(\"/read\", async (req, res) => {\n  const productList = await Product.find();\n  res.send(JSON.stringify(productList));\n});\n```\n\n```js\n// id를 기반으로 제품 업데이트\napp.put(\"/update/:id\", async (req, res) => {\n  const product_id = req.params.id;\n  await Product.findByIdAndUpdate(product_id, {\n    title: req.body.title,\n    description: req.body.description,\n    price: req.body.price,\n    discountPercentage: req.body.discountPercentage,\n    rating: req.body.rating,\n    stock: req.body.stock,\n    brand: req.body.brand,\n    category: req.body.category,\n    thumbnail: req.body.thumbnail,\n    images: req.body.images,\n  });\n\n  res.send(\"제품이 성공적으로 업데이트되었습니다!\");\n});\n``` \n\n```js\n// id를 기반으로 제품 삭제\napp.delete(\"/delete/:id\", async (req, res) => {\n  const product_id = req.params.id;\n  await Product.findByIdAndDelete(product_id);\n  res.send(\"제품이 삭제되었습니다!\");\n});\n```\n\n위 코드에서 제품을 조작하는 네 가지 기본 라우트를 볼 수 있습니다. 프론트엔드 없이 테스트하려면 API 테스트 도구가 필요합니다. 저는 Postman(https://www.postman.com/)을 사용할 예정이지만, 다른 API 테스트 도구를 잘 알고 있다면 사용해도 좋습니다!\n```\n\n\n\n테스트해 봐요!\n\ncreate 메서드를 사용하면 데이터베이스에 새 제품을 추가할 수 있고 성공적인 응답을 받을 수 있어요!\n\n<img src=\"/assets/img/2024-05-12-CreatinganE-commerceSitewithMERNStackPartII_1.png\" />\n\nupdate 메서드를 사용하면 특정 제품을 업데이트할 수 있어요.\n\n\n\n<img src=\"/assets/img/2024-05-12-CreatinganE-commerceSitewithMERNStackPartII_2.png\" />\n\n삭제 메소드를 사용하여 데이터베이스에서 ID별 제품을 삭제할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-12-CreatinganE-commerceSitewithMERNStackPartII_3.png\" />\n\nget 메소드를 사용하여 데이터베이스에서 모든 제품을 검색할 수 있습니다.\n\n\n\n![이미지](/assets/img/2024-05-12-CreatinganE-commerceSitewithMERNStackPartII_4.png)\n\n체크를 수행하려면 Mongo DB Compass에서 다음 단계를 따르기만 하면 됩니다:\n\n- Mongo DB Compass를 엽니다.\n- 확인하려는 데이터베이스에 연결합니다.\n- 확인하려는 컬렉션을 선택합니다.\n- 컬렉션의 문서를 보고 데이터가 올바른지 확인합니다.\n\nMongo DB Compass에서 정기적인 확인을 수행함으로써 데이터의 정확성과 최신 상태를 보장할 수 있습니다. 특히 전자 상거래 웹사이트와 같이 대량의 데이터를 처리할 때 이 기능은 매우 중요합니다. 애플리케이션이 원활하게 작동하는지 확인하려면 꾸준한 확인을 잊지 마세요!\n\n\n\n![이미지](/assets/img/2024-05-12-CreatinganE-commerceSitewithMERNStackPartII_5.png)\n\n단일 제품을 가져오는 방법은 업데이트 함수와 매우 유사합니다. 단순히 id를 포함하고 .findById() 함수를 사용하면 됩니다. 마지막에 제품 객체를 반환합니다.\n\n이 연습을 좋은 도전으로 생각해보고 혼자서 작성해 보세요. 한번 시도해보고 어떻게 진행되는지 확인해보세요! 만약 잘 되지 않는다면 걱정하지 마세요! 항상 GitHub에서 해결책을 찾을 수 있습니다.\n\n마무리\n\n\n\n이 글에서는 Node.js로 MongoDB 데이터베이스를 조회하는 기본적인 내용을 다뤘어요. 우리는 기본 CRUD 함수를 생성하고 활용했는데, 이에 대해 더 깊이 들어가는 내용은 다음 글에서 다룰 예정이에요. 저희의 GitHub 저장소에서 코드를 확인하지 않으시면 안돼요! 다음 파트에서 뵙겠습니다!","ogImage":{"url":"/assets/img/2024-05-12-CreatinganE-commerceSitewithMERNStackPartII_0.png"},"coverImage":"/assets/img/2024-05-12-CreatinganE-commerceSitewithMERNStackPartII_0.png","tag":["Tech"],"readingTime":7},{"title":"효율적인 아키텍처 구현을 위한 프론트엔드 프레임워크 추천","description":"","date":"2024-05-12 19:44","slug":"2024-05-12-Frontendframeworksrecommendedforimplementingthearchitecture","content":"\n\n![Frontend Frameworks Recommended for Implementing the Architecture](/assets/img/2024-05-12-Frontendframeworksrecommendedforimplementingthearchitecture_0.png)\n\n깨끗하고 확장 가능한 프론트엔드 아키텍처를 구현할 때 고려할 수 있는 현대적인 프론트엔드 프레임워크가 여러 가지 있습니다. React와 Angular가 널리 사용되는 두 가지 선택지입니다.\n\nReact는 페이스북에서 개발된 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리입니다. React는 간결함과 유연성으로 유명하며 대규모 웹 애플리케이션을 구축하는 데 인기가 있습니다. React를 사용하면 재사용 가능한 UI 컴포넌트를 구축할 수 있어 코드베이스를 단순화하고 유지 관리를 쉽게할 수 있습니다.\n\n## 이것은 React를 사용한 간단한 카운터 컴포넌트의 예입니다:\n\n\n\n```js\r\njs\r\n```\r\n\r\n```js\r\n전체 화면 편집 코드 복사\r\n```\r\n\r\n```js\r\n1import { useState } from \"react\";\r\n2\r\n3export function Counter() {\r\n4  const [count, setCount] = useState(0);\r\n5\r\n6  function updateCounter(val: number) {\r\n7    setCount(count + val);\r\n8  }\r\n9\r\n10  return (\r\n11    <div>\r\n12      <h2>카운터 값은 {count}입니다</h2>\r\n13      <button onClick={() => updateCounter(1)}>증가</button>\r\n14    </div>\r\n15  );\r\n16}\r\n```\r\n\r\n이 예제에서는 useState 훅을 사용하여 카운터의 상태를 관리합니다. updateCounter 함수는 useState로 반환된 setter 함수를 사용하여 카운터 값을 업데이트합니다.\n\n\n\nAngular은 웹 애플리케이션을 구축하는 데 사용할 수 있는 완전한 기능을 갖춘 프레임워크에요. Google에서 개발 및 유지보수되며 복잡한 애플리케이션을 구축하는 데 필요한 다양한 도구와 기능을 제공해요. Angular는 컴포넌트 기반 아키텍처를 사용하여 모듈화되고 확장 가능한 애플리케이션을 만들 수 있도록 도와줘요.\n\n## Angular를 사용한 간단한 카운터 컴포넌트 예시입니다:\n\n```js\ntypescript\n```\n\n```js\nEditFull ScreenCopy code\n```\n\n\n\n```js\n1import { Component } from '@angular/core';\n  \n2\n3@Component({\n4  selector: 'counter-comp',\n5  template: `\n6    <div style=\"border:2px solid red\">\n7      <h2>counter value is { count }</h2>\n8      <button (click)=\"updateCounter()\" [disabled]=\"count > 5\">increment</button>\n9    </div>\n10  `,\n11  styles: []\n12})\n13export class CounterComponent {\n14  count = 1;\n15\n16  updateCounter() {\n17    this.count++;\n18  }\n19}\n```\n\n이 예제에서는 카운터 상태를 관리하는 CounterComponent 클래스를 정의합니다. updateCounter 메서드는 카운터 값을 증가시킵니다.\n\n## React와 Angular 모두 각자의 강점과 약점을 가지고 있으며, 두 프레임워크 중 어느 것을 선택할지는 여러분의 특정 요구사항과 선호도에 따라 다를 것입니다. 가벼우면서 유연한 라이브러리를 찾고 있다면 React가 더 나은 선택일 수 있습니다. 다양한 기능과 도구를 갖춘 포괄적인 프레임워크를 찾고 있다면 Angular가 더 나은 선택일 수 있습니다.\n\n중요한 것은 여러분의 요구사항을 충족하고 깔끔하고 확장 가능한 프론트엔드 아키텍처를 구축할 수 있는 프레임워크를 선택하는 것입니다. 신중히 옵션을 평가하고 적절한 프레임워크를 선택함으로써 성공을 이룰 수 있으며, 응용 프로그램을 유지보수하고 시간이 흐를수록 확장할 수 있도록 할 수 있습니다.```","ogImage":{"url":"/assets/img/2024-05-12-Frontendframeworksrecommendedforimplementingthearchitecture_0.png"},"coverImage":"/assets/img/2024-05-12-Frontendframeworksrecommendedforimplementingthearchitecture_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 앱 만들기 Create React App 없이","description":"","date":"2024-05-12 19:42","slug":"2024-05-12-CreateReactAppwithoutCreateReactApp","content":"\n\n```\n![이미지](/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_0.png)\n\n이 기사는 \"create-react-app\", \"NextJS\" 등의 라이브러리 또는 프레임워크를 사용하지 않고 리액트 앱을 만드는 과정에 대해 이야기합니다.\n\n## 사전 지식 개념\n\n- Webpack — 코드를 하나의 파일로 번들링하는 데 도움을 줍니다.\n- Babel — ECMAScript 2015+ (ES6+) 코드를 이전 JavaScript 엔진에서 실행할 수 있는 하위 호환 버전으로 변환하는 데 사용됩니다.\n- Node.js — 노드 설치, package.json 생성 및 npm을 사용하여 노드 모듈 설치\n```\n\n\n\n## 이 기사는 다음 사항을 이해하는 데 도움이 됩니다\n\n- 웹팩(webpack)과 바벨(babel)이 어떻게 실제로 작동하는지;\n- 리액트(React) 앱을 빌드하는 시작부터 끝까지의 흐름;\n- 개발 및 프로덕션 빌드 설정 방법 및 중요성;\n- 필요한 서버 세부 정보 설정;\n- 웹팩(webpack)과 바벨(babel) 구성 파일 작성 및 그곳에 존재하는 논리 이해;\n- 클라이언트 측 및 서버 측 렌더링 구성 방법;\n- React에서 HMR(Hot Module Replacement)이 작동하는 방식 이해.\n\n## 소스 코드\n\n- 리포지토리 — https://github.com/kannanagasamy/react-app-without-cra\n- 브랜치 — main\n\n\n\n더 알아보기:\n\n## 절차\n\n1. 시스템에 node가 설치되어 있는지 확인합니다\n\n시스템에 Node.js를 설치하고 터미널에서 node -v를 입력하여 설치되어 있는지 확인합니다.\n\n\n\n## 2. 프로젝트 폴더 및 package.json 생성하기\n\n아무 이름으로 프로젝트 폴더를 생성하고 해당 폴더로 이동한 후 npm init을 사용하여 폴더 안에 package.json 파일을 생성합니다. 폴더로 이동하세요.\n\n## 3. 웹팩 종속성 설치하기\n\n```js\nnpm i --save-dev webpack webpack-cli webpack-dev-server\n```\n\n\n\n- 웹팩 — 코드를 모두 번들로 묶어 최종 빌드를 생성할 수 있습니다.\n- 웹팩-cli — 개발자가 커스텀 웹팩 프로젝트를 설정할 때 속도를 높이기 위해 유연한 명령 집합을 제공하는 CLI 도구입니다. 웹팩 v4 이상을 사용하고 명령 줄에서 웹팩을 호출하려면 이 도구가 필요합니다.\n- 웹팩-dev-server — 웹팩 개발 서버는 미니 노드.js 익스프레스 서버입니다. SockJS라는 라이브러리를 사용하여 웹 소켓을 흉내냅니다. 로컬호스트 개발 환경을 만들 수 있게 해줍니다.\n\n## 4. Babel 종속성 설치\n\n```js\nnpm i --save-dev babel-loader @babel/preset-env @babel/core \n@babel/plugin-transform-runtime \n@babel/preset-react \n@babel/eslint-parser \n@babel/runtime\n@babel/cli\n```\n\n- babel-loader — JavaScript 파일을 babel과 웹팩을 사용하여 변환할 수 있게 해줍니다. 각 파일에 대한 Babel 구성의 사용자 정의 처리를 추가할 수 있는 로더 빌더 유틸리티를 노출합니다.\n- @babel/preset-env — 해당 환경에 필요한 syntax 변환 및 브라우저 폴리필을 세밀하게 관리하지 않고 최신 JavaScript를 사용할 수 있도록 합니다. 이렇게 함으로써 JavaScript 번들이 더 작아지고 개발자의 작업을 더욱 쉽게 할 수 있습니다!\n- @babel/core — 코어 패키지\n- @babel/plugin-transform-runtime — Babel의 주입된 도우미 코드를 재사용하여 코드 크기를 줄이도록 하는 플러그인\n- @babel/preset-react — Reactjs를 사용할 때 React 프리셋을 사용합니다. HTML 파일을 React 기반 파일로 변환하는 데 도움이 됩니다.\n- babel-eslint — Babel에 의해 변환된 소스 코드에서 ESLint를 실행할 수 있게 하는 파서\n- @babel/runtime — 폴리필 및 다른 Babel이 참조할 수 있는 것들을 포함하는 패키지\n- @babel/cli — Babel을 사용하기 위한 명령 줄 인터페이스\n\n\n\n## 5. 필요한 린터 및 경로 설치하기\n\n```js\nnpm i --save-dev eslint eslint-config-airbnb-base \neslint-plugin-jest \neslint-config-prettier\npath\n```\n\n## 6. 리액트와 리액트 돔 설치하기\n\n```js\nnpm i react react-dom\n```\n\n\n\n## 7. index.html 파일 생성하기\n\n프로젝트의 루트에 \"public\"이라는 폴더를 생성하세요. 그 안에 index.html 파일을 만들어주세요.\n\n## 8. App.js 파일 생성하기\n\nsrc 폴더를 생성하고 그 안에 App.js 파일을 만드세요. 다음 코드를 추가해주세요:\n\n\n\n## 8. index.js 파일 만들기\n\n프로젝트의 루트 또는 원하는 곳에 index.js 파일을 만듭니다. 이 파일은 webpack의 진입점으로 작동할 것입니다.\n\n다음 코드를 추가합니다:\n\n## 9. webpack.config.js 파일 만들기\n\n\n\n프로젝트 루트에 webpack.config.js 파일을 생성하고 다음 코드를 추가하세요. 더 나아가 이 파일은 파일들을 하나의 닠 파일로 번들링하고 개발 서버를 설정하는 구성을 포함하고 있습니다.\n\n코드 내의 주석은 각 줄이 무엇을 하는지 이해하는 데 도움이 됩니다:\n\n## 10. .babelrc 파일 생성\n\n루트에 .babelrc 파일을 생성하고 다음 코드를 추가하세요.\n\n\n\n이것은 Babel을 위한 설정 파일입니다. babel이 내부에 정의된 플러그인과 프리셋을 사용하도록 지시할 것입니다.\n\n## 11. package.json 파일 업데이트\n\n7번째와 8번째 줄에 start 및 build 스크립트를 추가하십시오.\n\n- start 스크립트는 웹팩 개발 서버를 현재 프로젝트의 public 폴더에서 9500 포트로 실행하라는 것입니다.\n- build 명령은 main.js 파일에 이 패키지를 빌드하라는 것입니다. 이는 사실상 webpack.config.js 파일의 모든 논리를 실행합니다.\n\n\n\n## 12. 최종 프로젝트 폴더 구조가 이렇게 되어야 합니다\n\n![프로젝트 폴더 구조](/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_1.png)\n\n## 13. \"npm run build\" 실행하기\n\n- 위의 코드를 추가한 후 npm run build를 실행하세요. 이렇게 하면 public 폴더에 main.js 파일이 생성됩니다. 이 파일은 실제로 1MB 이상의 크기를 가지고 있습니다. 이것이 개발용 빌드입니다.\n\n\n\n## 14. \"npm start\" 명령 실행하기\n\n터미널에서 `npm start` 명령을 실행하여 애플리케이션을 시작하세요. 이렇게 하면 개발 서버가 시작됩니다.\n\n코드 전체는 위에서 공유한 저장소 링크에서 찾을 수 있습니다.\n\n# 기타 주요 사항\n\n\n\n## 프로덕션 빌드로 변경하기\n\n- 이제 프로덕션 빌드로 변경해 볼 수 있어요. 이를 위해 webpack.config.js 파일에 다음 변경을 해야 합니다.\n\n```js\nmode: \"production\"\n```\n\n- 이제 npm run build를 실행하면 다시 main.js 파일이 생성되지만 사이즈가 매우 작아질거에요 (`200kb).\n- 1000KB에서 200KB로 최적화되어 더 나은 프로덕션 빌드를 사용하는 것이 좋을 수 있어요. 하지만 개발 중에는 핫 리로딩이 더 빠르기 때문에 개발 모드를 사용해야 해요.\n\n\n\n## 핫 모듈 교체\n\n- HMR은 webpack-dev-server에서 처리됩니다. 페이지 로드 옵션 없이도 HMR을 사용할 수 있습니다. 필요한 옵션을 설정하면 성능 측면에서 큰 도움이 됩니다.\n- 다양한 시나리오에 대한 아래 코드 스니펫을 확인해보세요:\n\n```js\n//HMR을 사용하지만 라이브 리로드를 사용하지 않으려면 webpack.config.js에서 아래 구성을 사용하세요.\ndevServer: {\n        hot: true ,\n        liveReload:false\n    }\n\n//HMR을 사용하고 싶지 않지만 라이브 리로드를 사용하려면,\ndevServer: {\n        hot: false ,\n        liveReload: true\n    },\n\n//라이브 리로드를 사용하고 싶지 않다면,\ndevServer: {\n        hot: false , //이 옵션은 필수로 false로 설정해야 합니다.\n        liveReload: false\n    },\r\n```\n\n## 참고문헌\n\n\n\n- 웹팩의 HMR — https://webpack.js.org/guides/hot-module-replacement/\n- 번들 크기를 줄이는 다양한 방법 — https://blog.jakoblind.no/3-ways-to-reduce-webpack-bundle-size/\n- devserver 이해 및 자세한 작업 방법 — https://webpack.js.org/configuration/dev-server/#devserverlivereload\n- 프로덕션을 위한 번들 최소화 — https://webpack.js.org/plugins/mini-css-extract-plugin/#minimizing-for-production\n- 웹팩을 사용한 프로덕션 사이트 구축 방법 — https://webpack.js.org/guides/production/\n- 완벽한 devpack 서버 설정 — https://linguinecode.com/post/how-to-setup-webpack-dev-server-react-babel\n- 로더 자세히 살펴보기 — https://webpack.js.org/concepts/loaders/\n- babel-preset-env 자세히 이해하기 — https://blog.jakoblind.no/babel-preset-env/\n\n이 글이 도움이 되셨기를 바라며. 다음 글도 기대해주세요.\n\n# 리액트 앱을 레고처럼 재사용 가능한 컴포넌트로 만들기\n\n![이미지](/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_2.png)\n\n\n\nBit의 오픈 소스 도구는 25만 명 이상의 개발자가 컴포넌트를 사용하여 앱을 개발할 수 있게 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 컴포넌트로 전환하고 애플리케이션 간에 공유하세요. 협업이 더 쉽고 빠르게 개발할 수 있습니다.\n\n→ 자세히 알아보기\n\n앱을 구성 요소로 분할하여 앱 개발을 쉽게 만들고 원하는 워크플로에 최상의 경험을 누릴 수 있습니다:\n\n\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포\n\n\n\n## 더 알아보기:","ogImage":{"url":"/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_0.png"},"coverImage":"/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_0.png","tag":["Tech"],"readingTime":6},{"title":"React 개발을 향상시키는 새로운 훅과 19버전의 개선 사항","description":"","date":"2024-05-12 19:41","slug":"2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19","content":"\n\n![React 19 new features](/assets/img/2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19_0.png)\n\n안녕하세요! React 19이 출시되었는데요, 새로운 도구와 개선 사항이 많아져 개발자들에게 일을 더 쉽게 만들어 줍니다. 이 블로그 포스트에서는 무엇이 새로운지 살펴보고 React 개발을 어떻게 더 나아지게 하는지 알아보겠습니다.\n\n새로운 훅 요약:\n- use: 이 새로운 훅은 비동기 데이터 가져오기와 처리를 간단하게 만들어 주어 약속이 해결될 때까지 컴포넌트를 중단할 수 있습니다.\n- useFormStatus: 개발자들은 이제 양식 제출 상태를 효과적으로 추적하여 사용자에게 양식 처리 중 더 나은 피드백을 제공할 수 있습니다.\n- useActionState: 이 훅은 액션 상태를 추적하고 직접적으로 상태를 업데이트할 수 있어 UI 피드백을 강화하고 UI 액션 관리를 향상시킵니다.\n- useOptimistic: 이 훅을 사용하면 낙관적 업데이트를 쉽게 관리할 수 있어 서버로부터 확인을 받기 전에 즉시 변경 사항을 반영할 수 있습니다.\n\n\n\n새로운 훅의 장점:\n\n- 간소화된 비동기 데이터 가져오기: use 훅을 사용하면 구성 요소가 데이터 가져오기가 완료될 때까지 대기하도록 설정하여 프로세스를 최적화하고 사용자 경험을 향상시킵니다.\n- 더 나은 폼 피드백: useFormStatus를 사용하면 개발자가 양식 제출 중에 사용자에게 향상된 피드백을 제공하여 더 직관적인 인터페이스를 제공할 수 있습니다.\n- 동작 상태 추적: useActionState를 활용하면 동작 상태를 직접 제어하며 UI 피드백을 향상시키고 상호 작용을 더 부드럽게 만들 수 있습니다.\n- 낙관적 UI 업데이트: useOptimistic을 활용하면 개발자가 효율적인 서버 동기화로 사용자에게 즉각적인 피드백을 제공하여 원활한 사용자 경험을 만들 수 있습니다.\n\n결론:\nReact 19의 새로운 훅과 개선 사항은 상태 관리, 이벤트 처리, 애플리케이션 성능 향상에 필요한 강력한 도구를 개발자에게 제공합니다. 이벤트 처리를 간소화하고 낙관적 업데이트를 개선하며 동시 렌더링을 더 잘 제어함으로써 React 19는 고성능 애플리케이션 개발의 기반을 마련합니다.\n\n이러한 발전을 통해 개발자는 React 프로젝트를 새로운 수준으로 끌어올려 사용자 경험을 혁신하고 웹 개발에서 혁신을 이끌 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19_0.png"},"coverImage":"/assets/img/2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19_0.png","tag":["Tech"],"readingTime":2},{"title":"Nodejs, React 및 TypeScript에서 인증 및 권한 부여 방법 ","description":"","date":"2024-05-12 19:37","slug":"2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2","content":"\n<img src=\"/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_0.png\" />\n\n# 소개\n\n이것은 웹 애플리케이션에서 사용자 인증 및 권한을 구현하는 두 부분 튜토리얼의 두 번째 기사입니다.\n\n튜토리얼의 첫 번째 부분은 현대 웹 애플리케이션 내에서 인증 및 권한의 개념을 설명하는 데 전념되었습니다. 아직 보지 않았다면, 진행하기 전에 첫 번째 부분을 확인하는 것을 추천합니다.\n\n기초를 다룬 기초를 바탕으로, React, Node.js 및 TypeScript를 사용하여 토큰 기반 사용자 인증 및 권한 부여를 하는 풀 스택 시스템을 단계별로 구현할 것입니다. 이 튜토리얼의 완전한 코드베이스를 이 GitHub 저장소에서 찾을 수도 있습니다. 먼저 다음 섹션에서 프로젝트 구조에 익숙해져 봅시다.\n\n# 프로젝트 구조\n\n![프로젝트 구조](/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_1.png)\n\n위의 그림 1에서 전체 풀 스택 프로젝트 구조가 나와 있습니다. 서버 및 사용자 인터페이스(UI) 내 각 구성 요소의 목적에 대해 논의해 봅시다.\n\n## 사용자 인터페이스\n\n사용자 인터페이스는 매우 기본적이며, 프레젠테이션 레이어의 Auth 컴포넌트로 구성됩니다. 사용자는 이러한 컴포넌트와 상호작용하여 사용자 지정 후크 useApi 및 ApiProvider 클래스를 통해 서버에 인증을 요청합니다. 서버가 사용자가 제출한 자격 증명을 유효성 검사하면 응답 내에서 JWT 토큰을 반환합니다. 유효한 서버 응답시, 컴포넌트로부터 AuthReducer로 작업이 디스패치됩니다. 디스패치된 작업은 관련 AuthState로 줄어들고, AuthContext를 통해 전체 어플리케이션 인터페이스에 제공됩니다. 사용자 인터페이스는 React 및 TypeScript를 사용하여 구현될 것입니다.\n\n## 서버\n\n서버는 인터페이스에서 사용자 자격 증명 데이터와 함께 요청을 받게 될 것입니다. 먼저 Cors(Cross-Origin-Resource-Sharing) 규칙을 위반하지 않는지 확인하고 제출된 입력 데이터가 유효한지를 검증할 것입니다. 이러한 단계 중 하나라도 통과하지 못하면 오류 응답이 반환됩니다. 사용자 인증은 사용자/가입 route에서 새로운 사용자가 생성되거나 사용자/로그인 route에서 기존 사용자가 인증됩니다. 이 프로젝트에서는 InMemoryDataProvider가 구현되며 사용자 데이터는 간단한 객체에 저장됩니다. 이는 튜토리얼이 복잡해지지 않도록 의도된 것이며 사용자 인증 및 권한 부여에 중점을 두었습니다. DataProviderInterface는 데이터 검색 기능을 추상화하기 위해 사용되며, 나중에 이를 구현하는 다른 제공자로 쉽게 전환할 수 있도록 설계되었습니다. 사용자가 가입 또는 로그인을 성공적으로 완료하면 서명된 서버와 함께 만료 가능한 JWT(JSON Web Token)가 생성되어 사용자 인터페이스로 반환됩니다. 이 토큰, 일반적으로 인증 토큰으로 알려져 있으며, 사용자 인터페이스에서 /resource 엔드포인트를 통해 보호된 서버 측 리소스에 액세스하기 위해 요청에 포함됩니다.\n\n# 사전 준비 사항\n\n이 튜토리얼을 성공적으로 완료하기 위한 전제 조건 목록은 다음과 같습니다:\n\n- 해당 튜토리얼을 완료하려면 컴퓨터에 Node.js가 설치되어 있어야 합니다.\n- Node Package Manager (NPM)은 Node.js가 설치되어 있으면서 Yarn을 선호하며 프로젝트 종속성 관리에는 Yarn이 사용될 것입니다.\n- 웹이 작동하는 방식에 대한 알맞은 지식이 있어야 하며 인증 및 권한 부여 시스템을 구현한 시스템을 사용하거나 본적이 있어야 합니다.\n- 본 문서 이전에 Node.js, React 및 Typescript와 함께 작업한 경험이 있어야 하지만, 코드 안내를 받을 예정이므로 심층적인 지식은 선택 사항입니다.\n\n자, 소개는 이제 끝내고 실제 프로젝트 구현으로 넘어가 봅시다. 멋지네요! 😁\n\n# 1. 서버 설정\n\n## 1.1 의존성 설치\n\n먼저 다음 명령어를 사용하여 프로젝트 디렉토리를 만들고 서버 코드 기반을 설정해보겠습니다:\n\n```js\nmkdir authentication-and-authorization &&\\\ncd authentication-and-authorization &&\\\nmkdir server &&\\\ncd server && mkdir src\n```\n\n시작 서버 폴더 구조는 아래와 같이 표시됩니다:\n\n```bash\n/authentication-and-authorization\n  |__ /server\n      |__ /src\n```\n\n/server 폴더 안에 있는 터미널에서 다음 명령어를 실행하여 노드 프로젝트를 초기화하세요:\n\n```bash\nnpm init -y\n```\n\n이제 서버 프로젝트의 시작점이 있으니 다음 명령어를 사용하여 Typescript 프로젝트로 설정하겠습니다:\n\n```js\nyarn add typescript @types/node --dev && npx tsc --init\n```\n\n위 명령은 /server 폴더 안에 tsconfig.json 파일을 생성했을 겁니다. 해당 파일의 내용을 아래 코드와 같이 변경해주세요:\n\n```js\n{\n  \"compilerOptions\": {\n    \"target\": \"es2016\",\n    \"module\": \"commonjs\",\n    \"rootDir\": \"./src\",\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true\n  }\n}\n```\n\n가장 중요한 설정은 rootDir입니다. 이 설정은 TypeScript 컴파일러에게 .ts 파일을 어디에서 찾아 .js 파일로 변환하고 outDir로 지정된 디렉토리에 배치해야 하는지 알려줍니다.\n\n이제 서버에 필요한 초기 패키지 종속성을 설치하겠습니다:\n\n```js\nyarn add express dotenv cors &&\\\nyarn add @types/express @types/dotenv @types/cors --dev\n```\n\n3rd party 패키지에 대한 타입 정의 파일도 개발 종속성으로 설치했다는 것에 유의하세요.\n\n## 1.2 Express 서버 만들기\n\n먼저 Express 서버의 기본 구조를 생성하고 본 강좌를 통해 이를 확장해 나갈 것입니다. /server/src 디렉토리 안에서 다음 명령을 실행하여 app.ts와 index.ts를 생성하세요:\n\n```js\ntouch app.ts && touch index.ts\n```\n\napp.ts 안에는 서버 환경 변수를 초기화하고 관련 미들웨어를 사용하여 Express 앱 객체를 생성할 것입니다. app.ts의 내용은 아래와 같습니다 (이것은 해당 파일의 최종 코드가 아닙니다):\n\n```js\n/* app.ts */\n\n// 전역 종속성\nimport * as dotenv from \"dotenv\";\ndotenv.config(); // 로컬 .env 파일을 사용하여 환경 변수를 초기화합니다\n\n// 프로젝트 종속성\nimport routes from \"./routes\";\n\n// express 앱 설정\nimport express from \"express\";\nconst app = express();\n\n// 미들웨어\napp.use(express.json());\n\n// 라우트\napp.use(routes);\n\nexport default app;\n```\n\nindex.ts에서는 아래와 같이 SERVER_PORT 환경 변수로 지정된 포트에서 express 서버를 실행할 것입니다:\n\n```js\n/* index.ts */\n\n// 프로젝트 종속성\nimport app from \"./app\";\nconst { SERVER_PORT } = process.env;\n\n// 앱이 listening중\napp.listen(SERVER_PORT, () => {\n  console.info(`앱이 포트 ${SERVER_PORT}에서 실행 중입니다`);\n});\n```\n\nGit에서 무시될 수 있는 .env 파일에 프로젝트 환경 변수를 지정하는 것은 좋은 관행입니다. 이 파일은 /server폴더에 생성할 것입니다:```\n\n```js\n# .env\n\nSERVER_PORT=8000\n```\n\n익스프레스 서버를 실행하려면 /server 폴더 내에서 다음 명령을 실행할 수 있습니다:\n\n```js\nrm -rf ./dist && npx tsc && cp .env ./dist/.env && cd ./dist && node index.js\n```\n\n위 명령은 먼저 ./dist 디렉토리를 제거하고, ./src 디렉토리에 있는 모든 코드를 타입 확인하고 ./dist 디렉토리 내의 JavaScript로 변환합니다. 컴파일 단계가 완료되면 .env 파일이 ./dist 디렉토리로 복사되어 서버를 node index.js로 실행할 때 환경 변수가 올바르게 초기화됩니다. 매번 이 명령을 실행하는 것은 지루할 수 있으므로 server/package.json 내에 몇 가지 스크립트를 만들어 프로세스를 단순화하겠습니다:\n\n```\n\n\n\n```json\n{\n  \"name\": \"server\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"npx tsc && cp .env ./dist/.env\",\n    \"start\": \"rm -rf ./dist && yarn build && cd ./dist && node index.js\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@types/cors\": \"^2.8.13\",\n    \"@types/dotenv\": \"^8.2.0\",\n    \"@types/express\": \"^4.17.15\",\n    \"@types/node\": \"^18.11.18\",\n    \"typescript\": \"^4.9.4\"\n  },\n  \"dependencies\": {\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^16.0.3\",\n    \"express\": \"^4.18.2\"\n  }\n}\n```\n\n이제 start 스크립트를 사용하여 아래와 같이 서버를 실행할 수 있습니다:\n\n```bash\nyarn start\n```\n\n![이미지](/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_2.png)\n\n```\n\n\n\n서버 프로젝트가 이제 설정되었습니다. 다음 섹션에서는 백엔드 인증 및 권한 시스템 설정 과정을 보여드릴 것입니다.\n\n## 1.3 사용자 데이터 제공자\n\n데이터 저장 레이어는 인증 시스템에 필수적입니다. 새 사용자가 생성될 때, 그들의 데이터는 유지되어야 합니다. 나중에 로그인할 때 사용자가 제출한 자격 증명을 확인할 수 있도록 합니다. 간단히 말해서, 사용자 데이터 저장을 위해 인메모리 저장을 구현할 것이지만, 나중에 실제 데이터베이스로 구현을 교체하는 것이 쉽도록 인터페이스를 사용하여 구현할 것입니다.\n\n/server/src/data_providers 폴더를 생성하고 아래와 같이 인터페이스 IDataProvider를 정의할 것입니다.\n\n\n\n```js\n// server/src/data_providers/IDataProvider.ts\n\nexport default interface IDataProvider<Resource> {\n  createData: (resource: Resource) => Promise<void>;\n  readData: (args: {id: string, matchField: string}) => Promise<Resource>;\n  updateData: (args: {id: string, resource: Resource}) => Promise<void>;\n  deleteData: (id: string) => Promise<void>;\n}\n```\n\n이 인터페이스는 일반적인 CRUD 작업을 나타내는 네 가지 메서드로 구성되어 있습니다. 이 메서드들은 Resource 타입의 일반적인 값을 소비하거나 반환합니다. IDataProvider의 InMemoryDataProvider 구현은 아래와 같이 보여집니다.\n\n```js\n// server/src/data_providers/InMemoryDataProvider.ts\n\nimport IDataProvider from \"./IDataProvider\";\n\nexport default class InMemoryDataProvider<Resource extends {id: string, data: any}> implements IDataProvider<Resource> {\n  private _data: Resource[];\n\n  constructor() {\n    this._data = [];\n  };\n\n  public async createData(resource: Resource) {\n    this._data.push(resource);\n    return;\n  }\n\n  public async readData(args: {id: string, matchField: string}) {\n    return this._data.filter(x => x.data[args.matchField] === args.id)[0];\n  };\n\n  public async updateData(props: { id: string; resource: Resource; }) {\n    const {id, resource} = props;\n    for(const datum of this._data) {\n      if(datum.id === id) {\n        datum.data = resource.data;\n      }\n    }\n\n    return;\n  };\n\n  public async deleteData(id: string) {\n    this._data = this._data.filter(datum => datum.id !== id);\n    return;\n  };\n}\n```\n\nInMemoryDataProvider는 IDataProvider에서 정의된 공개 메서드를 엄격하게 구현합니다. 실제 데이터 저장소는 InMemoryDataProvider 클래스 인스턴스에 특정한 private \\_data 배열 속성입니다. InMemoryDataProvider의 generic 타입은 Resource이며 'id: string, data: any'를 확장하였기 때문에 입력 자원은 id 및 데이터를 포함하고 기타 속성을 추가로 가져야합니다. TypeScript의 이 인터페이스 중심적 접근의 장점은 IDataProvider 인터페이스를 준수한다면 데이터 저장소를 다른 구현체로 쉽게 교체할 수 있다는 점입니다(예: SQL 데이터베이스 사용).```\n\n사용자 관련 데이터에서 CRUD 작업을 실행하기 위해 비즈니스 로직을 데이터 액세스 계층에서 분리하는 사용자 저장소를 추가로 생성할 것입니다. 먼저, 다음과 같이 정의된 추상화 Repository를 작성할 것입니다. 이 Repository는 다양한 데이터 소스 유형에서 확장될 수 있는 인터페이스를 정의합니다.\n\n```js\n// server/src/repositories/Repository.ts\n\nimport IDataProvider from \"../data_providers/IDataProvider\";\n\nexport default class Repository<Resource> {\n  protected _provider: IDataProvider<Resource>;\n\n  constructor(args: {provider: IDataProvider<Resource>}) {\n    this._provider = args.provider;\n  };\n\n  public get provider(): IDataProvider<Resource> {\n    return this._provider;\n  }\n}\n```\n\nRepository에서 파생된 클래스는 데이터 액세스 계층을 형성하는 IDataProvider를 구현하는 제공자(provider)를 가져야 합니다. 그리고 UserRepository 클래스는 Repository를 확장하고 사용자 데이터와 상호작용하는 자체 public 메서드를 갖습니다. 아래에서 자세히 살펴봅시다.\n\n```js\n// server/src/repositories/UserRepository.ts\n\nimport IDataProvider from \"../data_providers/IDataProvider\";\nimport Repository from \"./Repository\";\nimport { randomUUID } from \"crypto\";\nimport InMemoryDataProvider from \"../data_providers/InMemoryDataProvider\";\n\ntype UserData = {\n  email: string,\n  name: string,\n  password: string,\n  createdAt: string,\n  updatedAt: string\n};\n\nexport class UserResource {\n  private _id: string;\n\n  constructor(private _data: UserData) {\n    this._id = randomUUID();\n  };\n\n  public get id(): string {\n    return this._id;\n  }\n\n  public get data(): UserData {\n    return this._data;\n  }\n}\n\nexport class UserRepository extends Repository<UserResource> {\n  constructor(args: {provider: IDataProvider<UserResource>}) {\n    super({provider: args.provider});\n  }\n\n  public async createUser(user: UserResource) {\n    await this.provider.createData(user);\n    return;\n  }\n\n  public async getUserBy(args: {id: string, matchField: string}) {\n    return this.provider.readData({id: args.id, matchField: args.matchField});\n  }\n}\n\nconst dataProvider = new InMemoryDataProvider<UserResource>();\nconst userRepository = new UserRepository({provider: dataProvider});\n\nexport default userRepository;\n```\n\n사용자 데이터의 구조는 UserData 유형에 의해 정의되며, 리소스 구조는 UserResource 클래스에 의해 정의됩니다. 이 클래스는 id 및 data 공개 속성으로 구성되어 있습니다. 또한, creatUser 및 getUserBy 메서드는 데이터 액세스 레이어와 상호 작용하여 데이터를 검색하고 쓰기 위해 IDataProvider의 구현을 통해 사용됩니다.\n\n참고: 우리는 InMemoryDataProvider의 인스턴스를 사용하여 UserRepository의 인스턴스를 생성합니다. 나중에 데이터를 데이터베이스에 저장하려면, InMemoryDataProvider 대신 IDataProvider 인터페이스를 구현하는 다른 클래스를 사용할 수 있습니다. 우리는 이제 UserRepository를 사용하여 사용자 등록 및 로그인 API 엔드포인트의 비즈니스 논리에서 사용할 수 있습니다. 이는 다음 섹션에서 설명될 것입니다.\n\n## 1.3 사용자 등록 및 로그인을 위한 라우트\n\n다음으로, express 라우트를 모두 보관할 폴더를 생성할 것입니다. 터미널에서 아래 명령어를 입력하세요:\n\n```js\nyarn add bcrypt jwt &&\\\nyarn add @types/bcrypt @types/jwt --dev &&\\\ncd server/src &&\\\nmkdir routes &&\\\ncd ./routes &&\\\ntouch index.ts user.ts\n```\n\n알림: 추가적으로 npm 패키지 bcrypt 및 jwt를 서버 프로젝트 내에 설치했습니다. 사용자 비밀번호를 암호화하는 데 bcrypt를 사용하고, 성공적인 사용자 등록 및 로그인 요청에 대한 응답에 반환될 인증 토큰을 생성하기 위해 jwt를 사용할 것입니다. /server 내부의 폴더 구조는 아래와 같이 표시됩니다:\n\n```js\n/server\n  |__ /src\n      |__ ...\n      |__ /routes\n        |__ index.ts\n        |__ user.ts\n```\n\nindex.ts 내에서는 응용 프로그램의 모든 가능한 경로를 포함하는 중앙 라우터를 만들 것입니다. 현재는 등록 및 로그인을 위한 특정 /user 경로만 가질 것입니다.```\n\n```js\n// server/src/routes/index.ts\n\n// 전역 종속성\nimport { Router } from \"express\";\nconst router = Router();\nimport userRoute from \"./user\";\n\n// API에 대한 모든 라우트\nrouter.use(\"/user\", userRoute);\n\nexport default router;\n```\n\nuserRoute는 다음과 같이 user.ts에 구현되어 있습니다.\n\n```js\n// server/src/routes/user.ts\n\n// 전역 종속성\nconst { ENCRYPTION_KEY, AUTH_TOKEN_KEY } = process.env;\nimport {Router} from 'express';\nconst userRoute = Router();\nimport bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\n\n// 프로젝트 종속성\nimport {UserResource} from '../repositories/UserRepository';\nimport { validateHasParameters, validateEmailFormat, validatePasswordLength } from \"../middleware/validation\";\nimport userRepository from '../repositories/UserRepository';\n\n/**\n * 이메일, 비밀번호 및 이름을 입력하여 사용자 등록\n */\nuserRoute.post(\n  \"/register\",\n  validateHasParameters(\"email\", \"password\", \"name\"),\n  validateEmailFormat,\n  validatePasswordLength,\n  async (req, res) => {\n    const { name, email, password } = req.body;\n    try {\n      const userExist = await userRepository.getUserBy({id: email, matchField: 'email'});\n      if (userExist) {\n        return res.status(409).json({ error: \"User already exist\" });\n      }\n\n      const date = new Date().toISOString();\n\n      // 사용자 비밀번호 암호화\n      const passwordHash = await bcrypt.hash(password, ENCRYPTION_KEY!);\n\n      // 사용자 정보와 만료 날짜로 인증 토큰 생성\n      const userData = {\n        name: name,\n        email: email,\n        password: passwordHash,\n        createdAt: date,\n        updatedAt: date,\n      };\n      const newUser = new UserResource(userData);\n\n      // 사용자 데이터 저장\n      await userRepository.createUser(newUser);\n\n      const jwtOptions = {\n        expiresIn: '24h',  // 24시간 후 토큰 만료\n      };\n\n      const authToken = jwt.sign(newUser.data, AUTH_TOKEN_KEY!, jwtOptions);\n\n      return res.status(200).json({\n        success: true,\n        user: {\n          user_id: newUser.id,\n          email: newUser.data.email,\n          name: newUser.data.name,\n          auth_token: authToken,\n        },\n      });\n    } catch (error) {\n      console.error(error);\n      return res.status(500).json({ error: `내부 오류` });\n    }\n  }\n);\n\n/**\n * 입력된 이메일과 비밀번호를 사용하여 사용자 로그인 세션 인증\n */\nuserRoute.post(\n  \"/login\",\n  validateHasParameters(\"email\", \"password\"),\n  async (req, res) => {\n    const { email, password } = req.body;\n\n    try {\n      // 사용자 존재 여부 및 제공된 비밀번호가 올바른지 확인\n      const user = await userRepository.getUserBy({id: email, matchField: 'email'});\n      const userExists = !!user;\n      const passwordCorrect = userExists && (await bcrypt.compare(password, user.data.password));\n      if(userExists && passwordCorrect) {\n\n        const jwtOptions = {\n          expiresIn: '24h',  // 24시간 후 토큰 만료\n        };\n\n        const authToken = jwt.sign(user.data, AUTH_TOKEN_KEY!, jwtOptions);\n\n        return res.status(200).json({\n          success: true,\n          user: {\n            user_id: user.id,\n            email: user.data.email,\n            name: user.data.name,\n            auth_token: authToken,\n          },\n        });\n      }\n\n      return res.status(400).json({error: '잘못된 인증 정보'});\n    } catch (error) {\n      console.error(error);\n      return res.status(500).json({ error: `서버 오류` });\n    }\n  }\n);\n\nexport default userRoute;\n```\n\nPOST /user/register 엔드포인트에서는 요청 본문에 이름, 이메일 및 비밀번호 세 개의 매개변수를 받습니다. 사용자가 이메일을 통해 존재하는지 확인한 후, 참이면 오류를 반환합니다. 그런 다음 저장을 위해 사용자 관련 데이터 userData를 생성하며, 제공된 비밀번호는 이전에 설치한 bcrypt를 사용하여 ENCRYPTION_KEY로 암호화됩니다. 사용자 데이터의 지속성은 userRepository.createUser를 사용하여 수행하며, 사용자 생성이 성공하면 24시간 만료 기간이 있는 JWT 토큰이 초기화됩니다. JWT 토큰은 이전에 설치한 jwt를 사용하여 AUTH_TOKEN_KEY로 서명되며 사용자 관련 데이터를 포함합니다. 브라우저가 서버 응답을 받으면 이 JWT 토큰이 프론트엔드에 저장됩니다.\n\n```\n\n\n\nPOST /user/login 엔드포인트에서는 요청 본문 내 email과 password 세 개의 매개변수를 받습니다. 먼저 사용자가 실제로 존재하는지 확인하고 제공된 비밀번호가 해당 사용자 이메일에 대해 찾은 복호화된 비밀번호와 일치하는지 확인합니다. 성공적인 사용자 유효성 검사 후, 동일한 JWT 서명 프로세스가 반복됩니다.\n\n/register 및 /login 엔드포인트에 대한 사용자 입력 유효성 검사용 미들웨어도 구현했다는 것을 알았을 겁니다. 다음 명령어를 사용해 /middleware 디렉토리와 그 안에 validation.ts 파일을 생성해 보세요.\n\n```js\ncd server/src &&\\\nmkdir middleware &&\\\ntouch validation.ts\n```\n\nvalidation.ts 파일에서는 사용자 입력을 검증하기 위한 함수들을 정의할 것입니다.\n\n```js\n// server/src/middleware/validation.ts\n\nimport { NextFunction, Request, Response } from \"express\";\n\nexport const validateHasParameters = (...args: string[]) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const body = req.body;\n    let valid = true;\n\n    for (const arg of args) {\n      if (body[arg] === undefined) {\n        res.status(403).json({ error: arg + \" not specified\" });\n        valid = false;\n        break;\n      }\n    }\n\n    if (valid) {\n      next();\n    }\n  };\n};\n\nexport const validatePasswordLength = (req: Request, res: Response, next: NextFunction) => {\n  const { password } = req.body;\n  if (!!password && password.length > 7) {\n    next();\n  } else {\n    res.status(403).json({ error: \"The password provided is not valid\" });\n  }\n};\n\nexport const validateEmailFormat = (req: Request, res: Response, next: NextFunction) => {\n  const { email } = req.body;\n  const re =\n    /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  if (!!email && re.test(String(email).toLowerCase())) {\n    next();\n  } else {\n    res.status(403).json({ error: \"The email provided is not valid\" });\n  }\n};\n```\n\nvalidateHasParameter은 모든 POST 요청에 사용되며 특정 매개변수가 제출되었는지 확인합니다. validatePasswordLength 및 validateEmailFormat 미들웨어는 /user/register 엔드포인트에서 요청에 대해 유효한 비밀번호 길이와 이메일 형식을 보장하는 데 사용됩니다.\n\n마지막으로, app.ts에서 routes를 사용하여 루터를 express 앱에 연결해야 합니다. 아래에 표시된대로 routes를 파일 맨 위에서 가져오는 것에 유의하십시오.\n\n```js\n/* app.ts */\n\n// 전역 종속성\nimport * as dotenv from \"dotenv\";\ndotenv.config(); // 로컬 .env 파일을 사용하여 환경 변수 초기화\n\n// 프로젝트 종속성\nimport routes from \"./routes\";\n\n// express 앱 설정\nimport express from \"express\";\nconst app = express();\n\n// 미들웨어\napp.use(express.json());\n\n// 라우터\napp.use(routes);\n\nexport default app;\n```\n\n이제 사용자가 방금 만든 엔드포인트를 사용하여 등록하고 로그인할 수 있습니다. 다음 섹션에서는 서버 측에서 보호된 리소스에 대한 사용자 권한 추적을 다룰 것입니다.\n\n## 1.4 사용자 권한\n\n사용자 권한은 인증된 사용자가 보호된 서버 리소스에 액세스하려고 시도하는 프로세스입니다. 이를 위해서는 사용자 등록 또는 로그인 이벤트에서 생성된 토큰이 사용자 브라우저 세션에서 시작된 모든 요청에 첨부되어야 합니다. 토큰은 각 사용자의 브라우저 세션에서 사용된 AUTH_TOKEN_KEY와 같은 것으로 확인될 것입니다. 앞으로 토큰이 요청과 함께 전달되는 방법을 나준에 다룰 것이며, 지금은 서버 측에서 미들웨어 사용자 권한을 구현할 것입니다.\n\n서버/src/middleware 디렉토리 안에 auth.ts라는 추가 파일을 만들 것입니다.\n\n```js\ncd server/src/middleware && touch auth.ts\n```\n\nauth.ts 파일 안에는 들어오는 요청을 가로채고 토큰 유효성 검사 프로세스를 수행하는 checkAuthToken 미들웨어를 정의할 것입니다.\n\n```js\n// server/src/middleware/auth.ts\n\n// 전역 의존성\nimport jwt, { JwtPayload } from 'jsonwebtoken';\nconst { AUTH_TOKEN_KEY } = process.env;\n\n// 프로젝트 의존성\nimport userRepository from '../repositories/UserRepository';\n\nexport const checkAuthToken = async (req: any, res: any, next: any) => {\n  const auth_token = req.headers[\"x-access-token\"] as string;\n\n  try {\n    if (!auth_token) {\n      throw new Error('Unauthorized');\n    }\n\n    const decodedUserInfo = jwt.verify(auth_token, AUTH_TOKEN_KEY!) as JwtPayload;\n    // 사용자가 실제로 데이터베이스에 존재하는지 확인\n    const user = await userRepository.getUserBy({ id: decodedUserInfo.email, matchField: 'email' });\n    if(!user) {\n      throw new Error('Unauthorized');\n    }\n\n    req.user = {...user.data, ...decodedUserInfo};\n  } catch (error) {\n    return res.status(403).json({error: 'Unauthorized'});\n  }\n\n  return next();\n};\n```\n\n확인할 토큰은 요청 헤더 X-ACCESS-TOKEN 안에 포함될 것입니다. 추출된 토큰은 AUTH_TOKEN_KEY를 사용하여 검증되며, 해당 데이터 페이로드는 decodedUserInfo에 할당될 것입니다. 그런 다음 제출된 토큰의 유효성을 보장하기 위해 데이터 저장소에 사용자가 실제로 존재하는지 추가로 확인할 것입니다. 토큰 유효성 검사에 실패하면 403 오류 'Unauthorized' 메시지로 응답할 것입니다.```\n\n인증 논리를 테스트하려면 보호된 서버 리소스를 흉내 내는 더미 /resource API 엔드포인트를 설정할 수 있습니다. 먼저 다음 명령을 사용하여 resource.ts 파일을 만듭니다.\n\n```js\ncd server/src/routes && touch resource.ts\n```\n\nresource.ts 파일의 내용은 간단하며 단일 GET 엔드포인트로 구성되어 일부 정적 HTML을 반환합니다.\n\n```js\n// server/src/routes/resource.ts\n\nimport { Router } from \"express\";\nconst resourceRoute = Router();\n\nresourceRoute.get(\"/\", async (req, res) => {\n  return res.status(200).send(\"<h1>You have successfully access resource!</h1>\");\n});\n\nexport default resourceRoute;\n```\n\nserver/src/routes/index.ts 파일 안에 /resource 엔드포인트를 아래와 같이 추가할 수 있습니다.\n\n```js\n// server/src/routes/index.ts\n\n// 전역 의존성\nimport { Router } from \"express\";\nconst router = Router();\nimport userRoute from \"./user\";\nimport resourceRoute from \"./resource\";\nimport { checkAuthToken } from \"../middleware/auth\";\n\n// API에 대한 모든 라우트\nrouter.use(\"/user\", userRoute);\nrouter.use(\"/resource\", checkAuthToken, resourceRoute);\n\nexport default router;\n```\n\n또한 checkAuthToken 미들웨어를 import하고 /resource 엔드포인트와 연결했습니다. 이를 통해 해당 엔드포인트로 들어오는 모든 요청이 토큰 권한 부여를 위해 유효성을 검사받도록 됩니다.\n\n## 1.5 CORS 구현\n\n앞서 말한 튜토리얼의 제1부에서는 CORS 규칙이 서버에 의해 지정되어 특정 출처 도메인으로부터의 요청을 허용할 수 있도록합니다. 이를 위해 외부 패키지인 cors를 사용할 것이며, 따라서 다음 명령을 사용하여 먼저 서버 프로젝트에 추가해야합니다.\n\n```js\ncd server && yarn add cors && yarn add @types/cors --dev\n```\n\n실제 CORS 규칙은 다음과 같이 서버/src/app.ts에서 미들웨어로 지정됩니다.\n\n```js\n/* app.ts */\n\n// global dependencies\nimport * as dotenv from \"dotenv\";\ndotenv.config(); // 로컬 .env 파일을 사용하여 환경 변수를 초기화합니다.\nimport cors from \"cors\";\n\n// project dependencies\nimport routes from \"./routes\";\n\n// express 앱 설정\nimport express from \"express\";\nconst app = express();\n\n// CORS 설정\napp.use(\n  \"/\",\n  cors({\n    origin: true, // 참고: 여기서 모든 출천을 허용하고 있습니다.\n    optionsSuccessStatus: 200,\n    preflightContinue: false,\n    methods: \"GET,POST,OPTIONS\",\n    credentials: true,\n  })\n);\n\n// 미들웨어\napp.use(express.json());\n\n// 라우트\napp.use(routes);\n\nexport default app;\n```\n\n가장 중요한 설정은 origin: true로 설정해야 합니다. 이 설정은 모든 도메인에서의 요청을 허용합니다. 이 설정은 로컬 개발에 충분하지만 운영 환경에서는 프로젝트별 도메인 목록에서 요청을 허용해야 합니다.\n\n이제 서버에 필요한 모든 작업을 완료했습니다. 다음에는 사용자가 서버 애플리케이션과 상호 작용하는 방법을 보여주기 위해 프론트엔드 로그인 폼을 구현할 것입니다.\n\n# 2. 사용자 인터페이스 설정\n\n## 2.1 종속성 설치\n\n사용자 인터페이스에 대해 우리는 React 코드를 호스팅하기 위해 ./authentication-and-authorization 폴더에 별도의 폴더를 만들 것입니다:\n\n```js\nmkdir ui && cd ui\n```\n\n/ui 디렉토리 내에서 Typescript를 활성화한 React 프로젝트를 설정하기 위해 다음 명령을 실행하십시오:\n\n```js\nyarn create react-app ./ --template typescript\n```\n\n설치 프로세스가 완료되면 '/ui' 폴더 내 불필요한 파일들을 정리하고 아래에 표시된 디렉토리와 동일하게 보이도록 조정할 것입니다:\n\n```js\n/ui\n  |__ /node_modules\n      |__ ...\n  |__ /public\n      |__ favicon.ico\n      |__ index.html\n      |__ logo192.png\n      |__ logo512.png\n      |__ manifest.json\n      |__robots.txt\n  |__ /src\n      |__ App.css\n      |__ App.tsx\n      |__ index.css\n      |__ index.tsx\n      |__ react-app-env.d.ts\n  |__ .gitignore\n  |__ package.json\n  |-- README.md\n  |__ tsconfig.json\n  |__ yarn.lock\n```\n\nindex.tsx와 App.tsx에서 불필요한 코드와 잘못된 import를 제거하여 아래에 표시된 파일과 동일하게 만들어야 합니다:\n\n```js\n/* index.tsx */\n\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n```js\n/* App.tsx */\n\nimport \"./App.css\";\n\nfunction App() {\n  return <div className=\"App\">안녕</div>;\n}\n\nexport default App;\n```\n\n좋은 소식은 사용자 인터페이스에 대한 모든 설정이 완료되었으며 이제 실제 리액트 애플리케이션을 만들 준비가 되었다는 것입니다!\n\n## 2.2 전역 인증 상태 관리\n\n어플리케이션이 동작하려면 인터페이스가 사용자의 인증 상태에 대해 알아야 합니다. 이를 React Context와 useReducer 훅을 사용하여 전역 상태로 관리할 것입니다. 먼저 ui/src/ 안에 전역 인증 상태를 위한 스토어 디렉토리를 생성합니다:\n\n```\n\n\n\n```js\ncd ui/src &&\\\nmkdir store &&\\\ncd store && mkdir auth &&\\\ntouch authAction.ts AuthContextProvier.tsx authReducer.ts\n```\n\nauthAction.ts는 사용자가 인터페이스 내에서 트리거할 수 있는 가능한 액션을 포함하고 있습니다:\n\n```js\n/* ui/src/store/auth/authActions.ts */\n\nexport enum AuthActionEnum {\n  LOG_IN = 'LOG_IN',\n  LOG_OUT = 'LOG_OUT',\n};\n\nexport type AuthAction = {\n  type: AuthActionEnum.LOG_IN,\n  payload: {\n    authToken: string;\n    userId: string;\n    email: string;\n    name: string;\n  }\n} | {\n  type: AuthActionEnum.LOG_OUT,\n  payload: null,\n}\n```\n\nauthReducer.ts 내부에서는 인증 관련 액션을 해당 상태로 매핑하는 리듀서를 생성할 것입니다:\n\n```js\n/* ui/src/store/auth/authReducer.ts */\n\nimport { Reducer } from \"react\";\nimport { AuthAction } from \"./authActions\";\n\nexport interface AuthState {\n  isLoggedIn: boolean;\n  authToken?: string;\n  userId?: string;\n  name?: string;\n  email?: string;\n}\n\nexport const defaultAuthState: AuthState = {\n  isLoggedIn: false,\n};\n\nconst authReducer: Reducer<AuthState, AuthAction> = (state, action) => {\n  // 사용자가 성공적으로 인증되면\n  if (action.type === \"LOG_IN\") {\n    localStorage.setItem(\"user\", JSON.stringify(action.payload));\n    return {\n      ...state,\n      isLoggedIn: true,\n      authToken: action.payload.authToken,\n      userId: action.payload.userId,\n      name: action.payload.name,\n      email: action.payload.email,\n    };\n  }\n\n  // 사용자 로그아웃\n  if (action.type === \"LOG_OUT\") {\n    localStorage.removeItem(\"user\");\n    return defaultAuthState;\n  }\n\n  return defaultAuthState;\n};\n\nexport default authReducer;\n```\n\n기본 상태는 false로 설정된 하나의 필드인 isLoggedIn으로 구성됩니다. 사용자가 인증을 한 번하면 리듀서는 LOG_IN 액션을 처리하고 사용자 관련 정보를 localStorage에 유지하며 새 인증 상태를 반환하여 동일한 정보를 유지합니다. 사용자 정보를 계속 유지해야 하는 이유는 사용자가 페이지를 나가고 나중에 방문할 때 인증 상태가 유지되어야 하기 때문입니다. LOG_OUT 액션은 리듀서에 의해 처리되어 모든 상태 및 저장된 사용자 정보가 기본 값으로 재설정됩니다.\n\n이제 액션과 리듀서가 정의되었으므로 AuthContextProvider.tsx에서 전체 응용 프로그램에 인증 상태를 제공하는 컨텍스트 제공자 구성 요소를 만듭니다:\n\n```js\n/* ui/src/store/auth/AuthContextProvider.tsx */\n\n// 전역 가져오기\nimport React, { createContext, useReducer, useCallback, useEffect } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\n// 프로젝트 종속성\nimport { AuthActionEnum } from \"./authActions\";\nimport authReducer, { AuthState, defaultAuthState } from \"./authReducer\";\n\ntype AuthProviderProps = {\n  children: React.ReactElement,\n};\n\nexport type UserData = {\n  authToken: string,\n  userId: string,\n  name: string,\n  email: string,\n};\n\nexport interface AuthContext {\n  authState: AuthState;\n  globalLogInDispatch: (props: UserData) => void;\n  globalLogOutDispatch: () => void;\n}\n\n// Auth 컨텍스트\nconst authCtx =\n  createContext <\n  AuthContext >\n  {\n    authState: defaultAuthState,\n    globalLogInDispatch: () => {},\n    globalLogOutDispatch: () => {},\n  };\n\nexport const AuthContextProvider = (props: AuthProviderProps) => {\n  const { children } = props;\n\n  const [authState, authDispatch] = useReducer(authReducer, defaultAuthState);\n  const navigate = useNavigate();\n\n  // 사용자 세부 정보가 지속되는지 확인, 대부분 브라우저 새로 고침에 대응\n  useEffect(() => {\n    const user = localStorage.getItem(\"user\");\n    if (user) {\n      const userData: UserData = JSON.parse(user);\n      authDispatch({ type: AuthActionEnum.LOG_IN, payload: userData });\n    }\n  }, []);\n\n  const globalLogInDispatch = useCallback(\n    (props: UserData) => {\n      const { authToken, email, name, userId } = props;\n      authDispatch({\n        type: AuthActionEnum.LOG_IN,\n        payload: {\n          authToken,\n          userId,\n          name,\n          email,\n        },\n      });\n      navigate(\"/resource\");\n    },\n    [navigate]\n  );\n\n  const globalLogOutDispatch = useCallback(() => {\n    authDispatch({ type: AuthActionEnum.LOG_OUT, payload: null });\n    navigate(\"/user/login\");\n  }, [navigate]);\n\n  // 하위 컴포넌트로 전달할 컨텍스트 값\n  const ctx = {\n    authState,\n    globalLogInDispatch,\n    globalLogOutDispatch,\n  };\n\n  return <authCtx.Provider value={ctx}>{children}</authCtx.Provider>;\n};\n\nexport default authCtx;\n```\n\nAuthContextProvider 컴포넌트는 authState 및 관련 디스패치 메서드를 authCtx 컨텍스트 내의 모든 자식 컴포넌트에 제공하는 Higher Order Component (HOC)입니다. globalLogInDispatch와 globalLogOutDispatch 함수는 각각 LOG_IN 및 LOG_OUT 액션을 리듀서에 디스패치하여 인증 상태를 업데이트하는 데 사용됩니다. 인증 액션이 디스패치될 때 해당 경로로 이동하기 위해 react-router-dom도 사용하고 있습니다. 마지막으로, 사용자가 이전에 로그인했는지 여부를 확인하고 필요할 경우 localStorage에 저장된 정보를 찾아 LOG_IN 액션을 디스패치하는 useEffect 훅을 정의했습니다.\n\n마지막 단계는 index.tsx에서 애플리케이션을 AuthContextProvider로 래핑하여 컨텍스트를 제공하는 것입니다.\n\n```js\n/* index.tsx */\n\nimport ReactDOM from 'react-dom/client';\nimport React from 'react';\nimport './index.css';\nimport App from './App';\nimport { BrowserRouter } from 'react-router-dom';\nimport { AuthContextProvider } from './store/auth/AuthContextProvider';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <AuthContextProvider>\n        <App />\n      </AuthContextProvider>\n    </BrowserRouter>\n  </React.StrictMode>\n);\n```\n\n## 2.3 서버와 통신하기\n\n인증 상태 관리가 완료되었으니 이제 내부 메모리 데이터베이스에서 사용자 데이터를 검색해야 하는 서버와의 통신에 집중해 봅시다. 이를 위해 React 컴포넌트에서 서버 엔드포인트를 요청하는 논리를 모두 재사용할 수 있도록 useApi라는 커스텀 훅을 생성할 것입니다. ui/src 내부에 코드를 호스팅할 수 있는 관련 파일이 있는 hooks 폴더를 만들어 보겠습니다:\n\n```js\ncd ui/src && mkdir hooks && cd hooks &&\\\nmkdir api && cd api &&\\\ntouch apiData.ts useApi.ts\n```\n\napiData.ts 파일에는 사용자 로그인 및 등록 이벤트에 대한 서버에서 반환될 데이터 구조가 포함되어 있습니다:\n\n```js\n/* ui/src/hooks/api/apiData.ts */\n\nexport type AuthData = {\n  success: boolean,\n  user: {\n    user_id: string,\n    email: string,\n    name: string,\n    auth_token: string,\n  },\n};\n```\n\nuseApi.ts 파일에는 서버와 통신하기 위한 커스텀 훅이 들어 있어요:\n\n```js\n/* ui/src/hooks/api/useApi.ts */\n\n// 전역 의존성\nimport { useState, useCallback, useContext } from \"react\";\n\n// 프로젝트 의존성\nimport AuthContext from \"../../store/auth/AuthContextProvider\";\n\nconst BASE_URL = \"http://localhost:8000\";\n\nconst useApi = () => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const { authState, globalLogOutDispatch } = useContext(AuthContext);\n\n  const request = useCallback(\n    async (\n      endpoint: string,\n      params: { [key: string]: any },\n      handleSuccessResponse: (data: any) => void,\n      handleErrorResponse?: (error: Error) => void\n    ) => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        // NOTE: 사용자가 로그인 중이면 요청 헤더에 auth 토큰 삽입\n        if (authState.isLoggedIn) {\n          params.headers[\"x-access-token\"] = authState.authToken;\n        }\n\n        const response = await fetch(BASE_URL + endpoint, { ...params });\n        if (!response.ok) {\n          const data = await response.json(); // 항상 json 응답을 가정\n          throw new Error(data.error);\n        }\n        const data = await response.json(); // 항상 json 응답을 가정\n\n        // 응답이 정상적이고 오류가 없는 경우, 성공 응답 처리\n        handleSuccessResponse && (await handleSuccessResponse(data));\n      } catch (error: any) {\n        // NOTE: 권한이 없는 오류인 경우 사용자 로그아웃\n        if (error && error.message && error.message === \"Unauthorized\") {\n          globalLogOutDispatch();\n        }\n\n        // 지정된 오류 처리\n        if (handleErrorResponse) {\n          handleErrorResponse(error.message || error.error || error);\n        } else {\n          setError(error.message || error.error || error);\n        }\n      }\n\n      setLoading(false);\n    },\n\n    [authState.isLoggedIn, authState.authToken, globalLogOutDispatch]\n  );\n\n  return {\n    loading: loading,\n    error: error,\n    request: request,\n    setError: setError,\n  };\n};\n\nexport default useApi;\n```\n\nuseApi 훅은 request 함수 내에서 fetch 요청을 보내는 것을 담당하고 있어요. 전역 인증 상태를 통해 사용자가 로그인했는지 먼저 확인하고, 사용자가 인증되면 요청 헤더 x-access-token에 authToken을 첨부합니다. 이 토큰은 요청과 함께 전송되어 서버가 사용자가 특정 리소스에 액세스할 권한이 있는지 확인할 수 있게 해줍니다. 또한, 커스텀 훅은 요청-응답 사이클 및 오류 처리의 상태 관리도 관리합니다. 서버에서 성공적인 응답을 받았다면 handleSuccessResponse 콜백을 통해 데이터를 처리하고, 응답이 실패한 경우 handleErrorResponse 콜백을 통해 오류를 처리합니다. 응답 오류에 \"Unauthorized\" 메시지가 있으면 globalLogOutDispatch 함수를 트리거하여 사용자 인증 상태를 재설정합니다.\n\n## 2.4 인증 구성 요소\n\n우리 애플리케이션의 모든 비즈니스 로직을 완료했고, 이제 화면 인터페이스를 작업할 차례입니다. 먼저 React 컴포넌트를 호스팅할 폴더를 만들어봅시다:\n\n```js\ncd ui/src && mkdir components &&\\\ncd components && mkdir auth &&\\\ntouch Auth.tsx LogInForm.tsx RegisterForm.tsx validations.ts\n```\n\n먼저, LogInForm.tsx와 RegisterForm.tsx에서 각각 로그인 및 사용자 등록을 위한 양식 컴포넌트를 생성해보겠습니다:\n\n```js\n/* ui/src/components/auth/LoginForm.tsx */\n\nimport { FormEventHandler } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport styles from \"./Auth.module.css\";\n\ntype Props = {\n  onSubmit: FormEventHandler<HTMLFormElement>,\n};\n\nconst LoginForm = (props: Props) => {\n  const { onSubmit } = props;\n  return (\n    <form onSubmit={onSubmit} className={styles.Form}>\n      <div className={styles.Input}>\n        <label htmlFor=\"email\">이메일</label>\n        <input id=\"email\" name=\"email\" type=\"email\" required placeholder=\"이메일 주소\" />\n      </div>\n      <div className={styles.Input}>\n        <label htmlFor=\"password\">비밀번호</label>\n        <input id=\"password\" name=\"password\" type=\"password\" required placeholder=\"비밀번호\" />\n      </div>\n      <button type=\"submit\">제출</button>\n      <Link className={styles.Link} to={\"/user/register\"}>\n        아직 계정이 없으신가요? 가입하기\n      </Link>\n    </form>\n  );\n};\n\nexport default LoginForm;\n```\n\n```js\n/* ui/src/components/auth/RegisterForm.tsx */\n\nimport { FormEventHandler } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport styles from \"./Auth.module.css\";\n\ntype Props = {\n  onSubmit: FormEventHandler<HTMLFormElement>,\n};\n\nconst RegisterForm = (props: Props) => {\n  const { onSubmit } = props;\n  return (\n    <form onSubmit={onSubmit} className={styles.Form}>\n      <div className={styles.Input}>\n        <label htmlFor=\"name\">이름</label>\n        <input id=\"name\" name=\"name\" type=\"text\" required placeholder=\"전체 이름\" />\n      </div>\n      <div className={styles.Input}>\n        <label htmlFor=\"email\">이메일</label>\n        <input id=\"email\" name=\"email\" type=\"email\" required placeholder=\"이메일 주소\" />\n      </div>\n      <div className={styles.Input}>\n        <label htmlFor=\"password\">비밀번호</label>\n        <input id=\"password\" name=\"password\" type=\"password\" required placeholder=\"비밀번호\" />\n      </div>\n      <button type=\"submit\">제출</button>\n      <Link className={styles.Link} to={\"/user/login\"}>\n        이미 계정이 있으신가요? 로그인하기\n      </Link>\n    </form>\n  );\n};\n\nexport default RegisterForm;\n```\n\n두 양식은 각각 이름, 이메일과 비밀번호 속성을 포함한 폼 제출 이벤트를 처리할 콜백 프롭인 onSubmit을 전달받습니다.\n\n그 다음으로, Auth.tsx에서 사용자 브라우저 내의 네비게이션 경로에 따라 LogInForm 또는 RegisterForm 구성 요소 중 하나를 표시할 컴포넌트를 만들겠습니다:\n\n```js\n/* ui/src/components/auth/Auth.tsx */\n\n// 전역 imports\nimport { useEffect, useState, useContext, FormEventHandler } from \"react\";\n\n// 프로젝트 의존성\nimport useApi from \"../../hooks/api/useApi\";\nimport AuthContext from \"../../store/auth/AuthContextProvider\";\nimport { validatePasswordLength, validateEmailFormat } from \"./validations\";\nimport { AuthData } from \"../../hooks/api/apiData\";\nimport { useLocation } from \"react-router-dom\";\nimport LoginForm from \"./LoginForm\";\nimport RegisterForm from \"./RegisterForm\";\n\nconst Auth = () => {\n  const [authData, setAuthData] = useState<AuthData>();\n  const { request, setError } = useApi();\n  const { globalLogInDispatch } = useContext(AuthContext);\n  const location = useLocation();\n  const currentPathArray = location.pathname.split('/');\n  const isLogin = currentPathArray[currentPathArray.length - 1] === 'login';\n\n  // 로그인 사용자에 대한 api 응답 성공 시, 전역 auth LOG_IN 이벤트를 디스패치합니다\n  useEffect(() => {\n    if (authData && \"success\" in authData) {\n      globalLogInDispatch({\n        authToken: authData.user.auth_token,\n        userId: authData.user.user_id,\n        name: authData.user.name,\n        email: authData.user.email,\n      });\n    }\n  }, [authData, globalLogInDispatch]);\n\n  const authHandler: FormEventHandler<HTMLFormElement> = async (event) => {\n    event.preventDefault();\n    const data = new FormData(event.currentTarget);\n    // 먼저 유효성 검사!\n    const userEmail = data.get(\"email\");\n    const userPassword = data.get(\"password\");\n    const userName = data.get(\"name\");\n    try {\n      if (\n        !validateEmailFormat(userEmail?.toString() || \"\") ||\n        !validatePasswordLength(userPassword?.toString() || \"\")\n      ) {\n        throw new Error(\"잘못된 자격 증명 형식입니다!\");\n      }\n      const params = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email: userEmail,\n          password: userPassword,\n          name: userName,\n        }),\n      };\n\n      const endpoint = `/user/${isLogin ? 'login' : 'register'}`\n      await request(endpoint, params, setAuthData);\n    } catch (error: any) {\n      setError(error.message || error);\n    }\n  };\n\n  return (\n    <>\n      <h2>{isLogin ? '로그인' : '가입하기'}</h2>\n      {\n        isLogin\n          ? <LoginForm onSubmit={authHandler} />\n          : <RegisterForm onSubmit={authHandler} />\n      }\n    </>\n  );\n};\n\nexport default Auth;\n```\n\n우리는 react-router-dom에서 제공하는 useLocation을 사용하여 사용자가 브라우저에서 어떤 경로에 있는지 추출합니다. 경로에 따라, LoginForm 또는 RegisterForm을 표시하도록 선택합니다. 각 폼에 대한 onSubmit 핸들러는 authHandler에 정의된 대로 작동하며, 이 핸들러는 양식 제출 이벤트에서 모든 입력 폼 속성을 추출하고 서버에서 사용자/로그인 또는 사용자/등록 엔드포인트를 요청하기 전에 이를 유효성 검사합니다.\n\n양식 제출 이벤트에 대한 유효성 검사 로직은 기본적이며 아래 validation.ts에서 보여진 것과 같습니다:\n\n```js\n/* ui/src/components/auth/validations.ts */\n\nexport const validatePasswordLength = (password: string) => {\n  return !!password && password.length > 7;\n};\n\nexport const validateEmailFormat = (email: string) => {\n  const re =\n    /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  return !!email && re.test(String(email).toLowerCase());\n};\n```\n\n## 2.5 Resource component\n\n마지막으로 만들 인터페이스 구성 요소는 보호된 리소스 경로를 시뮬레이션하는 더미 페이지입니다. 코드를 호스팅할 폴더를 만들기 위해 먼저 다음 명령어를 실행하세요:\n\n```js\ncd ui/src/components &&\\\nmkdir resource &&\\\ncd resource &&\\\ntouch Resource.tsx\n```\n\nResource.tsx 파일 내부에 아래와 같이 구성 요소를 생성할 것입니다:\n\n```js\n/* ui/src/components/resource/Resource.tsx */\n\nimport { useCallback, useContext, useEffect, useState } from \"react\";\nimport useApi from \"../../hooks/api/useApi\";\nimport authCtx from \"../../store/auth/AuthContextProvider\";\nimport styles from \"./Resource.module.css\";\n\nconst Resource = () => {\n  const [data, setData] = useState();\n  const { request, setError } = useApi();\n  const { globalLogOutDispatch } = useContext(authCtx);\n\n  const fetchData = useCallback(async () => {\n    try {\n      const params = {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      };\n      await request(\"/resource\", params, (result) => {\n        setData(result.data);\n      });\n    } catch (error: any) {\n      setError(error.message || error);\n    }\n  }, [request, setError]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return (\n    <div className={styles.Resource}>\n      <h1>{data}</h1>\n      <button onClick={globalLogOutDispatch}>로그아웃</button>\n    </div>\n  );\n};\n\nexport default Resource;\n```\n\n이 컴포넌트는 간단하며 useEffect 훅을 사용하여 서버의 /resource 엔드포인트로 호출하는 로직으로 구성되어 있습니다. 이 호출에는 pre-existing auth 토큰이 필요합니다. 반환된 데이터는 페이지에 표시되며 로그아웃 버튼을 클릭하면 auth 컨텍스트에서 globalLogOutDispatch를 트리거하여 전역 auth 상태를 재설정합니다.\n\n## 2.6 모든 것을 연결하기\n\n인터페이스 애플리케이션을 위한 비즈니스 로직과 프레젠테이션 컴포넌트를 작성했으니, App.tsx에서 react-router-dom을 사용하여 프론트엔드 라우팅을 통해 모든 것을 연결해보겠습니다 :\n\n```js\n/* ui/src/App.tsx */\n\nimport \"./App.css\";\nimport { Route, Routes, Navigate, useLocation } from \"react-router-dom\";\nimport AuthContext from \"./store/auth/AuthContextProvider\";\nimport { useContext } from \"react\";\nimport Resource from \"./components/resource/Resource\";\nimport Auth from \"./components/auth/Auth\";\n\nfunction App() {\n  const { authState } = useContext(AuthContext);\n  const location = useLocation();\n\n  return (\n    <div className=\"App\">\n      <Routes>\n        <Route path=\"/\" element={<Navigate to={authState.isLoggedIn ? location.pathname : \"/user/login\"} />} />\n        {!authState.isLoggedIn && (\n          <Route path=\"user\">\n            <Route path=\"register\" element={<Auth />} />\n            <Route path=\"login\" element={<Auth />} />\n          </Route>\n        )}\n        {authState.isLoggedIn && <Route path=\"resource\" element={<Resource />} />}\n      </Routes>\n    </div>\n  );\n}\n\nexport default App;\n```\n\nApp.tsx 파일 내에서는 지금 애플리케이션의 모든 라우팅이 구성되어 있습니다. /user/register, /user/login 및 /resource로 구성되어 있습니다. 컨텍스트에서 제공된 전역 인증 상태가 사용자가 인증된 상태를 나타내면 사용자에게 /resource 경로에 액세스할 수 있도록 허용하여 해당 서버의 엔드포인트로 이동하여 'protected' 데이터를 표시합니다.\n\n# 결론\n\n이 글에서는 풀스택 인증 시스템을 구현하는 데 필요한 기능을 만들었습니다. 인증 방법은 토큰 기반 방식으로, 이는 이 튜토리얼 시리즈의 첫 번째 글에서 논의되었습니다. 애플리케이션의 각 구성 요소에 대해 많은 세부 정보를 다뤘지만, 아직 할 일이 많습니다. 예를 들어 다음과 같은 작업을 수행할 수 있습니다:\n\n- 프론트엔드 애플리케이션의 스타일링 개선, 이 리포지토리에서 설정한 기본 스타일링을 가져올 수 있습니다.\n- 프론트엔드 및 백엔드에서 적절한 사용자 입력 유효성 검사, SQL 인젝션 방지 또는 데이터 유형 유효성 검사와 같은 작업.\n- 잘못된 자격 증명을 제출했을 때 사용자 경험을 향상시키기 위한 에러 처리.\n- 실제 데이터베이스를 구축하여 사용자 데이터 저장.\n- AWS 또는 GCP와 같은 클라우드 제공 업체를 사용하여 애플리케이션을 컨테이너화하고 배포.\n\n나머지는 네가 알아서 해주면 돼! 그리고 언제든지 애플리케이션을 개선하거나 다른 방법으로 작업할 수 있는 좋은 제안이 있다면 댓글을 남겨줘! 이 튜토리얼의 최종 코드는 여기서 확인할 수 있어.\n","ogImage":{"url":"/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_0.png"},"coverImage":"/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_0.png","tag":["Tech"],"readingTime":39},{"title":"프로젝트에 따라 Nodejs의 올바른 버전으로 자동 전환하기","description":"","date":"2024-05-12 19:36","slug":"2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject","content":"\n\nNode.js 개발의 끊임없이 변화하는 풍경 속에서는 다양한 프로젝트 요구 사항과 호환성 문제를 관리하는 것이 부담스러운 작업일 수 있습니다. 이 기사에서는 프로젝트의 요구 사항에 기반하여 Node.js의 올바른 버전으로 자동 전환하는 컨셉을 탐구합니다.\n\nNVM이란 무엇인가요?\nNVM, Node Version Manager, 여러 개의 Node.js 설치를 시스템에서 원활하게 관리하는 데 사용되는 go-to 솔루션입니다. 다양한 Node.js 버전 요구 사항을 가진 여러 프로젝트에서 작업하는 개발자이거나 최신 기능과 업데이트를 탐구하고 싶어하는 열정적인 사용자라면, NVM은 몇 가지 간단한 명령어로 다양한 Node.js 버전 간에 간편하게 전환할 수 있도록 해줍니다.\n\nNVM GitHub 레포지토리에서 예시를 확인해보세요\n\n```js\n$ nvm use 16\nNow using node v16.9.1 (npm v7.21.1)\n$ node -v\nv16.9.1\n$ nvm use 14\nNow using node v14.18.0 (npm v6.14.15)\n$ node -v\nv14.18.0\n$ nvm install 12\nNow using node v12.22.6 (npm v6.14.5)\n$ node -v\nv12.22.6\n```\n\n\n\n.nvmrc이 무엇인가요?\n\nNode.js 생태계에서 .nvmrc 파일은 Node Version Manager(nvm)에서 사용되는 간단한 구성 파일입니다. 이 파일은 일반적으로 프로젝트의 루트 디렉토리에 위치하며 해당 프로젝트에서 작업할 때 사용해야 하는 특정 Node.js 버전을 지정합니다.\n\n![사진](/assets/img/2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject_0.png)\n\n.nvmrc 파일 만들기 및 사용하기\n\n\n\n\"`.nvmrc` 파일을 만들고 사용하는 것은 매우 간단합니다.\n\n1. 프로젝트 디렉토리로 이동합니다.\n\n2. `.nvmrc`라는 새 파일을 만들고 원하는 노드 버전을 입력합니다.\n\n여기 샘플 내용 파일이 있습니다.\"\n\n\n\n```js\nv18.18.2\n```\n\n3. 터미널에서 nano ~/.bashrc를 입력하여 .bashrc를 엽니다.\n\n4. 이 코드를 .bashrc 파일 끝에 붙여넣고 저장하세요.\n\n```js\n# .nvmrc 파일이 있으면 .nvmrc의 노드 버전을 사용합니다.\n\n# 터미널이 시작될 때 호출\nif [[ -f .nvmrc ]]\nthen\n  nvm use\nfi\n\n# cd 명령어를 통해 디렉토리가 변경될 때 호출\nfunction cd() {\n builtin cd \"$@\"\n  if [[ -f .nvmrc ]]\n  then\n    nvm use\n  fi\n}\n```\n\n\n\n5. 컴퓨터를 다시 부팅하거나 터미널에서 다음 명령어를 입력하여 다시 시작하세요: source .bashrc\n\n6. 이제 .nvmrc 파일이 있는 디렉토리에서 터미널을 열 때마다 터미널이 노드 버전을 자동으로 전환할 것입니다.\n\n이것은 .nvmrc 파일이 있는 모든 프로젝트에 대해 작동할 것입니다.\n\n요약하자면, 다음에 프로젝트를 시작할 때 .nvmrc 파일을 생성하고 버전 관련 문제를 해결하세요.","ogImage":{"url":"/assets/img/2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject_0.png"},"coverImage":"/assets/img/2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject_0.png","tag":["Tech"],"readingTime":2},{"title":"리플렛js와 리액트로 시작하기 간단한 지도 렌더링하기","description":"","date":"2024-05-12 19:34","slug":"2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap","content":"\n\n![Leaflet.js와 React를 사용하여 간단한 지도 렌더링 시작하기](/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png)\n\n# 소개\n\n이 시리즈에서는 강력한 오픈 소스 JavaScript 라이브러리인 Leaflet.js를 활용하여 React, HTML 및 CSS로 Google 지도 대안으로 상호 작용하는 지도를 생성하는 방법을 살펴볼 것입니다. 주니어 또는 중급 개발자라면 Leaflet.js 사용 방법을 이해함으로써 위치 데이터를 표시하고 사용자 정의 맵 기반 애플리케이션을 쉽게 구축할 수 있습니다. 이 첫 번째 글에서는 개발 환경을 설정하고 기본적인 지도를 렌더링하는 것부터 시작하겠습니다.\n\n이후의 글에서는 대화식 맵핑의 세계로 더욱 깊이 파고들어, 마커 추가, 부드러운 확대 기능 활성화, 클릭 이벤트 처리, 외부 데이터 작업 및 다각형 및 팝업 사용자 정의 등의 주제를 다룰 것입니다.\n\n\n\n이 튜토리얼과 더 나아가기 위해 다음 도구들을 활용할 것입니다:\n\n- Leaflet\n인터랙티브 지도를 생성하는 JavaScript 라이브러리\n- React\n사용자 인터페이스를 구축하는 JavaScript 라이브러리\n- React-Leaflet\nLeaflet 지도용 React 컴포넌트들\n\n# Leaflet은 무엇인가요?\n\nLeaflet.js는 오픈 소스이며 가벼운 JavaScript 라이브러리로, 웹을 위한 인터랙티브 지도를 손쉽게 만들 수 있습니다.\n\n\n\n약 38,000개의 스타를 보유한 Leaflet.js는 휴대폰 친화적 대화형 지도를 위한 주요 오픈 소스 JavaScript 라이브러리 중 하나입니다.\n\n만약 \"Leaflet\"이라는 이름의 유래에 대해 궁금하다면, 이것은 단편적이고, 표시하고, 지도를 손쉽게 탐색할 수 있도록 도와주는 편리한 도구로 생각해보세요 - 마치 바람에 흩날리는 나뭇잎처럼 손쉽게 움직일 수 있습니다.\n\nLeaflet을 선택하는 이유는?\n\n- 가볍고 빠름: 개발자들이 Leaflet을 좋아하는 주요 이유 중 하나는 가벼운 무게에 있습니다 - 약 42KB의 무게를 상하. 웹 페이지가 무거운 스크립트에 늘어지지 않도록 보장하여 부드럽고 신속한 사용자 경험을 제공합니다.\n- 사용자 친화적이고 직관적: Leaflet의 API는 명쾌하고 직관적이어서 모든 수준의 개발자에게 완벽히 적합합니다. 경험이 풍부한 전문가든 막 시작한 초심자든 쉽게 이해하고 구현할 수 있을 것입니다.\n- 사용자 정의 가능 및 다재다능: Leaflet은 가볍지만 강력한 기능을 제공합니다! 당신의 특정 요구에 맞게 지도를 맞춤화하기 위해 원활하게 통합할 수 있는 다양한 플러그인과 확장기능을 제공합니다. 마커 및 폴리곤 표시부터 상호작용 처리까지, 가능성은 거의 무한합니다.\n- 크로스 플랫폼 호환성: Leaflet으로 생성한 지도는 다양한 플랫폼과 장치에서 어려움 없이 볼 수 있습니다. 사용자가 데스크톱, 스마트폰 또는 태블릿에서 애플리케이션을 접근하더라도, 지도는 아름답게 작동할 것입니다.\n- 활발한 커뮤니티 및 지속적인 개발: 열정적이고 활발한 개발자 및 기여자들의 커뮤니티로 Leaflet은 계속 발전하고 개선되고 있습니다. 업데이트, 버그 수정 및 흥미로운 새로운 기능이 정기적으로 출시되어 당신이 최신의 지도 기술을 선도하도록 보장합니다.\n\n\n\n리플렛은 웹 페이지에서 지도를 렌더링하기 위해 HTML, CSS, 및 JavaScript를 조합하여 사용합니다. 최신 브라우저의 강력한 기능을 활용하며 OpenStreetMap, Mapbox 및 기타 인기 있는 맵 제공업체를 활용하여 다양한 스타일과 데이터 오버레이를 가진 지도를 표시할 수 있습니다.\n\n재미있는 사실: 리플렛의 \"잎\" 로고!\n\n리플렛의 재미있는 잎 로고를 본 적이 있을 지도 모릅니다. 귀여운 외양 뿐만 아니라 라이브러리의 가벼운 특성을 상징합니다. 마치 단 한 잎이 바람에 가볍게 나부끼는 것처럼, 리플렛의 최소주의 디자인은 사용자에게 부드럽고 빠른 지도 상호작용을 제공합니다.\n\n\n\n이제 Leaflet.js의 마법을 소개했으니, 소마건을 걸고 React와 함께 재미있는 상호작용 맵핑의 흥미진진한 세계에 뛰어들어 봅시다. 함께 멋진 지도 애플리케이션을 만들어 사용자에게 오랫동안 기억에 남는 경험을 선사하며 이 학습 여정을 즐겨봅시다!\n\n멋진 모험을 지도에 표현할 준비가 되셨나요? 시작해 봅시다!\n\n그런데..\n\nReact로 들어가기 전에, 일반적인 html, css 및 js를 통해 Leaflet의 기본을 이해해 봅시다. 이를 위해 Leaflet 지도를 설정하고, 마커 및 팝업을 사용하는 간단한 예제를 만들 것입니다.\n\n\n\n# Leaflet 라이브러리로 단순한 HTML, CSS 및 JS 예제 만들기\n\n이 섹션에서는 Leaflet.js 라이브러리를 포함한 간단한 HTML 페이지를 만들고, 기본 지도를 렌더링하고 마커 및 팝업을 추가하는 방법을 보여줄 것입니다.\n\n단계 1: HTML 구조 설정\n\n좋아하는 텍스트 편집기를 열고 새 HTML 파일(예: index.html)을 만들고 기본 구조를 설정하세요:\n\n\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>간단한 Leaflet 지도</title>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\" />\n  <style>\n    /* 지도 컨테이너 크기 설정 */\n    #map {\n      height: 400px;\n      width: 100%;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"map\"></div>\n  <script src=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\"></script>\n  <script src=\"app.js\"></script>\n</body>\n</html>\n```\n\nStep 2: JavaScript 파일 생성 (app.js)\n\n다음으로, HTML 파일과 동일한 디렉토리에 'app.js'라는 새 JavaScript 파일을 만듭니다. 여기에 지도를 렌더링하고 마커 및 팝업을 추가하는 코드를 작성할 것입니다.\n\n```js\n// 문서가 준비되기를 기다립니다.\ndocument.addEventListener('DOMContentLoaded', function () {\n  // 맵 인스턴스를 생성하고 초기 뷰 좌표 및 확대 수준을 설정합니다.\n  var map = L.map('map').setView([51.505, -0.09], 13);\n\n  // OpenStreetMap으로부터 지도에 타일 레이어 추가\n  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n  }).addTo(map);\n\n  // 팝업이 있는 마커를 생성하고 지도에 추가합니다.\n  var marker = L.marker([51.505, -0.09]).addTo(map);\n  marker.bindPopup(\"안녕하세요, 저는 마커입니다!\").openPopup();\n});\n```\n\n| Name      | Age | Location |\n|-----------|-----|----------|\n| John      | 25  | New York |\n| Emily     | 28  | Paris    |\n| Matthew   | 23  | London   |\n\n\n지도 만들기 및 타일 레이어 추가하기\n\n```js\n// 지도 인스턴스 생성 및 초기 보기 좌표 및 확대 수준 설정\nvar map = L.map('map').setView([51.505, -0.09], 13);\n```\n\n여기서 `L.map()` 메서드를 사용하여 새 지도 인스턴스를 생성하고 우리의 지도가 렌더링될 `div` 요소의 ID를 전달했습니다.\n\n`setView()` 메서드는 맵의 초기 보기를 지정한 위도(51.505) 및 경도(-0.09)와 확대 수준 13으로 설정합니다. 확대 수준이 높을수록 지도가 더 가깝게 표시됩니다.\n\n\n\n```js\n// 지도에 OpenStreetMap에서 타일 레이어 추가\nL.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\nattribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n}).addTo(map);\n타일 레이어의 attribution 옵션은 OpenStreetMap 기여자들에게 크레딧을 주기 위해 사용됩니다. 제3자 소스에서 지도 데이터를 사용할 때 적절한 소유권을 제공하는 것이 중요합니다.\n```\n\n위 코드에서 L.tileLayer() 메서드를 사용하여 타일 레이어를 생성했습니다.\n\n타일 레이어는 지도의 시각적 표현을 구성하는 이미지 타일 세트입니다. 이 예에서는 https://'s'.tile.openstreetmap.org/'z'/'x'/'y'.png로 제공되는 OpenStreetMap 타일 레이어를 사용하고 있습니다. 's', 'z', 'x', 'y'는 서브도메인, 줌 레벨 및 타일 좌표를 나타내는 자리 표시자입니다. Leaflet은 자동으로 이러한 자리 표시자를 교체하여 지도를 이동하고 확대/축소할 때 올바른 타일을 로드합니다.\n\n타일 레이어의 attribution 옵션은 OpenStreetMap 기여자들에게 크레딧을 주기 위해 사용됩니다. 제3자 소스에서 지도 데이터를 사용할 때 적절한 소유권을 제공하는 것이 중요합니다.\n\n\n\n팝업이 달린 마커 추가하기\n\n```js\n// 팝업이 달린 마커를 생성하고 맵에 추가하기\nvar marker = L.marker([51.505, -0.09]).addTo(map);\nmarker.bindPopup(\"안녕하세요, 저는 마커입니다!\").openPopup();\n```\n\n맵에 마커를 추가하려면 L.marker() 메소드를 사용하고 위도와 경도를 배열 [51.505, -0.09]로 전달합니다. 이로 인해 마커가 맵의 해당 위치에 배치됩니다.\n\n그런 다음 bindPopup() 메소드를 사용하여 마커에 팝업을 추가합니다. 팝업 내용은 \"안녕하세요, 저는 마커입니다!\" 라는 문자열입니다. 그리고 openPopup() 메소드를 사용하여 팝업을 마커가 맵에 추가된 직후에 바로 표시합니다.\n\n\n\n다른 타일 레이어 사용하기\n\nLeaflet은 지도의 외관과 스타일을 변경할 수 있는 다양한 타일 레이어를 제공합니다. OpenStreetMap 이외에도 Mapbox, Stamen, Esri 등 다른 제공 업체를 사용할 수 있습니다.\n\nMapbox 타일 레이어를 사용하는 예시입니다:\n\n```js\n// Mapbox 타일 레이어 사용하기\nL.tileLayer('https://{s}.tiles.mapbox.com/v4/{mapId}/{z}/{x}/{y}.png?access_token={accessToken}', {\n  attribution: '© <a href=\"https://www.mapbox.com/about/maps/\">Mapbox</a>',\n  mapId: 'your-mapbox-map-id', // 여러분의 Mapbox 맵 ID로 대체해주세요\n  accessToken: 'your-mapbox-access-token' // 여러분의 Mapbox 액세스 토큰으로 대체해주세요\n}).addTo(map);\n```\n\n\n\nMapbox 타일 레이어를 사용하려면 Mapbox 계정에 가입하고 액세스 토큰과 맵 ID를 획득해야 합니다. 'your-mapbox-map-id'와 'your-mapbox-access-token'을 실제 Mapbox 자격 증명으로 대체해주세요.\n\n# React-Leaflet\n\n이제 Leaflet과 순수 JavaScript를 사용하여 지도를 생성하고 마커를 추가하는 방법을 알게 되었습니다. React를 사용하여 동일한 결과를 어떻게 얻을 수 있는지 알아봅시다.\n\n필수 전제 조건\n\n\n\n리액트 구현에 들어가기 전에 컴퓨터에 다음이 설치되어 있는지 확인하세요:\n\n- Node.js (최신 LTS 버전) 및 npm (Node Package Manager)\n- 선호하는 코드 편집기 (예: Visual Studio Code, Sublime Text, 또는 Atom)\n\n개발 환경 설정하기\n\n먼저 터미널이나 명령 프롬프트를 열고 다음 단계를 따르세요:\n\n\n\n- Create React App을 사용하여 새로운 React 프로젝트를 만들어보세요:\n\n```\nnpx create-react-app leaflet-map-app\n\ncd leaflet-map-app\n```\n\n2. 필요한 종속성을 설치하세요:\n\n\n\nnpm install leaflet\n\nnpm install react-leaflet\n\n3. 이제 코드 편집기에서 프로젝트를 엽니다.\n\n간단한 지도 컴포넌트 생성\n\n\n\n프로젝트의 'src' 폴더에 'SimpleMap.js'라는 새 파일을 만들어 주세요. 이 파일은 맵을 렌더링하는 주요 리액트 컴포넌트가 될 거에요.\n\n맵 설정하기\n\nSimpleMap.js 안에서 필요한 모듈을 먼저 import 하는 것으로 시작해요:\n\n```js\nimport React, { useRef } from \"react\";\nimport { MapContainer, TileLayer } from \"react-leaflet\";\nimport \"leaflet/dist/leaflet.css\";\n```\n\n\n\n지도 렌더링하기\n\n이제 SimpleMap 컴포넌트를 구현하고 지도를 렌더링합시다:\n\n```js\nconst SimpleMap = () => {\n  const mapRef = useRef(null);\n  const latitude = 51.505;\n  const longitude = -0.09;\n\n  return ( \n    // 지도 컨테이너의 높이와 너비를 설정해야지만 지도가 표시됩니다.\n      <MapContainer center={[latitude, longitude]} zoom={13} ref={mapRef} style={{height: \"100vh\", width: \"100vw\"}}>\n        <TileLayer\n          attribution='&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n          url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        />\n        {/* 추가 지도 레이어나 컴포넌트를 이곳에 추가할 수 있습니다 */}\n      </MapContainer>\n  );\n};\n\nexport default SimpleMap;\n```\n\n중요 사항!\n\n\n\n\nMapContainer center='[위도, 경도]' zoom='13' ref='mapRef' style='높이: \"100vh\", 너비: \"100vw\"'\n\nMapContainer의 높이와 너비를 설정하지 않으면 지도가 렌더링되지 않습니다.\n\nmapRef 사용 이유:\n\nuseRef로 mapRef를 사용하면 React-Leaflet이 관리하는 Leaflet 지도 인스턴스에 직접 액세스할 수 있습니다. 이는 표준 속성이나 이벤트 처리의 범위를 벗어나야 하는 작업을 수행해야 할 때 특히 유용합니다. 예를 들어 지도와 상호 작용하거나 지도의 중심을 동적으로 업데이트하거나 Leaflet의 기본 API에 직접 액세스해야 할 수 있습니다.\n```\n\n\n\nmapRef을 사용하면 맵 인스턴스를 더 많은 제어력과 유연성을 가질 수 있어요. 이는 응용 프로그램에서 더 고급 맵 기능이나 상호 작용을 구현할 때 유용해요.\n\n다음 기사에서 더 자세히 살펴보겠습니다.\n\nMapContainer 구성 요소\n\nMapContainer는 첫 번째 예제와 같이 맵을 위한 `div` 요소 컨테이너를 렌더링합니다.\n\n\n\nMapContainer이 DOM에 렌더링되는 방법:\n\nJSX 코드에 MapContainer 컴포넌트를 포함하면, 다른 React 컴포넌트와 마찬가지로 DOM에 렌더링됩니다. 그러나 MapContainer와 일반 HTML 요소 사이에 중요한 차이가 있습니다:\n\nReact-Leaflet은 내부적으로 Leaflet의 코어 라이브러리를 사용하여 DOM을 직접 조작하여 지도를 렌더링합니다. MapContainer 컴포넌트가 DOM에 렌더링되면, 지정된 높이와 너비로 `div` 요소가 생성되는데, 이는 지도의 컨테이너 역할을 합니다.\n\n초기 렌더링 후에 React가 가상 DOM의 변경 사항을 조정할 때, Leaflet의 코어 라이브러리가 제어를 가져와 맵의 모양과 업데이트를 효율적으로 관리하면서 React 컴포넌트를 전체 재렌더링시키지 않습니다. 이 접근 방식은 상호작용 형식의 맵을 다룰 때 빈번한 업데이트가 필요한 경우에 최적의 성능을 보장합니다.\n\n\n\n모든 것을 함께 적용하기\n\nApp.js 파일에서 SimpleMap 컴포넌트를 import하여 주요 응용 프로그램에서 사용합니다:\n\n```js\nimport React from 'react';\nimport SimpleMap from './SimpleMap';\n\nfunction App() {\n  return (\n    <div>\n      <h1>내 Leaflet.js 및 React 지도</h1>\n      <SimpleMap />\n    </div>\n  );\n}\nexport default App;\n```\n\n프로젝트 디렉토리에서 npm install을 실행하여 필요한 패키지를 설치해야 합니다. 모든 것이 설정되면 npm start로 개발 서버를 실행하고 브라우저에서 http://localhost:3000을 방문하여 지도를 확인할 수 있습니다.\n\n\n\n아래는 Markdown 형식으로 테이블을 변경한 결과입니다.\n\n```\n<img src=\"/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_2.png\" />\n\n# React-Leaflet의 한계\n\nReact-Leaflet은 상호작용적 지도를 만드는 데 훌륭한 도구이지만 몇 가지 재미있는 한계가 있습니다.\n```\n\n\n\nLeaflet은 로드될 때 DOM에 직접 호출을 하기 때문에 React Leaflet은 서버 측 렌더링과 호환되지 않습니다.\n\n노출된 구성 요소는 Leaflet 레이어의 추상화이며 DOM 요소가 아닙니다. 일부 구성 요소는 Leaflet에서 노출된 세터를 호출하여 직접 업데이트할 수 있는 프로퍼티를 가지고 있으며, 다른 구성 요소는 key 프로퍼티에 고유한 값이 설정되어 React의 알고리즘이 정확히 처리할 수 있도록 완전히 대체되어야 합니다.\n\n이러한 도전을 극복하기 위해 개발자들은 다양한 접근 방식을 사용해 왔습니다. 예를 들어:\n\n- 조건부 렌더링: 일반적인 접근 방식 중 하나는 Leaflet 구성 요소를 클라이언트 측에서만 조건부로 렌더링하는 것입니다. 동적 임포트 또는 useEffect 훅과 같은 기술을 사용하여 초기 렌더링 후 클라이언트에서만 실행되도록 보장합니다.\n- Leaflet-Headless: 일부 개발자들은 Leaflet의 headless 버전인 \"leaflet-headless\"와 같이 Leaflet의 headless 버전을 만들어 왔습니다. 이를 통해 DOM 없이 서버에서 Leaflet 지도를 렌더링할 수 있습니다. 그러나 이러한 해결책은 제한 사항을 가질 수 있으며 Leaflet의 모든 기능을 제공하지 않을 수도 있습니다.\n\n\n\nNext.js에서 조건부 렌더링의 예 및 간단한 해결책입니다:\n\n```js\nimport dynamic from 'next/dynamic'\n\nfunction HomePage() {\n  const Map = dynamic(\n    () => import('@components/map'), // 컴포넌트 위치인 '@components/map'을 교체해주세요\n    { \n      loading: () => <p>지도를 불러오는 중입니다</p>,\n      ssr: false // 이 줄이 중요합니다. 서버 측 렌더링을 막습니다\n    }\n  )\n  return <Map />\n}\n\nexport default HomePage\n```\n\n# 공식 문서 자세히 살펴보기\n\n더 많은 고급 사용 사례를 탐색하거나 React-Leaflet 컴포넌트의 속성과 기능에 대해 더 깊이 파고들고 싶다면, 공식 문서를 참조해보세요! 이 문서에는 Leaflet을 React 애플리케이션 내에서 최대한 활용할 수 있도록 가능한 모든 컴포넌트, 옵션, 특징에 대한 포괄적인 정보가 제공되어 있습니다.\n\n\n\n문서 링크: React-Leaflet 공식 문서\n\n# GitHub에서 코드 살펴보기\n\n코드를 탐험하고 지도 뒤에 숨겨진 마법을 확인하고 싶다면, 이 기사 시리즈의 전체 소스 코드가 GitHub에서 사용 가능합니다! 🚀🔍\n\nGitHub에서 코드를 확인해보세요\n\n\n\n자유롭게 살펴보고 실험하며 예제를 활용해보세요. 코딩 즐기세요! 🌟🖥️\n\n# 결론\n\n이 시리즈의 첫 번째 기사를 완료한 것을 축하합니다! 저는 개발자 기사를 쓰고 지식을 공유하는 이 여정에 기쁨을 느낍니다. Leaflet.js와 React를 함께 사용하면 쉽게 대화형 지도를 생성할 수 있어 구글 맵에 대한 무료이면서 강력한 대안을 제공합니다.\n\n다음 기사에서는 지도에 마커 추가 및 부드러운 확대 기능을 가능하게 함으로써 대화형 매핑의 세계로 더 깊이 들어갈 것입니다. 함께 하면 주니어 및 중급 개발자가 지도 시각화 기술을 마스터하기 위해 가치 있는 풍부한 애플리케이션을 만들 수 있을 것입니다.\n\n\n\n우리가 다룰 다가오는 주제들에 대해 정말 기대돼요. 여러분들도 마찬가지겠죠? 이 시리즈를 통해, 개발자들이 새로운 기술을 탐험하고 창의력을 발휘하여 멋진 애플리케이션을 만들도록 돕고 영감을 주는 것이 제 목표입니다.\n\n이 여정에 함께해 주셔서 감사드리고, 다음 시리즈를 여러분과 함께 나누는 것을 기대할 뿐입니다. 즐겁게 코딩하시고, 다음에 뵙겠습니다!","ogImage":{"url":"/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png"},"coverImage":"/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png","tag":["Tech"],"readingTime":12},{"title":"Reactforce를 사용하는 것이 좋은 아이디어라고 생각하는 ChatGPT세요","description":"","date":"2024-05-12 19:32","slug":"2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea","content":"\n\n다음 글은 ChatGPT가 쓴 것입니다:\n\n![image](/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png)\n\n나: \"salesforce.com에 웹사이트를 배포하는 데 React를 사용하는 장점에 관한 글을 써 주세요.\"\n\nChatGPT:\n\n\n\n# Salesforce에서 웹 배포를 향상시키기 위한 React 활용: IT 임원을 위한 안내서\n\n## EXECUTIVE SUMMARY\n\n기업 기술 분야의 경쟁적 환경에서 IT 임원들은 지속적으로 효율성과 혁신을 향상시키는 전략을 모색하고 있습니다. Salesforce.com과 React를 통합함으로써 복잡한 비즈니스 요구에 부합하는 강력하고 확장 가능한 웹사이트를 배포하는 혁신적인 방법론을 제시합니다. 본 기사는 Salesforce에서 웹 배포를 위해 React를 활용하는 전략적 이점에 대해 다루며 비즈니스 영향과 관리적 통찰을 강조합니다.\n\n## 전략적 개발 장점\n\n\n\n1. 구성 요소 중심의 효율성: React의 구성 요소 기반 구조는 재사용 가능한 코드를 촉진하여 개발 시간과 비용을 줄이며 Salesforce 애플리케이션 전체에서 일관성을 보장합니다. 이 모듈식 접근 방식은 기민한 개발 방법을 용이하게 하여 IT 팀이 비즈니스 요구 사항의 변화에 신속히 대응할 수 있도록 합니다.\n\n2. 간소화된 개발 및 유지 관리: JSX를 활용하여 코딩하는 것은 개발 프로세스를 단순화하여 컨셉에서 배포까지 걸리는 시간을 크게 줄입니다. React의 아키텍처는 미래 업데이트와 유지 보수를 간소화하기도 하며, 비즈니스 영향을 최소화하면서 장기적 기업 애플리케이션을 유지하는 데 중요한 역할을 합니다.\n\n## 사용자 참여 및 성능 향상\n\n3. 고성능 웹사이트: React의 가상 DOM은 웹사이트 성능을 최적화하여 기업 환경에서 일반적인 대규모 데이터셋을 처리하는 데 중요합니다. 이는 더 빠르고 반응적인 웹 애플리케이션을 통해 사용자 만족도와 참여도를 향상시킵니다.\n\n\n\n4. Salesforce Lightning과의 원활한 통합: React를 Salesforce Lightning과 조율함으로써 기관은 생산성과 사용자 도입을 향상시키는 통합 사용자 경험을 누릴 수 있습니다. 이 조합은 비즈니스 사용자를 위한 강력한 인터페이스를 제공하며 Salesforce의 강력한 백엔드 기능을 React의 동적 프론트엔드 기능과 결합합니다.\n\n## 확장성 및 기업 성장\n\n5. 확장 가능한 솔루션: React의 유연성은 비증분 솔루션을 지원하여 비즈니스와 함께 성장할 수 있습니다. 기능을 확장하거나 새로운 서비스를 통합하거나 더 많은 사용자를 수용하기 위해 확장하는 경우, React를 Salesforce와 결합함으로써 웹 인프라가 효율적으로 적응할 수 있도록 보장합니다.\n\n6. 커뮤니티 및 혁신: React의 광범위한 개발자 커뮤니티와 풍부한 생태계를 활용하면 Salesforce 배치에 첨단 혁신을 가져올 수 있습니다. 이러한 다양한 도구 및 라이브러리에 접근하는 것은 개발을 가속화하고 기업의 과제에 첨단 솔루션을 제공할 수 있습니다.\n\n\n\n## 결론\n\n디지털 생태계 내에서 가능한 경계를 넓히려는 IT 임원들에게는 Salesforce 웹사이트 배포를 위해 React를 도입하는 것이 전략적 이점을 제공합니다. 이 조합은 개발을 간소화하고 사용자 경험을 향상시키는 데에 그치지 않고 비즈니스 성장 및 적응성 목표와도 일치합니다. React를 받아들임으로써 기업은 비즈니스 성공을 이끄는 더 매력적이고 성능이 우수하며 확장 가능한 웹 솔루션을 만들 수 있습니다.\n\n## 행동 요령\n\n조직의 웹 전략에 대한 다음 단계를 고려할 때, Salesforce와 React 통합의 잠재적인 영향을 곰곰히 생각해보세요. 이 기술을 귀사의 특정 비즈니스 요구에 맞게 맞춤화하는 방법에 대해 깊이 있게 탐구하려면 귀사의 기업 맥락에 맞춘 통찰력과 실행 전략을 제공할 수 있는 전문가와 상담을 고려해 보세요.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n\n\n## 전략적 개발 장점 (내 생각)\n\n나는 React의 컴포넌트 프레임워크와 미리 만들어진 컴포넌트의 오픈 소스 제공이 Lightning의 동일한 개념보다 훨씬 선두라고 제안할 것입니다. 차이를 알기 위해 둘 다 배워야 하지만... 그저 요약하자면: React = Best\n\n또한 React 개발 과정이 극적으로 더 나은 것에 동의합니다. 당사의 Reactforce 솔루션에는 여기에 약간의 비밀 소스가 있습니다.... 개발에서 Hot Reloading을 지원하고 Salesforce 환경에 오프라인 프록시 액세스도 지원합니다. 이는 개발 워크스테이션에서 로컬로 실행되는 React 서버에서 Salesforce 스크래치 조직(또는 샌드박스)에서 라이브 데이터를 사용하여 React 앱을 구축할 수 있다는 것을 의미합니다. 이것은 React 및 Salesforce 개발자들에게 자랑스럽게 보여주는 소프트웨어 마술입니다.\n\n위 기사에서 ChatGPT가 실제로 이해하지 못하는 것은 React 사이트를 네이티브 Salesforce.com 조직에 배포함으로써, 데이터의 다수 복사본을 관리하기 위해 필요한 모든 데이터 통합, 변환 및 지속적인 지원을 우회하고 있다는 점입니다. React는 JavaScript remoting 또는 LWC 컨트롤러를 통해 Salesforce에 직접적으로 대화하며, 데이터웨어하우스나 운영 데이터 저장소로 미들웨어를 통해 고통스럽게 연결된 중요한 데이터뿐만 아니라 Salesforce 데이터 중 어떤 것이든지 솔루션을 구축하는 놀라운 속도와 유연성을 제공합니다.\n\n\n\n## 사용자 참여 및 성능 향상 (내 생각)\n\nReact에 익숙하지 않다면, 대부분의 사람들이 사용한다는 것만 말씀드립니다. 마이크로소프트 팀즈는 React로 작성되었습니다. Netflix와 지라도 마찬가지입니다. 끝이 없이 많이 있습니다. React로 작성된 웹사이트를 언제든지 표시해주는 크롬 확장 프로그램을 설치할 수 있습니다. 제가 직접 수행한 완전히 비과학적인 연구에 의하면, 가장 빠르고 시각적으로 매력적이며 반응성 있는 사이트 대부분은 대부분 React를 사용하고 있습니다.\n\nReact는 Salesforce Lightning과 비교할 수조차 없습니다. React는 단일 페이지 애플리케이션으로, 전체 사이트가 처음 로드될 때 브라우저로 다운로드됩니다. 애플리케이션은 브라우저로 푼다음 Salesforce (또는 원하는 데이터 소스)로 API 호출을 수행합니다. 단일 페이지 애플리케이션 (SPA)의 최종 결과는 브라우저가 거의 다시로드하지 않고 전체 사이트가 잘 만들어진 iOS 앱처럼 느껴진다는 것입니다. 웹 개발 세계에서 오신 분이라면 이것이 상당히 명백한 사실일 것입니다. Salesforce에서 오신 분이라면... 무엇을 놓치고 있는지 꼭 확인해보세요.\n\nReactforce에는 Salesforce 내부에서는 물론 Classic 또는 Lightning 경험 내에서도 절대적으로 매끈하게 작동하는 React의 비밀 소스가 있습니다. 더 나아가 전체 응용 프로그램을 완전히 렌더링하는 경우(예: 디지털 커뮤니티 경험)에 사용할 때 더욱 우수한 결과를 얻을 수 있습니다. 우리는 React를 사용하여 Salesforce.com에서 네이티브로 호스팅되는 금융 서비스 및 의료 포털을 구축하는 전문가입니다. 대안솔루션과의 차이는 즉시 눈에 띄며, 전체 솔루션에 대해 배울수록 혜택만 커집니다.\n\n\n\n## 확장성 및 기업 성장 (내 생각)\n\nSalesforce에서 실행 중인 React의 확장성에는 몇 가지 기술적 고려 사항이 있습니다. 먼저, React 앱이 페이지 레이아웃에서 내부적으로 실행되는지 아니면 외부적으로 커뮤니티에서 실행되는지에 따라 솔루션이 변경됩니다. 내부에서 실행할 때는 Javascript 리모팅을 사용하여 API 호출을 완전히 우회할 수 있습니다. 이것은 React에서 데이터베이스로 무제한 API 호출을 할 수 있다는 것을 의미합니다. React 앱을 내부적으로 렌더링하고 이 능력을 활용하기 위해 원격 메서드나 라이트닝 컨트롤러를 사용해야합니다.\n\n커뮤니티에서 React 앱을 외부에서 렌더링하는 경우에도 페이지 뷰(원격 메서드 및 Ajax 호출이 페이지 뷰로 계산됨)에 주의해야합니다. 우리는 규모에 맞게 외부 API 호출에 React를 사용하는 것이 비용 효율적인 대안임을 발견했습니다. Salesforce에서 필요한 API 호출을 구매하고, 예전에 고민했던 대부분의 확장성 문제에 대해서는 더 이상 생각하지 않아도 됩니다.\n\n기업은 React를 열렬히 환영할 것입니다. React 앱은 자가 포함되어 배포될 수 있으며 배포된 Salesforce 환경의 모든 보안 규칙을 존중합니다. 이는 혁신적인 창작물을 매우 빠르게 반복할 수 있음을 의미합니다. 또는 Reactforce Enterprise Portal(현재 베타)을 사용하여 회사 인트라넷 또는 익스트라넷을 철저한 솔루션으로 구성할 수 있습니다. 이 솔루션에는 완전히 사용자 정의 가능한 사용자 관리, 고급 경로 구성, 다양한 사이트 테마도 포함되어 있습니다. 마치 당신의 포털을 위한 포털 같아요. 이 애플리케이션에 대해 자랑스럽다고 생각하며, 몇 달 내에 일반 사용자에게 제공될 것으로 기대합니다.\n\n\n\n## 챗지피티(ChatGPT)가 아직은 이해하지 못하는 것들\n\nUI 계층으로 React를 채택하면 CRM 생태계에서 아직은 이해되지 않는 성숙함과 세련됨의 수준을 조직에 제공합니다. 이는 귀하의 직원, 파트너, 그리고 고객들에게 실제로 사용하고 싶어하는 UI 경험을 제공합니다.\n\n웹사이트의 백엔드로 Salesforce를 활용하면 견고하고 확장 가능하며 거의 제로 서포트 솔루션을 제공받을 수 있습니다. Salesforce의 놀라운 데이터베이스와 기업 보안 솔루션에 액세스할 수 있습니다. 귀하의 애플리케이션은 CIO들과 세계 각지의 아키텍트들이 사랑하고 존경하는 안전하고 견고한 인프라에 배포되면서 즉시 귀하의 고객들과 프로젝트 이해관계자들에게 감명을 줄 것입니다.\n\n## 내 인간적 요약\n\n\n\n재밌는 이유가 많아요! Salesforce에서 React를 사용해보는 것을 고려해볼 가치가 충분해요. 사실 저는(15년 경험의 Salesforce.com 및 AWS 전문 기술 아키텍트) 그냥 말하는 게 아니에요. ChatGPT도 이 솔루션이 얼마나 멋진지 아는 것 같아요. 더 많은 정보를 원한다면 직접 이메일 보내주세요: greg@cloudpremise.com.\n\n해피 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png"},"coverImage":"/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png","tag":["Tech"],"readingTime":6}],"page":"81","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":14,"currentPageGroup":4},"__N_SSG":true}