{"pageProps":{"posts":[{"title":"React 19 다가오는 변화에 대비하세요","description":"","date":"2024-05-12 21:09","slug":"2024-05-12-React19GetReadyForWhatsComing","content":"\n\n![React 19](/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png)\n\n리액트 19, 어떤 경우에도 공개될 수 있고, 모든 리액트 개발자들이 사용하고 싶어할 것입니다. 왜냐하면 최신 버전이 훨씬 더 나아졌기 때문이죠. 다가올 변화 중 일부를 살펴보겠습니다.\n\n## 리액트 컴파일러: 리액트 핵심 최적화\n\n오랫동안, 리액트 개발자들은 useMemo, useCallback, memo 훅을 활용하여 애플리케이션을 최적화하고 불필요한 다시 렌더링을 방지했습니다. 이로 인해 종종 어색한 코드가 만들어지곤 했는데, 이를 더 우아한 해결책을 찾게끔 할 것이라는 리액트 개발팀이 약속했습니다.\n\n\n\n그래서 정확히 그것이 React 19에서 제공되는 것입니다: 새로운 React 컴파일러. 이 컴파일러는 코드를 분석하여 상태 변경이 발생할 때 UI의 어떤 부분을 다시 렌더링해야 하는지 결정함으로써 React의 렌더링 프로세스를 자동으로 최적화하는 데 설계되었습니다.\n\nReact 컴파일러가 간단한 컴포넌트를 어떻게 최적화하는지 예시를 살펴봅시다:\n\n```js\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment</button>\n    </div>\n  );\n}\n```\n\nReact 컴파일러 없이 count 상태를 업데이트하면 `button` 요소를 포함한 전체 컴포넌트가 다시 렌더링됩니다. 그러나 해당 내용과 동작이 변경되지 않는 한 개선 없이 렌더링됩니다. 반면에 React 컴파일러를 사용하면 count를 보여주는 `p` 요소만 다시 렌더링되어 성능이 향상되고 오버헤드가 감소합니다.\n\n\n\n## 작업: 데이터 처리 간소화\n\n리액트 컴파일러에 추가로, 리액트 19에서는 Actions라는 강력한 새로운 기능이 소개되었습니다.\n\nActions를 사용하면 `form`과 같은 DOM 요소에 함수를 전달하여 폼 제출, 데이터 변이 및 기타 데이터 관련 작업을 손쉽게 처리할 수 있습니다. 아래는 예시입니다:\n\n```js\nimport React from 'react';\n\nfunction SearchForm({ action }) {\n  return (\n    <form action={action}>\n      <input name=\"query\" />\n      <button type=\"submit\">검색</button>\n    </form>\n  );\n}\n\nfunction App() {\n  const search = async (data) => {\n    const response = await fetch(`/api/search?q=${data.query}`);\n    const results = await response.json();\n    // 검색 결과로 UI 업데이트\n  };\n\n  return <SearchForm action={search} />;\n}\n```\n\n\n\n이 예시에서 SearchForm 컴포넌트는 액션 prop을 받습니다. 이 prop은 폼이 제출될 때 실행될 함수입니다. App 컴포넌트는 검색 함수를 정의합니다. 이 함수는 서버로 fetch 요청을 보내고 응답을 처리합니다.\n\n액션은 클라이언트 측에서 표준 JavaScript를 사용하여 또는 `use server` 지시문을 사용하여 서버에서 정의할 수 있습니다. React는 데이터 제출의 라이프사이클을 관리하며, useFormStatus 및 useActionState와 같은 훅을 제공하여 폼 액션의 현재 상태와 응답에 액세스할 수 있습니다.\n\n기본적으로, 액션은 전환 내에서 제출되어 현재 페이지를 상호작용적으로 유지합니다. React 19에서는 전환 내에서 async/await를 사용하여 비동기 요청이 진행 중일 때 대기 중 UI를 보여줄 수 있는 기능도 소개되었습니다.\n\n액션을 보완하는 것은 useOptimistic 훅입니다. 이 훅을 사용하면 개발자가 낙관적인 상태 업데이트를 관리할 수 있습니다. 이 훅을 사용하면 임시 업데이트가 적용되고 최종 상태가 확정되면 자동으로 되돌립니다. 이 기능을 사용하면 낙관적 UI 업데이트를 할 수 있으며, 제출이 성공하면 서버에서 제공된 데이터로 자연스럽게 되돌아갈 수 있습니다.\n\n\n\n## React 서버 구성 요소: 서버 측 렌더링을 더욱 진보시키다.\n\nReact 19에서 가장 기대되는 기능 중 하나는 React Server Components (RSC)의 도입입니다.\n\nRSC를 사용하면 개발자는 `use server` 지시어를 사용하여 특정 구성 요소를 \"서버\" 구성 요소로 표시할 수 있습니다. 이러한 구성 요소는 서버에서 렌더링되어 정적 HTML로 클라이언트로 스트리밍되어 초기 JavaScript 페이로드를 줄이고 성능을 향상시킵니다.\n\n다음은 RSC를 사용하는 예시입니다:\n\n\n\n```jsx\n// PostContent.server.jsx\nimport React, { useState, useEffect } from 'react';\nimport fetchPost from './fetchPost';\n\nexport default async function PostContent({ id }) {\n  const [post, setPost] = useState(null);\n\n  useEffect(() => {\n    const fetchPostData = async () => {\n      const postData = await fetchPost(id);\n      setPost(postData);\n    };\n    fetchPostData();\n  }, [id]);\n\n  if (!post) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  );\n}\n```\n\n이 예제에서 PostContent 컴포넌트는 .server.jsx 파일 확장자를 사용하여 서버 컴포넌트로 표시됩니다. 서버에서 렌더링될 때 fetchPost 함수가 실행되고 결과로 나온 게시물 데이터가 정적 HTML로 렌더링되어 클라이언트로 스트리밍됩니다.\n\nRSC와 액션을 결합하면 클라이언트 및 서버 환경에서 일관된 프로그래밍 모델로 풀 스택 앱을 만들 수 있습니다.\n\n## 리액트 개발의 미래를 받아들이기\n\n\n\nReact 19 컴파일러는 렌더링 프로세스를 대폭 가속화하고 불필요한 다시 렌더링을 줄일 것입니다. Meta Devs가 릴리스하는 내용을 항상 주시하시고 큰 날을 위해 준비하세요.\n\n출처: React Labs: 우리가 작업 중인 내용 — 2024년 2월 — React\n\n# 평문으로 간단히 🚀\n\nIn Plain English 커뮤니티의 일부로 함께해 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 작가에게 박수를 보내고 팔로우를 눌러주세요! 👏\r\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\r\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\r\n- 알고리즘 컨텐츠를 다루도록 강요하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!\r\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요.","ogImage":{"url":"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png"},"coverImage":"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 19의 새로운 기능 - 새로운 리액트 훅","description":"","date":"2024-05-12 21:07","slug":"2024-05-12-NewFeaturesinReact19NewReactHooks","content":"\n\n🚀 React 19의 새로운 시대를 탐험하다: 혁명적인 훅의 일단 봐 🌟\n\n![이미지](/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png)\n\n안녕하세요, React 팬 여러분! 우리의 컴포넌트와 상호 작용하는 방법을 재정의할 새로운 훅이 등장하는 React 19의 미래로 여행을 떠나 봅시다. React Hooks의 팬이라면, 놀라운 일이 기다리고 있어요!\n\nReact Hooks의 진화:\n\n\n\n리액트 훅스는 처음 소개된 이후로 게임 체인저 역할을 했어요. 상태 관리와 라이프사이클 메서드를 간편하게 만들어주죠. 만약 리액트의 내장 훅을 사용하거나 사용자 정의 훅을 만들었다면, 당신의 애플리케이션에 가져다주는 힘과 유연성을 고맙게 느낄 거예요.\n\n리액트 19에서는 useMemo, forwardRef, useEffect, useContext의 사용 방법이 바뀔 거에요. 이는 새로운 훅, use가 소개되기 때문이죠.\n\nuseMemo()로 간단한 메모이제이션:\n\n주목할만한 변경 중 하나는 useMemo() 훅의 단순화입니다. 리액트 19 이후에는 useMemo()을 명시적으로 사용할 필요가 없어요. 새 리액트 컴파일러가 메모이제이션을 자동으로 처리할 거예요. 이는 더 깨끗한 코드와 향상된 성능을 가져다줘요. 아래 예시에서 보여드릴게요:\n\n\n\nReact 19 이전:\n\n```js\nimport React, { useState, useMemo } from 'react';\n\nfunction ExampleComponent() {\n  const [inputValue, setInputValue] = useState('');\n\n  // 입력 값이 비어 있는지 확인 결과를 메모이제이션합니다\n  const isInputEmpty = useMemo(() => {\n    console.log('입력 값이 비어 있는지 확인 중...');\n    return inputValue.trim() === '';\n  }, [inputValue]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      />\n      <p>{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}</p>\n    </div>\n  );\n}\n\nexport default ExampleComponent;\n```\n\nReact 19 이후:\n\n```js\nimport React, { useState } from 'react';\n\nfunction ExampleComponent() {\n  const [inputValue, setInputValue] = useState('');\n\n  const isInputEmpty = () => {\n    console.log('입력 값이 비어 있는지 확인 중...');\n    return inputValue.trim() === '';\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      />\n      <p>{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}</p>\n    </div>\n  );\n}\n\nexport default ExampleComponent;\n```\n\n\n\n아래 예제에서 확인할 수 있듯이 React19 이후에는 값에 memo를 적용할 필요가 없습니다. React19에서는 이 기능을 자체적으로 처리합니다. 코드가 훨씬 깔끔해졌죠.\n\nforwardRef()로 리팩터링:\n\nReact 19에서 forwardRef()를 사용하는 컴포넌트를 리팩터링하는 것은 간단해졌습니다. forwardRef()를 사용하는 대신 ref를 직접 속성으로 전달할 수 있으며, 코드의 복잡성을 줄일 수 있습니다:\n\n```js\n// React 19 이전\nconst ExampleButton = forwardRef((props, ref) => (\n  <button ref={ref}>\n    {props.children}\n  </button>\n));\n\n// React 19 이후\nconst ExampleButton = ({ ref, children }) => (\n  <button ref={ref}>\n    {children}\n  </button>\n);\n```\n\n\n\n새로운 'use' Hook을 소개합니다:\n\nReact 19에서 가장 흥미로운 추가 기능은 'use' 훅인데요, 이를 통해 우리는 약속, 비동기 코드 및 컨텍스트를 다루는 방법을 단순화할 수 있습니다. 이 훅은 다음 예시에서 보여지는 것처럼 더 깔끔하고 간결한 코드를 작성할 수 있습니다:\n\n```js\nconst users = use(fetchUsers());\n```\n\n'use' 훅을 통해 비동기 작업 및 컨텍스트를 처리하는 새로운 가능성을 엽니다.\n\n\n\n아래 코드는 fetch 요청이 ne \"use\" 훅과 함께 처리되는 방법을 보여줍니다.\n\n```js\nimport { use } from \"react\";\n\nconst fetchUsers = async () => {\n    const res = await fetch('https://jsonplaceholder.typicode.com/users');\n    return res.json();\n};\n\nconst UsersItems = () => {\n    const users = use(fetchUsers());\n\n    return (\n        <ul>\n            {users.map((user) => (\n                <div key={user.id} className='bg-blue-50 p-2 my-4 rounded-lg'>\n                    <h2 className='text-xl font-bold'>{user.name}</h2>\n                    <p>{user.email}</p>\n                </div>\n            ))}\n        </ul>\n    );\n};\n\nexport default UsersItems;\n```\n\n이 코드는 다음과 같은 방식으로 작동합니다: fetchUsers 함수가 GET 요청을 처리합니다.\nuse 훅을 사용하여 fetchUsers 함수를 실행합니다. useEffect나 useState 훅을 사용하는 대신에 사용합니다.\nuseState 훅의 반환값은 사용자가 될 것이고, 이는 GET 요청의 응답(사용자)을 갖게 됩니다.\nreturn 블록에서는 사용자를 사용하여 매핑하고 목록을 생성합니다.\n\n새로운 훅을 사용할 수 있는 다른 곳은 Context입니다. React에서 Context API는 외부 상태 관리 라이브러리를 필요로하지 않고 컴포넌트 전체에서 전역 상태를 효과적으로 관리하는 강력한 방법을 제공합니다. use 훅의 도입으로 Context 작업이 더욱 간단해졌습니다.\n\n\n\n표 태그를 마크다운 형식으로 변경하세요.\n\n\n\n두 번째 예시는 테이블 태그가 아닌 HTML5로 렌더링된 SVG이미지를 사용하는 방법입니다. HTML5의 캔버스 요소를 사용하여 그래픽을 생성하고 작업할 수 있습니다. 이 예시에서는 표시되는 SVG이미지와 사용된 JavaScript 코드를 확인할 수 있습니다.\n\n\n\n```js\nconst { status } = useFormStatus()\n```\n\npending: Form이 보류 상태에 있으면 true가 되고, 그렇지 않으면 false가 됩니다.\ndata: parent `form`이 제출하는 데이터가 포함된 FormData 인터페이스를 구현한 객체입니다.\nmethod: HTTP 메소드 — GET 또는 POST. 기본적으로 GET일 것입니다.\naction: 함수 참조\n\nuseFormStatus()를 사용하여 Form 제출 상태에 따라 UI를 업데이트하는 반응형 Form을 만들 수 있습니다.\n\n다음은 코드 예시입니다:```\n\n\n\n```js\nimport { useFormStatus } from \"react-dom\";\n\nfunction Submit() {\n  const status = useFormStatus();\n  return <button disabled={status.pending}>{status.pending ? '제출 중...' : '제출'}</button>;\n}\n\nconst formAction = async () => {\n  // 2초 지연 시뮬레이션\n  await new Promise((resolve) => setTimeout(resolve, 3000));\n}\n\nconst FormStatus = () => {\n  return (\n    <form action={formAction}>\n      <Submit />\n    </form>\n  );\n};\n\nexport default FormStatus;\n```\n\n위의 코드에서, 폼을 제출하면 useFormStatus 훅에서 보류 상태를 가져옵니다. 보류 중일 때 UI에 \"제출 중...\"이라는 텍스트가 표시됩니다. 보류가 false가 되면 \"제출\"으로 텍스트가 변경됩니다.\n\nuseFormState() 훅\n\nuseFormState() 훅을 사용하면 폼 제출 결과를 기반으로 상태를 업데이트할 수 있습니다. 이는 특히 폼의 결과에 따라 UI 요소를 업데이트하거나 동작을 트리거하는 데 유용합니다:\n```\n\n\n\n여기가 문법입니다:\n\n```js\nconst [state, formAction] = useFormState(fn, initialState, permalink?);\n```\n\nfn: 폼이 제출되거나 버튼이 눌릴 때 호출되는 함수입니다.\ninitialState: 상태가 초기에 가질 값입니다. 직렬화 가능한 값이어야 합니다. 이 인수는 처음 액션이 호출된 후 무시됩니다.\npermalink: 옵션입니다. fn이 서버에서 실행될 경우 페이지가 permalink으로 리디렉트됩니다.\n\n이 훅은 반환할 것입니다:\n\n\n\n초기 상태: initialState로 전달한 값이 초기 상태로 설정됩니다.\nformAction: 폼 액션으로 전달될 액션입니다. 이 값의 반환값이 상태에서 사용 가능합니다.\n\nuseFormState()를 사용하면 복잡한 상태 관리 로직 없이 폼 상태를 쉽게 관리하고 폼 제출에 기반한 작업을 수행할 수 있습니다.\n\nuseOptimistic() 훅:\n\nuseOptimistic() 훅을 사용하면 비동기 작업이 진행 중일 때 다른 상태를 표시하여 더 반응성 있는 사용자 경험을 제공할 수 있습니다. 요청이 성공할 것이라 가정하고 즉시 UI를 업데이트하여 서버로부터 응답을 받기 전에도 UI가 갱신됩니다.\n\n\n\n여기 문법이에요:\n\n```js\nconst [ optimisticMessage, addOptimisticMessage] = useOptimistic(state, updatefn)\n```\n\n예를 들어, 응답이 오는 중일 때 사용자에게 즉각적인 응답을 제공하기 위해 \"상태\"를 표시할 수 있어요. 실제 응답이 서버로부터 반환되면 \"낙관적\" 상태가 그것으로 대체될 거예요.\n\n`useOptimistic` 훅은 요청이 성공할 것으로 가정하고 즉시 UI를 업데이트할 거예요. 이름이 \"낙관적\"인 이유는 사용자가 작업을 수행하는 낙관적(성공) 결과를 보게 되지만 실제 작업 완료까지 시간이 걸리기 때문이에요.\n\n\n\nuseOptimistic()을 사용하면 양식의 인지 성능을 향상시키고 사용자에게 즉각적인 피드백을 제공할 수 있습니다.\n\n다음 섹션에서는 useOptimistic 훅의 실제 구현에 대해 실제 예제로 자세히 살펴보겠습니다. 코드 실습과 즐거운 코딩을 기대해주세요!! 🚀\n\n관련 링크\n\nReact 19의 새로운 기능\n\n\n\nReact 19의 새로운 기능 — React 컴파일러\n\nReact 19의 새로운 기능 — 서버 컴포넌트\n\nReact 19의 새로운 기능 — 액션\n\nReact 19의 새로운 기능 — 웹 컴포넌트\n\n\n\nReact 19의 새로운 기능 — 문서 메타데이터\n\nReact 19의 새로운 기능 — 자산 로딩","ogImage":{"url":"/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png"},"coverImage":"/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png","tag":["Tech"],"readingTime":7},{"title":"12부 setTimeout  클로저 인터뷰 문제 ","description":"","date":"2024-05-12 21:06","slug":"2024-05-12-Part12setTimeoutClosuresInterviewQuestions","content":"\n\n# 사전 준비 사항:\n\n만약 클로저(Closures) 개념이 잘 이해되지 않는다면, 아래 내용을 꼭 읽어보세요:\n\n- Part 11: 자바스크립트(JS)에서의 클로저(Closures) 🤷🏻‍♀️\n\n![이미지](/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png)\n\n\n\n## 이 프로그램을 실행하면 콘솔에서 무엇을 기대하시나요?\n\n출력:\n\n![Output](/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_1.png)\n\n1초 후에 i의 값인 1이 출력됩니다.\n\n\n\n아래와 같이 시간 초가 지난 후 출력이 됩니다.\n\nsetTimeout()을 사용하면 3초 후에 i를 출력한 다음 \"Learn\"을 출력할 것으로 생각할 수 있습니다. 하지만, 그렇지 않습니다. \"Learn\"을 먼저 출력하고 3초를 기다린 후 i의 값을 출력할 것입니다.\n\n## setTimeout()이 실제로 하는 일은 무엇인가요?\n\n- 3줄에서, function ()이 클로저를 형성합니다. 이 함수는 i에 대한 참조를 기억합니다.\n- setTimeout()은 해당 콜백 함수를 실행하고 어딘가에 저장하고 타이머를 부착합니다. JS는 다음 줄로 진행합니다.\n- 타이머가 만료되면 해당 함수를 가져와서 호출 스택에 넣고 실행합니다.\n\n\n\n다음은 복잡한 문제의 예를 살펴보겠습니다.\n\n## 콘솔에 1부터 10까지의 숫자를 매 초마다 출력하려고 합니다. 즉, 1초 후에 1을, 2초 후에 2를, 그리고 3초 후에 3을 출력하는 방식입니다. 이를 어떻게 해결할 수 있을까요?\n\n첫 번째 떠오르는 해결책은 for 루프를 사용하고 그 안에 setTimeout()을 넣는 것입니다. 아래와 같이 말이죠?\n\n이제 결과를 확인해 보겠습니다:\n\n\n\n<img src=\"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_2.png\" />\n\n이건 우리가 기대했던 것과 다릅니다. 왜 그런 건가요? 무슨 일이 있었나요? 🧐\n\n두 가지 이유가 있어요:\n\n1. 우리는 클로저가 함수와 그 렉시컬 환경이 어떻게 동작하는지 배웠거든. 그래서 함수가 자신의 원래 범위에서 벗어나더라도 여전히 자신의 원래 범위를 기억할 거에요. 클로저는 렉시컬 범위의 변수에 접근할 수 있어요.\n\n\n\n그래서 setTimeout()이 이 함수를 취하고 어딘가에 저장하고 타임아웃을 부착하면, i에 대한 참조를 기억합니다.\n\n따라서 루프가 처음 실행될 때, 함수의 복사본을 만들어 타이머를 부착하고 i에 대한 참조를 기억합니다.\n\n마찬가지로, 모든 10개의 함수 복사본은 i에 대한 참조를 기억하고 있으며, 값이 아닙니다. 그리고 모두 같은 i에 대한 참조를 가리키고 있습니다.\n\n## 왜 젠장 같은 i에 대한 참조를 가리키고 있는 걸까요? 😳\n\n\n\n모든 이러한 기능들의 환경은 같기 때문이에요. setTimeout()의 콜백 함수 복사본들은 모두 같은 메모리 공간에서 i를 참조하고 있어요. 🤷🏻‍♀️\n\n2. JS는 아무것도 기다리지 않아요. 그래서 루프가 계속 실행될 거예요 🔄. 그래서 setTimeout()은 모든 10개의 함수를 저장하고 JS는 계속 진행할 거예요. JS는 타이머가 만료되기를 기다리지 않아요. \"Learn\"을 출력하고, 타이머가 만료되면 이미 너무 늦어요. 이제 i의 값이 변경되었어요. 왜냐하면 루프가 계속 실행되었으니까요. 이 콜백 함수가 실행될 때에는 이미 메모리 위치에 var i = 11의 값이 되어 있어요.\n\n그래서 매번 11이 출력되는 거죠 🤷🏻‍♀️. 왜냐하면 이러한 콜백 함수 복사본들이 모두 같은 메모리 위치를 참조하기 때문이에요 🤦🏻‍♀️. 해당 위치는 이제 10번 실행되었고 루프에서 값이 1씩 증가했기 때문에 11이 되었답니다 🙄.\n\n## 이제, 어떻게 이 문제를 해결할 수 있을까요? 💡💡\n\n\n\nlet 대신 var 대신 사용하세요. 왜냐하면 let은 블록 범위를 가지고 있기 때문에 각각의 반복에서 i는 매번 새로운 변수가 됩니다. 메모리에는 매번 i의 새 복사본이 있습니다. \n\nsetTimeout()이 실행될 때, 콜백 함수는 새로운 i의 복사본을 가질 것입니다. \n\n실행해보고 결과를 확인해봅시다:\n\n<img src=\"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_3.png\" />\n\n잘 작동했어요 🎉🎉\n\n\n\n## 다시 한 번 수정해 봅시다. let 키워드 때문에 실제로 일어난 일에 대해:\n\n1. i = 1로 시작한 루프에서, 함수가 자체적으로 새 변수와 클로저를 형성했습니다.\n2. i++ 이후에 함수가 다시 클로저를 형성했을 때, 값이 2인 새 변수를 가지고 있으며 이를 저장했습니다.\n3. 이런 식으로 계속 진행됩니다. 이렇게 하면 변수 i의 10개의 복사본을 만들어 각 함수마다 클로저를 형성합니다.\n\n## 그래서, 다음에 누군가 아래 두 경우의 출력 차이와 그 이유에 대해 물으면? 당신은 답을 알고 있습니다 😎\n\n## 경우 1:\n\n\n\n```js\nfunction x(){\n  for (var i = 1; i <= 10; i++){  // 이 부분에서 var을 사용했어요 \n    setTimeout(function (){\n    console.log(i);\n    }, i * 1000);\n  }\n  console.log(\"배워요\")\n}\nx();\r\n```\n\n## Case 2:\n\n```js\nfunction x(){\n  for (let i = 1; i <= 10; i++){  // 이 부분에서 let을 사용했어요 \n    setTimeout(function (){\n    console.log(i);\n    }, i * 1000);\n  }\n  console.log(\"배워요\")\n}\nx();\r\n```\n\nAnswer: let은 블록 스코프이며 루프가 실행될 때마다 매번 새로운 복사본을 생성합니다.\n\n\n\n## 다시 뒤로 돌아가기 🤭: 만약 var만 사용하고 매 초 1,2,3,..10을 출력해야 한다면 어떻게 해야 할까요? \n\n조금만 생각해 보세요. 어떤 해결책이 될 수 있을까요?\n요령은 매번 변수 i의 새 복사본을 만들어야 한다는 것입니다.\n\n그래서, 새로운 함수 close()를 만들고 그 안에 setTimeout()을 랩핑합니다. 그리고 호출할 때마다 i를 전달합니다.\n\n## 왜 이 방법이 동작할까요? 😬\n\n\n\n매번 i와 함께 close() 함수를 호출할 때마다 setTimeout()을 위한 새로운 i 복사본이 생성된다고 해요 😎.\n\n그게 전부에요. setTimeout()이 어떻게 작동하는지와 클로저랑 어떻게 연관되는지 다루었어요. 👏🏼\n\n## 다음 👩🏻‍🏫 ⏭️ : 제13부 : 클로저 JS 인터뷰 질문들 🤯\n\n이 기사를 읽어 주셔서 감사합니다 ❤️\n\n\n\n# ⭐️ 즐겁게 코딩해요. ⭐️\n\n오늘 무엇인가를 배웠으면 좋겠네요! 떠나시기 전에:\n\n- 👏 스와티 레드후를 따르고 스토리에 박수를 보내주세요 👩🏻‍💻\n- 📰 2023 자바스크립트 학습 로드맵에서 더 많은 콘텐츠를 확인해보세요 — 최고의 안내서 ❤️\n- 🔔 LinkedIn을 팔로우해주세요\n\n🚀👉 자바스크립트 기본을 확실히 다지고 멋진 직장을 찾아보세요","ogImage":{"url":"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png","tag":["Tech"],"readingTime":4},{"title":"React에서 Axios를 사용하여 중앙 집중식 API 클라이언트 파일 만들기","description":"","date":"2024-05-12 21:05","slug":"2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios","content":"\n\n리액트 애플리케이션을 구축할 때 API와 상호 작용하는 경우, API 호출을 처리하는 깔끔하고 조직화된 방식을 유지하는 것이 중요합니다. 이를 달성하는 효과적인 방법 중 하나는 중앙 집중식 API 클라이언트 파일을 생성하는 것입니다. 이 튜토리얼에서는 Axios를 사용하여 이러한 파일을 구조화하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png)\n\n# API 호출을 중앙 집중화하는 이유\n\nAPI 호출을 중앙 집중화하는 것에는 여러 가지 이점이 있습니다:\n\n\n\n- 모듈성: API 로직을 하나의 파일로 분리함으로써 응용 프로그램 전반에 걸쳐 모듈성과 재사용성을 촉진합니다.\n- 조직화: 모든 API 관련 코드가 하나의 파일에 포함되어 있어 관리하고 유지하는 것이 더 쉬워집니다.\n- 일관성: 일반적인 설정 및 오류 처리 전략을 한 곳에 정의함으로써 응용 프로그램 전체에서 일관성을 보장할 수 있습니다.\n\n# Axios 설정하기\n\n먼저 프로젝트에 Axios가 설치되어 있는지 확인하세요. npm이나 yarn을 통해 설치할 수 있습니다:\n\n```js\nnpm install axios\n# 또는\nyarn add axios\n```\n\n\n\n# API 클라이언트 파일 만들기\n\nAPI 호출을 처리할 apiClient.js 파일을 생성해 봅시다:\n\n```js\n// apiClient.js\n\nimport axios from 'axios';\n\nconst BASE_URL = process.env.REACT_APP_BASE_URL || 'https://api.example.com';\n\nconst apiClient = axios.create({\n  baseURL: BASE_URL,\n  headers: {\n    'Content-Type': 'application/json',\n    // 여기에 인증 토큰과 같은 다른 헤더를 추가할 수 있습니다\n  },\n});\n\n// 공통 API 메서드 정의\nconst _get = (url, config = {}) => {\n  return apiClient.get(url, config);\n};\n\nconst _delete = (url, config = {}) => {\n  return apiClient.delete(url, config);\n};\n\nconst _put = (url, data = {}, config = {}) => {\n  return apiClient.put(url, data, config);\n};\n\nconst _post = (url, data = {}, config = {}) => {\n  return apiClient.post(url, data, config);\n};\n\n// API 메서드 내보내기\nexport { _get, _delete, _put, _post };t api;\n```\n\n위 파일에서:\n\n\n\n- Axios 인스턴스를 생성하여 기본 URL과 기본 헤더를 설정합니다.\n- 각 엔드포인트에 해당하는 다양한 API 기능을 정의합니다.\n\n환경 변수 설정: 먼저, 각 환경에 맞게 환경 변수를 설정해야 합니다. 일반적으로 각 환경에 대한 .env 파일을 생성하여 이 작업을 수행할 수 있습니다. 예를 들어:\n\n- .env.development: 개발 환경을 위한 변수를 포함합니다.\n- .env.qa: QA 환경을 위한 변수를 포함합니다.\n- .env.staging: 스테이징 환경을 위한 변수를 포함합니다.\n- .env.production: 프로덕션 환경을 위한 변수를 포함합니다.\n\n각 .env 파일 내에서 기본 URL을 정의하세요.\n\n\n\nREACT_APP_BASE_URL=https://api.example.com\n\n- 다른 환경에 접속하기: 환경에 따라 (예: 개발, QA, 스테이징) React는 자동으로 해당 .env 파일을로드하고 BASE_URL이 그에 맞게 설정됩니다.\n\n예를 들어, 개발 중일 때 React는 .env.development를로드하고 BASE_URL이 해당 파일에 지정된 값으로 설정됩니다.\n\n마찬가지로 다른 환경 (예: QA, 스테이징)에서도 React는 해당 .env 파일을로드합니다.\n\n\n\n2. React 컴포넌트에서의 사용법: 이전 예시에서 보았던 것처럼 React 컴포넌트에서 api 객체를 계속 사용할 수 있습니다. 기본 URL은 환경에 따라 동적으로 결정됩니다.\n\n이 설정을 사용하면 다른 환경에 대해 쉽게 다른 기본 URL을 관리할 수 있어 React 애플리케이션이 실행 중인 환경에 따라 적절한 백엔드와 통신할 수 있도록 보장합니다.\n\n# 컴포넌트에서 API 클라이언트 사용하기\n\n이제 React 컴포넌트에서 이 API 클라이언트를 사용하는 방법을 살펴보겠습니다:\n\n\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { _get, _post, _put, _delete } from './apiClient'; // 필요에 따라 경로를 조정하세요\n\nfunction ExampleComponent() {\n  const [data, setData] = useState([]);\n\n  useEffect(() => {\n    // 컴포넌트가 마운트될 때 데이터 가져오기\n    fetchData();\n  }, []);\n\n  const fetchData = async () => {\n    try {\n      const response = await _get('/data', { headers: { Authorization: 'Bearer 여기에 토큰 입력' } });\n      setData(response.data);\n    } catch (error) {\n      console.error('데이터를 가져오는 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  const addData = async () => {\n    try {\n      const newData = { name: '새 데이터' };\n      await _post('/data', newData);\n      fetchData(); // 추가 후 데이터 새로고침\n    } catch (error) {\n      console.error('데이터 추가 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  const updateData = async (id, updatedData) => {\n    try {\n      await _put(`/data/${id}`, updatedData);\n      fetchData(); // 업데이트 후 데이터 새로고침\n    } catch (error) {\n      console.error('데이터 업데이트 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  const deleteData = async (id) => {\n    try {\n      await _delete(`/data/${id}`);\n      fetchData(); // 삭제 후 데이터 새로고침\n    } catch (error) {\n      console.error('데이터 삭제 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  return (\n    <div>\n      <h1>예시 컴포넌트</h1>\n      <button onClick={addData}>데이터 추가</button>\n      <ul>\n        {data.map(item => (\n          <li key={item.id}>\n            {item.name}\n            <button onClick={() => updateData(item.id, { name: '업데이트된 아이템' })}>업데이트</button>\n            <button onClick={() => deleteData(item.id)}>삭제</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default ExampleComponent;\n```\n\nAxios에서 config 매개변수를 사용하면 HTTP 요청에 대한 추가 구성을 전달할 수 있습니다. 일반적으로 사용되는 구성에는 헤더, 쿼리 매개변수, 요청 시간 초과, 인증 토큰 등이 있습니다.\n\n참고: axios.create()로 Axios 인스턴스를 만들 때 baseURL 옵션을 BASE_URL로 설정합니다. 이렇게 하면 이 Axios 인스턴스로 작성된 모든 요청에 기본 URL이 URL에 접두사로 붙습니다.\n\n예를 들어, ExampleComponent에서 _get(`/data`)를 호출하면 Axios는 `https://api.example.com/data`로 GET 요청을 보냅니다.```\n\n\n\n# 결론\n\nAxios를 사용하여 React 애플리케이션에서 API 호출을 중앙화하는 것은 API 로직을 관리하기 위한 깔끔하고 조직된 방법을 제공합니다. 중앙 집중화된 API 클라이언트 파일을 만들면 코드베이스에서 모듈화, 조직화 및 일관성을 달성할 수 있습니다. 이 방법을 통해 유지 보수가 간단해지며 애플리케이션 전체에서 코드 재사용을 장려합니다.\n\n오늘부터 API 호출을 조직화하고 React 프로젝트에 가져다 주는 혜택을 경험해보세요!","ogImage":{"url":"/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png"},"coverImage":"/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png","tag":["Tech"],"readingTime":5},{"title":"왜 효과가 필요하지 않을 수도 있습니다 React 컴포넌트 최적화하기","description":"","date":"2024-05-12 21:04","slug":"2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents","content":"\n\n<img src=\"/assets/img/2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents_0.png\" />\n\n요즘 리액트 개발에서 useEffect 훅은 강력한 도구입니다. 그러나 종종 과도하게 사용되거나 잘못 사용되어 불필요한 복잡성과 성능 문제를 야기할 수 있습니다. useEffect에 항상 의지하는 대신, 고려할 가치가 있는 대안들이 있습니다. 이 글에서는 그러한 대안을 탐구하고 실용적인 코딩 예제를 제공합니다.\n\n# 흔한 오용 사례\n\n# 1. 상태 동기화\n\n\n\n일반적인 사용 사례는 상태 변수를 동기화하는 것입니다. 하지만 리액트의 onChange 및 다른 이벤트 핸들러들은 대부분의 상태 업데이트를 직접 처리할 수 있습니다.\n\n잘못된 예시:\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [double, setDouble] = useState(0);\n\n  useEffect(() => {\n    setDouble(count * 2); // 이중 값 계산을 위한 사이드 이펙트\n  }, [count]);\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>증가</button>\n      <p>카운트: {count}</p>\n      <p>이중: {double}</p>\n    </div>\n  );\n}\n```\n\n최적화된 솔루션:\n\n\n\n```js\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const double = count * 2; // useEffect 없이 직접 계산\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>증가</button>\n      <p>카운트: {count}</p>\n      <p>더블: {double}</p>\n    </div>\n  );\n}\n```\n\n# 2. 데이터 가져오기\n\nuseEffect에서 데이터를 가져오는 것은 필수적이지만, react-query나 React의 새로운 Server Components와 같은 데이터 가져오기 라이브러리를 사용하여 간단히할 수 있습니다.\n\n잘못된 예시:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [profile, setProfile] = useState(null);\n  useEffect(() => {\n    async function fetchProfile() {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      setProfile(data);\n    }\n    fetchProfile();\n  }, [userId]);\n  return profile ? <div>{profile.name}</div> : <p>Loading...</p>;\n}\n```\n\nReact 서버 구성 요소를 사용한 최적화된 해결책:\n\n```js\n// components/UserProfile.server.js\nimport React from 'react';\n\nexport default async function UserProfile({ userId }) {\n  const response = await fetch(`https://api.example.com/users/${userId}`);\n  const profile = await response.json();\n\n  return <div>{profile.name}</div>;\n}\n```\n\n클라이언트 컴포넌트에서의 사용법:```\n\n\n\n```md\n// components/App.client.js\nimport UserProfile from './UserProfile.server';\n\nfunction App({ userId }) {\n  return (\n    <div>\n      <h1>User Profile</h1>\n      <UserProfile userId={userId} />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n## 3. Form Inputs and Debounced Updates\n\nInstead of debouncing updates through useEffect, handle it directly via controlled input components.\n\nIncorrect Example:\n```\n\n\n\n```js\r\nimport { useState, useEffect } from 'react';\n\nfunction Search() {\n  const [query, setQuery] = useState('');\n  const [debouncedQuery, setDebouncedQuery] = useState(query);\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedQuery(query);\n    }, 300);\n    return () => clearTimeout(timer);\n  }, [query]);\n  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;\n}\r\n```\n\n커스텀 훅을 사용한 최적화된 솔루션:\n\n```js\r\nimport { useState } from 'react';\nimport useDebounce from './useDebounce';\n\nfunction Search() {\n  const [query, setQuery] = useState('');\n  const debouncedQuery = useDebounce(query, 300);\n  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;\n}\r\n```\n\nuseDebounce 커스텀 훅은 디바운싱 로직을 캡슐화합니다:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n  return debouncedValue;\n}\nexport default useDebounce;\n```\n\n# 4. Prop이 변경될 때 모든 상태를 재설정하는 방법\n\n다른 항목 간을 이동할 때 폼 필드나 필터와 같은 상태 변수를 재설정하는 것이 중요합니다. 이 재설정을 처리하는 비효율적인 방법은 useEffect 훅을 사용하여 prop 변경에 따라 상태를 수동으로 지우는 것입니다. 그러나 이렇게 하면 추가 렌더링 사이클이 발생하고 불필요한 복잡성을 야기합니다.\n\n올바르지 않은 예시:```\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nexport default function ItemDetails({ itemId }) {\n  const [input, setInput] = useState('');\n  // 🔴 비효율적: 효과를 이용해 상태를 재설정\n  useEffect(() => {\n    setInput(''); // itemId가 변경될 때 입력 필드를 지움\n  }, [itemId]);\n\n  return <input value={input} onChange={(e) => setInput(e.target.value)} />;\n}\n```\n\n효과에 의존하는 대신 key prop을 사용하여 자동으로 재설정되도록 할 수 있습니다. 컴포넌트를 둘로 분리하고 내부 컴포넌트에 고유한 key prop을 전달하면 React가 새로운 인스턴스로 처리하여 모든 내부 상태를 재설정합니다.\n\n최적화된 솔루션:\n\n```js\nexport default function ItemDetails({ itemId }) {\n  return <ItemForm itemId={itemId} key={itemId} />;\n}\n\nfunction ItemForm({ itemId }) {\n  // ✅ key 변경 시 상태 자동 재설정\n  const [input, setInput] = useState('');\n  return (\n    <div>\n      <h2>아이템 {itemId}에 대한 세부정보</h2>\n      <input value={input} onChange={(e) => setInput(e.target.value)} />\n    </div>\n  );\n}\n```\n\n\n\n# 결론\n\nReact의 useEffect는 가치가 있지만 종종 잘못 적용될 수 있습니다. 많은 경우, 이벤트 핸들러, react-query와 같은 라이브러리, 또는 커스텀 훅과 같은 대안적인 접근 방식을 사용하면 더 깔끔하고 유지보수가 쉬운 해결책을 제공할 수 있습니다. 더 많은 정보를 원하신다면 React의 가이드를 확인해보세요.","ogImage":{"url":"/assets/img/2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents_0.png"},"coverImage":"/assets/img/2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents_0.png","tag":["Tech"],"readingTime":5},{"title":"Vite React 프로젝트에서 절대 상대 경로 Imports를 사용하면 안되는 이유","description":"","date":"2024-05-12 21:03","slug":"2024-05-12-AbsolutelyDontUseRelativePathsImportsInYourViteReactProject","content":"\n우리 모두는 코드를 작성하기 전에 파일 시스템을 700번이나 탐색하는 것을 멈춰야 합니다. 배워봅시다.\n\n새로운 React 프로젝트를 Vite로 설정했다고 가정하겠습니다. 아니라면, 이전 게시물을 참조하여 시작해보세요.\n\n기본적으로 이렇게 import 경로를 작성해야 합니다:\n\n```js\nimport SomeDefaultExport from \"../../../lib/usefulthings\";\nimport { NamedExport } from \"../../shared/things/NamedThing\";\n```\n\n이건 엄청난 문제는 아니지만, 깨끗한 코드란 wtf(정말 멍청한 질문) 수를 줄이는 거야. 그래서 이걸 훨씬 직접적이고 쉽게 이해할 수 있도록 수정해볼게. vite.config.js를 편집해보자.\n\n```js\n  resolve: {\n    alias: {\n      src: \"/src\",\n    },\n  },\n```\n\n여러분의 설정은 다음과 같이 보일 거에요:\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      src: \"/src\",\n    },\n  },\n});\n```\n\n이제, IDE도 우리와 함께 잘 작동하도록 도와줄 차례입니다. 프로젝트 루트 디렉토리에 새 파일을 추가해야 하며 jsconfig.json이라는 파일을 만들어야 합니다. 그리고 아래 내용을 추가해주세요:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"src/*\": [\"./src/*\"],\n    }\n  }\n}\n```\n\n위와 같이 작성할 수 있는 절대경로를 사용할 수 있게 해줍니다.\n\n```js\nimport SomeDefaultExport from \"src/lib/lib/usefulthings\";\nimport { NamedExport } from \"src/components/shared/things/NamedThing\";\n```\n\n제 삶을 훨씬 쉽게 만드는 데 이렇게 확장하고 싶어요:\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      src: \"/src\",\n      components: \"/src/components\",\n      assets: \"/src/assets\",\n      lib: \"/src/lib\",\n    },\n  },\n});\n```\n\njsconfig.json과 tsconfig.json을 잊지 마세요.\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"src/*\": [\"./src/*\"],\n      \"components/*\":[\"./src/components/*\"],\n      \"assets\": [\"./src/assets/*\"],\n      \"lib\": [\"./src/lib/*\"],\n    }\n  }\n}\n```\n\n여기 간단한 메모가 있어요. 몇 가지 예에서 개발자들이 이들 앞에 @ 기호를 사용하는 것을 본 적이 있는데, 저는 이것이 가독성이 좋은 개선이라고 생각해요. 하지만 @s 및 @c 등을 사용하여 이 이름을 더 줄이는 데 주의하세요. 빨리 배워도 명확한 코드 접근 방식을 장려하여, 필요한 것만큼 말하고 더 이상 또는 덜 이야기하지 않는 명확한 이름을 사용하는 것이 좋을 거예요.\n\n나는 Paul van Zyl이에요. 저는 Sigma Digital의 주요 컨설턴트이고, 작고 특화된 분산 형 제품 디자인 및 개발 팀입니다. 귀하의 다음 혁신적인 프로젝트를 실제로 제공할 수 있는 파트너를 찾고 있다면, 귀하와 귀하의 팀이 게임을 더 재미있게 즐길 수 있도록 도와 드릴 수 있는 파트너를 찾고 있다면, 혹은 그냥 인사를 하고 싶다면, 언제든지 연락 주세요: paul [at] sigmadigital.io\n","ogImage":{"url":"/assets/img/2024-05-12-AbsolutelyDontUseRelativePathsImportsInYourViteReactProject_0.png"},"coverImage":"/assets/img/2024-05-12-AbsolutelyDontUseRelativePathsImportsInYourViteReactProject_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 제어 및 비제어 훅","description":"","date":"2024-05-12 21:02","slug":"2024-05-12-Reactcontrolledanduncontrolledhooks","content":"\n\n<img src=\"/assets/img/2024-05-12-Reactcontrolledanduncontrolledhooks_0.png\" />\n\n리액트에서, 제어 및 비제어 컴포넌트는 폼 입력을 관리하는 데 사용되는 패턴입니다. 리액트 훅은 함수형 컴포넌트 내에서 상태를 관리하기 위한 제어 및 비제어 훅의 개념을 도입했습니다. 여기에 대한 개요입니다:\n\n## 제어 훅(Controlled Hooks):\n\nuseState 훅: 제어 훅을 사용하면 상태가 직접적으로 리액트에 의해 관리됩니다. useState 훅을 사용하면 상태 변수를 선언하고, 리액트가 제공하는 setter 함수를 사용하여 해당 변수를 업데이트할 수 있습니다. 컴포넌트의 상태가 변경되면 리액트가 업데이트된 상태로 컴포넌트를 다시 렌더링합니다.\n\n\n\n```js\nimport React, { useState } from 'react';\n\nfunction ControlledComponent() {\n  const [value, setValue] = useState('');\n\n  const handleChange = (event) => {\n    setValue(event.target.value);\n  };\n\n  return (\n    <input\n      type=\"text\"\n      value={value}\n      onChange={handleChange}\n    />\n  );\n}\n```\n\n이 예시에서는 입력 필드의 값이 'value' 상태 변수에 의해 제어되며, 업데이트는 'setValue' 함수로 처리됩니다.\n\n## Uncontrolled Hooks:\n\nuseRef Hook: Uncontrolled hooks를 사용하면 DOM 내부에서 상태를 직접 관리할 수 있습니다. React의 상태 관리 시스템을 통해가 아니라 직접 DOM 내에서 관리할 수 있습니다. useRef 훅은 렌더링 간에 다시 렌더링을 유발하지 않고 지속되는 값(current 속성)을 보유할 수 있는 가변 ref 객체를 생성합니다. \n```\n\n\n\n```js\nimport React, { useRef } from 'react';\n\nfunction UncontrolledComponent() {\n  const inputRef = useRef(null);\n\n  const handleClick = () => {\n    console.log(inputRef.current.value);\n  };\n\n  return (\n    <div>\n      <input type=\"text\" ref={inputRef} />\n      <button onClick={handleClick}>Log Value</button>\n    </div>\n  );\n}\n```\n\n이 예제에서 입력 필드의 값은 inputRef.current.value를 통해 DOM에 의해 직접 관리되며 변경 사항은 React의 상태 관리 시스템을 거치지 않고 액세스됩니다.\n\n# 제어 및 비제어 훅 사이 선택하기:\n\n- 제어된 훅(Controlled Hooks): React가 응용 프로그램 전체의 form 입력 상태를 관리하고 동기화해야 할 때 제어된 훅을 사용하세요. 제어된 컴포넌트는 form 데이터에 대한 단일 진실의 원천을 제공하여 변경 사항을 추적하고 관리하기 쉽게 만듭니다.\n- 비제어 훅(Uncontrolled Hooks): DOM 요소에 직접 액세스해야 하는 경우나 제어된 컴포넌트가 성능 문제를 일으킬 수 있는 대형 폼을 다룰 때 비제어 훅을 사용하세요. 비제어 컴포넌트는 모든 상태 변경마다 다시 렌더링을 유발하지 않아 더 빠를 수 있습니다. 그러나 복잡한 응용 프로그램에서는 특히 추적하고 관리하기 어려울 수 있습니다.```\n\n\n\n제어 및 비제어 훅은 각자의 사용 사례가 있으며 선택은 특정 요구 사항과 선호도에 따라 다릅니다.","ogImage":{"url":"/assets/img/2024-05-12-Reactcontrolledanduncontrolledhooks_0.png"},"coverImage":"/assets/img/2024-05-12-Reactcontrolledanduncontrolledhooks_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트에서 return null을 사용하지 마세요","description":"","date":"2024-05-12 21:01","slug":"2024-05-12-StopusingreturnnullinReact","content":"\n\n<img src=\"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png\" />\n\nReact를 사용할 때 컴포넌트에서 반환된 값의 의미를 이해하는 것이 중요합니다. 컴포넌트가 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용하는 것이 유혹스러울 수 있지만, 이는 의도하지 않은 결과를 초래할 수 있습니다. 이 게시물에서는 React 컴포넌트에서 return null을 사용하는 것이 나쁜 습관으로 여겨지는 이유와 return false가 더 좋은 대안인 이유에 대해 살펴보겠습니다.\n\n# \"return null\" 사용에 대한 문제점\n\n컴포넌트에서 return null을 사용하는 주된 문제점은 애플리케이션에서 예상치 못한 동작을 일으킬 수 있다는 것입니다. 특히, null은 React에서 렌더링할 유효한 값으로 처리되며, 이로 인해 컴포넌트의 자식 요소가 트리에서 분리될 수 있습니다. 이는 예기치 않은 다시 렌더링이나 상태 불일치 등 다양한 문제를 초래할 수 있습니다.\n\n\n\n이것이 발생하는 이유를 이해하기 위해서는 React가 어떻게 작동하는지에 대해 알아야 도움이 됩니다. 컴포넌트가 렌더링될 때, React는 현재 UI 상태를 나타내는 가상 DOM 트리를 생성합니다. 그런 다음 이 트리는 이전 트리와 비교되어 UI의 어느 부분을 업데이트해야 하는지를 결정합니다. 컴포넌트가 null을 반환하면, React에게 아무것도 렌더링할 필요가 없다고 알립니다. 그러나 이는 컴포넌트의 자식들이 업데이트되어야 하는 상태나 프롭을 가지고 있을 때 문제를 일으킬 수 있습니다.\n\n다음 예시를 살펴보세요:\n\n```js\nfunction Parent() {\n  return (\n    <div>\n      <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Child rendered');\n  });\n\n  if (count === 0) {\n    return null;\n  }\n\n  return (\n    <div>\n      <button onClick={() => setCount(count - 1)}>-</button>\n      {count}\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n이 예시에서, Child 컴포넌트는 count가 0과 같을 때 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용합니다. 그러나 이는 Child 컴포넌트가 count의 값이 0이 아닌 값으로 다시 렌더링될 때 문제를 일으킬 수 있습니다. 이 경우에 React는 Child 컴포넌트를 트리에 다시 연결해야 하며, 예상치 못한 동작을 일으킬 수 있습니다.\n\n\n\n# \"return false\"의 장점\n\nreturn null 대신에 return false를 사용하는 것이 더 좋은 방법입니다. 컴포넌트가 false를 반환하면 React는 이를 null을 반환한 것처럼 처리하지만, 또한 React에게 해당 컴포넌트의 자식들을 렌더링하지 말라고 말합니다. 이렇게 하면 컴포넌트와 해당 자식들이 트리에 연결된 채로 유지되어, return null을 사용했을 때 발생할 수 있는 문제점을 회피할 수 있습니다.\n\n다음은 return false를 사용하는 이전 예제의 업데이트된 버전입니다:\n\n```js\nfunction Parent() {\n  return (\n    <div>\n      <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Child rendered');\n  });\n\n  if (count === 0) {\n    return false;\n  }\n\n  return (\n    <div>\n      <button onClick={() => setCount(count - 1)}>-</button>\n      {count}\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n\n\n이 버전에서 Child 컴포넌트는 count가 0과 동일할 때 null 대신 false를 반환합니다. 이렇게 하면 컴포넌트와 해당 하위 요소가 렌더링할 필요가 없을 때에도 트리에 연결된 상태를 유지합니다. 결과적으로, 컴포넌트가 더 예측 가능하게 동작하고 return null을 사용할 때 발생할 수 있는 문제를 피할 수 있습니다.\n\n# \"return false\"를 사용하는 경우\n\n일반적으로 return null 대신에 return false를 사용하는 것이 더 나은 실천 방법이지만, 적용하기에 적절하지 않을 수 있는 경우가 있음을 기억하는 것이 중요합니다. 구체적으로, 컴포넌트가 렌더링할 필요가 없음을 나타내야 하는 경우에만 return false를 사용해야 합니다. 컴포넌트가 조건에 따라 무언가를 렌더링해야 하는 경우에는 if 문이나 삼항 연산자와 같은 조건부 렌더링 기술을 사용해야 합니다.\n\n다음은 if 문을 사용한 조건부 렌더링 예시입니다:\n\n\n\n```js\nfunction MyComponent({ isLoggedIn }) {\n  if (!isLoggedIn) {\n    return <LoginForm />;\n  }\n\n  return <Dashboard />;\n}\n```\n\n이 예에서 MyComponent 컴포넌트는 사용자가 로그인했는지에 따라 LoginForm 또는 Dashboard를 조건부로 렌더링하는 if 문을 사용합니다. 이는 return false 대신 조건부 렌더링을 사용하는 더 적절한 방법입니다.\n\n# 결론\n\n결론적으로, React 컴포넌트에서 return null을 사용하면 예기치 않은 동작을 유발하므로 일반적으로 피해야 합니다. 대신 컴포넌트가 렌더링하지 말아야 함을 나타내어야 할 때는 return false를 사용해야 합니다. 이렇게 함으로써 컴포넌트와 그 하위 요소는 트리에 연결된 상태를 유지하고 return null 사용으로 발생할 수 있는 문제를 피할 수 있습니다.\n```\n\n\n\n그러나 return false를 사용하는 경우는 컴포넌트가 아무것도 렌더링하지 말아야 하는 경우에만 사용해야 한다는 점을 명심해야 합니다. 컴포넌트가 조건부로 렌더링해야 하는 경우에는 조건부 렌더링 기술을 사용해야 합니다.","ogImage":{"url":"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png"},"coverImage":"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 JS에서 가짜 API 서버로 JSON 파일을 사용하는 방법","description":"","date":"2024-05-12 21:00","slug":"2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS","content":"\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_0.png)\n\n이 튜토리얼에서는 React JS에서 가짜 API를 위한 서버로 JSON 파일을 어떻게 사용하는지 배워보겠습니다. 실제 API에 의존하지 않고 애플리케이션을 테스트하고자 할 때 유용합니다. JSON 파일을 가짜 API로 사용함으로써 API 응답을 쉽게 모의하고 실제 API 호출을 하지 않고 다양한 시나리오를 테스트할 수 있습니다.\n\n# 요구 사항\n\n- json-server\n\n\n\n단계 1: JSON 파일 만들기\n리액트 프로젝트에서 새로운 JSON 파일을 만들고 \"db.json\"으로 이름 짓기. 이 파일에서 우리는 모킹하고 싶은 API 응답을 정의할 거에요. 아래는 예시입니다:\n\n단계 2: json-server 설치하기\nJSON 파일로부터 REST API를 시뮬레이트하기 위해 json-server 패키지를 사용할 거에요. 설치하려면 터미널에서 다음 명령어를 실행하세요:\n\n```js\nnpm install -g json-server\n```\n\n단계 3: JSON 서버 시작하기\nJSON 서버를 시작하려면 터미널에서 다음 명령어를 실행하고 JSON 파일의 경로를 지정하세요:\n\n\n\n```json\njson-server --watch db.json --port 3030\n```\n\n참고: React는 서버를 실행하는 데 사용되는 3000 포트를 사용하므로 포트를 수정하기 위해 —port 3030을 사용했습니다.\n\n단계 4: API 테스트\n이제 브라우저에서 http://localhost:3030/posts를 열면 데이터를 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_1.png)\n\n\n\n5단계: React에서 API 요청 만들기\nReact 컴포넌트에서 fetch API 또는 다른 HTTP 클라이언트 라이브러리를 사용하여 JSON 서버에 API 요청을 만듭니다. 다음은 fetch를 사용한 예시입니다:\n\n우리는 가짜 API 요청을 성공적으로 만들고 해당 요청을 통해 React 컴포넌트로 데이터를 가져왔습니다. GET 요청뿐만 아니라 POST 요청을 사용하여 데이터를 JSON 파일에 삽입하고, PUT 요청을 사용하여 데이터를 업데이트하고, DELETE 요청을 사용하여 JSON 데이터를 삭제할 수 있습니다. 이를 Postman에서 확인해 봅시다.\n\nPOST 요청\n\nJSON 파일에 새로운 게시물을 추가하려면 POST 요청을 만들고 본문을 사용하여 JSON 데이터를 추가해야 합니다. 다음은 예시입니다:\n\n\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_2.png)\n\nPUT 요청\n\n만약 데이터를 업데이트해야 한다면 PUT 요청을 사용하여 업데이트할 수 있습니다. 다음은 예시입니다:\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_3.png)\n\n\n\n삭제 요청\n\nJSON 파일에서 데이터를 삭제하려면 DELETE 요청을 사용할 수 있습니다. 예시는 다음과 같습니다:\n\n![예시 이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_4.png)\n\n여기까지입니다! React JS에서 가짜 API로 JSON 파일을 사용함으로써 실제 API에 의존하지 않고 응용 프로그램을 쉽게 테스트할 수 있습니다. 이는 테스트 목적으로 빠르고 쉬운 솔루션이며, 실제 API 호출을 하지 않고도 다양한 API 응답을 모방하고 다양한 시나리오를 테스트할 수 있습니다.\n\n\n\n문의 사항이 있으시면 LinkedIn을 통해 연락 주세요.\n\n오늘은 여기까지입니다. 아래에서 GitHub 저장소를 찾을 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_0.png"},"coverImage":"/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_0.png","tag":["Tech"],"readingTime":2},{"title":"React  Vite  React에서 Tailwind CSS가 작동되지 않는 문제 해결 2024년 업데이트","description":"","date":"2024-05-12 21:00","slug":"2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated","content":"\n\n<img src=\"/assets/img/2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated_0.png\" />\n\n가끔 Tailwind CSS가 작동하지 않고 Vite에 특히 지정된 방법으로 사전 설치를 따르지 않을 때 프로젝트에 적용할 수 없습니다.\n\n# 해결책\n\n간단합니다. 'vite.config.js' 파일에 아래와 같이 tailwindcss 및 css: ' ... '를 가져오는 부분을 추가해야 합니다.\n\n\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport tailwindcss from \"tailwindcss\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  css: {\n    postcss: {\n      plugins: [tailwindcss()],\n    },\n  },\n\n});\n```\n\n# 단계별 설치 안내\n\n또는 Vite + React 프로젝트에 Tailwind CSS 설정을 시작부터 따라갈 수도 있습니다.\n\n- Vite에 Tailwind CSS를 설치하는 명령어는 조금 다릅니다. postcss와 autoprefixer가 추가로 필요합니다.\n\n\n\n```js\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n2. 'tailwind.config.js' 파일을 아래와 같이 편집하여 모든 파일과 확장자를 추가하여 Tailwind CSS를 적용할 수 있습니다.\n\n```js\n/** @type {import('tailwindcss').Config} */\nexport default {\n  content: [\"./index.html\", \"./src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n3. 이것들을 당신의 CSS 파일 맨 위에 추가하세요.\n\n\n\n```js\n@tailwind 기본;\n@tailwind 컴포넌트;\n@tailwind 유틸리티;\n```\n\n완료! npm run dev로 이동해요.\n\n이제 일반적인 지시사항과 다른 부분을 보셨나요? output.css 파일을 생성하고 html 파일에 연결하는 단계가 필요하지 않아요.\n\nVite + React에서는 사실 더 간단하고 쉬워요.\n\n\n\n행복한 React! 🌐","ogImage":{"url":"/assets/img/2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated_0.png"},"coverImage":"/assets/img/2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated_0.png","tag":["Tech"],"readingTime":2}],"page":"75","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}