{"pageProps":{"posts":[{"title":"RxJS Creation Operators 마스터하기","description":"","date":"2024-05-18 22:03","slug":"2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams","content":"\n\n반응형 프로그래밍은 현대 웹 개발에서 중요한 기반 기술이 되었으며 비동기 데이터 스트림을 처리하는 견고한 방법을 제공합니다. RxJS 또는 JavaScript용 반응형 익스텐션은 JavaScript에서 반응형 프로그래밍을 구현하는 가장 인기있는 라이브러리 중 하나입니다. 생성 연산자는 여러 기능 중에서도 관찰 가능한 스트림을 생성하는 데 필수적인 도구로 강조됩니다. 이 블로그 포스트에서는 다양한 RxJS 생성 연산자, 작동 방식 및 각각에 대한 실제 사용 사례를 살펴보겠습니다.\n\n![image](/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png)\n\n## RxJS 생성 연산자란?\n\n이러한 연산자는 다양한 데이터 소스에서 새로운 Observables를 생성합니다. 이러한 연산자는 개발자들이 작업할 데이터 스트림의 소스를 정의할 수 있도록 해주기 때문에 중요합니다. 이러한 연산자를 이해하는 것은 RxJS의 전체 기능을 최대한 활용하는 데 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n# Creation Operators 목록\n\n(참고: “⭐ — 일반적으로 사용됨”)\n\n- ⭐ajax: Ajax 요청을 위한 observable을 생성하는 데 사용됩니다.\n- bindCallback: 콜백 스타일 함수를 observable로 변환합니다.\n- bindNodeCallback: bindCallback과 유사하지만, Node.js 스타일 콜백(error-first)을 위한 것입니다.\n- defer: observable의 생성을 구독 지점까지 지연시킵니다.\n- empty: 어떤 값도 방출하지 않고 즉시 완료되는 observable을 생성합니다.\n- ⭐from: 다양한 다른 객체 및 데이터 유형을 observable로 변환합니다.\n- ⭐fromEvent: DOM 이벤트 대상 또는 Node.js EventEmitter에서 이벤트를 방출하는 observable을 생성합니다.\n- fromEventPattern: 주어진 addHandler/removeHandler 함수 쌍에서 observable을 생성합니다.\n- generate: 제공된 반복 함수에 기반하여 시간이 지남에 따라 값들을 생성합니다.\n- ⭐interval: 지정된 간격에서 증가하는 숫자를 방출하는 observable을 생성합니다.\n- ⭐of: 값의 시퀀스를 observable 시퀀스로 방출합니다.\n- range: 지정된 범위 내의 숫자 시퀀스를 방출합니다.\n- throwError: 오류를 방출하는 observable을 생성합니다.\n- timer: 지정된 지연 후 단일 값을 방출합니다.\n- iif: 두 가지 가능한 원본 observable 중 하나에 조건부로 구독합니다.\n\n이제 Creation Operator를 하나씩 검토하고 예제를 통해 학습하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Ajax\n\nXMLHttpRequest API를 사용하여 HTTP 요청을 보냅니다.\n\n```js\n/* 실시간 사용 사례: 요청에서 반환되는 응답 객체를 방출하는 Observable */\nimport { ajax } from 'rxjs/ajax';\n\nconst githubUsers = `https://api.github.com/users?per_page=2`;\nconst users = ajax(githubUsers);\n\nconst subscribe = users.subscribe(\n  res => console.log(res),\n  err => console.error(err)\n);\n```\n\n```js\n/* 실시간 사용 사례: 요청에서 반환되는 응답 객체의 json 키만 방출하는 Observable */\nimport { ajax } from 'rxjs/ajax';\n\nconst githubUsers = `https://api.github.com/users?per_page=2`;\nconst users = ajax.getJSON(githubUsers);\n\nconst subscribe = users.subscribe(\n  res => console.log(res),\n  err => console.error(err)\n);\n```  \n\n<div class=\"content-ad\"></div>\n\n# bindCallback\n\n콜백 스타일의 함수를 Observable로 변환합니다.\n\n```js\n/* 실시간 사용 사례: jQuery의 getJSON을 Observable API로 변환하는 방법 */\n\nimport { bindCallback } from 'rxjs';\nimport * as jQuery from 'jquery';\n\nconst getJSONAsObservable = bindCallback(jQuery.getJSON);\nconst result = getJSONAsObservable('/my/url');\nresult.subscribe(x => console.log(x), e => console.error(e));\n```\n\n# bindNodeCallback\n\n<div class=\"content-ad\"></div>\n\n- 노드 스타일 콜백 함수를 Observable로 변환합니다.\n\n```js\n/* 실시간 사용 사례: 파일 시스템에서 파일 읽어오기 및 데이터를 Observable로 얻기 */\nimport { bindNodeCallback } from 'rxjs';\nimport * as fs from 'fs';\n\nconst readFileAsObservable = bindNodeCallback(fs.readFile);\nconst result = readFileAsObservable('./roadNames.txt', 'utf8');\n\nresult.subscribe(\n  x => console.log(x), // 파일 내용 처리\n  e => console.error(e) // 오류 처리\n);\n```\n\n- `defer`\n\nSubscriber가 Observable에 구독할 때까지 실행을 지연시키는 Observable를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\nRxJS에서 defer는 Observable을 생성하는 함수입니다. 주요 목적은 Observable이 구독될 때까지 Observable의 생성을 지연하는 것입니다. 이는 새로운 옵저버가 Observable을 구독할 때마다 설정 또는 초기화 논리가 실행되어야 하는 시나리오에서 유용합니다.\n\n```js\n/* 실시간 사용 사례: `of`를 사용하여 난수 생성 */\nimport { of, defer } from 'rxjs';\nconst randomOf$ = of(Math.random());\n\n// 랜덤 숫자 생성을 위해 `defer` 사용\nconst randomDefer$ = defer(() => of(Math.random()));\n\n// `randomOf$`를 여러 번 구독\nrandomOf$.subscribe(randomNumber => console.log('랜덤 숫자 (of):', randomNumber));\nrandomOf$.subscribe(randomNumber => console.log('랜덤 숫자 (of):', randomNumber));\nrandomOf$.subscribe(randomNumber => console.log('랜덤 숫자 (of):', randomNumber));\n\n// `randomDefer$`를 여러 번 구독\nrandomDefer$.subscribe(randomNumber => console.log('랜덤 숫자 (defer):', randomNumber));\nrandomDefer$.subscribe(randomNumber => console.log('랜덤 숫자 (defer):', randomNumber));\nrandomDefer$.subscribe(randomNumber => console.log('랜덤 숫자 (defer):', randomNumber));\n```\n\nOutput\n\n```js\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (defer): 0.987654321\n랜덤 숫자 (defer): 0.654321987\n랜덤 숫자 (defer): 0.123456789\n```\n\n<div class=\"content-ad\"></div>\n\n# 빈\n\n빈 Observable을 생성하고 즉시 완료 콜백을 호출합니다.\n\nRxJS의 빈 연산자는 값을 방출하지 않고 즉시 완료되는 Observable을 생성합니다. 값이 방출될 필요가 없지만 완료를 신호해야 하는 경우에 유용합니다.\n\n```js\n/* 실시간 사용 사례: 빈 Observable 생성 */\nimport { empty } from 'rxjs';\nconst emptyObservable$ = empty();\n// 빈 Observable에 구독하기\nemptyObservable$.subscribe({\n  next: () => console.log('다음 값'), // 호출되지 않음\n  complete: () => console.log('완료됨') // 즉시 호출됨\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# from\n\n배열, 프로미스, 이터러블 객체 또는 Observable과 유사한 객체에서 Observable을 생성합니다.\n\n```js\nimport { from } from 'rxjs';\nconst arraySource = from([1, 2, 3, 4, 5]);\nconst subscribe = arraySource.subscribe(val => console.log(val));\n//출력: 1, 2, 3, 4, 5\n```\n\n```js\nimport { from } from 'rxjs';\nconst source = from('Hello World');\nconst subscribe = source.subscribe(val => console.log(val));\n//출력: 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'\n```\n\n<div class=\"content-ad\"></div>\n\n\n```js\nconst numbers = from(new Promise((resolve, reject) => resolve('Hello World')));\nnumbers.subscribe((data) => {\n  console.log(data);\n});\n//output: Hello World\n```\n\n# fromEvent\n\n- 이벤트에서 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 사용자가 화면을 클릭할 때 시간 추적 */\nimport { fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = fromEvent(document, 'click');\nconst example = source.pipe(map(event => event.timeStamp));\nconst subscribe = example.subscribe(val => console.log(`이벤트 시간: ${val / 1000} 초`));\n```\n\n<div class=\"content-ad\"></div>\n\n출력\n\n```js\n이벤트 시간: 5.418900000000373 초\n이벤트 시간: 7.552900000000372 초\n```\n\n# fromEventPattern\n\nfromEventPattern은 이벤트를 반환하는 함수에서 Observable을 생성합니다. fromEventPattern을 사용하면 이벤트 처리기 함수를 등록하는 API를 Observable로 변환할 수 있습니다. fromEvent과 유사하지만 훨씬 유연합니다. fromEvent의 모든 사용 사례는 fromEventPattern으로 쉽게 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 생성\n\n함수를 기반으로 값을 생성하는 옵저버블을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 숫자 시퀀스 생성 */\n\nimport { generate } from 'rxjs';\nconst result = generate(0, x => x < 3, x => x + 1, x => x);\nresult.subscribe(x => console.log(x));\n\n// 결과:\n// 0\n// 1\n// 2\n```\n\n# 간격\n\n<div class=\"content-ad\"></div>\n\n일정한 간격으로 정수 시퀀스를 방출하는 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 1초 간격으로 값 시퀀스를 방출 */\nimport { interval } from 'rxjs';\n\n// 1초마다 시퀀스 값 방출\nconst source = interval(1000);\nconst subscribe = source.subscribe(val => console.log(val));\n//결과: 0, 1, 2, 3, 4, 5....\n```\n\n# of\n\n- 지정된 값을 순서대로 방출하는 Observable을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\n\nof(10, 20, 30)\n  .subscribe({\n    next: value => console.log('다음 값:', value),\n    error: err => console.log('에러 발생:', err),\n    complete: () => console.log('완료'),\n  });\n\n// 결과\n// 다음 값: 10\n// 다음 값: 20\n// 다음 값: 30\n// 완료\n```\n\n# range\n\n지정된 범위 내에서 숫자의 시퀀스를 방출하는 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 1에서 10까지 순차적으로 방출 */\n\nimport { range } from 'rxjs';\nconst source = range(1, 10);\nconst example = source.subscribe(val => console.log(val));\n// 출력: 1,2,3,4,5,6,7,8,9,10\n```\n\n<div class=\"content-ad\"></div>\n\n# throwError\n\n- 구독 시 오류를 발생시키는 Observable을 생성합니다.\n\n```js\n/* 구독 시 오류 발생 */\nimport { throwError } from 'rxjs';\n// 특정 값과 함께 오류를 발생시킵니다.\n\nconst source = throwError('오류 발생!');\n// 출력: 'Error: 오류 발생!'\n\nconst subscribe = source.subscribe({\n  next: val => console.log(val),\n  complete: () => console.log('완료!'),\n  error: val => console.log(`오류: ${val}`)\n});\n```\n\n# timer\n\n<div class=\"content-ad\"></div>\n\n- 특정 시간 간격 후에 발행을 시작하고 정수 시퀀스를 발행하는 Observable를 생성합니다.\n\n```js\n/* 실제 시나리오: 타이머는 1초 후에 발행을 시작하고 그 이후 매 2초마다 값을 발행합니다 */\n\nimport { timer } from 'rxjs';\n\n/*\n  timer 함수는 두 번째 인자를 가지며, 연속적으로 값들을 발행하는 빈도를 정의합니다.\n  이 경우, 1초 후에 첫 번째 값을 발행하고 그 이후 2초마다 값을 발행합니다.\n*/\nconst source = timer(1000, 2000);\n//출력: 0,1,2,3,4,5......\nconst subscribe = source.subscribe(val => console.log(val));\n```\n\n# iif\n\n조건에 따라 함수의 출력을 발행하는 Observable를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* Observable에 대한 액세스 제어 */\n\nimport { iif, of, EMPTY } from 'rxjs';\n \nlet accessGranted;\nconst observableIfYouHaveAccess = iif(\n  () => accessGranted,\n  of('액세스가 허용된 것 같아요...'),\n  EMPTY\n);\n \naccessGranted = true;\nobservableIfYouHaveAccess.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('끝')\n});\n \n// 출력:\n// '액세스가 허용된 것 같아요...'\n// '끝'\n \naccessGranted = false;\nobservableIfYouHaveAccess.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('끝')\n});\n \n// 출력:\n// '끝'\n```\n\n요약하면, RxJS Creation Operators는 JavaScript에서 반응형 프로그래밍의 기본 구성 요소입니다. 다양한 데이터 소스에서 Observable을 생성할 수 있게 해줌으로써, 이러한 연산자는 비동기 데이터 스트림을 효율적으로 처리할 수 있도록 개발자들을 지원합니다. API에서 데이터를 가져오는 ajax, 사용자 상호 작용에 반응하는 fromEvent, interval 및 timer를 사용하여 작업을 예약하는 등, 이러한 연산자들은 반응형 애플리케이션에서 데이터 흐름을 유연하고 강력하게 관리할 수 있는 방법을 제공합니다. 이러한 생성 연산자를 숙달하는 것은 RxJS의 모든 잠재력을 발휘하고 반응형 프로그래밍을 통한 반응형, 확장 가능하고 유지보수 가능한 애플리케이션을 구축하는 데 필수적입니다. 이 연산자들을 깊이 이해하고 그 기능을 실험하며, RxJS를 활용한 반응형 프로그래밍 마스터의 길에 나아가 보세요.\n\n즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png"},"coverImage":"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png","tag":["Tech"],"readingTime":9},{"title":"Angular 17에서 Google 지도 통합하기","description":"","date":"2024-05-18 22:02","slug":"2024-05-18-IntegratingGoogleMapsinAngular17","content":"\n\n만약 당신이 Angular에서 Google 지도 컴포넌트를 사용해 왔다면, 2024년 2월 21일부로 Marker가 사용 중단되었다는 경고를 받은 적이 있을 것입니다. 새롭고 더 사용자 정의할 수 있는 Advanced Marker를 사용하도록 권장되었습니다.\n\n안타깝게도, Angular에서의 Advanced Marker 사용 방법에 대한 가이드나 정보가 많이 없으며, 대부분의 문서들은 여전히 구식 Marker를 사용하고 있습니다.\n\n그러나 이 기사에서는 기존 Angular 프로젝트를 업데이트해야 하는 경우든, 처음부터 해당 컴포넌트를 시도해보는 경우든 새로운 Advanced Marker를 어떻게 사용할 수 있는지 공유하겠습니다.\n\n그러면 시작해봅시다!\n\n<div class=\"content-ad\"></div>\n\n# 준비물\n\nAngular 프로젝트를 생성하기 전에 Google Maps JavaScript API를 사용하기 위한 유효한 API 키가 있는지 확인해주세요. 추가 지침은 아래 링크를 참조해주세요:\nhttps://developers.google.com/maps/documentation/javascript/get-api-key\n\n또한, 이 컴포넌트에 필요한 맵 ID도 필요합니다. 다음 링크를 따라서 얻을 수 있습니다:\nhttps://developers.google.com/maps/documentation/get-map-id\n\n만일 맵 ID를 가지고 있지 않거나 얻을 수 없다면, 구글에서 제공한 개발용 맵 ID를 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- Map ID = DEMO_MAP_ID\n\n# 설정 단계\n\n새 프로젝트를 시작하고 이미 Angular v17이 설정되어 있다고 가정하면 새 앱을 만듭니다:\n\n```js\nng new angular-google-maps\ncd angular-google-maps\n```\n\n<div class=\"content-ad\"></div>\n\nGoogle Maps 모듈을 설치하려면 다음 명령어를 실행하세요:\n\n```js\nnpm i @angular/google-maps\n```\n\nAngular v17에서는 새 응용 프로그램이 기본적으로 독립적인 프로젝트로 생성됩니다. 컴포넌트가 독립적인지 여부는 src/app/app.component.ts 파일의 standalone 속성을 확인하여 알 수 있습니다. 컴포넌트가 독립적인 경우 해당 속성은 true로 표시됩니다.\n\n독립적인 컴포넌트의 경우 모듈을 src/app/app.component.ts 파일에 다음과 같이 가져옵니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n...\nimport { GoogleMapsModule } from \"@angular/google-maps\";\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [RouterOutlet, GoogleMapsModule],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.scss'\n})\n...\n```\n\n만약 해당 컴포넌트가 독립적이지 않다면 모듈을 src/app/app.module.ts 파일로 가져오세요:\n\n```js\n...\nimport { GoogleMapsModule } from \"@angular/google-maps\";\n\n@NgModule({\n  declarations: [...],\n  imports: [..., GoogleMapsModule],\n  ...\n})\nexport class AppModule {}\n```\n\n다음 스크립트를 애플리케이션의 src/index.html 파일에 추가하고 YOUR_API_KEY를 해당하는 API 키로 교체하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<head>\n  ...\n</head>\n<body>\n  ...\n  <script>\n    (g => {\n        var h, a, k, p = \"The Google Maps JavaScript API\", c = \"google\", l = \"importLibrary\", q = \"__ib__\", m = document, b = window;\n        b = b[c] || (b[c] = {});\n        var d = b.maps || (b.maps = {}),\n            r = new Set,\n            e = new URLSearchParams,\n            u = () => h || (h = new Promise(async (f, n) => {\n            await (a = m.createElement(\"script\"));\n            e.set(\"libraries\", [...r] + \"\");\n            for (k in g) e.set(k.replace(/[A-Z]/g, t => \"_\" + t[0].toLowerCase()), g[k]);\n            e.set(\"callback\", c + \".maps.\" + q);\n            a.src = `https://maps.${c}apis.com/maps/api/js?` + e;\n            d[q] = f;\n            a.onerror = () => h = n(Error(p + \" could not load.\"));\n            a.nonce = m.querySelector(\"script[nonce]\")?.nonce || \"\";\n            m.head.append(a)\n          }));\n        d[l] ? console.warn(p + \" only loads once. Ignoring:\", g) : d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n))\n      })({\n        v: \"weekly\",\n        key: \"YOUR_API_KEY\"\n      });\n  </script>\n</body>\n</html>\n```\n\n스크립트는 닫히는 body 태그 이전에 위치하고 head 태그 사이에 있지 않아야 합니다.\n\n# 지도 추가하기\n\n이제 맵의 높이와 너비를 추가하고, 옵션을 설정하여 구글 지도 컴포넌트를 애플리케이션에 추가할 수 있습니다:```\n\n<div class=\"content-ad\"></div>\n\n- 지도가 렌더링된 맵의 ID를 나타냅니다\n- center는 맵의 중심 (위도 및 경도)\n- zoom은 맵의 줌 레벨\n\n```js\n<!-- app.component.html -->\n<h1>Angular 17에서 Google 지도</h1>\n<google-map height=\"600px\" width=\"800px\" [options]=\"options\"> </google-map>\n```\n\n```js\n// app.component.ts\n...\nexport class AppComponent {\n  ...\n  options: google.maps.MapOptions = {\n    mapId: \"DEMO_MAP_ID\",\n    center: { lat: -31, lng: 147 },\n    zoom: 4,\n  };\n}\n```\n\n이제 다음 명령을 사용하여 응용 프로그램을 실행하실 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nng serve\n```\n\n해당 이미지와 비슷한 지도를 얻어야 합니다:\n\n<img src=\"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_0.png\" />\n\n# 고급 마커 추가하기\n\n<div class=\"content-ad\"></div>\n\n먼저, 마커의 위치(위도 및 경도)를 정의해야 합니다. 다음 변수를 app.component.ts 파일에 선언해주세요:\n\n```js\nexport class AppComponent {\n  ...\n  nzLocations: any[] = [\n    { lat: -36.817685, lng: 175.699196 },\n    { lat: -36.828611, lng: 175.790222 },\n    { lat: -39.927193, lng: 175.053218 },\n    { lat: -41.330162, lng: 174.865694 },\n    { lat: -43.999792, lng: 170.463352 },\n  ];\n  auLocations: any[] = [\n    { lat: -31.56391, lng: 147.154312 },\n    { lat: -33.718234, lng: 150.363181 },\n    { lat: -33.727111, lng: 150.371124 },\n    { lat: -33.848588, lng: 151.209834 },\n    { lat: -33.851702, lng: 151.216968 },\n    { lat: -34.671264, lng: 150.863657 },\n    { lat: -35.304724, lng: 148.662905 },\n    { lat: -37.75, lng: 145.116667 },\n    { lat: -37.759859, lng: 145.128708 },\n    { lat: -37.765015, lng: 145.133858 },\n    { lat: -37.770104, lng: 145.143299 },\n    { lat: -37.7737, lng: 145.145187 },\n    { lat: -37.774785, lng: 145.137978 },\n    { lat: -37.819616, lng: 144.968119 },\n    { lat: -38.330766, lng: 144.695692 },\n    { lat: -42.734358, lng: 147.439506 },\n    { lat: -42.734358, lng: 147.501315 },\n    { lat: -42.735258, lng: 147.438 },\n  ];\n}\n```\n\n다음으로, app.component.html 파일에서 for-loop를 사용하여 지도에 Advanced Markers를 추가할 것입니다.\n\n```html\n<google-map height=\"600px\" width=\"800px\" [options]=\"options\">\n  @for (location of nzLocations; track location) {\n  <map-advanced-marker\n    #markerElem=\"mapAdvancedMarker\"\n    [position]=\"{ lat: location.lat, lng: location.lng }\"\n  />\n  } @for (location of auLocations; track location) {\n  <map-advanced-marker\n    #markerElem=\"mapAdvancedMarker\"\n    [position]=\"{ lat: location.lat, lng: location.lng }\"\n  />\n  }\n</google-map>\n```\n\n<div class=\"content-ad\"></div>\n\n지금은 파일을 저장할 수 있고, 지도에 여러 호주 및 뉴질랜드 위치 표시기가 삽입된 것을 확인할 수 있습니다.\n\n![Google Map with location markers](/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_1.png)\n\n# 고급 마커 사용자 정의\n\n이제 우리가 지도를 성공적으로 초기화하고 표시기를 추가했으므로, 사용자 정의 이미지로 그들을 계속하여 사용자 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 인라인 SVG 사용하기\n\n기본 마커를 변경하려면 먼저 DOMParser를 추가하여 SVG 문자열을 DOM 요소로 변환해야 합니다. app.component.ts 파일에서 파서와 사용하려는 SVG 문자열을 초기화합니다:\n\n```js\n...\nngOnInit() {\n  const parser = new DOMParser();\n  // 이것은 집 아이콘의 SVG 문자열입니다. 사용하고 싶은 SVG 아이콘을 자유롭게 사용해주십시오.\n  const svgString = `<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"#FF5733\" stroke=\"#FFFFFF\" viewBox=\"0 0 24 24\">\n                    <path fill-rule=\"evenodd\" d=\"M11.293 3.293a1 1 0 0 1 1.414 0l6 6 2 2a1 1 0 0 1-1.414 1.414L19 12.414V19a2 2 0 0 1-2 2h-3a1 1 0 0 1-1-1v-3h-2v3a1 1 0 0 1-1 1H7a2 2 0 0 1-2-2v-6.586l-.293.293a1 1 0 0 1-1.414-1.414l2-2 6-6Z\" clip-rule=\"evenodd\"/>\n                    </svg>`;\n}\n```\n\n다음으로, 우리의 뉴질랜드 마커를 루프하여 원하는 이미지로 설정합니다. forEach 루프를 사용하여 각 위치의 내용 속성을 파서를 사용하여 문서 요소로 설정합니다. 위 코드에 이어 ngOnInit() 함수 내에서 이 작업을 수행하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nthis.nzLocations.forEach((location) => {\n  location.content = parser.parseFromString(svgString, \"image/svg+xml\").documentElement;\n});\n```\n\n모든 위치의 내용이 설정된 후에는 New Zealand 위치의 `map-advanced-marker` 태그의 내용 속성을 app.component.html 파일에서도 추가하고 수정해야 합니다.\n\n```html\n...\n@for (location of nzLocations; track location) {\n<map-advanced-marker\n  #markerElem=\"mapAdvancedMarker\"\n  [position]=\"{ lat: location.lat, lng: location.lng }\"\n  [content]=\"location.content\"\n/>\n}\n...\n```\n\n다음 이미지는 마커의 기본 핀 모양을 변경한 후 현재 지도가어떻게 보여야하는지 보여줍니다.```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_2.png\" />\n\n## PNG 이미지 사용하기\n\nPNG 이미지를 사용하려면 이미지를 참조하고 해당 요소를 위치 내용 태그에 설정해야 합니다.\n\napp.component.ts 파일에서 먼저 PNG 이미지에 대한 링크를 정의합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nngOnInit() {\n  ...\n  // 예시로 구글의 비치 플래그 이미지를 사용할 것이지만, 마음에 드시는 이미지를 자유롭게 사용해도 괜찮습니다\n  const beachFlag = \"https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png\";\n}\n```\n\n그런 다음, 우리는 ngOnInit() 함수 안에서 위 코드 이후에 오스트레일리아 마커들에 대해 forEach 루프를 사용하여 인라인 SVG 섹션에서 했던 것과 유사하게 각 위치의 내용으로 전달될 img 요소를 생성할 것입니다.\n\n```js\nthis.auLocations.forEach((location) => {\n  let imgTag = document.createElement(\"img\");\n  imgTag.src = beachFlag;\n  location.content = imgTag;\n});\n```\n\n한번 더, app.component.html 파일에서 오스트레일리아 위치들의 `map-advanced-marker` 태그의 내용 속성을 추가 및 수정해야 합니다.```\n\n<div class=\"content-ad\"></div>\n\n\n```js\n@for (location of auLocations; track location) {\n<map-advanced-marker\n  #markerElem=\"mapAdvancedMarker\"\n  [position]=\"{ lat: location.lat, lng: location.lng }\"\n  [content]=\"location.content\"\n/>\n}\n```\n\n\nThe final result should look like the following image:\n\n![Integrating Google Maps in Angular](/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_3.png)\n\n## Adding a Title\n\n\n<div class=\"content-ad\"></div>\n\n마커 위로 마우스를 올리면 제목 텍스트가 나타나며, 이는 `map-advanced-marker` 태그의 title 속성을 수정하여 설정합니다. 아래 코드에서는 각 위치의 인덱스 번호를 기반으로 제목을 추가했지만, 원하는 대로 변경할 수 있습니다.\n\n\n따라서 마커 위로 커서를 올리면 해당 위치 번호가 나타나는 작은 텍스트가 표시됩니다.\n\n<img src=\"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 정보 창 추가하기\n\n정보 창은 마커에 대한 자세한 정보를 제공할 수 있으며, 일반적으로 마커를 클릭할 때 표시됩니다. 우리는 고급 마커를 사용하고 있기 때문에 Advanced Marker에서 제공되는 새로운 기능인 openAdvancedMarkerElement()를 활용할 수 있습니다.\n\n먼저, imports를 업데이트하고 app.component.ts 파일에서 infoWindow의 ViewChild를 정의해야 합니다.\n\n```js\nimport { Component, ViewChild } from \"@angular/core\";\nimport { GoogleMapsModule, MapAdvancedMarker, MapInfoWindow } from \"@angular/google-maps\";\n...\nexport class AppComponent {\n...\n  @ViewChild(MapInfoWindow) infoWindow!: MapInfoWindow;\n...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그럼, 마커를 클릭했을 때 실행될 AppComponent 클래스의 함수를 작성할 수 있어요:\n\n```js\n...\nexport class AppComponent {\n...\n  onMarkerClick(marker: MapAdvancedMarker) {\n    this.infoWindow.openAdvancedMarkerElement(marker.advancedMarker, marker.advancedMarker.title);\n  }\n...\n}\n```\n\n`openAdvancedMarkerElement()` 함수의 첫 번째 매개변수는 정보 창이 열릴 마커 요소의 위치를 나타내고, 두 번째 매개변수는 정보 창에 표시될 내용으로 사용될 null이 가능한 문자열 또는 Element를 받아요.\n\n이제 할 일은 만들어둔 onMarkerClick 함수와 `map-info-window` 태그를 app.component.html 파일에 추가하는 거에요.\n\n<div class=\"content-ad\"></div>\n\n파일을 저장하고 이제 마커를 클릭하면 마커 제목이 나타나는 정보 창이 표시됩니다.\n\n<img src=\"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_5.png\" />\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n지금까지 따라오신 여러분, 축하드립니다! 구글 지도를 구현하여 클릭 시 정보 창이 열리는 사용자 정의 고급 마커가 포함된 지도를 성공적으로 만들었습니다.\n\n위 코드에 문제가 있거나 전체 코드를 보고 싶은 경우, 이 GitHub 저장소로 방문하여 프로젝트를 확인할 수 있습니다. 꼭 API 키를 교체해 주세요!\n\n이번 글은 여기까지입니다! 아래 댓글에 의견을 자유롭게 나눠주세요. 도움이 되었고 쉽게 따라올 수 있었기를 바라며, 저의 첫 Medium 글에 클랩 몇 개 부탁 드리겠습니다. 감사합니다! 😄","ogImage":{"url":"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_0.png"},"coverImage":"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_0.png","tag":["Tech"],"readingTime":11},{"title":"Angular 개발에서 흔히 하는 10가지 실수","description":"","date":"2024-05-18 21:56","slug":"2024-05-18-10CommonMistakesinAngularDevelopment","content":"\n\n## 고성능, 견고하며 안전한 애플리케이션 개발하기\n\n![이미지](/assets/img/2024-05-18-10CommonMistakesinAngularDevelopment_0.png)\n\nAngular 애플리케이션을 개발할 때 개발자들이 종종 실수하는 10가지 일반적인 실수를 예제와 함께 살펴보겠습니다.\n\n다음은 우리가 살펴볼 예제들에 대한 간략한 개요입니다:\n\n<div class=\"content-ad\"></div>\n\n- 구성 요소 설계의 부족: 일반적인 실수 중 하나는 Angular 구성 요소를 올바르게 설계하지 않는 것입니다. 이는 관심사의 분리와 재사용성의 원칙을 준수하지 않고, 볼륨이 크고 유지 보수가 어려운 구성 요소로 이어질 수 있습니다.\n- 비효율적인 변경 감지: Angular는 변경 감지를 사용하여 뷰를 모델과 동기화 유지합니다. 그러나 개발자가 변경 감지 전략을 최적화하지 않아 성능 문제를 발생시킬 수 있습니다. 기본 \"OnPush\" 전략을 사용하지 않거나 불필요하고 비용이 많이 드는 뷰 업데이트로 이어질 수 있습니다.\n- 반응형 프로그래밍 사용하지 않기: Angular는 반응형 폼과 RxJS와 같은 강력한 반응형 프로그래밍 기능을 제공하며, 이를 활용하지 않으면 복잡하고 오류가 발생하기 쉬운 코드로 이어질 수 있습니다.\n- 적절하지 못한 메모리 관리: 개발자가 리소스를 적절하게 관리하지 못하면 Angular 앱이 메모리 누수에 시달릴 수 있습니다. 예를 들어 옵저버를 구독해지하지 않거나 구성 요소를 올바르게 삭제하지 않거나 Angular의 의존성 주입 시스템을 올바르게 사용하지 않으면 메모리 누수가 발생하고 앱 성능이 저하될 수 있습니다.\n- 성능 최적화 부족: 성능 최적화가 제대로 구현되지 않으면 Angular 애플리케이션은 느려지고 응답하지 않을 수 있습니다. ngFor에 trackBy를 사용하지 않거나 HTTP 요청을 최적화하지 않거나 모듈의 지연 로딩을 활용하지 않으면 성능 최적화를 무시하면 사용자 경험이 좋지 않을 수 있습니다.\n- 보안 최선의 사례 무시: Angular는 XSS(Cross-Site Scripting) 및 CSRF(Cross-Site Request Forgery) 보호와 같은 내장 보안 기능을 제공합니다. 이러한 보안 기능을 무시하거나 사용자 입력을 유효성 검사하지 않거나 인증 및 권한 부여를 올바르게 처리하지 않으면 보안 취약점이 노출될 수 있습니다.\n- 테스트 부족: 포괄적인 단위 테스트와 e2e(종단 간) 테스트를 작성하지 않으면 버그가 많은 신뢰할 수 없는 애플리케이션으로 이어질 수 있습니다. 적절한 테스트를 무시하면 프로덕션 결함이 발생하고 애플리케이션의 유지 및 업데이트가 어려워질 수 있습니다.\n- Angular 최선의 사례 무시: Angular에는 고유한 최선의 사례와 코딩 규칙이 있습니다. Angular 스타일 가이드를 따르지 않거나 권장 폴더 구조를 준수하지 않으면 코드베이스를 이해하고 유지 관리하기 어려울 수 있습니다.\n- DOM 조작 최적화 무시: Angular 애플리케이션은 DOM(Document Object Model)의 빈번한 조작을 필요로 합니다. 과도한 양방향 데이터 바인딩을 사용하거나 안전한 DOM 업데이트를 위해 Renderer2 API를 활용하지 않으면 성능 문제, 느린 렌더링 및 부자연스러운 사용자 경험으로 이어질 수 있습니다.\n- 오류 조건 처리 미흡: 오류 처리는 견고하고 신뢰할 수 있는 Angular 애플리케이션을 작성하는 중요한 측면입니다. 실패한 HTTP 요청, 잘못된 사용자 입력 또는 예기치 않은 예외와 같은 오류 조건을 적절하게 처리하지 않으면 애플리케이션 충돌, 일관되지 않은 동작 및 부자연스러운 사용자 경험이 발생할 수 있습니다. 사용자에게 오류 메시지를 표시하거나 디버깅을 위해 오류를 로깅하고 오류에서 우아하게 복구하는 적절한 오류 처리 메커니즘을 구현하는 것이 중요합니다.\n\n## Poor Component Design\n\n관심사의 분리 부족:\n```js\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- ... 템플릿 코드 ... -->\n  `\n})\nexport class ExampleComponent {\n  constructor(private http: HttpClient) { }\n\n  // 컴포넌트 로직, HTTP 요청 포함하여 직접 컴포넌트 클래스에 작성\n  // ...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 Angular 컴포넌트는 HttpClient 모듈을 사용하여 HTTP 요청을 직접 처리하고 있습니다. 이는 관심사 분리 원칙을 위반하는 것이며, 컴포넌트는 뷰 렌더링 및 사용자 상호작용 처리에 중점을 두어야 하고, 서비스는 데이터 검색 및 조작을 포함한 비즈니스 로직을 처리해야 합니다. 컴포넌트 클래스에서 관심사를 섞으면 코드가 비대해지고 유지보수가 어려워질 수 있습니다.\n\n재사용성 부족:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <ul>\n      <li *ngFor=\"let product of products\">{{ product.name }}</li>\n    </ul>\n  `\n})\nexport class ProductListComponent {\n  products: Product[] = [\n    { id: 1, name: 'Product 1' },\n    { id: 2, name: 'Product 2' },\n    { id: 3, name: 'Product 3' }\n  ];\n\n  // 제품 목록에 특화된 컴포넌트 로직\n  // ...\n}\n\ninterface Product {\n  id: number;\n  name: string;\n}\n```\n\n이 예시에서는 제품 목록을 표시하는 ProductListComponent가 있습니다. 그러나 이 컴포넌트는 제품의 구체적인 데이터 구조와 제품 목록 표시에 특화된 로직과 강하게 결합되어 있습니다. 이는 다른 데이터 구조나 사용 사례에 쉽게 적응되지 않아서 재사용성이 떨어집니다.\n\n<div class=\"content-ad\"></div>\n\n향상된 재사용성:\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-item-list',\n  template: `\n    <h2>{ title }</h2>\n    <ul>\n      <li *ngFor=\"let item of items\">{ item.name }</li>\n    </ul>\n  `\n})\nexport class ItemListComponent {\n  @Input() title: string;\n  @Input() items: any[];\n\n  // 일반적인 항목 목록을 표시하는 컴포넌트 로직\n  // ...\n}\n```\n\n이 향상된 예시에서는 더 일반적인 형태의 ItemListComponent가 제공된 데이터를 통해 항목 목록을 표시할 수 있습니다. 이 컴포넌트는 더 이상 제품의 특정 데이터 구조에 강하게 결합되어 있지 않으며, @Input() 속성을 통해 다른 데이터 구조나 사용 사례에 쉽게 적응할 수 있습니다.\n\n컴포넌트를 더 일반적이고 설정 가능하며 유연하게 설계함으로써, 재사용성을 향상시킬 수 있습니다. 이러한 방식으로 컴포넌트를 다양한 시나리오에 적합하게 만들어 Angular 애플리케이션에서 코드 중복을 줄일 수 있습니다. 이는 유지보수성과 확장성을 촉진하며, 컴포넌트를 코드를 다시 작성하거나 복제하지 않고도 애플리케이션의 다양한 부분에서 쉽게 재사용할 수 있도록 돕습니다.\n\n<div class=\"content-ad\"></div>\n\n## 더 자세히 알아보기:\n\n## 비효율적인 변경 감지\n\n아래는 Angular 컴포넌트에서 비효율적인 변경 감지의 예시입니다:\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user',\n  template: `\n    <div>\n      <h1>{ user.name }</h1>\n      <p>{ user.age }</p>\n    </div>\n  `,\n})\nexport class UserComponent {\n  @Input() user: User; // User는 사용자 데이터를 표현하는 인터페이스 또는 클래스입니다\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예제에서 UserComponent에는 사용자 데이터를 입력으로받는 @Input() 속성 바인딩이 있는 user라는 속성이 있습니다. 기본적으로 Angular는 \"CheckAlways\" 변경 감지 전략을 사용합니다. 이것은 부모 구성요소에 변경이 발생할 때마다 사용자 입력 속성과 관련이 없어도 Angular가 UserComponent를 다시 렌더링하고 불필요한 뷰 업데이트를 일으킬 수 있어 성능 문제를 일으킬 수 있습니다.\n\n변경 감지 전략을 최적화하고 불필요한 뷰 업데이트를 피하기 위해 \"OnPush\" 변경 감지 전략을 사용할 수 있습니다. 이는 @Input() 속성의 참조가 변경될 때만 변경 감지가 트리거되는 변경 감지 전략을 사용합니다. 다음은 예시입니다:\n\n```js\nimport { Component, Input, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-user',\n  template: `\n    <div>\n      <h1>{ user.name }</h1>\n      <p>{ user.age }</p>\n    </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush, // 변경 감지 전략을 OnPush로 설정\n})\nexport class UserComponent {\n  @Input() user: User; // User는 사용자 데이터를 나타내는 인터페이스나 클래스입니다\n}\n```\n\n\"OnPush\" 변경 감지 전략을 사용하면 사용자 입력 속성의 참조가 변경될 때만 UserComponent에서 변경 감지가 수행되므로, 사용자 데이터가 자주 변경되지 않는 경우에는 보다 효율적인 변경 감지와 성능이 향상됩니다.\n\n<div class=\"content-ad\"></div>\n\n앵귤러 애플리케이션에서 각 구성 요소에 적합한 변경 감지 전략을 신중하게 선택하여 성능을 최적화하고 불필요한 뷰 업데이트를 방지하는 것이 중요합니다.\n\n## 반응형 프로그래밍을 사용하지 않는 경우\n\n다음은 폼 처리에 반응형 프로그래밍을 사용하지 않는 예제입니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { FormGroup, FormControl, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-login-form',\n  template: `\n    <form (ngSubmit)=\"onSubmit()\">\n      <input type=\"text\" [(ngModel)]=\"username\" name=\"username\" required>\n      <input type=\"password\" [(ngModel)]=\"password\" name=\"password\" required>\n      <button type=\"submit\">Login</button>\n    </form>\n  `,\n})\nexport class LoginFormComponent {\n  username: string;\n  password: string;\n\n  onSubmit() {\n    // 사용자 이름과 비밀번호로 폼 제출 로직\n    // ...\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위 예제에서는 LoginFormComponent가 템플릿 기반 폼과 ngModel을 사용하여 양방향 데이터 바인딩을 처리합니다. 하지만 이 접근 방식은 복잡하고 오류를 발생할 가능성이 있는 코드로 이어질 수 있습니다. 이는 폼 상태를 수동으로 관리하고 폼 유효성을 처리해야하기 때문입니다.\n\nAngular의 ReactiveFormsModule와 반응형 프로그래밍을 활용한 대안적 접근 방식은 다음과 같습니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { FormGroup, FormControl, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-login-form',\n  template: `\n    <form [formGroup]=\"loginForm\" (ngSubmit)=\"onSubmit()\">\n      <input formControlName=\"username\" required>\n      <input formControlName=\"password\" type=\"password\" required>\n      <button type=\"submit\">Login</button>\n    </form>\n  `,\n})\nexport class LoginFormComponent {\n  loginForm: FormGroup;\n\n  constructor() {\n    this.loginForm = new FormGroup({\n      username: new FormControl('', [\n        Validators.required,\n        Validators.pattern(/^\\S+$/), // enforce non-whitespace characters\n      ]),\n      password: new FormControl('', Validators.required, Validators.minLength(8)),\n    });\n  }\n\n  onSubmit() {\n    if (this.loginForm.invalid) {\n      // 폼이 유효하지 않음, 에러 처리\n      return;\n    }\n\n    const username = this.loginForm.get('username').value.trim();\n    const password = this.loginForm.get('password').value;\n\n    // 사용자 이름과 암호를 사용한 폼 제출 로직\n    // ...\n  }\n}\n```\n\n이 예제에서는 LoginFormComponent가 FormGroup 및 FormControl을 사용하여 Angular의 ReactiveFormsModule로 폼 입력을 반응적으로 처리합니다. 이를 통해 폼 상태를 효과적으로 제어할 수 있고, 보다 복잡한 폼 유효성을 처리할 수 있으며, 컴포넌트 로직에서 폼 데이터 처리를 단순화할 수 있습니다. Angular의 반응형 폼과 RxJS를 활용하면 응용 프로그램 상태 관리를 크게 간소화하고, 코드 유지 관리성을 향상시키며, 오류를 발생시킬 가능성을 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n리액티브 프로그래밍 특성을 활용하면 Angular의 리액티브 폼과 RxJS와 같은 기능을 사용하여 Angular 애플리케이션에서 오류 발생 가능성을 줄일 수 있습니다. 다음은 몇 가지 방법입니다:\n\n- 강한 타이핑: 리액티브 폼을 사용하면 TypeScript 인터페이스나 클래스를 활용하여 폼 데이터의 형태와 유형을 정의할 수 있습니다. 이를 통해 컴파일 시간 타입 체크를 제공하여 런타임이 아닌 빌드 시간에 타입 관련 오류를 찾아낼 수 있습니다. 이로써 잘못된 데이터 유형 전달 또는 정의되지 않은 속성 접근과 같은 문제를 방지할 수 있습니다.\n- 선언적 유효성 검사: 리액티브 폼을 사용하면 내장된 유효성 검사기나 사용자 정의 유효성 검사기를 활용하여 선언적으로 폼 유효성을 정의할 수 있습니다. 이를 통해 폼 입력의 복잡한 유효성 규칙을 정의하고 관리하기가 더 쉬워집니다. 유효성 검사 논리는 폼 내부에 캡슐화되어 있어 응용 프로그램의 다른 부분에 걸쳐 유효성 검사 논리의 일관성 또는 오류 발생 가능성을 줄일 수 있습니다.\n- 불변 데이터 흐름: 리액티브 프로그래밍은 불변 데이터 흐름을 장려하며 데이터를 불변이라고 다루고 변경 사항을 이벤트 스트림을 통해 수행합니다. 이를 통해 데이터의 직접적인 변이를 방지하여 예기치 않은 데이터 변이나 부작용으로 인한 오류 발생 가능성을 줄일 수 있습니다.\n- 명시적 상태 관리: RxJS를 사용한 리액티브 프로그래밍은 데이터 및 상태 변경의 흐름을 명시적으로 만들어줍니다. 이벤트 스트림이 관찰 가능하며 구독할 수 있기 때문에 데이터 및 상태 변경 흐름에 대해 추론하기가 더 쉬워질 수 있습니다. 이를 통해 숨겨진 또는 예상치 못한 상태 변경으로 인한 버그 발생 가능성을 줄일 수 있습니다.\n- 코드 조직 개선: 리액티브 프로그래밍은 관심사의 분리와 데이터 및 이벤트 처리에 더 기능적인 접근을 장려합니다. 결과적으로 조직화되고 모듈화된 코드와 역할의 명확한 분리로 인해 코딩이 더 용이해지며, 결합도가 높거나 흩어진 코드로 인한 오류가 줄어듭니다.\n- 오류 처리: RxJS를 사용한 리액티브 프로그래밍은 오류 처리 메커니즘을 내장하고 있어, 오류 처리 연산자와 같은 것을 통해 보다 체계적이고 집중적으로 오류를 처리할 수 있습니다. 이는 응용 프로그램이 크래시되거나 예상치 못한 동작을 일으킬 수 있는 처리되지 않은 오류를 방지하는 데 도움이 됩니다.\n\nAngular 애플리케이션에서 리액티브 폼과 RxJS와 같은 리액티브 프로그래밍 기능을 활용하면 오류 발생 가능성이 줄어들고 코드 유지 관리성이 향상되며, 더 견고하고 신뢰할 수 있는 애플리케이션을 개발할 수 있습니다.\n\n## 메모리 관리 부적절(runtime error)\n\n<div class=\"content-ad\"></div>\n\nAngular 애플리케이션에서 메모리 관리를 잘못한 예시를 몇 가지 들었습니다:\n\n옵저버블을 올바르게 해제하지 않기:\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <!-- Display products -->\n  `\n})\nexport class ProductListComponent implements OnInit {\n  products: Product[];\n\n  constructor(private dataService: DataService) {}\n\n  ngOnInit() {\n    // 데이터 서비스로부터 제품을 가져와 옵저버블을 구독합니다.\n    this.dataService.getProducts()\n      .subscribe(products => this.products = products);\n  }\n}\n```\n\n이 예시에서 ProductListComponent는 DataService에 의해 반환된 옵저버블을 구독하여 제품을 가져옵니다. 그러나 컴포넌트가 파괴되기 전에 옵저버블을 해지하지 않아 옵저버블이 완료되기 전에 컴포넌트가 파괴된 경우 메모리 누수가 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위의 예제를 개선하려면 다음과 같이 unsubscribe 메서드를 추가할 수 있습니다:\n\n```js\nimport { Component, OnInit, OnDestroy } from '@angular/core';\nimport { DataService } from './data.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <!-- Display products -->\n  `\n})\nexport class ProductListComponent implements OnInit, OnDestroy {\n  // ...\n\n  ngOnDestroy() {\n    // 메모리 누수를 방지하기 위해 옵저버에 대한 구독 취소\n    this.subscription.unsubscribe();\n  }\n}\n```\n\nAngular의 의존성 주입 시스템의 잘못된 사용:\n\n```js\nimport { Component, Injector } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <!-- Display products -->\n  `,\n  providers: [DataService]\n})\nexport class ProductListComponent {\n  constructor(private injector: Injector) {\n    // 의존성 주입기를 사용하여 데이터 서비스에서 제품 가져오기\n    const dataService = this.injector.get(DataService);\n    dataService.getProducts().subscribe(products => {\n      // 제품 처리\n    });\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예에서 ProductListComponent는 Angular의 Injector를 사용하여 수동으로 DataService의 인스턴스를 생성하고 가져오는 중입니다. this.injector.get(DataService)를 사용하여. 그러나 이 방식은 DataService가 Angular의 DI 시스템에 의해 적절하게 관리되지 않으면 메모리 누수로 이어질 수 있습니다. Angular는 컴포넌트가 파괴될 때 인스턴스를 자동으로 정리하지 않기 때문입니다.\n\nAngular의 의존성 주입 시스템의 올바른 사용법:\n\n```js\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <!-- 제품 표시 -->\n  `,\n  providers: [DataService]\n})\nexport class ProductListComponent {\n  constructor(private dataService: DataService) {\n    // 데이터 서비스로부터 제품 가져오기\n    this.dataService.getProducts().subscribe(products => {\n      // 제품 처리\n    });\n  }\n}\n```\n\n이 향상된 예에서는 ProductListComponent가 Angular의 의존성 주입 시스템을 올바르게 활용하도록 개선되었습니다. DataService를 직접 컴포넌트 생성자에 주입함으로써 Angular가 DataService 인스턴스를 관리하고 컴포넌트가 파괴될 때 올바르게 정리하며, 메모리 누수를 방지하고 메모리 관리를 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## 성능 최적화 부족\n\nngFor와 trackBy를 사용하지 않음:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <ul>\n      <li *ngFor=\"let product of products\">{ product }</li>\n    </ul>\n  `\n})\nexport class ExampleComponent {\n  products: Product[] = [\n    { id: 1, name: 'Product 1' },\n    { id: 2, name: 'Product 2' },\n    { id: 3, name: 'Product 3' }\n  ];\n\n  // 음이 아닌 경우가 뭐죠? trackBy 함수가 제공되지 않았습니다\n}\n```\n\n이 예에서 *ngFor 지시문을 사용하여 항목 목록을 렌더링합니다. 그러나 각 항목을 참조에 따라 비교하는 기본 추적 전략을 사용하며 항목을 변경할 때 전체 목록을 다시 렌더링합니다. 이는 특히 대규모 목록의 경우 비효율적일 수 있으며 불필요한 DOM 업데이트를 유발할 수 있습니다. 각 항목에 대해 고유 식별자를 반환하는 trackBy 함수를 제공함으로써 Angular는 렌더링 프로세스를 최적화하고 DOM 업데이트 수를 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <ul>\n      <li *ngFor=\"let product of products; trackBy: trackByProductId\">{ product.name }</li>\n    </ul>\n  `\n})\nexport class ExampleComponent {\n  products: Product[] = [\n    { id: 1, name: 'Product 1' },\n    { id: 2, name: 'Product 2' },\n    { id: 3, name: 'Product 3' }\n  ];\n\n  trackByProductId(index: number, product: Product): number {\n    return product.id; // Use a unique identifier for the product, such as an ID or a unique property value\n  }\n}\n\ninterface Product {\n  id: number;\n  name: string;\n}\n```\n\n이 업데이트된 버전에서는 trackByProductId 함수가 컴포넌트에 추가되었습니다. 이 함수는 템플릿의 ngFor 지시문의 trackBy 입력에 바인딩되어 있습니다. trackByProductId 함수는 ngFor 지시문에서 인덱스와 제품을 가져와 제품의 고유 식별자를 반환합니다. 이 경우에는 제품 객체의 id 속성입니다. 이렇게 함으로써 Angular은 제품을 효율적으로 추적하고 필요할 때에만 DOM을 업데이트하여 성능을 향상시키고 불필요한 DOM 업데이트를 줄일 수 있습니다. 또한 템플릿에서 product.name을 사용하여 제품의 이름을 표시하는 대신 전체 제품 객체를 사용하면 DOM의 불필요한 렌더링을 줄일 수 있습니다.\n\nHTTP 요청 최적화하지 않기:\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- API에서 데이터 표시 -->\n    <div *ngFor=\"let data of apiData\">{ data }</div>\n  `\n})\nexport class ExampleComponent implements OnInit {\n  apiData: any[];\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    // 컴포넌트 초기화 시 API 요청\n    this.http.get('https://api.example.com/data')\n      .subscribe(response => {\n        this.apiData = response;\n      });\n  }\n\n   // 앗! API 요청이 최적화되지 않았네요\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 HttpClient 모듈을 사용하여 컴포넌트 초기화 시 API 요청을 보내어 데이터를 가져오는 예제가 나와 있습니다. 그러나 캐싱, 디바운싱 또는 페이지네이션과 같은 최적화가 적용되지 않았습니다. 이로 인해 불필요한 HTTP 요청이 여러 번 발생하여 성능 문제가 발생하고 애플리케이션 실행이 느려질 수 있습니다. API 응답을 캐싱하거나 짧은 시간 내에 여러 요청을 방지하기 위해 디바운싱을 적용하거나 데이터를 더 작은 단위로 가져오기 위해 페이지네이션을 사용함으로써 애플리케이션의 성능을 향상시킬 수 있습니다.\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { debounceTime, tap } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- API에서 데이터 표시 -->\n    <div *ngFor=\"let data of apiData\">{{ data }}</div>\n    <!-- 로딩 스피너 표시 -->\n    <div *ngIf=\"loading\">데이터 로드 중...</div>\n    <!-- 오류 메시지 표시 -->\n    <div *ngIf=\"error\">{{ error }}</div>\n    <!-- 더 많은 데이터 로드 버튼 표시 -->\n    <button (click)=\"loadMore()\" *ngIf=\"hasNextPage && !loading\">더 불러오기</button>\n  `\n})\nexport class ExampleComponent implements OnInit {\n  apiData: any[] = [];\n  loading: boolean = false;\n  error: string = '';\n  page: number = 1;\n  hasNextPage: boolean = true;\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    this.loadMore(); // 초기 데이터 로드\n  }\n\n  loadMore() {\n    if (this.loading || !this.hasNextPage) return; // 여러 요청 방지하고 데이터를 다 로드했을 때 로딩 중지\n    this.loading = true;\n    this.error = '';\n\n    this.http.get(`https://api.example.com/data?page=${this.page}`)\n      .pipe(\n        tap(response => {\n          // 새로운 데이터를 기존 데이터 배열에 추가\n          this.apiData = this.apiData.concat(response);\n        }),\n        debounceTime(300) // 빠른 API 요청을 방지하기 위해 디바운스 적용\n      )\n      .subscribe(\n        () => {\n          this.loading = false;\n          this.page++; // 다음 loadMore 요청을 위해 페이지 증가\n        },\n        error => {\n          this.loading = false;\n          this.error = '데이터 로드 실패'; // 오류 메시지 표시\n        }\n      );\n  }\n}\n```\n\n이 업데이트된 버전에서는 다음 최적화가 적용되었습니다:\n\n- 캐싱: 로드된 데이터가 apiData 배열에 캐싱되어 불필요한 API 요청 없이 빠른 데이터 검색 및 렌더링이 가능합니다.\n- 디바운싱: API 요청에 debounceTime 연산자가 적용되어 빠른 API 요청을 방지합니다. 사용자가 빠르게 스크롤하거나 구성 요소와 상호 작용할 때 불필요한 요청을 방지하기 위해 요청을 지정된 시간 (이 예제에서는 300밀리초) 동안 지연시킵니다.\n- 페이지네이션: 현재 API에서 로드되는 데이터 페이지를 추적하기 위해 페이지 변수를 사용합니다. 각 성공적인 API 요청 후 증가되며, 데이터를 페이지별로 가져오고 한꺼번에 모든 데이터를 로드하는 것이 아닌 데이터를 청크 단위로 로드하여 성능을 향상시킬 수 있습니다.\n- 로딩 표시 및 오류 처리: API 요청 중 더 나은 사용자 피드백을 제공하기 위해 로딩 스피너와 오류 메시지가 추가되었습니다. 데이터를 가져오는 동안 로딩 스피너가 표시되고 API 요청이 실패하면 오류 메시지가 표시되어 사용자 경험을 향상시킵니다.\n- 더 많이 불러오기 버튼: 사용자가 수동으로 API에서 더 많은 데이터를로드하게하는 \"불러오기\" 버튼이 추가되었습니다. 구성 요소가 처음 렌더링될 때 초기 데이터를 자동으로로드하는 것을 방지하고 사용자가 언제 데이터를 추가로로드할지 제어할 수 있도록합니다.\n\n<div class=\"content-ad\"></div>\n\n모듈에 대한 레이지 로딩을 활용하지 않았습니다:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home.component';\nimport { AboutComponent } from './about.component';\nimport { ContactComponent } from './contact.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n  { path: 'contact', component: ContactComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n이 예제에서 모든 컴포넌트(HomeComponent, AboutComponent, 그리고 ContactComponent)가 AppRoutingModule에서 직접 import되어 즉시 로드됩니다. 이는 응용 프로그램이 시작될 때 이러한 모든 컴포넌트가 로드되고 초기화된다는 것을 의미합니다. 실제로 필요하지 않은 경우에도 이로 인해 초기 응용 프로그램 시작 시간이 더 오래 걸릴 수 있고 성능이 저하될 수 있습니다.\n\n성능을 최적화하려면 Angular는 레이지 로딩을 제공합니다. 이를 통해 모듈과 컴포넌트가 실제로 필요할 때만 로드할 수 있습니다. 모듈에 대한 레이지 로딩을 활용하여 초기 번들 크기를 줄이고 응용 프로그램의 시작 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nconst routes: Routes = [\n  { path: '', loadChildren: () => import('./home.component').then(m => m.HomeComponent) },\n  { path: 'about', loadChildren: () => import('./about.component').then(m => m.AboutComponent) },\n  { path: 'contact', loadChildren: () => import('./contact.component').then(m => m.ContactComponent) }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n이 갱신된 버전에서 route 설정에서 component 속성 대신 loadChildren 속성을 사용했습니다. loadChildren 속성은 import() 문을 사용하여 동적으로 구성 요소를 로드하는 함수를 지정하며, 구성 요소를 게으르게 로드하게 합니다.\n\n게으르게 로딩을 통해 사용자가 실제로 액세스할 때만 구성 요소를로드할 수 있으므로, 애플리케이션의 초기 로드 시간이 향상되고 미리로드해야 하는 코드 양이 줄어듭니다. 이는 특히 다수의 구성 요소와 복잡한 라우팅 구성이 있는 대규모 응용 프로그램에서 빠른로드 시간과 향상된 성능을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 보안 최적 사례 무시하기\n\n크로스사이트 스크립팅(XSS) 방어 무시하기:\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div [innerHTML]=\"unsafeHtml\"></div>\n  `\n})\nexport class ExampleComponent {\n  @Input() unsafeHtml: string;\n\n  // 어이쿠! 안전하지 않은 HTML이 템플릿에 직접 바인딩되어 있습니다.\n}\n```\n\n이 예에서 unsafeHtml 속성은 [innerHTML]을 사용하여 템플릿에 직접 바인딩됩니다. 이는 unsafeHtml에 전달된 악의적인 HTML 코드가 적절히 살균 처리되지 않고 그대로 렌더링되어 애플리케이션이 크로스사이트 스크립팅(XSS) 공격을 당할 가능성이 있습니다. XSS 공격을 방지하려면 Angular에서 DomSanitizer 서비스와 같은 내장 살균 메커니즘을 제공하므로 템플릿에 렌더링하기 전에 동적 콘텐츠를 적절히 살균 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```typescript\nimport { Component, Input } from '@angular/core';\nimport { DomSanitizer, SafeHtml } from '@angular/platform-browser';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div [innerHtml]=\"safeHtml\"></div>\n  `\n})\nexport class ExampleComponent {\n  @Input() unsafeHtml: string;\n  safeHtml: SafeHtml;\n\n  constructor(private sanitizer: DomSanitizer) {}\n\n  ngOnInit() {\n    // 안전하지 않은 HTML을 살균 처리합니다.\n    this.safeHtml = this.sanitizer.sanitize(\n      // 허용되는 HTML 요소 및 속성 목록을 사용합니다.\n      this.unsafeHtml,\n      { \n        allowedTags: ['div', 'span', 'a'], \n        allowedAttributes: { 'a': ['href'] } \n      }\n    );\n  }\n}\n```\n\n`ngOnInit()` 메서드에서는 `DomSanitizer` 서비스의 `sanitize()` 메서드를 사용하여 입력된 HTML 코드를 살균 처리합니다. `sanitize()` 메서드에 두 가지 인수를 전달합니다.\n\n- 잠재적으로 위험한 HTML 코드가 포함된 `unsafeHtml` 문자열입니다.\n- 허용되는 HTML 요소 및 속성을 정의하는 객체입니다.\n\n이 예제에서는 div, span, a 요소 및 a 요소의 href 속성만 허용하는 작은 화이트리스트를 정의했습니다. `unsafeHtml` 문자열에 있는 다른 요소나 속성은 살균 처리 중에 제거됩니다.\n\n\n<div class=\"content-ad\"></div>\n\nThe `sanitize()` 메서드는 안전한 HTML 코드를 포함하는 문자열을 반환하며, 그것을 `safeHtml` 속성에 할당합니다. `safeHtml` 속성은 `SafeHtml` 유형이며, Angular에서 HTML을 신뢰하고 기본 보안 검사를 우회하기 위해 사용하는 래퍼 클래스입니다. \n\n컴포넌트에서 렌더링하기 전에 잠재적으로 위험한 HTML 코드를 DomSanitizer 서비스를 사용하여 안전하게 처리함으로써 HTML에 포함된 악성 코드로 발생할 수 있는 XSS 공격의 위험을 줄일 수 있습니다.\n\nCross-Site Request Forgery (CSRF) 방지 무시:\n\n```js\nimport { HttpClient } from '@angular/common/http';\n\nexport class ExampleService {\n  constructor(private http: HttpClient) {}\n\n  public updateData(data: any) {\n    // 저런! 요청에 CSRF 토큰이 포함되지 않았습니다\n    return this.http.post('https://api.example.com/update', data);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 Angular 서비스의 updateData 메서드는 서버의 데이터를 업데이트하기 위해 POST 요청을 수행합니다. 그러나 요청에 Cross-Site Request Forgery (CSRF) 토큰이 포함되어 있지 않아 애플리케이션이 CSRF 공격에 취약해질 수 있습니다. Angular는 HTTP 요청에 자동으로 CSRF 토큰을 포함하여 기본 CSRF 보호 기능을 제공하지만, 적절한 설정과 사용법이 필요합니다. CSRF 보호를 무시하면 애플리케이션이 보안 위험에 노출될 수 있습니다.\n\n```js\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\n\nexport class ExampleService {\n  constructor(private http: HttpClient) {}\n\n  public updateData(data: any) {\n    // 요청 헤더에 CSRF 토큰 포함\n    const headers = new HttpHeaders().set('X-CSRF-TOKEN', '여기에_csrf_토큰_입력');\n    return this.http.post('https://api.example.com/update', data, { headers });\n  }\n}\n```\n\n이 업데이트된 버전에서는 HttpHeaders 클래스를 @angular/common/http에서 import하여 CSRF 토큰을 포함하는 새로운 헤더 객체를 생성합니다. X-CSRF-TOKEN 헤더는 적절한 CSRF 토큰 값으로 설정되어야 하며, 이는 안전한 소스(예: 서버 측)에서 얻어진 후 HTTP 요청과 함께 전달되어야 합니다. 이를 통해 CSRF 공격으로부터 보호를 제공하며, 서버 측에서 요청의 신뢰성을 확인합니다. CSRF 토큰을 얻고 포함하는 실제 방법은 애플리케이션의 백엔드 아키텍처 및 보안 구성에 따라 다를 수 있음을 참고해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <input [(ngModel)]=\"username\" placeholder=\"Username\">\n    <button (click)=\"login()\">Login</button>\n  `\n})\nexport class ExampleComponent {\n  username: string;\n\n  public login() {\n    // 앗! 입력 유효성 검사가 수행되지 않았어요\n    if (this.username === 'admin') {\n      // 관리자 액세스 부여\n    } else {\n      // 일반 사용자 액세스 부여\n    }\n  }\n}\n```\n\n이 예제에서는 Angular 컴포넌트에서 간단한 로그인 기능이 구현되어 있어요. 그러나 사용자명 입력에 대한 입력 유효성 검사가 수행되지 않아 악의적인 입력이 가능해지고 SQL 삽입, 코드 삽입 또는 권한 상승 공격과 같은 보안 취약점이 발생할 수 있어요. 데이터 유형, 길이, 형식 및 허용되는 문자를 포함한 적절한 사용자 입력 유효성 검사는 애플리케이션 내의 보안 위험을 방지하는 데 중요해요.\n\n```js\nimport { Component, FormBuilder, FormGroup, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <form [formGroup]=\"loginForm\">\n      <input formControlName=\"username\" placeholder=\"Username\">\n      <button (click)=\"login()\">Login</button>\n    </form>\n  `\n})\nexport class ExampleComponent {\n  loginForm: FormGroup;\n\n  constructor(private formBuilder: FormBuilder) {\n    this.loginForm = this.formBuilder.group({\n      username: ['', Validators.required, Validators.pattern(/^\\S*$/)]\n    });\n  }\n\n  public login() {\n    if (this.loginForm.valid) {\n      const username = this.loginForm.value.username;\n      if (username === 'admin') {\n        // 관리자 액세스 부여\n      } else {\n        // 일반 사용자 액세스 부여\n      }\n    }\n  }\n}\n```\n\n이 업데이트된 버전에서 Reactive Forms를 사용하고 있어요. [(ngModel)]을 사용하는 대신 Angular의 Reactive Forms 접근 방식을 고려해보세요. Reactive Forms는 양방향 데이터 바인딩보다 더 많은 제어와 유연성을 제공하며 양식 유효성 검사 및 데이터 처리에 관한 추가적인 기능을 제공해요.\n\n\n<div class=\"content-ad\"></div>\n\n## 테스트 부족\n\n단위 테스트 부족:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div *ngIf=\"isLoggedIn\">Welcome, { username }!</div>\n    <div *ngIf=\"!isLoggedIn\">Please login</div>\n  `\n})\nexport class ExampleComponent {\n  isLoggedIn: boolean;\n  username: string;\n\n  // 안타깝게도, 이 컴포넌트 로직을 다루는 단위 테스트가 없습니다.\n}\n```\n\n이 예시에서, Angular 컴포넌트는 isLoggedIn 플래그에 기반한 조건부 렌더링을 사용하여 간단한 로그인 기능을 구현했습니다. 그러나 이 컴포넌트 로직을 다루는 단위 테스트가 작성되지 않았습니다. 단위 테스트 부족은 발견되지 않은 버그로 이어지며 개발 또는 유지보수 중에 문제를 식별하고 해결하기 어렵게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { ExampleComponent } from './example.component';\n\ndescribe('ExampleComponent', () => {\n  let component: ExampleComponent;\n  let fixture: ComponentFixture<ExampleComponent>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ExampleComponent]\n    });\n    fixture = TestBed.createComponent(ExampleComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should display welcome message when isLoggedIn is true', () => {\n    component.isLoggedIn = true;\n    component.username = 'John';\n    fixture.detectChanges();\n    const welcomeElement = fixture.nativeElement.querySelector('div');\n    expect(welcomeElement.textContent).toContain('Welcome, John!');\n  });\n\n  it('should display login message when isLoggedIn is false', () => {\n    component.isLoggedIn = false;\n    fixture.detectChanges();\n    const loginElement = fixture.nativeElement.querySelector('div');\n    expect(loginElement.textContent).toContain('Please login');\n  });\n});\n```\n\n위 예제에서는 Angular Testing Utilities의 TestBed를 사용하여 테스트 모듈을 구성하고 생성하고, ComponentFixture를 사용하여 테스트 중에 구성 요소의 인스턴스를 만들고 조작합니다. fixture.detectChanges() 메서드는 변경 감지를 트리거하고 구성 요소의 뷰를 업데이트합니다.\n\nit 문은 구성 요소의 동작에 대한 기대치를 정의합니다. isLoggedIn이 true로 설정되었을 때 올바른 사용자 이름이 포함된 환영 메시지가 표시되고, isLoggedIn이 false로 설정되었을 때 로그인 메시지가 표시되는지 확인합니다.\n\n참고: 이것은 기본적인 예제일 뿐이며, 특정 요구 사항과 구성 요소 논리에 기반하여 테스트를 사용자 정의해야 할 수 있습니다. 모든 가능한 시나리오를 철저히 테스트하여 구성 요소의 정확성과 신뢰성을 보증하는 것이 중요합니다.\n  \n\n<div class=\"content-ad\"></div>\n\n## 여기서 더 알아보세요:\n\nEnd-to-End (e2e) 테스트 부재:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- ... 템플릿 코드 ... -->\n  `\n})\nexport class ExampleComponent {\n  // 이런! 이 컴포넌트의 기능을 커버하는 end-to-end (e2e) 테스트가 없어요\n}\n```\n\n이 예시에서 Angular 컴포넌트는 다양한 사용자 상호작용(예: 폼 제출, API 호출, DOM 조작)을 포함한 복잡한 기능을 구현합니다. 그러나 이 컴포넌트의 기능을 커버하는 end-to-end (e2e) 테스트가 작성되어 있지 않습니다. e2e 테스트 부재는 사용자 상호작용, 데이터 흐름, 컴포넌트, 서비스, API 간 통합과 관련된 발견되지 않은 문제를 초래할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n적절한 테스트, 단위 테스트 및 엔드 투 엔드 테스트를 포함한 적절한 테스팅은 개발 프로세스 초기에 문제를 식별하고 수정하는 데 중요합니다. 이를 통해 애플리케이션의 신뢰성과 안정성을 보장하고 앞으로의 유지 보수 및 업데이트를 용이하게 합니다.\n\n```js\nimport cy from 'cypress';\n\ndescribe('ExampleComponent', () => {\n  beforeEach(() => {\n    // 예: ExampleComponent 페이지로 이동하는 설정 작업 수행\n    cy.visit('/example');\n  });\n\n  it('로그인한 경우 환영 메시지가 표시되어야 함', () => {\n    // 예: 유효한 사용자 이름으로 로그인하는 사전 조건 설정\n    // Cypress의 명령을 사용하여 구성 요소의 DOM과 상호 작용할 수 있습니다.\n    cy.get('input').type('john');\n    cy.get('button').click();\n\n    // 예상되는 결과 확인, 예: 환영 메시지가 표시되는지 확인\n    cy.get('div').should('contain.text', 'Welcome, john!');\n  });\n\n  it('로그인하지 않은 경우 로그인 메시지가 표시되어야 함', () => {\n    // 예: 로그아웃하거나 로그인하지 않은 사전 조건 설정\n    // Cypress의 명령을 사용하여 구성 요소의 DOM과 상호 작용할 수 있습니다.\n\n    // 예상되는 결과 확인, 예: 로그인 메시지가 표시되는지 확인\n    cy.get('div').should('contain.text', 'Please login');\n  });\n});\n```\n\n위 예제에서는 Angular 애플리케이션용으로 인기 있는 엔드 투 엔드 테스트 프레임워크인 Cypress를 사용하고 있습니다. Cypress를 사용하면 애플리케이션과 상호 작용을 시뮬레이션하고 결과 DOM에 대한 단언을 수행할 수 있습니다.\n\n이 코드의 주요 포인트 요약은 다음과 같습니다:```\n\n<div class=\"content-ad\"></div>\n\n- 위 코드는 ExampleComponent에 대한 테스트 스위트를 정의합니다.\n- beforeEach 훅은 각 테스트 케이스를 실행하기 전에 일부 설정 작업을 실행하는 데 사용됩니다. 이 경우에는 cy.visit를 사용하여/example 페이지로 이동합니다.\n- 첫 번째 테스트 케이스(it)는 유효한 사용자 이름으로 로그인할 때 환영 메시지가 표시되는지 확인합니다. 이를 위해 Cypress의 cy.get 명령을 사용하여 입력 요소에 사용자 이름을 입력하고 버튼 요소를 클릭한 다음, should 명령과 contain.text 단언을 사용하여 div 요소가 예상 텍스트를 포함하는지 확인합니다.\n- 두 번째 테스트 케이스는 사용자가 로그인하지 않은 경우 로그인 메시지가 표시되는지 확인합니다. 이를 위해 div 요소가 예상 텍스트를 포함하는지 확인합니다.\n- 두 테스트 케이스 모두 Cypress의 명령 인터페이스(cy)를 사용하여 구성 요소의 DOM과 예상 결과에 대한 단언을 만듭니다.\n- describe 블록은 테스트 스위트를 캡슐화하고 이를 위한 설명적인 이름을 제공합니다.\n\n참고: 이는 기본적인 예시이며, 특정 응용 프로그램의 설정 및 요구 사항에 맞게 테스트를 사용자 정의해야 할 수 있습니다. 구성 요소의 최종 기능을 철저히 테스트하여 애플리케이션의 정확성과 신뢰성을 보증하는 것이 중요합니다.\n\n## Angular 최적 사례 무시\n\nAngular 최적 사례를 무시하면 이해하기, 유지 관리하기 및 확장하기 어려운 코드로 이어질 수 있습니다. Angular 최적 사례를 무시하는 몇 가지 예시는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- Angular 스타일 가이드를 따르지 않기: Angular는 명명 규칙, 파일 구성, 컴포넌트 아키텍처 등을 위한 지침을 제공하는 스타일 가이드가 있어요. 이러한 가이드를 무시하면 일관성이 없고 읽기 어려운 코드로 이어질 수 있어요. 예를 들어, 컴포넌트, 서비스 및 변수의 명명 규칙을 준수하지 않으면 코드베이스의 다른 부분의 목적과 기능을 이해하기 어려울 수 있어요. 또한 명명 충돌이 발생하고 문제를 식별하고 수정하기 어려워질 수 있어요.\n\n```js\n// Angular 스타일 가이드에 맞지 않는 예\n// 컴포넌트 클래스 이름에 PascalCase 사용 지침 무시\n// 컴포넌트 셀렉터에 kebab-case 사용 지침 무시\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'appExample', // 셀렉터에 kebab-case 사용하지 않음\n  templateUrl: './example.component.html',\n  styleUrls: ['./example.component.css']\n})\nexport class exampleComponent { // 클래스 이름에 PascalCase 사용하지 않음\n  // ...\n}\n```\n\n2. 권장된 폴더 구조를 따르지 않기: Angular는 컴포넌트, 서비스, 자산과 같은 다양한 파일 유형을 구성하기 위한 특정 폴더 구조를 권장해요. 권장된 구조를 무시하면 애플리케이션이 커지고 복잡해질수록 파일을 찾고 관리하기 어려워질 수 있어요. 예를 들어, 컴포넌트, 서비스 및 기타 파일을 각각의 폴더로 분리하지 않으면 혼잡하고 혼란스러운 디렉토리 구조로 이어질 수 있어요.\n\n```js\n// 권장된 폴더 구조를 따르지 않는 예\n// 컴포넌트를 별도의 폴더에 구성하는 지침 무시\n// 다른 파일에 대해 명확한 폴더 구조를 사용하지 않음\nsrc/\n  app/\n    components/\n      example.component.ts // 컴포넌트를 별도의 폴더에 구성하지 않음\n    services/\n      example.service.ts // 서비스를 별도의 폴더에 구성하지 않음\n    example.module.ts // 다른 파일에 대해 명확한 폴더 구조를 사용하지 않음\n    example.component.css\n    example.component.html\n```\n\n<div class=\"content-ad\"></div>\n\n3. Angular 기능을 적절하게 활용하지 않기: Angular은 개발을 간단하게 만들고 성능을 향상시키며 유지 보수성을 향상시키기 위한 다양한 기능과 API를 제공합니다. 이러한 기능을 무시하거나 잘못 사용하면 최적화되지 않은 코드나 유지 관리가 어려운 코드로 이어질 수 있습니다. 예를 들어, Angular의 내장 의존성 주입(DI) 시스템을 활용하지 않으면 묶여 있는 코드나 테스트하기 어려운 코드를 얻게 될 수 있습니다.\n\n```js\n// Angular의 의존성 주입을 적절하게 사용하지 않은 예시\n// 서비스에 대한 의존성 주입 가이드라인을 무시한 예\nimport { Component } from '@angular/core';\nimport { ExampleService } from './example.service';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- ... 템플릿 코드 ... -->\n  `,\n  providers: [ExampleService] // 의존성 주입을 사용하지 않고 서비스를 주입하는 예\n})\nexport class ExampleComponent {\n  constructor() {\n    this.exampleService = new ExampleService(); // 의존성 주입을 사용하지 않고 서비스를 주입하는 예\n  }\n  // ...\n}\n```\n\nAngular의 최선의 실천 방법을 따르면 코드베이스를 유지보수 가능하고 확장 가능하며 업계 표준을 준수할 수 있습니다. Angular 애플리케이션의 최적 개발과 유지 관리를 위해 최신 Angular 최선의 실천 방법과 코딩 규칙과 일치하도록 코드베이스를 정기적으로 검토하고 업데이트하는 것이 중요합니다.\n\n## DOM 조작 최적화하지 않기\n\n<div class=\"content-ad\"></div>\n\n과도한 양방향 데이터 바인딩:\n\n```js\n<!-- 컴포넌트 템플릿 -->\n<input [(ngModel)]=\"username\" />\n```\n\n이 예에서는 username이라는 속성이 양방향 데이터 바인딩을 사용하여 입력 필드에 바인딩되었을 경우, 입력 필드의 변경이 발생하면 변경 감지가 트리거되어 DOM이 업데이트됩니다. 이로 인해 빈번하고 불필요한 DOM 업데이트가 발생할 수 있어, 대규모 양식이나 빈번히 업데이트되는 입력란을 다룰 때 퍼포먼스 문제가 발생할 수 있습니다.\n\n이를 최적화하기 위해 (input) 및 (change)와 같은 이벤트 핸들링을 사용하여 일방향 데이터 바인딩을 고려하고, 두방향 데이터 바인딩 대신 필요할 때만 컴포넌트 속성을 수동으로 업데이트할 수 있습니다. 다음은 이에 대한 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- 컴포넌트 템플릿 -->\n<input [value]=\"username\" (input)=\"onUsernameInput($event.target.value)\" />\n\n<!-- 컴포넌트 클래스 -->\nonUsernameInput(value: string) {\n  this.username = value;\n}\n```\n\nRenderer2 API를 사용하지 않고 안전한 DOM 업데이트를 하지 않은 예시:\n\n```js\n<!-- 컴포넌트 템플릿 -->\n<div [style.backgroundColor]=\"bgColor\">안녕, 세상아!</div>\n```\n\n이 예시에서 bgColor 속성은 div 요소의 style.backgroundColor 속성에 바인딩되어 있어, DOM 스타일을 직접 조작하고 있습니다. 그러나 DOM을 직접 조작하는 것은 위험할 수 있고 권장되지 않습니다. 이는 애플리케이션에 보안 취약점을 노출시키고 Angular의 내장 보안 기능을 우회할 수 있기 때문입니다.```\n\n<div class=\"content-ad\"></div>\n\n이를 최적화하기 위해 DOM을 안전하게 조작하는 Angular의 Renderer2 API를 사용할 수 있습니다. 예를 들어:\n\n```js\n<!-- 컴포넌트 템플릿 -->\n<div #myDiv>Hello, World!</div>\n```\n\n```js\n<!-- 컴포넌트 클래스 -->\nimport { Renderer2, ElementRef, ViewChild } from '@angular/core';\n\n@ViewChild('myDiv', { static: true }) myDiv: ElementRef;\n\nconstructor(private renderer: Renderer2) {}\n\nngOnInit() {\n  this.renderer.setStyle(this.myDiv.nativeElement, 'backgroundColor', this.bgColor);\n}\n```\n\n이 예에서는 Renderer2 API를 사용하여 div 요소의 배경색 스타일을 안전하게 설정하고 Angular의 보안 기능이 적용되어 DOM 조작이 최적화됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 에러 조건 처리하지 않기:\n\n실패한 HTTP 요청 처리하기:\n\nAngular 애플리케이션에서 실패한 HTTP 요청을 처리하지 않는 것이 어떤 문제를 일으킬 수 있는지 예시를 보여드리겠습니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div>{ data }</div>\n  `,\n})\nexport class ExampleComponent {\n  data: string;\n\n  constructor(private http: HttpClient) {}\n\n  getData() {\n    this.http.get('/api/data').subscribe(\n      (data) => {\n        this.data = data; // 검색한 데이터로 UI 업데이트\n      },\n      (error) => {\n        console.error('데이터 가져오기 실패:', error); // 에러 기록\n      }\n    );\n  }\n}\n```  \n\n<div class=\"content-ad\"></div>\n\n위 예시에서는 Angular의 HttpClient를 사용하여 HTTP GET 요청을 /api/data로 보내고 있습니다. http.get() 메서드로 반환된 Observable에 구독하여 데이터를 검색하고 있습니다. 그러나 subscribe() 메서드의 두 번째 콜백 함수를 사용하여 적절한 오류 처리를 구현하지 않았습니다.\n\n이로 인해 다음과 같은 문제가 발생할 수 있습니다:\n\n- 애플리케이션 충돌: HTTP 요청 중에 오류가 발생하는 경우(네트워크 오류 또는 서버 측 오류 등), 오류는 subscribe() 메서드의 오류 콜백으로 전달됩니다. 그러나 적절한 오류 처리를 구현하지 않았기 때문에 오류가 처리되지 않고, 이로 인해 예외가 발생하여 애플리케이션이 충돌할 수 있습니다.\n- 일관성 없는 동작: HTTP 요청 중에 오류가 발생하는 경우 데이터 속성이 업데이트되지 않을 수 있지만 UI는 여전히 사용자에게 불완전하거나 일관성 없는 정보를 표시할 수 있습니다. 이는 사용자 경험을 해치고 부정확한 애플리케이션 동작으로 이어질 수 있습니다.\n- 오류 가시성 부족: 적절한 오류 처리 없이 오류 메시지나 로그가 사용자에게 표시되지 않거나 디버깅을 위해 기록되지 않을 수 있습니다. 이는 애플리케이션의 문제를 식별하고 해결하는 데 어려움을 줄 수 있으며, 안정성과 신뢰성이 감소할 수 있습니다.\n\n이 문제를 해결하기 위해서는 사용자에게 오류 메시지를 표시하거나 디버깅을 위해 오류를 기록하고 오류에서 원활하게 복구하는 등의 적절한 오류 처리 메커니즘을 구현하는 것이 중요합니다. 이전 코드 예제에서 보여준 대로 이를 수행하여 Angular 애플리케이션의 안정성과 신뢰성을 확보할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { catchError } from 'rxjs/operators';\nimport { throwError } from 'rxjs';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div>{ data }</div>\n    <div class=\"error\" *ngIf=\"errorMessage\">{ errorMessage }</div>\n  `,\n})\nexport class ExampleComponent {\n  data: string;\n  errorMessage: string;\n\n  constructor(private http: HttpClient) {}\n\n  getData() {\n    this.http.get('/api/data').pipe(\n      catchError((error) => {\n        this.errorMessage = 'Failed to get data: ' + error; // Display error message\n        console.error('Failed to get data:', error); // Log error\n        return throwError(error); // Rethrow the error to propagate\n      })\n    ).subscribe(\n      (data) => {\n        this.data = data; // Update UI with retrieved data\n      }\n    );\n  }\n}\n```\n\n개선된 예시에서는 RxJS 라이브러리의 catchError 연산자를 사용하여 HTTP 요청 중 발생하는 오류를 처리했습니다. HTTP 요청 중 오류가 발생하면 catchError 연산자가 오류를 잡고 사용자 정의 오류 처리 논리를 구현할 수 있게 합니다. 이 경우 UI에 오류 메시지를 표시하고 오류를 콘솔에 로깅하고 있습니다. 또한 RxJS의 throwError를 사용하여 오류를 재전파하여 처리되지 않은 상태로 남지 않도록 하고 있습니다.\n\n적절한 오류 처리 메커니즘을 구현함으로써, HTTP 요청의 오류가 적절히 처리되고, 사용자에게 오류 메시지가 표시되며, 디버깅을 위해 오류가 로깅되고, 응용 프로그램이 안정적이고 신뢰할 수 있게 유지될 수 있습니다.\n\n예기치 않은 예외 처리:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <button (click)=\"onButtonClick()\">Click me</button>\n  `,\n})\nexport class ExampleComponent {\n  onButtonClick() {\n    // This code may throw an unexpected exception\n    throw new Error('Unexpected exception occurred');\n  }\n}\n```\n\n이 예시에서는 간단한 Angular 컴포넌트가 있는데, 버튼 클릭 이벤트 핸들러가 포함되어 있습니다. 버튼을 클릭하면 onButtonClick() 메서드가 호출되는데, 이 메서드에는 예상치 못한 예외가 발생할 수 있는 코드가 포함되어 있습니다. 그러나 이 예외를 잡고 처리하기 위한 오류 처리 메커니즘이 구현되어 있지 않습니다.\n\n예기치 못한 예외를 처리하지 않는 문제는 응용 프로그램을 충돌시키고 일관성없는 사용자 경험을 유발할 수 있다는 것입니다. 예상치 못한 예외가 발생하면 응용 프로그램이 알 수 없는 상태로 남아 있고, 사용자는 빈 화면이나 깨진 화면을 보거나 응용 프로그램이 응답하지 않을 수 있습니다. 더욱이, 예외가 처리되지 않았으므로 디버깅 목적으로 기록되지 않을 수도 있어 문제를 진단하고 해결하는 것이 어려울 수 있습니다.\n\n예상치 못한 예외를 잡고 처리하기 위해 try-catch 블록을 사용하거나 Angular에서 전역 오류 처리 기술을 사용하는 등 적절한 오류 처리 메커니즘을 구현하는 것이 중요합니다. 이는 응용 프로그램이 안정적이고 신뢰성 있게 유지되며, 예기치 않은 오류가 발생해도 일관된 사용자 경험을 제공하도록 보장합니다.```\n\n<div class=\"content-ad\"></div>\n\n```\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <button (click)=\"onButtonClick()\">Click me</button>\n    <div *ngIf=\"errorMessage\" class=\"error-message\">{ errorMessage }</div>\n  `,\n})\nexport class ExampleComponent {\n  errorMessage: string = '';\n\n  onButtonClick() {\n    try {\n      // This code may throw an unexpected exception\n      throw new Error('Unexpected exception occurred');\n    } catch (error) {\n      // Handle the error and display error message\n      this.errorMessage = 'An error occurred: ' + error.message;\n      console.error(error); // Log the error for debugging\n    }\n  }\n}\n```\n\n개선된 예시에서는 예기치 못한 예외가 발생할 수 있는 코드 주변에 try-catch 블록을 추가했습니다. 예외가 발생하면 catch 블록에서 잡히며, 사용자에게 오류 메시지를 표시하고 디버깅 목적으로 오류를 로깅할 수 있습니다. 예기치 못한 예외를 처리함으로써 응용 프로그램이 안정적으로 유지되고 예기치 않은 오류가 발생해도 일관된 사용자 경험을 제공할 수 있습니다.\n\n요약하면, Angular는 웹 응용 프로그램을 구축하기 위한 강력하고 기능이 풍부한 프레임워크이지만, 최적의 성능, 유지 관리 및 신뢰성을 보장하기 위해 개발자들이 인식하고 피해야 할 몇 가지 흔한 실수가 있습니다. 이러한 실수에는 부적절한 컴포넌트 설계, 비효율적인 변경 감지, 반응형 프로그래밍의 부재, 적절하지 않은 메모리 관리, 성능 최적화의 부족, 보안 모범 사례 무시, 테스트 부재, Angular 최상의 실천법 따르지 않기, 오류 상황 처리를 미뤄두는 것 등이 있습니다.\n\n이러한 일반적인 실수를 이해하고 해결함으로써, 개발자들은 원할하고 신뢰할 수 있는 Angular 애플리케이션을 만들 수 있습니다. 사용자 경험을 원활하게 제공하며 유지 가능하며 확장 가능하며 모범 사례를 준수하는 Angular 애플리케이션을 만들기 위해 Angular 문서를 준수하고 최신 모범 사례를 따르고 적절한 오류 처리, 테스트 및 성능 최적화 기법을 통합하는 것이 중요합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 리유저블 컴포넌트로 Angular 앱 만들기, 마치 레고처럼\n\n![Image](/assets/img/2024-05-18-10CommonMistakesinAngularDevelopment_1.png)\n\nBit는 오픈 소스 도구로 25만 명 이상의 개발자들이 컴포넌트를 사용해 앱을 구축할 수 있게 도와줍니다.\n\nUI, 기능 또는 페이지를 재사용 가능한 컴포넌트로 바꾸고 애플리케이션 간에 공유할 수 있습니다. 협업하기 쉽고 더 빨리 작업할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n→ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 쉽게 만들고 원하는 워크플로에 대한 최상의 경험을 즐기세요:\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n<div class=\"content-ad\"></div>\n\n## → 코드 공유 및 재사용\n\n## → Monorepo\n\n## 더 알아보기:\n\n[https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc](https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc)\n\n<div class=\"content-ad\"></div>\n\nhttps://blog.bitsrc.io/how-we-build-our-design-system-15713a1f1833","ogImage":{"url":"/assets/img/2024-05-18-10CommonMistakesinAngularDevelopment_0.png"},"coverImage":"/assets/img/2024-05-18-10CommonMistakesinAngularDevelopment_0.png","tag":["Tech"],"readingTime":38},{"title":"앵귤러에서 let을 사용하여 템플릿 로컬 변수 생성하기","description":"","date":"2024-05-18 21:55","slug":"2024-05-18-TemplatelocalvariableswithletinAngular","content":"\n\n![image](/assets/img/2024-05-18-TemplatelocalvariableswithletinAngular_0.png)\n\n# Angular에서 let 사용하기\n\nAngular를 오랫동안 사용해본 적이 있다면, 언젠가는 템플릿 내에서 변수를 선언하고 싶은 경우가 있을 것입니다. 이것은 나중에 템플릿에서 사용할 값을 저장하고 싶을 때 흔히 발생하는 상황입니다.\n\n가장 일반적인 방법은 ngIf와 같은 디렉티브를 사용하여 as 키워드를 이용해 변수에 값을 할당하는 것입니다. 예를 들면:\n\n<div class=\"content-ad\"></div>\n\n```js\n<div *ngIf=\"user$ | async as user\">\n  <h1>{ user.name }</h1>\n</div>\n\n<!-- 또는 새로운 제어 흐름 사용 -->\n@if (user$ | async; as user) {\n  <h1>{ user.name }</h1>\n}\n```\n\n숫자를 다루고 있을 때는 어떻게 될까요?\n\n```js\n<div>\n    @if (points$ | async; as points) {\n        <h1>당신은 { points } 포인트를 가지고 있습니다!</h1>\n    }\n</div>\n```\n\n템플릿에서 포인트가 0이라면 어떻게 표시될까요? 아무것도 표시되지 않을 것입니다! 왜냐하면 0은 falsy한 값이기 때문에 if 블록 내에서 사용될 때 내용을 표시하지 않습니다.```\n\n<div class=\"content-ad\"></div>\n\n새로운 @let 블록이 작용하는 곳입니다. @let 블록을 사용하면 템플릿 내에서 변수를 선언하고 나중에 템플릿에서 사용할 수 있습니다. 어떻게 작동하는지 살펴봅시다.\n\n```js\n<div>\n    @let points = (points$ | async) ?? 0;  \n    <h1>You have: { points } points!</h1>\n</div>\n```\n\n이렇게 하면 points가 0이더라도 내용이 렌더링됩니다. 이는 let 블록이 Falsy 값을 확인하지 않기 때문에 발생하는 것이며 템플릿에서 그 시점에 변수를 선언하기 때문입니다.\n\n또한, @let 블록의 가장 일반적인 사용 사례 중 하나는 복잡한 표현식에 대한 별칭을 저장할 수 있는 변수를 저장하는 것입니다. 예를 들어:\n\n<div class=\"content-ad\"></div>\n\n```js\n@let someField = someService.someSignal().someProperty.someOtherProperty;\n<div>{ someField }</div>\n```\n\n# Angular에서 @let 사용 방법\n\n다음은 새로운 @let를 여러 방법으로 사용할 수 있습니다:\n\n- 비동기 파이프와 함께:\n\n<div class=\"content-ad\"></div>\n\n\n```js\n<div>\n    @let user = (user$ | async) ?? { name: 'Guest' };  \n    <h1>{ user.name }</h1>\n</div>\n```\n\n- With control flow directives:\n\n```js\n<div>\n    @let user = user$ | async;  \n    @if (user) {\n        <h1>{ user.name }</h1>\n    }\n</div>\n```\n\n- Inside @for to refactor code duplications:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<mat-selection-list>\n    @for (item of items(); track item.id) {\n        @let isSelected = item.id === selectedId();\n        <mat-list-option [selected]=\"isSelected\" [class.selected]=\"isSelected\">\n            { item.text } \n            @if (isSelected) {\n                <span>(selected)</span>\n            }\n        </mat-list-option>\n    }\n</mat-selection-list>\n```\n\n- 삼항 연산자 활용:\n\n```js\n<div>\n    @for (game of games; track game.id) {\n        @let points = calcPoints(game.points > 0 ? game.points : 0);  \n        <h1>You have: { points } points!</h1>\n    }\n</div>\n```\n\n- 기본 산술 연산자 활용:\n\n<div class=\"content-ad\"></div>\n\n```js\n<div>\n   @for (게임 of 게임목록; 게임.id로 순회) {\n       @let 합계 = 이전합계 + 게임.점수; \n       <h1>총 점수: { 합계 }</h1>\n   }\n</div>\n```\n\n- 신호와 함께:\n\n```js\n<div>\n    @let 사용자이름 = 사용자()?.이름 ?? '손님';\n    <h1>환영합니다, { 사용자이름 }</h1>\n</div>\n```\n\n- 여러 선언을 한 줄에 나열하거나 여러 줄에 나눠서 선언하기:\n\n<div class=\"content-ad\"></div>\n\n```js\n<div>  \n    @let total = count + previousCount, average = calcAverage(count), (여기서 `total`을 사용할 수 있을까요?)\n    \n    @let total = count + previousCount, \n         average = calcAverage(count)\n    <h1>{total}</h1>\n</div>\n```\n\n# 좋은 정보\n\nlet 선언은 JavaScript의 let 선언과 거의 동일하게 작동합니다.\n\n- 스코핑은 JavaScript의 let과 동일하게 작동합니다.\n- 타입 추론이 그대로 작동합니다!\n- let 선언은 구성 속성보다 로컬 let 선언을 우선시합니다.\n- let 선언은 정의되기 전에 참조할 수 없으며, 예외는 이벤트 핸들러 내에서 사용될 때입니다. \n\n\n<div class=\"content-ad\"></div>\n\n이 기능은 2017년 3월부터 열려 있던 문제를 해결합니다.\n\n이 PR에서는 @let 블록이 도입되기 전에 고려된 여러 대안을 볼 수 있습니다.\n\n- @let 대신 @const\n- 새로운 키워드 전체\n- @let 대신 @var\n- 블록 형식의 구문\n\nPR에 대한 자세한 정보는 여기에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n여기서 새로운 @let 블록을 Angular 템플릿에서 사용하는 방법이 있습니다. 이 기능은 아마도 예상대로 다가오는 달에 출시될 Angular v18.1에서 사용 가능할 것으로 예상됩니다.\n\nAngular 템플릿에서 @let 블록의 다른 사용 사례에 대해 떠오르는 것이 있으면 알려주세요. 🚀\n\n# 읽어 주셔서 감사합니다!\n\n만약 이 글이 흥미로웠고 유용하다고 생각되고 Angular에 대해 더 배우고 싶다면, 제게 커피 한 잔 사주는 걸로 응원해주세요 ☕️ 또는 X(이전 트위터) @Enea_Jahollari에서 저를 팔로우해주세요. Angular 최신 뉴스, 신호, 비디오, 팟캐스트, 업데이트, RFC, 풀 리퀘스트 등에 대해 많이 트윗하고 블로깅합니다. 💎","ogImage":{"url":"/assets/img/2024-05-18-TemplatelocalvariableswithletinAngular_0.png"},"coverImage":"/assets/img/2024-05-18-TemplatelocalvariableswithletinAngular_0.png","tag":["Tech"],"readingTime":4},{"title":"3D로 감싼 벡터 필드와 연료 소비","description":"","date":"2024-05-18 21:52","slug":"2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D","content":"\n\n![image](/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_0.png)\n\n푸아송 방정식, 벡터 필드 및 특수 신경망 사이의 연결을 탐구하면서, 사용자 정의 벡터 필드 시각화를 만들기로 결정했습니다. 미적분의 몇 가지 경험적인 응용을 소개하고 싶습니다. 보트, 비행기 또는 차량을 보유하고 계신다면, 이 글을 마치면 돈을 아끼기 위해 어느 경로를 선택하고 언제 출발해야 하는지를 결정할 수 있을 겁니다. 대개의 여정에서 강한 해풍보다 강한 꼬리풍이 더 좋습니다.\n\n본 글의 목표는 공간을 통과하는 가장 일치하는 경로를 찾는 것입니다. 이를 달성하기 위해 일반적인 작업과 비용 함수 같은 기본적인 개념을 사용할 것입니다. 최적 제어의 의미에서 최적 경로를 찾는 것이 목표가 아니므로 글의 끝에 우리는 정확한 비행 또는 항해 당 소비량을 알지 못할 것입니다. 그러나 “주어진 벡터 필드에 대해, 이 경로는 최소한의 저항을 줄 것”이라고 말할 수 있을 것입니다. 하지만 나중에 특히 신경망과 결합하여 최적 제어 개념을 다시 살펴볼 수도 있을 것입니다. 이러한 분야는 매우 관련이 깊습니다.\n\n본 글에서 제시된 솔루션은 WebGL2와 TypeScript의 조합입니다. WebGL 개념은 제가 직접 구현했지만, 일부 계산 부분은 직접 구현하기 번거로울 수 있습니다. 즉, 방정식의 상징적 조작이나 노이즈 생성과 같은 부분은 제작자의 이해로 하여금 코드를 이해하는 데 아무런 영향을 끼치지 않아야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 소리를 내보세요\n\n보통 날씨 예보나 현재 바람 상황은 바람 깃발을 통해 설명됩니다. 이 바람 깃발은 특정 위치(경도, 위도, 고도)에서의 바람의 방향과 속도를 기본적으로 제공합니다. 이러한 데이터 포인트들은 벡터 필드를 형성합니다(공간의 각 점에서의 관련 스칼라 값과 방향). 하지만 스칼라 필드 같은 다른 종류의 필드들도 있습니다. 즉, 공간의 각 점에서의 온도와 같은 것입니다. 제 집 프로젝트에서는 벡터 필드 데이터가 저가 해결하고 있는 문제들에 해당하지만 연료 소비에 대한 경우와 이 게시물에서는 소음을 생성기로 사용할 것입니다.\n\n벡터 필드를 생성하기 위해 Simplex 소음을 사용할 것입니다. Simplex 소음의 중요한 성능 특성 중 하나는 생성된 소음의 차원과 매우 잘 조화를 이룬다는 것입니다. 다른 것들과 대조적으로, 예를 들어 퍼린 소음과 같은 것들과는 다르게요. 우리의 벡터 필드는 시간에 따라 변할 것이므로, 4차원 소음을 생성해야 하며 매 프레임은 사실상 그 4차원 공간에서의 3차원 슬라이스가 될 것입니다. Simplex 소음이 더 나은 성능을보일 수 있는 이유에 대해 상세히 다루는 공간이 없기 때문에 그것에 대한 자세한 내용을 다루지 않겠습니다. 그건 또 다른 전체 블로그 글이 될 것이지만 웹에서 많은 정보를 찾을 수 있습니다.\n\n우리의 사용 사례에 대해, 저는 이 소스에서 Simplex 구현을 사용했습니다. 이 결정의 뒤에 있는 이유는 쉐이더에서 직접 계산을 사용할 수 있는 가능성과 코드가 상당히 읽기 쉽기 때문입니다. 우리의 소음 기능인 N(x, y, z, t)는 `0, 1.0` 사이의 값입니다. 내부적으로 벡터 당 세 개의 랜덤 값이 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n- XY 평면 각도\n- XZ 평면 내 각도\n- 벡터 크기\n\n각 쌍은 z 매개변수에 대한 다른 상수 오프셋 샘플링을 통해 얻어집니다. 오프셋은 값이 교차하지 않도록 선택되므로 XY 각도는 N(x, y, z, t), XZ 각도는 N(x, y, z + 오프셋, t)이고 벡터 크기는 N(x, y, z + 2*오프셋, t)입니다. 중요 참고 사항은 서로 다른 노이즈 구현은 서로 다른 함수 범위를 가질 수 있으므로 항상 `0`, `1.0` 사이의 값을 얻을 수 없을 수도 있습니다.\n\n아래 벡터 필드의 시각화를 확인할 수 있습니다. 벡터 외에도 텍스처로 렌더링된 노이즈를 볼 수 있습니다 - 회색으로 분리되거나 RGB로 세 개의 채널로 결합됩니다.\n\n공간은 Z 축을 따라 n 개의 평면으로 분할되며, 각 평면은 그럼으로써 렌더링됩니다. 일반적으로 전체 노이즈 필드를 렌더링할 필요는 없지만, 시각화 목적으로 그렇게 합니다. 아래에서 보듯이, 하단 레이어는 노이즈 필드가 실제로 어떻게 보이는지 보여줍니다; 시간에 따라 변하는 회색 이미지입니다. 그런 다음 오프스크린 텍스처를 가져와서 우리의 벡터를 그릴 수 있습니다 (현재 각 평면당 400개의 벡터). 벡터의 각도와 크기는 쉐이더에서 텍셀을 추출하여 텍스처로부터 얻어집니다. 사용자 인터페이스에서 동적으로 더 많은 레이어를 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 플로우, 느껴보세요!\n\n벡터는 현재 벡터 필드 상태를 시각화하는 데 좋지만 때로는 전체 시스템의 시간 간격 기반 동작을 얻기 위해 플로우 필드 시각화를 하는 것이 더 나을 수도 있어요. 그리고 그것이 바로 우리의 세 번째 시각화 도구이기도 해요. WebGL은 약간 제한적인 프레임워크이기 때문에 (컴퓨팅 또는 지오메트리 쉐이더의 사용은 야생 서부와 같다), 우리는 플로우 필드를 텍스처에 렌더링할 거에요. 간단화된 파이프라인은 다음과 같아요:\n\n- 시간 T에서 공간 내에서 N개의 랜덤한 점을 생성하고 위치를 버퍼 B1과 B2에 저장하기\n- B1의 점들을 텍스처에 그리기\n- 텍스처 렌더링 후 텍스처의 알파 값을 낮추어 시간에 따라 입자의 꼬리를 얻기\n- 현재 벡터 필드(우리의 Noise 함수)를 기반으로 시간 T+Epsilon에서 점들의 위치 계산하고 결과를 B2에 저장하기, 기본적으로 B2 = Noise('B1')\n- 버퍼 B1과 B2 교체하기\n- 두 번째 단계로 이동하기\n\n그러나 이 단계에서는 우리가 노이즈를 렌더링할 때와 같이 오프스크린 텍스처를 사용하지는 않을 거에요. 우리는 데이터셋(점으로 표현된 입자) 위에서 계산하는 것에만 관심이 있기 때문에 WebGL의 Transform Feedback 기능을 사용할 거예요. 이 접근 방식은 GPGPU에 대한 텍스처 핑퐁보다 약간 더 나아요. 우리는 데이터와 직접 작업할 수 있어 샘플링 모호성을 방지할 수 있어요. 텍스처나 텍셀 페치의 샘플링이 어떻게 깨졌다는 것은 전혀 말하고 싶지 않아, 하지만 얻은 데이터의 정확성과 특정 방식으로 보간되지 않을 것임을 내 인생을 건다고 말할 수는 없겠어요. 하지만 아마도 저는 너무 의심이 많을지도 모르겠어요. :] 빨간색은 더 빠른 입자를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n말씀드린 대로, 저희 Noise 함수는 셰이더에서 구현되어 있어서 Transform feedback과 함께 Noise를 사용하는 것은 간단합니다. 저는 성능을 깊게 테스트하지는 않았지만, 우리는 입자들을 두 번만 접촉하고 새로운 위치를 계산하고 드로우 콜을 하기 때문에 규모 확장 관점에서 꽤 좋을 것입니다. 이 특정 경우에는 플로우 시각화가 그다지 흥미로운 것은 아니지만, 이것을 2D 평면상의 투사 표면 기울기 필드의 시각화로 사용하고 있으며 3D 공간을 탐색하는 것보다 더 유용합니다.\n\n## 비행기는 어디죠, 류보스키?\n\n그래서 저희는 벡터 필드를 갖고 있고, 몇 가지 시각화 기술 집합도 있습니다. 필요한 것은 실제 비행기와 비행 경로뿐입니다. 일반적으로, 어떤 경로를 선택하든 여행 비용을 계산할 수 있어야 하지만, 실제 생활과 적어도 어느 정도 유사한 케이스를 만들기 위해 실제 비행과 비슷한 경로를 선택해야 합니다.\n\n저는 Bump 함수부터 시작하기로 결정했습니다. 이 함수는 대칭적이며, 도메인 크기에 비해 오랜 플랫폼을 갖고 있을 수 있으며, 공격적인 이륙 또는 착륙을 나타낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n웹지엘에서 경로 시각화는, 잘, 이상적이지 않아요. 우리는 공간에서 경로 표현에 많은 시간을 쏟을 수 있지만, 저는 더 중요한 일이 있어서 악마와 협상을 통해 LINE_STRIP를 통한 표현으로 만족해야 합니다. 어떤 함수든 주어졌을 때, 프로그램은 N개의 점에서 함수를 샘플링하고 벡터 필드를 통해 스트립을 만듭니다. 보면서 알 수 있듯이, 어떤 샘플 점에서든 해당 시간에 벡터 값도 시각화됩니다.\n\n<img src=\"/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_1.png\" />\n\n## 비행 비용\n\n나중에 더 복잡한 내용을 다룰 예정이지만, 먼저 입자가 일정 경로를 따라 벡터 필드를 통해 이동할 때 수행되는 작업의 기본적인 정의를 사용할 것입니다. 그래서 우리 경우에 비행기가 단순히 입자로 가정합시다. 직관적으로, 이 적분은 현재 시간에 따른 벡터 필드와 얼마나 잘 맞는지를 말합니다. 즉, 양수가 나오면 풍향이 더 세다는 것을 의미하고, 음수가 나오면 역풍이 더 강했다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Vector Fields and Fuel Consumption Wrapped in 3D](/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_2.png)\n\nr는 우리 경로를 통해 매개변수화된 함수이며, F는 노이즈 함수에 의해 정의된 우리의 벡터 필드이며, 경로에서 계산된 것이며 시간 t에 대해 적분하고 싶습니다. 또한 적분하기 전에는 매개변수화된 함수의 도함수와 점곱을 해야 합니다. 이 모든 것은 전부 좋고 훌륭한데, 식을 적분하기 시작하기 전까지만요. 이를 해결하는 데 여러 문제가 있습니다. 하지만 그 문제에 들어가기 전에, 우리의 노이즈 함수를 살펴봅시다.\n\n## Akima? 네!\n\n심플렉스 노이즈의 정의는 기본적으로 우리의 섀이더에 작성되어 있으므로, 이를 적분의 입력으로 사용해도 괜찮다고 생각할 수 있습니다. 결국, 노이즈 계산을 단순화할 때 논리적으로 증명하기 위해서, 이는 적분하기 쉽게 다루기 쉬운 다항식들에 대한 멋진 작업들뿐인 것이기 때문입니다.\n\n\n<div class=\"content-ad\"></div>\n\n문제는 벡터 계수를 얻으려면 사인 및 코사인 함수를 적용해야 한다는 것입니다. 그리고 이러한 함수를 적분하면, 일반화된 프레넬 적분 영역에 들어가게 됩니다. 이러한 적분을 해결하고 나열할 수는 있지만, 많은 작업이 필요합니다. 그리고 궁금증은 Matlab이나 Scipy와 같은 백엔드를 사용하지 않고도 비슷한 프로젝트에서 복소해석을 다루고 싶은지에 대한 문제입니다.\n\n그러나 다른 방법으로 이 문제를 해결하는 또 다른 주장이 있습니다. 종종 수천 개의 센서에서 얻은 데이터때문에 벡터 필드의 정의를 알 수 없는 경우가 많습니다. 그리고 예, 동적 시스템을 어떻게든 모델링하거나, 뉴럴 네트워크를 학습시키거나 오버피팅하여 꽤 좋은 상미분 방정식 또는 편미분 방정식을 얻을 수는 있지만, 그것은 쉬운 작업이 아닙니다.\n\n대신, 우리는 다음과 같이 할 것입니다. 경로 r을 따라 노이즈 함수를 N개의 점에서 샘플링하여 무작위 삼중 세트 (XY 각도, XZ 각도, 벡터 크기)를 얻습니다. 그런 다음, 우리는 벡터의 성분을 얻기 위해 사인/코사인 변환을 적용할 것입니다. 마지막으로, 우리는 그 데이터 점에 Akima 스플라인 보간을 적용하여 세 개의 연속적인 조각 이차 다항 함수를 얻을 것입니다 (총 N-1 다항 함수가 각 성분당).\n\nAkima 스플라인은 계산이 매우 빠르고 특히 연속 도함수의 n차 순도 같은 강력한 요구사항이 없는 경우 특히 유용한 유형의 스플라인이기 때문에 흥미로운 유형의 스플라인입니다. 우리의 경우, 우리는 처음 도함수만 필요합니다. 이것은 잘 동작하며 평균 오차가 작으며 종종 그러한 다항 함수들이 선형이거나 일정할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이는 단일 적분이 N-1개의 적분으로 분할되어 함께 요약해야 한다는 것을 의미합니다. 이론적으로 각 근사치에 스텝 함수 또는 헤비사이드 함수의 해석적 근사치를 곱해서, 스플라인이 해당 도메인에서만 \"활성화\"되도록 할 수 있습니다. 그러나 이는 최종 적분을 더욱 복잡하게 만들 수 있습니다.\n\n# 버프 함수가 손을 놓고 있지 않습니다\n\n지금까지는 벡터 필드가 다항식으로 근사되어 왔고 이제는 매개변수화된 경로 함수 r의 미분을 어떻게 처리할지 신경 써야 합니다. 우리의 내적 부분을 살펴봅시다: \n\n![image](/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_3.png)\n\n<div class=\"content-ad\"></div>\n\nAkima의 보간 (다항식)이 있는 벡터 필드에 따른 경로의 pol, 그리고 g(t)는 t에 관한 매개변수화된 경로의 z 성분입니다. 아래에서 g(t) 함수의 두 예시를 볼 수 있습니다. 하나는 상수 0이고, 다른 하나는 sin(t)입니다. 이제 우리는 벡터 필드를 통해 의미 있는 경로를 구성할 수 있습니다.\n\n범프 함수의 유도는 나쁘지 않지만, 우리는 이것이 다항식들과의 내적에서 곱해질 것이며, 그것이 우리의 다음 문제라는 것을 깨닫게 되어야 합니다. 그러한 적분은 수치적으로만 해결할 수 있고, 그것은 우리가 꼭 하고 싶어하는 것은 아닙니다.\n\n그래서, 우리는 매개변수화된 경로 함수의 유도를 Akima 스플라인을 통해 보간할 것입니다. 이제 내적은 최대 6차수의 다항식을 생성하고, 다항식의 적분은 괜찮고 잘 되며, 결국 언어로도 따지지 않고 잘 될 것입니다.\n\n라이브 데모나 소스 코드를 함께 살펴보거나 플레이하려고 계획하시는 경우, FlightHelper 클래스에 임의의 경로를 추가할 수 있습니다. 사용하고 싶은 기호적 표현을 사용할 수 있지만, Nerdamer와 호환되어야 합니다. 이전 그림에서 본 함수들에 대한 정의는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nstatic init() {\n  this.flightPaths = new Array<FlightPath>()\n  this.flightPaths.push(\n    new FlightPath(\"sin(3x)\", \"e^(-1/(1-x^2))\")\n  )\n\n  for (let i = 0; i < 5; i++) {\n    let offset = \"\" + (1 + 0.1 * i) + \"*\"\n    this.flightPaths.push(\n      new FlightPath(\"0\", offset + \"e^(-1/(1-x^2))\")\n    )\n  }\n}\n```\n\n# 결과가 나타납니다!\n\n정수 안정성과 계산된 작업이 정확하게 될지에 대해 약간 불안했던 점을 인정해야 했습니다. 특히 여러 Akima 보간법을 사용하는 경우입니다. 그 결과는 생각보다 나아졌습니다. 아래 비디오에서 확인할 수 있습니다.\n\n벡터 필드가 우리의 경로와 일치하는 경우, 작업 결과는 2가 되며 정확히 도메인 크기가 2이기 때문에 합리적입니다. 벡터 필드가 우리에게 반대로 작용할 때 작업 결과는 -2이고 수직일 때는 작업이 0입니다. 다음 비디오에서는 벡터 필드가 잡음에 의해 무작위로 개선되었을 때의 계산을 볼 수 있습니다. 완료되면 최적의 경로는 검은색으로 표시되며 각 경로의 비용은 왼쪽 상단에 표시됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 하지만 비행기는 단순히 한 점이 아닙니다\n\n지금까지 우리는 벡터 필드가 우리의 경로와 얼마나 일치하는지 계산할 수 있었습니다. 우리의 계산은 정확한 모델은 아니지만, 이제 어느 경로가 에너지적인 관점에서 어떻게 더 나은지 또는 나쁜지를 말할 수 있습니다. 우리가 프라하에서 도쿄로 사선비행기로 날아갈 때 언제 출발할지 선택한다면, 날씨 예측을 기반으로 작업 계수를 계산하여 가장 일치하는 예측을 선택했기 때문에 연료를 절약할 수 있습니다. 그러나 다른 교통 수단으로도 그렇게 할 수 있습니다. 예를 들어 보트를 소유하고 있다면, 바람 날씨 예측 데이터 대신에 파도 속도를 바람 예측과 결합하여 사용할 수 있으며, 작업은 동일하지만 차원이 적어집니다.\n\n연료 소비의 정확한 모델보다는 계산을 개선할 수 있는 한 가지 방법이 있습니다. 작업 적분 뿐만 아니라, 우리의 적분에 다른 함수를 추가해 보겠습니다. 이를 '비용'이라고 부르겠습니다: \n\n<img src=\"/assets/img/2024-05-18-벡터필드와연료소비의3D포장.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 함수는 다음과 같은 전체 동적 특성을 나타낼 수 있어요:\n\n- 45도에서의 역풍은 45도에서의 유동풍과는 다른 영향을 줄 수 있어요.\n- 이륙 단계에서는, 벡터 필드에서의 어떤 역풍이 최종 작업 적분에 더 큰 영향을 줄 거에요.\n- 비행 시간이 길수록, 연료를 소모하기 때문에 바람이 더 큰 영향을 줄 거에요.\n- 비행기의 공기역학 프로필을 전파할 수도 있어요. 즉, 각도별로 다른 계수를 사용할 수 있어요.\n- 지금까지 비행기의 추진력을 고려하지 않았는데, 이 또한 벡터 필드의 영향에 대해 동적 시스템일 수 있어요.\n\n비용 함수는 매우 복잡할 수 있으며, 물리적인 비행기나 상세한 모델이 없으면 예측하기 어려울 수 있어요. 그러나 서로 다른 아이디어로 실험해 볼 수 있으며, 포아송 방정식과 관련해 이 개념을 해결하는 동안 다양한 경우에 대해 실험해 볼 수 있어요. 또한 비용 함수의 적용은 다른 경우에 따라 다르며, 곱셈뿐만 아니라 비용이 작업자 역할을 할 수도 있어요.\n\n# 길을 보여주세요, 나의 주여\n\n<div class=\"content-ad\"></div>\n\n지금은 목적지로 비행할 때 언제 출발할지 선택할 수 있는 위치에 있습니다. 경로도 선택할 수 있습니다 — 보통 이는 사실이 아니며, 항공 공간은 무질서가 아닙니다. 수학적 관점에서 우리는 작업 적분의 전역 최솟값을 찾고, 해당 최솟값 후보를 얻기 위해 도함수가 영과 같은 도함수를 찾을 수 있습니다:\n\n![image](/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_5.png)\n\n이 문제를 해결하는 것은 쉽지 않을 수 있습니다. 특히 비용 함수가 복잡해질 때입니다 — 이것은 개념/아이디어로만 간주하십시오. 실제로 이러한 문제는 다르게 해결됩니다. 그러나 실제 세계에서 효과적으로 작동할 수 있는 다른 옵션들이 있습니다. 지금까지 이러한 옵션은 프로젝트에 아직 구현되지 않았습니다. 왜냐하면 저는 그것들이 필요하지 않았기 때문이지만, 나중에 추가할 수도 있습니다.\n\n하나의 해결책은 세상을 3D 그리드로 분할하고 그래프상에서 최적의 경로를 찾는 것입니다. 그리드가 정칙적이므로 경로에 스플라인 보간을 적용할 수도 있습니다. 게다가 규칙 세트도 갖고 있을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 경로 시작점으로부터 현재 위치까지의 유클리드 거리는 항상 증가해야 하며, 동시에 현재 위치로부터 경로 끝까지의 유클리드 거리는 항상 감소해야 합니다.\n- 격자 위의 어떤 점도 반드시 어떤 봉투 안에 있어야 합니다.\n\n또 다른 해결책은 \"몬테 칼로\"와 비슷한 접근 방식일 수 있습니다. n개의 경로를 생성하고, 각각의 작업을 계산한 다음 어떤 최상의 하위 집합을 선택하고, 각 하위 집합에 대해 비슷한 경로 집합을 생성합니다. 반복 횟수는 사용자에 달려 있으며, 얼마나 정확한 결과가 필요한지에 따라 다릅니다. 벡터 필드가 연속적일 것이고 해당 필드의 어떤 측정도 마찬가지로 연속적일 것이므로, 우리 비행용으로는 꽤 좋은 후보를 선정할 수 있어야 합니다. 마지막 문장은 매우 가정적이지만, 바람이나 어떤 자연 현상에 관한 이야기라면, 같은 지역 내에서 비용이 많이 드는 경로들이 많은 지역이 아니라 특별한 계곡이 있는 것이 상식적으로 보이지 않습니다.\n\n<img src=\"/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_6.png\" />\n\n# 미래 계획\n\n<div class=\"content-ad\"></div>\n\n초반에는 포아송 방정식에 관한 글을 작성하려 했지만 결국 시각화 작업이 예상보다 더 오랜 시간이 걸렸고 중간에 더 많은 기능을 추가하기도 했어요. 그래도 어쨌든 결과적으로 이런 식으로 끝나서 기뻐요. 이런 작은 작업조차 흥미로운 부분이 많거든요. GitHub에서 실시간 데모와 소스 코드를 확인할 수 있어요. 해당 프로젝트 관련 모든 것은 webgl2 폴더에 있어요. 아직 몇 가지 부분을 더 최적화하고 싶어해요 (노이즈 계산/경로 비용 속도 향상, 더 나은 궤도 카메라, 드로우 호출 감소 (인스턴스 어레이, 중복된 유니폼 제거) 등). 현재로서는 데스크탑/노트북에서의 사용이 선호돼요.\n\n다음 블로그 글에서는 신경망과 포아송 방정식에 관한 몇 가지 아이디어를 소개하고 WebGL에서 WebGPU로 전환하고 싶어해요. 이번에는 데스크탑 애플리케이션으로 개발할 거라 C++ 또는 Rust를 사용할 거에요. 그 중에서 Rust가 더 재미있어 보이네요. 시간 내 주셔서 감사합니다. 자유롭게 의겢거나 댓글을 남겨주세요. 그리고 제 LaTeX 기술이 녹슨 것 같아서 LaTeX OG들에게 일으킨 피해에 대해 정말 죄송해요.","ogImage":{"url":"/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_0.png"},"coverImage":"/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_0.png","tag":["Tech"],"readingTime":11},{"title":"nightwatch-api v301에서 playwright로 이주를 고려해야 하는 이유","description":"","date":"2024-05-18 21:51","slug":"2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright","content":"\n\nNightwatch.js v1.7은 JavaScript를 위해 고안된 것이기 때문에 TypeScript을 지원했습니다. Igor Bari가 nightwatch-api를 만들어 TypeScript을 지원했습니다. Igor Bari에게 nightwatch-api를 만들어주어서 정말 감사해야 합니다. Nightwatch.js v1.7 npm 패키지는 TypeScript 개발자들이 Nightwatch.js v1.7을 편리하게 제어할 수 있도록 제공했습니다.\n\n## nightwatch-api와 Nightwatch.js v1.7의 관계는 무엇인가요?\n\nnightwatch-api는 TypeScript를 지원하기 위해 만들어진 래퍼이며 Nightwatch.js v1.7과 관련이 있습니다.\n\n## Nightwatch.js v1.7의 인기는 어떤가요?\n\n<div class=\"content-ad\"></div>\n\n많은 개발자들이 Nightwatch.js 프로젝트에서 nightwatch-api npm 패키지를 사용해 왔습니다. 여전히 매주 다운로드되고 있어요.\n\n![이미지](/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_0.png)\n\n# Nightwatch.js v2.0 릴리스 이후 어떤 일이 있었나요?\n\nNightwatch.js v2.0 릴리스부터는 Cucumber.js를 지원합니다. Nightwatch 엔지니어링 블로그에서 Nightwatch로 Cucumber 테스트를 실행하는 데 관한 상세한 블로그 포스트가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n2022년 3월 16일에 Igor Bari가 경고 메시지를 포함하여 README.md를 업데이트했습니다.\n\n![이미지](/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_1.png)\n\n# Nightwatch v1.x에서 Nightwatch v2.x로의 이주는 무엇이 발생했나요?\n\nNightwatch.js는 v1.x에서 v2.x로의 마이그레이션을 돕기위한 마이그레이션 가이드를 만들었습니다. 그러나 이 가이드는 nightwatch-api npm 패키지 사용자에게 도움이 되지 않습니다. Nightwatch.js는 JavaScript를 사용할 때만 cucumber.js를 지원하기 때문에 TypeScript 사용자는 마이그레이션에서 제외됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 다음 단계는 무엇이 있을까요?\n\n- 누군가가 nightwatch-api 프로젝트를 포크하고 Nightwatch.js v2.0을 지원하도록 만들어야합니다.\n답변: 아직 누구도 프로젝트를 포크하지 않았습니다. 포크를 확인했는데 https://github.com/mucsi96/nightwatch-api/forks?include=active&page=1&period=&sort_by=stargazer_counts Nightwatch.js v2.0이상을 지원하기 위해 작업한 프로젝트를 찾지 못했습니다.\n- cucumber.js를 사용하고 TypeScript로 테스트를 작성할 수 있는 다른 테스팅 프레임워크로 이동하십시오. 또한 새로운 테스팅 프레임워크로의 이전을 지원하기 위해 Nightwatch.js v1.7의 다양한 기능을 지원해야합니다.\n답변: Nightwatch.js와 주요 두 가지 테스팅 프레임워크를 비교할 수 있는 방법을 확인해보실 수 있습니다. Nightwatch.js에서 제공한 것으로 두 테스팅 프레임워크 중 어떤 것이 좋은 대안이 될지 보여주었습니다.\n\n# nightwatch-api v3.0.1에서 playwright로 이주를 고려해야 하는 이유\n\n내 관점으로 볼 때, Nightwatch.js 및 주요 두 가지 테스팅 프레임워크를 읽은 후, playwright가 좋은 대안이 될 것으로 판단했습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_2.png)\n\n고려 사항\n\n- 테스트 시작 전에 AUT를 실행할 수 있는 지원. 사용자가 특정 포트에서 테스트 시작 전에 AUT를 시작할 수 있습니다.\n- Visual Studio Code와 확장 프로그램 형태로 통합되어 있습니다.\n- 다양한 언어 지원 - Javascript, Typescript, Java, Python, .NET.\n\n나는 이러한 세 가지 고려 사항으로 Nightwatch.js v1.7에서 Playwright로 테스트를 이전하려고 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n내 글을 좋아하신다면, 제 Medium 팔로우하기를 눌러주세요. 또한 YouTube에서 제 영상을 시청하실 수도 있고, 커피 한 잔 사주는 걸로도 저를 응원할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_0.png"},"coverImage":"/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_0.png","tag":["Tech"],"readingTime":3},{"title":"앵귤러에서 NgRx를 활용한 상태 관리하는 방법","description":"","date":"2024-05-18 21:49","slug":"2024-05-18-StatemanagementwithNgRxinAngular","content":"\n\n\n![스크린샷](/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_0.png)\n\n현대의 프론트엔드 애플리케이션은 주로 컴포넌트 개념을 사용합니다. 이는 사용자 인터페이스의 독립적이고 재사용 가능하며 자체적인 부분을 나타냅니다. Angular, React, Vue.js와 같은 인기 있는 프론트엔드 라이브러리들에서 이 개념은 중요합니다. 다수의 컴포넌트가 동일한 데이터를 필요로 할 때 간편함과 여러 이점을 제공하지만 문제도 발생할 수 있습니다. 이 문제를 해결하기 위해 Redux 패턴이라는 개념이 있습니다. Redux 라이브러리는 처음에 React 생태계에서 인기를 얻었지만 Angular나 Vue.js와 같은 다른 프레임워크에서도 사용할 수 있습니다. 이 글에서는 NgRx 라이브러리를 사용한 상태 관리에 집중하겠습니다. Angular에서는 Redux를 사용할 수 있지만, Angular에 특별히 제작된 인기 있는 상태 관리 라이브러리인 NgRx를 사용하는 애플리케이션을 자주 볼 수 있습니다.\n\n## NgRx란?\n\n소개에서 언급한 대로, NgRx는 Redux에 영감을 받은 상태 관리를 위한 라이브러리입니다. Angular용 Redux 원칙을 구현하여 애플리케이션 상태를 예측 가능하고 구조적인 방식으로 관리합니다. NgRx는 액션, 리듀서, 이펙트, 셀렉터와 같은 개념을 사용하여 상태를 조작하는데 있어 가시적인 방식을 제공합니다.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_1.png\" />\n\n## 저장소\n\n\"저장소\"는 불변 데이터 구조로 구현된 상태 관리자의 일부입니다. 다시 말하면, 그 안에 포함된 데이터는 직접 변경할 수 없습니다. 따라서 모든 상태 변경은 작업을 통해 이루어져야 합니다. 이러한 작업은 '리듀서'라고 불리는 메커니즘을 통해 상태에서 변경될 내용을 정의합니다. 이 함수는 상태와의 통신을 처리합니다.\n\n## 리듀서\n\n<div class=\"content-ad\"></div>\n\n리듀서의 책임은 스토어의 상태를 변경할 필요가 있는 모든 작업을 처리하는 것입니다. 현재 상태와 액션을 입력으로 받아 변경 후의 새로운 상태를 반환합니다.\n\n## 액션\n\n\"액션\"은 단순히 상태 변경을 나타내는 객체들입니다. 상태를 변경할 정보를 포함한 액션은 스토어로 전송됩니다.\n\n## 셀렉터\n\n<div class=\"content-ad\"></div>\n\n\"selectors\"는 저장된 상태의 특정 정보에 액세스하고 가져 오는 데 사용되는 기능입니다. 따라서 구성 요소가 상점의 완전한 상태를 직접 가져 오는 대신 필요한 데이터만 요청 할 수 있습니다. 이렇게하면 코드가 더 모듈식이고 재사용 가능하며 유지 보수가 쉬워집니다. 또한, 요청 한 구성 요소에 제공되기 전에 상태에서 calc 및 변환을 수행 할 수도 있습니다.\n\n## 효과\n\n\"효과\"는 비동기 작업이나 부작용, 즉 네트워크 요청, 데이터베이스 액세스, 외부 API 호출 또는 순수 동기가 아닌 작업과 같은 기능을 나타냅니다. 그러나이 기능을이 기사에서는 사용하지 않습니다. 곧이 주제에 특별히 전념 한 기사를 쓰는 것을 선호합니다.\n\n# 실제로 사용하는 NgRx\n\n<div class=\"content-ad\"></div>\n\n내 저장소에 있는 애플리케이션은 GitHub의 igormarti/angular-ngrx-shopping(https://github.com/) 링크에서 확인할 수 있어요. 클론하려면 확인해보세요. 하지만 이 개념을 처음부터 적용할 수도 있어요. 내 애플리케이션에서는 제품을 즐겨찾기에 추가하는 상태 관리자를 사용할 거에요. 우리 애플리케이션에는 스토어에서 즐겨찾기한 제품들을 요청할 몇 가지 구성 요소가 있을 거예요. 이후 단계에서 자세한 내용을 볼 수 있을 거에요. 코드 구현에 대해 한 가지 팁: 이 프로젝트의 코드 구현은 Angular 버전 16과 NgRx 버전 7.8.0을 사용해 만들어졌어요.\n\n# Angular에서 NgRx 설치\n\n프로젝트에서 NgRx를 설치하려면 루트 폴더에서 다음 명령을 실행하세요:\n\n```js\nnpm install @ngrx/store --save\n```\n\n<div class=\"content-ad\"></div>\n\n# 프로젝트에서 NgRx 구조화하기\n\nNgRx를 프로젝트에 설치한 후에는, 이제 구조를 만들어야 하는 때입니다. 다음 단계에서는 액션, 리듀서, 셀렉터 및 초기 상태를 만들 것입니다.\n\n먼저, 애플리케이션의 앱 폴더 내에서 \"states\"라는 폴더를 만들 것입니다. 이 폴더 안에 \"favorite-product\"라는 폴더를 만든 후, 그 안에 \"action\", \"reducer\", \"selector\"라는 세 개의 폴더를 만들 것입니다. 구조는 다음과 같습니다:\n\n```js\napp ->\n  states ->\n      favorite-product ->\n                    action\n                    reducer\n                    selector\n```\n\n<div class=\"content-ad\"></div>\n\n이제 \"favorite-product\" 폴더 안에 \"app.state.ts\" 파일을 생성할 것입니다. 이 파일은 초기 상태의 모델이 될 것입니다:\n\n```js\nimport { FavoriteProduct } from \"src/app/models/favorite-product.model\";\n\nexport interface AppState {\n    products: FavoriteProduct[];\n}\n```\n\n우리의 \"AppState\" 인터페이스 안에 \"products\"라는 속성이 있음을 주목해주세요. 이는 초기 상태의 유형을 나타내는 배열 \"FavoriteProduct\"입니다. 따라서 우리는 이 인터페이스를 프로젝트에 만들어야 합니다. 저는 내 애플리케이션에서 \"src/app/models/favorite-product.model\" 경로에 만들었습니다. 그러나 원하는 곳에 넣으셔도 됩니다. 중요한 점은 \"app.state.ts\" 파일에서 올바르게 가져오는 것입니다.\n\n```js\nexport interface FavoriteProduct {\n    id: number;\n    name: string;\n    price: number;\n    image: string;\n    isFavorite?: boolean;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 작업 생성하기\n\n이 단계에서는 \"src\\app\\states\\favorite-product\\action\" 폴더 안에 작업을 만들 것입니다. 우리의 파일은 \"app.action.ts\"로 명명될 것입니다. 이 파일에는 데이터 상태를 변경하는 모든 작업을 나타내는 함수들이 포함될 것입니다. 다음의 코드를 참조해주세요:\n\n```js\nimport { createAction, props } from '@ngrx/store';\nimport { FavoriteProduct } from \"src/app/models/favorite-product.model\";\n\nexport const add = createAction('[FavoriteProduct] Add',  props<{ product: FavoriteProduct }>());\nexport const remove = createAction('[FavoriteProduct] Remove', props<{ product: FavoriteProduct }>());\nexport const updateAllState = createAction('[FavoriteProduct] Update all state of favorites products', \n props<{ products: FavoriteProduct[] }>());\nexport const clear = createAction('[FavoriteProduct] Clear');\n```\n\n위 코드에서는 \"@ngrx/store\" 모듈의 \"createAction\" 함수가 작업 설명을 첫 번째 매개변수로서, 처리할 데이터를 두 번째 매개변수로 가지는 것을 알 수 있습니다. 우리의 \"favorite-product\" 상태에는 다음과 같은 작업들이 있을 것입니다: add, remove, updateAllState, clear.\n\n<div class=\"content-ad\"></div>\n\n## 리듀서 생성하기\n\n우리는 \"src\\app\\states\\favorite-product\\reducer\" 폴더에 \"app.reducer.ts\" 파일을 만들어야 합니다. 이 파일에서는 즐겨찾는 제품 목록의 초기 상태를 초기화하고 각 작업에 대한 비즈니스 로직을 구현한 다음 상태를 업데이트하기 전에 상태를 변경합니다. 자세한 내용은 다음 코드를 참조해주세요:\n\n```js\nimport { createReducer, on } from '@ngrx/store';\nimport { add, remove, clear, updateAllState } from '../action/app.action';\nimport { AppState } from '../app.state';\n\nexport const initialState: AppState = {\n  products:[],\n};\n\nexport const favoriteReducer = createReducer(\n  initialState,\n  on(add, (state, {product}) => (\n    {\n      ...state,\n      products: [...state.products, product]\n    }\n  )\n  ),\n  on(remove, (state, {product}) => ({\n    ...state,\n    products: state.products.filter((p)=> product.id != p.id)\n  })),\n  on(updateAllState, (state, {products}) => (\n    {\n      ...state,\n      products\n    }\n  )\n  ),\n  on(clear, state => initialState)\n);\n```\n\n먼저 초기 상태가 빈 즐겨찾는 제품 배열로 초기화되는 것을 알아봅니다. 그다음, \"@ngrx/store\" 모듈에서 \"createReducer\" 함수가 초기 상태와 여러 \"on\" 함수를 받아 작업을 상태 변경과 연결하고 있음을 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n- \"add\" 액션은 현재 상태에 새 제품을 추가합니다.\n- 마찬가지로, \"remove\" 액션은 현재 상태에서 특정 제품을 제거합니다.\n- \"updateAllState\" 액션은 매개변수로 받은 제품 목록으로 상태를 업데이트합니다.\n- 마지막으로 중요하지만 더욱 중요한 것은, \"clear\" 액션은 초기 상태로 설정하여 상태를 재설정하며, 저장소에서 모든 즐겨찾는 제품을 모두 지우게 됩니다.\n\n## 셀렉터 생성하기\n\n이제 저장소에서 데이터를 검색하려면 셀렉터를 생성해야 합니다. 이를 위해 'src\\app\\states\\favorite-product\\selector' 폴더에 'app.selector.ts' 파일을 만들어야 합니다. 자세한 내용은 다음 코드를 참조해주십시오:\n\n```js\nimport { createFeatureSelector, createSelector } from '@ngrx/store';\nimport { AppState } from '../app.state';\nimport { FavoriteProduct } from \"src/app/models/favorite-product.model\";\n\n// 애플리케이션 내에서 즐겨찾는 제품의 전체 상태를 가져옵니다.\nexport const selectAppState = createFeatureSelector<AppState>('favorite');\n\n// 모든 즐겨찾는 제품 가져오기\nexport const selectProducts = createSelector(\n  selectAppState,\n  (state: AppState) => state.products\n);\n\n// ID로 하나의 즐겨찾는 제품 가져오기\nexport const selectProductById = createSelector(\n  selectProducts,\n  (products: FavoriteProduct[], props: { productId: number }) =>\n    products.find(product => product.id === props.productId)\n);\n```\n\n<div class=\"content-ad\"></div>\n\n첫 번째 함수에서는 'favorite' 스토리지에서 전체 상태를 얻고 있습니다. 두 번째 함수에서는 이 완전한 상태를 사용하여 즐겨찾는 상품만 검색합니다. 마지막 함수는 즐겨찾는 상품의 상태를 활용하여 해당 ID의 특정 상품을 가져옵니다. 우리는 이러한 모든 함수를 애플리케이션에서 필요한 데이터를 검색하는 데 사용할 수 있습니다.\n\n우리의 폴더 구조는 다음과 같이 구성되어 있습니다:\n\n![폴더 구조](/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_2.png)\n\n상태 관리를 사용하기 전에 StoreModule을 모듈에 가져와 reducer를 포함해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { NgModule } from '@angular/core';\nimport { AppComponent } from './app.component';\nimport { StoreModule } from '@ngrx/store';\nimport { favoriteReducer } from './states/favorite-product/reducer/app.reducer';\n\n@NgModule({\n  declarations: [\n\n  ],\n  imports: [\n    StoreModule.forRoot({favorite:favoriteReducer})...\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n## 액션 사용하기\n\n상태에서 액션을 사용하려면 먼저 \"@ngrx/store\" 모듈에서 \"Store\"를 가져와서 생성자에 포함해야 합니다. 다음은 예시입니다:\n\n```js\nimport { Store } from '@ngrx/store';\n\n@Component({\n  selector: 'app-home-product',\n  templateUrl: './home-product.component.html',\n  styleUrls: ['./home-product.component.scss']\n})\nexport class HomeProductComponent{\n\nconstructor(private readonly storageService:StorageService<FavoriteProduct[]>){}\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n'store'을 import한 후에는 이제 액션을 사용할 수 있습니다. 우리 애플리케이션에서는 특정 제품의 하트 아이콘을 클릭할 때마다 해당 제품을 즐겨찾기에 추가합니다. 아래 이미지에서 'Notebook' 제품이 즐겨찾기 목록에 추가되었음을 보실 수 있습니다. 또한, 오른쪽 상단에 있는 하트 아이콘에 주목해주세요. 이 아이콘은 즐겨찾기에 추가된 항목 수를 나타내는데, 이 경우에는 '1'이 표시됩니다.\n\n![image](/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_3.png)\n\n따라서 즐겨찾기 아이콘을 클릭할 때마다 'dispatch' 함수가 트리거되며, 원하는 액션을 매개변수로 전달합니다. 이 경우에는 액션이 'add'가 됩니다. 아래 코드를 확인해주세요:\n\n```js\n<mat-icon [style.color]=\"product.isFavorite?'red':'black'\" class=\"mat-icon-lg icon\" \n(click)=\"addProductToFavorites(product)\" >favorite</mat-icon>\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Store } from '@ngrx/store';\n\n@Component({\n  selector: 'app-home-product',\n  templateUrl: './home-product.component.html',\n  styleUrls: ['./home-product.component.scss']\n})\nexport class HomeProductComponent {\n\n  constructor(private readonly storageService:StorageService<FavoriteProduct[]>) {}\n\n  addProductToFavorites(product: FavoriteProduct) {\n    const favoriteProduct: FavoriteProduct = {\n      ...product,\n      isFavorite: true\n    }\n    this.store.dispatch(add({ product }));\n  }\n\n}\n```\n\n그래서, 'dispatch' 함수를 트리거할 때마다 클릭한 제품이 '리듀서'로 전송되는데, 이는 데이터를 처리하고 상태에 저장하기 전에 책임이 있습니다.\n\n## 셀렉터 사용하기\n\n셀렉터를 사용하기 위해서는 '@ngrx/store' 모듈에서 'Store'를 가져와야 합니다. 그러나 셀렉터를 사용하여 데이터를 검색하는 데 사용되는 함수는 'pipe'입니다. 다음 코드에서 자세한 내용을 확인하세요:```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { FavoriteProduct } from 'src/app/models/favorite-product.model';\nimport { Store, select } from '@ngrx/store';\nimport { AppState } from 'src/app/states/favorite-product/app.state';\nimport { selectProducts } from 'src/app/states/favorite-product/selector/app.selector';\n\n@Component({\n  selector: 'app-header',\n  templateUrl: './header.component.html',\n  styleUrls: ['./header.component.scss']\n})\nexport class HeaderComponent {\n\n  favoritesProducts: Observable<Array<FavoriteProduct>> = this.store.pipe(select(selectProducts))\n\n  constructor(private router: Router, private store: Store<AppState>) { }\n\n}\n```\n\n'pipe' 안에 있는 코드를 볼 때 'select' 함수를 사용하고 있습니다. 이 함수는 '@ngrx/store' 모듈에서 가져온 것으로, 셀렉터를 파라미터로 받습니다. 현재 셀렉터는 'selectProducts'이며 'FavoriteProduct' 배열의 'Observable'을 반환합니다. 이 목록은 속성에 저장되어 템플릿에서 사용되어 즐겨찾기 제품의 수량을 표시합니다. 아래 템플릿 코드에서 더 자세한 내용을 확인할 수 있습니다:\n\n```js\n<mat-icon [style.color]=\"'red'\" \nmatBadge=\"{(favoritesProducts | async)?.length}\" \nmatBadgePosition=\"above after\">favorite</mat-icon>\n```\n\n템플릿에서 'async' 파이프를 사용해 TypeScript에서 옵저버블로 받은 데이터를 처리합니다. 그리고 'length' 속성을 이용하여 목록에 있는 항목 수를 얻습니다. 더 자세한 코드는 제 GitHub 리포지토리에서 확인할 수 있습니다. 아래 링크에 접속해주세요: igormarti/angular-ngrx-shopping (github.com)```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nAngular 애플리케이션에서 상태 관리는 매우 중요한 요소입니다. 특히 특정 상태가 복잡해지는 경우가 많습니다. Angular의 인기 있는 상태 관리 라이브러리인 NgRx는 애플리케이션 상태를 중앙에서 예측 가능하게 효율적으로 관리할 수 있는 견고하고 확장 가능한 솔루션을 제공합니다. 액션, 리듀서, 셀렉터 등의 개념을 활용해 NgRx를 사용하면 개발자들이 상태 변경을 효율적으로 처리하고 관심사를 명확히 분리할 수 있습니다. NgRx를 사용하면 유지보수성이 높고 테스트 가능하며 확장 가능한 Angular 애플리케이션을 만들 수 있어서 복잡한 상태 관련 도전 과제를 관리하는 강력한 도구로 작용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_0.png"},"coverImage":"/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_0.png","tag":["Tech"],"readingTime":11},{"title":"TypeScript 53에 새로 추가된 내용 정리","description":"","date":"2024-05-18 21:47","slug":"2024-05-18-WhatsFreshinTypeScript53LetsDiveIn","content":"\n\n\n![2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0](/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png)\n\n자바스크립트로 작업 중인 상황을 상상해보세요. 이 언어는 유연하지만 때로는 까다로운 면이 있습니다.\n\n타입스크립트는 코드를 실행하기 전에 실수를 잡아주는 일종의 보조 역할을 하는데요.\n\n변수와 함수와 같은 요소들의 타입을 명시하는 방법을 추가함으로써 이를 수행합니다.\n\n\n<div class=\"content-ad\"></div>\n\n그러니까, 흔한 오류를 미리 방지하는 데 넘어서 TypeScript는 테이블에 몇 가지 멋진 기능을 가져다 줍니다. 이것을 한 마디로 말하면, 오타를 만들 것 같을 때나 특정 사항을 확인을 잊었을 때 지적해주는 스마트한 친구가 있다고 생각해보세요. 하나 더, 코드를 작성하는 동안 당신을 도와주기도 합니다.\n\nVisual Studio 또는 VS Code를 사용해 본 적이 있다면, 자동 완성, 코드 탐색, 코드를 더 깔끔하게 만드는 매력적인 부분이 TypeScript가 뒷담화로 작동하고 있다는 거죠.\n\n호기심이 생겼고 TypeScript를 한 번 시도해 보고 싶다면, TypeScript를 사용하는 방법은 다음과 같습니다:\n\nTypeScript를 시작해 보려면 NuGet을 사용하여 가져올 수 있고, npm 세계에 더 익숙하다면 다음 명령어를 입력해 보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install -D typescript\n```\n\n# Import 속성\n\nTypeScript 5.3에서 새로 추가된 멋진 기능 중 하나는 import 속성입니다. 이것들은 런타임에 가져온 항목들을 다루는 방법에 대한 특정 세부사항을 알려주는 작은 태그 같은 역할을 합니다.\n\n예를 들어, JSON 파일을 가져올 때 이것이 JSON으로 처리되고 실행 가능한 JavaScript로 처리되지 않도록 하려면 다음과 같이 할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport obj from \"./something.json\" with { type: \"json\" };\n```\n\n이러한 속성은 TypeScript 자체에서 확인되지 않습니다. 대신 브라우저나 런타임이 따를 주석과 같습니다. 따라서 자유롭게 사용할 수 있지만, 무의미한 유형을 사용하여 브라우저를 혼란스럽게 하지 않도록 주의하십시오:\n\n```js\nimport * as foo from \"./foo.js\" with { type: \"fluffy bunny\" };\n```\n\n동적 임포트인 import()로 만든 임포트도 이러한 임포트 속성을 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```javascript\nconst obj = await import(\"./something.json\", {\n    with: { type: \"json\" }\n});\n```\n\n재밌는 점은 TypeScript가 예전 기능인 \"import assertions\"에서 이 새로운 import 속성으로 이동하고 있다는 것입니다.\n\n이제 더 이상 assert 키워드를 사용하는 대신 with를 사용합니다. 이전 코드에 assert가 있는 경우, 새로운 문법인 with를 사용하도록 업데이트하는 것이 권장됩니다.\n\n# Import 타입에서 버그 수정된 해상도 모드 안정성 지원\n\n\n<div class=\"content-ad\"></div>\n\n현재는 Markdown 형식을 사용하고 있는 것 같네요. 예를 들어, 코드에서 타입 가져오기를 기존 require처럼 처리하거나 현대적인 import처럼 처리할지 결정할 때 사용하는 설정과 비슷한 거죠.\n\n코드에서 타입 가져오기를 예전 방식인 require()처럼 처리하고 싶다면 다음과 같이 할 수 있어요:\n\n```js\nimport type { TypeFromRequire } from \"pkg\" with {\n    \"resolution-mode\": \"require\"\n};\n```\n\n그리고 새로운 import 방식을 선호한다면, 이렇게 할 수도 있죠:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport type { TypeFromImport } from \"pkg\" with {\n    \"resolution-mode\": \"import\"\n};\n```\n\n하지만 여기에 멋진 부분이 있어요. 이 기능은 처음에 import 어써션에 사용할 수 없었는데요, 이는 모듈이 어떻게 처리되어야 하는지에 대한 힌트 같은 것입니다.\n\n지금은 TypeScript 5.3에서 이 \"resolution-mode\" 속성을 import 타입에도 확장했습니다. 따라서, 이제 일반적인 import뿐만 아니라 import()를 사용하여 동적으로 타입을 끌어올 때에도 사용할 수 있어요.\n\n여기에 더 실용적인 예시가 있습니다:```\n\n<div class=\"content-ad\"></div>\n\n```js\nexport type TypeFromRequire =\n    import(\"pkg\", { with: { \"resolution-mode\": \"require\" } }).TypeFromRequire;\n\nexport type TypeFromImport =\n    import(\"pkg\", { with: { \"resolution-mode\": \"import\" } }).TypeFromImport;\n\nexport interface MergedType extends TypeFromRequire, TypeFromImport {}\n```\n\n# resolution-mode All Module Modes에서 지원됩니다.\n\n과거에는 node16 및 nodenext와 같은 특정 moduleResolution 옵션에서만 resolution-mode 마법을 사용할 수 있었습니다.\n\n하지만 생각해보세요! TypeScript 5.3가 삶을 더 간단하게 만들어줍니다. 이제 bundler, node10 및 심지어 classic와 같은 모든 다른 moduleResolution 옵션과 함께 resolution-mode를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n더는 당신이 타입을 다루는 방식을 조정하고 싶어서 발생하는 오류가 더 이상 나타나지 않는다.\n\n TypeScript는 여러분이 원하는 모듈 모드에서 자유롭게 작업할 수 있도록 더 널널해졌어요. 멋지죠?\n\n# switch (true) 좁히기\n\n이제 true로 설정된 switch 문을 다룰 때, TypeScript가 각 case의 조건에 따라 타입을 똑똑하게 좁힐 수 있어요. 자세히 설명해 드릴게요.\n\n<div class=\"content-ad\"></div>\n\n자, 이런 함수가 있다고 하자:\n\n```js\nfunction f(x: unknown) {\n    switch (true) {\n        case typeof x === \"string\":\n            // 'x'은 여기서 'string'입니다.\n            console.log(x.toUpperCase());\n            // 계속 진행...\n\n        case Array.isArray(x):\n            // 'x'는 여기서 'string | any[]' 입니다.\n            console.log(x.length);\n            // 계속 진행...\n\n        default:\n            // 'x'는 여기서 'unknown'입니다.\n            // ...\n    }\n}\n```\n\n여기서 하는 일은, 각 case의 조건에 따라 TypeScript가 'x'의 유형을 더 수월하게 파악하는 것입니다.\n\n예를 들어, 'x'가 문자열이면, 그것을 알고 있으며, toUpperCase()와 같은 문자열 관련 작업을 수행할 수 있습니다. 배열인 경우에도 이해합니다.\n\n<div class=\"content-ad\"></div>\n\n# 불리언에 대한 비교 좁히기\n\n당신이 직접적으로 true 또는 false와 비교를 할 때를 말해요. 스타일적 이유이거나 JavaScript의 특징을 처리하기 위해서 명시적으로 무언가가 true인지 false인지 확인할 때 그렇습니다.\n\n이전에 TypeScript는 이러한 비교를 인지하지 못했지만, 이제는 도와줄 준비가 되어 있어요. 한 예제로 보여드릴게요:\n\n```js\ninterface A {\n    a: string;\n}\n\ninterface B {\n    b: string;\n}\n\ntype MyType = A | B;\n\nfunction isA(x: MyType): x is A {\n    return \"a\" in x;\n}\n\nfunction someFn(x: MyType) {\n    if (isA(x) === true) {\n        console.log(x.a); // TypeScript가 이해했어요!\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그래, isA(x) === true를 보셨나요? TypeScript가 그것을 이해하고 if 블록 내에서 타입을 더 좁게 인식할 수 있게 되었습니다.\n\n그래서 TypeScript가 불평하지 않고도 console.log(x.a)와 같은 작업을 자신 있게 수행할 수 있습니다.\n\n# Symbol.hasInstance를 통한 좁히기\n\ninstanceof를 사용할 때, [Symbol.hasInstance]로 정의된 메서드를 고려하여 더 똑똑해졌습니다. 이는 사용자 정의 타입 가드를 사용하여 타입을 더 정확하게 좁힐 수 있게 되었다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 통해 설명해 드리겠습니다:\n\nPoint라는 클래스가 있다고 상상해 보세요. 이제 TypeScript를 사용하여 [Symbol.hasInstance]를 사용하여 해당 클래스에 특별한 메서드를 정의할 수 있습니다. 이 메서드에서는 Point와 유사한지를 확인하기 위한 사용자 지정 로직을 구현할 수 있습니다.\n\n```js\nclass Point {\n    static [Symbol.hasInstance](val: unknown): val is PointLike {\n        // 여기에 사용자 정의 타입 가드 로직을 넣으세요\n    }\n}\n```\n\n그런 다음 코드에서 instanceof를 사용할 때 TypeScript는 사용자 정의 타입 가드를 인식하고 활용할 수 있습니다. 예를 들면:\n\n<div class=\"content-ad\"></div>\n\n```ts\nfunction f(value: unknown) {\n    if (value instanceof Point) {\n        // Now, you can access properties defined in PointLike,\n        // but you won't have access to specific Point methods or properties.\n    }\n}\n```\n\n그래서 이 기능은 기본적으로 TypeScript가 사용자 정의 유형 확인을 정말 이해하고 유형을 더 정확하게 좁힐 수 있도록 합니다.\n\n# 인스턴스 필드에서 수퍼 속성 액세스를 위한 검사\n\n클래스를 다룰 때 기반 클래스에서 메서드에 접근하기 위해 super 키워드를 사용할 수 있습니다. 이것은 \"이 클래스에서 상속 받은 클래스로부터 메서드를 가져오게 해줘\"라는 방식입니다.\n\n\n<div class=\"content-ad\"></div>\n\n예를 들어:\n\n```js\nclass Base {\n    someMethod() {\n        console.log(\"베이스 메서드 호출됨!\");\n    }\n}\n\nclass Derived extends Base {\n    someMethod() {\n        console.log(\"파생 메서드 호출됨!\");\n        super.someMethod();\n    }\n}\n\nnew Derived().someMethod();\n// 출력:\n//   파생 메서드 호출됨!\n//   베이스 메서드 호출됨!\n```\n\n따라서 super.someMethod()은 베이스 클래스에서 메서드를 특별히 얻는 방법임을 알 수 있습니다.\n\n이제 여기가 tricky한 부분입니다. 클래스 필드(전체의 속성)를 다룬다면, 동일한 방식으로 super를 사용하는 것이 예상대로 작동하지 않을 수 있습니다. TypeScript 5.3는 이를 잘 파악하여 경고를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n여기 예시가 있어요:\n\n```js\nclass Base {\n    someMethod = () => {\n        console.log(\"someMethod called!\");\n    }\n}\n\nclass Derived extends Base {\n    someOtherMethod() {\n        super.someMethod(); // 이제 오류가 발생할 거예요!\n    }\n}\n\nnew Derived().someOtherMethod();\n// 💥\n// 'super.someMethod'이 'undefined'이기 때문에 작동하지 않아요.\n```\n\n그래서 TypeScript 5.3은 super를 사용하여 무언가에 접근할 때 그것이 클래스 필드인지 확인해요. 그게 맞다면, super를 통해 접근하려고 하면 TypeScript가 런타임 오류에 부딪히기 전에 멈춰줄 거예요. 코드에 잠입하는 교묘한 버그를 막기 위해 친구가 코드를 한 번 더 확인해주는 것 같죠!\n\n# 자동 Imports 유형을 선호하는 설정\n\n<div class=\"content-ad\"></div>\n\n자동으로 타입에 대한 import를 추가할 때, 이전에는 사용자 설정을 기반으로 했습니다. 예를 들어, Person이라는 타입이 있는 경우:\n\n```js\nexport let p: Person;\n```\n\nTypeScript는 보통 다음과 같이 import를 추가했을 것입니다:\n\n```js\nimport { Person } from \"./types\";\n\nexport let p: Person;\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 설정에 따라 다를 수 있습니다. 예를 들어, verbatimModuleSyntax와 같은 특정 설정이 있는 경우에는 type 수정자를 추가할 수도 있습니다:\n\n```js\nimport { type Person } from \"./types\";\n\nexport let p: Person;\n```\n\n이제 TypeScript는 더 많은 제어권을 제공합니다. 특정한 선호도가 있거나 코드베이스에서 특정 옵션을 사용할 수 없는 경우, 가능한 경우에는 항상 명시적인 타입 가져오기를 설정할 수 있습니다. 이는 \"안녕 TypeScript, 이렇게 해 달라고 말했어, 깜짝 놀라지 말고\"라고 말하는 것과 같습니다. 그래서 TypeScript를 자신이 원하는 방식으로 작동하도록 만드는 것입니다.\n\n# TypeScript 5.3에서 몇 가지 최적화가 소개되었습니다:\n\n<div class=\"content-ad\"></div>\n\n우선, JSDoc 파싱을 스킵하고 있습니다. 이는 TypeScript가 JSDoc에 불필요한 시간과 메모리를 소비하지 않아 컴파일 속도를 높일 수 있음을 의미합니다.\n\n특히 변경 사항이 빈번한 감시 모드에서 이 점이 특히 두드러집니다. 게다가, 이 개선은 TypeScript 자체뿐만 아니라 typescript-eslint와 Prettier와 같은 도구들도 이 속도 및 메모리 향상으로 이점을 얻을 수 있습니다.\n\n또한, TypeScript가 교차(intersections)를 처리하는 방식에 최적화가 있습니다. 이는 TypeScript가 유니언과 교차에서 특히 타입을 비교하는 데 능숙해지고 있는 것과 같습니다.\n\n원본 교차형식을 살펴보면, 이제 더 빠르게 확인할 수 있어 타입 평가가 더 효율적으로 이루어집니다.\n\n<div class=\"content-ad\"></div>\n\n마지막으로 TypeScript는 tsserverlibrary.js 및 typescript.js 라이브러리 파일을 합치면서 봄철처럼 청소를 하고 있어요.\n\n중복을 줄이고 일관성을 높이기 위해 이들을 결합하고 있습니다.\n\n이렇게 하면 API 사용이 보다 간소화되며 자원 사용량이 감소하는데 도움이 됩니다. 모든 것이 제 자리에 있고 원활하게 작동되도록 집을 정리하는 것과 같아요.\n\n자세한 변경 사항에 대한 내용은 여기에서 확인할 수 있는 완전한 릴리스 로그를 참조해 주세요.\n\n<div class=\"content-ad\"></div>\n\n제 Medium 페이지와 연결해 보세요! ✍ : https://medium.com/@Evelyn.Taylor","ogImage":{"url":"/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png"},"coverImage":"/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png","tag":["Tech"],"readingTime":9},{"title":"Cars24 SDE-2 Frontend 면접 경험","description":"","date":"2024-05-18 21:46","slug":"2024-05-18-Cars24SDE-2FrontendInterviewExperience","content":"\n\n나는 링크드인에서 리쿠루터에게 연락했다.\n\n# 1차 면접 — JS\n\n질문 1 — 클로저란 무엇이며 예시와 함께 설명해보세요.\n\n```js\nfunction closure() {\n    let count = 0;\n    return function test() {\n        count++;\n        return count;\n    }\n}\n\nconst closuredTest = closure();\n\nconsole.log(closuredTest());\nconsole.log(closuredTest());\nconsole.log(closuredTest());\n```\n\n<div class=\"content-ad\"></div>\n\n2번 문제 - 커리(curry)란 무엇이며 주어진 함수의 커리 고차 함수를 만드세요.\n\n```js\nfunction sum(a, b, c){\n  return a + b + c; \n}\n```\n\n```js\nfunction curry(fn){\n  return function curriedFn(...params){\n    if(params.length >= fn.length){\n      return fn(...params);\n    }\n    else{\n      return function(...next){\n        return curriedFn(...params,...next);\n      }\n    }\n  }\n}\n\nlet curriedSum = curry(sum);\n\nconsole.log(curriedSum(1, 2, 3));   // 6, 일반적으로 호출 가능\nconsole.log(curriedSum(1)(2,3));    // 6, 첫 번째 인수 커리\nconsole.log(curriedSum(1)(2)(3));   // 6, 완전한 커리\n```\n\n3번 문제 - Task Queue(작업 큐) 및 이벤트 루프에 대해 설명해보세요.\n먼저 구두로 설명한 후 코드 스니펫을 작성했습니다.\n\n<div class=\"content-ad\"></div>\n\n\n## question4 — output based question\n\n```js\nasync function async1() {\n    console.log(\"async1 start\");\n    const data = await async2();\n    console.log(data);\n    console.log(\"async1 end\");\n}\n\nasync function async2() {\n    console.log(\"async2\");\n    return \"async2 completed\";\n}\n\nconsole.log(\"script start\");\n\nsetTimeout(function () {\n    console.log(\"setTimeout\");\n}, 0);\n\nasync1();\n\nnew Promise(function (resolve) {\n    console.log(\"promise1\");\n    resolve();\n}).then(function () {\n    console.log(\"promise2\");\n});\n\nconsole.log(\"script end\");\n```\n\nquestion 5 — explain this keyword and how can we change it forcefully\n\n\n<div class=\"content-ad\"></div>\n\n```javascript\nlet obj = {\n    name: 'prikshit',\n    myName(city, birthPlace) {\n        console.log(this.name + ' i live in ' + city + ' my birthplace is ' + birthPlace);\n    }\n}\n\nlet obj2 = {\n    name: 'sohail',\n}\n\n// obj.myName.call(obj2,'blr');\n// obj.myName.apply(obj2,['blr']);\n\nconst bindedFn = obj.myName.bind(obj2);\n\nbindedFn('blr', 'delhi');\n\nobj.myName(); // this keyword here is obj\n```\n\n## 2nd Round — Machine Coding\n\n1. **1st question** - 온라인/오프라인 상태를 보여주는 사용자 정의 훅을 만들어 보세요. (해결 사항)\n\n2. **2nd question** - 그리드 라이트를 만들어 보세요. (Uber 인터뷰어들의 즐겨하는 문제)\n\n\n<div class=\"content-ad\"></div>\n\n# 3차 라운드 — 기술 관리 라운드\n\n이번 라운드에서 면접관은 전자 상거래 필터 구성 요소를 만들어 달라고 했어요.","ogImage":{"url":"/assets/img/2024-05-18-Cars24SDE-2FrontendInterviewExperience_0.png"},"coverImage":"/assets/img/2024-05-18-Cars24SDE-2FrontendInterviewExperience_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 ","description":"","date":"2024-05-18 21:46","slug":"2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration","content":"\n\n\n\n![RAII Reimagined: Embracing Lifecycle Hooks](/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png)\n\n# RAII Reimagined: Embracing Lifecycle Hooks\n\nRAII은 객체 초기화 중에 리소스를 획득하고 파괴 시에 해제하는 것을 강조합니다. React Native에서는 컴포넌트 라이프사이클 훅이 RAII를 가능하게 합니다:\n\n```js\nimport React, { useEffect } from 'react';\nimport Geolocation from '@react-native-community/geolocation'; // 예시 리소스\n\nfunction LocationTracker() {\n  useEffect(() => {\n    const watchId = Geolocation.watchPosition(location => {\n      // ... 위치 데이터 처리\n    });\n\n    return () => {\n      Geolocation.clearWatch(watchId); // 언마운팅시 워치 해제\n    };\n  }, []); \n\n  // ... 컴포넌트 로직\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\n이 코드 조각에서:\n\n- useEffect는 컴포넌트가 마운트될 때 지리적 위치 감시를 설정합니다.\n- useEffect에서 반환된 정리 함수는 소멸자와 유사하게 동작하여 컴포넌트가 마운트 해제될 때 감시를 지워 리소스 누출을 방지합니다.\n\n# 스마트 포인터: TypeScript에서의 색다른 접근\n\nTypeScript에는 진정한 스마트 포인터가 없지만 클래스를 사용하여 그 본질을 모방할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AudioPlayer {\n  private sound: Sound | null; \n\n  constructor(filePath: string) {\n    this.sound = new Sound(filePath, error => {\n      // ... handle potential errors\n    });\n  }\n\n  play() {\n    if (this.sound) this.sound.play();\n  }\n\n  release() { \n    if (this.sound) {\n      this.sound.release(); \n      this.sound = null;\n    }\n  }\n}\n```\n\n구성요소에서:\n\n```js\nuseEffect(() => {\n  const player = new AudioPlayer('path/to/sound.mp3');\n  // ...\n\n  return () => {\n    player.release(); // 청소스럽게 오디오 자원을 해제합니다\n  };\n}, []);\n```\n\nAudioPlayer 클래스는 Sound 객체를 캡슐화하고 제어된 접근을 제공합니다. release 메서드는 스마트 포인터의 소멸자를 흉내내어 적절한 정리를 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n# 신중한 참조: 원시 포인터 함정 피하기\n\n객체 참조를 부드러운 포인터처럼 취급하세요:\n\n- 구독 취소: 컴포넌트가 언마운트될 때 항상 이벤트 이밋터나 옵저버블 구독을 해제하세요.\n- 인터벌 비우기: clearInterval 및 clearTimeout를 꼼꼼히 사용하세요.\n- 순환 참조 해제: 가비지 컬렉션을 방해할 수 있는 순환 참조에 주의하세요.\n\n기본 이상으로\n\n<div class=\"content-ad\"></div>\n\n- 라이브러리: RxJS (Observables)나 React Native AppState API와 같은 라이브러리를 고려하여 자원 관리를 효율적으로 처리합니다.\n- 커스텀 훅: 복잡한 자원 상호작용을 캡슐화하기 위해 커스텀 훅을 작성합니다.\n- 에러 처리: 자원 관리 전략에 정교한 에러 처리를 통합합니다.\n\nRAII 원칙을 적용하고 스마트 포인터에서 영감을 받아 React Native TypeScript 개발을 높여나갈 수 있습니다. 자원을 자신있게 관리하고 메모리 누수를 방지하며 시간이 지날수록 늘 튼튼한 애플리케이션을 구축하세요.","ogImage":{"url":"/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png"},"coverImage":"/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png","tag":["Tech"],"readingTime":3}],"page":"7","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}