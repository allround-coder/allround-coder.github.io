{"pageProps":{"posts":[{"title":"취업 전에 반드시 알아야하는 Reactjs의 10가지 핵심 개념 ","description":"","date":"2024-05-12 20:18","slug":"2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment","content":"\n![이미지](/assets/img/2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment_0.png)\n\n안녕, 친구들! 오늘은 웹 개발의 슈퍼히어로인 React.js의 마법같은 세계를 함께 즐겁게 탐험할 거에요. 생각해봐요, 당신이 주방에서 요리사라고 상상해봐요. 그리고 React.js가 여러분의 음식에 넣으면 모든 요리(웹 애플리케이션)가 맛있고 아름답게 보이게 만들어주는 비밀 재료라고 생각해봐요. 이제 React.js를 주인공으로 뽑아낸 10가지 핵심 개념을 알아봐요.\n\n#1. VirtualDOM: 성능의 슈퍼히어로\n\n비디오 게임을 하고 있는데 매번 버튼을 누를 때마다 화면 전체가 번쩍이면 재미없겠죠? React.js는 VirtualDOM을 사용하여 이 문제를 해결해요. 이는 당신의 웹사이트가 어떻게 보일지 미리 보여주는 것인데, 실제로 화면을 업데이트하지 않아요. 이렇게 함으로써 React.js는 필요한 내용만 업데이트해서 여러분의 웹사이트를 부드럽게 만들어줘요. 완전히 버터 같죠!\n\n# 2. JSX: React 언어\n\nJSX는 React.js가 사용하는 비밀 언어 같아요. HTML처럼 보이지만 실제로는 JavaScript에요. 온라인으로 피자를 주문할 때 특별한 코드로 말하는 것과 비슷해요. 한번 익숙해지면 재미있고 코드를 읽기 쉽게 만들어 줘요.\n\n# 3. Components: React의 구성 요소\n\nReact.js 세계에서 모든 것은 구성 요소로 이루어져 있어요. 그들을 레고 블록처럼 생각해보세요. 간단한 버튼부터 복잡한 양식까지 아무 것이나 만들 수 있고, 이 블록(구성 요소)을 다시 재사용할 수도 있어요. 원하는 모든 모양으로 변할 수 있는 마법 상자를 가지고 있는 것과 비슷해요.\n\n# 4. 프롭스: 메신저\n\n프롭스는 한 컴포넌트에서 다른 컴포넌트로 전송되는 편지처럼 작동합니다. 그들은 정보를 전달하고 컴포넌트에게 어떤 것을 표시할지 알려줍니다. 친구에게 메시지를 보내고, 그들이 다시 답장하는 상황을 상상해보세요. 이것이 React.js에서 프롭스가 동작하는 방식입니다. 모든 컴포넌트들이 같은 페이지에 있는지 확인합니다.\n\n# 5. 상태: 기억 보관함\n\n상태는 컴포넌트가 자체 정보를 기록하는 다이어리와 같습니다. 그것은 지난 일들을 기억하고 시간이 지남에 따라 변경됩니다. 지난 여름에 어떤 맛의 아이스크림을 좋아했는지 기억하는 것과 비슷합니다.\n\n# 6. 라이프사이클 메소드: 이야기꾼\n\n라이프사이클 메소드는 책의 장(chapters)과 같아요. 컴포넌트의 수명 주기를 이야기하는데, 그것은 그 컴포넌트가 태어나서 성장하고 마침내 떠날 때까지의 이야기 같아요. 마치 내가 좋아하는 영화 캐릭터의 생일을 알고 있는 것 같은 느낌이에요.\n\n# 7. 훅: 게임 체인저\n\n훅은 비디오 게임에서의 치트 코드와 같은 역할이에요. 클래스를 작성하지 않고도 상태(state) 및 다른 리액트(React) 기능을 사용할 수 있게 해줘요. 마법 지팡이를 휘두르지 않고도 모든 것을 할 수 있는 그런 느낌이에요.\n\n# 8. 문맥: 글로벌 소문\n\n문맥은 마을의 장난꾸러기처럼 동작합니다. 다른 구성 요소끼리 속삭이지 않아도 모두에게 정보를 공유합니다. 마을의 최신 소문을 알게 되는 느낌이죠.\n\n# 9. 조정: 평화지기\n\n조정은 축구 경기의 심판과 같습니다. 새로운 계획(가상 DOM)을 이전 계획과 비교하여 업데이트가 필요한 부분을 결정합니다. 모두가 동의할 수 있도록 싸움을 일으키지 않고 모든 사람이 같은 페이지에 있는지 확인하는 느낌입니다.\n\n# 10. 리액트 라우터: 여행 안내서\n\n리액트 라우터는 당신의 웹사이트를 위한 여행 안내서와 같아요. 사용자들이 길을 잃지 않고 서로 다른 페이지를 탐험할 수 있게 도와줍니다. 다음으로 어디로 가야할지 보여주는 지도가 있다고 생각해봐요.\n\n여기서 보았던 바와 같이, 리액트.js의 10가지 핵심 개념이 즐겁고 이해하기 쉬운 방식으로 설명되었어요. 당신이 기술 마법사라도, 웹 개발의 세계에 호기심 가득하더라도, 리액트.js는 흥미로운 것을 제공해줘요. 그래서 뭐해요? 리액트.js의 세계에 뛰어들어서 멋진 웹 애플리케이션을 만들기 시작해보세요. 언제나 기억하세요, 천 마일의 여정은 한 번의 클릭으로 시작됩니다. 즐거운 코딩 하시고, 당신의 리액트.js 여정이 소금버터처럼 부드럽기를 기원합니다.\n","ogImage":{"url":"/assets/img/2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment_0.png"},"coverImage":"/assets/img/2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트가 fetch를 왜 제거했는지 지금 RSC-fetch를 작성하기 위해 반드시 알아야 하는 내용","description":"","date":"2024-05-12 20:17","slug":"2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch","content":"\n\n<img src=\"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png\" />\n\n몇 일 전, React 팀이 암시적인 fetch 캐시를 제거했습니다. 그리고 fetch 요청의 결과를 명시적으로 캐시하는 데 `React.cache`를 사용하는 것을 제안했습니다. 새로운 `React.cache` API의 장점을 최대한 활용하려면 RSC에서 fetch 호출을 작성하는 새로운 방법을 이해하는 것이 중요합니다. 그러나 새로운 방법에 대한 이해에 접어들기 전에, 개발자가 캐시를 명시적으로 관리하는 것이 왜 유익한지 먼저 이해해 봅시다.\n\n암시적 캐싱의 위험성\n\n캐싱은 전반적으로 유익해 보이지만, 브라우저나 프레임워크가 개발자의 제어 없이 자동으로 데이터를 캐시하는 암시적 캐싱은 예상치 못한 동작과 버그를 일으킬 수 있습니다. 여기에 이유가 있습니다:\n\n\n\n- 만료된 데이터: API 응답이 자주 변경되는 경우, 암시적으로 캐싱을 하면 사용자에게는 오래된 정보가 제공될 수 있어서 보여지는 데이터와 실제 상태 사이에 불일치가 발생할 수 있습니다.\n- 일관성이 없음: 다른 브라우저나 브라우저 설정은 캐싱을 다르게 구현할 수 있어 사용자 경험 사이에 불일치가 생길 수 있습니다.\n- 디버깅 문제: 만료된 데이터로 인한 문제가 발생할 때, 캐싱 메커니즘을 명시적으로 제어하지 않는 경우 원인을 파악하기 어려울 수 있습니다.\n\n성능과 유지보수성을 위한 명시적 제어\n\n명시적 캐싱을 선택함으로써, 개발자가 데이터가 어떻게 그리고 언제 캐싱되는지에 대한 소유권을 갖도록 장려합니다. 이를 통해 우리는 다음과 같은 이점을 가질 수 있습니다:\n\n- 캐싱 전략 정의: 데이터의 특성과 업데이트 빈도에 기반하여 적절한 캐싱 전략을 선택할 수 있습니다. 예를 들어, 정적 데이터는 무기한 캐싱될 수 있으며, 자주 변경되는 데이터는 유효성 검사 메커니즘이 필요할 수 있습니다.\n- 무효화 처리: 캐시 만료 시간이나 무효화 리스너와 같은 기술을 구현하여 캐시가 적합하고 오래된 정보를 제공하지 않도록 할 수 있습니다.\n- 개선된 디버깅: 캐싱을 명시적으로 제어함으로써 데이터 흐름을 쉽게 이해하고 캐싱 문제의 원인을 식별할 수 있어 개발자들이 문제 해결을 용이하게 할 수 있습니다.\n\n\n\nReact fetch 캐시는 무엇인가요?\n\nfetch 호출을 하면 React가 fetch 결과를 캐싱했습니다. 다른 컴포넌트들이 동일한 데이터를 필요로 하여 동일한 fetch 호출을 하면, React는 엔드포인트로 새로운 요청을 보내지 않고 대신에 캐시로부터 데이터를 다른 컴포넌트에 제공합니다. 이는 성능을 위해 좋지만, 예상치 못한 동작을 일으킬 수도 있습니다. 예를 들어, 아래 코드에서 다섯 개의 컴포넌트가 fetch 호출을 하고 모두 동일한 데이터가 필요합니다. 이렇게 요청을 만들 경우에 React는 결과를 캐시하지 않고 동일한 엔드포인트에 다섯 번의 요청을 보냅니다. 여기서 `React.cache` API가 캐시를 명시적으로 관리하기 위해 등장합니다.\n\n\n\n**Reach.cache()** 새로운 방법으로 fetch 호출 작성하기\n\n이제는 동일한 데이터가 필요한 다른 컴포넌트가 있다면 새로운 요청을 수행하지 않도록 fetch 호출을 React.cache로 래핑해야 합니다. 이것은 한 번의 요청만을 수행합니다.\n\n```js\nimport React from \"react\"\n\nconst getMessiStats = React.cache(async () => {\n    const stats = await fetch('https://api.football-data.org/v2/players/52')\n    return stats.json()\n})\n\nasync function MessiStats() {\n    const data = await getMessiStats()\n    return (\n        <div>\n            {JSON.stringify(data)}\n        </div>\n    )\n}\n\nexport async function RSCFetch() {\n    const stats = await getMessiStats()\n    return (\n        <>\n            <div>{JSON.stringify(stats)}</div>\n            <MessiStats />\n            <MessiStats />\n            <MessiStats />\n            <MessiStats />\n        </>\n    )\n}\n```","ogImage":{"url":"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png"},"coverImage":"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트에서 useMemo 사용하기 - 코드 예제와 함께 1부 2부","description":"","date":"2024-05-12 20:15","slug":"2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12","content":"\n\n<img src=\"/assets/img/2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12_0.png\" />\n\nReact에서 useMemo는 계산에 대한 메모지와 같은 역할을 합니다. 그것은 답을 기억하기 때문에 매번 다시 계산할 필요가 없습니다.\n\n# 계산 시간을 단축하기\n\nuseMemo를 처음에 사용하여 결과를 저장하고 매번 컴포넌트가 업데이트될 때마다 다시 계산하는 것을 피하세요.\n\n\n\n```js\nimport { useMemo } from 'react';\n\nfunction TodoList({ todos, tab, theme }) {\n  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n  // ...\n}\n```\n\n컴포넌트가 다시 렌더링될 때마다 비싼 계산을 방지하려면 useMemo를 사용할 수 있어요. 이는 컴포넌트에 계산에 대한 단기 기억을 제공하는 것 같아요. 작동 방식은 다음과 같아요:\n\n- 두 가지 요소: useMemo에는 두 가지 요소가 필요해요:\n\n- 계산: 메모이즈하려는 계산을 수행하는 함수. 이 함수는 어떤 인수도 받지 않아야 해요 (() =` ...).\n- 감시 목록(의존성): useMemo가 계산 내부에서 사용하는 값들을 계속 지켜보아야 하는 목록. 이 값 중 하나라도 변경되면 계산을 다시 해야 해요.\n\n\n\n- 초기 렌더링: 컴포넌트가 처음 렌더링될 때 useMemo는 계산을 실행하고 결과를 저장합니다.\n- 이후 렌더링: 나중에 업데이트될 때 useMemo는 현재 종속성을 이전 렌더링에서 사용된 값과 비교합니다. 감지된 값 중 하나도 변경되지 않은 경우 (깊은 동등성을 위해 Object.is로 비교), useMemo는 이전에 계산된 결과를 단순히 반환하여 시간을 절약합니다.\n- 계산 재실행 트리거: 종속성 중 하나라도 변경된 경우, useMemo는 계산이 업데이트되어야 함을 이해합니다. 함수를 다시 실행하고 새로운 결과를 반환합니다.\n\n요약하면 useMemo는 계산 결과를 캐시처럼 저장하여 종속된 데이터가 변경될 때까지 유지합니다.\n\n실제 유용한 예제를 살펴보겠습니다.\n\n## 느린 계산 시뮬레이션과 useMemo의 힘\n\n\n\nuseMemo의 가치를 보여주기 위해, 이 예시에서는 filterTodos 함수에 의도적으로 지연을 추가했습니다. 이는 계산이 계산적으로 비싸다고 할 수 있는 실제 시나리오를 모방합니다.\n\n테스트해보세요!\n\n탭 간을 전환하고 테마를 토글해보세요. 특히 테마를 토글할 때 느린 반응을 느낄 수 있을 겁니다.\n\n왜 느려질까요?\n\n\n\n이 버전에서는 useMemo를 사용하지 않았어요. 그 결과로, sluggish한 filterTodos 함수가 모든 리렌더링마다 호출되는데, 테마에 변경이 있는 경우에도 호출됩니다 (필터링 로직에는 영향을 주지 않는 경우). 이 불필요한 다시 계산이 지연을 유발해요.\n\nApp.js\n\n```js\nimport { useState } from 'react';\nimport { createTodos } from './utils.js';\nimport TodoList from './TodoList.js';\n\nconst todos = createTodos();\n\nexport default function App() {\n  const [tab, setTab] = useState('all');\n  const [isDark, setIsDark] = useState(false);\n  return (\n    <>\n      <button onClick={() => setTab('all')}>\n        All\n      </button>\n      <button onClick={() => setTab('active')}>\n        Active\n      </button>\n      <button onClick={() => setTab('completed')}>\n        Completed\n      </button>\n      <br />\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={isDark}\n          onChange={e => setIsDark(e.target.checked)}\n        />\n        Dark mode\n      </label>\n      <hr />\n      <TodoList\n        todos={todos}\n        tab={tab}\n        theme={isDark ? 'dark' : 'light'}\n      />\n    </>\n  );\n}\n```\n\nTodoList.js\n\n\n\n```js\nimport { filterTodos } from './utils.js';\n\nexport default function TodoList({ todos, theme, tab }) {\n  const visibleTodos = filterTodos(todos, tab);\n  return (\n    <div className={theme}>\n      <ul>\n        <p><b>참고: <code>filterTodos</code>가 인위적으로 느려집니다!</b></p>\n          {visibleTodos.map(todo => (\n            <li key={todo.id}>\n              {todo.completed ?\n                <s>{todo.text}</s> :\n                todo.text\n              }\n            </li>\n          ))}\n      </ul>\n    </div>\n  );\n}\n``` \n\nutils.js\n\n```js\nexport function createTodos() {\n  const todos = [];\n  for (let i = 0; i < 50; i++) {\n    todos.push({\n      id: i,\n      text: \"할 일 \" + (i + 1),\n      completed: Math.random() > 0.5\n    });\n  }\n  return todos;\n}\n\nexport function filterTodos(todos, tab) {\n  console.log('[인위적으로 느려짐] \"' + tab + '\" 탭을 위해 ' + todos.length + '개의 할 일을 필터링합니다.');\n  let startTime = performance.now();\n  while (performance.now() - startTime < 500) {\n    // 극도로 느린 코드를 흉내 내기 위해 500ms 동안 아무것도 하지 않습니다.\n  }\n\n  return todos.filter(todo => {\n    if (tab === 'all') {\n      return true;\n    } else if (tab === 'active') {\n      return !todo.completed;\n    } else if (tab === 'completed') {\n      return todo.completed;\n    }\n  });\n}\n```\n\n모든 것에 끈적이지 않는 쪽지가 필요한 것은 아닙니다 (useMemo)\n```\n\n\n\n대부분의 경우, 메모이제이션 없이도 코드는 완벽하게 작동합니다. 응용 프로그램이 반응적이고 상호 작용이 원활하다면, 일단 useMemo를 사용할 필요가 없을 수도 있습니다.\n\n성능 테스트\n\nutils.js에 더 많은 할 일 항목을 추가해보고 동작을 관찰해보세요. 이 예제에서 필터링 자체는 그다지 느리지 않았습니다. 그러나 대량의 할 일이 있는 경우 대부분의 성능 병목 현상이 필터링에서 다시 렌더링 프로세스로 옮겨질 수 있습니다.\n\n# 스마트 업데이트: 필요할 때만 다시 렌더링하기\n\n\n\n일부 상황에서 useMemo는 구성 요소 내에서의 계산 뿐만 아니라 하위 구성 요소의 다시 렌더링을 최적화하는 데 도움이 될 수도 있습니다.\n\n예를 살펴봅시다\n\n우리의 TodoList 구성 요소가 필터링된 visibleTodos를 자식 List 구성 요소로 전달할 때를 상상해보세요. 이 내용은 다음 섹션에서 useMemo가 이 시나리오에서 어떻게 사용될 수 있는지 탐구하는 데 기초를 제공합니다.\n\n```js\nexport default function TodoList({ todos, tab, theme }) {\n  // ...\n  return (\n    <div className={theme}>\n      <List items={visibleTodos} />\n    </div>\n  );\n}\n```\n\n\n\n리액트는 일반적으로 부모 컴포넌트가 다시 렌더링될 때 자식 컴포넌트 전체를 다시 렌더링합니다. 이것이 TodoList에서 theme이 변경되어도 List 컴포넌트가 다시 렌더링되는 이유입니다 (visibleTodos prop에 영향을 주지 않는 한).\n\n그러나 자식 컴포넌트에서 느린 다시 렌더링 프로세스를 식별했다면, 성능을 개선할 수 있는 memo라는 기술을 활용할 수 있습니다. List 컴포넌트를 memo로 감싸면, List가 이전 렌더링과 비교해 실제로 변경된 props가 없다면 React에게 불필요한 다시 렌더링을 건너뛰도록 지시할 수 있습니다.\n\n```js\nimport { memo } from 'react';\n\nconst List = memo(function List({ items }) {\n  // ...\n});\n```\n\nList 컴포넌트를 memo로 감싸면, List의 props가 실제로 변경될 때만 List를 다시 렌더링하도록 React에 지시하는 셈입니다. 이는 특히 다시 렌더링 비용이 높은 컴포넌트에 대해서는 성능을 크게 향상시킬 수 있습니다.\n\n\n\n```js\nexport default function TodoList({ todos, tab, theme }) {\n  // 테마가 변경될 때마다, 이는 다른 배열이 됩니다...\n  const visibleTodos = filterTodos(todos, tab);\n  return (\n    <div className={theme}>\n      {/* ... 따라서 List의 props는 항상 동일하지 않으며 매번 재랜더링됩니다 */}\n      <List items={visibleTodos} />\n    </div>\n  );\n}\n```\n\n이전 예시에서 filterTodos 함수는 배열의 내용이 동일해도 항상 새 배열 객체를 반환합니다. 이 동작은 ''를 사용하여 객체 리터럴을 만들 때 항상 새로운 객체가 생성되는 방식과 유사합니다.\n\n보통, 이는 큰 문제가 되지 않을 수 있습니다. 그러나 우리의 경우에는 List 컴포넌트를 최적화하기 위해 memo를 사용하는데, 렌더링 사이에 props를 비교하는 데 의존합니다. filterTodos가 내용이 동일하더라도 항상 새 배열을 생성한다면, memo는 항상 다른 props로 인식하여 List를 다시 렌더링합니다. 이는 최적화의 목적을 무효화시킵니다.\n\n```js\nexport default function TodoList({ todos, tab, theme }) {\n  // React에게 다시 렌더링 사이에 계산을 캐시하도록 알립니다...\n  const visibleTodos = useMemo(\n    () => filterTodos(todos, tab),\n    [todos, tab] // ...따라서 이러한 종속성이 변경되지 않는 한...\n  );\n  return (\n    <div className={theme}>\n      {/* ...List는 동일한 props를 받고 렌더링을 건너뛸 수 있습니다 */}\n      <List items={visibleTodos} />\n    </div>\n  );\n}\n```\n\n\n\nvisibleTodos 계산을 useMemo로 감싸면, 필터링에 사용된 데이터(할 일 항목)가 변경되지 않는 한, 다시 렌더링 사이에 동일한 배열 참조를 반환함을 보장합니다. 이는 memo가 효과적으로 프롭을 비교하고 List 컴포넌트의 불필요한 다시 렌더링을 건너뛸 수 있도록 합니다.\n\n# 훅 체인에서 중복 계산 방지\n\n컴포넌트 코드 내에서 직접 정의한 사용자 지정 객체에 계산이 의존하는 경우는 어떻게 될까요?\n\n```js\nfunction Dropdown({ allItems, text }) {\n  const searchOptions = { matchMode: 'whole-word', text };\n\n  const visibleItems = useMemo(() => {\n    return searchItems(allItems, searchOptions);\n  }, [allItems, searchOptions]); // 🚩주의: 컴포넌트 내에서 생성된 객체에 의존성\n  // ...\n```\n\n\n\n## 컴포넌트 내 객체의 도전\n\n`useMemo`를 사용할 때 컴포넌트 코드 내에서 직접 생성된 객체와 관련된 잠재적인 함정이 있습니다. 해당 컴포넌트 내의 모든 코드가 다시 렌더링될 때마다 실행되므로, 매번 객체를 생성하는 것은 메모이제이션의 목적을 무효화시킵니다.\n\n## 왜 동작하지 않는지\n\n검색옵션이라는 객체에 의존하는 계산이 있다고 상상해보십시오. 이 객체를 컴포넌트 본문 안에서 직접 생성하고 `useMemo`의 의존성으로 추가한다면 문제가 발생합니다. React는 모든 코드를 다시 실행하기 때문에, 다시 렌더링될 때마다 검색옵션 객체를 재생성합니다. 심지어 그 내용이 동일하더라도 말이죠. 이는 `useMemo`가 항상 새로운 객체 참조를 보게 하고 실제 데이터가 변경되지 않았더라도 다시 계산을 시작하도록 유발합니다.\n\n\n\n## 해결책: 사전에 객체를 메모이즈(Memoize)하세요\n\n이 문제를 해결하기 위해, useMemo에 전달하기 전에 검색 옵션 객체 자체를 메모이즈하세요. 이렇게 하면 관련 데이터가 변경되지 않을 때 useMemo이 일관된 객체 참조를 받아들여 적절히 계산 결과를 캐시할 수 있습니다.\n\n```js\nfunction Dropdown({ allItems, text }) {\n  const searchOptions = useMemo(() => {\n    return { matchMode: 'whole-word', text };\n  }, [text]); // ✅ 텍스트가 변경될 때만 변경됩니다\n\n  const visibleItems = useMemo(() => {\n    return searchItems(allItems, searchOptions);\n  }, [allItems, searchOptions]); // ✅ allItems 또는 searchOptions가 변경될 때만 변경됩니다\n  // ...\n```\n\n## 더 간략한 방법\n\n\n\n이전 예제에서는 useMemo에 전달하기 전에 searchOptions 객체를 기억하도록 언급했습니다. 그것은 동작하지만, 더 원할한 방법이 있습니다.\n\n## 모든 것을 함께 유지\n\n객체를 따로 기억하는 대신, 그것을 useMemo 계산 함수 내부에 직접 이동시키면 어떨까요? 이렇게 하면 객체의 생성이 사용하는 계산과 밀접하게 연관됨이 보장됩니다.\n\n## 장점\n\n\n\n`useMemo` 내에서 객체 정의를 배치함으로써, 계산이 실제로 실행될 때만 객체가 생성된다는 것을 보장합니다. 게다가, 객체의 로직에 대한 모든 변경 사항이 자동으로 계산에 반영되어 동기화를 유지합니다. 이는 코드를 닍고 일관성을 보장하여 모든 것을 간단하게 만들어 줍니다.\n\n```js\nfunction Dropdown({ allItems, text }) {\n  const visibleItems = useMemo(() => {\n    const searchOptions = { matchMode: 'whole-word', text };\n    return searchItems(allItems, searchOptions);\n  }, [allItems, text]); // ✅ allItems 또는 text가 변경될 때만 변경됩니다\n  // ...\n```\n\n# 함수 캐싱\n\nForm 컴포넌트가 React.memo()를 사용하여 성능 최적화되어 있다고 가정해봅시다. 이 컴포넌트에 함수를 속성(prop)으로 제공하고 싶습니다.\n\n\n\n상상해봐요. 뭔가를 담을 상자('')가 있다고 생각해봐요. 새 상자를 사용할 때마다 새로운 빈 상자를 얻게 돼요. 마찬가지로 React에서 두 가지 방식으로 함수를 정의하면(함수() ''와 () =` ''), 매번 완전히 새로운 함수가 만들어져요. 이것 자체로는 나쁜 것이 아니에요. 하지만 Form 컴포넌트를 최적화하고 불필요한 업데이트를 방지하기 위해 React.memo()를 사용하는 경우, 계속 변하는 함수 prop은 해당 최적화를 무의미하게 만들 수 있어요.\n\n함수를 다시 렌더링하지 않도록 useMemo를 사용하려면, useMemo 내부의 함수는 다른 함수를 반환해야 해요.\n\n```js\nexport default function Page({ productId, referrer }) {\n  const handleSubmit = useMemo(() => {\n    return (orderDetails) => {\n      post('/product/' + productId + '/buy', {\n        referrer,\n        orderDetails\n      });\n    };\n  }, [productId, referrer]);\n\n  return <Form onSubmit={handleSubmit} />;\n}\n```\n\n\n\n그 솔루션은 약간 어색할 수 있을 것 같아요. 다행히 React에서는 이 상황을 고려하여 특별히 설계된 useCallback이라는 내장 후크를 제공해요. useMemo로 중첩 함수를 생성하는 대신 useCallback을 사용하여 함수를 간단히 래핑할 수 있어요. useCallback은 의존성을 추적하고 해당 의존성이 변경될 때에만 새로운 함수를 생성해요.\n\n```js\nexport default function Page({ productId, referrer }) {\n  const handleSubmit = useCallback((orderDetails) => {\n    post('/product/' + productId + '/buy', {\n      referrer,\n      orderDetails\n    });\n  }, [productId, referrer]);\n\n  return <Form onSubmit={handleSubmit} />;\n}\n```\n\n우리가 보았던 두 가지 방법(useMemo와 중첩 함수, useCallback)은 같은 결과를 얻을 수 있어요. useCallback의 유일한 장점은, useMemo 내에서 추가적인 함수가 필요하지 않아져 코드를 보다 깔끔하게 유지할 수 있다는 점이에요. 이 외에는 다른 기능은 제공하지 않아요. useCallback에 대해 더 알고 싶다면, 추가 자료를 참고해보세요.\n\n# 요약\n\n\n\n- 최상위 또는 사용자 정의 후크: useMemo은 컴포넌트의 시작 부분에서만 호출하거나 직접 만든 사용자 정의 후크 안에서만 호출할 수 있습니다. 반복문이나 조건문 내에서는 작동하지 않습니다. 그 기능이 필요하다면 계산을 위한 별도의 컴포넌트를 만들어보세요.\n- 개발 중 두 번 호출 확인 (Strict Mode): 활성화되면 React는 고의로 계산 함수를 두 번 호출하여 계산 그 자체에 잠재적 문제가 없는지(“불순물\"라고 함) 확인합니다. 이는 오직 개발 목적으로만 사용되며 프로덕션에서는 발생하지 않습니다. 계산이 순수하다면(즉, 입력에만 의존하고 부작용이 없는 경우) 코드에 영향을 주지 않습니다. 추가된 결과는 그냥 무시됩니다.\n- 스마트 캐싱: React는 필요할 때가 아니면 캐시된 값을 버리지 않습니다. 개발 시 컴포넌트 코드를 편집할 때에는 클리어될 수 있습니다. 개발 및 프로덕션 모두에서 초기 렌더링 중 컴포넌트가 보류될 때 캐시가 클리어될 수 있습니다. React는 효율을 위해 캐시를 클리어하는 미래 기능을 도입할 수도 있습니다(가상 리스트와 같은 경우). 성능 최적화를 위해 useMemo를 사용한다면 이것이 문제가 되지 않을 것입니다. 그러나 다시 렌더링 간에 캐시된 값을 의존하는 경우 다른 이유로 상태 변수나 ref를 대신 사용하는 것을 고려해보세요.\n\n만약 이 글을 좋아하셨다면 박수나 댓글 부탁드립니다. 이를 통해 포스트의 퀄리티를 향상시킬 수 있고, 여러분에 대해 더 많이 알 수 있습니다. 많이 감사합니다!\n\n아래에서 제 소셜 미디어 및 새로운 글을 구독할 수 있는 링크를 찾으실 수 있습니다. 팁은 언제나 환영합니다.\n\n```js\ntype SocialMedia = {\n  LinkedIn: string;\n  GitHub: string;\n  StackOverflow: string;\n  Litsy: string;\n  Email: string;\n  X: string;\n}\n\nfunction newSocialMedia(): SocialMedia {\n  return {\n    LinkedIn: \"https://www.linkedin.com/in/edwardcasanova/\",\n    GitHub: \"https://github.com/ed3899\",\n    StackOverflow: \"stackoverflow.com/users/11941146/edward-casanova\",\n    Litsy: \"https://www.litsy.com/web/stack/edca3899/read\",\n    Email: \"ed.wacc1995@gmail.com\",\n    X: \"https://twitter.com/edca3911\"\n  };\n}\nconst subscribe = (): string => {\n  return \"https://medium.com/@ed.wacc1995/subscribe\";\n};\nconst tip = (): string => {\n  return \"https://paypal.me/edca3899?country.x=MX&locale.x=es_XC\";\n};\n```","ogImage":{"url":"/assets/img/2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12_0.png","tag":["Tech"],"readingTime":11},{"title":"리액트에서의 인증과 권한 부여 방법","description":"","date":"2024-05-12 20:14","slug":"2024-05-12-AuthenticationandAuthorizationinreact","content":"\n우리는 이 튜토리얼에서 React 앱에 대한 인증 및 권한 부여 기능을 활용할 것입니다. 시작해 봅시다...\n\n인증이란 무엇인가요?\n\n인증은 제공된 자격 증명을 사용하여 사용자의 신원을 확인하는 과정입니다. 사용자가 정당한지 확인하는 것이 일반적입니다.\n\n권한이란 무엇인가요?\n\n인증은 사용자 클라이언트의 권한이나 액세스 수준을 결정하는 보안 절차입니다. 인증된 사용자가 작업을 수행할 수 있는 권한 또는 액세스 여부를 확인하는 것은 표준 절차입니다.\n\n파일과 폴더를 정리해 봅시다.\n\nsrc 하위에 components 폴더를 만듭니다.\n그런 다음 다음 파일을 만듭니다: Unauthorized.js, Navbar.js, Profile.js, Extra.js, Home.js, About.js, Extra.js.\n\n![이미지](/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_0.png)\n\n리액트 라우터 패키지를 사용할 것이기 때문에 다음 명령어를 사용하여 설치해 보겠습니다.\n\nNPM을 사용하는 경우\n\n```js\nnpm install react-router-dom@6\n```\n\nYarn을 사용하는 경우\n\n```js\nyarn add react-router-dom@6\n```\n\n새로운 폴더를 만들어서 routes라고 이름 짓기로 하자.\n\n다음 파일을 만들어보세요: Authentication.js, Authorization.js, 그리고 RoutePath.js.\n\n<img src=\"/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_1.png\" />\n```\n\npermissions와 provider라는 이름의 두 개의 추가 폴더를 만들어 주세요. permissions 폴더 안에 permissions.js 파일을, provider 폴더 안에는 authprovider.js 파일을 만들어 주세요.\n\n우린 이제 폴더 구조를 마칩니다.\n\n![Authentication and Authorization in react](/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_2.png)\n\n인증 및 권한 부여가 어떻게 구현되는지 이해하는 것이 우리의 유일한 목표이기 때문에 복잡한 코드나 디자인에 신경쓰지 않을 거에요.\n\n지금 파일을 수정하기 시작하세요!!!\n\nPermissions.js\n\n```js\nconst PERMISSIONS = {\n  CAN_VIEW_ABOUT: \"view_about\",\n  CAN_VIEW_EXTRA: \"view_extra\",\n};\nexport default PERMISSIONS;\n```\n\n일부 데이터에 무단으로 접근을 막기 위해 권한을 만들었습니다.\n\nAuthProvider.js\n\n```js\nimport React, { createContext, useContext, useState } from \"react\";\nimport { useNavigate, useLocation } from \"react-router-dom\";\nconst AuthContext = createContext(null);\nexport const AuthProvider = ({ children }) => {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const redirectPath = location.state?.path || \"/profile\";\n  const [user, setUser] = useState({\n    username: \"\",\n    permissions: [],\n  });\n  const login = (user) => {\n    if (user === \"admin\") {\n      setUser({ username: user, permissions: [\"view_extra\"] });\n    } else {\n      setUser({ username: user, permissions: [\"view_about\"] });\n    }\n    navigate(redirectPath, { replace: true });\n  };\n  const logout = () => {\n    setUser({ username: \"\", permissions: [] });\n  };\n  return <AuthContext.Provider value={(user, login, logout)}>{children}</AuthContext.Provider>;\n};\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n```\n\n현재 로그인한 사용자와 부여된 권한을 저장하기 위해 사용자라는 상태 변수 객체를 만들었습니다.\n\nlogin() 함수는 사용자 매개변수를 받습니다. 사용자가 관리자이면 할당된 권한은 view_extra가 되고, 그렇지 않으면 view_about이 됩니다. 사용자 이름은 사용자와 동일합니다. 그 후, 페이지를 보려고 시도한 경로 또는 프로필 페이지로 이동합니다.\n\n사용자 변수는 logout()에 의해 클리어됩니다.\n\n우리는 context를 구축하고 user, login, logout 값을 provider를 통해 props로 전달했습니다. 앱 전체에서 어디서든 이를 액세스할 수 있습니다.\n\nAuthentication.js\n\n```js\nimport React from \"react\";\nimport { useAuth } from \"../provider/AuthProvider\";\nimport { Navigate, useLocation } from \"react-router-dom\";\n\nconst Authentication = ({ children }) => {\n  const { user } = useAuth();\n  const location = useLocation();\n\n  if (!user.username) {\n    return <Navigate to=\"/login\" state={{ path: location.pathname }} />;\n  }\n\n  return children;\n};\n\nexport default Authentication;\n```\n\nuseAuth()를 통해 사용자 객체에 액세스할 수 있었습니다. username 속성이 없다면 로그인되지 않은 상태로 간주되어 로그인 페이지로 이동합니다. 그 외의 경우에는 요청한 페이지가 표시됩니다.\n\nAuthorization.js\n\n```js\nimport React from \"react\";\nimport { Navigate, useLocation, Outlet } from \"react-router-dom\";\nimport Unauthorized from \"../components/Unauthorized\";\nimport { useAuth } from \"../provider/AuthProvider\";\nconst Authorization = ({ permissions }) => {\n    const { user } = useAuth();\n    const location = useLocation();\n    if (user.username) {\n        const userpermission = user.permissions;\n        const isAllowed = permissions.some((allowed) => userpermission.includes(allowed));\n        return isAllowed ? <Outlet /> : <Unauthorized />;\n    }\n    return <Navigate to=\"/login\" state={ path: location.pathname } replace />;\n};\nexport default Authorization;\n```\n\n코드를 조각 단위로 해석해 보겠습니다.\n\n당신이 사용자 이름에 따라 권한이 설정되어 있는 것을 염두에 두셨나요? 현재 로그인한 사용자를 통해 해당 권한에 액세스할 수 있게 됐습니다.\n\n권한 획득은 사용자가 로그인했는지에 따라 달라집니다. 현재 로그인한 사용자가 부모 구성 요소를 통해 권한이 부여되었는지 확인하고 싶습니다. 사용자가 권한이 부여된 경우 컴포넌트는 `Outlet/` (하위 라우트)를 렌더링하고, 그렇지 않은 경우 권한이없다는 컴포넌트를 반환합니다.\n\n사용자가 이미 로그인되어 있지 않은 경우 로그인 페이지가 표시됩니다.\n\nRoutepath.js에서\n\n```js\n<Route element={<Authorization permissions={[PERMISSIONS.CAN_VIEW_ABOUT]} />}>\n  <Route path=\"about\" element={<About />} />\n</Route>\n```\n\nAuthorization 컴포넌트를 Route의 element로 전달하여 권한이 포함된 CAN_VIEW_ABOUT을 가진 사용자가 about 페이지를 방문할 수 있습니다.\n\nAuthorization.js에서\n\n```js\nconst Authorization = ({ permissions }) => {};\n```\n\nRoutePath Component에 의해 권한 prop이 전달되었으며 이 경우 부모이다. 따라서 우리는 이제 해당 prop에 액세스할 수 있습니다.\n\n```js\nconst { user } = useAuth();\n```\n\nuseAuth()를 통해 현재 사용자에 액세스할 수 있습니다.\n\n```js\nif (user.username) {\n  const userpermission = user.permissions;\n  const isAllowed = permissions.some((allowed) => userpermission.includes(allowed));\n  return isAllowed ? <Outlet /> : <Unauthorized />;\n}\nreturn <Navigate to=\"/login\" state={{ path: location.pathname }} replace />;\n```\n\n사용자가 로그인한 경우에는 사용자 이름과 권한 속성에 액세스할 수 있습니다. 우리는 부여한 권한이 로그인한 사용자의 권한을 포함하는지 여부를 결정해야 합니다.\n\n```js\nconst isAllowed = permissions.some((allowed) => userpermission.includes(allowed));\n```\n\n사용자에게 권한이 있는 경우 (Children Route)이 렌더링되고, 그렇지 않으면 Unauthorized 컴포넌트가 반환됩니다.\n사용자가 이미 로그인하지 않은 경우 로그인 페이지가 표시됩니다.\n\nAbout.js\n\n```js\nimport React from “react\";\nconst About = () => {\n  return <div>About Page</div>;\n};\nexport default About;\n```\n\nExtra.js\n\n```js\nimport React from \"react\";\nconst Extra = () => {\n  return <div>Extra Page</div>;\n};\nexport default Extra;\n```\n\nHome.js\n\n```\n\n\n\n```js\nimport React from \"react\";\nconst Home = () => {\n    return <div>홈 페이지</div>;\n};\nexport default Home;\n```\n\nLogin.js\n\n```js\nimport React, { useState } from \"react\";\nimport { useAuth } from \"../provider/AuthProvider\";\nconst Login = () => {\n  const [user, setUser] = useState(null);\n  const { login } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const redirectPath = location.state?.path || \"\";\n  const handleLogin = () => {\n    login(user);\n  };\n  return (\n    <>\n      <h1>로그인 페이지</h1>\n      <label>이름</label>\n      <input type=\"text\" onChange={(e) => setUser(e.target.value)} />\n      <button type=\"submit\" onClick={handleLogin}>\n        로그인\n      </button>\n    </>\n  );\n};\nexport default Login;\n```\n\n우리는 사용자 상태 변수를 생성하고 입력 필드를 추가했습니다. 입력란에 입력된 데이터는 사용자를 위해 보관되며 로그인할 때 전달됩니다.\n\n```\n\n\n\nNavbar.js\n\n```js\nimport React from \"react\";\nimport { NavLink } from \"react-router-dom\";\nimport { useAuth } from \"../provider/AuthProvider\";\nexport const Navbar = () => {\n    const { user } = useAuth();\n    return (\n        <nav>\n            <NavLink to=\"/\">홈</NavLink>\n            <NavLink to=\"/about\">소개</NavLink>\n            {user.username && <NavLink to=\"/profile\">프로필</NavLink>}\n            {!user.username && <NavLink to=\"/login\">로그인</NavLink>}\n            <NavLink to=\"/extra\">추가</NavLink>\n        </nav>\n    );\n};\n```\n\n서로 다른 경로 간 이동이 간단해지도록 navbar를 추가했습니다. 프로필 링크는 로그인한 사용자를 위해 제공되지만, 아직 인증을 받지 않은 사용자에게는 로그인 링크가 표시됩니다.\n\n<img src=\"/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_3.png\" />\n\n```md\n![Authentication and Authorization in React](/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_4.png)\n\nProfile.js\n\n```js\nimport React from \"react\";\nimport { useAuth } from \"../provider/AuthProvider\";\n\nconst Profile = () => {\n  const { user, logout } = useAuth();\n\n  const logoutHandler = () => {\n    logout();\n  };\n\n  return (\n    <>\n      <h1>Welcome {user.username}</h1>\n      <button type=\"submit\" onClick={logoutHandler}>\n        Logout\n      </button>\n    </>\n  );\n};\n\nexport default Profile;\n```\n```\n\nWe used useAuth() to access user and logout(). We added a logout button to handle logout operations and displayed the username of the user who is presently logged in.\n\n```\n\n\n\nUnauthorized.js\n\n```js\nimport React from \"react\";\nconst Unauthorized = () => {\n return <div>이 페이지를 보기 위한 권한이 없습니다</div>;\n};\nexport default Unauthorized;\n```\n\nRoutePath.js\n\n```js\nimport React from \"react\";\nimport { Routes, Route } from \"react-router-dom\";\nimport Home from \"../components/Home\";\nimport About from \"../components/About\";\nimport Login from \"../components/Login\";\nimport Profile from \"../components/Profile\";\nimport Authentication from \"./Authentication\";\nimport Authorization from \"./Authorization\";\nimport PERMISSIONS from \"../permissions/Permissions\";\nimport Extra from \"../components/Extra\";\nconst RoutePath = () => {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Home />} />\n      <Route element={<Authorization permissions={[PERMISSIONS.CAN_VIEW_ABOUT]} />}>\n        <Route path=\"about\" element={<About />} />\n      </Route>\n      <Route\n        path=\"profile\"\n        element={\n          <Authentication>\n            <Profile />\n          </Authentication>\n        }\n      />\n      <Route element={<Authorization permissions={[PERMISSIONS.CAN_VIEW_EXTRA]} />}>\n        <Route path=\"extra\" element={<Extra />} />\n      </Route>\n      <Route path=\"login\" element={<Login />} />\n    </Routes>\n  );\n};\nexport default RoutePath;\n```\n\n`Routes` 구성 요소에서 루트를 캡슐화했습니다.\n\n```js\n<Route\n  path=\"profile\"\n  element={\n    <Authentication>\n      <Profile />\n    </Authentication>\n  }\n/>\n```\n\n접근하기 전에 인증이 필요하기 때문에 `Authentication` 구성 요소로 루트를 래핑했습니다.\n\n```js\n<Route element={<Authorization permissions={[PERMISSIONS.CAN_VIEW_EXTRA]} />}>\n  <Route path=\"extra\" element={<Extra />} />\n</Route>\n```\n\n또한 인가가 필요한 루트에 대해 인가를 요소로 전달했는데, 이 인가는 권한을 가진 자식 루트들을 감싸는 역할을 했어요. 이 경우 관리자 권한을 가진 사용자만 `Extra /` 컴포넌트를 볼 수 있어요.\n\n아래는 최종 결과물입니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*8u590rCf0gvThvAdNOAqoQ.gif)\n\n그래서, 새로운 것을 배웠나요? 마음대로 바꾸고 실험해보세요. 즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_0.png"},"coverImage":"/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_0.png","tag":["Tech"],"readingTime":10},{"title":"Vite React에서 프록시 설정하기","description":"","date":"2024-05-12 20:13","slug":"2024-05-12-SetupProxyinViteReact","content":"\n\nVite React 애플리케이션에서는 다음이 제게 가장 잘 작동하는 방법입니다:\n\nvite.config.js 파일에서 proxy 옵션을 사용할 수 있습니다. proxy 옵션을 사용하면 개발 중에 특정 요청을 다른 서버로 리디렉션할 수 있습니다. 이는 예를 들어 프런트엔드 애플리케이션이 별도 서버에서 실행되는 백엔드 API와 통신해야 할 때 유용합니다.\n\nvite.config.js 파일 안에 proxy 옵션을 정의하세요:\n\n```js\n/// <reference types=\"vite/client\" />\n\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n      proxy: {\n        '/api': {\n          target: 'http://your-backend-api-server.com',\n          changeOrigin: true,\n          rewrite: (path) => path.replace(/^\\/api/, ''),\n        },\n      },\n    },\n});\n```\n\n\n\n이 예제에서는 /api로 시작하는 요청에 대한 프록시를 설정하고 있습니다. 이 패턴과 일치하는 모든 요청은 http://your-backend-api-server.com 으로 리디렉션됩니다.\n\n환경 변수에서 API URL을 가져오고 싶다면 다음과 같이 작성할 수 있습니다.\n\n```js\n/// <reference types=\"vite/client\" />\n\nimport { defineConfig, loadEnv } from 'vite';\nimport react from '@vitejs/plugin-react';\n\n// https://vitejs.dev/config/\nexport default ({ mode }) => {\n  process.env = { ...process.env, ...loadEnv(mode, process.cwd()) };\n  const config = {\n    plugins: [react()],\n    server: {\n      proxy: {\n        '/api': {\n          target: process.env.VITE_BASE_URL,\n          changeOrigin: true,\n          rewrite: (path) => path.replace(/^\\/api/, ''),\n        },\n      },\n    },\n  };\n  return defineConfig(config);\n};\n```\n\n여기서 VITE_BASE_URL이 API URL입니다.\n\n\n\n이 포스트가 마음에 드셨다면 아래의 하트를 클릭해주세요 :).","ogImage":{"url":"/assets/img/2024-05-12-SetupProxyinViteReact_0.png"},"coverImage":"/assets/img/2024-05-12-SetupProxyinViteReact_0.png","tag":["Tech"],"readingTime":2},{"title":"바퀴 다시 발명하기 - 목록 사용","description":"","date":"2024-05-12 20:09","slug":"2024-05-12-Re-inventingthewheelUselist","content":"\n\n이번 시리즈에서는 바퀴를 새롭게 발명해 보려 합니다. 맞아요, 사람들이 네게 하지 말라고 말했던 것을 정확히 하려고 하지만, 우리는 반항자들이야 😉.\n\n프로젝트 틀을 만들기 위해 단순한 pnpm monorepos를 만들었지만, 여러분은 자유롭게 설정을 사용할 수 있어요. 중요한 건 완벽하게 작동하는 리액트 프로젝트를 갖고 있다는 것이에요. 이 시리즈는 그것에 대해 이야기하는 것이 아니지만, 관심이 있다면 나와 같은 가이드를 따라 갈 수 있어요: https://dev.to/vinomanick/create-a-monorepo-using-pnpm-workspace-1ebn\n\n하지만 내 설정을 꼭 따르고 싶다면, 여기서 레포를 클론할 수 있어요: https://github.com/FrancoRATOVOSON/use-wheel\n\n# 소개\n\n\n\nReact 생태계의 방대한 풍경 가운데, 우리는 개발 업무를 간소화해 주겠다고 약속하는 다양한 라이브러리와 프레임워크로 여유롭게 나눠먹는다. 그러나 프로젝트가 복잡해지면서 우리는 종종 우리의 요구 사항을 초과하는 부품과 복잡한 시스템과 씨름해야 할 때가 많습니다.\n\n이러한 딜레마는 최근 사이드 프로젝트에 착수할 때 익숙한 일 중 하나였습니다. 여러 도구와 라이브러리를 만지작거리면서, 많은 요구 사항이 더 단순하고 집중된 해결책으로 충족될 수 있다는 것을 깨달았습니다. 그래서 이 시리즈 아이디어가 탄생했습니다 — 불필요한 것을 벗어내고 단숨함의 우아함을 받아들이는 기본으로 되돌아가는 여정입니다.\n\n그러나 이것은 그냥 대충 다시 만드는 것에 대한 이야기만이 아닙니다. 이것은 창조의 기쁨을 되찾고 체험을 통해 학습함으로써 배우는 것에 대한 새로운 가능성을 발견하는 것입니다. 복잡한 개념을 기본 구성 요소로 분해함으로써, 우리는 어떻게 일이 진행되는지에 대한 깊은 이해를 얻고 혁신을 위한 새로운 가능성을 발견할 수 있습니다.\n\n# 오늘 우리는 뭐 요리해볼까요?\n\n\n\n그러면 함께 이 여정을 시작해보죠. 리스트는 널리 사용되는 만큼 필수적인 요소이죠. 사용자를 표시하거나 제품을 전시하는 등 무수히 많은 응용 프로그램의 기초를 이룹니다. 이미 사용 중인 솔루션들인 useList와 @tastack/table(테이블과 더 관련이 있다는 건 알지만) 같은 솔루션들은 매력적인 기능을 제공하지만, 우리의 요구에 정확히 맞춘 것을 만들 수 있다면 어떨까요?\n\nReact에서 리스트 관리의 기술을 탐구하며, 가벼우면서 다목적으로 사용할 수 있는 효용성 있는 도구를 만들어보겠습니다. 이 시리즈가 끝날 때쯤, 단순함의 힘에 대한 새로운 인식과 개발 워크플로우를 향상시킬 실용적인 도구가 생길 것입니다.\n\n이 여정의 끝에 우리가 생산할 결과는 다음과 같습니다:\n\n# 요구 사항\n\n\n\n그래, 시작해봅시다! 우리의 야생 목록을 다룰 때 필수적인 기능들에 대한 체크리스트가 있어요:\n\n- 정렬 (Sorting): 지저분한 데이터 스택에서 탐색해 본 적이 있나요? 시간이 없어요! 목록을 정렬하고 혼돈을 조금이나마 정리할 방법이 필요해요.\n- 필터링 (Filtering): 정보 과부하와 이별을 외치죠! 불필요한 소음을 걸러내고 진정으로 중요한 것에 집중하고 싶어요.\n- 표시 (Pagination & Page Size): 끝없는 결과 페이지를 넘기며 보기? 그럴 필요 없어요! 소형 청크로 나누어 탐색을 쉽게 만들어 주세요.\n- 선택 (Selection): 때로는 선택해야 할 때가 있어요! 여러 항목을 선택하거나 특별 데이터에 집중해야 할 때, 일을 처리할 도구가 필요해요.\n\n이제 우리의 희망 목록이 완성되었으니, 옷 소매를 걷어 올리고 일하러 가봐요. 우리 신뢰할 수 있는 \"useList\" 유틸리티의 탄생이랍니다!\n\n```js\n// useList.ts\n\nexport function useList<T>(data: Array<T>) {\n  return {\n    list: data\n      .filter(() => true) // 필터링 로직을 위한 자리 표시자\n      .sort(() => 0)      // 정렬 로직을 위한 자리 표시자\n      .slice()            // 페이징 로직을 위한 자리 표시자\n  }\n}\n```\n\n\n\n여기서 우리가 보고 있는 것은 무엇일까요? 우리는 데이터 배열을 가져와서 \"list\" 속성을 포함하는 깔끔한 패키지를 반환하는 일반적인 함수를 만들었습니다. 이 속성은 우리의 원본 데이터 배열의 필터링, 정렬 및 잘린 버전을 보유하고 있습니다.\n\n하지만 기다려봐, 아직 끝난 게 아니에요! 당연히 기본 기능이 준비되었지만, 이제 진짜 로직을 뿌려야 할 때입니다. 우리는 정렬, 필터링, 페이지네이션 및 선택을 다루고 있어요. 그러니 생각의 모자를 쓰고, 이에 조금의 코딩 마법을 뿌려봐요. 이것은 상당히 흥미진진한 여정이 될 거에요! 🎩✨\n\n일단 쉬운 것부터 시작해봅시다.\n\n## 선택하기\n\n\n\n알겠어요, 친구들, 선택에 관한 이야기를 해볼 시간이에요! 우리 목록에서 항목을 선택할 때 몇 가지 옵션이 있어요:\n\n- 사용자 지정 고유 ID: 한 가지 옵션은 사용자에게 고유 ID를 각 요소에 제공하도록 요청하는 것이에요. 이렇게 하면 사용자가 선택을 식별하는 방법을 완전히 제어할 수 있어요.\n- 유연한 선택 메커니즘: 또 다른 방법은 사용자가 선택 프로세스가 작동하는 방식을 결정하도록 하는 것이에요. 그러면 사용자가 자신의 특정 요구 사항과 선호도에 맞게 조정할 수 있어요.\n\n하지만 또 다른 옵션이 있어요, 선택 메커니즘을 우리가 맡지만 사용자들이 각 요소를 식별하는 방법을 선택할 수 있게 할 거예요. 어떻게요? 바로 이런 멋진 작은 함수를 제공해서:\n\n```js\ntype UseListOptions<T, U> = {\n  getId: (element: T) => U\n}\n```\n\n\n\n이렇게 하면 사용자가 요소를 식별하는 자체 방법을 지정할 수 있어요. 제공된 데이터에 이미 고유한 ID가 있는 경우 훌륭해요! 그렇지 않은 경우, 함수를 사용자 정의하여 ID를 생성할 수 있어요.\n\n이제 구현에 대해 자세히 알아볼까요? 수행해야 할 일은 선택 목록과 선택을 켜고 끄는 함수를 추가하는 것 뿐이에요:\n\n```js\nexport function useList<T, U>(data: Array<T>, { getId }: UseListOptions<T, U>) {\n  const [selection, setSelection] = React.useState<Set<U>>(new Set([]))\n\n  const toogleSelection = React.useCallback(\n    (item: T, state?: boolean) =>\n      setSelection(currentSelection => {\n        const itemId = getId(item)\n        const selectionList = new Set(currentSelection)\n        if (state || !selectionList.has(itemId)) selectionList.add(itemId)\n        else selectionList.delete(itemId)\n        return new Set(selectionList)\n      }),\n    [getId]\n  )\n\n  return {\n    list: data\n      .filter(() => true)\n      .sort(() => 0)\n      .slice(),\n    selection,\n    toogleSelection\n  }\n}\n```\n\n뭔가 빠뜨린 게 있나요? 음, 네, 제공하지 않을 수 없는 기능을 잊었네요:\n\n\n\n```js\nconst toogleSelectionAll = React.useCallback(\n  (state?: boolean) =>\n    setSelection(currentSelection => {\n      if (state || currentSelection.size === 0)\n        return new Set(data.map(item => getId(item)))\n      const selectionList = new Set(currentSelection)\n      selectionList.clear()\n      return selectionList\n    }),\n  [data, getId]\n)\n```\n\n그리고 이로서 모든 것을 마쳤습니다. 그 다음 계획은 무엇인가요?\n\n## 정렬 및 필터링\n\n좋아요, 여러분, 이제 정렬과 필터링을 다루는 시간입니다! 그리고 놀랍게도 선택보다 더 쉽습니다. 사용자는 함수를 제공하고, 우리는 그저 마법을 부릅니다.\n\n\n\n위 코드를 업데이트해 봅시다:\n\n```js\ntype UseListOptions<T, U> = {\n  filterFn: (element: T) => boolean\n  getId: (element: T) => U\n  sortFn: (elementA: T, elementB: T) => number\n}\n\nexport function useList<T, U>(\n  data: Array<T>,\n  { filterFn, getId, sortFn }: UseListOptions<T, U>\n) {\n\n  ...\n\n  return {\n    list: data.filter(filterFn).sort(sortFn).slice(),\n    selection,\n    toggleSelection\n  }\n}\n```\n\n이제 궁금증이 생길 수 있어요. \"필터링과 정렬 순서는 중요할까요?\" 그 대답은 네요 — 주로 성능상의 이유로 중요합니다. 정렬이 시작되기 전에 배열 크기를 줄이기 위해 데이터를 먼저 필터링합니다. 그러나 slice 작업은 마지막에 옵니다. 페이지네이션을 위한 것이거든요. 우리는 표시된 항목을 기준으로 정렬 및 필터링 매개변수가 변경되더라도 일관성을 유지하기 위해 전체 데이터 집합에서 필터링 및 정렬합니다.\n\n하지만 여기서 멈추지 않겠어요! 나중에 우리는 최적화와 코드 청결성에 대해 더 탐구할 거에요.\n\n\n\n이러한 조정 사항을 고려하면 정렬 및 필터링 기능이 빛을 발할 준비가 되었어요! React에서 목록 관리의 멋진 세계로 더 깊이 파고들어가는 것을 기대해 주세요.\n\n## 페이지네이션\n\n자, 이제 파티 시작할 시간이에요 😎.\n\n페이지네이션은 간단해 보일 수 있지만, 믿어두세요, 눈에 보이는 것 이상의 것이 있어요. 먼저, 현재 위치(현재 페이지, 말하자면)를 추적하고 한 번에 표시할 항목 수(페이지 크기)를 파악하며 페이지 간에 전환할 수 있는 편리한 기능이 몇 가지 필요해요 (첫 번째, 이전, 다음, 마지막, 그리고 심지어 이동하기까지!).\n\n\n\n시작해봐요:\n\n```js\n유형 UseListOptions <T, U> = {\n  defaultPageSize: 숫자\n  ...\n}\n\nexport function useList <T, U> (\n  데이터 : 배열 <T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions <T, U>\n) {\n  const [pageSize, setPageSize] = React.useState <number> (defaultPageSize)\n  const [index, setIndex] = React.useState <number> (0)\n\n  ...\n\n  return {\n    list : 데이터\n      .filter (filterFn)\n      .sort (sortFn)\n      .slice (index, index + pageSize),\n    ...\n  }\n}\n```\n\n참 간단하죠? 이제 현재 페이지를 결정하는 문제부터 해결해 봅시다:\n\n```js\nexport function useList <T, U> (\n  데이터 : 배열 <T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions <T, U>\n) {\n  ...\n\n  const currentPage = React.useMemo (\n    () => index / pageSize + 1,\n    [index, pageSize]\n  )\n\n  return {\n    ...\n    currentPage,\n  }\n}\n```\n\n\n\n이건 꽤 쉬운데요, 현재 페이지는 현재 인덱스를 페이지 크기로 나눈 값에 1을 더하면 됩니다. 왜냐하면 페이지는 1부터 시작하기 때문이에요. 그런데 이 말은 인덱스가 항상 페이지 크기의 배수여야 한다는 가정을 하고 있죠. 그러나 이는 합리적입니다. 페이지를 변경할 때마다 인덱스에 페이지 크기를 더해주기 때문이에요.\n\n이제 페이지 간에 부드러운 탐색을 보장합시다:\n\n```js\nconst nextPage = React.useCallback(() => {\n  if (pageSize < data.length && index + pageSize < data.length)\n    setIndex(currentIndex => currentIndex + pageSize)\n}, [data.length, index, pageSize])\n```\n\n먼저, 아직 보여줄 데이터가 남아 있는 경우에만 nextPage로 이동할 수 있도록 합시다. 이를 위해 페이지 크기는 데이터의 길이보다 작아야 하고, 인덱스를 증가시켰을 때 그 값이 데이터 배열 내에 여전히 존재해야 합니다. 이런 논리를 따라가면, 인덱스는 항상 페이지 크기의 배수일 것이라는 것을 알 수 있습니다. 왜냐하면 0, 페이지 크기, 페이지 크기 + 페이지 크기, ... 와 같이 될 수 있거든. 그런데 만약 갑자기 페이지 크기를 변경한다면 어떻게 될까요? 우리가 첫 번째 페이지에 있는 동안에는 별 상관이 없겠지만, 리스트의 어딘가에 있는데 첫 페이지가 아닌 경우에는 현재 페이지와 표시해야 하는 내용을 다시 계산해야 할 것입니다.\n\n\n\n음 네, 먼저 네비게이션을 완성하고 나중에 여기로 돌아올까요?\n그래서, 이전, 첫 번째 그리고 마지막 페이지:\n\n```js\nconst previousPage = React.useCallback(() => {\n  if (pageSize < data.length && index - pageSize >= 0)\n    setIndex(currentIndex => currentIndex - pageSize)\n}, [data.length, index, pageSize])\n\nconst firstPage = React.useCallback(() => setIndex(0), [])\n\nconst lastPage = React.useCallback(() => {\n  if (pageSize < data.length && index + pageSize < data.length) {\n    const pageCount = Math.ceil(data.length / pageSize)\n    setIndex(pageSize * pageCount)\n  }\n}, [data.length, index, pageSize])\n```\n\n알아채셨나요? 우리는 또 다른 중요한 정보인 pageCount를 만들었어요. 우리도 그것을 반환해야겠네요.\n\n코드를 변경해봅시다:\n\n\n\n```js\nconst pageCount = React.useMemo(() => {\n  if (pageSize >= data.length) return 1\n  return Math.ceil(data.length / pageSize)\n}, [data.length, pageSize])\n\n...\n\nconst lastPage = React.useCallback(() => {\n  if (pageSize < data.length && index + pageSize < data.length)\n    setIndex(pageSize * (pageCount - 1))\n}, [data.length, index, pageCount, pageSize])\r\n```\n\n이제 setPageSize 구현 전에 보너스 기능을 추가해 봅시다:\n\n```js\nconst goToPage = React.useCallback(\n  (destinationPage: number) => {\n    if (destinationPage < pageCount)\n      setIndex(pageSize * (destinationPage - 1))\n  },\n  [pageCount, pageSize]\n)\n```\n\n보시다시피 lastPage와 거의 비슷합니다. 나중에 정리하도록 하겠습니다.\n\n\n\n## 페이지 크기 설정\n\n여기서 재미있는 부분이 나왔네요! 사용자가 페이지 크기를 변경하기로 결정하는 것은 보통 한 번에 더 많은 정보를 보고 싶어서입니다. 그러나 이미 여러 페이지를 탐색 중이라면, 현재 페이지 유지와 더 많은 요소 표시 중 어느 것에 우선순위를 두어야 할까요? 우리에게 완전히 달려 있지만, 사용자의 관점에서는 뷰 크기를 변경했기 때문에 이전에 발견한 정보를 잃는 것이 이상적이지 않습니다. 게다가, 현재 어떤 페이지에 있는지에 대해서는 관심조차 없을 수도 있습니다.\n\n현재 표시된 정보는 현재 인덱스와 현재 페이지 크기 사이에 있습니다. 따라서 사용자가 페이지 크기를 업데이트하면, 현재 인덱스를 조정하여 그 값에 페이지 크기를 추가하면 마지막 인덱스가 포함되도록 해야 합니다.\n\n그것을 하는 가장 쉬운 방법은 다음과 같습니다:\n\n\n\n```js\nconst setPageSize = React.useCallback(\n  (size: number) => {\n    setPageSizeState(size);\n    const newIndex = Math.floor(index / size) * size;\n    setIndex(newIndex);\n  },\n  [index]\n);\n```\n\n아시다시피, 이것은 내가 만들기 별로 어렵지 않아 보이는 것보다 더 쉬운 것 같아요 😛. 해결책의 단순함이 해결해야 할 문제의 복잡함을 숨기는 것이 아니기 때문이에요. 이제 코드를 설명해 볼게요:\n먼저, 페이지 크기를 새 페이지 크기로 설정해요. 간단하죠? 그런데 이제 어려운 부분이 나와요: 왜 Math.floor를 사용하는 걸까요? 그리고 여기서 정확히 무엇을 계산하고 있을까요?\n\n다음을 고려해 보세요: 표시된 어떤 요소든 index와 index + pageSize 사이에 위치해 있어요. 다시 말해:\n\n- 페이지 1의 요소는 0부터 pageSize 사이에 위치해요\n- 페이지 2의 요소는 pageSize부터 pageSize * 2 사이에 위치해요\n- 페이지 3의 요소는 pageSize * 2부터 pageSize * 3 사이에 위치해요\n- 계속해서 이어지죠...\n\n\n\n일반적으로, 페이지 n의 요소는 (pageSize * (n-1))과 (pageSize * n) 사이에 있습니다. 이 계산을 역으로 바꾸면, n이 항상 (i / pageSize) + 1 이하임을 알 수 있습니다. 하지만 왜 \"이상\"이 아닌 걸까요? 이 계산이 수학적으로 맞을 수 있지만, 중요한 점은 i가 0에서 시작하는 반면 페이지 인덱스는 1에서 시작한다는 것을 기억하는 것입니다. 현재 인덱스는 현재 페이지에 페이지 크기를 곱한 값이기 때문에 결과를 곱해서 올바른 인덱스를 찾습니다.\n\n휴! 수학적인 여정이 꽤 길었지만, 이러한 세세한 점을 이해하면 사용자가 어떻게 상호 작용하든 페이징 시스템이 원활하게 작동하도록 할 수 있습니다.\n\n# 테스트\n\n## 설정하기\n\n\n\n우리의 페이지네이션 시스템을 만들었으니, 이제 시험해보는 시간이에요! 사용자 주문 목록을 만들고, 날짜나 금액으로 정렬하거나, 이메일로 필터링하며, 주문 상태를 변경(배송됨 또는 아직 안됨)하는 기능 등을 탐험해볼 거에요. 데이터를 채우기 위해, 현실적인 테스트 데이터를 생성하는 유용한 도구인 faker.js를 사용할 거예요.\n\n먼저, 데이터를 생성하는 방법을 보겠어요:\n\n```js\n// 저는 생성한 사용자 목록을 가지고 있는 사용자 목록을 만들었어요.\n// 각 주문이 개별 사용자에 속하지 않도록 하기 위해, 이것은 검색 필터 기능을 위한 것이에요.\nfunction fakeUserList() {\n  const list: string[] = []\n  for (let index = 0; index < 10; index++) {\n    list.push(faker.internet.email())\n  }\n  return list\n}\n\nexport function fakeOrdersList() {\n  const userList = fakeUserList()\n  const list: Order[] = []\n  const dataSize = faker.number.int({ max: 100, min: 50 })\n  for (let index = 0; index < dataSize; index++) {\n    list.push({\n      amount: faker.number.int({ max: 500, min: 150 }),\n      date: faker.date.recent({ days: 100 }),\n      id: faker.string.uuid(),\n      isDelivered: faker.number.int({ max: 10, min: 0 }) % 2 === 0,\n      user: userList[faker.number.int({ max: userList.length - 1, min: 0 })]\n    })\n  }\n\n  return list\n}\n```\n\n이제, 부모 컴포넌트를 설정해봅시다:\n\n\n\n```js\nimport React from 'react'\n\nimport { OrderList } from '@/components/common'\nimport { fakeOrdersList } from '@/lib/faker'\n\nexport default function OrdersPage() {\n  const [orders, setOrders] = React.useState(fakeOrdersList())\n\n  const deleteOrders = React.useCallback(\n    (ids: string[]) =>\n      setOrders(list => list.filter(element => !ids.includes(element.id))),\n    []\n  )\n\n  return <OrderList deleteOrders={deleteOrders} list={orders} />\n}\n```\n\n그리고 리스트 컴포넌트 :\n\n```js\n// import문 생략...\n\ninterface OrderListProps {\n  deleteOrders: (ids: string[]) => void\n  list: Array<Order>\n}\n\nexport default function OderList({ deleteOrders, list: data }: OrderListProps) {\n  const [search, setSearch] = React.useState<string>('')\n  const [sort, setSort] = React.useState<'asc' | 'desc' | null>(null)\n  const {\n    currentPage,\n    firstPage,\n    lastPage,\n    list,\n    nextPage,\n    pageCount,\n    pageSize,\n    previousPage,\n    selection,\n    setPageSize,\n    toogleSelection,\n    toogleSelectionAll\n  } = useList(data, {\n    defaultPageSize: 5,\n    filterFn: order => {\n      if (search) return order.user.toLowerCase().includes(search.toLowerCase())\n      return true\n    },\n    getId: elt => elt.id,\n    sortFn: (a, b) => {\n      if (!sort) return 0\n      if (sort === 'asc') return a.amount - b.amount\n      return b.amount - a.amount\n    }\n  })\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between gap-2 items-center\">\n        <div className=\"flex justify-start items-center gap-2\">\n          <div className=\"relative ml-auto flex-1 md:grow-0\">\n            <Search className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n            <Input\n              className=\"w-full rounded-lg bg-background pl-9 md:w-[200px] lg:w-[336px]\"\n              placeholder=\"검색...\"\n              type=\"search\"\n              onChange={e => setSearch(e.target.value)}\n            />\n          </div>\n          <div>\n            <DropdownMenu>\n              <DropdownMenuTrigger asChild>\n                <Button variant=\"outline\">\n                  {sort === 'asc' ? (\n                    <>\n                      <ArrowUpNarrowWide className=\"size-4 mr-4\" />\n                      오름차순\n                    </>\n                  ) : sort === 'desc' ? (\n                    <>\n                      <ArrowDownNarrowWide className=\"size-4 mr-4\" />\n                      내림차순\n                    </>\n                  ) : (\n                    <>\n                      <ArrowUpDown className=\"size-4 mr-4\" />\n                      정렬\n                    </>\n                  )}\n                </Button>\n              </DropdownMenuTrigger>\n              <DropdownMenuContent className=\"w-28 h-fit p-2 bg-background border rounded-md mt-2\">\n                <DropdownMenuRadioGroup\n                  value={sort || undefined}\n                  onValueChange={value => setSort(value as 'asc' | 'desc')}\n                >\n                  <DropdownMenuRadioItem className=\"cursor-pointer\" value=\"asc\">\n                    오름차순\n                  </DropdownMenuRadioItem>\n                  <DropdownMenuRadioItem\n                    className=\"cursor-pointer\"\n                    value=\"desc\"\n                  >\n                    내림차순\n                  </DropdownMenuRadioItem>\n                </DropdownMenuRadioGroup>\n              </DropdownMenuContent>\n            </DropdownMenu>\n          </div>\n          {search && (\n            <div>{`${data.filter(order => order.user.toLowerCase().includes(search.toLowerCase())).length} 결과`}</div>\n          )}\n        </div>\n        <div className=\"flex justify-end gap-2 items-center\">\n          <div className=\"text-muted-foreground text-nowrap\">페이지당 표시 행 수</div>\n          <Select\n            value={`${pageSize}`}\n            onValueChange={value => setPageSize(Number(value))}\n          >\n            <SelectTrigger className=\"w-16\">\n              <SelectValue placeholder={`${pageSize}`} />\n            </SelectTrigger>\n            <SelectContent side=\"bottom\">\n              {[5, 10, 15, 20, 30, 50].map(size => (\n                <SelectItem key={`pageSize-${size}`} value={`${size}`}>\n                  {size}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        </div>\n      </div>\n      <div className=\"space-y-4\">\n        {list.map(order => {\n          const { amount, date, id, isDelivered, user } = order\n          return (\n            <Card\n              className={cn('p-4', 'flex items-center justify-between')}\n              key={id}\n            >\n              <div className=\"flex item-center gap-2\">\n                <div className=\"size-9 grid content-center ml-2\">\n                  <Checkbox\n                    checked={selection.has(id)}\n                    id={user}\n                    onCheckedChange={state =>\n                      toogleSelection(\n                        order,\n                        typeof state === 'string' ? false : state\n                      )\n                    }\n                  />\n                </div>\n                <label\n                  className={cn(\n                    'flex flex-col gap-1',\n                    'font-medium leading-none',\n                    'cursor-pointer'\n                  )}\n                  htmlFor={user}\n                >\n                  <span className=\"font-semibold\">{user}</span>\n                  <span className=\"text-sm text-muted-foreground\">\n                    {format(date, 'PPP')}\n                  </span>\n                </label>\n                <div>{isDelivered && <Badge>배송완료</Badge>}</div>\n              </div>\n              <div>{`${amount} $`}</div>\n            </Card>\n          )\n        })}\n      </div>\n      <div className=\"flex justify-between items-center\">\n        <div className=\"flex justify-start items-center gap-4\">\n          <div className=\"flex flex-col gap-0\">\n            <div className=\"flex gap-2 justify-start items-center\">\n              <Checkbox\n                checked={selection.size > 0}\n                id=\"all-users-selection\"\n                onCheckedChange={state =>\n                  toogleSelectionAll(typeof state === 'string' ? false : state)\n                }\n              />\n              <label\n                className=\"text-muted-foreground cursor-pointer\"\n                htmlFor=\"all-users-selection\"\n              >\n                {selection.size > 0 ? `모두 선택 해제` : `모두 선택`}\n              </label>\n            </div>\n            {data && (\n              <p>{`${selection.size} 중 ${data.length} 사용자 선택됨.`}</p>\n            )}\n          </div>\n          {selection.size > 0 && (\n            <Button\n              variant=\"destructive\"\n              onClick={() => deleteOrders(Array.from(selection))}\n            >\n              선택된 사용자 삭제\n            </Button>\n          )}\n        </div>\n        <div className={cn('flex justify-start items-center gap-2')}>\n          <Button\n            disabled={currentPage === 0}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={firstPage}\n          >\n            <DoubleArrowLeftIcon className=\"size-4\" />\n          </Button>\n          <Button\n            disabled={currentPage === 0}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={previousPage}\n          >\n            <ChevronLeftIcon className=\"size-4\" />\n          </Button>\n          <div className=\"text-muted-foreground\">\n            {`페이지 ${currentPage} / 총 ${pageCount} 페이지`}\n          </div>\n          <Button\n            disabled={currentPage >= pageCount}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={nextPage}\n          >\n            <ChevronRightIcon className=\"size-4\" />\n          </Button>\n          <Button\n            disabled={currentPage >= pageCount}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={lastPage}\n          >\n            <DoubleArrowRightIcon className=\"size-4\" />\n          </Button>\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\n\n\n## 기다리지 말고, 한번 시도해봅시다\n\n우리 예시를 테스트해보러 바로 들어가봅시다! 처음 눈에 보이는 대로 모든 것이 원활히 작동해야 합니다. 몇 가지 요소를 선택해보고, 모두 선택 해제하기, 모두 선택하기, 오름차순 및 내림차순으로 정렬하기, 페이지 크기 변경하기, 페이지를 통해 이동하기를 시도해보세요. 예! 모든 것이 잘 진행되지만, 검색할 때까지요.\n\n[이미지](/assets/img/2024-05-12-Re-inventingthewheelUselist_0.png)\n\n어떤 문제를 발견하셨나요? 화면에 표시된 요소는 9개만 있어야 합니다. 이것은 페이지 2가 4개의 요소만 포함해야 한다는 것을 의미합니다 (실제로 그렇지만), 그리고 마지막 페이지여야 합니다. 그러나 그렇지 않습니다. 요소를 필터링할 때, 페이지네이션 로직이 목록의 현재 상태에 따라 따르지 않습니다. 그 결과, 다른 페이지로 이동하면 아무것도 나타나지 않게 됩니다.\n\n\n\n지금, 이러한 오류를 수정하고 코드를 정리해 봅시다:\n\n# 마지막 스프린트\n\n## 우선, 문제를 해결하세요\n\n해결책은 놀랍게도 간단합니다:\n\n\n\n```js\nexport function useList<T, U>(\n  dataList: Array<T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions<T, U>\n) {\n  const data = React.useMemo(\n    () => dataList.filter(filterFn ?? (() => true)),\n    [dataList, filterFn]\n  )\n  ...\n}\n```\n\n지금은 많은 것을 이름을 다시 지을 필요가 없어요. 우리는 간단히 페이지네이션 및 선택과 같은 다른 기능들을, 필터된 목록을 기반으로 합니다.\n이제 예제를 다시 실행하고 변경 사항을 관찰해 보세요:\n\n![Re-inventing the wheel: UseList](/assets/img/2024-05-12-Re-inventingthewheelUselist_1.png)\n\n심지어 모두 선택을 시도해 볼 수 있고, 필터된 결과만 선택됨을 알 수 있을 거예요. 그러나 모든 선택된 값을 삭제하면, \"모두 선택\" 확인란이 여전히 선택된 채로 남겨진다는 것을 알 수 있을 거예요. 이는 데이터가 변경될 때 선택 목록을 업데이트하지 않기 때문입니다.\n이러한 문제를 해결해 봅시다:```\n\n\n\n```js\nexport function useList<T, U>(\n  dataList: Array<T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions<T, U>\n) {\n  ...\n\n  React.useEffect(() => {\n    setSelection(new Set([]))\n  }, [dataList.length])\n\n  ...\n}\n```\n\n각 렌더링마다 원본 데이터의 길이가 변경되면 선택 목록을 지웁니다.\n\n네, 우리의 훅은 실제로 더 확장되고 복잡해지고 있습니다. 이제 코드를 정리해봅시다.\n(네, 알겠어요. 여전히 깔끔한 코드에 대해서는 이야기를 못하고 있는데 말이죠! 🙄)\n\n## 정리하기\n\n\n\n먼저, 각 기능을 자신만의 함수로 분리해 봅시다. 선택 기능부터 시작해 보겠습니다. 선택에 대한 파일을 만들고 다음 코드를 붙여 넣어주세요:\n\n```js\nexport function useListSelection<T, U>(\n  data: Array<T>,\n  getId: (element: T) => U\n) {\n  const [selection, setSelection] = React.useState<Set<U>>(new Set([]))\n\n  React.useEffect(() => {\n    setSelection(new Set([]))\n  }, [data.length])\n\n  const toogleSelection = React.useCallback(\n    (item: T, state?: boolean) =>\n      setSelection(currentSelection => {\n        const itemId = getId(item)\n        const selectionList = new Set(currentSelection)\n        if (state || !selectionList.has(itemId)) selectionList.add(itemId)\n        else selectionList.delete(itemId)\n        return new Set(selectionList)\n      }),\n    [getId]\n  )\n\n  const toogleSelectionAll = React.useCallback(\n    (state?: boolean) =>\n      setSelection(currentSelection => {\n        if (state || currentSelection.size === 0)\n          return new Set(data.map(item => getId(item)))\n        const selectionList = new Set(currentSelection)\n        selectionList.clear()\n        return selectionList\n      }),\n    [data, getId]\n  )\n\n  return { selection, toogleSelection, toogleSelectionAll }\n}\n```\n\n이제 페이징에 대해 해결해 봅시다. 파일을 만들고 아래 코드를 붙여 넣어주세요:\n\n```js\nexport function useListPagination<T>(data: Array<T>, defaultPageSize: number) {\n  const [pageSize, setPageSizeState] = React.useState<number>(defaultPageSize)\n  const [index, setIndex] = React.useState<number>(0)\n\n  const currentPage = React.useMemo(\n    () => index / pageSize + 1,\n    [index, pageSize]\n  )\n\n  const pageCount = React.useMemo(() => {\n    if (pageSize >= data.length) return 1\n    return Math.ceil(data.length / pageSize)\n  }, [data.length, pageSize])\n\n  const nextPage = React.useCallback(() => {\n    if (pageSize < data.length && index + pageSize < data.length)\n      setIndex(currentIndex => currentIndex + pageSize)\n  }, [data.length, index, pageSize])\n\n  const previousPage = React.useCallback(() => {\n    if (pageSize < data.length && index - pageSize >= 0)\n      setIndex(currentIndex => currentIndex - pageSize)\n  }, [data.length, index, pageSize])\n\n  const firstPage = React.useCallback(() => setIndex(0), [])\n\n  const lastPage = React.useCallback(() => {\n    if (pageSize < data.length && index + pageSize < data.length)\n      setIndex(pageSize * (pageCount - 1))\n  }, [data.length, index, pageCount, pageSize])\n\n  const goToPage = React.useCallback(\n    (destinationPage: number) => {\n      if (destinationPage < pageCount)\n        setIndex(pageSize * (destinationPage - 1))\n    },\n    [pageCount, pageSize]\n  )\n\n  const setPageSize = React.useCallback(\n    (size: number) => {\n      setPageSizeState(size)\n      const newIndex = Math.floor(index / size) * size\n      setIndex(newIndex)\n    },\n    [index]\n  )\n\n  return {\n    currentPage,\n    firstPage,\n    goToPage,\n    index,\n    lastPage,\n    nextPage,\n    pageCount,\n    pageSize,\n    previousPage,\n    setPageSize\n  }\n}\n```\n\n\n\n그렇죠, 여전히 꽤 크지만 삶이 그런 거에요. 항상 원하는 대로 되는 것은 아니죠. 🤷🏾‍♂️.\n자, 이제 메인 후크를 업데이트해 봅시다:\n\n```js\nexport function useList<T, U>(\n  dataList: Array<T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions<T, U>\n) {\n  const data = React.useMemo(\n    () => dataList.filter(filterFn ?? (() => true)),\n    [dataList, filterFn]\n  )\n\n  const selection = useListSelection(data, getId)\n  const { index, pageSize, ...pagination } = useListPagination(\n    data,\n    defaultPageSize\n  )\n\n  const list = React.useMemo(\n    () => [...data].sort(sortFn).slice(index, index + pageSize),\n    [data, index, pageSize, sortFn]\n  )\n\n  return {\n    list,\n    pageSize,\n    ...pagination,\n    ...selection\n  }\n}\n```\n\n\"모두 선택\" 확인란이 데이터 크기가 변경될 때(예: 삭제 시) 또는 필터링할 때 선택 취소됩니다. 이는 선택을 지우기 위해 사용하는 useEffect가 필터링된 데이터에 기반하고 있기 때문입니다. 사용자가 적용하는 검색 또는 필터와 관계없이 선택을 유지할지 또는 현재 동작을 유지할지 결정할 수 있습니다.\n\n현재 동작을 유지하면 선택은 후크에서 반환한 데이터를 기반으로 하지만, 기존 동작은 최종 사용자가 보기를 결정한 데이터 내용이 아닌 데이터에서 작동할 수 있어 예측할 수 없는 동작을 초래할 수 있습니다. 사용자 경험(UX)과 보안을 위해 현재 구현이 더 나은 선택입니다. 하지만, 여전히 확신이 들지 않는다면, 선택 후크에서 useEffect를 제거하고 그것을 useList 함수로 이동시키고, 의존성을 dataList.length로 변경해보세요.\n\n\n\n# 최종 기능\n\n이제 최종 고려 사항은 사용자가 사용하려는 기능을 선택할 수 있는 유연성을 제공하는 것입니다. 사용자가 항상 정렬, 필터링 또는 선택 기능이 필요한 것은 아닐 수 있습니다. 따라서 이러한 기능을 선택 사항으로 허용해야 합니다. 구현 내용을 자세히 살펴보겠습니다.\n\n일부 새로운 아이디어: 사용자가 사용하려는 각 기능에 대해 값을 제공해야 합니다. 예를 들어, 페이지네이션에는 defaultPageSize, 필터링에는 filterFn, 정렬에는 sortFn, 선택 기능에는 getId를 제공해야 합니다. 사용자가 매개변수에 값을 제공하지 않으면 해당 기능이 비활성화됩니다. getId 함수를 제공하지 않고도 액세스하려고 할 경우에도 기능을 사용할 수 있습니다.\n\n이제 당신은 « 네, 그런데 모든 것이 선택 사항이라면, 사용자가 빈 객체를 제공하면 어떻게 되나요? »라고 할 것이고, 저는 그들이 그냥 멍청한 것이라고 말할 것이지만 그것은 아무 문제가 되지 않을 것입니다 😜. 걱정하지 마세요, TypeScript가 우리를 돕기 위해 여기 있습니다. 사용자로부터 최소한 하나의 매개변수를 제공 받기 위해 유틸리티 타입을 생성해야 합니다. 여기에 결과입니다:\n\n\n\n```js\r\ntype AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U]\n\ntype UseListOptions<T, U> = {\n  defaultPageSize: number\n  filterFn: (element: T) => boolean\n  getId: (element: T) => U\n  sortFn: (elementA: T, elementB: T) => number\n}\n\ntype UseListParamsType<T, U> = AtLeastOne<UseListOptions<T, U>>\r\n```\n\n이제 UseListParamsType을 훅의 두 번째 매개변수 유형으로 사용하고 완료!\n\n예제 코드의 오류를 수정하는 시간입니다 (일부 매개변수를 제거해서 어떻게 되는지도 시도해보세요):\n\n```js\r\nreturn (\n  <div className=\"space-y-4\">\n    <div className=\"flex justify-between gap-2 items-center\">\n      <div className=\"flex justify-start items-center gap-2\">\n        <div className=\"relative ml-auto flex-1 md:grow-0\">\n          <Search className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n          <Input\n            className=\"w-full rounded-lg bg-background pl-9 md:w-[200px] lg:w-[336px]\"\n            placeholder=\"Search...\"\n            type=\"search\"\n            onChange={e => setSearch(e.target.value)}\n          />\n        </div>\n        <div>\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <Button variant=\"outline\">\n                {sort === 'asc' ? (\n                  <>\n                    <ArrowUpNarrowWide className=\"size-4 mr-4\" />\n                    Asc\n                  </>\n                ) : sort === 'desc' ? (\n                  <>\n                    <ArrowDownNarrowWide className=\"size-4 mr-4\" />\n                    Desc\n                  </>\n                ) : (\n                  <>\n                    <ArrowUpDown className=\"size-4 mr-4\" />\n                    Sort\n                  </>\n                )}\n              </Button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent className=\"w-28 h-fit p-2 bg-background border rounded-md mt-2\">\n              <DropdownMenuRadioGroup\n                value={sort || undefined}\n                onValueChange={value => setSort(value as 'asc' | 'desc')}\n              >\n                <DropdownMenuRadioItem className=\"cursor-pointer\" value=\"asc\">\n                  Asc\n                </DropdownMenuRadioItem>\n                <DropdownMenuRadioItem\n                  className=\"cursor-pointer\"\n                  value=\"desc\"\n                >\n                  Desc\n                </DropdownMenuRadioItem>\n              </DropdownMenuRadioGroup>\n            </DropdownMenuContent>\n          </DropdownMenu>\n        </div>\n        {search && (\n          <div>{`${data.filter(order => order.user.toLowerCase().includes(search.toLowerCase())).length} results`}</div>\n        )}\n      </div>\n      {pageSize && setPageSize && (\n        <div className=\"flex justify-end gap-2 items-center\">\n          <div className=\"text-muted-foreground text-nowrap\">\n            Rows per page\n          </div>\n          <Select\n            value={`${pageSize}`}\n            onValueChange={value => setPageSize?.(Number(value))}\n          >\n            <SelectTrigger className=\"w-16\">\n              <SelectValue placeholder={`${pageSize}`} />\n            </SelectTrigger>\n            <SelectContent side=\"bottom\">\n              {[5, 10, 15, 20, 30, 50].map(size => (\n                <SelectItem key={`pageSize-${size}`} value={`${size}`}>\n                  {size}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        </div>\n      )}\n    </div>\n    <div className=\"space-y-4\">\n      {list.map(order => {\n        const { amount, date, id, isDelivered, user } = order\n        return (\n          <Card\n            className={cn('p-4', 'flex items-center justify-between')}\n            key={id}\n          >\n            <div className=\"flex item-center gap-2\">\n              {selection && toogleSelection && (\n                <div className=\"size-9 grid content-center ml-2\">\n                  <Checkbox\n                    checked={selection.has(id)}\n                    id={user}\n                    onCheckedChange={state =>\n                      toogleSelection(\n                        order,\n                        typeof state === 'string' ? false : state\n                      )\n                    }\n                  />\n                </div>\n              )}\n              <label\n                className={cn(\n                  'flex flex-col gap-1',\n                  'font-medium leading-none',\n                  'cursor-pointer'\n                )}\n                htmlFor={user}\n              >\n                <span className=\"font-semibold\">{user}</span>\n                <span className=\"text-sm text-muted-foreground\">\n                  {format(date, 'PPP')}\n                </span>\n              </label>\n              <div>{isDelivered && <Badge>delivered</Badge>}</div>\n            </div>\n            <div>{`${amount} $`}</div>\n          </Card>\n        )\n      })}\n    </div>\n    <div className=\"flex justify-between items-center\">\n      {selection && (\n        <div className=\"flex justify-start items-center gap-4\">\n          <div className=\"flex flex-col gap-0\">\n            <div className=\"flex gap-2 justify-start items-center\">\n              {toogleSelectionAll && (\n                <Checkbox\n                  checked={selection.size > 0}\n                  id=\"all-users-selection\"\n                  onCheckedChange={state =>\n                    toogleSelectionAll(\n                      typeof state === 'string' ? false : state\n                    )\n                  }\n                />\n              )}\n              <label\n                className=\"text-muted-foreground cursor-pointer\"\n                htmlFor=\"all-users-selection\"\n              >\n                {selection.size > 0 ? `Unselect all` : `Select all`}\n              </label>\n            </div>\n            {data && (\n              <p>{`${selection.size} of ${data.length} user(s) selected.`}</p>\n            )}\n          </div>\n          {selection.size > 0 && (\n            <Button\n              variant=\"destructive\"\n              onClick={() => deleteOrders(Array.from(selection))}\n            >\n              Delete selected users\n            </Button>\n          )}\n        </div>\n      )}\n      {currentPage && pageCount && (\n        <div className={cn('flex justify-start items-center gap-2')}>\n          <Button\n            disabled={currentPage === 0}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={firstPage}\n          >\n            <DoubleArrowLeftIcon className=\"size-4\" />\n          </Button>\n          <Button\n            disabled={currentPage === 0}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={previousPage}\n          >\n            <ChevronLeftIcon className=\"size-4\" />\n          </Button>\n          <div className=\"text-muted-foreground\">\n            {`Page ${currentPage} of ${pageCount}`}\n          </div>\n          <Button\n            disabled={currentPage >= pageCount}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={nextPage}\n          >\n            <ChevronRightIcon className=\"size-4\" />\n          </Button>\n          <Button\n            disabled={currentPage >= pageCount}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={lastPage}\n          >\n            <DoubleArrowRightIcon className=\"size-4\" />\n          </Button>\n        </div>\n      )}\n    </div>\n  </div>\n)\r\n```\n\n\n\n# 결론\n\n긴 여정이죠? 깊게 숨 쉬세요, 우리는 막 시작했어요. 이 시리즈에서는 리액트 애플리케이션에서 보통 사용하는 몇 가지 유용한 도구들을 새롭게 구현해 볼 거예요.","ogImage":{"url":"/assets/img/2024-05-12-Re-inventingthewheelUselist_0.png"},"coverImage":"/assets/img/2024-05-12-Re-inventingthewheelUselist_0.png","tag":["Tech"],"readingTime":33},{"title":"React-router를 사용하여 네비게이션 바 만들기","description":"","date":"2024-05-12 20:08","slug":"2024-05-12-Creatingnavbarusingreact-router","content":"\n\n안녕하세요 여러분! 어떻게 하고 계신가요?\n\n여기서는 React 라우팅 모듈을 사용하여 React 네비게이션 바를 설정하는 방법에 대해 자세히 알아보겠습니다. 이 방법 외에도 다른 방법들이 있지만, 저는 이 방법을 선호합니다. 보다 간결하고 오류를 방지할 수 있기 때문이죠. 단계별로 진행해보겠습니다.\n\n단계1\n\n먼저 다음 명령어를 사용하여 React 앱을 설정할 것입니다:\n\n\n\n여기에는 시스템에 최신 노드 버전이 설치되어 있어야 합니다.\n\n단계 2\n\n앱의 src 디렉터리 내에 컴포넌트 폴더를 만들고 다음과 같이 네비게이션 바에 표시할 세 개의 컴포넌트를 만드십시오.\n\n![Creatingnavbarusingreact-router](/assets/img/2024-05-12-Creatingnavbarusingreact-router_0.png)\n\n\n\n### 단계 3:\n\n이제 리액트 라우터 라이브러리를 설치할 것입니다.\n\n리액트 라우터는 리액트에서 경로 지정을 위한 표준 라이브러리입니다. 리액트 애플리케이션의 다양한 컴포넌트 뷰 간의 이동을 활성화하며, 브라우저 URL을 변경 가능하게 하고 UI가 URL과 동기화되도록 합니다.\n\n기억해야 할 한 가지는 버전이 `6.3여야 한다는 것입니다. 이전 버전은 이 프로젝트에서 사용할 일부 자식 컴포넌트를 지원하지 않습니다.\n\n\n\n![이미지](/assets/img/2024-05-12-Creatingnavbarusingreact-router_1.png)\n\n### 단계 4\n\n다음으로 할 일은 index.js에서 react-router-dom에서 BrowserRouter를 import하는 것입니다. 그런 다음, 우리가 만들어진 앱을 browserRouter로 감싸줄 것입니다. 우리의 index.js 파일은 다음과 같이 보일 것입니다:\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { BrowserRouter } from 'react-router-dom';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>\n);\nreportWebVitals();\n```\n\n\n\n5단계\n\n이제 네비게이션 바 페이지를 만들어봅시다. 먼저, React Router DOM에서 Link 컴포넌트를 가져와야 합니다. Link는 다른 경로로의 링크를 생성하고 애플리케이션에서 탐색을 구현하는 데 사용됩니다. 네비게이션 바의 앵커 태그 역할을 하는데, 'to'를 사용하여 경로를 정의합니다('to'는 href와 유사합니다). 우리의 네비게이션 바는 다음과 같이 보여야 합니다:\n\n```js\nimport React from 'react';\nimport {Link} from 'react-router-dom';\n\nconst Navbar=()=>{\n    return (    \n                <div className='navBar'>\n                    <div className='stocks'>\n                        <Link to=\"/\">Stocks</Link>\n                    </div>\n                    <div className='favourites'>\n                        <Link to=\"/favourites\">Favourite</Link>\n                    </div>\n                    <div className='cart'>\n                        <Link to=\"/cart\">Cart</Link>\n                    </div>\n                </div>\n    )\n\n}\n\nexport default Navbar;\n```\n\n6단계\n\n\n\napp.js로 이동하여 react-router-dom에서 Route 및 routes 컴포넌트를 가져옵니다. Routes 컴포넌트에는 모든 경로가 포함되어 있고, route는 선택할 수있는 개별 경로를 정의합니다. 우리의 app.js는 이렇게 보일 것입니다:\n\n```js\nimport './App.css';\nimport { Route, Routes } from 'react-router-dom';\nimport Navbar from './components/navbar';\nimport Stocks from './components/stocks';\nimport Favourites from './components/favourites';\nimport Cart from './components/cart';\n\nfunction App() {\n  return (\n   <>\n    <Navbar/>\n      <div>\n    <Routes>        \n      <Route path=\"/\"  element={<Stocks/>} />\n      <Route path=\"/favourites\"  element={<Favourites />}/>\n      <Route path=\"/cart\"  element={<Cart/>}/>\n    </Routes>\n    </div>\n    </>\n   \n  );\n}\n\nexport default App;\n```\n\n그런 다음 우리는 일치하는 경로를 사용하여 element로 컴포넌트를 정의합니다.\n\n우와!!! 우리의 네비게이션 바가 사용할 준비가 되었습니다. 전체 코드는 GitHub에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-Creatingnavbarusingreact-router_0.png"},"coverImage":"/assets/img/2024-05-12-Creatingnavbarusingreact-router_0.png","tag":["Tech"],"readingTime":3},{"title":"Reactjs에서 Yup 라이브러리를 사용하여 양식 유효성 검사를 만드는 방법","description":"","date":"2024-05-12 20:07","slug":"2024-05-12-HowtocreateformvalidationwithYuplibraryinReactjs","content":"\n\n폼 유효성 검사는 모든 웹 애플리케이션의 중요한 부분입니다. 사용자가 입력한 데이터가 올바르고 완전한지 확인하는 데 도움이 됩니다. Yup은 Reactjs의 인기있는 유효성 검사 라이브러리로, 폼 유효성을 쉽게 만들고 관리할 수 있습니다.\n\n![Yup 라이브러리를 사용하여 어떻게 Reactjs에서 폼 유효성을 만들 수 있는지](/assets/img/2024-05-12-HowtocreateformvalidationwithYuplibraryinReactjs_0.png)\n\nYup을 사용하려면 먼저 npm을 사용하여 설치해야 합니다: npm install yup\n\nYup을 설치한 후에는 유효성 검사 스키마를 작성할 수 있습니다. 유효성 검사 스키마는 폼의 데이터를 유효성 검사하는 규칙을 정의하는 객체입니다.\n\n\n\n예를 들어, 다음 스키마는 사용자 이름과 비밀번호를 유효성 검사합니다:\n\n```js\nconst schema = Yup.object().shape({\n  username: Yup.string().required(),\n  password: Yup.string().required().minLength(8),\n});\n```\n\nrequired() 규칙은 필드가 필수임을 나타냅니다. minLength() 규칙은 필드가 적어도 8자여야 함을 나타냅니다.\n\n그런 다음 validate() 메서드를 사용하여 폼 데이터를 유효성 검사할 수 있습니다.\n\n\n\n```js\nconst formData = {\n  username: \"user123\",\n  password: \"password123\",\n};\n\nconst errors = schema.validate(formData);\n\nif (errors.length > 0) {\n  // 폼 데이터에 오류가 있습니다\n} else {\n  // 폼 데이터가 유효합니다\n}\n```\n\n만일 폼 데이터가 유효하지 않을 경우, errors 객체는 오류 메시지의 배열을 포함하게 됩니다.\n\nYup은 email(), url(), number() 등 다양한 다른 유효성 검사 규칙도 제공합니다. Yup 문서에서 사용 가능한 유효성 검사 규칙의 전체 목록을 찾을 수 있습니다.\n\n다음은 사용자가 새 계정을 만들 수 있는 폼을 유효성 검사하기 위해 Yup을 사용하는 예시입니다:\n```  \n\n\n\n```js\nconst schema = Yup.object().shape({\n  username: Yup.string().required().minLength(3).maxLength(25),\n  email: Yup.string().email().required(),\n  password: Yup.string().required().minLength(8).maxLenght(25),\n});\n\nconst handleSubmit = (e) => {\n  e.preventDefault();\n\n  const formData = {\n    username: e.target.username.value,\n    email: e.target.email.value,\n    password: e.target.password.value,\n  };\n\n  const errors = schema.validate(formData);\n\n  if (errors.length > 0) {\n    // 양식 데이터에 오류가 있음\n    alert(errors.join(\"\\n\"));\n  } else {\n    // 양식 데이터가 유효함, 처리할 작업 수행\n  }\n};\n\nconst App = () => {\n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"text\" name=\"username\" placeholder=\"사용자 이름\" />\n      <input type=\"email\" name=\"email\" placeholder=\"이메일\" />\n      <input type=\"password\" name=\"password\" placeholder=\"비밀번호\" />\n      <button type=\"submit\">계정 생성</button>\n    </form>\n  );\n};\n```\n\n이 예시는 사용자가 제출 버튼을 클릭할 때 onSubmit 이벤트 핸들러를 사용하여 양식 데이터를 유효성 검사합니다. 양식 데이터가 유효하면 코드는 해당 데이터를 처리합니다. 그렇지 않으면 오류 메시지가 표시됩니다.\n```","ogImage":{"url":"/assets/img/2024-05-12-HowtocreateformvalidationwithYuplibraryinReactjs_0.png"},"coverImage":"/assets/img/2024-05-12-HowtocreateformvalidationwithYuplibraryinReactjs_0.png","tag":["Tech"],"readingTime":3},{"title":"Nextjs에서 이미지 로딩을 흐릿하게 만들기","description":"","date":"2024-05-12 20:06","slug":"2024-05-12-MakeYourImageLoadingBlurryinNextjs","content":"\n\n웹 이미지는 사이트 성능 측면에서 중요하며 솔직히 말하자면 번거로운 부분이기도 합니다. Next.js의 최고의 기능 중 하나는 이미지 컴포넌트로, 이미지를 최적화해 줍니다. 이 컴포넌트는 화면 크기에 맞춰 WebP와 같은 현대적인 포맷의 이미지를 자동으로 생성하여 이미지 크기를 줄여줍니다. 또한 이미지가 뷰포트에 진입할 때 이미지를 불러오는 lazy loading과 레이아웃 이동을 방지하는 시각적 안정성이 구현되어 있습니다. 만약 이미지 컴포넌트에 익숙하지 않다면 Lee Robinson의 이 비디오를 추천합니다. 이 글에서는 실제 이미지가 로드되는 동안 흐린 이미지를 추가하는 것에 초점을 맞추고자 합니다.\n\n## 이미지 컴포넌트의 기본 이미지 흐림\n\n이미지 컴포넌트에는 한 가지 제한이 있지만, 기본 옵션으로 이미지를 흐리게 만들어 줄 수도 있습니다! 제 포트폴리오 웹사이트에서 한 예시를 보여드리겠습니다.\n\n기본 로딩보다 훨씬 나아요. 앞서 언급한 대로 한 가지 제한이 있습니다: 이미지를 정적으로 가져와야 합니다. 특히 이미지 동적 또는 클라우드 서비스를 사용하는 경우에는 이미지를 정적으로 가져오는 것이 불가능할 수 있습니다. 이 제한을 다음 기술에서 극복하겠지만, 지금은 이 기본 흐린 이미지를 가능하게 하는 코드를 살펴보도록 하죠.\n\n\n\n```js\nimport furkanpicture from \"@/public/pics/furkan.png\";\nimport Image from \"next/image\";\nimport React from \"react\";\n\nexport default function AboutImage() {\n  return (\n    <figure>\n      <Image\n        src={furkanpicture}\n        alt={\"Furkan Cengiz\"}\n        placeholder=\"blur\" //기본값은 \"empty\"입니다\n      />\n    </figure>\n  );\n}\n```\n\nplaceholder prop을 blur로 전달하고 src prop을 정적으로 가져온 이미지 개체로 전달할 때 Image 컴포넌트는 비디오에서 보는 것처럼 흐린 이미지를 생성합니다! 정적 페이지나 웹사이트를 구축 중이라면 기본적인 블러 동작을 활용할 수 있습니다!\n\n## Plaiceholder를 사용하여 dataURL 생성하기\n\n정적 이미지를 사용하는 경우 로딩 상태에 대한 흐린 이미지를 추가할 수 있습니다. 이제 이전 방법의 한계를 극복해야 합니다.\n```\n\n\n\n문서에 따르면 동적 이미지를 위해 Image 컴포넌트의 blurDataUrl 속성에 dataURL을 전달해야 합니다. dataURL은 기본적으로 base64 형식으로 흐린 이미지 데이터를 보유하는 문자열입니다.\n\n```js\ndataURL 예시\ndata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAYAAAB/qH1jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAJ0lEQVR4nGPY2fXjv458/H9Bbtf/IDbD/7v//8/Mvfq/J+nEfxAbAF3NFsFiuaE1AAAAAElFTkSuQmCC\n```\n\n우리는 이제 무엇이 필요한지 알았지만, 이렇게 데이터URL을 생성하는 방법이 무엇인지 궁금할 것입니다. 문서에서 제안한대로, plaiceholder는 이를 가능하게 해줍니다!\n\n우선, sharp와 plaiceholder 두 가지 패키지를 설치해야 합니다. 설치 방법은 이 페이지를 참고해주세요.\n\n\n\nNext.js를 사용하고 있다고 가정합니다. 다음 페이지를 따라서 next.config.ts 또는 next.config.mjs 파일을 구성해 주세요.\n\n설치가 완료되었습니다! 이제 서버 측에서 실행되는 사용자 정의 함수를 구현해야 합니다. 이 함수는 우리가 필요한 데이터URL을 생성합니다.\n\n```js\nimport fs from \"node:fs/promises\";\nimport { getPlaiceholder } from \"plaiceholder\";\n\nexport const getBase64 = async (imgPath: string) => {\n  try {\n    const file = await fs.readFile(`public/${imgPath}`)\n    const { base64 } = await getPlaiceholder(file)\n    return base64\n  } catch (error: unknown) {\n    // 에러 처리\n    if (error instanceof Error) return error.message\n    else if (error && typeof error === \"object\" && \"message\" in error)\n      return error.message as string\n    else if (typeof error === \"string\") return error;\n    else return \"예기치 않은 오류 발생!\"\n  }\n}\n```\n\n저는 문서에서처럼 then 또는 catch 메서드 대신 async-await 키워드를 사용하여 구현했습니다. getPlaiceholder 함수가 필요한 파일을 읽어야 합니다. 파일 경로에 \"public\" 접두사를 추가했습니다. 그런 다음 파일을 getPlaiceholder 함수에 전달했습니다. 이 함수는 css, color, pixels, base64 등과 같은 여러 객체를 반환합니다. 반환된 객체를 비구조화하여 base64 값을 추출하고 반환하세요!\n\n\n\n필요한 데이터URL을 생성하는 함수가 완성되었습니다. 이제 중요한 마지막 단계가 나왔어요!\n\n## getBase64 함수 사용하기\n\n함수에서 node:fs/promises를 가져오는 함수를 통해 파일을 읽었음을 알 수 있어요. 이는 이 함수가 노드 환경에서만 실행될 수 있다는 뜻이에요. 그러므로, 클라이언트 구성 요소에서 이 함수를 사용할 수는 없다는 점을 명심하는 것이 중요해요. 그치만 걱정할 필요는 아직 없어요. 왜냐하면 서버 구성 요소는 있거든요. 클라이언트 구성 요소에서 이 함수를 사용할 수 없더라도, 여전히 서버 구성 요소에서 이 async 함수를 호출하고 반환된 값을 클라이언트 구성 요소로 전달할 수 있어요.\n\n저의 포트폴리오 프로젝트에서 예제를 확인할 수 있어요. (이미 서버 구성 요소에서 이미지 구성 요소를 사용 중이라면, 이 마지막 단계는 필요하지 않아요. 클라이언트 구성 요소에 base64 문자열을 blurDataUrl 속성에 전달하려면 단순히 구성 요소를 async로 만들고 함수를 호출하면 됩니다.)\n\n\n\n위의 코드에서 여러 개의 base64 문자열을 생성하고 각각의 클라이언트 컴포넌트로 전달하고 있어요. (개별 이미지의 경로 문자열을 getBase64 함수에 전달하고 기다리면 단일 base64 문자열을 생성할 수 있어요)\n\n그래서 지금 우리는 흐린 이미지를 준비했어요!\n\n\n\n마지막으로, 플레이스홀더를 사용하여 SVG 및 색상과 같은 다른 기술을 활용할 수 있습니다. 그 외에도 시도해 볼 수 있는 기술이 많으니 플레이스홀더의 데모를 방문해 모든 기술을 확인해보세요.\n\n로딩 상태에서 흐릿한 이미지는 정말 좋아하는 기술입니다. 많은 웹사이트와 심지어 Discord와 같은 Windows 애플리케이션이 사용하는 기술인데, 우아함의 요소를 더해준다고 생각합니다. 이 기사가 도움이 되었으면 좋겠어요. 제 최신 작업 소식을 받아보려면 Medium이나 LinkedIn에서 팔로우해주세요. 다음 글에서 뵙길 기대하겠습니다!","ogImage":{"url":"/assets/img/2024-05-12-MakeYourImageLoadingBlurryinNextjs_0.png"},"coverImage":"/assets/img/2024-05-12-MakeYourImageLoadingBlurryinNextjs_0.png","tag":["Tech"],"readingTime":4},{"title":"리덕스-퍼시스트로 React 앱의 상태 유지하기","description":"","date":"2024-05-12 20:05","slug":"2024-05-12-PersistingStateinYourReactAppwithRedux-Persist","content":"\n\n프런트엔드 개발 세계에서 React는 주요한 역할을 하는 기술로 떠올랐어요. 컴포넌트 기반 아키텍처와 가상 DOM을 통해 사용자 인터페이스를 구축하는 데 강력한 도구로 작용해요. React 애플리케이션의 상태를 관리할 때 Redux는 예측 가능성과 디버깅의 용이성으로 인해 인기 있는 선택지에요. 그렇다면 Redux 상태를 페이지 새로고침이나 앱 재시작에 걸쳐 유지하려면 어떻게 해야 할까요? 이때 \"redux-persist\"가 등장해요.\n\nRedux-persist는 Redux와 완벽하게 통합되어 애플리케이션의 상태를 유지하도록 돕는 라이브러리에요. 이 글에서는 실용적인 코드 조각을 활용해 React 앱에서 redux-persist를 사용하는 방법을 살펴볼 거예요.\n\n# 상태 유지의 필요성\n\nredux-persist에 대해 자세히 알아보기 전에 React 애플리케이션에서 상태 유지가 필요한 이유를 이해하는 것이 중요해요. 대부분의 경우, 애플리케이션의 상태는 메모리에 저장되며 페이지를 새로고침하거나 앱을 닫았다가 다시 열 때 재설정돼요. 일부 애플리케이션에서는 이러한 동작이 수용 가능할 수 있지만, 사용자가 페이지를 떠나거나 새로고침한 후에도 사용자 데이터, 설정 또는 세션 정보를 저장하고 로드해야 하는 경우도 많아요.\n\n\n\n리덕스-퍼시스트는 이 문제에 간편한 해결책을 제공합니다. 이를 통해 Redux 스토어의 상태를 로컬 스토리지나 AsyncStorage(React Native 애플리케이션의 경우)와 같은 영구 저장 매체에 저장한 다음 앱을 로드할 때 해당 상태로 스토어를 재생성할 수 있습니다.\n\n이제 여러분의 리액트 애플리케이션에 이를 구현하는 방법을 살펴보겠습니다.\n\n# 시작하기\n\n먼저, 리액트 프로젝트에 리덕스가 설정되어 있는지 확인하세요. 아직 설정하지 않았다면 Redux를 설치하고 애플리케이션을 위한 스토어를 만들어야 합니다. 이번 시연을 위해 이미 준비된 리덕스 스토어가 있다고 가정하겠습니다.\n\n\n\n다음으로 redux-persist 라이브러리를 설치해야 합니다. npm 또는 yarn을 사용하여 다음과 같이 설치할 수 있습니다:\n\n```js\nnpm install redux-persist\n# 또는\nyarn add redux-persist\n```\n\n이제 redux-persist를 설치했으므로 Redux 스토어와 함께 작동하도록 구성할 수 있습니다.\n\n# 구성\n\n\n\n당신의 Redux 스토어 구성 파일에서 redux-persist로부터 persistReducer를 import하여 상태의 원하는 부분을 지속적으로 저장하도록 구성하세요. 어떤 리듀서와 그 리듀서의 어떤 속성을 지속적으로 저장할지 선택할 수 있습니다.\n\n```js\n// store.js\nimport { createStore } from 'redux';\nimport { persistStore, persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage'; // 사용할 저장 엔진 선택\nimport rootReducer from './reducers'; // 루트 리듀서 import\nconst persistConfig = {\n  key: 'root',\n  storage,\n  // 지속적으로 저장하려는 리듀서 지정\n  whitelist: ['user'], // 이 예시에서는 'user' 리듀서를 지속적으로 저장합니다\n};\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\nexport const store = createStore(persistedReducer);\nexport const persistor = persistStore(store);\n```\n\n이 예시에서는 redux-persist를 사용하여 `user` 리듀서를 지속적으로 저장하도록 구성했지만, 이를 애플리케이션의 요구에 맞게 사용자 정의할 수 있습니다.\n\n# 앱 감싸기\n\n\n\n이제 Redux 스토어를 redux-persist로 구성했으니, redux-persist에서 제공하는 PersistGate 컴포넌트로 앱을 감싸야 합니다. 이 컴포넌트는 영속 상태가 검색되기 전에 앱이 렌더링되도록 보장합니다.\n\n```js\n// index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/integration/react'; // PersistGate 가져오기\nimport { store, persistor } from './store';\nimport App from './App';\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor}>\n      <App />\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n# 사용법\n\nredux-persist가 설정된 상태에서는 React 컴포넌트에서 Redux를 평소처럼 사용할 수 있습니다. persistConfig에서 지정한 모든 상태는 자동으로 지속될 것이며 다시 수분화될 것입니다.\n\n\n\n```js\n// userReducer.js\nconst initialState = {\n  username: '',\n  email: '',\n  // ... other user-related properties\n};\nconst userReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'SET_USERNAME':\n      return {\n        ...state,\n        username: action.payload,\n      };\n    case 'SET_EMAIL':\n      return {\n        ...state,\n        email: action.payload,\n      };\n    // ... other reducer cases\n    default:\n      return state;\n  }\n};\nexport default userReducer;\n```\n\n위 예에서 'user' 리듀서에 대한 모든 변경 사항은 앱이 다시 시작되거나 페이지가 새로고침될 때 자동으로 유지되고 다시로드됩니다.\n\n# 결론\n\nRedux-persist는 React 애플리케이션의 상태 지속성을 제공하여 애플리케이션을 강화하는 강력한 라이브러리입니다. 이는 사용자가 로그인해야 하는 애플리케이션이나 사용자 선호 설정 및 세션 데이터를 저장하려는 애플리케이션에 매우 유용할 수 있습니다.\n```\n\n\n\n이 문서에 설명된 단계를 따라 하면 Redux를 사용하는 React 애플리케이션에 redux-persist를 쉽게 통합할 수 있습니다. 이를 통해 사용자들이 세션 및 페이지 새로고침 간에 데이터 지속성을 즐길 수 있게 되어, 더 견고하고 사용자 친화적인 애플리케이션을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-PersistingStateinYourReactAppwithRedux-Persist_0.png"},"coverImage":"/assets/img/2024-05-12-PersistingStateinYourReactAppwithRedux-Persist_0.png","tag":["Tech"],"readingTime":4}],"page":"79","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}