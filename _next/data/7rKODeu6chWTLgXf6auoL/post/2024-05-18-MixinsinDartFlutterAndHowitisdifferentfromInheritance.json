{"pageProps":{"post":{"title":"Dart Flutter에서의 믹스인 사용하기","description":"","date":"2024-05-18 22:20","slug":"2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance","content":"\n\n<img src=\"/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_0.png\" />\n\n안녕하세요!\n\n오늘은 믹스인에 대해 이야기해 보겠습니다. 한 가지 질문이 있는데요.\n\n믹스인이란 무엇인가요? 상속과 어떻게 다른가요? 상속과 어떤 점이 다른지 알고 계시면 섹션 2로 스크롤하셔서 믹스인을 구현하는 방법을 확인해보세요 :) 모르신다면 여기에서 자세히 설명해 드리겠습니다!\n\n<div class=\"content-ad\"></div>\n\n## 섹션 1: 정의부터 시작합시다\n\n맞죠? 대부분 mixins에 대해 검색할 때 가장 많이 볼 내용이죠. 대부분은 제처럼 상속과 혼동할 수도 있어요 :) . 그러니, mixins에 대해 시작하기 전에 is-a 관계(상속)와 has-a 관계(구성)에 대해 알아야 합니다.\n\n그러니 이 개념들에 대해 간단히 명확화해 볼까요? 이 이미지를 살펴보세요\n\n![이미지](/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_1.png)\n\n<div class=\"content-ad\"></div>\n\n무엇을 관찰하셨나요?\n\n첨부된 실시간 예제를 참고하면 다음과 같이 관찰할 수 있습니다.\n\n- 삼성은 모바일이에요.\n- 삼성은 카메라를 가지고 있고 블루투스도 가지고 있어요.\n\n자세한 통찰력을 얻기 위해 다음 정의를 확인해보세요.\n\n\n<div class=\"content-ad\"></div>\n\nis-a 관계: 두 클래스 간의 직접적인 관계로 정의될 수 있으며, 한 클래스(예: Class B)가 다른 클래스(예: Class A)의 하위 클래스인 경우입니다. 이를 상속이라고 합니다.\n\n---\n\nhas-a 관계: 한 클래스(예: Class A)가 다른 클래스(예: Class B)의 인스턴스를 멤버로 포함하는 관계로 정의될 수 있습니다. 이 관계를 통해 Class A가 Class B의 기능과 속성에 액세스할 수 있도록 해주므니다. 이런 관계를 합성이라고 합니다.\n\n마지막으로 이것이 프로그래밍적으로 어떻게 보이는지 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n*주의: 코멘트에 집중해주세요.*\n\n```js\n// 부모 클래스\nclass Mobile {\n}\n\n// 하위 클래스 또는 자식 클래스\n// 삼성이 Mobile을 확장한 is-a 관계의 예시\nclass Samsung extends Mobile {\n\n// has-a 관계의 예시\n Wifi wifi = Wifi();\n Camera camera = Camera();\n}\n```\n\n이제 is-a 및 has-a 관계에 대해 분명히 이해하셨기를 바랍니다.\n\n이제 이미 mixin의 정의를 읽으셨다면, 다시 한번 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n믹신을 사용하는 클래스들은 모든 속성과 기능을 상속받지만 서브클래스로 지칭할 수는 없어요.\n\n그 이유는 뭘까요???\n\n믹신은 클래스와 믹신이 제공하는 기능 사이에 \"has-a\" 관계와 비슷하지만 정확히는 그렇지 않은 관계를 설정합니다. 이는 믹신에 정의된 메서드와 속성에 접근할 수 있게 합니다.\n\n하지만, 차이점은 클래스 자체가 믹신의 인스턴스를 보유하지 않고 그냥 상속한다는 것입니다. 엄격한 계층 구조는 엄격한 부모-자식 관계의 계층 구조와 결합되어 있지 않으므로 그렇죠.\n\n<div class=\"content-ad\"></div>\n\n이 유연성을 통해 클래스들은 믹스인이 제공하는 기능을 직접적인 \"is-a relationship\" 없이 활용할 수 있습니다.\n\n이해했어요? 그렇지 않다면, 기다려 주세요 — Section 2에서 자세히 설명하겠습니다. 금방 이해하실 거예요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:996/1*ETWMK2xQnq54XonmQMumIw.gif)\n\n## Section 2 : 믹스인 구현\n\n<div class=\"content-ad\"></div>\n\n이제 Dart와 Flutter에서 이들을 어떻게 구현할 수 있는지 살펴봐요.\n\n1. 믹신 선언: 믹신은 믹신 키워드를 사용하여 선언하며 믹신의 이름이 뒤따릅니다. 믹신에는 메서드와 프로퍼티가 포함될 수 있어요.\n\n```dart\nmixin MixinLogger {\n\n void logMessage(String message) { \n   print(\"MESSAGE: $message\");\n }\n\n}\n```\n\n2. 믹신 사용: 클래스에서 믹신을 사용하려면 믹신의 이름이 따르는 with 키워드를 사용해요. 이를 통해 클래스는 믹신에서 정의된 기능을 상속받을 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass APIService with MixinLogger { \n\n  void getPosts() { \n    try { \n      final response = http.get('https://www.example.com/posts'); \n     } catch (Exception e) { \n        // mixin 메소드 호출\n        logMessage(e.toString()); \n     } \n    } \n\n  }\n```\n\n이제!\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*i7xIxer3Ijfhk9r7xR_USg.gif)\n\n```js\nvoid main(){\n  APIService apiService = APIService();\n\n  if(apiService.runtimeType is MixinLogger){\n    print(\"APIService는 MixinLogger 타입입니다.\");\n  }\n  else{\n    print(\"APIService는 MixinLogger 타입이 아닙니다.\");\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n무엇이 출력될까요?\n\n1 섹션을 모르거나 건너뛴 경우, 다시 살펴보세요.\n\n그래서 결과는 \"APIService is not off type MixinLogger\"가 될 것입니다.\n\n왜 그럴까요???? 같은 답변이지만 이번에는 이해하리라고 기대합니다.\n\n<div class=\"content-ad\"></div>\n\n믹신은 클래스와 믹신이 제공하는 기능 사이에 \"has-a\" 관계와 유사하지만 정확히 동일하지는 않는 관계를 수립합니다. 이를 통해 믹신에서 정의된 메서드와 속성에 액세스할 수 있습니다.\n\n그러나 차이점은 클래스 자체가 믹신의 인스턴스를 보유하지 않고 단순히 상속한다는 것입니다. 엄격한 계층 구조는 없습니다. 따라서 부모-자식 관계의 엄격한 계층 구조에 제한받지 않습니다.\n\n이 유연성을 통해 클래스는 믹신과 직접적인 \"is-a 관계\"를 형성하지 않고도 믹신이 제공하는 기능을 활용할 수 있습니다.\n\n이제 더 많은 기능을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*j5nDu39KHxe3669LfJKieg.gif)\n\n## 3. mixin에 있는 기능:\n\nmixin에서의 on 키워드:\n\n원하는 클래스의 하위 클래스에서만 사용되도록 mixin을 제한하려면 mixin 클래스를 on 키워드와 함께 선언해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식에 맞게 표 태그를 변경해주세요.\n\n\nmixin `mixinname` on `class_name_on_which_mixin_should_restricted`\n\n*주의: 주석에 집중*\n\n```js\nmixin MixinDiscount on Product{\n\n  performDiscountOperation(double price,double discount){\n     // perform discount operations\n    }\n\n}\n\n\nclass Product{\n\n}\n```\n\n여기서 Discount mixin은 제한되어서 Product 클래스 Type의 하위 클래스와 함께만 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\n// 컴파일 시간에 오류가 발생하여 텔레비전이 Product를 구현해야 함을 지정\nclass Television with MixinDiscount {\n\n}\n```\n\n```js\n// 규칙을 준수하므로 작동합니다.\nclass Television extends Product with MixinDiscount {\n\n  void doSomeOperation() {\n    // 이제 메서드를 직접 호출할 수 있습니다\n    performDiscountOperation(1000, 10);\n  }\n\n}\n```\n\n여러 mixin 상속:\n\n하나의 함수를 포함하는 MixinA 및 MixinB를 선언해봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nmixin MixinA{\n\n  void functionA(){\n    print(\"function A\");\n   }  \n\n}\n\nmixin MixinB{\n\n  void functionB(){\n    print(\"function B\");\n  }\n\n}\n```\n\n```dart\nclass Consumer with MixinA, MixinB{\n\n}\n\nvoid main(){\n  final consumer = Consumer();\n  //Now consumer can be able to use both functions from mixin A and B\n  consumer.functionA();\n  consumer.functionB();\n}\n```\n\n만약 여러 가지믹신이 동일한 함수 시그니처를 갖는다면?\n\nDart가 대비할 준비가 되어 있습니다 :)\n\n<div class=\"content-ad\"></div>\n\n```js\nmixin MixinA {\n  void foo() {\n    print('A.foo');\n  }\n}\n\nmixin MixinB {\n  void foo() {\n    print('B.foo');\n  }\n}\n```\n\n이제 믹신 A와 B를 사용하는 클래스 C를 정의해 봅시다:\n\n```js\nclass ClassC with MixinA, MixinB {\n  // 클래스 구현...\n}\n\nvoid main() {\n  final c = ClassC();\n  c.foo(); // 결과: B.foo\n}\n```\n\n이 상황에서 클래스 C는 믹신 A와 B에서 foo() 메서드를 모두 얻게 됩니다. 하지만 충돌이 있기 때문에 Dart는 어떤 것을 사용할지 결정해야 합니다. Dart는 마지막으로 사용된 믹신인 B의 foo() 메서드를 선택합니다. 따라서 클래스 C의 인스턴스를 만들고 foo()를 호출하면 mixin B의 함수가 호출됩니다.```\n\n<div class=\"content-ad\"></div>\n\n여러 상속을 지원하는 프로그래밍 언어는 다이아몬드 문제로 알려진 이러한 시나리오에 대한 복잡성을 가지고 있습니다. 그런데 Dart에는 쉽죠? :)\n\n지금까지입니다.\n\n읽어 주셔서 감사합니다 !!!\n\n![image](https://miro.medium.com/v2/resize:fit:1280/1*R6bQiuW46ycpDFAI2tSUcw.gif)\n\n<div class=\"content-ad\"></div>\n\n내 첫 블로그 포스팅이에요! 도움이 되었으면 좋겣아요 :)\n\n이브라힘 사이드.","ogImage":{"url":"/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_0.png"},"coverImage":"/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    hr: \"hr\",\n    em: \"em\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안녕하세요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오늘은 믹스인에 대해 이야기해 보겠습니다. 한 가지 질문이 있는데요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"믹스인이란 무엇인가요? 상속과 어떻게 다른가요? 상속과 어떤 점이 다른지 알고 계시면 섹션 2로 스크롤하셔서 믹스인을 구현하는 방법을 확인해보세요 :) 모르신다면 여기에서 자세히 설명해 드리겠습니다!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"섹션 1: 정의부터 시작합시다\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"맞죠? 대부분 mixins에 대해 검색할 때 가장 많이 볼 내용이죠. 대부분은 제처럼 상속과 혼동할 수도 있어요 :) . 그러니, mixins에 대해 시작하기 전에 is-a 관계(상속)와 has-a 관계(구성)에 대해 알아야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러니 이 개념들에 대해 간단히 명확화해 볼까요? 이 이미지를 살펴보세요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"무엇을 관찰하셨나요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첨부된 실시간 예제를 참고하면 다음과 같이 관찰할 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"삼성은 모바일이에요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"삼성은 카메라를 가지고 있고 블루투스도 가지고 있어요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자세한 통찰력을 얻기 위해 다음 정의를 확인해보세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"is-a 관계: 두 클래스 간의 직접적인 관계로 정의될 수 있으며, 한 클래스(예: Class B)가 다른 클래스(예: Class A)의 하위 클래스인 경우입니다. 이를 상속이라고 합니다.\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"has-a 관계: 한 클래스(예: Class A)가 다른 클래스(예: Class B)의 인스턴스를 멤버로 포함하는 관계로 정의될 수 있습니다. 이 관계를 통해 Class A가 Class B의 기능과 속성에 액세스할 수 있도록 해주므니다. 이런 관계를 합성이라고 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로 이것이 프로그래밍적으로 어떻게 보이는지 살펴봅시다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.em, {\n        children: \"주의: 코멘트에 집중해주세요.\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 부모 클래스\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Mobile\"\n        }), \" {\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 하위 클래스 또는 자식 클래스\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 삼성이 Mobile을 확장한 is-a 관계의 예시\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Samsung\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_ inherited__\",\n          children: \"Mobile\"\n        }), \" {\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// has-a 관계의 예시\"\n        }), \"\\n \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Wifi\"\n        }), \" wifi = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Wifi\"\n        }), \"();\\n \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Camera\"\n        }), \" camera = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Camera\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 is-a 및 has-a 관계에 대해 분명히 이해하셨기를 바랍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 이미 mixin의 정의를 읽으셨다면, 다시 한번 읽어보세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"믹신을 사용하는 클래스들은 모든 속성과 기능을 상속받지만 서브클래스로 지칭할 수는 없어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그 이유는 뭘까요???\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"믹신은 클래스와 믹신이 제공하는 기능 사이에 \\\"has-a\\\" 관계와 비슷하지만 정확히는 그렇지 않은 관계를 설정합니다. 이는 믹신에 정의된 메서드와 속성에 접근할 수 있게 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만, 차이점은 클래스 자체가 믹신의 인스턴스를 보유하지 않고 그냥 상속한다는 것입니다. 엄격한 계층 구조는 엄격한 부모-자식 관계의 계층 구조와 결합되어 있지 않으므로 그렇죠.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 유연성을 통해 클래스들은 믹스인이 제공하는 기능을 직접적인 \\\"is-a relationship\\\" 없이 활용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이해했어요? 그렇지 않다면, 기다려 주세요 — Section 2에서 자세히 설명하겠습니다. 금방 이해하실 거예요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:996/1*ETWMK2xQnq54XonmQMumIw.gif\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Section 2 : 믹스인 구현\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 Dart와 Flutter에서 이들을 어떻게 구현할 수 있는지 살펴봐요.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"믹신 선언: 믹신은 믹신 키워드를 사용하여 선언하며 믹신의 이름이 뒤따릅니다. 믹신에는 메서드와 프로퍼티가 포함될 수 있어요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-dart\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mixin\"\n        }), \" MixinLogger {\\n\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" logMessage(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"String\"\n        }), \" message) { \\n   \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"MESSAGE: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"$message\"\n          }), \"\\\"\"]\n        }), \");\\n }\\n\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"믹신 사용: 클래스에서 믹신을 사용하려면 믹신의 이름이 따르는 with 키워드를 사용해요. 이를 통해 클래스는 믹신에서 정의된 기능을 상속받을 수 있어요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"APIService\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MixinLogger\"\n        }), \" { \\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getPosts\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") { \\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" { \\n      final response = http.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'https://www.example.com/posts'\"\n        }), \"); \\n     } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Exception\"\n        }), \" e) { \\n        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// mixin 메소드 호출\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"logMessage\"\n        }), \"(e.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toString\"\n        }), \"()); \\n     } \\n    } \\n\\n  }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:996/1*i7xIxer3Ijfhk9r7xR_USg.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \"){\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"APIService\"\n        }), \" apiService = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"APIService\"\n        }), \"();\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \"(apiService.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"runtimeType\"\n        }), \" is \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MixinLogger\"\n        }), \"){\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"APIService는 MixinLogger 타입입니다.\\\"\"\n        }), \");\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \"{\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"APIService는 MixinLogger 타입이 아닙니다.\\\"\"\n        }), \");\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"무엇이 출력될까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"1 섹션을 모르거나 건너뛴 경우, 다시 살펴보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 결과는 \\\"APIService is not off type MixinLogger\\\"가 될 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"왜 그럴까요???? 같은 답변이지만 이번에는 이해하리라고 기대합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"믹신은 클래스와 믹신이 제공하는 기능 사이에 \\\"has-a\\\" 관계와 유사하지만 정확히 동일하지는 않는 관계를 수립합니다. 이를 통해 믹신에서 정의된 메서드와 속성에 액세스할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 차이점은 클래스 자체가 믹신의 인스턴스를 보유하지 않고 단순히 상속한다는 것입니다. 엄격한 계층 구조는 없습니다. 따라서 부모-자식 관계의 엄격한 계층 구조에 제한받지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 유연성을 통해 클래스는 믹신과 직접적인 \\\"is-a 관계\\\"를 형성하지 않고도 믹신이 제공하는 기능을 활용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 더 많은 기능을 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:996/1*j5nDu39KHxe3669LfJKieg.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. mixin에 있는 기능:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"mixin에서의 on 키워드:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원하는 클래스의 하위 클래스에서만 사용되도록 mixin을 제한하려면 mixin 클래스를 on 키워드와 함께 선언해야 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Markdown 형식에 맞게 표 태그를 변경해주세요.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"mixin \", _jsx(_components.code, {\n        children: \"mixinname\"\n      }), \" on \", _jsx(_components.code, {\n        children: \"class_name_on_which_mixin_should_restricted\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.em, {\n        children: \"주의: 주석에 집중\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"mixin \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MixinDiscount\"\n        }), \" on \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \"{\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"performDiscountOperation\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"double price,double discount\"\n        }), \"){\\n     \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// perform discount operations\"\n        }), \"\\n    }\\n\\n}\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \"{\\n\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 Discount mixin은 제한되어서 Product 클래스 Type의 하위 클래스와 함께만 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 컴파일 시간에 오류가 발생하여 텔레비전이 Product를 구현해야 함을 지정\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Television\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MixinDiscount\"\n        }), \" {\\n\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 규칙을 준수하므로 작동합니다.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Television\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_ inherited__\",\n          children: \"Product\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MixinDiscount\"\n        }), \" {\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"doSomeOperation\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 이제 메서드를 직접 호출할 수 있습니다\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"performDiscountOperation\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \");\\n  }\\n\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여러 mixin 상속:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하나의 함수를 포함하는 MixinA 및 MixinB를 선언해봅시다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-dart\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mixin\"\n        }), \" MixinA{\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" functionA(){\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"function A\\\"\"\n        }), \");\\n   }  \\n\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mixin\"\n        }), \" MixinB{\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" functionB(){\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"function B\\\"\"\n        }), \");\\n  }\\n\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-dart\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-class\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"Consumer\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"with\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"MixinA\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"MixinB\"\n          })]\n        }), \"{\\n\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" main(){\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"final\"\n        }), \" consumer = Consumer();\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//Now consumer can be able to use both functions from mixin A and B\"\n        }), \"\\n  consumer.functionA();\\n  consumer.functionB();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 여러 가지믹신이 동일한 함수 시그니처를 갖는다면?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Dart가 대비할 준비가 되어 있습니다 :)\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"mixin \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MixinA\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"foo\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'A.foo'\"\n        }), \");\\n  }\\n}\\n\\nmixin \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MixinB\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"foo\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'B.foo'\"\n        }), \");\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 믹신 A와 B를 사용하는 클래스 C를 정의해 봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ClassC\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MixinA\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MixinB\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 클래스 구현...\"\n        }), \"\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  final c = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ClassC\"\n        }), \"();\\n  c.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"foo\"\n        }), \"(); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과: B.foo\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 상황에서 클래스 C는 믹신 A와 B에서 foo() 메서드를 모두 얻게 됩니다. 하지만 충돌이 있기 때문에 Dart는 어떤 것을 사용할지 결정해야 합니다. Dart는 마지막으로 사용된 믹신인 B의 foo() 메서드를 선택합니다. 따라서 클래스 C의 인스턴스를 만들고 foo()를 호출하면 mixin B의 함수가 호출됩니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여러 상속을 지원하는 프로그래밍 언어는 다이아몬드 문제로 알려진 이러한 시나리오에 대한 복잡성을 가지고 있습니다. 그런데 Dart에는 쉽죠? :)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"읽어 주셔서 감사합니다 !!!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1280/1*R6bQiuW46ycpDFAI2tSUcw.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"내 첫 블로그 포스팅이에요! 도움이 되었으면 좋겣아요 :)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이브라힘 사이드.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}