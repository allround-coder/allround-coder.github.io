{"pageProps":{"post":{"title":"리액트에서 환경 변수 사용하기","description":"","date":"2024-05-12 20:41","slug":"2024-05-12-UsingenvironmentvariablesinReact","content":"\n\n서버 측 프로그래밍 배경이 없으면 환경 변수는 마법 같은 존재일 수 있어요. 이 지식 부족 때문에 로컬 환경에서 할 일 앱을 만든 뒤, 처음으로 프로덕션 빌드를 만들려고 하면 갑자기 좌절감이 밀릴 수 있어요.\n\n업데이트: 만약 자체 도구에서 환경 변수를 사용하는 방법이나 React에서 환경 변수가 작동하는 것에 대해 자세히 알고 싶다면, 이 멋진 시에 계속 읽어보세요. 하지만 단숨에 문제를 해결하고 있다면, Create React App 같은 기본 설정을 사용 중이라면 여기서 문서를 확인하세요. NextJS 사용자는 여기서 문서를 확인하세요.\n\n## 우리가 해결하고 있는 문제:\n\n## 간단히 말해서: 환경 변수\n\n\n\n리액트를 다룰 때 환경 변수는 글로벌 process.env 객체를 통해 사용할 수 있는 변수들입니다. 이 글로벌 객체는 Node.js를 통해 환경에서 제공됩니다. 그리고 브라우저에는 Node.js가 없기 때문에 webpack이 필요합니다.\n\n## 실제로 환경 변수를 설정하고 사용하는 방법\n\n리액트 프로젝트에서 webpack을 사용하여 환경 변수를 설정하고 사용하는 두 가지 방법을 보여드리겠습니다: npm 스크립트를 사용하는 방법과 .env 파일을 사용하는 방법입니다. 여기서는 당신이 리액트 설정에 대해 숙지하고 있다고 가정하겠습니다.\n\n## 방법 1: npm 스크립트를 사용하여 환경 변수 설정하기\n\n\n\n먼저 npm을 통해 webpack과 webpack-cli를 설치해보세요: $ npm install --save-dev webpack webpack-cli.\n\npackage.json 파일로 이동해서 scripts 키를 확인하고 webpack을 실행하는 명령어를 찾아보세요. 아마도 다음과 유사한 것을 찾을 수 있을 겁니다:\n\n이제 스크립트에 --env 플래그와 함께 환경 변수를 추가해봅시다.\n\n우리는 두 스크립트 모두에 --env.API_URL= 부분을 추가했습니다. 이제 npm run dev 명령어를 실행하고 React 컴포넌트로 이동하여 process.env.API_URL을 사용해보세요:\n\n\n\n```js\nconst App = () => <h1>{process.env.API_URL}</h1>;\n```\n\n그리고.. 제가 프로젝트를 망가뜨렸습니다. 죄송해요.\n\n— 그 이유는 프론트엔드 코드에서 환경 변수를 사용할 때 실제로는 코드를 컴파일할 때 대체될 자리 표시자로 작동한다는 것이다. 문제는, 웹팩에게 이러한 변수들을 실제 값으로 컴파일하도록 지시하지 않았다는 것이다. 웹팩 설정 파일에서 DefinePlugin 웹팩 플러그인을 사용하여 이를 처리해보자:\n\n귀하는 값들을 좋은 객체로 줄여서 수동으로 정의할 필요가 없도록 할 수도 있습니다:```\n\n\n\n지금 명령을 실행하면 모든 것이 컴파일되고 process.env.API_URL이 환경 변수에 따라 올바른 URL로 컴파일됩니다.\n\n축하해요! 그런데, 기다려봐요!\n\n## 방법 2: .env 파일을 사용하여 환경 변수 설정하기\n\n여기서의 전체 아이디어는 환경 변수로 채워진 파일(단순히 .env라고 불리는)을 생성하는 것입니다.\n\n\n\n지역 데이터베이스 비밀번호가 인터넷 계정 모두에 동일한 비밀번호라는 것을 알지 못하도록하기 위해, .env 파일을 .gitignore에 추가하는 것을 권장합니다.\n\n당신의 프론트엔드 코드는 두 환경 (개발/프로덕션)에서 동일한 환경 변수 (process.env.API_URL)를 참조할 것이지만, .env 파일에서 서로 다른 값을 정의했기 때문에 컴파일된 값은 다를 것입니다.\n\n## .env 파일 만들기\n\n이 파일은 프로젝트의 루트에 있어야 하며 .env로 부릅니다. 변수를 추가해 봅시다:\n\n\n\n```js\nAPI_URL=http://localhost:8000\n```\n\n여기까지가요! 네, 그게 다예요..\n\n## .env 파일 다루기\n\n이제 파일과 그 내용을 실제로 다룰 방법이 필요해요. 우리는 이를 위해 널리 사용되는 npm 패키지인 dotenv를 사용할 거에요. Dotenv는 일반적으로 사용됩니다 (create-react-app에서 사용하니까요) 그리고 .env 파일에서 변수를 가져와 글로벌 process.env에 추가할 거에요.\n\n\n\n$ npm install --save-dev dotenv\n\n## React 프로젝트에 변수 추가하기\n\n와, 그거 정말 멋지네요. 그런데 하나 문제가 있어요. Dotenv은 서버 쪽에서만 작동해요. 우리는 백엔드 작업을 하고 있지 않아요.\n\n우리는 클라이언트 쪽을 개발하고 있어요. Dotenv는 실제로 변수를 저장할 환경이 필요해요. 웹팩이 그 역할을 해줄 거에요!\n\n\n\n전체 webpackDefinePlugin 관련 내용이 이전에 정말 잘 작동했으므로 우리 webpack 구성에서 다시 사용해 봅시다:\n\ndotenv에 .config()를 호출하면 .env 파일에 설정된 환경 변수가 모두 parsed라는 키 아래 있는 Object로 반환됩니다. 이제 React 코드를 확인해 봅시다:\n\n```js\nconst App = () => <h1>{process.env.API_URL}</h1>;\n```\n\n와우, 정말 잘 작동하네요! .env 파일에서 정의한 API_URL 환경 변수의 값을 보여줍니다.\n\n\n\n한 가지 문제가 있어요: 우리는 여전히 프로덕션과 개발 환경에 대해 다른 API_URL 값을 정의해야 합니다.\n\n## 다른 환경을 위한 다른 환경 변수\n\n전체 아이디어는 다른 환경을 위해 다른 .env 파일을 만들고 webpack이 활성화된 환경에 따라 올바른 .env 파일을 선택하게 하는 것입니다. 그래서 프로젝트의 루트에 두 개의 파일을 생성하세요:\n\n- .env (프로덕션을 위한 모든 환경 변수 포함)\n- .env.development (개발을 위한 모든 환경 변수 포함)\n\n\n\n잘 이해하신다는 것이 명확하게 전하고 싶네요: 환경 이름을 .env 파일 이름 뒤에 붙이는 겁니다. 보통은 프로덕션 빌드에 원래 .env 파일을 사용하는 것이 관례이기 때문에 해당 파일에는 접미사를 붙이지 않을 겁니다.\n\n## NPM 스크립트를 사용하여 활성 환경 설정하기\n\n패키지.json에서 현재 환경을 설정하기 위해 NPM 스크립트(메소드 1에서 한 것처럼)를 사용할 거에요:\n\n패키지.json에서 환경을 정의했기 때문에 이제 웹팩 설정에서 해당 환경을 사용할 수 있어요!\n\n\n\n다음 단계는 웹팩 구성으로 이동하여 활성 환경에 속한 .env 파일을 사용하도록 설정하는 것입니다. 이전과 마찬가지로 dotenv을 사용하지만 이제는 매개변수에 사용자 정의 경로를 지정합니다.\n\n지금까지 하는 일은 여기까지입니다. 그러나 package.json에서 환경을 설정하고 프로젝트 루트에 해당하는 .env 파일을 생성한다면 더 많은 환경을 위해 .env 파일을 더 만들 수 있습니다(.env.staging 예를 들어)!\n\n마지막 부분은 이해하기 어려울 수 있으니 한 줄씩 차근차근 읽어보시고 궁금한 점이 있으면 아래에 댓글을 달거나 트위터에서 연락해주세요.\n\n이제 마무리 지었습니다! 해냈어요!\n\n\n\n수고하셨어요.\n\nXOXO.","ogImage":{"url":"/assets/img/2024-05-12-UsingenvironmentvariablesinReact_0.png"},"coverImage":"/assets/img/2024-05-12-UsingenvironmentvariablesinReact_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"서버 측 프로그래밍 배경이 없으면 환경 변수는 마법 같은 존재일 수 있어요. 이 지식 부족 때문에 로컬 환경에서 할 일 앱을 만든 뒤, 처음으로 프로덕션 빌드를 만들려고 하면 갑자기 좌절감이 밀릴 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"업데이트: 만약 자체 도구에서 환경 변수를 사용하는 방법이나 React에서 환경 변수가 작동하는 것에 대해 자세히 알고 싶다면, 이 멋진 시에 계속 읽어보세요. 하지만 단숨에 문제를 해결하고 있다면, Create React App 같은 기본 설정을 사용 중이라면 여기서 문서를 확인하세요. NextJS 사용자는 여기서 문서를 확인하세요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"우리가 해결하고 있는 문제:\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"간단히 말해서: 환경 변수\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트를 다룰 때 환경 변수는 글로벌 process.env 객체를 통해 사용할 수 있는 변수들입니다. 이 글로벌 객체는 Node.js를 통해 환경에서 제공됩니다. 그리고 브라우저에는 Node.js가 없기 때문에 webpack이 필요합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"실제로 환경 변수를 설정하고 사용하는 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트 프로젝트에서 webpack을 사용하여 환경 변수를 설정하고 사용하는 두 가지 방법을 보여드리겠습니다: npm 스크립트를 사용하는 방법과 .env 파일을 사용하는 방법입니다. 여기서는 당신이 리액트 설정에 대해 숙지하고 있다고 가정하겠습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"방법 1: npm 스크립트를 사용하여 환경 변수 설정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 npm을 통해 webpack과 webpack-cli를 설치해보세요: $ npm install --save-dev webpack webpack-cli.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json 파일로 이동해서 scripts 키를 확인하고 webpack을 실행하는 명령어를 찾아보세요. 아마도 다음과 유사한 것을 찾을 수 있을 겁니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 스크립트에 --env 플래그와 함께 환경 변수를 추가해봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 두 스크립트 모두에 --env.API_URL= 부분을 추가했습니다. 이제 npm run dev 명령어를 실행하고 React 컴포넌트로 이동하여 process.env.API_URL을 사용해보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"App\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") => \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \">\"]\n          }), \"{process.env.API_URL}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \">\"]\n          })]\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고.. 제가 프로젝트를 망가뜨렸습니다. 죄송해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"— 그 이유는 프론트엔드 코드에서 환경 변수를 사용할 때 실제로는 코드를 컴파일할 때 대체될 자리 표시자로 작동한다는 것이다. 문제는, 웹팩에게 이러한 변수들을 실제 값으로 컴파일하도록 지시하지 않았다는 것이다. 웹팩 설정 파일에서 DefinePlugin 웹팩 플러그인을 사용하여 이를 처리해보자:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"귀하는 값들을 좋은 객체로 줄여서 수동으로 정의할 필요가 없도록 할 수도 있습니다:```\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금 명령을 실행하면 모든 것이 컴파일되고 process.env.API_URL이 환경 변수에 따라 올바른 URL로 컴파일됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"축하해요! 그런데, 기다려봐요!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"방법 2: .env 파일을 사용하여 환경 변수 설정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서의 전체 아이디어는 환경 변수로 채워진 파일(단순히 .env라고 불리는)을 생성하는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지역 데이터베이스 비밀번호가 인터넷 계정 모두에 동일한 비밀번호라는 것을 알지 못하도록하기 위해, .env 파일을 .gitignore에 추가하는 것을 권장합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"당신의 프론트엔드 코드는 두 환경 (개발/프로덕션)에서 동일한 환경 변수 (process.env.API_URL)를 참조할 것이지만, .env 파일에서 서로 다른 값을 정의했기 때문에 컴파일된 값은 다를 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \".env 파일 만들기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 파일은 프로젝트의 루트에 있어야 하며 .env로 부릅니다. 변수를 추가해 봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"API_URL\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"http\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//localhost:8000\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기까지가요! 네, 그게 다예요..\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \".env 파일 다루기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 파일과 그 내용을 실제로 다룰 방법이 필요해요. 우리는 이를 위해 널리 사용되는 npm 패키지인 dotenv를 사용할 거에요. Dotenv는 일반적으로 사용됩니다 (create-react-app에서 사용하니까요) 그리고 .env 파일에서 변수를 가져와 글로벌 process.env에 추가할 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"$ npm install --save-dev dotenv\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"React 프로젝트에 변수 추가하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"와, 그거 정말 멋지네요. 그런데 하나 문제가 있어요. Dotenv은 서버 쪽에서만 작동해요. 우리는 백엔드 작업을 하고 있지 않아요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 클라이언트 쪽을 개발하고 있어요. Dotenv는 실제로 변수를 저장할 환경이 필요해요. 웹팩이 그 역할을 해줄 거에요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"전체 webpackDefinePlugin 관련 내용이 이전에 정말 잘 작동했으므로 우리 webpack 구성에서 다시 사용해 봅시다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"dotenv에 .config()를 호출하면 .env 파일에 설정된 환경 변수가 모두 parsed라는 키 아래 있는 Object로 반환됩니다. 이제 React 코드를 확인해 봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"App\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") => \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \">\"]\n          }), \"{process.env.API_URL}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \">\"]\n          })]\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"와우, 정말 잘 작동하네요! .env 파일에서 정의한 API_URL 환경 변수의 값을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한 가지 문제가 있어요: 우리는 여전히 프로덕션과 개발 환경에 대해 다른 API_URL 값을 정의해야 합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"다른 환경을 위한 다른 환경 변수\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"전체 아이디어는 다른 환경을 위해 다른 .env 파일을 만들고 webpack이 활성화된 환경에 따라 올바른 .env 파일을 선택하게 하는 것입니다. 그래서 프로젝트의 루트에 두 개의 파일을 생성하세요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \".env (프로덕션을 위한 모든 환경 변수 포함)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \".env.development (개발을 위한 모든 환경 변수 포함)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"잘 이해하신다는 것이 명확하게 전하고 싶네요: 환경 이름을 .env 파일 이름 뒤에 붙이는 겁니다. 보통은 프로덕션 빌드에 원래 .env 파일을 사용하는 것이 관례이기 때문에 해당 파일에는 접미사를 붙이지 않을 겁니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"NPM 스크립트를 사용하여 활성 환경 설정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"패키지.json에서 현재 환경을 설정하기 위해 NPM 스크립트(메소드 1에서 한 것처럼)를 사용할 거에요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"패키지.json에서 환경을 정의했기 때문에 이제 웹팩 설정에서 해당 환경을 사용할 수 있어요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 단계는 웹팩 구성으로 이동하여 활성 환경에 속한 .env 파일을 사용하도록 설정하는 것입니다. 이전과 마찬가지로 dotenv을 사용하지만 이제는 매개변수에 사용자 정의 경로를 지정합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지 하는 일은 여기까지입니다. 그러나 package.json에서 환경을 설정하고 프로젝트 루트에 해당하는 .env 파일을 생성한다면 더 많은 환경을 위해 .env 파일을 더 만들 수 있습니다(.env.staging 예를 들어)!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막 부분은 이해하기 어려울 수 있으니 한 줄씩 차근차근 읽어보시고 궁금한 점이 있으면 아래에 댓글을 달거나 트위터에서 연락해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 마무리 지었습니다! 해냈어요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수고하셨어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"XOXO.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}