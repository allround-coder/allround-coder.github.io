{"pageProps":{"post":{"title":"자바스크립트의 기본 타입과 참조 타입 이해하기","description":"","date":"2024-05-17 20:25","slug":"2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript","content":"\n\nJavaScript을 다룰 때, 원시(primitive) 타입과 참조(reference) 타입의 차이를 알고 데이터가 가변(mutable)인지 불변(immutable)인지 이해하는 것이 매우 중요합니다. 간단한 용어로 설명해보겠습니다.\n\n원시 타입\n원시 타입은 자신의 값을 직접 저장하는 기본 데이터 유형입니다. 이에는 다음이 포함됩니다:\n\n```js\n- Number: 1, 2.5, 100과 같은 숫자\n- String: \"hello\", \"123\"과 같은 문자열\n- Boolean: true 또는 false\n- Null: 어떠한 객체 값도 의도적으로 없음을 나타내는 특별한 값\n- Undefined: 할당된 값이 없는 변수를 나타냄\n```\n\n변수에 원시 값을 할당할 때, 값을 복사합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n```js\nlet x = 10;\nlet y = x;\ny = 20;\nconsole.log(x); // 10\nconsole.log(y); // 20\n```\n\n참조형 타입\n객체(Object)와 배열(Array)과 같은 참조형 타입은 데이터가 메모리에 어디에 저장되어 있는지를 가리키는 참조(또는 주소)를 저장합니다.\n\n```js\nlet obj1 = { name: \"Ali\" };\nlet obj2 = obj1;\nobj2.name = \"Reza\";\nconsole.log(obj1.name); // \"Reza\"\nconsole.log(obj2.name); // \"Reza\"\n```\n\n<div class=\"content-ad\"></div>\n\n가변이란 무엇을 의미합니까?\n가변이란 데이터가 생성된 후에 변경될 수 있다는 것을 의미합니다. JavaScript의 객체, 배열 및 함수는 가변입니다.\n\n```js\nlet person = { name: \"Ali\", age: 25 };\nperson.name = \"Reza\";\nconsole.log(person); // { name: \"Reza\", age: 25 }\n// 배열을 사용한 예시:\n\nlet numbers = [1, 2, 3];\nnumbers.push(4);\nconsole.log(numbers); // [1, 2, 3, 4]\n```\n\n불변이란 무엇을 의미합니까?\n불변이란 데이터가 생성된 후에는 변경할 수 없다는 것을 의미합니다. 숫자, 문자열 및 불리언과 같은 기본 유형은 불변입니다.\n\n문자열을 사용한 예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nlet greeting = \"Hello\";\nlet newGreeting = greeting.replace(\"H\", \"J\");\nconsole.log(greeting); // \"Hello\"\nconsole.log(newGreeting); // \"Jello\"\n```\n\n왜 중요한가요?\n- 메모리 관리: 가변 데이터는 변경이 원본 데이터에 직접적으로 반영되기 때문에 메모리 사용을 최적화하는 데 도움이 됩니다.\n\n실용적인 팁:\n객체나 배열을 다룰 때, 하나의 변수를 변경하면 다른 변수에도 같은 데이터를 참조하고 있다면 영향을 줄 수 있습니다. 이를 피하기 위해 깊은 복사(deep copy)를 사용할 수 있습니다.\n\n```js\n#### 객체의 깊은 복사:\n```javascript\nlet original = { name: \"Ali\", age: 25 };\nlet copy = JSON.parse(JSON.stringify(original));\ncopy.name = \"Reza\";\nconsole.log(original); // { name: \"Ali\", age: 25 }\nconsole.log(copy); // { name: \"Reza\", age: 25 }\n```\n\n<div class=\"content-ad\"></div>\n\n깊은 복사를 통해 원본 객체의 완전히 독립적인 복사본을 생성하므로 복사본을 변경해도 원본에는 영향을 미치지 않습니다.\n\n---\n\n이 개념을 이해하면 더 나은 코드를 작성하고 잠재적인 문제를 피할 수 있습니다. 이에 대해 어떻게 생각하시나요? 생각과 경험을 공유해 주세요!","ogImage":{"url":"/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png","tag":["Tech"],"readingTime":2},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\",\n    hr: \"hr\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"JavaScript을 다룰 때, 원시(primitive) 타입과 참조(reference) 타입의 차이를 알고 데이터가 가변(mutable)인지 불변(immutable)인지 이해하는 것이 매우 중요합니다. 간단한 용어로 설명해보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원시 타입\\n원시 타입은 자신의 값을 직접 저장하는 기본 데이터 유형입니다. 이에는 다음이 포함됩니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"- \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Number\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2.5\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \"과 같은 숫자\\n- \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"hello\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"123\\\"\"\n        }), \"과 같은 문자열\\n- \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Boolean\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" 또는 \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n- \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Null\"\n        }), \": 어떠한 객체 값도 의도적으로 없음을 나타내는 특별한 값\\n- \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Undefined\"\n        }), \": 할당된 값이 없는 변수를 나타냄\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"변수에 원시 값을 할당할 때, 값을 복사합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" x = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" y = x;\\ny = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"20\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(x); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 10\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(y); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 20\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"참조형 타입\\n객체(Object)와 배열(Array)과 같은 참조형 타입은 데이터가 메모리에 어디에 저장되어 있는지를 가리키는 참조(또는 주소)를 저장합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" obj1 = { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ali\\\"\"\n        }), \" };\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" obj2 = obj1;\\nobj2.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"name\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Reza\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(obj1.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"name\"\n        }), \"); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"Reza\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(obj2.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"name\"\n        }), \"); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"Reza\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가변이란 무엇을 의미합니까?\\n가변이란 데이터가 생성된 후에 변경될 수 있다는 것을 의미합니다. JavaScript의 객체, 배열 및 함수는 가변입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" person = { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ali\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"25\"\n        }), \" };\\nperson.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"name\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Reza\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(person); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// { name: \\\"Reza\\\", age: 25 }\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 배열을 사용한 예시:\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" numbers = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"];\\nnumbers.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"push\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(numbers); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [1, 2, 3, 4]\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"불변이란 무엇을 의미합니까?\\n불변이란 데이터가 생성된 후에는 변경할 수 없다는 것을 의미합니다. 숫자, 문자열 및 불리언과 같은 기본 유형은 불변입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"문자열을 사용한 예시:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" greeting = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" newGreeting = greeting.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"replace\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"H\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"J\\\"\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(greeting); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"Hello\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(newGreeting); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"Jello\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"왜 중요한가요?\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"메모리 관리: 가변 데이터는 변경이 원본 데이터에 직접적으로 반영되기 때문에 메모리 사용을 최적화하는 데 도움이 됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실용적인 팁:\\n객체나 배열을 다룰 때, 하나의 변수를 변경하면 다른 변수에도 같은 데이터를 참조하고 있다면 영향을 줄 수 있습니다. 이를 피하기 위해 깊은 복사(deep copy)를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"#### 객체의 깊은 복사:\\n\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"``\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"`javascript\\nlet original = { name: \\\"Ali\\\", age: 25 };\\nlet copy = JSON.parse(JSON.stringify(original));\\ncopy.name = \\\"Reza\\\";\\nconsole.log(original); // { name: \\\"Ali\\\", age: 25 }\\nconsole.log(copy); // { name: \\\"Reza\\\", age: 25 }\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"깊은 복사를 통해 원본 객체의 완전히 독립적인 복사본을 생성하므로 복사본을 변경해도 원본에는 영향을 미치지 않습니다.\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"이 개념을 이해하면 더 나은 코드를 작성하고 잠재적인 문제를 피할 수 있습니다. 이에 대해 어떻게 생각하시나요? 생각과 경험을 공유해 주세요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}