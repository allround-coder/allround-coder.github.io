{"pageProps":{"post":{"title":"CodeLlama vs CodeGemma, AI 코딩 어시스턴스에 오픈 모델 활용하기","description":"","date":"2024-05-17 20:44","slug":"2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance","content":"\n\n<img src=\"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_0.png\" />\n\nAI 코딩 도구 시장은 수십억 달러의 산업입니다. 2030년까지 172억 달러에 이를 것으로 예상되며, 현재에도 VS Code 또는 JetBrains IDE용 AI 플러그인은 수백만 번 다운로드되었습니다. 하지만 무료 코딩 도우미로 로컬 모델을 실행할 수 있을까요? 그리고 그 성능은 어떨까요? 이 기사에서는 두 개의 오픈 모델, Code Gemma와 Code Llama를 테스트해 보겠습니다. 제 PC에 설치하고, 그들이 어떻게 작동하는지 확인할 것입니다.\n\n더 이상의 말이 필요 없으니, 시작해 봅시다!\n\n## 1. 모델들\n\n<div class=\"content-ad\"></div>\n\n본문 작성 시점에서 코딩 목적으로 두 가지 주요 오픈 모델이 무료로 다운로드할 수 있으며 사용할 수 있습니다:\n\n- CodeLlama. 이 모델은 2023년 Meta에서 출시되었으며, 7B, 13B, 34B, 70B 크기로 제공됩니다. \"Base\", \"Instruct\", \"Python\" 모델을 사용할 수 있습니다. 4가지 크기이지만, 로컬에서 실제로 사용할 수 있는 것은 7B 및 13B 모델뿐입니다; 다른 크기는 너무 \"무겁습니다.\"\n- CodeGemma. 이 모델은 2024년 Google에서 출시되었으며, 2B 및 7B 크기로 제공됩니다. 2B 모델은 코드 완성을 위해 훈련되었으며, 7B 모델은 코드 채움 및 자연어 프롬프트를 위해 훈련되었습니다.\n\n본문에서는 HuggingFace에서 제공되며 GGUF 형식으로 다운로드할 수 있는 7B 및 13B 모델을 테스트할 것이며, 이를 사용하여 다양한 앱에서 이 모델들을 사용할 수 있도록 OpenAI 호환 로컬 서버를 실행할 것입니다. 그러나 이를 수행하기 전에 단순히 모델을 Python으로 실행하여 무엇을 할 수 있는지 살펴보겠습니다. 실제 사용으로 넘어가고 싶은 독자분들은 이 부분을 건너뛸 수 있습니다.\n\n두 모델을 테스트하기 위해 Google Colab 인스턴스를 무료로 사용할 것입니다. 먼저, 모델과 토크나이저를 로드해보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig\nimport transformers\nimport torch\n\n\nmodel_id = \"...\"\nbnb_config = BitsAndBytesConfig(\n    load_in_4bit=True,\n    bnb_4bit_quant_type=\"nf4\",\n    bnb_4bit_use_double_quant=False,\n)\n\ntokenizer = AutoTokenizer.from_pretrained(model_id)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_id,\n    quantization_config=bnb_config,\n    device_map=\"cuda\",\n    torch_dtype=torch.bfloat16,\n)\n```\n\nHuggingFace의 Transformers 라이브러리는 모델 파일을 자동으로 다운로드해줍니다. 7B 모델은 약 16.2 GB의 GPU RAM을 필요로 하지만, bits and bytes 라이브러리를 활용하여 4비트 해상도로 모델을 실행하면 필요한 메모리 용량은 약 5GB 정도로 줄어듭니다.\n\n이제 모델을 테스트하기 위한 코드 조각을 만들어 봅시다. 예를 들어, 문자열 목록을 파일에 작성하는 Python 메서드를 작성해보겠습니다:\n\n```python\npython_code = \"\"\"\nclass Writer:\n   def write_file(self, filename: str, data: List[str]):\n        \\\"\\\"\\\" Write list of strings to a text file \\\"\\\"\\\"\n        with open(filename, 'w') as f_out:\n            for line in data:\n                f_out.write(f\"{line}\\n\")\n\"\"\"\n```\n\n<div class=\"content-ad\"></div>\n\n모델의 코딩 능력을 테스트하기 위해, 두 모델에게 \"pytest\"를 만들도록 요청해보겠습니다:\n\n```js\nchat = [{\n    \"role\": \"user\",\n    \"content\": f\"이 파이썬 메소드에 대한 pytest를 작성해주세요:\\n{python_code}. \"\\\n               f\"테스트가 끝나면 생성된 파일을 삭제하세요.\"\n    }]\n\n\nprompt = tokenizer.apply_chat_template(chat, tokenize=False, add_generation_prompt=True)\ninputs = tokenizer.encode(prompt, add_special_tokens=False, return_tensors=\"pt\")\noutputs = model.generate(input_ids=inputs.to(model.device), max_new_tokens=1024)\nresult = tokenizer.decode(outputs[0])\n```\n\n결과적으로, CodeLlama 7B가 이 코드를 생성했고, 이 과정은 19초가 걸렸습니다:\n\n```js\nimport pytest\n\n\nclass TestWriter:\n    def test_write_file(self):\n        writer = Writer()\n        filename = 'test.txt'\n        data = ['line1', 'line2', 'line3']\n        writer.write_file(filename, data)\n        with open(filename, 'r') as f:\n            lines = f.readlines()\n            assert lines == data\n        os.remove(filename)\n```\n\n<div class=\"content-ad\"></div>\n\nCodeGemma이 이 코드를 생성했고, 프로세스에는 16초가 걸렸어요:\n\n```js\nimport pytest\n\n\ndef test_write_file():\n    \"\"\" write_file 메소드를 테스트함 \"\"\"\n    filename = \"test.txt\"\n    data = [\"This is a test\", \"line 2\", \"line 3\"]\n    Writer().write_file(filename, data)\n\n    with open(filename, \"r\") as f:\n        assert f.read() == \"This is a test\\nline 2\\nline 3\\n\"\n\n    import os\n    os.remove(filename)\n```\n\n개인적으로, 저는 두 번째 버전을 선호해요. 첫째, CodeGemma가 메소드의 설명을 나타내는 docstring을 제공했고, 이는 현대적인 \"linter\" 도구의 요구 사항이에요. 둘째, Writer().write_file(...) 코드는 writer 변수를 선언하고 나중에 사용하는 것보다 더 간결하고 가독성이 좋아 보여요. 셋째, CodeGemma는 \"os\" 파이썬 모듈을 가져왔는데, CodeLlama는 이를 \"잊어버렸어요\".\n\n첫눈에는 두 코드 조각이 모두 올바르게 보여요. pytest -v file.py 명령을 실행하여 코드를 실행해 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_1.png\" />\n\n실제로 두 테스트의 정확성에 대해 잘못 이야기 했었고, 첫 번째 테스트에 버그가 있습니다. 재미있게도, 두 번째 테스트는 뿐만 아니라 더 나은 모습을 하고 있으며, 작동하기도 합니다. 그 반면 첫 번째는 작동하지 않습니다. 스크린샷에서 오류는 명백합니다. 독자들은 자신의 힘으로 어떻게 수정할지 찾아보세요.\n\n처음에는 CodeGemma 2B \"코드 완성\" 모델을 테스트할 계획이 없었지만, 독자들을 위한 추가 혜택으로 해보자구요! 모델을 로드하는 방법은 동일합니다. 오직 모델 ID만 바꾸면 됩니다:\n\n```js\nmodel_id = \"google/codegemma-2b\"\nmodel = AutoModelForCausalLM.from_pretrained(model_id, ...)\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 코드 완성을 위해 훈련된 모델입니다. 영어 설명이 없어도 되며, 소스 코드만 제공하면 됩니다:\n\n```js\n# Prompt\npython_code = \"\"\"\nclass Writer:\n   def write_file(self, filename: str, data: List[str]):\n      ...\n\nimport pytest\n\ndef test_write_file():\n    \\\"\\\"\\\"\\ Test the write_file method \\\"\\\"\\\"\n\"\"\"\n\nprompt = f\"\"\"\n<|fim_prefix|>{python_code}\n```\n\n<div class=\"content-ad\"></div>\n\n우리가 볼 수 있듯이 해당 코드는 \"그대로 사용\"되지 않을 것입니다. 하지만 논리는 올바른 것으로 보입니다. 필요한 수정은 assert 라인을 올바르게 포맷하는 것입니다:\n\n```js\nassert lines == [\"Hello\\n\", \"World\\n\"]\n```\n\n이후에 \"pytest\"가 통과되었습니다. 모델은 테스트 이후 파일을 제거하지 않았지만, 나는 프롬프트에서 그것을 요청하지 않았습니다. 마지막으로, 소형 모델의 실행 시간은 단지 3.3초로, 더 큰 모델과 비교했을 때 약 5배 빠릅니다.\n\n## 2. 람마 서버 실행\n\n<div class=\"content-ad\"></div>\n\n우리는 파이썬에서 모델을 테스트했고, 이제 로컬 OpenAI 호환 서버를 실행해볼 차례입니다. 이를 위해 Llama-cpp-python을 사용할 거예요. 이 프로젝트는 멋지고 가벼워요. 한 줄의 명령어로 우리가 원하는 어떤 모델이든 실행할 수 있어요:\n\n```js\n# 코드 Gemma\npython3 -m llama_cpp.server --model codegemma-7b-it-Q4_K_M.gguf --n_ctx 8192 --n_gpu_layers -1 --host 0.0.0.0 --port 8000\n\n# 코드 Llama 7B\npython3 -m llama_cpp.server --model codellama-7b-instruct.Q4_K_M.gguf --n_ctx 8192 --n_gpu_layers -1 --host 0.0.0.0 --port 8000\n\n# 코드 Llama 13B\npython3 -m llama_cpp.server --model codellama-13b-instruct.Q4_K_M.gguf --n_ctx 8192 --n_gpu_layers -1 --host 0.0.0.0 --port 8000\n```\n\n모델을 로드할 GPU RAM이 충분하지 않으면, n_gpu_layers 매개변수를 변경하여 GPU에 일부 레이어만 로드할 수 있어요. 또한 Apple Silicon이나 심지어 CPU에서 모델을 실행할 수도 있지만 물론 느릴 거예요.\n\n## 3. 앱들\n\n<div class=\"content-ad\"></div>\n\n지금은 로컬 OpenAI 호환 서버가 있으며 몇 가지 앱을 테스트할 준비가 되어 있습니다!\n\n### 3.1 AI Shell\n\nAI Shell은 자연어 프롬프트를 콘솔 명령어로 변환할 수 있는 오픈 소스 앱입니다. 이 앱은 꽤 인기가 있으며 작성 당시 프로젝트는 GitHub에서 3.6K개의 스타를 받았습니다. AI Shell은 TypeScript로 작성되었으며 npm 패키지 관리자를 통해 이 앱을 설치할 수 있습니다 (저는 여기서 Node JS 20.13.0도 설치했습니다):\n\n```js\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\nnvm install v20.13.0\nnpm install -g @builder.io/ai-shell\n```\n\n<div class=\"content-ad\"></div>\n\n앱을 실행하기 전에 API 엔드포인트를 구성해야 합니다:\n\n```js\nai config set OPENAI_KEY=12345678\nai config set OPENAI_API_ENDPOINT=http://127.0.0.1:8000/v1\n```\n\n이제 콘솔에서 \"ai chat\" 명령을 입력하여 언제든지 모델과 대화를 시작할 수 있습니다:\n\n![대화 모델](https://miro.medium.com/v2/resize:fit:1400/1*9zJpuyFx_-HW4AZ4b9ZH8A.gif)\n\n<div class=\"content-ad\"></div>\n\n프로그램을 사용하는 또 다른 방법은 실행하려는 명령어를 입력하는 것입니다. 예를 들어, \"현재 폴더에 있는 파일 표시\"와 같은 내용을 입력할 수 있어요:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*4PElpWscaef11mHRzCdZ5Q.gif)\n\n안타깝게도 무료 7B 모델로는 작동하지 않았고, 모델이 올바른 쉘 명령어를 생성하지 못했어요. 또한 프롬프트 안에 있는 \"스크립트\"라는 단어가 모델을 혼란스럽게 만들었고, 영화 대본과 관련된 텍스트를 생성했어요.\n\n이 문제는 아마도 프롬프트를 조정하여 해결할 수 있겠죠. 그러나 이 텍스트를 작성할 때에는 프롬프트가 TypeScript 소스에 하드코딩되어 있어 쉽게 구성할 수 없었어요. 아직까지 GitHub에서 제 기능 제안에 응답한 사람이 없지만, 향후 개선될 것을 희망해요.\n\n<div class=\"content-ad\"></div>\n\n3.2 ShellGPT\n\nShellGPT는 이 텍스트를 작성하는 시점에서 GitHub에서 8.3K개의 스타를 가진 또 다른 흥미로운 오픈소스 프로젝트입니다. 우리는 다음과 같이 pip를 사용하여 쉽게 응용 프로그램을 설치할 수 있습니다:\n\n```js\npip3 install shell-gpt\n```\n\n로컬 모델과 함께 ShellGPT를 사용하려면 ~/.config/shell_gpt/.sgptrc 파일에서 API 엔드포인트를 변경해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nAPI_BASE_URL=http://127.0.0.1:8000/v1\nOPENAI_API_KEY=12345678\n```\n\n그럼 이제 우리는 이전 앱과 거의 같은 방식으로 터미널 쉘에 직접 요청을 입력할 수 있어요:\n\n```js\nsgpt \"로컬 파일을 표시하는 명령어를 작성해주세요\"\n```\n\n안타깝게도, CodeGemma 모델은 ShellGPT에서 작동하지 않았고, LlamaCpp 서버는 Server 500 오류를 반환했어요: '시스템 역할이 지원되지 않음'. 처음에는 LlamaCpp 문제인 줄 알았지만 로그를 확인한 후에는 모델 메타데이터에 이런 라인이 있는 것을 보았어요:\n\n<div class=\"content-ad\"></div>\n\n```js\n{ if messages[0]['role'] == 'system' }\n  { raise_exception('시스템 역할은 지원되지 않습니다')\n```\n\n코드젬마가 \"시스템\" 역할을 지원하지 않는 것은 안타깝습니다. 왜냐하면 OpenAI API에서 널리 사용되기 때문입니다. 따라서 OpenAI 호환 앱은 코드젬마를 사용할 수 없습니다. 이전에 보았던 것처럼, 코드젬마가 생성한 코드는 꽤 좋았기 때문에 아쉽습니다.\n\n코드람마에 대한 셸GPT는 잘 작동합니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*N6gwsFM7ZNt7OW2sZcaNZg.gif)\n\n<div class=\"content-ad\"></div>\n\n터미널 셸에서 '—shell' 접두어를 지정하여 명령을 직접 실행하는 기능이 편리합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*xTTNTI0Ykh8NGuqkIpwLVg.gif)\n\n더 개선할 공간이 있습니다. 예를 들어, \"문서 폴더의 크기 표시하기\" 프롬프트에 대한 ```du -sh ~/Documents``` 응답이 반환됩니다. 이것은 올바른 bash 명령어입니다. 그러나 ShellGPT는 ``` 문자열에서 해당 명령을 가져오지 못했고 \"명령을 찾을 수 없음\" 오류만 받았습니다.\n\n<div class=\"content-ad\"></div>\n\nbash 명령어를 사용하는 것도 유용하지만, 실제 코딩 지원은 어떨까요? 오픈소스 CodeGPT 플러그인을 통해 이를 할 수 있어요. 먼저, PyCharm IDE에 플러그인을 설치하고 LlamaCpp와 함께 사용할 수 있도록 설정했어요:\n\n![CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance](/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_2.png)\n\n예를 들어, 다음과 같은 Python 클래스를 고려해봅시다:\n\n```js\nclass ServerConnection:\n    \"\"\" Server connection handling \"\"\"\n\n    def __init__(self):\n        self.is_connected = False\n        self.connection_time = -1\n        self.uploads_total = 0\n        self.reconnects_total = 0\n        self.reconnect_threshold_sec = 64\n```\n\n<div class=\"content-ad\"></div>\n\n저는 모델에게 변수를 따로 Python 데이터 클래스로 리팩터링하도록 요청할 것입니다.\n\n결과적으로 CodeGemma는 이를 수행하지 못했으며 \"시스템 역할을 지원하지 않음\"이라는 오류가 발생했습니다. CodeLlama 7B는 작업을 완료할 수 없었고 대신에 데이터 클래스 대신 표준 클래스를 생성했습니다. 반면에 CodeLlama 13B는 잘 수행했습니다:\n\n![이미지](/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_3.png)\n\n다음 단계로, 더 복잡한 내용을 요청하고 텍스트 필드와 버튼 프롬프트가 있는 UI Python 애플리케이션을 만들어보았습니다. Llama 13B 모델이 이 코드를 생성했습니다:\n\n<div class=\"content-ad\"></div>\n\n```python\nimport tkinter as tk\n\n# 메인 창 생성\nroot = tk.Tk()\nroot.title(\"Hello World\")\nroot.geometry(\"320x200\")\n\n# 텍스트 필드 생성\ntext_field = tk.Entry(root)\ntext_field.pack()\n\n# 버튼 생성\nbutton = tk.Button(root, text=\"Click Me!\", command=lambda: print(\"You clicked the button!\"))\nbutton.pack()\n\n# 메인 루프 시작\nroot.mainloop()\n``` \n\n코드는 올바르지만, 애플리케이션 창이 보이지 않았습니다. 크기가 지정되지 않았습니다. 나는 모델에게 제목을 \"Hello World\"로 변경하고 창 크기를 320x200으로 설정하도록 요청했습니다: \n\n<img src=\"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_4.png\" />\n\n결과가 적절하게 나와 요청한 애플리케이션이 예상대로 작동했습니다.```\n\n<div class=\"content-ad\"></div>\n\n![CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_5](/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_5.png)\n\n저는 13B 모델이 완벽하지 않다는 것을 인정해야합니다. 이론적으로는 큰 컨텍스트 창과 이전 채팅 결과를 사용해야 하지만, 제가 모델에게 생성된 코드를 클래스로 이동하도록 요청했을 때 창 크기나 제목을 설정하지 않은 새로운 코드를 생성했습니다:\n\n```js\nimport tkinter as tk\n\nclass HelloWorld(tk.Frame):\n    def __init__(self, master=None):\n        super().__init__(master)\n        self.pack()\n\n        # 텍스트 필드 생성\n        self.text_field = tk.Entry(self)\n        self.text_field.pack()\n\n        # 버튼 생성\n        self.button = tk.Button(self, text=\"Click Me!\", command=lambda: print(\"Button clicked!\"))\n        self.button.pack()\n\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    app = HelloWorld(root)\n    root.mainloop()\n```\n\n하지만 일반적으로 말하자면, 모델이 정확한 클래스를 생성했으며 조금의 복사 붙여넣기로 작업을 완료하는 것이 쉬웠습니다.\n\n<div class=\"content-ad\"></div>\n\n## 4. 단점\n\n지금까지 모든 예시를 통해 모델이 작동하는 것을 확인할 수 있습니다; 코드와 bash 명령을 모두 생성할 수 있습니다. 그러나 몇 가지 단점과 문제점도 있습니다:\n\n- 로컬 LLM 인스턴스를 사용하려면 좋은 그래픽 카드가 필요합니다. 저는 2.5년 전에 구매한 8GB GPU RAM을 갖춘 GeForce RTX 3060 카드를 사용하고 있습니다. Colab 테스트에서는 8 GB가 7B 모델을 실행하는 데 충분하다는 것을 확인했지만, 실제 데스크탑에서는 그 용량이 부족했습니다. OS 자체도 일부 GPU를 필요로 하기 때문입니다. 실제로 13B 모델을 실행하려면 적어도 16 GB의 GPU RAM이 필요하며, 미래 개선을 위한 여유 공간으로 24 GB가 필요합니다. 현실적으로 고려할만 한가요? 현재 GPU 가격을 고려할 때, 1000-1500달러에는 AI 구독을 여러 년간 할 수 있습니다.\n- 오픈 소스 앱은 완벽하지 않습니다. 제 테스트에서 LlamaCpp 서버는 때로 \"segmentation fault\"와 함께 충돌하고, CodeGPT 앱은 때로는 모델에 요청을 전송하지 않았고, PyCharm을 재시작해야 했고 등등 발생했습니다. 이것은 오픈 소스이며 어떤 종류의 보장도 없으므로 불평할 것이 아니지만, 이러한 AI 도구들에 대해서는 아직 \"초기 채택\" 단계에 있다는 것을 인정해야 합니다.\n- 또한 대형 로컬 언어 모델 실행은 에너지를 많이 소비하는 작업입니다. 마지막 테스트로 내 데스크톱 PC에 전력계를 연결했습니다. 평상시에는 약 80 와트를 소비하는 것으로 나타났습니다. 하지만 LLM 요청이 실행될 때는 에너지 소비량이 거의 3배 증가합니다: \n\n![이미지](/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_6.png)\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n본 기사에서는 오픈 언어 모델이 코딩 어시스턴트로서 작동하는 능력을 테스트하였고, 결과는 흥미로웠습니다:\n\n- 작은 7B 및 13B 모델조차도 리팩토링, 단위 테스트 생성 또는 작은 코드 템플릿 작성과 같은 일부 코딩 작업을 수행할 수 있습니다. 물론, 이러한 모델들은 175B ChatGPT 3.5와 같이 큰 모델에 비해 능력이 떨어지지만, 로컬 모델을 사용하는 것은 구독 비용이 필요하지 않을 뿐만 아니라, 개인 정보 관점에서 빠르고 효율적일 수도 있습니다.\n- 반면에 로컬 모델을 실행하려면 고사양의 하드웨어가 필요하며, 이는 비용 부담뿐만 아니라 에너지 소모도 초래할 수 있습니다. 본 기사 작성 시, 고사양 GPU는 최대 $1500에 이를 수 있으며, 이는 로컬 LLMs만 실행하기에는 현실적이지 않습니다 — 해당 비용으로 클라우드 서비스 구독을 매우 오랜 기간 동안 이용할 수 있습니다.\n- AI 도구를 사용하는 도전 과제는 하드웨어뿐만 아니라 소프트웨어에도 있습니다. 최소한 본 게시물 작성 시점에는 AI 소프트웨어의 오픈 소스 생태계가 아직 미성숙한 것으로 나타났습니다. HuggingFace에서 39,769개의 오픈 7B 모델을 발견했으나 GitHub에서의 오픈 소스 AI 앱 수는 미미합니다. 이 기사에서 설명한 3가지가 거의 제가 찾아낸 전부였습니다 (만약 놓친 것이 있다면, 아래 댓글에 쓰거나, 추가 리뷰를 진행할지도 모릅니다).\n\n일반적으로 일상적인 코딩 작업에 로컬 LLM을 사용하는 것은 가능하지만, 소프트웨어와 하드웨어 모두에서 여전히 많은 도전 과제가 있음을 알 수 있습니다. 더 나은 AI 칩 및 효율적인 모델을 위해 노력하고 있는 다른 기업들이 있음도 알고 있습니다. Microsoft의 Phi-3와 같은 새로운 모델은 이제 모바일 하드웨어에서도 작동할 수 있습니다. 그것이 AI 산업을 어떻게 바꿀지 어떻게 알 수 있을까요? 다음 세대의 통합 그래픽 카드는 저렴하고 조용하며 CUDA 호환될 것인가요? 아직 모릅니다. 분명히 새로운 AI 관련 하드웨어가 발표될 것이며 (M4가 이미 첫 번째였습니다), 적어도 오픈 사용을 위한 드라이버 없이 독점적인 새 하드웨어가 되지 않기를 희망합니다.\n\n<div class=\"content-ad\"></div>\n\n읽어 주셔서 감사합니다. 이야기가 마음에 드셨다면 Medium에 구독해보세요. 그러면 새 기사가 발행될 때 알림을 받을 수 있을 뿐만 아니라 수천 편의 다른 작가들의 이야기에도 완전한 접속 권한을 얻을 수 있습니다. 또한 LinkedIn을 통해 연락하실 수도 있습니다. 거기에서는 전체 기사로 충분치 않은 작은 포스트를 주기적으로 발행하고 있습니다. 이번 포스트와 다른 포스트의 전체 소스 코드를 원하신다면 Patreon 페이지를 방문해보세요.\n\n자연어 처리와 언어 모델을 사용하는 것에 관심이 있는 분들은 다른 논문들도 읽어보세요:\n\n- GPT 모델: 어떻게 작동합니까?\n- 16, 8 및 4비트 부동 소수점 형식 - 어떻게 작동합니까?\n- 대규모 언어 모델로 판다 데이터프레임 처리하기\n- 주말 AI 프로젝트 (제1부): 라즈베리 파이에서 음성 인식 및 LLaMA-2 GPT 실행\n- 주말 AI 프로젝트 (제2부): 음성 인식, PTT 및 라지 액션 모델을 라즈베리 파이에서 사용하기\n- 주말 AI 프로젝트 (제3부): 시각 장애인을 위한 시각 보조 도구 만들기","ogImage":{"url":"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_0.png"},"coverImage":"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_0.png","tag":["Tech"],"readingTime":14},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h3: \"h3\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"AI 코딩 도구 시장은 수십억 달러의 산업입니다. 2030년까지 172억 달러에 이를 것으로 예상되며, 현재에도 VS Code 또는 JetBrains IDE용 AI 플러그인은 수백만 번 다운로드되었습니다. 하지만 무료 코딩 도우미로 로컬 모델을 실행할 수 있을까요? 그리고 그 성능은 어떨까요? 이 기사에서는 두 개의 오픈 모델, Code Gemma와 Code Llama를 테스트해 보겠습니다. 제 PC에 설치하고, 그들이 어떻게 작동하는지 확인할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더 이상의 말이 필요 없으니, 시작해 봅시다!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 모델들\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"본문 작성 시점에서 코딩 목적으로 두 가지 주요 오픈 모델이 무료로 다운로드할 수 있으며 사용할 수 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"CodeLlama. 이 모델은 2023년 Meta에서 출시되었으며, 7B, 13B, 34B, 70B 크기로 제공됩니다. \\\"Base\\\", \\\"Instruct\\\", \\\"Python\\\" 모델을 사용할 수 있습니다. 4가지 크기이지만, 로컬에서 실제로 사용할 수 있는 것은 7B 및 13B 모델뿐입니다; 다른 크기는 너무 \\\"무겁습니다.\\\"\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"CodeGemma. 이 모델은 2024년 Google에서 출시되었으며, 2B 및 7B 크기로 제공됩니다. 2B 모델은 코드 완성을 위해 훈련되었으며, 7B 모델은 코드 채움 및 자연어 프롬프트를 위해 훈련되었습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"본문에서는 HuggingFace에서 제공되며 GGUF 형식으로 다운로드할 수 있는 7B 및 13B 모델을 테스트할 것이며, 이를 사용하여 다양한 앱에서 이 모델들을 사용할 수 있도록 OpenAI 호환 로컬 서버를 실행할 것입니다. 그러나 이를 수행하기 전에 단순히 모델을 Python으로 실행하여 무엇을 할 수 있는지 살펴보겠습니다. 실제 사용으로 넘어가고 싶은 독자분들은 이 부분을 건너뛸 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"두 모델을 테스트하기 위해 Google Colab 인스턴스를 무료로 사용할 것입니다. 먼저, 모델과 토크나이저를 로드해보겠습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" transformers \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" transformers\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" torch\\n\\n\\nmodel_id = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \"\\nbnb_config = BitsAndBytesConfig(\\n    load_in_4bit=\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"True\"\n        }), \",\\n    bnb_4bit_quant_type=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"nf4\\\"\"\n        }), \",\\n    bnb_4bit_use_double_quant=\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"False\"\n        }), \",\\n)\\n\\ntokenizer = AutoTokenizer.from_pretrained(model_id)\\nmodel = AutoModelForCausalLM.from_pretrained(\\n    model_id,\\n    quantization_config=bnb_config,\\n    device_map=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"cuda\\\"\"\n        }), \",\\n    torch_dtype=torch.bfloat16,\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HuggingFace의 Transformers 라이브러리는 모델 파일을 자동으로 다운로드해줍니다. 7B 모델은 약 16.2 GB의 GPU RAM을 필요로 하지만, bits and bytes 라이브러리를 활용하여 4비트 해상도로 모델을 실행하면 필요한 메모리 용량은 약 5GB 정도로 줄어듭니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 모델을 테스트하기 위한 코드 조각을 만들어 봅시다. 예를 들어, 문자열 목록을 파일에 작성하는 Python 메서드를 작성해보겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"python_code = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\\\"\\nclass Writer:\\n   def write_file(self, filename: str, data: List[str]):\\n        \\\\\\\"\\\\\\\"\\\\\\\" Write list of strings to a text file \\\\\\\"\\\\\\\"\\\\\\\"\\n        with open(filename, 'w') as f_out:\\n            for line in data:\\n                f_out.write(f\\\"{line}\\\\n\\\")\\n\\\"\\\"\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모델의 코딩 능력을 테스트하기 위해, 두 모델에게 \\\"pytest\\\"를 만들도록 요청해보겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"chat = [{\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"user\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content\\\"\"\n        }), \": f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"이 파이썬 메소드에 대한 pytest를 작성해주세요:\\\\n{python_code}. \\\"\"\n        }), \"\\\\\\n               f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"테스트가 끝나면 생성된 파일을 삭제하세요.\\\"\"\n        }), \"\\n    }]\\n\\n\\nprompt = tokenizer.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"apply_chat_template\"\n        }), \"(chat, tokenize=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"False\"\n        }), \", add_generation_prompt=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\ninputs = tokenizer.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"encode\"\n        }), \"(prompt, add_special_tokens=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"False\"\n        }), \", return_tensors=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"pt\\\"\"\n        }), \")\\noutputs = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"generate\"\n        }), \"(input_ids=inputs.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to\"\n        }), \"(model.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"device\"\n        }), \"), max_new_tokens=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1024\"\n        }), \")\\nresult = tokenizer.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"decode\"\n        }), \"(outputs[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"])\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과적으로, CodeLlama 7B가 이 코드를 생성했고, 이 과정은 19초가 걸렸습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" pytest\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TestWriter\"\n        }), \":\\n    def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"test_write_file\"\n        }), \"(self):\\n        writer = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Writer\"\n        }), \"()\\n        filename = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'test.txt'\"\n        }), \"\\n        data = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'line1'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'line2'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'line3'\"\n        }), \"]\\n        writer.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"write_file\"\n        }), \"(filename, data)\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"open\"\n        }), \"(filename, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'r'\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \":\\n            lines = f.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readlines\"\n        }), \"()\\n            assert lines == data\\n        os.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"remove\"\n        }), \"(filename)\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"CodeGemma이 이 코드를 생성했고, 프로세스에는 16초가 걸렸어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" pytest\\n\\n\\ndef \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"test_write_file\"\n        }), \"():\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\" write_file 메소드를 테스트함 \\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n    filename = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"test.txt\\\"\"\n        }), \"\\n    data = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"This is a test\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"line 2\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"line 3\\\"\"\n        }), \"]\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Writer\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"write_file\"\n        }), \"(filename, data)\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"open\"\n        }), \"(filename, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"r\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \":\\n        assert f.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read\"\n        }), \"() == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"This is a test\\\\nline 2\\\\nline 3\\\\n\\\"\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" os\\n    os.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"remove\"\n        }), \"(filename)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개인적으로, 저는 두 번째 버전을 선호해요. 첫째, CodeGemma가 메소드의 설명을 나타내는 docstring을 제공했고, 이는 현대적인 \\\"linter\\\" 도구의 요구 사항이에요. 둘째, Writer().write_file(...) 코드는 writer 변수를 선언하고 나중에 사용하는 것보다 더 간결하고 가독성이 좋아 보여요. 셋째, CodeGemma는 \\\"os\\\" 파이썬 모듈을 가져왔는데, CodeLlama는 이를 \\\"잊어버렸어요\\\".\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫눈에는 두 코드 조각이 모두 올바르게 보여요. pytest -v file.py 명령을 실행하여 코드를 실행해 보겠습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실제로 두 테스트의 정확성에 대해 잘못 이야기 했었고, 첫 번째 테스트에 버그가 있습니다. 재미있게도, 두 번째 테스트는 뿐만 아니라 더 나은 모습을 하고 있으며, 작동하기도 합니다. 그 반면 첫 번째는 작동하지 않습니다. 스크린샷에서 오류는 명백합니다. 독자들은 자신의 힘으로 어떻게 수정할지 찾아보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"처음에는 CodeGemma 2B \\\"코드 완성\\\" 모델을 테스트할 계획이 없었지만, 독자들을 위한 추가 혜택으로 해보자구요! 모델을 로드하는 방법은 동일합니다. 오직 모델 ID만 바꾸면 됩니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"model_id = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"google/codegemma-2b\\\"\"\n        }), \"\\nmodel = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AutoModelForCausalLM\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from_pretrained\"\n        }), \"(model_id, ...)\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 코드 완성을 위해 훈련된 모델입니다. 영어 설명이 없어도 되며, 소스 코드만 제공하면 됩니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Prompt\"\n        }), \"\\npython_code = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\nclass Writer:\\n   def write_file(self, filename: str, data: List[str]):\\n      ...\\n\\nimport pytest\\n\\ndef test_write_file():\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\ Test the write_file method \\\\\\\"\\\\\\\"\\\\\\\"\\n\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n\\nprompt = f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\n<|fim_prefix|>{python_code}\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 볼 수 있듯이 해당 코드는 \\\"그대로 사용\\\"되지 않을 것입니다. 하지만 논리는 올바른 것으로 보입니다. 필요한 수정은 assert 라인을 올바르게 포맷하는 것입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"assert lines == [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello\\\\n\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"World\\\\n\\\"\"\n        }), \"]\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이후에 \\\"pytest\\\"가 통과되었습니다. 모델은 테스트 이후 파일을 제거하지 않았지만, 나는 프롬프트에서 그것을 요청하지 않았습니다. 마지막으로, 소형 모델의 실행 시간은 단지 3.3초로, 더 큰 모델과 비교했을 때 약 5배 빠릅니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 람마 서버 실행\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 파이썬에서 모델을 테스트했고, 이제 로컬 OpenAI 호환 서버를 실행해볼 차례입니다. 이를 위해 Llama-cpp-python을 사용할 거예요. 이 프로젝트는 멋지고 가벼워요. 한 줄의 명령어로 우리가 원하는 어떤 모델이든 실행할 수 있어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 코드 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Gemma\"\n        }), \"\\npython3 -m llama_cpp.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"server\"\n        }), \" --model codegemma-7b-it-\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"Q4_K_M\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"gguf\"\n        }), \" --n_ctx \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8192\"\n        }), \" --n_gpu_layers -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" --host \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), \" --port \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8000\"\n        }), \"\\n\\n# 코드 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Llama\"\n        }), \" 7B\\npython3 -m llama_cpp.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"server\"\n        }), \" --model codellama-7b-instruct.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Q4_K_M\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"gguf\"\n        }), \" --n_ctx \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8192\"\n        }), \" --n_gpu_layers -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" --host \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), \" --port \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8000\"\n        }), \"\\n\\n# 코드 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Llama\"\n        }), \" 13B\\npython3 -m llama_cpp.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"server\"\n        }), \" --model codellama-13b-instruct.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Q4_K_M\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"gguf\"\n        }), \" --n_ctx \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8192\"\n        }), \" --n_gpu_layers -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" --host \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), \" --port \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8000\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모델을 로드할 GPU RAM이 충분하지 않으면, n_gpu_layers 매개변수를 변경하여 GPU에 일부 레이어만 로드할 수 있어요. 또한 Apple Silicon이나 심지어 CPU에서 모델을 실행할 수도 있지만 물론 느릴 거예요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 앱들\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금은 로컬 OpenAI 호환 서버가 있으며 몇 가지 앱을 테스트할 준비가 되어 있습니다!\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.1 AI Shell\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"AI Shell은 자연어 프롬프트를 콘솔 명령어로 변환할 수 있는 오픈 소스 앱입니다. 이 앱은 꽤 인기가 있으며 작성 당시 프로젝트는 GitHub에서 3.6K개의 스타를 받았습니다. AI Shell은 TypeScript로 작성되었으며 npm 패키지 관리자를 통해 이 앱을 설치할 수 있습니다 (저는 여기서 Node JS 20.13.0도 설치했습니다):\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"curl -o- \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\"\n        }), \"\\nnvm install v20\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".13\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), \"\\nnpm install -g @builder.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"io\"\n        }), \"/ai-shell\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앱을 실행하기 전에 API 엔드포인트를 구성해야 합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"ai config set \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"OPENAI_KEY\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12345678\"\n        }), \"\\nai config set \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"OPENAI_API_ENDPOINT\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"http\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//127.0.0.1:8000/v1\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 콘솔에서 \\\"ai chat\\\" 명령을 입력하여 언제든지 모델과 대화를 시작할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*9zJpuyFx_-HW4AZ4b9ZH8A.gif\",\n        alt: \"대화 모델\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로그램을 사용하는 또 다른 방법은 실행하려는 명령어를 입력하는 것입니다. 예를 들어, \\\"현재 폴더에 있는 파일 표시\\\"와 같은 내용을 입력할 수 있어요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*4PElpWscaef11mHRzCdZ5Q.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안타깝게도 무료 7B 모델로는 작동하지 않았고, 모델이 올바른 쉘 명령어를 생성하지 못했어요. 또한 프롬프트 안에 있는 \\\"스크립트\\\"라는 단어가 모델을 혼란스럽게 만들었고, 영화 대본과 관련된 텍스트를 생성했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 문제는 아마도 프롬프트를 조정하여 해결할 수 있겠죠. 그러나 이 텍스트를 작성할 때에는 프롬프트가 TypeScript 소스에 하드코딩되어 있어 쉽게 구성할 수 없었어요. 아직까지 GitHub에서 제 기능 제안에 응답한 사람이 없지만, 향후 개선될 것을 희망해요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"3.2 ShellGPT\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ShellGPT는 이 텍스트를 작성하는 시점에서 GitHub에서 8.3K개의 스타를 가진 또 다른 흥미로운 오픈소스 프로젝트입니다. 우리는 다음과 같이 pip를 사용하여 쉽게 응용 프로그램을 설치할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"pip3 install shell-gpt\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로컬 모델과 함께 ShellGPT를 사용하려면 ~/.config/shell_gpt/.sgptrc 파일에서 API 엔드포인트를 변경해야 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"API_BASE_URL\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"http\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//127.0.0.1:8000/v1\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"OPENAI_API_KEY\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12345678\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그럼 이제 우리는 이전 앱과 거의 같은 방식으로 터미널 쉘에 직접 요청을 입력할 수 있어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"sgpt \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"로컬 파일을 표시하는 명령어를 작성해주세요\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안타깝게도, CodeGemma 모델은 ShellGPT에서 작동하지 않았고, LlamaCpp 서버는 Server 500 오류를 반환했어요: '시스템 역할이 지원되지 않음'. 처음에는 LlamaCpp 문제인 줄 알았지만 로그를 확인한 후에는 모델 메타데이터에 이런 라인이 있는 것을 보았어요:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{ \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" messages[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'role'\"\n        }), \"] == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'system'\"\n        }), \" }\\n  { \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"raise_exception\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'시스템 역할은 지원되지 않습니다'\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드젬마가 \\\"시스템\\\" 역할을 지원하지 않는 것은 안타깝습니다. 왜냐하면 OpenAI API에서 널리 사용되기 때문입니다. 따라서 OpenAI 호환 앱은 코드젬마를 사용할 수 없습니다. 이전에 보았던 것처럼, 코드젬마가 생성한 코드는 꽤 좋았기 때문에 아쉽습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드람마에 대한 셸GPT는 잘 작동합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*N6gwsFM7ZNt7OW2sZcaNZg.gif\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"터미널 셸에서 '—shell' 접두어를 지정하여 명령을 직접 실행하는 기능이 편리합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*xTTNTI0Ykh8NGuqkIpwLVg.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"더 개선할 공간이 있습니다. 예를 들어, \\\"문서 폴더의 크기 표시하기\\\" 프롬프트에 대한 \", _jsx(_components.code, {\n        children: \"du -sh ~/Documents\"\n      }), \" 응답이 반환됩니다. 이것은 올바른 bash 명령어입니다. 그러나 ShellGPT는 ``` 문자열에서 해당 명령을 가져오지 못했고 \\\"명령을 찾을 수 없음\\\" 오류만 받았습니다.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"bash 명령어를 사용하는 것도 유용하지만, 실제 코딩 지원은 어떨까요? 오픈소스 CodeGPT 플러그인을 통해 이를 할 수 있어요. 먼저, PyCharm IDE에 플러그인을 설치하고 LlamaCpp와 함께 사용할 수 있도록 설정했어요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_2.png\",\n        alt: \"CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, 다음과 같은 Python 클래스를 고려해봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ServerConnection\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\" Server connection handling \\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n\\n    def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"__init__\"\n        }), \"(self):\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_connected\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"False\"\n        }), \"\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"connection_time\"\n        }), \" = -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"uploads_total\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"reconnects_total\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"reconnect_threshold_sec\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"64\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 모델에게 변수를 따로 Python 데이터 클래스로 리팩터링하도록 요청할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과적으로 CodeGemma는 이를 수행하지 못했으며 \\\"시스템 역할을 지원하지 않음\\\"이라는 오류가 발생했습니다. CodeLlama 7B는 작업을 완료할 수 없었고 대신에 데이터 클래스 대신 표준 클래스를 생성했습니다. 반면에 CodeLlama 13B는 잘 수행했습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 단계로, 더 복잡한 내용을 요청하고 텍스트 필드와 버튼 프롬프트가 있는 UI Python 애플리케이션을 만들어보았습니다. Llama 13B 모델이 이 코드를 생성했습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" tkinter \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" tk\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 메인 창 생성\"\n        }), \"\\nroot = tk.Tk()\\nroot.title(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello World\\\"\"\n        }), \")\\nroot.geometry(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"320x200\\\"\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 텍스트 필드 생성\"\n        }), \"\\ntext_field = tk.Entry(root)\\ntext_field.pack()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 버튼 생성\"\n        }), \"\\nbutton = tk.Button(root, text=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Click Me!\\\"\"\n        }), \", command=\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"lambda\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"You clicked the button!\\\"\"\n        }), \"))\\nbutton.pack()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 메인 루프 시작\"\n        }), \"\\nroot.mainloop()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드는 올바르지만, 애플리케이션 창이 보이지 않았습니다. 크기가 지정되지 않았습니다. 나는 모델에게 제목을 \\\"Hello World\\\"로 변경하고 창 크기를 320x200으로 설정하도록 요청했습니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_4.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과가 적절하게 나와 요청한 애플리케이션이 예상대로 작동했습니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_5.png\",\n        alt: \"CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_5\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 13B 모델이 완벽하지 않다는 것을 인정해야합니다. 이론적으로는 큰 컨텍스트 창과 이전 채팅 결과를 사용해야 하지만, 제가 모델에게 생성된 코드를 클래스로 이동하도록 요청했을 때 창 크기나 제목을 설정하지 않은 새로운 코드를 생성했습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" tkinter \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" tk\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HelloWorld\"\n        }), \"(tk.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Frame\"\n        }), \"):\\n    def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"__init__\"\n        }), \"(self, master=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \"):\\n        \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"super\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"__init__\"\n        }), \"(master)\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"pack\"\n        }), \"()\\n\\n        # 텍스트 필드 생성\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"text_field\"\n        }), \" = tk.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Entry\"\n        }), \"(self)\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"text_field\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"pack\"\n        }), \"()\\n\\n        # 버튼 생성\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"button\"\n        }), \" = tk.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Button\"\n        }), \"(self, text=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Click Me!\\\"\"\n        }), \", command=\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"lambda\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Button clicked!\\\"\"\n        }), \"))\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"button\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"pack\"\n        }), \"()\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" __name__ == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"__main__\\\"\"\n        }), \":\\n    root = tk.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Tk\"\n        }), \"()\\n    app = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HelloWorld\"\n        }), \"(root)\\n    root.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mainloop\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 일반적으로 말하자면, 모델이 정확한 클래스를 생성했으며 조금의 복사 붙여넣기로 작업을 완료하는 것이 쉬웠습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. 단점\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지 모든 예시를 통해 모델이 작동하는 것을 확인할 수 있습니다; 코드와 bash 명령을 모두 생성할 수 있습니다. 그러나 몇 가지 단점과 문제점도 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"로컬 LLM 인스턴스를 사용하려면 좋은 그래픽 카드가 필요합니다. 저는 2.5년 전에 구매한 8GB GPU RAM을 갖춘 GeForce RTX 3060 카드를 사용하고 있습니다. Colab 테스트에서는 8 GB가 7B 모델을 실행하는 데 충분하다는 것을 확인했지만, 실제 데스크탑에서는 그 용량이 부족했습니다. OS 자체도 일부 GPU를 필요로 하기 때문입니다. 실제로 13B 모델을 실행하려면 적어도 16 GB의 GPU RAM이 필요하며, 미래 개선을 위한 여유 공간으로 24 GB가 필요합니다. 현실적으로 고려할만 한가요? 현재 GPU 가격을 고려할 때, 1000-1500달러에는 AI 구독을 여러 년간 할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"오픈 소스 앱은 완벽하지 않습니다. 제 테스트에서 LlamaCpp 서버는 때로 \\\"segmentation fault\\\"와 함께 충돌하고, CodeGPT 앱은 때로는 모델에 요청을 전송하지 않았고, PyCharm을 재시작해야 했고 등등 발생했습니다. 이것은 오픈 소스이며 어떤 종류의 보장도 없으므로 불평할 것이 아니지만, 이러한 AI 도구들에 대해서는 아직 \\\"초기 채택\\\" 단계에 있다는 것을 인정해야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"또한 대형 로컬 언어 모델 실행은 에너지를 많이 소비하는 작업입니다. 마지막 테스트로 내 데스크톱 PC에 전력계를 연결했습니다. 평상시에는 약 80 와트를 소비하는 것으로 나타났습니다. 하지만 LLM 요청이 실행될 때는 에너지 소비량이 거의 3배 증가합니다:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-CodeLlamavsCodeGemmaUsingOpenModelsforAICodingAssistance_6.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"본 기사에서는 오픈 언어 모델이 코딩 어시스턴트로서 작동하는 능력을 테스트하였고, 결과는 흥미로웠습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"작은 7B 및 13B 모델조차도 리팩토링, 단위 테스트 생성 또는 작은 코드 템플릿 작성과 같은 일부 코딩 작업을 수행할 수 있습니다. 물론, 이러한 모델들은 175B ChatGPT 3.5와 같이 큰 모델에 비해 능력이 떨어지지만, 로컬 모델을 사용하는 것은 구독 비용이 필요하지 않을 뿐만 아니라, 개인 정보 관점에서 빠르고 효율적일 수도 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"반면에 로컬 모델을 실행하려면 고사양의 하드웨어가 필요하며, 이는 비용 부담뿐만 아니라 에너지 소모도 초래할 수 있습니다. 본 기사 작성 시, 고사양 GPU는 최대 $1500에 이를 수 있으며, 이는 로컬 LLMs만 실행하기에는 현실적이지 않습니다 — 해당 비용으로 클라우드 서비스 구독을 매우 오랜 기간 동안 이용할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"AI 도구를 사용하는 도전 과제는 하드웨어뿐만 아니라 소프트웨어에도 있습니다. 최소한 본 게시물 작성 시점에는 AI 소프트웨어의 오픈 소스 생태계가 아직 미성숙한 것으로 나타났습니다. HuggingFace에서 39,769개의 오픈 7B 모델을 발견했으나 GitHub에서의 오픈 소스 AI 앱 수는 미미합니다. 이 기사에서 설명한 3가지가 거의 제가 찾아낸 전부였습니다 (만약 놓친 것이 있다면, 아래 댓글에 쓰거나, 추가 리뷰를 진행할지도 모릅니다).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일반적으로 일상적인 코딩 작업에 로컬 LLM을 사용하는 것은 가능하지만, 소프트웨어와 하드웨어 모두에서 여전히 많은 도전 과제가 있음을 알 수 있습니다. 더 나은 AI 칩 및 효율적인 모델을 위해 노력하고 있는 다른 기업들이 있음도 알고 있습니다. Microsoft의 Phi-3와 같은 새로운 모델은 이제 모바일 하드웨어에서도 작동할 수 있습니다. 그것이 AI 산업을 어떻게 바꿀지 어떻게 알 수 있을까요? 다음 세대의 통합 그래픽 카드는 저렴하고 조용하며 CUDA 호환될 것인가요? 아직 모릅니다. 분명히 새로운 AI 관련 하드웨어가 발표될 것이며 (M4가 이미 첫 번째였습니다), 적어도 오픈 사용을 위한 드라이버 없이 독점적인 새 하드웨어가 되지 않기를 희망합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"읽어 주셔서 감사합니다. 이야기가 마음에 드셨다면 Medium에 구독해보세요. 그러면 새 기사가 발행될 때 알림을 받을 수 있을 뿐만 아니라 수천 편의 다른 작가들의 이야기에도 완전한 접속 권한을 얻을 수 있습니다. 또한 LinkedIn을 통해 연락하실 수도 있습니다. 거기에서는 전체 기사로 충분치 않은 작은 포스트를 주기적으로 발행하고 있습니다. 이번 포스트와 다른 포스트의 전체 소스 코드를 원하신다면 Patreon 페이지를 방문해보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자연어 처리와 언어 모델을 사용하는 것에 관심이 있는 분들은 다른 논문들도 읽어보세요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"GPT 모델: 어떻게 작동합니까?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"16, 8 및 4비트 부동 소수점 형식 - 어떻게 작동합니까?\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"대규모 언어 모델로 판다 데이터프레임 처리하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"주말 AI 프로젝트 (제1부): 라즈베리 파이에서 음성 인식 및 LLaMA-2 GPT 실행\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"주말 AI 프로젝트 (제2부): 음성 인식, PTT 및 라지 액션 모델을 라즈베리 파이에서 사용하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"주말 AI 프로젝트 (제3부): 시각 장애인을 위한 시각 보조 도구 만들기\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}