{"pageProps":{"post":{"title":"챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법","description":"","date":"2024-05-17 03:23","slug":"2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2","content":"\n\n제1부에서는 수십억 개의 매개변수를 가진 큰 언어 모델에 무료로 액세스하고 활용할 수 있다는 것을 발견했어요. 제처럼 여러분도 하드웨어 한정으로 고민 중이라면, 이 해킹 방법은 하이엔드 GPU나 유료 구독 없이도 Qwen-110B-chat과 같은 대규모 모델과 상호 작용할 수 있는 기쁨을 선사할 거예요.\n\n제2부에서는 지금부터 체험을 더 향상시키기 위해 스트림릿 인터페이스로 동일한 개념을 적용하여 챗봇에 시각적으로 매력적인 스트리밍 효과를 추가할 거예요.\n\n과정을 되짚어보자면, Python, Gradio_client 및 코딩 능력이 필요해요. AI 챗봇을 텍스트 인터페이스를 통해 만드는 데 초점을 맞추었어요:\n\n- 환경 설정: 먼저 가상 환경을 만들고 필요한 패키지(huggingface_hub, gradio-client 및 streamlit)를 설치하세요. PyTorch나 TensorFlow가 필요하지 않으며, 상호 작용은 API를 통해 이루어질 거예요.\n- Hugging Face API 토큰: 사용자는 Hugging Face에 등록하고 모델 추론 API에 액세스하기 위해 API 토큰을 생성해야 해요.\n- 챗봇 코딩: Hugging Face Spaces에서 Gradio의 \"API를 통해 사용\" 기능을 활용하여 이러한 강력한 모델에 Python 코드로 연결하는 방법을 배웠어요. 특히 여러 언어로 상업적 이용을 위한 라이선스가 허용되는 Qwen 시리즈 모델에 초점을 맞췄어요.\n- 스트리밍 효과: 코드 구조를 살펴보면, 모델과 상호 작용할 수 있는 함수를 만드는 방법을 설명했어요. predict() 및 submit() 메서드 중에서 선택하여 스트리밍 효과와 함께 또는 없이 응답을 생성하는 방법을 강조했어요.\n\n<div class=\"content-ad\"></div>\n\n조금 헤매고 있다면 part 1부터 시작하는 것을 제안해요:\n\n## 핵심 코드부터 Streamlit 인터페이스까지\n\n이걸 꼭 말해야 해요: 터미널에서 모든 앱이 정상 작동하지 않으면 그래픽 인터페이스를 시작하지 말아야 해요.\n\n이건 필수 조건이에요! 그래서 Streamlit 인터페이스를 만드는 것이 아주 쉬울 거에요: 이미 이전 파트에서 라이브러리와 상호작용이 어떻게 작동하는지 확인했기 때문이죠.\n\n<div class=\"content-ad\"></div>\n\n모든 것은 이 핵심을 중심으로 움직입니다:\n\n```js\nfrom gradio_client import Client\n\nclient = Client(\"Qwen/Qwen1.5-110B-Chat-demo\")\nresult = client.submit(\n        query='What is Science?',\n        history=[],\n        system=\"You are a helpful assistant.\",\n        api_name=\"/model_chat\"\n)\nprint(result)\n```\n\n그리고 submit() 메소드를 사용하여 스트리밍 객체/반복자를 얻을 수 있다는 것을 알고 있습니다. Streamlit을 사용하면 스트림을 다루기가 훨씬 쉬워집니다. 사실, 애플리케이션은 항상 페이지 위젯을 새로 고치기 때문에 텍스트 애플리케이션에서 사용되는 지루한 알고리즘을 무시할 수 있습니다. 기억하시나요?\n\n```js\n    final = ''\n    for chunk in result:\n        if final == '':\n            final=chunk[1][0][1]\n            print(chunk[1][0][1], end=\"\", flush=True)\n        else:\n            try:\n                print(chunk[1][0][1].replace(final,''), end=\"\", flush=True)\n                final = chunk[1][0][1]\n            except:\n                pass    \n```\n\n<div class=\"content-ad\"></div>\n\nstring.replace()을 사용하여 이미 생성된 것에서 새로운 단어를 빼내는 작업을 했었는데, 더이상 필요하지 않아요.🥳\n\n# Streamlit 앱\n\n습관적인 사람이라... 그래서 내 코드가 다른 프로젝트와 매우 비슷하다는 사실을 발견할 수 있을 거에요. 그런데 괜찮아요! 결국, 템플릿을 적용하고 수정하는 것이 매번 처음부터 시작하는 것보다 쉽고 빠를 수 있거든.\n\n새 파일을 만들어보세요: 제 파일은 st-Qwen1.5–110B-Chat.py라고 해요. 주요 라이브러리를 가져와 세션 상태 전역 변수를 생성하는 것부터 시작해볼까요?\n\n<div class=\"content-ad\"></div>\n\n```python\nimport streamlit as st\nimport time\nimport sys\nfrom gradio_client import Client\n# Internal usage\nimport os\nfrom time import sleep\n\n\nif \"hf_model\" not in st.session_state:\n    st.session_state.hf_model = \"Qwen1.5-110B-Chat\"\n# Initialize chat history\nif \"messages\" not in st.session_state:\n    st.session_state.messages = []\n```\n\n프로그램에서 전역 변수는 공유되어 사용될 수 있습니다. 또한 session_state라고 불리는 이러한 객체들이 streamlit의 매 실행마다 변경되지 않는 것을 필요로합니다.\n\n그리고 2가지 주요 함수를 정의합니다:\n\n```python\n@st.cache_resource\ndef create_client():   \n    yourHFtoken = \"hf_xxxxxxxxxxxxxxxxxxxxxxx\" #여기에 여러분의 HF 토큰을 넣으세요\n    print(f'{st.session_state.hf_model}에 대한 API Gradio 클라이언트를 로딩 중입니다.')\n    client = Client(\"Qwen/Qwen1.5-110B-Chat-demo\", hf_token=yourHFtoken)\n    return client\n\n# 모든 채팅 메시지를 chathistory.txt에 기록하는 함수\ndef writehistory(text):\n    with open('chathistorywen110b.txt', 'a', encoding='utf-8') as f:\n        f.write(text)\n        f.write('\\n')\n    f.close()\n```\n\n<div class=\"content-ad\"></div>\n\n저희는 @st.cache_resource 데코레이터를 사용하고 있습니다. 이는 Qwen1.5-110에 대한 API gradio 클라이언트를 Streamlit이 매 실행마다 로딩하지 않기를 원하기 때문입니다 (이는 분당 1회 이상 발생할 수 있습니다): Gradio 클라이언트 연결이 실행 중에 변경되지 않을 것이기 때문에, 이 리소스를 특별한 메모리에 캐싱하고 있습니다 (@st.cache_resource). 자세한 내용은 여기에서 확인하실 수 있습니다.\n\n## 일부 그래픽 조정\n\n이제 기본 Streamlit 페이지 요소와 챗봇에 사용할 아이콘을 설정할 수 있습니다.\n\n```js\n#아바타\nav_us = '🧑‍💻'  # './man.png'  #\"🦖\"  # \"🧑‍💻\", \"🤖\", \"🦖\"과 같은 단일 이모지입니다. Shortcut은 지원되지 않습니다.\nav_ass = \"🤖\"   #'./robot.png'\n# 기본 모델 설정\n\n### STREAMLIT UI 시작\nst.image('https://github.com/fabiomatricardi/ChatBOTMastery/raw/main/qwen100logo.png', )\nst.markdown(\"### *Streamlit & Gradio_client로 구동됨*\", unsafe_allow_html=True )\nst.markdown('---')\n\nclient = create_client()\n```\n\n<div class=\"content-ad\"></div>\n\n- 채팅 인터페이스에 로컬 이미지를 사용할 수도 있어요 (코드의 주석을 참고하세요!)\n- 마지막으로, create_client()로 클라이언트 연결을 인스턴스화해요.\n\n# 본문 — 채팅 인터페이스\n\nStreamlit은 자신의 위젯에 변경이 발생할 때마다 또는 입력(버튼, 선택기, 라디오 요소 등)으로 사용자 조작이 호출될 때마다 코드를 맨 위부터 다시 실행해요.\n\n그래서 저희는 대화 기록을 맨 위에 먼저 렌더링하기 시작했어요. 여기서는 뭐라도 새롭게 발명한 건 없어요: Streamlit 블로그의 공식 자습서에서 모두 배웠거든요.\n\n<div class=\"content-ad\"></div>\n\n이것은 표준 렌더링입니다. OpenAI API와 호환되는 chat_completion 형식에 모두 적용 가능합니다.\n\n코드로 돌아가서, 우리는 chat_template 메시지들을 표시하고, 메시지 목록을 반복하며 사용자 프롬프트(myprompt)가 제출되기를 기다립니다.\n\n```js\n# 앱 재실행 시 이전 대화 내용을 보여줍니다\nfor message in st.session_state.messages:\n    if message[\"role\"] == \"user\":\n        with st.chat_message(message[\"role\"],avatar=av_us):\n            st.markdown(message[\"content\"])\n    else:\n        with st.chat_message(message[\"role\"],avatar=av_ass):\n            st.markdown(message[\"content\"])\n# 사용자 입력 받기\nif myprompt := st.chat_input(\"인공지능 모델이란 무엇인가요?\"):\n    # 사용자 메시지를 대화 내역에 추가\n    st.session_state.messages.append({\"role\": \"user\", \"content\": myprompt})\n    # 대화 메시지 컨테이너에 사용자 메시지 표시\n    with st.chat_message(\"user\", avatar=av_us):\n        st.markdown(myprompt)\n        usertext = f\"user: {myprompt}\"\n        writehistory(usertext)\n        # 차후 사용을 위해 대화 상대의 응답을 표시\n```\n\n여기에 이상한 writehistory(usertext) 지시문을 추가하고 있는 것을 볼 수 있습니다. 기억하시나요? 처음에 이 함수를 선언했던 거죠? 저는 모든 대화 내용을 로컬 텍스트 파일에 저장하는 버릇이 있어요. 이는 프롬프트를 분석하거나 미래 활용을 위해 자료를 조직화할 때 매우 편리합니다.🙂\n\n<div class=\"content-ad\"></div>\n\n프롬프트에서 제출된 내용을 확인한 후, gradio 클라이언트 인스턴스(client.submit)를 호출하고 스트리밍을 시작합니다 (message_placeholder.markdown(r[1][0][1]+ \"▌\"))\n\n```js\n    # 채팅 메시지 컨테이너에 어시스턴트 응답 표시\n    with st.chat_message(\"assistant\"):\n        message_placeholder = st.empty()\n        full_response = \"\"\n        res  =  client.submit(\n                query=myprompt,\n                history=[],\n                system=\"You are a helpful assistant.\",\n                api_name=\"/model_chat\"\n                )        \n        for r in res:\n            full_response=r[1][0][1]\n            message_placeholder.markdown(r[1][0][1]+ \"▌\")\n\n        message_placeholder.markdown(full_response)\n        asstext = f\"assistant: {full_response}\"\n        writehistory(asstext)       \n        st.session_state.messages.append({\"role\": \"assistant\", \"content\": full_response})\n```\n\n이게 전부에요. full_response는 최종 텍스트가 들어 있는 변수이므로 대화 기록에도 추가하여 표시합니다.\n\n해결했으면 댓글에 알려주세요 👍\n\n<div class=\"content-ad\"></div>\n\n파이썬 파일을 저장한 후 터미널에서 가상 환경을 활성화한 상태에서 다음과 같이 실행하세요.\n\n```js\nstreamlit run .\\st-Qwen1.5-110B-Chat.py\n```\n\n아래처럼 나와야 합니다... 그리고 기본 브라우저가 로컬 URL인 http://localhost:8501로 열리게 됩니다.\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png)\n\n<div class=\"content-ad\"></div>\n\nStreamlit은 로컬 네트워크로의 편리한 라우팅을 제공합니다. 예를 들어, 핸드폰이 동일한 액세스 포인트에 연결되어 있으면 Network URL로 표시된 주소인 http://192.168.2.6:8501을 통해 핸드폰에서도 이 애플리케이션을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_1.png)\n\n# 다른 모델 실행에 대한 참고 사항\n\nGitHub 리포지토리에서도 Streamlit Python 파일을 실행하는 방법을 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- OpenELM 3B\n- Phi-3-mini-Instruct 128k\n- QwenMoE\n\n고객 구성이 변경될 예정입니다 (물론...) 그리고 스트리밍 지침도 변경될 것입니다. 이는 API 엔드포인트가 다른 데이터 유형을 반환하기 때문에 발생합니다. OpenELM 및 Phi-3의 경우 순수한 문자열이 반환되므로 어떠한 사전/튜플 위치에 있는 LLM 응답을 추출할 필요가 없습니다. 여기를 살펴보세요:\n\n그리고 또한 PLEASE, 기억해주세요...\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 모든 복잡성을 다루는 이유는 무엇일까요? 우리는 어떻게 일하는지 배우고, 나만의 AI 비서를 만드는 방법을 알고 싶기 때문입니다. 내가 상상할 수 있는 최고의 목적을 위해 콘텐츠 생성, 학습 자료, 프레젠테이션, 교육 지원 등.\n\n어디에 사용할 건가요?\n\n글이 마음에 드셨으면 좋겣습니다. 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면 다음을 해볼 수 있습니다 :\n\n<div class=\"content-ad\"></div>\n\n- 이 이야기에 대해 많이 박수를 쳐 주세요\n- 기억할 가치가 있는 부분을 강조하십시오 (나중에 찾기 쉽고, 더 나은 기사를 쓰는 데 도움이 될 것입니다)\n- Build Your Own AI를 시작하는 방법을 배우려면, 무료 eBook을 다운로드하세요\n- 내 링크를 사용하여 Medium 멤버십 가입하기 - (무제한 Medium 이야기를 읽으려면 매달 $5)\n- Medium에서 나를 팔로우하기\n- 내 최신 기사 읽기 https://medium.com/@fabio.matricardi\n\n여기 몇 가지 더 흥미로운 읽을거리:\n\n추가 학습 자료\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_3.png)\n\n<div class=\"content-ad\"></div>\n\n이 이야기는 Generative AI Publication에서 발행되었습니다.\n\n최신 AI 이야기를 놓치지 않으려면 Substack, LinkedIn 및 Zeniteq에서 저희와 연락하여 AI의 미래를 함께 창조해보세요!\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_4.png)","ogImage":{"url":"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png"},"coverImage":"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png","tag":["Tech"],"readingTime":9},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h1: \"h1\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"제1부에서는 수십억 개의 매개변수를 가진 큰 언어 모델에 무료로 액세스하고 활용할 수 있다는 것을 발견했어요. 제처럼 여러분도 하드웨어 한정으로 고민 중이라면, 이 해킹 방법은 하이엔드 GPU나 유료 구독 없이도 Qwen-110B-chat과 같은 대규모 모델과 상호 작용할 수 있는 기쁨을 선사할 거예요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제2부에서는 지금부터 체험을 더 향상시키기 위해 스트림릿 인터페이스로 동일한 개념을 적용하여 챗봇에 시각적으로 매력적인 스트리밍 효과를 추가할 거예요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"과정을 되짚어보자면, Python, Gradio_client 및 코딩 능력이 필요해요. AI 챗봇을 텍스트 인터페이스를 통해 만드는 데 초점을 맞추었어요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"환경 설정: 먼저 가상 환경을 만들고 필요한 패키지(huggingface_hub, gradio-client 및 streamlit)를 설치하세요. PyTorch나 TensorFlow가 필요하지 않으며, 상호 작용은 API를 통해 이루어질 거예요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Hugging Face API 토큰: 사용자는 Hugging Face에 등록하고 모델 추론 API에 액세스하기 위해 API 토큰을 생성해야 해요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"챗봇 코딩: Hugging Face Spaces에서 Gradio의 \\\"API를 통해 사용\\\" 기능을 활용하여 이러한 강력한 모델에 Python 코드로 연결하는 방법을 배웠어요. 특히 여러 언어로 상업적 이용을 위한 라이선스가 허용되는 Qwen 시리즈 모델에 초점을 맞췄어요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"스트리밍 효과: 코드 구조를 살펴보면, 모델과 상호 작용할 수 있는 함수를 만드는 방법을 설명했어요. predict() 및 submit() 메서드 중에서 선택하여 스트리밍 효과와 함께 또는 없이 응답을 생성하는 방법을 강조했어요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"조금 헤매고 있다면 part 1부터 시작하는 것을 제안해요:\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"핵심 코드부터 Streamlit 인터페이스까지\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이걸 꼭 말해야 해요: 터미널에서 모든 앱이 정상 작동하지 않으면 그래픽 인터페이스를 시작하지 말아야 해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이건 필수 조건이에요! 그래서 Streamlit 인터페이스를 만드는 것이 아주 쉬울 거에요: 이미 이전 파트에서 라이브러리와 상호작용이 어떻게 작동하는지 확인했기 때문이죠.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 것은 이 핵심을 중심으로 움직입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" gradio_client \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Client\"\n        }), \"\\n\\nclient = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Client\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Qwen/Qwen1.5-110B-Chat-demo\\\"\"\n        }), \")\\nresult = client.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"submit\"\n        }), \"(\\n        query=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'What is Science?'\"\n        }), \",\\n        history=[],\\n        system=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"You are a helpful assistant.\\\"\"\n        }), \",\\n        api_name=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/model_chat\\\"\"\n        }), \"\\n)\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(result)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 submit() 메소드를 사용하여 스트리밍 객체/반복자를 얻을 수 있다는 것을 알고 있습니다. Streamlit을 사용하면 스트림을 다루기가 훨씬 쉬워집니다. 사실, 애플리케이션은 항상 페이지 위젯을 새로 고치기 때문에 텍스트 애플리케이션에서 사용되는 지루한 알고리즘을 무시할 수 있습니다. 기억하시나요?\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"    final = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" chunk \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"result\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" final == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \":\\n            final=chunk[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\n            \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(chunk[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], end=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \", flush=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"else\"\n        }), \":\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"try\"\n        }), \":\\n                \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(chunk[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"replace\"\n        }), \"(final,\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \"), end=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \", flush=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\n                final = chunk[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"except\"\n        }), \":\\n                pass    \\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"string.replace()을 사용하여 이미 생성된 것에서 새로운 단어를 빼내는 작업을 했었는데, 더이상 필요하지 않아요.🥳\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Streamlit 앱\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"습관적인 사람이라... 그래서 내 코드가 다른 프로젝트와 매우 비슷하다는 사실을 발견할 수 있을 거에요. 그런데 괜찮아요! 결국, 템플릿을 적용하고 수정하는 것이 매번 처음부터 시작하는 것보다 쉽고 빠를 수 있거든.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새 파일을 만들어보세요: 제 파일은 st-Qwen1.5–110B-Chat.py라고 해요. 주요 라이브러리를 가져와 세션 상태 전역 변수를 생성하는 것부터 시작해볼까요?\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" streamlit \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" st\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" time\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" sys\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" gradio_client \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" Client\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Internal usage\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" os\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" time \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" sleep\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"hf_model\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" st.session_state:\\n    st.session_state.hf_model = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Qwen1.5-110B-Chat\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Initialize chat history\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"messages\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" st.session_state:\\n    st.session_state.messages = []\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로그램에서 전역 변수는 공유되어 사용될 수 있습니다. 또한 session_state라고 불리는 이러한 객체들이 streamlit의 매 실행마다 변경되지 않는 것을 필요로합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 2가지 주요 함수를 정의합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@st.cache_resource\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_client\"\n        }), \"():   \\n    yourHFtoken = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"hf_xxxxxxxxxxxxxxxxxxxxxxx\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"#여기에 여러분의 HF 토큰을 넣으세요\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f'\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{st.session_state.hf_model}\"\n          }), \"에 대한 API Gradio 클라이언트를 로딩 중입니다.'\"]\n        }), \")\\n    client = Client(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Qwen/Qwen1.5-110B-Chat-demo\\\"\"\n        }), \", hf_token=yourHFtoken)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" client\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 모든 채팅 메시지를 chathistory.txt에 기록하는 함수\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"writehistory\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"text\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"open\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'chathistorywen110b.txt'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'a'\"\n        }), \", encoding=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'utf-8'\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" f:\\n        f.write(text)\\n        f.write(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'\\\\n'\"\n        }), \")\\n    f.close()\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희는 @st.cache_resource 데코레이터를 사용하고 있습니다. 이는 Qwen1.5-110에 대한 API gradio 클라이언트를 Streamlit이 매 실행마다 로딩하지 않기를 원하기 때문입니다 (이는 분당 1회 이상 발생할 수 있습니다): Gradio 클라이언트 연결이 실행 중에 변경되지 않을 것이기 때문에, 이 리소스를 특별한 메모리에 캐싱하고 있습니다 (@st.cache_resource). 자세한 내용은 여기에서 확인하실 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"일부 그래픽 조정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 기본 Streamlit 페이지 요소와 챗봇에 사용할 아이콘을 설정할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"#아바타\\nav_us = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'🧑‍💻'\"\n        }), \"  # \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./man.png'\"\n        }), \"  #\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🦖\\\"\"\n        }), \"  # \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🧑‍💻\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🤖\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🦖\\\"\"\n        }), \"과 같은 단일 이모지입니다. \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Shortcut\"\n        }), \"은 지원되지 않습니다.\\nav_ass = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🤖\\\"\"\n        }), \"   #\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./robot.png'\"\n        }), \"\\n# 기본 모델 설정\\n\\n### \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"STREAMLIT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"UI\"\n        }), \" 시작\\nst.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"image\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'https://github.com/fabiomatricardi/ChatBOTMastery/raw/main/qwen100logo.png'\"\n        }), \", )\\nst.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"### *Streamlit & Gradio_client로 구동됨*\\\"\"\n        }), \", unsafe_allow_html=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \" )\\nst.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'---'\"\n        }), \")\\n\\nclient = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_client\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"채팅 인터페이스에 로컬 이미지를 사용할 수도 있어요 (코드의 주석을 참고하세요!)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"마지막으로, create_client()로 클라이언트 연결을 인스턴스화해요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"본문 — 채팅 인터페이스\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Streamlit은 자신의 위젯에 변경이 발생할 때마다 또는 입력(버튼, 선택기, 라디오 요소 등)으로 사용자 조작이 호출될 때마다 코드를 맨 위부터 다시 실행해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 저희는 대화 기록을 맨 위에 먼저 렌더링하기 시작했어요. 여기서는 뭐라도 새롭게 발명한 건 없어요: Streamlit 블로그의 공식 자습서에서 모두 배웠거든요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 표준 렌더링입니다. OpenAI API와 호환되는 chat_completion 형식에 모두 적용 가능합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드로 돌아가서, 우리는 chat_template 메시지들을 표시하고, 메시지 목록을 반복하며 사용자 프롬프트(myprompt)가 제출되기를 기다립니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 앱 재실행 시 이전 대화 내용을 보여줍니다\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" message \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"session_state\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"messages\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \"] == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"user\\\"\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_message\"\n        }), \"(message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \"],avatar=av_us):\\n            st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content\\\"\"\n        }), \"])\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"else\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_message\"\n        }), \"(message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \"],avatar=av_ass):\\n            st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content\\\"\"\n        }), \"])\\n# 사용자 입력 받기\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" myprompt := st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_input\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"인공지능 모델이란 무엇인가요?\\\"\"\n        }), \"):\\n    # 사용자 메시지를 대화 내역에 추가\\n    st.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"session_state\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"messages\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"({\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"user\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content\\\"\"\n        }), \": myprompt})\\n    # 대화 메시지 컨테이너에 사용자 메시지 표시\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_message\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"user\\\"\"\n        }), \", avatar=av_us):\\n        st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(myprompt)\\n        usertext = f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"user: {myprompt}\\\"\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"writehistory\"\n        }), \"(usertext)\\n        # 차후 사용을 위해 대화 상대의 응답을 표시\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에 이상한 writehistory(usertext) 지시문을 추가하고 있는 것을 볼 수 있습니다. 기억하시나요? 처음에 이 함수를 선언했던 거죠? 저는 모든 대화 내용을 로컬 텍스트 파일에 저장하는 버릇이 있어요. 이는 프롬프트를 분석하거나 미래 활용을 위해 자료를 조직화할 때 매우 편리합니다.🙂\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프롬프트에서 제출된 내용을 확인한 후, gradio 클라이언트 인스턴스(client.submit)를 호출하고 스트리밍을 시작합니다 (message_placeholder.markdown(r[1][0][1]+ \\\"▌\\\"))\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"    # 채팅 메시지 컨테이너에 어시스턴트 응답 표시\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_message\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"assistant\\\"\"\n        }), \"):\\n        message_placeholder = st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"empty\"\n        }), \"()\\n        full_response = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n        res  =  client.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"submit\"\n        }), \"(\\n                query=myprompt,\\n                history=[],\\n                system=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"You are a helpful assistant.\\\"\"\n        }), \",\\n                api_name=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/model_chat\\\"\"\n        }), \"\\n                )        \\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" r \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"res\"\n        }), \":\\n            full_response=r[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\n            message_placeholder.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(r[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]+ \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"▌\\\"\"\n        }), \")\\n\\n        message_placeholder.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(full_response)\\n        asstext = f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"assistant: {full_response}\\\"\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"writehistory\"\n        }), \"(asstext)       \\n        st.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"session_state\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"messages\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"({\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"assistant\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content\\\"\"\n        }), \": full_response})\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이게 전부에요. full_response는 최종 텍스트가 들어 있는 변수이므로 대화 기록에도 추가하여 표시합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해결했으면 댓글에 알려주세요 👍\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파이썬 파일을 저장한 후 터미널에서 가상 환경을 활성화한 상태에서 다음과 같이 실행하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"streamlit run .\\\\st-\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Qwen1\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".5\"\n        }), \"-110B-\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Chat\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"py\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래처럼 나와야 합니다... 그리고 기본 브라우저가 로컬 URL인 http://localhost:8501로 열리게 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Streamlit은 로컬 네트워크로의 편리한 라우팅을 제공합니다. 예를 들어, 핸드폰이 동일한 액세스 포인트에 연결되어 있으면 Network URL로 표시된 주소인 http://192.168.2.6:8501을 통해 핸드폰에서도 이 애플리케이션을 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"다른 모델 실행에 대한 참고 사항\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GitHub 리포지토리에서도 Streamlit Python 파일을 실행하는 방법을 찾을 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"OpenELM 3B\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Phi-3-mini-Instruct 128k\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"QwenMoE\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"고객 구성이 변경될 예정입니다 (물론...) 그리고 스트리밍 지침도 변경될 것입니다. 이는 API 엔드포인트가 다른 데이터 유형을 반환하기 때문에 발생합니다. OpenELM 및 Phi-3의 경우 순수한 문자열이 반환되므로 어떠한 사전/튜플 위치에 있는 LLM 응답을 추출할 필요가 없습니다. 여기를 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 또한 PLEASE, 기억해주세요...\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 모든 복잡성을 다루는 이유는 무엇일까요? 우리는 어떻게 일하는지 배우고, 나만의 AI 비서를 만드는 방법을 알고 싶기 때문입니다. 내가 상상할 수 있는 최고의 목적을 위해 콘텐츠 생성, 학습 자료, 프레젠테이션, 교육 지원 등.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"어디에 사용할 건가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"글이 마음에 드셨으면 좋겣습니다. 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면 다음을 해볼 수 있습니다 :\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이 이야기에 대해 많이 박수를 쳐 주세요\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"기억할 가치가 있는 부분을 강조하십시오 (나중에 찾기 쉽고, 더 나은 기사를 쓰는 데 도움이 될 것입니다)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Build Your Own AI를 시작하는 방법을 배우려면, 무료 eBook을 다운로드하세요\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"내 링크를 사용하여 Medium 멤버십 가입하기 - (무제한 Medium 이야기를 읽으려면 매달 $5)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Medium에서 나를 팔로우하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"내 최신 기사 읽기 https://medium.com/@fabio.matricardi\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기 몇 가지 더 흥미로운 읽을거리:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"추가 학습 자료\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 이야기는 Generative AI Publication에서 발행되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최신 AI 이야기를 놓치지 않으려면 Substack, LinkedIn 및 Zeniteq에서 저희와 연락하여 AI의 미래를 함께 창조해보세요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_4.png\",\n        alt: \"이미지\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}