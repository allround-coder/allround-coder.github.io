{"pageProps":{"posts":[{"title":"GraphQL 및 MongoDB와 React","description":"","date":"2024-05-14 12:05","slug":"2024-05-14-GraphQLandMongoDBwithReact","content":"\n\n![그림](/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png)\n\n웹 개발자들의 세계에서는 계속해서 최고의 개발 및 웹 응용 프로그램의 기능을 보여줄 수 있는 것을 찾기 위한 노력이 계속되고 있습니다. 오래된 REST API의 대안으로 최근에 인정받게 된 새롭고 흥미로운 기술이 GraphQL입니다. REST가 한 요청에 대해 자주 단일 데이터 세트를 반환하는데 반해, GraphQL은 클라이언트가 원하는 특정 데이터를 요청할 수 있습니다. 따라서 데이터 전송을 줄이는 것뿐만 아니라 서버 측 응답을 빠르고 간단하게 만드는 두 가지 과정으로 이루어집니다. GraphQL과 MongoDB의 조합은 데이터 처리에 있어 유연하고 효율적인 조합을 제공합니다. 이 멋진 GraphQL과 MongoDB의 조합은 개발자들이 동적 웹 응용 프로그램을 디자인하고 관리하는 방식에 혁명을 일으키고 있습니다.\n\n# GraphQL의 힘\n\nGraphQL의 가장 큰 장점은 그 유연성입니다. 개발자들은 쿼리를 최적화하여 필요한 모든 데이터를 한 군데서 얻을 수 있습니다. 이로 인해 REST API에 대해 여러 차례의 연이은 요청이 필요하지 않아집니다. 현재 장치의 다양성 및 네트워크 조건의 변동성에 매우 중요합니다.\n\n\n\nGraphQL, MongoDB 및 React가 웹 개발의 주요 도구로 사용될 때, 이러한 도구들은 개발 프로세스를 자동화할 수 있게 되었습니다. 이것은 완전히 다르게 만듭니다. 문서 중심의 NoSQL 데이터베이스 시스템인 MongoDB는 대량의 비구조화 정보를 처리하는 우수한 옵션을 제공하며, 동적이고 구조화되지 않은 GraphQL 요청을 쿼리하는 데 매우 빠르고 유연합니다. React의 선언 기반 특성을 활용하여 사용자 인터페이스를 구축하고 응용 프로그램의 상태를 처리하는 것은 매우 적합합니다. React는 데이터베이스에서 사용자 인터페이스로 실시간 데이터를 제공하여 GraphQL의 동적이고 견고한 특성을 보완합니다.\n\n본 글에서는 GraphQL을 통해 MongoDB와 통신하고 React 애플리케이션을 통합하는 과정, GraphQL 서버 설정 방법 및 데이터베이스 상호작용을 최적화하기 위한 최선의 방법에 대해 살펴보겠습니다. 이러한 기술의 결합을 통해 프로그래밍 시간을 최소화하고 애플리케이션의 유지 보수를 간소화할 뿐만 아니라, 고성능 및 확장 가능한 웹 애플리케이션을 구축할 수 있는 기회를 제공합니다.\n\n# GraphQL 기초\n\n2015년 Facebook 팀이 설계한 GraphQL은 API용 쿼리 언어로 볼 수 있으며, 동시에 제공된 데이터를 기반으로한 쿼리 실행 메커니즘을 제공합니다. 이를 통해 기업은 API 데이터를 완전하고 의미 있게 설명하여 고객이 정확히 필요한 것만 요청할 수 있도록 합니다. 결과적으로 네트워크 개선으로 이어지고, 네트워크 부하가 줄어듭니다.\n\n\n\n# 스키마와 타입\n\nGraphQL 스키마는 API의 중심 요소입니다. GraphQL 스키마는 데이터 유형과 그들 사이의 관계를 정의하며, 따라서 쿼리는 클라이언트가 원하는 것과 정확히 일치하도록 구성됩니다. 설명은 목록처럼 보이며 위치에는 유형이 있을 수 있습니다. 그들은 더 유연하고 복잡한 데이터 구조를 만들 수 있도록 유형의 유형일 수도 있습니다.\n\n# 쿼리\n\nGraphQL의 쿼리는 정적 특성 모음과 달리, GraphQL에서는 일치하는 스키마에서 제공된 유형에 해당하는 모든 데이터를 포함할 수 있습니다. GraphQL의 경우 클라이언트는 자주 REST API에서 발생하는 불필요한 정보 전달 없이 정확히 필요에 맞는 방식으로 데이터를 검색할 수 있습니다.\n\n\n\nGraphQL에서의 예시 쿼리는 다음과 같을 수 있어요:\n\n```js\n{\n  user(id: \"1\") {\n    name\n    email\n    friends {\n      name\n    }\n  }\n}\n```\n\n이 쿼리는 사용자의 이름, 이메일, 그리고 친구들의 이름에 대한 정보만 요청하고, 사용자와 친구들에 대한 다른 모든 정보는 제외합니다.\n\n# 뮤테이션(mutations)\n\n\n\nGraphQL에서 돌연변이는 데이터를 수정하는 데 사용됩니다. 쿼리와 마찬가지로 돌연변이는 스키마에 의해 정의되며 클라이언트가 데이터를 정확하고 제어된 방식으로 변경할 수 있도록 합니다. 돌연변이는 다음과 같이 보일 수 있습니다:\n\n```js\nmutation {\n  addUser(name: \"John Doe\", email: \"john@example.com\") {\n    id\n    name\n    email\n  }\n}\n```\n\n이 예제에서 addUser 돌려변이는 지정된 이름과 이메일 주소를 가진 새로운 사용자를 추가하고 새로 생성된 사용자에 대한 정보를 반환합니다.\n\n# Subscriptions\n\n\n\n서브스크립션은 GraphQL의 중요한 부분으로, 클라이언트가 원하는 데이터에 대한 실시간 알림을 받을 수 있는 기능을 제공합니다. 이는 대화방이나 게임과 같이 데이터의 지속적인 업데이트가 필요한 애플리케이션에서 특히 유용합니다. GraphQL의 서브스크립션은 다음과 같이 구현할 수 있습니다:\n\n```js\nsubscription {\n  messageAdded(channelId: \"1\") {\n    id\n    content\n    sender {\n      name\n    }\n  }\n}\n```\n\n채널에 새로운 게시물이 추가될 때, 모든 구독자는 즉시 게시물의 세부 정보를 포함한 알림을 받습니다.\n\n# REST와의 비교\n\n\n\nREST에서 볼 수 있는 데이터의 형태와 볼륨을 결정하는 데 서버가 가지는 고민과는 달리, GraphQL에서는 실제로 데이터를 요청하는 것이 클라이언트에 달려 있습니다. 이는 검색된 데이터를 필요한 것만으로 줄이고 데이터 상호작용이 어떻게 일어나는지에 대한 클라이언트의 제어를 더 많이 제공합니다. 이 GraphQL의 기능은 오늘날 고성능과 속도를 요구하는 웹 애플리케이션에 이상적입니다.\n\n# GraphQL 서버 구성\n\nMongoDB 및 React와 결합하여 GraphQL의 모든 잠재력을 실현하는 첫 번째 단계는 GraphQL 서버를 생성하는 것입니다. 이 섹션에서는 이 접근 방식을 사용하여 서버를 생성하고 실행하는 방법을 배우게 됩니다. 이 스택은 React 및 Apollo Client를 사용하여 프런트엔드 애플리케이션, Express 및 Apollo Server를 사용하는 백엔드, 그리고 Mongoose 라이브러리를 통해 서버리스 Mongo DB로 구성됩니다.\n\n# 단계 1: 몇 가지 설치 의존성을 추가하여 프로젝트를 개인화하세요.\n\n\n\n첫 번째로, 새로운 노드를 생성하세요. 먼저 새 브라우저 인스턴스를 열고 JS 프로젝트를 수행해야 하는 설치 페이지로 이동한 다음 필요한 패키지를 설치해주세요. 터미널을 열고 다음 명령을 실행하세요:\n\n```js\nmkdir graphql-mongo-server\ncd graphql-mongo-server\nnpm init -y\nnpm install apollo-server-express express graphql mongoose\n```\n\n이러한 명령은 프로젝트를 위한 새 디렉토리를 생성하고, 새로운 Node.js 프로젝트를 초기화하며 필요한 종속성을 설치합니다.\n\n# 단계 2: Express 및 Apollo Server 구성\n\n\n\n`index.js` 파일을 만들고 Express 서버 구성 및 GraphQL 쿼리를 처리하기 위해 Apollo Server를 통합하세요.\n\n```js\n// index.js\n\nconst express = require('express');\nconst { ApolloServer, gql } = require('apollo-server-express');\n\nconst app = express();\n\n// GraphQL 스키마 정의\nconst typeDefs = gql`\n  type Query {\n    hello: String\n  }\n`;\n\n// 리졸버 구현\nconst resolvers = {\n  Query: {\n    hello: () => '안녕, 세상아!'\n  }\n};\n\n// Apollo 서버 생성\nconst server = new ApolloServer({ typeDefs, resolvers });\n\n// Express 미들웨어에 Apollo 적용\nserver.applyMiddleware({ app });\n\nconst PORT = 4000;\napp.listen(PORT, () =>\n  console.log(`서버가 http://localhost:${PORT}${server.graphqlPath} 에서 실행 중입니다.`)\n);\n```\n\n# Step 3: MongoDB 연결\n\nMongoose를 사용하여 프로젝트에 MongoDB를 추가하세요. 이를 위해 `index.js` 파일을 업데이트하여 데이터베이스에 연결하는 코드를 추가하세요.\n\n\n\n```js\nconst mongoose = require('mongoose');\n\n// MongoDB에 연결\nmongoose.connect('mongodb://localhost:27017/mygraphqlapp', {\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n});\nmongoose.connection.once('open', () => {\n  console.log('MongoDB 데이터베이스에 연결되었습니다');\n});\n```\n\n로컬호스트:27017/mygraphqlapp를 귀하의 데이터베이스 연결 문자열로 교체해 주세요.\n\n# 단계 4: GraphQL 모델 및 스키마 정의\n\nMongoose 데이터 모델의 정의를 형식화하고 이러한 모델을 사용하여 GraphQL 스키마를 설정합니다. 예를 들어, 사용자 모델을 생성하고 이를 GraphQL 스키마에 추가합니다.\n\n\n\n\n```js\n// Mongoose 사용자 모델 정의\nconst User = mongoose.model('User', new mongoose.Schema({\n  name: String,\n  email: String,\n  age: Number\n}));\n\n// GraphQL 스키마 확장\nconst typeDefs = gql`\n  type User {\n    id: ID!\n    name: String\n    email: String\n    age: Int\n  }\n  type Query {\n    users: [User]\n  }\n  type Mutation {\n    addUser(name: String!, email: String!, age: Int): User\n  }\n`;\nconst resolvers = {\n  Query: {\n    users: () => User.find({})\n  },\n  Mutation: {\n    addUser: async (_, { name, email, age }) => {\n      const user = new User({ name, email, age });\n      await user.save();\n      return user;\n    }\n  }\n};\n```\n\n이러한 단계를 통해 MongoDB 연결이 준비된 기본 GraphQL 서버를 생성할 수 있습니다. React 애플리케이션과 효율적으로 상호작용하는 쿼리 및 뮤테이션을 처리하기 위해 이 서버를 사용할 수 있습니다.\n\n# React에서의 GraphQL 통합\n\nGraphQL 서버를 설정하면 다음으로 할 일은 해당 서버를 React 앱과 통합하는 것입니다. Apollo Client를 통해 GraphQL 서버에 쉽게 쿼리 및 뮤테이션을 수행할 수 있어 MongoDB 데이터와 동적 상호작용을 가능하게 할 수 있습니다. 이 경우에는 React에 Apollo Client를 추가하고 이 섹션에서 몇 가지 작업을 찾아보는 방법을 살펴볼 것입니다.\n\n\n\n\n# 단계 1: Apollo Client 설치하기\n\n먼저 React 프로젝트에 필요한 Apollo Client 패키지를 설치해보세요:\n\n```js\nnpm install @apollo/client graphql\n```\n\n# 단계 2: Apollo Client 사용자 정의하기\n\n\n\nApollo Client의 인스턴스를 생성하고 React 애플리케이션에 연결해보세요. 이를 위해 다음 코드를 ApolloClient.js와 같은 파일에 추가해주세요:\n\n```js\nimport { ApolloClient, InMemoryCache, HttpLink, from } from '@apollo/client';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:4000/graphql' // 여러분의 GraphQL 서버 URL로 교체해주세요\n});\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: from([httpLink])\n});\nexport default client;\n```\n\n# 단계 3: Apollo Provider 통합\n\nReact 앱을 ApolloProvider로 감싸서 쿼리와 뮤테이션을 앱의 모든 컴포넌트에서 사용할 수 있게 만들어보세요. App.js에서:\n\n\n\n```js\nimport React from 'react';\nimport { ApolloProvider } from '@apollo/client';\nimport client from './ApolloClient';\nimport Users from './components/Users';\n\nfunction App() {\n  return (\n    <ApolloProvider client={client}>\n      <div className=\"App\">\n        <h1>GraphQL and React</h1>\n        <Users />\n      </div>\n    </ApolloProvider>\n  );\n}\nexport default App;\n```\n\n# 단계 4: 쿼리와 뮤테이션 만들고 사용하기\n\nGraphQL과 상호 작용하기 위해 useQuery와 useMutation 훅을 사용하는 React 컴포넌트를 만듭니다. 사용자를 표시하고 새 사용자를 추가하는 컴포넌트 예제:\n\n```js\nimport React, { useState } from 'react';\nimport { useQuery, useMutation, gql } from '@apollo/client';\n\nconst GET_USERS = gql`\n  query {\n    users {\n      id\n      name\n      email\n    }\n  }\n`;\n\nconst ADD_USER = gql`\n  mutation AddUser($name: String!, $email: String!) {\n    addUser(name: $name, email: $email) {\n      id\n      name\n      email\n    }\n  }\n`;\n\nfunction Users() {\n  const { data, loading, error } = useQuery(GET_USERS);\n  const [addUser] = useMutation(ADD_USER);\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error :(</p>;\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n    if (name && email) {\n      await addUser({ variables: { name, email } });\n      window.location.reload(); // 추가 후 간단히 페이지 새로고침\n    }\n  };\n  return (\n    <div>\n      <form onSubmit={handleSubmit}>\n        <input\n          type=\"text\"\n          placeholder=\"이름\"\n          value={name}\n          onChange={e => setName(e.target.value)}\n        />\n        <input\n          type=\"email\"\n          placeholder=\"이메일\"\n          value={email}\n          onChange={e => setEmail(e.target.value)}\n        />\n        <button type=\"submit\">사용자 추가</button>\n      </form>\n      <ul>\n        {data && data.users.map(user => (\n          <li key={user.id}>{user.name} - {user.email}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\nexport default Users;\n```\n\n\n\n본 코드는 React 애플리케이션에서 GraphQL을 사용하여 데이터를 가져와 서버로 전송하는 예시입니다. 주어진 예시는 당신의 애플리케이션의 더 정교한 요구사항과 기능에 맞게 개선하고 일반화할 수 있습니다.\n\n# 실제 예시: 할 일 앱\n\n이어서, 웹 개발 기초를 학습하는 초보자들에게 표준 연습으로 사용되는 To-Do 애플리케이션을 만들어 봅시다. 이 특정 섹션에서는 우리의 프론트엔드로 React를 구현하고 데이터 관리를 위해 GraphQL을 사용하며, 데이터 저장소로 MongoDB를 사용할 간단한 Todo 애플리케이션을 만들어 보겠습니다. 이 프로젝트는 작업 생성, 편집 및 삭제와 같은 항목을 다룰 것입니다.\n\n# 단계 1: MongoDB 데이터베이스 구성하기\n\n\n\nMongoDB를 설치하여 작업 데이터를 저장하는 것이 첫 번째 단계입니다. Mongoose를 사용하여 MongoDB에 Todo 항목을 위한 스키마를 만듭니다:\n\n```js\nconst mongoose = require('mongoose');\n\nconst { Schema } = mongoose;\n\nconst todoSchema = new Schema({\n  text: String,\n  completed: Boolean\n});\n\nconst Todo = mongoose.model('Todo', todoSchema);\n```\n\n# 단계 2: GraphQL 스키마 만들기\n\nTodo 요소를 관리하는 데이터 유형, 쿼리 및 뮤테이션을 포함하는 GraphQL 스키마를 정의합니다.\n\n\n\n```js\n상수 { gql } = require ('apollo-server-express')를 가져와주세요.\n\nconst typeDefs = gql`\n  type Todo {\n    id: ID!\n    text: String!\n    completed: Boolean!\n  }\n  type Query {\n    todos: [Todo]\n  }\n  type Mutation {\n    addTodo(text: String!): Todo\n    updateTodo(id: ID!, completed: Boolean!): Todo\n    deleteTodo(id: ID!): Todo\n  }\n`;\n\n# 단계 3: 리졸버 구현하기\n\n다음 단계는 GraphQL을 위한 리졸버를 구현하는 것인데, 이는 데이터베이스와 상호작용하는 논리를 제공합니다.\n\nconst resolvers = {\n  Query: {\n    todos: () => Todo.find({})\n  },\n  Mutation: {\n    addTodo: async (_, { text }) => {\n      const todo = new Todo({ text, completed: false });\n      await todo.save();\n      return todo;\n    },\n    updateTodo: async (_, { id, completed }) => {\n      return Todo.findByIdAndUpdate(id, { completed }, { new: true });\n    },\n    deleteTodo: async (_, { id }) => {\n      return Todo.findByIdAndRemove(id);\n    }\n  }\n};\n```\n\n\n\n# 단계 4: Apollo Client를 통합하여 React와 통합\n\nReact 애플리케이션에 Apollo Client를 통합하고 작업을 표시 및 관리하는 컴포넌트를 만듭니다:\n\n```js\nimport React from 'react';\nimport { useQuery, useMutation, gql } from '@apollo/client';\n\nconst GET_TODOS = gql`\n  query {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst ADD_TODO = gql`\n  mutation AddTodo($text: String!) {\n    addTodo(text: $text) {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nfunction Todos() {\n  const { data, loading, error } = useQuery(GET_TODOS);\n  const [addTodo] = useMutation(ADD_TODO);\n\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error :(</p>;\n\n  const handleAddTodo = async text => {\n    if (text) {\n      await addTodo({ variables: { text } });\n    }\n  };\n\n  return (\n    <div>\n      <ul>\n        {data.todos.map(todo => (\n          <li key={todo.id}>\n            {todo.text}\n          </li>\n        ))}\n      </ul>\n      <button onClick={() => handleAddTodo('새 작업 추가')}>작업 추가</button>\n    </div>\n  );\n}\n\nexport default Todos;\n```\n\n# 단계 5: 사용자 인터페이스 구현\n\n\n\n간단한 사용자 인터페이스를 React로 개발해보세요. 사용자들이 작업을 추가하고 완료된 것으로 표시하거나 작업을 삭제할 수 있게 만들어보세요. 복잡한 양식이나 버튼을 사용하여 작업을 구성할 필요는 없습니다.\n\n위에서 언급된 조치들은 React 애플리케이션과 GraphQL 서버 간에 완전한 통신을 제공하며 데이터베이스로 MongoDB를 사용합니다. 이를 통해 빠르고 효율적으로 작동하는 애플리케이션이 생성됩니다.\n\n# 결론\n\n따라서, 우리는 GraphQL, MongoDB 및 React를 결합하는 방법을 찾았습니다. 이 두 기술의 결합은 웹 애플리케이션의 성능을 실제로 향상시키며 개발 복잡성을 크게 줄일 수 있습니다. 이 기술 스택을 중요시하는 몇 가지 주요 포인트를 살펴봅시다.\n\n\n\n# GraphQL을 사용해야 하는 이유\n\n- 요청한 대로: GraphQL을 사용하면 필요한 데이터만 요청할 수 있어서 불필요한 데이터 없이 작업할 수 있습니다. 이는 더 적은 데이터 전송 및 빠른 페이지 로딩으로 이어집니다.\n- 한 곳을 통해 모두 처리: REST API의 여러 엔드포인트에 작별을 고한다면, GraphQL은 하나의 통합된 지점을 통해 통신하여 코드를 추적 가능하고 아키텍처를 더욱 명료하게 만듭니다.\n- 실시간 업데이트: GraphQL을 사용하면 채팅이나 협업과 같이 데이터가 지속적으로 업데이트되는 기능을 쉽게 구현할 수 있습니다.\n\n\n# GraphQL을 강력하게 만드는 것은 무엇인가요?\n\n- 유연성과 강력함: MongoDB는 데이터 저장을 유연하게 제공하며, 반면에 React는 사용자 인터페이스를 유연하게 구축하는 데 도움을 줍니다. 이 두 가지를 팀으로 사용하면 모든 요구 사항에 손쉽게 조정될 수 있는 좋은 조합이 될 수 있습니다.\n- 개발이 쉬워짐: 이 스택은 GraphQL API의 명확한 규칙 덕분에 코드를 줄이고 개발 단계마다 확신을 키울 수 있도록 도와줍니다.\n\n\n\n# GraphQL과 MongoDB의 성능 영향\n\nGraphQL, React, 그리고 MongoDB가 함께 작동하면 여러분의 일상이 간소화되고 응용 프로그램은 더 빠르게 반응합니다. 쿼리 최적화는 서버 및 네트워크 부하를 줄이고 데이터 처리 속도를 높여 인터페이스를 더 반응적으로 만듭니다. 따라서 사용자들의 눈에 띄게 제품 품질을 향상하는 중요한 요소입니다.\n\n요약하면, 더 강력한 웹 응용 프로그램을 만들고 싶다면 더 빠르고 개발하기 쉬운 웹 응용 프로그램을 만들어야 한다면 GraphQL, MongoDB 및 React의 세트가 반드시 필요합니다. 이것은 분명히 수익성이 입증된 프로젝트의 미래에 대한 장기적인 투자입니다!","ogImage":{"url":"/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png"},"coverImage":"/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png","tag":["Tech"],"readingTime":13},{"title":"로컬 Gemma 모델과 연결하는 LM Studio를 통한 간단한 React 앱 UI","description":"","date":"2024-05-14 12:04","slug":"2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio","content":"\n\n로컬 데이터를 Gemma를 통해 LM Studio로 처리함으로써 정보를 외부 서버로 보내지 않고 제어할 수 있습니다. 이 방식은 민감한 문서나 개인 데이터를 다룰 때 데이터 개인 정보 보호와 보안을 보장합니다. 이 기사에서는 로컬 LLM과 상호작용하기 위해 간단한 React 앱 GUI를 사용하는 방법을 살펴보겠습니다.\n\nLM Studio 및 Gemma 모델 설치\n\n```js\nhttps://lmstudio.ai/\n```\n\nWindows / Linux / Mac 버전을 다운로드하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_0.png)\n\n이제 노트북/PC/서버에 적합한 모델을 찾아보세요.\n\n우리는 Gemma Model을 사용하고 있습니다. 이는 기계 학습에 경험이 제한된 개발자들에게도 쉽게 사용할 수 있습니다. 그들의 가벼운 특성은 접근성이 높고 사용하기 편리합니다.\n\n![이미지](/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_1.png)\n\n\n\n다운로드 후에는 왼쪽 메뉴에서이 모델을 로컬 서버에서 제공하는 옵션을 찾을 수 있습니다. 선택한 후 위쪽 드롭다운에서 사용 가능한 로컬 모델 목록을 선택하고 \"서버 시작\"을 클릭할 수 있습니다. 오른쪽 메뉴에서는 로컬 모델의 설정을 사용자 정의할 수 있습니다. 샘플 코드 섹션에서 API Curl 명령을 볼 수 있습니다. 로컬호스트 URL 및 API의 매개변수가 표시됩니다.\n\n![이미지](/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_2.png)\n\n이제 LM Studio 설정이 완료되었으며 Gemma 모델이 로컬 API로 이용 가능해졌습니다.\n\n간단한 React App GUI를 작성하여 Gemma 모델의 로컬 LM Studio API와 상호 작용해 보겠습니다. 나중에 이 코드를 사용하여 직접 응용 프로그램에서 사용할 수 있습니다.\n\n\n\nReact GUI\n\n설정\n\n여기서는 React 앱에 Vite를 사용하고 있습니다.\n\n```js\nnpm create vite@latest\n```\n\n\n\n프롬프트 메뉴에서 Framework를 React로, Variant를 Javascript로 선택하고 해당 디렉토리로 이동하여 설치하세요.\n\n```js\nnpm install\n```\n\n앱을 미리 보기하려면 다음을 실행하세요.\n\n```js\nnpm run dev\n```\n\n\n\n웹 브라우저를 열고 http://localhost:5173/ 로 이동하세요.\n\n무료 사이트에서 lens.png 및 loading.gif 두 개의 이미지를 다운로드하여 assets 디렉토리에 추가하세요.\n\n이제 아래 코드를 사용하여 3개 파일을 업데이트하세요.\n\nApp.jsx\n\n\n\n```js\nimport { useState, useEffect } from 'react'\nimport reactLogo from './assets/react.svg'\nimport viteLogo from '/vite.svg'\nimport './App.css'\nimport lens from \"./assets/lens.png\";\nimport loadingGif from \"./assets/loading.gif\";\n\nfunction App() {\n\n  const [prompt, updatePrompt] = useState(undefined);\n  const [loading, setLoading] = useState(false);\n  const [answer, setAnswer] = useState(undefined);\n\n  useEffect(() => {\n    if (prompt != null && prompt.trim() === \"\") {\n      setAnswer(undefined);\n    }\n  }, [prompt]);\n\n  const sendPrompt = async (event) => {\n    if (event.key !== \"Enter\") {\n      return;\n    }\n\n    try {\n      setLoading(true);\n\n      const requestOptions = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(\n          \n          { \n            model: \"lmstudio-ai/gemma-2b-it-GGUF\", \n            temperature : 0.7,\n            max_tokens : -1,\n            messages: [ { role : \"user\", content : `${prompt}` },] \n          },\n        ),\n      };\n\n      const res = await fetch(\"/api/v1/chat/completions\", requestOptions);\n  \n      if (!res.ok) {\n        throw new Error(\"Something went wrong\");\n      }\n      const testresp = await res.json();\n      console.log(testresp.choices[0].message.content);\n      setAnswer(testresp.choices[0].message.content);\n\n    } catch (err) {\n      console.error(err, \"err\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <>\n      <div>\n        <a href=\"https://vitejs.dev\" target=\"_blank\">\n          <img src={viteLogo} className=\"logo\" alt=\"Vite logo\" />\n        </a>\n        <a href=\"https://react.dev\" target=\"_blank\">\n          <img src={reactLogo} className=\"logo react\" alt=\"React logo\" />\n        </a>\n      </div>\n      <h1>React Chat LLM UI</h1>\n      <input\n            type=\"text\"\n            className=\"searchlight__input\"\n            placeholder=\"Ask me anything and press enter...\"\n            disabled={loading}\n            style={\n              backgroundImage: loading ? `url(${loadingGif})` : `url(${lens})`,\n            }\n            onChange={(e) => updatePrompt(e.target.value)}\n            onKeyDown={(e) => sendPrompt(e)}\n          />\n\n        <div className=\"searchlight__answer\">{answer && <p>{answer}</p>}</div>\n\n    </>\n  )\n}\n\nexport default App\n```\n\nApp.css\n\n아래 코드로 기존의 App.css를 업데이트하세요. 원하시는 대로 사용자 정의할 수 있습니다.\n\n```js\n#root {\n  max-width: 1280px;\n  margin: 0 auto;\n  padding: 2rem;\n  text-align: center;\n}\n\n.logo {\n  height: 6em;\n  padding: 1.5em;\n  will-change: filter;\n  transition: filter 300ms;\n}\n.logo:hover {\n  filter: drop-shadow(0 0 2em #646cffaa);\n}\n.logo.react:hover {\n  filter: drop-shadow(0 0 2em #61dafbaa);\n}\n\n@keyframes logo-spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n@media (prefers-reduced-motion: no-preference) {\n  a:nth-of-type(2) .logo {\n    animation: logo-spin infinite 20s linear;\n  }\n}\n\n.card {\n  padding: 2em;\n}\n\n.read-the-docs {\n  color: #888;\n}\n\n.searchlight__input {\n  display: block;\n  height: 56px;\n  width: 80%;\n  border: 0;\n  border-radius: 12px;\n  outline: none;\n  font-size: 1.2rem;\n  color: #000;\n  background-position: left 17px center;\n  background-repeat: no-repeat;\n  background-color: #fff;\n  background-size: 3.5%;\n  padding-left: 60px;\n}\n\n.searchlight__input::placeholder {\n  line-height: 1.5em;\n}\n\n.searchlight__answer {\n  min-height: 115px;\n  line-height: 1.5em;\n  letter-spacing: 0.1px;\n  padding: 10px 30px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.searchlight__answer p::after {\n  content: \"\";\n  width: 2px;\n  height: 14px;\n  position: relative;\n  top: 2px;\n  left: 2px;\n  background: black;\n  display: inline-block;\n  animation: cursor-blink 1s steps(2) infinite;\n}\n\n@keyframes cursor-blink {\n  0% {\n    opacity: 0;\n  }\n}\n```\n\n\n\nLM Studio Local API를 호출하기 위해 Gemma를 업데이트하려면 Vite 구성 파일을 수정하십시오.\n\nvite.config.js\n\n```js\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:1234\",\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, \"\"),\n        onBeforeSend(proxyContext) {\n          const { req, res } = proxyContext;\n          const { url, method, headers, rawBody } = req;\n          return proxyContext;\n        },\n      },\n    },\n  },\n});\n```\n\n샘플 출력:\n\n\n\n![이미지](/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_3.png)\n\n대체 도구: Ollama는 로컬 서버에서 오픈 소스 모델을 호스팅하는 또 다른 도구입니다.\n\n다음 글에서는 문서를 업로드하고 채팅하는 방법을 알아보겠습니다.\n\n해보고 느낀 점은 댓글로 공유해주세요.","ogImage":{"url":"/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_0.png"},"coverImage":"/assets/img/2024-05-14-SimpleReactAppUItoConnectwithLocalGemmaModelviaLMStudio_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트 컴포넌트 이해하기 함수 vs 클래스  모듈화된 UI 만들기를 간단하게 만들기","description":"","date":"2024-05-14 12:03","slug":"2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple","content":"\n\n리액트에서 컴포넌트는 사용자 인터페이스의 주요 구성 요소입니다. 이를 사용하면 UI를 독립적이고 재사용 가능한 조각으로 나눌 수 있으며, 각각이 자체 동작 및 렌더링 로직을 캡슐화합니다. 이 모듈식 접근 방식은 애플리케이션을 유지하고 확장하기 쉽게 만들어줍니다.\n\n![이미지](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_0.png)\n\n리액트에서 컴포넌트는 두 가지 주요 방법으로 정의할 수 있습니다: Function Components(함수 컴포넌트)와 Class Components(클래스 컴포넌트).\n\n# Function Components\n\n\n\n기능 구성 요소는 복잡한 상태 관리나 라이프사이클 메서드에 액세스할 필요가 없는 컴포넌트에 권장되며 더 간단합니다. 이들은 본질적으로 React 엘리먼트를 반환하는 JavaScript 함수입니다. 기본 예제를 살펴보겠습니다:\n\n![Welcome function component example](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_1.png)\n\n이 예제에서 Welcome은 프롭스 객체를 수락하고 간단한 인사 메시지인 React 엘리먼트를 반환하는 함수 컴포넌트입니다. 이 컴포넌트는 이름 프롭을 전달하여 UI에서 사용할 수 있습니다:\n\n![Using the Welcome function component](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_2.png)\n\n\n\n# 클래스 구성요소\n\n클래스 구성요소는 더 많은 기능을 가지고 있으며, 구성요소가 상태를 관리하거나 라이프사이클 이벤트를 처리해야 할 때 사용됩니다. 이들은 React.Component를 확장한 ES6 클래스로 정의되어 있어야 하며, React 요소를 반환하는 render() 메서드를 반드시 포함해야 합니다:\n\n![Class Components](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_3.png)\n\n이 Welcome 클래스 구성요소는 위에서 보여진 함수 구성요소와 유사하게 작동하지만 클래스로 정의되어 있습니다. 또한 render 메서드 내에서 this.props를 사용하여 props에 액세스합니다.\n\n\n\n# 컴포넌트 조합하기\n\n컴포넌트는 출력에서 다른 컴포넌트를 참조할 수 있습니다. 이 조합 기능은 리액트의 강력한 기능 중 하나로, 간단한 구성 요소에서 복잡한 UI를 구축할 수 있게 합니다. 다음은 Welcome 컴포넌트를 사용하여 부모 App 컴포넌트 안에 넣은 예제입니다:\n\n![이미지](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_4.png)\n\n이 App 컴포넌트는 세 개의 다른 이름을 가진 Welcome 컴포넌트를 렌더링하여, 컴포넌트가 다른 속성(props)과 함께 재사용될 수 있는 방법을 보여줍니다.\n\n\n\n# 컴포넌트 추출하기\n\n자주 컴포넌트가 너무 복잡해지면 작은 컴포넌트로 추출하는 것이 좋은 방법입니다. 예를 들어, Comment 컴포넌트가 있다면 Avatar와 UserInfo 컴포넌트를 추출하여 Comment 컴포넌트를 단순화할 수 있습니다:\n\n![Component Extraction](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_5.png)\n\n이 예에서 Avatar 및 UserInfo는 Comment 컴포넌트의 특정 부분을 처리하는 작은 컴포넌트이며, 주 컴포넌트를 더 깔끔하고 관리하기 쉽게 만듭니다.\n\n\n\n# 결론\n\nReact 컴포넌트는 동적이고 인터랙티브한 사용자 인터페이스를 구축하는 강력하고 다재다능한 도구입니다. 함수 컴포넌트와 클래스 컴포넌트를 이해하고 활용하며, 구성과 추출을 통해 잘 정리되고 유지보수가 쉬운 React 애플리케이션을 만들 수 있습니다.\n\n# 관련 기사\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해 주시면 좋겠어요! 👏\n- 다음 링크에서 우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 저희 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 기반 콘텐츠를 다루는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_0.png"},"coverImage":"/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_0.png","tag":["Tech"],"readingTime":3},{"title":"마이크로 프론트엔드 Vite를 이용한 React용 모듈 페더레이션","description":"","date":"2024-05-14 12:00","slug":"2024-05-14-MicroFrontendModuleFederationwithViteforReact","content":"\n\n![image](/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_0.png)\n\n백엔드 개발자를 위한 마이크로서비스 아키텍처 소개 후, 우리는 프론트엔드 애플리케이션을 위한 비슷한 아키텍처인 '마이크로 프론트엔드'를 개발하고자 합니다. 이 아키텍처는 마이크로서비스와 비슷한 이점과 단점을 가지고 있습니다. 이 아키텍처를 구현하는 방법 중 하나는 웹팩과 Vite와 같은 번들링 도구에서 제공되는 '모듈 페데레이션'입니다.\n\n# 모듈 페데레이션이란?\n\n모듈 페데레이션은 다양한 빌드가 하나의 애플리케이션을 구성하기 위해 함께 동작하는 개념입니다. 대부분의 경우 하나는 모든 다른 원격 구성 요소를 가져와 공유할 수 있도록 구축된 호스트 애플리케이션일 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_1.png\" />\n\n위의 도식은 작동 방식에 대한 간략한 설명을 보여줍니다. 호스트 애플리케이션에는 각 원격 컴포넌트에 대한 참조가 가져오기(import)나 Lazy Loaded 모듈로 포함됩니다. 각각 \"홈페이지 앱\"과 \"결제 앱\"이 호스팅된 원격 서버에서 공유 컴포넌트는 자바스크립트 모듈로 패키징되어 빌드된 자바스크립트 파일로써 공개적으로 사용 가능합니다(위의 예제에서 \"homepage.js\"와 \"payment.js\"로 확인됨). 그런 다음 호스트 애플리케이션에서 이러한 원격 컴포넌트들을 런타임에 자바스크립트 모듈로 가져와서 호스팅된 애플리케이션에서 컴포넌트로 처리됩니다.\n\n모듈 페더레이션에 대한 더 자세한 내용은 여기서 확인할 수 있습니다.\n\n# Vite에서 모듈 페더레이션을 사용하는 방법?\n\n\n\n모듈 연합 기능을 얻으려면 Vite에 플러그인을 추가해야 합니다. 플러그인은 다음에서 찾을 수 있어요!\n\n모듈 연합 기능을 얻기 위해 설정해야 할 최소한 두 군데가 항상 있어요. 하나는 공유할 컴포넌트가 있는 원격 어플리케이션에 적용돼야 해요. 이 곳에서 Vite에게 어떤 컴포넌트가 모듈로 공유될지, 빌드를 위한 진입점 이름이 무엇인지 알려주는 것이에요. 다른 설정은 모듈 연합을 사용할 호스트 어플리케이션에서 적용돼야 해요.\n\n양쪽에 적용해야 할 구성은 다음과 같아요.\n\n## 원격 어플리케이션 기본 구성\n\n\n\n```js\nexport default defineConfig({\n    plugins: [\n        react(),\n        federation({\n             name: 'remotecomponent1',\n             filename: 'remotecomponent1.js',\n             exposes: {\n                 './Button': './src/components/buttons.tsx'\n             },\n             shared: ['react', 'react-dom', 'react-router-dom'],\n        }),\n    ]\n});\n```\n\n패더레이션 플러그인의 각 필드를 살펴봅시다.\n\nName: 공유 컴포넌트를 포함한 JavaScript 모듈에 할당할 모듈 이름입니다. 필수입니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\nFileName: JavaScript 모듈의 진입 파일의 파일 이름입니다. 이 필드는 필수가 아니며, 기본값은 `remoteEntry.js`입니다. 자세한 내용은 여기에서 확인할 수 있습니다.```\n\n\n\n공개합니다: 원격 모듈로 공개할 구성 요소를 나열해야 하는 곳입니다. 자세한 내용은 여기에서 찾을 수 있습니다.\n\n참고: 모든 노출 구성 요소는 리액트 구성 요소를 기본 내보내기로 내보내야 합니다. 그렇지 않으면 호스트 응용 프로그램 측에서 문제없이 통합할 수 없습니다. 리액트 구성 요소에서 개별 내보내기를 가져올만한 충분한 세부 정보가 없기 때문입니다.\n\n공유: 이것은 조금 복잡한 속성입니다. 라이브러리와 관련하여 리액트와 같은 경우 모든 라이브러리 사이에서 상태를 처리하기 위해 모든 라이브러리 사이에서 하나의 인스턴스를 공유해야 합니다. 따라서 원격 모듈을 사용할 때 리액트 인스턴스를 원격 모듈과 호스트 응용프로그램 모두에서 사용하는 방법이 필요합니다. 이를 위해 호스트 측 구성 및 원격 응용 프로그램 측 구성에 이 속성을 추가하고 공유할 라이브러리 목록을 양쪽에 모두 추가하면 됩니다. 무엇을 공유할지 알리려면 이 속성을 사용하면 됩니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\n# 호스트 응용 프로그램 기본 구성\n\n\n\n호스트 애플리케이션을 구성하는 두 가지 방법이 있습니다. 하나는 원격 모듈 진입 파일의 URL을 직접 참조하는 것이고, 다른 하나는 동적으로 참조를 채우는 것입니다. 두 가지 모두 원격 측에 대한 속성 세트가 비슷하지만 remotes 속성을 제외하고는 동일한 Name과 Shared 속성이 있습니다. 이에 대한 설명은 다음과 같습니다.\n\nRemotes: 원격 모듈의 진입 파일에 대한 참조를 보관합니다. 아래는 remotes 속성을 사용하는 예시입니다. 더 많은 세부 정보는 여기에서 찾을 수 있습니다.\n\n## URL을 사용하여 원격 컴포넌트 가져오기\n\n```js\nexport default defineConfig({\n    plugins: [\n        react(),\n        federation({\n             name: 'remotecomponent1',\n             remotes: {\n                 sharedComp: 'http://localhost:3001/assets/remotecomponent1.js',\n             },\n             shared: ['react', 'react-dom', 'react-router-dom'],\n        }),\n    ]\n});\n```\n\n\n\n## URL을 동적으로 적용하여 Remote 컴포넌트 가져오기\n\n```js\nexport default defineConfig({\n    plugins: [\n        react(),\n        federation({\n             name: 'remotecomponent1',\n             remotes: [\n                 {\n                     sharedComp: {\n                         external: `Promise.resolve(window.remoteURL)`,\n                         from: 'vite',\n                         externalType: 'promise',\n                     },\n                 },\n             ],\n             shared: ['react', 'react-dom', 'react-router-dom'],\n        }),\n    ]\n});\n```\n\n외부: 원격 모듈의 주소가 될 수 있으며, 기본적으로 URL 또는 `string` 형식의 Promise일 수 있습니다. 더 많은 세부 정보는 여기에서 확인할 수 있습니다.\n\nFrom: 원격 모듈이 어디에서 오는지 Vite가 알 수 있도록 하는 속성입니다. Webpack 또는 Vite에서 오는지 여부를 나타냅니다. 더 많은 세부 정보는 여기에서 확인할 수 있습니다.\n\n\n\nExternalType:는 외부 속성에서 사용할 외부 참조 유형을 설정합니다. 이 값은 url 또는 promise가 될 수 있습니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\n참고: 여기 예제에서는 window.remoteURL을 사용하여 url을 가져오고 있습니다. 따라서 이것은 호스트 애플리케이션 시작 시 설정됩니다. 따라서 이 속성은 애플리케이션의 루트 구성 요소인 app.tsx 또는 다른 곳에 설정할 수 있습니다.\n\n# 호스트 애플리케이션 내에서 원격 모듈 사용하는 방법\n\n호스트 애플리케이션의 구성 요소에서 원격 모듈을 사용하는 두 가지 방법이 있습니다.\n\n\n\n## 정적 임포트로 사용\n\n리액트 컴포넌트 내에서 원격 모듈을 항상 정적 임포트할 수 있습니다.\n\n```js\nimport Button from 'sharedComp/Button';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"card\">\n        <Button />\n      </div>\n    </div>\n  )\n}\n\nexport default App;\n```\n\n이 방법도 좋지만 성능과 신뢰성 측면에서는 가장 유망한 방법은 아닙니다. 이 방법을 사용할 때 몇 가지 문제가 발생했습니다. 또한 이 방법을 사용하면 네트워크 수준의 문제를 처리하기 어렵습니다.\n\n\n\n## 레이지로드된 모듈로\n\n이것은 성능을 향상시키고 네트워크 문제를 처리하기 위해 레이지 로딩을 사용하여 원격 모듈을 로드하는 것입니다.\n\n```js\nimport {lazy, Suspense} from 'react';\nconst Button = lazy(() => import('sharedComp/Button') as any);\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"card\">\n        <Suspense fallback={<div>Loading...</div>}>\n          <Button />\n        </Suspense>\n      </div>\n    </div>\n  )\n}\n\nexport default App;\n```\n\n이것은 원격 모듈을 사용하는 권장 방법으로, 이를 통해 네트워크 관련 문제와 성능 관련 문제를 처리할 수 있습니다.\n\n\n\n알림: 만약 TypeScript를 사용하여 구현하고 싶다면, 소스 루트에 사용자 정의 타입 선언 파일을 추가하고 remotes 구성의 이름을 모듈로 추가해야 합니다. 파일 이름은 module.d.ts와 같이 지정할 수 있습니다.\n\n```js\ndeclare module 'sharedComp/*' {}\n```\n\n# 어플리케이션 실행\n\n호스트 및 원격 어플리케이션을 실행할 때 몇 가지 주의할 점이 있습니다.\n\n\n\n- 개발 중일 때 파일 서비스가 작동하려면 개발 모드 대신 미리보기 모드에서 원격 응용 프로그램 및 호스트 응용 프로그램을 실행해야합니다. 그렇지 않으면 파일이 제공되지 않기 때문에 모듈 페더레이션이 개발 모드에서 작동하지 않습니다.\n- 또한 구성 요소를 공유할 때 javascript 모듈로 공유되고 응용 프로그램으로 공유되지 않는다는 것을 기억해야합니다. 응용 프로그램의 책임은 공유 모듈을 가져와 사용할 호스트 응용 프로그램에 의해 수행됩니다. 따라서 원격 구성 요소가 환경 변수나 기타 프로세스 관련 데이터를 사용하는 경우 호스트 응용 프로그램을 통해 원격 구성 요소로 전달될 것입니다. 따라서 원격 구성 요소를 사용할 때 항상 호스트 응용 프로그램이 해당 원격 구성 요소가 실행 중인 플랫폼이라는 것을 기억해주셔야 합니다. 외부 서버에서 실행 중이더라도 모듈 페더레이션을 사용할 때 전달되는 것은 파일만이며, 그 이상이 아닙니다. URL을 통해 원격 서버 측 응용 프로그램이 실행 중인 것을 볼 수는 있지만, 호스트 응용 프로그램 측에서는 단지 공유 javascript 모듈 진입 .js 파일을 참조하고 있을 뿐입니다. 따라서 원격 응용 프로그램 측에서 제공되더라도 호스트 응용 프로그램에서 모든 프로세스 관련 데이터를 제공하도록하십시오.\n\n# 지금까지 배운 내용을 기반으로 기본 시나리오를 구현해 봅시다\n\n여러 팀 간에 나눌 수 있는 다른 구성 요소가있는 사용 사례를 고려해 보겠습니다. E-Commerce 사이트를 시나리오로 삼아보겠습니다. 호스트로 E-Commerce 웹 앱을 개발하고 결제 구성 요소 및 홈페이지 구성 요소를 가져오겠습니다. 기본 시나리오로서 지금은 홈페이지 사용 사례만 구현해 보겠습니다.\n\n나는 react 및 Vite에 대한 vite-plugin-federation 샘플에서 일부 코드를 빌려와 기본 애플리케이션을 가져 와서 모듈 페더레이션의 기본 사용 사례를 보여주는 다음 애플리케이션을 만들었습니다.\n\n\n\n이 샘플에서는 웹사이트의 홈페이지를 원격 모듈로 개발했습니다. 이 모듈은 웹사이트(호스트 애플리케이션)에서 참조됩니다. 원격 모듈은 이 샘플(Main 브랜치)에서 정적 임포트로 가져오며, 원격 모듈은 정적 URL을 사용하여 참조됩니다.\n\n따라서 원격 애플리케이션에서 'Button'과 'Home' 두 가지 컴포넌트를 노출시켰습니다. 그리고 이들을 'homepage.js'라는 entry 파일 이름을 가진 모듈에 추가했습니다.\n\n이제 원격 애플리케이션에서 공유된 Home 컴포넌트를 살펴보겠습니다.\n\n여기서 컴포넌트를 자세히 살펴보면 default로 노출된 것을 볼 수 있습니다. 공유된 컴포넌트를 default로 내보내는 것이 중요합니다. 컴포넌트를 default로 내보내지 않으면 호스트 애플리케이션 측에서 이를 참조하는 것이 어려워집니다.\n\n\n\n호스트 애플리케이션 측에서 원격 모듈을 사용할 때 정적 임포트를 사용할 수 있습니다.\n\n그리고 각 구성 요소를 가져온 후에는 일반 구성 요소와 마찬가지로 사용할 수 있습니다. 그러나 실제 프로덕션 환경에서는 원격 모듈이 시간에 따라 사용할 수 없을 수 있으므로 정적 임포트 사용 시 문제가 발생할 수 있습니다. 따라서 이러한 모듈에 대한 지연 로딩을 사용하면 네트워크 관련 문제를 처리할 때 도움이 됩니다. 이 브랜치의 지연 로딩 예제를 여기에서 찾을 수 있습니다.\n\n지연 로딩을 사용하면 호스트 애플리케이션 측에서 원격 모듈을 사용하는 방법은 다음과 같습니다.\n\n6행과 7행에서 원격 모듈에서 구성 요소를 지연 로딩했습니다. 그런 다음 Suspense 구성 요소 내에서 해당 구성 요소를 사용하여 비동기로로드하고 로드하는 데 시간이 걸리는 경우 대체 구성 요소를 적용했습니다.\n\n\n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n\nAlso when importing these from remote modules if you are using typescript remember to add a custom definition file for types. So here in my implementation I have added the custom.d.ts file. This file help you to get rid of the compilation error Module not found .\n\n# Lets look in to implementing a bit advance scenario\n\nLet’s add the payment component in to the story and make this a bit more complicated. Implementation for the advance scenario can be found in this branch.\n\nThis adds bit of complexity as this uses two different remote modules to load home and payment pages and also added the complexity of react routing on to the host app. Also in this sample the payment page is loaded using a dynamically set URL which is pushed during the runtime through window object.\n\n\n\n\n호스트 애플리케이션 측에서 이 고급 사용 사례를 위한 Vite 구성은 다음과 같이 보입니다.\n\n여기 구성에서는 결제 및 홈 원격 모듈을로드하기 위해 두 가지 다른 원격 구성을 추가했음을 볼 수 있습니다. 각각에 대해 두 가지 다른 외부 유형을 추가했습니다. 여기서 이전 예제에서 한 것처럼 홈 컴포넌트를 설정된 URL로 로드하고 있지만 결제 모듈을 로드하기 위해 외부 유형인 promise를 사용하고 있습니다. 이것은 빌드 단계에서 결제 리모트 모듈이 호스팅되는 URL이 무엇인지 모른다면 런타임에서 설정할 수 있어야 한다는 것을 보여주기 위해 사용하고 있습니다. 이는 애플리케이션을 호스팅하고 모든 URL을 런타임에 해결하는 경우 유용합니다. 그래서 라인 25에서 결제 리모트 모듈의 URL을 런타임 중에 promise를 사용하여 로드하는 아래 구성을 사용하고 있습니다.\n\n```js\nremotes: [\n...\n{\n  payment: {\n     external: 'Promise.resolve(window.paymentUrl)',\n     from: 'vite',\n     externalType: 'promise'\n  },\n}\n...\n```\n\n그리고 호스트 애플리케이션의 App.tsx 컴포넌트 내부에 결제 리모트 모듈 URL을 window 객체에 설정하고, 홈 페이지 리모트 모듈에 추가하여 게으르게 로드하고 있습니다.\n\n\n\n# 개발 중 발생할 수 있는 오류 및 해결 방법\n\n- React, React Router Dom 및 다른 공유 라이브러리가 정의되지 않은 경우.\n\n확인해야 할 사항\n\n- 원격 앱 Vite 구성 또는 호스트 앱 Vite 구성의 공유 속성에 올바른 공유 라이브러리 목록이 추가되지 않은 경우입니다. 양쪽의 공유 목록이 동일해야 합니다.\n- 원격 앱과 호스트 앱 간에 공유해야 하는 모든 것이 공유 목록에 추가되었는지 확인해보세요.\n\n\n\n2. 원격 모듈을 로드하지 못했습니다.\n\n![이미지](/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_2.png)\n\n확인해야 할 사항은 다음과 같습니다.\n\n- 호스트 측 Vite 구성에서 각 원격 모듈 이름이 고유한지 확인하세요.\n- 원격 측 Vite 구성에 올바른 컴포넌트 이름이 명시되어 있는지 확인하세요. 구성 내에서 컴포넌트 이름은 공유하려는 컴포넌트와 비슷해야 합니다.\n- 원격 애플리케이션 측에서 컴포넌트가 기본으로 내보내졌는지 확인하세요.\n\n\n\n3. 만약 모든 패키지가 monorepo 구조에 있다면 npm 호이스팅과 호스트 및 원격 모듈 간의 라이브러리 공유에 문제가 발생합니다.\n\n이는 vite-plugin-federation 쪽에서 열린 이슈입니다. 그러나 모노리포 구조를 유지해야 한다면 위 샘플 프로젝트에서 한 것처럼 각 개별 애플리케이션에서 노드 모듈을 설치해야 합니다.\n\n# 결론\n\n- 원격 모듈을 가져오는 경우 정적 임포트 대신 지연 로딩을 사용하는 것이 좋습니다.\n- 원격 호스팅 모듈의 URL을 알고 있다면 구성에서 정적 URL을 사용하고, 실행 중에 동적으로 URL을 해결해야 할 경우 URL을 해결하기 위해 프로미스 방법을 사용하세요.\n- 문제없이 작동하도록 하려면 모든 것을 공유 컴포넌트에 추가해야 합니다. 예시: 원격 애플리케이션 루트 수준에서 적용한 프로바이더가 있는 경우 이를 공유 컴포넌트 내에 추가하거나 호스트 애플리케이션 측에서 프로바이더를 생성하여 해당 원격 컴포넌트를 감싸야 합니다(이 방법은 테스트하지 않았음)… 이것은 원격 모듈에 함께 패킹될 컴포넌트 및 해당에 필요한 임포트만 공유되기 때문입니다. 따라서 원격 앱의 루트 컴포넌트에 추가한 내용은 공유 컴포넌트 내에서 사용할 수 없습니다.\n- 항상 호스트 및 원격 간에 vue 및 react와 같은 핵심 라이브러리를 공유하세요.","ogImage":{"url":"/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_0.png"},"coverImage":"/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_0.png","tag":["Tech"],"readingTime":10},{"title":"Nextjs를 사용하여 Resend를 이용해 사용자에게 직접 메일을 보내는 방법","description":"","date":"2024-05-14 11:58","slug":"2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend","content":"\n\nNext.js는 매우 다재다능한 프론트엔드를 제공해줘요. 이를 단독으로 사용하여 웹 사이트의 대부분 요구 사항을 해결할 수 있어요. 프로젝트 구조 자체에 서버 측 렌더링을 활용하고 API를 생성할 수 있는 기능이 내장되어 있어 Next.js 앱의 기능을 확장할 수 있어요.\n\n![Resend 이미지](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_0.png)\n\n이 기사에서는 개발자를 위한 이메일 API인 Resend를 탐색하고 앱과 통합해볼 거예요. 우리는 간단한 연락처 양식을 만들어서 제출하면 제출된 정보와 함께 이메일을 우리 받은 편지함으로 전송할 거에요. 이 통합은 문의, 대기 목록 또는 기타 양식 정보를 받고 바로 우리 받은 편지함으로 전달하고 싶을 때 아주 유용해요.\n\n# 우리 Next.js 앱\n\n\n\n간단한 Next.js 앱을 만들 계획이에요. contact form을 사용해서. yarn create next-app를 사용해서.\n\n```js\nyarn create next-app\n```\n\n프로젝트 구성을 위해 다음 설정을 사용했어요. tailwind를 스타일링에 선택하고 코드를 정리하기 위해 src 디렉토리를 사용했어요.\n\n![이미지](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_1.png)\n\n\n\n## 연락 양식 만들기\n\n간결하게 유지하려고 하며 이름과 이메일을 요청하는 연락 양식을 만들겠습니다.\n\n다음과 같이 index.js 페이지 컴포넌트를 업데이트 해보세요:\n\n```js\nimport { useState } from \"react\";\nimport Head from \"next/head\";\n\nexport default function Home() {\n    const [name, setName] = useState(\"\");\n    const [email, setEmail] = useState(\"\");\n    const [loading, setLoading] = useState(false);\n\n    const handleSubmit = () => {\n      console.log(\"여기에 API 호출하기\")\n    }\n    return (\n        <main\n            className={`flex flex-col items-center p-24 min-h-screen`}\n        >\n            <Head>\n                <title>Contact Me | Coffeed</title>\n            </Head>\n\n            <div className=\"relative flex flex-col gap-4 \">\n                <div className=\"flex flex-col place-items-center gap-4\">\n                    <h1 className={`m-0 text-center text-3xl`}>연락하기</h1>\n                </div>\n                <form\n                    className=\"mt-6 flex flex-col max-w-xl gap-4 z-10\"\n                    onSubmit={handleSubmit}\n                >\n                    <label htmlFor=\"name\" className=\"sr-only\">\n                        이름\n                    </label>\n                    <input\n                        id=\"name\"\n                        name=\"name\"\n                        type=\"text\"\n                        autoComplete=\"name\"\n                        required\n                        value={name}\n                        className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이름\"\n                        onChange={(e) => setName(e.target.value)}\n                    />\n                    <label htmlFor=\"email-address\" className=\"sr-only\">\n                        이메일 주소\n                    </label>\n                    <input\n                        id=\"email-address\"\n                        name=\"email\"\n                        type=\"email\"\n                        autoComplete=\"email\"\n                        required\n                        value={email}\n                        className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이메일\"\n                        onChange={(e) => setEmail(e.target.value)}\n                    />\n                    <button\n                        type=\"submit\"\n                        className=\"flex justify-center rounded-md bg-blue-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-blue-500\"\n                    >\n                        {loading ? (\n                            <div\n                                style={\n                                    borderTopColor: \"transparent\",\n                                }\n                                className=\"w-6 h-6 border-4 border-white border-solid rounded-full animate-spin\"\n                            ></div>\n                        ) : (\n                            \"제출\"\n                        )}\n                    </button>\n                </form>\n            </div>\n        </main>\n    );\n}\n```\n\n\n\n테일윈드를 사용하여 스타일을 입히고 사용자로부터 이름과 이메일을 받는 간단한 양식을 만들었습니다. 양식을 제출할 때 Send Mail API 호출을 트리거합니다.\n\n다음 단계를 진행하기 위해 Next.js에서 Resend 및 필수 API를 설정해봅시다.\n\n# Resend로 시작하기\n\nresend.com으로 이동하여 계정에 로그인하세요. 이메일이나 Github를 사용하여 새로운 계정을 만들 수 있습니다.\n\n\n\nResend는 플랫폼에서 도메인을 소유하고 확인한 경우에만 사용자에게 이메일을 보낼 수 있습니다. 이를 통해 해당 도메인 이름을 사용하여 어떤 이메일 주소에서든 이메일을 보낼 수 있습니다. 예를 들어, noreply@coffeed.com에서 사용자에게 이메일을 보내려면 coffeed.com 도메인을 Resend에 추가한 다음 해당 도메인 이름 레코드를 추가하여 해당 도메인을 소유하고 있는 것을 확인해야 합니다.\n\n## 도메인 추가\n\n도메인을 추가하려면 도메인으로 이동한 다음 도메인 추가를 클릭하세요.\n\n![도메인 추가](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_2.png)\n\n\n\n도메인 이름을 입력하고 지역을 선택해주세요. 기본값인 \"us-east-1\"은 무료이며 저희가 사용하는 용도에 적합합니다.\n\n![도메인 설정](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_3.png)\n\n도메인을 추가하면 DNS 레코드 세트가 표시되며, 해당 레코드들을 도메인 서비스 제공업체에서 업데이트해야 합니다. MX 및 2개의 TXT 레코드를 DNS에 추가한 후에 \"DNS 레코드 확인\"을 클릭하여 도메인을 확인할 수 있습니다.\n\n![DNS 레코드 확인](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_4.png)\n\n\n\n도메인을 확인하는 것은 이메일 전달성을 보장하는 데 필수적입니다. 한 번 도메인을 확인하면 이메일을 보낼 수 있는 권한이 부여됩니다.\n\n## API 키 생성\n\nAPI 키는 요청을 인증하는 비밀 토큰입니다.\n\n- 사이드바의 API 키로 이동합니다.\n- API 키 생성을 클릭합니다.\n- API 키에 이름을 지정합니다.\n- 허가로 보내기 액세스를 선택하고 액세스를 제한하려는 특정 도메인을 선택하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_5.png\"/>\n\n또한 \"전체 액세스\" 권한이 있지만 보안을 위해 단일 도메인에 제한된 \"전송 액세스\" 권한을 사용하는 것이 좋습니다. .env 파일에 생성된 이 API 키를 RESEND_API_KEY 변수로 추가하세요.\n\n# Next.js 앱에 Resend 추가하기\n\n이제 프로젝트로 돌아가서 Resend sdk 라이브러리를 추가해봅시다. 터미널에서 다음 명령을 실행하세요:\n\n\n\n```js\nyarn add resend\n```\n\n## 1. 이메일 템플릿 추가하기\n\n먼저 src 폴더의 components 폴더에 새로운 이메일 템플릿 폴더를 만들어보세요. src/components/email/ 폴더에 contact-form.jsx라는 새로운 이메일 템플릿을 추가해주세요.\n\n```js\nexport const EmailTemplate = ({\n  name,\n  email\n}) => (\n  <div>\n    <p>안녕하세요 Kavya,</p>\n    <p>\n        {name}님이 웹사이트에서 연락 양식을 제출했습니다. 그들의\n        이메일은 {email} 입니다!\n    </p>\n    <p>\n        감사합니다,\n        <br />\n        Coffee\n    </p>\n  </div>\n);\n```\n\n\n\n이메일 본문을 스타일링하기 위해 HTML을 사용하여 이름과 이메일을 입력할 수 있는 간단한 템플릿을 만들었습니다. React 컴포넌트로 구성된 이 템플릿을 보면 프로젝트에서 디자인한 React 컴포넌트를 사용하거나 수정할 수 있습니다.\n\n## 2. 이메일을 보내는 API 생성하기\n\npages/api/ 디렉토리 아래에 send.js라는 API 파일을 생성하세요. 요청 본문에서 이름과 이메일을 가져와서 Resend 라이브러리의 sendEmail 함수를 호출하고 EmailTemplate과 함께 사용하세요.\n\n```js\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nconst data = await resend.sendEmail({\n    from: `${process.env.FROM_EMAIL}`,\n    to: `${process.env.TO_EMAIL}`,\n    subject: \"🎉 연락 양식으로 새로운 제출이 도착했습니다!\",\n    html: \"\",\n    react: EmailTemplate({ name, email })\n});\n```\n\n\n\n다음 변수들은 .env 파일에 선언되어야 합니다:\n\n- RESEND_API_KEY — Resend 관리자 섹션에서 생성된 API 키.\n- FROM_EMAIL — 메일이 보내지는 이메일 주소. Resend 관리자에서 확인된 도메인으로부터 보내진 것으로 나타나야 합니다.\n- TO_EMAIL — 메일이 전송될 이메일 주소. 이 경우에는 내 이메일 주소로 메일을 보내고 있습니다.\n\n```js\nimport { EmailTemplate } from '../../components/email/contact-form';\nimport { Resend } from 'resend';\n\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nexport default async (req, res) => {\n  try {\n    const { name, email } = JSON.parse(req.body);\n\n    const data = await resend.sendEmail({\n        from: `${process.env.FROM_EMAIL}`,\n        to: `${process.env.TO_EMAIL}`,\n        subject: \"🎉당신의 연락 양식으로의 새로운 제출!\",\n        html: \"\",\n        react: EmailTemplate({ name, email })\n    });\n\n    res.status(200).json(data);\n  } catch (error) {\n    res.status(400).json(error);\n  }\n};\n```\n\n대신 제출된 이메일 주소로 설정하여 사용자에게 바로 이메일이 전송되도록 할 수도 있습니다.\n\n\n\n## 3. 양식 제출 시 이메일 트리거\n\nhandleSubmit 함수를 만들고 이름과 이메일을 본문의 매개변수로 사용하여 이메일을 트리거할 수 있습니다.\n```js\nconst [name, setName] = useState(\"\");\nconst [email, setEmail] = useState(\"\");\nconst [loading, setLoading] = useState(false);\n\nconst handleSubmit = async (e) => {\n    setLoading(true);\n    e.preventDefault();\n\n    if (name == \"\" && email == \"\") {\n        setLoading(false);\n        alert(\"이름과 이메일을 모두 입력해주세요\");\n        return false;\n    }\n\n    await fetch(\"/api/send\", {\n        method: \"POST\",\n        body: JSON.stringify({ name, email }),\n    })\n        .then((res) => res.json())\n        .then((data) => {\n            setLoading(false);\n            if (data && data.id) {\n                alert(`${name}님, 관심 표현해 주셔서 감사합니다! 곧 연락 드리겠습니다!`);\n                setName(\"\");\n                setEmail(\"\");\n            } else {\n                alert(\"죄송합니다! 다시 시도해주세요.\");\n            }\n        })\n        .catch((err) => {\n            setLoading(false);\n            alert(\"우왕! 불행하게도 오류가 발생했습니다.\");\n        });\n    return true;\n};\n```\n\n이렇게 하면 Next.js 앱에 Resend 기능을 연결할 수 있습니다. 여기에 인덱스 페이지의 최종 코드가 있습니다:\n\n\n\n```js\r\nimport { useState } from \"react\";\nimport Head from \"next/head\";\n\nexport default function Home() {\n    const [name, setName] = useState(\"\");\n    const [email, setEmail] = useState(\"\");\n    const [loading, setLoading] = useState(false);\n\n    const handleSubmit = async (e) => {\n        setLoading(true);\n        e.preventDefault();\n\n        if (name == \"\" && email == \"\") {\n            setLoading(false);\n            alert(\"이름과 이메일 주소를 모두 입력해주세요!\");\n            return false;\n        }\n\n        await fetch(\"/api/send\", {\n            method: \"POST\",\n            body: JSON.stringify({ name, email }),\n        })\n            .then((res) => res.json())\n            .then((data) => {\n                setLoading(false);\n                if (data && data.id) {\n                    alert(`${name}님, 저희에게 관심 가져주셔서 감사합니다! 곧 연락드리겠습니다!`);\n                    setName(\"\");\n                    setEmail(\"\");\n                } else {\n                    alert(\"죄송합니다! 다시 시도해주세요.\");\n                }\n            })\n            .catch((err) => {\n                setLoading(false);\n                alert(\"앗! 죄송하지만 오류가 발생했습니다.\");\n            });\n        return true;\n    };\n    return (\n        <main\n            className={`flex flex-col items-center p-24 min-h-screen`}\n       >\n            <Head>\n                <title>나에게 연락하기 | Coffeed</title>\n            </Head>\n\n            <div className=\"relative flex flex-col gap-4 \">\n                <div className=\"flex flex-col place-items-center gap-4\">\n                    <h1 className={`m-0 text-center text-3xl`}>나에게 연락하기</h1>\n                </div>\n                <form\n                    className=\"mt-6 flex flex-col max-w-xl gap-4 z-10\"\n                    onSubmit={handleSubmit}\n                >\n                    <label htmlFor=\"name\" className=\"sr-only\">\n                        이름\n                    </label>\n                    <input\n                        id=\"name\"\n                        name=\"name\"\n                        type=\"text\"\n                        autoComplete=\"name\"\n                        required\n                        value={name}\n                       className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이름\"\n                        onChange={(e) => setName(e.target.value)}\n                    />\n                    <label htmlFor=\"email-address\" className=\"sr-only\">\n                        이메일 주소\n                    </label>\n                    <input\n                        id=\"email-address\"\n                        name=\"email\"\n                        type=\"email\"\n                        autoComplete=\"email\"\n                        required\n                        value={email}\n                        className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이메일\"\n                        onChange={(e) => setEmail(e.target.value)}\n                    />\n                    <button\n                        type=\"submit\"\n                        className=\"flex justify-center rounded-md bg-blue-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-blue-500\"\n                    >\n                        {loading ? (\n                            <div\n                                style={{\n                                    borderTopColor: \"transparent\",\n                                }}\n                                className=\"w-4 h-4 border-2 border-white border-solid rounded-full animate-spin\"\n                            ></div>\n                        ) : (\n                            \"제출하기\"\n                        )}\n                    </button>\n                </form>\n            </div>\n        </main>\n    );\n}\r\n```\n\n양식을 제출하면 이메일이 .env 파일에 설정된 TO_EMAIL로 전송됩니다.\n\n<img src=\"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_6.png\" />\n\n이메일 API를 활용하여 다른 사용 사례에 통합하여 직접 알림을 받을 수도 있습니다.\n\n\n\nNext.js playbook **Coffee** 팀에서 작업 중인 페이지입니다. 대기 목록에 추가하려면 coffee@coffeeinc.in으로 이메일을 보내주세요.","ogImage":{"url":"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_0.png"},"coverImage":"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_0.png","tag":["Tech"],"readingTime":13},{"title":"리액트에서 반응형 디자인 구축하기 어떤 기기에서도 멋있게 보이는 반응형 디자인을 만들기 위한 최상의 방법","description":"","date":"2024-05-14 11:57","slug":"2024-05-14-BuildingaresponsivedesigninReactBestpracticesforcreatingaresponsivedesignthatlooksgreatonanydevice","content":"\n\n반응형 디자인은 현대 웹 개발의 중요한 측면이 되었습니다. 이 기사에서는 React에서 반응형 디자인을 구축하는 최상의 방법과 어떻게 모든 기기에서 멋지게 보이는 디자인을 만들 수 있는지 알아보겠습니다.\n\n## 반응형 디자인 원리 활용하기\n\nReact에서 반응형 디자인을 만들기 위해서는 반응형 디자인 원리를 활용하는 것이 중요합니다. 이는 웹사이트가 데스크톱, 태블릿 또는 스마트폰 등 모든 기기에서 멋지게 보이도록 보장합니다. 이러한 원리에는 상대적인 단위를 사용해 글꼴 크기를 조절하고 유연한 레이아웃을 사용하며 다양한 화면 크기에 맞게 이미지를 최적화하는 것이 포함됩니다.\n\n## CSS 프레임워크 사용하기\n\n\n\nCSS 프레임워크를 사용하면 빠르고 쉽게 반응형 디자인을 만들 수 있어요. 리액트와 함께 사용할 수 있는 여러 CSS 프레임워크가 있습니다. 부트스트랩, 마테리얼라이즈, 시맨틱 UI 등이 있어요. 이러한 프레임워크들은 사전 제작된 구성 요소와 반응형 레이아웃을 제공하며 필요에 맞게 사용자 정의할 수 있어요.\n\n# 미디어 쿼리 활용\n\n미디어 쿼리는 화면 크기를 기반으로 웹사이트에 다른 스타일을 적용할 수 있는 CSS 기능이에요. 미디어 쿼리를 사용하여 레이아웃, 폰트 크기 및 기타 디자인 요소를 조정하여 모든 기기에서 웹사이트가 멋지게 보이도록 할 수 있어요.\n\n```js\n@media (max-width: 768px) {\n .container { flex-direction: column;\n  } \n} \n@media (min-width: 768px) { \n.container {\n flex-direction: row; \n  } \n}\n```\n\n\n\n이 예시에서 두 개의 미디어 쿼리를 정의했습니다. 첫 번째 쿼리는 화면 크기가 768픽셀 이하일 때 적용됩니다. 이 쿼리는 flex-direction 속성을 column으로 설정하여 레이아웃을 단일 열로 변경합니다. 두 번째 쿼리는 화면 크기가 768픽셀 이상일 때 적용됩니다. 이 쿼리는 flex-direction 속성을 row로 설정하여 레이아웃을 여러 열로 변경합니다.\n\n# Flexbox 사용\n\nFlexbox는 유연한 레이아웃을 생성할 수 있는 CSS 기능입니다. Flexbox를 사용하면 다양한 화면 크기와 방향에 맞춰 레이아웃을 조정할 수 있습니다. Flexbox를 이용하면 모든 기기에서 멋지게 보이는 반응형 디자인을 쉽게 만들 수 있습니다.\n\n```js\n.container {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n}\n```\n\n\n\n이 예제에서는 유연한 레이아웃을 만들기 위해 flexbox를 사용하는 컨테이너 요소를 정의했습니다. display 속성을 flex로 설정하여 브라우저에 flexbox를 사용하도록 지시했습니다. flex-direction 속성을 row로 설정하여 레이아웃이 행으로 표시되도록 했습니다. justify-content 속성을 space-between으로 설정하여 항목을 주축을 따라 균등하게 배치했습니다. align-items 속성을 center로 설정하여 항목을 교차 축을 따라 가운데 정렬했습니다.\n\n# React 반응형 라이브러리 사용하기\n\n다양한 React 반응형 라이브러리를 사용하면 반응형 디자인을 보다 편리하게 구축할 수 있습니다. 이러한 라이브러리에는 react-responsive, react-device-detect, react-media 등이 있습니다. 이러한 라이브러리는 기기 유형을 감지하고 레이아웃을 그에 맞게 조정하는 데 도움이 되는 컴포넌트를 제공합니다.\n\n```js\nimport { useMediaQuery } from \"react-responsive\";\n\nfunction MyComponent() {\n  const isTabletOrMobile = useMediaQuery({ maxWidth: 768 });\n\n  return (\n    <div> {isTabletOrMobile ? <MobileComponent /> : <DesktopComponent />} </div>\n  );\n}\n```\n\n\n\n이 예시에서는 react-responsive 라이브러리의 useMediaQuery 훅을 사용하여 기기가 태블릿 또는 모바일 장치인지 감지했습니다. isTabletOrMobile 변수를 사용하여 MobileComponent 또는 DesktopComponent 중 하나를 조건부로 렌더링했습니다.\n\n# 결론\n\nReact에서 반응형 디자인을 구축하는 것은 웹사이트가 모든 기기에서 훌륭하게 보이도록 보장하는 데 중요합니다.","ogImage":{"url":"/assets/img/2024-05-14-BuildingaresponsivedesigninReactBestpracticesforcreatingaresponsivedesignthatlooksgreatonanydevice_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaresponsivedesigninReactBestpracticesforcreatingaresponsivedesignthatlooksgreatonanydevice_0.png","tag":["Tech"],"readingTime":3},{"title":"React TypeScript 마스터하기 개발자를 위한 포괄적인 가이드","description":"","date":"2024-05-14 11:54","slug":"2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers","content":"\n\n![이미지](/assets/img/2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers_0.png)\n\nReact 능력을 더 높이고 싶은 개발자이신가요? TypeScript로 React를 마스터하려면 더 이상 찾을 필요가 없어요. 이 포괄적인 안내서는 React 응용 프로그램을 TypeScript로 구축하는 데 필요한 모든 것을 알려줄 거에요. 처음 시작하는 중이거나 React를 한동안 사용해온 분이더라도, 이 안내서는 깨끗하고 효율적이며 확장 가능한 코드를 작성하는 데 필요한 도구와 지식을 제공할 거예요. 그러니 함께 React TypeScript의 세계를 탐험해 봐요!\n\n# 1. 함수 컴포넌트\n\n## 1.1 외부 선언\n\n\n\n저희 컴포넌트의 props에 대한 타입을 정의하기 위해 인터페이스를 사용하세요.\n\n```js\ninterface GreetingProps {\n  name: string;\n}\n\nconst Greeting = ({ name }: GreetingProps) => <div>Hello, {name}!</div>;\n```\n\n## 1.2 Inline Declaration\n\n조금 더 간단한 props를 가진 컴포넌트의 경우, 인라인으로 선언할 수 있습니다.\n\n\n\n```js\nconst Greeting = ({ name }: { name: string }) => <div>환영합니다, {name}님!</div>;\n```\n\n## 1.3 제네릭 사용하기\n\n제네릭은 컴포넌트 props의 유연성을 향상시킵니다.\n\n```js\n// 제네릭 타입 정의\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n}\n\n// 그 제네릭 타입을 사용하여 함수 컴포넌트 생성\nconst List: React.FC<ListProps<string>> = ({ items, renderItem }) => (\n  <ul>{items.map((item, index) => <li key={index}>{renderItem(item)}</li>)}</ul>\n);\n\nconst UserList = () => {\n  const users = [\"Alice\", \"Bob\", \"Charlie\"];\n  return <List items={users} renderItem={(user) => <strong>{user}</strong>} />;\n};\n```\n\n\n\n# 2. 훅\n\n## 2.1 useState\n\n간단히 초기값을 제공하면 TypeScript가 해당 유형을 자동으로 유추해줍니다.\n\n```js\nconst [counter, setCounter] = useState(0);\n// 'counter'는 숫자로 추론됩니다\n// 'setCounter'는 숫자나 숫자를 반환하는 함수를 입력으로 받는 함수입니다\n```\n\n\n\n초기 상태가 정의되지 않을 수 있는 경우에는 상태의 타입을 명시적으로 정의할 수 있습니다.\n\n```js\ninterface User {\n  name: string;\n  id: number;\n  email: string;\n}\n\nfunction UserProfile() {\n  const [user, setUser] = useState<User | undefined>();\n\n  // 'user'은 User 객체이거나 undefined일 수 있습니다.\n}\n```\n\n`User | undefined`와 같이 undefined일 수 있는 제네릭을 사용할 때, 객체가 undefined일 수 있다는 오류가 발생할 수 있습니다. 이 경우 다음 두 가지 방법으로 처리할 수 있습니다:\n\n- 옵셔널 체이닝 연산자 `?.`을 사용하는 것입니다.\n\n\n\n```js\nfunction UserProfile() {\n  const [user, setUser] = useState<User | undefined>();\n\n  return (\n    <div>\n      Name: {user?.name} {/* 여기서 선택적 체이닝을 사용했습니다. */}\n    </div>\n  );\n}\n```\n\n- 초기값으로 빈 객체 제공 및 타입 어설션 사용\n\n```js\nconst [user, setUser] = useState<User>({} as User);\n// 여기서 우리는 빈 객체가 실제로 User 객체라고 말하고 있습니다.\n```\n\n## 2.2 useCallback\n\n\n\n\n위의 텍스트를 부탁하신 대로 친절하게 한국어로 번역해 드리겠습니다.\n\n함수의 타입은 첫 번째 인수에서 추론됩니다.\n\n버튼이 클릭될 때 작업을 수행해야 하는 함수가 있고, 그러나 이 함수가 컴포넌트가 렌더링될 때마다 재생성되지 않도록 하고 싶다면 useCallback을 사용할 수 있습니다.\n\n```js\nconst saveUser = useCallback(\n  (id: number, userData: User) => {\n    // 이 함수가 사용자 데이터를 서버로 보내는 상황을 상상해보세요\n    api.updateUser(id, userData);\n  },\n  [],\n); // 의존성 배열이 비어 있으므로, 이 함수는 한 번 생성되고 재생성되지 않음\n\n// 'saveUser'는 다음과 같이 추론됩니다: (id: number, userData: User) => void\n```\n\n## 2.3 useMemo\n\n\n\n제공된 첫 번째 인수의 반환 값을 기반으로 유형이 추론됩니다.\n\n카트에 있는 항목들의 총 가격을 계산하는 시나리오를 고려해 보세요. 세금을 포함한 가격을 계산하려면:\n\n```js\nconst totalPrice = useMemo(() => {\n  const price = items.reduce((total, item) => total + item.price, 0);\n  return (price * (1 + taxRate)).toFixed(2);\n}, [items, taxRate]); // 'totalPrice'은 toFixed로 인해 문자열로 추론됩니다\n```\n\n값의 반환 유형을 명시적으로 지정할 수도 있습니다.\n\n\n\n그러나 제네릭을 사용하여 명시적으로 잘못된 유형을 설정하려고하면 TypeScript에서 경고가 발생할 것입니다:\n\n```js\n// toFixed로 인해 반환 유형이 문자열인 경우 오류가 발생합니다.\nconst totalPrice = useMemo<number>(() => {\n  const price = items.reduce((total, item) => total + item.price, 0);\n  return (price * (1 + taxRate)).toFixed(2);\n}, [items, taxRate]); // 오류: 'string' 형식은 'number' 형식에 할당할 수 없습니다.\n```\n\n## 2.4 useRef\n\nDOM 노드에 액세스하려면 null의 초기값을 제공할 수 있습니다.\n\n\n\n페이지가 로드될 때 텍스트 입력란에 초점을 맞추어야 할 때:\n\n```js\nconst inputRef = useRef<HTMLInputElement>(null);\n\nuseEffect(() => {\n  // 컴포넌트가 마운트된 후 입력 요소에 초점을 맞춥니다\n  inputRef.current?.focus();\n}, []);\n```\n\nuseRef는 업데이트되어도 다시 렌더링을 발생시키지 않는 타이머 참조와 같은 변경 가능한 값을 저장하는 데에도 사용할 수 있습니다.\n\n2초마다 메시지를 기록하는 타이머를 설정하고 싶다고 가정해봅시다:\n\n\n\n```js\nconst timerRef = useRef<NodeJS.Timer>();\n\nuseEffect(() => {\n  timerRef.current = setInterval(() => {\n    console.log(\"Timer tick\");\n  }, 2000);\n\n  // 컴포넌트가 언마운트 될 때 interval을 정리합니다.\n  return () => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n    }\n  };\n}, []);\n```\n\n## 2.5 useImperativeHandle\n\nuseImperativeHandle은 ref를 사용할 때 노출되는 인스턴스 값을 사용자 정의하는 데 사용됩니다. 타입은 forwardRef 지점에서 정의되며, 제네릭이 전달되는 순서를 주의해야 합니다—ref는 props 앞에 옵니다.\n\n부모 컴포넌트에서 리셋할 수 있는 사용자 정의 입력 컴포넌트가 있는 시나리오를 상상해봅시다.```\n\n\n\n```js\nimport { useRef, forwardRef, useImperativeHandle, useState } from \"react\";\n\n// 사용자 정의 ref 타입 정의\ninterface CustomInputHandle {\n  clear: () => void;\n}\n\nconst Form = () => {\n  // null로 초기화\n  const inputRef = useRef<CustomInputHandle>(null);\n\n  const handleClearClick = () => {\n    inputRef.current?.clear();\n  };\n\n  return (\n    <div>\n      <CustomInput ref={inputRef} />\n      <button onClick={handleClearClick}>Clear Input</button>\n    </div>\n  );\n};\n\n// props와 ref 타입 정의의 역순에 유의하세요\nconst CustomInput = forwardRef<CustomInputHandle, {}>((props, ref) => {\n  const [text, setText] = useState(\"\");\n\n  useImperativeHandle(ref, () => ({\n    clear: () => {\n      setText(\"\");\n    },\n  }));\n\n  return (\n    <input type=\"text\" value={text} onChange={(e) => setText(e.target.value)} />\n  );\n});\n\nexport default Form;\n```\n\n## 2.6 useContext\n\nuseContext를 사용하면 컴포넌트에서 context 객체를 소비할 수 있습니다. 자동으로 타입이 유추되므로 createContext 단계에서 타입을 정의하는 것이 중요합니다.\n\n초기 값 설정이 가능하며 TypeScript가 자동으로 타입을 추론합니다.\n  \n\n\n\n```js\nconst ThemeContext = createContext({\n  theme: \"light\",\n  toggleTheme: () => {},\n});\n\n// 'ThemeContext'는 다음과 같이 추론됩니다:\n// const ThemeContext: React.Context<{\n//   theme: string;\n//   toggleTheme: () => void;\n// }>\n```\n\n만약 컨텍스트 타입을 더 엄격하게 보장하고 싶다면, 빈 객체와 타입 어순화를 사용하여 제네릭을 사용할 수 있습니다.\n\n```js\ninterface ThemeContextType {\n  theme: string;\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType>({} as ThemeContextType);\n\n// 'ThemeContext'는 이제 'theme'와 'toggleTheme'을 갖는 객체를 엄격하게 요구합니다.\n```\n\n## 2.7 useReducer\n\n\n\n\nuseReducer은 React에서 상태 관리에 사용되는 훅으로, 여러 하위 값이 관련되거나 다음 상태가 이전 상태에 의존하는 복잡한 상태 논리가 있는 경우 특히 유용합니다. TypeScript는 상태와 액션에 대한 타입을 제공하여 useReducer를 매우 효과적으로 활용할 수 있습니다.\n\n예를 들어, 항목을 추가하거나 제거할 수 있는 쇼핑 카트를 관리하는 경우:\n\n```js\nimport { useReducer } from \"react\";\n\nconst initialCart = {\n  items: [],\n  total: 0,\n};\n\n// 1. 초기 상태 타입 정의\ntype CartState = typeof initialCart;\n\n// 2. 액션 타입 정의\ntype CartActionType =\n  | { type: \"addItem\"; payload: { item: string; price: number } }\n  | { type: \"removeItem\"; payload: { index: number } };\n\nfunction cartReducer(state: CartState, action: CartActionType) {\n  switch (action.type) {\n    case \"addItem\":\n      return {\n        ...state,\n        items: [...state.items, action.payload.item],\n        total: state.total + action.payload.price,\n      };\n    case \"removeItem\":\n      const newItems = state.items.filter((_, index) => index !== action.payload.index);\n      return {\n        ...state,\n        items: newItems,\n        total: state.total - state.items[action.payload.index].price,\n      };\n    default:\n      throw new Error();\n  }\n}\n\nconst ShoppingCart = () => {\n  const [cart, dispatch] = useReducer(cartReducer, initialCart);\n  return (\n    <>\n      총액: {cart.total}\n      <button onClick={() => dispatch({ type: \"addItem\", payload: { item: 'Apple', price: 1 } })}>\n        사과 추가\n      </button>\n      <button onClick={() => dispatch({ type: \"removeItem\", payload: { index: 0 } })}>\n        항목 제거\n      </button>\n      {/* 상품 목록 */}\n      {cart.items.map((item, index) => (\n        <div key={index}>{item}</div>\n      ))}\n    </>\n  );\n};\n\nexport default ShoppingCart;\n```\n\n## 2.8 useEffect / useLayoutEffect\n\n\n\nuseEffect와 useLayoutEffect은 함수 컴포넌트에서 부작용을 수행하는 데 사용되는 훅입니다. 이들은 componentDidMount, componentDidUpdate 및 componentWillUnmount과 같은 클래스 컴포넌트의 라이프사이클 메서드와 유사합니다. TypeScript에서 이러한 훅에 대한 타입을 명시적으로 정의할 필요가 없는 이유는 이러한 훅이 타입 정의를 필요로 하는 것이 없기 때문입니다.\n\n다음은 API에서 사용자 데이터를 가져와야 하는 애플리케이션에서 useEffect를 사용한 실제 예시입니다:\n\n```js\nimport { useEffect, useState } from \"react\";\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst UserProfile = () => {\n  const [user, setUser] = useState<User | null>(null);\n\n  useEffect(() => {\n    const fetchUserData = async () => {\n      const response = await fetch(\"https://api.example.com/user\");\n      const userData: User = await response.json();\n      setUser(userData);\n    };\n\n    fetchUserData();\n  }, []); // 의존성 배열이 비어 있으면, 이 효과는 componentDidMount와 유사하게 한 번만 실행됩니다.\n\n  if (!user) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n};\n\nexport default UserProfile;\n```\n\n# 3. 내장 타입\n\n\n\n## 3.1 스타일 속성 유형\n\nReact에서 자식 컴포넌트에 인라인 스타일을 전달하려면 React.CSSProperties를 사용할 수 있습니다.\n\n```js\ninterface Props {\n  style?: React.CSSProperties;\n}\n```\n\n## 3.2 자식 요소 유형\n\n\n\n3.2.1 React.ReactNode\n\nJSX에서 렌더링할 수 있는 모든 유형의 연합체입니다. 문자열, 숫자, React 엘리먼트 및 이러한 유형의 배열이 포함됩니다.\n\n```js\ninterface Props {\n  children?: React.ReactNode;\n}\n```\n\n이 유형을 사용하면 children prop이 JSX에서 렌더링할 수 있는 어떤 유형이든 될 수 있음을 TypeScript에 알리는 것입니다. 매우 유연합니다.\n\n\n\n3.2.2 React.ReactElement\n\n이 유형은 문자열이나 숫자와 같은 JavaScript 기본 유형을 제외하고 JSX 요소만 포함합니다. 이는 주로 함수 컴포넌트의 반환 유형을 정의하는 데 사용됩니다.\n\n```js\ninterface Props {\n  children?: React.ReactElement;\n}\n```\n\n## 3.3 컴포넌트 속성 유형 가져오기\n\n\n\n만약 자식 컴포넌트가 인라인으로 props를 정의하고 부모 컴포넌트가 자식의 props 유형을 참조해야 할 경우, React.ComponentProps를 사용하여 자식 컴포넌트의 props 유형을 추론할 수 있습니다.\n\n```js\nconst ChildComponent = ({ message }: { message: string }) => <div>{message}</div>;\n\ntype ChildPropsType = React.ComponentProps<typeof ChildComponent>;\n\n// ChildPropsType는 다음과 같이 추론됩니다:\n// type ChildPropsType = {\n//   message: string;\n// }\n```\n\n# 4. 이벤트 처리\n\n## 4.1 이벤트 유형\n\n\n\n리액트에서 이벤트를 다룰 때는 이벤트 핸들러 내에서 예상한 속성에 액세스할 수 있도록 올바른 이벤트 유형을 지정하는 것이 중요합니다.\n\n### 4.1.1 onClick 이벤트\n\n버튼 요소에서 마우스 이벤트를 처리할 때, React.MouseEvent에 HTMLButtonElement를 제네릭 매개변수로 전달하세요.\n\n```js\ninterface Props {\n  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;\n}\n```  \n\n\n\n4.1.2 onChange 이벤트\n\n입력 요소에서의 변경 이벤트에 대해 React.ChangeEvent에 HTMLInputElement를 일반적인 매개변수로 전달하십시오.\n\n```js\nfunction App() {\n  const [value, setValue] = useState(\"\");\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setValue(event.target.value);\n  };\n\n  return <input value={value} onChange={handleChange} />;\n}\n```\n\n4.1.3 공통 이벤트 유형\n\n\n\n가장 일반적인 몇 가지입니다:\n\n- React.MouseEvent: 클릭이나 마우스 이동과 같은 마우스 이벤트에 사용됩니다.\n- React.ChangeEvent: 값이 변경될 때 주로 폼 요소에서 변경 이벤트에 사용됩니다.\n- React.KeyboardEvent: 키 입력을 캡처하는 키보드 이벤트에 사용됩니다.\n- React.DragEvent: 드래그 앤 드롭 상호작용에 사용됩니다.\n- React.FocusEvent: onFocus 및 onBlur와 같은 포커스 관련 이벤트에 사용됩니다.\n- React.FormEvent: 관련된 모든 폼 상호작용을 포함하는 폼 이벤트에 사용됩니다.\n- React.WheelEvent: 스크롤링과 같은 마우스 휠 이벤트에 사용됩니다.\n- React.TouchEvent: 터치 기능 장치에서 터치 이벤트에 사용됩니다.\n- React.ClipboardEvent: 복사 및 붙여넣기와 같은 클립보드 이벤트에 사용됩니다.\n- React.AnimationEvent: CSS 애니메이션 이벤트에 사용됩니다.\n- React.TransitionEvent: CSS 전환 이벤트에 사용됩니다.\n\n4.1.4 HTML 태그 및 유형 매핑\n\nReact와 TypeScript를 함께 사용할 때 이벤트를 처리하거나 참조를 만들 때 HTML 태그를 해당 유형으로 매핑하는 것이 중요합니다. 이러한 매핑을 통해 이벤트 핸들러나 참조가 해당 요소에 특정한 속성과 메서드에 액세스할 수 있도록 보장됩니다. TypeScript에서 일반적인 HTML 태그와 해당 유형은 다음과 같습니다:\n\n\n\n```js\n인터페이스 HTMLElementTagNameMap {\n  \"a\": HTMLAnchorElement;\n  \"article\": HTMLElement;\n  \"aside\": HTMLElement;\n  \"body\": HTMLBodyElement;\n  \"br\": HTMLBRElement;\n  \"button\": HTMLButtonElement;\n  \"canvas\": HTMLCanvasElement;\n  \"div\": HTMLDivElement;\n  \"dl\": HTMLDListElement;\n  \"dt\": HTMLElement;\n  \"dd\": HTMLElement;\n  \"em\": HTMLElement;\n  \"footer\": HTMLElement;\n  \"form\": HTMLFormElement;\n  \"h1\": HTMLHeadingElement;\n  \"h2\": HTMLHeadingElement;\n  \"h3\": HTMLHeadingElement;\n  \"h4\": HTMLHeadingElement;\n  \"h5\": HTMLHeadingElement;\n  \"h6\": HTMLHeadingElement;\n  \"head\": HTMLHeadElement;\n  \"header\": HTMLElement;\n  \"html\": HTMLHtmlElement;\n  \"iframe\": HTMLIFrameElement;\n  \"img\": HTMLImageElement;\n  \"input\": HTMLInputElement;\n  \"label\": HTMLLabelElement;\n  \"link\": HTMLLinkElement;\n  \"main\": HTMLElement;\n  \"nav\": HTMLElement;\n  \"p\": HTMLParagraphElement;\n  \"picture\": HTMLPictureElement;\n  \"section\": HTMLElement;\n  \"select\": HTMLSelectElement;\n  \"span\": HTMLSpanElement;\n  \"strong\": HTMLElement;\n  \"table\": HTMLTableElement;\n  \"tbody\": HTMLTableSectionElement;\n  \"textarea\": HTMLTextAreaElement;\n  \"tfoot\": HTMLTableSectionElement;\n  \"thead\": HTMLTableSectionElement;\n  \"title\": HTMLTitleElement;\n  \"tr\": HTMLTableRowElement;\n  \"ul\": HTMLUListElement;\n  \"li\": HTMLLIElement;\n  \"video\": HTMLVideoElement;\n}\n```\n\n## 4.2 Event Handler Function Types\n\nReact는 이벤트 핸들러 함수 유형을 제공하여 이벤트 핸들러의 타입을 지정할 수 있습니다. 이러한 유형은 요소 유형을 매개변수로 사용할 수 있는 제네릭입니다.\n\n4.2.1 onChange 이벤트\n\n\n\n\n이벤트 유형을 직접 사용하는 것 외에도 React의 이벤트 핸들러 유형을 사용할 수 있습니다. 이전에 언급한 input의 change 이벤트에 대해:\n\n```js\nconst handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n  setValue(event.target.value);\n};\n```\n\nReact.ChangeEventHandler 유형을 사용하여 다시 작성할 수 있습니다:\n\n```js\nconst handleChange: React.ChangeEventHandler<HTMLInputElement> = (event) => {\n  setValue(event.target.value);\n};\n```\n\n\n\n이벤트 객체는 자동으로 `React.ChangeEvent<HTMLInputElement>` 유형으로 추론됩니다.\n\n4.2.2 일반 이벤트 핸들러 함수 유형\n\n이벤트의 유형에 따라 React는 사용할 수 있는 다양한 이벤트 핸들러 함수 유형을 제공합니다:\n\n- React.MouseEventHandler: 클릭 또는 마우스 이동과 같은 마우스 이벤트에 대해.\n- React.ChangeEventHandler: 값이 변경될 때 주로 폼 요소 내의 변경 이벤트에 대해.\n- React.KeyboardEventHandler: 키 누름을 캡처하는 키보드 이벤트에 대해.\n- React.DragEventHandler: 드래그 앤드 드롭 상호작용에 대해.\n- React.FocusEventHandler: onFocus 및 onBlur와 같은 포커스 관련 이벤트에 대해.\n- React.FormEventHandler: 모든 관련 폼 상호작용을 아우르는 폼 이벤트에 대해.\n- React.WheelEventHandler: 스크롤링과 같은 마우스 휠 이벤트에 대해.\n- React.TouchEventHandler: 터치 기능 장치에서 터치 이벤트에 대해.\n- React.ClipboardEventHandler: 복사 및 붙여넣기와 같은 클립보드 이벤트에 대해.\n- React.AnimationEventHandler: CSS 애니메이션 이벤트에 대해.\n- React.TransitionEventHandler: CSS 전환 이벤트에 대해.\n\n\n\n위의 특정 함수 유형을 사용함으로써 이벤트 핸들러가 처리하는 이벤트 유형에 따라 올바르게 입력된 것을 보장하여 타입 안전성을 높이고 이벤트 처리 로직에서 잠재적인 버그를 방지할 수 있습니다.\n\n# 5. 유틸리티 타입\n\nTypeScript는 타입을 쉽게 조작할 수 있도록 도와주는 여러 유틸리티 타입을 제공하며, 수많은 타입을 수동으로 정의할 필요 없이 코드를 유연하고 재사용 가능하게 만들어줍니다.\n\n다음은 일반적으로 사용되는 유틸리티 타입에 대한 간단한 개요입니다:\n\n\n\n- Partial`T`: 이 유틸리티 타입은 타입 T를 가져와서 그 모든 속성을 옵션으로 만듭니다. 원본 타입의 모든 속성을 포함하지 않는 객체를 만들고 싶을 때 유용합니다.\n- Required`T`: Partial의 반대로, 이 유틸리티 타입은 타입 T를 가져와서 그 모든 속성을 필수로 만듭니다.\n- Readonly`T`: 이 유틸리티 타입은 타입 T를 가져와서 그 모든 속성을 읽기 전용으로 만듭니다. 즉, 값이 변경될 수 없습니다.\n- Record`K, T`: 이 유틸리티 타입은 타입 T의 일련의 속성 K를 가진 타입을 생성합니다. 고정된 키 집합으로 객체 타입을 만드는 데 유용합니다.\n- Pick`T, K`: 이 유틸리티 타입은 타입 T에서 속성 K 집합을 선택하여 타입을 생성합니다.\n- Omit`T, K`: 이 유틸리티 타입은 타입 T에서 속성 K 집합을 제외하여 타입을 생성합니다.\n- ReturnType`T`: 이 유틸리티 타입은 함수 타입을 가져와서 해당 반환 타입을 생성합니다.\n- InstanceType`T`: 이 유틸리티 타입은 생성자 함수 타입을 가져와서 해당 생성자에 의해 만들어진 인스턴스의 타입을 생성합니다.\n\n더 자세한 정보를 원하시면 이전의 기사를 참고해주세요:\n\n# 결론\n\n요약하면, TypeScript는 React 개발 경험을 향상시키는 강력한 기능 세트를 제공합니다. 엄격한 타입을 사용하여 컴포넌트의 속성과 상태를 정의하고 이벤트를 처리하며 유틸리티 제너릭을 활용하면 TypeScript는 코드 신뢰성과 유지 관리성을 보장합니다. 이 개념을 숙지하면 개발자는 더 예측 가능하고 오류에 강한 응용 프로그램을 만들 수 있습니다. TypeScript의 다양한 타입 및 유틸리티를 탐험하여 버그를 줄이고 팀원 간 협업을 개선할 수 있습니다. 즐거운 코딩 하세요!\n\n\n\n# 친절하게 말해보자 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 격려하고 팔로우하세요 ️👏️️\n- 팔로우해요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers_0.png","tag":["Tech"],"readingTime":15},{"title":"useEffect vs useLayoutEffect를 쉽게 이해하기","description":"","date":"2024-05-14 11:53","slug":"2024-05-14-useEffectvsuseLayoutEffectinplainlanguage","content":"\n\nuseEffect vs useLayoutEffect에 대한 차이점과 유사점을 발견하고, 언제 각각을 사용해야 하는지 배워보세요.\n\n![이미지](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_0.png)\n\n본 글에서는 useEffect와 useLayoutEffect의 기능, 차이점, 그리고 각각을 언제 사용해야 하는지 다룰 것입니다.\n\n시작하기 전, 간단하고 빠른 답변을 찾는 분들을 위해:\n\n\n\n이 두 가지 리액트 훅은 비슷한 기능을 하며 동일한 방식으로 작동합니다.\n\n차이점은 useLayoutEffect가 화면의 변경 사항을 사용자가 볼 수 있는 렌더링 이전에 호출되는 반면, useEffect는 사용자가 화면의 변경 사항을 볼 수 있는 렌더링 이후에 호출된다는 것입니다.\n\n나중에 이것이 무슨 의미인지 자세히 살펴보겠습니다.\n\n지금은 useLayoutEffect 예제와 useEffect 예제를 간단히 살펴보며 시작해보겠습니다.\n\n\n\n![이미지](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_1.png)\n\n# useLayoutEffect와 useEffect의 유사점은 무엇인가요?\n\nReact 훅인 useLayoutEffect와 useEffect는 실제로 사용법과 역할 측면에서 완전히 동일합니다. 두 훅의 서명(signature)은 동일합니다.\n\n그러므로 질문에 대한 대답은 매우 유사합니다. 두 훅을 구분하는 핵심적인 차이점이 단 하나뿐이라는 것입니다.\n\n\n\n이러한 훅은 React 컴포넌트에서 작업을 수행할 수 있게 해줍니다. 이 작업들은 조건부로 실행되어 매번 렌더링할 때마다 실행하는 것을 피해 비용이 많이든다.\n\n이제 useEffect에 대해 구체적으로 이야기해 보겠습니다. 이것은 React 내에서 사용되는 핵심 훅 중 하나로, useState와 함께 React에서 사용하는 중요한 요소입니다.\n\nuseEffect 훅은 API 호출, 상태 설정, 타이머 사용, 구독, 변이 등과 같은 다양한 작업을 수행하는 데 사용됩니다.\n\n다시 말해, 첫 번째 렌더링 시 또는 프롭이 변경될 때와 같이 가끔 실행하고 싶은 코드가 있다면, useEffect를 사용하여 실행할 수 있습니다.\n\n\n\nuseEffect를 사용하는 예제입니다:\n\n![useEffect Example](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_2.png)\n\n보시다시피 useEffect 후크가 있고, 이를 두 가지로 제공하고 있습니다. 콜백 함수와 의존성 배열입니다.\n\n콜백 함수에는 실행하려는 모든 코드와 해당 코드가 실행되어야 하는 조건이 포함될 것입니다 (필요한 경우).\n\n\n\n의존성 배열은 useEffect가 호출될 때 콜백을 조건부로 실행할 수 있는 변수 배열입니다.\n\n이 훅이 호출되면 리액트는 의존성 배열의 각 항목을 이전 버전과 비교합니다.\n\n만약 두 항목이 참조적 동일성(비교했을 때 동일함)을 가지고 있다면 콜백이 호출되지 않습니다. 그러나 일치하지 않는다면 콜백이 호출됩니다.\n\n여기 참조적 동일성의 빠른 예시입니다:\n\n\n\n![image](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_3.png)\n\n# useLayoutEffect vs useEffect의 차이점은 무엇인가요?\n\n이제 이 두 훅 간의 차이점에 대해 이야기해보겠습니다.\n\n이 게시물의 시작 부분에서 useEffect가 페이지와 상호 작용할 수 있는 시점에 실행되고, useLayoutEffect는 페이지와 상호 작용하기 전에 실행된다고 말했습니다. 그것에 대해 조금 더 자세히 살펴보고 코드에 대한 실제로 무슨 의미인지 이해해 봅시다.\n\n\n\n## 1. 실행 순서\n\nuseLayoutEffect은 화면을 그리기 위해 DOM을 기다리지 않고 즉시 실행됩니다. 이것은 실행 순서에 영향을 미칩니다.\n\nuseEffect 훅 안에서,\n\n```js\nuseEffect(() => {\nconsole.log(\"log 1\")\n}, [])\nuseEffect(() => {\nconsole.log(\"log 2\")\n}, [])\n```\n\n\n\n위 코드는 다음과 같이 출력됩니다:\n\n```js\nlog 1\nlog 2\n```\n\n이것은 useEffect와 함께 작업할 때 예상되는 동작입니다. 지정된 순서대로 실행됩니다.\n\n이제 두 번째 훅을 useLayoutEffect로 바꿔봅시다:\n\n\n\n```js\nuseEffect(() => {\nconsole.log(\"log 1\")\n}, [])\nuseLayoutEffect(() => {\nconsole.log(\"log 2\")\n}, [])\n```\n\n위의 출력결과,\n\n```js\nlog 2\nlog 1\n```\n\n예상대로, useLayoutEffect는 DOM 변이와 관계없이 실행되므로 useEffect 훅보다 더 빠르게 실행됩니다.\n\n\n\n## 2. 시각적 불일치\n\n복잡한 사용자 상호작용에 애니메이션이 포함된 경우 ref를 다룰 때 useEffect 대신 useLayoutEffect를 사용하는 것이 좋을 수 있습니다.\n\n```js\nReact.useLayoutEffect(() => {\n  console.log(ref.current)\n})\n```\n\n위의 예시에서 useLayoutEffect는 기다렸다가 값을 업데이트한 후 다른 코드 조각으로 넘어갑니다. useEffect 훅에서 발생하는 애니메이션 깜빡임을 개선할 수 있을 수도 있습니다.\n\n\n\n이것은 비싼 후크 실행과 부드러운 애니메이션 사이의 타협점입니다. 그러나 React는 작은 사용 사례에 대해 최적화되어 충분히 빠르기 때문에 두 가지 사이에 신경 쓸 필요가 없을 겁니다.\n\n## 3. useLayoutEffect 및 SSR\n\n악명 높은 useLayoutEffect 경고가 있습니다.\n\n“경고: 서버에서 useLayoutEffect는 아무것도 수행하지 않습니다. 왜냐하면 해당 효과가 서버 렌더러의 출력 형식으로 인코딩될 수 없기 때문입니다…\"\n\n\n\nSSR을 다룰 때는 JavaScript가 제대로 로드될 때까지 useEffect 및 useLayoutEffect가 작동하지 않습니다. 따라서 콘솔에서 위와 같은 경고 메시지를 볼 수 있습니다. useEffect는 컴포넌트의 렌더 주기와 상관이 없기 때문에 해당 경고가 발생하지 않는 것이며, useLayoutEffect는 사용자가 컴포넌트를 처음으로 렌더링할 때 사용자가 보게 될 사항을 고려하고 중요시합니다.\n\nReact 커뮤니티는 이 문제를 해결하기 위해 두 가지 방법을 제안합니다.\n\n1. 물론 가능하다면 useEffect 훅으로 변환해 보는 것이 첫 번째 시도입니다.\n\n2. useEffect에서 깜빡거림 문제가 있는 경우나 개발자가 useLayoutEffect를 필요로 하는 경우, 다른 방법으로는 JavaScript가 제대로 로드될 때까지 해당 훅을 사용하는 컴포넌트를 지연시키는 것이 될 수 있습니다. 다시 말해, React 컴포넌트를 게으르게 로드하는 방법입니다.\n\n\n\n# useLayoutEffect와 useEffect를 사용할 때에 대한 요약\n\nuseEffect를 사용하여 시작하는 것이 좋습니다. 대부분의 경우 그냥 그대로 두어도 될 것입니다.\n\n만약 useEffect를 사용할 때 DOM 변이가 있고 문제가 발생한다면, 예를 들어 UI가 한 가지에서 빠르게 다른 것으로 변경되는 상황이라면, useEffect가 시각적 변경 후에 로드되기 때문에 useLayoutEffect로 전환하는 것을 고려해야 합니다.\n\n마지막으로 useLayoutEffect와 useEffect의 차이를 기억하기 위한 도움이 되는 글:\n\n\n\n- useLayoutEffect: DOM 변경 후, 시각적 변화 전 그리고 브라우저가 그리기 전에 발생합니다. 이는 사용자가 코드를 기다려야 한다는 것을 의미합니다.\n- useEffect: DOM 변경 후, 시각적 변화 후, 그리고 브라우저가 이미 그린 후에 발생합니다. 이는 사용자가 코드를 기다릴 필요가 없다는 것을 의미합니다.\n\n만일 이 이야기를 즐겼다면 👏 버튼을 클릭하고 공유해 주세요. 다른 사람들도 발견할 수 있도록! 아래에 댓글을 남겨주시면 감사하겠습니다.\n\nGroww 엔지니어링팀은 기술 습작, 최신 기술 및 일반적인 프로그래밍 문제를 해결하는 더 나은 방법을 게시합니다. 최신 업데이트를 받으려면 여기에서 구독해주세요.\n\n저희는 채용 중입니다. 채용 공고를 확인하려면 여기를 클릭해주세요.","ogImage":{"url":"/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_0.png"},"coverImage":"/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_0.png","tag":["Tech"],"readingTime":5},{"title":"React Vite Typescript에서 SVG 사용하는 방법","description":"","date":"2024-05-14 11:52","slug":"2024-05-14-HowtoUseSVGinReactViteTypescript","content":"\n\nSVG(Scalable Vector Graphics)은 확장 가능성과 유연성으로 현대 웹 개발에서 중요한 역할을 하고 있어요. React와 결합하면 동적이고 시각적으로 멋진 사용자 인터페이스를 만들 수 있는 무궁무진한 가능성이 열립니다. 이 안내서에서는 SVG를 React 프로젝트에 효과적으로 통합하는 방법을 살펴볼 거에요.\n\n구현 세부 사항에 들어가기 전에, React 내에서 SVG 기초를 이해하는 게 중요해요. React에서 SVG 요소는 일반 HTML 요소와 마찬가지로 JSX 내에 매끄럽게 통합될 수 있어요. 이 통합은 React의 상태와 프롭 메커니즘을 활용하여 SVG 요소를 동적으로 조작하는 데 개발자들에게 힘을 실어줘요. 결과적으로 SVG 그래픽은 애플리케이션 상태 변경에 반응하여 매우 유연하며 매력적인 사용자 인터페이스를 만드는 데 도움이 돼요.\n\n```js\nnpm install vite-plugin-svgr\n```\n\n- vite-plugin-svgr: 이것은 설치되는 npm 패키지의 이름이에요. \"vite-plugin-svgr\"은 Vite와 함께 작동하도록 설계된 플러그인이에요. Vite는 빠른 개발 서버, 최적화된 프로덕션 빌드 등 다양한 기능을 제공하는 차세대 프런트엔드 도구에요. 이 특정 플러그인을 사용하면 Vite로 구동되는 React 프로젝트에서 SVG 파일을 직접 구성 요소로 사용할 수 있어요. SVGR 라이브러리를 활용하는 거죠.\n\n\n\nTypeScript로 작업하는 Vite 프로젝트에서는 컴포넌트, 모듈 또는 기타 TypeScript 파일에 대해 TypeScript 선언 파일(.d.ts 파일)을 생성해야 할 수 있습니다. 선언 파일은 TypeScript 코드에 대한 유형 정보를 제공하고 더 나은 IDE 지원, 유형 확인 및 코드 문서화를 가능하게 합니다.\n\n```js\nnpm install vite-plugin-dts\n```\n\n```js\nimport { defineConfig } from \"vite\";\nimport svgr from \"vite-plugin-svgr\";\nimport dts from \"vite-plugin-dts\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  build: {\n    outDir: \"build\",\n  },\n  plugins: [ svgr(), dts(), react()],\n});\n```\nvite.config.ts 파일을 해당 내용으로 변경하세요.\n\n\n\n루트 디렉토리에 svg.d.ts라는 파일을 만들어주세요.\n\n```js\ndeclare module \"*.svg?react\" {\n  import { FunctionComponent, SVGAttributes } from \"react\";\n  const content: FunctionComponent<SVGAttributes<SVGElement>>;\n  export default content;\n}\n```\n\n위의 코드를 svg.d.ts 파일에 붙여넣기해주세요.\n\n```js\n\"include\": [\"src\",\"src/vite-env.d.ts\"],\n```\n\n\n\n이제 tsconfig.json에 위 src, src/vite-env.d.ts를 추가하세요.\n\n그런 다음 Svg를 Component로 가져와서 React Component로 사용할 수 있습니다.\n\n```js\nimport CollectHoverIcon from \"../../assets/Collections.svg?react\";\n```\n\n이제 이 Svg를 React Component로 가져올 수 있습니다. 가져오는 디렉토리 끝에 ?react을 추가하는 것을 잊지 마세요.\n\n\n\n파일 경로에 \"?react\"가 추가되어 있는 경우, 보통 이는 SVG 파일이 React 사용을 위해 특정 최적화나 변환을 적용하여 가져오고 있음을 나타냅니다. 많은 경우, 이는 SVG 파일이 정적 자산이 아닌 React 구성 요소로 가져올 수 있다는 의미일 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-HowtoUseSVGinReactViteTypescript_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoUseSVGinReactViteTypescript_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 네이티브 또는 엑스포 앱에서의 I18n","description":"","date":"2024-05-14 11:51","slug":"2024-05-14-I18ninYourReactNativeorExpoApps","content":"\n\n<img src=\"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png\" />\n\n현대 기술 생태계에서 지리적 경계를 넘어 전 세계 관객을 대상으로 서비스를 제공하는 것이 예외가 아닌 표준이 되었습니다.\n\ni18n-js로 시작하기\n\n# 설치\n\n\n\n```js\n# npm\nnpm install i18n-js expo-localization\n\n# yarn\nyarn add i18n-js expo-localization\n\n# pnpm\npnpm add i18n-js expo-localization\n\n# bun\nbun add i18n-js expo-localization\n```\n\n## 그런 다음 루트 또는 src 폴더에 i18n.ts 파일을 생성하십시오.\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n  en: {\n    hello: \"hello %{name}!\"\n  },\n  zh: {\n    hello: \"안녕하세요 %{name}!\"\n  },\n});\n\ni18n.defaultLocale = deviceLanguage;\n\ni18n.locale = deviceLanguage;\n```\n\n## 그러면 locales 폴더에 다국어 JSON 파일을 생성할 수 있습니다.\n\n\n\n```js\n// (root)/src/locales/en.json\n{\n hello: \"안녕 %{name}!\"\n}\n```\n\n```js\n// (root)/src/locales/zh.json\n{\n hello: \"안녕하세요 %{name}!\"\n}\n```\n\ni18n.ts 변경사항\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\n+import en from '../locales/en.json';\n+import zh from '../locales/zh.json';\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n+  en,\n+  zh,\n});\n\ni18n.defaultLocale = deviceLanguage;\n\ni18n.locale = deviceLanguage;\n```\n\n\n\n이제 컴포넌트에서 사용할 수 있어요. 여기 컴포넌트에서 translate 함수를 사용하는 예시가 있어요.\n\n```js\n// example.tsx\nimport { i18n } from '../lib/i18m';\n\nfunction Example() {\n return <div>{i18n.t(\"hello\", {name: \"Toy\"})}</div>\n}\n```\n\n하지만 로컬을 변경하고 싶어요, 어떻게 해야 할까요?\n\n걱정 마세요, i18n.ts 파일에 changeLanguage 함수를 정의할 수 있어요.\n\n\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\nimport en from '../locales/en.json';\nimport zh from '../locales/zh.json';\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n  en,\n  zh,\n});\n\ni18n.defaultLocale = deviceLanguage;\ni18n.locale = deviceLanguage;\n\n+ export function changeLanguage(lang: string) {\n+  i18n.locale = lang;\n+ }\n```\n\n그런 다음 이 함수를 언어 변경 컴포넌트에 사용할 수 있습니다.\n\n```js\n// example.tsx\nimport { i18n, changeLanguage } from '../lib/i18n';\nimport { View, Button } from 'react-native';\n\nfunction Example() {\n return (\n  <View>\n   <View>{i18n.t(\"hello\", {name: \"Toy\"})}</View>\n   <Button onPress={() => changeLanguage('zh')} title=\"언어 변경\"/>\n  </View>\n );\n}\n```\n\n너무 간단해 보이지 않나요? 이 패키지는 매우 강력하고 실용적입니다.\n\n\n\n\n이 라이브러리는 Rails-i18n에서 제공하는 기본 번역을 사용할 수 있습니다.\n\n마지막으로, i18n-js에서 더 많은 정보를 읽으려면 공식 문서로 이동할 수 있습니다.\n\nReact Native 및 Expo 앱에서 i18n을 채택하면 미래를 대비한 글로벌 확장의 길이 열립니다. 국제화는 일회성 작업이 아닌 앱이 전 세계에서 관련성을 유지하고 접근성이 있으며 사용자 친화적인 지속적인 의무라는 것을 명심해야 합니다.\n\n경험 많은 개발자이든 처음 국제화를 시작하는 중이든, 전 세계적인 모바일 앱을 개발하는 길은 당신 손안에 있으며, i18n-js는 이 추구에서 믿을 수 있는 동료입니다. React Native 및 Expo 앱의 최대 잠재력을 발휘하여 세계의 언어로 강화시키는 시간입니다.\n\n\n\n이 기사를 읽어 주셔서 감사합니다. 최대한 많이 박수/추천 해 주시고 친구들과 공유도 꼭 해주세요. 제게는 매우 중요한 일이죠.","ogImage":{"url":"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png"},"coverImage":"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png","tag":["Tech"],"readingTime":3}],"page":"41","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}