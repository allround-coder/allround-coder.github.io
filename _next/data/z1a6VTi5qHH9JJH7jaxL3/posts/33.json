{"pageProps":{"posts":[{"title":"2024년에 Nodejs로 CLI 애플리케이션 만들기","description":"","date":"2024-05-14 14:25","slug":"2024-05-14-BuildingaCLIAppwithNodejsin2024","content":"\n\n## Node.js로 CLI 앱을 만드는 과정을 자세히 안내하는 스텝바이스텝 가이드입니다. 명령 처리와 사용자 프롬프트부터 사용자 경험 향상, 프로젝트 구조 정리 및 문서화에 이르기까지 모든 것을 다루고 있습니다.\n\n![CLI App with Node.js](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png)\n\n## 왜 Node.js를 사용해야 하는가?\n\n이벤트 기반 아키텍처와 이를 위해 특별히 설계된 많은 패키지를 제공하는 npm 생태계로 인해 효율적이고 확장 가능한 CLI 도구를 개발하는 데 가장 적합한 선택지가 됩니다.\n\n\n\n## CLI 앱을 만드는 이유는?\n\n- 작업 자동화\n- 개발자를 위한 도구 만들기\n- 시스템과 흐름 관리와 상호작용\n\n## 실제 예시\n\nNielsen에서는 많은 가치를 제공하는 여러 CLI를 만들었습니다.\n\n\n\n- CI/CD 플로우에서 동적 파이프라인을 관리하는 CLI — 더 이상 수동 구성이나 프로세스 간 대기가 필요하지 않아요.\n- 로컬 도커 환경을 설정하고 관리하는 CLI.\n- 마이그레이션을 위한 미리 정의된 단계를 실행하는 CLI.\n\n이제 한 개 만드는 것이 얼마나 쉬운지 알게 될 거예요.\n바로 코드로 빠져들기를 원하시는 분들을 위해, 파일은 여기서 찾을 수 있어요.\n\n# 목차\n\n- 설정하기\n∘ 프로젝트 부트스트랩\n∘ Commander.js 가져오기\n∘ CLI 만들기\n- 유저 경험\n∘ 색상 추가하기\n∘ 쉬운 프롬프팅\n∘ 멋진 로더\n∘ ASCII 아트 추가하기\n- 프로젝트 구조\n- 문서화\n∘ 자동 문서 생성\n- 최선의 실천법\n\n\n\n# 설정하기\n\n먼저 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요.\n\n## 단계 1: 프로젝트 시작하기\n\n프로젝트를 위한 새 폴더를 만들고 그 안으로 들어가세요:\n\n\n\n```js\nmkdir my-node-cli\ncd my-node-cli\n```\n\n새 Node.js 프로젝트를 시작해보세요:\n\n```js\nnpm init\n```\n\n## 단계 2: Commander.js 가져오기\n\n\n\nCommander.js은 Node.js에서 CLI를 구축하는 데 사용하는 핵심 도구입니다. 입력 구문 분석, 도움말 텍스트 및 오류 관리를 위한 스위스 아미 나이프가 있는 것과 같습니다.\n\n```js\nnpm install commander\n```\n\n## 단계 3: CLI 만들기\n\n프로젝트 폴더에 index.js라는 파일을 만듭니다. 이것이 우리의 CLI가 시작하는 곳이 될 것입니다. 이 CLI를 실행하기 위해 맨 위에 shebang을 추가하십시오.\n\n\n\n```md\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\n\nprogram\n  .version(\"1.0.0\")\n  .description(\"내 노드 CLI\")\n  .option(\"-n, --name <type>\", \"당신의 이름을 추가하세요\")\n  .action((options) => {\n    console.log(`안녕, ${options.name}!`);\n  });\n\nprogram.parse(process.argv);\n```\n\n패키지.json에 bin을 추가하여 CLI 명령을 인식하도록하고 CommonJS 대신 ES 모듈과 함께 작동하도록 유형을 추가하십시오:\n\n```js\n\"bin\": {\n    \"my-node-cli\": \"./index.js\"\n},\n\"type\": \"module\"\n```\n\n프로젝트를 전역적으로 연결하려면:\n```bash\nnpm link\n```\n\n\n\n```js\nnpm link \n```\n\n그러면, 내 my-node-cli가 당신의 터미널에서 실행될 준비가 끝납니다!\n\n```js\nmy-node-cli --name YourName\n```\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_1.png)\n\n\n\n참고: Node.js 18.3부터는 내장된 커맨드 라인 인수 구문 분석기가 있습니다. 이것에 대해 읽어보고 commander.js 대신 사용할지 결정할 수 있습니다.\n\n# 사용자 경험\n\n## 색상 추가하기\n\nChalk는 CLI 출력을 다채롭게 만드는 데 완벽합니다. 다음 명령을 사용하여 가져올 수 있습니다:\n\n\n\n```js\nnpm install chalk\n```\n\n이제 우리의 인사말을 개선해 보겠습니다:\n\n```js\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\nimport chalk from \"chalk\";\n\nprogram\n  .version(\"1.0.0\")\n  .description(\"내 Node CLI\")\n  .option(\"-n, --name <type>\", \"당신의 이름을 추가하세요\")\n  .action((options) => {\n    console.log(chalk.blue(`안녕, ${options.name}!`));\n    console.log(chalk.green(`안녕, ${options.name}!`));\n    console.log(chalk.red(`안녕, ${options.name}!`));\n  });\n\nprogram.parse(process.argv);\n```\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_2.png)\n\n\n\n## 손쉬운 프롬프팅\n\n더욱 상호작용적인 느낌을 원하신다면 Inquirer.js가 좋은 선택입니다.\n\n```js\nnpm install inquirer\n```\n\n데이터를 수집하기 위해 명령줄 옵션을 사용하는 대신, 사용자에게 질문하세요.\n\n\n\n```js\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\nimport chalk from \"chalk\";\nimport inquirer from \"inquirer\";\n\nprogram.version(\"1.0.0\").description(\"나의 Node CLI\");\n\nprogram.action(() => {\n  inquirer\n    .prompt([\n      {\n        type: \"input\",\n        name: \"name\",\n        message: \"당신의 이름은 무엇인가요?\",\n      },\n    ])\n    .then((answers) => {\n      console.log(chalk.green(`안녕하세요, ${answers.name}님!`));\n    });\n});\n\nprogram.parse(process.argv);\n```\n\n![Building a CLI App with Node.js](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_3.png)\n\n사용 가능한 Confirm 프롬프트 유형이 있습니다. 사용자에게 예/아니오 질문을 합니다.\n\n![Building a CLI App with Node.js](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_4.png)\n\n\n\n\n프롬프트 유형 — 사용자가 옵션 목록에서 선택할 수 있도록 합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_5.png)\n\n또한 체크박스, 비밀번호, 목록 및 확장 기능도 있습니다. https://github.com/SBoudrias/Inquirer.js에서 더 많이 알아보세요.\n\n## 멋진 로더들\n\n\n\n로딩 시간을 어떻게 보내시나요? ora를 사용하면 재미있게 만들 수 있어요. 스피너 애니메이션을 추가하는 데 좋아요:\n\n```js\nnpm install ora\n```\n\n시간이 걸리는 프로세스에 로더를 뿌려보세요:\n\n```js\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\nimport chalk from \"chalk\";\nimport inquirer from \"inquirer\";\nimport ora from \"ora\";\n\nprogram.version(\"1.0.0\").description(\"My Node CLI\");\n\nprogram.action(() => {\n  inquirer\n    .prompt([\n      {\n        type: \"list\",\n        name: \"choice\",\n        message: \"옵션을 선택하세요:\",\n        choices: [\"옵션 1\", \"옵션 2\", \"옵션 3\"],\n      },\n    ])\n    .then((result) => {\n      const spinner = ora(`${result.choice} 작업 중...`).start(); // 스피너 시작\n\n      setTimeout(() => {\n        spinner.succeed(chalk.green(\"완료!\"));\n      }, 3000);\n    });\n});\n\nprogram.parse(process.argv);\n```\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*wFmspYHAW5572fRutff1MQ.gif\" />\n\n## ASCII Art 추가\n\nfiglet.js로 마지막 손질을 해봅시다:\n\n```js\nnpm install figlet\n```\n\n\n\nindex.js에 다음을 추가해주세요.\n\n```js\nimport figlet from \"figlet\";\n\nconsole.log(\n  chalk.yellow(figlet.textSync(\"My Node CLI\", { horizontalLayout: \"full\" }))\n);\n```\n\n<img src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_6.png\" />\n\nCLI의 aesthetic에 맞게 ASCII 아트를 맞춤화할 수 있는 다양한 글꼴 및 사용자 정의 옵션이 있습니다.\n\n\n\n# 프로젝트 구조\n\n프로젝트를 깔끔하게 유지하면 나중에 시간을 아낄 수 있어요, 특히 프로젝트가 커지면 더욱 그렇습니다. 다음은 시작하기에 좋은 간단하면서도 효과적인 구조입니다:\n\n```js\nmy-node-cli/\n├─ bin/\n│ └─ index.js\n├─ src/\n│ ├─ commands/\n│ ├─ utils/\n│ └─ lib/\n├─ package.json\n└─ README.md\n```\n\n- bin — 여러분의 CLI가 있는 곳입니다. 누군가가 CLI를 실행할 때 호출되는 곳입니다.\n- src/commands — 개별 명령어 파일이 있는 위치입니다. 새로운 명령어를 추가하거나 기존 명령어를 편집할 때 더 깔끔하게 작업할 수 있습니다.\n- src/utils — 여러 명령어에서 필요한 유틸리티 함수를 담고 있습니다. 데이터 형식 설정과 같은 기능이 포함될 수 있습니다.\n- src/lib — 여러분의 CLI가 API와 상호 작용하거나 복잡한 로직을 실행하는 경우 주요 기능이 위치할 수 있습니다.\n\n\n\n# 문서화\n\n명확한 문서화가 중요합니다. 사용자를 명령줄 도구를 통해 직접 놀라운 작업을 수행할 수 있도록 설치, 사용법 및 명령 옵션을 README.md에 개요로 기록하십시오.\n\n```js\n# 내 노드 CLI\n내 노드 CLI는 터미널에서 직접 멋진 작업을 수행할 수 있는 도구입니다.\n\n## 설치\n\n```bash\nnpm install -g my-node-cli\n```\n\n## 사용법\n내 노드 CLI를 사용하려면 다음을 실행하십시오:\n\n```bash\nmy-node-cli - help\n```\n\n### 명령어\n- `my-node-cli - name YourName`: 당신의 이름으로 인사합니다.\n- `my-node-cli option1`: 옵션 1을 실행합니다.\n\n더 자세한 명령어 정보는 `my-node-cli --help`를 실행해 주세요.\n\n## 기여하기\n기여는 환영합니다...\n\n## 라이선스\n이 프로젝트는 라이선스가 부여되었습니다...\n \n\n## 문서 자동 생성하기\n\n\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n```js\n/**\n * 이 함수는 사용자의 이름으로 인사합니다.\n * @param {string} name 사용자의 이름\n */\nconst greet = (name) => {\n  console.log(`안녕, ${name}!`);\n};\n```\n\n# Best Practices\n\n실제 CLI 논리 작업을 시작하기 전에 Liran Tal의 이 리포를 확인하는 것을 강력히 권장합니다. 이 리포는 3천 개 이상의 스타를 받았으며 제가 생각한 모든 최상의 실천 방법과 그 이상을 다룹니다.\n\n\n\n예를 들어, 사용자가 호출할 때 동일한 정보를 반복해서 제공하는 것을 요구하지 않고, 상태를 유지하면서 사용자 경험을 제공할 수 있습니다. conf를 사용하여 사용자 이름, 이메일 또는 API 토큰과 같은 데이터를 저장할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_7.png)\n\n이 모든 것이 실제로 작동하는 것을 보고 싶나요? 모든 예시 파일과 함께 완성된 프로젝트를 제 GitHub 페이지에서 확인해보세요. 들어가서 둘러보고, 자유롭게 실험해보세요. 만약 도움이 된다면 리포지토리를 fork하거나 스타를 눌러주세요!","ogImage":{"url":"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png","tag":["Tech"],"readingTime":7},{"title":"웹지엘WebGL로 애니메이션된 물 효과 구현하기 반사와 굴절 추가하기","description":"","date":"2024-05-14 14:23","slug":"2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL","content":"\n\n![워터 이미지](/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png)\n\n물은 컴퓨터 그래픽에서 렌더링하기 가장 어려운 부분 중 하나이면서 동시에 가장 보상이 큰 요소 중 하나입니다, 특히 실시간으로 처리할 때입니다. 잘 보이는 물은 시각적으로 매력적이며 나는 항상 현실적인 물을 렌더링하는 도전에 매혹을 느꼈습니다. 그래서 나는 지난 몇 주간 WebGL 엔진에 물을 추가해 보았습니다. 이 게시물에서는 WebGL에서 물을 렌더링하는 데 사용할 수 있는 다양한 기술과 제가 구현한 것에 대해 알아보겠습니다.\n\n# 기본 물\n\n실시간 그래픽에서 물을 렌더링하는 여러 가지 방법이 있습니다. 장면의 모양에 따라 쉬울 수도, 매우 복잡할 수도 있습니다. 아마 가장 간단한 방법은 큰 파란색 사각형을 그리는 것입니다. 이것만으로도 Minecraft 환경과 같은 것에 충분할 수도 있습니다.\n\n\n\n파란색 쿼드에서 발전하는 다음 단계는 원활한 애니메이션된 물 질감을 추가하고 루프를 돌아야 할 것입니다. 그러나 평면 물은 별로 흥미로워 보이지 않기 때문에 파도를 추가하는 것이 좋을 것 같습니다. 첫 번째 옵션은 쿼드를 훨씬 작은 쿼드 그리드로 세분화한 다음 버텍스의 y 위치를 버텍스 셰이더에서 애니메이션하는 것입니다. 이 접근 방식은 실제로 물 표면의 고도가 변경된다는 장점이 있습니다. 그러나 이러한 방법의 단점은 물의 크기와 규모에 따라 좋아 보이려면 많은 버텍스가 필요할 수 있다는 것입니다.\n\n두 번째 옵션은 보통 선호하는 방법이라고 할 수 있는데, 노멀 맵으로 파도를 추가하는 것입니다. 이로 인해 물의 고도는 실제로 변경되지 않고 항상 완벽히 평평합니다. 노멀 맵은 표면과 빛이 상호 작용하는 방식을 변경하기 때문에 파도가 있는 것처럼 보입니다. 노멀은 프래그먼트 수준에서 계산되고 애니메이션되며, 이는 성능에 미치는 영향이 최소화되면서 작은 파도를 쉽게 추가할 수 있다는 것을 의미합니다.\n\n과거에는 사인스 패턴이나 인터넷에서 가져온 물 질감 및 노멀 맵을 사용했었는데, 이는 학습과 테스트에는 적합한 방법이었습니다. 그러나 (유감스럽게도 아직 출시되지 않은) 독립 개발 게임을 작업할 때는 인터넷에서 무작위 텍스처를 사용할 수 없었습니다. 대신에 나는 연속 애니메이션된 물 질감과 노멀 맵을 만들기 위한 절차적 알고리즘을 만들었습니다. 이러한 질감을 만들기 위한 꼼수는 주기적 3D Perlin 잡음입니다. 주기적 3D 잡음은 3D 공간을 완벽하게 타일링하는 3D 쿠브로 상상할 수 있으며 쿠브의 모든 면이 이웃과 일치합니다. 그런 다음 Perlin 잡음의 값들을 물의 고도로 사용하여 메시를 만들고 노멀을 계산한 다음, RGB 값으로 인코딩하게 됩니다. 비슷하게 몇 가지 다른 푸른색을 섞어 색 질감을 만들 수 있습니다. 지금까지는 C++에서만 이를 구현했으며 JavaScript 및 WebGL의 이미지만 사용하고 있습니다. 그러나 이러한 텍스처는 상당히 크기 때문에 WebGL에서는 제한된 인터넷 속도 문제로 인해 훨씬 큰 문제가 됩니다. 앞으로는 이 접근 방식을 JavaScript로 변환하고 대용량 텍스처의 평균 다운로드 속도보다 더 빠르게 생성할 수 있는지 시도해 볼 수도 있을 것입니다.\n\n# 반사 및 굴절\n\n\n\n물의 가장 상징적인 측면 중 하나는 그 반사입니다: 고요한 빙하 호수에 산과 나무가 반영되는 모습, 해질녘의 색감이 바다에 반사되는 모습, 혹은 지역 연못에 당신의 반영. 반영은 정말 멋집니다. 하지만 광선 추적 없이 반사를 어떻게 렌더링할까요? 임의의 반사는 WebGL과 같은 래스터화 API로는 매우 어려우며, 레이 트레이싱 기술의 가장 큰 이점인 그림자와 함께 구현은 더욱 어렵습니다. 가장 좋은 선택은 사전에 빠져 나온 반사 큐브맵인데, 이는 플레이어 캐릭터와 같은 동적 실시간 객체를 반사할 수 없습니다.\n\n그러나 큰 물 표면은 행운의 예외입니다. 생각해 보면, 물체의 반사는 마치 수면 아래서 보는 듯한 것이다.\n\n![image](/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_1.png)\n\n이는 단순히 카메라를 물 표면에 반사시키고 새로운 카메라 위치에서 장면을 텍스처로 렌더링하는 것을 의미합니다. 물 표면 아래의 모든 것은 어차피 반사될 수 없기 때문에 제거됩니다. 같은 트릭은 굴절에도 작동합니다. 장면은 일반 카메라 위치에서 또 다른 텍스처로 렌더링되며, 물 표면 위의 모든 것이 잘립니다.\n\n\n\n하지만, 이는 추가적인 렌더링 패스 두 개를 추가합니다. 낮은 해상도와 더 적은 세부 정보로 렌더링할 수 있지만, 장면의 복잡성에 따라 프레임 시간에 상당한 시간을 추가할 수 있습니다.\n\n물 표면이 그려질 때, 보통 맵을 사용하여 반사와 굴절을 왜곡시킬 수 있어 물결에도 영향을 받게 만들 수 있습니다.\n\n# 구현\n\n일반 맵 파도나 반사를 위해 카메라를 반사하는 것과 같은 물 관련 트릭은 그 자체로 복잡하지 않습니다. 그러나 잘 보이는 물을 얻기 위해서는 많은 작은 효과가 필요하며, 이러한 조합은 더 복잡해질 수 있습니다. 물이 잘 보이기 시작하려면 최소한 일련의 조작해야할 다양한 매개변수가 있습니다. 하나의 값이 너무 많이 벗어나면 상당히 나쁘게 보일 수 있습니다. 그러나 이것을 이용할 수도 있습니다. 몇 가지 매개변수를 이상한 값으로 설정하면 여전히 파란 물 텍스처를 사용하여 라바를 꽤 잘 보이게 만들 수도 있었습니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_2.png\" />\n\n내 WebGL 물 구현은 그것이 기반으로하는 OpenGL 버전과 비교해서 큰 향상을 이루었습니다. 물을 사용하고 싶을 때, 물 개체를 만들고 반사 및 굴절할 모든 개체를 추가하기만 하면 됩니다. 복잡한 쉐이더 전환, 유니폼, 카메라 반사 등은 내부적으로 처리됩니다. 이것이 지난 리팩터링 블로그 글에서 이야기한 쉐이더 모듈과 행렬 슬롯이 필요한 이유 중 하나였습니다. 외부에서 물 클래스를 사용하는 것은 매우 깨끗하고 간단하지만, 엔진 내부 코드는 여전히 복잡성을 줄이고 앞으로 유지보수 가능하도록 개선할 필요가 있습니다.\n\n```js\nvar water = new Sparrow.Water( engine , { /* 물 옵션 */ } );\nwater.addObject( cube );\nwater.addObject( model );\n```\n\nWebGL이나 다른 그래픽 API에서 물을 렌더링하는 것은 매우 간단한 경우부터 매우 복잡한 경우까지 다양한데, 이를 수행하는 여러 가지 방법과 맞춰야 할 많은 세부 사항이 있기 때문입니다. 그러나 이 포스트가 무엇이 필요한지에 대한 좋은 아이디어를 제공했으면 좋겠습니다. 현재 물 구현의 상태에 만족하고 있지만, 미래에 다양한 시나리오에 대해 더 맞춤화할 수 있도록 추가적인 컨트롤을 추가하고 싶습니다.\n\n\n\n원문: https://pingpoli.de.","ogImage":{"url":"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png","tag":["Tech"],"readingTime":4},{"title":"네스트JS에서 인증 구현하는 방법에 대한 상세 가이드","description":"","date":"2024-05-14 14:21","slug":"2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS","content":"\n\n이 포괄적인 안내서는 강력한 Node.js 프레임워크인 NestJS에서 인증 구현에 대한 단계별 안내를 제공합니다. 기본 개념, 최선의 실천법 및 실전 예제를 다루며, 이 안내서는 NestJS 애플리케이션을 위한 견고한 인증 시스템을 구축하기 위한 지식을 개발자들에게 제공하는 것을 목표로 합니다.\n\n![이미지](/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png)\n\n인증은 많은 애플리케이션의 기능성에서 중요한 구성 요소로 자리 잡고 있습니다. 인증 관리는 특정 프로젝트의 특정 요구 사항에 맞게 맞춘 각기 다른 접근 방식과 전략을 탐색하는 과정을 포함합니다. 이 섹션에서는 여러 인증 접근 방식을 개요하여 다양한 응용프로그램의 명백한 요구 사항을 충족시킬 수 있는 사용자 정의 옵션을 설명합니다.\n\n특정 시나리오에서 클라이언트는 사용자 이름과 비밀번호로 인증하여 프로세스를 시작합니다. 성공적인 인증 후에 서버는 JWT(JSON Web Token)를 생성하고, 이를 인증 확인을 위한 후속 요청의 권한 부여 헤더로 전송할 수 있는 베어러 토큰으로 전송합니다. 더불어, 유효한 JWT가 포함된 요청에서만 접근 가능한 안전한 경로를 설정할 것입니다.\n\n\n\n# 스텝 바이 스텝 가이드:\n\n진행은 초기 요구 사항으로 시작됩니다: 사용자 인증. 그 다음으로는 JWT를 생성하고 발급함으로써 이를 확장합니다. 마지막으로는 수신 요청 내의 유효한 JWT의 존재를 확인하는 보호된 라우트를 구축합니다.\n\n## 1. 종속성 설치\n\n```js\nnpm install @nestjs/jwt passport-jwt @types/passport-jwt\n```\n\n\n\n## 2. 인증 및 사용자 모듈 생성하기\n\n```js\nnest g module auth\nnest g controller auth\nnest g service auth\n```\n\nAuthService를 구현할 때 유용하게 사용자 작업을 캡슐화하는 UsersService를 만드는 것이 좋습니다. 그러니 바로 해당 모듈과 서비스를 생성합시다:\n\n```js\nnest g module users\nnest g service users\n```\n\n\n\n## 3. 사용자 DTO 구현\n\nData Transfer Object (DTO)는 응용 프로그램의 다른 부분 간에 네트워크를 통해 전송될 데이터를 정의하고 유효성 검사하는 데 사용되는 디자인 패턴입니다.\n\n```js\n// backend/src/dto/user/base-user.dto.ts\n```\n\n```js\nimport { ApiProperty } from '@nestjs/swagger';\nexport class BaseUser {\n  @ApiProperty()\n  id?: string;\n  @ApiProperty()\n  username?: string;\n  @ApiProperty()\n  email: string;\n  @ApiProperty()\n  password: string;\n  @ApiProperty()\n  confirmPassword?: string;\n  @ApiProperty()\n  designation?: string;\n}\n```\n\n\n\n```js\n// backend/src/dto/user/create-user.dto.ts\n```\n\n```js\nimport { BaseUser } from \"./base-user.dto\";\nexport class CreateUserDto extends BaseUser {\n  createdAt: Date;\n}\n```\n\n```js\n// backend/src/dto/user/update-user.dto.ts\n```\n\n```js\nimport { BaseUser } from \"./base-user.dto\";\nexport class UpdateUserDto extends BaseUser {\n  updatedAt: Date;\n}\n```\n\n\n\n## 4. 사용자 엔티티 구현\n\n엔티티란 TypeScript 클래스 또는 오브젝트를 가리키며 데이터베이스 테이블이나 문서의 모델을 나타냅니다. 엔티티는 TypeORM이나 Sequelize와 같은 ORM 라이브러리와 함께 사용되어 데이터베이스와 상호 작용합니다. 엔티티는 데이터 구조를 정의하며 주로 데이터베이스 테이블의 직접적인 표현입니다.\n\n```js\n// backend/src/entities/user.entity.ts\n```\n\n```js\nimport { Column, Entity, ObjectId, ObjectIdColumn } from 'typeorm';\n@Entity()\nexport class UserEntity {\n  @ObjectIdColumn()\n  id: ObjectId;\n  @Column()\n  username: string;\n  @Column()\n  email: string;\n  @Column()\n  password: string;\n  @Column()\n  createdAt: Date;\n  @Column()\n  updatedAt: Date;\n}\n```\n\n\n\n**사용자 클래스**는 **@Entity 데코레이터**로 표시되어 엔티티를 나타낸다는 것을 나타냅니다. 클래스 속성 (id, username, email, password, confirmPassword, createdAt, updatedAt)은 @PrimaryGeneratedColumn 및 @Column과 같은 데코레이터로 주석이 달려 있어 데이터베이스 스키마에서의 역할을 지정합니다.\n\n## 5. Auth Controller 구현\n\n이 NestJS 컨트롤러, **AuthController**,는 인증 관련 HTTP 요청을 처리합니다. 라우트 처리를 위해 데코레이터를 활용하고, 설명서를 위해 Swagger를 통합하며, 타입 확인을 위해 DTO를 사용합니다. **@Public 데코레이터**는 특정 엔드포인트가 인증을 요구하지 않는 것을 나타내며, **AuthService**는 실제 인증 로직을 담당합니다.\n\n```js\n// backend/src/modules/auth/auth.controller.ts\n```\n\n\n\n\n## 6. 인증 모듈 구현\n\n이 NestJS 모듈인 AuthModule은 컨트롤러, 서비스 및 가드를 포함한 인증 관련 컴포넌트를 캡슐화하고 조직화하기 위해 설계되었습니다. 전반적으로, AuthModule은 코드 조직화를 촉진하고 재사용성을 촉진하며 인증 관련 컴포넌트를 관리하는 중앙 모듈로 작용합니다. 가드, 서비스의 사용 및 JwtModule 및 TypeOrmModule과 같은 외부 모듈의 구성은 NestJS에서 모듈화되고 확장 가능한 애플리케이션 아키텍처에 가장 적합한 방법을 따릅니다.\n\n```js\n// backend/src/modules/auth/auth.module.ts\n```\n\n\n\n```js\nimport { Module } from '@nestjs/common';\nimport { AuthController } from './auth.controller';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\nimport { JwtModule } from '@nestjs/jwt';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserEntity } from 'src/entities/user.entity';\nimport { jwtConstants } from './constants';\nimport { APP_GUARD } from '@nestjs/core';\nimport { AuthGuard } from './auth.guard';\n@Module({\n  imports: [\n    UsersModule,\n    JwtModule.register({\n      global: true,\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '1d' },\n    }),\n    TypeOrmModule.forFeature([UserEntity]),\n  ],\n  controllers: [AuthController],\n  providers: [\n    {\n      provide: APP_GUARD,\n      useClass: AuthGuard,\n    },\n    AuthService\n  ],\n  exports: [AuthService]\n})\nexport class AuthModule {}\n```\n\n- JwtModule: JwtModule을 구성하고 가져와서 JSON Web Tokens (JWT)을 다루는 데 사용되며 비밀 및 만료 시간과 같은 지정된 옵션을 제공합니다.\n- TypeOrmModule.forFeature([UserEntity]): TypeORM을 구성하여 모듈 내에서 UserEntity를 제공하도록 설정합니다.\n- 'provide: APP_GUARD, useClass: AuthGuard': APP_GUARD 토큰을 사용하여 AuthGuard를 글로벌 가드로 등록합니다. 해당 가드는 JWT 토큰을 유효성 검사하고 사용자의 인증 상태를 보장하는 역할을 합니다.\n- AuthService: 해당 모듈 내에서 제공자로 AuthService를 등록합니다. 해당 서비스는 사용자 인증을 위한 비즈니스 로직을 포함하고 있을 것입니다.\n\n## 7. 인증 가드 구현:\n\nNestJS의 AuthGuard 클래스는 애플리케이션 내의 루트를 보호하기 위한 사용자 정의 인증 가드를 구현하는 역할을 합니다. 이 AuthGuard는 미들웨어로 사용되어 인증이 필요한 루트를 보호합니다. 루트의 메타데이터를 확인하고 JWT 토큰을 유효성 검사함으로써, 애플리케이션의 특정 부분에만 인증된 사용자만 접근하도록 보장합니다. 또한, 사용자 페이로드는 편리하게 요청 객체에 첨부되어 라우트 핸들러에서 추가 처리를 위해 사용됩니다.```\n\n\n\n```js\n// backend/src/modules/auth/auth.guard.ts\n```\n\n```js\nimport {\n  CanActivate,\n  ExecutionContext,\n  Injectable,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\nimport { Request } from 'express';\nimport { Reflector } from '@nestjs/core';\nimport { IS_PUBLIC_KEY } from './public-strategy';\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  constructor(private jwtService: JwtService, private reflector: Reflector) {}\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (isPublic) {\n      return true;\n    }\n    const request = context.switchToHttp().getRequest();\n    const token = this.extractTokenFromHeader(request);\n    if (!token) {\n      throw new UnauthorizedException();\n    }\n    try {\n      const payload = await this.jwtService.verifyAsync(\n        token,\n        {\n          secret: jwtConstants.secret\n        }\n      );\n      // 💡 We're assigning the payload to the request object here\n      // so that we can access it in our route handlers\n      request['user'] = payload;\n    } catch {\n      throw new UnauthorizedException();\n    }\n    return true;\n  }\n  private extractTokenFromHeader(request: Request): string | undefined {\n    const [type, token] = request.headers.authorization?.split(' ') ?? [];\n    return type === 'Bearer' ? token : undefined;\n  }\n}\n```\n\n## 8. Auth Service 구현\n\nNestJS 애플리케이션에서 이 AuthService 클래스는 사용자 인증 및 가입 프로세스를 처리하는 역할을 담당합니다.```\n\n\n\n\n\n```js\n// backend/src/modules/auth/auth.service.ts\n```\n\n```js\nimport { Injectable, UnauthorizedException } from \"@nestjs/common\";\nimport { UsersService } from \"../users/users.service\";\nimport { JwtService } from '@nestjs/jwt';\nimport { CreateUserDto } from \"src/dto/user/create-user.dto\";\n@Injectable()\nexport class AuthService {\n  constructor(private usersService: UsersService, private jwtService: JwtService) {}\n  async signIn(email, pass) {\n    const user = await this.usersService.findOneBy(email);\n    if (user?.password !== pass) {\n      throw new UnauthorizedException();\n    }\n    const payload = { sub: user.id, email: user.email };\n    return {\n      access_token: await this.jwtService.signAsync(payload),\n    };\n  }\n  async signUp(payload: CreateUserDto) {\n    const user = await this.usersService.create(payload);\n    return user;\n  }\n}\n```\n\n## 9. JWT 사용하여 비밀 키를 보관하는 상수 구현\n\nJWT 기반 인증에서, 비밀 키는 토큰의 무결성과 신뢰성을 보장하기 위해 사용되는 중요한 정보입니다. 이는 토큰을 발급하는 서버와 토큰을 유효성을 검증하는 서버 또는 클라이언트 사이에서 공유되는 비밀 키로 작용합니다.```\n\n\n\n```js\n// backend/src/modules/auth/constants.ts\n```\n\n```js\nexport const jwtConstants = {\n  secret: \"JWTSecret#@!\",\n};\n```\n\n## 10: Implement Public Strategy\n\n이 전략은 AuthModule에서 위에서 AuthGuard를 사용하여 전역 인증을 활성화했기 때문에 인증이 필요하지 않음을 나타내는 루트 또는 핸들러를 표시하는 유틸리티를 정의합니다. route 또는 핸들러에 메타데이터를 첨부하기 위해 @nestjs/common 모듈에서 SetMetadata 함수를 사용합니다.```\n\n\n\n```js\n// backend/src/modules/auth/public-strategy.ts\n```\n\n```js\nimport { SetMetadata } from '@nestjs/common';\nexport const IS_PUBLIC_KEY = 'isPublic';\nexport const Public = () => SetMetadata(IS_PUBLIC_KEY, true);\n```\n\n## 11. 사용자 모듈 구현\n\n이 모듈인 UsersModule은 응용 프로그램 내에서 사용자 관리와 관련된 기능을 구성하고 제공하는 데 전념합니다.\n\n\n\n```js\n// backend/src/modules/users/users.module.ts\n```\n\n```js\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserEntity } from 'src/entities/user.entity';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n  imports: [\n    TypeOrmModule.forFeature([UserEntity]),\n  ],\n})\nexport class UsersModule {}\n```\n\n- providers 배열: UsersService를 providers 배열에 포함합니다. 이는 UsersService가 모듈 전반에 걸쳐 injectable하게 만듭니다.\n\n2. exports 배열: UsersService를 exports 배열에 추가합니다. 즉, UsersModule을 import하는 다른 모듈에서 UsersService를 사용할 수 있습니다.\n  \n\n\n\n3. `imports` 배열: Utilizes `TypeOrmModule.forFeature([UserEntity])`를 사용하여 UserEntity를 모듈에 import합니다. 이를 통해 UserEntity와 관련된 TypeORM 기능에 액세스할 수 있습니다.\n\n## 12. 사용자 서비스 구현\n\nUsersService는 사용자 관련 데이터와 상호 작용하는 데 책임이 있으며, 이메일로 사용자를 찾거나 새 사용자를 생성하는 메서드를 제공합니다. 이 서비스에서 `@InjectRepository(UserEntity)`를 사용하여 MongoRepository`UserEntity`를 서비스에 주입합니다. 이 저장소는 UserEntity와 관련이 있으며 데이터베이스 상호 작용을 위한 메서드를 제공합니다.\n\n```js\n// backend/src/modules/users/users.service.ts\n```\n\n\n\n```js\nimport { Injectable } from \"@nestjs/common\";\nimport { InjectRepository } from \"@nestjs/typeorm\";\nimport { BaseUser } from \"src/dto/user/base-user.dto\";\nimport { CreateUserDto } from \"src/dto/user/create-user.dto\";\nimport { UserEntity } from \"src/entities/user.entity\";\nimport { MongoRepository } from \"typeorm\";\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectRepository(UserEntity)\n    private userRepository: MongoRepository<UserEntity>,\n) { }\n  async findOneBy(email: string): Promise<UserEntity | undefined> {\n    return await this.userRepository.findOneBy({ email: email });\n  }\n  async create(createUserDto: CreateUserDto) {\n    return this.userRepository.save({\n        ...createUserDto,\n        createdAt: new Date(),\n    });\n  }\n}\n```\n\nUsersService는 사용자 관련 작업에 대한 로직을 캡슐화하여 사용자 데이터와 상호 작용하는 깔끔하고 모듈식 방법을 제공합니다. 리포지토리 사용, 의존성 주입, 그리고 TypeORM과의 통합은 NestJS로 확장 가능하고 유지보수 가능한 애플리케이션을 구축하기 위한 모범 사례와 일치합니다.\n\n## Swagger에 따라 모든 것이 잘 설정되었습니다 😜:\n\n<img src=\"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_1.png\" />\n\n\n\n\n<img src=\"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_2.png\" />\n\n## 참고자료:","ogImage":{"url":"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png"},"coverImage":"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png","tag":["Tech"],"readingTime":11},{"title":"JavaScript 제너레이터에 대해 두렵지 마세요","description":"","date":"2024-05-14 14:20","slug":"2024-05-14-DontBeAfraidofJavaScriptGenerators","content":"\n\n![이미지](/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png)\n\n솔직히 말해봅시다: 제너레이터를 사용한 코드를 얼마나 자주 만나게 되나요?\n\n매일 다양한 개발자들의 코드를 검토하지만, 제너레이터를 거의 만나지 못합니다.\n\n그 이유는 무엇일까요?\n\n\n\n사람들은 이해하지 못하나요? 아니면 혜택을 못 보는 건가요?\n\nJavaScript는 유연성과 폭넓은 기능으로 유명한데요, ECMAScript 2015에서 독특한 도구인 제너레이터를 소개했습니다. 이들은 비동기 프로그래밍을 제어하고, 반복 가능한 객체를 생성하며, 여러 값을 반환하는 강력한 수단입니다. 이 안내서에서는 제너레이터의 동작 방식, 적용 분야, 그리고 어떻게 잠재력을 활용할 수 있는지 배워볼 거에요.\n\n# 제너레이터란 무엇인가요?\n\n제너레이터는 전통적인 함수와 다릅니다. 그들은 실행을 여러 번 시작하고 중단할 수 있어요. 이는 여러 값을 반환하고 나중에 실행을 계속할 수 있게 해주어 비동기 작업을 관리하거나, 반복자를 생성하거나, 끝없는 데이터 스트림을 처리하는 데 완벽한 방법입니다.\n\n\n\n생성기는 function* 구문으로 구분됩니다. 다음 기본 예제를 살펴보세요:\n\n```js\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n```\n\n여기서 yield는 값을 반환하고 생성기의 실행을 일시 중단합니다. 각 호출마다, 생성기는 그 다음 값을 반환합니다.\n\n# 생성기 객체와 상호 작용하기\n\n\n\n제너레이터 함수를 호출하면 해당 바디가 직접 실행되지 않습니다. 대신, 실행을 제어할 수 있는 제너레이터 객체가 생성됩니다. 이 객체는 순회 가능하므로 for...of 루프 및 유사한 작업에 적합합니다.\n\n제너레이터 객체를 살펴봅시다:\n\n- next(): 이 메소드는 제너레이터를 다시 시작하고, 다음으로 순회된 값을 반환하며, 제너레이터가 완료되었는지(done 속성으로 확인합니다.\n이전에 작성한 generateSequence 예제를 사용하여:\n\n```js\nconsole.log(generator.next()); // { value: 1, done: false }\n```\n\n\n\n- return(): 이 메서드는 generator를 일찍 종료시키며, 마치 return 명령을 실행한 것처럼 동작합니다.\n\n```js\nconsole.log(numbers.return(100)); // { value: 100, done: true }\n```\n\n- throw(): 이 메서드는 오류를 삽입할 수 있게 해주며, generator 내부에서 오류 처리를 간편하게 할 수 있습니다.\n\n```js\nfunction* generateTasks() {\n  try {\n    yield \"작업 시작\";\n    yield \"작업 진행 중\";\n    yield \"작업 거의 완료\";\n  } catch (error) {\n    console.log('문제 발생:', error.message);\n  }\n}\n\nconst tasks = generateTasks();\n\nconsole.log(tasks.next().value); // 출력: \"작업 시작\"\nconsole.log(tasks.next().value); // 출력: \"작업 진행 중\"\ntasks.throw(new Error('이런! 문제가 발생했어요.')); \n// 출력: \"문제 발생: 이런! 문제가 발생했어요.\"\nconsole.log(tasks.next()); // 출력: { value: undefined, done: true }\n```\n\n\n\n위의 예제에서는 next() 메서드를 사용하여 몇 가지 작업을 시작한 후 throw() 메서드를 사용하여 오류를 발생시킵니다. 제너레이터는 try-catch 블록 덕분에이 오류를 캡처하여 오류 메시지를 기록하고 오류 시나리오를 단호하게 처리합니다.\n\n# 무한 데이터 스트림을 위한 제너레이터 활용\n\n제너레이터는 무한 데이터 스트림을 처리하는 데 뛰어납니다. 요청 시에만 값을 생성하는 잠재적으로 끝없는 데이터 구조를 설계할 수 있습니다. 웹 애플리케이션에서의 무한 스크롤링과 같은 상황을 생각해보세요.\n\n```js\nfunction* infiniteNumbers() {\n  let index = 0;\n  while (true) {\n    yield index++;\n  }\n}\n```\n\n\n\nI confess, while(true) could scare anyone at first glance, but that is the magic of generators.\n\n# Synchronous and Asynchronous Iteration with Generators\n\nWhen blended with promises, generators can emulate the async/await pattern, offering a neater, more intuitive method to draft asynchronous code. To illustrate, let’s fetch data using a generator:\n\n```js\nfunction* fetchData() {\n  const users = yield fetch('https://api.example.com/users');\n  console.log('Users:', users);\n  // ...\n}\n```\n\n\n\n# 제너레이터의 고급 활용\n\nasync/await는 간단한 비동기 작업에 유용하지만, 다양한 기능을 제공하는 제너레이터는 더 다양한 가능성을 제공합니다.\n\n- 제너레이터 조합: 이를 통해 여러 개의 제너레이터를 매끄럽게 통합하여 복잡한 값 시퀀스를 만들 수 있습니다.\n\n```js\nfunction* generateSequence() {\n  yield* generateNumbers();\n  yield* generateCharacters('A', 'Z');\n}\n```\n\n\n\n- 무한 생성기: 생성기는 무한한 값 시퀀스를 생성할 수 있어 연속 데이터 스트림이나 무한한 알고리즘에 이상적입니다. 위의 while (true)을 기억하시나요?\n\n# 실세계 시나리오 (업데이트): 무한 스크롤\n\n![이미지](/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_1.png)\n\n자바스크립트 생성기에 대한 중요하고 실용적인 응용 프로그램을 개념화하는 것이 어려울 수 있습니다. 그러나 생성기는 비동기 코드와 매끄럽게 통합되며 무한한 반복을 지원하는 등 다양한 기능을 제공합니다. 예시를 살펴보죠.\n\n\n\n하단에 제시된 코드는 순수히 예시로 제시된 것입니다. 실제로 사용할 준비가 된 코드는 다양한 예외 상황을 처리해야 합니다.\n\n무한 스크롤을 지원하는 소셜 미디어 피드를 구성하는 것을 제안합니다. 다시 말해, 사용자가 목록의 끝까지 스크롤하면 추가적인 게시물이 가져와서 피드에 추가됩니다.\n\n두 번째 주의: 제너레이터는 한 가지 접근법을 제공하지만, JavaScript 생태계에서 단독적인 것은 아닙니다. 비슷한 결과를 얻기 위한 대체 방법이 있습니다. 그럼에도 불구하고, 학습을 위해 사용자가 스크롤할 때 게시물을 계속해서 가져오는 메커니즘을 구성해보겠습니다.\n\n먼저, 데이터를 담을 기본적인 HTML/CSS 구조를 설정해보겠습니다. 실험해보고 싶다면 사용하실 수 있습니다:\n\n\n\n```js\r\n// CSS 코드\n.post {\n  height: 300px;\n}\n\n// HTML 코드\n<div id=\"postsContainer\">\n  \n</div>\r\n```\n\n다음은 \"10개의 게시물\"을 가져오기 위해 설계된 스크립트를 검토할 것입니다. 사용자가 스크롤하고 페이지 끝에 가까워지면 생성기가 작동하여 다음 10개의 게시물을 가져올 것입니다:\n\n```js\r\n// 일반 `fetch`를 대체하기 위한 것일 뿐입니다\n// 10개의 게시물을 생성하고 반환합니다\nasync function simulatedFetch(currentPage) {\n  const posts = Array.from({ length: 10 }, (_, i) => ({ content: `포스트 - ${currentPage}${i}` }));\n  return Promise.resolve(posts)\n}\n\nasync function* paginatedFetcher(apiUrl, itemsPerPage) {\n    let currentPage = 0;\n\n    while (true) {\n        // 현실적인 경우에 대한 주석\n        // const response = await fetch(`${apiUrl}?page=${currentPage}&limit=${itemsPerPage}`);\n        const response = await simulatedFetch(currentPage)\n      \n        // const posts = await response.json();\n        const posts = response;\n      \n        if (posts.length === 0) {\n            return;  // 데이터의 끝\n        }\n      \n        yield posts;\n        currentPage++;\n    }\n}\n\n// 무한 스크롤과 함께 사용:\n// API는 설명적인 역할로 실제 사용되지는 않습니다\nconst getPosts = paginatedFetcher('https://api.example.com/posts', 10);\n\n// DOM에 게시물을 표시하는 함수\nfunction displayPosts(posts) {\n  const container = document.getElementById('postsContainer');\n    posts.forEach(post => {\n        const postElement = document.createElement('div');\n        postElement.className = 'post';\n        postElement.innerText = post.content;\n        container.appendChild(postElement);\n    });\n}\n\n// 무한 스크롤 로직\nwindow.onscroll = async function() {\n    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {\n        const { value } = await getPosts.next();\n        if (value) {\n            displayPosts(value);\n        }\n    }\n};\n\n// 초기 데이터 가져오기\n(async () => {\n    const { value } = await getPosts.next();\n    displayPosts(value);\n})();\r\n```\n\n# 결론\n\n\n\nJavaScript에서의 생성기들은 그저 새로운 것뿐만이 아니라, 비동기 작업을 다루는 데 중요하며, 반복 가능한 객체를 만드는 데도 중요합니다.\n\n다음에 데이터를 실시간으로 관리해야 할 때, 생성기를 사용하기 주저하지 마세요.\n\n실제 시나리오에서 생성기를 효과적으로 활용한 경험이 있다면 공유해 주세요. 더 많은 예시를 만나면, 어디에 활용하는 게 가장 적절한지 더 쉽게 알 수 있을 거예요.\n\n저와 소통하세요! 저는 아래에서 찾을 수 있어요:\n- Medium: https://medium.com/@yuribett\n- Linkedin: https://www.linkedin.com/in/yuribett/\n- X (formerly Twitter): https://twitter.com/yuribett\n\n\n\n# Stackademic\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 향한 박수와 팔로우를 고려해주세요! 👏\n- 트위터(X), 링크드인, YouTube에서 저희를 팔로우해 주세요.\n- 세계적으로 프로그래밍 교육을 민주화하는 Stackademic.com에서 더 많은 정보를 찾아보세요.","ogImage":{"url":"/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png"},"coverImage":"/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular 17에서 Role-Based Access Control RBAC 구현하기","description":"","date":"2024-05-14 14:19","slug":"2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17","content":"\n\n<img src=\"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png\" />\n\n앵귤러 17 애플리케이션에서 Role-Based Access Control (RBAC)을 구현하는 것에는 특정 경로 및 기능에만 인가된 사용자가 액세스할 수 있도록 여러 단계를 거쳐야 합니다. 앵귤러 17은 서비스, 가드, 지시문과 같은 Angular의 핵심 기능을 사용하여 이러한 시나리오를 처리합니다.\n\n여기에는 여러 부분으로 나뉘어진 완전한 예제가 있습니다:\n\n# 1. 앵귤러 프로젝트 설정\n\n\n\n먼저 Angular CLI가 설치되었는지 확인하세요:\n\n```js\nnpm install -g @angular/cli\n```\n\n새로운 Angular 프로젝트를 생성하세요:\n\n```js\nng new angular-rbac --routing=true --style=css\ncd angular-rbac\n``` \n\n\n\n# 2. 인증 모의 서비스\n\n사용자 로그인을 관리하고 역할을 저장하는 간단한 인증 서비스를 만들어보세요.\n\n```js\nng generate service auth\n```\n\nauth.service.ts를 편집하세요.\n\n\n\n```js\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nexport interface User {\n  username: string;\n  roles: string[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  private currentUserSubject: BehaviorSubject<User | null>;\n  public currentUser: Observable<User | null>;\n\n  constructor() {\n    this.currentUserSubject = new BehaviorSubject<User | null>(null);\n    this.currentUser = this.currentUserSubject.asObservable();\n  }\n\n  login(username: string, password: string): void {\n    // 데모용으로, 인증이 성공했다고 가정합니다.\n    const user: User = {\n      username: username,\n      roles: username === 'admin' ? ['admin', 'user'] : ['user'],\n    };\n    this.currentUserSubject.next(user);\n  }\n\n  logout(): void {\n    this.currentUserSubject.next(null);\n  }\n\n  public get currentUserValue(): User | null {\n    return this.currentUserSubject.value;\n  }\n\n  public isAuthorized(allowedRoles: string[]): boolean {\n    const user = this.currentUserValue;\n    if (!user) return false;\n    return user.roles.some(role => allowedRoles.includes(role));\n  }\n}\n```\n\n# 3. 라우트 보호를 위한 인증 가드\n\n사용자 역할에 따라 라우트를 보호하는 가드를 생성하세요.\n\n```js\nng generate guard auth\n```\n\n\n\nEdit the auth.guard.ts:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {\n    const allowedRoles = next.data['roles'] as string[];\n    if (this.authService.isAuthorized(allowedRoles)) {\n      return true;\n    }\n\n    // Redirect to the login page or some other route\n    this.router.navigate(['/login']);\n    return false;\n  }\n}\n```\n\n# 4. Setup Routes with Role Protections\n\nEdit the app-routing.module.ts to define roles required for each route:\n\n\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { AdminComponent } from './admin/admin.component';\nimport { LoginComponent } from './login/login.component';\nimport { UserComponent } from './user/user.component';\nimport { AuthGuard } from './auth.guard';\n\nconst routes: Routes = [\n  { path: 'login', component: LoginComponent },\n  { path: 'admin', component: AdminComponent, canActivate: [AuthGuard], data: { roles: ['admin'] } },\n  { path: 'user', component: UserComponent, canActivate: [AuthGuard], data: { roles: ['user', 'admin'] } }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n# 5. Create Components for Each Route\n\n```js\nng generate component login\nng generate component admin\nng generate component user\n```\n\n각 컴포넌트는 필요에 따라 기본 정보 또는 양식을 렌더링하는 간단한 구조여야 합니다.```\n\n\n\n# 6. 로그인 기능 구현하기\n\n사용자 로그인을 처리하기 위해 login.component.ts를 업데이트하세요:\n\n```js\nimport { Component } from '@angular/core';\nimport { AuthService } from '../auth.service';\n\n@Component({\n  selector: 'app-login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {\n  username: string = '';\n  password: string = '';\n\n  constructor(private authService: AuthService) { }\n\n  login(): void {\n    this.authService.login(this.username, this.password);\n  }\n}\n```\n\n# 7. 어플리케이션 테스트하기\n\n\n\nAngular 개발 서버를 실행해주세요:\n\n```js\nng serve\n```\n\nhttp://localhost:4200 으로 이동하여 다른 사용자로 로그인하여 다양한 경로를 테스트해보세요.\n\n이 설정은 Angular 17 애플리케이션에서 역할 기반 액세스를 위한 기본적인 프레임워크를 제공합니다. 실제 백엔드 통합, 토큰 기반 인증 처리, 그리고 더 정교한 사용자 관리 기능을 추가함으로써 더 확장시킬 수 있습니다.\n\n\n\n감사합니다\n\n찬단","ogImage":{"url":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png","tag":["Tech"],"readingTime":5},{"title":"JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기","description":"","date":"2024-05-14 14:17","slug":"2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend","content":"\n\n<img src=\"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png\" />\n\n우리 스타트업은 아이들이 화면에서 색칠된 템플릿을 생동감있게 만들 수 있게 해줘. 종이에 색칠된 템플릿을 업로드하여 디지털 세계를 구축하는 것만으로도 흥미로운 경험이지만, 우리는 아이들에게 추가로 동물에 대한 목소리를 녹음할 기회를 주고 싶었어.\n\n<img src=\"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_1.png\" />\n\n## 문제\n\n\n\n작업한 것을 기록합니다. 음성 녹음을 위한 MediaRecorder API 부분은 간단했지만, 업로드한 오디오 파일이 재생되지 않거나 손상된 것으로 보였습니다. 이는 브라우저가 mp3 또는 wav로 오디오를 기록하지 않고 webm으로 기록하기 때문입니다 (적어도 Chrome에서).\n\n우리가 할 일:\n\n- wav로 오디오 녹음\n- wav를 mp3로 변환\n- 오디오 파일을 서버에 업로드\n- 로컬 디스크 또는 S3에 파일 저장\n\n# 오디오 변환을 wav로 변경\n\n\n\n최종적으로 녹음을 mp3 파일로 변환하려면 먼저 wav 형식으로 변환해야 했습니다. 이를 위해 기본 MediaRecorder의 대체물인 확장 가능한 drop-in MediaRecorder인 chrisguttandin/extendable-media-recorder 라이브러리를 사용했습니다.\n\n다음과 같이 설치하세요:\n\n```js\nnpm install extendable-media-recorder\n```\n\n# 오디오 녹음\n\n\n\ngetUserMedia를 사용하여 오디오를 녹음하는 방법에 대한 많은 안내서가 있어요. 저는 간단하게 유효한 mp3 또는 wav 오디오 파일을 만드는 핵심 부분을 다룰 거에요.\n\n```js\nimport {MediaRecorder, register} from 'extendable-media-recorder';\nimport {connect} from 'extendable-media-recorder-wav-encoder';\n\nlet mediaRecorder = null;\nlet audioBlobs = [];\nlet capturedStream = null;\n\n// extendable-media-recorder-wav-encoder를 등록합니다.\nasync function connect() {\n  await register(await connect());\n}\n\n// 오디오 녹음을 시작합니다.\nfunction startRecording() {\n\n  return navigator.mediaDevices.getUserMedia({\n    audio: {\n      echoCancellation: true,\n    }\n  }).then(stream => {\n      audioBlobs = [];\n      capturedStream = stream;\n\n      // 확장된 MediaRecorder 라이브러리를 사용합니다.\n      mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/wav'\n      });\n\n      // 녹음 중 오디오 블롭을 추가합니다.\n      mediaRecorder.addEventListener('dataavailable', event => {\n        audioBlobs.push(event.data);\n      });\n\n      mediaRecorder.start();\n  }).catch((e) => {\n    console.error(e);\n  });\n\n}\n```\n\n그리고 녹음을 중지하는 함수:\n\n```js\nfunction stopRecording() {\n  return new Promise(resolve => {\n    if (!mediaRecorder) {\n      resolve(null);\n      return;\n    }\n\n    mediaRecorder.addEventListener('stop', () => {\n      const mimeType = mediaRecorder.mimeType;\n      const audioBlob = new Blob(audioBlobs, { type: mimeType });\n\n      if (capturedStream) {\n        capturedStream.getTracks().forEach(track => track.stop());\n      }\n\n      resolve(audioBlob);\n    });\n    \n    mediaRecorder.stop();\n    \n  });\n}\n```\n\n\n\n브라우저에서 오디오를 재생하고 싶다면 다음과 같이 할 수 있어요:\n\n```js\n playAudio(audioBlob) {\n  if (audioBlob) {\n    const audio = new Audio();\n    audio.src = URL.createObjectURL(audioBlob);\n    audio.play();\n  }\n}\n```\n\n# Wav를 mp3로 변환\n\nWav를 mp3로 변환하기 위해 lamejs 라이브러리를 사용했어요:\n\n\n\n설치\n\n```js\nnpm install @breezystack/lamejs\n```\n\n이제 `convertWavToMp3` 함수를 만들고 녹음된 오디오Blob을 전달하여 mp3 Blob을 얻을 수 있습니다.\n\n```js\nimport * as lamejs from '@breezystack/lamejs';\n\nconvertWavToMp3(wavBlob) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = function () {\n      const arrayBuffer = this.result;\n\n      // WAV 디코더 생성\n      // @ts-expect-error - 무슨 일인지 모르겠어요\n      const wavDecoder = lamejs.WavHeader.readHeader(new DataView(arrayBuffer));\n\n      // WAV 오디오 데이터를 샘플 배열로 가져옴\n      const wavSamples = new Int16Array(arrayBuffer as ArrayBuffer, wavDecoder.dataOffset, wavDecoder.dataLen / 2);\n\n      // MP3 인코더 생성\n      const mp3Encoder = new lamejs.Mp3Encoder(wavDecoder.channels, wavDecoder.sampleRate, 128);\n\n      // WAV 샘플을 MP3로 인코딩\n      const mp3Buffer = mp3Encoder.encodeBuffer(wavSamples);\n\n      // MP3 인코딩 완료\n      const mp3Data = mp3Encoder.flush();\n\n      // MP3 헤더와 데이터를 새로운 ArrayBuffer로 결합\n      const mp3BufferWithHeader = new Uint8Array(mp3Buffer.length + mp3Data.length);\n      mp3BufferWithHeader.set(mp3Buffer, 0);\n      mp3BufferWithHeader.set(mp3Data, mp3Buffer.length);\n\n      // ArrayBuffer에서 Blob 생성\n      const mp3Blob = new Blob([mp3BufferWithHeader], { type: 'audio/mp3' });\n\n      resolve(mp3Blob);\n    };\n\n    reader.onerror = function (error) {\n      reject(error);\n    };\n\n    // 입력 Blob을 ArrayBuffer로 읽기\n    reader.readAsArrayBuffer(wavBlob);\n  });\n}\n```\n\n\n\n# 파일 업로드\n\n파일 업로드는 상당히 쉬운 부분이며 코드를 통해 자세하게 설명할 수 있어서 매우 쉽게 이해할 수 있을 겁니다:\n\n```js\n/**\n * 오디오 blob을 서버에 업로드합니다\n * @params {Blob} audioBlob - 오디오 blob 데이터\n * @params {string} fileType - 'mp3' 또는 'wav'\n * @return {Promise<object>}\n */\nfunction uploadBlob(audioBlob, fileType) {\n  const formData = new FormData();\n  formData.append('audio_data', audioBlob, 'file');\n  formData.append('type', fileType || 'mp3');\n\n  // 오디오를 업로드하기 위한 서버 엔드포인트:\n  const apiUrl = \"http://localhost:3000/upload/audio\";\n\n  const response = await fetch(apiUrl, {\n    method: 'POST',\n    cache: 'no-cache',\n    body: formData\n  });\n\n  return response.json();\n}\n```\n\n# 전부 함께\n\n\n\n위의 모든 함수를 함께 사용하는 빠른 예제:\n\n```js\n// 초기화\nawait connect();\n\n// 사용자가 녹음 버튼을 클릭함\nstartRecording();\n\n// 사용자가 정지 버튼을 클릭하거나 정의된 시간 초과\nconst wavAudioBlob = await stopRecording();\n\n// 재미로: 재생\nplayAudio(wavAudioBlob);\n\n// mp3로 변환\n// 참고: mp3는 Chrome 및 Firefox에서만 작동했습니다\n// Safari는 이에 대한 호감을 잃어 보였으므로 Safari에는 .wav를 업로드했습니다\nconst mp3Blob = await convertWavToMp3(wavAudioBlob);\n\n// 서버에 블랍 업로드\nconst response = await uploadBlob(mp3Blob, 'mp3');\n```\n\ntry/catch를 사용하고 일부 변수가 null인지 확인하는 것이 좋습니다.\n\n# 파일 저장 — Flask\n\n\n\n오디오 파일을 엔드포인트에 POST한 후에는 저장을 원할 것입니다. Python Flask에서 파일을 로컬로 저장하거나 S3 버킷에 저장하는 방법을 보여드릴게요. 다른 언어(NodeJS, PHP 등)에서도 비슷하게 적용할 수 있어요.\n\n```js\ndef uploadAudio(request):\n\n  # 파라미터 가져오기\n  audio_file = request.files.get('audio_data')\n  file_type = request.form.get(\"type\", \"mp3\")\n  \n  # 파일명에 UUID 생성하는 것을 고려할 수 있어요\n  filename = \"myAudioFile.\" + file_type\n  \n  # 로컬 디스크에 저장하기\n  target_path = (\"your/local/dir/%s\" % filename)\n  audio_file.save(target_path)\n\n  # 또는: AWS S3에 파일 저장하기\n  session = boto3.Session(\"\"\" API 인증 정보 \"\"\")\n  s3 = session.resource('s3')\n  bucket = s3.Bucket(\"your-bucket-name\")\n  destination_dir = \"audiofiles/\"\n  response = bucket.upload_fileobj(audio_file, destination_dir, ExtraArgs={\n    \"ContentType\": \"audio/\" + file_type\n  })\n```\n\n버그를 발견하거나 개선 제안이 있다면 댓글로 알려주세요!","ogImage":{"url":"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png"},"coverImage":"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png","tag":["Tech"],"readingTime":6},{"title":"더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들","description":"","date":"2024-05-14 14:16","slug":"2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity","content":"\n\n![Chrome DevTools JavaScript Debugging Features for Better Productivity](/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png)\n\n소프트웨어 버그는 소프트웨어 프로그램에서 예상치 못한 또는 잘못된 동작을 가리킵니다. 다른 소프트웨어 유형과 마찬가지로 웹 앱에도 버그가 포함될 수 있습니다. 웹 앱의 버그는 해당 웹 앱의 품질을 버그 심각도에 따라 저하시킬 수 있습니다. 몇 가지 심각한 소프트웨어 버그는 전체 웹 앱을 영향을 미치며 사용자 인터랙션 흐름을 망가뜨릴 수 있습니다. 한편 일부 미세한 소프트웨어 버그는 사용자 흐름의 일부를 영향을 미치며 대안 흐름으로 교체 가능할 수 있습니다. 잘 알려진 디버깅 프로세스는 웹 개발자가 웹 앱에서 버그를 제거하여 품질을 회복하는 데 도움을 줍니다.\n\n현대 웹 브라우저는 기능이 풍부한 웹 개발 환경으로서, JavaScript 소스 코드에서 버그를 감지하기 위한 디버깅 기능을 제공합니다. 예를 들어, Google Chrome은 제품적인 JavaScript 디버깅을 위해 DevTools 패널을 제공합니다. DevTools은 표준 중단점을 기반으로 한 동적 코드 분석 및 변수 감시, 스택 프레임 분석기, 리스너 검사자 등과 같은 고급 디버깅 기능을 제공합니다. DevTools는 브라우저에서 로드된 베니라 JavaScript를 디버그할 수 있을 뿐만 아니라 Chrome DevTools 프로토콜을 통해 TypeScript, Node.js, Deno 및 React Native 앱을 디버그할 수 있도록 지원합니다. 게다가 대부분의 프론트엔드 프레임워크/라이브러리는 디버깅 경험을 향상하기 위한 DevTools 확장을 제공합니다(예: React Developer Tools).\n\n생산성 중심의 Chrome DevTools 기능을 파악하면 JavaScript 소스 코드를 빠르게 디버그할 수 있고 버그 수정을 생산적으로 진행할 수 있습니다. 이 글에서는 JavaScript 디버깅 생산성을 높일 수 있는 DevTools 기능에 대해 설명하겠습니다. 이러한 DevTools 기능을 연습하고 디버깅 방법을 찾는 대신 디버깅에만 집중하세요!\n\n\n\n# 변수와 표현식 감시하기\n\n디버거 브레이크포인트가 코드 실행을 중단할 때마다, 마우스를 가져다 대면 JavaScript 변수를 살펴볼 수 있습니다. 이 기술을 사용하여 디버깅 중에 원자값과 객체를 살펴볼 수 있지만, 한꺼번에 여러 변수를 감시해야 한다면 시간이 많이 소요될 수 있습니다. 디버깅 중 감시해야 하는 변수와 표현식을 평가해야 한다면 더 어려워질 수 있습니다. 이런 경우에는 디버거 코드 뷰와 콘솔을 자주 왔다갔다해야 합니다.\n\nDevTools에서는 브레이크포인트를 기반으로 변수와 표현식을 감시하거나 브레이크포인트에서 멈추지 않고 수동으로 업데이트할 수 있습니다. 다음 코드 조각을 살펴보세요:\n\n```js\nlet m = 0;\nlet s = 0;\n\nsetInterval(() => {\n  s++;\n  if(s === 60) {\n    m++;\n    s = 0;\n  }\n}, 1000);\n```\n\n\n\n위 코드는 두 변수를 사용해 간단한 초-분 타이머를 구현한 것입니다. 다음과 같이 새로운 감시자를 추가하고 중단점을 설정하여 m 및 s 변수를 확인할 수 있습니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*T23NrZm73SydEAZjai8NVQ.gif)\n\n매 초마다 실행을 멈추는 중단점이 있기 때문에 중단점을 제거하고 대신 새로고침 버튼을 누를 수 있습니다. 또한 감시자 레코드로 표현식을 평가할 수도 있습니다. 예를 들어 다음 샘플 표현식이 선행 0이 있는 타이머 값을 출력하는 방법을 확인해보세요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*4f9JCOR17w3M4-Tp82Q92w.gif)\n\n\n\n# 콘솔에서 디버거 컨텍스트 사용하기\n\n우리는 객체 속성을 검사하기 위해 마우스를 호버하고 관찰자를 설정하는 방식으로 사용할 수 있습니다. 그러나 어떤 상황에서는 콘솔에서 자동 완성을 지원하는 상태에서 객체 메서드를 트리거하고 객체 속성을 검사해야 할 때가 있습니다. 개발 도구는 이 요구 사항을 해결하기 위해 콘솔의 범위를 현재 중단점으로 변경합니다. d 객체의 getMilliseconds() 메서드의 반환 값을 확인해야 한다고 가정해 봅시다:\n\n```js\nfunction getMagicDate(d) {\n  if(d.getDate() % 2 === 0) {\n    d.setDate(d.getDate() + 2);\n  }\n  else {\n    d.setMonth(d.getMonth() + 1);\n  }\n  return d;\n}\n\ngetMagicDate(new Date());\n```\n\n먼저 중단점을 설정하고 코드 실행 프로세스를 중단해야 합니다. 그런 다음, 콘솔 서랍을 열기 위해 escape 키를 누르고 실행할 메서드를 입력하세요:\n\n\n\n![Live Expressions](https://miro.medium.com/v2/resize:fit:1400/1*yErxg7PWPkt1nBHar2Z3Mw.gif)\n\n# 중단점 없이 실시간 표현식 만들기\n\n첫 번째 예제에서는 위쳐(watchers)를 사용하여 샘플 프로그램의 몇 가지 변수를 조사했습니다. 표현식의 업데이트된 결과를 보려면 중단점에 멈춰야했거나 새로 고침 버튼을 눌러야 했습니다. DevTools를 사용하면 콘솔에서 실시간 표현식을 만들 수 있으므로 중단점을 사용하지 않고도 원하는 표현식의 업데이트된 결과를 볼 수 있습니다.\n\n이 시나리오에 대해 이전에 사용한 코드를 사용하겠습니다:\n\n\n\n```js\nlet m = 0;\nlet s = 0;\n\nsetInterval(() => {\n  s++;\n  if (s === 60) {\n    m++;\n    s = 0;\n  }\n\n  console.log(`${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`);\n}, 1000);\n```\n\n\n\n# 마지막 콘솔 결과 및 선택된 요소에 액세스하는 방법\n\n자동화를 위해 Bash 스크립팅을 사용하는 경우, 마지막 완료된 프로세스의 종료 코드를 가져오는 방법을 알고 있을 것입니다. $? 특수 Bash 매개변수가 도움이 됩니다. DevTools도 자동화 스크립팅에 존재하는 유사한 기능을 제공하여 디버깅 생산성을 향상시키려고 노력합니다. 콘솔에서 여러 식을 평가할 때, 사전 정의된 $_ 유틸리티 변수를 사용하여 마지막 표현식의 결과를 얻을 수 있습니다. 이는 디버깅 중에 테스트 데이터를 작성할 때 매우 유용합니다. 다음 예제를 살펴보세요:\n\n![예제](https://miro.medium.com/v2/resize:fit:1400/1*emqAYbt1vrKkcYS8aWP0Yw.gif)\n\n위 예에서는 $_ 유틸리티 변수를 사용하여 이전에 생성된 JavaScript 객체에 액세스합니다.\n\n\n\n우리는 모두 포커스가 있는 요소를 반환하는 document.activeElement 속성에 대해 알고 있습니다. 그렇다면 DevTools Inspector에서 선택한 DOM 요소에 대한 참조를 얻어야 한다면 어떻게 할까요? $0 유틸리티 변수가 도와줍니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*rGXZoHl7e_qNtS9dCIG8Nw.gif\" />\n\n공식 Chrome 콘솔 유틸리티 참조를 읽고 JavaScript 디버깅 중에 콘솔에서 사용할 수 있는 더 많은 단축 변수와 함수에 대해 알아보세요.\n\n다음 이야기는 여러분에게 JavaScript의 최신 단축 구문에 대해 가르쳐줍니다:\n\n\n\n# 이벤트 리스너 브레이크포인트 설정하기\n\n풀리피처가 갖춰진 개발 환경인 웹 브라우저는 다양한 이벤트를 제공하여 개발자들이 고품질이고 사용자 친화적인 웹 앱을 개발할 수 있도록 도와줍니다. 각 브라우저 API는 일반적으로 개발자들을 위한 이벤트 기반 상호작용 모델을 제공하며, 그에 따라 개발자들은 JavaScript 코드베이스에서 이벤트 리스너 콜백을 붙이곤 합니다. 디버깅을 위해 이벤트 리스너에 대한 브레이크포인트를 설정하려면 알려진 쉽고 간단한 방법이 있습니다.\n\n다음 코드를 살펴보세요:\n\n```js\nlet btn = document.getElementById('btn');\nlet count = 0;\n\nbtn.addEventListener('click', (e) => {\n  btn.innerText = `Clicked ${++count} times`;\n});\n```\n\n\n\n우리는 쉽게 이벤트 리스너를 중단점으로 설정할 수 있습니다. 왜냐하면 어디에 작성되어 있는지 알기 때문이죠. 그런데 만약 많은 이벤트 리스너가 있는 낯선한 코드베이스를 디버깅해야 한다면 어떨까요? DevTools는 이벤트 이름을 기반으로 중단점을 설정할 수 있는 방법을 제공합니다. 다음 예시를 살펴보세요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*jWE3Q8yaZtfjoU-OsZK3EQ.gif)\n\n위의 클릭 리스너 중단점은 코드 실행을 중지하고 자동으로 리스너 콜백으로 이동합니다. 비슷하게, XHR, worker, clipboard, keyboard 등의 이벤트에 대한 중단점을 설정하고 이벤트 리스너 등록을 찾을 수 있습니다.\n\n다음 이야기에서는 모든 현대 웹 개발자가 알아야 할 새로운 브라우저 이벤트 및 API에 대해 설명합니다:\n\n\n\n# 네트워크 요청 중단점 사용하기\n\nXHR 이벤트 중단점을 사용하여 네트워크 요청을 감지할 수 있습니다. 이를 통해 네트워크 관련 JavaScript 코드에 수동으로 중단점을 설정할 필요 없이 코드 실행이 모든 XHR 이벤트에서 중단되는 것이 아니라 특정 네트워크 요청에만 관심이 있는 경우에도 이를 감지할 수 있습니다. 개발자 도구는 URL 필터를 기반으로 네트워크 요청을 감지하는 소스 탭에 다른 섹션을 제공합니다. 예를 들어, 앱이 https://api.example.com URL에 대한 요청을 보내는 소스 코드 라인을 찾아야 한다고 가정해봅시다. 다음과 같이 XHR/fetch 중단점을 설정할 수 있습니다:\n\n![네트워크 요청 중단점](https://miro.medium.com/v2/resize:fit:1400/1*vg4xUAWXbRv7vJrAYQWq1w.gif)\n\n이 접근법을 사용하면 특정 네트워크 요청이 어디서 트리거되었는지, 코드를 검사하거나 네트워크 탭에서 시간을 소비하지 않고 파악할 수 있습니다. 위 미리보기에서처럼, 개발자 도구는 네트워크 요청을 전송한 코드 세그먼트를 자동으로 표시하므로 필요한 경우 새로운 중단점을 설정하고 결과를 추가 검사할 수 있습니다.\n\n\n\n# 호출 스택 검사\n\n개발자들은 종종 전체 소스 코드를 여러 JavaScript 함수로 분해하여 코드의 가독성과 품질을 향상시킵니다. 또한 이러한 함수들을 여러 모듈로 정리하여 관리 가능성을 더욱 향상시킵니다. 따라서 특정 웹 앱에서 사용자가 작업을 호출할 때마다 JavaScript 엔진의 호출 스택에서 여러 JavaScript 함수가 실행됩니다. 이러한 스택 프레임은 입력 매개변수와 비공개 변수를 포함하는 함수 스코프를 보유합니다. 재귀 알고리즘 디버깅 및 함수 호출 스택 분석을 위해 스택 프레임을 검사하는 것이 중요합니다.\n\n스택 프레임 분석기를 사용하는 것은 매우 쉬운데 - debugger 키워드를 사용하고 호출 스택 세그먼트를 열고 각 스택 프레임의 스코프를 검사할 수 있습니다. 아래 미리보기에서 보여지는 것과 같습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*8OX_qVhdz4UtapF2jUzV8A.gif)\n\n\n\n호출 스택은 이론적인 스택 데이터 구조를 사용합니다. 모든 일반적인 데이터 구조를 알면 프로그래밍 기술이 향상되며, 다음 이야기에서 설명했습니다:\n\n읽어주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png"},"coverImage":"/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png","tag":["Tech"],"readingTime":6},{"title":"시작하기 JavaScript LLM 앱용 LangSmith","description":"","date":"2024-05-14 14:14","slug":"2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps","content":"\n\n대용량 언어 모델(Large Language Models, LLM)의 파워를 LangSmith와 함께 발휘하세요: 시작부터 끝까지 AI 개발을 최적화해보세요!\n\n대용량 언어 모델(LLM) 위에 챗봇을 구축하고 있다고 상상해보세요. 감정 분석, RAG 검색 또는 문맥 이해와 같은 복잡한 기능을 통합할 때 예기치 않은 오류에 직면합니다. 이러한 문제를 해결하더라도 새로운 도전이 나타나고 앱에 작은 변경 사항이나 LLM의 업데이트로 인해 발생할 수 있습니다. LLM과 작업하면 마법 상자에 연결된 것처럼 느껴지기도 합니다. 때로는 결과가 놀라울 정도로 훌륭하고 때로는 그렇지 않을 수도 있습니다. 그들이 왜 그렇게 행동하는지, 그것이 앱에 어떤 영향을 미치는지 알기 어려울 때가 있습니다.\n\nLangSmith는 개발부터 모니터링까지 LLM 애플리케이션의 전체 라이프사이클을 최적화하는 포괄적인 데브옵스 플랫폼으로 이 문제를 해결합니다. 이 통합은 개발을 단순화하는 것뿐만 아니라 개발자들 사이의 신뢰를 높이고 품질을 보장하며 비용을 관리하고 지연 시간을 줄여, LLM 애플리케이션 개발을 더욱 접근 가능하고 효율적으로 만듭니다.\n\n본 문서에서는 LangSmith가 무엇인지, 왜 사용해야 하는지, 어떻게 사용해야 하는지, 그리고 런 트레이스 기능의 빠른 데모를 진행하겠습니다.\n\n\n\nLangSmith을 사용해야 하는 이유는 무엇일까요?\n\n- 포괄적인 개발 도구: LangSmith는 LLM 애플리케이션을 위한 맞춤형 개발 도구를 제공하여 상세한 호출 순서 가시성, 실시간 디버깅, 및 성능 최적화 기능을 제공합니다.\n- 고급 테스팅 및 평가: 이 플랫폼은 강력한 테스트 프레임워크와 AI 지원 평가를 제공하여 응답의 품질을 보장하며, 관련성, 정확성, 민감성을 포괄합니다.\n- 배포 및 확장성: LangSmith는 리소스 집약적인 LLM 애플리케이션의 배포와 확장을 간소화하여 성능 저하 없이 증가된 부하를 관리합니다.\n- 실시간 모니터링 및 분석: 종합적인 모니터링은 비용, 지연 시간, 품질을 추적하며, 실시간 분석을 통해 신속한 결정을 내릴 수 있도록 지원합니다.\n- 비용 관리: LangSmith는 LLM 프로젝트의 재정 측면을 관리하는 데 도움을 줌으로써 지출을 최적화하고 애플리케이션 효율성을 극대화하는 통찰을 제공합니다.\n- 협업 기능: 이 플랫폼은 공유 작업 공간, 버전 관리, 그리고 커뮤니케이션 도구로 팀워크를 강화하여, 지역 간 원활한 협업을 지원합니다.\n\n# 주요 기능\n\nLangSmith에는 많은 기능이 있으며 새로운 기능을 지속적으로 추가합니다. 여기 몇 가지 주요 기능을 살펴보세요:\n\n\n\n## 실행 추적\n\n추적은 LLM 애플리케이션의 동작을 이해하는 데 도움이 되는 강력한 도구입니다. 추적을 사용하면 예기치 않은 결과나 에이전트가 루프를 도는 이유, 실행이 느린 이유, 비용이 얼마나 드는지, 또는 고객이 최적의 응답을 받지 못하는 이유 등의 문제를 진단할 수 있습니다.\n\n## 주석이 달린 큐\n\n주석이 달린 큐는 데이터를 빠르게 순환하고 주석을 달 수 있는 사용자 친화적인 방법입니다. 사람들이나 LLM이 결과를 평가할 수 있는 워크플로우를 만들 수 있습니다. 이 데이터는 애플리케이션의 테스트 및 개선에 사용될 수 있습니다.\n\n\n\n## 데이터셋 및 테스트\n\n데이터셋은 업로드할 수도 있고 실제 실행에서 파생될 수도 있습니다. 그런 다음 이 데이터를 사용하여 응용 프로그램의 성능과 정확도를 측정하는 평가자를 사용하여 테스트를 실행할 수 있습니다.\n\n## 허브\n\n허브를 사용하면 LLM 프롬프트용 GitHub과 같은 협업, 테스트 및 공유가 가능합니다. 프롬프트를 효과적으로 작성하는 방법을 확인하는 데 도움되는 것뿐만 아니라 프롬프트를 관리하는 훌륭한 방법이기도 합니다.\n\n\n\n이 기사에서는 실시간 디버깅에 대해 자세히 살펴보겠습니다.\n\n# LangChain과 프로젝트 통합\n\nLangChain.js를 사용하여 간단한 앱을 만들었는데, 이는 LangSmith와의 통합 설정에 좋은 시작점을 제공할 것입니다.\n\n- 저장소 복제: git clone git@github.com:kenzic/simple-langsmith-demo.git\n- 의존성 설치: yarn\n- LangSmith 계정 등록\n- API 키 받기\n- OpenAI API 키 받기\n- .env.example을 .env로 이동하고 다음 값을 채워 넣으세요:\n\n\n\n```js\nLANGCHAIN_PROJECT=\"langsmith-demo\"\nLANGCHAIN_TRACING_V2=true\nLANGCHAIN_API_KEY=<your-api-key>\n\n# OpenAI API를 사용하여 LLM에 호출을 하지만, LangSmith를 사용하는 데 필수적이지는 않습니다\nOPENAI_API_KEY=<your-openai-api-key>\r\n```\n\n시작하기 전에 코드를 이해하는 데 1 ~ 2분 정도 소요되도록 사전에 시간을 투자해보세요. 이 코드는 높은 수준에서 다음과 같은 작업을 수행합니다:\n\n- 입력값 \"프랑스의 수도는 무엇인가요?\"로 앱을 호출합니다.\n- 대화 검색 체인 (RunnableSequence):\n  - 문서 검색 체인을 호출하여 컨텍스트를 추가합니다. 이는 사용자의 질문에 답변하기 위해 데이터를 가져오는 사용자 지정 검색기를 사용합니다 (RunnableMap).\n  - 문서 검색 체인에서 가져온 컨텍스트를 사용하여 사용자 질문에 대한 LLM 답변을 Mr. Burns의 억양으로 작성하는 프롬프트를 생성합니다 (ChatPromptTemplate).\n  - LLM을 호출합니다 (ChatOpenAI).\n  - 응답을 구문 분석하여 문자열로 반환합니다 (StrOutputParser).\n\n# 실습하기```\n\n\n\n이 기사에서는 아마도 가장 강력한 기능인 실행 추적 및 디버깅 기능에 초점을 맞출 것입니다.\n\n이제 우리 앱을 테스트하고 디버깅할 준비가 되었어요!\n\n다음을 실행하여 시작하십시오: yarn start\n\n스크립트는 앱에 \"프랑스의 수도는 어디인가요?\"라고 묻습니다.\n\n\n\n우리가 받은 결과가 상당히 예상치 못한 것 같아요. 프랑스의 수도가 스프링필드라고 생각하고 있는 것 같아요. 이상하죠.\n\n우리 중 일부는 프랑스의 수도가 스프링필드가 아니라 파리임을 알고 있죠. 그래서 왜 이런 결과를 받는 걸까요? 게다가 앱이 답변을 제대로 주기까지 오래 걸리는 것 같아요. 이 부분을 빨리 처리할 수는 없을까요?\n\nhttps://smith.langchain.com/ 로 이동해서 \"langsmith-demo\" 프로젝트를 클릭해주세요. 프로젝트 내부에 들어가면 실행 기록을 볼 수 있어요. 최근 실행부터 시작해서 무슨 일이 일어나고 있는지 힌트가 있는지 확인해보겠어요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png)\n\n\n\n최상위 수준의 추적 결과 (RunnableSequence)를 살펴보면, 앱이 실행되는 데 3.33초가 걸리고 입력과 출력이 일치함을 볼 수 있지만 출력물은 명백히 잘못되었습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_1.png)\n\n다음 수준인 (RunnableMap)로 이동하면, 앱의 일부분이 LLM이 답변을 안내하는 데 사용할 문맥이나 지식을 검색하는 역할을 살펴볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_2.png)\n\n\n\n여기에서 무슨 일이 일어나고 있는지 빠르게 파악할 수 있어요. 저희 리트리버가 사실과 다른 정보를 제공하고 있네요. 이 데모에서는 \"프랑스의 수도는 파리입니다\"라는 내용으로 문서 내용을 바꿔서 수정할 수 있어요.\n\n쉬웠죠! 하지만 아직 앱이 조금 느린 것 같아요. 왜 그럴까요? 계속 추적해보면 ChatPromptTemplate은 잘 보이고 실행 시간은 0.00초가 걸리므로, 그 부분은 아닌 것 같아요.\n\n![image](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_3.png)\n\n다음으로, ChatOpenAI 단계는 조금 느린데, 인터넷을 통해 요청을 보내고 있기 때문에 예상대로 그럴 수 있어요. 또한 OpenAI에 대한 호출이 총 139개의 토큰을 사용하여 총 $0.0001165를 소비했다는 점을 알려드릴게요. 앱이 더 복잡해지면 이 비용을 이해하기 위해 이 숫자에 주의해야 할 거예요.\n\n\n\n<img src=\"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_4.png\" />\n\n마침내 StrOutputParser로 이동합니다. 실행 시간이 0.00초이고 출력을 올바르게 구문 분석했으므로 여기서 모든 것이 정상인 것 같습니다.\n\n<img src=\"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_5.png\" />\n\n그래서 앱에서 병목 현상이 어디에 있는지 궁금하신가요? RunnableMap으로 돌아가 봅시다. 이 부분이 2.01초가 걸리는 것을 볼 수 있습니다. 한 개의 하드코딩된 문서를 반환하는 간단한 작업에 대해 이 시간은 높아 보입니다. 코드를 살펴보면 기능 slowLookupTask이 있음을 알 수 있습니다. 이 기능은 데모를 위해 인위적으로 만들어졌지만, 실제 시나리오에서는 검색기가 응용 프로그램의 지연 원인이 될 수 있으며, 종종 제어할 수 있는 부분 중 하나입니다.\n\n\n\n마침내 스크립트를 다시 실행합시다. 어떻게나! 이제 쿼리에 올바른 답변을 받아, 2초를 절약했습니다!\n\n## 다음 단계\n\nLangSmith의 능력의 일부에 불과하지만, 이 짧은 글이 어떤 가능성을 밝혀주기를 바랍니다.\n\nLangSmith의 디버깅 기능을 활용하여 더욱 탐험하면, 그 가능성을 최대로 발휘할 수 있습니다:\n\n\n\n- 고급 테스트 및 평가 도구를 활용하여 응답 품질을 지속적으로 확인합니다.\n- 비용 관리 통찰력을 활용하여 리소스 사용량 및 비용을 최적화합니다.\n- 공동 작업 공간, 버전 관리 및 빠른 라이브러리를 활용하여 협업을 촉진합니다.\n- 감정 분석 및 맥락 이해와 같은 고급 기능을 통합합니다.\n- LangSmith의 미래를 형성하기 위해 새로운 릴리스에 주목하고 LangSmith 커뮤니티에 참여하세요.\n\nLLM 애플리케이션은 발전함에 따라 LangSmith가 개발을 간소화하고 성능을 보장하며 AI 혁신을 이끌어내는 도구를 제공합니다.\n\n# 마무리\n\nLangSmith 소개를 마치고 대형 언어 모델 애플리케이션 개발 마스터에 한 발짝 다가가셨습니다. 이 안내서에서는 고대형 언어 모델 프로젝트의 개발 및 유지 관리를 간소화하기 위해 LangSmith와 LangChain을 설정하고 사용하는 방법을 개요로 설명했습니다.\n\n\n\n다룬 내용을 간단히 요약해 드리겠습니다:\n\n- 프로젝트를 LangChain과 LangSmith와 통합 설정하는 방법.\n- 애플리케이션을 이해하고 최적화하기 위해 실시간 디버깅 및 실행 추적을 활용하는 방법.\n\nLangSmith로 수행할 수 있는 많은 작업이 있습니다. 이에 관한 내용은 나중에 다룰 것이지만, 오늘 LangSmith를 사용하고 있지 않다면 기술 스택에 추가할 가치가 있다는 것을 확신시켜 드릴 수 있기를 바랍니다.\n\n연결 유지하고 여정을 공유하기 위해 아래 채널을 통해 언제든지 연락해 주세요:\n\n\n\n- 👨‍💼 LinkedIn: LLM 개발 및 기술 혁신에 대한 자세한 통찰력을 얻으려면 저와 함께하세요.\n- 💻 GitHub: 제 프로젝트를 살펴보고 지속적인 작업에 기여하세요.\n- 📚 Medium: LangSmith, LangChain 및 기타 AI 기술에 대한 보다 심층적인 토론을 위해 제 기사를 팔로우하세요.\n\n귀하의 피드백 및 협업은 귀중합니다. 행복한 개발하고 LangSmith로 만드는 놀라운 응용 프로그램을 기대하겠습니다!","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png","tag":["Tech"],"readingTime":6},{"title":"새로운 Angular 17 기능 새로운 제어 흐름 구문","description":"","date":"2024-05-14 14:12","slug":"2024-05-14-NewAngular17featurenewcontrolflowsyntax","content":"\n\n# Angular의 새로운 선언적 제어 흐름을 시그널 기반 예시로 설명합니다\n\n![이미지](/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png)\n\nAngular 17은 11월 초에 출시될 예정이며, 선언적 제어 흐름을 갖는 새로운 템플릿 제어 블록 구문을 제공할 것입니다. 이 새로운 블록을 사용하는 두 가지 그룹의 특징이 있습니다:\n\n- 지연 로딩 블록: Angular 17은 블록 내용의 지연 로딩을 가능케 하는 @defer 제어 블록을 가집니다. 블록 내용의 종속 항목에도 지연 로딩이 적용됩니다: 모든 컴포넌트, 지시문 및 파이프도 지연 로딩이 될 것입니다. 이전 기사에서 defer 블록이 어떻게 작동하는지 예시로 보여드렸습니다.\n- 조건부 렌더링과 컬렉션 항목 렌더링을 제공하는 블록 (RFC): 이는 NgIf, NgFor 및 NgSwitch 지시문에 대한 대안입니다.\n\n\n\n이러한 새 제어 블록의 가장 중요한 이점 중 하나는 시그널을 통해 영역이 없는 애플리케이션을 지원한다는 것입니다.\n\n이 기사에서는 다음을 보여줍니다:\n\n- 새 제어 블록 구문을 사용하여 @if와 @else를 사용하여 조건에 따라 렌더링되는 블록 만들기\n- @switch, @case, @default를 사용하여 스위치 및 케이스 블록 만들기\n- @for를 사용하여 루프를 만들고 @empty 블록으로 빈 컬렉션을 처리하는 방법\n- ngIf, ngFor 및 ngSwitch를 새 제어 블록 구문으로 이전하는 방법\n\n전체 소스 코드는 여기에서 사용할 수 있습니다:\n\n\n\nhttps://github.com/gergelyszerovay/angular-17-control-flow\n\n저는 Angular v17.0.0-next.8을 사용했습니다. 독립 구성 요소와 시그널을 사용했습니다. 프론트엔드를 시작하려면 yarn run start 또는 npm run start를 입력하세요.\n\n# 조건적으로 렌더링되는 컨트롤 블록: @if 및 @else\n\n첫 번째 예제에서는 체크박스를 만들고 isChecked 시그널에 바인딩합니다. 시그널의 기본값은 true이므로 초기에 체크박스가 선택되고 @if 블록 내용이 렌더링됩니다. 아래 예제는 src\\app\\app.component.html 템플릿 파일에서 가져온 것입니다.\n\n\n\n```js\n<h3>&#64;if and &#64;else</h3>\n<div>\n  <input #checkbox type=\"checkbox\" [checked]=\"isChecked()\" (change)=\"isChecked.set(checkbox.checked)\" id=\"checkbox\"/>\n</div>\n<div>\n@if (isChecked()) {\n  <span>Checked</span>\n} \n@else {\n  <span>Not checked</span>\n}\n</div>\n```\n\n'@if (logical_expression)' 문은 논리 표현식을 사용하여 @if 블록을 생성합니다. 저는 논리 표현식으로 isChecked() 신호를 사용했는데, 이는 부울 값으로 평가됩니다.\n\n@else 블록을 @if 블록 아래에 추가했습니다. 이 블록은 @if 블록의 논리 표현식이 false로 평가될 때 렌더링됩니다. 즉, isChecked() 신호의 값이 false인 경우에 해당합니다. 따라서 체크박스를 해제하면 Angular가 @else 블록의 내용을 렌더링합니다.\n\n새로운 제어 블록 구문과 관련된 중요한 사항이 하나 더 있습니다: '@', '' 및 '' 문자에 특별한 의미가 있기 때문에 템플릿의 텍스트에서 이를 대체해야 합니다. HTML 엔티티를 사용해야 합니다:\n\n\n\n\n- '@' 대신에 &#64;을 사용하세요. 위 코드의 'h3' 헤딩을 확인해보세요.\n- ' ' 대신에 &#123;을 사용하세요.\n- ' ' 대신에 &#125;을 사용하세요.\n\n그렇지 않으면 다음과 같은 컴파일 오류 중 하나가 발생할 수 있습니다:\n\n- [ERROR] NG5002: Incomplete block \"…\". If you meant to write the @ character, you should use the \"@\" HTML entity instead. [plugin angular-compiler]\n- [ERROR] NG5002: Unexpected character \"EOF\" (Do you have an unescaped \"'\" in your template? Use \"'' ‘'’ ''\") to escape it.)\n\n# Collection의 항목을 렌더링하기 위해 @for 블록 사용\n\n\n\n아이템 배열을 컴포넌트 클래스에서 정의해 봅시다:\n\n```js\ncollection = [\n    { id: 1, name: '아이템 1' },\n    { id: 2, name: '아이템 2' },\n    { id: 3, name: '아이템 3' }\n  ];\n```\n\n컬렉션 요소를 렌더링하기 위해 @for (item of items; track item.id) ' 블록을 사용할 수 있습니다:\n\n```js\n<ul>\n@for (item of collection; track item.id; let index = $index, first = $first; let last = $last, even = $even, odd = $odd; let count = $count) {\n<li><strong>{item.name}</strong> index={index} first={first} last={last} even={even} odd={odd} count={count}</li>\n}\n</ul>\n```\n\n\n\n컬렉션 내 각 항목은 고유한 속성(예: id와 같은)을 가져야 하며, 이 값을 track 인수로 참조해야 합니다. 컬렉션이 객체가 아닌 문자열이나 숫자를 포함하는 경우에는 항목 자체를 track 값으로 사용할 수 있습니다: @for (item of items; track item) '.\n\n현재 항목 옆에 @for 표현식을 사용하면 블록 내에서 다음 값에 액세스할 수 있습니다:\n\n- $index: 컬렉션 내 항목의 인덱스\n- $even: 인덱스가 짝수인 경우 true\n- $odd: 인덱스가 홀수인 경우 true\n- $count: 컬렉션 내 항목 수\n- $first: 현재 항목이 컬렉션 내 첫 번째인 경우 true\n- $last: 현재 항목이 컬렉션 내 마지막인 경우 true\n\n# @for에서 전달된 빈 컬렉션을 처리하기 위해 @empty 블록 사용하기\n\n\n\n@for 블록 아래에 @empty 블록을 추가할 수 있습니다. @empty 블록의 내용은 @for 블록에 전달한 컬렉션이 비어있을 때 렌더링됩니다:\n\n```js\n<ul>\n@for (item of emptyCollection; track item.id;) {\n<li><strong>{item.name}</strong></li>\n}\n@empty {\n  <span>컬렉션이 비어 있습니다</span>\n}\n</ul>\n```\n\n# @switch, @case 및 @default로 제어 흐름 변경\n\n다음 예시에서 네 개의 라디오 버튼과 radioValue signal을 생성합니다. signal의 초기값은 1이며 사용자가 라디오 버튼을 클릭할 때 signal의 값이 1, 2, 3 또는 4로 변경됩니다:\n\n\n\n```js\n<div>\n  <div>\n    <input type=\"radio\" [checked]=\"radioValue() === 1\" (change)=\"radioValue.set(1)\" id=\"radio1\"/>\n    <label for=\"radio1\">1</label>\n  </div>\n  <div>\n    <input type=\"radio\" [checked]=\"radioValue() === 2\" (change)=\"radioValue.set(2)\" id=\"radio2\"/>\n    <label for=\"radio2\">2</label>\n  </div>\n  <div>\n    <input type=\"radio\" [checked]=\"radioValue() === 3\" (change)=\"radioValue.set(3)\" id=\"radio3\"/>\n    <label for=\"radio3\">3</label>\n  </div>\n  <div>\n    <input type=\"radio\" [checked]=\"radioValue() === 4\" (change)=\"radioValue.set(4)\" id=\"radio4\"/>\n    <label for=\"radio4\">4</label>\n  </div>\n</div>\n<div>\n```\n라디오 버튼 3개를 선택했습니다.\n```js\n@switch (radioValue()) {\n  @case (1) {\n    <span>Case 1</span>\n  }\n  @case (2) {\n    <span>Case 2</span>\n  }\n  @default {\n    <span>Default case (Not 1 or 2)</span>\n  }\n}\n</div>\n```\n\n\n\n앱 템플릿의 이전 구조 지시문을 새 제어 블록으로 변환하려면 다음 스키마틱을 실행하세요:\n\n```js\nng g @angular/core:control-flow-migration\n```\n\n# 요약\n\n본 문서에서는 Angular 17의 새로운 제어 흐름이 어떻게 작동하는지를 보여드렸습니다: 새로운 제어 블록 구문을 사용하여 조건부 블록 및 반복문을 만드는 방법을 안내했습니다. 내 튜토리얼이 유용했기를 바라며!\n\n\n\n이 기사 시리즈의 첫 부분에서는 새로운 지연 블록의 작동 방식과 이러한 블록 내용의 로딩 및 렌더링을 트리거할 조건을 지정하는 방법에 대해 설명했습니다: 새로운 Angular 17 기능: 지연 로딩.\n\n그리고 언제든지 피드백을 주시면 감사하겠습니다!\n\n# 👨‍💻저자 소개\n\n내 이름은 Gergely Szerovay이고, 프론트엔드 개발 챕터 리드로 일하고 있습니다. Angular 가르치기 (및 배우기)는 제 소질 중 하나입니다. Angular 관련 콘텐츠를 매일 소비합니다 — 기사, 팟캐스트, 컨퍼런스 강연 등을 포함하여요.\n\n\n\n저는 매달 발견한 최고의 자료를 여러분에게 보낼 수 있도록 Angular Addict 뉴스레터를 만들었어요. 경험 많은 Angular Addict 이든 초보자든 모두 대상입니다.\n\n뉴스레터 외에도 Angular Addicts라는 제 판에서 — 맞아요! — 수집한 가장 유익하고 흥미로운 자료들을 소개하고 있어요. 글쓴이로 참여하고 싶다면 언제든지 알려주세요.\n\n함께 Angular를 배워봐요! 여기서 구독하기 🔥\n\nSubstack, Medium, Dev.to, Twitter 또는 LinkedIn에서 저를 팔로우해서 Angular에 대해 더 많은 정보를 얻어보세요!","ogImage":{"url":"/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png"},"coverImage":"/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1","description":"","date":"2024-05-14 14:09","slug":"2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1","content":"\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png)\n\n웹 3.0의 개념은 2000년대 초반에 나타나기 시작했으며, 웹 2.0의 잠재적인 후속자로 손에 잡히는 관심을 끌었습니다. 그 시작 시기는 정확히 정해져 있지 않지만, \"웹 3.0\"이라는 용어는 2000년대 중반쯤에 기술자들과 사고 선도자들이 인터넷 진화의 다음 단계를 상상하기 시작함에 따라 널리 통용되었습니다.\n\n웹 3.0은 인터넷 진화의 혁명적인 단계로 생겨나며, 분산된 신뢰성 없는 프레임워크로 전통적인 표준을 깰 준비를 하고 있습니다. 이 개혁적인 패러다임 변화는 중앙화된 권한으로부터 벗어나 개인 이해관계자 간에 권력이 민주화된 시대를 예고하고 있습니다. 블록체인, 분산저장 및 스마트 계약과 같은 최첨단 기술을 활용하여, 웹 3.0은 조직이 운영에서 향상된 보안, 투명성 및 효율성을 추구하는 동력적 제안을 제시하고 있습니다. 이 대대적인 변화는 거래의 모습을 재정립 뿐만 아니라, 점차적으로 디지턀 배경에서 혁신을 받아들여 번영하기 위한 필요성을 강조합니다. 조직이 웹 3.0의 모습을 탐색하는 동안, 그들은 새로운 기회의 가능성을 풀고 산업의 궤도를 형성할 수 있는 변형적인 여정에 나서며, 보다 분산된, 유연한 및 포용적인 생태계로 향하는 전환적인 여정을 시작합니다.\n\n# 웹 2.0의 문제점과 웹 3.0의 발명을 이끈 문제들\n\n\n\n웹 2.0는 여러 측면에서 혁명적이었지만 몇 가지 문제와 제약도 함께 가져왔습니다. 이 기사에서 몇 가지를 강조하고 싶습니다:\n\n## 권력의 중앙화\n\n웹 2.0 플랫폼은 대부분 중앙 집중화되어 있어서 소수의 대형 기업이 사용자 데이터, 콘텐츠 배포, 플랫폼 운영에 상당한 통제력을 갖고 있습니다. 이 중앙 집중화는 검열, 데이터 유출, 그리고 통제된 상업 관행과 같은 문제로 이어질 수 있습니다.\n\n## 프라이버시 부재\n\n\n\n웹 2.0 기반 애플리케이션은 일반적으로 명확한 동의나 적절한 개인정보 보호 없이도 사용자 데이터를 대상으로 한 광고 및 기타 목적을 위해 방대한 양을 수집합니다. 이러한 프라이버시의 부족은 사용자 신뢰를 약화시키고 데이터 남용과 감시에 대한 우려를 야기할 수 있습니다.\n\n## 상호 운용성 도전\n\n현재의 애플리케이션은 종종 재고를 축적하여 사용자가 서로 다른 서비스와 애플리케이션 간의 데이터와 정보를 원할하게 전송하는 것을 어렵게 만듭니다. 이러한 상호 운용성의 부족은 혁신을 억제하고 사용자 선택을 제한하며 새로운 경쟁 업체에 대한 진입 장벽을 만들 수 있습니다.\n\n## 보안 취약점\n\n\n\n오늘날의 웹 2.0 기반 구현은 때로 보안 취약점과 데이터 유출에 노출될 수 있어서 사용자 정보를 위험에 빠뜨릴 수 있습니다. 데이터의 중앙 집중 저장 및 단일 장애 지점에 의존하면 사이버 공격 및 민감한 정보에 대한 무단 액세스 가능성이 증가합니다.\n\n![그림](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_1.png)\n\n## 이용자 제어의 제한\n\n웹 2.0에서 사용자는 자신의 데이터, 신원 및 디지털 자산에 대해 제한된 제어권을 갖고 있습니다. 플랫폼은 종종 서비스 약관을 지시하고 컨텐츠를 검열하거나 액세스를 제한하거나 사용자에게 별다른 대응 기회 없이 계정을 해지할 권한을 갖고 있습니다.\n\n\n\n## 수익 모델\n\n애플리케이션은 주로 광고 수익과 사용자 데이터 활용을 통해 수익을 창출합니다. 이는 플랫폼이 사용자의 복지보다는 사용자 참여 지표를 우선시하도록 장려하며, 부정한 행위와 관심 조작으로 이어질 수 있습니다.\n\n## 신뢰 문제\n\n플랫폼은 불투명한 알고리즘, 편향적인 콘텐츠 관리, 그리고 의사결정 프로세스의 투명성 부족으로 인해 신뢰 문제를 겪을 수 있습니다. 이는 온라인 정보와 상호 작용의 정직성과 신뢰성에 대한 사용자의 신뢰를 약화시킬 수 있습니다.\n\n\n\n# 웹 3.0의 핵심 원칙\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_2.png)\n\n## 분산화\n\n웹 3.0은 통제를 분산화하고 중앙 당국 또는 중개인에 의존성을 제거하려고 합니다. 소수 기업이나 개체의 손에 집중시키는 대신 사용자 네트워크 사이에서 권력을 분산시켜 더 견고하고 포용적이며 검열 방지혁 인터넷 생태계를 만들려고 합니다. 이더리움 블록체인에 배포된 탈중앙화 애플리케이션(DApp)과 상호 작용하기 위해 web3.js 라이브러리를 사용하는 다음 예제를 확인해보세요.\n\n\n\n```js\n// Web3.js 라이브러리를 가져옵니다\nimport Web3 from 'web3';\n\n// 이더리움 네트워크에 연결합니다 ('http://localhost:8545'를 자신의 이더리움 노드 URL로 바꿉니다)\nconst web3 = new Web3('http://localhost:8545');\n\n// 스마트 계약의 주소와 ABI (Application Binary Interface)를 정의합니다\nconst contractAddress = '0x1234567890123456789012345678901234567890'; // 귀하의 계약 주소로 대체합니다\nconst contractABI: any[] = [\n  // 귀하의 스마트 계약 메서드의 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getData\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n];\n\n// 계약 인스턴스를 생성합니다\nconst contract = new web3.eth.Contract(contractABI, contractAddress);\n\n// 스마트 계약에서 데이터를 가져오는 함수\nasync function fetchData(): Promise<void> {\n  try {\n    // 스마트 계약의 getData 함수 호출\n    const data: number = await contract.methods.getData().call();\n    console.log('스마트 계약에서 검색된 데이터:', data);\n  } catch (error) {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  }\n}\n\n// fetchData 함수 호출합니다\nfetchData();\n```\n\n## 상호 운용성\n\n웹 3.0의 개념은 서로 다른 플랫폼, 응용 프로그램 및 프로토콜간의 상호 운용성을 촉진합니다. 이는 다양한 생태계 간의 원활한 데이터 교환과 협력을 가능케 하며, 혁신을 촉진하고 사용자가 사일로된 데이터나 닫힌 시스템으로 제약받지 않고 웹을 더 유연하게 탐색할 수 있도록 합니다.\n\n다음은 서로 다른 네트워크에 배포된 두 개의 이더리움 기반 스마트 계약 간의 상호 운용성을 보여주는 TypeScript의 기본 예제입니다.```\n\n\n\n```js\n// Web3.js 라이브러리를 가져와서 사용합니다\nimport Web3 from 'web3';\n\n// 이더리움 네트워크에 연결합니다 (이더리움 노드 URL과 네트워크 ID를 교체해주세요)\nconst web3NetworkA = new Web3('http://networkA:8545');\nconst web3NetworkB = new Web3('http://networkB:8545');\n\n// 네트워크 A에 배포된 첫 번째 스마트 계약의 주소와 ABI를 정의합니다\nconst contractAddressA = '0x1234567890123456789012345678901234567890'; // 네트워크 A의 계약 주소로 교체해주세요\nconst contractABIA: any[] = [\n  // 네트워크 A에 배포된 스마트 계약의 ABI\n  // 네트워크 A의 계약과 상호작용할 메서드를 정의합니다\n];\n\n// 네트워크 B에 배포된 두 번째 스마트 계약의 주소와 ABI를 정의합니다\nconst contractAddressB = '0x0987654321098765432109876543210987654321'; // 네트워크 B의 계약 주소로 교체해주세요\nconst contractABIB: any[] = [\n  // 네트워크 B에 배포된 스마트 계약의 ABI\n  // 네트워크 B의 계약과 상호작용할 메서드를 정의합니다\n];\n\n// 두 계약의 인스턴스를 생성합니다\nconst contractA = new web3NetworkA.eth.Contract(contractABIA, contractAddressA);\nconst contractB = new web3NetworkB.eth.Contract(contractABIB, contractAddressB);\n\n// 두 계약 간 데이터 전송하는 함수를 정의합니다\nasync function transferData(): Promise<void> {\n  try {\n    // 계약 A에서 데이터를 검색하는 메서드 호출\n    const data = await contractA.methods.getData().call();\n\n    // 계약 B에서 데이터를 설정하는 메서드 호출\n    await contractB.methods.setData(data).send({ from: '0x당신의주소', gas: 500000 });\n    \n    console.log('계약 A에서 계약 B로 데이터 전송 성공:', data);\n  } catch (error) {\n    console.error('데이터 전송 중 오류 발생:', error);\n  }\n}\n\n// 상호운용성을 보여주기 위해 transferData 함수 호출\ntransferData();\n```\n\n## 개인정보\n\n개인정보 보호는 Web 3.0의 핵심 원칙으로, 사용자가 개인 데이터를 제어하고 소유하는 것을 강조합니다. 사용자 데이터가 수집되고 이익을 위해 활용되며 침해를 받는 Web 2.0과는 달리, Web 3.0은 사용자의 개인 정보를 보호하는 메커니즘을 우선시합니다. 이는 분산 저장, 암호화, 자기 주권 식별 솔루션 등을 포함합니다.\n\n다음은 TypeScript를 사용한 간단한 예제로, 암호 기술과 분산 인증 메커니즘을 활용하여 사용자의 개인 정보 보호를 강화하는 웹3-react 라이브러리를 이용한 탈중앙화 애플리케이션(DApp)과 상호 작용하는 방법을 보여줍니다.```\n\n\n\n```js\nimport { ethers } from 'ethers';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { InjectedConnector } from '@web3-react/injected-connector';\nimport { useWeb3React } from '@web3-react/core';\n\n// 주입된 커넥터를 초기화합니다.\nconst injectedConnector = new InjectedConnector({ supportedChainIds: [1, 3, 4, 5, 42] });\n\n// 이더리움 프로바이더를 초기화합니다.\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\n\n// 계정 세부 정보를 가져오는 함수\nasync function fetchAccountDetails(): Promise<void> {\n  try {\n    // 사용자의 이더리움 계정에 접근 권한을 요청합니다.\n    await provider.send('eth_requestAccounts', []);\n\n    // 서명자를 가져옵니다.\n    const signer = provider.getSigner();\n\n    // 사용자의 이더리움 주소를 가져옵니다.\n    const address = await signer.getAddress();\n\n    // 주소 출력\n    console.log('사용자 주소:', address);\n  } catch (error) {\n    console.error('계정 세부 정보 가져오기 오류:', error);\n  }\n}\n\n// 주요 함수\nasync function main(): Promise<void> {\n  // 계정 세부 정보 가져오기\n  await fetchAccountDetails();\n}\n\n// 주요 함수 실행\nmain();\n```\n\n## 사용자 권한 부여\n\n또한 사용자에게 온라인 경험, 아이덴티티 및 디지털 자산에 대한 더 큰 통제력을 제공하여 사용자들을 권한 부여하는 것을 목표로 합니다. Web 3.0에서 탈중앙화된 거버넌스, 자체 실행 스마트 계약 및 토큰화와 같은 기능을 통해 사용자들은 의사 결정 과정에 더 적극적으로 참여하고 새로운 경제적 기회에 접근하며 디지털 삶 소유권을 주장할 수 있습니다.\n\nTypeScript를 사용한 Web 3.0에서 사용자 권한 부여를 보여주는 간단한 예제로 탈중앙화된 아이덴티티(DID) 솔루션을 사용합니다. 이 예제에서는 이더리움에서 탈중앙화된 아이덴티티 관리의 인기 있는 선택인 uPort 라이브러리를 사용할 것입니다.\n\n\n\n\n```js\nimport { Connect, SimpleSigner } from 'uport-connect';\n\n// uPort 인스턴스 생성\nconst uport = new Connect('당신의앱이름', {\n  clientId: '당신의클라이언트아이디', // 여러분의 uPort 클라이언트 ID로 대체해주세요\n  signer: SimpleSigner('당신의개인키') // 여러분의 개인 키로 대체해주세요\n});\n\n// 사용자를 위한 탈중앙화 식별자(DID) 생성하는 함수\nasync function createDID(): Promise<void> {\n  try {\n    // 사용자에게 탈중앙화 식별자를 만들기 위한 동의를 요청함\n    const credentials = await uport.requestCredentials({\n      requested: ['name', 'avatar'], // 요청된 사용자 속성\n      notifications: true // 크리덴셜 요청을 위한 푸시 알림 활성화\n    });\n\n    // 사용자의 탈중앙화 식별자를 기록함\n    console.log('탈중앙화 식별자(DID):', credentials);\n  } catch (error) {\n    console.error('탈중앙화 식별자 생성 중 오류 발생:', error);\n  }\n}\n\n// 사용자를 위해 탈중앙화 식별자를 만들기 위해 createDID 함수 호출\ncreateDID();\n```\n\n# 웹 3.0에 대해 더 알아보기\n\n위의 기사에서 몇 가지 용어를 언급했는데, 분명 일부 용어가 블록체인과 관련이 있다는 걸 알아챘을 거예요. 그래서 우리는 블록체인이 웹 3.0을 위한 기술적 기반으로 작용한다고 할 수 있어요. 이제 웹 3.0 관련 용어 몇 가지 더 살펴봅시다.\n\n## 탈중앙화 애플리케이션 (DApp)```\n\n\n\n분산 애플리케이션(DApp)은 블록체인 기술을 활용하는 분산 네트워크에서 작동하는 소프트웨어 응용 프로그램 유형입니다. 일반적으로 중앙화된 서버에 호스팅되고 단일 엔티티에 의해 제어되는 전통적인 애플리케이션과는 달리, DApp은 컴퓨터(노드)들의 동등 네트워크에서 실행되며 데이터와 작업이 네트워크 상으로 분산됩니다. DApp의 주요 특징으로는 분산화, 오픈 소스, 토큰화, 스마트 계약, 변경할 수 없는 데이터와 상호 운용성이 있습니다.\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_3.png)\n\n분산화 응용 프로그램의 몇 가지 예시로는 분산 재무(DeFi) 플랫폼, 분산 거래소 (DEX), 블록체인 기반 게임, 소셜 네트워크 및 공급망 관리 시스템 등이 있습니다.\n\n## 스마트 계약 및 ABI\n\n\n\n스마트 계약은 합의 조건이 직접 코드로 작성된 자체 실행 계약입니다. 이러한 계약은 이더리움과 같은 블록체인 네트워크에 저장되고 실행되며 중개인 없이 당사자 간의 합의 조건을 자동으로 시행합니다. 스마트 계약의 주요 특징으로는 자치성, 신뢰 없음, 보안, 투명성, 효율성 및 분산화가 있습니다.\n\n위 예제에서 스마트 계약인 다음 코드를 주목했을 것입니다:\n\n```js\nconst contractABI: any[] = [\n  // 스마트 계약 메서드의 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getData\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n];\n```\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_4.png)\n\n\n\nABI는 \"Application Binary Interface\"의 약자입니다. ABI는 이더리움 블록체인에 배포된 스마트 계약의 인터페이스를 JSON으로 나타낸 것입니다. 스마트 계약의 메서드와 속성을 정의하며, 해당 메서드와 속성의 이름, 매개변수, 반환 유형 및 가시성을 포함합니다.\n\nABI는 탈중앙화된 응용프로그램(DApps)이나 스크립트와 같은 외부 응용프로그램에서 스마트 계약과 상호작용하는 데 중요합니다. ABI는 이더리움 가상 머신(EVM)과 외부 응용프로그램 사이의 다리 역할을 하며, 배포된 스마트 계약에서 함수를 호출하고 상호작용할 수 있게 합니다.\n\nAPI와는 다른 ABI에 대한 내용을 자세히 다룬 좋은 기사가 있습니다.\n\n## 검열 저항력\n\n\n\nWeb 3.0 아키텍처는 검열에 강하게 설계되어 시각과 표현의 자유를 지킵니다. 탈중앙화된 네트워크와 프로토콜을 통해 어떠한 단일 엔티티도 콘텐츠를 통제하거나 검열하는 것이 어렵게 되어, 정보가 모든 이에게 접근 가능하도록 보장됩니다.\n\n다음은 IPFS Helia를 사용한 간단한 TypeScript 예제로, 탈중앙화된 저장소가 검열에 대항하는 데 어떻게 기여할 수 있는지 보여줍니다:\n\n```js\n// IPFS Helia 불러오기\nimport IPFSHelia from 'ipfs-helia';\n\n// IPFS Helia 노드에 연결하기 ('localhost'를 IPFS Helia 노드 주소로 대체)\nconst ipfsHelia = new IPFSHelia({ host: 'localhost', port: '5002', protocol: 'http' });\n\n// IPFS Helia에 파일을 업로드하는 함수\nasync function uploadFile(): Promise<string> {\n  try {\n    const fileContent = Buffer.from('Hello, world!', 'utf-8');\n\n    // 파일을 IPFS Helia에 업로드\n    const result = await ipfsHelia.add(fileContent);\n    const ipfsHash = result.cid.toString();\n\n    console.log('해시 값으로 IPFS Helia에 파일 업로드 완료:', ipfsHash);\n    return ipfsHash;\n  } catch (error) {\n    console.error('IPFS Helia에 파일을 업로드하는 중 오류 발생:', error);\n    throw error;\n  }\n}\n\n// 해시 값을 사용하여 IPFS Helia에서 파일을 검색하는 함수\nasync function retrieveFile(ipfsHash: string): Promise<void> {\n  try {\n    // IPFS Helia에서 파일을 검색\n    const fileBuffer = await ipfsHelia.cat(ipfsHash);\n    const fileContent = fileBuffer.toString();\n\n    console.log('IPFS Helia로부터 검색된 파일 내용:', fileContent);\n  } catch (error) {\n    console.error('IPFS Helia로부터 파일을 검색하는 중 오류 발생:', error);\n  }\n}\n\n// 파일을 IPFS Helia에 업로드\nuploadFile()\n  .then((ipfsHash) => {\n    // IPFS Helia로부터 업로드된 파일 검색\n    retrieveFile(ipfsHash);\n  })\n  .catch((error) => {\n    console.error('오류:', error);\n  });\n```\n\n## 향상된 확장성과 성능\n\n\n\n웹 3.0은 이전 웹의 확장성과 성능 문제에 대응하기 위해 노력합니다. 샤딩, 레이어 2 솔루션 및 개선된 합의 메커니즘과 같은 혁신들은 웹 3.0 플랫폼이 더 높은 거래 및 상호 작용의 부하를 더 효율적으로 처리할 수 있도록 합니다.\n\n## 토큰화와 디지털 자산\n\n웹 3.0은 자산과 서비스를 블록체인 네트워크 상의 디지털 토큰으로 표현하는 토큰화 개념을 소개합니다. 이로써 부분 소유권을 용이하게 만들고 유동성을 향상시키며 새로운 형태의 가치 교환과 통화화를 가능하게 합니다. 다음은 이더리움 블록체인에서 ERC-20 표준을 사용하여 토큰화와 디지털 자산을 설명하는 간단한 예시입니다.\n\n```js\nimport Web3 from 'web3';\nimport { Contract, ContractFactory } from 'ethers';\nimport { ethers } from 'hardhat';\n\n// 이더리움 네트워크에 연결하기 ('http://localhost:8545'를 사용 중인 이더리움 노드 URL로 대체하세요)\nconst web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));\n\n// ERC-20 토큰 컨트랙트 ABI\nconst tokenABI: any[] = [\n  // ERC-20 표준 메소드 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  // 다른 메소드들...\n];\n\n// ERC-20 토큰 컨트랙트를 배포하는 함수\nasync function deployTokenContract(name: string, symbol: string, initialSupply: number): Promise<void> {\n  try {\n    // 서명자 얻기\n    const signer = ethers.provider.getSigner();\n\n    // ERC-20 토큰 컨트랙트 배포\n    const tokenFactory = new ContractFactory(tokenABI, ERC20Token.bytecode, signer);\n    const tokenContract = await tokenFactory.deploy(name, symbol, initialSupply);\n\n    console.log('ERC-20 토큰 컨트랙트 배포됨:', tokenContract.address);\n  } catch (error) {\n    console.error('ERC-20 토큰 컨트랙트 배포 중 오류 발생:', error);\n  }\n}\n\n// deployTokenContract 함수를 호출하여 ERC-20 토큰 컨트랙트를 배포합니다.\ndeployTokenContract('MyToken', 'MTK', 1000000);\n```\n\n\n\n여기까지 도착했다면, 이 글의 제2부를 계속 읽고 싶은 것 같네요. 아래 링크에서 제2부를 확인해보세요. \n\n[https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220](https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220)","ogImage":{"url":"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png"},"coverImage":"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png","tag":["Tech"],"readingTime":13}],"page":"33","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}