{"pageProps":{"post":{"title":"검색 기능을 최적화하자  React 입력 최적화","description":"","date":"2024-05-12 22:27","slug":"2024-05-12-DebounceyourSearchReactInputOptimization","content":"\n\n<img src=\"/assets/img/2024-05-12-DebounceyourSearchReactInputOptimization_0.png\" />\n\n디바운싱은 작업이 발생하는 횟수를 제한하는 최적화 기법입니다. React에서 검색 기능을 구현했을 때 사용자가 각 문자를 입력할 때마다 목록을 자동으로 필터링하거나 fetch 요청을 보내는 경우,이 기술은 응용 프로그램의 효율성을 크게 향상시킬 수 있는 기술입니다.\n\n# 설정 / 설치\n\n이 예제에서는 고유틸리티 라이브러리인 lodash에서 debounce 함수를 가져와 사용할 것입니다. 이를 위해 필터링 작업을 처리할 구성요소의 맨 위에 다음 코드 줄을 추가하면 됩니다.\n\n\n\n```js\nimport debounce from 'lodash.debounce';\n```\n\n다음으로는 사용 중인 것에 따라 npm 또는 yarn으로 종속성을 설치해야 합니다.\n\nnpm install lodash.debounce\n\n또는\n\n\n\nyarn add lodash.debounce\n\n# 예시 분석\n\n위의 CodeSandbox 예시에서 간단한 앱을 만들어 보았어요. 해당 앱은 과일 목록을 표시하고, 입력란에 텍스트를 입력할 때마다 목록이 필터링되는 기능을 가지고 있어요.\n\n입력란은 제어 폼(Controlled Form)이에요. 표시되는 값은 상태(state)에서 가져오며, 입력란은 onChange 이벤트를 통해 상태와 연결되어 있어요.\n\n\n\n```js\nconst [searchTerm, setSearchTerm] = useState(\"\");\n\nconst handleChange = (e) => {\n  setSearchTerm(e.target.value);\n};\n```\n\n```js\n<input type=\"text\" value={searchTerm} onChange={handleChange} />\n```\n\n사용자가 입력하는 문자마다 과일 목록이 필터링되고 사용자가 볼 수 있는 목록이 업데이트됩니다.\n\n```js\nlet listToDisplay = fruits;\nif (searchTerm !== \"\")\n  listToDisplay = fruits.filter((fruit) => {\n    return fruit.includes(searchTerm);\n  });\n}\n```  \n\n\n\n# 문제\n\n이 예시는 작동이 잘되지만, 목록의 크기가 커질수록 각 검색에 걸리는 시간이 길어질 것을 상상할 수 있습니다. 또 다른 시나리오는 각 문자열을 검색할 때마다 API 요청을 보내는 것일 수 있습니다. 어느 쪽이든, 이 구현은 애플리케이션을 느리게 만들 수 있고 이를 어떻게 해결해야 할지 고민에 빠질 수 있습니다. 여기서 debounce가 등장합니다.\n\n# Debounce\n\n```js\n_.debounce(func, [wait=0], [options={}])\n```\n\n\n\n디바운스가 3개의 인수를 사용하지만, 우리는 첫 두 인수를 사용할 것입니다. 실행하고 싶은 함수와 기다리고 있는 시간입니다.\n\n또한 나중에 정리에 도움이 되는 debounce에 내장된 .cancel 함수도 사용할 것입니다.\n\n디바운스 함수에 대한 더 많은 정보는 공식 설명서를 참조해주세요.\n\n# 구현\n\n\n\n첫 번째 단계는 useMemo을 사용하여 debounce 함수에서 반환 값을 메모이즈하는 작업입니다. 이 반환된 값은 다시 렌더링 사이에 유지됩니다. 이 단계는 필수적입니다. 왜냐하면 이 데이터를 다시 렌더링 사이에서 지속하지 않으면 debounce의 다른 구현이 모든 다시 렌더링마다 발생하게 되고, 본질적으로 우리의 초기 예제를 가지고 있는 셈이 됩니다. 즉, 마지막 문자 입력 후 일정 시간이 지난 후에 한 문자씩 목록을 필터링하는 상태가 될 것입니다.\n\n```js\nconst debouncedResults = useMemo(() => {\n  return debouce(handleChange, 300);\n}, []);\n```\n\n다음으로 useEffect를 사용하여 컴포넌트가 언마운트될 때 debounce에서 발생하는 부작용을 정리할 것입니다. 더 이상 해당 페이지나 뷰에 나 있지 않을 때는 검색을 실행할 이유가 없습니다. 여기서는 메모이즈된 반환 값을 사용하여 .cancel 함수를 호출할 것입니다.\n\n```js\nuseEffect(() => {\n  return () => {\n    debouncedResults.cancel();\n  };\n});\n```\n\n\n\n마침내 이전 작업 중 일부를 취소할 차례입니다. `value` 속성을 삭제하여 폼을 비제어 상태로 만들고 `onChange`를 `debouncedResults`를 호출하도록 설정합니다. 이렇게 하면 입력이 변경될 때마다 폼이 디바운스되도록 할 수 있습니다.\n\n```js\n<input type=\"text\" onChange={debouncedResults} />\n```\n\n그리고 이렇게 완료되었습니다. 디바운싱이 적용된 입력 상자가 완성되었습니다!\n\n# 작업 예시","ogImage":{"url":"/assets/img/2024-05-12-DebounceyourSearchReactInputOptimization_0.png"},"coverImage":"/assets/img/2024-05-12-DebounceyourSearchReactInputOptimization_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-DebounceyourSearchReactInputOptimization_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"디바운싱은 작업이 발생하는 횟수를 제한하는 최적화 기법입니다. React에서 검색 기능을 구현했을 때 사용자가 각 문자를 입력할 때마다 목록을 자동으로 필터링하거나 fetch 요청을 보내는 경우,이 기술은 응용 프로그램의 효율성을 크게 향상시킬 수 있는 기술입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"설정 / 설치\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예제에서는 고유틸리티 라이브러리인 lodash에서 debounce 함수를 가져와 사용할 것입니다. 이를 위해 필터링 작업을 처리할 구성요소의 맨 위에 다음 코드 줄을 추가하면 됩니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" debounce \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'lodash.debounce'\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로는 사용 중인 것에 따라 npm 또는 yarn으로 종속성을 설치해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"npm install lodash.debounce\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또는\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"yarn add lodash.debounce\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"예시 분석\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 CodeSandbox 예시에서 간단한 앱을 만들어 보았어요. 해당 앱은 과일 목록을 표시하고, 입력란에 텍스트를 입력할 때마다 목록이 필터링되는 기능을 가지고 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"입력란은 제어 폼(Controlled Form)이에요. 표시되는 값은 상태(state)에서 가져오며, 입력란은 onChange 이벤트를 통해 상태와 연결되어 있어요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [searchTerm, setSearchTerm] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handleChange\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"e\"\n        }), \") => {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setSearchTerm\"\n        }), \"(e.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"target\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \");\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"<input type=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"text\\\"\"\n        }), \" value={searchTerm} onChange={handleChange} />\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자가 입력하는 문자마다 과일 목록이 필터링되고 사용자가 볼 수 있는 목록이 업데이트됩니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" listToDisplay = fruits;\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (searchTerm !== \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \")\\n  listToDisplay = fruits.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"filter\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"fruit\"\n          }), \") =>\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" fruit.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"includes\"\n        }), \"(searchTerm);\\n  });\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"문제\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예시는 작동이 잘되지만, 목록의 크기가 커질수록 각 검색에 걸리는 시간이 길어질 것을 상상할 수 있습니다. 또 다른 시나리오는 각 문자열을 검색할 때마다 API 요청을 보내는 것일 수 있습니다. 어느 쪽이든, 이 구현은 애플리케이션을 느리게 만들 수 있고 이를 어떻게 해결해야 할지 고민에 빠질 수 있습니다. 여기서 debounce가 등장합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Debounce\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"_.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"debounce\"\n        }), \"(func, [wait=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], [options={}])\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"디바운스가 3개의 인수를 사용하지만, 우리는 첫 두 인수를 사용할 것입니다. 실행하고 싶은 함수와 기다리고 있는 시간입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 나중에 정리에 도움이 되는 debounce에 내장된 .cancel 함수도 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"디바운스 함수에 대한 더 많은 정보는 공식 설명서를 참조해주세요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"구현\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫 번째 단계는 useMemo을 사용하여 debounce 함수에서 반환 값을 메모이즈하는 작업입니다. 이 반환된 값은 다시 렌더링 사이에 유지됩니다. 이 단계는 필수적입니다. 왜냐하면 이 데이터를 다시 렌더링 사이에서 지속하지 않으면 debounce의 다른 구현이 모든 다시 렌더링마다 발생하게 되고, 본질적으로 우리의 초기 예제를 가지고 있는 셈이 됩니다. 즉, 마지막 문자 입력 후 일정 시간이 지난 후에 한 문자씩 목록을 필터링하는 상태가 될 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" debouncedResults = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useMemo\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =>\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"debouce\"\n        }), \"(handleChange, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"300\"\n        }), \");\\n}, []);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로 useEffect를 사용하여 컴포넌트가 언마운트될 때 debounce에서 발생하는 부작용을 정리할 것입니다. 더 이상 해당 페이지나 뷰에 나 있지 않을 때는 검색을 실행할 이유가 없습니다. 여기서는 메모이즈된 반환 값을 사용하여 .cancel 함수를 호출할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useEffect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =>\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =>\"\n        }), \" {\\n    debouncedResults.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"cancel\"\n        }), \"();\\n  };\\n});\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"마침내 이전 작업 중 일부를 취소할 차례입니다. \", _jsx(_components.code, {\n        children: \"value\"\n      }), \" 속성을 삭제하여 폼을 비제어 상태로 만들고 \", _jsx(_components.code, {\n        children: \"onChange\"\n      }), \"를 \", _jsx(_components.code, {\n        children: \"debouncedResults\"\n      }), \"를 호출하도록 설정합니다. 이렇게 하면 입력이 변경될 때마다 폼이 디바운스되도록 할 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"<input type=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"text\\\"\"\n        }), \" onChange={debouncedResults} />\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 이렇게 완료되었습니다. 디바운싱이 적용된 입력 상자가 완성되었습니다!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"작업 예시\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}