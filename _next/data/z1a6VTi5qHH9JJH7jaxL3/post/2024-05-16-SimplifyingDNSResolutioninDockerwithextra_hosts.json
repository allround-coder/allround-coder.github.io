{"pageProps":{"post":{"title":"도커에서 extra_hosts를 사용하여 DNS 해결 단순화하기","description":"","date":"2024-05-16 16:56","slug":"2024-05-16-SimplifyingDNSResolutioninDockerwithextra_hosts","content":"\n\n소개: Docker 세계에서는 가장 간단한 작업조차 복잡해질 수 있습니다. 최근 Docker 컨테이너에서 Apache Airflow를 실행하는 중에 귀찮은 문제에 직면했습니다. 우리의 설정은 Airflow를 Azure PostgreSQL 데이터베이스에 연결하는 것을 포함했지만, 때때로 DNS 오류로 인해 작업 흐름이 방해받았습니다. 조사를 통해 Docker의 DNS 캐싱 부족이 문제의 주범임을 알게 되었습니다. 이 게시물에서는 Docker Compose의 extra_hosts 기능을 활용하여 문제를 해결한 방법을 공유하겠습니다. 이를 통해 팀이 불필요한 두통으로부터 구해졌습니다.\n\n문제: Docker 컨테이너는 내장된 DNS 캐싱이 없어 모든 연결 시도에 대해 DNS 해상도에 의존해야 합니다. 이는 가끔 실패로 이어질 수 있으며 특히 네트워크 트래픽이 많은 환경에서 문제가 발생할 수 있습니다. 우리의 경우, 매일 수천 개의 작업을 실행하는 Apache Airflow가 DNS 해상도 문제로 PostgreSQL 데이터베이스에 연결하는 데 어려움을 겪고 있었습니다.\n\n해결책: DNS 해상도 문제에 대처하기 위해 Docker Compose의 extra_hosts 기능을 활용했습니다. 이 편리한 기능을 사용하면 추가 호스트 이름과 IP 주소를 지정하여 DNS 해상도가 전혀 필요하지 않게 됩니다. 호스트 이름을 직접 IP 주소로 매핑함으로써 개인 DNS 서버의 부하를 줄이고 컨테이너 간 안정적인 통신을 보장할 수 있습니다.\n\n구현: 해결책을 구현하는 것은 간단했습니다. PostgreSQL 데이터베이스 호스트 이름과 해당 IP 주소에 대한 extra_hosts 항목을 Docker Compose 구성에 업데이트했습니다.\n\n<div class=\"content-ad\"></div>\n\n\n버전: '3'\n서비스:\n  airflow:\n    이미지: airflow:latest\n    환경:\n     - AIRFLOW__CORE__EXECUTOR=LocalExecutor\n     - AIRFLOW__DATABASE__SQL_ALCHEMY_CONN=postgresql+psycopg2://@myprivatpgsqlserver.postgres.database.azure.com:6432/mydbinstance\n     - AIRFLOW__CORE__LOAD_EXAMPLES=False\n     - AIRFLOW__CORE__LOGGING_LEVEL=INFO\n    extra_hosts:\n     - \"myprivatpgsqlserver.postgres.database.azure.com:192.168.159.84\"\n    # 기타 Airflow 구성...\n\n이 구성에서는:\n\n- airflow 서비스 하위에 extra_hosts 섹션을 추가했습니다.\n\n우리는 myprivatpgsqlserver.postgres.database.azure.com 호스트명 및 해당 IP 주소 192.168.1.100을 지정하여 PostgreSQL 데이터베이스에 대한 연결에 대한 DNS 해결을 우회했습니다.\n","ogImage":{"url":"/assets/img/2024-05-16-SimplifyingDNSResolutioninDockerwithextra_hosts_0.png"},"coverImage":"/assets/img/2024-05-16-SimplifyingDNSResolutioninDockerwithextra_hosts_0.png","tag":["Tech"],"readingTime":2},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    div: \"div\",\n    ul: \"ul\",\n    li: \"li\",\n    h1: \"h1\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"소개: Docker 세계에서는 가장 간단한 작업조차 복잡해질 수 있습니다. 최근 Docker 컨테이너에서 Apache Airflow를 실행하는 중에 귀찮은 문제에 직면했습니다. 우리의 설정은 Airflow를 Azure PostgreSQL 데이터베이스에 연결하는 것을 포함했지만, 때때로 DNS 오류로 인해 작업 흐름이 방해받았습니다. 조사를 통해 Docker의 DNS 캐싱 부족이 문제의 주범임을 알게 되었습니다. 이 게시물에서는 Docker Compose의 extra_hosts 기능을 활용하여 문제를 해결한 방법을 공유하겠습니다. 이를 통해 팀이 불필요한 두통으로부터 구해졌습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"문제: Docker 컨테이너는 내장된 DNS 캐싱이 없어 모든 연결 시도에 대해 DNS 해상도에 의존해야 합니다. 이는 가끔 실패로 이어질 수 있으며 특히 네트워크 트래픽이 많은 환경에서 문제가 발생할 수 있습니다. 우리의 경우, 매일 수천 개의 작업을 실행하는 Apache Airflow가 DNS 해상도 문제로 PostgreSQL 데이터베이스에 연결하는 데 어려움을 겪고 있었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해결책: DNS 해상도 문제에 대처하기 위해 Docker Compose의 extra_hosts 기능을 활용했습니다. 이 편리한 기능을 사용하면 추가 호스트 이름과 IP 주소를 지정하여 DNS 해상도가 전혀 필요하지 않게 됩니다. 호스트 이름을 직접 IP 주소로 매핑함으로써 개인 DNS 서버의 부하를 줄이고 컨테이너 간 안정적인 통신을 보장할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"구현: 해결책을 구현하는 것은 간단했습니다. PostgreSQL 데이터베이스 호스트 이름과 해당 IP 주소에 대한 extra_hosts 항목을 Docker Compose 구성에 업데이트했습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"버전: '3'\\n서비스:\\nairflow:\\n이미지: airflow\", _jsx(_components.div, {}), \"\\n환경:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"AIRFLOW__CORE__EXECUTOR=LocalExecutor\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"AIRFLOW__DATABASE__SQL_ALCHEMY_CONN=postgresql+psycopg2://@myprivatpgsqlserver.postgres.database.azure.com:6432/mydbinstance\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"AIRFLOW__CORE__LOAD_EXAMPLES=False\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"AIRFLOW__CORE__LOGGING_LEVEL=INFO\\nextra_hosts:\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"\\\"myprivatpgsqlserver.postgres.database.azure.com:192.168.159.84\\\"\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"기타 Airflow 구성...\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 구성에서는:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"airflow 서비스 하위에 extra_hosts 섹션을 추가했습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 myprivatpgsqlserver.postgres.database.azure.com 호스트명 및 해당 IP 주소 192.168.1.100을 지정하여 PostgreSQL 데이터베이스에 대한 연결에 대한 DNS 해결을 우회했습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}