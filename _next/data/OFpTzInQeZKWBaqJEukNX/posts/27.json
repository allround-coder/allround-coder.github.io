{"pageProps":{"posts":[{"title":"Angular 프로젝트에서 React 컴포넌트 사용하는 방법","description":"","date":"2024-06-22 03:34","slug":"2024-06-22-UseReactComponentInsideAngularProject","content":"\n\n<img src=\"/assets/img/2024-06-22-UseReactComponentInsideAngularProject_0.png\" />\n\n많은 글에서 어떤 인기 있는 프레임워크가 더 나은지에 대한 논쟁을 보았을 겁니다. React JS인지 Angular인지요. 그러나 제가 알기로는 대부분의 현대 프레임워크들은 비슷하다고 생각해요. (각 프레임워크의 백지상태의 자바스크립트 뒷단이 어떻게 돌아가는지 알고 있다면 말이죠.) 단지 작은 구문 변경과 브라우저에서 div를 렌더링하는 방식에 약간의 차이만 있을 뿐입니다.\n\nReact JS가 최고인지 Angular가 최고인지는 중요하지 않아요. 전문가들은 신경 쓰지 않으며 더 많이 솔루션을 제공하는데 초점을 맞추죠.\n\n그래서 만약 우리가 Angular와 React JS를 동시에 단일 프로젝트에서 사용하여 이 논쟁을 마무리짓는다면 어떨까요?\n\n<div class=\"content-ad\"></div>\n\n이를 위해 첫 번째 단계는 다음 명령을 CMD에서 실행하여 Angular 프로젝트를 초기화하는 것입니다:\n\n```js\nng new angular-react\n\ncd angular-react\n```\n\n위의 명령은 최신 버전의 새로운 Angular 프로젝트를 만들고, 그 후에 해당 프로젝트 루트 폴더로 이동합니다.\n\n이후에 Angular 내에서 React를 지원하기 위한 모든 종속성들을 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install react, react-dom\n```\n\n프로젝트 내에서 React 패키지가 설치되면, React 컴포넌트를 작성하기 위해 tsconfig.json 파일을 .tsx를 지원하도록 업데이트해야 합니다:\n\n```js\n{\n  \"compilerOptions\": {\n    ...\n    \"jsx\": \"react\",\n    ...\n  },\n}\n```\n\ntsconfig.json 파일에서 compilerOptions 아래에 \"jsx\" 속성을 추가하고 값을 \"react\"로 설정하세요. 이렇게 하면 TypeScript 컴파일러가 JSX 또는 TSX 파일과 코드를 이해하고 지원할 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\nTypescript 구성이 완료되면 Angular에서 실제 React 코드가 작성된 새 컴포넌트를 생성할 것입니다.\n\n```js\nng g c react-comp\n```\n\n위 명령은 프로젝트의 app 폴더에 새 컴포넌트를 추가할 것입니다. 컴포넌트를 추가한 후에는 react-comp.component.ts의 확장자를 react-comp.component.tsx로 변경하십시오.\n\n```js\n/** 컴포넌트 폴더 구조 **/\n\n- react-comp\n    react-comp.component.css\n    react-comp.component.html\n    react-comp.component.ts -> react-comp.component.tsx\n```\n\n<div class=\"content-ad\"></div>\n\nHTML 파일에 div를 추가하고 ID를 할당하세요. 이렇게 하면 React가 해당 루트 div를 찾도록 도와줍니다:\n\n```js\n<p>react-comp works!</p>\n<div id=\"react-comp\"></div>\n```\n\n.tsx 파일 안에 다음 코드를 복사하세요:\n\n```js\nimport { Component } from '@angular/core';\nimport React from 'react'\nimport ReactDOM from 'react-dom/client';\nimport { MyComponent } from 'react-sample'\n\n@Component({\n  selector: 'app-react-comp',\n  standalone: true,\n  imports: [],\n  templateUrl: './react-comp.component.html',\n  styleUrl: './react-comp.component.css'\n})\nexport class ReactCompComponent {\n\n  ngOnInit(): void {\n    const root = ReactDOM.createRoot(\n      document.getElementById('react-comp') as HTMLElement\n    )\n\n    root.render(\n      <div>\n        <MyComponent message='이거 에갈앵 안에 있는 리액트 컴포넌트입니다'  />\n      </div>\n    )\n\n  }\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위 코드는 Angular 컴포넌트이며, 컴포넌트 라이프사이클의 ngOnInit 이벤트에서 React 컴포넌트를 렌더링합니다.\n\n그러면 이제 Angular 내에서 React 컴포넌트를 실행할 수 있습니다.\n\n이 글의 자세한 설명을 원하시면 아래 링크를 참조해 주세요.\n\n링크: [https://youtu.be/iI8IMVMrzWc](https://youtu.be/iI8IMVMrzWc)","ogImage":{"url":"/assets/img/2024-06-22-UseReactComponentInsideAngularProject_0.png"},"coverImage":"/assets/img/2024-06-22-UseReactComponentInsideAngularProject_0.png","tag":["Tech"],"readingTime":3},{"title":"2024년 최신 Angular에서 템플릿 기반 폼을 사용하는 방법","description":"","date":"2024-06-22 03:32","slug":"2024-06-22-TemplateDrivenForminAngular","content":"\n\n이 기사에서는 템플릿 폼과 언제 템플릿 드리븐 폼을 사용해야 하는지에 대해 안내하겠습니다.\n\n현실적인 예로 병원을 방문할 때 종이를 받아서 기본 정보를 적어야 하는 상황이나 학교 입학 신청서를 작성해야 하는 상황이 있습니다. 이 정보들은 소프트웨어에 업로드됩니다. 따라서 폼은 본질적으로 정보를 수집하는 종이라고 할 수 있습니다. 기술적 관점에서 Angular는 템플릿 드리븐 폼을 제공하여 사물에 대한 정보를 수집하게 됩니다.\n\n참고: Angular에서 폼을 사용하는 경우에는 AppModule에서 FormModule을 반드시 import해야 합니다.\n\n# 템플릿 드리븐 폼\n\n<div class=\"content-ad\"></div>\n\n- 사용하기 쉽습니다\n- 간단한 시나리오에 적합합니다.\n- 복잡한 시나리오에는 권장하지 않습니다.\n- 구문은 이전 버전의 AngularJS와 유사합니다.\n- 템플릿 기반 폼에 사용되는 구문은 양방향 데이터 바인딩 [(NgModel)]로, 최소한의 컴포넌트 코드를 사용합니다.\n- 폼 및 데이터의 자동 추적(앵귤러에서 처리)\n- 템플릿 유효성 검사는 지시어를 통해 검증됩니다.\n- 템플릿 기반 폼의 단위 테스트는 값 변경과 유효성 검사가 비동기적이라는 문제가 있습니다.\n- 데이터 모델은 구조적이지 않습니다.\n- 템플릿 폼에서의 예측 가능성은 비동기적입니다.\n- 폼 유효성 검사는 필드에 보다 많은 유효성 검사 태그를 추가하거나 복잡한 교차 필드 유효성 검사를 추가할수록 폼의 가독성이 떨어집니다.\n\n# 언제 템플릿 기반 폼을 사용해야 하는가:\n\n로그인과 같이 기본적이고 간단한 요구사항을 갖는 앱에서는 템플릿 기반 폼을 사용해야 합니다.\n\n예제 템플릿 기반 폼\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';        // FormsModule 가져오기\n \nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n \n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    FormsModule                    // Imports 배열에 추가\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n```js\n<form #SingUpForm=\"ngForm\">\n\n// 템플릿에서 변수를 생성합니다. 앵귤러에서는 이를 템플릿 참조 변수라고 합니다\n```\n\n# ngForm이란 무엇인가요?\n\nngForm은 다음을 실행합니다:\n\n\n<div class=\"content-ad\"></div>\n\n- `Form` 지시문에 자체 바인딩\n- 최상위 FormGroup 인스턴스 생성\n- ngModel 지시문이있는 각 자식 컨트롤에 대해 FormControl 인스턴스 생성\n- NgModelGroup 지시문에 대해 각각 FormGroup 인스턴스를 생성\n\n# 템플릿 기반의 FormControl 인스턴스\n\n이들은 firstName, lastName 및 다른 필드입니다. 이들을 formControl 인스턴스에 바인딩해야 합니다. 이는 ngModel 지시문을 사용하여 수행합니다.\n\n```js\n<input type=\"text\" name=\"firstname\" ngModel>\n```\n\n<div class=\"content-ad\"></div>\n\n\n파일을 다음과 같이 수정해주세요. \n\n\n<form #singUpForm=\"ngForm\" (ngSubmit)=\"onSubmit(singUpForm)\">\n \n  <p>\n    <label for=\"firstname\">이름</label>\n    <input type=\"text\" name=\"firstname\" ngModel>\n  </p>\n \n  <p>\n    <label for=\"lastname\">성</label>\n    <input type=\"text\" name=\"lastname\" ngModel>\n  </p>\n \n  <p>\n    <label for=\"email\">이메일</label>\n    <input type=\"text\" id=\"email\" name=\"email\" ngModel>\n  </p>\n \n  <p>\n    <label for=\"gender\">성별</label>\n    <input type=\"radio\" value=\"male\" name=\"gender\" ngModel> 남성\n    <input type=\"radio\" value=\"female\" name=\"gender\" ngModel> 여성\n  </p>\n \n  <p>\n    <label for=\"isMarried\">결혼 여부</label>\n    <input type=\"checkbox\" name=\"isMarried\" ngModel>\n  </p>\n \n  <select name=\"country\" ngModel>\n    <option [ngValue]=\"c.id\" *ngFor=\"let c of countryList\">\n      {c.name}\n    </option>\n  </select>\n \n  <p>\n    <button type=\"submit\">제출</button>\n  </p>\n  \n</form>\n\n\n```typescript\nimport { Component } from '@angular/core';\n \n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = '템플릿 기반 폼';\n \n  countryList:country[] = [\n    new country(\"1\", \"파키스탄\"),\n    new country('2', '아랍에미리트'),\n    new country('3', '미국')\n  ];\n}\n \nexport class country {\n  id:string;\n  name:string;\n \n  constructor(id:string, name:string) {\n    this.id=id;\n    this.name=name;\n  }\n\n onSubmit(contactForm) {\n    console.log(contactForm.value);\n  }\n}\n```\n\n# 내장 검증기\n\n내장 검증기는 필수(required), 최소 길이(minlength), 최대 길이(maxlength), 패턴(pattern)과 같은 HTML5 유효성 검사 속성을 사용합니다. Angular는 이러한 유효성 검사 속성을 해석하고, FormControl 인스턴스에 유효성 검사기 함수를 추가합니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 필수 유효성 검사\n\n필수 유효성 검사는 양식 컨트롤에 비어있지 않은 값이 입력된 경우에만 true를 반환합니다.\n\n# 최소길이 유효성 검사\n\n이 유효성 검사기는 컨트롤 값이 유효성 검사기에 지정된 값보다 적은 수의 문자를 가져서는 안 된다는 것을 요구합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, minlength validator는 사용자 이름 값이 적어도 20자여야 함을 보장합니다.\n\n```js\n<input type=\"text\" id=\"userName\" name=\"userName\" required minlength=\"20\">\n```\n\n# Maxlength Validation\n\n이 Validator는 문자 수가 속성 값 이상으로 초과되지 않아야 함을 요구합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, maxlength 검증기는 사용자 이름 값이 최대 20자까지인지 확인합니다.\n\n```js\n<input type=\"text\" id=\"userName\" name=\"userName\" required maxlength=\"20\">\n```\n\n# 패턴 유효성 검사\n\n이 유효성 검사기는 컨트롤 값이 속성에 제공된 정규식 패턴과 일치해야 함을 요구합니다. 예를 들어, 패턴 ^[a-zA-Z]+$는 문자만 허용됨을 보장합니다 (공백도 허용되지 않음). 이 패턴을 사용자 이름에 적용해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n# 이메일 유효성 검사\n\n이 유효성 검사기는 제어 값이 유효한 이메일 주소여야 함을 요구합니다.\n\n```js\n<input type=\"text\" id=\"email\" name=\"email\" required email>\n```\n\n<div class=\"content-ad\"></div>\n\n# 유효성 스타일링\n\n모델 기반 폼과 유사하게, 우리는 각 모델 폼 컨트롤의 상태에 접근할 수 있습니다. 이를 위해서는 최상위 폼 그룹을 통해 이동해야 합니다.\n\nngForm 지시자는 최상위 FormGroup를 form 속성을 통해 제공하므로, 이메일 필드의 유효성, 수정 여부, 터치 여부를 다음과 같이 표시할 수 있습니다:\n\n```js\n<pre>유효함? {f.form.controls.email?.valid}</pre>\n<pre>수정됨? {f.form.controls.email?.dirty}</pre>\n<pre>터치됨? {f.form.controls.email?.touched}</pre>\n```\n\n<div class=\"content-ad\"></div>\n\n# 엘비스 연산자\n\n? 기호를 엘비스 연산자라고 합니다. 만약 ? 왼쪽에 위치한 속성이 null이 아닌 경우에만 ? 오른쪽에 속성을 호출하려고 시도합니다. 템플릿 기반 형식에서 Angular이 페이지를 빌드할 때 컨트롤이 가끔 null 일 수 있으므로 안전을 위해 엘비스 연산자를 사용합니다.\n\n```js\n<pre>Valid? {f.form.controls.email?.valid}</pre>\n```\n\n# 폼 초기화\n\n<div class=\"content-ad\"></div>\n\n```js\n<form (ngSubmit)=\"onSubmit()\" #myForm=\"ngForm\">\n```\n\n```js\n@ViewChild('myForm') form: any;\n\nonSubmit() {\n  if (this.form.valid) {\n    console.log(\"Form Submitted!\");\n    this.form.reset();\n  }\n}\n```\n\n## NgModelGroup 지시자\n\nngModelGroup 지시자를 사용하면 관련 있는 입력을 그룹화하여 폼에 의해 표현되는 객체를 유용하고 예측 가능한 방식으로 구조화할 수 있습니다. ngModelGroup는 주로 fieldset과 결합하여 사용되는데, 이들은 대부분 \"입력을 그룹화함\"이라는 같은 아이디어를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {Component, ViewChild} from \"@angular/core\";\n@Component({\n    selector: 'app',\n    template: `\n<form \n    #formRef=\"ngForm\" \n    (ngSubmit)=\"onSubmit(formRef.value)\"\n    >\n    <fieldset ngModelGroup=\"login\">\n        <input \n            #usernameRef=\"ngModel\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            type=\"text\"        \n            required\n            minlength=\"3\"\n        >    \n        <div *ngIf=\"usernameRef.errors?.required\">This field is required</div>\n        <div *ngIf=\"usernameRef.errors?.minlength\">This field must be longer than {usernameRef.errors?.minlength.requiredLength} characters. You only typed {usernameRef.errors?.minlength.actualLength}</div>\n        \n        <input type=\"password\" ngModel name=\"password\">\n    </fieldset>\n    <button type=\"submit\">Submit</button>\n</form> \n{formRef.value | json}   \n{formRef.valid | json}   \n\n``` \n\n# 출력\n\n```js \n{ \"login\": { \"username\": \"Zeeshan\", \"password\": \"\" } } true\n```\n\n```js\nimport {Component, ViewChild} from \"@angular/core\";\n@Component({\n    selector: 'app',\n    template: `\n<form \n    #formRef=\"ngForm\" \n    (ngSubmit)=\"onSubmit(formRef.value)\"\n    >\n    <fieldset ngModelGroup=\"login\">\n        <input \n            #usernameRef=\"ngModel\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            type=\"text\"        \n            required\n            minlength=\"3\"\n        >    \n        <div *ngIf=\"usernameRef.errors?.required\">This field is required</div>\n        <div *ngIf=\"usernameRef.errors?.minlength\">This field must be longer than {usernameRef.errors?.minlength.requiredLength} characters. You only typed {usernameRef.errors?.minlength.actualLength}</div>\n        \n        <input type=\"password\" ngModel name=\"password\">\n    </fieldset>\n     <fieldset ngModelGroup=\"signUp\">\n        <input \n            #usernameRef=\"ngModel\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            type=\"text\"        \n            required\n            minlength=\"3\"\n        >    \n        <div *ngIf=\"usernameRef.errors?.required\">This field is required</div>\n        <div *ngIf=\"usernameRef.errors?.minlength\">This field must be longer than {usernameRef.errors?.minlength.requiredLength} characters. You only typed {usernameRef.errors?.minlength.actualLength}</div>\n        \n        <input type=\"password\" ngModel name=\"password\">\n    </fieldset>\n    \n    <button type=\"submit\">Submit</button>\n</form> \n{formRef.value | json}   \n{formRef.valid | json}   \n\n```\n\n\n<div class=\"content-ad\"></div>\n\n# 결과\n\n```js\n{ \"login\": { \"username\": \"Zeeshan\", \"password\": \"\" },\n  \"signUp\": { \"username\": \"Zeeshan\", \"password\": \"\" } } true\n```\n\n# 유효성 검사/오류 메시지 표시\n\nAngular은 각 필드에 적용된 ngModel 지시문을 갖는 각각의 필드에 대해 FormControl을 생성합니다. FormControl은 유효(valid), 변경된(dirty), 터치(touched) 등과 같은 폼 요소의 상태를 노출합니다.\n\n<div class=\"content-ad\"></div>\n\nFormControl에 대한 참조를 얻는 두 가지 방법이 있습니다.\n\n- 하나는 contactForm 변수를 사용하는 방법입니다. myForm.controls.firstname.valid를 사용하여 firstname이 유효한지 확인할 수 있습니다.\n- 다른 방법은 각 FormControl을 위해 새로운 로컬 변수를 만드는 것입니다. 예를 들어 다음과 같이 firstname=\"ngModel\"을 생성하면 firstname 변수에 FormControl 인스턴스가 만들어집니다.\n\n```js\n<input type=\"text\" id=\"firstname\" name=\"firstname\" required minlength=\"10\" \n            #firstname=\"ngModel\">\n```\n\n이제 firstname FormControl 인스턴스에 대한 참조가 있으므로 해당 상태를 확인할 수 있습니다. firstname에 오류가 있는지 확인하기 위해 valid 속성을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n\n<div *ngIf=\"!firstname?.valid && (firstname?.dirty || firstname?.touched)\">\nInvalid First Name\n</div>\n```\n\n# 결론\n\n우리는 템플릿 주도형 폼이 여전히 모델 주도형 폼과 동일한 클래스를 사용하지만 템플릿 주도 접근 방식에서는 모델이 명시적으로 컴포넌트에서 생성되는 것이 아니라 템플릿에서 디렉티브에 의해 생성된다는 것을 배웠습니다.","ogImage":{"url":"/assets/img/2024-06-22-TemplateDrivenForminAngular_0.png"},"coverImage":"/assets/img/2024-06-22-TemplateDrivenForminAngular_0.png","tag":["Tech"],"readingTime":10},{"title":"앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기","description":"","date":"2024-06-22 03:31","slug":"2024-06-22-AngularAnimationsTutorialRouteTransitions","content":"\n\n만약 라우팅을 갖춘 Angular 애플리케이션을 다룬 적이 있다면, 루트 간 이동 시에 트랜지션을 추가하고 싶었을 것입니다. 이렇게 하면 애플리케이션이 전체적으로 더 우아해 보입니다. 알고 계셨나요? Animation 모듈을 이용하면 이를 쉽게 구현할 수 있습니다. 이번 예제에서 그 방법을 보여드리겠습니다. 그럼 시작해봅시다.\n\n# 시작하기 전에\n\n자, 그러기 전에 너무 멀리 나가기 전에 Angular의 애니메이션 프레임워크에 중점을 둔 다수의 포스트를 이미 만들었다는 것을 기억하는 것이 중요합니다.\n\n## Angular 애니메이션 자습서:\n\n<div class=\"content-ad\"></div>\n\n- 기초 학습\n- 입장 및 퇴장 애니메이션\n- Keyframes 기능\n- 쿼리 및 Stagger 함수\n- 시작 및 완료 이벤트\n- 병렬 애니메이션\n- 알 수 없는 높이로 애니메이션 설정하기\n- 매개변수로 유연성 추가\n- 재사용 가능한 애니메이션 생성\n- 애니메이션 비활성화 및 활성화\n\n위 포스트들은 다양한 애니메이션 주제를 다루고 있습니다. 따라서 이 중 어떤 개념이 익숙하지 않다면, 이 포스트들을 먼저 확인해보는 것이 좋습니다. 그렇지 않으면 이 예제에서 헤맬 수 있습니다.\n\n그리고, 이것들을 쉽게 찾을 수 있도록 우리는 Angular Animation 재생 목록을 YouTube 채널에서 만들었으니 확인해보세요!\n\n좋아요, 충분하니까, 이제 이 포스트의 예제로 넘어가 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 데모 애플리케이션\n\n이 예제에서는 이 간단한 데모 애플리케이션을 사용할 것입니다. 이동할 수 있는 몇 가지 다른 페이지가 있습니다. 주 메뉴에서 링크를 클릭하면 해당 페이지로 이동됩니다. \n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*wysR9eAe-EwO7yxd.gif)\n\n하지만 서로 다른 페이지로 이동할 때 전환 효과가 있는 것이 더 좋을 것입니다. 여기서 보는 것처럼 횡단페이드 효과나 다른 효과가 있으면 좋을 것 같습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*-Szw6y8W09ki2NN9.gif)\n\n요번 예제에서 우리가 할 일이 바로 이것입니다. 하지만 먼저, 필요한 내용을 더 잘 이해하기 위해 기존 코드를 살펴보겠습니다.\n\n# 기존 코드\n\n그래, 언급했듯이, 이 앱은 이미 라우팅이 설정되어 있습니다. 따라서, 앱 컴포넌트를 살펴보면 템플릿에 router-outlet이 있다는 것을 알 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## main.ts\n\n```js\n@Component({\n    selector: 'app-root',\n    template: `\n        <app-nav></app-nav>\n        <router-outlet></router-outlet>\n    `,\n    ...\n})\nexport class App {\n}\n```\n\n내비게이션 구성 요소의 링크 중 하나를 클릭하면 라우트된 구성 요소가 router-outlet 요소의 형제로 삽입됩니다. 라우트 구성을 살펴보면, 주소 표시줄에서 볼 경로와 해당 경로로 이동할 때 표시하려는 구성 요소를 모두 제공한 곳입니다.\n\n따라서 예를 들어 \"blog\" 경로로 이동하면 BlogComponent가 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n    path: 'blog',\n    component: BlogComponent,\n    title: '우리 블로그',\n}\n```\n\n또는 \"contact\" 경로로 이동하면 ContactComponent가 표시됩니다.\n\n```js\n{\n    path: 'contact',\n    component: ContactComponent,\n    title: '문의하기',\n}\n```\n\n이해하셨죠? 새 경로의 활성 컴포넌트는 Angular 애니메이션 측면에서 \"입력\" 항목으로 간주됩니다. 그리고 이전 경로의 컴포넌트는 \"떠나는\" 항목으로 간주됩니다. 이것은 두 개를 모두 애니메이션화하는 방법을 갖게 될 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 \"입장\" 및 \"퇴장\" 애니메이션 개념이 익숙하지 않다면, 여기에 비디오가 있으니 꼭 확인해보세요. 개념을 더 잘 이해할 수 있습니다.\n\n# 라우트 전환 애니메이션 만들기\n\n자, 지금까지 모든 작업 방식에 대한 이해가 되었으니, 이제 애니메이션을 만드는 것부터 시작해봅시다. 이를 위해 애니메이션 코드를 추가하는 새 파일을 만들어야 합니다. \"route-transition.ts\" 라고 이름 짓겠습니다.\n\n이제 내보낼 수 있는 상수를 추가해야 합니다. 앱 구성 요소에이 애니메이션을 가져올 수 있도록 하기 위해 \"route-transition.ts\"라고 이름 짓습니다. 상수의 이름은 \"routeTransition\"으로 지정해보겠습니다. 우리는 Angular 애니메이션 모듈에서 trigger() 함수를 사용하여 이를 설정할 것입니다. 이름으로도 routeTransition으로 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## route-transition.ts\n\n```js\nimport { trigger } from '@angular/animations';\n\nexport const routeTransition = trigger('routeTransition', [\n]);\n```\n\n그 다음, transition() 함수가 필요합니다. 이 라우트 전환에서는 라우트 데이터 변경 시마다 실행되길 원할 것입니다. 따라서 별표(*)가 있는 모든 상태에서 다른 상태로 애니메이션을 적용할 것입니다.\n\n```js\nimport { ..., transition } from '@angular/animations';\n\nexport const routeTransition = trigger('routeTransition', [\n    transition('* => *', [\n    ])\n]);\n```\n\n<div class=\"content-ad\"></div>\n\n이제 이 애니메이션에서 처음 할 일은 항목이 \"숨겨진\" 상태에서 시작하도록 설정하는 것입니다. 그러니까, entering 컴포넌트를 쿼리하기 위해 query() 함수를 추가해봐요. 그런 다음 시작 스타일을 제공할 수 있도록 style() 함수를 추가할 거에요. 우리는 불투명도가 0이고 크기가 0.9인 상태로 시작할 거에요. 마지막으로 해야 할 일은 entering 항목을 찾지 못했을 때의 선택적 플래그를 추가하는 것이에요.\n\n```js\nimport { ..., query, style } from '@angular/animations';\n\nexport const routeTransition = trigger('routeTransition', [\n    transition('* => *', [\n        query(':enter', [\n            style({ opacity: 0, scale: 0.9 }),\n        ], { optional: true })\n    ])\n]);\n```\n\n그렇죠, 다음은 leaving 컴포넌트를 전환할거에요. 그래서 떠나는 항목을 쿼리하기 위해 또 다른 query() 함수를 추가해봅시다.\n\n이 항목의 경우 시작 스타일이 필요하지 않습니다. 왜냐하면 자동적으로 완전히 불투명하고 전체 크기로 시작하거든요. 우리가 해야 할 일은 애니메이션을 추가해서 animate() 함수를 추가하는 것이에요. 이 애니메이션을 정말로 볼 수 있도록 하기 위해 우리는 일 초 동안 애니메이션을 수행하도록 설정할 거에요. 그런 다음 애니메이션 효과를 줄 스타일을 추가하기 위해 다른 style() 함수를 사용하도록 해봅시다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nexport const routeTransition = trigger('routeTransition', [\n    transition('* => *', [\n        ...,\n        query(':enter', [\n            animate('1s', style({ opacity: 1, scale: 1 }))\n        ], { optional: true })\n    ])\n]);\n```\n\n자, 애니메이션에 필요한 모든 것을 추가했습니다. 이제 전환하여 앱 컴포넌트에 추가할 수 있습니다.\n\n# 부모 컴포넌트에 라우트 전환 애니메이션 추가\n\n애니메이션을 사용하려면 먼저 컴포넌트 메타데이터에 애니메이션 배열을 추가해야 합니다. 이 배열 내에서 새 \"routeTransition\" 애니메이션을 추가해보세요.\n\n<div class=\"content-ad\"></div>\n\n## main.ts\n\n```js\nimport { routeTransition } from './route-transition';\n\n@Component({\n    selector: 'app-root',\n    ...,\n    animations: [\n        routeTransition\n    ]\n})\nexport class App {\n}\n```\n\n그럼, 이제 이것을 연결할 수 있습니다. 그전에 이 레이아웃이 어떻게 작동하는지 이해하는 것이 중요합니다. 그리드를 사용합니다. 첫 번째 열은 내비게이션을 위한 것이고, 두 번째 열은 라우트된 컴포넌트를 위한 것입니다. router-outlet의 형제인 모든 것은 두 번째 그리드 열에 배치됩니다. 즉, 들어오고 나가는 항목 모두 이 열 안에 서로 겹쳐 있습니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/0*MTj1pIyBHdnErdu5.gif\" />\n\n<div class=\"content-ad\"></div>\n\n안타깝게도 여기서 해야할 일이 라우터 출력 주위에 컨테이너를 추가하는 것입니다. 애니메이션을 제대로 연결하려면 들어오고 나가는 항목을 쿼리할 수 있어야 하기 때문입니다.\n\n하지만 걱정하지 마세요. display: contents로 설정하여 사실상 보이지 않도록 만들 수 있습니다. 그래서, div를 추가하고 이 div에 display, contents 스타일을 추가합시다.\n\n```js\n<div style=\"display: contents\">\n    <router-outlet></router-outlet>\n</div>\n```\n\n그래서 여기가 우리가 애니메이션 트리거를 바인딩할 곳이며, 어떤 것에 바인딩하여 경로를 변경할 때 트리거할 것인가요?\n\n<div class=\"content-ad\"></div>\n\n# 경로 전환을 트리거하는 방법\n\n루트를 변경할 때 활성 라우트의 스냅샷 데이터 개체를 사용할 수 있습니다.\n\n이를 위해 생성자를 추가해야 합니다. 그런 다음 ActivatedRoute를 주입해야 합니다. \"route\"라는 이름의 보호된 필드를 만들고 ActivatedRoute 클래스에 주입해야 합니다.\n\n```js\nimport { ..., ActivatedRoute } from '@angular/router';\n\n@Component({\n    selector: 'app-root',\n    ...\n})\nexport class App {\n    constructor(protected route: ActivatedRoute) {\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 애니메이션 트리거를 div에 바인딩해봅시다. route, snapshot, data 객체에 바인딩할 거에요. 이 객체는 route가 변경될 때마다 업데이트되니 우리 애니메이션을 제대로 트리거하게 될 거에요.\n\n```js\n<div [@routeTransition]=\"route.snapshot.data\" style=\"display: contents\">\n    <router-outlet></router-outlet>\n</div>\n```\n\n좋아요, 거의 다 왔어요. 이 애니메이션이 작동하려면 providers 배열에 provideAnimations() 함수를 추가하여 애니메이션을 활성화해야 합니다.\n\n```js\nimport { provideAnimations } from '@angular/platform-browser/animations';\n\nbootstrapApplication(App, {\n    providers: [ \n        ...,\n        provideAnimations()\n    ]\n});\n```\n\n<div class=\"content-ad\"></div>\n\n좋아요, 이제 라우트 간에 전환할 때 필요한 모든 것이 준비되었어요. 이제 저장하고 시도해봅시다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*ZC_28tRmHkrNc482.gif)\n\n좋아요, 나가는 구성 요소와 들어오는 구성 요소를 모두 제대로 애니메이션화하는 것 같아요. 이제 조금 이상해 보이죠, 주로 얼마나 느리게 애니메이션되는지 때문에요. 기억하시죠, 나가는 항목에 1초간, 들어오는 항목에 또 1초간 애니메이션을 주고 있어요. 이것은 이러한 유형의 전환에 대해 꽤 느린 속도에요. 하지만 이 애니메이션이 어떻게 작동하는지 제시하고 싶었어요.\n\n이제 작동하는 것을 볼 수 있고, 그것을 이해했으니, 0.2초와 같이 짧은 기간으로 전환해봅시다.\n\n<div class=\"content-ad\"></div>\n\n## route-transition.ts\n\n```js\n    export const routeTransition = trigger('routeTransition', [\n        transition('* => *', [\n            ...,\n            query(':leave', [\n                animate('0.2s', ...)\n            ], ...),\n            query(':enter', [\n                animate('0.2s', ...)\n            ], ...)\n        ])\n    ]);\n```\n\n이제 저장하고 다시 시도해 보세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*FyBZwrhqsmy4Y9XB.gif)\n\n<div class=\"content-ad\"></div>\n\n잘 했어요!\n\n# 결론\n\n물론, 이러한 종류의 애니메이션을 만드는 다양한 방법이 있습니다. 이제 Angular 애플리케이션에 라우트 전환을 추가하기 위해 필요한 모든 것을 알았으니, 상상력만이 당신을 막는 것일 뿐입니다.\n\n아직도 Angular 애니메이션에 대해 다룰 내용이 많이 남아 있지만, 여기까지 하겠습니다. 앞으로 미래의 게시물을 계속 주시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n# 실제로 보고 싶으세요?\n\nStackblitz 예시에서 이 기술들의 데모 코드와 예시를 확인해보세요. 궁금한 점이나 생각이 있으시면 언제든 댓글을 남겨주세요.\n\n# 이 내용 중에 도움이 되는 것이 있으셨나요?\n\n만약 도움이 되는 내용이 있다면, 사랑을 표현해주고 싶다면 언제든 커피 한 잔 사주세요!\n\n<div class=\"content-ad\"></div>\n\n원래 2024년 6월 13일에 https://briantree.se에서 게시된 내용입니다.","ogImage":{"url":"/assets/img/2024-06-22-AngularAnimationsTutorialRouteTransitions_0.png"},"coverImage":"/assets/img/2024-06-22-AngularAnimationsTutorialRouteTransitions_0.png","tag":["Tech"],"readingTime":8},{"title":"아답터 디자인 패턴을 Angular에서 사용하는 방법","description":"","date":"2024-06-22 03:29","slug":"2024-06-22-DesignPatternsAdapterinAngular","content":"\n\n구조 패턴은 클래스와 객체를 더 큰 구조로 결합하는 방법을 설명합니다.\n\n구조 디자인 패턴에는 다음이 포함됩니다:\n1. 어댑터\n2. 컴포지트\n3. 프록시\n4. 플라이웨이트\n5. 퍼사드\n6. 브릿지\n7. 데코레이터\n\n어댑터 패턴은 한 클래스의 인터페이스를 클라이언트가 기대하는 인터페이스로 적응시킵니다. 이를 통해 그렇지 않았을 때 호환되지 않을 클래스 간의 협력이 가능해집니다. 이는 관련 없는 클래스끼리 협력할 수 있게 합니다.\n\nAdapter 패턴을 구현하는 두 가지 방법이 있습니다:\n- extends\n- 합성\n\n<div class=\"content-ad\"></div>\n\n양쪽 경우 모두 예제로 설명하는 것이 가장 쉬울 것입니다.\n\n만약 전체 데모를 보고 싶다면, 제 데모 프로젝트를 확인해보세요.\n\n## 확장\n\n첫 번째 경우에는 부적절한 인터페이스를 가진 클래스에 파생 클래스를 배치하고 원하는 기능을 얻기 위해 해당 클래스에 메서드를 추가하는 방식으로 원하는 기능을 얻습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, AdapterComponent 예제 구성 요소에서 TableComponent 구성 요소를 배치합니다.\n\n아래에는 두 그룹의 버튼이 있습니다. 첫 번째 그룹인 Status에는 Status 열에 해당하는 값을 선택하는 라디오 버튼과 드롭다운 목록이 포함되어 있습니다. 두 번째 그룹인 Type 버튼에는 Type 열에 해당하는 값을 선택하는 라디오 버튼과 드롭다운 목록이 포함되어 있습니다. 아래는 AdapterComponent 구성 요소 템플릿입니다:\n\n```js\n<div>\n    <div>\n        <app-table [items]=\"currentTasks()\" />\n    </div>\n\n    <div>\n        <app-radio [name]=\"'filter'\" \n                   [value]=\"FilterColumn.status\" \n                   [label]=\"'Status'\" [isChecked]=\"true\"\n            (selectedValue)=\"onRadioSelectionChange($event)\" />\n\n        <app-select-dropdown \n            *ngIf=\"configFilter.filterKey === FilterColumn.status\" \n            [keys]=\"statusKeys\"\n            [values]=\"statusValues\" \n            [selectedValue]=\"configFilter.statusValue\"\n            (selectionChange)=\"ngModelChangeFilterValue( FilterColumn.status, configFilter.statusValue = $event)\" />\n    </div>\n\n    <div>\n        <app-radio [name]=\"'filter'\" \n                   [value]=\"FilterColumn.type\" \n                   [label]=\"'Type'\" [isChecked]=\"false\"\n            (selectedValue)=\"onRadioSelectionChange($event)\" />\n\n        <app-select-dropdown \n            *ngIf=\"configFilter.filterKey === FilterColumn.type\" \n            [keys]=\"typesKeys\"\n            [values]=\"typesValues\" \n            [selectedValue]=\"configFilter.typeValue\"\n            (selectionChange)=\"ngModelChangeFilterValue(FilterColumn.type, configFilter.typeValue = $event )\" />\n    </div>\n</div>\n```\n\nTableComponent 구성 요소의 내용을 보여주는 클래스, 템플릿 및 스타일이 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-table', \n  template: `\n  <table>\n    <thead>\n        <th *ngFor=\"let column of columns\">{ column }</th>\n    </thead>\n    <tbody>\n        @for (item of items; track item.id;) {\n        <tr>\n            <td *ngFor=\"let column of columns\">\n                <ng-container [ngSwitch]=\"column\">\n                    <span *ngSwitchCase=\"'status'\">{ item[column] | status }</span>\n                    <span *ngSwitchCase=\"'type'\">{ item[column] | types }</span>\n                    <span *ngSwitchDefault>{ item[column] }</span>\n                </ng-container>\n            </td>\n        </tr>\n        }\n    </tbody>\n  </table>`,\n    styles:[`\n    table { border-collapse: collapse; }\n    th, td { \n      border: 1px solid black; \n      padding: 8px; }\n    th { background-color: #f2f2f2; }`]\n})\nexport class TableComponent {\n  @Input() items: any[] = [];\n  columns: string[] = [];\n\n  ngOnInit() {\n    if (this.items.length > 0) {\n      this.columns = Object.keys(this.items[0]);\n    }\n  }\n}\n```\n\n라디오 버튼을 구현해야 하는데, 선택한 값을 위한 드롭다운 목록의 가시성을 토글하는 기능을 AdapterComponent 구성 요소에 구현해야 합니다. 재사용 가능한 컴포넌트를 구현하는 것이 가장 좋은 접근 방식입니다. 아래는 재사용 가능한 컴포넌트 RadioComponent의 제안된 구현입니다:\n\n```js\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { FilterColumn } from '../../model/model';\n\n@Component({\n  selector: 'app-radio',\n  template: ` \n  <label>\n    <input \n        type=\"radio\" \n        name=\"{name}\" \n        value=\"{value}\" \n        (change)=\"onSelectionChange()\" \n        [checked]=\"isChecked\">\n    { label }\n  </label>`,\n})\nexport class RadioComponent {\n\n  @Input() name: string = '';\n  @Input() value!: FilterColumn;\n  @Input() label: string = '';\n  @Input() isChecked: boolean = false;\n  @Output() selectedValue = new EventEmitter<FilterColumn>();\n\n  onSelectionChange() {\n    this.selectedValue.emit(this.value);\n  }\n}\n```\n\n값 선택 드롭다운 목록을 위한 재사용 가능한 컴포넌트는 아래와 같습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-select-dropdown',\n  template: `\n  <select [(ngModel)]=\"selectedValue\" (ngModelChange)=\"onSelectionChange()\">\n    <option *ngFor=\"let key of keys\" [value]=\"key\">{ values[key] }</option>\n  </select>`\n})\nexport class SelectDropdownComponent {\n  @Input() keys: number[] = [];\n  @Input() values: Record<number, string> = {};\n  @Input() selectedValue: number | null = null;\n  @Output() selectionChange: EventEmitter<number> = new EventEmitter<number>();\n\n  onSelectionChange() {\n    this.selectionChange.emit(Number(this.selectedValue!));\n  }\n}\n```\n\nTasks 테이블에 대한 인터페이스 모델 및 우리가 집중할 값 선택을 위한 드롭다운 목록은 아래에 위치해 있습니다:\n\n```js\nexport interface Tasks {\n  readonly id: number;\n  readonly name: string;\n  readonly status: StatusKey;\n  readonly type: TypesKey;\n  readonly description: string;\n}\n\nexport const Status: Record<number, string> = {\n  1: 'done',\n  2: 'during',\n  3: 'not performed',\n};\n\nexport type StatusKey = keyof typeof Status;\n\nexport type TaskTypes = {\n  [key: number]: string;\n};\n\nexport const Types: TaskTypes = {\n  1: 'Urgent',\n  2: 'Important',\n  3: 'Routine',\n  4: 'Extra',\n  5: 'Training',\n};\n\nexport type TypesKey = keyof typeof Types;\n\nexport enum FilterColumn {\n  status = 'status',\n  type = 'type',\n}\n```\n\nTasks 테이블의 현재 데이터는 주입된 DataService 서비스 내에 위치한 getCurrentTasks() 메서드를 사용하여 가져옵니다. 여기서 객체 배열의 값은 Signals로 래핑됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n변경된 테이블 태그를 마크다운 형식으로 바꿨습니다.\n\n<div class=\"content-ad\"></div>\n\n표, 라디오 버튼 및 드롭다운 목록은 서로 통신하지 않습니다. 비록 라디오 버튼과 드롭다운 목록이 표의 요소를 포함하고 있지만요. 라디오 버튼 Status 및 Type은 표의 열 이름과 대응됩니다. 드롭다운 목록에는 필터링에 사용할 수 있는 열의 요소가 포함되어 있습니다. 이러한 요소들 간의 통신은 필터 메서드를 구현하여 수행할 수 있습니다:\n\n```js\nimport { FilterColumn, Tasks } from '../../common/model/model';\n\nexport interface SingleColumnFilterable<T> {\n    filterBySingleColumn(tasks: T[], column: keyof T, value: number): T[];\n}\n\nexport class SingleColumnFilter implements SingleColumnFilterable<Tasks> {\n    filterBySingleColumn(tasks: Tasks[], column: keyof typeof FilterColumn, value: number): Tasks[] {\n        const filteredTasks = tasks.filter(task => task[column] == value);\n        return filteredTasks;\n    }\n}\n```\n\n먼저, filterBySingleColumn 필터링 기능의 정의를 포함하는 SingleColumnFilterable 인터페이스를 구현합니다. 해당 함수는 매우 일반적이므로 SingleColumnFilterable 인터페이스는 다른 클래스에서 사용할 수 있습니다. filterBySingleColumn 메서드에는 열 이름 및 Tasks[] 개체 배열을 필터링하는 값을 포함하는 매개변수가 있습니다. 필터 값에 기반하여 필터링된 개체 배열을 반환합니다.\n\n이 기능이 우리의 어댑터입니다. 지정된 인터페이스를 가진 개체 배열을 가져와 지정된 매개변수에 기반한 개체 배열을 반환합니다. \n어댑터 함수는 데이터를 필터링할 필요는 없지만, 작업을 수행하거나 변환하는 등의 작업을 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n`filterBySingleColumn` 함수는 `SingleColumnFilter` 클래스를 확장한 `AdapterComponent` 클래스에서 사용됩니다. `filterBySingleColumn` 함수는 재사용 가능한 `SelectDropdownComponent`의 `ngModelChangeFilterValue` 메서드 내에 있습니다. 이 함수의 결과는 `DataService`로 전달됩니다. 서비스는 Signal을 사용하여 Tasks 객체의 배열을 업데이트하고 현재 Tasks 객체의 배열을 AdapterComponent로 전달합니다. 아래는 AdapterComponent의 구현입니다:\n\n```js\nimport { Component, Inject, Signal, inject } from '@angular/core';\nimport { Status, Tasks, StatusKey, TypesKey, Types, FilterColumn } from '../../../common/model/model';\nimport { DataService } from '../../../common/service/data.service';\nimport { SingleColumnFilter,  } from '../../common/task-manager';\nimport { tasks } from '../../../common/service/data';\n\nexport interface FilterConfiguration {\n  filterKey: FilterColumn;\n  statusValue: keyof typeof Status | 0,\n  typeValue: keyof typeof Types | 0;\n}\n\n@Component({\n  selector: 'app-adapter',\n  templateUrl: './adapter.component.html',\n  styleUrl: './adapter.component.scss'\n})\nexport class AdapterComponent extends SingleColumnFilter {\n  private dataService = inject(DataService);\n  startupConfiguration: FilterColumn = FilterColumn.status;\n  FilterColumn = FilterColumn;\n  configFilter: FilterConfiguration = {\n    filterKey: this.startupConfiguration,\n    statusValue: 0,\n    typeValue: 0\n  }\n\n  statusKeys: StatusKey[] = Object.keys(Status).map(Number) as StatusKey[];\n  statusValues = Status;\n\n  typesKeys: TypesKey[] = Object.keys(Types).map(Number) as TypesKey[];\n  typesValues = Types;\n\n  protected currentTasks: Signal<Tasks[]> = this.dataService.getCurrentTasks();\n\n  constructor() {\n    super()\n  }\n\n  onRadioSelectionChange(selectedValue: FilterColumn) {\n\n    selectedValue === FilterColumn.type ? this.configFilter.statusValue = 0 : this.configFilter.typeValue = 0\n    if (this.configFilter.statusValue === 0 && this.configFilter.typeValue === 0) {\n      this.dataService.updateTasks(tasks);\n    }\n    this.configFilter.filterKey = selectedValue\n  }\n\n  ngModelChangeFilterValue(typeFilter: keyof typeof FilterColumn, val: number) {\n\n    const filteredTasks = this.filterBySingleColumn(tasks, typeFilter, Number(val));\n    this.dataService.updateTasks(filteredTasks);\n  }\n}\n```\n\n## 조합\n\n두 번째 경우에는 조합의 사용은 기존 클래스를 구성 요소로 포함하는 새 클래스의 객체를 생성하는 것을 의미합니다. 예를 들어, 드롭다운 리스트는 Tasks 객체의 배열 요소를 포함하는 새 클래스의 객체를 생성합니다. 두 개의 드롭다운 리스트가 함께 배열을 필터링하도록 하는 예시를 구현해봅시다. Status 또는 Type 드롭다운 리스트에서 값을 선택하면 Tasks 테이블이 필터링됩니다. 그러므로, 필터링할 column 이름과 마지막으로 선택된 값을 매개변수로 하는 ngModelChangeFilter 메서드를 생성해 봅시다.\n\n<div class=\"content-ad\"></div>\n\nAdapterComponent 컴포넌트의 템플릿은 현재 다음과 같습니다:\n\n```js\n<div>\n    <div>\n        <app-table [items]=\"currentTasks()\" />\n    </div>\n\n    <div>\n\n        <app-radio [name]=\"'filter'\" \n                   [value]=\"FilterColumn.status\" \n                   [label]=\"'Status'\" \n                   [isChecked]=\"true\"\n            (selectedValue)=\"onRadioSelectionChange($event)\" />\n\n        <app-select-dropdown \n            *ngIf=\"configFilter.filterKey === FilterColumn.status\" \n            [keys]=\"statusKeys\"\n            [values]=\"statusValues\" \n            [selectedValue]=\"configFilter.statusValue\"\n            (selectionChange)=\"ngModelChangeFilterValue( FilterColumn.status, configFilter.statusValue = $event)\" />\n\n    </div>\n    <div>\n\n        <app-radio [name]=\"'filter'\" \n                   [value]=\"FilterColumn.type\" \n                   [label]=\"'Type'\" \n                   [isChecked]=\"false\"\n            (selectedValue)=\"onRadioSelectionChange($event)\" />\n\n        <app-select-dropdown \n            *ngIf=\"configFilter.filterKey === FilterColumn.type\" \n            [keys]=\"typesKeys\"\n            [values]=\"typesValues\" \n            [selectedValue]=\"configFilter.typeValue\"\n            (selectionChange)=\"ngModelChangeFilterValue(FilterColumn.type, configFilter.typeValue = $event )\" />\n\n    </div>\n</div>\n<hr>\n<div>\n    <div>\n        <app-table [items]=\"currentTasks()\" />\n    </div>\n\n    <div>\n        <app-select-dropdown [keys]=\"statusKeys\" \n            [values]=\"statusValues\" \n            [selectedValue]=\"configFilter.statusValue\"\n            (selectionChange)=\"ngModelChangeFilter(configFilter.filterKey = FilterColumn.status, configFilter.statusValue = $event)\" />\n\n\n        <app-select-dropdown [keys]=\"typesKeys\" \n            [values]=\"typesValues\" \n            [selectedValue]=\"configFilter.typeValue\"\n            (selectionChange)=\"ngModelChangeFilter(configFilter.filterKey = FilterColumn.type, configFilter.typeValue = $event)\" />\n    </div>\n\n</div>\n```\n\n컴포넌트의 AdapterComponent 클래스:\n\n```js\nimport { Component, Signal, inject } from '@angular/core';\nimport { Status, Tasks, StatusKey, TypesKey, Types, FilterColumn } from '../../../common/model/model';\nimport { DataService } from '../../../common/service/data.service';\nimport { SingleColumnFilter, DoubleColumnFilter } from '../../common/task-manager';\nimport { tasks } from '../../../common/service/data';\n\n\nexport interface FilterConfiguration {\n  filterKey: FilterColumn;\n  statusValue: keyof typeof Status | 0,\n  typeValue: keyof typeof Types | 0;\n}\n\n\n@Component({\n  selector: 'app-adapter',\n  templateUrl: './adapter.component.html',\n  styleUrl: './adapter.component.scss'\n})\nexport class AdapterComponent extends SingleColumnFilter {\n  private dataService = inject(DataService);\n  startupConfiguration: FilterColumn = FilterColumn.status;\n  FilterColumn = FilterColumn;\n  configFilter: FilterConfiguration = {\n    filterKey: this.startupConfiguration,\n    statusValue: 0,\n    typeValue: 0\n  }\n\n  statusKeys: StatusKey[] = Object.keys(Status).map(Number) as StatusKey[];\n  statusValues = Status;\n\n  typesKeys: TypesKey[] = Object.keys(Types).map(Number) as TypesKey[];\n  typesValues = Types;\n\n  protected currentTasks: Signal<Tasks[]> = this.dataService.getCurrentTasks();\n\n  constructor() {\n    super()\n  }\n\n  ngModelChangeFilter(typeSort: FilterColumn, val: number) {\n\n    const data = new DoubleColumnFilter(tasks)\n    const filteredTasks = data.filterByBothColumns(this.configFilter.statusValue, this.configFilter.typeValue)\n\n    this.dataService.updateTasks(filteredTasks);\n  }\n\n  onRadioSelectionChange(selectedValue: FilterColumn) {\n\n    selectedValue === FilterColumn.type ? this.configFilter.statusValue = 0 : this.configFilter.typeValue = 0\n    if (this.configFilter.statusValue === 0 && this.configFilter.typeValue === 0) {\n      this.dataService.updateTasks(tasks);\n    }\n    this.configFilter.filterKey = selectedValue\n  }\n\n  ngModelChangeFilterValue(typeFilter: keyof typeof FilterColumn, val: number) {\n\n    const filteredTasks = this.filterBySingleColumn(tasks, typeFilter, Number(val));\n    this.dataService.updateTasks(filteredTasks);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nngModelChangeFilter 메소드에는 DoubleColumnFilter 클래스의 객체가 포함되어 있습니다. DoubleColumnFilter 클래스의 매개변수는 tasks 객체의 배열을 전달합니다. 따라서 DoubleColumnFilter 클래스는 생성자에서 Tasks 객체의 배열을 받습니다. DoubleColumnFilter 클래스는 DoubleColumnFilterable 인터페이스를 구현합니다. 아래는 DoubleColumnFilter 클래스와 DoubleColumnFilterable 인터페이스의 구현 내용입니다:\n\n```js\nimport { StatusKey, Tasks, TypesKey } from '../../common/model/model';\n\nexport interface DoubleColumnFilterable<T> {\n    filterByBothColumns(status: StatusKey | 0, type: TypesKey | 0): T[];\n}\n\nexport class DoubleColumnFilter implements DoubleColumnFilterable<Tasks> {\n    constructor(private tasks: Tasks[]) {}\n    \n    filterByBothColumns(status: StatusKey | 0, type: TypesKey | 0): Tasks[] {\n    \n        return this.tasks.filter(task => {\n            const statusMatches = status !== 0 ? task.status === status : true;\n            const typeMatches = type !== 0 ? task.type === type : true;\n            return statusMatches && typeMatches;\n        });\n    }\n}\n```\n\n필터링된 결과는 DataService 서비스의 updateTasks 메소드로 전달됩니다. updateTasks 메소드는 Tasks 객체의 배열을 업데이트합니다.\n\n생성자에 객체 배열을 주입하는 것은 정확히 합성입니다. 즉, 두 가지 추상화가 사용하는 것입니다. 이 경우에는 서로 다른 값과 서로 다른 열을 필터링하는 두 개의 드롭다운 목록이 추상화입니다. 그러나 둘 다 동일한 Tasks 객체 배열을 기반으로 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 요약\n\n어댑터 패턴은 응용 프로그램 내의 다른 인터페이스 간의 상호 운용성을 제공하는 특정 기능을 수행하는 추상화입니다.\n\n디자인 패턴의 전반적인 개념을 갖고 보면, 어댑터 패턴은 Liskov 대체 원칙(Liskov Substitution Principle, LSP) 및 단일 책임 원칙(Single Responsibility Principle, SRP)을 준수한다는 것이 분명합니다. LSP에서는 하위 클래스가 기본 클래스의 기능을 확장하면서 원래 동작을 변경하지 않습니다. SRP는 클래스를 작은 단위로 나누어 각각이 단일 기능을 수행하도록 하는 것을 포함합니다.","ogImage":{"url":"/assets/img/2024-06-22-DesignPatternsAdapterinAngular_0.png"},"coverImage":"/assets/img/2024-06-22-DesignPatternsAdapterinAngular_0.png","tag":["Tech"],"readingTime":15},{"title":"타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법","description":"","date":"2024-06-22 03:26","slug":"2024-06-22-ExpressErrorHandlingLikeaProusingTypescript","content":"\n\n![2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0](/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png)\n\n# 소개\n\nExpress는 Node.js를 위한 인기 있는 서버 프레임워크로, 웹 애플리케이션과 API를 만드는 프로세스를 간단히하는 데 사용됩니다.\n\nExpress는 강력하고 유연한 환경을 제공하여 웹 애플리케이션을 구축하는 데 도움이 되지만, 배포 환경으로 사용할 때 신뢰성, 유지 보수성 및 보안을 보장하기 위해 개발자가 주의해야 할 에러 핸들링이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n잘 구조화된 오류 처리 메커니즘은 예기치 못한 충돌을 방지하고 보안 취약점을 노출시키지 않으며, 무언가 잘못되었을 때 의미 있는 오류 메시지를 제공하여 사용자 경험을 향상시킬 수 있습니다. 우리는 Typescript를 사용하여 응용 프로그램에서 오류 처리를 실제로 개선하기 위한 강력한 도구인 이유를 살펴볼 것입니다. 이 기사에서는 프로덕션용 Express 애플리케이션에서 오류를 효과적으로 처리하기 위한 몇 가지 최상의 방법론과 전략을 탐색할 것입니다.\n\n다음 섹션에서 예시 Express 서버를 설정하는 것으로 시작하겠습니다!\n\n# Express 서버 설정\n\n이 기사에서는 Express 서버가 포함된 시작 프로젝트 템플릿을 준비했습니다. 해당 레포지토리에서 프로젝트를 복제할 수 있습니다. 프로젝트를 다운로드한 후, 다음 명령을 실행하여 모든 종속성을 설치하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\ncd express-error-handling && npm install\n```\n\n이제 프로젝트 구조를 살펴보겠습니다:\n\n![프로젝트 구조](/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_1.png)\n\n서버는 index.ts에서 8000 포트에서 시작되어 듣고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/** src/index.ts **/\n\nimport app from \"./app\";\n\nconst initServer = async () => {\n  app.listen(8000, () => {\n    console.log(`Listening on port ${8000}`);\n  });\n}\n\ninitServer();\n```\n\nExpress 서버의 모든 설정은 아래와 같이 app.ts 내에서 수행됩니다:\n\n```js\n/** src/app.ts **/\n\n// 전역 의존성\nimport express from \"express\";\nimport { json } from \"body-parser\";\n\n// 프로젝트 의존성\nimport userRouter from \"./routes/users\";\n\n// Express 초기화\nconst app = express();\n\n// 미들웨어\napp.use(json());\n\n// 라우터\napp.use(userRouter);\n\nexport default app;\n```\n\n이 예제 서버에서는 routes/users.ts에 위치한 하나의 엔드포인트가 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n/** src/routes/users.ts **/\n\nimport { Request, Response, Router } from \"express\";\n\nconst router = Router();\n\nconst userData = [\n  {id: 1, name: \"Sam\"},\n  {id: 2, name: \"Bob\"},\n  {id: 3, name: \"Joe\"},\n];\n\nconst fetchUserData = (): Promise<typeof userData> => {\n  return new Promise((resolve, reject) => {\n    const randomNum = Math.floor(Math.random() * 10 + 1);\n    setTimeout(() => {\n      if(randomNum === 1) {\n        reject(\"오류: 뭔가 잘못되었습니다!\");\n      } else {\n        resolve(userData);\n      }\n    }, 1000);\n  })\n};\n\nconst getHandler = async (req: Request, res: Response) => {\n  const { id } = req.query;\n  if(!id) {\n    return res.status(400).send({ message: \"Id가 필요합니다!\" });\n  }\n  \n  try {\n    const fetchedUserData = await fetchUserData();\n    let filteredUserData = fetchedUserData.filter((user) => user.id === parseInt(id as string));\n    return res.status(200).send({ data: filteredUserData });\n  } catch (err) {\n    return res.status(500).send({ message: err });\n  }\n};\n\nconst postHandler = (req: Request, res: Response) => {\n  const { name } = req.body;\n  if(!name) {\n    return res.status(400).send({ message: \"이름이 필요합니다!\" });\n  }\n\n  const newUser = {\n    id: userData.length + 1,\n    name,\n  };\n\n  userData.push(newUser);\n  return res.status(201).send({ data: newUser });\n};\n\nrouter.get(\"/users\", getHandler);\nrouter.post(\"/users\", postHandler);\n\nexport default router;\r\n```\n\n<div class=\"content-ad\"></div>\n\ngetHandler가 비동기이고 postHandler는 동기입니다. 이는 각 라우트 핸들러에서 발생하는 오류를 어떻게 처리할지에 역할을 하며, 나중에 왜 그러한지 알게 될 것입니다. 우선 그것을 염두에두세요.\n\n제공된 코드의 오류 처리 기술은 일반적인 접근 방식과 구체적인 오류 처리의 부재로 인해 프로덕션 수준 애플리케이션에 적합하지 않습니다. 이것은 작은 프로젝트이기 때문에 즉시 영향을 보지 못할 수 있습니다. 그러나 가령 수백 개의 엔드포인트가 있는 익스프레스 서버가 있고 매일 여러 개발자가 작업하고 있다고 상상해봅시다. 서로 다른 엔드포인트를 통해 동일 유형의 오류에 대한 클라이언트 연결이 동일한 응답을 받도록 일관된 오류 인터페이스를 어떻게 보장할 수 있을까요?\n\n예를 들어, getHandler에서 요청에 id 쿼리 매개변수가 지정되지 않았다면 상태 코드 400과 메시지 속성이 있는 객체로 응답을 보냅니다. 새로운 개발자가 분리된 엔드포인트에서 작업하다가 동일 유형의 오류에 대해 같은 유형의 응답을 보내려고 하지만 오류 속성을 포함한 객체를 사용하기로 결정한다고 상상해 봅시다. 이 경우 연결된 클라이언트는 서버에서 유래할 수 있는 모든 가능한 오류 형식을 알아야 하므로 이는 지속 가능한 패턴이 아닙니다.\n\n다음 섹션에서 익스프레스 서버에서 올바른 오류 처리에 사용되는 기술을 보여드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Express 기본 오류 처리기\n\nExpress 기본 오류 처리기는 Express에서 제공하는 내장 오류 처리 미들웨어입니다. 이는 응닑-요청 주기 동안 발생하는 오류를 처리하는 대체 메커니즘으로 작용하지만 응용 프로그램의 라우트 핸들러나 사용자 정의 오류 미들웨어에서 명시적으로 처리되지 않은 경우에 대비합니다.\n\n기본 오류 처리기는 err, req, res 및 next라는 네 개의 인수를 취합니다. err 인수는 오류 객체를 나타내고, req와 res는 각각 요청 및 응답 객체입니다. next 함수는 미들웨어 스택에서 다음 오류 처리 미들웨어(있는 경우)로 오류를 전달하는 데 사용됩니다.\n\n기본 오류 처리기는 개발 중에 처리되지 않은 오류를 빠르게 식별하는 데 유용하지만, 일반적으로 프로덕션 환경에서는 적합하지 않습니다. 프로덕션에서는 보다 견고한 오류 처리를 제공하는 사용자 정의 오류 처리 미들웨어로 기본 오류 처리기를 대체하고, 적절한 로깅, 사용자 친화적인 오류 응답 및 서로 다른 유형의 오류를 구분하는 기능을 제공해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n기본 오류 처리기를 교체하려면 네 가지 인수 (err, req, res 및 next)를 사용하는 사용자 지정 오류 미들웨어를 만들어 해당 미들웨어 내에서 오류 처리 로직을 정의할 수 있습니다. 이렇게 함으로써 오류 응답을 더욱 세밀하게 제어할 수 있으며 응용 프로그램이 제품 환경에서 신뢰성 있게 동작하고 안전하게 운영되도록 할 수 있습니다. 아래에 샘플 사용자 지정 오류 처리기 미들웨어가 표시되어 있습니다.\n\n```js\n/** src/middlewares/errors.ts **/\n\nimport { NextFunction, Request, Response } from \"express\";\n\nexport const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {\n  console.error(err);\n  res.status(500).send({ errors: [{ message: \"Something went wrong\" }] });\n};\n```\n\n위의 핸들러는 간단히 err 객체를 가져와서 해당 객체를 로깅한 후에 500 상태로 클라이언트에게 응답을 보냅니다.\n\n미들웨어 폴더를 만들고, 해당 폴더 안에 위의 오류 처리기 코드를 담은 새로운 errors.ts 파일을 만들어 보도록 하겠습니다. 그리고 app.ts 파일 내에서 express 서버와 연결된 내보내기된 에러 핸들러를 연결할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/** src/app.ts **/\n\n// 글로벌 의존성\nimport express from \"express\";\nimport { json } from \"body-parser\";\n\n// 프로젝트 의존성\nimport userRouter from \"./routes/users\";\nimport errorHandler from \"./middlewares/errors\";\n\n// 익스프레스 초기화\nconst app = express();\n\n// 미들웨어\napp.use(json());\n\n// 라우트\napp.use(userRouter);\n\n// 오류 처리\napp.use(errorHandler);  // <--------- errorHandler를 사용 중\n\nexport default app;\n```\n\n즉, 라우트나 미들웨어에서 오류가 발생하면 errorHandler에서 처리됩니다. 그러나 여기에 한 가지 주의해야 할 점이 있습니다. 동기식 라우트 핸들러와 비동기식 라우트 핸들러에서 오류를 처리하는 방법이 다르며 다음 두 섹션에서 그 차이를 알아볼 것입니다.\n\n# 동기식 오류\n\n우선 동기식 라우트 핸들러에서 오류를 처리하는 방법을 살펴봅시다. 이것은 더 쉬운 방식으로 다룰 수 있습니다. users.ts의 postHandler를 아래와 같이 변경해봅시다:\n\n<div class=\"content-ad\"></div>\n\n```js\n/** src/routes/users.ts **/\n\nconst postHandler = (req: Request, res: Response) => {\n  const { name } = req.body;\n  if(!name) {\n    throw new Error(\"Name is required!\");\n    // return res.status(400).send({ message: \"Name is required!\" });\n  }\n\n  const newUser = {\n    id: userData.length + 1,\n    name,\n  };\n\n  userData.push(newUser);\n  return res.status(201).send({ data: newUser });\n};\n```\n\n사용자 엔드포인트에 이름이 요청 본문에 포함되지 않은 요청을 보내보세요. 서버는 응답 본문에서 오류 배열과 함께 500 상태 코드로 응답합니다.\n\n동기적 루트 핸들러에서 오류가 발생하면 사용자 정의 오류 처리기 미들웨어가 즉시 잡아내고 클라이언트에 응답을 보내기 전에 사용자 정의 논리를 적용합니다. 이제 다음 섹션에서 비동기 루트 핸들러에서 발생하는 오류를 처리하는 방법을 살펴봅시다.\n\n# 비동기 오류\n\n<div class=\"content-ad\"></div>\n\n지금은 users.ts의 getHandler를 아래와 같이 변경해 봅시다:\n\n```js\n/** src/routes/users.ts **/\n\nconst getHandler = async (req: Request, res: Response) => {\n  const { id } = req.query;\n  if (!id) {\n    throw new Error(\"Id is required!\");\n    // return res.status(400).send({ message: \"Id is required!\" });\n  }\n  \n  const fetchedUserData = await fetchUserData();\n  let filteredUserData = fetchedUserData.filter((user) => user.id === parseInt(id as string));\n  return res.status(200).send({ data: filteredUserData });\n};\n```\n\n이제 id 쿼리 매개변수 없이 사용자 엔드포인트로 GET 요청을 시도해보세요. 놀랍게도 전체 익스프레스 서버가 충돌할 것이고, 이것은 비동기 오류가 기본적으로 익스프레스 오류 처리기에서 잡히지 않기 때문입니다. 비동기 오류를 오류 처리기 미들웨어로 전달하려면 아래와 같이 익스프레스 next 함수를 사용해야 합니다.\n\n```js\n/** src/routes/users.ts **/\n\nconst getHandler = async (req: Request, res: Response, next: NextFunction) => {\n  const { id } = req.query;\n  if (!id) {\n    return next(new Error(\"Id is required!\"));\n    // throw new Error(\"Id is required!\");\n    // return res.status(400).send({ message: \"Id is required!\" });\n  }\n  \n  try {\n    const fetchedUserData = await fetchUserData();\n    let filteredUserData = fetchedUserData.filter((user) => user.id === parseInt(id as string));\n    return res.status(200).send({ data: filteredUserData });\n  } catch (err) {\n    next(err);\n  }\n};\n```\n\n<div class=\"content-ad\"></div>\n\n다음 함수는 일반적으로 인수를 받지 않고 요청을 다음 미들웨어로 이동시키기 위해 호출됩니다. next 함수에 입력을 제공하면 Express 서버에게 모든 것을 건너뛰고 바로 에러 핸들러로 이동해야 한다는 신호를 보냅니다.\n\nfetchUserData가 프라미스를 반환하므로 오류 처리를 위해 try-catch 블록을 구현하고 catch 표현식에서 next 함수를 사용하여 오류를 전파해야 합니다. express-async-errors npm 패키지를 사용하면 next 함수를 사용하지 않고 비동기 라우트 핸들러에서 간단히 오류를 던질 수 있도록 express 라이브러리를 수정하는 방법을 제공합니다.\n\n다음 명령을 실행하여 패키지를 설치할 수 있습니다:\n\n```js\nnpm install express-async-errors\n```\n\n<div class=\"content-ad\"></div>\n\napp.ts 파일 안에서 express 라이브러리에 대한 패치가 적용되도록 패키지를 import하세요.\n\n```js\n/** src/app.ts **/\n\n// Global dependencies\nimport express from \"express\";\nimport { json } from \"body-parser\";\nimport \"express-async-errors\";  // <---------- apply async error patch\n\n// Project dependencies\nimport userRouter from \"./routes/users\";\nimport { errorHandler } from \"./middlewares/errors\";\n\n// Express 초기화\nconst app = express();\n\n// 미들웨어\napp.use(json());\n\n// 라우터\napp.use(userRouter);\n\n// 에러 처리\napp.use(errorHandler);\n\nexport default app;\n```\n\n그런 다음 users.ts 파일 안의 getHandler를 수정하여 서버가 크래시하는 걱정없이 간단히 에러를 throw할 수 있습니다.\n\n```js\n/** src/routes/users.ts **/\n\nconst getHandler = async (req: Request, res: Response, next: NextFunction) => {\n  const { id } = req.query;\n  if(!id) {\n    throw new Error(\"Id is required!\");\n  }\n  \n  const fetchedUserData = await fetchUserData();\n  let filteredUserData = fetchedUserData.filter((user) => user.id === parseInt(id as string));\n  return res.status(200).send({ data: filteredUserData });\n};\n```\n\n<div class=\"content-ad\"></div>\n\nExpress에서 오류를 중앙 집중식으로 처리하는 데 도움을 주는 도구가 있으니, 해결해야 할 문제가 아직 몇 가지 더 있습니다:  \n- 모든 오류가 500 응답으로 처리되는 대신 다른 상태 코드로 응답을 보내는 방법은 무엇인가요?  \n- 클라이언트에게 오류 응답을 일관된 형식으로 보장하는 방법은 무엇인가요?  \n\n이것이 TypeScript가 우리를 도와줄 부분이며, 다음 섹션에서 왜 도와주는지 볼 것입니다.  \n\n# 사용자 정의 오류 클래스\n\n<div class=\"content-ad\"></div>\n\n고객에게 반환하는 오류에 일관된 인터페이스를 보장하기 위해 TypeScript에서 사용자 정의 오류 클래스를 만들 수 있습니다. 이를 통해 더 구조화되고 의미 있는 오류 응답을 제공할 수 있습니다. 사용자 정의 오류 클래스를 사용하면 특정 오류 정보를 캡슐화하고 응용 프로그램 전반에서 일관된 오류 객체를 만들 수 있습니다.\n\n우리는 아래와 같이 CustomError 추상 클래스를 생성하면서 시작합니다.\n\n```js\n/** src/errors/CustomError.ts **/\n\nexport type CustomErrorContent = {\n  message: string,\n  context?: { [key: string]: any }\n};\n\nexport abstract class CustomError extends Error {\n  abstract readonly statusCode: number;\n  abstract readonly errors: CustomErrorContent[];\n  abstract readonly logging: boolean;\n\n  constructor(message: string) {\n    super(message);\n\n    // 내장 클래스를 확장하고 있기 때문에 사용합니다.\n    Object.setPrototypeOf(this, CustomError.prototype);\n  }\n}\n```\n\nCustomErrorContent 유형은 오류 메시지의 구조를 정의합니다. 이는 필수 메시지 필드와 선택적 context 필드(추가적인 오류 관련 데이터를 보유하는 키-값 객체)를 포함합니다. 반면에 CustomError 추상 클래스는 특정 사용자 정의 오류 클래스를 만드는 데 기본 역할을 합니다. 이 클래스는 statusCode(오류 응답에 보낼 HTTP 상태 코드를 나타냄), errors(구체적인 오류 세부 정보를 가진 CustomErrorContent 객체 배열), logging(오류를 로깅해야 하는지 여부를 나타내는 부울값) 세 가지 추상 속성을 구현하도록 강제합니다. 이 추상 클래스 자체는 기본 내장 Error 클래스를 확장하므로 stack 및 cause와 같은 속성에 접근할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nCustomError 클래스를 확장하고 추상 속성을 구현함으로써 다양한 오류 시나리오를 처리하는 일관성 있고 구조화된 확장 가능한 오류 클래스를 만들 수 있습니다. 예를 들어, 아래와 같이 일반적인 BadRequestError 클래스를 생성할 수 있습니다.\n\n```js\n/** src/errors/BadRequestError **/\n\nimport { CustomError } from \"./CustomError\";\n\nexport default class BadRequestError extends CustomError {\n  private static readonly _statusCode = 400;\n  private readonly _code: number;\n  private readonly _logging: boolean;\n  private readonly _context: { [key: string]: any };\n\n  constructor(params?: {code?: number, message?: string, logging?: boolean, context?: { [key: string]: any }) {\n    const { code, message, logging } = params || {};\n    \n    super(message || \"Bad request\");\n    this._code = code || BadRequestError._statusCode;\n    this._logging = logging || false;\n    this._context = params?.context || {};\n\n    // 내장 클래스를 확장하는 경우만 필요\n    Object.setPrototypeOf(this, BadRequestError.prototype);\n  }\n\n  get errors() {\n    return [{ message: this.message, context: this._context }];\n  }\n\n  get statusCode() {\n    return this._code;\n  }\n\n  get logging() {\n    return this._logging;\n  }\n}\n```\n\n이 클래스는 CustomError 클래스를 확장하고 Express 서버 애플리케이션에서 잘못된 요청 시나리오를 처리하기 위해 설계되었습니다. 이 클래스에는 HTTP 상태 코드를 나타내는 _code, 로깅 플래그를 나타내는 _logging, 그리고 오류에 대한 추가적인 컨텍스트 데이터를 나타내는 _context라는 프라이빗 속성이 포함되어 있습니다. 클래스 생성자는 옵션 params 객체를 인수로 받아 코드, 메시지, 로깅, 컨텍스트를 지정하여 오류를 사용자 정의할 수 있도록합니다. params가 제공되지 않으면 생성자는 오류 메시지(\"Bad request\")와 상태 코드(400)에 대한 기본값을 설정합니다. 이 사용자 정의 오류 클래스를 위한 구체적인 오류 세부 정보를 반환하도록 구현된 errors, statusCode 및 logging Getter 메서드가 있습니다. 이것들이 CustomError 클래스에 의해 강제됨에 유의하세요.\n\n우리는 사용자 엔드포인트의 postHandler에서 BadRequestError 클래스를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n/** src/routes/users.ts **/\n\n// ***\n\nconst postHandler = (req: Request, res: Response) => {\n  const { name } = req.body;\n  if(!name) {\n    throw new BadRequestError({code: 400, message: \"Name is required!\", logging: true});\n  }\n\n  const newUser = {\n    id: userData.length + 1,\n    name,\n  };\n\n  userData.push(newUser);\n  return res.status(201).send({ data: newUser });\n};\n\n// ***\r\n```\n\n마지막으로, 사용자 지정 오류 처리 미들웨어 내에서 표를 Markdown 형식으로 변경할 수 있습니다. 아래의 예시와 같이 CustomError의 인스턴스를 특별히 찾도록 로직을 조정할 수 있습니다.\n\n```js\r\n/** src/middlewares/errors.ts **/\n\nimport { NextFunction, Request, Response } from \"express\";\nimport { CustomError } from \"../errors/CustomError\";\n\nexport const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {\n  // 처리된 오류\n  if(err instanceof CustomError) {\n    const { statusCode, errors, logging } = err;\n    if(logging) {\n      console.error(JSON.stringify({\n        code: err.statusCode,\n        errors: err.errors,\n        stack: err.stack,\n      }, null, 2));\n    }\n\n    return res.status(statusCode).send({ errors });\n  }\n\n  // 처리되지 않은 오류\n  console.error(JSON.stringify(err, null, 2));\n  return res.status(500).send({ errors: [{ message: \"문제가 발생했습니다\" }] });\n};\r\n```\n\n미들웨어는 먼저 오류가 CustomError 클래스의 인스턴스인 처리된 사용자 정의 오류인지 확인합니다. 처리된 오류일 경우, 미들웨어는 사용자 지정 오류 객체에서 HTTP 상태 코드, 오류 세부 정보 및 로깅 플래그를 추출합니다. 이 오류에 대해 로깅이 활성화되어 있는 경우, 디버깅 목적으로 콘솔에 오류와 그 스택 트레이스를 로깅합니다. 그런 다음 추출된 오류 세부 정보로 클라이언트에 적절한 응답을 보냅니다.\n\n<div class=\"content-ad\"></div>\n\n미처리된 오류(사용자 정의 오류가 아닌 오류)의 경우 미들웨어가 오류를 콘솔에 기록하며, 오류 객체의 형식이 지정된 JSON 표현과 함께 스택 추적을 표시합니다. 로깅 후 미들웨어는 클라이언트에게 \"문제가 발생했습니다.\" 라는 기본 오류 메시지와 함께 일반적인 500 Internal Server Error 응답을 보냅니다.\n\n위 구현을 통해 이제 우리는 효과적이고 중앙집중화된 오류 관리를 보장하는 미들웨어를 보유하게 되었으며, 사용자 정의 오류에 대한 특정 응답을 제공하고 디버깅 목적으로 미처리된 오류를 로깅합니다.\n\n# 결론\n\n효과적인 오류 처리는 제품용으로 제작된 안정적이고 견고한 Express 서버 응용 프로그램을 구축하는 중요한 측면입니다. 이 기사에서는 Express 서버에서 TypeScript를 사용하여 프로처럼 오류를 처리하기 위한 다양한 전략과 모범 사례를 탐색했습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 예시 Express 서버를 설정하고 Express에서 제공하는 기본 오류 처리 기술의 한계를 확인하며 시작했습니다. 이러한 한계를 극복하기 위해 우리는 사용자 정의 오류 처리 미들웨어를 구현하여 오류 응답을 더 세밀하게 제어하고 응용 프로그램 전반에 걸쳐 일관성을 유지할 수 있도록 했습니다.\n\n우리의 오류 처리 방법 중 하나는 TypeScript를 사용하여 사용자 정의 오류 클래스를 만드는 것이었습니다. 우리는 CustomError라는 추상 기본 클래스를 정의했는데, 이 클래스는 하위 클래스에 statusCode, errors 및 logging과 같은 특정 속성을 강제했습니다. 이 기본 클래스를 확장하고 사용자 정의 오류 클래스에서 이러한 속성을 구현함으로써 일정한 형식을 갖는 체계적이고 의미 있는 오류 응답을 얻었습니다.\n\n우리는 라우트 핸들러에서 동기적 및 비동기적 오류를 효과적으로 처리하는 방법을 배우며, next 함수를 사용하거나 express-async-errors 패키지를 활용하여 비동기적 오류 처리를 간단화했습니다.\n\n이러한 기술을 결합하여 우리는 중앙 집중화된 표준화된 오류 처리 메커니즘을 수립하여 클라이언트가 어떤 종류의 오류나 어떤 엔드포인트를 액세스하더라도 일관된 오류 응답을 받도록 했습니다. 또한, 적절한 경우 콘솔에 오류를 로깅함으로써 디버깅 능력을 향상시키고, 동시에 안전하고 사용자 친화적인 오류 인터페이스를 유지했습니다.\n\n<div class=\"content-ad\"></div>\n\n요약하면, TypeScript의 강력한 기능과 잘 구성된 오류 처리 전략을 활용하여 더 견고하고 유지보수가 쉬운 Express 서버 애플리케이션을 구축할 수 있으며, 프로덕션 환경에서 예기치 못한 다운타임을 최소화할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png"},"coverImage":"/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png","tag":["Tech"],"readingTime":16},{"title":"Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법","description":"","date":"2024-06-22 03:25","slug":"2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma","content":"\n\n<img src=\"/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png\" />\n\n안녕하세요! 이번 튜토리얼에서는 NextJS 앱에 인증을 추가하는 방법을 Next Auth를 사용하여 보여드릴 거에요. 저는 NextJS 애플리케이션을 실행하기 위해 런타임으로 bun을 사용할 거에요.\n\nStep I : Next 14 프로젝트 설정하기\n\n```js\nbunx create-next-app@latest next-auth-prisma\n```\n\n<div class=\"content-ad\"></div>\n\n위의 명령어를 입력하시거나 프로젝트 설정을 위해 NextJS의 공식 문서를 참고하시면 됩니다.\n\n단계 II: NextAuth API route 설정\n\nNext 앱을 설치한 후에는 다음 명령어를 통해 앱 안에 next-auth 패키지를 설치해야 합니다.\n\n```js\nbun add next-auth\n```\n\n<div class=\"content-ad\"></div>\n\n이제 다음 인증에 사용할 인증 옵션을 구성해야 합니다. 기본 폴더로 이동하여 lib라는 새 폴더를 만들고 lib 폴더 안에 auth.ts라는 새 파일을 만들고 다음 코드를 복사하세요.\n\n/lib/auth.ts\n\n```js\nimport type { NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\n\nexport const authOptions: NextAuthOptions = {\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    CredentialsProvider({\n      name: \"Email and Password\",\n      credentials: {\n        email: {\n          label: \"Email\",\n          type: \"email\",\n          placeholder: \"example@example.com\",\n        },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        const user = { id: \"1\", name: \"Admin\", email: \"admin@admin.com\" };\n        return user;\n      },\n    }),\n  ],\n};\n```\n\n위 코드는 다음 인증 구성 설정 프로세스를 보여줍니다. 저는 next-auth에서 CredentialsProvider를 사용했지만 Google, Github, Facebook 등의 다른 프로바이더를 사용할 수 있습니다. 이러한 프로바이더를 구현하려면 해당 프로바이더의 구성에 대해 공식 문서를 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n지금 자격 증명 객체에는 로그인 양식에 표시되는 이메일과 비밀번호가 필드로 포함되어 있습니다. 인증 단계에는 목업 사용자 객체를 반환하는 더미 자격 증명이 있습니다.\n\n다음 단계는 NextAuth에서 인증 요청을 처리하는 API 경로를 생성하는 것입니다. 시작하려면 앱 디렉토리 내에 api라는 새 폴더를 만들고 그 안에 auth라는 새 폴더를 만들어주시고 auth 내부에 catch-all-routes 폴더 [...nextauth]을 만든 다음 auth 폴더 내에 route.ts라는 이름의 파일을 만들어주시고 다음 코드를 붙여넣어주세요.\n\n/app/api/auth/[…nextauth]/route.ts\n\n```js\nimport { authOptions } from \"@/lib/auth\";\nimport NextAuth from \"next-auth\";\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n```\n\n<div class=\"content-ad\"></div>\n\n프렌들리하게 번역하면 다음과 같습니다:\n\n우리는 이전에 NextAuth 함수 안에서 미리 구성한 authOptions를 가져왔고, next auth 핸들러를 내보냈습니다.\n\n3단계: 버튼 만들기\n\n애플리케이션의 페이지 간 이동을 쉽게 하기 위해 브라우저에 수동으로 URL을 입력하는 대신 버튼을 만들겠습니다. 기본 폴더 내에 components라는 새 폴더를 만들고 buttons.component.tsx라는 파일을 생성하세요.\n\n/components/buttons.component.tsx\n\n<div class=\"content-ad\"></div>\n\n```js\n\"use client\";\n\nimport { signIn, signOut } from \"next-auth/react\";\nimport Link from \"next/link\";\n\nexport const LoginButton = () => {\n  return (\n    <button style={ marginRight: 10 } onClick={() => signIn()}>\n      Sign in\n    </button>\n  );\n};\n\nexport const RegisterButton = () => {\n  return (\n    <Link href=\"/register\" style={ marginRight: 10 }>\n      Register\n    </Link>\n  );\n};\n\nexport const LogoutButton = () => {\n  return (\n    <button style={ marginRight: 10 } onClick={() => signOut()}>\n      Sign Out\n    </button>\n  );\n};\n\nexport const ProfileButton = () => {\n  return <Link href=\"/profile\">Profile</Link>;\n};\n```\n\n이제 홈 컴포넌트에서 버튼들을 import하세요.\n\n```js\nimport {\n  LoginButton,\n  LogoutButton,\n  ProfileButton,\n  RegisterButton,\n} from \"@/components/buttons.component\";\n\nexport default function Home() {\n  return (\n    <main\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: \"70vh\",\n      }}\n    >\n      <div>\n        <LoginButton />\n        <RegisterButton />\n        <LogoutButton />\n        <ProfileButton />\n      </div>\n    </main>\n  );\n}\n```\n\n이제 NextAuth에서 JWT 인증을 추가해야 하므로 프로젝트의 루트 디렉토리 내 .env 파일에 JWT의 시크릿을 정의해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```yaml\n#.env\n\nNEXTAUTH_SECRET=secret\nNEXTAUTH_URL=http://localhost:3000\n\n이제 http://localhost:3000/를 방문하여 애플리케이션에 액세스하고 홈페이지에서 클릭하여 로그인 버튼을 누르면 로그인 양식으로 이동합니다.\n\n![이미지](/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_1.png)\n```\n\n<div class=\"content-ad\"></div>\n\nWe have mock credentials, so feel free to use any email and password to submit the form. Once the submission is successful, you will be redirected back to the home page. At that point, you can view the application's cookies.\n\n![Cookie Image](/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_2.png)\n\nStep IV: Integrating with database\n\nFor real-world users, we need to connect to a database. I will be using PostgreSQL as the database and Prisma as the ORM.\n\n<div class=\"content-ad\"></div>\n\n새 데이터베이스를 생성하고 데이터베이스 URL을 .env 파일에 넣으세요\n\n```js\nDATABASE_URL=postgresql://postgres:pawan123@localhost:5432/next-auth?schema=public\n```\n\n이제 다음 명령어를 사용하여 prisma ORM과 bcryptjs를 설치하여 사용자 비밀번호를 해싱하세요.\n\n```js\nnpm add @prisma/client bcryptjs && npm add -D ts-node prisma @types/bcryptjs\n```\n\n<div class=\"content-ad\"></div>\n\n프리즈마를 설정하고 포스트그리스 데이터베이스에 연결하려면 다음 명령을 실행하여 프로젝트에서 프리즈마를 초기화하고 포스트그레스SQL용 데이터 소스를 만드세요.\n\n```js\nnpx prisma init --datasource-provider postgresql\n```\n\n이제 schema.prisma 파일 내에 User 모델을 만들어보세요.\n\n```js\n// 이것은 당신의 프리즈마 스키마 파일입니다.\n// 자세한 내용은 다음 문서에서 확인하세요: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id       String @id @default(uuid())\n  name     String\n  email    String @unique\n  password String\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 새 사용자를 생성하고 데이터베이스에 저장하는 등록 기능을 만들 수 있지만, 나는 직접 데이터베이스에 사용자를 입력할 것이다. 시작하려면 prisma 디렉토리에 seed.ts 파일을 만들고 아래 코드를 복사해 넣어라.\n\nprisma/seed.ts\n\n```js\nimport { PrismaClient } from \"@prisma/client\";\nimport { hash } from \"bcryptjs\";\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  const password = await hash(\"password123\", 12);\n  const user = await prisma.user.upsert({\n    where: { email: \"admin@admin.com\" },\n    update: {},\n    create: {\n      email: \"admin@admin.com\",\n      name: \"Admin\",\n      password,\n    },\n  });\n  console.log({ user });\n}\nmain()\n  .then(() => prisma.$disconnect())\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```\n\n쉽게 테스트 사용자로 데이터베이스에 시드(seed)를 생성할 수 있도록 하기 위해 package.json 파일에 스크립트를 추가할 것이다. 파일을 열어 다음 스크립트를 추가하라:\n\n<div class=\"content-ad\"></div>\n\n```json\n{\n    \"prisma\": {\n        \"seed\": \"ts-node --compiler-options {\\\"module\\\":\\\"CommonJS\\\"} prisma/seed.ts\"\n    }\n}\n```\n\n이제 다음 명령을 사용하여 마이그레이션을 생성하고 사용자 스키마를 데이터베이스에 푸시하세요.\n\n```js\nnpx prisma migrate dev --name init\n```\n\n마이그레이션을 생성한 후 다음 명령을 사용하여 데이터베이스에 사용자를 시드하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx prisma db seed\n```\n\n이제 PostgreSQL 데이터베이스와 통신할 수 있도록 @prisma/client 패키지를 사용하여 전역 PrismaClient 인스턴스를 생성할 것입니다. 이를 위해 lib 폴더 안에 prisma.ts라는 파일을 만들고 다음 코드를 추가해주세요.\n\n```js\nimport { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient({\n    log: [\"query\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n```\n\nPrisma와 데이터베이스 설정을 완료했으니, 이제 auth.ts 파일에서 로그인 양식을 인증할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { prisma } from \"@/lib/prisma\";\nimport { compare } from \"bcryptjs\";\nimport type { NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\n\nexport const authOptions: NextAuthOptions = {\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    CredentialsProvider({\n      name: \"로그인\",\n      credentials: {\n        email: {\n          label: \"이메일\",\n          type: \"email\",\n          placeholder: \"example@example.com\",\n        },\n        password: { label: \"비밀번호\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: {\n            email: credentials.email,\n          },\n        });\n\n        if (!user || !(await compare(credentials.password, user.password))) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          randomKey: \"일부 랜덤 키\",\n        };\n      },\n    }),\n  ],\n};\n```\n\n이제 사용자 정의 키를 추가할 수 있습니다. 다음은 NextAuth 구성의 콜백 속성에서 콜백을 수정하는 방법입니다. 이렇게 하면 세션 개체와 JWT에 필요한 정보를 포함시킬 수 있으며 응용 프로그램에 언제든지 어디서나 액세스할 수 있습니다.\n\n```js\ncallbacks: {\n    session: ({ session, token }) => {\n      console.log(\"세션 콜백\", { session, token });\n      return {\n        ...session,\n        user: {\n          ...session.user,\n          id: token.id,\n          randomKey: token.randomKey,\n        },\n      };\n    },\n    jwt: ({ token, user }) => {\n      console.log(\"JWT 콜백\", { token, user });\n      if (user) {\n        const u = user as unknown as any;\n        return {\n          ...token,\n          id: u.id,\n          randomKey: u.randomKey,\n        };\n      }\n      return token;\n    },\n  },\n```\n\nStep V: NextAuth 세션 데이터 가져오기\n\n\n<div class=\"content-ad\"></div>\n\nnext 앱 내에서 권한이 부여된 사용자 세션 데이터를 얻는 두 가지 방법이 있습니다.\n\ni. 서버 컴포넌트에서\n\n서버 컴포넌트 내에서 세션 데이터를 가져오기 위해 getServerSession 함수를 사용할 수 있습니다.\n\n```js\nimport {\n  LoginButton,\n  LogoutButton,\n  ProfileButton,\n  RegisterButton,\n} from \"@/components/buttons.component\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\n\nexport default async function Home() {\n  const session = await getServerSession(authOptions);\n  console.log(session);\n\n  return (\n    <main\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: \"70vh\",\n      }}\n    >\n      <div>\n        <LoginButton />\n        <RegisterButton />\n        <LogoutButton />\n        <ProfileButton />\n\n        <h1>Server Session</h1>\n        <pre>{JSON.stringify(session)}</pre>\n      </div>\n    </main>\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n서버 페이지를 무단 사용자로부터 보호하기 위해 미인가 사용자를 signin 페이지로 리다이렉트하는 다음 코드를 사용할 수 있습니다.\n\n```js\nif (!session) {\n    redirect(\"/api/auth/signin\");\n}\n```\n\nii. 클라이언트 컴포넌트\n\n클라이언트 컴포넌트에서 세션 데이터를 검색하려면 next auth에서 제공하는 세션 제공자를 사용하고 앱을 세션 제공자로 래핑해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n기본 디렉토리에 providers 폴더를 만들고, NextAuthProvider.tsx라는 새 파일을 생성한 다음 아래 코드를 붙여넣어주세요.\n\n```js\n\"use client\";\n\nimport { SessionProvider } from \"next-auth/react\";\n\ntype Props = {\n  children?: React.ReactNode;\n};\n\nexport const NextAuthProvider = ({ children }: Props) => {\n  return <SessionProvider>{children}</SessionProvider>;\n};\n```\n\n이제 layout.tsx 파일에서 프로바이더를 감싸주세요.\n\n```js\nimport { NextAuthProvider } from \"./providers/NextAuthProvider\";\n\nexport const metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <NextAuthProvider>{children}</NextAuthProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 세션 데이터를 가져오는 클라이언트 컴포넌트를 생성해보세요.\n\n```js\n\"use client\";\n\nimport { useSession } from \"next-auth/react\";\n\nexport const User = () => {\n  const { data: session } = useSession();\n\n  return (\n    <>\n      <h1>Client Session</h1>\n      <pre>{JSON.stringify(session)}</pre>\n    </>\n  );\n};\n```\n\n이제 권한이 없는 사용자로부터 클라이언트 컴포넌트를 보호하기 위해 아래 코드를 클라이언트 컴포넌트에 붙여넣어주세요.\n\n```js\nconst { status } = useSession({\n    required: true,\n    onUnauthenticated() {\n      redirect(\"/api/auth/signin\");\n    },\n  });\n\n  if (status === \"loading\") {\n    return <p>Loading....</p>;\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n결론\n\n이 튜토리얼에서는 NextAuth를 새로운 Next.js 14 앱에 통합하는 방법에 대해 배웠습니다. 이 글이 유익하고 즐거웠기를 바랍니다. 피드백이나 질문이 있으면 언제든 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png","tag":["Tech"],"readingTime":12},{"title":"Express  Typescript 서버에서 Vue  Vite 설정하는 방법","description":"","date":"2024-06-22 03:22","slug":"2024-06-22-SettingupanExpressTypescriptServerwithVueVite","content":"\n\n\n\n![Setting up an Express TypeScript Server with Vue Vite](/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png)\n\n백엔드 개발에 뛰어들기는, 특히 프론트엔드 개발자로써는 미지의 영역에 발을 딛는 것처럼 느껴질 수 있어요. \"프론트엔드 걸리\"를 자처하는 나로서는 솔직히 말하면, 백엔드 개발에 뛰어들기 전에 조심스럽게 느껴졌어요. 그러나 프로젝트의 일부 클라이언트 측 로직을 백엔드로 옮긴 후에야, 서버 측 작업이 상상했던 것만큼 무섭지 않다는 것을 깨달았어요.\n\n백엔드 개발에 대해 제가 느낀 불안을 공감한다면, 여기에 잘 왔어요. 이 블로그에서는 Express 서버를 TypeScript와 통합하는 방법을 안내할 거예요.\n\n초보자를 위한 이 포괄적인 가이드는 다음을 중점적으로 다룰 거예요:\n\n\n<div class=\"content-ad\"></div>\n\n- TypeScript로 Express 서버 설정하기\n- 클라이언트와 서버 간 통신 설정하기\n- Vite를 사용하여 요청 프록시 설정하기\n\n이제 프론트엔드와 백엔드 간의 간극을 좁히러 뛰어들어봅시다! 🚀\n\n# 시작하기\n\n이 튜토리얼의 전체 소스 코드에 액세스하려면 여기에 있는 GitHub 리포지토리를 방문해주세요. 서버 및 클라이언트 환경 변수를 추가하는 것을 잊지 마세요. 클론하거나 포크하거나 리포지토리를 별표로 표시하여 차후 참고 및 실험에 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요. 터미널에서 명령어 node -v를 실행하여 Node.js가 설치되어 있는지 확인할 수 있습니다. 설치되어 있다면 설치된 버전이 표시됩니다. 그렇지 않다면 여기를 클릭하여 Node.js를 설치할 수 있습니다.\n\n## 서버 설정하기\n\n백엔드를 설정하는 첫 번째 단계는 적절한 기술 스택을 선택하는 것입니다. Express.js를 사용할 것이며, 이는 간결함과 유연성으로 유명한 Node.js 프레임워크입니다. 추가로 TypeScript를 활용하여 서버 측 코드베이스에 정적 타이핑을 도입할 것입니다.\n\n## 프로젝트 초기화\n\n<div class=\"content-ad\"></div>\n\n우리는 새 디렉토리를 만들고 npm을 사용하여 새 Node.js 프로젝트를 초기화할 것입니다. 초기화된 후 Express 및 TypeScript를 포함한 필수 종속성을 설치하기 위해 각각의 명령을 실행할 것입니다.\n\n- 새 디렉토리 만들기\n\n우리는 스타터 프로젝트를 위한 새 디렉토리를 만들어 시작할 것입니다. 이를 위해 당신의 운영 체제의 터미널 또는 파일 탐색기를 사용할 수 있습니다.\n\n```js\nmkdir express-starter\n```\n\n<div class=\"content-ad\"></div>\n\n2. 프로젝트 디렉토리로 이동해주세요.\n\n디렉토리가 생성되면 cd 명령어를 사용하여 해당 디렉토리로 이동해주세요.\n\n```js\ncd express-starter\n```\n\n3. 서버 및 클라이언트 폴더를 생성하세요.\n\n<div class=\"content-ad\"></div>\n\nexpress-starter 디렉토리에 들어간 후, 두 개의 폴더를 만들어주세요: client와 server 폴더를 만들어주세요. 그런 다음 server 폴더로 이동해주세요.\n\n```js\nmkdir server client cd server\n```\n\n4. 새로운 Node.js 프로젝트 초기화하기.\n\nnpm init을 사용하여 새로운 Node.js 프로젝트를 초기화하세요. 이렇게 하면 package.json 파일이 생성되며, 프로젝트와 의존성에 대한 메타데이터가 저장됩니다. 프롬프트를 따르거나 -y 플래그를 사용하여 모든 프롬프트에 대한 기본값을 수락할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm init -y\n```\n\n5. 의존성 설치하기.\n\n이제, 프로젝트에 필요한 의존성을 설치해보겠습니다.\n\n```js\n# dependencies \nnpm install express cors dotenv  \n\n# development dependencies \nnpm install -D typescript @types/cors @types/node @types/express nodemon\n```\n\n<div class=\"content-ad\"></div>\n\n각 종속성이 무엇을 하는지 간단히 살펴봅시다.\n\n- express: 우리가 서버를 구축하기 위해 사용할 Node.js의 웹 프레임워크입니다.\n- typescript: TypeScript 컴파일러 및 언어입니다. 프로젝트를 타입 안전하게 유지하고 런타임 이전에 버그를 잡을 수 있게 합니다.\n- cors: Cross-Origin Resource Sharing은 교차 출처 요청을 허용하여 백엔드 API가 다른 포트에서 실행되더라도 클라이언트에서 안전하게 액세스할 수 있도록 합니다.\n- dotenv: .env 파일에서 환경 변수를로드합니다.\n- nodemon: Nodemon은 변경 사항을 감지하면 자동으로 노드 응용 프로그램을 다시 시작합니다. 이는 변경 사항이 적용되기 위해 응용 프로그램을 중지하고 다시 시작할 필요가 없다는 것을 의미합니다.\n- @types/node, @types/cors 및 @types/express: Node.js, Cors 및 Express에 대한 유형 정의로 TypeScript 지원을 활성화합니다.\n\n의존성 대 개발 의존성\n\n-D 플래그를 사용하여 설치 중에 일부 dev 종속성을 추가했지만, 왜 필요했을까요? 개발 의존성은 개발 중에만 필요한 모듈로, 종속성은 런타임에서 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n의존성\n\n의존성은 우리 애플리케이션이 올바르게 작동하기 위해 필요한 필수 패키지입니다. npm install을 실행하면 이러한 패키지가 설치됩니다. 이러한 패키지는 package.json 파일의 의존성 섹션에 나열됩니다. 이러한 패키지 없이 배포된 앱은 작동하지 않을 수 있습니다.\n\n개발 의존성\n\n반면에 개발 의존성은 개발 및 테스트 목적에만 필요합니다. 이러한 패키지는 앱이 정상적으로 실행되기 위해 반드시 필요한 것은 아니지만, 빌드, 테스트 및 코드 린팅과 같은 작업에 중요합니다. 이러한 패키지들은 package.json의 devDependencies 섹션에 명시됩니다.\n\n<div class=\"content-ad\"></div>\n\n6. tsconfig.json 생성하기\n\nTypeScript를 구성하기 위해 tsconfig.json 파일을 생성하세요. 이 파일은 TypeScript가 코드를 컴파일하는 방법을 지정합니다. npx tsconfig.json을 실행한 후 Node를 선택하세요. 이 명령은 일부 기본 설정이 포함된 tsconfig.json 파일을 생성합니다.\n\n```sh\nnpx tsconfig.json\n```\n\n7. 소스 파일 생성 및 package.json 업데이트하기\n\n<div class=\"content-ad\"></div>\n\n다음으로, src 디렉토리를 생성하세요. src 디렉토리 안에 우리의 주 파일인 main.ts를 만들 것입니다.\n\n```js\n# src 폴더 생성\nmkdir src\n\n# 폴더로 이동\ncd src\n\n# .ts 파일 생성\ntouch main.ts\n\n# src에서 나와서 서버 디렉토리로 돌아갑니다\ncd ..\n```\n\npackage.json에서 엔트리 포인트를 index.js 대신 main.js로 수정하세요.\n\n```js\n\"main\": \"main.js\",\n```\n\n<div class=\"content-ad\"></div>\n\n8. .env 파일을 생성하세요.\n\n환경 변수를 구성하기 위해 .env 파일을 만듭니다 (예: API 키). 이 파일은 민감한 정보가 노출되지 않도록 버전 관리에서 제외되어야 합니다. 서버 폴더의 루트에 .env 파일을 생성하세요.\n\n```js\ntouch .env\n```\n\n9. .gitignore 파일을 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n.gitignore 파일을 만들어서 버전 관리에서 무시해야 할 파일과 디렉토리를 지정하여 불필요한 파일을 커밋하는 것을 피해야 합니다. 서버 폴더의 루트에 .gitignore 파일을 생성하세요. 우선 node_modules와 .env*를 추가하겠습니다. *는 Git에게 .env로 시작하는 모든 파일이나 폴더를 무시하도록 지시합니다.\n\n```js\n.env* \nnode_modules/\n```\n\n이 시점에서 프로젝트 구조는 다음과 같을 수 있습니다:\n\n```js\nexpress-starter/\n├── client/\n└── server/\n    ├── node_modules/\n  └── src/\n        └── main.ts\n  ├── .env\n  ├── .gitignore\n    ├── package.json\n    ├── tsconfig.json\n```\n\n<div class=\"content-ad\"></div>\n\n기본 설정을 마쳤으니 이제 서버를 생성해봅시다.\n\n# 서버 생성\n\nsrc/main.ts 파일 안에 다음 스니펫을 추가하세요.\n\n```js\n// server/src/main.ts\n\nimport cors from 'cors';\nimport 'dotenv/config';\nimport express from 'express';\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\nconst PORT = process.env.PORT || 3001;\n\napp.get('/api', (_req, res) => {\n  res.status(200).json({ message: '서버에서 안녕하세요!' });\n});\n\napp.listen(PORT, () => {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n이것은 기본 express 서버입니다. 이 앱은 서버를 시작하고 지정된 포트에서 연결을 수신 대기합니다. /api 경로에 대한 요청에 대해 \"서버에서 안녕하세요!\"라고 응답합니다. 코드가 무엇을 하는지 이해해 봅시다.\n\n- 미들웨어 설정\n\napp.use()는 미들웨어를 등록하는 방법입니다. 미들웨어는 서버가 특정 요청을 처리하기 전에 실행하는 특별한 함수들입니다. 미들웨어는 서버가 요청을 수신하고 클라이언트에게 응답을 보내는 순간 사이에서 작동합니다.\n\n우리의 경우, 몇 가지 전역 미들웨어를 등록했습니다:\n\n<div class=\"content-ad\"></div>\n\n- cors: 이 미들웨어는 서버가 서로 다른 소스/출처에서 오는 요청을 수락할 수 있도록 합니다.\n- express.json(): 들어오는 요청을 JSON 형식으로 파싱합니다.\n- express.urlencoded('extended: true'): 요청에서 폼 데이터를 파싱합니다.\n\n2. 라우트 설정\n\napp.get(`/api`)은 특히 /api URL로의 GET 요청에 대한 라우트 핸들러를 설정합니다. 이 라우트로 GET 요청이 올 경우, 서버는 상태 코드 200과 \"서버에서 인사합니다!\" 메시지로 응답합니다.\n\n3. 서버 초기화\n\n<div class=\"content-ad\"></div>\n\napp.listen()은 지정된 포트(PORT)에서 Express 앱을 수신하여 시작합니다. 환경 변수에 포트가 지정되지 않은 경우 기본값은 포트 3001입니다.\n\n이 설정으로 서버를 실행하는 한 걸음 더 나아갈 수 있습니다.\n\n# TypeScript로 Nodemon 구성하기\n\nmain.ts를 실행하려면 서버 디렉토리 내에서 node src/main.ts를 실행할 수 있지만, \".ts\" 라는 알 수 없는 파일 확장자 오류가 발생합니다.\n\n<div class=\"content-ad\"></div>\n\nNode와 TypeScript\n\n`node src/main.ts`를 실행할 때 Node.js가 TypeScript 파일을 직접 실행할 것으로 기대할 수 있습니다. 그러나 Node.js는 TypeScript를 네이티브로 이해하지 않습니다. JavaScript만을 이해합니다.\n\nTypeScript는 JavaScript의 확장이므로 TypeScript 코드는 Node.js에서 실행되기 전에 JavaScript로 컴파일되어야 합니다. 이 컴파일 과정은 .ts 파일을 Node가 이해할 수 있는 동등한 .js 파일로 변환합니다.\n\n서버 코드를 실행하려면 먼저 TypeScript 컴파일러(tsc)를 사용하여 TypeScript 코드를 JavaScript로 변환해야 합니다. 이를 통해 컴파일된 JavaScript 코드가 포함된 dist/main.js 파일이 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 모든 TypeScript 파일을 JavaScript로 컴파일\nnpx tsc\n\n# 생성된 JavaScript 파일 실행\nnode dist/main.js\n```\n\n위의 명령어에서 npx tsc는 TypeScript 컴파일러(tsc)를 호출하여 프로젝트의 모든 TypeScript 파일을 JavaScript로 컴파일합니다. 그 결과로 생성된 JavaScript 파일은 dist 디렉토리에 출력됩니다. 생성된 JavaScript 파일은 Node.js를 사용하여 실행할 수 있습니다.\n\n컴파일된 JavaScript 파일의 출력 디렉토리는 tsconfig.json 파일의 outDir 속성을 사용하여 지정됩니다.\n\n```js\n// server/tsconfig.json\n\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n마지막으로, dist 폴더를 .gitignore 파일에 포함시켜야합니다. 이렇게 하면 컴파일된 JavaScript 파일이 버전 관리에 포함되지 않습니다.\n\n```js\n// server/.gitignore\n\nnode_modules\ndist\n.env*\n```\n\nNodemon을 사용하여 변경 사항 감지\n\nTypeScript 파일을 수정할 때마다 npx tsc 및 node dist/main.js를 사용하여 파일을 수동으로 다시 컴파일하고 실행해야합니다. 이러한 반복 작업은 빠르게 지루해질 수 있습니다. 이 과정을 간소화하기 위해 nodemon이라는 도구를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nNodemon은 디렉토리 내 파일 변경을 감지하여 Node.js 기반 애플리케이션을 자동으로 다시 시작하는 도구입니다. 이를 이용하면 코드를 수정할 때마다 서버를 수동으로 중지하고 다시 시작하는 수고를 덜 수 있습니다.\n\nNodemon은 이미 설치했으므로 이제 구성만 남았습니다.\n\nNodemon 구성하기\n\nNodemon을 구성하려면 package.json에 nodemonConfig를 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```json\n// server/package.json\n\n\"scripts\": {\n    \"dev\": \"nodemon\"\n  },\n  \"nodemonConfig\": {\n    \"watch\": [\n      \"src\"\n    ],\n    \"exec\": \"tsc && node ./dist/main.js\",\n    \"ext\": \"ts,js,json\"\n  },\n```\n\nnodemonConfig 섹션은 파일 변경을 모니터링할 때 nodemon이 어떻게 동작해야 하는지 알려줍니다:\n\n- watch: nodemon에게 src 폴더 내의 변경 사항을 모니터링하도록 지시합니다.\n- ext: 변경 사항을 모니터링할 파일 확장자를 지정합니다 (ts, js, json).\n- exec: 변경 사항이 감지되었을 때 실행할 명령을 정의합니다. 이 경우 TypeScript 파일을 컴파일하고 node ./dist/main.js를 실행하여 서버를 시작합니다.\n\n이제 npm run dev를 실행하여 간단히 nodemon과 함께 서버를 시작할 수 있습니다. 파일 변경 사항을 모니터링하고 서버를 자동으로 다시 시작하는 프로세스가 자동화됩니다. 이 변경 사항으로 서버는 요청을 받을 준비가 되었습니다. Postman과 같은 API 플랫폼이 있다면 http://localhost:3001/api에 GET 요청을 보내보거나 브라우저에서 링크를 방문하여 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 클라이언트 설정\n\n저희 서버는 클라이언트로부터의 요청을 받을 준비가 되어 있습니다. 프론트엔드에서는 Vue를 사용할 것입니다. Vue는 Vite를 기반으로 한 빌드 설정을 사용하며, 이를 우리 서버와 통신하도록 구성할 것입니다. 시작해봅시다.\n\n- 클라이언트 디렉토리로 이동하기\n\n먼저 서버 디렉토리를 중지하고 종료한 후, 클라이언트로 이동해보겠습니다. 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러 중지한 다음, 다음 명령어를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 서버 디렉토리를 나와 클라이언트로 이동 \ncd ../client\n```\n\n2. Vue 프로젝트 생성\n\nVue 앱을 만들려면 다음 명령을 실행하세요. 이 명령은 . .에 의해 지정된 클라이언트 폴더에 직접 프로젝트를 생성합니다.\n\n```js\nnpm create vue@latest .\n```\n\n<div class=\"content-ad\"></div>\n\n여러 선택지를 만들어 몇 가지 선택을 해야 할 것입니다. 패키지 이름과 TypeScript 지원에 대해 고민할 차례입니다. 당신의 프로젝트를 위해 express-vue로 이름을 지어주고 TypeScript 지원에 \"예\"를 선택하되, 다른 선택 가능한 기능들에 대해서는 \"아니요\"를 선택하여 프로젝트를 간단하게 유지해주세요.\n\n그 다음, 의존성을 설치하고 개발 서버를 시작해보세요.\n\n```js\n# 의존성 설치\nnpm install\n\n# 개발 서버 시작\nnpm run dev\n```\n\n이제 http://localhost:5173/에서 Vue 프로젝트가 실행 중일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n3. .env 파일 추가\n\n다음 변수를 사용하여 클라이언트 폴더의 루트에 .env 파일을 추가하십시오.\n\n```js\nVITE_SERVER_URL=http://localhost:3001\nVITE_SERVER_API_PATH=/api\n```\n\n.env 파일을 변경하면 서버를 다시 시작해야 할 수도 있습니다. 서버를 중지하려면 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러주세요. 그런 다음 서버를 다시 시작하려면 npm run dev를 다시 실행해주세요.\n\n<div class=\"content-ad\"></div>\n\n4. vite.config.ts 파일 업데이트\n\n우리는 vite.config.ts 파일을 사용하여 클라이언트와 서버 간의 통신을 활성화하기 위해 파일을 사용자 정의하고 싶어요. defineConfig은 Vite 프로젝트에서 구성 옵션을 정의하는 데 사용되는 도우미 함수입니다. defineConfig은 객체나 함수 둘 중 하나를 인수로 받을 수 있어요. 환경 변수를 로드할 수 있도록 함수를 전달할 거에요.\n\n```js\nimport { fileURLToPath, URL } from 'node:url';\n\nimport vue from '@vitejs/plugin-vue';\nimport { defineConfig, loadEnv } from 'vite';\n\n// <https://vitejs.dev/config/>\nexport default defineConfig((env) => {\n  const envars = loadEnv(env.mode, './');\n\n  const serverURL = new URL(\n    envars.VITE_SERVER_URL ?? '<http://localhost:3001>'\n  );\n  const serverAPIPath = envars.VITE_SERVER_API_PATH ?? '/api';\n\n  return {\n    envDir: './',\n\n    // 클라이언트에서 API 경로를 전역적으로 사용할 수 있도록 함\n    define: {\n      __API_PATH__: JSON.stringify(serverAPIPath),\n    },\n\n    plugins: [vue()],\n    resolve: {\n      alias: {\n        '@': fileURLToPath(new URL('./src', import.meta.url)),\n      },\n    },\n\n    server: {\n      port: 5173,\n      proxy: {\n        // API 경로를 가진 요청을 서버로 프록시함\n        // <http://localhost:5173/api> -> <http://localhost:3001/api>\n        [serverAPIPath]: serverURL.origin,\n      },\n    },\n  };\n});\n```\n\n이 설정의 각 부분이 어떤 역할을 하는지 살펴보도록 하죠.\n\n<div class=\"content-ad\"></div>\n\n- 환경 변수 로딩: loadEnv 함수를 사용하여 현재 모드(예: 개발, 프로덕션)에 기반하여 환경 변수를 로드합니다. 프로젝트 디렉토리에 있는 .env 파일을 읽고 변수를 envars 객체에 로드합니다.\n- 서버 URL 및 API 경로 구문 분석: 서버 URL 및 API 경로가 구문 분석되며, .env 파일에서 찾지 못한 경우 기본값이 제공됩니다.\n\n구성 옵션:\n\n- envDir: 환경 변수가 위치한 디렉토리를 지정합니다.\n- define: 빌드 과정 중에 대체될 전역 상수를 정의할 수 있습니다. 이 경우 __API_PATH__는 서버 API 경로 값으로 정의됩니다.\n- plugins: 프로젝트에서 사용하는 Vite 플러그인을 지정합니다. 여기서 Vue.js 플러그인(vue())이 추가됩니다.\n- resolve.alias: 모듈 해상도를 위한 별칭을 정의합니다. 이 경우 @ 별칭이 src 디렉토리로 설정됩니다.\n\n서버 구성:\n\n<div class=\"content-ad\"></div>\n\n- server.port: Vite 개발 서버가 실행될 포트를 지정합니다. 여기서는 5173으로 설정되어 있어요.\n- server.proxy: 프록시 설정은 클라이언트와 서버 간 통신을 가능하게 합니다. API 경로와 일치하는 요청은 서버 URL로 전달됩니다. http://localhost:5173/api로 요청을 보내면 http://localhost:3001/api로 우리 서버로 전달됩니다.\n\n5. 전역 상수 선언\n\nvite.config.ts 파일에 전역 상수를 추가한 후, TypeScript가 이 상수를 인식하여 타입 확인을 수행하게 만들어야 합니다. env.d.ts 파일에 타입 정의를 선언하여 이를 달성할 수 있어요.\n\n```js\n// client/env.d.ts  \n\n/// <reference types=\"vite/client\" /> \ndeclare const __API_PATH__: string;\n```  \n\n<div class=\"content-ad\"></div>\n\n이 선언에서는 TypeScript에 __API_PATH__ 상수의 존재를 알리고, 해당 타입을 문자열로 지정합니다. 이는 TypeScript가 프로젝트 전체에서 이 글로벌 상수에 대한 유형 확인 및 IntelliSense 지원을 제공하도록 보장합니다.\n\n6. 서버에 요청 보내기\n\n이제 Vite 프로젝트를 서버와 통신하도록 구성했으므로 App.vue 파일을 업데이트하여 서버로부터 요청을 보내고 응답을 화면에 표시해 보겠습니다. 다음 스니펫은 Vue.js composition API를 사용하여 서버에서 데이터를 가져와 앱에 표시하는 방법을 보여줍니다.\n\n```js\n// client/src/App.vue\n\n<script setup lang=\"ts\">\nimport { ref } from \"vue\";\n\n// API 기본 URL을 포함하는 전역 상수 -> /api\nconst baseURL = __API_PATH__;\n\n// 로딩 상태 및 응답 메시지 관리를 위한 반응형 변수\nconst isLoading = ref(false);\nconst message = ref(\"\");\n\n// 서버에서 데이터를 가져오는 함수\nasync function fetchAPI() {\n  try {\n    // 로딩 상태를 true로 설정\n    isLoading.value = true;\n\n    // 서버에 GET 요청 보내기\n    const response = await fetch(baseURL);\n\n    // JSON 응답 해석\n    const data = await response.json();\n\n    // 응답 데이터로 메시지 업데이트\n    message.value = data.message;\n  } catch (error) {\n    // 오류 처리\n    message.value = \"데이터 검색 오류\";\n    console.error(error);\n  } finally {\n    // 로딩 상태 재설정\n    isLoading.value = false;\n  }\n}\n</script>\n\n<template>\n  <!-- fetchAPI 함수를 실행하는 버튼 -->\n  <button @click=\"fetchAPI\">가져오기</button>\n\n  <!-- 데이터를 가져올 때 로딩 메시지 표시 -->\n  <p v-if=\"isLoading\">로딩 중...</p>\n\n  <!-- 사용 가능한 경우 응답 메시지 표시 -->\n  <p v-else-if=\"message\">{ message }</p>\n</template>\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드 스니펫에서:\n\n- 우리는 Vue의 composition API에서 ref 함수를 가져와 반응형 변수를 생성하여 로딩 상태(isLoading)와 응답 메시지(message)를 관리합니다.\n- fetchAPI 함수는 fetch API를 사용해 서버로 GET 요청을 보내는 데 정의됩니다.\n- 요청이 처리되는 동안 로딩 상태가 true로 설정되고 로딩 메시지가 표시됩니다.\n- 요청이 완료되면 로딩 상태가 재설정되고 서버로부터의 응답 메시지가 표시됩니다.\n- 요청 중에 발생하는 모든 오류는 catch되어 메시지가 업데이트됩니다.\n\n이러한 업데이트로 인해, Vue 애플리케이션은 서버에서 데이터를 가져와 사용자에게 표시할 수 있습니다.\n\n7. 두 서버를 시작하세요.\n\n<div class=\"content-ad\"></div>\n\n이미 클라이언트가 실행 중이므로 서버를 시작해야 합니다. VS Code를 사용 중이라면, 메뉴 바에서 Terminal 옵션을 마우스 오른쪽 클릭하고 New Terminal을 선택하여 새 터미널을 열 수 있습니다. 또는 새 터미널 창을 열어 프로젝트 디렉토리로 이동할 수도 있어요. 프로젝트 디렉토리에 들어간 후 아래 명령어를 실행하여 서버를 시작하세요:\n\n```js\ncd server\nnpm run dev\n```\n\n위의 명령어를 실행하면 서버 디렉토리로 이동한 후 개발 모드에서 서버가 시작됩니다.\n\n8. 클라이언트 측 요청 초기화.\n\n<div class=\"content-ad\"></div>\n\n클라이언트에서 App.vue에서 버튼을 클릭하여 요청을 트리거하는 것이 마지막 단계입니다. 이렇게 하면 서버로 요청이 전송됩니다.\n\n# 결론\n\n축하합니다! 🎉 Express.js 및 TypeScript를 사용하여 백엔드에 Vue.js 및 Vite를 사용하는 풀스택 웹 개발 환경을 구축하는 방법을 성공적으로 배우셨습니다.\n\n이 가이드에서 다룬 내용은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 백엔드 설정: TypeScript로 Express.js 서버를 초기화하고 미들웨어를 구성하며 노드.js에서 실행할 수 있도록 코드를 컴파일하는 것부터 시작했습니다.\n- 프론트엔드 구성: 다음으로, 클라이언트와 서버 간의 통신을 허용하도록 Vite를 구성했습니다. 특정 요청을 서버로 프록시하기 위해 Vite의 서버 옵션을 활용했습니다.\n- 클라이언트-서버 통신: 환경을 설정한 후, Vue.js composition API를 사용하여 프론트엔드에서 백엔드로 요청을 보내는 방법을 배웠습니다. 서버에서 데이터를 가져와 UI를 업데이트하여 반응형 웹 애플리케이션을 만들었습니다.\n\n서버 측 로직 작업에 대한 걱정이 줄어들었기를 바라며, 동적 웹 애플리케이션을 구축하는 기초를 마련했으니 실험을 계속해보고, 계속해서 개발하고, 풀스택 부분에 더 깊이 파고들기를 주저하지 마십시오.\n\n즐거운 코딩!\n\n![이미지](/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_1.png)","ogImage":{"url":"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png"},"coverImage":"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png","tag":["Tech"],"readingTime":15},{"title":"TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트","description":"","date":"2024-06-22 03:21","slug":"2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights","content":"\n\n\n![Understanding TypeScript's Handling of Object Literal Types](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png)\n\n안녕하세요! TypeScript의 객체 리터럴 형식 처리는 때로 예상치 못한 동작을 일으킬 수 있다는 사실을 알고 계셨나요? TypeScript를 배우기 시작했을 때 나는 가끔 일어나는 이 문제로 어려움을 겪었습니다. 이것은 일관성이 없어 보이는 TypeScript의 동작 때문에 처음에는 감이 오지 않았습니다.\n\n맥락을 좀 더 설명하자면, TypeScript는 현대적 웹 애플리케이션을 구축하기 위한 타입 안전성과 고급 기능을 제공하는 Javascript의 상위 집합체로서 작용합니다. TypeScript는 선택적 정적 타이핑을 도입하여 개발자가 개발 과정 초기에 오류를 빨리 찾아내고 더 신뢰할 수 있는 코드를 작성할 수 있게 지원합니다.\n\n기본적으로, TypeScript는 이러한 상황에서 도와줍니다 (조금 미묘한 암시가 있음):-\n\n\n<div class=\"content-ad\"></div>\n\n![UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_1](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_1.png)\n\n![UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_2](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_2.png)\n\n그러면 블로그 주제로 넘어가 보겠습니다. 타입스크립트에 의한 객체 리터럴의 일관되지 않은 처리에 대해 다루고 있습니다. 제가 말하는 것은 객체를 다룰 때 타입스크립트의 행동에 대해 어떤 불일치가 관찰될 수 있다는 것입니다. 설명을 듣겠습니까?\n\n# 이슈 설명\n\n<div class=\"content-ad\"></div>\n\n사용자를 생성하는 데 사용되는 기본 함수입니다. 기능이 작성되지 않은 빈 함수이지만, 여기서 다루는 문제는 기능의 유무가 아닙니다. 문제는 거의 동일한 약간의 차이가 있는 두 가지 다른 방법으로 호출할 때 발생합니다.\n\n다음과 같은 자잘한 차이점이 있습니다.\n\n함수에 기대하는 매개변수(이름 및 isPaid)에 email이라는 추가적인 인수를 전달하여 함수를 호출하면 오류가 발생합니다. 이는 함수를 선언할 때 정의되지 않았기 때문에 예상하지 못했던 것입니다. 꽤 기본적인 문제죠?\n\n<div class=\"content-ad\"></div>\n\n하지만 우리가 객체를 함수의 인수로 전달하는 방식을 약간 수정하면 이 오류가 말이 안 되기 시작합니다. 우리가 바로 전달한 객체를 변수에 할당한 뒤에 변수를 함수에 전달하는 방식으로 바꾸는 것인데, 이전과 동일한 오류가 발생해야 했지만 오류가 발생하지 않습니다.\n\n![이미지](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_5.png)\n\n제가 말한 불일치입니다. 이런 일이 발생한 이유와 이를 방지할 수 있는 방법에 대해 논의하고 싶습니다.\n\n# 이런 일이 발생한 이유\n\n<div class=\"content-ad\"></div>\n\nTypeScript의 설계 결정 사항 중 Excess Property Checking과 Structural Typing 때문에 오류가 발생합니다.\n\n이 동작의 핵심은 TypeScript가 초과 속성을 확인하는 방식에 있습니다. 직접 객체 리터럴을 전달할 때 TypeScript는 함수에 추가적인 속성이 전달되지 않도록 엄격한 초과 속성 확인을 수행합니다. 이것은 잠재적인 오류를 빨리 발견하기 위한 것입니다.\n\n반면, 객체가 변수에 할당된 경우 TypeScript는 이 엄격한 확인을 건너뜁니다. 그 이유는 해당 추가 속성이 있는 객체가 코드 다른 곳에서 사용될 수 있으며, TypeScript는 이러한 경우에 더 많은 유연성을 허용합니다. 이를 구조적 타이핑이라고하며, TypeScript는 객체가 즉시 리터럴이 아닌 경우 필수 속성만을 확인하고 추가 속성을 무시합니다.\n\n## 관용구에는 말이 있듯이\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_6.png\" />\n\n변수에 객체를 할당하고 함수에 전달할 때, TypeScript는 구조적 타이핑을 활용합니다. 이는 객체가 기대되는 타입 구조를 준수하는 한 추가적인 속성을 가질 수 있게 합니다. 이 접근법은 더 융통성이 있고 유연합니다.\n\n장점:-\n\n유연성: 객체를 다양한 맥락에서 더 다재다능하게 사용할 수 있습니다. 개발자는 코드의 관련없는 부분에서 오류를 일으키지 않고 추가적인 속성을 가진 객체를 생성할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n편의성: 이 기능은 복잡한 데이터 구조를 다룰 때나 다른 목적을 위해 객체에 추가 정보를 확장할 때 특히 객체 생성 및 조작을 용이하게 만듭니다.\n\n유형 안전성: TypeScript는 유연성을 유지하면서도 필수 속성이 존재하고 올바른 유형을 갖추도록 보장하여 유연성과 유형 안전성 사이의 균형을 제공합니다.\n\n# 이러한 오류를 보다 엄격한 유형 안전성을 보장하고 한정하려면 어떻게 해야 합니까?\n\n방법 1: 변경할 변수의 유형을 명시적으로 주석으로 표시합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_7.png\" />\n\n여기서 우리는 추가 속성이 없도록 특정 유형으로 변수를 명시적으로 선언하고 있습니다.\n\n방법 2: 함수 매개변수를 설정할 때 엄격한 유형을 사용합니다.\n\n<img src=\"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_8.png\" />\n\n<div class=\"content-ad\"></div>\n\n여기서는 함수를 만들 때 매개변수가 엄격하게 형식화되므로 TypeScript가 알 수 없는 속성과 관련된 오류를 발생시킵니다.\n\n방법 3: 인터페이스 유형 사용\n\n![이미지](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_9.png)\n\n여기서는 유형 안전성을 위해 인터페이스를 사용하고, 추가 속성이 필요한 사용 사례에 대해 기본 인터페이스를 확장하고 있습니다.\n그러나 기본 인터페이스를 추가 속성과 함께 사용할 때 TypeScript가 알 수 없는 속성에 대한 오류를 내보내는 것을 볼 수 있습니다. 이는 맥락에 따라 쉽게 완화될 수 있으며 두 가지 목적을 제공합니다:-\n\n<div class=\"content-ad\"></div>\n\n- 만약 추가적인 이메일 속성이 필요한 상황이라면, 오류를 완화하기 위해 확장된 인터페이스를 사용할 수 있습니다.\n- 만약 추가적인 이메일 속성이 필요하지 않은 상황이라면, 인터페이스는 올바른 유형 확인기로 작용하여 이메일 매개변수를 잘못 설정한 오류를 알려줍니다.\n\n# 결론\n\n특히 직접적인 객체 리터럴과 변수 사이의 차이에 대한 TypeScript의 처리 방식은 유형 안전성과 유연성을 균형 있게 유지하는 의도적인 설계 선택입니다. 이 동작을 이해하면 보다 견고한 TypeScript 코드를 작성하고 기능을 효과적으로 사용하는 데 도움이 됩니다. 위에서 설명한 방법을 따르면 보다 엄격한 유형 안전성을 보장하고 과도한 속성과 관련된 잠재적인 위험 요소를 피할 수 있습니다. 처음에는 일관성이 없어 보일 수 있지만 (저에게도 그랬습니다), 이것이 유연성을 제공하기 위해 설계된 기능임을 알아차리면 개발 프로세스에서 TypeScript를 더 잘 활용할 수 있습니다.\n\n# Stackademic 🎓\n\n<div class=\"content-ad\"></div>\n\n끝까지 읽어주셔서 감사합니다! 이제 가시기 전에:\n\n- 작가를 격려하고 팔로우해주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문: In Plain English | CoFeed | Differ\n- Stackademic.com에서 더 많은 콘텐츠를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular 16 Signals 완벽 설명 5가지 예제로 배우는 법","description":"","date":"2024-06-22 03:19","slug":"2024-06-22-Angular16SignalsExplainedWithFiveExamples","content":"\n\nMarkdown 형식으로 테이블 태그를 변경해 주세요.\n\n<div class=\"content-ad\"></div>\n\n시그널의 값은 항상 게터 함수를 통해 읽습니다. 이는 Angular이 시그널이 사용된 위치를 추적할 수 있게 합니다.\n\n그래서 이 개념을 실제로 적용하고 TypeScript에서 몇 가지 실용적인 예제로 배워봅시다:\n\n## 예제 1: 시그널을 사용하여 총 가격 업데이트하기\n\n가정해보죠. 사용자가 쇼핑 카트에 항목을 추가할 수 있는 전자 상거래 애플리케이션을 가지고 있다고 해봅시다. 항목의 총 가격을 표시하고 새 항목이 추가되거나 제거될 때마다 업데이트하고 싶습니다. 이를 달성하기 위해 시그널을 사용하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n  selector: 'my-cart',\n  template: `\n    <ul>\n      <li *ngFor=\"let item of items\">\n        {item.name} - ${item.price}\n        <button (click)=\"removeItem(item)\">Remove</button>\n      </li>\n    </ul>\n    Total Price: ${totalPrice()}\n  `,\n})\nexport class CartComponent {\n  items = [    { name: 'Product A', price: 10 },    { name: 'Product B', price: 15 },    { name: 'Product C', price: 20 },  ];\n  \n  // 장바구니의 항목 목록을 위한 신호인 itemList을 정의합니다.\n  itemList = signal(this.items);\n  \n  // 총 가격을 위한 계산된 값인 totalPrice를 정의합니다.\n  totalPrice = computed(() => {\n    return this.itemList().reduce((acc, curr) => acc + curr.price, 0);\n  });\n  \n  removeItem(item) {\n    // 선택한 항목을 제거하여 itemList 신호를 업데이트합니다.\n    this.itemList.set(this.itemList().filter((i) => i !== item));\n  }\n}\n```\n\n이 예제에서는 장바구니에 있는 항목 목록을 나타내는 신호인 itemList을 정의하고, itemList에 의존하는 총 가격인 totalPrice를 계산된 값으로 정의합니다. 장바구니에서 항목을 제거할 때 itemList 신호를 업데이트하여 totalPrice를 다시 계산합니다.\n\n## 예제 2: 신호를 사용하여 로딩 스피너를 보이거나 숨기기\n\nAPI에서 데이터를 가져와 테이블에 표시하는 컴포넌트가 있다고 가정해봅시다. 데이터를 가져오는 동안 로딩 스피너를 표시하려고 합니다. 이를 신호를 사용하여 구현하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n  selector: 'my-table',\n  template: `\n    <div *ngIf=\"isLoading()\">\n      Loading...\n    </div>\n    <table *ngIf=\"!isLoading()\">\n      <thead>...</thead>\n      <tbody>...</tbody>\n    </table>\n  `,\n})\nexport class TableComponent {\n  // 로딩 상태를 위한 신호 loading을 정의하고 초기값을 true로 설정합니다.\n  \n  loading = signal(true);\n  \n  ngOnInit() {\n    // API에서 데이터를 가져옵니다.\n    fetchData().subscribe((data) => {\n      // 데이터가 수신되면 로딩 신호를 false로 업데이트합니다.\n      this.loading.set(false);\n      \n      // 테이블에 데이터를 렌더링합니다.\n      ...\n    });\n  }\n  \n  isLoading() {\n    return this.loading();\n  }\n}\n```\n\n이 예제에서는 로딩 상태를 나타내는 신호 loading을 정의하고 초기값을 true로 설정합니다. 컴포넌트가 초기화될 때 API에서 데이터를 가져와 데이터를 수신했을 때 로딩 신호를 false로 업데이트합니다. isLoading 메서드는 현재 로딩 신호의 값을 반환하며, 이 값은 로딩 스피너 또는 테이블을 조건부로 렌더링하는 데 사용됩니다.\n\n## 예제 3: 응용 프로그램에서 반응형 프로그래밍을 위한 신호 사용\n\n이 예제에서는 여러 가지 신호, 계산된 신호 및 이펙트를 활용하여 더 복잡한 시나리오에서의 사용법을 시연합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { signal, computed, effect } from 'signal';\n\n// Writable signals\nconst firstName = signal('John');\nconst lastName = signal('Doe');\nconst age = signal(30);\n\n// Computed signal to calculate the full name\nconst fullName = computed(() => `${firstName()} ${lastName()}`);\n\n// Computed signal to determine if the person is an adult\nconst isAdult = computed(() => age() >= 18);\n\n// Effect to log the full name and adult status whenever any of the signals change\neffect(() => {\n  console.log(`Full Name: ${fullName()}`);\n  console.log(`Is Adult: ${isAdult()}`);\n});\n\n// Update the values of the writable signals\nfirstName.set('Jane');\nlastName.set('Smith');\nage.set(25);\n```\n\n여기 예제에서는 세 가지 쓰기 가능한 시그널이 있습니다: firstName, lastName 및 age입니다. firstName과 lastName을 결합하는 fullName 및 나이를 기반으로 사람이 성인인지 여부를 결정하는 isAdult라는 두 개의 계산된 시그널을 만듭니다. 그런 다음, 시그널이 변경 될 때마다 전체 이름 및 성인 여부를 기록하는 효과를 만듭니다.\n\n쓰기 가능한 시그널의 값을 업데이트하면, 해당 값이 변경되었을 때 효과가 실행되어 업데이트된 전체 이름과 성인 여부가 기록됩니다.\n\n이 예제는 시그널, 계산된 시그널 및 효과가 데이터의 변경을 추적하고 반응하여 애플리케이션에서 반응형 프로그래밍을 가능하게 하는 방법을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 예제 4: 다양한 조건에 따라 데이터를 필터링, 정렬 및 계산하는 신호 사용\n\n이 예제는 여러 신호를 통합하고 종속성을 가진 계산된 신호 및 효과를 포함하여 더 복잡한 시나리오를 다룹니다:\n\n```js\nimport { signal, computed, effect } from 'signal';\n\n// 쓰기 가능한 신호\nconst todos = signal([\n  { id: 1, title: '장보기', completed: false },\n  { id: 2, title: '세탁하기', completed: true },\n  { id: 3, title: '개 산책시키기', completed: false }\n]); // 할 일 목록\n\nconst showCompleted = signal(false); // 완료된 할 일을 표시해야 하는지 여부를 나타내는 플래그\n\n// showCompleted 플래그에 기반하여 할 일을 필터링하고 정렬하는 계산된 신호\nconst filteredTodos = computed(() => {\n  const filtered = todos().filter(todo => showCompleted() || !todo.completed);\n  return filtered.sort((a, b) => a.id - b.id);\n});\n\n// 남은 할 일 수를 계산하는 계산된 신호\nconst remainingTodosCount = computed(() =>\n  todos().reduce((count, todo) => (todo.completed ? count : count + 1), 0)\n);\n\n// 변경 시 필터링된 할 일과 남은 수를 로그하는 효과\neffect(() => {\n  console.log('필터링된 할 일:');\n  console.log(filteredTodos());\n  console.log(`남은 할 일 수: ${remainingTodosCount()}`);\n});\n\n// 쓰기 가능한 신호의 값 업데이트\ntodos.mutate(value => {\n  value.push({ id: 4, title: '집 청소하기', completed: false });\n  value[1].completed = false;\n});\n\n// showCompleted 플래그 업데이트\nshowCompleted.set(true);\n```\n\n이 예제에서는 할 일 목록을 나타내는 쓰기 가능한 신호 todos가 있습니다. 또한 완료된 할 일을 표시해야 하는지를 나타내는 쓰기 가능한 신호 showCompleted가 있습니다. showCompleted 플래그에 따라 할 일을 필터링하고 정렬하는 computed 신호 filteredTodos를 생성합니다. 추가로, 남은 할 일 수를 계산하는 computed 신호 remainingTodosCount를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 그런 다음, 변경될 때마다 필터된 할 일 목록과 남은 항목 수를 기록하는 효과를 만듭니다. 결정이 변경될 때마다 이 효과가 여러 번 실행됩니다.\n\n할 일 목록을 업데이트하고 showCompleted 플래그를 변경하는 경우와 같이 쓰기 가능한 시그널의 값을 업데이트할 때, 이 효과가 실행되어 업데이트된 필터된 할 일 목록과 남은 항목 수를 기록합니다. 마지막으로 showCompleted 플래그를 업데이트하여 새로운 필터된 할 일 목록으로 다시 효과를 트리거합니다.\n\n이 예제에서는 시그널, 계산된 시그널 및 효과가 어떻게 함께 작동하여 필터링, 정렬 및 다양한 조건에 따라 데이터를 계산하는 복잡한 시나리오를 처리하는지 보여줍니다.\n\n## 예제 5: 다수의 사용자가 공유하고 수정할 수 있는 장보기 목록 애플리케이션을 구현하는 데 시그널을 사용하는 예시\n\n<div class=\"content-ad\"></div>\n\n여기 신호(Signals)를 활용하여 다수 사용자가 공유하고 수정할 수 있는 식료품 쇼핑 목록 애플리케이션을 만드는 방법 예제가 있어요.\n\n```js\n@Component({\n  selector: 'my-grocery-list',\n  template: `\n    <h2>식료품 목록:</h2>\n    <ul>\n      <li *ngFor=\"let item of items\">\n        {item.name} - {item.quantity} - 최종 편집자: {item.lastEditedBy}\n        <button (click)=\"removeItem(item)\">삭제</button>\n      </li>\n    </ul>\n    <h3>아이템 추가:</h3>\n    <form (submit)=\"addItem()\">\n      <input type=\"text\" [(ngModel)]=\"newItemName\" placeholder=\"이름\">\n      <input type=\"number\" [(ngModel)]=\"newItemQuantity\" placeholder=\"수량\">\n      <button type=\"submit\">추가</button>\n    </form>\n  `,\n})\nexport class GroceryListComponent {\n  items = [    { name: '사과', quantity: 5, lastEditedBy: null },    { name: '바나나', quantity: 3, lastEditedBy: null },    { name: '우유', quantity: 1, lastEditedBy: null },  ];\n  \n  // 아이템 목록에 대한 신호(signal) 정의\n  itemList = signal(this.items);\n  \n  // 현재 사용자의 이름에 대한 신호(signal) 정의\n  currentUser = signal('남편');\n  \n  addItem() {\n    // 현재 사용자의 이름을 마지막으로 편집한 값으로 하는 새로운 항목을 itemList 신호에 추가\n    this.itemList.set([...this.itemList(), { name: this.newItemName, quantity: this.newItemQuantity, lastEditedBy: this.currentUser() }]);\n    \n    // 입력 필드를 지웁니다\n    this.newItemName = '';\n    this.newItemQuantity = '';\n  }\n  \n  removeItem(item) {\n    // 선택한 항목을 itemList 신호에서 제거\n    this.itemList.set(this.itemList().filter((i) => i !== item));\n  }\n}\n```\n\n이 예제에서는 식료품 쇼핑 목록의 항목 리스트를 위한 itemList 신호와 현재 사용자의 이름을 위한 currentUser 신호를 정의했습니다. 새 항목을 추가하거나 기존 항목을 제거할 때 itemList 신호를 업데이트하여 뷰의 재계산이 일어나도록 합니다. 또한 수정된 항목의 lastEditedBy 속성을 currentUser 신호의 현재 값으로 설정합니다.\n\naddItem 메서드는 현재 사용자의 이름을 lastEditedBy 값으로 하는 새 항목을 itemList 신호에 추가합니다. removeItem 메서드는 선택한 항목을 itemList 신호에서 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n이 글을 읽어주셔서 감사합니다. 제 글이 유익하고 생각을 자극했기를 바랍니다.\n\n만약 여러분이 이 글을 지금까지 즐겁게 읽으셨다면, 제 Medium 페이지를 팔로우하시고 박수를 쳐주세요! 🙂\n\n![image](/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_1.png)\n\n팔로우하신다면 댓글 섹션에서 다른 분들과 함께 소통할 수 있는 기회도 생기고, 여러분의 의견을 항상 환영합니다. 팔로워 여러분들의 의견을 매우 소중히 여깁니다. 💬🌟\n\n<div class=\"content-ad\"></div>\n\n내 다른 게시물에 대한 링크:\n1. PART ONE: 간단한 예제와 함께 마이크로서비스 애플리케이션에서 사용되는 가장 일반적인 Spring Boot 어노테이션\n2. PART TWO: 간단한 예제와 함께 마이크로서비스 애플리케이션에서 사용되는 가장 일반적인 Spring Boot 어노테이션\n3. MySQL 및 Rest 엔드포인트를 사용하는 간단한 Spring Boot 애플리케이션\n4. Spring Boot를 사용하여 마이크로서비스 애플리케이션에서 REST API를 개발할 때 따를 가장 좋은 방법들","ogImage":{"url":"/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_0.png"},"coverImage":"/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_0.png","tag":["Tech"],"readingTime":8},{"title":"Redux에서 Redux Toolkit으로 마이그레이션 3부작 시리즈","description":"","date":"2024-06-22 03:16","slug":"2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries","content":"\n\n## 파트 1: Redux 및 Typescript를 사용하여 애플리케이션 개발하기\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png)\n\n레거시 코드베이스를 React로 이관하는 것은 오래된 개발 방식에서 새로운 방식을 가르치는 것과 비슷합니다. 도전적이지만 보람이 있어요! 저희 애플리케이션 중 하나에서는 Redux Toolkit 없이 Redux를 사용하고 있는데, 이전 방식에 대한 리소스를 찾기는 바늘을 건삭하는 것과 같습니다. 대부분의 현대적인 앱은 이제 Redux Toolkit을 사용하며, 이것은 Redux가 공식적으로 추천하는 방식입니다.\n\n이것이 Redux에서 Redux Toolkit으로 마이그레이션하는 가이드를 작성하게 된 계기예요. 앱에 세련된 업그레이드를 해주는 것으로 생각해보세요! 이 튜토리얼은 3부작 시리즈로 이루어져 있을 것입니다: 먼저 전통적인 Redux를 사용하여 앱을 구축한 다음, Redux Toolkit으로 메이크오버할 거예요.\n\n<div class=\"content-ad\"></div>\n\n간단한 GitHub 프로필 찾기 애플리케이션을 만들어 보세요\n\n![GitHub profile finder](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_1.png)\n\n이 애플리케이션에서는 팔로워 수가 1000을 초과하는 인기 있는 사용자 목록을 선별해 두었습니다. 코딩 세계에서는 인기가 중요하니까요! 코딩 영웅들을 찾아보고 'View Repos' 옵션으로 그들의 공개 저장소로 들어가 보세요. 또한 즐겨찾기한 즐겨찾기기능(데이터 표시 제외)이 있어 좋아하는 사용자를 즐겨찾기할 수 있습니다.\n\n전제 조건\n\n<div class=\"content-ad\"></div>\n\nReact와 TypeScript에 대한 좋은 이해도가 있어야 하며, Redux와 Tailwind CSS의 기본 지식이 필요합니다.\n\nGitHub에서 우리 React 앱의 기본 설정을 찾을 수 있습니다.\n\n이 저장소에 대해:\n이 저장소 내에서, Vite 빌드 도구를 사용하여 구축된 기본 React 애플리케이션을 발견할 수 있습니다. 타입 안전성을 위해 TypeScript를 활용하고, 디자인을 위해 Tailwind CSS를 사용할 것입니다.\n\n이 애플리케이션에 필요한 라이브러리를 설치해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n저희는 인터넷 연결에 Axios를 사용하고 앱을 탐색하기 위해 React Router를 사용하며 물론 상태를 유지하기 위해 Redux를 사용할 것입니다. 이 라이브러리들을 설치해 봅시다!!\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_2.png)\n\n폴더 구조\n\n이 폴더 구조를 계속 사용할 것입니다. 함께 따라오고 싶다면 이 튜토리얼과 함께 feature/old-redux 브랜치를 확인해 주세요. 함께 여정을 즐길까요!\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_3.png)\n\n먼저, 쉬운 작업으로 시작해보죠 - API 요청 설정해보기.\n\n'redux' 폴더 아래에 'services'라는 폴더를 만들고, 그 안에 'index.ts'라는 파일을 만들어봅시다.\n\n이 파일에서는 네 가지 유용한 메소드를 사용하여 조금의 마법을 부릴 겁니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 'fetchTopUsersBySize': 상위 사용자 목록을 가져옵니다.\n- 'fetchUserBySearch': 사용자를 검색합니다.\n- 'fetchReposByUserName': 특정 사용자의 저장소를 검색합니다.\n- 'fetchRepoBySearch': 이름으로 저장소를 검색합니다.\n\n```js\nimport api from '../api';\n\nexport const fetchTopUsersBySize = async (size: number = 30) => {\n  const response = await api.get(\n    `/search/users?q=followers:>1000&sort=followers&order=desc&per_page=${size}`\n  );\n  return response.data;\n};\n\nexport const fetchUserBySearch = async (text: string) => {\n  const response = await api.get(`/search/users?q=${text}`);\n  return response.data;\n};\n\nexport const fetchReposByUserName = async (userName: string) => {\n  const response = await api.get(\n    `/users/${userName}/repos?sort=created&direction=desc`\n  );\n  return response.data;\n};\n\nexport const fetchRepoBySearch = async (userName: string, text: string) => {\n  const response = await api.get(\n    `/search/repositories?q=user:${userName}+${text}`\n  );\n  return response.data;\n};\n```\n\n주요 Redux 개념 요약\n\n- Store: 애플리케이션 전체 상태를 보유하는 단일 진리의 소스입니다.\n- Actions: 발생한 일을 설명하는 일반적인 자바스크립트 객체입니다.\n- Reducers: 현재 상태와 동작을 인자로 받아 새로운 상태를 반환하는 순수 함수입니다.\n\n<div class=\"content-ad\"></div>\n\n리덕스 폴더 구조\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_4.png)\n\n내 폴더 구조에 대한 자세한 내용은 다루지 않겠습니다. 다양한 개발자들은 서로 다른 관점으로 폴더 구조를 설정하기 때문입니다. 내 GitHub 저장소를 참조하여 내 코드 구조와 누락된 사항이 무엇인지 확인해보세요.\n\n가장 먼저, 우리 액션을 설정해봅시다.\n\n<div class=\"content-ad\"></div>\n\n우리의 액션 유형을 설정해 봅시다! 액션 유형을 다양한 섹션으로 분할하여 깔끔하게 유지합니다.\n\n- Action Types를 위한 Enum: UsersActionTypes라는 열거형을 정의하여 모든 액션 유형 상수를 포함시킵니다. 이렇게 하면 관리가 쉬워지고 오타를 방지할 수 있습니다.\n- 액션 인터페이스: 각 액션 유형에 대한 인터페이스를 정의합니다.\n- 액션을 위한 Union Types: 관련된 액션을 그룹화하기 위해 유니온 타입을 정의합니다.\n\n```js\nimport { Users } from '../../types/usersTypes';\n\nexport enum UsersActionTypes {\n  /** 사용자 가져오기 */\n  FETCH_TOP_USERS_REQUEST = 'FETCH_TOP_USERS_REQUEST',\n  FETCH_TOP_USERS_SUCCESS = 'FETCH_TOP_USERS_SUCCESS',\n  FETCH_TOP_USERS_FAILURE = 'FETCH_TOP_USERS_FAILURE',\n\n  /** 검색으로 사용자 가져오기 */\n  FETCH_USERS_BY_SEARCH_REQUEST = 'FETCH_USERS_BY_SEARCH_REQUEST',\n  FETCH_USERS_BY_SEARCH_SUCCESS = 'FETCH_USERS_BY_SEARCH_SUCCESS',\n  FETCH_USERS_BY_SEARCH_FAILURE = 'FETCH_USERS_BY_SEARCH_FAILURE',\n\n  /** 사용자 좋아요 옵션 전환 */\n  TOGGLE_USER_LIKE = 'TOGGLE_USER_LIKE',\n}\n\nexport interface FetchTopUsersRequestAction {\n  type: typeof UsersActionTypes.FETCH_TOP_USERS_REQUEST;\n}\n\nexport interface FetchTopUsersSuccessAction {\n  type: typeof UsersActionTypes.FETCH_TOP_USERS_SUCCESS;\n  payload: Users;\n}\n\nexport interface FetchTopUsersFailureAction {\n  type: typeof UsersActionTypes.FETCH_TOP_USERS_FAILURE;\n  payload: string;\n}\n\nexport interface FetchUsersBySearchRequestAction {\n  type: typeof UsersActionTypes.FETCH_USERS_BY_SEARCH_REQUEST;\n}\n\nexport interface FetchUsersBySearchSuccessAction {\n  type: typeof UsersActionTypes.FETCH_USERS_BY_SEARCH_SUCCESS;\n  payload: Users;\n}\n\nexport interface FetchUsersBySearchFailureAction {\n  type: typeof UsersActionTypes.FETCH_USERS_BY_SEARCH_FAILURE;\n  payload: string;\n}\n\nexport interface ToggleUserLikeAction {\n  type: typeof UsersActionTypes.TOGGLE_USER_LIKE;\n  payload: number;\n}\n\nexport type FetchTopUsersActions =\n  | FetchTopUsersRequestAction\n  | FetchTopUsersSuccessAction\n  | FetchTopUsersFailureAction;\n\nexport type FetchUsersBySearchActions =\n  | FetchUsersBySearchRequestAction\n  | FetchUsersBySearchSuccessAction\n  | FetchUsersBySearchFailureAction;\n\nexport type UserActions =\n  | FetchTopUsersActions\n  | FetchUsersBySearchActions\n  | ToggleUserLikeAction;\n```\n\n- FetchTopUsersRequestAction, FetchTopUsersSuccessAction, FetchTopUsersFailureAction: 상위 사용자 가져오기와 관련된 작업에 대한 인터페이스입니다. FETCH_TOP_USERS_SUCCESS에는 가져온 사용자 데이터가 포함된 Users 유형의 payload가 포함되어 있으며, FETCH_TOP_USERS_FAILURE에는 오류 메시지를 나타내는 문자열 유형의 payload가 포함되어 있습니다.\n- FetchUsersBySearchRequestAction, FetchUsersBySearchSuccessAction, FetchUsersBySearchFailureAction: 검색으로 사용자를 가져오기 위한 유사한 인터페이스입니다.\n- ToggleUserLikeAction: 좋아요 옵션을 전환하는 작업을 위한 인터페이스로, 사용자 ID를 나타내는 숫자 유형의 payload가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n알림: 계속 진행하기 전에 redux-thunk를 설치해 봅시다.\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_5.png)\n\nRedux Thunk는 액션 생성자가 액션 객체 대신 함수를 반환할 수 있게 해주는 미들웨어입니다. 이 함수는 비동기 작업을 수행하고 해당 작업이 완료되면 일반 동기 액션을 디스패치할 수 있습니다.\n\n이제 우리의 액션 생성자와 thunk 함수를 준비해 봅시다. 이들은 데이터를 가져오고 필요한 액션을 디스패치하는 Redux 설정의 핵심 역할을 담당할 것입니다. 아래는 코드와 각 부분이 하는 역할에 대한 설명입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Users } from '../../types/usersTypes';\nimport { fetchTopUsersBySize, fetchUserBySearch } from '../../services';\nimport { ThunkAction } from 'redux-thunk';\nimport { ApplicationState } from '../../store';\nimport {\n  FetchTopUsersRequestAction,\n  UsersActionTypes,\n  FetchTopUsersSuccessAction,\n  FetchTopUsersFailureAction,\n  FetchUsersBySearchRequestAction,\n  FetchUsersBySearchSuccessAction,\n  FetchUsersBySearchFailureAction,\n  FetchTopUsersActions,\n  FetchUsersBySearchActions,\n  ToggleUserLikeAction,\n} from './types';\n\n// 액션 생성자\nexport const fetchTopUsersRequest = (): FetchTopUsersRequestAction => ({\n  type: UsersActionTypes.FETCH_TOP_USERS_REQUEST,\n});\n\nexport const fetchTopUsersSuccess = (\n  users: Users\n): FetchTopUsersSuccessAction => ({\n  type: UsersActionTypes.FETCH_TOP_USERS_SUCCESS,\n  payload: users,\n});\n\nexport const fetchTopUsersFailure = (\n  error: string\n): FetchTopUsersFailureAction => ({\n  type: UsersActionTypes.FETCH_TOP_USERS_FAILURE,\n  payload: error,\n});\n\nexport const fetchSearchUsersRequest = (): FetchUsersBySearchRequestAction => ({\n  type: UsersActionTypes.FETCH_USERS_BY_SEARCH_REQUEST,\n});\n\nexport const fetchSearchUsersSuccess = (\n  users: Users\n): FetchUsersBySearchSuccessAction => ({\n  type: UsersActionTypes.FETCH_USERS_BY_SEARCH_SUCCESS,\n  payload: users,\n});\n\nexport const fetchSearchUsersFailure = (\n  error: string\n): FetchUsersBySearchFailureAction => ({\n  type: UsersActionTypes.FETCH_USERS_BY_SEARCH_FAILURE,\n  payload: error,\n});\n\nexport const toogleUserLike = (userId: number): ToggleUserLikeAction => ({\n  type: UsersActionTypes.TOGGLE_USER_LIKE,\n  payload: userId,\n});\n\n// Thunk 함수\nexport const getTopUsersBySize =\n  (\n    size: number = 30\n  ): ThunkAction<void, ApplicationState, unknown, FetchTopUsersActions> =>\n  async (dispatch) => {\n    dispatch(fetchTopUsersRequest());\n    try {\n      const users = await fetchTopUsersBySize(size);\n      dispatch(fetchTopUsersSuccess(users));\n    } catch (error) {\n      if (error instanceof Error) {\n        dispatch(fetchTopUsersFailure(error.message));\n      } else {\n        dispatch(fetchTopUsersFailure('Oops something went wrong!!!'));\n      }\n    }\n  };\n\nexport const getUsersBySearch =\n  (\n    userName: string\n  ): ThunkAction<void, ApplicationState, unknown, FetchUsersBySearchActions> =>\n  async (dispatch) => {\n    dispatch(fetchSearchUsersRequest());\n    try {\n      const users = await fetchUserBySearch(userName);\n      dispatch(fetchSearchUsersSuccess(users));\n    } catch (error) {\n      if (error instanceof Error) {\n        dispatch(fetchSearchUsersFailure(error.message));\n      } else {\n        dispatch(fetchSearchUsersFailure('Oops something went wrong!!!'));\n      }\n    }\n  };\r\n```\n\n참고: ' ApplicationState '를 ‘../../store’에서 가져오는 것은 오류를 발생시킵니다. 하지만 걱정하지 마세요. 코드를 설정할 때 이를 수정할 것입니다.\n\n- 액션 생성자: Redux 스토어에 보내는 액션을 생성하는 함수들입니다.\n\n- fetchTopUsersRequest, fetchTopUsersSuccess, 그리고 fetchTopUsersFailure: 이러한 함수들은 상위 사용자를 가져오는 과정의 다른 단계(요청, 성공, 실패)을 위한 액션을 생성합니다.\n- fetchSearchUsersRequest, fetchSearchUsersSuccess, 그리고 fetchSearchUsersFailure: 검색을 통해 사용자를 가져오기 위한 유사한 함수들입니다.\n- toggleUserLike: 사용자의 좋아요 상태를 전환하는 액션을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n2. Thunk 함수: 이는 비동기 작업을 처리하고 결과에 따라 액션을 디스패치하는 함수들입니다.\n\n- getTopUsersBySize: 이 Thunk 함수는 특정 크기를 기반으로 상위 사용자들을 가져옵니다. 먼저 요청이 시작되었음을 나타내기 위해 fetchTopUsersRequest를 디스패치합니다. 그런 다음 fetchTopUsersBySize를 사용하여 사용자를 가져오려고 시도합니다. 성공하면 가져온 사용자와 함께 fetchTopUsersSuccess를 디스패치하고 오류가 발생하면 오류 메시지와 함께 fetchTopUsersFailure를 디스패치합니다.\n- getUsersBySearch: getTopUsersBySize와 유사하게,이 Thunk 함수는 검색어를 기반으로 사용자를 가져오는 작업을 처리합니다. 시작을 나타내기 위해 fetchSearchUsersRequest를 디스패치 한 후 fetchUserBySearch를 사용하여 사용자를 가져오려고 시도합니다. 성공하면 사용자와 함께 fetchSearchUsersSuccess를 디스패치하고 실패하면 오류 메시지와 함께 fetchSearchUsersFailure를 디스패치합니다.\n\n이러한 액션 생성자 및 Thunk 함수는 Redux 애플리케이션에서 데이터를 가져오고 상태 전환이 관리되는 논리를 처리하는 데 중요합니다. 이러한 방식으로 액션과 액션 유형을 구성함으로써 Redux 설정에서 다양한 사용자 관련 작업을 처리하기 위한 명확하고 관리 가능한 구조를 만들 수 있습니다. 이러한 구조가 갖춰지면 리듀서를 설정하여 이러한 작업을 처리하러 진행할 수 있습니다.\n\n다음으로 리듀서를 설정해 봅시다. 여기서 상태 관리가 게임을 시작합니다.\n\n<div class=\"content-ad\"></div>\n\n이 코드 조각은 애플리케이션의 상태가 Redux 스토어에 전달된 다양한 액션에 대한 응답으로 어떻게 업데이트되는지를 정의하기 때문에 중요합니다. 각 부분이 무엇을 하는지 살펴보겠습니다.\n\n```js\nimport {\n  UserActions,\n  UsersActionTypes,\n  FetchTopUsersSuccessAction,\n  FetchTopUsersFailureAction,\n  ToggleUserLikeAction,\n} from '../actions/users/types';\nimport { Users } from '../types/usersTypes';\n\ninterface UsersState {\n  loading: boolean;\n  users: Users | null;\n  error: string | null;\n}\n\nconst initialState: UsersState = {\n  loading: false,\n  users: null,\n  error: null,\n};\n\nexport const usersReducer = (\n  state = initialState,\n  action: UserActions\n): UsersState => {\n  switch (action.type) {\n    case UsersActionTypes.FETCH_TOP_USERS_REQUEST:\n    case UsersActionTypes.FETCH_USERS_BY_SEARCH_REQUEST:\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n    case UsersActionTypes.FETCH_TOP_USERS_SUCCESS:\n    case UsersActionTypes.FETCH_USERS_BY_SEARCH_SUCCESS:\n      return {\n        ...state,\n        loading: false,\n        users: (action as FetchTopUsersSuccessAction).payload,\n        error: null,\n      };\n    case UsersActionTypes.FETCH_TOP_USERS_FAILURE:\n    case UsersActionTypes.FETCH_USERS_BY_SEARCH_FAILURE:\n      return {\n        ...state,\n        loading: false,\n        error: (action as FetchTopUsersFailureAction).payload,\n      };\n\n    case UsersActionTypes.TOGGLE_USER_LIKE: {\n      const userId = (action as ToggleUserLikeAction).payload;\n      if (!state.users) {\n        return state; // 사용자 데이터가 null인 경우 상태를 그대로 반환합니다.\n      }\n      const updatedUsers = state.users.items.map((user) => {\n        if (user.id === userId) {\n          return {\n            ...user,\n            isLiked: !user.isLiked, // 좋아하는 속성을 토글합니다.\n          };\n        }\n        return user;\n      });\n      return {\n        ...state,\n        users: {\n          ...state.users,\n          items: updatedUsers,\n        },\n      };\n    }\n    default:\n      return state;\n  }\n};\n```\n\n- 상태 인터페이스 및 초기값:\n\n- UsersState: 사용자의 Redux 상태의 모양을 정의하며, 데이터가 검색 중인지를 나타내는 loading, 사용자 데이터를 보유하거나 아직 검색되지 않은 경우 null 또는 오류 메시지를 저장하는 error를 포함합니다.\n- initialState: 기본값으로 UsersState를 초기화합니다.\n\n<div class=\"content-ad\"></div>\n\n2. Reducer Function:\n\n- usersReducer: 이 함수는 디스패치된 액션에 기반하여 상태 업데이트를 처리합니다. 상태와 액션을 매개변수로 받습니다.\n- switch 문: action.type을 평가하여 상태를 업데이트하는 방법을 결정합니다.\n- FETCH_TOP_USERS_REQUEST 및 FETCH_USERS_BY_SEARCH_REQUEST: loading을 true로 설정하고 기존 오류를 지웁니다.\n- FETCH_TOP_USERS_SUCCESS 및 FETCH_USERS_BY_SEARCH_SUCCESS: payload에서 가져온 사용자 데이터로 상태를 업데이트하고 loading을 false로 설정합니다.\n- FETCH_TOP_USERS_FAILURE 및 FETCH_USERS_BY_SEARCH_FAILURE: payload에서 가져온 오류 메시지로 상태를 업데이트하고 loading을 false로 설정합니다.\n- TOGGLE_USER_LIKE: userId로 식별된 사용자의 isLiked 속성을 토글합니다. 상태.users.items를 매핑하여 사용자를 찾고 isLiked를 토글한 후 새 배열인 updatedUsers를 반환합니다. 마지막으로 updatedUsers로 상태를 업데이트합니다. 왜 이렇게 많이 빙빙 돌까요? 상태는 불변이기 때문에 새 복사본을 만들어야 합니다.\n\n3. Default case: 액션 유형이 어떤 케이스와도 일치하지 않으면 상태를 그대로 반환합니다.\n\n이 리듀서는 우리 상태의 내비게이터 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n루트 리듀서를 만들어 봅시다. combineReducers를 사용하여 rootReducer를 생성합니다. combineReducers를 사용하면 Redux 상태의 관리를 간단하게 만들 수 있습니다. 이를 통해 상태 관리 로직을 분리하여 전문화된 리듀서로 분할할 수 있습니다. 우리의 리듀서를 하나의 rootReducer로 결합함으로써, Redux 스토어가 애플리케이션의 다른 부분의 상태를 조직적이고 확장 가능한 방식으로 관리할 수 있도록 합니다.\n\n```js\nimport { combineReducers } from 'redux';\nimport { usersReducer } from './userReducer';\n\n// Combine Reducers\nconst rootReducer = combineReducers({\n  users: usersReducer,\n});\n\n// export type AppState = ReturnType<typeof rootReducer>;\nexport default rootReducer;\n```\n\n이제 우리의 액션과 리듀서가 원활하게 함께 작동하고 있으니, Redux 상태의 기반인 스토어를 구축할 시간입니다!\n\n다음으로, 스토어 설정에 대해 자세히 알아보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 그 전에 애플리케이션에서 사용할 액션 유형을 내보내보겠습니다.\n\n```js\nimport { UserActions } from '../actions/users/types';\n\nexport type AppActionTypes = UserActions;\n```\n\n여기는 Redux 스토어를 설정하는 코드입니다. 이곳에서 모든 마법이 일어납니다.\n\n```js\nimport {\n  applyMiddleware,\n  compose,\n  legacy_createStore as createStore,\n} from 'redux';\nimport { thunk, ThunkDispatch } from 'redux-thunk';\nimport rootReducer from '../reducers';\nimport { AppActionTypes } from '../types/types';\nimport loggingMiddleware from '../middlewares/logging';\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n  }\n}\n\n// 미들웨어 배열 정의\nconst middleware = [thunk, loggingMiddleware];\n\nconst composeEnhancers =\n  (typeof window !== 'undefined' &&\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) ||\n  compose;\n\nexport const store = createStore(\n  rootReducer,\n  undefined,\n  composeEnhancers(applyMiddleware(...middleware))\n);\n\nexport type ApplicationState = ReturnType<typeof rootReducer>;\nexport type ApplicationDispatch = ThunkDispatch<\n  ApplicationState,\n  unknown,\n  AppActionTypes\n>;\n```\n\n<div class=\"content-ad\"></div>\n\n- 창 선언: 우리는 Redux DevTools Extension과 호환되는 저장소를 만들기 위한 전역 인터페이스를 선언하여, 둘 사이의 원활한 통신을 보장합니다.\n- 미들웨어 설정: 우리는 미들웨어 팀을 구성하며 thunk와 loggingMiddleware을 포함시켜, 비동기 작업 및 로깅 활동과 같은 작업을 처리할 준비를 합니다.\n- Enhancers 조합: 이 함수는 미들웨어를 결합하고 저장소를 향상시키는 조합자를 만들어서, 모든 것이 원활하게 동작하도록 합니다. Redux DevTools Extension과 통합되며, 보기 좋은 저장소가 되도록 세심하게 조정됩니다!\n- 저장소 생성: createStore를 사용하여 Redux 저장소를 만들어냅니다. rootReducer를 취하여 상태를 관리하며, 초기 상태로 undefined를 사용하며, 작업 및 상태 변경을 효과적으로 관리하기 위해 미들웨어를 적용합니다.\n- 타입 정의: 마지막으로 rootReducer가 관리하는 Redux 상태의 유형으로 ApplicationState를 정의하고, 디스패치 함수의 유형으로 ApplicationDispatch를 정의하여 Redux 여행 중에 타입 안전성을 보장합니다.\n\n```js\nimport { Middleware } from 'redux';\nimport { ApplicationState } from '../store';\n\nconst loggingMiddleware: Middleware<object, ApplicationState> =\n  (store) => (next) => (action) => {\n    // 액션을 기록합니다.\n    console.log('Action:', action);\n\n    // 액션이 전달되기 전의 현재 상태를 가져옵니다.\n    const prevState = store.getState();\n\n    // 액션을 실행합니다.\n    const result = next(action);\n\n    // 액션이 전달된 후의 상태를 가져옵니다.\n    const nextState = store.getState();\n\n    // 상태 변경 사항을 기록합니다.\n    console.log('이전 상태:', prevState);\n    console.log('다음 상태:', nextState);\n\n    return result;\n  };\n\nexport default loggingMiddleware;\n```\n\n저장소가 설정되어 있으므로, Redux 상태 관리는 응용 프로그램의 복잡성을 처리할 준비가 되어 있습니다. 이제, 페이지를 구축하기 전에, 우리 전체 응용 프로그램을 `Provider store='store'`로 감싸봅시다. 이렇게 하면 Redux 저장소가 구성 요소 트리의 모든 구성 요소에서 사용할 수 있게 됩니다. store는 Redux 저장소의 인스턴스를 나타내는 속성으로 전달되며, 저장소는 여러분의 Redux 저장소 인스턴스를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n메인.tsx 파일에 이 코드를 추가해주세요.\n\n```js\n<Provider store={store}>\n      <div className=\"min-h-screen flex  justify-center bg-gray-100\">\n        <div class=\"w-full max-w-screen-lg m-4 p-4 bg-white rounded shadow-md\">\n          <h1 className=\"text-4xl font-bold text-blue-900 mb-4 tracking-wider uppercase\">\n            GitHub Finder\n          </h1>\n          <RouterProvider router={router} />\n        </div>\n      </div>\n    </Provider>\r\n```\n\n이 글이 조금 무거워지고 있는 것 같지만, Redux 상태 관리를 설정하는 데에는 약간의 노력이 필요합니다. 그게 바로 Redux Toolkit이라는 것을 만들었기 때문이죠. 다음 시리즈에서 이에 대해 다룰 예정입니다. 이제 내가 당신의 신뢰를 되찾았길 바라며, 어플리케이션에 대해 살펴봐요!\n\nuseSelector와 useDispatch 훅\n\n<div class=\"content-ad\"></div>\n\nReact Redux에서 useSelector 및 useDispatch 훅을 사용하면 컴포넌트가 Redux 스토어와 상호작용하는 방법이 간소화됩니다.\n\nuseSelector: 이 훅을 사용하면 컴포넌트가 Redux 상태의 특정 슬라이스를 선택할 수 있어 데이터 접근을 최적화하고 불필요한 렌더링을 최소화할 수 있습니다.\n\nuseDispatch: 액션을 디스패치하는 데 사용되며, useDispatch를 사용하면 컴포넌트가 상태 변경을 트리거하고 응용 프로그램 내에서 비동기 작업을 관리할 수 있습니다.\n\n우리 애플리케이션에서 useSelector 훅을 사용하는 것은 다음과 같이 보입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst state = useSelector((state:ApplicationState) => state.users);\n```\n\n매번 ApplicationState를 import하는 것은 조금 귀찮을 수 있습니다. 그래서 대신 전체 애플리케이션에서 사용할 수 있는 사용자 정의 훅을 만드는 것을 선호합니다. 제 사용자 정의 훅은 이렇게 생겼어요:\n\n```js\nexport const useAppSelector: TypedUseSelectorHook<ApplicationState> =\n  useSelector;\n```\n\n코드에서 단축키를 만드는 것과 비슷한데요 — 누가 코딩에서 단축키를 좋아하지 않겠어요? 😉\n\n\n<div class=\"content-ad\"></div>\n\n비슷하게, 우리 애플리케이션에서 useDispatch 훅을 사용하는 것은 다음과 같습니다:\n\n```js\nconst dispatch = useDispatch<ApplicationDispatch>();\n```\n\n또한, 반복적으로 ApplicationDispatch를 다루는 것은 번거로울 수 있습니다. 그래서 여기 내가 만든 커스텀 훅이 어떻게 단순화시키는지 알아봅시다:\n\n```js\nexport const useAppDispatch: () => ApplicationDispatch = useDispatch;\n```\n\n<div class=\"content-ad\"></div>\n\n우리가 사용자 정의 훅을 사용할 수 있게 되었으니, 이제 사용자 목록 페이지 구축에 집중해 보겠습니다. Redux 상태에 접근하기 위한 useAppSelector 및 액션을 디스패치하기 위한 useAppDispatch를 사용하여 원활한 사용자 경험을 만들 준비가 되었습니다. 시작해 봅시다!\n\n```js\nimport React, { useEffect } from 'react';\nimport SearchBox from '../components/SearchBox';\nimport {\n  getTopUsersBySize,\n  getUsersBySearch,\n  toggleUserLike,\n} from '../redux/actions/users/actions';\nimport Loading from '../components/Loading';\nimport Error from '../components/Error';\nimport { NavLink } from 'react-router-dom';\nimport { useAppDispatch, useAppSelector } from '../hooks/hooks';\nimport LikeButton from '../components/LikeButton';\n\nconst Home: React.FC = () => {\n  const { loading, users, error } = useAppSelector((state) => state.users);\n  const dispatch = useAppDispatch();\n  const handleSearch = (query: string) => {\n    if (query) {\n      dispatch(getUsersBySearch(query));\n    } else {\n      dispatch(getTopUsersBySize());\n    }\n  };\n  useEffect(() => {\n    dispatch(getTopUsersBySize());\n  }, [dispatch]);\n\n  return (\n    <div className=\"container mx-auto p-4 flex flex-col\">\n      <div className=\"flex justify-center mb-6\">\n        <div className=\"w-2/3\">\n          <SearchBox placeholder=\"Search user...\" onSearch={handleSearch} />\n        </div>\n      </div>\n      <hr />\n      <h2 className=\"text-2xl text-blue-700 font-bold my-4\">\n        Users - {users?.total_count}\n      </h2>\n      {loading ? (\n        <Loading />\n      ) : error ? (\n        <Error message={error} />\n      ) : (\n        <div\n          className=\"flex-grow  overflow-y-auto\"\n          style={{ maxHeight: 'calc(100vh - 300px)' }}\n        >\n          <ul className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6\">\n            {users?.items.map((user) => (\n              <li\n                key={user.login}\n                className=\"flex items-center space-x-4 p-4 bg-white rounded shadow hover:shadow-lg transition-shadow\"\n              >\n                <img\n                  src={user.avatar_url}\n                  alt={`${user.login} avatar`}\n                  className=\"w-16 h-16 rounded-full\"\n                />\n                <div className=\"flex flex-col gap-0.5\">\n                  <span className=\"text-lg text-blue-950 font-medium\">\n                    {user.login}\n                  </span>\n                  <div className=\"flex gap-2\">\n                    <NavLink\n                      className=\"underline underline-offset-2 text-orange-500 hover:text-orange-600\"\n                      to={`/${user.login}/repos`}\n                    >\n                      View repos\n                    </NavLink>\n                    <div>\n                      <LikeButton\n                        liked={!!user.isLiked}\n                        toggleLike={() => dispatch(toggleUserLike(user.id))}\n                      />\n                    </div>\n                  </div>\n                </div>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n- 상태 관리: useAppSelector 훅을 사용하여 Redux 상태에 접근하고, 특히 로딩 상태 (loading), 사용자 데이터 (users), 오류 메시지 (error)가 포함된 state.users에 접근합니다.\n- 디스패치 함수: useAppDispatch는 디스패치 함수 dispatch를 얻기 위해 사용되며, 컴포넌트가 getTopUsersBySize, getUsersBySearch, toggleUserLike와 같은 액션을 디스패치할 수 있도록 합니다.\n\n더 많은 라우팅 코드는 제 저장소에서 확인하실 수 있습니다\n\n\n\n<div class=\"content-ad\"></div>\n\n지금 애플리케이션을 실행하면, 위대한 사용자 목록 페이지가 나타납니다! 축하해요, 성공했어요! 🎉 이 코드를 자유롭게 조작하고 도전하여 자체 Repository 페이지를 구현해 보세요. 그리고 기억하세요, 올바른 방향으로 가는 데 조금의 도움이 필요하다면, 우리의 저장소가 도와드릴 준비가 되어 있어요. 지금 바로 들어가서 새로 만든 것을 탐험해 보세요!\n\n제가 긴 글을 썼다는 것을 알고 있어요, 전통적인 Redux 애플리케이션을 설치하는 것은 실제로 시간이 걸릴 수 있습니다 — 이렇게 강력한 라이브러리조차 비판에 직면하기도 했죠. 하지만 걱정하지 마세요! Redux 팀은 이 피드백을 즐겁게 받아들이고 이러한 문제점을 해결하는 주요 업데이트인 Redux Toolkit을 소개했어요. 마치 Redux가 새 옷을 입고 다시 사랑에 빠지는 것 같아요!\n\n당신의 애플리케이션을 Redux Toolkit으로 마이그레이션하는 방법이 궁금하신가요? 계속 주목해 주세요. 더 간단하고 즐거운 상태 관리를 위한 건박스 스!!\n\n코딩 즐기세요!!!","ogImage":{"url":"/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png"},"coverImage":"/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png","tag":["Tech"],"readingTime":23}],"page":"27","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}