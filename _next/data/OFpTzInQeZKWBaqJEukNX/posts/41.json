{"pageProps":{"posts":[{"title":"API에 대한 동시 요청 처리하기 Nodejs, AWS","description":"","date":"2024-06-20 04:20","slug":"2024-06-20-HandlingConcurrentRequeststoanAPINodejsAWS","content":"\n\n동시에 여러 입찰을 처리하고 실시간 입찰 시스템에서 우승자를 결정하는 것은 데이터 일관성과 공정성을 보장할 때 특히 어려울 수 있습니다. diff database를 사용할 수도 있어요.\n\n단계\n\n## Node.js 서버 설정\n\nExpress 및 Mongoose가 포함된 기본 Node.js 서버를 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm init -y\nnpm install express mongoose body-parser\n```\n\n```js\nsaas-bidding/\n│\n├── models/\n│   ├── bid.js\n│   └── auction.js\n│\n├── routes/\n│   ├── bids.js\n│   └── auctions.js\n│\n├── app.js\n└── config.js\n```\n\nconfig.js\n\n```js\n// config.js\nmodule.exports = {\n  mongoURI: 'mongodb://localhost:27017/saasbidding',\n  port: 3000\n};\n```\n\n<div class=\"content-ad\"></div>\n\n더하기 기호 뒤에 해당 값을 입력하세요:\n\nMongoose 모델 생성\n\n경매 모델 (models/auction.js)\n\n```js\n// models/auction.js\nconst mongoose = require('mongoose');\n\nconst AuctionSchema = new mongoose.Schema({\n  product: { type: String, required: true },\n  startingPrice: { type: Number, required: true },\n  currentHighestBid: { type: Number, default: 0 },\n  highestBidder: { type: mongoose.Schema.Types.ObjectId, ref: 'Bidder' },\n  endTime: { type: Date, required: true }\n});\n\nmodule.exports = mongoose.model('Auction', AuctionSchema);\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// models/bid.js\nconst mongoose = require('mongoose');\n\nconst BidSchema = new mongoose.Schema({\n  auctionId: { type: mongoose.Schema.Types.ObjectId, ref: 'Auction', required: true },\n  bidderId: { type: mongoose.Schema.Types.ObjectId, ref: 'Bidder', required: true },\n  bidAmount: { type: Number, required: true },\n  timestamp: { type: Date, default: Date.now }\n});\n\nmodule.exports = mongoose.model('Bid', BidSchema);\n```\n\n## Express and Mongoose (app.js)\n\n```js\n// app.js\nconst express = require('express');\nconst mongoose = require('mongoose');\nconst bodyParser = require('body-parser');\nconst config = require('./config');\n\nconst app = express();\n\nmongoose.connect(config.mongoURI, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.use(bodyParser.json());\n\n// Routes\napp.use('/bids', require('./routes/bids'));\napp.use('/auctions', require('./routes/auctions'));\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});\n```\n\nBids 및 Auctions에 대한 라우팅\n\n<div class=\"content-ad\"></div>\n\n경매 라우트(Auction Routes)는 다음과 같습니다(routes/auctions.js)\n\n```js\n// routes/auctions.js\nconst express = require('express');\nconst Auction = require('../models/auction');\nconst router = express.Router();\n\n// 새 경매 생성\nrouter.post('/', async (req, res) => {\n  const { product, startingPrice, endTime } = req.body;\n  const auction = new Auction({ product, startingPrice, endTime });\n  await auction.save();\n  res.status(201).send(auction);\n});\n\n// 경매 세부 정보 가져오기\nrouter.get('/:id', async (req, res) => {\n  const { id } = req.params;\n  const auction = await Auction.findById(id).populate('highestBidder');\n  res.send(auction);\n});\n\nmodule.exports = router;\n```\n\n입찰 라우트(Bid Routes)는 다음과 같습니다(routes/bids.js)\n\n```js\n// routes/bids.js\nconst express = require('express');\nconst mongoose = require('mongoose');\nconst Bid = require('../models/bid');\nconst Auction = require('../models/auction');\nconst router = express.Router();\n\n// 입찰하기\nrouter.post('/', async (req, res) => {\n  const session = await mongoose.startSession();\n  session.startTransaction();\n  try {\n    const { auctionId, bidderId, bidAmount } = req.body;\n\n    // 경매 찾기\n    const auction = await Auction.findById(auctionId).session(session);\n    if (!auction) {\n      throw new Error('경매를 찾을 수 없습니다');\n    }\n\n    // 입찰이 현재 최고 입찰보다 높은지 확인\n    if (bidAmount <= auction.currentHighestBid) {\n      throw new Error('입찰 금액은 현재 최고 입찰보다 높아야 합니다');\n    }\n\n    // 새로운 입찰 생성\n    const bid = new Bid({ auctionId, bidderId, bidAmount });\n    await bid.save({ session });\n\n    // 경매에 새로운 최고 입찰로 업데이트\n    auction.currentHighestBid = bidAmount;\n    auction.highestBidder = bidderId;\n    await auction.save({ session });\n\n    await session.commitTransaction();\n    session.endSession();\n    res.status(201).send(bid);\n  } catch (error) {\n    await session.abortTransaction();\n    session.endSession();\n    res.status(400).send({ error: error.message });\n  }\n});\n\n// 특정 경매에 대한 모든 입찰 가져오기\nrouter.get('/:auctionId', async (req, res) => {\n  const { auctionId } = req.params;\n  const bids = await Bid.find({ auctionId }).sort({ timestamp: -1 });\n  res.send(bids);\n});\n\nmodule.exports = router;\n```\n\n<div class=\"content-ad\"></div>\n\n# 동시에 발생하는 입찰 처리\n\n동시에 발생하는 입찰을 효율적으로 처리하기 위해 MongoDB의 세션과 트랜잭션 기능을 사용하여 원자성을 보장합니다. 주요 단계는 다음과 같습니다:\n\n- 세션 및 트랜잭션 시작: 세션을 시작하여 세션 내의 작업이 원자적으로 실행되도록 합니다.\n- 경매 유효성 검사: 경매가 존재하고 유효한지 확인합니다.\n- 입찰 유효성 검사: 현재 가장 높은 입찰가보다 입찰이 높은지 확인합니다.\n- 경매 업데이트: 입찰이 유효한 경우 새로운 최고 입찰가로 경매를 업데이트합니다.\n- 트랜잭션 커밋: 변경 사항을 영구적으로 만들기 위해 트랜잭션을 커밋합니다.\n- 오류 처리: 오류 발생 시 트랜잭션을 중단하여 데이터 일관성을 보장합니다.\n\n# AWS 및 자동 스케일링을 활용하여 더 최적화해봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 주요 구성 요소\n\n- Node.js 어플리케이션: API 요청을 처리합니다.\n- 부하 분산 장치: 여러 인스턴스에 들어오는 트래픽을 분산합니다.\n- 자동 확장: 트래픽에 기반하여 인스턴스 수를 자동으로 조정합니다.\n- 메시지 큐: 입찰 요청을 비동기적으로 처리합니다.\n- 데이터베이스: 동시에 발생하는 쓰기 및 읽기 작업을 효율적으로 처리합니다.\n- 캐시: 읽기 작업을 가속화하고 데이터베이스에 가해지는 부하를 감소시킵니다.\n- 마이크로서비스 아키텍처: 구성요소를 분리하고 특정 작업을 효율적으로 처리합니다.\n\n# AWS 아키텍처\n\n- 탄력적 부하 분산기 (ELB): 입찰 요청을 분산합니다.\n- 자동 확장 그룹: 응용프로그램 인스턴스가 부하를 처리할 수 있는지 확인합니다.\n- Amazon SQS (Simple Queue Service): 입찰 요청 큐를 관리합니다.\n- Amazon RDS/DynamoDB: 경매 및 입찰 데이터를 저장합니다.\n- Amazon ElastiCache (Redis): 빈번하게 액세스되는 데이터를 캐싱합니다.\n- Worker 노드: 큐에서 입찰 요청을 처리합니다.\n- Amazon CloudWatch: 인프라를 모니터링하고 확장합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-HandlingConcurrentRequeststoanAPINodejsAWS_0.png)\n\n단계\n\nnode.js\n\n```js\nnpm init -y\nnpm install express body-parser aws-sdk\n```\n\n<div class=\"content-ad\"></div>\n\nconfig.js\n\n```js\nmodule.exports = {\n  awsRegion: 'us-east-1',\n  sqsQueueUrl: 'YOUR_SQS_QUEUE_URL',\n  mongoURI: 'mongodb://localhost:27017/saasbidding',\n  port: 3000\n};\n```\n\napp.js\n\n```js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst AWS = require('aws-sdk');\nconst config = require('./config');\n\nconst app = express();\napp.use(bodyParser.json());\n\nAWS.config.update({ region: config.awsRegion });\n\nconst sqs = new AWS.SQS();\n\napp.post('/bid', async (req, res) => {\n  const { auctionId, bidderId, bidAmount } = req.body;\n\n  const params = {\n    MessageBody: JSON.stringify({ auctionId, bidderId, bidAmount }),\n    QueueUrl: config.sqsQueueUrl\n  };\n\n  try {\n    await sqs.sendMessage(params).promise();\n    res.status(200).send({ message: 'Bid received' });\n  } catch (error) {\n    res.status(500).send({ error: 'Failed to process bid' });\n  }\n});\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});\n```\n\n<div class=\"content-ad\"></div>\n\nWorker.js 파일 — 이 파일은 SQS에서 메시지를 처리하고 데이터베이스를 업데이트합니다.\n\n```js\nconst AWS = require('aws-sdk');\nconst mongoose = require('mongoose');\nconst Auction = require('./models/auction');\nconst Bid = require('./models/bid');\nconst config = require('./config');\n\nAWS.config.update({ region: config.awsRegion });\n\nconst sqs = new AWS.SQS();\nconst queueUrl = config.sqsQueueUrl;\n\nmongoose.connect(config.mongoURI, { useNewUrlParser: true, useUnifiedTopology: true });\n\nconst processBid = async (message) => {\n  const { auctionId, bidderId, bidAmount } = JSON.parse(message.Body);\n\n  const session = await mongoose.startSession();\n  session.startTransaction();\n  try {\n    const auction = await Auction.findById(auctionId).session(session);\n    if (bidAmount <= auction.currentHighestBid) {\n      throw new Error('Bid amount must be higher than the current highest bid');\n    }\n\n    const bid = new Bid({ auctionId, bidderId, bidAmount });\n    await bid.save({ session });\n\n    auction.currentHighestBid = bidAmount;\n    auction.highestBidder = bidderId;\n    await auction.save({ session });\n\n    await session.commitTransaction();\n    session.endSession();\n  } catch (error) {\n    await session.abortTransaction();\n    session.endSession();\n    throw error;\n  }\n};\n\nconst pollQueue = async () => {\n  const params = {\n    QueueUrl: queueUrl,\n    MaxNumberOfMessages: 10,\n    WaitTimeSeconds: 20\n  };\n\n  try {\n    const data = await sqs.receiveMessage(params).promise();\n    if (data.Messages) {\n      for (const message of data.Messages) {\n        try {\n          await processBid(message);\n          await sqs.deleteMessage({ QueueUrl: queueUrl, ReceiptHandle: message.ReceiptHandle }).promise();\n        } catch (error) {\n          console.error('Failed to process bid', error);\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Failed to receive messages', error);\n  }\n\n  setImmediate(pollQueue);\n};\n\npollQueue();\r\n```\n\n## AWS 리소스 구성\n\n- Elastic Load Balancer: ELB를 설정하여 여러 EC2 인스턴스 간에 들어오는 트래픽을 분산합니다.\n- Auto Scaling 그룹: 트래픽 패턴에 따라 EC2 인스턴스를 추가하거나 제거할 수 있도록 자동 스케일링을 구성합니다.\n- Amazon SQS: 수신된 입찰 요청을 관리하기 위한 SQS 대기열을 생성합니다.\n- Amazon RDS/DynamoDB: 경매 및 입찰 데이터를 처리할 데이터베이스를 설정합니다.\n- Amazon ElastiCache (Redis): 자주 액세스되는 데이터를 캐싱하여 데이터베이스 부하를 줄이기 위해 Redis를 사용합니다.\n- Amazon CloudWatch: 인프라를 모니터링하고 스케일링 이벤트를 트리거할 알림을 설정합니다.\n\n\n<div class=\"content-ad\"></div>\n\n주의 : 이 코드는 샘플입니다. 조심해서 사용해주세요.","ogImage":{"url":"/assets/img/2024-06-20-HandlingConcurrentRequeststoanAPINodejsAWS_0.png"},"coverImage":"/assets/img/2024-06-20-HandlingConcurrentRequeststoanAPINodejsAWS_0.png","tag":["Tech"],"readingTime":9},{"title":"Agora 라이브 비디오 스트림에 실시간 3D 아바타 추가하기","description":"","date":"2024-06-20 04:18","slug":"2024-06-20-AddRealtime3DAvatarstoAgoraLiveVideoStreams","content":"\n\n현재 급속히 변화하는 디지털 환경에서 라이브 스트림 비디오가 주도를 차지하고 있어요. 사용자들은 이제 더 몰입적이고 맞춤형 스트리밍 옵션을 기대하고 있어요. 콘텐츠 크리에이터들은 점점 더 창의적인 방법으로 스트리밍을 하기 위해 노력하고 있어요. 이로 인해 자신의 움직임과 표현을 반영하는 동적 3D 아바타에 대한 수요가 늘어나고 있어요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*dbCqUb7N3awHxQP4xj3ZXA.gif)\n\n실시간 가상 아바타는 전통적으로 복잡한 모션 캡처 장비와 정교한 소프트웨어가 필요했기 때문에 보통 일반 사용자나 독립적인 크리에이터들에게는 접근하기 어려웠어요. 그러나 이 역시 인공지능이 상황을 바꾸는 분야 중 하나에요. 컴퓨터 비전의 발전으로 장치에서 정교한 AI 알고리즘을 실행해서 인간의 얼굴 제스처를 실시간으로 정확하게 캡처하고 디지털 형태로 번역할 수 있게 된 거예요.\n\n이 가이드에서는 MediaPipe와 ReadyPlayerMe의 3D 아바타를 사용해 Agora 라이브 스트림에 3D 가상 아바타를 통합하는 방법을 살펴볼 거예요. 관객 참여도를 높이거나 앱의 비디오 통화/라이브 방송에 창의적 요소를 추가하는 것이 목표라면, 이 안내서는 3D 가상 페르소나를 구현하는 데 필요한 단계를 제공할 거예요.\n\n<div class=\"content-ad\"></div>\n\n# 전제 조건\n\n- Node.JS\n- Agora 개발자 계정\n- HTML/CSS/JS의 기본 지식\n- ThreeJS의 기본 이해\n- Agora - Web QuickStart의 기본 이해\n- 코드 편집기 (저는 VSCode를 사용합니다)\n- ReadyPlayerMe에서 3D 아바타\n\n# Agora + MediaPipe 프로젝트\n\n이 안내서를 간결하게 유지하기 위해 Agora Video SDK를 웹 앱에 구현하는 방법을 이해한다고 가정합니다. 알지 못한다면, 'Building a Group Video Chat Web App' 안내서를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n시작하려면 데모 프로젝트를 다운로드하세요. 코드를 다운로드한 후 터미널에서 프로젝트 폴더로 이동하여 npm을 사용하여 노드 패키지를 설치하십시오.\n\n```js\ngit clone git@github.com:digitallysavvy/agora-mediapipe-readyplayerme.git\ncd agora-mediapipe-readyplayerme\nnpm i\n```\n\n# 핵심 구조 (HTML)\n\nindex.html의 HTML 구조에서 시작해보겠습니다. 본문에서 \"call\" UI 요소가 있는 맨 위에, 원격 비디오를 담을 컨테이너, 로컬 사용자를 담을 컨테이너(음소거 및 음소거 해제를 위한 버튼 포함), 채팅에서 떠나기 위한 버튼이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/agora-box-logo.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" />\n    <title>Agora Live Video Demo</title>\n  </head>\n  <body>\n    <div id=\"container\"></div>\n    <div id=\"local-user-container\"></div>\n    <div id=\"local-media-controls\">\n      <button id=\"mic-toggle\" class=\"media-active\">Mic</button>\n      <button id=\"video-toggle\" class=\"media-active\">Video</button>\n      <button id=\"leave-channel\" class=\"media-active\">Leave</button>\n    </div>\n    <div id=\"overlay\" class=\"modal\">\n      <div id=\"form-container\">\n        <h1 id=\"form-header\">Avatar Video Chat</h1>\n        <form id=\"join-channel-form\">\n          <div id=\"form-body\">\n            <div class=\"form-group\">\n              <label for=\"form-rpm-url\">Ready Player Me URL</label>\n              <input type=\"text\" id=\"form-rpm-url\" placeholder=\"http://models.readyplayer.me/<MODEL-ID>.glb\" class=\"form-control\">\n            </div>\n            <div id=\"form-footer\">\n              <button type=\"submit\" id=\"join-channel-btn\">Join Channel</button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n    <script type=\"module\" src=\"/main.js\"></script>\n  </body>\n</html>\n\n\n투사 UI 외에도 사용자가 아바타 URL을 입력할 수 있는 오버레이 화면과 채널에 참여하는 버튼이 필요합니다.\n\n# Agora Client 및 데이터 저장소\n\nmain.js에 우리는 Agora 클라이언트를 생성하여 Agora의 SDK를 사용하고 로컬 미디어를 사용하여 오디오, 비디오 및 캔버스 트랙과 활성 상태에 대한 참조를 유지합니다. MediPipe의 컴퓨터 비전에서 얻은 데이터를 저장하기 위해 headRotation과 blendShapes가 필요합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// Agora 클라이언트 생성\nconst client = AgoraRTC.createClient({ \n  codec: 'vp9',\n  mode: 'live',\n  role: 'host'\n})\n\nconst localMedia = {\n  audio: {\n    track: null,\n    isActive: false\n  },\n  video: {\n    track: null,\n    isActive: false\n  },\n  canvas: {\n    track: null,\n    isActive: false\n  },\n}\n\n// 원격 스트림을 저장할 컨테이너\nlet remoteUsers = {}                \n\n// 얼굴 특징점 데이터 저장\nlet headRotation\nlet blendShapes\n```\n\n# DOMContentLoaded 및 이벤트 리스너\n\n페이지가 로드될 때, Agora 이벤트, 미디어 컨트롤, 그리고 폼 제출을 위한 리스너를 추가합니다. 리스너가 준비되면, 오버레이 폼을 보여줄 준비가 되었습니다.\n\n```js\n// DOM이 로드될 때까지 기다립니다\ndocument.addEventListener('DOMContentLoaded', async () => {\n  // Agora 이벤트 리스너 추가\n  addAgoraEventListeners()\n  // 로컬 미디어 버튼에 대한 리스너 추가\n  addLocalMediaControlListeners()\n  // 채널 참여 폼 가져오기 & 폼 제출 처리\n  const joinform = document.getElementById('join-channel-form')\n  joinform.addEventListener('submit', handleJoin)\n  // 오버레이 폼 보이기\n  showOverlayForm(true) \n})\n```\n\n<div class=\"content-ad\"></div>\n\n# 3D & 아바타 설정\n\n이 가이드의 선행 요건 중 하나는 ReadyPlayerMe의 3D 아바타입니다. ReadyPlayerMe는 Apple의 ARKit ARFaceAnchor 위치에 대한 이름 규칙을 준수하는 3D 파일을 제공합니다. 이러한 정의는 산업 표준이며 MediaPipe의 출력과 일치합니다.\n\n코드로 돌아와서, 사용자가 \"참가\" 버튼을 클릭하면 ThreeJS 씬을 초기화하고 `canvas`를 localUserContainer에 추가합니다.\n\n```js\n// 로컬 사용자 컨테이너 div 가져오기\nconst localUserContainer = document.getElementById('local-user-container')\n\n// 씬을 만들고 canvas를 localUserContainer에 추가\nconst { scene, camera, renderer } = await initScene(localUserContainer)\n```\n\n<div class=\"content-ad\"></div>\n\n새로 생성된 씬을 사용하여 glbURL을 통해 사용자의 ReadyPlayerMe 아바타를 로드하세요. glbURL에는 URL 매개변수가 추가됩니다. 이는 blend shapes가 ReadyPlayerMe에서 제공하는 기본 .glb 파일의 일부가 아니기 때문입니다. 이러한 매개변수는 ReadyPlayerMe RESTful API의 일부이며, 아바타용입니다.\n\n3D 아바타를 로드한 후, 해당 씬 그래프를 탐색하고 모든 노드를 사용하여 빠르게 headMesh에 액세스할 수 있는 객체를 생성합니다.\n\n```js\n// glb url에 url 매개변수 추가 - morphTargets를 사용하여 ReadyPlayerMe 아바타 로드\nconst rpmMorphTargetsURL = glbURL + '?morphTargets=ARKit&textureAtlas=1024'\nlet nodes\n// morph targets가 포함된 GLB 로드\nconst loader = new GLTFLoader()\nloader.load(rpmMorphTargetsURL, \n  async (gltf) => {\n  const avatar = gltf.scene\n  // 아바타 노드 그래프 작성\n  nodes =  await getGraph(avatar)\n  const headMesh = nodes['Wolf3D_Avatar']\n  // 위치 조정\n  avatar.position.y = -1.65\n  avatar.position.z = 1\n  \n  // 씬에 아바타 추가\n  scene.add(avatar)\n},\n(event) => {\n  // 로딩 세부 정보 출력\n  console.log(event)\n})\n```\n\n씬이 초기화되는 시점과 3D 아바타가 로드되는 시점 간의 지연 시간을 고려하기 위해, 3D 아바타가 씬에 추가되기 전에 모델이 로드 중임을 사용자에게 알리기 위해 로딩 애니메이션을 표시하는 것이 좋은 실천법입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 로딩 애니메이션 표시\nconst loadingDiv = document.createElement('div')\nloadingDiv.classList.add('lds-ripple')\nloadingDiv.append(document.createElement('div'))\nlocalUserContainer.append(loadingDiv)\n\n/* loader.load - 성공 시 콜백 */\nloadingDiv.remove() // 로딩 스피너 삭제\n```\n\n# Agora로 비디오 엘리먼트 초기화\n\n<img src=\"/assets/img/2024-06-20-AddRealtime3DAvatarstoAgoraLiveVideoStreams_0.png\" />\n\n카메라 액세스를 받고 비디오 및 오디오 트랙을 만드는 데 Agora를 사용합니다. 비디오 엘리먼트의 소스로 카메라의 비디오 트랙을 사용할 것입니다. 더 자세한 설명이 필요하면 Agora를 사용하여 사용자 정의 비디오 엘리먼트를 사용하는 방법에 대한 내 안내서를 확인해주세요. \n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 로컬 마이크와 카메라 초기화\nawait initDevices('music_standard', '1080_3')\n// 비디오 요소 생성\nconst video = document.createElement('video')\nvideo.setAttribute('webkit-playsinline', 'webkit-playsinline');\nvideo.setAttribute('playsinline', 'playsinline');\n// 카메라 트랙을 사용하여 새 MediaStream 생성하고 비디오의 소스로 설정\nvideo.srcObject = new MediaStream([localMedia.video.track.getMediaStreamTrack()])\n```\n\n# 미디어파이프 설정\n\n얼굴과 제스처를 인식하기 전에, 미디어파이프의 컴퓨터 비전 기술을 위한 최신 웹어셈블리(WASM) 파일을 먼저 다운로드해야 합니다. 이 파일들은 FaceLandmarker 작업을 설정하는 데 필수적입니다. FaceLandmarker는 비디오 스트림에서 사용자 얼굴의 특정 \"관심 지점\"을 식별하는 컴퓨터 비전 알고리즘입니다. 이 정밀도는 인공지능이 얼굴 특징을 효과적으로 추적할 수 있게 합니다.\n\n컴퓨터 비전에서 작업을 실행하는 것은 AI에 요청을 보내고, AI가 자신감 수준인 예측을 반환하는 것을 의미합니다. 우리는 각 비디오 프레임에 대해 이 작업을 계속 반복적으로 실행할 것이며, 이를 predictionLoop이라고 이름 붙였습니다.\n\n\n<div class=\"content-ad\"></div>\n\n얼굴 랜드마크 구성에서는 FaceLandmarker를 설정하여 두 가지 중요한 데이터 유형을 생성합니다: outputFacialTransformationMatrixes와 outputFaceBlendshapes: true. outputFacialTransformationMatrixes는 얼굴 위치, 회전 및 크기의 추정을 제공하여 머리 움직임을 추적하는 데 필수적입니다. 반면 outputFaceBlendshapes는 즉시 명확하지 않을 수 있습니다. 이는 블렌드 모양 또는 모양 키프라는 3D 모델링 기술을 포함합니다. 이를 통해 3D 메시가 \"닫힘\" (0으로 표시)에서 \"열림\" (1로 표시)으로 부드럽게 전환할 수 있습니다. 이 방법은 모든 가능한 얼굴 움직임을 모델링하는 것을 피할 수 있어 효율적입니다. 대신 렌더링 엔진이 이러한 상태를 보간합니다.\n\n이러한 설정은 머리 회전 및 위치를 모니터링하기 위해 변환 행렬을 사용하고, 블렌드 모양 예측은 ARKit 표준 블렌드 모양에 대해 0에서 1 범위를 제공하여 52가지 다른 얼굴 움직임을 다룹니다.\n\n```js\n// 미디어파이프 비전 작업 초기화\nconst faceLandmarker = await initVision()\n\n// 미디어파이프 비전 초기화\nconst initVision = async () => {\n  // 최신 비전 WASM 파일 로드\n  const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm')\n  // 얼굴 랜드마크 트래커 구성\n  const faceLandmarker = await FaceLandmarker.createFromOptions(\n    vision, { \n      baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,\n      },\n      outputFaceBlendshapes: true,\n      outputFacialTransformationMatrixes: true,\n      runningMode: 'VIDEO'\n    })\n  return faceLandmarker\n}\n```\n\n# 컴퓨터 비전 예측 루프\n\n<div class=\"content-ad\"></div>\n\nfaceLandmarker와 `video/`을 설정하고 나면, 우리는 모든 비디오 프레임에 MediaPipe의 컴퓨터 비전 작업을 실행하는 예측 루프를 시작할 수 있습니다. 예측 결과를 반환하면 facialTransformationMatrixes에 접근할 수 있어 headRotation을 계산할 수 있게 됩니다. 또한, 예측 결과는 얼굴 메시의 블렌드 형태에 대한 추정 가중치를 제공합니다.\n\n```js\nvideo.addEventListener(\"loadeddata\", () => {\n  video.play()                            // 비디오 재생 시작\n  initPredictLoop(faceLandmarker, video)  // 얼굴 랜드마킹 예측 루프 시작\n})\n\nconst initPredictLoop = (faceLandmarker, video) => {\n  // 스트림 재생 시간을 추적하는 플래그\n  let lastVideoTime = -1\n  // 예측 루프\n  const predict = () => {\n    // 타임스탬프 생성\n    const timeInMs = Date.now()\n    // 비디오 재생 중일 때\n    if (lastVideoTime !== video.currentTime) {\n      lastVideoTime = video.currentTime\n      // 비디오 프레임에서 얼굴을 감지하는 비전 작업 실행\n      const result = faceLandmarker.detectForVideo(video, timeInMs)\n      // 얼굴 1에 대한 얼굴 매트릭스 변환 정보 가져오기\n      const faceMatrix = result.facialTransformationMatrixes\n      if (faceMatrix && faceMatrix.length > 0) {\n        const matrix = new THREE.Matrix4().fromArray(faceMatrix[0].data)\n        headRotation =  new THREE.Euler().setFromRotationMatrix(matrix)\n      }\n      // 얼굴 1에 대한 블렌드 형태 예측 가져오기\n      const blendShapePredictions = result.faceBlendshapes\n      if (blendShapePredictions && blendShapePredictions.length > 0){\n        blendShapes = blendShapePredictions[0].categories\n      }\n    }\n    // 모든 프레임 업데이트에서 예측하기\n    requestAnimationFrame(predict)\n  }\n  // 루프 시작\n  requestAnimationFrame(predict)\n}\n```\n\n# 컴퓨터 비전 + 3D 아바타\n\nThreeJS 씬을 렌더링하려면 렌더 루프를 사용합니다. 렌더 루프를 초기화할 때, 예측 루프의 결과를 사용하여 머리 회전과 블렌드 형태 강도를 업데이트하는 함수를 전달할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n// 렌더 루프 만들기\nconst initRenderLoop = (scene, camera, renderer, sceneUpdates) => {\n  const render = (time) => {\n    // 씬 업데이트하기\n    sceneUpdates(time)\n    // 카메라를 사용하여 씬 렌더링\n    renderer.render(scene, camera)\n    // 렌더를 호출 스택에 추가\n    requestAnimationFrame(render)\n  }\n  // 렌더 루프 시작\n  requestAnimationFrame(render)\n}\n\ninitRenderLoop(scene, camera, renderer, (time) => {\n  // 노드 또는 헤드 회전이 null이면 빨리 반환하기\n  if(!nodes || !headRotation) return\n  // 헤드, 목, 어깨 본에 회전 데이터 적용하기\n  nodes.Head.rotation.set(headRotation.x, headRotation.y, headRotation.z)\n  nodes.Neck.rotation.set(headRotation.x/2, headRotation.y/2, headRotation.z/2)\n  nodes.Spine1.rotation.set(headRotation.x/3, headRotation.y/3, headRotation.z/3)\n  // 블렌드 쉐이프 반복하기\n  blendShapes.forEach(blendShape => {\n    const headMesh = nodes.Wolf3D_Avatar\n    const blendShapeIndex = headMesh.morphTargetDictionary[blendShape.categoryName]\n    if (blendShapeIndex >= 0) {\n      headMesh.morphTargetInfluences[blendShapeIndex] = blendShape.score\n    }\n  })\n})\r\n```\n\n기본적으로 입 움직임이 표정을 과장할 때만 보입니다. 말할 때 사람 얼굴이 일반적으로 움직이는 방식은 아닙니다. 이를 보상하기 위해 블렌드 쉐이프 점수를 과장하여 아바타의 입이 더 반응적으로 보이도록 할 수 있습니다.\n\n타겟으로 정할 모든 블렌드 쉐이프를 나열하고 기본 점수에 대한 배수를 설정합시다. 입이 움직이지 말아야 할 때나 과장해서 나타내지 않도록, 상한선과 하한선을 설정해보겠습니다.\n\n```js\r\n// 입 블렌드 쉐이프\nconst mouthBlendShapes = [\n  'mouthSmile_L', 'mouthSmile_R', 'mouthFrown_L','mouthFrown_R',\n  'mouthOpen', 'mouthPucker','mouthWide','mouthShrugUpper','mouthShrugLower',\n]\n// 입 움직임 강조를 위한 배수\nconst exagerationMultiplier = 1.5\nconst threshold ={ min: 0.25, max: 0.6}\r\n```\n\n<div class=\"content-ad\"></div>\n\n멀티플라이어를 적용하려면 mouthBlendShapes 목록에서 특정 키를 확인해야 합니다. 이 작업은 점수를 적용하는 루프 내에서 처리할 수 있습니다. mouth 블렌드 모양을 식별할 때 동시에 그것들이 임계값 내에 있는지도 확인할 것입니다.\n\n```js\n// 블렌드 모양 반복\nblendShapes.forEach(blendShape => {\n  const headMesh = nodes.Wolf3D_Avatar\n  const blendShapeIndex = headMesh.morphTargetDictionary[blendShape.categoryName]\n  if (blendShapeIndex >= 0) {\n    // mouth 블렌드 모양에 대한 점수를 과장\n    if (mouthBlendShapes.includes[blendShape.categoryName] && blendShape.score > threshold.min && blendShape.score < threshold.max) {\n      blendShape.score *= exagerationMultiplier\n    }\n    headMesh.morphTargetInfluences[blendShapeIndex] = blendShape.score\n  }\n})\n```\n\n# ThreeJS에서 Agora 비디오 스트림으로\n\n![이미지](/assets/img/2024-06-20-AddRealtime3DAvatarstoAgoraLiveVideoStreams_1.png)\n\n<div class=\"content-ad\"></div>\n\n렌더 루프는 3D 씬을 캔버스에 렌더링합니다. `canvas`에서 Agora로 씬을 전송하려면 captureStream을 생성하고 비디오 트랙을 사용하여 사용자 지정 비디오 트랙을 초기화하십시오.\n\n더 자세한 설명이 필요하시다면 캔버스 엘리먼트를 사용하여 Agora 비디오 트랙을 생성하는 방법을 안내하는 내 안내서를 확인해보세요.\n\n```js\n// 캔버스 가져오기\nconst canvas = renderer.domElement\n// 프레임 속도 설정\nconst fps = 30\n// captureStream 생성\nconst canvasStream = canvas.captureStream(fps)\n// 캔버스 스트림으로부터 비디오 트랙 가져오기\nconst canvasVideoTrack = canvasStream.getVideoTracks()[0]\n// canvasVideoTrack을 사용하여 사용자 지정 Agora 비디오 트랙 생성\nconst customAgoraVideoTrack = AgoraRTC.createCustomVideoTrack({\n  mediaStreamTrack: canvasVideoTrack,\n  frameRate: fps\n})\nlocalMedia.canvas.track = customAgoraVideoTrack\nlocalMedia.canvas.isActive = true\n// 캔버스 트랙을 채널에 게시\nawait client.publish([localMedia.audio.track, localMedia.canvas.track])\n```\n\n로컬 클라이언트가 채널에 참여하면, 이전에 설정한 이벤트 리스너가 동작합니다. 사용자가 채널에 참여할 때마다 그들의 비디오 스트림이 #container에 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 테스트\n\nVite를 사용하고 있으므로 로컬에서 테스트하기 쉽습니다. 터미널에서 프로젝트 폴더로 이동하고 npm을 사용하여 코드를 실행하세요.\n\n```js\nnpm run dev\n```\n\n로컬 서버가 실행되면 코드를 테스트할 시간입니다. ReadyPlayer.Me로 이동하여 아바타의 URL을 복사하세요. URL을 양식에 붙여넣고 \"가입\"을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n채널에서 여러 사용자를 시뮬레이션하려면 첫 번째 탭에서 URL을 복사한 다음 다른 브라우저 창을 열고 URL을 붙여넣으세요. URL을 복사하는 것은 동일한 채널에 참여할 수 있도록 돕습니다. 두 창을 사용하면 각 캔버스가 보이게 됩니다. 이는 브라우저가 웹사이트의 탭이 초점을 잃으면 AnimationFrame 요청을 일시 중지하기 때문에 중요합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*TVz9rtnQHNU4yDco9nH6BQ.gif)\n\n여러 기기로 테스트하려면 프로젝트를 안전한 https 연결로 실행해야 합니다. 이를 설정하려면 두 가지 옵션이 있습니다: 로컬 장치에 사용자 정의 SSL 인증서를 구성하거나 ngrok와 같은 서비스를 사용하여 로컬 기기에서 나가는 터널을 생성하고 https URL을 제공합니다.\n\n# 끝.\n\n<div class=\"content-ad\"></div>\n\n여기에 Agora의 Video SDK를 사용하여 MediaPipe의 컴퓨터 비전을 활용하여 사용자 정의 3D 아바타를 만드는 방법이 있습니다. 웨비나, 대화형 교육 플랫폼 또는 라이브 비디오가 핵심 역할을 하는 다른 어플리케이션을 위해 이 예시는 훌륭한 기반입니다. 이 코드를 조정하고 사용하여 현실을 확장하는 더 복잡한 AI 기반 기능을 만들어 보세요.\n\n이 안내서는 Agora의 Raw Video와 Custom Video와 같은 두 가지 고급 비디오 주제를 다룹니다. Agora Video for Web 문서에서 고급 비디오 주제를 더 깊이 파고들어 보세요.","ogImage":{"url":"/assets/img/2024-06-20-AddRealtime3DAvatarstoAgoraLiveVideoStreams_0.png"},"coverImage":"/assets/img/2024-06-20-AddRealtime3DAvatarstoAgoraLiveVideoStreams_0.png","tag":["Tech"],"readingTime":15},{"title":"지금 언급한 콘텐츠와 관련하여 다음과 같이 번역할 수 있습니다 아주 똑똑하지만 노력을 하지 않는 개발자 대처 방법어떻게 하면 좋을까요 이제 한번 살펴보겠습니다","description":"","date":"2024-06-20 04:17","slug":"2024-06-20-HowDoYouDealwithaVerySmartDeveloperWhoIsntWorkingHard","content":"\n\n## 프로그래밍 의견\n\n![이미지](/assets/img/2024-06-20-HowDoYouDealwithaVerySmartDeveloperWhoIsntWorkingHard_0.png)\n\n만약 텔레비전을 조립하는 조선라인에 있다고 상상해보세요. 예를 들어, 누군가가 몇 분동안 자신의 작업을 멈추면 곧바로 제품 생산량이 줄어들게 됩니다. 이는 돈으로 환산하면 제품 제작 비용이 증가하는 것을 의미합니다.\n\n불행히도, 이러한 관리 방식으로 소프트웨어 개발자도 관리하려고 합니다. 그리고 이때 이러한 종류의 질문들이 나오게 됩니다. 소프트웨어 개발자의 작업은 더 많은 숙련이 필요한데, 모든 종류의 숙련된 작업에서는 좋은 것을 만들어내는 능력이 항상 시간과 경험에 의존적입니다.\n\n<div class=\"content-ad\"></div>\n\n경험이 적을수록 품질이 좋은 것을 만드는 데 걸리는 시간이 더 오래 걸리고, 경험이 많을수록 품질이 좋은 것을 만드는 데 걸리는 시간이 덜 걸립니다. 이것을 조각을 만드는 것에 비유할 수 있겠네요. 이에 자질을 비교해보면, 보스나 관리자로서 결과물을 평가하는 것이 더 중요합니다. 빠르게 행동한다면, 1시간이건 1일이건 상관없죠.\n\n그것은 비용과 대조되는데, 우리가 예산을 갖고 있다면 일정 시간보다 더 오래 걸리게 허용할 수 없죠. 하지만 그것은 개발자가 하는 것이 아니라 관리자의 역할입니다. 개발자는 문제나 작업을 받아서 얼마나 걸리는지 말하고 그 시간 안에 작업이 완료될 것을 확약해야 합니다. 관리자가 그것이 실행 가능한지 여부를 결정하는 사람입니다.\n\n프로젝트 리더 직책에 대한 면접에서, 어떻게 일할 것인지에 대해 물어보았습니다. 제 경우, 프로세스를 실행하고 인프라를 구축하며 소프트웨어 개발자와 제 자신의 삶을 더 쉽게 만들기 위해 훈련합니다.\n\n인터뷰어는 나의 의도를 완벽하게 요약하고 이해한 것을 알려주었지만 한 가지 문제가 있었습니다. 언젠가 내일은 모양새가 되고 노력이 줄어들 것이라고 깨달았다고 합니다.\n\n<div class=\"content-ad\"></div>\n\n일단 그를 웃게 했다. 정확히 그의 말대로, 그 프로세스를 실행한 후, 하루 중 대부분의 시간을 아무것도 하지 않게 될 것이라고 한다. 하루 중 대부분을 아무것도 안 하게 되는 것이 문제라고 했다. 비록 현재의 팀보다 4배 더 효율적이고 생산적인 팀을 만들어낼 것이라고 해도 말이다.\n\n노력보다 생산성을 중요시하는 것이 문제다. 상사들은 늦게까지 남아 있는 사람, 주말에 출근하는 사람, 자녀의 생일을 놓치는 사람, 병원에 어머니와 같이 출근하는 사람, 5년간 휴가를 안 낸 사람들을 더욱 높이 평가하는 경향이 있다. 8시에서 5시에 출퇴근하는 사람을 아주 추하게 여기는 것이다.\n\n생산성이 전부다. 그러한 재능 있는 사람을 갖게 되면, 진짜 생산성을 기준으로 측정하는 법을 배워야 한다: 얼마나 빨리 작업을 끝내는지, 코드에서 버그가 얼마나 생기는지, QA가 티켓을 얼마나 자주 반납하는지 등을 통해.\n\n반대 특성을 가진 사람을 가지고 있는 것은 매우 비용이 많이 든다. 그들이 일을 많이 하고 있을지도 모르지만, 제품을 계속 실패 없이 전달할 수 없다면, 고객이 요청하지 않은 것을 하게 된다. 천 번을 설명해야 할지도 모른다. 그렇다, 비용이 많이 들고, 이것은 팀이 가진 문제다.\n\n<div class=\"content-ad\"></div>\n\n물론, 그렇다고 해서 당신이 질서 정연하거나 규칙을 어기는 허락을 받지 않아야 한다는 뜻은 아닙니다. 대신 그 대신, 그의 생산성을 유지하는 방법을 찾는 것이 여러분의 역할이 될 것입니다 (바쁘다는 것과는 다릅니다).\n\n# Stackademic 🎓\n\n마지막까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 박수를 보내고 작성자를 팔로우 해주세요! 👏\n- 저희를 팔로우하세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Differ\n- Stackademic.com에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-06-20-HowDoYouDealwithaVerySmartDeveloperWhoIsntWorkingHard_0.png"},"coverImage":"/assets/img/2024-06-20-HowDoYouDealwithaVerySmartDeveloperWhoIsntWorkingHard_0.png","tag":["Tech"],"readingTime":2},{"title":"Astro 기반 문서에 다중 버전 지원 추가하기","description":"","date":"2024-06-20 04:15","slug":"2024-06-20-AddingMulti-VersionSupporttoYourAstro-basedDocumentation","content":"\n\n## 같은 문서 안에 여러 버전을 가질 수 있는 방법은 무엇인가요?\n\n![Image](/assets/img/2024-06-20-AddingMulti-VersionSupporttoYourAstro-basedDocumentation_0.png)\n\n현재 Astro는 매우 인기가 높습니다. 저에게 물어봐도 마찬가지에요. 이 프레임워크를 사용하면 개발자들이 유연하고 강력한 정적 웹사이트를 만들 수 있습니다.\n\n다른 곳에서 이주할 때 여러 렌더링 라이브러리를 통합할 수 있는 능력은 채택을 도와 줍니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 문서 사이트를 만드는 것은 아마도 지금 이 시점에서는 사소한 문제일지 모르지만, 최근에 해결해야 했던 문제인 문서 사이트에 다중 버전 지원을 추가하는 방법에 대해 다루고 싶었습니다.\n\n그러니 시작해 봅시다.\n\n# 문제\n\n문서 사이트를 구축하는 것은 많은 페이지로 이루어진 정적 사이트를 구축하는 것 이상을 의미하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n용하기 쉬우면 Astro를 사용하면 간단합니다.\n\n그러나 제품 버전이 변경될 때 페이지가 변경되면 어떻게 됩니까?\n\n그럴 때 해결해야할 두 가지 주요 문제가 있습니다:\n\n- 쉬운 문제: 라우팅 프로세스에 버전을 추가합니다. 버전 간에 전환할 수 있어야하며, Astro는 파일 경로 기반의 라우팅을 사용하므로 각 버전에 대한 폴더를 만들어야 합니다.\n- 어려운 문제: 현재 버전에 맞게 모든 상대적 링크를 처리하고 내부 탐색을 일관되게 유지해야 합니다 (현재 선택된 버전에 따라 동일한 링크가 다른 버전으로 리디렉트되어야 합니다).\n\n<div class=\"content-ad\"></div>\n\n이 문제들은 사소해 보일 수 있지만 쉽게 해결되지 않습니다.\n\n두 기능을 모두 구현하는 방법을 살펴보겠습니다.\n\n# 문제 해결\n\n해결해야 할 문제는 두 가지이므로 한 가지씩 해결해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n## 라우팅 프로세스에 버전 추가하기\n\n가장 쉬운 방법은 /docs/getting-started와 같은 경로에서 /docs/1.1.0/getting-started로 이동하는 것을 확인하는 것입니다.\n\n이렇게 하면 해당 페이지의 내용으로 사용할 getting-started.mdx 파일을 여전히 참조할 수 있고, 해당 파일에 접근하려면 1.1.0이라는 폴더 안에 넣어야 합니다.\n\n이것은 단순한 것으로 보이네요. 해야 할 일은 폴더 구조를 변경하는 것뿐입니다. 따라서 이렇게 변경해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n/\n |_ docs\n     |_ v1.0.0\n     |  |_ getting-started.mdx\n     |\n     |_ v2.0.0\n        |_ getting-started.mdx\n```\n\n위와 같이 변경해 주세요. 변경 후에 Astro가 콘텐츠를 찾을 수 있도록 알려주었으며, 이제 Astro는 제대로 동작할 것입니다. 이제 npm run build를 실행하면 모든 것이 제대로 빌드되지만 새로운 폴더에 생성될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 아직 끝나지 않았어요. 이것은 1단계의 반만이에요. 우리는 아직 버전 지원의 중요한 부분을 놓치고 있어요. 바로 버전 전환기에요.\n\n사용자가 버전을 변경할 수 있는 방법을 추가해야 해요. 그래서 그 코드를 살펴보도록 해요:\n\n원하는 곳에 추가할 수 있는 간단한 컴포넌트에요. 저는 대개 문서 사이트에 추가하는 헤더에 추가하는 것을 좋아해요. 하지만 당신이 원하는 대로 사용할 수 있어요.\n\n코드를 보면, 컴포넌트는 VERSIONS 배열 내에 나열된 버전을 기반으로 버전 드롭다운을 그려줄 거에요. 거기서 표시할 레이블과 경로를 가져올 거에요.\n\n<div class=\"content-ad\"></div>\n\n최신 버전에서는 경로가 없다는 것을 주목해주세요. 이렇게 하면 최신 버전을 루트 폴더 아래의 docs 폴더에 유지하고, 버전이 명시된 경우에만 버전 폴더를 사용할 수 있게 됩니다.\n\n그런 다음 JavaScript 코드의 일부로 selectCurrentVersion 함수가 실행됩니다. 이 함수는 URL에서 버전 번호를 가져와 올바른 옵션 요소를 선택합니다.\n\n마지막으로 드롭다운에서 onChange 이벤트가 발생하면 updateLocation 함수를 호출합니다. 이 함수는 선택한 버전으로 현재 경로 내의 현재 버전을 덮어씁니다. 그런 다음 사용자를 새 URL로 리디렉션합니다.\n\n그런데 잠깐, 이제 새 버전을 릴리스할 때마다 문서 링크를 모두 확인하고 사용자가 버전 간을 이동하는 것을 방지하기 위해 내부 링크를 업데이트해야 한다는 말인가요?\n\n<div class=\"content-ad\"></div>\n\n그렇게하면 정말 귀찮을 텐데, 특히 문서가 충분히 큰 경우 말이죠. 그래서 이에 대해 처리할 방법을 찾아보겠습니다.\n\n## 모든 상대 링크 처리\n\n문서에 추가하는 하드코딩된 경로에 실제 문서 버전을 유지하는 것을 피할 방법을 찾아야 합니다.\n\n왜냐하면 그렇게 한다면 각 새 버전을 릴리스할 때마다 최신 버전의 문서를 복제해야 하기 때문에 매번 검색 및 교체 프로세스를 실행해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 우리가 그것을 잊어버리거나 어떠한 이유로 인해, 검색 패턴이 모든 URL을 포착하지 못하면, 결함이 있는 문서 사이트가 공개될 수 있습니다.\n\n우리는 항상 현재 버전을 생각하고, 대안 버전의 문서가 없는 것처럼 다른 섹션에 링크를 걸어야 한다는 방법을 찾아야 합니다.\n\n내가 생각해낸 해결책은 브라우저에서 URL을 직접 수정하는 스크립트를 추가하는 것이었습니다:\n\n그 스크립트를 내 메인 레이아웃 파일의 하단에 넣었습니다. 그렇게 하면 컨텐츠가 로드될 때 스크립트가 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n해당 코드는 모든 링크를 실행하고, 사이트 도메인 내의 장소로 리디렉션하는 링크를 찾습니다 (이상적으로 \"docs.yourdomain.com\"과 같은 것) 그 중에서만 현재 버전이 있는 새 링크로 변경합니다.\n\n다시 말해, /docs/getting-started와 같은 상대적 링크를 가져와 현재 선택된 버전에 맞게 /docs/v1.0.0/getting-started로 동적으로 변환합니다. 이렇게하면 모든 상대적 링크 (내비게이션에 사용되는 링크)가 현재 선택된 버전에 자동으로 맞춰집니다.\n\n그게 전부에요. Astro는 정적 사이트에 JavaScript를 추가하고 컴포넌트를 만들 때 매우 유연성을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n이 예제들은 두 가지 다른 사용 사례를 보여줍니다. 하나는 동적 부분이 있는 컴포넌트가 생성될 때이며, 서버에서 드롭다운이 렌더링되더라도 여전히 작동하도록하기 위해 추가적인 JS 코드를 추가해야 합니다.\n\n다른 한편으로, 모든 서버 사이드 렌더링된 링크는 동적으로 업데이트되어야 합니다(사실 내부 네비게이션만 해당됩니다), 그래서 해당 작업을 수행하는 스크립트를 페이지에 추가했습니다. 우리는 다른 UI 라이브러리를 사용할 필요가 없었습니다.\n\n이러한 유형의 문제를 이전에 마주쳤나요? 그 문제를 어떻게 해결했나요?\n\n# 레고처럼 재사용 가능한 컴포넌트로 앱을 개발하세요\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-AddingMulti-VersionSupporttoYourAstro-basedDocumentation_1.png)\n\nBit’s open-source tool helps over 250,000 developers build apps with components.\n\nEasily turn any UI, feature, or page into a reusable component — and share it across your applications. Collaborate more efficiently and build faster.\n\n→ Learn more\n\n\n<div class=\"content-ad\"></div>\n\n앱을 컴포넌트로 분리하여 앱 개발을 쉽게 만들고, 원하는 작업을 위한 최상의 경험을 즐기세요:\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n<div class=\"content-ad\"></div>\n\n## → Monorepo\n\n# Learn more","ogImage":{"url":"/assets/img/2024-06-20-AddingMulti-VersionSupporttoYourAstro-basedDocumentation_0.png"},"coverImage":"/assets/img/2024-06-20-AddingMulti-VersionSupporttoYourAstro-basedDocumentation_0.png","tag":["Tech"],"readingTime":5},{"title":"MERN 스택에서 사용자 인증 시스템 이해하기 단계별 안내  파트1 - 서버 사이드","description":"","date":"2024-06-20 04:13","slug":"2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide","content":"\n\n안녕하세요 개발자 여러분! 이 이야기에서는 서버 및 클라이언트 측을 모두 포함한 인증 시스템을 구축할 것입니다. 그러나 이 부분에서는 서버 측만 구축할 것입니다.\n\n이 프로젝트의 레포지토리 링크는 다음과 같습니다. 미리 확인해보세요.\n\n## 목차\n\n- 소개\n- 프로젝트 설정하기\n- 환경 변수 설정하기\n- 데이터베이스 구성하기\n- 모델 생성하기\n- 컨트롤러 구축하기\n- 미들웨어 구현하기\n- 라우트 설정하기\n- 서버 테스트하기\n\n<div class=\"content-ad\"></div>\n\n## 1. 소개\n\n인증은 모든 애플리케이션의 중요한 부분입니다. 사용자가 자신이 주장하는 대로인지 확인하고 그들이 자격이 있는 리소스에 액세스할 수 있도록 보장합니다. 이 안내서에서는 Node.js, Express 및 JWT (JSON Web Tokens)를 사용하여 간단한 토큰 기반 인증 시스템을 구축할 것입니다.\n\n이야기 끝에 프로젝트 폴더 구조는 다음과 같이 보일 것입니다:\n\n![프로젝트 폴더 구조](/assets/img/2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide_0.png)\n\n<div class=\"content-ad\"></div>\n\n그럼 시작해보겠습니다!\n\n## 2: 프로젝트 설정\n\n먼저, 프로젝트를 설정해보겠습니다. 터미널을 열고 아래 명령어를 실행해주세요:\n\n```bash\nmkdir user-auth-system\ncd user-auth-system\nmkdir server\nmkdir client\ncd server\nnpm init -y\n```\n\n<div class=\"content-ad\"></div>\n\n프로젝트 폴더를 만들었는데 서버 및 클라이언트 폴더를 모두 포함하고 있어요. 하지만 클라이언트 쪽은 Part 2에서 만들 거에요. 이제 프로젝트의 서버 쪽에 사용할 필수 패키지를 설치해봐요.\n\n다음 패키지들을 사용할 거에요:\n\n- 서버용으로 express\n- 토큰 처리를 위한 jsonwebtoken\n- 패스워드 해싱을 위한 bcryptjs\n- 환경 변수를 관리하는 dotenv\n- 데이터베이스용으로 mongoose\n- Node.js 서버를 자동으로 재시작하는 nodemon\n- Cross-Origin Resource Sharing를 활성화하기 위한 cors\n\n아래 명령어를 실행하여 이러한 모든 패키지를 설치해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install express jsonwebtoken bcryptjs dotenv mongoose nodemon cors\n```\n\n## 3. 환경 변수 설정\n\n루트 디렉터리에 .env 파일을 만들고 다음 환경 변수를 추가하세요.\n\n```js\nMONGO_URI=\"mongodb://127.0.0.1/UserAuthSystem\" // 본인의 정보로 대체해주세요\nPORT=5000\nJWT_SECRET=your_jwt_secret_key\n```\n\n<div class=\"content-ad\"></div>\n\n- JWT_SECRET: JWT(JSON Web Token) 비밀 키는 토큰을 서명하고 확인하기 위해 사용되는 문자열입니다. 신뢰할 수 있는 출처에서 발급되었으며 조작되지 않았음을 서버가 확인하여 토큰의 무결성과 신뢰성을 보장합니다. 비밀 키를 문서에 책임을 증명하는 서명이나 봉인과 같다고 생각해보세요.\n- MONGO_URI: MongoDB URI는 응용 프로그램을 MongoDB 데이터베이스에 연결하는 연결 문자열입니다. 데이터베이스 주소, 포트 번호, 데이터베이스 이름 및 인증 자격 증명과 같은 정보를 포함합니다. 데이터베이스의 소포 주소처럼 생각해보세요. 응용 프로그램이 데이터베이스를 찾고 통신할 수 있도록 하는 것입니다. 사용자는 로컬 및 클라우드 기반 연결 문자열을 모두 사용할 수 있습니다.\n\n보안상의 이유로 Node.js 프로젝트의 .env 파일은 민감한 정보가 버전 관리에서 노출되지 않도록 .gitignore 파일에 포함되어야 합니다.\n\n## 4. 서버 생성\n\nserver.js라는 파일을 만들어 간단한 Express 서버를 만들어봅시다. 다음 코드를 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nrequire(\"dotenv\").config();\nconst express = require(\"express\");\nconst app = express();\nconst cors = require(\"cors\");\n\nrequire(\"./config/db\");\n\n//Middlewares\napp.use(cors());\napp.use(express.json());\n\nconst PORT = process.env.PORT || 5000;\napp.listen(PORT, () => console.log(`SERVER RUNNING ON PORT: ${PORT}`));\n```\n\n아래 명령으로 코드를 실행할 수 있습니다:\n\n```js\nnode src/server.js\n```\n\n서버를 시작하는 데 nodemon 패키지를 사용할 수도 있습니다. nodemon을 사용하면 파일 변경 후 서버를 다시 시작할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 package.json 파일의 scripts 섹션을 업데이트해야 합니다:\n\n```json\n \"scripts\": {\n    \"start\": \"node src/server.js\",\n    \"dev\": \"nodemon src/server.js\"\n  },\n```\n\n이제 다음 명령어를 실행해주세요:\n\n```bash\nnpm run dev\n```\n\n<div class=\"content-ad\"></div>\n\n터미널에서 포트 5000에서 서버가 실행 중임을 확인해야 해요. 확인되면 좋아요! 우리 서버가 가동 중이에요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:900/0*0feaPgbIGqHg0vXg.gif)\n\n## 5. 데이터베이스 구성\n\n데이터베이스로 MongoDB를 사용할 거예요. 데이터베이스 연결을 구성하기 위해 src/config 폴더에 db.js 파일을 생성해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst mongoose = require(\"mongoose\");\nmongoose\n  .connect(process.env.MONGO_URI)\n  .then(() => console.log(\"DATABASE CONNECTED\"))\n  .catch((err) => {\n    console.log(\"DATABASE CONNECTION ERROR\", err);\n    process.exit(1);\n  });\n```\n\nURL 'mongodb://127.0.0.1/UserAuthSystem'를 로컬에서 사용할 수 있습니다. 그러나 여기서 온라인 데이터베이스를 생성할 수도 있습니다. 프로젝트를 생성한 다음 클러스터를 만들면 됩니다. 거기서 얻은 URL을 사용하여 자신의 데이터베이스를 사용할 수 있습니다. 양쪽 모두 문제없이 작동합니다.\n\n## 6. 모델 생성\n\n다음으로 src/models/User.js에 User 모델을 생성해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst mongoose = require(\"mongoose\");\nconst bcrypt = require(\"bcryptjs\");\n\nlet UserSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: true,\n    index: true,\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    match: [/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/],\n  },\n  password: {\n    type: String,\n    required: true,\n    select: false,\n  },\n  created_at: {\n    type: String,\n  },\n});\n\nUserSchema.pre(\"save\", async function (next) {\n  if (!this.isModified(\"password\")) {\n    return next();\n  }\n  const salt = await bcrypt.genSalt(10);\n  this.password = await bcrypt.hash(this.password, salt);\n  next();\n});\n\nmodule.exports = mongoose.model(\"user\", UserSchema);\n```\n\n- 사용자 문서를 저장하기 전에, 사전 저장 후크가 암호가 수정되었는지 확인합니다.\n- 암호가 수정되었으면, bcryptjs를 사용하여 솔트를 생성하고 암호를 해시하여 데이터베이스에 저장합니다.\n\n## 7. Controllers 만들기\n\n컨트롤러는 route의 로직을 처리합니다. 이제 src/controllers 폴더에 authController.js를 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst bcrypt = require(\"bcryptjs\");\nconst jwt = require(\"jsonwebtoken\");\nconst { check, validationResult } = require(\"express-validator\");\n\nconst User = require(\"../models/User\");\n\nasync function Login(req, res) {\n  try {\n    await check(\"email\", \"유효한 이메일을 입력해주세요\").isEmail().run(req);\n    await check(\"password\", \"비밀번호를 입력해주세요\").exists().run(req);\n\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n\n    const { email, password } = req.body;\n\n    let user = await User.findOne({ email }).select(\"+password\");\n    if (!user) {\n      return res.status(400).json({\n        msg: \"유효하지 않은 자격 증명\",\n        success: false,\n      });\n    }\n\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) {\n      return res.status(400).json({\n        msg: \"유효하지 않은 자격 증명\",\n        success: false,\n      });\n    }\n\n    jwt.sign(\n      { id: user._id },\n      process.env.JWT_SECRET,\n      { expiresIn: \"10m\" },\n      (err, token) => {\n        if (err) throw err;\n        res.status(200).json({\n          token,\n        });\n      }\n    );\n  } catch (err) {\n    console.log(err);\n    res.status(400).json({ success: false });\n  }\n}\n\nasync function Register(req, res) {\n  try {\n    await check(\"username\", \"사용자 이름을 입력해주세요\").not().isEmpty().run(req);\n    await check(\"email\", \"유효한 이메일을 입력해주세요\").isEmail().run(req);\n    await check(\"password\", \"비밀번호는 6자 이상이어야 합니다\")\n      .isLength({ min: 6 })\n      .run(req);\n\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() }); \n    }\n\n    const { username, email, password } = req.body;\n\n    let user = await User.findOne({ email });\n    if (user) { \n      return res.status(400).json({ \n        msg: \"이미 등록된 사용자\",\n        success: false,\n      });\n    }\n\n    user = new User({\n      username,\n      email,\n      password,\n    });\n\n    await user.save();\n\n    jwt.sign(\n      { id: user._id },\n      process.env.JWT_SECRET,\n      { expiresIn: 36000 },\n      (err, token) => {\n        if (err) throw err;\n        res.status(200).json({\n          token,\n        });\n      }\n    );\n  } catch (err) {\n    console.log(err);\n    res.status(400).json({ success: false });\n  }\n}\n\nasync function GetUser(req, res) {\n  try {\n    const user = await User.findById(req.user.id);\n    res.status(200).json({\n      user,\n      success: true,\n    });\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).json({ msg: \"서버 에러\" });\n  }\n}\n\nmodule.exports = { Login, Register, GetUser };\n``` \n\n- 이 컨트롤러 파일은 로그인, 등록 및 사용자 데이터 가져오기와 같은 핵심 기능을 제공하며, 인증을 위해 JSON Web Token을 활용합니다. 이러한 기능을 라우트에서 사용할 것입니다.\n- 인증 시스템의 로그인 및 등록 부분에서 토큰이 생성됩니다. 이 토큰은 클라이언트로 보내는 응답에 포함됩니다. 인증 검증에 중요한 역할을 합니다. 또한 클라이언트 측에서 토큰은 후속 사용을 위해 쿠키에 저장됩니다.\n- express-validator npm 패키지를 사용하여 이메일 및 비밀번호가 제공되고 유효한지 확인합니다.\n\n## 8. 미들웨어 구현\n\n토큰을 확인하기 위한 미들웨어가 필요합니다. 계속하기 전에 미들웨어가 무엇인지 설명드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- 미들웨어는 웹 애플리케이션에서 요청이 최종 라우트 핸들러에 도달하기 전에 처리하는 함수입니다. 인증, 로깅 또는 요청 및 응답 객체 수정과 같은 작업을 처리할 수 있습니다.\n- 미들웨어를 공항의 보안 점검 및 프로세스와 비슷하게 생각해보세요. 비행기를 탑승하기 전에 보안, 세관, 탑승 등 다양한 점검점을 거치는 것처럼 요청도 최종 라우트 핸들러에 도달하기 전에 여러 미들웨어 함수를 거칩니다. 각 미들웨어는 특정 작업을 수행한 다음 요청을 다음 미들웨어로 전달하여 코드를 모듈화하고 재사용 가능하게 만듭니다.\n\n우리는 src/middlewares/verifyAuth.js에서 이를 달성합니다.\n\n```js\nconst jwt = require(\"jsonwebtoken\");\nmodule.exports = (req, res, next) => {\n  const token = req.header(\"x-token\");\n  if (!token) {\n    return res.status(401).json({\n      msg: \"유효한 토큰이 없습니다\",\n      success: false,\n    });\n  }\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    req.user = decoded;\n    next();\n  } catch (err) {\n    res.status(400).json({\n      msg: \"유효한 토큰이 없습니다\",\n      success: false,\n    });\n  }\n};\n```\n\n- 이 코드 스니펫은 x-token으로 할당된 요청 헤더에서 토큰을 확인합니다.\n- 토큰이 유효하면 토큰을 디코드하고 디코딩된 사용자 정보를 req.user에 할당한 다음 next()를 호출하여 제어를 다음 미들웨어 또는 라우트 핸들러로 전달합니다.\n\n<div class=\"content-ad\"></div>\n\n## 9. 라우트 설정하기\n\n이제 라우트를 설정해봅시다. src/routes 폴더에 auth.js를 생성하세요.\n\n```js\nconst express = require(\"express\");\nconst { Login, Register, GetUser } = require(\"../controllers/authController\");\nconst verifyAuth = require(\"../middlewares/verifyAuth\");\n\nconst router = express.Router();\n\nrouter.post(\"/login\", Login);\n\nrouter.post(\"/register\", Register);\n\nrouter.get(\"/user\", verifyAuth, GetUser);\n\nmodule.exports = router;\n```\n\n또한 server.js 파일을 업데이트하여 라우트를 연결해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nrequire(\"dotenv\").config();\nconst express = require(\"express\");\nconst app = express();\nconst cors = require(\"cors\");\n\nrequire(\"./config/db\");\n\n//Middlewares\napp.use(cors());\napp.use(express.json());\n\n// Routes\napp.use(\"/\", require(\"./routes/auth\"));\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`));\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:960/0*ggZsEOvbfphfI42C.gif\" />\n\n## 10. 서버 테스트하기\n\n이제 서버를 테스트해보는 시간입니다. 제대로 작동하는지 확인해봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n- npm run dev 명령어로 서버를 다시 실행한 후 Postman과 같은 API 플랫폼을 사용하여 /register 및 /login 엔드포인트를 테스트해보세요.\n- 또는 다른 쉬운 방법을 제안할 수도 있어요. VS Code 확장 프로그램인 REST Client를 사용해보세요.\n\n![이미지](/assets/img/2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide_1.png)\n\n- 이 확장 프로그램을 활용하기 위해 .rest 확장자를 가진 파일을 생성해야 해요. 그 파일에 HTTP 메서드를 입력하고 간편하게 요청을 보낼 수 있어요. 이 방법을 사용하여 라우트를 테스트하는 것을 선호한다면 이 방법을 사용할 수도 있어요.\n\n다음은 routes.rest 파일 내용입니다.\n\n<div class=\"content-ad\"></div>\n\n\nPOST http://localhost:3000/login\nContent-Type: application/json\n\n{\n    \"email\":\"test@gmail.com\",\n    \"password\":\"123456\"\n}\n\n###\n\nPOST http://localhost:3000/register\nContent-Type: application/json\n\n{\n    \n    \"email\":\"test@gmail.com\",\n    \"username\":\"alitalhacoban\",\n    \"password\":\"123456\"\n}\n\n###\n\nGET http://localhost:3000/user\nContent-Type: application/json\nx-token:your_access_token\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:990/0*Fl_hEz8V6Z0DRz88.gif\" />\n\n이 글에서는 간단한 토큰 기반 인증 시스템을 Node.js에서 구축했습니다. 이 설정은 Node.js 애플리케이션에서 안전한 인증을 구현하기 위한 견고한 기반을 제공합니다. Part 2에서는 이 프로젝트의 클라이언트 측을 구축하여 인증용 사용자 인터페이스를 만드는 방법과 서버와의 연결 방법에 대해 살펴볼 것입니다.\n\n이 글이 여러분에게 도움이 되기를 바랍니다. 계속 주시고 이와 같은 내용을 더 원하시면 박수를 치세요! 즐거운 코딩하세요!\n\n\n<div class=\"content-ad\"></div>\n\n아래 링크를 확인해 보세요.\n\n- cobanalitalha@gmail.com\n- github.com/carpodok\n- linkedin.com/alitalhacoban","ogImage":{"url":"/assets/img/2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide_0.png"},"coverImage":"/assets/img/2024-06-20-UnderstandingUserAuthenticationSystemtheMERNStackAStep-by-StepGuidePart1-ServerSide_0.png","tag":["Tech"],"readingTime":11},{"title":"Vue3에서 구성 요소 간 통신하는 9가지 방법","description":"","date":"2024-06-20 04:12","slug":"2024-06-20-9WaysofComponentCommunicationinVue3","content":"\n\n![이미지](/assets/img/2024-06-20-9WaysofComponentCommunicationinVue3_0.png)\n\n# 개요\n\n- props / emit\n- provide / inject\n- Pinia\n- expose / ref\n- attr\n- v-model\n- mitt.js\n- Slots\n- Teleport\n\n# Props / Emit\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트는 props를 사용하여 데이터를 자식 컴포넌트로 전달하고, 자식 컴포넌트는 이벤트를 사용하여 부모 컴포넌트에 데이터를 전달합니다.\n\n부모 컴포넌트에서 데이터를 자식 컴포넌트로 전달합니다.\n\n```js\n// Parent.vue에서 전송\n<child :msg2=\"msg2\"></child>\n<script setup lang=\"ts\">\n    import child from \"./child.vue\"\n    import { ref, reactive } from \"vue\"\n    const msg2 = ref<string>(\"자식 컴포넌트로 전송되는 메시지 2입니다\")\n    // 복잡한 타입의 경우\n    const msg2 = reactive<string>([\"하위 컴포넌트로 전송되는 메시지 2입니다\"])\n</script>\n\n// Child.vue에서 수신\n<script setup lang=\"ts\">\n    // import 할 필요 없이 직접 사용합니다\n    // import { defineProps } from \"vue\"\n    interface Props {\n      msg1: string\n      msg2: string\n    }\n    const props = withDefaults(defineProps<Props>(), {\n      msg1: '',\n      msg2: '',\n    })\n    console.log(props) // { msg2: \"하위 컴포넌트로 전송되는 메시지 2입니다\" }\n</script>\r\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트가 setup() 메서드를 사용하고 자식 컴포넌트가 script setup 구문을 사용하는 경우, 부모의 데이터에서 속성을 전달받지 못하며 부모의 setup 함수에서 전달받은 속성만 받을 수 있습니다.\n\n부모 컴포넌트가 script setup 구문을 사용하고 자식 컴포넌트가 setup() 메서드를 사용하는 경우, 자식은 부모의 데이터 및 setup 함수에서 속성을 모두 받을 수 있습니다. 그러나 자식 컴포넌트가 setup에서 속성을 받으려면 부모의 setup 함수에서만 속성을 받을 수 있고 데이터 속성에서는 받을 수 없습니다.\n\n자식 컴포넌트가 부모로 데이터를 전달\n\n```js\n// Child.vue dispatch\n<template>\n    // 방법 1\n    <button @click=\"emit('myClick')\">버튼</button>\n    // 방법 2\n    <button @click=\"handleClick\">버튼</button>\n</template>\n<script setup lang=\"ts\">\n    \n    // 방법 1: Vue3.2 버전에 적합, import 필요 없음\n    // import { defineEmits } from \"vue\"\n    // 방법 1에 대응\n    const emit = defineEmits([\"myClick\",\"myClick2\"])\n    // 방법 2에 대응\n    const handleClick = ()=>{\n        emit(\"myClick\", \"부모 컴포넌트로 전송된 메시지입니다\")\n    }\n    \n    // 방법 2: Vue3.2 버전에 적합하지 않음, useContext()는 사용이 중단됨\n    import { useContext } from \"vue\"\n    const { emit } = useContext()\n    const handleClick = () => {\n        emit(\"myClick\", \"부모 컴포넌트로 전송된 메시지입니다\")\n    }\n</script>\n\n// Parent.vue response\n<template>\n    <child @myClick=\"onMyClick\"></child>\n</template>\n<script setup lang=\"ts\">\n    import child from \"./child.vue\"\n    const onMyClick = (msg: string) => {\n        console.log(msg) // 부모 컴포넌트가 받은 메시지입니다\n    }\n</script>\r\n```\n\n<div class=\"content-ad\"></div>\n\n# 제공 / 주입\n\n이 매커니즘은 부모로부터 하위 구성 요소 중 어떤 것이든 종속성 주입을 개발하는 데 사용됩니다. 반드시 직계 자식 구성 요소일 필요는 없습니다.\n\n제공: 우리가 지정한 데이터를 주입할 수 있도록 합니다.\n\n주입: 어떠한 하위 구성 요소에서도 이 구성 요소에 추가하고 싶은 데이터를 수신합니다. 구성 요소가 얼마나 심층적으로 중첩되었는지와는 관계없이 직접 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// Parent.vue\n<script setup>\n    import { provide } from \"vue\"\n    provide(\"name\", \"Jhon\")\n</script>\n\n// Child.vue\n<script setup>\n    import { inject } from \"vue\"\n    const name = inject(\"name\")\n    console.log(name) // Jhon\n</script>\n```\n\n# Pinia\n\nPinia는 Vuex의 대체로 설계된 새로운 Vue 상태 관리 라이브러리입니다.\n\n```js\n// main.ts\nimport { createPinia } from 'pinia'\ncreateApp(App).use(createPinia()).mount('#app')\n\n// /store/user.ts\nimport { defineStore } from 'pinia'\nexport const userStore = defineStore('user', {\n    state: () => {\n        return { \n            count: 1,\n            arr: []\n        }\n    },\n    getters: { ... },\n    actions: { ... }\n})\n\n// Page.vue\n<template>\n    <div>{ store.count }</div>\n</template>\n<script lang=\"ts\" setup>\nimport { userStore } from '../store'\nconst store = userStore()\n// 분해할당\n// const { count } = userStore()\n</script>\n```\n\n<div class=\"content-ad\"></div>\n\n# 노출 / 참조\n\n참조는 부모 구성 요소가 자식 구성 요소의 인스턴스나 요소에 직접 액세스하는 데 사용될 수 있습니다.\n\n```js\n// Child.vue\n<script setup>\n    // 방법 1 Vue 3.2 버전에 적합하지 않으며,이 버전에서 useContext()는 사용되지 않습니다.\n    import { useContext } from \"vue\"\n    const ctx = useContext()\n    // 노출된 속성 및 메서드 등\n    ctx.expose({\n        childName: \"이것은 자식 구성 요소의 속성입니다\",\n        someMethod(){\n            console.log(\"이것은 자식 구성 요소의 메서드입니다\")\n        }\n    })\n    \n    // 방법 2 Vue 3.2 버전에 적합하며, import할 필요가 없습니다.\n    // import { defineExpose } from \"vue\"\n    defineExpose({\n        childName: \"이것은 자식 구성 요소의 속성입니다\",\n        someMethod(){\n            console.log(\"이것은 자식 구성 요소의 메서드입니다\")\n        }\n    })\n</script>\n\n// Parent.vue  참조 ref=\"comp\"\n<template>\n    <child ref=\"comp\"></child>\n    <button @click=\"handlerClick\">버튼</button>\n</template>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref } from \"vue\"\n    const comp = ref(null)\n    const handlerClick = () => {\n        console.log(comp.value.childName) // 자식 구성 요소에서 노출된 속성 가져오기\n        comp.value.someMethod() // 자식 구성 요소에서 노출된 메서드 호출\n    }\n</script>\r\n```\n\n# attrs\n\n<div class=\"content-ad\"></div>\n\n\nattrs: 부모 스코프에서 클래스 및 스타일을 제외한 컬렉션을 포함합니다.\n\n```js\n// Parent.vue에서 전송\n<child :msg1=\"msg1\" :msg2=\"msg2\" title=\"3333\"></child>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref, reactive } from \"vue\"\n    const msg1 = ref(\"1111\")\n    const msg2 = ref(\"2222\")\n</script>\n\n// Child.vue에서 수신\n<script setup>\n    import { defineProps, useAttrs } from \"vue\"\n    const props = defineProps({\n        msg1: String\n    })\n\n    const attrs = useAttrs()\n    console.log(attrs) // { msg2:\"2222\", title: \"3333\" }\n</script>\n```\n\n# v-model\n\n여러 데이터 요소에 대한 양방향 데이터 바인딩을 지원합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// Parent.vue\n<child v-model:key=\"key\" v-model:value=\"value\"></child>\n<script setup>\n    import child from \"./child.vue\"\n    import { ref, reactive } from \"vue\"\n    const key = ref(\"1111\")\n    const value = ref(\"2222\")\n</script>\n\n// Child.vue\n<template>\n    <button @click=\"handlerClick\">Button</button>\n</template>\n<script setup>\n    \n    // Method 1은 useContext()이 폐기됨에 따라 Vue 3.2 버전에 적합하지 않습니다.\n    import { useContext } from \"vue\"\n    const { emit } = useContext()\n    \n    // Method 2는 Vue 3.2 버전에 적합하며, import 할 필요가 없습니다.\n    // import { defineEmits } from \"vue\"\n    const emit = defineEmits([\"key\",\"value\"])\n    \n    // 사용법\n    const handlerClick = () => {\n        emit(\"update:key\", \"새로운 키\")\n        emit(\"update:value\", \"새로운 값\")\n    }\n</script>\r\n```\n\n# mitt.js\n\nVue3에서는 컴포넌트간 통신을 위한 EventBus가 더 이상 사용되지 않지만, EventBus와 동일한 원리를 기반으로 하는 mitt.js라는 대체 방법이 새롭게 도입되었습니다.\n\n```js\r\n// mitt.js\nimport mitt from 'mitt'\nconst mitt = mitt()\nexport default mitt;\n\n// 컴포넌트 A\n<script setup>\nimport mitt from './mitt'\nconst handleClick = () => {\n    mitt.emit('handleChange')\n}\n</script>\n\n// 컴포넌트 B \n<script setup>\nimport mitt from './mitt'\nimport { onUnmounted } from 'vue'\nconst someMethed = () => { ... }\nmitt.on('handleChange',someMethed)\nonUnmounted(()=>{\n    mitt.off('handleChange',someMethed)\n})\n</script>\r\n```\n\n<div class=\"content-ad\"></div>\n\n# 슬롯\n\n슬롯은 부모 구성 요소가 자식 구성 요소의 콘텐츠 일부를 제어할 수 있도록 합니다. 재사용 가능하고 유연한 구성 요소 템플릿을 만드는 데 유용합니다.\n\n## 기본 슬롯\n\n```js\n// Parent.vue\n<FancyButton>\n  Click me! <!-- 슬롯 콘텐츠 -->\n</FancyButton>\n\n// Child.vue\n<button class=\"fancy-btn\">\n  <slot></slot> <!-- 슬롯 출력 -->\n</button>\n```\n\n<div class=\"content-ad\"></div>\n\n## 이름이 지정된 슬롯\n\n이름이 지정된 슬롯은 기본 슬롯을 기반으로 한 분류이며, 내용물을 해당 자리 표시자에 일치시키는 것으로 이해할 수 있습니다.\n\n```js\n// Parent.vue\n<template>\n  <Child>\n    <template v-slot:monkey>\n      <div>monkey</div>\n    </template>\n\n    <button>Click me!</button>\n  </Child>\n</template>\n\n// Child.vue\n<template>\n  <div>\n    <!-- 기본 슬롯 -->\n    <slot></slot>\n    <!-- 이름이 지정된 슬롯 -->\n    <slot name=\"monkey\"></slot>\n  </div>\n</template>\n```\n\n## 스코프 있는 슬롯\n\n<div class=\"content-ad\"></div>\n\n슬롯의 내용은 자식 컴포넌트의 상태에 액세스할 수 없습니다. 그러나 경우에 따라 슬롯의 내용이 부모 컴포넌트의 sphere와 자식 컴포넌트의 sphere에서 데이터를 사용하고 싶을 수 있습니다. 이를 달성하기 위해서는 렌더링 시 자식 컴포넌트가 슬롯에 데이터를 제공할 수 있는 방법이 필요합니다.\n\n```js\n// Parent.vue\n<template>\n  <!-- v-slot=\"{scope}\"은 자식 컴포넌트에서 전달된 데이터를 수신하는 데 사용됩니다 -->\n  <!-- :list=\"list\"은 리스트를 자식 컴포넌트에 전달합니다 -->\n  <Child v-slot=\"{scope}\" :list=\"list\">\n    <div>\n      <div>Name: { scope.name }</div>\n      <div>Occupation: { scope.occupation }</div>\n      <hr>\n    </div>\n  </Child>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport Child from './components/Child.vue'\n\nconst list = ref([\n  { name: 'Jhon', occupation: 'Thundering'},\n  ...\n])\n</script>\n\n// Child.vue\n<template>\n  <div>\n    <!-- 각 항목을 반환하려면 :scope=\"item\"을 사용합니다 -->\n    <slot v-for=\"item in list\" :scope=\"item\" />\n  </div>\n</template>\n\n<script setup>\nconst props = defineProps({\n  list: {\n    type: Array,\n    default: () => []\n  }\n})\n</script>\r\n```\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n<div class=\"content-ad\"></div>\n\n- 작가에게 박수와 팔로우를 부탁드립니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Differ\n- 더 많은 콘텐츠: Stackademic.com","ogImage":{"url":"/assets/img/2024-06-20-9WaysofComponentCommunicationinVue3_0.png"},"coverImage":"/assets/img/2024-06-20-9WaysofComponentCommunicationinVue3_0.png","tag":["Tech"],"readingTime":9},{"title":"자바스크립트 101 타이머에 대해 알아보기","description":"","date":"2024-06-20 04:10","slug":"2024-06-20-JavaScript101AllAboutTimers","content":"\n\n## 타이머는 사용 방법을 알고 있다면 강력한 도구가 될 수 있어요\n\n![JavaScript timers](/assets/img/2024-06-20-JavaScript101AllAboutTimers_0.png)\n\n자바스크립트 타이머는 주기적인 동작을 달성하거나 지연된 작업을 트리거하는 데 훌륭한 도구입니다.\n\n어떤 시간 기반 논리를 가지고 있던, 타이머가 답이 될 거예요.\n\n<div class=\"content-ad\"></div>\n\n하지만 그들이 어떻게 작동하는지 완전히 이해하지 못한다면, JavaScript로 만들어진 벽에 머리를 맞추게 될 거예요.\n\n가용한 타이머들과 그 작동 방식을 살펴보겠습니다.\n\n# 타이머에 대해 기억해야 할 주요 사항\n\n타이머의 세부사항에 대해 깊이 들어가기 전에, 타이머에 대해 기억해야 할 중요한 몇 가지 사항이 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 정확하지는 않아요\n\n타이머는 일정한 시간 후에 작업을 트리거하거나 지정된 시간이 지날 때마다 작업을 반복합니다.\n\n하지만 여러분이 엄밀히 1초마다 정확하게 작동한다고 기대할지도 모릅니다. 그러나 실제로는 그렇지 않습니다.\n\n이러한 타이머의 사양에 따르면 시간 매개변수(즉, 지정한 시간(초) 수)를 최소 대기 시간으로 사용할 것이라고 명시되어 있지만, 다른 작업이 먼저 완료되어야 할 경우에는 더 긴 시간이 소요될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n정확한 시간 측정에 의존하는 로직, 예를 들어 setInterval 콜백으로 초를 세는 시계가 있을 때에만 문제가 될 수 있습니다.\n\n이 점을 염두에 두고 타이머를 사용한다면 안전합니다.\n\n## 비동기 함수들입니다\n\n즉, 이들은 완료될 때까지 프로그램 흐름을 멈추지 않습니다. 타임아웃 값을 0으로 지정해도 그들의 동작은 여전히 비동기적일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 함수들은 원하는 함수에 대한 참조를 이벤트 루프에 추가하므로, 타임아웃 값에 0을 지정해도 해당 참조는 그 다음에 오는 모든 작업 이후에 예약됩니다.\n\n# setTimeout 이해하기\n\nsetTimeout 함수는 아마도 가장 이해하기 쉬운 함수일 것입니다. 주된 목적은 일정 시간 후에 함수를 트리거하는 것입니다.\n\n이 함수는 다음을 받습니다:\n\n<div class=\"content-ad\"></div>\n\n- 실행할 함수에 대한 참조입니다. 시간이 지나면 트리거될 코드입니다.\n- 함수가 실행되기 전의 초 단위의 숫자입니다.\n- 그 외의 모든 매개변수는 동일한 순서로 실행된 함수로 전달됩니다.\n\n따라서 다음 코드는 3초 후에 \"Hello World\"를 출력합니다:\n\n이 작업이 작동하는 이유는 console.log 함수가 받은 모든 매개변수를 연결하고 문자열을 출력하기 때문입니다.\n\n그러나 대신 다음과 같은 것이있는 경우 어떻게 됩니까:\n\n<div class=\"content-ad\"></div>\n\n14번 줄은 작동하지만, 16번 줄은 동작하지 않습니다. 이는 호출된 함수의 실행 컨텍스트가 변하기 때문입니다. 사실, 전역 범위로 변경됩니다. Node에서는 global, 브라우저에서는 window 입니다.\n\n두 경우 모두 함수의 this가 변경되므로, 16번 줄이 실행될 때 this.c에 대한 참조가 더 이상 존재하지 않습니다.\n\n따라서 이 문제를 해결하려면 다음과 같이 간단히 wrapper 함수를 만들 수 있습니다:\n\n16번 줄에 추가한 wrapper 익명 함수에 주목해 주세요. 이제 익명 함수가 두 매개변수와 함께 호출될 때, 해당 함수 내에서 바로 c.log를 call 메서드로 호출합니다 (모든 함수에 있는 메서드입니다). 우리는 call 메서드를 사용하는데, 이는 익명 함수에 의해 수신된 인수를 직접 log 메서드로 전달하기 때문입니다. 우리는 동적 방식으로 이동하고 있기 때문에 call을 사용하지 않고는 이 작업을 수행할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n익명 함수에 하드 코딩된 매개변수가 있다면 다음과 같이 log 메서드를 직접 호출할 수 있습니다:\n\nsetTimeout은 특별한 종류의 비동기 함수이므로 그 이후에 작성하는 모든 코드가 해당 함수가 트리거되기 전에 실행됩니다:\n\n해당 코드의 출력은 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-20-JavaScript101AllAboutTimers_1.png)\n\n<div class=\"content-ad\"></div>\n\n세트 타임아웃에서 9번째 줄이 타임아웃이 0인데도 마지막으로 실행된다는 것에 주목해 보세요.\n\n## 그리고 한 가지!\n\nsetTimeout에 대해 다시 한 번 살펴보기 전에, 타임아웃 값을 설정하고 실행을 중단해야 하는 경우에는 어떻게 해야 할까요? 실행되기 전에 타이머를 중지하려면 반환된 값(타이머 ID)을 저장하면 됩니다.\n\n그 값은 clearTimeout 함수와 함께 사용하여 타이머가 트리거되기 전에 중지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이전에 있던 코드를 편집해봅시다. 이번에는 첫 번째 타임아웃을 제거해 보겠습니다:\n\n위 코드를 사용하면 첫 번째 타이머가 코드를 실행하기 전에 제거되어 문자열 \"Third! (1)\"이 출력되지 않을 것입니다.\n\n하지만 만약 이 타이머를 제거하는 대신에 몇 초마다 반복하도록 하고 싶다면 어떻게 해야 할까요? 그런 경우 setTimeout은 한계가 있고, 그의 형제인 setInternval을 사용할 수 있습니다.\n\n# setInterval 이해하기\n\n<div class=\"content-ad\"></div>\n\nsetInterval 함수는 setTimeout과 매우 유사하지만, 함수를 한 번만 트리거하는 대신 그 함수를 멈출 때까지 계속해서 실행합니다.\n\n이 함수의 시그니처는 setInterval과 정확히 동일하며, 모든 매개변수에 대한 설명도 동일합니다.\n\n트리거된 함수 내에서 this의 컨텍스트에 대한 제한 사항도 마찬가지입니다. 해결책 또한 동일하게 래퍼 함수를 사용하는 것입니다.\n\n위 코드는 1초마다 실행되는 루프를 시작하며, 실행될 때마다 무작위 이름이 선택되어 \"Hello `name`\" 문자열이 출력됩니다.\n\n<div class=\"content-ad\"></div>\n\n뿐만 아니라, 무한 루프를 4초 후에 타임아웃하여 clearTimeout 함수를 호출하여 종료하는 타임아웃을 설정하고 있습니다. 물론 clearInterval 함수도 있지만, 동일한 타이머 풀을 사용하기 때문에 서로 교차하여 사용할 수 있습니다.\n\n타이머는 반복적이거나 지연된 동작을 생성하는 훌륭한 도구이며, 특히 일정 시간 기반 조건하에서 다른 서비스와 상호 작용해야 할 때 유용합니다.\n\n타임아웃과 간격 모두 clear* 함수를 사용하여 트리거되기 전에 중지할 수 있습니다. 돌려받은 함수 호출 ID를 유지했다면 언제든지 가능합니다.\n\nJavaScript에서 타이머에 대해 더 궁금한 사항이 있으신가요? 댓글에 질문을 남겨주시면 최선을 다해 답변해 드리겠습니다!\n\n<div class=\"content-ad\"></div>\n\n# 리고처럼 재사용 가능한 컴포넌트로 앱을 개발하세요\n\n![JavaScript 101](/assets/img/2024-06-20-JavaScript101AllAboutTimers_2.png)\n\nBit의 오픈소스 도구는 25만 명 이상의 개발자들이 컴포넌트로 앱을 개발하는 데 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 컴포넌트로 변환하고, 여러 애플리케이션에서 공유할 수 있습니다. 협업이 쉽고 개발 속도도 빨라집니다.\n\n<div class=\"content-ad\"></div>\n\n→ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 쉽게 만들고, 원하는 작업 흐름에 대한 최상의 경험을 즐기세요:\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n<div class=\"content-ad\"></div>\n\n## - 코드 공유 및 재사용\n\n## - Monorepo\n\n# 자세히 알아보기","ogImage":{"url":"/assets/img/2024-06-20-JavaScript101AllAboutTimers_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScript101AllAboutTimers_0.png","tag":["Tech"],"readingTime":4},{"title":"7 개의 오픈 소스 프로젝트, 여러분이 알아두어야 할 것 JavaScript 편 ","description":"","date":"2024-06-20 04:09","slug":"2024-06-20-7OpenSourceProjectsYouShouldKnowJavaScriptEdition","content":"\n\n![이미지](/assets/img/2024-06-20-7OpenSourceProjectsYouShouldKnowJavaScriptEdition_0.png)\n\n안녕하세요 👋🏼\n이 글에서는 JavaScript로 작성된 알아두어야 할 7개의 오픈 소스 저장소를 살펴볼 것입니다. 제 눈길을 끈 흥미로운 프로젝트들을 공유하고 싶어요.\n시작해봅시다 🤙🏼\n\n## Appwrite\n\nAppwrite는 웹, 모바일, 네이티브 또는 백엔드 앱을 위한 종단 간 백엔드 서버입니다.\n사용자 인증, 사용자 및 팀 데이터를 저장하고 쿼리하는 데이터베이스, 저장 및 파일 관리, 이미지 조작, 클라우드 함수 등의 서비스와 쉽게 앱을 통합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## melonJS\n\nmelonJS는 개발자와 디자이너가 내용에 집중할 수 있도록 돕는 HTML5 게임 엔진입니다.\n이 프레임워크는 풍부한 구성 요소 모음과 다양한 타사 도구 지원을 제공합니다.\nPhaser와 같은 다른 JavaScript 게임 엔진에 대한 대안이 됩니다🤞\n\n## GDevelop\n\nGDevelop는 또 다른 무료, 오픈소스 게임 엔진으로 PC나 휴대폰과 같은 다양한 플랫폼에서 구축할 수 있습니다.\n이 게임 엔진의 독특한 점은 조건과 액션을 기반으로 한 논리 시스템을 사용하기 때문에 코드를 사용하지 않고 비디오 게임을 만들 수 있다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## Egg.js\n\nEgg.js는 사용자의 키 입력을 감지하여 웹 이스터 에그를 쉽게 추가할 수 있는 간단한 라이브러리입니다.\n사용하기 쉽고 정말 재밌어요 🤣\n\n## API Vault\n\nAPI Vault는 JavaScript로 작성된 멋진 프로젝트입니다. 이 프로젝트는 온라인 플랫폼으로, 공개 API들의 세계로 이어지는 게이트웨이 역할을 합니다.\n카테고리별로 API를 필터링하고 자신에게 맞는 API를 찾을 수도 있어요 🖐\n\n<div class=\"content-ad\"></div>\n\n## sweetalert2\n\nsweetalert2는 외부 종속성 없이 JavaScript의 팝업 상자를 대체하는 아름다운, 반응형, 사용자 정의 가능하며 접근성이 좋은 도구입니다. 주로 JavaScript 프로젝트를 위해 설계되었으며 Angular, React, Vue와 같은 세 가지 대형 프론트엔드 프레임워크와 통합할 수 있습니다.\n\n## Video.js\n\nVideo.js는 HTML 비디오 및 미디어 소스 확장을 지원하는 웹 비디오 플레이어로 유튜브 및 비메오와 같은 다른 재생 기술도 지원합니다. 데스크탑 및 모바일 디바이스에서 비디오 재생을 지원합니다.\nsweetalert2와 마찬가지로 이 라이브러리를 Angular, React, Vue 세 가지 JavaScript 프레임워크와 통합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n여기에는 사용하거나 기여할 가치가 있는 7개의 오픈 소스 프로젝트가 나열되어 있습니다🖖 즐거운 코딩하세요!✨\n\n안녕하세요👋🏻\n제 이름은 도메니코이고, Vue.js 프레임워크에 열정을 가진 소프트웨어 개발자입니다. 제 지식과 경험을 공유하기 위해 이에 대한 기사를 씁니다. 제 프로젝트를 발견하려면 내 Linktree를 방문하지 않길 잊지 마세요🫰🏻\n\n제 Linktree를 확인해보세요👇🏻","ogImage":{"url":"/assets/img/2024-06-20-7OpenSourceProjectsYouShouldKnowJavaScriptEdition_0.png"},"coverImage":"/assets/img/2024-06-20-7OpenSourceProjectsYouShouldKnowJavaScriptEdition_0.png","tag":["Tech"],"readingTime":2},{"title":"전략 패턴 NET C","description":"","date":"2024-06-20 04:08","slug":"2024-06-20-StrategyPatternNETC","content":"\n\n전략(pattern) 패턴은 알고리즘의 동작을 런타임(runtime)에서 선택할 수 있게 해주는 행동 디자인 패턴입니다. 주요 아이디어는 알고리즘의 집합을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만드는 것입니다. 전략(pattern) 패턴은 알고리즘을 사용하는 클라이언트로부터 독립적으로 알고리즘을 변경할 수 있게 합니다.\n\n## 구성 요소\n\n- 컨텍스트(Context): Strategy 인스턴스에 대한 참조를 포함하는 클래스입니다. 이는 전략(strategy)이 작동하는 방법의 세부 정보를 이해하지 않고도 작업의 실행을 전략(strategy)의 구현에 위임합니다.\n- 전략(strategy) 인터페이스: 이는 모든 구체적인 전략(strategy)들을 위한 공통 인터페이스를 정의합니다. 컨텍스트가 전략을 실행하는 데 사용하는 메서드를 선언합니다.\n- 구체적인 전략(strategy): 전략(strategy) 인터페이스를 구현하는 개별 클래스입니다. 각각은 다른 알고리즘이나 작업 수행 방법을 나타냅니다.\n\n## 원칙과 정책\n\n<div class=\"content-ad\"></div>\n\n- 변이의 캡슐화: 전략 패턴은 알고리즘의 변하는 부분을 유지되는 부분과 캡슐화합니다. 이는 알고리즘의 변경이 클라이언트 코드에 영향을 미치지 않는다는 것을 의미합니다.\n- 인터페이스에 프로그래밍, 구현에 프로그래밍하지 말기: 클라이언트는 구현이 아닌 인터페이스를 통해 전략과 상호작용합니다. 이는 클라이언트 코드가 인터페이스를 구현하는 어떤 전략과도 작동할 수 있다는 것을 의미합니다.\n- 상속보다 구성을 선호: 상속하는 대신 전략 패턴은 구성을 사용하여 책임을 전략 객체에 위임합니다. 이는 적절한 동작을 선택하는 더 많은 유연성을 제공합니다.\n- 개방/폐쇄 원칙: 시스템은 확장을 위해 열려 있지만 수정에 대해 폐쇄되어야 합니다. 새로운 전략을 추가할 때 콘텍스트나 클라이언트 코드가 시스템을 사용하는 방식을 변경하지 않아도 됩니다.\n- 단일 책임 원칙: 각 전략 클래스는 특정 알고리즘이나 동작을 나타내는 단일 책임이 있습니다. 이로 인해 이해하기 쉽고 구현하고 테스트하기 쉽습니다.\n\n이러한 원칙을 따르면 전략 패턴은 다양한 알고리즘이나 동작을 처리하는 유연한 구조를 제공하여 애플리케이션의 기능적 부분을 관리, 확장 및 수정하기 쉽도록 만들어줍니다.\n\n# 결제 처리 시스템\n\n크레딧 카드, PayPal 또는 암호화폐와 같이 다양한 결제 전략이 필요한 결제 처리 시스템을 고려해 봅시다. 결제 전략은 종종 변경되거나 추가가 필요할 수 있어 전략 패턴에 적합한 사용 사례입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-StrategyPatternNETC_0.png\" />\n\n# 전략 패턴 없이\n\n초기에 시스템은 신용카드 결제만 지원할 수 있으므로 직접 클래스 내에 구현할 수 있습니다.\n\n```js\npublic class PaymentProcessor\n{\n    public void ProcessPayment(decimal amount, string method)\n    {\n        if (method == \"CreditCard\")\n        {\n            // 신용카드 결제 처리 로직\n            Console.WriteLine($\"신용카드를 통한 {amount} 처리 중\");\n        }\n    }\n}\n\n// 사용법\nvar paymentProcessor = new PaymentProcessor();\npaymentProcessor.ProcessPayment(100.00m, \"CreditCard\");\n```\n\n<div class=\"content-ad\"></div>\n\n이제 PayPal을 결제 방법으로 추가해야 한다고 가정해 보겠습니다. PaymentProcessor 클래스를 수정하여 다른 if-else 조건을 추가해야 할 수 있습니다.\n\n```js\npublic class PaymentProcessor\n{\n    public void ProcessPayment(decimal amount, string method)\n    {\n        if (method == \"CreditCard\")\n        {\n            // 신용카드 결제 처리 로직\n            Console.WriteLine($\"신용카드로 {amount} 처리중\");\n        }\n        else if (method == \"PayPal\")\n        {\n            // PayPal 결제 처리 로직\n            Console.WriteLine($\"PayPal로 {amount} 처리중\");\n        }\n        // 새 결제 방법을 추가할 때마다 더 많은 if-else 문이 여기에 추가됩니다.\n    }\n}\n\n// 사용 예\nvar paymentProcessor = new PaymentProcessor();\npaymentProcessor.ProcessPayment(100.00m, \"CreditCard\");\npaymentProcessor.ProcessPayment(75.50m, \"PayPal\");\n```\n\n## 이 접근 방식의 문제점\n\n- 확장성: 새 결제 방법마다 ProcessPayment 메서드에 더 많은 if-else 조건을 추가해야 하므로, 메서드는 무한정으로 커지게 됩니다.\n- 유지보수성: 시간이 흐르면서 ProcessPayment 메서드는 점점 복잡해지고 관리하기 어려워집니다.\n- 개방/폐쇄 원칙 위반: 이 클래스는 수정을 열어둔 상태입니다. 새로운 결제 유형을 추가할 때마다 이 클래스를 수정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 전략 패턴 사용하기\n\n자, 이제 코드를 전략 패턴을 사용하도록 리팩토링해보겠습니다. 이렇게 하면 더 유연하고 유지보수하기 쉬워집니다.\n\n## 전략 인터페이스\n\n```js\npublic interface IPaymentStrategy\n{\n    void ProcessPayment(decimal amount);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 구체적인 전략\n\n```js\npublic class CreditCardPaymentStrategy : IPaymentStrategy\n{\n    public void ProcessPayment(decimal amount)\n    {\n        // 신용 카드 결제 처리 로직\n        Console.WriteLine($\"신용 카드로 {amount} 처리 중\");\n    }\n}\n\npublic class PayPalPaymentStrategy : IPaymentStrategy\n{\n    public void ProcessPayment(decimal amount)\n    {\n        // PayPal 결제 처리 로직\n        Console.WriteLine($\"PayPal로 {amount} 처리 중\");\n    }\n}\n```\n\n## 컨텍스트 클래스\n\n```js\npublic class PaymentProcessor\n{\n    private IPaymentStrategy _paymentStrategy;\n\n    public PaymentProcessor(IPaymentStrategy paymentStrategy)\n    {\n        _paymentStrategy = paymentStrategy;\n    }\n\n    public void SetPaymentStrategy(IPaymentStrategy paymentStrategy)\n    {\n        _paymentStrategy = paymentStrategy;\n    }\n\n    public void ProcessPayment(decimal amount)\n    {\n        _paymentStrategy.ProcessPayment(amount);\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 사용법\n\n```js\nvar creditCardPayment = new PaymentProcessor(new CreditCardPaymentStrategy());\ncreditCardPayment.ProcessPayment(100.00m); \n// 출력: 신용 카드로 100.00 처리 중\n\nvar payPalPayment = new PaymentProcessor(new PayPalPaymentStrategy());\npayPalPayment.ProcessPayment(75.50m); \n// 출력: PayPal로 75.50 처리 중\n```\n\n전략 패턴의 맥락에서 새 결제 방법을 추가하는 것은 간단한 프로세스이며 기존 코드를 변경할 필요가 없기 때문에 이 패턴의 주요 이점 중 하나입니다.\n\n기존 시스템에 새로운 암호화폐 결제 전략을 추가하는 방법을 살펴보고 이 접근 방식이 기능 확장을 어떻게 단순화하는지 비교해봅시다.\n\n<div class=\"content-ad\"></div>\n\n## 암호화폐 결제 전략 추가하기\n\nIPaymentStrategy 인터페이스를 구현하는 클래스를 생성하여 새로운 구체적인 전략을 정의하세요.\n\n```js\npublic class CryptoPaymentStrategy : IPaymentStrategy\n{\n    public void ProcessPayment(decimal amount)\n    {\n        Console.WriteLine($\"암호화폐를 통한 {amount} 처리 중\");\n        // 실제 암호화폐 처리 로직\n    }\n}\n```\n\n새 전략을 사용하는 방법은 새 CryptoPaymentStrategy로 PaymentProcessor를 인스턴스화하는 것만으로 간단합니다.\n\n<div class=\"content-ad\"></div>\n\n```javascript\nvar cryptoPayment = new PaymentProcessor(new CryptoPaymentStrategy());\ncryptoPayment.ProcessPayment(50.00m); \n// 출력: 50.00을(를) 암호화폐를 통해 처리 중\n```\n\n전략 패턴의 맥락에서 새로운 지불 전략을 추가함으로써, 해당 패턴이 변경과 확장을 효율적으로 다루는 능력을 보여줍니다. 이를 통해 새로운 기능을 기존 코드베이스에 영향을 주지 않고 매끄럽게 추가할 수 있어서 버그 도입 위험을 크게 줄이고 시스템을 더 관리 가능하고 확장 가능하게 만들 수 있습니다.\n\n## 전략 패턴 사용의 장점\n\n- 확장 용이성: IPaymentStrategy 인터페이스를 구현하는 새 클래스를 만들기만 하면 됩니다. 기존 코드를 수정할 필요가 없습니다.\n- 개방/폐쇄 원칙 준수: 시스템은 확장을 위해 열려 있지만 수정은 닫혀 있습니다. 기존 클래스를 변경하지 않고 새로운 지불 전략을 추가할 수 있습니다.\n- 간결함과 유지보수성: PaymentProcessor 클래스는 간단한 상태를 유지하며 새 지불 방법이 추가될수록 복잡성이 증가하지 않습니다. 각 지불 방법은 자체 클래스에 캡슐화되어 있어 시스템을 이해하고 유지하기 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n이 정보가 유용했길 바랍니다. 🌟 즐거우면서도 풍부한 학습 여정을 희망합니다!\n\n📚 이와 같은 통찰력을 더 원하신다면, 자유롭게 👉 Merwan Chinta를 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-06-20-StrategyPatternNETC_0.png"},"coverImage":"/assets/img/2024-06-20-StrategyPatternNETC_0.png","tag":["Tech"],"readingTime":6},{"title":"좋은 이름을 선택하기 위한 7단계 치트 시트","description":"","date":"2024-06-20 04:06","slug":"2024-06-20-My7-StepCheatSheetforChoosingGoodNames","content":"\n\n뭔가 이름 짓기는 결코 쉬운 일이 아니었죠. 특히 개발자들에게!\n\n![이미지](/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_0.png)\n\n변수, 클래스, 함수 및 기타 코드 요소에 선택한 이름은 의미 있는, 정확한 및 쉽게 이해할 수 있는 이름이어야 하기 때문에 이름 짓는 것은 어려운 작업으로 간주될 수 있습니다.\n\n코드베이스를 깨끗하고 유지보수 가능하게 유지하기 위해서는 좋고 일관된 이름 규칙이 필수적입니다. 시스템이 커짐에 따라 새로운 이름이 기존 이름과 충돌하지 않도록 보장하는 것이 어려울 수 있기 때문에 이것은 도전적일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 코드 이름을 선택할 때 고려해야 할 사항에 대한 체크리스트를 살펴보겠습니다. 이 목록에는 저의 개인적인 통찰과 Uncle Bob 및 Eric Evans와 같은 유명한 저자들의 아이디어가 포함되어 있습니다.\n\n## 1. 의도 및 측정 단위\n\n선택한 이름은 요소의 의도 및 기능뿐만 아니라 해당되는 측정 단위도 명확히 전달해야 합니다. 이렇게 함으로써 코드를 작성하는 사람뿐만 아니라 나중에 코드를 읽거나 수정해야 하는 다른 사람에게도 코드를 이해하고 유지할 수 있도록 도와줄 것입니다.\n\n반면에 지나치게 짧은 변수 이름이나 믿을 수 없는 약어의 사용은 관련된 모든 사람들에게 코드의 가독성과 이해도를 크게 해치게 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\npublic double calculateBmi(double m, double h) {\n    double sh = h * h;\n    double mKg = m * 0.453d;\n    return mKg / sh;\n}\n```\n\n위 코드 스니펫을 보기 좋게 개선할 수 있습니다. 변수에 적절한 이름을 선택하면 코드의 가독성이 크게 향상됩니다:\n\n```js\npublic static final double LBS_TO_KG = 0.453d;\n\npublic double calculateBmi(double massInLbs, double heightInMeters) {\n    double squaredHeight = heightInMeters * heightInMeters;\n    double massInKg = massInLbs * LBS_TO_KG;\n    return massInKg / squaredHeight;\n}\n```\n\n## 2. Avoid Noise Words\n\n\n<div class=\"content-ad\"></div>\n\n한번 웃어보세요! 자바 애플리케이션을 위한 클래스 이름을 생성해주는 재밌는 웹사이트가 있어요. \"enterprisify\"를 몇 번 클릭해보세요! 이런 생성된 이름들은 '소음 단어'로 이루어져 있어요. 이것은 의도를 표현하지 않는 기술 용어들이에요.\n\n클래스 이름에 소음 단어를 사용하면 코드를 이해하기 어려울 수 있어요. AccountData와 Account 클래스와 다른 점을 알고 계신가요?\n\n그러면 AccountSummary가 더 나은 선택이 될 수도 있어요.\n\n그리고 AccountDto나 AccountEntity는 어떨까요?\n\n<div class=\"content-ad\"></div>\n\n“Data”라는 노이즈 단어는 추가 정보를 제공하지 않아요. 하지만 때로는 클래스 이름을 지을 때 기술 용어를 사용해서 클래스의 위치나 구현을 나타낼 수 있어요. 예를 들어, Service, Dto, Entity, Repository와 같은 접미사를 사용할 수 있어요.\n\n![이미지](/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_1.png)\n\n## 3. 데이터 유형 및 키워드 피하기\n\n데이터 유형 역시 \"노이즈 단어\"로 간주될 수 있어요. 몇 가지 예시는 다음과 같아요:\n\n<div class=\"content-ad\"></div>\n\n```js\n기록 PromotionRecord (\n    // ...\n){}\n\n추상 클래스 AbstarctPromotion {\n  // ...\n}\n\nOffsetDateTime startOffsetDateTime;\n\nList<Account> listOfAccounts;\n```\n\n동일하게 인터페이스와 그 구현에 대한 특별한 명명 패턴은 안티 패턴으로 간주될 수 있습니다. 흔히 사용되는 방법은 인터페이스에 \"I\"를 접두사로 붙이고 클래스에 \"Impl\" 접미사를 붙이는 것입니다:\n\n```js\ninterface ICustomerDetailsProvider {}\n\nclass CustomerDetailsProviderImpl implements ICustomerDetailsProvider {}\n```\n\n그럼 정말 인터페이스가 필요한 이유는 무엇일까요? 대부분의 경우 인터페이스를 두 가지 경우 중 하나에서 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- 의존 역전(Dependency Inversion): 인터페이스는 도메인 레이어의 일부이며 구현은 인프라스트럭처 레이어의 코드를 사용하는 어댑터처럼 작동합니다.\n예를 들어, 도메인 레이어의 일부로 CustomerDetailsProvider 인터페이스를 가질 수 있고, 해당 구현은 네트워크 호출을 통해 고객에 대한 특정 데이터를 가져옵니다. 만약 해당 구현을 \"CustomerDetailsProviderImpl\"이라고 명명한다면 \"Impl\" 접미사는 가치를 추가하지 않을 것입니다. 대신, \"CustomerDetailsApiClient\" 또는 \"CustomerApiAdapter\"와 같이 데이터가 어떻게 가져와지는지에 대한 힌트를 제공해줄 것입니다.\n- 다형성(Polymorphism): 다형성을 위해 인터페이스를 사용한다면, 최소 두 가지 이상의 명확히 구분된 구현이 있어야 합니다. 예를 들어, \"Payment\" 인터페이스와 다른 결제 방법을 위한 다양한 구현이 있다면 구현은 매우 다르며 의미 있는 이름을 가져야 합니다: \"CashPayment\", \"VisaPayment\", \"OnlinePayment\" 등.\n\n## 4. 길이 대 무게\n\n변수 이름을 짓는 경우, 이름의 길이는 변수의 범위와 직접적으로 비례해야 합니다. 따라서 작은 범위의 경우, 단일 작은 단어나 약어가 충분합니다. Uncle Bob은 더 나아가서 매우 작은 범위(한 줄짜리 코드와 같은)에는 하나의 글자 이름조차 충분하다고 말합니다.\n\n```js\n// 작은 범위\nfor(Employee employee : employeesEligibleForPromotion) {\n    // 4-5 줄의 코드\n}\n\n// 매우 작은 범위\nemployeesEligibleForPromotion.stream()\n    .map(e -> e.getName().toLowerCase())\n    .forEach(this::sendNotificationToHrDepartment);\n```\n\n<div class=\"content-ad\"></div>\n\n더 긴 범위에 따라, 변수 이름도 길어집니다. 하지만 변수 이름이 너무 길어진다면, 이는 코드 향기의 지표일 수 있습니다: 함수가 너무 커졌다는 것을 의미할 수 있습니다.\n\n예를 들어, 위의 코드 스니펫에서 직원 목록에 대해 꽤 긴 이름을 사용했죠: employeesEligibleForPromotion. 이는 함수의 범위가 크거나 동일한 범위 내에 다른 직원 목록이 있음을 의미할 수 있습니다. 어쨌든, 기능을 추출할 수 있습니다:\n\n```js\npublic void sendNotificationToHrForEmployees(List<Employees> employees) {\n    employees.stream()\n      .map(e -> e.getName().toLowerCase())\n      .forEach(this::sendNotificationToHrDepartment);\n}\n```\n\n우리가 볼 수 있듯이, 함수를 추출하고 변수의 범위를 작게 만들면 이름을 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n함수를 명명할 때는 범위가 길수록 이름을 작고 추상적으로 지어야 합니다. 이는 우리가 상위 수준의 함수가 구현 세부 정보를 누설하지 않도록 원하기 때문입니다. 따라서 범위가 작은 함수는 이름이 더 길어질 것입니다.\n\n## 5. 일관성\n\n일관된 명명 규약은 다른 사람들이 작성한 코드를 탐색하고 이해하기 쉽게 만들어줍니다. 특히 대규모 공동 작업 프로젝트에서 이는 중요합니다. 또한, 일관성은 명명 충돌을 방지하고 코드에 버그나 오류가 도입되는 가능성을 줄일 수 있습니다.\n\n동일한 작업에 대해 다른 동사를 사용하지 않도록 주의하세요: 구현이 동일한 경우 fetch, retrieve, get 및 find를 서로 교차적으로 사용하지 마세요. 동시에 다른 구현이나 개념에 대해 서로 다른 단어를 선택해야 합니다. 예를 들어, \"find\" 동사를 사용하여 Optional 또는 nullable 데이터를 반환할 수 있지만, 데이터가 누락된 경우에는 \"get\"이 항상 예외를 throw합니다.\n\n<div class=\"content-ad\"></div>\n\n## 6. 비즈니스 용어 vs. 기술 용어\n\n비즈니스 용어와 기술 용어는 우리에게 적절한 이름을 선택하는 데 도움을 줄 수 있습니다. Clean Code에서 Uncle Bob은 기술 용어가 다른 개발자들에 의해 쉽게 이해될 수 있기 때문에 우선적으로 고려해야 한다고 제안합니다. Adapter, Builder, Repository, Dto와 같은 용어는 컴포넌트의 구현이나 위치를 나타낼 수 있습니다.\n\n반면에 Eric Evan의 도메인 주도 설계는 비즈니스 언어를 받아들이는 것이 복잡한 도메인 모델을 가진 대규모 시스템에서 도움이 된다고 가르쳐줍니다. 이는 개발자와 비즈니스 담당자 간의 커뮤니케이션 간극을 크게 줄일 수 있습니다.\n\n전반적으로, 컴포넌트에 이름을 선택할 때 비즈니스 용어와 기술 용어 모두 좋은 후보가 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 7. 동사 vs. 명사\n\n약칭으로는, 함수에는 동사를 사용하고 필드 및 변수에는 명사를 사용해야 합니다.\n\n대부분의 경우 클래스에는 명사를 사용할 것이지만 몇 가지 특별한 경우가 있을 수 있습니다. 예를 들어, \"세로 슬라이스\" 디자인을 사용하는 경우 사용 사례를 나타내는 클래스를 가질 수 있습니다. 이러한 클래스는 CreateAccount, DisableAcount, ApplyPromotion과 같은 이름을 가질 것입니다.\n\n인터페이스는 모두 메서드와 동작에 관한 것입니다. 인터페이스 이름을 정할 때에는 명사를 사용해야 하지만, 동시에 그들이 가능하게 하는 행동을 명확하게 표현해야 합니다. 예를 들어 Clonable, Runnable, Executable, DataProvider 등이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n이 글에서는 좋은 이름을 선택하기 위한 7단계 체크리스트를 살펴보았습니다. 우리는 의도 표현, 측정 단위, 그리고 \"잡음 단어\" 피하기에 대해 처음에 논의했습니다. 그 후에는 이름의 길이, 일관성, 그리고 사용할 수 있는 단어 유형에 대해 배웠습니다.\n\n![링크](/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_2.png)\n\n# 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n기사를 읽어 주셔서 감사합니다! 의견을 주시면 감사하겠습니다. 어떠한 피드백이든 환영입니다.\n\n프로젝트 이름을 선택할 때 꼭 지켜야 할 사항과 지켜야 할 규칙에 대한 .svg 치트 시트를 만들었습니다. 이 글에서 논의한 내용을 간결하게 요약한 것입니다. 제 콘텐츠가 마음에 들고, 이 치트 시트를 이메일로 받고 싶다면, 이메일 구독을 고려해 주세요.\n\n즐거운 코딩 시간 보내세요!\n\n# 레벨업 코딩\n\n<div class=\"content-ad\"></div>\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 👏 스토리에 박수를 보내고 저자를 팔로우하세요 👉\n- 📰 Level Up Coding 게시물에서 더 많은 콘텐츠를 확인하세요\n- 🔔 팔로우하기: Twitter | LinkedIn | Newsletter\n\n🚀👉 Level Up 재능 동호회에 가입하여 멋진 취업 기회를 찾아보세요","ogImage":{"url":"/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_0.png"},"coverImage":"/assets/img/2024-06-20-My7-StepCheatSheetforChoosingGoodNames_0.png","tag":["Tech"],"readingTime":7}],"page":"41","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}