{"pageProps":{"posts":[{"title":"자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다","description":"","date":"2024-05-14 14:06","slug":"2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter","content":"\n\nGit 내부를 배우면서 더 나은 이해를 위해 간소화된 버전을 구현해 보세요!\n\n![이미지](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png)\n\n## Git 또는 일반적으로 버전 관리란?\n\n우리 프로젝트를 시간에 따라 추적하는 데 도움이 되는 것이에요. 좋은 예시 중 하나는 소스 코드를 쉽게 과거의 특정 시간에 어떻게 보였는지 볼 수 있다는 것이죠.\n\n\n\n# 왜 그것을 이해해야 할까요?\n\n우선, 무언가 잘못되었을 때 몇 가지 명령어를 무심코 알아서는 도움이 되지 않습니다. 둘째로, 매일 다루고 있는 것이 어떻게 작동하는지 이해하지 못한다면, 재미가 어디에 있을까요?\n\n이제 슈퍼 간단한 버전 관리 시스템인 Gitj를 구현하는 방법을 하나씩 이해해 보겠습니다.\n\n# 구현\n\n\n\ngit은 압축 및 데이터 저장 방식과 같이 더 고급 기능을 수행한다는 것을 염두에 두세요. 이 내용은 별도의 기사에서 다룰 수 있습니다.\n\n# 첫 번째 명령어 적용: Init!\n\n아마도 알고 계시다시피 프로젝트를 git init으로 시작하면 git은 .git 폴더를 생성하고 데이터를 그 안에 저장합니다. 이를 구현해보겠습니다:\n\ngit이 생성하는 두 가지 중요한 폴더는 refs와 objects입니다. objects는 git의 구성 요소입니다. 3가지 유형(사실 4가지!)이 있을 수 있습니다: commit, tree 및 blob입니다. 이러한 각 유형을 자세히 살펴보겠습니다. refs 폴더에는 브랜치와 각 브랜치의 최신 커밋이 포함된 heads라는 하위 폴더가 있습니다(이름에서 알 수 있듯이 브랜치의 헤드를 저장하는 것으로 보입니다). 또한 현재 브랜치 또는 커밋을 유지하는 HEAD라는 중요한 파일이 있습니다.(가끔은 브랜치 대신 커밋에서 checkout을 수행할 수 있습니다)\n\n\n\n\"이제 init 함수를 호출하면 이러한 폴더들을 만들어 보겠습니다.\n\n```js\nconst fs = require(\"fs\");\n\nfunction init() {\n    // .gitj라는 폴더를 만들고, .gitj/objects와 .gitj/refs, .gitj/refs/heads와 같은 하위 폴더들을 생성합니다.\n    fs.mkdirSync(\".gitj\");\n    fs.mkdirSync(\".gitj/objects\");\n    fs.mkdirSync(\".gitj/refs\");\n    fs.mkdirSync(\".gitj/refs/heads\");\n    // .gitj/refs/heads/master라는 파일을 생성합니다.\n    fs.writeFileSync(\".gitj/refs/heads/master\", \"\");\n    // .gitj/HEAD라는 파일을 생성합니다.\n    fs.writeFileSync(\".gitj/HEAD\", \"ref: refs/heads/master\");\n}\n\ninit();\n```\n\n# Git Add! 파일을 스테이징 영역에 추가하기\n\nGit에서 파일은 세 가지 다른 단계에 있을 수 있습니다:\"\n\n\n\n![image](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_1.png)\n\n- Working Directory: 평소 작업하는 디렉토리로 파일 및 폴더를 변경하고 구조를 수정합니다.\n\n- Staging Directory: 작업 디렉토리의 한 순간의 스냅샷이며 git add 명령을 사용하면 실제로 파일이 .git 폴더로 복사됩니다. 주의할 점은 스테이징 파일들이 이후에 리포지토리에 커밋하려는 최종 원고이라는 것입니다.\n\n- Repository: commit 명령을 실행하면 리포지토리에 새로운 스냅샷이 생성됩니다. 이제 이 커밋의 SHA 해시를 사용하여 이 스냅샷을 가리킬 수 있습니다(스테이징 파일을 가리킬 수는 없으며 스테이징 파일은 종이 딱지 같은 역할을 합니다).\n\n\n\n이제 git add 명령어를 구현해 봅시다.\n\ngit add에서 수행해야 할 단계는:\n\n- 파일 내용 읽기\n- 파일 내용을 해싱하기\n- 해시를 파일 이름으로 사용하여 객체 폴더에 저장하기\n- 파일이 이미 존재하는 경우 아무 작업도 수행하지 않습니다. 동일한 내용을 가진 파일이 10개 있다면(심지어 다른 파일 이름과 폴더 위치를 가지더라도), git은 그것들을 10번 복사하는 게 아니라 blob를 재사용할 수 있습니다.\n\n또한, git은 해시의 처음 두 글자를 사용하여 폴더 이름을 생성합니다. 예를 들어, 해시가 4f9be057f0ea5d2ba72fd2c810e8d7b9aa98b469라면 git은 이 폴더에 저장합니다: 4f 및 나머지는 파일로 생성합니다: 9be057f0ea5d2ba72fd2c810e8d7b9aa98b469. 왜냐하면 시간이 지남에 따라 단일 폴더에 많은 파일이 있으면 파일에 액세스하는 데 시간이 더 오래 걸릴 수 있기 때문에 git은 폴더에 처음 두 글자를 사용함으로써 이 문제를 방지하려고 합니다.\n\n\n\n```js\nconst fs = require(\"fs\");\nconst crypto = require(\"crypto\");\n\nfunction add(filename) {\n    try {\n        // 파일이 존재하는지 확인\n        fs.accessSync(filename);\n        // 파일 읽기\n        const content = fs.readFileSync(filename);\n        // 파일 해싱\n        const hash = crypto.createHash(\"sha1\");\n        hash.update(content);\n        const sha = hash.digest(\"hex\");\n        // 해시의 첫 두 문자로 폴더 생성 (폴더가 없는 경우)\n        if (!fs.existsSync(`.gitj/objects/${sha.slice(0, 2)}`)) {\n            fs.mkdirSync(\".gitj/objects/\" + sha.slice(0, 2), { recursive: true });\n        }\n        if (fs.existsSync(`.gitj/objects/${sha.slice(0, 2)}/${sha.slice(2)}`)) {\n            // 이미 같은 내용의 블롭이 존재함\n            process.exit(0);\n        }\n        // 파일을 objects 폴더에 쓰기\n        fs.writeFileSync(`.gitj/objects/${sha.slice(0, 2)}/${sha.slice(2)}`, content);\n    } catch (error) {\n        console.log(error);\n        console.log(`파일 ${filename}이(가) 존재하지 않습니다.`);\n        process.exit(1);\n    }\n}\n\nadd('./sample/src/readme.md')\n```\n\nadd.js를 실행하여 소스 코드에서 파일을 추가한 후, 객체 저장소에 다음과 같은 파일이 생겼어야 합니다.\n\n![이미지](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_2.png)\n\n# 변경사항을 커밋하세요!\n\n\n\n\n커밋 자체도 객체 유형입니다. 아마도 예측하신 것처럼 우리의 객체 폴더에 더 많은 파일을 생성해야 합니다.\n\n커밋의 목적은 현재 상황(파일 및 폴더)에 대한 포인터를 만들어 이 상태로 돌아올 수 있도록 하는 것입니다.\n\nGit의 커밋 객체에는 다음 정보가 포함됩니다:\n\n- 작성자: 변경사항을 만든 사람\n- 커미터: 변경사항을 커밋한 사람 (때로는 다른 사람으로부터 패치를 받아 변경사항을 커밋해야 할 수도 있습니다.)\n- 커밋일\n- 커밋 메시지\n- 트리 (작업 디렉토리의 모양을 생성 시점에 유지하는 또 다른 객체)\n- 부모(존재하는 경우)\n\n\n\n## Git Commit이 어떻게 보이는지 알아봅시다\n\n만약 git log 명령어를 사용하면 커밋 해시 목록을 확인할 수 있고, 이 중 하나를 복사하여 git show --pretty=raw commitHash 명령어를 사용할 수 있습니다. 이 몤령어의 결과 예시는 다음과 같습니다(날짜는 커미터와 저자 이름 뒤의 타임스탬프로 표시됩니다):\n\n![Git Commit](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_3.png)\n\n이 예제에서는 부모가 있지만, 만약 커밋이 모든 첫 번째 커밋이라면 부모가 없습니다.\n\n\n\n부모가 커밋 객체 내에 존재하는 이유는 이러한 커밋들을 연결하여 연결할 수 있기 때문입니다. 따라서 우리가 과거의 커밋을 수동으로 변경하면 모든 커밋 해시를 다시 계산해야 하므로 모든 것이 엉망이 됩니다. 이는 리베이스와 같은 명령어를 사용하여 수행하는 작업입니다.\n\n## Git에서 Tree 객체 유형은 무엇인가요?\n\n폴더와 파일의 구조를 유지하는 객체 유형입니다. 예를 들어, 저가 보여준 커밋 예제에서 Tree 객체를 확인하고 내용을 볼 수 있습니다. Tree를 확인하려면 git ls-tree treeHash를 사용해야 합니다. 다음은 예시입니다:\n\n![이미지](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_4.png)\n\n\n\n이것은 기본 트리입니다. 작업 디렉토리의 파일과 폴더를 포함하고 있습니다. 여기서 두 가지 다른 유형을 볼 수 있는데, 파일을 나타내는 blob과 이 경우 하위 폴더를 나타내는 다른 트리 객체를 가리키는 tree가 있습니다.\n\n결과에서 두 번째 열은 객체의 유형, 세 번째 열은 SHA이며, 마지막 열은 파일 또는 폴더 이름입니다(파일 이름을 blob 밖에 유지하는 것은 동일한 내용을 반복해서 재사용하는 데 도움이 된다는 점을 이미 언급했습니다). 아직 알지 못하는 것은 첫 번째 열입니다. 첫 번째 열은 파일 모드입니다. 파일 모드는 객체의 유형 (예: blob, tree)과 해당 권한을 지정합니다. 040000 또는 100644와 같은 앞부분의 숫자는 8진수 표기법으로 파일 모드를 나타냅니다. 가장 일반적인 모드는 다음과 같습니다:\n\n- 100644: 읽기-쓰기 권한이 있는 일반 파일 (blob)을 나타냅니다.\n- 100755: 읽기-쓰기-실행 권한이 있는 실행 파일 (blob)을 나타냅니다.\n- 040000: 디렉토리 (tree)를 나타냅니다.\n\n커밋 기능을 구현하기 위해 필요한 조치:\n\n\n\n- 현재 작업 디렉토리의 트리를 생성하세요\n- 커밋 객체를 생성하세요\n- 부모 커밋(Head)을 얻으세요. 만약 부모가 없다면 이 커밋 이후에 head(master)를 업데이트하세요.\n\n우리는 git이 하는 방식과 동일한 파일 및 폴더 구조를 생성하는 간단한 트리를 만들 것입니다.\n\n## 트리 생성 함수 구현!\n\n각 파일의 파일 모드를 가져오는 작은 함수:\n\n\n\n```js\nasync function getTreeFileMode(fileType, fileOrFolder) {\n    const { mode } = await fs.stat(fileOrFolder);\n    return fileType === 'tree' ? '040000' : '100' + ((mode & parseInt(\"777\", 8)).toString(8));\n}\n```\n\n파일의 해시 값을 가져오는 함수\n\n```js\nasync function getHashOfFile(path) {\n    const content = await fs.readFile(path);\n    const hash = crypto.createHash(\"sha1\");\n    hash.update(content);\n    const sha = hash.digest(\"hex\");\n    return sha;\n}\n```\n\n이제 메인 함수입니다.\n\n\n\n```js\nasync function createTreeObjectsFromPaths(folderPath) {\n    let treeFileContent = '';\n    let treeHash = ''\n    // 이 함수의 설명:\n    // 1- fs.readdir 결과를 반복한다.\n    // 2- 만약 디렉토리라면 유형은 tree이고 이 함수를 재귀적으로 호출한다. 그렇지 않으면 파일 또는 blob이다.\n    //    그리고 우리는 해시를 계산해야 한다.\n    // 3- 우리는 트리 객체를 만들기 위해 파일 모드(040000, 100644, ...)를 가져온다.\n    // 4- 트리 객체의 내용을 가지고 있다. 이제 해시를 생성할 수 있다.\n    // 5- 객체(현재 트리의 해시)가 존재하면 아무것도 할 필요가 없고, 그렇지 않으면 객체를 만들어서 객체 폴더에 저장한다.\n\n    // 이 함수를 실행해서 제대로 작동하는지 확인해봅시다:\n}\n```\n\n이 함수를 실행해보고 정상적으로 작동하는지 확인해보겠습니다:\n\n\n\n이제 폴더 구조는 이렇게 보입니다.\n\n![Folder Structure](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_5.png)\n\n이제 `createTreeObjectsFromPaths('.')`를 실행합니다. 결과로 Gitj 폴더에 두 개의 새 객체가 생성됩니다:\n\n![Result](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_6.png)\n\n\n\n이 중 하나의 객체 내용은 루트 폴더에 있는 package.json을 blob 유형으로 가지고 있을 것으로 예상되고 src 폴더를 가리키는 다른 tree 객체를 기대합니다:\n\n![image 1](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_7.png)\n\n이 tree 커밋 해시는 이제 src 폴더의 구조를 저장하는 다른 객체를 가리킵니다:\n\n![image 2](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_8.png)\n\n\n\n이제 커밋 기능을 구현할 시간입니다.\n\n```js\nconst fs = require('fs').promises;\nconst crypto = require('crypto');\nconst { createTreeObjectsFromPaths, folderOrFileExist } = require('./tree');\n\nasync function commit(commitMessage) {\n    const treeHash = await createTreeObjectsFromPaths('./sample');\n    const parentHash = await getLatestCommitHash();\n    const author = 'test';\n    const committer = 'test';\n    const commitDate = Date.now();\n    const commitContent = `tree ${treeHash}\\nparent ${parentHash}\\nauthor ${author}\\ncommitter ${committer}\\ncommit date ${commitDate}\\n${commitMessage}`;\n    const hash = crypto.createHash(\"sha1\");\n    hash.update(commitContent);\n    const commitHash = hash.digest(\"hex\");\n    // commit 객체를 objects 폴더에 작성합니다.\n    if (!await folderOrFileExist(`.gitj/objects/${commitHash.slice(0, 2)}`)) {\n        await fs.mkdir(`.gitj/objects/${commitHash.slice(0, 2)}`, { recursive: true });\n    }\n    if (await folderOrFileExist(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`)) {\n        // 이미 동일한 내용의 커밋이 존재합니다.\n        console.log(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`);\n        return commitHash;\n    }\n    // 파일을 objects 폴더에 작성합니다.\n    await fs.writeFile(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`, commitContent);\n    // 현재 브랜치의 헤드를 커밋 해시로 설정합니다.\n    await fs.writeFile('.gitj/refs/heads/master', commitHash);\n    return commitHash;\n}\n```\n\n어려운 부분은 트리 객체였는데, 이제 모든 데이터를 갖고 있고 이를 함께 묶어 새로운 커밋 객체를 만듭니다. 또한, 브랜치의 헤드를 업데이트하여 이 새로운 스냅샷을 가리키도록 해야 합니다 (당연히 커밋 해시).\n\n\n\n## 마스터 브랜치 또는 메인 브랜치 또는 다른 브랜치가 무엇을 의미하죠?\n\n브랜치는 단순히 커밋을 가리키는 참조 또는 책갈피입니다. 커밋의 구현에서 본 것처럼 파일 내용을 업데이트 했을 때 refs/head/master 와 같은 파일의 내용을 볼 수 있습니다. 그것은 단지 커밋 해시입니다. 이 커밋 해시에는 부모가 있을 수 있으며(첫 번째 커밋이 아닌 경우), 더 이상 커밋이 없을 때까지 과거로 돌아갈 수 있습니다. 즉, 이 브랜치 이름을 사용하여 최신 커밋(Head!)에 액세스할 수 있습니다. 간단히 말해, 특정 브랜치에 있는 것은 다른 head를 가리키고 있다는 것을 의미합니다.\n\nblob에 파일 이름을 저장하지 않으므로, 파일 이름이 다르더라도 git이 blob을 사용할 수 있는 이점이 있습니다.\n\n## Git Checkout를 어떻게 실행하나요?\n\n\n\n이미 커밋 기능을 구현했으므로, 커밋에는 트리 객체(모든 폴더와 파일을 재귀적으로 가리킨다)에 접근할 수 있고, 파일은 .git(우리 경우 .gitj)에 blob으로 저장되어 있습니다. 따라서 먼저 작업 디렉토리를 제거한 다음 누군가가 다른 커밋(또는 브랜치 - 브랜치 헤드는 커밋 해시를 가리킨다)을 확인할 때 전체 디렉터리를 다시 만들어야 합니다. 하지만 먼저 커밋 해시 또는 브랜치 이름을 HEAD 파일에 저장해야 합니다.\n\n그 전에, 해당 커밋의 트리 객체를 가져오는 작은 함수를 구현하고 싶습니다:\n\n```js\nasync function getTreeHashFromCommit(commitHash) {\n    const commitContent = await fs.readFile(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`, 'utf-8');\n    const array = commitContent.split('\\n').map(e=> e.split(' '))\n    const elem = array.find(e => e[1] === 'tree');\n    return elem[2];\n};\n```\n\n이제 트리를 가지고 있으면 전체 폴더를 다시 만들어야 합니다:\n\n\n\n먼저, 이 커밋을 HEAD 파일에 써서 헤드가 더 이상 마스터에 있지 않음을 기억합니다. 전체 폴더를 다시 만들기 위해 트리와 블롭을 재귀적으로 가져와야 합니다. 다음은 구현 내용입니다:\n\n```js\nasync function convertTreeObject(treeHash, folderPrefix = '', files = []) {\n    const treeObject = await fs.readFile(`.gitj/objects/${treeHash.slice(0, 2)}/${treeHash.slice(2)}`, 'utf-8');\n    const array = treeObject.split('\\n').map(e=> e.split(' '))\n    for (const file of array) {\n        if (!file || file.length < 2) continue;\n        const [mode, type, hash, name] = file;\n        if (type === 'tree') {\n            await convertTreeObject(hash, folderPrefix + name + '/', files);\n        } else {\n            files.push({\n                mode: mode,\n                type: type,\n                hash: hash,\n                name: folderPrefix + name\n            })\n        }\n    }\n    return files;\n}\n```\n\n만약 파일이 있다면 파일의 이름과 블롭(파일의 내용)을 배열에 추가합니다. 객체 타입이 tree이면 이것이 폴더라는 것이고, 이 함수를 재귀적으로 호출하여 올바른 파일 경로를 생성하기 위해 부모 폴더의 경로를 전달해야 합니다.\n\n\n\n## 앞으로 구현하고 싶은 몇 가지 기능\n\n- Git 상태 확인\n- Git 차이 확인\n\n# 결론\n\n우리는 git이 히스토리를 추적할 수 있는 능력을 제공하기 위해 해시 및 커밋 해시 체인을 사용하는 방법을 배웠습니다. 개인적으로는 이런 식의 심층적인 탐구가 내용을 정말 잘 배우는 가장 좋은 방법이라고 생각합니다. 유용했기를 바랍니다. 만약 git에 더 많은 기능을 구현하는 데 관심이 있다면 이 GitHub 저장소를 확인해보세요.\n\n\n\n# 참고 자료\n\n- [CS50 YouTube 영상](https://www.youtube.com/watch?v=lG90LZotrpo&ab_channel=CS50)\n- [유튜브의 인코드된 비디오](https://www.youtube.com/watch?v=P6jD966jzlk&pp=ygUgR2l0IGludGVybmFscyBob3cgaXQgc3RvcmVzIGRhdGE%3D)\n- [GOTO Conferences YouTube 채널](https://www.youtube.com/watch?v=dBSHLb1B8sw&ab_channel=GOTOConferences)\n\n\n\nhttps://www.youtube.com/watch?v=52MFjdGH20o&ab_channel=Brief","ogImage":{"url":"/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png","tag":["Tech"],"readingTime":12},{"title":"고통 없는 리액트 다시 렌더링 피하기와 의존성 간소화하기","description":"","date":"2024-05-14 14:04","slug":"2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies","content":"\n\n\n![React without Pain: Avoid Re-Renders and Simplify Dependencies](/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png)\n\nReact에서 다시 렌더링을 추적하는 것은 고통스러운 과정일 수 있습니다. Fine-grain 반응성 패턴은 이 문제를 완전히 제거하는 해결책을 제공하여 React 엔지니어가 종속성을 추적하는 것을 잊고 코드 작성에 집중할 수 있게 합니다. 이 기사에서는 라이브러리 Mlyn이 종속성 관리를 간단하게 하고 React 애플리케이션에서 불필요한 다시 렌더링을 방지하는 방법을 살펴보겠습니다.\n\n# 종속성 관리: 공통 문제\n\n기존의 React 애플리케이션에서 상태와 종속성을 관리하는 것은 종종 복잡하고 오류가 발생하기 쉬운 코드로 이어질 수 있습니다. 이 문제를 설명하기 위해 간단한 카운터 예제를 살펴보겠습니다.\n\n\n\n\n# 전통적인 리액트 예제\n\n```js\nimport React, { useState, useCallback } from \"react\";\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  const onIncrement = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, [count]); // count에 의존\n  return (\n    <div>\n      <h1>카운트: {count}</h1>\n      <button onClick={onIncrement}>증가</button>\n    </div>\n  );\n};\nexport default Counter;\n```\n\n# 의존성 문제\n\n이 예제에서 onIncrement 함수는 count를 의존성으로 하는 useCallback으로 래핑되어 있습니다. count가 변경될 때마다 onIncrement가 다시 생성됩니다.\n\n\n\n# Mlyn과 함께 간단하게\n\nMlyn은 세부적인 반응성을 소개하여 의존성을 걱정하지 않고 상태 업데이트를 관리할 수 있습니다. Mlyn을 사용하여 동일한 예제를 다시 작성해 봅시다.\n\n# Mlyn 예제\n\n```js\nimport React, { useCallback } from \"react\";\nimport { rc, useSubject } from \"mlyn/react\";\nconst Counter = rc(() => {\n  const state = useSubject({ count: 0 });\n  const increment = useCallback(() => {\n    state.count(state.count() + 1);\n  }, []);\n  return (\n    <div>\n      <h1>Count: {state.count()}</h1>\n      <button onClick={onIncrement}>Increment</button>\n    </div>\n  );\n});\n\nexport default Counter;\n```  \n\n\n\nstate.count의 참조가 변경되지 않기 때문에 useCallback에서 해당 값을 다시 만들지 않고도 읽을 수 있습니다.\n\n# 정교한 Reactivity의 장점\n\n- Stable Callbacks: Mlyn의 onIncrement 함수는 state.count를 의존성으로 필요로하지 않습니다. 이러한 안정성은 함수의 불필요한 재생성을 방지합니다. 그리고 onIncrement의 소비자들은 count가 변경되어도 다시 렌더링되지 않습니다.\n- 단순화된 코드: Mlyn을 사용하면 종속성을 수동으로 추적할 필요가 없습니다.\n\n# IncrementButton 추출: 다시 렌더링에 대한 더 깊은 이해\n\n\n\nLet’s extract the increment button into theIncrementButton component to understand how Mlyn’s approach prevents unnecessary re-renders.\n\n# Traditional React: Re-Rendering Issue\n\nIn the traditional example, IncrementButton re-renders every time count changes because increment is a new function reference each time.\n\n```js\nconst IncrementButton = React.memo(({ onIncrement }) => {\n  console.log(\"IncrementButton re-rendered\");\n  return (\n    <div>\n      <button onClick={onIncrement}>Increment from Child</button>\n    </div>\n  );\n});\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  const onIncrement = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, [count]); // Dependency on count\n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <IncrementButton onIncrement={onIncrement} />\n    </div>\n  );\n};\n```\n\n\n\n# Mlyn: 불필요한 다시 렌더링 방지\n\nMlyn을 사용하면 onIncrement가 동일한 참조로 유지되어 IncrementButton이 불필요하게 다시 렌더링되지 않습니다. 이것은 섬세한 용량으로 반응하는 주요 장점입니다.\n\n# 예제 재방문\n\n```js\nconst Counter = rc(() => {\n  const state = useSubject({ count: 0 });\n  const onIncrement = useCallback(() => {\n    state.count(state.count() + 1); // 어떤 종속성도 필요하지 않습니다\n  }, []);\n  return (\n    <div>\n      <h1>Count: {state.count()}</h1>\n      <IncrementButton onIncrement={onIncrement} />\n    </div>\n  );\n});\n```\n\n\n\n# 개요\n\nMlyn의 섬세한 리액티브는 상태 관리를 간단하게 만들어 줍니다:\n\n- 의존성 추적이 필요 없어집니다: 수동으로 종속성을 업데이트할 필요 없이 더 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n- 불필요한 다시 렌더링 방지: 컴포넌트는 실제 상태나 프롭이 변경될 때만 다시 렌더링되어 성능과 효율성을 향상시킵니다.\n\nMlyn을 도입함으로써, React 엔지니어는 복잡한 상태 종속성을 관리하는 귀찮음 없이 기능이 풍부한 코드 작성에 집중할 수 있습니다. 다음 프로젝트에 Mlyn을 통합해보고 섬세한 리액티브의 편리함을 경험해보세요!\n\n\n\nmlyn에 관심이 있다면, GitHub에서 확인해보세요: [https://github.com/vaukalak/mlyn](https://github.com/vaukalak/mlyn)","ogImage":{"url":"/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png"},"coverImage":"/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png","tag":["Tech"],"readingTime":4},{"title":"JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내","description":"","date":"2024-05-14 14:02","slug":"2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide","content":"\n\n![image](/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png)\n\n라이브 기사 — 최근 업데이트: 2024년 2월 7일.\n\n프로그래밍 언어에서 새로운 기능을 발견하는 것은 휴일이나 생일처럼 기대감과 새로운 선물을 탐험하는 기쁨으로 가득한 흥미진진한 시간입니다. ES2024®의 제안된 기능으로 인해 개발자들은 JavaScript 코딩을 더 효율적이고 가독성 있고 견고하게 만들어 주는 다양한 향상을 풀어나가려는 이유입니다. 최상위 await의 직관적인 구문부터 파이프라인 연산자의 표현력 있는 기능, 그리고 불변 레코드와 튜플의 신뢰성까지, 각 새로운 기능은 선택된 선물처럼 주어져서 JavaScript 생태계를 발전시키고 개발자들에게 더 많은 도구를 제공하기 위해 공들여 디자인되었습니다.\n\nECMAScript 2024 국제화 API 사양(ECMA-402 11판)에 따르면 ES2024에는 여러 기능이 포함될 예정입니다.\n\n\n\n그냥 유의해 주세요. 몇 가지는 여전히 \"제안 사항\"이라서 조금씩 변경될 수 있지만, 다행히도 이 문서는 승인된 변경 사항에 맞춰 조정될 것입니다!\n\n더 이상 미루지 말고…\n\n# 잘 형성된 유니코드 문자열\n\n이 기능은 JavaScript가 유니코드 문자열을 처리하는 방식을 개선하려는 것입니다. 유니코드 문자열은 다양한 언어와 기호를 나타내는 데 중요합니다. 이 업데이트는 다른 JavaScript 환경에서 이러한 문자열을 일관되고 정확하게 처리할 수 있도록 보장할 것입니다.\n\n\n\n```js\nconst sampleStrings = [\n  // 혼자 있는 대체문자가 포함된 예제\n  \"igor\\uD800\", // 앞 부분 대체문자\n  \"igor\\uD800komolov\", // 앞 부분 대체문자 뒤에 텍스트\n  \"\\uDC00yourfuse\",    // 뒷 부분 대체문자\n  \"your\\uDC00fuse\",    // 뒷 부분 대체문자 뒤에 텍스트\n  \n  // 올바르게 작성된 예제\n  \"yourFuse\",       // 대체문자 없는 일반 문자열\n  \"emoji\\uD83D\\uDE00\", // 완전한 대체 문자 쌍(이모지)을 갖는 문자열\n];\n\nsampleStrings.forEach(str => {\n  console.log(`처리된 문자열: ${str.toWellFormed()}`);\n});\n\n// 기대 출력:\n// \"처리된 문자열: igor�\"\n// \"처리된 문자열: igor�komolov\"\n// \"처리된 문자열: �yourfuse\"\n// \"처리된 문자열: your�fuse\"\n// \"처리된 문자열: yourFuse\"\n// \"처리된 문자열: emoji😀\"\n```\n\n위의 예제에서는 toWellFormed() 메소드가 혼자 있는 대체 문자와 올바르게 작성된 문자열이 포함된 문자열 배열에 적용됩니다. 이 메소드는 혼자 있는 대체 문자를 올바르게 작성된 유니코드 문자열로 변환하여 잘못된 시퀀스를 대체 문자로 바꾸며, 이미 올바르게 작성된 문자열은 변경하지 않습니다.\n\n```js\nconst problematicURL = \"https://yourfuse.com/query=\\uDC00data\";\n\ntry {\n  encodeURI(problematicURL);\n} catch (e) {\n  console.log('에러:', e.message); // 기대 결과: URIError: URI malformed\n}\n\n// toWellFormed()를 사용하여 에러 방지\nconsole.log('올바른 형식의 URI:', encodeURI(problematicURL.toWellFormed())); \n// 기대 출력: \"https://yourfuse.com/query=%EF%BF%BDdata\"\n```\n\n- problematicURL 변수에는 뒷 부분 대체 문자(\\uDC00)를 포함한 URL이 들어 있습니다.\n- encodeURI()로 이 URL을 인코딩하려고 하면 잘못된 유니코드 문자열로 인해 URIError가 발생합니다.\n- toWellFormed()를 적용하면 혼자 있는 대체 문자가 유니코드 대체 문자(U+FFFD, %EF%BF%BD로 인코드)로 대체되어 encodeURI()가 오류 없이 처리할 수 있게 됩니다.\n\n\n\n# Atomic waitSync\n\n이 추가 사항은 주로 공유 메모리 컨텍스트에서 동시 작업을 대상으로 합니다. 이는 데이터 무결성을 보장하고 멀티스레드 작업에서 경합 조건을 방지하는 데 중요한 동기화 메커니즘을 제공합니다. 예를 들어, waitSync는 여러 작업자 간의 공유 버퍼에 대한 액세스를 동기화하는 데 사용될 수 있습니다.\n\n아직 예제가 제공되지 않아 문서가 아직 작성 중이므로 어떻게 구현될지 보여드릴 수 없습니다. 그러나 기존 Atomics 메서드를 기반으로 가정을 할 수 있습니다. 다음과 같습니다...\n\n```js\n// sharedArray가 SharedArrayBuffer임을 가정합니다.\nconst sharedArray = new Int32Array(new SharedArrayBuffer(1024));\n\nfunction performSynchronizedOperation(index, value) {\n    // waitSync 메서드는 특정 조건이 충족될 때까지 실행을 차단합니다.\n    // 예를 들어, 지정된 인덱스의 값이 0이 아닌 값이 될 때까지 기다릴 수 있습니다.\n    Atomics.waitSync(sharedArray, index, 0);\n\n    // 공유 메모리에서 작업 수행\n    sharedArray[index] = value;\n\n    // 다른 스레드나 작업자에게 인덱스의 값이 업데이트되었음을 알립니다.\n    Atomics.notify(sharedArray, index, 1);\n}\n\n// 웹 워커나 다른 스레드에서\nperformSynchronizedOperation(0, 123);\n```\n\n\n\n# 정규 표현식의 v 플래그와 집합 표기법 + 문자열 속성\n\n자바스크립트의 정규 표현식에 대한 이 개선 사항은 더 복잡한 패턴 매칭과 문자열 조작을 가능하게 합니다. 'v' 플래그와 집합 표기법을 사용하면 더 정확하고 표현력 있는 정규식 패턴을 생성할 수 있습니다. 예를 들어, 이 기능을 사용하여 특정 유니코드 속성을 가진 문자 집합을 일치시킬 수 있습니다.\n\n```js\n// 차이/빼기\n[A--B]\n\n// 교집합\n[A&&B]\n\n// 중첩된 문자 클래스\n[A--[0-9]]\n```\n\nA와 B는 문자 클래스(예: [a-z])나 속성 이스케이프를 나타냅니다. 제안에 대한 설명적인 예제와 FAQ을 확인할 수 있습니다.\n\n\n\n# 최상위 await\n\n이 \"Just Do It\" 기능은 await 키워드가 비동기 함수 외부에서도 사용되도록 허용하여 비동기 코드를 더 쉽게 작성하고 읽을 수 있게 합니다. 예를 들어, 모듈의 최상위 수준에서 프로미스를 직접 await할 수 있어 모듈 가져오기 또는 데이터 비동기로 가져오는 코드를 간소화할 수 있습니다.\n\n```js\n// 최상위 await 사용\nconst data = await fetchData();\nconsole.log(data);\n```\n\n정말로 무겁고 복잡한 async/await 구조에 새로운 바람을 불어넣어 줍니다!\n\n\n\n# 파이프라인 연산자\n\n파이프라인 연산자(`|`)는 여러 함수 호출로 이루어진 코드의 가독성을 향상시킵니다. 이는 함수형 스타일 구문을 허용하여 식의 결과를 다음 함수의 인자로 전달할 수 있게 합니다. 예를 들어, 중첩된 함수 호출을 명확한 연산 순서로 재구성할 수 있습니다:\n\n```js\n// 파이프라인 연산자 없이\nconst calculatedValue = Math.ceil(Math.pow(Math.max(0, -10), 1/3));\n\n// 파이프라인 연산자 사용 시\nconst calculatedValue = -10\n  |> (n => Math.max(0, n)) // Math.max 대체\n  |> (n => Math.pow(n, 1/3)) // Math.pow 대체\n  |> Math.ceil; // Math.ceil 사용\n```\n\n이 예제에서:\n\n\n\n- Math.max 함수는 숫자가 음수가 아닌지 확인합니다.\n- Math.pow 함수는 세제곱근을 계산합니다 (1/3의 거듭제곱).\n- Math.ceil 함수는 숫자를 가장 가까운 정수로 올립니다.\n\n파이프라인 연산자(`|`)는 이러한 작업들을 연쇄적으로 쉽게 할 수 있게 해주어 코드를 더 읽기 쉽게 만듭니다.\n\n이제 다음은 데이터 변환에 파이프라인 연산자가 얼마나 유용한지 보여주는 예제입니다:\n\n```js\n// 파이프라인 연산자는 일련의 함수들을 명확하고 간결한 방식으로 연쇄적으로 적용하여 복잡한 데이터 조작을 간단하게 합니다.\n\nconst numbers = [10, 20, 30, 40, 50];\n\nconst processedNumbers = numbers\n  |> (_ => _.map(n => n / 2)) // 각 숫자를 절반으로 나누기\n  |> (_ => _.filter(n => n > 10)); // 10보다 작거나 같은 숫자 제외하기\n\nconsole.log(processedNumbers); // [15, 20, 25]\n```  \n\n\n\n이 예제에서:\n\n- map 함수는 배열 내의 각 숫자를 절반으로 나눕니다.\n- filter 함수는 10 이하인 숫자를 제거합니다.\n- 파이프라인 연산자 (|`)를 사용하여 이러한 변환을 우아하게 연결하여 코드 가독성을 향상시킵니다.\n\n기억하세요, 파이프라인 연산자는 여전히 \"Draft\" 상태인 TC39의 단계 2에 있습니다.\n\n# 레코드 및 튜플\n\n\n\n이 변하지 않는 데이터 구조들은 각각 객체와 배열과 유사하지만 생성 후 수정할 수 없습니다. 예를 들어, 레코드나 튜플을 업데이트하면 새로운 인스턴스가 생성됩니다:\n\n```js\n// 불변한 레코드 생성\nconst userProfile = #{\n  username: \"IgorKomolov\",\n  age: 39,\n};\n\n// 불변한 튜플 생성\nconst numberSequence = #[10, 20, 30];\n\n// 이러한 구조를 업데이트하면 새로운 인스턴스가 생성됩니다\nconst updatedProfile = userProfile.with({ age: 40});\nconsole.log(updatedProfile); // #{ username: \"IgorKomolov\", age: 40 }\nconsole.log(userProfile); // #{ username: \"IgorKomolov\", age: 39 } (변하지 않음)\n\nconst newNumberSequence = numberSequence.with(1, 25);\nconsole.log(newNumberSequence); // #[10, 25, 30]\nconsole.log(numberSequence); // #[10, 20, 30] (변하지 않음)\n```\n\n레코드는 객체와 유사하게 동작하고, 튜플은 배열과 유사합니다. 그러나 그들의 핵심 특징은 불변성입니다.\n\n레코드와 튜플은 특정 상황에서 성능을 향상시키고 코드베이스에서 불변성을 강제할 수 있습니다. 이들은 제안의 2단계에 있으며 아직 JavaScript 엔진에 구현되지는 않았지만, 개발자들은 Babel과 같은 트랜스파일러를 사용하여 이들을 실험할 수 있습니다.\n\n\n\n# 데코레이터\n\n이제 이게 가능해졌어요, TypeScript에 감사해요! 클래스, 메서드, 속성 또는 매개변수의 동작을 수정하거나 확장하는 기능을 제공합니다. 주석 추가, 로깅 또는 선언적 방식으로 동작을 수정하는 데 특히 유용합니다:\n\n```js\n// 메서드 실행을 추적하기 위해 데코레이터 적용\nclass SampleClass {\n  @trackExecution\n  performAction(parameter1, parameter2) {\n    // 메서드 구현 내용이 여기에 있습니다\n  }\n}\n```\n\n이 예시에서:\n\n\n\n- SampleClass는 정의되는 클래스입니다.\n- @trackExecution은 performAction 메서드 호출을 기록하거나 추적하기 위해 사용되는 데코레이터입니다.\n- performAction은 SampleClass 내의 메서드로, 두 개의 매개변수(parameter1 및 parameter2)를 사용합니다. 이 데코레이터는 이 메서드에 대한 각 호출을 기록하거나 추적합니다.\n\n# 패턴 매칭\n\n이 기능은 복잡한 데이터 구조의 비구조화 및 일치에 대한 간결한 구문을 소개하여 코드 가독성을 높이고 보일러플레이트를 줄입니다.\n\n(연구 중) 더 많은 정보가 곧 제공될 예정이니 나중에 다시 확인해주세요!\n\n\n\n# Temporal\n\n잠시만요! 엄청 오래전에 기획되었지만, 업데이트된 Temporal은 JavaScript를 위해 제안된 최신 및 포괄적인 날짜 및 시간 API로, 현재 Stage 3에 있어요. 기존 Date 객체의 제한 사항과 복잡성 중 많은 부분을 해결하기 위해 설계되었어요. 여기 ES2024에서 Temporal을 사용하는 몇 가지 예시가 있어요:\n\n이 객체는 현재 시간에 대한 Temporal 값을 생성하기 위한 여러 팩토리 메서드를 제공해요.\n\n## UTC에서 현재 시간 가져오기\n\n\n\n\nTemporal.Now.instant().toString()\n\n## 특정 시간대에서 현재 존재하는 날짜 및 시간 가져오기\n\nTemporal.Now.zonedDateTimeISO(`Asia/Shanghai`).toString()\n\n## ISO 형식의 현재 플레인 날짜 및 시간 가져오기\n\n\n\n\n표를 아래와 같이 Markdown 형식으로 변경해주세요.\n\nTemporal.Now.plainDateTimeISO().toString()\n\n## 현재 plain 시간을 ISO 형식으로 얻기\n\nTemporal.Now.plainTimeISO().toString().\n\n## ZonedDateTime.prototype의 속성\n\n\n\nTemporal의 ZonedDateTime 클래스에는 날짜 및 시간 정보를 자세히 조작하고 검색할 수 있는 여러 속성과 메서드가 있습니다.\n\n- 이러한 속성 및 메서드에는 달력, 시간대, 연도, 월, 일, 시간, 분, 초 및 나노초를 반환하는 getter가 포함됩니다.\n- .with(), .add(), .subtract(), .until(), .since(), .round()과 같은 메서드도 포함되어 있어, 지역 시간 값을 다루는 데 풍부한 기능을 제공합니다.\n\n## Temporal의 Plain Time 클래스\n\nTemporal은 시간대 없이 시간을 나타내는 추상 클래스인 \"plain\" 클래스를 소개합니다.\n\n\n\n- 이러한 클래스에는 PlainDateTime, PlainDate 및 PlainTime이 포함됩니다.\n- 이들은 특정 시간대에서 벽시간을 표시하거나 1984년 6월의 첫 번째 화요일을 찾는 것과 같이 시간대가 중요하지 않은 시간 계산에 유용합니다.\n\n이 예시들은 ES2024의 Temporal이 JavaScript에서의 날짜 및 시간 처리를 간단하고 향상시킬 수 있다는 것을 보여줍니다. 개발자들에게 더 견고하고 다재다능한 도구를 제공합니다.\n\n지금 사용해보고 싶으신가요? 문제없어요!\n\n제안을 가져오거나 Babel Polyfil을 사용해보세요. 이렇게 제안을 가져오는 방법이 있습니다...\n\n\n\n```js\n//네 맞아요, 제안서도 가져올 수 있어요 :)\nimport { Temporal } from '@std/proposal-temporal';\n\n\n//기본 연산\nconst now = Temporal.Now.zonedDateTimeISO('America/New_York');\nconsole.log(now.toString());\n\n//조작 및 비교\n\nconst date = Temporal.PlainDate.from('2024-01-01');\nconst newDate = date.add({ days: 10 });\nconsole.log(newDate.toString()); // 결과 '2024-01-11'\n```\n\n# 에르고노믹 브랜드 체크\n\n사용자 지정 클래스 및 데이터 구조에서 객체 타입을 확인하는 것을 단순화하여 유형 검증을 더 직관적이고 실수를 줄입니다. 이제 부모 복제본은 보지 않을 거예요!\n\n## 전통적인 방법 (ES2024 이전)\n\n\n\n```js\nclass Book {\n    #author;\n\n    constructor(author) {\n        this.#author = author;\n    }\n\n    static hasAuthorField(obj) {\n        try {\n            obj.#author; // 비공개 필드에 접근 시도\n            return true; // 접근 성공\n        } catch (err) {\n            if (err instanceof TypeError) {\n                return false; // 접근 실패, 필드가 존재하지 않음\n            }\n            throw err; // 다른 오류는 다시 던짐\n        }\n    }\n}\n\n// 사용 예시:\nconst myBook = new Book(\"Igor Komolov\");\nconsole.log(Book.hasAuthorField(myBook)); // 예상 결과: true\n\nconst otherObject = {};\nconsole.log(Book.hasAuthorField(otherObject)); // 예상 결과: false\n```\n\n## 새로운 ES2024 방식\n\n```js\nclass BookES2024 {\n    #author;\n\n    constructor(author) {\n        this.#author = author;\n    }\n\n    static hasAuthorField(obj) {\n        return #author in obj; // 비공개 필드를 확인하는 새로운 ES2024 구문\n    }\n}\n\n// 사용 예시:\nconst myBook2024 = new BookES2024(\"Igor Komolov\");\nconsole.log(BookES2024.hasAuthorField(myBook2024)); // 예상 결과: true\n\nconst otherObject2024 = {};\nconsole.log(BookES2024.hasAuthorField(otherObject2024)); // 예상 결과: false\n```\n\n이 예제에서 Book 클래스는 전통적인 방식을 보여주고, BookES2024는 새로운 ES2024 구문을 사용합니다. hasAuthorField 정적 메소드는 #author 비공개 필드가 객체에 존재하는지 확인하며, 각 클래스에서 서로 다른 접근 방식을 사용합니다.\n\n\n\n# Realms API\n\n이 API는 격리된 JavaScript 환경을 만드는 메커니즘을 제공합니다. 안전한 코드 실행 및 샌드박싱에 유용하며, 제어된 격리된 컨텍스트에서 코드를 실행할 수 있게 합니다. 게다가, 이름도 너무 멋져요!\n\n## Realm 생성 및 간단한 표현식 평가\n\n```js\nconst igorsRealm = new Realm();\nigorsRealm.evaluate('3 * 5'); // Igor의 영역에서 15로 계산됨\n```\n\n\n\n## 다른 영역 간 심볼 공유\n\n```js\nconst igorsRealm = new Realm();\nSymbol.for('y') === igorsRealm.evaluate('Symbol.for(\"y\")'); // true 반환, 공유된 심볼 'y'\n```\n\n## 자동 래핑된 함수 사용\n\n한 영역에서 다른 영역으로 전송된 호출 가능한 객체의 경우 대상 영역에서 래핑된 함수 이국적 객체가 생성됩니다. 호출되는 경우 래핑된 함수는 원래 영역의 연결된 함수로 호출을 연결합니다.\n\n\n\n```js\nconst igorsRealm = new Realm();\nconst doubleFunction = igorsRealm.evaluate('num => num * 2');\ndoubleFunction(10); // 결과: 20\n```\n\n## 콜백을 이용한 함수 평가\n\n```js\nconst igorsRealm = new Realm();\nconst processNumber = igorsRealm.evaluate('(number, callback) => callback(number + 5)');\nprocessNumber(5, (result => console.log(result))); // 로그: 10 (5 + 5)\n```\n\n## 제한된 전역 컨텍스트 접근\n\n\n\n\n글로벌 객체인 globalThis, 배열 또는 Object.prototype에 realm.evaluate를 통해 직접 액세스하는 것은 TypeError를 발생시킵니다.\n\n```js\nconst igorsRealm = new Realm();\nigorsRealm.evaluate('this'); // TypeError 발생\nigorsRealm.evaluate('new Array()'); // TypeError 발생\nigorsRealm.evaluate('Object.keys({})'); // TypeError 발생\n```\n\nES2024에서 예정된 새로운 기능들은 자바스크립트 코딩에 접근하는 방식을 혁신할 것으로 예상됩니다. 이러한 향상들은 코드 가독성과 효율성을 향상시키는 것뿐만 아니라 불변 데이터 구조와 고급 패턴 매칭과 같은 강력한 새로운 패러다임을 소개하기도 합니다. 이러한 기능들이 제안에서 구현으로 이동할 때, 개발자들이 더 깨끗하고 유지보수 가능하며 표현력이 풍부한 자바스크립트 코드를 작성할 수 있는 새로운 가능성을 열어줍니다. 이러한 진보로운 발전과 함께 자바스크립트의 미래는 밝아보이며, 현대 웹 개발의 중요한 요충지가 된 언어의 지속적인 발전을 시사합니다.","ogImage":{"url":"/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png"},"coverImage":"/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png","tag":["Tech"],"readingTime":11},{"title":"크롬 콘솔 유틸리티 모든 개발자가 알아야 할 내용","description":"","date":"2024-05-14 14:00","slug":"2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow","content":"\n\n\n![ChromeConsoleUtilities](/assets/img/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow_0.png)\n\n모든 표준 웹 브라우저는 일반적으로 개발자가 웹 앱을 디버깅할 수 있는 도구를 제공합니다. 예를 들어 대부분의 브라우저에는 내장된 JavaScript 디버거, DOM 트리 인스펙터, 네트워크 모니터 및 네트워크 속도 시뮬레이터가 있습니다. 인기 있는 Google Chrome 브라우저는 생산성 중심의 웹 앱 디버깅 기능을 제공하는 잘 알려진 DevTools 툴킷을 제공합니다. DevTools 프로토콜 덕분에 네이티브 웹 앱 디버깅 외에도 Chrome에서 TypeScript, Deno, Node.js 및 React Native 앱을 디버깅할 수 있습니다.\n\n웹 앱 디버깅 프로세스는 주로 브라우저 콘솔, 디버거 인터페이스 및 DOM 인스펙터를 사용합니다. 웹 개발자들은 보통 브라우저 콘솔을 사용하여 디버깅과 실험적인 목적을 위해 빠른 코드 조각을 실행하고 디버깅 관련 로그 값을 확인합니다. Chrome은 GNU/Linux 터미널에서 개발자 생산성을 높이는 Bash 해석기와 같은 여러 생산성 중심 단축키를 제공하여 콘솔에서 코드 조각을 효율적으로 작성하는 데 도움을 줍니다. 이러한 Chrome 콘솔 유틸리티 단축키를 사용하여 웹 애플리케이션 디버깅 관련 작업(예: 인스펙터에서 선택된 DOM 요소 가져오기)을 빠르게 처리할 수 있습니다. 이러한 콘솔 유틸리티는 브라우저 콘솔에서만 작동하므로 웹 앱 소스 파일에서 이름 충돌을 걱정할 필요가 없습니다.\n\n이 기사에서는 Chrome에서 사용할 수 있는 여러 콘솔 유틸리티를 설명하여 웹 애플리케이션을 더 빠르게 디버깅할 수 있도록 도와드리겠습니다. 디버깅 활동 중에 번거롭고 긴 코드 입력이 필요한 마우스 클릭이나 입력을 피하고 Chrome 콘솔에서 이러한 빠른 단축키를 사용하세요.\n\n\n\n\n# 빠른 DOM 노드 선택을 위한 JQuery 스타일 셀렉터\n\n인기있는 JQuery 라이브러리는 기존의 웹 API보다 CSS 셀렉터를 기반으로 DOM 요소를 선택하는 더 생산적인 방법을 제공합니다. 만약 콘솔에서 일부 DOM 노드 속성에 액세스하거나 일부 DOM 노드를 검색해야 하는 경우는 어떨까요? 웹 앱이 JQuery를 사용한다면 JQuery를 사용할 수 있으므로 $ 구문을 사용할 수 있지만, 만약 JQuery를 사용하지 않는다면요?\n\nChrome은 JQuery 라이브러리를 사용하지 않아도 콘솔에서 $ 구문을 사용할 수 있게 해줍니다. Chrome 콘솔에서 $는 단일 요소를 즉시 쿼리할 수 있도록 document.querySelector 메서드의 단축키로 작동합니다:\n\n```js\n$('.item-01')\n```\n\n\n\n위의 코드 스니펫은 item-01 클래스 이름을 가진 첫 번째 DOM 노드를 출력합니다. 비슷하게, $$ 바로 가기는 document.querySelectorAll 메서드를 트리거하고 하나 이상의 요소를 반환합니다. 예를 들어, 다음 코드 스니펫은 모든 `h1` 요소를 출력합니다:\n\n```js\n$$('h1')\n```\n\nXPath 표현식을 기반으로 DOM 요소를 선택할 수도 있습니다. 다음과 같이 사용합니다:\n\n```js\n$x('/html/body/div')\n```\n\n\n\n# 표준 콘솔 API 단축키\n\n모든 브라우저와 Node.js와 같은 JavaScript 실행 환경은 웹 앱 코드베이스에서 디버깅을 위해 개발자들이 사용할 수 있는 완전한 기능을 갖춘 콘솔 API를 제공합니다. 예기치 않은 문제가 발생할 때 브라우저 콘솔에 몇 가지 메시지를 기록할 수 있습니다. 그런 다음 개발자 또는 사용자 테스트 중에 중요 문제를 진단하기 위해 분석할 수 있습니다. console.log, console.error, console.warn은 일반적으로 사용되는 콘솔 로깅 방법입니다.\n\nChrome은 디버깅 생산성을 향상시키기 위해 여러 콘솔 API에 대한 단축 함수 이름만을 제공합니다. dir 함수는 console.dir API 메소드를 트리거하므로 객체의 키-값 데이터를 출력하는 데 사용할 수 있습니다. 이것은 콘솔이 기본적으로 HTML 코드와 함께 요소를 출력할 때 DOM 요소 속성을 출력하는 좋은 메커니즘입니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*edY7C6664IEZlnhK3uEfCA.gif)\n\n\n\n비슷하게, 콘솔 표시 방법을 이용하기 위해 table 함수를 사용할 수 있습니다. 또한 clear 함수는 console.clear 메서드를 호출하여 브라우저 콘솔을 지웁니다.\n\n콘솔 API는 또한 성능 프로파일러를 시작하고 중지하는 두 가지 표준이 아닌 메서드를 제공합니다. Chrome은 profile 및 profileEnd 콘솔 함수 단축키를 통해 이러한 프로파일러 전용 콘솔 API 메서드를 호출하며, 다음 미리 보기에 나와 있습니다:\n\n![JavaScript Object API Shortcuts](https://miro.medium.com/v2/resize:fit:1400/1*Bh2JR81JSCzdF55B1PFeng.gif)\n\n\n\n현대적인 범용 프로그래밍 언어인 JavaScript는 거의 모든 개발 요구 사항을 위한 완전히 갖춘 미리 로드된 표준 라이브러리를 제공합니다. JavaScript는 JSON과 유사한 객체 개념과 내장 JSON 직렬화/역직렬화를 사용하여 객체를 다루는 데 생산적인 방법을 제공합니다. 모든 웹 개발자가 Object.keys 및 Object.values 메서드를 알고 있습니다. 이들은 JavaScript 객체에서 키와 값을 추출하는 데 도움이 되는 메서드입니다. Chrome 콘솔 유틸리티는 키와 값 내장 기능 바로 가기를 구현하며 디버깅 활동 중에 이러한 자주 사용되는 Object API 메서드를 생산적으로 사용할 수 있게 해줍니다.\n\n다음 객체의 키와 값을 별도로 검사해야 한다고 가정해 보겣습니다:\n\n```js\nconst doc = {\n  id: 100,\n  title: 'My document',\n  size: 'A4',\n  authorId: 100\n}\n```\n\n위 객체의 키만 출력하려면, 다음 미리보기에 표시된 대로 keys 함수를 사용할 수 있습니다.\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*kDCuc9qJcb5Af0z8nH0FOQ.gif)\n\n\"values\" 함수는 특정 객체의 모든 값을 출력하는 효율적인 방법을 제공합니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*1eIQH3rgOnfb6Po5Kgu5hQ.gif)\n\n다음 이야기는 경험 많은 웹 개발자로서 알아야 할 새로운 브라우저 API를 설명합니다:\n\n\n\n\n# 브레이크포인트 설정 및 소스 코드 검사를 위한 바로 가기\n\n현대 웹 앱 디버깅 프로세스는 일반적으로 브레이크포인트와 DOM 검사를 활용합니다. 브레이크포인트는 JavaScript 디버깅을 도와주고, DOM 검사는 HTML 분석 및 CSS 기반 스타일링 개선을 지원합니다. 브레이크포인트를 설정하려면 개발자 도구 인터페이스나 디버거 JavaScript 문을 사용할 수 있습니다. Chrome 콘솔도 브레이크포인트 설정을 위한 생산성 바로 가기를 제공합니다.\n\n다음과 같은 함수가 현재 콘솔 컨텍스트에 로드되어 있고 사용 가능하다고 가정해 봅시다:\n\n```js\nfunction genArr(n) {\n  let sq = n ** 2;\n  sq = Math.min(sq, 1000);\n  let arr = [...new Array(sq).keys()];\n  return arr;\n}\n```\n\n\n\ngenArr 함수 내에서 중단점을 설정해야 한다고 가정해봅니다. 콘솔에서 debug 함수를 호출하여 자동 중단점을 활성화할 수 있습니다:\n\n```js\ndebug(genArr)\n```\n\n그러면, 개발자 도구가 genArr 함수에 자동으로 중단점을 추가할 것입니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*FkCGFnh2yVQ1O9lWH0B8fQ.gif\" />\n\n\n\n지금은 genArr 함수가 실행될 때 자동 중단점이 코드 실행을 중단시킵니다. 다음 함수 호출로 자동 중단점을 비활성화할 수 있습니다:\n\n```js\nundebug(genArr)\n```\n\n위 접근법을 사용하면 중단점을 설정하고 함수를 검색할 수 있습니다. 자동 중단점을 활성화하지 않고 함수 소스를 확인해야 하는 경우 inspect 함수가 도움이 됩니다. 특정 함수로 이동하고 콘솔에 해당 함수의 소스를 출력합니다. 아래 미리보기에서 보여지는 것과 같습니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*f33oL_zYjf0OJikBbmUxmQ.gif\" />\n\n\n\n현재 활성 요소를 검사하는 기능을 사용할 수 있어요. \n\n```js\ninspect(document.activeElement)\n```\n\n# 함수 호출 모니터링\n\n디버깅 작업 중에 함수 호출을 감지하는 여러 방법이 있어요. 일부 개발자들은 주로 콘솔에 일부 값을 출력하여 함수 호출을 감지하기 위해 console.log 문을 수동으로 사용하죠. 한편, 일부 개발자들은 중단점을 설정합니다. 이러한 접근 방법에는 여러 가지 단점이 있어요. 특정 함수가 수천 번 호출된다면, 중단점으로는 시간이 많이 소요될 거에요. 반면 콘솔.log 기반 방법을 사용하려면 소스를 수동으로 편집해야 해요.\n\n\n\n크롬 콘솔 유틸리티에는 빌트인 콘솔 함수인 monitor 및 unmonitor이 있어서 소스 파일을 직접 편집하거나 중단점을 사용하지 않고도 함수 호출을 효율적으로 모니터링할 수 있습니다.\n\n이전 genArr 함수 실행을 모니터링해야 한다고 가정해봅시다:\n\n```js\nfunction genArr(n) {\n  let sq = n ** 2;\n  sq = Math.min(sq, 1000);\n  let arr = [...new Array(sq).keys()];\n  return arr;\n}\n```\n\n먼저 특정 함수에 대해 모니터링 기능을 활성화하세요:\n\n\n\n```js\nmonitor(genArr)\n```\n\n지금부터 genArr 함수에 들어오는 모든 호출을 모니터링하고 콘솔에 입력된 인수를 출력합니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*K8rzCdmRGu0IZXTa5EV7Vw.gif\" />\n\n다음 코드 스니펫을 사용하여 genArr 함수의 함수 모니터링을 비활성화할 수 있습니다:\n\n\n\n```js\nunmonitor(genArr)\n```\n\n# 콘솔 내에서 이벤트 처리하기\n\nDevTools에는 브라우저 이벤트를 감지하는 여러 가지 방법이 있습니다. 특정 이벤트가 트리거될 때 소스 브레이크포인트를 자동으로 설정하는 이벤트 브레이크포인트를 설정할 수 있습니다. 또한 window 객체에 연결된 전역 이벤트를 찾는 기능도 제공합니다. 그렇다면 콘솔에서 웹 앱 이벤트를 직접 감지하고 탐색하고 싶다면 어떻게 해야 할까요?\n\nChrome 콘솔 유틸리티는 getEventListeners 내장 함수를 제공하여 특정 객체의 등록된 이벤트 리스너를 찾을 수 있습니다. 예를 들어, 다음 코드 조각은 현재 활성 DOM 요소 객체에 연결된 모든 이벤트 리스너를 출력합니다:\n\n\n\n```js\ngetEventListeners(document.activeElement)\n```\n\n위의 유틸리티 함수는 등록된 이벤트 리스너를 살펴보는 데 도움이 됩니다. 특정 이벤트가 어떻게 트리거되었는지를 알고 싶을 때, DevTools GUI의 이벤트 리스너 브레이크포인트 기능을 사용하지 않고는 어떻게 할 수 있을까요?\n\nmonitorEvents 및 unmonitorEvents 바로 가기 함수를 사용하면 JavaScript 객체를 기반으로 브라우저 이벤트를 모니터링할 수 있습니다.\n\n다음 코드 스니펫을 살펴보세요:\n\n\n\n```js\nmonitorEvents(document.activeElement, 'click')\n```\n\n위의 코드 조각을 콘솔에 입력하면 현재 활성 요소의 모든 클릭 이벤트를 찾을 수 있어요:\n\n![click event monitoring](https://miro.medium.com/v2/resize:fit:1400/1*LRnKHf1OPXuqUl7z6YbDag.gif)\n\n다음 코드 조각으로 이벤트 모니터링을 비활성화할 수 있어요:\n\n\n\n```js\nunmonitorEvents(document.activeElement)\n```\n\n# 줄임표 디버그 관련 변수들\n\n모든 명령 줄 해석기는 일반적으로 개발 작업을 가속화하는 다양한 생산성 중심의 단축키를 제공합니다. 예를 들어 Bash 해석기는 이전 명령의 프로세스 종료 코드를 얻기 위한 특별 매개 변수 $?를 제공합니다. 비슷하게, Chrome 콘솔 해석기는 웹 앱 디버깅 작업을 위한 각종 줄임표 변수들을 제공합니다.\n\n$_ 줄임표 변수는 콘솔에서 실행된 이전 표현식의 반환 값을 리턴합니다.\n\n\n\n아래 예시를 살펴봐주세요:\n\n<img src=\"/assets/img/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow_1.png\" />\n\n이전에 document.activeElement 속성과 $ 쿼리 선택자 단축키를 사용하여 DOM 요소를 참조했습니다. 그러나 디버깅 중에 실제 렌더링된 DOM의 포커스를 변경하지 않고도 요소 탭(인스펙터) 내에서 DOM 트리 요소를 선택하는 것이 일반적입니다. 인스펙터에서 현재 선택된 DOM 요소를 가져오기 위한 단축 변수가 있다면 document.activeElement나 $ 기반 선택자 구문을 사용하지 않고도 콘솔에서 효율적으로 사용할 수 있습니다.\n\nChrome에서는 $0 단축 변수를 사용하여 인스펙터에서 선택된 DOM 요소를 참조할 수 있습니다. 콘솔을 통해 선택된 DOM 요소의 데이터 속성을 변경해야 한다고 가정해보세요. 다음 미리보기에 표시된 대로 수행할 수 있습니다:\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*XHlPmNHQwVPU4uTkxzMaKQ.gif)\n\n여기 이 기사의 보너스 디버깅 팁을 알려 드리겠습니다. 시스템 클립보드로 역직렬화된 JavaScript 객체를 복사하는 데 복사 함수를 사용할 수 있습니다.\n\n다음 예제 코드 조각을 살펴보세요. 이 코드는 샘플 JavaScript 객체를 시스템 클립보드로 복사합니다:\n\n```js\nconst doc = {\n  id: 100,\n  title: '내 문서',\n  size: 'A4',\n  authorId: 100\n};\ncopy(doc)\n```\n\n\n\n더 많은 생산성 중심 기능을 Chrome DevTools에서 배울 수 있는 다음 이야기를 확인해보세요:\n\n읽어줘서 고마워.","ogImage":{"url":"/assets/img/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":8},{"title":"JavaScript에서 내장 함수를 사용하지 않고 비동기 작업을 병렬로 실행하기","description":"","date":"2024-05-14 13:59","slug":"2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript","content":"\n\n![Excute Asynchronous Tasks in Parallel without Using Built-in Functions in JavaScript](/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png)\n\n비동기 작업은 데이터베이스에서 데이터를 가져오거나 네트워크 요청을 만들거나 파일에서 읽는 등 외부 이벤트를 기다리는 작업이 포함된 상황에서 특히 흔히 발생합니다.\n\n이러한 작업이 완료될 때까지 전체 프로그램을 멈추지 않고 비동기 작업은 서로 독립적으로 실행되며 서로 다른 시간에 완료될 수 있으므로 효율성과 반응성이 향상됩니다.\n\n비동기 병렬 실행을 통해 작업을 동시에 실행할 수 있으므로 하드웨어의 기능(예: 다중 CPU 코어)을 활용할 수 있습니다. 이는 시스템 자원을 더 효율적으로 사용하고 작업을 빠르게 완료할 수 있게 합니다. 예: 일괄 처리, 웹 서버 요청의 동시 실행.\n\n\n\n자바스크립트는 Promise.all()이나 Promise.race()와 같은 내장 함수를 제공하여 비동기 병렬 실행을 달성할 수 있습니다. 이러한 내장 함수들은 간단한 경우에 편리하지만, 더 복잡한 시나리오를 위해 자체 병렬 비동기 함수를 사용하면 더 많은 제어, 유연성 및 최적화 가능성을 제공할 수 있습니다.\n\n동일한 작업을 Promises를 사용하여 수행하기 위해 사용자 지정 함수를 작성하는 샘플 예제를 찾아보세요.\n\n```js\nconst executeParallel = (tasks) => {\n  return new Promise((resolve, reject) => {\n    const results = []; // 작업의 결과를 저장합니다\n    let completedCount = 0; // 완료된 작업을 추적합니다\n\n    const handleResolve = (result, index) => {\n      results[index] = result;\n      completedCount++;\n      if (completedCount === tasks.length) {\n        resolve(results);\n      }\n    };\n\n    const handleReject = (error) => {\n      reject(error);\n    };\n\n    tasks.forEach((task, index) => {\n      task()\n        .then((result) => {\n          // 모든 작업이 완료되면 주 Promise를 해결합니다\n          handleResolve(result, index);\n        })\n        .catch((error) => {\n          handleReject(error); // 작업 중 하나라도 실패할 경우 Promise를 거부합니다\n        });\n    });\n  });\n};\n\n// 예제 작업\nconst task1 = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('작업 1 완료');\n    }, 200);\n  });\n};\n\nconst task2 = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('작업 2');\n    }, 10);\n  });\n};\n\nconst task3 = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('105');\n    }, 50);\n  });\n};\n\nexecuteParallel([task1, task2, task3])\n  .then((results) => {\n    console.log('모든 작업 완료:', results);\n  })\n  .catch((error) => {\n    console.error('에러:', error);\n  });\n```\n\n위 구현에서:\n\n\n\n- executeParallel() 함수는 각각이 Promise를 반환하는 함수인 작업 배열을 가져옵니다.\n- executeParallel() 내에서 모든 작업의 완료를 추적하는 주요 Promise가 생성됩니다.\n- 각 작업은 Promise.resolve(task())를 사용하여 비동기적으로 실행됩니다.\n- 작업이 완료되면 그 결과가 배열에 저장되고 completedCount가 증가합니다.\n- 작업 중에 오류가 발생하면 주요 Promise는 해당 오류로 거부됩니다.\n- 모든 작업이 완료되면 주요 Promise는 결과 배열로 해결됩니다.\n\n이 블로그가 도움이 되고 통찰력을 줬기를 바랍니다. 읽어주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png","tag":["Tech"],"readingTime":3},{"title":"Nodejs에서의 디자인 패턴","description":"","date":"2024-05-14 13:57","slug":"2024-05-14-DesignPatternsinNodejs","content":"\n\nNode.js는 이벤트 주도, 비차단 I/O 모델을 사용하여 확장 가능한 네트워크 애플리케이션을 개발할 수 있는 인기 있는 JavaScript 런타임입니다. 다양한 디자인 패턴을 사용하면 코드 재사용, 유지 관리성 및 견고성을 증진시킬 수 있습니다. 이 기사에서는 Node.js 개발에 가장 유용한 디자인 패턴 중 일부를 개요하겠습니다.\n\n![](/assets/img/2024-05-14-DesignPatternsinNodejs_0.png)\n\n## 디자인 패턴 소개\n\n디자인 패턴은 소프트웨어 개발자가 코딩하는 동안 반복적으로 마주치는 문제에 대한 검증된 해결책입니다. 이는 도전적인 과제를 해결하는 구조화된 방법을 제공하며 소프트웨어 아키텍처에서 최상의 실천법을 촉진합니다. 디자인 패턴을 통합함으로써, 개발자는 더 견고하고 유지보수 가능하며 확장 가능한 코드베이스를 작성할 수 있습니다.\n\n\n\n## 왜 Node.js에서 디자인 패턴이 중요한 이유\n\nNode.js는 비차단 이벤트 주도 구조로 알려져 있어 소프트웨어 디자인에서 독특한 도전과 기회를 제공합니다. Node.js에 맞는 디자인 패턴을 적용하면 더 효율적이고 최적화된 애플리케이션을 개발할 수 있습니다. Node.js 생태계에서 특히 가치 있는 몇 가지 주요 디자인 패턴을 살펴보겠습니다:\n\n## 싱글톤 패턴\n\n싱글톤 패턴은 클래스가 하나의 인스턴스만 가지며 그에 대한 전역 액세스 지점을 제공하는 것을 보장합니다. Node.js에서 모듈이 캐시되고 애플리케이션 전체에서 공유될 수 있는 환경에서, 싱글톤 패턴을 사용하여 리소스를 효율적으로 관리할 수 있습니다. 예를 들어, 데이터베이스 연결 풀을 싱글톤으로 구현하여 자원 낭비를 방지할 수 있습니다.\n\n\n\n```js\nclass Database {\n  constructor() {\n    this.connection = null;\n  }\n  \n  static getInstance() {\n    if (!Database.instance) {\n      Database.instance = new Database();\n    }\n    return Database.instance; \n  }\n\n  connect() {\n    // connect to database\n    this.connection = 'Connected'; \n  }\n}\n\nconst db1 = Database.getInstance();\nconst db2 = Database.getInstance();\n\nconsole.log(db1 === db2); // true\n\ndb1.connect(); \n\nconsole.log(db1.connection); // 'Connected'\nconsole.log(db2.connection); // 'Connected'\n```\n\n중요한 점은:\n\n- 생성자는 직접 인스턴스화를 방지하기 위해 비공개로 만들었습니다.\n- 정적 메소드 getInstance()는 인스턴스가 아직 존재하지 않는 경우 인스턴스를 만들고 반환합니다. 이렇게 하면 하나의 인스턴스만 생성됩니다.\n- db1과 db2 인스턴스는 동일한 객체를 가리킵니다.\n- db1이 연결하면 동일한 객체이기 때문에 db2도 연결을 받습니다.\n\n이를 통해 하나의 데이터베이스 인스턴스만 있고 중복 연결을 방지할 수 있습니다. 싱글톤 패턴은 클래스의 하나의 인스턴스만 존재해야 하는 상황에 유용합니다.\n\n\n\n\n## 팩토리 패턴\n\n팩토리 패턴은 생성될 객체의 정확한 클래스를 지정하지 않고 객체를 생성하는 방법을 제공합니다. Node.js에서는 파일을 읽거나 API 호출과 같은 비동기 작업을 다룰 때 객체 생성을 간소화할 수 있습니다. 팩토리 패턴은 객체 생성을 추상화함으로써 코드의 가독성과 재사용성을 향상시킵니다.\n\n```js\nclass Car {\n  constructor(model, price) {\n    this.model = model;\n    this.price = price;\n  }\n}\n\nclass CarFactory {\n  createCar(model) {\n    switch(model) {\n      case 'civic':\n        return new Car('Honda Civic', 20000);\n      case 'accord':  \n        return new Car('Honda Accord', 25000);\n      case 'odyssey':\n        return new Car('Honda Odyssey', 30000);\n      default:\n        throw new Error('Unknown model');\n    }\n  }\n}\n\nconst factory = new CarFactory();\n\nconst civic = factory.createCar('civic');\nconst accord = factory.createCar('accord');\n\nconsole.log(civic.model); // Honda Civic \nconsole.log(accord.model); // Honda Accord\n```\n\n주요 포인트는:\n\n\n\n- CarFactory 클래스는 객체 생성 로직을 처리합니다.\n- createCar() 메서드는 모델을 기반으로 Car 인스턴스를 반환합니다.\n- 클라이언트 코드는 직접 생성자 호출 대신 팩토리를 사용합니다.\n\n이는 객체 생성 로직을 추상화하여 지원되는 모델을 쉽게 확장할 수 있게 합니다. 팩토리 패턴은 복잡한 객체 생성 로직이 클라이언트 코드에 결합되지 말아야 하는 경우 유용합니다.\n\n## 옵저버 패턴\n\nNode.js의 이벤트 주도 특성은 옵저버 패턴과 잘 맞습니다. 이 패턴은 의존하는 객체 목록인 옵저버라는 종속 항목 목록을 유지하는 주제를 포함하며 상태 변경 시 이들에게 알립니다. Node.js의 맥락에서는 이를 활용하여 실시간 애플리케이션 및 채팅 애플리케이션과 같은 이벤트 주도 시스템을 구축할 수 있습니다.\n\n\n\n```js\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  unsubscribe(observer) {\n    this.observers = this.observers.filter(o => o !== observer);\n  }\n\n  notify(data) {\n    this.observers.forEach(o => o.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n\n  update(data) {\n    console.log(`${this.name} received ${data}`);\n  }\n}\n\nconst subject = new Subject();\n\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('Hello World');\n// Observer 1 received Hello World\n// Observer 2 received Hello World\n\nsubject.unsubscribe(observer2);\n\nsubject.notify('Hello Again');\n// Observer 1 received Hello Again\n```\n\n주요 포인트는:\n\n- Subject는 관찰자 목록을 유지합니다.\n- 관찰자들은 주제에 구독하고 구독을 취소합니다.\n- notify()가 호출되면 주제는 구독된 관찰자들을 모두 업데이트합니다.\n\n이를 통해 발행자를 구독자에 결합하지 않고 여러 개체에 업데이트를 발행할 수 있습니다. Observer 패턴은 이벤트 처리와 비동기적인 워크플로에 유용합니다.\n\n\n\n\n## 미들웨어 패턴\n\nNode.js의 미들웨어 아키텍처는 웹 애플리케이션에서 요청과 응답을 처리하는 데 널리 사용됩니다. 미들웨어 패턴은 요청을 순차적으로 처리하는 함수 체인을 포함합니다. 각 함수는 요청이나 응답을 수정한 다음 체인 내의 다음 함수로 전달할 수 있습니다. 이 패턴은 모듈성을 향상시키며, 각기 다른 기능을 완벽하게 결합하지 않고도 개발자가 다양한 기능을 확장할 수 있도록 합니다.\n\n```js\nconst express = require('express');\nconst app = express();\n\nconst logger = (req, res, next) => {\n  console.log('Logged');\n  next();\n}\n\nconst authenticate = (req, res, next) => {\n  // 사용자 인증\n  next();\n}\n\napp.use(logger); \napp.use(authenticate);\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});\n\napp.listen(3000);\n```\n\n주요 포인트는:\n\n\n\n- 미들웨어 함수 logger와 authenticate는 라우트 핸들러를 감싸고 있어요.\n- 라우트 전후에 로직을 실행할 수 있어요.\n- next() 함수는 다음 미들웨어로 제어를 전달해요.\n- app.use()는 미들웨어를 전역으로 적용해요.\n\n이를 통해 요청 처리를 작은 재사용 가능한 단위로 분해할 수 있어요. 미들웨어 패턴은 Express 및 다른 Node.js 프레임워크에서 로깅, 인증 등과 같은 작업에서 매우 일반적으로 사용돼요.\n\n다른 미들웨어의 예시로는 body parsers, 압축, 속도 제한 등이 있어요. 이 패턴을 통해 모듈화된 방식으로 요청 파이프라인을 구축할 수 있어요.\n\n## 모듈 패턴\n\n\n\n모듈 패턴은 Node.js에서 가장 기본적이면서도 근본적인 패턴 중 하나입니다. 이 패턴을 사용하면 코드를 특정 기능을 캡슐화하는 별도의 파일 또는 모듈로 구성할 수 있습니다.\n\n```js\n// counter.js\n\nlet count = 0;\n\nconst increment = () => {\n  count++;\n}\n\nconst decrement = () => {\n  count--;\n}\n\nconst get = () => {\n  return count; \n}\n\nmodule.exports = {\n  increment,\n  decrement,\n  get  \n};\n\n// app.js\n\nconst counter = require('./counter');\n\ncounter.increment();\ncounter.increment();\n\nconsole.log(counter.get()); // 2\n\ncounter.decrement();\n\nconsole.log(counter.get()); // 1\n```\n\n중요한 포인트는:\n\n- counter.js 모듈은 private 변수인 count에 작용하는 함수들을 내보냅니다.\n- 함수들은 모듈 내부에서 로직과 데이터를 캡슐화합니다.\n- app.js는 모듈을 가져와 공개 API를 사용합니다.\n\n\n\n이 패턴은 데이터 캡슐화를 제공하며 오직 공개 API만 노출합니다. 모듈 패턴은 코드를 재사용 가능하고 이식 가능한 모듈로 구성하는 데 Node.js에서 매우 일반적으로 사용됩니다.\n\n다른 예시로는 미들웨어 모듈, 유틸리티 라이브러리, 데이터 접근 계층 등이 있습니다. 이 패턴은 의존성 관리와 구현 세부 정보 숨기기에 도움이 됩니다.\n\n## 데코레이터 패턴\n\n데코레이터는 다른 인스턴스에 영향을 주지 않으면서 객체에 새로운 기능을 동적으로 추가합니다. 이는 Node의 핵심 모듈을 확장하는 데 이상적입니다.\n\n\n\n```js\nclass Car {\n  constructor() {\n    this.price = 10000;\n  }\n\n  getPrice() {\n    return this.price;\n  }\n}\n\nclass CarOptions {\n  constructor(car) {\n    this.car = car;\n  }\n\n  addGPS() {\n    this.car.price += 500;\n  }\n  \n  addRims() {\n    this.car.price += 300; \n  }\n}\n\nconst basicCar = new Car();\n\nconsole.log(basicCar.getPrice()); // 10000\n\nconst carWithOptions = new CarOptions(basicCar);\n\ncarWithOptions.addGPS();\ncarWithOptions.addRims();\n\nconsole.log(carWithOptions.car.getPrice()); // 10800\n```\n\n주요 포인트:\n\n- CarOptions는 Car 클래스를 래핑하고 그 동작을 확장합니다.\n- addGPS()와 같은 메서드는 래핑된 Car의 상태를 수정합니다. \n- 클라이언트는 추가 기능이 있는 Car의 장식된 인스턴스를 갖게 됩니다.\n\n이는 실행 중에 동적으로 동작을 확장할 수 있도록 해줍니다. 데코레이터 패턴은 추상화에 유용하며 작은 기능을 추가하기 위해 서브클래스를 만들 필요가 없습니다.\n\n\n\n\n일부 다른 예시로는 인증된 경로, 로깅 래퍼, 캐싱 데코레이터 등이 있습니다. 이 패턴은 Node.js 애플리케이션에서 개방/폐쇄 원칙을 준수하는 유연한 방법을 제공합니다.\n\n## 의존성 주입 패턴\n\n의존성 주입은 모듈이나 클래스가 내부적으로 생성하는 대신 외부 소스에서 의존성을 받는 패턴입니다. 이는 간결함, 테스트 용이성, 재사용성을 촉진하는 데 도움이 됩니다.\n\n```js\n// service.js\nclass Service {\n  constructor(db, logger) {\n    this.db = db;\n    this.logger = logger;\n  }\n\n  async getUser(userId) {\n    const user = await this.db.findUserById(userId);\n    this.logger.log(`사용자 ${user.name}을(를) 가져왔습니다.`);\n    return user;\n  }\n}\n\n// app.js\nconst Database = require('./database'); \nconst Logger = require('./logger');\n\nconst db = new Database();\nconst logger = new Logger();\n\nconst service = new Service(db, logger);\n\nservice.getUser(1);\n```\n\n\n\n주요 포인트는 다음과 같아요:\n\n- Service 클래스는 생성자를 통해 의존성을 선언합니다.\n- 호출 코드는 실제 의존성인 db와 logger를 주입합니다.\n- 이를 통해 Service와 구체적인 의존성이 결합이 해제됩니다.\n\n장점:\n\n- 모듈 간의 느슨한 결합\n- 의존성을 모의(mock)화하여 쉬운 테스트\n- 구현체 교체 가능합니다.\n\n\n\n의존성 주입 패턴은 NestJS와 같은 Node.js 프레임워크에서 일반적으로 사용됩니다. 이 패턴을 사용하면 코드 조직화와 재사용성을 더 효율적으로 할 수 있습니다.\n\n## Promise 패턴\n\nPromise는 Node.js에서 비동기 프로그래밍을 위한 패턴입니다. 이들은 비동기 작업의 최종 결과를 나타냅니다. 다음은 간단한 예제입니다:\n\n```js\nconst fetchData = new Promise((resolve, reject) => {\n  // 비동기 작업\n  const data = getDataFromDatabase();\n  \n  if (data) {\n    resolve(data); \n  } else {  \n    reject('데이터 가져오기 오류');\n  }\n});\n\nfetchData\n  .then(data => {\n    // 성공적인 데이터 처리\n  })\n  .catch(err => {\n    // 에러 처리  \n  });\n```\n\n\n\n주요 측면은 다음과 같습니다:\n\n- Promise는 resolve 및 reject 함수가 포함된 콜백을 사용합니다.\n- 비동기 작업은 콜백 내에서 시작됩니다.\n- resolve(data)는 성공 시 데이터를 반환합니다.\n- reject(error)는 실패 시 오류를 반환합니다.\n- 소비자들은 .then() 및 .catch()를 사용하여 결과를 얻습니다.\n\n장점:\n\n- 비동기 코드에서 콜백 지옥을 피할 수 있습니다.\n- 비동기 결과를 처리하는 표준화된 방법\n- Promise를 연결하고 조합할 수 있는 능력\n\n\n\n약속은 현대 Node.js 개발에 불가결하며, 깔끔한 비동기 코드 작성을 가능하게 합니다. axios와 같은 라이브러리, fs.promises와 같은 코어 API를 구동합니다.\n\n## 디자인 패턴 구현\n\nNode.js의 강점과 일치하는 주요 디자인 패턴을 탐색했으니, 효과적으로 구현하는 방법에 대해 자세히 알아봅시다:\n\n## 1. 컨텍스트 이해\n\n\n\n디자인 패턴을 적용하기 전에는 애플리케이션의 맥락을 이해하는 것이 중요합니다. 애플리케이션의 요구 사항, 확장 가능성 요구 사항 및 해결하려는 특정 문제 등을 고려해야 합니다. 디자인 패턴은 일반적인 해결책이 아니며, 프로젝트의 독특한 특성에 맞추어야 합니다.\n\n## 2. 모듈화\n\nNode.js는 모듈 시스템을 통해 모듈화를 촉진합니다. 디자인 패턴을 구현할 때에는 모듈을 작고 집중적이며 단일 책임을 부여하는 노력을 해야 합니다. 이렇게 하면 코드 재사용성과 유지보수성이 증가하며, 전체 애플리케이션에 영향을 미치지 않고 특정 기능을 교체하거나 향상시키기가 더 쉬워집니다.\n\n## 3. 비동기 패턴\n\n\n\nNode.js의 비동기적인 성격을 고려할 때, 비동기 프로그래밍 패러다임에 부합하는 디자인 패턴을 선택하는 것이 중요합니다. 옵저버 패턴과 미들웨어 패턴과 같은 패턴들은 자연스럽게 비동기 환경에 잘 맞아 이벤트 및 비동기 작업을 손쉽게 처리할 수 있게 해줍니다.\n\n## 결론\n\n디자인 패턴을 활용하면 Node.js 개발자들은 조직화되고 유연하며 견고한 코드를 작성할 수 있습니다. Factory, decorator, singleton과 같은 검증된 패턴을 활용하면 유지보수 및 확장이 쉬운 대규모 애플리케이션을 구축할 수 있습니다. 디자인 원칙을 적용하는 방법을 이해하는 것은 고급 Node 개발을 숙달하기 위한 핵심 요소입니다.","ogImage":{"url":"/assets/img/2024-05-14-DesignPatternsinNodejs_0.png"},"coverImage":"/assets/img/2024-05-14-DesignPatternsinNodejs_0.png","tag":["Tech"],"readingTime":10},{"title":"Angular 17의 새로운 기능들","description":"","date":"2024-05-14 13:55","slug":"2024-05-14-WhatsNewinAngular17","content":"\n\n## 웹 개발\n\n![Angular 17](/assets/img/2024-05-14-WhatsNewinAngular17_0.png)\n\n앵귤러 팀이 더 이상 비밀로 간직할 수 없었습니다. 그들은 2023년 11월 8일에 프레임워크의 17번 버전을 공개하기 전 유튜브에서 지난 월요일에 흥미로운 소식을 드렸습니다.\n\n이전 릴리스의 개발자 미리보기에 있던 신호와 독립 컴포넌트와 같은 기능에 추가로, 프레임워크는 시대에 발맞추기 위해 새롭게 변모했습니다. 앵귤러는 이제 새로운 사이트, 최신 문서 및 멋진 새로운 로고를 갖추었습니다! 마치 프레임워크가 새 옷장을 얻은 것 같군요.\n\n\n\n만약 Angular의 최신 릴리스에 열정적이라면, 이 게시물을 놓치고 싶지 않을 거에요. 저와 함께 Angular 게임을 업그레이드할 수 있는 방법에 대해 살펴보세요.\n\n![Angular Latest Release](/assets/img/2024-05-14-WhatsNewinAngular17_1.png)\n\n이번 새 릴리스의 흥미로운 기능 중에는 새로운 템플릿 제어 블록 구문이 있어요. 이것은 더 부드럽고 표현력이 풍부한 코딩을 의미해요!\n\n이제 이야기의 주인공인 'Deferred loading blocks'에 대해 알려드릴게요.\n\n\n\n# 지연 로딩 블록\n\nAngular 17에서는 @defer 컨트롤 블록을 사용하여 콘텐츠를 지연 로딩할 수 있습니다. 컴포넌트, 디렉티브, 파이프를 포함한 의존성에 대해서도 적용됩니다.\n\n그리고 가장 좋은 점은?\n\n지연 가능한 뷰를 통해 현재 사용자 상호작용에 필요한 뷰만 로드할 수 있습니다. 번역하자면, 더 빠른 초기로드 시간과 최적화된 경험을 얻을 수 있습니다. 누가 속도와 효율성을 좋아하지 않겠어요?\n\n\n\n```js\n@defer {\n <details-component />\n} @loading (after 100ms; minimum 1s) {\n <p> Loading… </p>\n} @error {\n  <p> Failed to load the content ☹️ </p>\n}\n```\n\n이고르 세도프는 코딩 심장을 뛰게 만들어 줄 비디오에서 예제와 사용 사례 시나리오를 제공했습니다:\n\n# 조건부 렌더링\n\n*ngIf, *ngFor 및 *ngSwitch 지시문에 작별 인사를 전하세요. 이제 더 나은 대안들이 있어서 더 쉬워졌습니다.\n\n\n\n## @switch, @case, @default\n\n@switch, @case, 그리고 @default은 제어 흐름 블록에서 멋진 친구들이에요. 다음 예시를 통해 어떻게 작동하는지 살펴보면서 동적 양식 템플릿에서 추출한 아래 예시를 리팩토링해 보겠습니다:\n\n```js\n<ng-container [ngSwitch]=\"formControl.controlType\">\n  <mat-form-field *ngSwitchCase=\"'dropdown'\">\n   ...\n  </mat-form-field>\n  <ng-container *ngSwitchCase=\"'slideToggle'\">\n    <mat-slide-toggle [formControl]=\"formGroup.get(formControl.key)\">\n     ...\n    </mat-slide-toggle>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'checkbox'\">\n    <mat-checkbox [formControl]=\"formGroup.get(formControl.key)\">\n     ...\n    </mat-checkbox>\n  </ng-container>\n</ng-container>\n```\n\n위의 코드 대신, @switch 블록에 세 개의 중첩된 블록을 사용할 거에요:\n\n\n\n- @case(`dropdown`) 블록의 내용은 formControl.controlType이 `dropdown`과 같을 때 렌더링됩니다.\n- @case(`slideToggle`) 블록의 내용은 formControl.controlType이 `slideToggle`과 같을 때 렌더링됩니다.\n- @case(`checkbox`) 블록의 내용은 formControl.controlType이 `checkbox`와 같을 때 렌더링됩니다.\n\n```js\n@switch (formControl.controlType) {\n  @case ('dropdown') {\n    <mat-form-field *ngSwitchCase=\"'dropdown'\">\n     ...\n    </mat-form-field>\n  }\n  @case ('slideToggle') {\n    <mat-slide-toggle [formControl]=\"formGroup.get(formControl.key)\">\n      ...\n    </mat-slide-toggle>\n  }\n  @case ('checkbox') {\n    <mat-checkbox [formControl]=\"formGroup.get(formControl.key)\">\n     ...\n    </mat-checkbox>\n  }\n  @default {\n    ...\n  }\n}\n```\n\n새로운 구문으로 코드를 작성하면 매우 가독성이 좋아지고 개발자 경험이 향상됩니다(DX).\n\n## @if, @else, @for, @empty\n\n\n\n@if, @else 및 @for 블록을 사용하면 항목을 조건부로 렌더링하고 컬렉션을 쉽게 처리할 수 있습니다. 이전 구문 대신:\n\n```js\n<ng-container *ngIf=\"showAllFields; else customFieldsTemplate\">\n   <ng-container *ngFor=\"let ecsField of ecsFields; trackBy: trackByFn\">\n      <div class=\"mt-2\">\n        { ecsField.name }\n      </div>\n  </ng-container>\n</ng-container>\n<ng-template #customFieldsTemplate>\n  Custom fields template.\n</ng-template>\n```\n\n다음과 같이 템플릿에 로직을 구현할 수 있습니다:\n\n```js\n@if (showAllFields) {\n  @for (ecsField of ecsFields; track: ecsField.id) {\n    <div class=\"mt-2\">\n      { ecsField.name }\n    </div>\n  }\n} @else {\n  Custom fields template.\n}\n```\n\n\n\n내장 @for 루프에는 0개의 항목을 포함하는 컬렉션을 위한 선택적인 @empty 블록을 통해 편리한 단축키가 함께 제공됩니다:\n\n```js\n@for (ecsField of ecsFields; track: ecsField.id) {\n  <div class=\"mt-2\">\n    { ecsField.name }\n  </div>\n} @empty {\n  필드 목록이 비어 있습니다.\n}\n```\n\n# 반복문을 통한 빠른 렌더 속도\n\n자, 이제 속도에 대해 이야기해봅시다.\n\n\n\n*for에서 누락된 trackBy 함수는 성능 문제를 야기하기 쉽습니다. 하지만 @for를 사용하면 이런 문제가 사라집니다.\n\n@for가 뛰어나게 만드는 점은 빠른 차이 비교 성능을 보장하기 위해 track이 필수적이라는 것입니다. 그리고 가장 좋은 점은 사용하기가 정말 쉽다는 것이죠! 이제 더 이상 컴포넌트 클래스에 메서드를 추가할 필요가 없습니다. trackBy와 달리 track은 표현식으로만 사용할 수 있습니다.\n\n이 결과는 커뮤니티 프레임워크 벤치마킹에서 최대 90%까지 빠른 런타임을 제공할 수 있다는 것입니다!\n\n# 새로운 제어 플로우 구문으로 마이그레이션하기\n\n\n\n당신의 머리 속에서 삐죽삐죽한 무언가가 돌고 있을 거라고 느껴져요. 새 문법을 사용하려면 코드를 전면적으로 리팩토링해야 한다는 생각에 말이죠.\n\n하지만 걱정 마세요! 기쁜 소식을 전해드릴게요.\n\n리팩토링에 머리 아픔을 느끼지 않아도 됩니다. @angular/core:control-flow-migration 스키마가 모두 대신 처리해 드릴 거예요. 터미널을 열어서 다음 명령어를 실행해보세요:\n\n```js\nng g @angular/core:control-flow-migration\n```\n\n\n\n# 렌더링을 위한 새로운 라이프사이클 후크\n\n앵귤러의 서버 측 렌더링 (SSR) 및 정적 사이트 생성 (SSG) 성능을 더욱 원활하게 하기 위해, 앵귤러 팀은 DOM 흉내와 직접적인 DOM 조작에서 이별을 준비 중입니다.\n\n이를 위해 프레임워크는 이제 afterRender 및 afterNextRender 라이프사이클 후크를 제공합니다:\n\n- afterRender 후크는 렌더링이 완료된 후에 콜백을 트리거하기 위해 동작합니다.\n- afterNextRender 후크는 다음 렌더링이 끝난 후에 트리거될 콜백을 등록합니다.\n\n\n\n# SSR 기능 기본 제공\n\nAngular의 옛날을 떠올려보면 SSR을 활성화하는 것은 모험을 떠나는 것과 같은 느낌이었습니다. 별도의 패키지(Angular Universal)와 중복된 빌드 프로세스를 다루고 angular.json에서 구성을 해석해야 했죠. 정말 머리 아파지죠.\n\n하지만 새로운 시대가 열렸어요!\n\n최신 애플리케이션 빌더는 간단함과 통일성에 초점을 맞추고 있습니다. Angular 앱을 위한 올인원 빌더를 제공해줘요. 앱 쉘, 브라우저, 서버 등을 모두 원활하게 통합시켜줍니다.\n\n\n\n새 프로젝트를 시작할 때, 다음 명령어를 실행하여 SSR 마법을 뿌려보세요:\n\n```js\nng new --ssr\n```\n\nCLI는 심지어 SSR을 활성화할지 묻기 위해 명령 프롬프트에서 확인을 요청할 거에요.\n\n그리고 SSR을 나중에 선택하려면 걱정하지 마세요! 그냥 아래와 같이 입력해주세요:\n\n\n\n\nnpm install @angular/ssr --save\n\n\n그럼요! 이제 Angular 앱이 SSR에 준비됐어요.\n\n# 수분공급\n\n수분공급은 서버에서 렌더된 애플리케이션을 클라이언트 측에서 다시 살려내는 마법 같은 행위에요.\n\n\n\n\n서버 렌더링된 DOM 구조를 재사용하고 애플리케이션 상태를 유지하며 서버에서 이미 가져온 애플리케이션 데이터를 전송하며 기타 영웅적인 역할을 수행합니다.\n\n그리고 놀랍게도!\n\nSSR을 선택하면 기본적으로 하이드레이션을 사용합니다. 이 기술에 대해 더 깊이 이해하려면 하이드레이션 가이드를 확인하세요.\n\n# ESBuild 및 Vite 기본 지원\n\n\n\n자, 이제 엔진 덮개 아래를 살펴보겠습니다: Angular CLI의 빌드 파이프라인.\n\nAngular는 CLI에서 ng build, ng serve 및 ng test와 같은 명령에 사용되는 빌더를 제공합니다. 이러한 내장 CLI 빌더 및 기타 빌더의 기본 대상 구성은 워크스페이스 구성 파일 angular.json의 architect 섹션에 사용 가능합니다:\n\n![이미지](/assets/img/2024-05-14-WhatsNewinAngular17_2.png)\n\n빌드 파이프라인에서 중요한 변경 사항은 모든 새 애플리케이션에 대해 esbuild 플러스 Vite가 기본적으로 활성화되었다는 사실입니다.\n\n\n\nAngular 16에 개발자 미리보기로 도입된 Esbuild 및 Vite 기반 빌드 경험이 소개되었어요. 피드백 결과 몇 가지 경우 빌드 시간이 67% 향상되었다고 해요.\n\n![2024-05-14-WhatsNewinAngular17_3.png](/assets/img/2024-05-14-WhatsNewinAngular17_3.png)\n\nSSR 및 SSG를 사용하는 경우, ng build의 속도가 최대 87% 향상되고 ng serve의 편집-새로고침 루프도 80% 빨라져요.\n\n# 마지막으로\n\n\n\nAngular 버전 17은 우리가 기대하던 멋진 새로운 기능을 가져오는 것뿐만 아니라 버그 수정과 성능 향상도 포함되어 있어요.\n\n더 자세한 내용이 궁금하다면, 백스테이지 패스는 GitHub에 있어요. 그리고 Angular의 미래를 예상해보고 싶다면, 로드맵을 확인해보세요.\n\n즐거움을 놓치지 마세요! 터미널로 이동해서 `ng upgrade` 명령어로 마법을 일으켜보세요.\n\n# 더 알고 싶다면?\n\n\n\n제가 똑똑하고 호기심 많은 사람들을 위해 엔지니어링, 기술 및 리더십에 관한 글을 쓰고 있어요 🧠💡. 독점 액세스를 원하시면 무료 이메일 뉴스레터에 가입해주세요.\n\n27,000여 명의 학생들과 함께 온라인 비디오 코스인 Web Performance 101: 웹 앱 성능 향상 방법을 받아보세요.","ogImage":{"url":"/assets/img/2024-05-14-WhatsNewinAngular17_0.png"},"coverImage":"/assets/img/2024-05-14-WhatsNewinAngular17_0.png","tag":["Tech"],"readingTime":7},{"title":"좋은 커밋 대 나의 커밋 완벽한 Git 커밋 메시지 작성법","description":"","date":"2024-05-14 13:53","slug":"2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage","content":"\n\n수 년 전, 궁금증 때문에 커밋 메시지 작성에 대한 구체적인 규칙이 있다는 것을 알지 못했어요. 예전엔 \"기능 2 추가\", \"메인 네비게이션 바 버그 수정\", 혹은 \"foo\"와 같이 간단한 메시지가 충분하다고 생각했어요. 하지만 커밋 메시지가 대부분 무시당한다고 생각했던 것은 잘못된 생각이었어요. 실제로, 신중하고 세심하게 작성된 커밋 메시지는 우리 미래의 자신이 우리의 성실함과 세심함에서 이익을 얻게끔 해주는 필수적인 역할을 합니다.\n\n목차: 왜 깨끗한 커밋 메시지 작성에 신경을 써야 할까? | 흔한 실수들 | 7가지 규칙 | 사례 연구 | 팁.\n\n# 왜 깨끗한 커밋 메시지 작성이 중요할까요?\n\n\n\n커밋은 프로그래머의 기술의 구체적인 구성 요소로 작용합니다. 코드의 완성을 나타내며, 올바르게 작성되면 상당한 가치를 제공합니다. 잘 쓰여진 커밋 메시지는 필수불가결합니다. 왜냐하면 컨텍스트를 제공하기 때문입니다. 그렇지 않으면 커밋 메시지는 처음부터 필요하지 않을 것입니다.\n\n개발자들 사이의 일반적인 실수 중 하나는 Git 저장소를 백업 시스템으로 취급하는 것입니다. 현재 코드 상태를 캡처하기 위해 무작위로 커밋하는 것은 미래에 코드베이스를 확인할 때 과거 변경 사항을 이해하는 능력을 방해할 수 있습니다. \"WIP\", \"Off for lunch\", \"End of code for today\", \"I am tired AF\", \"Happy Weekend Team\", \"First to commit\"과 같은 커밋 메시지는 추가적인 가치가 전혀 없기 때문에 Git 로그를 혼란스럽게 만들며, 본질적인 커밋 내용을 파악하기 어렵게 만들 수 있습니다.\n\n# 원격 저장소에 커밋할 때 피해야 할 몇 가지 주요 실수가 여기 있습니다.\n\n## 서로 다른 파일에 대한 변경 사항을 분리하여 커밋하지 마세요.\n\n\n\n다른 팀원들과 협업하거나 커밋 기록을 검토할 때 각 파일을 따로 커밋하는 것은 문제를 야기할 수 있습니다. 변경 사항의 전체 맥락을 이해하고 서로 간의 관계를 파악하는 데 어려움을 겪을 수 있어요.\n\n예를 들어, 온라인 상점을 만들고 있다고 가정해봅시다. 아래와 같이 하면 안 되죠:\n\n```js\n# header.js에 대한 변경 사항을 따로 커밋\ngit add header.js\ngit commit -m \"헤더 레이아웃 개선\"\n\n# footer.js에 대한 변경 사항을 따로 커밋\ngit add footer.js\ngit commit -m \"푸터 디자인 최적화\"\n```\n\n커밋 구조가 이러한 형태인 경우, 커밋 기록이 증가함에 따라 일관되지 못할 수 있어요.\n\n\n\n커밋은 명확하고 간결하며 논리적인 단위로 구성되어야 합니다. 예를 들어, 코드 레이아웃 섹션을 완료한 후 헤더와 푸터 섹션을 작업한 경우, 이러한 변경 사항을 커밋하기 전에 변경 사항들을 결합하는 것이 깔끔합니다:\n\n```js\n# header.js 및 footer.js의 Staging 변경 사항\ngit add header.js footer.js\n\n# 관련 변경 사항 함께 커밋\ngit commit -m \"UI 개선: 헤더 및 푸터 개선\"\n```\n\n이론적으로는 쉽게 들릴 수 있지만 실천하기는 쉽지 않을 수 있습니다. 그래서 변경 사항들을 메인 브랜치로 통합하기 전에 개인 브랜치를 유지하여 합병하기 전에 변경 사항을 커밋하는 것이 좋은 실천법입니다.\n\n## 개인 커밋용 전용 브랜치 만들기\n\n\n\n코드를 커밋한다고 해서 꼭 당신의 git 로그의 끝없는 영역에 영원히 남아 있어야 하는 것은 아닙니다. 개인 브랜치를 당신의 개인 프로그래머 스케치패드로 생각해보세요. 여기서는 다른 사람이 당신의 작업을 세심하게 조사할 필요 없이 자유롭게 실험할 수 있습니다.\n\n상황을 상상해보세요: 코딩 중이지만 잠시 쉬어야 하는 때가 오거나 저녁식사를 앞두고 있을 때. 현재 진행 중인 작업을 잃을까봐 두려워서 변경 사항을 커밋하기로 했습니다. 이런 경우에는 개인 브랜치가 완벽하게 활용될 수 있는 상황입니다. 당신의 코딩 세션을 마무리하거나 갑작스럽게 커밋을 하고 싶은 날에도 이러한 변경 사항은 개인 브랜치에 보관됩니다.\n\n```js\ncommit [커밋 해시]\nAuthor: Your Name <your.email@example.com>\nDate:   [타임스탬프]\n    작업 중\n\ncommit [커밋 해시]\nAuthor: Your Name <your.email@example.com>\nDate:   [타임스탬프]\n\n    파일을 최종적으로 잃기 전에 커밋합니다.\n\ncommit [커밋 해시]\nAuthor: Your Name <your.email@example.com>\nDate:   [타임스탬프]\n\n    저녁식사 준비 중\n\ncommit [커밋 해시]\nAuthor: Your Name <your.email@example.com>\nDate:   [타임스탬프]\n\n    화장실 가는 시간!\n```\n\n협업 환경에서는 개인 브랜치의 명칭을 명확하게 지어야 합니다. 이러한 종류의 커밋 메시지는 퍼블릭 브랜치에 나타나서는 안 되기 때문입니다.\n\n\n\n명시적인 브랜치 네이밍이나 동료들과 직접 의사 소통을 통해, 현재 브랜치의 내용이 지속적인 작업의 기반으로 사용되지 않음을 분명히 해주세요. 개인 브랜치에 적합한 좋은 네이밍은 `private/do-not-use-this` 같은 것입니다.\n\n당신의 퍼블릭 브랜치에 포함되는 모든 커밋은 잘 다듬어진, 독립적인, 되돌릴 수 있고 명확히 설명된 작업 단위여야 합니다.\n\n# 사례 연구: 온라인 스토어의 장바구니 기능 개발\n\n지금까지 진행해온 온라인 스토어 프로젝트를 살펴보겠습니다. 이 문맥에서, 여러분은 스토어에 장바구니 기능을 추가하는 것을 책임지는 프론트엔드 개발자로 활동하게 됩니다. 여러분의 여정은 다음과 같이 펼쳐집니다:\n\n\n\n이제 Git 로그를 살펴보겠습니다:\n\n```js\ncommit [commit-hash-1]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    장바구니 섹션의 CSS 디자인 향상\n\ncommit [commit-hash-2]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    장바구니에 Javascript 기능 추가\n\ncommit [commit-hash-3]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    텍스트 정렬 문제 해결을 위한 CSS 수정\n\ncommit [commit-hash-4]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    장바구니 동작과 관련된 카운터 버그 수정\n\ncommit [commit-hash-5]\nAuthor: Your Name <your.email@example.com>\nDate: [Timestamp]\n\n    결제 버튼에 로딩 애니메이션 통합\n```\n\n이러한 변경 사항이 온라인 상점과 관련된 다른 커밋들과 함께 주요 기능 브랜치에 통합되어야 한다면, 리뷰 프로세스가 어려워질 수 있습니다.\n\n## 이런 커밋 로그들을 수정하는 방법은 다음과 같습니다\n\n\n\n우선 기능 브랜치로 전환해주세요:\n\n```js\n# feature/cart-section이라는 기능 브랜치로 전환\ngit checkout feature/cart-section\n```\n\n그런 다음 private/do-not-use-this 브랜치에서 모든 커밋을 하나의 커밋 메시지로 feature/cart-section에 통합해주세요:\n\n```js\n# private 브랜치의 모든 커밋을 하나의 커밋으로 feature 브랜치에 병합 및 통합\ngit merge --squash private/do-not-use-this\n```\n\n\n\n병합 및 squash 작업을 완료한 후에는 명확하고 설명적인 커밋 메시지를 작성해야 합니다:\n\n```js\n# 자세한 커밋 메시지를 작성하세요\ngit commit -v -m \"Feat: 멋진 애니메이션으로 장바구니 기능 만들기\n\n장바구니 섹션의 CSS 레이아웃을 개선하여 텍스트 정렬 문제를 해결하고 레이아웃을 재미있게 향상하여 가독성을 높였습니다.\"\n\"\n```\n\n# 완벽한 커밋 메시지 작성을 위한 7가지 표준 규칙\n\n이 규칙은 커밋 메시지가 올바르게 서식이 지정되고 명확한 정보를 전달하도록 보장하기 위한 지침과 모범 사례를 제공합니다. 특정 규칙은 다른 소스에 따라 다를 수 있지만, 일반적인 목표는 Git 버전 관리 시스템 내에서 커밋 메시지의 가독성과 이해를 높이는 것입니다.\n\n\n\n## 규칙 1: 제목은 50자로 제한하세요.\n\n커밋 메시지의 제목을 작성할 때는 간결하고 목적을 집중시키는 것이 좋습니다. 제목은 커밋의 목적을 간단히 요약한 것으로, 이상적으로 50자를 넘지 않도록 하는 것이 좋습니다.\n\n50자로 제한하는 것이 힘들다면, 커밋의 의도에 대한 명확성이 부족할 수 있습니다. 커밋 메시지는 명확하고 간결하며 독립적으로 설명할 수 있어야 합니다. 이 글자 수 제한을 준수함으로써, 가장 중요한 정보에 우선순위를 두어 팀원들과 미래의 본인이 변경 내용의 본질을 한눈에 파악하기 쉽게 할 수 있습니다.\n\n## 규칙 2: 제목의 첫 글자만 대문자로 쓰세요.\n\n\n\n커밋 메시지를 작성할 때 제목 라인의 첫 글자를 대문자로 쓰면 됩니다. 이는 간결한 문장을 쓰는 것과 마찬가지로 타이틀 케이스를 사용하는 것입니다. 추가로 메시지의 나머지 부분은 소문자로 작성해주세요.\n\n## Rule 3: 제목 라인 끝에 온점을 찍지 말아주세요\n\n제목 라인을 온점으로 끝내지 않는 이유는 부분적으로는 역사적이며 일부는 일관된 스타일을 유지하기 위함입니다. 제목 라인을 명령문이나 명령처럼 취급하여 작성하는 관례에 따라 마침표를 생략합니다. 이를 통해 이 관례를 강화하고 제목 라인을 간결하게 유지할 수 있습니다.\n\n```js\ngit commit -v -m \"Create the Cart Feature with a Nice Animation\"\n```\n\n\n\n## 규칙 4: 제목과 본문 사이에 빈 줄을 넣으세요\n\n이 가이드라인은 조금 이상하게 보일지 모르지만, 실용성에 근간을 두고 있습니다. 많은 개발자들이 Git을 위한 명령줄 인터페이스를 사용하는데, 이들은 자동 줄 바꿈을 지원하지 않는 경우가 많습니다. 그래서 의도적인 형식 규칙이 도입되었으며 일관적이고 가독성 있는 커밋 메시지를 보장합니다.\n\n```js\ngit commit -v -m \"친절한 애니메이션을 가진 카트 기능 만들기\n\n본문...\n\"\n```\n\n## 규칙 5: 커밋 본문의 줄을 72자로 래핑하세요\n\n\n\n줄 바꿈 규칙은 전통적인 단어 줄 바꿈을 의미하는 것이 아니라, 명령줄 사용자가 72자를 초과하는 커밋 본문을 겪을 수 있다는 고려에서 비롯된 것임을 명확히 하는 것이 중요합니다.\n\n대부분의 경우, 메시지는 72자를 초과할 것입니다. 이러한 경우에는 아래의 커밋 메시지에서 보여주는 바와 같이 텍스트를 줄 바꿈하고 다음 줄에서 문장을 계속하는 것이 좋습니다:\n\n```js\ngit commit -v -m \"Create the Cart Feature with a Nice Animation\n\nEnhanced the CSS layout of the cart section, addressing text\nalignment issues and refining the layout for improved aesthetics\nand readability.\"\n```\n\n요약하자면, 점 목록을 표시하는 표준 방법은 하이픈이나 별표 뒤에 공백 하나를 두고 사용하는 것입니다. 더불어 조직적 가독성을 높이기 위해 들여쓰기를 유지하는 것이 중요합니다.\n\n\n\n## 규칙 6: 명령형 문법 사용하기\n\n가치 있는 실천 방법 중 하나는 커밋 메시지를 작성할 때 해당 커밋이 구현되면 정확한 작업을 수행할 것이라는 기본적인 이해를 갖는 것입니다. 커밋 메시지를 작성할 때 ‘만일 적용된다면, 이 커밋은…’이라는 문장을 논리적으로 완성하는 방식으로 만드세요. 예를 들어, `git commit -m \"Fixed the bug on the layout page\"` ❌ 대신에 `git commit -m \"Fix the bug on the layout page\"` ✔ 를 사용하세요.\n\n다시 말해, 만일 이 커밋이 적용된다면, 실제로 레이아웃 페이지에서 버그가 해결될 것입니다.\n\n## 규칙 7: “무엇\"과 “왜\"를 설명하되, “어떻게\"에 대해서는 제외하세요.\n\n\n\n커밋 메시지를 “무엇\"과 “왜\"로 제한하면 각 변경 사항에 대해 간결하면서도 정보를 제공하는 설명이 생성됩니다. 코드가 어떻게 구현되었는지 알고 싶은 개발자는 직접 코드베이스를 참조할 수 있습니다. 대신, 변경된 내용과 변경의 이유, 영향을 받은 구성 요소나 영역을 강조해주세요.\n\n## 사례 연구: Angular의 커밋 메시지 관행\n\nAngular는 효과적인 커밋 메시지 관행의 저변적인 예로 자리 잡고 있습니다. Angular 팀은 커밋 메시지를 작성할 때 특정 접두사의 사용을 지지합니다. 이러한 접두사에는 “chore: ,\" “docs: ,\" “style: ,\" “feat: ,\" “fix: ,\" “refactor: ,\" 그리고 “test: .\"가 포함됩니다. 이러한 접두사를 통합함으로써 커밋 이력은 각 커밋의 성격을 이해하는 데 유용한 자원이 됩니다.\n\n# 팁\n\n\n\n커밋 메시지를 통해 명확하고 의미 있는 커뮤니케이션을 우선시하는 것을 기억해 주세요. 정성스럽게 작성된 커밋 메시지는 ‘무엇을,’ ‘왜’에 대한 설명을 담고 있어야 합니다. 하지만 ‘어떻게’까지는 너무 자세히 설명하지 않아도 됩니다. 커밋 기록은 미래의 여러분과 팀원들이 의지할 중요한 자원이 되므로, 정보를 제공하고 간결하며 일관된 내용으로 커밋 메시지를 작성하는 습관을 들어보세요.\n\nGit을 깊게 이해하고 숙련된 \"버전 컨트롤러\"로 성장하고 싶다면, 이 훌륭한 자료들을 살펴보세요:","ogImage":{"url":"/assets/img/2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage_0.png"},"coverImage":"/assets/img/2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage_0.png","tag":["Tech"],"readingTime":7},{"title":"클라이언트 측 JavaScript를 사용하여 문자열을 버퍼 및 데이터 URL 형식으로 변환하는 방법","description":"","date":"2024-05-14 13:52","slug":"2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript","content":"\n\n웹 애플리케이션에서는 Base64가 종종 사용됩니다. 바이너리 데이터를 ASCII 텍스트 형식으로 저장하거나 전송하기 위해 인코딩하는 데 쓰입니다. 예를 들어, 파일 전송 API는 효율적인 저장 및 처리 속도로 인해 이진 데이터로 반환된 응답을 받는 경우가 많습니다.\n\n![image](/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png)\n\n# NodeJS의 버퍼 클래스\n\nNodeJS에 독점적인 전역 API 중 하나인 버퍼 클래스는 보내거나 받는 이진 데이터를 처리하는 편리한 수단으로 사용됩니다. 예를 들어, 다음 코드 스니펫은 NodeJS의 버퍼 모듈을 사용하여 문자열을 ArrayBuffer로 변환하거나 그 반대로 변환하는 방법을 보여줍니다:\n\n\n\n```js\nconst str = 'Hey. this is a string!';\n\nconst buffer = Buffer.from(str, 'utf-8'); // 형식: ArrayBuffer\nconst b64Str = Buffer.from(str, 'utf-8').toString('base64');\nconsole.log(b64Str);\n/* 예상 결과: */\n// SGV5LiB0aGlzIGlzIGEgc3RyaW5nIQ==\n\nconst originalStr = Buffer.from(b64Str, 'base64').toString('utf-8');\nconsole.log(originalStr);\n/* 예상 결과: */\n// Hey. this is a string!\n```\n\n## 클라이언트 측 브라우저 환경\n\n- btoa()는 Base64로 인코딩된 문자열을 읽고 출력합니다.\n- atob()은 Base64 문자열의 디코딩에 사용됩니다.\n\nNodeJS의 Buffer 모듈은 기본적으로 UTF-8 인코딩 체계를 사용하는 반면, btoa()와 atob()은 유니코드 텍스트와 같은 비 ASCII 문자를 해석할 수 없어 에러를 발생시킵니다.\n\n\n\n```js\ntry {\n  btoa('ヾξ⸨🎀˶❛ヮ❛⸩ﾉ ᵀᴴᴱ ᴿᴵᴮᴮᴼᴺ ᴳᴵᴿᴸ'); // 유니코드 문자만\n} catch(err) {\n  console.error(err);\n}\n// 콘솔 출력:\n/* InvalidCharacterError: Failed to execute 'btoa' on 'Window': The */\n/* string to be encoded contains characters outside of the Latin1 range. */\n```\n\n그러므로 데이터를 이진 데이터 형식으로 변환하는 경우 — 즉, Data URL 및 ArrayBuffer로 변환하기 위해 사전에 UTF-8로 문자열을 바이트 시퀀스로 변환한 후 이 바이트 시퀀스를 Base64 문자열로 인코딩해야 합니다.\n\n# 구현 세부 사항\n\n여기 클라이언트 측 JavaScript를 사용하여 \"유니코드 문제\"를 해결하기 위한 2가지 가능한 방법이 있습니다. 양 구현 모두 아래의 헬퍼 함수 convertBitArrtoB64 및 convertB64ToBitArr가 포함되어야 한다는 점을 유의하십시오:\n\n\n\n```js\n// Uint8Array를 Base64 문자열로 변환하는 함수\nconst convertBitArrtoB64 = (bitArr) => ( btoa( bitArr.reduce((data, byte) => data + String.fromCharCode(byte), '') ) );\n\n// Base64 문자열을 Uint8Array로 변환하는 함수\nconst convertB64ToBitArr = (b64Str) => ( Uint8Array.from(atob( (b64Str.includes(';base64,') ? (b64Str.split(','))[1] : b64Str) ), (v) => v.charCodeAt(0)) );\n```\n\n## (1) TextEncoder & TextDecoder\n\nUTF-8 문자열 인코딩은 네이티브 브라우저에서 TextEncoder 인터페이스(반대 방향으로는 TextDecoder)로 처리할 수 있습니다:\n\n- 문자열을 ArrayBuffer 및 Base64로 인코딩된 데이터 URL로 변환하기\n\n\n\n\n```js\nconst inputStr = '히카리 미나미';\n\n// 문자열을 Uint8Array로 출력하는 인자를 사용하는 함수\nconst bitArr = (utf8Str) => (new TextEncoder().encode(utf8Str));\n\nconst uInt8Arr = bitArr(inputStr);\nconsole.log(uInt8Arr);\n// 예상 결과:\n// 236,150,136,237,132,132,235,170,164,237,157,144,32,236,130,183,235,143,138\n\nconst buffer = uInt8Arr.buffer; \nconsole.log(buffer); \n// 예상 결과:\n// 바이트 길이가 21인 ArrayBuffer 출력\n\nconst b64Str = convertBitArrtoB64( bitArr(inputStr) );\nconsole.log(b64Str);\n// 예상 결과:\n// 7ZWw7ISw7Iqk7YOJIDA=\n```\n\n- 원래 입력된 텍스트로의 역 변환\n\n```js\n// Uint8Array를 사용하는 인자를 문자열로 출력하는 함수\nconst utf8Str = (bitArr) => (new TextDecoder().decode(bitArr.buffer));\n\nconst originalStr = utf8Str(convertB64ToBitArr(b64Str));\nconsole.log(originalStr);\n// 예상 결과:\n// 히카리 미나미\n```\n\n## (2) unescape + encodeURIComponent 및 decodeURIComponent + escape\n\n\n\n\n그러나 대안으로 UTF-8 인코더를 구현하는 JavaScript를 사용할 수도 있습니다. 이를 위해 브라우저 글로벌 객체인 unescape + encodeURIComponent (그리고 반대 방향으로는 decodeURIComponent + escape)를 사용할 수 있습니다:\n\n- 문자열을 ArrayBuffer와 Base64로 인코딩된 데이터 URL로 변환\n\n```js\nconst inputStr = 'ヾξ⸨🎀˶❛ヮ❛⸩ﾉ ᵀᴴᴱ ᴿᴵᴮᴮᴼᴺ ᴳᴵᴿᴸ';\n\n// 문자열을 받아 Base64 문자열을 출력하는 함수\nconst utf8_to_b64 = (str) => (btoa(unescape(encodeURIComponent(str))));\n\nconst b64Str = utf8_to_b64(inputStr);\nconsole.log(b64Str);\n// 예상 결과:\n// 44O+zr7iuKjwn46Ay7binZvjg67inZviuKnvvokg4bWA4bS04bSxIOG0v+G0teG0ruG0ruG0vOG0uiDhtLPhtLXhtL/htLg=\n\nconst uInt8Arr = convertB64ToBitArr(utf8_to_b64(inputStr));\nconsole.log(uInt8Arr);\n// 예상 결과:\n// 227,131,190,206,190,226,184,168,240,159,142,128,203,182,226,157,155,227,131,174,226,157,155,226,184,169,239,190,137,32,225,181,128,225,180,180,225,180,177,32,225,180,191,225,180,181,225,180,174,225,180,174,225,180,188,225,180,186,32,225,180,179,225,180,181,225,180,191,225,180,184\n\nconst buffer = uInt8Arr.buffer; \nconsole.log(buffer); \n// 예상 결과:\n// 71바이트 길이의 ArrayBuffer를 출력함\n```\n\n- 원래 입력 텍스트로의 역변환\n\n\n\n```js\n// Base64로 인코딩된 데이터 URL을 받아 String을 출력하는 함수입니다.\nconst b64_to_utf8 = (str) => (decodeURIComponent(escape(atob(str)));\n\nconst originalStr = b64_to_utf8(b64Str);\n// 예상 결과:\n// ヾξ⸨🎀˶❛ヮ❛⸩ﾉ ᵀᴴᴱ ᴿᴵᴮᴮᴼᴺ ᴳᴵᴿᴸ\n```\n\n# 실시간 데모\n\n## ASCII 문자만 사용\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*FHtRkS1iUjaSCPGv6Pz0-A.gif\" />\n\n\n\n\n## 유니코드 문자만\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*kwj-q8KMkj_nQcqWhliUBw.gif)\n\nconvert-to-buffer에서 직접 시도해보세요!\n\n여기까지 읽어주셔서 정말 감사합니다! ❤ 이 구현이 유용했기를 바라며, 더 많은 GIS, 데이터 분석 및 웹 응용 프로그램 관련 콘텐츠를 원하시면 Medium에서 제 팔로우를 해주세요. 정말로 감사하겠습니다 — 😀\n\n\n\n— 🌮 타코 한 개 사주세요 ξ(🎀˶❛◡❛)\n\n## 다른 웹 관련 콘텐츨 후보:\n\n# PlainEnglish.io 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 저자에 대한 박수 및 팔로우 부탁드려요️\n- In Plain English에 글을 쓸 수 있는 방법을 배워보세요️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture","ogImage":{"url":"/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png","tag":["Tech"],"readingTime":5},{"title":"믿거나 말거나, 우리에게 또 다른 할 일 앱이 필요합니다","description":"","date":"2024-05-14 13:50","slug":"2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp","content":"\n\n## 네, 이미 수백만 개 이상 구현된 것이 있음에도 불구하고...\n\n그 중에 하나가 있어요:\n\n- 찾을 수가 없어요.\n- 정말 필요해요.\n\n그래서, 제가 직접 만들기로 결정했어요. 생산성 앱으로 넘쳐나는 세상에서 새 할일 목록을 소개하는 아이디어는 중복되었거나 아주 불필요한 것처럼 보일 수 있어요. 이미 잘 밟힌 길을 왜 가야 할까요?\n\n\n\n그럼에도 불구하고, 내 목표는 초보 개발자의 작은 프로젝트에 흔히 볼 수 있는 애플리케이션 개념의 성공을 단순히 희망하는 데 그치지 않습니다. 저는 실제로 더 집중할 만한 몇 가지 사안이 있는데, 이에 대해 뒤에 자세히 논의할 것입니다. 이 애플리케이션의 아이디어에서부터 시작해보죠. 인기 있는 책에서 영감을 받았습니다.\n\n# 할 일 목록이란?\n\n팀 페리스(Tim Ferriss)의 책 '4시간 근무주'에 대해 들어봤을지도 모릅니다. 개인적으로 매우 유용하다고 생각하며 유용한 팁과 기교가 많이 있습니다. 그 중 하나를 사용해 보고 굉장히 강력한 도구라고 판단했습니다. 간단히 설명하자면, 그것은 플래너입니다. 하지만 처음에 상상할 것과 다른 플래너입니다. 오히려 그것을 도구라고 하거나, 단지 삶을 현재의 상태에서 기대되는 상태로 바꾸기 위한 프레임워크라고 할 것입니다. 일반적으로 그것이 플래너의 목표겠죠? 그렇다고 볼 수도 있겠지만, 저는 이것이 제가 알고 있는 다른 것보다 훨씬 잘 작동한다고 생각합니다. 한 번 해봤고 결과에 만족했습니다. 그래서 다시 해보고 싶습니다. 이번에는 종이가 아닌 앱을 사용하려고 합니다. 계획의 디지털 버전을 사용하면 다양한 일을 할 수 있습니다... 적어도 언제든지 출력하여 종이 버전을 얻을 수 있습니다! 농담은 놓고 — 정확히 어떻게 보일지와 어떤 기능이 최종적으로 포함될지 아직 모르겠지만, 디지턼 버전으로부터 혜택을 얻을 수 있는 여러 방법이 있는데요:\n\n- 접근성과 휴대성: 디지털 정보도 분실될 수 있습니다. 다만, 전반적으로 디지털 자산을 보관하는 것이 훨씬 쉽습니다.\n- 동기화와 백업: 처음 버전에는 포함되지 않을 것인데 필요할 때 실행할 수 있는 기회가 있습니다.\n- 업데이트와 편집: 거의 깜빡했네요! 종이에서는 어떻게 편집하시나요?\n- 데이터 분석과 통찰: 이것은 명백히 애플리케이션의 일부여야 합니다. 최소한 진행 상황의 시각화가 필수적인 것으로 보입니다.\n- 멀티미디어 통합: 진부해 보일지 모르지만 중요하지 않다는 뜻은 아닙니다. 종이 버전에 외부 자원에 대한 링크를 추가할 수는 없겠지요.\n\n\n\n## 그리고 훨씬 많은 것이 있어요! 사실 세계에 직접적으로 속하지 않아요 — 우리의 상상력으로 제한돼요.\n\n## 계획자.\n\n알았어요, 그러니까 우리가 어플리케이션이 가치를 가져다준다고 합의했으니, 이 책에서 계획자가 어떻게 정의되었는지 살펴보고 그 요소들을 세분화해보겠습니다.\n\n![이미지](/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png)\n\n\n\n제가 두 가지 주요 부분으로 나누어서 설명해 드릴게요. 먼저 목표를 정의하는 단계와 관련된 7단계를 포함한 부분이고 두 번째로는 그 목표를 이루기 위해 필요한 작업 목록을 설정하는 부분입니다.\n\n기본적으로 먼저, 원하는 것, 되고 싶은 사람, 하고 싶은 일을 정의한 뒤, 그것을 이루기 위한 시간이나 돈을 투자하는 비용을 확인해야 해요:\n\n![이미지](/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_1.png)\n\n두 번째로, 이루어져야 하는 구체적인 작업 목록이에요:\n\n\n\n<img src=\"/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_2.png\" />\n\n실생활 예시로 가볍게 한 번 생각해보자. 나만의 자동차로 전국을 여행하는 꿈이 있다고 상상해봐. 그런데 당장은 운전 면허나 자동차 둘 다 없군. 정말 큰 프로젝트 같지만 그래도 6개월 안에 완성할 수 있는 것이야.\n이번에 우리가 할 일을 표로 나눠서 좀 더 구체화해보자.\n\n## 단계 1: 소유\n\n당연하게도, 자동차와 운전 면허가 필요하겠지? 이 두 가지를 목록에 추가해보자:\n- 자동차\n- 운전 면허\n\n\n\n## 단계 5: 비용\n\n앗, 단계 번호가 혼란스러울 수 있어요. 방금 전에는 1단계에 있었는데, 이제는 5단계에요. 아마도 우리 애플리케이션에서는 이제 이런 단계들의 번호를 숫자 색인으로 사용하지 않을 거예요.\n\n그래서, 제가 전문가는 아니지만 이 차가 당신에게 처음으로 소개되는 차일 거예요. 그렇기 때문에 너무 걱정할 필요는 없지만 너무 오래된 차도 아니어야 해요. 10~15년 된 일본 제조 차량이 좋은 후보라고 생각해요. 상태가 괜찮은 차를 구입하기 위해 약 10,000 달러를 준비해야 할 거예요.\n또한 운전 면허를 취득하는 데 일부 비용이 들어요. 당신이 사는 나라에 따라 비용이 다르겠지만, 여기서는 평균적으로 약 500달러를 사용해볼게요.\n\n그럼 이 두 가지를 추가해볼게요:\n- 오래되지 않은 차: 10,000 달러\n- 운전 면허: 500 달러\n\n\n\n월 1,750달러를 모아야 한다는 것은 꽤 많은 금액입니다. 그러나 특정한 경우에는 이미 약간의 저축이 있을 수도 있고, 더 싼 차를 사기 위해 노력하고 있을 수도 있습니다.\n\n## 지금 취해야 할 단계\n\n글을 쓰고 나서 곧바로 할 수 있는 일들입니다. 다음 주 월요일이나 아침까지 기다릴 필요는 없습니다. 지금 바로 시작하세요.\n예를 들어:\n— 운전 규칙 배우기\n— 자산 계산하기\n— 저축 계획 수립하기\n— 줄일 수 있는 지출 결정하기\n\n## 내일\n\n\n\n\"내일\"을 정확히 의미하지는 않습니다. 대신 이것은 막힘이 있는 작업이며 다른 일을 완료하거나 일어난 후에만 할 수 있습니다. 이전 목록의 작업이 완료되기를 기다릴 수도 있습니다:\n\n- 운전 이론 시험 통과\n- 운전 교육사 찾기\n- 저축 계획을 평가하고 필요하다면 조정하기\n\n## 이후\n\n다시 말해, \"내일\"을 문자 그대로 받아들여서는 안 된다고 생각합니다. 이것은 직접적으로 당신의 주요 목표로 이어지는 마지막 작업이며 이전 목록을 해결함으로써 막힘이 해제됩니다:\n\n- 운전 시험을 통과하고 면허증을 받기\n- 지역 중고차 시장 분석\n- 저축 계좌에서 돈 인출\n- 중고차 판매자와 몇 가지 약속하기\n- 자동차 구매\n- 여행을 떠나세요!\n\n\n\n그거거든요, 거의 다 됐어요. 지금까지 받은 것으로 이미 유용한 계획을 가지고 있지만, 우리가 아직 STEP 2: BEING과 STEP 3: DOING에 손을 대지 않았어요. 작가나 음악가가 되고 싶을 수도 있고, 직업을 바꾸고 싶을 수도 있어요. 체육관에 가거나 마라톤을 뛰기 시작해도 좋아요. 무엇이든 좋아요—써 내려보고, 그것을 이룰 방법을 생각하고 계획을 세워보세요.\n\n이것은 일반적인 꿈과 아이디어를 구체적인 것들로 분해하고 그것들을 이루기 위한 계획을 세우는 강력한 도구에요. 그리고 한번 이걸 마치면 두 가지 중요한 지점으로 이끌어줘요:\n1. 목표를 이루기 위해 정확히 무엇이 필요한지 생각해보기.\n2. 실제로 그것에 얼마나 많은 자원이 필요한지 이해하기.\n\n첫 번째 지점이 매우 명백하고, 우리는 이미 이에 대해 지나왔기 때문에—두 번째 지점의 중요성은 몇 가지 설명이 필요할 수도 있어요. 저자는 일주일에 너무 많은 시간을 일하게 되어 결국 필요한 것보다 더 많이 벌게 되지만, 이른 퇴직을 위한 충분한 금액은 아니라는 사례를 제시해요. 이렇게 하다 보면 돈을 벌기 위해 시간을 소비하는데 있어서 차이를 만들지 못하게 되죠. 자신의 기회를 가로채지 말고 레버리지를 만들고 더 많이 벌게 되는 걸 시작해보세요. 적어도 기쁨을 주는 일을 하세요.\n\n제가 다른 경우를 상상해볼 수도 있는데, 소득이 좋아서 부채들—차 대출, 주택 대출, 할부 등 때문에 여유 자금이 없는 경우가 있을 수 있어요. 정확히 무엇이 필요한지 판단하고 그 외의 것들을 모두 끊어내면—청구서를 지불하기 위해 쓰는 시간을 줄이고 미래를 위해 투자할 수 있는 시간을 늘릴 수도 있어요.\n\n\n\n# 앱이 무엇인가요?\n\n내 계획은 브라우저 전용 앱으로 만들어서 모든 \"단계\"와 \"동작\"을 채울 수 있는 것이다. 완료된 항목을 확인하고 새 항목을 추가하는 등 할 일 앱의 일반적인 기능 세트가 포함되어 있습니다. 총 비용 및 월 단위 비용의 기본적인 계산, 남은 시간 및 완료 여부를 나타내는 진행률 표시 막대도 포함됩니다.\n\n목표는 가능한 한 적은 기능을 가지고 있으면서도 완전한 제품이라고 부를 수 있을 정도로 충분히 많은 것을 갖추는 것입니다.\n\n하지만 알고 있는 바로는 — 인기/성공이 된다는 가능성은 무의미하다고 생각합니다. 복권에 당첨될 확률 정도나 비슷한 수준이라고 말씀 드릴 것입니다. 그러나 복권은 비교적 아무것도 들지 않는 대가로 구매할 수 있지만, 애플리케이션을 만들기에는 시간을 많이 투자해야 하는 도전적인 작업입니다. 그것이 무슨 일이 좀 괴물스러운 것 같다고 생각합니다. 그래서 내가 좀 더 일반적인 애플리케이션의 성공 여부와 관계없이 유익한 다른 목표가 필요합니다. 그리고 적어도 두 가지 목표가 이미 떠오르고 있습니다.\n\n\n\n## 1. 가능한 한 간단한 방법을 찾아보세요.\n\n낚시 끈과 고무줄을 사용하여 슬링샷을 만들어보세요. 그것은 가능한 한 적은 양의 기능/기술을 적절하게 조합하여, 최종 제품으로 잠재적 사용자에게 독특하고 (적어도 어느 정도는) 유용한 경험을 제공할 수 있도록 하는 것이 목표임을 강조하고 싶습니다. 서버 없이, 데이터베이스 없이, 인증 없이 등을 염두에 두세요. 브라우저에서 시작부터 끝까지 실행되는 순수한 JavaScript 앱이 될 것입니다. 데이터는 탭 간에 영속적이며 사용자가 브라우저를 닫고 다시 열어도 유지될 것이지만, 다른 기기에서는 사용할 수 없을 것입니다. 이것은 흠이 될 수 있지만, 사용자가 제공하는 민감한 데이터의 보안을 보장하기 때문에 동시에 이점이 될 수 있습니다. 사용자 브라우저의 벽 밖으로는 결코 나가지 않습니다. 그래서 이것은 제 생각에 꽤 유익한 대가제이며, 이 경우에는 개발 노력이 필요하지 않습니다.\n그게 다에요. 한 번의 네트워크 요청도 없죠... 호스팅에서 앱을 다운로드하기 위해 한 번 제외하고 말이에요. 첫 번째 버전에서는 반드시 적절한 데이터베이스와 인증이 삽입될 수도 있지만, 결코 중요하지는 않아요.\n\n## 2. 과정을 기록하세요.\n\n이것도 중요한 사항입니다. 저는 이미 10년 이상 업계에서 다양한 프로젝트를 맡아왔습니다. 내가 말해도 믿지 못할 정도로 나쁜 과정과 매우 좋고 수월한 과정들을 목격했어요. 그것들이 완벽하지는 않지만 더 나은 방법을 상상할 수 없을 만큼 좋았죠. 그러나 무언가를 한 곳에서 가져와 다른 곳에 적용하면 대부분 실패할 가능성이 높을 것입니다. 각 사례는 가능한 모든 방법에서 독특할 수 있으며, 그것들을 구축하기 위해서는 기술을 배워야 합니다. 좋은 장인은 장차 나올 제품에 어울리는 것이 아니라, 잘하는 도구가 아닌 제품에 맞는 도구를 사용한다는 것을 유념해야 합니다.\n그래서 개발 과정에서 마주하는 도전들을 기록하고, 어떤 관행이 잘 작동했고 어떤 것이 그렇지 않았는지 이유를 적어나갈 것입니다. 최종적으로 이는 시리즈로 이어지는 기사 집필이 되어야 할 것입니다.\n\n\n\n# 팀\n\n물론, 모든 것을 혼자서 하지는 않을 거에요. 프로젝트를 함께 진행할 친구가 있습니다. 그는 초보 개발자이지만 JavaScript와 ReactJS에 대한 지식이 있어서, 약간의 도움과 멘토링으로 일을 처리할 만하다고 믿어요.  \n나는 코딩을 최대한 멀리하려고 노력할 거에요. 그러다가 그가 곤경에 처했을 때나 전략적 결정을 내려야 할 때만 개입할 거에요.\n\n# 결론\n\n이 여정은 시작에 불과하고, 목적지는 불확실하지만, 우리가 그리고 있는 길은 학습과 혁신의 가능성으로 가득합니다. 여러분을 이 모험에 초대합니다. 피드백을 제공하거나 기능을 제안하거나, 그냥 우리의 진행상황을 따라오는 것까지. 함께 무엇을 만들 수 있는지 탐험해봐요.","ogImage":{"url":"/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png"},"coverImage":"/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png","tag":["Tech"],"readingTime":6}],"page":"110","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}