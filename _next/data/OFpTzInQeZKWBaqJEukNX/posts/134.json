{"pageProps":{"posts":[{"title":"리액트, 리액트 네이티브 및 노드js에서의 암호화","description":"","date":"2024-05-12 21:56","slug":"2024-05-12-EncryptioninReactReactNativeandNodejs","content":"\n\n암호화에 대한 올바른 모듈을 선택해주세요\n\n# 소개\n\n최근 프로젝트에서 만났던 암호화 관련 문제를 공유하고자 합니다. 먼저 사용된 암호화 방법론을 설명하고 어려움에 대해 깊이 있는 이야기로 파헤쳐보겠습니다. 웹 및 모바일 애플리케이션을 개발할 때 고려해야할 중요한 점은 호환성입니다. 기능을 설계하거나 모듈을 선택하거나 솔루션을 고려할 때 전체적인 접근 방식이 있어야 합니다. 모든 플랫폼에서 작동해야 합니다.\n\n# 암호화 아키텍처\n\n\n\n- 프론트엔드(React, React Native)에서 AES 암호화 키 생성하기\n- 백엔드(Node.js)에서 RSA 공개 및 개인 키 생성하기\n- RSA 공개 키를 프론트엔드와 공유하기\n- AES 키를 RSA 공개 키로 암호화하기\n- 보낼 데이터를 AES 키로 암호화하기\n- 암호화된 데이터와 암호화된 AES 키를 백엔드로 보내기\n- 백엔드에서 RSA 개인 키를 사용하여 암호화된 AES 키를 해독하여 AES 키를 검색하기\n- 검색된 AES 키를 사용하여 암호화된 요청 데이터를 해독하기.\n\n백엔드는 비슷한 프로세스를 따라 프론트엔드로 응답을 돌려보낼 것입니다. 키를 생성하고 암호화하는데 사용된 암호화 기술 전체 과정에 대해 설명하지는 않겠습니다. 다른 글에서 다룰 수도 있겠지만, 이제는 문제에 집중해보겠습니다.\n\n![Encryption in React, React Native, and Node.js](/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png)\n\n# 문제\n\n\n\nAES 키를 생성하고 RSA 키를 생성하며 RSA 키를 사용하여 AES 키를 암호화하는 경우, 코어 노드 js 모듈의 일부인 기본 암호화 모듈을 사용할 수 있습니다. React는 내부적으로 노드에 의존성이 있기 때문에 키를 생성하고 암호화하는 데 큰 문제가 없으며 추가 패키지도 필요하지 않습니다. 그러나 React Native의 경우 노드 코어 모듈을 지원하지 않습니다. 따라서 다양한 탐구 끝에 혼자 사용하면 좋지만 암호화를 만들기위해 패키지를 대체하는 것과 관련된 문제가 있는 react-native-rsa-native, crypto-browserify, react-native-fast-crypto, react-native-quick-crypto와 같은 패키지들은 작동하지 않는 것 같습니다.\n\n# 해결책\n\n모든 플랫폼(웹, 모바일 및 백엔드)을 위한 동일한 암호화 기능과 기술을 제공할 수 있는 일반적인 패키지를 검색하는 도중 더욱 신뢰할 수 있고 호환성이 뛰어나며 크기가 작고 인기가 많은 node-forge 패키지를 발견했습니다. 다른 패키지들과 비교했을 때 이 패키지는 모든 암호화 기능, 암호 및 암호화 기술을 갖추고 있어 솔루션을 구현하기 쉽게 만들어 주었습니다.\n\n```js\n// AES 키 생성\n// 클라이언트 측 React 및 React Native\n\nimport forge from 'node-forge';\nexport const generateAesKey = () => {\n  const aesSalt = forge.random.getBytesSync(16);\n  const keyPassPhrase = forge.random.getBytesSync(16);\n  const aesKey = forge.pkcs5.pbkdf2(\n    keyPassPhrase,\n    aesSalt,\n    ENCRYPTION_AES_ENC_KEY_OPTIONS.iterations, // 필요에 따라 사용\n    ENCRYPTION_AES_ENC_KEY_OPTIONS.keySize, // 필요에 따라 사용\n  );\n  return aesKey;\n};\n```\n\n\n\n```js\n// RSA 공개 및 개인 키 생성\n// 서버 측 Node.js\nconst forge = require('node-forge');\nconst rsaKeyPair = forge.pki.rsa.generateKeyPair({ bits: BITS }); // 필요에 따라 사용\nconst publicKeyPem = forge.pki.publicKeyToPem(rsaKeyPair.publicKey);\nconst privateKeyPem = forge.pki.privateKeyToPem(rsaKeyPair.privateKey);\n```\n\n```js\n// RSA 공개 키를 사용하여 AES 키 암호화\n// React 및 React Native\n\nimport forge from 'node-forge';\nexport const encryptAesKey = (receivedpublicKeyPem: string, aesKey: string) => {\n  try {\n    const publicKey = forge.pki.publicKeyFromPem(receivedpublicKeyPem);\n    const encryptedAesKey = publicKey.encrypt(aesKey, 'RSA-OAEP');\n    return forge.util.encode64(encryptedAesKey);\n  } catch (error) {\n    console.error('암호화 오류:', error);\n    throw error;\n  }\n};\n```\n\n```js\n// RSA 개인 키를 사용하여 암호화된 AES 키 복호화\nconst decryptedAesKey = rsaKeyPair.privateKey.decrypt(forge.util.decode64(encryptedAesKey), 'RSA-OAEP');\n```\n\n요청 데이터를 AES 키를 사용하여 암호화하고 백엔드에서 데이터를 복호화하기 위해 제 요구에 따라 다른 모듈을 사용했습니다 (React에는 crypto-js, React Native에는 react-native-crypto-js). 여전히 이 프로세스에 node-forge를 사용할 수 있습니다.\n\n\n\n\n읽어 주셔서 감사합니다! 👋","ogImage":{"url":"/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png"},"coverImage":"/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 애플리케이션 모듈화하기","description":"","date":"2024-05-12 21:53","slug":"2024-05-12-ModularizingReactApplication","content":"\n\n리액트 애플리케이션에서는 뷰 레이어 이상의 것을 사용하는 게 일반적입니다. 라우터, 로컬 저장소, 네트워크 요청, 보안 기능 등이 필요할 수 있습니다. 이러한 문제들을 모두 뷰 컴포넌트나 훅 안에서 처리하려고 하면 혼란을 초래하고 코드를 이해하기 어렵게 만들 수 있습니다.\n\n컴포넌트에 모든 것을 쑤셔 넣기보다는 각각 다른 파일이나 폴더로 관심사를 분리하는 것이 더 좋습니다. 이런 식으로 코드를 구성하면 응용 프로그램을 이해하는 데 필요한 정신적 부담을 줄일 수 있습니다. 한 번에 한 가지에 집중할 수 있어서 유지보수와 새로운 기능 추가가 더 쉬워집니다.\n\n하나의 접근 방법은 뷰-모델-데이터 레이어링 개념을 사용하는 것입니다. 이는 코드를 세 개의 레이어로 분리하는 것을 포함합니다. 뷰 레이어(리액트 컴포넌트), 모델 레이어(비즈니스 로직 및 계산), 데이터 레이어(네트워크 요청, 로컬 저장소 등)로 구분합니다. 이를 통해 응용 프로그램의 각 측면을 독립적으로 생각할 수 있어서 집중력을 높이고 코드를 더 모듈화하고 유지보수하기 쉽게 만들 수 있습니다.\n\n이러한 원칙은 새로운 것이 아니며 웹 시대 이전의 대형 GUI 애플리케이션에서 사용되었습니다. 이러한 확립된 패턴을 리액트 애플리케이션에 적용함으로써 더 조직적이고 관리 가능한 코드베이스를 만들 수 있습니다.\n\n\n\n# React 어플리케이션의 발전\n\nReact 어플리케이션이 성장함에 따라 초기에는 모든 로직을 컴포넌트 내부에 넣을 것입니다. 그러나 코드가 추가될수록 유지보수하기 어려운 혼돈스러운 상황이 될 수 있습니다. 이를 피하려면 확장 가능한 프런트엔드 앱을 구축하기 위해 다음 단계를 따르세요:\n\n1. 간단하게 시작하기: 처음에는 React 컴포넌트 내에 모든 로직이 들어갈 수 있으며, 동적 요소가 포함된 HTML처럼 보일 수 있습니다.\n\n2. 코드 구조화: 앱이 확장됨에 따라 코드를 뷰, 모델 및 데이터와 같은 별도의 레이어로 구성합니다. 이렇게 함으로써 복잡성을 줄이고 유지보수를 쉽게 만듭니다.\n\n\n\n모듈화: 코드를 더 작고 재사용 가능한 모듈로 분할하여 앱 전반에 걸쳐 관리하고 재사용하기 쉽게 합니다.\n\n패턴 수립: 코드 구조, 명명 및 폴더 구성을 위한 명확한 패턴과 규칙을 정하여 일관성과 명확성을 유지합니다.\n\n수립된 패턴 활용: 검증된 디자인 패턴과 업계 모베스트 프랙티스를 활용하여 앱 아키텍처를 이끄는 우량한 방법을 찾아 공통된 함정을 피합니다.\n\n문서화: 코드베이스를 효과적으로 문서화하여 개발자를 안내하고 모든 사람이 앱의 구조와 설계 결정을 이해할 수 있도록 합니다.\n\n\n\n## 단일 구성 요소 애플리케이션\n\n![이미지](/assets/img/2024-05-12-ModularizingReactApplication_0.png)\n\n## 다중 구성 요소 애플리케이션\n\n복잡한 구성 요소를 작은 구성 요소로 분할하는 것은 좋은 아이디어입니다. 이는 최종 HTML의 구조를 반영하며 한 번에 한 부분에 초점을 맞출 수 있게 해줍니다.\n\n\n\n![ModularizingReactApplication_1](/assets/img/2024-05-12-ModularizingReactApplication_1.png)\n\n앱이 커질수록 단순히 UI에 관한 것만이 아닙니다. 네트워크 요청을 처리하고 UI용 데이터를 형태로 변경하며, 서버에 대한 데이터를 수집해야 할 것입니다. 모든 것을 컴포넌트에 넣는 건 이상하게 느껴질 수 있습니다. 사용자가 보는 것뿐만이 아닙니다. 게다가 어떤 컴포넌트는 너무 많은 내부 상태를 유지해야 합니다.\n\n## 훅을 이용한 상태 관리\n\n이러한 논리를 서로 다른 위치에 두는 것이 더 낫습니다. React에서는 이렇게 할 수 있도록 여러분의 훅을 만들 수 있습니다. 훅은 상태를 공유하고 상태가 변경될 때의 로직을 공유하는 데 도움이 됩니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-ModularizingReactApplication_2.png\" />\n\n하나의 컴포넌트를 여러 부분으로 나누었군요. 몇 개의 간단한 디스플레이 전용 컴포넌트와 컴포넌트 상태를 다루는 재사용 가능한 훅이 있습니다.\n\n하지만 때로는 훅 안에 상태를 관리하는 것이 아닌 계산을 하는 로직이 있다면서요.\n\n## 비즈니스 모델이 나타났습니다\n\n\n\n![모듈화된 React 애플리케이션의 이미지](/assets/img/2024-05-12-ModularizingReactApplication_3.png)\n\n이 논리를 다른 곳으로 옮기면 정말 도움이 될 수 있다는 것을 깨달았군요. 이것을 분리함으로써, 논리가 더 집중되고 특정 뷰에 의존하지 않습니다. 따라서 데이터 매핑 및 널 값을 확인하는 간단한 객체를 만들기 시작합니다. 이러한 객체를 더 많이 만들면서 상속 또는 다형성을 사용하면 모든 것이 더 깔끔해집니다. 다른 영역에서 디자인 패턴을 적용하여 프론트엔드 애플리케이션을 더 깨끗하고 조직화된 상태로 만들려고 합니다.\n\n# 계층화된 프론트엔드 애플리케이션\n\n애플리케이션이 성장함에 따라 일부 패턴에 주목할 때가 옵니다. 사용자 인터페이스와 관련이 없고 데이터가 어디에서 왔는지 신경 쓰지 않는 객체들이 있습니다. 이러한 객체들을 다른 계층으로 분리하려고 합니다. 각 계층을 자세히 설명해 드릴게요: 표현(Presentation), 도메인(Domain), 그리고 데이터(Data) 계층입니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-ModularizingReactApplication_4.png\" />\n\n위의 개요를 통해 코드를 구조화하는 방법과 다음 단계를 알 수 있습니다. 하지만 접해 보기 전에 고려해야 할 많은 세부 사항이 있습니다.\n\n다음 섹션에서는 실제 프로젝트의 기능을 안내해 드릴 것입니다. 이를 통해 대규모 프론트엔드 응용 프로그램에 유용한 패턴 및 설계 원칙을 보여 드릴 것입니다.\n\n# 예제 프로젝트\n\n\n\n## 결제 기능 구축\n\n먼저 기본적인 온라인 주문 앱으로 시작해 봅시다. 여기서 고객들은 제품을 선택하고 주문에 추가할 수 있습니다. 그리고 나중에 결제 방법을 선택하여 구매를 완료할 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-ModularizingReactApplication_5.png)\n\n알겠어요. 지금은 결제 컴포넌트에 집중해 봅시다. 결제 방법 옵션들은 서버 측에서 구성되어 있어서, 서로 다른 국가의 고객들은 서로 다른 옵션을 볼 수 있습니다. 예를 들어, Apple Pay는 특정 국가에서만 이용 가능할 수 있습니다. 결제 방법용 라디오 버튼은 백엔드로부터의 데이터에 의해 제어됩니다. 만약 결제 방법이 반환되지 않는다면, 아무것도 보여주지 않고 기본값으로 \"현금 결제\"를 가정할 것입니다.\n\n\n\n테이블 태그를 Markdown 형식으로 변경해 보세요.\n\nSetup your mock server\n\n- Install JSON Server\n\n```js\nnpm install -g json-server\n```\n\n2. Create a Mock Data File payment-methods.json\n\n\n\n```json\n{\n  \"paymentMethods\": [\n    { \"name\": \"신용 카드\" },\n    { \"name\": \"PayPal\" },\n    { \"name\": \"Apple Pay\" }\n  ]\n}\n```\n\n3. JSON Server 시작\n\n```js\njson-server --watch payment-methods.json --port 3001\n```\n\n결제 과정은 건너뛰고 Payment 컴포넌트만 살펴봄으로써 간단하게 유지할 것입니다. 여기에 코드가 어떻게 나올지에 대한 기본적인 예시가 있습니다:\n\n\n\n```js\nsrc/Payment.tsx…\n\n  export const Payment = ({ amount }: { amount: number }) => {\n    const [paymentMethods, setPaymentMethods] = useState<LocalPaymentMethod[]>(\n      []\n    );\n  \n    useEffect(() => {\n      const fetchPaymentMethods = async () => {\n        const url = \"http://localhost:3001/paymentMethods\";\n  \n        const response = await fetch(url);\n        const methods: RemotePaymentMethod[] = await response.json();\n  \n        if (methods.length > 0) {\n          const extended: LocalPaymentMethod[] = methods.map((method) => ({\n            provider: method.name,\n            label: `Pay with ${method.name}`,\n          }));\n          extended.push({ provider: \"cash\", label: \"Pay in cash\" });\n          setPaymentMethods(extended);\n        } else {\n          setPaymentMethods([]);\n        }\n      };\n  \n      fetchPaymentMethods();\n    }, []);\n  \n    return (\n      <div>\n        <h3>Payment</h3>\n        <div>\n          {paymentMethods.map((method) => (\n            <label key={method.provider}>\n              <input\n                type=\"radio\"\n                name=\"payment\"\n                value={method.provider}\n                defaultChecked={method.provider === \"cash\"}\n              />\n              <span>{method.label}</span>\n            </label>\n          ))}\n        </div>\n        <button>${amount}</button>\n      </div>\n    );\n  };\n```\n\n이 코드는 꽤 일반적이며, 초보자를 위한 튜토리얼에서 가져온 것일 것입니다. 그렇게 나쁘지 않지만, 서로 다른 것들을 한 곳에 섞어서 이해하기 어렵게 만들었습니다.\n\n## 초기 구현의 문제점\n\n원래 코드의 문제점은 주로 Payment 컴포넌트가 너무 많은 일을 하고 있다는 것입니다. 다양한 작업을 처리하므로 코드를 이해하기 어렵습니다. 변경을 하려면 네트워크 요청을 시작하는 방법, 컴포넌트용 데이터 형식을 지정하는 방법, 각 결제 방법을 표시하는 방법, 그리고 Payment 컴포넌트 자체의 렌더링 로직을 이해해야 합니다.\n\n\n\n지금은 간단한 예제에서는 큰 문제가 되지는 않아요. 하지만 코드가 커지고 복잡해지면 리팩토링이 필요해질 거에요.\n\n뷰 코드와 비뷰 코드를 서로 다른 위치에 분리하는 것이 좋은 생각이죠. 뷰는 비뷰 로직보다 자주 변경되곤 해요. 이를 분리함으로써 특정 모듈에 집중하여 새로운 기능을 구현하기가 더 쉬워집니다.\n\n## 뷰 코드와 비뷰 코드의 분리\n\n뷰 코드와 비뷰 코드를 분리해봅시다. React에서는 사용자 정의 훅을 사용하여 컴포넌트의 상태를 관리하면서 컴포넌트 자체는 대부분 상태가 없도록 유지할 수 있어요. Extract Function 기법을 사용하여 usePaymentMethods라는 함수를 생성할 거에요. \"use\" 접두사는 React에서 해당 함수가 상태를 처리하는 훅이라는 것을 나타내는 관례입니다.\n\n\n\n표 태그를 마크다운 형식으로 변경하십시오.\n\n\n\n뷰를 더 나눠서 하위 구성 요소를 추출해 보는 건 어때요? 컴포넌트를 순수 함수로 만들면 (입력에 따라 결과가 예측 가능한) 테스트, 이해 및 재사용에 매우 도움이 될 거예요. 기억하세요, 컴포넌트가 작을수록 재사용될 가능성이 높아집니다.\n\n우리는 \"함수 추출\" 기술을 다시 사용할 수 있어요 (React에서는 컴포넌트를 본질적으로 함수로 취급하기 때문에 \"컴포넌트 추출\"이라고 부를 수도 있어요).\n\n```js\nsrc/Payment.tsx…\n\nconst PaymentMethods = ({\n  paymentMethods,\n}: {\n  paymentMethods: LocalPaymentMethod[];\n}) => (\n  <>\n    {paymentMethods.map((method) => (\n      <label key={method.provider}>\n        <input\n          type=\"radio\"\n          name=\"payment\"\n          value={method.provider}\n          defaultChecked={method.provider === \"cash\"}\n        />\n        <span>{method.label}</span>\n      </label>\n    ))}\n  </>\n);\n```\n\nPayment 컴포넌트는 PaymentMethods를 직접 사용할 수 있으므로 다음과 같이 단순화할 수 있답니다.\n\n\n\nsrc/PaymentComponent.tsx…\n\n```js\nexport const Payment = ({ amount }: { amount: number }) => {\n    const { paymentMethods } = usePaymentMethods();\n\n    return (\n      <div>\n        <h3>결제</h3>\n        <PaymentMethods paymentMethods={paymentMethods} />\n        <button>${amount}</button>\n      </div>\n    );\n  };\n```\n\nPaymentMethods는 상태를 가지지 않는 순수 함수(순수 컴포넌트)입니다. 기본적으로 문자열 서식 변환 함수입니다.\n\n## 로직을 캡슐화하기 위한 데이터 모델링\n\n\n\n지금까지 우리가 한 변경 사항은 뷰와 뷰가 아닌 코드를 분리하는 데 초점을 맞춰왔는데, 이것은 좋은 일이죠. 훅은 데이터를 가져오고 형태를 바꾸는 것을 관리하며, Payment와 PaymentMethods 모두 비교적 작고 이해하기 쉬운 형태가 되었어요.\n\n하지만 조금 더 자세히 살펴보면 아직 개선할 부분이 있습니다. 예를 들어, PaymentMethods 컴포넌트에서는 결제 수단이 기본적으로 선택되어야하는지 여부를 결정하는 일부 로직이 있습니다.\n\n```js\nsrc/Payment.tsx…\n\n  const PaymentMethods = ({\n    paymentMethods,\n  }: {\n    paymentMethods: LocalPaymentMethod[];\n  }) => (\n    <>\n      {paymentMethods.map((method) => (\n        <label key={method.provider}>\n          <input\n            type=\"radio\"\n            name=\"payment\"\n            value={method.provider}\n            defaultChecked={method.provider === \"cash\"}\n          />\n          <span>{method.label}</span>\n        </label>\n      ))}\n    </>\n  );\n```\n\n뷰에서 이러한 테스트 문은 로직 누출로 간주될 수 있으며, 시간이 지남에 따라 서로 다른 곳에 흩어져 수정이 더 어려워질 수 있습니다.\n\n\n\n데이터를 가져올 때 데이터 변환에서 논리 누출 가능성이 또 하나 있을 수 있습니다.\n\n```js\n useEffect(() => {\n      const fetchPaymentMethods = async () => {\n        const url = \"https://online-ordering.com/api/payment-methods\";\n  \n        const response = await fetch(url);\n        const methods: RemotePaymentMethod[] = await response.json();\n  \n        if (methods.length > 0) {\n          const extended: LocalPaymentMethod[] = methods.map((method) => ({\n            provider: method.name,\n            label: `Pay with ${method.name}`,\n          }));\n          extended.push({ provider: \"cash\", label: \"Pay in cash\" });\n          setPaymentMethods(extended);\n        } else {\n          setPaymentMethods([]);\n        }\n      };\n  \n      fetchPaymentMethods();\n    }, []);\n```\n\nmethods.map 안의 익명 함수가 변환을 묵묵히 수행합니다. 위의 `method.provider === \"cash\"`와 함께 이 논리는 클래스로 추출할 수 있습니다. 데이터와 동작을 단일 위치로 중앙 집중화한 PaymentMethod 클래스를 만들 수 있습니다.\n\n```js\n// src/PaymentMethod.ts\n\ninterface RemotePaymentMethod {\n  name: string;\n}\n\nexport interface LocalPaymentMethod {\n  provider: string;\n  label: string;\n  isDefaultMethod: boolean;\n}\n\nexport function createPaymentMethod(remotePaymentMethod: RemotePaymentMethod): LocalPaymentMethod {\n  const provider = remotePaymentMethod.name;\n  const label = provider === 'cash' ? `Pay in ${provider}` : `Pay with ${provider}`;\n  const isDefaultMethod = provider === 'cash';\n\n  return { provider, label, isDefaultMethod };\n}\n```  \n\n\n\n이제,\n\n```js\nimport { createPaymentMethod } from './PaymentMethod';\n\nuseEffect(() => {\n  const fetchPaymentMethods = async () => {\n    const url = \"https://online-ordering.com/api/payment-methods\";\n\n    const response = await fetch(url);\n    const methods: RemotePaymentMethod[] = await response.json();\n\n    if (methods.length > 0) {\n      // Memetakan setiap elemen dari methods menjadi objek LocalPaymentMethod\n      const localMethods: LocalPaymentMethod[] = methods.map(createPaymentMethod);\n\n      // Menambahkan metode pembayaran \"cash\" sebagai opsi tambahan\n      localMethods.push({ provider: \"cash\", label: \"Pay in cash\" });\n\n      // Mengatur state paymentMethods dengan array hasil pemetaan\n      setPaymentMethods(localMethods);\n    } else {\n      // Jika tidak ada metode pembayaran yang ditemukan, set state menjadi array kosong\n      setPaymentMethods([]);\n    }\n  };\n\n  fetchPaymentMethods();\n}, []);\n```\n\n이제 Payment 컴포넌트를 작업을 완료하기 위해 함께 작동하는 여러 작은 부분들로 재구성하고 있어요.\n\n![ModularizingReactApplication_6](/assets/img/2024-05-12-ModularizingReactApplication_6.png)\n\n\n\n새로운 구조에는 여러 가지 이점이 있어요:\n\n- 로직 캡슐화: 이 클래스는 모든 결제 방법 관련 로직을 캡슐화하여, 뷰에 내장하는 것보다 테스트와 수정이 더 쉬워졌어요.\n- 순수한 기능성: 추출된 컴포넌트인 PaymentMethods는 도메인 객체 배열에만 의존하는 순수한 기능이에요. 이로 인해 외부 상태와 상호 작용할 필요 없이 쉽게 테스트하고 재사용할 수 있어요.\n- 명확성과 모듈성: 각 부분이 명확하고 독립적으로 탐색할 수 있어요. 이 모듈식 접근법은 새로운 요구 사항이 발생했을 때 코드 수정을 간단하게 만들어줘요.\n\n# 새로운 요구 사항: 자선 단체에 기부하기\n\n새로운 기능인 자선 단체에 소액을 기부할 수 있는 기능을 애플리케이션에 추가하고 있어요. 고객이 주문과 함께 작은 금액을 자선 단체에 기부할 수 있는 옵션을 제공할 거예요. 사용자의 주문 총액이 $19.80이라면, $0.20을 기부할 수 있는 옵션을 제공할 거예요. 동의하면, 해당 버튼에 표시되는 총 금액을 업데이트할 거예요.\n\n\n\n\n![ModularizingReactApplication](/assets/img/2024-05-12-ModularizingReactApplication_7.png)\n\n변경을 하기 전에 현재 코드 구조를 간단히 살펴봅시다. 코드를 구조화해서 각 부분을 폴더로 구분하는 것을 선호합니다. 이렇게 하면 규모가 커져도 쉽게 탐색할 수 있어요.\n\n```js\nsrc\n      ├── App.tsx\n      ├── components\n      │   ├── Payment.tsx\n      │   └── PaymentMethods.tsx\n      ├── hooks\n      │   └── usePaymentMethods.ts\n      ├── models\n      │   └── PaymentMethod.ts\n      └── types.ts\n```\n\n우리 앱에서 App.tsx는 주 진입점으로 작동합니다. 이 파일에는 Payment 컴포넌트가 포함되어 있는데, 이 컴포넌트는 다양한 결제 옵션을 표시하기 위해 PaymentMethods를 활용합니다. usePaymentMethods 훅은 원격 서비스에서 데이터를 가져와 PaymentMethod 객체로 변환합니다. PaymentMethod 객체는 레이블과 기본 옵션 여부를 저장합니다.\n\n\n\n## 내부 상태: 기부에 동의\n\n이 페이지에서 체크박스를 선택한 사용자를 추적하기 위해 Payment에서 이러한 수정 사항을 구현하려면 agreeToDonate라는 부울 상태가 필요합니다.\n\n```js\n // 새로운 기능\n  const [agreeToDonate, setAgreeToDonate] = useState(false);\n\n  const { total, tip } = useMemo(\n    () => ({\n      total: agreeToDonate ? Math.floor(amount + 1) : amount,\n      tip: parseFloat((Math.floor(amount + 1) - amount).toPrecision(10)),\n    }),\n    [amount, agreeToDonate]\n  );\n\n  const handleChange = (event) => {\n    setAgreeToDonate(event.target.checked);\n  };\n```\n\nMath.floor 함수를 사용하여 숫자를 내림하여 사용자가 기부에 동의한 경우 올바른 금액을 얻을 수 있습니다. 내림 처리된 값과 원래 금액 간의 차이는 팁에 할당됩니다.\n\n\n\n뷰 관점에서, JSX에는 간단한 설명과 함께 체크박스가 포함될 것입니다:\n\n```js\nsrc/Payment.tsx…\n\n  return (\n    <div>\n      <h3>Payment</h3>\n      <PaymentMethods options={paymentMethods} />\n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            onChange={handleChange}\n            checked={agreeToDonate}\n          />\n          <p>\n            {agreeToDonate\n              ? \"기부해 주셔서 감사합니다.\"\n              : `나는 자선에 $${tip}을 기부하고 싶어합니다.`}\n          </p>\n        </label>\n      </div>\n      <button>${total}</button>\n    </div>\n  );\n```\n\n이러한 새로운 변경 사항으로 코드가 다시 여러 작업을 처리하기 시작합니다. 뷰 관련 코드와 비뷰 관련 코드가 혼합되지 않도록 주의깊게 관찰하는 것이 중요합니다. 불필요한 혼합이 발견된다면 분리할 수 있는 방법을 고려해보세요.\n\n그러나 이것은 엄격한 규칙은 아닙니다. 작고 일관된 구성 요소의 경우, 모든 것을 깔끔하게 유지하여 전반적인 작동 방식을 이해하기 위해 여러 곳을 찾아다닐 필요가 없도록 해도 괜찮습니다. 그러나 컴포넌트 파일이 이해하기 어렵게 너무 커지지 않도록 주의해야 합니다.\n\n\n\n# 훅을 활용하여 해결책 모색\n\n이 상황에서는 기부 여부에 따라 팁과 총액을 계산할 수 있는 객체가 필요합니다. 사용자가 기부 여부를 변경할 때마다 업데이트된 총액과 팁을 반환해야 합니다. \n\n이 요구 사항을 충족하기 위해 이러한 로직을 캡슐화하는 사용자 정의 훅을 구현하는 것이 이상적입니다. 이 사용자 정의 훅은 사용자의 입력을 기반으로 총액 및 팁 값을 계산하며 깔끔하고 재사용 가능한 솔루션을 제공할 것입니다.\n\n```js\nsrc/hooks/useRoundUp.ts…\n\n  export const useRoundUp = (amount: number) => {\n    const [agreeToDonate, setAgreeToDonate] = useState<boolean>(false);\n  \n    const {total, tip} = useMemo(\n      () => ({\n        total: agreeToDonate ? Math.floor(amount + 1) : amount,\n        tip: parseFloat((Math.floor(amount + 1) - amount).toPrecision(10)),\n      }),\n      [amount, agreeToDonate]\n    );\n  \n    const updateAgreeToDonate = () => {\n      setAgreeToDonate((agreeToDonate) => !agreeToDonate);\n    };\n  \n    return {\n      total,\n      tip,\n      agreeToDonate,\n      updateAgreeToDonate,\n    };\n  };\n```\n\n\n\n그래서 뷰에서는 초기 금액을 전달하여 이 훅을 활용할 것입니다. 이 훅은 모든 필요한 상태를 내부적으로 관리할 것입니다. 사용자가 기부 선호도를 토글할 때마다 updateAgreeToDonate 함수를 사용하여 훅의 값을 수정할 수 있습니다. 그러면 업데이트된 총액과 팁 금액을 반영하기 위해 리렌더링이 트리거됩니다.\n\n```js\nsrc/components/Payment.tsx…\n\n  export const Payment = ({ amount }: { amount: number }) => {\n    const { paymentMethods } = usePaymentMethods();\n  \n    const { total, tip, agreeToDonate, updateAgreeToDonate } = useRoundUp(amount);\n  \n    return (\n      <div>\n        <h3>Payment</h3>\n        <PaymentMethods options={paymentMethods} />\n        <div>\n          <label>\n            <input\n              type=\"checkbox\"\n              onChange={updateAgreeToDonate}\n              checked={agreeToDonate}\n            />\n            <p>{formatCheckboxLabel(agreeToDonate, tip)}</p>\n          </label>\n        </div>\n        <button>${total}</button>\n      </div>\n    );\n  };\n```\n\n메시지 형식 지정 로직을 formatCheckboxLabel과 같은 도우미 함수로 추출하는 것은 실제로 컴포넌트의 코드를 단순화할 것입니다. 이 도우미 함수는 사용자가 기부에 동의했는지 여부에 따라 적절한 메시지를 생성하는 논리를 처리할 수 있습니다.\n\n```js\nconst formatCheckboxLabel = (agreeToDonate: boolean, tip: number) => {\n  return agreeToDonate\n    ? \"기부해 주셔서 감사합니다.\"\n    : `자선 단체에 $${tip} 기부하고 싶습니다.`;\n};\n```\n\n\n\n상태와 로직을 useRoundUp과 같은 사용자 정의 훅에서 관리함으로써 Payment 컴포넌트가 훨씬 간단해지고 렌더링에 집중할 수 있습니다. 역할의 분리로 코드를 이해, 테스트 및 유지 관리하기 쉬워집니다. 또한 기부 확인란을 별도의 컴포넌트로 추출하는 것은 모듈성과 재사용성을 더욱 향상시켜 React 개발에서의 모범 사례를 준수합니다.\n\n```js\nsrc/components/DonationCheckbox.tsx…\n\n  const DonationCheckbox = ({\n    onChange,\n    checked,\n    content,\n  }: DonationCheckboxProps) => {\n    return (\n      <div>\n        <label>\n          <input type=\"checkbox\" onChange={onChange} checked={checked} />\n          <p>{content}</p>\n        </label>\n      </div>\n    );\n  };\n```\n\n또한 Payment에서는 React의 선언적 UI 덕분에 코드를 간단하게 읽을 수 있습니다. 거칠고 단순한 HTML조각처럼요.\n\n```js\nsrc/components/Payment.tsx…\n\n  export const Payment = ({ amount }: { amount: number }) => {\n    const { paymentMethods } = usePaymentMethods();\n  \n    const { total, tip, agreeToDonate, updateAgreeToDonate } = useRoundUp(amount);\n  \n    return (\n      <div>\n        <h3>Payment</h3>\n        <PaymentMethods options={paymentMethods} />\n        <DonationCheckbox\n          onChange={updateAgreeToDonate}\n          checked={agreeToDonate}\n          content={formatCheckboxLabel(agreeToDonate, tip)}\n        />\n        <button>${total}</button>\n      </div>\n    );\n  };\n```\n\n\n\n이제 이 시점에서 우리의 코드 구조는 아래 다이어그램과 같이 보입니다. 각 부분이 자신의 업무에 집중하고 프로세스가 작동하도록 함께 모이는 것에 주목해주세요.\n\n![모듈화된 리액트 애플리케이션 다이어그램](/assets/img/2024-05-12-ModularizingReactApplication_8.png)\n\n# 참고","ogImage":{"url":"/assets/img/2024-05-12-ModularizingReactApplication_0.png"},"coverImage":"/assets/img/2024-05-12-ModularizingReactApplication_0.png","tag":["Tech"],"readingTime":17},{"title":"React 앱을 GitHub 저장소에 연결하기","description":"","date":"2024-05-12 21:52","slug":"2024-05-12-ConnectingaReactApptoaGitHubRepository","content":"\n\n![이미지](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_0.png)\n\n이\n튜토리얼에서는 React 애플리케이션을 GitHub 저장소에 연결하는 방법을 배울 것입니다. 이 연결은 프로젝트에서 변경 사항을 추적하고 다른 사람들과 효과적으로 협업하는 데 중요합니다.\n\n다음은 시작하는 데 도움이 될 수 있는 단계별 가이드입니다:\n\n## 1. React 앱 만들기:\n\n\n\n비주얼 스튜디오 코드 터미널에서 다음 명령을 사용하여 React 애플리케이션을 시작하세요:\n\n```js\nnpx create-react-app my-react-app\n```\n\n앱의 디렉토리로 이동하세요:\n\n```js\ncd my-first-app\n```\n\n\n\n아래는 표의 내용입니다.\n\n| Order Number | Product Name | Quantity |\n|--------------|--------------|----------|\n| 1            | T-shirt      | 2        |\n| 2            | Jeans        | 1        |\n| 3            | Shoes        | 2        |\n\n\n\n한 번 시작하면 브라우저에서 앱이 작동하는 것을 볼 수 있을 거에요.\n\n![이미지](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_2.png)\n\n### 3. GitHub 저장소 설정:\n\n선택한 이름으로 새 GitHub 저장소를 만드세요. 다른 설정은 기본값으로 둬두 돼요.\n\n\n\n\n![Connecting a React App to a GitHub Repository](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_3.png)\n\nOnce created, you'll land on a new page.\n\n![Connecting a React App to a GitHub Repository](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_4.png)\n\nRemember to copy the repository link.\n\n\n\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_5.png\" />\n\n## 4. GitHub 저장소에 React 앱 연결하기:\n\nReact 애플리케이션의 디렉토리에서 새 터미널 탭을 열고 (필요시) 다음을 사용하여 앱 디렉토리로 이동하세요:\n\n```js\ncd my-first-app\n```\n\n\n\n기토 저장소를 초기화하세요\n\n```js\ngit init\n```\n\n아래 명령어를 사용하여 앱을 GitHub 저장소에 연결하세요. `<username>`을 여러분의 GitHub 사용자 이름으로 바꿔주세요:\n\n```js\ngit remote add origin https://github.com/<username>/my-first-app.git\n```\n\n\n\n내 경우에는\n\n```js\ngit remote add origin https://github.com/Brianhulela/my-first-app.git\n```\n\n![이미지](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_6.png)\n\n명령이 실행을 완료하면 다음 명령으로 연결을 확인합니다:\n\n\n\n```js\ngit remote -v\n```\n\n저장소 이름을 확인할 수 있어야 합니다. 저의 경우에는 출력이 다음과 같았습니다:\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_7.png\" />\n\n## 5. 변경 내용 준비 및 푸시:\n\n\n\n다음 명령을 실행하여 변경 내용을 커밋할 준비를 합니다:\n\n```js\ngit add .\ngit commit -m \"첫 번째 git 커밋\"\n```\n\n앱에 변경 사항이 없는 경우 커밋이 \"working tree clean\"을 반환할 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_8.png)\n\n\n\n## 6. 저장소로 푸시하기:\n\n귀하의 앱을 GitHub 저장소로 푸시하려면 다음을 사용하십시오:\n\n```js\ngit push\n```\n\n\"upstream\" 브랜치에 관한 오류가 발생할 수 있습니다. 마스터 브랜치가 아직 업스트림으로 설정되지 않았기 때문입니다. 다음 단계에서 이를 수행하겠습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_9.png\" />\n\n## 7. Upstream Branch 설정하기:\n\n다음 명령어를 사용하여 upstream branch를 설정하여 에러를 해결하세요:\n\n```js\ngit push --set-upstream origin master\n```\n\n\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_10.png\" />\n\n## 7. GitHub에서 확인하기:\n\n마지막으로, React 애플리케이션이 성공적으로 푸시되었는지 확인하기 위해 GitHub 저장소를 확인하세요.\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_11.png\" />\n\n\n\n이 단계를 따라하면 React 앱과 GitHub 저장소 간에 연결을 설정하여 효율적인 버전 관리와 협업이 가능해집니다.\n\n저장소: [https://github.com/Brianhulela/my-first-app](https://github.com/Brianhulela/my-first-app)","ogImage":{"url":"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_0.png"},"coverImage":"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_0.png","tag":["Tech"],"readingTime":3},{"title":"잔머리 풀기 CORS와 함께하는 Spring Boot, Spring Security","description":"","date":"2024-05-12 21:49","slug":"2024-05-12-WhattheCORSftSpringBootSpringSecurity","content":"\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_0.png\" />\n\n알겠습니다. 어느 날 한 마리로 리소스를 만들고, 읽고, 업데이트하고, 삭제할 수 있는 단일 리소스에 노출된 엔드포인트를 제공하는 간단한 Rest API를 만들려고 했습니다. React를 사용하여 이러한 요청을 제출하는 작은 폼을 만들고 싶었습니다.\n\n주의하세요, 다음 React 폼은 정말 진보적입니다. 이러한 종류의 폼을 만들려면 최소한 닌자 수준의 React 개발자여야합니다.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_1.png\" />\n\n\n\n친구들은 부러워하지 마세요!\n\n그래서 제 Rest API(Spring Boot으로 만든)는 'http://localhost:8080'에서 실행되고, 내 React 앱은 'http://localhost:3000'에서 실행 중이었어요.\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_2.png)\n\n첫 번째 포스트 요청을 보내 리소스를 서버에 만들 준비가 끝났어요. 기다림이 여린 마음으로, 마치 JPL 직원들이 Perseverance 착륙을 기다리던 것처럼요.\n\n\n\n그 다음 콘솔에서 이것을 보았어요\n\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_3.png)\n\n그리고 '개발자 콘솔'의 네트워크 탭으로 들어가서 더 자세히 파헤치려고 했더니, 두 개의 요청이 남아 있는 것을 보았어요\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_4.png)\n\n\n\n리액트 코드에서 fetch api를 사용하여 아래 POST 요청을 보냈습니다.\n\n![POST 요청](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_5.png)\n\n페이지에서 해당 제출 버튼을 누른 후, 두 가지에 대해 혼란스러웠습니다: \n\n- 왜 내 POST가 실패했는지\n- 개발자 콘솔 스크린샷에서 두 개의 요청이 서버 네트워크 탭에 표시되는 이유\n\n\n\nCORS 소개\n\nCORS는 특정 자바스크립트 코드(예: 내 React 코드 - http://localhost:3000)가 서버(내 서버에서 실행 중인 Spring Boot Rest Api - http://localhost:8000)로부터 리소스를 요청할 권한이 있는지 브라우저가 이해하는 방법입니다. 서버에서 허용되지 않으면 브라우저가 CORS 예외를 간단히 발생시킵니다.\n\n콘솔에서 받은 오류 메시지로 이해해 봅시다:\n\n\nfetch에 대한 액세스가 CORS 정책에 의해 차단되었습니다. ‘http://localhost:8080/airports`에서 `http://localhost:3000` 출처로부터: 사전 플라이트 요청에 대한 응답이 액세스 제어 확인을 통과하지 못함: 요청한 리소스에 ‘Access-Control-Allow-Origin’ 헤더가 없습니다. 불투명한 응답이 필요한 경우 요청의 모드를 ‘no-cors’로 설정하여 CORS가 비활성화된 상태로 리소스를 가져올 수 있습니다.\n\n\n\n\n여기 이해해야 할 키포인트는 '오리진(origin)'입니다. '오리진'은 '프로토콜://호스트:포트'의 조합입니다. 따라서 요청은 'http://localhost:3000'이라는 오리진에서 이루어지고 요청은 'http://localhost:8080'으로 보내집니다. 이는 두 개의 다른 오리진 간의 통신을 시도하는 것입니다. 따라서 이러한 경우에는 브라우저가 요청자(http://localhost:3000)가 요청받는이(http://localhost:8080)로부터 리소스를 요청할 수 있는지 확인합니다. 요청자가 허용되지 않을 경우, 요청을 할 때 CORS 에러가 발생합니다.\n\n그런데 왜 네트워크 탭에서 두 개의 요청이 발생하는 것일까요?\n\n주의 깊게 살펴보면, 하나의 요청은 'preflight'로 분류되고 다른 하나(즉, 실제로 POST를 하는 요청)는 스크린샷에서 보듯이 'CORS 에러'로 분류됩니다. 따라서 브라우저들은 먼저 POST 요청을 보내지 않고, 서버에서 허용된 '오리진'이 무엇인지 확인하려고 먼저 시도합니다. 이 확인을 위해 서버로 OPTIONS 요청을 보냅니다. 이는 종종 'preflight' 요청이라고 불립니다.\n\n따라서 이 preflight 요청으로 브라우저가 실제로 무엇을 기대하고 있는지 알아볼까요?\n\n\n\n브라우저는 서버로부터 해당 요청을 수락할 수 있다는 응답 헤더를 받기를 기다리고 있어요.\n\n정확히 어떤 응답 헤더인가요?\n\n\"access-control-allow-origin\" — 여기서 허용된 출처가 명시된 헤더에요. localhost:3000이 헤더에 명시되어 있다면 우리는 업무를 진행할 수 있어요.\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_6.png)\n\n\n\n이렇게 실패한 사전 플라이트 요청을 확인해 봅시다.\n\n요청 방법이 ‘OPTIONS’이고 서버에서 그 요청을 하지 못하게 하는 (403) 것으로 나왔네요. 그리고 나의 응답 헤더에는 ‘Access-Control-Allow-Origin’이라고 언급된 것이 없습니다. 결국, 서버 측에서 \"OPTIONS\" 요청 방법이 정의되지 않았기 때문에 사전 플라이트 요청 자체가 실패했습니다.\n\n![image](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_7.png)\n\n내 컨트롤러에는 기본적인 CRUD 요청 매핑(GET, POST, PUT, DELETE)만 있습니다.\n\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_8.png\" />\n\n이제 원래 질문은 무엇일까요? 사전검사(preflight)가 허용된 출처를 확인하고 \"http://localhost:3000\"을 허용된 출처로 허용하는 방법은 무엇일까요?\n\nSpring Boot은 @CrossOrigin 어노테이션을 통해 간단한 해결책을 제공합니다. 컨트롤러 클래스 상단에 이렇게 간단히 넣어보세요.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_9.png\" />\n\n\n\n이제 Spring Boot 애플리케이션을 다시 시작하고 리소스를 게시해 보았어요.\n\n그러자 성공했어요!\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_10.png)\n\n이제 프리플라이트와 포스트 요청이 모두 '200 - A Ok ;)'로 성공적으로 나갔다는 것을 확인하실 수 있을 거예요.\n\n\n\n자 이제 사전 검사 요청과 응답 헤더를 살펴보겠습니다.\n\n사전 검사의 요청 헤더에서 요청 방법은 ‘OPTIONS’이며 응답 헤더에서는 다음을 알 수 있습니다.\n\n‘Access-Control-Allow-Origin’ : * (이는 어떤 출처에서도 서버로의 요청을 보낼 수 있다는 것을 나타내므로 제 리액트 애플리케이션도 요청을 보낼 수 있는 자격이 있습니다.)\n\n‘Access-Control-Allow-Methods’ : POST (사전 검사는 만들어질 POST가 자격이 있다는 것을 확인했습니다)\n\n\n\n'허용' : GET, HEAD, POST, PUT, DELETE, OPTIONS, PATCH.\n\n서버의 @CrossOrigins 변경 전에 사전 요청(preflight request)이 서버에서 OPTIONS가 허용되지 않았기 때문에 403 상태를 받았습니다. 하지만 이제 서버에서 모든 요청 방법이 허용되는 것을 볼 수 있습니다. 따라서 preflight인 \"OPTIONS\" 요청이 서버에 선언된 엔드포인트가 없더라도 정상적으로 진행됩니다.\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_11.png)\n\n컨트롤러에 @CrossOrigins를 선언하는 것만으로 모든 출처와 방법이 서버에 도달할 수 있는 문을 열게 됩니다. 하지만 실제 응용 프로그램에서는 그런 것을 원하지 않을 것입니다. 따라서 @CrossOrigins의 이러한 속성을 사용하여 서버에서 필터링하고자 하는 출처와 방법을 사용자 정의할 수 있습니다.\n\n\n\n- origins = \"http://localhost:3000\"\n\n(내 React 앱만 요청할 수 있게 해줍니다)\n\n2. methods='RequestMethod.GET,RequestMethod.POST,RequestMethod.PUT,RequestMethod.DELETE'\n\n(어떤 메서드를 요청에서 허용할 지 정의할 수 있습니다)\n\n\n\n다른 것들을 선언하여 헤더를 허용하는 것, 자격 증명을 허용하는지 등을 확인할 수 있습니다. 스스로 살펴보세요!\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_12.png)\n\nPhase II — 스프링 시큐리티를 사용하여 내 요청에 기본 인증 부착\n\n좋아요. 이 자신감을 얻은 후에, 나는 내 REST API에 스프링 시큐리티를 부착해보고 싶었습니다. 요청을 인증하는 방법으로 기본 인증을 허용하려고 했습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_13.png\" />\n\n나는 닌자인 나로써, pom.xml에 Spring Security 스타터 종속성을 추가하고 메이븐 종속성을 업데이트하고 서버를 시작했어. 서버를 다시 시작하면, Spring Security가 응용 프로그램에 '사용자'라는 기본 사용자 이름과 Spring Security가 무작위로 생성하는 해시된 비밀번호로 인증 레이어를 추가해.\n\n이제, 리액트 애플리케이션에서 동일한 포스트 요청을 보냈어.\n\n그리고 다시 한 번, 무서운 CORS 예외가 발생했어.\n\n\n![2024-05-12-WhattheCORSftSpringBootSpringSecurity_14](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_14.png)\n\n네트워크에 들어가서 문제를 더 디버깅했습니다.\n\npost 요청이 하나만 있었고 프리플라이트 요청은 없었습니다. post 요청에 대한 응답에는 'Access-Control-Allow-Origin'이 설정되어 있지 않았습니다. 또한 'WWW-Authenticate:Basic realm=\"Realm\"' 헤더를 확인했습니다.\n\n![2024-05-12-WhattheCORSftSpringBootSpringSecurity_15](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_15.png)\n\n\n\n그래서 기본적으로 스프링 시큐리티를 활성화한 후에는 두 가지 작업을 수행해야 합니다:\n\n- 요청을 보낼 때 클라이언트에서 기본 인증 요청을 보내야 합니다.\n- 서버가 React 애플리케이션이 허용된 출처임을 나타내는 Access-Control-Allow-Origin 플래그를 보내야 합니다.\n\n그런데, 우리가 컨트롤러에 @CrossOrigins를 이미 언급했었죠.\n\n그렇지만, 스프링 시큐리티를 활성화했을 때는 고려되지 않으니 이를 해결할 방법이 필요합니다.\n\n\n\n한 단계씩 해결해 보겠습니다.\n\n- 우리 클라이언트에서 기본 인증 요청을 보냅시다.\n\nFetch를 사용하므로 React에서 POST 호출을 할 때 보내는 매개변수에 다음 헤더 정보를 첨부해야 합니다:\n\n\n\"Authorization\":\"Basic Base64encoded(username:password)\"\n\n\n\n\n제 사용자 이름은 \"user\"이고,\n\n비밀번호는 \"harambe\"입니다.\n\n리액트에서 btoa라는 함수를 사용할 수 있습니다. 사용자 이름과 비밀번호를 이 함수에 전달하면 btoa(user:harambe)처럼 보일 것입니다. btoa 메소드는 base64 인코딩된 문자열을 반환합니다. 그래서 결과물은 다음과 같이 보일 것입니다:\n\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_16.png)\n\n\n\n기본 및 btoa(username:password) 방법 사이에 공백을 유지하는 것을 잊지 마세요. 이것은 인증을 돕게 됩니다.\n\n이제 해당 포스트 호출을 다시 시도해 봅시다.\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_17.png)\n\n음, 음, 여기 누가 있나요. 네트워크로 이동하여 사전 휴식 및 포스트 요청을 모두 확인했습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_18.png\" />\n\n패턴은 프로젝트에 spring security를 추가하기 전에 만난 것과 똑같아요. 권한이없는 하나의 사전(OPTIONS) 요청과 별도의 CORS 예외가 있다 fetch POST 호출(실제 호출).\n\n사전 요청과 응답을 살펴보면, 서버에서는 액세스 허용 제어 원점을 반환하지 않았고 OPTIONS 요청에서도 인증을 예상하고 있었어요.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_19.png\" />\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_20.png\" />\n\n저는 주말 절반을 보내며 Spring Security를 구성하여 Cross Origin 요청을 허용하는 방법을 찾았습니다. 이 코드를 발견했어요.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_21.png\" />\n\n이 Rest API를 호스팅하는 주요 Spring 애플리케이션에서 이러한 기본 제공 메서드를 호출하여 Spring Security 구성을 구성하세요.\n\n\n\n여기 메서드가 있어요.\n\n- cors() - 스프링 시큐리티에 CORS를 활성화하라고 알려줍니다. 이제 서버는 오리진을 화이트리스트/필터링할 준비가 되었어요. 그래서 여전히 오리진 목록을 설정할 것입니다.\n- httpBasic() - 클라이언트가 기본 인증 방식을 통해 요청을 인증할 것이라고 스프링 시큐리티에 알려줍니다. 그래서 스프링 시큐리티는 클라이언트에서 보내는 'Authorization': 'Basic #해시'를 읽을 수 있도록 조정되어 있어요. 유효한 인증 정보인 경우, 스프링 시큐리티는 우리를 통과시켜줄 거에요.\n\n코드에서 보이는 나머지 메서드들에 대해서는 다른 블로그 포스트를 계획 중이에요.\n\n지금은 cors()가 활성화된 상태일 뿐, 화이트리스트에 등록할 오리진을 아직 설정해야 해요.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_22.png\" />\n\n여기서 컨트롤러를 보면 다음과 같은 설정을 추가했습니다.\n\n- origins = \"http://localhost:3000\" : 내 리액트 코드가 있는 곳입니다.\n- allowCredentials = true: 인증 형식을 사용한다면 중요한 부분입니다.\n\n기본적으로 @CrossOrigin은 모든 요청 방식과 헤더를 허용합니다. 그래서 사전 통지 요청에 문제가 없을 겁니다.\n\n\n\n지금, 다시 그 게시 버튼을 눌러보세요\n\n![이미지1](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_23.png)\n\n![이미지2](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_24.png)\n\n마침내, 영광의 달콤함.\n\n\n\n이곳에 있는 두 번째 요청은 무시해 주세요. Preflight에서 온 것이 아닙니다. 화면 캡처에서 보는 것처럼, 뭔가를 게시한 후에 'Get'을 수행하는 로직을 작성했습니다.\n\n우리의 설정으로 인해 POST 요청 및 응답 헤더가 어떻게 영향을 받는지 확인해보겠습니다.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_25.png\" />\n\n'Access-Control-Allow-Credentials' 플래그가 true로 설정되어 있고, 허용된 출처에는 React 애플리케이션 원본이 표시되는 것을 볼 수 있습니다.\n\n\n\n행복한 하루 보내세요!","ogImage":{"url":"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_0.png"},"coverImage":"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_0.png","tag":["Tech"],"readingTime":9},{"title":"리덕스 툴킷 API들","description":"","date":"2024-05-12 21:47","slug":"2024-05-12-ReduxToolkitAPIs","content":"\n\n<img src=\"/assets/img/2024-05-12-ReduxToolkitAPIs_0.png\" />\n\nRedux Toolkit은 JavaScript 애플리케이션을 위한 인기 있는 상태 관리 라이브러리인 Redux와 함께 작업하는 과정을 간단하게 만들어 주는 일련의 도구와 유틸리티를 제공하는 패키지입니다. Redux Toolkit의 주요 기능 중 하나는 Redux 개발을 간소화하기 위한 여러 함수와 유틸리티를 포함한 내장 API입니다.\n\nRedux Toolkit은 JavaScript 애플리케이션을 위한 인기 있는 상태 관리 라이브러리인 Redux와 함께 작업하는 과정을 간단하게 만들어 주는 일련의 도구와 유틸리티를 제공하는 패키지입니다. Redux Toolkit의 주요 기능 중 하나는 Redux 개발을 간소화하기 위한 여러 함수와 유틸리티를 포함한 내장 API입니다.\n\nRedux Toolkit API에 대한 개요는 아래와 같습니다:\n\n\n\n- createSlice: 이 유틸리티 함수를 사용하면 Redux 슬라이스를 정의할 수 있어요. 슬라이스는 응용 프로그램 상태의 특정 부분을 관리하기 위한 리듀서 로직 모음입니다. 제공하는 리듀서 로직에 기반하여 자동으로 액션 생성자와 액션 유형을 생성하여 보일러플레이트 코드를 줄여줘요.\n- configureStore: 이 함수는 Redux DevTools Extension을 지원하는 합리적인 기본값을 갖춘 Redux 스토어를 만드는 데 사용돼요. 여러 구성 단계를 단일 함수 호출로 결합하여 Redux 스토어를 설정하는 과정을 단순화시켜줘요.\n- createAsyncThunk: 이 유틸리티 함수는 Redux에서 비동기 로직을 처리하는 과정을 간단하게 해주는데, API에서 데이터를 가져오는 비동기 작업의 상태에 따라 자동으로 보류 중, 성공 및 거부된 액션을 디스패치하는 액션 생성자를 생성합니다.\n- createEntityAdapter: 이 유틸리티 함수는 Redux에서 정규화된 엔티티 상태를 관리하기 위한 리듀서 함수와 셀렉터 집합을 생성해줘요. Redux에서 관계형 데이터 구조를 다루기 쉽도록 데이터를 정규화된 형식으로 조직화하고 관리하는데 도움이 돼요.\n- createReducer: 이 유틸리티 함수를 사용하면 createSlice에서 사용하는 방식과 유사하게 액션 유형의 맵을 기반으로 리듀서 로직을 정의할 수 있어요. 슬라이스 외부에서 리듀서 로직을 더 유연하게 정의해야 하는 경우에 유용해요.\n\n전반적으로 Redux Toolkit API는 Redux를 사용하는 일반적인 경우를 단순화하고, 보일러플레이트 코드를 줄이며, Redux 작업을 위한 직관적이고 견해 있는 도구 세트를 제공하여 개발자 생산성을 향상시킵니다.\n\n# Redux 데이터 과부하 문제를 어떻게 처리하나요?\n\nRedux Toolkit은 직접적으로 데이터 과부하 문제를 처리하지는 않지만, 이를 완화할 수 있는 도구와 패턴을 제공해요:\n\n\n\n- 정규화된 상태 관리: Redux Toolkit은 createEntityAdapter와 같은 유틸리티를 사용하여 정규화된 상태 관리를 권장합니다. 데이터 구조를 정규화함으로써 데이터 오버로드를 방지할 수 있으며, 데이터를 구조화된 방식으로 조직화하여 관리 및 업데이트하기 쉽게 만들어줍니다.\n- 선택적 데이터 로딩: createAsyncThunk를 사용하면 게으른 로딩 또는 페이지네이션과 같은 선택적 데이터 로딩 기술을 구현하여 필요한 데이터만 필요할 때만 로드할 수 있습니다. 이는 Redux 저장소에 저장된 데이터 양을 줄이고 성능을 향상시킬 수 있습니다.\n- 메모화: Redux Toolkit은 메모화를 직접 처리하지는 않지만, Reselect와 같은 메모화 라이브러리를 Redux Toolkit과 함께 사용하여 선택자를 최적화하고 데이터 오버로드로 인한 불필요한 다시 렌더링을 방지할 수 있습니다.\n- 미들웨어와 쓰로틀링: Redux 미들웨어를 사용하여 데이터 오버로드를 유발할 수 있는 작업에 대한 쓰로틀링이나 디바운싱 기술을 구현할 수 있습니다. 쓰로틀링은 액션이 디스패치되는 속도를 제어하여 Redux 저장소에 과도한 업데이트를 방지하는 데 도움이 될 수 있습니다.\n- 선택적 상태 슬라이싱: 전체 상태 객체에 액세스하는 대신 선택자를 사용하여 상태 트리의 필요한 부분만 검색할 수 있습니다. 이는 성능을 향상시키고 특히 대량 데이터 처리 시 메모리 사용량을 줄일 수 있습니다.\n\nRedux Toolkit은 Redux 상태를 관리하기 위한 유용한 도구와 패턴을 제공하지만 데이터 오버로드 문제를 피하기 위해 응용 프로그램의 상태 관리 전략을 신중하게 설계하는 것이 중요합니다. 특정 사용 사례에 적합한 정규화, 선택적 데이터 로딩, 메모화 및 기타 성능 최적화 기술을 조합하여 사용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-ReduxToolkitAPIs_0.png"},"coverImage":"/assets/img/2024-05-12-ReduxToolkitAPIs_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 컨텍스트의 최상의 사용 방법","description":"","date":"2024-05-12 21:46","slug":"2024-05-12-ReactContextBestPractices","content":"\n\n리액트 프레임워크는 효율성과 유연성으로 유명하며, 개발자들이 견고하고 확장 가능한 웹 애플리케이션을 만들 수 있도록 다양한 기능을 제공합니다. 이러한 기능 중에서 리액트 컨텍스트 API는 상태를 관리하고 데이터를 구성 요소 트리 전체로 전달할 수 있는 주요 도구로, 프롭 드릴링이 필요 없이 개발자들이 상태를 효과적으로 관리할 수 있게 해줍니다. 이는 애플리케이션 내 여러 구성 요소에서 필요로 하는 \"전역\" 데이터를 처리하는 데 매우 유용합니다. 예를 들어 사용자 인증, 테마 또는 선호하는 언어와 같은 데이터가 있습니다.\n\n그러나 컨텍스트 API는 강력하지만, 의도하지 않은 다시 렌더링을 방지하고 애플리케이션의 성능을 유지하기 위해 신중한 접근이 필요합니다. 이 블로그 글은 리액트 컨텍스트 API를 사용하는 데 최선의 방법에 대해 탐구하며, 애플리케이션이 효율적으로 유지되고 코드가 유지보수 가능하도록 하는 것을 목표로 합니다.\n\n다음 섹션에서는 컨텍스트 API에 대해 자세히 살펴보고, 언제 컨텍스트를 사용해야 하는지 강조하고, 리액트 애플리케이션에서 컨텍스트를 구현하기 위한 여러 가이드라인을 논의할 것입니다. 리액트에 익숙하지 않거나 상태 관리에 대한 지식을 향상시키고 싶다면, 이 글은 유용한 통찰과 지침을 제공할 것입니다.\n\n![React Context Best Practices](/assets/img/2024-05-12-ReactContextBestPractices_0.png)\n\n\n\n# React Context의 기본 이해\n\nReact Context는 React 16.3에서 소개된 기능으로, 데이터를 props를 통해 전달하지 않고 컴포넌트 간에 공유할 수 있도록 해줍니다. Context API는 \"prop drilling\" 문제를 해결하는 데 도움이 됩니다. \"prop drilling\"은 데이터를 최상위 컴포넌트에서 하위 컴포넌트로 전달하는 과정을 말합니다. Context를 사용하면 어디에 있든지 컴포넌트에 상태를 직접 제공할 수 있습니다.\n\n먼저, React Context는 React.createContext()를 사용하여 생성됩니다. 이 함수는 Provider와 Consumer를 포함한 객체를 반환합니다.\n\n```js\nconst MyContext = React.createContext(defaultValue);\n```\n\n\n\nProvider 컴포넌트는 트리 상위에서 사용되며 value 프롭을 받습니다. 이 값은 문자열, 객체, 함수 등 아무 것이나 될 수 있습니다.\n\n```js\n<MyContext.Provider value={/* 어떤 값 */}>\n```\n\nContext에 저장된 데이터에 필요한 모든 컴포넌트는 Consumer 컴포넌트를 통해 액세스할 수 있습니다. Consumer는 렌더 프롭 API를 사용합니다. 즉, 함수를 자식으로 취하는 것을 의미합니다. 이 함수는 컨텍스트 값 받아들이고 React 노드를 반환합니다.\n\n```js\n<MyContext.Consumer>\n  {value => /* 컨택스트 값에 기반하여 렌더링할 내용 */}\n</MyContext.Consumer>\n```\n\n\n\n대신에 함수 컴포넌트 내에서 컨텍스트에 액세스하려면 useContext 훅을 사용할 수 있습니다.\n\n```js\nconst value = useContext(MyContext);\n```\n\n중요한 점은 React가 이 컨텍스트 객체에 구독하는 컴포넌트를 렌더링할 때, 가장 가까운 일치하는 Provider에서 현재 컨텍스트 값을 읽을 것이라는 것입니다.\n\n컨텍스트 API는 모든 상태 또는 prop 상호작용을 대체하기 위한 것이 아닙니다. 컴포넌트 트리에서 \"전역\"으로 간주될 수 있는 데이터를 공유하기 위해 설계되었습니다. 예를 들어 현재 인증된 사용자, 테마 또는 언어 설정과 같은 것입니다.\n\n\n\nMobX React Context의 기본 사항을 이해하는 것은 더 고급 사용법과 모벡스 사이의 상호작용 및 최적의 방법에 뛰어들기 전에 중요합니다. 이는 훅과 같은 다른 기능들과 어떻게 통합하고, 불필요한 렌더링과 다른 성능 문제를 방지하기 위해 컨텍스트를 어떻게 적절히 구성하는지를 배우는 것을 포함합니다.\n\n# React Context 사용의 최상의 방법\n\n- Context를 절약하게 사용하세요: 컨텍스트 API는 강력한 도구이지만 상태 관리의 해결책으로 쓰기에는 적합하지 않습니다. 필요할 때만 사용하고 지나치게 사용하면 불필요한 다시 렌더링을 유발하고 성능에 부정적인 영향을 미칠 수 있습니다.\n- 복잡한 상태에 useReducer와 함께 컨텍스트 사용하기: useReducer 훅은 여러 하위 값이 관련된 복잡한 상태 로직을 관리하는 데 선호되는 선택지입니다. 컨텍스트와 함께 사용하면 컴포넌트의 복잡한 로컬 상태를 reducer 함수로 관리할 수 있어 상태 관리에 이상적입니다.\n- 관심사 분리를 위해 여러 컨텍스트 사용하기: 하나의 큰 컨텍스트 대신 여러 작은 컨텍스트로 분리하는 것이 좋습니다. 이렇게 하면 구독하는 데이터가 변경될 때만 컴포넌트가 다시 렌더링되므로 불필요한 다시 렌더링을 방지할 수 있습니다.\n- Prop Drilling 피하기: 컨텍스트는 트리를 통해 수동으로 prop을 전달하는 것 대신 사용할 수 있는 대안입니다. 중첩된 컴포넌트를 통해 prop을 전달하게 되면 Context를 도입할 때인지 검토해야 합니다.\n- 컨텍스트를 테스트하세요: 애플리케이션의 다른 부분과 마찬가지로 컨텍스트도 예상대로 동작하는지 확인하기 위해 테스트해야 합니다. React의 ReactTestRenderer.create와 enzyme의 shallow 및 mount 메서드를 사용하여 컨텍스트 소비자와 제공자를 테스트할 수 있습니다.\n- 컨텍스트 제공자 안에 컴포넌트 래핑하기: 컴포넌트를 컨텍스트 제공자 내에 래핑하도록 해주세요. 제공자 내에 있는 컴포넌트만 컨텍스트에 액세스할 수 있습니다.\n- 기본 값을 사용하세요: 기본 값은 컴포넌트를 감싸지 않고 독립적으로 테스트하는 데 유용할 수 있습니다. 컴포넌트 주변에 일치하는 제공자가 없을 때 컨텍스트는 기본 값을 사용할 것입니다.\n\n이러한 최상의 방법을 따르면 일반적인 함정을 피하고 성능을 향상시키며 애플리케이션의 상태 관리를 효율적이고 유지보수 가능하게 할 수 있습니다. 또한 useReducer와 Context의 강력한 조합을 통합하여 복잡한 상태 로직을 쉽고 정확하게 관리할 수 있습니다.\n\n\n\n![React Context Best Practices](/assets/img/2024-05-12-ReactContextBestPractices_1.png)\n\n# 결론\n\n요약하면, React Context API는 상태(state)와 속성(props)을 쉽게 관리할 수 있는 강력한 기능으로, 애플리케이션을 간소화하고 성능을 향상시킬 수 있습니다. React Context에 대한 최상의 사용 사례를 따르면, 이 기능을 최대한 활용하여 prop 전달을 줄이고 코드를 더 읽기 쉽고 유지보수하기 쉽게 만들 수 있습니다.\n\n올바르게 활용하면, React Context는 매끄럽고 매력적인 사용자 경험을 만들어줍니다. 전역 상태 처리부터 테마 또는 다국어 지원까지, 애플리케이션에서 Context를 활용할 수 있는 가능성은 매우 많습니다. 그러나 Context는 애플리케이션에서 모든 상태 관리를 대체해서는 안 되며, 대신 구성 요소 간에 액세스해야 하는 전역 상태를 전략적으로 사용해야 합니다.\n\n\n\nReact Context를 사용하는 것을 탐험할 때, Context의 구조와 조직을 고려하는 것이 중요하며 불필요한 다시 렌더링을 피하고 다른 기능과 함께 Context를 결합하여 최대 이점을 얻을 수 있습니다.\n\nReactjs 개발자를 고용하려면 CronJ IT Technologies를 고려해보세요. 그들의 팀은 React를 활용한 경험이 풍부하며 복잡한 애플리케이션에서 React Context의 강력함을 발휘한 경험이 있습니다. React 여정을 시작하거나 기존 애플리케이션을 개선하려는 경우, CronJ가 필요한 전문 지식과 지원을 제공할 수 있습니다.\n\n# 참고 자료\n\n- https://reactjs.org/docs/context.html\n- 자바스크립트에서 푸시 알림: 포괄적 가이드 | Olga Green | 2023년 6월 | Medium\n- 상태 관리를 위한 React Context API","ogImage":{"url":"/assets/img/2024-05-12-ReactContextBestPractices_0.png"},"coverImage":"/assets/img/2024-05-12-ReactContextBestPractices_0.png","tag":["Tech"],"readingTime":5},{"title":"React Div 대신에 React Fragments를 사용해야 하는 이유","description":"","date":"2024-05-12 21:45","slug":"2024-05-12-WhyYouShouldUseReactFragmentsInsteadofDivs","content":"\n\n![이미지](/assets/img/2024-05-12-WhyYouShouldUseReactFragmentsInsteadofDivs_0.png)\n\n프론트엔드 개발의 세계에서는 모든 코드 라인이 중요합니다. 웹 애플리케이션이 더 복잡해지면서 성능 최적화와 가독성 있는 깨끗한 코드 유지가 중요해집니다. React 개발자가 가진 덜 알려진 도구 중 하나인 React 프래그먼트는 이러한 고민을 해소해줍니다. 이 글에서는 프로젝트에 React 프래그먼트를 사용하는 것이 어떻게 게임 체인저가 될 수 있는지 살펴보겠습니다.\n\nReact 프래그먼트란 무엇인가요?\nReact 16.2에서 소개된 React 프래그먼트는 DOM에 추가적인 노드를 생성하지 않고 여러 개의 React 엘리먼트를 그룹화하는 방법을 제공합니다. div나 다른 컨테이너 엘리먼트와 달리 프래그먼트는 추가적인 DOM 레이어를 도입하지 않고 엘리먼트를 그룹화할 수 있습니다.\n\n성능 최적화\nReact 프래그먼트를 div 대신 선택하는 핵심 이유 중 하나는 성능 최적화입니다. div를 사용하여 엘리먼트 목록을 렌더링할 때 각 div는 DOM 트리에 새로운 노드를 추가합니다. 특히 긴 목록이나 깊게 중첩된 컴포넌트를 다룰 때 불필요한 비대가 될 수 있습니다.\n반면에 React 프래그먼트는 새로운 DOM 노드를 만들지 않습니다. 대신, DOM 계층 구조에 추가적인 레이어를 도입하지 않고 엘리먼트를 그룹화할 수 있습니다. 이는 보다 빠른 렌더링 시간과 보다 간결한 DOM 구조를 가져와서 궁극적으로 응용 프로그램의 성능을 향상시킬 수 있습니다.\n\n\n\n친절한 톤으로 번역해드리겠습니다.\n\n더 깨끗한 마크업\n성능 이점을 넘어서 React Fragments를 사용하면 더 깨끗한 마크업을 얻을 수 있습니다. 아이템 목록을 부모 div로 감싸지 않고 렌더링하고 싶은 시나리오를 생각해보세요. 이때 div를 사용하면 HTML에 불필요한 래퍼 엘리먼트가 도입되어 마크업이 복잡해지고 가독성이 떨어지게 됩니다.\nReact Fragments는 추가적인 노드를 DOM에 추가하지 않고도 엘리먼트를 그룹화할 수 있어 이 문제를 우아하게 해결합니다. 이를 통해 JSX 마크업을 깔끔하고 간결하게 유지하면서도 필요한 엘리먼트에만 집중할 수 있죠, 부가적인 래퍼에 신경 쓸 필요가 없습니다.\n\n향상된 접근성\n접근성은 React Fragments가 빛을 발하는 또 다른 영역입니다. div나 다른 컨테이너 엘리먼트를 사용할 때, 스크린 리더가 이러한 엘리먼트의 존재를 알리고 시각 장애를 가진 사용자들을 혼란스럽게 할 수 있습니다. React Fragments를 사용하면 추가적인 노드를 생성하지 않아 스크린 리더에는 보이지 않으므로 UI가 더 접근성 있게 되는 장점이 있습니다.\n\n결론\n요약하면, React Fragments는 React 애플리케이션에서 엘리먼트를 그룹화하는 가벼운 효율적인 방법을 제공합니다. 불필요한 DOM 노드를 피하면서 성능 향상, 깨끗한 마크업, 그리고 높은 접근성을 얻을 수 있습니다. 다음에 엘리먼트를 감싸기 위해 div를 사용하려 할 때는 React Fragment를 대신 활용해보고 직접 이점을 경험해보세요.","ogImage":{"url":"/assets/img/2024-05-12-WhyYouShouldUseReactFragmentsInsteadofDivs_0.png"},"coverImage":"/assets/img/2024-05-12-WhyYouShouldUseReactFragmentsInsteadofDivs_0.png","tag":["Tech"],"readingTime":2},{"title":"스크롤이 맨 아래로 도착했는지 감지하기","description":"","date":"2024-05-12 21:44","slug":"2024-05-12-Detectscrollreachesthebottom","content":"\n\n안녕하세요, 오늘은 사용자가 페이지 맨 아래로 스크롤할 때 감지하는 방법을 알려 드리겠습니다.\n\n코딩에 들어가기 전에 계산에 필요한 몇 가지 중요한 정보를 이해하는 것이 중요합니다:\n\n- window.innerHeight: 보이는 콘텐츠의 높이입니다.\n- document.body.scrollHeight: 보이는 부분과 숨겨진 부분을 모두 포함한 전체 콘텐츠의 총 높이입니다.\n- window.scrollY: 사용자가 스크롤한 위치를 나타냅니다.\n\n명확히 이해하기 위해 예제를 드리겠습니다:\n\n\n\n먼저, NextJS와 TypeScript를 사용하여 소스 코드를 초기화하고, 익숙한 다른 프레임워크를 사용할 수도 있어요.\n\n다음으로 각각 높이가 500px인 `div`를 3개 추가할 거에요.\n\n<img src=\"/assets/img/2024-05-12-Detectscrollreachesthebottom_0.png\" />\n\n이렇게 하면 전체 콘텐츠의 높이가 1500px가 됩니다.\n\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*Qocsql64DWbgFLXBqug2SA.gif)\n\n윈도우 높이를 500px로 조정하면 다음과 같이 됩니다:\n\n![이미지](/assets/img/2024-05-12-Detectscrollreachesthebottom_1.png)\n\ninnerHeight는 빨간색 상자 영역이고, outerHeight에는 주소 표시줄과 탭 표시줄이 포함됩니다.\n\n\n\n좋아요, 이제 document.body.scrollHeight와 window.innerHeight를 확인할 거예요.\n\n그럼 이제 scrollY를 확인해볼게요.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*tSttaLTndCd9JLMhdbz29A.gif)\n\n동영상을 보시면 알 수 있지만, 페이지에 처음 접속했을 때 scrollY 값은 0일 거에요. 왜냐하면 아직 스크롤하지 않았기 때문이죠. 그런 다음 페이지를 스크롤하기 시작하면, 스크롤한 거리에 따라 scrollY 값이 적절하게 변경될 거에요.\n\n\n\n그리고 페이지를 맨 아래로 스크롤하면 scrollY = scrollHeight - innerHeight가 됩니다.\n\n아래는 해당하는 공식입니다.\n\n```js\nconst scrolledTo = window.scrollY + window.innerHeight\nconst isReachBottom = document.body.scrollHeight === scrolledTo\n```\n\n이제 한번 시도해 봅시다!\n\n\n\n```js\nuseEffect(() => {\n    const onscroll = () => {\n        const scrolledTo = window.scrollY + window.innerHeight;\n        const isReachBottom = document.body.scrollHeight === scrolledTo;\n        if (isReachBottom) alert(\"맨 아래에 도달했습니다!\");\n    };\n    window.addEventListener(\"scroll\", onscroll);\n    return () => {\n        window.removeEventListener(\"scroll\", onscroll);\n    };\n}, []);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*Vv4q8HBbBSC6n32NRV97cQ.gif\" />\n\n좋아요! 작동합니다!\n\n하지만 무한 스크롤을 위해 직장에서 사용하면 좋은 방법은 아닙니다. 스크롤이 맨 아래에 도달할 때까지 API를 호출하는 것은 좋지 않습니다. 이렇게 하면 사용자 경험이 나빠집니다. 대신, 스크롤이 맨 아래에서 일정 거리(예: 맨 아래에서 300px)를 벗어나면 API 호출을 트리거하고 새 콘텐츠가 로드되어 문서에 추가됩니다. 이렇게 하면 사용자가 기다리는 시간이 줄어듭니다.\n\n\n\n\n위의 공식은 다음과 같습니다:\n\n```js\nconst scrolledTo = window.scrollY + window.innerHeight\nconst threshold = 300\nconst isReachBottom = document.body.scrollHeight - threshold === scrolledTo\n```\n\n잘 보이지만 여기 작은 문제가 있어요. 사용하는 것이 있습니다. 동등성 연산자 ===을 사용하면 scrollY가 사용자가 스크롤할 때마다 1픽셀씩 증가하지 않기 때문에 isReachBottom이 여러 번 false가 될 가능성이 높습니다. 사용자가 얼마나 빨리 스크롤하는지에 따라 달라집니다.\n\n이 문제를 해결하려면 `(=`를 사용하면 됩니다:\n\n\n\n```js\nconst isReachBottom = document.body.scrollHeight - threshold <= scrolledTo\n```\n\n좋아요, 새로운 것을 테스트해볼까요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*d6GdJZpt4RNPfe-03diBfQ.gif)\n\n좋아요, 성공했어요!\n\n\n\n이제 스크롤이 맨 아래에 도달하는 방법을 배웠어요!\n\n데모 코드는 여기에서 확인할 수 있어요: [https://github.com/alanng2050/medium-demo-scroll-to-bottom](https://github.com/alanng2050/medium-demo-scroll-to-bottom)\n\n읽어 주셔서 감사합니다!\n\n즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-Detectscrollreachesthebottom_0.png"},"coverImage":"/assets/img/2024-05-12-Detectscrollreachesthebottom_0.png","tag":["Tech"],"readingTime":3},{"title":"Next Js 13 프로젝트에서 Redux Tool Kit을 구성해 보세요","description":"","date":"2024-05-12 21:42","slug":"2024-05-12-ConfigureReduxToolKitinNextJs13project","content":"\n\n<img src=\"/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_0.png\" />\n\n안녕하세요! 이 글에서는 Next Js 13 프로젝트에 Redux Tool kit (RTK)을 설정하는 단계별 프로세스를 안내해 드리겠습니다. Redux Tool kit은 React/Next Js 애플리케이션에서 상태를 전역적으로 관리하는 데 도움이 되는 도구 세트입니다. Next Js 13의 릴리스 이후로, Redux Tool kit을 Next 13 앱에 통합하는 데 도움이 되는 문서가 부족합니다. 이 글이 여러분이 읽으면서 기대하는 만족도를 높여드릴 것을 희망합니다.\n\n프로젝트 설정 및 설치\n\n이미 Next 13 프로젝트를 설정했고 상태를 관리하기 위해 redux tool kit을 통합할 준비가 되어 있다고 가정합니다. 만약 제 가정이 틀렸다면, 항상 그런 경우이니까 Next js를 설치하는 방법은 여기를 참조하세요.\n\n\n\nRedux 도구 킷을 앱에 통합하기 위해 먼저 필요한 라이브러리를 설치해야 합니다.\n\n```js\n// Redux 도구 킷과 리액트 리덕스 설치\nnpm install @reduxjs/toolkit react-redux\n```\n\nRedux 도구 킷과 리액트 리덕스는 앱을 실행시키고 전역 상태를 관리할 준비를 완료하는 데 필요한 라이브러리입니다.\n\n그다음, Next 앱 프로젝트 구조를 설정해야 합니다. src/app 폴더 안에 GlobalRedux라는 새 폴더를 만들고, GlobalRedux 폴더 안에 store.js와 provider.js라는 두 파일을 만들어야 합니다. 또한, 슬라이스에 관련된 모든 파일을 담을 Features라는 폴더를 생성해야 합니다. 간단하고 최소한의 구조를 유지하기 위해 하나의 슬라이스만 생성하겠습니다. 그것을 counterSlice.js라고 이름 짓겠습니다. JavaScript 파일에 확장자로 .jsx 또는 .js 중 하나를 선택할 수 있습니다. 이제 프로젝트 구조는 다음과 같아야 합니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_1.png\" />\n\n## 슬라이스 구성\n\n슬라이스란 당신의 앱에서 하나의 기능에 대한 Redux 리듀서 로직과 액션들의 모음을 나타냅니다. 일반적으로 한 파일에 정의되어 있습니다. 코드를 자세히 살펴보기 전에 중요한 점을 알려드릴게요. 모든 파일은 클라이언트 측 컴포넌트입니다. 파일의 맨 위에 'use client'를 추가해야 합니다. 이제 방금 만든 각 파일에 코드를 추가해 보겠습니다. 먼저 counterSlice.jsx 파일을 구성해야 합니다. 이 파일은 컴포넌트의 상태를 변경하기 위해 실행해야 하는 코드를 가져옵니다.\n\n```js\n//counterSlice.jsx\n\n\"use client\"; // 이것은 클라이언트 측 컴포넌트입니다.\n\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst initialState = {\n  value: 0,\n};\n\nexport const counterSlice = createSlice({\n  name: \"counter\",\n  initialState,\n  reducers: {\n    increment: (state) => {\n      state.value += 1;\n    },\n    decrement: (state) => {\n      state.value -= 1;\n    },\n    incrementByAmount: (state, action) => {\n      state.value += action.payload;\n    },\n  },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\n\nexport default counterSlice.reducer;\n```\n\n\n\n위 파일에서는 카운터 버튼을 증가 및 감소하는 논리를 간단히 작성하고 있습니다.\n\n## 저장소 설정\n\n이제 Redux-tool-kit 저장소를 설정해 봅시다. Redux 저장소는 애플리케이션의 모든 상태를 저장하는 중심적인 버킷입니다. 애플리케이션 상태에 대한 단일 진실의 원천으로 고려되고 유지되어야 합니다.\n\n```js\n//store.jsx\n\n\"use client\";\nimport { combineReducers, configureStore } from \"@reduxjs/toolkit\";\nimport counterReducer from \"./Features/Counter/counterSlice\";\n\n\nconst rootReducer = combineReducers({\n  counter: counterReducer,\n  // 여기에 모든 리듀서를 추가하세요\n}, );\n\nexport const store = configureStore({\n  reducer: rootReducer,\n});\n```\n\n\n\n저희 store.js가 작동 중이니, 앱에 상태 변화가 전역 변수로 캡처되도록 스토어를 제공해야 합니다. 이것이 대부분의 자습서에서 빠뜨리는 가장 중요한 부분이에요.\n\n## 사용자 지정 프로바이더 구성\n\nNext.js와 Redux 툴킷을 설정할 때, provider.js라는 별도의 파일을 만들어야 합니다. `Provider` 컴포넌트는 Redux 스토어를 Redux 스토어에 액세스해야 하는 중첩된 모든 컴포넌트에 사용할 수 있게 합니다. provider.js 파일을 설정해봅시다.\n\n```js\n//provider.js\n\"use client\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./store\";\n\nexport function Providers({ children }) {\n  return <Provider store={store}>{children}</Provider>;\n}\n```\n\n\n\n대부분의 리액트 앱에서 제공 엘리먼트를 직접적으로 Next 애플리케이션의 루트에 감싸지 않는다는 점에 주목하게 될 거예요. 대신 여러분이 만든 별도의 제공자 컴포넌트인 Providers를 생성하고, 이를 애플리케이션의 루트를 감싸기 위해 내보낼 거예요. 이는 이번 경우인 메인 레이아웃인 layout.jsx 파일이 서버 측 렌더링된 컴포넌트이지만, Next.js 제공자 컴포넌트는 클라이언트 측으로 렌더링되어야 하기 때문이에요. 만약 여러분이 이 규칙을 어긴다면 버그가 발생할 수 있으니 참고하세요. 앱을 직접적으로 제공자로 감싸는 것이 아니라 적용하는 것을 시도해보면 문제점을 보실 수 있을 거예요.\n\n## 앱 루트를 제공자로 감싸기\n\n마지막으로, 방금 만든 사용자 지정 제공자 컴포넌트로 앱을 감싸야 합니다. 이 단계도 주의깊게 살펴주세요. 리액트 애플리케이션과 달리, Next.js 13에는 app.js라는 특별한 루트 앱이 없는데요. 그래서 Next 13 앱의 주요 시작점은 여러분의 layout.js 파일입니다. 우리가 만든 사용자 지정 제공자를 가져와서 layout.jsx 파일의 자식 요소들을 감싸게 될 거에요. layout.js 파일의 자식 요소들은 여러분의 앱의 모든 페이지들이라는 뜻이에요. 이제 앱의 모든 상태를 하나의 저장소에서 관리하고 있습니다.\n\n```js\n//layout.js\nimport { Providers } from \"./GlobalRedux/provider\";\nimport \"./globals.css\";\nimport styles from \"./page.module.css\";\n\nexport const metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\nconst RootLayout = ({ children }) => {\n  return (\n    <html lang=\"en\">\n      <head className={styles.header}></head>\n      <body>\n        {/* 사용자 지정 제공자 컴포넌트를 가져오세요 */}\n        <Providers>{children}</Providers>\n      </body>\n    </html>\n  );\n};\nexport default RootLayout;\n```\n\n\n\n지금까지 계속 참고해 왔다면, 멋진 일을 했어요. 이제 커피 한 잔을 마실 시간이에요.\n\n마지막 단계가 하나 남았어요. 우리 앱에 저장된 상태에 접근하고 만든 컴포넌트 내에서 사용해야 해요. 이를 위해 useDispatch와 selector 훅을 사용할 거에요. react-redux에서 useDispatch 훅은 우리에게 스토어의 디스패치 메소드에 액세스할 수 있게 해줘요. 디스패치는 우리가 리덕스 스토어로 액션을 보내는 데 사용되며 컴포넌트 내에서 스토어에 영향을 주는 유일한 방법이에요. \"선택자 함수\"는 리덕스 스토어 상태(또는 상태의 일부)를 인수로 받고 그 상태에 기반한 데이터를 반환하는 어떠한 함수라고 할 수 있어요. 말이 많아졌네요, 이제 useDispatch와 selector가 어떻게 사용되어 앱 상태에 액세스할 수 있는지 보겠습니다.\n\n```js\n//page.jsx\n\n//기본적으로, 이는 저장된 상태에 액세스하거나 컴포넌트 상태로 스토어를 업데이트하는 방법입니다.\n\n\"use client\";\n\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { increment, decrement } from \"./GlobalRedux/Features/counter/counterSlice\";\n\n\nexport default function Home() {\n//useSelector를 통해 스토어로부터 상태 가져오기\n  const count = useSelector((state) => state.counter.value); // 카운터 상태에 액세스\n\n//useDispatch는 컴포넌트에서 스토어를 상태로 업데이트하는 데 사용되며, counterslice.js 내에서 정의된 로직에 따라 정의됩니다\n  const dispatch = useDispatch();\n\n  return (\n    <div>\n      <h1>Counter: {count}</h1> {/* 카운터 상태 표시 */}\n      <button onClick={() => dispatch(increment())}>증가</button>\n      <button onClick={() => dispatch(decrement())}>감소</button>\n    </div>\n  );\n}\n```\n\n위 파일에서 우리는 간단히 컴포넌트 내에서 스토어 상태의 값을 가져오고 싶었어요. page.jsx 파일에서 카운터를 생성하고 감소 또는 증가하는 두 개의 버튼을 만들었어요. useSelector 메소드를 사용하여 스토어의 카운터 값에 액세스할 수 있었죠. 사용자가 증가 또는 감소 버튼을 클릭했을 때 우리의 스토어를 업데이트하기 위해, useDispatch 메소드를 실행하여 컨터스라이스.jsx에 정의된 로직을 실행해요. 이 경우에는 간단히 스토어에서 카운터 값을 증가/감소시키는 로직이었습니다.\n\n\n\n## 결론\n\n끝까지 참고해 주셔서 축하드립니다. 다음 JS 13 앱에 Redux 툴킷을 설정할 수 있었으면 좋겠네요. 이 글이 마음에 드셨다면 좋아요를 눌러주세요.","ogImage":{"url":"/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_0.png"},"coverImage":"/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 모달 컴포넌트에서 포커스 트래핑 구현하기","description":"","date":"2024-05-12 21:41","slug":"2024-05-12-AchievingFocusTrappinginaReactModalComponent","content":"\n<img src=\"/assets/img/2024-05-12-AchievingFocusTrappinginaReactModalComponent_0.png\" />\n\n포커스 포획은 웹 개발에서 필수적인 기술로, 모달이나 대화 상자와 같은 특정 영역 내에서 키보드 포커스가 유지되어 사용자에 대한 접근성과 사용 편의성을 향상시킵니다. 이 글에서는 외부 라이브러리에 의존하지 않고 사용자 정의 React 모달 구성 요소에서 포커스 포획을 구현하는 방법을 살펴보겠습니다.\n\n# 포커스 포획 이해하기\n\nReact에서 모달 구성 요소를 설계하는 과정에는 여러 가지 고려 사항이 포함됩니다. 이러한 고려 사항 중 하나는 적절한 포커스 관리를 보장하는 것입니다. 포커스 포획은 이 프로세스에서 중요한 역할을 하는 기술입니다.\n\n모달이 열린 상태에서는 모달 자체의 경계 내에서 키보드 포커스가 제한되는 것이 중요합니다. 이렇게 함으로써 사용자가 실수로 모달 외부의 요소인 버튼, 링크 또는 폼 입력란과 같은 요소로 이동하는 것을 방지할 수 있습니다.\n\n이 예시에서 사용자가 샌드박스 환경을 벗어나 탭 키로 브라우저 내의 다른 포커스 가능한 요소에 의도치 않게 도달하는 것을 확인할 수 있습니다.\n\n포커스 강제로 구현함으로써 사용자가 키보드만 사용하여 모달 콘텐츠와 효율적으로 상호 작용할 수 있는 제어된 환경을 만들어냅니다. 이를 통해 전반적인 사용자 경험과 애플리케이션의 접근성을 향상시킬 수 있습니다.\n\n포커스 트래핑은 모달 내에서 포커스 순서를 조작하고 특정 키보드 이벤트를 가로채어 구현됩니다. 포커스 순서를 관리하여 사용자가 상호 작용 요소를 탐색하기 위해 \"Tab\" 키를 누를 때, 포커스는 모달 내에 유지되고 포커스 가능한 요소 사이를 순환하게 됩니다.\n\n또한, 포커스 트래핑은 특정 키보드 이벤트를 가로채어 특별한 상황을 처리하는 것을 포함합니다. 예를 들어, 사용자가 모달 내의 마지막 포커스 가능한 요소에 도달하고 계속 \"Tab\" 키를 누르는 경우, 포커스가 첫 번째 요소로 순환되어 원활한 순환 네비게이션 경험을 만들어야 합니다.\n\n또 다른 일반적인 시나리오는 모달을 닫기 위해 \"Escape\" 키 입력을 처리하는 것입니다. 모달이 열려 있고 사용자가 \"Escape\" 키를 누르면 모달이 닫혀야 하며, 포커스는 모달을 열었던 요소로 돌아가야 합니다.\n\n우리의 사용자 정의 React 모달 컴포넌트에서는 useRef와 useEffect 훅의 조합을 사용하여 포커스 트래핑을 구현할 것입니다. 모달 요소에 ref를 할당함으로써 해당 요소의 포커스 관련 속성에 액세스하고 조작할 수 있습니다. useEffect 훅을 사용하여 모달이 열린 상태에서 키보드 이벤트에 대한 이벤트 리스너를 설정하고 필요한 포커스 조작을 수행할 수 있습니다.\n\n모달 컴포넌트 내에서 포커스 관리를 하는 것으로, 원활하고 직관적인 사용자 경험을 만들어냅니다. 우리가 구현 중인 포커스 포획 논리 덕분에 키보드 사용자들은 예상치 못한 포커스 변화나 중단 없이 모달 컴포넌트의 콘텐츠를 탐색하고 상호작용할 수 있습니다.\n\n# 모달 컴포넌트 구성\n\nReact 모달에서 포커스 포획을 보여주기 위해, 우리는 사용자 정의 Modal 컴포넌트를 만들 것입니다. 포커스 포획 논리만을 보여주기 위해, 이 컴포넌트는 최소한의 스타일로 구현될 것입니다.\n\n다음 섹션에서는 우리의 사용자 정의 React 모달 컴포넌트의 구현 세부 사항에 대해 살펴보고 포커스 포획을 어떻게 달성하는지 탐구할 것입니다.\n\n# 포커스 트래핑 구현\n\n모달 컴포넌트에서는 useEffect 훅을 사용하여 모달이 열릴 때 포커스 트래핑을 관리합니다. 구현을 단계별로 살펴보면 다음과 같습니다:\n\n- useRef 훅을 사용하여 modalRef를 정의하여 모달 요소를 참조합니다. 이 컴포넌트는 isOpen 및 setIsOpen 두 가지 props을 받습니다. 자식 요소는 boolean인 isOpen prop에 따라 표시됩니다. 이 boolean 상태의 setter 함수는 setIsOpen prop입니다.\n\n```js\nconst Modal = ({ isOpen, setIsOpen }) => {\n  const modalRef = useRef(null);\n};\n```\n\n- 다음 단계는 Modal 컴포넌트 내부에 useEffect 훅을 정의하는 것입니다. 그런 다음 isOpen 속성이 true인지 확인합니다. 자식 요소는 boolean isOpen 속성에 따라 표시됩니다. 이 값이 true이면 포커스 트랩 설정을 진행합니다.\n\n```js\nuseEffect(() => {\n  if (isOpen) {\n    //...설정\n  }\n}, [isOpen]);\n```\n\n- 이 설정에서는 모달 내부의 모든 포커스 가능한 요소를 querySelectorAll 메서드를 사용하여 쿼리합니다. 이에는 버튼, 링크, 입력란, 선택란, 텍스트영역, 명시적 tabindex 값을 가진 요소가 포함됩니다. 조심스럽게 MDN 웹 문서 HTML 요소 참조를 확인하여 이 목록에 포함해야 할지 여부를 확인하십시오.\n\n```js\nconst modalElement = modalRef.current;\nconst focusableElements = modalElement.querySelectorAll(\n  'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n);\n```\n\n- 우리는 첫 번째 및 마지막 초점 대상 요소를 각각 firstElement 및 lastElement 변수에 저장합니다.\n\n```js\nconst firstElement = focusableElements[0];\nconst lastElement = focusableElements[focusableElements.length - 1];\n```\n\n- 우리는 두 개의 이벤트 핸들러 함수를 정의합니다: handleTabKeyPress와 handleEscapeKeyPress. 전자는 \"Tab\" 키를 누를 때 원형 탐색을 모달 내에서 가능하게 하고, 후자는 \"Escape\" 키를 눌러 모달을 닫도록 setIsOpen 함수를 호출합니다.\n- event.shiftKey 조건은 \"Shift\" 키가 \"Tab\" 키와 함께 눌렸는지 여부를 결정하는 데 사용됩니다. 이 조건은 모달 내에서의 원형 초점 탐색을 처리하는 데 도움이 됩니다.\n- handleTabKeyPress 이벤트 핸들러는 \"Tab\" 키가 눌렸을 때 트리거됩니다. event.shiftKey 속성은 \"Shift\" 키가 이벤트와 동시에 눌렸는지 여부를 나타내는 부울 값입니다.\n- \"Shift\" 키가 눌렸고 (event.shiftKey가 true이고 현재 초점이 맞춰진 요소가 첫 번째 초점 요소인 경우(document.activeElement === firstElement)), 사용자가 첫 번째 요소에서 역방향으로 탐색 중임을 의미합니다. 이 경우, 모달을 벗어나지 않으려고 기본 탭 동작이 방지됩니다 (event.preventDefault()), 초점은 마지막 초점 대상 요소로 설정됩니다 (lastElement.focus()). 이렇게 하면 모달 내에서 원형 초점 탐색이 생성됩니다.\n- \"Shift\" 키가 눌리지 않았고 (event.shiftKey가 false이고 현재 초점이 마지막 초점 요소인 경우(document.activeElement === lastElement)), 사용자가 마지막 요소에서 앞으로 탐색 중임을 의미합니다. 마찬가지로, 기본 탭 동작이 방지되고 초점은 첫 번째 초점 요소로 설정됩니다 (firstElement.focus()), 모달 내에서 원형 탐색이 계속됩니다.\n- event.shiftKey 조건을 사용하여, \"Tab\" 키를 단독 또는 \"Shift\" 키와 함께 누를 때 모달의 초점 대상 요소 내에서 정상적으로 전진 및 후진 탐색이 작동하도록 로직이 보장됩니다.\n\n```js\nconst handleTabKeyPress = (event) => {\n  if (event.key === \"Tab\") {\n    if (event.shiftKey && document.activeElement === firstElement) {\n      event.preventDefault();\n      lastElement.focus();\n    } else if (!event.shiftKey && document.activeElement === lastElement) {\n      event.preventDefault();\n      firstElement.focus();\n    }\n  }\n};\n\nconst handleEscapeKeyPress = (event) => {\n  if (event.key === \"Escape\") {\n    setIsOpen(false);\n  }\n};\n```\n\n- addEventListener를 사용하여 모달 요소에 이벤트 리스너를 추가합니다. 그런 다음 useEffect 훅은 isOpen 또는 setIsOpen이 변경될 때마다 실행되도록 설정해야 합니다. isOpen이 변경될 때마다 효과가 다시 트리거됩니다. 그러나 효과 내부의 코드는 isOpen의 값에 따라 이벤트 리스너를 추가하거나 제거하기만 합니다. isOpen 상태 자체를 직접 수정하지는 않습니다.\n- 의존성 배열에 해당 상태가 포함된 useEffect 훅 내에서 isOpen 상태를 수정하는 것은 문제가 발생할 수 있습니다. 훅은 관찰 중인 의존성 중 하나가 변경될 때 관련 컴포넌트를 다시 렌더링하도록 강제합니다. 따라서 무한한 재렌더링 루프를 트리거할 수 있습니다. 무한한 재렌더링 루프를 방지하는 주요 요소는 효과가 isOpen 상태에 따라 이벤트 리스너를 추가하거나 제거하지만 isOpen 상태 자체를 수정하지 않는다는 것입니다. 따라서 실행될 때 컴포넌트의 다시 렌더링을 트리거하지 않습니다.\n\n```js\nmodalElement.addEventListener(\"keydown\", handleTabKeyPress);\nmodalElement.addEventListener(\"keydown\", handleEscapeKeyPress);\n```\n\n- useEffect 훅에서 반환된 클린업 함수 내에서 이벤트 리스너를 제거하여 메모리 누수를 방지합니다.\n\n```js\nreturn () => {\n  modalElement.removeEventListener(\"keydown\", handleTabKeyPress);\n  modalElement.removeEventListener(\"keydown\", handleEscapeKeyPress);\n};\n```\n\n모달 컴포넌트의 최종 버전입니다:\n\n```js\nimport React, { useRef, useEffect } from \"react\";\n\nconst Modal = ({ isOpen, setIsOpen }) => {\n  const modalRef = useRef(null);\n\n  useEffect(() => {\n    if (isOpen) {\n      const modalElement = modalRef.current;\n      // 포커스 가능한 HTML 요소를 포함하고 싶다면 이 문자열에 추가하세요\n      const focusableElements = modalElement.querySelectorAll(\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n      );\n      const firstElement = focusableElements[0];\n      const lastElement = focusableElements[focusableElements.length - 1];\n\n      const handleTabKeyPress = (event) => {\n        if (event.key === \"Tab\") {\n          if (event.shiftKey && document.activeElement === firstElement) {\n            event.preventDefault();\n            lastElement.focus();\n          } else if (!event.shiftKey && document.activeElement === lastElement) {\n            event.preventDefault();\n            firstElement.focus();\n          }\n        }\n      };\n\n      const handleEscapeKeyPress = (event) => {\n        if (event.key === \"Escape\") {\n          setIsOpen(false);\n        }\n      };\n\n      modalElement.addEventListener(\"keydown\", handleTabKeyPress);\n      modalElement.addEventListener(\"keydown\", handleEscapeKeyPress);\n\n      return () => {\n        modalElement.removeEventListener(\"keydown\", handleTabKeyPress);\n        modalElement.removeEventListener(\"keydown\", handleEscapeKeyPress);\n      };\n    }\n  }, [isOpen, setIsOpen]);\n\n  return isOpen ? (\n    <div className=\"modal\" ref={modalRef}>\n      <div className=\"modal__box\">\n        <span>Tab 키를 눌러 자식 요소들 사이로 포커스를 이동하세요. Esc 키를 눌러 모달을 닫을 수 있습니다.</span>\n        <a className=\"modal__box__children\" href=\"www.google.com\">\n          링크\n        </a>\n        <button className=\"modal__box__children\">모달 버튼</button>\n        <input className=\"modal__box__children\"></input>\n        <span className=\"modal__box__children\" tabIndex=\"0\">\n          포커스 가능한 텍스트\n        </span>\n      </div>\n    </div>\n  ) : (\n    <></>\n  );\n};\n\nexport default Modal;\n```\n\n마침내, 포커스 트래핑을 구현하여 사용자가 모달 외부로 의도치 않게 이동하지 않도록 보장합니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*9jPfh_LYgjYCEKWBTcORow.gif\" />\n\n# 결론\n\n이 기사에서는 사용자 정의 React 모달 구성 요소에서 초점 포착을 어떻게 달성하는지 살펴보았습니다. 모달 내에서 초점을 적절하게 관리함으로써 응용 프로그램의 접근성과 사용성을 향상시킬 수 있습니다. 기술의 기본 원리를 이해하고 코드에 구현함으로써, 더 견고하고 사용자 친화적인 응용 프로그램을 개발할 수 있습니다.\n\n이 기사에서 만든 모달 구성 요소의 완전한 코드는 CodeSandbox 데모에서 찾을 수 있습니다.\n\n필요한 초점 포착 로직을 처리하는 외부 라이브러리가 있더라도, 내부 로직을 이해하고 도움말 확인을 직접 만드는 것이 중요하다고 생각합니다. 그러나 특정 필요에 대한 외부 라이브러리를 구현하는 것도 많은 시간을 절약할 수 있습니다. 각 구현 결정의 장단점을 따져 현명하게 작업하는 것이 현명합니다.\n\nOne of those external solutions is the accessibility-focused open-source library CactusUI where focus trapping is handled within the FocusTrap component. You may find the source code in the following repository.\n\n![Focus Trap Component](/assets/img/2024-05-12-AchievingFocusTrappinginaReactModalComponent_1.png)\n\nRemember, focus trapping is just one aspect of creating accessible modal components. It’s essential to consider other accessibility practices, such as screen reader compatibility, keyboard navigation, and ARIA attributes, to ensure an inclusive experience for all users.\n\n# 소셜미디어\n\n# Github\n\n# Linkedin\n\nOgun Akar — 프론트엔드 개발자 @ ÇSTech\n\n# 참고문헌\n","ogImage":{"url":"/assets/img/2024-05-12-AchievingFocusTrappinginaReactModalComponent_0.png"},"coverImage":"/assets/img/2024-05-12-AchievingFocusTrappinginaReactModalComponent_0.png","tag":["Tech"],"readingTime":9}],"page":"134","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}