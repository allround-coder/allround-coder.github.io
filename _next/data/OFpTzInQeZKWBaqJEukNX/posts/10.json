{"pageProps":{"posts":[{"title":"OpenAI 기능 호출로 훈련 데이터 생성하는 방법","description":"","date":"2024-06-23 13:54","slug":"2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling","content":"\n\n<img src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png\"/>\n\n머신 러닝과 인공 지능 분야에 파묻혀들면 준비 데이터의 품질이 중요하다는 것을 알 수 있어요. 1만 개의 텍스트나 이미지에 레이블을 붙이는 등의 훈련 데이터를 생성하는 것은 지루한 작업일 수 있어요. 하지만 OpenAI 모델을 사용하면 이 과정을 자동화할 수 있답니다. OpenAI 모델은 우리 모델을 위해 구체적인 훈련 또는 세밀한 조정 데이터를 생성할 수 있어요. 이 블로그 글에서는 이 작업이 어떻게 이루어지는지에 대해 살펴볼 거에요.\n\n(그런데 GPT가 밈을 생성할 수 있다는 거 알고 계셨나요?)\n\n<img src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_1.png\"/>\n\n<div class=\"content-ad\"></div>\n\n# 왜 이 기능을 사용해야 하나요?\n\nOpenAI의 가장 유용한 기능 중 하나는 함수 호출입니다. 사전 정의된 스키마로 함수를 호출할 수 있어 일관성을 보장합니다. 훈련 데이터를 생성할 때 이 일관성은 중요합니다. 예를 들어, 대부분의 레이블 값은 사전 정의된 옵션 세트를 따르는 스키마를 가져야 합니다. 또한 이러한 함수에 로직을 추가하여 깨끗하고 일관된 데이터를 처리하고 이를 데이터베이스나 CSV 파일에 저장하는 등의 작업을 수행할 수 있습니다.\n\n# 나의 동기\n\n최근 개발한 사이드 프로젝트에서 인공지능 기능이 탑재된 RSS 리더를 만들었습니다.\n하나의 기능은 게시물 내용을 \"긍정적\", \"부정적\", \"중립적\"으로 분류하는 것입니다. 이를 통해 사용자들은 원할 경우 부정적인 게시물을 걸러낼 수 있습니다. 많은 모델이 잘 수행하는 것을 찾았지만, 저는 RSS 피드 데이터로 하나를 세밀하게 조정하여 정확도를 개선하려고 합니다. 그러나 사용자 정의 레이블로 더 고급 감정 분류기를 생성하려면 직접 훈련 데이터셋을 만들고 모델을 훈련해야 합니다. 기존 모델을 사용하든 새로 생성하든, 고품질의 훈련 데이터가 필요합니다. 이것이 저가 고안한 다음 방법을 찾은 이유입니다.\n\n<div class=\"content-ad\"></div>\n\n# OpenAI를 사용하여 데이터 라벨링하기\n\n먼저 데이터를 수집하세요. 이 데이터를 사용하여 라벨링하거나 새로운 머신러닝 특성을 추가하여 세밀하게 조정된 데이터셋을 만들 수 있습니다. 이 간단한 가이드를 참고해보세요:\n\nOpenAI에 적절한 컨텍스트 제공하기:\n\n- 명확한 시스템 프롬프트 추가, 예: \"제공된 데이터에 라벨을 지정하는 것이 여러분의 작업입니다.\"\n- 프롬프트에 데이터 컨텍스트 포함, 예: \"이 블로그 게시물에 `blog post content...` 라벨을 추가하세요.\"\n\n<div class=\"content-ad\"></div>\n\n오픈에이아이(Function Schema)에 대한 기능 스키마를 작성해주세요:\n\n- 도구에 대한 자세한 설명을 제공해주세요.\n- 응답을 제한하기 위해 enum 및 다른 스키마 요소를 사용하여 매개변수를 명확히 정의해주세요.\n\n스키마에 의해 정의된 함수를 작성해주세요:\n\n- 이 기능은 데이터를 처리하거나 저장하거나 다른 작업을 수행할 수 있습니다. 제 경우에는 훈련 데이터 CSV 파일에 새로운 행을 추가하여 새로운 훈련 요소를 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 단계를 따르면 데이터를 정확하고 일관되게 레이블링하여 모델 훈련에 사용할 수 있습니다.\n\n# 간단한 코드 예제 살펴보기\n\n여기 텍스트 레이블링 도구의 간단한 예제가 있습니다. 이것보다 훨씬 복잡한 작업도 할 수 있지만, 복잡한 ML 피처를 생성하거나 이미지 인식 또는 텍스트 음성 변환 피처를 활용하는 등의 작업도 가능합니다. 하지만 명확하게 하기 위해 이 예제를 선택했습니다:\n\n이 예제에서는 어떤 텍스트에 [`긍정적`, `부정적`, `중립적`] 중 하나의 레이블을 추가하고 해당 결과를 CSV 파일에 작성하여 나준에 모델을 가르치거나 세부 조정할 수 있도록 했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {ITool, ToolSchema} from './interfaces/tool.interface';\nimport {ToolUtils} from \"../utils/tool-utils\";\nimport * as path from 'path';\nimport {createObjectCsvWriter as createCsvWriter} from 'csv-writer';\n\nexport class LabelTool implements ITool<string[], { inputText: string }> {\n    private csvWriter;\n\n    constructor(private readonly labels: string[] = ['positive', 'negative', 'neutral'], private readonly csvFilePath: string = path.join('labeled_text.csv')) {\n        this.csvWriter = createCsvWriter({\n            path: this.csvFilePath,\n            header: [\n                {id: 'label', title: 'Label'},\n                {id: 'text', title: 'Text'},\n            ],\n            append: true\n        });\n    }\n\n    // 해당 도구를 사용하여 OpenAI에 요청을 생성하고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n    async callback(\n        options: { label: string },\n        ctx: { inputText: string },\n    ): Promise<any> {\n\n        // 새로운 레이블이 지정된 데이터 행을 csv에 작성합니다.\n        await this.csvWriter.writeRecords([{\n            label: options.label,\n            text: ctx.inputText\n        }]);\n\n        console.log(`CSV 행 추가됨: ${options.label} | ${ctx.inputText}`);\n\n        return `레이블이 성공적으로 추가되었습니다: ${options.label}`;\n    }\n\n    // JSON 스키마에 대해 더 알아보려면 여기를 방문하세요 https://json-schema.org/learn/getting-started-step-by-step\n    async getSchema(ctx: { inputText: string }): Promise<ToolSchema> {\n\n        // 이는 LLM을 위한 제공된 스키마입니다.\n        return {\n            type: 'function',\n            function: {\n                name: 'set_label',\n                description: '텍스트에 레이블 설정',\n                function: ToolUtils.getToolFn(this, ctx),\n                parse: JSON.parse,\n                parameters: {\n                    type: 'object',\n                    properties: { // 이 속성들은 콜백 \"options\" 매개변수에 있을 것입니다\n                        label: {\n                            type: 'string',\n                            description: '입력 텍스트의 레이블',\n                            enum: this.labels // 가능한 문자열을 제한합니다\n                        },\n                    },\n                },\n            },\n        };\n    }\n}\n```\n\n이 도구를 사용하면 OpenAI에 요청을 보내고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n```js\nimport OpenAI from \"openai\";\nimport {LabelTool} from \"./tools/label.tool\";\nrequire('dotenv').config()\n\nconst client = new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY,\n});\n\n(async () => {\n    const inputTexts = [ // OpenAI 모델이 이를 ['positive', 'negative', 'neutral']로 레이블링합니다\n        \"이 제품을 사랑해요!\",\n        \"이게 내가 산 것 중에 가장 최악이에요.\",\n        \"괜찮아요, 유난히 좋진 않지만 나쁘진 않아요.\",\n        \"돈 안 아깝다고.\",\n        \"최고의 구매!\",\n    ];\n\n    for (const inputText of inputTexts) {\n        console.debug(`프롬프트: 이 텍스트에 레이블을 부여하세요: ${inputText}`);\n\n        const tool = new LabelTool(['positive', 'negative', 'neutral']);\n        const context = { inputText: inputText };\n        const prompt = `이 텍스트에 레이블을 부여하세요: ${inputText}`;\n        const system = '훈련 데이터 생성을 돕는 유용한 도우미입니다.';\n\n        const runner = client.beta.chat.completions.runTools({\n            model: 'gpt-3.5-turbo',\n            messages: [\n                {\n                    role: 'system',\n                    content: system,\n                },\n                {\n                    role: 'user',\n                    content: prompt,\n                },\n            ],\n            tools: [await tool.getSchema(context)],\n            tool_choice: 'auto', // 'auto' 대신 tool_choice: {function: {name: ...}를 전달하면 해당 함수를 호출한 후 즉시 반환됩니다\n        });\n\n        const finalContent = await runner.finalContent();\n        console.log(`AI 응답: ${finalContent}\n        `);\n    }\n})();\n```\n\n로그 결과:\n\n\n<div class=\"content-ad\"></div>\n\n\nPrompt: 이 텍스트를 라벨링하세요: 나는이 제품을 좋아해요!\nCSV 행 추가: 긍정적 | 나는이 제품을 좋아해요!\nAI 응답: \"나는이 제품을 좋아해요!\" 텍스트가 긍정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 이건 내가 산 것 중 가장 최악입니다.\nCSV 행 추가: 부정적 | 이건 내가 산 것 중 가장 최악입니다.\nAI 응답: \"이건 내가 산 것 중 가장 최악입니다.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nCSV 행 추가: 중립 | 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nAI 응답: \"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\" 텍스트가 중립으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 가치가 없어요.\nCSV 행 추가: 부정적 | 가치가 없어요.\nAI 응답: \"가치가 없어요.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 최고의 구매!\nCSV 행 추가: 긍정적 | 최고의 구매!\nAI 응답: \"최고의 구매!\" 텍스트가 긍정적으로 라벨링되었습니다.\r\n\n\r\nCSV 파일:\r\n\r\n\n라벨,텍스트\r\n긍정적,나는이 제품을 좋아해요!\r\n부정적,이건 내가 산 것 중 가장 최악입니다.\r\n중립,\"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\"\r\n부정적,가치가 없어요.\r\n긍정적,최고의 구매!\r\n\n\r\n물론 이 방법을 단순화하거나 확장하는 다양한 방법이 있지만, 이 예제를 선택하여 아이디어를 제공했습니다. 이 코드를 다음 GitHub 저장소에서 시도해볼 수 있습니다: https://github.com/MaurerKrisztian/training_data_genration_with_openai\r\n\n\n<div class=\"content-ad\"></div>\n\nOpenAI의 함수 호출을 사용하면 고품질의 훈련 데이터를 생성하는 것이 훨씬 쉬워집니다. 텍스트, 이미지, 오디오 또는 기타 데이터를 레이블링할 때, 이 방법을 사용하면 레이블이 정확하고 일관적임이 보장됩니다. 이를 통해 기계 학습 모델을 훈련하거나 세부 조정할 때 많은 시간과 노력을 절약할 수 있습니다.\n\n이 블로그 글을 읽어 주셔서 감사합니다! 이 아이디어에 대해 여전히 실험 중이라 의견을 주시면 감사하겠습니다. 어떻게 이 방법을 활용하거나 확장할 수 있는지에 대한 생각이 있으면 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png"},"coverImage":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png","tag":["Tech"],"readingTime":7},{"title":"Angular에서 첫 번째 라이브러리 만드는 단계별 가이드","description":"","date":"2024-06-23 13:52","slug":"2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular","content":"\n\n<img src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png\" />\n\n안녕하세요! 라이브러리 프로젝트를 진행 중이었고, 각본을 만들 때는 앵귤러 라이브러리를 단계별로 만드는 방법을 어딘가에 기록하지 않았다는 것을 깨닫게 되었습니다. 이것은 나중에 참고할 수 있도록 그리고 여러분을 위해도 올린 것입니다. 그러니 시작해 보겠습니다!\n\n이 블로그 글을 시작하기 전에, 앵귤러 라이브러리 코딩랩에 대해 말씀드리고 싶습니다. 나는 Angular를 사용하여 라이브러리를 만드는 동안 마주치는 모든 가능한 오류들을 설명하고 있는 코딩랩을 준비 중입니다. 이 코딩랩은 CLI를 사용하여 라이브러리를 만드는 방법을 단계별로 안내하는 내용이 될 것입니다. 이 코딩랩은 자세한 레시피가 되어서, 여러분은 그대로 따라 하여 라이브러리를 만들 수 있습니다.\n\n이 블로그 글에서는 라이브러리의 개요, 라이브러리 생성, 앵귤러 애플리케이션에서 로컬로 사용하는 방법, npm에 발행하는 방법에 대해 이야기하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n라이브러리 만들기: [여기](https://github.com/NishuGoel/ngSLDemo)\n\n라이브러리 사용하기: [여기](https://github.com/NishuGoel/consuming-angular-lib)\n\n# 개요\n\n우선, 프로그래밍에서 라이브러리란 일반적으로 무엇을 의미하는지 이해해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n사전 컴파일된 루틴 - 이것은 반복적으로 수행할 작업의 컴파일된, 확립된, 즉시 사용 가능한 버전임을 시사합니다.\n프로그램이 사용할 수 있다 - 이는 이 재사용성이 라이브러리가 생성된 프로젝트가 아니더라도 여러 다른 프로젝트에서 활용될 수 있다는 것을 시사합니다.\n\n이 모든 것을 종합하면, 라이브러리는 주로 여러 프로젝트에서 사용할만한 기능 세트이며 해당 기능의 컴파일된 버전이 번들로 제공되어 필요한 프로젝트에 제공됩니다. 따라서 라이브러리의 기능은 다음과 같습니다.\n\n- 쉽게 공유할 수 있는 코드\n- 반복해서 사용할 수 있는 기능\n- 하나의 기능을 위해 별도로 지정된 코드\n\nAngular 라이브러리에는 기능을 정의하기 위한 컴포넌트, 모듈, 서비스가 포함되어 있습니다. 우리 앱에서 이미 많은 라이브러리를 사용하고 있습니다. 예를 들어 카운트 다운 타이머나 스크롤 바와 같은 기능을 위해서 사용됩니다. 자주 사용되는 기능이 있다면 왜 그것을 라이브러리로 내보내어 활용하지 않을까요? 많은 Angular/Javascript 라이브러리에 연결된 Angular 애플리케이션으로 생각해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 어떤 라이브러리가 Angular 라이브러리로서 자격을 갖추려면 무엇이 있어야 할까요?\n\n- 먼저 플랫폼 독립적이어야 합니다.\n- 번들화되고 배포돼야 합니다.\n- AOT 컴파일레이션 준비가 되어 있어야 합니다.\n- TypeScript로 작성돼야 합니다.\n\n이제 모든 사람이 소비하기 쉽도록 표준화되고 있는 라이브러리를 만들기 위해서는 패키지를 어떻게 배포해야 하는지에 대한 표준이나 권장 방법이 있어야 합니다.\n\nAngular 패키지 포맷은 우리의 Angular 패키지를 배포하는 추천 방법입니다. 이는 다음에 중점을 두고 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 모듈 정의\n- 타이핑 파일\n- 진입점\n- AOT 준비 메타데이터 파일\n\nAPF를 여기에서 읽으세요.\n\n# 라이브러리 만들기\n\n주로 라이브러리를 만드는 데 필요한 중요한 단계는 모든 템플릿을 인라인하고 ngc로 컴파일하여 빌드 형식을 생성하는 것입니다. 그러나 이는 많은 수동 작업이 필요하고 ng-packagr이 이를 해결하기에 충분합니다.\n\n<div class=\"content-ad\"></div>\n\nng-packagr을 사용하여 라이브러리를 생성하는 방법에 대해 작성했어요.\n\nDavid Herges가 만든 ng-packagr은 단일 명령어를 사용하여 라이브러리를 빌드하고 패키징할 수 있게 해줍니다. 그러나 Angular 6 이후에는 CLI 내에 통합되어 있어, ng-packagr을 사용하여 Angular 라이브러리를 생성하는 데 ng generate 명령어를 사용할 수 있습니다.\n\nng-packagr이 우리를 위해 처리해주는 것들은 무엇이 있을까요?\n\n- Angular 패키지 형식으로 라이브러리 생성\n- 모든 번들 생성 (es52015, esm5, umd)\n- 형식 정의 파일(.d.ts) 생성\n- aot 메타데이터 파일 생성\n- 모든 스타일과 템플릿을 인라인으로 처리합니다!\n\n<div class=\"content-ad\"></div>\n\n저희 라이브러리를 위한 작업 공간을 만들어보겠습니다!\n\n다음 명령어를 사용하여 새로운 애플리케이션을 생성하되 애플리케이션을 만들지 않도록 설정하세요.\n\n```bash\nng new `application-name` --create-application=false\n```\n\n이렇게 하면 애플리케이션을 만들지 않고 작업 공간만 생성됩니다. 이후 해당 작업 공간 내에서 라이브러리를 생성할 수 있습니다. 아래 이미지를 참고하세요.\n\n![Step-by-step guide to creating your first library in Angular](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_1.png)\n\n\n<div class=\"content-ad\"></div>\n\nng generate library `library-name`\n\n이 명령은 lib 폴더가 포함된 projects 폴더를 생성합니다. 여기서 라이브러리에 추가할 기능을 작성할 수 있어요! \n\n![Step-by-step guide to creating your first library in Angular](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_2.png)\n\n라이브러리 작성을 마쳤나요?\n\n<div class=\"content-ad\"></div>\n\n# 라이브러리 구축 시간입니다!\n\n루트 package.json에 빌드 라이브러리 스크립트를 추가하세요:\n\n```json\n\"build-library\": \"ng build nishu-library”\n```\n\n![이미지](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_3.png)\n\n<div class=\"content-ad\"></div>\n\n이렇게 하면 라이브러리를 위한 dist 폴더가 생성됩니다.\n\n![이미지](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_4.png)\n\n프로젝트가 조금 어려워지기 시작하는 지점입니다. 왜냐하면 이제 전체 프로젝트에는 3개의 package.json 파일이 모두 포함되어 있다는 것을 알아차릴 것입니다. 루트 package.json에는 라이브러리 빌드 스크립트가 작성되어 있고, 라이브러리 package.json에는 라이브러리의 이름, 버전과 같은 정보가 제공됩니다. 이것은 라이브러리를 npm에 배포할 때 사용됩니다. 라이브러리를 패키징할 때에 대해 이야기를 나눌 것입니다.\n세 번째 package.json은 방금 생성한 라이브러리의 배포 폴더에 있습니다. 이 폴더에는 내보낼 최종 코드가 포함되어 있습니다.\n\n# 라이브러리 패키징\n\n<div class=\"content-ad\"></div>\n\n우리 라이브러리를 패키징하려면 라이브러리 배포 디렉토리로 이동하여 npm pack 명령을 실행하면 됩니다.\n\n여기서 라이브러리 디렉토리를 패킹하는 혼란을 피합니다. 라이브러리의 빌드된 배포 폴더를 패킹해야 합니다. 이를 수동으로 하는 대신에 스크립트도 추가할 수 있습니다.\n\n\"pack-lib\": \"cd dist/nishu-library && npm pack\"\n\n이렇게 하면 라이브러리용 .tgz 패키지가 생성되고, 이를 내보낼 것입니다. 다른 애플리케이션에서 사용될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_5.png\" />\n\n우리의 패키지가 준비되었으니, 다른 애플리케이션 내에서 사용하여 테스트할 수 있습니다.\n\n새로운 Angular 애플리케이션을 생성하고 다음을 사용하여 라이브러리를 설치하세요:\n\nnpm install `path-to-tgz-file`\n\n<div class=\"content-ad\"></div>\n\n패키지.json을 확인해 보세요. 종속성에 설치되었는지 확인하세요.\n\n다음과 같이 파일이 추가된 것을 확인할 수 있을 겁니다:\n\n![image](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_6.png)\n\n다음 단계로, 라이브러리의 모듈을 가져와 컴포넌트를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n\n' NishuLibraryModule'를 `nishu-library`에서 가져와주세요.\n\n이렇게 하면 프로젝트에서 이 모듈 내에서 선언된 컴포넌트에 액세스할 수 있게 됩니다. 이제 템플릿에서 이 컴포넌트를 직접 사용하여 작동 방식을 확인할 수 있습니다!\n\n<img src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_7.png\" />\n\n템플릿에서는,\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<section class=\"body-section\">\n    <lib-nishu-library></lib-nishu-library>\n</section>\n```\n\n여기 있어요!\n\n<img src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_8.png\" />\n\n# 마지막으로 우리 라이브러리를 게시해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n라이브러리를 게시하려면 npm 패키지에 대한 네이밍 규칙을 따르고 고유하게 유지해야 합니다. npm에는 많은 라이브러리가 있으므로, 라이브러리를 @`your-username`/`library-name`과 같이 명명하는 것이 쉬운 방법입니다.\n\n다음 단계는 package.json 내부에 라이브러리의 이름과 버전을 지정하는 것입니다.\n\n```js\n{\n  \"name\": \"nishu-library\",\n  \"version\": \"1.0.0\",\n  \"peerDependencies\": {\n        \"@angular/common\": \"~9.0.0\",\n        \"@angular/core\": \"~9.0.0\",\n  }\n}\n```\n\npeerDependencies는 소비 프로젝트에 해당 패키지 버전과 잘 호환됨을 알리는 방법입니다. 라이브러리의 버전을 주요 버전, 부 버전, 패치 버전 구체적으로 따르기 위해 시맨틱 버전팅을 사용하세요. SemVer에 대해 자세히 알아보세요.\n\n<div class=\"content-ad\"></div>\n\n패키지.json에는 작성자, 라이선스 등 라이브러리에 대한 더 많은 정보를 추가할 수 있습니다.\n\n라이브러리를 빌드하고 dist 폴더에 업데이트된 패키지.json을 찾으세요. pack-lib 스크립트를 사용하여 새 번들을 패키징하세요.\n\n모두 준비되었나요? 이제 npm에 로그인합시다. 명령줄 또는 GUI에서 둘 다 가능합니다.\n\nnpm login을 사용하여 npm에 로그인하고 npm whoami로 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n단계별로 첫 번째 Angular 라이브러리를 만드는 방법에 대한 안내서.\n\n<div class=\"content-ad\"></div>\n\n짠, 이제 누구나 아래와 같이 Angular 프로젝트에서 이 공개 라이브러리를 사용할 수 있어요:\n\n```bash\nnpm i nishu-library\n```\n\n읽어 주셔서 감사합니다! 피드백/질문은 트위터/링크드인을 통해 연락해 주세요. 🚀","ogImage":{"url":"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png"},"coverImage":"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png","tag":["Tech"],"readingTime":7},{"title":"모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까","description":"","date":"2024-06-23 13:51","slug":"2024-06-23-MonorepoorNotMonorepo","content":"\n\n소프트웨어 아키텍처를 결정할 때입니다. 점진적인 방식이 좋을까요, 아니면 처음부터 최상의 디자인을 찾아야 할까요? 우리는 모두 완벽을 추구합니다 — 최고의 라이브러리, 최고의 도구 등을. 하지만 “best”는 상대적인 개념이며, 선한 사람이 되는 것과 같이 주관적이며 상황에 따라 달라집니다. 좋은 소프트웨어를 설계할 때 여러 매개변수가 의사결정에 영향을 미치고 변화할 수 있다는 것을 염두에 두세요.\n\n과도한 설계는 피해야 합니다. 더 가치 있는 것을 만들기 위해서는 더 많은 지식과 경험이 필요하지만, 아키텍처를 너무 복잡하게 만들지 않는 것이 중요합니다. 모노 레포와 이 방식을 채택할지 결정하는 데 고려해야 할 사항을 살펴봅시다.\n\n# 모노 레포란 무엇인가요?\n\n모노 레포는 “단일 저장소”를 줄인 용어로, 여러 프로젝트의 코드가 단일 저장소에 위치하는 버전 컨트롤 전략입니다. 이 방식은 각 프로젝트가 자체 저장소를 가지는 폴리 레포 모델과 대조됩니다.\n\n<div class=\"content-ad\"></div>\n\n# Monorepos의 장점\n\n1. 통합된 코드베이스: Monorepo를 사용하면 모든 코드가 한 곳에 있어 다른 프로젝트 간에 코드를 쉽게 공유하고 재사용할 수 있습니다.\n2. 단순화된 의존성 관리: 모든 프로젝트가 같은 저장소를 공유하기 때문에 의존성 관리가 더 간단해집니다.\n3. 일관된 도구 및 구성: 단일 저장소를 통해 모든 프로젝트에서 도구와 구성을 일관되게 사용할 수 있습니다.\n4. 더 나은 협업: Monorepo에서 작업하는 팀은 모든 프로젝트의 변경 사항을 볼 수 있어 소통과 협업이 개선됩니다.\n\n# Monorepos의 도전과제\n\n1. 확장성 문제: 코드베이스가 커지면 저장소가 다루기 어려워져 관리가 더 어려워질 수 있습니다.\n2. 복잡한 빌드 프로세스: 한 부분의 변경이 다른 부분에 영향을 줄 수 있어 빌드 및 테스트가 더 복잡해질 수 있습니다.\n3. 접근 제어: 액세스 및 권한 관리는 특히 여러 팀이 있는 대규모 조직에서 도전적일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n코드 예제: TurboRepo를 이용한 단일저장소 설정\n\nTurboRepo는 JavaScript 및 TypeScript 코드베이스를 위한 고성능 빌드 시스템으로, 단일 저장소에 이상적입니다. 다음은 기본적인 설정 방법입니다:\n\n1. 설치:\n\n```js\nnpx create-turbo@latest\ncd my-turbo-repo\n```\n\n<div class=\"content-ad\"></div>\n\n2. 애플리케이션과 패키지 추가하기:\n\n```js\n npx turbo run create next-app apps/myapp\n npx turbo run create react-lib packages/mylib\n```\n\n3. 프로젝트 간 코드 공유하기:\n\n```js\n// packages/mylib/src/index.ts\nexport function greet(name: string) {\nreturn `Hello, ${name}!`;\n }\n\n// apps/myapp/pages/index.tsx\nimport { greet } from 'mylib';\n\nconst Home = () => {\n return <div>{greet(‘World’)}</div>;\n }\n\nexport default Home;\n```\n\n<div class=\"content-ad\"></div>\n\n4. TurboRepo 구성:\n\n```js\n // turbo.json\n {\n   \"pipeline\": {\n     \"build\": {\n       \"dependsOn\": [\"^build\"],\n       \"outputs\": [\"dist/**\"]\n     },\n     \"lint\": {},\n     \"test\": {}\n   }\n }\n```\n\n5. TurboRepo 실행:\n\n```js\nnpx turbo run build\n```\n\n<div class=\"content-ad\"></div>\n\n# 증분 빌드 및 캐싱\n\nTurboRepo는 대규모 코드베이스에 효율적인 증분 빌드와 캐싱을 제공하여 뛰어납니다.\n\n1. TurboRepo 캐싱:\n\nsa\n\n<div class=\"content-ad\"></div>\n\n```js\n\n // turbo.json\n {\n   \"pipeline\": {\n     \"build\": {\n       \"dependsOn\": [\"^build\"],\n       \"outputs\": [\"dist/**\"],\n       \"cache\": true\n     },\n     \"lint\": {\n       \"cache\": true\n     },\n     \"test\": {\n       \"cache\": true\n     }\n   }\n }\n```\n\n## 단일 저장소(monorepo)를 사용해야 하는 경우\n\n- 꽉 결합: 프로젝트가 빈번하게 코드를 공유하고 서로 강하게 결합되어 있는 경우, 단일 저장소(monorepo)는 의존성 관리와 통합을 간소화할 수 있습니다.\n- 소규모부터 중간 규모의 팀: 의사소통이 간단한 작은 팀에서는 단일 저장소(monorepo)가 더 관리하기 쉬울 수 있습니다.\n- 일관된 표준: 프로젝트 간 일관된 코딩 표준, 도구 및 관행을 유지하는 것이 우선시되는 경우.\n\n## 단일 저장소(monorepo)를 피해야 하는 경우\n\n<div class=\"content-ad\"></div>\n\n- 대규모 다양한 팀: 서로 느슨하게 결합된 프로젝트에 참여하는 대규모 팀은 모노 레포를 사용하기 어려울 수 있습니다.\n- 독립적인 배포: 프로젝트가 서로에게 영향을 미치지 않고 독립적으로 배포되어야 하는 경우, 폴리 레포가 더 적합할 수 있습니다.\n- 확장성 고려: 코드베이스가 크게 성장할 것으로 예상된다면, 모노 레포가 그 규모를 처리할 수 있는지 고려해야 합니다.\n\n# 결론\n\n소프트웨어 아키텍처에서 모노 레포와 폴리 레포 중 어떤 것을 선택할지 결정하는 것은 중요한 결정입니다. 각 접근 방식의 장단점을 여러분의 특정 요구 사항과 맥락에 대비해 고려하는 것이 중요합니다. 요구 사항을 충족시키면서 솔루션을 가능한 한 간단하게 유지함으로써 과도한 엔지니어링을 피할 수 있습니다. 모노 레포를 선택하든 말든, 주요한 것은 유연하고 유지 가능하며 확장 가능한 아키텍처를 구축하는 것입니다.\n\n글의 비전에 보다 잘 맞게 각 섹션을 조정하거나 확장해도 괜찮습니다!","ogImage":{"url":"/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png"},"coverImage":"/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png","tag":["Tech"],"readingTime":4},{"title":"dotenv으로 TypeScript에서 환경 변수 사용하는 방법","description":"","date":"2024-06-23 13:50","slug":"2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv","content":"\n\n새 프로젝트를 시작하거나 환경 변수가 필요한 기존 프로젝트와 작업 중이라면, 이 안내서가 TypeScript 코드베이스에 원활하게 통합되도록 도와줄 것입니다.\n\n# 단계 1: 필수 패키지 설치\n\n터미널을 열고 프로젝트의 루트 디렉토리로 이동하세요. npm과 같은 선호하는 패키지 관리자를 사용하여 필요한 패키지를 설치하세요:\n\n```js\nnpm install dotenv ts-node\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: 환경 변수 구성\n\n프로젝트 디렉토리의 루트에 .env 파일을 생성하세요. 이 파일 안에 환경 변수를 다음 형식을 사용하여 정의하세요:\n\n```js\nVARIABLE_NAME=value\n```\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nREACT_APP_MY_API_KEY=your-api-key-here\n```\n\n# 단계 3: TypeScript 파일 생성\n\n환경 변수에 액세스할 위치에 .ts 파일을 생성합니다. 이 예제에서는 파일 이름을 app.ts로 지정합시다.\n\n# 단계 4: 환경 변수 가져오고 사용하기\n\n<div class=\"content-ad\"></div>\n\n당신의 TypeScript 파일(app.ts)에서 dotenv 라이브러리를 가져와서 환경 변수를 .env 파일에서 로드할 수 있도록 구성하세요:\n\n```js\n// app.ts\nimport dotenv from 'dotenv';\ndotenv.config();  // .env 파일로부터 환경 변수 로드\nconst apiKey = process.env.REACT_APP_MY_API_KEY;  // 환경 변수 검색\nconsole.log('API Key:', apiKey);  // 필요한 대로 환경 변수 사용하기\n```\n\n# 단계 5: ts-node를 사용하여 TypeScript 파일 실행하기\n\nts-node는 수동 컴파일 작업 없이 TypeScript 파일을 직접 실행하는 프로세스를 간소화하는 중요한 도구입니다. TypeScript는 정적으로 유형이 지정된 언어이며 Node.js 환경에서 실행되기 전에 JavaScript로 변환되어야 합니다. 이때 ts-node가 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n터미널에서 프로젝트 디렉토리로 이동한 후 TypeScript 파일을 ts-node을 사용하여 실행하세요:\n\n```js\nnpx ts-node app.ts\n```\n\nts-node 패키지는 수동 컴파일 과정 없이 TypeScript 파일을 직접 실행할 수 있도록 도와줍니다. 특히 개발 중에 코드를 빠르게 테스트하고 싶을 때 유용합니다.\n\n이 간단한 단계를 따라가면 dotenv와 ts-node 패키지를 사용하여 환경 변수를 TypeScript 코드에 손쉽게 통합할 수 있습니다. 어려움을 겪는 경우 각 단계를 주의 깊게 따르고 파일 경로와 변수 이름이 프로젝트 구조와 일치하는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n# 자주 묻는 질문 (FAQs)\n\n## 1. TypeScript 프로젝트에서 환경 변수가 필요한 이유는 무엇인가요?\n\n환경 변수는 코드베이스 외부에 API 키 또는 데이터베이스 자격 증명과 같은 중요한 정보를 안전하게 저장하는 데 필수적입니다. 이러한 관행은 보안을 강화하고 개발, 테스트 및 프로덕션 환경 간의 구성 전환 프로세스를 간소화합니다.\n\n## 2. 다른 프로그래밍 언어에서도 환경 변수를 사용할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n네, 환경 변수는 많은 프로그래밍 언어와 프레임워크에서 표준 기능입니다. 이를 사용하면 설정을 코드와 독립적으로 저장할 수 있어 유연성과 보안을 높일 수 있습니다.\n\n## 3. 프로덕션 환경에서 환경 변수를 업데이트하는 방법은 무엇인가요?\n\n애플리케이션을 프로덕션 환경에 배포할 때, 일반적으로 호스팅 공급업체의 대시보드나 명령줄 인터페이스를 사용하여 환경 변수를 설정합니다. 이를 통해 민감한 정보가 코드와 분리되어 안전하게 보호됩니다.\n\n## 4. 환경 변수를 관리하는데 dotenv 대체품이 있을까요?\n\n<div class=\"content-ad\"></div>\n\n네, dotenv 외에도 config, env-cmd 및 호스팅 플랫폼에서 제공하는 내장 솔루션과 같은 대체 제품이 있습니다. 프로젝트의 요구 사항과 아키텍처에 가장 적합한 것을 선택하세요.\n\n# 5. 브라우저 기반 TypeScript 애플리케이션에서 환경 변수를 사용할 수 있나요?\n\n네, 브라우저 기반 TypeScript 애플리케이션에서 환경 변수를 사용할 수 있습니다. 그러나 이러한 변수는 클라이언트 측에서 접근 가능할 것입니다. 민감한 정보를 보호하기 위해 서버 측 코드 또는 프록시 엔드포인트를 사용하는 것이 권장됩니다.\n\n요약하면, dotenv와 ts-node를 사용하여 TypeScript 프로젝트에 환경 변수를 통합하는 것은 보안 및 구성 관리를 향상시키는 간단한 프로세스입니다. 이러한 단계와 지침을 따르면 민감한 정보를 코드와 분리하여 더 안전하고 효율적인 개발 워크플로우를 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 저는 전문 프론트엔드 개발자를 희망하고 있고, 본업은 시스템 관리자인 수샨트입니다. 저의 학습 여정을 완전 초보자의 눈을 통해 공유하겠습니다. 코딩 통찰력부터 IT 분야를 넘나드는 방법까지 모두 기록해 나갈 예정이에요. 앞으로의 서비스 개발을 향해 노력하는 동안 함께 LinkedIn에서 연결하고 배우는 시간을 가지길 기대하고 있습니다! 함께 소통하고 배우는 것을 기대하고 있어요!","ogImage":{"url":"/assets/img/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv_0.png"},"coverImage":"/assets/img/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv_0.png","tag":["Tech"],"readingTime":3},{"title":"타입스크립트 런타임 설정 완전 정복하는 방법","description":"","date":"2024-06-23 13:49","slug":"2024-06-23-MasteringTypescriptRuntimeConfigurations","content":"\n\n대부분의 사람들이 경력 초기에 배우는 것 중 하나가 구성(configuration)입니다. 그리고 대부분의 사람들이 처음에 배운 방법을 계속 사용합니다. 저는 10년 이상 웹 개발을 해 왔는데, 끊임없이 다양한 구성 접근 방식을 보았습니다. 오늘은 여러분이 앱을 구성하는 것을 조금 더 쉽게 만들어 드리려고 왔습니다. 물론, 새롭게 출시한 제 패키지 https://github.com/mrspartak/config 도 소개할 예정이에요.\n\n![image](/assets/img/2024-06-23-MasteringTypescriptRuntimeConfigurations_0.png)\n\n저는 풀스택 개발자이지만, 백엔드와 프론트엔드 구성을 구분하지는 않습니다. 빌드 시간 및 실행 시간 구성을 모두 사용할 수 있기 때문에 유사하다고 생각하기 때문이죠. 우리는 컨테이너화 시대에 살고 있으므로, 주로 이 유형의 배포에 초점을 맞출 거예요. 아래 섹션에서 제공하는 통찰력은 꽤 주관적일 수 있으므로, 만약 여러분의 의견이 다르다면 댓글로 의견을 나누고 싶어요.\n\n## 빌드 시간 구성(Build-time configuration)\n\n<div class=\"content-ad\"></div>\n\n빌드 시간 구성은 백엔드에서는 덜 흔하지만 프론트엔드에서는 꽤 인기 있는 접근 방식입니다. 여기서 구성 값을 패키지나 이미지에 포함하여 애플리케이션을 실행하는 데 충분할 수 있습니다. 저에게는 빌드 시간에 환경과 관련된 모든 것을 처리하는 것이 합리적으로 보입니다. 이는 코드에서 IO 작업이 어떻게 동작하는지에 영향을 미치는 구체적인 테스트, 스테이징 및 프로덕션 환경 구성을 포함합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*WIXN4ZkEhqUXVOfalToyAg.gif)\n\n그러나 일부 사람들은 빌드 시간에 API 엔드포인트, 인증 키 등 외부 구성을 포함하여 이를 지나치게 사용하기도 합니다. 이 방법은 작동하지만 각 환경별로 패키지나 이미지를 재빌드하고 테스트해야 하므로 빌드 간에 불일치를 일으킬 수 있습니다.\n\n## 런타임 구성.\n\n<div class=\"content-ad\"></div>\n\n백엔드에서 진짜 빛을 발할 때죠. 하지만 나는 SSR (서버 측 렌더링) 및 SPA (단일 페이지 응용 프로그램) 프런트엔드에서 실행시 구성을 자주 사용해요. 앱이 로드되는 처음에 사용되고 외부 구성을 모두 포함해야 하며 환경에 따라 크게 달라질 수 있어요. 여기서 순간적인 환경의 강점이 발휘되어 더 큰 유연성과 적응성을 제공해 줍니다.\n\n## 어떻게 구성하나요?\n\n그래서 정확히 구성(configuration)이 뭔가요? `.env` 파일을 알죠… 아니라면 `.toml`이나 `.json`, `.ini`이 있겠죠? 안돼, 그냥 `.ts` 파일을 만들고 그 안에서 객체를 내보내요. 하지만 기다려봐요. 파일을 git에 커밋해야 하나요? 환경마다 파일을 만들고 비밀 데이터를 숨길까요?\n\n<img src=\"https://miro.medium.com/v2/resize:fit:960/1*7S4sjloFaBx5isjqi_OAXw.gif\" />\n\n<div class=\"content-ad\"></div>\n\n최고의 형식에 대해 전쟁을 벌일 수 있지만, 사실은 별로 중요하지 않아요. 읽기 쉽고 확장 가능하며 텍스트로 저장할 수 있는 것이면 충분히 좋아요. 당신이 원하는 대로 하세요. 하지만 저장 및 사용 전략은 상당히 중요해요.\n\n저장 측면에서, Kubernetes (k8s), Docker Swarm 또는 일반 Docker를 사용하는 경우, 아마도 configs와 secrets에 익숙할 겁니다. 이를 통해 코드와 실행 중인 컨테이너에 파일이나 폴더를 첨부할 수 있어요. 대부분의 어려움은 개발 환경이나 프로덕션 환경에 새로운 구성을 배포할 때 발생한다고 생각해요.\n\n## 확인, 확인, 확인\n\n설정은 선언부터 시작돼요. 그것만이 필요한 거예요. 백엔드에서 데이터베이스를 호출해야 한다면, 이 데이터베이스에 인증하는 데 필요한 것을 알아내서 설정 선언에 넣어보세요. 그 결과는 무엇일까요? 앱이 충돌하게 되는 거죠 — 이게 바로 좋은 일이에요. 이를 통해 누락된 또는 잘못된 구성을 조기에 확인할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:960/1*hDRj2PnNe94Krj76Az67lQ.gif)\n\n다음으로 필요한 필드를 구성 파일에 추가해야 합니다. 검증 라이브러리를 사용하거나 더 좋은 방법으로 (비밀 광고 경고) 제 라이브러리를 사용하여 검증을 처리하세요.\n\n## 병합, 때때로 시간을 절약합니다\n\n기본 PORT가 항상 설정되어 있는데 설정하지 않을 때는 어떻게 할까요? 당연히 그 기본값을 정의하는 것이 도움이 됩니다. 그런데 그 후에 어떻게 병합하죠? lodash를 사용하거나 더 나은 방법으로 (계속 언급하다 보면 짜증나지 않고 내 생각처럼 되기 시작한다는 말이 있습니다).\n\n\n<div class=\"content-ad\"></div>\n\n## 개발자에 대한 생각은 뭐야? 그보다 더 있을까?\n\n물론이죠. 물어주셔서 감사합니다. 제 현재 주 언어는 TypeScript이기 때문에 그것에서 최선을 다해야겠죠. 상상해보세요! 전체 구성이 타입으로 정의된 것을 볼 수 있다면 얼마나 멋진가요. 예를 들어 Zod로 유효성을 검사하는 사람들은 이미 이 편한 삶을 살고 있어요. 제 라이브러리를 사용하면 어떤 유효성 검사 라이브러리라도 손쉽게 적용할 수 있답니다.\n\ntrpc 무신, 정말 천재적이에요. 그의 코드를 그냥 복사하여 사용하면 구성을 결과로 유도해낼 수 있어요. 마법 같죠.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*7sjOuoIpBuH3KTlkUFt1QQ.gif)\n\n<div class=\"content-ad\"></div>\n\n## 개발 환경을 언급했어요. 커밋할까 말까?\n\n안 돼요. 정말로요. OPENAPI_KEY를 즉시 훔치고, 일주일 후엔 길거리에서 구걸하게 될 거에요. 비밀 저장소 솔루션을 사용해주세요. 1Password, Google Cloud, Amazon, Infisical, dotenv.org, 그리고 여러 다른 멋진 프로젝트들이 안전하게 시크릿을 저장하고 공유할 수 있게 해줘요.\n\npackage.json에 설정 스크립트를 포함해서 시크릿의 정확한 버전을 다운로드할 수 있게 해주세요. 또한, 충돌을 피하기 위해 버전을 업데이트하고 git에서 충돌을 피하도록 하는 업로드 스크립트도 포함해주세요. 나중에 감사를 말할 거예요. 저는 이 방법을 여러 해 동안 사용해왔고, 로컬 설정을 플래시 드라이브나 Slack을 통해 공유하는 데 돌아갈 수 없을 거예요.\n\n![image](https://miro.medium.com/v2/resize:fit:960/1*CR7GClSquXaYgsn6gmGv6Q.gif)\n\n<div class=\"content-ad\"></div>\n\n## 좋아 좋아, 이제 다른 무거운 npm 패키지에 대해 말씀드릴게요\n\n실제로, 이 패키지는 종속성이 전혀 없으며 TypeScript를 사용하고 아마도 번들러를 사용해야 합니다. 일반적으로 위에서 언급한 모든 문제를 해결해 줍니다 (물론 개발 환경은 제외하고요). 이 패키지를 사용하면 다음과 같은 장점을 얻을 수 있어요:\n\n- 3가지 소스 옵션: JSON 파일, JSON URL 및 객체를 지원하여 대부분의 사용 사례를 커버합니다.\n- 런타임 유효성 검사: Zod, Superstruct, Yup 등 인기있는 라이브러리와 함께 작동합니다.\n- TypeScript IntelliSense: 유효성 검사 라이브러리의 변환기를 적용하고 해결된 유효성에 대한 힌트를 제공합니다.\n- 병합: 왜냐하면요? 기본값을 분리해서 가지고 있는 것이 상당히 멋지기 때문이죠. 기본값을 항상 유효성 검사 스키마에 넣을 수 있지만, 그러면 코드에 저장되어 있게 됩니다.\n- 완전히 테스트된 상태: 상용화 준비가 끝난 상태이며 이미 다수의 응용 프로그램에서 사용되었습니다.\n- 백엔드 및 프런트엔드 친화적: 양쪽 환경에서 매끄럽게 작동합니다.\n\n```js\n// file: state/config.ts\nimport { fromJSONFile } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst config = await fromJSONFile({\n  path: [\"../config/default.json\", \"../config/runtime.json\"],\n  schema: z.object({\n    db: z.object({\n      host: z.string(),\n      port: z.number(),\n      username: z.string(),\n      password: z.string()\n    }),\n    app: z.object({\n      port: z.number().optional().default(3000)\n    })\n  }),\n});\n\nexport default config\n\n\n\n// file: index.ts\n// 해결된 구성을 가져옵니다\nimport config from './state/config.js';\n\n// 애플리케이션에서 구성을 사용합니다\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n<div class=\"content-ad\"></div>\n\n## 그런데 JSON 지원만 있는 것 같아요. 환경 변수를 사용하는데 무거운 시스템 쓰레기가 많이 들어가지 않은 사랑스러운 방법이 있을까요?\n\n객체와 작업하는 것을 지원하므로 env 객체를 함수에 전달할 수 있어요. 다른 .env 파서를 다시 작성하는 것이 이상할 수 있겠죠. 시장에 이미 테스트된 많은 것들이 있으니까요.\n\n```js\n// file: state/config.ts\nimport { fromObject } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    NODE_ENV: z.enum([\"development\", \"production\"]),\n    DB_HOST: z.string(),\n    DB_PORT: z.number(),\n    DB_USER: z.string(),\n    DB_PASSWORD: z.string(),\n    APP_PORT: z.number().default(3000),\n  })\n  .transform((data) => ({\n    environment: data.NODE_ENV,\n    port: data.APP_PORT,\n    db: {\n      host: data.DB_HOST,\n      port: data.DB_PORT,\n      user: data.DB_USER,\n      password: data.DB_PASSWORD,\n    },\n  }));\n\nconst config = await fromObject({\n  data: process.env,\n  schema\n})\n\nexport default config\n\n\n// file index.ts\nimport 'dotenv/config'\n// ! dotenv 이후에 설정이로드되어야 하므로 process.env가 채워집니다.\nimport config from './state/config.js';\n\n// 애플리케이션에서 구성 사용하기\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n## 프론트엔드를 언급했는데, 노드 파일 API를 사용한 것 같아요. 빌드가 깨질 거에요.\n\n<div class=\"content-ad\"></div>\n\n네. 그렇습니다. 따로 내보내는 방법이 있습니다. (만약 다른 더 나은 해결책을 아시면 연락 주세요)\n\n```js\n// 파일: state/config.ts\nimport { fromObject } from \"@mrspartak/config/web\"; // 라이브러리의 별도 빌드\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    API_URL: z.string(),\n  })\n\nconst config = await fromObject({\n  data: import.meta.env, // vite의 예제\n  schema\n})\n\nexport default config\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*ipkgq4adHLjucIErFR2buA.gif)","ogImage":{"url":"/assets/img/2024-06-23-MasteringTypescriptRuntimeConfigurations_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringTypescriptRuntimeConfigurations_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 파이썬 및 웹 개발자를 위한 Rob Percival의 최고의 Udemy 강좌 10선","description":"","date":"2024-06-23 13:47","slug":"2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024","content":"\n\n## 2024년에 Python 및 JavaScript를 배우기 위한 Rob Percival 강사의 가장 좋아하는 Udemy 강의들\n\n![이미지](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_0.png)\n\n안녕하세요 여러분, 웹 개발, Python, JavaScript 및 Node.js를 배우기 위한 Udemy의 최고 강사인 Rob Percival의 최고의 온라인 강좌를 찾고 계시다면, 당신이 올바른 장소에 오신 것을 환영합니다.\n\nRob Percival은 Udemy의 최고 강사 중 하나인데, Jose Portilla, Stephen Grider, Maximillian SchwarzMuller, Stephane Maarek 및 Brad Traversy와 함께 제가 가장 좋아하는 강사 중 한 명입니다. 이 기사에서는 Udemy 최고 강사이자 제가 최고로 좋아하는 Rob Percival의 최고의 온라인 강좌를 공유하려고 합니다. 하지만, 우선적으로 Rob이 누구인지 알려드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n로브 퍼서벌은 유데미 플랫폼에서 가장 자격 있는 강사 중 한 명으로, 코딩에 미친 열정을 가지고 케임브리지 대학에서 수학 학위를 받은 사람입니다.\n\n그는 친구들과 가족을 위한 웹사이트를 만들면서 웹 개발의 기초를 익혔습니다. 웹 개발이 매우 유망한 직업 선택일 수 있다는 것을 깨달은 후에는, 선생님으로 일하던 일을 그만두고 전업 코더가 되기로 결심했습니다.\n\n로브 퍼서벌은 어린이들에게 코딩을 가르치는 데 열정적입니다. 매해 여름에는 케임브리지라는 아름다운 도시에서 코드 스쿨을 운영합니다. 또한 에코 웹 호스팅이라는 인기 있는 웹 호스팅 및 디자인 서비스도 운영합니다.\n\n유데미에서 그의 강좌 중 하나라도 체험해 보면 많은 사람들 - 포함해서 제 자신도 - 그의 강좌를 수강하고 추천하는 이유를 알 수 있을 것입니다. 그의 강좌는 시장에서 가장 우수하며, 만약 어쩌다가 강좌가 마음에 들지 않는다고 느끼면, 기쁜 마음으로 환불해 드릴 것입니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 해드린 어려운 일을 대신해 로브의 우데미 플랫폼에서의 최고 강의 목록을 정리했습니다. 거의 모든 강의가 가치 있는 것을 깨달을 때, 이게 생각보다 얼마나 어려운 일이었는지 알게 될 거예요. 더 자세한 내용을 알아보려면 계속 읽어주세요.\n\n# 2024년 로브 퍼서벌의 파이썬 및 웹 개발자를 위한 최고의 우데미 강좌 10선\n\n다음은 우데미에서 로브 퍼서벌의 최고 온라인 강좌 목록입니다. 로브는 웹 개발, 디지털 마케팅, 노드제이에스, 카피라이팅, 파이썬, 자바스크립트, 루비 온 레일즈, 머신 러닝을 학습할 수 있는 멋진 강좌를 만들었습니다. 이러한 필수 기술을 배우고 테크 분야에서 경력을 시작하려면 우데미에서 로브의 강좌에 참여하세요.\n\n## 1. 완전한 웹 개발자 강좌 3.0 [우데미]\n\n<div class=\"content-ad\"></div>\n\n이 멋진 코스를 통해 HTML, CSS, JavaScript, PHP, Python 및 MySQL을 사용하여 25개의 웹사이트 및 모바일 앱을 만들며 웹 개발을 배울 수 있습니다. 이 코스를 마칠 때쯤에는 주니어 웹 개발자로서 좋은 직장을 얻을 수 있을 것입니다.\n\n코스 기간: 40시간\n\n코스 평점: 5점 만점에 4.5점\n\n코스 강사: Rob Percival\n\n<div class=\"content-ad\"></div>\n\n코스 가격: $56\n\n이 코스를 구매하면 온디맨드 비디오 강의 40시간 이상과 135개의 기사에 평생 액세스할 수 있습니다.\n\n다음은 이 코스에 가입할 수 있는 링크입니다 — The Complete Web Developer Course 3.0\n\n![Course Image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 2. The Complete Python Course — Learn Python By Doing [Udemy]\n\n이 강좌는 초보자와 숙련자 모두에게 완벽합니다. Python 3로 모든 중요한 Python 주제를 배우고 작업할 수 있습니다. 객체 지향 프로그래밍을 마스터하고 프로처럼 프로그램 구조를 만들 수 있습니다.\n\n강좌 기간: 35 시간\n\n강좌 평가: 5점 만점에 4.6점\n\n<div class=\"content-ad\"></div>\n\n강의 강사: Rob Percival 및 Telcado\n\n강의 가격: $56\n\n이 강의를 구매하면 요청 시 볼 수 있는 35시간 이상의 비디오 강의, 56개의 기사, 그리고 13개의 다운로드 가능한 교육 자료에 평생 액세스할 수 있습니다.\n\n다음은 이 강의인 \"The Complete Python Course - Learn Python By Doing\"에 가입할 수 있는 링크입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_2.png\" />\n\n## 3. The Complete React Js & Redux Course — Build Modern Web Apps\n\n이 훌륭한 강의는 React.js를 사용하여 더 나은 웹 애플리케이션을 만들 수 있도록 도와줍니다. React.js는 강력하고 인기 있는 JavaScript 라이브러리 중 하나입니다. 당신은 기본적으로 현대적인 방식으로 웹 애플리케이션을 구축하는 방법을 배우게 될 것입니다.\n\n수강 시간: 8 시간\n\n<div class=\"content-ad\"></div>\n\n코스 평점: 5점 만점에 4.6점\n\n강사: Rob Percival\n\n가격: $56\n\n이 코스에서 가장 좋은 점은 Instagram과 유사한 웹 앱을 처음부터 만들 수 있다는 것입니다! Redux를 사용하여 앱 데이터를 관리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 코스에 참여하려면 여기 링크를 클릭하세요 — The Complete React Js & Redux Course — Build Modern Web Apps\n\n![course image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_3.png)\n\n### 4. The Complete Node.js Developer Course (3rd Edition) [Udemy]\n\n이 코스를 통해 Node.js, Express, MongoDB 및 Jest를 사용하여 실제 웹 애플리케이션을 구축하는 방법을 학습할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n강의 기간: 35 시간\n\n강의 평점: 5점 만점 중 4.6점\n\n강사: Rob Percival과 Andrew Mead\n\n강의 가격: $56\n\n<div class=\"content-ad\"></div>\n\n이 코스를 구매하시면 온디맨드 비디오 강의 35시간 이상과 다운로드 가능한 교육 자료 135개에 대한 평생 액세스가 제공됩니다.\n\n이 코스에 가입하려면 다음 링크를 참조하세요 — The Complete Node.js Developer Course\n\n[이미지](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_4.png)\n\n## 5. The Complete Ruby On Rails Developer Course [Udemy]\n\n<div class=\"content-ad\"></div>\n\n\n이 강좌를 통해 아이디어를 신속하게 프로토타이핑하고 이를 발표 가능한 앱으로 구현하는 방법을 배울 수 있습니다. 귀하는 전문적인 Ruby on Rails 개발자가 될 것입니다.\n\n강좌 기간: 46 시간\n\n강좌 평점: 5점 만점 중 4.6점\n\n강좌 강사: Rob Percival\n\n\n<div class=\"content-ad\"></div>\n\n수강료: $56\n\n이 과정을 구매하면 온 디맨드 비디오 강의 45시간 이상, 기사 157편, 그리고 다운로드 가능한 교육 자료 1개에 평생 접근할 수 있습니다.\n\n이 과정에 가입하려면 다음 링크를 클릭하세요 — The Complete Ruby On Rails 개발자 과정\n\n![course image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_5.png)\n\n<div class=\"content-ad\"></div>\n\n## 6. 파이썬을 활용한 완벽한 머신러닝 코스 [Udemy]\n\n이 훌륭한 코스를 통해 Python, SVM, 회귀 및 비지도 학습을 활용하여 12개의 머신러닝 프로젝트 포트폴리오를 만들 수 있습니다.\n\n코스 기간: 18 시간\n\n코스 평점: 5점 만점 중 4.4점\n\n<div class=\"content-ad\"></div>\n\n강의 강사: Rob Percival\n\n수업 가격: $56\n\n이 강좌의 가장 좋은 점은 Python, SVM, 회귀, 비지도 학습 및 기타를 사용하여 12개의 기계 학습 프로젝트 포트폴리오를 만들 수 있다는 것입니다!\n\n다음은 이 강좌에 가입할 수 있는 링크입니다 — Python을 이용한 완벽한 머신 러닝 강좌\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_6.png)\n\n## 7. The Complete WordPress Website Business Course [Udemy]\n\n이 완벽한 워드프레스 과정을 통해 워드프레스를 쉽게 마스터할 수 있습니다. 여기서 중요한 점은 이 모든 것을 하기 위해 코딩이나 프로그래밍을 배울 필요가 없다는 것입니다.\n\n수강 기간: 22시간\n\n\n<div class=\"content-ad\"></div>\n\n코스 평점: 5점 만점에 4.3점\n\n코스 강사: Rob Percival\n\n아래 링크를 통해 이 코스에 참여할 수 있습니다 — The Complete WordPress Website Business Course\n\n![Course Image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_7.png)\n\n<div class=\"content-ad\"></div>\n\n## 8. The Complete Digital Marketing Course — 12 Courses in 1 [Udemy]\n\n이 강좌는 디지털 마케팅 전략, 소셜 미디어 마케팅, SEO, YouTube, 이메일, Facebook 마케팅 및 분석을 습득하는 데 도움이 되는 훌륭한 강좌입니다.\n\n수강 시간: 22 시간\n\n강좌 평점: 5점 만점 중 4.5점\n\n<div class=\"content-ad\"></div>\n\n수강 강사: Rob Percival\n\n수강료: $56\n\n이 강의를 구매하면 온디맨드 비디오 강의 22시간 이상, 기사 35편, 그리고 다운로드 가능한 교육 자료 11개에 평생 접근할 수 있습니다.\n\n이 강의인 The Complete Digital Marketing Course — 12 Courses in 1 에 가입하려면 여기를 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_8.png)\n\n## 9. The Complete Android N Developer Course [Udemy]\n\n이 훌륭한 강의는 안드로이드 앱 개발에 대해 모든 것을 알려줄 것입니다. 안드로이드 7 Nougat를 사용하여 Uber, WhatsApp 및 Instagram과 같은 실제 앱을 구축할 수 있도록 합니다.\n\n수강 시간: 32 시간\n\n<div class=\"content-ad\"></div>\n\n강의 평점: 5점 만점에 4.1점\n\n강의 강사: Rob Percival\n\n강의 가격: $56\n\n이 강의의 최고 장점은 Uber, WhatsApp, Instagram 등의 실제 앱을 만들면서 안드로이드 7 누가 버전에서 안드로이드 앱 개발을 배울 수 있다는 것입니다!\n\n<div class=\"content-ad\"></div>\n\n이 과정에 참여하려면 다음 링크를 클릭해주세요 — The Complete Android N Developer Course\n\n![course image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_9.png)\n\n## 10. The Complete JavaScript Course — Beginner To Professional\n\n제목만 봐도 환상적인 내용처럼 보이죠? 여러분이 JavaScript 개발자가 되기 위해 필요한 유일한 과정입니다. 이 강의에는 45개의 JavaScript 프로젝트, JSON, 그리고 AJAX가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 강좌 정보\n\n- 수업 시간: 35시간\n- 강좌 평점: 5점 만점에 4.7점\n- 강사: Rob Percival\n- 강좌 비용: $56\n\n<div class=\"content-ad\"></div>\n\n간단히 말해서, JavaScript를 배우기 위한 최고의 Udemy 강좌 중 하나입니다. 사실, JavaScript 개발자가 되기 위한 유일한 필수 강좌입니다 — 45개의 JavaScript 프로젝트, ES6, JSON, AJAX 등이 모두 포함되어 있습니다!\n\n다음은 이 강좌에 가입할 수 있는 링크입니다 — The Complete JavaScript Course — Beginner To Professional\n\n![이미지](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_10.png)\n\n# Rob Percvial 자주 묻는 질문들\n\n<div class=\"content-ad\"></div>\n\n이제 학습자들이 Rob Percival과 그의 Udemy 코스에 관해 자주 묻는 질문을 살펴보겠습니다.\n\n## 1. Rob Percival은 누구인가요?\n\nRob Percival은 Udemy 플랫폼에서 가장 자격 있는 강사 중 한 명으로, 코딩을 좋아하는 사람이자 케임브리지 대학에서 수학 학위를 받은 사람입니다. 그는 친구와 가족을 위해 웹 사이트를 만들며 웹 개발의 기초를 배웠습니다. Rob Percival에 대해 더 알고 싶다면 여기를 클릭해보세요.\n\n![image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_11.png)\n\n<div class=\"content-ad\"></div>\n\n## 2. 로브 퍼서벌의 자격은 무엇인가요?\n\n로브 퍼서벌은 아이들에게 코딩을 가르치는 데 열정적입니다. 매년 여름에는 캠브리지라는 아름다운 도시에서 코드 스쿨을 운영합니다. 또한 Eco Web Hosting이라는 매우 인기 있는 웹 호스팅 및 디자인 서비스도 운영하고 있습니다.\n\n## 3. 로브 퍼서벌의 강의를 수강해야 하는 이유는 무엇인가요?\n\nUdemy에서 그의 강의 중 하나를 시도해보면, 저를 포함한 많은 사람들이 그의 강의를 수강하고 추천하는 이유가 왜인지 알게 될 것입니다. 그의 강의는 시장 최고이며, 만약 강의가 별로라고 느끼는 경우에도 편안하게 환불해 드립니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n이상이 2024년에 파이썬과 자바스크립트를 배우기 위한 로브 퍼서벌의 베스트 유데미 강좌에 관한 전부입니다. 이것은 지금까지 로브 퍼서벌이 만든 가장 좋은 강좌들입니다. 이러한 강좌들은 몇 주 만에 완전 초보자에서 자바나 파이썬 전문가로 변모시켜 줄 것입니다.\n\n이 로브 퍼서벌의 베스트 유데미 강좌 10개 목록을 좋아하셨다면, 친구나 가족과 자유롭게 공유해보세요.\n\n다음의 웹 개발 자료도 마음에 드실지도 모릅니다:\n\n<div class=\"content-ad\"></div>\n\n- 풀 스택 웹 개발자가 되기 위한 10가지 최고 강좌\n- 초보자를 위한 Angular 학습용 무료 강좌 10가지\n- 웹 개발자를 위한 최고의 JavaScript 강좌 10가지\n- 2024년 React 개발자 로드맵\n- 40대에 코딩과 웹 개발을 배울 수 있을까요?\n- 2024년 React 학습을 위한 무료 강좌 10가지\n- 2024년까지 풀스택 웹 개발자가 되기 위한 강좌 10가지\n- 모든 소프트웨어 엔지니어가 배워야 할 10가지\n- 2024년에 Node.js를 배우기 위한 내가 좋아하는 강좌\n- HTML과 CSS를 배우기 위한 내가 좋아하는 무료 강좌\n- 2024년에 TypeScript를 배우기 위한 최고의 7가지 강좌\n- 웹 디자인을 위한 Bootstrap 학습용 무료 강좌 7가지\n- 웹 개발을 깊게 공부하기 위한 내가 좋아하는 강좌\n\n이 기사를 읽어 주셔서 감사합니다. 만약 이 Udemy의 최고 강좌들로 HTML, CSS, JavaScript, Angular, ReactJS, Nodejs를 배우는 것을 좋아한다면 친구나 동료와 공유해주세요. 질문이나 피드백이 있으시면 메모를 남겨주시기 바랍니다.\n\n추신: Javascript를 배우고 싶지만 Rob의 강좌의 대안을 찾고 계시다면 Jonas Schmedtmann의 '2024년 완전한 JavaScript 코스: 실전 프로젝트 구축'도 좋은 강좌입니다.","ogImage":{"url":"/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_0.png"},"coverImage":"/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_0.png","tag":["Tech"],"readingTime":9},{"title":"Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내","description":"","date":"2024-06-23 13:45","slug":"2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs","content":"\n\n![OptimizingNext.jsdatarefreshAGuidetoRevalidationwithMedusajs_0](/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png)\n\n안녕하세요! 내부 서버를 사용하여 Next.js 애플리케이션에서 다시 유효성을 설정하는 가이드에 오신 것을 환영합니다. 이 자습서에서는 다양한 다시 유효성 유형을 탐색하고 그들의 보안을 향상하는 방법을 살펴볼 것입니다.\n\n# 왜 다시 유효성 검사가 중요한가요?\n\n다시 유효성 검사는 매 요청마다 소스에서 데이터를 가져오는 것을 피하고 웹 응용 프로그램의 성능을 향상시키기 위해 중요합니다. 기본적으로 Next.js는 fetch를 사용하여 요청을 캐시하며, POST 요청도 포함됩니다. 다시 유효성 검사를 하지 않거나 데이터 캐시를 선택적으로 사용하지 않는 경우, 애플리케이션이 사실상 정적으로 변할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n### 재확인의 두 가지 유형:\n\n- 시간 기반 재확인\n- 요청에 따른 재확인\n\n### 1. 시간 기반 재확인\n\n시간 기반 재확인은 Next.js 애플리케이션의 데이터에 대한 캐시 유효 기간을 설정하는 간단한 방법입니다. 밀리초(millisecond)로 간격을 지정함으로써 데이터가 캐시에서 유효한 기간을 정의할 수 있습니다. 다음은 이를 구현하는 방법입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfetch('https://example.pl/api/products', { next: { revalidate: 3600 } })\n```\n\n이 예제에서 revalidate 옵션이 3600초(1시간)로 설정되어 있습니다. 이는 지정된 API 엔드포인트에서 가져온 데이터가 최대 1시간 동안 신선하다고 간주됨을 의미합니다. 이 기간이 지나면 데이터를 새로 고칠 요청이 이루어집니다.\n\n대안으로 페이지나 구성 요소 파일 자체에서 revalidate 속성을 사용할 수도 있습니다:\n\n```js\n// app/products/page.tsx\n\nexport const revalidate = 3600 // 최대 1시간마다 재검증\n```\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식은 캐시를 주기적으로 업데이트하고 애플리케이션이 지속적인 요청으로 서버를 과부하시키지 않고 최신 데이터를 제공하는 데 특히 유용합니다.\n\n## 2. 요청에 의한 재유효화\n\n요청에 의한 재유효화는 필요할 때만 데이터를 새로 고쳐야 하는 유연성을 제공하며, 이를 캐시 태그나 서버 액션 또는 라우트 핸들러 내에서 특정 경로를 사용하여 달성할 수 있습니다. 아래는 설정 방법입니다:\n\n```js\nexport default async function Page() {\n  const res = await fetch(\n    'https://example.pl/api/products', \n    { next: { tags: ['products'] } } // 이 부분이 마법이 일어나는 곳입니다\n  ) \n  const data = await res.json()\n\n  return (\n  ...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드를 한국어로 번역하면 다음과 같습니다.\n\nNext.js에서 라우트 핸들러를 만들어보겠습니다\n\n```js\n// app/api/revalidate/[tag]/route.ts\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n) {\n  const tag = params.tag\n\n  revalidateTag(tag);\n\n  return NextResponse.json({ revalidated: tag });\n}\n```\n\n이 라우트에 접근할 때 URL http://localhost:3000/api/revalidate/products를 사용하면 캐시를 삭제하고 최신 데이터로 다시 가져옵니다.\n\n내부 서버에서 다시 유효성을 검증하는 방법\n\n<div class=\"content-ad\"></div>\n\n우리의 라우트 핸들러를 개선하여 쿼리 매개변수에 비밀 키를 포함시키는 것이 좋겠어요. 이렇게 하면 권한이 있는 사용자만 재확인 프로세스를 수동으로 트리거할 수 있습니다.\n\n```js\n// app/api/revalidate/[tag]/route.ts\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n) {\n  const tag = params.tag\n  // 검색 매개변수에서 비밀 키 가져오기\n  const secret = request.nextUrl.searchParams.get('secret');\n\n  // 비밀 키 확인\n  if (secret !== process.env.REVALIDATE_SECRET) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  revalidateTag(tag);\n\n  return NextResponse.json({ revalidated: tag });\n}\n```\n\n환경 변수에 REVALIDATE_SECRET도 추가해주세요:\n\n```js\n// .env\nREVALIDATE_SECRET=supersecret_revalidate_key\n```\n\n<div class=\"content-ad\"></div>\n\n이제 Medusa.js를 사용하고 있다고 가정하고 서버로 이동하여 각 제품 업데이트마다 구독자를 구현해 봅시다.\n\n```js\n// src/subscribers/product.ts\nimport axios from \"axios\";\n\nclass ProductSubscriber {\n  constructor({ eventBusService }) {\n    eventBusService.subscribe(\n      \"product.created\",\n      this.revalidateOnDemand\n    );\n    eventBusService.subscribe(\n      \"product.updated\",\n      this.revalidateOnDemand\n    );\n    eventBusService.subscribe(\n      \"product.deleted\",\n      this.revalidateOnDemand\n    );\n  }\n\n  revalidateOnDemand = async () => {\n    await axios.post(process.env.FRONTEND_REVALIDATE_URL/products, {\n      params: {\n        secret: process.env.FRONTEND_REVALIDATE_SECRET\n      },\n    });\n  };\n}\n\nexport default ProductSubscriber;\n```\n\n`.env` 파일에 다음 변수들을 포함시키세요.\n\n```js\n// .env\nREVALIDATE_SECRET=supersecret_revalidate_key\nFRONTEND_REVALIDATE_URL=http://localhost.3000/api/revalidate\n```\n\n<div class=\"content-ad\"></div>\n\n# 마무리\n\n이러한 전략을 활용하여 성능 최적화와 데이터 신선도 사이의 균형을 유지할 수 있습니다. URL 매개변수에 비밀 키를 추가하여 권한이 있는 사용자만 수동 재확인을 트리거할 수 있도록하는 것은 귀하의 애플리케이션의 보안을 강화합니다.\n\n본 문서가 도움이 되었기를 바랍니다.\n\n읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png"},"coverImage":"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png","tag":["Tech"],"readingTime":4},{"title":"React Router에 대해 알아보기 사용 방법과 주요 기능 ","description":"","date":"2024-06-23 13:44","slug":"2024-06-23-LearnaboutReactRouter","content":"\n\n리액트는 단일 페이지 애플리케이션(SPA)에서 리액트 라우터를 기반으로 합니다.\n\n안녕하세요, 이 DIY 프로젝트에 오신 것을 환영합니다.\n\n시작하기 전에, 먼저 제 소개를 드리겠습니다. 저는 시니어 개발자이자 아키텍트입니다.\n\n이 작업을 시작하기 전에 사전 요구 사항을 나열해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n- 노드가 설치되었는지 확인해주세요 (설치되어 있지 않은 경우 여기를 클릭해주세요).\n\n위에 언급된 요구 사항이 있는지 확인해주세요.\n\nReact Router가 무엇인가요? 사용해야 하는 이유는 무엇인가요?\n\nReact Router는 React를 위한 라우터 관리자로, 즉 컴포넌트의 렌더링을 제어합니다.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션 내에 SignIn, SignUp, Home, Dashboard와 같은 컴포넌트가 있는 간단한 예를 가정해보겠어요. 사용자 상호작용에 따라 한 번에 한 컴포넌트만 나타나도록 설정되어 있어요.\n\n예를 들어, 사용자가 로그인하려면 SignIn 컴포넌트를 렌더링하고, 계정을 만들고 싶다면 SignUp 컴포넌트가 될 거예요. 그렇다면 렌더링을 어떻게 관리할까요?\n\n브라우저에서는 이를 경로를 사용하여 이루어낼 수 있어요. 예를 들어, https://medium.com/`path`\n\n여기서 예를 들어, https://medium.com/signin이라면 SignIn을 렌더링하세요.\n\n<div class=\"content-ad\"></div>\n\nReact Router가 등장하여 이러한 조건을 제어할 수 있게 됩니다. 여기서 React 라우터를 사용하기 시작하려면 먼저 React 앱을 가져와야 합니다. 아래는 이 멋진 GitHub - jherr/create-mf-app: CLI app to create Module Federation applications를 사용해 기본 React 애플리케이션을 만드는 방법에 대한 내용입니다. 자세한 정보 및 이 명령을 사용하여 React를 생성하는 이유에 대해 알아보려면 여기를 클릭해주세요.\n\n```js\n# 웹팩으로 React 생성하기\nnpx create-mf-app\n```\n\nNVM을 사용하여 노드 버전을 최신 버전으로 설정했습니다. NVM에 대해 더 자세히 알아보려면 여기를 클릭해주세요.\n\n<div class=\"content-ad\"></div>\n\n\n![React Router](/assets/img/2024-06-23-LearnaboutReactRouter_0.png)\n\n앱 프로젝트 유형을 선택했고, 포트 번호는 기본값 8080으로 남겼습니다. 선택한 프레임워크는 리액트이며 이 부분에서 자유롭게 놀아보세요.\n\n![코드베이스](/assets/img/2024-06-23-LearnaboutReactRouter_1.png)\n\n이제 로컬호스트:8080에서 실행 중인 리액트 애플리케이션이 준비되었습니다. 폴더와 컴포넌트의 코드베이스를 살펴보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-LearnaboutReactRouter_2.png\" />\n\n<img src=\"/assets/img/2024-06-23-LearnaboutReactRouter_3.png\" />\n\n## React Router Dom 설치\n\n이제 npm i react-router-dom을 설치해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-LearnaboutReactRouter_4.png\" />\n\n앱 컴포넌트에서는 전체 애플리케이션을 BrowserRouter로 래핑해 봅시다.\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { \n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\n\nconst App = () => (\n  <div className=\"container\">\n    <h1>App Component</h1>\n  </div>\n);\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>\n);\n```\n\n# React Router를 사용한 기본 라우팅\n\n<div class=\"content-ad\"></div>\n\n리액트 라우터는 `Routes /`와 `Route /` 컴포넌트를 제공하며 경로에 기반하여 컴포넌트를 렌더링합니다:\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  Route,\n  Routes,\n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\n\nconst App = () => (\n  <div className=\"container\">\n    <h1>App Component</h1>\n  </div>\n);\n\nconst Login = () => (\n  <div className=\"container\">\n    <h1>Login Component</h1>\n  </div>\n);\n\nconst AppRoute = () => {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<App />} />\n      <Route path=\"/login\" element={<Login />} />\n    </Routes>\n  )\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  <BrowserRouter>\n    <AppRoute />\n  </BrowserRouter>\n);\n```\n\n위의 코드 조각을 설명하자면, react-router-dom에서 세 가지를 import 했습니다: Route, Routes, BrowserRouter 이 세 가지가 모여 라우터 마법을 수행합니다.\n\nBrowserRouter — 앱 전체를 제어하는 기본 래퍼입니다.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션의 경로 목록 및 경로와 요소를 함께 나열한 루트입니다.\n\n루트 - 경로와 요소를 매핑하는 개별 항목\n\n## 경로를 나타내는 일반 JavaScript 객체\n\nReact 컴포넌트에서 react-router-dom에 있는 후크와 함수형 컴포넌트로 이를 구현할 수 있습니다. \n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  useRoutes,\n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\n\nconst App = () => (\n  <div className=\"container\">\n    <h1>App Component</h1>\n  </div>\n);\n\nconst Login = () => (\n  <div className=\"container\">\n    <h2>Login Component</h2>\n  </div>\n);\n\nconst AppRoute = () => {\n  const routes = useRoutes([\n    {\n      path: \"/\",\n      element: <App />\n    },\n    {\n      path: \"/login\",\n      element: <Login />\n    }\n  ]);\n  return routes;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  <BrowserRouter>\n    <AppRoute />\n  </BrowserRouter>\n);\n```\n\n와우!! 기본 설정 로직을 완료했습니다. 어려움이 있거나 소스 코드를 보려면 여기를 클릭하세요\n\n# 공개 및 보호된 라우트\n\n보호된 라우트는 Private Routes로도 알려져 있으며 일부 사용자의 액세스 수준에 따라 특정 경로에 대한 액세스를 제한하는 기본 개념입니다.\n\n<div class=\"content-ad\"></div>\n\n이에 대해 알아보려면 먼저 Outlet에 대해 배워야 합니다. 이것들은 다시 말해 React Routers에서 옵니다.\n\nOutlet은 기본적으로 React가 라우터 구성에 따라 표시해야 하는 적절한 구성 요소로 대체하는 요소입니다.\n\n그게 무슨 말인지 이해하지 못했다면 걱정하지 마세요. 먼저 SimpleLayout과 DashboardLayout을 구현하는 예제 스니펫을 아래에서 살펴보겠습니다.\n\n## SimpleLayout\n\n<div class=\"content-ad\"></div>\n\n```js\n# src/layouts/SimpleLayout\nimport { useOutlet } from \"react-router-dom\";\n\nconst SimpleLayout = () => {\n  const outlet = useOutlet();\n\n  return (\n    <div className=\"container\">\n      {outlet}\n    </div>\n  )\n\n}\n\nexport default SimpleLayout\n```\n\n저는 SimpleLayout 컴포넌트의 outlet을 얻기 위해 useOutlet 훅을 사용했습니다. 이를 일반적인 앱에서는 헤더, 푸터 및 내비게이션 바 컴포넌트로 감쌌습니다.\n\n## DashboardLayout\n\n```js\nimport { Link, Navigate, Outlet } from \"react-router-dom\";\n\nconst DashboardLayout = () => {\n  const isLoggedIn = () => {\n    // 인증 로직이 여기에 들어갑니다\n    return Math.floor(Math.random() * 10) < 8\n  };\n\n  if (!isLoggedIn()) {\n    alert('isLoggedIn 함수가 로그인하지 않은 사용자를 반환하는 예시')\n    return <Navigate to=\"/login\" />;\n  }\n\n  return (\n    <div className=\"container\">\n      <nav>\n        <Link to=\"/dashboard\">대시보드 홈</Link>\n        <br />\n        <Link to=\"/dashboard/settings\">대시보드 설정</Link>\n      </nav>\n      <Outlet />\n    </div>\n  )\n\n}\n\nexport default DashboardLayout\n```\n\n<div class=\"content-ad\"></div>\n\n로그인 여부 확인하는 함수가 맞게 동작하지 않습니다. 이 예시에서는 랜덤 값을 사용하여 참 또는 거짓을 무작위로 반환하도록 했습니다.\n\n`Outlet`은 `useOutlet` 훅을 사용한 것과 같은 역할을 합니다.\n\n`!isLoggedIn()`은 이 부분에서 실패하면 사용자가 `/login`으로 이동하게 되며, 이는 SimpleLayout 컴포넌트로 이동합니다. 사용자를 브라우저에서 이동시키기 위해 Navigate 컴포넌트를 사용하여 사용자를 리디렉션시킵니다.\n\n우리는 개인 및 보호된 경로를 처리하기 위한 레이아웃을 준비했습니다.\n\n<div class=\"content-ad\"></div>\n\nRoutes 및 Route에 Simple 및 Dashboard 레이아웃을 사용하도록 지원을 추가해 보겠습니다.\n\n## 레이아웃 지원과 라우트, 라우트 패턴\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  Route,\n  Routes,\n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\nimport DashboardLayout from \"./Layouts/Dashboard\";\nimport SimpleLayout from \"./Layouts/Simple\";\n\nconst App = () => (\n  <div className=\"container\">\n    <h1>App Component</h1>\n  </div>\n);\n\nconst Login = () => (\n  <div className=\"container\">\n    <h2>Login Component</h2>\n  </div>\n);\n\nconst Dashboard = () => (\n  <div className=\"container\">\n    <h2>Dashboard Home Component</h2>\n  </div>\n);\n\nconst Settings = () => (\n  <div className=\"container\">\n    <h2>Settings Component</h2>\n  </div>\n);\n\nconst AppRoute = () => {\n  return (\n    <Routes>\n      <Route path=\"\" element={<SimpleLayout />}>\n        <Route index path=\"\" element={<App />} />\n        <Route path=\"/login\" element={<Login />} />\n      </Route>\n      <Route path=\"/dashboard\" element={<DashboardLayout />}>\n        <Route index path=\"\" element={<Dashboard />} />\n        <Route path=\"settings\" element={<Settings />} />\n      </Route>\n    </Routes>\n  )\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  <BrowserRouter>\n    <AppRoute />\n  </BrowserRouter>\n);\n```\n\n대시보드 및 설정 구성요소가 DashboardLayout 내에서 어떻게 렌더링되는지 이해하는 방법은 Route 구성 요소 자체에 route를 자식으로 보내는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n더 간단히 설명하면\n\n```js\n<Route path=\"/dashboard\" element={<DashboardLayout />}>\n  <Route index path=\"\" element={<Dashboard />} />\n</Route>\n```\n\n위와 같은 구조로 전달됩니다. `Route index path=”” element='`Dashboard /`' /` prop으로 전달되며, DashboardLayout 내에서 isLoggedIn 상태를 확인하여 `Dashboard` 컴포넌트를 렌더링합니다.\n\n가독성을 높이기 위해 아래 섹션에서 직접 Dashboard를 객체 내의 children 키에 넣는 방식을 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n## Layout Support with Plain JS Object Route patterns\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  useRoutes,\n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\nimport DashboardLayout from \"./Layouts/Dashboard\";\nimport SimpleLayout from \"./Layouts/Simple\";\n\nconst App = () => (\n  <div className=\"container\">\n    <h1>App Component</h1>\n  </div>\n);\n\nconst Login = () => (\n  <div className=\"container\">\n    <h2>Login Component</h2>\n  </div>\n);\n\nconst Dashboard = () => (\n  <div className=\"container\">\n    <h2>Dashboard Component</h2>\n  </div>\n);\n\nconst Setting = () => (\n  <div className=\"container\">\n    <h2>Setting Component</h2>\n  </div>\n);\n\nconst AppRoute = () => {\n  const routes = useRoutes([\n    {\n      path: '/',\n      element: <SimpleLayout />,\n      children: [\n        {\n          index: true,\n          element: <App />\n        },\n        {\n          path: '/login',\n          element: <Login />\n        }\n      ]\n    },\n    {\n      path: '/dashboard',\n      element: <DashboardLayout />,\n      children: [\n        {\n          index: true,\n          element: <Dashboard />\n        },\n        {\n          path: 'settings',\n          element: <Setting />\n        }\n      ]\n    }\n  ]);\n  return routes;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  <BrowserRouter>\n    <AppRoute />\n  </BrowserRouter>\n);\n```\n\n이를 따라 했을 때 앱이 어떻게 보여야 하는지에 대한 스크린샷을 첨부합니다. [GitHub 레포지토리 링크](GitHub Repo Link)\n\n만약 마음에 드신다면, 이 블로그에 대해 몇 번의 클랩을 더 클릭해주시면 정말 좋겠습니다. 이를 통해 저의 작업에 더 많은 동기부여를 할 수 있습니다. 아래 내용도 좋아하실 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 테이블 태그를 바꿀게요.\n\n\n| 제목                                             | 작성자          | 날짜       | 플랫폼  |\n|--------------------------------------------------|-----------------|------------|---------|\n| Dockerize any Application in seconds              | Akhshy Ganesh   | Jun, 2024 | Medium  |\n| Must know GitHub Commands for Developers          | Akhshy Ganesh   | Jun, 2024 | Medium  |\n| MacOS Home Brew Guide. MacOS without home brew is nightmare | Akhshy Ganesh | Jun, 2024 | Medium  |\n","ogImage":{"url":"/assets/img/2024-06-23-LearnaboutReactRouter_0.png"},"coverImage":"/assets/img/2024-06-23-LearnaboutReactRouter_0.png","tag":["Tech"],"readingTime":10},{"title":"React 앱 도커라이징 코드 예제로 간단하게 따라 하는 단계별 가이드","description":"","date":"2024-06-23 13:43","slug":"2024-06-23-DockerizingaReactAppAStep-by-StepGuidewithCodeExample","content":"\n\n<img src=\"/assets/img/2024-06-23-DockerizingaReactAppAStep-by-StepGuidewithCodeExample_0.png\" />\n\n프로페셔널한 리액트 개발자로서, 리액트 앱을 도커화하는 것은 시간을 절약하고 개발 프로세스를 효율적으로 만드는 중요한 기술입니다. 도커는 애플리케이션과 의존성을 하나의 컨테이너로 패키징할 수 있게 해주는 컨테이너화 도구입니다. 도커는 개발 환경을 일관되게 만드는 데 매우 유용하며 복잡한 설치 및 구성 프로세스를 없애줍니다.\n\n본문에서는 코드 예시와 함께 리액트 앱을 도커화하는 과정을 안내합니다. 간단한 Create React App으로 만든 리액트 앱을 사용하여 리액트 애플리케이션을 컨테이너화하는 방법을 보여줄 것입니다.\n\n# 전제 조건\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에, 저희가 컴퓨터에 다음 사전 준비물이 설치되어 있는지 확인해야 합니다:\n\n- Docker — 공식 웹사이트에서 다운로드할 수 있어요.\n- Node.js — 공식 웹사이트에서 다운로드할 수 있어요.\n\n# 단계 1: 리액트 앱 만들기\n\n먼저 Create React App을 사용해 간단한 리액트 앱을 만들어 봅시다. 터미널을 열고 다음 명령어를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx create-react-app my-react-app\n```\n\n이 명령어를 실행하면 my-react-app 이라는 이름의 새 React 앱이 생성됩니다.\n\n# 단계 2: React 앱 빌드하기\n\n앱이 생성되면 Dockerize하기 전에 빌드해야 합니다. 터미널을 열고 앱의 루트 디렉토리로 이동한 다음 다음 명령어를 실행하십시오:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm run build\n```\n\n이 명령어를 실행하면 앱을 빌드하고 Docker로 제공할 정적 자산이 포함된 build 디렉토리가 생성됩니다.\n\n# 단계 3: Dockerfile 생성\n\n다음으로 앱의 루트 디렉토리에 Dockerfile을 생성해야 합니다. Dockerfile은 앱이 실행될 환경을 지정하는 데 사용됩니다. 좋아하는 텍스트 편집기를 열고 앱의 루트 디렉토리에 Dockerfile이라는 새 파일을 생성해주세요. 파일에 다음 코드를 추가해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\r\n# 베이스 이미지 지정\nFROM node:alpine\r\n```\n\n```js\r\n# 작업 디렉토리 설정\nWORKDIR /app\n# package.json과 package-lock.json 파일 복사\nCOPY package*.json ./\n# 종속성 설치\nRUN npm install\n# 앱 파일 복사\nCOPY . .\n# 앱 빌드\nRUN npm run build\n# 포트 노출\nEXPOSE 3000\n# 앱 실행\nCMD [\"npm\", \"start\"]\r\n```\n\n이 Dockerfile은 노드의 가벼운 버전인 node:alpine을 베이스 이미지로 지정합니다. 우리는 작업 디렉토리를 /app으로 설정하고, package.json 및 package-lock.json 파일을 복사하고, 종속성을 설치하며, 앱 파일을 복사하고, 앱을 빌드하고, 포트 3000을 노출합니다. 마지막으로, npm start로 앱을 실행할 수 있도록 명령을 설정합니다.\n\n# 단계 4: Docker 이미지 빌드하기\n\n<div class=\"content-ad\"></div>\n\n이제 Dockerfile이 준비되었으니 Docker 이미지를 빌드하는 데 사용할 수 있습니다. 터미널을 열고 앱의 루트 디렉토리로 이동한 다음 다음 명령을 실행하세요:\n\n```js\ndocker build -t my-react-app-image .\n```\n\n이 명령은 my-react-app-image라는 태그가 붙은 Docker 이미지를 빌드합니다.\n\n# 단계 5: Docker 컨테이너 실행\n\n<div class=\"content-ad\"></div>\n\n도커 이미지를 빌드했으면, 도커 컨테이너를 실행할 수 있어요. 터미널을 열고 다음 명령어를 실행해주세요:\n\n```js\ndocker run -p 3000:3000 my-react-app-image\n```\n\n이렇게 하면 도커 컨테이너가 시작되고, 당신의 컴퓨터의 3000번 포트를 컨테이너의 3000번 포트에 매핑해줍니다. 이제 웹 브라우저를 열고 http://localhost:3000 으로 이동하여 React 앱을 확인할 수 있어요.\n\n# 단계 6: 도커화된 React 앱 테스트하기\n\n<div class=\"content-ad\"></div>\n\n도커화된 React 앱이 작동 중인지 확인하려면 웹 브라우저를 열고 http://localhost:3000으로 이동하십시오. 도커 컨테이너 내에서 React 앱이 실행 중인 것을 볼 수 있어야 합니다.\n\n# 단계 7: 도커 이미지 게시\n\n마침내, 우리는 도커 이미지를 Docker Hub 또는 Amazon ECR과 같은 컨테이너 레지스트리에 게시할 수 있습니다. 다른 개발자들이 자신의 프로젝트에서 이미지를 사용하기 쉬워집니다. 이미지를 Docker Hub에 게시하려면 다음 단계를 따르세요:\n\n- 이미 계정이 없다면 Docker Hub 계정을 만드세요.\n- 터미널에서 docker login 명령을 사용하여 Docker Hub에 로그인하세요.\n- 다음 명령을 사용하여 Docker 이미지에 Docker Hub 사용자 이름 및 앱 이름을 태그하세요.\n\n<div class=\"content-ad\"></div>\n\n다음 명령어를 사용하여 Docker 이미지를 Docker Hub에 푸시하세요:\n\n- docker push your-docker-hub-username/my-react-app-image:latest\n\n이제 Docker 이미지가 Docker Hub에 사용 가능해졌습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 글에서는 간단한 예제를 활용하여 React 앱을 Docker화하는 방법을 배웠습니다. Dockerfile을 만들고 Docker 이미지를 빌드하며 Docker 컨테이너를 실행하는 방법을 살펴보았습니다. 또한 Docker화된 앱을 테스트하고 Docker 이미지를 Docker Hub에 게시했습니다. React 앱을 Docker화하면 개발 프로세스를 간소화하고 다른 개발자와 앱을 공유하기가 더 쉬워집니다. 이 지식을 활용하여 여러분만의 React 앱을 Docker화하고 컨테이너화가 제공하는 다양한 이점을 활용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-DockerizingaReactAppAStep-by-StepGuidewithCodeExample_0.png"},"coverImage":"/assets/img/2024-06-23-DockerizingaReactAppAStep-by-StepGuidewithCodeExample_0.png","tag":["Tech"],"readingTime":4},{"title":"React로 대용량 데이터를 빠르게 렌더링하는 방법","description":"","date":"2024-06-23 13:42","slug":"2024-06-23-Reducerenderingtimewithlargedatainreact","content":"\n\n\n![img](/assets/img/2024-06-23-Reducerenderingtimewithlargedatainreact_0.png)\n\n# 소개\n\n현대 웹 개발에서 성능이 매우 중요합니다. 웹 애플리케이션이 복잡해지고 데이터 양이 증가함에 따라 효율적인 렌더링을 관리하는 것이 중요해집니다. React 애플리케이션의 성능을 개선하기 위한 한 가지 효과적인 기술은 가상화입니다. 이 글에서는 가상화가 무엇인지, 왜 중요한지, React 애플리케이션에서 어떻게 구현하는지 알아보겠습니다.\n\n# 가상화란 무엇인가?\n\n\n<div class=\"content-ad\"></div>\n\n웹 개발에서 가상화는 DOM에서 보이는 부분만 렌더링하고 나머지는 메모리에 유지하는 기술을 말합니다. 이 접근 방식은 DOM 노드의 수를 크게 줄여 렌더링 성능을 향상시키고 전체 사용자 경험을 향상시킵니다.\n\n# 왜 가상화인가요?\n\n# 성능 상의 이점\n\n- 메모리 사용량 감소: 일부 항목만 렌더링하므로 메모리 소비를 최소화할 수 있습니다.\n- 렌더링 시간 단축: 더 적은 DOM 노드는 더 빠른 렌더링 시간을 의미하며, 반응이 더 빠른 UI를 제공합니다.\n- 부드러운 스크롤링: 가상화를 통해 대용량 데이터 세트에서도 부드러운 스크롤링 경험을 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 사용 사례\n\n- 대량 목록 또는 테이블: 어드민 대시보드나 데이터 분석 도구와 같이 대량의 테이블 데이터를 표시하는 애플리케이션.\n- 무한 스크롤링: 사용자가 스크롤할 때 계속로드되는 콘텐츠가 있는 소셜 미디어 피드나 뉴스 웹사이트.\n\n# React에서 가상화 구현하기\n\n# 프로젝트 설정하기\n\n<div class=\"content-ad\"></div>\n\n가상화를 보여주기 위해, react-virtualized 라이브러리를 사용하여 간단한 리액트 애플리케이션을 만들어보려고 합니다.\n\n## 단계 1: 리액트 애플리케이션 생성\n\n```js\nnpx create-react-app react-virtualization-example\ncd react-virtualization-example\nnpm install react-virtualized\n```\n\n## 단계 2: 기본 컴포넌트 설정\n\n<div class=\"content-ad\"></div>\n\n가상 목록을 표시하는 컴포넌트를 만들어보세요.\n\n```js\n// src/VirtualizedList.js\nimport React from 'react';\nimport { List } from 'react-virtualized';\nimport 'react-virtualized/styles.css'; // 한 번만 가져오면 됩니다.\n```\n\n```js\nconst VirtualizedList = ({ items }) => {\n  const rowRenderer = ({ key, index, style }) => (\n    <div key={key} style={style} className=\"list-item\">\n      {items[index]}\n    </div>\n  );\n  return (\n    <List\n      width={300}\n      height={600}\n      rowCount={items.length}\n      rowHeight={50}\n      rowRenderer={rowRenderer}\n    />\n  );\n};\nexport default VirtualizedList;\n```\n\n# 가상 컴포넌트 통합\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: 앱에서 가상화된 컴포넌트 사용하기\n\n```js\n// src/App.js\nimport React from 'react';\nimport VirtualizedList from './VirtualizedList';\n```\n\n```js\nconst App = () => {\n  const items = Array.from({ length: 1000 }, (_, index) => `아이템 ${index + 1}`);\n  return (\n    <div className=\"App\">\n      <h1>가상화된 목록 예제</h1>\n      <VirtualizedList items={items} />\n    </div>\n  );\n};\nexport default App;\n```\n\n# 가상화된 목록 향상하기\n\n<div class=\"content-ad\"></div>\n\n## 단계 4: 스타일 추가하기\n\n시각화를 더 향상시키기 위한 기본적인 스타일을 추가해보세요.\n\n```js\n/* src/App.css */\n.list-item {\n  padding: 10px;\n  border-bottom: 1px solid #ccc;\n  background-color: #fff;\n}\n```\n\n# 고급 사용법\n\n<div class=\"content-ad\"></div>\n\n## 단계 5: 가상 목록 커스터마이징하기\n\nreact-virtualized의 고급 기능인 동적 행 높이, 무한 스크롤 등을 탐색해보세요.\n\n```js\nimport React from 'react';\nimport { InfiniteLoader, List, AutoSizer } from 'react-virtualized';\n```\n\n```js\nconst InfiniteVirtualizedList = ({ loadMoreRows, isRowLoaded, rowCount }) => {\n  const rowRenderer = ({ key, index, style }) => (\n    <div key={key} style={style} className=\"list-item\">\n      {`아이템 ${index + 1}`}\n    </div>\n  );\n  return (\n    <InfiniteLoader\n      isRowLoaded={isRowLoaded}\n      loadMoreRows={loadMoreRows}\n      rowCount={rowCount}\n    >\n      {({ onRowsRendered, registerChild }) => (\n        <AutoSizer>\n          {({ height, width }) => (\n            <List\n              height={height}\n              width={width}\n              onRowsRendered={onRowsRendered}\n              ref={registerChild}\n              rowCount={rowCount}\n              rowHeight={50}\n              rowRenderer={rowRenderer}\n            />\n          )}\n        </AutoSizer>\n      )}\n    </InfiniteLoader>\n  );\n};\nexport default InfiniteVirtualizedList;\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n가상화는 대량 데이터 집합을 다루는 리액트 애플리케이션의 성능을 향상시키는 강력한 기술입니다. 보이는 항목만 렌더링함으로써 앱의 효율성과 응답성을 크게 향상시킬 수 있습니다. react-virtualized와 같은 도구를 사용하면 이 기술을 구현하기 쉽고 다양한 사용 사례에 맞는 기능을 제공합니다.\n\n# 참고 자료\n\n- react-virtualized 문서\n- React 공식 문서","ogImage":{"url":"/assets/img/2024-06-23-Reducerenderingtimewithlargedatainreact_0.png"},"coverImage":"/assets/img/2024-06-23-Reducerenderingtimewithlargedatainreact_0.png","tag":["Tech"],"readingTime":4}],"page":"10","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}