{"pageProps":{"posts":[{"title":"웹 컴포넌트에서 커스텀 상태의 숨겨진 힘","description":"","date":"2024-06-23 13:03","slug":"2024-06-23-TheHiddenPowerofCustomStatesForWebComponents","content":"\n\n사용자 정의 요소의 진화 과정에서 중요한 단계\n\n![image](/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png)\n\n이전에 썼던 \"웹 컴포넌트가 이제 네이티브 폼 요소가 될 수 있게 되었고\"와 \"웹 컴포넌트의 네이티브 폼 유효성 검사\"라는 기사에서, ElementInternals 속성에 대해 설명했었어요. 이 속성을 통해 사용자 정의 요소가 양식과 관련되도록 할 수 있게 되었죠.\n\n이 인터페이스는 또한 개발자들이 사용자 정의 상태와 사용자 정의 요소를 연관시킬 수 있도록 하며, 이 상태에 기반하여 스타일을 입힐 수 있게 해줍니다.\n\n<div class=\"content-ad\"></div>\n\nElementInternals의 states 속성은 사용자 지정 요소가 있는 상태를 나타내는 CustomStateSet을 반환합니다. 이 CustomStateSet은 집합에 추가 및 제거를 가능하게 합니다.\n\n집합의 각 상태는 문자열로 표시되며 현재 그에는 두 가지 유형의 구문이 있습니다:\n\n- 이전 구문: --mystate (향후 지원 중단 예정)\n- 새로운 구문: mystate\n\n이러한 상태는 내장된 상태와 마찬가지로 사용자 지정 상태 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 선택된 체크박스는 내장된 :checked 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n```js\ninput[type=”checkbox”]:checked {\n outline: solid green;\n}\n```\n\n다른 예로, 비활성화된 버튼은 :disabled 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n```js\nbutton:disabled {\n cursor: not-allowed;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n비슷하게, 사용자 정의 상태를 포함하는 요소는 다음과 같은 방식으로 CSS에서 액세스할 수 있습니다:\n\n```js\n/* 이전 구문 */\nmy-element:--mystate {\n  color: red;\n}\n\n/* 새 구문 */\nmy-element:state(mystate) {\n  color: red;\n}\n```\n\n# 사용자 정의 상태의 사용 사례\n\n사용자 정의 상태는 강력한 기능을 해제합니다.\n\n<div class=\"content-ad\"></div>\n\n내부 상태에 기반을 둔 Web Components의 스타일링을 지원하기 때문에 이러한 상태를 반영하기 위해 컴포넌트에 속성이나 클래스를 추가할 필요가 없어요. 따라서 완전히 내부적으로 유지됩니다.\n\n예를 들어, `video-player` 컴포넌트가 있고 이 컴포넌트는 비디오를 재생하는 데 사용되는 재생 버튼을 표시합니다.\n\n재생 버튼을 클릭하면 비디오가 재생되고, 이 때 재생 버튼이 숨겨지고 일시 정지 버튼이 표시되기를 원합니다.\n\n그런 후 일시 정지 버튼을 클릭하면 이 버튼이 숨겨지고 재생 버튼이 다시 표시되어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n이 작업을 간단히 수행하는 방법은 플레이 속성을 소개하고 해당 속성을 반영하고 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 것입니다.\n\n```js\nclass VideoPlayer extends HTMLElement {\n\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({mode: 'open'});\n\n    shadowRoot.innerHTML = `\n      <style>\n        :host {\n          display: block;\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        :host([playing]) #play {\n          display: none;\n        }\n\n        :host([playing]) #pause {\n          display: block;\n        }\n      </style>\n\n      <button id=\"play\" type=\"button\">Play</button>\n      <button id=\"pause\" type=\"button\">Pause</button\n    `;\n  }\n\n  connectedCallback() {\n    const playButton = this.shadowRoot.querySelector('#play');\n    const pauseButton = this.shadowRoot.querySelector('#pause');\n\n    playButton.addEventListener('click', () => {\n      this.playing = true;\n    });\n\n    pauseButton.addEventListener('click', () => {\n      this.playing = false;\n    });\n  }\n\n  get playing() {\n    return this.hasAttribute('playing');\n  }\n\n  set playing(isPlaying) {\n    if(isPlaying) {\n      this.setAttribute('playing', '');\n    }\n    else {\n      this.removeAttribute('playing');\n    }\n  }\n}\n```\n\n기본적으로 재생 버튼이 표시됩니다. 플레이 속성을 위한 설정자가 정의되어 해당 속성을 설정하거나 제거하며 CSS 규칙은 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 역할을 합니다.\n\n아래에 작동하는 예제가 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n이 방법은 잘 작동하지만 이 구현에 잠재적인 문제가 있을 수 있어요.\n\n이렇게 내부 속성을 속성으로 노출하는 것은 항상 바람직하지 않을 수 있고 캡슐화를 깨버릴 수 있어요.\n\n이 경우 playing 속성을 노출하는 것은 나쁜 생각은 아닐 수 있지만, 이는 사용자가 그냥 속성을 추가함으로써 컴포넌트를 재생 상태로 수동 설정할 수 있지만, 실제로 비디오가 재생되는 것은 아니라는 점이에요.\n\n이 속성을 노출함으로써 사용자가 playing 속성을 추가하기만 하면 비디오를 재생할 수 있다는 기대감조차 줄 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n사실 특정 상태의 웹 컴포넌트를 설정하기 위해 속성을 추가하는 것은 해당 상태를 설정하는 것이 아니기 때문에 playing 속성을 true로 설정하지 않습니다. playing 속성에 playing 속성을 추가하는 것만으로 playing 속성을 true로 설정하지는 않습니다.\n\n이 경우 실제로 심각한 피해를 입히지는 않겠지만 내부 속성을 노출하는 것이 좋지 않은 경우가 항상 있을 수 있습니다.\n\n이것은 사용자 정의 상태에 대한 완벽한 사용 사례입니다. 속성은 노출되지 않지만 이러한 상태에 기반한 CSS 스타일을 사용하여 컴포넌트를 여전히 스타일링할 수 있습니다.\n\n# 사용자 정의 상태 추가 및 제거\n\n<div class=\"content-ad\"></div>\n\n언급한 바와 같이 모든 사용자 지정 상태는 ElementInternals 인터페이스의 states 속성에 저장된 CustomStateSet 객체에 저장됩니다.\n\n상태를 추가하고 제거하는 데 사용되는 add 및 delete 메서드와 요소가 특정 상태를 갖고 있는지 확인하는 has 메서드가 있습니다.\n\n다른 주목할 만한 메서드로는 모든 상태를 지우는 clear 및 요소의 모든 상태를 반복하는 forEach가 있습니다:\n\n```js\n// 내부 구현 부착\nthis.internals = this.attachInternals();\n\n// 상태 추가 예전 문법\nthis.internals.states.add('--foo');\n\n// 상태 추가 새 문법\nthis.internals.states.add('bar');\n\n// 상태 반복\nthis.internals.states.forEach(state => {\n console.log(state); // foo bar\n});\n\n// 상태 제거 예전 문법\nthis.internals.states.delete('--bar');\n\n// 상태 제거 새 문법\nthis.internals.states.delete('bar');\n\n// 상태 존재 여부 확인 예전 문법\nthis.internals.states.has('--foo'); // true\nthis.internals.states.has('--bar'); // false\n\n// 상태 존재 여부 확인 새 문법\nthis.internals.states.has('foo'); // true\nthis.internals.states.has('bar'); // false\n```\n\n<div class=\"content-ad\"></div>\n\n브라우저에서 오래된 구문만 지원하는 경우 --로 시작하지 않는 상태를 추가하려고 할 때 오류가 발생합니다:\n\n```js\nthis.internals = this.attachInternals();\nthis.internals.states.add('foo'); // 오류, '--'로 시작하지 않음 (오래된 구문만 지원)\n```\n\n이전 예제가 사용자 정의 상태와 함께 작동하도록 하려면 `playing` 속성의 게터 및 세터를 상태와 함께 작동하도록 변경해야 합니다. 이를 오래된 및 새로운 구문을 지원하는 브라우저에서 작동하도록 하려면 --없이 상태를 설정하는 것은 try/catch 블록으로 감싸야 합니다:\n\n```js\nget playing() {\n  return this.internals.states.has('--playing') || this.#internals.states.has('playing');\n}\n\nset playing(isPlaying) {\n  if(isPlaying) {\n    try {\n      this.internals.states.add('playing');\n    }\n    catch(e) {\n      this.internals.states.add('--playing');\n    }\n  }\n  else {\n   this.internals.states.delete('playing');\n   this.internals.states.delete('--playing');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경했습니다.\n\n```js\n/* 이전 구문 */\nhost(:--playing) #play {\n  display: none;\n}\n\n/* 이전 구문 */\n:host(:--playing) #pause {\n  display: block;\n}\n\n/* 새로운 구문 */\nhost(:state(playing)) #play {\n  display: none;\n}\n\n/* 새로운 구문 */\n:host(:state(playing)) #pause {\n  display: block;\n}\n```\n\n내부 속성이 속성으로 노출되지 않도록 하는 것은 좋지만, 여전히 소비자가 내부 속성을 통해 상태에 액세스하고 add 및 delete 메서드를 호출하여 상태를 추가하거나 제거할 수 있습니다:\n\n```js\nconst player = document.querySelector('video-player');\n\n// 이전 구문\nplayer.internals.states.add('--playing');\n\n// 새로운 구문\nplayer.internals.states.add('playing');\n```\n\n<div class=\"content-ad\"></div>\n\n더 좋지 않은 점은 소비자가 내부 상태를 변경하기 위해 playing의 setter를 호출할 수 있다는 것입니다.\n\n이를 수정하여 getter와 setter 및 내부 속성을 모두 #으로 접두사를 붙여 private로 만들 수 있습니다:\n\n```js\n// internals is now private\nthis.#internals = this.attachInternals();\n\nget playing() {\n  return this.#internals.states.has('--playing') || this.#internals.states.has('playing');\n}\n\nset playing(isPlaying) {\n  if(isPlaying) {\n    try {\n      this.#internals.states.add('playing');\n    }\n    catch(e) {\n      this.#internals.states.add('--playing');\n    }\n        \n  }\n  else {\n   this.#internals.states.delete('playing');\n   this.#internals.states.delete('--playing');\n  }\n}\n```\n\nprivate 속성에 대한 getter와 setter 쌍을 작성하는 것이 직관적이지 않을 수 있지만, 이것이 실제로 작동한다는 것에 주목하세요.\n\n<div class=\"content-ad\"></div>\n\n비록 playing에 getter와 setter가 정의되어 있지만, 여전히 private이며 클래스 내에서만 접근 가능합니다.\n\n값을 할당하면 setter가 호출되고 값을 읽으면 getter가 호출됩니다.\n\n아래에 전체 코드가 있습니다:\n\n```js\nclass VideoPlayer extends HTMLElement {\n  #internals;  // private property를 필요로 하는 클래스 필드\n\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({mode: 'open'});\n\n    this.#internals = this.attachInternals();\n\n    shadowRoot.innerHTML = `\n      <style>\n        :host {\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        /* 예전 문법 */\n        :host(:--playing) #play {\n          display: none;\n        }\n\n        :host(:--playing) #pause {\n          display: block;\n        }\n\n        /* 새로운 문법 */\n        :host(:state(playing)) #play {\n          display: none;\n        }\n\n        :host(:state(playing)) #pause {\n          display: block;\n        }\n      </style>\n\n      <button id=\"play\" type=\"button\">재생</button>\n      <button id=\"pause\" type=\"button\">일시정지</button>\n    `;\n  }\n\n  connectedCallback() {\n    const playButton = this.shadowRoot.querySelector('#play');\n    const pauseButton = this.shadowRoot.querySelector('#pause');\n\n    playButton.addEventListener('click', () => {\n      this.#playing = true;\n    });\n\n    pauseButton.addEventListener('click', () => {\n      this.#playing = false;\n    });\n  }\n\n  get playing() {\n    return this.#internals.states.has('--playing') || this.#internals.states.has('playing');\n  }\n\n  set playing(isPlaying) {\n    if(isPlaying) {\n      try {\n        this.#internals.states.add('playing');\n      }\n      catch(e) {\n        this.#internals.states.add('--playing');\n      }\n    }\n    else {\n      this.#internals.states.delete('playing');\n      this.#internals.states.delete('--playing');\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 여기에는 오래된 구문과 새 구문 둘 다 작동하는 작동 예제가 있습니다:\n\n이 예제들은 커스텀 상태에 기반하여 커스텀 요소를 내부 컴포넌트 내에서 :host 가상 클래스를 사용하여 스타일링하는 방법을 보여줍니다.\n\n커스텀 요소는 사용자 정의 상태에 기반하여 외부에서 스타일링될 수도 있습니다.\n\n이 스타일링은 :checked나 :hover와 같은 내장 상태에 기반하여 구성 요소를 스타일링하는 것과 동일한 형태를 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* 예전 구문 */\nvideo-player:--playing {\n  border: 1px solid red;\n}\n\n/* 새로운 구문 */\nvideo-player:state(playing) {\n  border: 1px solid red;\n}\n```\n\n같은 CSS 속성에 대한 사용자 지정 상태를 기반으로 스타일 지정이 내부와 외부에서 모두 정의된 경우, 외부에서 정의된 스타일이 우선합니다.\n\n다음 예제에서 컴포넌트는 --playing/playing 사용자 지정 상태일 때 녹색 테두리가 추가됩니다.\n\n--playing/playing 상태에 대해 컴포넌트 내부에서 정의된 파란색 테두리는 덮어씌워집니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 컴포넌트 외부에서 정의된 스타일\n// 이렇게 하면 컴포넌트에 녹색 테두리가 우선적으로 적용됩니다.\n// 이전 구문\nvideo-player:--playing {\n  border: 2px solid green;\n}\n\n// 새로운 구문\nvideo-player:state(playing) {\n  border: 2px solid green;\n}\n\n// 컴포넌트 내부에서 정의된 스타일\n// 외부에서 정의된 스타일에 덮어씌워지게 됩니다.\n// 이전 구문\n:host(:--playing) {\n  border: 2px solid blue;\n}\n\n// 새로운 구문\n:host(:state(playing)) {\n  border: 2px solid blue;\n}\n```\n\n# 결론\n\n사용자 정의 상태(Custom States)는 웹 컴포넌트의 진화를 위한 중요한 단계입니다.\n\n이를 통해 컴포넌트의 상태를 속성이나 클래스를 추가하지 않고도 스타일링할 수 있어 외부에서 상태를 조작할 수 없도록 유지할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n커스텀 상태는 Chrome, Edge, Safari Tech Preview 187에서는 CustomStateSet 기능 플래그가 활성화되어 있고, Firefox 122에서는 dom.element.customstateset.enabled가 true로 설정되어 있을 때 지원됩니다.\n\n현대 웹 플랫폼, 웹 컴포넌트, 그리고 Progressive Web Apps에 관한 제 주간 뉴스레터 'Modern Web Weekly'에 가입해보세요.","ogImage":{"url":"/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png"},"coverImage":"/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png","tag":["Tech"],"readingTime":11},{"title":"상위 1 웹 개발자가 되기 위해 꼭 가져야 할 10가지 기술","description":"","date":"2024-06-23 13:02","slug":"2024-06-23-10must-haveskillstobecomeatop1webdeveloper","content":"\n\n\n![Image](/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png)\n\n웹 개발자가 반드시 갖추어야 할 10가지 필수 기술…\n\n이미 알고 있을 수 있는 웹 기초부터 시작하여 브라우저 개발 도구를 활용하고 AI로 빠르게 코딩하는 것과 같은 중요한 기술까지 배워보세요.\n\n이론적 지식보다는 실제 행동에 초점을 맞춘 것을 알 수 있죠 — 왜냐하면 그것이 중요하기 때문입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 1. HTML essentials: Create a basic functional web page\n\n웹 사이트의 핵심 뼈대에 대해 알아보세요.\n\n다음과 같이 진행해보세요:\n\n- 편집기에서 HTML 페이지를 만들고 브라우저에서 엽니다\n- 페이지 제목 및 아이콘 설정\n- 텍스트 단락 만들기\n- 제목 만들기\n- 다른 페이지로 연결하는 링크 만들기\n- 이미지 표시\n- 테이블 데이터 표시\n- 요소 목록 표시\n- 폼을 사용하여 입력 처리\n- 주석 만들기 및 코드 주석 처리\n- 시맨틱 HTML로 페이지를 더 유의미하게 만들기\n\n<div class=\"content-ad\"></div>\n\n일부 사람들은 CSS 때문에 시맨틱 HTML이 무의미하다고 생각하지만, 그들은 틀렸어요.\n\n접근성과 페이지 내용을 검색 엔진에 설명하여 결과 페이지에서 높은 순위를 얻는 데 여전히 중요합니다.\n\n\n![image](/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_1.png)\n\n\n시맨틱 요소가 없다면, 모든 것에 'div'를 사용하는 개발자들처럼 될 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 2. CSS 핵심: 웹 페이지 스타일링\n\n이렇게 변화시킬 수 있어요:\n\n![Before and after](/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_2.png)\n\n<div class=\"content-ad\"></div>\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*OjV0rbJN2AKW1VAh.gif)\n\n뼈대에 생명을 불어넣는 방법:\n\n- 페이지에 스타일 추가하기\n- 색상 추가: 채우기, 그라데이션, 불투명도, 전경 및 배경 색상\n- 글꼴 사용자 정의: 글꼴 패밀리, 크기, 스타일, 두께, 웹 안전한 글꼴, Google Fonts\n- 레이아웃 만들기: 여백 및 안팎 간격, 시각적 쌓임, 상대적 정렬\n- 배경 추가 및 사용자 정의\n- 애니메이션 및 전환으로 더 매력적으로 꾸미기\n- 특정 상태 및 요소 부분에 스타일 적용: 가상 선택자 및 가상 클래스\n- 모양 사용자 정의: 외곽선 및 테두리, 높이, 너비\n- 스타일 재사용: CSS 변수\n- 모든 화면 크기에 대해 멋지게 보이도록 페이지 스타일링하기: 미디어 쿼리, 반응형 이미지\n- 프레임워크로 더 빨리 스타일링하기: Tailwind, Sass\n\n<div class=\"content-ad\"></div>\n\n# 3. JavaScript essentials\n\n웹 페이지에 상호 작용성을 추가하고 일어나는 일들을 만드는 방법:\n\n# 기본 사항\n\n코딩을 처음 시작하신 분들에게:\n\n<div class=\"content-ad\"></div>\n\n어떻게:\n\n- 프로그래밍에 대해 생각해보기\n- 페이지에 JavaScript 코드 추가\n- 출력하기: alert(), innerHTML, console logging\n- 데이터 관리하기 — 변수 만들기, 사용하기, 업데이트하기, 출력하기: 데이터 타입, 스코프\n- 주석 작성하기 및 기존 코드를 주석 처리하기\n- 동작 재사용하기: 함수 만들기 및 호출하기: 구문, 매개변수 및 인자, 반환 값, 타입, 스코프\n- 현실 세계 엔티티를 나타내는 객체들 생성하기: 데이터 및 변수, 동작 및 메소드, 중첩된 객체\n- 페이지의 요소 선택 및 조작하기: getElementById, querySelector, 메소드 및 속성 사용 등\n- 입력 및 이벤트 처리하기: 웹 페이지에서 등\n- 문자열로 텍스트 조작하기: 여러 줄, 부분 문자열, 대소문자, 연결, 보간, 분할 및 결합, 자르기 및 채우기, 검색 및 대체, 정규 표현식\n- 목록 사용하기: 초기화, 추가, 업데이트, 제거, 반복, 변환, 검색, 필터, 정렬, 역순\n- 날짜와 시간 사용하기: 생성, 업데이트, 형식화 및 표시\n- 조건부로 데이터 가져오거나 동작하기: if/else, switch, 삼항 연산자, 사전 선택\n- 조건부로 계속해서 동작하기: while, do while, for, break, continue\n- TypeScript로 개발 환경 업그레이드하기: 타입, 제네릭, 인터페이스, 트랜스 파일링, 구성 설정 등.\n\n# 클라이언트 측 개발\n\n당신은 코딩 기초를 알고 계시겠지만, 브라우저에 특히적인 JS 코드를 작성할 수 있나요?\n\n<div class=\"content-ad\"></div>\n\n아래와 같은 방법으로:\n\n- 서버에 네트워크 요청을 보내는 방법: fetch() API, HTTP 동사, 데이터 전송 및 수신\n- UI 상태 다루기: 비어 있는 상태, 로딩 중인 상태, 오류가 발생한 상태, 일부만 화면에 나타낸 상태, 이상적인 상태\n- 데이터를 로컬에 저장하기: 쿠키, 로컬 저장소, 세션 저장소 등\n- 코드를 구성하고 패키지화하는 방법: 모듈 및 모듈 번들러\n- 폼 입력 처리하기\n- NPM 패키지를 사용하여 더 빠르게 코딩하는 방법\n\n# 4. 개발 도구로 삶의 질 개선하기\n\n아래와 같은 방법으로:\n\n<div class=\"content-ad\"></div>\n\n- 콘솔 로그를 만들고 검사하고 필터링하세요: 정보, 오류, 경고\n- 임시 스크립트 및 작업을 추가하세요\n- HTML 요소를 검사, 선택, 및 디버그하세요\n- 스타일을 임시로 수정하세요\n- 네트워크 요청을 모니터링하세요\n- 여러 화면 크기에서 페이지를 테스트하세요\n- 더 빨리 개발하기 위해 편집기 확장 기능을 설치하세요\n- 편집기 테마, 글꼴 및 설정을 사용자 정의하여 개발을 더 즐기세요\n- 통합된 디버거를 사용하세요\n- Emmet을 포함한 스니펫을 사용하여 더 빠르게 코드를 작성하세요\n- 키보드 단축키를 사용하여 더 빨리 개발하세요\n- AI를 사용하여 더 빨리 개발하세요\n\n# 5. 사이트 성능 향상\n\n방법:\n\n- 성능을 측정하세요\n- 인지 성능을 향상시키세요\n- 핵심 웹 핵심 지표 개선: LCP, CLS, INP\n- 일반적인 리소스 전달을 최적화하세요: 캐싱,\n- 이미지를 최적화하세요: 압축, WebP\n- 이미지와 비디오를 지연 로드하세요\n- CSS를 최적화하세요\n- 웹 글꼴을 최적화하세요: 압축, 스와핑 등.\n\n<div class=\"content-ad\"></div>\n\n# 6. 자바스크립트 프레임워크: 빠르게 개발하기\n\nReact, Angular 또는 Vue인 경우에 관계없이 모두 동일한 기본 개념을 가지고 있습니다.\n\n다음 방법에 대해 알아 봅시다:\n\n- 컴포넌트를 생성하고 재사용합니다\n- 컴포넌트에서 데이터를 수락하고 표시합니다: 데이터 바인딩, 조건부 렌더링 등\n- 컴포넌트에서 상태를 관리합니다\n- 목록 데이터를 표시하고 업데이트합니다\n- 컴포넌트에서 이벤트를 처리합니다\n- 부작용 및 외부 데이터 변경 및 상태 변경을 처리합니다\n- 앱-수준 상태를 관리합니다 — 컴포넌트와 독립적으로\n- 폼 입력을 처리합니다\n- 컴포넌트를 스타일링합니다\n- 프론트엔드 라우팅을 사용한 SPA 네비게이션을 처리합니다\n\n<div class=\"content-ad\"></div>\n\n# 7. 버전 컨트롤: 변경 사항 추적\n\n버전 컨트롤을 사용하면 코드베이스 전체의 변경 사항을 추적하고 실험하는 것이 쉬워집니다.\n\n방법:\n\n- 로컬 저장소를 만들어 코드 및 에셋을 저장합니다.\n- 파일 및 변경 사항을 스테이징하고 커밋합니다: 최선의 방법, 등.\n- .gitignore를 사용하여 파일 무시\n- 이전 커밋 가져오기\n- 새 브랜치 생성: 최신 또는 이전 커밋에서\n- 브랜치 병합: 병합 충돌 해결 등.\n\n<div class=\"content-ad\"></div>\n\n# Git & GitHub\n\n다음을 참고하세요:\n\n- 자신의 GitHub 레포지토리 만들기: README.md, 라이센스 등\n- 원격 저장소 사용하기: 만들기, 푸시, 풀, 제거\n- GitHub에서 레포지토리 복제하기\n- GitHub 레포지토리 포크하기\n- GitHub 레포지토리에 풀 리퀘스트 만들기\n\n# 8. 데이터베이스에서 데이터 관리하기\n\n<div class=\"content-ad\"></div>\n\n프론트엔드에 전념하고 있더라도 데이터 처리 및 조작에 대한 이해력을 향상시킬 수 있습니다.\n\n다음을 하는 방법:\n\n- 데이터를 위한 스키마 설계\n- 스키마 구현: 테이블, 키, 데이터 형식, 외래 키, 컬렉션 (NoSQL)\n- 데이터베이스에 데이터 추가\n- 데이터 읽기: 조인, 필터링, 정렬, 검색, 집계\n- 데이터 업데이트\n- 데이터 삭제\n\n# 9. 서버 측 개발\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n- 필요 시 빠르게 학습하기\n- 코드에서 독립적으로 문제 해결하기\n- 디자이너, 클라이언트 및 다른 개발자와 소통하기\n- 디버그하고 인내심을 갖기\n- 필요에 따라 정보를 검색하고 필요에 맞게 처리하기\n\n# 마무리\n\n이 모든 것을 배우면 웹 앱과 사이트의 99%를 높은 품질과 빠른 속도로 처음부터 끝까지 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png"},"coverImage":"/assets/img/2024-06-23-10must-haveskillstobecomeatop1webdeveloper_0.png","tag":["Tech"],"readingTime":5},{"title":"React로 카운트다운 타이머 만드는 방법","description":"","date":"2024-06-22 15:35","slug":"2024-06-22-BuildingaCountdownTimerinReact","content":"\n\n\n![Countdown Timer](/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png)\n\nReact 애플리케이션에 동적 카운트다운 타이머를 추가해보고 싶었나요? 생산성 앱을 만들고 있거나 라이브 이벤트를 진행하거나 웹사이트를 화려하게 꾸미고 싶은 경우, 카운트다운 타이머는 매력적이고 기능적인 추가물이 될 수 있습니다. 이 기사에서는 React.js를 사용하여 간단하면서도 강력한 1시간 카운트다운 타이머를 구축하는 방법에 대해 살펴보겠습니다.\n\n# 시작하기\n\n코드에 들어가기 전에, 우리가 달성하려는 목표를 명확히 해 봅시다. 우리의 목표는 실시간으로 업데이트되는 시각적으로 매력적인 카운트다운 타이머를 만드는 것입니다. 이 타이머는 1시간부터 0까지 카운트다운됩니다. 이를 달성하기 위해 우리는 인기 있는 React 라이브러리와 useState 및 useEffect 훅을 활용할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 카운트다운 컴포넌트\n\n시작해봅시다. 카운트다운 타이머 컴포넌트를 만들어봅시다. 이 컴포넌트는 카운트다운 논리와 렌더링을 캡슐화할 것입니다.\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nconst CountdownTimer = () => {\n  // 초기 시간 (1시간 단위)\n  const initialTime = 60 * 60;\n  const [timeRemaining, setTimeRemaining] = useState(initialTime);\n\n  useEffect(() => {\n    const timerInterval = setInterval(() => {\n      setTimeRemaining((prevTime) => {\n        if (prevTime === 0) {\n          clearInterval(timerInterval);\n          // 타이머가 0이 되면 수행할 작업\n          console.log('카운트다운 완료!');\n          return 0;\n        } else {\n          return prevTime - 1;\n        }\n      });\n    }, 1000);\n\n    // 컴포넌트가 언마운트될 때 인터벌 정리\n    return () => clearInterval(timerInterval);\n  }, []); // 빈 의존성 배열은 효과가 마운트 시에 한 번만 실행되도록 함\n\n  // 초를 시간, 분, 초로 변환\n  const hours = Math.floor(timeRemaining / 3600);\n  const minutes = Math.floor((timeRemaining % 3600) / 60);\n  const seconds = timeRemaining % 60;\n\n  return (\n    <div>\n      <p>카운트다운 타이머:</p>\n      <p>{`${hours}시간 ${minutes}분 ${seconds}초`}</p>\n    </div>\n  );\n};\n\nexport default CountdownTimer;\n```\n\n# 카운트다운타이머 컴포넌트 사용하기\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\nimport CountdownTimer from './CountdownTimer';\n\nconst App = () => {\n  return (\n    <div>\n      <h1>React Countdown Timer</h1>\n      <CountdownTimer />\n    </div>\n  );\n};\n\nexport default App;\n```\n\n# 결론\n\nReact와 해당 훅을 이용하여, 유연하고 매력적인 카운트다운 타이머를 제작했습니다. 이를 프로젝트에 손쉽게 통합할 수 있습니다. 스타일링을 맞춤화하거나 음향 효과를 추가하거나, 애플리케이션의 요구 사항에 기반한 추가 기능을 통합하는 자유를 누려보세요.\n\n자, 이제 다음 React 프로젝트에서 시간을 효율적으로 활용해 보세요. 즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingaCountdownTimerinReact_0.png","tag":["Tech"],"readingTime":3},{"title":"실전 HTML과 CSS 빠른 실력 향상을 위한 10개 프로젝트","description":"","date":"2024-06-22 15:35","slug":"2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement","content":"\n\nHTML과 CSS를 숙달하는 것은 시각적으로 매력적인 웹사이트를 만드는 데 그치지 않습니다 — 사용자 경험을 공감시키는 것입니다. 처음부터 시작하든지 기술을 더욱 향상시키는 중이든, 저희가 선별한 10일 가이드는 실전 프로젝트로 학습을 가속화하는 데 도움이 될 것입니다.\n\n1일차: 미디어 쿼리를 사용하여 반응형 네비게이션 바를 만들어, 다양한 화면 크기에 매끄럽게 적응되도록 합시다.\n\n- 프로젝트 1: 드롭다운이 있는 반응형 네비게이션 바\n- 프로젝트 2: 호버 효과가 있는 세련된 네비게이션 바\n- 프로젝트 3: 로고와 메뉴 항목이 있는 네비게이션 바\n- 프로젝트 4: 검색 창이 있는 투명한 네비게이션 바\n- 프로젝트 5: 아이콘 링크가 있는 네비게이션 바\n\n2일차: Flexbox를 사용하여 유연한 항목 위치 지정 및 그리드를 사용하여 구조화된 카드 배열을 디자인하고 구현해보세요.\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트는 나중에 추가될 예정입니다. (22/6/24)\n\nDay 3: CSS Grid을 활용하여 반응형이고 시각적으로 매력적인 고급 레이아웃을 생성하는 데 초점을 맞춘 Grid Stock 프로젝트를 살펴보세요.\n\n- 프로젝트는 나중에 추가될 예정입니다. (23/6/24)\n\nDay 4: 부드러운 전환 효과와 컨트롤을 갖춘 가로 및 세로 이미지 슬라이더를 개발하여 이미지를 쇼케이스하세요.\n\n<div class=\"content-ad\"></div>\n\n- 나중에 프로젝트가 추가될 예정입니다. (24/6/24)\n\n5일차: 다음 튜토리얼에서 프로젝트를 구현해 보세요: https://www.youtube.com/watch?v=NU6BqU67Lv8, 해당 개념을 이해하고 적용에 중점을 두세요.\n\n6일차: 적어도 3–5개의 다른 프로젝트로 푸터의 디자인 및 스타일링을 연습해 보며 레이아웃, 내용 정렬 및 시각적 매력에 실험해 보세요.\n\n- 나중에 프로젝트가 추가될 예정입니다. (26/6/24)\n\n<div class=\"content-ad\"></div>\n\n일일 프로젝트를 수행하면서 링크를 업데이트할 예정입니다. 이를 통해 CSS를 단계별로 숙달하는 데 집중하고, 각 날짜 학습 목표와 일치하는 관련 자습서 및 자료에 액세스할 수 있습니다. 제 진행을 따라가고 최신 업데이트를 확인하려면 정기적으로 방문해주세요. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement_0.png"},"coverImage":"/assets/img/2024-06-22-Hands-OnHTMLandCSS10ProjectsforRapidSkillImprovement_0.png","tag":["Tech"],"readingTime":2},{"title":"HTMX 20 이해하기 웹 개발을 단순화하는 방법","description":"","date":"2024-06-22 15:34","slug":"2024-06-22-UnderstandingHTMX20SimplifyingWebDevelopment","content":"\n\n<img src=\"/assets/img/2024-06-22-UnderstandingHTMX20SimplifyingWebDevelopment_0.png\" />\n\nHTMX 2.0 최근 릴리즈로 인해 복잡한 JavaScript 프레임워크를 쉽게 이해할 수 있는 HTML 속성으로 대체할 수 있는 잠재력에 대한 관심을 끌었습니다. 이 새로운 버전은 웹 개발을 간단하게 만들어 개발자들이 JavaScript에 심취하지 않고도 동적이고 상호작용이 가능한 웹 애플리케이션을 만들 수 있도록 하는 것을 목표로 합니다.\n\n## HTMX란?\n\nHTMX는 개발자들이 AJAX, CSS 전환, 웹소켓 및 서버-보낸 이벤트에 HTML 속성을 통해 직접 액세스 할 수 있도록 하는 라이브러리입니다. 주요 목표는 상호작용을 HTML에서 직접 처리함으로써 JavaScript의 필요성을 줄이고 웹 개발을 더 간단하게 만드는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## HTMX 2.0의 주요 기능\n\n- 향상된 HTML 속성: HTMX는 JavaScript를 작성하지 않고도 HTML 속성을 사용하여 클라이언트 측 상호작용(예: HTTP 요청)을 트리거합니다. 이 접근 방식은 코드를 더 쉽게 읽고 유지보수하기 쉽게 만듭니다.\n- WebSockets 및 SSE 지원: HTMX 2.0은 WebSockets 및 Server-Sent Events (SSE)를 내장 지원하여 실시간 데이터 업데이트 및 클라이언트와 서버 간 통신을 가능하게 합니다.\n- 점진적 향상: HTMX는 점진적 향상의 원칙을 따라 JavaScript가 비활성화되거나 사용자의 브라우저에서 완전히 지원되지 않아도 웹 페이지가 작동하도록 보장합니다.\n- 성능 향상: 클라이언트 측 로직의 많은 부분을 서버로 옮기고 필요한 JavaScript의 양을 줄이면 HTMX는 성능을 향상시키고 더 빠른 로드 시간을 제공할 수 있습니다.\n\n## HTMX 작동 방식\n\nHTMX는 요소의 동작을 정의하기 위해 HTML 속성을 이용합니다. 다음은 일반적인 HTMX 속성 몇 가지입니다:\n\n<div class=\"content-ad\"></div>\n\n- hx-get: 요소를 트리거했을 때 지정된 URL로 GET 요청을 보냄.\n- hx-post: 지정된 URL로 POST 요청을 보냄.\n- hx-trigger: 클릭, 마우스 오버 또는 제출과 같이 요청을 트리거하는 이벤트를 정의함.\n- hx-swap: 응답이 DOM에 삽입되는 방식을 결정함. innerHTML, outerHTML, beforebegin, afterbegin, beforeend, afterend과 같은 옵션이 있음.\n\n예시\n\nHTMX를 활용한 간단한 예시입니다:\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n    <title>HTMX 예시</title>\n    <script src=\"https://unpkg.com/htmx.org\"></script>\n</head>\n<body>\n    <button hx-get=\"/hello\" hx-trigger=\"click\" hx-swap=\"innerHTML\">\n        Click me\n    </button>\n    <div id=\"content\"></div>\n    <script>\n        document.addEventListener('DOMContentLoaded', () => {\n            htmx.on('htmx:beforeRequest', function(evt) {\n                console.log('요청을 보내기 전:', evt.detail);\n            });\n        });\n    </script>\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n이 예에서는 버튼을 클릭하면 /hello로 AJAX GET 요청이 전송됩니다. 서버에서의 응답이 버튼의 내부 HTML을 대체합니다. 이 설정을 통해, AJAX 호출 및 DOM 조작을 처리하기 위한 추가 JavaScript 작성이 필요하지 않습니다.\n\n## HTMX 사용의 장점\n\n- 복잡성 감소: 상호 작용 로직을 HTML로 이동함으로써, HTMX는 JavaScript 중심의 프레임워크와 관련된 복잡성을 줄입니다.\n- 유지보수 용이성: 코드는 HTML에서 요소의 동작이 명확하게 정의되므로 유지보수 및 가독성이 향상됩니다.\n- 성능 향상: 더 많은 작업을 서버로 옮기고 클라이언트 측 JavaScript를 줄이면 성능이 향상되고 로드 시간이 줄어듭니다.\n- 사용자 경험 향상: WebSockets 및 SSE를 통한 실시간 업데이트는 웹 애플리케이션의 응답성과 상호 작용성을 개선합니다.\n\n## Laravel과의 통합\n\n<div class=\"content-ad\"></div>\n\nHTMX를 Laravel 애플리케이션에 신속하게 통합하여 동적 동작을 개선할 수 있습니다. 상당한 복잡성을 추가하지 않고 사용할 수 있어요. 아래는 Laravel 프로젝트에 HTMX를 설정하는 방법에 대한 간략한 개요입니다:\n\n- 설정: Laravel Blade 템플릿에 HTMX 라이브러리를 포함시킵니다.\n- 라우트와 컨트롤러: HTMX가 수행하는 AJAX 요청을 처리하기 위한 라우트 및 컨트롤러를 정의하세요.\n- Blade 템플릿: Blade 템플릿에서 HTMX 속성을 사용하여 AJAX 요청을 트리거하고 페이지 일부를 동적으로 업데이트하세요.\n\n라라벨 예시\n\n다음은 Laravel에서 HTMX를 사용하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\nBlade Template (resources/views/welcome.blade.php)\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Laravel with HTMX</title>\n    <script src=\"https://unpkg.com/htmx.org\"></script>\n</head>\n<body>\n    <button hx-get=\"{ route('getData') }\" hx-trigger=\"click\" hx-target=\"#content\" hx-swap=\"innerHTML\">\n        Get Data\n    </button>\n    <div id=\"content\"></div>\n</body>\n</html>\n```\n\nRoute (routes/web.php)\n\n```js\nRoute::get('/getData', function () {\n    return response()->json(['message' => 'Hello, World!']);\n})->name('getData');\n```\n\n<div class=\"content-ad\"></div>\n\n이 설정은 버튼 클릭이 AJAX 요청을 트리거하여 Laravel 라우트에 전달하고 응답이 추가 JavaScript를 작성하지 않고 div의 내용을 업데이트하는 방법을 보여줍니다.\n\n# 결론\n\nHTMX 2.0은 작업 흐름을 간소화하고 응용 프로그램 성능을 향상시키려는 웹 개발자들에게 흥미로운 개발을 제공합니다. 클라이언트 측 상호 작용을 처리하기 위해 HTML 속성을 활용함으로써, HTMX는 복잡한 JavaScript 프레임워크에 대한 필요성을 줄이고 유지 보수성을 향상시킵니다.\n\n더 많은 독해 및 고급 사용법을 위해서 HTMX 문서를 참조하고 최신 릴리스 및 기능을 확인해 주세요.","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingHTMX20SimplifyingWebDevelopment_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingHTMX20SimplifyingWebDevelopment_0.png","tag":["Tech"],"readingTime":4},{"title":"Position Sticky 문제 해결하기 Overflow Clip으로 Overflow Hidden 문제 해결하는 방법","description":"","date":"2024-06-22 15:33","slug":"2024-06-22-OvercomingPositionStickyIssuesSolvingOverflowHiddenProblemswithOverflowClip","content":"\n\n\n<img src=\"/assets/img/2024-06-22-OvercomingPositionStickyIssuesSolvingOverflowHiddenProblemswithOverflowClip_0.png\" />\n\nPosition sticky는 특정 스크롤 위치에 도달했을 때 요소가 뷰포트에 \"붙어 있는\" CSS 위치 지정 속성입니다. 그러나 CSS overflow 속성과 호환되지 않아 종종 \"overflow: hidden\"을 사용하는 상황에서 문제가 발생합니다. 이로 인해 요소가 \"붙어 있지 않고\" 대신 \"고정된 것처럼\" 행동할 수 있습니다. 그러나 이 문제를 해결하는 방법이 있습니다. 대신 \"overflow: clip\"을 사용하는 것입니다.\n\n이 문제에 대한 자세한 내용과 \"overflow: clip\"이 어떻게 문제를 해결하는 데 도움이 되는지 살펴보겠습니다.\n\nPosition sticky: 간단한 개요\n\n\n<div class=\"content-ad\"></div>\n\n우선, position: sticky가 무엇을 하는지 간략히 살펴봅시다. 요소에 position: sticky를 적용하면 일정 지점을 스크롤하면 \"sticky\"가 됩니다. 이로써 요소가 화면 내에 계속 보이게 할 수 있고, 지나치게 스크롤했을 때에도 그대로 보이게 됩니다. 사용자가 웹 사이트를 스크롤하는 동안 계속 보이게 하고 싶은 내비게이션 바, 헤더 및 기타 요소를 만들 때 유용한 속성입니다.\n\noverflow: hidden 문제점\n\nposition: sticky를 사용할 때, CSS overflow 속성을 \"hidden\" 값과 함께 사용하면 제대로 작동하지 않을 수 있습니다. 이는 “overflow: hidden”이 요소에 새로운 블록 형식화 컨텍스트를 만들기 때문입니다. 이것은 요소의 크기와 위치를 제한하는 컨테이너로 작용하므로 자식 요소의 크기와 위치에 영향을 줍니다.\n\nposition: sticky가 적용된 요소가 \"overflow: hidden\" 속성이 적용된 요소 내에 있을 때, 요소는 뷰포트에 대한 위치를 더 이상 알 수 없어 \"붙지\" 못하는 현상이 발생합니다. 대신, 스크롤하면 화면에서 고정된 위치에 남아 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: overflow: clip\n\n좋은 소식은 이 문제에 대한 간단한 해결책이 있다는 것입니다. “overflow: hidden” 대신에 “overflow: clip”을 사용할 수 있습니다. 이 속성 값은 요소의 콘텐츠를 클립하여 보여주는 방식에서 “overflow: hidden”과 유사하지만 새로운 블록 서식 맥락을 만들지 않습니다. 즉, “overflow: clip”이 적용된 요소 안의 요소들은 “overflow: hidden”과 같은 방식으로 영향을 받지 않습니다.\n\n“overflow: hidden” 대신에 “overflow: clip”을 사용함으로써 position: sticky가 있는 요소가 기대한 대로 작동하도록 할 수 있습니다. 스크롤하면 해당 요소들이 뷰포트에 고정되는 것을 확인할 수 있습니다.\n\n결론\n\n<div class=\"content-ad\"></div>\n\n요약하자면, `position: sticky`는 사용자가 웹사이트를 스크롤할 때 요소가 뷰포트에 \"붙는\" 유용한 CSS 속성입니다. 그러나 \"overflow: hidden\"과 함께 사용할 때 예상치 못한 동작을 일으켜 요소가 제대로 고정되지 못하는 상황이 발생할 수 있습니다. 이 문제를 해결하려면 대신에 \"overflow: clip\"을 사용할 수 있습니다. 새로운 블록 포맷팅 컨텍스트를 생성하지 않고 요소의 콘텐츠를 클립하는 기능을 제공합니다. 이렇게 하면 `position: sticky`가 있는 요소가 예상대로 작동하고 사용자가 그 요소를 스크롤하면 계속 가시적으로 유지됩니다.","ogImage":{"url":"/assets/img/2024-06-22-OvercomingPositionStickyIssuesSolvingOverflowHiddenProblemswithOverflowClip_0.png"},"coverImage":"/assets/img/2024-06-22-OvercomingPositionStickyIssuesSolvingOverflowHiddenProblemswithOverflowClip_0.png","tag":["Tech"],"readingTime":2},{"title":"여러분의 웹사이트를 위해 꼭 필요한 5가지 웹 접근성 기능과 사용자들이 당연히 누려야 할 것들","description":"","date":"2024-06-22 15:32","slug":"2024-06-22-5AccessibilityFeaturesYourWebsiteNeedsandThatYourUsersDeserve","content":"\n\n상위 백만 대 웹사이트 중 95% 이상*의 홈페이지가 기본 접근성 기준을 준수하지 못한다는 사실을 알고 계셨나요? 세계 인구의 16%*가 장애를 가지고 살고 있다고 하니(세계보건기구 기준), 접근성 있는 사용자 경험은 결코 간과되어서는 안 됩니다. 웹사이트의 모든 상호작용은 방문 예정인 모든 사람을 위해 작동해야 합니다.\n\n![image](/assets/img/2024-06-22-5AccessibilityFeaturesYourWebsiteNeedsandThatYourUsersDeserve_0.png)\n\n## 조금의 이해\n\n웹 디자인과 개발 여정 중 사용자 상호작용(UI)과 사용자 경험(UX)은 계획 프로세스의 큰 부분을 차지합니다. UX 요구 사항 수집 과정이나 웹 디자이너를 위한 지침에 접근성 있는 사용자 이야기를 포함하는 것이 매우 중요합니다. 웹 디자인 도구도 좋지만, 이 주제에서는 제한적일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래 고려해야 할 사항 중 일부를 이미 알고 계실 수도 있습니다. Content Management Systems, Documents, 그리고 요즘 대부분의 소셜 미디어에서 보다 일반적으로 사용되는 '대체 텍스트(Alt Tags)'에 대해 말이죠. 사용자가 온라인에서 정보, 제품 또는 서비스를 찾을 때 여기저기서 찾을 수 있습니다.\n\n# 주요 접근성 기능\n\n아마도 이러한 측면 중 일부는 여러분의 웹사이트를 조사해 볼 새로운 통찰력을 제공할 것으로 기대합니다:\n\n## Alt 태그 (또는 대체 텍스트 또는 대체 설명)\n\n<div class=\"content-ad\"></div>\n\n웹 사이트에서 가장 일반적인 접근성 기능입니다. HTML 이미지 마크업 내에 포함되어 있으며, 스크린 리더가 필요한 사용자들이 이미지와 그래픽에 대한 설명을 경험할 수 있도록 합니다.\n\n## 색 대비\n\n색맹부터 저시력자까지, 웹 사이트에 대한 추가적인 스타일링 기능이 중요합니다. 이를 통해 색 대비를 자유롭게 변경할 수 있습니다. 다른 예로, 디스렉시아는 웹 요소의 주의를 산만하게 만드는 것을 줄이거나 제거하고, 밝은(흰색이 아닌) 배경에 더 어두운 글꼴 색상을 사용할 수 있는 옵션을 제공합니다. 이러한 색상 기술을 사용하면 자폐 스펙트럼 질환자에도 도움이 될 수 있습니다.\n\n## 명확한 피드백\n\n<div class=\"content-ad\"></div>\n\n사용자들은 당신의 웹사이트가 잘 반응할 때 잘 반응합니다. 대부분의 상호작용에 쉬운 지침을 제공하는 것이 중요합니다. 또한 직관적인 양식 유효성 검사를 하는 것은 사용자들이 자신의 데이터를 제공할 때 확신을 갖게 합니다. 발생한 오류도 경험의 일부로 사용자가 다음에 무엇을 해야 하는지 안내해야 합니다.\n\n## CSS 웹킷 (레거시 웹 브라우저 지원)\n\n당신의 웹사이트는 멋져 보일 수 있습니다. 팬시한 그라데이션과 클라우드에서 가져온 폰트... 그것은 멋집니다! 그렇지만 사용자들이 오래된 웹 브라우저에 접근하는 것에 제한이 있는 경우 가장 중요합니다. 당신의 CSS가 웹사이트의 스타일링 속성에서 대체할 수 있는 능력을 갖추는 것이 필수입니다.\n\n## 키보드 탐색\n\n<div class=\"content-ad\"></div>\n\n웹사이트를 키보드만 사용해서 쉽게 이동할 수 있는 능력을 갖추세요. 이 기능은 모든 내비게이션과 상호작용 요소에 통합되어야 합니다. 또 다른 고려 사항은 웹 디자인이 접근성 있는 디자인을 방해하는 요소로 의도적으로 요소의 외관을 비활성화하지 않았는지 확인하는 것입니다.\n\n# 웹사이트를 더 나은 상태로 만들기 위해 무엇을 할 수 있을까요?\n\n만약 웹사이트에서 접근성이슈에 대해 확신이 없는 경우, W3C에서 제공하는 무료 마크업 체커를 사용하는 것이 좋은 시작점입니다.\n\n웹 접근성에 관련된 경험이나 질문이 있다면 댓글을 남겨주세요. 다른 사람들로부터 더 많이 배우고 제 지식을 공유하는 것을 즐기고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n* [https://www.acquia.com/blog/accessibility-statistics](https://www.acquia.com/blog/accessibility-statistics)\n* [https://validator.w3.org/](https://validator.w3.org/)","ogImage":{"url":"/assets/img/2024-06-22-5AccessibilityFeaturesYourWebsiteNeedsandThatYourUsersDeserve_0.png"},"coverImage":"/assets/img/2024-06-22-5AccessibilityFeaturesYourWebsiteNeedsandThatYourUsersDeserve_0.png","tag":["Tech"],"readingTime":3},{"title":"Javascript scrollIntoView 메소드 사용 방법","description":"","date":"2024-06-22 15:32","slug":"2024-06-22-JavascriptscrollIntoViewmethod","content":"\n\n\n![scrollIntoView method](/assets/img/2024-06-22-JavascriptscrollIntoViewmethod_0.png)\n\nscrollIntoView는 요소를 뷰포트 안으로 부드럽게 스크롤할 수 있는 자바스크립트 메소드입니다. 이 메소드는 이미 보이는 뷰포트에 요소가 없다면 요소를 보이게 만듭니다. 사용자가 어떤 작업을 수행하거나 애니메이션 효과로 요소를 보여줄 때 유용합니다.\n\nscrollIntoView 메소드는 문서 객체 모델(DOM)의 Element 인터페이스의 일부입니다.\n\nelement.scrollIntoView();\nelement.scrollIntoView([scrollIntoViewOptions]);\n\n<div class=\"content-ad\"></div>\n\nscrollIntoView의 문법에는 2 가지 유형이 있습니다.\n\n이 메소드는 기본 옵션으로 요소를 보이도록 스크롤하는 데 사용됩니다.\n\n이는 요소가 이미 보이지 않은 경우 요소가 포함되어 있는 요소의 맨 위나 뷰포트로 스크롤됩니다.\n\nscrollIntoViewOptions는 뷰포트에서 요소를 스크롤하는 여러 옵션을 지정하는 선택적 객체 속성입니다.\n\n<div class=\"content-ad\"></div>\n\n다음과 같은 속성이 있습니다.\n\n이 속성은 아래 유형을 통해 스크롤의 동작을 정의하는 데 사용됩니다.\n\n가능한 값은\n\n- auto(기본값): 스크롤 동작에 따라 요소를 스크롤합니다.\n- smooth: 부드럽고 애니메이션 효과로 요소를 스크롤합니다.\n- instant: 즉시 요소를 스크롤하여 단일 점프와 동일합니다.\n\n<div class=\"content-ad\"></div>\n\n이 속성은 가시 영역 내 요소의 수직 정렬을 정의하는 데 사용됩니다.\n\n가능한 값은\n\n- start(기본): 요소를 시작 위치에 스크롤합니다.\n- center: 요소를 중앙에 스크롤합니다.\n- end: 요소를 끝에 스크롤합니다.\n- nearest: 수직으로 가장 가까운 가장자리로 스크롤합니다.\n\n이 속성은 가시 영역 내 요소의 수평 정렬을 정의하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 가능한 값들입니다\n\n- start(기본): 요소를 시작 위치에 스크롤합니다.\n- center: 요소를 중앙에 스크롤합니다.\n- end: 요소를 끝에 스크롤합니다.\n- nearest: 수평으로 가장 가까운 가장자리로 스크롤합니다.\n\n## 예시\n\n여기에 scrollIntoView의 다양한 속성 조합에 따라 생성된 3가지 예시가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 1. scrollIntoView() 기본\n\n이것은 요소를 보이는 뷰포인트로 스크롤합니다.\n\n<!DOCTYPE html>\n<html>\n    <style>\n        #container {\n            height: 250px;\n            overflow: auto;\n        }\n        #scroll-div {\n            margin: 500px;\n            height: 800px;\n            background-color: pink;\n        }\n    </style>\n\n    <body>\n        <h1>Javascript scrollIntoView</h1>\n\n        <button onclick=\"myFunction()\">요소로 스크롤하려면 클릭</button>\n\n        <div id=\"container\">\n            <div id=\"scroll-div\">\n                <p>텍스트1</p>\n                <p>텍스트2</p>\n                <p>텍스트3</p>\n            </div>\n        </div>\n\n        <script>\n            function myFunction() {\n                const element = document.getElementById('scroll-div');\n                element.scrollIntoView();\n            }\n        </script>\n    </body>\n</html>\n\n# 2. scrollIntoView() 수직으로\n\n<div class=\"content-ad\"></div>\n\n아래 코드는 요소를 수직으로 화면 안에 스크롤합니다.\n\n<!DOCTYPE html>\n<html>\n    <style>\n        #scroll-div {\n            margin-top: 100px;\n            padding-right: 100%;\n            height: 800px;\n            background-color: pink;\n            overflow: auto;\n        }\n    </style>\n\n    <body>\n        <h1>Javascript scrollIntoView</h1>\n\n        <button onclick=\"myFunction()\">요소를 스크롤하려면 클릭하세요</button>\n\n        <div id=\"scroll-div\">텍스트</div>\n\n        <script>\n            function myFunction() {\n                const element = document.getElementById('scroll-div');\n                element.scrollIntoView({\n                    behavior: 'smooth',\n                    block: 'end',\n                    inline: 'nearest',\n                });\n            }\n        </script>\n    </body>\n</html>\n\n# 3 .scrollIntoView() 수평 방향\n\n이것은 요소를 수평으로 화면 안에 스크롤합니다.\n\n<div class=\"content-ad\"></div>\n\n<!DOCTYPE html>\n<html>\n    <style>\n        #scroll-div {\n            margin-left: 100%;\n            padding-right: 100%;\n            height: 800px;\n            background-color: pink;\n            overflow: auto;\n        }\n    </style>\n\n    <body>\n        <h1>Javascript scrollIntoView</h1>\n\n        <button onclick=\"myFunction()\">Click to scroll the element</button>\n\n        <div id=\"scroll-div\">Text</div>\n\n        <script>\n            function myFunction() {\n                const element = document.getElementById('scroll-div');\n                element.scrollIntoView({\n                    behavior: 'smooth',\n                    block: 'nearest',\n                    inline: 'start',\n                });\n            }\n        </script>\n    </body>\n</html>\r\n\n참고: scrollIntoView 메서드는 요소의 CSS에 많이 의존합니다. 요소에 대한 스크롤 간격에 대한 유효한 CSS를 제공했을 경우에만 예상대로 작동합니다.\n\n이 글을 읽어주셔서 감사합니다. 이 글이 요소 스크롤에 도움이 되기를 바랍니다.","ogImage":{"url":"/assets/img/2024-06-22-JavascriptscrollIntoViewmethod_0.png"},"coverImage":"/assets/img/2024-06-22-JavascriptscrollIntoViewmethod_0.png","tag":["Tech"],"readingTime":4},{"title":"Bootstrap으로 반응형 웹사이트 만드는 방법 Step-by-Step 가이드","description":"","date":"2024-06-22 15:31","slug":"2024-06-22-ProcesstoCreateaResponsiveWebsitewithBootstrap","content":"\n\n\n![image](/assets/img/2024-06-22-ProcesstoCreateaResponsiveWebsitewithBootstrap_0.png)\n\n요즘의 다양한 기기 환경에 반응하는 웹사이트를 만드는 것은 중요합니다. 인기 있는 프론트엔드 프레임워크인 부트스트랩은 강력한 도구와 구성 요소로 이 작업을 더 쉽게 만들어줍니다. 이 기사는 부트스트랩을 사용하여 반응형 웹사이트를 만드는 과정을 안내합니다.\n\n# 부트스트랩 소개\n\n부트스트랩은 무료이며 오픈 소스의 CSS 프레임워크로, 반응형 및 모바일 최우선의 프론트엔드 웹 개발을 대상으로 합니다. CSS 및 JavaScript 기반으로 이루어져 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 부트스트랩을 사용한 반응형 웹사이트 만들기\n\n반응형 웹사이트를 만드는 것은 오늘날의 다양한 디바이스를 고려할 때 중요합니다. 인기 있는 프론트엔드 프레임워크인 부트스트랩은 강력한 도구와 구성 요소로 이 작업을 쉽게 만들어 줍니다. 이 글에서는 부트스트랩을 사용하여 반응형 웹사이트를 만드는 과정을 안내합니다.\n\n## 부트스트랩 소개\n\n부트스트랩은 반응형 및 모바일을 우선으로 하는 프론트엔드 웹 개발을 위한 무료 오픈 소스 CSS 프레임워크입니다. 타이포그래피, 폼, 버튼, 내비게이션 및 기타 인터페이스 구성 요소용 CSS 및 JavaScript 기반 디자인 템플릿이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 부트스트랩 설치하기\n\n## 단계 1: 부트스트랩 다운로드 및 포함\n\n부트스트랩을 사용하려면 프로젝트에 CSS 및 JS 파일을 포함해야 합니다. 부트스트랩은 공식 웹사이트에서 다운로드하거나 CDN 링크를 사용할 수 있습니다.\n\n## 단계 2: 기본 HTML 구조\n\n<div class=\"content-ad\"></div>\n\nHTML 문서의 기본 구조를 작성하고 반응형 웹사이트의 기반을 만들어 보세요.\n\n# 레이아웃 구성\n\n## 단계 3: 그리드 시스템 사용하기 \n\n부트스트랩의 그리드 시스템은 반응형 디자인 기능의 핵심입니다. 컨테이너, 행 및 열 시리즈를 사용하여 콘텐츠를 배치하고 정렬합니다.\n\n<div class=\"content-ad\"></div>\n\n컨테이너: 반응형 너비를 가진 고정폭 컨테이너 또는 전체 너비 컨테이너를 만들려면 .container 또는 .container-fluid를 사용하세요.\n행: 열의 수평 그룹을 만들려면 .row를 사용하세요.\n열: .col-* 클래스를 사용하여 행당 표시할 열의 수를 정의하세요. 부트스트랩은 행당 최대 12개 열을 지원합니다.\n\n## 단계 4: 반응형 이미지 추가\n\n이미지가 반응형으로 유지되도록 하려면 .img-fluid 클래스를 사용하세요. 이렇게 하면 이미지가 다양한 화면 크기에 맞게 적절히 조정됩니다.\n\n# 스타일링과 컴포넌트\n\n<div class=\"content-ad\"></div>\n\n## Step 5: 네비게이션 바\n\n부트스트랩은 기본으로 반응형 네비게이션 바를 제공합니다. .navbar, .navbar-expand-*, 그리고 .navbar-light 또는 .navbar-dark 클래스를 사용하여 반응형 및 사용자 정의 가능한 네비게이션 바를 만들 수 있습니다.\n\n## Step 6: 반응형 유틸리티\n\n부트스트랩에는 화면 크기에 따라 콘텐츠를 표시하거나 숨기기 위한 여러 유틸리티 클래스가 포함되어 있습니다. .d-none, .d-sm-block, 그리고 .d-md-none과 같은 클래스를 사용하여 다양한 기기에서 요소의 가시성을 제어할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 자바스크립트로 향상하기\n\n## 단계 7: 대화형 구성 요소\n\n부트스트랩은 모달, 툴팁, 캐러셀 및 아코디언과 같은 다양한 JavaScript 구성 요소를 제공하여 상호 작용성을 향상시킬 수 있습니다. 이러한 구성 요소는 구현 및 사용자 정의가 쉽습니다.\n\n# 테스트 및 최적화\n\n<div class=\"content-ad\"></div>\n\n## 단계 8: 크로스 브라우저 테스트\n\n웹사이트가 다양한 브라우저와 기기에서 올바르게 보이고 작동하는지 확인하세요. BrowserStack와 같은 도구 또는 브라우저의 개발자 도구의 반응형 디자인 모드를 활용할 수 있습니다.\n\n## 단계 9: 성능 최적화\n\nCSS와 JavaScript 파일을 최소화하고, 반응형 이미지를 사용하며, 브라우저 캐싱을 활용하여 웹사이트의 성능을 최적화하세요.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n부트스트랩은 강력한 그리드 시스템, 다양한 구성 요소 및 유틸리티 클래스를 통해 반응형 웹사이트를 만드는 프로세스를 간단화합니다. 이러한 단계를 따라가면 어떤 기기에서도 멋지게 보이는 반응형, 모바일 우선 웹사이트를 만들 수 있습니다. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-22-ProcesstoCreateaResponsiveWebsitewithBootstrap_0.png"},"coverImage":"/assets/img/2024-06-22-ProcesstoCreateaResponsiveWebsitewithBootstrap_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter에서 복잡한 HTML 처리하는 방법","description":"","date":"2024-06-22 15:30","slug":"2024-06-22-HandlingcomplexHTMLinFlutter","content":"\n## 플러터에서 중첩된 테이블 뷰 표시\n\n<img src=\"/assets/img/2024-06-22-HandlingcomplexHTMLinFlutter_0.png\" />\n\n저는 비즈니스가 모든 메일, SMS, 소셜 미디어 플랫폼을 한 앱에서 연결하고 고객 커뮤니케이션을 관리하는 통합 메시징 수신함 애플리케이션인 Helpwise 애플리케이션을 개발 중입니다.\n\n앱의 기능 중 하나는 Gmail 수신함을 연결하여 모든 이메일을 같은 앱에서 받는 것입니다. Helpwise는 지금까지 모든 이메일 스레드를 표시하기 위해 웹 뷰를 사용해 왔기 때문에 지금까지 어떤 문제도 발생하지 않았습니다.\n\n<div class=\"content-ad\"></div>\n\n웹뷰를 네이티브 플러터 코드로 이동하기로 결정했어요, 즉 앱 자체에서 이메일 데이터를 처리하기로 했어요. 내 지식으로는 HTML 데이터를 쉽게 처리하고 flutter_html 패키지를 사용해 HTML을 렌더링할 수 있다고 생각했어요.\n\n간단해 보이죠? 어떤 문제가 발생할 수 있을까요? 😂\n\n하지만 그렇게 간단하지 않아요. 코드를 구현한 후 대부분의 이메일이 잘 보이지만 뉴스레터, 서명 및 테이블이 전혀 나타나지 않았어요.\n\n전 정말 깜짝 놀랐어요. 웹에 대한 지식이 전혀 없어 어떻게 이를 해결할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n저는 전체 웹을 검색해보니 해당 패키지가 복잡한 테이블을 제대로 처리하지 못하는 것을 발견했고, HTML을 렌더링하기 위해 패키지가 TABLE_SECTION을 표시하여 해당 영역을 표시한다는 것을 알았어요.\n\n이 버그는 2021년 3월에 열렸으며 아직 해결되지 않았습니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:888/1*rCkV8LeAQf6Wiizx0ljAsQ.gif\" />\n\n도와주실 수 있나요? 지금 제가 할 수 있는 일이 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n## 해결책 1\n\n첫 번째 해결책은 html_editor_enhanced를 사용하는 것이었습니다. 이는 텍스트 편집기로 HTML 코드를 삽입하여 편집기를 뷰 전용 위젯으로 사용하는 방법입니다.\n\n해결책을 시도해보았지만 왜 작동하지 않았을까요?\n\n편집기가 비활성화되어 있더라도 특정한 높이를 지정해주어야 합니다. 필요한 높이를 주면 이메일의 보기 영역이 제한됩니다.\n\n<div class=\"content-ad\"></div>\n\n당신이 없슴을 알겠는데, 함께 수정하면 된다고 생각해요! 😊 계속해서 함께 문제를 해결해 나가보자구요! 🚀\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:996/1*mEstF6mH4U8BXs7z40YxhA.gif\" />\n\n저는 선배와 문제를 논의하면서, 합의할 수 있는 해결책을 찾으려고 노력했어요. 그때 갑자기 그가 제안한 것이라구요\n\n이게 뭐야? HTML을 Webview에서 렌더링할 수 있을 줄 몰랐어? Webview를 표시하려면 URL이 필요한 것 아니었어?\n\n지금 알게 된 건가봐요 😅\n\n<div class=\"content-ad\"></div>\n\n## 실제 해결책\n\n그래서 우리가 어떻게 구현했는지 봅시다,\n\n우리는 flutter_inappwebview 패키지를 사용했어요\n\nHTML을 렌더링하고 완벽하게 작동했어요.\n\n<div class=\"content-ad\"></div>\n\n모두 읽어주셔서 감사합니다......😍😍\n\n아직 읽고 계신다면 쉽지 않군요 😅\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*IEsaQG2ZpzqelL3T1bUVQg.gif)\n\nHTML을 표시하는 것은 가능했지만 특정 높이를 증명해야 했습니다. 즉, 사용자는 전체 내용을 보려면 이메일 내에서 스크롤해야 하는데, 심지어 리스트뷰 빌더 내에서도 그렇습니다.\n\n<div class=\"content-ad\"></div>\n\n## 이제 웹뷰 높이를 동적으로 조절해야 할까요?\n\n수 시간 동안 검색한 끝에 웹뷰의 높이를 얻기 위해 특정 HTML 코드를 추가하는 StackOverflow 쓰레드를 찾았어요.\n\n하지만 문제는 이 해결책을 적용한 후에, 일부의 경우 높이가 0으로 표시되고 오류도 표시되지 않았어요. 초기 높이를 설정하면 이메일을 볼 수 있지만요.\n\n지금은 HTML 코드가 문제인 것 같아요. 우리는 플러터에 친숙하니까요.\n\n<div class=\"content-ad\"></div>\n\n## 단계 2 — 높이 일관되게 가져오기\n\n웹뷰 높이를 인쇄할 수 있는지 확인할 때 콘솔 로그를 추가하여 높이를 출력했는데, 놀랍게도 매번 올바른 높이를 얻었습니다.\n\n그러자 왜 그냥 로그를 가져와서 두 배로 변환하고 사용하지 않을까 생각했죠. 간단하죠?\n\n결국 그랬더니 딱 맞았습니다 😅\n\n<div class=\"content-ad\"></div>\n\n```js\nAnimatedContainer(\n  duration: Duration(milliseconds: 500),\n  height: height + (height == 0 ? 0 : 50),\n  child: InAppWebView(\n    initialData: InAppWebViewInitialData(data: html),\n    initialOptions: InAppWebViewGroupOptions(\n      crossPlatform: InAppWebViewOptions(\n        supportZoom: false,\n        javaScriptEnabled: true,\n        disableHorizontalScroll: false,\n        disableVerticalScroll: true,\n      ),\n    ),\n    onLoadError: (controller, url, code, message) =>\n        print(\"onLoadError: $url, $code, $message\"),\n    onLoadHttpError:\n        (controller, url, statusCode, description) => print(\n            \"onLoadHttpError: $url, $statusCode, $description\"),\n    onConsoleMessage: (controller, consoleMessage) {\n      print('height: ${height}');\n      height = double.parse(consoleMessage.message);\n      setState(() {});\n    },\n  ),\n);\n```\n\n```js\nhtml = \"\"\"\n<html lang=\"en\">\n  <meta name=\"viewport\" content=\"width=device-width user-scalable=no zoom=1.1\">\n  <style>img {max-width: 100%; height: auto}</style>\n  <body>\n    <div><div class=\"htmlWrapper container\" id=\"_flutter_target_do_not_delete\">$html</div></div>\n    <script>\n      function outputsize() {\n        console.log(document.getElementById(\"_flutter_target_do_not_delete\").offsetHeight);\n        window.postMessage('flutterTargetHeight', document.getElementById(\"_flutter_target_do_not_delete\").offsetHeight);\n      }\n      new ResizeObserver(outputsize).observe(_flutter_target_do_not_delete)\n      outputsize()\n    </script>\n</html>\n\"\"\";\n```\n\n이렇게하여 HTML이 로드될 때마다 올바른 높이를 얻고 부드러운 애니메이션을 함께 사용할 수 있었습니다.\n\n만세!!! 성공했습니다…….\n\n<div class=\"content-ad\"></div>\n\n위 글 읽어주셔서 감사합니다 ❤️\n\n제 Udemy 과정인 \"2023년 Appwrite with Flutter 초급 과정\"이 오픈되었습니다. 아래 링크를 통해 강좌를 확인하세요!\n\n[Appwrite with Flutter 초급 과정 2023](https://www.udemy.com/course/appwrite-with-flutter-beginner-course-2023/)\n\n감사합니다!\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 표 태그를 변경하세요.\n","ogImage":{"url":"/assets/img/2024-06-22-HandlingcomplexHTMLinFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-HandlingcomplexHTMLinFlutter_0.png","tag":["Tech"],"readingTime":5}],"page":"14","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}