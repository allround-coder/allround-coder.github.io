{"pageProps":{"posts":[{"title":"앵귤러에서 마이크로 프론트엔드 애플리케이션 만드는 방법","description":"","date":"2024-05-27 19:02","slug":"2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1","content":"\n\n<img src=\"/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png\" />\n\n# 안내 내용\n\n이 안내서에서 다룰 내용은 다음과 같습니다:\n\n- Angular에서 Micro-Frontend 애플리케이션 소개\n- Angular에서 간단한 호스트 및 Micro-Frontend 애플리케이션 생성\n\n<div class=\"content-ad\"></div>\n\n# 소개\n\n크고 화려한 생일 파티를 준비한다고 상상해보세요. 엄청나게 큰 케이크를 굽고, 장식을 꾸미고, 게임을 설치하고, 음식을 준비해야 합니다. 이 모든 것을 혼자 다 처리하려고 하면 압도될 수 있습니다. 하지만 친구들에게 작업을 분담할 수 있다면 어떨까요? 한 명은 케이크를 굽고, 다른 한 명은 장식을 하고, 또 다른 한 명은 게임을 설치하고, 한 명은 음식을 책임지죠. 모두가 독립적으로 일하지만 모여서 멋진 파티를 만들어냅니다.\n\n웹 애플리케이션이 커지고 복잡해지면 단일 대규모 코드베이스를 유지하는 것이 어려워질 수 있습니다. 이러한 문제를 해결하기 위해 마이크로 프론트엔드와 모듈 연합이라는 개념이 소개되었습니다. 이러한 개념을 활용하면 개발자들이 모듈식, 확장 가능하며 유지보수가 쉬운 웹 애플리케이션을 만들 수 있습니다. 이 기사에서는 마이크로 프론트엔드의 기본 개념, Webpack 5의 기능, 그리고 Angular 프로젝트에서 모듈 연합을 구현하는 방법에 대해 자세히 살펴보겠습니다.\n\n# 마이크로 프론트엔드란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n마이크로 프론트엔드 아키텍처를 생각해보면 번화한 쇼핑몰의 푸드코트와 비슷합니다. 각 음식점(마이크로 프론트엔드)은 독립적으로 운영되어 독특한 요리를 제공합니다. 피자 전문점, 스시 전문점, 햄버거 전문점 등이 있습니다. 각 음식점은 독립적으로 관리되고 운영되며 재고가 구비되지만, 함께하면 쇼핑몰 방문객들에게 즐거운 다이닝 경험을 선사합니다.\n\n마이크로 프론트엔드는 이 개념을 웹 애플리케이션에 적용한 것입니다. 큰 웹 애플리케이션을 더 작고, 준 독립적인 \"마이크로\" 애플리케이션으로 분할합니다. 각 마이크로 프론트엔드는 별도로 개발, 배포, 유지보수할 수 있습니다. 이 접근 방식을 통해 서로 다른 팀이 서로 다른 프론트엔드 부분에 작업을 할 수 있으며, 서로 간섭하지 않게 되어 확장성, 유지보수성이 향상되며 동일한 애플리케이션 내에서 다른 기술을 사용할 수 있습니다.\n\n# 웹팩 5이란?\n\n캠핑용품을 준비하는 것과 같습니다. 텐트, 음식, 옷, 캠핑 장비가 필요합니다. 이 모든 것을 하나의 큰 가방에 랜덤하게 넣는 대신, 특정 카테고리에 지정된 여러 작은 가방을 사용합니다. 이렇게 하면 물건을 싸고, 찾고, 사용하는 것이 훨씬 쉽고 효율적입니다.\n\n<div class=\"content-ad\"></div>\n\n웹팩 5은 자바스크립트 애플리케이션을 위한 궁극적인 패킹 시스템 같아요. 자바스크립트 파일, 스타일, 이미지, 그리고 다른 에셋들을 효율적으로 정리하고 패킹하는 모듈 번들러에요. 아래는 웹팩 5의 주요 기능들이에요:\n\n- 모듈 연맹: 다른 캠퍼들 사이에서 공급을 공유하는 것처럼, 모듈 연맹은 여러 웹팩 빌드가 함께 작동하도록 하여, 애플리케이션 간의 코드 공유를 가능하게 함.\n- 개선된 캐싱: 미래의 패킹을 빠르게 만들어주는, 잊지 않게 해주는 매우 체계적인 체크리스트와 같은 것으로 생각해봐요.\n- Tree Shaking: 가방에서 불필요한 물건을 제거하여 가벼우고 효율적으로 만드는 것과 같아요.\n- 에셋 모듈: 에셋 파일(예: 이미지와 폰트)을 다루기 쉽게 해주어 모든 것이 제 위치에 있도록 해요.\n- 웹 어셈블리 지원: WebAssembly에 대한 향상된 지원으로, 여러 가지 고급 캠핑 가전들을 위한 특별한 칸나 있는 것처럼 생각해봐요.\n\n# 독립형 컴포넌트란 무엇인가요?\n\n레고 블럭을 사용해 건물을 지을 때, 각각의 레고 블럭은 독립적인 부분으로, 독립적으로 사용하거나 다른 블럭들과 결합하여 더 큰 것을 만들 수 있어요. 각 블럭이 어느 세트에서 왔는지 고민할 필요는 없어요; 어디에 놓든 그대로 작동해요.\n\n<div class=\"content-ad\"></div>\n\nAngular에서 독립형 컴포넌트는 다양하고 다재다능한 레고 블록과 같습니다. 이들은 특정 NgModule에 바인딩되지 않은 Angular 컴포넌트로, NgModule 선언 내에서 명시적으로 가져오기 및 내보내기가 필요 없이 응용 프로그램의 여러 부분에서 사용할 수 있습니다.\n\n- 높은 재사용성: 레고 블록처럼 독립형 컴포넌트는 서로 다른 모듈 및 프로젝트에서 사용할 수 있습니다.\n- 관계 단순화: 복잡한 가져오기/내보내기 관계가 제거되어 컴포넌트 계층 구조가 단순화됩니다.\n- 지연 로드 모듈과 함께 작동: 독립형 컴포넌트는 지연 로드된 모듈과 원활하게 통합됩니다.\n- 제3자 라이브러리 통합: NgModule 선언을 수정하지 않고 제3자 라이브러리와 함께 사용할 수 있습니다.\n- 복잡성 감소: 의존성 관리가 쉬워지며, 마치 레고 모형을 조직하는 것과 같습니다.\n- 더 깔끔한 코드 분리 유도: 코드베이스가 깔끔하고 모듈식으로 유지되어, 마치 레고 모형의 구분된 섹션을 구성하는 것과 같습니다.\n- 더 이동 가능: 독립형 컴포넌트는 이동, 리팩토링 또는 이주가 쉽습니다. 마치 레고 조각을 재배열하는 것과 같습니다.\n\n독서해 주셔서 감사합니다. 즐거운 코딩되세요! :)\n\n# 관련 링크:\n\n<div class=\"content-ad\"></div>\n\n- **Angular에서 모듈 연합 및 마이크로 프론트엔드 애플리케이션 가이드 - 파트 1**  \n- **Angular에서 모듈 연합 및 마이크로 프론트엔드 애플리케이션 가이드 - 파트 2**  ","ogImage":{"url":"/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png"},"coverImage":"/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png","tag":["Tech"],"readingTime":3},{"title":"앵귤러 신호 컴포넌트 입력을 위한 새로운 시대","description":"","date":"2024-05-27 19:00","slug":"2024-05-27-AngularSignalsANewEraforComponentInputs","content":"\n\n## 안녕하세요 👋\n\n이 문서는 시그널에 사용되는 새로운 입력 API에 대해 소개하고 있습니다. 시그널을 사용하여 Angular 앱 내에서 통신을 활성화하기 위해 사용되는 모든 새로운 API에 대해 이미 다뤘습니다. 아래에는 Angular 앱 내에서 시그널을 사용하여 통신하는 새로운 방법에 대해 더 자세히 알아볼 수 있는 구체적인 예제가 있습니다:\n\n이전에 언급했듯이, 이 문서는 특히 새로운 입력 API에 대한 간략한 개요를 제공하는 데 초점을 맞추고 있습니다.\n\n기존 Angular은 컴포넌트 입력을 처리하기 위해 setter나 ngOnChanges를 사용합니다. 이러한 방법은 작동하지만 명령형 스타일에 의존합니다.\n\n<div class=\"content-ad\"></div>\n\n➡️ 신호 입력:\n\n- 신호 입력은 구성 요소 입력을 관리하는 선언적인 방법을 제공합니다.\n- 입력 값이 변경될 때 Angular에게 통지함으로써 반응적인 접근 방식을 제공합니다.\n- 이를 통해 더 세밀한 변경 감지와 효율적인 업데이트가 가능해집니다.\n\n➕ 신호 입력의 장점:\n\n- 성능 향상: 변경 감지가 최적화되어 불필요한 다시 렌더링을 최소화하며, Angular 앱의 존리스 이동에 중요한 역할을 합니다.\n- 단순화된 코드: 코드가 더 깨끗하고 이해하기 쉬워집니다.\n- 증진된 반응성: 신호는 계산 및 효과와 같은 Angular의 반응적 기능과 원활하게 통합됩니다.\n\n<div class=\"content-ad\"></div>\n\n🗝️ 중요한 개념:\n\n- input: 입력 속성을 위한 신호를 생성합니다 (예시).\n- computed: 기존 신호로부터 새 값을 파생합니다 (예시).\n- effects: 신호 변경으로 인해 트리거된 부작용을 실행합니다 (더 자세한 내용은 여기에서 찾을 수 있습니다).\n\n```js\n...\nexport class AComponent {\n  \n  anInput = input.required<number>();\n      \n  constructor(){\n    // ⚠️ 주입 환경에서 호출되어야 합니다\n    effect(() => console.log(this.anInput());\n  }\n\n...\n}\n```\n\n- 선택적 및 필수 입력: 신호는 초기값과 함께 선택적이거나 필수로 지정할 수 있습니다 (예시).\n- 입력 변환: 입력 신호는 입력 값의 의미를 변경하지 않고 강제 혹은 구문 분석이 필요할 때 변환될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n...\nexport class AComponent {\n\n  disabled = input(false, {\n    transform: (value: boolean|string) => typeof value === 'string' ? value === '' : value,\n  });\n\n}\n\n// In consumer cmp\n<a-cmp disabled />\n```\n\n- Input Aliasing: 신호를 사용하면 입력 속성에 별칭을 지정할 수 있습니다. (자세한 내용은 여기에서 찾을 수 있습니다)\n\n```js\n@Component({\n  standalone: true,\n  selector: 'a-cmp',\n  template: `...`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class AComponent {\n  \n  aName= input.required<string>({alias: 'aliasName'});\n...\n}\n\n// a-cmp 소비자\n<a-cmp [aliasName]=\"'a name'\" />\n```\n\n🎬 신호 입력을 실행하는 중:\n\n<div class=\"content-ad\"></div>\n\n- 시그널로 라우트 파라미터에 액세스: 라우터에 withComponentInputBinding 옵션을 활성화하여 반응형 시그널로 라우트 파라미터에 액세스할 수 있습니다.\n\n```js\n// 1 - 앱 구성 파일( AppModule에서도 제공할 수 있음)\nexport const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes, withComponentInputBinding())]\n};\n\n// 2 - 라우트 내부\nconst routes: Routes = [\n  {\n    title: 'Route X',\n    path: 'route-x/:id',\n    component: AComponent\n  },\n  ...\n]\n\n// 3 - AComponent 내부\nid = input<string>(); // 👈 이제는 라우트 파라미터에서 id 값을 추출할 필요가 없습니다\n```\n\n- 시그널로 데이터 가져오기: 시그널을 사용하여 서비스에서 데이터를 가져올 수 있습니다.\n\n```js\n@Component({\n  standalone: true,\n  selector: 'a-cmp',\n  template: `{ data() }`,\n})\nexport default class AComponent {\n  private readonly aService = inject(AService);\n\n  id = input.required<string>();\n  \n  /*💡toSignal로 생성된 구독은 toSignal을 호출하는 컴포넌트 또는 서비스가 제거될 때 주어진 Observable에서 자동으로 구독을 해제합니다.*/\n  data = toSignal(this.aService.getData(i), {initialValue: []}); // 👈 toSignal 사용 예시\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- 복잡한 시나리오: toSignal이 강력하긴 하지만, Observables를 사용해야 하는 특정 상황이 있습니다. 이는 주로 RxJS 연산자를 활용하여 데이터를 보다 효과적으로 처리하는 데 도움이 되기 때문입니다. 이를 위해 필요한 모든 프로세스를 처리하고 데이터를 신호로 쉽게 추적할 수 있는 스트림을 생성하는 toObservable 유틸리티를 사용할 수 있습니다. 다음 예시는 id 입력이 변경될 때마다 가장 최신의 새로운 id를 기반으로 즉시 getData으로 전환하고 싶을 때 간단한 케이스를 제공합니다.\n\n```js\n...\n@Component({\n  standalone: true,\n  selector: 'a-cmp',\n  template: `{ data() }`,\n})\nexport default class AComponent {\n  private readonly aService = inject(AService);\n\n  id = input.required<string>();\n\n  /* id 신호가 변경될 때, toObservable(this.id)는 가장 최신의 id를 발행하고 서비스의 getData(id) 함수를 트리거합니다. */\n  data = toSignal(\n      toObservable(this.id) // 👈 toObservable 사용\n        .pipe(\n          switchMap((i) => this.aService.getData(i))\n        )\n      );\n}\n```\n\n🎯 신호 입력 이상:\n\n이 새로운 API는 Angular 애플리케이션의 반응성과 효율성을 향상시키는 데 중요한 역할을 합니다. 이것들은 더 간단하고 반응적인 컴포넌트 디자인을 생성할 수 있게 해주며, zoneless 애플리케이션을 구축하는 데 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n최종 목표는 미래에 존리스(Zoneless) 모드의 보급을 촉진하는 것입니다. 특히, 이 기능을 지원하는 실험적 API는 이미 Angular의 최신 버전(현재 버전 17)에서 사용할 수 있습니다(첫머리에서 언급된 글을 참조하세요).\n\n여기까지가 이 기사의 내용입니다. 마음에 드셨으면 좋겣어요. 만약 이 형식을 좋아하시고 이와 유사한 간결하고 명료한 기사를 더 원하신다면 알려주세요.\n\n오늘은 여기까지, 안녕🙋\n\n질문이나 피드백이 있으면 댓글을 남기거나 LinkedIn을 통해 저에게 연락해주세요 — 기다리고 있겠습니다!\n\n<div class=\"content-ad\"></div>\n\n부지런히 커피 한 잔 사 줄래요? ☕️\n\n만약 제 글을 좋아하셨다면 👏, 공유 🔗, 그리고 최신 글을 받기 위해 구독 🔔 해주세요.\n\n저와 소통하고 싶다면 Medium, Linkedin, Facebook, Instagram, YouTube, 또는 Twitter에서 연락해 주세요.\n\n# 쉬운 용어로 🚀\n\n<div class=\"content-ad\"></div>\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 작가를 박수치고 팔로우하세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-05-27-AngularSignalsANewEraforComponentInputs_0.png"},"coverImage":"/assets/img/2024-05-27-AngularSignalsANewEraforComponentInputs_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular v18 성능 향상 및 개발자 경험 향상","description":"","date":"2024-05-27 19:00","slug":"2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer","content":"\n\n<img src=\"/assets/img/2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer_0.png\" />\n\n# Angular v18: 성능 향상 및 개발 경험 향상\n\n안녕하세요, Angular 개발자 여러분! 기다리시던 순간이 왔습니다. Angular v18이 공식적으로 출시되었으며, 여러분의 개발 경험을 향상시키기 위해 설계된 다양한 흥미로운 기능과 개선 사항을 가져왔습니다. 몇 가지 주요 기능을 살펴보겠습니다:\n\n1. Zoneless Change Detection (실험적): Angular v18은 zoneless change detection을 실험적으로 지원합니다. 이 혁신적인 접근 방식은 Angular이 컴포넌트 내에서 변경 사항을 감지하는 방식을 최적화하여 응용 프로그램 성능을 혁신적으로 개선할 수 있습니다. 아직 실험 단계이지만, Angular의 성능 최적화의 미래를 엿볼 수 있는 기능입니다.\n\n<div class=\"content-ad\"></div>\n\n2. Angular.dev: Your New Developer Hub: Angular 개발자를 위한 공식 홈인 Angular.dev로 옮겼습니다. 이 간소화된 플랫폼은 깊이 있는 가이드와 자습서부터 최신 뉴스와 업데이트까지 모든 Angular 요구 사항에 대한 중앙 집중지를 제공합니다.\n\n3. Stable Material 3 and More: Material 3, deferrable views 및 내장 제어 흐름이 모두 v18에서 안정적인 상태로 졸업했습니다. 이는 이러한 기능을 확신을 갖고 활용할 수 있음을 의미하며, 그들이 철저히 테스트되고 제품으로 출시 준비가 되어 있음을 알 수 있습니다. 또한 v18은 개발자 경험과 사용성을 향상시키기 위한 다양한 개선 사항을 포함하고 있습니다.\n\n4. Server-Side Rendering Boost: 서버 측 렌더링(SSR)을 사용하는 개발자들을 위해 v18에서 다양한 개선 사항이 제공됩니다. 이에는 i18n 수분화 지원, 향상된 디버깅 기능, 그리고 Angular Material 내의 수분화 지원이 포함됩니다. 또한, Google Search를 구동하는 동일한 라이브러리가 제공하는 이벤트 리플레이 기능이 이제 사용 가능해져 원활한 사용자 상호작용이 가능해졌습니다.\n\n5. Stay Ahead of the Curve: Angular v18을 사용하면 항상 진화하고 경계를 넓히는 프레임워크에 접근할 수 있습니다. v18로 업그레이드하면 최신 개발 사항과 최고의 실천법을 갖춤으로써 여러분의 애플리케이션을 웹 개발 분야의 선두에 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n업그레이드하고 탐험하기:\n\nAngular v18로 업그레이드하는 것은 매우 쉽습니다. Angular 팀은 원활한 전환을 보장하기 위해 포괄적인 이주 안내서를 제공했습니다. 당신이 경험且 개발자이든, Angular을 처음 시작한 사용자이든, v18은 개발 워크플로우를 향상시키고 고성능 웹 애플리케이션을 개발하는 매력적인 기회를 제공합니다.\n\n그러니 무엇을 기다리고 있나요? Angular v18로 뛰어들어 기대가 되는 새로운 기능을 탐험해보세요! 자세한 정보 및 심층 가이드는 공식 Angular 블로그 포스트를 참조하세요.","ogImage":{"url":"/assets/img/2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer_0.png"},"coverImage":"/assets/img/2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular의 경로 리다이렉션 로직을 개선하는 방법 RedirectFunction 소개","description":"","date":"2024-05-27 18:59","slug":"2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction","content":"\n\n<img src=\"/assets/img/2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction_0.png\" />\n\n최근 업데이트에서 Angular는 RedirectFunction을 통해 유연한 경로 리다이렉션 접근 방식을 소개하여 라우팅 기능을 크게 개선했습니다. 이 새로운 기능을 통해 개발자는 문자열이나 UrlTree를 반환할 수 있는 함수를 사용하여 리디렉션을 정의할 수 있어 라우팅 로직에서 향상된 제어와 다양성을 제공합니다.\n\n# RedirectFunction 이해하기\n\nAngular에서의 전통적인 접근 방식은 Route.redirectTo 속성 내에서 직접 문자열 경로를 지정하는 것이었습니다. 효과적이지만, 이 방법은 특히 라우트 매개변수와 데이터를 기반으로 동적으로 리디렉션 경로를 생성하는 능력에서 한계가 있었습니다. 새로운 RedirectFunction은 이러한 제한을 극복하여 함수가 리디렉트 대상을 결정할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n리다이렉트 기능의 주요 특징:\n\n- 동적 리다이렉트: 이 기능은 이전의 정적 리다이렉트와 유사하게 문자열을 반환하거나 더 복잡하고 절대적인 리다이렉트를 가능하게 하는 UrlTree를 반환할 수 있습니다.\n- 라우트 파라미터 및 데이터에 접근: 이전 방법과 달리, 개발자는 현재 라우트에서만 파라미터와 데이터에 액세스할 수 있었지만 RedirectFunction을 사용하면 일치하는 부모 라우트에서 파라미터와 데이터에 액세스할 수 있습니다. 이는 라우트 매칭 과정 중에 파라미터 및 데이터를 집계함으로써 달성됩니다.\n- 개선된 컨텍스트 인식: 매치 중에 params와 데이터를 상속받음으로써 함수는 보다 광범위한 컨텍스트를 활용하여 더 더욱 정보에 기반한 리다이렉션 결정을 내릴 수 있습니다.\n\n# 제약 사항 및 고려 사항:\n\n- RedirectFunction은 전체 ActivatedRouteSnapshot 인터페이스를 제공하지 않습니다. 해결된 제목이나 레이지로드된 컴포넌트와 같은 특정 속성들은 라우트 매칭 단계에서 사용할 수 없습니다. 사용 가능한 속성은 다음과 같습니다: routeConfig, url, params, queryParams, fragment, data, outlet, title.\n- 전체 라우트 트리에 의존하는 속성(예: root, parent, pathFromRoot, firstChild, children)은 아직 전체 라우트 매칭이 이루어지지 않았기 때문에 제외됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 실용적인 예시\n\n검색 쿼리 매개변수에 기반하여 사용자를 리디렉션해야 하는 시나리오를 고려해보세요. 새로운 RedirectFunction을 사용하면 이를 매끄럽게 구현할 수 있습니다:\n\n```js\nexport const routes: Routes = [\n  {\n    path: 'search',\n  redirectTo: ({ queryParams }) => {\n    const router = inject(Router);\n    const searchQuery = queryParams['q'];\n\n    return searchQuery\n      // UrlTree 반환\n      ? router.createUrlTree(['/results'], {\n          queryParams: { q: searchQuery },\n        })\n     // 또는 문자열\n      : 'home';\n  },\n},\n{\n  path: 'results',\n  component: ResultsComponent,\n},\n{\n  path: 'home',\n  component: HomeComponent,\n},\n];\n```\n\n이 예시에서 redirectTo 함수는 검색 쿼리 매개변수가 있는 경우 동적으로 사용자를 리디렉션하는 UrlTree를 생성합니다. 검색 쿼리가 있는 경우 쿼리 매개변수를 포함하여 결과 페이지로 리디렉션하고, 없는 경우 홈 페이지로 리디렉션합니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\nAngular의 RedirectFunction 소개는 프레임워크의 라우팅 기능을 크게 향상시킨 것으로 평가됩니다. 이 업데이트는 라우트 컨텍스트에 더 많은 유연성과 접근성을 제공하여, 개발자들이 더 동적이고 컨텍스트에 민감한 리디렉션을 만들 수 있게 해주며, 결과적으로 Angular 애플리케이션의 전반적인 사용자 경험을 향상시킵니다.\n\nAngular와 JS에 대해 더 많은 내용을 읽으려면 Medium나 Twitter에서 저를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction_0.png"},"coverImage":"/assets/img/2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction_0.png","tag":["Tech"],"readingTime":3},{"title":"Angular v18 발표 내용 정리 ","description":"","date":"2024-05-27 18:57","slug":"2024-05-27-Angularv18announcements","content":"\n\n<img src=\"/assets/img/2024-05-27-Angularv18announcements_0.png\" />\n\n2024년 5월 26일, Angular 팀이 Angular 18 버전을 발표했어요. Angular 개발자로서 Angular이 새로운 반응형 시스템을 구축한 진전에 대해 너무 기대돼요. 그래서 이들의 발표를 함께 공유하려고 해요.\n\n이번 새 릴리스는 Angular을 향상시켜 개발자 커뮤니티에 더 나은 서비스를 제공하고 웹을 발전시키기 위한 방법을 찾는 것을 목표로 하고 있어요. 이들의 향상 사항 중 일부를 나열하면:\n\n- 템플릿 레벨의 지연 로딩과 defer 구문.\n- 더 직관적인 제어 흐름.\n- Angular 시그널을 활용한 반응성 개선.\n- SSR(Server side rendering) 및 Hydration 지원을 포함해요.\n\n<div class=\"content-ad\"></div>\n\n그리고 더 많은 개선 사항이 있습니다.\n\n# 새로운 반응성 시스템 상태\n\n가장 중요한 프로젝트부터 시작합니다. 그들의 반응성 시스템을 재설계하는 프로젝트가 시작되었습니다. 이 재설계 작업은 Angular v16부터 시작되었습니다.\n\n이 프로젝트의 주요 목표는 Angular 애플리케이션에서 zone.js를 선택 사항으로 만드는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 질문에 대한 답변으로 Alex Rickabaugh는 zone.js로 구축된 응용 프로그램의 역호환성이 있다고 확인했습니다. 그리고 그들은 zone.js와 함께 반응성에 대한 성능 약점을 발견했으며 많은 유지 보수적인 도전 과제도 있었습니다. 또한 새로운 웹 API의 추가로 로딩 및 초기화 비용이 증가했습니다.\n\n이후 Angular 팀은 다음 10년 동안 개발자의 요구를 충족시키고 웹 성능을 향상시킬 새로운 반응성 시스템에 투자하기로 결정했습니다.\n\nAngular은 이미 Angular 16부터 새로운 반응성 시스템의 재설계를 시작했습니다. 시그널, 컴퓨티드 그리고 이펙트라는 세 가지 반응 API를 소개하여\n\nAngular 17에서, 시그널, 컴퓨티드 그리고 이펙트는 안정된 API가 되었습니다. 이러한 API들은 새로운 반응성 시스템의 핵심이며, 우리가 사용함으로써 Angular이 응용 프로그램 상태에서 발생한 변경 사항을 이해하고 UI를 올바르고 효율적으로 업데이트할 수 있도록 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n또한 Angular 팀은 NgXS 및 NgRx 팀에 접근하여 신호 API가 그들의 사용 사례를 지원하는지 확인했습니다. NgRx의 signal store의 통합은 이 협력의 열매입니다.\n\n이 세 가지 API는 Angular에게 존을 사용하지 않고도 이 반응성 모델을 구축할 수 있는 기초를 제공합니다.\n\n# 하이브리드 변경 감지\n\nAngular 라이브러리 및 응용 프로그램을 존에서 독립적으로 사용할 수 있게 하기 위해 모든 구성 요소에 영향을 주지 않고 Angular 팀은 지난 여섯 달 동안 새로운 변경 감지 모드에 대해 작업해 왔습니다.\n\n<div class=\"content-ad\"></div>\n\n이 모드의 목표는 정확성, 성능, 개발자 경험 및 하위 호환성을 균형있게 유지하는 것입니다.\n\n이를 완전히 구현하는 데는 시간이 걸립니다. 또한, Angular 팀은 구글 Angular 애플리케이션에서 이러한 아이디어를 테스트하고 일부는 이미 제품에 적용되었습니다.\n\nV18에서 새로운 변경 감지 모드의 두 가지 요소를 출시했습니다:\n\n- 하이브리드 변경 감지 : V18에서 기본적으로 활성화되며, zone.js에 추가로 Angular은 신호도 감지하고 변경 감지를 예약합니다.\n- Zone을 비활성화하는 실험적 API : 이 API는 여전히 실험 중인 상태입니다. 이 API를 사용하면 zones를 비활성화하고 애플리케이션이 완전히 zone-less 상태가 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nV18 이후, Angular 팀에는 다음과 같은 다른 프로젝트들이 준비 중입니다:\n\n- Angular 패키지 및 다른 생태계 라이브러리를 위한 zone-less Angular의 개발자 미리보기.\n- 시그널 기반의 폼과 라우터.\n- 시그널 컴포넌트.\n- Angular의 안정성과 신뢰성에 대한 헌신.\n\n# Angular 수분\n\n이 기능은 Angular 16에서 소개되었습니다. 이는 Angular Universal과 함께 SSR을 사용할 때, Angular이 이제 서버 측 렌더링된 HTML을 클라이언트에서 재사용할 수 있게 되었음을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n## DevTools에서 수분 보충 기능이 강화되었습니다\n\nV18 Angular 팀에서는 Angular DevTools에서 수분 보충을 지원하기 위한 기능을 강화했습니다. 개발자는 수분 보충 정보를 볼 수 있습니다. 수분 보충된 컴포넌트, 건너 뛰어진 컴포넌트, 그리고 오류를 만난 컴포넌트를 쉽게 수정할 수 있습니다.\n\n## Angular Material 컴포넌트는 수분 보충을 지원합니다\n\nV18에서는 모든 Angular Material 컴포넌트가 수분 보충을 지원하여 애플리케이션 성능을 높일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## i18n 블록 지원 — 미리보기\n\nV18에서는 i18n 블록을 위한 수분 지원도 추가되었고, 이 기능은 개발자 미리보기 상태입니다.\n\n## 이벤트 재생 — 미리보기\n\nAngular 팀에서 미리보기 모드에 새로운 기능인 이벤트 재생(Event Replay)도 출시했습니다. 애플리케이션이 수분화되는 중에 사용자가 애플리케이션과 상호 작용할 수 있습니다. 이러한 작업은 캡쳐되어 재생할 수 있습니다. 이 기능은 JsAction에 의해 제공되며 Wiz와의 협력으로 나온 것입니다. 애플리케이션이 완전히 수분화될 때 이벤트가 캡처되어 올바른 시간에 재생됩니다.\n\n<div class=\"content-ad\"></div>\n\n다음 Angular 수분화를 위해\n\n- 루트용 렌더링 모드 선택, 클라이언트 측, 서버 측 또는 빌드 시간에 렌더링될 루트를 선택할 수 있도록 후크를 구축하려고 합니다.\n- 매개변수화된 루트의 SSG(정적 사이트 생성) 경험 향상.\n\n# Angular material 3\n\nAngular V18은 드디어 material design 3을 지원합니다. 새로운 사용 가능한 기능은:\n\n<div class=\"content-ad\"></div>\n\n- 테마 생성 체계를 변경했습니다.\n- CSS 변수를 기반으로 한 간소화된 테마 스타일.\n- CSS 변수를 기반으로 한 더 세부적인 테마 사용자 정의.\n- 컴포넌트에 색상 변형을 적용하기 위한 더 유연한 API.\n\n앱에서 Material 3을 사용하려면 mat.define-theme을 사용하여 sass에서 m3 테마를 생성하세요 :\n\n![image](/assets/img/2024-05-27-Angularv18announcements_1.png)\n\n또는 Angular CLI의 ng generate 명령을 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n$ ng generate @angular/material:m3-theme\n```\n\n테마를 애플리케이션에 적용하려면 가져와서 적용해야 합니다:\n\n![Angularv18announcements_2](/assets/img/2024-05-27-Angularv18announcements_2.png)\n\n색상, 타이포그래피 등을 읽기 위한 새로운 SASS API도 소개되었습니다. 또한 M2 테마는 여전히 지원된다고 발표되었습니다.\n\n<div class=\"content-ad\"></div>\n\nAngular Material의 다음 단계에 있습니다.\n\n- 더 많은 유연성을 위해 앵귤러 마테리얼의 일부 동작을 근미래에 완전히 사용자 정의 된 CDK 구성 요소로 추출하고 있습니다.\n\n# 기타 기능\n\n이전에 설명한 것 외에 V18에는 다음 세대 웹 앱을 구축하는 데 도움이 되는 추가적인 작은 기능 및 버그 수정이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 새로운 시그널 기반 API\n\n- 시그널 입력 API: 시그널 입력을 사용하면 부모와 자식 컴포넌트 간에 값을 바인딩할 수 있습니다. 일방향 바인딩.\n\n![](/assets/img/2024-05-27-Angularv18announcements_3.png)\n\n- 모델 입력 API: 시그널 모델 입력을 사용하여 데이터를 두 방향 바인딩하여 동기화합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Angular v18 Announcement Image 4](/assets/img/2024-05-27-Angularv18announcements_4.png)\n\n- Signal Query APIs: offer an alternative approach to the decorator-based queries, namely @ViewChild, @ViewChildren, @ContentChild, and @ContentChildren, supplying query results as a Signal.\n\n![Angular v18 Announcement Image 5](/assets/img/2024-05-27-Angularv18announcements_5.png)\n\nTo learn more about signals, check the guide: [Angular Signals Guide](https://angular.dev/guide/signals)\n\n\n<div class=\"content-ad\"></div>\n\n## Zoneless APIs\n\nzone.js 이벤트 통합은 V18에서 기본적으로 활성화되며, zone-less와 동일한 스케줄러를 사용합니다:\n\n![](/assets/img/2024-05-27-Angularv18announcements_6.png)\n\nzone.js를 사용하는 Angular은 Angular zone 밖에서 변경이 일어날 때에도 변경 감지를 스케줄할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Angular v18 announcements](/assets/img/2024-05-27-Angularv18announcements_7.png)\n\n이전에 언급했듯이 Angular Material 구성 요소 및 CDK는 zone-less 호환됩니다. zone-less는 실험적인 모드에서 사용할 수 있습니다.\n\n## Typescript 5.4\n\nV18에서는 typescript 5.4 기능을 활용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 마지막 할당 후 클로저에서의 유지된 좁힘.\n- NoInfer 유틸리티 타입.\n- Object.groupBy 및 Map.groupBy\n- …\n\n더 많은 TS 5.4 기능을 확인하려면 이 블로그 포스트를 확인하세요 : https://devblogs.microsoft.com/typescript/announcing-typescript-5-4/\n\n## 기본 `ng-content`\n\n이 릴리스 이후, 개발자들은 이제 `ng-content`에 기본값을 제공할 수 있습니다. 이를 통해 빈 목록과 현재 콘텐츠가 없는 다른 컴포넌트에 값 할당이 가능해집니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-05-27-Angularv18announcements_8.png\" />\n\n## Angular Forms 새로운 전역 observable\n\nGitHub에서 가장 많은 투표를 받은 기능 요청을 개발했습니다. 이는 모든 컨트롤 및 해당 하위 요소에 대한 모든 종류의 이벤트를 추적하도록 구독할 수 있는 전역 observable입니다.\n\n<img src=\"/assets/img/2024-05-27-Angularv18announcements_9.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n## Angular.dev\n\n해당 업데이트는 현대화된 로고를 갖춘 새로운 Angular.dev 웹사이트를 소개하였습니다.\n\n마지막으로, Angular 팀의 전체 로드맵을 확인하고 싶다면 다음 페이지를 방문해주세요 : [Angular 로드맵](https://angular.dev/roadmap)\n\n이 기사의 끝까지 읽어 주셔서 감사합니다! 떠나시기 전에:\n\n<div class=\"content-ad\"></div>\n\n- 작가를 박수로 응원하고 팔로우하세요! 👏️\n- 저를 팔로우하세요: X | LinkedIn | YouTube","ogImage":{"url":"/assets/img/2024-05-27-Angularv18announcements_0.png"},"coverImage":"/assets/img/2024-05-27-Angularv18announcements_0.png","tag":["Tech"],"readingTime":7},{"title":"챗GPT, TypeScript를 사용하여 기본 코드 주도형 DB 도구 만들기","description":"","date":"2024-05-27 18:54","slug":"2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool","content":"\n\n<img src=\"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_0.png\" />\n\n안녕하세요! ChatGPT가 등장했고 엔지니어들 사이에서 큰 첫 인상을 남겼어요 — 이름에 비웃음을 보이는 사람부터 우주 탄생에 대해 이야기하는 등 다양한 의견이 있어요. 어느 쪽에 속하더라도 대부분은 이것이 산업 전체에 많은 변화를 가져올 것이라는 것을 깨달아요.\n\n저는 프로그래머들이 만든 어떤 생산성 도구와 마찬가지로, ChatGPT를 효과적으로 활용하는 한 보상을 받을 것으로 생각해요. 효과적으로 사용하는 법을 배우기 위해서는 복잡한 시나리오를 시도하고 이를 어떻게 운영하는지 확인해야 해요. 저는 ChatGPT를 사용하여 빠르게 기본적인 코드 기반 데이터베이스 도구를 만들어보고, 그것에 추가해서 프로젝트를 실제로 몇 가지 기본 사례에 맞게 작동하도록 만들 계획이에요.\n\n우선, 어떤 것에 대한 복잡한 프롬프트를 선택해봅시다. 코드 기반 데이터베이스 마이그레이터를 만드는 것은 흥미로운 도전이 될 수 있을 것 같아요. 우리는 코드 파일을 이해하고 필요한 추가 컨텍스트로 일부 클래스 속성을 장식하는 메타프로그래밍 작업을 해야하기 때문이죠. 이 글을 간결하게 유지하기 위해, 우리는 Primary 및 Foreign 키가 있는 테이블 생성 스크립트를 생성하고 작업 순서를 보장하는 마이그레이터의 일부분만 만들 것이에요.\n\n<div class=\"content-ad\"></div>\n\n요구 사항 목록은 다음과 같습니다:\n\n- 데이터베이스의 테이블을 위한 인터페이스 작성 — 이는 어떤 플러그인이 적응할 수 있는 데이터의 추상 표현을 제공합니다\n- 테이블 간의 관계 데이터를 어떻게 표현할지에 대한 인터페이스 조정 — 이는 우리의 이관 작업에 대비한 더 고급 개념입니다\n- 플러그인이 관계 데이터를 마이그레이션 도구의 스크립트로 변환할 수 있도록 하는 인터페이스 작성 — 우리는 상하 이관 작업을 원할 것이며 이러한 작업의 추상화를 최대한 포착할 겁니다\n- 내보낸 클래스의 소스 파일을 읽고 인터페이스를 활용하여 데이터를 구축할 수 있는 프로토타입 애플리케이션 작성 — 데이터베이스 코드 모델링의 기능적 측면을 테스트하기 위함입니다\n\n이러한 요구 사항이 작성되면 이제 빠른 프롬프트를 만들어볼 수 있습니다. 몇 번의 시행착오 뒤에, 이에 대한 ChatGPT의 출력을 확인해 봅시다:\n\n이리저리 까다로운 조건들이 많지만, ChatGPT는 기꺼이 협조할 준비가 되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_1.png)\n\n지금까지... 그리 좋지 않아요. 우리의 클래스 파일을 정규식으로 맞추고 싶지 않고, 앞으로 나올 것들이 좀 무서워요.\n\n![image](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_2.png)\n\n처음 텍스트 출력물은 놀랍네요. TypeScript를 거의 10년 동안 다루어왔지만, TypeScript 컴파일러 API에서 무언가를 가져오거나 내보내 본 적이 없었어요. 코드는 정말 흥미로워요:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_3.png\" />\n\n이것은 멋진 시작이에요. 컴파일러 API에서 정보를 추출할 수 있는 매우 간단하고 우아한 방법에 대해 동시에 배우고 있어요. 이 방법은 코드-퍼스트 솔루션에 대한 제 아이디어의 기능 프로토 타입을 계속 구축할 수 있는 필요한 모든 정의로 연결되는 게이트웨이에요. 그리고 프로토타입 코드가 실시간으로 작성돼요. ChatGPT와 함께 작업하는 핵심 개념에 접근할 수 있는데, 그 중 가장 흥미로운 건 오직 올바른 방법으로 프롬프트하면 솔루션에 대한 많은 연구를 처리할 수 있다는 거에요.\n\n심지어 코드 파일로 복사하여 추가 수정 없이 다중 행 주석으로 붙여넣을 수 있는 작동 방식에 대한 설명도 포함돼 있어요:\n\n<img src=\"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n하지만 그 다음에 나오는 내용은 제가 찾던 것과는 조금 다릅니다. ChatGPT는 다음 코드 파일에서 기존 솔루션을 재정의하고 로컬 Postgres 데이터베이스가 설정되었고 Sequelize가 추가되었으며 classInfoList 출력을 통해 정의된 모델을 설정합니다.\n\n![이미지](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_5.png)\n\n우리가 찾던 것은 아닌 것 같고, 원래 프롬프트를 다시 살펴보면, 실제 마이그레이션이 발생하지 않도록 했어야 합니다. 우리가 원한 것은 단지 마이그레이션을 생성하는 다른 전략을 \"연결할\" 수 있는 인터페이스를 생성하는 것이었습니다.\n\n그래서 해야 할 일 목록에서, ChatGPT가 우리를 다음과 같은 불필요한 일로부터 구해준 것을 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 우리가 존재하는 것을 모르고 발견 못할 수도 있는 해결책에 대해 조사 중이었습니다.\n- 원본 파일에서 클래스와 종속성을 추출할 수 있는 초기 프로토타입을 작성 중입니다.\n\n처음부터 끝까지 생성된 모든 것, 처음에 정규 표현식 및 마지막에 Sequelize를 포함한 모든 것은 유용하지 않으며 사양의 일부도 아닙니다. 적어도 이 복잡한 프롬프트에 대한 어느 정도의 이해를 보여줍니다. 이 경우에는 ChatGPT가 몇몇 비관론자들이 예측한 것보다 전반적으로 조금 덜 진전을 남겼다는 것을 안타깝게 생각합니다.\n\n우리의 Code-First 이관 도구를 위한 인터페이스를 구축하기 시작하는 것부터 유용하게 일부 코드를 적응해봅시다. 테이블 생성을 스크립팅하기 위해 필요한 TableInfo 유형 및 지원 유형을 정의하는 것부터 시작합니다:\n\n이 유형은 약간 복잡합니다. 그러므로 최종적인 TableInfo 인터페이스로부터 분해해 보겠습니다. 클래스 이름에서 파생된 테이블 이름, 열 집합 및 테이블 간 관계를 나타내는 문자열을 유지합니다.\n\n<div class=\"content-ad\"></div>\n\n- 관계 - 관계를 나열해 놓는 이유는 대부분의 RDBMS에서 활성 관계가 없는 경우 테이블을 삭제하는 작업이 가능하지 않은 경우가 있기 때문입니다. 관계를 나열함으로써 테이블을 만들고 삭제할 순서를 결정할 수 있습니다.\n- 컬럼 - 이는 테이블 정의의 본질을 담고 있습니다. 컬럼은 fieldName, datatype, nullable을 포함하며, 이는 자명한 내용입니다. \"modifiers\" 속성은 주/외래 키와 같은 주요 정의를 위한 대체 속성입니다.\n\n![image1](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_6.png)\n\n![image2](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_7.png)\n\n우리는 Automigrate API를 위한 일반적인 인터페이스를 정의했습니다. 이로써, 특정 데이터베이스를 위한 플러그인이 구현되어 있다면, 마이그레이터는 여러 데이터베이스 언어를 지원할 수 있을 만큼 유연해질 것입니다. 이제 프로그래밍할 인터페이스를 알았으니, CodeFirst 모델 관점에서 TableInfo를 작성하는 방법을 고민해볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n여기에 예시 모델 몇 개를 작성해 보겠습니다. 우리는 일종의 TypeScript 클래스로 일련의 테이블을 코드 기반으로 정의할 것입니다.\n\n이제 우리에겐 몇 개의 테이블이 있습니다: Project, Feature, Person, 그리고 Project_Persons입니다. 여기에 몇 가지 관계가 포함되어 있습니다. Feature가 Project에 속하고, Project에는 많은 사람들이 할당될 수 있지만, 사람들은 프로젝트 외부에서 관리되어야 합니다.\n\n그러나 현재 상태에서는 관계 자체를 정의할 수 없으며, 다른 곳에서 어떻게 가정할지도 어렵습니다. 또한 기본 키나 외래 키를 나타내는 필드 또는 이러한 외래 키가 어떻게 관련되는지를 관리하는 좋은 방법이 없습니다. 또한 사용자들이 이러한 관계를 추적하기 위해 모델에 추가 속성을 정의하거나 생성자에 정보를 넣어야 한다면 사용자 경험에 좋지 않을 것입니다.\n\n여기에는 필드에 메타데이터를 표시할 수 있게 해주는 실험적인 TypeScript 데코레이터 개념이 있습니다. '실험적인'이라는 표현에 겁먹지 마세요. 이 기능은 꽤 오랫동안 개선되어 왔습니다. 이를 활성화하기 위해 tsconfig.json 파일로 이동하여 experimentalDecorators와 emitDecoratorMetadata를 true로 표시하여 컴파일러에서 지원을 받을 수 있도록 설정해야 합니다. 이 작업을 마치면 기본 키와 외래 키에 대한 일부 데코레이터를 정의할 수 있어야 합니다:\n\n<div class=\"content-ad\"></div>\n\n이 코드는 두 개의 새로운 데코레이터, PrimaryKey 및 ForeignKey를 정의하고 reflect 라이브러리를 통해 메타데이터를 추출할 수 있는 메서드를 제공합니다. 여기서 \"target\"의 존재는 이러한 메서드를 클래스의 인스턴스화된 인스턴스에 호출하여 해당 메타데이터를 검색해야 한다는 것을 의미합니다. 이는 나중에 구현을 약간 복잡하게 만들 수 있지만 대부분의 경우에는 배포 스크립트를 효과적으로 작성할 수 있도록 해줄 것입니다.\n\n이 코드는 실험적인 것이며 위의 가설을 확인하고 싶으므로, 이러한 데코레이터가 예상대로 작동하는지 확인하기 위한 테스트도 작성하겠습니다:\n\n이러한 모든 테스트가 실행되고 통과되었으므로, 이제 코드 퍼스트 모델에서 이러한 새로운 데코레이터를 활용할 준비가 되었습니다. 우리가 조정한 CodeFirst.ts 파일을 보여주기 위해 여기서 차이를 사용하겠습니다:\n\n이제 우리가 예제 모델을 확인하고 지원하는 참조 메타데이터를 설정하고 플러그인 인터페이스를 구축했으므로, 문제의 핵심인 TypeScript 컴파일러 API를 통해 클래스 정의의 메타데이터를 추출할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n원래의 ChatGPT 코드 출력으로 돌아가 봅시다. 그 코드는 디렉토리에서 파일을 가져 와 TypeScript API를 통해 ClassInfo를 검색 한 다음 해당 이름과 종속성을 반환하는 코드를 생성 했습니다. 모두 함께, 우리가 작성해야 하는 유형의 코드입니다. 이 코드를 관련 책임으로 분해하여 각각에 대해 고려하고 무슨 일이 일어나고 있는지 명확하게합니다.\n\n제가 말하고 싶은 것은 애플리케이션의 주요 부분에서 소스에서 파일을 검색하는 처리를 처리하고 싶지 않다는 것입니다. 이는 애플리케이션의 외부에서 발생해야 하므로, 소스 파일이 위치한 곳을 선택할 수 있도록 새로운 Modeler 클래스를 만들 것입니다. 이때 다른 사람이 우리 라이브러리를 사용하려는 경우 소스 파일의 위치를 지정할 수 있습니다.\n\nTypeScript 컴파일러의 SourceFiles 유형을 사용하고 코드를 가져 오기위한 방법을 구현할 것입니다. 예제 디렉토리에서 사물을 테스트 할 수 있도록:\n\n여기서 SourceExtractor 클래스를 만들었습니다. 이 클래스에는 두 개의 static 메서드가 있습니다 - getSourceFile 및 getFilesFrom이라는, 파일을 읽고 해당 TypeScript SourceFile을 검색하기 위해 문자열 인수를 취하는 메서드입니다. 이것은 이제 클래스 정의를 해석하고 플러그인 API 유형을 생성하는 모델러에게 전달될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n먼저, 소스 파일 유형을 사용 가능한 데이터로 분해하는 데 도움이 되는 메서드를 분해하고 구축하는 것부터 시작합시다:\n\n소스 파일을 구문 분석하는 데 도움이 되는 몇 가지 메서드가 있습니다.\n\n- tryGetTargetInstance — 모델에서 클래스를 인스턴스화하여 반환합니다. 실행 중에 클래스가 등록되지 않은 경우, 실행이 실패한 이유를 명시적으로 알려주고 사용자가 어떻게 해야 하는지 설명하는 오류가 발생합니다.\n- getPropertiesOf — 클래스 멤버에서 속성을 필터링하는 데 도움이 되는 구문 설탕\n- getClassesFrom — 소스 파일에서 클래스를 필터링하는 데 도움이 되는 구문 설탕\n- processClassFile — 이것은 단일 클래스 속성 처리를 기대하는 뼈대 메서드입니다. 우리의 이상적인 결과는 전체 ColumnDefinition 또는 속성이 어떤 이유로 표현할 수 없는 경우 false입니다.\n- getColumnDefinitionsFrom — ColumnDefinitions를 생성하는 데 호출할 메서드입니다. 또한 출력에서 구문 분석 실패를 필터링합니다.\n\n이제 추출기를 설정하여 소스 파일 구문 분석기의 도우미 메서드를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n모델러는 여기서 단 하나의 도우미 함수인 extractForeignKeyTables만 가지고 있습니다. 이 함수는 현재 열 목록과 다른 모델 간의 종속성 목록을 생성하여 출력된 업 및 다운 마이그레이션의 순서를 정렬합니다.\n\n이외에도 추출 메서드는 간단합니다. 소스 추출기로 추출할 파일과 등록된 유형을 사용하여 TableInfo[]를 생성하는데, 모두 정적 타입 확인으로 강제됩니다. 이는 각 파일을 반복하고 클래스를 가져와 getColumnDefinitions 메서드를 통해 인터페이스 정의를 추출하는 방식으로 동작합니다. 또한 우리의 도우미 함수를 활용하여 마이그레이션을 구축하는 데 필요한 모든 정보를 얻을 수 있습니다.\n\n이제 라이브러리를 사용하는 최종 사용자의 관점에서 어떻게 보일지 살펴보는 것이 좋을 것 같습니다. 이전에 코드 퍼스트 예제 파일을 검토했지만, 그것을 어떻게 통합할까요? 간단히 다음과 같이 요약해 봅시다:\n\n매우 간단합니다! 먼저 대상 파일(이 경우 CodeFirst.ts 파일)을 가져와 파일로부터 모델 추출을 실행하고 TableInfo 인터페이스를 상태 파일로 출력할 수 있습니다. 이는 로컬 환경과 새로 만든 변경 사항 간의 차이점을 나타내는 변경점에 대해서만 스크립트를 생성하기 위해 이전 마이그레이션 간의 차이를 구현할 가능성이 높은 곳입니다.\n\n<div class=\"content-ad\"></div>\n\n추가로 예제 플러그인이 생성하는 것을 모델링할 수 있습니다. AutomigrateAPI 인터페이스를 구현하는 스텁 클래스를 간단히 선언하여 해당 정보를 스크립트 파일로 출력하면 됩니다. 이러한 스크립트는 마이그레이션을 수행하는 대상 환경에서 실행하는 것입니다.\n\n사용하기 매우 쉽고 인터페이스에 대해 매우 확신하고 있습니다. 충분한 테스트 커버리지가 있으므로 자신 있게 변경을 할 수 있고 필요에 따라 테스트를 조정할 수 있습니다. 이제 소스 파일 해석이 작동하도록 해 봅시다!\n\n자주 마주칠 개념 중 하나는 TypeScript 컴파일러 API가 구문에 대한 자체 내부 표현을 가지고 있다는 것입니다. 이는 SyntaxKind라는 enum 안에 존재하며 컴파일러가 인식하는 코드의 각 부분에 대한 표현이 있습니다. typescript.d.ts에서 SyntaxKind 정의로 이동하는 단축키인 fn+F12를 사용하여 액세스할 수 있습니다:\n\n![이미지](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_8.png)\n\n<div class=\"content-ad\"></div>\n\n그래서 필요한 것은 TypeScript 컴파일러 출력을 해석하고 작업 중인 인터페이스를 위해 이러한 유형 (DatabaseType)의 표현을 반환하는 기능 세트가 있어야 할 것 같아요.\n\n일단 이를 작성해 봅시다:\n\ntypescriptSyntaxKindToDatabaseTypeMap은 우리 라이브러리의 \"방해 방지 계층\"으로 존재하여 우리가 필요에 따라 쉽게 변화할 수 있게 해줍니다. 대부분이 꽤 직접적인 변환인 점을 고려하면, SyntaxKind를 그대로 사용하고 SyntaxKind.UndefinedKeyword와 SyntaxKind.TypeReference을 만나면 단순히 정의되지 않은 값을 반환하는 것이 아닌가하는 의문이 생길 수 있습니다. 그 이유는 이 라이브러리가 항상 TypeScript 컴파일러를 사용할지 알 수 없기 때문입니다.\n\n이 방법을 통해 API로부터 기저 구현의 세부 정보를 반환함으로써 이를 넘나드는 방법을 만들어봅시다. 우리가 지금 사용하는 것보다 우수한 새 라이브러리를 찾으면 이 라이브러리와는 아무 상관이 없는 응용 프로그램 코드의 중요 부분이 변경되어야 할 수도 있음을 발견할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nextractKeyData 메소드는 클래스 파일을 해석하면서 클래스 객체의 인스턴스에서 데코레이터 (AKA 키 데이터)를 생성합니다. 이는 미래 마이그레이션을 위한 ColumnDefinitions을 생성하는 중요한 부분입니다.\n\n이전에는 processClassProperty라는 메서드 스텁을 추가하여 코드를 작성할 준비를 했습니다. 이제 해당 스텁을 제거하고 TypeScript 컴파일러 API를 통해 많은 속성 정보 추출을 처리할 새 파일에 재작성하겠습니다.\n\n원래 ChatGPT 구현의 \"본질\"은 TypeScript 컴파일러 API에 대해 약간 배웠던 곳에 있습니다. 이를 통해 각 속성 선언이 여러 연관 값들을 가지고 있고, 컴파일러 API가 노드를 평가하는 데 일부 단순화된 도우미를 제공한다는 것을 알게 되었습니다. 몇 가지 유효성 검사 후 정적 유형 확인이 어떻게 타입을 표현하는지도 조금 배우게 될 것입니다.\n\n이는 상당히 큰 코드 청크이므로, 먼저 processClassProperty 메서드에서부터 다른 코드 경로를 방문하면서 분석해 보겠습니다. GitHub에 통합된 빠른 머메이드 차트를 작성해보겠습니다. 이를 README와 함께 문서화의 나머지 부분에 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nflowchart TD\n A[processClassProperty]\n A --> B{Is Union Type?} \n B --> |No| singleNode[processSingularNode]\n B --> |Yes| C[Definition is Valid]\n C --> |No| E[Error]\n C --> |Defined Type| singleNode\n singleNode --> typeRefCheck{Node Type?}\n typeRefCheck --> |TypeReference or date| pTypeRef[processFromTypeReferenceNode]\npTypeRef --> return\n typeRefCheck --> |Array| arrayCheck{Is array type?}\n arrayCheck --> retArr[Retrieve array type]\n retArr --> typeRefCheck\n typeRefCheck --> |Basic Type| basicType[typescriptSyntaxKindToDatabaseTypeMap]\n return((return ColumnDefinition))\n basicType --> return\n typeRefCheck --> |Else| error[Error]\n```\n\n![image](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_9.png)\n\n첫 번째 호출이 속성이 공용 형식인지 여부에 따라 분기되는 것을 볼 수 있습니다. 이는 공용 형식을 사용하는 방식 중 하나로 \"archived: boolean | undefined\"와 같이 null 값을 db 모델로 나타낼 수 있는 방법입니다. 반면에 \"string | number\"를 허용하는 모델을 작성하려는 경우, 대부분의 데이터베이스에서 이를 표현할 수 없으므로 이를 시도하는 사람에게 명시적인 오류를 throw합니다. Else 조건의 경우 \"정의되지 않은 형식\" 노드를 일반적으로 처리할 것입니다.\n\n그리하여 processSingularNode로 이어지는데, 이 처리 과정이 우리의 분류 작업의 주된 부분을 담당합니다. 현재 노드 유형을 가져오고 여러 코드 경로가 있으며 각각은 열 정의를 생성하는 방식에서 약간의 차이가 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n- Array - 배열은 자체 유형이며 그 아래에 더 많은 노드가 있어 배열화된 값을 정의합니다. 이에 따라 주요 배열 유형을 추출한 후 processSingularNode 호출로 다시 전달해야 합니다. 거기서 반환 값을 내부적으로 처리할 수 있습니다.\n- TypeReference - TypeReference는 사용자가 정의한 클래스나 JavaScript 자체의 데이터 유형인 이 속성을 의미합니다. 두 경우 모두 다룰 것이지만, 현재 우리는 다른 비-기본 유형에 대해서는 아무것도 하지 않습니다.\n- 기본 유형 - 여기서 TypeScript 유형을 API 호출용 데이터범에 매핑하고 값을 반환합니다.\n\n이를 넘어서, 이제 ColumnDefinition을 메인 응용 프로그램으로 반환하고 있습니다! 이제 응용 프로그램을 테스트하고 프로토타입을 구현할 수 있습니다. 인기 있는 데이터베이스인 Postgres 플러그인을 만들어보겠습니다.\n\n플러그인을 구현하는 사람을 위해 drop table 문의 정렬기가 유용하다는 것을 알고 있습니다. 플러그인을 활용하는 누구나 테이블 삭제를 순서대로 처리하는 정렬기를 사용할 수 있도록 하겠습니다. 우리가 각 구현에서 수행해야 할 것임을 알고 있기 때문에 모든 사람들의 시간을 절약하기 위해 도움말 파일을 추가하겠습니다:\n\n그리고 자신의 테이블이 효과적으로 정렬되는지 확인하기 위해 몇 가지 테스트를 작성해보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n상단의 테스트에서 우리가 기대한 정렬 순서가 유지되었음을 확인했으므로 테이블을 올바르게 삭제할 것입니다. 이것은 특히 복잡한 시나리오를 처리하지는 않지만, 미래 유지보수자나 이관 도구를 사용하고 싶어하는 사람들에게 일부 테스트된 리소스를 제공하는 방법을 보여주기 위한 단순한 구현입니다.\n\n이제 빠르게 Postgres 플러그인을 만들어 봅시다:\n\n이 플러그인은 조금 무겁지만, 빠르게 살펴보겠습니다:\n\n- postgresMap은 데이터베이스 유형 추상화에서 Postgres의 데이터 유형으로의 관계를 제공합니다. 이는 열 정의를 구성할 때 사용됩니다.\n- columnMap은 열을 생성하는 방법입니다. 가능한 옵션의 배열을 만들고, junk를 제거하기 위해 boolean에 맞게 필터링한 다음, 이를 하나의 공백으로 결합합니다. 여기에는 열의 기본/외래 키 지정도 포함되어 있습니다.\n- relationshipMap은 외래 키 관계를 매핑하는 작은 도우미입니다.\n- tableCreateMapper는 매우 직관적으로 단일 완전한 테이블 생성 스크립트를 생성합니다.\n- tableDropMapper는 유사하지만 테이블 삭제용입니다.\n- PostgresPlugin은 AutomigrateAPI를 실제로 구현하는 클래스입니다. 다른 함수들을 한 곳에 모아 AutoMigrateOutput을 생성하여 데이터베이스에 적용할 수 있는 up-and-down 이관을 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n좋아요, 이제 모든 코드를 미리 작성했고 모델도 작성했으니, 테스트를 한 번 해보겠습니다! 먼저, 방금 작성한 Postgres 플러그인을 사용하도록 예제 인덱스 파일을 변경하겠습니다:\n\n위의 차이점을 보면 예제 플러그인을 PostgresPlugin으로 교체하는 것을 보여줍니다. 이런 식으로 인터페이스를 활용하는 것의 장점은 이 코드 조각을 쉽게 교체할 수 있으며, 테스트의 다른 부분에는 변경이 필요하지 않다는 것입니다. 모든 것이 여전히 동일하게 작동합니다. 실행하면 두 가지 예상 출력이 생성됩니다: 현재 실행 상태를 포함하는 state/state.json 파일과 API 인터페이스에서 정의한 마이그레이션을 포함하는 scripts/scripts.json 파일(문자열 배열로 된 up 및 down).\n\n우리의 출력 상태에는 테이블 정보 배열이 포함되어 있습니다. 이 배열은 테이블 이름, 열, 다른 테이블과의 관계에 대한 문자열 배열을 포함합니다. 열 정의에는 필드 이름, 열 유형, Null 여부 및 수정자(즉, 키)가 포함됩니다. 이 모든 것이 플러그인에게 유효한 마이그레이션을 생성하는 데 필요했던 내용입니다. 이것은 기본 사례를 다루지만, 프로덕션 환경에서 플러그인을 올바르게 관리하기 위해 상태 파일의 다른 반복을 저장하고 비교해야 할 것입니다.\n\n생산된 마이그레이션이 무엇인지 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n저희가 보았을 때, 출력물이 API 정의와 일치하는 것을 확인할 수 있습니다. up 및 down 문자열 배열을 포함하는 JSON 객체는 마이그레이션 프로세스의 단계를 나타냅니다. 테이블 생성문이 작동하고, 데이터를 제대로 비우기 위해 테이블 삭제문이 순서대로 나열되어 있어 우리의 다운 마이그레이션 작업이 문제없이 진행될 수 있음을 알 수 있습니다. 우리의 기본 케이스가 잘 이행된 것이죠!\n\n# 다음 단계\n\n마이그레이션 도구를 프로덕션 환경에 사용할 수 있도록 만드는 것은 범위를 벗어나지만, 이 곳에서 생성된 로직의 대부분이 이미 완성되었으므로 우리에게는 꽤 간단한 길이 있다는 것을 알고 있습니다. 프로덕션 환경에 맞게 만들기 위해 statefile 작업에 관한 몇 가지를 변경해야 합니다:\n\n- 내부적으로 statefile을 관리하기 위해 라이브러리의 실행 프로세스를 수정하거나 새로운 메소드 집합을 개발합니다.\n- statefile에 해시 코드 또는 날짜 후위사항을 추가하여 어떤 순서로 statefile을 고려해야 하는지 추적할 수 있도록 합니다.\n- statefile 간의 차이를 활용하여 플러그인 아키텍처에서 호출할 메소드를 결정하는 책임을 지는 클래스를 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n이렇게 하면 라이브러리 코드 실행 사이에 마이그레이션 차이점만 적용할 수 있습니다.\n\n플러그인 자체에 대해 말하자면, 지금은 완전히 구현된 테이블만 생성할 수 있습니다. 단일 책임 원칙을 위반하지 않고 플러그인 아키텍처를 명확하고 간결하게 유지하는 가장 좋은 방법은 차이점을 처리하고 이를 플러그인 API 호출로 변환하는 레이어를 삽입하는 것입니다. 우리를 제품 사용 가능한 상태로 이끌 수 있는 몇 가지 API 변경과 수정이 있습니다:\n\n- 테이블 제거\n- 열 추가/삭제/변경\n- 관계 변경\n- 수동 스크립트 (데이터 마이그레이션 등)\n\nChatGPT가 우리에게 가르칠 수 있는 것들을 살펴보고 TypeScript 컴파일러 API에 대해 좀 더 배우는 것을 즐겼으면 좋겠습니다. 이것은 메타 프로그래밍 작업에 강력한 도구이며 개발자의 관점에서 매우 흥미로운 기능입니다.\n\n<div class=\"content-ad\"></div>\n\n최종 작동 코드를 확인하고 싶다면, 디버깅으로 실행하고 npm 설치를 위한 로컬 라이브러리 빌드 구성이 포함된 최종 운영 코드를 확인하실 수 있습니다. GitHub 링크는 여기 있어요:\n\n읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_0.png"},"coverImage":"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_0.png","tag":["Tech"],"readingTime":15},{"title":"Angular 18의 새로운 기능 알아보기","description":"","date":"2024-05-27 18:51","slug":"2024-05-27-WhatsnewinAngular18","content":"\n\n![image](/assets/img/2024-05-27-WhatsnewinAngular18_0.png)\n\n2024년 5월 23일에 릴리스된 Angular의 새로운 버전인 Angular 18은 개발을 간소화하고 성능을 향상시키며 보다 동적인 웹 애플리케이션을 작성할 수 있도록 개선 사항을 가져왔습니다. 주요 기능들을 살펴보고 Angular 경험을 더 높여줄 수 있는 기능들을 살펴보겠습니다.\n\n## 독립형 컴포넌트 — 더 간단하고 재사용 가능한 구성 요소\n\nAngular 18은 독립형 컴포넌트를 소개하여 NgModules의 제약 없이 재사용 가능한 컴포넌트를 만들 수 있게 했습니다. 이를 통해 프로젝트 구조를 간소화하고 보일러플레이트 코드를 줄이며 모듈식 접근 방식을 사용할 수 있습니다. 더 작고 독립적인 컴포넌트로 복잡한 UI를 구축하고 이를 유지 보수하고 응용 프로그램의 다른 영역 간에 공유하기 쉽게 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n아래에는 기본 독립형 컴포넌트를 보여주는 코드 예제가 있습니다:\n\n![DatePickerComponent](/assets/img/2024-05-27-WhatsnewinAngular18_1.png)\n\n이 예제에서 DatePickerComponent는 NgModule이 필요하지 않습니다. 직접 가져와서 애플리케이션의 루트 모듈이나 다른 컴포넌트에서 사용할 수 있습니다. 이를 통해 UI를 구축하는 더 가벼운 방식과 조립 가능한 방식을 촉진합니다.\n\n## Zone-less Change Detection — 성능 향상 (실험적)\n\n<div class=\"content-ad\"></div>\n\nAngular 18은 실험적 기능으로 Zone-less 변화 감지를 소개했습니다. Zone.js에 대한 의존성을 제거함으로써, 이 방식은 특히 대규모 애플리케이션에서 성능 향상을 이끌어낼 수 있습니다. Zone.js는 특정 시나리오에서 오버헤드를 일으킬 수 있으며, Zone-less 변화 감지는 Angular 애플리케이션 내에서 변화 감지에 대한 대안적 접근 방식을 제공합니다.\n\n## 함수를 이용한 라우트 리다이렉트 — 유연한 라우팅 제어\n\n함수를 정의할 수 있는 기능을 통해 라우트 리다이렉트는 더 많은 기능을 얻습니다. 이를 통해 애플리케이션의 라우팅 전략 내에서 더 동적이고 조건부적인 리다이렉션 로직을 구현할 수 있습니다. 사용자 역할, 인증 상태 또는 기타 동적 조건에 따라 리다이렉트를 생성하는 상황을 상상해보세요.\n\n![이미지](/assets/img/2024-05-27-WhatsnewinAngular18_2.png)\n\n<div class=\"content-ad\"></div>\n\n## 개선된 디버깅 도구 — 문제 해결이 쉬워집니다\n\nAngular 18은 디버깅 도구를 개선했으며 의존성 주입 계층 구조에 대한 더 나은 가시성과 DI 관련 문제에 대한 개선된 오류 메시지를 제공합니다. 복잡한 Angular 애플리케이션의 디버깅은 때로는 어려울 수 있습니다. 개선된 디버깅 도구는 의존성 주입과 관련된 문제를 더 쉽게 식별할 수 있도록 도와주며 디버깅 프로세스를 간소화합니다.\n\n## 새롭고 업데이트된 웹 사이트\n\nAngular.io가 Angular.dev로 대체되었습니다. 기능인 문서, 튜토리얼 및 새로운 기능을 살펴볼 수 있는 플레이그라운드와 함께 재정의된 사용자 인터페이스를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-WhatsnewinAngular18_3.png\" />\n\n## 강조점 너머\n\n이것들은 Angular 18의 많은 흥미로운 기능 중 일부입니다. 다른 주목할만한 개선 사항은 다음과 같습니다:\n\n- 향상된 AOT 컴파일: 더 효율적인 AOT 컴파일 프로세스로 대규모 응용 프로그램의 빌드 시간을 단축하고 실행 시간 성능을 향상시킬 수 있습니다.\n- ng-content 기본 콘텐츠: 컴포넌트 템플릿의 유연성을 높이기 위해 ng-content 태그 내에서 기본 콘텐츠를 직접 정의할 수 있습니다. 이를 통해 구성 요소의 구조를 단순화하고 콘텐츠가 어떻게 투영되는지에 대한 더 많은 제어권을 제공할 수 있습니다.\n- TypeScript 5.5 지원: TypeScript의 최신 기능과 개선 사항을 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 앵귤러 개발의 미래에 도전하세요\n\n성능, 개발자 경험 및 모듈성에 초점을 맞춘 Angular 18은 우수한 웹 애플리케이션을 구축할 수 있도록 돕습니다. 이러한 기능에 대해 자세히 살펴보고 다음 프로젝트에서 Angular 18의 전체 잠재력을 발휘하기 위해 공식 Angular 문서를 탐험해보세요.\n\n기억하세요, 이것은 시작에 불과합니다. Angular 18은 탐험할 다양한 기능을 제공합니다. 포괄적인 세부 정보 및 코드 예제를 위해 공식 문서를 참조해보세요.\n\n원문: [https://cheeseblogger.com](https://cheeseblogger.com), 2024년 5월 25일에 게시됨","ogImage":{"url":"/assets/img/2024-05-27-WhatsnewinAngular18_0.png"},"coverImage":"/assets/img/2024-05-27-WhatsnewinAngular18_0.png","tag":["Tech"],"readingTime":3},{"title":"ElysiaJS 소개 및 정리","description":"","date":"2024-05-27 18:50","slug":"2024-05-27-FirstLookAtElysiaJS","content":"\n\n## 새로운 번 런타임 환경에서 현대적인 API 구축\n\n중간에 Medium에 오랫동안 없어서 죄송합니다. 제가 계획한 기사 시리즈, 튜토리얼, 고찰 및 코드를 공유하기 위해 기다리고 있습니다.\n\n최근에 프론트엔드 개발자로서 큰 전기를 경험했습니다. 백엔드 개발에 더 많은 시간을 투자해야겠다고 결정했습니다. 최근에 트윗을 읽고 새로운 기술이 Ben Holmes의 의견을 이끈다는 것에 대해 생각해보게 되었습니다.\n\n인터넷 전체(Reddit.com만)를 연구하고 사람들의 의견을 듣고 나니, 개발자들은 여전히 Express를 좋아하는 것으로 결론을 내렸습니다. Express는 인터넷에 많은 것을 제공해 왔으며 여전히 가장 안정적인 라이브러리 중 하나입니다. 하지만 저는 개인적으로 다른 기술을 시도하고 다른 기술에 도전하고 싶었습니다. 그때 발견한 것이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n# 번\n\n![이미지](/assets/img/2024-05-27-FirstLookAtElysiaJS_0.png)\n\n와 어마어마해! 그게 필요한 거잖아. 또 다른 자바스크립트... 잠깐, 런타임 환경?\n\n맞아, 라이브러리나 프레임워크가 아니야; 런타임 환경이거든. 2018년에 Ryan Dahl이 Node 문제를 해결하기 위해 Deno를 발명했지만, 그렇게 유명해진 것 같지는 않아.\n\n<div class=\"content-ad\"></div>\n\n2023년 9월 8일, Bun이 첫 안정 버전을 출시했어요. 많은 JavaScript 개발자들이 이 새로운 런타임 환경을 시도 중이고 매우 유망해 보여요. Next, Nuxt, SvelteKit과 같은 유명한 프론트엔드 프레임워크들이 Bun을 사용할 수 있는 옵션을 제공하고 있어요. 저는 Bun 라이브러리들을 살펴보았고 API를 구축하기 위해 이것을 배우기로 결정했어요:\n\n# ElysiaJS\n\n![ElysiaJS](/assets/img/2024-05-27-FirstLookAtElysiaJS_1.png)\n\nElysiaJS는 자신을 \"에르고노믹 프레임워크\"로 소개하며 엔드투엔드 유형 안전성을 제공한다고 주장해요. 이 언어를 시험해보고 나서, 나는 이것을 매우 직관적으로 느꼈어요. 풍부한 API, 훌륭한 플러그인 관리 및 원하는 것이 정확히 얻을 수 있도록 보증해주는 견고한 유효성 검사 API가 있어요.\n\n<div class=\"content-ad\"></div>\n\n# Elysia 설치하기\n\n이 문서에서는 이미 Bun을 설치했다고 가정합니다. 다음과 같이 새로운 Elysia 애플리케이션을 생성할 수 있습니다:\n\n```js\nbun create elysia hello-server\ncd hello-server\n```\n\n기존 애플리케이션이 있다면, Elysia를 다음과 같이 설치할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nbun add elysia\n```\n\n그리고 여기에 자세히 설명된 패키지.json 파일에 필요한 스크립트를 설정하세요.\n\n# ElysiaJS 첫 번째 살펴보기\n\n몇 줄의 코드로 매우 간단한 서버를 시작할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* src/index.ts */\nimport { Elysia } from 'elysia';\n\nconst app = new Elysia()\n  .onStart(() => console.log(\"서버가 시작되었습니다!\"))\n  .get('/', () => \"안녕하세요 서버\")\n  .listen(8080);\n```\n\n이 서버를 실행하고 테스트할 수 있습니다:\n\n```js\n$ bun dev\n서버가 시작되었습니다!\n\n$ curl http://localhost:8080/\n안녕하세요 서버\n```\n\n더 많은 라우트를 그룹화하고 생성하기 위해 인스턴스를 만들고 메인 애플리케이션에서 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"node src/index.ts\"\n  },\n  \"dependencies\": {\n    \"elysia\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^4.0.3\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n대부분의 프레임워크는 Elysia가 하는 일을 합니다. 그런데 왜 Elysia가 다른 것일까요? 그것은 타입 안전성과 유효성 검사 때문입니다. 위의 나이 예제를 고려해보세요. 나이는 어떤 타입이든 될 수 있습니다. 이것은 타입 안전하지 않습니다.\n\n```js\n/* src/index.ts */\nimport { Elysia, t } from 'elysia';\n\nconst age = new Elysia()\n  .get('/age', () => \"당신의 나이를 모릅니다.\")\n  .post('/age', ({ body: { age } }) => `안녕하세요, 당신은 ${age}살 입니다.`, {\n    body: t.Object({\n      age: t.Number()\n    })\n  });\n\nconst app = new Elysia()\n  .onStart(() => console.log(\"서버가 시작되었습니다!\"))\n  .get('/', () => \"안녕하세요 서버\")\n  .use(age)\n  .listen(8080);\n```\n\n이 서버를 다시 실행하고 bun dev를 사용하여 테스트해보세요.\n\n```js\n$ curl -v -H \"Content-Type: application/json\" \\\n>   -X POST \\\n>   -d '{\"age\": \"20\"}' \\\n>   http://localhost:8080/age\n{\n  \"type\": \"body\",\n  \"at\": \"age\",\n  \"message\": \"예상된 숫자\",\n  \"expected\": {\n    \"age\": 0\n  },\n  \"found\": {\n    \"age\": \"20\"\n  },\n  \"errors\": [\n    {\n      \"type\": 41,\n      \"schema\": {\n        \"type\": \"number\"\n      },\n      \"path\": \"/age\",\n      \"value\": \"20\",\n      \"message\": \"예상된 숫자\"\n    }\n  ]\n}\n```\n\n<div class=\"content-ad\"></div>\n\nElysiaJS에서는 나이 대신 숫자가 아닌 문자열을 보내면 오류가 발생합니다. 서버 측 개발자로서, 본문 데이터를 수동으로 유효성 검사할 필요가 없었습니다. 응답의 헤더를 보면 HTTP/1.1 400 Bad Request가 반환되는 것을 확인할 수 있습니다. 정수를 전달하면 curl이 성공합니다.\n\n```js\n$ curl -v -H \"Content-Type: application/json\" \\\n>   -X POST \\\n>   -d '{\"age\": 20}' \\\n>   http://localhost:8080/age\nHi, you are 20 years old\n```\n\n# ElysiaJS/Eden\n\n이것은 Type-Safety 제목의 확장입니다. API 엔드포인트를 테스트할 때 curl을 사용했습니다. 개발자로서, Postman이나 wget을 사용할 수도 있지만 이러한 도구들은 타입 안전하지 않습니다. 요청을 할 때 실수를 하면 정의되지 않은 동작이 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n프론트엔드 애플리케이션은 API 요청을 할 때 타입 오류가 발생하기 쉽습니다. tRPC는 이 기능을 제공하는 좋은 시도였지만, 프로젝트를 구현하기 위한 적응성이 큰 단점이었습니다. Eden은 이 문제를 훌륭하게 해결하여 이 시리즈의 향후 기사에서 자세히 다루겠습니다.\n\nEden으로 돌아와서, 라우트가 원하는 대로 작동하는지 확인하기 위해 일부 유닛 테스트를 작성해보겠습니다. 먼저 index.ts에서 애플리케이션 타입을 내보내야 합니다.\n\n```js\n/* src/index.ts */\nimport { Elysia, t } from 'elysia';\n\nconst age = new Elysia()\n  .get('/age', () => \"당신의 나이를 모르겠어요\")\n  .post('/age', ({ body: { age } }) => `안녕하세요, 당신은 ${age}살 입니다`, {\n    body: t.Object({\n      age: t.Number()\n    })\n  });\n\nconst app = new Elysia()\n  .onStart(() => console.log(\"서버가 시작되었습니다!\"))\n  .get('/', () => \"안녕하세요 서버\")\n  .use(age)\n  .listen(8080);\n\nexport type App = typeof app // <- 타입을 내보내기\n```\n\n두 번째로, 유닛 테스트를 작성할 수 있습니다. 의존성으로 @elysiajs/eden을 설치해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* test/route.test.ts */\nimport { describe, expect, it } from 'bun:test';\nimport { edenTreaty } from '@elysiajs/eden';\nimport { type App } from '../src';\n\nconst BASE_URL = \"http://localhost:8080\";\nconst app = edenTreaty<App>(BASE_URL);\n\ndescribe(\"Age API\", () => {\n  it(\"GET / works as expected\", async () => {\n    const { data, status } = await app.get();\n\n    expect(data).toBe(\"Hello Server\");\n    expect(status).toBe(200);\n  });\n\n  describe(\"/age routes\", () => {\n    it(\"GET /age returns IDK\", async () => {\n      const { data, status } = await app.age.get();\n\n      expect(data).toBe(\"I don't know your age\");\n      expect(status).toBe(200);\n    });\n\n    it(\"POST /age with number returns OK\", async () => {\n      const body = { age: 20 };\n      const { data, status } = await app.age.post(body);\n\n      expect(data).toBe(`Hi, you are ${body.age} years old`);\n      expect(status).toBe(200);\n    });\n\n    it(\"POST /age with string returns error\", async () => {\n      const body = { age: \"20\" };\n      const { status, error } = await app.age.post(body);\n\n      expect(status).toBe(400);\n      expect(error).toBeTruthy();\n    });\n\n    it(\"POST /age with wrong key returns error\", async () => {\n      const body = { myAge: \"20\" };\n      const { status, error } = await app.age.post(body);\n\n      expect(status).toBe(400);\n      expect(error).toBeTruthy();\n    });\n  })\n});\n```\n\n우리가 가진 라우트에 대한 유형이 edenTreaty에서 반환될 때 다음과 같이 매핑됩니다:\n\n```js\nGET /              -> app.get()\nGET /age           -> app.age.get()\nPOST /age          -> app.age.post(body)\n\nGET /api/books     -> app.api.books.get()\nGET /api/books/:id -> app.api.books[id].get()\nPOST /auth/login   -> app.auth.login.post(body)\n```\n\nhttp://localhost:8080에서 서버를 실행 중이라면, 애플리케이션을 테스트해보세요.\n\n<div class=\"content-ad\"></div>\n\n\n$ bun test\nbun test v1.0.30 (1424a196)\n\ntest/route.test.ts:\n✓ Age API > /age routes > GET /age returns IDK [3.70ms]\n✓ Age API > /age routes > POST /age with number returns OK [1.35ms]\n✓ Age API > /age routes > POST /age with string returns error [5.12ms]\n✓ Age API > /age routes > POST /age with wrong key returns error [0.94ms]\n✓ Age API > GET / works as expected [0.59ms]\n\n 5 pass\n 0 fail\n 10 expect() calls\nRan 5 tests across 1 files. [43.00ms]\n\n\nEden은 E2E Type Safety를 얻을 수 있는 훌륭한 도구입니다. 이를 프런트엔드 애플리케이션에서 사용하거나 서버를 테스트할 때 활용할 수 있습니다.\n\n# 결론\n\n안타깝게도 이 글은 너무 길어져서 종료하겠습니다. 유용한 기능을 가진 Elysia에 대한 설명을 계속 진행할 수 없어서 유감스럽습니다. 더 많은 정보를 알고 싶다면 여기에서 문서를 확인할 수 있습니다. Elysia 팀은 훌륭한 일을 하고 있고 이 라이브러리가 밝은 미래를 가질 것으로 기대합니다. 첫 안정적인 릴리스를 기대할 수밖에 없네요.\n\n\n<div class=\"content-ad\"></div>\n\n제 기사를 즐겁게 읽어 주셨기를 바랍니다. 무슨 교훈이 있다면 더 좋겠네요. 감사합니다!\n\n```js\n연결하고 싶으시면?\n\n내 GitHub 프로필.\n내 포트폴리오 웹사이트.\n```","ogImage":{"url":"/assets/img/2024-05-27-FirstLookAtElysiaJS_0.png"},"coverImage":"/assets/img/2024-05-27-FirstLookAtElysiaJS_0.png","tag":["Tech"],"readingTime":8},{"title":"모던 브라우저에서 AWS S3 직접 업로드하는 방법","description":"","date":"2024-05-27 18:48","slug":"2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers","content":"\n\n안녕하세요, 제 이름은 Taylor Hughes입니다. 소프트웨어 엔지니어입니다. 저는 페이스북, 구글, 클럽하우스 및 중간의 여러 스타트업에서 앱을 출시하고 팀을 구축했습니다.\n\n사용자가 S3 버킷에 파일을 업로드할 수 있는 방법을 제공하는 문제는 모든 프로젝트에서 마주치는 문제입니다. 그러나 올바른 JavaScript 구성 요소를 식별하고 모든 것을 함께 작동하도록 설정하여이 작업을 수행하는 것은 마법처럼 느껴집니다.\n\nAWS 문서에 따르면 추가 인증 서비스를 설정하고 전체 AWS JS SDK를 클라이언트 코드로 가져와야하지만 실제로 그럴 필요는 없습니다!\n\n대신 사전 서명된 URL 및 현대적인 웹 API를 사용하여 브라우저에서 손쉽게 S3로 직접 업로드 할 수 있습니다. 코드 몇 줄을 사용하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n사용자 브라우저의 관점에서 전체 솔루션은 다음과 같습니다:\n\n- 사용자가 \"파일 업로드\"를 클릭하고 파일을 선택합니다.\n- 해당 파일의 메타데이터를 기반으로 서버 측 API에서 미리 서명된 S3 PutObject URL을 요청합니다.\n- 미리 서명된 S3 URL을 제공받으면 브라우저는 XmlHttpRequest를 사용하여 파일을 PUT하고 진행 상황을 모니터링할 수 있습니다.\n- 업로드가 완료되면 브라우저는 새 키를 다시 API로 반환하여 업로드된 파일에 대해 API가 수행해야 하는 작업을 트리거합니다.\n- 이윤 창출!\n\n만약 완성된 코드로 바로 이동하고 싶다면, TypeScript 프론트엔드 및 Python API 핸들러 예시가 포함된 gist를 확인해보세요.\n\n이 게시물에서는 단계별로 진행해 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n## AWS 구성\n\n먼저, 공개 액세스가 비활성화되어 있고 액세스 정책이 없는 새 버킷 yourproject-upload을 만듭니다. (또한 이 버킷에 대해 모든 것을 24시간 후에 만료되도록 하는 라이프사이클 규칙을 추가했습니다 — 업로드된 파일을 다른 위치로 이동하여 공개적으로 사용합니다.)\n\n둘째, web-upload-only라는 새 IAM 사용자를 추가합니다. 새 사용자의 액세스 키와 비밀을 가져와서 이를 백엔드 웹 서버에 추가하세요. (이 자격 증명은 주 AWS 자격 증명과 별도여야 합니다.)\n\n셋째, web-upload-only에게 새 버킷 yourproject-upload/*의 모든 경로에 대한 s3:PutObject 액세스 권한을 부여합니다. (우리는 사전 서명된 PutObject URL을 반환할 때 쓰기 키를 제한할 것입니다.)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers_0.png\" />\n\n마지막으로, 일반 AWS 역할 또는 사용자에게 yourproject-upload/* 버킷에 s3:GetObject 액세스도 부여하세요. 업로드 버킷에서 파일을 가져와 main/public 서빙 버킷으로 옮기기 위해 더 많은 권한을 가진 다른 사용자가 필요합니다.\n\n## 웹 서버: \"업로드 생성\" API 엔드포인트 추가\n\n새 IAM 사용자의 액세스 키와 시크릿을 얻었다면 이제 S3에 특정 키를 쓸 수 있는 사전 서명된 URL을 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 엔드포인트로 전송되는 입력은 다음과 같습니다:\n\n- content_type — 브라우저의 PUT 요청의 컨텐츠 유형으로 설정될 파일의 MIME 유형이며, 서명에 포함되어야 합니다.\n- filename — 파일의 원본 파일명으로, 여기서 확장자를 가져와서 S3 키에 좋은 확장자를 부여할 수 있습니다.\n\n이러한 입력을 바탕으로 AWS S3 클라이언트를 생성하고 서명된 PutObject URL을 생성하세요. Python에서 boto3를 사용하면 다음과 같이 보입니다:\n\n```python\ndef upload_s3_client() -> S3Client:\n    return boto3.client(\n        \"s3\",\n        aws_access_key_id=settings.UPLOAD_AWS_ACCESS_KEY_ID,\n        aws_secret_access_key=settings.UPLOAD_AWS_SECRET_ACCESS_KEY,\n        region_name=AWS_REGION,\n    )\n\n@api_view(\"/upload/create\")\ndef create_upload(request: Request) -> Response:\n    ext = request.validated_data[\"original_filename\"].split(\".\")[-1].lower()\n    # 생성된 S3 경로에 사용자 ID와 날짜 포함하기:\n    date = datetime.now().strftime(\"%Y%m%d\")\n    key = f\"uploads/{request.user.id}/{date}-{uuid.uuid4()}.{ext}\"\n    # 서명된 URL 생성:\n    presigned_upload_url = upload_s3_client().generate_presigned_url(\n        \"put_object\",\n        Params={\n            \"Bucket\": \"yourproject-upload\",\n            \"Key\": key,\n            \"ContentType\": request.validated_data[\"content_type\"],\n        },\n        ExpiresIn=60 * 60,\n    )\n    # 클라이언트에게 키 및 서명된 PutObject URL을 반환합니다:\n    return success_response(\n        {\"key\": key, \"presigned_upload_url\": presigned_upload_url}\n    )\n```\n\n<div class=\"content-ad\"></div>\n\n## 클라이언트 측: 모두 연결하기\n\n이제 클라이언트 측에서는 파일 입력란을 추가하여 파일 객체를 가져와야합니다. 한 번 파일 객체를 가져오면 새 API 백엔드에서 미리 서명된 URL을 요청할 수 있습니다. API 요청을 보통 어떻게 만들든지 상관없습니다:\n\n```js\nfunction getPresignedUrl(file: File) {\n  return makeAPIRequest(\n    \"POST\",\n    \"upload/create\",\n    {\n      original_filename: file.name,\n      content_type: file.type,\n    },\n    (response) => response as {\n      key: string;\n      presigned_upload_url: string;\n    },\n  );\n}\n```\n\n그런 다음, XmlHttpRequest를 만들어 파일을 직접 S3로 전송할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction uploadFile(\n  file: File,\n  presignedUploadUrl: string,\n  onProgress: (pct: number) => void,\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.upload.addEventListener(\"progress\", (e) => {\n      if (e.lengthComputable) {\n        const pct = e.loaded / e.total;\n        onProgress(pct * 100);\n      }\n    });\n    xhr.upload.addEventListener(\"error\", (e) => {\n      reject(new Error(\"Upload failed: \" + e.toString()));\n    });\n    xhr.upload.addEventListener(\"abort\", (e) => {\n      reject(new Error(\"Upload aborted: \" + e.toString()));\n    });\n    xhr.addEventListener(\"load\", (e) => {\n      if (xhr.status === 200) {\n        resolve();\n      } else {\n        reject(new Error(\"Upload failed \" + xhr.status));\n      }\n    });\n    xhr.open(\"PUT\", presignedUploadUrl, true);\n    try {\n      xhr.send(file);\n    } catch (e) {\n      reject(new Error(\"Upload failed: \" + e.toString()));\n    }\n  });\n}\n```\n\nReact Hooks를 사용하는 프로젝트라면 다음과 같이 모두 연결할 수 있습니다:\n\n```js\nexport function useUpload() {\n  const [uploadState, setUploadState] = useState<\n    \"idle\" | \"starting\" | \"uploading\" | \"finishing\" | \"done\" | \"error\"\n  >(\"idle\");\n  const [uploadProgress, setUploadProgress] = useState(0);\n  const [uploadError, setUploadError] = useState<Error | null>(null);\n\n  return {\n    uploadState,\n    uploadProgress,\n    uploadError,\n    upload: async (\n      file: File,\n      onSuccess: (uploadKey: string) => Promise<void>,\n    ) => {\n      setUploadState(\"starting\");\n\n      try {\n        // 백엔드 API에서 사전 서명된 URL 가져오기:\n        const { key, presigned_upload_url } = await getPresignedUrl(\n          file,\n        );\n        setUploadState(\"uploading\");\n        // XmlHttpRequest를 사용하여 실제 업로드:\n        await uploadFile(file, presigned_upload_url, (pct) => {\n          setUploadProgress(pct);\n        });\n        setUploadState(\"finishing\");\n        // 이 업로드된 파일을 유용하게 활용하기; 아마도 이 키를 다른 API 엔드포인트로 전달할 것입니다!\n        await onSuccess(key);\n        setUploadState(\"done\");\n      } catch (e) {\n        setUploadState(\"error\");\n        setUploadError(e);\n      }\n    },\n  };\n}\n```\n\n## 마지막으로: 새로 업로드된 파일 사용하기\n\n\n<div class=\"content-ad\"></div>\n\n업로드가 완료되면 업로드한 S3 키를 API로 전송하여 다른 곳에 저장하거나 원하는 대로 후속 처리할 수 있습니다.\n\n업로드 전용 S3 버킷 내의 경로인 업로드 키를 받는 또 다른 API 엔드포인트를 추가하세요. 그런 다음 파일을 다운로드하여 유효성을 검사하거나 다른 서비스에서 즉시 사용할 수 있도록 다른 버킷으로 복사할 수 있습니다.\n\n(저는 업로드 키에 인증된 사용자 ID를 넣는 것을 좋아합니다. 이렇게 하면 이 엔드포인트 내에서 현재 사용자로부터 업로드된 것인지 확인할 수 있습니다.)\n\n다음은 Python에서 버킷을 공개 서빙 버킷에 복사하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nupload_key = request.validated_data[\"upload_key\"]\next = upload_key.split(\".\")[-1]\nslug = slugify(request.validated_data[\"filename\"])\ndate = datetime.now().strftime(r\"%Y%m%d_%H%M%S\")\npublic_key = f\"media/{request.user.id}/{date}-{slug}.{ext}\"\n\ntry:\n  public_content_s3_client().copy(\n    CopySource={\n      \"Bucket\": \"yourproject-upload\",\n      \"Key\": upload_key,\n    },\n    Bucket=\"yourproject-public\",\n    Key=public_key,\n  )\nexcept Exception:\n  logging.exception(f\"Failed to copy file for user={request.user.id}\")\n```\n\n요렇게 해요. 누군가에겐 도움이 되길 바래요! 혹시 다시 필요하시다면 여기 스크립트 내용이 담긴 gist 링크도 드릴게요. 🥰\n\n의견이나 피드백이 있으시면 언제든지 알려주세요! @taylorhughes\n","ogImage":{"url":"/assets/img/2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers_0.png"},"coverImage":"/assets/img/2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers_0.png","tag":["Tech"],"readingTime":7},{"title":"NestJS의 비즈니스 로직 조직 이해하기","description":"","date":"2024-05-27 18:47","slug":"2024-05-27-UnderstandingNestJSsBusinessLogicOrganization","content":"\n\n\n![Understanding NestJS's Business Logic Organization](/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png)\n\n전통적인 MVC 아키텍처에서 왔다면 NestJS는 낯설게 느껴질 수 있습니다. 물론, view(사용자 인터페이스) 계층, model(데이터베이스) 계층, 및 controller(비즈니스 로직) 간의 관심사 분리 아이디어는 존재합니다. 그러나 NestJS에서는 파일과 비즈니스 로직을 구조화하기 위한 새로운 흐름을 소개합니다. 라우팅 요청에 대한 컨트롤러, 비즈니스 로직 처리를 위한 서비스, 데이터베이스 조작을 위한 리포지토리의 패턴을 사용합니다. NestJS에서 비즈니스 로직을 어떻게 구성할지 살펴보겠습니다.\n\n## 요청 처리 새로운 방식\n\nNestJS는 구성 기반의 백엔드 프레임워크입니다. JavaScript로 작성되었지만 TypeScript를 사용할 때 가장 빛을 발합니다. 기본 NodeJS와 Express의 Wild West 접근 방식과 Ruby on Rails의 엄격한 규칙 기반 접근 방식과는 다릅니다. NestJS는 애플리케이션 개발을 위한 최상의 관행을 형성하면서도 유연한 디자인을 가능하게 하는 패턴 또는 레시피를 제공합니다.\n\n\n<div class=\"content-ad\"></div>\n\nNestJS 프로젝트의 설정은 모듈의 조율에 중점을 두고 있습니다. 모든 로직은 기능을 제공하거나 사용하는 모듈에 래핑되어 있습니다. 다른 소프트웨어와 마찬가지로 진입점이 있으며 서로 의존하는 웹이 있습니다:\n\n![이미지](/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_1.png)\n\nNestJS는 사용자 요청을 처리하기 위해 서비스와 리포지토리를 모듈 간에 공유하면서 복잡해질 수 있습니다. 단순하게 시작하여 컨트롤러, 서비스 및 리포지토리를 포함하는 격리된 모듈부터 시작하는 것이 좋습니다. 데이터베이스 변경 요청이 NestJS 프로젝트를 통해 어떻게 라우팅되는지 살펴보겠습니다.\n\n## NestJS에서 컨트롤러는 무엇을 하는가?\n\n<div class=\"content-ad\"></div>\n\n모든 것은 컨트롤러에서 시작됩니다. 클래식 MVC 프로젝트에서는 컨트롤러가 프로젝트의 많은 부분을 책임집니다. 뷰는 서버에서 반환된 데이터를 반영합니다. 모델은 데이터 구조를 제공하고 레코드와 관련된 비즈니스 로직을 저장하며, 컨트롤러는 이들 간의 모든 것을 조율합니다.\n\nNestJS에서도 컨트롤러는 일부 비슷한 기능을 가지지만 책임은 훨씬 적습니다. 컨트롤러는 간단히 트래픽 디렉터로 기능하여 어디로 어떻게 전달해야 하는지 확인합니다. 요청 유효성 검사를 위한 파이프나 들어오는 데이터를 형성하고 유효성 검사하기 위한 DTO(데이터 전송 객체)와 같이 더 많은 기능을 추가할 수 있지만, 컨트롤러는 비즈니스 로직을 처리하지 않습니다.\n\nNestJS에서는 컨트롤러의 역할이 요청을 수락하고 일부 유효성 검사를 수행하여 요청과 데이터를 올바른 서비스로 라우트하는 것입니다. 이는 여전히 많은 책임을 요구하지만 다른 프레임워크보다는 적습니다.\n\n![이미지](/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_2.png)\n\n<div class=\"content-ad\"></div>\n\n## NestJS에서 서비스는 무엇을 하는가요?\n\n요청 및 선택적 데이터가 어디로 가는지 알게 되면 비즈니스 로직에 맞게 형태를 변형합니다. 이것이 우리의 서비스 파일이 필요한 이유입니다. NestJS의 서비스는 컨트롤러로부터의 요청에 기반하여 데이터를 생성, 형태를 변형 또는 업데이트하는 로직을 말합니다. 신발을 구매한 사람을 위한 새로운 주문을 생성하거나 사용자의 구식 지불 수단을 제거하는 등의 작업이 일어날 수 있습니다.\n\n무엇을 하든, 서비스에서는 애플리케이션 데이터에 대한 작업을 수행하여 새 상태를 지속할 수 있게 됩니다. 서비스가 데이터를 형태로 만드는 동안, 이 새 상태를 지속하기 위해 데이터베이스와 대화하는 책임은 없습니다. 데이터를 지속시키기 위해서는 저장소가 필요합니다.\n\n## NestJS에서 리포지토리는 무엇을 하는가요?\n\n<div class=\"content-ad\"></div>\n\n저장소는 데이터베이스로의 요청을 처리합니다. 사용자의 요청이 올바른 비즈니스 로직(컨트롤러에 의해)으로 라우팅되고 데이터에 필요한 작업(서비스에 의해)이 수행되면 업데이트된 응용 프로그램 상태를 영속화할 준비가 됩니다.\n\n저장소는 CRU(D) 작업으로 구성되어 있으며 API 클라이언트와 유사한 도구로 볼 수 있습니다. 저장소의 메서드는 데이터베이스에 특정 데이터 레코드를 읽거나 쓰기를 예상합니다. 그게 전부입니다. 이는 다른 접근 방식인 ORM과는 달라요, 여기서 데이터베이스 호출이 서비스에 직접 엮이지 않습니다. 추가 파일이 늘어나는 것은 더 많은 작업이 필요해 보일 수 있지만, 별도의 저장소 파일을 갖는 것은 서비스 또는 앱 사이에서 데이터베이스 작업을 공유하고, 코드를 확장하기 위해 코드를 모듈화하는 데 도움이 됩니다.\n\n## NestJS에 대한 마지막 생각\n\nNestJS는 강력한 백엔드 프레임워크로 API를 빌드하는 프로세스를 가속화합니다. Ruby on Rails 또는 Java 배경에서 오는 것을 배워야 할 내용이 많을 수 있습니다. 다행히 문서는 방대하고 이해하기 쉽습니다. 깨끗하고 일관된 코드를 작성하기 위해 문서를 여러 번 검토하는 것을 강력히 권장합니다.","ogImage":{"url":"/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png"},"coverImage":"/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png","tag":["Tech"],"readingTime":3}],"page":"60","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}