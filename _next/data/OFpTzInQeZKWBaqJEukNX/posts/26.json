{"pageProps":{"posts":[{"title":"가로 스크롤 테이블에서 테이블 헤더 고정하는 방법","description":"","date":"2024-06-22 03:45","slug":"2024-06-22-Fixingatableheaderonahorizontallyscrollingtable","content":"\n\n\n![image](/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_0.png)\n\nYou would think this is easy. But it really isn’t.\n\n# Chapter 0: The environment\n\nThis entire post is based on a React application, so while it’s not mandatory, it would help if you had at least basic knowledge of React and React Hooks.\n\n\n<div class=\"content-ad\"></div>\n\n# 장 1: 초기 문제\n\n저희가 최근 작업한 프로젝트에서 맞닥뜨린 매우 구체적인 문제가 있었습니다: 클라이언트가 대형 테이블을 원했습니다.\n\n대형이라고 무슨 뜻일까요? 제가 본 테이블 중에는 15개 이상의 열이 있는 것도 있고 화면보다 훨씬 더 넓은 것도 있었습니다. 운이 좋게도 이번에 다룬 테이블은 그중 하나는 아니었지만, 사용 가능한 공간보다는 더 넓었습니다.\n\n![이미지](/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_1.png)\n\n<div class=\"content-ad\"></div>\n\n이와 더불어, 표에 쉽게 스크롤할 수 있는 버튼이 필요했습니다.\n\n이를 달성하기 위해 표를 화면의 너비의 일정 비율(예: 화면 너비의 80%)로 고정한 `div`로 감싼 다음, 버튼 몇 개와 스크롤링 기능을 추가했습니다. 스크롤링 함수는 래퍼(wrapper)의 스크롤 위치를 변경하는 방식으로 작동합니다. 스크롤링 함수는 다음과 같이 보였습니다:\n\n<img src=\"/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_2.png\" />\n\n이를 통해 가로 스크롤이 가능하고 터치패드가 없는 경우에도 스크롤할 수 있는 버튼이 있는 멋진 표가 만들어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*6xTzUdpHHNCkKTkS5PWENQ.gif)\n\nThis was good, and working as expected.\n\n# Chapter 2: 새로운 요구 사항이 발생하다\n\n이 상태의 표가 승인되고 운영 환경에 배포되었습니다. 사용자 중 일부가 헤더를 상단에 고정하여 스크롤할 때 헤더를 유지하도록 요청하기 시작했습니다. 이렇게 하면 각 값을 확인하기 위해 열 이름을 왔다갔다 스크롤할 필요 없이 어떤 값인지 쉽게 인식할 수 있을 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n우리의 첫 번째 충동은 대부분의 사람들이 할 것이라고 생각하는 것이었습니다: 테이블의 thead 요소에 position: sticky를 추가했습니다.\n\n![이미지](/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_3.png)\n\n이게 정말 이렇게 간단할 수 있나 싶으신가요? 그것은 그렇습니다. 이렇게 할 때 어떤 일이 벌어지는지 확인해보세요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*KBjRnzusCS-VdO3C-doD9A.gif)\n\n<div class=\"content-ad\"></div>\n\n테이블 요소들은 효과적으로 position: sticky 속성을 갖고 있지만 조금 스크롤하면 화면을 벗어냅니다.\n\nCSS 사양에 따르면:\n\n여기서 문제는 다음과 같습니다:\n\n- .layout__content이 스크롤됩니다.\n- .table__wrapper는 스크롤되지 않습니다.\n- .table thead는 .table_wrapper에 대해 sticky 속성을 갖습니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 원했던 것은 .table thead가 .layout__content에 대해 sticky하게 되는 것이었습니다. 이것은 불가능한데, .table__wrapper에는 오직 overflow-x만 지정되어 있어도 여전히 overflow 속성이 있기 때문에 .table thead가 그것에 붙어버립니다.\n\n# Chapter 3: 첫 번째 접근 방식\n\n그래서 명세를 고려하여, .layout__content에서 overflow-x를 제거해보고 결과를 확인해봅시다.\n\n<img src=\"/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n그럼 무엇이 일어날까요?\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*BN3b0lj6txdVX7w0LsJvgQ.gif)\n\n그래서 작동한 것 같군요... 아니죠?\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*iQPnhfp3bjC5QGndmaE1Nw.gif)\n\n<div class=\"content-ad\"></div>\n\n앗, 이런! 스크롤 버튼이 작동을 멈췄네요. 게다가 이제 표를 스크롤하면 제목을 포함한 전체 페이지가 스크롤되는 문제가 발생했어요. 그런 건 예상치 못한 일이에요.\n\n하지만, 어쨌든! 우리의 헤더는 이제 고정되어 있어요!\n\n# Chapter 4: Don’t tell me what to do!\n\n그래서 우리는 문제에 대한 해결책을 찾아 (그리고 머리를 긁으면서) 꽤 오랜 시간을 보냈는데요: 자바스크립트와 CSS를 사용하자는 해결책을 찾았답니다!\n\n<div class=\"content-ad\"></div>\n\n기본 아이디어는 다음과 같아요:\n\n- 표의 헤더가 어디에 있는지 확인해 봅시다.\n- 사용자가 어느 정도 스크롤했는지 확인해 봅시다. a. 사용자가 헤더 시작 부분 아래로 스크롤했다면, thead 요소를 위로 유지하도록 번역합시다. b. 그렇지 않다면, 표 헤더에서 translate 속성을 제거합시다.\n\n이 앱에서 React를 사용했기 때문에 실제 DOM 요소를 추적하기 위해 일부 ref를 활용했어요.\n\n아래처럼 코드를 작성해보았는데요 (재사용성을 위해 훅으로 작성했습니다):\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_5.png\" />\n\n아래 코드를 분해해 봅시다:\n\n우선, 테이블 래퍼(wrapper)용과 테이블 헤더용 두 개의 ref를 선언합니다.\n\n테이블 자체 대신 테이블 래퍼에 대한 ref를 선언하는 이유에 대해 궁금해 할 수 있습니다. 이는 코드 아래쪽에서 사용자가 얼마나 스크롤했는지 계산하기 위해 위치 지정(positioning)을 사용하는데, offsetTop은 부모에 상대적이므로 테이블은 항상 부모에 대해(offsetTop) 0인 값을 갖습니다. 래퍼는 스크롤 요소의 직계 자식이어야 합니다(우리의 경우 layout__content 요소).\n\n\n<div class=\"content-ad\"></div>\n\n그럼, 스크롤 요소에 이벤트 리스너를 추가하는 역할을 맡은 useEffect 훅을 작성합니다. 스크롤할 때 적절히 반응할 수 있도록 설정합니다.\n\n그렇다면 '적절히 반응한다'는 무엇을 의미할까요? 헤더의 위치를 스크롤 요소와 비교해야 하지만 이동할 것이기 때문에 실제로 테이블의 위치를 확인해야 합니다. 여기서 테이블 래퍼를 사용하는 것이죠. 해당 요소는 콘텐츠 요소와 비교하여 이동하지 않기 때문입니다. 그 후에 부모 요소가 헤더 위치를 지나쳤는지 확인하여, 그렇다면 해당 스크롤 위치 차이 (스크롤 위치 - 헤더 위치)로 해당 요소를 변환합니다. 스크롤 위치가 헤더 위치보다 위에 있다면 해당 translate 속성을 제거합니다.\n\n또한, 이벤트 리스너를 제거하는 것을 기억하는 것도 중요합니다. 그렇지 않으면 응용 프로그램의 다른 섹션으로 이동한 후 더 이상 존재하지 않는 요소를 참조할 수 있어 응용 프로그램이 크래시할 수 있습니다. 우리의 useEffect 안에 그 작업을 수행하는 함수를 반환하여 이 문제를 해결합니다.\n\n그래서, 작동했나요?\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*51AviR697AWxTnCS6QjquQ.gif)\n\n네! 100% 완벽하지는 않아요, 헤더가 조금씩 점프할 수 있지만, 그건 이 블로그 게시물의 범위를 벗어나는 문제에요.\n\n하지만 개발 도구에서 등장하는 것이 있어요:\n\n![image](/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_6.png)\n\n<div class=\"content-ad\"></div>\n\n해당 링크를 따라가면 Firefox가 우리가 하는 것에 대해 position: sticky를 사용하는 것을 권장하는 것을 볼 수 있어요.\n\n음, Firefox야, 우리가 원하는대로 작동한다면 position: sticky를 사용할 거에요.\n\n# 최종 생각\n\n이 문제는 작업하기 정말 재미있었지만, CSS 명세가 이를 고려해주면 좋을 것 같아요. \"sticky-anchor\"라는 속성이 있고 값으로 \"ancestor\" 또는 \"screen\"을 사용할 수 있다면 좋을 것 같아요. ancestor는 현재 동작을 유지하고 기본값이 되며, screen은 전체 화면만을 고려할 것 같아요. 그렇다면 우리는 모든 코드를 건너뛰고 다음과 같은 CSS만 가질 수 있을 거에요:\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 테이블 태그 변경한 것입니다.\n\n\n![이미지](/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_7.png)\n\n또한, 이 방법은 가로 스크롤 헤더에서 일부 득독이 발생할 수 있으므로, 100% 완벽한 해결책이 필요한 경우 이벤트 루프 및 애니메이션 루프를 찾아보는 것이 좋습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_0.png"},"coverImage":"/assets/img/2024-06-22-Fixingatableheaderonahorizontallyscrollingtable_0.png","tag":["Tech"],"readingTime":6},{"title":"필수 CSS 인터뷰 질문 15선","description":"","date":"2024-06-22 03:44","slug":"2024-06-22-15EssentialCSSInterviewQuestions","content":"\n\n<img src=\"/assets/img/2024-06-22-15EssentialCSSInterviewQuestions_0.png\" />\n\n저희의 핵심 웹 개발 인터뷰 질문 시리즈에 다시 오신 것을 환영합니다! 지난 번에는 HTML에 대해 다뤘는데요, 놓치셨다면 링크를 확인해보세요:\n\n이제 CSS로 들어가 봅시다 🎨 인터뷰를 위한 준비를 하거나 기술을 갱신하거나 CSS를 얼마나 잘 이해하는지 궁금하다면 이 블로그가 딱입니다.\n\n이 블로그에서는 모든 웹 개발자가 알아야 할 주요 주제와 개념을 다뤄볼 것입니다. 이러한 질문은 지식을 테스트하고 CSS를 명확하게 설명할 수 있는지 확인하는 데 훌륭합니다.\n\n<div class=\"content-ad\"></div>\n\n시작해봅시다! CSS에 대해 얼마나 알고 계신지 확인해보세요! 🚀\n\n## 1. \"id\"와 \"class\"의 차이점\n\n- Id: 고유한 요소를 식별하는 데 사용됩니다. 한 번 이상 사용할 수 없습니다. 재사용할 수 없습니다.\n- Class: 페이지 내에서 여러 요소를 선택하는 데 사용됩니다.\n\n예시: 웹사이트에 로고가 있다면 id를 사용할 것이지만, 동일한 스타일을 공유할 많은 글이 있다면 class를 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 2. CSS에서 \"id\"와 \"class\"를 선택하는 방법\n\n- Id: #으로 선택됩니다.\n- Class: .으로 선택됩니다.\n\n## 3. 텍스트의 글꼴을 변경할 수 있는 속성은 무엇인가요?\n\nfont-family\n\n<div class=\"content-ad\"></div>\n\n## 4. 웹사이트의 배경을 변경하는 방법은 무엇인가요?\n\n배경 또는 배경 이미지\n\n## 5. 메뉴를 고정하는 데 사용해야 하는 속성은 무엇인가요?\n\nposition: fixed;\n\n<div class=\"content-ad\"></div>\n\n예: 웹 사이트에서 스크롤하고 나서 내비게이션바에 \"position: fixed;\"를 적용하면 스크롤 양에 관계없이 페이지 상단에 고정됩니다.\n\n## 6. 그림자를 추가할 수 있는 속성은 무엇인가요?\n\ntext-shadow 또는 box-shadow\n\n## 7. inline, inline-block 및 block 간에는 어떤 차이가 있나요?\n\n<div class=\"content-ad\"></div>\n\n- 인라인: 이 요소들은 새로운 줄 바꿈을 시작하지 않고 텍스트 라인 안에서 부드럽게 통합되며 필요한 너비만 차지합니다. 너비와 높이를 포함한 요소의 차원은 시각적으로 나타나지 않습니다.\n- Inline-block: 인라인 요소와 유사하지만, 이 구성 요소들은 새로운 줄에서 시작하지 않고 너비와 높이 값을 명시적으로 설정할 수 있어 외형에 대한 더 많은 제어를 제공합니다.\n- 블록: 대조적으로, 블록 요소는 새로운 줄에서 시작하고 전체 사용 가능한 너비를 채우도록 확장됩니다. 디자인 요구 사항에 맞게 너비와 높이 값을 조정하는 유연성을 제공합니다.\n\n![이미지](/assets/img/2024-06-22-15EssentialCSSInterviewQuestions_1.png)\n\n## 8. 웹 사이트를 반응형으로 만들 수 있는 방법은 무엇인가요?\n\n백분율 단위로 측정하고 미디어 쿼리를 사용함으로써 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n## 9. 이미지가 상자를 벗어나는 경우 제한하고 싶다면 어떻게 해야 하나요?\n\noverflow: hidden\n\n## 10. \"visibility: hidden\"과 \"display: none\"의 차이점을 설명해주세요.\n\n- visibility: hidden: 요소를 숨기지만 웹 문서에서 공간을 차지하고 문서 레이아웃에 영향을 줍니다.\n- display: none: 요소를 숨기지만 어떤 공간도 차지하지 않고 문서 레이아웃에 영향을 주지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-15EssentialCSSInterviewQuestions_2.png\" />\n\n## 11. Flexbox와 CSS 그리드의 차이:\n\n내용을 구조화하는 방식이 다릅니다:\n\n- Flexbox는 요소를 배치하는 그리드를 제공합니다.\n- CSS 그리드는 좀 더 콜라주와 같은 느낌입니다.\n\n<div class=\"content-ad\"></div>\n\n## 12. CSS 전처리기와 프레임워크의 차이:\n\n- 전처리기: 코드 작성 속도를 높이기 위한 추가 기능을 제공합니다 (SASS).\n- 프레임워크: 사전 정의된 디자인과 기능을 위해 태그와 클래스를 간단히 적용할 수 있는 미리 만들어진 요소를 제공합니다 (부트스트랩).\n\n## 13. 레이어 관리 방법:\n\nz-index 속성을 사용하여 레이어를 관리합니다. 이를 통해 한 레이어를 다른 레이어 앞이나 뒤로 나타낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 14. Margin과 Padding의 차이:\n\n- Margin은 외부 간격입니다.\n- Padding은 내부 간격입니다.\n\n![CSS Interview Questions](/assets/img/2024-06-22-15EssentialCSSInterviewQuestions_3.png)\n\n## 15. RGBA에서 A는 무엇을 의미합니까?\n\n<div class=\"content-ad\"></div>\n\nRGBA 색 모델에서 \"A\"는 \"알파\"를 나타냅니다. 이 구성요소는 색상의 투명도 또는 불투명도 수준을 나타냅니다. 값이 0이면 완전히 투명하고, 값이 1이면 완전히 불투명합니다.\n\n# 마무리\n\n![image](/assets/img/2024-06-22-15EssentialCSSInterviewQuestions_4.png)\n\n읽어 주셔서 감사합니다! 다른 유용한 질문이 있으면 댓글에 공유해 주세요. 함께 공부하고 면접을 위해 준비할 수 있도록 도와주세요 🤗\n\n<div class=\"content-ad\"></div>\n\n저희의 다가오는 블로그를 기대해 주세요. JavaScript와 React에 관한 인터뷰 질문에 대해 자세히 다룰 예정이에요.\n\n더 많은 통찰과 업계의 모범 사례를 위해 디스코드 커뮤니티에 가입하고 인스타그램을 팔로우해 주세요. 💬👥📢\n\nDevOps, 웹 개발 및 기술 관련 주제에 대한 시각적 자습서와 심층적인 탐구를 원하신다면 ✨ YouTube 채널 ✨을 구독해 주세요.\n\n즐거운 코딩하세요!  👩🏻‍💻👩🏼‍💻","ogImage":{"url":"/assets/img/2024-06-22-15EssentialCSSInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-06-22-15EssentialCSSInterviewQuestions_0.png","tag":["Tech"],"readingTime":4},{"title":"미디어 쿼리에서 CSS 색상 변수를 사용하는 방법","description":"","date":"2024-06-22 03:43","slug":"2024-06-22-EngineeringCSSColorVariablesinMediaQueries","content":"\n\n공학 (CSS)\n\n![EngineeringCSS](/assets/img/2024-06-22-EngineeringCSSColorVariablesinMediaQueries_0.png)\n\n# 미디어 쿼리에서 CSS 변수 사용하기\n\n- 미디어 쿼리를 사용하면 장치의 특성에 따라 너비, 높이 등을 기준으로 다른 스타일을 적용할 수 있습니다. CSS 변수와 미디어 쿼리를 결합하여 변수의 값들을 동적으로 변경하여 반응형 디자인을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 예시\n\n![EngineeringCSSColorVariablesinMediaQueries_1](/assets/img/2024-06-22-EngineeringCSSColorVariablesinMediaQueries_1.png)\n\n![media queries](https://miro.medium.com/v2/resize:fit:1200/1*VUoWXkS1fU3pKCBe7jX7Tg.gif)\n\n- 미디어 쿼리에 초점을 맞추면,\n\n<div class=\"content-ad\"></div>\n\n```js\n@media (min-width: 600px) {\n            :root {\n                --alam-bg-color: #06c0ee;\n            }\n        }\n\n@media (min-width: 900px) {\n            :root {\n                --alam-bg-color: #A3FF36\n            }\n}\n```\n\n- 뷰포트 너비에 따라 --alam-bg-color 값이 변경되는 미디어 쿼리를 두 개 정의했습니다. 600px와 900px입니다.\n\n600px 이상을 위한 미디어 쿼리:\n\n- 뷰포트 너비가 600px 이상일 때, --alam-bg-color 변수가 #06c0ee (라이트 블루)로 재정의됩니다.\n- 이는 body의 배경 색상이 라이트 블루로 변경됨을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n900px 이상의 미디어 쿼리:\n\n- 뷰포트 너비가 적어도 900px 이상일 때, --alam-bg-color 변수가 다시 #A3FF36 (라이트 그린) 으로 재정의됩니다.\n- 본문의 배경색이 라이트 그린으로 변경됩니다.\n\n600px 미만인 경우?\n\n- 너비가 600px 미만일 경우, 배경색은 기본 alam-yellow로 설정됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image 1](/assets/img/2024-06-22-EngineeringCSSColorVariablesinMediaQueries_2.png)\n\n![image 2](/assets/img/2024-06-22-EngineeringCSSColorVariablesinMediaQueries_3.png)\n","ogImage":{"url":"/assets/img/2024-06-22-EngineeringCSSColorVariablesinMediaQueries_0.png"},"coverImage":"/assets/img/2024-06-22-EngineeringCSSColorVariablesinMediaQueries_0.png","tag":["Tech"],"readingTime":2},{"title":"초보자를 위한 Nodejs, ExpressJs 및 Ejs를 사용한 블로그 만들기 HTML  CSS 포함 가이드","description":"","date":"2024-06-22 03:41","slug":"2024-06-22-HowtobuildabloginJsNodeExpressJsEjsandHTMLCSSAsabeginner","content":"\n이 쉬운 가이드에서는 Express.js를 사용하여 간단하지만 강력한 블로그 애플리케이션을 구축하는 과정을 안내하겠습니다. Express.js는 Node.js를 위한 빠르고 유연하며 가벼운 웹 프레임워크입니다. 이 자습서를 마치면 자신만의 맞춤형 블로그 플랫폼을 만들 수 있는 모든 지식을 습득할 것입니다. 블로그 게시물을 쉽게 추가, 편집 및 삭제할 수 있을 것입니다.\n\n이 자습서를 통해 다음과 같은 주요 주제를 다룰 것입니다:\n\n- 환경 설정: 우리는 Node.js를 설치하고 새 Express.js 프로젝트를 초기화함으로써 시작할 것입니다. 프로젝트 디렉토리를 구성하고 필요한 종속성을 설치하는 방법을 배울 것입니다.\n- 우리가 구현한 기능은 다음과 같습니다: 사용자는 블로그를 작성하고 게시할 수 있으며, 모든 블로그 목록을 볼 수 있으며, 긴 글을 위한 개별 블로그 세부 정보에 액세스할 수 있으며, 더 이상 필요하지 않은 블로그를 삭제하고, 기존 블로그 게시물을 편집할 수 있습니다.\n- 사용자 인터페이스 개선: 잘 디자인된 사용자 인터페이스는 사용자 경험을 크게 향상시킬 수 있습니다. HTML, CSS 및 EJS(Embedded JavaScript) 템플릿을 사용하여 블로그 애플리케이션용 깔끔하고 직관적인 인터페이스를 만들 것입니다.\n\n# 환경 설정:\n\n<div class=\"content-ad\"></div>\n\n먼저 공식 웹 사이트에서 Node.js를 다운로드한 다음 프로젝트 폴더를 만듭니다. 다음으로 Visual Studio Code에서 해당 폴더를 열고 npm을 초기화합니다. 그런 다음 다음 명령을 실행하여 필요한 종속성을 설치합니다:\n\nnpm 초기화:\n\n```js\nnpm init\n```\n\n공식 Express.js 웹 사이트에서 Express.js를 다운로드합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm i express\n```\n\n우선 index.js 파일을 생성하고 Express 서버를 설정하세요. Express를 불러오고, 이 파일 내에서 라우트를 정의하세요. 그런 다음, 주 라우트에 대한 라우트 핸들러를 작성하세요.\n\n```js\nimport express from \"express\";\nconst app = express();\nconst port = 3000;\n\n// 주 라우트 설정\napp.get(\"/\", (req, res) => {\n  res.send(\"Hello World\");\n});\n\n// 서버 시작\napp.listen(port, () => {\n  console.log(`포트 ${port}에서 Listening 중`);\n});\n```\n\n![이미지](/assets/img/2024-06-22-HowtobuildabloginJsNodeExpressJsEjsandHTMLCSSAsabeginner_0.png)\n\n<div class=\"content-ad\"></div>\n\n그 다음으로 템플릿으로 EJS를 다운로드합니다. EJS는 Embedded JavaScript의 준말로, Node.js 및 웹 개발 모두에 적합한 템플릿 엔진입니다. HTML 템플릿에 JavaScript 코드를 직접 통합하여 동적 HTML 콘텐츠를 생성할 수 있습니다.\n\n# 다음은 우리가 구현한 기능 및 사용자 인터페이스 개선사항이 있습니다:\n\n다음은 우리 애플리케이션에서 제공하는 중요한 기능들입니다:\n\n- 블로그 게시물 생성: 사용자는 쉽고 유용한 블로그 게시물을 선호에 맞게 생성할 수 있습니다.\n- 블로그 게시물 목록 보기: 사용자는 편리한 목록보기를 통해 모든 블로그 게시물을 효율적으로 검색할 수 있습니다.\n- 개별 블로그 게시물 보기: 사용자들은 특정 블로그 게시물에 깊이 파고들어 자세히 읽고 분석할 수 있습니다.\n- 편집 기능: 사용자들은 블로그 게시물을 편집할 수 있는 능력이 있어 콘텐츠가 최신 및 관련성을 유지할 수 있습니다.\n- 삭제 기능: 사용자들은 필요에 따라 블로그 게시물을 쉽게 삭제할 수 있어 콘텐츠를 관리하고 깔끔한 경험을 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로, 메인 페이지용 index.ejs 파일을 생성하고 그 안에 HTML 코드를 작성할 것입니다. 또한 헤더, 푸터, styles.css와 같은 정적 파일을 위해 public 폴더를 생성할 것입니다. 이 폴더 안에 header.ejs, footer.ejs, 그리고 styles.css 파일을 만들 것입니다.\n\n```js\n//index.ejs\n  <main>\n    <%- include('public/partials/header.ejs') %>\n\n    <h1 class=\"title\">블로그 앱에 오신 것을 환영합니다</h1>\n    <div class=\"form-container\">\n      <p class=\"form-text\">블로그를 편집하세요</p>\n      <p class=\"form-text\">블로그를 생성하기 위한 양식을 작성하세요</p>\n      <form\n        action=\"/home\"\n        method=\"post\"\n      >\n        <label for=\"bTitle\">블로그 제목</label>\n        <input\n          type=\"text\"\n          id=\"bTitle\"\n          name=\"blogTitle\"\n          placeholder=\"여기에 제목을 입력하세요...\"\n          required\n        />\n\n        <label for=\"bDes\">블로그 설명</label>\n        <textarea\n          type=\"text\"\n          id=\"bDes\"\n          name=\"blogDes\"\n          placeholder=\"여기에 블로그 내용을 입력하세요...\"\n          rows=\"6\"\n          required\n        >\n        </textarea>\n        <input\n          type=\"submit\"\n          value=\"게시\"\n        />\n      </form>\n    </div>\n    <%- include('public/partials/footer.ejs') %>\n  </main>\n```\n\n```js\n//header.ejs\n<header class=\"site-header\">\n  <div class=\"site-identity\">\n    <h1>\n      <a href=\"#\">블로그 앱</a>\n    </h1>\n  </div>\n  <nav class=\"site-navigation\">\n    <ul class=\"nav\">\n      <li>\n        <a href=\"/\">블로그 만들기</a>\n      </li>\n      <li>\n        <a href=\"/home\">모든 블로그 보기</a>\n      </li>\n    </ul>\n  </nav>\n</header>\n```\n\n```js\n//footer.ejs\n<footer class=\"site-footer\">\n    <div class=\"site-identity\">\n      <p><a href=\"#\">&copy;\n        <%= new Date().getFullYear() %></a> Made With ❤️ | All Right Reserved</p>\n    </div>\n  </footer>\n```\n\n<div class=\"content-ad\"></div>\n\n위의 내용은 Express.js와 EJS 템플릿을 사용하여 블로그 애플리케이션을 위한 간단한 웹 페이지 구조를 나타냅니다.\n\nindex.ejs에는 새 블로그 포스트를 작성하는 양식이 포함되어 있습니다.\n\nheader.ejs에는 내비게이션 링크가 포함된 헤더 섹션이 있습니다.\n\nfooter.ejs에는 저작권 정보가 포함된 푸터 섹션이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n포함 함수는 index.ejs 내에 header.ejs 및 footer.ejs 내용을 포함하여 페이지 간 일관성을 유지하는 데 사용됩니다.\n\n다음으로, EJS 템플릿 렌더링에 필요한 경로를 정의할 것입니다. Node.js dirname을 사용하여 디렉토리에 액세스할 것입니다. 우리 애플리케이션에 필요한 모든 경로를 설정하는 방법을 알려드릴게요.\n\n```js\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nconst indexPath = join(__dirname, \"index.ejs\");\nconst homePath = join(__dirname, \"views/home.ejs\");\nconst blogDetailsPath = join(__dirname, \"views/blogDetails.ejs\");\n\n// index 페이지 렌더링\napp.get(\"/\", (req, res) => {\n  res.render(indexPath);\n});\n```\n\n이 코드는 다양한 EJS 템플릿을 위한 파일 경로를 정의하고 루트(\"/\") 엔드포인트로 GET 요청이 발생할 때 index.ejs 템플릿을 렌더링하기 위한 라우트를 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로, Body Parser를 다운로드하세요. 이는 HTTP 요청 본문에서 JSON, 텍스트, URL 인코딩 및 Raw 데이터 세트를 구문 분석하기 위한 네 가지 Express 미들웨어를 제공합니다. 이러한 미들웨어 루틴은 대상 컨트롤러에 도달하기 전에 들어오는 요청을 처리합니다.\n\n```js\nnpm i body-parser\n```\n\n다음으로, index.js 파일에 새 블로그를 만드는 POST 요청 코드를 작성해 보세요. 그리고 views라는 새 폴더를 만들어주세요. 이 폴더 안에 blogList.ejs라는 파일을 만들어서 만든 블로그 목록을 표시해보세요. 사용자 입력 값을 캡처하고 \"bloglist\" 페이지에 렌더링하는 로직을 구현하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 블로그 목록 초기화\nlet blogList = [];\n// 포스트 요청\napp.post(\"/home\", (req, res) => {\n  const blogTitle = req.body.blogTitle;\n  const blogDescription = req.body.blogDes;\n  blogList.push({\n    id: generateID(),\n    title: blogTitle,\n    description: blogDescription,\n  });\n  res.render(homePath, {\n    blogList: blogList,\n  });\n});\n// 랜덤 ID를 생성하는 함수\nfunction generateID() {\n  return Math.floor(Math.random() * 10000);\n}\n```\n\n이 코드는 \"/home\"로의 POST 요청을 관리하여 요청 본문에서 블로그 제목과 설명을 추출하고, 무작위로 생성된 ID와 함께 blogList 배열에 추가한 후, 업데이트된 blogList 데이터로 \"homePath\" 템플릿을 렌더링합니다. 또한 각 블로그 게시물에 대한 랜덤 ID를 생성하기 위한 generateID() 함수를 포함하고 있습니다.\n\n```js\n<main>\n    <%- include('../public/partials/header.ejs') %>\n        <% if (blogList.length < 1) { %>\n            <h1 class=\"no-blog-title\">\n                아직 블로그가 없습니다. 새로운 블로그를 만들려면 <br />홈 페이지를 방문하세요.\n            </h1>\n            <% } else { %>\n                <h1 class=\"title\">당신의 블로그 목록</h1>\n            <% } %>\n\n            <div class=\"overflow-div\">\n                <div class=\"home-container\">\n                    <% for (let index=0; index < blogList.length; index++) { %>\n                        <div class=\"blog-card\">\n                            <span class=\"blog-number\">\n                                <%= index + 1 %>\n                            </span>\n                            <h4>\n                                <%= blogList[index].title %>\n                            </h4>\n                            <p>\n                                <%= blogList[index].description?.slice(0, 300) %>\n                                <% if (blogList[index].description?.length > 299) { %> ...\n                                    <a class=\"view-btn\" href=\"/blogDetails/<%= blogList[index].id %>\">\n                                        View Blog</a>\n                                <% } %>\n                            </p>\n                            <div class=\"btn-wrapper\">\n                                <form action=\"/delete/<%= blogList[index].id %>\" method=\"post\">\n                                    <button class=\"delete-btn\">Delete</button>\n                                </form>\n                                <a class=\"edit-btn\" href=\"/edit/<%= blogList[index].id %>\">edit</a>\n                            </div>\n                        </div>\n                    <% } %>\n                </div>\n            </div>\n\n        <%- include('../public/partials/footer.ejs') %>\n</main>\n```\n\n위 코드는 EJS 템플릿을 사용하여 블로그 애플리케이션의 프론트 엔드 구조를 나타냅니다. BlogList 페이지 (blogList.ejs), 헤더 (header.ejs), 푸터 (footer.ejs) 파일이 포함되어 있습니다. 이 페이지는 JavaScript의 반복 메커니즘을 활용하여 각 블로그 항목을 반복하고 표시합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경한 표입니다.\n\n![How to build a login in Js, Node, ExpressJs, Ejs and HTML/CSS As a beginner](/assets/img/2024-06-22-HowtobuildabloginJsNodeExpressJsEjsandHTMLCSSAsabeginner_2.png)\n\n그 다음으로, 사용자가 각 블로그 게시물의 전체 내용을 볼 수 있는 새로운 블로그 상세 파일을 생성할 것입니다. Express 라우팅을 사용하여 \"View Blog\" 링크를 클릭하여 각 특정 블로그 게시물을 볼 수 있도록 동적 경로를 구현할 것입니다. viewBlogDetails.ejs 파일을 생성하고 필요한 로직을 구현할 것입니다.\n\n```js\n// 블로그 상세 페이지 렌더링\napp.get(\"/blogDetails/:id\", (req, res) => {\n  const blogId = req.params.id;\n  const blogDetails = blogList.find((blog) => blog.id === parseInt(blogId));\n  res.render(blogDetailsPath, {\n    blogDetails: blogDetails,\n  });\n});\n```\n\n\n<%- include('../public/partials/header.ejs') %>\n<div class=\"container\">\n  <div class=\"viewBlog-header\">\n    <h1 class=\"title text-left\"><%= blogDetails?.title %></h1>\n\n    <a href=\"/edit/<%=blogDetails.id  %>\" class=\"edit-btn\">Edit</a>\n  </div>\n  <div class=\"overflow-div\">\n    <p><%= blogDetails?.description %></p>\n  </div>\n</div>\n\n<%- include('../public/partials/footer.ejs') %>\n\n\n<div class=\"content-ad\"></div>\n\n위의 코드는 지정된 블로그 ID를 기반으로 블로그 세부 페이지를 렌더링하는 라우트를 설정합니다. 요청 매개변수에서 ID를 추출하고 blogList 배열에서 해당 블로그 세부 정보를 찾습니다. 그런 다음 검색된 세부 정보를 사용하여 blogDetails.ejs 템플릿을 렌더링합니다.\n\n![이미지](/assets/img/2024-06-22-HowtobuildabloginJsNodeExpressJsEjsandHTMLCSSAsabeginner_3.png)\n\n다음으로, 블로그 게시물을 편집하는 기능을 만들어보겠습니다. 이를 통해 사용자가 블로그 게시물을 편집할 수 있습니다.\n\n```js\n// 블로그 업데이트\napp.post(\"/edit/:id\", (req, res) => {\n  const blogId = req.params.id;\n  const editBlog = blogList.findIndex((blog) => blog.id === parseInt(blogId));\n  if (editBlog === -1) {\n    res.send(\"<h1> 뭔가 잘못되었습니다 </h1>\");\n  }\n  const updatedTitle = req.body.blogTitle;\n  const updatedDescription = req.body.blogDes;\n\n  const blogTitle = (blogList[editBlog].title = updatedTitle);\n  const blogDescription = (blogList[editBlog].description = updatedDescription);\n  [...blogList, { blogTitle: blogTitle, blogDescription: blogDescription }];\n\n  res.render(homePath, {\n    isEdit: true,\n    blogList: blogList,\n  });\n});\n```\n\n<div class=\"content-ad\"></div>\n\n이 Express.js 코드는 블로그 글을 편집하는 작업을 수행합니다. /edit/123(여기서 123은 글 ID입니다)와 같은 URL로의 POST 요청을 수신 대기합니다. ID를 추출하고 해당 글을 찾아 업데이트를 검색합니다. 데이터 문제를 피하기 위해 업데이트가 적용된 새로운 객체를 생성하고(원래 ID 포함) 기존 글을 새 글로 대체합니다. 선택적으로 업데이트된 목록이 있는 페이지를 렌더링할 수 있습니다.\n\n이제 블로그 삭제 기능을 구현해 봅시다.\n\n```js\napp.post(\"/delete/:id\", (req, res) => {\n  const blogId = req.params.id;\n  blogList = blogList.filter((blog) => blog.id !== parseInt(blogId));\n  res.send('<script>alert(\"Blog deleted successfully\"); window.location=\"/home\";</script>');\n  res.redirect(\"/home\");\n});\n```\n\n이 코드는 블로그 글을 삭제하는 라우트를 정의합니다. 요청 URL에서 글 ID를 추출하고 메모리에 있는 블로그 목록을 필터링하여 해당 글을 제거합니다. 응답에는 알림 메시지를 보내거나 사용자를 홈페이지로 두 번 리디렉션하는 기법들이 섞여 있습니다. 이 방식은 제한사항이 있습니다. 서버 재시작 시 데이터가 손실되고 응답 방법이 충돌할 수 있습니다. 더 견고한 솔루션을 찾으려면 데이터베이스 사용 및 프레젠테이션 로직을 서버 측 코드에서 분리하는 것이 권장됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 마무리\n\n이 가이드를 통해 Node.js, Express.js, EJS, HTML, 그리고 CSS를 사용하여 간단한 블로그 애플리케이션을 구축하는 과정을 안내해 드렸습니다. 환경을 설정하는 방법, 라우트를 생성하는 방법, 사용자 입력을 처리하는 방법, EJS 템플릿을 사용하여 동적 콘텐츠를 렌더링하는 방법, 블로그 글 생성, 조회, 편집, 삭제와 같은 기본 기능을 구현하는 방법을 배우셨습니다. 이는 기능적인 출발점이지만, 중요한 점은 배열과 같은 인메모리 데이터 저장소를 사용하면 서버 재시작 시 데이터 손실이 발생한다는 것입니다. 더 견고한 솔루션을 위해 영구 저장을 위해 데이터베이스를 사용하고 표현 로직을 서버측 코드와 분리하는 것이 중요합니다. 이렇게 하면 블로그 애플리케이션이 더 신뢰할 수 있고 확장 가능해집니다.\n\n건배: 이 프로젝트의 코드는 여기에서 찾을 수 있습니다: Github-Blog-App\n","ogImage":{"url":"/assets/img/2024-06-22-HowtobuildabloginJsNodeExpressJsEjsandHTMLCSSAsabeginner_0.png"},"coverImage":"/assets/img/2024-06-22-HowtobuildabloginJsNodeExpressJsEjsandHTMLCSSAsabeginner_0.png","tag":["Tech"],"readingTime":11},{"title":"CSS position fixed가 문제인 3가지 이유","description":"","date":"2024-06-22 03:40","slug":"2024-06-22-CSSpositionfixedisterriblehereswhy","content":"\n\n## 자바스크립트 UI - 개발 블로그 #4\n\n![이미지](/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png)\n\n## 소개\n\nHTML과 CSS는 근본적인 문제를 해결하기보다 예외 사항을 도입하는 경향이 있습니다. 특히 position 속성과 특히 position: fixed는 그 증거입니다. 이런 언어들이 계속해서 개념, 규칙 및 규례를 만들어 내지만 더 많은 이상한 행동과 일관성이 내가 셀 수 있는 것보다 더 많이 있어서 이해하기 어렵습니다.\n\n<div class=\"content-ad\"></div>\n\n그게 무슨 뜻이지?\n\n## 규칙\n\n당신이 뷰 트리의 가장 기본적인 규칙을 직관적으로 이해하려면 로켓 과학자가 되어있을 필요는 없어요:\n\n- 우리 코드의 트리는 뷰 트리와 똑같이 보여야 해요 (한숨)\n- 각 뷰는 유일하며 트리에 한 번만 나타날 수 있어요\n- 각 뷰는 정확히 하나의 부모를 가지고 있어요. 루트는 부모가 없어요\n- 뷰는 0개 이상의 자식을 가질 수 있어요\n- 나중에 정의된 뷰가 일찍 정의된 뷰 위에 나타나요\n\n<div class=\"content-ad\"></div>\n\n이것은 직관적이고 명확하며 간단합니다. 위치:고정을 입력하세요.\n\n## 위치: 고정의 엉망인 디자인\n\nHTML에는 우리의 계층 구조를 정의하는 방법에 대한 특정한 엄격함이 있으며 이는 올바른 레이아웃/사용자 인터페이스 개념을 근본적으로 훼손합니다. 이를 해결하기 위해 CSS가 개입해 HTML에 패치를 적용해야 했고, 결과적으로 레이아웃 구축과 관련하여 더 많은 문제가 발생했습니다. 이 예제를 살펴보세요. 이 스니펫은 화면에 어떻게 보일까요?\n\n```js\n<body>\n  <div id=\"fixed_1\" style=\"position: fixed\">\n    <div id=\"fixed_2\" style=\"position: fixed\"></div>\n  </div>\n  <div id=\"regular\"></div>\n</body>\n```  \n\n<div class=\"content-ad\"></div>\n\nfixed_1은 일반적인 흐름에서 벗어나 뷰포트에 대해 상대적으로 배치되어 부모가 변경됩니다. fixed_2도 동일하지만 시각적으로 fixed_1의 자식이 아닌 형제가 되었습니다 (fixed_1은 fixed_1을 자르거나 스크롤할 수 없습니다). 더불어 (위치상의) 그들은 정해진 것보다 뒤에 정의되었다는 사실에도 불구하고 일반적인 것 위에 나타납니다. 그리고 웹 전문가들이 의미론적으로 생각하는 것입니다.\n\n수백 페이지의 명세서를 쓰고, 끝없는 예외, 이상한 새로운 개념, 쌓임 맥락, 포함 블록을 도입하고 CSS가 가파른 학습 곡선을 가지고 있다고 말해도, 결과는 여전히 대참사일 것입니다. 심지어 하나의 요소에 position: fixed를 추가하면, 앞서 정의한 다섯 가지 규칙을 근본적으로 어길 것입니다 (오히려 이것은 내 규칙이 아니라 HTML과 CSS의 핵심입니다). 이 모든 것은 HTML이 뷰포트에 뷰를 직접 추가하는 것을 허용하지 않기 때문입니다.\n\n## 해결책\n\nHTML 가르침을 잠시 내려놓고 이 코드 조각을 살펴보시기 바랍니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<viewport>\n  <html>\n    <body>\n      <div id=\"regular\">웹 사이트의 본문</div>\n    </body>\n  </html>\n  <div id=\"fixed_1\">고정입니다</div>\n  <div id=\"fixed_2\">여기도 고정입니다</div>\n</viewport>\n```\n\n이것은 명백히 유효하지 않은 HTML이지만 매우 가깝습니다. 이전에 정의한 다섯 가지 규칙을 모두 준수하며 고정 위치를 필요로하지 않습니다. 사실, 위치 속성조차 필요하지 않습니다. 뷰를 소유한 곳에 두어 뷰 계층 구조가 명확합니다. 무작정 특정 예외를 생성하는 대신 자체 규칙을 이해함으로써 더 적은 노력으로 더 많은 것을 달성할 수 있습니다.\n\n안타깝게도 브라우저에서 뷰 트리의 루트는 이보다 훨씬 복잡합니다. 실제 viewport는 직접 접근할 수 없으며 `html`은 viewport도 아니고 viewport의 첫 번째 자식조차 아닙니다. 실제 트리는 다음과 같이 더 복잡합니다:\n\n```js\nwindow //object\n  screen //object, window의 상위\n  viewport //object, 접근 불가, 루트 뷰여야 함\n    #document //node, 실제 루트 뷰\n      #doctype //node\n      <html> //\"root\" element\n        <head> //보이지 않는 요소 (메타데이터)\n        <body>  //\"root\" element\n          <div> //요소 (고정), viewport의 직접 자식이어야 함\n          <div> //요소 (일반)\n```\n\n<div class=\"content-ad\"></div>\n\n절대 아름다워요.\n\n## JavaScriptUI는 어떻게 작동하나요\n\nJavaScriptUI에서는 position: fixed를 사용할 필요가 없습니다. 사실 position 속성 전체가 불필요합니다. 대신에 적절한 뷰 계층 구조와 직관적인 컨테이너가 있습니다 (사실 display 속성도 제거되었지만, 이 부분은 다른 설치에서 다룰 예정입니다). 당신이 작성한 대로 결과가 나옵니다.\n\n이것은 정확히 같은 예제이지만 엉망과 혼란이 없습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nApp(\n  Stack(\n    Text(\"웹 사이트의 본문입니다.\")\n  ),\n  Text(\"고정입니다.\"),\n  Text(\"또 다른 고정입니다.\")\n);\n```\n\n다시 말씀드리지만, 이 코드는 유효한 JavaScript 코드입니다. 단일 라이브러리에 의존하고 있습니다. 여전히 레거시 혼란이 유효한지 생각하시나요?\n\n## 하지만, 그게 왜 중요한가요?\n\n알겠어요. 이건 단 하나의 속성일 뿐이고 누가 신경 쓸까요, 맞죠? 제가 전하는 포인트는 HTML과 CSS가 이러한 성가신 문제에 침통해 있으며, 프로젝트가 확장될수록 이러한 문제들이 얼마나 많은 압박을 가하는지 심지어 인지하지 못할 수 있을 것이라는 것입니다. 오버레이, 팝업, 문서 내 다른 레이어가 필요한 경우 이 문제를 마주치게 될 것이며, CSS 코드를 부풀려 HTML 계층 구조를 엉망으로 만들며 혼란을 증가시키고 접근성을 해치고 반응성을 부정적으로 영향을 미칠 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 마무리\n\n이번 포스트는 짧았지만 여전히 도움이 된다면 좋겠습니다. 다음 주에는 더 많은 CSS 속성 및 값에 대해 알아보고 사용하기 좋은 추상화를 구축할 것입니다.\n\n만약 이 프로젝트가 마음에 든다면 박수 치거나 댓글을 남기고 다른 사람들과 이 블로그를 공유해주세요.\n\n감사합니다, 즐거운 시간 보내세요!\n\n<div class=\"content-ad\"></div>\n\n⬅️ DevBlog #3 — CSS를 대체하기 위한 새로운 스타일 시스템 설계","ogImage":{"url":"/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png"},"coverImage":"/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular에서 Web Sockets 구현하는 방법 가이드","description":"","date":"2024-06-22 03:39","slug":"2024-06-22-GuidetoimplementWebSocketsinAngular","content":"\n\n## 소개:\n\n웹 개발은 진화 중이며 실시간 애플리케이션은 사용자에게 즉각적인 업데이트를 제공하는 능력으로 인해 인기를 얻고 있습니다. 웹 소켓은 강력한 기술로, 클라이언트와 서버 간 실시간 통신을 가능하게 합니다. 이 자습서에서는 Angular 애플리케이션에 웹 소켓을 통합하여 실시간 상호작용을 원활하게 할 것입니다.\n\nAngular에서는 ngx-socket-io를 사용하여 웹 소켓 연결을 만들어 Angular 앱에 웹 소켓 기능을 추가하는 것이 더 쉬워집니다.\n\n## Angular 애플리케이션에서 웹 소켓 사용 방법:\n\n<div class=\"content-ad\"></div>\n\n## 1. 설치 :\n\nNPM을 사용하여 Socket.IO를 프로젝트에 추가하려면 터미널이나 명령 프롬프트에서 다음 명령을 입력하면 됩니다:\n// npm으로 설치하기\nnpm install socket.io\n\n// yarn으로 설치하기\nyarn add socket.io\n\n## 2. 웹 소켓 서비스 생성하기:\n\n<div class=\"content-ad\"></div>\n\n```js\n// web-socket.service.ts\n\nimport { Injectable } from '@angular/core';\nimport { Socket } from 'ngx-socket-io';\n\n@Injectable({\n providedIn: 'root',\n})\nexport class WebSocketService {\n private webSocket: Socket;\n\n constructor() {\n  this.webSocket = new Socket({\n   url: \"https://exampleUrl.com\",\n   options: {},\n  });\n }\n\n // This method is used to start the connection/handshake of the socket with the server\n connectSocket(message) {\n  this.webSocket.emit('connect', message);\n }\n\n // This method is used to receive a response from the server\n receiveStatus() {\n  return this.webSocket.fromEvent('/get-response');\n }\n\n // This method is used to end the web socket connection\n disconnectSocket() {\n  this.webSocket.disconnect();\n }\n}\n```\n\n## 3. Using Web-socket Service in an Angular Component:\n\n```js\n// my-component.component.ts\n\nimport { Component, OnInit, OnDestroy } from '@angular/core';\nimport { WebSocketService } from './websocket.service';\n\n@Component({\n selector: 'app-my-component',\n templateUrl: './my-component.component.html',\n styleUrls: ['./my-component.component.css'],\n})\nexport class MyComponentComponent implements OnInit, OnDestroy {\n constructor(private webSocketService: WebSocketService) { }\n\n ngOnInit(): void {\n  this.initializeSocketConnection();\n }\n\n ngOnDestroy() {\n  this.disconnectSocket();\n }\n\n // Initializes the socket connection\n initializeSocketConnection() {\n  this.webSocketService.connectSocket('message');\n }\n\n // Receives a response from the socket connection\n receiveSocketResponse() {\n  this.webSocketService.receiveStatus().subscribe((receivedMessage: string) => {\n   console.log(receivedMessage);\n  });\n }\n\n // Disconnects the socket connection\n disconnectSocket() {\n  this.webSocketService.disconnectSocket();\n }\n}\n```\n\n# Conclusion:\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서 웹 소켓을 활용하면 애플리케이션의 프론트엔드와 백엔드 간 실시간 통신을 구축할 수 있습니다. 이를 통해 사용자들에게 실시간 업데이트, 채팅 기능 또는 협업 편집과 같은 기능을 제공할 수 있어요.\n이 예시를 확장하여 추가 기능을 통합하거나 견고한 오류 처리를 구현하거나 백엔드 데이터베이스와 원활하게 통합하는 등 더 많은 기능을 추가할 수 있습니다. 즐거운 코딩 여행 되세요!","ogImage":{"url":"/assets/img/2024-06-22-GuidetoimplementWebSocketsinAngular_0.png"},"coverImage":"/assets/img/2024-06-22-GuidetoimplementWebSocketsinAngular_0.png","tag":["Tech"],"readingTime":3},{"title":"Angular에서 쿼리 매개변수와 경로 조건을 사용해 동적 콘텐츠 표시 및 숨기기 방법","description":"","date":"2024-06-22 03:38","slug":"2024-06-22-DynamicallyShoworHideContentinAngularUsingQueryParametersandRouteConditions","content":"\n\n현대 웹 애플리케이션에서는 현재 경로나 쿼리 매개변수에 따라 동적 콘텐츠가 필요한 경우가 일반적입니다. 이 게시물에서는 Angular 애플리케이션에서 쿼리 매개변수 및 경로 조건을 사용하여 요소를 조건부로 표시하는 방법을 보여드리겠습니다. 홈 페이지에서는 검색 창이 표시되지만 프로필 페이지에서는 숨겨지는 실제 예제를 통해 안내해 드리겠습니다.\n\n# 단계 1: 라우트 정의\n\napp-routing.module.ts에서 라우트를 정의하세요:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { ProfileComponent } from './profile/profile.component';\nimport { NotFoundComponent } from './not-found/not-found.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'profile', component: ProfileComponent },\n  { path: '**', component: NotFoundComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: 컴포넌트 생성\n\n이제 HomeComponent와 ProfileComponent를 생성하세요.\n\nHomeComponent\n\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-home',\n  templateUrl: './home.component.html',\n  styleUrls: ['./home.component.css']\n})\nexport class HomeComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\nProfileComponent\n\n```js\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-profile',\n  templateUrl: './profile.component.html',\n  styleUrls: ['./profile.component.css']\n})\nexport class ProfileComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n```\n\n# 내용을 동적으로 표시하거나 숨기기\n\n홈페이지에서는 검색 창을 표시하고 프로필 페이지에서는 숨기고 싶습니다. 이를 위해 Angular의 ActivatedRoute 및 Router 서비스를 사용하여 라우트 변경을 감지하고 조건에 따라 검색 창을 표시할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: Navbar 컴포넌트 업데이트\n\nNavbarComponent를 경로 변경에 반응하도록 업데이트하세요.\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { Router } from '@angular/router';\n\n@Component({\n  selector: 'app-navbar',\n  templateUrl: './navbar.component.html',\n  styleUrls: ['./navbar.component.css']\n})\nexport class NavbarComponent implements OnInit {\n  showSearchBar: boolean = true;\n\n  constructor(private router: Router) { }\n\n  ngOnInit(): void {\n    this.router.events.subscribe(() => {\n      this.showSearchBar = this.router.url !== '/profile';\n    });\n  }\n}\n```\n\n# 단계 4: Navbar 템플릿 업데이트\n\n<div class=\"content-ad\"></div>\n\n```js\n<nav>\n  <!-- other nav elements -->\n  <div *ngIf=\"showSearchBar\">\n    <input type=\"text\" placeholder=\"Search...\">\n  </div>\n</nav>\n```\n\n# 설명\n\n- 라우트 정의: 홈 및 프로필 페이지를 위한 라우트를 정의합니다.\n- 컴포넌트: HomeComponent 및 ProfileComponent를 위한 기본 컴포넌트가 생성되었습니다.\n- 네비게이션 바 컴포넌트:\n\n<div class=\"content-ad\"></div>\n\n- NavbarComponent는 Angular의 Router 서비스를 사용하여 라우트 변경을 구독합니다.\n- 현재 URL을 확인하여 검색 창을 표시하거나 숨길지 여부를 결정합니다.\n- URL이 /profile인 경우 showSearchBar를 false로 설정하여 검색 창을 숨깁니다. 그 외의 경우에는 true로 설정됩니다.","ogImage":{"url":"/assets/img/2024-06-22-DynamicallyShoworHideContentinAngularUsingQueryParametersandRouteConditions_0.png"},"coverImage":"/assets/img/2024-06-22-DynamicallyShoworHideContentinAngularUsingQueryParametersandRouteConditions_0.png","tag":["Tech"],"readingTime":3},{"title":"Angular 애플리케이션 성능 향상 팁 ","description":"","date":"2024-06-22 03:37","slug":"2024-06-22-HowtoImproveAngularApplicationPerformance","content":"\n\n![그림](/assets/img/2024-06-22-HowtoImproveAngularApplicationPerformance_0.png)\n\n앵귤러는 복잡하고 인터랙티브한 웹 애플리케이션을 구축하는 데 사용할 수 있는 강력한 JavaScript 프레임워크입니다. 그러나 적절하게 최적화되지 않으면 앵귤러 애플리케이션은 느리고 반응이 없을 수 있습니다.\n\n이 문서에서는 앵귤러 애플리케이션의 성능을 향상시키는 방법에 대해 몇 가지 팁과 트릭을 논의할 것입니다. 이러한 팁에는 잘 알려진 것뿐만 아니라 신호와 관련이 없는 몇 가지 독특한 방법도 포함되어 있습니다.\n\n1. ngFor 루프에서 trackBy 사용하기\n\n<div class=\"content-ad\"></div>\n\nngFor 디렉티브는 데이터 컬렉션을 순회하고 각 항목마다 템플릿을 렌더링하는 데 사용됩니다. 그러나 컬렉션이 큰 경우에는 성능 문제가 발생할 수 있습니다.\n\n성능을 향상시키려면 trackBy 속성을 사용하여 컬렉션의 변경 사항을 추적할 수 있습니다. 이렇게 하면 Angular가 컬렉션의 각 항목에 대해 전체 템플릿을 다시 렌더링하는 것을 방지할 수 있습니다.\n\n2. Lazy loading 사용하기\n\nLazy loading은 필요한 컴포넌트만 로드할 수 있는 기술입니다. 이를 통해 브라우저가 다운로드하는 초기 번들의 크기를 줄여 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n게으른로딩을 사용하려면, 각 게으른로딩된 컴포넌트를 위한 별도의 모듈을 생성해야합니다. 그런 다음, 컴포넌트가 필요할 때 모듈을 로드하기 위해 라우터를 사용할 수 있습니다.\n\n3. 복잡한 표현식과 함께 ngIf 사용을 피하세요\n\nngIf 디렉티브는 템플릿을 조건부로 렌더링하는 데 사용됩니다. 그러나 템플릿의 표시 여부를 제어하는 표현식이 복잡한 경우, 이는 성능 문제로 이어질 수 있습니다.\n\n성능을 향상시키려면, ngIf와 복잡한 표현식을 사용하는 것을 피해야합니다. 대신, ngSwitch 디렉티브나 ngTemplate 디렉티브를 사용해야합니다.\n\n<div class=\"content-ad\"></div>\n\n4. OnPush 변경 감지 전략 사용하기\n\nAngular는 응용 프로그램 상태의 변경사항을 추적하기 위해 변경 감지를 사용합니다. 그러나 변경 감지를 너무 자주 사용하면 성능 문제가 발생할 수 있습니다.\n\n성능을 개선하기 위해 OnPush 변경 감지 전략을 사용할 수 있습니다. 이 전략은 응용 프로그램 상태가 명시적으로 변경될 때만 변경 사항을 확인합니다.\n\n5. 불변 데이터 구조 사용하기\n\n<div class=\"content-ad\"></div>\n\n앵귤러는 기본적으로 불변 데이터 구조를 사용합니다. 이는 데이터 구조에 변경이 있을 때 새로운 사본이 생성된다는 것을 의미합니다. 이는 앵귤러가 데이터 구조의 변경을 추적할 필요가 없어지므로 성능을 향상시킬 수 있습니다.\n\nAOT 컴파일 사용하기\n\nAOT(Ahead Of Time) 컴파일은 앵귤러가 애플리케이션 코드를 미리 컴파일할 수 있는 기술입니다. 이를 통해 애플리케이션이 로드될 때 브라우저에서 수행해야 하는 작업량을 줄이므로 성능을 향상시킬 수 있습니다.\n\nAOT 컴파일을 사용하기 위해서는 Angular CLI에서 이를 활성화해야 합니다. 다음 명령어를 실행하여 이 작업을 수행할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nng build --aot\n```\n\n7. 서버 측 렌더링을 위해 Angular Universal 사용하기\n\nAngular Universal은 Angular 애플리케이션을 서버에서 렌더링할 수 있는 기술입니다. 이를 통해 느린 연결을 가진 사용자들의 성능을 향상시킬 수 있습니다.\n\nAngular Universal을 사용하려면 Angular Universal 패키지를 설치하고 Angular CLI에서 활성화해야 합니다. 다음 명령어를 실행하여 이 작업을 수행할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nng add @angular/universal\n```\n\n8. RxJS 및 Signals를 함께 사용하여 반응형 프로그래밍\n\nRxJS는 JavaScript를 위한 반응형 프로그래밍 API를 제공하는 라이브러리입니다. 반응형 프로그래밍은 비동기 이벤트를 더 효율적으로 처리할 수 있게 해 주어 Angular 애플리케이션의 성능을 향상시킬 수 있습니다.\n\nSignals는 Angular 16의 새로운 기능으로, 성능을 향상하는 데 사용될 수 있습니다. Signals는 변경 사항을 관찰할 수 있는 반응적인 값입니다. 이는 값이 변경될 때 다른 부분에 알림을 보내기 위해 Signals를 사용할 수 있다는 것을 의미합니다. 이는 불필요한 변경 검출 주기의 수를 줄여 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어 사용자가 버튼을 클릭할 때 응용 프로그램에 신호를 보낼 수 있습니다. 이렇게 하면 버튼을 클릭할 때마다 Angular에서 전체 템플릿을 다시 렌더링할 필요가 없어집니다.\n\n10. 웹 워커 사용\n\n웹 워커는 최신 브라우저의 기능으로, 백그라운드에서 코드를 실행할 수 있도록 해줍니다. 이를 통해 CPU 집약적 작업을 백그라운드로 옮겨서 Angular 애플리케이션의 성능을 향상시킬 수 있습니다.\n\n11. 성능 프로파일링 도구 사용\n\n<div class=\"content-ad\"></div>\n\n성능 프로파일링 도구는 귀하의 응용 프로그램에서 성능 문제를 일으키는 부분을 식별하는 데 도움을 줄 수 있습니다. 이 도구들은 응용 프로그램의 다른 부분에 얼마나 많은 시간이 소요되고 있는지, 그리고 응용 프로그램이 얼마나 자주 재렌더링되는지를 보여줄 수 있습니다.\n\n12. Angular 응용 프로그램을 제공하기 위해 CDN을 사용하세요\n\nAngular 응용 프로그램을 제공하기 위해 CDN을 사용하는 것은 응용 프로그램 코드가 사용자 브라우저에 도달하기까지 여행해야 하는 거리를 줄여 응용 프로그램의 성능을 향상시킬 수 있습니다.\n\n13. 이미지를 최적화하세요\n\n<div class=\"content-ad\"></div>\n\n이미지를 최적화하면 사용자 브라우저에서 다운로드해야 하는 이미지의 크기를 줄여 Angular 애플리케이션의 성능을 향상할 수 있어요.\n\n14. 캐싱 전략 사용하기\n\n캐싱 전략을 사용하면 개선할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-22-HowtoImproveAngularApplicationPerformance_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoImproveAngularApplicationPerformance_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular와 NET Core로 Google 캘린더에 이벤트 동기화하는 방법","description":"","date":"2024-06-22 03:36","slug":"2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore","content":"\n\n<img src=\"/assets/img/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore_0.png\" />\n\n이 기사에서는 앵귤러를 프론트엔드로 사용하고 백엔드 프로그래밍 언어로 닷넷 코어를 사용하여 우리 애플리케이션의 이벤트를 구글 캘린더에 동기화하는 방법을 단계별로 설명합니다.\n\n# 단계 1: 구글 콘솔 OAuth 2.0 클라이언트 ID 설정\n\n- 구글 콘솔로 이동하여 구글 계정으로 로그인합니다.\n- 새 프로젝트를 만들고 이름을 지정합니다.\n- APIs 및 서비스로 이동하고 Google 캘린더 API를 활성화합니다.\n- 다음으로 OAuth 동의 화면으로 이동합니다.\n- 여기에 처음 왔고 OAuth 동의 화면이 아직 구성되지 않았다면, OAuth 동의 화면을 구성하도록 강제하며 정보를 입력하고 다음 스코프 탭으로 이동합니다.\n- 스코프 추가 및 제거 버튼을 클릭하여 스코프 목록에서 \".../auth/calendar.events\" 스코프를 선택합니다.\n- 다음 단계에서는 테스트용 구글 사용자 ID를 입력합니다 (이것들은 캘린더 이벤트를 동기화 할 클라이언트의 구글 이메일 ID입니다).\n- 자격 증명으로 이동하여 자격 증명 만들기 링크를 클릭하고 OAuth 클라이언트 ID를 선택합니다.\n- 애플리케이션 유형을 웹 애플리케이션으로 설정합니다.\n- 다음 설정에서 승인된 Javascript 원본 (구글에 로그인 할 웹 애플리케이션 도메인 링크 예: http://www.example.com 또는 http://localhost:4200) 및 승인된 리디렉션 URI (구글이 로그인 후 우리 애플리케이션으로 리디렉션 할 링크 예: http://www.example.com/google-login 또는 http://localhost:4200/google-login)를 입력합니다.\n- 생성 후, 앵귤러 애플리케이션에서 사용할 클라이언트 ID를 복사하여 구글에 로그인하고 로그인 한 후 구글에서 액세스 토큰을 가져올 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore_1.png\" />\n\n# 단계 2: Angular 애플리케이션 부분\n\n- 이 부분에서는 Google에 로그인하여 유효한 액세스 토큰을 받아 dot net core 웹 API 백엔드 서비스로 보낼 것입니다.\n- 위의 기능을 통합할 준비가 된 Angular 프로젝트를 가정합니다.\n- 패키지 \"angular-oauth2-oidc\"를 설치합니다.\n- npm i angular-oauth2-oidc를 실행합니다.\n- Google에 로그인하기 위해 새로운 컴포넌트(예: google-login)를 생성합니다.\n- 그 다음에 angular-oauth2-oidc에서 새로 생성한 컴포넌트로 라이브러리를 가져옵니다.\n\n```js\nimport { AuthConfig, OAuthService } from 'angular-oauth2-oidc';\n\nconstructor(private readonly oAuthService: OAuthService) {\n    this.signIntoGoogle(); // 클라이언트 측에 저장된 Google 인증 토큰을 확인하고, 없다면 Google 로그인 페이지로 리디렉션합니다.\n}\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 클라이언트 ID를 사용하는 코드입니다.\n\n```js\n signIntoGoogle() {\n\n        const oAuthConfig: AuthConfig = {\n          issuer: 'https://accounts.google.com',\n          strictDiscoveryDocumentValidation: false,\n          redirectUri: window.location.origin + '/google-login', // Google에서 인증 후 리디렉션할 URL\n          clientId: your-client-id, //(Google 콘솔 OAuth2 클라이언트 ID)\n          scope: 'https://www.googleapis.com/auth/calendar'\n        }\n\n        this.oAuthService.configure(oAuthConfig)        \n\n        this.oAuthService.loadDiscoveryDocument().then(() => {\n          this.oAuthService.tryLoginImplicitFlow().then(() => {\n            if (!this.oAuthService.hasValidAccessToken()) { // 토큰이 유효한지 확인\n              this.oAuthService.initLoginFlow() // 로그인이 되어 있지 않다면 Google 로그인 페이지로 이동\n              console.log('Google에 로그인 중...') \n            } else {\n              console.log('Google에 로그인됨') \n              this.syncEvents(); // 이미 로그인되어 있다면 syncEvents 메서드 호출\n            }\n          },\n            (err) => {\n                console.log(\"액세스 거부, 다시 시도해 주세요!\") \n            })\n        })      \n  }\n\n syncEvents() {\n    if (this.syncing) {\n      return;\n    }\n\n    if (!this.oAuthService.hasValidAccessToken()) {\n      this.router.navigate(['/google-login']) \n      return; // 로그인되어 있지 않거나 유효한 액세스 토큰을 찾지 못했을 때\n    }\n\n    let scopes = this.oAuthService.getGrantedScopes() as Array<string>;\n\n    if (!scopes.includes(\"https://www.googleapis.com/auth/calendar\")) {\n      console.log(\"액세스 거부, 다시 시도해 주세요!\")\n      this.oAuthService.logOut();\n      this.syncing = false;\n      return;\n    }\n\n    this.syncing = true;\n    console.log(\"동기화 중, 잠시 기다려 주세요...!\")\n\n    const token = {\n      accessToken: this.oAuthService.getAccessToken()\n    }\n    \n    // 데이터베이스에서 Google 캘린더로 약속, 이벤트 등을 동기화하도록 .NET Core 백엔드 웹 API 엔드포인트 호출\n    this.http.post(env.API_ENDPOINT + 'api/googlecal/sync-events', token, {\n    }).subscribe((response: any) => {\n      console.log(\"이벤트가 성공적으로 동기화되었습니다!\")\n      this.syncing = false;\n    }, err => {\n      console.log(err);\n      this.syncing = false;\n    });\n  }\n```\n\n7. 위 코드는 브라우저에 유효한 인증 토큰이 있는지 확인하고, 그렇지 않다면 Google에서 로그인 플로우를 시작합니다. Google에 성공적으로 로그인하면 Google이 Authorized Redirect Uris에서 정의한 유효한 URL로 리디렉트되고, 유효한 인증 토큰이 브라우저에 저장됩니다.\n\n8. 다음으로 해당 토큰이 .NET Core 백엔드 웹 API로 전송되어 동기화(약속, 이벤트 등을 애플리케이션에서 Google 캘린더로 동기화)가 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: Dotnet Core WebAPI 부분\n\n- 여기서는 Angular 애플리케이션에서 게시된 유효한 액세스 토큰을 사용하여 Google 서비스를 생성하고 Google 기본 캘린더에 이벤트를 만드는 방법을 알아봅니다.\n- NuGet에서 두 개의 패키지가 필요합니다.\n- dotnet add package Google.Apis.Auth.AspNetCore3 — 버전 1.68.0\n- dotnet add package Google.Apis.Calendar.v3 — 버전 1.68.0.3430\n- 다음과 같이 컨트롤러에서 패키지를 가져옵니다.\n\n```js\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Google.Apis.Auth.OAuth2;\nusing Google.Apis.Calendar.v3;\nusing Google.Apis.Calendar.v3.Data;\nusing Google.Apis.Services;\nusing Google.Apis.Util.Store;\n\nusing Google.Apis.Auth.AspNetCore3;\nusing Google.Apis.Auth.OAuth2.Responses;\n\nnamespace ngCommon.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class GoogleCalController : ControllerBase\n    {\n        static string calendarId = \"primary\";\n\n        [HttpPost, Route(\"sync-events\")]\n        public IActionResult CreateEventsToGoogleCalendar([FromBody] TokenResponse accessToken)\n        {\n            CalendarService _service = GetCalenderServiceFromAccessToken(accessToken.AccessToken);\n\n            // 데이터베이스에서 객체 변수를 가져와 이벤트를 생성합니다.\n            this.CreateCalenderEvent(_service, appointment); // 여러분의 애플리케이션 개체 변수\n\n            // 이미 만들어진 캘린더 이벤트 가져오기\n            List<Event> listEvents = this.GetCalenderEvents(_service);\n\n            // 캘린더 이벤트를 반복하고 특정 이벤트를 업데이트합니다.\n            foreach (var event1 in listEvents)\n            {\n                this.UpdateCalenderEvent(_service, event1, appointment); // 여러분의 애플리케이션 개체 변수\n            }\n            // 여러분의 애플리케이션과 관련된 삭제된 이벤트 ID\n            var deletedApntIds = listEvents.Where(p => !appointments.Select(o => o.Id.ToString()).ToArray().Contains(p.ExtendedProperties.Private__.Where(k => k.Key == \"appointmentId\").FirstOrDefault().Value)).Select(p => p.Id).ToList(); \n            // 삭제된 ID를 반복하고 Google 캘린더에서 삭제합니다.\n            foreach (var eventId in deletedApntIds)\n            {\n                this.DeleteCalenderEvent(_service, eventId);\n            }\n\n            return Ok(new { result = true });\n        }\n\n\n        private CalendarService GetCalenderServiceFromAccessToken(string accessToken)\n        {\n            GoogleCredential credential;\n            credential = GoogleCredential.FromAccessToken(accessToken);\n\n            // Google 캘린더 API 서비스 생성\n            var service = new CalendarService(new BaseClientService.Initializer\n            {\n                HttpClientInitializer = credential,\n                ApplicationName = \"application name\"\n            });\n\n            return service;\n        }\n\n        private void CreateCalenderEvent(CalendarService _service, Models.Appointment appointment)\n        {\n            DateTime newDate = new DateTime();\n            Event body = new Event();\n\n            EventDateTime start = new EventDateTime();\n            start.DateTime = newDate; // 날짜와 시간\n\n            EventDateTime end = new EventDateTime();\n            end.DateTime = newDate;  // 날짜와 시간\n\n            body.Start = start;\n            body.End = end;\n            body.Summary = \"summary\"; // 이벤트의 표시 이름\n            body.Description = \"some description\";\n\n            body.ExtendedProperties = new Event.ExtendedPropertiesData()\n            {\n                Private__ = new Dictionary<string, string>()\n                {\n                    {\"origin\",\"web\"},\n                    {  \"appointmentId\",    \"some-text\" },\n                    {   \"date\", \"some-text\" },\n                    {   \"time\", \"some-text\"},\n                    { \"patientId\", \"some-text\"}\n                    // 이러한 키-값 쌍을 사용하여 본인의 애플리케이션 관련 데이터를 삽입할 수 있습니다\n                }\n            };\n\n            try\n            {\n                EventsResource.InsertRequest request = new EventsResource.InsertRequest(_service, body, calendarId);\n                Event response = request.Execute();\n            }\n            catch (System.Exception ex)\n            {\n                throw;\n            }\n\n        }\n\n        private List<Event> GetCalenderEvents(CalendarService _service)\n        {\n            DateTime dt1 = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, 0, 0, 0);\n\n            var newDate = new DateTimeOffset(dt1, this.GetTimeZoneInfo().GetUtcOffset(dt1));\n\n            // 요청 매개변수 정의\n            EventsResource.ListRequest request = _service.Events.List(calendarId);\n            request.TimeMin = newDate.LocalDateTime;\n            request.ShowDeleted = false;\n            request.SingleEvents = true;\n            // request.MaxResults = 10;\n            request.OrderBy = EventsResource.ListRequest.OrderByEnum.StartTime;\n\n            // 이벤트 목록\n            Events events = request.Execute();\n            return events.Items.Where(p => p.ExtendedProperties != null && p.ExtendedProperties.Private__ != null &&\n                    p.ExtendedProperties.Private__.Where(p => p.Key == \"origin\").FirstOrDefault().Value == \"web\").Select(p => p).ToList();\n\n        }\n\n        private void UpdateCalenderEvent(CalendarService _service, Event event1, Models.Appointment appointment)\n        {\n            DateTime dt1 = new DateTime(appointment.Date.Year, appointment.Date.Month, appointment.Date.Day,\n            appointment.Time.Hours, appointment.Time.Minutes, appointment.Time.Seconds);\n\n            var newDate = new DateTimeOffset(dt1, this.GetTimeZoneInfo().GetUtcOffset(dt1));\n\n            EventDateTime start = new EventDateTime();\n            start.DateTime = newDate.LocalDateTime;\n\n            EventDateTime end = new EventDateTime();\n            end.DateTime = newDate.LocalDateTime;\n\n            event1.Start = start;\n            event1.End = end;\n\n            event1.ExtendedProperties = new Event.ExtendedPropertiesData()\n            {\n                Private__ = new Dictionary<string, string>()\n                {\n                    { \"origin\",\"web\"},\n                    { \"appointmentId\",    appointment.Id.ToString() },\n                    { \"date\", appointment.Date.ToShortDateString() },\n                    { \"time\", appointment.Time.ToString()},\n                    { \"patientId\", appointment.Patient.Id.ToString()}\n                }\n            };\n\n            EventsResource.UpdateRequest request = new EventsResource.UpdateRequest(_service, event1, calendarId, event1.Id);\n            Event response = request.Execute();\n        }\n\n        private bool DeleteCalenderEvent(CalendarService _service, string eventId)\n        {\n            EventsResource.DeleteRequest request = new EventsResource.DeleteRequest(_service, calendarId, eventId);\n            string response = request.Execute();\n            return true;\n        }\n    }\n}\n```\n\n6. 이러한 위의 메서드를 사용하여 Google 캘린더에서 이벤트를 생성, 나열, 업데이트 및 삭제할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n구글 캘린더 이벤트를 생성할 때, \"Events.ExtendedProperties\"를 사용하여 애플리케이션과 관련된 정보를 저장하고, 이전에 설정한 \"ExtendedProperties\"를 기반으로 이벤트를 검색하여 애플리케이션을 통해 생성된 이벤트만 반환받을 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n코딩 즐기세요!","ogImage":{"url":"/assets/img/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore_0.png"},"coverImage":"/assets/img/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore_0.png","tag":["Tech"],"readingTime":12},{"title":"풀스택 NET 개발자 면접 대비 질문 목록","description":"","date":"2024-06-22 03:35","slug":"2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview","content":"\n\n<img src=\"/assets/img/2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview_0.png\" />\n\n풀 스택 개발자로서, 인터뷰어들은 다양한 기술에 관해 물을 수 있습니다. 그러나 나는 .NET, Angular, C#, SQL Server 및 Azure와 같은 주요 분야에 초점을 맞출 것입니다. 또한 MongoDB, 마이크로서비스 아키텍처, Docker 및 Kubernetes와 같은 보조 기술에 대한 질문에 대비할 필요가 있습니다.\n\nC# 및 .NET Framework/Core:\n\n- .NET Framework와 .NET (Core)의 차이점에 대해 설명해보세요.\n- C#을 사용하는 이점은 무엇인가요?\n- C#에서 다양한 컬렉션 유형과 사용 사례에 대해 설명해보세요.\n- .NET에서의 가비지 컬렉션에 대해 설명하고 작동 방식을 설명해보세요.\n- C# 애플리케이션에서 예외 처리를 어떻게 처리하나요?\n- C#에서 async/await 키워드는 어떻게 사용되나요?\n- 의존성 주입(Dependency Injection, DI)과 그 이점에 대해 설명해보세요.\n- C#에서 다양한 상속 유형에 대해 토론해보세요.\n- .NET 프로젝트에서 단위 테스트를 어떻게 구현하나요?\n- .NET 개발에서 일반적으로 사용되는 일부 디자인 패턴은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nASP.NET Core MVC/Web API:\n\n- ASP.NET Core에서 Model-View-Controller (MVC) 패턴을 설명해드릴게요.\n- ASP.NET Core MVC와 Web API의 차이점은 무엇인가요?\n- ASP.NET Core 애플리케이션에서 라우팅을 어떻게 처리하나요?\n- ASP.NET Core의 미들웨어와 기능에 대해 설명해드릴게요.\n- ASP.NET Core에서 인증과 권한 부여를 구현하는 다양한 방법에 대해 논의해볼까요?\n- ASP.NET Core에서 CORS(Cross-Origin Resource Sharing)를 구성하는 방법은 무엇인가요?\n- ASP.NET Core MVC에서 모델 바인딩과 유효성 검사를 설명해드릴게요.\n- ASP.NET Core 애플리케이션에서 캐싱을 구현하는 방법에 대해 알려드릴게요.\n- ASP.NET Core 애플리케이션의 성능을 향상시키기 위한 몇 가지 모범 사례는 무엇인가요?\n- ASP.NET Core에서 제공되는 로깅 메커니즘에 대해 논의해볼까요?\n\n데이터베이스(SQL Server):\n\n- SQL Server에서 다양한 종류의 조인(내부, 왼쪽, 오른쪽, 전체)을 설명해드릴게요.\n- SQL Server에서 저장 프로시저와 함수에 대해 논의하고 이점에 대해 알려드릴게요.\n- SQL Server에서 트랜잭션을 어떻게 구현하나요?\n- 데이터베이스 설계에서의 정규화와 중요성에 대해 설명해드릴게요.\n- SQL Server에서 다양한 종류의 인덱스 및 사용 시기에 대해 알려드릴게요.\n- 데이터베이스 작업 시 보안 고려 사항에 대해 논의해드릴게요.\n- .NET 애플리케이션에서 데이터베이스 마이그레이션을 어떻게 관리하나요?\n- Entity Framework(EF)와 데이터 액세스에서의 역할에 대해 설명해드릴게요.\n- .NET에서 데이터 액세스에 대한 다양한 접근 방식을 논의하고 ADO.NET, EF Core 등에 대해 이야기해볼까요?\n- 데이터베이스 쿼리의 성능을 최적화하는 방법에 대해 어떻게 생각하시나요?\n\n<div class=\"content-ad\"></div>\n\n프론트엔드 기술 (Angular):\n\n- Angular에서 컴포넌트의 개념을 설명해주세요.\n- Angular에서 데이터 바인딩 메커니즘을 논의해주세요 (일방향, 양방향).\n- Angular에서 서비스 및 의존성 주입을 어떻게 관리하나요?\n- Angular에서 라우팅을 설명하고 다양한 라우팅 전략에 대해 알려주세요.\n- Angular에서 모듈은 무엇이고 그 목적은 무엇인가요?\n- Angular에서 지시문을 사용하는 최선의 방법에 대해 논의해주세요.\n- Angular에서 컴포넌트 간 통신을 어떻게 구현하나요?\n- Angular에서 반응형 프로그래밍 개념을 설명해주세요 (Observables, RxJS).\n- Angular에서 양식 및 유효성 검사를 처리하는 기술에 대해 논의해주세요.\n- Angular 컴포넌트 및 서비스에 대한 유닛 테스트를 어떻게 구현하나요?\n\n클라우드 및 데브옵스 (Azure):\n\n- 다른 클라우드 컴퓨팅 서비스 모델을 설명해주세요 (IaaS, PaaS, SaaS).\n- .NET 애플리케이션에 Microsoft Azure를 사용하는 이점을 논의해주세요.\n- Azure App Service 및 Azure Functions은 무엇이며 사용 사례는 무엇인가요?\n- Azure Cosmos DB를 설명하고 SQL Server와 비교했을 때 차이점에 대해 설명해주세요.\n- Azure Active Directory (AAD)와 그 역할에 대해 논의해주세요.\n- Azure Storage 서비스는 무엇이며 어떻게 사용하나요?\n- Azure DevOps 도구 (Azure 파이프라인, Azure Repos) 및 기능에 대해 설명해주세요.\n- .NET 개발에서 CI/CD (지속적 통합/지속적 제공) 관행에 대해 논의해주세요.\n- .NET 애플리케이션을 Azure에 배포하기 위한 로깅 및 모니터링을 어떻게 구현하나요?\n- .NET 애플리케이션을 Azure에 배포하는 최상의 방법에 대해 설명해주세요.\n\n<div class=\"content-ad\"></div>\n\n보너스 질문:\n\n- 마이크로서비스 아키텍처 프레임워크(.NET Dapr 등)를 사용한 경험에 대해 이야기해주세요.\n- 개발 프로세스에서 성능 최적화에 대한 접근 방법은 무엇인가요?","ogImage":{"url":"/assets/img/2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview_0.png"},"coverImage":"/assets/img/2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview_0.png","tag":["Tech"],"readingTime":3}],"page":"26","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}