{"pageProps":{"posts":[{"title":"앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성","description":"","date":"2024-06-20 02:51","slug":"2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024","content":"\n\nAngular은 개발 커뮤니티에서 필수적인 프레임워크로 자리매김했습니다. GitHub에서 26만 개의 스타를 획득한 Angular은 개발자들에게 중요한 도구로 자리를 굳혀가고 있습니다. Angular은 범용 해법, 최적의 방법, 그리고 포괄적인 안내를 제공하여, 프론트엔드 개발자들에게 필수적인 도구로 자리매김하고 있습니다.\n\n파헤치기 전에 약간의 스포일러: 주요 내용 요약\n\nAngular은 싱글 페이지 애플리케이션 (SPA) 개발에 큰 영향을 미치는 다목적 TypeScript 기반 웹 애플리케이션 프레임워크입니다. 이 프레임워크는 효율적인 변경 탐지 시스템, 상태 변경 관리를 위한 Zones 사용, 그리고 Model-View-ViewModel (MVVM) 아키텍처로 유명합니다.\n\n주요 핵심내용\n\n<div class=\"content-ad\"></div>\n\n- Angular의 역할: Angular은 현대 웹 개발에 필수적입니다.\n- 커뮤니티 주도의 로드맵: 모든 전문 지식 수준을 위한 구조화된 지침이 제공됩니다.\n- 기본 지식: 웹 기술과 TypeScript에 대한 튼튼한 이해가 필요합니다.\n- Angular CLI: 이 도구는 개발 프로세스를 간소화합니다.\n- 핵심 개념: 디렉티브, 반응형 폼, 의존성 주입 및 HTTP 클라이언트가 중요합니다.\n\n2024년 Angular 로드맵\n\nAngular는 개발자들의 요구를 충족시키기 위해 지속적으로 발전하며 다재다능한 프레임워크로 자리 잡았습니다. 고유한 변경 감지 메커니즘과 Zones의 사용은 성능 효율성과 반응형 사용자 인터페이스를 보장합니다. MVVM 아키텍처를 통해 SPA를 효과적으로 구축하고 상호 작용할 수 있습니다.\n\n주요 구성 요소\n\n<div class=\"content-ad\"></div>\n\n- 변경 감지: Angular의 시스템은 가상 DOM 접근 방식과는 다르며, 성능과 응답성에 초점을 맞춥니다.\n- Zones: 원활한 사용자 경험을 보장하기 위해 비동기 작업을 관리합니다.\n- MVVM 아키텍처: SPA 개발에 견고한 기반을 제공합니다.\n\nAngular 로드맵 시작하기!\n\nAngular를 시작하려면 기본적인 웹 기술과 TypeScript를 시작으로 핵심 원리와 도구에 대한 꼼꼼한 이해가 필요합니다.\n\nAngular에 꼭 필요한 TypeScript의 핵심 개념\n\n<div class=\"content-ad\"></div>\n\n- 구조적 타이핑: 유연한 데이터 관리를 위한 기능입니다.\n- 타입 인터페이스: 복잡한 타입 구조를 정의하고 재사용합니다.\n- 유니언 타입: 타입 정의에 다양성을 추가합니다.\n- 내장 타입: 일관된 데이터 처리를 보장합니다.\n- 타입 가드 및 제네릭: 안전한 코드 조합을 가능하게 합니다.\n- 데코레이터: 클래스 선언에 메타데이터와 로직을 추가합니다.\n\n예시:\n\n![이미지](/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png)\n\n프로젝트 부트스트래핑을 위한 Angular CLI 활용\n\n<div class=\"content-ad\"></div>\n\nAngular CLI는 프로젝트 설정 및 관리를 간단하게 해주며, 다음과 같은 명령어를 통해 생산성을 향상시킵니다:\n\n- 프로젝트 초기화\n- 모듈, 컴포넌트, 서비스 생성\n- 애플리케이션 빌드, 서빙, 컴파일\n\n예시:\n\n![이미지](/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_1.png)\n\n<div class=\"content-ad\"></div>\n\n'''HTML, CSS 및 핵심 JavaScript으로 기초 다지기'''\n\n앵귤러를 숙달하려면 HTML, CSS 및 JavaScript에 능숙해져야 합니다. 이들은 앵귤러 구조의 기본 구성 요소입니다:\n\n- HTML: 웹 콘텐츠의 의미론적 구조.\n- CSS: 응답 및 매력적인 인터페이스를 위한 스타일링.\n- JavaScript: 웹 애플리케이션의 동적 처리.\n\n예:\n\n<div class=\"content-ad\"></div>\n\n\n![Angular](/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_2.png)\n\n## Angular Roadmap의 핵심 개념 및 모범 사례\n\n각 지시자(directives), 반응형 폼(reactive forms), 의존성 주입(dependency injection), 그리고 HTTP 클라이언트 등 Angular의 핵심 개념을 이해하는 것은 효율적이고 확장 가능한 애플리케이션을 만드는 데 필수적입니다.\n\n- 지시자(directives): HTML 기능 확장\n- 반응형 폼(reactive forms): 복잡한 데이터 입력을 위한 모델 주도 접근 방식\n- 의존성 주입(dependency injection): 모듈화 및 단위 테스트 단순화\n- HTTP 클라이언트: 외부 API와의 통신 처리\n\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 아래는 요청하신 내용에 대한 한국어 번역입니다.\n\n지시문 예시:\n\n- 구조 지시문: *ngFor, *ngIf\n- 속성 지시문: [ngStyle], [ngClass]\n\nAngular의 고급 기능 및 기술\n\n모듈화, 지연 로딩, 변경 감지 전략 및 서버 측 렌더링 (SSR)과 같은 고급 기능은 고성능 애플리케이션 구축에 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n- 모듈 및 Lazy Loading: 시작 성능을 향상시킵니다.\n- 변경 감지 전략: 성능을 최적화합니다.\n- SSR용 Angular Universal: SEO 및 접근성을 개선합니다.\n\n예: Lazy Loading\n\n```typescript\nconst routes: Routes = [\n  { path: 'feature', loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule) }\n];\n```\n\n신생 기술\n\n<div class=\"content-ad\"></div>\n\n기계 학습(ML), 인공 지능(AI) 및 블록체인의 통합은 Angular의 기능을 변화시키고 성능과 적응성을 향상시키고 있습니다.\n\n- ML 및 AI: 적응형 물리학 및 예측 모델링.\n- 블록체인: 탈중앙화된 컴퓨팅 및 자산 상호 운용성.","ogImage":{"url":"/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png"},"coverImage":"/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png","tag":["Tech"],"readingTime":4},{"title":"제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요","description":"","date":"2024-06-20 02:47","slug":"2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference","content":"\n\n거의 10년 전에 Java 개발자로서 경력을 시작했고, 여전히 변수를 끊임없이 타이핑했던 기억이 나네요! TypeScript로 전향한 후에는 타입 추론에 의존하기 시작했습니다. 이 언어 기능을 넘어서 이를 이해하고 있고, 이 덕분에 일상적으로 많은 키 스트로크를 절약하고 있어요.\n\n명시적 추론을 사용할 수 있다는 것을 깨달았을 때 기쁜 충격을 받았어요. 한 줄로 배열과 반환 타입을 추출할 수 있다는 것이죠!\n\n첫 번째 스키마 라이브러리를 배운 후에 엄청난 획기가 왔어요.\n\n스키마 작성을 마스터한 뒤에는 말로써 일석이조였죠. 런타임에서 수신 데이터를 구문 분석하고 추론된 유형을 컴파일 타임에 사용할 수 있었어요!\n\n<div class=\"content-ad\"></div>\n\n이 발견으로 내 생산성이 향상되었어요. 이로 인해 더 빨리 프로젝트를 완료할 수 있었거든.\n\n왜 빠른 배송이 중요한가요?\n\n경쟁사보다 빨라야 한다고 얘기하는 사람도 있죠...\n\n빠르게 배송하지 않고 꾸준히 하지 않으면, 엔지니어링 프로세스에 문제가 있는 것이라고 볼 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png)\n\n위의 그림 속 핸들을 잡고 있는 사람은 배의 엔지니어링에 대해 의심하고 있는 걸까요?\n\n생산성 향상은 다음과 같은 개념에서 비롯되었습니다.\n\n파싱을 프로젝트의 핵심 요소로 취급하고 계약 프로그래밍을 강제 적용하기 시작했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n먼저, 각 수신 구조를 구문 분석하면 데이터 처리가 시작되기 전에 보안 계층을 도입합니다. 유명한 속담을 바꿔 말하면, 수신 데이터를 테스트하지 않으면 결국 클라이언트가 테스트하게 될 것입니다!\n\n둘째로, 이는 또한 생산 중에 발생할 수 있는 버그의 수를 줄이며, 실행 시 오류를 컴파일 타입 오류로 대체합니다. 컴파일 할 수 없는 프로젝트를 배포해서는 안 됩니다!\n\n세 번째로, 적절한 애플리케이션 모니터링을 통해 구문 분석 오류(PPI를 고려함)를 오류 수집기로 보낼 수 있습니다. 문제가 발생한 위치를 이해하면 피드백 루프를 단축시킬 수 있습니다. 클라이언트가 문제를 알기 전에 문제에 대해 알고 싶습니다.\n\n마지막으로, LLM을 사용하여 스키마를 더 빨리 작성할 수 있습니다. 다시 말해, 인공지능을 습득한 사람들은 아마도 그렇지 않은 사람들의 직업을 대체할 것입니다. 이야기 끝에 별도의 섹션에서 LLM 사용에 대해 논의하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n이야기를 써서 생산성을 향상시키는 발견을 설명했어요. 제 경험에서 배우고, 현재와 미래 프로젝트에 적용해 보세요!\n\n이야기에서 제시된 모든 코드 조각은 Bun 1.1.12에서 코딩하고 테스트했어요.\n\n# 스키마 라이브러리 선택\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_1.png)\n\n<div class=\"content-ad\"></div>\n\n선택은 어려운 결정이죠.\n\n최근 몇 년 동안 다양한 스키마 라이브러리를 사용해봤는데, 특히 Zod, @effect/schema, 그리고 Yup을 주로 사용했어요. 이들은 일반적인 유효성 검증과 파싱에 사용할 때 거의 구별하기 어렵지만, 브랜드 타입이나 숫자 범위를 정의할 때 차이가 나타날 수 있어요.\n\n소프트웨어 엔지니어는 작업에 적합한 도구를 선택해야 해요. 함수형 프로그래밍에 대한 좋은 지원이 필요하다면, 불변성을 보장하고 모나드 구조를 지원하는 @effect/schema가 가장 적합할 거예요.\n\n최소한의 종속성을 유지하고 싶다면, 아무 종속성도 없는 Zod을 선호할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n모든 언급된 라이브러리에 대한 동등한 코드를 제시하겠습니다.\n\n다음 명령어를 사용하여 이들을 설치할 수 있습니다:\n\n```js\nbun install @effect/schema yup zod\n```\n\n## 구문 분석이 검증을 이기는 이유\n\n<div class=\"content-ad\"></div>\n\n제대로 시작하기 전에 TypeScript의 구조적 타이핑과 유효성 검사 및 구문 분석에 미치는 영향을 언급해야 합니다.\n\n두 타입을 비교할 때 컴파일러는 이름을 무시하고 속성 타입만 확인합니다. 예를 들어 다음 타입은 동일하다고 간주됩니다:\n\n```js\ntype User = { id: string };\ntype Company = { id: string };\n```\n\nTypeScript를 사용하기 시작할 때는 명백하지 않을 수 있지만, 더 많은 경험을 쌓으면 감이 올 것입니다. 그러나 객체 리터럴 주변에 더 많은 유의해야 할 점이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n타입 변수를 초기화할 때 컴파일러는 초과 속성에 대한 검사를 실행합니다. 우리는 이 할당의 오른쪽을 오브젝트 리터럴이라고 공식적으로 부릅니다. 다음 스니펫은 컴파일되지 않습니다:\n\n```js\nconst user: User = {\n  id: '1',\n  name: 'test username',\n};\n```\n\n저는 이 언어 기능의 이유에 동의합니다. 선택한 타입을 준수하지 않는다면 타입 변수를 지정하지 않는 것이 좋습니다. 이게 합리적으로 느껴지시나요?\n\n다음 스니펫에서 확인할 수 있듯이 함수에 오브젝트 인자를 전달할 때 초과 속성 검사는 작동하지 않습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  test: 1,\n};\n\nconst canAccessDashboard = (user: User) => (user.claims & 0x01) !== 0;\n\ncanAccessDashboard(userWithExcessProperties);\n```\n\n프로그램은 함수를 통해 데이터가 흐르는 단순한 흐름입니다. 데이터를 구문 분석하면 반복적으로 함수에 전달됩니다. 이제 데이터를 구문 분석해야 하는 이유에 대해 설명하겠습니다.\n\n구조를 검증할 때는 해당 스키마에 적합한지만 확인합니다. 유효성 검사는 새 객체를 생성하지 않습니다. TypeScript에서 원본 구조를 함수에 전달할 때 초과된 속성도 함께 전달될 수 있습니다.\n\n로그에 사용자 데이터를 기록하면 개인 식별 정보를 저장할 수 있습니다! 그래서 그것을 피하기 위해 원하는 속성을 갖는 새 객체를 만들어 데이터를 구문 분석해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_2.png\" />\n\n# 추론\n\n스키마 라이브러리를 사용하여 한 방에 두 마리의 새를 잡고 싶어요. 어떤 API에든 딱 붙어보이지만 그 대신에 어떤 데이터든 수월하게 파싱하고 컴파일러에 대한 형식을 얻고 싶어요.\n\nZod를 사용하여 사용자 스키마를 작성하려면 아래 코드를 작성할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport z, { ZodType } from 'zod';\n\nconst userSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  claims: z.number(),\n}).readonly();\r\n```\n\n이제 사용자 유형을 추론하겠습니다:\n\n```js\r\ntype User = z.infer<typeof userSchema>;\r\n```\n\n이 문장은 다음 코드의 달신이 되었습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n유저 타입을 호출할 때 다음 메소드를 이용하여 구문 분석할 거에요:\n\nconst user: User = userSchema.parse(userWithExcessProperties);\n\n사용자들을 그룹화하고 싶다고 상상해 보세요. 그룹 스키마와 해당 유형을 비슷하게 작성할 거에요:\n\n<div class=\"content-ad\"></div>\n\nconst groupSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  userIds: z.array(z.string()).readonly(),\n  interests: z.array(z.object({\n    id: z.string(),\n    level: z.union([\n      z.literal('low'),\n      z.literal('medium'),\n      z.literal('high')\n    ]),\n  })).readonly(),\n}).readonly();\n\ntype Group = z.infer<typeof groupSchema>;\r\n\n## 추이추론\n\n별도의 변수로 스키마를 추출하지 않고 관심 수준 유형을 추출하는 방법은 무엇인가요?\n\nTypeScript 유형 메커니즘을 활용하여 다음과 같이 작성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\ntype InterestLevel = Group['interests'][number]['level'];\n\n만약 제가 스키마를 별도로 사용하지 않는다면, 제 다른 비즈니스 구조의 일부로 유지합니다.\n\n덧붙여, 최소 추론 규칙을 만들었습니다. 이미 추론한 타입이 있는 경우, 그 하위 타입을 추출하기 위해 다시 추론해서는 안 된다는 것입니다!\n\n## 일반 추론\n\n<div class=\"content-ad\"></div>\n\n이제 좀 더 고급 추론 패턴을 보여드릴게요. 이를 \"일반 추론\"이라고 부르겠어요.\n\n임의의 데이터와 그들의 체크섬을 포함하는 구조를 구문 분석해야 한다고 상상해봅시다. 우리는 이러한 구조를 보통 봉투(envelope)라고 부릅니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_3.png)\n\n그래서 우리는 일반 빌더 함수를 작성할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\nconst buildChecksumEnvelopeSchema = <T>(\n  datumSchema: ZodType<T>\n) => z.object({\n  datum: datumSchema,\n  checksum: z.string(),\n}).readonly();\n\n위의 코드 조각에서 `ZodType<T>`는 일반 타입 T로 구문 분석되는 스키마입니다.\n\n만약 사용자 및 그룹 스키마와 타입을 필요로 한다면, 다음과 같이 타입을 지정할 수 있습니다:\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype UserChecksumEnvelope = z.infer<typeof userEnvelopeSchema>;\ntype GroupChecksumEnvelope = z.infer<typeof groupEnvelopeSchema>;\n\n<div class=\"content-ad\"></div>\n\n만약 우리가 일반적인 envelope 타입을 유지하고 싶다면 어떻게 할까요? 우리는 이를 사용하여 내용을 정확히 모르는 임의의 envelopes에 작업을 수행할 수 있습니다. 예를 들어, 체크섬을 계산하는 것과 같이요.\n\ntype ChecksumEnvelope<T> = z.infer<\n  ReturnType<typeof buildChecksumEnvelopeSchema<T>>\n>;\n\ntype UserChecksumEnvelope = ChecksumEnvelope<User>;\ntype GroupChecksumEnvelope = ChecksumEnvelope<Group>;\n\n## 단수 schema\n\n스키마를 사용할 때, 저는 단수 구조만을 정의하는 것을 선호합니다. 예를 들어, 다음과 같이 작성하지 않겠습니다:\n\n<div class=\"content-ad\"></div>\n\nconst usersSchema = z.array(userSchema);\ntype Users = z.infer<typeof usersSchema>;\n\n가능하다면 복수형 타입을 정의하지 않겠어요. 배열에는 `ReadonlyArray<User>`나 `User[]`를 사용할 거에요. 혼란을 피하고 다른 명명 규칙을 만들지 않기 위해 가능한 한 타입 별칭을 적게 사용하려고 해요.\n\n## 내보내기\n\n일반적으로 schema와 비즈니스 구조체의 유추된 타입을 내보내요. 다른 개발자들이 혼란스럽지 않도록 helper schema를 절대 내보내지 않아요. 가져올 수 있는 문장을 줄이기 위해 노력해요.\n\n<div class=\"content-ad\"></div>\n\n# 불변성\n\n저는 불변성의 충실한 지지자입니다.\n\n새로운 변수를 생성할 때만 데이터가 변경되므로 코드를 분석하기가 더 쉽다고 생각합니다. 제 스키마는 불변성을 일등 시민 개념으로 취급하길 원합니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_4.png)\n\n<div class=\"content-ad\"></div>\n\n불변성을 사용하는 것은 프로그래밍 언어의 규칙을 제한하기 위해 사슬을 사용하는 것과 같습니다. 깨지기 쉬운 링크만 깨뜨리면 됩니다. 저희 경우에는 스키마가 그런 링크일 수 있습니다.\n\nZod 스키마를 불변하게 만들기 위해 readonly 메서드를 호출합니다. Zod는 자동으로 불변의 추론된 유형을 생성합니다.\n\n예를 들어, 아래에 명시된 것처럼 그룹 스키마는 이미 불변성 원칙을 준수합니다:\n\nconst groupSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  userIds: z.array(z.string()).readonly(),\n  interests: z.array(z.object({\n    id: z.string(),\n    level: z.union([\n      z.literal('low'),\n      z.literal('medium'),\n      z.literal('high'),\n    ]),\n  })).readonly(),\n}).readonly();\n\n<div class=\"content-ad\"></div>\n\n만약 추론된 타입을 준수하는 인스턴스를 생성할 때 불변성에서 일시적으로 벗어나고 싶다면 어떻게 해야 할까요?\n\n해당 readonly 수정자를 무효화하는 타입을 사용해야 합니다. 일부 스키마에는 충분하지 않을 수도 있습니다. ReadonlyArray 타입을 가변으로 만들려면 어떻게 해야 할까요? 그리고 ReadonlySet은 어떻게 해야 할까요? ReadonlyMap은요?\n\n우리는 많은 실수를 저지르지 말고 전용 라이브러리를 사용해야 합니다. 예를 들어, ts-essentials 라이브러리와 많은 다른 라이브러리가 관련된 타입을 포함하고 있습니다.\n\n다음 명령어를 입력하여 설치할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nbun install ts-essentials\n\n이제 아래의 코드를 작성할 수 있습니다:\n\nimport type { DeepWritable } from ‘ts-essentials’;\n\ntype WritableGroup = DeepWritable<Group>;\n\n# Enumerations\n\n<div class=\"content-ad\"></div>\n\nZod에서 열거형을 정의하는 세 가지 방법이 있습니다:\n\n- 네이티브 열거형 사용\n- Zod의 리터럴 유니언 사용\n- Zod의 열거형 사용\n\n각 방법은 적절한 구문 분석과 유추된 유형을 제공합니다. 차이점은 열거된 모든 값을 액세스하는 데 있습니다.\n\n예를 들어, 언어 목록이 있다면 사용자의 선택을 유효성 검사하고 목록을 프론트 엔드에 전송하여 드롭다운에서 표시해야 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_5.png\" />\n\n## 네이티브 열거\n\nTypeScript를 사용하면 컴파일 시에 존재하고 런타임에도 존재하는 열거형(enum) 타입을 선언할 수 있습니다. 예를 들어, 다음과 같이 관심 수준을 나타내는 enum을 정의할 수 있습니다:\n\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n};\n\n<div class=\"content-ad\"></div>\n\nZod는 열거 유형에서 스키마를 작성하는 방법을 제공합니다. 아래 코드 스니펫에서와 같이:\n\nconst interestLevelSchema = z.nativeEnum(InterestLevel);\n\n만약 const 키워드로 InterestLevel 열거 유형을 선언했다면, 이전에는 컴파일 시간에만 존재했기 때문에 Zod 도우미를 사용할 수 없었습니다.\n\n열거된 모든 값을 추출하려면 다음 코드를 작성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nconst interestLevels = Object.values(InterestLevel);\n\n## Zod의 리터럴 유니언\n\n다른 패턴을 사용하여 열거 스키마를 정의할 수 있습니다. 결국, 열거는 문자열 또는 숫자 리터럴의 유니언입니다.\n\n각 관심 수준 리터럴에 대한 스키마를 작성해 봅시다:\n\n<div class=\"content-ad\"></div>\n\nconst interestLevelLiteralSchemata = [\n  z.literal('low'),\n  z.literal('medium'),\n  z.literal('high'),\n] as const;\n\n자 이제 적절한 스키마와 타입을 정의할 시간입니다:\n\nconst interestLevelSchema = z.union(interestLevelLiteralSchemata);\ntype InterestLevel = z.infer<typeof interestLevelSchema>;\n\n마지막으로, 모든 열거된 값을 추출할 수 있습니다:  \n\n<div class=\"content-ad\"></div>\n\nconst interestLevels = interestLevelLiteralSchemata\n  .map((literal) => literal.value);\n\n## 조드의 열거\n\n열거 스키마를 정의하는 내가 가장 좋아하는 방법은 조드의 열거 도우미를 사용하는 것입니다.\n\n다음과 같은 방법으로 스키마를 작성하고 타입을 추론할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nconst interestLevelSchema = z.enum(['low', 'medium', 'high']);\ntype InterestLevel = z.infer<typeof interestLevelSchema>;\n\n모든 열거된 값 추출을 한 줄로 처리할 수 있습니다:\n\nconst interestLevels = interestLevelSchema.options;\n\n# 구분된 연합(Unions)\n```\n\n<div class=\"content-ad\"></div>\n\n일반적인 유니언 타입에서는 컴파일러가 많은 서로 다른 타입을 구분합니다. 디스크리미네이트 유니언에서는 컴파일러가 공유 프로퍼티를 기준으로 구분합니다. 예를 들어, 애플리케이션의 작업을 특정 액터인 사용자 또는 그룹에 할당할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_6.png)\n\n제가 액터 스키마를 구현하고 다음과 같이 타입을 추론할 것입니다:\n\n```js\nconst userActorSchema = z.object({\n  type: z.literal('user'),\n  id: z.string(),\n});\n\nconst groupActorSchema = z.object({\n  type: z.literal('group'),\n  id: z.string(),\n});\n\nconst actorSchema = z.discriminatedUnion(\n  \"type\",\n  [userActorSchema, groupActorSchema],\n).readonly();\n\ntype Actor = z.infer<typeof actorSchema>;\n```\n\n<div class=\"content-ad\"></div>\n\n내 선택에는 설명이 필요해요!\n\n먼저, 사용자와 그룹 액터의 스키마를 명시적으로 정의했어요. 이 방법은 구분된 연합의 각 구성 요소를 명명하고 들여쓰기 수준을 낮게 유지하죠.\n\n누군가 액터 스키마를 읽으면, 여러 줄로 이루어진 스키마를 읽지 않아도 내 의도를 즉시 추측할 거에요!\n\n둘째, 액터 유형을 스키마에서 추론했어요. 코드 베이스에서 연합 유형의 연산이 멤버 대신 발생하기를 기대하죠.\n\n<div class=\"content-ad\"></div>\n\n세 번째로, 나는 사용자의 종류와 그룹 활동자의 유형을 추론하지 않았어. 나중에 그들을 정의해야 한다면, 다음 패턴을 사용하여 그렇게 할 수 있을 것 같아:\n\n```js\ntype UserActor1 = z.infer<typeof userActorSchema>;\ntype UserActor2 = Extract<Actor, { type: 'user' }>;\ntype UserActor3 = Actor & { type: 'user' };\n```\n\n각각이 동일한 결과를 가져오는 것에도 불구하고, 나는 첫 번째 것을 사용하지 않을 거야. 왜냐하면 그것은 최소한 추론 규칙에 어긋나기 때문이야. 이미 활동자 유형을 추론을 통해 얻었다면 TypeScript 유형 도우미를 사용하여 더 정확한 유형을 추출할 수 있어.\n\n그리고 discriminatedUnion 메서드를 사용하여 식별 속성의 이름을 명시해야 하는 이유를 궁금해할 수도 있어. 일치시켜야 할 내용을 알면 Zod가 적합한 스키마를 빠르게 찾을 수 있어. 이러한 최적화를 피하고 싶다면 union 도우미를 사용할 수도 있었겠지.\n\n<div class=\"content-ad\"></div>\n\n# 기존 유형 변환\n\n기존 TypeScript 프로젝트에는 많은 유형이 포함되어 있을 것입니다. 이를 수동으로 작성하는 것은 여러분의 시간을 낭비하는 일입니다. 대신 LLM 또는 코드 완성 도구를 사용할 수 있습니다. 정확한 법적 조언은 제공하지 않겠지만, 소유 코드베이스에서 이러한 기술을 사용할 수 있는지 항상 확인합니다.\n\n각 LLM 제공업체는 모델에 제공하는 데이터에 대해 무엇이 발생하는지 알려줄 것입니다!\n\n특정 LLM을 추천하지는 않겠지만, 주요 모델들이 이 문제를 상당히 잘 처리합니다. 유형을 정의하고 스키마 정의를 시작해보세요. 몇 번 시도한 후에는 고품질 자동완성 스키마가 나올 것입니다.\n\n<div class=\"content-ad\"></div>\n\nLLM을 완전히 믿지 마세요. 항상 결과를 검증해야 합니다!\n\n다양한 유형이 있다면, 먼저 그들의 정규 표현을 얻는 것을 추천합니다. AST 추출기를 작성하거나 TypeScript Language Server에 요청하여 이를 수행하거나, LLM이 작업을 처리하도록 할 수 있습니다. 처음 두 가지 가능성에 대해 LLM을 사용할 수 있습니다!\n\n정규 표현을 구문 분석하여 스키마를 생성하는 스크립트를 작성할 수 있습니다. 가장 큰 어려움은 스키마를 생성하는 것이 아니라 구문 분석에 사용하는 것입니다. 프로젝트 아키텍처의 완전한 변경이 필요할 수도 있습니다!\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_7.png)\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n나는 스키마와 유형 추론을 사용하는 것에 대한 설득력있는 주장을 펼쳤기를 희망합니다, 특히 LLMs와 함께. 아니라면, 의견을 남겨주세요! 다양한 기술적 주제에 대해 토론하는 것을 좋아합니다.\n\n가장 중요한 포인트를 되풀이하자면, 데이터를 단순히 유효성 검사하는 것이 아니라 파싱해야 한다고 생각합니다. 우리는 스키마를 작성하고 그로부터 유형을 추론해야 합니다. 나는 불변성을 지지하며 이 패러다임을 준수하는 스키마를 선호합니다. 또한 열거 유형 대신 스키마 리터럴을 사용하는 것을 좋아합니다.\n\n나는 내 코드가 파싱되지 않은 데이터에서 실행되지 않기 때문에 보다 빠르게 배포할 수 있습니다. 컴파일 시간 오류만 만날 것이라고 믿습니다. 애플리케이션 모니터링 덕분에 파싱이 실패할 때를 알 수 있습니다. 나는 LLM을 사용하여 스키마를 작성하고 유형을 더 빨리 추론할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이야기의 개념을 설명하는 부록을 작성했습니다. 이번에는 다른 스키마 라이브러리를 사용하여 @effect/schema와 yup을 설명합니다.\n\n# 부록 A: @effect/schema\n\n사용자 스키마를 정의하기 위해 다음과 같이 작성해야 합니다:\n\n```js\nimport { Schema } from \"@effect/schema\"\n\nconst userSchema = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  claims: Schema.Number,\n});\n```\n\n<div class=\"content-ad\"></div>\n\n사용자 스키마는 이미 불변성을 준수합니다. 아래 스니펫을 사용하여 사용자 유형을 추론할 수 있습니다:\n\n```js\ntype User = Schema.Schema.Type<typeof userSchema>;\n```\n\n위의 type helper는 다음 코드와 동일합니다:\n\n```js\ntype User = typeof userSchema.Type;\n```\n\n<div class=\"content-ad\"></div>\n\n라이브러리는 객체를 구문 분석하고 초과 속성을 허용하지 않습니다. 아래 내용을 확인해주세요:\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  excessProperty: 1,\n};\n\nconst user = Schema.decodeSync(userSchema)(userWithExcessProperties);\n```\n\n그룹 스키마와 해당 유형은 사용자 스키마와 유사하게 정의할 수 있습니다:\n\n```js\nconst groupSchema = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  userIds: Schema.Array(Schema.String),\n  interests: Schema.Array(\n    Schema.Struct({\n      id: Schema.String,\n      level: Schema.Union(\n        Schema.Literal('low'),\n        Schema.Literal('medium'),\n        Schema.Literal('high'),\n      ),\n    })\n  ),\n});\n\ntype Group = Schema.Schema.Type<typeof groupSchema>;\n```\n\n<div class=\"content-ad\"></div>\n\n일반적인 추론을 달성하기 위해 다음 코드를 작성합니다:\n\n```js\nconst buildChecksumEnvelopeSchema = <T>(\n  datumSchema: Schema.Schema<T>\n) => Schema.Struct({\n  datum: datumSchema,\n  checksum: Schema.String,\n});\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype ChecksumEnvelope<T> = Schema.Schema.Type<\n  ReturnType<typeof buildChecksumEnvelopeSchema<T>>\n>;\n\ntype UserChecksumEnvelope = ChecksumEnvelope<User>;\ntype GroupChecksumEnvelope = ChecksumEnvelope<Group>;\n```\n\n@effect/schema를 사용하여 열거 스키마를 정의하는 세 가지 방법을 찾았습니다.\n\n첫 번째 방법은 리터럴의 합집합을 사용하는 것입니다. 아래 예제를 살펴보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst interestLevelSchema = Schema.Union(\n  Schema.Literal('low'),\n  Schema.Literal('medium'),\n  Schema.Literal('high'),\n);\n\ntype InterestLevel = Schema.Schema.Type<typeof interestLevelSchema>;\n```\n\n스키마 속성에 액세스하여 관심 수준 목록을 추출할 수 있습니다. 아래에 나와있는 것처럼:\n\n```js\nconst interestLevels = interestLevelSchema\n  .members\n  .flatMap((member) => member.literals);\n```\n\n두 번째 접근 방법은 스키마 리터럴 도우미를 사용하는 것입니다. 한 줄로 스키마를 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst interestLevelSchema = Schema.Literal(‘low’, ‘medium’, ‘high’);\n```\n\n우리는 모든 값을 가져 오기위한 한 줄짜리도 사용할 것입니다:\n\n```js\nconst interestLevels = interestLevelSchema.literals;\n```\n\n이 라이브러리를 사용하면 네이티브 열거 유형을 사용할 수 있습니다! 다음 조각을 살펴보세요:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n}\n\nconst interestLevelSchema = Schema.Enums(InterestLevel)\nconst interestLevels = Object.values(InterestLevel);\n```\n\n차별화 된 연합을 정의하는 것이 더 간단하지 않았을 것입니다. 아래 코드 조각을 읽어보세요.\n\n```js\nconst userActorSchema = Schema.Struct({\n  type: Schema.Literal('user'),\n  id: Schema.String,\n});\n\nconst groupActorSchema = Schema.Struct({\n  type: Schema.Literal('group'),\n  id: Schema.String,\n});\n\nconst actorSchema = Schema.Union(userActorSchema, groupActorSchema);\ntype Actor = Schema.Schema.Type<typeof actorSchema>;\n```\n\n# 부록 B : Yup\n\n\n<div class=\"content-ad\"></div>\n\nYup을 사용한 사용자 스키마는 다음과 같습니다:\n\n```js\nimport Yup from ‘yup’;\n\nconst userSchema = Yup.object({\n  id: Yup.string().required(),\n  name: Yup.string().required(),\n  claims: Yup.number().required(),\n}).noUnknown();\n```\n\n이 라이브러리에는 두 가지 주의 사항이 있습니다. 먼저, 필수 도우미를 사용하여 비널 값 받아들이기, 두 번째로 초과 속성을 제외하려면 noUnknown 도우미를 사용해야 합니다.\n\n하지만, 여기에 더 많은 내용이 있습니다!\n\n<div class=\"content-ad\"></div>\n\n추론된 유형에서 스키마를 불변성을 보장하도록 강제하는 방법을 찾지 못했습니다. 다음과 같이 ts-essentials 라이브러리의 DeepReadonly 유형 도우미를 사용해야 했습니다:\n\n```js\ntype User = DeepReadonly<Yup.InferType<typeof userSchema>>;\n```\n\n위의 유형은 다음과 같습니다:\n\n```js\ntype User = DeepReadonly<typeof userSchema['__outputType']>;\n```\n\n<div class=\"content-ad\"></div>\n\n도서관은 내가 정의한 구문 분석을 수행하는 validateSync라는 메서드를 제공합니다:\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  excessProperty: 1,\n};\n\nconst user = userSchema.validateSync(userWithExcessProperties);\n```\n\n그룹 스키마를 다음 형식으로 정의하기를 제안합니다:\n\n```js\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n}\n\nconst groupSchema = Yup.object({\n  id: Yup.string().required(),\n  name: Yup.string().required(),\n  userIds: Yup.array(\n    Yup.string().required()\n  ).required(),\n  interests: Yup.array(\n    Yup.object({\n      id: Yup.string().required(),\n      level: Yup.mixed<InterestLevel>()\n        .oneOf(Object.values(InterestLevel))\n        .required(),\n    })\n  ).required(),\n}).noUnknown();\n\ntype Group = DeepReadonly<Yup.InferType<typeof groupSchema>>;\n```\n\n<div class=\"content-ad\"></div>\n\n만약 주의깊게 살펴봤다면, 관심 수준을 위한 enum 형식을 볼 수 있었을 것입니다. 곧 enum을 사용하는 이유에 대해 설명할 것입니다.\n\n아래 예제에서 제시된대로 제네릭 추론을 달성할 수 있습니다:\n\n```js\nconst buildChecksumEnvelopeSchema = <T>(\n  datumSchema: Yup.Schema<T>\n) => Yup.object({\n  datum: datumSchema,\n  checksum: Yup.string().required(),\n}).noUnknown();\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype UserChecksumEnvelope = DeepReadonly<\n  Yup.InferType<typeof userEnvelopeSchema>\n>;\n\ntype GroupChecksumEnvelope = DeepReadonly<\n  Yup.InferType<typeof groupEnvelopeSchema>\n>;\n\ntype ChecksumEnvelope<T> = DeepReadonly<\n  Yup.InferType<ReturnType<typeof buildChecksumEnvelopeSchema<T>>>\n>;\n\ntype UserChecksumEnvelope = ChecksumEnvelope<User>;\ntype GroupChecksumEnvelope = ChecksumEnvelope<Group>;\n```\n\n약속한 대로, Yup에서 enum 유형을 사용하는 것이 가장 합리적인 이유를 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 열거형 유형의 스키마를 손쉽게 만들 수 있습니다:\n\n```js\nconst interestLevelSchema = Yup.mixed<InterestLevel>()\n  .oneOf(Object.values(InterestLevel))\n  .required();\n```\n\n모든 값을 배열로 먼저 정의해야하는 두 번째 방법도 있습니다:\n\n```js\nconst interestLevels = [\n  'low',\n  'medium',\n  'high',\n] as const;\n\ntype InterestLevel = typeof interestLevels[number];\n```\n\n<div class=\"content-ad\"></div>\n\n다음은 한 줄로 스키마를 작성할 수 있습니다:\n\n```js\nconst interestLevelSchema = Yup.mixed<InterestLevel>()\n  .oneOf(interestLevels)\n  .required();\n```\n\n여기에는 공용 체계에 대한 스키마를 작성하는 상세한 지침이 있어야 합니다. 유감스럽게도 Yup을 사용하여 지원하는 것을 찾지 못했습니다. 그러나 해결책을 찾았습니다.\n\n스키마 시퀀스가 있는 경우, 각 스키마를 사용하여 객체를 구문 분석하는 함수를 작성하여 일치하는 것을 찾을 때까지 시도할 수 있습니다. 빠르게 작성하는 데 도움이 되는 LLM을 사용할 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n설정된 제한 시간이 초과되어 서비스에 영향을 줄 수 있습니다. 해당 작업에 대한 피드백이 필요하신 경우 언제든지 알려주세요!","ogImage":{"url":"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png"},"coverImage":"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png","tag":["Tech"],"readingTime":19},{"title":"앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기","description":"","date":"2024-06-20 02:46","slug":"2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase","content":"\n\n<img src=\"/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png\" />\n\n앵귤러, 인기 있는 자바스크립트 프레임워크로, 개발자에게 강력한 도구를 제공하여 동적이고 대화식 웹 애플리케이션을 만들 수 있게 합니다. 이 중요한 도구 중 하나는 디렉티브입니다. 이 블로그 게시물에서는 앵귤러의 디렉티브에 대해 깊이 있는 내용을 다루고, 그 종류를 탐색하며 사용법을 보여주는 코드 예제를 제공할 것입니다.\n\n# 디렉티브란 무엇인가요?\n\n디렉티브는 HTML을 확장하여 DOM 요소에 사용자 지정 동작을 부여하거나 새 HTML 요소를 생성하는 방법입니다. 이는 앵귤러의 선언적 사용자 인터페이스 구축 방식의 중요한 부분입니다. 디렉티브를 사용하면 DOM을 조작하거나 CSS 스타일을 적용하고 사용자 입력을 처리하는 등 다양한 작업을 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 지시문의 종류\n\nAngular는 네 가지 종류의 지시문을 제공합니다.\n\n- 컴포넌트 지시문: Angular에서 가장 일반적인 지시문 유형입니다. 컴포넌트는 템플릿이 있는 지시문입니다. 사용자 인터페이스의 일부를 캡슐화하며 종종 연관된 로직을 갖습니다. 재사용 가능한 UI 구성 요소를 만드는 데 사용됩니다.\n- 속성 지시문: 속성 지시문은 요소, 컴포넌트 또는 다른 지시문의 외관 또는 동작을 변경합니다. 일반적으로 HTML 요소의 속성으로 적용됩니다. 예시로는 ngClass, ngStyle 및 ngModel이 있습니다.\n- 구조 지시문: 구조 지시문은 요소를 추가하거나 제거함으로써 DOM 구조를 수정합니다. 가장 잘 알려진 구조 지시문은 ngIf, ngFor 및 ngSwitch입니다.\n- 사용자 정의 지시문: 개발자는 Angular의 기능을 확장하기 위해 사용자 정의 지시문을 생성할 수 있습니다. 사용자 정의 지시문은 속성 지시문, 구조 지시문 또는 둘 다가 될 수 있습니다. 복잡한 동작을 캡슐화하고 코드를 더 모듈화하는 데 유용합니다.\n\n이제 Angular에서 지시문을 사용하는 방법을 이해하기 위한 일부 실용적인 예제를 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 예제 1: ngIf 구조 지시문 사용하기\n\nngIf 지시문은 주어진 표현식에 기반하여 요소를 조건부로 렌더링하는 데 사용됩니다.\n\n```js\n<!-- app.component.html -->\n\n<div *ngIf=\"isLoggedIn\">\n  <p>Welcome, { username }!</p>\n</div>\n```\n\n```js\n// app.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  isLoggedIn = true;\n  username = 'John';\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 isLoggedIn이 true인 경우에만 문단 요소가 렌더링됩니다.\n\n# 예제 2: 최소 글자 수를 위한 커스텀 디렉티브 생성\n\n텍스트 필드에 사용자 입력이 최소 글자 요구 사항을 충족하는지 확인하고 싶다고 상상해보세요. Angular의 커스텀 디렉티브를 사용하여 이를 달성할 수 있습니다. 이를 위해 appMinLength이라는 커스텀 디렉티브를 생성해 봅시다.\n\n## 디렉티브 생성\n\n<div class=\"content-ad\"></div>\n\n위에있는 텍스트를 친절한 톤으로 한국어로 번역해 드리겠습니다.\n\n여기 AppMinLength 지시문을 만드는 방법이 있습니다:\n\n```js\n// min-length.directive.ts\nimport { Directive, Input, ElementRef, HostListener } from '@angular/core';\n\n@Directive({\n  selector: '[appMinLength]',\n})\nexport class MinLengthDirective {\n  @Input('appMinLength') minLength: number;\n  constructor(private el: ElementRef) {}\n  @HostListener('input') onInput() {\n    const inputValue: string = this.el.nativeElement.value;\n    if (inputValue.length < this.minLength) {\n      this.el.nativeElement.setCustomValidity(`최소 길이는 ${this.minLength}자여야 합니다.`);\n    } else {\n      this.el.nativeElement.setCustomValidity('');\n    }\n  }\n}\n```\n\n이 지시문을 단계별로 이해해 봅시다:\n\n- 우리는 [appMinLength] 선택자를 사용하여 HTML 요소의 속성으로 사용될 것임을 나타내는 MinLengthDirective 라는 사용자 정의 지시문을 정의합니다.\n- @Input('appMinLength') minLength: number; 데코레이터를 사용하여 지시문에 최소 길이를 입력으로 전달할 수 있습니다. 이 길이는 템플릿에서 지시문을 사용할 때 지정됩니다.\n- 생성자에서 ElementRef를 주입하여 지시문이 적용된 DOM 요소에 액세스할 수 있습니다.\n- @HostListener('input') 데코레이터를 사용하여 요소에서 입력 이벤트를 청취합니다. 이 이벤트는 사용자가 입력 필드에 문자를 입력하거나 삭제할 때 트리거됩니다.\n- onInput 메서드 내에서 요소로부터 현재 입력 값을 검색합니다.\n- 입력 값의 길이를 지정된 minLength과 비교합니다. 입력 길이가 필요한 최소값보다 작으면 setCustomValidity를 사용하여 사용자에게 최소 문자 요구 사항을 보여주는 사용자 지정 유효성 메시지를 설정합니다.\n- 입력 길이가 최소 요구 사항을 충족하는 경우 사용자 정의 유효성 메시지를 지웁니다.\n\n<div class=\"content-ad\"></div>\n\n## 사용자 정의 지시문 적용\n\nAngular 컴포넌트 템플릿에서 이 사용자 정의 지시문을 사용하려면 다음과 같이 입력 필드에 속성처럼 적용할 수 있습니다:\n\n```js\n<!-- app.component.html -->\n\n<input type=\"text\" placeholder=\"텍스트 입력\" [appMinLength]=\"5\" required>\n```\n\n이 예시에서는 입력 필드의 최소 길이를 5글자로 지정했습니다. 사용자가 다섯 글자 미만으로 양식을 제출하려고 시도하면 유효성 검사 오류가 발생하여 입력이 필요한 최소 길이를 충족시키도록 보장됩니다.\n\n<div class=\"content-ad\"></div>\n\n이런 맞춤 지시문을 사용하면 Angular 애플리케이션에서 특정 동작이나 제약 조건을 강제할 수 있어요. 이렇게 하면 요소들 사이의 일관성과 사용성이 향상됩니다.\n\n# 예시 3: ngFor 구조 지시문 사용\n\nngFor 지시문은 컬렉션을 반복하고 각 항목에 대해 요소를 렌더링하는 데 사용됩니다.\n\n```js\n<!-- app.component.html -->\n<ul>\n  <li *ngFor=\"let item of items\">{ item }</li>\n</ul>\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// app.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  items = ['Item 1', 'Item 2', 'Item 3'];\n}\n```\n\n이 예제에서는 items 배열의 각 요소마다 목록 항목이 생성됩니다.\n\n# 결론\n\nAngular 디렉티브는 동적이고 상호작용적인 웹 애플리케이션을 만드는 강력한 도구입니다. 이를 사용하여 DOM을 조작하고 요소 렌더링을 제어하고 재사용 가능한 동작을 캡슐화할 수 있습니다. 디렉티브를 이해하고 효과적으로 사용함으로써 유지보수 가능하고 유연한 Angular 애플리케이션을 만들 수 있습니다. 프로젝트에서 디렉티브를 실험해보고 진정한 잠재력을 발견할 수 있을 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png"},"coverImage":"/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트 공부 순수하고 불량한","description":"","date":"2024-06-20 02:44","slug":"2024-06-20-JavascriptattheNunneryPureUndefiled","content":"\n\n가장 좋은 자바스크립트는 간단하고 깔끔하며 클래스, this, 상속 및 데코레이터와 같은 추종할만한 기능으로 오염되지 않았어야 한다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png)\n\n## TLDR;\n\n자바스크립트는 다양한 언어 기능을 갖춘 매우 강력한 프로그래밍 언어입니다. 그러나 대부분은 완전한 쓰레기입니다. 지난 10년 동안 엔지니어들이 품질 좋은 코드를 작성하는 능력을 저해하는 데 그 기능들은 소용이 없었습니다. 저는 객체와 함수만 사용하는 것이 훨씬 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n# JavaScript의 문제\n\nJavaScript는 놀라운 언어입니다. JavaScript의 가장 놀라운 점은 그 창시 이후 얼마나 멀리 왔는지입니다. 대부분의 언어는 창조, 구식화, 소멸이라는 자연스러운 과정을 따릅니다. 하지만 약한 프로그래밍 언어는 필요한 것을 갖추지 못하면 새로운 언어에 밀려나며 결국 소멸합니다.\n\nJavaScript는 그 규칙의 예외입니다.\n\nJavaScript가 약했더라도 웹을 구동하는 기술로서 죽어서는 안되었습니다. 대신 새로운 기능들이 외부로 테이핑, 접착, 그리고 끈과 와이어로 결합되어 추가되었습니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 오늘 알고 있는, 싫어하는, 그리고 사랑하는 JavaScript는 처음부터 의심스러운 핵심 엔진에 계층 지어 쌓인 기능들의 집합이에요.\n\n# 커뮤니티의 문제\n\n진짜 문제는 JavaScript가 아니라, 엔지니어들이 JavaScript에 대해 어떻게 생각하는지에요. 모든 언어 기능이 특별하고 유용하며 적절한 시간과 장소가 있어서 가능한 경우 모든 기능을 배워서 사용해야 한다고 배우게 되죠.\n\n거짓말이에요.\n\n<div class=\"content-ad\"></div>\n\n프로토타입 상속을 예로 들어보죠. 좀 이상하고, 좀 추잡하며, 현대 프로그래밍 언어에는 어울리지 않는 개념이죠. 언어에 그 개념이 존재한다고 해서 우리가 받아들여야 하는 것은 아니라고 생각해요.\n\n# 해결책\n\n저는 모든 저 추잡한 특징들을 거부해요. 간단히 거절합니다. 특히 클래스, this 키워드, 데코레이터 및 상속 형태의 어떤 형태에도 의존하지 않아요. 제 JavaScript 코드는 모두 객체와 함수로 이루어져 있어요.\n\n## 클래스를 사용하지 않아요\n\n<div class=\"content-ad\"></div>\n\n클래스는 상태가 초기화된 객체일 뿐입니다. 정말, 그게 전부에요!\n\n다음 두 코드 조각은 정신적으로 동일합니다. 유일한 차이점은 클래스 파서는 new 키워드를 요구하는데 반해 const 파서는 그렇지 않습니다.\n\n![image](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_1.png)\n\n그렇다면 왜 클래스를 사용해야 할까요? 상속에 대해 생각 중이라면 다음 코드 조각을 고려해보세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_2.png)\n\n클래스로 할 수 있는 것은 모두 객체와 함수로도 할 수 있어요. 그리 어렵지 않아요.\n\n## 데코레이터는 사용하지 않아요\n\n사실 데코레이터 아이디어를 좋아해요. 안타깝게도 자바스크립트 위원회가 금기 주류에 취해 있었던 그 날 밤, 형식을 결정해버렸어요.\n\n\n<div class=\"content-ad\"></div>\n\n이를 수행하기 위해 자바스크립트가 만든 형식을 배워야 합니다. 저는 파이썬 접근 방식을 선호합니다. 파이썬에서 데코레이터는 함수를 인수로 받아들이고 함수를 반환하는 함수입니다.\n\n이것이 어떻게 동작하는지 자바스크립트에서 보여 드리겠습니다:\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_3.png)\n\n이 예제에서는 `speak` 함수를 우리의 `uppercase` 및 `emphasize` 데코레이터로 장식하여 `scream` 함수를 만들었습니다. 실제로 우리는 데코레이팅하는 것이 아니라 조합하고 있습니다. 그것은 버그가 아니라 기능입니다. 어쨌든, 우리는 동일한 꾸미기 목표를 달성하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 그런데 왜요?\n\n내 코드를 객체와 함수에만 제한하는 이유가 몇 가지 있습니다. 일반적으로 이야기하자면, 이렇게 하면 코드를 간단하고 읽기 쉽고 빠르며, 전반적으로 더 나아지게 할 수 있습니다. 나는 더 좋아합니다.\n\n## 클래스는 상태를 쌓는 경향이 있습니다\n\n이것은 절대적인 규칙은 아니지만, 제 경력 동안 본 경향입니다. 개인적으로, 결정론적인 코드와 가능한 한 순수한 함수를 강력히 선호합니다. 당신이 단호하다면 클래스로도 이러한 것들을 달성할 수 있습니다. 그러나 항상 그대로인 것 같지는 않습니다. 제가 단호해도, 다음 10 명의 엔지니어들은 같은 생각을 공유할 가능성이 낮습니다.\n\n<div class=\"content-ad\"></div>\n\n시간이 지남에 따라 클래스는 더 많은 속성을 저장하고 해당 속성에 의존하는 더 많은 함수를 추가하는 경향이 있습니다. 클래스가 정말 통제를 벗어날 때, 어느 시점에 적절한 속성 값은 메소드의 올바른 기능에 중요해집니다. 즉, 상태의 악몽입니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_4.png)\n\n객체를 사용하면 모듈 스코프에서 결정적인 함수를 작성하고 필요한 것만 전달해서 객체 인스턴스에서 호출할 수 있습니다. 이를 통해 함수에 수동으로 상태를 전달하게 되는데, 이를 통해 엔지니어들이 무엇을 추가하는지 두 번 생각하도록 유도합니다.\n\n이를 클래스로 수행할 수 있지만, 30년 이상의 전통이 있어 이 방식으로 작업하지 않는 것이 좋습니다. 다른 사람들이 당신의 코드를 분석하고 클래스를 찾게 되면, 그들은 깊게 생각하지 않고 상태를 더 늘리게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 클래스 테스트하기 어렵습니다\n\n이 포인트는 이전 내용과 밀접하게 관련되어 있습니다. 클래스가 가지고 있는 상태(state)가 많을수록 그것을 테스트하기가 어려워집니다. 클래스에서 상태를 제거하여 불변 객체(immutable object)로 만들고, 복잡한 함수를 모듈 스코프에 배치하여 독립적으로 테스트할 수 있도록 한다면, 테스트의 복잡성을 크게 줄일 수 있습니다.\n\n저는 유닛 테스트에 코드 커버리지를 중요하게 생각합니다. 아픈 경험을 토대로 말씀드리지만 상태를 가지는 클래스의 코드 커버리지는 아무런 의미가 없다고 말할 수 있습니다. 반면, 만일 클래스가 불변 객체 인스턴스이고 모듈 스코프에 결정적 함수(deterministic functions)가 있으며, 결정적 함수들이 100%의 유닛 테스트로 커버된 경우에는, 실제로 로직이 커버된 것에 자신감을 가질 수 있습니다.\n\n<img src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n우리의 오토바이 수업은 약간 특이해요 — 빨간 오토바이가 가장 빠르다는 건 누구나 알고 있죠 — 하지만 이것은 국가가 결과를 파생해내는 실제 시나리오를 보여줘요.\n\n테스트를 작성할 때, 물건의 색상과 같이 보이게는 상관없는 것이 속도에 영향을 미칠 수 있다는 것이 명백하지 않을 수 있어요.\n\n함수 및 객체 버전에서, getSpeed 함수를 위한 테스트를 작성하면 개발자에게 색상 — 필수 인수 — 가 결과에 영향을 미친다는 것을 알려줄 거에요.\n\n<div class=\"content-ad\"></div>\n\n## 객체는 인지 부담을 줄입니다\n\n사람으로서 클래스 메서드를 이해하기 위해서는 모든 상태를 내 머리로 불러와야 하고 그 후 이에 의존하는 상태를 고려하여 런타임 동작을 고려해야 합니다. 개발자로서 우리는 주로 이 의존 상태를 식별하기 위해 클래스 메서드를 검사하여 this나 self와 같은 키워드를 찾게 됩니다.\n\n결정론적 함수는 인자를 통해 의존성을 정의합니다. 이러한 경향은 이해하기 쉽고 추론하기 쉽게 만듭니다.\n\n## 데코레이터는 영원히 함수에 데코레이터를 바인딩합니다\n\n<div class=\"content-ad\"></div>\n\nJavaScript에서 @decorator 기능을 사용할 때는 데코레이터 함수를 영원히 데코레이트된 함수에 바인딩하는 것입니다. 이것은 함수를 격리해서 테스트하는 능력을 완전히 파괴합니다.\n\nspeak/scream 데코레이터 예제의 버전을 살펴봅시다. 이 예제는 @decorator 기능을 사용하도록 변환되었습니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_7.png)\n\n나는 데코레이터를 실행하지 않고는 speak 메서드를 테스트할 수 없습니다. 품질 높은 단위 테스트를 중요시하는 사람으로서, 이는 시작조차 할 수 없는 상황입니다.\n\n<div class=\"content-ad\"></div>\n\n## 장식자는 난해한 형식에 대한 지식이 필요합니다\n\n다음 코드 스니펫을 살펴보고, 저희 강조 장식자에 관해 알려주세요: 타겟이 무엇인가요? 이름은 무엇인가요? 그리고 디스크립터는 무엇인가요?\n\n<img src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_8.png\" />\n\n장식자의 정의는 간단하고 아름다운데...함수를 취하고 함수를 반환하는 함수입니다. 자바스크립트는 복잡한 형식으로 실로 우아한 패턴을 와해시켰습니다.\n\n<div class=\"content-ad\"></div>\n\n## 데코레이터들은 이를 필요로 합니다\n\n우리 두 데코레이터에서 보듯이, apply와 this를 사용하여 데코레이트된 메소드의 컨텍스트를 올바르게 설정해야 합니다.\n\n저랑 함께 마음을 열고 잠시 얘기해볼까요?... 20년 전 실수였고 오늘날에도 그래요. 하느님아, 자바스크립트에 이것을 중심으로 언어 기능을 만들지 말아 주시고 엔지니어분들아, 코딩에서 이를 중심으로 코드를 작성하지 말아 주세요.\n\n그리고 다른 얘기인데, 만약 면접을 볼 때 this 키워드에 대해 물어보면, 올바른 대답은 \"잘 모르겠어요, 이 구식 쓰레기를 사용하지 않아요. 이것은 코드를 불필요하게 복잡하게 만들 뿐이에요\" 입니다.","ogImage":{"url":"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png"},"coverImage":"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png","tag":["Tech"],"readingTime":6},{"title":"모바일에서 Playwright와 TypeScript로 자동화 테스팅을 간편하게 하기","description":"","date":"2024-06-20 02:42","slug":"2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript","content":"\n\n\n![Playwright](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_0.png)\n\n플레이 라이트는 모바일 및 웹 애플리케이션을 처리할 수 있는 다재다능한 도구로, 모든 주요 브라우저를 지원합니다. 이 유연성은 개발자와 테스터가 웹 애플리케이션이 다양한 화면 크기와 다른 조명 조건에서 어떻게 보이고 동작할지에 대한 통찰력을 얻을 수 있도록 합니다.\n\nPlaywright에서 모바일 장치 에뮬레이션은 테스트 범위를 크게 확장하지만, 실제 장치에서의 테스트 필요성을 대체하지는 않는다는 점을 기억하는 것이 중요합니다. 에뮬레이션은 사전 점검을 수행하고 애플리케이션이 다양한 장치 구성에 잘 적응하는지 확인하는 편리한 방법을 제공합니다. 그러나 성능 및 특정 하드웨어 상호작용에 대한 포괄적인 테스트, 특히 실제 장치에서의 테스트는 여전히 필수적입니다.\n\nPlaywright의 기능을 활용함으로써 개발 및 QA 팀은 다양한 장치 범주에 걸쳐 더 견고하고 사용자 친화적인 경험을 보장할 수 있으며, 궁극적으로 더 높은 품질의 웹 애플리케이션으로 이끌어 줄 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 목차\n\n- 주요 기능\n- 뷰포트 에뮬레이션\n- 색 구성표 유효성 검사\n- 지리 위치, 시간대, 및 지역 설정\n- 선행 조치\n- 프로젝트 초기화\n- tsconfig.json 생성\n- 테스트 케이스 생성 및 결과\n- 테스트 실행 방법\n- 결론\n\n# ↪️ 주요 기능\n\n# 뷰포트 에뮬레이션:\n\n<div class=\"content-ad\"></div>\n\n플레이라이트는 각종 모바일 기기의 뷰포트 크기를 에뮬레이트할 수 있어, 스마트폰과 태블릿을 포함한 다양한 모바일 기기의 화면 크기를 시뮬레이션할 수 있습니다. 이 기능을 통해 웹 애플리케이션이 다양한 화면 크기에 대응하여 레이아웃과 기능에 대한 잠재적인 문제를 해결하며, 모든 플랫폼에서 일관된 사용자 경험을 제공할 수 있습니다.\n\n# 색상 구성 검증:\n\n다크 모드와 다른 사용자별 색상 기본 설정의 인기가 높아지면서, 플레이라이트의 모바일 기기 에뮬레이션 기능을 활용하여 테스터들은 웹 애플리케이션의 디자인이 다른 색상 구성에서 어떻게 작동하는지 확인할 수 있습니다. 이는 밝은 모드와 어두운 모드에서 애플리케이션의 모습이 일관되고 접근성 있는지 확인하는 것을 포함합니다. 이렇게 함으로써, 개발자들은 사용자의 색상 구성 환경에 관계없이 시각적으로 매력적이고 사용자 친화적인 경험을 제공할 수 있습니다.\n\n# 지리적 위치, 시간대, 지역 설정:\n\n<div class=\"content-ad\"></div>\n\n플레이라이트에는 위치정보, 시간대 및 로캘을 시뮬레이션하는 강력한 기능이 포함되어 있어 다양한 테스트 시나리오를 지원합니다. 이 기능을 통해 개발자들은 웹 애플리케이션이 전 세계 사용자를 대상으로 다양한 지리적 지역 및 시간대에서 어떻게 작동하는지 테스트할 수 있으며, 전 세계 사용자에게 올바른 동작을 제공할 수 있습니다. 예를 들어, 다른 로캘을 시뮬레이션하여 날짜 및 시간 형식, 언어 설정 및 기타 지역별 기능이 예상대로 작동하는지 확인할 수 있습니다. 이러한 포괄적인 테스트를 통해 애플리케이션이 전 세계의 다양한 지역의 사용자에게 원활하고 정확한 경험을 제공하는지 확인할 수 있습니다.\n\n프레임워크의 다양한 에뮬레이션 기능은 테스트 과정을 크게 향상시켜주며, 개발자와 테스터들에게 다양한 장치 및 설정에서 웹 애플리케이션의 고품질 성능과 사용자 경험을 제공할 수 있는 강력한 도구를 제공합니다.\n\n# 사전 준비 단계\n\nTypeScript로 Playwright 스크립트를 작성하여 제공된 웹사이트에서 모바일 기기 에뮬레이션(예: iPhone 11)을 사용하여 로그인 프로세스를 자동화하는 방법을 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 프로젝트 초기화하기:\n\n- npm init -y\n- npm install playwright typescript ts-node @types/node\n- `npm` : JavaScript 패키지를 관리하는 유틸리티인 Node Package Manager입니다.\n- `init` : 새로운 Node.js 프로젝트를 초기화하고 `package.json` 파일을 생성합니다.\n- `-y` : 이 옵션은 모든 프롬프트에 \"예\"로 자동응답하여 기본 설정을 허용합니다.\n- `npm install` : 이 명령은 나열된 패키지를 설치하고 `package.json` 파일에 종속성으로 포함시킵니다.\n\n# tsconfig.json 파일 생성하기:\n\n```js\n{\n  \"compilerOptions\": {\n    \"target\": \"ES6\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true\n  },\n  \"include\": [\"src/**/*\"]\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드의 각 줄에 대한 자세한 설명을 드리겠습니다:\n\ncompilerOptions:\n\n- TypeScript 컴파일러에 코드를 컴파일하는 방법을 알려주는 다양한 설정이 포함되어 있습니다.\n\ntarget:\n\n<div class=\"content-ad\"></div>\n\nJavaScript를 출력하는 버전을 지정합니다.\n\nModule:\n\n- 출력에 사용할 모듈 시스템을 정의합니다.\n\noutDir:\n\n<div class=\"content-ad\"></div>\n\n- 컴파일된 파일이 배치될 디렉토리입니다.\n\nrootDir:\n\n- TypeScript 소스 파일이 포함된 디렉토리입니다.\n\nStrict:\n\n<div class=\"content-ad\"></div>\n\n- 모든 엄격한 유형 확인 옵션을 활성화합니다.\n\n**esModuleInterop**:\n\n- CommonJS와 ES 모듈간의 호환성을 보장합니다.\n\n**Include:**\n\n<div class=\"content-ad\"></div>\n\n- 컴파일에 포함할 파일이나 디렉토리를 지정합니다.\n\n# 테스트 케이스 생성 및 결과:\n\n# TypeScript 스크립트 생성:\n\nsrc 디렉토리를 만들고 그 안에 mobileTest.ts라는 파일을 생성하고 다음과 같은 내용을 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { chromium, devices } from 'playwright';\nconst iPhone11 = devices['iPhone 11'];\n(async () => {\n  // Chromium 브라우저 실행\n  const browser = await chromium.launch({ headless: false });\n  // iPhone 11 디바이스 설정으로 새로운 브라우저 컨텍스트 생성\n  const context = await browser.newContext({\n    ...iPhone11,\n    locale: 'en-US',\n    geolocation: { latitude: 37.7749, longitude: -122.4194 },\n    permissions: ['geolocation'],\n  });\n  // 컨텍스트에서 새로운 페이지 생성\n  const page = await context.newPage();\n  // 로그인 페이지로 이동\n  await page.goto('https://practicetestautomation.com/practice-test-login/');\n  // 사용자 이름 입력\n  await page.fill('#username', 'student');\n  // 비밀번호 입력\n  await page.fill('#password', 'Password123');\n  // 로그인 버튼 클릭\n  await page.click('#submit');\n  // 특정 요소를 확인하여 로그인 성공 여부 확인\n  const successMessage = await page.textContent('.post-title');\n  if (successMessage?.includes('Logged In Successfully')) {\n    console.log('로그인 성공');\n  } else {\n    console.log('로그인 실패');\n  }\n\n  // 브라우저 닫기\n  await browser.close();\n})();\n```\n\n위의 코드 각 줄에 대한 자세한 설명:\n\n모듈 가져오기\n\n- 'playwright'에서 'chromium, devices' 가져오기;\n- chromium: Playwright에서 Chromium 브라우저 가져오기.\n- devices: Playwright에서 사전 정의된 디바이스 설명자(예: 모바일 디바이스) 가져오기.\n\n<div class=\"content-ad\"></div>\n\n\n모바일 기기 정의\n\n- const iPhone11 = devices['iPhone 11'];iPhone11: 이 줄은 iPhone 11에 대한 미리 정의된 기기 설명자를 변수 iPhone11에 할당합니다. 기기 설명자에는 뷰포트 크기, 사용자 에이전트 및 해당 기기를 흉내 내는 기타 설정과 같은 정보가 포함됩니다.\n\n비동기 함수\n\n- (async () => {\n- 이것은 비동기 함수를 시작합니다. async 키워드를 사용하면 함수 내에서 await을 사용할 수 있어서 동기적으로 보이는 방식으로 비동기 작업을 수행할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n웹 브라우저 실행하기\n\n- const browser = await chromium.launch('headless: false');\n- chromium.launch(): 크로미엄 브라우저의 인스턴스를 실행합니다.\n- 'headless: false': 브라우저가 헤드리스 모드가 아닌, 즉 브라우저 창이 표시되는 모드로 실행됩니다.\n\n기기 설정을 갖춘 브라우저 컨텍스트 생성하기\n\n```js\nconst context = await browser.newContext({\n  ...iPhone11,\n  locale: 'en-US',\n  geolocation: { latitude: 37.7749, longitude: -122.4194 },\n  permissions: ['geolocation'],\n});\n```\n\n<div class=\"content-ad\"></div>\n\nbrowser.newContext(): 이것은 특정 설정으로 새로운 브라우저 컨텍스트를 만듭니다.\n\n…iPhone11: 전개 연산자 (…)는 iPhone11 설명자의 모든 속성을 컨텍스트 설정으로 복사하는 데 사용됩니다.\n\nlocale: 'en-US': 로캘(언어)을 영어(미국)으로 설정합니다.\n\ngeolocation: ' latitude: 37.7749, longitude: -122.4194 ': 지리적 위치를 캘리포니아 주 샌프란시스코에 해당하는 좌표로 설정합니다. permissions: ['geolocation']: 브라우저 컨텍스트에 지리적 위치 사용 권한을 부여합니다.\n\n<div class=\"content-ad\"></div>\n\n새 페이지 생성\n\n- const page = await context.newPage();\n- context.newPage(): 브라우저 컨텍스트에 새 페이지(탭)를 만듭니다.\n\n로그인 페이지로 이동\n\n- await page.goto('https://practicetestautomation.com/practice-test-login/');\n- page.goto(): 이 코드는 지정된 URL로 이동합니다. 여기서는 제공된 웹사이트의 로그인 페이지로 이동합니다.\n\n<div class=\"content-ad\"></div>\n\n사용자 이름 입력\n\n- await page.fill('#username', 'student');\n- page.fill(): 이 명령은 CSS 선택자 #username로 식별된 입력란에 'student'라는 텍스트를 입력합니다.\n\n비밀번호 입력\n\n- await page.fill('#password', 'Password123');\n- page.fill(): 이 명령은 CSS 선택자 #password로 식별된 입력란에 'Password123'이라는 텍스트를 입력합니다.\n\n<div class=\"content-ad\"></div>\n\n로그인 버튼을 클릭해주세요.\n\n- await page.click(‘#submit’);\n- page.click(): 이것은 CSS 선택자 #submit로 식별된 버튼을 클릭합니다.\n- 로그인 성공 확인\n\n```js\nconst successMessage = await page.textContent('.post-title');\n  if (successMessage?.includes('Logged In Successfully')) {\n    console.log('로그인 성공');\n  } else {\n    console.log('로그인 실패');\n  }\n```\n\npage.textContent(): 이것은 CSS 선택자 .post-title로 식별된 요소의 텍스트 콘텐츠를 검색합니다.\n\n<div class=\"content-ad\"></div>\n\n성공 메시지?.includes('로그인 성공'): 이것은 검색된 텍스트 내용이 '로그인 성공'이라는 구문을 포함하는지 확인합니다.\n\nconsole.log('로그인 성공'): 해당 구문이 찾아진 경우 콘솔에 '로그인 성공'을 기록합니다. console.log('로그인 실패'): 해당 구문이 찾아지지 않은 경우 콘솔에 '로그인 실패'를 기록합니다.\n\n브라우저 닫기\n\n- await browser.close();\n- ')();\n- browser.close(): 이것은 브라우저를 닫습니다.')();: 이것은 비동기 함수를 종료하고 즉시 호출합니다.\n\n<div class=\"content-ad\"></div>\n\n# 테스트 실행 방법\n\n- 터미널을 열고 다음 명령을 입력하세요: npx ts-node src/mobileTest.ts\n\n![이미지 1](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_1.png)\n\n![이미지 2](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_2.png)\n\n<div class=\"content-ad\"></div>\n\n\n![이미지1](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_3.png)\n\n![이미지2](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_4.png)\n\n![이미지3](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_5.png)\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트에서는 Playwright 및 TypeScript를 사용하여 웹 사이트의 로그인 기능을 자동화하는 견고한 테스팅 프레임워크를 구축했습니다. iPhone 11을 모방하여 모바일 기기에서 사이트가 잘 작동하도록 보장했습니다. TypeScript 구성(`tsconfig.json`)은 코드 컴파일을 최적화하고, 스크립트(`loginTest.ts`)는 자격 증명 입력부터 성공 확인까지 전체 로그인 프로세스를 자동화했습니다.\n\n이 방법은 테스트를 간소화하고 모바일 환경에서 문제를 발견하여 웹 사이트 품질을 향상시킵니다. Playwright 및 TypeScript를 활용하여 신뢰할 수 있고 확장 가능한 테스트 솔루션을 개발했습니다. 그러나 모바일 기기 에뮬레이션은 실제 기기에서의 테스트를 대체하지 않으며, 초기 설정이 복잡할 수 있습니다.\n\n더 많은 강력한 도구를 소화하고 탐구하여 전문적인 테스팅 도구를 숙달하기 위해 'Jignect' 와 함께 노력해보세요.\n\n저희의 섬세한 접근 방식과 첨단 솔루션이 품질과 성능을 새로운 높이로 끌어올린 것을 목격하세요. 소프트웨어 테스팅 탁월성의 세계로 여정을 시작하세요. 더 자세한 내용은 \"Tools & Technologies & QA Services\"를 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n만약 당사가 제공하는 멋진 서비스에 대해 더 알고 싶다면 언제든지 연락해 주세요.\n\n행복한 테스트하세요! 🙂\n\n원문: https://jignect.tech 에서 2024년 6월 19일에 게시됨.","ogImage":{"url":"/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_0.png"},"coverImage":"/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_0.png","tag":["Tech"],"readingTime":9},{"title":"CDK 중첩 스택 - 왜와 어떻게","description":"","date":"2024-06-20 02:39","slug":"2024-06-20-CDKNestedStacksTheWhyandHow","content":"\n\n\n![CDK Nested Stacks](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_0.png)\n\n## 시작말\n\n✔️ 우리는 중첩 스택의 필요성에 대해 이야기합니다.\n✔️ AWS CDK로 어떻게 이것이 실현될 수 있는지 논의합니다.\n\n# 소개 👋🏽\n\n\n<div class=\"content-ad\"></div>\n\n이 빠른 기사에서는 AWS CDK 중첩 스택에 대해 이야기하고, 언제 우리 서비스에 사용해야 하는지, 그리고 이를 어떻게 구현할 수 있는지에 대해 살펴볼 것입니다. 예제 코드 베이스를 통해 걸어 보기 위해 'Gilmore Cuisine'라는 가상 회사를 다룰 것입니다:\n\n![image](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_1.png)\n\n기사의 코드는 GitHub에서 여기에서 찾을 수 있습니다:\n\n더 자세한 기사와 예제는 Serverless Advocate 패턴 및 솔루션 레지스트리를 자유롭게 이용해 주세요:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_2.png\" />\n\n# 어떻게 작동할까요? 💡\n\n애플리케이션을 구축할 때 클라우드포메이션에서 스택 당 500개의 리소스 제한에 도달하는 경우가 종종 있습니다.\n\n이것은 우리가 아마도 내부적으로 많은 리소스를 포함하는 우리만의 L3 구성을 사용했기 때문에 발생할 수 있습니다. 예를 들어 알람, 점진적 배포, 대시보드 등을 포함하는 람다 구성이 있는 경우이며, 우리는 이 구성을 스택에서 여러 번 사용하여 제한을 초과하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\nAWS CDK의 NestedStack 구조는 부모 스택 내에서 하나의 자원으로 계산하여 스택 당 AWS CloudFormation 500개 자원 제한을 우회할 수 있게 해줍니다. 이는 중첩 스택이 다른 중첩 스택을 포함하여 최대 500개의 자원을 가질 수 있다는 것을 의미합니다. 중첩 스택은 구조화된 스택의 계층을 가질 수 있습니다:\n\n![CDK Nested Stacks hierarchy](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_3.png)\n\n중첩 스택의 범위(본질적으로 부모)는 AWS CDK의 Stack 또는 NestedStack 구조여야 합니다. 기존의 스택과 마찬가지로 중첩 스택에서의 구조 정의는 동일합니다.\n\n합성 과정에서 중첩 스택은 자체 AWS CloudFormation 템플릿으로 변환되어 AWS CDK 스테이징 버킷에 업로드됩니다. 중첩 스택은 부모 스택에 바인딩되어 독립적인 배포 자산으로 처리되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n부모 스택과 중첩 스택 간의 리소스 속성의 상호 참조는 AWS CDK를 사용할 때 자동으로 스택 매개변수와 출력으로 변환됩니다.\n\n다음 섹션의 코드를 살펴봅시다.\n\n👇 더 나아가기 전에 — 앞으로의 블로그 게시물과 서버리스 뉴스를 받으시려면 LinkedIn에서 저와 연결해주세요 https://www.linkedin.com/in/lee-james-gilmore/\n\n![CDK Nested Stacks](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_4.png)\n\n<div class=\"content-ad\"></div>\n\n# 코드를 통해 이야기하기👨‍💻\n\n내 작업을 따르는 사람들은 일반적으로 애플리케이션을 '상태 없음'과 '상태 있는' 리소스로 분할하는 것을 알고 있을 것입니다. 또한 깔끔한 코드 및 아키텍처에 대한 내 의견이 있습니다.\n\n이 경로를 계속 따라가서 중첩 스택을 사용하려면 폴더 구조 관점에서 다음과 같이 보일 것입니다:\n\n![Folder Structure](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_5.png)\n\n<div class=\"content-ad\"></div>\n\n이제 이제는 'stateful' 및 'stateless'의 상위 스택 아래 하나 이상의 중첩된 스택을 가지고 있음을 쉽게 확인할 수 있습니다. 그리고 그 스택이 개념적 수준에서 무엇을 포함하는지 볼 수 있습니다(API 리소스, 데이터베이스 리소스, 이벤트 버스 리소스 및 컴퓨팅 리소스).\n\n이제 폴더 구조를 확장해 보면:\n\n![image](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_6.png)\n\n중첩된 스택에는 파일에 'nested'가 추가된 단어도 있습니다. 이는 생성된 파일과 콘솔에 표시되어 이해하기 쉽게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n우리의 상태 유지 스택 코드를 살펴보면 다음과 같은 내용을 볼 수 있습니다:\n\n```js\nimport * as cdk from 'aws-cdk-lib';\n\nimport { Construct } from 'constructs';\nimport { DatabaseResources } from './nested/database/database-nested';\nimport { EventBusResources } from './nested/event-bus/event-bus-nested';\n\nexport interface GilmoreCuisineStatefulStackProps extends cdk.StackProps {\n  stage: string;\n}\n\nexport class GilmoreCuisineStatefulStack extends cdk.Stack {\n  public databaseResources: DatabaseResources;\n  public eventBusResources: EventBusResources;\n\n  constructor(\n    scope: Construct,\n    id: string,\n    props: GilmoreCuisineStatefulStackProps\n  ) {\n    super(scope, id, props);\n\n    // 두 상태 유지 중첩 스택을 가져와서 인스턴스화합니다.\n    this.databaseResources = new DatabaseResources(this, 'DatabaseResources', {\n      stage: props.stage,\n    });\n\n    this.eventBusResources = new EventBusResources(this, 'EventBusResources', {\n      stage: props.stage,\n    });\n  }\n}\n```\n\n위에서 볼 수 있듯이, 우리의 상위 스택은 두 중첩된 스택을 가져와서 그것들을 인스턴스화합니다.\n\n그런 다음 DatabaseResources 중첩 스택을 살펴보면 다음과 같은 내용을 볼 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport * as cdk from 'aws-cdk-lib';\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\n\nimport { Construct } from 'constructs';\n\ninterface DatabaseResourcesProps extends cdk.NestedStackProps {\n  stage: string;\n}\n\nexport class DatabaseResources extends cdk.NestedStack {\n  public table: dynamodb.Table;\n\n  constructor(scope: Construct, id: string, props: DatabaseResourcesProps) {\n    super(scope, id, props);\n\n    // our database is a static resource\n    this.table = new dynamodb.Table(this, 'Table', {\n      tableName: `gilmore-cuisine-table-${props.stage}`,\n      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,\n      partitionKey: {\n        name: 'id',\n        type: dynamodb.AttributeType.STRING,\n      },\n      removalPolicy: cdk.RemovalPolicy.DESTROY,\n    });\n  }\n}\n```\n\n특히 이 스택이 cdk.Stack이 아닌 부모와 같이 cdk.NestedStack을 확장하는 것을 볼 수 있습니다.\n\n이제 상태 리소스를 사용하는 ComputeResources 중첩 스택으로 이동하면 다음과 같은 코드가 나옵니다:\n\n```js\nimport * as apigw from 'aws-cdk-lib/aws-apigateway';\nimport * as cdk from 'aws-cdk-lib';\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\nimport * as events from 'aws-cdk-lib/aws-events';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as nodeLambda from 'aws-cdk-lib/aws-lambda-nodejs';\nimport * as path from 'path';\n\nimport { Construct } from 'constructs';\n\ninterface ComputeResourcesProps extends cdk.NestedStackProps {\n  stage: string;\n  api: apigw.RestApi;\n}\n\nexport class ComputeResources extends cdk.NestedStack {\n  private api: apigw.RestApi;\n  private table: dynamodb.Table;\n  private bus: events.EventBus;\n\n  constructor(scope: Construct, id: string, props: ComputeResourcesProps) {\n    super(scope, id, props);\n\n    this.api = props.api;\n\n    // 상태 리소스에서 테이블의 인스턴스 가져오기\n    this.table = dynamodb.Table.fromTableName(\n      this,\n      'Table',\n      `gilmore-cuisine-table-${props.stage}`\n    ) as dynamodb.Table;\n\n    // 상태 리소스에서 bus의 인스턴스 가져오기\n    this.bus = events.EventBus.fromEventBusName(\n      this,\n      'EventBus',\n      `gilmore-cuisine-event-bus-${props.stage}`\n    ) as events.EventBus;\n\n    // 람다 파우어툴즈 설정 생성\n    const lambdaPowerToolsConfig = {\n      LOG_LEVEL: 'DEBUG',\n      POWERTOOLS_LOGGER_LOG_EVENT: 'true',\n      POWERTOOLS_LOGGER_SAMPLE_RATE: '1',\n      POWERTOOLS_TRACE_ENABLED: 'enabled',\n      POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS: 'captureHTTPsRequests',\n      POWERTOOLS_SERVICE_NAME: 'gilmore-cuisine-service',\n      POWERTOOLS_TRACER_CAPTURE_RESPONSE: 'captureResult',\n      POWERTOOLS_METRICS_NAMESPACE: 'gilmore-cuisine',\n    };\n\n    // 람다 함수 생성\n    const listBookingsLambda: nodeLambda.NodejsFunction =\n      new nodeLambda.NodejsFunction(this, 'ListBookingsLambda', {\n        functionName: `${props.stage}-gilmore-cuisine-list-bookings`,\n        runtime: lambda.Runtime.NODEJS_20_X,\n        entry: path.join(\n          __dirname,\n          '../../src/adapters/primary/list-bookings/list-bookings.adapter.ts'\n        ),\n        memorySize: 1024,\n        handler: 'handler',\n        tracing: lambda.Tracing.ACTIVE,\n        bundling: {\n          minify: true,\n          sourceMap: true,\n        },\n        environment: {\n          NODE_OPTIONS: '--enable-source-maps',\n          ...lambdaPowerToolsConfig,\n          TABLE_NAME: this.table.tableName,\n          BUS: this.bus.eventBusName,\n        },\n      });\n\n    const createBookingLambda: nodeLambda.NodejsFunction =\n      new nodeLambda.NodejsFunction(this, 'CreateBookingLambda', {\n        functionName: `${props.stage}-gilmore-cuisine-create-booking`,\n        runtime: lambda.Runtime.NODEJS_20_X,\n        entry: path.join(\n          __dirname,\n          '../../src/adapters/primary/create-booking/create-booking.adapter.ts'\n        ),\n        memorySize: 1024,\n        handler: 'handler',\n        tracing: lambda.Tracing.ACTIVE,\n        bundling: {\n          minify: true,\n          sourceMap: true,\n        },\n        environment: {\n          NODE_OPTIONS: '--enable-source-maps',\n          ...lambdaPowerToolsConfig,\n          TABLE_NAME: this.table.tableName,\n          BUS: this.bus.eventBusName,\n        },\n      });\n\n    // 함수에 대한 테이블 권한 부여\n    this.table.grantReadData(listBookingsLambda);\n    this.table.grantWriteData(createBookingLambda);\n\n    // 함수가 메시지를 발행하도록 허용\n    this.bus.grantPutEventsTo(createBookingLambda);\n\n    // 올바른 API 리소스에 람다 함수 추가\n    const orders = this.api.root\n      .getResource('v1')\n      ?.getResource('bookings') as apigw.Resource;\n\n    orders.addMethod(\n      'GET',\n      new apigw.LambdaIntegration(listBookingsLambda, {\n        proxy: true,\n      })\n    );\n\n    orders.addMethod(\n      'POST',\n      new apigw.LambdaIntegration(createBookingLambda, {\n        proxy: true,\n      })\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위에서 볼 수 있듯이 DynamoDB 테이블 및 EventBridge 이벤트 버스의 상태를 전달하는 것이 아니라, 다음 메서드를 사용하여 그들에 대한 참조를 얻고 있습니다.\n\n```js\n...\n// 상태를 가진 스택에서 테이블의 인스턴스를 가져옴\nthis.table = dynamodb.Table.fromTableName(\n  this,\n  'Table',\n  `gilmore-cuisine-table-${props.stage}`\n) as dynamodb.Table;\n\n// 상태를 가진 스택에서 이벤트 버스의 인스턴스를 가져옴\nthis.bus = events.EventBus.fromEventBusName(\n  this,\n  'EventBus',\n  `gilmore-cuisine-event-bus-${props.stage}`\n) as events.EventBus;\n...\n```\n\n그러나 이는 상태를 가진 스택이 상태가 없는 스택보다 먼저 배포되어야 함을 의미합니다. 이는 의존성에 관한 다음과 같이 메인 애플리케이션 파일에서 확실하게 할 수 있습니다.\n\n```js\n#!/usr/bin/env node\n\nimport 'source-map-support/register';\n\nimport * as cdk from 'aws-cdk-lib';\n\nimport { GilmoreCuisineStatefulStack } from '../stateful/stateful';\nimport { GilmoreCuisineStatelessStack } from '../stateless/stateless';\n\nconst stage = 'prod';\n\nconst app = new cdk.App();\n\nconst stateful = new GilmoreCuisineStatefulStack(\n  app,\n  'GilmoreCuisineStatefulStack',\n  {\n    stage,\n  }\n);\n\nconst stateless = new GilmoreCuisineStatelessStack(\n  app,\n  'GilmoreCuisineStatelessStack',\n  {\n    stage,\n  }\n);\n\n// stateless가 stateful보다 먼저 배포되도록 함\nstateless.addDependency(stateful);\n```\n\n<div class=\"content-ad\"></div>\n\n다음 섹션에서 해결책을 배포하고 테스트해 봅시다.\n\n## 배포 및 테스트 🧑🏾‍💻\n\n그럼 이제 'gilmore-cuisine' 폴더에서 다음 명령을 실행하여 스택을 배포해 보겠습니다:\n\n\nnpm run deploy\n\n\n<div class=\"content-ad\"></div>\n\n동일한 폴더에서 cdk 목록 명령을 실행하면 앞서 설명한대로 두 개의 상위 스택만 볼 수 있습니다:\n\n![CDK Nested Stacks](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_7.png)\n\n합성된 CloudFormation 템플릿 및 에셋이 포함된 cdk.out 폴더를 로컬로 확인하면 다음 파일들이 표시됩니다:\n\n두 개의 상위 템플릿, GilmoreCuisineStatefulStack.template.json 및 GilmoreCuisineStatelessStack.template.json,이 있음을 확인할 수 있습니다. 이들은 아래와 유사한 내용을 가지고 있으며 중첩 스택을 가리킵니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n\"UpdateReplacePolicy\": \"Delete\",\n\"DeletionPolicy\": \"Delete\",\n\"Metadata\": {\n  \"aws:cdk:path\": \"GilmoreCuisineStatefulStack/EventBusResources.NestedStack/EventBusResources.NestedStackResource\",\n  \"aws:asset:path\": \"GilmoreCuisineStatefulStackEventBusResourcesAC59B19D.nested.template.json\",\n  \"aws:asset:property\": \"TemplateURL\"\n}\n...\n```\n\n배포가 완료되면 콘솔로 전환하여 콘솔에 중첩 스택이 표시되지 않도록 설정하면 다음과 같이 표시됩니다:\n\n이제 콘솔에서 두 스택의 하위 중첩 스택을 살펴보겠습니다:\n\n이제 각 스택의 내용을 자세히 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n## ✔️ Stateful Stack\n\n상태 유지 스택 안에는 DatabaseResources와 EventBusResources에 대한 중첩 스택을 볼 수 있습니다:\n\n보다 자세한 내용을 살펴보면 다음과 같습니다:\n\nDatabaseResources\n우리의 DynamoDB 테이블이 포함된 DatabaseResources에 대한 중첩 스택을 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nEventBusResources\n이벤트 버스, CloudWatch 로그 그룹 및 이벤트 규칙 대상을 포함하는 EventBusResources의 중첩 스택을 볼 수 있습니다:\n\n이제 무상태 스택과 관련된 내용을 살펴보겠습니다.\n\n## ✔️ 무상태 스택\n\n무상태 스택에는 ApiResources 및 ComputeResources의 두 개의 중첩 스택이 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\nApiResources\n아래에서 ApiResources에 대한 중첩 스택을 볼 수 있는데, API Gateway REST API, 스테이지, 배포 등이 포함되어 있습니다.\n\nComputeResources\n아래에서 ComputeResources에 대한 중첩 스택을 볼 수 있는데, 두 개의 람다 함수가 포함되어 있습니다:\n\n## 테스팅 🧪\n\n<img src=\"/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_8.png\" />\n\n<div class=\"content-ad\"></div>\n\n만약 Postman 파일을 사용하여 /bookings/의 POST 엔드포인트를 요청하면 다음과 같은 결과를 볼 수 있습니다:\n\n![이미지](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_9.png)\n\n그리고 CloudWatch 로그의 모든 이벤트를 캐치하는 대상을 살펴보면 아래와 같이 이벤트가 표시됩니다:\n\n![이미지](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_10.png)\n\n<div class=\"content-ad\"></div>\n\n아래는 목록 예약 엔드포인트를 실행할 수도 있어요. \n\n이것을 보여 주겠죠: \n\n![List Bookings EndPoint](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_12.png)\n\n# 결론  \n\n<div class=\"content-ad\"></div>\n\n이 글을 읽어주셔서 감사합니다. 마지막으로 다룬 내용을 요약하면 다음과 같습니다:\n\n- 중첩 스택이 필요한 이유에 대해 이야기했습니다.\n- AWS CDK를 사용하여 이를 어떻게 구현할 수 있는지에 대해 이야기했습니다.\n\n# 마무리 인사 👋🏽\n\n이 짧은 글을 즐겁게 읽어주셨기를 바라며, 마음에 드셨다면 공유해 주시고 피드백을 주세요!\n\n<div class=\"content-ad\"></div>\n\n비슷한 콘텐츠를 더 보고 싶다면 제 YouTube 채널을 방문해주세요!\n\n![YouTube](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_13.png)\n\n그리고 다음 링크를 통해 연락할 수도 있어요:\n\n[LinkedIn 프로필](https://www.linkedin.com/in/lee-james-gilmore/)\n[Twitter 프로필](https://twitter.com/LeeJamesGilmore)\n\n<div class=\"content-ad\"></div>\n\n만약 이 게시물을 즐겼다면, 추가 포스트/시리즈를 확인하려면 제 프로필 Lee James Gilmore를 팔로우해 주세요. 또한 'clap' 기능을 이용해 주세요. 게시물 하단에 위치해 있습니다. 한 번 이상으로도 클랩을 할 수 있어요! \n\n# 나에 대해\n\n\"안녕하세요, 저는 영국에 거주하고 있는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 기술 및 아키텍처 글로벌 총괄인 Lee입니다. 현재 City Electrical Factors (UK) 및 City Electric Supply (US)에서 근무 중이며, 지난 6년간 주로 AWS에서 풀스택 JavaScript를 사용해 왔습니다.\"\n\n<div class=\"content-ad\"></div>\n\n저는 모든 것을 AWS, 혁신, 소프트웨어 아키텍처, 그리고 기술에 대한 사랑으로 서버리스를 옹호하는 사람이라고 생각해요.\n\n*** 제공된 정보는 제 개인적인 견해이며, 그에 따른 책임을 지지 않습니다. ***\n\n아래 내용도 관심이 있을지도 모릅니다:","ogImage":{"url":"/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_0.png"},"coverImage":"/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_0.png","tag":["Tech"],"readingTime":13},{"title":"자바스크립트 맵이 무엇이며 어떻게 작동하는지 완벽한 가이드","description":"","date":"2024-06-20 02:37","slug":"2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide","content":"\n\n![JavaScript Maps](/assets/img/2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide_0.png)\n\n안녕하세요! 아마도 JavaScript 객체에 익숙하실 것입니다. 그런데 JavaScript에서 데이터 세트를 만드는 또 다른 방법인 'Maps'에 대해 알고 계셨나요? 지금은 JavaScript의 일반 객체를 사용하고 계실 수도 있는데, 문제 해결에 더 나은 해결책이 될 수 있는 맵(map)을 사용해볼까요?\n\nJavaScript 맵은 객체와 몇 가지 주요 면에서 다릅니다. typeof new Map()을 호출하면 object가 반환되지만, 이것에 속지 마세요! 객체와 맵 사이에 주요한 차이점들을 알아보겠습니다:\n\n- 객체와 달리 기본적으로 어떠한 키도 포함하지 않습니다. 객체는 프로토타입 객체를 포함하고 있습니다.\n- 맵은 삽입된 순서대로 정렬되는 것이 보장됩니다. 객체도 요즘은 이와 같이 동작하지만, 같은 보장을 제공하지는 않습니다.\n- 맵의 키는 함수나 객체를 포함하여 모든 것이 될 수 있습니다. 반면 JavaScript에서는 문자열이나 심볼이어야 합니다.\n- 데이터의 빠른 또는 빈번한 추가 또는 삭제 작업을 필요로 하는 작업에서 객체보다 더 나은 성능을 보여줍니다.\n- 객체와 달리 맵은 기본적으로 iterable(반복 가능)합니다.\n\n더 궁금한 점이 있으시면 언제든지 물어보세요!\n\n<div class=\"content-ad\"></div>\n\n지도의 많은 혜택을 고려한다면, 작동 방식을 살펴보는 게 좋겠죠.\n\n# JavaScript Maps 작동 기본\n\nJavaScript에서의 모든 지도는 new Map() 생성자를 사용하여 초기화됩니다. 예를 들어, myFirstMap이라는 지도를 생성해 봅시다:\n\n```js\nlet myFirstMap = new Map();\n```\n\n<div class=\"content-ad\"></div>\n\n차이점은 맵에서 키를 설정, 가져오거나 삭제하려면 Map과 함께 제공되는 특정 메서드를 사용해야 한다는 것입니다. 따라서 firstKey라는 키로 someValue의 새 값을 설정하려면 다음 메서드를 실행할 수 있습니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\n```\n\n# JavaScript Map에서 항목 삭제\n\nJavaScript 맵에서 키를 삭제하려면 delete() 메서드를 호출해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.delete('firstKey');\n```\n\n또한 clear()를 사용하여 전체 맵을 삭제하고 내용을 비울 수도 있습니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.clear();\nconsole.log(myFirstMap); // Map(0) 반환\n```\n\n# JavaScript Map에서 키 가져오기\n\n\n<div class=\"content-ad\"></div>\n\n다른 방법들과 비슷하게, firstKey의 값을 얻으려면 get()을 사용해야 합니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.get('firstKey') // 'someValue'\n```\n\n# JavaScript Map에서 키가 존재하는지 확인하기\n\nJavaScript Maps에는 특정 키가 있는지 확인하려면 has() 메서드를 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.has('firstKey') // true\n```\n\n# 주의: 일반 객체 속성을 Map과 함께 사용하지 마세요\n\n자바스크립트에는 많은 특이성이 있고, Map도 예외는 아닙니다. 놀랍게도, Map은 객체 표기법도 지원할 수 있습니다. 예를 들어, 다음과 같이 동작하는 것처럼 보입니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap['firstKey'] = 'someValue';\nconsole.log(myFirstMap); // Map(0) { firstKey: 'someValue' }\n```\n\n<div class=\"content-ad\"></div>\n\n그러나, 이렇게 하면 안 돼요! 이것은 맵 자체에 새 항목을 만드는 것이 아니라 단순히 객체를 만드는 것이에요. 그러면 JavaScript 맵의 모든 이점을 잃게 되요.\n\n# JavaScript 맵의 크기를 알려주는 방법\n\n맵에 있는 키의 개수를 찾는 것은 객체보다 맵이 조금 더 사용하기 쉬운 경우 중 하나에요. 이를 위해 size() 메서드를 사용할 수 있어요. 이 메서드는 키의 개수를 반환해요:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.size // 1\n```\n\n<div class=\"content-ad\"></div>\n\n객체의 크기를 알아내기 위해 일반적으로 Object.keys()와 length를 혼합하여 사용합니다:\n\n```js\nlet myObj = { \"name\" : \"John\" };\nlet sizeOfObj = Object.keys(myObj).length; // 1\n```\n\n# 문자열이 아닌 키로 Map 사용하기\n\n제가 언급했듯이, JavaScript Maps는 함수와 객체와 같은 비전통적인 키를 허용합니다. 반면 객체는 문자열과 심볼만 허용합니다. 예를 들어, Map에서는 다음과 같이 유효합니다:\n\n<div class=\"content-ad\"></div>\n\n맵의 키는 값이 아닌 참조 값에 기반합니다. 즉, 다음과 같이 작동합니다.\n\n```js\nlet myFirstMap = new Map();\nlet myFunction = function() { return \"someReturn\"; }\nmyFirstMap.set(myFunction, \"value\");\nmyFirstMap.get(myFunction); // \"someReturn\" 반환\n```\n\n아래는 작동하지 않습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nlet myFirstMap = new Map();\nlet myFunction = function() { return \"someReturn\"; }\nmyFirstMap.set(myFunction, \"value\");\nmyFirstMap.get(function() { return \"someReturn\"; }); // 결과는 정의되지 않습니다\nmyFirstMap.get('someReturn'); // 결과는 정의되지 않습니다\n```\n\n그 이유는 function() { return \"someReturn\"; }와 myFunction이 값으로는 같지만 시스템 메모리에 저장된 위치가 다르기 때문입니다. 그래서 완전히 동등하지는 않습니다. 비슷하게, 맵은 반환 값에 대해 작동하지 않으므로 myFirstMap.get('someReturn') 또한 정의되지 않은 값을 반환합니다.\n\n객체에 대해서도 같은 예제가 유사한 결과를 가져옵니다:\n\n```js\nlet myFirstMap = new Map();\nlet myObject = { \"someKey\" : \"someValue\" }\nmyFirstMap.set(myObject, \"value\");\nmyFirstMap.get({ \"someKey\" : \"someValue\" }); // 결과는 정의되지 않습니다\nmyFirstMap.get(myObject); // 결과는 'value'를 반환합니다\n```\n\n<div class=\"content-ad\"></div>\n\n# JavaScript Maps 병합하기\n\n여러 맵을 하나로 병합하려면, 객체를 병합하는 방식과 마찬가지로 스프레드 구문을 사용하여 병합할 수 있습니다. 예를 들어, 여기서는 spread 구문을 사용하여 myFirstMap과 mySecondMap을 myNewMap으로 병합합니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nlet mySecondMap = new Map();\nmySecondMap.set(\"someOther\", \"value\");\nlet myNewMap = new Map([...myFirstMap, ...mySecondMap]);\nconsole.log(myNewMap);\n// Map(2) { some: \"value\", someOther: \"value\" }\n```\n\n# 맵(Map)에서 반복하기\n\n<div class=\"content-ad\"></div>\n\n맵은 기본적으로 Iterable 합니다. 객체를 반복하려면 보통 Object.keys와 같은 함수를 사용해야 합니다. 결국, 우리는 다음과 같이 모든 맵에서 forEach를 사용할 수 있습니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.forEach(function(value, key, map) {\n    // value -> 맵에서 키의 값\n    // key -> 맵 안의 항목의 키\n    // map -> 전체 맵\n    console.log(value, key, map);\n})\n```\n\n# JavaScript Map에서 for를 사용한 반복\n\n또한 for(let ... of )을 사용하여 맵을 반복할 수도 있습니다! 이렇게 하면 각 항목이 키와 값의 배열로 반환됩니다. 예를 들어:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nfor(let x of myFirstMap) {\n    // Returns [ 'some', 'value' ]\n    console.log(x);\n}\n```\n\n# JavaScript Map에서 값 또는 키를 순회하기\n\nJavaScript에서 값 또는 키를 순회하는 또 다른 멋진 방법은 values() 또는 entries() 메서드를 사용하는 것입니다. 이들 메서드는 각각 map의 값과 항목에 대한 새로운 반복자를 반환합니다. 이는 생성기 함수에서와 마찬가지로 next() 함수를 사용하여 다음 키 또는 값을 액세스할 수 있다는 것을 의미합니다.\n\n예를 들어, entries()가 어떻게 작동하는지 살펴보겠습니다:\n\n\n\n<div class=\"content-ad\"></div>\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\nlet allKeys = myFirstMap.entries();\nconsole.log(allKeys); // MapIterator {} 객체를 반환합니다\nconsole.log(allKeys.next()); // { value: [ 'some', 'value' ], done: false }를 반환합니다\nconsole.log(allKeys.next().value); // [ 'some', 'value' ]를 반환합니다\n```\n\nallKeys.next()에서 반환된 것은 객체입니다. 이 객체 안의 값은 [ `some`, `value` ] 입니다 - 맵의 첫 번째 항목을 나타내는 배열입니다. 계속해서 next()를 실행하여 맵의 다음 항목들을 얻을 수 있습니다. 정말 멋집니다! 값으로만 이 작업을 다시 할 수도 있습니다.\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\nlet allValues = myFirstMap.values();\nconsole.log(allValues); // MapIterator {} 객체를 반환합니다\nconsole.log(allValues.next()); // { value: 'value', done: false }를 반환합니다\nconsole.log(allValues.next().value); // 'value'를 반환합니다\n```\n\n이러한 이터레이터들은 특정 상황에서 유용하며 맵에 있는 모든 데이터를 반복하는 멋진 방법이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 자바스크립트에서 맵의 직렬화\n\n맵의 한 가지 단점은 JSON.parse() 및 JSON.stringify로 쉽게 직렬화할 수 없다는 점입니다. 이를 시도하면 비어 있는 객체가 반환되는데, 이는 맵의 객체가 항목으로만 채워졌을 때 비어 있기 때문에 어느 정도 이해됩니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\n// Returns {}\nconsole.log(JSON.stringify(myFirstMap));\n```\n\n맵을 직렬화하는 유일한 현실적인 방법은 객체나 배열로 변환한 후에 직렬화하는 것이며, 이를 위해 맵을 사용한다면 이 작업을 수행해주는 별도의 도우미 함수를 유지해야 합니다. 예를 들어, Array.from()을 사용하여 우리의 맵을 배열로 변환한 다음 JSON.stringify()를 사용하여 직렬화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\nlet arrayMap = Array.from(myFirstMap);\n// Returns [[\"some\",\"value\"],[\"someOther\",\"value\"],[\"aFinal\",\"value\"]]\nconsole.log(JSON.stringify(arrayMap));\n```\n\n그런 다음, 다시 Map으로 변환하려면 JSON.parse()를 사용하여 new Map()과 함께 사용해야합니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\n// Map을 배열로 변환\nlet arrayMap = Array.from(myFirstMap);\n// Map의 JSON 문자열 버전:\nlet stringifiedMap = JSON.stringify(arrayMap);\n// 다시 Map으로 변환하려면 new Map(JSON.parse...)를 사용하세요:\nlet getMap = new Map(JSON.parse(stringifiedMap));\n// Map(3) {'some' => 'value', 'someOther' => 'value', 'aFinal' => 'value'}를 반환\nconsole.log(getMap);\n```\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n자바스크립트 Maps는 객체의 모든 유연성이 필요하지 않을 때 데이터를 저장하는 훌륭한 방법입니다. 데이터의 순서가 굉장히 중요한 상황에서는 객체보다 성능이 우수합니다. 아이템을 자주 추가하거나 제거해야 하는 상황에서도 객체보다 효율적입니다. 이 안내서에서는 Maps에 대해 알아야 할 모든 것을 다뤘지만, 자바스크립트에 대해 더 알고 싶다면 여기를 클릭해주세요.\n\n이 내용이 유익했기를 바라며, 즐거운 하루 보내세요.\n\nPlainEnglish.io에서 더 많은 콘텐츠를 만나보세요. 무료 주간 뉴스레터 구독 신청하세요. 트위터, 링크드인, 유튜브, 디스코드에서 팔로우하세요. 성장 해킹에 관심이 있다면 Circuit을 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide_0.png"},"coverImage":"/assets/img/2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"쉬운 125번 유효한 회문","description":"","date":"2024-06-20 02:36","slug":"2024-06-20-Easy125ValidPalindrome","content":"\n\nLeetCode 50 두 포인터\n\n# 예시\n\n## 예시 1\n\n```js\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\"는 회문입니다.\n```\n\n<div class=\"content-ad\"></div>\n\n## 예제 2\n\n```js\n입력: s = \"race a car\"\n출력: false\n설명: \"raceacar\"은 회문이 아닙니다.\n```\n\n## 예제 3\n\n```js\n입력: s = \" \"\n출력: true\n설명: 비어있는 문자열 \"\"은 알파벳이나 숫자가 아닌 문자를 제거한 후에 남는 문자열입니다. \n앞으로 읽거나 뒤로 읽어도 동일하기 때문에 회문입니다.\n```\n\n<div class=\"content-ad\"></div>\n\n# 해결책\n\n- 공간 복잡도: O( )\n- 시간 복잡도: O( )\n\n## 파이썬\n\n```js\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n\n        while left < right:\n            while left < right and not s[left].isalnum():\n                left += 1\n            \n            while left < right and not s[right].isalnum():\n                right -= 1\n            \n            if s[left].lower() != s[right].lower():\n                return False\n\n            left += 1\n            right -= 1\n        \n        return True\n```  \n\n<div class=\"content-ad\"></div>\n\n## TypeScript\n\n# Postscript\n\n## Python isalnum( )\n\n```js\ntxt1 = \"Company12\"\nprint(txt1.isalnum())  # 결과: True\n\ntxt2 = \"Company 12\"\nprint(txt2.isalnum())  # 결과: False\n\ntxt3 = \"Hello@World\"\nprint(txt3.isalnum())  # 결과: False\n\ntxt4 = \"HelloWorld\"\nprint(txt4.isalnum())  # 결과: True\n```\n\n<div class=\"content-ad\"></div>\n\n## 참고 자료\n\n1. https://github.com/TheExplainthis/LeetCodeJourney/","ogImage":{"url":"/assets/img/2024-06-20-Easy125ValidPalindrome_0.png"},"coverImage":"/assets/img/2024-06-20-Easy125ValidPalindrome_0.png","tag":["Tech"],"readingTime":2},{"title":"앵귤러에서 사전 인터페이스를 활용하여 동적 폼 생성하기","description":"","date":"2024-06-20 02:35","slug":"2024-06-20-HowtoCreateDynamicFormsinAngularUsingaDictionaryInterface","content":"\n\n\n![이미지](/assets/img/2024-06-20-HowtoCreateDynamicFormsinAngularUsingaDictionaryInterface_0.png)\n\n앵귤러에서 동적 폼을 생성하면 유연한 데이터 구조를 처리하는 강력한 방법이 될 수 있습니다. 특히 복잡하거나 중첩된 JSON 객체를 반환하는 API와 작업할 때 유용합니다. 이 기사에서는 Dictionary 인터페이스와 동적 폼 생성기 서비스를 사용하여 앵귤러에서 동적 폼을 생성하는 방법을 보여드리겠습니다.\n\n## Dictionary 인터페이스 정의하기\n\n먼저 Dictionary 인터페이스를 정의해봅시다. 이 인터페이스를 사용하면 문자열 또는 중첩된 사전을 포함할 수 있는 재귀 형식을 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\nexport interface Dictionary {\n  [key: string]: string | Dictionary;\n}\n```\n\n## 동적 폼 생성기 서비스 만들기\n\n다음으로, 딕셔너리의 구조에 기반하여 폼 컨트롤을 생성할 수 있는 서비스가 필요합니다. 이 서비스는 중첩된 딕셔너리에 대해 재귀적으로 폼 그룹을 생성하고 문자열 값에 대해 폼 컨트롤을 만들 것입니다.\n\n다음은 DynamicFormGeneratorService입니다:\n\n<div class=\"content-ad\"></div>\n\n```ts\n@Injectable({\n  providedIn: 'root',\n})\nexport class DynamicFormGeneratorService {\n  #fb = inject(FormBuilder);\n\n  createForm(data: Dictionary): FormGroup {\n    const formControls = this.createControls(data);\n    return this.#fb.group(formControls);\n  }\n\n  private createControls(data: Dictionary): { [key: string]: AbstractControl } {\n    return Object.keys(data).reduce((controls, key) => {\n      if (typeof data[key] === 'object' && data[key] !== null) {\n        controls[key] = this.#fb.group(this.createControls(data[key] as Dictionary));\n      } else {\n        controls[key] = new FormControl(data[key] as string, Validators.required);\n      }\n      return controls;\n    }, {} as { [key: string]: AbstractControl });\n  }\n}\n```\n\n## 동적 폼 그룹 컴포넌트 생성\n\n이제, 이 서비스를 사용하여 사전 데이터를 기반으로 폼을 생성하는 컴포넌트를 생성해 봅시다. 이 컴포넌트는 폼을 랜더링하고 폼 제출을 처리하는 역할을 담당할 것입니다.\n\n다음은 DynamicFormGroupComponent의 TypeScript 코드입니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n  selector: 'app-dynamic-form-group',\n  standalone: true,\n  imports: [ReactiveFormsModule],\n  templateUrl: './dynamic-form-group.component.html',\n})\nexport class DynamicFormGroupComponent implements OnInit {\n  @Output() formValues = new EventEmitter<Dictionary>();\n  @Input() initialData?: Dictionary;\n  @Input() formGroup: FormGroup = new FormGroup({});\n\n  #dynamicFormService = inject(DynamicFormGeneratorService);\n  objectKeys = Object.keys;\n\n  ngOnInit(): void {\n    if (this.initialData) {\n      this.formGroup = this.#dynamicFormService.createForm(this.initialData);\n    }\n  }\n\n  onSubmit(): void {\n    if (!this.initialData || this.formGroup.invalid) return;\n    this.formValues.emit(this.formGroup.value);\n  }\n\n  isGroup(control: AbstractControl | null): control is FormGroup {\n    return control instanceof FormGroup;\n  }\n\n  getFormGroup(control: AbstractControl | null): FormGroup {\n    return control as FormGroup;\n  }\n}\n```\n\n그리고 해당하는 HTML 템플릿:\n\n```js\n<form\n  [formGroup]=\"formGroup\"\n  class=\"p-6 bg-indigo-50 border border-red-200 rounded-lg shadow-sm space-y-4\"\n>\n  <!-- 이 루프는 formGroup.controls 객체의 키를 반복합니다. -->\n  <!-- 각 키는 폼 컨트롤이나 중첩된 폼 그룹을 나타냅니다. -->\n  <ng-container *ngFor=\"let key of objectKeys(formGroup.controls)\">\n    <!-- 현재 폼 컨트롤이 FormGroup인지 확인하는 조건문입니다. -->\n    <ng-container *ngIf=\"isGroup(formGroup.get(key)); else singleControl\">\n      <!-- 그것이 FormGroup이면, 해당하는 필드셋이 생성됩니다. -->\n      <fieldset\n        [formGroupName]=\"key\"\n        class=\"border border-gray-300 rounded-lg p-4 bg-white\"\n      >\n        <legend class=\"text-lg font-semibold text-gray-700 mb-2\">{ key }</legend>\n\n        <!-- 중첩된 FormGroup은 formGroup 입력 프로퍼티를 사용하여 컴포넌트에 전달됩니다. -->\n        <app-dynamic-form-group\n          [formGroup]=\"getFormGroup(formGroup.get(key))\"\n        ></app-dynamic-form-group>\n      </fieldset>\n    </ng-container>\n    <ng-template #singleControl>\n      <!-- 현재 폼 컨트롤이 FormGroup가 아닌 경우, 해당하는 입력 필드가 생성됩니다. -->\n      <!-- formControlName 지시문은 이 입력 필드를 해당 폼 컨트롤과 연결합니다. -->\n      <div class=\"flex flex-col space-y-2\">\n        <label [for]=\"key\" class=\"text-sm font-medium text-gray-600\">{ key }</label>\n        <input\n          [formControlName]=\"key\"\n          id=\"{ key }\"\n          class=\"p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500\"\n        />\n      </div>\n    </ng-template>\n  </ng-container>\n\n  <!-- initialData가 있는지 확인하고 있으면 제출 버튼을 추가합니다. -->\n  <button\n    *ngIf=\"initialData\"\n    (click)=\"onSubmit()\"\n    [disabled]=\"formGroup.invalid\"\n    class=\"bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 disabled:opacity-50 disabled:cursor-not-allowed\"\n  >\n    제출\n  </button>\n</form>\n```\n\n# 모두 함께 넣어보기\n\n\n<div class=\"content-ad\"></div>\n\n이 동적 양식을 애플리케이션에서 사용하려면 일반적으로 사전 데이터를 제공하고 양식 제출을 처리하는 부모 구성 요소가 있는 것이 일반적입니다:\n\n```js\nexport class AppComponent {\n  title = 'dynamic-forms';\n\n  onFormValues(values: Dictionary) {\n    console.table(values);\n  }\n\n  contract: Dictionary = {\n    contractId: 'C12345',\n    contractType: 'Employment',\n    startDate: '2024-01-01',\n    endDate: '2025-01-01',\n    employer: {\n      name: 'Tech Corp Inc.',\n      address: '456 Technology Drive, Silicon Valley, USA',\n      contact: {\n        phone: '555-1234',\n        email: 'hr@techcorp.com',\n      },\n    },\n\n    jobDetails: {\n      jobTitle: 'Senior Developer',\n      jobDescription:\n        'Responsible for developing and maintaining web applications.',\n      salary: '75000',\n      benefits: 'Health, Dental, Vision',\n    },\n  };\n}\n```\n\n# 미리보기\n\n<img src=\"/assets/img/2024-06-20-HowtoCreateDynamicFormsinAngularUsingaDictionaryInterface_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 기사에서는 Angular를 사용하여 사전 인터페이스를 활용해 동적 양식을 생성하는 방법을 보여드렸습니다. Angular의 반응형 폼과 재귀적 접근을 활용하여 복잡한 형식을 생성하고 모든 데이터 구조에 적응할 수 있습니다. 이 방법은 특히 API에서 동적 데이터를 처리하고 유연한 폼 구성 요소를 생성하는 데 유용합니다.\n\n더 많은 Angular 팁과 트릭을 기대해 주세요! 👨‍💻\n\n이 기사를 즐겼고 연결하고 싶다면 LinkedIn에서 저를 팔로우해 주세요.\n\n<div class=\"content-ad\"></div>\n\n# 스택데미크 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Differ\n- 스택데미크 닷컴에서 더 많은 컨텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-20-HowtoCreateDynamicFormsinAngularUsingaDictionaryInterface_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoCreateDynamicFormsinAngularUsingaDictionaryInterface_0.png","tag":["Tech"],"readingTime":6},{"title":"타입스크립트 세금","description":"","date":"2024-06-20 02:30","slug":"2024-06-20-TheTypeScriptTax","content":"\n\n## 비용 대 수익 분석\n\n![이미지](/assets/img/2024-06-20-TheTypeScriptTax_0.png)\n\nTypeScript는 2017년부터 2019년까지 크게 성장했으며 여러 가지 면에서 그렇게 한 것이 타당합니다. TypeScript를 애용하는 이유가 많습니다. 2018년 JavaScript의 상태 조사에서 응답자의 거의 절반은 TypeScript를 시도해보고 다시 사용할 의향이 있다고 말했습니다. 그러나 대규모 앱 개발 프로젝트에 사용해야 할까요?\n\n본 문서는 TypeScript를 사용하여 대규모 애플리케이션을 구축하는 데의 투자 수익률(ROI)을 분석하기 위해 좀 더 비판적이고 데이터 중심의 방식을 취합니다.\n\n<div class=\"content-ad\"></div>\n\n# TypeScript 성장\n\nTypeScript는 가장 빠르게 성장하는 언어 중 하나이며 현재는 JavaScript로 컴파일하는 언어 중 선두를 유지하고 있어요.\n\n![TheTypeScriptTax_1](/assets/img/2024-06-20-TheTypeScriptTax_1.png)\n\n![TheTypeScriptTax_2](/assets/img/2024-06-20-TheTypeScriptTax_2.png)\n\n<div class=\"content-ad\"></div>\n\n이 높은 추세는 무시해서는 안 될만큼 인상적하지만, 전체적인 JavaScript 생태계를 지배하고 있는 것으로는 아직까지 거리가 멀어요. 이것은 훨씬 더 큰 바다 속에서 큰 물결과 같다고 말할 수 있을 것 같아요.\n\n![이미지1](/assets/img/2024-06-20-TheTypeScriptTax_3.png)\n\n![이미지2](/assets/img/2024-06-20-TheTypeScriptTax_4.png)\n\n그렇지만, TypeScript는 2018년에 전환점에 다다르고, 2019년에 많은 제작 프로젝트들이 사용할 것으로 예상됩니다. JavaScript 개발자로서, 선택의 여지가 없을 수도 있어요. TypeScript 결정은 당신 대신에 이뤄질 것이며, 배우고 사용하는 데 두려워하지 말아야 해요.\n\n<div class=\"content-ad\"></div>\n\n그러나 그것을 사용할지 여부를 결정하는 위치에 있다면, 혜택과 비용에 대한 현실적인 이해가 필요합니다. 그것이 긍정적인 영향을 줄까요, 부정적인 영향을 줄까요?\n\n내 경험 상, 둘 다 가지고 있지만 긍정적인 ROI에 미치지 못합니다. 많은 개발자들이 TypeScript를 좋아하며, TypeScript 개발 경험의 여러 측면을 진심으로 즐기는 부분이 많습니다. 그러나 이 모든 것에는 비용이 따릅니다.\n\n# 배경\n\n저는 C/C++ 및 Java와 같은 정적 타입 언어를 사용하는 배경을 가지고 있습니다. JavaScript의 동적 타입은 처음에는 적응하기 어려웠지만, 익숙해지면 긴 어두운 터널을 벗어나 빛 안으로 들어온 것처럼 느껴졌습니다. 정적 타입에 대해 좋아할 점이 많지만, 동적 타입에 대해서도 많이 좋아합니다.\n\n<div class=\"content-ad\"></div>\n\n지난 몇 년 동안, TypeScript에 전적으로 몰두하다가 경험을 쌓아왔습니다. TypeScript를 사용하여 대규모 프로덕션 팀을 이끌며 TypeScript의 다양한 프로젝트에 대한 영향과 비교를 볼 수 있었습니다.\n\n2018년에는 탈중앙화 애플리케이션이 부상했고 대부분의 경우 스마트 계약과 오픈 소스 소프트웨어를 사용하게 되었습니다. 가치 있는 인터넷을 다룰 때 버그는 사용자에게 비용을 치르게 할 수 있습니다. 신뢰할 수 있는 코드를 작성하는 것이 더 중요해졌고, 이러한 프로젝트들이 일반적으로 오픈 소스로 공개되어 있기 때문에 TypeScript로 코드를 개발하여 다른 TypeScript 팀이 통합하기 쉽도록 만든 것이 좋다고 생각했습니다. 동시에 JavaScript를 사용하는 프로젝트와의 호환성도 유지되었습니다.\n\n최근 TypeScript에 대한 이해도가 깊어졌습니다. TypeScript의 장단점을 보다 명확하게 파악했습니다. 제 기대와는 달리 성공적이지 못했다는 점이 안타깝지만, 향후 TypeScript를 큰 규모 프로젝트에 선택하지 않을 것입니다.\n\n## TypeScript에 대한 저의 애정한 점\n\n<div class=\"content-ad\"></div>\n\n저는 TypeScript에 대해 여전히 장기적으로 긍정적인 마음을 갖고 있습니다. TypeScript를 좋아하고 있으며, 아직도 TypeScript에 대해 많이 사랑하는 부분이 많습니다. TypeScript 개발자와 지지자들이 이 글을 적극적인 비판으로 보는 것이 아니라 적대적인 비난으로 받아들이지 않기를 바랍니다. TypeScript 개발자들은 몇 가지 문제를 해결할 수 있고, 그들이 그렇게 한다면 ROI 분석을 반복해 다른 결과에 도달할 수도 있습니다.\n\n정적 타입은 함수를 문서화하고 사용 방법을 명확히 하며 인식적 부담을 줄이는 데 매우 유용할 수 있습니다. 예를 들어, Haskell의 타입은 보통 도움이 되고 비용 효율적이며 무해하며 방해되지 않는다고 생각합니다. 그러나 때로는 Haskell의 유연한 하이어캌드 타입 시스템조차 방해가 되기도 합니다. Haskell (또는 TypeScript)에서 변환자를 타이핑해 보세요. 쉽지 않고 아마도 무타입 등가물 보다 조금 더 어려울 것입니다.\n\nTypeScript에서 타입 어노테이션은 방해되는 경우 선택 사항으로 사용될 수 있다는 것을 좋아하고 있으며, TypeScript가 구조적 타이핑을 사용하고 타입 추론을 일부 지원한다는 점을 사랑합니다 (추론에 대한 개선 여지가 많이 있지만). \n\nTypeScript는 사용자 정의 타입을 지원하는데, 이는 재사용 가능한(인라인이 아닌) 타입이며 다양한 방식으로 API와 함수 시그니처를 주석 처리하는데 적용할 수 있는 것입니다. 하나의 인터페이스에는 많은 구현체가 있을 수 있습니다. 인터페이스는 TypeScript의 가장 좋은 기능 중 하나이며, 이 기능이 JavaScript에 내장되어 있는 것을 바라곤 합니다.\n\n<div class=\"content-ad\"></div>\n\n가장 좋은 뉴스: Atom이나 Visual Studio Code와 같은 잘 지원되는 편집기를 사용한다면, 내 의견으로는 TypeScript의 편집기 플러그인은 자바스크립트 생태계에서 최고의 IDE 개발자 경험을 제공합니다. 다른 플러그인 개발자들은 이를 시도하고 개선 방법에 대해 메모해 보아야 합니다.\n\n# 숫자로 보는 TypeScript의 ROI\n\n대규모 응용 프로그램에 적합한지 여부를 보다 잘 이해하기 위해 몇 가지 차원에서 TypeScript를 -10부터 10까지의 척도로 평가할 것입니다.\n\n0보다 큰 수는 긍정적인 영향을 나타냅니다. 0보다 작은 수는 부정적인 영향을 나타냅니다. 3-5점은 상대적으로 강한 영향을 나타내며, 2점은 중간 영향을 나타냅니다. 1점은 비교적 낮은 영향을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n이 숫자들은 정확하게 측정하기 어려우며 다소 주관적일 수 있지만, 실제 프로젝트에서 관찰된 비용 및 보상을 반영하기 위해 최선을 다한 것으로 추정했습니다.\n\n영향력이 평가된 모든 프로젝트는 `50k LOC`이며, 여러 명의 협업자가 여러 달 동안 작업한 프로젝트입니다. 하나의 프로젝트는 Angular 2 + TypeScript로 작성된 프로젝트로, 기존 JavaScript를 사용한 Angular 1로 작성된 유사한 프로젝트와 비교되었습니다. 다른 모든 프로젝트는 React와 Node로 작성되었으며, 일반 JavaScript로 작성된 React/Node 프로젝트와 비교되었습니다. 주관적인 버그 발생률, 상대적인 속도, 개발자 피드백은 추정되었지만 정확하게 측정되지 않았습니다. 모든 팀에는 경험 많은 TypeScript 개발자와 신입 TypeScript 개발자가 혼합되어 있었으며, 모든 팀원은 TypeScript 온보딩을 돕기 위해 더 경험 많은 멘토에게 접근할 수 있었습니다.\n\n작은 샘플링된 프로젝트의 객관적 데이터는 신뢰할 수 있는 오차 범위 내에서 명확한 객관적 판단을 내리기 어려웠습니다. 하나의 프로젝트에서 원시 JavaScript는 TypeScript보다 41% 낮은 공개 버그 발생률을 보여주었습니다. 다른 한 프로젝트에서는 TypeScript 프로젝트가 해당 네이티브 JavaScript 버전보다 4% 낮은 버그 발생률을 보여주었습니다. 분명히 다른 품질 측정 항목들의 구현(또는 부재)이 TypeScript보다 훨씬 강력한 영향을 미쳐 사용성을 뛰어넘는 수치를 왜곡시켰습니다.\n\n오차 범위가 너무 넓어서 객관적인 양적 측정을 포기하고 대신 기능 전달 속도 및 시간 사용 내역에 초점을 맞추었습니다. ROI를 점별로 상세하게 분석한 내용을 확인하실 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n주관적인 요소가 많기 때문에 해석의 여지에 오차를 허용해야 합니다(차트에 표현됨), 하지만 전체적인 ROI(투자수익률) 균형은 예상할 수 있는 것을 잘 보여줄 것입니다.\n\n이 작은 혜택 점수들에 대한 피너쥐 의견 반박을 이미 듣고 있네요, 그러나 전적으로 그 주장에 동의하지는 않습니다. TypeScript는 매우 유용하고 강력한 기능을 제공합니다. 그 부분에 대해서는 의문의 여지가 없습니다.\n\n작은 혜택 점수를 이해하기 위해서 TypeScript와 비교할 때 무엇을 고려해야 하는지 잘 알아야 합니다: JavaScript만이 아니라 JavaScript와 함께 사용되는 원시 JavaScript용 도구들까지를 비교하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n자세히 살펴보겠습니다.\n\n개발 도구: TypeScript의 내가 가장 좋아하는 기능 중 하나이자 아마도 TypeScript를 사용하는 가장 강력한 현실적인 혜택은 TypeScript가 인터페이스 유형 힌트를 제공하고 프로그래밍 중에 잠재적인 오류를 실시간으로 잡아내어 개발자의 인지 부하를 줄여준다는 점입니다. 일부 좋은 플러그인과 함께 원시 JavaScript에서 그것들 중 하나도 가능하지 않았다면 TypeScript에 더 많은 혜택을 주겠지만, JavaScript를 사용하는 것만으로도 가능한 기능은 0 점이며, 시작점이 이미 꽤 좋은 편입니다.\n\n대부분의 TypeScript 지지자들은 TypeScript가 무엇과 경쟁하는지 제대로 이해하지 못하는 것 같습니다. 개발 도구 선택은 TypeScript vs 원시 JavaScript와 도구 없음이 아니라 TypeScript와 전체적인 JavaScript 개발 도구 생태계 전체의 비교입니다. 원시 JavaScript 자동완성 및 오류 감지는 자동완성, 유형 추론 및 린트 도구를 사용할 때 TypeScript의 혜택의 80% - 90%를 제공합니다. 유형 추론을 실행하고 ES6 기본 매개변수를 사용할 때는 TypeScript 코드와 같이 유형 힌트를 얻습니다.\n\n![이미지](/assets/img/2024-06-20-TheTypeScriptTax_6.png)\n\n<div class=\"content-ad\"></div>\n\n공정하게 말하자면, TypeScript 코드의 주석을 제공하기 위해 기본 매개변수를 사용하면 TypeScript 코드에 대한 주석을 제공할 필요가 없게 됩니다. 이는 TypeScript를 사용하는 데 발생하는 오버헤드 중 하나인 타입 구문 부담을 줄이는 훌륭한 방법입니다.\n\nTypeScript의 이러한 기능에 대한 도구는 아마도 조금 더 나은데, 모든 것이 한 곳에 모아져 있습니다. 하지만 이것만으로는 비용을 합당화할만큼 충분하지는 않습니다.\n\nAPI 문서: TypeScript의 또 다른 큰 장점은 항상 소스 코드와 동기화되는 API에 대한 더 나은 문서입니다. TypeScript 코드에서 심지어 API 문서를 생성할 수도 있습니다. 이는 JSDoc와 Tern.js를 JavaScript에서 사용하여 동일한 이점을 얻을 수 있으며, 문서 생성기가 풍부합니다. 개인적으로 JSDoc를 좋아하지는 않지만, TypeScript는 여기서 몇 가지 우위성을 얻습니다.\n\n실제로 최고의 인라인 문서 작성이 있어도 여전히 실제 문서가 필요하므로, TypeScript는 기존 문서 옵션을 대체하는 것이 아니라 더 나은 옵션을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n리팩터링. 대부분의 경우에 TypeScript를 사용하여 리팩터링에서 상당한 이점을 얻을 수 있다면, 당신의 코드가 너무 강하게 결합되어 있다는 것을 나타내는 코드 스멜일 가능성이 높습니다. 저는 더 많은 조립 가능하고, 더 튼튼하게 결합되지 않은 코드를 작성하는 방법에 대해 전체적인 책을 썼습니다. “Composing Software” 라는 책입니다. TypeScript가 당신에게 많은 리팩터링 고통을 덜어 주고 있다면, 강하게 결합된 것이 여전히 피할 수 있는 다른 문제들을 많이 유발하고 있는 가능성이 높습니다. 반드시 그 책을 읽을 것을 적극 추천합니다, 특히 “Mocking is a Code Smell“이라는 챕터는 강하게 결합된 원인과 그것을 피하는 데 도움이 되는 여러 가지 모범 사례들에 대해 많은 정보를 제공합니다.\n\n반면에, 일부 기업은 매우 큰 생태계를 운영하며 연결된 프로젝트들이 동일한 코드 저장소를 공유하고 있는 경우가 있습니다 (예: Google의 유명한 monorepo). TypeScript를 사용하면 그들은 API 디자인 선택들을 업그레이드하여 더 나은 디자인 및 새로운 사용 사례를 고려할 수 있습니다. 해당 업그레이드 담당자들은 또한 그들의 라이브러리 변경이 monorepo에 의존하는 소프트웨어 중 어느 것도 깨뜨리지 않도록 확인하는 책임이 있습니다. TypeScript는 이 매우 제한된 TypeScript 사용자 하위 집합에게 상당한 시간 절약 기회를 제공할 수 있습니다.\n\n나는 매우 제한된 하위 집합이라고 말하는데, 거대하고 폐쇄적인 monorepo 생태계는 규칙보다는 예외입니다. 이 프로세스는 Google에서 규모가 있을 수 있지만, 라이브러리 작성자가 인식하지 못하는 저장소에는 규모가 불가능합니다. 더 넓은 생태계에서 라이브러리 API에 파괴적인 변경을 가하는 것은 알지 못하는 코드를 깨뜨릴 수 있습니다.\n\n전통적인, 더 분산화된 라이브러리 생태계에서, 사람들은 API에 파괴적인 변경을 피하고 대신 확장에 대한 Open/Close 원칙을 따르며 새로운 기능들을 만듭니다(API는 확장을 위해 열려 있고, 파괴적인 변경에 대해서는 닫혀 있습니다). 이것이 대부분의 경우 웹 플랫폼이 어떻게 발전해 왔는지를 보여줍니다, 몇 가지 예외를 제외하고요. 이것이 React가 여전히 React 0.14 이후로 더 좋은 옵션들로 대체되었음에도 지원하는 기능들을 유지하는 이유입니다. React는 계속 발전하고 훌륭한 새로운 기능들을 추가하여 개발 경험을 급격하게 개선하지만, 예를 들어 class components는 매우 개선된 React Hooks API가 확립 된 후에도 React에서 지원될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n생태계 전체에 변경을 가하는 것을 필수로 하는 대신 선택 사항으로 만들어줍니다. 팀은 전체 생태계 코드 변경 프로젝트를 라이브러리 팀에게 부담 주지 않고 필요에 따라 소프트웨어를 점진적으로 업그레이드할 수 있습니다.\n\n전체 생태계 코드 변경이 필요한 경우에도 유형 추론 및 자동 코드 변환 도구를 활용할 수 있어요. TypeScript가 필요하지 않습니다.\n\n처음에는 리팩터링에 대한 스코어를 0으로 잡고 목록에서 제외했으나 제가 열린/닫힌 접근 방식, 추론 및 코드 변환 방식을 강력하게 선호하기 때문입니다. 그러나 일부 팀은 특정한 상황 하에서 실제 혜택을 누리고 있습니다.\n\n네이티브 JavaScript를 사용하는 다른 방식이 더 나을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n타입 안전성은 큰 차이를 만들지 않는 것 같아요. TypeScript 지지자들은 자주 타입 안전성의 이점을 언급하지만, 실제로 타입 안전성이 제작 단계에서의 버그 밀도에 큰 영향을 주지 않는 것으로 나타났어요. (2022 연구에 따르면 TypeScript가 버그 감소에 큰 영향을 미치지 않는 증거가 더 많습니다). 이것은 코드 검토와 TDD가 (특히 TDD만으로 40% ~ 80%의 차이를 만들어냅니다) 매우 큰 영향을 미칩니다. 디자인 리뷰, 사양 리뷰, 코드 리뷰와 TDD를 결합하면 버그 밀도가 90% 이상 감소할 수 있어요. 이러한 프로세스의 많은 부분 (특히 TDD)은 TypeScript가 잡는 버그와 같은 종류의 모든 버그를 잡아내는 데 도움이 되며, TypeScript가 잡을 수 없는 많은 버그도 잡아낼 수 있어요.\n\nTypeScript는 \"공개 버그\"의 약 20% 정도를 다룰 수밖에 없는데, 공개란 버그가 구현 단계를 넘어서 공개 저장소에 커밋된 상태를 의미합니다. 이 정보는 영국 대학 (University College London)의 Zheng Gao와 Earl T. Barr, 그리고 Microsoft Research의 Christian Bird에 따라요.\n\n이 연구의 저자들은 TypeScript의 영향을 과소평가했다고 생각하는데, 다른 품질 측정이 이미 적용된 것으로 가정했지만 다른 버그 방지 조치의 품질을 판단하는 노력을 하지 않았어요. 이를 인정했지만 계산에서 전혀 고려하지 않았답니다.\n\n내 경험상 대부분의 팀은 일부 조치를 부분적으로 적용하지만 모든 중요한 버그 방지 조치를 충분히 적용하지 않아요. 우리 팀에서는 디자인 리뷰, 사양 리뷰, TDD, 코드 리뷰, 린트, 스키마 유효성 검사 및 회사에서 지원하는 지도를 활용해 버그 밀도에 뚜렷한 영향을 미치며, 타입 오류를 거의 제로로 줄일 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n내 경험상 린팅을 제외한 모든 것이 정적 타입보다 코드 품질에 더 큰 영향을 미칩니다. 다시 말해, 나는 논문의 저자들보다 훨씬 엄격한 '제로' 정의에서 시작하고 있어요.\n\n만약 다른 버그 예방 조치를 제대로 구현하지 않았다면, TypeScript만 사용해서 버그 밀도를 15%에서 18% 줄일 수 있을 거라는 확신은 있지만, 제품이 출시되어 현실적인 문제를 일으키기 시작할 때까지 80%의 버그를 완전히 감지하지 못할 거에요.\n\nTypeScript가 실시간 버그 피드백을 제공한다는 주장도 있겠지만, 타입 추론, 린트 및 TDD도 마찬가지로 버그를 더 일찍 잡을 수 있어요 (파일 저장 시에 유닛 테스트를 실행하는 watch 스크립트를 설정했기 때문에 거의 즉시 풍부한 피드백을 받아요). 이러한 다른 조치들이 비용이 든다는 이야기를 할 수 있지만, TypeScript가 항상 버그 80%를 놓치기 때문에 당연히 이런 조치들을 건너뛸 수 없으니, 비용은 ROI 수학의 양쪽에 적용되며 이미 고려되어 있어요.\n\n이 연구는 사전에 알려진 버그를 살펴보았고, 해당 버그를 수정하는 데 변경된 정확한 코드 라인도 포함되어 있었어요. 즉, 문제와 잠재적인 해결책이 타입 도입 전에 알려진 상태였습니다. 이는 사전에 해당 버그가 존재함을 알고 있더라도 TypeScript가 공개된 버그 중 85%를 검출하지 못했다는 것을 의미하며, 15%만 잡아냈다는 것을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n왜 TypeScript로는 많은 버그를 감지할 수 없을까요? 우선, GitHub에서 연구된 공개 분류된 버그 중 약 78%가 사양 오류로 인한 것이었습니다. 행동을 올바르게 지정하지 않거나 사양을 올바르게 구현하지 못한 실패는 가장 흔한 버그 유형이며, 이 사실은 TypeScript로 감지하거나 예방할 수 있는 대다수의 버그를 자동으로 불가능하게 만듭니다. \"To Type or Not to Type\"에서 연구 저자들은 \"ts-undetectable\" 버그 범주를 식별하고 분류했습니다.\n\n위의 \"StringError\"는 문자열이 올바른 유형인데도 잘못된 값(예: 잘못된 URL)을 포함한 오류의 분류입니다. 브랜치 오류와 술어 오류는 잘못된 코드 경로를 사용하게 만드는 논리 오류입니다. TypeScript가 다뤄야 할 수 없는 다양한 기타 오류가 있음을 볼 수 있습니다. TypeScript가 버그의 20% 이상을 감지할 수 있을 가능성은 적습니다.\n\n하지만 20%는 꽤 많이 들리죠! TypeScript가 왜 더 높은 버그 예방 점수를 얻지 못할까요?\n\n<div class=\"content-ad\"></div>\n\n정적 유형으로 감지할 수 없는 많은 버그가 있기 때문에 디자인 검토, 명세 검토, 코드 검토 및 TDD와 같은 기타 품질 관리 수단을 건너 뛰는 것은 책임감이 없을 수 있습니다. 따라서 TypeScript가 버그를 방지하는 데 사용되는 유일한 도구일 것으로 가정하는 것은 공정하지 않습니다. 실제 ROI를 파악하려면 연구 저자들이 충분히 고려하지 않은 다른 수단으로 발견된 버그를 할인한 후 버그 감소 수학을 적용해야 합니다.\n\n![image](/assets/img/2024-06-20-TheTypeScriptTax_8.png)\n\n만약 프로젝트에 버그 방지 수단이 없었다면 1,000개의 버그가 있었을 것으로 상상해보세요. 다른 품질 조치를 적용한 뒤 잠재적인 프로덕션 버그 카운트가 100으로 감소했습니다. 이제 TypeScript가 추가적으로 얼마나 많은 버그를 방지했는지를 살펴보아 TypeScript 투자의 버그 발견 ROI를 더 진정한 의미로 살펴볼 수 있습니다. 버그의 거의 80%가 TypeScript로 감지할 수 없으며, 모든 TypeScript 감지 가능한 버그는 TDD와 같은 다른 수단으로 잠재적으로 발견될 수 있습니다.\n\n- 수단 없음: 1,000개의 버그\n- 다른 수단 적용 후: 100개의 버그 남음 — 900개의 버그 발견\n- TypeScript를 다른 수단에 추가한 후: 80개의 버그 남음 — 추가 20개의 버그 발견\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-TheTypeScriptTax_9.png)\n\n일부 사람들은 정적 타입이 있다면 많은 테스트를 작성할 필요가 없다고 말합니다. 이들은 어리석은 주장을 하는 중입니다. 정말 아무 대결도 아닙니다. TypeScript를 사용하더라도 다른 조치들이 필요합니다.\n\n![이미지](/assets/img/2024-06-20-TheTypeScriptTax_10.png)\n\n이 시나리오에서 리뷰 및 TDD를 통해 TypeScript 없이 1,000개 중 900개의 버그를 잡을 수 있습니다. TypeScript는 리뷰와 TDD를 건너뛰면 1,000개 중 200개의 버그를 잡아냅니다. 당연히 둘 중 하나를 선택할 필요는 없지만, 다른 조치들을 적용한 후 TypeScript를 추가하면 기하급수적으로 감소하는 결과로 인해 매우 작은 개선이 이루어집니다.\n\n\n<div class=\"content-ad\"></div>\n\n업데이트: 2019년 2월 11일:\n\n에어비앤비가 최근 TypeScript를 개발 프로세스에 추가하여 버그를 38% 줄였다고 보고했습니다. 이게 어떻게 가능할까요? 이 기사에 따르면 그건 불가능한 일이죠, 맞나요? 숫자 학산이 아니에요. 우리는 백분율, 평균, 그리고 감소하는 수익에 관해 다루고 있어요, 구체적인 값들은 아니죠.\n\n이 기사가 의존하는 연구에서는 평균을 대표하고 있으며, 다른 품질 측정의 존재나 결여가 TypeScript가 해결할 수 있는 잔여 버그의 백분율에 영향을 줍니다.\n\n다른 측정이 해결하는 ts-감지할 수 없는 버그가 많아지면 TypeScript가 처리할 수 있는 잔여 버그의 백분율도 높아지지만, 그 다른 측정들은 또한 TypeScript가 처리해야 할 잔여 버그의 총 수치를 줄여줍니다. 따라서 백분율은 올라갈 수 있지만, 잡히는 버그의 총 수치는 거의 변하지 않을 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n또한, 주의 깊은 코드 리뷰는 버그를 발견하고 줄이는 데 탁월한 역할을 합니다. 전체 코드베이스를 완전히 재검토하는 것만큼 주의 깊은 코드 리뷰는 없습니다. 모든 코드 라인을 주의 깊게 검사하고 분석함으로써 나타나는 결과를 보면, 그로부터 약 30%의 버그 감소가 기대됩니다. 단독 이러한 작업만으로도 (JavaScript로 남겨두었을지라도) 타입과는 무관하게 버그가 줄어들 것으로 예상됩니다.\n\n현재로서는 높은 확률로 방식을 공개하지 않았으며 그들이 사용하는 다른 버그 감소 방안에 대해 보고하지 않았으나, 나는 코드에 들어가기 전 사양 설명 검토 프로세스의 형태를 사용하여 코드로 전이되는 사양 버그의 비율을 줄이고 있다고 추측하고 있습니다.\n\n다른 말로 하면, TypeScript로 해결할 수 없는 많은 버그를 제거할 때 TypeScript는 남아있는 버그에 대해 더 높은 비율의 버그 감소를 제공할 수 있습니다.\n\n이 결과는 TypeScript로 해결할 수 있는 공개 버그의 20%만이 실제로 해결될 수 있다는 사실을 변경하지 않으며, 지수적으로 감소하는 수익에 대한 주장을 무효화하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n에어비앤비는 디자인 또는 사양 검토와 함께 자동화된 코드 커버리지가 평균 이상일 수 있다는 것을 시사합니다. 아마도 단위 테스트 커버리지나 기능 테스트 커버리지 중 하나라도 빠진, 즉 높지 않은 자동 코드 커버리지를 가지고 있을 수 있습니다. 적절한 단위 테스트 커버리지를 가지면 정적 타입이 잡을 수 있는 버그의 거의 100%를 포함하여 TypeScript로 잡을 수 없는 많은 버그를 잡을 수 있습니다.\n\n대부분의 팀은 거의 또는 전혀 구현된 디자인/사양 검토 프로세스가 없습니다. 엔지니어가 개발자에게 전달하기 전에 모델링을 비판적으로 검토하는 것만으로도 평균 이상일 것입니다. 많은 팀은 전혀 공식적인 디자인 검토 프로세스가 없습니다.\n\n아래는 그들의 TypeScript 이점 차트가 어떻게 보일지에 대한 예시입니다:\n\n![이미지](/assets/img/2024-06-20-TheTypeScriptTax_11.png)\n\n<div class=\"content-ad\"></div>\n\nTypeScript는 여전히 1,000개 중 38개의 잠재적 버그만을 잡아내지만, 대부분의 잠재적 버그는 TypeScript보다 이전 단계에서(예를 들어 모형을 개발자가 적용하기 전에 검토하는 사람들 등) 잡힐 수 있기 때문에 TypeScript는 남은 버그의 큰 부분을 처리할 수 있습니다. 이 경우, Airbnb의 추가 코드 품질 조치를 놓친 팀들보다 18개의 버그가 더 발견되었어요.\n\n점차적인 반환 수치의 수학적 분석은 TypeScript가 모든 버그 중 훨씬 더 많은 비율을 잡아낼 수 있는 경우에만 완전히 무효화될 수 있습니다: 약 75% 이상까지, 그 단계에서 다른 비용이 많이 드는 품질 관리 프로세스 부분이나 코드 리뷰 또는 TDD를 대체할 수 있을 수도 있습니다.\n\nTypeScript로 전환하면서 Airbnb가 정확히 몇 개의 버그를 잡았는지, TypeScript가 막지 못한 버그의 분류를 배우는 것, 버그 밀도(그리고 어떻게 계산했는지), 그리고 이미 적용하고 있는 다른 품질 관리 조치에 대해 배울 수 있다면 흥미로울 것입니다.\n\n수백만 달러 규모의 대규모 개발 프로젝트에 품질 관리 시스템을 구현한 경험으로 보면, 비용이 많이 드는 시스템 구현의 효율성에 대한 내 기대는 30% ~ 80%의 감소라는 영역에 있습니다. 이러한 종류의 숫자들은 다음 중 어느 것이든 얻을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 디자인 및 명세 검토 (최대 80% 감소)\n- TDD (남은 버그의 40-80% 감소)\n- 코드 검토 (코드 검토 1시간 당 유지보수 시간 33시간 감소)\n\n결과가 명확하게 나타나는데, 타입 오류는 가능한 버그의 작은 부분에 불과하며, 타입 오류를 잡는 다른 방법들도 있습니다. TypeScript가 버그로부터 당신을 보호해주지는 않는다는 것이 밝혀졌습니다. 최상의 경우, 아주 조금의 감소만 얻을 수 있을 뿐이며, 여전히 모든 품질 측정이 필요합니다.\n\nTypeScript의 혜택이 별로 크지 않다는 것 같습니다. 하지만 이것만큼의 혜택이 없다면 다른 혜택이 없을까요?\n\n새로운 JavaScript 기능 및 크로스 브라우저 JavaScript로 컴파일: Babel은 네이티브 JavaScript를 위해 둘 다 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n이점에 대한 설명이 끝났어요. 제 기분은 조금 실망스럽군요. 다른 도구를 사용하여 원시 JavaScript의 경우에도 타입 힌트, 자동 완성 및 큰 버그 감소를 얻을 수 있다면, TypeScript의 차이로 인한 투자 대비가 가치 있는지에 대해 알아봐야 합니다.\n\n그것을 알아내기 위해서 TypeScript의 비용을 자세히 살펴봐야 합니다.\n\n채용: JavaScript 상태 조사 응답자의 거의 절반은 TypeScript를 사용했으며 다시 사용할 의향이 있습니다. 또한 33.7%는 배우고 싶어하지만, 5.4%는 TypeScript를 사용했지만 다시 사용하지 않고, 13.7%는 TypeScript를 배우는 것에 관심이 없습니다. 이로 인해 거의 20%에 해당하는 인원이 인적자원 확보 풀에서 제외되며, 이는 많은 인재 채용이 필요한 팀에게 상당한 비용이 될 수 있습니다. 채용은 몇 달 동안 지속되고 다른 개발자들의 생산성 시간을 소모할 수 있는 비용이 크기 때문입니다. (그리고 대부분의 경우, 기존 개발자가 새로운 후보자의 기술을 가장 잘 판단할 수 있는 사람입니다.)\n\n반면, 개발자 한두 명만 채용해야 한다면, TypeScript를 사용하는 것은 거의 절반이 넘는 후보자 풀에게 더욱 흥미로운 공고를 만들 수 있습니다. 소규모 프로젝트의 경우, 중립적이거나 미세하게 긍정적일 수 있습니다. 수백 또는 수천명의 팀의 경우, ROI 오차 마진의 부정적인 쪽으로 기울 것입니다.\n\n<div class=\"content-ad\"></div>\n\n설치, 초기 교육: 한 번 들어가는 비용이므로 비교적 낮습니다. 자바스크립트에 익숙한 팀은 보통 2~3개월 내에 TypeScript에서 생산성을 띄우고, 6~8개월 이내에는 상당히 숙달합니다. 채용보다는 비용이 높지만, 이 비용만 고려한다면 노력을 들여야하는 가치가 충분합니다.\n\n미지원 기능 - HOFs, 합성, 높은 종류의 일반화 타입 등: TypeScript는 관용적인 자바스크립트와 완전히 연동되지 않습니다. TypeScript에서의 가장 큰 도전 중 하나이기도 합니다. 숙달된 자바스크립트 개발자들은 종종 TypeScript로 표현하기 어려운 또는 불가능한 상황을 자주 겪을 수 있지만, 성실한 개발자들은 올바르게 작업하고 싶어 할 것입니다. TypeScript에서 제대로 타이핑할 수 없는 것들을 타이핑하는 방법을 배우려고 구글링하는 데 시간을 보낼 것입니다.\n\nTypeScript는 현재의 한계를 더 잘 설명하고 발견할 수 있도록 좋은 문서 및 자료를 제공함으로써 이 비용을 줄일 수 있습니다. 여러분들은 고차 함수, 선언적 함수 합성, 트랜스듀서 등에서 TypeScript를 잘 사용하도록 시간을 낭비하지 않도록 해야 합니다. 많은 경우, 잘 행동하고 가독성이 높고 유지보수가 용이한 TypeScript 타이핑을 갖추는 것은 불가능할 수 있습니다. 개발자들은 더 생산적인 일에 시간을 소비할 수 있도록 이를 빨리 발견해야 합니다.\n\n지속적인 지도: 사람들은 TypeScript에서 생산적으로 될 수 있지만, 자신감을 갖는 데는 상당히 많은 시간이 걸립니다. 아직도 많은 것을 배워야 한다고 느낍니다. TypeScript에서는 동일한 것을 타이핑하는 다양한 방법이 있으며, 각각의 장단점을 이해하고 최선의 방법을 찾아내는 것은 초기 학습 곡선보다 시간이 더 오래 걸릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 새로운 TypeScript 개발자들은 주석과 인라인 타입을 지나치게 사용하는 경향이 있습니다. 반면 더 경험이 있는 TypeScript 개발자들은 인터페이스를 재사용하고 인라인 주석의 구문 혼란을 줄이기 위해 별도의 타입을 만들어 사용하고 있습니다. 더 경험이 있는 개발자들은 또한 타입을 정교하게 조정하여 컴파일 시간에 더 나은 오류를 발견하게 됩니다.\n\n타입에 대한 이러한 추가 관심은 새로운 개발자를 합류시킬 때마다 발생하는 비용이지만, 경험 있는 TypeScript 개발자가 팀 전체와 새로운 팁을 공유하며 배우기 시작할 때마다 발생하는 비용입니다. 이러한 지속적인 멘토가 협력의 정상적인 부산물일뿐이며, 다른 부분에 적용할 때 장기적으로 비용을 절약할 수 있는 건강한 습관입니다. 그러나 이에는 비용이 들어가며 TypeScript는 이를 크게 증가시킵니다.\n\n타이핑 오버헤드: 타이핑 오버헤드 비용에는 추가 시간을 들여 타이핑, 테스트, 디버깅 및 유지 관리하는 모든 비용이 포함됩니다. 디버깅 타입은 종종 간과되는 비용입니다. 타입 주석은 자체 버그 클래스를 가지고 있습니다. 너무 엄격하거나 너무 느슨하거나 그저 잘못된 타입을 갖는 경우가 있습니다.\n\n이 비용 부문은 처음 탐색했을 때보다는 줄어들었는데, 이제 많은 써드파티 라이브러리가 타입을 포함하고 있어서 자체로 추적하거나 만들어야 하는 일이 줄었습니다. 그러나 이러한 타입 중 여전히 많은 부분이 잘못되었거나 최신이 아닌 경우가 많아서, 여전히 타입 힌트가 필요한 써드파티 라이브러리에 대해 타입을 보충해야 할 것입니다. 종종 개발자들은 이러한 타입을 상류로 추가하려고 하며, 그 결과는 다양합니다.\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 테이블 태그를 변경해주시면 더 많은 문법 소음이 줄어듭니다. 하스켈 같은 언어에서는 타입이 일반적으로 간단한 한 줄짜리로 함수 정의 위에 나열됩니다. TypeScript에서는 특히 제네릭 함수의 경우, 기본적으로 삽입적이고 정의되어 있습니다.\n\n함수 시그니처의 가독성을 높이는 대신 TypeScript 타입들은 종종 함수 시그니처를 이해하기 어렵게 만들 수 있습니다. 이것이 경험 많은 TypeScript 개발자들이 보통 재사용 가능한 타입 및 인터페이스를 더 많이 사용하고 함수 구현에서 타입을 분리하여 선언하는 이유 중 하나입니다. 대규모 TypeScript 프로젝트는 종종 프로젝트 어디에서나 가져와 사용할 수 있는 재사용 가능한 타입 라이브러리를 개발하며, 그러한 라이브러리의 유지 보수는 추가로 처리해야 할 일이 될 수 있지만 가치 있는 작업이 됩니다.\n\n문법 소음은 여러 이유로 문제가 됩니다. 코드를 무너지지 않게 유지하고 싶은 이유가 집을 정리해서 깔끔하게 보관하는 이유와 같습니다:\n\n- 더 많은 돌출 = 버그가 숨을 수 있는 더 많은 곳 = 더 많은 버그.\r\n- 더 많은 돌출은 찾고 있는 정보를 찾기 어렵게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n정리는 정말 중요하죠. 잡음 없애는 행위는 시그널을 더 잘 들을 수 있게 해줘요. TypeScript의 구문 잡음은 상당한 비용 중 하나니까요. 더 나은 방법을 통해 개선할 수 있습니다:\n\n- 고차형 타입을 사용한 제네릭에 대한 더 나은 지원으로, 템플릿 구문 잡음을 줄일 수 있습니다. (참고: Haskell의 타입 시스템)\n- 디폴트로 인라인 타입을 사용하는 대신 따로 구분 가능하도록 장려합니다. 인라인 타입을 피하는 것이 좋은 방법으로 인식되면, 타이핑 구문이 함수 구현과 겹치지 않아 읽기 쉬워질 거에요. Stack Overflow에서 홍보하는 동안 일부 문서 개선을 통해 구현될 수 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\nTypescript에 대해 여전히 많이 좋아합니다. 더 나아지길 희망하고 있습니다. 앞으로 새로운 기능을 추가하고 문서를 개선하여 이러한 비용 문제를 충분히 해결할 수 있을 것으로 기대합니다.\n\n그러나 이러한 문제를 외면하거나 Typescript의 혜택을 과대평가하는 것은 책임있지 않습니다. \n\nTypescript는 타입 추론, 고계 함수 및 제네릭의 측면에서 더 나아질 수 있고, Typescript 팀은 튜토리얼, 비디오, 최선의 사례, 그리고 Typescript의 제한 사항을 쉽게 찾을 수 있도록 개선하는 큰 기회가 있습니다. 이는 Typescript 개발자들이 시간을 절약하고 사용 비용을 크게 줄일 수 있게 해줄 것입니다.\n\nTypescript가 계속 성장함에 따라, 사용자들이 여전히 애정의 단계를 넘어서 비용과 현재의 한계를 깨닫기를 희망합니다. 더 많은 사용자가 늘어날수록, 더 많은 창의적인 사고가 해결책에 집중할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\nTypeScript에 있어서, 작은 오픈 소스 라이브러리에서는 분명히 다시 사용할 것입니다. 이는 다른 TypeScript 사용자들을 위해 삶을 더 쉽게 만들기 위함입니다. 그러나 다음 대규모 응용 프로그램에서는 현재 TypeScript 버전을 사용하지 않을 것입니다. 왜냐하면 프로젝트가 클수록 TypeScript를 사용하는 비용이 증가하기 때문입니다.\n\n이 결론은 기이한 것입니다. 왜냐하면 TypeScript의 슬로건은 \"확장 가능한 JavaScript\"이기 때문입니다. 더 솔직한 슬로건은 다음과 같이 수정될 수 있을 것입니다: \"어색하게 확장되는 JavaScript\".\n\nEric Elliott는 분산 시스템 전문가이자 \"Composing Software\"와 \"Programming JavaScript Applications\"의 저자입니다. DevAnywhere.io의 공동 창업자로서, 개발자들에게 원격으로 일하고 업무/생활 균형을 맞추기 위해 필요한 기술을 가르칩니다. 그는 암호화 프로젝트를 위해 개발 팀을 구축하고 자문하며, Adobe Systems, Zumba Fitness, The Wall Street Journal, ESPN, BBC 및 Usher, Frank Ocean, Metallica 등의 최고 음악가를 포함한 소프트웨어 경험을 개선했습니다.\n\n그는 세계에서 가장 아름다운 여자와 함께 원거리 생활을 즐깁니다.","ogImage":{"url":"/assets/img/2024-06-20-TheTypeScriptTax_0.png"},"coverImage":"/assets/img/2024-06-20-TheTypeScriptTax_0.png","tag":["Tech"],"readingTime":19}],"page":"45","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}