{"pageProps":{"posts":[{"title":"2024년에 React, Vite, Electron, 그리고 FastAPI로 Full-Stack 애플리케이션 만들기","description":"","date":"2024-05-12 22:52","slug":"2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024","content":"\n\n![이미지](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_0.png)\n\n이 포괄적인 가이드에서는 React, Vite, Electron 및 FastAPI를 활용하여 간단한 풀스택 애플리케이션을 설정하는 방법을 안내해 드릴 거에요. 이 튜토리얼을 완료하면 단일 명령어로 시작되는 기능적인 애플리케이션을 보유하게 되며 로컬 개발 및 테스트에 적합할 거에요.\n\n# 개요\n\n이 애플리케이션 아키텍처는 아래와 같이 통합될 것입니다:\n\n\n\n- ReactJS: 사용자 인터페이스를 구축하기 위한 강력한 라이브러리.\n- Vite: 웹 프로젝트용 현대적이고 빠른 빌드 도구.\n- Electron: 웹 기술로 크로스 플랫폼 데스크톱 앱을 빌드하는 프레임워크.\n- FastAPI: Python으로 API를 빌드하기 위한 효율적이고 고성능 프레임워크.\n\n# 시스템 디자인 개요\n\n아래 다이어그램은 시스템 아키텍처를 설명합니다:\n\n![Architecture Diagram](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_1.png)\n\n\n\n다음은 각 구성 요소 간 상호 작용을 보여주는 다이어그램입니다:\n\n- Electron Main Process: 라이프사이클 이벤트를 관리하고 브라우저 창을 생성합니다.\n- Electron Renderer Process: 브라우저 창 내에서 웹 프런트엔드를 실행합니다.\n- React Application: Vite를 통해 제공되는 UI를 제공합니다.\n- FastAPI Server: 백엔드 로직 및 데이터 관리를 처리합니다.\n\n# 애플리케이션 구조\n\n다음은 우리의 간단한 애플리케이션의 구조입니다:\n\n\n\n```js\nmy-project/\n│\n├── backend/\n│   ├── main.py            # FastAPI 애플리케이션\n│   └── requirements.txt   # Python 종속성\n│\n├── frontend/              # Vite 프로젝트 루트\n│   ├── main.jsx           # React 애플리케이션 진입점\n│   ├── App.jsx            # React 컴포넌트\n│   ├── App.module.css     # 스타일\n│   └── vite.config.js     # Vite 구성 설정\n│   └── package.json       # 프론트엔드 종속성을 위한 NPM 패키지 파일\n│\n├── electron/\n│   └── main.cjs           # Electron 메인 스크립트\n│   └── preload.cjs           # Electron 메인 스크립트\n│\n├── package.json           # Electron을 위한 루트 NPM 패키지 파일\n```\n\n# 환경 설정\n\n## 1. 가상 환경\n\n프로젝트 디렉토리에서 파이썬 가상 환경을 만들면 전역 파이썬 환경과 별도로 파이썬 종속성을 관리할 수 있습니다.\n\n\n\nWindows:\n\n\n```js\npython -m venv venv\n.\\venv\\Scripts\\activate\n```\n\nmacOS/Linux:\n\n```js\npython3 -m venv venv\nsource venv/bin/activate\n```\n\n\n\n# 2. 종속성 설치\n\n백엔드 디렉토리에서 requirements.txt 파일을 추가하세요:\n\n```js\nfastapi==0.68.1\nuvicorn==0.15.0\n```\n\nPython 종속성을 설치하세요:\n\n\n\n```js\npip install -r backend/requirements.txt\n```\n\n## 3. 프론트엔드 및 일렉트론 설정\n\nVite를 사용하여 프론트엔드를 초기화하고 일렉트론을 구성합니다.\n\nVite 프로젝트를 초기화합니다 (프론트엔드 디렉토리 내부):\n\n\n\n```js\nnpm create vite@latest --template frontend\n```\n\nNode 의존성 패키지 설치:\n\n```js\nnpm install\n```\n\n# 4. 백엔드 서버\n\n\n\nfrontend/App.jsx:\n\n```jsx\nimport React from 'react';\n\nfunction App() {\n    return (\n        <div>\n            <h1>Welcome to the React Front-end!</h1>\n            <p>Your data:</p>\n            <table>\n                <tr>\n                    <th>Message</th>\n                </tr>\n                <tr>\n                    <td>Hello from FastAPI</td>\n                </tr>\n            </table>\n        </div>\n    );\n}\n\nexport default App;\n```  \n\n\n\n```js\nimport React, { useEffect, useState } from \"react\";\nimport styles from \"./App.module.css\"; // CSS 모듈 가져오기\n\nfunction App() {\n  const [data, setData] = useState(\"\");\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(\"http://localhost:8000/data\");\n        const jsonData = await response.json();\n        setData(jsonData.message);\n      } catch (error) {\n        console.error(\"데이터를 불러오는 도중 오류가 발생했습니다:\", error);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return (\n    <div>\n      <div>{data || \"로딩 중...\"}</div>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n스타일 추가:\nfrontend/App.module.css:\n\n```css\n.container {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100vh;\n  }\n  \n  .content {\n    text-align: center;\n    font-family: Arial, sans-serif;\n    background-color: #f0f0f0;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n}\n```\n\nfrontend/main.jsx:\n\n\n\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App.jsx\";\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n# 6. 일렉트론 구성\n\nelectron/main.cjs:\n\n```js\nconst { app, BrowserWindow } = require('electron');\nconst path = require('path');\n\nfunction createWindow() {\n    const mainWindow = new BrowserWindow({\n        width: 800,\n        height: 600,\n        webPreferences: {\n            preload: path.join(__dirname, 'preload.cjs'),\n            contextIsolation: true, // 보안을 위해 중요함\n            enableRemoteModule: false, // 보안 상 이유로 원격 모듈 비활성화\n            nodeIntegration: false // 보안 상 이유로 nodeIntegration 비활성화\n        }\n    });\n\n    // 로컬 웹 서버 URL 로드\n    mainWindow.loadURL('http://localhost:5173');\n\n}\n\napp.whenReady().then(createWindow);\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') {\n        app.quit();\n    }\n});\n```\n\n\n\nelectron/preload.cjs:\n\n```js\nconst { contextBridge, ipcRenderer } = require('electron');\n\n// 렌더러 프로세스에 노출할 안전한 API\ncontextBridge.exposeInMainWorld('api', {\n    send: (channel, data) => {\n        // 렌더러에서 메인 프로세스로 데이터를 보내기 위한 채널 화이트리스트\n        const validChannels = ['toMain'];\n        if (validChannels.includes(channel)) {\n            ipcRenderer.send(channel, data);\n        }\n    },\n    receive: (channel, func) => {\n        // 메인에서 렌더러 프로세스로 데이터를 수신하기 위한 채널 화이트리스트\n        const validChannels = ['fromMain'];\n        if (validChannels.includes(channel)) {\n            // 새 리스너를 추가하기 전에 채널에서 모든 리스너를 제거\n            // 이렇게 하면 여러 리스너가 등록되는 것을 방지\n            ipcRenderer.removeAllListeners(channel);\n            ipcRenderer.on(channel, (event, ...args) => func(...args));\n        }\n    }\n});\n```\n\n# 7. 통합 시작 명령\n\npackage.json을 업데이트하여 모든 서비스를 하나의 명령어로 시작하세요.\n\n\n\n```json\n{\n  \"name\": \"frontend\",\n  \"private\": true,\n  \"version\": \"0.0.1\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"start\": \"concurrently \\\"npm run start-backend\\\" \\\"npm run start-frontend\\\" \\\"npm run start-electron\\\"\",\n    \"start-backend\": \"cd backend && uvicorn main:app --reload --host localhost --port 8000\",\n    \"start-frontend\": \"cd frontend && vite\",\n    \"start-electron\": \"electron electron/main.cjs\"\n  },\n  \"devDependencies\": {\n    \"vite\": \"^5.2.0\",\n    \"concurrently\": \"^7.0.0\"\n  }\n}\n```\n\n# 응용 프로그램 실행 방법\n\n응용프로그램을 실행하려면:\n\n```js\nnpm start\n```\n\n\n\n아래 명령어로 백엔드, 프론트엔드 및 일렉트론을 동시에 시작하여 즉시 애플리케이션을 확인할 수 있습니다.\n\n성공적인 터미널 출력은 다음과 같아야 합니다:\n\n![이미지](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_2.png)\n\n# 결과\n\n\n\nBrowser:\n\n![Browser screenshot](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_3.png)\n\nMacOS:\n\n![MacOS screenshot](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_4.png)\n\n\n\nWindows:\n\n![Windows](/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_5.png)\n\n## 결론\n\n이 안내서는 최신 기술을 활용하여 개발 및 확장 가능한 제품 배포 모델에 이상적인 완전한 스택 애플리케이션을 구축하기 위한 간단한 로드맵을 제시합니다. 이 프레임워크는 소프트웨어 아키텍처의 최상의 실천 방법을 준수하며, 요소의 느슨한 결합과 손쉬운 유지 관리를 촉진합니다.\n\n\n\n여기서 전체 코드에 액세스하세요\n\n질문이 있으시면 언제든지 물어보세요.","ogImage":{"url":"/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaFull-StackApplicationwithReactViteElectronandFastAPIin2024_0.png","tag":["Tech"],"readingTime":7},{"title":"React Context와 TypeScript를 마스터하기 포괄적인 튜토리얼","description":"","date":"2024-05-12 22:51","slug":"2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial","content":"\n\n친절한 톤으로 한국어로 번역하면 다음과 같습니다.\n\n\"이 글에서는 TypeScript를 사용하여 더 가독성이 좋고 쉽게 이해할 수 있으며 최신 best practice에 맞는 React 컨텍스트를 만드는 과정을 안내하겠습니다. React 컨텍스트는 컴포넌트 트리의 모든 수준을 통해 props를 전달하지 않고 상태 데이터를 관리하고 공유할 수 있는 방법을 제공합니다.\n\nReact Context 설정 방법\n\n먼저, React Context API를 사용하여 기본 값이 null인 컨텍스트를 생성해봅시다.\"\n\n\n\n기본값을 null로 설정한 이유에 대해 궁금할 수 있습니다. 이 선택은 곧 명백해질 목적이 있습니다.\n\n콘텍스트 제공자 생성하기\n\n다음은 우리가 콘텍스트 제공자를 구성하는 방법입니다:\n\n![Context Provider Structure](/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_1.png)\n\n\n\n제공된 코드 스니펫에서 useMemo의 사용을 알 수 있을 것입니다. 여기서의 목적은 context 값이 각 렌더링마다 변경되지 않도록 똑똑하게 저장하는 것입니다. 이 과정을 통해 컨텍스트가 다시평가될 때 불필요한 변경을 방지합니다.\n\n조금 더 자세히 살펴보죠: 애플리케이션의 표시가 컨텍스트 제공자 내부 업데이트로 인해 변경되는 경우를 상상해보세요. 이러한 경우에는 컨텍스트 객체를 재설정하는 것이 합리적입니다. 그러나 부모 구성 요소의 상태 변경과 같은 외부 요소에서 업데이트가 발생하는 경우도 고려해야 합니다. 이러한 시나리오에서 매번 새 객체를 만드는 것은 과도합니다. 최적화된 방식을 통해 이러한 비제공자 유발 렌더 중에는 불필요한 객체 재생성을 방지합니다.\n\n매 렌더링마다 객체를 재생성하는 것에 대해 왜 걱정해야 하는지 의문이 생길 수 있는 데요? 사실, 많은 경우에는 이것이 심각한 문제처럼 보이지 않을 수 있습니다. 그러나 더 깊이 파고들면, 이러한 실천은 예기치 못한 버그로 이어질 수 있습니다. 예를 들어, 컨텍스트 값 객체가 useEffect 훅 내에서 종속성으로 사용될 때 관련 문제가 발생할 수 있습니다. 객체 참조 일관성을 유지함으로써 우연한 다시 렌더링으로 인한 잠재적인 이상 현상을 우회합니다. 이러한 전략적 기동이 결국 코드베이스의 견고성과 안정성에 기여합니다.\n\n커스텀 훅을 사용한 컨텍스트 소비 최적화\n\n\n\n내용을 이해하기 위해 커스텀 훅을 만들 것입니다. 이 접근 방식은 모듈화 및 코드 가독성을 높이는 데 도움이 됩니다.\n\n![마크다운](/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_2.png)\n\n이 조각에서는 useMessageContext라는 커스텀 훅을 생성하여 컨텍스트의 사용을 캡슐화하고 있습니다. 이를 통해 두 가지 중요한 목표를 달성합니다:\n\n- 모듈화: 커스텀 훅은 컨텍스트 사용의 세부 정보를 추상화하여 관리 및 재사용을 쉽게 만듭니다. 응용 프로그램 전체에서 컨텍스트 소비 방법을 변경해야 할 경우, 한 곳에서 수행할 수 있습니다.\n- 명확성과 가독성: 일반적인 useContext 대신 useMessageContext를 사용함으로써 더 구체적인 의미 체계를 제공하여 코드를 이해하기 쉽게 만듭니다. 코드베이스에서 작업하는 사람은 누구나 컨텍스트 소비의 목적을 빠르게 파악할 수 있습니다.\n\n\n\n여기 useMessageContext 훅이 의존하는 useContextWrapper 함수의 구현 내용입니다:\n\n![이미지](/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_3.png)\n\n이 useContextWrapper 함수는 추가적인 오류 처리 레이어를 추가합니다. 해당 프로바이더가 제대로 제공되지 않으면, 명료하고 유익한 오류 메시지가 표시되어 개발자가 효과적으로 문제를 해결할 수 있도록 안내됩니다.\n\n마무리하며\n\n\n\n이 가이드라인을 따라가면 효율적이고 유지보수가 쉬운 TypeScript를 사용한 잘 구조화된 React 컨텍스트를 만들 수 있습니다. 컨텍스트 프로바이더를 올바르게 설정하고 유형을 정의하며 사용자 지정 후크를 통해 컨텍스트를 소비하는 것은 더 견고하고 확장 가능한 애플리케이션에 기여할 것입니다.\n\n![이미지](/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_4.png)\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringReactContextwithTypeScriptAComprehensiveTutorial_0.png","tag":["Tech"],"readingTime":3},{"title":"이벤트 루프가 뭐죠 자바스크립트 비동기 프로그래밍 탐구","description":"","date":"2024-05-12 22:50","slug":"2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming","content":"\n\n\n![이미지](/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png)\n\n자바스크립트는 본질적으로 싱글 스레드입니다. 그렇다면 프라미스와 비동기 메서드를 어떻게 처리할까요? 그것들을 어떻게 병렬로 실행할까요? 답은 명확하지 않을 수 있습니다. 자바스크립트 비동기 프로그래밍을 탐구해봅시다...\n\n# 정교하고 효율적인 아키텍처\n\n자바스크립트는 이벤트 루프, 태스크 큐 및 마이크로태스크 큐를 결합하여 싱글 스레드 언어가 비동기 작업을 수행할 수 있도록 정교하고 효율적인 아키텍처를 갖추고 있습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_1.png\" />\n\n## 예시를 살펴보겠습니다...\n\n```js\n// 메소드-1\nconsole.log(\"A\");\n\n// 메소드-2\nsetTimeout(()=>{\n  console.log(\"B\");\n},100);\n\n// 메소드-3\nsetTimeout(()=>{\n  console.log(\"C\");\n},0);\n\n// 메소드-4\nconsole.log(\"D\");\n\n/***\n*\n* 출력:\n* ADCB\n*\n***/\n\n```\n\n- 실행이 시작되면 각 메소드 호출이 실행을 위해 CallStack에 들어갑니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_2.png\" />\n\n- 즉시 결과를 제공할 수 있는 메서드(동기 메서드)가 실행됩니다. 비동기 메서드의 콜백은 해당 Web API로 넘어갑니다.\n\n<img src=\"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_3.png\" />\n\n- 메서드 1과 4는 즉시 반환되고, 메서드 2와 3은 실행 시간이 되었을 때 TaskQueue로 푸시하기 위해 setTimeout API로 넘어갑니다.\n- 타이머가 0일 때 메서드 3이 Task Queue로 푸시되고, 타이머가 100일 때 메서드 4가 그 뒤를 이어 실행됩니다.\n- 그리고 나중에 Task Queue에 있는 각 메서드가 자유 시간이 되면 실행을 위해 호출 스택으로 이동됩니다. 이것이 Javascript가 비동기 메서드를 처리하는 방식입니다.\n\n\n\n## MicroTask Queue이 하는 일은 무엇인가요…?\n\n- MicroTask Queue은 Promise에서의 콜백을 처리하는 전용 큐입니다.\n- MicroTask Queue에 있는 콜백은 Task Queue에서의 작업보다 우선순위가 높기 때문에, Task Queue에서의 작업은 MicroTask Queue의 작업이 모두 Call Stack으로 이동한 후에만 Call Stack으로 이동됩니다. 언제 큐에 도착했느냐에 관계없이 그렇습니다.\n\n# 결론\n\n이벤트 루프의 개념은 JavaScript를 더 동적이고 유연하게 만들어 주었습니다. JavaScript가 일 스레드인 한에서 비동기 프로그래밍을 수행하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png"},"coverImage":"/assets/img/2024-05-12-WhattheheckistheEventLoopExploreJavascriptAsynchronousProgramming_0.png","tag":["Tech"],"readingTime":2},{"title":"React에서 페이지 이동, 새로고침할 때 상태 유지하는 5가지 방법","description":"","date":"2024-05-12 22:49","slug":"2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact","content":"\n## 페이지 새로 고침 간에 React 상태 유지하는 다양한 방법 배우기\n\n![이미지](/assets/img/2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact_0.png)\n\n# 1. LocalStorage 사용하기 — 클래스 컴포넌트\n\n가장 간단한 방법 중 하나는 브라우저의 localStorage를 사용하여 상태를 유지하는 것입니다. 예제를 살펴보겠습니다.\n\n우리 주(state)에 count가 있습니다. 이제 페이지를 새로고침해도 이 count 값을 유지하고 싶다면, localStorage를 사용하면 됩니다.\n\n보시다시피, 이제 setState 메소드를 호출할 때마다 state 값을 저장합니다. 이것은 우리가 원하는 바를 달성하기 위한 간단한 방법입니다.\n\n우리는 클래스 컴포넌트를 살펴봤으므로, 함수형 컴포넌트에서는 어떻게 할지 살펴봅시다.\n\n# 2. LocalStorage 사용하기 — 함수형 컴포넌트\n\n먼저, 우리는 클래스 기반 컴포넌트를 함수형 컴포넌트로 변환할 것입니다.\n\n이제 우리가 상태를 유지하기 위해 localStorage를 추가하는 방법을 살펴봅시다.\n\n여기서 함수형 컴포넌트에 대한 약간 다른 접근 방식을 취했다는 것을 알 수 있습니다. useEffect 훅을 사용하여 두 가지 작업을 수행합니다.\n\n- 변경 사항을 추적하고 LocalStorage를 업데이트합니다.\n- 초기화시 LocalStorage에서 저장된 값을 검색합니다.\n\n# 3. Redux 저장소에서 LocalStorage 사용하기\n\n컴포넌트 수준에서 상태를 localStorage에 저장하는 한 가지 문제는 동일한 컴포넌트의 여러 인스턴스가 있는 경우입니다. 이는 localStorage에 중복 된 키를 만들어 예상치 못한 동작을 일으킬 수 있습니다.\n\n이 문제를 해결하기 위해서는 다음과 같은 방법이 있습니다.\n\n- 재사용 가능한 컴포넌트에 ID를 전달하고 이를 사용하여 localStorage에 값을 저장합니다.\n- 또는 상위 수준에서 상태를 지속시킵니다.\n\n만약 Redux를 사용한다면, 앱 상태를 localStorage에 유지하기 위해 사용할 수 있습니다.\n\n먼저, 수동으로 그것을 어떻게 할지 살펴보고, 그런 다음에는 우리를 위해 처리해줄 라이브러리인 \"Redux Persist\"를 사용하여 어떻게 할지 확인해보겠습니다.\n\n여기서는 스토어 업데이트를 구독하고 localStorage에 지속시킴으로써 구현할 수 있습니다. 그리고 앱을 초기화할 때 localStorage로부터 초기 상태를 전달할 수 있습니다.\n\n# 4. Redux Persist 사용하기\n\n수동으로 상태를 지속 및 초기화하는 대신 라이브러리를 사용할 수 있습니다.\n\n보시다시피, Redux Persist에서 persistReducer를 사용하여 persistStore를 저장하고 초기화할 수 있습니다.\n\n# 5. URL 파라미터 사용\n\n가장 명백한 방법이지만, URL 파라미터를 사용하여 상태를 지속하는 방법을 살펴봅시다. 이 접근 방식은 URL 길이 제한으로 인해 데이터가 간단하고 직접적인 원시 값인 경우에 적합합니다.\n\n만약 코드를 자세히 살펴보면, 상태를 브라우저 히스토리에 추가하고 컴포넌트를 초기화할 때 URL 매개변수에서 초기 값을 가져온다는 점입니다.\n\n여기서 중요한 장점 중 하나는 리로드 시 상태를 유지하고 브라우저 뒤로 가기 버튼을 사용하여 이전 상태로 이동할 수 있다는 것입니다.\n\n# 결론\n\n간단한 경우에는 URL 매개변수를 사용할 수 있습니다. 데이터가 조금 더 복잡한 경우에는 localStorage에 저장하는 것이 좋습니다. localStorage 접근 방법을 사용하면 컴포넌트 레벨 또는 앱 레벨에서 상태를 유지할 지를 결정할 수 있습니다.\n\n간단하게 하려면, Redux Persist와 같은 라이브러리를 사용하여 앱 상태를 영구 저장하고 다시 구성하는 방법이 있습니다.\n\n그러나 선택한 옵션에 상관없이 상태 변경을 철저히 관리하는 것도 중요합니다. 한 번 상태가 설정되면 새 릴리스에서 상태 관련 코드를 수정하면 일부 사용자에게 애플리케이션을 망가뜨릴 수도 있습니다.\n\n읽어 주셔서 감사합니다. 그리고 댓글 섹션에서 어떻게 생각하시는지 꼭 알려주세요. 🤔\n\n## 리액트 앱을 레고처럼 재사용 가능한 컴포넌트로 구축해보세요\n\n![이미지](/assets/img/2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact_1.png)\n\nBit의 오픈 소스 도구는 250,000명 이상의 개발자들이 컴포넌트로 앱을 구축하는 데 도움을 줍니다.\n\n어떤 UI, 기능 또는 페이지든지 재사용 가능한 컴포넌트로 변환하고 애플리케이션 간에 공유할 수 있습니다. 협업하기가 더 쉽고 빠르게 빌드할 수 있습니다.\n\n→ 자세히 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 쉽고 편안하게 만들고 원하는 작업 흐름에 최고의 경험을 누리세요:\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포\n\n## 자세히 알아보기\n","ogImage":{"url":"/assets/img/2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact_0.png"},"coverImage":"/assets/img/2024-05-12-5MethodstoPersistingStateBetweenPageReloadsinReact_0.png","tag":["Tech"],"readingTime":3},{"title":"인앱 알림 대비 푸시 알림 - 2024년 제품 커뮤니케이션에서 어떤 알림 채널이 더 나을까요","description":"","date":"2024-05-12 22:47","slug":"2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024","content":"\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_0.png)\n\n업무 커뮤니케이션 채널에 대한 필요성이 증가함에 따라, 인앱 인박스 알림이 모바일 및 웹 푸시 알림의 장점을 효과적으로 통합한 혁신적인 솔루션으로 등장했습니다. hbr.org의 통계에 따르면 소비자들 중 73%가 단일 소매업체와 여러 통신 채널을 통해 상호 작용하는 필요성을 보여주고 있습니다.\n\n먼저 앱 인박스 플레이그라운드를 시도해보세요→\n\n인앱 인박스 메시징을 통해 사용자들은 편의에 맞게 메시지를 다시 확인할 수 있어 전통적인 푸시 알림의 긴급성을 줄입니다. 알림 센터는 메시지가 관련성을 잃을 때까지 접근 가능한 저장소 역할을 하게 됩니다. 고객 공참을 향상하기 위해 사용하는 사용자와의 모바일 인박스 거래 5가지 사용 사례를 확인해보세요.\n\n\n\n# 푸시 알림 이해하기:\n\n푸시 알림은 널리 사용되는 커뮤니케이션 도구로, 높은 무시율과 과다함에 대한 도전에 직면하고 있습니다. 스마트폰 사용자들은 하루에 평균 46개의 푸시 알림을 받아, 대안 탐색이 필수적입니다.\n\n# 비교 분석: 앱 인박스 대 푸시 알림:\n\n기술적 세부 사항을 탐색하여, 앱 인박스 메시징과 푸시 알림을 비교하는 자세한 비교를 살펴봅시다.\n\n\n\n# 1. 구독 과정:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_1.png)\n\n# 2. 출현과 소멸:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_2.png)\n\n\n\n# 3. 기술 구현 및 호환성:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_3.png)\n\n# 4. 사용자 상호작용:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_4.png)\n\n\n\n# 5. 스토리지 및 접근성:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_5.png)\n\n# 사용 사례: 언제 앱 인박스 또는 푸시 알림을 선택해야 하는가:\n\n제품에서 푸시 알림을 사용해야 하는 때와 인앱 박스 알림을 사용해야 하는 때를 알아보고 몇 가지 예시를 살펴보세요. 이 외에도 이벤트의 흐름을 통합하기 위해 메시지 대기열 기술을 선택해야 합니다. 당신의 알림 시스템을 위해 적절한 메시지 대기열 기술을 선택하기.\n\n\n\n<img src=\"/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_6.png\" />\n\n# 기술 정보 — 앱 안내상자 설정:\n\n커뮤니케이션 전략에 앱 안내상자 메시징을 통합하는 것은 주요 기술 정보를 활용한 간단한 프로세스로 진행됩니다. 백엔드 인프라, 프론트엔드 알림함, socket.io를 사용하여 두 가지 사이의 연결이 필요하므로 이는 복잡한 작업입니다. 그러나 SuprSend를 사용하면 이런 프로세스를 크게 간소화할 수 있어서 앱 안내상자를 쉽게 구현할 수 있습니다.\n\nSuprSend로 두 단계만 거치면 시작할 수 있습니다.\n\n\n\n## 스크립트 설치:\n\nApp Inbox 설정을 위해 하나의 스크립트를 사용하여 고급 기능에 접근하세요.\n\n예시 코드:\n\n`<img src=\"/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_7.png\" />`\n\n\n\n휴대폰 받은 편지함이 사용자 참여도를 높이는 방법을 아셨나요? (inapp-inbox를 사용한 사례 연구 포함)\n\n## 사용자 인증:\n\n메시지는 별도의 구독 과정 없이 인증된 사용자에게 접근 가능합니다.\n\n예시 코드:\n\n\n\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_8.png)\n\n문서를 확인해보세요: 개요 (suprsend.com)\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_9.png)\n\n# 기술적인 통찰력 — 푸시 알림 설정:\n\n\n\n사용자에게 푸시 알림을 고려 중인 비즈니스들을 위해 고려해야 할 몇 가지 기술적 측면이 있습니다:\n\n## Firebase 통합:\n\n푸시 알림은 Firebase 프로젝트 생성 및 ESP와의 기능 연관이 필요합니다.\n\n예시 코드:\n\n\n\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_10.png)\n\n## 토큰 사용법:\n\n푸시 알림은 메시지를 보내기 위해 푸시 토큰을 사용하며 사용자는 웹사이트에서 구독해야 합니다.\n\n예시 코드:\n\n\n\n\n![image](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_11.png)\n\n이 모든 것들은 코드에서 유지하기가 꽤 복잡하고, 특히 멀티 테넌시 사용 사례가 있는 경우에는 더욱 어렵습니다. 여기서 SuprSend는 선호하는 푸시 알림 공급업체를 추가하고 API나 프론트엔드 편집기를 통해 템플릿과 코드를 만들며, API를 통해 워크플로우를 관리하고, 멀티 테넌트를 관리하며 대시보드에서 완전한 감시를 할 수 있는 단일 대시보드를 제공하여 모든 것을 간단하게 만듭니다.\n\n![image](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_12.png)\n\n결론적으로, 앱 인박스와 푸시 알림 중 어떤 것을 선택할지는 비즈니스의 특정 커뮤니케이션 요구에 달려 있습니다. 푸시 알림은 즉각적이고 주목을 끄는 시나리오에서 뛰어나지만, 앱 인박스는 사용자 중심 접근 방식을 제공하여 장기 프로모션과 지속적인 참여에 이상적입니다. 자세한 정보는 확인해보세요: Mobile In-App Inboxes Have 17% Higher Click Rates Than Push Notifications. Why It Should Bother Product Teams?\n\n\n\n# 앱 인박스를 쉽게 통합하고 싶으신가요?\n\nSuprSend와 함께하면 10분 이내에 앱 인박스를 시작할 수 있습니다. 원하는 SDK를 통합하고 몇 줄의 코드를 복사하면 됩니다. 문서를 확인하여 무난하게 시작하세요.\n\n2줄의 코드로 인앱 인박스를 통합하고 시작할 수 있습니다. 자세한 내용은 다음 문서를 확인해주세요: [인앱 인박스 템플릿](suprsend.com)\n\n![image](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_13.png)\n\n\n\n원래 발행된 곳: https://www.suprsend.com.","ogImage":{"url":"/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_0.png"},"coverImage":"/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_0.png","tag":["Tech"],"readingTime":5},{"title":"Reactjs에서 데이터를 Excel XLSX로 내보내는 방법","description":"","date":"2024-05-12 22:45","slug":"2024-05-12-HowtoexportdatatoExcelXLSXinReactjs","content":"\n\n# 소개\n\n웹 개발의 동적 풍경에서 React.js는 강력한 라이브러리로 강력한 사용자 인터페이스를 구축하는 데 뛰어납니다. 많은 웹 애플리케이션에서 일반적인 요구 사항 중 하나는 데이터를 Excel 형식으로 내보내는 기능입니다. 이 안내서에서는 React.js와 SheetJS 및 File-Saver 라이브러리를 함께 사용하여 이를 원활하게 수행하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-05-12-HowtoexportdatatoExcelXLSXinReactjs_0.png)\n\n## SheetJS와 File-Saver를 사용해야 하는 이유?\n\n\n\nSheetJS는 엑셀을 포함한 다양한 스프레드시트 형식의 데이터를 구문 분석, 조작 및 작성하는 데 사용할 수 있는 높은 수준의 기능을 제공하는 자바스크립트 라이브러리입니다. 반면에 File-Saver는 브라우저에서 자바스크립트로 생성된 파일을 저장하는 프로세스를 간단하게 만들어 줍니다. 이 두 라이브러리를 함께 사용하면 React.js 애플리케이션에서 데이터를 엑셀 형식으로 직접 내보내는 강력한 솔루션을 제공할 수 있습니다.\n\n## 설치\n\n시작하려면 SheetJS와 File-Saver를 설치해 보겠습니다:\n\n```js\nnpm install xlsx file-saver\n```\n\n\n\n## 실행\n\n의존성을 설치한 후 구현부로 넘어가봅시다. \"ExcelExport.jsx\" 파일을 만들고 아래 코드를 추가해주세요:\n\n```js\nimport React from 'react';\nimport { saveAs } from 'file-saver';\nimport XLSX from 'xlsx';\n\nconst ExcelExport = ({ data, fileName }) => {\n  const exportToExcel = () => {\n    const worksheet = XLSX.utils.json_to_sheet(data);\n    const workbook = XLSX.utils.book_new();\n    XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');\n    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });\n    const blob = new Blob([excelBuffer], {type: 'application/octet-stream'});\n    saveAs(blob, `${fileName}.xlsx`);\n  };\n\n  return (\n    <button onClick={exportToExcel}>Excel로 내보내기</button>\n  );\n}\n\nexport default ExcelExport;\n```\n\n## 사용법\n\n\n\nExcelExport 컴포넌트를 사용하려면 내보내려는 데이터를 props로 전달하면 됩니다:\n\n```js\nimport React from 'react';\nimport ExcelExport from './ExcelExport';\n\nconst data = [\n  { id: 1, name: 'John Doe', age: 30, profession: 'Developer' },\n  { id: 2, name: 'Jane Smith', age: 25, profession: 'Designer' }\n];\n\nconst App = () => {\n  return (\n    <div>\n      <h1>데이터를 Excel로 내보내기</h1>\n      <ExcelExport data={data} fileName=\"employees\" />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n## 사용자 정의\n\nSheetJS가 제공하는 다양한 기능을 사용하여 워크시트 오브젝트를 조작하여 워크북에 추가하는 전에 Excel 시트를 더 자세히 사용자 정의할 수 있습니다. 이는 추가 시트 추가, 셀 스타일링 및 기타 작업을 포함하며, SheetJS가 제공하는 다양한 기능을 사용하여 가능합니다.\n\n\n\n## 결론\n\nReact.js 애플리케이션에서 데이터를 Excel 형식으로 내보내는 것은 많은 프로젝트에서 흔한 요구사항입니다. SheetJS와 File-Saver 라이브러리의 기능을 활용하면 이 작업을 매우 간단하게 수행할 수 있습니다. 이 안내서에서 안내된 단계를 따르면 Excel 내보내기 기능을 React.js 애플리케이션에 원활하게 통합하여 사용자가 데이터를 분석하고 조작하는 편리한 방법을 제공할 수 있습니다. 그러니 사용자에게 권한을 부여하고, SheetJS와 File-Saver 라이브러리의 강력한 조합을 통해 개발 워크플로를 간소화하세요!","ogImage":{"url":"/assets/img/2024-05-12-HowtoexportdatatoExcelXLSXinReactjs_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoexportdatatoExcelXLSXinReactjs_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식","description":"","date":"2024-05-12 22:45","slug":"2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB","content":"\n\n![이미지](/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png)\n\n건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.\n\n우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.\n\n서비스 워커란 무엇인가요?\n\n\n\n서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.\n\n동기화 관리자와 IndexedDB: 완벽한 조합\n\nSync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.\n\n사용 사례: 오프라인에서 양식 데이터 저장\n\n\n\n건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.\n\n# 코드 예시\n\n## 시작하기\n\n저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.\n\n\n\n번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:\n\n```js\nbun create my-app --template react\n```\n\n```js\ncd my-app && bun run dev\n```\n\n저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.\n\n\n\n**참고**: 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.\n\n# 단계 1: 서비스 워커 등록\n\n애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.\n\n```js\ninterface Person {\n  firstName: string,\n  lastName: string,\n  age: number\n}\n\nfunction App() {\n  const [people, setPeople] = useState<Person[]>([]);\n  const { register, handleSubmit } = useForm();\n\n  const registerWorker = () => {\n    if ('serviceWorker' in navigator) {\n      window.addEventListener('load', () => {\n        navigator.serviceWorker.register('/service-worker.js', {scope: '/', type: 'module'})\n          .then(registration => {\n            console.log('Service Worker registered: ', registration);\n          })\n          .catch(registrationError => {\n            console.log('Service Worker registration failed: ', registrationError); \n          });\n      });\n    }\n  }\n```\n\n\n\n# 단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정\n\n우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.\n\n이 서비스 워커 파일에서 'install' 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:\n\n```js\n// service-worker.js \n\nself.addEventListener('install', async (event) => {\n    console.log('Service Worker installing...');\n    await openDB('formDataStore', 1, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains('formData')) {\n            db.createObjectStore('formData', { autoIncrement: true });\n            console.log('Object store created!');\n          }\n        },\n    });\n    console.log('Service Worker installed.');\n});\n```\n\n\n\n# 단계 3: 폼 제출 가로채기\n\n폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.\n\n```js\n// App.tsx\n\n  const onSubmit = async (data: FieldValues) => {\n    if (navigator.onLine) {\n      const response = await fetch(API_URL + '/people',\n        { method: \"POST\", body: JSON.stringify(data) }\n      )\n      if (response.ok) {\n        console.log(response)\n        setPeople((prevPeople) => [{...data} as Person, ...prevPeople])\n      }\n\n    } else {\n      await storeFormDataLocally(data);\n    }\n  }\n```\n\n# 단계 4: 로컬로 데이터 저장하기\n\n\n\n오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.\n\n```js\nasync function storeFormDataLocally(formData : FieldValues) {\n\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readwrite');\n    const store = tx.objectStore('formData');\n    store.put(formData);\n    await tx.done;\n    if ('serviceWorker' in navigator && 'SyncManager' in window) {\n      const registration : any  = await navigator.serviceWorker.ready\n      try {\n        await registration.sync.register('sendFormData');\n          console.log('Sync event registered');\n      } catch(e) {\n          console.log('Failed to register sync, will retry on next   visit' + e);\n      }\n  }\n    db.close();\n  }\n```\n\n서비스 워커는 'sync' 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.\n\n```js\nself.addEventListener('sync', event => {\n    if (event.tag === 'sendFormData') {\n        event.waitUntil(sendFormDataToServer());\n    }\n});\n```\n\n\n\n# 단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기\n\n실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.\n\n```js\nexport async function sendFormDataToServer() {\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readonly');\n    const store = tx.objectStore('formData');\n    const allSavedData = await store.getAll();\n    console.log('저장된 폼 데이터', allSavedData);\n    try {\n        allSavedData.forEach( async (form, index) =>  {\n            const response = await fetch('http://localhost:3000/people',  \n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(form)\n            });\n            if (response.ok) {\n                console.log('서버와 동기화된 데이터:', form);\n                await db.transaction('formData', 'readwrite').objectStore('formData').delete(index);\n                console.log(`제거된 폼 데이터: ${form.firstName} ${form.lastName}` )\n            }\n        });\n    } catch (error) {\n        console.error('폼 데이터 전송 실패:', error);\n    }\n}\n```\n\n# 결론\n\n\n\n건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.\n\nReact, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.\n\n코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.\n\n원문은 https://dennistowns.substack.com에서 원본 게시됨.","ogImage":{"url":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png"},"coverImage":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png","tag":["Tech"],"readingTime":7},{"title":"칼닷컴을 리액트를 이용하여 웹사이트에 통합하는 단계별 안내","description":"","date":"2024-05-12 22:44","slug":"2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide","content":"\n\n현재의 빠르게 변화하는 세상에서 비즈니스 및 전문가들이 시간을 효율적으로 관리하기 위해 필수적인 효율적인 일정 관리 도구들이 되었습니다. Cal.com은 회의와 약속을 일정 잡는 과정을 간소화하여 사용자들이 회의를 설정하는 데 자주 발생하는 번복된 소통을 최소화하고 시간을 절약할 수 있는 도구 중 하나입니다. 이 블로그 포스트에서는 React를 사용하여 웹 사이트에 Cal.com을 원활하게 임베드하는 방법에 대해 살펴보겠습니다. React는 사용자 인터페이스를 구축하는 데 가장 인기있는 JavaScript 라이브러리 중 하나입니다.\n\n# 단계 1: Cal.com 계정 등록\n\nCal.com을 웹 사이트에 임베드하려면 먼저 Cal.com에 계정을 등록해야 합니다. 다행히도 이 과정은 간단하며 몇 분 정도 소요됩니다. 등록이 완료되면 Cal.com 대시보드에 접속하여 일정 설정 기본 사항을 사용자 정의하고, 임베드 가능한 일정 링크를 생성할 수 있게 됩니다.\n\n\n\n# 단계 2: React 설치하기\n\n이미 진행하지 않았다면 Cal.com을 웹사이트에 통합하기 위해 React 프로젝트를 설정해야 합니다. create-react-app을 사용하거나 React 프로젝트를 초기화하는 선호하는 방법을 사용하여 새로운 React 프로젝트를 만들 수 있습니다.\n\n# 단계 3: Cal.com 위젯 패키지 설치하기 (방법 1)\n\nCal.com은 React 위젯 패키지를 제공하여 React 애플리케이션에 일정 기능을 쉽게 포함시킬 수 있습니다. Cal.com 위젯 패키지를 설치하려면 npm을 사용할 수 있습니다:\n\n\n\n```js\nnpm install @calcom/react-widget\n```\n\nCal.com 위젯 패키지를 설치한 후 Cal.com 위젯 컴포넌트를 React 애플리케이션에 추가할 수 있습니다. CalcomWidget 컴포넌트를 React 컴포넌트로 가져와 JSX 마크업 내에서 사용하세요:\n\n```js\nimport React from 'react';\nimport { CalcomWidget } from '@calcom/react-widget';\n\nconst App = () => {\n  return (\n    <div>\n      <h1>내 웹사이트에 오신 것을 환영합니다</h1>\n      <CalcomWidget\n        schedulingLink=\"여기에 당신의 일정 관리 링크를 입력하세요\"\n        buttonText=\"내 Cal 예약하기\"\n        \n      />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n\"여기에 당신의 일정 관리 링크를 입력하세요\"를 Cal.com 대시보드에서 생성된 일정 관리 링크로 대체하세요. 원하는대로 버튼 텍스트를 사용자화할 수 있습니다.\n\n\n\nCal.com 위젯 컴포넌트는 당신의 웹사이트와 일치하도록 커스터마이징할 수 있어요. CalcomWidget 컴포넌트에 props를 전달하여 버튼 텍스트, 버튼 색상, 위젯 크기 등을 다양하게 사용자화할 수 있어요.\n\n당신의 웹사이트는 이렇게 보일 거에요:\n\n![Cal.com Widget Example](/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_1.png)\n\n# 단계 3: Cal.com 임베드 패키지 설치 (방법 2)\n\n\n\nCal.com은 React 임베드 패키지도 제공합니다. npm을 사용하여 패키지를 설치할 수 있어요:\n\n```js\nnpm install @calcom/embed-react\n```\n\n패키지를 설치한 후에는 React 애플리케이션에 Cal.com 임베드 컴포넌트를 추가할 수 있어요. React 컴포넌트에서 Cal 컴포넌트를 가져와 JSX 마크업 안에서 사용하세요:\n\n```js\nimport React from 'react';\nimport Cal from \"@calcom/embed-react\";\n\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <h1>다음은 인라인 cal.com 임베드입니다</h1>\n      <Cal calLink=\"rick/get-rick-rolled\"></Cal>\n    </div>\n  );\n}\n```\n\n\n\nCal 컴포넌트는 calLink라는 속성과 함께 사용됩니다. 이 속성은 삽입할 Cal.com 일정 링크를 지정합니다. 이 경우 \"rick/get-rick-rolled\"이 예제 링크로 제공됩니다. 이를 Cal.com 대시보드에서 생성된 실제 Cal.com 일정 링크로 교체해야 합니다.\n\n당신의 웹사이트는 다음과 같이 보일 것입니다:\n\n![Image](/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_2.png)\n\n# Method 1과 Method 2 사이의 차이는 무엇인가요?\n\n\n\n두 코드 스니펫은 모두 Cal.com 일정을 React 애플리케이션에 삽입하는 동일한 목표를 달성합니다.\n\n요약하면, 메소드 1은 상세한 지침과 사용자 정의 옵션을 제공하는 포괄적인 가이드를 제공하며, 메소드 2는 빠른 통합을 위한 간단하고 사용 준비가 된 코드 스니펫을 제공합니다. 두 가지 방법 중 선택은 사용자의 선호도, React에 대한 익숙함 및 통합에 필요한 사용자 지정 수준에 달려 있습니다.\n\n# 단계 6: 웹사이트 테스트 및 배포하기\n\nReact 애플리케이션에 Cal.com을 통합한 후에는 모든 것이 올바르게 작동하는지 확인하기 위해 기능을 테스트하는 것이 중요합니다. 누군가가 약속을 예약하면 제어판이 표시됩니다:\n\n\n\n\n![image](/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_3.png)","ogImage":{"url":"/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"Axios를 활용하여 API 요청 최적화하기 Interceptors 및 고급 오류 처리","description":"","date":"2024-05-12 22:42","slug":"2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling","content":"\n\n\n![Alt text](/assets/img/2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling_0.png)\n\n프로젝트에서 API 통신의 참된 잠재력을 발휘해 보세요! 다재다능한 HTTP 클라이언트인 Axios를 살펴보고, 인터셉터와 견고한 에러 처리로 요청 관리를 어떻게 높일 수 있는지 알아보세요.\n\nAxios와 기본 Fetch API는 JavaScript에서 HTTP 요청을 하는 도구이지만, 주요 차이점이 있습니다. Axios가 인기 있는 이유와 Fetch API와의 차이점을 강조한 비교입니다:\n\n## 1. 사용 편의성 및 구문:\n\n\n\n— Axios: 깔끔한 구문과 일관된 API를 제공하여 간단하게 사용할 수 있습니다. 그리고 메서드들은 Promises를 반환하여 비동기 작업을 쉽게 연결하고 처리할 수 있습니다.\n— Fetch API: 강력하지만 더 많은 설명이 필요한 구문을 갖고 있으며, 다양한 HTTP 메서드나 헤더를 처리하기 위해서는 추가적인 보일러플레이트(boilerplate) 코드가 필요할 수 있습니다.\n\n## 2. JSON 데이터 다루기:\n\n— Axios: JSON 응답을 자동으로 구문 분석하여 JSON 데이터를 다루는 프로세스를 간단화합니다.\n— Fetch API: 응답에서 JSON 데이터를 추출하려면 수동으로 .json() 메서드를 호출해야 합니다.\n\n## 3. 인터셉터:\n\n\n\n- Axios: Interceptors를 사용하여 HTTP 요청이나 응답이 .then() 또는 .catch() 블록에 도달하기 전에 전역적으로 가로채고 수정하는 것을 가능하게 합니다.\n- Fetch API: 내장된 Interceptors가 없기 때문에 유사한 기능을 달성하려면 추가 코드 및 각 사용 지점에서 처리가 필요합니다.\n\n## 4. 오류 처리:\n\n- Axios: 견고한 오류 처리가 있으며 HTTP 오류 상태 (예: 404 또는 500)에 대해 자동으로 프라미스를 거부합니다.\n- Fetch API: 응답의 ok 속성을 수동으로 확인해야 하며 오류는 자동으로 throw되지 않습니다.\n\nAxios가 인기 있는 이유:\n- 편리성: Axios는 개발자 친화적 인터페이스를 제공하여 명확한 구문으로 작업하기 쉽게 만듭니다.\n- 기능이 풍부함: Interceptors, 자동 JSON 구문 분석 및 요청/응답 변환과 같은 내장 기능은 인기에 기여합니다.\n- 일관된 동작: Axios는 Fetch API에 존재하는 일부 불일치에 대응하여 서로 다른 브라우저에서 일관된 동작을 보장합니다.\n\n\n\n## Axios 시작하기\n\n## 1. Axios 설치하기:\n\n프로젝트에 Axios가 설치되어 있는지 확인하세요. npm 또는 yarn을 사용하여 설치할 수 있습니다:\n\n```js\nnpm install axios\n// 또는\nyarn add axios\n```\n\n\n\n## 2. Axios 인스턴스를 가져와서 만들기:\n\nAPI 요청을 만들 예정인 JavaScript 파일에서 Axios를 가져와주세요. 그리고 기본 URL, 헤더 등과 같은 기본 설정을 설정하기 위해 Axios 인스턴스를 만들어주세요. 이렇게 하면 다른 요청에서 동일한 설정을 재사용할 수 있어요:\n\n```js\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: 'https://api.example.com',\n  headers: {\n    'Content-Type': 'application/json',\n    // 다른 공통 헤더를 추가해주세요\n  },\n});\n```\n\n## 3. 요청과 응답 인터셉터 처리:\n\n\n\n```js\nAxios는 요청과 응답을 전역적으로 처리하기 위해 인터셉터를 사용할 수 있습니다. 이는 헤더 추가, 오류 처리 등과 같은 작업에 유용합니다.\n\n// 요청 인터셉터\napi.interceptors.request.use(\n  (config) => {\n    // 요청 구성을 여기서 수정하세요 (예: 권한 헤더 추가)\n    return config;\n  },\n  (error) => {\n    // 요청 오류 처리\n    return Promise.reject(error);\n  }\n);\n\n// 응답 인터셉터\napi.interceptors.response.use(\n  (response) => {\n    // 응답 데이터를 여기서 수정하세요\n    return response;\n  },\n  (error) => {\n    // 응답 오류 처리\n    return Promise.reject(error);\n  }\n);\n\n## 4. 비동기 요청에 대해 Async/Await 사용:\n\n클린하고 가독성이 좋은 비동기 코드를 위해 async/await 구문을 활용하세요:\n```\n\n\n\n```js\nasync function fetchData() {\n  try {\n    const response = await api.get('/endpoint');\n    // 응답 데이터 처리\n  } catch (error) {\n    // 에러 처리\n  }\n}\n```\n\n## 5. 동시 요청 최적화:\n\n여러 요청을 동시에 실행할 수 있는 경우 성능을 최적화하기 위해 Promise.all을 사용해보세요:\n\n```js\nasync function fetchMultipleData() {\n  try {\n    const [data1, data2] = await Promise.all([\n      api.get('/endpoint1'),\n      api.get('/endpoint2'),\n    ]);\n    // 데이터 처리\n  } catch (error) {\n    // 에러 처리\n  }\n}\n```\n\n\n\n## 6. 요청 취소:\n\nAxios는 요청 취소를 지원합니다. 이는 사용자가 요청이 완료되기 전에 페이지를 벗어날 때 불필요한 요청을 방지하는 데 유용할 수 있습니다:\n\n```js\nconst source = axios.CancelToken.source();\n\ntry {\n  const response = await api.get('/endpoint', {\n    cancelToken: source.token,\n  });\n  // 응답 처리\n} catch (error) {\n  if (axios.isCancel(error)) {\n    // 요청이 취소되었습니다\n  } else {\n    // 다른 오류 처리\n  }\n}\n\n// 요청 취소하기\nsource.cancel('사용자에 의해 요청이 취소됨');\n```\n\n## 성공 및 오류 토스트와 함께 완전한 소스 코드\n\n\n\n```js\nimport { toast } from 'react-hot-toast';\nimport Axios from 'axios';\n\nconst axios = Axios.create({\n  // 여러분의 API 기본 URL로 변경하세요\n  baseURL: 'https://fakerapi.it/api/v1',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\naxios.interceptors.response.use(\n  (response) => {\n    const data = response?.data;\n\n    console.log(data);\n\n    if (data?.message && typeof data?.message === 'string') {\n      toast.success(data.message);\n    } else if (data?.status && typeof data?.status === 'string') {\n      toast.success(data.status + ` - 상태 코드: ${data.code}`);\n    }\n\n    // 필요에 맞게 변경하세요\n    return data.data;\n  },\n  (error) => {\n    const data = error.response.data;\n\n    if (data?.message && typeof data?.message === 'string') {\n      toast.error(data.message);\n    } else if (data?.status && typeof data?.status === 'string') {\n      toast.error(data.status + ` - 상태 코드: ${data.code}`);\n    }\n\n    return Promise.reject(data);\n  }\n);\n\naxios.interceptors.request.use((config) => {\n  let token = 'your-bearer-token';\n\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  } else {\n    // 토큰이 없는 경우 처리\n    // 로그인 페이지로 리디렉션하거나 적절한 조치를 취할 수 있습니다\n  }\n\n  return config;\n});\n\nexport default axios;\n```\n\naxios 템플릿 코드를 문서에 추가했고, 아래 링크를 참조해주세요:\n\n[GitHub Gist](https://www.0cb.tech/jbbch)\n[실시간 코드 — StackBlitz](https://www.0cb.tech/fvopy)\n\n' embed https://stackblitz.com/edit/vitejs-vite-uqovqp?embed=1&file=src%2Flib%2Faxios.js '\n","ogImage":{"url":"/assets/img/2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling_0.png"},"coverImage":"/assets/img/2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling_0.png","tag":["Tech"],"readingTime":5},{"title":"env 변수 undefined","description":"","date":"2024-05-12 22:41","slug":"2024-05-12-envvariablesundefined","content":"\n\n애플리케이션을 구축할 때 VITE, REACT 또는 NEXT를 기반으로 하는 상황에 갇혀 과연 환경 변수를 어떻게 설정해야 할지 모를 때가 있나요?\n\n저 또한 예전에 여러분과 같은 상황에 처해 있었고, 고민 끝에 제 문제에 맞는 해결책을 찾기 위해 인터넷을 뒤적였어요.\n\n우리가 설치한 패키지/모듈의 공식 문서에 기재된 케이스와 맞지 않는 기능이 있는 프로젝트를 갖고 있는 경우가 많습니다. 따라서 이 게시물은 환경 변수와 여러분의 “상황\"에서 이를 작동시키는 방법에 대한 내용입니다.\n\n환경 변수란 정확히 무엇인가요?\n\n\n\n환경 변수는 단순히 프로젝트의 파일 시스템 전역에서 사용하려는 변수들입니다. 하지만 이를 인터넷에서 다른 사람들에게 공개하거나 보여주고 싶지는 않아요. 기본적으로 \"SECRET_KEY\"나 \"PUBLISHABLE_KEY\"와 같은 민감한 변수나 키들입니다. 이러한 종류의 키/변수는 .env라는 파일 안에 작성됩니다.\n\n이 .env 파일을 어떻게 만들까요?\n\n먼저 프로젝트 폴더에서 package.json 파일의 계층을 찾으세요. 그 후, 새 파일을 만들기 위해 마우스 오른쪽 버튼을 클릭하고 파일 이름을 \"env\"로 작성하세요. 정확하게 이렇게 작성해 주셔야 하며, 이렇게 하시면 환경 변수 파일이 생성됩니다.\n\n![이미지](/assets/img/2024-05-12-envvariablesundefined_0.png)\n\n\n\n.env 파일에 환경 변수를 어떻게 작성하나요?\n\n- Vite 애플리케이션(프론트엔드)에 환경 변수를 사용하려면 패키지(dotenv)를 설치할 필요가 없습니다. .env 파일을 생성하기만 하면 됩니다.\n\n```js\nVITE_YOUR_VARIABLE_NAME=SOMETHING\n```\n\n2. 마찬가지로 React 애플리케이션(프론트엔드)에 환경 변수를 사용하려면 패키지(dotenv)를 설치할 필요가 없습니다. .env 파일을 생성하기만 하면 됩니다.\n\n\n\n3. REACT 앱에서 변수를 선언하는 구문은 다음과 같습니다. 변수 이름은 'REACT_APP_' 프리픽스가 있어야 합니다. 그렇지 않으면 변수가 제대로 작동하지 않습니다.\n\n```js\nREACT_APP_YOUR_VARIABLE_NAME=SOMETHING\n```\n\n4. NEXT 앱에서 환경 변수를 선언할 때 변수는 아래와 같이 보여야 합니다. \"NEXT_PUBLIC_\" 프리픽스가 있어야만 제대로 작동합니다.\n\n```js\nNEXT_PUBLIC_YOUR_VARIABLE_NAME=SOMETHIN\n```\n\n\n\n<img src=\"/assets/img/2024-05-12-envvariablesundefined_1.png\" />\n\n5. 백엔드(server) 폴더에서 환경 변수를 선언하는 경우, dotenv이라는 패키지가 필요합니다.\n\n설치\n\nyarn과 npm은 우리가 인터넷에서 패키지를 다운로드하여 프로젝트에서 사용하고 멋진 것을 만들 수 있도록 도와주는 패키지 관리자입니다.\n\n\n\n```js\nnpm i dotenv\n```\n\n또는\n\n```js\nyarn add dotenv\n```\n\n5. 이제 서버 측 폴더의 index.js(루트 파일/진입점)에서 방금 설치한 이 패키지를 구성해야 합니다.\n\n\n\n```js\nconst dotenv = require(\"dotenv\")\ndotenv.config()\n```\n\n![2024-05-12-envvariablesundefined_2.png](/assets/img/2024-05-12-envvariablesundefined_2.png)\n\n다음에는 .env 파일을 만드는 방법에 언급된 것과 똑같은 절차를 수행합니다. 그러나 백엔드에서는 환경 변수의 이름을 원하는 대로 지정할 수 있습니다.\n\n```js\nMONGO_URL=SDAHKAFHKLJAHFLA\nJWT_KEY=FHALKHFLAHF\n```\n\n\n\n그 변수를 컴포넌트 파일에서 어떻게 접근할 수 있는지 알고 계신가요?\n\n프런트엔드\n\n- Vite 앱의 경우\n\n```js\nconst VARIABLE_NAME = import.meta.env.VITE_YOUR_KEY_VARIABLE_NAME\n```\n\n\n\n- React 앱용\n\n```js\nconst VARIABLE_NAME = process.env.REACT_APP_YOUR_KEY_VARIABLE_NAME\n```\n\n- Next 앱용\n\n```js\nconst VARIABLE_NAME = process.env.NEXT_PUBLIC_YOUR_VARIABLE_NAME\n```\n\n\n\n백엔드\n\n- 원하는 변수에 액세스하려면 process.env.VARIABLE_NAME을 사용해야 합니다.\n\n```js\nconst VARIABLE_NAME = process.env.YOUR_VARIABLE_NAME\n```\n\n최종 참고 사항:\n\n\n\n- VARIABLE_NAME을 대문자로 작성하는 것이 좋지만 casing은 당신에게 달려 있어요.\n- 환경 변수를 선언할 때 공백, 쉼표 또는 세미콜론을 사용하지 마세요.\n\n이제 프런트엔드와 백엔드를 위한 환경 변수 설정의 기술을 습득했어요. 어려움이 있으면 언제든 저에게 GitHub 또는 프로필 내 링크를 통해 연락해 주세요.\n\n마지막으로, 표준 최고의 실천 방법을 준수하면 개발 능력이 향상되고 다른 사람에게 전문성을 나타낼 수 있어요. 이 \"case\"에서는 대문자 또는 소문자 변수 이름 사용을 피하세요.","ogImage":{"url":"/assets/img/2024-05-12-envvariablesundefined_0.png"},"coverImage":"/assets/img/2024-05-12-envvariablesundefined_0.png","tag":["Tech"],"readingTime":3}],"page":"130","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}