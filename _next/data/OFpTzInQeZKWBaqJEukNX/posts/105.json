{"pageProps":{"posts":[{"title":"NET Core 6와 React JS를 활용한 제품 관리 애플리케이션 개발하기 CRUD 작업 포함","description":"","date":"2024-05-14 15:36","slug":"2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations","content":"\n\n<img src=\"/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png\" />\n\n# 소개\n\n이 글에서는 .NET Core 6을 사용하여 CRUD 작업을 수행하는 제품 관리 웹 API를 만들고 React JS의 도움으로 다양한 형식을 사용할 것입니다.\n\n# 사전 준비조건\n\n\n\n- Visual Studio 2022\n- VS Code\n- SQL Server\n- .NET Core SDK\n- Node JS\n\n# 제품 관리 응용 프로그램\n\n단계 1\n\n새 제품 관리 .NET Core Web API를 만드세요.\n\n\n\nStep 2\n\n데이터베이스 마이그레이션 및 SQL Server와의 연결에 사용하는 다음 NuGet 패키지를 설치하십시오.\n\n![NuGet Packages](/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_1.png)\n\nStep 3\n\n\n\nentities 폴더 안에 product 클래스를 추가해주세요.\n\n```js\nnamespace ProductManagementAPI.Entities\n{\n    public class Product\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public decimal Price { get; set; }\n    }\n}\n```\n\n4단계\n\ndata 폴더 안에 AppDbContext 클래스를 만들어 SQL Server 연결 및 DB 설정 속성을 추가해주세요.\n\n\n\n```cs\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Data\n{\n    public class AppDbContext : DbContext\n    {\n        public DbSet<Product> Products { get; set; }\n        protected readonly IConfiguration Configuration;\n        public AppDbContext(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n        protected override void OnConfiguring(DbContextOptionsBuilder options)\n        {\n            options.UseSqlServer(Configuration.GetConnectionString(\"DefaultConnection\"));\n            options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);\n        }\n    }\n}\n```\n\nStep 5\n\n리포지토리 폴더 내에 제품 리포지토리를 추가하세요.\n\nIProductRepository\n\n\n\n\n```js\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public interface IProductRepository\n    {\n        void AddProduct(Product product);\n        void DeleteProduct(int id);\n        List<Product> GetAllProducts();\n        Product GetProductById(int id);\n        void UpdateProduct(Product product);\n    }\n}\n```\n\nProductRepository\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public class ProductRepository : IProductRepository\n    {\n        private readonly AppDbContext _context;\n        public ProductRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n        public List<Product> GetAllProducts()\n        {\n            return _context.Products.ToList();\n        }\n        public Product GetProductById(int id)\n        {\n            return _context.Products.FirstOrDefault(p => p.Id == id);\n        }\n        public void AddProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n            _context.Products.Add(product);\n            _context.SaveChanges();\n        }\n        public void UpdateProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n            _context.Entry(product).State = EntityState.Modified;\n            _context.SaveChanges();\n        }\n        public void DeleteProduct(int id)\n        {\n            var product = _context.Products.Find(id);\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n            _context.Products.Remove(product);\n            _context.SaveChanges();\n        }\n    }\n}\n```\n\n단계 6\n\n\n\n\n위 코드를 사용하여 다양한 작업을 수행하는 새 제품 컨트롤러를 만들었습니다. 이제 이를 호출하면 우리의 프런트엔드 애플리케이션을 통해 다양한 작업을 수행할 수 있습니다.\n\n```js\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing ProductManagementAPI.Entities;\nusing ProductManagementAPI.Repositories;\n\nnamespace ProductManagementAPI.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductRepository _productRepository;\n        public ProductController(IProductRepository productRepository)\n        {\n            _productRepository = productRepository;\n        }\n        [HttpGet]\n        public IActionResult GetAllProducts()\n        {\n            var products = _productRepository.GetAllProducts();\n            return Ok(products);\n        }\n        [HttpGet(\"{id}\")]\n        public IActionResult GetProductById(int id)\n        {\n            var product = _productRepository.GetProductById(id);\n            if (product == null)\n            {\n                return NotFound();\n            }\n            return Ok(product);\n        }\n        [HttpPost]\n        public IActionResult AddProduct([FromBody] Product product)\n        {\n            if (product == null)\n            {\n                return BadRequest();\n            }\n            _productRepository.AddProduct(product);\n            return CreatedAtAction(nameof(GetProductById), new { id = product.Id }, product);\n        }\n        [HttpPut(\"{id}\")]\n        public IActionResult UpdateProduct(int id, [FromBody] Product product)\n        {\n            if (product == null || id != product.Id)\n            {\n                return BadRequest();\n            }\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n            _productRepository.UpdateProduct(product);\n            return NoContent();\n        }\n        [HttpDelete(\"{id}\")]\n        public IActionResult DeleteProduct(int id)\n        {\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n            _productRepository.DeleteProduct(id);\n            return NoContent();\n        }\n    }\n}\n```\n\n7단계\n\n앱 설정 파일을 열어 데이터베이스 연결 문자열을 추가하세요.\n\n\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"ConnectionStrings\": {\n    \"DefaultConnection\": \"Data Source=DESKTOP-8RL8JOG;Initial Catalog=ReactNetCoreCrudDb;User Id=sa;Password=database@1;\"\n  }\n}\n```\n\n**단계 8**\n\n서비스 컨테이너 내에서 서비스를 등록하고 미들웨어를 구성하세요.\n\n```csharp\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Repositories;\n\nvar builder = WebApplication.CreateBuilder(args);\n// 컨테이너에 서비스 추가\nbuilder.Services.AddScoped<IProductRepository, ProductRepository>();\nbuilder.Services.AddDbContext<AppDbContext>();\nbuilder.Services.AddCors(options => {\n    options.AddPolicy(\"CORSPolicy\", builder => builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());\n});\n\nbuilder.Services.AddControllers();\n// Swagger/OpenAPI 구성에 대해 더 자세히 알아보려면 https://aka.ms/aspnetcore/swashbuckle을 참조하세요\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\nvar app = builder.Build();\n// HTTP 요청 파이프라인 구성\napp.UseCors(\"CORSPolicy\");\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n\n\n9단계\n\n아래 엔터티 프레임워크 데이터베이스 마이그레이션 명령을 실행하여 데이터베이스와 테이블을 생성합니다.\n\n```js\nadd-migration \"v1\"\nupdate-database\n```\n\n10단계\n\n\n\n마지막으로, 애플리케이션을 실행하고 Swagger UI를 사용하여 다양한 API 엔드포인트를 실행하세요.\n\n![Swagger UI](/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_2.png)\n\nReact JS를 사용하여 클라이언트 애플리케이션을 생성하고 위의 API 엔드포인트를 이용해보세요.\n\n1단계\n\n\n\n다음 명령어를 사용하여 새 React JS 애플리케이션을 만들어 보세요:\n\nnpx create-react-app react-netcore-crud-app\n\n단계 2\n\n프로젝트 디렉토리로 이동하세요.\n\n\n\ncd react-netcore-crud-app\n\n**단계 3**\n\n백엔드 API를 소비하고 호출하기 위해 Axios를 설치하고 디자인을 위해 bootstrap을 설치하세요.\n\nnpm install axios\n\n\n\nnpm install bootstrap\n\n단계 4\n\n다음 컴포넌트 및 서비스를 추가하세요:\n\n제품 목록 컴포넌트.\n\n\n\n```js\n// src/components/ProductList/ProductList.js\nimport React, { useState, useEffect } from 'react';\nimport ProductListItem from './ProductListItem';\nimport productService from '../../services/productService';\n\nconst ProductList = () => {\n    const [products, setProducts] = useState([]);\n    useEffect(() => {\n        fetchProducts();\n    }, []);\n    const fetchProducts = async () => {\n        try {\n            const productsData = await productService.getAllProducts();\n            setProducts(productsData);\n        } catch (error) {\n            console.error('제품을 불러오는 중 오류가 발생했습니다:', error);\n        }\n    };\n    const handleDelete = async (id) => {\n        try {\n            await productService.deleteProduct(id);\n            fetchProducts(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 삭제 중 오류가 발생했습니다:', error);\n        }\n    };\n    const handleEdit = () => {\n        fetchProducts(); // 편집 후 제품 목록 새로고침\n    };\n    return (\n        <div className=\"container\">\n            <h2 className=\"my-4\">제품 목록</h2>\n            <ul className=\"list-group\">\n                {products.map(product => (\n                    <ProductListItem key={product.id} product={product} onDelete={() => handleDelete(product.id)} onEdit={handleEdit} />\n                ))}\n            </ul>\n        </div>\n    );\n};\nexport default ProductList;\n```\n\n제품 목록 항목 컴포넌트.\n\n```js\n// src/components/ProductList/ProductListItem.js\nimport React, { useState } from 'react';\nimport productService from '../../services/productService';\n\nconst ProductListItem = ({ product, onDelete, onEdit }) => {\n    const [isEditing, setIsEditing] = useState(false);\n    const [editedName, setEditedName] = useState(product.name);\n    const [editedPrice, setEditedPrice] = useState(product.price);\n    const handleEdit = async () => {\n        setIsEditing(true);\n    };\n    const handleSave = async () => {\n        const editedProduct = { ...product, name: editedName, price: parseFloat(editedPrice) };\n        try {\n            await productService.updateProduct(product.id, editedProduct);\n            setIsEditing(false);\n            onEdit(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 업데이트 중 오류가 발생했습니다:', error);\n        }\n    };\n    const handleCancel = () => {\n        setIsEditing(false);\n        // 수정된 값 초기화\n        setEditedName(product.name);\n        setEditedPrice(product.price);\n    };\n    return (\n        <li className=\"list-group-item\">\n            {isEditing ? (\n                <div className=\"row\">\n                    <div className=\"col\">\n                        <input type=\"text\" className=\"form-control\" value={editedName} onChange={e => setEditedName(e.target.value)} required />\n                    </div>\n                    <div className=\"col\">\n                        <input type=\"number\" className=\"form-control\" value={editedPrice} onChange={e => setEditedPrice(e.target.value)} required />\n                    </div>\n                    <div className=\"col-auto\">\n                        <button className=\"btn btn-success me-2\" onClick={handleSave}>저장</button>\n                        <button className=\"btn btn-secondary\" onClick={handleCancel}>취소</button>\n                    </div>\n                </div>\n            ) : (\n                <div className=\"d-flex justify-content-between align-items-center\">\n                    <span>{product.name} - ${product.price}</span>\n                    <div>\n                        <button className=\"btn btn-danger me-2\" onClick={onDelete}>삭제</button>\n                        <button className=\"btn btn-primary\" onClick={handleEdit}>편집</button>\n                    </div>\n                </div>\n            )}\n        </li>\n    );\n};\nexport default ProductListItem;\n```\n\n제품 서비스.\n\n\n\n\n```js\n// src/services/productService.js\nimport axios from 'axios';\n\nconst baseURL = 'https://localhost:7202/api/Product';\nconst productService = {\n    getAllProducts: async () => {\n        const response = await axios.get(baseURL);\n        return response.data;\n    },\n    addProduct: async (product) => {\n        const response = await axios.post(baseURL, product);\n        return response.data;\n    },\n    deleteProduct: async (id) => {\n        const response = await axios.delete(`${baseURL}/${id}`);\n        return response.data;\n    },\n    updateProduct: async (id, product) => {\n        const response = await axios.put(`${baseURL}/${id}`, product);\n        return response.data;\n    }\n};\nexport default productService;\n```\n\nApp component.\n\n```js\n// src/App.js\nimport React, { useState } from 'react';\nimport ProductList from './components/ProductList/ProductList';\nimport ProductForm from './components/ProductForm/ProductForm';\n\nfunction App() {\n    const [refresh, setRefresh] = useState(false);\n    const handleProductAdded = () => {\n        setRefresh(!refresh); // 상태를 토글하여 다시 렌더링을 트리거합니다.\n    };\n    return (\n        <div>\n            <ProductList key={refresh} />\n            <ProductForm onProductAdded={handleProductAdded} />\n        </div>\n    );\n}\nexport default App;\n```\n\n5단계\n\n\n\n\n다음 명령을 사용하여 응용 프로그램을 실행하고 동일한을 사용하여 다양한 CRUD 작업을 수행하십시오.\n\n![image](/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_3.png)\n\n# GitHub\n\nhttps://github.com/Jaydeep-007/React_NETCore_CRUD\n\n\n\n# 결론\n\n이 기사에서는 .NET Core 및 SQL Server를 사용하여 제품 관리 백엔드 응용 프로그램을 만들었고 CRUD 작업을 수행하는 데 필요한 다양한 API 엔드포인트를 만들었습니다. 나중에 React JS를 사용하여 프론트엔드 응용 프로그램을 만들었고 Axios의 도움을 받아 백엔드 응용 프로그램을 동일한 내에서 사용했습니다.","ogImage":{"url":"/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png"},"coverImage":"/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png","tag":["Tech"],"readingTime":14},{"title":"시맨틱 검색을 위한 MongoDB Atlas 시작하기","description":"","date":"2024-05-14 15:33","slug":"2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch","content":"\n\n## 최신 MongoDB Atlas Vector Search 기능을 소개합니다\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png)\n\n6월 22일, MongoDB가 Atlas Vector Search를 미리 보기 모드로 출시했습니다.\n\n이 새로운 기능을 사용해봤어요!\n\n\n\n테이블 태그를 마크다운 형식으로 바꾸세요.\n\n\n\n이 검색 방법은 텍스트, 오디오, 비디오 및 이미지와 같이 구조화되지 않은 데이터를 효과적으로 검색하기 위해 기계 학습 모델을 활용합니다. 이를 통해 검색 항목과 유사하거나 관련된 항목을 찾을 수 있습니다. 추천 시스템, 챗봇 또는 검색 엔진과 같은 여러 사용 사례에 활용됩니다.\n\n텍스트 데이터를 다룰 때 벡터 검색을 통해 정확한 검색어가 검색된 문장에 없더라도 비슷한 의미의 단어나 구를 찾을 수 있습니다.\n\n벡터 검색은 임베딩 개념을 기반으로 합니다.\n\n## Embeddings\n\n\n\n벡터 검색은 고급 머신 러닝 모델(encoders)을 사용하여 구조화되지 않은 입력 데이터의 수치적 표현을 제공하는 벡터 임베딩을 생성합니다.\n\n벡터 임베딩은 컴퓨터에게 일반적으로 이해하기 어려운 구조화되지 않은 데이터를 숫자 형식으로 변환합니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_1.png)\n\n임베딩은 주로 수치 값 배열인 고차원 벡터입니다. 이러한 벡터는 데이터의 맥락적 및 의미적 정보를 포함하고 있어 유의미한 비교와 계산을 수행할 수 있도록 합니다.\n\n\n\n예를 들어, 텍스트 임베딩 모델(인코더)은 구절 내 단어들 사이의 관계를 학습하여 문장의 의미와 맥락 정보를 포착하는 임베딩을 생성할 수 있습니다.\n\n![image](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_2.png)\n\n위 이미지에서 \"bovine buddies say\" 구절은 부동 소수점 숫자 배열([-0.005, 0.012, -0.008, ..., -0.010])로 인코딩되었습니다.\n\n벡터의 차원은 임베딩 모델에 따라 다르며 높을 수 있습니다(수천 개까지).\n\n\n\nMarkdown으로 테이블 태그를 변경하세요.\n\n\n\n## Atlas Vector Search\n\nAtlas Vector Search은 MongoDB Atlas의 새로운 기능으로, MongoDB의 검색 기능을 더욱 발전시킵니다.\n\nMongoDB Atlas Vector Search는 다음을 제공합니다:\n\n- 원하는 외부 ML 모델(OpenAI, Hugging Face 등)에서 생성된 임베딩 벡터를 보존하는 벡터 저장소;\n- 저장된 임베딩 벡터를 색인화하는 벡터 저장소 인덱스;\n- 저장된 벡터에서 의미 검색을 수행하기 위한 근사 최근 이웃(ANN) 알고리즘을 구현하는 검색 작업.\n\n\n\n몽고디비 Atlas Search를 사용하면 사용자는 기본 키워드 매칭 이상의 정보 검색 기능을 확장할 수 있습니다. 이 혁신적인 도구는 컨텍스트 인식 시맨틱 검색을 가능하게하여 사용자의 검색어에서 의미를 유추할 수 있도록 합니다.\n\n# 액션에서의 Atlas Vector Search\n\n이제 몽고디비 Atlas Vector Search의 새로운 기능을 시도해 보겠습니다.\n\n이 튜토리얼을 완료하기 위해 다음 단계를 실행해 보겠습니다:\n\n\n\n- 무료 MongoDB ATLAS 클러스터를 생성하세요.\n- 속담과 쿼리를 위한 MongoDB 컬렉션을 생성하세요.\n- Hugging Face API 토큰을 생성하세요.\n- 생성된 Hugging Face API 토큰을 Atlas에 임포트하세요.\n- Atlas Database Triggers 및 HF API 실행을 위한 함수를 만드세요.\n- 벡터 검색 인덱스를 생성하세요.\n- 속담 데이터셋을 MongoDB에 삽입하세요.\n- 의미론적 쿼리를 실행하세요.\n\n이번 튜토리얼에서는 Atlas UI만 사용하여 작업할 예정입니다.\n\n## 1. 무료 MongoDB ATLAS 클러스터 생성\n\n첫 번째 단계는 MongoDB Atlas 무료 클러스터(M0 클러스터)를 배포하는 것입니다.\n\n\n\n이 튜토리얼에서는 새로운 것을 만들기보다 기존의 Atlas 클러스터를 자유롭게 사용해도 괜찮습니다.\n\n## 2. 속담 및 질의를 위한 MongoDB 컬렉션 생성\n\n이 튜토리얼에서는 같은 데이터베이스에 속한 두 개의 컬렉션을 사용할 것입니다:\n\n- 속담과 그에 대한 내장 값을 저장하는 `vector_search.proverbs`\n- 질의와 답변을 저장하는 `vector_search.queries`\n\n\n\n데이터베이스와 컬렉션은 Atlas UI에서 생성됩니다.\n\n데이터베이스 배포에서 'Collections 찾아보기' 버튼을 클릭하십시오:\n\n![Collections 찾아보기](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_4.png)\n\n그런 다음 Collections 탭에서 + 데이터베이스 생성을 클릭하고 데이터베이스 이름 (vector_search), 첫 번째 컬렉션 이름 (proverbs)을 입력한 후 생성 버튼을 클릭하십시오.\n\n\n\nMarkdown 형식으로 테이블 태그를 바꿔 주세요:\n\n\n![이미지 1](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_5.png)\n\n두 번째 컬렉션을 만들기 위해 데이터베이스 vector_search를 선택하거나 호버한 후, 플러스(+) 아이콘을 클릭하세요.\n\n![이미지 2](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_6.png)\n\n다음으로 vector_search 데이터베이스 내에 queries 컬렉션을 생성하세요:\n\n\n\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_7.png\" />\n\n이제 여러분의 컬렉션이 준비되었어요.\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_8.png\" />\n\n## 3. Hugging Face API 토큰 생성\n\n\n\n프로버브에 대한 벡터 임베딩을 얻기 위해 무료 공개 Hugging Face 추론 API를 사용할 것입니다.\n\n텍스트 임베딩 API를 호출하기 전에 Hugging Face 사이트에서 읽기 액세스 토큰을 생성해야 합니다.\n\nHugging Face 웹사이트로 이동하여 로그인하거나 회원 가입하세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_9.png)\n\n\n\n로그인한 후 오른쪽 상단으로 이동하여 프로필 아이콘을 클릭하고 설정을 선택하세요. 그런 다음 프로필 설정 페이지 왼쪽에 있는 Access Tokens를 클릭하고 New Token 버튼을 누르세요.\n\n![Access Tokens](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_10.png)\n\n토큰에 이름을 지정하고 read 역할을 선택한 후 Generate a token을 클릭하세요.\n\n![Generate a Token](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_11.png)\n\n\n\n위의 생성된 토큰을 안전한 위치에 복사하여 저장해주세요.\n\n![image](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_12.png)\n\n## 4. 아틀라스로 허깅 페이스 API 토큰 가져오기\n\nHF API를 호출하기 전에 먼저 아틀라스에 이전에 생성된 허깅 페이스 토큰을 가져와야 합니다.\n\n\n\nAtlas UI의 App Services 페이지로 이동해주세요:\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_13.png)\n\nTriggers 애플리케이션(가장 왼쪽 상자)을 클릭한 후, 왼쪽 메뉴에서 Values를 선택하고, Create New Value 버튼을 클릭해주세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_14.png)\n\n\n\n가장 먼저 할 일은 비밀을 만드는 것입니다. 값을 HF_secret로 지정하고 유형을 Secret으로 선택하여 허깅페이스 토큰을 Add Content 필드에 붙여넣은 다음 저장을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_15.png)\n\n그런 다음, 함수에서 사용할 새 환경 변수를 생성해야 합니다. 이를 위해 오른쪽 상단 버튼의 Create New Value를 다시 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_16.png)\n\n\n\nHF_value라는 이름의 Value 타입의 값을 생성하고 Secret HF_secret에 링크를 걸고 저장을 누르세요. 아래에서 정확히 수행한 것을 따라해주세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_17.png)\n\n## 5. Atlas 데이터베이스 트리거 및 함수 생성하여 HF API 호출하기\n\nAtlas UI에서 우리는 격언 및 쿼리 컬렉션에 데이터베이스 트리거를 정의할 수 있습니다. 이를 통해 이 컬렉션에 새 문서가 삽입될 때마다 Hugging Face API를 호출할 수 있습니다.\n\n\n\n데이터베이스 트리거를 생성하려면 데이터베이스 배포로 이동한 다음 왼쪽 탐색 메뉴에서 트리거를 클릭하십시오.\n\n\"트리거 추가\" 버튼을 클릭하여 새 트리거를 구성할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_18.png)\n\nHF_Create_Embeddings 트리거\n\n\n\nvector_search.proverbs 컬렉션에 대한 첫 번째 트리거인 HF_Create_Embeddings을 생성했습니다. 아래와 같이 트리거를 구성하세요:\n\n![trigger configuration](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_19.png)\n\n함수 섹션에서 Function을 이벤트 유형으로 선택하고, 다음의 자바스크립트 함수 코드를 아래 코드 블록에 붙여넣으세요.\n\n![javascript function code](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_20.png)\n\n\n\n위 양식에 붙여넣을 코드는 다음과 같습니다:\n\n```js\nexports = async function(changeEvent) {\n    // 변경 이벤트에서 전체 문서를 가져옵니다.\n    const doc = changeEvent.fullDocument;\n\n    // Hugging Face API의 URL과 키를 정의합니다.\n    const url = 'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2';\n    // App Services 내부의 \"Values\" 유틸리티에서 API 키의 값을 지정한 이름을 사용합니다.\n    const hf_read_token = context.values.get(\"HF_value\");\n\n    try {\n        console.log(`ID가 ${doc._id}인 문서 처리 중`);\n\n        // Hugging Face API를 호출하여 임베딩을 가져옵니다.\n        let response = await context.http.post({\n            url: url,\n            headers: {\n                'Authorization': `Bearer ${hf_read_token}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                // 문서 내 데이터를 임베딩할 필드를 지정합니다. 여기서는 샘플 속담 데이터의 \"proverb\" 필드를 사용합니다.\n                inputs: [doc.proverb]\n            })\n        });\n\n        // JSON 응답을 파싱합니다.\n        let responseData = EJSON.parse(response.body.text());\n\n        // 응답 상태를 확인합니다.\n        if(response.statusCode === 200) {\n            console.log(\"임베딩을 성공적으로 받았습니다.\");\n\n            const embedding = responseData[0];\n\n            // MongoDB Atlas에서 클러스터를 가져옵니다.\n            const mongodb = context.services.get('Cluster0');\n            const db = mongodb.db('vector_search'); // 데이터베이스명으로 변경하세요.\n            const collection = db.collection('proverbs'); // 컬렉션명으로 변경하세요.\n\n            // MongoDB에서 문서를 업데이트합니다.\n            const result = await collection.updateOne(\n                { _id: doc._id },\n                // 새로운 필드에 임베딩을 저장할 이름을 지정합니다.\n                { $set: { proverb_embedding: embedding }\n            );\n\n            if(result.modifiedCount === 1) {\n                console.log(\"문서를 성공적으로 업데이트했습니다.\");\n            } else {\n                console.log(\"문서를 업데이트하는 데 실패했습니다.\");\n            }\n        } else {\n            console.log(`임베딩을 받는 데 실패했습니다. 상태 코드: ${response.statusCode}`);\n        }\n\n    } catch(err) {\n        console.error(err);\n    }\n};\n```\n\n트리거 HF_Create_Embeddings는 속담 콜렉션에 삽입된 각 속담에 대한 벡터 임베딩을 얻기 위해 Hugging Face all-MiniLM-L6-v2 모델 API를 호출합니다.\n\nSemantic_Query 트리거\n\n\n\n두 번째 트리거는 쿼리 컬렉션에 생성될 것입니다. 트리거 함수에서는 Hugging Face 임베딩 모델을 호출하여 사용자 쿼리의 임베딩을 가져와 MongoDB 집계 명령을 통해 벡터 검색을 실행할 것입니다.\n\n벡터 검색 결과는 쿼리 컬렉션에 저장될 것입니다.\n\n두 번째 트리거를 만들려면, 첫 번째 트리거와 동일한 프로세스를 따르되, 다음에 설명된 매개변수를 조정해야 합니다 (다른 모든 매개변수 값은 이전과 동일합니다):\n\n이름 Semantic_Query\n\n\n\n컬렉션 이름 쿼리\n\n함수 코드에 다음 블록을 붙여 넣으세요:\n\n```js\nexports = async function(changeEvent) {\n    // 변경 이벤트에서 전체 문서 가져오기\n    const doc = changeEvent.fullDocument;\n\n    // Hugging Face API URL 및 키 정의\n    const url = 'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2';\n    // App Services 내의 \"Values\" 유틸리티에서 API 키의 값을 설정한 이름을 사용\n    const hf_read_token = context.values.get(\"HF_value\");\n\n    try {\n        console.log(`아이디가 ${doc._id}인 문서 처리 중`);\n\n        // 쿼리의 임베딩을 가져오기 위해 Hugging Face API 호출\n        let response = await context.http.post({\n            url: url,\n            headers: {\n                'Authorization': `Bearer ${hf_read_token}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                // 데이터를 임베딩할 문서 내 필드. 여기선 \"queries\" 컬렉션의 \"query\" 필드입니다.\n                inputs: [doc.query]\n            })\n        });\n\n        // JSON 응답 파싱\n        let responseData = EJSON.parse(response.body.text());\n\n        // 응답 상태 확인\n        if (response.statusCode === 200) {\n            console.log(\"임베딩 성공적으로 수신\");\n\n            const embedding = responseData[0];\n\n            // MongoDB Atlas에서 클러스터 가져오기\n            const mongodb = context.services.get('Cluster0');\n            const db = mongodb.db('vector_search'); // 데이터베이스 이름으로 대체\n            const proverbs_collection = db.collection('proverbs'); // 컬렉션 이름으로 대체\n            const queries_collection = db.collection('queries'); // 컬렉션 이름으로 대체\n\n            // 유사 문서 쿼리\n            const documents = await proverbs_collection.aggregate([\n                {\n                    \"$search\": {\n                        \"index\": \"vector_search_index\",\n                        \"knnBeta\": {\n                            \"vector\": embedding,\n                            \"path\": \"proverb_embedding\",\n                            \"k\": 2\n                        }\n                    }\n                },\n                {\n                    \"$project\": {\n                        \"_id\": 0,\n                        \"proverb\": 1\n                    }\n                }\n            ]).toArray();\n            \n            // MongoDB에서 문서 업데이트\n            const result = await queries_collection.updateOne(\n                { _id: doc._id },\n                // \"answer\" 필드에 쿼리 결과가 포함됩니다.\n                { $set: { query_embedding: embedding, answer: documents }\n            });\n\n        } else {\n            console.log(`임베딩 수신 실패. 상태 코드: ${response.statusCode}`);\n        }\n\n    } catch(err) {\n        console.error(err);\n    }\n};\n```\n\n## 6. 벡터 탐색 인덱스 생성\n\n\n\n우리는 직역 검색을 가능하게 하기 위해 속담 모음에 벡터 검색 인덱스를 생성해야 합니다. 속담 모음은 우리의 쿼리에 응답하기 위해 검색될 속담 문장의 임베딩(proverb_embedding 필드)을 포함할 것입니다.\n\n인덱스를 생성하려면 다음을 수행하세요. Atlas Search로 이동: 데이터베이스 배포 페이지에서 왼쪽 메뉴에서 검색을 클릭한 후, 데이터 원본 선택 드롭다운 메뉴에서 클러스터를 선택하고 Go to Atlas Search 버튼을 누릅니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_21.png)\n\n새로운 검색 인덱스를 구성하려면 Create Search Index 버튼을 클릭하세요:\n\n\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_22.png)\n\n다음 페이지에서 JSON Editor 상자를 선택하고 Next 버튼을 누르세요:\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_23.png)\n\n데이터베이스 및 컬렉션 영역에서 vector_search 데이터베이스와 proverbs 컬렉션을 선택하고, Index Name 필드에 vector_search_index라는 인덱스 이름을 지정하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_24.png\" />\n\n다음 JSON 문서를 텍스트 영역에 붙여넣고 '다음' 버튼을 클릭해주세요.\n\n```js\n{\n  \"mappings\": {\n    \"dynamic\": true,\n    \"fields\": {\n      \"proverb_embedding\": {\n        \"dimensions\": 384,\n        \"similarity\": \"dotProduct\",\n        \"type\": \"knnVector\"\n      }\n    }\n  }\n}\n```\n\n'검색 인덱스 생성'을 클릭하면 인덱스 생성이 시작됩니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_25.png\" />\n\n곧 새로운 인덱스가 활성 상태로 사용 가능할 것입니다.\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_26.png\" />\n\n## 7. 경구 데이터 세트를 MongoDB에 삽입하기\n\n\n\n우리는 임베딩 스토어를 채우기 위해 영어 속담을 속담 컬렉션에 삽입할 것입니다. Atlas UI에서 하나의 속담을 추가할 것입니다.\n\n우리가 삽입하는 첫 번째 속담은 다음과 같습니다:\n\n속담을 삽입하려면:\n\n- 데이터베이스 배포 페이지에서 Browse Collections로 이동하세요.\n- vector_search 데이터베이스 아래에 있는 proverbs 컬렉션을 선택하세요.\n- \"proverb\"를 필드 이름으로 하고 속담 문장을 값으로 하는 단일 필드 문서를 추가하세요.\n- 그런 다음 삽입을 눌러주세요.\n\n\n\n마법처럼 새로운 필드인 'proverb_embedding'이 문서에 추가됩니다:\n\n'proverb_embedding' 필드에는 HF_Create_Embeddings 트리거에서 호출된 Hugging Face 텍스트 임베딩 모델 API에 의해 생성된 임베딩 벡터(384개의 부동 소수점 요소가 있는 배열)가 포함되어 있습니다.\n\n\n\n자세한 것은 나중에 업데이트됩니다.\n\n\n\n늦게라도 하는 것이 낫죠.\n\n호기심은 고양이를 죽인다고 해요.\n\n불에 노는 바보는 불에 탄다고 하잖아요.\n\n정의를 미루면 결국 물거품이 돼버립니다.\n\n\n\n밤은 충고를 안겨줍니다.\n\n로마는 하루 만에 지어지지 않았어요.\n\n울타리 너머에 있는 잔디가 더 푸릅니다.\n\n우리 속담 컬렉션에는 10개의 문서가 있어요.\n\n\n\n<img src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_29.png\" />\n\n## 8. Semantic queries 실행하기\n\n검색을 실행하기 위해 쿼리 컬렉션에 단일 필드 문서를 삽입할 것입니다. 필드 이름은 \"query\"이고 값은 다음과 같이 우리 검색어의 텍스트입니다:\n\n' \"query\": \"Things that look good outwardly may not be as valuable or good.\"'\n\n\n\n새로운 문서가 쿼리 컬렉션에 삽입되면 `Semantic_Query` 트리거가 실행됩니다:\n\n- 속담 문장을 전달하여 쿼리의 임베딩을 얻기 위해 Hugging Face API를 호출합니다.\n- 받은 임베딩 벡터를 문서 자체에 저장합니다 (query_embedding 필드).\n- MongoDB 집계 명령어를 통해 vector_search_index에서 벡터 검색을 실행합니다.\n- 검색 결과를 문서 자체에 저장합니다 (answer 필드).\n\n쿼리를 테스트하려면 \"Collections\" 탭으로 이동하여 쿼리 컬렉션에 쿼리를 삽입하세요:\n\n![2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png)\n\n\n\n여기 답변이 있어요:\n\n![image](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_31.png)\n\n우리 질문과 가장 유사한 의미를 가진 속담 두 개는 다음과 같습니다:\n\n\"반짝이는 것이 모두 금은 아니다.\" 그리고 \"만능 재주꾼은 아무것도 제대로 할 수 없다.\"\n\n\n\n정답이 잘 보입니다! 데이터셋과 쿼리를 실험해 볼 수 있습니다. 또한 OpenAI 텍스트 임베딩 API와 같은 다양한 임베딩 모델을 테스트하여 응답의 정확성을 평가할 수도 있습니다.\n\n# 참고 자료\n\n- MongoDB Atlas 매뉴얼\n- MongoDB Atlas 벡터 검색\n- MongoDB Atlas 검색 튜토리얼\n- 일반적인 영어 속담\n- Hugging Face 텍스트 임베딩 모델\n\nMongoDB에 대한 지식을 확장하고 싶다면 How MongoDB Works에 대한 제 논문을 살펴보세요.\n\n\n\n제가 쓰는 이야기를 좋아해주시고 지원하고 싶으시다면, Medium 회원이 되어서 지원해주실 수 있어요. 매달 $5를 내면 Medium의 모든 이야기에 무제한 액세스할 수 있어요. 저의 추천 링크를 사용해서 가입하면, 작은 커미션을 받을 수 있어요. 고려해 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png","tag":["Tech"],"readingTime":15},{"title":"리액트에서의 동적 임포트","description":"","date":"2024-05-14 15:30","slug":"2024-05-14-DynamicImportsinReact","content":"\n\n![Dynamic Imports in React](/assets/img/2024-05-14-DynamicImportsinReact_0.png)\n\nReact에서의 동적 가져오기는 런타임에서 JavaScript 모듈을 동적으로로드할 수 있게 해줍니다. 이는 응용 프로그램의 성능과로드 시간을 크게 향상시킬 수 있습니다. 이 기술은 코드 분할 및 지연 로드에 특히 유용하며 필요할 때만 필요한 코드를로드합니다.\n\nimport() 함수는 사용하고자하는 동적 가져오기 모듈로 해결되는 Promise를 반환합니다.\n\nJavaScript의 일반적인 import문(import 문을 사용)은 Promise를 반환하지 않습니다. 동기 작업이므로 가져온 모듈에서 내보낸 값을 반환합니다.\n\n\n\n```js\r\nimport React from 'react';\n\nconst AnotherComponent = () => {\n  return <div>다른 컴포넌트가 동적으로 로드되었습니다!</div>;\n};\n\nexport default AnotherComponent;\r\n```\n\n```js\r\nconst MyComponent = () => {\n  const [importedComponent, setImportedComponent] = useState(null);\n\n  useEffect(() => {\n    const importComponent = async () => {\n      const module = await import('./AnotherComponent');\n      const AnotherComponent = module.default;\n      setImportedComponent(<AnotherComponent />);\n    };\n\n    importComponent();\n  }, []);\n\n  return (\n    <div>\n      {importedComponent}\n      <div>이것은 내 기능적인 컴포넌트입니다!</div>\n    </div>\n  );\n};\n\n///다른 방법은 ...///\nconst MyComponent = async () => {\n  const module = import('./AnotherComponent');\n  const {AnotherComponent} = await module;\n  return <AnotherComponent />;\n};\n\nexport default MyComponent;\n\n// 콘솔에서 내보낸 모듈을 확인할 때 { default: \"\"}는 모든 함수 이름을 키로 하고 \n// 값으로 정의를 포함하며, default 키가 있으면 default로 가져온 것이 값이 되고, \n// 그렇지 않으면 정의가 없는 것이 됩니다.\r\n```\n\n## 동적 가져오기를 언제 사용해야 할까요?\n\n동적 가져오기는 React 애플리케이션의 성능을 향상시키는 좋은 방법이지만, React 앱에서 동적 가져오기를 사용하는 더 좋은 사용 사례가 있습니다.\n\n\n\n- 코드 모듈화: 동적 가져오기는 코드 모듈화와 서버에서 데이터를 가져올 필요가 있을 때 사용할 수 있습니다. 예를 들어 서버 측 렌더링 애플리케이션에서 이를 사용할 수 있습니다.\n- 애플리케이션이 아직 로딩 중인 경우 컴포넌트가 필요하지 않을 때 동적 가져오기를 사용할 수 있습니다.\n- 조건부 가져오기는 동적 가져오기에 대한 우수한 사용 사례입니다. 여기서 모듈 또는 컴포넌트는 필요한 페이지에서만 가져오며 애플리케이션에서 필요한 경우에만 가져옵니다.\n\n## React.lazy()\n\nReact.lazy() 함수를 사용하면 동적 가져오기를 일반 컴포넌트로 렌더링할 수 있습니다. 기본적으로 React.lazy()는 동적 가져오기를 호출하고 프로미스를 반환합니다.\n\n```js\nimport React, { lazy } from \"react\";\nconst Blog = React.lazy(() => \n  import('./Pages/Blog'));\n```\n\n\n\n# React.Suspense()\n\nReact.Suspense는 React 개발자가 React 컴포넌트의 렌더링을 로드될 때까지 중단시킬 수 있게 합니다. React.Suspense는 JSX 코드 조각 또는 React 컴포넌트인 React 요소를 허용하는 fallback 속성을 제공합니다.\n\nReact 동적 임포트를 이용해 페이지를 방문하는 사용자들은 종종 빈 페이지 화면을 경험합니다. 이는 애플리케이션이 모듈을 로드하는 동안 수행되며, 일부 사용자는 느린 인터넷 연결로 인해 오류가 발생할 수도 있습니다. React.lazy()와 React.Suspense를 결합하여 이 문제를 해결할 수 있습니다.\n\n이를 위해 React.Suspense를 사용하여 모든 종속성이 지연 로드될 때까지 컴포넌트의 렌더링을 중단하고, React.Suspense는 사용자를 위한 대체 UI를 표시할 것입니다.\n\n\n\n```js\nimport React, { Suspense } from 'react';\n\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n\nconst App = () => {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <LazyComponent />\n      </Suspense>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n알고 싶은 내용이 있다면 구독, 박수, 좋아요 및 공유하세요. 건배!","ogImage":{"url":"/assets/img/2024-05-14-DynamicImportsinReact_0.png"},"coverImage":"/assets/img/2024-05-14-DynamicImportsinReact_0.png","tag":["Tech"],"readingTime":3},{"title":"작별인사, Ramda","description":"","date":"2024-05-14 15:28","slug":"2024-05-14-FarewellRamda","content":"\n\n## 옛날 코드를 해독하느라 수고스러운 적이 있으신가요? 종종 Ramda가 관련되어 복잡한 작업을 하게 만들어 다른 간단한 대안을 찾게 했었죠.\n\n![Ramda 이미지](/assets/img/2024-05-14-FarewellRamda_0.png)\n\n# 소개\n\n두 해 전의 코드를 만나서 변경을 하려고 애를 쓰시는 일이 있었나요? 수정할 곳을 찾기 위해 많은 시간을 들이지만 어디서 어떻게 변경을 해야 할지 알 수 없는 경우가 많아요. 가끔 그럴 때마다, 아주 놀라운 일인데 고대 문명의 암호화된 메세지를 해독하려는 느낌과도 같은 것이었어요. 저는 이런 경험을 여러 차례 해왔는데, 대부분 Ramda가 관련되어 있었습니다. 이 경험이 중복됨을 느끼며, 대안을 탐구하고 제 코드 유지보수 전략을 재고하게 되었죠.\n\n\n\n# 새로운 Ramda의 탐험\n\nRamda는 함수형 프로그래밍 원칙을 받아들이고 견고한 유틸리티 함수 세트를 제공하여 여러분을 강력하게 지원하는 환상적인 JavaScript 라이브러리입니다. 이 라이브러리는 불변 데이터를 다루고 함수를 조합하며 코드에 선언적인 풍미를 불어넣는 데 주력합니다. Ramda를 사용하면 자동으로 커링이 될 뿐만 아니라 함수를 부드럽게 조합하고 불변 데이터를 간편하게 다룰 수 있습니다. 또한, 함수의 인수를 명시적으로 언급하지 않고 정의하는 포인트프리 스타일의 우아함을 받아드리도록 격려합니다. Ramda는 JavaScript 프로젝트에서 함수형 프로그래밍을 더 접근하기 쉽고 표현력있고 즐거운 경험으로 만들어냅니다.\n\nRamda를 사용하기 시작했을 때, \"와우\" 효과를 경험했습니다. 선언적인 코드가 얼마나 우아해졌는지를 즐겼고, 툴킷의 유용한 함수들 덕분에 복잡한 논리를 한 문장으로 표현할 수 있었습니다. Ramda로 과제를 해결할 때마다 뇌에서 보상 느낌을 받았습니다. 더 많은 논리를 통합할 수 있었을 때 더 큰 만족감을 느꼈습니다. 또한 이 같은 감정 이외에도 Ramda는 데이터 불변성 유지, 선언적 표현을 강화하고 편리한 도우미 함수 세트를 통해 루틴 작업을 해결하는 등 여러 가지 방법으로 코드를 획기적으로 개선시켰습니다.\n\n# Ramda의 쇠퇴와 JavaScript의 부흥\n\n\n\n그러나 JavaScript가 진화함에 따라 저와 많은 동료들은 Ramda, Lodash 등의 라이브러리를 대체하여 언어의 기본 도구와 기능을 점차적으로 더 많이 활용하게 되었습니다.\n\n어떤가요? 언어의 기본 기능만을 사용하여 간단하고 깔끔한 코드를 작성하는 그 기분이 참 달콤하지 않나요? 제가 생각하기에 우리 모두가 한 번쯤은 느꼈을 거에요. 개발자로서 우리는 무엇을 가장 잘 알고 있는지에 자주 익숙해지는 경향이 있습니다. 그래서 이 경우에는 구식이지만 좋은 기존의 네이티브 JavaScript에 더 많이 기댈 때가 많아요.\n\n마치 꾸준하고 깔끔한 컵 커피를 즐기는 것처럼, 네이티브 JavaScript로 작업하는 것에는 특별한 즐거움이 있습니다. 이것은 우리에게 새로운 라이브러리의 세세한 사항을 배우지 않고도 즉시 시작할 수 있는 익숙함과 직관성을 제공해줍니다.\n\nES5 시절부터 ES2015, ES2017를 거쳐 새롭고 화려한 ES2020까지 자바스크립트는 크게 성장했습니다. 각 업데이트는 새로운 멋진 기능을 가져와 우리의 코딩 생활을 훨씬 더 간단하게 만들어주었으며, 자바스크립트 코드의 기능 및 선언적 성격을 크게 향상시켰습니다.\n\n\n\n먼저 배열을 다루는 map(), reduce(), filter()와 같은 고차 함수부터 시작해보죠. 이제 이들은 쉬울 정도로 쉽게 느껴졌어요. 만만한 일이었죠.\n\n다음으로 멋진 화살표 함수가 등장했어요. 이런 신규 추가 기능들은 간결하고 직관적이었어요. 코드를 읽고 이해하기 쉽게 만들어 주었죠.\n\n이어서 템플릿 리터럴이 등장했는데, 이것들은 문자열 다루기를 바꿔 놓았어요. 더 이상 복잡한 연결 작업은 사라지고, 부드럽고 신뢰할 수 있는 문자열 생성만 남았죠.\n\n펼침 구문은 또 다른 유용한 추가였어요. 배열이나 객체를 확장하거나 변경 불가능성을 유지하는 것이 쉬워졌죠. 마지막으로 파괴 할당, 옵셔널 체이닝, 널 병합 연산자라는 유용한 세 가지를 갖게 되었어요. 이들은 코드를 더 쉽고 눈에 잘 들어오도록 만들어 주었어요.\n\n\n\n네이티브 JavaScript 기능을 사용하면 익숙함과 간편함을 느낄 수 있어요. 이런 친숙함 덕분에 개발자들은 학습 과정 없이도 생성할 수 있어요. 우리 많은 이들은 이 언어의 핵심에 매료되어 있어요. JavaScript의 핵심이자 경량화되고 유연한 네이티브 기능들은 JavaScript의 핵심이자 최적화가 고려된 성능 또한 가지고 있어요.\n\n예를 들어, 람다(Ramda)와 같은 라이브러리는 코드를 추가적인 추상적인 단계로 둘러싸지만, 네이티브 JavaScript는 빠른 속도로 실행됩니다.\n\nJavaScript 엔진인 V8과 같은 엔진의 최적화로 이러한 기능들은 더욱 발전합니다. V8의 개발자들은 지속적으로 네이티브 기능들에 최적화를 진행하고 있어요. 이는 JavaScript 코드가 원활하고 빠르게 실행되도록 보장해줍니다. JavaScript 코드가 웰오일 된 기계처럼 돌아가게 해줘요.\n\n하지만 속도만이 중요한 것은 아니에요. 통합성과 호환성도 중요해요. 이러한 네이티브 기능은 다른 언어의 부분들과 원활하게 연계되어 작동하며, 다양한 API와 JavaScript의 광범위한 생태계와 조화롭게 작동해요.\n\n\n\n네이티브 JavaScript의 또 하나의 장점은 다양한 ECMAScript 버전과의 호환성 및 최소한의 종속성을 가지고 있다는 것입니다. 지속적인 ECMAScript 업데이트로 계속해서 발전하는 이 언어는 많은 개발자들에게 최고의 선택지입니다. 원래 것이 이렇게 잘되는데 새로운 것을 찾아야 할 이유가 무엇인가요?\n\n# \"람다마이즈드\" TypeScript에 머리를 쥐어박다\n\n프로젝트를 TypeScript로 전환하고 기존의 람다 코드를 통합하려고 할 때 새로운 문제가 발생할 수 있습니다. TypeScript는 정적 타입을 제공하여 코드 안전성을 향상시키고 개발자 생산성을 증가시키는 장점을 제공합니다. 그러나 TypeScript에 람다를 섞을 때는 타이핑 접근 방식과 호환성의 차이로 인해 약간 까다로워질 수 있습니다.\n\n람다 함수에서 사용하는 타입이 TypeScript typings와 일치하는지 확인하는 것이 주요한 고민거리입니다. 람다는 일부 TypeScript typings을 제공하지만 모든 시나리오를 다루지 못하거나 최신 람다 버전과 호환되지 않을 수 있습니다. 이로 인해 기대하는 타입과 추론된 타입 간의 불일치가 발생할 수 있어 소매를 걷어 올리고 타입 주석을 수동으로 처리하거나 사용자 정의 typings를 생성해야 할 수도 있습니다.\n\n\n\n또 다른 도전 과제는 Ramda의 함수형 프로그래밍 스타일인데, 함수 커링과 함수 조합이 있어 복잡할 수 있어요. TypeScript의 타입 추론은 이러한 각종 마무리를 따라가기에 어려울 수 있어요. 그래서 명시적인 타입 주석을 추가하거나 추가적인 어서션을 해야 모든 것이 제자리에 있도록 관리할 수 있어요. 이건 좀 복잡해지며 코드를 읽기 어렵고 유지보수하기 힘들 수 있어요.\n\n더군다나, Ramda 코드가 TypeScript를 염두에 두지 않고 작성됐다면, 적절한 타입 주석과 문서가 부족할 수 있어요. 이는 TypeScript 규칙을 맞추고 타입 안전성을 보장하기 위해 코드 베이스를 리팩토링하고 적응시키기 위해 추가 시간과 노력을 투자해야 할 수 있다는 걸 의미해요.\n\n한편, TypeScript와 함께 네이티브 JavaScript 기능을 사용하면 이러한 문제들을 해결할 수 있어요. TypeScript가 걱정 없이 타입을 정확하게 처리할 수 있어서 여러분의 삶을 훨씬 쉽게 만들 수 있어요. 원활한 통합과 향상된 TypeScript 지원은 네이티브 JavaScript 기능을 TypeScript 프로젝트에 매력적인 옵션으로 만들어 줘요, 특히 타입 안전성과 효과적인 개발을 목표로 할 때 더욱 그렇답니다.\n\n# 말은 그만하고 코드를 보여줘\n\n\n\nRamda로 작성된 이 코드를 살펴보겠습니다. 이 코드는 매우 복잡한 논리를 수행하지는 않습니다. 상황 자체는 꽤 직관적입니다. 그러나 이에도 불구하고 이 스니펫의 논리를 이해하기 위해 내 두뇌는 노력해야 합니다.\n\n```js\nconst result = R.pipe(\n  R.filter(R.both(\n    R.propSatisfies(R.gt(R.__, 25), 'age'),\n    R.pathEq(['address', 'country'], 'USA')\n  )),\n  R.map(R.prop('name'))\n)(users)\n\n// 🤔 🤔 🤔\n```\n\n이 코드는 사용자의 나이와 거주 국가에 따라 사용자 목록을 필터링하며, 특히 미국에 거주하며 25세 이상인 사용자를 찾습니다. 위의 Ramda 예시는 R.pipe()를 사용하여 다중 작업을 연결해 함수형 프로그래밍 원리를 적용합니다. 논리가 제일 복잡한 것은 아니지만, 함수들의 계층적인 조합은 이해하기 위해 잠깐의 고민(또는 두 번의 고민)이 필요합니다.\n\n이를 Lodash로 다시 작성하여 좀 더 나은 코드로 만들어볼 수 있습니다\n\n\n\n```js\nconst resultL2 = _.map(\n  _.filter(\n    users,\n    user => user.age > 25 && user.address.country === 'USA'\n  ),\n  'name'\n)\n\n// 👌👌👌\n```\n\n바로 Lodash 버전은 더 친근하다 느껴집니다. filter()와 map()을 사용해 콜백 함수 내에서 필터 조건을 직접적으로 표현하여 우리의 삶을 간단하게 만들어 줍니다. 그럼에도 불구하고 개선의 여지가 있다면, 더 간소화할 수 있는 방법은 여전히 남아 있습니다.\n\n더 나아가서 이를 순수 JavaScript만 사용하여 다시 작성해 보겠습니다:\n\n```js\nconst result = users\n  .filter(\n    user => user.age > 25 && user.address.country === 'USA'\n  )\n  .map(user => user.name)\n\n// 🥹🥹🥹\n```\n\n\n\n아름다운!\n\n구문은 간단하고 직관적이며 핵심 논리에서 우리 주의를 분산시키는 추상화 요소가 없습니다. 읽고 이해하기 쉬운 작업 목록이 표시됩니다. 동일한 필터링 및 매핑 작업을 수행하기 위해 filter() 및 map() 배열 메서드를 사용합니다. 필터링 조건은 콜백 함수 내부에 직접 작성되어 코드 스니펫을 더 읽기 쉽게 만듭니다. 실제로, 심지어 내 할머니도 이 코드를 읽어낼 수 있을 것 같아요.\n\n전통적 코딩 스타일에 익숙한 사람들은 Ramda의 함수형 프로그래밍 및 커링 사용량이 많고 사용되는 이름 짓기 관행 때문에 코드를 이해하기 어려울 수 있습니다. 특히 프로젝트 내에서 다른 코드 스타일 사이를 전환해야 할 때는 더 어려울 수 있습니다. 본질적으로 특정 관행에 익숙하지 않은 경우 Ramda 코드를 읽는 것은 퍼즐을 푸는 것과 같을 수 있습니다. 이러한 낯설음으로 인해 여러 코딩 패러다임을 동시에 처리할 때 특히 읽고 따라가기 어려울 수 있습니다.\n\n# 일부 변론의 말씀\n\n\n\n잘못 이해하지 마세요. 이전에 제기한 우려에도 불구하고 Ramda는 적절하게 활용될 때 강력한 도구임은 부인할 수 없어요.\n\n이 도구는 기능 프로그래밍에 완전히 헌신된 프로젝트에서 정말 빛을 발합니다. 하지만 프로젝트가 서로 다른 코딩 스타일을 오가는 혼합 모델이라면 JavaScript와 Lodash를 사용하는 게 더 편한 선택이 될 수도 있어요. 목표는 가장 멋진 도구를 사용하는 것이 아니라 명확하고 효율적인 코드를 작성하는 것이라는 걸 기억해 주세요.\n\nJavaScript는 기능 스타일을 손쉽게 처리할 수 있는 능력이 향상되어 지금껏 잘 작동해 왔고, Lodash 역시 너무 복잡함 없이 다양한 작업을 처리하는 데 탁월한 능력을 발휘해 왔어요.\n\n프로젝트 전체에 일관된 코딩 스타일을 유지하는 것도 도움이 될 수 있어요. 이는 팀에 새로 합류한 사람이 빠르게 적응할 수 있도록 단합감을 가져다 주기 때문에 매우 중요합니다. 빠르게 적응하면 빠르게 기여할 수 있어요.\n\n\n\n# 결론\n\nRamda는 분명 강점이 있고 함수형 프로그래밍 분야에서 중요한 위치를 차지하지만, 프로젝트에서 다양한 코딩 스타일을 사용하는 경우에는 항상 최적의 선택이 되지는 않을 수 있습니다. 이러한 상황에서는 현대 네이티브 JavaScript와 Lodash를 계속 사용하는 것이 더 나을 수도 있습니다. 궁극적으로, 우리의 목표는 단지 복잡한 도구만 사용하는 것이 아니라 효과적이고 명확한 코드를 작성하는 것입니다.","ogImage":{"url":"/assets/img/2024-05-14-FarewellRamda_0.png"},"coverImage":"/assets/img/2024-05-14-FarewellRamda_0.png","tag":["Tech"],"readingTime":7},{"title":"타입 vs 인터페이스 TypeScript에서","description":"","date":"2024-05-14 15:27","slug":"2024-05-14-TypesVsInterfacesinTypeScript","content":"\n\n\n![TypesVsInterfacesinTypeScript](/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png)\n\nTypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.\n\n오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.\n\n더 이상 미루지 말고 바로 들어가 봅시다.\n\n\n\n\n차이가 무엇인가요?\n\n이 동물 유형 및 인터페이스 정의를 분석해 봅시다:\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\n\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n```\n\n구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.\n\n\n\n이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.\n\n# 확장성\n\n확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.\n\n```js\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n\ninterface Dog extends Animal {\n  breed: string\n}\n\nconst dog: Dog = {\n  species: '포유동물',\n  name: '브루노',\n  breed: '저먼 셰퍼드',\n  age: 5\n}\n```\n\n\n\n개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.\n\n타입은 두 개의 타입을 병합하는 데 Union(`|`) 및 Intersection(`&`) 연산자를 사용하여 속성을 확장할 수도 있습니다.\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\ntype Dog = {\n  breed: string\n} & Animal\n\n// ❌ 작동하지 않음\ninterface Dog {\n  breed \n} & Animal\n```\n\n# 성능\n\n\n\n성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.\n\n이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.\n\nMatt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.\n\n# 인터페이스가 해로울 수 있는 이유\n\n\n\nTypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.\n\n선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.\n\n```js\n// 초기 Dog 인터페이스\ninterface Dog {\n  species: string\n  name: string\n  age: number\n}\n// \"선언 병합\"을 이용해 Dog 인터페이스 보강\ninterface Dog {\n  breed: string\n}\n\n// \"병합된\" 인터페이스로 새로운 \"개\"를 정의해봐\nconst dog: Dog = { name: \"Bruno\", age: 5, breed: \"German Shepherd\", species: \"Mamamal\" }\n```\n\n이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.\n\n그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.\n\n\n\n```js\n인터페이스 Cloner {\n  clone(animal: Animal): Animal;\n}\n인터페이스 Cloner {\n  clone(animal: Sheep): Sheep;\n}\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n\n// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:\n\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.\n\n## 클래스와의 안전하지 않은 병합\n\nTypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\n두 인터페이스의 병합 중에\n\n\n\n```js\n인터페이스 동물 {\n    a: 문자열;\n    b: 문자열;\n}\n\n인터페이스 개는 동물을 확장하며 {\n    c: 문자열;\n}\n\n클래스 개 {\n    constructor() {}\n}\n```\n\n위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.\n\n그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.\n\n```js\n클래스 개 {\n    a: 문자열;\n    b: 문자열;\n    c: 문자열;\n}\n```\n\n\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n| Types do not have this problem, and hence are more straightforward and safe to use as a result.                        |\n|--------------------------------------------------------------------------------------------------------------------------|\n| **Conclusion**                                                                                                          |\n| Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types. |\n| Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.                         |\n\n\n\n인터페이스와 성능 면에서도 타입들은 동일합니다.","ogImage":{"url":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png","tag":["Tech"],"readingTime":4},{"title":"가장빠른 구체적인걸로 Golang Air를 이용한 실시간 리로드 구현 안내로 표현하는게 괜찮을거 같아요","description":"","date":"2024-05-14 15:24","slug":"2024-05-14-GuideforImplementingLiveReloadUsingGolangAir","content":"\n에어는 개발 중에 Go 애플리케이션을 실시간으로 다시로드하는 데 사용되는 명령 줄 유틸리티입니다. 이 도구는 Go 애플리케이션이 실시간으로 다시로드되도록 하는 데 도움이 되는 도구로 작용합니다.\n\n![이미지](/assets/img/2024-05-14-GuideforImplementingLiveReloadUsingGolangAir_0.png)\n\n코딩하는 동안 라이브 리로드를 사용하면 개발자가 실시간으로 변경 사항을 확인할 수 있습니다. 변경 사항이 있을 때 서버를 수동으로 중지하고 다시 시작할 필요가 없어 시간을 절약할 수 있습니다. 어떤 Go 라이브 리로드 프레임워크는 소스 코드 변경 후 애플리케이션을 자동으로 다시로드할 수 있습니다. 이 기사에서는 Air 라이브러리를 사용하여 Go에서 라이브 리로드를 구현하는 방법을 안내합니다.\n\n# Golang Air 라이브러리 소개\n\n에어는 개발 중인 Go 애플리케이션을 실시간으로 다시로드할 수 있도록 설계된 명령줄 유틸리티입니다. 이것은 Go 애플리케이션이 실시간으로 다시로드될 수 있도록 도와주는 도구로 작용합니다.\n\n에어 외에도 Go용 잘 알려진 라이브 리로드 프레임워크로는 Fresh와 Realize가 있습니다. 이들은 소스 코드의 변경을 감지하면 자동으로 애플리케이션을 다시 빌드하고 다시 시작하는 방식으로 작동합니다.\n\n- Fresh는 모든 Go 웹 서버와 함께 사용할 수 있는 명령줄 도구로, 손쉽게 빌드 프로세스에 통합할 수 있습니다.\n- Realize는 Go 기반 빌드 시스템으로, Go 애플리케이션에 대한 라이브 리로딩 기능을 제공합니다.\n\n이러한 옵션들 사이의 기능적 유사성을 고려할 때, Go 프로젝트에 사용할 프레임워크를 선택하는 것은 주로 개인 취향에 달려 있습니다. 각 프레임워크를 시험해보고 어떤 것이 작업 흐름에 가장 직관적이고 직관적으로 느껴지는지 확인해보세요.\n\n# Live Reload이란 무엇인가요?\n\nLive Reload는 소스 코드를 수정할 때 애플리케이션이나 서버를 자동으로 새로 고침하는 개발 기능입니다. 이는 개발 및 디버깅 중에 특히 유용하며, 코드를 수정할 때마다 애플리케이션을 수동으로 중지하고 다시 시작해야 하는 필요성을 제거합니다.\n\n# Live Reload를 구현해야 하는 시점은 언제인가요?\n\nLive Reload는 다양한 시나리오에서 유용합니다. 여기에는 다음이 포함됩니다:\n\n# 웹 개발\n\n라이브 리로드는 웹 개발에서 일반적으로 사용됩니다. 클라이언트 측 (HTML, CSS, 자바스크립트)와 서버 측 (백엔드 코드) 변경사항에 모두 적용됩니다. 파일을 저장하면 웹 페이지가 자동으로 새로 고침되어 수동으로 새로 고침할 필요 없이 최신 변경 사항이 반영됩니다.\n\n# 프론트엔드 프레임워크\n\n리액트, 앵귤러, 뷰와 같은 프론트엔드 프레임워크는 종종 내장되어 있거나 쉽게 통합할 수 있는 도구를 지원합니다. 이는 개발 프로세스를 가속화하고 개발자가 사용자 인터페이스에서 즉각적인 변경 사항을 볼 수 있도록 해줍니다.\n\n# 백엔드 개발\n\n백엔드 개발 중에는 서버 측 코드에 변경 사항이 있을 때 서버를 자동으로 다시 시작하는 라이브 리로드가 유용합니다. 이 기능은 Express (Node.js), Django (Python)와 같은 프레임워크에서 일반적으로 사용됩니다.\n\n# 크로스 플랫폼 개발\n\nReact Native 또는 Flutter와 같은 프레임워크를 사용한 모바일 앱 개발과 같은 크로스 플랫폼 개발 시나리오에서 라이브 리로드는 가치 있는 기능입니다. 코드 변경사항이 연결된 기기나 에뮬레이터에서 자동 업데이트를 트리거할 수 있습니다.\n\n# Go 언어 (Golang)\n\nGo 프로그래밍 언어는 개발 중에 실시간 리로드를 잘 지원합니다. gin, fresh, air와 같은 도구들은 Go 커뮤니티에서 인기가 있습니다. 이 도구들은 코드 변경을 모니터하고 자동으로 Go 애플리케이션을 다시 빌드하고 재시작하여 원활한 개발 경험을 제공합니다.\n\ngin을 사용한 예시:\n\n```js\ngo get -u github.com/codegangsta/gin\ngin run main.go\n```\n\n에어를 사용한 예시:\n\n```js\ngo get -u github.com/cosmtrek/air\nair\n```\n\n# Go에서의 라이브 리로드 vs 핫 리로드\n\nGo에서 \"라이브 리로드\"라는 용어는 응용프로그램을 수동으로 중지하고 다시 시작할 필요 없이 자동으로 새로 고침하고 업데이트하는 기능을 가리킵니다.\n\n\"핫 리로드\"라고도 알려진 유사한 개념은 응용 프로그램의 코드를 업데이트하는 것을 의미하는데, 이때 응용 프로그램이 여전히 실행 중인 상태에서 현재 상태나 진행 중인 프로세스를 방해하지 않고 업데이트하는 것입니다.\n\n라이브 리로드와 핫 리로드는 모두 개발에서 유용하며, 수동으로 중단하고 다시 시작할 필요 없이 코드 변경의 빠른 반복과 테스트를 가능하게 합니다. 응용 프로그램의 복잡성에 따라, 핫 리로딩을 구현하는 것이 불가능하거나 더 많은 도전을 야기할 수 있습니다.\n\nGo 및 Gin 프로젝트는 라이브 리로드 기능을 내장하고 있지 않습니다. 따라서, Go와 Gin 프로젝트에서 라이브 리로드를 구현하기 위해 Air 라이브러리를 구성하는 방법을 살펴보겠습니다.\n\n# Gin Gonic과 함께 Golang Air 사용하는 6단계\n\n# 단계 1: Gin Gonic과 Air 설치하기\n\n터미널을 열고 다음 명령어를 실행하여 Gin Gonic과 Air를 설치하세요:\n\n```js\n# Gin Gonic 설치\ngo get -u github.com/gin-gonic/gin\n```\n\n```js\n# Air 설치\ngo get -u github.com/cosmtrek/air\n```\n\n# 단계 2: 간단한 Gin 애플리케이션 만들기\n\n다음 내용으로 main.go라는 새 파일을 만드세요:\n\n```js\n// main.go\npackage main\n\nimport (\n \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n // 새 Gin 라우터 생성\n router := gin.Default()\n\n // 라우트 정의\n router.GET(\"/\", func(c *gin.Context) {\n  c.JSON(200, gin.H{\n   \"message\": \"안녕, Gin!\",\n  })\n })\n\n // 서버를 8080 포트에서 실행\n router.Run(\":8080\")\n}\n```\n\n# 단계 3: Air 구성 파일 만들기\n\nair.toml이라는 파일을 만들어서 다음 내용을 넣어주세요:\n\n```js\n# air.toml\nroot = \".\"\ntmp_dir = \"tmp\"\nbuild_cmd = \"go build -o ./tmp/main .\"\nrun_cmd = \"./tmp/main\"\n```\n\n# 단계 4: Air로 애플리케이션 실행하기\n\n터미널에서 프로젝트 디렉토리로 이동한 후 Air를 사용하여 애플리케이션을 실행하세요:\n\n```js\n공기;\n```\n\n이렇게 하면 live-reloading이 포함된 Gin 애플리케이션이 시작됩니다. 코드를 변경하고 파일을 저장하면 Air가 변경 사항을 자동으로 감지하고 서버를 다시 시작합니다.\n\n# 단계 5: 애플리케이션 테스트하기\n\n웹 브라우저를 열고 http://localhost:8080에 접속해보세요. JSON 응답을 확인할 수 있어야 합니다.\n\n```js\n{\"message\":\"안녕, 진님!\"}\n```\n\n# 단계 6: 변경 내용을 만들고 실시간 새로 고침 확인하기\n\nmain.go 파일을 수정하고 저장한 뒤 Air가 서버를 자동으로 다시 시작하는 것을 확인하세요. 응용 프로그램을 수동으로 다시 시작하지 않아도 브라우저에서 업데이트된 응답을 확인할 수 있습니다.\n\n# Echo로 Golang Air 사용하는 6 단계\n\n# 단계 1: Echo와 Air 설치하기\n\n터미널을 열고 다음 명령어를 실행하여 Echo와 Air를 설치하세요:\n\n```js\n# Echo 설치\ngo get -u github.com/labstack/echo/v4\n\n# Air 설치\ngo get -u github.com/cosmtrek/air\n```\n\n# 단계 2: 간단한 Echo 애플리케이션 생성하기\n\n```go\n// main.go\npackage main\n\nimport (\n \"github.com/labstack/echo/v4\"\n \"net/http\"\n)\n\nfunc main() {\n // Create a new Echo instance\n e := echo.New()\n\n // Define a route\n e.GET(\"/\", func(c echo.Context) error {\n  return c.JSON(http.StatusOK, map[string]string{\n   \"message\": \"Hello, Echo!\",\n  })\n })\n\n // Start the server on port 8080\n e.Start(\":8080\")\n}\n```\n\nStep 3: Air Configuration File 생성하기\n\n다음 내용으로 air.toml이라는 파일을 생성하세요:\n\n```js\n# air.toml\nroot = \".\"\ntmp_dir = \"tmp\"\nbuild_cmd = \"go build -o ./tmp/main .\"\nrun_cmd = \"./tmp/main\"\n```\n\n# 단계 4: Air로 애플리케이션 실행하기\n\n터미널에서 프로젝트 디렉토리로 이동하여 다음 명령어를 사용하여 애플리케이션을 실행하세요:\n\n```js\nair;\n```\n\n# 단계 5: 애플리케이션 테스트하기\n\n웹 브라우저를 열고 http://localhost:8080에 접속해보세요. 다음과 같은 JSON 응답이 표시되어야 합니다:\n\n```js\n{\"message\":\"Hello, Echo!\"}\n```\n\n# 단계 6: 변경 사항을 적용하고 라이브 리로딩 확인하기\n\n위와 동일합니다.\n\n# Air 및 Fiber 사용을 위한 6 단계\n\n# 단계 1: Fiber 및 Air 설치하기\n\n터미널을 열고 다음 명령어를 실행하여 Fiber와 Air를 설치하세요:\n\n```js\n# Fiber 설치하기\ngo get -u github.com/gofiber/fiber/v2\n```\n\n```js\n# Air 설치하기\ngo get -u github.com/cosmtrek/air\n```\n\n# 단계 2: 간단한 Fiber 애플리케이션 만들기\n\n다음 내용으로 main.go란 새 파일을 만드세요.\n\n# 스텝 3: Air 구성 파일 생성\n\n다음 내용으로 air.toml이라는 파일을 생성하세요:\n\n```js\n# air.toml\nroot = \".\"\ntmp_dir = \"tmp\"\nbuild_cmd = \"go build -o ./tmp/main .\"\nrun_cmd = \"./tmp/main\"\n```\n\n# 단계 4: Air로 애플리케이션 실행하기\n\n터미널에서 프로젝트 디렉토리로 이동하고 Air를 사용하여 애플리케이션을 실행하세요:\n\n```js\nair;\n```\n\n이렇게 하면 Fiber 애플리케이션이 라이브 리로딩과 함께 시작됩니다. 코드를 수정하고 파일을 저장할 때마다 Air가 변경 사항을 자동으로 감지하고 서버를 다시 시작합니다.\n\n# 단계 5: 애플리케이션 테스트하기\n\n웹 브라우저를 열고 http://localhost:8080 으로 이동하세요. JSON 응답을 확인해야합니다:\n\n```js\n{\"message\":\"Hello, Fiber!\"}\n```\n\n# 단계 6: 변경 사항을 만들고 실시간 리로딩 확인하기\n\n위와 동일합니다.\n\n# 도커 컨테이너와 함께 Golang Air 사용하기 위한 4단계\n\n고랭 어플리케이션에서 도커 컨테이너와 함게 라이브 리로드를 사용하는 주요 이점 중 하나는 매번 컨테이너를 중지하고 시작하는 번거로움 없이 코드를 빠르게 반복할 수 있다는 것입니다.\n\n이는 특히 컨테이너 안에서 어플리케이션을 개발하고 유효성을 검사할 때 매우 유용하며, 문제를 신속하고 쉽게 식별하여 해결할 수 있도록 도와줍니다.\n\n라이브 리로드 라이브러리를 도커와 통합하려면, 도커 컨테이너 내에서 로컬 소스 코드 디렉토리를 볼륨 마운트해야 합니다. 이 설정을 통해 Air 라이브러리가 코드 변경을 모니터하고 필요에 따라 서버를 자동으로 새로 고칠 수 있게 됩니다.\n\n# 단계 1: Air 설치 및 실행을 위한 Dockerfile 작성\n\n```js\nFROM golang:latest\n\n# 컨테이너 내에서 작업 디렉토리 설정\nWORKDIR /app\n\n# go.mod 및 go.sum 파일을 작업 공간으로 복사\nCOPY go.mod go.sum ./\n\n# 모든 종속성 다운로드\nRUN go mod download\n\n# 현재 디렉토리의 소스를 작업 공간으로 복사\nCOPY . .\n\n# Go 앱 빌드\nRUN go build -o main .\n\n# 외부로 포트 8080 노출\nEXPOSE 8080\n\n# 실행 가능 파일 실행하는 명령\nCMD [\"air\"]\n```\n\n# 단계 2: .air.toml 파일 생성하기\n\n프로젝트 루트에 다음 내용을 포함하는 .air.toml 파일을 만들어주세요:\n\n```toml\nroot = \".\"\ntestdata_dir = \"testdata\"\ntmp_dir = \"tmp\"\n\n[build]\n  args_bin = []\n  bin = \"./tmp/main\"\n  cmd = \"go build -o ./tmp/main .\"\n  delay = 1000\n  exclude_dir = [\"assets\", \"tmp\", \"vendor\", \"testdata\"]\n  exclude_file = []\n  exclude_regex = [\"_test.go\"]\n  exclude_unchanged = false\n  follow_symlink = false\n  full_bin = \"\"\n  include_dir = []\n  include_ext = [\"go\", \"tpl\", \"tmpl\", \"html\"]\n  kill_delay = \"0s\"\n  log = \"build-errors.log\"\n  send_interrupt = false\n  stop_on_error = true\n\n[color]\n  app = \"\"\n  build = \"yellow\"\n  main = \"magenta\"\n  runner = \"green\"\n  watcher = \"cyan\"\n\n[log]\n  time = false\n\n[misc]\n  clean_on_exit = false\n\n[screen]\n  clear_on_rebuild = false\n```\n\n# 단계 3: Docker 이미지 빌드하기\n\n```bash\ndocker build -t airy-app .\n```\n\n# 단계 4: 도커 컨테이너에서 서버 실행하기\n\n```js\ndocker run -p 8080:8080 -v $PWD:/app airy-app\n```\n\n- docker run: 도커 컨테이너를 실행하는 데 사용되는 명령어입니다.\n- p 8080:8080: 이 옵션은 호스트 머신의 포트 8080을 컨테이너 내부의 포트 8080에 매핑합니다. 외부 시스템이 컨테이너 내에서 실행 중인 애플리케이션에 포트 8080을 통해 액세스할 수 있게 합니다.\n- v $PWD:/app: 이 옵션은 호스트 머신의 현재 작업 디렉토리($PWD)를 컨테이너 내부의 /app 디렉토리에 마운트합니다. 이것은 볼륨 마운트이며, 호스트의 현재 작업 디렉토리의 파일 및 디렉토리에 대한 컨테이너의 액세스를 허용합니다. 호스트나 컨테이너의 파일을 변경하면 둘 다 반영됩니다.\n- airy-app: 이것은 실행 중인 도커 이미지의 이름입니다. 이것은 컨테이너가 생성될 이미지를 지정합니다.\n\n`docker run` 명령은 airy-app 이미지에서 컨테이너를 생성하고 실행합니다. 이는 호스트의 포트 8080을 컨테이너 내부의 포트 8080으로 매핑하여 외부에서 애플리케이션에 액세스할 수 있게 합니다. 또한 현재 작업 디렉토리를 호스트에서 컨테이너 내부의 /app디렉토리로 마운트하여 호스트와 컨테이너 간의 데이터 공유를 용이하게 합니다.\n\n# Go에서 Live Reload 사용의 장단점\n\n# 장점\n\nLive reload는 코딩 프로세스의 효율성을 크게 향상시키는 개발 도구입니다. 소스 코드를 변경할 때 응용 프로그램이 자동으로 즉시 업데이트되도록 하는 것으로, 수동 재시작이 필요 없습니다. 여기에서 이점을 살펴보겠습니다:\n\n- 개발 속도 향상: 기존 개발은 코드 변경 사항이 적용되는 것을 보기 위해 응용 프로그램을 중지하고 다시 시작해야 하는 경우가 많습니다. Live reload를 사용하면 코드를 저장하는 즉시 변경 사항이 동적으로 적용되어 더 빠른 개발 워크플로우를 제공합니다.\n- 다운타임 최소화: Live reload 없이는 수정 후 응용 프로그램이 다시 시작될 때까지 다운타임을 경험하는 경우가 많습니다. Live reload를 사용하면 이러한 다운타임을 최소화하여 코딩에 집중하며 중단 없이 작업할 수 있습니다.\n- 디버깅 용이: Live reload는 가치 있는 디버깅 도구입니다. 변경 사항이 발생할 때마다 응용 프로그램을 자동 새로고침하여 문제를 신속히 식별하고 해결할 수 있습니다. 이러한 즉각적인 피드백 루프는 디버깅 프로세스를 가속화합니다.\n- 효율적인 테스팅: 지속적이고 자동화된 새로고침은 서로 다른 시나리오를 테스트하는 데 유용하며, 수동 개입이 필요하지 않고 변경 사항이 철저히 테스트됨을 보장합니다.\n- 심플한 컨테이너 개발: Docker와 같은 컨테이너 환경에서는 빠르게 변화에 적응하기 위해 live reload가 유용하며, 컨테이너화된 응용 프로그램 내에서 문제를 식별하고 해결하기가 더 쉬워집니다.\n- 복잡한 프로젝트에 이상적: 다수의 종속성이나 긴 시작 시간이 필요한 복잡한 프로젝트에서 live reload는 특히 유용합니다. 반복적인 수동 개입없이 코드 변경 사항의 영향을 실시간으로 확인하여 개발 프로세스를 간소화합니다.\n\n본질적으로 라이브 리로딩은 개발 워크플로우를 간소화하고 다운 타임을 줄이며 디버깅을 돕는 시간 절약 메커니즘입니다. 특히 복잡한 구조나 긴 시작 프로세스를 갖는 프로젝트에 특히 유용합니다.\n\n# 단점\n\n- 자원 소모가 큼: 라이브 리로딩 도구는 추가적인 시스템 자원을 사용하여 응용 프로그램을 모니터하고 다시 불러오는 데 사용됩니다. 이는 개발 중에 메모리와 CPU 사용량이 증가할 수 있습니다.\n- 의도치 않은 부작용 가능성: 자동 리로딩은 기존 상태와 진행 중인 프로세스를 중단시키므로 복잡한 응용프로그램에서 예기치 않은 동작을 초래할 수 있습니다. 개발자들은 잠재적인 부작용에 주의해야 합니다.\n- 호환성 문제: 라이브 리로딩 기능을 통합하려면 프로젝트 구조나 종속성을 조정해야 할 수 있습니다. 일부 프로젝트는 특정 라이브 리로딩 도구와 호환되지 않을 수 있습니다.\n- 빌드 시간 부담: 라이브 리로딩 중에 응용 프로그램을 다시 빌드하고 다시 시작하는 과정은 약간의 지연을 발생시킵니다. 이 지연은 일반적으로 최소화되지만 시간이 지남에 따라 누적되어 전체 개발 경험에 영향을 줄 수 있습니다.\n- 특정 도구에 종속: 라이브 리로딩은 종종 특정 도구나 라이브러리(예: Air, Fresh)를 통해 용이해집니다. 이러한 도구에 의존하는 것은 관리 및 업데이트가 필요한 종속성을 도입할 수 있습니다.\n\n라이브 리로딩을 통해 코드 변경에 대한 빠른 피드백을 제공함으로써 개발 경험을 크게 향상시킬 수 있습니다. 그러나 자원 소모, 의도치 않은 부작용, 특정 프로젝트 환경에서의 신중한 통합 필요성과 같은 잠재적인 단점에 대해 인지해야 합니다. 라이브 리로딩을 사용할지 여부는 프로젝트의 특정 요구 사항과 특성을 기반으로 결정되어야 합니다.\n\n# 결론\n\n요약하자면, 개발 과정에서 실시간 다시로드의 중요성은 과장할 수 없습니다. 이는 더 효율적인 작업 흐름을 위한 촉매제 역할을 하며, 개발자들이 코드 변경의 영향을 실시간으로 확인할 수 있도록 합니다.\n\nGo (Golang)의 경우, Air와 같은 도구는 다시 빌드하고 다시 시작하는 프로세스를 자동화하여 지속적인 개발 환경을 조성하는 데 중요한 역할을 합니다. 이는 반복 속도를 가속화할 뿐만 아니라, 개발자들이 수동 개입으로 인한 방해 없이 코딩에 집중할 수 있도록 하기 때문에 전반적인 생산성을 향상시킵니다.\n\n궁극적으로, Air와 같은 도구가 보여주는 실시간 다시로드는 현대적인 개발 환경에서 필수적인 자산으로, 빠른 피드백 루프와 반응성 있는 코딩 경험에 기여합니다.\n","ogImage":{"url":"/assets/img/2024-05-14-GuideforImplementingLiveReloadUsingGolangAir_0.png"},"coverImage":"/assets/img/2024-05-14-GuideforImplementingLiveReloadUsingGolangAir_0.png","tag":["Tech"],"readingTime":10},{"title":"마이크로 프론트엔드 재사용하는 방법","description":"","date":"2024-05-14 15:22","slug":"2024-05-14-HowtoReuseMicroFrontends","content":"\n\n## 마이크로 프론트엔드는 재사용하기 어렵습니다. 그러나 적절한 도구 세트를 활용하면 서로 다른 프로젝트에 걸쳐 마이크로 프론트엔드를 재사용할 수 있습니다.\n\n![Micro Frontends](/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png)\n\n이론상으로 마이크로 프론트엔드는 멋지지만, 여러 팀이 동시에 병렬로 생성하고 개별적으로 섞어 다양한 응용 프로그램을 만들어내고 그들의 로직을 재작성할 필요 없이 서로 조합할 수 있습니다.\n\n그들은 마치 마법 같아요!\n\n\n\n하지만 실제로 이러한 마이크로 프론트엔드를 공유하고 재사용하는 과정은 쉽지 않습니다.\n\n그래서 이 글에서 여러 프로젝트에서 무난하게 재사용하는 방법을 보여드릴 거에요.\n\n시작해봅시다!\n\n# 우리가 사용할 도구\n\n\n\n마이크로 프론트엔드 자체로는 재사용이나 여러 팀 또는 개발 커뮤니티와 공유할 방법을 제공하지 않습니다.\n\n따라서 우리는 어떤 종류의 도구가 필요하며, 오늘은 비트(Bit)에 대해 알려 드리겠습니다.\n\n비트(Bit) 및 비트 클라우드(Bit Cloud)(클라우드 기반 마켓플레이스)는 구성 가능한 소프트웨어 제품을 개발하는 혁신적인 팀을 위한 완벽한 솔루션을 제공합니다. 업계를 선도하는 구성 요소 기반 개발 플랫폼으로, 수천 개의 팀 및 포춘 500 개사에게 대규모 앱 개발을 위한 구성 가능 앱 개발을 지원합니다.\n\n아래는 CDD 플랫폼에서 필요한 주요 기능 중 일부이며 비트(Bit)에서 제공하는 기능입니다.\n\n\n\n- 컴포넌트 중심 개발 툴셋\n- 컴포넌트 소스 코드 관리 및 버전 관리\n- 의존성 관리: 자동화, 스마트하고 일관성 있음\n- 패키징 및 배포\n- 공유하고 협업하는 중앙 플랫폼\n- 찾아보기 및 검색\n- 사용, 설치 및 통합 (빌드 시간 및 런타임)\n\n여기서 \"composable app development\"와 \"component-driven\"에 대해 얘기하고 있는 이유가 뭘까요? 왜냐하면 그것이 우리 문제를 해결하는 열쇠가 될 것이기 때문이에요.\n\n알다시피, Bit에는 코드뿐만 아니라 테스트와 논리적 컴포넌트의 문서까지 포함하는 \"컴포넌트\" 개념이 있어요. 이 \"컴포넌트\" 개념을 우리의 마이크로 프론트엔드에 매핑할 수 있게 되면 위에서 언급한 혜택을 누릴 수 있게 됩니다.\n\n\n\n우리의 마이크로 프론트엔드는 갑자기 다음과 같습니다:\n\n- 조립 가능합니다.\n- 모든 종속성을 쉽게 관리할 수 있습니다.\n- 개별 패키지로 쉽게 배포할 수 있습니다.\n- Bit.cloud를 통해 쉽게 발견할 수 있습니다.\n- 그리고 Bit를 통해 이러한 패키지를 설치하는 것은 단 한 가지 명령을 실행하는 것만큼 단순합니다.\n\n다른 프로젝트 내에서 일부 마이크로 프론트엔드를 재사용하는 실용적인 예제를 살펴봅시다.\n\n읽은 내용이 마음에 드셨나요? IT 산업에서 20년치의 지식을 모두와 공유하는 내 무료 뉴스레터에 가입해 보시는 건 어떨까요? \"늙은 개발자의 혼잣말\"에 참여해 보세요!\n\n\n\n# 기존의 마이크로 프론트엔드 재사용\n\n만약 Bit를 사용하여 독자적인 마이크로 프론트엔드를 어떻게 만들 수 있는지 궁금하다면, 아래 기사를 읽어보세요. 그곳에서 모든 과정을 단계별로 보여줄 테니까요:\n\n그러나 단순히 재사용만 하려면, 조금 더 간단한 프로세스가 적용됩니다.\n\n먼저 해야 할 일은 아래와 같은 명령어로 Bit를 설치하는 것입니다:\n\n\n\n```js\nnpx @teambit/bvm install\n```\n\n설치가 완료되면 Bit은 프로젝트에 패키지를 추가할 준비가 되어 있지만, 이를 수행할 수 있는 여러 가지 방법을 이해해야 합니다.\n\n우선 Bit.cloud를 통해 원하는 마이크로 프론트엔드를 찾아 설치해야 합니다. 예를 들어, 얼마 전에 만든 블로그 마이크로 프론트엔드를 한 번 살펴보겠습니다. 그것은 기사를 나열하는 간단한 마이크로 프론트엔드입니다.\n\n페이지의 오른쪽 상단에는 \"사용\" 버튼이 있습니다. 클릭하면 다음 메뉴가 표시됩니다:\n\n\n\n\n<img src=\"/assets/img/2024-05-14-HowtoReuseMicroFrontends_1.png\" />\n\n알겠지만, 'Bit'를 사용하는 것 외에도 \"npm\", \"yarn\", \"pnpm\"을 사용할 수 있습니다. 이 모든 프로세스는 간단합니다. 웹사이트에서 제공된 라인을 사용하기만 하면 됩니다. 사실, 이 방법은 Bit가 시스템에 설치되어 있을 필요가 전혀 없습니다. 그러나 이 명령을 사용하여 사용자 정의 Bit 레지스트리를 구성해야 합니다.\n\n```js\nnpm config set '@deleteman:registry' https://node.bit.cloud\n```\n\n그러나 아마도 이미 알고 계실 것처럼, 이 도구들은 모든 종속성을 직접 node_modules 폴더 내에 설치합니다. 이는 유용하지만 패키지의 코드에 쉽게 액세스하지 못하게 하고 심지어 변경할 수 없게 합니다. 보통 다른 사람의 패키지를 변경하고 싶지 않지만, 여기서는 여러분이 자신의 마이크로 프론트엔드를 재사용하고자 할 수도 있기 때문에 여기저기 변경하는 게 유용할 수 있습니다.\n\n\n\n그런 경우에는 비트(Bit)의 옵션에 대해 알아두는 게 좋아요:\n\n- 설치: 이 옵션은 npm을 사용하는 것과 거의 비슷합니다. 프로젝트에 구성 요소를 설치하면 예상대로 node_modules 폴더 안에 저장됩니다.\n- 가져오기: 이전 옵션처럼 종속성을 저장하는 대신, 이 명령은 패키지를 워크스페이스 루트에 새 폴더에 다운로드합니다. 그러면 node_modules 블랙홀에 빠질 필요 없이 코드에 쉽게 액세스할 수 있어요. 더불어 Bit는 가져온 각 구성 요소에 대해 node_modules 안에 심볼릭 링크를 만들고 새로 다운로드한 파일을 가리킵니다. 이렇게 하면 코드에서 가져온 구성 요소를 여전히 일반 외부 구성 요소처럼 가져올 수 있습니다. 가져온 마이크로 프론트엔드를 변경하면 업데이트를 새 버전으로 푸시할 수 있어요. 다른 사람들과 협업하여 마이크로 프론트엔드를 개발하고 확장하려는 경우에 이 옵션이 완벽해요.\n- 포크: 그러나 마이크로 프론트엔드의 사본을 만들고 변경하고 싶다면, Forking이 적절한 옵션이에요. \"가져오기\" 명령과 동일하게 작동하지만 버전 기록을 다운로드하지 않아서 사실상 당신의 변경을 기다리는 새로운 구성 요소가 됩니다.\n\n이런 내용을 감안하고, 내가 만든 마이크로 프론트엔드를 사용해 새로운 프로젝트를 처음부터 만드는 실용적인 예시를 살펴보겠어요.\n\n## 마이크로 프론트엔드로 웹사이트 구축하기\n\n\n\n위 예시를 통해, 홈 화면에 2개의 링크가 있는 웹사이트를 만들어보겠습니다:\n\n- 블로그: 블로그 마이크로 프론트엔드를 사용하여 블로그를 표시할 예정입니다.\n- 문서: 문서 마이크로 프론트엔드를 사용하여 내부 네비게이션 및 사용자 정의 페이지를 표시할 예정입니다.\n\n이들은 모두 예시 마이크로 프론트엔드입니다만, 귀하의 사용 사례에 유용한 예시로 확장할 수 있습니다.\n\n우리는 Bit를 사용하여 React 앱을 만들고, 그 후에 마이크로 프론트엔드를 설치할 것입니다.\n\n\n\n코딩을 시작하기 전에 먼저 Bit 워크스페이스를 생성하여 애플리케이션 코드를 넣을 수 있도록 하겠어요. 이렇게 하면 나중에 공유할 수 있게 될 거에요 (이에 대해서는 잠시 후에 더 자세히 알려드릴게요).\n\n```js\nyour-project-folder> bit new react workspace --env teambit.react/react-env --default-scope deleteman.test-website\n```\n\n이제 워크스페이스 폴더 안에서 작업할 거에요.\n\n이제 새로운 React 애플리케이션을 만들어봅시다.\n\n\n\n이를 위해서, 아래 명령어를 사용할 거에요:\n\n```js\nbit create react-app apps/website --aspect teambit.react/react-env\n```\n\n이것은 기본 scope 내 (우리의 경우에는 test-website)에 apps/website 폴더를 생성합니다.\n\n이제 앱을 다음과 같이 설정하세요:\n\n\n\n```js\nbit use apps/website\n```\n\n그리고 `bit run website`으로 마침내 테스트할 수 있습니다. 이것은 포트 3000에서 서버를 시작하며 다음과 같이 매우 기본적인 내용이 표시됩니다:\n![이미지](/assets/img/2024-05-14-HowtoReuseMicroFrontends_2.png)\n\n이제 `apps/website/website.tsx` 파일의 코드를 다음과 같이 변경하겠습니다:\n\n\n\n\n```js\nimport './App.css';\n\nexport function Website() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <p>\n         웹사이트에 오신 것을 환영합니다!\n        </p>\n        <p>\n          저희 제품에 대해 더 알고 싶다면, 저희의 <a href=\"/docs\">문서</a>를 방문해 주세요.\n          혹은 <a href=\"/blog\">기술 블로그</a>도 확인해 보세요.\n        </p>\n        \n      </header>\n    </div>\n  );\n}\n```\n\n우리는 더 간단히 단축할 수 있지만, 너무 복잡하게 하지 않기 위해 새 홈페이지가 어떻게 보이는지 알려드릴게요:\n\n![2024-05-14-HowtoReuseMicroFrontends_3.png](/assets/img/2024-05-14-HowtoReuseMicroFrontends_3.png)\n\n이제 두 섹션에 대한 라우트를 추가해 봅시다. 블로그 섹션이 가장 쉽기 때문에, 그것부터 시작해봅시다.\n\n\n\n가장 먼저 해야 할 일은 Bit를 사용하여 블로그 마이크로 프론트엔드를 가져오는 것입니다:\n\n```js\nyour-project-folder> bit import deleteman.microfrontends/blog\n```\n\n지금은 프로젝트의 루트에 microfrontends라는 폴더가 생겼을 것이며, website.tsx 파일을 다음과 같이 편집할 수 있을 것입니다:\n\n```js\nimport { useState } from 'react';\nimport { Blog } from \"@deleteman/microfrontends.blog\";\nimport './App.css';\n\nexport function Website() {\n\n  const [page, setPage] = useState(\"home\");\n\n  function navTo(event, target) {\n    event.preventDefault();\n    setPage(target);\n    return false;\n  }\n\n  if(page === \"home\") {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <p>\n            웹사이트에 오신 것을 환영합니다!\n          </p>\n          <p>\n            제품에 대해 더 알아보려면 <a href=\"#\" className='inline' onClick={(evt) => navTo(evt,'docs')}>문서</a>를 방문해주세요.\n            또는 <a href=\"#\" className='inline' onClick={(evt) => navTo(evt, 'blog')}>기술 블로그</a>를 확인해도 좋아요.\n          </p>\n        </header>\n      </div>\n    );\n  }\n\n  if(page === \"blog\") {\n    return (\n      <>\n        <Blog />\n        <p>\n          홈으로 돌아가려면 <a href=\"#\" className='inline' onClick={(evnt) => navTo(evnt, 'home')}>홈</a>을 클릭하세요.\n        </p>\n      </>\n    );\n  }\n}\n```\n\n\n\n주목하세요! 여기서는 첫 번째 마이크로 프론트엔드인 Blog 컴포넌트를 가져온다는 것을 알 수 있습니다. 파일이 다른 위치에 있더라도 node_modules 폴더 안에 복사된 것처럼 다룰 수 있어요.\n\n게다가 추가적인 라우팅을 추가하지 않았으므로 간단한 페이지 상태 변수로 내비게이션을 시뮬레이션하고 있어요.\n\n이제 Docs 마이크로 프론트엔드에서는 동일한 동작이 되도록, 올바른 컴포넌트를 렌더링하기 위해 새로운 if 문을 추가할 거예요:\n\n```js\nimport {Docs} from \"@deleteman/microfrontends.docs\"\n\n if(page == \"docs\") {\n    return (\n      <>\n      <Docs />\n        <p>\n          Go back <a href=\"#\" className='inline' onClick={(evnt) => navTo(evnt, 'home')}>Home</a>\n        </p>\n      </>\n    )\n  }\n```\n\n\n\n다시 한 번 알고 계시든 아니면 그렇지 않든, Docs 컴포넌트를 마치 node_modules 내에 설치된 것처럼 가져오고 있어요.\n\n그리고 여기가 최종 (그리고 못생긴) 결과입니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*DAkwXJnhXjDGwVvmrh_M0Q.gif)\n\n단순히 프로젝트에 2개의 마이크로 프론트엔드를 추가함으로써, 블로그와 문서 섹션을 위한 완전히 작동하는 내비게이션과 새로운 내부 링크 및 페이지를 쉽게 추가할 수 있었어요.\n\n\n\n강력한 내용이네요!\n\n## Bit에 최종 제품 푸시하기\n\n네, Bit를 사용하면 컴포넌트를 공유할 뿐만 아니라 완전한 애플리케이션도 공유할 수 있어요.\n\n이유가 뭔가요? 그것은 이들이 실제로 플랫폼에서 CI를 구성할 수 있는 능력을 제공하기 때문이에요.\n\n\n\n하지만 중요한 점은 최최 어플리케이션이 완성되면 버전을 지정하여 컴포넌트로 공유할 수 있다는 것이다. 다른 개발자들이 이를 설치하고 작업할 수 있으며, 동시에 완벽하게 작동하는 CI/CD 파이프라인을 갖게 될 것이다.\n\n가장 먼저 해야 할 일은 Bit.cloud에 가서 새 scope를 생성하는 것이다. 나는 \"test-website\"라고 이름 지었어 (네, 너무 원래 있어 보여!):\n\n![이미지](/assets/img/2024-05-14-HowtoReuseMicroFrontends_4.png)\n\n지금쯤이면 이미 어플리케이션을 설정하고 생성했을 것이다 (이 강의 전체를 통해 그렇게 했으니까), 따라서 남은 것은 버전을 지정하고 내보내는 것이다.\n\n\n\n다음 명령어를 실행해주세요:\n\n```js\nbit tag\nbit export\n```\n\n첫 번째 명령은 테스트를 실행하고 코드를 린트하며 모든 것이 예상대로 작동하는지 확인할 것입니다. 그리고 그렇게 되면 버전을 0.0.1로 만들 것입니다.\n\n마지막 명령은 두 파일을 클라우드에 업로드할 것입니다. 제 경우에는 여기에서 최종 결과를 볼 수 있습니다.\n\n\n\n\"그리고 만일 'Dependencies' 탭을 클릭하면, 앱을 만들 때 사용한 2개의 마이크로 프론트엔드를 보실 수 있습니다:\n\n![Dependencies](/assets/img/2024-05-14-HowtoReuseMicroFrontends_5.png)\n\n이제 우리의 프로젝트는 팀원들과 함께 협업할 준비가 된 상태입니다.\n\n성공!\"\n\n\n\n마이크로 프론트엔드는 환상적인 재사용성 솔루션을 제시합니다. 이미 존재하는 것을 재사용하여 복잡한 웹사이트와 애플리케이션을 만들 수 있습니다.\n\n팀은 개별적으로 이러한 구성 요소를 만들 수 있으며, 다른 사용자들은 이를 섞어서 매치할 수 있습니다. 생각해보면 레고 블록과 놀이하는 것과 매우 흡사합니다.\n\n물론, \"블록\"을 공유하고 사용하는 것은 간단하지 않습니다. 이를 발견하고 새 프로젝트에 설치하기 위한 도구가 필요합니다. 다행히도 Bit를 사용하면 컴포넌트 중심의 접근 방식으로 마이크로 프론트엔드를 쉽게 만들고 공유하고 재사용할 수 있습니다.\n\n그뿐만 아니라, 이미 존재하는 구성 요소를 확장할 수 있는 도구를 개발자들에게 제공합니다.\n\n\n\n# 또한, 기존 애플리케이션에 마이크로 프론트엔드를 생성하고 추가하는 방법에 대해 알아보세요:\n\n# 추가로 읽을 거리:","ogImage":{"url":"/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png","tag":["Tech"],"readingTime":9},{"title":"자바스크립트 47일차 - 자바스크립트 기초 마스터하기 면접 준비를 위한 포괄적인 가이드","description":"","date":"2024-05-14 15:21","slug":"2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation","content":"\n\n100일간의 자바스크립트 면접 준비: 초보자의 여정 | 코딩 라운드\n\n![이미지](/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_0.png)\n\n## 상위 10개 중요한 인터뷰 자바스크립트 코딩 라운드 인터뷰 질문\n\n## 자바스크립트에서 ARRAY의 ARRAY를 펼치는 방법?\n\n\n\n```js\nconst arry = [[1, 2, [3]], 4, [5, [6, 7]]]\n\n// 출력  [1, 2, 3, 4, 5, 6, 7]\n```\n\n답변\n\n단계 1 — flattenMyArray 함수는 배열을 입력으로 받고 각 요소를 반복합니다.\n\n단계 2 — 요소가 배열이면 해당 하위 배열을 펼치기 위해 재귀적으로 자신을 호출합니다.\n\n\n\n**단계 3** — 그렇지 않으면, 요소를 평탄화된 배열에 추가합니다.\n\n**단계 4** — 마지막으로, 평탄화된 배열을 반환합니다.\n\n# 방법 1 — (ForEach 방법)\n\n**단계 1** — 평탄화해야 할 입력 배열을 정의합니다.\n\n\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n```\n\nStep 2— `flattenArray` 함수와 결과값(펼쳐진 배열)을 저장할 빈 배열을 만듭니다.\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n\nfunction flattenArray(arr) {\n    let flattened = [];\n\n}\n```\n\nStep 3— 각 요소를 `forEach` 방법으로 반복하고 함수의 끝에 펼쳐진 값을 반환합니다.\n\n\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n\nfunction flattenArray(arr) {\n   let flattened = [];\n\n   arr.forEach(item => {\n     console.log(item)\n       \n   });\n\n    return flattened;\n}\n```\n\n제 4단계 — 입력 배열로 함수를 호출하고 항목에 대한 console.log를 확인합니다.\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n\nfunction flattenArray(arr) {\n   let flattened = [];\n\n   arr.forEach(item => {\n     console.log(item)\n       \n   });\n\n    return flattened;\n}\n\nconst flattenedArray = flattenArray(nestedArray);\n```\n\n<img src=\"/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_1.png\" />\n\n\n\n\nStep 5— foreach 코드 안에 위의 console.log 관찰에 따라 몇 가지 조건을 추가해 봅시다.\n\n- 요소가 배열인 경우, 해당 하위 배열을 평탄화하도록 재귀적으로 자신을 호출합니다.\n- 그렇지 않으면, 해당 요소를 평탄화된 배열에 푸시합니다.\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n\nfunction flattenArray(arr) {\n   let flattened = [];\n\n   arr.forEach(item => {\n   /* 요소가 배열인 경우, 해당 하위 배열을 재귀적으로 평탄화하도록 호출합니다. */\n    if (Array.isArray(item)) {\n            flattened = flattened.concat(flattenArray(item));\n        } else {\n   // 그렇지 않으면, 해당 요소를 평탄화된 배열에 푸시합니다\n            flattened.push(item);\n        }\n\n   });\n\n    return flattened;\n}\n\nconst flattenedArray = flattenArray(nestedArray);\n```\n\n![JavaScript Basics](/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_2.png)\n\n\n\n# 최종 코드\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]];\n\nfunction flattenArray(arr) {\n   let flattened = [];\n\n   arr.forEach(item => {\n   /* 만약 요소가 배열이라면 해당 하위 배열을 평탄화하기 위해 재귀적으로 자신을 호출합니다. */\n    if (Array.isArray(item)) {\n            flattened = flattened.concat(flattenArray(item));\n        } else {\n   // 그렇지 않으면 요소를 평탄화된 배열에 추가합니다.\n            flattened.push(item);\n        }\n\n   });\n\n    return flattened;\n}\n\nconst flattenedArray = flattenArray(nestedArray);\n```\n\nES6 Map 방법을 사용한 또 다른 방법을 DAY 48에서 논의할 예정입니다.\n\n![JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_3.png](/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_3.png)\n\n\n\n# 행복한 코딩 하세요 그리고 기대해주세요 :)\n\n# 만약 제 블로그가 도움이 되었다면 구독, 박수와 팔로우 부탁드립니다 :)","ogImage":{"url":"/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_0.png"},"coverImage":"/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_0.png","tag":["Tech"],"readingTime":4},{"title":"라라벨 8로 사용자 로그인 및 등록 화면 생성","description":"","date":"2024-05-14 15:19","slug":"2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8","content":"\n\nLaravel 8 로그인 및 회원가입 튜토리얼; 이 튜토리얼에서는 라라벨 애플리케이션에서 사용자 지정 인증 로그인 및 회원가입을 생성하는 방법에 대해 설명합니다.\n\n단계 1: 라라벨 애플리케이션 만들기\n단계 2: 데이터베이스 연결\n단계 3: 권한 부여 컨트롤러 설정\n단계 4: 권한 부여 라우트 생성\n단계 5: 권한 부여 블레이드 뷰 파일 생성\n단계 6: 라라벨 개발 서버 실행\n\n단계 1: 라라벨 애플리케이션 만들기\n\n시스템에 이미 Composer를 구성했다고 가정하고, 다음 명령을 실행하여 새 라라벨 애플리케이션을 설치합니다. 그렇지 않은 경우에는 다음 링크에서 다운로드할 수 있습니다.\n\n\n\n```js\ncomposer create-project - prefer-dist laravel/laravel_demo_app\n```\n\n그런 다음, 애플리케이션 폴더로 이동하세요:\n\n```js\ncd laravel_demo_app\n```\n\n단계 2: 데이터베이스에 연결하기\n\n\n\n이제 Laravel 애플리케이션을 데이터베이스에 연결하기 위해 .env 구성 파일에 데이터베이스 이름, 사용자 이름 및 비밀번호를 추가해야 합니다:\n\n```js\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=데이터베이스_이름\nDB_USERNAME=데이터베이스_사용자_이름\nDB_PASSWORD=데이터베이스_비밀번호\n```\n\nLaravel 애플리케이션에는 기본 User 모델과 마이그레이션 파일이 함께 제공됩니다. 데이터베이스에 새 테이블을 만들기 위해 다음 명령을 실행해야 합니다. 따라서 터미널로 이동하여 다음 명령을 실행하세요.\n\n```js\nphp artisan migrate\n```\n\n\n\n3단계: 인가 컨트롤러 설정하기\n\n다음으로, 제안된 명령을 명령 프롬프트에 작성하고 새로운 컨트롤러 파일인 CustomAuthController를 생성하는 명령을 실행하세요.\n\n```js\nphp artisan make:controller CustomAuthController\n```\n\n그런 다음 파일을 열어주세요.\n\n\n\n```plaintext\n`app\\Http\\Controllers\\CustomAuthController.php` 에 위 코드를 주의 깊게 넣어주세요.\n\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse Hash;\nuse Session;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass CustomAuthController extends Controller\n{\n\n    public function index()\n    {\n        return view('auth.login');\n    }\n\n    public function customLogin(Request $request)\n    {\n       $validator =  $request->validate([\n            'email' => 'required',\n            'password' => 'required',\n        ]);\n   \n    \n        $credentials = $request->only('email', 'password');\n        if (Auth::attempt($credentials)) {\n            return redirect()->intended('dashboard')\n                        ->withSuccess('Signed in');\n        }\n        $validator['emailPassword'] = '이메일 주소 또는 비밀번호가 올바르지 않습니다.';\n        return redirect(\"login\")->withErrors($validator);\n    }\n\n\n\n    public function registration()\n    {\n        return view('auth.registration');\n    }\n\n    public function customRegistration(Request $request)\n    {  \n        $request->validate([\n            'name' => 'required',\n            'email' => 'required|email|unique:users',\n            'password' => 'required|min:6',\n        ]);\n           \n        $data = $request->all();\n        $check = $this->create($data);\n         \n        return redirect(\"dashboard\")->withSuccess('가입이 완료되었습니다');\n    }\n\n\n    public function create(array $data)\n    {\n      return User::create([\n        'name' => $data['name'],\n        'email' => $data['email'],\n        'password' => Hash::make($data['password'])\n      ]);\n    }\n\n    public function dashboard()\n    {\n        if(Auth::check()){\n            return view('dashboard');\n        }\n  \n        return redirect(\"login\")->withSuccess('접근 권한이 없습니다');\n    }\n\n    public function signOut() {\n        Session::flush();\n        Auth::logout();\n  \n        return Redirect('login');\n    }\n}\n\nStep 4: 권한 부여 라우트 생성\n\n\n\n\n이 단계에서는 라라벨 애플리케이션에서 사용자 정의 인증을 처리하기 위해 POST 및 GET 방식으로 경로를 생성하는 방법을 설명합니다. route/web.php 파일을 열고 다음 코드를 추가하세요.\n\n<?php\n\nuse Illuminate\\Support\\Facades\\Route;\nuse App\\Http\\Controllers\\CustomAuthController;\n\n/*\n|--------------------------------------------------------------------------\n| Web Routes\n|--------------------------------------------------------------------------\n*/\n\nRoute::get('dashboard', [CustomAuthController::class, 'dashboard']); \nRoute::get('login', [CustomAuthController::class, 'index'])->name('login');\nRoute::post('custom-login', [CustomAuthController::class, 'customLogin'])->name('login.custom'); \nRoute::get('registration', [CustomAuthController::class, 'registration'])->name('register-user');\nRoute::post('custom-registration', [CustomAuthController::class, 'customRegistration'])->name('register.custom'); \nRoute::get('signout', [CustomAuthController::class, 'signOut'])->name('signout');\n\n단계 5: Auth Blade View 파일 생성\n\nResources/views/ 폴더 내에서 auth 폴더를 생성하고 그 안에 new login.blade.php 파일을 만들어 이 파일에 다음 코드를 넣어주세요.\n\n\n\n<link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n<main class=\"login-form\">\n    <div class=\"cotainer\">\n        <div class=\"row justify-content-center\">\n            <div class=\"col-md-4\">\n                <div class=\"card\">\n                    <h3 class=\"card-header text-center\">로그인</h3>\n                    <div class=\"card-body\">\n                        <form method=\"POST\" action=\"{ route('login.custom') }\">\n                            @csrf\n                            <div class=\"form-group mb-3\">\n                                <input type=\"text\" placeholder=\"이메일\" id=\"email\" class=\"form-control\" name=\"email\" required autofocus>\n                            </div>\n\n                            <div class=\"form-group mb-3\">\n                                <input type=\"password\" placeholder=\"비밀번호\" id=\"password\" class=\"form-control\" name=\"password\" required>\n                                @if ($errors->has('emailPassword'))\n                                <span class=\"text-danger\">{ $errors->first('emailPassword') }</span>\n                                @endif\n                            </div>\n\n                            <div class=\"form-group mb-3\">\n                                <div class=\"checkbox\">\n                                    <label>\n                                        <input type=\"checkbox\" name=\"remember\"> 기억하기\n                                    </label>\n                                </div>\n                            </div>\n\n                            <div class=\"d-grid mx-auto\">\n                                <button type=\"submit\" class=\"btn btn-dark btn-block\">로그인</button>\n                            </div>\n                        </form>\n\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</main>\n\nResources/views/auth 폴더로 이동하여 비슷하게 registration.blade.php 파일을 만들고, 이 파일에 다음 코드를 추가해주세요:\n\n<link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n\n<main class=\"signup-form\">\n    <div class=\"cotainer\">\n        <div class=\"row justify-content-center\">\n            <div class=\"col-md-4\">\n                <div class=\"card\">\n                    <h3 class=\"card-header text-center\">사용자 등록</h3>\n                    <div class=\"card-body\">\n\n                        <form action=\"{ route('register.custom') }\" method=\"POST\">\n                            @csrf\n                            <div class=\"form-group mb-3\">\n                                <input type=\"text\" placeholder=\"이름\" id=\"name\" class=\"form-control\" name=\"name\"\n                                    required autofocus>\n                                @if ($errors->has('name'))\n                                <span class=\"text-danger\">{ $errors->first('name') }</span>\n                                @endif\n                            </div>\n\n                            <div class=\"form-group mb-3\">\n                                <input type=\"text\" placeholder=\"이메일\" id=\"email_address\" class=\"form-control\"\n                                    name=\"email\" required autofocus>\n                                @if ($errors->has('email'))\n                                <span class=\"text-danger\">{ $errors->first('email') }</span>\n                                @endif\n                            </div>\n\n                            <div class=\"form-group mb-3\">\n                                <input type=\"password\" placeholder=\"비밀번호\" id=\"password\" class=\"form-control\"\n                                    name=\"password\" required>\n                                @if ($errors->has('password'))\n                                <span class=\"text-danger\">{ $errors->first('password') }</span>\n                                @endif\n                            </div>\n\n                            <div class=\"form-group mb-3\">\n                                <div class=\"checkbox\">\n                                    <label><input type=\"checkbox\" name=\"remember\"> 기억하기</label>\n                                </div>\n                            </div>\n\n                            <div class=\"d-grid mx-auto\">\n                                <button type=\"submit\" class=\"btn btn-dark btn-block\">가입하기</button>\n                            </div>\n                        </form>\n\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</main>\n\nResources/views/ 폴더로 이동하여 새로운 dashboard.blade.php 파일을 만들고, 이 파일에 다음 코드를 추가해주세요:\n\n\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>라라벨에서 사용자 지정 인증</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n</head>\n\n<body>\n\n    <nav class=\"navbar navbar-light navbar-expand-lg mb-5\" style=\"background-color: #e3f2fd;\">\n        <div class=\"container\">\n            <a class=\"navbar-brand mr-auto\" href=\"#\">코드사전</a>\n            <button class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#navbarNav\"\n                aria-controls=\"navbarNav\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\n                <span class=\"navbar-toggler-icon\"></span>\n            </button>\n            <div class=\"collapse navbar-collapse\" id=\"navbarNav\">\n                <ul class=\"navbar-nav\">\n                    @guest\n                    <li class=\"nav-item\">\n                        <a class=\"nav-link\" href=\"{ route('login') }\">로그인</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a class=\"nav-link\" href=\"{ route('register-user') }\">가입하기</a>\n                    </li>\n                    @else\n                    <li class=\"nav-item\">\n                        <a class=\"nav-link\" href=\"{ route('signout') }\">로그아웃</a>\n                    </li>\n                    @endguest\n                </ul>\n            </div>\n        </div>\n    </nav>\n\n</body>\n\n</html>\n\n단계 6: 라라벨 서버 실행하기\n\n마지막으로, 브라우저에서 애플리케이션을 시작할 수 있도록 라라벨 개발 서버를 실행해야 합니다. 명령 프롬프트를 통해 다음 명령어를 실행해 주세요.\n\nphp artisan serve\n\n\n\n브라우저 주소창에 다음 URL을 추가하고 애플리케이션을 테스트해보세요.\n\nhttp://127.0.0.1:8000/login\nhttp://127.0.0.1:8000/registration\n\n소스 코드\n\n![이미지](/assets/img/2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8_0.png)","ogImage":{"url":"/assets/img/2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8_0.png"},"coverImage":"/assets/img/2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8_0.png","tag":["Tech"],"readingTime":11},{"title":"당신만의 개인 복사 편집기 LangChainjs와 일렉트론을 이용해 LLM 지원 앱 만들기","description":"","date":"2024-05-14 15:17","slug":"2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron","content":"\n\n![이미지](/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_0.png)\n\n자바스크립트를 사용하여 LLM을 백엔드로 지원하는 앱을 작성한다니, 미친 생각일 수도 있죠? 사실 LangChain과 같은 외부 API와 라이브러리에 크게 의존하는 앱에는 파이썬 대신 자바스크립트를 사용하는 것이 혜택이 있습니다. 기존의 웹 앱 모델에서는 HTML/CSS/JS 프론트엔드와 원하는 서버 측 언어를 사용한 백엔드를 개발해야 합니다. 그러나 LangChain과 js-tiktoken과 같은 LLM을 다루는 자바스크립트 라이브러리들이 등장하면서, 이제는 백엔드 계층 없이 AI 기능이 탑재된 앱을 만들 수 있습니다.\n\n객관적으로 말하자면, 완전한 클라이언트 측 접근 방식을 선택하면 기능이 제한될 수 있습니다. 하지만 완전한 클라이언트 측 응용프로그램을 견고한 Electron 데스크톱 프레임워크와 결합하면, 이러한 제약이 많이 해결됩니다. Electron을 사용하면 프론트엔드 웹 앱을 크로스 플랫폼 데스크톱 앱으로 패키징할 수 있고, 여러 플랫폼의 앱 스토어에 배포할 수 있습니다.\n\n일반적으로 웹 앱에서 기대되는 계정 관리와 같은 기능들은 데스크톱 공간에서 선택사항이 됩니다. 게다가 호스트 운영 체제와 상호 작용하는 네이티브 플러그인에 액세스할 수 있어, 일반적인 웹 앱의 한계를 벗어나 앱을 확장할 수 있습니다.\n\n\n\n이 기사에서는 LLM을 백업하는 응용 프로그램의 자바스크립트 POC(Concept(POC)) 구현물을 포괄적인 데스크톱 경험으로 전환하는 과정을 살펴볼 것입니다. 이 기사에서 논의된 코드는 오픈 소스이며 MIT 라이선스에 따라 라이선스가 부여되었으므로 자유롭게 사용하거나 더 나아가 포크하고 개선 또는 향상시킬 수 있습니다.\n\n이 아이디어가 발생한 것은 ChatGPT에 기사를 수동으로 복사하고 붙여넣기 하는 것에 지쳤을 때였습니다. Python에서 LangChain을 사용해본 경험이 있었기 때문에 간단한 단일 페이지 React 앱을 만들어 보았습니다. 이 앱은 입력된 텍스트를 가져와 JS로 LangChain을 통해 처리하고 편집된 텍스트를 반환할 수 있는 앱이었습니다. LangChain의 API는 Python 및 JavaScript 구현 간에 매우 유사하여 한 언어에 익숙한 사람이 다른 언어를 탐색하기 쉽습니다. 흥미로운 점은 LangChain 코드가 POC의 가장 쉬운 부분이었습니다. 아래에 LLM 상호작용을 위한 코드가 제공되었습니다.\n\n```js\nconst openAIApiKey = process.env.REACT_APP_OPENAI_API_KEY;\nconst modelName =  \"gpt-4\";\nconst enc = encodingForModel(modelName);\nconst chunk_token_size = 1000;\nconst llm = new ChatOpenAI({modelName: modelName, temperature: 0, openAIApiKey: openAIApiKey});\nconst promptTemplate = ChatPromptTemplate.fromPromptMessages([\n    SystemMessagePromptTemplate.fromTemplate(\n      \"You are an expert copy editor. It is your task to take a piece of an article and proof-read it for grammar and style. Provide a rewritten copy of the article portion back to the human.\"\n    ),\n    HumanMessagePromptTemplate.fromTemplate(\"{input}\")\n  ])\nconst chain = new ConversationChain({prompt: promptTemplate, llm: llm});\n\n...\n\nconst openAICalls = chunks.map((chunk, idx) => chain.call({input: chunk}));\n```\n\n그 다음으로, 나는 사용자 정의 텍스트 청크 알고리즘을 개발했습니다. 문단 중간에 텍스트를 분할하는 것을 피하고 싶었기 때문에 내장된 분할 방법을 활용하여 새 줄을 기준으로 텍스트를 분할했습니다. 이는 문단을 분할하는 대략적인 근사치지만 merseured 분할을 위해 spaCy나 NLTK와 같은 도구에 액세스할 수 없었기 때문에 최선의 선택이었습니다. 그런 다음 분할된 각 문자열을 검토하고 js-tiktoken을 사용하여 토큰 카운트를 계산했습니다. 이 카운트는 분할을 최대 토큰 수로 결합하는 데 사용되었습니다. 이 방법을 통해 문단을 분할하지 않으면서 LLMChain에 개별 호출할 수 있었으며 나중에 완전히 편집된 텍스트로 재조립할 수 있었습니다.\n\n\n\n지금까지 총 24시간 동안 자바스크립트 코드를 약 250줄 작성하여 POC를 완성했습니다. 최신 미디엄 기사를 사이트에 붙여넣고 한 번의 버튼 클릭으로 교정된 복사본을 받았을 때, 공유할 가치가 있는 것이 느껴졌어요.\n\n운이 좋게도 제게는 미디엄에 글을 쓰는 친구들이 있어요. 제 간단한 POC를 그들과 공유했는데, 그들은 흥미로워 했어요! 하지만 리액트 코드베이스를 다운로드하고 종속성을 설치하고 적절한 환경 변수로 실행하는 기술적 전문성이 부족했어요. 자체 호스팅 웹 앱보다 더 사용하기 쉬운 제품이 필요했죠.\n\nAI를 기반으로 한 제품을 개발할 때, 초기에 사용자당 비용을 고려하는 게 중요해요. AI 앱에 대한 인기 있는 모델인 소프트웨어 서비스(SaaS)는 사용자 계정을 쉽게 활용할 수 있어서 AI 앱의 경우 효율적이에요. 게다가 사용자가 지불한 것만 액세스 할 수 있도록 보장하는 것도 간단해요. 하지만, 구독의 단점 중 하나는 많은 사용자들이 매달 새로운 앱을 구매해야 할 때 느끼는 피로감이에요.\n\n이 문제를 회피하기 위해 사용자들로부터 자신의 OpenAI API 키를 제공해 달라고 결정했어요. 이 방식이 NextCloud와 같은 다른 오픈 소스 프로젝트에서 성공적으로 작동하고 있다는 것을 봤어요. 이러면 사용자의 AI 사용에 대한 지불을 피할 수 있어요. 또한 API는 사용량에 따라 지불하는 방식으로 운영되어 사용자들이 많은 AI 기반 웹 앱들에서 요구되는 가짜 돈 토큰을 구매할 필요가 없어지는 소비자를 위한 움직임이에요.\n\n\n\n내 다른 동료 Medium 작가들이 이 앱을 사업으로 전환하는 기회를 왜 잡지 않았느냐고 의문을 제기했습니다. 컨셉은 탄탄하고 효과적했는데, 왜 나만의 사장이 되지 않았느냐고요? 제 다소 부끄러운 대답은 비즈니스보다 오픈 소스 프로젝트를 관리하는 것이 더 낫다고 느끼기 때문이라고 했습니다. 하지만 이것이 전부가 아니에요. 더 나아가 사용자들이 매월 구독을 해야 하는 것 없이 강력한 AI 작성 능력에 접근할 수 있는 도구를 제공하기를 목표로 했습니다. 2008년 이후로 오픈 소스 소프트웨어의 능동적인 사용자로서, 개인이나 소규모 그룹이 중요한 영향력을 행사하기 위한 최상의 방법이라고 단정했습니다.\n\n비즈니스 고려는 뒷전으로, 지금은 이 POC를 완전한 OSS 데스크탑 앱으로 발전시키는 방법에 대해 생각할 때입니다. 주로 백엔드 Python 코드를 작성하거나 가끔 JavaScript로 웹 앱을 만드는 개발자로서 Electron은 자연스러운 선택이었습니다. 익숙한 웹 기술로 작업할 수 있을 뿐만 아니라, 리눅스를 포함한 주요 플랫폼에 쉽게 배포할 수 있도록 도와줍니다.\n\n조사를 한 결과, Electron 앱을 만드는 방법이 웹 앱을 만드는 방법만큼 다양하다는 것을 빨리 깨달았습니다. POC는 React와 Material UI 컴포넌트를 사용하여 작성되어 있어서, Electron을 사용하기로 선택한 솔루션에서 계속 사용할 수 있는지가 중요했습니다. 몇 가지 다른 옵션을 테스트한 후, Electron과 React를 사용하여 빌드하기 위한 최상의 해결책은 Electron-React-Boilerplate임을 자신 있게 말할 수 있습니다.\n\n이 프로젝트는 포괄적인 기본 GitHub 저장소를 제공합니다. 추가 개발을 위해 준비된 간단한 웹 앱뿐만 아니라, 각 지원 OS에 대한 코드베이스 테스트를 위한 GitHub Actions, 결과 이진 파일을 빌드하고 게시하는 GitHub 릴리스, 코드 취약점을 스캔하는 등이 포함되어 있습니다. 개발적인 측면에서, 종속성을 설치한 후 npm start 명령어 하나로 프로젝트를 실행시킬 수 있습니다. Electron-React-Boilerplate를 사용하면 훌륭하게 구성된, 견해가 명확한 설정을 채택하고 내 앱을 구축하는 데 집중할 수 있습니다.\n\n\n\n다음 단계는 모든 하드 코딩된 매개변수를 React 상태로 변환하여 나중에 설정 패널에 포함할 것입니다. 이에는 이전에 환경 변수를 사용하여 웹 앱으로 전달했던 OpenAI API 키도 포함됩니다. 나는 사용자들이 혼란스러워하지 않도록 설정을 \"일반\"과 \"고급\"으로 분류하기로 결정했습니다. 참고용으로 아래 스크린샷을 확인해주세요.\n\n![이미지](/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_1.png)\n\n기본 설정이 정해지면, 나의 초점은 코딩에서 프로젝트의 다른 측면으로 옮겼습니다. 첫 번째 작업은 앱 로고를 만드는 것이었습니다. 예술가는 아니지만, 빠르게 DALL-E에게 로고를 생성하도록 요청하는 OpenAI API 키가 있었기 때문에 로고를 만들었습니다. 그 후 간단한 README를 작성하고 새 로고를 저장소에 추가했습니다.\n\n추가 조정을 통해, 내 POC(Concept화된 개념)를 베타 품질의 데스크탑 앱으로 성공적으로 변형했습니다. 간단한 아이디어를 가져와 사용 가능한 제품으로 발전시켰습니다. POC(Proof of Concept)를 제품으로 발전하는 과정은 절대적으로 간단하지 않지만, 적절한 도구를 갖추면 프로세스를 크게 용이하게 할 수 있습니다. 만약 Python과 JavaScript로 오픈 소스 프로젝트에 작업을 한다면, 유지해야 하는 코드 베이스 수가 두 배로 증가하고 웹 앱을 자체 호스팅하려는 사람들로만 구성되는 대상으로 제한될 것입니다. 그러나 Electron을 이용하면 사람들이 쉽게 다운로드하고 사용할 수 있는 앱을 만들고 배포할 수 있었습니다.\n\n\n\n![사진](/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_2.png)\n\n내가 만든 프로젝트는 \"편집장(Editor in Chief)\"입니다. 많은 사람들에게 정말 유용할 수 있는 잠재력이 있다고 생각해요.\n\n다음 수준으로 나아가는 데 도와주고 싶으세요? 사용해보고 버그 보고서를 제출하고 코드 및 문서를 기여하세요. 어떤 방식으로 상호 작용하든 상관없어요. 꼭 당신을 환영할 거예요.\n\nGPT-4를 활용한 기사 편집과 인공지능 기술을 활용한 작성을 위한 FOSS 솔루션인 '편집장(Editor in Chief)'을 이용해보세요.","ogImage":{"url":"/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_0.png"},"coverImage":"/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_0.png","tag":["Tech"],"readingTime":6}],"page":"105","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}