{"pageProps":{"post":{"title":"리액트 네이티브에서 페이지와 함께 페이지네이션하기","description":"","date":"2024-05-12 22:14","slug":"2024-05-12-PaginationinReactNativewithPage","content":"\n\n소개:\n\n페이지네이션은 React Native에서 대량의 데이터 목록을 효율적으로 관리하고 표시할 수 있게 해주는 강력한 기술입니다. 이 글에서는 FlatList와 페이지네이션 버튼을 사용하여 고급 페이지네이션을 구현하는 방법에 대해 알아볼 것입니다. 페이지네이션의 논리, 각 페이지별 데이터 검색 방법 및 렌더링 프로세스의 최적화에 대해 논의할 것입니다. 함께 React Native 페이지네이션을 마스터해봅시다!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Vj09FpPeRuOC7tDLGpBrsg.gif)\n\n```js\n..... 구성 요소 구조 ....\nconst handlePageClick = (p: number) => setCurrentPage(p);\n\n  const renderItem = ({item}: {item: ScoreCard}) => {\n    return <Card item={item} key={item.id} />;\n  };\n\nreturn (\n<SafeAreaView style={styles.container}>      \n      <FlatList\n        data={items}\n        renderItem={renderItem}\n        keyExtractor={item => item.id}\n        ListEmptyComponent={handleEmpty}\n        windowSize={10} // VirtualizedList의 기능 추가\n        refreshControl={\n          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />\n        }\n      />\n      <View style={styles.paginationContainer}>\n        {renderPaginationButtons()}\n      </View>\n    </SafeAreaView>\n)\n...\n```\n\n\n\n- 페이지네이션 로직\n\n저희 페이지네이션 구현의 핵심은 'Institution' 컴포넌트에 있습니다. 이 컴포넌트는 'useState'와 같은 React 훅을 사용하여 중요한 상태 변수를 관리합니다. 'currentPage' 상태는 현재 표시되는 페이지를 나타내고, 'totalPages'는 전체 목록에 대한 총 페이지 수를 저장합니다. 'itemsPerPage'를 설정하여 페이지 당 표시할 항목 수를 결정하여 로딩 프로세스를 최적화합니다.\n\n```js\nconst [totalPages, setTotalpages] = useState(0);\nconst [currentPage, setCurrentPage] = useState(0);\nconst [items, setItems] = useState([]);\nconst [refreshing, setRefreshing] = useState(false);\nconst itemsPerPage = 16;\n```\n\n2. 각 페이지의 데이터 가져오기\n\n\n\n'fetchData' 함수는 페이지네이션 로직의 중요한 부분입니다. 'Institution' 컴포넌트가 마운트되거나 'currentPage'가 변경될 때마다 해당 함수를 호출하여 현재 페이지의 데이터를 검색합니다. 우리는 데이터를 가져오는 작업을 처리하는 'fetcher' 유틸리티 함수를 사용합니다.\n\n```js\nuseEffect(() => {\n  fetchData();\n}, [currentPage]);\n\nasync function fetchData() {\n  setRefreshing(true);\n  try {\n    let response = await fetcher(currentPage, itemsPerPage);\n    setTotalpages(response.metadata.total / itemsPerPage);\n    let data: [] = response.results;\n    setItems(data);\n    setRefreshing(false);\n  } catch (error) {\n    setRefreshing(false);\n    console.log(error);\n  }\n}\n```\n\n3. 페이지네이션 버튼 처리\n\n사용자가 페이지별 목록을 탐색할 수 있도록 하기 위해, 페이지네이션 버튼을 렌더링할 때 TouchableOpacity 요소를 사용합니다. 'renderPaginationButtons' 함수는 'currentPage', 'totalPages', 그리고 표시할 최대 버튼 수('maxButtonsToShow')를 기반으로 표시할 페이지를 계산한 다음 적절한 버튼을 생성합니다.\n\n\n\n```js\nconst renderPaginationButtons = () => {\n  const maxButtonsToShow = 5;\n  let startPage = Math.max(0, currentPage - Math.floor(maxButtonsToShow / 2));\n  let endPage = Math.min(totalPages, startPage + maxButtonsToShow - 1);\n\n  if (endPage - startPage + 1 < maxButtonsToShow) {\n    startPage = Math.max(0, endPage - maxButtonsToShow + 1);\n  }\n\n  const buttons = [];\n\n  for (let i = startPage; i <= endPage; i++) {\n    buttons.push(\n      <TouchableOpacity\n        key={i}\n        onPress={() => handlePageClick(i)}\n        style={[\n          styles.paginationButton,\n          i === currentPage ? styles.activeButton : null,\n        ]}>\n        <Text style={{color: 'white'}}>{i}</Text>\n      </TouchableOpacity>,\n    );\n  }\n\n  return buttons;\n};\n```\n\n4. Pull-to-Refresh 및 데이터 없음 처리\n\n더 나은 사용자 경험을 제공하기 위해 'RefreshControl'를 사용하여 pull-to-refresh 기능을 구현했습니다. 사용자는 필요할 때 목록을 수동으로 새로 고칠 수 있습니다. 추가로, 표시할 기관이 없는 시나리오를 처리하기 위해 '기관 없음' 메시지를 렌더링합니다.\n\n```js\nconst handleRefresh = () => {\n  setRefreshing(true);\n  setTimeout(() => setRefreshing(false), 1000);\n};\n\nconst handleEmpty = () => {\n  return <Text>기관이 없습니다!</Text>;\n};\n```\n\n\n\n5. 더 나은 사용자 경험을 위한 스타일링\n\n저희는 컴포넌트에 시각적 매력을 더하기 위해 StyleSheet를 활용합니다. 페이지네이션 버튼은 활성화될 때 색상과 크기가 변경되어 사용자에게 시각적 피드백을 제공하여 전체 앱 경험을 향상시킵니다.\n\n```js\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  paginationContainer: {\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingVertical: 8,\n    backgroundColor: 'transparent',\n  },\n  paginationButton: {\n    justifyContent: 'center',\n    alignItems: 'center',\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    marginHorizontal: 4,\n    backgroundColor: 'gray',\n  },\n  activeButton: {\n    backgroundColor: '#22c55d',\n    width: 50,\n    height: 50,\n    borderRadius: 25,\n  },\n  buttonText: {\n    color: 'white',\n  },\n});\n```\n\n맺음말\n\n\n\n이 코드에 대한 링크는 여기에서 확인할 수 있습니다 - ` paginate. React Native pagination을 FlatList와 페이지 버튼으로 마스터하여 대량의 데이터 목록을 손쉽게 처리하여 부드러운 성능과 더 나은 사용자 경험을 보장할 수 있습니다. 페이지네이션은 렌더링을 크게 최적화하며 네트워크 리소스 부하를 줄이고 전반적인 앱 대응성을 향상시킵니다. React Native 애플리케이션에서 고급 페이지네이션을 구현하는 것은 고품질이고 성능이 우수한 모바일 앱을 제공하는 데 유용한 기술입니다.","ogImage":{"url":"/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png"},"coverImage":"/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>소개:</p>\n<p>페이지네이션은 React Native에서 대량의 데이터 목록을 효율적으로 관리하고 표시할 수 있게 해주는 강력한 기술입니다. 이 글에서는 FlatList와 페이지네이션 버튼을 사용하여 고급 페이지네이션을 구현하는 방법에 대해 알아볼 것입니다. 페이지네이션의 논리, 각 페이지별 데이터 검색 방법 및 렌더링 프로세스의 최적화에 대해 논의할 것입니다. 함께 React Native 페이지네이션을 마스터해봅시다!</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*Vj09FpPeRuOC7tDLGpBrsg.gif\" alt=\"이미지\"></p>\n<pre><code class=\"hljs language-js\">..... 구성 요소 구조 ....\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handlePageClick</span> = (<span class=\"hljs-params\">p: number</span>) => <span class=\"hljs-title function_\">setCurrentPage</span>(p);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">renderItem</span> = (<span class=\"hljs-params\">{item}: {item: ScoreCard}</span>) => {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Card</span> <span class=\"hljs-attr\">item</span>=<span class=\"hljs-string\">{item}</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{item.id}</span> /></span></span>;\n  };\n\n<span class=\"hljs-keyword\">return</span> (\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">SafeAreaView</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{styles.container}</span>></span>      \n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">FlatList</span>\n        <span class=\"hljs-attr\">data</span>=<span class=\"hljs-string\">{items}</span>\n        <span class=\"hljs-attr\">renderItem</span>=<span class=\"hljs-string\">{renderItem}</span>\n        <span class=\"hljs-attr\">keyExtractor</span>=<span class=\"hljs-string\">{item</span> =></span> item.id}\n        ListEmptyComponent={handleEmpty}\n        windowSize={10} // VirtualizedList의 기능 추가\n        refreshControl={\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">RefreshControl</span> <span class=\"hljs-attr\">refreshing</span>=<span class=\"hljs-string\">{refreshing}</span> <span class=\"hljs-attr\">onRefresh</span>=<span class=\"hljs-string\">{handleRefresh}</span> /></span>\n        }\n      />\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{styles.paginationContainer}</span>></span>\n        {renderPaginationButtons()}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">View</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">SafeAreaView</span>></span></span>\n)\n...\n</code></pre>\n<ul>\n<li>페이지네이션 로직</li>\n</ul>\n<p>저희 페이지네이션 구현의 핵심은 'Institution' 컴포넌트에 있습니다. 이 컴포넌트는 'useState'와 같은 React 훅을 사용하여 중요한 상태 변수를 관리합니다. 'currentPage' 상태는 현재 표시되는 페이지를 나타내고, 'totalPages'는 전체 목록에 대한 총 페이지 수를 저장합니다. 'itemsPerPage'를 설정하여 페이지 당 표시할 항목 수를 결정하여 로딩 프로세스를 최적화합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> [totalPages, setTotalpages] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n<span class=\"hljs-keyword\">const</span> [currentPage, setCurrentPage] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n<span class=\"hljs-keyword\">const</span> [items, setItems] = <span class=\"hljs-title function_\">useState</span>([]);\n<span class=\"hljs-keyword\">const</span> [refreshing, setRefreshing] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n<span class=\"hljs-keyword\">const</span> itemsPerPage = <span class=\"hljs-number\">16</span>;\n</code></pre>\n<ol start=\"2\">\n<li>각 페이지의 데이터 가져오기</li>\n</ol>\n<p>'fetchData' 함수는 페이지네이션 로직의 중요한 부분입니다. 'Institution' 컴포넌트가 마운트되거나 'currentPage'가 변경될 때마다 해당 함수를 호출하여 현재 페이지의 데이터를 검색합니다. 우리는 데이터를 가져오는 작업을 처리하는 'fetcher' 유틸리티 함수를 사용합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-title function_\">fetchData</span>();\n}, [currentPage]);\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">setRefreshing</span>(<span class=\"hljs-literal\">true</span>);\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetcher</span>(currentPage, itemsPerPage);\n    <span class=\"hljs-title function_\">setTotalpages</span>(response.<span class=\"hljs-property\">metadata</span>.<span class=\"hljs-property\">total</span> / itemsPerPage);\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">data</span>: [] = response.<span class=\"hljs-property\">results</span>;\n    <span class=\"hljs-title function_\">setItems</span>(data);\n    <span class=\"hljs-title function_\">setRefreshing</span>(<span class=\"hljs-literal\">false</span>);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-title function_\">setRefreshing</span>(<span class=\"hljs-literal\">false</span>);\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error);\n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li>페이지네이션 버튼 처리</li>\n</ol>\n<p>사용자가 페이지별 목록을 탐색할 수 있도록 하기 위해, 페이지네이션 버튼을 렌더링할 때 TouchableOpacity 요소를 사용합니다. 'renderPaginationButtons' 함수는 'currentPage', 'totalPages', 그리고 표시할 최대 버튼 수('maxButtonsToShow')를 기반으로 표시할 페이지를 계산한 다음 적절한 버튼을 생성합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">renderPaginationButtons</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> maxButtonsToShow = <span class=\"hljs-number\">5</span>;\n  <span class=\"hljs-keyword\">let</span> startPage = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-number\">0</span>, currentPage - <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(maxButtonsToShow / <span class=\"hljs-number\">2</span>));\n  <span class=\"hljs-keyword\">let</span> endPage = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(totalPages, startPage + maxButtonsToShow - <span class=\"hljs-number\">1</span>);\n\n  <span class=\"hljs-keyword\">if</span> (endPage - startPage + <span class=\"hljs-number\">1</span> &#x3C; maxButtonsToShow) {\n    startPage = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-number\">0</span>, endPage - maxButtonsToShow + <span class=\"hljs-number\">1</span>);\n  }\n\n  <span class=\"hljs-keyword\">const</span> buttons = [];\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = startPage; i &#x3C;= endPage; i++) {\n    buttons.<span class=\"hljs-title function_\">push</span>(\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">TouchableOpacity</span>\n        <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{i}</span>\n        <span class=\"hljs-attr\">onPress</span>=<span class=\"hljs-string\">{()</span> =></span> handlePageClick(i)}\n        style={[\n          styles.paginationButton,\n          i === currentPage ? styles.activeButton : null,\n        ]}>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Text</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{color:</span> '<span class=\"hljs-attr\">white</span>'}}></span>{i}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Text</span>></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">TouchableOpacity</span>></span></span>,\n    );\n  }\n\n  <span class=\"hljs-keyword\">return</span> buttons;\n};\n</code></pre>\n<ol start=\"4\">\n<li>Pull-to-Refresh 및 데이터 없음 처리</li>\n</ol>\n<p>더 나은 사용자 경험을 제공하기 위해 'RefreshControl'를 사용하여 pull-to-refresh 기능을 구현했습니다. 사용자는 필요할 때 목록을 수동으로 새로 고칠 수 있습니다. 추가로, 표시할 기관이 없는 시나리오를 처리하기 위해 '기관 없음' 메시지를 렌더링합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleRefresh</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-title function_\">setRefreshing</span>(<span class=\"hljs-literal\">true</span>);\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">setRefreshing</span>(<span class=\"hljs-literal\">false</span>), <span class=\"hljs-number\">1000</span>);\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleEmpty</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Text</span>></span>기관이 없습니다!<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Text</span>></span></span>;\n};\n</code></pre>\n<ol start=\"5\">\n<li>더 나은 사용자 경험을 위한 스타일링</li>\n</ol>\n<p>저희는 컴포넌트에 시각적 매력을 더하기 위해 StyleSheet를 활용합니다. 페이지네이션 버튼은 활성화될 때 색상과 크기가 변경되어 사용자에게 시각적 피드백을 제공하여 전체 앱 경험을 향상시킵니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> styles = <span class=\"hljs-title class_\">StyleSheet</span>.<span class=\"hljs-title function_\">create</span>({\n  <span class=\"hljs-attr\">container</span>: {\n    <span class=\"hljs-attr\">flex</span>: <span class=\"hljs-number\">1</span>,\n  },\n  <span class=\"hljs-attr\">paginationContainer</span>: {\n    <span class=\"hljs-attr\">flexDirection</span>: <span class=\"hljs-string\">'row'</span>,\n    <span class=\"hljs-attr\">justifyContent</span>: <span class=\"hljs-string\">'center'</span>,\n    <span class=\"hljs-attr\">alignItems</span>: <span class=\"hljs-string\">'center'</span>,\n    <span class=\"hljs-attr\">paddingVertical</span>: <span class=\"hljs-number\">8</span>,\n    <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">'transparent'</span>,\n  },\n  <span class=\"hljs-attr\">paginationButton</span>: {\n    <span class=\"hljs-attr\">justifyContent</span>: <span class=\"hljs-string\">'center'</span>,\n    <span class=\"hljs-attr\">alignItems</span>: <span class=\"hljs-string\">'center'</span>,\n    <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">40</span>,\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">40</span>,\n    <span class=\"hljs-attr\">borderRadius</span>: <span class=\"hljs-number\">20</span>,\n    <span class=\"hljs-attr\">marginHorizontal</span>: <span class=\"hljs-number\">4</span>,\n    <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">'gray'</span>,\n  },\n  <span class=\"hljs-attr\">activeButton</span>: {\n    <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">'#22c55d'</span>,\n    <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">50</span>,\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">50</span>,\n    <span class=\"hljs-attr\">borderRadius</span>: <span class=\"hljs-number\">25</span>,\n  },\n  <span class=\"hljs-attr\">buttonText</span>: {\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'white'</span>,\n  },\n});\n</code></pre>\n<p>맺음말</p>\n<p>이 코드에 대한 링크는 여기에서 확인할 수 있습니다 - ` paginate. React Native pagination을 FlatList와 페이지 버튼으로 마스터하여 대량의 데이터 목록을 손쉽게 처리하여 부드러운 성능과 더 나은 사용자 경험을 보장할 수 있습니다. 페이지네이션은 렌더링을 크게 최적화하며 네트워크 리소스 부하를 줄이고 전반적인 앱 대응성을 향상시킵니다. React Native 애플리케이션에서 고급 페이지네이션을 구현하는 것은 고품질이고 성능이 우수한 모바일 앱을 제공하는 데 유용한 기술입니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}