{"pageProps":{"post":{"title":"경이로운 WebGL 점 구체 만드는 방법","description":"","date":"2024-06-22 13:43","slug":"2024-06-22-StunningWebGLDotSpheres","content":"\n\n\n![Image](/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png)\n\n최근에 Stripe와 GitHub에서 WebGL 지구 모형이 눈에 띄게 사용되면서 많은 관심을 받았습니다. 둘 다 자사 홈페이지에서 그것들을 주목적으로 활용했고, 이에 관한 블로그 포스트를 작성했습니다(Stripe의 포스트는 [여기](Stripe's link)에서 확인할 수 있고, GitHub의는 [여기](GitHub's link)에서 확인할 수 있습니다).\n\n두 지구 모형은 대부분 점들로 이루어져 있는데, 이것이 저에게 구체 표면에 점들을 분산시키는 다양한 방법에 대해 생각해보게 했습니다. 구 형태에 대한 점 배치는 수학자들이 적극적으로 고민하는 복잡한 퍼즐로, 이 기사를 위해서 제가 몇 가지 기본적인 방법을 소개하고 WebGL에서 어떻게 구현할 수 있는지에 대해 제한했습니다.\n\n# 씬 설정하기\n\n\n<div class=\"content-ad\"></div>\n\n현재 진행하기 전에, 구를 만들 WebGL 씬을 구축하는 것이 필요합니다. WebGL API와 상호 작용하기 위한 주요 프레임워크로 Three.js를 사용하고 있어요. 이 글의 코드 스니펫은 간결하고 관련성이 높도록 유지하고 있으니, 전체 코드를 확인하려면 포함된 샌드박스를 살펴보세요.\n\n씬을 생성한 후, 모든 점에 대한 geometries를 포함할 dotGeometries 배열을 정의합니다. 그런 다음, 씬 내의 공간에 빈 벡터, 즉 3D 포인트를 생성하며, 해당 위치는 각각의 점을 만들 때마다 재할당됩니다.\n\n```js\n// 씬을 설정합니다.\nconst scene = new THREE.Scene();\n\n// 모든 점의 geometries를 보관할 배열을 정의합니다.\nconst dotGeometries = [];\n\n// 점에서 사용할 빈 벡터를 생성합니다.\nconst vector = new THREE.Vector3();\n\n// 이곳에서 점을 생성하고 위치를 지정합니다!\n```\n\n점을 생성하고 그 geometries를 dotGeometries 배열에 넣은 후, mergeBufferGeometries 유틸리티를 사용하여 이를 하나의 geometry로 병합할 수 있습니다. 그런 다음, dot geometries에서 mesh를 생성하고, 이에 재질을 부여하고 씬에 추가하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 모든 점 지오메트리를 하나의 버퍼 지오메트리로 병합합니다.\nconst mergedDotGeometries = BufferGeometryUtils.mergeBufferGeometries(\n  dotGeometries\n);\n\n// 점을 위한 재질을 정의합니다.\nconst dotMaterial = new THREE.MeshBasicMaterial({\n  color: DOT_COLOR,\n  side: THREE.DoubleSide\n});\n\n// 점 지오메트리와 재질에서 점 메시를 생성합니다.\nconst dotMesh = new THREE.Mesh(mergedDotGeometries, dotMaterial);\n\n// 점 메시를 씬에 추가합니다.\nscene.add(dotMesh);\n```\n\n이제 어떻게 점을 생성하고 배치할지 살펴봅시다.\n\n# 기본적인 접근 방법\n\n구에 점을 추가하는 가장 쉬운 방법은 단순히 구가 갖도록 원하는 위도 선 및 경도 선의 수를 정의한 다음 해당 선들에 따라 점을 배치하는 것입니다. 여기에는 몇 가지 중요한 사항이 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n먼저, 각 점에 대해 phi와 theta 각도를 정의합니다. 이러한 각도는 구 좌표계의 일부로, 점이 3D 공간에서 원점과의 관계를 정확히 나타내는 시스템입니다 (우리의 경우에는 구의 중심).\n\n두 번째로, phi와 theta는 모두 라디안으로 측정됩니다. 핵심은 180º에 π 라디안이 있다는 것을 기억하는 것입니다. 여기서 phi를 찾기 위해선 단순히 π를 위도 주선 수로 나누면 됩니다. 그러나 theta를 찾기 위해서는 경도 주선 수로 2 * π를 나누어야 합니다. 왜냐하면 경도 주선이 구의 전체 360º를 계속 감싸도록 하기 때문입니다.\n\n```js\n// 위도를 반복합니다.\nfor (let lat = 0; lat < LATITUDE_COUNT; lat += 1) {\n  // 경도를 반복합니다.\n  for (let lng = 0; lng < LONGITUDE_COUNT; lng += 1) {\n    // 점에 대한 geometry를 생성합니다.\n    const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n    // 점을 위한 phi와 theta 각도를 정의합니다.\n    const phi = (Math.PI / LATITUDE_COUNT) * lat;\n    const theta = ((2 * Math.PI) / LONGITUDE_COUNT) * lng;\n\n    // 구 반지름, phi 및 theta에서 생성된 구 좌표를 사용하여 벡터를 설정합니다.\n    vector.setFromSphericalCoords(SPHERE_RADIUS, phi, theta);\n\n    // 점이 올바른 방향을 향하도록 합니다.\n    dotGeometry.lookAt(vector);\n\n    // 점 geometry를 올바른 위치로 이동합니다.\n    dotGeometry.translate(vector.x, vector.y, vector.z);\n\n    // 위치 지정 geometry를 배열에 추가합니다.\n    dotGeometries.push(dotGeometry);\n  }\n}\n```\n\n이렇게 해서 다음 결과를 얻을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n만약 구를 회전시키면, 맨 위와 맨 아래의 고리가 가운데보다 훨씬 더 밀집되어 있는 것을 알게 될 거에요. 이는 각 위도선에 있는 점들의 개수를 다양하게 하지 않았기 때문입니다. 여기서 구 패킹이 필요한 때입니다.\n\n# 실로택시스 방법론\n\n해바라기 꽃의 머리나 솔방울의 바닥을 본 적이 있다면, 이상하고 독특한 패턴을 알아차릴 수 있을 겁니다. 이 패턴은 피보나치 수열을 기반으로 하는 배열에 의해 만들어져, 실로택시스로 알려져 있습니다. 이를 이용하여 점들을 구의 표면 위에 더 균일하게 위치시켜 보이도록 할 수 있습니다.\n\n이번에는 위도와 경도 선의 개수를 정의하는 대신, 단순히 구에 나타나길 원하는 총 점의 수를 정의합니다. 위도 선을 가로지르는 대신, 점들은 구의 한 극에서 다른 극까지 단일하고 연속적인 나선 형태로 렌더링될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 점의 개수만큼 반복합니다.\nfor (let dot = 0; dot < DOT_COUNT; dot += 1) {\n  // 점을 위한 geometry를 생성합니다.\n  const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n\n  // 각 점의 구면 좌표를 계산하여 피로태시스 패턴으로 만듭니다.\n  const phi = Math.acos(-1 + (2 * dot) / DOT_COUNT);\n  const theta = Math.sqrt(DOT_COUNT * Math.PI) * phi;\n\n  // 구의 반지름, phi 및 theta에서 생성된 구면 좌표를 사용하여 벡터를 설정합니다.\n  vector.setFromSphericalCoords(SPHERE_RADIUS, phi, theta);\n\n  ...\n\n}\n```\n\n위와 같은 결과가 나타납니다.\n\n이 방법은 훨씬 더 만족스럽습니다. 그러나 가능한 한 점들을 골고루 배치하고 싶지만 자유롭게 위도 선 수를 정의하고 싶다면 어떻게 해야 할까요?\n\n# 선형 접근법\n\n\n<div class=\"content-ad\"></div>\n\n이번에는 필요한 위도선 수를 정의하되, 점의 수도 위치한 위도선의 둘레에 기반하여 조절됩니다. 간격에 대한 더 큰 제어를 위해 점 밀도 매개변수도 정의할 것입니다.\n\n여기서 까다로운 부분은 각 위도선의 반지름을 계산하는 것입니다. 일단 그것을 구했다면, 얼마나 많은 점을 표시해야 하는지 간단히 알아내고, 각각에 대해 첫 번째 방법과 유사한 방식으로 파이와 세타를 찾는 것도 상대적으로 간단합니다.\n\n```js\n// 위도 선을 가로지르는 루프\n  for (let lat = 0; lat < LATITUDE_COUNT; lat += 1) {\n    // 위도선의 반지름 계산\n    const radius =\n      Math.cos((-90 + (180 / LATITUDE_COUNT) * lat) * (Math.PI / 180)) *\n      SPHERE_RADIUS;\n    // 위도선의 둘레 계산\n    const latitudeCircumference = radius * Math.PI * 2 * 2;\n    // 해당 위도선에 필요한 점의 수 계산\n    const latitudeDotCount = Math.ceil(latitudeCircumference * DOT_DENSITY);\n\n    // 해당 위도선의 점 수에 대해 루프 수행\n    for (let dot = 0; dot < latitudeDotCount; dot += 1) {\n      const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n      // 점을 위한 파이와 세타 각도 계산\n      const phi = (Math.PI / LATITUDE_COUNT) * lat;\n      const theta = ((2 * Math.PI) / latitudeDotCount) * dot;\n\n      ...\n\n    }\n  }\n```\n\n이로써 매우 만족스러운 점 배치가 됩니다:\n\n<div class=\"content-ad\"></div>\n\n저희는 구체에 점들이 표시되는 방법에 대해 다루었습니다. 그렇다면 더 복잡한 효과를 얻을 수는 없을까요?\n\n# 모양 마스킹\n\n더 복잡한 패턴으로 점을 표시하는 방법을 알아내려면 수학적인 두통으로 빠르게 빠질 수 있습니다. 그러나 위의 포장 배치 중 하나와 마스크 이미지를 결합하여 일부 특별한 효과를 얻을 수 있습니다.\n\n이를 위해 먼저 HTML 캔버스 요소를 만들고 마스크 이미지를 그려야 합니다. 이 요소는 실제로 화면에 렌더링되지 않습니다. 이미지에서 픽셀 데이터를 추출하는 편리한 방법 뿐입니다. 이 일은 한 번만 해야하므로 미리 수행한 다음 추출된 이미지 데이터를 renderScene 함수로 전달하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이미지 로더를 초기화합니다.\nconst imageLoader = new THREE.ImageLoader();\n\n// 점이 표시되는 위치를 결정하는 이미지를 로드합니다. 이 작업이 완료되기 전에 구 cannot be initialised until this is complete.\nimageLoader.load(MASK_IMAGE, (image) => {\n    // HTML 캔버스를 생성하고 해당 캔버스의 컨텍스트를 가져와 이미지를 그립니다.\n    const tempCanvas = document.createElement(\"canvas\");\n\n    tempCanvas.width = image.width;\n    tempCanvas.height = image.height;\n\n    const ctx = tempCanvas.getContext(\"2d\");\n\n    ctx.drawImage(image, 0, 0);\n\n    // 캔버스 컨텍스트에서 이미지 데이터를 읽어옵니다.\n    const imageData = ctx.getImageData(0, 0, image.width, image.height);\n\n    renderScene(imageData);\n});\n```\n\n이제 이미지 데이터를 사용할 수 있으므로 몇 가지 유틸리티 함수를 추가해야 합니다. 첫 번째 함수는 구의 한 점을 가져와 해당 점이 구에 매핑된 경우 mask 이미지에서의 UV 좌표를 반환합니다.\n\n```js\n// 구의 한 점을 가져와 해당 점이 사각 텍스처 또는 이미지에서 UV 포인트로 변환하는 유틸리티 함수입니다.\nconst spherePointToUV = (dotCenter, sphereCenter) => {\n    // 구의 중심에서 점의 중심 방향을 나타내는 새로운 벡터를 만듭니다.\n    const newVector = new THREE.Vector3();\n    newVector.subVectors(sphereCenter, dotCenter).normalize();\n\n    // 점의 UV 좌표를 계산해서 벡터로 반환합니다.\n    const uvX = 1 - (0.5 + Math.atan2(newVector.z, newVector.x) / (2 * Math.PI));\n    const uvY = 0.5 + Math.asin(newVector.y) / Math.PI;\n\n    return new THREE.Vector2(uvX, uvY);\n};\n```\n\n두 번째 함수는 주어진 UV 좌표에서 mask 이미지의 픽셀 데이터를 반환합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이미지에서 특정 지점의 데이터를 샘플링하는 유틸리티 함수입니다. imageData 객체가 필요합니다.\nconst sampleImage = (imageData, uv) => {\n  // UV 좌표를 기반으로 점의 데이터를 계산하고 반환합니다.\n  const point =\n    4 * Math.floor(uv.x * imageData.width) +\n    Math.floor(uv.y * imageData.height) * (4 * imageData.width);\n\n  return imageData.data.slice(point, point + 4);\n};\n```\n\n이제 마스킹 효과를 적용하는 데 필요한 모든 것을 갖추었습니다. 각 점의 위치를 계산한 후에 해당 점의 경계 구를 계산합니다. 이후에 이를 사용하여 dot의 중심점을 spherePointToUV 함수에 전달할 수 있습니다. 이후에는 sampleImage 함수를 사용하여 해당 지점의 특정 픽셀 데이터를 찾을 수 있습니다. 픽셀이 투명하지 않으면 도트를 포함하고, 투명하면 도트를 제외합니다.\n\n```js\n// 도트 geometry를 위치로 이동합니다.\ndotGeometry.translate(vector.x, vector.y, vector.z);\n\n// 도트의 경계 구를 찾습니다.\ndotGeometry.computeBoundingSphere();\n\n// 랜드 이미지에서 도트의 UV 위치를 찾습니다.\nconst uv = spherePointToUV(\n  dotGeometry.boundingSphere.center,\n  new THREE.Vector3()\n);\n\n// 주어진 UV 위치에서 랜드 이미지의 픽셀을 샘플링합니다.\nconst sampledPixel = sampleImage(imageData, uv);\n\n// 픽셀에 색상 값이 포함되어 있으면 (다시 말해, 투명하지 않으면),\n// 도트를 생성합니다. 그렇지 않으면 건너뜁니다.\nif (sampledPixel[3]) {\n  // 위치 지정 geometry를 배열에 추가합니다.\n  dotGeometries.push(dotGeometry);\n}\n```\n\n실제로는 투명 배경을 가진 png 이미지를 마스크로 지정할 수 있습니다. 도트는 이미지의 해당 점이 투명하지 않은 경우에만 구로 렌더링됩니다. 간단한 다이아몬드 패턴을 가진 이미지로부터 이 멋진 결과를 얻을 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n더 복잡한 마스크 이미지를 사용하여 이 지구 효과와 같은 모양을 얻을 수 있어요:\n\n또한 텍스트를 렌더링할 수도 있어요:\n\n# 여기까지!\n\n이러한 구 형상 기법들을 WebGL 쇼피스의 기초로 여러 곳에서 사용했어요. 이를 통해 여러분도 같은 작업을 해볼 수 있기를 바랄게요. 만약 이 기사를 즐겨보았거나 어떤 면에서 도움이 되었다면 꼭 알려주세요! 제 웹사이트는 여기 있어요.","ogImage":{"url":"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png"},"coverImage":"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png\" alt=\"Image\"></p>\n<p>최근에 Stripe와 GitHub에서 WebGL 지구 모형이 눈에 띄게 사용되면서 많은 관심을 받았습니다. 둘 다 자사 홈페이지에서 그것들을 주목적으로 활용했고, 이에 관한 블로그 포스트를 작성했습니다(Stripe의 포스트는 [여기](Stripe's link)에서 확인할 수 있고, GitHub의는 [여기](GitHub's link)에서 확인할 수 있습니다).</p>\n<p>두 지구 모형은 대부분 점들로 이루어져 있는데, 이것이 저에게 구체 표면에 점들을 분산시키는 다양한 방법에 대해 생각해보게 했습니다. 구 형태에 대한 점 배치는 수학자들이 적극적으로 고민하는 복잡한 퍼즐로, 이 기사를 위해서 제가 몇 가지 기본적인 방법을 소개하고 WebGL에서 어떻게 구현할 수 있는지에 대해 제한했습니다.</p>\n<h1>씬 설정하기</h1>\n<div class=\"content-ad\"></div>\n<p>현재 진행하기 전에, 구를 만들 WebGL 씬을 구축하는 것이 필요합니다. WebGL API와 상호 작용하기 위한 주요 프레임워크로 Three.js를 사용하고 있어요. 이 글의 코드 스니펫은 간결하고 관련성이 높도록 유지하고 있으니, 전체 코드를 확인하려면 포함된 샌드박스를 살펴보세요.</p>\n<p>씬을 생성한 후, 모든 점에 대한 geometries를 포함할 dotGeometries 배열을 정의합니다. 그런 다음, 씬 내의 공간에 빈 벡터, 즉 3D 포인트를 생성하며, 해당 위치는 각각의 점을 만들 때마다 재할당됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 씬을 설정합니다.</span>\n<span class=\"hljs-keyword\">const</span> scene = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">Scene</span>();\n\n<span class=\"hljs-comment\">// 모든 점의 geometries를 보관할 배열을 정의합니다.</span>\n<span class=\"hljs-keyword\">const</span> dotGeometries = [];\n\n<span class=\"hljs-comment\">// 점에서 사용할 빈 벡터를 생성합니다.</span>\n<span class=\"hljs-keyword\">const</span> vector = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">Vector3</span>();\n\n<span class=\"hljs-comment\">// 이곳에서 점을 생성하고 위치를 지정합니다!</span>\n</code></pre>\n<p>점을 생성하고 그 geometries를 dotGeometries 배열에 넣은 후, mergeBufferGeometries 유틸리티를 사용하여 이를 하나의 geometry로 병합할 수 있습니다. 그런 다음, dot geometries에서 mesh를 생성하고, 이에 재질을 부여하고 씬에 추가하면 됩니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 모든 점 지오메트리를 하나의 버퍼 지오메트리로 병합합니다.</span>\n<span class=\"hljs-keyword\">const</span> mergedDotGeometries = <span class=\"hljs-title class_\">BufferGeometryUtils</span>.<span class=\"hljs-title function_\">mergeBufferGeometries</span>(\n  dotGeometries\n);\n\n<span class=\"hljs-comment\">// 점을 위한 재질을 정의합니다.</span>\n<span class=\"hljs-keyword\">const</span> dotMaterial = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">MeshBasicMaterial</span>({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-variable constant_\">DOT_COLOR</span>,\n  <span class=\"hljs-attr\">side</span>: <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-property\">DoubleSide</span>\n});\n\n<span class=\"hljs-comment\">// 점 지오메트리와 재질에서 점 메시를 생성합니다.</span>\n<span class=\"hljs-keyword\">const</span> dotMesh = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">Mesh</span>(mergedDotGeometries, dotMaterial);\n\n<span class=\"hljs-comment\">// 점 메시를 씬에 추가합니다.</span>\nscene.<span class=\"hljs-title function_\">add</span>(dotMesh);\n</code></pre>\n<p>이제 어떻게 점을 생성하고 배치할지 살펴봅시다.</p>\n<h1>기본적인 접근 방법</h1>\n<p>구에 점을 추가하는 가장 쉬운 방법은 단순히 구가 갖도록 원하는 위도 선 및 경도 선의 수를 정의한 다음 해당 선들에 따라 점을 배치하는 것입니다. 여기에는 몇 가지 중요한 사항이 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>먼저, 각 점에 대해 phi와 theta 각도를 정의합니다. 이러한 각도는 구 좌표계의 일부로, 점이 3D 공간에서 원점과의 관계를 정확히 나타내는 시스템입니다 (우리의 경우에는 구의 중심).</p>\n<p>두 번째로, phi와 theta는 모두 라디안으로 측정됩니다. 핵심은 180º에 π 라디안이 있다는 것을 기억하는 것입니다. 여기서 phi를 찾기 위해선 단순히 π를 위도 주선 수로 나누면 됩니다. 그러나 theta를 찾기 위해서는 경도 주선 수로 2 * π를 나누어야 합니다. 왜냐하면 경도 주선이 구의 전체 360º를 계속 감싸도록 하기 때문입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 위도를 반복합니다.</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> lat = <span class=\"hljs-number\">0</span>; lat &#x3C; <span class=\"hljs-variable constant_\">LATITUDE_COUNT</span>; lat += <span class=\"hljs-number\">1</span>) {\n  <span class=\"hljs-comment\">// 경도를 반복합니다.</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> lng = <span class=\"hljs-number\">0</span>; lng &#x3C; <span class=\"hljs-variable constant_\">LONGITUDE_COUNT</span>; lng += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-comment\">// 점에 대한 geometry를 생성합니다.</span>\n    <span class=\"hljs-keyword\">const</span> dotGeometry = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">CircleGeometry</span>(<span class=\"hljs-variable constant_\">DOT_SIZE</span>, <span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-comment\">// 점을 위한 phi와 theta 각도를 정의합니다.</span>\n    <span class=\"hljs-keyword\">const</span> phi = (<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> / <span class=\"hljs-variable constant_\">LATITUDE_COUNT</span>) * lat;\n    <span class=\"hljs-keyword\">const</span> theta = ((<span class=\"hljs-number\">2</span> * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>) / <span class=\"hljs-variable constant_\">LONGITUDE_COUNT</span>) * lng;\n\n    <span class=\"hljs-comment\">// 구 반지름, phi 및 theta에서 생성된 구 좌표를 사용하여 벡터를 설정합니다.</span>\n    vector.<span class=\"hljs-title function_\">setFromSphericalCoords</span>(<span class=\"hljs-variable constant_\">SPHERE_RADIUS</span>, phi, theta);\n\n    <span class=\"hljs-comment\">// 점이 올바른 방향을 향하도록 합니다.</span>\n    dotGeometry.<span class=\"hljs-title function_\">lookAt</span>(vector);\n\n    <span class=\"hljs-comment\">// 점 geometry를 올바른 위치로 이동합니다.</span>\n    dotGeometry.<span class=\"hljs-title function_\">translate</span>(vector.<span class=\"hljs-property\">x</span>, vector.<span class=\"hljs-property\">y</span>, vector.<span class=\"hljs-property\">z</span>);\n\n    <span class=\"hljs-comment\">// 위치 지정 geometry를 배열에 추가합니다.</span>\n    dotGeometries.<span class=\"hljs-title function_\">push</span>(dotGeometry);\n  }\n}\n</code></pre>\n<p>이렇게 해서 다음 결과를 얻을 수 있습니다:</p>\n<div class=\"content-ad\"></div>\n<p>만약 구를 회전시키면, 맨 위와 맨 아래의 고리가 가운데보다 훨씬 더 밀집되어 있는 것을 알게 될 거에요. 이는 각 위도선에 있는 점들의 개수를 다양하게 하지 않았기 때문입니다. 여기서 구 패킹이 필요한 때입니다.</p>\n<h1>실로택시스 방법론</h1>\n<p>해바라기 꽃의 머리나 솔방울의 바닥을 본 적이 있다면, 이상하고 독특한 패턴을 알아차릴 수 있을 겁니다. 이 패턴은 피보나치 수열을 기반으로 하는 배열에 의해 만들어져, 실로택시스로 알려져 있습니다. 이를 이용하여 점들을 구의 표면 위에 더 균일하게 위치시켜 보이도록 할 수 있습니다.</p>\n<p>이번에는 위도와 경도 선의 개수를 정의하는 대신, 단순히 구에 나타나길 원하는 총 점의 수를 정의합니다. 위도 선을 가로지르는 대신, 점들은 구의 한 극에서 다른 극까지 단일하고 연속적인 나선 형태로 렌더링될 것입니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 점의 개수만큼 반복합니다.</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> dot = <span class=\"hljs-number\">0</span>; dot &#x3C; <span class=\"hljs-variable constant_\">DOT_COUNT</span>; dot += <span class=\"hljs-number\">1</span>) {\n  <span class=\"hljs-comment\">// 점을 위한 geometry를 생성합니다.</span>\n  <span class=\"hljs-keyword\">const</span> dotGeometry = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">CircleGeometry</span>(<span class=\"hljs-variable constant_\">DOT_SIZE</span>, <span class=\"hljs-number\">5</span>);\n\n  <span class=\"hljs-comment\">// 각 점의 구면 좌표를 계산하여 피로태시스 패턴으로 만듭니다.</span>\n  <span class=\"hljs-keyword\">const</span> phi = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">acos</span>(-<span class=\"hljs-number\">1</span> + (<span class=\"hljs-number\">2</span> * dot) / <span class=\"hljs-variable constant_\">DOT_COUNT</span>);\n  <span class=\"hljs-keyword\">const</span> theta = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sqrt</span>(<span class=\"hljs-variable constant_\">DOT_COUNT</span> * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>) * phi;\n\n  <span class=\"hljs-comment\">// 구의 반지름, phi 및 theta에서 생성된 구면 좌표를 사용하여 벡터를 설정합니다.</span>\n  vector.<span class=\"hljs-title function_\">setFromSphericalCoords</span>(<span class=\"hljs-variable constant_\">SPHERE_RADIUS</span>, phi, theta);\n\n  ...\n\n}\n</code></pre>\n<p>위와 같은 결과가 나타납니다.</p>\n<p>이 방법은 훨씬 더 만족스럽습니다. 그러나 가능한 한 점들을 골고루 배치하고 싶지만 자유롭게 위도 선 수를 정의하고 싶다면 어떻게 해야 할까요?</p>\n<h1>선형 접근법</h1>\n<div class=\"content-ad\"></div>\n<p>이번에는 필요한 위도선 수를 정의하되, 점의 수도 위치한 위도선의 둘레에 기반하여 조절됩니다. 간격에 대한 더 큰 제어를 위해 점 밀도 매개변수도 정의할 것입니다.</p>\n<p>여기서 까다로운 부분은 각 위도선의 반지름을 계산하는 것입니다. 일단 그것을 구했다면, 얼마나 많은 점을 표시해야 하는지 간단히 알아내고, 각각에 대해 첫 번째 방법과 유사한 방식으로 파이와 세타를 찾는 것도 상대적으로 간단합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 위도 선을 가로지르는 루프</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> lat = <span class=\"hljs-number\">0</span>; lat &#x3C; <span class=\"hljs-variable constant_\">LATITUDE_COUNT</span>; lat += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-comment\">// 위도선의 반지름 계산</span>\n    <span class=\"hljs-keyword\">const</span> radius =\n      <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cos</span>((-<span class=\"hljs-number\">90</span> + (<span class=\"hljs-number\">180</span> / <span class=\"hljs-variable constant_\">LATITUDE_COUNT</span>) * lat) * (<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> / <span class=\"hljs-number\">180</span>)) *\n      <span class=\"hljs-variable constant_\">SPHERE_RADIUS</span>;\n    <span class=\"hljs-comment\">// 위도선의 둘레 계산</span>\n    <span class=\"hljs-keyword\">const</span> latitudeCircumference = radius * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-comment\">// 해당 위도선에 필요한 점의 수 계산</span>\n    <span class=\"hljs-keyword\">const</span> latitudeDotCount = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">ceil</span>(latitudeCircumference * <span class=\"hljs-variable constant_\">DOT_DENSITY</span>);\n\n    <span class=\"hljs-comment\">// 해당 위도선의 점 수에 대해 루프 수행</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> dot = <span class=\"hljs-number\">0</span>; dot &#x3C; latitudeDotCount; dot += <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">const</span> dotGeometry = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">CircleGeometry</span>(<span class=\"hljs-variable constant_\">DOT_SIZE</span>, <span class=\"hljs-number\">5</span>);\n      <span class=\"hljs-comment\">// 점을 위한 파이와 세타 각도 계산</span>\n      <span class=\"hljs-keyword\">const</span> phi = (<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> / <span class=\"hljs-variable constant_\">LATITUDE_COUNT</span>) * lat;\n      <span class=\"hljs-keyword\">const</span> theta = ((<span class=\"hljs-number\">2</span> * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>) / latitudeDotCount) * dot;\n\n      ...\n\n    }\n  }\n</code></pre>\n<p>이로써 매우 만족스러운 점 배치가 됩니다:</p>\n<div class=\"content-ad\"></div>\n<p>저희는 구체에 점들이 표시되는 방법에 대해 다루었습니다. 그렇다면 더 복잡한 효과를 얻을 수는 없을까요?</p>\n<h1>모양 마스킹</h1>\n<p>더 복잡한 패턴으로 점을 표시하는 방법을 알아내려면 수학적인 두통으로 빠르게 빠질 수 있습니다. 그러나 위의 포장 배치 중 하나와 마스크 이미지를 결합하여 일부 특별한 효과를 얻을 수 있습니다.</p>\n<p>이를 위해 먼저 HTML 캔버스 요소를 만들고 마스크 이미지를 그려야 합니다. 이 요소는 실제로 화면에 렌더링되지 않습니다. 이미지에서 픽셀 데이터를 추출하는 편리한 방법 뿐입니다. 이 일은 한 번만 해야하므로 미리 수행한 다음 추출된 이미지 데이터를 renderScene 함수로 전달하면 됩니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이미지 로더를 초기화합니다.</span>\n<span class=\"hljs-keyword\">const</span> imageLoader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">ImageLoader</span>();\n\n<span class=\"hljs-comment\">// 점이 표시되는 위치를 결정하는 이미지를 로드합니다. 이 작업이 완료되기 전에 구 cannot be initialised until this is complete.</span>\nimageLoader.<span class=\"hljs-title function_\">load</span>(<span class=\"hljs-variable constant_\">MASK_IMAGE</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">image</span>) =></span> {\n    <span class=\"hljs-comment\">// HTML 캔버스를 생성하고 해당 캔버스의 컨텍스트를 가져와 이미지를 그립니다.</span>\n    <span class=\"hljs-keyword\">const</span> tempCanvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">\"canvas\"</span>);\n\n    tempCanvas.<span class=\"hljs-property\">width</span> = image.<span class=\"hljs-property\">width</span>;\n    tempCanvas.<span class=\"hljs-property\">height</span> = image.<span class=\"hljs-property\">height</span>;\n\n    <span class=\"hljs-keyword\">const</span> ctx = tempCanvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">\"2d\"</span>);\n\n    ctx.<span class=\"hljs-title function_\">drawImage</span>(image, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n\n    <span class=\"hljs-comment\">// 캔버스 컨텍스트에서 이미지 데이터를 읽어옵니다.</span>\n    <span class=\"hljs-keyword\">const</span> imageData = ctx.<span class=\"hljs-title function_\">getImageData</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, image.<span class=\"hljs-property\">width</span>, image.<span class=\"hljs-property\">height</span>);\n\n    <span class=\"hljs-title function_\">renderScene</span>(imageData);\n});\n</code></pre>\n<p>이제 이미지 데이터를 사용할 수 있으므로 몇 가지 유틸리티 함수를 추가해야 합니다. 첫 번째 함수는 구의 한 점을 가져와 해당 점이 구에 매핑된 경우 mask 이미지에서의 UV 좌표를 반환합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 구의 한 점을 가져와 해당 점이 사각 텍스처 또는 이미지에서 UV 포인트로 변환하는 유틸리티 함수입니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">spherePointToUV</span> = (<span class=\"hljs-params\">dotCenter, sphereCenter</span>) => {\n    <span class=\"hljs-comment\">// 구의 중심에서 점의 중심 방향을 나타내는 새로운 벡터를 만듭니다.</span>\n    <span class=\"hljs-keyword\">const</span> newVector = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">Vector3</span>();\n    newVector.<span class=\"hljs-title function_\">subVectors</span>(sphereCenter, dotCenter).<span class=\"hljs-title function_\">normalize</span>();\n\n    <span class=\"hljs-comment\">// 점의 UV 좌표를 계산해서 벡터로 반환합니다.</span>\n    <span class=\"hljs-keyword\">const</span> uvX = <span class=\"hljs-number\">1</span> - (<span class=\"hljs-number\">0.5</span> + <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">atan2</span>(newVector.<span class=\"hljs-property\">z</span>, newVector.<span class=\"hljs-property\">x</span>) / (<span class=\"hljs-number\">2</span> * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>));\n    <span class=\"hljs-keyword\">const</span> uvY = <span class=\"hljs-number\">0.5</span> + <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">asin</span>(newVector.<span class=\"hljs-property\">y</span>) / <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">Vector2</span>(uvX, uvY);\n};\n</code></pre>\n<p>두 번째 함수는 주어진 UV 좌표에서 mask 이미지의 픽셀 데이터를 반환합니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이미지에서 특정 지점의 데이터를 샘플링하는 유틸리티 함수입니다. imageData 객체가 필요합니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sampleImage</span> = (<span class=\"hljs-params\">imageData, uv</span>) => {\n  <span class=\"hljs-comment\">// UV 좌표를 기반으로 점의 데이터를 계산하고 반환합니다.</span>\n  <span class=\"hljs-keyword\">const</span> point =\n    <span class=\"hljs-number\">4</span> * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(uv.<span class=\"hljs-property\">x</span> * imageData.<span class=\"hljs-property\">width</span>) +\n    <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(uv.<span class=\"hljs-property\">y</span> * imageData.<span class=\"hljs-property\">height</span>) * (<span class=\"hljs-number\">4</span> * imageData.<span class=\"hljs-property\">width</span>);\n\n  <span class=\"hljs-keyword\">return</span> imageData.<span class=\"hljs-property\">data</span>.<span class=\"hljs-title function_\">slice</span>(point, point + <span class=\"hljs-number\">4</span>);\n};\n</code></pre>\n<p>이제 마스킹 효과를 적용하는 데 필요한 모든 것을 갖추었습니다. 각 점의 위치를 계산한 후에 해당 점의 경계 구를 계산합니다. 이후에 이를 사용하여 dot의 중심점을 spherePointToUV 함수에 전달할 수 있습니다. 이후에는 sampleImage 함수를 사용하여 해당 지점의 특정 픽셀 데이터를 찾을 수 있습니다. 픽셀이 투명하지 않으면 도트를 포함하고, 투명하면 도트를 제외합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 도트 geometry를 위치로 이동합니다.</span>\ndotGeometry.<span class=\"hljs-title function_\">translate</span>(vector.<span class=\"hljs-property\">x</span>, vector.<span class=\"hljs-property\">y</span>, vector.<span class=\"hljs-property\">z</span>);\n\n<span class=\"hljs-comment\">// 도트의 경계 구를 찾습니다.</span>\ndotGeometry.<span class=\"hljs-title function_\">computeBoundingSphere</span>();\n\n<span class=\"hljs-comment\">// 랜드 이미지에서 도트의 UV 위치를 찾습니다.</span>\n<span class=\"hljs-keyword\">const</span> uv = <span class=\"hljs-title function_\">spherePointToUV</span>(\n  dotGeometry.<span class=\"hljs-property\">boundingSphere</span>.<span class=\"hljs-property\">center</span>,\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">THREE</span>.<span class=\"hljs-title class_\">Vector3</span>()\n);\n\n<span class=\"hljs-comment\">// 주어진 UV 위치에서 랜드 이미지의 픽셀을 샘플링합니다.</span>\n<span class=\"hljs-keyword\">const</span> sampledPixel = <span class=\"hljs-title function_\">sampleImage</span>(imageData, uv);\n\n<span class=\"hljs-comment\">// 픽셀에 색상 값이 포함되어 있으면 (다시 말해, 투명하지 않으면),</span>\n<span class=\"hljs-comment\">// 도트를 생성합니다. 그렇지 않으면 건너뜁니다.</span>\n<span class=\"hljs-keyword\">if</span> (sampledPixel[<span class=\"hljs-number\">3</span>]) {\n  <span class=\"hljs-comment\">// 위치 지정 geometry를 배열에 추가합니다.</span>\n  dotGeometries.<span class=\"hljs-title function_\">push</span>(dotGeometry);\n}\n</code></pre>\n<p>실제로는 투명 배경을 가진 png 이미지를 마스크로 지정할 수 있습니다. 도트는 이미지의 해당 점이 투명하지 않은 경우에만 구로 렌더링됩니다. 간단한 다이아몬드 패턴을 가진 이미지로부터 이 멋진 결과를 얻을 수 있습니다:</p>\n<div class=\"content-ad\"></div>\n<p>더 복잡한 마스크 이미지를 사용하여 이 지구 효과와 같은 모양을 얻을 수 있어요:</p>\n<p>또한 텍스트를 렌더링할 수도 있어요:</p>\n<h1>여기까지!</h1>\n<p>이러한 구 형상 기법들을 WebGL 쇼피스의 기초로 여러 곳에서 사용했어요. 이를 통해 여러분도 같은 작업을 해볼 수 있기를 바랄게요. 만약 이 기사를 즐겨보았거나 어떤 면에서 도움이 되었다면 꼭 알려주세요! 제 웹사이트는 여기 있어요.</p>\n</body>\n</html>\n"},"__N_SSG":true}