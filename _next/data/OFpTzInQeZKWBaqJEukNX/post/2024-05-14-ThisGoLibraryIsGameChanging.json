{"pageProps":{"post":{"title":"이 Go 라이브러리는 혁신적입니다","description":"","date":"2024-05-14 11:39","slug":"2024-05-14-ThisGoLibraryIsGameChanging","content":"\n\n<img src=\"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png\" />\n\nReact의 강력한 기능 중 하나는 JSX입니다. React는 렌더링 로직이 다른 UI 로직과 본질적으로 결합되어 있다는 사실을 받아들입니다. Jinja와 같은 템플릿 엔진을 사용하는 것은 데이터를 컴포넌트로 전달하는 대신 엔진에 문맥을 '전달'해야 한다는 사실로 인해 같은 경험을 제공해주지 않습니다.\n\n# Templ은 HTML과 Go 사이의 간격을 좁히려고 합니다\n\n```js\npackage main\n\n// 우리 Component에서 사용할 수 있는 일반 Go 코드\nvar greeting = \"환영합니다!\"\n\n// templ Component\ntempl headerTemplate(name string) {\n  <header>\n    <h1>{ name }</h1>\n    <h2>\"{ greeting }\"은 일반 Go 코드에서 옵니다</h2>\n  </header>\n}\n```\n\n\n\n다음과 같이 templ은 Go에 자체 구문을 추가하지만 기본적으로 함수처럼 작동합니다.\n\n# 구성\n\n## Templ\n\n```js\npackage components\n\ntempl Link(name string, path string) {\n    - <li>\n    -     <a href={templ.URL(path)}>{name}</a>\n    - </li>\n}\n\ntempl NavBar() {\n    - @Link(\"Home\", \"home\")\n    - @Link(\"News\", \"news\")\n    - @Link(\"Contact Us\", \"contact-us\")\n}\n```\n\n\n\n## 리엑트\n\n```js\nfunction Welcome(props) {\n  return <h1>안녕, {props.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"사라\" />\n      <Welcome name=\"카할\" />\n      <Welcome name=\"에디트\" />\n    </div>\n  );\n}\n```\n\n보시다시피 구문은 매우 유사합니다. 리엑트 컴포넌트는 HTML 스타일 요소로 변합니다.\n\n# For 루프\n\n\n\n```js\npackage main\n\ntempl nameList(items []Item) {\n  <ul>\n  for _, item := range items {\n    <li>{ item.Name }</li>\n  }\n  </ul>\n}\n```\n\n여기서 Javascript가 약간 뛰어나다고 할 수 있습니다. Javascript에는 배열을 쉽게 반복할 수 있는 Map 함수와 같은 작은 도우미들이 많이 있습니다.\n\n# Javascript\n\n문법이 React와 비슷해 보이지만, 완전히 다릅니다. Templ은 Javascript와 상호 작용할 수 없도록 제한됩니다.\n\n\n\n```js\ntempl body() {\n <script>\n  const chart = LightweightCharts.createChart(document.body, { width: 400, height: 300 });\n  const lineSeries = chart.addLineSeries();\n  lineSeries.setData([\n    { time: '2019-04-11', value: 80.01 },\n    { time: '2019-04-12', value: 96.63 },\n    { time: '2019-04-13', value: 76.64 },\n    { time: '2019-04-14', value: 81.89 },\n    { time: '2019-04-15', value: 74.43 },\n    { time: '2019-04-16', value: 80.01 },\n    { time: '2019-04-17', value: 96.63 },\n    { time: '2019-04-18', value: 76.64 },\n    { time: '2019-04-19', value: 81.89 },\n    { time: '2019-04-20', value: 74.43 },\n  ]);\n </script>\n}\n```\n\n템플은 그냥 템플릿 엔진일 뿐이에요. 텍스트를 합쳐주는 거죠.\n\n# 템플 설치하기\n\n```js\ngo install github.com/a-h/templ/cmd/templ@latest\n```\n\n\n\n# Templ은 어떻게 작동하나요?\n\nTempl 문서에서는 모든 .templ 파일을 components 폴더/패키지에 저장하는 것을 권장합니다.\n\n```js\n//navbar.templ\npackage components\n\ntempl Link(name string, path string) {\n    <li>\n        <a href={templ.URL(path)}>{name}</a>\n    </li>\n}\n\ntempl NavBar() {\n    @Link(\"Home\", \"home\")\n    @Link(\"News\", \"news\")\n    @Link(\"Contact Us\", \"contact-us\")\n}\n```\n\n그런 다음 .templ 파일을 만든 후 다음 명령을 실행하면 됩니다:\n\n\n\n```js\ntempl generate\n```\n\n그런 다음, 코드 생성을 사용하여 별도의 ‘navbar_templ.go’ 파일을 생성합니다.\n\n<img src=\"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_1.png\" />\n\n그런 다음 핸들러에서는 간단히 Render 함수를 호출할 수 있습니다.\n\n\n\n\n```js\npackage main\n\nimport (\n\"context\"\n\"templ-echo-test/components\"\n\n\"github.com/labstack/echo/v4\"\n)\n\nfunc Page(c echo.Context) error {\nreturn components.NavBar().Render(context.Background(), c.Response())\n}\n```\n\n코드 생성 패스 없이는 Go가 .templ 파일을 읽을 수 없습니다.\n\n# 핫 리로드\n\ntempl을 사용하는 Go 웹 애플리케이션에 웹 브라우저에서 액세스하려면 몇 가지 일이 발생해야 합니다:\n\n\n\n\n- templ generate 명령을 실행하여 *.templ 파일에서 Go 코드 (*_templ.go 파일)를 생성해야 합니다.\n- Go 코드는 포트에서 웹 서버를 시작해야 합니다. 예: (http.ListenAndServe(\"localhost:8080\", nil).\n- Go 프로그램을 실행해야 합니다. 예: go run .. 명령으로 실행합니다.\n- 웹 브라우저가 페이지에 접속하거나 새로고침해야 합니다. 예: http://localhost:8080.\n\n만약 *.templ 파일이 변경되면, #1과 #2를 실행해야 합니다.\n\n만약 *.go 파일이 변경되면, #3과 #4를 실행해야 합니다.\n\nTempl은 이러한 작업을 자동으로 수행하는 내장 툴을 제공합니다. Air와 같은 도구들도 사용할 수 있지만, 내장된 툴처럼 페이지를 자동으로 새로고침하지는 않습니다.\n\n\n\n아래 명령어를 실행하여 설정을 합니다\n\n```js\ntempl generate --watch --proxy=\"http://localhost:8080\" --cmd=\"go run .\"\n```\n\n# 내 이북을 확인해보세요: Go로 풀스택 애플리케이션 작성하기\n\nhttps://harryhtml.gumroad.com/l/tdbxl","ogImage":{"url":"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png"},"coverImage":"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png\">\n<p>React의 강력한 기능 중 하나는 JSX입니다. React는 렌더링 로직이 다른 UI 로직과 본질적으로 결합되어 있다는 사실을 받아들입니다. Jinja와 같은 템플릿 엔진을 사용하는 것은 데이터를 컴포넌트로 전달하는 대신 엔진에 문맥을 '전달'해야 한다는 사실로 인해 같은 경험을 제공해주지 않습니다.</p>\n<h1>Templ은 HTML과 Go 사이의 간격을 좁히려고 합니다</h1>\n<pre><code class=\"hljs language-js\">package main\n\n<span class=\"hljs-comment\">// 우리 Component에서 사용할 수 있는 일반 Go 코드</span>\n<span class=\"hljs-keyword\">var</span> greeting = <span class=\"hljs-string\">\"환영합니다!\"</span>\n\n<span class=\"hljs-comment\">// templ Component</span>\ntempl <span class=\"hljs-title function_\">headerTemplate</span>(<span class=\"hljs-params\">name string</span>) {\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">header</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{ name }<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h2</span>></span>\"{ greeting }\"은 일반 Go 코드에서 옵니다<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h2</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">header</span>></span></span>\n}\n</code></pre>\n<p>다음과 같이 templ은 Go에 자체 구문을 추가하지만 기본적으로 함수처럼 작동합니다.</p>\n<h1>구성</h1>\n<h2>Templ</h2>\n<pre><code class=\"hljs language-js\">package components\n\ntempl <span class=\"hljs-title class_\">Link</span>(name string, path string) {\n    - <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span>></span>\n    -     <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">{templ.URL(path)}</span>></span>{name}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n    - <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span></span>\n}\n\ntempl <span class=\"hljs-title class_\">NavBar</span>() {\n    - @<span class=\"hljs-title class_\">Link</span>(<span class=\"hljs-string\">\"Home\"</span>, <span class=\"hljs-string\">\"home\"</span>)\n    - @<span class=\"hljs-title class_\">Link</span>(<span class=\"hljs-string\">\"News\"</span>, <span class=\"hljs-string\">\"news\"</span>)\n    - @<span class=\"hljs-title class_\">Link</span>(<span class=\"hljs-string\">\"Contact Us\"</span>, <span class=\"hljs-string\">\"contact-us\"</span>)\n}\n</code></pre>\n<h2>리엑트</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Welcome</span>(<span class=\"hljs-params\">props</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>안녕, {props.name}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Welcome</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"사라\"</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Welcome</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"카할\"</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Welcome</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"에디트\"</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n</code></pre>\n<p>보시다시피 구문은 매우 유사합니다. 리엑트 컴포넌트는 HTML 스타일 요소로 변합니다.</p>\n<h1>For 루프</h1>\n<pre><code class=\"hljs language-js\">package main\n\ntempl <span class=\"hljs-title function_\">nameList</span>(<span class=\"hljs-params\">items []Item</span>) {\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ul</span>></span>\n  for _, item := range items {\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span>></span>{ item.Name }<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span>\n  }\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ul</span>></span></span>\n}\n</code></pre>\n<p>여기서 Javascript가 약간 뛰어나다고 할 수 있습니다. Javascript에는 배열을 쉽게 반복할 수 있는 Map 함수와 같은 작은 도우미들이 많이 있습니다.</p>\n<h1>Javascript</h1>\n<p>문법이 React와 비슷해 보이지만, 완전히 다릅니다. Templ은 Javascript와 상호 작용할 수 없도록 제한됩니다.</p>\n<pre><code class=\"hljs language-js\">templ <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\"></span>) {\n <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">const</span> chart = <span class=\"hljs-title class_\">LightweightCharts</span>.<span class=\"hljs-title function_\">createChart</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>, { <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">400</span>, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">300</span> });\n  <span class=\"hljs-keyword\">const</span> lineSeries = chart.<span class=\"hljs-title function_\">addLineSeries</span>();\n  lineSeries.<span class=\"hljs-title function_\">setData</span>([\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-11'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">80.01</span> },\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-12'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">96.63</span> },\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-13'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">76.64</span> },\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-14'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">81.89</span> },\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-15'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">74.43</span> },\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-16'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">80.01</span> },\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-17'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">96.63</span> },\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-18'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">76.64</span> },\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-19'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">81.89</span> },\n    { <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2019-04-20'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">74.43</span> },\n  ]);\n </span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></span>\n}\n</code></pre>\n<p>템플은 그냥 템플릿 엔진일 뿐이에요. 텍스트를 합쳐주는 거죠.</p>\n<h1>템플 설치하기</h1>\n<pre><code class=\"hljs language-js\">go install github.<span class=\"hljs-property\">com</span>/a-h/templ/cmd/templ@latest\n</code></pre>\n<h1>Templ은 어떻게 작동하나요?</h1>\n<p>Templ 문서에서는 모든 .templ 파일을 components 폴더/패키지에 저장하는 것을 권장합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//navbar.templ</span>\npackage components\n\ntempl <span class=\"hljs-title class_\">Link</span>(name string, path string) {\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">{templ.URL(path)}</span>></span>{name}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span></span>\n}\n\ntempl <span class=\"hljs-title class_\">NavBar</span>() {\n    @<span class=\"hljs-title class_\">Link</span>(<span class=\"hljs-string\">\"Home\"</span>, <span class=\"hljs-string\">\"home\"</span>)\n    @<span class=\"hljs-title class_\">Link</span>(<span class=\"hljs-string\">\"News\"</span>, <span class=\"hljs-string\">\"news\"</span>)\n    @<span class=\"hljs-title class_\">Link</span>(<span class=\"hljs-string\">\"Contact Us\"</span>, <span class=\"hljs-string\">\"contact-us\"</span>)\n}\n</code></pre>\n<p>그런 다음 .templ 파일을 만든 후 다음 명령을 실행하면 됩니다:</p>\n<pre><code class=\"hljs language-js\">templ generate\n</code></pre>\n<p>그런 다음, 코드 생성을 사용하여 별도의 ‘navbar_templ.go’ 파일을 생성합니다.</p>\n<img src=\"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_1.png\">\n<p>그런 다음 핸들러에서는 간단히 Render 함수를 호출할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">package main\n\n<span class=\"hljs-keyword\">import</span> (\n<span class=\"hljs-string\">\"context\"</span>\n<span class=\"hljs-string\">\"templ-echo-test/components\"</span>\n\n<span class=\"hljs-string\">\"github.com/labstack/echo/v4\"</span>\n)\n\nfunc <span class=\"hljs-title class_\">Page</span>(c echo.<span class=\"hljs-property\">Context</span>) error {\n<span class=\"hljs-keyword\">return</span> components.<span class=\"hljs-title class_\">NavBar</span>().<span class=\"hljs-title class_\">Render</span>(context.<span class=\"hljs-title class_\">Background</span>(), c.<span class=\"hljs-title class_\">Response</span>())\n}\n</code></pre>\n<p>코드 생성 패스 없이는 Go가 .templ 파일을 읽을 수 없습니다.</p>\n<h1>핫 리로드</h1>\n<p>templ을 사용하는 Go 웹 애플리케이션에 웹 브라우저에서 액세스하려면 몇 가지 일이 발생해야 합니다:</p>\n<ul>\n<li>templ generate 명령을 실행하여 <em>.templ 파일에서 Go 코드 (</em>_templ.go 파일)를 생성해야 합니다.</li>\n<li>Go 코드는 포트에서 웹 서버를 시작해야 합니다. 예: (http.ListenAndServe(\"localhost:8080\", nil).</li>\n<li>Go 프로그램을 실행해야 합니다. 예: go run .. 명령으로 실행합니다.</li>\n<li>웹 브라우저가 페이지에 접속하거나 새로고침해야 합니다. 예: <a href=\"http://localhost:8080\" rel=\"nofollow\" target=\"_blank\">http://localhost:8080</a>.</li>\n</ul>\n<p>만약 *.templ 파일이 변경되면, #1과 #2를 실행해야 합니다.</p>\n<p>만약 *.go 파일이 변경되면, #3과 #4를 실행해야 합니다.</p>\n<p>Templ은 이러한 작업을 자동으로 수행하는 내장 툴을 제공합니다. Air와 같은 도구들도 사용할 수 있지만, 내장된 툴처럼 페이지를 자동으로 새로고침하지는 않습니다.</p>\n<p>아래 명령어를 실행하여 설정을 합니다</p>\n<pre><code class=\"hljs language-js\">templ generate --watch --proxy=<span class=\"hljs-string\">\"http://localhost:8080\"</span> --cmd=<span class=\"hljs-string\">\"go run .\"</span>\n</code></pre>\n<h1>내 이북을 확인해보세요: Go로 풀스택 애플리케이션 작성하기</h1>\n<p><a href=\"https://harryhtml.gumroad.com/l/tdbxl\" rel=\"nofollow\" target=\"_blank\">https://harryhtml.gumroad.com/l/tdbxl</a></p>\n</body>\n</html>\n"},"__N_SSG":true}