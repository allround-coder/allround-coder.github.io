{"pageProps":{"post":{"title":"대기업 프론트엔드 단골 useState 질문","description":"","date":"2024-05-12 20:51","slug":"2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong","content":"\n<img src=\"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_0.png\" />\n\n리액트에서 `useState`는 함수 컴포넌트에서 상태를 관리하는 데 필수적인 도구입니다. 그 사용법은 직관적이고 유연합니다. 하지만 초보자들과 어떤 경험이 있는 개발자들도 `useState`가 어떻게 작동하는지와 관련된 세부 내용을 완전히 이해하지 못할 수 있습니다.\n\n다음 코드를 분석해보겠습니다. 버튼 A, B, C, D를 클릭한 후에 각 버튼에 표시된 숫자를 고려하고 이러한 결과가 발생하는 이유를 생각해봅시다.\n\n```js\nimport { useState } from \"react\";\n\nexport default function UseStateDemo() {\n  const [numberA, setNumberA] = useState(0);\n  const [numberB, setNumberB] = useState(0);\n  const [numberC, setNumberC] = useState(0);\n  const [numberD, setNumberD] = useState(0);\n\n  const handleButtonA = () => {\n    setNumberA(numberA + 1);\n    setNumberA(numberA + 1);\n  };\n\n  const handleButtonB = () => {\n    setNumberB((n) => n + 1);\n    setNumberB((n) => n + 1);\n  };\n\n  const handleButtonC = () => {\n    setNumberC(numberC + 3);\n    setNumberC((n) => n + 1);\n  };\n\n  const handleButtonD = () => {\n    setNumberD(numberD + 4);\n    setNumberD((n) => n + 1);\n    setNumberD(99);\n  };\n\n  return (\n    <>\n      <button\n        type=\"button\"\n        className=\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"\n        onClick={handleButtonA}\n      >\n        Button A {numberA}\n      </button>\n      <button\n        type=\"button\"\n        className=\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"\n        onClick={handleButtonB}\n      >\n        Button B {numberB}\n      </button>\n      <button\n        type=\"button\"\n        className=\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"\n        onClick={handleButtonC}\n      >\n        Button C {numberC}\n      </button>\n      <button\n        type=\"button\"\n        className=\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"\n        onClick={handleButtonD}\n      >\n        Button D {numberD}\n      </button>\n    </>\n  );\n}\n```\n\n<img src=\"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_1.png\" />\n\n버튼 A를 누른 후 각각 버튼 B, 버튼 C, 버튼 D를 순서대로 클릭하면 버튼에 적힌 숫자가 1, 2, 4, 99인 것을 확인할 수 있어요.\n\n<img src=\"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_2.png\" />\n\n결과가 기대와 일치했나요?\n\n# 결과 분석\n\n## 버튼 A:\n\nsetNumberA(numberA + 1)가 두 번 호출되었습니다. 각 호출은 현재 값에 따라 상태를 업데이트하지만 상태 업데이트는 비동기적입니다. useState의 set 함수는 값이 즉시 업데이트되지 않고 다음 렌더링 중에 적용됩니다. 따라서 두 호출 모두 numberA의 동일한 기본값을 사용하여 0부터 1로만 증가합니다.\n\n## 버튼 B:\n\n표 태그를 Markdown 형식으로 변경해주세요.\n\n| Button | 역할                                                                                                                                                              |\n| ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| A      | setNumberB(n = n + 1)를 두 번 사용합니다. 이 접근 방식은 각 증가가 최신 상태 값에 기반하게 합니다. 결과적으로 카운트가 정확하게 2씩 증가합니다.                   |\n| C      | 초기에 setNumberB(numberC + 3)은 직접 카운트를 3씩 증가시킵니다. 그런 다음 setNumberC(n = n + 1)는 최신 상태 값을 기반으로 추가로 1씩 증가시켜 총 4씩 증가합니다. |\n| D      |                                                                                                                                                                   |\n\n첫 번째 setNumberD(numberD + 4)는 수를 4씩 증가시킵니다. 다음으로 setNumberD(n =` n + 1)은 1씩 추가 증가시킵니다. 마지막으로 numberD를 직접 99로 설정하면 이전 증가가 무시되고 값을 99로 고정시킵니다.\n\n# 이유\n\n콜백 함수가 인수로 사용될 때(예: n =` n + 1), 현재 상태 값을 기준으로 증분을 허용합니다. 이는 상태 업데이트가 서로 의존하거나 업데이트가 가장 최신 값에 기반하는 것을 보장해야 할 때 유용합니다.\n\n변수 값 직접 업데이트하기(예: setNumber(value))는 특정 양을 명시적으로 추가하는 장점이 있습니다. 그러나 여러 직접 업데이트는 이전 상태 값이 사용되어 오래된 상태 값으로 인해 부정확한 업데이트를 초래할 수 있습니다.\n\n따라서, 콜백 함수를 사용하는 것은 정확한 증분 및 순차적 상태 업데이트가 필요한 시나리오에 더 적합합니다. 특히 업데이트가 기존 상태 값에 따라 결정될 때 유용합니다. 직접적인 업데이트는 간단한 증분이 필요하거나 현재 상태를 고려할 필요가 없는 상황에 더 적합합니다.\n\n# 결론\n\nuseState 훅을 사용하면 함수 컴포넌트에서 상태 변수를 선언하고 상태를 업데이트하는 함수를 제공합니다. 이는 상태를 비동기적으로 업데이트하여 여러 `set` 호출이 즉시 컴포넌트의 현재 렌더링 주기에 반영되지 않도록합니다.\n\nuseState의 설계는 함수 컴포넌트에서 상태 관리를 더 유연하게 만들어줍니다. 비동기 및 콜백 메커니즘을 이해하면 정확한 여러 상태 업데이트에 대해 올바르게 사용하는 데 도움이 됩니다.\n\n일반적으로 콜백 함수를 사용하여 정확한 업데이트를 보장하는 것이 좋습니다. 특히 여러 개의 업데이트가 비동기 환경에서 발생하는 경우에는 더욱 중요합니다.\n\n# 쉽게 설명한 것 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수치고 팔로우해 주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인해 보세요\n","ogImage":{"url":"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_0.png"},"coverImage":"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_0.png\">\n<p>리액트에서 <code>useState</code>는 함수 컴포넌트에서 상태를 관리하는 데 필수적인 도구입니다. 그 사용법은 직관적이고 유연합니다. 하지만 초보자들과 어떤 경험이 있는 개발자들도 <code>useState</code>가 어떻게 작동하는지와 관련된 세부 내용을 완전히 이해하지 못할 수 있습니다.</p>\n<p>다음 코드를 분석해보겠습니다. 버튼 A, B, C, D를 클릭한 후에 각 버튼에 표시된 숫자를 고려하고 이러한 결과가 발생하는 이유를 생각해봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">UseStateDemo</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [numberA, setNumberA] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> [numberB, setNumberB] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> [numberC, setNumberC] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> [numberD, setNumberD] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleButtonA</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setNumberA</span>(numberA + <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-title function_\">setNumberA</span>(numberA + <span class=\"hljs-number\">1</span>);\n  };\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleButtonB</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setNumberB</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =></span> n + <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-title function_\">setNumberB</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =></span> n + <span class=\"hljs-number\">1</span>);\n  };\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleButtonC</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setNumberC</span>(numberC + <span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-title function_\">setNumberC</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =></span> n + <span class=\"hljs-number\">1</span>);\n  };\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleButtonD</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setNumberD</span>(numberD + <span class=\"hljs-number\">4</span>);\n    <span class=\"hljs-title function_\">setNumberD</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =></span> n + <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-title function_\">setNumberD</span>(<span class=\"hljs-number\">99</span>);\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n        <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span>\n        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"</span>\n        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleButtonA}</span>\n      ></span>\n        Button A {numberA}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n        <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span>\n        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"</span>\n        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleButtonB}</span>\n      ></span>\n        Button B {numberB}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n        <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span>\n        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"</span>\n        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleButtonC}</span>\n      ></span>\n        Button C {numberC}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n        <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span>\n        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"</span>\n        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleButtonD}</span>\n      ></span>\n        Button D {numberD}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n}\n</code></pre>\n<img src=\"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_1.png\">\n<p>버튼 A를 누른 후 각각 버튼 B, 버튼 C, 버튼 D를 순서대로 클릭하면 버튼에 적힌 숫자가 1, 2, 4, 99인 것을 확인할 수 있어요.</p>\n<img src=\"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_2.png\">\n<p>결과가 기대와 일치했나요?</p>\n<h1>결과 분석</h1>\n<h2>버튼 A:</h2>\n<p>setNumberA(numberA + 1)가 두 번 호출되었습니다. 각 호출은 현재 값에 따라 상태를 업데이트하지만 상태 업데이트는 비동기적입니다. useState의 set 함수는 값이 즉시 업데이트되지 않고 다음 렌더링 중에 적용됩니다. 따라서 두 호출 모두 numberA의 동일한 기본값을 사용하여 0부터 1로만 증가합니다.</p>\n<h2>버튼 B:</h2>\n<p>표 태그를 Markdown 형식으로 변경해주세요.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Button</th><th>역할</th></tr></thead><tbody><tr><td>A</td><td>setNumberB(n = n + 1)를 두 번 사용합니다. 이 접근 방식은 각 증가가 최신 상태 값에 기반하게 합니다. 결과적으로 카운트가 정확하게 2씩 증가합니다.</td></tr><tr><td>C</td><td>초기에 setNumberB(numberC + 3)은 직접 카운트를 3씩 증가시킵니다. 그런 다음 setNumberC(n = n + 1)는 최신 상태 값을 기반으로 추가로 1씩 증가시켜 총 4씩 증가합니다.</td></tr><tr><td>D</td><td></td></tr></tbody></table>\n<p>첫 번째 setNumberD(numberD + 4)는 수를 4씩 증가시킵니다. 다음으로 setNumberD(n =` n + 1)은 1씩 추가 증가시킵니다. 마지막으로 numberD를 직접 99로 설정하면 이전 증가가 무시되고 값을 99로 고정시킵니다.</p>\n<h1>이유</h1>\n<p>콜백 함수가 인수로 사용될 때(예: n =` n + 1), 현재 상태 값을 기준으로 증분을 허용합니다. 이는 상태 업데이트가 서로 의존하거나 업데이트가 가장 최신 값에 기반하는 것을 보장해야 할 때 유용합니다.</p>\n<p>변수 값 직접 업데이트하기(예: setNumber(value))는 특정 양을 명시적으로 추가하는 장점이 있습니다. 그러나 여러 직접 업데이트는 이전 상태 값이 사용되어 오래된 상태 값으로 인해 부정확한 업데이트를 초래할 수 있습니다.</p>\n<p>따라서, 콜백 함수를 사용하는 것은 정확한 증분 및 순차적 상태 업데이트가 필요한 시나리오에 더 적합합니다. 특히 업데이트가 기존 상태 값에 따라 결정될 때 유용합니다. 직접적인 업데이트는 간단한 증분이 필요하거나 현재 상태를 고려할 필요가 없는 상황에 더 적합합니다.</p>\n<h1>결론</h1>\n<p>useState 훅을 사용하면 함수 컴포넌트에서 상태 변수를 선언하고 상태를 업데이트하는 함수를 제공합니다. 이는 상태를 비동기적으로 업데이트하여 여러 <code>set</code> 호출이 즉시 컴포넌트의 현재 렌더링 주기에 반영되지 않도록합니다.</p>\n<p>useState의 설계는 함수 컴포넌트에서 상태 관리를 더 유연하게 만들어줍니다. 비동기 및 콜백 메커니즘을 이해하면 정확한 여러 상태 업데이트에 대해 올바르게 사용하는 데 도움이 됩니다.</p>\n<p>일반적으로 콜백 함수를 사용하여 정확한 업데이트를 보장하는 것이 좋습니다. 특히 여러 개의 업데이트가 비동기 환경에서 발생하는 경우에는 더욱 중요합니다.</p>\n<h1>쉽게 설명한 것 🚀</h1>\n<p>In Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:</p>\n<ul>\n<li>작가를 박수치고 팔로우해 주세요 👏</li>\n<li>팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter</li>\n<li>다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed</li>\n<li>PlainEnglish.io에서 더 많은 콘텐츠를 확인해 보세요</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}