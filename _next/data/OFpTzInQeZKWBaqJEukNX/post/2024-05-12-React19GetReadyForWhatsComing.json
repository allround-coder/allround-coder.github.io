{"pageProps":{"post":{"title":"React 19 다가오는 변화에 대비하세요","description":"","date":"2024-05-12 21:09","slug":"2024-05-12-React19GetReadyForWhatsComing","content":"\n\n![React 19](/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png)\n\n리액트 19, 어떤 경우에도 공개될 수 있고, 모든 리액트 개발자들이 사용하고 싶어할 것입니다. 왜냐하면 최신 버전이 훨씬 더 나아졌기 때문이죠. 다가올 변화 중 일부를 살펴보겠습니다.\n\n## 리액트 컴파일러: 리액트 핵심 최적화\n\n오랫동안, 리액트 개발자들은 useMemo, useCallback, memo 훅을 활용하여 애플리케이션을 최적화하고 불필요한 다시 렌더링을 방지했습니다. 이로 인해 종종 어색한 코드가 만들어지곤 했는데, 이를 더 우아한 해결책을 찾게끔 할 것이라는 리액트 개발팀이 약속했습니다.\n\n\n\n그래서 정확히 그것이 React 19에서 제공되는 것입니다: 새로운 React 컴파일러. 이 컴파일러는 코드를 분석하여 상태 변경이 발생할 때 UI의 어떤 부분을 다시 렌더링해야 하는지 결정함으로써 React의 렌더링 프로세스를 자동으로 최적화하는 데 설계되었습니다.\n\nReact 컴파일러가 간단한 컴포넌트를 어떻게 최적화하는지 예시를 살펴봅시다:\n\n```js\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment</button>\n    </div>\n  );\n}\n```\n\nReact 컴파일러 없이 count 상태를 업데이트하면 `button` 요소를 포함한 전체 컴포넌트가 다시 렌더링됩니다. 그러나 해당 내용과 동작이 변경되지 않는 한 개선 없이 렌더링됩니다. 반면에 React 컴파일러를 사용하면 count를 보여주는 `p` 요소만 다시 렌더링되어 성능이 향상되고 오버헤드가 감소합니다.\n\n\n\n## 작업: 데이터 처리 간소화\n\n리액트 컴파일러에 추가로, 리액트 19에서는 Actions라는 강력한 새로운 기능이 소개되었습니다.\n\nActions를 사용하면 `form`과 같은 DOM 요소에 함수를 전달하여 폼 제출, 데이터 변이 및 기타 데이터 관련 작업을 손쉽게 처리할 수 있습니다. 아래는 예시입니다:\n\n```js\nimport React from 'react';\n\nfunction SearchForm({ action }) {\n  return (\n    <form action={action}>\n      <input name=\"query\" />\n      <button type=\"submit\">검색</button>\n    </form>\n  );\n}\n\nfunction App() {\n  const search = async (data) => {\n    const response = await fetch(`/api/search?q=${data.query}`);\n    const results = await response.json();\n    // 검색 결과로 UI 업데이트\n  };\n\n  return <SearchForm action={search} />;\n}\n```\n\n\n\n이 예시에서 SearchForm 컴포넌트는 액션 prop을 받습니다. 이 prop은 폼이 제출될 때 실행될 함수입니다. App 컴포넌트는 검색 함수를 정의합니다. 이 함수는 서버로 fetch 요청을 보내고 응답을 처리합니다.\n\n액션은 클라이언트 측에서 표준 JavaScript를 사용하여 또는 `use server` 지시문을 사용하여 서버에서 정의할 수 있습니다. React는 데이터 제출의 라이프사이클을 관리하며, useFormStatus 및 useActionState와 같은 훅을 제공하여 폼 액션의 현재 상태와 응답에 액세스할 수 있습니다.\n\n기본적으로, 액션은 전환 내에서 제출되어 현재 페이지를 상호작용적으로 유지합니다. React 19에서는 전환 내에서 async/await를 사용하여 비동기 요청이 진행 중일 때 대기 중 UI를 보여줄 수 있는 기능도 소개되었습니다.\n\n액션을 보완하는 것은 useOptimistic 훅입니다. 이 훅을 사용하면 개발자가 낙관적인 상태 업데이트를 관리할 수 있습니다. 이 훅을 사용하면 임시 업데이트가 적용되고 최종 상태가 확정되면 자동으로 되돌립니다. 이 기능을 사용하면 낙관적 UI 업데이트를 할 수 있으며, 제출이 성공하면 서버에서 제공된 데이터로 자연스럽게 되돌아갈 수 있습니다.\n\n\n\n## React 서버 구성 요소: 서버 측 렌더링을 더욱 진보시키다.\n\nReact 19에서 가장 기대되는 기능 중 하나는 React Server Components (RSC)의 도입입니다.\n\nRSC를 사용하면 개발자는 `use server` 지시어를 사용하여 특정 구성 요소를 \"서버\" 구성 요소로 표시할 수 있습니다. 이러한 구성 요소는 서버에서 렌더링되어 정적 HTML로 클라이언트로 스트리밍되어 초기 JavaScript 페이로드를 줄이고 성능을 향상시킵니다.\n\n다음은 RSC를 사용하는 예시입니다:\n\n\n\n```jsx\n// PostContent.server.jsx\nimport React, { useState, useEffect } from 'react';\nimport fetchPost from './fetchPost';\n\nexport default async function PostContent({ id }) {\n  const [post, setPost] = useState(null);\n\n  useEffect(() => {\n    const fetchPostData = async () => {\n      const postData = await fetchPost(id);\n      setPost(postData);\n    };\n    fetchPostData();\n  }, [id]);\n\n  if (!post) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  );\n}\n```\n\n이 예제에서 PostContent 컴포넌트는 .server.jsx 파일 확장자를 사용하여 서버 컴포넌트로 표시됩니다. 서버에서 렌더링될 때 fetchPost 함수가 실행되고 결과로 나온 게시물 데이터가 정적 HTML로 렌더링되어 클라이언트로 스트리밍됩니다.\n\nRSC와 액션을 결합하면 클라이언트 및 서버 환경에서 일관된 프로그래밍 모델로 풀 스택 앱을 만들 수 있습니다.\n\n## 리액트 개발의 미래를 받아들이기\n\n\n\nReact 19 컴파일러는 렌더링 프로세스를 대폭 가속화하고 불필요한 다시 렌더링을 줄일 것입니다. Meta Devs가 릴리스하는 내용을 항상 주시하시고 큰 날을 위해 준비하세요.\n\n출처: React Labs: 우리가 작업 중인 내용 — 2024년 2월 — React\n\n# 평문으로 간단히 🚀\n\nIn Plain English 커뮤니티의 일부로 함께해 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 작가에게 박수를 보내고 팔로우를 눌러주세요! 👏\r\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\r\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\r\n- 알고리즘 컨텐츠를 다루도록 강요하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!\r\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요.","ogImage":{"url":"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png"},"coverImage":"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png\" alt=\"React 19\"></p>\n<p>리액트 19, 어떤 경우에도 공개될 수 있고, 모든 리액트 개발자들이 사용하고 싶어할 것입니다. 왜냐하면 최신 버전이 훨씬 더 나아졌기 때문이죠. 다가올 변화 중 일부를 살펴보겠습니다.</p>\n<h2>리액트 컴파일러: 리액트 핵심 최적화</h2>\n<p>오랫동안, 리액트 개발자들은 useMemo, useCallback, memo 훅을 활용하여 애플리케이션을 최적화하고 불필요한 다시 렌더링을 방지했습니다. 이로 인해 종종 어색한 코드가 만들어지곤 했는데, 이를 더 우아한 해결책을 찾게끔 할 것이라는 리액트 개발팀이 약속했습니다.</p>\n<p>그래서 정확히 그것이 React 19에서 제공되는 것입니다: 새로운 React 컴파일러. 이 컴파일러는 코드를 분석하여 상태 변경이 발생할 때 UI의 어떤 부분을 다시 렌더링해야 하는지 결정함으로써 React의 렌더링 프로세스를 자동으로 최적화하는 데 설계되었습니다.</p>\n<p>React 컴파일러가 간단한 컴포넌트를 어떻게 최적화하는지 예시를 살펴봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleClick</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setCount</span>(count + <span class=\"hljs-number\">1</span>);\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>Count: {count}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{handleClick}</span>></span>Increment<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n</code></pre>\n<p>React 컴파일러 없이 count 상태를 업데이트하면 <code>button</code> 요소를 포함한 전체 컴포넌트가 다시 렌더링됩니다. 그러나 해당 내용과 동작이 변경되지 않는 한 개선 없이 렌더링됩니다. 반면에 React 컴파일러를 사용하면 count를 보여주는 <code>p</code> 요소만 다시 렌더링되어 성능이 향상되고 오버헤드가 감소합니다.</p>\n<h2>작업: 데이터 처리 간소화</h2>\n<p>리액트 컴파일러에 추가로, 리액트 19에서는 Actions라는 강력한 새로운 기능이 소개되었습니다.</p>\n<p>Actions를 사용하면 <code>form</code>과 같은 DOM 요소에 함수를 전달하여 폼 제출, 데이터 변이 및 기타 데이터 관련 작업을 손쉽게 처리할 수 있습니다. 아래는 예시입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SearchForm</span>(<span class=\"hljs-params\">{ action }</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">{action}</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"query\"</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>></span>검색<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">form</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">search</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">data</span>) => {\n    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/search?q=<span class=\"hljs-subst\">${data.query}</span>`</span>);\n    <span class=\"hljs-keyword\">const</span> results = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n    <span class=\"hljs-comment\">// 검색 결과로 UI 업데이트</span>\n  };\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">SearchForm</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">{search}</span> /></span></span>;\n}\n</code></pre>\n<p>이 예시에서 SearchForm 컴포넌트는 액션 prop을 받습니다. 이 prop은 폼이 제출될 때 실행될 함수입니다. App 컴포넌트는 검색 함수를 정의합니다. 이 함수는 서버로 fetch 요청을 보내고 응답을 처리합니다.</p>\n<p>액션은 클라이언트 측에서 표준 JavaScript를 사용하여 또는 <code>use server</code> 지시문을 사용하여 서버에서 정의할 수 있습니다. React는 데이터 제출의 라이프사이클을 관리하며, useFormStatus 및 useActionState와 같은 훅을 제공하여 폼 액션의 현재 상태와 응답에 액세스할 수 있습니다.</p>\n<p>기본적으로, 액션은 전환 내에서 제출되어 현재 페이지를 상호작용적으로 유지합니다. React 19에서는 전환 내에서 async/await를 사용하여 비동기 요청이 진행 중일 때 대기 중 UI를 보여줄 수 있는 기능도 소개되었습니다.</p>\n<p>액션을 보완하는 것은 useOptimistic 훅입니다. 이 훅을 사용하면 개발자가 낙관적인 상태 업데이트를 관리할 수 있습니다. 이 훅을 사용하면 임시 업데이트가 적용되고 최종 상태가 확정되면 자동으로 되돌립니다. 이 기능을 사용하면 낙관적 UI 업데이트를 할 수 있으며, 제출이 성공하면 서버에서 제공된 데이터로 자연스럽게 되돌아갈 수 있습니다.</p>\n<h2>React 서버 구성 요소: 서버 측 렌더링을 더욱 진보시키다.</h2>\n<p>React 19에서 가장 기대되는 기능 중 하나는 React Server Components (RSC)의 도입입니다.</p>\n<p>RSC를 사용하면 개발자는 <code>use server</code> 지시어를 사용하여 특정 구성 요소를 \"서버\" 구성 요소로 표시할 수 있습니다. 이러한 구성 요소는 서버에서 렌더링되어 정적 HTML로 클라이언트로 스트리밍되어 초기 JavaScript 페이로드를 줄이고 성능을 향상시킵니다.</p>\n<p>다음은 RSC를 사용하는 예시입니다:</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-comment\">// PostContent.server.jsx</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useState, useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">import</span> fetchPost <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./fetchPost'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">PostContent</span>(<span class=\"hljs-params\">{ id }</span>) {\n  <span class=\"hljs-keyword\">const</span> [post, setPost] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">null</span>);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchPostData</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n      <span class=\"hljs-keyword\">const</span> postData = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetchPost</span>(id);\n      <span class=\"hljs-title function_\">setPost</span>(postData);\n    };\n    <span class=\"hljs-title function_\">fetchPostData</span>();\n  }, [id]);\n\n  <span class=\"hljs-keyword\">if</span> (!post) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>;\n  }\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{post.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{post.content}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n</code></pre>\n<p>이 예제에서 PostContent 컴포넌트는 .server.jsx 파일 확장자를 사용하여 서버 컴포넌트로 표시됩니다. 서버에서 렌더링될 때 fetchPost 함수가 실행되고 결과로 나온 게시물 데이터가 정적 HTML로 렌더링되어 클라이언트로 스트리밍됩니다.</p>\n<p>RSC와 액션을 결합하면 클라이언트 및 서버 환경에서 일관된 프로그래밍 모델로 풀 스택 앱을 만들 수 있습니다.</p>\n<h2>리액트 개발의 미래를 받아들이기</h2>\n<p>React 19 컴파일러는 렌더링 프로세스를 대폭 가속화하고 불필요한 다시 렌더링을 줄일 것입니다. Meta Devs가 릴리스하는 내용을 항상 주시하시고 큰 날을 위해 준비하세요.</p>\n<p>출처: React Labs: 우리가 작업 중인 내용 — 2024년 2월 — React</p>\n<h1>평문으로 간단히 🚀</h1>\n<p>In Plain English 커뮤니티의 일부로 함께해 주셔서 감사합니다! 떠나시기 전에:</p>\n<ul>\n<li>작가에게 박수를 보내고 팔로우를 눌러주세요! 👏</li>\n<li>팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터</li>\n<li>다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed</li>\n<li>알고리즘 컨텐츠를 다루도록 강요하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!</li>\n<li>더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요.</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}