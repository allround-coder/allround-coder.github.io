{"pageProps":{"post":{"title":"앵귤러에서의 HTTP Interceptors","description":"","date":"2024-05-12 23:44","slug":"2024-05-12-HTTPInterceptorsinAngular","content":"\n\n<img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png\" />\n\n안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.\n\n# 안내\n\n- Angular란 무엇인가요?\n\n\n\n**HTTP Interceptor란 무엇인가요?**\n\n**Angular에서의 HTTP Interceptor**\n\n**HTTP Interceptor의 장점**\n\n**실용적인 구현**\n\n\n\n# 선행 요건\n\n- TypeScript와 Angular에 대한 기본적인 이해\n- Angular CLI\n- NodeJS\n\n\n\n- VS Code\n\n## Angular이란 무엇인가요?\n\nAngular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.\n\n## HTTP Interceptor란 무엇인가요?\n\n\n\n- HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.\n\n- 이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.\n\n## Angular의 HTTP 인터셉터\n\n- Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png\" />\n\n- HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.\n\n- HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.\n\n# HTTP 인터셉터의 장점\n\n\n\n아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:\n\n테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.\n\n크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.\n\n전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.\n\n\n\n오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.\n\n캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.\n\n역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.\n\n보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.\n\n\n\n세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:\n\n| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool. \n\n## 실용적인 구현\n\n실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.\n\n이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.\n\n\n\n1. 로깅 인터셉터\n\nAngular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.\n\n단계 1\n\n다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.\n\n\n\n이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpResponse,\n} from '@angular/common/http';\nimport { Observable, tap } from 'rxjs';\n\n@Injectable()\nexport class LoggingInterceptor implements HttpInterceptor {\n  constructor() {}\n\n  intercept(\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    console.log('Outgoing HTTP request', request);\n    return next.handle(request).pipe(\n      tap((event: HttpEvent<any>) => {\n        console.log('Incoming HTTP response', event);\n      })\n    );\n  }\n}\n```\n\n- 여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.\n\n- HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.\n\n\n\n- 우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.\n\n- next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.\n\n- 그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.\n\n- tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.\n\n\n\n단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { LoggingInterceptor } from './interceptors/logging.interceptor';\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true\n    }\n]\n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.\n\n\n\nHTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:\n\n![HTTPInterceptorsinAngular_2](/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png)\n\n실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.\n\n2. 요청에 헤더 추가\n\n\n\n앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.\n\n단계 1\n\n다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeadersInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n    console.log(request)\n    const GUID = 'f4179b26-21ac-432c-bcd8-cb4bc6e50981'\n    const modifiedRequest = request.clone({\n      setHeaders:{\n        GUID\n      }\n    })\n    return next.handle(modifiedRequest);\n  }\n}\n```\n\n\n\n먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\n\n### 단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { HeadersInterceptor } from './interceptors/headers.interceptor'\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: HeadersInterceptor, multi: true\n    }\n  ]\n```\n\n\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.\n\n![HTTP Interceptors in Angular](/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png)\n\n실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.\n\n3. 에러 처리 Interceptor\n\n\n\n앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.\n\n서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.\n\n각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.\n\n에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.\n\n\n\n**단계 1**\n\n다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { Observable, catchError, throwError } from 'rxjs';\n\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return next.handle(request).pipe(\n      catchError((error: HttpErrorResponse) => {\n        // 여기서 오류를 처리합니다\n        console.error('오류 발생:', error);\n        // 요구에 따라 오류 throw\n        return throwError(error);\n      })\n    );\n  }\n}\n```\n\n- `intercept()` 메서드 내에서 RxJS의 `catchError` 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.\n\n\n\n**단계 1**\n\n· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.\n\n**단계 2**\n\n· 앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { ErrorInterceptor } from './interceptors/error.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true\n  }\n]\n```\n\n\n\n· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.\n\n4. Authentication Interceptor\n\nAngular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.\n\n단계 1\n\n\n\n다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n//import { AuthService } from './auth.service';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(/*private authService: AuthService*/) {}\n\n  intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA\";//his.authService.getToken();\n\n    if (authToken) {\n      // 요청을 복제하고 토큰을 첨부합니다\n      const authReq = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${authToken}`\n        }\n      });\n\n      return next.handle(authReq);\n    }\n\n    // 토큰이 없는 경우 원본 요청을 전달합니다\n    return next.handle(req);\n  }\n}\n```\n\n여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다. \n\nStep 2\n\n\n\n앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { AuthInterceptor } from './interceptors/auth.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true\n  }\n]  \n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.\n\nHTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png\" />\n\n여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.\n\n# GitHub URL\n\nhttps://github.com/Jaydeep-007/angular-http-interceptor-demo\n\n\n\n# 결론\n\n이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.\n\n코딩하세요!\n\n# 간단히 말해서\n\n\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 칭찬하고 팔로우해 주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입해주세요. 🗞️\n- 트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png"},"coverImage":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png\">\n<p>안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.</p>\n<h1>안내</h1>\n<ul>\n<li>Angular란 무엇인가요?</li>\n</ul>\n<p><strong>HTTP Interceptor란 무엇인가요?</strong></p>\n<p><strong>Angular에서의 HTTP Interceptor</strong></p>\n<p><strong>HTTP Interceptor의 장점</strong></p>\n<p><strong>실용적인 구현</strong></p>\n<h1>선행 요건</h1>\n<ul>\n<li>\n<p>TypeScript와 Angular에 대한 기본적인 이해</p>\n</li>\n<li>\n<p>Angular CLI</p>\n</li>\n<li>\n<p>NodeJS</p>\n</li>\n<li>\n<p>VS Code</p>\n</li>\n</ul>\n<h2>Angular이란 무엇인가요?</h2>\n<p>Angular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.</p>\n<h2>HTTP Interceptor란 무엇인가요?</h2>\n<ul>\n<li>\n<p>HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.</p>\n</li>\n<li>\n<p>이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.</p>\n</li>\n</ul>\n<h2>Angular의 HTTP 인터셉터</h2>\n<ul>\n<li>Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.</li>\n</ul>\n<img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png\">\n<ul>\n<li>\n<p>HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.</p>\n</li>\n<li>\n<p>HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.</p>\n</li>\n</ul>\n<h1>HTTP 인터셉터의 장점</h1>\n<p>아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:</p>\n<p>테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.</p>\n<p>크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.</p>\n<p>전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.</p>\n<p>오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.</p>\n<p>캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.</p>\n<p>역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.</p>\n<p>보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.</p>\n<p>세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:</p>\n<p>| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool.</p>\n<h2>실용적인 구현</h2>\n<p>실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.</p>\n<p>이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.</p>\n<ol>\n<li>로깅 인터셉터</li>\n</ol>\n<p>Angular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.</p>\n<p>단계 1</p>\n<p>다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.</p>\n<p>이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">HttpEvent</span>,\n  <span class=\"hljs-title class_\">HttpInterceptor</span>,\n  <span class=\"hljs-title class_\">HttpHandler</span>,\n  <span class=\"hljs-title class_\">HttpRequest</span>,\n  <span class=\"hljs-title class_\">HttpResponse</span>,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/common/http'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Observable</span>, tap } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoggingInterceptor</span> implements <span class=\"hljs-title class_\">HttpInterceptor</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {}\n\n  <span class=\"hljs-title function_\">intercept</span>(\n    <span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">HttpRequest</span>&#x3C;any>,\n    <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">HttpHandler</span>\n  ): <span class=\"hljs-title class_\">Observable</span>&#x3C;<span class=\"hljs-title class_\">HttpEvent</span>&#x3C;any>> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Outgoing HTTP request'</span>, request);\n    <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">handle</span>(request).<span class=\"hljs-title function_\">pipe</span>(\n      <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">event: HttpEvent&#x3C;any></span>) =></span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Incoming HTTP response'</span>, event);\n      })\n    );\n  }\n}\n</code></pre>\n<ul>\n<li>\n<p>여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.</p>\n</li>\n<li>\n<p>HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.</p>\n</li>\n<li>\n<p>우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.</p>\n</li>\n<li>\n<p>next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.</p>\n</li>\n<li>\n<p>그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.</p>\n</li>\n<li>\n<p>tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.</p>\n</li>\n</ul>\n<p>단계 2</p>\n<p>앱 모듈에 인터셉터를 제공하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">LoggingInterceptor</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./interceptors/logging.interceptor'</span>;\n\n<span class=\"hljs-attr\">providers</span>: [\n    {\n      <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">HTTP_INTERCEPTORS</span>, <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">LoggingInterceptor</span>, <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>\n    }\n]\n</code></pre>\n<p>AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.</p>\n<p>HTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:</p>\n<p><img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png\" alt=\"HTTPInterceptorsinAngular_2\"></p>\n<p>실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.</p>\n<ol start=\"2\">\n<li>요청에 헤더 추가</li>\n</ol>\n<p>앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.</p>\n<p>단계 1</p>\n<p>다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">HttpRequest</span>,\n  <span class=\"hljs-title class_\">HttpHandler</span>,\n  <span class=\"hljs-title class_\">HttpEvent</span>,\n  <span class=\"hljs-title class_\">HttpInterceptor</span>\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/common/http'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Observable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HeadersInterceptor</span> implements <span class=\"hljs-title class_\">HttpInterceptor</span> {\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {}\n\n  <span class=\"hljs-title function_\">intercept</span>(<span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">HttpRequest</span>&#x3C;unknown>, <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">HttpHandler</span>): <span class=\"hljs-title class_\">Observable</span>&#x3C;<span class=\"hljs-title class_\">HttpEvent</span>&#x3C;unknown>> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(request)\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">GUID</span> = <span class=\"hljs-string\">'f4179b26-21ac-432c-bcd8-cb4bc6e50981'</span>\n    <span class=\"hljs-keyword\">const</span> modifiedRequest = request.<span class=\"hljs-title function_\">clone</span>({\n      <span class=\"hljs-attr\">setHeaders</span>:{\n        <span class=\"hljs-variable constant_\">GUID</span>\n      }\n    })\n    <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">handle</span>(modifiedRequest);\n  }\n}\n</code></pre>\n<p>먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.</p>\n<h3>단계 2</h3>\n<p>앱 모듈에 인터셉터를 제공하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HeadersInterceptor</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./interceptors/headers.interceptor'</span>\n\n<span class=\"hljs-attr\">providers</span>: [\n    {\n      <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">HTTP_INTERCEPTORS</span>, <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">HeadersInterceptor</span>, <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>\n    }\n  ]\n</code></pre>\n<p>AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.</p>\n<p><img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png\" alt=\"HTTP Interceptors in Angular\"></p>\n<p>실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.</p>\n<ol start=\"3\">\n<li>에러 처리 Interceptor</li>\n</ol>\n<p>앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.</p>\n<p>서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.</p>\n<p>각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.</p>\n<p>에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.</p>\n<p><strong>단계 1</strong></p>\n<p>다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">HttpRequest</span>,\n  <span class=\"hljs-title class_\">HttpHandler</span>,\n  <span class=\"hljs-title class_\">HttpEvent</span>,\n  <span class=\"hljs-title class_\">HttpInterceptor</span>,\n  <span class=\"hljs-title class_\">HttpErrorResponse</span>\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/common/http'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Observable</span>, catchError, throwError } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ErrorInterceptor</span> implements <span class=\"hljs-title class_\">HttpInterceptor</span> {\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {}\n\n  <span class=\"hljs-title function_\">intercept</span>(<span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">HttpRequest</span>&#x3C;any>, <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">HttpHandler</span>): <span class=\"hljs-title class_\">Observable</span>&#x3C;<span class=\"hljs-title class_\">HttpEvent</span>&#x3C;any>> {\n    <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">handle</span>(request).<span class=\"hljs-title function_\">pipe</span>(\n      <span class=\"hljs-title function_\">catchError</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error: HttpErrorResponse</span>) =></span> {\n        <span class=\"hljs-comment\">// 여기서 오류를 처리합니다</span>\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'오류 발생:'</span>, error);\n        <span class=\"hljs-comment\">// 요구에 따라 오류 throw</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">throwError</span>(error);\n      })\n    );\n  }\n}\n</code></pre>\n<ul>\n<li><code>intercept()</code> 메서드 내에서 RxJS의 <code>catchError</code> 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.</li>\n</ul>\n<p><strong>단계 1</strong></p>\n<p>· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.</p>\n<p><strong>단계 2</strong></p>\n<p>· 앱 모듈에서 인터셉터를 제공하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ErrorInterceptor</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./interceptors/error.interceptor'</span>;\n\n<span class=\"hljs-attr\">providers</span>: [\n  {\n    <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">HTTP_INTERCEPTORS</span>, <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">ErrorInterceptor</span>, <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>\n  }\n]\n</code></pre>\n<p>· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.</p>\n<ol start=\"4\">\n<li>Authentication Interceptor</li>\n</ol>\n<p>Angular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.</p>\n<p>단계 1</p>\n<p>다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">HttpEvent</span>,\n  <span class=\"hljs-title class_\">HttpInterceptor</span>,\n  <span class=\"hljs-title class_\">HttpHandler</span>,\n  <span class=\"hljs-title class_\">HttpRequest</span>,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/common/http'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Observable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-comment\">//import { AuthService } from './auth.service';</span>\n\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AuthInterceptor</span> implements <span class=\"hljs-title class_\">HttpInterceptor</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-comment\">/*private authService: AuthService*/</span></span>) {}\n\n  <span class=\"hljs-title function_\">intercept</span>(\n    <span class=\"hljs-attr\">req</span>: <span class=\"hljs-title class_\">HttpRequest</span>&#x3C;any>,\n    <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">HttpHandler</span>\n  ): <span class=\"hljs-title class_\">Observable</span>&#x3C;<span class=\"hljs-title class_\">HttpEvent</span>&#x3C;any>> {\n    <span class=\"hljs-keyword\">const</span> authToken = <span class=\"hljs-string\">\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA\"</span>;<span class=\"hljs-comment\">//his.authService.getToken();</span>\n\n    <span class=\"hljs-keyword\">if</span> (authToken) {\n      <span class=\"hljs-comment\">// 요청을 복제하고 토큰을 첨부합니다</span>\n      <span class=\"hljs-keyword\">const</span> authReq = req.<span class=\"hljs-title function_\">clone</span>({\n        <span class=\"hljs-attr\">setHeaders</span>: {\n          <span class=\"hljs-title class_\">Authorization</span>: <span class=\"hljs-string\">`Bearer <span class=\"hljs-subst\">${authToken}</span>`</span>\n        }\n      });\n\n      <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">handle</span>(authReq);\n    }\n\n    <span class=\"hljs-comment\">// 토큰이 없는 경우 원본 요청을 전달합니다</span>\n    <span class=\"hljs-keyword\">return</span> next.<span class=\"hljs-title function_\">handle</span>(req);\n  }\n}\n</code></pre>\n<p>여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.</p>\n<p>Step 2</p>\n<p>앱 모듈에서 인터셉터를 제공하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AuthInterceptor</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./interceptors/auth.interceptor'</span>;\n\n<span class=\"hljs-attr\">providers</span>: [\n  {\n    <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">HTTP_INTERCEPTORS</span>, <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">AuthInterceptor</span>, <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>\n  }\n]  \n</code></pre>\n<p>AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.</p>\n<p>HTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.</p>\n<img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png\">\n<p>여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.</p>\n<h1>GitHub URL</h1>\n<p><a href=\"https://github.com/Jaydeep-007/angular-http-interceptor-demo\" rel=\"nofollow\" target=\"_blank\">https://github.com/Jaydeep-007/angular-http-interceptor-demo</a></p>\n<h1>결론</h1>\n<p>이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.</p>\n<p>코딩하세요!</p>\n<h1>간단히 말해서</h1>\n<p>우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:</p>\n<ul>\n<li>작가를 박수로 칭찬하고 팔로우해 주세요! 👏</li>\n<li>PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀</li>\n<li>무료 주간 뉴스레터에 가입해주세요. 🗞️</li>\n<li>트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}