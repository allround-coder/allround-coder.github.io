{"pageProps":{"post":{"title":"JavaScript에서 내장 함수를 사용하지 않고 비동기 작업을 병렬로 실행하기","description":"","date":"2024-05-14 13:59","slug":"2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript","content":"\n\n![Excute Asynchronous Tasks in Parallel without Using Built-in Functions in JavaScript](/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png)\n\n비동기 작업은 데이터베이스에서 데이터를 가져오거나 네트워크 요청을 만들거나 파일에서 읽는 등 외부 이벤트를 기다리는 작업이 포함된 상황에서 특히 흔히 발생합니다.\n\n이러한 작업이 완료될 때까지 전체 프로그램을 멈추지 않고 비동기 작업은 서로 독립적으로 실행되며 서로 다른 시간에 완료될 수 있으므로 효율성과 반응성이 향상됩니다.\n\n비동기 병렬 실행을 통해 작업을 동시에 실행할 수 있으므로 하드웨어의 기능(예: 다중 CPU 코어)을 활용할 수 있습니다. 이는 시스템 자원을 더 효율적으로 사용하고 작업을 빠르게 완료할 수 있게 합니다. 예: 일괄 처리, 웹 서버 요청의 동시 실행.\n\n\n\n자바스크립트는 Promise.all()이나 Promise.race()와 같은 내장 함수를 제공하여 비동기 병렬 실행을 달성할 수 있습니다. 이러한 내장 함수들은 간단한 경우에 편리하지만, 더 복잡한 시나리오를 위해 자체 병렬 비동기 함수를 사용하면 더 많은 제어, 유연성 및 최적화 가능성을 제공할 수 있습니다.\n\n동일한 작업을 Promises를 사용하여 수행하기 위해 사용자 지정 함수를 작성하는 샘플 예제를 찾아보세요.\n\n```js\nconst executeParallel = (tasks) => {\n  return new Promise((resolve, reject) => {\n    const results = []; // 작업의 결과를 저장합니다\n    let completedCount = 0; // 완료된 작업을 추적합니다\n\n    const handleResolve = (result, index) => {\n      results[index] = result;\n      completedCount++;\n      if (completedCount === tasks.length) {\n        resolve(results);\n      }\n    };\n\n    const handleReject = (error) => {\n      reject(error);\n    };\n\n    tasks.forEach((task, index) => {\n      task()\n        .then((result) => {\n          // 모든 작업이 완료되면 주 Promise를 해결합니다\n          handleResolve(result, index);\n        })\n        .catch((error) => {\n          handleReject(error); // 작업 중 하나라도 실패할 경우 Promise를 거부합니다\n        });\n    });\n  });\n};\n\n// 예제 작업\nconst task1 = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('작업 1 완료');\n    }, 200);\n  });\n};\n\nconst task2 = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('작업 2');\n    }, 10);\n  });\n};\n\nconst task3 = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('105');\n    }, 50);\n  });\n};\n\nexecuteParallel([task1, task2, task3])\n  .then((results) => {\n    console.log('모든 작업 완료:', results);\n  })\n  .catch((error) => {\n    console.error('에러:', error);\n  });\n```\n\n위 구현에서:\n\n\n\n- executeParallel() 함수는 각각이 Promise를 반환하는 함수인 작업 배열을 가져옵니다.\n- executeParallel() 내에서 모든 작업의 완료를 추적하는 주요 Promise가 생성됩니다.\n- 각 작업은 Promise.resolve(task())를 사용하여 비동기적으로 실행됩니다.\n- 작업이 완료되면 그 결과가 배열에 저장되고 completedCount가 증가합니다.\n- 작업 중에 오류가 발생하면 주요 Promise는 해당 오류로 거부됩니다.\n- 모든 작업이 완료되면 주요 Promise는 결과 배열로 해결됩니다.\n\n이 블로그가 도움이 되고 통찰력을 줬기를 바랍니다. 읽어주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png","tag":["Tech"],"readingTime":3},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png\" alt=\"Excute Asynchronous Tasks in Parallel without Using Built-in Functions in JavaScript\"></p>\n<p>비동기 작업은 데이터베이스에서 데이터를 가져오거나 네트워크 요청을 만들거나 파일에서 읽는 등 외부 이벤트를 기다리는 작업이 포함된 상황에서 특히 흔히 발생합니다.</p>\n<p>이러한 작업이 완료될 때까지 전체 프로그램을 멈추지 않고 비동기 작업은 서로 독립적으로 실행되며 서로 다른 시간에 완료될 수 있으므로 효율성과 반응성이 향상됩니다.</p>\n<p>비동기 병렬 실행을 통해 작업을 동시에 실행할 수 있으므로 하드웨어의 기능(예: 다중 CPU 코어)을 활용할 수 있습니다. 이는 시스템 자원을 더 효율적으로 사용하고 작업을 빠르게 완료할 수 있게 합니다. 예: 일괄 처리, 웹 서버 요청의 동시 실행.</p>\n<p>자바스크립트는 Promise.all()이나 Promise.race()와 같은 내장 함수를 제공하여 비동기 병렬 실행을 달성할 수 있습니다. 이러한 내장 함수들은 간단한 경우에 편리하지만, 더 복잡한 시나리오를 위해 자체 병렬 비동기 함수를 사용하면 더 많은 제어, 유연성 및 최적화 가능성을 제공할 수 있습니다.</p>\n<p>동일한 작업을 Promises를 사용하여 수행하기 위해 사용자 지정 함수를 작성하는 샘플 예제를 찾아보세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">executeParallel</span> = (<span class=\"hljs-params\">tasks</span>) => {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n    <span class=\"hljs-keyword\">const</span> results = []; <span class=\"hljs-comment\">// 작업의 결과를 저장합니다</span>\n    <span class=\"hljs-keyword\">let</span> completedCount = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 완료된 작업을 추적합니다</span>\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleResolve</span> = (<span class=\"hljs-params\">result, index</span>) => {\n      results[index] = result;\n      completedCount++;\n      <span class=\"hljs-keyword\">if</span> (completedCount === tasks.<span class=\"hljs-property\">length</span>) {\n        <span class=\"hljs-title function_\">resolve</span>(results);\n      }\n    };\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleReject</span> = (<span class=\"hljs-params\">error</span>) => {\n      <span class=\"hljs-title function_\">reject</span>(error);\n    };\n\n    tasks.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">task, index</span>) =></span> {\n      <span class=\"hljs-title function_\">task</span>()\n        .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">result</span>) =></span> {\n          <span class=\"hljs-comment\">// 모든 작업이 완료되면 주 Promise를 해결합니다</span>\n          <span class=\"hljs-title function_\">handleResolve</span>(result, index);\n        })\n        .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =></span> {\n          <span class=\"hljs-title function_\">handleReject</span>(error); <span class=\"hljs-comment\">// 작업 중 하나라도 실패할 경우 Promise를 거부합니다</span>\n        });\n    });\n  });\n};\n\n<span class=\"hljs-comment\">// 예제 작업</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">task1</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'작업 1 완료'</span>);\n    }, <span class=\"hljs-number\">200</span>);\n  });\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">task2</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'작업 2'</span>);\n    }, <span class=\"hljs-number\">10</span>);\n  });\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">task3</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'105'</span>);\n    }, <span class=\"hljs-number\">50</span>);\n  });\n};\n\n<span class=\"hljs-title function_\">executeParallel</span>([task1, task2, task3])\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">results</span>) =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'모든 작업 완료:'</span>, results);\n  })\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'에러:'</span>, error);\n  });\n</code></pre>\n<p>위 구현에서:</p>\n<ul>\n<li>executeParallel() 함수는 각각이 Promise를 반환하는 함수인 작업 배열을 가져옵니다.</li>\n<li>executeParallel() 내에서 모든 작업의 완료를 추적하는 주요 Promise가 생성됩니다.</li>\n<li>각 작업은 Promise.resolve(task())를 사용하여 비동기적으로 실행됩니다.</li>\n<li>작업이 완료되면 그 결과가 배열에 저장되고 completedCount가 증가합니다.</li>\n<li>작업 중에 오류가 발생하면 주요 Promise는 해당 오류로 거부됩니다.</li>\n<li>모든 작업이 완료되면 주요 Promise는 결과 배열로 해결됩니다.</li>\n</ul>\n<p>이 블로그가 도움이 되고 통찰력을 줬기를 바랍니다. 읽어주셔서 감사합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}