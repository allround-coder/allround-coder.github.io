{"pageProps":{"post":{"title":"TanStack Router는 SPA 개발을 위한 가장 강력한 옵션 중 하나입니다, TanStack Query","description":"","date":"2024-05-12 21:31","slug":"2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery","content":"\n\n![이미지](/assets/img/2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery_0.png)\n\nReact에서 라우팅과 데이터 가져오기는 특히 중요한 역할을 합니다.\n\n물론 Next.js나 Remix와 같은 프레임워크를 채택하면 프레임워크에서 제공하는 API를 사용하여 라우팅부터 데이터 가져오기까지 모든 것을 구현할 수 있습니다.\n\n그러나 BtoB 서비스의 경우 SPA만으로 충분하며, Next.js와 같은 프레임워크를 채택하는 것은 불필요하게 과분할 수 있습니다.\n\n\n\n우리가 원하는 것은 안전한 유형의 파일 기반 라우팅과 효율적인 데이터 가져오기입니다.\n\n본 문서는 2024년 2월 기준으로, TanStack Router가 기술 선택에서 SPA용 라우팅 라이브러리로 매우 강력한 옵션이라는 것을 소개합니다.\n\n# 소개\n\n본 문서에서는 TanStack Router 및 TanStack Query가 기능과 실제 설계 구조 예제에 기반하여 SPA 애플리케이션에 대한 최적의 해결책 중 하나가 될 수 있는 방법에 대해 논의할 것입니다.\n\n\n\nTanStack Router은 SSR (서버 측 렌더링) 기능을 제공하지만, 이 대화에서는 특히 SPA에 적용된 부분에 초점을 맞출 것입니다.\n\n## 대상\n\n- React와 함께 SPA를 위한 기술 선택을 고려 중인 개발자\n- 안전한 유형의 개발 경험을 찾는 개발자\n- Next.js와 같은 프레임워크 도입이 너무 많다고 느끼는 개발자\n- React + Vite와 호환되는 라이브러리를 찾고 있는 개발자\n\n# TanStack Router 소개\n\n\n\nTanStack Router는 2023년 크리스마스에 버전 1.0으로 출시된 비교적 새로운 라이브러리입니다. 이 트윗에 게시된 비디오에서는 그 기능을 쉽게 이해할 수 있도록 설명하고 있으니 한번 보세요.\n\n# 타입 안전 및 간편한 라우팅\n\nTanStack Router의 주요 기능 중 하나는 타입 안전성입니다. `Link /` 또는 useNavigate를 사용하여 탐색할 때 코드 완성을 제공합니다. 경로뿐만 아니라 경로 매개변수와 검색 매개변수를 타입 안전하게 처리할 수 있어 매우 강력합니다.\n\n게다가 API는 매우 간단하고 이해하기 쉽습니다. 이것이 높은 품질의 개발 경험을 제공한다고 느낄 수 있는 이유 중 하나입니다.\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*JdXNcU_oldH_BlIQhZeNPQ.gif)\n\n# 파일 기반 라우트 생성\n\n저는 TanStack Router의 파일 기반 라우팅 및 자동 생성 기능을 특히 좋아합니다. 이는 파일을 통해 라우팅을 정의할 수 있으며, Next.js나 Remix의 App Router와 유사하게 라우팅이 자동으로 생성됩니다. 이는 코드베이스에 라우팅을 구현할 필요가 없다는 것을 의미합니다.\n\n물론 코드를 기반으로 라우팅을 구현하는 것도 가능하지만, 공식 권장사항은 파일 기반 라우팅을 하는 것입니다.\n\n\n\n참고: 이 문서는 폴더 경로 방식 라우팅을 소개합니다. 플랫 라우트가 아닙니다.\n\n```js\n__root.tsx // 루트 파일은 모든 라우트에 적용됩니다.\nposts/\n  route.tsx // `/posts`\n  $postId/\n    route.tsx // `/posts/$postId\r\n```\n\n위와 같은 디렉토리 구조를 가지고 있을 때, /posts 및 /posts/$postId의 라우트가 생성됩니다. 또한 TanStack Router는 고유한 파일 정의를 갖고 있기 때문에 특히 중요한 것들을 소개할 것입니다.\n\n## 특별한 역할을 하는 파일 이름\n\n\n\n__root.tsx\n\n이 파일은 모든 경로에 적용되는 파일입니다. 특정 경로가 없으며 여기에서 정의된 컴포넌트는 항상 렌더링됩니다.\n\n```js\nimport { createRootRoute } from '@tanstack/react-router'\n\nexport const Route = createRootRoute()\n```\n\n또한, createRootRoute 대신 createRootRouteWithContextAPI를 사용하면 의존성 주입이 가능합니다.\n\n\n\n```js\nimport { createRootRouteWithContext, createRouter } from '@tanstack/react-router'\n\ninterface MyRouterContext {\n  queryClient: QueryClient\n}\n\nconst rootRoute = createRootRouteWithContext<MyRouterContext>()({\n  component: App,\n})\n\nconst queryClient = new QueryClient()\n\nconst router = createRouter({\n  routeTree: rootRoute,\n  context: {\n    queryClient,\n  },\n})\n```\n\n$token（예: $postId）\n\n$를 접두어로 사용하면 URL 경로로 사용될 것을 의미합니다. 또한, 일치하는 경로 매개변수는로더 함수나 컴포넌트 내에서 참조할 수 있습니다.\n\n```js\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ params }) => {\n    return fetchPost(params.postId)\n  },\n})\n```\n\n\n\n_ 접두사\n\n_를 접두어로 사용할 때, 레이아웃 경로로 사용되며 URL 경로에 표시되지 않습니다. 이는 디렉토리 구조와 라우팅이 다음과 같이 일치한다는 것을 의미합니다.\n\n```js\n_layout/\n  layout-a.tsx // → /layout-a\n  layout-b.tsx // → /layout-b\n```\n\n이렇게 하면 서로 관련된 라우트들을 일치시킬 수 있습니다.\n\n\n\n## RouteOptions 유형\n\n```js\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  component, // skip\n  loader,\n  errorComponent,\n  pendingComponent,\n  validateSearch,\n})\n```\n\nloader\n\n```js\ntype loader = ({/** 생략 */}) => Promise<TLoaderData> | TLoaderData | void\n```\n\n\n\n이 기능은 Remix/React-Router의 로더와 유사합니다. 경로가 호출될 때 트리거가 발동되며, 실패할 경우 오류를 발생시킵니다.\n\n로더가 Promise를 반환할 때, 경로는 보류 상태가 되며, 렌더링은 Promise가 해결될 때까지 일시 중단됩니다. Promise가 거부되면 경로는 오류 상태가 됩니다.\n\n오류 구성요소, 보류 구성요소\n\n위에서 언급한 로더 함수의 맥락에서, Promise의 상태에 따라 렌더링이 일시 중단되거나 오류 상태가 될 수 있다고 설명했습니다. 따라서 TanStack Router는 각 경로에 대해 오류 및 보류 상태를 위한 구성 요소를 정의할 수 있습니다.\n\n\n\n```js\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  component, // success\n  errorComponent, // error\n  pendingComponent, // pending\n})\n```\n\nvalidateSearch\n\nvalidateSearch을 사용하여 검색 매개변수를 유효성 검사하고 안전하게 처리할 수 있습니다. 또한 zod와 같은 유효성 검사 라이브러리와 결합할 수 있습니다.\n\n```js\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().catch(1),\n  filter: z.string().catch(''),\n  sort: z.enum(['newest', 'oldest', 'price']).catch('newest'),\n})\n\ntype ProductSearch = z.infer<typeof productSearchSchema>\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search) => productSearchSchema.parse(search),\n})\n```\n\n\n\n# 번들 크기를 줄이기 위한 코드 분할\n\nTanStack 라우터는 코드 분할을 위한 기능을 내장하고 있습니다. 코드 분할 (또는 지연 로딩)의 주요 목적은 세 가지입니다:\n\n- 초기 페이지 로드에 필요한 코드량을 줄입니다.\n- 필요할 때만 대상 코드를 로드합니다.\n- 코드를 청크(chunk)로 나눠서 더 세분화된 수준에서 캐싱을 가능하게 합니다.\n\n## 코드 분할 사용 방법\n\n\n\nTanStack Router로 코드 분할하는 방법은 간단해요:\n\n이를 통해 Critical Routes와 Lazy Routes를 구별할 수 있어요.\n\nCritical Route\n\n- 초기에 로드되는 코드입니다.\n\n\n\n게으른 루트\n\n- 요청 시 로드되는 코드, 지연이 발생합니다.\n\n그렇다면, 코드 분할을 위한 대상을 선택하기 위해 어떤 기준을 사용해야 할까요?\n\nTanStack 라우터 문서에서 명확히 설명되어 있습니다.\n\n\n\nCritical Route에 대한 목표 (route.tsx)\n\n- 경로 구문 분석/직렬화\n- 검색 매개변수 유효성 검사\n- 로더, 로드 전\n- 라우트 컨텍스트\n- 메타\n- 링크\n- 스크립트\n- 스타일\n- 아래에 나열되지 않은 모든 다른 라우트 구성\n\nLazy Route에 대한 목표 (route.lazy.tsx)\n\n- 라우트 컴포넌트\n- 오류 컴포넌트\n- 대기 중인 컴포넌트\n- 찾을 수 없는 컴포넌트\n\n\n\n각 경로와 연관된 컴포넌트는 Lazy Loading을 위해 지정할 수 있습니다.\n\n## 로더는 코드 분할 대상이 아닌가요???\n\n로더를 Lazy Routes의 일부로 만들지 않는 세 가지 이유가 있습니다:\n\n- 로더를 대상으로 지정하면 두 번의 왕복이 필요합니다: 하나는 로더 자체의 청크를 가져오기 위한 것이고, 다른 하나는 그를 실행하기 위한 것입니다.\n- 일반적으로 로더에는 상대적으로 적은 양의 코드가 포함되어 있기 때문에, 이를 포함시켜도 번들 크기를 크게 줄이지 않습니다.\n- 경로에 대해, 로더는 프리로딩을 위한 중요한 요소입니다.\n\n\n\n# 검색 매개변수를 사용한 상태 관리\n\nTanStack Router는 검색 매개변수를 전역 상태로 간주하며, 타입 안전성 및 유효성 검사 기능을 통해 이를 안전하게 관리할 수 있게 해줍니다.\n\n사용자들에게는 다음과 같은 시나리오에서 상태가 일관되게 유지되는 것을 기대합니다:\n\n- Cmd/Ctrl + 클릭으로 새 탭 열기\n- 즐겨찾기나 링크 공유\n- 페이지 새로고침\n\n\n\n개발자들에게는 다른 상태 관리 솔루션과 같이 유연하고 안전하며 유효성을 갖춘 방식으로 검색 매개변수를 관리하는 이 접근 방식이 검색 매개변수를 더 효율적으로 처리할 수 있게 합니다.\n\n## 왜 URLSearchParams를 사용하지 않나요?\n\nURLSearchParams에는 다음과 같은 단점이 있습니다:\n\n- 항상 문자열 유형임.\n- 대부분의 경우 평면 구조입니다.\n- 검색 매개변수를 업데이트할 때 URL 경로를 고려해야 합니다.\n\n\n\n그러나 검색 매개변수를 전역 상태로 고려할 때, 이러한 단점은 중대한 도전 과제가 됩니다.\n\n이상적인 해결책은 다음과 같습니다:\n\n- 중첩된 배열 및 객체와 같은 복잡한 데이터 유형을 조작할 수 있는 능력을 포함하여 상태 관리 라이브러리와 유사한 유형의 여러 가지 처리.\r\n- URL 경로와 상호 작용하지 않고 검색 매개변수를 관리합니다.\n\nTanStack Router는 이러한 도전에 대처합니다.\n\n\n\n## JSON-first 검색 매개변수\n\nTanStack Router는 강력한 구문 분석기를 갖추고 있어서 검색 매개변수를 자동으로 구조화된 JSON으로 변환할 수 있습니다. 이는 JSON으로 직렬화 가능한 데이터를 검색 매개변수로 사용할 수 있다는 것을 의미합니다.\n\n```js\nconst link = (\n  <Link\n    to=\"/shop\"\n    search={\n      pageIndex: 3,\n      includeCategories: ['electronics', 'gifts'],\n      sortBy: 'price',\n      desc: true,\n    }\n  />\n)\n// → /shop?pageIndex=3&includeCategories=%5B%22electronics%22%2C%22gifts%22%5D&sortBy=price&desc=true\n```\n\n## 유효성 검사와 유형 정의\n\n\n\n검색 매개변수의 유효성 검사 및 유형 정의는 createFileRouteAPI의 validateSearch 옵션을 사용합니다. 이를 통해 구성 요소에서 검색 매개변수를 검색하고 조작할 때 유형 안전성을 제공할 수 있습니다.\n\n```js\n// /routes/shop.products.tsx\n\ntype ProductSearchSortOptions = 'newest' | 'oldest' | 'price'\n\ntype ProductSearch = {\n  page: number\n  filter: string\n  sort: ProductSearchSortOptions\n}\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search: Record<string, unknown>): ProductSearch => {\n    // 검색 매개변수를 유효성 검사하고 구문 분석하여 유형화된 상태로 반환합니다.\n    return {\n      page: Number(search?.page ?? 1),\n      filter: (search.filter as string) || '',\n      sort: (search.sort as ProductSearchSortOptions) || 'newest',\n    }\n  },\n})\n```\n\n# 캐시를 이용한 데이터 로딩\n\nTanStack Router는 SWR 캐싱이 가능한 기능을 제공하여 일반적인 로더 역할을 뛰어넘습니다. 이 기능을 통해 데이터를 사전로드하고 캐시된 데이터를 표시하거나 이전에 검색한 데이터를 캐시하고 다시 사용할 수 있습니다.\n\n\n\n## 의존성 기반 Stale-While-Revalidate 캐싱\n\n캐시는 경로 의존성에 의해 제어됩니다. 여기서 의존성은 다음과 같은 요소들입니다:\n\n- 라우트의 경로명\n/posts/1 대 /posts/2\n- loaderDeps가 제공하는 추가적인 의존성\nloaderDeps: (' search: ' index, size ' ') =` (' index, size ')\n\n## 캐시 제어\n\n\n\nTanStack Router의 캐시는 TanStack Query와 비슷하며, TanStack Query에 익숙한 사람들은 학습 비용을 낮추면서 처리할 수 있습니다.\n\nstaleTime\n\n- 캐시된 데이터가 오래되었다고 간주되기까지의 시간입니다. 기본값은 0입니다.\n\ngcTime\n\n\n\n- 사용되지 않은 캐시가 폐기되기까지의 시간입니다. 기본값은 30분입니다.\n\n# TanStack Query의 Suspense\n\n지금까지 TanStack Router에 대해 이야기했지만, TanStack Query v5와 함께 안정화된 suspense 기능에 대해 설명하려고 합니다.\n\n일반 useQuery와 useSuspenseQuery의 주요 차이점은 이제 데이터가 정의되지 않은 상태에 대한 계산이 필요하지 않다는 것입니다.\n\n\n\nTanStack Query을 사용할 때, 데이터가 없을 경우 pendingComponent가 표시되고 오류가 발생할 경우 errorComponent가 표시되도록 구현했습니다. 아래 코드는 이를 예시로 보여줍니다.\n\n```js\nfunction Todos() {\n  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })\n\n  if (query.status === \"pending\") {\n    return <Pending />\n  }\n\n  if (query.status === \"error\") {\n    return <Error />\n  }\n\n  return (\n    <div>\n      할 일 목록\n    </div>\n  )\n}\n```\n\n그러나 useSuspenseQuery를 사용할 때는 데이터가 정의되지 않은 상태를 고려할 필요가 없으므로 코드가 다음과 같이 변경됩니다:\n\n```js\nfunction Todos() {\n  const { data } = useSuspenseQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n\n  // 🎉 로딩 또는 오류 상태를 처리할 필요가 없습니다\n\n  return (\n    <div>\n      { /* TypeScript가 데이터가 undefined일 수 없다는 것을 알고 있습니다 */ }\n      {data.map((todo) => (\n        <div>{todo.title}</div>\n      ))}\n    </div>\n  )\n}\n```\n\n\n\n```js\nfunction App() {\n  // 🚀 경계(Boundaries)는 로딩 및 오류 상태를 처리합니다\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <ErrorBoundary fallback={<div>On no!</div>}>\n        <Todos />\n      </ErrorBoundary>\n    </Suspense>\n  )\n}\n```\n\n이전에는 컴포넌트 자체에서 \"대기 중\" 및 \"오류\" 상태를 처리해야했습니다. 이제 이러한 과제를 별도로 관리할 수 있게 되었습니다.\n\n- 대기 중 상태: Suspense의 대기 중 대체(fallback)로 처리됩니다.\n- 오류 상태: ErrorBoundary의 대체(fallback)로 처리됩니다.\n\n일부 분들께서는 이러한 역할 분담의 분리가 TanStack Router의 파일 기반 접근 방식과 잘 맞는다는 것을 알아채셨을 것입니다. TanStack Router에서는 각 경로(route)별로 컴포넌트, 대기 중 컴포넌트(pendingComponent) 및 오류 컴포넌트(errorComponent)를 정의할 수 있었습니다.```\n\n\n\n```js\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  component, // 성공\n  errorComponent, // 오류\n  pendingComponent, // 보류 중\n})\n```\n\n이는 컴포넌트 내에서 사용되는 useSuspenseQuery의 보류 및 오류 상태 처리를 TanStack Router를 통해 경로별로 구성할 수 있다는 것을 의미합니다.\n\n## Loader 또는 TanStack Query를 사용해야 할까요?\n\nTanStack Query의 suspense 기능이 TanStack Router와 호환되는 방법을 설명했습니다. 그러나 데이터 가져오기 관점에서는 TanStack Router의 로더를 사용하거나 SWR 캐싱 기능을 가진 TanStack Router를 사용하는 것도 가능합니다.\n\n\n\n그래서 그것들을 어떻게 구분하고 활용해야 할까요?\n\n공식 문서에서는 TanStack Router의 Cache의 장단점을 언급했습니다.\n\nTanStack Router Cache의 장점\n\n- 쉽게 사용할 수 있음\r\n- 경로별 중복 제거, 사전로딩, 로딩 처리를 가능하게 함\r\n- 자동으로 가비지 수집을 지원함\n\n\n\nTanStack Router Cache의 단점\n\n- 지속성을 위한 어댑터나 모델 없음\n- 라우트 간 캐시 공유 또는 중복 제거 기능 없음\n- 업데이트를 위한 API가 부족함\n\n로더는 대상 라우트와 관련이 있으며, 라우트 간에 캐시를 공유할 수 없습니다.\n\n따라서 응용 프로그램 상태 관리 도구로서의 TanStack Query의 존재가 필요하며, TanStack Router와 효과적으로 결합되어야 합니다.\n\n\n\n## 캐시 데이터 미리 로딩\n\nTanStack Router에는 미리 로딩하는 기능이 내장되어 있습니다. 예를 들어 사용자가 다른 화면으로 이동하려는 `Link`에 마우스를 가져가면 해당 경로에 필요한 데이터를 미리 로드합니다.\n\n이 기능은 매우 강력하며 TanStack Query와 결합하여 데이터 가져오기를 보다 효율적으로 만들어주고 때로는 폭포 모델 문제까지 해결할 수 있습니다.\n\n다음은 코드 예시입니다:\n\n\n\nTanStack Router의 로더를 사용하여 데이터를 미리 준비하고, TanStack Query의 캐시에 저장하세요. 그래서 useSuspenseQuery가 호출되는 시점에는 데이터가 이미 준비되어 있는 것이 보장됩니다.\n\n```js\n// src/routes/posts.tsx\n\nconst postsQueryOptions = queryOptions({\n  queryKey: 'posts',\n  queryFn: () => fetchPosts,\n})\n\nexport const Route = createFileRoute('/posts')({\n  // 데이터가 로드되도록 'loader' 옵션 사용\n  loader: () => queryClient.ensureQueryData(postsQueryOptions),\n  component: () => {\n    // 캐시에서 데이터를 읽고 업데이트에 구독합니다\n    const posts = useSuspenseQuery(postsQueryOptions)\n\n    return (\n      <div>\n        {posts.map((post) => (\n          <Post key={post.id} post={post} />\n        ))}\n      </div>\n    )\n  },\n})\n```\n\nTanStack Router의 로더를 사용하여 데이터를 미리 로드하고, TanStack Query의 useSuspenseQuery로 캐시된 데이터 상태를 관리하세요.\n\n# TanStack Router의 디렉터리 디자인\n\n\n\n지금까지 TanStack 라우터의 기능과 TanStack 쿼리와의 호환성에 대해 논의해왔습니다. 마지막으로, TanStack 라우터의 디렉토리 구조를 소개하며 해당 특징과 장점에 대해 설명하겠습니다.\n\n다음은 디렉토리 구조입니다:\n\n```js\n.\n├── __root.tsx // 루트 파일\n├── posts\n│   ├── -components // 🐢 경로 내부에서 사용되는 UI 구성 요소\n│   ├── -api // 🦋 경로 내부에서 사용되는 API 통신 훅\n│   ├── -types // 🐠 경로 내부에서 사용되는 타입 정의\n│   ├── -functions // 🦐 경로 내부에서 사용되는 함수\n│   ├── route.lazy.tsx // 🐕 지연 로드 라우트\n│   ├── route.tsx // 🦈 주요 라우트\n│   └── $postId // /posts와 유사\n│       ├── -components\n│       ├── -api\n│       ├── -types\n│       ├── -functions\n│       ├── route.lazy.tsx\n│       └── route.tsx\n```\n\n## 특징 1: 특징 기반 디렉토리 구조\n\n\n\n제공된 예시에서 각 라우트는 다음과 같은 디렉토리를 포함하고 있어요:\n\n- -components: 해당 라우트 내에서 사용하는 UI 구성 요소들이 들어 있어요.\n- -api: 해당 라우트 내에서 사용하는 API 통신에 사용되는 후크들이 들어 있어요. 여기에는 TanStack Query와 같은 API가 활용돼요.\n- -types: 해당 라우트 내에서 사용하는 타입 정의들이 들어 있어요.\n- -functions: 해당 라우트 내에서 사용되는 함수들이 들어 있어요. 각 함수는 자체 단위 테스트가 구현될 수도 있어요.\n\n이 접근 방식을 통해, 디렉토리인 components나 api와 같은 레이어 기반 접근 방식과는 달리 기능 기반 디자인이 가능해져요.\n\n물론, 모든 기능이 직접적으로 라우트에 해당하는 것은 아닐 거예요. 그런 경우에는 관련된 관심사를 그룹화하기 위해 _접두사를 사용하는 것이 효과적일 수 있어요.\n\n\n\n## 기능 2: 라우트 훅 사용을 특정 라우트에 제한\n\nTanStack Router에서는 각 특정 라우트에 대응하는 Route Hooks를 사용하여 경로 매개변수와 검색 매개변수를 안전하게 처리할 수 있습니다.\n\n```js\nexport const Route = createFileRoute('/posts/$postId')({\n  component: PostComponent,\n})\n\nfunction PostComponent() {\n  const { postId } = Route.useParams()\n  return <div>포스트 {postId}</div>\n}\n```\n\n위와 같은 디렉토리 디자인으로 캡슐화된 라우트 내에서 사용되는 컴포넌트들이 있을 때, /posts 하위의 라우트에 대해 /posts에 특화된 Route Hooks가 사용됨을 명확하게 알 수 있습니다.\n\n\n\n```md\n.\n├── pages\n├── components\n│   ├── Post.tsx // 해당 컴포넌트 라우트 훅을 사용하나요?\n│   ├── Todo.tsx // 해당 컴포넌트 라우트 훅을 사용하나요?\n│   ├── Form.tsx // ???\n│   └── Card.tsx // ???\n```\n\n아주 극단적인 예시라고 하더라도, 컴포넌트가 최상위 계층에 배치된 디자인에서는 어떤 라우트 훅이 어디에 사용되고 있는지를 구분하는 것이 어렵습니다.\n\n특집 기반의 디자인에 초점을 맞추면, 특정 라우트 내에서 사용되는 컴포넌트만을 고려하게 됩니다.\n\n```md\n.\n├── posts\n│   ├── -components // /posts 라우트 훅이 사용됨\n│   │   ├── Card.tsx\n│   │   └── Form.tsx\n│   └── $postId \n│       └── -components // /posts/$postId 라우트 훅이 사용됨\n```\n\n\n\n## 기능 3: Suspense를 위한 명확한 경계\n\nTanStack Query의 useSuspenseQuery를 사용하면 보류 및 오류 상태에 대한 문제를 외부화하여 컴포넌트 측이 데이터가 정의되지 않은 경우를 예상할 필요가 없어집니다.\n\nTanStack Router와 잘 어울린다고 언급한 이유 중 하나는 각 라우트마다 pendingComponent 및 errorComponent를 정의할 수 있으므로 사용자 정의 Suspense 경계를 정의할 필요가 없다는 것입니다.\n\n더 많은 정보를 원한다면 TanStack Router 문서에 게시된 샘플을 참조해주세요.\n\n\n\n위의 이미지에서 빨간색과 파란색 프레임으로 표시된 Suspense 바운더리가 있습니다. 이는 파란 프레임 내에서 발생하는 보류 및 오류 상태가 /post/$postId 경로에 정의된 처리에 의해 처리되는 반면 빨간 프레임 내에서 발생하는 상태는 /posts 경로에 정의된 처리에 의해 처리된다는 것을 의미합니다.\n\n(아래는 실제 코드 예시입니다.)\n\n# 요약\n\n\n\n이번 세션에서는 TanStack Router의 기능과 TanStack Query와의 호환성, 그리고 디렉토리 디자인을 소개했습니다. Next.js와 Remix와 같은 프레임워크의 발전은 놀라운데, React를 사용하여 Single Page Applications (SPAs)을 개발하는 도중에 완전히 해결되지 않은 어려움이 있었다는 느낌이 있었습니다.\n\n그러나 이번에 소개된 TanStack Router의 파일 기반 및 높은 개발 경험(DX) 접근 방식은 React 라이브러리 선택 시 효과적인 선택일 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery_0.png"},"coverImage":"/assets/img/2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery_0.png","tag":["Tech"],"readingTime":14},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery_0.png\" alt=\"이미지\"></p>\n<p>React에서 라우팅과 데이터 가져오기는 특히 중요한 역할을 합니다.</p>\n<p>물론 Next.js나 Remix와 같은 프레임워크를 채택하면 프레임워크에서 제공하는 API를 사용하여 라우팅부터 데이터 가져오기까지 모든 것을 구현할 수 있습니다.</p>\n<p>그러나 BtoB 서비스의 경우 SPA만으로 충분하며, Next.js와 같은 프레임워크를 채택하는 것은 불필요하게 과분할 수 있습니다.</p>\n<p>우리가 원하는 것은 안전한 유형의 파일 기반 라우팅과 효율적인 데이터 가져오기입니다.</p>\n<p>본 문서는 2024년 2월 기준으로, TanStack Router가 기술 선택에서 SPA용 라우팅 라이브러리로 매우 강력한 옵션이라는 것을 소개합니다.</p>\n<h1>소개</h1>\n<p>본 문서에서는 TanStack Router 및 TanStack Query가 기능과 실제 설계 구조 예제에 기반하여 SPA 애플리케이션에 대한 최적의 해결책 중 하나가 될 수 있는 방법에 대해 논의할 것입니다.</p>\n<p>TanStack Router은 SSR (서버 측 렌더링) 기능을 제공하지만, 이 대화에서는 특히 SPA에 적용된 부분에 초점을 맞출 것입니다.</p>\n<h2>대상</h2>\n<ul>\n<li>React와 함께 SPA를 위한 기술 선택을 고려 중인 개발자</li>\n<li>안전한 유형의 개발 경험을 찾는 개발자</li>\n<li>Next.js와 같은 프레임워크 도입이 너무 많다고 느끼는 개발자</li>\n<li>React + Vite와 호환되는 라이브러리를 찾고 있는 개발자</li>\n</ul>\n<h1>TanStack Router 소개</h1>\n<p>TanStack Router는 2023년 크리스마스에 버전 1.0으로 출시된 비교적 새로운 라이브러리입니다. 이 트윗에 게시된 비디오에서는 그 기능을 쉽게 이해할 수 있도록 설명하고 있으니 한번 보세요.</p>\n<h1>타입 안전 및 간편한 라우팅</h1>\n<p>TanStack Router의 주요 기능 중 하나는 타입 안전성입니다. <code>Link /</code> 또는 useNavigate를 사용하여 탐색할 때 코드 완성을 제공합니다. 경로뿐만 아니라 경로 매개변수와 검색 매개변수를 타입 안전하게 처리할 수 있어 매우 강력합니다.</p>\n<p>게다가 API는 매우 간단하고 이해하기 쉽습니다. 이것이 높은 품질의 개발 경험을 제공한다고 느낄 수 있는 이유 중 하나입니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*JdXNcU_oldH_BlIQhZeNPQ.gif\" alt=\"이미지\"></p>\n<h1>파일 기반 라우트 생성</h1>\n<p>저는 TanStack Router의 파일 기반 라우팅 및 자동 생성 기능을 특히 좋아합니다. 이는 파일을 통해 라우팅을 정의할 수 있으며, Next.js나 Remix의 App Router와 유사하게 라우팅이 자동으로 생성됩니다. 이는 코드베이스에 라우팅을 구현할 필요가 없다는 것을 의미합니다.</p>\n<p>물론 코드를 기반으로 라우팅을 구현하는 것도 가능하지만, 공식 권장사항은 파일 기반 라우팅을 하는 것입니다.</p>\n<p>참고: 이 문서는 폴더 경로 방식 라우팅을 소개합니다. 플랫 라우트가 아닙니다.</p>\n<pre><code class=\"hljs language-js\">__root.<span class=\"hljs-property\">tsx</span> <span class=\"hljs-comment\">// 루트 파일은 모든 라우트에 적용됩니다.</span>\nposts/\n  route.<span class=\"hljs-property\">tsx</span> <span class=\"hljs-comment\">// `/posts`</span>\n  $postId/\n    route.<span class=\"hljs-property\">tsx</span> <span class=\"hljs-comment\">// `/posts/$postId</span>\n</code></pre>\n<p>위와 같은 디렉토리 구조를 가지고 있을 때, /posts 및 /posts/$postId의 라우트가 생성됩니다. 또한 TanStack Router는 고유한 파일 정의를 갖고 있기 때문에 특히 중요한 것들을 소개할 것입니다.</p>\n<h2>특별한 역할을 하는 파일 이름</h2>\n<p>__root.tsx</p>\n<p>이 파일은 모든 경로에 적용되는 파일입니다. 특정 경로가 없으며 여기에서 정의된 컴포넌트는 항상 렌더링됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { createRootRoute } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@tanstack/react-router'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createRootRoute</span>()\n</code></pre>\n<p>또한, createRootRoute 대신 createRootRouteWithContextAPI를 사용하면 의존성 주입이 가능합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { createRootRouteWithContext, createRouter } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@tanstack/react-router'</span>\n\ninterface <span class=\"hljs-title class_\">MyRouterContext</span> {\n  <span class=\"hljs-attr\">queryClient</span>: <span class=\"hljs-title class_\">QueryClient</span>\n}\n\n<span class=\"hljs-keyword\">const</span> rootRoute = createRootRouteWithContext&#x3C;<span class=\"hljs-title class_\">MyRouterContext</span>>()({\n  <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">App</span>,\n})\n\n<span class=\"hljs-keyword\">const</span> queryClient = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">QueryClient</span>()\n\n<span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createRouter</span>({\n  <span class=\"hljs-attr\">routeTree</span>: rootRoute,\n  <span class=\"hljs-attr\">context</span>: {\n    queryClient,\n  },\n})\n</code></pre>\n<p>$token（예: $postId）</p>\n<p>$를 접두어로 사용하면 URL 경로로 사용될 것을 의미합니다. 또한, 일치하는 경로 매개변수는로더 함수나 컴포넌트 내에서 참조할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { createFileRoute } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@tanstack/react-router'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createFileRoute</span>(<span class=\"hljs-string\">'/posts/$postId'</span>)({\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-keyword\">async</span> ({ params }) => {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fetchPost</span>(params.<span class=\"hljs-property\">postId</span>)\n  },\n})\n</code></pre>\n<p>_ 접두사</p>\n<p>_를 접두어로 사용할 때, 레이아웃 경로로 사용되며 URL 경로에 표시되지 않습니다. 이는 디렉토리 구조와 라우팅이 다음과 같이 일치한다는 것을 의미합니다.</p>\n<pre><code class=\"hljs language-js\">_layout/\n  layout-a.<span class=\"hljs-property\">tsx</span> <span class=\"hljs-comment\">// → /layout-a</span>\n  layout-b.<span class=\"hljs-property\">tsx</span> <span class=\"hljs-comment\">// → /layout-b</span>\n</code></pre>\n<p>이렇게 하면 서로 관련된 라우트들을 일치시킬 수 있습니다.</p>\n<h2>RouteOptions 유형</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// routes/posts.tsx</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createFileRoute</span>(<span class=\"hljs-string\">'/posts'</span>)({\n  component, <span class=\"hljs-comment\">// skip</span>\n  loader,\n  errorComponent,\n  pendingComponent,\n  validateSearch,\n})\n</code></pre>\n<p>loader</p>\n<pre><code class=\"hljs language-js\">type loader = <span class=\"hljs-function\">(<span class=\"hljs-params\">{/** 생략 */}</span>) =></span> <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-title class_\">TLoaderData</span>> | <span class=\"hljs-title class_\">TLoaderData</span> | <span class=\"hljs-keyword\">void</span>\n</code></pre>\n<p>이 기능은 Remix/React-Router의 로더와 유사합니다. 경로가 호출될 때 트리거가 발동되며, 실패할 경우 오류를 발생시킵니다.</p>\n<p>로더가 Promise를 반환할 때, 경로는 보류 상태가 되며, 렌더링은 Promise가 해결될 때까지 일시 중단됩니다. Promise가 거부되면 경로는 오류 상태가 됩니다.</p>\n<p>오류 구성요소, 보류 구성요소</p>\n<p>위에서 언급한 로더 함수의 맥락에서, Promise의 상태에 따라 렌더링이 일시 중단되거나 오류 상태가 될 수 있다고 설명했습니다. 따라서 TanStack Router는 각 경로에 대해 오류 및 보류 상태를 위한 구성 요소를 정의할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// routes/posts.tsx</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createFileRoute</span>(<span class=\"hljs-string\">'/posts'</span>)({\n  component, <span class=\"hljs-comment\">// success</span>\n  errorComponent, <span class=\"hljs-comment\">// error</span>\n  pendingComponent, <span class=\"hljs-comment\">// pending</span>\n})\n</code></pre>\n<p>validateSearch</p>\n<p>validateSearch을 사용하여 검색 매개변수를 유효성 검사하고 안전하게 처리할 수 있습니다. 또한 zod와 같은 유효성 검사 라이브러리와 결합할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { z } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'zod'</span>\n\n<span class=\"hljs-keyword\">const</span> productSearchSchema = z.<span class=\"hljs-title function_\">object</span>({\n  <span class=\"hljs-attr\">page</span>: z.<span class=\"hljs-title function_\">number</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-number\">1</span>),\n  <span class=\"hljs-attr\">filter</span>: z.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-string\">''</span>),\n  <span class=\"hljs-attr\">sort</span>: z.<span class=\"hljs-title function_\">enum</span>([<span class=\"hljs-string\">'newest'</span>, <span class=\"hljs-string\">'oldest'</span>, <span class=\"hljs-string\">'price'</span>]).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-string\">'newest'</span>),\n})\n\ntype <span class=\"hljs-title class_\">ProductSearch</span> = z.<span class=\"hljs-property\">infer</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> productSearchSchema>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createFileRoute</span>(<span class=\"hljs-string\">'/shop/products'</span>)({\n  <span class=\"hljs-attr\">validateSearch</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">search</span>) =></span> productSearchSchema.<span class=\"hljs-title function_\">parse</span>(search),\n})\n</code></pre>\n<h1>번들 크기를 줄이기 위한 코드 분할</h1>\n<p>TanStack 라우터는 코드 분할을 위한 기능을 내장하고 있습니다. 코드 분할 (또는 지연 로딩)의 주요 목적은 세 가지입니다:</p>\n<ul>\n<li>초기 페이지 로드에 필요한 코드량을 줄입니다.</li>\n<li>필요할 때만 대상 코드를 로드합니다.</li>\n<li>코드를 청크(chunk)로 나눠서 더 세분화된 수준에서 캐싱을 가능하게 합니다.</li>\n</ul>\n<h2>코드 분할 사용 방법</h2>\n<p>TanStack Router로 코드 분할하는 방법은 간단해요:</p>\n<p>이를 통해 Critical Routes와 Lazy Routes를 구별할 수 있어요.</p>\n<p>Critical Route</p>\n<ul>\n<li>초기에 로드되는 코드입니다.</li>\n</ul>\n<p>게으른 루트</p>\n<ul>\n<li>요청 시 로드되는 코드, 지연이 발생합니다.</li>\n</ul>\n<p>그렇다면, 코드 분할을 위한 대상을 선택하기 위해 어떤 기준을 사용해야 할까요?</p>\n<p>TanStack 라우터 문서에서 명확히 설명되어 있습니다.</p>\n<p>Critical Route에 대한 목표 (route.tsx)</p>\n<ul>\n<li>경로 구문 분석/직렬화</li>\n<li>검색 매개변수 유효성 검사</li>\n<li>로더, 로드 전</li>\n<li>라우트 컨텍스트</li>\n<li>메타</li>\n<li>링크</li>\n<li>스크립트</li>\n<li>스타일</li>\n<li>아래에 나열되지 않은 모든 다른 라우트 구성</li>\n</ul>\n<p>Lazy Route에 대한 목표 (route.lazy.tsx)</p>\n<ul>\n<li>라우트 컴포넌트</li>\n<li>오류 컴포넌트</li>\n<li>대기 중인 컴포넌트</li>\n<li>찾을 수 없는 컴포넌트</li>\n</ul>\n<p>각 경로와 연관된 컴포넌트는 Lazy Loading을 위해 지정할 수 있습니다.</p>\n<h2>로더는 코드 분할 대상이 아닌가요???</h2>\n<p>로더를 Lazy Routes의 일부로 만들지 않는 세 가지 이유가 있습니다:</p>\n<ul>\n<li>로더를 대상으로 지정하면 두 번의 왕복이 필요합니다: 하나는 로더 자체의 청크를 가져오기 위한 것이고, 다른 하나는 그를 실행하기 위한 것입니다.</li>\n<li>일반적으로 로더에는 상대적으로 적은 양의 코드가 포함되어 있기 때문에, 이를 포함시켜도 번들 크기를 크게 줄이지 않습니다.</li>\n<li>경로에 대해, 로더는 프리로딩을 위한 중요한 요소입니다.</li>\n</ul>\n<h1>검색 매개변수를 사용한 상태 관리</h1>\n<p>TanStack Router는 검색 매개변수를 전역 상태로 간주하며, 타입 안전성 및 유효성 검사 기능을 통해 이를 안전하게 관리할 수 있게 해줍니다.</p>\n<p>사용자들에게는 다음과 같은 시나리오에서 상태가 일관되게 유지되는 것을 기대합니다:</p>\n<ul>\n<li>Cmd/Ctrl + 클릭으로 새 탭 열기</li>\n<li>즐겨찾기나 링크 공유</li>\n<li>페이지 새로고침</li>\n</ul>\n<p>개발자들에게는 다른 상태 관리 솔루션과 같이 유연하고 안전하며 유효성을 갖춘 방식으로 검색 매개변수를 관리하는 이 접근 방식이 검색 매개변수를 더 효율적으로 처리할 수 있게 합니다.</p>\n<h2>왜 URLSearchParams를 사용하지 않나요?</h2>\n<p>URLSearchParams에는 다음과 같은 단점이 있습니다:</p>\n<ul>\n<li>항상 문자열 유형임.</li>\n<li>대부분의 경우 평면 구조입니다.</li>\n<li>검색 매개변수를 업데이트할 때 URL 경로를 고려해야 합니다.</li>\n</ul>\n<p>그러나 검색 매개변수를 전역 상태로 고려할 때, 이러한 단점은 중대한 도전 과제가 됩니다.</p>\n<p>이상적인 해결책은 다음과 같습니다:</p>\n<ul>\n<li>중첩된 배열 및 객체와 같은 복잡한 데이터 유형을 조작할 수 있는 능력을 포함하여 상태 관리 라이브러리와 유사한 유형의 여러 가지 처리.</li>\n<li>URL 경로와 상호 작용하지 않고 검색 매개변수를 관리합니다.</li>\n</ul>\n<p>TanStack Router는 이러한 도전에 대처합니다.</p>\n<h2>JSON-first 검색 매개변수</h2>\n<p>TanStack Router는 강력한 구문 분석기를 갖추고 있어서 검색 매개변수를 자동으로 구조화된 JSON으로 변환할 수 있습니다. 이는 JSON으로 직렬화 가능한 데이터를 검색 매개변수로 사용할 수 있다는 것을 의미합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> link = (\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Link</span>\n    <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"/shop\"</span>\n    <span class=\"hljs-attr\">search</span>=<span class=\"hljs-string\">{</span>\n      <span class=\"hljs-attr\">pageIndex:</span> <span class=\"hljs-attr\">3</span>,\n      <span class=\"hljs-attr\">includeCategories:</span> ['<span class=\"hljs-attr\">electronics</span>', '<span class=\"hljs-attr\">gifts</span>'],\n      <span class=\"hljs-attr\">sortBy:</span> '<span class=\"hljs-attr\">price</span>',\n      <span class=\"hljs-attr\">desc:</span> <span class=\"hljs-attr\">true</span>,\n    }\n  /></span></span>\n)\n<span class=\"hljs-comment\">// → /shop?pageIndex=3&#x26;includeCategories=%5B%22electronics%22%2C%22gifts%22%5D&#x26;sortBy=price&#x26;desc=true</span>\n</code></pre>\n<h2>유효성 검사와 유형 정의</h2>\n<p>검색 매개변수의 유효성 검사 및 유형 정의는 createFileRouteAPI의 validateSearch 옵션을 사용합니다. 이를 통해 구성 요소에서 검색 매개변수를 검색하고 조작할 때 유형 안전성을 제공할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// /routes/shop.products.tsx</span>\n\ntype <span class=\"hljs-title class_\">ProductSearchSortOptions</span> = <span class=\"hljs-string\">'newest'</span> | <span class=\"hljs-string\">'oldest'</span> | <span class=\"hljs-string\">'price'</span>\n\ntype <span class=\"hljs-title class_\">ProductSearch</span> = {\n  <span class=\"hljs-attr\">page</span>: number\n  <span class=\"hljs-attr\">filter</span>: string\n  <span class=\"hljs-attr\">sort</span>: <span class=\"hljs-title class_\">ProductSearchSortOptions</span>\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createFileRoute</span>(<span class=\"hljs-string\">'/shop/products'</span>)({\n  <span class=\"hljs-attr\">validateSearch</span>: (<span class=\"hljs-attr\">search</span>: <span class=\"hljs-title class_\">Record</span>&#x3C;string, unknown>): <span class=\"hljs-function\"><span class=\"hljs-params\">ProductSearch</span> =></span> {\n    <span class=\"hljs-comment\">// 검색 매개변수를 유효성 검사하고 구문 분석하여 유형화된 상태로 반환합니다.</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">page</span>: <span class=\"hljs-title class_\">Number</span>(search?.<span class=\"hljs-property\">page</span> ?? <span class=\"hljs-number\">1</span>),\n      <span class=\"hljs-attr\">filter</span>: (search.<span class=\"hljs-property\">filter</span> <span class=\"hljs-keyword\">as</span> string) || <span class=\"hljs-string\">''</span>,\n      <span class=\"hljs-attr\">sort</span>: (search.<span class=\"hljs-property\">sort</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ProductSearchSortOptions</span>) || <span class=\"hljs-string\">'newest'</span>,\n    }\n  },\n})\n</code></pre>\n<h1>캐시를 이용한 데이터 로딩</h1>\n<p>TanStack Router는 SWR 캐싱이 가능한 기능을 제공하여 일반적인 로더 역할을 뛰어넘습니다. 이 기능을 통해 데이터를 사전로드하고 캐시된 데이터를 표시하거나 이전에 검색한 데이터를 캐시하고 다시 사용할 수 있습니다.</p>\n<h2>의존성 기반 Stale-While-Revalidate 캐싱</h2>\n<p>캐시는 경로 의존성에 의해 제어됩니다. 여기서 의존성은 다음과 같은 요소들입니다:</p>\n<ul>\n<li>라우트의 경로명\n/posts/1 대 /posts/2</li>\n<li>loaderDeps가 제공하는 추가적인 의존성\nloaderDeps: (' search: ' index, size ' ') =` (' index, size ')</li>\n</ul>\n<h2>캐시 제어</h2>\n<p>TanStack Router의 캐시는 TanStack Query와 비슷하며, TanStack Query에 익숙한 사람들은 학습 비용을 낮추면서 처리할 수 있습니다.</p>\n<p>staleTime</p>\n<ul>\n<li>캐시된 데이터가 오래되었다고 간주되기까지의 시간입니다. 기본값은 0입니다.</li>\n</ul>\n<p>gcTime</p>\n<ul>\n<li>사용되지 않은 캐시가 폐기되기까지의 시간입니다. 기본값은 30분입니다.</li>\n</ul>\n<h1>TanStack Query의 Suspense</h1>\n<p>지금까지 TanStack Router에 대해 이야기했지만, TanStack Query v5와 함께 안정화된 suspense 기능에 대해 설명하려고 합니다.</p>\n<p>일반 useQuery와 useSuspenseQuery의 주요 차이점은 이제 데이터가 정의되지 않은 상태에 대한 계산이 필요하지 않다는 것입니다.</p>\n<p>TanStack Query을 사용할 때, 데이터가 없을 경우 pendingComponent가 표시되고 오류가 발생할 경우 errorComponent가 표시되도록 구현했습니다. 아래 코드는 이를 예시로 보여줍니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Todos</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> query = <span class=\"hljs-title function_\">useQuery</span>({ <span class=\"hljs-attr\">queryKey</span>: [<span class=\"hljs-string\">'todos'</span>], <span class=\"hljs-attr\">queryFn</span>: getTodos })\n\n  <span class=\"hljs-keyword\">if</span> (query.<span class=\"hljs-property\">status</span> === <span class=\"hljs-string\">\"pending\"</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Pending</span> /></span></span>\n  }\n\n  <span class=\"hljs-keyword\">if</span> (query.<span class=\"hljs-property\">status</span> === <span class=\"hljs-string\">\"error\"</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Error</span> /></span></span>\n  }\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      할 일 목록\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  )\n}\n</code></pre>\n<p>그러나 useSuspenseQuery를 사용할 때는 데이터가 정의되지 않은 상태를 고려할 필요가 없으므로 코드가 다음과 같이 변경됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Todos</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> { data } = <span class=\"hljs-title function_\">useSuspenseQuery</span>({\n    <span class=\"hljs-attr\">queryKey</span>: [<span class=\"hljs-string\">'todos'</span>],\n    <span class=\"hljs-attr\">queryFn</span>: fetchTodos,\n  })\n\n  <span class=\"hljs-comment\">// 🎉 로딩 또는 오류 상태를 처리할 필요가 없습니다</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      { /* TypeScript가 데이터가 undefined일 수 없다는 것을 알고 있습니다 */ }\n      {data.map((todo) => (\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>{todo.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      ))}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  )\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// 🚀 경계(Boundaries)는 로딩 및 오류 상태를 처리합니다</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">div</span>></span>Loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>}>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ErrorBoundary</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">div</span>></span>On no!<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>}>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Todos</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ErrorBoundary</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Suspense</span>></span></span>\n  )\n}\n</code></pre>\n<p>이전에는 컴포넌트 자체에서 \"대기 중\" 및 \"오류\" 상태를 처리해야했습니다. 이제 이러한 과제를 별도로 관리할 수 있게 되었습니다.</p>\n<ul>\n<li>대기 중 상태: Suspense의 대기 중 대체(fallback)로 처리됩니다.</li>\n<li>오류 상태: ErrorBoundary의 대체(fallback)로 처리됩니다.</li>\n</ul>\n<p>일부 분들께서는 이러한 역할 분담의 분리가 TanStack Router의 파일 기반 접근 방식과 잘 맞는다는 것을 알아채셨을 것입니다. TanStack Router에서는 각 경로(route)별로 컴포넌트, 대기 중 컴포넌트(pendingComponent) 및 오류 컴포넌트(errorComponent)를 정의할 수 있었습니다.```</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// routes/posts.tsx</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createFileRoute</span>(<span class=\"hljs-string\">'/posts'</span>)({\n  component, <span class=\"hljs-comment\">// 성공</span>\n  errorComponent, <span class=\"hljs-comment\">// 오류</span>\n  pendingComponent, <span class=\"hljs-comment\">// 보류 중</span>\n})\n</code></pre>\n<p>이는 컴포넌트 내에서 사용되는 useSuspenseQuery의 보류 및 오류 상태 처리를 TanStack Router를 통해 경로별로 구성할 수 있다는 것을 의미합니다.</p>\n<h2>Loader 또는 TanStack Query를 사용해야 할까요?</h2>\n<p>TanStack Query의 suspense 기능이 TanStack Router와 호환되는 방법을 설명했습니다. 그러나 데이터 가져오기 관점에서는 TanStack Router의 로더를 사용하거나 SWR 캐싱 기능을 가진 TanStack Router를 사용하는 것도 가능합니다.</p>\n<p>그래서 그것들을 어떻게 구분하고 활용해야 할까요?</p>\n<p>공식 문서에서는 TanStack Router의 Cache의 장단점을 언급했습니다.</p>\n<p>TanStack Router Cache의 장점</p>\n<ul>\n<li>쉽게 사용할 수 있음</li>\n<li>경로별 중복 제거, 사전로딩, 로딩 처리를 가능하게 함</li>\n<li>자동으로 가비지 수집을 지원함</li>\n</ul>\n<p>TanStack Router Cache의 단점</p>\n<ul>\n<li>지속성을 위한 어댑터나 모델 없음</li>\n<li>라우트 간 캐시 공유 또는 중복 제거 기능 없음</li>\n<li>업데이트를 위한 API가 부족함</li>\n</ul>\n<p>로더는 대상 라우트와 관련이 있으며, 라우트 간에 캐시를 공유할 수 없습니다.</p>\n<p>따라서 응용 프로그램 상태 관리 도구로서의 TanStack Query의 존재가 필요하며, TanStack Router와 효과적으로 결합되어야 합니다.</p>\n<h2>캐시 데이터 미리 로딩</h2>\n<p>TanStack Router에는 미리 로딩하는 기능이 내장되어 있습니다. 예를 들어 사용자가 다른 화면으로 이동하려는 <code>Link</code>에 마우스를 가져가면 해당 경로에 필요한 데이터를 미리 로드합니다.</p>\n<p>이 기능은 매우 강력하며 TanStack Query와 결합하여 데이터 가져오기를 보다 효율적으로 만들어주고 때로는 폭포 모델 문제까지 해결할 수 있습니다.</p>\n<p>다음은 코드 예시입니다:</p>\n<p>TanStack Router의 로더를 사용하여 데이터를 미리 준비하고, TanStack Query의 캐시에 저장하세요. 그래서 useSuspenseQuery가 호출되는 시점에는 데이터가 이미 준비되어 있는 것이 보장됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/routes/posts.tsx</span>\n\n<span class=\"hljs-keyword\">const</span> postsQueryOptions = <span class=\"hljs-title function_\">queryOptions</span>({\n  <span class=\"hljs-attr\">queryKey</span>: <span class=\"hljs-string\">'posts'</span>,\n  <span class=\"hljs-attr\">queryFn</span>: <span class=\"hljs-function\">() =></span> fetchPosts,\n})\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createFileRoute</span>(<span class=\"hljs-string\">'/posts'</span>)({\n  <span class=\"hljs-comment\">// 데이터가 로드되도록 'loader' 옵션 사용</span>\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">() =></span> queryClient.<span class=\"hljs-title function_\">ensureQueryData</span>(postsQueryOptions),\n  <span class=\"hljs-attr\">component</span>: <span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-comment\">// 캐시에서 데이터를 읽고 업데이트에 구독합니다</span>\n    <span class=\"hljs-keyword\">const</span> posts = <span class=\"hljs-title function_\">useSuspenseQuery</span>(postsQueryOptions)\n\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n        {posts.map((post) => (\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Post</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{post.id}</span> <span class=\"hljs-attr\">post</span>=<span class=\"hljs-string\">{post}</span> /></span>\n        ))}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n    )\n  },\n})\n</code></pre>\n<p>TanStack Router의 로더를 사용하여 데이터를 미리 로드하고, TanStack Query의 useSuspenseQuery로 캐시된 데이터 상태를 관리하세요.</p>\n<h1>TanStack Router의 디렉터리 디자인</h1>\n<p>지금까지 TanStack 라우터의 기능과 TanStack 쿼리와의 호환성에 대해 논의해왔습니다. 마지막으로, TanStack 라우터의 디렉토리 구조를 소개하며 해당 특징과 장점에 대해 설명하겠습니다.</p>\n<p>다음은 디렉토리 구조입니다:</p>\n<pre><code class=\"hljs language-js\">.\n├── __root.<span class=\"hljs-property\">tsx</span> <span class=\"hljs-comment\">// 루트 파일</span>\n├── posts\n│   ├── -components <span class=\"hljs-comment\">// 🐢 경로 내부에서 사용되는 UI 구성 요소</span>\n│   ├── -api <span class=\"hljs-comment\">// 🦋 경로 내부에서 사용되는 API 통신 훅</span>\n│   ├── -types <span class=\"hljs-comment\">// 🐠 경로 내부에서 사용되는 타입 정의</span>\n│   ├── -functions <span class=\"hljs-comment\">// 🦐 경로 내부에서 사용되는 함수</span>\n│   ├── route.<span class=\"hljs-property\">lazy</span>.<span class=\"hljs-property\">tsx</span> <span class=\"hljs-comment\">// 🐕 지연 로드 라우트</span>\n│   ├── route.<span class=\"hljs-property\">tsx</span> <span class=\"hljs-comment\">// 🦈 주요 라우트</span>\n│   └── $postId <span class=\"hljs-comment\">// /posts와 유사</span>\n│       ├── -components\n│       ├── -api\n│       ├── -types\n│       ├── -functions\n│       ├── route.<span class=\"hljs-property\">lazy</span>.<span class=\"hljs-property\">tsx</span>\n│       └── route.<span class=\"hljs-property\">tsx</span>\n</code></pre>\n<h2>특징 1: 특징 기반 디렉토리 구조</h2>\n<p>제공된 예시에서 각 라우트는 다음과 같은 디렉토리를 포함하고 있어요:</p>\n<ul>\n<li>-components: 해당 라우트 내에서 사용하는 UI 구성 요소들이 들어 있어요.</li>\n<li>-api: 해당 라우트 내에서 사용하는 API 통신에 사용되는 후크들이 들어 있어요. 여기에는 TanStack Query와 같은 API가 활용돼요.</li>\n<li>-types: 해당 라우트 내에서 사용하는 타입 정의들이 들어 있어요.</li>\n<li>-functions: 해당 라우트 내에서 사용되는 함수들이 들어 있어요. 각 함수는 자체 단위 테스트가 구현될 수도 있어요.</li>\n</ul>\n<p>이 접근 방식을 통해, 디렉토리인 components나 api와 같은 레이어 기반 접근 방식과는 달리 기능 기반 디자인이 가능해져요.</p>\n<p>물론, 모든 기능이 직접적으로 라우트에 해당하는 것은 아닐 거예요. 그런 경우에는 관련된 관심사를 그룹화하기 위해 _접두사를 사용하는 것이 효과적일 수 있어요.</p>\n<h2>기능 2: 라우트 훅 사용을 특정 라우트에 제한</h2>\n<p>TanStack Router에서는 각 특정 라우트에 대응하는 Route Hooks를 사용하여 경로 매개변수와 검색 매개변수를 안전하게 처리할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title function_\">createFileRoute</span>(<span class=\"hljs-string\">'/posts/$postId'</span>)({\n  <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">PostComponent</span>,\n})\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">PostComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> { postId } = <span class=\"hljs-title class_\">Route</span>.<span class=\"hljs-title function_\">useParams</span>()\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>포스트 {postId}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n}\n</code></pre>\n<p>위와 같은 디렉토리 디자인으로 캡슐화된 라우트 내에서 사용되는 컴포넌트들이 있을 때, /posts 하위의 라우트에 대해 /posts에 특화된 Route Hooks가 사용됨을 명확하게 알 수 있습니다.</p>\n<pre><code class=\"hljs language-md\">.\n├── pages\n├── components\n│   ├── Post.tsx // 해당 컴포넌트 라우트 훅을 사용하나요?\n│   ├── Todo.tsx // 해당 컴포넌트 라우트 훅을 사용하나요?\n│   ├── Form.tsx // ???\n│   └── Card.tsx // ???\n</code></pre>\n<p>아주 극단적인 예시라고 하더라도, 컴포넌트가 최상위 계층에 배치된 디자인에서는 어떤 라우트 훅이 어디에 사용되고 있는지를 구분하는 것이 어렵습니다.</p>\n<p>특집 기반의 디자인에 초점을 맞추면, 특정 라우트 내에서 사용되는 컴포넌트만을 고려하게 됩니다.</p>\n<pre><code class=\"hljs language-md\">.\n├── posts\n│   ├── -components // /posts 라우트 훅이 사용됨\n│   │   ├── Card.tsx\n│   │   └── Form.tsx\n│   └── $postId \n│       └── -components // /posts/$postId 라우트 훅이 사용됨\n</code></pre>\n<h2>기능 3: Suspense를 위한 명확한 경계</h2>\n<p>TanStack Query의 useSuspenseQuery를 사용하면 보류 및 오류 상태에 대한 문제를 외부화하여 컴포넌트 측이 데이터가 정의되지 않은 경우를 예상할 필요가 없어집니다.</p>\n<p>TanStack Router와 잘 어울린다고 언급한 이유 중 하나는 각 라우트마다 pendingComponent 및 errorComponent를 정의할 수 있으므로 사용자 정의 Suspense 경계를 정의할 필요가 없다는 것입니다.</p>\n<p>더 많은 정보를 원한다면 TanStack Router 문서에 게시된 샘플을 참조해주세요.</p>\n<p>위의 이미지에서 빨간색과 파란색 프레임으로 표시된 Suspense 바운더리가 있습니다. 이는 파란 프레임 내에서 발생하는 보류 및 오류 상태가 /post/$postId 경로에 정의된 처리에 의해 처리되는 반면 빨간 프레임 내에서 발생하는 상태는 /posts 경로에 정의된 처리에 의해 처리된다는 것을 의미합니다.</p>\n<p>(아래는 실제 코드 예시입니다.)</p>\n<h1>요약</h1>\n<p>이번 세션에서는 TanStack Router의 기능과 TanStack Query와의 호환성, 그리고 디렉토리 디자인을 소개했습니다. Next.js와 Remix와 같은 프레임워크의 발전은 놀라운데, React를 사용하여 Single Page Applications (SPAs)을 개발하는 도중에 완전히 해결되지 않은 어려움이 있었다는 느낌이 있었습니다.</p>\n<p>그러나 이번에 소개된 TanStack Router의 파일 기반 및 높은 개발 경험(DX) 접근 방식은 React 라이브러리 선택 시 효과적인 선택일 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}