{"pageProps":{"post":{"title":"NextAuth v5를 사용한 보호된 라우팅 구현하기","description":"","date":"2024-05-14 11:21","slug":"2024-05-14-ImplementingProtectedRoutingwithNextAuthv5","content":"\n\n![이미지](/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png)\n\n이 글에서는 Next.js 애플리케이션에서 NextAuth v5를 사용하여 클라이언트 측 및 서버 측 경로를 보호하는 방법을 알려드릴 거에요.\n\nNextAuth.js는 Next.js 애플리케이션에서 널리 사용되는 인증 라이브러리로, 버전 5가 출시되면서 여러 가지 주목할만한 개선 사항과 변경 사항이 소개되었어요. 이 최신 버전에서 중요한 업데이트 중 하나는 미들웨어 시스템에서 관찰되어요. 미들웨어 API가 향상되어 인증 흐름과 접근 제어에 대해 더 많은 유연성과 제어를 제공하고 있어요.\n\n그럼 시작해봅시다!\n\n\n\n## 단계 1 — 새로운 Next.js 프로젝트를 생성하고 필요한 패키지 설치하기\n\n이 글에서는 Next.js 애플리케이션을 만드는 방법에 대해 자세히 다루지는 않겠지만, nextAuth를 사용하기 위해서는 최신 버전이 필요합니다.\n\n```js\nnpm install --save next-auth\n```\n\n<img src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_1.png\" />\n\n\n\n## 단계 2— 애플리케이션 내에 nextAuth 제공자 설정하기\n\n이 예제에서는 Google을 인증 제공자로 사용할 것입니다. 이제 Next 앱 내에 \"services\"라는 새 폴더를 만들고 그 안에 auth.ts라는 새 파일을 생성하세요. 파일을 만든 후 아래 코드를 추가하세요.\n\n```js\nimport NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\n\nexport const {\n  handlers: { GET, POST },\n  auth\n} = NextAuth({\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_ID as string,\n      clientSecret: process.env.GOOGLE_SECRET as string\n    })\n  ],\n  pages: {\n    signIn: '/login'\n  }\n});\n```\n\n반드시 .env 파일을 만들어서 google 클라이언트 ID와 clientSecret를 추가해주세요.\n\n\n\n다음으로, Next 앱 내에서 api 디렉토리(페이지 디렉토리 내부) 안에 새 폴더를 만들어주세요. 폴더의 이름은 `auth`로 지어주세요. 그 폴더 안에 `...nextAuth`(대소문자 구분 필수)라는 폴더를 만들고, 그 안에 `route.ts` 파일을 생성해주세요.\n\n<img src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_2.png\" />\n\n해당 파일을 생성한 후, 아래 코드를 추가해주세요.\n\n```js\nexport { GET, POST } from '../../../../services/auth';\nexport const runtime = 'edge';\n```\n\n\n\n이제 제공자 설정이 모두 끝났으니, useContext API와 유사하게 전체 앱에 인증 상태를 제공하는 다른 컴포넌트를 사용하여 모든 구성 요소와 라우트를 감싸는 작업을 진행해 보겠습니다.\nrootlayout.ts 파일 내에서 세션 제공자(SessionProvider)를 사용하여 컴포넌트를 감싸세요.\n\n```js\nimport './globals.css';\n\nimport Navbar from '../components/nav-bar/navbar';\nimport { SessionProvider } from 'next-auth/react';\n\nexport default function RootLayout({\n  children\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\" className=\"h-full\">\n      <body className=\"h-full flex flex-col\">\n          <SessionProvider>\n            <Navbar />\n            <main className=\"flex-1\">{children}</main>\n          </SessionProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n## 단계 3 — 모든 signIn 및 signOut 함수 구현\n\n그런 다음 nextAuth를 사용하여 모든 signIn 및 signOut 함수를 구현해야 합니다. 그러나 이 문서에서는 해당 함수를 구현하지 않겠습니다. 필요한 라우트를 보호하는 방법만 안내해 드리겠습니다.\n\n\n\n## 단계 4 — 클라이언트 측과 서버 측 라우트를 보호하는 미들웨어 생성\n\n이 접근 방식에서는 클라이언트 측과 서버 측 라우트를 보호하기 위해 미들웨어를 사용할 것입니다. 먼저 src 폴더 안에 middleware.ts라는 새 파일을 만들고 다음 코드를 추가해주세요.\n\n<img src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_3.png\" />\n\n```js\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nconst protectedRoutes = [\n  '/dashboard',\n  '/profile',\n];\nconst unprotectedRoutes = ['/', '/login'];\n\nimport { auth } from './services/auth';\n\nexport default async function middleware(request: NextRequest) {\n  const session = await auth();\n\n  const isProtectedRoute = protectedRoutes.some((prefix) =>\n    request.nextUrl.pathname.startsWith(prefix)\n  );\n\n  if (!session && isProtectedRoute) {\n    const absoluteURL = new URL('/', request.nextUrl.origin);\n    return NextResponse.redirect(absoluteURL.toString());\n  }\n  if (session && unprotectedRoutes.includes(request.nextUrl.pathname)) {\n    const absoluteURL = new URL('/dashboard', request.nextUrl.origin);\n    return NextResponse.redirect(absoluteURL.toString());\n  }\n}\n```\n\n\n\n해당 코드에는 \"protectedRoutes\"와 \"unprotectedRoutes\"라우트가 몇 개 있습니다. 다음 js 애플리케이션에서 라우트를 보호하려면 이 배열에서 원하는 라우트를 추가하거나 제거할 수 있습니다.\n\n전체 문서를 보려면 방문해주세요.\n세미콜론 — 기술 블로그 (semicolon-blog.vercel.app)\n\n우리는 클라이언트 측과 서버 측 라우트를 성공적으로 보호했다고 생각합니다. 감사합니다! 👏👏👏","ogImage":{"url":"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png\" alt=\"이미지\"></p>\n<p>이 글에서는 Next.js 애플리케이션에서 NextAuth v5를 사용하여 클라이언트 측 및 서버 측 경로를 보호하는 방법을 알려드릴 거에요.</p>\n<p>NextAuth.js는 Next.js 애플리케이션에서 널리 사용되는 인증 라이브러리로, 버전 5가 출시되면서 여러 가지 주목할만한 개선 사항과 변경 사항이 소개되었어요. 이 최신 버전에서 중요한 업데이트 중 하나는 미들웨어 시스템에서 관찰되어요. 미들웨어 API가 향상되어 인증 흐름과 접근 제어에 대해 더 많은 유연성과 제어를 제공하고 있어요.</p>\n<p>그럼 시작해봅시다!</p>\n<h2>단계 1 — 새로운 Next.js 프로젝트를 생성하고 필요한 패키지 설치하기</h2>\n<p>이 글에서는 Next.js 애플리케이션을 만드는 방법에 대해 자세히 다루지는 않겠지만, nextAuth를 사용하기 위해서는 최신 버전이 필요합니다.</p>\n<pre><code class=\"hljs language-js\">npm install --save next-auth\n</code></pre>\n<h2>단계 2— 애플리케이션 내에 nextAuth 제공자 설정하기</h2>\n<p>이 예제에서는 Google을 인증 제공자로 사용할 것입니다. 이제 Next 앱 내에 \"services\"라는 새 폴더를 만들고 그 안에 auth.ts라는 새 파일을 생성하세요. 파일을 만든 후 아래 코드를 추가하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">NextAuth</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next-auth'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">GoogleProvider</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next-auth/providers/google'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> {\n  <span class=\"hljs-attr\">handlers</span>: { <span class=\"hljs-variable constant_\">GET</span>, <span class=\"hljs-variable constant_\">POST</span> },\n  auth\n} = <span class=\"hljs-title class_\">NextAuth</span>({\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title class_\">GoogleProvider</span>({\n      <span class=\"hljs-attr\">clientId</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">GOOGLE_ID</span> <span class=\"hljs-keyword\">as</span> string,\n      <span class=\"hljs-attr\">clientSecret</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">GOOGLE_SECRET</span> <span class=\"hljs-keyword\">as</span> string\n    })\n  ],\n  <span class=\"hljs-attr\">pages</span>: {\n    <span class=\"hljs-attr\">signIn</span>: <span class=\"hljs-string\">'/login'</span>\n  }\n});\n</code></pre>\n<p>반드시 .env 파일을 만들어서 google 클라이언트 ID와 clientSecret를 추가해주세요.</p>\n<p>다음으로, Next 앱 내에서 api 디렉토리(페이지 디렉토리 내부) 안에 새 폴더를 만들어주세요. 폴더의 이름은 <code>auth</code>로 지어주세요. 그 폴더 안에 <code>...nextAuth</code>(대소문자 구분 필수)라는 폴더를 만들고, 그 안에 <code>route.ts</code> 파일을 생성해주세요.</p>\n<p>해당 파일을 생성한 후, 아래 코드를 추가해주세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> { <span class=\"hljs-variable constant_\">GET</span>, <span class=\"hljs-variable constant_\">POST</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../../../../services/auth'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> runtime = <span class=\"hljs-string\">'edge'</span>;\n</code></pre>\n<p>이제 제공자 설정이 모두 끝났으니, useContext API와 유사하게 전체 앱에 인증 상태를 제공하는 다른 컴포넌트를 사용하여 모든 구성 요소와 라우트를 감싸는 작업을 진행해 보겠습니다.\nrootlayout.ts 파일 내에서 세션 제공자(SessionProvider)를 사용하여 컴포넌트를 감싸세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'./globals.css'</span>;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Navbar</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../components/nav-bar/navbar'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">SessionProvider</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next-auth/react'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">RootLayout</span>(<span class=\"hljs-params\">{\n  children\n}: {\n  children: React.ReactNode;\n}</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"h-full\"</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">body</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"h-full flex flex-col\"</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">SessionProvider</span>></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Navbar</span> /></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">main</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"flex-1\"</span>></span>{children}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">main</span>></span>\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">SessionProvider</span>></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">body</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">html</span>></span></span>\n  );\n}\n</code></pre>\n<h2>단계 3 — 모든 signIn 및 signOut 함수 구현</h2>\n<p>그런 다음 nextAuth를 사용하여 모든 signIn 및 signOut 함수를 구현해야 합니다. 그러나 이 문서에서는 해당 함수를 구현하지 않겠습니다. 필요한 라우트를 보호하는 방법만 안내해 드리겠습니다.</p>\n<h2>단계 4 — 클라이언트 측과 서버 측 라우트를 보호하는 미들웨어 생성</h2>\n<p>이 접근 방식에서는 클라이언트 측과 서버 측 라우트를 보호하기 위해 미들웨어를 사용할 것입니다. 먼저 src 폴더 안에 middleware.ts라는 새 파일을 만들고 다음 코드를 추가해주세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">NextResponse</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/server'</span>;\n<span class=\"hljs-keyword\">import</span> type { <span class=\"hljs-title class_\">NextRequest</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/server'</span>;\n\n<span class=\"hljs-keyword\">const</span> protectedRoutes = [\n  <span class=\"hljs-string\">'/dashboard'</span>,\n  <span class=\"hljs-string\">'/profile'</span>,\n];\n<span class=\"hljs-keyword\">const</span> unprotectedRoutes = [<span class=\"hljs-string\">'/'</span>, <span class=\"hljs-string\">'/login'</span>];\n\n<span class=\"hljs-keyword\">import</span> { auth } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./services/auth'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">middleware</span>(<span class=\"hljs-params\">request: NextRequest</span>) {\n  <span class=\"hljs-keyword\">const</span> session = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">auth</span>();\n\n  <span class=\"hljs-keyword\">const</span> isProtectedRoute = protectedRoutes.<span class=\"hljs-title function_\">some</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">prefix</span>) =></span>\n    request.<span class=\"hljs-property\">nextUrl</span>.<span class=\"hljs-property\">pathname</span>.<span class=\"hljs-title function_\">startsWith</span>(prefix)\n  );\n\n  <span class=\"hljs-keyword\">if</span> (!session &#x26;&#x26; isProtectedRoute) {\n    <span class=\"hljs-keyword\">const</span> absoluteURL = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-string\">'/'</span>, request.<span class=\"hljs-property\">nextUrl</span>.<span class=\"hljs-property\">origin</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">redirect</span>(absoluteURL.<span class=\"hljs-title function_\">toString</span>());\n  }\n  <span class=\"hljs-keyword\">if</span> (session &#x26;&#x26; unprotectedRoutes.<span class=\"hljs-title function_\">includes</span>(request.<span class=\"hljs-property\">nextUrl</span>.<span class=\"hljs-property\">pathname</span>)) {\n    <span class=\"hljs-keyword\">const</span> absoluteURL = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-string\">'/dashboard'</span>, request.<span class=\"hljs-property\">nextUrl</span>.<span class=\"hljs-property\">origin</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">redirect</span>(absoluteURL.<span class=\"hljs-title function_\">toString</span>());\n  }\n}\n</code></pre>\n<p>해당 코드에는 \"protectedRoutes\"와 \"unprotectedRoutes\"라우트가 몇 개 있습니다. 다음 js 애플리케이션에서 라우트를 보호하려면 이 배열에서 원하는 라우트를 추가하거나 제거할 수 있습니다.</p>\n<p>전체 문서를 보려면 방문해주세요.\n세미콜론 — 기술 블로그 (semicolon-blog.vercel.app)</p>\n<p>우리는 클라이언트 측과 서버 측 라우트를 성공적으로 보호했다고 생각합니다. 감사합니다! 👏👏👏</p>\n</body>\n</html>\n"},"__N_SSG":true}