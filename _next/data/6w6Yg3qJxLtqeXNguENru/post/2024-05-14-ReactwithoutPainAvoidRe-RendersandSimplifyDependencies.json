{"pageProps":{"post":{"title":"고통 없는 리액트 다시 렌더링 피하기와 의존성 간소화하기","description":"","date":"2024-05-14 14:04","slug":"2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies","content":"\n\n\n![React without Pain: Avoid Re-Renders and Simplify Dependencies](/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png)\n\nReact에서 다시 렌더링을 추적하는 것은 고통스러운 과정일 수 있습니다. Fine-grain 반응성 패턴은 이 문제를 완전히 제거하는 해결책을 제공하여 React 엔지니어가 종속성을 추적하는 것을 잊고 코드 작성에 집중할 수 있게 합니다. 이 기사에서는 라이브러리 Mlyn이 종속성 관리를 간단하게 하고 React 애플리케이션에서 불필요한 다시 렌더링을 방지하는 방법을 살펴보겠습니다.\n\n# 종속성 관리: 공통 문제\n\n기존의 React 애플리케이션에서 상태와 종속성을 관리하는 것은 종종 복잡하고 오류가 발생하기 쉬운 코드로 이어질 수 있습니다. 이 문제를 설명하기 위해 간단한 카운터 예제를 살펴보겠습니다.\n\n\n\n\n# 전통적인 리액트 예제\n\n```js\nimport React, { useState, useCallback } from \"react\";\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  const onIncrement = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, [count]); // count에 의존\n  return (\n    <div>\n      <h1>카운트: {count}</h1>\n      <button onClick={onIncrement}>증가</button>\n    </div>\n  );\n};\nexport default Counter;\n```\n\n# 의존성 문제\n\n이 예제에서 onIncrement 함수는 count를 의존성으로 하는 useCallback으로 래핑되어 있습니다. count가 변경될 때마다 onIncrement가 다시 생성됩니다.\n\n\n\n# Mlyn과 함께 간단하게\n\nMlyn은 세부적인 반응성을 소개하여 의존성을 걱정하지 않고 상태 업데이트를 관리할 수 있습니다. Mlyn을 사용하여 동일한 예제를 다시 작성해 봅시다.\n\n# Mlyn 예제\n\n```js\nimport React, { useCallback } from \"react\";\nimport { rc, useSubject } from \"mlyn/react\";\nconst Counter = rc(() => {\n  const state = useSubject({ count: 0 });\n  const increment = useCallback(() => {\n    state.count(state.count() + 1);\n  }, []);\n  return (\n    <div>\n      <h1>Count: {state.count()}</h1>\n      <button onClick={onIncrement}>Increment</button>\n    </div>\n  );\n});\n\nexport default Counter;\n```  \n\n\n\nstate.count의 참조가 변경되지 않기 때문에 useCallback에서 해당 값을 다시 만들지 않고도 읽을 수 있습니다.\n\n# 정교한 Reactivity의 장점\n\n- Stable Callbacks: Mlyn의 onIncrement 함수는 state.count를 의존성으로 필요로하지 않습니다. 이러한 안정성은 함수의 불필요한 재생성을 방지합니다. 그리고 onIncrement의 소비자들은 count가 변경되어도 다시 렌더링되지 않습니다.\n- 단순화된 코드: Mlyn을 사용하면 종속성을 수동으로 추적할 필요가 없습니다.\n\n# IncrementButton 추출: 다시 렌더링에 대한 더 깊은 이해\n\n\n\nLet’s extract the increment button into theIncrementButton component to understand how Mlyn’s approach prevents unnecessary re-renders.\n\n# Traditional React: Re-Rendering Issue\n\nIn the traditional example, IncrementButton re-renders every time count changes because increment is a new function reference each time.\n\n```js\nconst IncrementButton = React.memo(({ onIncrement }) => {\n  console.log(\"IncrementButton re-rendered\");\n  return (\n    <div>\n      <button onClick={onIncrement}>Increment from Child</button>\n    </div>\n  );\n});\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  const onIncrement = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, [count]); // Dependency on count\n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <IncrementButton onIncrement={onIncrement} />\n    </div>\n  );\n};\n```\n\n\n\n# Mlyn: 불필요한 다시 렌더링 방지\n\nMlyn을 사용하면 onIncrement가 동일한 참조로 유지되어 IncrementButton이 불필요하게 다시 렌더링되지 않습니다. 이것은 섬세한 용량으로 반응하는 주요 장점입니다.\n\n# 예제 재방문\n\n```js\nconst Counter = rc(() => {\n  const state = useSubject({ count: 0 });\n  const onIncrement = useCallback(() => {\n    state.count(state.count() + 1); // 어떤 종속성도 필요하지 않습니다\n  }, []);\n  return (\n    <div>\n      <h1>Count: {state.count()}</h1>\n      <IncrementButton onIncrement={onIncrement} />\n    </div>\n  );\n});\n```\n\n\n\n# 개요\n\nMlyn의 섬세한 리액티브는 상태 관리를 간단하게 만들어 줍니다:\n\n- 의존성 추적이 필요 없어집니다: 수동으로 종속성을 업데이트할 필요 없이 더 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n- 불필요한 다시 렌더링 방지: 컴포넌트는 실제 상태나 프롭이 변경될 때만 다시 렌더링되어 성능과 효율성을 향상시킵니다.\n\nMlyn을 도입함으로써, React 엔지니어는 복잡한 상태 종속성을 관리하는 귀찮음 없이 기능이 풍부한 코드 작성에 집중할 수 있습니다. 다음 프로젝트에 Mlyn을 통합해보고 섬세한 리액티브의 편리함을 경험해보세요!\n\n\n\nmlyn에 관심이 있다면, GitHub에서 확인해보세요: [https://github.com/vaukalak/mlyn](https://github.com/vaukalak/mlyn)","ogImage":{"url":"/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png"},"coverImage":"/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png\" alt=\"React without Pain: Avoid Re-Renders and Simplify Dependencies\"></p>\n<p>React에서 다시 렌더링을 추적하는 것은 고통스러운 과정일 수 있습니다. Fine-grain 반응성 패턴은 이 문제를 완전히 제거하는 해결책을 제공하여 React 엔지니어가 종속성을 추적하는 것을 잊고 코드 작성에 집중할 수 있게 합니다. 이 기사에서는 라이브러리 Mlyn이 종속성 관리를 간단하게 하고 React 애플리케이션에서 불필요한 다시 렌더링을 방지하는 방법을 살펴보겠습니다.</p>\n<h1>종속성 관리: 공통 문제</h1>\n<p>기존의 React 애플리케이션에서 상태와 종속성을 관리하는 것은 종종 복잡하고 오류가 발생하기 쉬운 코드로 이어질 수 있습니다. 이 문제를 설명하기 위해 간단한 카운터 예제를 살펴보겠습니다.</p>\n<h1>전통적인 리액트 예제</h1>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useState, useCallback } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Counter</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> onIncrement = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">prevCount</span> =></span> prevCount + <span class=\"hljs-number\">1</span>);\n  }, [count]); <span class=\"hljs-comment\">// count에 의존</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>카운트: {count}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onIncrement}</span>></span>증가<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n};\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Counter</span>;\n</code></pre>\n<h1>의존성 문제</h1>\n<p>이 예제에서 onIncrement 함수는 count를 의존성으로 하는 useCallback으로 래핑되어 있습니다. count가 변경될 때마다 onIncrement가 다시 생성됩니다.</p>\n<h1>Mlyn과 함께 간단하게</h1>\n<p>Mlyn은 세부적인 반응성을 소개하여 의존성을 걱정하지 않고 상태 업데이트를 관리할 수 있습니다. Mlyn을 사용하여 동일한 예제를 다시 작성해 봅시다.</p>\n<h1>Mlyn 예제</h1>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useCallback } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> { rc, useSubject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"mlyn/react\"</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Counter</span> = <span class=\"hljs-title function_\">rc</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> state = <span class=\"hljs-title function_\">useSubject</span>({ <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span> });\n  <span class=\"hljs-keyword\">const</span> increment = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =></span> {\n    state.<span class=\"hljs-title function_\">count</span>(state.<span class=\"hljs-title function_\">count</span>() + <span class=\"hljs-number\">1</span>);\n  }, []);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>Count: {state.count()}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onIncrement}</span>></span>Increment<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n});\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Counter</span>;\n</code></pre>\n<p>state.count의 참조가 변경되지 않기 때문에 useCallback에서 해당 값을 다시 만들지 않고도 읽을 수 있습니다.</p>\n<h1>정교한 Reactivity의 장점</h1>\n<ul>\n<li>Stable Callbacks: Mlyn의 onIncrement 함수는 state.count를 의존성으로 필요로하지 않습니다. 이러한 안정성은 함수의 불필요한 재생성을 방지합니다. 그리고 onIncrement의 소비자들은 count가 변경되어도 다시 렌더링되지 않습니다.</li>\n<li>단순화된 코드: Mlyn을 사용하면 종속성을 수동으로 추적할 필요가 없습니다.</li>\n</ul>\n<h1>IncrementButton 추출: 다시 렌더링에 대한 더 깊은 이해</h1>\n<p>Let’s extract the increment button into theIncrementButton component to understand how Mlyn’s approach prevents unnecessary re-renders.</p>\n<h1>Traditional React: Re-Rendering Issue</h1>\n<p>In the traditional example, IncrementButton re-renders every time count changes because increment is a new function reference each time.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">IncrementButton</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">memo</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ onIncrement }</span>) =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"IncrementButton re-rendered\"</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onIncrement}</span>></span>Increment from Child<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n});\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Counter</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> onIncrement = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">prevCount</span> =></span> prevCount + <span class=\"hljs-number\">1</span>);\n  }, [count]); <span class=\"hljs-comment\">// Dependency on count</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>Count: {count}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">IncrementButton</span> <span class=\"hljs-attr\">onIncrement</span>=<span class=\"hljs-string\">{onIncrement}</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n};\n</code></pre>\n<h1>Mlyn: 불필요한 다시 렌더링 방지</h1>\n<p>Mlyn을 사용하면 onIncrement가 동일한 참조로 유지되어 IncrementButton이 불필요하게 다시 렌더링되지 않습니다. 이것은 섬세한 용량으로 반응하는 주요 장점입니다.</p>\n<h1>예제 재방문</h1>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Counter</span> = <span class=\"hljs-title function_\">rc</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> state = <span class=\"hljs-title function_\">useSubject</span>({ <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span> });\n  <span class=\"hljs-keyword\">const</span> onIncrement = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =></span> {\n    state.<span class=\"hljs-title function_\">count</span>(state.<span class=\"hljs-title function_\">count</span>() + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 어떤 종속성도 필요하지 않습니다</span>\n  }, []);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>Count: {state.count()}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">IncrementButton</span> <span class=\"hljs-attr\">onIncrement</span>=<span class=\"hljs-string\">{onIncrement}</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n});\n</code></pre>\n<h1>개요</h1>\n<p>Mlyn의 섬세한 리액티브는 상태 관리를 간단하게 만들어 줍니다:</p>\n<ul>\n<li>의존성 추적이 필요 없어집니다: 수동으로 종속성을 업데이트할 필요 없이 더 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.</li>\n<li>불필요한 다시 렌더링 방지: 컴포넌트는 실제 상태나 프롭이 변경될 때만 다시 렌더링되어 성능과 효율성을 향상시킵니다.</li>\n</ul>\n<p>Mlyn을 도입함으로써, React 엔지니어는 복잡한 상태 종속성을 관리하는 귀찮음 없이 기능이 풍부한 코드 작성에 집중할 수 있습니다. 다음 프로젝트에 Mlyn을 통합해보고 섬세한 리액티브의 편리함을 경험해보세요!</p>\n<p>mlyn에 관심이 있다면, GitHub에서 확인해보세요: <a href=\"https://github.com/vaukalak/mlyn\" rel=\"nofollow\" target=\"_blank\">https://github.com/vaukalak/mlyn</a></p>\n</body>\n</html>\n"},"__N_SSG":true}