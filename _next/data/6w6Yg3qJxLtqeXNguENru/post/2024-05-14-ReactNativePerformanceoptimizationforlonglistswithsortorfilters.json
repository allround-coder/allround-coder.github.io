{"pageProps":{"post":{"title":"React Native 정렬 또는 필터가 있는 긴 목록의 성능 최적화","description":"","date":"2024-05-14 10:33","slug":"2024-05-14-ReactNativePerformanceoptimizationforlonglistswithsortorfilters","content":"\n\nReact Native에서 긴 요소 목록을 다루는 것은 꽤 도전적일 수 있어요. RN 문서에서는 FlatList를 사용하는 것을 권장하지만, 제공된 예제는 종종 방대한 목록이나 필터 적용 및 목록 정렬과 같은 시나리오를 다루지 않아서 많은 애플리케이션에서 필수적인 요구 사항들을 보여주지 못합니다.\n\n# 예시와 관찰\n\nRN 문서의 성능에 따른 가이드에 따라 매우 간단한 사용자 인터페이스를 갖춘 새로운 React Native 프로젝트를 만들어 보겠습니다. 우리는 이 인터페이스를 따라 MOCK 데이터셋을 만들었습니다. 이 데이터셋은 다음 인터페이스를 따르는 500개의 제품 항목이 있어요:\n\n```js\ninterface Item {\n id: number\n name: string\n expiration_date: string\n qty: number\n}\n```\n\n\n\n그럼, 헤더와 두 개의 버튼이 있는 FlatList를 구현했습니다. 하나의 버튼은 ID가 가장 높은 순서대로 목록을 정렬하고, 다른 하나는 ID가 가장 낮은 순서대로 정렬합니다.\n\n```js\nexport const List = () => {\n  const [orderBy, setOrderBy] = useState<'normal' | 'reverse'>('normal');\n\n  const renderListItem = useCallback(({item, index}: {item: Item; index: number}) => {\n    return <ListItem item={item} index={index} />;\n  }, []);\n\n  const ListHeaderComponent = useCallback(() => {\n    return (\n      <Header\n        title={'Order by'}\n        onPressButton1={() => {\n          setOrderBy('normal');\n        }}\n        onPressButton2={() => {\n          setOrderBy('reverse');\n        }}\n      />\n    );\n  }, []);\n\n  const orderedData = useMemo(() => {\n    return orderBy === 'normal'\n      ? mockData.data.sort((a, b) => a.id - b.id)\n      : mockData.data.sort((a, b) => b.id - a.id);\n  }, [orderBy]);\n\n  return (\n    <>\n      <FlatList\n        ListHeaderComponent={ListHeaderComponent}\n        keyExtractor={({id}) => id.toString()}\n        renderItem={renderListItem}\n        data={orderedData}\n        stickyHeaderIndices={[0]}\n      />\n    </>\n  );\n}\n```\n\nListItem 컴포넌트를 메모이즈하여 불필요한 다시 렌더링을 피했습니다. 인덱스에 따라 배경색이 결정되며, 동작을 이해하기 위해 인덱스를 기록하고 있습니다.\n\n```js\nexport const ListItem = memo(({item, index}: {item: Item; index: number}) => {\n  const backgroundColor = item.id % 2 === 0 ? '#red' : 'pink';\n\n  console.log(index);\n  return (\n    <View\n      style={{\n        ...styles.container,\n        backgroundColor,\n      }}>\n      <Text>\n        {item.name} - {item.id}\n      </Text>\n    </View>\n  );\n})\n```\n\n\n\nFlatList은 동작을 이해하고 문제를 해결하는 데 도움이 되는 세 가지 중요한 속성을 제공합니다:\n\n- initialNumToRender: 초기 배치에서 렌더링할 아이템 수를 결정하며, 화면을 채우되 과도하게 많이 렌더링하지 않아야 합니다.\n- maxToRenderPerBatch: 각 증분 렌더 배치에서 렌더링할 최대 아이템 수를 지정합니다.\n- updateCellsBatchingPeriod: 배치 렌더 사이의 밀리초 단위 지연 시간을 설정합니다.\n\n예를 들어, initialNumToRender=10, maxToRenderPerBatch=10, updateCellsBatchingPeriod=10으로 설정하면, 리스트는 초기 10개 아이템을 먼저 렌더링한 다음, 10ms마다 10개씩 더 추가하여 완료될 때까지 부드럽게 렌더링되며, JS 스레드를 차단하지 않습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*okgjSFX3jUmN-5CM2dAESw.gif)\n\n\n\n리스트를 스크롤하는 동안 추가 항목이 배경에서 완료될 때까지 렌더링됩니다.\n\n![scrolling](https://miro.medium.com/v2/resize:fit:1200/1*cDzV6w7LguahgYZ4ywfQig.gif)\n\n그러나 목록을 정렬할 때 예상대로 동작하지 않습니다.\n\n![sorting](https://miro.medium.com/v2/resize:fit:1200/1*a4yZcj1iJYYel3tllSJqEw.gif)\n\n\n\nRN의 가이드라인을 따라 FlatList 성능을 향상시키려고 노력했지만, 목록이 예상대로 동작하지 않았어요. 그러나 성능을 향상시키는 것으로 보이는 잠재적인 해결책을 고안해 냈어요.\n\n주문 상태가 변경될 때마다 리스트의 다시 마운트를 트리거할 수 있도록 키를 사용함으로써, 초기 마운트 과정을 완료될 때까지 JS 스레드를 차단하지 않고 효율적으로 진행할 수 있어요.\n\n```js\n<FlatList\n    key={orderBy}\n    ...나머지 초기 속성\n/>\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*yLeRxhhh2BRKBJ2MBERS5Q.gif)\n\n\n\n행동을 더 잘 이해하기 위해 initialNumToRender=20, maxToRenderPerBatch=1 및 updateCellsBatchingPeriod=500으로 설정합니다.\n\n![이미지1](https://miro.medium.com/v2/resize:fit:1200/1*1JSiEZjP8PLNiP8I2OEvVw.gif)\n\n그러나 키가 삭제되면 어떻게 되나요?\n\n![이미지2](https://miro.medium.com/v2/resize:fit:1200/1*vnZ50uq7oTxc1T_vdNHopQ.gif)\n\n\n\n요약하자면, 렌더링된 목록에서 데이터를 필터링하거나 정렬하는 것은 초기 렌더링 시 항목 수와 동일한 수의 항목이 렌더링될 때까지 JS 스레드를 차단하는데 이상적인 방법이 아닙니다. \n목록의 성능을 향상시킬 수 있습니다. 목록을 강제로 마운트하여 교차 상태를 키로 전달하면 목록의 데이터도 변경할 수 있습니다.\n\n저장소: https://gitlab.com/sebastian.e.vogel/reactnativelonglistperformance","ogImage":{"url":"/assets/img/2024-05-14-ReactNativePerformanceoptimizationforlonglistswithsortorfilters_0.png"},"coverImage":"/assets/img/2024-05-14-ReactNativePerformanceoptimizationforlonglistswithsortorfilters_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>React Native에서 긴 요소 목록을 다루는 것은 꽤 도전적일 수 있어요. RN 문서에서는 FlatList를 사용하는 것을 권장하지만, 제공된 예제는 종종 방대한 목록이나 필터 적용 및 목록 정렬과 같은 시나리오를 다루지 않아서 많은 애플리케이션에서 필수적인 요구 사항들을 보여주지 못합니다.</p>\n<h1>예시와 관찰</h1>\n<p>RN 문서의 성능에 따른 가이드에 따라 매우 간단한 사용자 인터페이스를 갖춘 새로운 React Native 프로젝트를 만들어 보겠습니다. 우리는 이 인터페이스를 따라 MOCK 데이터셋을 만들었습니다. 이 데이터셋은 다음 인터페이스를 따르는 500개의 제품 항목이 있어요:</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">Item</span> {\n <span class=\"hljs-attr\">id</span>: number\n <span class=\"hljs-attr\">name</span>: string\n <span class=\"hljs-attr\">expiration_date</span>: string\n <span class=\"hljs-attr\">qty</span>: number\n}\n</code></pre>\n<p>그럼, 헤더와 두 개의 버튼이 있는 FlatList를 구현했습니다. 하나의 버튼은 ID가 가장 높은 순서대로 목록을 정렬하고, 다른 하나는 ID가 가장 낮은 순서대로 정렬합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">List</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> [orderBy, setOrderBy] = useState&#x3C;<span class=\"hljs-string\">'normal'</span> | <span class=\"hljs-string\">'reverse'</span>>(<span class=\"hljs-string\">'normal'</span>);\n\n  <span class=\"hljs-keyword\">const</span> renderListItem = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{item, index}: {item: Item; index: number}</span>) =></span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ListItem</span> <span class=\"hljs-attr\">item</span>=<span class=\"hljs-string\">{item}</span> <span class=\"hljs-attr\">index</span>=<span class=\"hljs-string\">{index}</span> /></span></span>;\n  }, []);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ListHeaderComponent</span> = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Header</span>\n        <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">{</span>'<span class=\"hljs-attr\">Order</span> <span class=\"hljs-attr\">by</span>'}\n        <span class=\"hljs-attr\">onPressButton1</span>=<span class=\"hljs-string\">{()</span> =></span> {\n          setOrderBy('normal');\n        }}\n        onPressButton2={() => {\n          setOrderBy('reverse');\n        }}\n      /></span>\n    );\n  }, []);\n\n  <span class=\"hljs-keyword\">const</span> orderedData = <span class=\"hljs-title function_\">useMemo</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">return</span> orderBy === <span class=\"hljs-string\">'normal'</span>\n      ? mockData.<span class=\"hljs-property\">data</span>.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> a.<span class=\"hljs-property\">id</span> - b.<span class=\"hljs-property\">id</span>)\n      : mockData.<span class=\"hljs-property\">data</span>.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> b.<span class=\"hljs-property\">id</span> - a.<span class=\"hljs-property\">id</span>);\n  }, [orderBy]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">FlatList</span>\n        <span class=\"hljs-attr\">ListHeaderComponent</span>=<span class=\"hljs-string\">{ListHeaderComponent}</span>\n        <span class=\"hljs-attr\">keyExtractor</span>=<span class=\"hljs-string\">{({id})</span> =></span> id.toString()}\n        renderItem={renderListItem}\n        data={orderedData}\n        stickyHeaderIndices={[0]}\n      />\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n}\n</code></pre>\n<p>ListItem 컴포넌트를 메모이즈하여 불필요한 다시 렌더링을 피했습니다. 인덱스에 따라 배경색이 결정되며, 동작을 이해하기 위해 인덱스를 기록하고 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ListItem</span> = <span class=\"hljs-title function_\">memo</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{item, index}: {item: Item; index: number}</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> backgroundColor = item.<span class=\"hljs-property\">id</span> % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">'#red'</span> : <span class=\"hljs-string\">'pink'</span>;\n\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">View</span>\n      <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span>\n        <span class=\"hljs-attr\">...styles.container</span>,\n        <span class=\"hljs-attr\">backgroundColor</span>,\n      }}></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Text</span>></span>\n        {item.name} - {item.id}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Text</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">View</span>></span></span>\n  );\n})\n</code></pre>\n<p>FlatList은 동작을 이해하고 문제를 해결하는 데 도움이 되는 세 가지 중요한 속성을 제공합니다:</p>\n<ul>\n<li>initialNumToRender: 초기 배치에서 렌더링할 아이템 수를 결정하며, 화면을 채우되 과도하게 많이 렌더링하지 않아야 합니다.</li>\n<li>maxToRenderPerBatch: 각 증분 렌더 배치에서 렌더링할 최대 아이템 수를 지정합니다.</li>\n<li>updateCellsBatchingPeriod: 배치 렌더 사이의 밀리초 단위 지연 시간을 설정합니다.</li>\n</ul>\n<p>예를 들어, initialNumToRender=10, maxToRenderPerBatch=10, updateCellsBatchingPeriod=10으로 설정하면, 리스트는 초기 10개 아이템을 먼저 렌더링한 다음, 10ms마다 10개씩 더 추가하여 완료될 때까지 부드럽게 렌더링되며, JS 스레드를 차단하지 않습니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1200/1*okgjSFX3jUmN-5CM2dAESw.gif\" alt=\"이미지\"></p>\n<p>리스트를 스크롤하는 동안 추가 항목이 배경에서 완료될 때까지 렌더링됩니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1200/1*cDzV6w7LguahgYZ4ywfQig.gif\" alt=\"scrolling\"></p>\n<p>그러나 목록을 정렬할 때 예상대로 동작하지 않습니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1200/1*a4yZcj1iJYYel3tllSJqEw.gif\" alt=\"sorting\"></p>\n<p>RN의 가이드라인을 따라 FlatList 성능을 향상시키려고 노력했지만, 목록이 예상대로 동작하지 않았어요. 그러나 성능을 향상시키는 것으로 보이는 잠재적인 해결책을 고안해 냈어요.</p>\n<p>주문 상태가 변경될 때마다 리스트의 다시 마운트를 트리거할 수 있도록 키를 사용함으로써, 초기 마운트 과정을 완료될 때까지 JS 스레드를 차단하지 않고 효율적으로 진행할 수 있어요.</p>\n<pre><code class=\"hljs language-js\">&#x3C;<span class=\"hljs-title class_\">FlatList</span>\n    key={orderBy}\n    ...나머지 초기 속성\n/>\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1200/1*yLeRxhhh2BRKBJ2MBERS5Q.gif\" alt=\"이미지\"></p>\n<p>행동을 더 잘 이해하기 위해 initialNumToRender=20, maxToRenderPerBatch=1 및 updateCellsBatchingPeriod=500으로 설정합니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1200/1*1JSiEZjP8PLNiP8I2OEvVw.gif\" alt=\"이미지1\"></p>\n<p>그러나 키가 삭제되면 어떻게 되나요?</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1200/1*vnZ50uq7oTxc1T_vdNHopQ.gif\" alt=\"이미지2\"></p>\n<p>요약하자면, 렌더링된 목록에서 데이터를 필터링하거나 정렬하는 것은 초기 렌더링 시 항목 수와 동일한 수의 항목이 렌더링될 때까지 JS 스레드를 차단하는데 이상적인 방법이 아닙니다.\n목록의 성능을 향상시킬 수 있습니다. 목록을 강제로 마운트하여 교차 상태를 키로 전달하면 목록의 데이터도 변경할 수 있습니다.</p>\n<p>저장소: <a href=\"https://gitlab.com/sebastian.e.vogel/reactnativelonglistperformance\" rel=\"nofollow\" target=\"_blank\">https://gitlab.com/sebastian.e.vogel/reactnativelonglistperformance</a></p>\n</body>\n</html>\n"},"__N_SSG":true}