{"pageProps":{"post":{"title":"러스트 트레이트 TypeScript 인터페이스의 강력한 대안","description":"","date":"2024-05-20 21:42","slug":"2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface","content":"\n\n\n![RustTraitAPowerfulAlternativeToTypeScriptInterface](/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png)\n\nRust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.\n\n이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.\n\n# 선언\n\n\n<div class=\"content-ad\"></div>\n\n이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.\n\n인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.\n\nTypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:\n\n```js\ninterface Entity {\n    id: string;\n    timestamp: number;\n}\n\ninterface Document extends Entity {\n    revised: boolean;\n}\n\ninterface Image extends Entity {\n    type: string;\n}\n```\n\n<div class=\"content-ad\"></div>\n\nRust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.\n\n```js\nstruct Document {\n    id: String,\n    timestamp: u64,\n    revised: bool,\n}\n\nstruct Image {\n    id: String,\n    timestamp: u64,\n    mime_type: String,\n}\n```\n\n# 상속 및 제네릭\n\n이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined =>\n documents.find(({ id: docId }) => docId === id);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined =>\n images.find(({ id: imageId }) => imageId === id);\n```\n\n하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:\n\n```js\nconst get = <T extends Entity>(\n id: string,\n elements: T[]\n): T | undefined =>\n elements.find(({ id: elementId }) => elementId === id);\n\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined => get<Document>(id, documents);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined => get<Image>(id, images);\n```\n\nRust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:```\n\n<div class=\"content-ad\"></div>\n\n```rs\nfn get_document(id: String, documents: Vec<Document>) -> Option<Document> {\n    documents.into_iter().find(|document| document.id == id)\n}\n\nfn get_image(id: String, images: Vec<Image>) -> Option<Image> {\n    images.into_iter().find(|image| image.id == id)\n}\n```\n\n위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.\n\n이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.\n\n```rs\ntrait Compare {\n    fn compare(&self, id: &str) -> bool;\n}\n\nimpl Compare for Document {\n    fn compare(&self, id: &str) -> bool {\n        self.id == id\n    }\n}\n\nimpl Compare for Image {\n    fn compare(&self, id: &str) -> bool {\n        self.id == id\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.\n\n```js\nfn get<T: Compare>(id: String, elements: Vec<T>) -> Option<T> {\n    elements.into_iter().find(|element| element.compare(&id))\n}\n\nfn get_document(id: String, documents: Vec<Document>) -> Option<Document> {\n    get(id, documents)\n}\n\nfn get_image(id: String, images: Vec<Image>) -> Option<Image> {\n    get(id, images)\n}\n```\n\n또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:\n\n```js\nfn get<T: Compare + OtherTrait>(id: String, elements: Vec<T>) -> Option<T> {\n    elements\n        .into_iter()\n        .find(|element| element.compare(&id) && element.other_trait(&id))\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.\n\n```rust\ntrait Compare {\n    fn sort(&self, other: &Self) -> Ordering;\n}\n\nimpl Compare for Document {\n    fn sort(&self, other: &Self) -> Ordering {\n        self.timestamp.cmp(&other.timestamp)\n    }\n}\n```\n\n# 결론\n\n우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.\n\n<div class=\"content-ad\"></div>\n\n무한한 여정이 시작됩니다\n데이비드\n\n더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png"},"coverImage":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png\" alt=\"RustTraitAPowerfulAlternativeToTypeScriptInterface\"></p>\n<p>Rust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.</p>\n<p>이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.</p>\n<h1>선언</h1>\n<p>이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.</p>\n<p>인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.</p>\n<p>TypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">Entity</span> {\n    <span class=\"hljs-attr\">id</span>: string;\n    <span class=\"hljs-attr\">timestamp</span>: number;\n}\n\ninterface <span class=\"hljs-title class_\">Document</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Entity</span> {\n    <span class=\"hljs-attr\">revised</span>: boolean;\n}\n\ninterface <span class=\"hljs-title class_\">Image</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Entity</span> {\n    <span class=\"hljs-attr\">type</span>: string;\n}\n</code></pre>\n<p>Rust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">Document</span> {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>,\n    <span class=\"hljs-attr\">timestamp</span>: u64,\n    <span class=\"hljs-attr\">revised</span>: bool,\n}\n\nstruct <span class=\"hljs-title class_\">Image</span> {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>,\n    <span class=\"hljs-attr\">timestamp</span>: u64,\n    <span class=\"hljs-attr\">mime_type</span>: <span class=\"hljs-title class_\">String</span>,\n}\n</code></pre>\n<h1>상속 및 제네릭</h1>\n<p>이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> getDocument = (\n <span class=\"hljs-attr\">id</span>: string,\n <span class=\"hljs-attr\">documents</span>: <span class=\"hljs-title class_\">Document</span>[]\n): <span class=\"hljs-title class_\">Document</span> | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =></span>\n documents.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ id: docId }</span>) =></span> docId === id);\n\n<span class=\"hljs-keyword\">const</span> getImages = (\n <span class=\"hljs-attr\">id</span>: string,\n <span class=\"hljs-attr\">images</span>: <span class=\"hljs-title class_\">Image</span>[]\n): <span class=\"hljs-title class_\">Image</span> | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =></span>\n images.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ id: imageId }</span>) =></span> imageId === id);\n</code></pre>\n<p>하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> get = &#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Entity</span>>(\n <span class=\"hljs-attr\">id</span>: string,\n <span class=\"hljs-attr\">elements</span>: T[]\n): T | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =></span>\n elements.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ id: elementId }</span>) =></span> elementId === id);\n\n<span class=\"hljs-keyword\">const</span> getDocument = (\n <span class=\"hljs-attr\">id</span>: string,\n <span class=\"hljs-attr\">documents</span>: <span class=\"hljs-title class_\">Document</span>[]\n): <span class=\"hljs-title class_\">Document</span> | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =></span> get&#x3C;<span class=\"hljs-title class_\">Document</span>>(id, documents);\n\n<span class=\"hljs-keyword\">const</span> getImages = (\n <span class=\"hljs-attr\">id</span>: string,\n <span class=\"hljs-attr\">images</span>: <span class=\"hljs-title class_\">Image</span>[]\n): <span class=\"hljs-title class_\">Image</span> | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =></span> get&#x3C;<span class=\"hljs-title class_\">Image</span>>(id, images);\n</code></pre>\n<p>Rust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:```</p>\n<pre><code class=\"hljs language-rs\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_document</span>(id: <span class=\"hljs-type\">String</span>, documents: <span class=\"hljs-type\">Vec</span>&#x3C;Document>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Option</span>&#x3C;Document> {\n    documents.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">find</span>(|document| document.id == id)\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_image</span>(id: <span class=\"hljs-type\">String</span>, images: <span class=\"hljs-type\">Vec</span>&#x3C;Image>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Option</span>&#x3C;Image> {\n    images.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">find</span>(|image| image.id == id)\n}\n</code></pre>\n<p>위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.</p>\n<p>이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.</p>\n<pre><code class=\"hljs language-rs\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">Compare</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">compare</span>(&#x26;<span class=\"hljs-keyword\">self</span>, id: &#x26;<span class=\"hljs-type\">str</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">bool</span>;\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Compare</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Document</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">compare</span>(&#x26;<span class=\"hljs-keyword\">self</span>, id: &#x26;<span class=\"hljs-type\">str</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.id == id\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Compare</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Image</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">compare</span>(&#x26;<span class=\"hljs-keyword\">self</span>, id: &#x26;<span class=\"hljs-type\">str</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.id == id\n    }\n}\n</code></pre>\n<p>마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.</p>\n<pre><code class=\"hljs language-js\">fn get&#x3C;<span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Compare</span>>(<span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">elements</span>: <span class=\"hljs-title class_\">Vec</span>&#x3C;T>) -> <span class=\"hljs-title class_\">Option</span>&#x3C;T> {\n    elements.<span class=\"hljs-title function_\">into_iter</span>().<span class=\"hljs-title function_\">find</span>(|element| element.<span class=\"hljs-title function_\">compare</span>(&#x26;id))\n}\n\nfn <span class=\"hljs-title function_\">get_document</span>(<span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">documents</span>: <span class=\"hljs-title class_\">Vec</span>&#x3C;<span class=\"hljs-title class_\">Document</span>>) -> <span class=\"hljs-title class_\">Option</span>&#x3C;<span class=\"hljs-title class_\">Document</span>> {\n    <span class=\"hljs-title function_\">get</span>(id, documents)\n}\n\nfn <span class=\"hljs-title function_\">get_image</span>(<span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">images</span>: <span class=\"hljs-title class_\">Vec</span>&#x3C;<span class=\"hljs-title class_\">Image</span>>) -> <span class=\"hljs-title class_\">Option</span>&#x3C;<span class=\"hljs-title class_\">Image</span>> {\n    <span class=\"hljs-title function_\">get</span>(id, images)\n}\n</code></pre>\n<p>또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:</p>\n<pre><code class=\"hljs language-js\">fn get&#x3C;<span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Compare</span> + <span class=\"hljs-title class_\">OtherTrait</span>>(<span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">elements</span>: <span class=\"hljs-title class_\">Vec</span>&#x3C;T>) -> <span class=\"hljs-title class_\">Option</span>&#x3C;T> {\n    elements\n        .<span class=\"hljs-title function_\">into_iter</span>()\n        .<span class=\"hljs-title function_\">find</span>(|element| element.<span class=\"hljs-title function_\">compare</span>(&#x26;id) &#x26;&#x26; element.<span class=\"hljs-title function_\">other_trait</span>(&#x26;id))\n}\n</code></pre>\n<p>이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">Compare</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">sort</span>(&#x26;<span class=\"hljs-keyword\">self</span>, other: &#x26;<span class=\"hljs-keyword\">Self</span>) <span class=\"hljs-punctuation\">-></span> Ordering;\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Compare</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Document</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">sort</span>(&#x26;<span class=\"hljs-keyword\">self</span>, other: &#x26;<span class=\"hljs-keyword\">Self</span>) <span class=\"hljs-punctuation\">-></span> Ordering {\n        <span class=\"hljs-keyword\">self</span>.timestamp.<span class=\"hljs-title function_ invoke__\">cmp</span>(&#x26;other.timestamp)\n    }\n}\n</code></pre>\n<h1>결론</h1>\n<p>우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.</p>\n<p>무한한 여정이 시작됩니다\n데이비드</p>\n<p>더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}