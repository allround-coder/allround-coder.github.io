{"pageProps":{"post":{"title":"RxJS Creation Operators 마스터하기","description":"","date":"2024-05-18 22:03","slug":"2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams","content":"\n\n반응형 프로그래밍은 현대 웹 개발에서 중요한 기반 기술이 되었으며 비동기 데이터 스트림을 처리하는 견고한 방법을 제공합니다. RxJS 또는 JavaScript용 반응형 익스텐션은 JavaScript에서 반응형 프로그래밍을 구현하는 가장 인기있는 라이브러리 중 하나입니다. 생성 연산자는 여러 기능 중에서도 관찰 가능한 스트림을 생성하는 데 필수적인 도구로 강조됩니다. 이 블로그 포스트에서는 다양한 RxJS 생성 연산자, 작동 방식 및 각각에 대한 실제 사용 사례를 살펴보겠습니다.\n\n![image](/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png)\n\n## RxJS 생성 연산자란?\n\n이러한 연산자는 다양한 데이터 소스에서 새로운 Observables를 생성합니다. 이러한 연산자는 개발자들이 작업할 데이터 스트림의 소스를 정의할 수 있도록 해주기 때문에 중요합니다. 이러한 연산자를 이해하는 것은 RxJS의 전체 기능을 최대한 활용하는 데 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n# Creation Operators 목록\n\n(참고: “⭐ — 일반적으로 사용됨”)\n\n- ⭐ajax: Ajax 요청을 위한 observable을 생성하는 데 사용됩니다.\n- bindCallback: 콜백 스타일 함수를 observable로 변환합니다.\n- bindNodeCallback: bindCallback과 유사하지만, Node.js 스타일 콜백(error-first)을 위한 것입니다.\n- defer: observable의 생성을 구독 지점까지 지연시킵니다.\n- empty: 어떤 값도 방출하지 않고 즉시 완료되는 observable을 생성합니다.\n- ⭐from: 다양한 다른 객체 및 데이터 유형을 observable로 변환합니다.\n- ⭐fromEvent: DOM 이벤트 대상 또는 Node.js EventEmitter에서 이벤트를 방출하는 observable을 생성합니다.\n- fromEventPattern: 주어진 addHandler/removeHandler 함수 쌍에서 observable을 생성합니다.\n- generate: 제공된 반복 함수에 기반하여 시간이 지남에 따라 값들을 생성합니다.\n- ⭐interval: 지정된 간격에서 증가하는 숫자를 방출하는 observable을 생성합니다.\n- ⭐of: 값의 시퀀스를 observable 시퀀스로 방출합니다.\n- range: 지정된 범위 내의 숫자 시퀀스를 방출합니다.\n- throwError: 오류를 방출하는 observable을 생성합니다.\n- timer: 지정된 지연 후 단일 값을 방출합니다.\n- iif: 두 가지 가능한 원본 observable 중 하나에 조건부로 구독합니다.\n\n이제 Creation Operator를 하나씩 검토하고 예제를 통해 학습하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Ajax\n\nXMLHttpRequest API를 사용하여 HTTP 요청을 보냅니다.\n\n```js\n/* 실시간 사용 사례: 요청에서 반환되는 응답 객체를 방출하는 Observable */\nimport { ajax } from 'rxjs/ajax';\n\nconst githubUsers = `https://api.github.com/users?per_page=2`;\nconst users = ajax(githubUsers);\n\nconst subscribe = users.subscribe(\n  res => console.log(res),\n  err => console.error(err)\n);\n```\n\n```js\n/* 실시간 사용 사례: 요청에서 반환되는 응답 객체의 json 키만 방출하는 Observable */\nimport { ajax } from 'rxjs/ajax';\n\nconst githubUsers = `https://api.github.com/users?per_page=2`;\nconst users = ajax.getJSON(githubUsers);\n\nconst subscribe = users.subscribe(\n  res => console.log(res),\n  err => console.error(err)\n);\n```  \n\n<div class=\"content-ad\"></div>\n\n# bindCallback\n\n콜백 스타일의 함수를 Observable로 변환합니다.\n\n```js\n/* 실시간 사용 사례: jQuery의 getJSON을 Observable API로 변환하는 방법 */\n\nimport { bindCallback } from 'rxjs';\nimport * as jQuery from 'jquery';\n\nconst getJSONAsObservable = bindCallback(jQuery.getJSON);\nconst result = getJSONAsObservable('/my/url');\nresult.subscribe(x => console.log(x), e => console.error(e));\n```\n\n# bindNodeCallback\n\n<div class=\"content-ad\"></div>\n\n- 노드 스타일 콜백 함수를 Observable로 변환합니다.\n\n```js\n/* 실시간 사용 사례: 파일 시스템에서 파일 읽어오기 및 데이터를 Observable로 얻기 */\nimport { bindNodeCallback } from 'rxjs';\nimport * as fs from 'fs';\n\nconst readFileAsObservable = bindNodeCallback(fs.readFile);\nconst result = readFileAsObservable('./roadNames.txt', 'utf8');\n\nresult.subscribe(\n  x => console.log(x), // 파일 내용 처리\n  e => console.error(e) // 오류 처리\n);\n```\n\n- `defer`\n\nSubscriber가 Observable에 구독할 때까지 실행을 지연시키는 Observable를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\nRxJS에서 defer는 Observable을 생성하는 함수입니다. 주요 목적은 Observable이 구독될 때까지 Observable의 생성을 지연하는 것입니다. 이는 새로운 옵저버가 Observable을 구독할 때마다 설정 또는 초기화 논리가 실행되어야 하는 시나리오에서 유용합니다.\n\n```js\n/* 실시간 사용 사례: `of`를 사용하여 난수 생성 */\nimport { of, defer } from 'rxjs';\nconst randomOf$ = of(Math.random());\n\n// 랜덤 숫자 생성을 위해 `defer` 사용\nconst randomDefer$ = defer(() => of(Math.random()));\n\n// `randomOf$`를 여러 번 구독\nrandomOf$.subscribe(randomNumber => console.log('랜덤 숫자 (of):', randomNumber));\nrandomOf$.subscribe(randomNumber => console.log('랜덤 숫자 (of):', randomNumber));\nrandomOf$.subscribe(randomNumber => console.log('랜덤 숫자 (of):', randomNumber));\n\n// `randomDefer$`를 여러 번 구독\nrandomDefer$.subscribe(randomNumber => console.log('랜덤 숫자 (defer):', randomNumber));\nrandomDefer$.subscribe(randomNumber => console.log('랜덤 숫자 (defer):', randomNumber));\nrandomDefer$.subscribe(randomNumber => console.log('랜덤 숫자 (defer):', randomNumber));\n```\n\nOutput\n\n```js\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (defer): 0.987654321\n랜덤 숫자 (defer): 0.654321987\n랜덤 숫자 (defer): 0.123456789\n```\n\n<div class=\"content-ad\"></div>\n\n# 빈\n\n빈 Observable을 생성하고 즉시 완료 콜백을 호출합니다.\n\nRxJS의 빈 연산자는 값을 방출하지 않고 즉시 완료되는 Observable을 생성합니다. 값이 방출될 필요가 없지만 완료를 신호해야 하는 경우에 유용합니다.\n\n```js\n/* 실시간 사용 사례: 빈 Observable 생성 */\nimport { empty } from 'rxjs';\nconst emptyObservable$ = empty();\n// 빈 Observable에 구독하기\nemptyObservable$.subscribe({\n  next: () => console.log('다음 값'), // 호출되지 않음\n  complete: () => console.log('완료됨') // 즉시 호출됨\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# from\n\n배열, 프로미스, 이터러블 객체 또는 Observable과 유사한 객체에서 Observable을 생성합니다.\n\n```js\nimport { from } from 'rxjs';\nconst arraySource = from([1, 2, 3, 4, 5]);\nconst subscribe = arraySource.subscribe(val => console.log(val));\n//출력: 1, 2, 3, 4, 5\n```\n\n```js\nimport { from } from 'rxjs';\nconst source = from('Hello World');\nconst subscribe = source.subscribe(val => console.log(val));\n//출력: 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'\n```\n\n<div class=\"content-ad\"></div>\n\n\n```js\nconst numbers = from(new Promise((resolve, reject) => resolve('Hello World')));\nnumbers.subscribe((data) => {\n  console.log(data);\n});\n//output: Hello World\n```\n\n# fromEvent\n\n- 이벤트에서 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 사용자가 화면을 클릭할 때 시간 추적 */\nimport { fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = fromEvent(document, 'click');\nconst example = source.pipe(map(event => event.timeStamp));\nconst subscribe = example.subscribe(val => console.log(`이벤트 시간: ${val / 1000} 초`));\n```\n\n<div class=\"content-ad\"></div>\n\n출력\n\n```js\n이벤트 시간: 5.418900000000373 초\n이벤트 시간: 7.552900000000372 초\n```\n\n# fromEventPattern\n\nfromEventPattern은 이벤트를 반환하는 함수에서 Observable을 생성합니다. fromEventPattern을 사용하면 이벤트 처리기 함수를 등록하는 API를 Observable로 변환할 수 있습니다. fromEvent과 유사하지만 훨씬 유연합니다. fromEvent의 모든 사용 사례는 fromEventPattern으로 쉽게 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 생성\n\n함수를 기반으로 값을 생성하는 옵저버블을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 숫자 시퀀스 생성 */\n\nimport { generate } from 'rxjs';\nconst result = generate(0, x => x < 3, x => x + 1, x => x);\nresult.subscribe(x => console.log(x));\n\n// 결과:\n// 0\n// 1\n// 2\n```\n\n# 간격\n\n<div class=\"content-ad\"></div>\n\n일정한 간격으로 정수 시퀀스를 방출하는 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 1초 간격으로 값 시퀀스를 방출 */\nimport { interval } from 'rxjs';\n\n// 1초마다 시퀀스 값 방출\nconst source = interval(1000);\nconst subscribe = source.subscribe(val => console.log(val));\n//결과: 0, 1, 2, 3, 4, 5....\n```\n\n# of\n\n- 지정된 값을 순서대로 방출하는 Observable을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\n\nof(10, 20, 30)\n  .subscribe({\n    next: value => console.log('다음 값:', value),\n    error: err => console.log('에러 발생:', err),\n    complete: () => console.log('완료'),\n  });\n\n// 결과\n// 다음 값: 10\n// 다음 값: 20\n// 다음 값: 30\n// 완료\n```\n\n# range\n\n지정된 범위 내에서 숫자의 시퀀스를 방출하는 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 1에서 10까지 순차적으로 방출 */\n\nimport { range } from 'rxjs';\nconst source = range(1, 10);\nconst example = source.subscribe(val => console.log(val));\n// 출력: 1,2,3,4,5,6,7,8,9,10\n```\n\n<div class=\"content-ad\"></div>\n\n# throwError\n\n- 구독 시 오류를 발생시키는 Observable을 생성합니다.\n\n```js\n/* 구독 시 오류 발생 */\nimport { throwError } from 'rxjs';\n// 특정 값과 함께 오류를 발생시킵니다.\n\nconst source = throwError('오류 발생!');\n// 출력: 'Error: 오류 발생!'\n\nconst subscribe = source.subscribe({\n  next: val => console.log(val),\n  complete: () => console.log('완료!'),\n  error: val => console.log(`오류: ${val}`)\n});\n```\n\n# timer\n\n<div class=\"content-ad\"></div>\n\n- 특정 시간 간격 후에 발행을 시작하고 정수 시퀀스를 발행하는 Observable를 생성합니다.\n\n```js\n/* 실제 시나리오: 타이머는 1초 후에 발행을 시작하고 그 이후 매 2초마다 값을 발행합니다 */\n\nimport { timer } from 'rxjs';\n\n/*\n  timer 함수는 두 번째 인자를 가지며, 연속적으로 값들을 발행하는 빈도를 정의합니다.\n  이 경우, 1초 후에 첫 번째 값을 발행하고 그 이후 2초마다 값을 발행합니다.\n*/\nconst source = timer(1000, 2000);\n//출력: 0,1,2,3,4,5......\nconst subscribe = source.subscribe(val => console.log(val));\n```\n\n# iif\n\n조건에 따라 함수의 출력을 발행하는 Observable를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* Observable에 대한 액세스 제어 */\n\nimport { iif, of, EMPTY } from 'rxjs';\n \nlet accessGranted;\nconst observableIfYouHaveAccess = iif(\n  () => accessGranted,\n  of('액세스가 허용된 것 같아요...'),\n  EMPTY\n);\n \naccessGranted = true;\nobservableIfYouHaveAccess.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('끝')\n});\n \n// 출력:\n// '액세스가 허용된 것 같아요...'\n// '끝'\n \naccessGranted = false;\nobservableIfYouHaveAccess.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('끝')\n});\n \n// 출력:\n// '끝'\n```\n\n요약하면, RxJS Creation Operators는 JavaScript에서 반응형 프로그래밍의 기본 구성 요소입니다. 다양한 데이터 소스에서 Observable을 생성할 수 있게 해줌으로써, 이러한 연산자는 비동기 데이터 스트림을 효율적으로 처리할 수 있도록 개발자들을 지원합니다. API에서 데이터를 가져오는 ajax, 사용자 상호 작용에 반응하는 fromEvent, interval 및 timer를 사용하여 작업을 예약하는 등, 이러한 연산자들은 반응형 애플리케이션에서 데이터 흐름을 유연하고 강력하게 관리할 수 있는 방법을 제공합니다. 이러한 생성 연산자를 숙달하는 것은 RxJS의 모든 잠재력을 발휘하고 반응형 프로그래밍을 통한 반응형, 확장 가능하고 유지보수 가능한 애플리케이션을 구축하는 데 필수적입니다. 이 연산자들을 깊이 이해하고 그 기능을 실험하며, RxJS를 활용한 반응형 프로그래밍 마스터의 길에 나아가 보세요.\n\n즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png"},"coverImage":"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>반응형 프로그래밍은 현대 웹 개발에서 중요한 기반 기술이 되었으며 비동기 데이터 스트림을 처리하는 견고한 방법을 제공합니다. RxJS 또는 JavaScript용 반응형 익스텐션은 JavaScript에서 반응형 프로그래밍을 구현하는 가장 인기있는 라이브러리 중 하나입니다. 생성 연산자는 여러 기능 중에서도 관찰 가능한 스트림을 생성하는 데 필수적인 도구로 강조됩니다. 이 블로그 포스트에서는 다양한 RxJS 생성 연산자, 작동 방식 및 각각에 대한 실제 사용 사례를 살펴보겠습니다.</p>\n<p><img src=\"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png\" alt=\"image\"></p>\n<h2>RxJS 생성 연산자란?</h2>\n<p>이러한 연산자는 다양한 데이터 소스에서 새로운 Observables를 생성합니다. 이러한 연산자는 개발자들이 작업할 데이터 스트림의 소스를 정의할 수 있도록 해주기 때문에 중요합니다. 이러한 연산자를 이해하는 것은 RxJS의 전체 기능을 최대한 활용하는 데 필수적입니다.</p>\n<h1>Creation Operators 목록</h1>\n<p>(참고: “⭐ — 일반적으로 사용됨”)</p>\n<ul>\n<li>⭐ajax: Ajax 요청을 위한 observable을 생성하는 데 사용됩니다.</li>\n<li>bindCallback: 콜백 스타일 함수를 observable로 변환합니다.</li>\n<li>bindNodeCallback: bindCallback과 유사하지만, Node.js 스타일 콜백(error-first)을 위한 것입니다.</li>\n<li>defer: observable의 생성을 구독 지점까지 지연시킵니다.</li>\n<li>empty: 어떤 값도 방출하지 않고 즉시 완료되는 observable을 생성합니다.</li>\n<li>⭐from: 다양한 다른 객체 및 데이터 유형을 observable로 변환합니다.</li>\n<li>⭐fromEvent: DOM 이벤트 대상 또는 Node.js EventEmitter에서 이벤트를 방출하는 observable을 생성합니다.</li>\n<li>fromEventPattern: 주어진 addHandler/removeHandler 함수 쌍에서 observable을 생성합니다.</li>\n<li>generate: 제공된 반복 함수에 기반하여 시간이 지남에 따라 값들을 생성합니다.</li>\n<li>⭐interval: 지정된 간격에서 증가하는 숫자를 방출하는 observable을 생성합니다.</li>\n<li>⭐of: 값의 시퀀스를 observable 시퀀스로 방출합니다.</li>\n<li>range: 지정된 범위 내의 숫자 시퀀스를 방출합니다.</li>\n<li>throwError: 오류를 방출하는 observable을 생성합니다.</li>\n<li>timer: 지정된 지연 후 단일 값을 방출합니다.</li>\n<li>iif: 두 가지 가능한 원본 observable 중 하나에 조건부로 구독합니다.</li>\n</ul>\n<p>이제 Creation Operator를 하나씩 검토하고 예제를 통해 학습하겠습니다.</p>\n<h1>Ajax</h1>\n<p>XMLHttpRequest API를 사용하여 HTTP 요청을 보냅니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: 요청에서 반환되는 응답 객체를 방출하는 Observable */</span>\n<span class=\"hljs-keyword\">import</span> { ajax } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/ajax'</span>;\n\n<span class=\"hljs-keyword\">const</span> githubUsers = <span class=\"hljs-string\">`https://api.github.com/users?per_page=2`</span>;\n<span class=\"hljs-keyword\">const</span> users = <span class=\"hljs-title function_\">ajax</span>(githubUsers);\n\n<span class=\"hljs-keyword\">const</span> subscribe = users.<span class=\"hljs-title function_\">subscribe</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res),\n  <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err)\n);\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: 요청에서 반환되는 응답 객체의 json 키만 방출하는 Observable */</span>\n<span class=\"hljs-keyword\">import</span> { ajax } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/ajax'</span>;\n\n<span class=\"hljs-keyword\">const</span> githubUsers = <span class=\"hljs-string\">`https://api.github.com/users?per_page=2`</span>;\n<span class=\"hljs-keyword\">const</span> users = ajax.<span class=\"hljs-title function_\">getJSON</span>(githubUsers);\n\n<span class=\"hljs-keyword\">const</span> subscribe = users.<span class=\"hljs-title function_\">subscribe</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res),\n  <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err)\n);\n</code></pre>\n<h1>bindCallback</h1>\n<p>콜백 스타일의 함수를 Observable로 변환합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: jQuery의 getJSON을 Observable API로 변환하는 방법 */</span>\n\n<span class=\"hljs-keyword\">import</span> { bindCallback } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> jQuery <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'jquery'</span>;\n\n<span class=\"hljs-keyword\">const</span> getJSONAsObservable = <span class=\"hljs-title function_\">bindCallback</span>(jQuery.<span class=\"hljs-property\">getJSON</span>);\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">getJSONAsObservable</span>(<span class=\"hljs-string\">'/my/url'</span>);\nresult.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x), <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e));\n</code></pre>\n<h1>bindNodeCallback</h1>\n<ul>\n<li>노드 스타일 콜백 함수를 Observable로 변환합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: 파일 시스템에서 파일 읽어오기 및 데이터를 Observable로 얻기 */</span>\n<span class=\"hljs-keyword\">import</span> { bindNodeCallback } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> fs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'fs'</span>;\n\n<span class=\"hljs-keyword\">const</span> readFileAsObservable = <span class=\"hljs-title function_\">bindNodeCallback</span>(fs.<span class=\"hljs-property\">readFile</span>);\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">readFileAsObservable</span>(<span class=\"hljs-string\">'./roadNames.txt'</span>, <span class=\"hljs-string\">'utf8'</span>);\n\nresult.<span class=\"hljs-title function_\">subscribe</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x), <span class=\"hljs-comment\">// 파일 내용 처리</span>\n  <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e) <span class=\"hljs-comment\">// 오류 처리</span>\n);\n</code></pre>\n<ul>\n<li><code>defer</code></li>\n</ul>\n<p>Subscriber가 Observable에 구독할 때까지 실행을 지연시키는 Observable를 생성합니다.</p>\n<p>RxJS에서 defer는 Observable을 생성하는 함수입니다. 주요 목적은 Observable이 구독될 때까지 Observable의 생성을 지연하는 것입니다. 이는 새로운 옵저버가 Observable을 구독할 때마다 설정 또는 초기화 논리가 실행되어야 하는 시나리오에서 유용합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: `of`를 사용하여 난수 생성 */</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span>, defer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">const</span> randomOf$ = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>());\n\n<span class=\"hljs-comment\">// 랜덤 숫자 생성을 위해 `defer` 사용</span>\n<span class=\"hljs-keyword\">const</span> randomDefer$ = <span class=\"hljs-title function_\">defer</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>()));\n\n<span class=\"hljs-comment\">// `randomOf$`를 여러 번 구독</span>\nrandomOf$.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">randomNumber</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'랜덤 숫자 (of):'</span>, randomNumber));\nrandomOf$.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">randomNumber</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'랜덤 숫자 (of):'</span>, randomNumber));\nrandomOf$.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">randomNumber</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'랜덤 숫자 (of):'</span>, randomNumber));\n\n<span class=\"hljs-comment\">// `randomDefer$`를 여러 번 구독</span>\nrandomDefer$.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">randomNumber</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'랜덤 숫자 (defer):'</span>, randomNumber));\nrandomDefer$.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">randomNumber</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'랜덤 숫자 (defer):'</span>, randomNumber));\nrandomDefer$.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">randomNumber</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'랜덤 숫자 (defer):'</span>, randomNumber));\n</code></pre>\n<p>Output</p>\n<pre><code class=\"hljs language-js\">랜덤 숫자 (<span class=\"hljs-keyword\">of</span>): <span class=\"hljs-number\">0.123456789</span>\n랜덤 숫자 (<span class=\"hljs-keyword\">of</span>): <span class=\"hljs-number\">0.123456789</span>\n랜덤 숫자 (<span class=\"hljs-keyword\">of</span>): <span class=\"hljs-number\">0.123456789</span>\n랜덤 숫자 (defer): <span class=\"hljs-number\">0.987654321</span>\n랜덤 숫자 (defer): <span class=\"hljs-number\">0.654321987</span>\n랜덤 숫자 (defer): <span class=\"hljs-number\">0.123456789</span>\n</code></pre>\n<h1>빈</h1>\n<p>빈 Observable을 생성하고 즉시 완료 콜백을 호출합니다.</p>\n<p>RxJS의 빈 연산자는 값을 방출하지 않고 즉시 완료되는 Observable을 생성합니다. 값이 방출될 필요가 없지만 완료를 신호해야 하는 경우에 유용합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: 빈 Observable 생성 */</span>\n<span class=\"hljs-keyword\">import</span> { empty } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">const</span> emptyObservable$ = <span class=\"hljs-title function_\">empty</span>();\n<span class=\"hljs-comment\">// 빈 Observable에 구독하기</span>\nemptyObservable$.<span class=\"hljs-title function_\">subscribe</span>({\n  <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'다음 값'</span>), <span class=\"hljs-comment\">// 호출되지 않음</span>\n  <span class=\"hljs-attr\">complete</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'완료됨'</span>) <span class=\"hljs-comment\">// 즉시 호출됨</span>\n});\n</code></pre>\n<h1>from</h1>\n<p>배열, 프로미스, 이터러블 객체 또는 Observable과 유사한 객체에서 Observable을 생성합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">from</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">const</span> arraySource = <span class=\"hljs-title function_\">from</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]);\n<span class=\"hljs-keyword\">const</span> subscribe = arraySource.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val));\n<span class=\"hljs-comment\">//출력: 1, 2, 3, 4, 5</span>\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">from</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title function_\">from</span>(<span class=\"hljs-string\">'Hello World'</span>);\n<span class=\"hljs-keyword\">const</span> subscribe = source.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val));\n<span class=\"hljs-comment\">//출력: 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'</span>\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> numbers = <span class=\"hljs-title function_\">from</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'Hello World'</span>)));\nnumbers.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n});\n<span class=\"hljs-comment\">//output: Hello World</span>\n</code></pre>\n<h1>fromEvent</h1>\n<ul>\n<li>이벤트에서 Observable을 생성합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: 사용자가 화면을 클릭할 때 시간 추적 */</span>\n<span class=\"hljs-keyword\">import</span> { fromEvent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> { map } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n\n<span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title function_\">fromEvent</span>(<span class=\"hljs-variable language_\">document</span>, <span class=\"hljs-string\">'click'</span>);\n<span class=\"hljs-keyword\">const</span> example = source.<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =></span> event.<span class=\"hljs-property\">timeStamp</span>));\n<span class=\"hljs-keyword\">const</span> subscribe = example.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`이벤트 시간: <span class=\"hljs-subst\">${val / <span class=\"hljs-number\">1000</span>}</span> 초`</span>));\n</code></pre>\n<p>출력</p>\n<pre><code class=\"hljs language-js\">이벤트 시간: <span class=\"hljs-number\">5.418900000000373</span> 초\n이벤트 시간: <span class=\"hljs-number\">7.552900000000372</span> 초\n</code></pre>\n<h1>fromEventPattern</h1>\n<p>fromEventPattern은 이벤트를 반환하는 함수에서 Observable을 생성합니다. fromEventPattern을 사용하면 이벤트 처리기 함수를 등록하는 API를 Observable로 변환할 수 있습니다. fromEvent과 유사하지만 훨씬 유연합니다. fromEvent의 모든 사용 사례는 fromEventPattern으로 쉽게 처리할 수 있습니다.</p>\n<h1>생성</h1>\n<p>함수를 기반으로 값을 생성하는 옵저버블을 생성합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: 숫자 시퀀스 생성 */</span>\n\n<span class=\"hljs-keyword\">import</span> { generate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">generate</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x &#x3C; <span class=\"hljs-number\">3</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x);\nresult.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x));\n\n<span class=\"hljs-comment\">// 결과:</span>\n<span class=\"hljs-comment\">// 0</span>\n<span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<h1>간격</h1>\n<p>일정한 간격으로 정수 시퀀스를 방출하는 Observable을 생성합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: 1초 간격으로 값 시퀀스를 방출 */</span>\n<span class=\"hljs-keyword\">import</span> { interval } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-comment\">// 1초마다 시퀀스 값 방출</span>\n<span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title function_\">interval</span>(<span class=\"hljs-number\">1000</span>);\n<span class=\"hljs-keyword\">const</span> subscribe = source.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val));\n<span class=\"hljs-comment\">//결과: 0, 1, 2, 3, 4, 5....</span>\n</code></pre>\n<h1>of</h1>\n<ul>\n<li>지정된 값을 순서대로 방출하는 Observable을 생성합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>)\n  .<span class=\"hljs-title function_\">subscribe</span>({\n    <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'다음 값:'</span>, value),\n    <span class=\"hljs-attr\">error</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'에러 발생:'</span>, err),\n    <span class=\"hljs-attr\">complete</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'완료'</span>),\n  });\n\n<span class=\"hljs-comment\">// 결과</span>\n<span class=\"hljs-comment\">// 다음 값: 10</span>\n<span class=\"hljs-comment\">// 다음 값: 20</span>\n<span class=\"hljs-comment\">// 다음 값: 30</span>\n<span class=\"hljs-comment\">// 완료</span>\n</code></pre>\n<h1>range</h1>\n<p>지정된 범위 내에서 숫자의 시퀀스를 방출하는 Observable을 생성합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실시간 사용 사례: 1에서 10까지 순차적으로 방출 */</span>\n\n<span class=\"hljs-keyword\">import</span> { range } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>);\n<span class=\"hljs-keyword\">const</span> example = source.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val));\n<span class=\"hljs-comment\">// 출력: 1,2,3,4,5,6,7,8,9,10</span>\n</code></pre>\n<h1>throwError</h1>\n<ul>\n<li>구독 시 오류를 발생시키는 Observable을 생성합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 구독 시 오류 발생 */</span>\n<span class=\"hljs-keyword\">import</span> { throwError } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-comment\">// 특정 값과 함께 오류를 발생시킵니다.</span>\n\n<span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title function_\">throwError</span>(<span class=\"hljs-string\">'오류 발생!'</span>);\n<span class=\"hljs-comment\">// 출력: 'Error: 오류 발생!'</span>\n\n<span class=\"hljs-keyword\">const</span> subscribe = source.<span class=\"hljs-title function_\">subscribe</span>({\n  <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val),\n  <span class=\"hljs-attr\">complete</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'완료!'</span>),\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`오류: <span class=\"hljs-subst\">${val}</span>`</span>)\n});\n</code></pre>\n<h1>timer</h1>\n<ul>\n<li>특정 시간 간격 후에 발행을 시작하고 정수 시퀀스를 발행하는 Observable를 생성합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* 실제 시나리오: 타이머는 1초 후에 발행을 시작하고 그 이후 매 2초마다 값을 발행합니다 */</span>\n\n<span class=\"hljs-keyword\">import</span> { timer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-comment\">/*\n  timer 함수는 두 번째 인자를 가지며, 연속적으로 값들을 발행하는 빈도를 정의합니다.\n  이 경우, 1초 후에 첫 번째 값을 발행하고 그 이후 2초마다 값을 발행합니다.\n*/</span>\n<span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-number\">2000</span>);\n<span class=\"hljs-comment\">//출력: 0,1,2,3,4,5......</span>\n<span class=\"hljs-keyword\">const</span> subscribe = source.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val));\n</code></pre>\n<h1>iif</h1>\n<p>조건에 따라 함수의 출력을 발행하는 Observable를 생성합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* Observable에 대한 액세스 제어 */</span>\n\n<span class=\"hljs-keyword\">import</span> { iif, <span class=\"hljs-keyword\">of</span>, <span class=\"hljs-variable constant_\">EMPTY</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n \n<span class=\"hljs-keyword\">let</span> accessGranted;\n<span class=\"hljs-keyword\">const</span> observableIfYouHaveAccess = <span class=\"hljs-title function_\">iif</span>(\n  <span class=\"hljs-function\">() =></span> accessGranted,\n  <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-string\">'액세스가 허용된 것 같아요...'</span>),\n  <span class=\"hljs-variable constant_\">EMPTY</span>\n);\n \naccessGranted = <span class=\"hljs-literal\">true</span>;\nobservableIfYouHaveAccess.<span class=\"hljs-title function_\">subscribe</span>({\n  <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value),\n  <span class=\"hljs-attr\">complete</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'끝'</span>)\n});\n \n<span class=\"hljs-comment\">// 출력:</span>\n<span class=\"hljs-comment\">// '액세스가 허용된 것 같아요...'</span>\n<span class=\"hljs-comment\">// '끝'</span>\n \naccessGranted = <span class=\"hljs-literal\">false</span>;\nobservableIfYouHaveAccess.<span class=\"hljs-title function_\">subscribe</span>({\n  <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value),\n  <span class=\"hljs-attr\">complete</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'끝'</span>)\n});\n \n<span class=\"hljs-comment\">// 출력:</span>\n<span class=\"hljs-comment\">// '끝'</span>\n</code></pre>\n<p>요약하면, RxJS Creation Operators는 JavaScript에서 반응형 프로그래밍의 기본 구성 요소입니다. 다양한 데이터 소스에서 Observable을 생성할 수 있게 해줌으로써, 이러한 연산자는 비동기 데이터 스트림을 효율적으로 처리할 수 있도록 개발자들을 지원합니다. API에서 데이터를 가져오는 ajax, 사용자 상호 작용에 반응하는 fromEvent, interval 및 timer를 사용하여 작업을 예약하는 등, 이러한 연산자들은 반응형 애플리케이션에서 데이터 흐름을 유연하고 강력하게 관리할 수 있는 방법을 제공합니다. 이러한 생성 연산자를 숙달하는 것은 RxJS의 모든 잠재력을 발휘하고 반응형 프로그래밍을 통한 반응형, 확장 가능하고 유지보수 가능한 애플리케이션을 구축하는 데 필수적입니다. 이 연산자들을 깊이 이해하고 그 기능을 실험하며, RxJS를 활용한 반응형 프로그래밍 마스터의 길에 나아가 보세요.</p>\n<p>즐거운 코딩되세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}