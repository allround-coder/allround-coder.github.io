{"pageProps":{"post":{"title":"우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법","description":"","date":"2024-05-18 21:44","slug":"2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu","content":"\n\n웹 응용 프로그램을 SSL 인증서로 안전하게 보호하는 것은 클라이언트와 서버 간에 전송되는 데이터의 기밀성과 무결성을 보장하기 위해 중요합니다. 이 튜토리얼에서는 Ubuntu 운영 체제의 Apache 웹 서버에 대한 서브젝트 대체 이름 (SAN)이 포함된 자체 서명 SSL 인증서를 생성하는 과정을 안내합니다.\n\n# 필수 사항\n\n시작하기 전에 다음 사항을 확인하세요:\n\n<div class=\"content-ad\"></div>\n\n- Apache가 설치된 Ubuntu 서버\n- openssl 도구가 설치되어 있습니다.\n\n우선, 프론트엔드 폴더로 이동해주세요.\n\n### 단계 1: 디렉토리 생성\n\n인증서를 위한 디렉토리를 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nmkdir certificates\ncd certificates\n```\n\n# 단계 2: 개인 키 생성\n\n```js\nopenssl genpkey -algorithm RSA -out private.key\n```\n\n- genpkey: 이 하위 명령어는 개인 키를 생성하는 데 사용됩니다.\n- -algorithm RSA: 키 생성에 사용할 알고리즘을 지정합니다. 이 경우 RSA (Rivest–Shamir–Adleman) 알고리즘을 사용합니다. RSA는 널리 사용되는 비대칭 암호 알고리즘입니다.\n- -out private.key: 생성된 개인 키를 저장할 출력 파일을 지정합니다. 이 예에서는 개인 키가 private.key라는 파일에 저장됩니다.\n\n<div class=\"content-ad\"></div>\n\n[비권장] 만약 당신의 private.key가 암호로 보호되기를 원한다면 -\n\n```js\nopenssl genpkey -algorithm RSA -aes256 -out private.key\n```\n\n-aes256:\n\n- 이 매개변수는 개인 키에 사용할 암호화 알고리즘을 나타냅니다. 이 경우 AES (고급 암호화 표준)와 키 길이가 256비트인 AES-256를 사용합니다. 이 매개변수는 추가 보안을 위해 개인 키를 AES-256로 암호화하는 것을 보장합니다. 사용자는 키 생성 과정 중에 암호를 입력하도록 요청받으며, 이 암호는 개인 키를 암호화하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 아래의 정보를 Markdown 형식으로 변환해 드릴게요.\n\n```\nYou’ll be prompted to enter a passphrase; remember this passphrase as you’ll need it later.\n\n## Step 3: Create a SAN Configuration File\n\nCreate a file named san.conf with the following content:\n\n```js\n[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = req_ext\nprompt = no\n\n[req_distinguished_name]\nCN = localhost\nC = BD\nST = Dhaka\nL = Motijheel\nO = Robist\nOU = Developers\nemailAddress = smazoomder@gmail.com\n\n[req_ext]\nsubjectAltName = IP:192.168.0.88\n``` \n\n\n<div class=\"content-ad\"></div>\n\n(당신의 IP를 Ip 자리에 넣으세요)\n\n- [req]: 이 섹션은 인증서 요청에 대한 속성을 지정합니다.\n- distinguished_name = req_distinguished_name: 인증서를 요청하는 엔티티에 대한 다양한 세부 정보를 정의하는 식별 이름 섹션을 가리킵니다.\n- req_extensions = req_ext: 인증서에 추가 정보를 포함할 수 있는 확장 섹션을 가리킵니다.\n- prompt = no: 인증서 생성 과정 중에 인증서 세부 정보에 대한 프롬프트를 비활성화합니다.\n- [req_distinguished_name]: 공통 이름 (CN), 국가 (C), 주 (ST), 지역 (L), 조직 (O), 조직 단위 (OU) 및 이메일 주소와 같은 다양한 식별 이름 속성을 정의합니다.\n- CN = localhost: 일반적으로 인증서와 관련된 도메인 이름인 공통 이름(CN)을 지정합니다.\n- C = BD: 국가 속성으로 방글라데시를 나타냅니다.\n- ST = Dhaka: 주 속성으로 다카를 지정합니다.\n- L = Motijheel: 지역 속성으로 모티제엘을 나타냅니다.\n- O = Robist: 조직 속성으로 로비스트를 나타냅니다.\n- OU = Developers: 조직 단위 속성으로 개발자를 나타냅니다.\n- emailAddress = smazoomder@gmail.com: 인증서와 관련된 이메일 주소입니다.\n- [req_ext]: 추가 확장을 인증서에 포함할 수 있는 확장 섹션입니다.\n- subjectAltName = IP:192.168.0.88: 대체 식별자로 IP 주소(192.168.0.88)를 포함하는 Subject Alternative Name (SAN) 확장을 지정합니다.\n\n## Subject Alternative Name (SAN)의 내용 :\n\n- Subject: SSL/TLS 인증서의 맥락에서 \"주체\"는 일반적으로 인증서가 발행된 엔티티(웹사이트 또는 서버 등)를 가리킵니다. 일반적으로 공통 이름(CN), 조직 및 위치와 같은 정보를 포함합니다.\n- Alternative Name: \"대체 이름\"은 SSL/TLS 인증서에 포함될 수 있는 추가 식별자를 가리킵니다. 이러한 식별자는 공통 이름(CN)을 넘어서 유효한 인증서에 대한 다른 이름을 세분화하여 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## SAN 사용 이유:\n\n- 다중 식별자 지원: SAN을 통해 하나의 SSL/TLS 인증서가 여러 식별자에 대해 유효할 수 있습니다. 기존에는 SSL 인증서가 주된 도메인을 나타내는 공통 이름(CN) 필드를 기반으로 발급되었습니다. 그러나 유연성이 커지면서 SAN을 통해 추가 이름을 포함할 수 있게 되었습니다.\n- 다중 도메인 인증서: SAN은 하나의 인증서가 여러 도메인이나 서브도메인을 커버해야 하는 상황에서 특히 유용합니다. 각 도메인마다 별도의 인증서를 얻는 대신 SAN 확장을 지원하는 다중 도메인 인증서를 사용할 수 있습니다.\n- IP 주소 및 이메일 주소: SAN은 도메인 이름에만 국한되지 않습니다. IP 주소와 이메일 주소를 대체 식별자로 포함할 수도 있습니다. IP 주소를 통해 접근되는 서비스나 이메일 통신을 커버해야 하는 경우 유용합니다.\n- 와일드카드 인증서: SAN은 와일드카드 인증서와 함께 일반적으로 사용됩니다. 와일드카드 인증서는 도메인과 서브도메인을 커버하며, SAN은 추가 도메인을 더 확장할 수 있습니다.\n- 인증서 불일치 문제 회피: SAN을 포함하면 인증서 불일치 문제를 예방할 수 있습니다. 대체 이름을 통해 서비스에 액세스할 때, SAN의 존재로 인해 인증서가 여전히 유효하다고 간주됩니다.\n\n요약하면, Subject Alternative Name (SAN)은 SSL/TLS 인증서에 다중 식별자를 포함할 수 있는 확장 기능으로, 안전한 통신에서 다양한 명명 시나리오에 대한 유연성과 광범위한 커버리지를 제공합니다.\n\n# 단계 4: 인증서 서명 요청(CSR) 생성\n\n<div class=\"content-ad\"></div>\n\n```js\nopenssl req -new -key private.key -out certificate.csr -config san.conf\n```\n\nopenssl req:\n\n- 이 명령어는 OpenSSL에서 인증서 요청을 생성하고 처리하는 데 사용됩니다.\n\n-new:\n\n<div class=\"content-ad\"></div>\n\n- 새로운 CSR (인증서 서명 요청)이 생성되고 있음을 나타냅니다.\n\n- -key private.key:\n\n- CSR을 생성하는 데 사용될 개인 키 파일을 지정합니다. 이전 단계에서 생성 된 개인 키 (private.key)가 여기에서 사용됩니다.\n\n- -out certificate.csr:\n\n<div class=\"content-ad\"></div>\n\n- 생성된 CSR이 저장될 출력 파일을 지정합니다. 이 예시에서는 CSR이 certificate.csr이라는 파일에 저장됩니다.\n\n- `config san.conf`:\n\n- 인증서에 대한 부가 설정 및 Subject Alternative Names (SANs)을 포함하는 구성 파일 (san.conf)을 지정합니다.\n\n# 단계 5: 자체 서명 인증서 생성\n\n<div class=\"content-ad\"></div>\n\n```bash\nopenssl x509 -req -in certificate.csr -signkey private.key -out server.cert -days 365\n```\n\nopenssl x509:\n\n- X.509 인증서 파일에 서명하고 표시하는 데 사용되는 OpenSSL 명령입니다.\n\n-req:\n\n<div class=\"content-ad\"></div>\n\n- 입력 파일(certificate.csr)이 인증 요청서(CSR)임을 나타냅니다.\n\n- certificate.csr 파일 안에:\n\n- 서명이 필요한 인증 요청서(CSR)가 포함된 입력 파일을 지정합니다. 이 예에서 CSR 파일은 certificate.csr입니다.\n\n- signkey private.key:\n\n<div class=\"content-ad\"></div>\n\n- CSR을 서명하고 인증서를 생성할 때 사용할 개인 키(private.key)를 지정합니다.\n\n- server.cert에 저장됩니다:\n\n- 서명된 X.509 인증서가 저장될 출력 파일을 지정합니다. 이 예시에서는 인증서 파일의 이름을 server.cert로 지정합니다.\n\n- 365일 동안 유효합니다:\n\n<div class=\"content-ad\"></div>\n\n- 인증서의 유효 기간을 일(day) 단위로 지정합니다.이 경우 인증서는 365일(1년) 동안 유효합니다.\n\n## X.509 인증서 소개\n\nX.509 인증서는 공개 키 인증서의 형식과 구조를 정의하는 X.509 표준을 따르는 디지털 인증서입니다. 이러한 인증서는 TLS/SSL을 포함한 인터넷 보안 프로토콜에서 널리 사용됩니다. 아래는 X.509 인증서의 구성 요소입니다:\n\n<div class=\"content-ad\"></div>\n\n- 버전: X.509 표준의 버전을 나타냅니다. (예: 버전 1, 2 또는 3)\n- 일련 번호: 인증서 발급자 (인증 기관)가 할당한 고유 식별자로, 인증서를 구분합니다.\n- 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용한 암호화 알고리즘을 지정합니다.\n- 발급자: 인증서를 발급한 엔터티 (일반적으로 인증 기관)를 식별합니다.\n- 유효 기간: 인증서의 유효성을 나타내는 시간 범위를 정의합니다. \"발효일\"과 \"만료일\"이 포함됩니다.\n- 주체: 인증서의 공개 키와 관련된 엔터티 (예: 사람, 조직 또는 장치)를 식별합니다.\n- 주체 공개 키 정보: 주체가 사용하는 공개 키와 알고리즘을 포함합니다.\n- 확장: 인증서와 관련된 추가 정보 또는 속성을 포함합니다. 주체 대체 이름 (SAN), 키 사용 등이 포함될 수 있습니다.\n- 인증서 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용하는 알고리즘을 지정합니다.\n- 인증서 서명 값: 인증 기관에 의해 생성된 디지털 서명을 포함하여 인증서의 무결성과 신뢰성을 보장합니다.\n\n# X.509 인증서의 목적:\n\n- 인증: 인증서 소지자의 신원을 확인합니다.\n- 암호화: 공개 키를 사용하여 데이터를 암호화하여 안전한 통신을 지원합니다.\n- 디지털 서명: 디지털 서명의 생성과 검증을 통해 데이터 무결성을 보장합니다.\n- 키 교환: 안전한 통신 프로토콜에서 암호 키 교환을 지원합니다.\n\n# SSL/TLS에서의 사용:\n\n<div class=\"content-ad\"></div>\n\n- SSL/TLS 프로토콜에서 X.509 인증서는 클라이언트와 서버 간 안전한 연결을 설정하는 데 필수적입니다. 클라이언트가 안전한 웹 사이트에 연결할 때, 서버는 자체 X.509 인증서를 제출하고 클라이언트는 이를 확인하여 안전하고 신뢰할 수 있는 연결을 보장합니다.\n- X.509 인증서는 내부 사용을 위해 자체 서명될 수도 있고, 공개적인 웹 사이트를 위해 신뢰할 수 있는 인증 기관에 의해 서명될 수도 있습니다.\n\n웹 보안, 시스템 관리 또는 소프트웨어 개발에 관여하는 모든 사람에게 X.509 인증서를 이해하는 것이 중요합니다.\n\n# 단계 6: Apache 구성 업데이트\n\nApache 가상 호스트 구성을 업데이트하세요 (/etc/apache2/sites-available/your-site.conf):\n\n<div class=\"content-ad\"></div>\n\n\n# 가상 호스트 설정:\n\n- **`VirtualHost *:443`**: 443 포트에서 HTTPS 통신을 위한 가상 호스트 블록을 정의합니다.\n\n- **`ServerName localhost`**: 이 가상 호스트와 연결된 기본 도메인 이름을 지정합니다. 이 경우 \"localhost\"로 설정되어 있습니다.\n \n\n<div class=\"content-ad\"></div>\n\n\nServerAdmin webmaster@localhost: 서버 관리자의 이메일 주소.\n\nDocumentRoot /var/www/html/your-project/backend/public: 이 VirtualHost의 문서 루트 디렉터리를 설정합니다. 이것은 웹 서버가 파일을 제공하는 위치입니다.\n\nSSLEngine on: SSL 연결을 처리해야 함을 나타내는이 VirtualHost를위한 SSL 엔진을 활성화합니다.\n\nSSLUseStapling off: SSL 스테이플링을 비활성화합니다. SSL 스테이플링은 SSL/TLS 인증서 확인을 강화하는 메커니즘입니다. 그러나이 예제에서는 비활성화되어 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\nSSLCertificateFile /var/www/html/your-project/certificates/server.cert: SSL 인증서 파일의 경로를 지정합니다. 이는 이전 단계에서 생성된 공개 키 인증서 파일입니다.\n\nSSLCertificateKeyFile /var/www/html/your-project/certificates/private.key: SSL 인증서와 관련된 개인 키 파일의 경로를 지정합니다.\n\nServerAlias 192.168.0.88: 이 VirtualHost가 응답해야 하는 추가 도메인 이름 또는 IP 주소를 지정합니다. 여기서는 IP 주소 192.168.0.88이 포함됩니다.\n\n`Directory \"/var/www/html/your-project/backend/public\"`: 지정된 디렉토리에 대한 구성 블록을 시작합니다.\n\n<div class=\"content-ad\"></div>\n\nOptions All: 이 디렉토리에 대해 사용 가능한 모든 옵션을 허용합니다.\n\nAllowOverride All: 이 디렉토리에서 .htaccess 파일을 사용하여 구성 재정의를 허용합니다.\n\nRequire all granted: 모든 사용자에게 액세스를 부여합니다.\n\n`/Directory`: 지정된 디렉토리에 대한 구성 블록을 종료합니다.\n\n<div class=\"content-ad\"></div>\n\n`/VirtualHost` : VirtualHost 블록을 종료합니다.\n\n# 설정 목적:\n\n- 이 구성 블록은 Apache가 지정된 도메인 (localhost 및 192.168.0.88)에 대한 SSL 연결을 어떻게 처리해야 하는지를 보장합니다. SSL 인증서 파일을 가리키고 연관 디렉토리에 대한 액세스 설정을 정의합니다.\n- \"/var/www/html/your-project\"와 같은 자리 표시자를 프로젝트에서 실제 사용하는 경로로 교체해야 합니다.\n\n그런 다음 활성화하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo a2ensite your-site.conf\n```\n\n# 단계 7: 아파치 재시작\n\n```js\nsudo systemctl restart apache2\n```\n\nSSL/TLS 키의 암호를 입력하라는 프롬프트가 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 8: Apache 오류 로그 확인\n\n```bash\nsudo tail -f /var/log/apache2/error.log\n```\n\nSSL과 관련된 오류 메시지를 확인해 보세요.\n\n# 단계 9: 라라벨 저장소 권한 설정\n\n<div class=\"content-ad\"></div>\n\n```js\ncd /var/www/html/your-project/backend\nsudo chmod -R 775 storage\nsudo chown -R www-data:www-data storage\n```\n\n이제 https://192.168.0.88 (당신의 IP)에서 애플리케이션에 안전하게 액세스할 수 있어야 합니다.\n\n# 단계 10: React/Laravel 애플리케이션을 실행 중이라면\n\n프론트엔드 환경에서:\n\n\n<div class=\"content-ad\"></div>\n\n\nREACT_APP_NAME = 'your-project'\nREACT_APP_VERSION = v1.1.0\nGENERATE_SOURCEMAP = false\n\nREACT_APP_API_BASE_URL='https://192.168.0.88/api'\nREACT_APP_ASSET_BASE_URL='https://192.168.0.88/storage'\nREACT_APP_MAIN_DOMAIN='192.168.0.88:3000'\nREACT_APP_API_DOMAIN='https://192.168.0.88'\nREACT_APP_BACK_DOMAIN = 'https://192.168.0.88'\n\nREACT_APP_SITE_KEY = 'your-key'\n\n\nin backend env :\n\n\nAPP_URL=https://192.168.0.88\nAPP_SITE_URL=\"https://192.168.0.88:3000\"\n\n\n축하합니다! Ubuntu에서 Apache 웹 서버에 대한 Subject Alternative Name이 포함된 자체 서명 SSL 인증서를 성공적으로 생성했습니다.\n  \n\n<div class=\"content-ad\"></div>\n\n문제가 있으면 다음을 실행해 보세요\n\n```js\nsudo systemctl restart apache2\n```\n\n```js\ncd /var/www/html/your-project/backend\nsudo chmod -R 775 storage\nsudo chown -R www-data:www-data storage\n```\n\n# (선택 사항) /etc/hosts 파일 업데이트\n\n<div class=\"content-ad\"></div>\n\n친구야, 아래와 같이 /etc/hosts 파일에 localhost와 192.168.0.88(IP 주소)의 항목이 있는지 확인해 주세요.\n\n# (선택 사항) Chrome에서 인증서를 가져오는 방법:\n\n- 권한 생성 및 인증서를 CRT 형식으로 변환:\n\n```js\nopenssl x509 -in server.cert -out server.crt\n```\n\n<div class=\"content-ad\"></div>\n\n- PKCS#12 형식으로 인증서 및 키 변환하기:\n\n```js\nopenssl pkcs12 -export -out certificate.pfx -inkey private.key -in server.cert\n```\n\n개인 키의 암호를 입력하라는 프롬프트가 표시됩니다.\n\n3. Chrome에 인증서 가져오기:\n\n<div class=\"content-ad\"></div>\n\n- 크롬을 열고 설정으로 이동합니다.\n- 아래로 스크롤하여 고급을 클릭합니다.\n- 개인 정보 및 보안 아래에서 인증서 관리를 클릭합니다.\n- 인증서 창에서 개인 탭으로 이동합니다.\n- 가져오기를 클릭하고 생성한 certificate.pfx 파일을 선택합니다.\n- 가져오기 마법사를 따라가고 암호를 입력하고 나오면 상점을 선택합니다.\n\n4. 신뢰할 수 있는 인증 기관(CA)을 추가하려면 다음을 수행하십시오:\n\n```js\nsudo cp server.crt /usr/local/share/ca-certificates/server.crt\nsudo update-ca-certificates\n```\n\n다음 명령을 사용하여 인증서가 신뢰 목록에 추가되었는지 확인하십시오:\n\n<div class=\"content-ad\"></div>\n\n```js\nawk -v cmd='openssl x509 -noout -subject' ' /BEGIN/{close(cmd)};{print | cmd}' < /etc/ssl/certs/ca-certificates.crt | grep -i localhost\n```\n\n인증서의 전체 세부 정보를 확인하려면 OpenSSL 또는 다른 도구를 사용할 수 있습니다. 예를 들어 OpenSSL을 사용하여 다음과 같이 실행할 수 있습니다.\n\n```js\nopenssl x509 -in server.cert -text -noout\n```\n\n만료 날짜 확인: SSL 인증서가 만료되지 않았는지 확인하십시오. 다음 OpenSSL 명령어를 사용하여 만료 날짜를 확인할 수 있습니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\nopenssl x509 -enddate -noout -in server.cert\n```\n\n인증서 내용 확인:\n\nOpenSSL을 사용하여 인증서 및 개인 키 파일의 내용을 확인할 수 있습니다. 원하는 정보가 포함되어 있는지 확인하세요:\n\n```js\nopenssl x509 -in server.cert -text -noout\nopenssl rsa -in private.key -text -noout\n```\n\n<div class=\"content-ad\"></div>\n\n만약 필요하다면, 개인 키 파일은 암호로 보호되지 않습니다. 암호로 보호되어 있다면 개인 키에서 암호구를 제거해야 할 수도 있습니다.\n\n```js\nopenssl rsa -in private.key -out private.key\n```\n\n인증서를 확인하려면\n\n```js\nopenssl verify server.crt\n```","ogImage":{"url":"/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png","tag":["Tech"],"readingTime":11},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>웹 응용 프로그램을 SSL 인증서로 안전하게 보호하는 것은 클라이언트와 서버 간에 전송되는 데이터의 기밀성과 무결성을 보장하기 위해 중요합니다. 이 튜토리얼에서는 Ubuntu 운영 체제의 Apache 웹 서버에 대한 서브젝트 대체 이름 (SAN)이 포함된 자체 서명 SSL 인증서를 생성하는 과정을 안내합니다.</p>\n<h1>필수 사항</h1>\n<p>시작하기 전에 다음 사항을 확인하세요:</p>\n<ul>\n<li>Apache가 설치된 Ubuntu 서버</li>\n<li>openssl 도구가 설치되어 있습니다.</li>\n</ul>\n<p>우선, 프론트엔드 폴더로 이동해주세요.</p>\n<h3>단계 1: 디렉토리 생성</h3>\n<p>인증서를 위한 디렉토리를 생성하세요.</p>\n<pre><code class=\"hljs language-js\">mkdir certificates\ncd certificates\n</code></pre>\n<h1>단계 2: 개인 키 생성</h1>\n<pre><code class=\"hljs language-js\">openssl genpkey -algorithm <span class=\"hljs-variable constant_\">RSA</span> -out private.<span class=\"hljs-property\">key</span>\n</code></pre>\n<ul>\n<li>genpkey: 이 하위 명령어는 개인 키를 생성하는 데 사용됩니다.</li>\n<li>-algorithm RSA: 키 생성에 사용할 알고리즘을 지정합니다. 이 경우 RSA (Rivest–Shamir–Adleman) 알고리즘을 사용합니다. RSA는 널리 사용되는 비대칭 암호 알고리즘입니다.</li>\n<li>-out private.key: 생성된 개인 키를 저장할 출력 파일을 지정합니다. 이 예에서는 개인 키가 private.key라는 파일에 저장됩니다.</li>\n</ul>\n<p>[비권장] 만약 당신의 private.key가 암호로 보호되기를 원한다면 -</p>\n<pre><code class=\"hljs language-js\">openssl genpkey -algorithm <span class=\"hljs-variable constant_\">RSA</span> -aes256 -out private.<span class=\"hljs-property\">key</span>\n</code></pre>\n<p>-aes256:</p>\n<ul>\n<li>이 매개변수는 개인 키에 사용할 암호화 알고리즘을 나타냅니다. 이 경우 AES (고급 암호화 표준)와 키 길이가 256비트인 AES-256를 사용합니다. 이 매개변수는 추가 보안을 위해 개인 키를 AES-256로 암호화하는 것을 보장합니다. 사용자는 키 생성 과정 중에 암호를 입력하도록 요청받으며, 이 암호는 개인 키를 암호화하는 데 사용됩니다.</li>\n</ul>\n<p>안녕하세요! 아래의 정보를 Markdown 형식으로 변환해 드릴게요.</p>\n<pre><code>You’ll be prompted to enter a passphrase; remember this passphrase as you’ll need it later.\n\n## Step 3: Create a SAN Configuration File\n\nCreate a file named san.conf with the following content:\n\n```js\n[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = req_ext\nprompt = no\n\n[req_distinguished_name]\nCN = localhost\nC = BD\nST = Dhaka\nL = Motijheel\nO = Robist\nOU = Developers\nemailAddress = smazoomder@gmail.com\n\n[req_ext]\nsubjectAltName = IP:192.168.0.88\n</code></pre>\n<p>(당신의 IP를 Ip 자리에 넣으세요)</p>\n<ul>\n<li>[req]: 이 섹션은 인증서 요청에 대한 속성을 지정합니다.</li>\n<li>distinguished_name = req_distinguished_name: 인증서를 요청하는 엔티티에 대한 다양한 세부 정보를 정의하는 식별 이름 섹션을 가리킵니다.</li>\n<li>req_extensions = req_ext: 인증서에 추가 정보를 포함할 수 있는 확장 섹션을 가리킵니다.</li>\n<li>prompt = no: 인증서 생성 과정 중에 인증서 세부 정보에 대한 프롬프트를 비활성화합니다.</li>\n<li>[req_distinguished_name]: 공통 이름 (CN), 국가 (C), 주 (ST), 지역 (L), 조직 (O), 조직 단위 (OU) 및 이메일 주소와 같은 다양한 식별 이름 속성을 정의합니다.</li>\n<li>CN = localhost: 일반적으로 인증서와 관련된 도메인 이름인 공통 이름(CN)을 지정합니다.</li>\n<li>C = BD: 국가 속성으로 방글라데시를 나타냅니다.</li>\n<li>ST = Dhaka: 주 속성으로 다카를 지정합니다.</li>\n<li>L = Motijheel: 지역 속성으로 모티제엘을 나타냅니다.</li>\n<li>O = Robist: 조직 속성으로 로비스트를 나타냅니다.</li>\n<li>OU = Developers: 조직 단위 속성으로 개발자를 나타냅니다.</li>\n<li>emailAddress = <a href=\"mailto:smazoomder@gmail.com\">smazoomder@gmail.com</a>: 인증서와 관련된 이메일 주소입니다.</li>\n<li>[req_ext]: 추가 확장을 인증서에 포함할 수 있는 확장 섹션입니다.</li>\n<li>subjectAltName = IP:192.168.0.88: 대체 식별자로 IP 주소(192.168.0.88)를 포함하는 Subject Alternative Name (SAN) 확장을 지정합니다.</li>\n</ul>\n<h2>Subject Alternative Name (SAN)의 내용 :</h2>\n<ul>\n<li>Subject: SSL/TLS 인증서의 맥락에서 \"주체\"는 일반적으로 인증서가 발행된 엔티티(웹사이트 또는 서버 등)를 가리킵니다. 일반적으로 공통 이름(CN), 조직 및 위치와 같은 정보를 포함합니다.</li>\n<li>Alternative Name: \"대체 이름\"은 SSL/TLS 인증서에 포함될 수 있는 추가 식별자를 가리킵니다. 이러한 식별자는 공통 이름(CN)을 넘어서 유효한 인증서에 대한 다른 이름을 세분화하여 지정할 수 있습니다.</li>\n</ul>\n<h2>SAN 사용 이유:</h2>\n<ul>\n<li>다중 식별자 지원: SAN을 통해 하나의 SSL/TLS 인증서가 여러 식별자에 대해 유효할 수 있습니다. 기존에는 SSL 인증서가 주된 도메인을 나타내는 공통 이름(CN) 필드를 기반으로 발급되었습니다. 그러나 유연성이 커지면서 SAN을 통해 추가 이름을 포함할 수 있게 되었습니다.</li>\n<li>다중 도메인 인증서: SAN은 하나의 인증서가 여러 도메인이나 서브도메인을 커버해야 하는 상황에서 특히 유용합니다. 각 도메인마다 별도의 인증서를 얻는 대신 SAN 확장을 지원하는 다중 도메인 인증서를 사용할 수 있습니다.</li>\n<li>IP 주소 및 이메일 주소: SAN은 도메인 이름에만 국한되지 않습니다. IP 주소와 이메일 주소를 대체 식별자로 포함할 수도 있습니다. IP 주소를 통해 접근되는 서비스나 이메일 통신을 커버해야 하는 경우 유용합니다.</li>\n<li>와일드카드 인증서: SAN은 와일드카드 인증서와 함께 일반적으로 사용됩니다. 와일드카드 인증서는 도메인과 서브도메인을 커버하며, SAN은 추가 도메인을 더 확장할 수 있습니다.</li>\n<li>인증서 불일치 문제 회피: SAN을 포함하면 인증서 불일치 문제를 예방할 수 있습니다. 대체 이름을 통해 서비스에 액세스할 때, SAN의 존재로 인해 인증서가 여전히 유효하다고 간주됩니다.</li>\n</ul>\n<p>요약하면, Subject Alternative Name (SAN)은 SSL/TLS 인증서에 다중 식별자를 포함할 수 있는 확장 기능으로, 안전한 통신에서 다양한 명명 시나리오에 대한 유연성과 광범위한 커버리지를 제공합니다.</p>\n<h1>단계 4: 인증서 서명 요청(CSR) 생성</h1>\n<pre><code class=\"hljs language-js\">openssl req -<span class=\"hljs-keyword\">new</span> -key private.<span class=\"hljs-property\">key</span> -out certificate.<span class=\"hljs-property\">csr</span> -config san.<span class=\"hljs-property\">conf</span>\n</code></pre>\n<p>openssl req:</p>\n<ul>\n<li>이 명령어는 OpenSSL에서 인증서 요청을 생성하고 처리하는 데 사용됩니다.</li>\n</ul>\n<p>-new:</p>\n<ul>\n<li>\n<p>새로운 CSR (인증서 서명 요청)이 생성되고 있음을 나타냅니다.</p>\n</li>\n<li>\n<p>-key private.key:</p>\n</li>\n<li>\n<p>CSR을 생성하는 데 사용될 개인 키 파일을 지정합니다. 이전 단계에서 생성 된 개인 키 (private.key)가 여기에서 사용됩니다.</p>\n</li>\n<li>\n<p>-out certificate.csr:</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>생성된 CSR이 저장될 출력 파일을 지정합니다. 이 예시에서는 CSR이 certificate.csr이라는 파일에 저장됩니다.</p>\n</li>\n<li>\n<p><code>config san.conf</code>:</p>\n</li>\n<li>\n<p>인증서에 대한 부가 설정 및 Subject Alternative Names (SANs)을 포함하는 구성 파일 (san.conf)을 지정합니다.</p>\n</li>\n</ul>\n<h1>단계 5: 자체 서명 인증서 생성</h1>\n<pre><code class=\"hljs language-bash\">openssl x509 -req -<span class=\"hljs-keyword\">in</span> certificate.csr -signkey private.key -out server.cert -days 365\n</code></pre>\n<p>openssl x509:</p>\n<ul>\n<li>X.509 인증서 파일에 서명하고 표시하는 데 사용되는 OpenSSL 명령입니다.</li>\n</ul>\n<p>-req:</p>\n<ul>\n<li>\n<p>입력 파일(certificate.csr)이 인증 요청서(CSR)임을 나타냅니다.</p>\n</li>\n<li>\n<p>certificate.csr 파일 안에:</p>\n</li>\n<li>\n<p>서명이 필요한 인증 요청서(CSR)가 포함된 입력 파일을 지정합니다. 이 예에서 CSR 파일은 certificate.csr입니다.</p>\n</li>\n<li>\n<p>signkey private.key:</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>CSR을 서명하고 인증서를 생성할 때 사용할 개인 키(private.key)를 지정합니다.</p>\n</li>\n<li>\n<p>server.cert에 저장됩니다:</p>\n</li>\n<li>\n<p>서명된 X.509 인증서가 저장될 출력 파일을 지정합니다. 이 예시에서는 인증서 파일의 이름을 server.cert로 지정합니다.</p>\n</li>\n<li>\n<p>365일 동안 유효합니다:</p>\n</li>\n</ul>\n<ul>\n<li>인증서의 유효 기간을 일(day) 단위로 지정합니다.이 경우 인증서는 365일(1년) 동안 유효합니다.</li>\n</ul>\n<h2>X.509 인증서 소개</h2>\n<p>X.509 인증서는 공개 키 인증서의 형식과 구조를 정의하는 X.509 표준을 따르는 디지털 인증서입니다. 이러한 인증서는 TLS/SSL을 포함한 인터넷 보안 프로토콜에서 널리 사용됩니다. 아래는 X.509 인증서의 구성 요소입니다:</p>\n<ul>\n<li>버전: X.509 표준의 버전을 나타냅니다. (예: 버전 1, 2 또는 3)</li>\n<li>일련 번호: 인증서 발급자 (인증 기관)가 할당한 고유 식별자로, 인증서를 구분합니다.</li>\n<li>서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용한 암호화 알고리즘을 지정합니다.</li>\n<li>발급자: 인증서를 발급한 엔터티 (일반적으로 인증 기관)를 식별합니다.</li>\n<li>유효 기간: 인증서의 유효성을 나타내는 시간 범위를 정의합니다. \"발효일\"과 \"만료일\"이 포함됩니다.</li>\n<li>주체: 인증서의 공개 키와 관련된 엔터티 (예: 사람, 조직 또는 장치)를 식별합니다.</li>\n<li>주체 공개 키 정보: 주체가 사용하는 공개 키와 알고리즘을 포함합니다.</li>\n<li>확장: 인증서와 관련된 추가 정보 또는 속성을 포함합니다. 주체 대체 이름 (SAN), 키 사용 등이 포함될 수 있습니다.</li>\n<li>인증서 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용하는 알고리즘을 지정합니다.</li>\n<li>인증서 서명 값: 인증 기관에 의해 생성된 디지털 서명을 포함하여 인증서의 무결성과 신뢰성을 보장합니다.</li>\n</ul>\n<h1>X.509 인증서의 목적:</h1>\n<ul>\n<li>인증: 인증서 소지자의 신원을 확인합니다.</li>\n<li>암호화: 공개 키를 사용하여 데이터를 암호화하여 안전한 통신을 지원합니다.</li>\n<li>디지털 서명: 디지털 서명의 생성과 검증을 통해 데이터 무결성을 보장합니다.</li>\n<li>키 교환: 안전한 통신 프로토콜에서 암호 키 교환을 지원합니다.</li>\n</ul>\n<h1>SSL/TLS에서의 사용:</h1>\n<ul>\n<li>SSL/TLS 프로토콜에서 X.509 인증서는 클라이언트와 서버 간 안전한 연결을 설정하는 데 필수적입니다. 클라이언트가 안전한 웹 사이트에 연결할 때, 서버는 자체 X.509 인증서를 제출하고 클라이언트는 이를 확인하여 안전하고 신뢰할 수 있는 연결을 보장합니다.</li>\n<li>X.509 인증서는 내부 사용을 위해 자체 서명될 수도 있고, 공개적인 웹 사이트를 위해 신뢰할 수 있는 인증 기관에 의해 서명될 수도 있습니다.</li>\n</ul>\n<p>웹 보안, 시스템 관리 또는 소프트웨어 개발에 관여하는 모든 사람에게 X.509 인증서를 이해하는 것이 중요합니다.</p>\n<h1>단계 6: Apache 구성 업데이트</h1>\n<p>Apache 가상 호스트 구성을 업데이트하세요 (/etc/apache2/sites-available/your-site.conf):</p>\n<h1>가상 호스트 설정:</h1>\n<ul>\n<li>\n<p><strong><code>VirtualHost *:443</code></strong>: 443 포트에서 HTTPS 통신을 위한 가상 호스트 블록을 정의합니다.</p>\n</li>\n<li>\n<p><strong><code>ServerName localhost</code></strong>: 이 가상 호스트와 연결된 기본 도메인 이름을 지정합니다. 이 경우 \"localhost\"로 설정되어 있습니다.</p>\n</li>\n</ul>\n<p>ServerAdmin webmaster@localhost: 서버 관리자의 이메일 주소.</p>\n<p>DocumentRoot /var/www/html/your-project/backend/public: 이 VirtualHost의 문서 루트 디렉터리를 설정합니다. 이것은 웹 서버가 파일을 제공하는 위치입니다.</p>\n<p>SSLEngine on: SSL 연결을 처리해야 함을 나타내는이 VirtualHost를위한 SSL 엔진을 활성화합니다.</p>\n<p>SSLUseStapling off: SSL 스테이플링을 비활성화합니다. SSL 스테이플링은 SSL/TLS 인증서 확인을 강화하는 메커니즘입니다. 그러나이 예제에서는 비활성화되어 있습니다.</p>\n<p>SSLCertificateFile /var/www/html/your-project/certificates/server.cert: SSL 인증서 파일의 경로를 지정합니다. 이는 이전 단계에서 생성된 공개 키 인증서 파일입니다.</p>\n<p>SSLCertificateKeyFile /var/www/html/your-project/certificates/private.key: SSL 인증서와 관련된 개인 키 파일의 경로를 지정합니다.</p>\n<p>ServerAlias 192.168.0.88: 이 VirtualHost가 응답해야 하는 추가 도메인 이름 또는 IP 주소를 지정합니다. 여기서는 IP 주소 192.168.0.88이 포함됩니다.</p>\n<p><code>Directory \"/var/www/html/your-project/backend/public\"</code>: 지정된 디렉토리에 대한 구성 블록을 시작합니다.</p>\n<p>Options All: 이 디렉토리에 대해 사용 가능한 모든 옵션을 허용합니다.</p>\n<p>AllowOverride All: 이 디렉토리에서 .htaccess 파일을 사용하여 구성 재정의를 허용합니다.</p>\n<p>Require all granted: 모든 사용자에게 액세스를 부여합니다.</p>\n<p><code>/Directory</code>: 지정된 디렉토리에 대한 구성 블록을 종료합니다.</p>\n<p><code>/VirtualHost</code> : VirtualHost 블록을 종료합니다.</p>\n<h1>설정 목적:</h1>\n<ul>\n<li>이 구성 블록은 Apache가 지정된 도메인 (localhost 및 192.168.0.88)에 대한 SSL 연결을 어떻게 처리해야 하는지를 보장합니다. SSL 인증서 파일을 가리키고 연관 디렉토리에 대한 액세스 설정을 정의합니다.</li>\n<li>\"/var/www/html/your-project\"와 같은 자리 표시자를 프로젝트에서 실제 사용하는 경로로 교체해야 합니다.</li>\n</ul>\n<p>그런 다음 활성화하세요:</p>\n<pre><code class=\"hljs language-js\">sudo a2ensite your-site.<span class=\"hljs-property\">conf</span>\n</code></pre>\n<h1>단계 7: 아파치 재시작</h1>\n<pre><code class=\"hljs language-js\">sudo systemctl restart apache2\n</code></pre>\n<p>SSL/TLS 키의 암호를 입력하라는 프롬프트가 표시됩니다.</p>\n<h1>단계 8: Apache 오류 로그 확인</h1>\n<pre><code class=\"hljs language-bash\">sudo <span class=\"hljs-built_in\">tail</span> -f /var/log/apache2/error.log\n</code></pre>\n<p>SSL과 관련된 오류 메시지를 확인해 보세요.</p>\n<h1>단계 9: 라라벨 저장소 권한 설정</h1>\n<pre><code class=\"hljs language-js\">cd /<span class=\"hljs-keyword\">var</span>/www/html/your-project/backend\nsudo chmod -R <span class=\"hljs-number\">775</span> storage\nsudo chown -R www-<span class=\"hljs-attr\">data</span>:www-data storage\n</code></pre>\n<p>이제 <a href=\"https://192.168.0.88\" rel=\"nofollow\" target=\"_blank\">https://192.168.0.88</a> (당신의 IP)에서 애플리케이션에 안전하게 액세스할 수 있어야 합니다.</p>\n<h1>단계 10: React/Laravel 애플리케이션을 실행 중이라면</h1>\n<p>프론트엔드 환경에서:</p>\n<p>REACT_APP_NAME = 'your-project'\nREACT_APP_VERSION = v1.1.0\nGENERATE_SOURCEMAP = false</p>\n<p>REACT_APP_API_BASE_URL='<a href=\"https://192.168.0.88/api\" rel=\"nofollow\" target=\"_blank\">https://192.168.0.88/api</a>'\nREACT_APP_ASSET_BASE_URL='<a href=\"https://192.168.0.88/storage\" rel=\"nofollow\" target=\"_blank\">https://192.168.0.88/storage</a>'\nREACT_APP_MAIN_DOMAIN='192.168.0.88:3000'\nREACT_APP_API_DOMAIN='<a href=\"https://192.168.0.88\" rel=\"nofollow\" target=\"_blank\">https://192.168.0.88</a>'\nREACT_APP_BACK_DOMAIN = '<a href=\"https://192.168.0.88\" rel=\"nofollow\" target=\"_blank\">https://192.168.0.88</a>'</p>\n<p>REACT_APP_SITE_KEY = 'your-key'</p>\n<p>in backend env :</p>\n<p>APP_URL=<a href=\"https://192.168.0.88\" rel=\"nofollow\" target=\"_blank\">https://192.168.0.88</a>\nAPP_SITE_URL=\"<a href=\"https://192.168.0.88:3000\" rel=\"nofollow\" target=\"_blank\">https://192.168.0.88:3000</a>\"</p>\n<p>축하합니다! Ubuntu에서 Apache 웹 서버에 대한 Subject Alternative Name이 포함된 자체 서명 SSL 인증서를 성공적으로 생성했습니다.</p>\n<p>문제가 있으면 다음을 실행해 보세요</p>\n<pre><code class=\"hljs language-js\">sudo systemctl restart apache2\n</code></pre>\n<pre><code class=\"hljs language-js\">cd /<span class=\"hljs-keyword\">var</span>/www/html/your-project/backend\nsudo chmod -R <span class=\"hljs-number\">775</span> storage\nsudo chown -R www-<span class=\"hljs-attr\">data</span>:www-data storage\n</code></pre>\n<h1>(선택 사항) /etc/hosts 파일 업데이트</h1>\n<p>친구야, 아래와 같이 /etc/hosts 파일에 localhost와 192.168.0.88(IP 주소)의 항목이 있는지 확인해 주세요.</p>\n<h1>(선택 사항) Chrome에서 인증서를 가져오는 방법:</h1>\n<ul>\n<li>권한 생성 및 인증서를 CRT 형식으로 변환:</li>\n</ul>\n<pre><code class=\"hljs language-js\">openssl x509 -<span class=\"hljs-keyword\">in</span> server.<span class=\"hljs-property\">cert</span> -out server.<span class=\"hljs-property\">crt</span>\n</code></pre>\n<ul>\n<li>PKCS#12 형식으로 인증서 및 키 변환하기:</li>\n</ul>\n<pre><code class=\"hljs language-js\">openssl pkcs12 -<span class=\"hljs-keyword\">export</span> -out certificate.<span class=\"hljs-property\">pfx</span> -inkey private.<span class=\"hljs-property\">key</span> -<span class=\"hljs-keyword\">in</span> server.<span class=\"hljs-property\">cert</span>\n</code></pre>\n<p>개인 키의 암호를 입력하라는 프롬프트가 표시됩니다.</p>\n<ol start=\"3\">\n<li>Chrome에 인증서 가져오기:</li>\n</ol>\n<ul>\n<li>크롬을 열고 설정으로 이동합니다.</li>\n<li>아래로 스크롤하여 고급을 클릭합니다.</li>\n<li>개인 정보 및 보안 아래에서 인증서 관리를 클릭합니다.</li>\n<li>인증서 창에서 개인 탭으로 이동합니다.</li>\n<li>가져오기를 클릭하고 생성한 certificate.pfx 파일을 선택합니다.</li>\n<li>가져오기 마법사를 따라가고 암호를 입력하고 나오면 상점을 선택합니다.</li>\n</ul>\n<ol start=\"4\">\n<li>신뢰할 수 있는 인증 기관(CA)을 추가하려면 다음을 수행하십시오:</li>\n</ol>\n<pre><code class=\"hljs language-js\">sudo cp server.<span class=\"hljs-property\">crt</span> /usr/local/share/ca-certificates/server.<span class=\"hljs-property\">crt</span>\nsudo update-ca-certificates\n</code></pre>\n<p>다음 명령을 사용하여 인증서가 신뢰 목록에 추가되었는지 확인하십시오:</p>\n<pre><code class=\"hljs language-js\">awk -v cmd=<span class=\"hljs-string\">'openssl x509 -noout -subject'</span> <span class=\"hljs-string\">' /BEGIN/{close(cmd)};{print | cmd}'</span> &#x3C; <span class=\"hljs-regexp\">/etc/</span>ssl/certs/ca-certificates.<span class=\"hljs-property\">crt</span> | grep -i localhost\n</code></pre>\n<p>인증서의 전체 세부 정보를 확인하려면 OpenSSL 또는 다른 도구를 사용할 수 있습니다. 예를 들어 OpenSSL을 사용하여 다음과 같이 실행할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">openssl x509 -<span class=\"hljs-keyword\">in</span> server.<span class=\"hljs-property\">cert</span> -text -noout\n</code></pre>\n<p>만료 날짜 확인: SSL 인증서가 만료되지 않았는지 확인하십시오. 다음 OpenSSL 명령어를 사용하여 만료 날짜를 확인할 수 있습니다.```</p>\n<pre><code class=\"hljs language-js\">openssl x509 -enddate -noout -<span class=\"hljs-keyword\">in</span> server.<span class=\"hljs-property\">cert</span>\n</code></pre>\n<p>인증서 내용 확인:</p>\n<p>OpenSSL을 사용하여 인증서 및 개인 키 파일의 내용을 확인할 수 있습니다. 원하는 정보가 포함되어 있는지 확인하세요:</p>\n<pre><code class=\"hljs language-js\">openssl x509 -<span class=\"hljs-keyword\">in</span> server.<span class=\"hljs-property\">cert</span> -text -noout\nopenssl rsa -<span class=\"hljs-keyword\">in</span> private.<span class=\"hljs-property\">key</span> -text -noout\n</code></pre>\n<p>만약 필요하다면, 개인 키 파일은 암호로 보호되지 않습니다. 암호로 보호되어 있다면 개인 키에서 암호구를 제거해야 할 수도 있습니다.</p>\n<pre><code class=\"hljs language-js\">openssl rsa -<span class=\"hljs-keyword\">in</span> private.<span class=\"hljs-property\">key</span> -out private.<span class=\"hljs-property\">key</span>\n</code></pre>\n<p>인증서를 확인하려면</p>\n<pre><code class=\"hljs language-js\">openssl verify server.<span class=\"hljs-property\">crt</span>\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}