{"pageProps":{"post":{"title":"LWC에서 구성 요소 간 통신","description":"","date":"2024-05-14 15:09","slug":"2024-05-14-ComponentCommunicationinLWC","content":"\n\n![Component Communication in LWC](/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png)\n\n이 주제에서는 LWC 컴포넌트가 서로 통신하는 방법을 다룰 것입니다.\n\n컴포넌트 간에 통신하는 네 가지 방법이 있습니다.\n\n- 부모에서 자식으로의 통신\n- 자식에서 부모로의 통신\n- Pub-Sub 모델을 사용한 독립형 컴포넌트 간 통신 (구식 기술)\n- 교차 프레임워크 (VF 페이지, Aura 및 라이트닝 메시징 서비스를 사용한 LWC 간 통신)\n\n\n\n# 부모 자식간 통신\n\n부모 자식 간 통신을 하려면 아래 단계를 따라하세요.\n\n- 컴포넌트 구성을 만듭니다. 부모 클래스에서 `c-component-communication-child`와 같은 자식 컴포넌트에 액세스할 수 있습니다.\n- 자식 컴포넌트에서 부모 데이터를 보관할 public 속성을 만들어야 합니다.\n- public 속성을 만들기 위해 @api 데코레이터를 사용하십시오.\n- 부모 컴포넌트에서 자식 컴포넌트의 public 속성을 정의하려면 하이픈(-) 부호를 사용합니다. 예를 들어, 자식 컴포넌트에 @api userDetails가 있다면 부모 컴포넌트에 user-details와 같이 작성해야 합니다.\n\n## 부모에서 자식으로 통신하는 방법이 4가지 있습니다.\n\n\n\nA. 자식에게 기본 데이터 전달\nB. 자식에게 비 기본 데이터 전달\nC. 작업 이벤트에서 자식에게 데이터 전달\nD. 자식 메서드를 부모에서 호출\n\n자식에게 기본 데이터 전달\n--- --- --- --- --- --- --- ---\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_1.png)\n\n\n\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_2.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_3.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_4.png)\n\n\n\n\n결과\n\n<img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_5.png\" />\n\n## 자식에게 비 기본 데이터 전달\n\n---\n\n\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_6.png)\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_7.png)\n\n자식 컴포넌트\n\n\n\n\n![Component Communication in LWC - Step 8](/assets/img/2024-05-14-ComponentCommunicationinLWC_8.png)\n\n![Component Communication in LWC - Step 9](/assets/img/2024-05-14-ComponentCommunicationinLWC_9.png)\n\n### Result\n\n![Component Communication in LWC - Step 10](/assets/img/2024-05-14-ComponentCommunicationinLWC_10.png)\n\n\n\n\n## 액션 이벤트 발생 시 자식에 데이터 전달\n\n---\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_11.png)\n\n\n\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_12.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_13.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_14.png)\n\n\n\n\n결과\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*YiKgaCBRXqveyetchoFM8A.gif\" />\n\n## 부모에게 자식 메서드 호출하기\n\n---\n\n\n\n이 코드를 사용하면 querySelector 매개변수에 자식 컴포넌트 이름을 전달하여 자식 컴포넌트 메서드를 호출할 수 있습니다.\n예시: this.template.querySelector('c-component-communication-child').childMethod().\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_15.png)\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_16.png)\n\n\n\nChild Component\n\n![Component Communication in LWC](/assets/img/2024-05-14-ComponentCommunicationinLWC_17.png)\n\n![Component Communication in LWC](/assets/img/2024-05-14-ComponentCommunicationinLWC_18.png)\n\nResult\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*TkpNP-vozpdAfIjKnElUeA.gif)\n\n# 자식에서 부모로 통신하기\n\n자식에서 부모로 통신하려면 사용자 지정 이벤트를 사용하고 해당 이벤트를 발송해야 합니다. 하지만 사용자 지정 이벤트로 넘어가기 전에 먼저 이벤트가 무엇인지 알아보겠습니다.\n\n이벤트란 무엇인가?\nJS와 HTML의 상호 작용은 모두 이벤트를 통해 처리됩니다. 사용자나 브라우저가 페이지를 조작하려고 할 때 해당 페이지가 로드될 때 이를 이벤트라고 합니다. 모든 이벤트는 'on' 키워드로 시작합니다.\n\n\n\n\n예를 들어, onclick, onchange, onkeyup 등.\n\n## 커스텀 이벤트 생성 및 발송\n\n커스텀 이벤트를 생성하려면 CustomEvent() 생성자를 사용하세요. 이 생성자에는 이벤트 유형을 나타내는 문자열이 필수 매개변수로 전달되어야 합니다.\n\n커스텀 이벤트를 발송하려면 EventTarget.dispatchEvent()를 사용하세요. LWC에서 EventTarget는 this를 의미합니다.\n\n\n\n부모 컴포넌트\n\n![이미지1](/assets/img/2024-05-14-ComponentCommunicationinLWC_19.png)\n\n![이미지2](/assets/img/2024-05-14-ComponentCommunicationinLWC_20.png)\n\n자식 컴포넌트\n\n\n\n\n![Screenshot 1](/assets/img/2024-05-14-ComponentCommunicationinLWC_21.png)\n\n![Screenshot 2](/assets/img/2024-05-14-ComponentCommunicationinLWC_22.png)\n\nResult\n\n![Animation](https://miro.medium.com/v2/resize:fit:1400/1*4gUjy7HDpHBU0m-ucNilTQ.gif)\n\n\n\n\n# Pub-Sub 모델을 사용한 독립 구성 요소 간 통신\n\n두 개의 독립 구성 요소 간의 통신을 위해 두 가지 기술인 1) Pub-Sub 모델과 2) 라이트닝 메시지 서비스(LMS)를 사용합니다.\n\n이 주제에서는 Pub-Sub 모델을 사용하여 독립 구성 요소 간 통신하는 방법을 배워 보겠습니다.\n\n먼저, 원하는 이름으로 컴포넌트를 만들어야 합니다. 저는 pubsub이라는 이름을 사용했습니다.\n해당 컴포넌트에는 아래 코드를 js 파일에 붙여넣으십시오.\n\n\n\n```js\n/* eslint-disable no-console */\nconst store = {};\n/**\n * 이벤트에 대한 콜백 함수를 구독합니다.\n * @param {string} eventName - 청취할 이벤트의 이름.\n * @param {function} callback - 해당 이벤트가 발생했을 때 호출할 함수.\n */\n\nconst subscribe = (eventName, callback) => {\n    if (!store[eventName]) {\n        store[eventName] = new Set();\n    }\n    store[eventName].add(callback);\n};\n\n/**\n * 이벤트에 대한 콜백 함수 구독을 취소합니다.\n * @param {string} eventName - 구독을 취소할 이벤트의 이름.\n * @param {function} callback - 구독을 취소할 함수.\n */\nconst unsubscribe = (eventName, callback) => {\n    if (store[eventName]) {\n        store[eventName].delete(callback);\n    }\n};\n\n/**\n * 청취자에게 이벤트를 발행합니다.\n * @param {string} eventName - 발행할 이벤트의 이름.\n * @param {*} payload - 발행할 이벤트의 페이로드.\n */\n\nconst publish = (eventName, payload) => {\n    if (store[eventName]) {\n        store[eventName].forEach(callback => {\n            try {\n                callback(payload);\n            } catch (error) {\n                console.error(error);\n            }\n        });\n    }\n};\n\nexport default {\n    subscribe,\n    unsubscribe,\n    publish\n};\n```\n\n위의 코드에서 두 개의 매개변수를 보유하는 세 개의 Const 변수가 있습니다. 첫 번째는 eventName이고 두 번째는 콜백 메서드입니다.\n\nPubSubComp_A\n\n![ComponentCommunicationinLWC_23](/assets/img/2024-05-14-ComponentCommunicationinLWC_23.png)\n\n\n\n\n\n![PubSubComp_B](/assets/img/2024-05-14-ComponentCommunicationinLWC_25.png)\n\n![Image](/assets/img/2024-05-14-ComponentCommunicationinLWC_26.png)\n\n\n\n\n결과\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*50ZgsP84cx1CGezDS_iu6A.gif)","ogImage":{"url":"/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png\" alt=\"Component Communication in LWC\"></p>\n<p>이 주제에서는 LWC 컴포넌트가 서로 통신하는 방법을 다룰 것입니다.</p>\n<p>컴포넌트 간에 통신하는 네 가지 방법이 있습니다.</p>\n<ul>\n<li>부모에서 자식으로의 통신</li>\n<li>자식에서 부모로의 통신</li>\n<li>Pub-Sub 모델을 사용한 독립형 컴포넌트 간 통신 (구식 기술)</li>\n<li>교차 프레임워크 (VF 페이지, Aura 및 라이트닝 메시징 서비스를 사용한 LWC 간 통신)</li>\n</ul>\n<h1>부모 자식간 통신</h1>\n<p>부모 자식 간 통신을 하려면 아래 단계를 따라하세요.</p>\n<ul>\n<li>컴포넌트 구성을 만듭니다. 부모 클래스에서 <code>c-component-communication-child</code>와 같은 자식 컴포넌트에 액세스할 수 있습니다.</li>\n<li>자식 컴포넌트에서 부모 데이터를 보관할 public 속성을 만들어야 합니다.</li>\n<li>public 속성을 만들기 위해 @api 데코레이터를 사용하십시오.</li>\n<li>부모 컴포넌트에서 자식 컴포넌트의 public 속성을 정의하려면 하이픈(-) 부호를 사용합니다. 예를 들어, 자식 컴포넌트에 @api userDetails가 있다면 부모 컴포넌트에 user-details와 같이 작성해야 합니다.</li>\n</ul>\n<h2>부모에서 자식으로 통신하는 방법이 4가지 있습니다.</h2>\n<p>A. 자식에게 기본 데이터 전달\nB. 자식에게 비 기본 데이터 전달\nC. 작업 이벤트에서 자식에게 데이터 전달\nD. 자식 메서드를 부모에서 호출</p>\n<p>자식에게 기본 데이터 전달</p>\n<hr>\n<p>부모 컴포넌트</p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_1.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_2.png\" alt=\"Child Component\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_3.png\" alt=\"Child Component\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_4.png\" alt=\"Child Component\"></p>\n<p>결과</p>\n<h2>자식에게 비 기본 데이터 전달</h2>\n<hr>\n<p>부모 컴포넌트</p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_6.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_7.png\" alt=\"이미지\"></p>\n<p>자식 컴포넌트</p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_8.png\" alt=\"Component Communication in LWC - Step 8\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_9.png\" alt=\"Component Communication in LWC - Step 9\"></p>\n<h3>Result</h3>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_10.png\" alt=\"Component Communication in LWC - Step 10\"></p>\n<h2>액션 이벤트 발생 시 자식에 데이터 전달</h2>\n<hr>\n<p>부모 컴포넌트</p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_11.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_12.png\" alt=\"Child Component\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_13.png\" alt=\"Child Component\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_14.png\" alt=\"Child Component\"></p>\n<p>결과</p>\n<h2>부모에게 자식 메서드 호출하기</h2>\n<hr>\n<p>이 코드를 사용하면 querySelector 매개변수에 자식 컴포넌트 이름을 전달하여 자식 컴포넌트 메서드를 호출할 수 있습니다.\n예시: this.template.querySelector('c-component-communication-child').childMethod().</p>\n<p>부모 컴포넌트</p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_15.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_16.png\" alt=\"이미지\"></p>\n<p>Child Component</p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_17.png\" alt=\"Component Communication in LWC\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_18.png\" alt=\"Component Communication in LWC\"></p>\n<p>Result</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*TkpNP-vozpdAfIjKnElUeA.gif\" alt=\"image\"></p>\n<h1>자식에서 부모로 통신하기</h1>\n<p>자식에서 부모로 통신하려면 사용자 지정 이벤트를 사용하고 해당 이벤트를 발송해야 합니다. 하지만 사용자 지정 이벤트로 넘어가기 전에 먼저 이벤트가 무엇인지 알아보겠습니다.</p>\n<p>이벤트란 무엇인가?\nJS와 HTML의 상호 작용은 모두 이벤트를 통해 처리됩니다. 사용자나 브라우저가 페이지를 조작하려고 할 때 해당 페이지가 로드될 때 이를 이벤트라고 합니다. 모든 이벤트는 'on' 키워드로 시작합니다.</p>\n<p>예를 들어, onclick, onchange, onkeyup 등.</p>\n<h2>커스텀 이벤트 생성 및 발송</h2>\n<p>커스텀 이벤트를 생성하려면 CustomEvent() 생성자를 사용하세요. 이 생성자에는 이벤트 유형을 나타내는 문자열이 필수 매개변수로 전달되어야 합니다.</p>\n<p>커스텀 이벤트를 발송하려면 EventTarget.dispatchEvent()를 사용하세요. LWC에서 EventTarget는 this를 의미합니다.</p>\n<p>부모 컴포넌트</p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_19.png\" alt=\"이미지1\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_20.png\" alt=\"이미지2\"></p>\n<p>자식 컴포넌트</p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_21.png\" alt=\"Screenshot 1\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_22.png\" alt=\"Screenshot 2\"></p>\n<p>Result</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*4gUjy7HDpHBU0m-ucNilTQ.gif\" alt=\"Animation\"></p>\n<h1>Pub-Sub 모델을 사용한 독립 구성 요소 간 통신</h1>\n<p>두 개의 독립 구성 요소 간의 통신을 위해 두 가지 기술인 1) Pub-Sub 모델과 2) 라이트닝 메시지 서비스(LMS)를 사용합니다.</p>\n<p>이 주제에서는 Pub-Sub 모델을 사용하여 독립 구성 요소 간 통신하는 방법을 배워 보겠습니다.</p>\n<p>먼저, 원하는 이름으로 컴포넌트를 만들어야 합니다. 저는 pubsub이라는 이름을 사용했습니다.\n해당 컴포넌트에는 아래 코드를 js 파일에 붙여넣으십시오.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* eslint-disable no-console */</span>\n<span class=\"hljs-keyword\">const</span> store = {};\n<span class=\"hljs-comment\">/**\n * 이벤트에 대한 콜백 함수를 구독합니다.\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">string</span>} <span class=\"hljs-variable\">eventName</span> - 청취할 이벤트의 이름.\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">function</span>} <span class=\"hljs-variable\">callback</span> - 해당 이벤트가 발생했을 때 호출할 함수.\n */</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">subscribe</span> = (<span class=\"hljs-params\">eventName, callback</span>) => {\n    <span class=\"hljs-keyword\">if</span> (!store[eventName]) {\n        store[eventName] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();\n    }\n    store[eventName].<span class=\"hljs-title function_\">add</span>(callback);\n};\n\n<span class=\"hljs-comment\">/**\n * 이벤트에 대한 콜백 함수 구독을 취소합니다.\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">string</span>} <span class=\"hljs-variable\">eventName</span> - 구독을 취소할 이벤트의 이름.\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">function</span>} <span class=\"hljs-variable\">callback</span> - 구독을 취소할 함수.\n */</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">unsubscribe</span> = (<span class=\"hljs-params\">eventName, callback</span>) => {\n    <span class=\"hljs-keyword\">if</span> (store[eventName]) {\n        store[eventName].<span class=\"hljs-title function_\">delete</span>(callback);\n    }\n};\n\n<span class=\"hljs-comment\">/**\n * 청취자에게 이벤트를 발행합니다.\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">string</span>} <span class=\"hljs-variable\">eventName</span> - 발행할 이벤트의 이름.\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">*</span>} <span class=\"hljs-variable\">payload</span> - 발행할 이벤트의 페이로드.\n */</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">publish</span> = (<span class=\"hljs-params\">eventName, payload</span>) => {\n    <span class=\"hljs-keyword\">if</span> (store[eventName]) {\n        store[eventName].<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">callback</span> =></span> {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-title function_\">callback</span>(payload);\n            } <span class=\"hljs-keyword\">catch</span> (error) {\n                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error);\n            }\n        });\n    }\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    subscribe,\n    unsubscribe,\n    publish\n};\n</code></pre>\n<p>위의 코드에서 두 개의 매개변수를 보유하는 세 개의 Const 변수가 있습니다. 첫 번째는 eventName이고 두 번째는 콜백 메서드입니다.</p>\n<p>PubSubComp_A</p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_23.png\" alt=\"ComponentCommunicationinLWC_23\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_25.png\" alt=\"PubSubComp_B\"></p>\n<p><img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_26.png\" alt=\"Image\"></p>\n<p>결과</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*50ZgsP84cx1CGezDS_iu6A.gif\" alt=\"이미지\"></p>\n</body>\n</html>\n"},"__N_SSG":true}