{"pageProps":{"post":{"title":"JavaScript와 TypeScript 비교 정리","description":"","date":"2024-05-27 18:10","slug":"2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years","content":"\n\n\n![2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png](/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png)\n\n이 기사는 지난 3년 동안 (그리고 그 이전에서도) JavaScript/ECMAScript와 TypeScript에서 발생한 거의 모든 변경 사항을 살펴봅니다.\n\n다음의 기능들 중 일부는 여러분에게 적용되지 않거나 실용적이지 않을 수 있지만, 이러한 언어에 대한 이해를 더 깊게 하고 가능한 기능을 보여주기 위한 것입니다.\n\n많은 TypeScript 기능들을 생략했는데, 그 이유는 \"이전과 달리 예상대로 작동하지 않았으나, 지금은 그렇게 됩니다\"로 요약할 수 있습니다. 따라서 과거에 작동하지 않았던 것이 있다면, 다시 시도해 보세요.\n\n\n<div class=\"content-ad\"></div>\n\n- JavaScript / ECMAScript (가장 오래된 것부터)\n- TypeScript (가장 오래된 것부터)\n\n# 내용\n\n# ECMAScript\n\n## 과거 (아직도 중요한 이전 소개들)\n\n<div class=\"content-ad\"></div>\n\n- Tagged template literals: 템플릿 리터럴 앞에 함수 이름을 붙이면 함수가 템플릿 리터럴 및 템플릿 값들을 전달받게 됩니다. 이 방법에는 재미있는 활용법이 있습니다.\n\n```js\n// 임의의 숫자를 포함한 문자열을 로깅할 때 숫자를 형식화하는 방법을 작성하고 싶다고 가정해 봅시다.\n// 그럴 때 태그드 템플릿을 사용할 수 있습니다.\nfunction formatNumbers(strings: TemplateStringsArray, number: number): string {\n  return strings[0] + number.toFixed(2) + strings[1];\n}\nconsole.log(formatNumbers`This is the value: ${0}, it's important.`); // This is the value: 0.00, it's important.\n\n// 문자열 내의 번역 키를 \"번역\"하고 싶을 때 (여기서는 소문자로 변경)\nfunction translateKey(key: string): string {\n  return key.toLocaleLowerCase();\n}\nfunction translate(strings: TemplateStringsArray, ...expressions: string[]): string {\n  return strings.reduce((accumulator, currentValue, index) => accumulator + currentValue + translateKey(expressions[index] ?? ''), '');\n}\nconsole.log(translate`Hello, this is ${'NAME'} to say ${'MESSAGE'}.`); // Hello, this is name to say message.\n```\n\n- Symbols: 객체에 대한 고유 키: Symbol(\"foo\") === Symbol(\"foo\"); // false. 내부적으로 사용됩니다.\n\n```js\nconst obj: { [index: string]: string } = {};\n\nconst symbolA = Symbol('a');\nconst symbolB = Symbol.for('b');\n\nconsole.log(symbolA.description); // \"a\"\n\nobj[symbolA] = 'a';\nobj[symbolB] = 'b';\nobj['c'] = 'c';\nobj.d = 'd';\n\nconsole.log(obj[symbolA]); // \"a\"\nconsole.log(obj[symbolB]); // \"b\"\n\n// 다른 심볼이나 심볼 없이는 키에 액세스할 수 없습니다.\nconsole.log(obj[Symbol('a')]); // undefined\nconsole.log(obj['a']); // undefined\n\n// for ... in을 사용할 때 키가 열거되지 않습니다.\nfor (const i in obj) {\n  console.log(i); // \"c\", \"d\"\n}\n```  \n\n<div class=\"content-ad\"></div>\n\n## ES2020\n\n- Optional chaining: 잠재적으로 정의되지 않은 객체의 값을 (인덱싱을 통해) 액세스하기 위해 부모 객체 이름 뒤에 ?를 사용하여 선택적 연결을 사용할 수 있습니다. 이는 인덱싱 ([...]) 또는 함수 호출에도 사용할 수 있습니다.\n\n```js\n// 이전:\n// 우리가 정확히 정의된 것인지 확신할 수 없는 객체 변수 (또는 다른 구조)가 있을 때,\n// 속성에 쉽게 액세스할 수 없습니다.\nconst object: { name: string } | undefined = Math.random() > 0.5 ? undefined : { name: 'test' };\nconst value = object.name; // 타입 오류: 'object' 가 'undefined' 일 수 있습니다.\n\n// 먼저 정의되었는지 확인해야 했지만, 이는 가독성을 해치며 중첩된 객체에 대해 복잡해집니다.\nconst objectOld: { name: string } | undefined = Math.random() > 0.5 ? undefined : { name: 'test' };\nconst valueOld = objectOld ? objectOld.name : undefined;\n\n// 새로운 방법:\n// 대신 선택적 연결을 사용할 수 있습니다.\nconst objectNew: { name: string } | undefined = Math.random() > 0.5 ? undefined : { name: 'test' };\nconst valueNew = objectNew?.name;\n\n// 이것은 인덱싱 및 함수에도 사용할 수 있습니다.\nconst array: string[] | undefined = Math.random() > 0.5 ? undefined : ['test'];\nconst item = array?.[0];\nconst func: (() => string) | undefined = Math.random() > 0.5 ? undefined : () => 'test';\nconst result = func?.();\n```\n\n- 널 병합 연산자 (??): 조건부 할당을 위해 || 연산자를 사용하는 대신 새로운 ?? 연산자를 사용할 수 있습니다. 모든 거짓 값에 적용되는 대신 undefined와 null에만 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst value: string | undefined = Math.random() > 0.5 ? undefined : 'test';\n\n// 이전:\n// 값이 undefined 또는 null인 경우 다른 값으로 조건적으로 할당하려면 \"||\" 연산자를 사용할 수 있었습니다.\nconst anotherValue = value || 'hello';\nconsole.log(anotherValue); // \"test\" 또는 \"hello\"\n\n// 이는 참 값 사용 시 잘 작동하지만, 0이나 빈 문자열과 비교할 경우에도 적용됩니다.\nconst incorrectValue = '' || 'incorrect';\nconsole.log(incorrectValue); // 항상 \"incorrect\"\nconst anotherIncorrectValue = 0 || 'incorrect';\nconsole.log(anotherIncorrectValue); // 항상 \"incorrect\"\n\n// 새로운 방법:\n// 이제 nullish 병합 연산자를 사용할 수 있습니다. 이는 오직 undefined와 null 값에만 적용됩니다.\nconst newValue = value ?? 'hello';\nconsole.log(newValue) // 항상 \"hello\"\n\n// 이제 falsy 값들이 교체되지 않습니다.\nconst correctValue = '' ?? 'incorrect';\nconsole.log(correctValue); // 항상 \"\"\nconst anotherCorrectValue = 0 ?? 'incorrect';\nconsole.log(anotherCorrectValue); // 항상 0\n```\n\n- import(): 변수를 사용하여 런타임에서 동적으로 import ... from ... 처럼 모듈을 가져올 수 있습니다.\n\n```js\nlet importModule;\nif (shouldImport) {\n  importModule = await import('./module.mjs');\n}\n```\n\n- String.matchAll(): 루프를 사용하지 않고 정규 표현식의 여러 일치 항목과 캡처 그룹을 모두 얻을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst stringVar = 'testhello,testagain,';\n\n// 이전:\n// 일치 항목만 검색되며 캡처 그룹은 포함되지 않습니다.\nconsole.log(stringVar.match(/test([\\w]+?),/g)); // [\"testhello,\", \"testagain,\"]\n\n// 캡처 그룹을 포함한 하나의 일치 항목만 검색합니다.\nconst singleMatch = stringVar.match(/test([\\w]+?),/);\nif (singleMatch) {\n  console.log(singleMatch[0]); // \"testhello,\"\n  console.log(singleMatch[1]); // \"hello\"\n}\n\n// 같은 결과를 얻지만 매우 직관적이지 않습니다 (exec 메서드는 마지막 인덱스를 저장합니다).\n// 루프 외부에서 정의되어야 하며 전역으로 선언되어야 하며 (/g) 모드여야 합니다.\nconst regex = /test([\\w]+?),/g;\nlet execMatch;\nwhile ((execMatch = regex.exec(stringVar)) !== null) {\n  console.log(execMatch[0]); // \"testhello,\", \"testagain,\"\n  console.log(execMatch[1]); // \"hello\", \"again\"\n}\n\n// 새로운 방법:\n// 정규식은 전역 (/g)이어야 합니다. 그렇지 않으면 작동하지 않습니다.\nconst matchesIterator = stringVar.matchAll(/test([\\w]+?),/g);\n// 순회해야 하거나 배열(Array.from())로 변환해야 하며 직접 색인화(인덱싱)할 수 없습니다.\nfor (const match of matchesIterator) {\n  console.log(match[0]); // \"testhello,\", \"testagain,\"\n  console.log(match[1]); // \"hello\", \"again\"\n}\n```\n\n- Promise.allSettled(): Promise.all()과 유사하지만 모든 Promise가 완료될 때까지 기다리며 첫 번째 reject/throw에서 반환하지 않습니다. 모든 오류 처리를 보다 쉽게 할 수 있습니다.\n\n```js\nasync function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n\n// 이전:\nconsole.log(await Promise.all([success1(), success2()])); // [\"a\", \"b\"]\n// 하지만:\ntry {\n  await Promise.all([success1(), success2(), fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 주의: 하나의 에러만 처리하고 성공 값에 액세스할 수 없습니다.\n\n// 이전 해결 방법 (정말 최적이 아님):\nconsole.log(await Promise.all([ // [\"a\", \"b\", undefined, undefined]\n  success1().catch(e => { console.log(e); }),\n  success2().catch(e => { console.log(e); }),\n  fail1().catch(e => { console.log(e); }), // \"fail 1\"\n  fail2().catch(e => { console.log(e); })])); // \"fail 2\"\n\n// 새로운 방법:\nconst results = await Promise.allSettled([success1(), success2(), fail1(), fail2()]);\nconst sucessfulResults = results\n  .filter(result => result.status === 'fulfilled')\n  .map(result => (result as PromiseFulfilledResult<string>).value);\nconsole.log(sucessfulResults); // [\"a\", \"b\"]\nresults.filter(result => result.status === 'rejected').forEach(error => {\n  console.log((error as PromiseRejectedResult).reason); // \"fail 1\", \"fail 2\"\n});\n// 또는:\nfor (const result of results) {\n  if (result.status === 'fulfilled') {\n    console.log(result.value); // \"a\", \"b\"\n  } else if (result.status === 'rejected') {\n    console.log(result.reason); // \"fail 1\", \"fail 2\"\n  }\n}\n```\n\n- BigInt: 새로운 BigInt 데이터 유형을 사용하여 큰 (정수) 숫자를 정확하게 저장하고 처리할 수 있어 JavaScript가 숫자를 부동 소수점으로 저장하는 것에 의한 오류를 방지할 수 있습니다. BigInt() 생성자를 사용하여 생성할 수 있고(불완전성을 방지하기 위해 문자열을 선호) 또는 숫자 끝에 n을 추가하여 생성할 수 있습니다.\n  \n\n<div class=\"content-ad\"></div>\n\n```md\n// 이전:\n// JavaScript는 숫자를 부동 소수점으로 저장하기 때문에 항상 약간의 부정확성이 있습니다.\n// 더 중요한 것은 특정 숫자 이후에 정수 연산에 부정확성이 시작됩니다.\nconst maxSafeInteger = 9007199254740991;\nconsole.log(maxSafeInteger === Number.MAX_SAFE_INTEGER); // true\n\n// 해당 숫자보다 큰 숫자와 비교하면 부정확성이 발생할 수 있습니다.\nconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2);\n\n// NEW:\n// BigInt 데이터 형식을 사용하면 이론적으로 무한히 큰 (정수) 숫자를 저장하고 조작할 수 있습니다.\n// 숫자 끝에 \"n\"을 추가하거나 BigInt 생성자를 사용하여 사용합니다.\nconst maxSafeIntegerPreviously = 9007199254740991n;\nconsole.log(maxSafeIntegerPreviously); // 9007199254740991\n\nconst anotherWay = BigInt(9007199254740991);\nconsole.log(anotherWay); // 9007199254740991\n\n// 안전한 정수(Number.MAX_SAFE_INTEGER)보다 큰 정수를 전달하면 안됩니다.\nconst incorrect = BigInt(9007199254740992);\nconsole.log(incorrect); // 9007199254740992\nconst incorrectAgain = BigInt(9007199254740993);\nconsole.log(incorrectAgain); // 9007199254740992\n// 오랜, 동일한 값으로 변환됩니다.\n\n// 대신 문자열을 사용하거나 더 좋은 다른 구문을 사용합니다.\nconst correct = BigInt('9007199254740993');\nconsole.log(correct); // 9007199254740993\nconst correctAgain = 9007199254740993n;\nconsole.log(correctAgain); // 9007199254740993\n\n// 16진수, 8진수 및 2진수도 문자열로 전달할 수 있습니다.\nconst hex = BigInt('0x1fffffffffffff');\nconsole.log(hex); // 9007199254740991\nconst octal = BigInt('0o377777777777777777');\nconsole.log(octal); // 9007199254740991\nconst binary = BigInt('0b11111111111111111111111111111111111111111111111111111');\nconsole.log(binary); // 9007199254740991\n\n// 대부분의 산술 연산은 예상대로 작동하지만 다른 연산자도 BigInt 여야합니다. 모든 연산도 BigInt를 반환합니다.\nconst addition = maxSafeIntegerPreviously + 2n;\nconsole.log(addition); // 9007199254740993\n\nconst multiplication = maxSafeIntegerPreviously * 2n;\nconsole.log(multiplication); // 18014398509481982\n\nconst subtraction = multiplication - 10n;\nconsole.log(subtraction); // 18014398509481972\n\nconst modulo = multiplication % 10n;\nconsole.log(modulo); // 2\n\nconst exponentiation = 2n ** 54n;\nconsole.log(exponentiation); // 18014398509481984\n\nconst exponentiationAgain = 2n ^ 54n;\nconsole.log(exponentiationAgain); // 18014398509481984\n\nconst negative = exponentiation * -1n;\nconsole.log(negative); // -18014398509481984\n\n// BigInt로 인한 정수 나눗셈은 조금 다르게 작동합니다.\nconst division = multiplication / 2n;\nconsole.log(division); // 9007199254740991\n// 나뉠 수 있는 정수에 대해서는 제대로 작동합니다.\n\n// 나누기가 안 되는 숫자에 대해서는 정수 나눗셈(내림)처럼 작동할 것입니다.\nconst divisionAgain = 5n / 2n;\nconsole.log(divisionAgain); // 2\n\n// 일치하는(엄격한) 비교가 BigInt 숫자에는 적용되지 않습니다.\nconsole.log(0n === 0); // false\nconsole.log(0n == 0); // true\n\n// 그러나 비교는 예상대로 작동합니다.\nconsole.log(1n < 2); // true\nconsole.log(2n > 1); // true\nconsole.log(2 > 2); // false\nconsole.log(2n > 2); // false\nconsole.log(2n >= 2); // true\n\n// 타입은 \"bigint\"입니다.\nconsole.log(typeof 1n); // \"bigint\"\n\n// 일반 숫자(부호있는 부호 없는 (음수 없음))로 다시 변환할 수 있습니다.\n// 그러나 이는 정확도를 희생합니다. 유효 숫자의 수를 지정할 수 있습니다.\n\nconsole.log(BigInt.asIntN(0, -2n)); // 0\nconsole.log(BigInt.asIntN(1, -2n)); // 0\nconsole.log(BigInt.asIntN(2, -2n)); // -2\n// 보통 더 높은 비트 수를 사용할 것입니다.\n\n// 음수 숫자는 부호가 있는 숫자로 변환될 때 2의 보수로 변환됩니다.\nconsole.log(BigInt.asUintN(8, -2n)); // 254\n```\n\n- globalThis: 환경(브라우저, NodeJS, ...)와 상관없이 전역 컨텍스트에서 변수에 액세스할 수 있습니다. 여전히 권장되지는 않지만 때로는 필요합니다. 브라우저의 최상위 수준에서 this와 유사합니다.\n\n```md\nconsole.log(globalThis.Math); // Math Object\n```\n\n- import.meta: ES-모듈을 사용할 때 현재 모듈 URL import.meta.url을 얻습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconsole.log(import.meta.url); // \"file://...\"\n```\n\n- export * as … from …: 쉽게 기본값을 하위 모듈로 다시 내보냅니다.\n\n```js\nexport * as am from 'another-module'\n```\n\n```js\nimport { am } from 'module'\n```\n\n<div class=\"content-ad\"></div>\n\n## ES2021\n\n- String.replaceAll(): 이제 문자열 내에서 부분 문자열의 모든 인스턴스를 대체할 수 있습니다. 더 이상 항상 전역 플래그(/g)를 사용하는 정규 표현식을 사용할 필요가 없습니다.\n\n```js\nconst testString = 'hello/greetings everyone/everybody';\n// 이전:\n// 첫 번째 인스턴스만 대체함\nconsole.log(testString.replace('/', '|')); // 'hello|greetings everyone/everybody'\n\n// 대체하기 위해 정규 표현식을 사용해야 했는데, 이는 성능이 좋지 않고 이스케이프가 필요합니다.\n// 전역 플래그(/g)를 참고하세요.\nconsole.log(testString.replace(/\\//g, '|')); // 'hello|greetings everyone|everybody'\n\n// 새로운 기능:\n// replaceAll을 사용하면 더 명확하고 빠릅니다.\nconsole.log(testString.replaceAll('/', '|')); // 'hello|greetings everyone|everybody'\n```\n\n- Promise.any(): 프로미스 목록 중 하나의 결과만 필요한 경우, 첫 번째 결과를 반환합니다. 모든 프로미스가 거부될 때만 거부하고 AggregateError를 반환하며, 즉시 거부되는 Promise.race가 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconsole.log(await Promise.race([success1(), success2()])); // \"a\"\n// 그러나:\ntry {\n  await Promise.race([fail1(), fail2(), success1(), success2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 유의: 하나의 오류만 catch하고 성공 값을 액세스할 수 없습니다.\n\n// 이전 수정 (정말 최적화되지 않음):\nconsole.log(await Promise.race([ // \"a\"\n  fail1().catch(e => { console.log(e); }), // \"fail 1\"\n  fail2().catch(e => { console.log(e); }), // \"fail 2\"\n  success1().catch(e => { console.log(e); }),\n  success2().catch(e => { console.log(e); })]));\n\n// 새로운:\nconsole.log(await Promise.any([fail1(), fail2(), success1(), success2()])); // \"a\"\n// 모든 프로미스가 거부될 때만 거부하고 모든 오류를 포함하는 AggregateError를 리턴합니다.\ntry {\n  await Promise.any([fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // [AggregateError: All promises were rejected]\n  console.log(e.errors); // [\"fail 1\", \"fail 2\"]\n}\n```\n\n- Nullish coalescing assignment (??=): 이전에 \"nullish\"였을 때만 값을 할당합니다 (null 또는 undefined).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () => 'b';\n\n// undefined는 nullish이므로 새 값이 x1에 할당됩니다.\nx1 ??= 'b';\nconsole.log(x1) // \"b\"\n\n// 문자열은 nullish가 아니므로 x2에 새 값이 할당되지 않습니다.\n// 또한 참고: getNewValue()가 실행되지 않습니다.\nx2 ??= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- Logical and assignment (&&=): 이전에 \"truthy\"였을 때만 값을 할당합니다 (true 또는 true로 변환되는 값).```\n\n<div class=\"content-ad\"></div>\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () => 'b';\n\n// 지정되지 않은 값인 x1에 새 값이 할당되지 않습니다. 왜냐하면 지정되지 않은 값은 참이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx1 &&= getNewValue();\nconsole.log(x1) // undefined\n\n// 문자열은 참이므로 새 값이 x2에 할당됩니다.\nx2 &&= 'b';\nconsole.log(x2) // \"b\"\n```\n\n- 논리 또는 할당 (||=): 이전에 \"거짓\"인 경우에만 값이 할당됩니다 (false 또는 false로 변환).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () => 'b';\n\n// x1에 새 값이 할당됩니다. 왜냐하면 지정되지 않은 값은 거짓이기 때문입니다.\nx1 ||= 'b';\nconsole.log(x1) // \"b\"\n\n// x2에 새 값이 할당되지 않습니다. 왜냐하면 문자열은 거짓이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx2 ||= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- WeakRef: 객체가 가비지 수집되는 것을 방지하지 않고 객체에 \"약한\" 참조를 보유합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst ref = new WeakRef(element);\n\n// 만약 객체/요소가 여전히 존재하고 쓰레기 수집되지 않았다면 값을 가져옵니다.\nconst value = ref.deref;\nconsole.log(value); // undefined\n// 객체가 더는 존재하지 않는 것 같습니다.\n```\n\n- 숫자 리터럴 구분자 (_): 가독성을 위해 숫자를 _로 구분합니다. 이는 기능에 영향을 미치지 않습니다.\n\n```js\nconst int = 1_000_000_000;\nconst float = 1_000_000_000.999_999_999;\nconst max = 9_223_372_036_854_775_807n;\nconst binary = 0b1011_0101_0101;\nconst octal = 0o1234_5670;\nconst hex = 0xD0_E0_F0;\n```\n\n## ES2022\n  \n\n<div class=\"content-ad\"></div>\n\n- 최상위 대기: await 키워드는 이제 ES 모듈의 최상위 수준에서 사용할 수 있습니다. 이는 래퍼 함수의 필요성을 제거하고 오류 처리를 개선합니다.\n\n```js\nasync function asyncFuncSuccess() {\n  return 'test';\n}\n\nasync function asyncFuncFail() {\n  throw new Error('Test');\n}\n\n// 이전:\n// 프로미스를 대기하려면 async 함수 내부에서만 가능했습니다.\n// await asyncFuncSuccess(); // SyntaxError: await is only valid in async functions\n// 따라서 async 함수 내부로 래핑해야 했고 이는 오류 처리와 최상위 동시성을 잃게 했습니다.\ntry {\n  (async () => {\n    console.log(await asyncFuncSuccess()); // \"test\"\n    try {\n      await asyncFuncFail();\n    } catch (e) {\n      // 오류 처리를 위해 필요합니다. 그렇지 않으면 오류가 캐치되지 않거나 적절한 추적 없이 너무 늦게 되어버립니다.\n      console.error(e); // Error: \"Test\"\n      throw e;\n    }\n  })();\n} catch (e) {\n  // 함수가 async여서 절대 호출되지 않거나(적절한 추적이 없거나 너무 늦게) 이유 때문에\n  console.error(e);\n}\n\n// 비동기 함수가 기다려지지 않았기 때문에 이 프로미스 결과보다 먼저 기록됩니다.\nconsole.log('Hey'); // \"Hey\"\n\n// 새로운:\n// 파일이 ES 모듈이라면(package.json에 설정되었고, exports가 있고, \".mts\"로 명명된 경우) 최상위 수준에서 바로 await할 수 있습니다.\nconsole.log(await asyncFuncSuccess()); // \"test\"\ntry {\n  await asyncFuncFail();\n} catch (e) {\n  console.error(e); // Error: \"Test\"\n}\n\n// 모든 비동기 호출이 기다려지기 때문에 이 프로미스 결과 뒤에 기록됩니다.\nconsole.log('Hello'); // \"Hello\"\n```\n\n- #private: 클래스 멤버(속성 및 메서드)를 이름이 #로 시작하게하여 비공개로 만듭니다. 따라서 이러한 멤버는 클래스 내부에서만 액세스할 수 있습니다. 삭제되거나 동적으로 할당할 수 없습니다. 잘못된 동작은 JavaScript(하지만 TypeScript가 아닌) 구문 오류를 발생시킵니다. TypeScript 프로젝트에서는 권장되지 않습니다. 대신 기존 private 키워드를 사용하십시오.\n\n```js\nclass ClassWithPrivateField {\n  #privateField;\n  #anotherPrivateField = 4;\n\n  constructor() {\n    this.#privateField = 42; // 유효\n    delete this.#privateField; // 구문 오류\n    this.#undeclaredField = 444; // 구문 오류\n    console.log(this.#anotherPrivateField); // 4\n  }\n}\n\nconst instance = new ClassWithPrivateField();\ninstance.#privateField === 42; // 구문 오류\n```\n\n<div class=\"content-ad\"></div>\n\n- static 클래스 멤버: 클래스 필드(속성 및 메서드)를 static으로 표시하세요.\n\n```js\nclass Logger {\n  static id = 'Logger1';\n  static type = 'GenericLogger';\n  static log(message: string | Error) {\n    console.log(message);\n  }\n}\n\nclass ErrorLogger extends Logger {\n  static type = 'ErrorLogger';\n  static qualifiedType;\n  static log(e: Error) {\n    return super.log(e.toString());\n  }\n}\n\nconsole.log(Logger.type); // \"GenericLogger\"\nLogger.log('Test'); // \"Test\"\n\n// 정적으로만 있는 클래스를 생성하는 것은 무의미하지만 여기선 시연을 위해 수행되었습니다.\nconst log = new Logger();\n\nErrorLogger.log(new Error('Test')); // 에러: \"Test\" (부모 클래스의 생성에 영향을 받지 않음)\nconsole.log(ErrorLogger.type); // \"ErrorLogger\"\nconsole.log(ErrorLogger.qualifiedType); // undefined\nconsole.log(ErrorLogger.id); // \"Logger1\"\n\n// log()가 인스턴스 메서드가 아닌 정적 메서드이기 때문에 예외를 발생시킵니다.\nconsole.log(log.log()); // log.log is not a function\n```\n\n- 클래스 내의 정적 초기화 블록: 클래스가 초기화될 때 실행되는 블록, 기본적으로 정적 멤버를 초기화하는 \"생성자\"입니다.\n\n```js\nclass Test {\n  static staticProperty1 = '속성 1';\n  static staticProperty2;\n  static {\n    this.staticProperty2 = '속성 2';\n  }\n}\n\nconsole.log(Test.staticProperty1); // \"Property 1\"\nconsole.log(Test.staticProperty2); // \"Property 2\"\n```\n\n<div class=\"content-ad\"></div>\n\n- 가져오기 어설션 (비표준, V8에서 구현됨): 가져온 항목의 유형을 확인하기 위해 사용할 수 있습니다. `import ... from ... assert ' type: `json` '`로 JSON을 직접 가져오고 구문 분석할 필요 없이 사용할 수 있습니다.\n\n```js\nimport json from './foo.json' assert { type: 'json' };\nconsole.log(json.answer); // 42\n```\n\n- 정규표현식 일치 인덱스: 정규표현식 일치 및 캡처 그룹의 시작 및 끝 인덱스를 가져올 수 있습니다. RegExp.exec(), String.match() 및 String.matchAll()에 대해 작동합니다.\n\n```js\nconst matchObj = /(test+)(hello+)/d.exec('start-testesthello-stop');\n\n// 이전:\nconsole.log(matchObj?.index);\n\n// 새로운:\nif (matchObj) {\n  // 전체 일치 항목의 시작 및 끝 인덱스(이전에 시작만 있었음).\n  console.log(matchObj.indices[0]); // [9, 18]\n\n  // 캡처 그룹의 시작 및 끝 인덱스.\n  console.log(matchObj.indices[1]); // [9, 13]\n  console.log(matchObj.indices[2]); // [13, 18]\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- Negative indexing (.at(-1)): 배열이나 문자열을 인덱싱할 때, at()을 사용하여 뒤에서부터 인덱싱할 수 있습니다. 값 가져오기(arr[arr.length - 1]와 동일)만 가능하며 값을 설정할 수는 없습니다.\n\n```js\nconsole.log([4, 5].at(-1)) // 5\n\nconst array = [4, 5];\narray.at(-1) = 3; // SyntaxError: Assigning to rvalue\n```\n\n- hasOwn: 객체가 어떤 속성을 가지고 있는지 obj.hasOwnProperty()을 사용하는 대신 추천되는 새 방법입니다. 일부 특수한 경우에 더 잘 작동합니다.\n\n```js\nconst obj = { name: 'test' };\n\nconsole.log(Object.hasOwn(obj, 'name')); // true\nconsole.log(Object.hasOwn(obj, 'gender')); // false\n```\n\n<div class=\"content-ad\"></div>\n\n- 오류 원인: 이제 오류에 대한 선택적 원인을 지정할 수 있습니다. 이는 다시 throw할 때 원래 오류를 지정할 수 있게 합니다.\n\n```js\ntry {\n  try {\n    connectToDatabase();\n  } catch (err) {\n    throw new Error('데이터베이스 연결에 실패했습니다.', { cause: err });\n  }\n} catch (err) {\n  console.log(err.cause); // ReferenceError: connectToDatabase is not defined\n}\n```\n\n## 미래 (이미 TypeScript 4.9에서 사용 가능)\n\n- Auto-Accessor: 속성을 자동으로 비공개로 만들고 get/set 접근자를 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass Person {\n  accessir name: string;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name) // 'test'\n  }\n}\n\nconst person = new Person('test');\n```\n\n# TypeScript\n\n## 기초 (추후 소개를 위한 문맥)\n\n- 제네릭: 다른 유형으로 유형을 전달합니다. 이를 통해 유형을 일반화 할 수 있지만 여전히 유형 안전성을 유지할 수 있습니다. 항상 `any` 또는 `unknown` 대신 이를 선호해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// WITHOUT:\nfunction getFirstUnsafe(list: any[]): any {\n  return list[0];\n}\n\nconst firstUnsafe = getFirstUnsafe(['test']); // typed as any\n\n// WITH:\nfunction getFirst<Type>(list: Type[]): Type {\n  return list[0];\n}\n\nconst first = getFirst<string>(['test']); // typed as string\n\n// In this case the parameter can even be dropped because it is inferred from the argument.\nconst firstInferred = getFirst(['test']); // typed as string\n\n// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.\nclass List<T extends string | number> {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nconst list = new List<string>();\nlist.push(9); // Type error: Argument of type 'number' is not assignable to parameter of type 'string'.\nconst booleanList = new List<boolean>(); // Type error: Type 'boolean' does not satisfy the constraint 'string | number'.\n```\n\n## 과거 (아직도 유효한 이전 소개)\n\n- 유틸리티 타입: TypeScript에는 많은 유틸리티 타입이 포함되어 있으며, 그 중 가장 유용한 몇 가지가 여기에서 설명되었습니다.\n\n```js\ninterface Test {\n  name: string;\n  age: number;\n}\n\n// Partial 유틸리티 타입은 모든 속성을 선택적으로 만듭니다.\ntype TestPartial = Partial<Test>; // typed as { name?: string | undefined; age?: number | undefined; }\n// Required 유틸리티 타입은 반대로 동작합니다.\ntype TestRequired = Required<TestPartial>; // typed as { name: string; age: number; }\n// Readonly 유틸리티 타입은 모든 속성을 읽기 전용으로 만듭니다.\ntype TestReadonly = Readonly<Test>; // typed as { readonly name: string; readonly age: string }\n// Record 유틸리티 타입은 객체/맵/사전을 간단하게 정의할 수 있습니다. 가능한 경우에는 인덱스 시그니처보다 선호됩니다.\nconst config: Record<string, boolean> = { option: false, anotherOption: true };\n// Pick 유틸리티 타입은 지정된 속성만 가져옵니다.\ntype TestLess = Pick<Test, 'name'>; // typed as { name: string; }\ntype TestBoth = Pick<Test, 'name' | 'age'>; // typed as { name: string; age: string; }\n// Omit 유틸리티 타입은 지정된 속성을 무시합니다.\ntype TestFewer = Omit<Test, 'name'>; // typed as { age: string; }\ntype TestNone = Omit<Test, 'name' | 'age'>; // typed as {}\n// Parameters 유틸리티 타입은 함수 타입의 매개변수를 가져옵니다.\nfunction doSmth(value: string, anotherValue: number): string {\n  return 'test';\n}\ntype Params = Parameters<typeof doSmth>; // typed as [value: string, anotherValue: number]\n// ReturnType 유틸리티 타입은 함수 타입의 반환 타입을 가져옵니다.\ntype Return = ReturnType<typeof doSmth>; // typed as string\n\n// 이 외에도 많은 유틸리티 타입이 있으며, 그 중 일부는 아래에서 소개됩니다.\n```\n\n<div class=\"content-ad\"></div>\n\n- 조건부 타입: 어떤 타입이 다른 타입과 일치/확장되면 그에 따라 타입을 조건부로 설정합니다. 이는 JavaScript의 조건부(삼항) 연산자와 비슷하게 해석될 수 있습니다.\n\n```js\n// 배열인 경우에만 배열 타입을 추출하고, 그렇지 않으면 동일한 타입을 반환합니다.\ntype Flatten<T> = T extends any[] ? T[number] : T;\n\n// 요소 타입을 추출합니다.\ntype Str = Flatten<string[]>; // string 타입으로 지정됨\n\n// 타입을 그대로 유지합니다.\ntype Num = Flatten<number>; // number 타입으로 지정됨\n```\n\n- 조건부 타입으로 추론: 모든 일반 타입이 소비자에 의해 명시적으로 지정되어야 하는 것은 아닙니다. 일부는 코드로부터 추론될 수도 있습니다. 추론된 타입을 기반으로 조건부 논리를 작성하려면 infer 키워드가 필요합니다. 이는 일시적인 추론된 타입 변수를 정의하는 방식입니다.\n\n```js\n// 이전 예제를 기반으로 해서 더 깔끔하게 작성할 수 있습니다.\ntype FlattenOld<T> = T extends any[] ? T[number] : T;\n\n// 배열에서 직접 인덱싱하는 대신, 배열에서 항목(Item)의 타입을 추론할 수 있습니다.\ntype Flatten<T> = T extends (infer Item)[] ? Item : T;\n\n// 함수의 반환 타입을 가져오고, 그 외의 경우에는 undefined로 지정하는 타입을 작성할 수도 있습니다.\ntype GetReturnType<Type> = Type extends (...args: any[]) => infer Return ? Return : undefined;\n\ntype Num = GetReturnType<() => number>; // number 타입으로 지정됨\n\ntype Str = GetReturnType<(x: string) => string>; // string 타입으로 지정됨\n\ntype Bools = GetReturnType<(a: boolean, b: boolean) => void>; // undefined 타입으로 지정됨\n```\n\n<div class=\"content-ad\"></div>\n\n- 튜플 Optional Elements와 Rest: 튜플에서 `?`를 사용하여 옵셔널 요소를 선언하고, 다른 타입을 기반으로 나머지 요소를 사용할 수 있습니다.\n\n```js\n// 튜플의 길이를 아직 알 수 없지만 적어도 한 개는 있는 경우, `?`를 사용하여 옵셔널 타입을 지정할 수 있습니다.\nconst list: [number, number?, boolean?] = [];\nlist[0] // number 타입으로 지정됩니다\nlist[1] // number 또는 undefined 타입으로 지정됩니다\nlist[2] // boolean 또는 undefined 타입으로 지정됩니다\nlist[3] // Type error: 길이가 '3'인 '[number, (number | undefined)?, (boolean | undefined)?]' 형식의 튜플에는 '3' 인덱스 요소가 없습니다.\n\n// 기존 타입을 기반으로 튜플을 사용할 수도 있습니다.\n// 배열의 시작 부분에 패딩을 추가하려면 나머지 연산자 `...`를 사용할 수 있습니다.\nfunction padStart<T extends any[]>(arr: T, pad: string): [string, ...T] {\n  return [pad, ...arr];\n}\n\nconst padded = padStart([1, 2], 'test'); // [string, number, number] 타입으로 지정됩니다\n```\n\n- 추상 클래스와 메소드: 클래스와 그 내부 메소드를 추상으로 선언하여 인스턴스화되지 않도록 할 수 있습니다.\n\n```js\nabstract class Animal {\n  abstract makeSound(): void;\n\n  move(): void {\n    console.log('roaming the earth...');\n  }\n}\n\n// 추상 메소드는 확장 시 구현되어야 합니다.\nclass Cat extends Animal {} // 컴파일 오류: 추상 클래스 'Animal'로부터 상속된 추상 멤버 'makeSound'가 구현되지 않은 비-추상 클래스 'Cat'입니다.\n\nclass Dog extends Animal {\n  makeSound() {\n    console.log('woof');\n  }\n}\n\n// 추상 클래스는 (인터페이스처럼) 인스턴스화할 수 없으며, 추상 메소드는 호출할 수 없습니다.\nnew Animal(); // 컴파일 오류: 추상 클래스의 인스턴스를 생성할 수 없습니다.\n\nconst dog = new Dog().makeSound(); // \"woof\"가 출력됩니다\n```\n\n<div class=\"content-ad\"></div>\n\n- 생성자 서명: 클래스 선언 외부에서 생성자의 유형을 정의합니다. 대부분의 경우에 사용되지 않아야 하며, 추상 클래스 대신 사용할 수 있습니다.\n\n```js\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass AnotherTest {\n  age: number;\n}\n\nfunction makeObj(n: ConstructsMyInterface) {\n  return new n('hello!');\n}\n\nconst obj = makeObj(Test); // Test로 타입 지정됨\nconst anotherObj = makeObj(AnotherTest); // 타입 오류: 'AnotherTest'의 유형은 'ConstructsMyInterface'의 매개변수에 할당할 수 없습니다.\n```\n\n- ConstructorParameters 유틸리티 타입: TypeScript 도우미 함수로, 생성자 타입에서 생성자 매개변수를 가져옵니다 (클래스에서 가져오는 것이 아닙니다).\n\n```js\n// makeObj 함수에 생성자 인수를 얻고 싶다면?\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nfunction makeObj(test: ConstructsMyInterface, ...args: ConstructorParameters<ConstructsMyInterface>) {\n  return new test(...args);\n}\n\nmakeObj(Test); // 타입 오류: 2개의 매개변수가 필요하지만 1개만 전달되었습니다.\nconst obj = makeObj(Test, 'test'); // Test로 타입 지정됨\n```\n\n<div class=\"content-ad\"></div>\n\n## TypeScript 4.0\n\n- Variadic Tuple Types: 튜플에서의 나머지 요소는 이제 제네릭할 수 있습니다. 여러 개의 나머지 요소를 사용하는 것도 허용됩니다.\n\n```js\n// 만약 길이와 타입이 정의되지 않은 두 튜플을 결합하는 함수가 있다면 어떨까요? 반환 타입을 어떻게 정의할 수 있을까요?\n\n// 이전:\n// 우리는 몇 가지 오버로드를 작성할 수 있었습니다.\ndeclare function concat(arr1: [], arr2: []): [];\ndeclare function concat<A>(arr1: [A], arr2: []): [A];\ndeclare function concat<A, B>(arr1: [A], arr2: [B]): [A, B];\n// 이하 생략\n\n// 대신에 타입을 결합할 수 있습니다.\ndeclare function concatBetter<T, U>(arr1: T[], arr2: U[]): (T | U)[];\n// 그러나 이것은 (T | U)[]로 타입이 지정됩니다.\n\n// 새로운 기능:\n// 가변 길이 튜플 타입을 사용하면 쉽게 정의할 수 있고 길이 정보를 유지할 수 있습니다.\ndeclare function concatNew<T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U];\n\nconst tuple = concatNew([23, 'hey', false] as [number, string, boolean], [5, 99, 20] as [number, number, number]);\nconsole.log(tuple[0]); // 23\nconst element: number = tuple[1]; // 타입 오류: 타입 'string'을 'number'에 할당할 수 없습니다.\nconsole.log(tuple[6]); // 타입 오류: 길이 '6'인 튜플 타입 '[23, \"hey\", false, 5, 99, 20]'에는 인덱스 '6'에 요소가 없습니다.\n```\n\n- Labeled Tuple Elements: 튜플 요소는 이제 [start: number, end: number]와 같이 이름을 지정할 수 있습니다. 요소 중 하나가 이름이 지정되면 모두 이름이 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n혹시 클래스 생성자에서 속성이 설정될 때 속성의 타입을 자동으로 추론할 수 있어서 더 이상 수동으로 설정할 필요가 없습니다.\n\n```js\nclass Animal {\n  // 생성자에서 할당될 때 타입을 설정할 필요가 없습니다.\n  name;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name); // 문자열로 타입이 지정됨\n  }\n}\n```\n\n- JSDoc @deprecated 지원: JSDoc/TSDoc의 @deprecated 태그가 TypeScript에서 인식됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n/** @deprecated 메시지 */\ntype Test = string;\n\nconst test: Test = 'dfadsf'; // 타입 오류: '테스트'가 사용되지 않습니다.\n```\n\n## TypeScript 4.1\n\n- 템플릿 리터럴 타입: 리터럴 타입을 정의할 때, '$'를 이용하여 템플릿을 활용할 수 있습니다. 이를 통해 여러 개의 문자열 리터럴을 조합하는 등 복잡한 문자열 타입을 만들 수 있습니다.\n\n```js\ntype VerticalDirection = 'top' | 'bottom';\ntype HorizontalDirection = 'left' | 'right';\ntype Direction = `${VerticalDirection} ${HorizontalDirection}`;\n\nconst dir1: Direction = 'top left';\nconst dir2: Direction = 'left'; // 타입 오류: '\"left\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\nconst dir3: Direction = 'left top'; // 타입 오류: '\"left top\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\n\n// 이는 제네릭 및 새로운 유틸리티 타입과도 결합할 수 있습니다.\ndeclare function makeId<T extends string, U extends string>(first: T, second: U): `${Capitalize<T>}-${Lowercase<U>}`;\n```\n\n<div class=\"content-ad\"></div>\n\n- 키 다시 매핑하기: 매핑된 타입을 다시 정의하여 그 값들을 사용할 수 있습니다. [K in keyof T as NewKeyType]: T[K].\n\n```js\n// 예를 들어, 객체를 다시 포맷하되 그 ID 앞에 밑줄을 추가하고 싶다고 가정해 봅시다.\nconst obj = { value1: 0, value2: 1, value3: 3 };\nconst newObj: { [Property in keyof typeof obj as `_${Property}`]: number }; // { _value1: number; _value2: number; value3: number; }로 타입이 지정됩니다.\n```\n\n- 재귀 조건부 타입: 조건부 타입을 해당 정의 내부에서 사용합니다. 이를 통해 무한히 중첩된 값을 조건부적으로 언패킹하는 타입을 생성할 수 있습니다.\n\n```js\ntype Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;\n\ntype P1 = Awaited<string>; // string으로 타입이 지정됩니다.\ntype P2 = Awaited<Promise<string>>; // string으로 타입이 지정됩니다.\ntype P3 = Awaited<Promise<Promise<string>>>; // string으로 타입이 지정됩니다.\n```\n\n<div class=\"content-ad\"></div>\n\n- JSDOC @see 태그를 지원하는 편집기: 이제 편집기에서 JSDoc/TSDoc @see 변수/유형/링크 태그가 지원됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * 다른 값의 복사본\n * @see originalValue\n */\nconst value = originalValue;\n```\n\n- tsc --explainFiles: --explainFiles 옵션은 TypeScript CLI에서 컴파일에 사용된 파일과 그 이유를 설명해주는 데 사용될 수 있습니다. 이는 디버깅에 유용할 수 있습니다. 경고: 대규모 프로젝트나 복잡한 설정의 경우 많은 출력물이 생성됩니다. 대신 tsc --explainFiles | less 또는 비슷한 방법을 사용하십시오.\n\n```js\ntsc --explainFiles\n\n<<output\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es5.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n...\noutput\n```\n\n<div class=\"content-ad\"></div>\n\n- Destructured 변수는 명시적으로 사용되지 않음을 표시할 수 있습니다: 구조 분해할 때 밑줄을 사용하여 변수가 사용되지 않음을 표시할 수 있습니다. 이를 통해 TypeScript에서 \"사용되지 않는 변수\" 오류를 방지할 수 있습니다.\n\n```js\nconst [_first, second] = [3, 5];\nconsole.log(second);\n\n// 심지어 더 짧게\nconst [_, value] = [3, 5];\nconsole.log(value);\n```\n\n## TypeScript 4.3\n\n- 속성에 대한 별도의 쓰기 유형: set/get 접근자를 정의할 때, 쓰기/설정 형식이 읽기/가져오기 형식과 다를 수 있습니다. 이를 통해 동일한 값의 여러 형식을 수락하는 setter를 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass Test {\n  private _value: number;\n\n  get value(): number {\n    return this._value;\n  }\n\n  set value(value: number | string) {\n    if (typeof value === 'number') {\n      this._value = value;\n      return;\n    }\n    this._value = parseInt(value, 10);\n  }\n}\n```\n\n- override: 상속된 클래스 메서드를 명확하게 오버라이드로 표시하기 위해 override를 사용하세요. 부모 클래스가 변경되면 TypeScript에서 부모 메서드가 더 이상 존재하지 않음을 알려줄 수 있습니다. 이를 통해 더 안전한 복잡한 상속 패턴을 구현할 수 있습니다.\n\n```js\nclass Parent {\n  getName(): string {\n    return 'name';\n  }\n}\n\nclass NewParent {\n  getFirstName(): string {\n    return 'name';\n  }\n}\n\nclass Test extends Parent {\n  override getName(): string {\n    return 'test';\n  }\n}\n\nclass NewTest extends NewParent {\n  override getName(): string { // Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.\n    return 'test';\n  }\n}\n```\n\n- static Index Signatures: 클래스에서 정적 속성을 사용할 때, 정적 [propName: string]: string을 사용하여 색인 서명을 설정할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이전 코드:\nclass Test {}\n\nTest.test = ''; // 타입 오류: 'test' 속성을 'Test' 형식에서 찾을 수 없습니다.\n\n// 새로운 코드:\nclass NewTest {\n  static [key: string]: string;\n}\n\nNewTest.test = '';\n```\n\n- JSDOC @link 태그를 위한 편집기 지원: JSDoc/TSDoc의 '@link 변수/타입/링크' 인라인 태그가 이제 지원되며 편집기에서 표시되고 해결됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * {@link originalValue}의 복사본\n */\nconst value = originalValue;\n```\n\n## TypeScript 4.4\n\n<div class=\"content-ad\"></div>\n\n- 정확한 선택적 속성 유형 (--exactOptionalPropertyTypes): 컴파일러 플래그 --exactOptionalPropertyTypes (또는 tsconfig.json에)를 사용하면, 암시적으로 undefined를 허용하는 속성에 대해 undefined로 할당하는 것이 허용되지 않습니다 (예: property?: string). 대신, property: string | undefined와 같이 명시적으로 undefined를 허용해야 합니다.\n\n```js\nclass Test {\n  name?: string;\n  age: number | undefined;\n}\n\nconst test = new Test();\ntest.name = undefined; // 타입 오류: 'exactOptionalPropertyTypes: true'를 사용하여 'undefined' 타입을 'string'에 할당할 수 없습니다. 대상의 유형에 'undefined'를 추가하는 것을 고려해보세요.\ntest.age = undefined;\nconsole.log(test.age); // undefined\n```\n\n## TypeScript 4.5\n\n- Awaited`` 유형 및 Promise 개선: 새로운 Awaited`` 유틸리티 유형은 무한히 중첩된 Promises에서 값 유형을 추출합니다 (값에 대해 await이 하는 것과 같이). 이는 또한 Promise.all()에 대한 유형 추론을 개선했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 제네릭 대기값을 가지고 싶다고 가정해 봅시다.\n// 이러한 경우 Awaited 유틸리티 타입을 사용할 수 있습니다 (소스 코드는 이전 예제의 일부였습니다).\n// 따라서 무한하게 중첩된 Promises가 모두 값으로 해결됩니다.\ntype P1 = Awaited<string>; // 문자열로 타입 지정\ntype P2 = Awaited<Promise<string>>; // 문자열로 타입 지정\ntype P3 = Awaited<Promise<Promise<string>>>; // 문자열로 타입 지정\n```\n\n- Import 이름에 대한 유형 수식어: 일반 (import type 아닌) import 문 안에서 type 키워드를 사용하여 해당 값이 유형 컴파일을 위해만 가져와야 함을 신호로 삼을 수 있습니다 (컴파일 후에 제거할 수 있습니다).\n\n```js\n// 이전:\n// 유형을 가져오는 가장 좋은 방법은 `import type` 키워드를 사용하여 컴파일 이후에 실제로 가져오지 않도록 하는 것입니다.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// 이 파일에 대해 두 개의 import 문이 필요했습니다.\n\n// 새로운:\n// 이제 이를 하나의 문으로 결합할 수 있습니다.\nimport { something, type SomeType } from './file';\n```\n\n- Const 어순: 상수를 정의할 때 const 키워드를 사용하여 이를 리터럴 타입으로 정확하게 지정할 수 있습니다. 이는 다양한 용례가 있으며 정확한 유형 정의가 쉬워집니다. 또한 상수 객체와 배열은 읽기 전용이 되어 상수 객체의 변이를 방지합니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이전:\nconst obj = { name: 'foo', value: 9, toggle: false }; // { name: string; value: number; toggle: boolean; }으로 타입 지정됨\n// 일반적으로 타입이 지정되어 있으므로 어느 값이든 할당 가능합니다.\nobj.name = 'bar';\n\nconst tuple = ['name', 4, true]; // (string | number | boolean)[]으로 타입 지정됨\n// 타입으로 길이와 정확한 형식을 결정할 수 없습니다. 어떤 값이든 어디에든 할당할 수 있습니다.\ntuple[0] = 0;\ntuple[3] = 0;\n\n// 새로운 방식:\nconst objNew = { name: 'foo', value: 9, toggle: false } as const; // { readonly name: \"foo\"; readonly value: 9; readonly toggle: false; }으로 타입 지정됨\n// 값을 할당할 수 없습니다 (\"foo\"(그리고 readonly로 정의되었기 때문).\nobjNew.name = 'bar'; // 타입 에러: 'name'에 할당할 수 없습니다. 읽기 전용 속성입니다.\n\nconst tupleNew = ['name', 4, true] as const; // readonly [\"name\", 4, true]으로 타입 지정됨\n// 이제 길이와 정확한 형식이 정의되어 있고, 값을 할당할 수 없습니다 (리터럴로 정의되었으며 readonly).\ntupleNew[0] = 0; // 타입 에러: '0'에 할당할 수 없습니다. 읽기 전용 속성입니다.\ntupleNew[3] = 0; // 타입 에러: 'readonly[\"name\", 4, true]'에 있는 인덱스 서명에는 읽기만 허용됩니다.\n```\n\n- 클래스 내의 메서드에 대한 코드 조각 완성: 클래스가 메서드 타입을 상속하면 편집기에서 코드 조각으로 제안됩니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:800/1*31No189vLt2Kdx5Ay_Ihig.gif\" />\n\n## TypeScript 4.6\n\n<div class=\"content-ad\"></div>\n\n- 인덱스된 액세스 추론 개선: 키로 직접 타입을 색인화할 때, 이제 같은 객체에 있는 경우 타입이 더 정확해집니다. 현대적인 TypeScript로 어떤 것이 가능한지 보여주는 좋은 예시입니다.\n\n```js\ninterface AllowedTypes {\n  'number': number;\n  'string': string;\n  'boolean': boolean;\n}\n\n// Record는 허용된 타입의 종류와 값 타입을 지정합니다.\ntype UnionRecord<AllowedKeys extends keyof AllowedTypes> = { [Key in AllowedKeys]:\n{\n  kind: Key;\n  value: AllowedTypes[Key];\n  logValue: (value: AllowedTypes[Key]) => void;\n}\n}[AllowedKeys];\n\n// 함수 logValue는 Record의 값만을 허용합니다.\nfunction processRecord<Key extends keyof AllowedTypes>(record: UnionRecord<Key>) {\n  record.logValue(record.value);\n}\n\nprocessRecord({\n  kind: 'string',\n  value: 'hello!',\n\n  // 값이 암묵적으로 string | number | boolean 타입을 가졌던 것이\n  // 이제 올바르게 오직 string으로 추론됩니다.\n  logValue: value => {\n    console.log(value.toUpperCase());\n  }\n});\n```\n\n- TypeScript 추적 분석기 (--generateTrace): --generateTrace '출력 폴더' 옵션을 사용하여 TypeScript CLI가 타입 검사 및 컴파일 프로세스에 대한 자세한 내용을 포함한 파일을 생성할 수 있습니다. 이는 복잡한 타입을 최적화하는 데 도움이 될 수 있습니다.\n\n```js\ntsc --generateTrace trace\n\ncat trace/trace.json\n<<출력\n[\n{\"name\":\"process_name\",\"args\":{\"name\":\"tsc\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"thread_name\",\"args\":{\"name\":\"Main\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"TracingStartedInBrowser\",\"cat\":\"disabled-by-default-devtools.timeline\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"program\",\"ts\":...,\"name\":\"createProgram\",\"args\":{\"configFilePath\":\"/...\",\"rootDir\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"E\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"X\",\"cat\":\"program\",\"ts\":...,\"name\":\"resolveModuleNamesWorker\",\"dur\":...,\"args\":{\"containingFileName\":\"/...\"},\n...\n출력\n\ncat trace/types.json\n<<출력\n[{\"id\":1,\"intrinsicName\":\"any\",\"recursionId\":0,\"flags\":[\"...\"]},\n{\"id\":2,\"intrinsicName\":\"any\",\"recursionId\":1,\"flags\":[\"...\"]},\n{\"id\":3,\"intrinsicName\":\"any\",\"recursionId\":2,\"flags\":[\"...\"]},\n{\"id\":4,\"intrinsicName\":\"error\",\"recursionId\":3,\"flags\":[\"...\"]},\n{\"id\":5,\"intrinsicName\":\"unresolved\",\"recursionId\":4,\"flags\":[\"...\"]},\n{\"id\":6,\"intrinsicName\":\"any\",\"recursionId\":5,\"flags\":[\"...\"]},\n{\"id\":7,\"intrinsicName\":\"intrinsic\",\"recursionId\":6,\"flags\":[\"...\"]},\n{\"id\":8,\"intrinsicName\":\"unknown\",\"recursionId\":7,\"flags\":[\"...\"]},\n{\"id\":9,\"intrinsicName\":\"unknown\",\"recursionId\":8,\"flags\":[\"...\"]},\n{\"id\":10,\"intrinsicName\":\"undefined\",\"recursionId\":9,\"flags\":[\"...\"]},\n{\"id\":11,\"intrinsicName\":\"undefined\",\"recursionId\":10,\"flags\":[\"...\"]},\n{\"id\":12,\"intrinsicName\":\"null\",\"recursionId\":11,\"flags\":[\"...\"]},\n{\"id\":13,\"intrinsicName\":\"string\",\"recursionId\":12,\"flags\":[\"...\"]},\n...\n출력\n```\n\n<div class=\"content-ad\"></div>\n\n## TypeScript 4.7\n\n- Node.js에서 ECMAScript 모듈 지원: CommonJS 대신 ES 모듈을 사용할 때, TypeScript가 이제 default를 지정할 수 있습니다. tsconfig.json에서 지정하세요.\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"module\": \"es2020\"\n]\n...\n```\n\n- package.json의 type: package.json의 type 필드를 \"module\"로 설정할 수 있습니다. 이것은 Node.js와 ES 모듈을 사용하기 위해 필요합니다. 대부분의 경우에 TypeScript에 충분하며 위의 컴파일러 옵션이 필요하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n\"type\": \"module\"\n...\n```\n\n- 인스턴스화 표현식: 인스턴스화 표현식을 사용하면 값을 참조할 때 유형 매개변수를 지정할 수 있습니다. 이를 통해 래퍼를 생성하지 않고 일반적인 유형을 좁힐 수 있습니다.\n\n```js\nclass List<T> {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nfunction makeList<T>(items: T[]): List<T> {\n  const list = new List<T>();\n  items.forEach(item => list.push(item));\n  return list;\n}\n\n// 특정 값만 허용하는 목록을 만드는 함수가 필요한 경우를 가정해 봅시다.\n// 이전:\n// 직접 래퍼 함수를 정의하고 인수를 전달해야 했습니다.\nfunction makeStringList(text: string[]) {\n  return makeList(text);\n}\n\n// 새로운 방법:\n// 인스턴스화 표현식을 사용하면 훨씬 쉽습니다.\nconst makeNumberList = makeList<number>;\n```\n\n- 추론된 유형 변수에 대한 extend 제한: 조건부 유형에서 유형 변수를 추론할 때, extends를 사용하여 직접 좁히거나 제한할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 배열의 첫 번째 요소가 문자열인 경우에만 해당 요소를 가져오는 유형을 작성하려고 한다고 가정해 봅시다.\n// 이를 위해 조건부 유형을 사용할 수 있습니다.\n\n// 이전:\ntype FirstIfStringOld<T> =\n  T extends [infer S, ...unknown[]]\n    ? S extends string ? S : never\n    : never;\n\n// 그러나 이 방법은 두 개의 중첩된 조건부 유형이 필요합니다. 이를 하나의 유형으로도 할 수 있습니다.\ntype FirstIfString<T> =\n  T extends [string, ...unknown[]]\n    // `T`에서 첫 번째 유형을 가져옵니다.\n    ? T[0]\n    : never;\n\n// 이것도 여전히 최적화되지 않은 상태이며 올바른 유형을 위해 배열을 인덱싱해야 합니다.\n\n// 새로운 방식:\n// 추론된 유형 변수에 extends 제약 조건을 사용하여 이를 더 간단하게 선언할 수 있습니다.\ntype FirstIfStringNew<T> =\n  T extends [infer S extends string, ...unknown[]]\n    ? S\n    : never;\n// 유형을 알아내는 방식은 이전과 동일하지만 더 깔끔한 구문입니다.\n\ntype A = FirstIfStringNew<[string, number, number]>; // string으로 유형 지정\ntype B = FirstIfStringNew<[\"hello\", number, number]>; // \"hello\"로 유형 지정\ntype C = FirstIfStringNew<[\"hello\" | \"world\", boolean]>; // \"hello\" 또는 \"world\"로 유형 지정\ntype D = FirstIfStringNew<[boolean, number, string]>; // never로 유형 지정\n```\n\n- 유형 매개변수를 위한 선택적 분산 주석: 제네릭은 \"일치하는지\" 확인할 때 다른 동작을 가질 수 있습니다. 예를 들어, 상속을 허용할 경우 getters 및 setters에 대해 반대로 반전됩니다. 이제 이를 명시적으로 지정할 수 있습니다.\n\n```js\n// 다른 인터페이스 / 클래스를 확장하는 인터페이스가 있다고 가정해 봅시다.\ninterface Animal {\n  animalStuff: any;\n}\n\ninterface Dog extends Animal {\n  dogStuff: any;\n}\n\n// 그리고 일반적인 \"getter\" 및 \"setter\"가 있습니다.\ntype Getter<T> = () => T;\n\ntype Setter<T> = (value: T) => void;\n\n// Getter<T1>과 Getter<T2> 또는 Setter<T1>과 Setter<T2>가 일치하는지 확인하려면 분산에 따라 달라집니다.\nfunction useAnimalGetter(getter: Getter<Animal>) {\n  getter();\n}\n\n// 이제 함수에 Getter를 전달할 수 있습니다.\nuseAnimalGetter((() => ({ animalStuff: 0 }) as Animal));\n// 당연히 작동합니다.\n\n// 그러나 Dog를 반환하는 Getter를 사용하려면 어떻게 해야 할까요?\nuseAnimalGetter((() => ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// 이 또한 작동합니다. 왜냐하면 Dog도 Animal이기 때문입니다.\n\nfunction useDogGetter(getter: Getter<Dog>) {\n  getter();\n}\n\n// useDogGetter 함수에 동일한 작업을 시도하면 동일한 동작을 얻지 못할 것입니다.\nuseDogGetter((() => ({ animalStuff: 0 }) as Animal); // Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.\n// 이는 Animal이 아닌 Dog가 필요하기 때문에 작동하지 않습니다.\n\nuseDogGetter((() => ({ animalStuff: 0, dogStuff: 0 }) as Dog);\n// 그러나 이 경우는 작동합니다.\n\n// 직관적으로 Setters가 같은 방식으로 작동할 것으로 기대할 수도 있지만, 사실은 그렇지 않습니다.\nfunction setAnimalSetter(setter: Setter<Animal>, value: Animal) {\n  setter(value);\n}\n\n// 동일한 유형의 Setter를 전달해도 작동합니다.\nsetAnimalSetter((value: Animal) => {}, { animalStuff: 0 });\n\nfunction setDogSetter(setter: Setter<Dog>, value: Dog) {\n  setter(value);\n}\n\n// 여기도 마찬가지로 작동합니다.\nsetDogSetter((value: Dog) => {}, { animalStuff: 0, dogStuff: 0 });\n\n// 그러나 Dog Setter를 setAnimalSetter 함수에 전달하면 Getter와는 반대로 동작이 반전됩니다.\nsetAnimalSetter((value: Dog) => {}, { animalStuff: 0, dogStuff: 0 }); // Type error: Argument of type '(value: Dog) => void' is not assignable to parameter of type 'Setter<Animal>'.\n\n// 이번에는 상황이 반대로 작동합니다.\nsetDogSetter((value: Animal) => {}, { animalStuff: 0, dogStuff: 0 });\n\n// 새로운 방법:\n// TypeScript에이를 표시하기 위해 (필수는 아니지만 가독성을 위해 유용), 유형 매개변수에 대한 선택적 분산 주석을 사용합니다.\ntype GetterNew<out T> = () => T;\ntype SetterNew<in T> = (value: T) => void;\n```\n\n- moduleSuffixes로 해상도 사용자 정의: 사용자 정의 파일 접미사를 사용하는 환경(예: 네이티브 앱 빌드에 .ios를 사용하는 경우)에서는 TypeScript가 가져오기를 정확하게 해석하도록 이 접미사를 tsconfig.json에 지정할 수 있습니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"moduleSuffixes\": [\".ios\", \".native\", \"\"]\n]\n...\n```\n\n```js\nimport * as foo from './foo';\n// 이 코드는 먼저 ./foo.ios.ts를 확인하고, 그 다음에는 ./foo.native.ts를, 마지막으로 ./foo.ts를 확인합니다.\n```\n\n- 에디터에서 소스 정의로 이동: 에디터에서 새로운 \"소스 정의로 이동\" 메뉴 옵션이 사용 가능합니다. 이는 \"정의로 이동\"과 유사하지만, .ts 및 .js 파일을 .d.ts 타입 정의 파일보다 우선합니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:800/1*y45nF8mb-nfBuVIUPt7KJQ.gif\" />\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*qvzGqfF844cXCPMeDrg_IQ.gif)\n\n## TypeScript 4.9\n\n- `satisfies` 연산자: `satisfies` 연산자는 실제로 그 타입을 할당하지 않고도 타입과의 호환성을 확인할 수 있게 해줍니다. 이를 통해 더 정확한 추론된 타입을 유지하면서도 호환성을 유지할 수 있습니다.\n\n```js\n// 이전:\n// 여러 항목과 그 색상을 저장하는 객체/맵/딕셔너리가 있다고 가정해 보겠습니다.\nconst obj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // { fireTruck: number[]; bush: string; ocean: number[]; } 타입으로 정의됨\n\n// 배열과 문자열에 대해 작업을 수행할 수 있도록 속성을 암시적으로 타입 지정합니다.\nconst rgb1 = obj.fireTruck[0]; // 숫자로 타입 지정\nconst hex = obj.bush; // 문자열로 타입 지정\n\n// 특정 객체만 허용하고 싶다면 Record 타입을 사용할 수 있습니다.\nconst oldObj: Record<string, [number, number, number] | string> = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // Record<string, [number, number, number] | string> 타입으로 정의됨\n// 하지만 이제 우리는 속성의 타입에 대한 정보를 잃어버립니다.\nconst oldRgb1 = oldObj.fireTruck[0]; // string 또는 number로 타입 지정\nconst oldHex = oldObj.bush; // string 또는 number로 타입 지정\n\n// 새롭게:\n// `satisfies` 키워드를 사용하여 타입과 호환성을 확인할 수 있습니다.\nconst newObj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} satisfies Record<string, [number, number, number] | string> // { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; } 타입으로 정의됨\n// 이제 속성의 타입에 대한 정보를 유지할 수 있을 뿐만 아니라 배열은 튜플로 더 정확해집니다.\nconst newRgb1 = newObj.fireTruck[0]; // 숫자로 타입 지정\nconst newRgb4 = newObj.fireTruck[3]; // 타입 오류: 길이가 '3'인 튜플 타입 '[number, number, number]'에는 인덱스 '3'에 해당하는 요소가 없습니다.\nconst newHex = newObj.bush; // 문자열로 타입 지정\n```\n\n<div class=\"content-ad\"></div>\n\n- 편집기의 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령: 편집기에서 새로운 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령(및 자동 수정)을 사용하면 Imports를 관리하는 것이 더 쉬워집니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*z5SG6BKwzyxrG6sG7OKciw.gif)\n\n## TypeScript 5.0\n\n- ES 데코레이터 지원: TypeScript는 이제 ES 데코레이터(곧 나올 ES 기능)를 지원하며, 기존 데코레이터와는 다릅니다. 이전에 TypeScript는 데코레이터에 대해 실험적인 지원을 했었는데, 이는 Angular와 같은 프레임워크에서 사용되는 것으로, --experimentalDecorators 플래그(또는 tsconfig.json에서)로 선택할 수 있었으며 약간 다르게 동작했습니다. 그러나 이제 새로운 ES 데코레이터는 이전 것과는 다르게 메타데이터를 내보내지 못하며 아직은 매개변수에서도 지원되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 주의: 2023년 5월 기준으로 이것은 예정된 ES 기능이므로 이 코드는 아직 작동하지 않습니다.\n\n// 디버깅 중에 메서드에 진입하거나 나갈 때마다 기록하려고 합니다.\n// 이것을 수동으로 하는 것은 상당히 지루할 수 있습니다. 자동화할 방법이 있을까요?\n// 네, 데코레이터를 사용하여 실행 컨텍스트를 대체할 수 있습니다.\n\n// 먼저 데코레이터 역할을 할 함수를 정의합니다. 이 함수는 원본 메서드와 컨텍스트 개체를 매개변수로 받아 새로운 실행 함수를 반환합니다.\nfunction logMethod<This, Args extends any[], Return>(originalMethod: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext) {\n  const methodName = String(context.name);\n\n  function replacementFunction(this: This, ...args: Args) {\n    console.log(`LOG: 메서드 '${methodName}' 진입 중.`)\n    const result = originalMethod.call(this, ...args);\n    console.log(`LOG: 메서드 '${methodName}' 나감.`)\n    return result;\n  }\n\n  return replacementFunction;\n}\n\n// 이제 이를 사용할 클래스를 정의합니다. 데코레이터는 클래스와 그 멤버에만 작동합니다.\n// 메서드에 '@'와 함수명을 사용하여 데코레이터를 적용합니다.\nclass Test {\n  @logMethod\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testObj = new Test();\n\n// 메서드를 실행하면 대체 메서드가 호출됩니다.\nconsole.log(testObj.doSomething()); // \"LOG: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"LOG: 메서드 'doSomething' 나감.\"\n\n// 사용자 정의 메시지와 같은 추가 인수를 전달하려면 데코레이터 팩토리(데코레이터 함수를 반환하는 함수)를 정의할 수 있습니다.\nfunction logMethodCustom(customMessage: string) {\n  return <This, Args extends any[], Return>(originalMethod: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext) => {\n    const methodName = String(context.name);\n\n    function replacementFunction(this: This, ...args: Args) {\n      console.log(`${customMessage}: 메서드 '${methodName}' 진입 중.`)\n      const result = originalMethod.call(this, ...args);\n      console.log(`${customMessage}: 메서드 '${methodName}' 나감.`)\n      return result;\n    }\n\n    return replacementFunction;\n  }\n}\n\n// 이번에는 함수 호출을 포함하는 `()`로 된 추가 인수를 사용하여 메서드에 데코레이터를 적용합니다.\nclass TestCustom {\n  @logMethodCustom('테스트 로그')\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testCustomObj = new Test();\n\n// 메서드 실행시 모든 작업이 예상대로 작동합니다.\nconsole.log(testCustomObj.doSomething()); // \"테스트 로그: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"테스트 로그: 메서드 'doSomething' 나감.\"\n\n// 데코레이터 함수에서 대체 메서드를 반환하지 않으면 원본 메서드가 호출되지만 관련 설정을 아직 설정할 수 있습니다.\n// 예를 들어 `constructor` 단계 이전에 `this`를 바인딩하여 클래스 외부에서 콜백으로 전달할 경우 동일하게 실행되도록합니다.\n// `constructor` 단계 이전에 코드를 실행하려면 컨텍스트 개체의 `addInitializer` 메서드를 사용할 수 있습니다.\nfunction bindThis(_: unknown, context: ClassMethodDecoratorContext) {\nconst methodName = context.name;\nif (context.private) {\n  throw new Error(`'bound'는 ${methodName as string}과 같은 비공개 속성을 데코레이션할 수 없습니다.`);\n}\ncontext.addInitializer(function (this: any) {\n  const methodName = context.name;\n    if (typeof methodName === 'string') {\n      this[methodName] = this[methodName].bind(this);\n    }\n  });\n}\n\n// 바인딩하지 않은 상태로 한번 정의합니다.\nclass TestUnbound {\n  private returnVal = '작업 중';\n\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testUnboundObj = new TestUnbound();\n\n// 메서드에 다시 \"데코레이터\"를 적용합니다.\nclass TestBound {\n  private returnVal = '작업 중';\n\n  @bindThis\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testBoundObj = new TestBound();\n\n// 클래스 컨텍스트 외부에 메서드를 저장하고 실행시키면 속성 값에 액세스할 수 없습니다.\nconst unboundFunc = testUnboundObj.doSomething;\nconsole.log(unboundFunc()); // 오류: \"Cannot read properties of undefined (reading 'returnVal')\"\n\n// 그러나 바인딩하면 예상대로 작동합니다.\nconst boundFunc = testBoundObj.doSomething;\nconsole.log(boundFunc()); // \"작업 중\"\n```\n\n- const 형식 매개변수: 형식 매개변수 앞에 const를 지정하는 const는 readonly 형식을 그대로 사용하는 것처럼 동작하도록 시도합니다. 그러나 변경 가능한 값을 형식화했다면 인자유추가 작동하지 않을 수 있습니다(왜냐하면 읽기전용 형식은 변경 가능한 형식에 할당할 수 없기 때문에 항상 readonly 형식을 상속해야 합니다). 이것은 여전히 허용된 매개변수를 제한하지 않습니다. 여전히 extends 내에서 제한해야 합니다.\n\n- 타입을 활용한 여러 구성 파일 지원: 복잡한 상속 구조를 만들거나 모든 \"tsconfig\"에서 항상 동일한 구성을 확장하거나 모든 설정을 복사하여 모두 복사하는 대신, \"tsconfig\" 파일에서 \"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"]를 지정함으로써 여러 파일을 확장하여 동작을 재정의할 수 있습니다. 후자의 파일이 오버라이드 동작을 우선시합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n// 여기서 \"tsconfig1.json\"은 \"@tsconfig/strictest/tsconfig.json\"을 덮어씁니다. \"tsconfig2.json\"은 \"tsconfig1.json\"과 \"@tsconfig/strictest/tsconfig.json\"을 덮어쓰며, 이 파일은 모두 덮어씁니다.\n\"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"./tsconfig1.json\", \"./tsconfig2.json\"],\n...\n```\n\n- 모든 열거형이 합집합 열거형입니다: 동적으로 할당된 열거형 값은 이제 더 이상 예전의 열거형 전략 기본값을 갖지 않습니다(열거형 키에 대한 타입 없음, 값으로만 사용 가능하며 타입으로 사용할 수 없음). 대신 이제 타입으로도 사용할 수 있습니다.\n\n```js\n// 열거형은 각 값마다 다른 타입을 만듭니다.\nenum Color {\n  Red, Green, Blue, Orange, Yellow, Violet\n}\n\n// 이를 통해 그들을 좁히고 다른 타입처럼 사용할 수 있습니다.\ntype PrimaryColor = Color.Red | Color.Green | Color.Blue;\n\n// 하지만:\n// 값이 동적으로 할당되면 고정된 값이 없습니다.\n// 이전에는 예전 열거형 동작으로 되돌아가게 되었습니다.\n// 예전 열거형 동작에서 그 멤버는 값으로만 존재하며 타입으로는 존재하지 않음.\nenum ColorRandom {\n  Red = Math.random(),\n  Green = Math.random(),\n  Blue = Math.random(),\n  Orange = Math.random(),\n  Yellow = Math.random(),\n  Violet = Math.random()\n}\n\n// 그래서 이전에는 좁혀지지 못했습니다.\ntype PrimaryColorRandom = ColorRandom.Red | ColorRandom.Green | ColorRandom.Blue; // 이전 타입 오류: Enum 타입 'ColorRandom'은 리터럴이 아닌 초기화 값을 갖는 멤버를 가지고 있습니다.\n// 하지만 이제 그들에게도 자체 타입이 있기 때문에 작동합니다.\n```\n\n- --moduleResolution bundler: TS 4.7의 모듈 해결 전략 \"node16\"은 ES 모듈을 더 잘 모델링할 수 있게 해주지만 일부 불필요한 제약이 있었습니다(파일 확장자를 명시해야 했으며, ...). 번들러를 사용 중이라면, 새 전략은 최신 기능을 유지하면서 일부 제약을 제거하려고 시도합니다. 컴파일러 플래그 --moduleResolution bundle를 지정하여 사용할 수 있습니다(또는 tsconfig.json에서). 번들러를 사용할 때만 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"moduleResolution\": \"bundler\"\n]\n...\n```\n\n```json\nimport * as foo from './foo';\n// 이제는 파일 확장자가 지정되지 않아도 다시 허용됩니다.\n```\n\n- 해상도 Customization Flags: \"hybrid\" 모듈 해상도에 대한 규칙을 설정합니다. 규칙은 다음과 같습니다: allowImportingTsExtensions, resolvePackageJsonExports (imports를 위해 package.json exports을 고려함), resolvePackageJsonImports (#로 시작하는 경로를 위해 로컬 package.json을 참조함), allowArbitraryExtensions 및 customConditions (node16 및 bundler 전용, package.json에서 조건부 exports 및 imports을 위해 사용됨)입니다. 이러한 모든 설정은 --를 접두사로 하여 컴파일러 플래그로 지정하거나 tsconfig.json에 지정할 수 있습니다.\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"allowImportingTsExtensions\": false,\n  \"resolvePackageJsonExports\": true,\n  \"resolvePackageJsonImports\": true,\n  \"allowArbitraryExtensions\": false,\n  \"customConditions\": [\"my-condition\"]\n  // 이제는 `package.json`의 `exports` 및 `imports`에 대한 사용자 정의 조건을 해결하려고 시도합니다.\n  // TS는 그런 다음 해당 사용자 정의 조건에 맞도록 파일을 매칭하려고 할 것입니다 (이 경우 `foo.mjs`).\n]\n...\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  ...\n  \"exports\": {\n    \".\": {\n      \"my-condition\": \"./foo.mjs\",\n      \"node\": \"./bar.mjs\",\n      \"import\": \"./baz.mjs\",\n      \"require\": \"./biz.mjs\"\n    }\n  }\n}\n```\n\n- **--verbatimModuleSyntax:** 자동으로 import (import elision) 및 exports를 제거하지 않도록 TypeScript를 중지합니다. 이것은 import side effects가 사용될 때 또는 TS가 import가 어디에서 사용되는지 인식하지 못할 때 유용할 수 있습니다. import type 및 export type 문은 여전히 최종 컴파일에서 제거됩니다. 대개 import가 타입인지 아닌지 명시하는 것이 권장됩니다. compiler flag --verbatimModuleSyntax(또는 tsconfig.json에서)를 지정하여 사용할 수 있습니다.\n\n```js\n// `verbatimModuleSyntax`가 설정되지 않으면 이 import는 최종 컴파일에서 제거될 것입니다.\nimport { Car } from './car';\n// 이 import는 아무 경우에나 제거될 것입니다.\nimport type { Car } from './car';\n// 이 import는 절대로 제거되지 않습니다.\nimport { logCar } from './car';\n\nexport function drive(car: Car) {\n  logCar(car);\n  // ...\n}\n```\n\n- **export type * 지원:** 기본 형식을 하위 모듈로 쉽게 다시 내보낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 기본 타입들을 다른 모듈로서 서브모듈로 내보냅니다.\nexport type * as am from 'another-module';\n// 또는 다시 기본 내보낸 것으로 제공합니다.\nexport type * from 'another-module';\n```\n\n```js\nimport type { am } from 'module';\n// 또는\nimport type { } from 'module';\n```\n\n- --build 하위에서 Emit-Specific 플래그 전달: 빌드에 대한 동작을 지정하는 플래그들 (--build를 사용할 때). 이들은 --declaration, --emitDeclarationOnly, --declarationMap, --sourceMap 및 --inlineSourceMap를 포함합니다. 모두 이제 컴파일러 플래그로 지정할 수 있습니다. 이전에는 tsconfig.json에서만 설정할 수 있었어요.\n\n```js\n# 이것은 `tsconfig.json`에서 비활성화되어 있더라도 타입 선언을 생성합니다.\ntsc --build --declaration\n```\n\n<div class=\"content-ad\"></div>\n\n- 에디터에서 대소문자 구분 없는 import 정렬: 에디터에서 import를 정렬할 때 대소문자 구분 동작을 변경하세요. 이 기능은 VSCode의 JSON 설정 내 typescript.unstable 아래에서 활성화하고 구성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1032/1*Fei6JPgYzIgnl_IMekhOQg.gif)\n\n- Exhaustive switch/case 자동 완성: 에디터에서 이제 리터럴 타입의 case 문을 자동으로 완성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:656/1*e9FNtf4-kxU787rEl1w9lQ.gif)","ogImage":{"url":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png"},"coverImage":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png","tag":["Tech"],"readingTime":53},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png\" alt=\"2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png\"></p>\n<p>이 기사는 지난 3년 동안 (그리고 그 이전에서도) JavaScript/ECMAScript와 TypeScript에서 발생한 거의 모든 변경 사항을 살펴봅니다.</p>\n<p>다음의 기능들 중 일부는 여러분에게 적용되지 않거나 실용적이지 않을 수 있지만, 이러한 언어에 대한 이해를 더 깊게 하고 가능한 기능을 보여주기 위한 것입니다.</p>\n<p>많은 TypeScript 기능들을 생략했는데, 그 이유는 \"이전과 달리 예상대로 작동하지 않았으나, 지금은 그렇게 됩니다\"로 요약할 수 있습니다. 따라서 과거에 작동하지 않았던 것이 있다면, 다시 시도해 보세요.</p>\n<ul>\n<li>JavaScript / ECMAScript (가장 오래된 것부터)</li>\n<li>TypeScript (가장 오래된 것부터)</li>\n</ul>\n<h1>내용</h1>\n<h1>ECMAScript</h1>\n<h2>과거 (아직도 중요한 이전 소개들)</h2>\n<ul>\n<li>Tagged template literals: 템플릿 리터럴 앞에 함수 이름을 붙이면 함수가 템플릿 리터럴 및 템플릿 값들을 전달받게 됩니다. 이 방법에는 재미있는 활용법이 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 임의의 숫자를 포함한 문자열을 로깅할 때 숫자를 형식화하는 방법을 작성하고 싶다고 가정해 봅시다.</span>\n<span class=\"hljs-comment\">// 그럴 때 태그드 템플릿을 사용할 수 있습니다.</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">formatNumbers</span>(<span class=\"hljs-params\">strings: TemplateStringsArray, number: number</span>): string {\n  <span class=\"hljs-keyword\">return</span> strings[<span class=\"hljs-number\">0</span>] + number.<span class=\"hljs-title function_\">toFixed</span>(<span class=\"hljs-number\">2</span>) + strings[<span class=\"hljs-number\">1</span>];\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(formatNumbers<span class=\"hljs-string\">`This is the value: <span class=\"hljs-subst\">${<span class=\"hljs-number\">0</span>}</span>, it's important.`</span>); <span class=\"hljs-comment\">// This is the value: 0.00, it's important.</span>\n\n<span class=\"hljs-comment\">// 문자열 내의 번역 키를 \"번역\"하고 싶을 때 (여기서는 소문자로 변경)</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">translateKey</span>(<span class=\"hljs-params\">key: string</span>): string {\n  <span class=\"hljs-keyword\">return</span> key.<span class=\"hljs-title function_\">toLocaleLowerCase</span>();\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-params\">strings: TemplateStringsArray, ...expressions: string[]</span>): string {\n  <span class=\"hljs-keyword\">return</span> strings.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumulator, currentValue, index</span>) =></span> accumulator + currentValue + <span class=\"hljs-title function_\">translateKey</span>(expressions[index] ?? <span class=\"hljs-string\">''</span>), <span class=\"hljs-string\">''</span>);\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(translate<span class=\"hljs-string\">`Hello, this is <span class=\"hljs-subst\">${<span class=\"hljs-string\">'NAME'</span>}</span> to say <span class=\"hljs-subst\">${<span class=\"hljs-string\">'MESSAGE'</span>}</span>.`</span>); <span class=\"hljs-comment\">// Hello, this is name to say message.</span>\n</code></pre>\n<ul>\n<li>Symbols: 객체에 대한 고유 키: Symbol(\"foo\") === Symbol(\"foo\"); // false. 내부적으로 사용됩니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">obj</span>: { [<span class=\"hljs-attr\">index</span>: string]: string } = {};\n\n<span class=\"hljs-keyword\">const</span> symbolA = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">'a'</span>);\n<span class=\"hljs-keyword\">const</span> symbolB = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">'b'</span>);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(symbolA.<span class=\"hljs-property\">description</span>); <span class=\"hljs-comment\">// \"a\"</span>\n\nobj[symbolA] = <span class=\"hljs-string\">'a'</span>;\nobj[symbolB] = <span class=\"hljs-string\">'b'</span>;\nobj[<span class=\"hljs-string\">'c'</span>] = <span class=\"hljs-string\">'c'</span>;\nobj.<span class=\"hljs-property\">d</span> = <span class=\"hljs-string\">'d'</span>;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj[symbolA]); <span class=\"hljs-comment\">// \"a\"</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj[symbolB]); <span class=\"hljs-comment\">// \"b\"</span>\n\n<span class=\"hljs-comment\">// 다른 심볼이나 심볼 없이는 키에 액세스할 수 없습니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj[<span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">'a'</span>)]); <span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj[<span class=\"hljs-string\">'a'</span>]); <span class=\"hljs-comment\">// undefined</span>\n\n<span class=\"hljs-comment\">// for ... in을 사용할 때 키가 열거되지 않습니다.</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> i <span class=\"hljs-keyword\">in</span> obj) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i); <span class=\"hljs-comment\">// \"c\", \"d\"</span>\n}\n</code></pre>\n<h2>ES2020</h2>\n<ul>\n<li>Optional chaining: 잠재적으로 정의되지 않은 객체의 값을 (인덱싱을 통해) 액세스하기 위해 부모 객체 이름 뒤에 ?를 사용하여 선택적 연결을 사용할 수 있습니다. 이는 인덱싱 ([...]) 또는 함수 호출에도 사용할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-comment\">// 우리가 정확히 정의된 것인지 확신할 수 없는 객체 변수 (또는 다른 구조)가 있을 때,</span>\n<span class=\"hljs-comment\">// 속성에 쉽게 액세스할 수 없습니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">object</span>: { <span class=\"hljs-attr\">name</span>: string } | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() > <span class=\"hljs-number\">0.5</span> ? <span class=\"hljs-literal\">undefined</span> : { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'test'</span> };\n<span class=\"hljs-keyword\">const</span> value = object.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">// 타입 오류: 'object' 가 'undefined' 일 수 있습니다.</span>\n\n<span class=\"hljs-comment\">// 먼저 정의되었는지 확인해야 했지만, 이는 가독성을 해치며 중첩된 객체에 대해 복잡해집니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">objectOld</span>: { <span class=\"hljs-attr\">name</span>: string } | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() > <span class=\"hljs-number\">0.5</span> ? <span class=\"hljs-literal\">undefined</span> : { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'test'</span> };\n<span class=\"hljs-keyword\">const</span> valueOld = objectOld ? objectOld.<span class=\"hljs-property\">name</span> : <span class=\"hljs-literal\">undefined</span>;\n\n<span class=\"hljs-comment\">// 새로운 방법:</span>\n<span class=\"hljs-comment\">// 대신 선택적 연결을 사용할 수 있습니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">objectNew</span>: { <span class=\"hljs-attr\">name</span>: string } | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() > <span class=\"hljs-number\">0.5</span> ? <span class=\"hljs-literal\">undefined</span> : { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'test'</span> };\n<span class=\"hljs-keyword\">const</span> valueNew = objectNew?.<span class=\"hljs-property\">name</span>;\n\n<span class=\"hljs-comment\">// 이것은 인덱싱 및 함수에도 사용할 수 있습니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">array</span>: string[] | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() > <span class=\"hljs-number\">0.5</span> ? <span class=\"hljs-literal\">undefined</span> : [<span class=\"hljs-string\">'test'</span>];\n<span class=\"hljs-keyword\">const</span> item = array?.[<span class=\"hljs-number\">0</span>];\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">func</span>: (<span class=\"hljs-function\">() =></span> string) | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() > <span class=\"hljs-number\">0.5</span> ? <span class=\"hljs-literal\">undefined</span> : <span class=\"hljs-function\">() =></span> <span class=\"hljs-string\">'test'</span>;\n<span class=\"hljs-keyword\">const</span> result = func?.();\n</code></pre>\n<ul>\n<li>널 병합 연산자 (??): 조건부 할당을 위해 || 연산자를 사용하는 대신 새로운 ?? 연산자를 사용할 수 있습니다. 모든 거짓 값에 적용되는 대신 undefined와 null에만 적용됩니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">value</span>: string | <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() > <span class=\"hljs-number\">0.5</span> ? <span class=\"hljs-literal\">undefined</span> : <span class=\"hljs-string\">'test'</span>;\n\n<span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-comment\">// 값이 undefined 또는 null인 경우 다른 값으로 조건적으로 할당하려면 \"||\" 연산자를 사용할 수 있었습니다.</span>\n<span class=\"hljs-keyword\">const</span> anotherValue = value || <span class=\"hljs-string\">'hello'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(anotherValue); <span class=\"hljs-comment\">// \"test\" 또는 \"hello\"</span>\n\n<span class=\"hljs-comment\">// 이는 참 값 사용 시 잘 작동하지만, 0이나 빈 문자열과 비교할 경우에도 적용됩니다.</span>\n<span class=\"hljs-keyword\">const</span> incorrectValue = <span class=\"hljs-string\">''</span> || <span class=\"hljs-string\">'incorrect'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(incorrectValue); <span class=\"hljs-comment\">// 항상 \"incorrect\"</span>\n<span class=\"hljs-keyword\">const</span> anotherIncorrectValue = <span class=\"hljs-number\">0</span> || <span class=\"hljs-string\">'incorrect'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(anotherIncorrectValue); <span class=\"hljs-comment\">// 항상 \"incorrect\"</span>\n\n<span class=\"hljs-comment\">// 새로운 방법:</span>\n<span class=\"hljs-comment\">// 이제 nullish 병합 연산자를 사용할 수 있습니다. 이는 오직 undefined와 null 값에만 적용됩니다.</span>\n<span class=\"hljs-keyword\">const</span> newValue = value ?? <span class=\"hljs-string\">'hello'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newValue) <span class=\"hljs-comment\">// 항상 \"hello\"</span>\n\n<span class=\"hljs-comment\">// 이제 falsy 값들이 교체되지 않습니다.</span>\n<span class=\"hljs-keyword\">const</span> correctValue = <span class=\"hljs-string\">''</span> ?? <span class=\"hljs-string\">'incorrect'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(correctValue); <span class=\"hljs-comment\">// 항상 \"\"</span>\n<span class=\"hljs-keyword\">const</span> anotherCorrectValue = <span class=\"hljs-number\">0</span> ?? <span class=\"hljs-string\">'incorrect'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(anotherCorrectValue); <span class=\"hljs-comment\">// 항상 0</span>\n</code></pre>\n<ul>\n<li>import(): 변수를 사용하여 런타임에서 동적으로 import ... from ... 처럼 모듈을 가져올 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> importModule;\n<span class=\"hljs-keyword\">if</span> (shouldImport) {\n  importModule = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./module.mjs'</span>);\n}\n</code></pre>\n<ul>\n<li>String.matchAll(): 루프를 사용하지 않고 정규 표현식의 여러 일치 항목과 캡처 그룹을 모두 얻을 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> stringVar = <span class=\"hljs-string\">'testhello,testagain,'</span>;\n\n<span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-comment\">// 일치 항목만 검색되며 캡처 그룹은 포함되지 않습니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(stringVar.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/test([\\w]+?),/g</span>)); <span class=\"hljs-comment\">// [\"testhello,\", \"testagain,\"]</span>\n\n<span class=\"hljs-comment\">// 캡처 그룹을 포함한 하나의 일치 항목만 검색합니다.</span>\n<span class=\"hljs-keyword\">const</span> singleMatch = stringVar.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/test([\\w]+?),/</span>);\n<span class=\"hljs-keyword\">if</span> (singleMatch) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(singleMatch[<span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// \"testhello,\"</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(singleMatch[<span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">// \"hello\"</span>\n}\n\n<span class=\"hljs-comment\">// 같은 결과를 얻지만 매우 직관적이지 않습니다 (exec 메서드는 마지막 인덱스를 저장합니다).</span>\n<span class=\"hljs-comment\">// 루프 외부에서 정의되어야 하며 전역으로 선언되어야 하며 (/g) 모드여야 합니다.</span>\n<span class=\"hljs-keyword\">const</span> regex = <span class=\"hljs-regexp\">/test([\\w]+?),/g</span>;\n<span class=\"hljs-keyword\">let</span> execMatch;\n<span class=\"hljs-keyword\">while</span> ((execMatch = regex.<span class=\"hljs-title function_\">exec</span>(stringVar)) !== <span class=\"hljs-literal\">null</span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(execMatch[<span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// \"testhello,\", \"testagain,\"</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(execMatch[<span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">// \"hello\", \"again\"</span>\n}\n\n<span class=\"hljs-comment\">// 새로운 방법:</span>\n<span class=\"hljs-comment\">// 정규식은 전역 (/g)이어야 합니다. 그렇지 않으면 작동하지 않습니다.</span>\n<span class=\"hljs-keyword\">const</span> matchesIterator = stringVar.<span class=\"hljs-title function_\">matchAll</span>(<span class=\"hljs-regexp\">/test([\\w]+?),/g</span>);\n<span class=\"hljs-comment\">// 순회해야 하거나 배열(Array.from())로 변환해야 하며 직접 색인화(인덱싱)할 수 없습니다.</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> match <span class=\"hljs-keyword\">of</span> matchesIterator) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(match[<span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// \"testhello,\", \"testagain,\"</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(match[<span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">// \"hello\", \"again\"</span>\n}\n</code></pre>\n<ul>\n<li>Promise.allSettled(): Promise.all()과 유사하지만 모든 Promise가 완료될 때까지 기다리며 첫 번째 reject/throw에서 반환하지 않습니다. 모든 오류 처리를 보다 쉽게 할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">success1</span>(<span class=\"hljs-params\"></span>) {<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'a'</span>}\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">success2</span>(<span class=\"hljs-params\"></span>) {<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'b'</span>}\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fail1</span>(<span class=\"hljs-params\"></span>) {<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">'fail 1'</span>}\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fail2</span>(<span class=\"hljs-params\"></span>) {<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">'fail 2'</span>}\n\n<span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<span class=\"hljs-title function_\">success1</span>(), <span class=\"hljs-title function_\">success2</span>()])); <span class=\"hljs-comment\">// [\"a\", \"b\"]</span>\n<span class=\"hljs-comment\">// 하지만:</span>\n<span class=\"hljs-keyword\">try</span> {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<span class=\"hljs-title function_\">success1</span>(), <span class=\"hljs-title function_\">success2</span>(), <span class=\"hljs-title function_\">fail1</span>(), <span class=\"hljs-title function_\">fail2</span>()]);\n} <span class=\"hljs-keyword\">catch</span> (e) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); <span class=\"hljs-comment\">// \"fail 1\"</span>\n}\n<span class=\"hljs-comment\">// 주의: 하나의 에러만 처리하고 성공 값에 액세스할 수 없습니다.</span>\n\n<span class=\"hljs-comment\">// 이전 해결 방법 (정말 최적이 아님):</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([ <span class=\"hljs-comment\">// [\"a\", \"b\", undefined, undefined]</span>\n  <span class=\"hljs-title function_\">success1</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); }),\n  <span class=\"hljs-title function_\">success2</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); }),\n  <span class=\"hljs-title function_\">fail1</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); }), <span class=\"hljs-comment\">// \"fail 1\"</span>\n  <span class=\"hljs-title function_\">fail2</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); })])); <span class=\"hljs-comment\">// \"fail 2\"</span>\n\n<span class=\"hljs-comment\">// 새로운 방법:</span>\n<span class=\"hljs-keyword\">const</span> results = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">allSettled</span>([<span class=\"hljs-title function_\">success1</span>(), <span class=\"hljs-title function_\">success2</span>(), <span class=\"hljs-title function_\">fail1</span>(), <span class=\"hljs-title function_\">fail2</span>()]);\n<span class=\"hljs-keyword\">const</span> sucessfulResults = results\n  .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =></span> result.<span class=\"hljs-property\">status</span> === <span class=\"hljs-string\">'fulfilled'</span>)\n  .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =></span> (result <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">PromiseFulfilledResult</span>&#x3C;string>).<span class=\"hljs-property\">value</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(sucessfulResults); <span class=\"hljs-comment\">// [\"a\", \"b\"]</span>\nresults.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =></span> result.<span class=\"hljs-property\">status</span> === <span class=\"hljs-string\">'rejected'</span>).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>((error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">PromiseRejectedResult</span>).<span class=\"hljs-property\">reason</span>); <span class=\"hljs-comment\">// \"fail 1\", \"fail 2\"</span>\n});\n<span class=\"hljs-comment\">// 또는:</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> result <span class=\"hljs-keyword\">of</span> results) {\n  <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">status</span> === <span class=\"hljs-string\">'fulfilled'</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result.<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// \"a\", \"b\"</span>\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">status</span> === <span class=\"hljs-string\">'rejected'</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result.<span class=\"hljs-property\">reason</span>); <span class=\"hljs-comment\">// \"fail 1\", \"fail 2\"</span>\n  }\n}\n</code></pre>\n<ul>\n<li>BigInt: 새로운 BigInt 데이터 유형을 사용하여 큰 (정수) 숫자를 정확하게 저장하고 처리할 수 있어 JavaScript가 숫자를 부동 소수점으로 저장하는 것에 의한 오류를 방지할 수 있습니다. BigInt() 생성자를 사용하여 생성할 수 있고(불완전성을 방지하기 위해 문자열을 선호) 또는 숫자 끝에 n을 추가하여 생성할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-md\">// 이전:\n// JavaScript는 숫자를 부동 소수점으로 저장하기 때문에 항상 약간의 부정확성이 있습니다.\n// 더 중요한 것은 특정 숫자 이후에 정수 연산에 부정확성이 시작됩니다.\nconst maxSafeInteger = 9007199254740991;\nconsole.log(maxSafeInteger === Number.MAX<span class=\"hljs-emphasis\">_SAFE_</span>INTEGER); // true\n\n// 해당 숫자보다 큰 숫자와 비교하면 부정확성이 발생할 수 있습니다.\nconsole.log(Number.MAX<span class=\"hljs-emphasis\">_SAFE_</span>INTEGER + 1 === Number.MAX<span class=\"hljs-emphasis\">_SAFE_</span>INTEGER + 2);\n\n// NEW:\n// BigInt 데이터 형식을 사용하면 이론적으로 무한히 큰 (정수) 숫자를 저장하고 조작할 수 있습니다.\n// 숫자 끝에 \"n\"을 추가하거나 BigInt 생성자를 사용하여 사용합니다.\nconst maxSafeIntegerPreviously = 9007199254740991n;\nconsole.log(maxSafeIntegerPreviously); // 9007199254740991\n\nconst anotherWay = BigInt(9007199254740991);\nconsole.log(anotherWay); // 9007199254740991\n\n// 안전한 정수(Number.MAX<span class=\"hljs-emphasis\">_SAFE_</span>INTEGER)보다 큰 정수를 전달하면 안됩니다.\nconst incorrect = BigInt(9007199254740992);\nconsole.log(incorrect); // 9007199254740992\nconst incorrectAgain = BigInt(9007199254740993);\nconsole.log(incorrectAgain); // 9007199254740992\n// 오랜, 동일한 값으로 변환됩니다.\n\n// 대신 문자열을 사용하거나 더 좋은 다른 구문을 사용합니다.\nconst correct = BigInt('9007199254740993');\nconsole.log(correct); // 9007199254740993\nconst correctAgain = 9007199254740993n;\nconsole.log(correctAgain); // 9007199254740993\n\n// 16진수, 8진수 및 2진수도 문자열로 전달할 수 있습니다.\nconst hex = BigInt('0x1fffffffffffff');\nconsole.log(hex); // 9007199254740991\nconst octal = BigInt('0o377777777777777777');\nconsole.log(octal); // 9007199254740991\nconst binary = BigInt('0b11111111111111111111111111111111111111111111111111111');\nconsole.log(binary); // 9007199254740991\n\n// 대부분의 산술 연산은 예상대로 작동하지만 다른 연산자도 BigInt 여야합니다. 모든 연산도 BigInt를 반환합니다.\nconst addition = maxSafeIntegerPreviously + 2n;\nconsole.log(addition); // 9007199254740993\n\nconst multiplication = maxSafeIntegerPreviously * 2n;\nconsole.log(multiplication); // 18014398509481982\n\nconst subtraction = multiplication - 10n;\nconsole.log(subtraction); // 18014398509481972\n\nconst modulo = multiplication % 10n;\nconsole.log(modulo); // 2\n\nconst exponentiation = 2n ** 54n;\nconsole.log(exponentiation); // 18014398509481984\n\nconst exponentiationAgain = 2n ^ 54n;\nconsole.log(exponentiationAgain); // 18014398509481984\n\nconst negative = exponentiation * -1n;\nconsole.log(negative); // -18014398509481984\n\n// BigInt로 인한 정수 나눗셈은 조금 다르게 작동합니다.\nconst division = multiplication / 2n;\nconsole.log(division); // 9007199254740991\n// 나뉠 수 있는 정수에 대해서는 제대로 작동합니다.\n\n// 나누기가 안 되는 숫자에 대해서는 정수 나눗셈(내림)처럼 작동할 것입니다.\nconst divisionAgain = 5n / 2n;\nconsole.log(divisionAgain); // 2\n\n// 일치하는(엄격한) 비교가 BigInt 숫자에는 적용되지 않습니다.\nconsole.log(0n === 0); // false\nconsole.log(0n == 0); // true\n\n// 그러나 비교는 예상대로 작동합니다.\nconsole.log(1n &#x3C; 2); // true\nconsole.log(2n > 1); // true\nconsole.log(2 > 2); // false\nconsole.log(2n > 2); // false\nconsole.log(2n >= 2); // true\n\n// 타입은 \"bigint\"입니다.\nconsole.log(typeof 1n); // \"bigint\"\n\n// 일반 숫자(부호있는 부호 없는 (음수 없음))로 다시 변환할 수 있습니다.\n// 그러나 이는 정확도를 희생합니다. 유효 숫자의 수를 지정할 수 있습니다.\n\nconsole.log(BigInt.asIntN(0, -2n)); // 0\nconsole.log(BigInt.asIntN(1, -2n)); // 0\nconsole.log(BigInt.asIntN(2, -2n)); // -2\n// 보통 더 높은 비트 수를 사용할 것입니다.\n\n// 음수 숫자는 부호가 있는 숫자로 변환될 때 2의 보수로 변환됩니다.\nconsole.log(BigInt.asUintN(8, -2n)); // 254\n</code></pre>\n<ul>\n<li>globalThis: 환경(브라우저, NodeJS, ...)와 상관없이 전역 컨텍스트에서 변수에 액세스할 수 있습니다. 여전히 권장되지는 않지만 때로는 필요합니다. 브라우저의 최상위 수준에서 this와 유사합니다.</li>\n</ul>\n<pre><code class=\"hljs language-md\">console.log(globalThis.Math); // Math Object\n</code></pre>\n<ul>\n<li>import.meta: ES-모듈을 사용할 때 현재 모듈 URL import.meta.url을 얻습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>); <span class=\"hljs-comment\">// \"file://...\"</span>\n</code></pre>\n<ul>\n<li>export * as … from …: 쉽게 기본값을 하위 모듈로 다시 내보냅니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">as</span> am <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'another-module'</span>\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { am } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>\n</code></pre>\n<h2>ES2021</h2>\n<ul>\n<li>String.replaceAll(): 이제 문자열 내에서 부분 문자열의 모든 인스턴스를 대체할 수 있습니다. 더 이상 항상 전역 플래그(/g)를 사용하는 정규 표현식을 사용할 필요가 없습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> testString = <span class=\"hljs-string\">'hello/greetings everyone/everybody'</span>;\n<span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-comment\">// 첫 번째 인스턴스만 대체함</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(testString.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">'/'</span>, <span class=\"hljs-string\">'|'</span>)); <span class=\"hljs-comment\">// 'hello|greetings everyone/everybody'</span>\n\n<span class=\"hljs-comment\">// 대체하기 위해 정규 표현식을 사용해야 했는데, 이는 성능이 좋지 않고 이스케이프가 필요합니다.</span>\n<span class=\"hljs-comment\">// 전역 플래그(/g)를 참고하세요.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(testString.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/\\//g</span>, <span class=\"hljs-string\">'|'</span>)); <span class=\"hljs-comment\">// 'hello|greetings everyone|everybody'</span>\n\n<span class=\"hljs-comment\">// 새로운 기능:</span>\n<span class=\"hljs-comment\">// replaceAll을 사용하면 더 명확하고 빠릅니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(testString.<span class=\"hljs-title function_\">replaceAll</span>(<span class=\"hljs-string\">'/'</span>, <span class=\"hljs-string\">'|'</span>)); <span class=\"hljs-comment\">// 'hello|greetings everyone|everybody'</span>\n</code></pre>\n<ul>\n<li>Promise.any(): 프로미스 목록 중 하나의 결과만 필요한 경우, 첫 번째 결과를 반환합니다. 모든 프로미스가 거부될 때만 거부하고 AggregateError를 반환하며, 즉시 거부되는 Promise.race가 아닙니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([<span class=\"hljs-title function_\">success1</span>(), <span class=\"hljs-title function_\">success2</span>()])); <span class=\"hljs-comment\">// \"a\"</span>\n<span class=\"hljs-comment\">// 그러나:</span>\n<span class=\"hljs-keyword\">try</span> {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([<span class=\"hljs-title function_\">fail1</span>(), <span class=\"hljs-title function_\">fail2</span>(), <span class=\"hljs-title function_\">success1</span>(), <span class=\"hljs-title function_\">success2</span>()]);\n} <span class=\"hljs-keyword\">catch</span> (e) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); <span class=\"hljs-comment\">// \"fail 1\"</span>\n}\n<span class=\"hljs-comment\">// 유의: 하나의 오류만 catch하고 성공 값을 액세스할 수 없습니다.</span>\n\n<span class=\"hljs-comment\">// 이전 수정 (정말 최적화되지 않음):</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([ <span class=\"hljs-comment\">// \"a\"</span>\n  <span class=\"hljs-title function_\">fail1</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); }), <span class=\"hljs-comment\">// \"fail 1\"</span>\n  <span class=\"hljs-title function_\">fail2</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); }), <span class=\"hljs-comment\">// \"fail 2\"</span>\n  <span class=\"hljs-title function_\">success1</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); }),\n  <span class=\"hljs-title function_\">success2</span>().<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); })]));\n\n<span class=\"hljs-comment\">// 새로운:</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">any</span>([<span class=\"hljs-title function_\">fail1</span>(), <span class=\"hljs-title function_\">fail2</span>(), <span class=\"hljs-title function_\">success1</span>(), <span class=\"hljs-title function_\">success2</span>()])); <span class=\"hljs-comment\">// \"a\"</span>\n<span class=\"hljs-comment\">// 모든 프로미스가 거부될 때만 거부하고 모든 오류를 포함하는 AggregateError를 리턴합니다.</span>\n<span class=\"hljs-keyword\">try</span> {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">any</span>([<span class=\"hljs-title function_\">fail1</span>(), <span class=\"hljs-title function_\">fail2</span>()]);\n} <span class=\"hljs-keyword\">catch</span> (e) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e); <span class=\"hljs-comment\">// [AggregateError: All promises were rejected]</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e.<span class=\"hljs-property\">errors</span>); <span class=\"hljs-comment\">// [\"fail 1\", \"fail 2\"]</span>\n}\n</code></pre>\n<ul>\n<li>Nullish coalescing assignment (??=): 이전에 \"nullish\"였을 때만 값을 할당합니다 (null 또는 undefined).</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> x1 = <span class=\"hljs-literal\">undefined</span>;\n<span class=\"hljs-keyword\">let</span> x2 = <span class=\"hljs-string\">'a'</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getNewValue</span> = (<span class=\"hljs-params\"></span>) => <span class=\"hljs-string\">'b'</span>;\n\n<span class=\"hljs-comment\">// undefined는 nullish이므로 새 값이 x1에 할당됩니다.</span>\nx1 ??= <span class=\"hljs-string\">'b'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x1) <span class=\"hljs-comment\">// \"b\"</span>\n\n<span class=\"hljs-comment\">// 문자열은 nullish가 아니므로 x2에 새 값이 할당되지 않습니다.</span>\n<span class=\"hljs-comment\">// 또한 참고: getNewValue()가 실행되지 않습니다.</span>\nx2 ??= <span class=\"hljs-title function_\">getNewValue</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x2) <span class=\"hljs-comment\">// \"a\"</span>\n</code></pre>\n<ul>\n<li>Logical and assignment (&#x26;&#x26;=): 이전에 \"truthy\"였을 때만 값을 할당합니다 (true 또는 true로 변환되는 값).```</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> x1 = <span class=\"hljs-literal\">undefined</span>;\n<span class=\"hljs-keyword\">let</span> x2 = <span class=\"hljs-string\">'a'</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getNewValue</span> = (<span class=\"hljs-params\"></span>) => <span class=\"hljs-string\">'b'</span>;\n\n<span class=\"hljs-comment\">// 지정되지 않은 값인 x1에 새 값이 할당되지 않습니다. 왜냐하면 지정되지 않은 값은 참이 아닙니다.</span>\n<span class=\"hljs-comment\">// 또한 주의: getNewValue()는 실행되지 않습니다.</span>\nx1 &#x26;&#x26;= <span class=\"hljs-title function_\">getNewValue</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x1) <span class=\"hljs-comment\">// undefined</span>\n\n<span class=\"hljs-comment\">// 문자열은 참이므로 새 값이 x2에 할당됩니다.</span>\nx2 &#x26;&#x26;= <span class=\"hljs-string\">'b'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x2) <span class=\"hljs-comment\">// \"b\"</span>\n</code></pre>\n<ul>\n<li>논리 또는 할당 (||=): 이전에 \"거짓\"인 경우에만 값이 할당됩니다 (false 또는 false로 변환).</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> x1 = <span class=\"hljs-literal\">undefined</span>;\n<span class=\"hljs-keyword\">let</span> x2 = <span class=\"hljs-string\">'a'</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getNewValue</span> = (<span class=\"hljs-params\"></span>) => <span class=\"hljs-string\">'b'</span>;\n\n<span class=\"hljs-comment\">// x1에 새 값이 할당됩니다. 왜냐하면 지정되지 않은 값은 거짓이기 때문입니다.</span>\nx1 ||= <span class=\"hljs-string\">'b'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x1) <span class=\"hljs-comment\">// \"b\"</span>\n\n<span class=\"hljs-comment\">// x2에 새 값이 할당되지 않습니다. 왜냐하면 문자열은 거짓이 아닙니다.</span>\n<span class=\"hljs-comment\">// 또한 주의: getNewValue()는 실행되지 않습니다.</span>\nx2 ||= <span class=\"hljs-title function_\">getNewValue</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x2) <span class=\"hljs-comment\">// \"a\"</span>\n</code></pre>\n<ul>\n<li>WeakRef: 객체가 가비지 수집되는 것을 방지하지 않고 객체에 \"약한\" 참조를 보유합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> ref = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakRef</span>(element);\n\n<span class=\"hljs-comment\">// 만약 객체/요소가 여전히 존재하고 쓰레기 수집되지 않았다면 값을 가져옵니다.</span>\n<span class=\"hljs-keyword\">const</span> value = ref.<span class=\"hljs-property\">deref</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value); <span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-comment\">// 객체가 더는 존재하지 않는 것 같습니다.</span>\n</code></pre>\n<ul>\n<li>숫자 리터럴 구분자 (_): 가독성을 위해 숫자를 _로 구분합니다. 이는 기능에 영향을 미치지 않습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> int = <span class=\"hljs-number\">1_000_000_000</span>;\n<span class=\"hljs-keyword\">const</span> float = <span class=\"hljs-number\">1_000_000_000.999_999_999</span>;\n<span class=\"hljs-keyword\">const</span> max = <span class=\"hljs-number\">9_223_372_036_854_775_807n</span>;\n<span class=\"hljs-keyword\">const</span> binary = <span class=\"hljs-number\">0b1011_0101_0101</span>;\n<span class=\"hljs-keyword\">const</span> octal = <span class=\"hljs-number\">0o1234_5670</span>;\n<span class=\"hljs-keyword\">const</span> hex = <span class=\"hljs-number\">0xD0_E0_F0</span>;\n</code></pre>\n<h2>ES2022</h2>\n<ul>\n<li>최상위 대기: await 키워드는 이제 ES 모듈의 최상위 수준에서 사용할 수 있습니다. 이는 래퍼 함수의 필요성을 제거하고 오류 처리를 개선합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">asyncFuncSuccess</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'test'</span>;\n}\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">asyncFuncFail</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">'Test'</span>);\n}\n\n<span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-comment\">// 프로미스를 대기하려면 async 함수 내부에서만 가능했습니다.</span>\n<span class=\"hljs-comment\">// await asyncFuncSuccess(); // SyntaxError: await is only valid in async functions</span>\n<span class=\"hljs-comment\">// 따라서 async 함수 내부로 래핑해야 했고 이는 오류 처리와 최상위 동시성을 잃게 했습니다.</span>\n<span class=\"hljs-keyword\">try</span> {\n  (<span class=\"hljs-keyword\">async</span> () => {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">asyncFuncSuccess</span>()); <span class=\"hljs-comment\">// \"test\"</span>\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">asyncFuncFail</span>();\n    } <span class=\"hljs-keyword\">catch</span> (e) {\n      <span class=\"hljs-comment\">// 오류 처리를 위해 필요합니다. 그렇지 않으면 오류가 캐치되지 않거나 적절한 추적 없이 너무 늦게 되어버립니다.</span>\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e); <span class=\"hljs-comment\">// Error: \"Test\"</span>\n      <span class=\"hljs-keyword\">throw</span> e;\n    }\n  })();\n} <span class=\"hljs-keyword\">catch</span> (e) {\n  <span class=\"hljs-comment\">// 함수가 async여서 절대 호출되지 않거나(적절한 추적이 없거나 너무 늦게) 이유 때문에</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e);\n}\n\n<span class=\"hljs-comment\">// 비동기 함수가 기다려지지 않았기 때문에 이 프로미스 결과보다 먼저 기록됩니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Hey'</span>); <span class=\"hljs-comment\">// \"Hey\"</span>\n\n<span class=\"hljs-comment\">// 새로운:</span>\n<span class=\"hljs-comment\">// 파일이 ES 모듈이라면(package.json에 설정되었고, exports가 있고, \".mts\"로 명명된 경우) 최상위 수준에서 바로 await할 수 있습니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">asyncFuncSuccess</span>()); <span class=\"hljs-comment\">// \"test\"</span>\n<span class=\"hljs-keyword\">try</span> {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">asyncFuncFail</span>();\n} <span class=\"hljs-keyword\">catch</span> (e) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e); <span class=\"hljs-comment\">// Error: \"Test\"</span>\n}\n\n<span class=\"hljs-comment\">// 모든 비동기 호출이 기다려지기 때문에 이 프로미스 결과 뒤에 기록됩니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Hello'</span>); <span class=\"hljs-comment\">// \"Hello\"</span>\n</code></pre>\n<ul>\n<li>#private: 클래스 멤버(속성 및 메서드)를 이름이 #로 시작하게하여 비공개로 만듭니다. 따라서 이러한 멤버는 클래스 내부에서만 액세스할 수 있습니다. 삭제되거나 동적으로 할당할 수 없습니다. 잘못된 동작은 JavaScript(하지만 TypeScript가 아닌) 구문 오류를 발생시킵니다. TypeScript 프로젝트에서는 권장되지 않습니다. 대신 기존 private 키워드를 사용하십시오.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassWithPrivateField</span> {\n  #privateField;\n  #anotherPrivateField = <span class=\"hljs-number\">4</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.#privateField = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// 유효</span>\n    <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-variable language_\">this</span>.#privateField; <span class=\"hljs-comment\">// 구문 오류</span>\n    <span class=\"hljs-variable language_\">this</span>.#undeclaredField = <span class=\"hljs-number\">444</span>; <span class=\"hljs-comment\">// 구문 오류</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.#anotherPrivateField); <span class=\"hljs-comment\">// 4</span>\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> instance = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ClassWithPrivateField</span>();\ninstance.#privateField === <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// 구문 오류</span>\n</code></pre>\n<ul>\n<li>static 클래스 멤버: 클래스 필드(속성 및 메서드)를 static으로 표시하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> {\n  <span class=\"hljs-keyword\">static</span> id = <span class=\"hljs-string\">'Logger1'</span>;\n  <span class=\"hljs-keyword\">static</span> type = <span class=\"hljs-string\">'GenericLogger'</span>;\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">message: string | <span class=\"hljs-built_in\">Error</span></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ErrorLogger</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Logger</span> {\n  <span class=\"hljs-keyword\">static</span> type = <span class=\"hljs-string\">'ErrorLogger'</span>;\n  <span class=\"hljs-keyword\">static</span> qualifiedType;\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">e: <span class=\"hljs-built_in\">Error</span></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">log</span>(e.<span class=\"hljs-title function_\">toString</span>());\n  }\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Logger</span>.<span class=\"hljs-property\">type</span>); <span class=\"hljs-comment\">// \"GenericLogger\"</span>\n<span class=\"hljs-title class_\">Logger</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Test'</span>); <span class=\"hljs-comment\">// \"Test\"</span>\n\n<span class=\"hljs-comment\">// 정적으로만 있는 클래스를 생성하는 것은 무의미하지만 여기선 시연을 위해 수행되었습니다.</span>\n<span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Logger</span>();\n\n<span class=\"hljs-title class_\">ErrorLogger</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">'Test'</span>)); <span class=\"hljs-comment\">// 에러: \"Test\" (부모 클래스의 생성에 영향을 받지 않음)</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">ErrorLogger</span>.<span class=\"hljs-property\">type</span>); <span class=\"hljs-comment\">// \"ErrorLogger\"</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">ErrorLogger</span>.<span class=\"hljs-property\">qualifiedType</span>); <span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">ErrorLogger</span>.<span class=\"hljs-property\">id</span>); <span class=\"hljs-comment\">// \"Logger1\"</span>\n\n<span class=\"hljs-comment\">// log()가 인스턴스 메서드가 아닌 정적 메서드이기 때문에 예외를 발생시킵니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(log.<span class=\"hljs-title function_\">log</span>()); <span class=\"hljs-comment\">// log.log is not a function</span>\n</code></pre>\n<ul>\n<li>클래스 내의 정적 초기화 블록: 클래스가 초기화될 때 실행되는 블록, 기본적으로 정적 멤버를 초기화하는 \"생성자\"입니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> {\n  <span class=\"hljs-keyword\">static</span> staticProperty1 = <span class=\"hljs-string\">'속성 1'</span>;\n  <span class=\"hljs-keyword\">static</span> staticProperty2;\n  <span class=\"hljs-keyword\">static</span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">staticProperty2</span> = <span class=\"hljs-string\">'속성 2'</span>;\n  }\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Test</span>.<span class=\"hljs-property\">staticProperty1</span>); <span class=\"hljs-comment\">// \"Property 1\"</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Test</span>.<span class=\"hljs-property\">staticProperty2</span>); <span class=\"hljs-comment\">// \"Property 2\"</span>\n</code></pre>\n<ul>\n<li>가져오기 어설션 (비표준, V8에서 구현됨): 가져온 항목의 유형을 확인하기 위해 사용할 수 있습니다. <code>import ... from ... assert ' type: </code>json<code> '</code>로 JSON을 직접 가져오고 구문 분석할 필요 없이 사용할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> json <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./foo.json'</span> assert { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'json'</span> };\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(json.<span class=\"hljs-property\">answer</span>); <span class=\"hljs-comment\">// 42</span>\n</code></pre>\n<ul>\n<li>정규표현식 일치 인덱스: 정규표현식 일치 및 캡처 그룹의 시작 및 끝 인덱스를 가져올 수 있습니다. RegExp.exec(), String.match() 및 String.matchAll()에 대해 작동합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> matchObj = <span class=\"hljs-regexp\">/(test+)(hello+)/</span>d.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">'start-testesthello-stop'</span>);\n\n<span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(matchObj?.<span class=\"hljs-property\">index</span>);\n\n<span class=\"hljs-comment\">// 새로운:</span>\n<span class=\"hljs-keyword\">if</span> (matchObj) {\n  <span class=\"hljs-comment\">// 전체 일치 항목의 시작 및 끝 인덱스(이전에 시작만 있었음).</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(matchObj.<span class=\"hljs-property\">indices</span>[<span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// [9, 18]</span>\n\n  <span class=\"hljs-comment\">// 캡처 그룹의 시작 및 끝 인덱스.</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(matchObj.<span class=\"hljs-property\">indices</span>[<span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">// [9, 13]</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(matchObj.<span class=\"hljs-property\">indices</span>[<span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// [13, 18]</span>\n}\n</code></pre>\n<ul>\n<li>Negative indexing (.at(-1)): 배열이나 문자열을 인덱싱할 때, at()을 사용하여 뒤에서부터 인덱싱할 수 있습니다. 값 가져오기(arr[arr.length - 1]와 동일)만 가능하며 값을 설정할 수는 없습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">at</span>(-<span class=\"hljs-number\">1</span>)) <span class=\"hljs-comment\">// 5</span>\n\n<span class=\"hljs-keyword\">const</span> array = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\narray.<span class=\"hljs-title function_\">at</span>(-<span class=\"hljs-number\">1</span>) = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// SyntaxError: Assigning to rvalue</span>\n</code></pre>\n<ul>\n<li>hasOwn: 객체가 어떤 속성을 가지고 있는지 obj.hasOwnProperty()을 사용하는 대신 추천되는 새 방법입니다. 일부 특수한 경우에 더 잘 작동합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'test'</span> };\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">hasOwn</span>(obj, <span class=\"hljs-string\">'name'</span>)); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">hasOwn</span>(obj, <span class=\"hljs-string\">'gender'</span>)); <span class=\"hljs-comment\">// false</span>\n</code></pre>\n<ul>\n<li>오류 원인: 이제 오류에 대한 선택적 원인을 지정할 수 있습니다. 이는 다시 throw할 때 원래 오류를 지정할 수 있게 합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">try</span> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-title function_\">connectToDatabase</span>();\n  } <span class=\"hljs-keyword\">catch</span> (err) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">'데이터베이스 연결에 실패했습니다.'</span>, { <span class=\"hljs-attr\">cause</span>: err });\n  }\n} <span class=\"hljs-keyword\">catch</span> (err) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err.<span class=\"hljs-property\">cause</span>); <span class=\"hljs-comment\">// ReferenceError: connectToDatabase is not defined</span>\n}\n</code></pre>\n<h2>미래 (이미 TypeScript 4.9에서 사용 가능)</h2>\n<ul>\n<li>Auto-Accessor: 속성을 자동으로 비공개로 만들고 get/set 접근자를 만듭니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> {\n  accessir <span class=\"hljs-attr\">name</span>: string;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name: string</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>) <span class=\"hljs-comment\">// 'test'</span>\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">'test'</span>);\n</code></pre>\n<h1>TypeScript</h1>\n<h2>기초 (추후 소개를 위한 문맥)</h2>\n<ul>\n<li>제네릭: 다른 유형으로 유형을 전달합니다. 이를 통해 유형을 일반화 할 수 있지만 여전히 유형 안전성을 유지할 수 있습니다. 항상 <code>any</code> 또는 <code>unknown</code> 대신 이를 선호해주세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// WITHOUT:</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFirstUnsafe</span>(<span class=\"hljs-params\">list: any[]</span>): any {\n  <span class=\"hljs-keyword\">return</span> list[<span class=\"hljs-number\">0</span>];\n}\n\n<span class=\"hljs-keyword\">const</span> firstUnsafe = <span class=\"hljs-title function_\">getFirstUnsafe</span>([<span class=\"hljs-string\">'test'</span>]); <span class=\"hljs-comment\">// typed as any</span>\n\n<span class=\"hljs-comment\">// WITH:</span>\n<span class=\"hljs-keyword\">function</span> getFirst&#x3C;<span class=\"hljs-title class_\">Type</span>>(<span class=\"hljs-attr\">list</span>: <span class=\"hljs-title class_\">Type</span>[]): <span class=\"hljs-title class_\">Type</span> {\n  <span class=\"hljs-keyword\">return</span> list[<span class=\"hljs-number\">0</span>];\n}\n\n<span class=\"hljs-keyword\">const</span> first = getFirst&#x3C;string>([<span class=\"hljs-string\">'test'</span>]); <span class=\"hljs-comment\">// typed as string</span>\n\n<span class=\"hljs-comment\">// In this case the parameter can even be dropped because it is inferred from the argument.</span>\n<span class=\"hljs-keyword\">const</span> firstInferred = <span class=\"hljs-title function_\">getFirst</span>([<span class=\"hljs-string\">'test'</span>]); <span class=\"hljs-comment\">// typed as string</span>\n\n<span class=\"hljs-comment\">// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">List</span>&#x3C;T <span class=\"hljs-keyword\">extends</span> string | number> {\n  private <span class=\"hljs-attr\">list</span>: T[] = [];\n\n  <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-attr\">key</span>: number): T {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">list</span>[key];\n  }\n\n  <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-attr\">value</span>: T): <span class=\"hljs-keyword\">void</span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">list</span>.<span class=\"hljs-title function_\">push</span>(value);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">List</span>&#x3C;string>();\nlist.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">9</span>); <span class=\"hljs-comment\">// Type error: Argument of type 'number' is not assignable to parameter of type 'string'.</span>\n<span class=\"hljs-keyword\">const</span> booleanList = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">List</span>&#x3C;boolean>(); <span class=\"hljs-comment\">// Type error: Type 'boolean' does not satisfy the constraint 'string | number'.</span>\n</code></pre>\n<h2>과거 (아직도 유효한 이전 소개)</h2>\n<ul>\n<li>유틸리티 타입: TypeScript에는 많은 유틸리티 타입이 포함되어 있으며, 그 중 가장 유용한 몇 가지가 여기에서 설명되었습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">Test</span> {\n  <span class=\"hljs-attr\">name</span>: string;\n  <span class=\"hljs-attr\">age</span>: number;\n}\n\n<span class=\"hljs-comment\">// Partial 유틸리티 타입은 모든 속성을 선택적으로 만듭니다.</span>\ntype <span class=\"hljs-title class_\">TestPartial</span> = <span class=\"hljs-title class_\">Partial</span>&#x3C;<span class=\"hljs-title class_\">Test</span>>; <span class=\"hljs-comment\">// typed as { name?: string | undefined; age?: number | undefined; }</span>\n<span class=\"hljs-comment\">// Required 유틸리티 타입은 반대로 동작합니다.</span>\ntype <span class=\"hljs-title class_\">TestRequired</span> = <span class=\"hljs-title class_\">Required</span>&#x3C;<span class=\"hljs-title class_\">TestPartial</span>>; <span class=\"hljs-comment\">// typed as { name: string; age: number; }</span>\n<span class=\"hljs-comment\">// Readonly 유틸리티 타입은 모든 속성을 읽기 전용으로 만듭니다.</span>\ntype <span class=\"hljs-title class_\">TestReadonly</span> = <span class=\"hljs-title class_\">Readonly</span>&#x3C;<span class=\"hljs-title class_\">Test</span>>; <span class=\"hljs-comment\">// typed as { readonly name: string; readonly age: string }</span>\n<span class=\"hljs-comment\">// Record 유틸리티 타입은 객체/맵/사전을 간단하게 정의할 수 있습니다. 가능한 경우에는 인덱스 시그니처보다 선호됩니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">config</span>: <span class=\"hljs-title class_\">Record</span>&#x3C;string, boolean> = { <span class=\"hljs-attr\">option</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">anotherOption</span>: <span class=\"hljs-literal\">true</span> };\n<span class=\"hljs-comment\">// Pick 유틸리티 타입은 지정된 속성만 가져옵니다.</span>\ntype <span class=\"hljs-title class_\">TestLess</span> = <span class=\"hljs-title class_\">Pick</span>&#x3C;<span class=\"hljs-title class_\">Test</span>, <span class=\"hljs-string\">'name'</span>>; <span class=\"hljs-comment\">// typed as { name: string; }</span>\ntype <span class=\"hljs-title class_\">TestBoth</span> = <span class=\"hljs-title class_\">Pick</span>&#x3C;<span class=\"hljs-title class_\">Test</span>, <span class=\"hljs-string\">'name'</span> | <span class=\"hljs-string\">'age'</span>>; <span class=\"hljs-comment\">// typed as { name: string; age: string; }</span>\n<span class=\"hljs-comment\">// Omit 유틸리티 타입은 지정된 속성을 무시합니다.</span>\ntype <span class=\"hljs-title class_\">TestFewer</span> = <span class=\"hljs-title class_\">Omit</span>&#x3C;<span class=\"hljs-title class_\">Test</span>, <span class=\"hljs-string\">'name'</span>>; <span class=\"hljs-comment\">// typed as { age: string; }</span>\ntype <span class=\"hljs-title class_\">TestNone</span> = <span class=\"hljs-title class_\">Omit</span>&#x3C;<span class=\"hljs-title class_\">Test</span>, <span class=\"hljs-string\">'name'</span> | <span class=\"hljs-string\">'age'</span>>; <span class=\"hljs-comment\">// typed as {}</span>\n<span class=\"hljs-comment\">// Parameters 유틸리티 타입은 함수 타입의 매개변수를 가져옵니다.</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSmth</span>(<span class=\"hljs-params\">value: string, anotherValue: number</span>): string {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'test'</span>;\n}\ntype <span class=\"hljs-title class_\">Params</span> = <span class=\"hljs-title class_\">Parameters</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> doSmth>; <span class=\"hljs-comment\">// typed as [value: string, anotherValue: number]</span>\n<span class=\"hljs-comment\">// ReturnType 유틸리티 타입은 함수 타입의 반환 타입을 가져옵니다.</span>\ntype <span class=\"hljs-title class_\">Return</span> = <span class=\"hljs-title class_\">ReturnType</span>&#x3C;<span class=\"hljs-keyword\">typeof</span> doSmth>; <span class=\"hljs-comment\">// typed as string</span>\n\n<span class=\"hljs-comment\">// 이 외에도 많은 유틸리티 타입이 있으며, 그 중 일부는 아래에서 소개됩니다.</span>\n</code></pre>\n<ul>\n<li>조건부 타입: 어떤 타입이 다른 타입과 일치/확장되면 그에 따라 타입을 조건부로 설정합니다. 이는 JavaScript의 조건부(삼항) 연산자와 비슷하게 해석될 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 배열인 경우에만 배열 타입을 추출하고, 그렇지 않으면 동일한 타입을 반환합니다.</span>\ntype <span class=\"hljs-title class_\">Flatten</span>&#x3C;T> = T <span class=\"hljs-keyword\">extends</span> any[] ? T[number] : T;\n\n<span class=\"hljs-comment\">// 요소 타입을 추출합니다.</span>\ntype <span class=\"hljs-title class_\">Str</span> = <span class=\"hljs-title class_\">Flatten</span>&#x3C;string[]>; <span class=\"hljs-comment\">// string 타입으로 지정됨</span>\n\n<span class=\"hljs-comment\">// 타입을 그대로 유지합니다.</span>\ntype <span class=\"hljs-title class_\">Num</span> = <span class=\"hljs-title class_\">Flatten</span>&#x3C;number>; <span class=\"hljs-comment\">// number 타입으로 지정됨</span>\n</code></pre>\n<ul>\n<li>조건부 타입으로 추론: 모든 일반 타입이 소비자에 의해 명시적으로 지정되어야 하는 것은 아닙니다. 일부는 코드로부터 추론될 수도 있습니다. 추론된 타입을 기반으로 조건부 논리를 작성하려면 infer 키워드가 필요합니다. 이는 일시적인 추론된 타입 변수를 정의하는 방식입니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이전 예제를 기반으로 해서 더 깔끔하게 작성할 수 있습니다.</span>\ntype <span class=\"hljs-title class_\">FlattenOld</span>&#x3C;T> = T <span class=\"hljs-keyword\">extends</span> any[] ? T[number] : T;\n\n<span class=\"hljs-comment\">// 배열에서 직접 인덱싱하는 대신, 배열에서 항목(Item)의 타입을 추론할 수 있습니다.</span>\ntype <span class=\"hljs-title class_\">Flatten</span>&#x3C;T> = T <span class=\"hljs-keyword\">extends</span> (infer <span class=\"hljs-title class_\">Item</span>)[] ? <span class=\"hljs-title class_\">Item</span> : T;\n\n<span class=\"hljs-comment\">// 함수의 반환 타입을 가져오고, 그 외의 경우에는 undefined로 지정하는 타입을 작성할 수도 있습니다.</span>\ntype <span class=\"hljs-title class_\">GetReturnType</span>&#x3C;<span class=\"hljs-title class_\">Type</span>> = <span class=\"hljs-title class_\">Type</span> <span class=\"hljs-keyword\">extends</span> (...<span class=\"hljs-attr\">args</span>: any[]) => infer <span class=\"hljs-title class_\">Return</span> ? <span class=\"hljs-title class_\">Return</span> : <span class=\"hljs-literal\">undefined</span>;\n\ntype <span class=\"hljs-title class_\">Num</span> = <span class=\"hljs-title class_\">GetReturnType</span>&#x3C;<span class=\"hljs-function\">() =></span> number>; <span class=\"hljs-comment\">// number 타입으로 지정됨</span>\n\ntype <span class=\"hljs-title class_\">Str</span> = <span class=\"hljs-title class_\">GetReturnType</span>&#x3C;<span class=\"hljs-function\">(<span class=\"hljs-params\">x: string</span>) =></span> string>; <span class=\"hljs-comment\">// string 타입으로 지정됨</span>\n\ntype <span class=\"hljs-title class_\">Bools</span> = <span class=\"hljs-title class_\">GetReturnType</span>&#x3C;<span class=\"hljs-function\">(<span class=\"hljs-params\">a: boolean, b: boolean</span>) =></span> <span class=\"hljs-keyword\">void</span>>; <span class=\"hljs-comment\">// undefined 타입으로 지정됨</span>\n</code></pre>\n<ul>\n<li>튜플 Optional Elements와 Rest: 튜플에서 <code>?</code>를 사용하여 옵셔널 요소를 선언하고, 다른 타입을 기반으로 나머지 요소를 사용할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 튜플의 길이를 아직 알 수 없지만 적어도 한 개는 있는 경우, `?`를 사용하여 옵셔널 타입을 지정할 수 있습니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">list</span>: [number, number?, boolean?] = [];\nlist[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// number 타입으로 지정됩니다</span>\nlist[<span class=\"hljs-number\">1</span>] <span class=\"hljs-comment\">// number 또는 undefined 타입으로 지정됩니다</span>\nlist[<span class=\"hljs-number\">2</span>] <span class=\"hljs-comment\">// boolean 또는 undefined 타입으로 지정됩니다</span>\nlist[<span class=\"hljs-number\">3</span>] <span class=\"hljs-comment\">// Type error: 길이가 '3'인 '[number, (number | undefined)?, (boolean | undefined)?]' 형식의 튜플에는 '3' 인덱스 요소가 없습니다.</span>\n\n<span class=\"hljs-comment\">// 기존 타입을 기반으로 튜플을 사용할 수도 있습니다.</span>\n<span class=\"hljs-comment\">// 배열의 시작 부분에 패딩을 추가하려면 나머지 연산자 `...`를 사용할 수 있습니다.</span>\n<span class=\"hljs-keyword\">function</span> padStart&#x3C;T <span class=\"hljs-keyword\">extends</span> any[]>(<span class=\"hljs-attr\">arr</span>: T, <span class=\"hljs-attr\">pad</span>: string): [string, ...T] {\n  <span class=\"hljs-keyword\">return</span> [pad, ...arr];\n}\n\n<span class=\"hljs-keyword\">const</span> padded = <span class=\"hljs-title function_\">padStart</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], <span class=\"hljs-string\">'test'</span>); <span class=\"hljs-comment\">// [string, number, number] 타입으로 지정됩니다</span>\n</code></pre>\n<ul>\n<li>추상 클래스와 메소드: 클래스와 그 내부 메소드를 추상으로 선언하여 인스턴스화되지 않도록 할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">abstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> {\n  abstract <span class=\"hljs-title function_\">makeSound</span>(): <span class=\"hljs-keyword\">void</span>;\n\n  <span class=\"hljs-title function_\">move</span>(): <span class=\"hljs-keyword\">void</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'roaming the earth...'</span>);\n  }\n}\n\n<span class=\"hljs-comment\">// 추상 메소드는 확장 시 구현되어야 합니다.</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Animal</span> {} <span class=\"hljs-comment\">// 컴파일 오류: 추상 클래스 'Animal'로부터 상속된 추상 멤버 'makeSound'가 구현되지 않은 비-추상 클래스 'Cat'입니다.</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Animal</span> {\n  <span class=\"hljs-title function_\">makeSound</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'woof'</span>);\n  }\n}\n\n<span class=\"hljs-comment\">// 추상 클래스는 (인터페이스처럼) 인스턴스화할 수 없으며, 추상 메소드는 호출할 수 없습니다.</span>\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(); <span class=\"hljs-comment\">// 컴파일 오류: 추상 클래스의 인스턴스를 생성할 수 없습니다.</span>\n\n<span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>().<span class=\"hljs-title function_\">makeSound</span>(); <span class=\"hljs-comment\">// \"woof\"가 출력됩니다</span>\n</code></pre>\n<ul>\n<li>생성자 서명: 클래스 선언 외부에서 생성자의 유형을 정의합니다. 대부분의 경우에 사용되지 않아야 하며, 추상 클래스 대신 사용할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">MyInterface</span> {\n  <span class=\"hljs-attr\">name</span>: string;\n}\n\ninterface <span class=\"hljs-title class_\">ConstructsMyInterface</span> {\n  <span class=\"hljs-title function_\">new</span>(<span class=\"hljs-attr\">name</span>: string): <span class=\"hljs-title class_\">MyInterface</span>;\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> implements <span class=\"hljs-title class_\">MyInterface</span> {\n  <span class=\"hljs-attr\">name</span>: string;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name: string</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AnotherTest</span> {\n  <span class=\"hljs-attr\">age</span>: number;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">makeObj</span>(<span class=\"hljs-params\">n: ConstructsMyInterface</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">n</span>(<span class=\"hljs-string\">'hello!'</span>);\n}\n\n<span class=\"hljs-keyword\">const</span> obj = <span class=\"hljs-title function_\">makeObj</span>(<span class=\"hljs-title class_\">Test</span>); <span class=\"hljs-comment\">// Test로 타입 지정됨</span>\n<span class=\"hljs-keyword\">const</span> anotherObj = <span class=\"hljs-title function_\">makeObj</span>(<span class=\"hljs-title class_\">AnotherTest</span>); <span class=\"hljs-comment\">// 타입 오류: 'AnotherTest'의 유형은 'ConstructsMyInterface'의 매개변수에 할당할 수 없습니다.</span>\n</code></pre>\n<ul>\n<li>ConstructorParameters 유틸리티 타입: TypeScript 도우미 함수로, 생성자 타입에서 생성자 매개변수를 가져옵니다 (클래스에서 가져오는 것이 아닙니다).</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// makeObj 함수에 생성자 인수를 얻고 싶다면?</span>\ninterface <span class=\"hljs-title class_\">MyInterface</span> {\n  <span class=\"hljs-attr\">name</span>: string;\n}\n\ninterface <span class=\"hljs-title class_\">ConstructsMyInterface</span> {\n  <span class=\"hljs-title function_\">new</span>(<span class=\"hljs-attr\">name</span>: string): <span class=\"hljs-title class_\">MyInterface</span>;\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> implements <span class=\"hljs-title class_\">MyInterface</span> {\n  <span class=\"hljs-attr\">name</span>: string;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name: string</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;\n  }\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">makeObj</span>(<span class=\"hljs-params\">test: ConstructsMyInterface, ...args: ConstructorParameters&#x3C;ConstructsMyInterface></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">test</span>(...args);\n}\n\n<span class=\"hljs-title function_\">makeObj</span>(<span class=\"hljs-title class_\">Test</span>); <span class=\"hljs-comment\">// 타입 오류: 2개의 매개변수가 필요하지만 1개만 전달되었습니다.</span>\n<span class=\"hljs-keyword\">const</span> obj = <span class=\"hljs-title function_\">makeObj</span>(<span class=\"hljs-title class_\">Test</span>, <span class=\"hljs-string\">'test'</span>); <span class=\"hljs-comment\">// Test로 타입 지정됨</span>\n</code></pre>\n<h2>TypeScript 4.0</h2>\n<ul>\n<li>Variadic Tuple Types: 튜플에서의 나머지 요소는 이제 제네릭할 수 있습니다. 여러 개의 나머지 요소를 사용하는 것도 허용됩니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 만약 길이와 타입이 정의되지 않은 두 튜플을 결합하는 함수가 있다면 어떨까요? 반환 타입을 어떻게 정의할 수 있을까요?</span>\n\n<span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-comment\">// 우리는 몇 가지 오버로드를 작성할 수 있었습니다.</span>\ndeclare <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">concat</span>(<span class=\"hljs-params\">arr1: [], arr2: []</span>): [];\ndeclare <span class=\"hljs-keyword\">function</span> concat&#x3C;A>(<span class=\"hljs-attr\">arr1</span>: [A], <span class=\"hljs-attr\">arr2</span>: []): [A];\ndeclare <span class=\"hljs-keyword\">function</span> concat&#x3C;A, B>(<span class=\"hljs-attr\">arr1</span>: [A], <span class=\"hljs-attr\">arr2</span>: [B]): [A, B];\n<span class=\"hljs-comment\">// 이하 생략</span>\n\n<span class=\"hljs-comment\">// 대신에 타입을 결합할 수 있습니다.</span>\ndeclare <span class=\"hljs-keyword\">function</span> concatBetter&#x3C;T, U>(<span class=\"hljs-attr\">arr1</span>: T[], <span class=\"hljs-attr\">arr2</span>: U[]): (T | U)[];\n<span class=\"hljs-comment\">// 그러나 이것은 (T | U)[]로 타입이 지정됩니다.</span>\n\n<span class=\"hljs-comment\">// 새로운 기능:</span>\n<span class=\"hljs-comment\">// 가변 길이 튜플 타입을 사용하면 쉽게 정의할 수 있고 길이 정보를 유지할 수 있습니다.</span>\ndeclare <span class=\"hljs-keyword\">function</span> concatNew&#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Arr</span>, U <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Arr</span>>(<span class=\"hljs-attr\">arr1</span>: T, <span class=\"hljs-attr\">arr2</span>: U): [...T, ...U];\n\n<span class=\"hljs-keyword\">const</span> tuple = <span class=\"hljs-title function_\">concatNew</span>([<span class=\"hljs-number\">23</span>, <span class=\"hljs-string\">'hey'</span>, <span class=\"hljs-literal\">false</span>] <span class=\"hljs-keyword\">as</span> [number, string, boolean], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">99</span>, <span class=\"hljs-number\">20</span>] <span class=\"hljs-keyword\">as</span> [number, number, number]);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tuple[<span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// 23</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">element</span>: number = tuple[<span class=\"hljs-number\">1</span>]; <span class=\"hljs-comment\">// 타입 오류: 타입 'string'을 'number'에 할당할 수 없습니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tuple[<span class=\"hljs-number\">6</span>]); <span class=\"hljs-comment\">// 타입 오류: 길이 '6'인 튜플 타입 '[23, \"hey\", false, 5, 99, 20]'에는 인덱스 '6'에 요소가 없습니다.</span>\n</code></pre>\n<ul>\n<li>Labeled Tuple Elements: 튜플 요소는 이제 [start: number, end: number]와 같이 이름을 지정할 수 있습니다. 요소 중 하나가 이름이 지정되면 모두 이름이 있어야 합니다.</li>\n</ul>\n<p>혹시 클래스 생성자에서 속성이 설정될 때 속성의 타입을 자동으로 추론할 수 있어서 더 이상 수동으로 설정할 필요가 없습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-comment\">// 생성자에서 할당될 때 타입을 설정할 필요가 없습니다.</span>\n  name;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name: string</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// 문자열로 타입이 지정됨</span>\n  }\n}\n</code></pre>\n<ul>\n<li>JSDoc @deprecated 지원: JSDoc/TSDoc의 @deprecated 태그가 TypeScript에서 인식됩니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@deprecated</span> 메시지 */</span>\ntype <span class=\"hljs-title class_\">Test</span> = string;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">test</span>: <span class=\"hljs-title class_\">Test</span> = <span class=\"hljs-string\">'dfadsf'</span>; <span class=\"hljs-comment\">// 타입 오류: '테스트'가 사용되지 않습니다.</span>\n</code></pre>\n<h2>TypeScript 4.1</h2>\n<ul>\n<li>템플릿 리터럴 타입: 리터럴 타입을 정의할 때, '$'를 이용하여 템플릿을 활용할 수 있습니다. 이를 통해 여러 개의 문자열 리터럴을 조합하는 등 복잡한 문자열 타입을 만들 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">VerticalDirection</span> = <span class=\"hljs-string\">'top'</span> | <span class=\"hljs-string\">'bottom'</span>;\ntype <span class=\"hljs-title class_\">HorizontalDirection</span> = <span class=\"hljs-string\">'left'</span> | <span class=\"hljs-string\">'right'</span>;\ntype <span class=\"hljs-title class_\">Direction</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${VerticalDirection}</span> <span class=\"hljs-subst\">${HorizontalDirection}</span>`</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">dir1</span>: <span class=\"hljs-title class_\">Direction</span> = <span class=\"hljs-string\">'top left'</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">dir2</span>: <span class=\"hljs-title class_\">Direction</span> = <span class=\"hljs-string\">'left'</span>; <span class=\"hljs-comment\">// 타입 오류: '\"left\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">dir3</span>: <span class=\"hljs-title class_\">Direction</span> = <span class=\"hljs-string\">'left top'</span>; <span class=\"hljs-comment\">// 타입 오류: '\"left top\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.</span>\n\n<span class=\"hljs-comment\">// 이는 제네릭 및 새로운 유틸리티 타입과도 결합할 수 있습니다.</span>\ndeclare <span class=\"hljs-keyword\">function</span> makeId&#x3C;T <span class=\"hljs-keyword\">extends</span> string, U <span class=\"hljs-keyword\">extends</span> string>(<span class=\"hljs-attr\">first</span>: T, <span class=\"hljs-attr\">second</span>: U): <span class=\"hljs-string\">`<span class=\"hljs-subst\">${Capitalize&#x3C;T>}</span>-<span class=\"hljs-subst\">${Lowercase&#x3C;U>}</span>`</span>;\n</code></pre>\n<ul>\n<li>키 다시 매핑하기: 매핑된 타입을 다시 정의하여 그 값들을 사용할 수 있습니다. [K in keyof T as NewKeyType]: T[K].</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 예를 들어, 객체를 다시 포맷하되 그 ID 앞에 밑줄을 추가하고 싶다고 가정해 봅시다.</span>\n<span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">value1</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">value2</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">value3</span>: <span class=\"hljs-number\">3</span> };\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">newObj</span>: { [<span class=\"hljs-title class_\">Property</span> <span class=\"hljs-keyword\">in</span> keyof <span class=\"hljs-keyword\">typeof</span> obj <span class=\"hljs-keyword\">as</span> <span class=\"hljs-string\">`_<span class=\"hljs-subst\">${Property}</span>`</span>]: number }; <span class=\"hljs-comment\">// { _value1: number; _value2: number; value3: number; }로 타입이 지정됩니다.</span>\n</code></pre>\n<ul>\n<li>재귀 조건부 타입: 조건부 타입을 해당 정의 내부에서 사용합니다. 이를 통해 무한히 중첩된 값을 조건부적으로 언패킹하는 타입을 생성할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">Awaited</span>&#x3C;T> = T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">PromiseLike</span>&#x3C;infer U> ? <span class=\"hljs-title class_\">Awaited</span>&#x3C;U> : T;\n\ntype <span class=\"hljs-variable constant_\">P1</span> = <span class=\"hljs-title class_\">Awaited</span>&#x3C;string>; <span class=\"hljs-comment\">// string으로 타입이 지정됩니다.</span>\ntype <span class=\"hljs-variable constant_\">P2</span> = <span class=\"hljs-title class_\">Awaited</span>&#x3C;<span class=\"hljs-title class_\">Promise</span>&#x3C;string>>; <span class=\"hljs-comment\">// string으로 타입이 지정됩니다.</span>\ntype <span class=\"hljs-variable constant_\">P3</span> = <span class=\"hljs-title class_\">Awaited</span>&#x3C;<span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-title class_\">Promise</span>&#x3C;string>>>; <span class=\"hljs-comment\">// string으로 타입이 지정됩니다.</span>\n</code></pre>\n<ul>\n<li>JSDOC @see 태그를 지원하는 편집기: 이제 편집기에서 JSDoc/TSDoc @see 변수/유형/링크 태그가 지원됩니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> originalValue = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">/**\n * 다른 값의 복사본\n * <span class=\"hljs-doctag\">@see</span> <span class=\"hljs-variable\">originalValue</span>\n */</span>\n<span class=\"hljs-keyword\">const</span> value = originalValue;\n</code></pre>\n<ul>\n<li>tsc --explainFiles: --explainFiles 옵션은 TypeScript CLI에서 컴파일에 사용된 파일과 그 이유를 설명해주는 데 사용될 수 있습니다. 이는 디버깅에 유용할 수 있습니다. 경고: 대규모 프로젝트나 복잡한 설정의 경우 많은 출력물이 생성됩니다. 대신 tsc --explainFiles | less 또는 비슷한 방법을 사용하십시오.</li>\n</ul>\n<pre><code class=\"hljs language-js\">tsc --explainFiles\n\n&#x3C;&#x3C;output\n../../.<span class=\"hljs-property\">asdf</span>/installs/nodejs/<span class=\"hljs-number\">16.13</span><span class=\"hljs-number\">.1</span>/.<span class=\"hljs-property\">npm</span>/lib/node_modules/typescript/lib/lib.<span class=\"hljs-property\">es5</span>.<span class=\"hljs-property\">d</span>.<span class=\"hljs-property\">ts</span>\n  파일 <span class=\"hljs-string\">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'</span>에서 <span class=\"hljs-string\">'es5'</span>로 참조되는 라이브러리\n  파일 <span class=\"hljs-string\">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'</span>에서 <span class=\"hljs-string\">'es5'</span>로 참조되는 라이브러리\n../../.<span class=\"hljs-property\">asdf</span>/installs/nodejs/<span class=\"hljs-number\">16.13</span><span class=\"hljs-number\">.1</span>/.<span class=\"hljs-property\">npm</span>/lib/node_modules/typescript/lib/lib.<span class=\"hljs-property\">es2015</span>.<span class=\"hljs-property\">d</span>.<span class=\"hljs-property\">ts</span>\n  파일 <span class=\"hljs-string\">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'</span>에서 <span class=\"hljs-string\">'es2015'</span>로 참조되는 라이브러리\n  파일 <span class=\"hljs-string\">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'</span>에서 <span class=\"hljs-string\">'es2015'</span>로 참조되는 라이브러리\n../../.<span class=\"hljs-property\">asdf</span>/installs/nodejs/<span class=\"hljs-number\">16.13</span><span class=\"hljs-number\">.1</span>/.<span class=\"hljs-property\">npm</span>/lib/node_modules/typescript/lib/lib.<span class=\"hljs-property\">es2016</span>.<span class=\"hljs-property\">d</span>.<span class=\"hljs-property\">ts</span>\n  파일 <span class=\"hljs-string\">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'</span>에서 <span class=\"hljs-string\">'es2016'</span>로 참조되는 라이브러리\n  파일 <span class=\"hljs-string\">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'</span>에서 <span class=\"hljs-string\">'es2016'</span>로 참조되는 라이브러리\n...\noutput\n</code></pre>\n<ul>\n<li>Destructured 변수는 명시적으로 사용되지 않음을 표시할 수 있습니다: 구조 분해할 때 밑줄을 사용하여 변수가 사용되지 않음을 표시할 수 있습니다. 이를 통해 TypeScript에서 \"사용되지 않는 변수\" 오류를 방지할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> [_first, second] = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(second);\n\n<span class=\"hljs-comment\">// 심지어 더 짧게</span>\n<span class=\"hljs-keyword\">const</span> [_, value] = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);\n</code></pre>\n<h2>TypeScript 4.3</h2>\n<ul>\n<li>속성에 대한 별도의 쓰기 유형: set/get 접근자를 정의할 때, 쓰기/설정 형식이 읽기/가져오기 형식과 다를 수 있습니다. 이를 통해 동일한 값의 여러 형식을 수락하는 setter를 정의할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> {\n  private <span class=\"hljs-attr\">_value</span>: number;\n\n  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">value</span>(): number {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span>;\n  }\n\n  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">value</span>(<span class=\"hljs-params\">value: number | string</span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">'number'</span>) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = value;\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = <span class=\"hljs-built_in\">parseInt</span>(value, <span class=\"hljs-number\">10</span>);\n  }\n}\n</code></pre>\n<ul>\n<li>override: 상속된 클래스 메서드를 명확하게 오버라이드로 표시하기 위해 override를 사용하세요. 부모 클래스가 변경되면 TypeScript에서 부모 메서드가 더 이상 존재하지 않음을 알려줄 수 있습니다. 이를 통해 더 안전한 복잡한 상속 패턴을 구현할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parent</span> {\n  <span class=\"hljs-title function_\">getName</span>(): string {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'name'</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NewParent</span> {\n  <span class=\"hljs-title function_\">getFirstName</span>(): string {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'name'</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Parent</span> {\n  override <span class=\"hljs-title function_\">getName</span>(): string {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'test'</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NewTest</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">NewParent</span> {\n  override <span class=\"hljs-title function_\">getName</span>(): string { <span class=\"hljs-comment\">// Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'test'</span>;\n  }\n}\n</code></pre>\n<ul>\n<li>static Index Signatures: 클래스에서 정적 속성을 사용할 때, 정적 [propName: string]: string을 사용하여 색인 서명을 설정할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이전 코드:</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> {}\n\n<span class=\"hljs-title class_\">Test</span>.<span class=\"hljs-property\">test</span> = <span class=\"hljs-string\">''</span>; <span class=\"hljs-comment\">// 타입 오류: 'test' 속성을 'Test' 형식에서 찾을 수 없습니다.</span>\n\n<span class=\"hljs-comment\">// 새로운 코드:</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NewTest</span> {\n  <span class=\"hljs-keyword\">static</span> [<span class=\"hljs-attr\">key</span>: string]: string;\n}\n\n<span class=\"hljs-title class_\">NewTest</span>.<span class=\"hljs-property\">test</span> = <span class=\"hljs-string\">''</span>;\n</code></pre>\n<ul>\n<li>JSDOC @link 태그를 위한 편집기 지원: JSDoc/TSDoc의 '@link 변수/타입/링크' 인라인 태그가 이제 지원되며 편집기에서 표시되고 해결됩니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> originalValue = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">/**\n * {<span class=\"hljs-doctag\">@link</span> originalValue}의 복사본\n */</span>\n<span class=\"hljs-keyword\">const</span> value = originalValue;\n</code></pre>\n<h2>TypeScript 4.4</h2>\n<ul>\n<li>정확한 선택적 속성 유형 (--exactOptionalPropertyTypes): 컴파일러 플래그 --exactOptionalPropertyTypes (또는 tsconfig.json에)를 사용하면, 암시적으로 undefined를 허용하는 속성에 대해 undefined로 할당하는 것이 허용되지 않습니다 (예: property?: string). 대신, property: string | undefined와 같이 명시적으로 undefined를 허용해야 합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> {\n  name?: string;\n  <span class=\"hljs-attr\">age</span>: number | <span class=\"hljs-literal\">undefined</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> test = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Test</span>();\ntest.<span class=\"hljs-property\">name</span> = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// 타입 오류: 'exactOptionalPropertyTypes: true'를 사용하여 'undefined' 타입을 'string'에 할당할 수 없습니다. 대상의 유형에 'undefined'를 추가하는 것을 고려해보세요.</span>\ntest.<span class=\"hljs-property\">age</span> = <span class=\"hljs-literal\">undefined</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(test.<span class=\"hljs-property\">age</span>); <span class=\"hljs-comment\">// undefined</span>\n</code></pre>\n<h2>TypeScript 4.5</h2>\n<ul>\n<li>Awaited<code> 유형 및 Promise 개선: 새로운 Awaited</code> 유틸리티 유형은 무한히 중첩된 Promises에서 값 유형을 추출합니다 (값에 대해 await이 하는 것과 같이). 이는 또한 Promise.all()에 대한 유형 추론을 개선했습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 제네릭 대기값을 가지고 싶다고 가정해 봅시다.</span>\n<span class=\"hljs-comment\">// 이러한 경우 Awaited 유틸리티 타입을 사용할 수 있습니다 (소스 코드는 이전 예제의 일부였습니다).</span>\n<span class=\"hljs-comment\">// 따라서 무한하게 중첩된 Promises가 모두 값으로 해결됩니다.</span>\ntype <span class=\"hljs-variable constant_\">P1</span> = <span class=\"hljs-title class_\">Awaited</span>&#x3C;string>; <span class=\"hljs-comment\">// 문자열로 타입 지정</span>\ntype <span class=\"hljs-variable constant_\">P2</span> = <span class=\"hljs-title class_\">Awaited</span>&#x3C;<span class=\"hljs-title class_\">Promise</span>&#x3C;string>>; <span class=\"hljs-comment\">// 문자열로 타입 지정</span>\ntype <span class=\"hljs-variable constant_\">P3</span> = <span class=\"hljs-title class_\">Awaited</span>&#x3C;<span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-title class_\">Promise</span>&#x3C;string>>>; <span class=\"hljs-comment\">// 문자열로 타입 지정</span>\n</code></pre>\n<ul>\n<li>Import 이름에 대한 유형 수식어: 일반 (import type 아닌) import 문 안에서 type 키워드를 사용하여 해당 값이 유형 컴파일을 위해만 가져와야 함을 신호로 삼을 수 있습니다 (컴파일 후에 제거할 수 있습니다).</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-comment\">// 유형을 가져오는 가장 좋은 방법은 `import type` 키워드를 사용하여 컴파일 이후에 실제로 가져오지 않도록 하는 것입니다.</span>\n<span class=\"hljs-keyword\">import</span> { something } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./file'</span>;\n<span class=\"hljs-keyword\">import</span> type { <span class=\"hljs-title class_\">SomeType</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./file'</span>;\n<span class=\"hljs-comment\">// 이 파일에 대해 두 개의 import 문이 필요했습니다.</span>\n\n<span class=\"hljs-comment\">// 새로운:</span>\n<span class=\"hljs-comment\">// 이제 이를 하나의 문으로 결합할 수 있습니다.</span>\n<span class=\"hljs-keyword\">import</span> { something, type <span class=\"hljs-title class_\">SomeType</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./file'</span>;\n</code></pre>\n<ul>\n<li>Const 어순: 상수를 정의할 때 const 키워드를 사용하여 이를 리터럴 타입으로 정확하게 지정할 수 있습니다. 이는 다양한 용례가 있으며 정확한 유형 정의가 쉬워집니다. 또한 상수 객체와 배열은 읽기 전용이 되어 상수 객체의 변이를 방지합니다.```</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">9</span>, <span class=\"hljs-attr\">toggle</span>: <span class=\"hljs-literal\">false</span> }; <span class=\"hljs-comment\">// { name: string; value: number; toggle: boolean; }으로 타입 지정됨</span>\n<span class=\"hljs-comment\">// 일반적으로 타입이 지정되어 있으므로 어느 값이든 할당 가능합니다.</span>\nobj.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">'bar'</span>;\n\n<span class=\"hljs-keyword\">const</span> tuple = [<span class=\"hljs-string\">'name'</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-literal\">true</span>]; <span class=\"hljs-comment\">// (string | number | boolean)[]으로 타입 지정됨</span>\n<span class=\"hljs-comment\">// 타입으로 길이와 정확한 형식을 결정할 수 없습니다. 어떤 값이든 어디에든 할당할 수 있습니다.</span>\ntuple[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;\ntuple[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-comment\">// 새로운 방식:</span>\n<span class=\"hljs-keyword\">const</span> objNew = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">9</span>, <span class=\"hljs-attr\">toggle</span>: <span class=\"hljs-literal\">false</span> } <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">const</span>; <span class=\"hljs-comment\">// { readonly name: \"foo\"; readonly value: 9; readonly toggle: false; }으로 타입 지정됨</span>\n<span class=\"hljs-comment\">// 값을 할당할 수 없습니다 (\"foo\"(그리고 readonly로 정의되었기 때문).</span>\nobjNew.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">'bar'</span>; <span class=\"hljs-comment\">// 타입 에러: 'name'에 할당할 수 없습니다. 읽기 전용 속성입니다.</span>\n\n<span class=\"hljs-keyword\">const</span> tupleNew = [<span class=\"hljs-string\">'name'</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-literal\">true</span>] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">const</span>; <span class=\"hljs-comment\">// readonly [\"name\", 4, true]으로 타입 지정됨</span>\n<span class=\"hljs-comment\">// 이제 길이와 정확한 형식이 정의되어 있고, 값을 할당할 수 없습니다 (리터럴로 정의되었으며 readonly).</span>\ntupleNew[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 타입 에러: '0'에 할당할 수 없습니다. 읽기 전용 속성입니다.</span>\ntupleNew[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 타입 에러: 'readonly[\"name\", 4, true]'에 있는 인덱스 서명에는 읽기만 허용됩니다.</span>\n</code></pre>\n<ul>\n<li>클래스 내의 메서드에 대한 코드 조각 완성: 클래스가 메서드 타입을 상속하면 편집기에서 코드 조각으로 제안됩니다.</li>\n</ul>\n<h2>TypeScript 4.6</h2>\n<ul>\n<li>인덱스된 액세스 추론 개선: 키로 직접 타입을 색인화할 때, 이제 같은 객체에 있는 경우 타입이 더 정확해집니다. 현대적인 TypeScript로 어떤 것이 가능한지 보여주는 좋은 예시입니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">AllowedTypes</span> {\n  <span class=\"hljs-string\">'number'</span>: number;\n  <span class=\"hljs-string\">'string'</span>: string;\n  <span class=\"hljs-string\">'boolean'</span>: boolean;\n}\n\n<span class=\"hljs-comment\">// Record는 허용된 타입의 종류와 값 타입을 지정합니다.</span>\ntype <span class=\"hljs-title class_\">UnionRecord</span>&#x3C;<span class=\"hljs-title class_\">AllowedKeys</span> <span class=\"hljs-keyword\">extends</span> keyof <span class=\"hljs-title class_\">AllowedTypes</span>> = { [<span class=\"hljs-title class_\">Key</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title class_\">AllowedKeys</span>]:\n{\n  <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-title class_\">Key</span>;\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-title class_\">AllowedTypes</span>[<span class=\"hljs-title class_\">Key</span>];\n  <span class=\"hljs-attr\">logValue</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">value: AllowedTypes[Key]</span>) =></span> <span class=\"hljs-keyword\">void</span>;\n}\n}[<span class=\"hljs-title class_\">AllowedKeys</span>];\n\n<span class=\"hljs-comment\">// 함수 logValue는 Record의 값만을 허용합니다.</span>\n<span class=\"hljs-keyword\">function</span> processRecord&#x3C;<span class=\"hljs-title class_\">Key</span> <span class=\"hljs-keyword\">extends</span> keyof <span class=\"hljs-title class_\">AllowedTypes</span>>(<span class=\"hljs-attr\">record</span>: <span class=\"hljs-title class_\">UnionRecord</span>&#x3C;<span class=\"hljs-title class_\">Key</span>>) {\n  record.<span class=\"hljs-title function_\">logValue</span>(record.<span class=\"hljs-property\">value</span>);\n}\n\n<span class=\"hljs-title function_\">processRecord</span>({\n  <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">'string'</span>,\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'hello!'</span>,\n\n  <span class=\"hljs-comment\">// 값이 암묵적으로 string | number | boolean 타입을 가졌던 것이</span>\n  <span class=\"hljs-comment\">// 이제 올바르게 오직 string으로 추론됩니다.</span>\n  <span class=\"hljs-attr\">logValue</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value.<span class=\"hljs-title function_\">toUpperCase</span>());\n  }\n});\n</code></pre>\n<ul>\n<li>TypeScript 추적 분석기 (--generateTrace): --generateTrace '출력 폴더' 옵션을 사용하여 TypeScript CLI가 타입 검사 및 컴파일 프로세스에 대한 자세한 내용을 포함한 파일을 생성할 수 있습니다. 이는 복잡한 타입을 최적화하는 데 도움이 될 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">tsc --generateTrace trace\n\ncat trace/trace.<span class=\"hljs-property\">json</span>\n&#x3C;&#x3C;출력\n[\n{<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"process_name\"</span>,<span class=\"hljs-string\">\"args\"</span>:{<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"tsc\"</span>},<span class=\"hljs-string\">\"cat\"</span>:<span class=\"hljs-string\">\"__metadata\"</span>,<span class=\"hljs-string\">\"ph\"</span>:<span class=\"hljs-string\">\"M\"</span>,<span class=\"hljs-string\">\"ts\"</span>:...,<span class=\"hljs-string\">\"pid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"tid\"</span>:<span class=\"hljs-number\">1</span>},\n{<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"thread_name\"</span>,<span class=\"hljs-string\">\"args\"</span>:{<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"Main\"</span>},<span class=\"hljs-string\">\"cat\"</span>:<span class=\"hljs-string\">\"__metadata\"</span>,<span class=\"hljs-string\">\"ph\"</span>:<span class=\"hljs-string\">\"M\"</span>,<span class=\"hljs-string\">\"ts\"</span>:...,<span class=\"hljs-string\">\"pid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"tid\"</span>:<span class=\"hljs-number\">1</span>},\n{<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"TracingStartedInBrowser\"</span>,<span class=\"hljs-string\">\"cat\"</span>:<span class=\"hljs-string\">\"disabled-by-default-devtools.timeline\"</span>,<span class=\"hljs-string\">\"ph\"</span>:<span class=\"hljs-string\">\"M\"</span>,<span class=\"hljs-string\">\"ts\"</span>:...,<span class=\"hljs-string\">\"pid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"tid\"</span>:<span class=\"hljs-number\">1</span>},\n{<span class=\"hljs-string\">\"pid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"tid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"ph\"</span>:<span class=\"hljs-string\">\"B\"</span>,<span class=\"hljs-string\">\"cat\"</span>:<span class=\"hljs-string\">\"program\"</span>,<span class=\"hljs-string\">\"ts\"</span>:...,<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"createProgram\"</span>,<span class=\"hljs-string\">\"args\"</span>:{<span class=\"hljs-string\">\"configFilePath\"</span>:<span class=\"hljs-string\">\"/...\"</span>,<span class=\"hljs-string\">\"rootDir\"</span>:<span class=\"hljs-string\">\"/...\"</span>},\n{<span class=\"hljs-string\">\"pid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"tid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"ph\"</span>:<span class=\"hljs-string\">\"B\"</span>,<span class=\"hljs-string\">\"cat\"</span>:<span class=\"hljs-string\">\"parse\"</span>,<span class=\"hljs-string\">\"ts\"</span>:...,<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"createSourceFile\"</span>,<span class=\"hljs-string\">\"args\"</span>:{<span class=\"hljs-string\">\"path\"</span>:<span class=\"hljs-string\">\"/...\"</span>},\n{<span class=\"hljs-string\">\"pid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"tid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"ph\"</span>:<span class=\"hljs-string\">\"E\"</span>,<span class=\"hljs-string\">\"cat\"</span>:<span class=\"hljs-string\">\"parse\"</span>,<span class=\"hljs-string\">\"ts\"</span>:...,<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"createSourceFile\"</span>,<span class=\"hljs-string\">\"args\"</span>:{<span class=\"hljs-string\">\"path\"</span>:<span class=\"hljs-string\">\"/...\"</span>},\n{<span class=\"hljs-string\">\"pid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"tid\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"ph\"</span>:<span class=\"hljs-string\">\"X\"</span>,<span class=\"hljs-string\">\"cat\"</span>:<span class=\"hljs-string\">\"program\"</span>,<span class=\"hljs-string\">\"ts\"</span>:...,<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"resolveModuleNamesWorker\"</span>,<span class=\"hljs-string\">\"dur\"</span>:...,<span class=\"hljs-string\">\"args\"</span>:{<span class=\"hljs-string\">\"containingFileName\"</span>:<span class=\"hljs-string\">\"/...\"</span>},\n...\n출력\n\ncat trace/types.<span class=\"hljs-property\">json</span>\n&#x3C;&#x3C;출력\n[{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"any\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"any\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"any\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">4</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"error\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">5</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"unresolved\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">4</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">6</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"any\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">5</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">7</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"intrinsic\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">6</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">8</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"unknown\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">7</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">9</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"unknown\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">8</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">10</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"undefined\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">9</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">11</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"undefined\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">10</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">12</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"null\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">11</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-number\">13</span>,<span class=\"hljs-string\">\"intrinsicName\"</span>:<span class=\"hljs-string\">\"string\"</span>,<span class=\"hljs-string\">\"recursionId\"</span>:<span class=\"hljs-number\">12</span>,<span class=\"hljs-string\">\"flags\"</span>:[<span class=\"hljs-string\">\"...\"</span>]},\n...\n출력\n</code></pre>\n<h2>TypeScript 4.7</h2>\n<ul>\n<li>Node.js에서 ECMAScript 모듈 지원: CommonJS 대신 ES 모듈을 사용할 때, TypeScript가 이제 default를 지정할 수 있습니다. tsconfig.json에서 지정하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">...\n<span class=\"hljs-string\">\"compilerOptions\"</span>: [\n  ...\n  <span class=\"hljs-string\">\"module\"</span>: <span class=\"hljs-string\">\"es2020\"</span>\n]\n...\n</code></pre>\n<ul>\n<li>package.json의 type: package.json의 type 필드를 \"module\"로 설정할 수 있습니다. 이것은 Node.js와 ES 모듈을 사용하기 위해 필요합니다. 대부분의 경우에 TypeScript에 충분하며 위의 컴파일러 옵션이 필요하지 않습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">...\n<span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"module\"</span>\n...\n</code></pre>\n<ul>\n<li>인스턴스화 표현식: 인스턴스화 표현식을 사용하면 값을 참조할 때 유형 매개변수를 지정할 수 있습니다. 이를 통해 래퍼를 생성하지 않고 일반적인 유형을 좁힐 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">List</span>&#x3C;T> {\n  private <span class=\"hljs-attr\">list</span>: T[] = [];\n\n  <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-attr\">key</span>: number): T {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">list</span>[key];\n  }\n\n  <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-attr\">value</span>: T): <span class=\"hljs-keyword\">void</span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">list</span>.<span class=\"hljs-title function_\">push</span>(value);\n  }\n}\n\n<span class=\"hljs-keyword\">function</span> makeList&#x3C;T>(<span class=\"hljs-attr\">items</span>: T[]): <span class=\"hljs-title class_\">List</span>&#x3C;T> {\n  <span class=\"hljs-keyword\">const</span> list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">List</span>&#x3C;T>();\n  items.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =></span> list.<span class=\"hljs-title function_\">push</span>(item));\n  <span class=\"hljs-keyword\">return</span> list;\n}\n\n<span class=\"hljs-comment\">// 특정 값만 허용하는 목록을 만드는 함수가 필요한 경우를 가정해 봅시다.</span>\n<span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-comment\">// 직접 래퍼 함수를 정의하고 인수를 전달해야 했습니다.</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">makeStringList</span>(<span class=\"hljs-params\">text: string[]</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">makeList</span>(text);\n}\n\n<span class=\"hljs-comment\">// 새로운 방법:</span>\n<span class=\"hljs-comment\">// 인스턴스화 표현식을 사용하면 훨씬 쉽습니다.</span>\n<span class=\"hljs-keyword\">const</span> makeNumberList = makeList&#x3C;number>;\n</code></pre>\n<ul>\n<li>추론된 유형 변수에 대한 extend 제한: 조건부 유형에서 유형 변수를 추론할 때, extends를 사용하여 직접 좁히거나 제한할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 배열의 첫 번째 요소가 문자열인 경우에만 해당 요소를 가져오는 유형을 작성하려고 한다고 가정해 봅시다.</span>\n<span class=\"hljs-comment\">// 이를 위해 조건부 유형을 사용할 수 있습니다.</span>\n\n<span class=\"hljs-comment\">// 이전:</span>\ntype <span class=\"hljs-title class_\">FirstIfStringOld</span>&#x3C;T> =\n  T <span class=\"hljs-keyword\">extends</span> [infer S, ...unknown[]]\n    ? S <span class=\"hljs-keyword\">extends</span> string ? S : never\n    : never;\n\n<span class=\"hljs-comment\">// 그러나 이 방법은 두 개의 중첩된 조건부 유형이 필요합니다. 이를 하나의 유형으로도 할 수 있습니다.</span>\ntype <span class=\"hljs-title class_\">FirstIfString</span>&#x3C;T> =\n  T <span class=\"hljs-keyword\">extends</span> [string, ...unknown[]]\n    <span class=\"hljs-comment\">// `T`에서 첫 번째 유형을 가져옵니다.</span>\n    ? T[<span class=\"hljs-number\">0</span>]\n    : never;\n\n<span class=\"hljs-comment\">// 이것도 여전히 최적화되지 않은 상태이며 올바른 유형을 위해 배열을 인덱싱해야 합니다.</span>\n\n<span class=\"hljs-comment\">// 새로운 방식:</span>\n<span class=\"hljs-comment\">// 추론된 유형 변수에 extends 제약 조건을 사용하여 이를 더 간단하게 선언할 수 있습니다.</span>\ntype <span class=\"hljs-title class_\">FirstIfStringNew</span>&#x3C;T> =\n  T <span class=\"hljs-keyword\">extends</span> [infer S <span class=\"hljs-keyword\">extends</span> string, ...unknown[]]\n    ? S\n    : never;\n<span class=\"hljs-comment\">// 유형을 알아내는 방식은 이전과 동일하지만 더 깔끔한 구문입니다.</span>\n\ntype A = <span class=\"hljs-title class_\">FirstIfStringNew</span>&#x3C;[string, number, number]>; <span class=\"hljs-comment\">// string으로 유형 지정</span>\ntype B = <span class=\"hljs-title class_\">FirstIfStringNew</span>&#x3C;[<span class=\"hljs-string\">\"hello\"</span>, number, number]>; <span class=\"hljs-comment\">// \"hello\"로 유형 지정</span>\ntype C = <span class=\"hljs-title class_\">FirstIfStringNew</span>&#x3C;[<span class=\"hljs-string\">\"hello\"</span> | <span class=\"hljs-string\">\"world\"</span>, boolean]>; <span class=\"hljs-comment\">// \"hello\" 또는 \"world\"로 유형 지정</span>\ntype D = <span class=\"hljs-title class_\">FirstIfStringNew</span>&#x3C;[boolean, number, string]>; <span class=\"hljs-comment\">// never로 유형 지정</span>\n</code></pre>\n<ul>\n<li>유형 매개변수를 위한 선택적 분산 주석: 제네릭은 \"일치하는지\" 확인할 때 다른 동작을 가질 수 있습니다. 예를 들어, 상속을 허용할 경우 getters 및 setters에 대해 반대로 반전됩니다. 이제 이를 명시적으로 지정할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 다른 인터페이스 / 클래스를 확장하는 인터페이스가 있다고 가정해 봅시다.</span>\ninterface <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-attr\">animalStuff</span>: any;\n}\n\ninterface <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-attr\">dogStuff</span>: any;\n}\n\n<span class=\"hljs-comment\">// 그리고 일반적인 \"getter\" 및 \"setter\"가 있습니다.</span>\ntype <span class=\"hljs-title class_\">Getter</span>&#x3C;T> = <span class=\"hljs-function\">() =></span> T;\n\ntype <span class=\"hljs-title class_\">Setter</span>&#x3C;T> = <span class=\"hljs-function\">(<span class=\"hljs-params\">value: T</span>) =></span> <span class=\"hljs-keyword\">void</span>;\n\n<span class=\"hljs-comment\">// Getter&#x3C;T1>과 Getter&#x3C;T2> 또는 Setter&#x3C;T1>과 Setter&#x3C;T2>가 일치하는지 확인하려면 분산에 따라 달라집니다.</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useAnimalGetter</span>(<span class=\"hljs-params\">getter: Getter&#x3C;Animal></span>) {\n  <span class=\"hljs-title function_\">getter</span>();\n}\n\n<span class=\"hljs-comment\">// 이제 함수에 Getter를 전달할 수 있습니다.</span>\n<span class=\"hljs-title function_\">useAnimalGetter</span>((<span class=\"hljs-function\">() =></span> ({ <span class=\"hljs-attr\">animalStuff</span>: <span class=\"hljs-number\">0</span> }) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Animal</span>));\n<span class=\"hljs-comment\">// 당연히 작동합니다.</span>\n\n<span class=\"hljs-comment\">// 그러나 Dog를 반환하는 Getter를 사용하려면 어떻게 해야 할까요?</span>\n<span class=\"hljs-title function_\">useAnimalGetter</span>((<span class=\"hljs-function\">() =></span> ({ <span class=\"hljs-attr\">animalStuff</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">dogStuff</span>: <span class=\"hljs-number\">0</span> }) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Dog</span>));\n<span class=\"hljs-comment\">// 이 또한 작동합니다. 왜냐하면 Dog도 Animal이기 때문입니다.</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useDogGetter</span>(<span class=\"hljs-params\">getter: Getter&#x3C;Dog></span>) {\n  <span class=\"hljs-title function_\">getter</span>();\n}\n\n<span class=\"hljs-comment\">// useDogGetter 함수에 동일한 작업을 시도하면 동일한 동작을 얻지 못할 것입니다.</span>\n<span class=\"hljs-title function_\">useDogGetter</span>((<span class=\"hljs-function\">() =></span> ({ <span class=\"hljs-attr\">animalStuff</span>: <span class=\"hljs-number\">0</span> }) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Animal</span>); <span class=\"hljs-comment\">// Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.</span>\n<span class=\"hljs-comment\">// 이는 Animal이 아닌 Dog가 필요하기 때문에 작동하지 않습니다.</span>\n\n<span class=\"hljs-title function_\">useDogGetter</span>((<span class=\"hljs-function\">() =></span> ({ <span class=\"hljs-attr\">animalStuff</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">dogStuff</span>: <span class=\"hljs-number\">0</span> }) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Dog</span>);\n<span class=\"hljs-comment\">// 그러나 이 경우는 작동합니다.</span>\n\n<span class=\"hljs-comment\">// 직관적으로 Setters가 같은 방식으로 작동할 것으로 기대할 수도 있지만, 사실은 그렇지 않습니다.</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setAnimalSetter</span>(<span class=\"hljs-params\">setter: Setter&#x3C;Animal>, value: Animal</span>) {\n  <span class=\"hljs-title function_\">setter</span>(value);\n}\n\n<span class=\"hljs-comment\">// 동일한 유형의 Setter를 전달해도 작동합니다.</span>\n<span class=\"hljs-title function_\">setAnimalSetter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value: Animal</span>) =></span> {}, { <span class=\"hljs-attr\">animalStuff</span>: <span class=\"hljs-number\">0</span> });\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setDogSetter</span>(<span class=\"hljs-params\">setter: Setter&#x3C;Dog>, value: Dog</span>) {\n  <span class=\"hljs-title function_\">setter</span>(value);\n}\n\n<span class=\"hljs-comment\">// 여기도 마찬가지로 작동합니다.</span>\n<span class=\"hljs-title function_\">setDogSetter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value: Dog</span>) =></span> {}, { <span class=\"hljs-attr\">animalStuff</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">dogStuff</span>: <span class=\"hljs-number\">0</span> });\n\n<span class=\"hljs-comment\">// 그러나 Dog Setter를 setAnimalSetter 함수에 전달하면 Getter와는 반대로 동작이 반전됩니다.</span>\n<span class=\"hljs-title function_\">setAnimalSetter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value: Dog</span>) =></span> {}, { <span class=\"hljs-attr\">animalStuff</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">dogStuff</span>: <span class=\"hljs-number\">0</span> }); <span class=\"hljs-comment\">// Type error: Argument of type '(value: Dog) => void' is not assignable to parameter of type 'Setter&#x3C;Animal>'.</span>\n\n<span class=\"hljs-comment\">// 이번에는 상황이 반대로 작동합니다.</span>\n<span class=\"hljs-title function_\">setDogSetter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value: Animal</span>) =></span> {}, { <span class=\"hljs-attr\">animalStuff</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">dogStuff</span>: <span class=\"hljs-number\">0</span> });\n\n<span class=\"hljs-comment\">// 새로운 방법:</span>\n<span class=\"hljs-comment\">// TypeScript에이를 표시하기 위해 (필수는 아니지만 가독성을 위해 유용), 유형 매개변수에 대한 선택적 분산 주석을 사용합니다.</span>\ntype <span class=\"hljs-title class_\">GetterNew</span>&#x3C;out T> = <span class=\"hljs-function\">() =></span> T;\ntype <span class=\"hljs-title class_\">SetterNew</span>&#x3C;<span class=\"hljs-keyword\">in</span> T> = <span class=\"hljs-function\">(<span class=\"hljs-params\">value: T</span>) =></span> <span class=\"hljs-keyword\">void</span>;\n</code></pre>\n<ul>\n<li>moduleSuffixes로 해상도 사용자 정의: 사용자 정의 파일 접미사를 사용하는 환경(예: 네이티브 앱 빌드에 .ios를 사용하는 경우)에서는 TypeScript가 가져오기를 정확하게 해석하도록 이 접미사를 tsconfig.json에 지정할 수 있습니다.```</li>\n</ul>\n<pre><code class=\"hljs language-js\">...\n<span class=\"hljs-string\">\"compilerOptions\"</span>: [\n  ...\n  <span class=\"hljs-string\">\"moduleSuffixes\"</span>: [<span class=\"hljs-string\">\".ios\"</span>, <span class=\"hljs-string\">\".native\"</span>, <span class=\"hljs-string\">\"\"</span>]\n]\n...\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./foo'</span>;\n<span class=\"hljs-comment\">// 이 코드는 먼저 ./foo.ios.ts를 확인하고, 그 다음에는 ./foo.native.ts를, 마지막으로 ./foo.ts를 확인합니다.</span>\n</code></pre>\n<ul>\n<li>에디터에서 소스 정의로 이동: 에디터에서 새로운 \"소스 정의로 이동\" 메뉴 옵션이 사용 가능합니다. 이는 \"정의로 이동\"과 유사하지만, .ts 및 .js 파일을 .d.ts 타입 정의 파일보다 우선합니다.</li>\n</ul>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:800/1*qvzGqfF844cXCPMeDrg_IQ.gif\" alt=\"이미지\"></p>\n<h2>TypeScript 4.9</h2>\n<ul>\n<li><code>satisfies</code> 연산자: <code>satisfies</code> 연산자는 실제로 그 타입을 할당하지 않고도 타입과의 호환성을 확인할 수 있게 해줍니다. 이를 통해 더 정확한 추론된 타입을 유지하면서도 호환성을 유지할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이전:</span>\n<span class=\"hljs-comment\">// 여러 항목과 그 색상을 저장하는 객체/맵/딕셔너리가 있다고 가정해 보겠습니다.</span>\n<span class=\"hljs-keyword\">const</span> obj = {\n  <span class=\"hljs-attr\">fireTruck</span>: [<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n  <span class=\"hljs-attr\">bush</span>: <span class=\"hljs-string\">'#00ff00'</span>,\n  <span class=\"hljs-attr\">ocean</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>]\n} <span class=\"hljs-comment\">// { fireTruck: number[]; bush: string; ocean: number[]; } 타입으로 정의됨</span>\n\n<span class=\"hljs-comment\">// 배열과 문자열에 대해 작업을 수행할 수 있도록 속성을 암시적으로 타입 지정합니다.</span>\n<span class=\"hljs-keyword\">const</span> rgb1 = obj.<span class=\"hljs-property\">fireTruck</span>[<span class=\"hljs-number\">0</span>]; <span class=\"hljs-comment\">// 숫자로 타입 지정</span>\n<span class=\"hljs-keyword\">const</span> hex = obj.<span class=\"hljs-property\">bush</span>; <span class=\"hljs-comment\">// 문자열로 타입 지정</span>\n\n<span class=\"hljs-comment\">// 특정 객체만 허용하고 싶다면 Record 타입을 사용할 수 있습니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">oldObj</span>: <span class=\"hljs-title class_\">Record</span>&#x3C;string, [number, number, number] | string> = {\n  <span class=\"hljs-attr\">fireTruck</span>: [<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n  <span class=\"hljs-attr\">bush</span>: <span class=\"hljs-string\">'#00ff00'</span>,\n  <span class=\"hljs-attr\">ocean</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>]\n} <span class=\"hljs-comment\">// Record&#x3C;string, [number, number, number] | string> 타입으로 정의됨</span>\n<span class=\"hljs-comment\">// 하지만 이제 우리는 속성의 타입에 대한 정보를 잃어버립니다.</span>\n<span class=\"hljs-keyword\">const</span> oldRgb1 = oldObj.<span class=\"hljs-property\">fireTruck</span>[<span class=\"hljs-number\">0</span>]; <span class=\"hljs-comment\">// string 또는 number로 타입 지정</span>\n<span class=\"hljs-keyword\">const</span> oldHex = oldObj.<span class=\"hljs-property\">bush</span>; <span class=\"hljs-comment\">// string 또는 number로 타입 지정</span>\n\n<span class=\"hljs-comment\">// 새롭게:</span>\n<span class=\"hljs-comment\">// `satisfies` 키워드를 사용하여 타입과 호환성을 확인할 수 있습니다.</span>\n<span class=\"hljs-keyword\">const</span> newObj = {\n  <span class=\"hljs-attr\">fireTruck</span>: [<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n  <span class=\"hljs-attr\">bush</span>: <span class=\"hljs-string\">'#00ff00'</span>,\n  <span class=\"hljs-attr\">ocean</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>]\n} satisfies <span class=\"hljs-title class_\">Record</span>&#x3C;string, [number, number, number] | string> <span class=\"hljs-comment\">// { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; } 타입으로 정의됨</span>\n<span class=\"hljs-comment\">// 이제 속성의 타입에 대한 정보를 유지할 수 있을 뿐만 아니라 배열은 튜플로 더 정확해집니다.</span>\n<span class=\"hljs-keyword\">const</span> newRgb1 = newObj.<span class=\"hljs-property\">fireTruck</span>[<span class=\"hljs-number\">0</span>]; <span class=\"hljs-comment\">// 숫자로 타입 지정</span>\n<span class=\"hljs-keyword\">const</span> newRgb4 = newObj.<span class=\"hljs-property\">fireTruck</span>[<span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">// 타입 오류: 길이가 '3'인 튜플 타입 '[number, number, number]'에는 인덱스 '3'에 해당하는 요소가 없습니다.</span>\n<span class=\"hljs-keyword\">const</span> newHex = newObj.<span class=\"hljs-property\">bush</span>; <span class=\"hljs-comment\">// 문자열로 타입 지정</span>\n</code></pre>\n<ul>\n<li>편집기의 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령: 편집기에서 새로운 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령(및 자동 수정)을 사용하면 Imports를 관리하는 것이 더 쉬워집니다.</li>\n</ul>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:800/1*z5SG6BKwzyxrG6sG7OKciw.gif\" alt=\"이미지\"></p>\n<h2>TypeScript 5.0</h2>\n<ul>\n<li>ES 데코레이터 지원: TypeScript는 이제 ES 데코레이터(곧 나올 ES 기능)를 지원하며, 기존 데코레이터와는 다릅니다. 이전에 TypeScript는 데코레이터에 대해 실험적인 지원을 했었는데, 이는 Angular와 같은 프레임워크에서 사용되는 것으로, --experimentalDecorators 플래그(또는 tsconfig.json에서)로 선택할 수 있었으며 약간 다르게 동작했습니다. 그러나 이제 새로운 ES 데코레이터는 이전 것과는 다르게 메타데이터를 내보내지 못하며 아직은 매개변수에서도 지원되지 않습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 주의: 2023년 5월 기준으로 이것은 예정된 ES 기능이므로 이 코드는 아직 작동하지 않습니다.</span>\n\n<span class=\"hljs-comment\">// 디버깅 중에 메서드에 진입하거나 나갈 때마다 기록하려고 합니다.</span>\n<span class=\"hljs-comment\">// 이것을 수동으로 하는 것은 상당히 지루할 수 있습니다. 자동화할 방법이 있을까요?</span>\n<span class=\"hljs-comment\">// 네, 데코레이터를 사용하여 실행 컨텍스트를 대체할 수 있습니다.</span>\n\n<span class=\"hljs-comment\">// 먼저 데코레이터 역할을 할 함수를 정의합니다. 이 함수는 원본 메서드와 컨텍스트 개체를 매개변수로 받아 새로운 실행 함수를 반환합니다.</span>\n<span class=\"hljs-keyword\">function</span> logMethod&#x3C;<span class=\"hljs-title class_\">This</span>, <span class=\"hljs-title class_\">Args</span> <span class=\"hljs-keyword\">extends</span> any[], <span class=\"hljs-title class_\">Return</span>>(<span class=\"hljs-attr\">originalMethod</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">this</span>: This, ...args: Args</span>) =></span> <span class=\"hljs-title class_\">Return</span>, <span class=\"hljs-attr\">context</span>: <span class=\"hljs-title class_\">ClassMethodDecoratorContext</span>) {\n  <span class=\"hljs-keyword\">const</span> methodName = <span class=\"hljs-title class_\">String</span>(context.<span class=\"hljs-property\">name</span>);\n\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">replacementFunction</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">this</span>: This, ...args: Args</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`LOG: 메서드 '<span class=\"hljs-subst\">${methodName}</span>' 진입 중.`</span>)\n    <span class=\"hljs-keyword\">const</span> result = originalMethod.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, ...args);\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`LOG: 메서드 '<span class=\"hljs-subst\">${methodName}</span>' 나감.`</span>)\n    <span class=\"hljs-keyword\">return</span> result;\n  }\n\n  <span class=\"hljs-keyword\">return</span> replacementFunction;\n}\n\n<span class=\"hljs-comment\">// 이제 이를 사용할 클래스를 정의합니다. 데코레이터는 클래스와 그 멤버에만 작동합니다.</span>\n<span class=\"hljs-comment\">// 메서드에 '@'와 함수명을 사용하여 데코레이터를 적용합니다.</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> {\n  @logMethod\n  <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'작업 중'</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> testObj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Test</span>();\n\n<span class=\"hljs-comment\">// 메서드를 실행하면 대체 메서드가 호출됩니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(testObj.<span class=\"hljs-title function_\">doSomething</span>()); <span class=\"hljs-comment\">// \"LOG: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"LOG: 메서드 'doSomething' 나감.\"</span>\n\n<span class=\"hljs-comment\">// 사용자 정의 메시지와 같은 추가 인수를 전달하려면 데코레이터 팩토리(데코레이터 함수를 반환하는 함수)를 정의할 수 있습니다.</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">logMethodCustom</span>(<span class=\"hljs-params\">customMessage: string</span>) {\n  <span class=\"hljs-keyword\">return</span> &#x3C;<span class=\"hljs-title class_\">This</span>, <span class=\"hljs-title class_\">Args</span> <span class=\"hljs-keyword\">extends</span> any[], <span class=\"hljs-title class_\">Return</span>><span class=\"hljs-function\">(<span class=\"hljs-params\">originalMethod: (<span class=\"hljs-variable language_\">this</span>: This, ...args: Args) => Return, context: ClassMethodDecoratorContext</span>) =></span> {\n    <span class=\"hljs-keyword\">const</span> methodName = <span class=\"hljs-title class_\">String</span>(context.<span class=\"hljs-property\">name</span>);\n\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">replacementFunction</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">this</span>: This, ...args: Args</span>) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${customMessage}</span>: 메서드 '<span class=\"hljs-subst\">${methodName}</span>' 진입 중.`</span>)\n      <span class=\"hljs-keyword\">const</span> result = originalMethod.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, ...args);\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${customMessage}</span>: 메서드 '<span class=\"hljs-subst\">${methodName}</span>' 나감.`</span>)\n      <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-keyword\">return</span> replacementFunction;\n  }\n}\n\n<span class=\"hljs-comment\">// 이번에는 함수 호출을 포함하는 `()`로 된 추가 인수를 사용하여 메서드에 데코레이터를 적용합니다.</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TestCustom</span> {\n  @<span class=\"hljs-title function_\">logMethodCustom</span>(<span class=\"hljs-string\">'테스트 로그'</span>)\n  <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'작업 중'</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> testCustomObj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Test</span>();\n\n<span class=\"hljs-comment\">// 메서드 실행시 모든 작업이 예상대로 작동합니다.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(testCustomObj.<span class=\"hljs-title function_\">doSomething</span>()); <span class=\"hljs-comment\">// \"테스트 로그: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"테스트 로그: 메서드 'doSomething' 나감.\"</span>\n\n<span class=\"hljs-comment\">// 데코레이터 함수에서 대체 메서드를 반환하지 않으면 원본 메서드가 호출되지만 관련 설정을 아직 설정할 수 있습니다.</span>\n<span class=\"hljs-comment\">// 예를 들어 `constructor` 단계 이전에 `this`를 바인딩하여 클래스 외부에서 콜백으로 전달할 경우 동일하게 실행되도록합니다.</span>\n<span class=\"hljs-comment\">// `constructor` 단계 이전에 코드를 실행하려면 컨텍스트 개체의 `addInitializer` 메서드를 사용할 수 있습니다.</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bindThis</span>(<span class=\"hljs-params\">_: unknown, context: ClassMethodDecoratorContext</span>) {\n<span class=\"hljs-keyword\">const</span> methodName = context.<span class=\"hljs-property\">name</span>;\n<span class=\"hljs-keyword\">if</span> (context.<span class=\"hljs-property\">private</span>) {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`'bound'는 <span class=\"hljs-subst\">${methodName <span class=\"hljs-keyword\">as</span> string}</span>과 같은 비공개 속성을 데코레이션할 수 없습니다.`</span>);\n}\ncontext.<span class=\"hljs-title function_\">addInitializer</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"><span class=\"hljs-variable language_\">this</span>: any</span>) {\n  <span class=\"hljs-keyword\">const</span> methodName = context.<span class=\"hljs-property\">name</span>;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> methodName === <span class=\"hljs-string\">'string'</span>) {\n      <span class=\"hljs-variable language_\">this</span>[methodName] = <span class=\"hljs-variable language_\">this</span>[methodName].<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>);\n    }\n  });\n}\n\n<span class=\"hljs-comment\">// 바인딩하지 않은 상태로 한번 정의합니다.</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TestUnbound</span> {\n  private returnVal = <span class=\"hljs-string\">'작업 중'</span>;\n\n  <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">returnVal</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> testUnboundObj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TestUnbound</span>();\n\n<span class=\"hljs-comment\">// 메서드에 다시 \"데코레이터\"를 적용합니다.</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TestBound</span> {\n  private returnVal = <span class=\"hljs-string\">'작업 중'</span>;\n\n  @bindThis\n  <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">returnVal</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> testBoundObj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TestBound</span>();\n\n<span class=\"hljs-comment\">// 클래스 컨텍스트 외부에 메서드를 저장하고 실행시키면 속성 값에 액세스할 수 없습니다.</span>\n<span class=\"hljs-keyword\">const</span> unboundFunc = testUnboundObj.<span class=\"hljs-property\">doSomething</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">unboundFunc</span>()); <span class=\"hljs-comment\">// 오류: \"Cannot read properties of undefined (reading 'returnVal')\"</span>\n\n<span class=\"hljs-comment\">// 그러나 바인딩하면 예상대로 작동합니다.</span>\n<span class=\"hljs-keyword\">const</span> boundFunc = testBoundObj.<span class=\"hljs-property\">doSomething</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">boundFunc</span>()); <span class=\"hljs-comment\">// \"작업 중\"</span>\n</code></pre>\n<ul>\n<li>\n<p>const 형식 매개변수: 형식 매개변수 앞에 const를 지정하는 const는 readonly 형식을 그대로 사용하는 것처럼 동작하도록 시도합니다. 그러나 변경 가능한 값을 형식화했다면 인자유추가 작동하지 않을 수 있습니다(왜냐하면 읽기전용 형식은 변경 가능한 형식에 할당할 수 없기 때문에 항상 readonly 형식을 상속해야 합니다). 이것은 여전히 허용된 매개변수를 제한하지 않습니다. 여전히 extends 내에서 제한해야 합니다.</p>\n</li>\n<li>\n<p>타입을 활용한 여러 구성 파일 지원: 복잡한 상속 구조를 만들거나 모든 \"tsconfig\"에서 항상 동일한 구성을 확장하거나 모든 설정을 복사하여 모두 복사하는 대신, \"tsconfig\" 파일에서 \"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"]를 지정함으로써 여러 파일을 확장하여 동작을 재정의할 수 있습니다. 후자의 파일이 오버라이드 동작을 우선시합니다.</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-js\">...\n<span class=\"hljs-comment\">// 여기서 \"tsconfig1.json\"은 \"@tsconfig/strictest/tsconfig.json\"을 덮어씁니다. \"tsconfig2.json\"은 \"tsconfig1.json\"과 \"@tsconfig/strictest/tsconfig.json\"을 덮어쓰며, 이 파일은 모두 덮어씁니다.</span>\n<span class=\"hljs-string\">\"extends\"</span>: [<span class=\"hljs-string\">\"@tsconfig/strictest/tsconfig.json\"</span>, <span class=\"hljs-string\">\"./tsconfig1.json\"</span>, <span class=\"hljs-string\">\"./tsconfig2.json\"</span>],\n...\n</code></pre>\n<ul>\n<li>모든 열거형이 합집합 열거형입니다: 동적으로 할당된 열거형 값은 이제 더 이상 예전의 열거형 전략 기본값을 갖지 않습니다(열거형 키에 대한 타입 없음, 값으로만 사용 가능하며 타입으로 사용할 수 없음). 대신 이제 타입으로도 사용할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 열거형은 각 값마다 다른 타입을 만듭니다.</span>\nenum <span class=\"hljs-title class_\">Color</span> {\n  <span class=\"hljs-title class_\">Red</span>, <span class=\"hljs-title class_\">Green</span>, <span class=\"hljs-title class_\">Blue</span>, <span class=\"hljs-title class_\">Orange</span>, <span class=\"hljs-title class_\">Yellow</span>, <span class=\"hljs-title class_\">Violet</span>\n}\n\n<span class=\"hljs-comment\">// 이를 통해 그들을 좁히고 다른 타입처럼 사용할 수 있습니다.</span>\ntype <span class=\"hljs-title class_\">PrimaryColor</span> = <span class=\"hljs-title class_\">Color</span>.<span class=\"hljs-property\">Red</span> | <span class=\"hljs-title class_\">Color</span>.<span class=\"hljs-property\">Green</span> | <span class=\"hljs-title class_\">Color</span>.<span class=\"hljs-property\">Blue</span>;\n\n<span class=\"hljs-comment\">// 하지만:</span>\n<span class=\"hljs-comment\">// 값이 동적으로 할당되면 고정된 값이 없습니다.</span>\n<span class=\"hljs-comment\">// 이전에는 예전 열거형 동작으로 되돌아가게 되었습니다.</span>\n<span class=\"hljs-comment\">// 예전 열거형 동작에서 그 멤버는 값으로만 존재하며 타입으로는 존재하지 않음.</span>\nenum <span class=\"hljs-title class_\">ColorRandom</span> {\n  <span class=\"hljs-title class_\">Red</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>(),\n  <span class=\"hljs-title class_\">Green</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>(),\n  <span class=\"hljs-title class_\">Blue</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>(),\n  <span class=\"hljs-title class_\">Orange</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>(),\n  <span class=\"hljs-title class_\">Yellow</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>(),\n  <span class=\"hljs-title class_\">Violet</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>()\n}\n\n<span class=\"hljs-comment\">// 그래서 이전에는 좁혀지지 못했습니다.</span>\ntype <span class=\"hljs-title class_\">PrimaryColorRandom</span> = <span class=\"hljs-title class_\">ColorRandom</span>.<span class=\"hljs-property\">Red</span> | <span class=\"hljs-title class_\">ColorRandom</span>.<span class=\"hljs-property\">Green</span> | <span class=\"hljs-title class_\">ColorRandom</span>.<span class=\"hljs-property\">Blue</span>; <span class=\"hljs-comment\">// 이전 타입 오류: Enum 타입 'ColorRandom'은 리터럴이 아닌 초기화 값을 갖는 멤버를 가지고 있습니다.</span>\n<span class=\"hljs-comment\">// 하지만 이제 그들에게도 자체 타입이 있기 때문에 작동합니다.</span>\n</code></pre>\n<ul>\n<li>--moduleResolution bundler: TS 4.7의 모듈 해결 전략 \"node16\"은 ES 모듈을 더 잘 모델링할 수 있게 해주지만 일부 불필요한 제약이 있었습니다(파일 확장자를 명시해야 했으며, ...). 번들러를 사용 중이라면, 새 전략은 최신 기능을 유지하면서 일부 제약을 제거하려고 시도합니다. 컴파일러 플래그 --moduleResolution bundle를 지정하여 사용할 수 있습니다(또는 tsconfig.json에서). 번들러를 사용할 때만 사용하세요.</li>\n</ul>\n<pre><code class=\"hljs language-json\">...\n<span class=\"hljs-attr\">\"compilerOptions\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n  ...\n  <span class=\"hljs-attr\">\"moduleResolution\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"bundler\"</span>\n<span class=\"hljs-punctuation\">]</span>\n...\n</code></pre>\n<pre><code class=\"hljs language-json\">import * as foo from './foo';\n<span class=\"hljs-comment\">// 이제는 파일 확장자가 지정되지 않아도 다시 허용됩니다.</span>\n</code></pre>\n<ul>\n<li>해상도 Customization Flags: \"hybrid\" 모듈 해상도에 대한 규칙을 설정합니다. 규칙은 다음과 같습니다: allowImportingTsExtensions, resolvePackageJsonExports (imports를 위해 package.json exports을 고려함), resolvePackageJsonImports (#로 시작하는 경로를 위해 로컬 package.json을 참조함), allowArbitraryExtensions 및 customConditions (node16 및 bundler 전용, package.json에서 조건부 exports 및 imports을 위해 사용됨)입니다. 이러한 모든 설정은 --를 접두사로 하여 컴파일러 플래그로 지정하거나 tsconfig.json에 지정할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-json\">...\n<span class=\"hljs-attr\">\"compilerOptions\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n  ...\n  <span class=\"hljs-attr\">\"allowImportingTsExtensions\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">false</span></span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"resolvePackageJsonExports\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"resolvePackageJsonImports\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"allowArbitraryExtensions\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">false</span></span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"customConditions\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-string\">\"my-condition\"</span><span class=\"hljs-punctuation\">]</span>\n  <span class=\"hljs-comment\">// 이제는 `package.json`의 `exports` 및 `imports`에 대한 사용자 정의 조건을 해결하려고 시도합니다.</span>\n  <span class=\"hljs-comment\">// TS는 그런 다음 해당 사용자 정의 조건에 맞도록 파일을 매칭하려고 할 것입니다 (이 경우 `foo.mjs`).</span>\n<span class=\"hljs-punctuation\">]</span>\n...\n</code></pre>\n<pre><code class=\"hljs language-js\">{\n  ...\n  <span class=\"hljs-string\">\"exports\"</span>: {\n    <span class=\"hljs-string\">\".\"</span>: {\n      <span class=\"hljs-string\">\"my-condition\"</span>: <span class=\"hljs-string\">\"./foo.mjs\"</span>,\n      <span class=\"hljs-string\">\"node\"</span>: <span class=\"hljs-string\">\"./bar.mjs\"</span>,\n      <span class=\"hljs-string\">\"import\"</span>: <span class=\"hljs-string\">\"./baz.mjs\"</span>,\n      <span class=\"hljs-string\">\"require\"</span>: <span class=\"hljs-string\">\"./biz.mjs\"</span>\n    }\n  }\n}\n</code></pre>\n<ul>\n<li><strong>--verbatimModuleSyntax:</strong> 자동으로 import (import elision) 및 exports를 제거하지 않도록 TypeScript를 중지합니다. 이것은 import side effects가 사용될 때 또는 TS가 import가 어디에서 사용되는지 인식하지 못할 때 유용할 수 있습니다. import type 및 export type 문은 여전히 최종 컴파일에서 제거됩니다. 대개 import가 타입인지 아닌지 명시하는 것이 권장됩니다. compiler flag --verbatimModuleSyntax(또는 tsconfig.json에서)를 지정하여 사용할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// `verbatimModuleSyntax`가 설정되지 않으면 이 import는 최종 컴파일에서 제거될 것입니다.</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Car</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./car'</span>;\n<span class=\"hljs-comment\">// 이 import는 아무 경우에나 제거될 것입니다.</span>\n<span class=\"hljs-keyword\">import</span> type { <span class=\"hljs-title class_\">Car</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./car'</span>;\n<span class=\"hljs-comment\">// 이 import는 절대로 제거되지 않습니다.</span>\n<span class=\"hljs-keyword\">import</span> { logCar } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./car'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drive</span>(<span class=\"hljs-params\">car: Car</span>) {\n  <span class=\"hljs-title function_\">logCar</span>(car);\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<ul>\n<li><strong>export type * 지원:</strong> 기본 형식을 하위 모듈로 쉽게 다시 내보낼 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 기본 타입들을 다른 모듈로서 서브모듈로 내보냅니다.</span>\n<span class=\"hljs-keyword\">export</span> type * <span class=\"hljs-keyword\">as</span> am <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'another-module'</span>;\n<span class=\"hljs-comment\">// 또는 다시 기본 내보낸 것으로 제공합니다.</span>\n<span class=\"hljs-keyword\">export</span> type * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'another-module'</span>;\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> type { am } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;\n<span class=\"hljs-comment\">// 또는</span>\n<span class=\"hljs-keyword\">import</span> type { } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;\n</code></pre>\n<ul>\n<li>--build 하위에서 Emit-Specific 플래그 전달: 빌드에 대한 동작을 지정하는 플래그들 (--build를 사용할 때). 이들은 --declaration, --emitDeclarationOnly, --declarationMap, --sourceMap 및 --inlineSourceMap를 포함합니다. 모두 이제 컴파일러 플래그로 지정할 수 있습니다. 이전에는 tsconfig.json에서만 설정할 수 있었어요.</li>\n</ul>\n<pre><code class=\"hljs language-js\"># 이것은 <span class=\"hljs-string\">`tsconfig.json`</span>에서 비활성화되어 있더라도 타입 선언을 생성합니다.\ntsc --build --declaration\n</code></pre>\n<ul>\n<li>에디터에서 대소문자 구분 없는 import 정렬: 에디터에서 import를 정렬할 때 대소문자 구분 동작을 변경하세요. 이 기능은 VSCode의 JSON 설정 내 typescript.unstable 아래에서 활성화하고 구성할 수 있습니다.</li>\n</ul>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1032/1*Fei6JPgYzIgnl_IMekhOQg.gif\" alt=\"이미지\"></p>\n<ul>\n<li>Exhaustive switch/case 자동 완성: 에디터에서 이제 리터럴 타입의 case 문을 자동으로 완성할 수 있습니다.</li>\n</ul>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:656/1*e9FNtf4-kxU787rEl1w9lQ.gif\" alt=\"이미지\"></p>\n</body>\n</html>\n"},"__N_SSG":true}