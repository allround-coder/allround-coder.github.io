{"pageProps":{"post":{"title":"리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식","description":"","date":"2024-05-12 22:45","slug":"2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB","content":"\n\n![이미지](/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png)\n\n건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.\n\n우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.\n\n서비스 워커란 무엇인가요?\n\n\n\n서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.\n\n동기화 관리자와 IndexedDB: 완벽한 조합\n\nSync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.\n\n사용 사례: 오프라인에서 양식 데이터 저장\n\n\n\n건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.\n\n# 코드 예시\n\n## 시작하기\n\n저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.\n\n\n\n번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:\n\n```js\nbun create my-app --template react\n```\n\n```js\ncd my-app && bun run dev\n```\n\n저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.\n\n\n\n**참고**: 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.\n\n# 단계 1: 서비스 워커 등록\n\n애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.\n\n```js\ninterface Person {\n  firstName: string,\n  lastName: string,\n  age: number\n}\n\nfunction App() {\n  const [people, setPeople] = useState<Person[]>([]);\n  const { register, handleSubmit } = useForm();\n\n  const registerWorker = () => {\n    if ('serviceWorker' in navigator) {\n      window.addEventListener('load', () => {\n        navigator.serviceWorker.register('/service-worker.js', {scope: '/', type: 'module'})\n          .then(registration => {\n            console.log('Service Worker registered: ', registration);\n          })\n          .catch(registrationError => {\n            console.log('Service Worker registration failed: ', registrationError); \n          });\n      });\n    }\n  }\n```\n\n\n\n# 단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정\n\n우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.\n\n이 서비스 워커 파일에서 'install' 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:\n\n```js\n// service-worker.js \n\nself.addEventListener('install', async (event) => {\n    console.log('Service Worker installing...');\n    await openDB('formDataStore', 1, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains('formData')) {\n            db.createObjectStore('formData', { autoIncrement: true });\n            console.log('Object store created!');\n          }\n        },\n    });\n    console.log('Service Worker installed.');\n});\n```\n\n\n\n# 단계 3: 폼 제출 가로채기\n\n폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.\n\n```js\n// App.tsx\n\n  const onSubmit = async (data: FieldValues) => {\n    if (navigator.onLine) {\n      const response = await fetch(API_URL + '/people',\n        { method: \"POST\", body: JSON.stringify(data) }\n      )\n      if (response.ok) {\n        console.log(response)\n        setPeople((prevPeople) => [{...data} as Person, ...prevPeople])\n      }\n\n    } else {\n      await storeFormDataLocally(data);\n    }\n  }\n```\n\n# 단계 4: 로컬로 데이터 저장하기\n\n\n\n오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.\n\n```js\nasync function storeFormDataLocally(formData : FieldValues) {\n\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readwrite');\n    const store = tx.objectStore('formData');\n    store.put(formData);\n    await tx.done;\n    if ('serviceWorker' in navigator && 'SyncManager' in window) {\n      const registration : any  = await navigator.serviceWorker.ready\n      try {\n        await registration.sync.register('sendFormData');\n          console.log('Sync event registered');\n      } catch(e) {\n          console.log('Failed to register sync, will retry on next   visit' + e);\n      }\n  }\n    db.close();\n  }\n```\n\n서비스 워커는 'sync' 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.\n\n```js\nself.addEventListener('sync', event => {\n    if (event.tag === 'sendFormData') {\n        event.waitUntil(sendFormDataToServer());\n    }\n});\n```\n\n\n\n# 단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기\n\n실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.\n\n```js\nexport async function sendFormDataToServer() {\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readonly');\n    const store = tx.objectStore('formData');\n    const allSavedData = await store.getAll();\n    console.log('저장된 폼 데이터', allSavedData);\n    try {\n        allSavedData.forEach( async (form, index) =>  {\n            const response = await fetch('http://localhost:3000/people',  \n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(form)\n            });\n            if (response.ok) {\n                console.log('서버와 동기화된 데이터:', form);\n                await db.transaction('formData', 'readwrite').objectStore('formData').delete(index);\n                console.log(`제거된 폼 데이터: ${form.firstName} ${form.lastName}` )\n            }\n        });\n    } catch (error) {\n        console.error('폼 데이터 전송 실패:', error);\n    }\n}\n```\n\n# 결론\n\n\n\n건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.\n\nReact, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.\n\n코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.\n\n원문은 https://dennistowns.substack.com에서 원본 게시됨.","ogImage":{"url":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png"},"coverImage":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png\" alt=\"이미지\"></p>\n<p>건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.</p>\n<p>우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.</p>\n<p>서비스 워커란 무엇인가요?</p>\n<p>서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.</p>\n<p>동기화 관리자와 IndexedDB: 완벽한 조합</p>\n<p>Sync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.</p>\n<p>사용 사례: 오프라인에서 양식 데이터 저장</p>\n<p>건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.</p>\n<h1>코드 예시</h1>\n<h2>시작하기</h2>\n<p>저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.</p>\n<p>번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:</p>\n<pre><code class=\"hljs language-js\">bun create my-app --template react\n</code></pre>\n<pre><code class=\"hljs language-js\">cd my-app &#x26;&#x26; bun run dev\n</code></pre>\n<p>저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.</p>\n<p><strong>참고</strong>: 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.</p>\n<h1>단계 1: 서비스 워커 등록</h1>\n<p>애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">Person</span> {\n  <span class=\"hljs-attr\">firstName</span>: string,\n  <span class=\"hljs-attr\">lastName</span>: string,\n  <span class=\"hljs-attr\">age</span>: number\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [people, setPeople] = useState&#x3C;<span class=\"hljs-title class_\">Person</span>[]>([]);\n  <span class=\"hljs-keyword\">const</span> { register, handleSubmit } = <span class=\"hljs-title function_\">useForm</span>();\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">registerWorker</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'serviceWorker'</span> <span class=\"hljs-keyword\">in</span> navigator) {\n      <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'load'</span>, <span class=\"hljs-function\">() =></span> {\n        navigator.<span class=\"hljs-property\">serviceWorker</span>.<span class=\"hljs-title function_\">register</span>(<span class=\"hljs-string\">'/service-worker.js'</span>, {<span class=\"hljs-attr\">scope</span>: <span class=\"hljs-string\">'/'</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'module'</span>})\n          .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">registration</span> =></span> {\n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Service Worker registered: '</span>, registration);\n          })\n          .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">registrationError</span> =></span> {\n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Service Worker registration failed: '</span>, registrationError); \n          });\n      });\n    }\n  }\n</code></pre>\n<h1>단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정</h1>\n<p>우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.</p>\n<p>이 서비스 워커 파일에서 'install' 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// service-worker.js </span>\n\nself.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'install'</span>, <span class=\"hljs-keyword\">async</span> (event) => {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Service Worker installing...'</span>);\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">openDB</span>(<span class=\"hljs-string\">'formDataStore'</span>, <span class=\"hljs-number\">1</span>, {\n        <span class=\"hljs-title function_\">upgrade</span>(<span class=\"hljs-params\">db</span>) {\n          <span class=\"hljs-keyword\">if</span> (!db.<span class=\"hljs-property\">objectStoreNames</span>.<span class=\"hljs-title function_\">contains</span>(<span class=\"hljs-string\">'formData'</span>)) {\n            db.<span class=\"hljs-title function_\">createObjectStore</span>(<span class=\"hljs-string\">'formData'</span>, { <span class=\"hljs-attr\">autoIncrement</span>: <span class=\"hljs-literal\">true</span> });\n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Object store created!'</span>);\n          }\n        },\n    });\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Service Worker installed.'</span>);\n});\n</code></pre>\n<h1>단계 3: 폼 제출 가로채기</h1>\n<p>폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// App.tsx</span>\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onSubmit</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">data: FieldValues</span>) => {\n    <span class=\"hljs-keyword\">if</span> (navigator.<span class=\"hljs-property\">onLine</span>) {\n      <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-variable constant_\">API_URL</span> + <span class=\"hljs-string\">'/people'</span>,\n        { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\"POST\"</span>, <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(data) }\n      )\n      <span class=\"hljs-keyword\">if</span> (response.<span class=\"hljs-property\">ok</span>) {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(response)\n        <span class=\"hljs-title function_\">setPeople</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevPeople</span>) =></span> [{...data} <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Person</span>, ...prevPeople])\n      }\n\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">storeFormDataLocally</span>(data);\n    }\n  }\n</code></pre>\n<h1>단계 4: 로컬로 데이터 저장하기</h1>\n<p>오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">storeFormDataLocally</span>(<span class=\"hljs-params\">formData : FieldValues</span>) {\n\n    <span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">openDB</span>(<span class=\"hljs-string\">'formDataStore'</span>, <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">const</span> tx = db.<span class=\"hljs-title function_\">transaction</span>(<span class=\"hljs-string\">'formData'</span>, <span class=\"hljs-string\">'readwrite'</span>);\n    <span class=\"hljs-keyword\">const</span> store = tx.<span class=\"hljs-title function_\">objectStore</span>(<span class=\"hljs-string\">'formData'</span>);\n    store.<span class=\"hljs-title function_\">put</span>(formData);\n    <span class=\"hljs-keyword\">await</span> tx.<span class=\"hljs-property\">done</span>;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'serviceWorker'</span> <span class=\"hljs-keyword\">in</span> navigator &#x26;&#x26; <span class=\"hljs-string\">'SyncManager'</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable language_\">window</span>) {\n      <span class=\"hljs-keyword\">const</span> registration : any  = <span class=\"hljs-keyword\">await</span> navigator.<span class=\"hljs-property\">serviceWorker</span>.<span class=\"hljs-property\">ready</span>\n      <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">await</span> registration.<span class=\"hljs-property\">sync</span>.<span class=\"hljs-title function_\">register</span>(<span class=\"hljs-string\">'sendFormData'</span>);\n          <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Sync event registered'</span>);\n      } <span class=\"hljs-keyword\">catch</span>(e) {\n          <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Failed to register sync, will retry on next   visit'</span> + e);\n      }\n  }\n    db.<span class=\"hljs-title function_\">close</span>();\n  }\n</code></pre>\n<p>서비스 워커는 'sync' 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.</p>\n<pre><code class=\"hljs language-js\">self.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'sync'</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =></span> {\n    <span class=\"hljs-keyword\">if</span> (event.<span class=\"hljs-property\">tag</span> === <span class=\"hljs-string\">'sendFormData'</span>) {\n        event.<span class=\"hljs-title function_\">waitUntil</span>(<span class=\"hljs-title function_\">sendFormDataToServer</span>());\n    }\n});\n</code></pre>\n<h1>단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기</h1>\n<p>실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sendFormDataToServer</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">openDB</span>(<span class=\"hljs-string\">'formDataStore'</span>, <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">const</span> tx = db.<span class=\"hljs-title function_\">transaction</span>(<span class=\"hljs-string\">'formData'</span>, <span class=\"hljs-string\">'readonly'</span>);\n    <span class=\"hljs-keyword\">const</span> store = tx.<span class=\"hljs-title function_\">objectStore</span>(<span class=\"hljs-string\">'formData'</span>);\n    <span class=\"hljs-keyword\">const</span> allSavedData = <span class=\"hljs-keyword\">await</span> store.<span class=\"hljs-title function_\">getAll</span>();\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'저장된 폼 데이터'</span>, allSavedData);\n    <span class=\"hljs-keyword\">try</span> {\n        allSavedData.<span class=\"hljs-title function_\">forEach</span>( <span class=\"hljs-keyword\">async</span> (form, index) =>  {\n            <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'http://localhost:3000/people'</span>,  \n            {\n                <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>,\n                <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/json'</span> },\n                <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(form)\n            });\n            <span class=\"hljs-keyword\">if</span> (response.<span class=\"hljs-property\">ok</span>) {\n                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'서버와 동기화된 데이터:'</span>, form);\n                <span class=\"hljs-keyword\">await</span> db.<span class=\"hljs-title function_\">transaction</span>(<span class=\"hljs-string\">'formData'</span>, <span class=\"hljs-string\">'readwrite'</span>).<span class=\"hljs-title function_\">objectStore</span>(<span class=\"hljs-string\">'formData'</span>).<span class=\"hljs-title function_\">delete</span>(index);\n                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`제거된 폼 데이터: <span class=\"hljs-subst\">${form.firstName}</span> <span class=\"hljs-subst\">${form.lastName}</span>`</span> )\n            }\n        });\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'폼 데이터 전송 실패:'</span>, error);\n    }\n}\n</code></pre>\n<h1>결론</h1>\n<p>건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.</p>\n<p>React, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.</p>\n<p>코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.</p>\n<p>원문은 <a href=\"https://dennistowns.substack.com%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\">https://dennistowns.substack.com에서</a> 원본 게시됨.</p>\n</body>\n</html>\n"},"__N_SSG":true}