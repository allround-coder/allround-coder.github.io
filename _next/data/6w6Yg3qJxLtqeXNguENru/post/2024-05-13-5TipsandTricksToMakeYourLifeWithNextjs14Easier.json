{"pageProps":{"post":{"title":"5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법","description":"","date":"2024-05-13 00:27","slug":"2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier","content":"\n\n![이미지](/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png)\n\nNext.js 14은 서버 렌더링된 React 애플리케이션을 구축하는 프로세스를 간단화하는 강력한 React 프레임워크입니다. 그러나 고급 기능과 규칙 때문에 특히 이 프레임워크에 처음 접하는 개발자들에게 혼란과 모호함이 있을 수 있습니다. 이 블로그 포스트에서는 Next.js 14를 사용하여 일상을 더 편리하게 만드는 다섯 가지 팁과 요령을 살펴보겠습니다.\n\n## 팁 1: Next.js 이미지 작업\n\nNext.js에서 이미지 처리는 혼란스러운 부분입니다. 로컬 이미지 또는 원격 이미지와 작업하는 방법은 다르기 때문입니다.\n\n\n\n# 로컬 이미지\n\n로컬 이미지를 사용할 때는 너비와 높이를 지정할 필요가 없어요. Next.js가 자동으로 이미지 크기를 확인합니다. 이미지를 가져와 `next/image` 컴포넌트를 사용해 렌더링하세요.\n\n```js\nimport Image from \"next/image\";\nimport localImage from \"public/hoy.png\";\nexport default function MyComponent() {\n  return <Image src={localImage} alt=\"로컬 이미지\" />;\n}\n```\n\n\n\n# 원격 이미지\n\n![Remote Image](/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_2.png)\n\n원격 이미지를 사용할 때는 레이아웃 변동을 방지하기 위해 블러 플레이스홀더를 제공하고 너비와 높이를 지정해야 합니다. `placeholder=\"blur\"` 속성을 사용하여 이미지의 완전한 버전이 로드될 때까지 이미지의 흐린 버전을 표시할 수 있습니다.\n\n원격 이미지의 블러 데이터 URL을 생성하려면 `sharp` 및 `placeholder` 패키지를 사용할 수 있습니다:\n\n\n\n```js\nimport Image from \"next/image\";\nimport getBase64 from \"./utils/getBase64\";\nexport default async function MyComponent() {\n  const blurDataUrl = await getBase64(remoteImageUrl);\n  return (\n    <Image\n      src={remoteImageUrl}\n      width={600}\n      height={600}\n      alt=\"Remote Image\"\n      placeholder=\"blur\"\n      blurDataURL={blurDataUrl}\n    />\n  );\n}\n```\n\n`getBase64` 유틸리티 함수는 원격 이미지를 가져와 ArrayBuffer로 변환한 다음 `placeholder` 패키지를 사용하여 해당 이미지의 base64 표현을 생성합니다.\n\n# 팁 2: 환경 변수 처리\n\n환경 변수를 `next.config.env.NEXT_PUBLIC_*`로 표시할 때 주의하십시오. 이러한 변수는 브라우저에서 노출되며 JavaScript 번들에 포함됩니다. 민감한 API 키나 비밀 정보가 있는 경우 `NEXT_PUBLIC_`로 접두사를 붙이지 않도록 주의하십시오. Node.js 환경에서만 사용할 수 있게 됩니다.```\n\n\n\n# 팁 3: Next.js에서 캐싱 이해하기\n\n![이미지](/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_3.png)\n\nNext.js의 캐싱 동작은 개발 환경과 프로덕션 환경에서 다릅니다. 개발 모드에서는 기본적으로 페이지가 동적으로 매 요청마다 렌더링됩니다. 그러나 프로덕션 모드에서는 Next.js가 페이지를 정적으로 렌더링하려고 시도합니다.\n\n프로덕션에서 캐싱을 제어하려면 `revalidate` 옵션을 사용하거나 페이지를 명시적으로 `dynamic`으로 표시할 수 있습니다.\n\n\n\n```js\n// 매 5초마다 다시 유효성 검사\nexport const revalidate = 5\n// 동적 렌더링 강제\nexport const dynamic = 'force-dynamic'\n```\n\n# 팁 4: 서버 컴포넌트에서 데이터 가져오기\n\n서버 컴포넌트의 데이터를 가져오기 위해 API 라우트 핸들러를 사용하는 것을 피하십시오. 대신 서버 컴포넌트 내에서 데이터를 직접 가져오세요. 이 방법을 통해 Next.js가 여러 서버 컴포넌트 사이에서 데이터의 캐싱 및 재사용을 최적화할 수 있습니다.\n\n만약 여러 컴포넌트 사이에서 동일한 데이터 가져오기 로직을 재사용해야 한다면, `server/` 디렉토리에 서버 액션을 생성하는 것을 고려해보세요.\n\n\n\n```js\nexport async function getJoke() {\n  const res = await fetch(\"https://api.example.com/joke\");\n  const data = await res.json();\n  if (res.ok) {\n    return { success: true, joke: data.joke };\n  } else {\n    return { error: data.error };\n  }\n}\n// app/page.jsx\nimport { getJoke } from \"../server/actions\";\nexport default async function Page() {\n  const { success, joke, error } = await getJoke();\n  if (success) {\n    return <div>{joke}</div>;\n  } else {\n    throw new Error(error);\n  }\n}\n```\n\n# Tip 5: 클라이언트 및 서버 구성 요소 이해하기\n\n기본적으로 Next.js의 페이지는 서버 구성 요소입니다. 서버 구성 요소 내에서 클라이언트 구성 요소를 렌더링하여 상호작용성을 추가할 수 있습니다.\n\n```js\n\"use client\";\nimport { useState } from \"react\";\nexport default function ClientComponent() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n```\n\n\n\n클라이언트 컴포넌트 내에 렌더링된 자식 컴포넌트는 '사용 클라이언트' 지시문이 필요 없이 자동으로 클라이언트 컴포넌트가 됩니다.\n\n프로바이더(예: 테마 제공자)를 사용할 때는 레이아웃에서 프로바이더로 자식 컴포넌트를 감싸면 자식 컴포넌트는 여전히 서버 컴포넌트로 렌더링됩니다.\n\n```js\n// app/layout.jsx\nimport { ThemeProvider } from \"your-theme-library\";\nexport default function RootLayout({ children }) {\n  return <ThemeProvider>{children}</ThemeProvider>;\n}\n```\n\n# 결론\n\n\n\nNext.js 14은 서버 렌더링된 React 애플리케이션의 개발을 최적화하는 강력하고 기능이 풍부한 프레임워크입니다. 새로운 개념과 규칙이 소개되었지만, 이 블로그 포스트에서 안내된 꿀팁과 요령을 따르면 혼동과 모호함이 발생할 수 있는 부분을 잘 헤쳐나갈 수 있을 거예요.\n\n이미지 사용 방법, 환경 변수 처리, 캐싱 관리, 서버 컴포넌트에서 데이터 가져오기, 그리고 클라이언트 및 서버 컴포넌트 간의 차이 등을 이해하면 Next.js 14로 튼튼하고 효율적인 애플리케이션을 개발하는 데 능숙해질 거예요.\n\n기술을 마스터하는 데 있어서 연습과 경험은 중요합니다. Next.js 문서를 탐험하고 커뮤니티 포럼에 참여하며 프레임워크의 기능을 실험해보면 보다 깊이 있는 이해를 다질 수 있을 거예요.","ogImage":{"url":"/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png"},"coverImage":"/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png\" alt=\"이미지\"></p>\n<p>Next.js 14은 서버 렌더링된 React 애플리케이션을 구축하는 프로세스를 간단화하는 강력한 React 프레임워크입니다. 그러나 고급 기능과 규칙 때문에 특히 이 프레임워크에 처음 접하는 개발자들에게 혼란과 모호함이 있을 수 있습니다. 이 블로그 포스트에서는 Next.js 14를 사용하여 일상을 더 편리하게 만드는 다섯 가지 팁과 요령을 살펴보겠습니다.</p>\n<h2>팁 1: Next.js 이미지 작업</h2>\n<p>Next.js에서 이미지 처리는 혼란스러운 부분입니다. 로컬 이미지 또는 원격 이미지와 작업하는 방법은 다르기 때문입니다.</p>\n<h1>로컬 이미지</h1>\n<p>로컬 이미지를 사용할 때는 너비와 높이를 지정할 필요가 없어요. Next.js가 자동으로 이미지 크기를 확인합니다. 이미지를 가져와 <code>next/image</code> 컴포넌트를 사용해 렌더링하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Image</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/image\"</span>;\n<span class=\"hljs-keyword\">import</span> localImage <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"public/hoy.png\"</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">{localImage}</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"로컬 이미지\"</span> /></span></span>;\n}\n</code></pre>\n<h1>원격 이미지</h1>\n<p><img src=\"/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_2.png\" alt=\"Remote Image\"></p>\n<p>원격 이미지를 사용할 때는 레이아웃 변동을 방지하기 위해 블러 플레이스홀더를 제공하고 너비와 높이를 지정해야 합니다. <code>placeholder=\"blur\"</code> 속성을 사용하여 이미지의 완전한 버전이 로드될 때까지 이미지의 흐린 버전을 표시할 수 있습니다.</p>\n<p>원격 이미지의 블러 데이터 URL을 생성하려면 <code>sharp</code> 및 <code>placeholder</code> 패키지를 사용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Image</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/image\"</span>;\n<span class=\"hljs-keyword\">import</span> getBase64 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./utils/getBase64\"</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> blurDataUrl = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getBase64</span>(remoteImageUrl);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Image</span>\n      <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">{remoteImageUrl}</span>\n      <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{600}</span>\n      <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">{600}</span>\n      <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Remote Image\"</span>\n      <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"blur\"</span>\n      <span class=\"hljs-attr\">blurDataURL</span>=<span class=\"hljs-string\">{blurDataUrl}</span>\n    /></span></span>\n  );\n}\n</code></pre>\n<p><code>getBase64</code> 유틸리티 함수는 원격 이미지를 가져와 ArrayBuffer로 변환한 다음 <code>placeholder</code> 패키지를 사용하여 해당 이미지의 base64 표현을 생성합니다.</p>\n<h1>팁 2: 환경 변수 처리</h1>\n<p>환경 변수를 <code>next.config.env.NEXT_PUBLIC_*</code>로 표시할 때 주의하십시오. 이러한 변수는 브라우저에서 노출되며 JavaScript 번들에 포함됩니다. 민감한 API 키나 비밀 정보가 있는 경우 <code>NEXT_PUBLIC_</code>로 접두사를 붙이지 않도록 주의하십시오. Node.js 환경에서만 사용할 수 있게 됩니다.```</p>\n<h1>팁 3: Next.js에서 캐싱 이해하기</h1>\n<p><img src=\"/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_3.png\" alt=\"이미지\"></p>\n<p>Next.js의 캐싱 동작은 개발 환경과 프로덕션 환경에서 다릅니다. 개발 모드에서는 기본적으로 페이지가 동적으로 매 요청마다 렌더링됩니다. 그러나 프로덕션 모드에서는 Next.js가 페이지를 정적으로 렌더링하려고 시도합니다.</p>\n<p>프로덕션에서 캐싱을 제어하려면 <code>revalidate</code> 옵션을 사용하거나 페이지를 명시적으로 <code>dynamic</code>으로 표시할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 매 5초마다 다시 유효성 검사</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> revalidate = <span class=\"hljs-number\">5</span>\n<span class=\"hljs-comment\">// 동적 렌더링 강제</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> dynamic = <span class=\"hljs-string\">'force-dynamic'</span>\n</code></pre>\n<h1>팁 4: 서버 컴포넌트에서 데이터 가져오기</h1>\n<p>서버 컴포넌트의 데이터를 가져오기 위해 API 라우트 핸들러를 사용하는 것을 피하십시오. 대신 서버 컴포넌트 내에서 데이터를 직접 가져오세요. 이 방법을 통해 Next.js가 여러 서버 컴포넌트 사이에서 데이터의 캐싱 및 재사용을 최적화할 수 있습니다.</p>\n<p>만약 여러 컴포넌트 사이에서 동일한 데이터 가져오기 로직을 재사용해야 한다면, <code>server/</code> 디렉토리에 서버 액션을 생성하는 것을 고려해보세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getJoke</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">\"https://api.example.com/joke\"</span>);\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> res.<span class=\"hljs-title function_\">json</span>();\n  <span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-property\">ok</span>) {\n    <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">joke</span>: data.<span class=\"hljs-property\">joke</span> };\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">error</span>: data.<span class=\"hljs-property\">error</span> };\n  }\n}\n<span class=\"hljs-comment\">// app/page.jsx</span>\n<span class=\"hljs-keyword\">import</span> { getJoke } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../server/actions\"</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Page</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> { success, joke, error } = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getJoke</span>();\n  <span class=\"hljs-keyword\">if</span> (success) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>{joke}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(error);\n  }\n}\n</code></pre>\n<h1>Tip 5: 클라이언트 및 서버 구성 요소 이해하기</h1>\n<p>기본적으로 Next.js의 페이지는 서버 구성 요소입니다. 서버 구성 요소 내에서 클라이언트 구성 요소를 렌더링하여 상호작용성을 추가할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">\"use client\"</span>;\n<span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ClientComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>Count: {count}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> setCount(count + 1)}>Increment<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n</code></pre>\n<p>클라이언트 컴포넌트 내에 렌더링된 자식 컴포넌트는 '사용 클라이언트' 지시문이 필요 없이 자동으로 클라이언트 컴포넌트가 됩니다.</p>\n<p>프로바이더(예: 테마 제공자)를 사용할 때는 레이아웃에서 프로바이더로 자식 컴포넌트를 감싸면 자식 컴포넌트는 여전히 서버 컴포넌트로 렌더링됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// app/layout.jsx</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ThemeProvider</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"your-theme-library\"</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">RootLayout</span>(<span class=\"hljs-params\">{ children }</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ThemeProvider</span>></span>{children}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ThemeProvider</span>></span></span>;\n}\n</code></pre>\n<h1>결론</h1>\n<p>Next.js 14은 서버 렌더링된 React 애플리케이션의 개발을 최적화하는 강력하고 기능이 풍부한 프레임워크입니다. 새로운 개념과 규칙이 소개되었지만, 이 블로그 포스트에서 안내된 꿀팁과 요령을 따르면 혼동과 모호함이 발생할 수 있는 부분을 잘 헤쳐나갈 수 있을 거예요.</p>\n<p>이미지 사용 방법, 환경 변수 처리, 캐싱 관리, 서버 컴포넌트에서 데이터 가져오기, 그리고 클라이언트 및 서버 컴포넌트 간의 차이 등을 이해하면 Next.js 14로 튼튼하고 효율적인 애플리케이션을 개발하는 데 능숙해질 거예요.</p>\n<p>기술을 마스터하는 데 있어서 연습과 경험은 중요합니다. Next.js 문서를 탐험하고 커뮤니티 포럼에 참여하며 프레임워크의 기능을 실험해보면 보다 깊이 있는 이해를 다질 수 있을 거예요.</p>\n</body>\n</html>\n"},"__N_SSG":true}