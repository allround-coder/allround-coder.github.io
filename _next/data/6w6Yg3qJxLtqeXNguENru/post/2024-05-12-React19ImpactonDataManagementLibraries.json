{"pageProps":{"post":{"title":"React 19 데이터 관리 라이브러리에 미치는 영향","description":"","date":"2024-05-12 22:57","slug":"2024-05-12-React19ImpactonDataManagementLibraries","content":"\n\n![이미지](/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png)\n\nReact 19에서는 데이터 처리 방식에 주로 초점을 맞춘 많은 새로운 기능이 도입되었습니다. 네, 이제 React는 효율적인 데이터 가져오기 및 데이터 변경을 처리하기 위한 많은 훅을 제공합니다. 여기에 모두 빠르게 나열해 보겠습니다.\n\n새로운 훅:\n- 많은 향상된 점:\n\n액션 소개:\n\n\n\nReact에서의 액션은 사용자가 UI와 상호작용한 후 수행하려는 모든 것을 의미합니다.\n예: 버튼을 클릭하는 것이 액션입니다. 양식을 제출하는 것도 액션입니다. 그리고 계속 나열됩니다.\n\n이전에는 useEffect, useState, useMemo과 같은 여러 후크를 결합하여 작업을 수행했습니다.\n\n하지만 이제 React에서 직관적인 API를 도입하여 더 이상 보일러플레이트 코드를 해결하기 위해 사용할 필요가 없습니다.\n\n간단한 예로 사용자 세부정보 저장을 살펴봅시다:\n\n\n\n```js\nfunction UpdateUser() {\n    const [status, setStatus] = useState(\"idle\");\n    const saveUser = (userData) => {\n        setStatus(\"saving\");\n        service.saveUser(userData)\n        .then(() => {\n            setStatus(\"idle\");\n            redirect(\"/userdetail\");\n        }).catch(() => {\n            setStatus(\"error\");\n        })\n    }\n\n   return (\n        <>\n            {status == \"saving\" ? \"저장 중....\" : \"\"}\n            <button onClick={() => saveUser()}>사용자 저장</button>\n        </>\n   )\n}\n```\n\nWith action:\n\n```js\nfunction UpdateUser() {\n    const [isPending, startTransition] = useTransition();\n    const [error, setError] = useState();\n    const saveUser = (userData) => {\n        startTransition(async () => {\n            await service.saveUser(userData)\n                .then(() => {\n                   redirect(\"/userdetail\");\n                })\n                .catch(err => {\n                    setError(err);\n                });\n        });\n    }\n\n   return (\n        <>\n            {isPending ? \"저장 중....\" : \"\"}\n            <button onClick={() => saveUser()}>사용자 저장</button>\n        </>\n   )\n}\n```\n\n\n\n동작을 래핑함으로써 React는 두 가지 훅을 도입했습니다: useActionState, useOptimistic.\n\nuseActionState 훅:\n\n이 훅은 데이터 변경 상태를 처리하는 데 사용됩니다. 예를 들어, 서버로 데이터를 보내는 경우 등에 활용됩니다. 예를 들어, 프로필 정보를 업데이트하는 간단한 예시가 여기 있습니다.\n\n```js\nimport { useActionState } from 'react';\n\nexport function MemberForm() {\n  const [error, submitAction, isPending] = useActionState(\n    async (previewState, formData) => {\n      const error = await updateUser(formData).catch(\n          (err) => 'Error ' + previewState\n      );\n      if(!error) {\n        redirect(\"/memberdetail\");\n        return null;\n      }\n      return error;\n    }\n  );\n\n  return (\n    <form id=\"memberForm\" name=\"memberForm\" action={submitAction}>\n      {isPending && <p>업데이트 중...</p>}\n      <fieldset>\n        <label htmlFor=\"firstName\">이름</label>\n        <input id=\"firstName\" name=\"FirstName\" type=\"text\" />\n      </fieldset>\n      <fieldset>\n        <label htmlFor=\"lastName\">성</label>\n        <input id=\"lastName\" name=\"LastName\" type=\"text\" />\n      </fieldset>\n      <!-- 구현 아래에 -->\n      <PhoneNumber />\n      <button type=\"submit\">저장</button>\n      {error && <p>{error} </p>}\n    </form>\n  );\n}\n```\n\n\n\nuseActionState()에 제공된 action 함수는 수행된 작업에 대해 null 또는 오류를 반환해야하고, 폼은 자동으로 재설정됩니다. previewState는 우리가 action에서 반환한 것과 같아집니다.\n\nuseFormStatus 훅:\n\n이 훅을 사용하면 폼 컴포넌트 내에서 폼 제출 상태를 알 수 있습니다.\n\n```js\nfunction PhoneNumber() {\n  const { pending } = useFormStatus();\n  return (\n     <fieldset disabled={pending}>\n       <label htmlFor=\"Phone\">전화번호</label>\n       <input id=\"Phone\" name=\"Phone\" type=\"number\" />\n     </fieldset>\n  )\n}\n```\n\n\n\n`useOptimistic()` 훅:\n\n이 훅은 서버로부터 응답을 기다리는 동안 UI에 낙관적인 업데이트를 수행하는 데 사용됩니다. 예: 좋아요 버튼을 클릭할 때, 우리는 서버가 성공 상태로 응답할 때까지 좋아요 반응을 표시하기를 기다리고 싶지 않습니다. 우리는 즉시 반응을 보여줄 수 있고, 서버에서 응답이 왔을 때, 그것을 로컬 상태에 동기화할 것입니다. 이것이 낙관적인 업데이트라고 불리는 것입니다.\n\n이를 위해 이전에는 API의 상태를 추적하고, API가 실패한 경우 이전 값으로 수동으로 전환해야 했습니다. 이 훅을 사용하면 코드가 더 간단해집니다. 여기 좋아요 버튼의 간단한 예시가 있습니다.\n\n```js\nimport React from 'react';\n\nfunction LikeButton({ count, onClick }) {\n  // 좋아요 카운트에 대한 낙관적 상태 생성.\n  const [optimisticCount, setOptimisticCount] = React.useOptimistic(\n    count,\n    (state, newValue) => {\n      // 여기서 우리는 즉시 상태를 계산합니다.\n      // 이 상태 함수의 반환 값은 즉시 optimisticCount에 설정될 것입니다.\n      console.log('낙관적 콜백 호출', state, newValue);\n      return newValue;\n    }\n  );\n\n  // 좋아요 상태 업데이트를 위한 전환 생성\n  // setOptimisticCount 메서드는 Action 내에서만 호출할 수 있기 때문에\n  // Action은 startTransition() 메서드 내부의 간단한 비동기 함수입니다.\n  const [isPending, startTransition] = React.useTransition();\n\n  const updateCount = () => {\n    startTransition(async () => {\n      // 즉시 카운트 증가\n      setOptimisticCount(optimisticCount + 1);\n      // 값이 부모 구성 요소에 저장될 때까지 대기\n      await onClick(optimisticCount).catch((err) => console.log(err));\n      // 반환될 때까지 이 전환은 보류 상태에 있을 것입니다.\n      return null;\n    });\n  };\n\n  return (\n    <p>\n      <span>\n        {optimisticCount} {count !== optimisticCount ? '업데이트 중...' : ''}\n      </span>\n      <button onClick={updateCount}>좋아요</button>\n    </p>\n  );\n}\n\nexport function ReactionComponent() {\n  const [count, setCount] = React.useState(0);\n  const onClick = () => {\n    return new Promise((resolve, reject) => {\n      // 지연을 모방\n      setTimeout(() => {\n        setCount(count + 1);\n        reject();\n      }, 2000);\n    });\n  };\n  return <LikeButton count={count} onClick={onClick} />;\n}\n```\n\n\n\nAPI를 사용하실 건가요?\n\n컴포넌트 내에서 리소스를 소비하는 데 사용됩니다. 이 리소스는 다음과 같을 수 있어요:\n\n- React Context: 여기에는 사용자 세션을 유지하기 위한 간단한 유틸리티 컴포넌트와 훅이 있습니다.\n\n```js\n import React from 'react';\n\n const UserContext = React.createContext();\n\n export function UserSession({ children }) {\n   const user = React.useMemo(() => ({ id: '001', name: 'user' }), []);\n   return <UserContext.Provider value={user}>{children}</UserContext.Provider>;\n }\n\n export function useUser() {\n   return React.use(UserContext);\n }\n```\n\n\n\n2. Promises: 이 기능을 사용하면 구성 요소 내에서 데이터를 직접로드 할 수 있습니다. 추가적인 보일러플레이트 코드가 필요하지 않습니다. 이 기능을 사용하기 전에 어떻게 했었는지 간단한 예시를 살펴보겠습니다.\n\n이전:\n\n```js\r\n //Before\n function UserDetailComponent({ userId }) {\n     const [user, setUser] = useState(null);\n     useEffect(() => {\n         fetchUser(userId)\n             .then(setUser);\n     }, [userId]);\n }\r\n```\n\n이후: 약속을 구성 요소에 직접 전달하고 사용할 수 있습니다. 'use'를 사용하여 소비합니다.\n\n\n\n```js\n// 이후\nfunction UserDetailComponent({ userPromise }) {\n    const user = use(userPromise);\n}\n\nfunction UserProfileComponent({ userId }) {\n    // 이는 매 렌더링마다 새 promise를 만들지 않았는지 확인하기 위한 것입니다.\n    // 일반적으로 데이터를 가져오는 라이브러리를 사용하여\n    // 리렌더링 간에 동일한 promise를 반환합니다.\n    const userPromise = useMemo(() => {\n        return fetchUser(userId);\n    }, [userId]);\n\n    return (\n        <React.Suspense fallback={\"로딩 중...\"}>\n            <UserDetailComponent userPromise={userPromise} />\n        </React.Suspense>\n    );\n}\n```\n\n개선 사항:\n\n- 컴포넌트 속성으로 ref 사용:\n\n이후에는 새 인자로 선언하는 대신 컴포넌트 속성에서 ref를 가져올 수 있습니다.\n```\n\n\n\n```js\n// 이전\nexport React.forwardRef(function UserDetails(props, ref) => {\n});\n\n// 이후\nexport function UserDetails({ user, ref }) {\n   useImperativeHandle(ref, function () {\n    return {};\n   });\n}\n\n//...\n<UserDetails ref={ref}/>\r\n```\n\n2. ref 콜백이 정리 함수를 반환합니다:\n\n이 향상으로 불필요한 보일러플레이트 코드를 제거할 수 있습니다\n\n```js\n// 이전\nfunction ProfileDetail() {\n    const ref = React.createRef();\n\n    useEffect(() => {\n     const listener = () => {};\n     ref.current.addEventListener(\"keydown\", listener);\n     return () => ref.current.removeEventListener(\"keydown\");\n    }, []);\n\n    return (\n        <input ref={ref}/>\n    )\n}\n\n// 이후\nfunction ProfileDetail() {\n    function inputRef(ref) {\n       const listener = () => {};\n       ref.current.addEventListener(\"keydown\", listener);\n       return () => ref.current.removeEventListener(\"keydown\");\n    }\n\n    return (\n        <input ref={inputRef}/>\n    )\n}\r\n```\n\n\n\n3. 컴포넌트에서의 메타 태그 지원:\n\n이제 클라이언트 컴포넌트 내에서 사용자가 있는 위치에 따라 문서 제목을 변경할 수 있습니다.\n\n```js\n<Router>\n    <Route path=\"/dashboard\" element={Dashboard} />\n    <Route path=\"/profile\" element={Profile} />\n</Router>\n\nfunction Dashboard() {\n    return (\n        <title>판매 대시보드</title>\n    )\n}\n\nfunction Profile() {\n    return (\n        <title>존의 프로필</title>\n    )\n}\n```\n\n# 정말 신경 써야 할까요:\n\n\n\n새로운 기능들과 개선사항을 고려할 때, React Query, SWR과 같은 데이터 관리 라이브러리를 사용하는 사용자라면 React에서 기본적으로 제공하는 이러한 새로운 데이터 관리 옵션에 대해 신경써야 할까요?\n\n내 의견으로는, 이것들은 모두 낮은 수준의 훅들로, 라이브러리 작성자가 코드베이스 내에서 보일러플레이트 코드를 제거하는 데 사용할 수 있습니다. 이미 상기한 데이터 관리 라이브러리를 통해 컴포넌트 수준에서 데이터를 가져오고, 로컬 캐싱과 유효한 무효화와 같은 기능을 활용하고 있기 때문에요.\n\nref, use(Context), 메타 태그와 같은 개선 사항을 활용하여 보일러플레이트 코드를 제거하고 코드베이스를 더 깔끔하게 만들 수 있습니다.\n\n데이터 관리를 위해 네이티브 폼 요소로 전환하는 주요 목적은 점진적인 향상을 선택하는 것입니다. 이 관점에서 코드베이스를 점진적으로 변경하여 앱이 최소한의 JavaScript로 작동하도록 할 수 있습니다.\n\n\n\n여기 샘플 놀이터가 있습니다.\n\n원본 게시물: 2024년 5월 9일, https://yab.hashnode.dev에서 게시됨.","ogImage":{"url":"/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png"},"coverImage":"/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png\" alt=\"이미지\"></p>\n<p>React 19에서는 데이터 처리 방식에 주로 초점을 맞춘 많은 새로운 기능이 도입되었습니다. 네, 이제 React는 효율적인 데이터 가져오기 및 데이터 변경을 처리하기 위한 많은 훅을 제공합니다. 여기에 모두 빠르게 나열해 보겠습니다.</p>\n<p>새로운 훅:</p>\n<ul>\n<li>많은 향상된 점:</li>\n</ul>\n<p>액션 소개:</p>\n<p>React에서의 액션은 사용자가 UI와 상호작용한 후 수행하려는 모든 것을 의미합니다.\n예: 버튼을 클릭하는 것이 액션입니다. 양식을 제출하는 것도 액션입니다. 그리고 계속 나열됩니다.</p>\n<p>이전에는 useEffect, useState, useMemo과 같은 여러 후크를 결합하여 작업을 수행했습니다.</p>\n<p>하지만 이제 React에서 직관적인 API를 도입하여 더 이상 보일러플레이트 코드를 해결하기 위해 사용할 필요가 없습니다.</p>\n<p>간단한 예로 사용자 세부정보 저장을 살펴봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">UpdateUser</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> [status, setStatus] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">\"idle\"</span>);\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">saveUser</span> = (<span class=\"hljs-params\">userData</span>) => {\n        <span class=\"hljs-title function_\">setStatus</span>(<span class=\"hljs-string\">\"saving\"</span>);\n        service.<span class=\"hljs-title function_\">saveUser</span>(userData)\n        .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =></span> {\n            <span class=\"hljs-title function_\">setStatus</span>(<span class=\"hljs-string\">\"idle\"</span>);\n            <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">\"/userdetail\"</span>);\n        }).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">() =></span> {\n            <span class=\"hljs-title function_\">setStatus</span>(<span class=\"hljs-string\">\"error\"</span>);\n        })\n    }\n\n   <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n            {status == \"saving\" ? \"저장 중....\" : \"\"}\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> saveUser()}>사용자 저장<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n        <span class=\"hljs-tag\">&#x3C;/></span></span>\n   )\n}\n</code></pre>\n<p>With action:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">UpdateUser</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> [isPending, startTransition] = <span class=\"hljs-title function_\">useTransition</span>();\n    <span class=\"hljs-keyword\">const</span> [error, setError] = <span class=\"hljs-title function_\">useState</span>();\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">saveUser</span> = (<span class=\"hljs-params\">userData</span>) => {\n        <span class=\"hljs-title function_\">startTransition</span>(<span class=\"hljs-keyword\">async</span> () => {\n            <span class=\"hljs-keyword\">await</span> service.<span class=\"hljs-title function_\">saveUser</span>(userData)\n                .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =></span> {\n                   <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">\"/userdetail\"</span>);\n                })\n                .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> {\n                    <span class=\"hljs-title function_\">setError</span>(err);\n                });\n        });\n    }\n\n   <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n            {isPending ? \"저장 중....\" : \"\"}\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> saveUser()}>사용자 저장<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n        <span class=\"hljs-tag\">&#x3C;/></span></span>\n   )\n}\n</code></pre>\n<p>동작을 래핑함으로써 React는 두 가지 훅을 도입했습니다: useActionState, useOptimistic.</p>\n<p>useActionState 훅:</p>\n<p>이 훅은 데이터 변경 상태를 처리하는 데 사용됩니다. 예를 들어, 서버로 데이터를 보내는 경우 등에 활용됩니다. 예를 들어, 프로필 정보를 업데이트하는 간단한 예시가 여기 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { useActionState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MemberForm</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [error, submitAction, isPending] = <span class=\"hljs-title function_\">useActionState</span>(\n    <span class=\"hljs-keyword\">async</span> (previewState, formData) => {\n      <span class=\"hljs-keyword\">const</span> error = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">updateUser</span>(formData).<span class=\"hljs-title function_\">catch</span>(\n          <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =></span> <span class=\"hljs-string\">'Error '</span> + previewState\n      );\n      <span class=\"hljs-keyword\">if</span>(!error) {\n        <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">\"/memberdetail\"</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n      }\n      <span class=\"hljs-keyword\">return</span> error;\n    }\n  );\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"memberForm\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"memberForm\"</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">{submitAction}</span>></span>\n      {isPending &#x26;&#x26; <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>업데이트 중...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>}\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">fieldset</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">htmlFor</span>=<span class=\"hljs-string\">\"firstName\"</span>></span>이름<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"firstName\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"FirstName\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">fieldset</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">fieldset</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">htmlFor</span>=<span class=\"hljs-string\">\"lastName\"</span>></span>성<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"lastName\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"LastName\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">fieldset</span>></span>\n      <span class=\"hljs-comment\">&#x3C;!-- 구현 아래에 --></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">PhoneNumber</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>></span>저장<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      {error &#x26;&#x26; <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{error} <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">form</span>></span></span>\n  );\n}\n</code></pre>\n<p>useActionState()에 제공된 action 함수는 수행된 작업에 대해 null 또는 오류를 반환해야하고, 폼은 자동으로 재설정됩니다. previewState는 우리가 action에서 반환한 것과 같아집니다.</p>\n<p>useFormStatus 훅:</p>\n<p>이 훅을 사용하면 폼 컴포넌트 내에서 폼 제출 상태를 알 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">PhoneNumber</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> { pending } = <span class=\"hljs-title function_\">useFormStatus</span>();\n  <span class=\"hljs-keyword\">return</span> (\n     <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">fieldset</span> <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{pending}</span>></span>\n       <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">htmlFor</span>=<span class=\"hljs-string\">\"Phone\"</span>></span>전화번호<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n       <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"Phone\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"Phone\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span> /></span>\n     <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">fieldset</span>></span></span>\n  )\n}\n</code></pre>\n<p><code>useOptimistic()</code> 훅:</p>\n<p>이 훅은 서버로부터 응답을 기다리는 동안 UI에 낙관적인 업데이트를 수행하는 데 사용됩니다. 예: 좋아요 버튼을 클릭할 때, 우리는 서버가 성공 상태로 응답할 때까지 좋아요 반응을 표시하기를 기다리고 싶지 않습니다. 우리는 즉시 반응을 보여줄 수 있고, 서버에서 응답이 왔을 때, 그것을 로컬 상태에 동기화할 것입니다. 이것이 낙관적인 업데이트라고 불리는 것입니다.</p>\n<p>이를 위해 이전에는 API의 상태를 추적하고, API가 실패한 경우 이전 값으로 수동으로 전환해야 했습니다. 이 훅을 사용하면 코드가 더 간단해집니다. 여기 좋아요 버튼의 간단한 예시가 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">LikeButton</span>(<span class=\"hljs-params\">{ count, onClick }</span>) {\n  <span class=\"hljs-comment\">// 좋아요 카운트에 대한 낙관적 상태 생성.</span>\n  <span class=\"hljs-keyword\">const</span> [optimisticCount, setOptimisticCount] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useOptimistic</span>(\n    count,\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">state, newValue</span>) =></span> {\n      <span class=\"hljs-comment\">// 여기서 우리는 즉시 상태를 계산합니다.</span>\n      <span class=\"hljs-comment\">// 이 상태 함수의 반환 값은 즉시 optimisticCount에 설정될 것입니다.</span>\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'낙관적 콜백 호출'</span>, state, newValue);\n      <span class=\"hljs-keyword\">return</span> newValue;\n    }\n  );\n\n  <span class=\"hljs-comment\">// 좋아요 상태 업데이트를 위한 전환 생성</span>\n  <span class=\"hljs-comment\">// setOptimisticCount 메서드는 Action 내에서만 호출할 수 있기 때문에</span>\n  <span class=\"hljs-comment\">// Action은 startTransition() 메서드 내부의 간단한 비동기 함수입니다.</span>\n  <span class=\"hljs-keyword\">const</span> [isPending, startTransition] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useTransition</span>();\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">updateCount</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">startTransition</span>(<span class=\"hljs-keyword\">async</span> () => {\n      <span class=\"hljs-comment\">// 즉시 카운트 증가</span>\n      <span class=\"hljs-title function_\">setOptimisticCount</span>(optimisticCount + <span class=\"hljs-number\">1</span>);\n      <span class=\"hljs-comment\">// 값이 부모 구성 요소에 저장될 때까지 대기</span>\n      <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">onClick</span>(optimisticCount).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err));\n      <span class=\"hljs-comment\">// 반환될 때까지 이 전환은 보류 상태에 있을 것입니다.</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n    });\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">span</span>></span>\n        {optimisticCount} {count !== optimisticCount ? '업데이트 중...' : ''}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">span</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{updateCount}</span>></span>좋아요<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ReactionComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onClick</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-comment\">// 지연을 모방</span>\n      <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-title function_\">setCount</span>(count + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-title function_\">reject</span>();\n      }, <span class=\"hljs-number\">2000</span>);\n    });\n  };\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">LikeButton</span> <span class=\"hljs-attr\">count</span>=<span class=\"hljs-string\">{count}</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick}</span> /></span></span>;\n}\n</code></pre>\n<p>API를 사용하실 건가요?</p>\n<p>컴포넌트 내에서 리소스를 소비하는 데 사용됩니다. 이 리소스는 다음과 같을 수 있어요:</p>\n<ul>\n<li>React Context: 여기에는 사용자 세션을 유지하기 위한 간단한 유틸리티 컴포넌트와 훅이 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserContext</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createContext</span>();\n\n <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">UserSession</span>(<span class=\"hljs-params\">{ children }</span>) {\n   <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useMemo</span>(<span class=\"hljs-function\">() =></span> ({ <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'001'</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'user'</span> }), []);\n   <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">UserContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{user}</span>></span>{children}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">UserContext.Provider</span>></span></span>;\n }\n\n <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useUser</span>(<span class=\"hljs-params\"></span>) {\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title class_\">UserContext</span>);\n }\n</code></pre>\n<ol start=\"2\">\n<li>Promises: 이 기능을 사용하면 구성 요소 내에서 데이터를 직접로드 할 수 있습니다. 추가적인 보일러플레이트 코드가 필요하지 않습니다. 이 기능을 사용하기 전에 어떻게 했었는지 간단한 예시를 살펴보겠습니다.</li>\n</ol>\n<p>이전:</p>\n<pre><code class=\"hljs language-js\"> <span class=\"hljs-comment\">//Before</span>\n <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">UserDetailComponent</span>(<span class=\"hljs-params\">{ userId }</span>) {\n     <span class=\"hljs-keyword\">const</span> [user, setUser] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">null</span>);\n     <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n         <span class=\"hljs-title function_\">fetchUser</span>(userId)\n             .<span class=\"hljs-title function_\">then</span>(setUser);\n     }, [userId]);\n }\n</code></pre>\n<p>이후: 약속을 구성 요소에 직접 전달하고 사용할 수 있습니다. 'use'를 사용하여 소비합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이후</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">UserDetailComponent</span>(<span class=\"hljs-params\">{ userPromise }</span>) {\n    <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-title function_\">use</span>(userPromise);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">UserProfileComponent</span>(<span class=\"hljs-params\">{ userId }</span>) {\n    <span class=\"hljs-comment\">// 이는 매 렌더링마다 새 promise를 만들지 않았는지 확인하기 위한 것입니다.</span>\n    <span class=\"hljs-comment\">// 일반적으로 데이터를 가져오는 라이브러리를 사용하여</span>\n    <span class=\"hljs-comment\">// 리렌더링 간에 동일한 promise를 반환합니다.</span>\n    <span class=\"hljs-keyword\">const</span> userPromise = <span class=\"hljs-title function_\">useMemo</span>(<span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fetchUser</span>(userId);\n    }, [userId]);\n\n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">React.Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>\"<span class=\"hljs-attr\">로딩</span> <span class=\"hljs-attr\">중...</span>\"}></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">UserDetailComponent</span> <span class=\"hljs-attr\">userPromise</span>=<span class=\"hljs-string\">{userPromise}</span> /></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">React.Suspense</span>></span></span>\n    );\n}\n</code></pre>\n<p>개선 사항:</p>\n<ul>\n<li>컴포넌트 속성으로 ref 사용:</li>\n</ul>\n<p>이후에는 새 인자로 선언하는 대신 컴포넌트 속성에서 ref를 가져올 수 있습니다.</p>\n<pre><code>\n\n\n```js\n// 이전\nexport React.forwardRef(function UserDetails(props, ref) => {\n});\n\n// 이후\nexport function UserDetails({ user, ref }) {\n   useImperativeHandle(ref, function () {\n    return {};\n   });\n}\n\n//...\n&#x3C;UserDetails ref={ref}/>\n</code></pre>\n<ol start=\"2\">\n<li>ref 콜백이 정리 함수를 반환합니다:</li>\n</ol>\n<p>이 향상으로 불필요한 보일러플레이트 코드를 제거할 수 있습니다</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 이전</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ProfileDetail</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> ref = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createRef</span>();\n\n    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n     <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">listener</span> = (<span class=\"hljs-params\"></span>) => {};\n     ref.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">\"keydown\"</span>, listener);\n     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> ref.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">\"keydown\"</span>);\n    }, []);\n\n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{ref}/</span>></span></span>\n    )\n}\n\n<span class=\"hljs-comment\">// 이후</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ProfileDetail</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inputRef</span>(<span class=\"hljs-params\">ref</span>) {\n       <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">listener</span> = (<span class=\"hljs-params\"></span>) => {};\n       ref.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">\"keydown\"</span>, listener);\n       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> ref.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">\"keydown\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{inputRef}/</span>></span></span>\n    )\n}\n</code></pre>\n<ol start=\"3\">\n<li>컴포넌트에서의 메타 태그 지원:</li>\n</ol>\n<p>이제 클라이언트 컴포넌트 내에서 사용자가 있는 위치에 따라 문서 제목을 변경할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">&#x3C;<span class=\"hljs-title class_\">Router</span>>\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Route</span> <span class=\"hljs-attr\">path</span>=<span class=\"hljs-string\">\"/dashboard\"</span> <span class=\"hljs-attr\">element</span>=<span class=\"hljs-string\">{Dashboard}</span> /></span></span>\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Route</span> <span class=\"hljs-attr\">path</span>=<span class=\"hljs-string\">\"/profile\"</span> <span class=\"hljs-attr\">element</span>=<span class=\"hljs-string\">{Profile}</span> /></span></span>\n&#x3C;/<span class=\"hljs-title class_\">Router</span>>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dashboard</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">title</span>></span>판매 대시보드<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">title</span>></span></span>\n    )\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Profile</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">title</span>></span>존의 프로필<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">title</span>></span></span>\n    )\n}\n</code></pre>\n<h1>정말 신경 써야 할까요:</h1>\n<p>새로운 기능들과 개선사항을 고려할 때, React Query, SWR과 같은 데이터 관리 라이브러리를 사용하는 사용자라면 React에서 기본적으로 제공하는 이러한 새로운 데이터 관리 옵션에 대해 신경써야 할까요?</p>\n<p>내 의견으로는, 이것들은 모두 낮은 수준의 훅들로, 라이브러리 작성자가 코드베이스 내에서 보일러플레이트 코드를 제거하는 데 사용할 수 있습니다. 이미 상기한 데이터 관리 라이브러리를 통해 컴포넌트 수준에서 데이터를 가져오고, 로컬 캐싱과 유효한 무효화와 같은 기능을 활용하고 있기 때문에요.</p>\n<p>ref, use(Context), 메타 태그와 같은 개선 사항을 활용하여 보일러플레이트 코드를 제거하고 코드베이스를 더 깔끔하게 만들 수 있습니다.</p>\n<p>데이터 관리를 위해 네이티브 폼 요소로 전환하는 주요 목적은 점진적인 향상을 선택하는 것입니다. 이 관점에서 코드베이스를 점진적으로 변경하여 앱이 최소한의 JavaScript로 작동하도록 할 수 있습니다.</p>\n<p>여기 샘플 놀이터가 있습니다.</p>\n<p>원본 게시물: 2024년 5월 9일, <a href=\"https://yab.hashnode.dev%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\">https://yab.hashnode.dev에서</a> 게시됨.</p>\n</body>\n</html>\n"},"__N_SSG":true}