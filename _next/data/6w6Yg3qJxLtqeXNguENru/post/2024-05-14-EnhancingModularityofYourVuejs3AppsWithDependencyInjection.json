{"pageProps":{"post":{"title":"Vuejs 3 앱의 모듈화를 개선하는 방법 의존성 주입","description":"","date":"2024-05-14 15:07","slug":"2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection","content":"\n\nVueJS를 사용하면 반응형 컴포넌트, 함수, 라이브러리 및 플러그인을 효율적으로 재사용할 수 있습니다. 이러한 기능들은 VueJS의 한 가지 우아하고 강력한 API 중 하나인 의존성 주입을 활용합니다.\n\n의존성 주입을 통해 부모 컴포넌트에서 후손 컴포넌트로 효율적인 로직 재사용이 가능하며, 프롭 전달에 대한 고민을 없애줍니다. 부모 컴포넌트에서 API로부터 데이터를 가져와 이 데이터를 계층 구조 내의 여러 하위 컴포넌트로 전송해야 하는 시나리오를 고려해 보세요. 이러한 하위 컴포넌트들은 부모로부터 전달된 데이터에 의존하여 정보를 렌더링합니다. 기존에는 모든 하위 컴포넌트에 데이터를 전달했을 것입니다. 데이터가 필요하지 않은 하위 컴포넌트에게까지 말이죠.\n\n이는 특정 컴포넌트로 무관한 데이터의 전달을 포함하는 프롭 드릴링(Prop Drilling)으로 이어질 수 있습니다.\n\n![image](/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png)\n\n\n\n이 접근 방식은 불필요한 구성 요소에 영향을 미치며, 우리가 깊이 파고들수록 유지 보수가 복잡해질 수 있습니다. 이러한 종류의 로직을 다루는 것은 부담스럽고 역생산적일 수 있습니다. 그러나 의존성 주입을 활용하면 이러한 어려움을 완전히 우회할 수 있습니다.\n\nVueJS 3 Composition API에서 의존성 주입을 구현하는 방법을 살펴보겠습니다. 우리는 이를 통해 VueJS 애플리케이션 내에서 모듈성을 보장하기 위해 그것을 활용하는 다양한 방법을 살펴볼 것입니다. 이를 설명하기 위해 샘플 사용 사례를 살펴볼 것입니다.\n\n## 예시\n\nVueJS 앱을 만들어보겠습니다. 가이드를 따라 VueJS 앱을 만들 수 있습니다.\n\n\n\n전제 조건\n\n- 명령줄에 익숙하신 분\n- Node.js 버전 16.0 이상 설치\n\nVue.js를 설정하고 모든 준비가 완료되었다고 가정하고 진행할 수 있습니다.\n\n## 앱 수준 종속성 주입\n\n\n\n앱 레벨 의존성 주입은 주입된 프로바이더를 렌더링된 앱 내 모든 컴포넌트에서 접근할 수 있도록 보장합니다. 주입될 프로바이더는 애플리케이션 상수, 변수, 핸들러 함수 등이 될 수 있습니다. 이러한 프로바이더는 자식이든 부모이든 관계없이 컴포넌트 계층 구조 어디에서든 사용할 수 있습니다.\n\n프로바이더는 두 개의 매개변수를 사용하여 선언됩니다. provide의 첫 번째 매개변수는 provide의 이름을 나타내며 문자열이어야 합니다. 두 번째 매개변수는 값을 정의합니다. 프로바이더가 여러 값을 하나의 프로바이더 이름 아래 캡슐화해야 할 때 객체도 받을 수 있다는 것을 명심하세요.\n\n현재 날짜를 제공하여 프로젝트 내에서 렌더링된 컴포넌트 어디에서나 편리하게 액세스하고 재사용할 수 있게 하려는 시나리오를 고려해보세요.\n\n프로젝트 설정 중 JavaScript 또는 TypeScript를 선택한 경우 main.js 또는 main.ts 파일로 이동하세요.\n\n\n\n위의 코드 스니펫에서는 날짜 변수의 값을 할당한 날짜를 제공합니다.\n\n## 구성 요소에서 제공된 항목에 액세스\n\n애플리케이션의 렌더링된 모든 구성 요소 내에서, 우리는 inject 함수를 활용하고 제공의 이름을 매개변수로 전달하여 날짜에 액세스할 수 있습니다.\n\n## 제공을 통해 도우미 함수 전달하기\n\n\n\n가정해 봅시다. 저희 애플리케이션에서 다양한 컴포넌트에서 제공하고 사용할 수 있는 헬퍼 함수가 있다고 합시다. 핸들러 함수를 가지고 제공으로 전달할 수도 있고 필요할 때마다 이를 액세스할 수 있습니다.\n\n우리의 사용 사례 시나리오를 수정해 봅시다. 우리 애플리케이션의 특정 컴포넌트에서 상대 시간을 표시하려고 합니다. 이를 위해 formatDateTimeWithRelativeTime 함수를 정의할 것입니다. 이 함수는 입력으로 날짜 문자열을 받아 그 날짜의 상대 시간을 현재 날짜 및 시간과 비교하여 결정합니다.\n\n이 함수를 날짜 제공 프로바이더로 제공하여 렌더링된 컴포넌트 내에서 액세스할 수 있도록 할 것입니다.\n\n렌더링된 컴포넌트 내에서 함수에 액세스하고 활용하는 것은 다른 함수와 동일하게 간단합니다. 특히 이 특정 시나리오에서는 아래 코드 스니펫에 표시된 대로 이를 관리할 수 있습니다.\n\n\n\n## 기본값 및 유연성\n\n우리가 제공되는 값이 없을 때 기본값을 제공하고 싶은 경우, 두 번째 매개변수를 제공하여 기본값으로 작용하게 할 수 있습니다. 즉,\n\n```js\n<script setup lang=\"ts\">\nimport { inject } from 'vue';\n\nconst date = inject('dates', \"20230812T144718\");\n\n//'20230812T144718'는 'dates' 제공자가 존재하지 않을 때 기본 날짜입니다.\n\n</script>\n\n<template>\n  <main>\n    <div>\n      <p>의존성 주입</p>\n      <p>날짜는 { date }입니다.</p>\n    </div>\n  </main>\n</template>\n```\n\n## 반응성과 유지보수\n\n\n\n사용자를 대상으로 하는 애플리케이션에서 값 제공을 위해 동적 업데이트가 필요할 수 있습니다. 이를 달성하기 위해서는 반응성이 우리를 이끌어 컴포넌트를 전략적으로 업데이트하고, 최적의 유지보수를 위해 관련 코드를 중앙집중화해야 합니다. 이 방식은 코드 관리를 간소화합니다.\n\nReactive provide/inject 값을 사용할 때 변경 사항을 가능한 한 제공자 내의 반응형 상태로 제한하는 것이 좋습니다. 이 실천은 제공된 상태와 잠재적인 변경 사항이 동일한 컴포넌트에 존재하도록 보장하여, 향후 유지보수를 간소화합니다.\n\n이 안내서에서 사용된 코드는 GitHub에서 찾을 수 있습니다.\n\n## 자원\n\n\n\n- https://vuejs.org/api/composition-api-dependency-injection.html\n- https://vuejs.org/guide/typescript/composition-api.html#typing-provide-inject\n\n## 결론\n\n의존성 주입은 특히 다른 대안들을 사용했을 때 prop 드릴링이 발생할 수 있는 시나리오에서 매우 유용합니다. 이 메커니즘을 통해 애플리케이션 전체에서 접근 가능해야 하는 중요한 기능, 변수 및 상수를 중앙 집중화하고, 중복을 제거하여 한 번만 포함시킴으로써 효율을 높일 수 있습니다.\n\n이 가이드를 따라 주셔서 감사합니다. 다른 사람들과 공유해주시면 감사하겠습니다. 궁금한 사항, 제안 사항이 있거나 단순히 이야기를 나누고 싶다면, X에서 @amjohnphilip과 연락하십시오. 귀하의 참여를 환영합니다!\n\n\n\n## 더 많은 읽을거리\n\n# 쉬운 영어로\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 격려해 주시고 팔로우해 주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾으실 수 있습니다. 🚀\n- 무료 주간 뉴스레터에 가입해 주세요. 🗞️\n- 트위터, 링크드인, 유튜브, 디스코드에서도 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png"},"coverImage":"/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>VueJS를 사용하면 반응형 컴포넌트, 함수, 라이브러리 및 플러그인을 효율적으로 재사용할 수 있습니다. 이러한 기능들은 VueJS의 한 가지 우아하고 강력한 API 중 하나인 의존성 주입을 활용합니다.</p>\n<p>의존성 주입을 통해 부모 컴포넌트에서 후손 컴포넌트로 효율적인 로직 재사용이 가능하며, 프롭 전달에 대한 고민을 없애줍니다. 부모 컴포넌트에서 API로부터 데이터를 가져와 이 데이터를 계층 구조 내의 여러 하위 컴포넌트로 전송해야 하는 시나리오를 고려해 보세요. 이러한 하위 컴포넌트들은 부모로부터 전달된 데이터에 의존하여 정보를 렌더링합니다. 기존에는 모든 하위 컴포넌트에 데이터를 전달했을 것입니다. 데이터가 필요하지 않은 하위 컴포넌트에게까지 말이죠.</p>\n<p>이는 특정 컴포넌트로 무관한 데이터의 전달을 포함하는 프롭 드릴링(Prop Drilling)으로 이어질 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png\" alt=\"image\"></p>\n<p>이 접근 방식은 불필요한 구성 요소에 영향을 미치며, 우리가 깊이 파고들수록 유지 보수가 복잡해질 수 있습니다. 이러한 종류의 로직을 다루는 것은 부담스럽고 역생산적일 수 있습니다. 그러나 의존성 주입을 활용하면 이러한 어려움을 완전히 우회할 수 있습니다.</p>\n<p>VueJS 3 Composition API에서 의존성 주입을 구현하는 방법을 살펴보겠습니다. 우리는 이를 통해 VueJS 애플리케이션 내에서 모듈성을 보장하기 위해 그것을 활용하는 다양한 방법을 살펴볼 것입니다. 이를 설명하기 위해 샘플 사용 사례를 살펴볼 것입니다.</p>\n<h2>예시</h2>\n<p>VueJS 앱을 만들어보겠습니다. 가이드를 따라 VueJS 앱을 만들 수 있습니다.</p>\n<p>전제 조건</p>\n<ul>\n<li>명령줄에 익숙하신 분</li>\n<li>Node.js 버전 16.0 이상 설치</li>\n</ul>\n<p>Vue.js를 설정하고 모든 준비가 완료되었다고 가정하고 진행할 수 있습니다.</p>\n<h2>앱 수준 종속성 주입</h2>\n<p>앱 레벨 의존성 주입은 주입된 프로바이더를 렌더링된 앱 내 모든 컴포넌트에서 접근할 수 있도록 보장합니다. 주입될 프로바이더는 애플리케이션 상수, 변수, 핸들러 함수 등이 될 수 있습니다. 이러한 프로바이더는 자식이든 부모이든 관계없이 컴포넌트 계층 구조 어디에서든 사용할 수 있습니다.</p>\n<p>프로바이더는 두 개의 매개변수를 사용하여 선언됩니다. provide의 첫 번째 매개변수는 provide의 이름을 나타내며 문자열이어야 합니다. 두 번째 매개변수는 값을 정의합니다. 프로바이더가 여러 값을 하나의 프로바이더 이름 아래 캡슐화해야 할 때 객체도 받을 수 있다는 것을 명심하세요.</p>\n<p>현재 날짜를 제공하여 프로젝트 내에서 렌더링된 컴포넌트 어디에서나 편리하게 액세스하고 재사용할 수 있게 하려는 시나리오를 고려해보세요.</p>\n<p>프로젝트 설정 중 JavaScript 또는 TypeScript를 선택한 경우 main.js 또는 main.ts 파일로 이동하세요.</p>\n<p>위의 코드 스니펫에서는 날짜 변수의 값을 할당한 날짜를 제공합니다.</p>\n<h2>구성 요소에서 제공된 항목에 액세스</h2>\n<p>애플리케이션의 렌더링된 모든 구성 요소 내에서, 우리는 inject 함수를 활용하고 제공의 이름을 매개변수로 전달하여 날짜에 액세스할 수 있습니다.</p>\n<h2>제공을 통해 도우미 함수 전달하기</h2>\n<p>가정해 봅시다. 저희 애플리케이션에서 다양한 컴포넌트에서 제공하고 사용할 수 있는 헬퍼 함수가 있다고 합시다. 핸들러 함수를 가지고 제공으로 전달할 수도 있고 필요할 때마다 이를 액세스할 수 있습니다.</p>\n<p>우리의 사용 사례 시나리오를 수정해 봅시다. 우리 애플리케이션의 특정 컴포넌트에서 상대 시간을 표시하려고 합니다. 이를 위해 formatDateTimeWithRelativeTime 함수를 정의할 것입니다. 이 함수는 입력으로 날짜 문자열을 받아 그 날짜의 상대 시간을 현재 날짜 및 시간과 비교하여 결정합니다.</p>\n<p>이 함수를 날짜 제공 프로바이더로 제공하여 렌더링된 컴포넌트 내에서 액세스할 수 있도록 할 것입니다.</p>\n<p>렌더링된 컴포넌트 내에서 함수에 액세스하고 활용하는 것은 다른 함수와 동일하게 간단합니다. 특히 이 특정 시나리오에서는 아래 코드 스니펫에 표시된 대로 이를 관리할 수 있습니다.</p>\n<h2>기본값 및 유연성</h2>\n<p>우리가 제공되는 값이 없을 때 기본값을 제공하고 싶은 경우, 두 번째 매개변수를 제공하여 기본값으로 작용하게 할 수 있습니다. 즉,</p>\n<pre><code class=\"hljs language-js\">&#x3C;script setup lang=<span class=\"hljs-string\">\"ts\"</span>>\n<span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>;\n\n<span class=\"hljs-keyword\">const</span> date = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-string\">'dates'</span>, <span class=\"hljs-string\">\"20230812T144718\"</span>);\n\n<span class=\"hljs-comment\">//'20230812T144718'는 'dates' 제공자가 존재하지 않을 때 기본 날짜입니다.</span>\n\n&#x3C;/script>\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">main</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>의존성 주입<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>날짜는 { date }입니다.<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">main</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span></span>\n</code></pre>\n<h2>반응성과 유지보수</h2>\n<p>사용자를 대상으로 하는 애플리케이션에서 값 제공을 위해 동적 업데이트가 필요할 수 있습니다. 이를 달성하기 위해서는 반응성이 우리를 이끌어 컴포넌트를 전략적으로 업데이트하고, 최적의 유지보수를 위해 관련 코드를 중앙집중화해야 합니다. 이 방식은 코드 관리를 간소화합니다.</p>\n<p>Reactive provide/inject 값을 사용할 때 변경 사항을 가능한 한 제공자 내의 반응형 상태로 제한하는 것이 좋습니다. 이 실천은 제공된 상태와 잠재적인 변경 사항이 동일한 컴포넌트에 존재하도록 보장하여, 향후 유지보수를 간소화합니다.</p>\n<p>이 안내서에서 사용된 코드는 GitHub에서 찾을 수 있습니다.</p>\n<h2>자원</h2>\n<ul>\n<li><a href=\"https://vuejs.org/api/composition-api-dependency-injection.html\" rel=\"nofollow\" target=\"_blank\">https://vuejs.org/api/composition-api-dependency-injection.html</a></li>\n<li><a href=\"https://vuejs.org/guide/typescript/composition-api.html#typing-provide-inject\" rel=\"nofollow\" target=\"_blank\">https://vuejs.org/guide/typescript/composition-api.html#typing-provide-inject</a></li>\n</ul>\n<h2>결론</h2>\n<p>의존성 주입은 특히 다른 대안들을 사용했을 때 prop 드릴링이 발생할 수 있는 시나리오에서 매우 유용합니다. 이 메커니즘을 통해 애플리케이션 전체에서 접근 가능해야 하는 중요한 기능, 변수 및 상수를 중앙 집중화하고, 중복을 제거하여 한 번만 포함시킴으로써 효율을 높일 수 있습니다.</p>\n<p>이 가이드를 따라 주셔서 감사합니다. 다른 사람들과 공유해주시면 감사하겠습니다. 궁금한 사항, 제안 사항이 있거나 단순히 이야기를 나누고 싶다면, X에서 @amjohnphilip과 연락하십시오. 귀하의 참여를 환영합니다!</p>\n<h2>더 많은 읽을거리</h2>\n<h1>쉬운 영어로</h1>\n<p>우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:</p>\n<ul>\n<li>작가를 박수로 격려해 주시고 팔로우해 주세요! 👏</li>\n<li>PlainEnglish.io에서 더 많은 콘텐츠를 찾으실 수 있습니다. 🚀</li>\n<li>무료 주간 뉴스레터에 가입해 주세요. 🗞️</li>\n<li>트위터, 링크드인, 유튜브, 디스코드에서도 팔로우해 주세요.</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}