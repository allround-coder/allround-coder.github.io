{"pageProps":{"post":{"title":"iFrame가 리스너를 제거하고 React는 알지 못한다 ","description":"","date":"2024-05-12 18:44","slug":"2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit","content":"\n\n# 개요\n\n이 기사에서는 부모 창과 자식 iFrame 간에 메시지를 보내는 방법을 보여드리고 싶어요. 이 과정에서 iFrame이 리스너를 어떻게 지우는지에 대해 흥미로운 점을 발견했어요. 걱정하지 마세요, 나아가면서 스크린샷을 게시할 거에요. [GitHub 링크](https://github.com)\n\n즐겁게 공부하세요!\n\n# iFrame이란 무엇인가요?\n\n\n\niFrame 또는 인라인 프레임은 부모 웹페이지 내에 다른 문서를 로드하는 HTML 요소입니다.\n\n# iFrame을 사용하는 곳은 어디인가요?\n\niFrame은 이미 있는 HTML 안에 HTML을 포함시키고 싶을 때나 신뢰할 수 없거나 제3자 스크립트를 백그라운드에서 실행하고 싶을 때 사용합니다. 즉, 광고 섹션을 웹사이트에 표시하거나 YouTube 비디오를 넣고 싶을 때 iFrame을 사용할 수 있습니다. 주로 iFrame을 사용하는 경우는 제3자 사이트/콘텐츠를 호스팅하는 것입니다.\n\n# iFrame 생성하기\n\n\n\n제가 만든 프로젝트는 간단한 React 앱(v18.2.0)입니다. 부모 위젯(App.tsx)은 iFrame 컴포넌트(IFrame.tsx)를 로드합니다. 두 컴포넌트가 마운트될 때 모두 메시지 이벤트를 수신하기 위해 이벤트 리스너를 추가합니다. 이벤트 리스너는 컴포넌트가 마운트 해제될 때 제거됩니다. 부모 컴포넌트는 자바스크립트의 postMessage 함수를 사용하여 iFrame에 메시지를 보냅니다.\n\nApp.tsx\n\n```js\nimport React, { useEffect, useRef } from \"react\";\nimport IFrame from \"./iFrame\";\n\nconst App: React.FC = () => {\n const refs = useRef<HTMLIFrameElement>(null);\n\n useEffect(() => {\n   window.addEventListener(\"message\", processMessage, false);\n   return () => window.removeEventListener(\"message\", processMessage);\n }, []);\n\n\n const processMessage = (event: MessageEvent) => {\n   if (event.origin !== \"http://localhost:8080\") {\n     return;\n   }\n   console.log(\"parent Event Listener\", event);\n };\n\n\n const buttonClick = (event: React.MouseEvent) => {\n   event.stopPropagation();\n   if (refs.current === null) {\n     return;\n   }\n\n   refs?.current?.contentWindow?.postMessage(\"부모에서 보낸 메시지\", \"*\");\n };\n return (\n   <div>\n     <button\n       style={ margin: \"10px\", marginLeft: \"0px\" }\n       onClick={buttonClick}\n     >\n       자식에게 메시지 보내기\n     </button>\n     <IFrame ref={refs} />\n   </div>\n );\n};\n\nexport default App;\n```\n\nIFrame.tsx\n\n\n\n```js\nimport React, { useEffect, useState, forwardRef, ForwardedRef } from \"react\";\n\n\ninterface IFrameProps {\n ref: ForwardedRef<HTMLIFrameElement>;\n}\n\nconst IFrame = forwardRef<HTMLIFrameElement, IFrameProps>((prop, ref) => {\n const [message, setMessage] = useState('');\n const iframeRef = ref as React.MutableRefObject<HTMLIFrameElement>;\n useEffect(() => {\n   console.log(\"mounted\");\n   iframeRef?.current?.contentWindow?.addEventListener(\n     \"message\",\n     processMessage,\n     false\n   );\n   return () => {\n     console.log(\"unmounted\");\n     iframeRef?.current?.contentWindow?.removeEventListener(\n       \"message\",\n       processMessage,\n       false\n     );\n   };\n }, [iframeRef?.current]);\n\n\n const processMessage = (event: MessageEvent) => {\n   console.log(\"iFrame Event Listener\");\n   if (event.origin !== \"http://localhost:8080\") {\n     return;\n   }\n\n\n  const newMessage = message.concat(event?.data)\n  setMessage(newMessage);\n\n\n };\n\n\n return (\n   <div>\n     <iframe id=\"1\" {...prop} ref={ref} srcDoc={message}></iframe>\n   </div>\n );\n});\n\n\nexport default IFrame;\r\n```\n\n리스너가 올바르게 마운트되었는지 확인하기 위해 iFrame에서 getEventListeners(window)을 실행했습니다. iFrame에서 'message' 이벤트를 수신 대기하는 리스너를 확인할 수 있었습니다. 보안 대책으로 악의적인 사용자로부터의 메시지를 무시하도록 origin을 확인해야 합니다.\n\n<img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_0.png\" />\n\n# 화면에서 보이는 모습\n```\n\n\n\n<img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_1.png\" />\n\n버튼을 클릭하면 메시지가 iFrame 안에 나타납니다.\n\n<img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_2.png\" />\n\n이 모든 것이 정말 기뻤어요. 그러나 이곳에서 문제가 발생했습니다. 다시 메시지를 iFrame으로 보내려고 시도했을 때 iFrame UI가 변경되지 않았습니다. iFrame 안에서 \"부모로부터 온 메시지\"를 여러 번 보기를 기대했는데 그런 일은 일어나지 않았습니다. 버튼 클릭 시 UI가 매번 업데이트되지 못했다는 것 같았어요.\n\n\n\n<img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_3.png\" />\n\n내 콘솔 로그를 확인해 보니, 이벤트 리스너를 언마운트한 후에 출력하는 `unmounted`가 아무런 발생하지 않았어. 이것은 React가 버튼 클릭 후 iFrame의 이벤트 리스너를 제대로 언마운트하지 않았음을 확인했어. (재표현)\n\nuseEffect의 의존성 배열을 건드리면서 리스너를 다시 마운트해 보았지만, 모든 시도가 실패했어. 자식에게 메시지를 여러 번 보내도, 자식은 첫 번째 메시지만 듣더라고.\n\n# 그래서 어떻게 하면 제대로 동작시킬 수 있을까?\n\n\n\n더 궁금해져서, 처음 메시지가 도착한 후에 다시 이벤트 리스너를 확인해 봤어요. 여기서 문제를 발견했어요.\n\n![이미지](/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_4.png)\n\n첫 번째 메시지가 도착한 후에 iFrame에는 어떠한 리스너도 연결되어 있지 않았어요. 마치 어떻게든 첫 번째 메시지가 도착한 후에 리스너들이 제거된 것처럼 보였어요.\n\n조금 더 실험해 본 결과, srcDoc 요소에 문제가 있는 것을 발견했어요. 따라서, 상태가 변경될 때 srcDoc 요소가 iFrame의 새 메시지를 가리키게 되었어요. 이 변경으로 인해 iFrame은 iFrame과 관련된 모든 이벤트 리스너를 모두 제거하고 리액트는 아무것도 모르게 되었어요 🫢.\n\n\n\n그래서 React는 iFrame이 그것을 하는지 모릅니다. 왜냐하면 React에게는 iFrame에 대한 참조가 추가/제거되어야 하는데, 참조가 절대 변경되지 않기 때문에 React는 이벤트 리스너를 마운트하거나 언마운트하지 않습니다.\n\n이 문제를 해결하기 위해 iFrame에 정적 HTML을 추가했으며, 메시지가 도착할 때마다 기존 HTML에 추가합니다. 이는 srcDoc가 새 HTML이 아니기 때문에 iFrame에 첨부된 이벤트 리스너를 지우지 않습니다.\n\n```js\nimport React, { useEffect, forwardRef, ForwardedRef } from \"react\";\n\n\ninterface IFrameProps {\n  ref: ForwardedRef<HTMLIFrameElement>;\n}\n\n\nconst html = `<html>\n<body>\n<div id=\"changeText\" value=\"changeText\">Hello Div</div>\n<button value=\"replyButton\" id=\"replyButton\">Reply to parent</button>\n<script>\n// Get the button element\nvar button = document.getElementById(\"replyButton\");\n\n\n// click event listener\nbutton.addEventListener(\"click\", function() {\n  console.log('sending message to parent');\n  window.parent.postMessage('Message from Child. Listen to me!');\n});\n</script>\n</body>\n</html>`;\n\n\nconst IFrame = forwardRef<HTMLIFrameElement, IFrameProps>((prop, ref) => {\n  const iframeRef = ref as React.MutableRefObject<HTMLIFrameElement>;\n  useEffect(() => {\n    console.log(\"mounted\");\n    iframeRef?.current?.contentWindow?.addEventListener(\n      \"message\",\n      processMessage,\n      false\n    );\n    return () => {\n      console.log(\"unmounted\");\n      iframeRef?.current?.contentWindow?.removeEventListener(\n        \"message\",\n        processMessage,\n        false\n      );\n    };\n  }, [iframeRef?.current]);\n\n\n  const processMessage = (event: MessageEvent) => {\n    console.log(\"iFrame Event Listener\");\n    if (event.origin !== \"http://localhost:8080\") {\n      return;\n    }\n\n\n    const node = document.createElement(\"div\");\n    const textNode = document.createTextNode(event?.data);\n    node.appendChild(textNode);\n    iframeRef?.current?.contentWindow?.document.body.appendChild(textNode);\n  };\n\n\n  return (\n    <div>\n      <iframe id=\"1\" {...prop} ref={ref} srcDoc={html}></iframe>\n    </div>\n  );\n});\n\n\nexport default IFrame;\r\n```\n\n# 요약\n\n\n\n- 부모와 자식 간의 간단한 메시지 통신이 작동하지 않는 이유에 대해 공유했어요. iFrame에서 srcDoc 요소를 변경할 경우 작동하지 않아요.\n- 이를 해결하기 위해 iFrame에 HTML을 삽입하고 지속적으로 추가하면 됩니다. 이렇게 하면 iFrame이 이벤트 리스너를 지워 버리는 것을 방지할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_0.png"},"coverImage":"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>개요</h1>\n<p>이 기사에서는 부모 창과 자식 iFrame 간에 메시지를 보내는 방법을 보여드리고 싶어요. 이 과정에서 iFrame이 리스너를 어떻게 지우는지에 대해 흥미로운 점을 발견했어요. 걱정하지 마세요, 나아가면서 스크린샷을 게시할 거에요. <a href=\"https://github.com\" rel=\"nofollow\" target=\"_blank\">GitHub 링크</a></p>\n<p>즐겁게 공부하세요!</p>\n<h1>iFrame이란 무엇인가요?</h1>\n<p>iFrame 또는 인라인 프레임은 부모 웹페이지 내에 다른 문서를 로드하는 HTML 요소입니다.</p>\n<h1>iFrame을 사용하는 곳은 어디인가요?</h1>\n<p>iFrame은 이미 있는 HTML 안에 HTML을 포함시키고 싶을 때나 신뢰할 수 없거나 제3자 스크립트를 백그라운드에서 실행하고 싶을 때 사용합니다. 즉, 광고 섹션을 웹사이트에 표시하거나 YouTube 비디오를 넣고 싶을 때 iFrame을 사용할 수 있습니다. 주로 iFrame을 사용하는 경우는 제3자 사이트/콘텐츠를 호스팅하는 것입니다.</p>\n<h1>iFrame 생성하기</h1>\n<p>제가 만든 프로젝트는 간단한 React 앱(v18.2.0)입니다. 부모 위젯(App.tsx)은 iFrame 컴포넌트(IFrame.tsx)를 로드합니다. 두 컴포넌트가 마운트될 때 모두 메시지 이벤트를 수신하기 위해 이벤트 리스너를 추가합니다. 이벤트 리스너는 컴포넌트가 마운트 해제될 때 제거됩니다. 부모 컴포넌트는 자바스크립트의 postMessage 함수를 사용하여 iFrame에 메시지를 보냅니다.</p>\n<p>App.tsx</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useEffect, useRef } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">IFrame</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./iFrame\"</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">App</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">() =></span> {\n <span class=\"hljs-keyword\">const</span> refs = useRef&#x3C;<span class=\"hljs-title class_\">HTMLIFrameElement</span>>(<span class=\"hljs-literal\">null</span>);\n\n <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n   <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">\"message\"</span>, processMessage, <span class=\"hljs-literal\">false</span>);\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">\"message\"</span>, processMessage);\n }, []);\n\n\n <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">processMessage</span> = (<span class=\"hljs-params\">event: MessageEvent</span>) => {\n   <span class=\"hljs-keyword\">if</span> (event.<span class=\"hljs-property\">origin</span> !== <span class=\"hljs-string\">\"http://localhost:8080\"</span>) {\n     <span class=\"hljs-keyword\">return</span>;\n   }\n   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"parent Event Listener\"</span>, event);\n };\n\n\n <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">buttonClick</span> = (<span class=\"hljs-params\">event: React.MouseEvent</span>) => {\n   event.<span class=\"hljs-title function_\">stopPropagation</span>();\n   <span class=\"hljs-keyword\">if</span> (refs.<span class=\"hljs-property\">current</span> === <span class=\"hljs-literal\">null</span>) {\n     <span class=\"hljs-keyword\">return</span>;\n   }\n\n   refs?.<span class=\"hljs-property\">current</span>?.<span class=\"hljs-property\">contentWindow</span>?.<span class=\"hljs-title function_\">postMessage</span>(<span class=\"hljs-string\">\"부모에서 보낸 메시지\"</span>, <span class=\"hljs-string\">\"*\"</span>);\n };\n <span class=\"hljs-keyword\">return</span> (\n   <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n     <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n       <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{</span> <span class=\"hljs-attr\">margin:</span> \"<span class=\"hljs-attr\">10px</span>\", <span class=\"hljs-attr\">marginLeft:</span> \"<span class=\"hljs-attr\">0px</span>\" }\n       <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{buttonClick}</span>\n     ></span>\n       자식에게 메시지 보내기\n     <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n     <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">IFrame</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{refs}</span> /></span>\n   <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;\n</code></pre>\n<p>IFrame.tsx</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useEffect, useState, forwardRef, <span class=\"hljs-title class_\">ForwardedRef</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\n\ninterface <span class=\"hljs-title class_\">IFrameProps</span> {\n <span class=\"hljs-attr\">ref</span>: <span class=\"hljs-title class_\">ForwardedRef</span>&#x3C;<span class=\"hljs-title class_\">HTMLIFrameElement</span>>;\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">IFrame</span> = forwardRef&#x3C;<span class=\"hljs-title class_\">HTMLIFrameElement</span>, <span class=\"hljs-title class_\">IFrameProps</span>>(<span class=\"hljs-function\">(<span class=\"hljs-params\">prop, ref</span>) =></span> {\n <span class=\"hljs-keyword\">const</span> [message, setMessage] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">''</span>);\n <span class=\"hljs-keyword\">const</span> iframeRef = ref <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">MutableRefObject</span>&#x3C;<span class=\"hljs-title class_\">HTMLIFrameElement</span>>;\n <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"mounted\"</span>);\n   iframeRef?.<span class=\"hljs-property\">current</span>?.<span class=\"hljs-property\">contentWindow</span>?.<span class=\"hljs-title function_\">addEventListener</span>(\n     <span class=\"hljs-string\">\"message\"</span>,\n     processMessage,\n     <span class=\"hljs-literal\">false</span>\n   );\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n     <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"unmounted\"</span>);\n     iframeRef?.<span class=\"hljs-property\">current</span>?.<span class=\"hljs-property\">contentWindow</span>?.<span class=\"hljs-title function_\">removeEventListener</span>(\n       <span class=\"hljs-string\">\"message\"</span>,\n       processMessage,\n       <span class=\"hljs-literal\">false</span>\n     );\n   };\n }, [iframeRef?.<span class=\"hljs-property\">current</span>]);\n\n\n <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">processMessage</span> = (<span class=\"hljs-params\">event: MessageEvent</span>) => {\n   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"iFrame Event Listener\"</span>);\n   <span class=\"hljs-keyword\">if</span> (event.<span class=\"hljs-property\">origin</span> !== <span class=\"hljs-string\">\"http://localhost:8080\"</span>) {\n     <span class=\"hljs-keyword\">return</span>;\n   }\n\n\n  <span class=\"hljs-keyword\">const</span> newMessage = message.<span class=\"hljs-title function_\">concat</span>(event?.<span class=\"hljs-property\">data</span>)\n  <span class=\"hljs-title function_\">setMessage</span>(newMessage);\n\n\n };\n\n\n <span class=\"hljs-keyword\">return</span> (\n   <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n     <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">iframe</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"1\"</span> {<span class=\"hljs-attr\">...prop</span>} <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{ref}</span> <span class=\"hljs-attr\">srcDoc</span>=<span class=\"hljs-string\">{message}</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">iframe</span>></span>\n   <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n );\n});\n\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">IFrame</span>;\n</code></pre>\n<p>리스너가 올바르게 마운트되었는지 확인하기 위해 iFrame에서 getEventListeners(window)을 실행했습니다. iFrame에서 'message' 이벤트를 수신 대기하는 리스너를 확인할 수 있었습니다. 보안 대책으로 악의적인 사용자로부터의 메시지를 무시하도록 origin을 확인해야 합니다.</p>\n<h1>화면에서 보이는 모습</h1>\n<pre><code>\n\n\n&#x3C;img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_1.png\" />\n\n버튼을 클릭하면 메시지가 iFrame 안에 나타납니다.\n\n&#x3C;img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_2.png\" />\n\n이 모든 것이 정말 기뻤어요. 그러나 이곳에서 문제가 발생했습니다. 다시 메시지를 iFrame으로 보내려고 시도했을 때 iFrame UI가 변경되지 않았습니다. iFrame 안에서 \"부모로부터 온 메시지\"를 여러 번 보기를 기대했는데 그런 일은 일어나지 않았습니다. 버튼 클릭 시 UI가 매번 업데이트되지 못했다는 것 같았어요.\n\n\n\n&#x3C;img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_3.png\" />\n\n내 콘솔 로그를 확인해 보니, 이벤트 리스너를 언마운트한 후에 출력하는 `unmounted`가 아무런 발생하지 않았어. 이것은 React가 버튼 클릭 후 iFrame의 이벤트 리스너를 제대로 언마운트하지 않았음을 확인했어. (재표현)\n\nuseEffect의 의존성 배열을 건드리면서 리스너를 다시 마운트해 보았지만, 모든 시도가 실패했어. 자식에게 메시지를 여러 번 보내도, 자식은 첫 번째 메시지만 듣더라고.\n\n# 그래서 어떻게 하면 제대로 동작시킬 수 있을까?\n\n\n\n더 궁금해져서, 처음 메시지가 도착한 후에 다시 이벤트 리스너를 확인해 봤어요. 여기서 문제를 발견했어요.\n\n![이미지](/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_4.png)\n\n첫 번째 메시지가 도착한 후에 iFrame에는 어떠한 리스너도 연결되어 있지 않았어요. 마치 어떻게든 첫 번째 메시지가 도착한 후에 리스너들이 제거된 것처럼 보였어요.\n\n조금 더 실험해 본 결과, srcDoc 요소에 문제가 있는 것을 발견했어요. 따라서, 상태가 변경될 때 srcDoc 요소가 iFrame의 새 메시지를 가리키게 되었어요. 이 변경으로 인해 iFrame은 iFrame과 관련된 모든 이벤트 리스너를 모두 제거하고 리액트는 아무것도 모르게 되었어요 🫢.\n\n\n\n그래서 React는 iFrame이 그것을 하는지 모릅니다. 왜냐하면 React에게는 iFrame에 대한 참조가 추가/제거되어야 하는데, 참조가 절대 변경되지 않기 때문에 React는 이벤트 리스너를 마운트하거나 언마운트하지 않습니다.\n\n이 문제를 해결하기 위해 iFrame에 정적 HTML을 추가했으며, 메시지가 도착할 때마다 기존 HTML에 추가합니다. 이는 srcDoc가 새 HTML이 아니기 때문에 iFrame에 첨부된 이벤트 리스너를 지우지 않습니다.\n\n```js\nimport React, { useEffect, forwardRef, ForwardedRef } from \"react\";\n\n\ninterface IFrameProps {\n  ref: ForwardedRef&#x3C;HTMLIFrameElement>;\n}\n\n\nconst html = `&#x3C;html>\n&#x3C;body>\n&#x3C;div id=\"changeText\" value=\"changeText\">Hello Div&#x3C;/div>\n&#x3C;button value=\"replyButton\" id=\"replyButton\">Reply to parent&#x3C;/button>\n&#x3C;script>\n// Get the button element\nvar button = document.getElementById(\"replyButton\");\n\n\n// click event listener\nbutton.addEventListener(\"click\", function() {\n  console.log('sending message to parent');\n  window.parent.postMessage('Message from Child. Listen to me!');\n});\n&#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>`;\n\n\nconst IFrame = forwardRef&#x3C;HTMLIFrameElement, IFrameProps>((prop, ref) => {\n  const iframeRef = ref as React.MutableRefObject&#x3C;HTMLIFrameElement>;\n  useEffect(() => {\n    console.log(\"mounted\");\n    iframeRef?.current?.contentWindow?.addEventListener(\n      \"message\",\n      processMessage,\n      false\n    );\n    return () => {\n      console.log(\"unmounted\");\n      iframeRef?.current?.contentWindow?.removeEventListener(\n        \"message\",\n        processMessage,\n        false\n      );\n    };\n  }, [iframeRef?.current]);\n\n\n  const processMessage = (event: MessageEvent) => {\n    console.log(\"iFrame Event Listener\");\n    if (event.origin !== \"http://localhost:8080\") {\n      return;\n    }\n\n\n    const node = document.createElement(\"div\");\n    const textNode = document.createTextNode(event?.data);\n    node.appendChild(textNode);\n    iframeRef?.current?.contentWindow?.document.body.appendChild(textNode);\n  };\n\n\n  return (\n    &#x3C;div>\n      &#x3C;iframe id=\"1\" {...prop} ref={ref} srcDoc={html}>&#x3C;/iframe>\n    &#x3C;/div>\n  );\n});\n\n\nexport default IFrame;\n</code></pre>\n<h1>요약</h1>\n<ul>\n<li>부모와 자식 간의 간단한 메시지 통신이 작동하지 않는 이유에 대해 공유했어요. iFrame에서 srcDoc 요소를 변경할 경우 작동하지 않아요.</li>\n<li>이를 해결하기 위해 iFrame에 HTML을 삽입하고 지속적으로 추가하면 됩니다. 이렇게 하면 iFrame이 이벤트 리스너를 지워 버리는 것을 방지할 수 있어요.</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}