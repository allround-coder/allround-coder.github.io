{"pageProps":{"post":{"title":"단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포","description":"","date":"2024-05-12 23:21","slug":"2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker","content":"\n\n모노 레포는 여러 프로젝트를 보관하는 버전 관리 코드 저장소입니다. 이러한 프로젝트들은 서로 관련이 있을 수 있지만 종종 논리적으로 독립적이며 다른 팀에 의해 운영됩니다. 일부 회사는 모든 코드를 모든 사람 사이에서 공유되는 단일 저장소에 호스팅합니다. 모노 레포는 거대한 크기에 도달할 수 있습니다.\n\n저는 이러한 소프트웨어 개발 전략을 매우 매력적으로 생각했습니다. 팀 간의 장벽과 칸막이를 제거하여 함께 잘 작동하는 일련의 마이크로서비스를 설계하고 유지하는 것이 더 쉬워집니다.\n\n![이미지](/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png)\n\n시작하기 전에 여기서 다룰 내용에 대한 기본적인 이해를 갖겠습니다.\n\n\n\n- 표준 프로젝트에서는 프로젝트 전체에서 사용되는 외부 종속성에 의존합니다.\n- 이러한 종속성은 여러 프로젝트가 이를 필요로 할 경우 여러 복사본이 생길 수 있습니다.\n- 여러 패키지가 서로 보완하는 경우 추상화가 최선의 접근 방식이 아닐 수 있습니다.\n- 한 번에 여러 앱을 실행하는 것은 이해관계자들에게 보여주는 즐거움입니다.\n\n이 문서에서는 pnpm 워크스페이스, 프론트엔드에서 React, 백엔드에서 ExpressJS를 사용하여 풀 스택 애플리케이션을 구축할 것입니다:\n\n- pnpm 워크스페이스: 이 프로젝트를 주관하고 클라이언트와 서버에서 필요한 일반적인 도구를 공유합니다.\n- 클라이언트: React 애플리케이션을 실행하는 모든 프론트엔드 코드를 포함합니다.\n- 서버: API 엔드포인트를 노출하는 ExpressJS 서버가 있습니다.\n\n전제 조건:\n\n\n\n- NodeJS: Node.js 설치 방법\n- pnpm: pnpm 설치 방법\n\n## pnpm 워크스페이스\n\n- 루트 폴더에 pnpm 워크스페이스 생성하기\n\n```js\npnpm init\n```\n\n\n\n- 패키지라는 폴더를 만드세요. 여기에는 클라이언트와 서버가 들어갈 거에요.\n\n```js\nmkdir packages\n```\n\n- pnpm-workspace.yaml 파일을 생성하세요. 이를 통해 pnpm이 제 패키지 폴더를 확인할 수 있어요.\n\n```js\ntouch pnpm-workspace.yaml\n```\n\n\n\n- 우리는 pnpm에게 내 패키지가 직장의 일부임을 알려줄 거에요.\n\n```js\n//pnpm-workspace.yaml\npackages:\n  - 'packages/*'\n```\n\n- 루트 디렉토리에 docker-compose.yml 파일을 만들어주세요. 나중에 이에 대해 이야기할 거에요\n\n```js\ntouch docker-compose.yml\n```\n\n\n\n## 클라이언트\n\n- 우리는 Vite를 사용하여 리액트 프로젝트를 설정할 것입니다. 프로젝트 이름은 client로 지정하세요. 이 이름은 pnpm이 이 패키지를 감지하는 방법이기 때문에 중요합니다.\n\n```js\n pnpm create vite\n```\n\n- 클라이언트를 위한 모든 종속성을 설치합니다. pnpm이 루트에 node_modules 폴더를 가지고 있다는 것에 주목하세요. 멋지죠!\n\n\n\n```js\ncd client\npnpm install\npnpm run dev\n```\n\n- 클라이언트용 도커 파일\n\n```js\ntouch Dockerfile\n```\n\n## 서버\n```\n\n\n\n- 여기에 익스프레스 애플리케이션을 설정할 거에요. 그를 위해 패키지 폴더로 이동하여 서버 폴더를 만들어야 해요.\n\n```js\nmkdir server\ncd server\n```\n\n- 서버 폴더 안에 새로운 npm 패키지를 생성할 거에요.\n\n```js\nnpm init\n```\n\n\n\n- 그리고 Express 프레임워크를 설치하세요.\n\n```js\nnpm install express\n```\n\n- 서버용 도커 파일도 만들어주세요.\n\n```js\ntouch Dockerfile\n```\n\n\n\n- 멋져요, 우리 절반 이상을 이미 지났어요! 그리고 이미 풀 스택 앱을 만들었다니 축하해요(조금 더 연결이 필요하지만, 클라이언트에서 서버로) :)\n\n연결이 얼마나 잘 되었는지 확인해봐요!\n\n## 서버 + 클라이언트\n\n- 서버에 index.js 파일을 만들어, 잘 진행 중이라고 말하고 http://localhost:3000에서 제공할 목록이 있어요\n\n\n\n```js\ntouch index.js\n```\n\n```js\n// server/index.js\nconst express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.get(\"/\", (req, res) => {\n  res.json([\n    { name: \"John\", age: 25 },\n    { name: \"Jane\", age: 30 },\n    { name: \"Bob\", age: 35 },\n  ]);\n});\n\napp.listen(PORT, () => {\n  console.log(`I am doing great and serving at ${PORT}`);\n});\n```\n\n- 패키지.json에서 서버를 시작하는 스크립트를 추가하세요.\n\n```js\n\"scripts\": {\n    \"dev\": \"node index.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n},\n```\n\n\n\n- 그리고 물론 실행해 주세요\n\n```js\npnpm run dev\n```\n\n- 이제 클라이언트에서 이 목록을 받습니다. Vite는 이를 사용하여 프론트엔드에서 http://localhost:3000을 자체 URL처럼 사용할 수 있습니다. 귀찮은 CORS 오류도 없어요 :) 이 코드를 vite.config.ts에 추가해 보세요.\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) => path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n\n\n- vite.config.ts 파일에서는 특별한 것이 없어요. localhost와 네트워크의 8080 포트에서 프론트엔드 코드를 실행합니다. 그리고 백엔드 API인 http://localhost:3000을 /api를 호출하여 프록시합니다.\n- 이제 App.ts 파일에서는 /api를 호출하여 http://localhost:3000에서 데이터를 가져옵니다.\n\n```js\nimport { useEffect, useState } from \"react\";\n\nimport \"./App.css\";\n\nfunction App() {\n  const [data, setData] = useState<any>(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      const response = await fetch(\"/api\");\n      const data = await response.json();\n      console.log(data);\n      setData(data);\n    };\n    fetchData();\n  }, []);\n\n  return <>{data && <pre>{JSON.stringify(data, null, 2)}</pre>}</>;\n}\n\nexport default App;\n```\n\n- 목록을 보려면 프론트앱을 시작해주세요.\n\n```js\npnpm run dev\n```\n\n\n\n이제 이 앱은 풀 스택 앱입니다! 그러나 pnpm에서 개발 경험을 향상시키고 이전에 만들었던 Docker 파일을 사용해 봅시다.\n\n개선 사항\n\n- 이제 백엔드와 프론트엔드를 별도로 시작해야 하므로, 워크스페이스 루트에 이를 추가하여 단일 명령으로 실행할 수 있게 합시다. package.json에 다음을 추가하여 pnpm run app을 통해 모두 시작할 수 있도록 하겠습니다!\n\n```js\n\"scripts\": {\n    \"client\": \"pnpm --filter \\\"client\\\" run dev\",\n    \"server\": \"pnpm --filter \\\"server\\\" run dev\",\n    \"app\": \"pnpm run client & pnpm run server\"\n},\n```\n\n\n\n- 클라이언트용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/client\n\n# 클라이언트 package.json 복사\nCOPY package.json .\n\n# 의존성 설치 \nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 8080\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n- 서버용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/server\n\n# 서버 package.json 복사\nCOPY package.json .\n\n# 의존성 설치\nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 3000\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n\n\n- 도커 컴포즈 파일로 이동하기 전에, 클라이언트 폴더의 vite.config.ts 파일에서 약간의 조정을 해보겠어요. 이 조정 내용은 이미지를 만들 때 'server_c'라는 이름의 서버 컨테이너를 사용하므로 기본적으로 로컬호스트가 아닌 http://server_c:3000을 타겟하도록 프론트엔드에 알려주는 것이에요.\n\n```js\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target:\n          process.env.NODE_ENV === \"docker\"\n            ? \"http://server_c:3000\"\n            : \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) => path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n- 루트 디렉토리에 위치한 도커 컴포즈 파일을 사용하여 두 이미지를 만들어봅시다. vite.config.ts 파일에서 제공하는 NODE_ENV=docker 환경을 주의해주세요.\n\n```yaml\nservices:\n  client:\n    build: ./packages/client\n    container_name: client_c\n    ports:\n      - \"8080:8080\"\n    environment:\n      - NODE_ENV=docker\n\n  server:\n    build: ./packages/server\n    container_name: server_c\n    ports:\n      - \"3000:3000\"\n```\n\n\n\n여기서 재밌는 마크다운 표 형식을 사용한 코드가 있어요. 도커 이미지를 빌드하고 도커 환경에서 앱을 시작하려면 docker-compose 파일을 실행해보세요!\n\n```js\ndocker-compose up\n```\n\n더 많은 코드들은 여기에서 확인할 수 있어요. 계속 배우고 있어요.\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 글을 추천하고 작가를 팔로우해 주시는 것을 고려해주세요! 👏\n- 우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠와 싸우는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png"},"coverImage":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>모노 레포는 여러 프로젝트를 보관하는 버전 관리 코드 저장소입니다. 이러한 프로젝트들은 서로 관련이 있을 수 있지만 종종 논리적으로 독립적이며 다른 팀에 의해 운영됩니다. 일부 회사는 모든 코드를 모든 사람 사이에서 공유되는 단일 저장소에 호스팅합니다. 모노 레포는 거대한 크기에 도달할 수 있습니다.</p>\n<p>저는 이러한 소프트웨어 개발 전략을 매우 매력적으로 생각했습니다. 팀 간의 장벽과 칸막이를 제거하여 함께 잘 작동하는 일련의 마이크로서비스를 설계하고 유지하는 것이 더 쉬워집니다.</p>\n<p><img src=\"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png\" alt=\"이미지\"></p>\n<p>시작하기 전에 여기서 다룰 내용에 대한 기본적인 이해를 갖겠습니다.</p>\n<ul>\n<li>표준 프로젝트에서는 프로젝트 전체에서 사용되는 외부 종속성에 의존합니다.</li>\n<li>이러한 종속성은 여러 프로젝트가 이를 필요로 할 경우 여러 복사본이 생길 수 있습니다.</li>\n<li>여러 패키지가 서로 보완하는 경우 추상화가 최선의 접근 방식이 아닐 수 있습니다.</li>\n<li>한 번에 여러 앱을 실행하는 것은 이해관계자들에게 보여주는 즐거움입니다.</li>\n</ul>\n<p>이 문서에서는 pnpm 워크스페이스, 프론트엔드에서 React, 백엔드에서 ExpressJS를 사용하여 풀 스택 애플리케이션을 구축할 것입니다:</p>\n<ul>\n<li>pnpm 워크스페이스: 이 프로젝트를 주관하고 클라이언트와 서버에서 필요한 일반적인 도구를 공유합니다.</li>\n<li>클라이언트: React 애플리케이션을 실행하는 모든 프론트엔드 코드를 포함합니다.</li>\n<li>서버: API 엔드포인트를 노출하는 ExpressJS 서버가 있습니다.</li>\n</ul>\n<p>전제 조건:</p>\n<ul>\n<li>NodeJS: Node.js 설치 방법</li>\n<li>pnpm: pnpm 설치 방법</li>\n</ul>\n<h2>pnpm 워크스페이스</h2>\n<ul>\n<li>루트 폴더에 pnpm 워크스페이스 생성하기</li>\n</ul>\n<pre><code class=\"hljs language-js\">pnpm init\n</code></pre>\n<ul>\n<li>패키지라는 폴더를 만드세요. 여기에는 클라이언트와 서버가 들어갈 거에요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">mkdir packages\n</code></pre>\n<ul>\n<li>pnpm-workspace.yaml 파일을 생성하세요. 이를 통해 pnpm이 제 패키지 폴더를 확인할 수 있어요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">touch pnpm-workspace.<span class=\"hljs-property\">yaml</span>\n</code></pre>\n<ul>\n<li>우리는 pnpm에게 내 패키지가 직장의 일부임을 알려줄 거에요.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//pnpm-workspace.yaml</span>\n<span class=\"hljs-attr\">packages</span>:\n  - <span class=\"hljs-string\">'packages/*'</span>\n</code></pre>\n<ul>\n<li>루트 디렉토리에 docker-compose.yml 파일을 만들어주세요. 나중에 이에 대해 이야기할 거에요</li>\n</ul>\n<pre><code class=\"hljs language-js\">touch docker-compose.<span class=\"hljs-property\">yml</span>\n</code></pre>\n<h2>클라이언트</h2>\n<ul>\n<li>우리는 Vite를 사용하여 리액트 프로젝트를 설정할 것입니다. 프로젝트 이름은 client로 지정하세요. 이 이름은 pnpm이 이 패키지를 감지하는 방법이기 때문에 중요합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"> pnpm create vite\n</code></pre>\n<ul>\n<li>클라이언트를 위한 모든 종속성을 설치합니다. pnpm이 루트에 node_modules 폴더를 가지고 있다는 것에 주목하세요. 멋지죠!</li>\n</ul>\n<pre><code class=\"hljs language-js\">cd client\npnpm install\npnpm run dev\n</code></pre>\n<ul>\n<li>클라이언트용 도커 파일</li>\n</ul>\n<pre><code class=\"hljs language-js\">touch <span class=\"hljs-title class_\">Dockerfile</span>\n</code></pre>\n<h2>서버</h2>\n<pre><code>\n\n\n- 여기에 익스프레스 애플리케이션을 설정할 거에요. 그를 위해 패키지 폴더로 이동하여 서버 폴더를 만들어야 해요.\n\n```js\nmkdir server\ncd server\n</code></pre>\n<ul>\n<li>서버 폴더 안에 새로운 npm 패키지를 생성할 거에요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">npm init\n</code></pre>\n<ul>\n<li>그리고 Express 프레임워크를 설치하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">npm install express\n</code></pre>\n<ul>\n<li>서버용 도커 파일도 만들어주세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">touch <span class=\"hljs-title class_\">Dockerfile</span>\n</code></pre>\n<ul>\n<li>멋져요, 우리 절반 이상을 이미 지났어요! 그리고 이미 풀 스택 앱을 만들었다니 축하해요(조금 더 연결이 필요하지만, 클라이언트에서 서버로) :)</li>\n</ul>\n<p>연결이 얼마나 잘 되었는지 확인해봐요!</p>\n<h2>서버 + 클라이언트</h2>\n<ul>\n<li>서버에 index.js 파일을 만들어, 잘 진행 중이라고 말하고 <a href=\"http://localhost:3000%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\">http://localhost:3000에서</a> 제공할 목록이 있어요</li>\n</ul>\n<pre><code class=\"hljs language-js\">touch index.<span class=\"hljs-property\">js</span>\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// server/index.js</span>\n<span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"express\"</span>);\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PORT</span> = <span class=\"hljs-number\">3000</span>;\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/\"</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =></span> {\n  res.<span class=\"hljs-title function_\">json</span>([\n    { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"John\"</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> },\n    { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Jane\"</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">30</span> },\n    { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Bob\"</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">35</span> },\n  ]);\n});\n\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-variable constant_\">PORT</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`I am doing great and serving at <span class=\"hljs-subst\">${PORT}</span>`</span>);\n});\n</code></pre>\n<ul>\n<li>패키지.json에서 서버를 시작하는 스크립트를 추가하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">\"scripts\"</span>: {\n    <span class=\"hljs-string\">\"dev\"</span>: <span class=\"hljs-string\">\"node index.js\"</span>,\n    <span class=\"hljs-string\">\"test\"</span>: <span class=\"hljs-string\">\"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\"</span>\n},\n</code></pre>\n<ul>\n<li>그리고 물론 실행해 주세요</li>\n</ul>\n<pre><code class=\"hljs language-js\">pnpm run dev\n</code></pre>\n<ul>\n<li>이제 클라이언트에서 이 목록을 받습니다. Vite는 이를 사용하여 프론트엔드에서 <a href=\"http://localhost:3000%EC%9D%84\" rel=\"nofollow\" target=\"_blank\">http://localhost:3000을</a> 자체 URL처럼 사용할 수 있습니다. 귀찮은 CORS 오류도 없어요 :) 이 코드를 vite.config.ts에 추가해 보세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { defineConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"vite\"</span>;\n<span class=\"hljs-keyword\">import</span> react <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@vitejs/plugin-react\"</span>;\n\n<span class=\"hljs-comment\">// https://vitejs.dev/config/</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>({\n  <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-title function_\">react</span>()],\n  <span class=\"hljs-attr\">server</span>: {\n    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">8080</span>,\n    <span class=\"hljs-attr\">strictPort</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">origin</span>: <span class=\"hljs-string\">\"http://0.0.0.0:8080\"</span>,\n    <span class=\"hljs-attr\">proxy</span>: {\n      <span class=\"hljs-string\">\"/api\"</span>: {\n        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">\"http://localhost:3000\"</span>,\n        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">rewrite</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">path: string</span>) =></span> path.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/^\\/api/</span>, <span class=\"hljs-string\">\"\"</span>),\n      },\n    },\n  },\n});\n</code></pre>\n<ul>\n<li>vite.config.ts 파일에서는 특별한 것이 없어요. localhost와 네트워크의 8080 포트에서 프론트엔드 코드를 실행합니다. 그리고 백엔드 API인 <a href=\"http://localhost:3000%EC%9D%84\" rel=\"nofollow\" target=\"_blank\">http://localhost:3000을</a> /api를 호출하여 프록시합니다.</li>\n<li>이제 App.ts 파일에서는 /api를 호출하여 <a href=\"http://localhost:3000%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\">http://localhost:3000에서</a> 데이터를 가져옵니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { useEffect, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"./App.css\"</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [data, setData] = useState&#x3C;any>(<span class=\"hljs-literal\">null</span>);\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchData</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n      <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">\"/api\"</span>);\n      <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n      <span class=\"hljs-title function_\">setData</span>(data);\n    };\n    <span class=\"hljs-title function_\">fetchData</span>();\n  }, []);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>{data &#x26;&#x26; <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">pre</span>></span>{JSON.stringify(data, null, 2)}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">pre</span>></span>}<span class=\"hljs-tag\">&#x3C;/></span></span>;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;\n</code></pre>\n<ul>\n<li>목록을 보려면 프론트앱을 시작해주세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">pnpm run dev\n</code></pre>\n<p>이제 이 앱은 풀 스택 앱입니다! 그러나 pnpm에서 개발 경험을 향상시키고 이전에 만들었던 Docker 파일을 사용해 봅시다.</p>\n<p>개선 사항</p>\n<ul>\n<li>이제 백엔드와 프론트엔드를 별도로 시작해야 하므로, 워크스페이스 루트에 이를 추가하여 단일 명령으로 실행할 수 있게 합시다. package.json에 다음을 추가하여 pnpm run app을 통해 모두 시작할 수 있도록 하겠습니다!</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">\"scripts\"</span>: {\n    <span class=\"hljs-string\">\"client\"</span>: <span class=\"hljs-string\">\"pnpm --filter \\\"client\\\" run dev\"</span>,\n    <span class=\"hljs-string\">\"server\"</span>: <span class=\"hljs-string\">\"pnpm --filter \\\"server\\\" run dev\"</span>,\n    <span class=\"hljs-string\">\"app\"</span>: <span class=\"hljs-string\">\"pnpm run client &#x26; pnpm run server\"</span>\n},\n</code></pre>\n<ul>\n<li>클라이언트용 Dockerfile</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">FROM</span> <span class=\"hljs-attr\">node</span>:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\n<span class=\"hljs-variable constant_\">WORKDIR</span> /app/client\n\n# 클라이언트 package.<span class=\"hljs-property\">json</span> 복사\n<span class=\"hljs-variable constant_\">COPY</span> package.<span class=\"hljs-property\">json</span> .\n\n# 의존성 설치 \n<span class=\"hljs-variable constant_\">RUN</span> npm install\n\n# 코드를 도커 이미지로 모두 복사\n<span class=\"hljs-variable constant_\">COPY</span> .\n\n<span class=\"hljs-variable constant_\">EXPOSE</span> <span class=\"hljs-number\">8080</span>\n\n<span class=\"hljs-variable constant_\">CMD</span> [<span class=\"hljs-string\">\"npm\"</span>,<span class=\"hljs-string\">\"run\"</span>, <span class=\"hljs-string\">\"dev\"</span>]\n</code></pre>\n<ul>\n<li>서버용 Dockerfile</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">FROM</span> <span class=\"hljs-attr\">node</span>:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\n<span class=\"hljs-variable constant_\">WORKDIR</span> /app/server\n\n# 서버 package.<span class=\"hljs-property\">json</span> 복사\n<span class=\"hljs-variable constant_\">COPY</span> package.<span class=\"hljs-property\">json</span> .\n\n# 의존성 설치\n<span class=\"hljs-variable constant_\">RUN</span> npm install\n\n# 코드를 도커 이미지로 모두 복사\n<span class=\"hljs-variable constant_\">COPY</span> .\n\n<span class=\"hljs-variable constant_\">EXPOSE</span> <span class=\"hljs-number\">3000</span>\n\n<span class=\"hljs-variable constant_\">CMD</span> [<span class=\"hljs-string\">\"npm\"</span>,<span class=\"hljs-string\">\"run\"</span>, <span class=\"hljs-string\">\"dev\"</span>]\n</code></pre>\n<ul>\n<li>도커 컴포즈 파일로 이동하기 전에, 클라이언트 폴더의 vite.config.ts 파일에서 약간의 조정을 해보겠어요. 이 조정 내용은 이미지를 만들 때 'server_c'라는 이름의 서버 컨테이너를 사용하므로 기본적으로 로컬호스트가 아닌 http://server_c:3000을 타겟하도록 프론트엔드에 알려주는 것이에요.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>({\n  <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-title function_\">react</span>()],\n  <span class=\"hljs-attr\">server</span>: {\n    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">8080</span>,\n    <span class=\"hljs-attr\">strictPort</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">origin</span>: <span class=\"hljs-string\">\"http://0.0.0.0:8080\"</span>,\n    <span class=\"hljs-attr\">proxy</span>: {\n      <span class=\"hljs-string\">\"/api\"</span>: {\n        <span class=\"hljs-attr\">target</span>:\n          process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">NODE_ENV</span> === <span class=\"hljs-string\">\"docker\"</span>\n            ? <span class=\"hljs-string\">\"http://server_c:3000\"</span>\n            : <span class=\"hljs-string\">\"http://localhost:3000\"</span>,\n        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">rewrite</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">path: string</span>) =></span> path.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/^\\/api/</span>, <span class=\"hljs-string\">\"\"</span>),\n      },\n    },\n  },\n});\n</code></pre>\n<ul>\n<li>루트 디렉토리에 위치한 도커 컴포즈 파일을 사용하여 두 이미지를 만들어봅시다. vite.config.ts 파일에서 제공하는 NODE_ENV=docker 환경을 주의해주세요.</li>\n</ul>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">client:</span>\n    <span class=\"hljs-attr\">build:</span> <span class=\"hljs-string\">./packages/client</span>\n    <span class=\"hljs-attr\">container_name:</span> <span class=\"hljs-string\">client_c</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"8080:8080\"</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">NODE_ENV=docker</span>\n\n  <span class=\"hljs-attr\">server:</span>\n    <span class=\"hljs-attr\">build:</span> <span class=\"hljs-string\">./packages/server</span>\n    <span class=\"hljs-attr\">container_name:</span> <span class=\"hljs-string\">server_c</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"3000:3000\"</span>\n</code></pre>\n<p>여기서 재밌는 마크다운 표 형식을 사용한 코드가 있어요. 도커 이미지를 빌드하고 도커 환경에서 앱을 시작하려면 docker-compose 파일을 실행해보세요!</p>\n<pre><code class=\"hljs language-js\">docker-compose up\n</code></pre>\n<p>더 많은 코드들은 여기에서 확인할 수 있어요. 계속 배우고 있어요.</p>\n<h1>Stackademic 🎓</h1>\n<p>끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:</p>\n<ul>\n<li>글을 추천하고 작가를 팔로우해 주시는 것을 고려해주세요! 👏</li>\n<li>우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord</li>\n<li>다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed</li>\n<li>알고리즘 콘텐츠와 싸우는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요</li>\n<li>Stackademic.com에서 더 많은 콘텐츠를 만나보세요</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}