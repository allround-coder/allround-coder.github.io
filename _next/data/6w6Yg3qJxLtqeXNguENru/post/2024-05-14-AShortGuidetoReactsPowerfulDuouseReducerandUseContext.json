{"pageProps":{"post":{"title":"React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내","description":"","date":"2024-05-14 11:15","slug":"2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext","content":"\n\n<img src=\"/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png\" />\n\nuseReducer과 useContext는 React에서 함께 사용하여 전체 애플리케이션의 상태를 관리하는 강력한 두 가지 훅입니다. useReducer는 복잡한 상태 전환을 더 예측 가능하고 관리하기 쉽게 처리할 수 있는 방법을 제공하며, useContext는 각 레벨을 통해 수동으로 props를 전달하지 않아도 컴포넌트 트리로 데이터를 전달할 수 있도록 해주어 데이터를 전역적으로 사용할 수 있게 합니다.\n\n이 블로그에서는 현재 알고 있는 코드 최적화 방법을 적용할 것입니다.\n\n앱에서 \"context\"라는 폴더를 생성하고 그 폴더 안에 \"IncrementContext\"라는 파일을 생성하세요.\n\n\n\n```js\r\nimport { createContext, useContext, useReducer } from 'react';\n\n// 상태를 보유하는 컨텍스트 생성\nconst IncrementContext = createContext();\n\n// 초기 상태 정의\nconst initialState = {\n  count: 0\n};\n```\n\n\n\n위의 코드 스니펫에서는 세 가지 리액트 훅, createContext, useContext 및 useReducer를 import했습니다.\n\n- CreateContext는 상태를 보유하는 컨텍스트를 생성하는 데 사용됩니다.\n- useContext는 컨텍스트를 호출하는 데 사용됩니다.\n- useReducer는 상태 변수와 기능을 관리하는 데 사용됩니다.\n\n또한 key-value 쌍인 count를 기본 값 0으로 가진 initialState 객체를 선언했습니다.\n\n이 코드를 useReducer 훅에 전달하여 기능을 구축할 것입니다.\n\n\n\n2. 리듀서 함수 작성하기\n\n```js\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\n// 리듀서와 초기 상태(initialState)와 함께 사용할 컴포넌트를 useReducer 훅 안에 선언할 것입니다.\n\n// IncrementProvider 내부에 선언될 것입니다.\nconst [state, dispatch] = useReducer(reducer, initialState);\n```\n\n리듀서 함수는 현재 상태와 액션 객체를 받아들여 액션의 유형 및 페이로드를 기반으로 새 상태를 반환하는 순수 함수입니다. 이는 React 애플리케이션에서 복잡한 상태 로직을 관리하기 위해 useReducer 훅과 함께 사용됩니다. 리듀서 함수는 현재 상태를 직접 수정하는 대신 항상 새 상태 객체를 반환해야 합니다.\n\n제공된 코드 스니펫에서 리듀서 함수는 현재 상태 객체와 형식(type) 속성이 있는 액션 객체를 받아들입니다. 액션 타입에 따라 리듀서는 count 속성이 증가하거나 감소한 새로운 상태 객체를 반환합니다. 액션 유형이 인식되지 않으면, 리듀서는 잘못된 액션이 전송되었음을 나타내기 위해 오류를 throw합니다.\n\n\n\n3. 콘텍스트 프로바이더 작성 및 데이터를 전역적으로 접근 가능하게 만들기\n\n```js\n// 리듀서와 초기 상태에 모두 액세스하려면 useReducer를 사용합니다.\nconst IncrementProvider = (props) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <IncrementContext.Provider value={{ ...state, dispatch }}>\n      {props.children}\n    </IncrementContext.Provider>\n  );\n}\n\n// IncrementProvider를 사용하여 index.js에서 전체 애플리케이션을 래핑합니다.\n// 이렇게 하면 콘텍스트 객체를 전역적으로 액세스할 수 있게 됩니다.\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n  <React.StrictMode>\n    <IncrementProvider>\n      <App />\n    </IncrementProvider>\n  </React.StrictMode>\n);\n```\n\nIncrementProvider는 useReducer를 사용하여 상태를 관리하고 createContext를 사용하여 콘텍스트를 생성하는 사용자 정의 프로바이더 컴포넌트입니다. 프로바이더 컴포넌트는 props를 인수로 받아 자식 컴포넌트를 래핑하는 프로바이더 컴포넌트를 반환합니다.\n\n프로바이더 컴포넌트는 IncrementContext.Provider를 사용하여 상태와 디스패치 함수를 컨텍스트를 통해 자식 컴포넌트에 제공합니다. 이를 위해 IncrementContext.Provider에 값을 전달하여 상태와 디스패치 함수가 포함된 객체를 전달합니다.\n\n\n\n예제 코드에서 IncrementProvider는 index.js 파일에서 App 컴포넌트를 감싸고 있습니다. 이렇게 함으로써 상태와 디스패치 함수를 App 컴포넌트의 모든 하위 컴포넌트에서 사용할 수 있게 됩니다.\n\nIncrementProvider로 전체 애플리케이션을 감싸면 모든 컴포넌트가 상태에 액세스하고 수정을 위한 액션을 디스패치할 수 있도록 보장합니다. 이는 React 애플리케이션에서 컨텍스트와 useReducer 훅을 사용하여 전역 상태를 관리하는 일반적인 패턴입니다.\n\n4. 컴포넌트에서 데이터에 액세스\n\n```js\nimport { useIncrementContext } from 'IncrementContext'\n\nconst MyComponent = () => {\n  // useContext를 사용하여 컨텍스트를 호출할 필요가 없습니다\n  // useIncrementContext 함수를 작성하여 컨텍스트를 호출하였기 때문입니다\n  const { state, dispatch } = useIncrementContext()\n\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n    </div>\n  );\n}\n```\n\n\n\n`useIncrementContext`은 `IncrementContext.Provider`에서 생성된 컨텍스트를 소비하는 데 사용되는 사용자 정의 후크입니다. 이 후크는 `useContext` 후크를 사용하는 보일러플레이트 코드를 추상화하여 컨텍스트 값을 쉽게 액세스할 수 있도록 돕습니다.\n\n예시 코드에서 `useIncrementContext`는 `IncrementContext` 파일에서 가져옵니다. `MyComponent` 컴포넌트는 `useIncrementContext` 후크를 사용하여 컨텍스트에서 상태 및 디스패치 함수에 액세스합니다.\n\n`useIncrementContext` 후크를 사용함으로써 컴포넌트에서 `useContext` 후크를 직접 사용할 필요가 없습니다. 대신 `useIncrementContext` 함수를 호출하여 컨텍스트에서 상태 및 디스패치 함수에 액세스할 수 있습니다.\n\n`MyComponent` 컴포넌트는 상태 객체에서 현재 카운트 값을 보여주는 단락을 렌더링합니다. 또한 클릭할 때 증가 또는 감소 액션을 디스패치하는 두 개의 버튼을 렌더링합니다.\n\n\n\n이 코드 스니펫은 React 컴포넌트에서 컨텍스트 값을 사용하기 위한 사용자 정의 훅을 어떻게 사용하는지 보여줍니다. 컨텍스트를 사용하는 과정을 간단하게 만들어주며 응용 프로그램의 여러 컴포넌트에서 상태와 디스패치 기능에 쉽게 액세스할 수 있습니다.\n\n이 블로그가 도움이 되기를 바라요!\n\nGithub : https://github.com/DevgenX","ogImage":{"url":"/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png"},"coverImage":"/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>useReducer과 useContext는 React에서 함께 사용하여 전체 애플리케이션의 상태를 관리하는 강력한 두 가지 훅입니다. useReducer는 복잡한 상태 전환을 더 예측 가능하고 관리하기 쉽게 처리할 수 있는 방법을 제공하며, useContext는 각 레벨을 통해 수동으로 props를 전달하지 않아도 컴포넌트 트리로 데이터를 전달할 수 있도록 해주어 데이터를 전역적으로 사용할 수 있게 합니다.</p>\n<p>이 블로그에서는 현재 알고 있는 코드 최적화 방법을 적용할 것입니다.</p>\n<p>앱에서 \"context\"라는 폴더를 생성하고 그 폴더 안에 \"IncrementContext\"라는 파일을 생성하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { createContext, useContext, useReducer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-comment\">// 상태를 보유하는 컨텍스트 생성</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">IncrementContext</span> = <span class=\"hljs-title function_\">createContext</span>();\n\n<span class=\"hljs-comment\">// 초기 상태 정의</span>\n<span class=\"hljs-keyword\">const</span> initialState = {\n  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n};\n</code></pre>\n<p>위의 코드 스니펫에서는 세 가지 리액트 훅, createContext, useContext 및 useReducer를 import했습니다.</p>\n<ul>\n<li>CreateContext는 상태를 보유하는 컨텍스트를 생성하는 데 사용됩니다.</li>\n<li>useContext는 컨텍스트를 호출하는 데 사용됩니다.</li>\n<li>useReducer는 상태 변수와 기능을 관리하는 데 사용됩니다.</li>\n</ul>\n<p>또한 key-value 쌍인 count를 기본 값 0으로 가진 initialState 객체를 선언했습니다.</p>\n<p>이 코드를 useReducer 훅에 전달하여 기능을 구축할 것입니다.</p>\n<ol start=\"2\">\n<li>리듀서 함수 작성하기</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">reducer</span> = (<span class=\"hljs-params\">state, action</span>) => {\n  <span class=\"hljs-keyword\">switch</span> (action.<span class=\"hljs-property\">type</span>) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'increment'</span>:\n      <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">count</span>: state.<span class=\"hljs-property\">count</span> + <span class=\"hljs-number\">1</span> };\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'decrement'</span>:\n      <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">count</span>: state.<span class=\"hljs-property\">count</span> - <span class=\"hljs-number\">1</span> };\n    <span class=\"hljs-attr\">default</span>:\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>();\n  }\n}\n\n<span class=\"hljs-comment\">// 리듀서와 초기 상태(initialState)와 함께 사용할 컴포넌트를 useReducer 훅 안에 선언할 것입니다.</span>\n\n<span class=\"hljs-comment\">// IncrementProvider 내부에 선언될 것입니다.</span>\n<span class=\"hljs-keyword\">const</span> [state, dispatch] = <span class=\"hljs-title function_\">useReducer</span>(reducer, initialState);\n</code></pre>\n<p>리듀서 함수는 현재 상태와 액션 객체를 받아들여 액션의 유형 및 페이로드를 기반으로 새 상태를 반환하는 순수 함수입니다. 이는 React 애플리케이션에서 복잡한 상태 로직을 관리하기 위해 useReducer 훅과 함께 사용됩니다. 리듀서 함수는 현재 상태를 직접 수정하는 대신 항상 새 상태 객체를 반환해야 합니다.</p>\n<p>제공된 코드 스니펫에서 리듀서 함수는 현재 상태 객체와 형식(type) 속성이 있는 액션 객체를 받아들입니다. 액션 타입에 따라 리듀서는 count 속성이 증가하거나 감소한 새로운 상태 객체를 반환합니다. 액션 유형이 인식되지 않으면, 리듀서는 잘못된 액션이 전송되었음을 나타내기 위해 오류를 throw합니다.</p>\n<ol start=\"3\">\n<li>콘텍스트 프로바이더 작성 및 데이터를 전역적으로 접근 가능하게 만들기</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 리듀서와 초기 상태에 모두 액세스하려면 useReducer를 사용합니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">IncrementProvider</span> = (<span class=\"hljs-params\">props</span>) => {\n  <span class=\"hljs-keyword\">const</span> [state, dispatch] = <span class=\"hljs-title function_\">useReducer</span>(reducer, initialState);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">IncrementContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">...state</span>, <span class=\"hljs-attr\">dispatch</span> }}></span>\n      {props.children}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">IncrementContext.Provider</span>></span></span>\n  );\n}\n\n<span class=\"hljs-comment\">// IncrementProvider를 사용하여 index.js에서 전체 애플리케이션을 래핑합니다.</span>\n<span class=\"hljs-comment\">// 이렇게 하면 콘텍스트 객체를 전역적으로 액세스할 수 있게 됩니다.</span>\n<span class=\"hljs-keyword\">const</span> root = <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">createRoot</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"root\"</span>));\nroot.<span class=\"hljs-title function_\">render</span>(\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">React.StrictMode</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">IncrementProvider</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">App</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">IncrementProvider</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">React.StrictMode</span>></span></span>\n);\n</code></pre>\n<p>IncrementProvider는 useReducer를 사용하여 상태를 관리하고 createContext를 사용하여 콘텍스트를 생성하는 사용자 정의 프로바이더 컴포넌트입니다. 프로바이더 컴포넌트는 props를 인수로 받아 자식 컴포넌트를 래핑하는 프로바이더 컴포넌트를 반환합니다.</p>\n<p>프로바이더 컴포넌트는 IncrementContext.Provider를 사용하여 상태와 디스패치 함수를 컨텍스트를 통해 자식 컴포넌트에 제공합니다. 이를 위해 IncrementContext.Provider에 값을 전달하여 상태와 디스패치 함수가 포함된 객체를 전달합니다.</p>\n<p>예제 코드에서 IncrementProvider는 index.js 파일에서 App 컴포넌트를 감싸고 있습니다. 이렇게 함으로써 상태와 디스패치 함수를 App 컴포넌트의 모든 하위 컴포넌트에서 사용할 수 있게 됩니다.</p>\n<p>IncrementProvider로 전체 애플리케이션을 감싸면 모든 컴포넌트가 상태에 액세스하고 수정을 위한 액션을 디스패치할 수 있도록 보장합니다. 이는 React 애플리케이션에서 컨텍스트와 useReducer 훅을 사용하여 전역 상태를 관리하는 일반적인 패턴입니다.</p>\n<ol start=\"4\">\n<li>컴포넌트에서 데이터에 액세스</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { useIncrementContext } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'IncrementContext'</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">MyComponent</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-comment\">// useContext를 사용하여 컨텍스트를 호출할 필요가 없습니다</span>\n  <span class=\"hljs-comment\">// useIncrementContext 함수를 작성하여 컨텍스트를 호출하였기 때문입니다</span>\n  <span class=\"hljs-keyword\">const</span> { state, dispatch } = <span class=\"hljs-title function_\">useIncrementContext</span>()\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>Count: {state.count}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> dispatch({ type: 'increment' })}>+<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =></span> dispatch({ type: 'decrement' })}>-<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n</code></pre>\n<p><code>useIncrementContext</code>은 <code>IncrementContext.Provider</code>에서 생성된 컨텍스트를 소비하는 데 사용되는 사용자 정의 후크입니다. 이 후크는 <code>useContext</code> 후크를 사용하는 보일러플레이트 코드를 추상화하여 컨텍스트 값을 쉽게 액세스할 수 있도록 돕습니다.</p>\n<p>예시 코드에서 <code>useIncrementContext</code>는 <code>IncrementContext</code> 파일에서 가져옵니다. <code>MyComponent</code> 컴포넌트는 <code>useIncrementContext</code> 후크를 사용하여 컨텍스트에서 상태 및 디스패치 함수에 액세스합니다.</p>\n<p><code>useIncrementContext</code> 후크를 사용함으로써 컴포넌트에서 <code>useContext</code> 후크를 직접 사용할 필요가 없습니다. 대신 <code>useIncrementContext</code> 함수를 호출하여 컨텍스트에서 상태 및 디스패치 함수에 액세스할 수 있습니다.</p>\n<p><code>MyComponent</code> 컴포넌트는 상태 객체에서 현재 카운트 값을 보여주는 단락을 렌더링합니다. 또한 클릭할 때 증가 또는 감소 액션을 디스패치하는 두 개의 버튼을 렌더링합니다.</p>\n<p>이 코드 스니펫은 React 컴포넌트에서 컨텍스트 값을 사용하기 위한 사용자 정의 훅을 어떻게 사용하는지 보여줍니다. 컨텍스트를 사용하는 과정을 간단하게 만들어주며 응용 프로그램의 여러 컴포넌트에서 상태와 디스패치 기능에 쉽게 액세스할 수 있습니다.</p>\n<p>이 블로그가 도움이 되기를 바라요!</p>\n<p>Github : <a href=\"https://github.com/DevgenX\" rel=\"nofollow\" target=\"_blank\">https://github.com/DevgenX</a></p>\n</body>\n</html>\n"},"__N_SSG":true}