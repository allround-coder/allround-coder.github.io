{"pageProps":{"post":{"title":"코틀린 함수가 일등 시민인 이유","description":"","date":"2024-05-15 10:25","slug":"2024-05-15-KotlinFunctionsasFirstClassCitizens","content":"\n\n코틀린에서 함수 구성 이해하기\n\n![코틀린 함수](/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png)\n\n코틀린에서 함수는 일등 시민으로 취급되어 변수처럼 다룰 수 있습니다. 즉, 함수는 변수에 할당되거나 다른 함수에 매개변수로 전달되거나 함수에서 반환될 수 있습니다.\n\n이를 통해 함수를 다양한 방식으로 결합하여 코드를 간소화하고 함수형 프로그래밍 패러다임을 사용할 수 있습니다.\n\n\n\n자, 우리가 얻을 수 있는 몇 가지 기능들을 살펴봅시다!\n\n## 변수에 값 할당하기 📝\n\n이것에 대한 예시는 다음과 같습니다:\n\n```js\n// 선언\nval foo : () -> Unit = {\n    println(\"안녕 함수!\")\n}\n\n// 사용\nfoo()\n\n// 결과\n안녕 함수!\n```\n\n\n\n참고: 네, 당신은 보통 또는 선언적으로 할 수 있습니다. 여기서는 함수 합성에 대해 이야기하고 있으므로 주석 섹션에서 소리치지 않아도 됩니다.\n\n이 방법의 장점:\n\n- 재사용성\n\n변수에 저장해 두었기 때문에 코드베이스의 여러 곳에서 재사용할 수 있습니다.\n\n\n\n```kotlin\n// 현재 시간 계산\nval currentTime: () -> Unit = {\n    val currentTime = LocalTime.now()\n    val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n    val formattedTime = currentTime.format(formatter)\n    println(\"현재 시간은: $formattedTime\")\n}\n\n// 보통은 호출하여 사용\ncurrentTime()\n\n// 또는 일정 간격으로\n\nsuspend fun repeatInterval(block: () -> Unit, delay: Long) {\n    while (true) {\n        delay(delay)\n        block.invoke()\n    }\n}\n\nfun main(){\n    runBlocking {\n        launch {\n            // 매개변수로 전달하는 사용법\n            repeatInterval(currentTime, 1000)\n        }\n    }\n}\n```\n\n2. 가독성\n\n익명 함수 대신 변수 이름을 전달하여 더 명확하게 만들 수 있습니다. 그렇지 않으면 전체 함수 블록을 읽어야 이해할 수 있습니다. 예시 :\n\n```kotlin\nrepeatInterval({\n  val currentTime = LocalTime.now()\n  val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n  val formattedTime = currentTime.format(formatter)\n  println(\"현재 시간은: $formattedTime\")\n  // 이것을 이해하려면 전체를 읽어야 합니다\n }, 1000)\n\n// 대비\n\nval currentTime: () -> Unit = {\n    val currentTime = LocalTime.now()\n    val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n    val formattedTime = currentTime.format(formatter)\n    println(\"현재 시간은: $formattedTime\")\n}\n\nrepeatInterval(currentTime, 1000)\n```\n\n\n\n## 함수를 인수로 전달할 수 있어요 🔀\n\n가장 흔한 사용 사례는 악명 높은 콜백 함수입니다. 예를 들어,\n\n```js\n// count complete callback\nval countCompleteCallback : () -> Unit = {\n    println(\"카운팅이 완료되었습니다!\")\n}\n\n// 콜백을 인수로 전달\nfun count10(callback:() -> Unit){\n    (1..10).toList().joinToString().also(::println)\n    callback.invoke()\n}\n\n// 트리거\ncount10(countCompleteCallback)\n\n// 결과\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n카운팅이 완료되었습니다!\n```\n\n하지만 우리가 가장 흔히 하는 일은 무엇인지 되돌아보자\n\n\n\n```js\n(1..10).map { it -> it * it }.also(::println)\n```\n\n여기서 map 함수는 구문 설탕을 추가하고 있지만 실제 코드는 다음과 같습니다.\n\n```js\n(1..10).map ({ it -> it * it }).also(::println)\n\n// 또는 \n\nval double = { it -> it * it }\n(1..10).map(double).also(::println)\n```\n\n맵 작업에서는 함수를 매개변수로 전달하고 있습니다. 이 방식은 모듈화되어 있고 집중적이어서 좋은 접근 방식입니다.\n\n\n\n## 다른 함수에서 함수를 반환할 수 있어요 🔙\n\n이것은 많은 사람들에게 이해하기 어려운 내용이지만, 이것을 기반으로 한 가장 유용한 팩토리 함수가 있어요. 예시를 보겠습니다:\n\n```js\nenum class Language {\n    ENGLISH,\n    FRENCH,\n    HINDI\n}\n\nfun greet(language: Language, name: String) {\n    val greetings = when (language) {\n        Language.ENGLISH -> \"Hello, $name!\"\n        Language.FRENCH -> \"Bonjour, $name!\"\n        Language.HINDI -> \"नमस्ते, $name!\"\n    }\n    println(greetings)\n}\n\ngreet(Language.HINDI, \"Chetan\") // नमस्ते, Chetan!\ngreet(Language.ENGLISH, \"Chetan\") // Hello, Chetan!\ngreet(Language.FRENCH, \"Chetan\") // Bonjour, Chetan!\n```\n\n이 프로그램은 언어와 이름을 인수로 사용하여 인사말을 출력합니다. 또는 이렇게도 할 수 있어요:\n\n\n\n```js\nenum class Language {\n    ENGLISH,\n    FRENCH,\n    HINDI\n}\n\nfun greetFactory(language: Language): (String) -> Unit {\n    // function within function\n    val greetTo = { name: String ->\n        val greetings = when(language){\n            Language.ENGLISH -> \"Hello, $name!\"\n            Language.FRENCH -> \"Bonjour, $name!\"\n            Language.HINDI -> \"नमस्ते, $name!\"\n        }\n        println(greetings)\n    }\n\n    // returning function\n    return greetTo\n}\n\n// mini function factories which are reusable\nval englishGreeting = greetFactory(Language.ENGLISH)\nval frenchGreeting = greetFactory(Language.FRENCH)\nval hindiGreeting = greetFactory(Language.HINDI)\n\n// use them separately \nhindiGreeting(\"Chetan\") // नमस्ते, Chetan!\nenglishGreeting(\"Chetan\") // Hello, Chetan!\nfrenchGreeting(\"Chetan\") // Bonjour, Chetan!\n```\n\n추후에 좋아하는 경우에 우리가 다양한 함수 조합 방법을 알고 있다는 것을 걱정하지 마십시오.\n\n## 커링 함수: 부분 실행 🥘\n\n커링 함수 또는 부분 실행 함수는 함수를 반환하는 함수의 부작용입니다. 이를 사용하여 함수의 일부분만 실행할 수 있지만 모두 실행하는 것은 아닙니다. 한 예를 살펴보겠습니다 :```\n\n\n\n```kotlin\n// 두 숫자를 더하는 커링된 함수를 정의했습니다\nfun curriedAdd(firstNumber: Int): (Int) -> Int {\n    val sumWith = { secondNumber: Int ->\n        val sum = firstNumber + secondNumber\n        sum\n    }\n    return sumWith\n}\n\n// 커링을 사용하여 부분적으로 적용된 함수를 생성합니다\nval partialResult = curriedAdd(2) // 이 함수는 첫 번째 인수를 2로 고정합니다\n\n// 이제 addTwo는 인수에 2를 더하는 함수입니다\nval result1 = partialResult(3) \nval result2 = partialResult(10) \n\nprintln(\"Result1: $result1\") // 결과: 2 + 3 = 5\nprintln(\"Result2: $result2\") // 결과: 2 + 10 = 12\n```\n\n여기서 `curriedAdd` 함수는 값 2로 부분 실행되며, 3이 전달될 때 완전 실행되어 결과를 반환합니다. 계산된 값들을 매개변수로 사용하는 경우 뒤에 계산을 완료한 값을로드할 수 있어 매우 편리합니다.\n\n## 클로저 👯\n\n클로저는 외부 함수 범위에 있는 변수에 접근할 수 있도록 내부 함수를 통해 제공합니다. 아래 예제를 참조하세요:\n\n\n\n\n```js\nfun countWithClosure(): () -> Unit {\n    var counter = 0 // 외부 스코프에서 정의된 변수\n    val innerFunction = {\n        counter++ // 외부 스코프의 변수에 접근 및 수정\n        println(\"Counter: $counter\")\n    }\n    return innerFunction\n}\n\nval increment = countWithClosure()\n\nincrement() // 출력: Counter: 1\nincrement() // 출력: Counter: 2\nincrement() // 출력: Counter: 3\n```\n\n기본적으로 두 개의 함수인 외부 함수와 내부 함수가 역할에 관여하며, 내부 함수는 외부 함수 스코프에 접근할 수 있으며 내부 함수 스코프를 사용하여 외부 스코프의 값을 변경할 수 있습니다.\n\nReact에서 매우 인기 있는 기능으로 사용자 정의 후크를 만드는 데 사용되며, Kotlin에서 Jetpack Compose에서도 사용할 수 있습니다.\n\n```js\nval leakyClosure: () -> Unit = {\n    // 여기서 컨텍스트나 다른 Composable에 액세스하면 메모리 누수가 발생할 수 있습니다.\n}\n```\n\n\n\n## 함수는 데이터 구조에 저장될 수 있어요 💾\n\n함수를 컬렉션/데이터 구조에 저장할 수 있어요:\n\n```js\nfun greet() {println(\"hello world!\")}\nfun farewell() {println(\"bye bye world!\")}\n\nval functions : List<()->Unit> = listOf(::greet, ::farewell)\n\n// 리스트를 반복하며 각 함수를 호출해요\nfunctions.onEach { it.invoke() }\n\n// 결과\nhello world!\nbye bye world!\n```\n\n런타임에서 코드 동작을 조작할 수 있어요. 저는 지난 회사에서 실시간 매개 변수 값을 가져와 서버에 기록하기 위해 분석을 구축하는 데 사용했어요. 예를 들어:\n\n\n\n```kotlin\nfun logOnUserClicked () : Map<String,Any> { \n  ...\n  return mapOf(\n    \"이메일\" to datastore.userEmail,\n    \"안드로이드 버전\" to BuildConfig.Version\n  )\n}\n\nfun logOnBackPress () : Map<String,Any> { ...}\n\nval events : List<()->Unit> = listOf(::logOnUserClicked, ::logOnBackPress)\n\nevents.forEach { event ->\n  loggingSdk.log(event())\n}\n```\n\n만약 지금 분석 시스템을 설계하는 방법에 대한 자세한 가이드가 필요하다면, 기사에 댓글을 달아주세요. 다음에 그에 맞는 내용을 만들어 보겠습니다.\n\n함수를 객체에 저장할 수도 있습니다. 예를들어:\n\n```kotlin\ndata class Calculator(\n    val addition: (Int, Int) -> Int = { num1, num2 -> num1 + num2 },\n    val subtraction: (Int, Int) -> Int = { num1, num2 -> num1 - num2 },\n    val multiplication: (Int, Int) -> Int = { num1, num2 -> num1 * num2 },\n)\n\nval calculator = Calculator()\n\nval result1 = calculator.addition(5, 3) // 결과: 8\nval result2 = calculator.subtraction(10, 4) // 결과: 6\nval result3 = calculator.multiplication(6, 2) // 결과: 12\n```\n\n\n\n객체 내에 함수를 저장하면 코드 구조를 더 잘 정의하고 강력하고 다재다능한 프로그래밍 기술을 구현할 수 있습니다.\n\n## 익명 함수 🕵🏽‍♂️\n\n일시적이거나 일회성 함수에 매우 유용합니다. 이름을 부여하지 않은 함수들이기 때문에 당연히 인라인 함수라고도 불립니다 — 그렇지 않았다면 왜 익명인지요?\n\n이미 알고 계신 예시:\n\n\n\n```js\n(1..10).map { it -> it * it }.also(::println) // 결과: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n(1..10).filter { it -> it % 2 == 0 }.also(::println) // 결과: [2, 4, 6, 8, 10]\n```\n\n여기까지입니다. 읽어주셔서 감사합니다!\n\n## - 삶 속에서의 업데이트 -\n\n안녕하세요 👋! 저는 코틀린과 안드로이드 개발에서 7년 이상의 실무 경험을 보유하고 있습니다. 새로운 흥미로운 기회를 찾고 있습니다! 제 포트폴리오와 GitHub 기여를 살펴보시고, 회사에서 경험 많은 안드로이드 개발자가 필요하다면 chetan.garg36@gmail.com으로 연락해주세요. 또한 WhatsApp 번호 +91 8368928213로 연락하거나 LinkedIn에서 저와 연결할 수도 있습니다. 제 전문성을 귀하의 팀에 어떻게 가져다줄 수 있는지 이야기해 보겠습니다!```","ogImage":{"url":"/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png"},"coverImage":"/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>코틀린에서 함수 구성 이해하기</p>\n<p><img src=\"/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png\" alt=\"코틀린 함수\"></p>\n<p>코틀린에서 함수는 일등 시민으로 취급되어 변수처럼 다룰 수 있습니다. 즉, 함수는 변수에 할당되거나 다른 함수에 매개변수로 전달되거나 함수에서 반환될 수 있습니다.</p>\n<p>이를 통해 함수를 다양한 방식으로 결합하여 코드를 간소화하고 함수형 프로그래밍 패러다임을 사용할 수 있습니다.</p>\n<p>자, 우리가 얻을 수 있는 몇 가지 기능들을 살펴봅시다!</p>\n<h2>변수에 값 할당하기 📝</h2>\n<p>이것에 대한 예시는 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 선언</span>\nval foo : () -> <span class=\"hljs-title class_\">Unit</span> = {\n    <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"안녕 함수!\"</span>)\n}\n\n<span class=\"hljs-comment\">// 사용</span>\n<span class=\"hljs-title function_\">foo</span>()\n\n<span class=\"hljs-comment\">// 결과</span>\n안녕 함수!\n</code></pre>\n<p>참고: 네, 당신은 보통 또는 선언적으로 할 수 있습니다. 여기서는 함수 합성에 대해 이야기하고 있으므로 주석 섹션에서 소리치지 않아도 됩니다.</p>\n<p>이 방법의 장점:</p>\n<ul>\n<li>재사용성</li>\n</ul>\n<p>변수에 저장해 두었기 때문에 코드베이스의 여러 곳에서 재사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-comment\">// 현재 시간 계산</span>\n<span class=\"hljs-keyword\">val</span> currentTime: () -> <span class=\"hljs-built_in\">Unit</span> = {\n    <span class=\"hljs-keyword\">val</span> currentTime = LocalTime.now()\n    <span class=\"hljs-keyword\">val</span> formatter = DateTimeFormatter.ofPattern(<span class=\"hljs-string\">\"HH:mm:ss\"</span>)\n    <span class=\"hljs-keyword\">val</span> formattedTime = currentTime.format(formatter)\n    println(<span class=\"hljs-string\">\"현재 시간은: <span class=\"hljs-variable\">$formattedTime</span>\"</span>)\n}\n\n<span class=\"hljs-comment\">// 보통은 호출하여 사용</span>\ncurrentTime()\n\n<span class=\"hljs-comment\">// 또는 일정 간격으로</span>\n\n<span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">repeatInterval</span><span class=\"hljs-params\">(block: () -> <span class=\"hljs-type\">Unit</span>, delay: <span class=\"hljs-type\">Long</span>)</span></span> {\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n        delay(delay)\n        block.invoke()\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>{\n    runBlocking {\n        launch {\n            <span class=\"hljs-comment\">// 매개변수로 전달하는 사용법</span>\n            repeatInterval(currentTime, <span class=\"hljs-number\">1000</span>)\n        }\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li>가독성</li>\n</ol>\n<p>익명 함수 대신 변수 이름을 전달하여 더 명확하게 만들 수 있습니다. 그렇지 않으면 전체 함수 블록을 읽어야 이해할 수 있습니다. 예시 :</p>\n<pre><code class=\"hljs language-kotlin\">repeatInterval({\n  <span class=\"hljs-keyword\">val</span> currentTime = LocalTime.now()\n  <span class=\"hljs-keyword\">val</span> formatter = DateTimeFormatter.ofPattern(<span class=\"hljs-string\">\"HH:mm:ss\"</span>)\n  <span class=\"hljs-keyword\">val</span> formattedTime = currentTime.format(formatter)\n  println(<span class=\"hljs-string\">\"현재 시간은: <span class=\"hljs-variable\">$formattedTime</span>\"</span>)\n  <span class=\"hljs-comment\">// 이것을 이해하려면 전체를 읽어야 합니다</span>\n }, <span class=\"hljs-number\">1000</span>)\n\n<span class=\"hljs-comment\">// 대비</span>\n\n<span class=\"hljs-keyword\">val</span> currentTime: () -> <span class=\"hljs-built_in\">Unit</span> = {\n    <span class=\"hljs-keyword\">val</span> currentTime = LocalTime.now()\n    <span class=\"hljs-keyword\">val</span> formatter = DateTimeFormatter.ofPattern(<span class=\"hljs-string\">\"HH:mm:ss\"</span>)\n    <span class=\"hljs-keyword\">val</span> formattedTime = currentTime.format(formatter)\n    println(<span class=\"hljs-string\">\"현재 시간은: <span class=\"hljs-variable\">$formattedTime</span>\"</span>)\n}\n\nrepeatInterval(currentTime, <span class=\"hljs-number\">1000</span>)\n</code></pre>\n<h2>함수를 인수로 전달할 수 있어요 🔀</h2>\n<p>가장 흔한 사용 사례는 악명 높은 콜백 함수입니다. 예를 들어,</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// count complete callback</span>\nval countCompleteCallback : () -> <span class=\"hljs-title class_\">Unit</span> = {\n    <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"카운팅이 완료되었습니다!\"</span>)\n}\n\n<span class=\"hljs-comment\">// 콜백을 인수로 전달</span>\nfun <span class=\"hljs-title function_\">count10</span>(<span class=\"hljs-params\">callback:() -> Unit</span>){\n    (<span class=\"hljs-number\">1.</span><span class=\"hljs-number\">.10</span>).<span class=\"hljs-title function_\">toList</span>().<span class=\"hljs-title function_\">joinToString</span>().<span class=\"hljs-title function_\">also</span>(::println)\n    callback.<span class=\"hljs-title function_\">invoke</span>()\n}\n\n<span class=\"hljs-comment\">// 트리거</span>\n<span class=\"hljs-title function_\">count10</span>(countCompleteCallback)\n\n<span class=\"hljs-comment\">// 결과</span>\n<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>\n카운팅이 완료되었습니다!\n</code></pre>\n<p>하지만 우리가 가장 흔히 하는 일은 무엇인지 되돌아보자</p>\n<pre><code class=\"hljs language-js\">(<span class=\"hljs-number\">1.</span><span class=\"hljs-number\">.10</span>).<span class=\"hljs-property\">map</span> { it -> it * it }.<span class=\"hljs-title function_\">also</span>(::println)\n</code></pre>\n<p>여기서 map 함수는 구문 설탕을 추가하고 있지만 실제 코드는 다음과 같습니다.</p>\n<pre><code class=\"hljs language-js\">(<span class=\"hljs-number\">1.</span><span class=\"hljs-number\">.10</span>).<span class=\"hljs-property\">map</span> ({ it -> it * it }).<span class=\"hljs-title function_\">also</span>(::println)\n\n<span class=\"hljs-comment\">// 또는 </span>\n\nval double = { it -> it * it }\n(<span class=\"hljs-number\">1.</span><span class=\"hljs-number\">.10</span>).<span class=\"hljs-title function_\">map</span>(double).<span class=\"hljs-title function_\">also</span>(::println)\n</code></pre>\n<p>맵 작업에서는 함수를 매개변수로 전달하고 있습니다. 이 방식은 모듈화되어 있고 집중적이어서 좋은 접근 방식입니다.</p>\n<h2>다른 함수에서 함수를 반환할 수 있어요 🔙</h2>\n<p>이것은 많은 사람들에게 이해하기 어려운 내용이지만, 이것을 기반으로 한 가장 유용한 팩토리 함수가 있어요. 예시를 보겠습니다:</p>\n<pre><code class=\"hljs language-js\">enum <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Language</span> {\n    <span class=\"hljs-variable constant_\">ENGLISH</span>,\n    <span class=\"hljs-variable constant_\">FRENCH</span>,\n    <span class=\"hljs-variable constant_\">HINDI</span>\n}\n\nfun <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\">language: Language, name: <span class=\"hljs-built_in\">String</span></span>) {\n    val greetings = when (language) {\n        <span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">ENGLISH</span> -> <span class=\"hljs-string\">\"Hello, $name!\"</span>\n        <span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">FRENCH</span> -> <span class=\"hljs-string\">\"Bonjour, $name!\"</span>\n        <span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">HINDI</span> -> <span class=\"hljs-string\">\"नमस्ते, $name!\"</span>\n    }\n    <span class=\"hljs-title function_\">println</span>(greetings)\n}\n\n<span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">HINDI</span>, <span class=\"hljs-string\">\"Chetan\"</span>) <span class=\"hljs-comment\">// नमस्ते, Chetan!</span>\n<span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">ENGLISH</span>, <span class=\"hljs-string\">\"Chetan\"</span>) <span class=\"hljs-comment\">// Hello, Chetan!</span>\n<span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">FRENCH</span>, <span class=\"hljs-string\">\"Chetan\"</span>) <span class=\"hljs-comment\">// Bonjour, Chetan!</span>\n</code></pre>\n<p>이 프로그램은 언어와 이름을 인수로 사용하여 인사말을 출력합니다. 또는 이렇게도 할 수 있어요:</p>\n<pre><code class=\"hljs language-js\">enum <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Language</span> {\n    <span class=\"hljs-variable constant_\">ENGLISH</span>,\n    <span class=\"hljs-variable constant_\">FRENCH</span>,\n    <span class=\"hljs-variable constant_\">HINDI</span>\n}\n\nfun <span class=\"hljs-title function_\">greetFactory</span>(<span class=\"hljs-attr\">language</span>: <span class=\"hljs-title class_\">Language</span>): (<span class=\"hljs-title class_\">String</span>) -> <span class=\"hljs-title class_\">Unit</span> {\n    <span class=\"hljs-comment\">// function within function</span>\n    val greetTo = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span> ->\n        val greetings = <span class=\"hljs-title function_\">when</span>(<span class=\"hljs-params\">language</span>){\n            <span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">ENGLISH</span> -> <span class=\"hljs-string\">\"Hello, $name!\"</span>\n            <span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">FRENCH</span> -> <span class=\"hljs-string\">\"Bonjour, $name!\"</span>\n            <span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">HINDI</span> -> <span class=\"hljs-string\">\"नमस्ते, $name!\"</span>\n        }\n        <span class=\"hljs-title function_\">println</span>(greetings)\n    }\n\n    <span class=\"hljs-comment\">// returning function</span>\n    <span class=\"hljs-keyword\">return</span> greetTo\n}\n\n<span class=\"hljs-comment\">// mini function factories which are reusable</span>\nval englishGreeting = <span class=\"hljs-title function_\">greetFactory</span>(<span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">ENGLISH</span>)\nval frenchGreeting = <span class=\"hljs-title function_\">greetFactory</span>(<span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">FRENCH</span>)\nval hindiGreeting = <span class=\"hljs-title function_\">greetFactory</span>(<span class=\"hljs-title class_\">Language</span>.<span class=\"hljs-property\">HINDI</span>)\n\n<span class=\"hljs-comment\">// use them separately </span>\n<span class=\"hljs-title function_\">hindiGreeting</span>(<span class=\"hljs-string\">\"Chetan\"</span>) <span class=\"hljs-comment\">// नमस्ते, Chetan!</span>\n<span class=\"hljs-title function_\">englishGreeting</span>(<span class=\"hljs-string\">\"Chetan\"</span>) <span class=\"hljs-comment\">// Hello, Chetan!</span>\n<span class=\"hljs-title function_\">frenchGreeting</span>(<span class=\"hljs-string\">\"Chetan\"</span>) <span class=\"hljs-comment\">// Bonjour, Chetan!</span>\n</code></pre>\n<p>추후에 좋아하는 경우에 우리가 다양한 함수 조합 방법을 알고 있다는 것을 걱정하지 마십시오.</p>\n<h2>커링 함수: 부분 실행 🥘</h2>\n<p>커링 함수 또는 부분 실행 함수는 함수를 반환하는 함수의 부작용입니다. 이를 사용하여 함수의 일부분만 실행할 수 있지만 모두 실행하는 것은 아닙니다. 한 예를 살펴보겠습니다 :```</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-comment\">// 두 숫자를 더하는 커링된 함수를 정의했습니다</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">curriedAdd</span><span class=\"hljs-params\">(firstNumber: <span class=\"hljs-type\">Int</span>)</span></span>: (<span class=\"hljs-built_in\">Int</span>) -> <span class=\"hljs-built_in\">Int</span> {\n    <span class=\"hljs-keyword\">val</span> sumWith = { secondNumber: <span class=\"hljs-built_in\">Int</span> ->\n        <span class=\"hljs-keyword\">val</span> sum = firstNumber + secondNumber\n        sum\n    }\n    <span class=\"hljs-keyword\">return</span> sumWith\n}\n\n<span class=\"hljs-comment\">// 커링을 사용하여 부분적으로 적용된 함수를 생성합니다</span>\n<span class=\"hljs-keyword\">val</span> partialResult = curriedAdd(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 이 함수는 첫 번째 인수를 2로 고정합니다</span>\n\n<span class=\"hljs-comment\">// 이제 addTwo는 인수에 2를 더하는 함수입니다</span>\n<span class=\"hljs-keyword\">val</span> result1 = partialResult(<span class=\"hljs-number\">3</span>) \n<span class=\"hljs-keyword\">val</span> result2 = partialResult(<span class=\"hljs-number\">10</span>) \n\nprintln(<span class=\"hljs-string\">\"Result1: <span class=\"hljs-variable\">$result1</span>\"</span>) <span class=\"hljs-comment\">// 결과: 2 + 3 = 5</span>\nprintln(<span class=\"hljs-string\">\"Result2: <span class=\"hljs-variable\">$result2</span>\"</span>) <span class=\"hljs-comment\">// 결과: 2 + 10 = 12</span>\n</code></pre>\n<p>여기서 <code>curriedAdd</code> 함수는 값 2로 부분 실행되며, 3이 전달될 때 완전 실행되어 결과를 반환합니다. 계산된 값들을 매개변수로 사용하는 경우 뒤에 계산을 완료한 값을로드할 수 있어 매우 편리합니다.</p>\n<h2>클로저 👯</h2>\n<p>클로저는 외부 함수 범위에 있는 변수에 접근할 수 있도록 내부 함수를 통해 제공합니다. 아래 예제를 참조하세요:</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title function_\">countWithClosure</span>(): () -> <span class=\"hljs-title class_\">Unit</span> {\n    <span class=\"hljs-keyword\">var</span> counter = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// 외부 스코프에서 정의된 변수</span>\n    val innerFunction = {\n        counter++ <span class=\"hljs-comment\">// 외부 스코프의 변수에 접근 및 수정</span>\n        <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"Counter: $counter\"</span>)\n    }\n    <span class=\"hljs-keyword\">return</span> innerFunction\n}\n\nval increment = <span class=\"hljs-title function_\">countWithClosure</span>()\n\n<span class=\"hljs-title function_\">increment</span>() <span class=\"hljs-comment\">// 출력: Counter: 1</span>\n<span class=\"hljs-title function_\">increment</span>() <span class=\"hljs-comment\">// 출력: Counter: 2</span>\n<span class=\"hljs-title function_\">increment</span>() <span class=\"hljs-comment\">// 출력: Counter: 3</span>\n</code></pre>\n<p>기본적으로 두 개의 함수인 외부 함수와 내부 함수가 역할에 관여하며, 내부 함수는 외부 함수 스코프에 접근할 수 있으며 내부 함수 스코프를 사용하여 외부 스코프의 값을 변경할 수 있습니다.</p>\n<p>React에서 매우 인기 있는 기능으로 사용자 정의 후크를 만드는 데 사용되며, Kotlin에서 Jetpack Compose에서도 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">val <span class=\"hljs-attr\">leakyClosure</span>: () -> <span class=\"hljs-title class_\">Unit</span> = {\n    <span class=\"hljs-comment\">// 여기서 컨텍스트나 다른 Composable에 액세스하면 메모리 누수가 발생할 수 있습니다.</span>\n}\n</code></pre>\n<h2>함수는 데이터 구조에 저장될 수 있어요 💾</h2>\n<p>함수를 컬렉션/데이터 구조에 저장할 수 있어요:</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\"></span>) {<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"hello world!\"</span>)}\nfun <span class=\"hljs-title function_\">farewell</span>(<span class=\"hljs-params\"></span>) {<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"bye bye world!\"</span>)}\n\nval functions : <span class=\"hljs-title class_\">List</span>&#x3C;()-><span class=\"hljs-title class_\">Unit</span>> = <span class=\"hljs-title function_\">listOf</span>(::greet, ::farewell)\n\n<span class=\"hljs-comment\">// 리스트를 반복하며 각 함수를 호출해요</span>\nfunctions.<span class=\"hljs-property\">onEach</span> { it.<span class=\"hljs-title function_\">invoke</span>() }\n\n<span class=\"hljs-comment\">// 결과</span>\nhello world!\nbye bye world!\n</code></pre>\n<p>런타임에서 코드 동작을 조작할 수 있어요. 저는 지난 회사에서 실시간 매개 변수 값을 가져와 서버에 기록하기 위해 분석을 구축하는 데 사용했어요. 예를 들어:</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">logOnUserClicked</span> <span class=\"hljs-params\">()</span></span> : Map&#x3C;String,Any> { \n  ...\n  <span class=\"hljs-keyword\">return</span> mapOf(\n    <span class=\"hljs-string\">\"이메일\"</span> to datastore.userEmail,\n    <span class=\"hljs-string\">\"안드로이드 버전\"</span> to BuildConfig.Version\n  )\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">logOnBackPress</span> <span class=\"hljs-params\">()</span></span> : Map&#x3C;String,Any> { ...}\n\n<span class=\"hljs-keyword\">val</span> events : List&#x3C;()-><span class=\"hljs-built_in\">Unit</span>> = listOf(::logOnUserClicked, ::logOnBackPress)\n\nevents.forEach { event ->\n  loggingSdk.log(event())\n}\n</code></pre>\n<p>만약 지금 분석 시스템을 설계하는 방법에 대한 자세한 가이드가 필요하다면, 기사에 댓글을 달아주세요. 다음에 그에 맞는 내용을 만들어 보겠습니다.</p>\n<p>함수를 객체에 저장할 수도 있습니다. 예를들어:</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Calculator</span>(\n    <span class=\"hljs-keyword\">val</span> addition: (<span class=\"hljs-built_in\">Int</span>, <span class=\"hljs-built_in\">Int</span>) -> <span class=\"hljs-built_in\">Int</span> = { num1, num2 -> num1 + num2 },\n    <span class=\"hljs-keyword\">val</span> subtraction: (<span class=\"hljs-built_in\">Int</span>, <span class=\"hljs-built_in\">Int</span>) -> <span class=\"hljs-built_in\">Int</span> = { num1, num2 -> num1 - num2 },\n    <span class=\"hljs-keyword\">val</span> multiplication: (<span class=\"hljs-built_in\">Int</span>, <span class=\"hljs-built_in\">Int</span>) -> <span class=\"hljs-built_in\">Int</span> = { num1, num2 -> num1 * num2 },\n)\n\n<span class=\"hljs-keyword\">val</span> calculator = Calculator()\n\n<span class=\"hljs-keyword\">val</span> result1 = calculator.addition(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// 결과: 8</span>\n<span class=\"hljs-keyword\">val</span> result2 = calculator.subtraction(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 결과: 6</span>\n<span class=\"hljs-keyword\">val</span> result3 = calculator.multiplication(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 결과: 12</span>\n</code></pre>\n<p>객체 내에 함수를 저장하면 코드 구조를 더 잘 정의하고 강력하고 다재다능한 프로그래밍 기술을 구현할 수 있습니다.</p>\n<h2>익명 함수 🕵🏽‍♂️</h2>\n<p>일시적이거나 일회성 함수에 매우 유용합니다. 이름을 부여하지 않은 함수들이기 때문에 당연히 인라인 함수라고도 불립니다 — 그렇지 않았다면 왜 익명인지요?</p>\n<p>이미 알고 계신 예시:</p>\n<pre><code class=\"hljs language-js\">(<span class=\"hljs-number\">1.</span><span class=\"hljs-number\">.10</span>).<span class=\"hljs-property\">map</span> { it -> it * it }.<span class=\"hljs-title function_\">also</span>(::println) <span class=\"hljs-comment\">// 결과: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span>\n(<span class=\"hljs-number\">1.</span><span class=\"hljs-number\">.10</span>).<span class=\"hljs-property\">filter</span> { it -> it % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span> }.<span class=\"hljs-title function_\">also</span>(::println) <span class=\"hljs-comment\">// 결과: [2, 4, 6, 8, 10]</span>\n</code></pre>\n<p>여기까지입니다. 읽어주셔서 감사합니다!</p>\n<h2>- 삶 속에서의 업데이트 -</h2>\n<p>안녕하세요 👋! 저는 코틀린과 안드로이드 개발에서 7년 이상의 실무 경험을 보유하고 있습니다. 새로운 흥미로운 기회를 찾고 있습니다! 제 포트폴리오와 GitHub 기여를 살펴보시고, 회사에서 경험 많은 안드로이드 개발자가 필요하다면 <a href=\"mailto:chetan.garg36@gmail.com\">chetan.garg36@gmail.com</a>으로 연락해주세요. 또한 WhatsApp 번호 +91 8368928213로 연락하거나 LinkedIn에서 저와 연결할 수도 있습니다. 제 전문성을 귀하의 팀에 어떻게 가져다줄 수 있는지 이야기해 보겠습니다!```</p>\n</body>\n</html>\n"},"__N_SSG":true}