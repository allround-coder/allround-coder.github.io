{"pageProps":{"post":{"title":"비동기 작업을 AbortController로 관리하기","description":"","date":"2024-05-15 15:29","slug":"2024-05-15-ManagingasynchronousoperationswithAbortController","content":"\n\n`<img src=\"/assets/img/2024-05-15-ManagingasynchronousoperationswithAbortController_0.png\" />`\n\nAbortController는 특수한 기능입니다. 대부분의 사람들은 Webpack 구성, 파일 I/O 또는 버퍼와 같은 것들과 작업을 하다가 이 매우 유용한 API를 우연히 발견하게 됩니다. 널리 사용되지 않지만 AbortController는 비동기 작업을 취소하는 방법을 제공하여 매우 유용합니다. 당신이 곧 알게 될 것은... 무엇이든지!\n\n하지만 먼저 기초부터 시작해보죠.\n\n# 네트워크 요청\n\n\n\nAbortController의 가장 잘 알려진 사용법은 네트워크 호출을 취소하는 데 사용하는 것입니다. fetch API는 옵션으로 signal 속성을 기본 제공하며, 문법은 다음과 같습니다:\n\n```js\nconst controller = new AbortController();\nconst signal = controller.signal;\n\nawait fetch(url, { signal })\n\n// 요청을 취소하려면 다음을 호출하십시오:\ncontroller.cancel()\n```\n\n웹 응용 프로그램 프레임워크 세계에서는 아래와 같이 사용되는 것을 찾을 수 있습니다 (이 기사 전반에서 코드 예시로 React를 사용합니다):\n\n```js\nuseEffect(() => {\n  const controller = new AbortController();\n  const signal = controller.signal;\n  \n  const fetchData = async () => {\n    try {\n      const res = await fetch(url, { signal })\n      const data = await res.json();\n\n      setState(data);\n    } catch (err) {\n      // 에러 처리\n    }\n  }\n  \n  void fetchData();\n  \n  return () => {\n    controller.abort()\n  }\n}, []);\n```\n\n\n이것은 당신의 컴포넌트가 unmounted(해제된) 될 때 API를 계속해서 가져오지 않고 상태를 설정하지 않도록 보장하기 위해 필요합니다.\n\n# 타이머\n\n일반적인 sleep 함수는 아래와 같이 보입니다:\n\n```js\nconst sleep = async (ms: number) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n```\n\n\n\n좋은 작업이 잘 되었지만 이렇게 되면 콜백을 취소할 수 없어요. 이 문제를 해결해 봐요:\n\n```js\nconst sleep = async (ms: number, timeoutId: NodeJS.Timeout) => {\n  return new Promise((resolve) => {\n    timeoutId = setTimeout(resolve, ms);\n  });\n};\n```\n\n이 코드는 간단한 작업에는 잘 작동하지만, 민감도에 따라 2가지 (또는 3가지) 문제가 있어요. 첫째, timeoutId가 사용되지 않는다는 경고가 대부분의 린팅 설정에서 표시될 거예요. 둘째, 네트워크 요청과 섞였을 때, 2개의 다른 정리 API가 발생해요. 세번째 문제는 timeoutId 매개변수가 참조로 전달되고, refenence 작업을 엄격히 제어하지 않는 언어에서 참조로 작업하는 것은 종종 예기치 못한 버그를 발생시킬 수 있어요.\n\nAbortController를 사용하면 도움이 될거예요, 특히 AbortController 신호는 여러 소스에 연결할 수 있기 때문에요.\n\n\n\n이제 신호를 지원하기 위해 sleep 함수를 수정해 봅시다:\n\n```js\nconst sleep = (ms: number, { signal = null }: { signal: AbortSignal | null }): Promise<void> =>\n  new Promise((resolve) => {\n    const timeoutId = setTimeout(resolve, ms);\n    \n    if (signal) {\n      signal.addEventListener('abort', () => clearTimeout(timeoutId), { once: true });\n    }\n  });\n```\n\n이제 fetch API와 일치하도록 정렬되었으니, 실제로 어떻게 작동하는지 살펴봅시다:\n\n```js\nuseEffect(() => {\n  const abortController = new AbortController();\n  const signal = abortController.signal;\n\n  const fetcher = async () => {\n    await fetch('/api/1', { signal });\n    await sleep(200, { signal });\n    await fetch('/api/2', { signal });\n  };\n\n  void fetcher();\n\n  return () => {\n    abortController.abort();\n  };\n}, []);\n```\n\n\n\n위에서 볼 수 있듯이, AbortController 신호는 fetch 요청과 사용자 정의 sleep 함수 두 가지에 모두 활용되어, 단일 신호가 여러 비동기 작업에 걸쳐 공유되고 코드를 깔끔하게 유지할 수 있다는 것을 보여줍니다.\n\n# Debounce와 Throttle\n\n사용자가 입력할 때 API에서 제안을 가져오고 싶은 검색 입력란을 가지고 있다고 상상해보세요. 매크로트롬이 발동되는 것은 거의 원하는 것이 아닙니다. 키 입력할 때마다 요청을 보내는 것은 성능 및 개인 정보 보호에 여러 문제가 있을 수 있습니다. 대신, API 요청을 debounce하여 사용자가 잠시 타이핑을 멈출 때까지 지연시킵니다. 이를 위해 AbortController가 어떻게 도움이 되는지 살펴보겠습니다:\n\n```js\nconst abortControllerRef = useRef<AbortController | null>(null);\n\nconst onInput = useCallback(\n  async (event: React.ChangeEvent<HTMLInputElement>) => {\n    abortControllerRef.current?.abort(); // 이전 비동기 작업을 안전하게 중단합니다\n\n    const input = event.currentTarget;\n\n    if (input.value?.length < 2) {\n      return; // 짧은 입력 값에 대한 조기 반환\n    }\n\n    abortControllerRef.current = new AbortController();\n    const signal = abortControllerRef.current.signal;\n\n    await sleep(300, { signal }); // Debounce 지연\n\n    await fetchSearchSuggestions(input.value, { signal });\n  },\n  []\n);\n\nuseEffect(() => {\n  return () => {\n    abortControllerRef.current?.abort(); // 컴포넌트가 언마운트될 때 진행 중인 모든 비동기 작업을 중지합니다\n  };\n}, []);\n\nreturn (\n  <input onInput={onInput} />\n);\n```\n\n\n\n다시 한 번 상세 제어기인 AbortController를 활용함으로써, 우리의 코드가 여러 번의 정리 작업을 처리할 필요 없이 간편하게 중단 사항을 처리할 수 있도록 보장합니다. debounce 목적으로 AbortController를 사용하는 추가적인 이점은 사용자가 sleep 함수가 종료된 후에 타이핑을 시작하면 비행 중인 호출을 취소할 것이므로 사용자가 항상 최신 쿼리 결과를 받게 함을 보장합니다. 이전에 해결된 쿼리가 아닌 최신 쿼리에 대한 결과를 사용자가 항상 수신합니다!\n\n이 기사를 리뷰해 준 Trys Mudford님께 감사드립니다 👏\n\n# 저자 소개\n\n저는 Szymon이라고 합니다. Motorway에서 웹 및 디자인 시스템 개발자로 근무하고 있습니다. 5년이 넘게 참여한 이후 영국에서 가장 빠르게 성장하는 중고차 거래 시장을 구축하는 데 도움을 주고 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-ManagingasynchronousoperationswithAbortController_0.png"},"coverImage":"/assets/img/2024-05-15-ManagingasynchronousoperationswithAbortController_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><code>&#x3C;img src=\"/assets/img/2024-05-15-ManagingasynchronousoperationswithAbortController_0.png\" /></code></p>\n<p>AbortController는 특수한 기능입니다. 대부분의 사람들은 Webpack 구성, 파일 I/O 또는 버퍼와 같은 것들과 작업을 하다가 이 매우 유용한 API를 우연히 발견하게 됩니다. 널리 사용되지 않지만 AbortController는 비동기 작업을 취소하는 방법을 제공하여 매우 유용합니다. 당신이 곧 알게 될 것은... 무엇이든지!</p>\n<p>하지만 먼저 기초부터 시작해보죠.</p>\n<h1>네트워크 요청</h1>\n<p>AbortController의 가장 잘 알려진 사용법은 네트워크 호출을 취소하는 데 사용하는 것입니다. fetch API는 옵션으로 signal 속성을 기본 제공하며, 문법은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbortController</span>();\n<span class=\"hljs-keyword\">const</span> signal = controller.<span class=\"hljs-property\">signal</span>;\n\n<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url, { signal })\n\n<span class=\"hljs-comment\">// 요청을 취소하려면 다음을 호출하십시오:</span>\ncontroller.<span class=\"hljs-title function_\">cancel</span>()\n</code></pre>\n<p>웹 응용 프로그램 프레임워크 세계에서는 아래와 같이 사용되는 것을 찾을 수 있습니다 (이 기사 전반에서 코드 예시로 React를 사용합니다):</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbortController</span>();\n  <span class=\"hljs-keyword\">const</span> signal = controller.<span class=\"hljs-property\">signal</span>;\n  \n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchData</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url, { signal })\n      <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> res.<span class=\"hljs-title function_\">json</span>();\n\n      <span class=\"hljs-title function_\">setState</span>(data);\n    } <span class=\"hljs-keyword\">catch</span> (err) {\n      <span class=\"hljs-comment\">// 에러 처리</span>\n    }\n  }\n  \n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fetchData</span>();\n  \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n    controller.<span class=\"hljs-title function_\">abort</span>()\n  }\n}, []);\n</code></pre>\n<p>이것은 당신의 컴포넌트가 unmounted(해제된) 될 때 API를 계속해서 가져오지 않고 상태를 설정하지 않도록 보장하기 위해 필요합니다.</p>\n<h1>타이머</h1>\n<p>일반적인 sleep 함수는 아래와 같이 보입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sleep</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ms: number</span>) => {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =></span> {\n    <span class=\"hljs-built_in\">setTimeout</span>(resolve, ms);\n  });\n};\n</code></pre>\n<p>좋은 작업이 잘 되었지만 이렇게 되면 콜백을 취소할 수 없어요. 이 문제를 해결해 봐요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sleep</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ms: number, timeoutId: NodeJS.Timeout</span>) => {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =></span> {\n    timeoutId = <span class=\"hljs-built_in\">setTimeout</span>(resolve, ms);\n  });\n};\n</code></pre>\n<p>이 코드는 간단한 작업에는 잘 작동하지만, 민감도에 따라 2가지 (또는 3가지) 문제가 있어요. 첫째, timeoutId가 사용되지 않는다는 경고가 대부분의 린팅 설정에서 표시될 거예요. 둘째, 네트워크 요청과 섞였을 때, 2개의 다른 정리 API가 발생해요. 세번째 문제는 timeoutId 매개변수가 참조로 전달되고, refenence 작업을 엄격히 제어하지 않는 언어에서 참조로 작업하는 것은 종종 예기치 못한 버그를 발생시킬 수 있어요.</p>\n<p>AbortController를 사용하면 도움이 될거예요, 특히 AbortController 신호는 여러 소스에 연결할 수 있기 때문에요.</p>\n<p>이제 신호를 지원하기 위해 sleep 함수를 수정해 봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> sleep = (<span class=\"hljs-attr\">ms</span>: number, { signal = <span class=\"hljs-literal\">null</span> }: { <span class=\"hljs-attr\">signal</span>: <span class=\"hljs-title class_\">AbortSignal</span> | <span class=\"hljs-literal\">null</span> }): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>> =>\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =></span> {\n    <span class=\"hljs-keyword\">const</span> timeoutId = <span class=\"hljs-built_in\">setTimeout</span>(resolve, ms);\n    \n    <span class=\"hljs-keyword\">if</span> (signal) {\n      signal.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'abort'</span>, <span class=\"hljs-function\">() =></span> <span class=\"hljs-built_in\">clearTimeout</span>(timeoutId), { <span class=\"hljs-attr\">once</span>: <span class=\"hljs-literal\">true</span> });\n    }\n  });\n</code></pre>\n<p>이제 fetch API와 일치하도록 정렬되었으니, 실제로 어떻게 작동하는지 살펴봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> abortController = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbortController</span>();\n  <span class=\"hljs-keyword\">const</span> signal = abortController.<span class=\"hljs-property\">signal</span>;\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetcher</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'/api/1'</span>, { signal });\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">200</span>, { signal });\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'/api/2'</span>, { signal });\n  };\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fetcher</span>();\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n    abortController.<span class=\"hljs-title function_\">abort</span>();\n  };\n}, []);\n</code></pre>\n<p>위에서 볼 수 있듯이, AbortController 신호는 fetch 요청과 사용자 정의 sleep 함수 두 가지에 모두 활용되어, 단일 신호가 여러 비동기 작업에 걸쳐 공유되고 코드를 깔끔하게 유지할 수 있다는 것을 보여줍니다.</p>\n<h1>Debounce와 Throttle</h1>\n<p>사용자가 입력할 때 API에서 제안을 가져오고 싶은 검색 입력란을 가지고 있다고 상상해보세요. 매크로트롬이 발동되는 것은 거의 원하는 것이 아닙니다. 키 입력할 때마다 요청을 보내는 것은 성능 및 개인 정보 보호에 여러 문제가 있을 수 있습니다. 대신, API 요청을 debounce하여 사용자가 잠시 타이핑을 멈출 때까지 지연시킵니다. 이를 위해 AbortController가 어떻게 도움이 되는지 살펴보겠습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> abortControllerRef = useRef&#x3C;<span class=\"hljs-title class_\">AbortController</span> | <span class=\"hljs-literal\">null</span>>(<span class=\"hljs-literal\">null</span>);\n\n<span class=\"hljs-keyword\">const</span> onInput = <span class=\"hljs-title function_\">useCallback</span>(\n  <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-attr\">event</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">ChangeEvent</span>&#x3C;<span class=\"hljs-title class_\">HTMLInputElement</span>>) => {\n    abortControllerRef.<span class=\"hljs-property\">current</span>?.<span class=\"hljs-title function_\">abort</span>(); <span class=\"hljs-comment\">// 이전 비동기 작업을 안전하게 중단합니다</span>\n\n    <span class=\"hljs-keyword\">const</span> input = event.<span class=\"hljs-property\">currentTarget</span>;\n\n    <span class=\"hljs-keyword\">if</span> (input.<span class=\"hljs-property\">value</span>?.<span class=\"hljs-property\">length</span> &#x3C; <span class=\"hljs-number\">2</span>) {\n      <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">// 짧은 입력 값에 대한 조기 반환</span>\n    }\n\n    abortControllerRef.<span class=\"hljs-property\">current</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbortController</span>();\n    <span class=\"hljs-keyword\">const</span> signal = abortControllerRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">signal</span>;\n\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">300</span>, { signal }); <span class=\"hljs-comment\">// Debounce 지연</span>\n\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetchSearchSuggestions</span>(input.<span class=\"hljs-property\">value</span>, { signal });\n  },\n  []\n);\n\n<span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n    abortControllerRef.<span class=\"hljs-property\">current</span>?.<span class=\"hljs-title function_\">abort</span>(); <span class=\"hljs-comment\">// 컴포넌트가 언마운트될 때 진행 중인 모든 비동기 작업을 중지합니다</span>\n  };\n}, []);\n\n<span class=\"hljs-keyword\">return</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">onInput</span>=<span class=\"hljs-string\">{onInput}</span> /></span></span>\n);\n</code></pre>\n<p>다시 한 번 상세 제어기인 AbortController를 활용함으로써, 우리의 코드가 여러 번의 정리 작업을 처리할 필요 없이 간편하게 중단 사항을 처리할 수 있도록 보장합니다. debounce 목적으로 AbortController를 사용하는 추가적인 이점은 사용자가 sleep 함수가 종료된 후에 타이핑을 시작하면 비행 중인 호출을 취소할 것이므로 사용자가 항상 최신 쿼리 결과를 받게 함을 보장합니다. 이전에 해결된 쿼리가 아닌 최신 쿼리에 대한 결과를 사용자가 항상 수신합니다!</p>\n<p>이 기사를 리뷰해 준 Trys Mudford님께 감사드립니다 👏</p>\n<h1>저자 소개</h1>\n<p>저는 Szymon이라고 합니다. Motorway에서 웹 및 디자인 시스템 개발자로 근무하고 있습니다. 5년이 넘게 참여한 이후 영국에서 가장 빠르게 성장하는 중고차 거래 시장을 구축하는 데 도움을 주고 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}