{"pageProps":{"posts":[{"title":"React에 Husky를 추가하는 방법","description":"","date":"2024-05-14 10:22","slug":"2024-05-14-HowtoaddhuskytoReact","content":"\n\n## Husky를 사용하여 오류를 줄이고 일관된 코드베이스를 유지하세요\n\n이 스토리는 원래 이곳에서 발행되었습니다.\n\nHusky는 현대적인 네이티브 Git 훅을 React 프로젝트에서 쉽게 사용할 수 있게 해줍니다. 커밋 메시지의 린트, 테스트 실행, 코드 린팅 등 커밋하거나 푸시할 때 수행할 수 있습니다.\n\n그렇다면 Git 훅은 무엇이며 어떻게 프로젝트에 Husky를 추가할 수 있을까요?\n\n\n\n## Git 훅이란 무엇인가요?\n\nGit 훅은 git의 실행 중 일정 시점에 실행될 수 있도록 설정할 수 있는 스크립트/프로그램입니다 (git 라이프사이클). 이러한 시점은 커밋의 다른 스테이지를 포함하며, 커밋 전(pre-commit)이나 커밋 후(post-commit)와 같은 시점이 있습니다.\n\nGit 훅을 사용하면 npm 테스트를 커밋 전에 실행하거나 eslint 오류 및 경고를 피하기 위해 eslint를 실행하는 것과 같이 다른 스크립트를 자동화하여 작업을 실행하여 개발자가 표준을 강제할 수 있습니다.\n\nHusky는 모든 Git 훅을 지원합니다. 제공되는 모든 Git 훅 목록은 여기에서 확인할 수 있습니다.\n\n\n\n# 리액트 프로젝트에 husky 추가하기\n\n프로젝트에 husky를 설치하는 두 가지 방법이 있어요:\n\n- 자동 (권장)\n- 수동\n\n## 자동 설치 (권장)\n\n\n\n패키지 husky-init은 husky와 함께 프로젝트를 빠르게 설치하고 초기화하는 데 사용됩니다.\n\n프로젝트 루트에서 husky를 설치하려면 다음 명령어를 입력하세요 (사용 중인 패키지 매니저에 따라 달라집니다).\n\n중요: package.json이 하위 디렉토리에 있는 경우 husky와 함께 사용자 정의 디렉토리를 설정하는 방법을 확인하세요.\n\n```bash\nnpx husky-init && npm install       # npm\nnpx husky-init && yarn              # Yarn 1\nyarn dlx husky-init --yarn2 && yarn # Yarn 2+\n```\n\n\n\n이 스크립트를 성공적으로 실행한 후 몇 가지 일이 발생했습니다:\n\n- 프로젝트 루트에 .husky라는 폴더가 추가되었습니다. 이 폴더에는 pre-commit이라는 파일이 포함되어 있습니다. 이 파일은 초기 pre-commit 후크입니다. 또한 자동으로 생성된 husky를 위한 셸 스크립트가 있는 _라는 폴더도 있습니다. (이것을 커밋하지 마세요, .gitignore를 참조하세요)\n- package.json이 수정되었습니다. prepare 스크립트가 추가되었고 husky가 devDependency로 추가되었습니다.\n- 그리고 package-lock.json이 업데이트되었습니다.\n\n이제 React 프로젝트에서 husky를 사용할 준비가 되었습니다. 😀\n\n## 수동 설치\n\n\n\n세 개 단계, 그러나 결과물은 자동 설치와 동일해야 합니다.\n\n- Husky 설치하기\n\n```js\nnpm install husky --save-dev\n```\n\n- Git 훅 활성화하기\n\n\n\n```js\nnpx husky install\n```\n\n- 설치 후 자동으로 Git 훅을 활성화하려면 package.json을 편집하세요.\n\n```js\nnpm pkg set scripts.prepare=\"husky install\"\n```\n\n## 훅 사용하기\n\n\n\n성공적인 설치 후에는 이미 pre-commit 훅이 설치되어 있어야 합니다.\n\n생성된 pre-commit 훅의 내용은 다음과 같습니다:\n\n```js\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\nnpm test\n```\n\n이는 매 commit 전에 npm test 스크립트가 실행된다는 것을 의미합니다. 테스트가 실패하면 오류가 발생하고, 테스트를 수정하지 않는 이상 commit할 수 없습니다. 이미 작은 규모의 프로젝트에서도 이것이 얼마나 유용한지 알 수 있을 것 같습니다.\n\n\n\n## 훅 생성\n\n훅에 명령을 추가하거나 새 훅을 만드는 구문은 다음과 같습니다:\n\n```js\nhusky add <file> [cmd]\n```\n\n예를 들어, pre-commit 훅에서 npm test 이후 ng lint를 실행하려면 다음과 같이 합니다.\n\n\n\n```js\nhusky add .husky/pre-commit ng lint\n```\n\n프리 커밋 후크가 업데이트되었습니다:\n\n```js\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\nnpm test\nng lint\n```\n\n🌟축하합니다🌟 React 프로젝트에 husky가 성공적으로 설치되었고 설정되었습니다.\n\n\n\n## TL;DR\n\n- Husky는 git 훅을 쉽게 사용하여 git 라이프사이클 이벤트에서 스크립트를 자동으로 실행하는 도구입니다.\n- 예를 들어: 코드를 커밋하기 전에 npm 스크립트를 실행하려면 pre-commit 훅을 사용하세요.\n\n읽어 주셔서 감사합니다. 궁금한 점이 있으시면 댓글 기능을 사용하거나 @mariokandut으로 메시지를 보내주세요. React에 대해 더 알고 싶다면 React 튜토리얼을 확인해보세요.\n\n참고문헌 (그리고 큰 감사): Git hooks, React, Husky, NPM — husky","ogImage":{"url":"/assets/img/2024-05-14-HowtoaddhuskytoReact_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoaddhuskytoReact_0.png","tag":["Tech"],"readingTime":3},{"title":"이들 생물들은 종종 그들의 문화 속 전설과 신화에 깊게 뿌리박혀 있으며, 그들의 믿음, 공포, 환경의 다양한 측면을 대표합니다","description":"","date":"2024-05-14 10:21","slug":"2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment","content":"\n\n## 신화적인 존재나 전설적인 이야기를 믿으시나요?\n\n![이미지](/assets/img/2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment_0.png)\n\n다양한 나라들의 역사를 살펴보면, 서로 다른 이름을 가진 다양한 신화적인 존재들의 전설을 발견할 수 있습니다. 각 나라마다 자신만의 신화적인 존재들과 이야기들을 가지고 있습니다.\n\n## 다양한 나라의 신화적인 존재들입니다.\n\n\n\n## 일본:\n\n여우 정령인 키츠네, 새처럼 생긴 도깨비 텐구, 물 정령인 카파 및 오니(흉악하고 강인한 정령).\n\n## 그리스:\n\n다두한 뱀 하이드라, 천하태평한 세계를 지키는 세두리를 맡은 세개 머리의 개 케르베로스, 그리고 날개 달린 영혼 하피들.\n\n\n\n## 북유럽 신화:\n\n요트나 (거인), 발키리 (여전사), 그리고 펜리르 (거대한 늑대).\n\n## 이집트:\n\n스핑크스 (사람의 머리를 가진 사자), 아누비스 (여우 머리를 가진 신), 그리고 암미트 (사자, 하마, 악어의 일부).\n\n\n\n## 인도:\n\n가루다(새 형태의 생물), 나가(뱀 형태의 존재), 그리고 락샤사(악마 형태의 존재).\n\n## 중국:\n\n용, 봉황, 그리고 치린(한콘류 생물).\n\n\n\n## 멕시코 :\n\n추파카브라 (염소 흡혈귀), 나후알 (모양 변이자), 라 요로나 (울부짖는 여성).\n\n## 러시아 :\n\n바바 야가 (마녀), 루살카 (물 정령), and 지메이 고르이치 (3머리 용).\n\n\n\n## 아프리카:\n\nMngwa(거대하고 사나운 고양이), Inkanyamba(거대한 장어), Adze(흡혈귀와 같은 존재).\n\n## 호주:\n\nBunyip(물 정령), Yowie(털불다리인간), Drop bear(허구적인 코알라와 유사한 생물).\n\n\n\n# 이들 생물은 종종 그들의 문화 속 전설과 신화에 깊이 뿌리를 내리며, 그들의 믿음, 두려움, 환경의 다양한 측면을 대표합니다.\n\n어떤 나라의 신화적 생물을 아시는 분은 댓글에 언급해 주세요.\n\n## 읽어 주셔서 감사합니다 😊","ogImage":{"url":"/assets/img/2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment_0.png"},"coverImage":"/assets/img/2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 앱에서 ESLint와 Prettier 설정하기","description":"","date":"2024-05-14 10:20","slug":"2024-05-14-SetupESLintandPrettierinReactApp","content":"\n\n<img src=\"/assets/img/2024-05-14-SetupESLintandPrettierinReactApp_0.png\" />\n\nESLint와 Prettier 설정은 초보자에게는 조금 긴장스러울 수 있어요. 저도 이 문제에 직면한 적이 있어서 잘 알고 있어요. 인터넷에는 린팅 설정에 관한 많은 기사가 있을 거예요. 그 중 일부는 여러분에게 맞을 지도 모르지만, 일부는 그렇지 않을 수도 있어요. 그 중 대부분은 라이브러리가 계속 업데이트되기 때문에 오래되었을 가능성이 크답니다.\n\n그래서, 우리는 ESLint와 Prettier에 대해 이해해야 해요.\n\n## ESLint이란?\n\n\n\nESLint는 구성 가능한 JavaScript 린터입니다. JavaScript 코드에서 문제를 찾아 해결하는 데 도움을 줍니다. 문제는 잠재적인 런타임 버그, 최적의 관행을 따르지 않는 것, 스타일링 문제 등 무엇이든 포함될 수 있습니다.\n\nESLint는 ECMAScript/JavaScript 코드에서 발견된 패턴을 식별하고 보고하는 도구로, 코드를 일관되게 만들고 버그를 피하기 위해 사용됩니다.\n\n## Prettier란 무엇인가요?\n\nPrettier는 대부분의 언어와 호환되는 주관적인 코드 형식 지정 도구입니다.\n\n\n\n## 먼저 React 앱을 만들어봐요\n\ndemo-app이라는 프로젝트를 생성하려면 다음 명령어를 실행하세요:\n\n```js\nnpx create-react-app demo-app\ncd demo-app\nnpm start\n```\n\n## ESLint와 Prettier 설정\n\n\n\n스텝 1: 프로젝트 루트 폴더에서 터미널을 열고 ESLint를 개발 의존성으로 설치하세요.\n\n```js\nnpm install eslint --save-dev\n 또는\nyarn add eslint --dev\n```\n\n스텝 2: 아래 명령어를 실행하여 .eslintrc.json 파일을 생성하세요.\n\n```js\nnpx eslint --init\n 또는\nyarn run eslint --init\n```\n\n\n\n이 프로세스를 통해 여러 옵션이 표시됩니다. 먼저 \"구문을 확인하고 문제를 찾습니다\"를 선택한 후 JavaScript 모듈(가져오기/내보내기)를 선택하고 React를 선택하세요. 그런 다음 프로젝트에 TypeScript를 사용하는지 물어볼 것입니다. 제 경우 TypeScript를 사용하지 않으므로 \"아니요\" 옵션을 선택하겠습니다. 브라우저를 선택한 후 JSON 옵션을 선택하세요. 그런 다음 eslint-plugin-react를 설치하라는 메시지가 표시됩니다. \"예\"를 클릭하세요.\n\n프로젝트 루트 폴더에 .eslintrc.json 파일이 표시됩니다.\n\n```json\n{\n    \"env\": {\n        \"browser\": true,\n        \"es2021\": true\n    },\n    \"extends\": [\n        \"eslint:recommended\",\n        \"plugin:react/recommended\"\n    ],\n    \"parserOptions\": {\n        \"ecmaVersion\": \"latest\",\n        \"sourceType\": \"module\"\n    },\n    \"plugins\": [\n        \"react\"\n    ],\n    \"rules\": {\n    }\n}\n```\n\n\n\n**단계 3: 규칙 추가**\n\n리액트 - 18.0.0에서 파일에 리액트를 가져오는 것은 선택 사항입니다. 이를 해결하기 위해 .eslintrc.json 파일에 규칙을 추가할 겁니다. 따라서 .eslintrc 파일을 열고 규칙 내부에 이 줄을 추가해주세요. \"react/react-in-jsx-scope\": \"off\"\n\n```js\n\"rules\": {\n    \"react/react-in-jsx-scope\": \"off\"\n}\n```\n\n**단계 4: Jest를 사용 중이라면**\n\nJest를 사용 중이라면, eslint가 test 또는 expect가 정의되지 않았다는 오류를 보여줄 수 있습니다. 이를 해결하기 위해 env 내부에 \"jest\": true를 추가해야 합니다.\n\n\n\n```js\n\"env\": {\n    \"browser\": true,\n    \"es2021\": true,\n    \"jest\": true\n  }\n```\n\n단계 5: 이제 리액트와 함께 작동하도록 eslint 플러그인을 추가하고, eslint 및 prettier가 서로 충돌하지 않도록 적절한 구성을 만들어주세요.\n\n```js\nnpm install eslint-config-prettier eslint-plugin-prettier prettier --save-dev\nor \nyarn add eslint-config-prettier eslint-plugin-prettier prettier --dev\n```\n\n단계 6: 위 모듈을 모두 설치한 후, .eslintrc.json 파일에 몇 가지 prettier 구성을 추가해야 합니다. 따라서 extends 내부에 \"plugin:prettier/recommended\"라는 줄을 추가해주세요.\n  \n\n\n\n```js\n\"extends\": [\n        \"eslint:recommended\",\n        \"plugin:react/recommended\",\n        \"plugin:prettier/recommended\"\n    ],\n```\n\nstep7: .prettierrc.json 파일을 생성하고 아래 코드를 붙여넣으세요\n\n```js\n{\n  \"semi\": true,\n  \"tabWidth\": 2,\n  \"printWidth\": 100,\n  \"singleQuote\": true,\n  \"trailingComma\": \"none\",\n  \"jsxBracketSameLine\": true\n}\n```\n\n이제 eslint와 prettier가 설정되었으니 package.json에 스크립트를 추가합시다.\n\n\n\n```js\n\"lint\": \"eslint .\",\n\"lint:fix\": \"eslint . --fix\",\n\"format\": \"prettier --write ./**/*.{js,jsx,ts,tsx,css,md,json} --config ./.prettierrc.json\"\n```\n\n위 명령어를 사용하여 소스 코드를 수정하고 확인할 수 있어요.\n\n읽어 주셔서 감사합니다.\n\n소스 코드: https://github.com/DreamSky1996/react-lint-prettier\n\n\n\n아란 그랜트가 만들었습니다","ogImage":{"url":"/assets/img/2024-05-14-SetupESLintandPrettierinReactApp_0.png"},"coverImage":"/assets/img/2024-05-14-SetupESLintandPrettierinReactApp_0.png","tag":["Tech"],"readingTime":4},{"title":"Choreo에서 Vite  React 앱을 만들고 배포하는 방법","description":"","date":"2024-05-14 10:19","slug":"2024-05-14-HowtoBuildandDeployaViteReactApponChoreo","content":"\n\n더블육을 전에 WSO2가 주굜한 코딩 대회에 참여했어요 (choreo.dev/cybertruck). 거기서 제가 경험해 본 내부 개발자 플랫폼인 Choreo를 탐험할 수 있었어요. 이 챌린지의 목표는 개인 개발자들이 Choreo를 경험할 수 있도록 하는 거에요.\n\nChoreo가 뭔데요?\n\n\"Choreo는 디지털 경험을 만드는 방식을 재정의하는 내부 개발자 플랫폼이에요. Choreo는 클라우드 네이티브 애플리케이션을 원활하게 디자인하고 개발하고 배포하고 관리할 수 있게 해 주어 혁신을 불러 일으키면서 시장 진입 시간을 줄여 줘요.\"\n\n그래서 오늘은 Vite+ React 앱을 Choreo에 빌드하고 배포하는 방법에 대해 설명할게요.\n\n\n\n시작하기 전에 다음 사항이 있는지 확인하세요:\n\n\n- Github 계정\n- Choreo 계정(https://console.choreo.dev/로 이동하여 가입하고 조직을 생성하세요.)\n \n\n앱 생성\n\n터미널을 열고 다음 명령어를 실행하세요:\n\n\n\n```js\nnpm create vite@latest my-project -- --template react\n```\n\n프로젝트 디렉토리로 이동하여 필요한 종속성을 설치하세요\n\n```js\ncd my-project\nnpm install\n```\n\n설치 프로세스를 완료한 후, IDE를 사용하여 프로젝트에 일부 변경을 가하실 수 있습니다. 이 데모에서 제가 한 작업은 다음과 같습니다.\n\n\n\n```js\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <>\n      <h1>Choreo 데모</h1>\n    </>\n  );\n}\n\nexport default App;\n```\n\n프로젝트를 수정한 후에 GitHub에 새 저장소를 만들고 프로젝트를 푸시하세요. Choreo 무료 평가판에서는 공개 저장소만 배포할 수 있습니다. 따라서 저장소 가시성을 공개로 설정해주세요.\n\n이제 Choreo에서 빌드하고 배포해봅시다.\n\n먼저, 조직 홈페이지를 볼 수 있는 console.choreo.dev로 이동해주세요.\n\n\n\n\n홈페이지에서 + 프로젝트 생성을 클릭하고, 프로젝트 이름을 입력한 후 \"새 프로젝트 생성\"을 클릭하면 새 프로젝트가 생성됩니다.\n\n프로젝트를 생성한 후, \"단일 구성 요소 생성\" 섹션 아래의 웹 애플리케이션 카드를 클릭하고 구성 요소의 이름과 설명을 입력하세요.\n\nGitHub 저장소를 이 구성 요소에 연결하려면 \"GitHub로 승인\"을 클릭하고, 이를 위해 생성한 저장소를 선택하세요.\n\n\n\n깃허브 레포지토리를 연결한 후, 데모와 관련된 필수 정보를 선택하십시오.\n\n```js\nBuildpack : React\nProject directory : /\nBuild command : npm run build \nBuild path : /dist\nNode version : 20(또는 사용 중인 버전)\n```\n\n<img src=\"/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_1.png\" />\n\n이제 생성 버튼을 클릭하면 컴포넌트가 성공적으로 생성됩니다.\n\n\n\n컴포넌트가 성공적으로 생성되면 대시보드의 왼쪽 사이드바에서 빌드 섹션으로 이동하여 '최신 버전 빌드'를 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_2.png)\n\n빌드 프로세스가 완료되면 응용 프로그램을 배포할 수 있습니다.\n\n그러려면 배포 섹션으로 이동하여 설정 카드에서 '구성 및 배포'를 클릭하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_3.png)\n\n이후에 왼쪽에 시트가 열리며 여기에서 파일 마운트와 인증 설정을 추가할 수 있습니다. 본 데모에서는 파일 마운트나 인증을 추가하지 않겠습니다. 이 부분은 건너뛰셔도 됩니다. (인증 패널에서 'Choreo Manage Authentication'을 끄는 것을 잊지 마세요)\n\n이제 배포 버튼을 클릭하여 애플리케이션을 개발 환경에 배포할 수 있습니다. 수 분 후에 배포 상태가 성공적으로 완료되었음을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_4.png)\n\n\n\n웹 애플리케이션을 성공적으로 호스팅했는지 확인하려면 개발 카드의 웹 앱 URL을 클릭해주세요.\n\n이제 Vite + React 앱을 Choreo에 성공적으로 배포했습니다.\n\n원하신다면 개발 환경 카드의 '프로모트' 버튼을 클릭하여 프로덕션 환경으로 승격시킬 수 있습니다. 게다가, 프로덕션 환경에서 애플리케이션에 대한 짧은 URL 접두사를 설정할 수도 있습니다.\n\n![이미지](/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_5.png)\n\n\n\n위의 데모에 대한 내 GitHub 레포를 확인해볼 수 있어요:\n\nhttps://github.com/chamals3n4/Vite-Choreo\n\n간단히 말해서, 오늘은 Vite + React 앱을 Choreo에 빌드하고 배포하는 방법을 배웠어요. Choreo를 사용하면 클라우드 네이티브 앱을 쉽게 배포할 수 있어요.\n\nChoreo에 대한 자세한 정보 및 고급 개념은 그들의 문서에서 찾을 수 있어요.\n\n\n\nhttps://wso2.com/choreo/docs/\n\n본 글을 읽어 주셔서 감사합니다. 즐거운 코딩 하세요!!","ogImage":{"url":"/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoBuildandDeployaViteReactApponChoreo_0.png","tag":["Tech"],"readingTime":3},{"title":"Create-React-App과 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법","description":"","date":"2024-05-14 10:17","slug":"2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd","content":"\n\n오늘은 개인 프로젝트를 진행하면서 애플리케이션 내에서 더 많은 사용자 정의를 가능하게하기 위해 드래그 앤 드롭 기능을 구현해야 했어요. 문서, 공식 문서 및 YouTube 비디오를 많이 살펴보느라 많은 시간을 보냈죠. 공부하고 구현을 시도한 깁ㄴ 긴 과정 끝에, 마침내 작동하게 만들었어요. 그런데 어떻게 하느냐구요? 그러기 전에, React 앱을 만들어 봐요!\n\n```js\nnpx create-react-app dnd-example\ncd dnd-example\nnpm start\n```\n\n축하해요! 이제 React 앱을 만들었어요.\n\n![드래그 앤 듭 구현 방법](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_0.png)\n\n\n\n하지만 이것은 시작에 불과해요. 오늘 사용할 패키지를 설치해봅시다.\n\nnpm i react-beautiful-dnd\n\nreact-beautiful-dnd가 무엇인지 모른다면 괜찮아요. Atlassian 팀에서 개발한 라이브러리인데, Jira를 만든 회사입니다. 또한 완전히 오픈 소스이며 프로젝트는 여기에서 확인할 수 있어요. 그리고 우리는 앱을 DragDropContext 컴포넌트 사이에 감싸야 해요. 기억하세요, DragDropContext는 하나만 가질 수 있어요. 그래서 권장하는 공식 문서의 사용 방법을 따르면 전체 앱을 이 사이에 감싸는 것이 좋은 아이디어에요. 현재 내 App.js 파일은 이렇게 생겼어요.\n\n\n\n드래그 앤 드롭 기능을 사용하기 위해서는 react-beautiful-dnd가 제공하는 DragDropContext가 필요합니다. 우리가 사용하는 라이브러리는 중첩된 DragDropContext를 지원하지 않습니다. 그러나 DragDropContext는 onDragEnd 콜백이 필요합니다. 이 콜백은 요소를 드래그한 후에 호출됩니다. 간단하게 하기 위해 함수를 사용할 것입니다. 제가 코드를 복사하여 붙여넣을 수 있는 형식으로 제공하지는 않겠습니다. 연습이 중요하다고 생각하기 때문입니다. 지금까지 우리 앱이 어떻게 보이는지 살펴봅시다:\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_2.png)\n\n하나씩 살펴보겠습니다.\n\n우리는 handleOnDragEnd라는 함수를 정의했고, result라는 매개변수를 받는데, 현재 중요하지 않습니다. 드래그 앤 드롭 기능이 작동하려면 DragDropContext 구성 요소로 둘러싸여야 합니다. 많은 사용 가능한 속성과 콜백이 있지만 onDragEnd를 제외하고는 필수 사항이 없습니다. 따라서 핸들러 함수를 DragDropContext 구성 요소의 속성으로 추가했습니다. 웹 사이트에 드래그 앤 드롭할 항목(빨간색 상자 목록)을 추가해보겠습니다. HTML 및 CSS 코드에 대해서는 HTML이나 CSS 튜토리얼이 아니기 때문에 코드를 제공하겠습니다. App.js 파일에는 DragDropContext 태그 내의 드래그 가능한 콘텐츠가 필요합니다. 그러므로 다음을 수행하겠습니다:\n\n\n\n```md\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_3.png)\n\n```js\n<ul>\n<li><div className=\"box red\"></div></li>\n<li><div className=\"box green\"></div></li>\n</ul>\n```\n\n그리고 App.css 파일에서 다음을 수행할 거예요:\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_4.png)\n\n\n\n\n```jsx\nul {\nlist-style: none;\npadding-left: 5px;\n}\n.box {\nwidth: 200px;\nheight: 50px;\nmargin-bottom: 5px;\n}\n.red {\nbackground: red;\n}\n.green {\nbackground: green;\n}\n```\n\n이 내용에 대해 자세히 언급하지 않겠습니다. 여러분은 여전히 상자를 끌어다 놓거나 드롭할 수 없다는 것을 알 수 있을 겁니다. 먼저 상자를 놓기에 집중해 보겠습니다. 이를 위해 Droppable이라는 다른 구성 요소를 가져와야 합니다. Droppable은 요소를 놓을 수 있는 영역을 정의하는 데 도움이 됩니다. 현재 사용 중인 경우 ul 요소 전체를 놓을 수있는 영역으로 하고 싶습니다.\n\n<img src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_5.png\" />\n\n좋아요, 쉬운 부분이죠? 그런데, Droppable 구성 요소에도 droppableId라는 속성이 필요합니다. 왜 그런지 궁금할 수 있습니다. HTML 페이지 전체에는 1개 이상의 놓을 수있는 영역이 있을 수 있으며 react-beautiful-dnd는 무슨일이든 요소를 놓는 지점을 식별해야 합니다. 그래서 id를 추가해 보겠습니다. 이는 문자열이면 무엇이든 상관없습니다. 저는 \"boxes\"라고 부를 것입니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_6.png)\n\n더 많은 속성이 있습니다. 'type', 'isDropDisabled' 등이 있지만 이번에는 간단한 드래그 앤 드롭을 할 것입니다. 더 자세히 살펴보고 싶다면 여기에서 공식 문서를 확인할 수 있어요. 이제 우리의 Droppable 구성 요소도 두 개의 인수가 있는 함수가 필요합니다. 이러한 인수들은 provided와 snapshot입니다. 이 예시에서는 provided만 사용하고 이것만 필요한 매개변수입니다. provided를 통해 중요한 3가지를 얻을 수 있습니다; provided.innerRef, provided.placeholder, provided.droppableProps입니다. 간단히 말하면 provided.innerRef를 가능한 높은 DOM 노드에 바인딩해야 합니다. 이것은 ReactDOM을 사용하지 않고도 DOM 노드를 찾을 수 있게 도와줍니다. provided.placeholder는 요소를 드래그할 때 플레이스홀더 공간을 만듭니다. 중요한 점은 provided.innerRef에 바인딩한 구성 요소 내에 플레이스홀더를 두어야 합니다. 마지막 props인 provided.droppableProps는 전개 연산자입니다. react-beautiful-dnd가 필요로 하는 모든 데이터와 스타일을 포함합니다. 이러한 props를 모두 동일한 요소에 넣어야 합니다. 인라인 스타일이 있는 경우, provided.droppableProps를 먼저 입력해야 합니다. provided.droppableProps에 스타일도 포함되어 있어 인라인 스타일이 덮어씁니다. 이제 실습해 봅시다:\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_7.png)\n\n지금 웹사이트를 확인해보면 아무 변화가 없을 것입니다. 그 이유는 무엇일까요? 우리의 요소들은 아직 드래그할 수 없기 때문입니다! 이제 이 문제를 해결해 봅시다. 먼저 Draggable을 가져와야 합니다. Draggable은 Droppable과 많은 경우 비슷하지만 요소를 드래그할 수 있게 만듭니다. DragDropContext와 달리, 여러 개의 Droppable과 Draggable을 가질 수 있습니다. Draggable은 항상 하나의 Droppable 내에 포함되어야 하고 Droppable은 항상 DragDropContext 내에 포함되어야 합니다. Droppable과 마찬가지로 Draggable도 동일한 문서에서 여러 개를 사용할 수 있기 때문에 ID가 필요합니다. 그러나 더 나아가기 전에, 여기서 배열을 사용하고 수동으로 작성된 div가 아닌 배열과 함께 사용할 것이므로 코드를 리팩토링하고 싶습니다. 또한 그 논리를 설명할 것이므로, 수동으로 작성된 div와 함께 사용한다 해도 잘 이해할 수 있도록 하겠습니다. 함께 따라오신다면, App 구성 요소 내에서 다음과 같이 객체들의 간단한 배열을 정의할 것입니다:\n\n\n\n아주 명확하지요. 이제 div를 표시하는 방법을 개선해 봅시다:\n\n이 기사는 적어도 React의 기본 지식이 있음을 가정하므로 map에 대해 자세히 설명하지는 않겠습니다. 배열을 해체하고 목록 항목에 키 값을 할당했습니다. 클래스에는 템플릿 리터럴이라는 것을 사용했습니다. 이게 무엇인지 모르겠다면 여기에서 내 기사를 읽어보세요. 페이지를 새로 고쳐도 아무것도 바뀌지 않을 겁니다. 이제 웹사이트에 드래그 기능을 추가해 봅시다. 먼저, 드래그 가능한 내용을 감싸는 데 필요한 것은 Draggable 컴포넌트입니다. 제 경우에는 li 요소가 됩니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_10.png\" />\n\n드래그 가능한 항목을 만들려면 index와 ID가 필요합니다. ID는 다시 한 번 문자열이어야 합니다. 여기서는 map 함수에서 받은 index를 사용할 것입니다. 그런데 문제는 ID가 숫자인데, 그래서 우리는 그 아주 오래된 toString() 함수를 사용할 겁니다. 시작해 봅시다!\n\n<img src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_11.png\" />\n\n좋아요, 여기서부터는 좀 더 가까워졌네요. Droppable과 유사하게, Draggable 컴포넌트도 두 가지 인수를 받는 함수가 필요합니다. 이 인수들은 우리 친구인 provided와 snapshot입니다. 다시 한 번, 우리는 provided만 사용할 것이고, 이것이 유일한 필수 인수입니다. Droppable과 마찬가지로, provided.innerRef, provided.draggableProps, provided.dragHandleProps라는 3가지 중요한 것을 얻습니다. 이들을 다시 동일한 요소에 할당해야 합니다. 이것들이 하는 일은 Droppable과 유사합니다. 우리는 리스트 요소에 이것들을 추가할 것입니다. 왜냐하면 우리는 이것이 드래그 가능하도록 하고 싶기 때문이죠.\n\n\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_12.png)\n\n하지만 조금 변경을 해줘야 해요. key prop을 Draggable 컴포넌트로 옮기겠어요. 각 draggable 요소에는 key가 필요해요.\n\n![이미지](/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_13.png)\n\n좋아요, 멋지죠! 이제 페이지를 새로 고치면 요소를 드래그 앤 드롭할 수 있어요. 와아아!\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:638/1*QSGvvVpg3ZwZF1ecxNeB3g.gif\" />\n\n알겠어요, 그거 좋은데 이건 의미가 없어요. 드래그앤드랍하는 동안 저장조차 안돼있네요. 이러한 경우에는 상태(states)를 사용할 거예요. 먼저 useState를 import해보죠.\n\n<img src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_14.png\" />\n\n다음으로, 상태(states)를 정의할거예요. 저는 이를 박스(boxes)라고 부를거에요. 그리고 시작할 때 배열을 삭제하고 상태로 할당할거에요.\n\n\n\n<img src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_15.png\" />\n\n알겠어요, 페이지를 새로고침하면... 아무것도 변하지 않을 거예요! 그건, 드래그가 끝났을 때 어떻게 동작하는지 다뤄주지 않았기 때문이죠. 그래서 handleonDragEnd를 정의했던 거예요, 맞죠? 그럼, 그걸 처리해 볼게요! 일단 결과가 무엇인지 간단히 console.log로 확인해 볼 거예요.\n\n<img src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_16.png\" />\n\n알겠어요, 그것은 우리가 사용할 수 있는 여러 멋진 요소들을 가진 객체네요. 그 중에서도 destination과 source에 관심이 있지만요. Source는 우리가 드래그한 요소에 대한 정보를 가지고 있고, destination은 우리가 그것을 끌어다 놓은 위치에 대한 정보를 가지고 있어요. 이 지식을 바탕으로, box 배열에서 새 배열을 만들어 볼게요.\n\n\n\n<img src=\"/assets/img/2024-05-14-Create-React-App와 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법_17.png\" />\n\n좋아요. 다음으로, 새 배열에서 드래그 된 요소를 제거하고 이동한 위치에 추가하려고 합니다. 이를 위해 다음과 같이 소스와 대상의 인덱스를 사용해야합니다.\n\n<img src=\"/assets/img/2024-05-14-Create-React-App와 react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법_18.png\" />\n\n좋아요, 그런데 그것만으로는 의미가 없어요, 맞죠? 우리는 그냥 새 배열을 만드는 것 뿐이에요. 그래 놓은 새 배열을 우리의 상태로 설정해야 해요.\n\n\n\n<img src=\"/assets/img/2024-05-14-Create-React-App와-react-beautiful-dnd를 사용하여 간단한 드래그 앤 드롭을 구현하는 방법_19.png\" />\n\n자, 이제 웹사이트를 다시 확인해 봅시다!\n\n<img src=\"https://miro.medium.com/v2/resize:fit:596/1*6BHSxIDCCkGF_gQq3sl5Ew.gif\" />\n\n잘 작동하네요! 하지만 작은 버그가 있네요. 만약 박스를 우리가 Droppable을 정의하지 않은 곳에 끌어다 놓으면 어떻게 될까요? 한번 시도해 보죠:\n\n\n\n<img src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_20.png\" />\n\n음, 예상대로 제 상자가 원래 위치로 돌아가고 이 오류가 발생했어요. 해결 방법은 간단해요. 목적지가 null이면 간단히 리턴하면 돼요:\n\n<img src=\"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_21.png\" />\n\n이제 Atlassian의 react-beautiful-dnd를 사용하여 완벽하게 작동하는 간단한 드래그 앤 드롭 기능이 준비됐어요! 이 기사를 위해 작성한 코드를 검토하려면 아래에 GitHub repo 링크를 추가하겠습니다.\n\n\n\n언제나 이 코드에 대해 개선 사항이나 질문이 있으면 아래 댓글을 남겨 주세요. 또한 제 일일 학습 루틴에서 더 많은 글을 보고 싶다면 제 팔로우를 고려해 주세요. 그렇다면, 다음 글에서 만나요!\n\n깃허브 저장소","ogImage":{"url":"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_0.png"},"coverImage":"/assets/img/2024-05-14-Howtoimplementasimpledrag-and-dropusingCreate-React-Appandreact-beautiful-dnd_0.png","tag":["Tech"],"readingTime":9},{"title":"React에서 React Router 링크를 테스트하는 방법 초심자를 위한 안내","description":"","date":"2024-05-14 10:15","slug":"2024-05-14-HowtoTestaReactRouterLinkinReactABeginnersGuide","content":"\n\n안녕하세요! 유닛 테스트의 바다에 발을 담그기 시작하셨나요? 그렇다면 올바른 곳에 왔어요! 오늘은 React Router를 사용하는 React 애플리케이션에서 클릭 가능한 링크를 테스트하는 재미있는 시간을 갖도록 할 거예요. 재미있고 간단하게 진행하며 테스팅의 세계로 여행을 시작해보아요!\n\n# 왜 네비게이션 링크를 테스트해야 하나요?\n\n네비게이션 링크는 많은 웹 애플리케이션에서 사용자 상호작용의 중추입니다. 페이지를 새로고침하지 않고 사용자를 부드럽게 이동시키며, 이를 테스트하는 것이 사용자 경험의 연속성을 보장하는 데 중요합니다. 오늘은 이 링크들이 사용자를 목적지로 올바르게 안내하는지 확인하는 방법을 배우게 될 거예요.\n\n# 코드: React Router 링크\n\n\n\n작은 링크 컴포넌트를 작성해 보겠습니다. MagicDoor라고 부를게요. 보기에는 이렇습니다:\n\n```js\n// MagicDoor.js\nimport React from 'react';\nimport { Link } from 'react-router-dom';\n\nfunction MagicDoor({ destinationId }) {\n  return (\n    <div>\n      <Link to={{\n        pathname: `/mystery-destination/${destinationId}`,\n        state: { from: window.location.pathname }\n      }}>\n        목적지로 이동하기\n      </Link>\n    </div>\n  );\n}\n\nexport default MagicDoor;\n```\n\n이 컴포넌트에서 destinationId는 열고자 하는 목적지를 결정하는 고유한 키입니다. 상태(state)는 어디서 왔는지의 기억을 갖고 있어요.\n\n# 테스트 시간: 제대로 열리나요?\n\n\n\n자, 이제 MagicDoor가 예상대로 작동하는지 확인해 봅시다. 올바른 URL을 가지고 있는지 확인하고 클릭했을 때 어떻게 되는지 살펴봅시다:\n\n```js\n// MagicDoor.test.js\nimport React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\nimport { BrowserRouter } from 'react-router-dom';\nimport theme from 'core/theme';\nimport { MuiThemeProvider } from '@material-ui/core/styles';\nimport MagicDoor from './MagicDoor';\n\ndescribe('MagicDoor Component', () => {\n  let store;\n  beforeAll(() => {\n    const mockStore = configureStore([]);\n    store = mockStore({}); // 초기 상태\n  });\n\n  it('문 사용시 올바른 목적지로 이동해야 함', () => {\n    const destinationId = '123';\n    const destinationLink = `mystery-destination/${destinationId}`;\n    render(\n      <Provider store={store}>\n        <MuiThemeProvider theme={theme}>\n          <BrowserRouter>\n            <MagicDoor destinationId={destinationId} />\n          </BrowserRouter>\n        </MuiThemeProvider>\n      </Provider>,\n    );\n    \n    const door = screen.getByText('Step through to your destination');\n    expect(door).toHaveAttribute('href', destinationLink);\n    \n    fireEvent.click(door);\n    expect(window.location.pathname).toBe(destinationLink);\n  });\n});\n```\n\n# 방금 무엇을 했나요?\n\n- 링크 찾기: getByText를 사용하여 텍스트에 따라 링크를 찾았습니다.\n- URL 확인: 링크의 href 속성이 제공한 목적지와 일치하는지 확인했습니다.\n- 클릭 시뮬레이션: fireEvent를 사용하여 클릭을 모방하고 올바른 URL이 열렸는지 확인했습니다.\n\n\n\n# 왜 이겪소!\n\nReact Router로 테스트를 진행하면 앱의 내부 이동이 의도한 대로 작동하는지 확인할 수 있어 사용자 경험에서 중요합니다. 사용자 상호작용을 모방하고 결과 경로를 확인함으로써, 사용자가 정확히 이동할 위치를 확인합니다.\n\n# 결론\n\n이제 React Router를 사용하여 React 애플리케이션의 네비게이션 링크를 테스트할 견고한 방법을 갖게 되었습니다. 작성하는 모든 테스트는 더 신뢰할 수 있는 애플리케이션을 구축하는 데 도움이 되며, 네비게이션이 매끄럽고 올바르게 흘러가는 것을 확인합니다.\n\n\n\n# 다음은 무엇인가요?\n\n어플리케이션의 다른 유형의 상호작용을 위한 테스트를 추가해보는 것은 어떨까요? 모든 조각의 테스트는 연결되어 매끄럽고 버그가 없는 사용자 경험을 만들어냅니다. 여러분이 어떤 것들을 만들어내는지 댓글에서 제 경험을 공유해 주시면 정말로 좋겠어요!\n\n기억하세요, 테스팅은 연습과 인내력으로 향상되는 기술입니다. 계속 하며 언젠가는 React 어플리케이션을 전문가처럼 테스트할 수 있게 될 거예요. 행복한 테스팅하세요!","ogImage":{"url":"/assets/img/2024-05-14-HowtoTestaReactRouterLinkinReactABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoTestaReactRouterLinkinReactABeginnersGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"스켈러블한 마이크로서비스 구축 Go로 GRPC 서비스 만들기 및 Envoy를 통해 React 앱에서 사용하기","description":"","date":"2024-05-14 10:14","slug":"2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy","content":"\n\n<img src=\"/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_0.png\" />\n\n# 준비물\n\n구현에 들어가기 전에 시스템에 다음 사항이 설치되어 있는지 확인하세요:\n\n- Go: 공식 웹사이트(https://golang.org/)에서 Go를 설치하세요.\n- Node.js와 npm: (https://nodejs.org/)에서 Node.js를 다운로드하고 설치하세요.\n- Docker: Envoy 프록시 컨테이너를 실행하기 위해 Docker를 설치하세요(https://www.docker.com/).\n\n\n\n# 단계 1: Go에서 GRPC 서비스 만들기\n\n먼저 Go로 GRPC 서비스를 만들어봅시다. 프로젝트를 위한 새 디렉토리를 만들고 Go 환경을 설정해보세요:\n\n```js\ngo-grpc-server-with-envoy\n```\n\n아래 명령을 실행하여 프로젝트를 초기화하세요:\n\n\n\n```js\ncd go-grpc-server-with-envoy\ngo mod init\n```\n\n지금은 새로운 Go 파일을 만들어서 서비스를 구현해보세요. 예를 들어 main.go 파일을 만들 수 있습니다. 이 파일에서 GRPC 서비스와 그 메서드를 정의해보세요. 다음은 간단한 예시입니다:\n\n```js\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"google.golang.org/grpc\"\n)\n\n// YourService should implement the methods of your GRPC service.\ntype YourService struct{}\n\n// 여기에 GRPC 메서드를 구현하세요.\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\tgrpcServer := grpc.NewServer()\n\t// 여기에 서비스를 등록하세요.\n\n\tif err := grpcServer.Serve(listener); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}\n```\n\n# 스텝 2: 프로토버프 정의 만들기\n\n\n\n\n서비스와 메시지를 Protocol Buffers(Protobuf)를 사용하여 정의하세요. \"proto\" 폴더 안에 .proto 파일을 만들어주세요. 예를 들어 UserInfo.proto 파일을 만들어서 서비스와 메시지 유형을 정의해주세요:\n\n```js\nsyntax = \"proto3\";\n\npackage proto;\n\noption go_package = \"app/proto\";\n\nmessage User {\n    string name = 1;\n    int32 age = 2;\n    Address address = 3;\n    PhoneNumber phone = 4;\n    string updated_at = 5;\n    string created_at = 6;\n}\n\nmessage Address {\n    string street = 1;\n    string city = 2;\n    string state = 3;\n    string zip = 4;\n}\n\nmessage PhoneNumber {\n    string primary = 1;\n    map<string, string> others = 2;\n}\n\nmessage UserRequest {\n    string name = 1;\n}\n\nmessage UserResponse {\n    User user = 1;\n    int32 status = 2;\n    string error = 3;\n}\n\nservice Usr {\n    rpc GetUser(UserRequest) returns (UserResponse) {}\n}\n```\n\n.proto 파일을 컴파일하여 Go 코드를 생성하세요:\n\n```js\n protoc ./proto/userInfo.proto --go_out=. --go-grpc_out=.\n```\n\n\n\n# 단계 3: GRPC 서비스 구현하기\n\nmain.go 파일에 .proto 파일의 정의에 따라 GRPC 서비스 메소드를 구현해주세요.\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net\"\n    \"time\"\n\n    \"github.com/digvijay17july/golang-projects/go-grpc-react-example/go-grpc-server-with-envoy/app/proto\"\n    \"google.golang.org/grpc\"\n)\n\ntype server struct {\n    proto.UnimplementedUsrServer\n}\n\nfunc (*server) GetUser(ctx context.Context, in *proto.UserRequest) (*proto.UserResponse, error) {\n    \n    others := make(map[string]string)\n    others[\"secondary\"] = \"233453\"\n    phone := &proto.PhoneNumber{Primary: \"1234567890\", Others: others}\n    user := &proto.User{Name: \"Digvijay\", Age: 23, Address: &proto.Address{Street: \"Pune\", City: \"Pune\", State: \"MAHARASHTRA\", Zip: \"201223\"}, Phone: phone, UpdatedAt: time.Now().UTC().String(), CreatedAt: time.Now().UTC().String()}\n    return &proto.UserResponse{User: user, Status: 200, Error: \"\"}, nil\n}\n\nfunc main() {\n    lis, err := net.Listen(\"tcp\", \":8080\")\n    if err != nil {\n        log.Fatalf(\"failed to listen: %v\", err)\n    }\n    s := grpc.NewServer()\n    grpcServer := &server{}\n    proto.RegisterUsrServer(s, grpcServer)\n    log.Printf(\"Starting server on port :%v\", lis.Addr())\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf(\"failed to serve: %v\", err)\n    }\n\n}\n```\n\n# 단계 4: GRPC 서비스 Docker 이미지 빌드 및 실행하기\n\n\n\nDockerfile for the Grpc Service app -\n\n```js\nFROM golang:1.21.4-alpine\n\nWORKDIR /app\n\nCOPY go.sum ./\n\nCOPY . ./\n\nRUN go build -o /go-grpc-server-with-envoy\n\nEXPOSE 8080\n\nCMD [\"/go-grpc-server-with-envoy\"]\n```\n\n이미지 빌드하기 -\n\n```js\ndocker build -t go-grpc-server-with-envoy .\n```\n\n\n\n# 단계 5: Envoy Proxy 설정하기\n\nEnvoy 폴더를 생성하세요. 이 폴더에는 2개의 파일이 포함됩니다.\n\n- ./config/envoy.yaml\n\n```js\nadmin:\n  address:\n    socket_address: { address: 0.0.0.0, port_value: 9901 }\nstatic_resources:\n  listeners:\n    - name: listener_0\n      address:\n        socket_address: { address: 0.0.0.0, port_value:  8080 }\n      filter_chains:\n        - filters:\n            - name: envoy.filters.network.http_connection_manager\n              typed_config:\n                \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n                codec_type: auto\n                stat_prefix: ingress_http\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains: [\"*\"]\n                      routes:\n                        - match: { prefix: \"/\"}\n                          route: { cluster: grpc_service}\n                      cors:\n                        allow_origin_string_match:\n                          - prefix: \"*\"\n                        allow_methods: GET, PUT, DELETE, POST, OPTIONS\n                        allow_headers: keep-alive,user-agent,cache-control,content-type,content-transfer-encoding,custom-header-1,x-accept-content-transfer-encoding,x-accept-response-streaming,x-user-agent,x-grpc-web,grpc-timeout\n                        max_age: \"1728000\"\n                        expose_headers: custom-header-1,grpc-status,grpc-message\n                http_filters:\n                  - name: envoy.filters.http.grpc_web\n                    typed_config:\n                      \"@type\": type.googleapis.com/envoy.extensions.filters.http.grpc_web.v3.GrpcWeb\n                  - name: envoy.filters.http.cors\n                    typed_config:\n                      \"@type\": type.googleapis.com/envoy.extensions.filters.http.cors.v3.Cors\n                  - name: envoy.filters.http.router\n                    typed_config:\n                      \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n  clusters:\n    - name: grpc_service\n      connect_timeout: 0.25s\n      type: LOGICAL_DNS\n      typed_extension_protocol_options:\n        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n          \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n          explicit_http_config:\n            http2_protocol_options: {}\n      lb_policy: ROUND_ROBIN\n      load_assignment:\n        cluster_name: grpc_service\n        endpoints:\n          - lb_endpoints:\n              - endpoint:\n                  address:\n                    socket_address:\n                      address: host.docker.internal\n                      port_value: 8080\n```\n\n\n\n2. ./config/Dockerfile\n\n```js\nFROM envoyproxy/envoy:v1.28.0\nCOPY ./envoy.yaml /etc/envoy/envoy.yaml\n```\n\n# 단계 6: 앱 실행을 위한 docker-compose.yaml 생성\n\n```js\nversion: '3'\nservices:\n  grpc-server:\n    image: go-grpc-server-with-envoy:latest  # 실제 Go gRPC 서버 이미지 이름과 태그로 변경\n    ports:\n      - \"8080:8080\"  # 컨테이너의 gRPC 포트를 호스트 머신에 매핑\n    networks:\n      - go-grpc-server-with-envoy\n\n  gateway-envoy:\n    build:\n      context: ./envoy/config\n      dockerfile: Dockerfile\n    ports:\n      - '8083:8080'\n\n    networks:\n      - go-grpc-server-with-envoy\n\nnetworks:\n  go-grpc-server-with-envoy:\n```\n\n\n\n백엔드를 Envoy 프록시로 실행하려면:\n\n```js\ndocker-compose up\n```\n\n출력:\n\n![이미지](/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_1.png)\n\n\n\n# 단계 7: 리액트 앱 생성하기\n\n```js\nnpx create-react-app my-grpc-app\ncd my-grpc-app\n```\n\n# 단계 8: gRPC-Web 및 google-protobuf 플러그인 설치\n\n```js\nnpm install -g protoc-gen-ts\nnpm i protoc-gen-grpc-web\n```\n\n\n\n# 단계 9: 리액트 앱에서 다른 종속성 구성하기\n\n```js\n  \"dependencies\": {\n    \"@grpc/proto-loader\": \"^0.7.10\",\n    \"@testing-library/jest-dom\": \"^5.17.0\",\n    \"@testing-library/react\": \"^13.4.0\",\n    \"@testing-library/user-event\": \"^13.5.0\",\n    \"@types/react\": \"^18.2.47\",\n    \"@types/react-dom\": \"^18.2.18\",\n    \"google-proto-files\": \"^4.0.0\",\n    \"google-protobuf\": \"3.21.2\",\n    \"grpc-web\": \"^1.5.0\",\n    \"protoc-gen-grpc-web\": \"^1.4.2\",\n    \"protoc-gen-ts\": \"^0.8.7\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-scripts\": \"5.0.1\",\n    \"web-vitals\": \"^2.1.4\"\n  }\n```\n\n# 단계 10: 리액트 앱을 위한 GRPC 클라이언트 코드 생성\n\n.proto 파일을 컴파일하여 js 코드를 생성하세요:\n\n\n\n```js\nprotoc -I=src/proto userInfo.proto --js_out=import_style=commonjs,binary:./src/proto --grpc-web_out=import_style=commonjs,mode=grpcwebtext:./src/proto\n```\n\n# 단계 11: React 앱 구성하기\n\nUserDetails.js\n\n```js\nimport React, { Component } from 'react';\nimport { UsrClient } from '../proto/userInfo_grpc_web_pb';\nimport { UserRequest } from '../proto/userInfo_pb';// 생성된 클라이언트 코드를 가져옵니다\n\nclass UserDetail extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            user: null,\n            error: null,\n        };\n    }\n\n    componentDidMount() {\n        const client = new UsrClient('http://localhost:8083'); // 사용 중인 gRPC 서버 URL로 교체해주세요\n\n        // 사용자 이름을 사용해 요청 생성\n        const request = new UserRequest();\n        // 원하는 사용자 이름으로 대체해주세요\n\n        // GetUser RPC 호출\n        client.getUser(request, {}, (err, response) => {\n            if (!err) {\n                this.setState({ user: response.getUser() });\n            } else {\n                this.setState({ error: '사용자 데이터를 불러오는 중 오류 발생' });\n            }\n        });\n    }\n\n    render() {\n        const { user, error } = this.state;\n\n        return (\n            <div>\n                {error ? (\n                    <p>Error: {error}</p>\n                ) : user ? (\n                    <div>\n                        <h1>사용자 세부 정보</h1>\n                        <p>이름: {user.getName()}</p>\n                        <p>나이: {user.getAge()}</p>\n                        <h2>주소</h2>\n                        <p>거리: {user.getAddress().getStreet()}</p>\n                        <p>도시: {user.getAddress().getCity()}</p>\n                        <p>주: {user.getAddress().getState()}</p>\n                        <p>우편번호: {user.getAddress().getZip()}</p>\n                        {/* 전화번호 정보를 비슷하게 표시할 수 있습니다 */}\n                        <p>업데이트 날짜: {user.getUpdatedAt()}</p>\n                        <p>생성 날짜: {user.getCreatedAt()}</p>\n                    </div>\n                ) : (\n                    <p>로딩 중...</p>\n                )}\n            </div>\n        );\n    }\n}\n\nexport default UserDetail;\n```\n\n\n\nApp.js\n\n```js\nimport logo from './logo.svg';\nimport './App.css';\nimport UserDetail from './components/UserDetails';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <UserDetail>\n          \n        </UserDetail>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n### Step 12: React 앱 빌드 및 실행\n\nReact 앱을 빌드하고 실행하세요.\n\n\n\n```js\nnpm start\n```\n\n결과 -\n\n<img src=\"/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_2.png\" />\n\n# 결론\n\n\n\n본 튜토리얼에서는 Go로 GRPC 서비스를 생성하는 방법, Envoy를 프록시로 구성하는 방법, 그리고 React 앱을 빌드하여 Envoy를 통해 GRPC 서비스와 통신하는 과정을 다루었습니다. 이 설정은 분산 시스템을 구축하는 확장 가능하고 효율적인 방법을 제공합니다. 필요에 따라 서비스 및 React 앱에 더 많은 GRPC 메서드와 기능을 추가하여 이 예제를 확장할 수 있습니다. 즐거운 코딩하세요!\n\n더 많은 정보를 위해 코드를 확인하세요: GitHub","ogImage":{"url":"/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingScalableMicroservicesCreatingaGRPCServicewithGoandConsumingitinaReactAppviaEnvoy_0.png","tag":["Tech"],"readingTime":11},{"title":" Nextjs 142의 새로운 기능을 살펴보세요 ","description":"","date":"2024-05-14 10:12","slug":"2024-05-14-ExplorewhatisnewinNextjs142","content":"\n\n![이미지](/assets/img/2024-05-14-ExplorewhatisnewinNextjs142_0.png)\n\nNext.js 14.2의 로컬 개발용 릴리스 후보인 Turbopack이 여러분의 경험을 업그레이드해줄 준비가 되어 있습니다! 💻\n\n# 주요 포인트:\n\n- 통합 테스트의 99.8%가 통과했습니다 🎉\n- Next.js 앱에서 사용되는 상위 300개 npm 패키지가 Turbopack으로 컴파일될 수 있습니다 📦\n- 모든 Next.js 예제가 매끈하게 작동합니다 🌐\n- Lightning CSS, 빠른 CSS 번들러 및 최소화 도구가 이제 통합되었습니다 🎨\n\n\n\n벌셀닷컴에 미치는 현실적인 영향, 대형 Next.js 앱:\n\n- 로컬 서버 시작 속도가 76.7% 빨라짐 ⚡\n- Fast Refresh로 코드 업데이트가 96.3% 빨라짐 🔥\n- 캐싱 없이 초기 루트 컴파일이 45.8% 빨라짐 🏎️\n\n한 번 시도해보세요:\n\n```js\nnext dev - turbo 🚀\n```\n\n\n\n# 먼저, Turbopack에 대해 간단히 알아봅시다.\n\n## 🌟웹팩의 후속제품, Rust로 만들어진 성공작 🚀\n\nTurbopack은 JavaScript와 TypeScript에 최적화된 혁신적인 점진적 번들러입니다. Rust로 설계되어 어떤 규모의 프로젝트에도 빠르고 적응할 수 있는 개발 경험을 제공합니다.\n\n## Turbopack의 주요 기능\n\n\n\n점진적 번들링: Turbopack가 작업을 완료하면 동일 작업을 다시 하지 않아 개발 프로세스를 최적화하고 시간을 절약합니다.\n\n풍부한 생태계 지원: TypeScript, JSX, CSS, CSS Modules 및 WebAssembly과의 기본적 호환성 제공.\n\n빠른 HMR: 응용 프로그램 크기와 관계없이 빠른 Hot Module Replacement는 효율적인 실시간 업데이트를 보장합니다.\n\nNative React Server Components 지원: Turbopack는 React Server Components를 기본으로 지원하여 통합을 향상시킵니다.\n\n\n\n다중 환경 최적화: 브라우저, 서버, 그리고 엣지와 같은 다양한 환경을 동시에 대상으로 삼아 최적화하며 SSR 및 React 서버 구성 요소를 지원합니다.\n\n# 🏗️ 빌드 및 프로덕션 향상 🚀\n\n## Tree-shaking 개선 사항: 🌳\n\n- 사용되지 않는 익스포트가 제거되어 프로덕션 JavaScript 번들 크기를 줄입니다 📉\n- 예: 단일 아이콘 컴포넌트를 가져오더라도 패키지에서 다른 모든 아이콘을 포함하지 않게 됩니다 🎨\n\n\n\n## 메모리 부족 충돌 방지: 💪\n\n- 대규모 앱을 위해 번들링 로직을 재구성하고 컴파일러를 최적화했습니다.\n- 새로운 `— experimental-debug-memory-usage` 플래그를 `next build`에 추가하여 메모리 성능을 디버그할 수 있습니다. 🔍 즉, 자바스크립트가 힙 사용량 및 가비지 컬렉션 통계와 같은 메모리 사용 정보를 빌드 중에 계속해서 출력합니다.\n\n## CSS 최적화: 🎨\n\n- 스타일 탐색 시 충돌을 피하기 위해 CSS를 청크로 만들었습니다. 🌈\n- CSS 청크의 순서와 병합은 import 순서로 정의되었습니다. 📂\n- 최상의 방법: CSS 모듈을 사용하고 단일 JS/TS 파일에 import하며 동일한 파일에서 전역 스타일을 import 합니다. 📂\n\n\n\n## 🔄 캐싱 개선 💾\n\n- staleTimes (실험적): ⏰ 사용자가 캐싱 휴리스틱에 대한 더 많은 제어를 원하는 현재 경험을 향상시키기 위한 것이나 완전한 솔루션이 되는 것은 아닙니다. (클라이언트 측 라우터 캐시 무효화 기간 설정을 추가 🕰️)\r\n- 기본적으로 prefetch된 라우트는 30초 동안 캐시되지만 prefetch='true'일 때는 5분 동안 캐시됩니다 📅\r\n- 기본 설정을 재정의하려면 next.config.js에서 규칙을 정의하여 사용자 정의할 수 있습니다 🛠️\n\n## 병렬 및 인터셉트 라우트: 🎡\n\n- revalidatePath 또는 revalidateTag를 사용하여 서버 액션을 호출하면 캐시를 재검증하고 보이는 슬롯을 새로고침합니다 🔄\r\n- router.refresh는 올바르게 보이는 슬롯을 새로 고치며 현재 보기를 유지합니다 🌟\n\n\n\n# 🛠️ 개발자 경험 (DX) 개선 사항 🌞\n\n## 에러 메시지 및 스택 추적: 📝 🚧\n\n- `next dev`에서 가독성 향상 🔍\n- 더 나은 에러 메시지, 오버레이 디자인 개선, 라이트 모드 및 다크 모드 지원 🌞🌙\n- 더 명확한 개발 및 빌드 로그 📜\n\n## React 수화 에러: 💧🚧\n\n\n\n- React 팀과의 협업을 통해 기본 오류 추적을 개선합니다 🤝\n- 오류가 발생한 파일 이름을 표시합니다 📂\n\nNext.js 14.2로 업그레이드하면 Turbopack의 성능, 최적화된 빌드, 개선된 캐싱, 더 나은 개발자 경험을 느낄 수 있습니다. 즐거운 코딩하세요! 👨‍💻👩‍💻🚀\n\n# 🎈 Next.js 14.2에서 무슨 변화가 있을까요? 🔍\n\n- 메모리 사용량 개선 🧠\n- 지속적인 캐싱 구현 💾\n- `next build`에 Turbopack 적용 🏗️ 여기서 추적해보세요","ogImage":{"url":"/assets/img/2024-05-14-ExplorewhatisnewinNextjs142_0.png"},"coverImage":"/assets/img/2024-05-14-ExplorewhatisnewinNextjs142_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트를 위한 전문 성능 향상 팁","description":"","date":"2024-05-14 10:11","slug":"2024-05-14-ExpertPerformanceTipsforREACT","content":"\n\n![Expert Performance Tips for REACT](/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png)\n\n웹 사이트의 성능은 사용자 경험, 검색 엔진 순위, 전환율, 비용 효율성, 경쟁 우위 및 접근성에 직접적인 영향을 미치기 때문에 중요합니다. 빠른 로딩 속도의 웹 사이트는 사용자 만족도를 높이고 이탈률을 낮추며 SEO 순위를 향상시킵니다. 또한 높은 전환율, 낮은 운영 비용 및 시장에서의 경쟁 우위를 가져다줍니다. 또한 최적화된 성능은 다양한 인터넷 연결과 장치를 사용하는 사용자를 대상으로하여 포용력을 보장합니다. 전반적으로 성능 최적화를 우선시함으로써 비즈니스 목표 달성과 웹 사이트 방문자에게 가치를 전달하는 것이 중요합니다.\n\n## 1. 비용이 많이 드는 계산에 useMemo 사용하기:\n\nReact 애플리케이션에서 데이터 변환과 같은 계산이 많이 드는 작업을 다룰 때 useMemo 훅을 사용하는 것이 중요합니다. 이를 통해 비용이 많이 드는 계산 결과를 기억하도록 할 수 있으며, 필요할 때만 다시 계산되도록 보장합니다. 종속성을 지정함으로써 언제 계산을 다시해야 하는지 제어하여 성능을 최적화할 수 있습니다.\n\n\n\n```js\nimport React, { useMemo } from 'react';\n\nconst MyComponent = ({ data }) => {\n  const transformedData = useMemo(() => {\n    // 여기에서 비싼 데이터 변환 수행\n    return data.map(item => item * 2);\n  }, [data]);\n  return (\n    <div>\n      {/* 변환된 데이터 사용 */}\n    </div>\n  );\n};\n```\n\n## 2. 메모이제이션된 함수에 useCallback 사용하기:\n\nProps로 전달된 콜백 함수는 메모이제이션되지 않으면 불필요한 다시 렌더링을 유발할 수 있습니다. useCallback 훅을 활용하여 이러한 함수를 메모이제이션함으로써 종속성이 변경될 때까지 자식 구성요소의 다시 렌더링을 방지할 수 있습니다. 이 최적화는 불필요한 렌더링 주기를 줄이며 애플리케이션의 반응성을 향상시킵니다.\n\n```js\nimport React, { useCallback } from 'react';\n\nconst ParentComponent = () => {\n  const handleButtonClick = useCallback(() => {\n    // 여기에서 버튼 클릭 처리\n  }, []);\n  return (\n    <ChildComponent onClick={handleButtonClick} />\n  );\n};\n```\n\n\n\n## 3. React.memo를 사용하여 성능 최적화하기:\n\nReact.memo 고차 컴포넌트를 사용하여 함수형 컴포넌트를 최적화할 수 있습니다. 이를 통해 컴포넌트를 기억하고, props가 변경되지 않은 경우 다시 렌더링되지 않습니다. 이 최적화는 특히 정적 props를 받는 컴포넌트의 렌더링 성능을 최적화하는 데 유용합니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = React.memo(({ prop1, prop2 }) => {\n  // 컴포넌트를 여기에 렌더링\n});\n```\n\n## 4. 효율적인 렌더링을 위한 가상 목록 사용하기:\n\n\n\n긴 데이터 목록을 렌더링하면 성능에 부정적인 영향을 미칠 수 있습니다. React-window나 react-virtualized와 같은 가상 목록 라이브러리는 화면에 보이는 항목만 렌더링하여 DOM 조작을 최소화하고 렌더링 성능을 획기적으로 향상시킴으로써 이 문제를 해결합니다.\n\n```js\nimport React from 'react';\nimport { FixedSizeList } from 'react-window';\n\nconst MyListComponent = ({ data }) => {\n  const renderRow = ({ index, style }) => {\n    const item = data[index];\n    return (\n      <div style={style}>{item}</div>\n    );\n  };\n  return (\n    <FixedSizeList\n      height={300}\n      width={300}\n      itemSize={50}\n      itemCount={data.length}\n    >\n      {renderRow}\n    </FixedSizeList>\n  );\n};\n```\n\n## 5. 지연로딩을 위한 코드 분할 사용하기:\n\n코드를 작은 관리 가능한 조각으로 분할하고 동적으로 가져오기와 React lazy와 Suspense 구성 요소를 사용하여 지연 시간을 최적화하는 것은 초기 로드 시간을 최적화하는 데 중요합니다. 필요할 때만 필요한 코드를로드함으로써 응용 프로그램의 인지 성능을 향상시킬 수 있습니다.\n\n\n\n```js\nimport React, { lazy, Suspense } from 'react';\n\nconst LazyComponent = lazy(() => import('./LazyComponent'));\nconst App = () => {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <LazyComponent />\n    </Suspense>\n  );\n};\n```\n\n## 6. React.Fragment를 사용하여 렌더링 최적화:\n\n컨테이너 없이 여러 요소를 렌더링할 때 React.Fragment 또는 그 간략한 구문을 사용하면 추가적인 DOM 노드를 생성하지 않게 됩니다. 이 최적화는 DOM을 가볍게 유지하여 렌더링 성능을 향상시키는 데 도움이 됩니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = () => {\n  return (\n    <>\n      <div>Element 1</div>\n      <div>Element 2</div>\n    </>\n  );\n};\n```\n\n\n\n## 7. 인라인 함수 정의를 피하세요:\n\n렌더 메소드 내에서 함수를 인라인으로 정의하면 각 렌더링마다 새로운 참조를 생성하여 자식 컴포넌트가 불필요하게 다시 렌더링될 수 있습니다. 이러한 함수를 렌더 메소드 외부로 추출하거나 useCallback을 사용하여 메모이제이션함으로써 렌더링 성능을 최적화할 수 있습니다.\n\n```js\nimport React, { useState } from 'react';\n\nconst MyComponent = () => {\n  const [count, setCount] = useState(0);\n  const handleIncrement = () => {\n    setCount(count + 1);\n  };\n  return (\n    <div>\n      <button onClick={handleIncrement}>증가</button>\n      <p>카운트: {count}</p>\n    </div>\n  );\n};\n```\n\n## 8. 성능 최적화를 위해 React.PureComponent 또는 React.memo를 사용하세요:\n\n\n\nReact.PureComponent 또는 React.memo를 활용하면 깊은 계층의 prop 비교를 수행하여 컴포넌트의 불필요한 다시 렌더링을 방지하는 데 도움이 됩니다. 이 최적화는 특히 클래스 컴포넌트 (PureComponent)와 함수형 컴포넌트 (React.memo로 메모이제이션된)에서 유용하며, prop 비교를 통해 렌더링 오버헤드를 크게 줄일 수 있습니다.\n\n```js\nimport React, { PureComponent } from 'react';\n\nclass MyComponent extends PureComponent {\n  render() {\n    // 여기서 컴포넌트 렌더링하기\n  }\n}\nexport default MyComponent;\n```\n\n## 9. 컴포넌트 프로파일링:\n\nReact DevTools와 같은 React의 내장 프로파일링 도구를 사용하여 컴포넌트에서 성능 병목 현상을 식별하세요. 프로파일링을 통해 불필요한 다시 렌더링이나 비효율적인 상태 관리와 같은 최적화가 필요한 부분을 파악할 수 있습니다.\n\n\n\n## 10. 트리 조정 최적화:\n\n컴포넌트 트리의 깊이를 최소화하고 복잡한 컴포넌트를 작고 관리하기 쉬운 부분으로 나누어 불필요한 렌더링을 피하세요. 이렇게 하면 업데이트 중에 조정해야 할 컴포넌트의 수를 줄여 성능을 향상시킬 수 있습니다.\n\n## 11. 불변 데이터 구조:\n\n불변 데이터 구조인 Immutable.js나 Immer와 같은 것을 사용하여 상태 관리를 최적화하세요. 불변 데이터를 사용하면 상태 변경을 비교하고 컴포넌트를 언제 업데이트해야 하는지 결정하는 것이 더 쉽습니다. 이렇게 하면 더 효율적인 렌더링과 성능 향상이 가능합니다.\n\n\n\n```js\nimport { Map } from 'immutable';\n\nconst initialState = Map({\n  counter: 0,\n  data: Map({}),\n});\n\n// 상태 업데이트\nconst newState = state.update('counter', counter => counter + 1);\n```\n\n## 12. 서버 측 렌더링 (SSR):\n\n서버 측 렌더링을 구현하여 React 컴포넌트를 서버에서 사전 렌더링하고 정적 HTML을 클라이언트에 제공하십시오. SSR은 초기 로드 시간을 줄이고 검색 엔진 크롤러가 콘텐츠를 효과적으로 색인화할 수 있도록 함으로써 지각된 성능을 향상시킵니다.\n\n## 13. Route-Based Splitting을 사용한 코드 분할:\n\n\n\n페이지 또는 라우트마다 필요한 JavaScript만로드하기 위해 라우트 기반 코드 분할을 구현하세요. 이 기술은 필요할 때 비동기적으로 코드를 로드하여 초기 번들 크기를 줄이고로드 시간을 개선합니다.\n\n```js\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nconst Home = lazy(() => import('./Home'));\nconst About = lazy(() => import('./About'));\n\nconst App = () => {\n  return (\n    <Router>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Switch>\n          <Route exact path=\"/\" component={Home} />\n          <Route path=\"/about\" component={About} />\n        </Switch>\n      </Suspense>\n    </Router>\n  );\n};\n\nexport default App;\n```\n\n## 14. 디바운싱과 스로틀링:\n\nAPI 요청이나 이벤트 핸들러와 같은 비용이 많이 드는 작업의 빈도를 제한하기 위해 디바운싱과 스로틀링 기술을 사용하세요. 디바운싱은 지정된 지연 후에 함수가 실행되도록 보장하고, 스로틀링은 함수가 호출될 속도를 제한하는데 사용됩니다. 둘 다 성능 병목 현상을 방지할 수 있습니다.\n\n\n\n```js\nimport React, { useState } from 'react';\nimport { debounce, throttle } from 'lodash';\n\nconst SearchInput = () => {\n  const [searchTerm, setSearchTerm] = useState('');\n\n  // 지연된 검색 처리기\n  const handleDebouncedSearch = debounce(search => {\n    // 검색 작업 수행\n    console.log('다음을 검색 중입니다:', search);\n  }, 500);\n\n  // 스크롤 쓸대 처리기\n  const handleThrottledScroll = throttle(() => {\n    // 스크롤 관련 작업 수행\n    console.log('스크롤 중...');\n  }, 100);\n\n  const handleChange = event => {\n    const { value } = event.target;\n    setSearchTerm(value);\n    handleDebouncedSearch(value); // 지연된 검색\n  };\n\n  return (\n    <input\n      type=\"text\"\n      value={searchTerm}\n      onChange={handleChange}\n      onScroll={handleThrottledScroll} // 스크롤 쓸대\n    />\n  );\n};\n\nexport default SearchInput;\n```\n\n## 15. 이벤트 핸들러 최적화:\n\n렌더 메서드 내부에서 요소에 직접 이벤트 리스너를 추가하는 것은 메모리 누수 및 성능 문제를 일으킬 수 있습니다. 대신, 이벤트 위임을 사용하거나 렌더 주기 외부에서 프로그래밍 방식으로 이벤트 리스너를 추가하여 이벤트 처리를 최적화하세요.\n\n```js\nimport React, { useEffect, useRef } from 'react';\n\nconst ScrollListener = () => {\n  const scrollRef = useRef(null);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      // 스크롤 관련 작업 수행\n      console.log('스크롤 중...');\n    };\n\n    // 마운트 시 이벤트 리스너 추가\n    scrollRef.current.addEventListener('scroll', handleScroll);\n\n    // 언마운트 시 이벤트 리스너 제거\n    return () => {\n      scrollRef.current.removeEventListener('scroll', handleScroll);\n    };\n  }, []); // 빈 종속성 배열은 효과가 한 번만 실행되도록 함\n\n  return (\n    <div ref={scrollRef} style={{ overflowY: 'scroll', height: '300px' }}>\n      {/* 스크롤 가능한 콘텐츠 */}\n    </div>\n  );\n};\n\nexport default ScrollListener;\n```\n\n\n\n## 16. 불필요한 부작용 피하기:\n\n함수형 컴포넌트 내의 부작용에 주의하세요. API 호출이나 상태 변경과 같은 작용은 불필요한 재랜더링을 유발할 수 있습니다. useEffect 훅을 사용하여 적절한 의존성 배열을 설정하여 부작용이 발생하는 시기를 제어하고 컴포넌트 렌더링을 최적화하세요.\n\n## 17. 이미지 최적화:\n\n손실 없는 압축(품질을 희생하지 않고 파일 크기를 줄이는)이나 손실 압축(일부 품질을 희생하면서 파일 크기를 줄이는)과 같은 압축 기술을 사용하여 이미지 파일 크기를 줄이세요. WebP, JPEG XR 또는 AVIF와 같은 이미지 형식을 사용하여 JPEG나 PNG와 같은 전통적인 형식보다 더 나은 압축률과 품질을 제공하세요. 또한 사용자의 기기와 화면 크기에 따라 적절한 크기의 이미지를 제공하기 위해 srcset 및 sizes 속성을 사용하여 반응형 이미지를 서비스하세요. 이를 통해 불필요한 데이터 전송을 줄이고 로딩 시간을 향상시킬 수 있습니다. 화면에 바로 나타나지 않는 이미지에 대해 lazy loading을 구현하여 화면에 나타나면 로드되도록 하여 중요한 콘텐츠를 우선적으로 처리하고 초기 페이지 로딩 성능을 향상시키세요. 마지막으로 사용자의 기기와 네트워크 상황에 따라 이미지를 자동으로 최적화하고 제공하는 이미지 CDN 서비스를 고려해보세요.\n\n\n\n감사합니다. 끝까지 오셔서 기쁩니다.\n\n저랑 소통해요. 이 링크를 클릭해서 더 많이 알아보세요.\n\n다음 블로그를 게시할 때 알림을 받으려면 구독해주세요. 다음에 또 만나요.","ogImage":{"url":"/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png"},"coverImage":"/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기","description":"","date":"2024-05-13 00:34","slug":"2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs","content":"\n\n![Node.js Logo](/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png)\n\nNode.js의 핵심에 오신 것을 환영합니다. 여기는 이벤트가 다스리고 비동기가 왕이 되는 곳입니다. 이 시리즈에서는 Node.js의 이벤트 주도 아키텍처를 해독하고 비동기 능력에 대해 자세히 살펴볼 것입니다. 초보자이든 경험이 풍부한 개발자이든 Node.js의 비밀을 해제할 준비를 해주세요. 여정을 시작해봅시다!\n\n1. 이벤트 주도 아키텍처:\n\nNode.js는 이벤트 주도 아키텍처에서 작동하며 작업은 이벤트 루프를 통해 비동기적으로 관리됩니다. 이 루프는 바쁜 교차로에서 교통 규제자와 유사하게 여러 작업을 효율적으로 동시에 처리합니다. 들어오는 요청이나 파일 작업과 같은 이벤트는 논블로킹 방식으로 대기열에 추가되고 처리되어 각 작업이 완료될 때까지 기다릴 필요 없이 원활하게 실행됩니다. 이 아키텍처를 통해 Node.js는 다양한 동시 작업을 효율적으로 처리하여 반응성이 뛰어나고 확장 가능한 애플리케이션을 만들기에 이상적입니다.\n\n\n\n2. Node.js에서 이벤트 처리하기:\n\nNode.js에서는 EventEmitter 클래스를 통해 이벤트 처리를 원활하게 할 수 있습니다. 이 클래스를 사용하면 개발자가 사용자 정의 이벤트를 생성하고 해당 이벤트에 대한 리스너를 붙일 수 있어 응용 프로그램 내에서 비동기 통신을 쉽게 할 수 있습니다.\n\n다음은 Node.js에서 이벤트 처리를 시작하는 방법입니다:\n\n```js\n// EventEmitter 클래스를 가져오기\nconst EventEmitter = require('events');\n\n// EventEmitter 클래스의 인스턴스 생성\nconst myEmitter = new EventEmitter();\n\n// 사용자 정의 이벤트 생성 및 리스너 붙이기\nmyEmitter.on('sayHi', () => {\n  console.log('Hi!');\n});\n\nmyEmitter.on('sayGoodbye', () => {\n  console.log('Goodbye!');\n});\n\n// 이벤트 발생\nmyEmitter.emit('sayHi'); // 출력: Hi!\nmyEmitter.emit('sayGoodbye'); // 출력: Goodbye!\n```\n\n\n\n3. 비동기 프로그래밍:\n\n비동기 프로그래밍은 Node.js에서의 기본 개념으로, 작업을 주 프로그램 흐름과 독립적으로 실행할 수 있게 합니다. 이 접근 방식은 I/O 작업, 네트워크 요청 또는 데이터베이스 쿼리와 같이 완료까지 시간이 걸릴 수 있는 작업을 처리할 때 주 프로그램 흐름을 차단하지 않고 다른 작업을 실행하는 데 중요합니다.\n\nNode.js에서 비동기 프로그래밍은 고성능이면서 블로킹되지 않는 애플리케이션을 개발하는 데 필수적입니다. 다음은 Node.js에서 비동기 프로그래밍에 사용되는 주요 메커니즘을 살펴보겠습니다:\n\n- 콜백 함수: 콜백 함수는 다른 함수의 인수로 전달되어 작업이 완료되면 실행됩니다. Node.js에서 비동기 프로그래밍의 기본 구성 요소입니다. 그러나 여러 중첩된 콜백을 관리하는 것은 코드를 읽거나 유지하기 어렵게 만들 수 있는 콜백 지옥에 빠질 수 있습니다.\n- 프로미스: 프로미스는 비동기 작업을 처리하고 콜백 지옥을 줄이는 더 구조화된 방법을 제공합니다. 프로미스는 비동기 작업의 최종 완료(또는 실패)를 나타내며 .then() 및 .catch() 메서드를 사용하여 작업을 연결할 수 있습니다. 프로미스는 코드 가독성과 유지 관리성을 향상시킵니다.\n- Async/Await: Async/Await은 ES2017 (ES8)에서 소개된 구문 설탕으로, 비동기 코드를 더욱 간단하게 작성할 수 있습니다. 이를 사용하면 동기적으로 보이는 비동기 코드를 작성할 수 있어 이해하기 쉽고 유지하기 쉽습니다. Async 함수는 암묵적으로 프로미스를 반환하며, await 키워드는 async 함수 내에서 비동기 작업의 완료를 기다리기 위해 사용됩니다.\n\n\n\n```js\n// 콜백 함수를 사용한 예시\nconst fs = require('fs');\n\nfs.readFile('example.txt', 'utf8', (err, data) => {\n  if (err) {\n    console.error('파일을 읽는 중 오류 발생:', err);\n    return;\n  }\n  console.log('파일 내용:', data);\n});\n\nconsole.log('파일 읽는 중...');\n\n// 프로미스를 사용한 예시\nconst readFilePromise = new Promise((resolve, reject) => {\n  fs.readFile('example.txt', 'utf8', (err, data) => {\n    if (err) {\n      reject(err);\n      return;\n    }\n    resolve(data);\n  });\n});\n\nreadFilePromise\n  .then(data => {\n    console.log('파일 내용:', data);\n  })\n  .catch(err => {\n    console.error('파일을 읽는 중 오류 발생:', err);\n  });\n\nconsole.log('파일 읽는 중...');\n\n// Async/Await를 사용한 예시\nasync function readFileAsync() {\n  try {\n    const data = await fs.promises.readFile('example.txt', 'utf8');\n    console.log('파일 내용:', data);\n  } catch (err) {\n    console.error('파일을 읽는 중 오류 발생:', err);\n  }\n}\n\nreadFileAsync();\nconsole.log('파일 읽는 중...');\n```\n\n4. 이벤트 루프의 동작:\n\n이벤트 루프는 Node.js의 핵심으로, 비동기 작업을 효율적으로 실행하는 역할을 합니다. 이벤트 루프의 내부 동작 방식을 간단히 살펴보고, Node.js에서 비동기 작업을 처리하는 방법에 대해 알아봅시다.\n\n1. 이벤트 큐:\n\n\n\n- Node.js에서 I/O 작업이나 타이머와 같은 비동기 작업을 만나면, 이러한 작업은 즉시 실행되지 않습니다.\n- 대신에, 이러한 작업은 이벤트 큐에 들어가서 처리될 차례를 기다립니다.\n\n2. 이벤트 루프 반복:\n\n- 이벤트 루프는 계속해서 반복하면서, 실행 준비가 된 이벤트 큐의 작업을 확인합니다.\n- 이벤트 큐가 비어있다면, 이벤트 루프는 작업이 추가될 때까지 기다립니다.\n\n3. 실행 단계:\n\n\n\n- 이벤트 큐에서 작업이 검색되면 실행 단계로 들어갑니다.\n- 작업이 처리되고 동기 작업인 경우 즉시 실행됩니다.\n\n4. Non-Blocking I/O:\n\n- 비동기 작업인 I/O 작업과 같은 작업의 경우, 이벤트 루프는 작업을 기저 시스템에 위임하여 Node.js가 그 동안 다른 작업을 계속 실행할 수 있도록 합니다.\n- 비동기 작업이 완료되면 해당 작업과 연결된 콜백이 콜백 큐에 배치됩니다.\n\n5. 콜백 큐:\n\n\n\n- 비동기 콜백은 연관된 작업들이 완료된 후에 콜백 큐에 저장됩니다.\n- 이벤트 루프는 각 반복마다 콜백 큐를 확인하여 실행 대기 중인 콜백이 있는지 확인합니다.\n\n6. 콜백 실행:\n\n- 이벤트 루프가 콜백 큐에서 콜백을 만나면 하나씩 검색하고 실행합니다.\n- 이 과정을 통해 비동기 작업이 완료된 순서대로 실행되어 프로그램 로직의 무결성을 유지합니다.\n\n![이미지](/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_1.png)\n\n\n\n- 이벤트 기반 아키텍처:\n\n- Node.js는 이벤트 기반 아키텍처에서 작동하며, 작업들이 이벤트 루프를 통해 비동기적으로 관리됩니다.\n- 이벤트 루프는 이벤트를 대기열에 넣고 처리함으로써 여러 작업을 효율적으로 동시에 처리합니다.\n\n2. Node.js에서 이벤트 처리:\n\n- Node.js는 EventEmitter 클래스를 제공하여 사용자 정의 이벤트를 생성하고 해당 이벤트에 청취자(listener)를 연결할 수 있습니다.\n- 이벤트와 청취자는 Node.js 애플리케이션 내에서 비동기 통신을 용이하게 만듭니다.\n\n\n\n3. 비동기 프로그래밍:\n\n- 비동기 프로그래밍은 주 프로그램 흐름과 독립적으로 작업을 실행할 수 있어 애플리케이션의 응답성을 향상시킵니다.\n- 콜백, 프로미스, 그리고 async/await는 Node.js에서 비동기 작업을 처리하는 데 사용되는 메커니즘입니다.\n- 콜백은 기본적이지만 콜백 지옥에 빠질 수 있습니다. 프로미스와 async/await는 보다 구조화되고 가독성이 좋은 대안을 제공합니다.\n\n4. 이벤트 루프 동작:\n\n- Node.js의 이벤트 루프는 지속적으로 반복하여 이벤트 큐에서 작업을 확인하고 처리합니다.\n- I/O 작업과 같은 비동기 작업은 하부 시스템에 위임되어 Node.js가 여러 동시 작업을 효율적으로 처리할 수 있게 합니다.","ogImage":{"url":"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png"},"coverImage":"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png","tag":["Tech"],"readingTime":5}],"page":"66","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}