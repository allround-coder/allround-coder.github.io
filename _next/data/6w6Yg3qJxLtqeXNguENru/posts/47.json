{"pageProps":{"posts":[{"title":"점진적 향상과 JavaScript 프레임워크  복잡한 관계","description":"","date":"2024-05-14 15:54","slug":"2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship","content":"\n\n<img src=\"/assets/img/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship_0.png\" />\n\n진보적 개선(PE)과 프론트엔드 JavaScript 프레임워크 간의 호환성 문제가 오랫동약 해결되지 못해, 모든 사용 사례를 만족시킬 수 있는 현대 웹 애플리케이션을 구축하는 것이 실제로 어려워졌습니다. 그러나 프론트엔드 기술의 큰 변화로 우리에게 더 많은 옵션이 제공되고 있습니다. 이 기사에서 현대화된 디자인 패턴과 사용 사례를 평가하면서 비즈니스에 미치는 영향을 고려해, 프로젝트에 가장 적합한 방향을 선택할 수 있습니다.\n\n## 진보적 개선이 해결하는 문제는 무엇인가요?\n\n진보적 개선(PE)의 일반적인 정의는 HTML만으로도 응용 프로그램을 사용할 수 있게 보장하여 사용자에게 높은 신뢰 수준을 제공할 수 있다는 것입니다. 다른 '층', 예를 들어 글꼴, 스타일 및 JavaScript와 같은 것들을 개선으로 간주합니다. 이 정의에는 주목할 만한 도전 과제가 있지만, 이 기사에서는 해당 정의를 사용하겠습니다.\n\n\n\nGov.uk은 \"모든 사용자에게 최대한의 성공 기회를 제공하려고 노력합니다\"라고 설명하고 있어요. 자바스크립트를 제대로 불러오거나 실행하지 못하는 방문자 수가 적더라도 무시할 수 없는 문제입니다. Gov.uk은 견고한 테스트를 실시하여 방문자 중 1.1%가 'JavaScript 향상 기능'을 이용할 수 없는 것으로 밝혀졌어요. 그러므로 점진적 향상 방식으로 제작한 웹사이트는 거의 100%의 사용자에게 사용 가능해야 합니다.\n\n## UI 프레임워크가 해결하는 문제는 무엇인가요?\n\nUI 프레임워크는 다양한 아키텍처 및 응용프로그램 설계 문제를 해결해 왔습니다. 이를 통해 UI, 비즈니스 논리 및 데이터 간 분명한 역할 분리가 가능해지며, 복잡한 상호 작용을 확장 가능한 방식으로 처리합니다. 이는 CDD(Component-Driven Development)를 가능하게 하며, 기관이 UI 자산을 설계, 개발 및 관리하는 방식을 혁신시켰습니다. Handlebars와 같은 템플릿 언어는 이 문제를 해결하려 애썼지만, UI 프레임워크만큼의 강력함, 구조 및 유연성을 제공하지 못했어요.\n\n# 일반적인 아키텍처들\n\n\n\n우리가 사용할 수 있는 주요 패턴을 살펴보겠습니다:\n\n## SPA(Single Page Apps)\n\nUI는 클라이언트 측 스크립팅(Javascript)과 종종 React 또는 Angular 같은 도구를 사용하여 제시되고 관리됩니다.\n\nSPA가 인기 있는 이유는:\n\n\n\n- 페이지의 일부만 업데이트되는 매끄러운 사용자 경험\n- 웹 UI는 사용자의 동작에 매우 민첩하게 반응합니다\n- UI 개발자에게 GUI를 구축하는 통일된 모듈식 방법이 하나 있습니다\n\n이들이 점진적 향상 요구 사항을 충족하나요?\n\nHTML이 서버에서 렌더링되지 않아 사용자가 JavaScript가 로드되고 구문 분석되고 실행되기 전에 상호 작용할 UI가 없습니다. 이는 그들이 PE 요구 사항을 충족하지 못한다는 것을 의미합니다.\n\n## PWA(점진적 웹 앱)\n\n\n\nPWAs(Progressive Web Apps)는 웹 기술을 사용하여 사용자에게 네이티브 앱과 유사한 경험을 제공합니다. 그들의 이름이 진화적 개선을 사용하여 구축된 것으로 보이지만 항상 그렇지는 않을 수 있습니다. 그러나, PWA는 네트워크를 개선으로 취급하는 로컬 캐싱을 사용하기 때문에 다른 형태의 웹 앱보다 진화적일 가능성이 높습니다.\n\nPWAs가 인기 있는 이유는 무엇인가요?\n\n- 네이티브 앱과 유사한 경험 (설치 가능, 오프라인 우선, 하드웨어 기능 접근)\n- 크로스 플랫폼 (한 번 빌드하면 어디서든 배포 가능)\n\nPWA는 진화적 개선 요구 사항을 충족시키나요?\n\n\n\nPWAs는 Service Worker라는 JavaScript 기능에 의존하지만, 개발자들에게 여러 캐싱 전략을 제공하여 HTML 중심의 응용 프로그램을 만들고 설치 가능하며 오프라인으로 작동하는 것이 가능합니다. 그러나 HTML이 렌더링되는 방법은 여전히 고려되어야 합니다. 일부 PWAs는 콘텐츠가 JavaScript에 의해 렌더링되는 SPA로, 이러한 경우 준수하지 않을 수 있습니다.\n\n## JAMStack\n\nJAMStack을 사용하여 구축된 응용 프로그램은 빌드 서버를 통해 페이지를 렌더링하고, 다른 소프트웨어 구성 요소(CMS, PIM 또는 UI 코드 베이스 등)에서 감지된 변경에 기반하여 HTML을 생성합니다.\n\nJAMStack이 인기있는 이유는 무엇인가요?\n\n\n\n- 관심사 분리가 잘 되어 있습니다.\n- 안전합니다 — 공격 표면이 작습니다.\n- 페이지가 미리 렌더링되어 빠릅니다.\n\n이것들은 점진적 향상 요구 사항을 충족합니까?\n\nJAMStack 웹사이트는 PE 요구 사항을 충족할 수 있지만, MPA(아래 참조)와 마찬가지로 풍부하고 동적이며 매우 개인화된 UI를 구축하기 위해 다른 패턴을 사용해야 할 수 있으며, 이로 인해 복잡성과 비용이 증가할 수 있습니다.\n\n## Multi-page apps (MPA)\n\n\n\nMPAs는 각 '페이지'가 사용자가 새 문서로 이동할 때 서버에서 로드되는 초기 웹 사이트 패턴입니다.\n\nMPAs가 인기 있는 이유는 무엇인가요?\n\n- 개발 및 유지 관리가 간단합니다 (UI 복잡성이 낮은 경우)\n- CMS, 전자 상거래 및 CRM 시스템과 같은 다양한 경험 플랫폼에서 지원됩니다.\n\n점진적 향상 요구 사항을 충족시킬까요?\n\n\n\n네, MPAs는 서버 사이드 렌더링 또는 정적 사이트 생성을 통해 사전 렌더링에 의존합니다. 두 경우 모두 각 제공된 페이지가 콘텐츠와 네이티브 상호 작용 요소로 가득 차 있어 JavaScript 없이도 사용자가 탐색할 수 있는 UI를 제공합니다.\n\n## 하위 패턴\n\n사용 중인 몇 가지 하위 패턴을 간단히 언급하는 것이 좋습니다:\n\n- Islands: 페이지 일부가 클라이언트 측 스크립팅에 의해 사용될 수 있는 형태\n- Streaming: UI 구성 요소를 점진적으로 클라이언트로 렌더링할 수 있는 방법\n\n\n\n양쪽 경우 모두 점진적 향상이 가능하지만 서버에 대체 콘텐츠를 생성해야하는 추가적인 노력이 필요합니다.\n\n# 사용 사례에 맞는 아키텍처 선택\n\n로리 보스는 두 가지 명확한 사용 사례를 위해 빌드해야 한다고 주장했습니다: 다중 페이지 앱 또는 \"사이트\" (블로그 등 각기 다른 페이지에서 사용되는 정적 텍스트 및 이미지)와 단일 페이지 웹 앱 또는 \"앱\" (은행 포털과 같이 작업 완료 또는 풍부한 미디어 소비를 가능하게 하는 대화형 도구). 그러나 이러한 사용 사례의 조합을 고려해야 하는 웹 애플리케이션이 많습니다. Jeremy Keith가 말한대로 \"그것은 스펙트럼(spectrum)이다\". 이는 많은 대규모 온라인 경험이 서버 측 렌더링(SSR), 정적 사이트 생성(SSG) 및 클라이언트 측 렌더링(CSR)의 다양한 아키텍처 패턴의 조합을 사용한다는 것을 의미합니다. 제가 최근 이끈 프로젝트 중 하나에서는 공개 사이트를 SEO 요구 사항을 충족시키기 위해 정적 사이트로 제공하고, 비공개 회원 사이트는 단일 페이지 앱으로 제공했습니다.\n\n# 규정 준수하기\n\n\n\n많은 기관들에게 PE는 솔루션 디자인 선택지입니다. 하지만 영국의 CDDO 같은 가이드라인을 따라야 하는 경우, ‘필수 내용’ 제공과 JS가 대신 처리하는 부분을 어디에서 구분해야 하는지 알기 어려울 수 있습니다.\n\nGov.uk은 순수 PE 접근 방식을 예외로 처리하는 흥미로운 예제를 제공합니다: “최근 React를 사용하여 웹 채팅 시스템을 프로토타입으로 만들었습니다. JavaScript를 요구하지 않는 필수 웹 채팅의 기본 수준을 상상하기 어렵지만, 우리는 개발하는 모든 웹 채팅 시스템이 최소한의 표준 연락처 양식을 함께 갖도록 할 것입니다\".\n\n포괄성 측면에서 이러한 접근 방식을 완전히 지지하지만, 비즈니스적인 관점에서 이는 한 가지 문제를 해결하기 위해 두 가지 솔루션을 구축하는 것이라는 점을 인지해야 합니다. 자주 그 비용이 투자할 가치가 있는지를 주장할 수 있습니다. 모든 사용자의 요구를 충족시키면서 투자 비용이 금방 회수될 수 있습니다. 예를 들어, 바쁜 전자 상거래 사업체의 경우, 해당 투자는 출시 몇 주 내에 자체 회수될 수 있습니다.\n\n서비스를 완전히 앱과 같은 것으로 구축해야 하지만 PE를 지원해야 하는 상황에 놓인다면 다음과 같은 선택지가 있을 것입니다:\n\n\n\n- 네이티브 모바일 앱을 개발하여 PE 요건을 면제받을 수는 있지만, 모바일 앱의 배포 제한으로 인해 사용자 접속에 제약이 생길 수도 있습니다 (웹과는 달리)\n- 가능하다면 웹 기반 앱과 HTML을 우선으로 하는 대체 방안을 개발하세요.\n- 웹 기반 앱을 개발하고 사용자가 서비스를 이용할 수 있는 다른 수단 (예: 콜센터)을 제공하세요.\n- 두 가지 솔루션을 구축하는 데 필요한 복잡한 기능과 관련 비용을 고려하여 규제 기관에 면제 사례를 제출하세요.\n\n# 청와대에 가서 케이크도 먹고 싶다면?\n\n위 사항을 고려할 때, 우리가 대중들의 기대에 부응하면서 포괄적이고 매력적인 애플리케이션을 구축하는 데 도움이 되는 패턴과 도구는 무엇이 있는지 살펴보겠습니다.\n\n최근 몇 년간 렌더링이나 메타 프레임워크로 불리는 새로운 클래스의 프레임워크가 등장했습니다. 이들은 거대한 UI 프레임워크 커뮤니티를 중심으로 구축되었으며, 여러 방식으로 렌더링될 수 있는 동시에 컴포넌트 중심 개발을 지원하는 디커플드 프런트엔드를 조직이 구축해야 한다는 요구에 대응했습니다.\n\n\n\n가장 잘 알려진 메타 프레임워크는 Next.JS와 Gatsby로 한동안 치열하게 경쟁해 왔습니다. Next.js는 개발자들의 지지를 얻고 Vercel(이전의 Zeit)로부터 상당한 투자를 받아 시장을 선도하는 지도를 차지했습니다.\n\n![이미지](/assets/img/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship_1.png)\n\nNext.js는 비교적 성숙하고 인기가 많지만 Marko, Astro, Fresh, Rocket, Enhance와 같은 새로운 도전자들이 있습니다. 각각은 약간 다른 것을 제공하지만 대부분 성능과 개발자 경험(DX)에 초점을 맞추고 있습니다.\n\n이러한 메타 프레임워크의 성공은 지원하는 기본 UI 프레임워크의 성공에 의존한다는 것을 명심해야 합니다. 대부분은 특정 도구 하나만 지원하며, Next.js(React), Nuxt(Vue), Sveltekit(Svelte) 등의 경우입니다. 일부는 UI 도구의 종속성이 없는데, 그중 Astro가 있습니다.\n\n\n\n대규모 UI 개발을 지원하면서 점진적 개선을 지원하는 프래임워크를 제공하는 주목할 만한 경쟁자가 Remix입니다. 마이클 잭슨의 작품으로, 많은 개발자들에게 공감되는 점진적 개선 철학을 갖고 있습니다. 최근 Shopify에 인수되었으며, 시장 선도적인 위치로 떠오를 가능성이 높습니다.\n\n# 결론\n\n이 기사에서는 웹 애플리케이션을 위한 (분리된) 사용자 인터페이스를 구축할 때 중요한 패턴과 도구를 살펴보고 사용 사례 및 비즈니스 제약 사항을 고려했습니다.\n\n이 분야는 수요로 인해 중요한 성장과 변화 기간을 겪고 있으며, 자금을 낭비하지 않고 올바른 접근 방식을 선택하는 것이 어려울 수 있습니다. 많은 선택지가 있어서 좋지만, 여전히 우리가 직면해야 하는 심오한 도전이 있습니다: 많은 사람들이 웹 기술을 사용해 네이티브 모바일/데스크톱 앱을 만들고자 하지만, 이는 목적에 맞지 않습니다. 이 블로그 글에 대한 돔의 댓글이 잘 설명하고 있습니다:\n\n\n\n아직 웹 UI를 배달하는 데 사용할 수 있는 단일한 배포 가능한 이진 파일이 없습니다. 그러나 웹 어셈블리 (WASM)가 잠재적인 해결책으로 등장했습니다. 이는 우리가 아마도 풍부한 웹 애플리케이션을 구축하는 데 잘못된 기술을 사용하고 있다는 기본적인 문제를 해결할 수 있을 것입니다. WebAssembly가 꾸준히 발전하고 전통적인 HTML 기반 애플리케이션에 도전하고 있지만, 현재로서는 JavaScript를 통해 로드해야 하며, 따라서 PE 요구 사항을 충족하지 못합니다.\n\n그동안, 우리는 우리가 가진 옵션을 받아들이고 경우에 따라 비용 대 수익을 따져야 합니다.","ogImage":{"url":"/assets/img/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship_0.png"},"coverImage":"/assets/img/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship_0.png","tag":["Tech"],"readingTime":7},{"title":"자바스크립트 인터뷰 마스터하기 재미있는 20가지 질문과 상세한 해결책","description":"","date":"2024-05-14 15:53","slug":"2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions","content":"\n\n![이미지](/assets/img/2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions_0.png)\n\n자바스크립트 인터뷰는 무서울 수 있지만, 준비와 연습을 통해 심지어 가장 어려운 질문에도 대처할 수 있습니다. 이 블로그에서는 다음과 같은 20가지 흥미로운 자바스크립트 인터뷰 질문을 자세한 해설과 예시와 함께 살펴보며, 다음 인터뷰에서 뛰어난 성과를 낼 수 있도록 돕겠습니다.\n\n## 1. 자바스크립트 호이스팅이란 무엇인가요? 예를 들어 설명해주세요.\n\n- 호이스팅은 자바스크립트의 기본 동작으로서 선언을 현재 스코프의 맨 위로 이동하는 것을 말합니다.\n\n\n\n예를 들어:\n\n```js\nconsole.log(x); // undefined\nvar x = 5\n```\n\n## 2. 자바스크립트에서 클로저란 무엇인가요? 예시를 제공해주세요.\n\n- 클로저는 외부 함수의 실행이 완료된 후에도 렉시컬 스코프에서 변수에 대한 접근 권한을 유지하는 함수입니다.\n\n\n\n예시:\n\n```js\nfunction outer() {\nvar x = 10;\nreturn function inner() {\nconsole.log(x);\n}\n}\nvar closureFunc = outer();\nclosureFunc(); // logs 10\n```\n\n## 3. 자바스크립트의 이벤트 버블링과 캡처에 대해 설명해 주세요.\n\n- 이벤트 버블링은 내부 요소에서 발생한 이벤트가 외부 조상 요소로 전파되는 것을 말합니다. 이벤트 캡처는 그 반대로, 이벤트가 먼저 바깥 요소에 의해 캡처되는 것을 의미합니다.\n\n\n\n예시:\n\n```js\ndocument.getElementById(\"inner\").addEventListener(\"click\", function() {\nconsole.log(\"Inner clicked\");\n}, true); // useCapture를 true로 설정하여 캡처 단계에서 이벤트를 처리합니다.\n```\n\n## 4. 자바스크립트에서 `==`와 `===` 연산자의 차이점은 무엇인가요?\n\n`==` 연산자는 형 변환을 수행한 후에 등가성을 확인하며, 즉 비교 전에 피연산자를 동일한 유형으로 변환합니다. 반면에 `===` 연산자(엄격한 동등 연산자)는 형 변환을 수행하지 않고 등가성을 확인합니다. 이 연산자는 피연산자의 값과 유형을 직접 비교합니다.\n\n\n\n예시:\n\n```js\n1 == '1'; // true\n1 === '1'; // false\n```\n\n## 5. 자바스크립트에서 프로토타입을 예를 들어 설명해보세요.\n\n- 자바스크립트에서, 객체는 속성을 상속하는 프로토타입을 가지고 있습니다.\n\n\n\n예시:\n\n```js\nvar person = {\nname: \"John\",\nage: 30\n};\nconsole.log(person.hasOwnProperty('name')); // true\nconsole.log(person.hasOwnProperty('toString')); // false\n```\n\n## 6. 자바스크립트에서 이벤트 위임(Event Delegation)이란 무엇인가요? 예시를 제공해주세요.\n\n- 이벤트 위임은 개별 자식 요소에 여러 개의 리스너를 추가하는 대신 부모 요소에 하나의 이벤트 리스너를 연결하는 기술입니다.\n\n\n\n예시:\n\n```js\ndocument.getElementById('parent').addEventListener('click', function(event) {\nif (event.target.tagName === 'LI') {\nconsole.log('List item clicked');\n}\n});\n```\n\n## 7. 자바스크립트의 Promise 개념을 설명해보세요.\n\n- Promise는 현재 사용 가능할 수도 있고, 미래에 사용 가능할 수도 있으며, 아예 사용 불가능할 수도 있는 값을 나타냅니다. 이들은 비동기 프로그래밍에 사용됩니다.\n\n\n\n예시:\n\n```js\nconst promise = new Promise((resolve, reject) => {\nsetTimeout(() => {\nresolve('해결됨!');\n}, 2000);\n});\npromise.then((result) => {\nconsole.log(result); // 해결됨!\n});\n```\n\n## 8. 자바스크립트의 이벤트 루프는 무엇인가요? 그 작동 방식을 설명해주세요.\n\n- 이벤트 루프는 비동기 작업을 처리하는 프로세스입니다. 이는 계속해서 호출 스택과 작업 큐를 확인하며, 스택이 비어 있을 때 큐에서 작업을 스택으로 밀어넣습니다. 이를 통해 자바스크립트가 비동기 작업을 효율적으로 처리할 수 있게 됩니다.\n\n\n\n## 9. 자바스크립트의 Arrow Functions 개념을 설명해주세요. 예시를 제공해주세요.\n\n- Arrow Functions은 자바스크립트에서 함수를 더 간결하게 작성하는 방법입니다. 전통적인 함수 표현식에 비해 더 짧은 구문을 가지고 있으며 자체 `this`를 바인딩하지 않습니다.\n\n예시:\n\n```js\nconst add = (a, b) => a + b;\nconsole.log(add(2, 3)); // 5\n```\n\n\n\n## 10. 자바스크립트에서 `this` 키워드란 무엇인가요? 동작 방식을 설명해주세요.\n\n- `this` 키워드는 자기 자신이 속한 객체를 가리킵니다. 그 값은 함수가 호출된 방식에 따라 결정됩니다.\n\n예시:\n\n```js\nconst obj = {\n  name: 'John',\n  greet() {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\nobj.greet(); // Hello, John!\n```\n\n\n\n## 11. 자바스크립트에서 프로토타입 상속 개념을 설명해보겠습니다. 예시를 함께 제공하겠습니다.\n\n- 프로토타입 상속은 기존 객체를 기반으로 객체를 생성하는 방법입니다. 자바스크립트에서 객체는 프로토타입으로부터 속성과 메서드를 상속받습니다.\n\n예시:\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  console.log(`안녕, 내 이름은 ${this.name}이야`);\n};\nconst john = new Person('John');\njohn.greet(); // 안녕, 내 이름은 John이야\n```\n\n\n\n## 12. 자바스크립트에서 객체를 생성하는 다양한 방법은 무엇인가요? 예제를 제시해주세요.\n\n- 자바스크립트에서는 객체 리터럴, 생성자 함수, `Object.create()` 메소드를 사용하여 객체를 생성할 수 있습니다.\n\n예시:\n\n```js\n// 객체 리터럴\nconst obj = { name: 'John' };\n// 생성자 함수\nfunction Person(name) {\nthis.name = name;\n}\nconst john = new Person('John');\n// Object.create()\nconst newObj = Object.create(null);\nnewObj.name = 'John';\n```\n\n\n\n## 13. 자바스크립트에서 Callback 함수의 개념을 설명해 주세요. 예시를 제공해 주세요.\n\n- Callback 함수란 다른 함수의 인수로 전달된 함수로, 그 후 바깥 함수 내에서 호출되어 어떤 동작을 완료하는 데 사용됩니다.\n\n예시:\n\n```js\nfunction fetchData(callback) {\n// 비동기 작업\nsetTimeout(() => {\nconst data = '일부 데이터';\ncallback(data);\n}, 2000);\n}\nfetchData((data) => {\nconsole.log(data); // 일부 데이터\n});\n```\n\n\n\n## 14. JavaScript에서 `let`, `const`, 그리고 `var`의 차이점은 무엇인가요?\n\n- `var`은 함수 스코프를 가지고 있고, `let`과 `const`는 블록 스코프를 가집니다. `let`은 재할당이 가능하고, `const`는 불가능합니다.\n\n예시:\n\n```js\nlet x = 5;\nconst y = 10;\nvar z = 15;\n```\n\n\n\n## 15. JavaScript에서 Async/Await 개념을 설명해주세요. 예시를 제공해주세요.\n\n- Async/Await은 Promises와 함께 작업하는 데 사용되는 구문 설탕입니다. 이를 사용하면 비동기 코드를 동기적으로 작성할 수 있습니다.\n\n예시:\n\n```js\nasync function fetchData() {\nconst response = await fetch('https://api.example.com/data');\nconst data = await response.json();\nreturn data;\n}\n```\n\n\n\n## 16. 자바스크립트에는 서로 다른 데이터 유형이 무엇이 있나요?\n\n- 자바스크립트에는 `string`, `number`, `boolean`, `null`, `undefined`, `symbol`과 함께 `object`라는 여섯 가지 기본 데이터 유형이 있습니다.\n\n## 17. CORS(Cross-Origin Resource Sharing)의 개념을 설명해주세요.\n\n- CORS는 브라우저에 의해 구현된 보안 기능으로, 웹 페이지가 원래 페이지를 제공한 도메인과 다른 도메인으로 요청을 보내는 것을 제한합니다.\n\n\n\n## 18. 자바스크립트에서 즉시 실행 함수 표현식(IIFE)이란 무엇인가요? 예시를 제공해주세요.\n\n- IIFE는 정의된 즉시 실행되는 함수입니다.\n\n예시:\n\n```js\n(function() {\nconsole.log('IIFE 실행됨');\n})();\n```\n\n\n\n## 19. 자바스크립트에서 `splice()`와 `slice()` 메서드에 대해 설명해주세요. 예제를 제공해주세요.\n\n- `splice()` 메서드는 기존 요소를 제거하거나 대체하여 배열의 내용을 변경합니다. `slice()`는 배열의 일부를 새 배열 객체로 얕은 복사하여 반환합니다.\n\n예제:\n\n```js\nconst arr = [1, 2, 3, 4, 5];\narr.splice(2, 1); // 인덱스 2의 요소를 제거\nconst newArr = arr.slice(1, 3); // [2, 3] 반환\n```\n\n\n\n## 20. 자바스크립트에서 'use strict' 지시어의 목적은 무엇인가요?\n\n- 'use strict' 지시어는 자바스크립트 코드에서 더 엄격한 구문 분석과 오류 처리를 강제합니다. 이는 일반적인 코딩 오류를 잡고 잠재적으로 위험한 코드 구조물을 방지하는 데 도움이 됩니다.\n\n결론:","ogImage":{"url":"/assets/img/2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions_0.png","tag":["Tech"],"readingTime":6},{"title":"애플리케이션 성능을 향상시키세요 Nodejs와 Redis","description":"","date":"2024-05-14 15:52","slug":"2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis","content":"\n\n\n![사진](/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_0.png)\n\n데이터베이스에서 데이터를 가져올 때마다 서버에 요청이 들어올 때마다 대기하는 것에 지쳤나요? 연결을 열고 쿼리를 실행하는 것은 애플리케이션의 속도를 늦출 수 있습니다. 그러나 만약 그 모든 것을 우회할 수 있는 방법이 있다면 어떨까요?\n\n캐싱이 바로 그 방법입니다.\n\n캐싱을 사용하면 자주 액세스하는 데이터를 임시 저장소에 저장하여 가져오는 데 걸리는 시간을 현저히 줄일 수 있습니다. 그리고 Redis는 Node.js 애플리케이션의 완벽한 동반자인 고속인 메모리 데이터 저장소입니다.\n\n\n\n\n하루, 한 시간 또는 심지어 일 분 동안 데이터를 캐싱해두고 Redis가 데이터베이스를 쿼리하는 데 걸리는 시간의 한 부분으로 데이터를 제공한다고 상상해보세요. 마치 마법처럼 — 여러분의 사용자는 데이터를 더 빨리 받을 수 있고, 서버는 땀 한 방울 흘리지 않고 더 많은 요청을 처리할 수 있습니다.\n\n그럼 왜 기다릴까요? Redis가 여러분의 Node.js 애플리케이션에서 데이터를 처리하는 방식을 혁신시키게 두세요. 데이터베이스 병목 현상에 작별을 고하고 번쩍번쩍 속도를 내는 것을 환영하세요. Redis의 속도에 놀라시는 것이 바로 지금입니다.\n\n# 요구 사항\n\n본 문서에서는 ExpressJs, Redis 그리고 NodeJs를 사용하여 데이터를 캐싱하고 HTTP 요청을 처리할 것입니다. 그러므로 NodeJs, NPM, Docker를 준비하는 것이 좋습니다.\nRedis 서버를 생성하여 저장 및 데이터 검색을 다루기 위해 Docker를 사용할 것입니다.\n\n\n\n# 애플리케이션 설정 및 실행\n\n작업할 디렉토리를 만들고, 해당 디렉토리 내에 애플리케이션 소스 코드를 포함하는 src라는 또 다른 디렉토리와 docker-compose.yml이라는 다른 파일을 생성하세요.\n최종 구조는 다음과 같아야 합니다:\n\n![애플리케이션 구조](/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_1.png)\n\nsrc 폴더 내부에서 다음 명령을 실행하세요:\n\n\n\n```js\nnpm i express redis\nnpm i -D nodemon\n```\n\n그런 다음 package.json을 업데이트하여 일부 새로운 명령어 별명을 포함시킬 수 있습니다. 아래 예시를 복사하세요.\n\n```js\n{\n  \"name\": \"src\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"dev\": \"nodemon app.js\",\n    \"start\": \"node app.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.19.2\",\n    \"redis\": \"^4.6.13\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.1.0\"\n  }\n}\n```\n\n그런 다음 src 폴더에 app.js 파일을 만들고 다음 라인을 포함시킵니다:```\n\n\n\n```js\nimport express from \"express\";\nconst PORT = 4000;\nconst app = express();\n\napp.get(\"/\", async (req, res) => {\n  return res.json(\"Hello World!!\");\n});\n\napp.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});\n```\n\n위의 코드를 실행하려면 다음 명령을 사용하십시오:\n\n```js\nnpm run dev\n```\n\n그리고 http://localhost:4000/을 방문하여 \"Hello World!!\"를 볼 수 있습니다.\n\n\n\n이제 터미널을 종료하여 서버를 중지하고 Redis에 연결을 시도해보겠습니다.\n아래의 코드를 app.js에 추가해주세요.\n\n```js\nimport { createClient } from \"redis\";\nconst client = createClient();\nclient.on(\"error\", (err) => console.error(\"Redis Client Error\", err));\nclient\n  .connect()\n  .then((suc) => console.info(`Redis connected`))\n  .catch((err) => console.error(`Error occured while redis is connecting, ${err}`));\n```\n\n이를 통해 애플리케이션과 Redis 서버 간에 연결이 생성됩니다.\n\n지금 애플리케이션을 실행해보면 충돌이 발생할 것입니다. 그 이유는 아직 Redis 서버를 설정하지 않았기 때문입니다. 따라서 지금 설정을 해보겠습니다.\ndocker-compose.yml 파일에 다음 라인을 복사해주세요.\n\n\n\n```yaml\n버전: \"3.8\"\n서비스:\n  캐시:\n    이미지: redis:6.2-alpine\n    재시작: 항상\n    포트:\n      - \"6379:6379\"\n    볼륨:\n      - cache:/data\n볼륨:\n  캐시:\n    드라이버: 로컬\n```\n\n메인 디렉토리에서 다음 명령어를 실행하세요:\n\n```js\ndocker-compose build\ndocker-compose up -d\n```\n\n참고: 명령어를 실행하려면 컴퓨터에 Docker가 설치되어 있어야 합니다.\n\n\n\n어제 후면을 다시 실행하면 다음이 출력됩니다:\n서버가 http://localhost:4000에서 실행 중입니다\n레디스 연결됨\n\n좋아요!! 계속 진행합시다\n\n이제 app.js 파일을 다음 라인을 포함하도록 조정해보세요:\n\n```js\nconst getData = async () => {\n  //이 부분은 데이터베이스에 쿼리하여 데이터를 가져 오는 것으로 가정합시다\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve([\"bar\", \"baz\", \"qux\"]);\n    }, 1_000);\n  });\n};\n\napp.get(\"/\", async (req, res) => {\n  let data;\n  let from = \"DB\";\n  data = await client.get(\"foo\");\n  if (!data) {\n    data = await getData();\n    await client.set(\"foo\", JSON.stringify(data), {\n      EX: 60,\n    });\n  } else {\n    from = \"Cache\";\n    data = JSON.parse(data);\n  }\n  return res.json({ data, from });\n});\n```\n\n\n\n여기서는 데이터 배열을 검색하고 60초 동안 캐시에 저장하는 가짜 프로미스를 만들어 보았습니다. 데이터가 얼마나 자주 변경되는지에 따라 변경할 수 있습니다.\n\n이제 다시 http://localhost:4000 으로 이동하세요.\n데이터를 수신했다는 배열이 포함된 데이터가 표시됩니다. \"from\" 값이 \"DB\"인 것을 확인할 수 있을 겁니다. 페이지를 새로 고치면 \"from\"이 \"Cache\"인 같은 빠른 응답을 확인할 수 있을 겁니다.\n\n캐시 이전:\n\n![이미지](/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_2.png)\n\n\n\n캐싱 후:\n\n<img src=\"/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_3.png\" />\n\n캐싱하기 전에 시간 차이를 볼 수 있습니다. 캐싱하기 전에는 1초가 걸렸는데, 이는 우리가 약속을 1초 동안 기다리도록 설정했기 때문입니다. 하지만 실제로는 데이터 크기와 작업하고 있는 데이터베이스에 따라 더 짧거나 더 오래 걸릴 수 있습니다. 그러나 캐싱을 사용하면 데이터를 매번 데이터베이스에서 가져오는 것보다 더 빠르게 검색할 수 있습니다.\n\n# 결론\n\n\n\n이것은 일반적인 개요예요. 자주 요청되는 데이터를 저장하는 캐싱 메커니즘을 포함하는 중요성을 설명하려고 노력했어요. 이것은 애플리케이션 성능을 향상시키고 클라이언트가 요청 처리를 기다리는 시간을 줄일 거예요. 제 첫 번째 글이에요. 읽어주셔서 감사해요. 누군가에게 도움이 되길 바라요!","ogImage":{"url":"/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_0.png"},"coverImage":"/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_0.png","tag":["Tech"],"readingTime":5},{"title":"1999년에 개인 웹사이트를 만드는 방법","description":"","date":"2024-05-14 15:47","slug":"2024-05-14-Howtocreateapersonalwebsitebutits1999","content":"\n\n20년 전 웹 개발자의 삶이 어땠는지, 인터넷이 여전히 새로운 개념이었고 웹에 접속하기 전에 이상한 비프음과 부우우우음을 들어야 했던 시절에 JavaScript와 CSS는 궁금한 것 이상의 것이었으며 간단한 웹사이트를 만드는 데 흔히 사용되는 것보다 eer바나 클 친 인터넷익스플로러가 가장 인기 있었던 시기란게 궁금했나요? 아마도 그렇지 않았을 것입니다... 하지만 여유로운 몇 분이 있고 쓸데없는 새로운 것을 배우고 싶다면 — 이 ㄱㄷㄷ은 당신을 실망시키지 않을 겁니다!\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_0.png)\n\n# 배경 이야기\n\n2022년 초에 향수에 젖어 어린 시절에 즐겨했던 게임(왕자와 겁쟁이 — 폴란드의 포인트 앤 클릭 게임이고, 맞아요, 저는 폴란드 출신입니다)을 하나 하고 싶어졌어요. 원본 게임 CD는 있었지만 실행할 수 있는 기계가 없었죠. 옛 스타일의 윈도우 PC에서 플레이하는 것이 더 재미있을 것 같아서, 내게 맞는 회사/중고 상품 웹사이트/온라인 시장을 통해 오랜만에 사용되는 기기(그리고 소프트웨어 — 윈도우 98)를 구매하고, 나를 위해 하나 짓기로 결심했어요... 어쨌든 제가 어떻게 만들었는지와 어떤 문제를 겪었는지에 대해서는 다음 이야기로 남겨둘게요.\n\n\n\n\n![게임을 완료한 후, 그리운 옛 마음은 사라지고 자리를 차지하고 먼지를 모으는 것들을 남겼어요. 이 PC에서 웹 개발을 시도해보자는 아이디어가 갑자기 떠올랐지만, 항상 더 좋은 일이 있는 것 같아요. 그래서 이 아이디어는 뒷전으로 밀려나 시간이 지난 후, 이 글을 쓰기로 결심했어요.\n\n# 1999\n\n그때 당시 저는 10살이었고, 적어도 3년 정도의 Microsoft Windows 운영 체제 경험이 있었죠. 웹 개발 여정은 2000년 초반에 시작했을 것이라고 확신하고 있어요. 처음으로 Macromedia Dreamweaver(2005년 Adobe가 Macromedia를 인수했어요)를 사용했고, CSS 없이 테이블 기반 레이아웃과 인터넷에서 복사한 JS 코드를 사용해 눈 오는 효과와 같은 트렌디한 효과를 적용한 \"프로젝트\"를 했어요.\n\n\n\n\n1999년에는 인터넷 자체가 나에게는 신비로웠어요. 아마 들어본 적은 있고 무엇인지 알았겠지만, 실제로 처음 접촉한 것은 21세기에 들어서였어요.\n\n![1999 이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_2.png)\n\n세상에서는 무슨 일이 벌어졌을까요? 유럽 연합이 새 통화인 유로를 도입했어요. 빌 클린턴은 미국 대통령이었죠. 세계 기상 기구는 90년대가 역대 가장 덥다(평균 온도를 얘기하죠)고 발표했어요. 스펀지밥 네모바지가 니켈로디언에서 데뷔했죠. 에미넴이 'The Slim Shady LP'를 발표했어요. '매트릭스'나 '스타워즈: 에피소드 1 - 마이너카의 위협' 같은 영화들이 세계 프리미어를 가졌죠.\n\n![1999 이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_3.png)\n\n\n\n모든 사람들이 천년 기리일 버그에 대해 이야기했어요. 2000년은 날짜 형식 문제로 인한 전 세계 컴퓨터 아포칼립스를 가져올 예정이었죠. 그래서, 이미 만들지 않은 경우에는 1999년이 개인 웹사이트를 만들기 마지막 기회였어요.\n\n# 프로젝트\n\n무엇을 할 건가요? 세 가지 탭을 갖춘 간단한 개인 웹사이트를 만들 거에요 — 홈(방문자에게 인사하기), 소개(간단한 소개) 및 연락(일부 연락처 정보). 레이아웃은 매우 복잡하지 않아도 괜찮아요 — 상단에 헤더(제목과 탭 탐색이 포함됨), 하단에 푸터, 그리고 탭 내용 영역이 사이에 위치하면 되요.\n\n![이미지를 참조하세요](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_4.png)\n\n\n\n최대한 CSS를 활용하고, 탭 간 전환은 JavaScript를 사용하여 구현하고 싶습니다. 서브페이지는 없을 것이며, HTML 인덱스 파일 하나, JS 파일 하나, CSS 파일 하나, 이미지 파일 몇 개(두 개)로 구성될 것입니다. 프로젝트 트리 구조는 다음과 같습니다:\n\n```js\nproject-root/\n├── assets/\n│   ├── scripts.js\n│   ├── styles.css\n|   ├── bg.gif (페이지의 배경으로 사용됨)\n|   └── mk.jpg (제 얼굴이 있는 about 섹션용 이미지)\n|\n└── index.html\n```\n\n해당 페이지는 그때 시점에서 이용 가능한 모든 (두 개의) 중요 브라우저인 MS Internet Explorer 5 및 Netscape Navigator 4.51에서 잘 작동하고 멋지게 보여야 합니다.\n\n# 도구\n\n\n\n클래식 스타일로 가서 웹 사이트의 모든 코드를 MS 메모장에 작성할 수도 있습니다. 그러나 조금 더 전문적으로 하기 위해 실제 코드 편집기를 사용합시다. 처음에는 Notepad++를 선택할 생각이었지만, 2003년에 출시되었으므로 1999년에는 존재하지 않았습니다. 내 마음속에는 1996년부터 제공되었던 폴란드어 코드 편집기인 Pajączek (스파이더)이 그렇게 욕심이 났었지만, 폴란드어로만 제공되고 무료가 아니었던 것으로 기억합니다. 구글과 위키피디아에서 몇 분동안 검색한 후에 Arachnophilia를 발견했습니다. 1996년에 출시된 이 툴은 무료이고 영어로 되어 있으며 이름도 거미와 관련이 있습니다. 이 정도면 충분합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*fHIISJOsPFdxcPnjQsnCgw.gif)\n\n내 Windows 98은 프리인스톨된 인터넷 익스플로러(v5.0)가 함께 있었지만, 다른 앱들을 얻어야 했습니다 — 넷스케이프 네비게이터와 아라크노필리아. 당연히 23년 전에 사용 가능했던 버전이어야 했습니다. 옛 소프트웨어를 찾는 것은 어렵지만 일반적으로 oldversion.com이 시작하기에 좋은 장소입니다. 유감스럽지만 그 사이트에 접속하려고 할 때 며칠 동안 다운되었으며, 그것이 완전히 없어진 것으로 확신했습니다. 그러나 이 단어들을 입력하는 동안, 현재 그것이 다시 온라인 상태인 것처럼 보입니다.\n\n그럼에도 불구하고 다른 곳에서 검색해야 했습니다. \"Netscape 4.5 다운로드\"와 같은 구글에 입력된 구문은 첫 번째 페이지에서 만족스러운 결과를 제공하지 않을 뿐 아니라 전혀 만족스럽지 않을 것입니다. 따라서 주변을 더 들여다봐야 했습니다. 결국, archive.org 페이지에서 필요한 정보를 제공해주는 것을 찾을 수 있었고, 1999년 5월에 제공된 apcmag.cd 디스크 이미지를 발견했습니다. 이 이미지에는 Netscape Navigator v4.51과 Arachnophilia v3.9가 포함되어 있었습니다.\n\n\n\n![링크 이름](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_5.png)\n\n내 초기 큰 계획은 로컬 서버를 사용하고 웹사이트를 로컬호스트에서 실행하는 것이었습니다(심지어 Windows 98에 Apache와 PHP를 설치하는 방법에 대한 오래된 기사를 찾았어요). 그러나 이 정도 규모의 프로젝트에는 좀 압도당하는 느낌이었고, 결국 그 아이디어를 포기했어요. 어쩌면 언젠가는 더 고급스러운 레트로 웹 요소를 사용하는 백엔드 로직이 필요한 프로젝트에 도전할지도 모르겠지만, 현재로서는 프론트엔드에만 집중할 거예요.\n\n# Arachnophilia\n\n내가 선택한 코드 에디터에 대해 간단히 얘기해보죠. 이것은 예전에는 꽤 좋게 여겨졌을지도 모르지만, 지금은 조금 싸구려 느낌이에요. 그럼에도 불구하고 일반적인 MS 메모장보다는 더 많은 것을 제공해줘요 — HTML 기본 구문 강조 기능과 미리보기 기능이 있어요(버튼을 클릭하면 Arachnophilia가 현재 HTML 코드를 임시 파일에 저장하고 IE에서 미리보기를 열어줘요; 페이지를 저장할 때마다 다시 불러오는 기능을 제공한다고 주장하지만, 불행히도 그 기능은 제게는 작동하지 않았어요).\n\n\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_6.png)\n\nJS 및 CSS 파일을 지원하지는 않지만, .js 또는 .css 확장자가 있는 txt 파일로 만들어 코드를 작성할 수 있어요.\n\n새 HTML 파일을 만들 때 페이지 제목, 텍스트 및 링크 색상을 설정할 수 있는 프롬프트 창이 나타납니다. 입력하신 내용에 따라 Arachnophilia가 초기 HTML 코드를 생성해줘요. 제목이 head 섹션에 설정되고, 텍스트와 링크 스타일이 body 태그의 속성으로 추가됩니다 (그냥 그대로 남길 건 아니에요).\n\n초기 HTML 코드는 대문자 태그 이름으로 작성되어 있는데, 이 올드 스쿨 느낌이 나쁘지 않아요. 그대로 따라해 볼게요. 물론 자동 들여쓰기는 없답니다.\n\n\n\n\n![Website Screenshot](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_7.png)\n\n# 먼저 로직을 고민해보세요\n\n전체 페이지를 구현하기 전에 JavaScript로 무엇을 할 수 있는지 알아보고 싶어요. 제 목표는 JS로 제어되는 탭을 만드는 거에요. 네비게이션 링크를 클릭하면 해당 탭이 표시되고 다른 탭은 숨겨져야 해요.\n\n먼저 인터넷 익스플로러에 집중했어요. 개발 도구도 JS 콘솔도 없어요. 뭔가 에러가 나오면 IE는 하단 표시줄에 경고 아이콘을 보여주는데, 그것을 더블 클릭하면 더 자세한 정보를 확인할 수 있어요 — 에러 메시지와 발생 위치가 표시돼요.\n\n\n\n\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_8.png)\n\n나는 익숙치 않은 것이지만 여전히 상당히 도움이 되었어. 문제가 있을 때 구글링을 해보면 대부분 해결책을 찾을 수 있었어 (결과는 잊혀진 포럼에 있는 오래된 글들을 가리킴) 아니면 caniuse.com을 사용해서 해당 메소드가 사용 가능한지 알아볼 수 있었어 (해당 사이트는 IE v6 이상만 나열하지만 내 경험 상 \"6-8\"로 표시된 경우 IE v5에서도 작동했어).\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_9.png)\n\n여기에는 Internet Explorer 5를 위한 PoC JavaScript 개발 중 발견한 몇 가지 사항이 있어:\n\n\n\n\n- getElementsByClassName은 지원되지 않지만 getElementsByName은 잘 작동합니다 (따라서 모든 네비게이션 링크를 선택하는 데 사용했습니다)...\n- ... 하지만 DIV로는 작동하지 않았습니다 (따라서 탭 콘텐츠를 선택하는 데 사용할 수 없었습니다),\n- addEventListener는 존재하지 않지만 IE에는 해당하는 방법이 있습니다 — attachEvent— 적어도 두 개의 인수를 사용해야 합니다 — 이벤트 이름 (그러나 on으로 시작해야 하며, 예: click 대신에 onclick) 및 콜백 (이벤트 객체를 인수로 받지 않습니다),\n- anchorElement.getAttribute(`href`)은 href 속성에 할당된 값만이 아닌 전체 URL 경로를 반환합니다 (따라서 속성에 #foobar와 같은 값이 지정된 경우 로컬에서 C:\\\\…\\#foobar와 같은 결과가 나올 것입니다)\n\n제가 탭 컨셉을 테스트하기 위해 작성한 HTML입니다:\n\n```js\n<A href=\"#tab0\" tab=\"tab0\" name=\"link\">링크 1</a>\n<A href=\"#tab1\" tab=\"tab1\" name=\"link\">링크 2</a>\n<A href=\"#tab2\" tab=\"tab2\" name=\"link\">링크 3</a>\n<DIV id=\"tab0\">콘텐츠 1</div>\n<DIV id=\"tab1\" style=\"display: none;\">콘텐츠 2</div>\n<DIV id=\"tab2\" style=\"display: none;\">콘텐츠 3</div>\n```\n\n보다 의미론적으로 유지하기 위해 href 속성을 유지했지만, JS에서 탭 ID를 쉽게 가져오기 위해 사용자 정의 속성 tab이 필요했습니다.\n\n\n\n그리고 탭 간 전환을 제어하는 JavaScript 코드가 여기 있어요:\n\n```js\nvar tabLinks = document.getElementsByName('link');\nvar currentOpenTabElement = document.getElementById('tab0');\n\nfor (var i = 0; i < tabLinks.length; i++) {\n tabLinks[i].addEventListener('click', createOnClickHandler(i));\n}\n\nfunction createOnClickHandler(tabLinkIndex) {\n var tabLink = tabLinks[tabLinkIndex];\n var tabId = tabLink.getAttribute('tab');\n \n return function() {\n  openTab(tabId);\n }\n}\n\nfunction openTab(tabId) {\n var tab = document.getElementById(tabId);\n currentOpenTabElement.style.display = 'none';\n tab.style.display = '';\n currentOpenTabElement = tab;\n}\n```\n\n그리고 솔직하게 말하자면 — 놀랍네요. 코드가 꽤 잘 작성되어 있고 제가 원하는 대로 작동합니다(탭 간 전환). 1999년, 인터넷 익스플로러이고 작동합니다. 정말 놀랍네요.\n\n# 넷스케이프 네비게이터 — 첫 영향\n\n\n\n내 코드가 인터넷 익스플로러에서 작동한다면, 넷스케이프 브라우저에서 어떤 문제가 발생할 수 있을까? — 나 자신에게 물었습니다. 90년대에는 심지어 가장 인기 있는 브라우저였지만, 나중에 인터넷 익스플로러에 밀려난 후에도 걱정할 것이 없다고 확신했습니다. 그래서 넷스케이프 네비게이터에서 내 페이지를 열어 보았더니...\n\n...탭 컨트롤이 작동하지 않았습니다.\n\n내 첫 번째 추측은 attachEvent가 인터넷 익스플로러 전용 기능이기 때문에 넷스케이프에서 작동하지 않을 것이라는 것이었습니다. 하지만 어떻게 확인할 수 있을까요? 넷스케이프에서 JS 오류 메시지를 출력하는 위치가 있을까요? JS 콘솔이 있을까요? 아니요. IE와 같이 하단 표시줄에 정보가 표시되는가요? 아니요. JS 코드를 실행할 때 문제가 발생했음을 나타내는 표시가 있나요? 음... 작동하지 않으니 어떤 종류의 피드백이지만, 아니요, 없습니다.\n\n그렇다면 넷스케이프 네비게이터 4.51에서 JavaScript를 디버깅하는 방법은 무엇일까요? 여러분이 직접 에러 처리를 해야 합니다 — 에러 메시지를 포함한 경고 창을 호출하는 window.onerror 핸들러를 추가하면 됩니다 (이 점은 제가 스스로 생각한 것이 아니라 여기에서 찾았습니다).\n\n\n\n<img src=\"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_10.png\" />\n\n앗, 그래서 getElementsByName은 넷스케이프 시대에 존재하지 않았어요. 그럼 getElementsByClassName은 어때요? 아니요. 아마 getElementById는 최소한 있겠지요? 아니요. 넷스케이프 네비게이터는 '아니요'만 있는 건가요? 아뇨, 그러나 분명히 많은 것들을 막아요.\n\ncaniuse.com에서 지원 정보를 찾을 수 없어요. 인터넷에 남아 있는 것으로만 제한돼요. 다행히도 여기 유용한 리소스가 하나 있어요 — 1999년에 발행된 넷스케이프 커뮤니케이션즈 코퍼레이션의 Client-Side JavaScript 참조서(버전 1.3). 제가 사용할 수 있는 것에 대한 어떤 아이디어를 제공해줬어요. 오, 넷스케이프 버전의 JavaScript는 완전히 다른 이야기 같아요. document.ids나 document.classes와 같은 컬렉션이 있긴 하지만 — 보통은 몇 가지 기본 스타일을 설정할 수 있지만, 브라우저가 페이지를 로드할 때 단 한 번만 할 수 있어요.\n\n제 아이디어는 클릭 핸들러를 부착하는 것을 담당하는 onClick 속성을 사용하는 것이었어요(크로스 브라우저 솔루션이라서요). 그러나 작동하지 않았어요. 다시 한 번, 구글 삼촌에게 기대야 했어요. 몇 개의 오래된 기사를 찾았지만 대부분이 제게 아무 방향도 제시하지 않았어요. 마침내 제 날을 구해 준 이 기사를 찾았어요. 넷스케이프는 페이지 내 요소를 위치시키고 애니메이션을 주려고 만든 자체 레이어 HTML 태그를 소개했어요.\n\n\n\n`layer` 태그의 유일한 문제는 CSS의 절대 위치 지정과 같은 동작 방식을 가지고 있다는 것입니다 (부모 레이어나 창을 기준으로). 다행히 `ilayer` 태그도 있습니다. 이것은 인라인 레이어입니다. 더 유용할 수 있지만 여전히 한 가지 작은 문제가 있습니다 - 레이어의 가시성 속성이 CSS 가시성 속성처럼 작동한다는 것이죠. 이는 요소를 숨길 수 있지만 여전히 공간을 차지한다는 것을 의미합니다. 결과적으로 첫 번째 탭은 원하는 위치에 표시되지만 다른 탭들은 아래에 나타나 버리고 이는 보기 좋지 않을 것입니다. 이를 해결하기 위해 올바른 위치로 이동시키기 위해 음수의 상단 속성 값을 사용해야 합니다. 휴...\n\n그러면 크로스 브라우저 버전은 어떻게 보일까요? 먼저, 넷스케이프 브라우저인지 확인하기 위해 문서의 `head`에 일부 인라인 스크립트를 추가해야 했습니다:\n\n```js\n<SCRIPT>\n   var probablyNetscape = !!document.layers && !!document.classes && !!document.ids;\n</SCRIPT>\n```\n\n왜 페이지를 방문하는 브라우저를 확인하기 위해 navigator 속성을 사용하지 않았을까요? navigator.appName은 Netscape를 반환합니다. 그런데 2023년에는 Chrome도 반환합니다. navigator.userAgent는 Mozilla v4.51을 반환하는데, 이것은 더 구체적이지만 완전히 신뢰할 수 없습니다. document가 layers와 같은 속성을 가지고 있는지 확인하면, 이 속성들은 완전히 넷스케이프와 관련된 것들이므로 더 신뢰할 수 있습니다.\n\n\n\n어쨌든 - 나는 scripts.js 파일과 HTML에서 probablyNetscape인지를 사용할 거야. HTML에 대해 얘기하면, 여기 있어:\n\n```js\n<A href=\"#tab0\" onClick=\"tabLinkClickHandler('tab0')\">링크 1</A>\n<A href=\"#tab1\" onClick=\"tabLinkClickHandler('tab1')\">링크 2</A>\n<A href=\"#tab2\" onClick=\"tabLinkClickHandler('tab2')\">링크 3</A>\n<DIV>\n  <ILAYER name=\"tab0\" style=\"display: block;\">\n    <DIV id=\"tab0\">콘텐츠 1</DIV>\n  </ILAYER>\n  <ILAYER name=\"tab1\" visibility=\"hide\" style=\"display: block;\">\n    <DIV id=\"tab1\">콘텐츠 2</DIV>\n  </ILAYER>\n  <SCRIPT>if (!probablyNetscape) {document.getElementById('tab1').style.display = 'none';}</SCRIPT>\n  <ILAYER name=\"tab2\" visibility=\"hide\" style=\"display: block;\">\n    <DIV id=\"tab2\">콘텐츠 3</DIV>\n  </ILAYER>\n  <SCRIPT>if (!probablyNetscape) {document.getElementById('tab2').style.display = 'none';}</SCRIPT>\n</DIV>\n```\n\n보다시피, 내가 사용한 일부 인라인 스크립트로 브라우저가 Netscape가 아닌 경우에 초기에 숨겨져야 하는 탭에 display: none 스타일을 추가했어. 이걸 한 이유는 Netscape Navigator에서 JS로 display 속성을 수정하는 기능이 제대로 작동하지 않기 때문에(따라서 제거할 수 없었어), 그리고 가능한 빨리 저런 탭들을 숨기고 싶었기 때문이야(scripts.js가 로드되기 전에).\n\nvisibility나 top 같은 `ILAYER` 속성들은 Netscape에서만 이해될 거야. 다른 브라우저들은 이를 무시할 거야 (응, IE 5는 이를 무시하니까, 미래 브라우저들도 그럴 걸 바래).\n\n\n\n탭 탐색을 위한 링크에는 클릭 핸들러가 할당된 onClick 속성이 있습니다. 이 클릭 핸들러는 scripts.js 파일에 정의되어 있어요:\n\n```js\nvar activeTab = 'tab0';\n\nif (probablyNetscape) {\n  window.onerror = function(message, file, line) {\n   alert('JavaScript error!\\nFile: ' + file + '\\nLine: ' + line + '\\nMessage: ' + message);\n  }\n\n  // Netscape Navigator에서 레이어의 위치 설정\n  document.layers.tab1.top = -38;\n  document.layers.tab2.top = -76;\n}\n\nfunction tabLinkClickHandler(tab) {\n  if (tab === activeTab) return;\n\n  if (probablyNetscape) {\n    document.layers[activeTab].visibility = 'hide';\n    document.layers[tab].visibility = 'show';\n  } else {\n    document.getElementById(activeTab).style.display = 'none';\n    document.getElementById(tab).style.display = 'block';\n  }\n \n  activeTab = tab;\n}\n```\n\n아, 그리고 알아요 — 누군가가 스크립트 파일이 로드되기 전에 링크를 클릭하면 오류가 발생할 거라는 거, 그러니까 이 시점에서 제 스크립트 코드를 단순히 index.html 파일에 모두 넣을 수도 있지만... 전 그냥 이렇게 하고 싶어요.\n\n그리고 이제... 웹 브라우저 간의 개념 증명이 동작하는 레이아웃과 CSS 스타일링 작업을 할 시간이 왔어요! 아하 — Netscape Navigator 덕분에 조금 짜증이 나긴 했지만요. 지금은 편안한 파트인 레이아웃과 CSS 스타일링을 하는 시간이죠!\n\n\n\n# 잘 하고 있어요\n\n배운 것이 있어요 — IE5를 위해 특별히 무언가 개발한 다음에 Netscape Navigator에 맞추려고 하면 완전히 다른 코드를 얻게 될 것 같아요. 처음부터 두 브라우저에서 모두 작동하는 솔루션을 찾아야 한다는 걸 이해했어요.\n\n사용하고 싶은 HTML 구조와 CSS 스타일에 대한 아이디어가 있어서, 크로스 브라우저화를 위해 차근차근 작업하기 시작했어요. 이제 1999년에 HTML 레이아웃을 스타일링하는 미친 듯한 이야기를 들려줄게요.\n\n마진 왼쪽과 오른쪽을 자동으로 설정하여 요소를 가운데 정렬하는 것은 작동하지 않아요. `center` 태그나 `align=\"center\"` 속성이 있는 `div`의 두 가지 가능한 해결책이 있어요. 이 요소는 페이지 내용 컨테이너를 감싸야 해요 (너비는 480픽셀로 설정된 상태지요). 양쪽 브라우저에서도 내용을 가운데 정렬하기 위해서 IE는 후손의 내용도 가운데 정렬하기 때문에 페이지 컨테이너에 왼쪽으로 정렬 속성을 설정할 수 있어요. 하지만 Netscape는 전체 컨테이너를 왼쪽으로 이동시키기 때문에 이를 올바르게 만들려면 (내용은 왼쪽에 있지만) 왼쪽으로 정렬된 세 번째 컨테이너가 필요해요. 이해를 돕기 위한 코드를 여기에 제시할게요:\n\n\n\n```js\n<DIV align=\"center\">\n  <!-- styles.css에서 너비가 480픽셀로 설정되어 있음 -->\n    <DIV class=\"page-container\">\n      <DIV align=\"left\">...</DIV>\n    </DIV>\n</DIV>\n```\n\nCSS 플렉스박스 (그리드 시스템도 마찬가지)는 항상 사용 가능했던 것은 아니었습니다. 웹 개발을 한지 ~10년 이상이 된다면 아마도 그리드 레이아웃을 만들기 위해 개발자들이 float 속성을 사용했다는 것을 기억하실 것입니다 (Bootstrap도 그렇게 했습니다). 원래 float를 그 용도로 사용하도록 의도되지 않았지만, 개발자들이 그것을 웹사이트 레이아웃 스타일링 역사에서 상당히 중요한 위치에 부여해 왔다고 생각합니다.\n\n어쨌든, 탭 컨트롤(링크)을 정렬하기 위해 float를 사용했습니다. 여기에는 ul 및 li 태그를 사용하고 싶었지만, Netscape는 float와 목록 요소 조합을 좋아하지 않는 것 같습니다... 게다가, anchor 태그에 직접 float 스타일을 사용하면 모든 기본 앵커 스타일이 제거될 것입니다 (Netscape에 대해서 말하는 것이고, IE에서는 모두 잘 작동합니다). DIV 기반의 목록을 사용하게 되었습니다.\n\n<img src=\"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_11.png\" />\n\n\n\n\nCSS로 설정된 DIV의 배경색은 넷스케이프 네비게이터 v4.51에서 심각한 문제입니다. CSS border 속성을 none으로 설정하지 않으면 (또는 다른 방법으로 설정하면, 그냥 테두리 스타일이 필요합니다) DIV 내부의 텍스트만 원하는 배경색이 적용됩니다 (일종의 텍스트 강조 스타일처럼).\n\n![이미지1](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_12.png)\n\n![이미지2](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_13.png)\n\n배경 이미지를 설정하려고 하니 또 다른 머리 아픔이 들었습니다. IE는 이미지(bg.gif) 경로가 styles.css 파일과 상대적이어야 하며 (그래서 url(`bg.gif`)이 괜찮음), 그러나 넷스케이프는 index.html 파일을 기준으로 상대적이어야 한다고 예상합니다 (url(`assets/bg.gif`)). 여기서 가장 간단한 해결책은 body 스타일 속성에서 배경을 직접 설정하는 것입니다 (물론 index.html을 기준으로 경로 설정 필요).\n\n\n\n내비게이션 작업 중에는 연결된 탭이 열릴 때 링크 스타일을 변경하고 싶었어요. Netscape의 제한 때문에 (i)layer 태그를 사용해야 했고, HTML을 수정하는 중에 Netscape가 치명적인 오류를 일으켰어요.\n\n```js\n...\n<div class=\"tab-control\">\n  <ilayer name=\"start-link\" class=\"tab-control-layer\">\n    <div class=\"tab-control-inner\">\n      <a href=\"#start\" id=\"start-link\">시작</a>\n    </div>\n  </ilayer>\n</div>\n...\n```\n\n아마도 CSS와도 관련이 있었던 것 같아요. 하지만 그 부분은 확인하지 않았어요.\n\n<img src=\"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_14.png\" />\n\n\n\n다음 문제는 여백입니다. 좀 더 명확하게 하죠: 넷스케이프 네비게이터 v4.51의 여백에 대해 말이죠. 모든 곳에 margin: 0을 설정할 수 있지만 넷스케이프는 신경쓰지 않아요. 그저 더 잘 알고 있는 거죠. 여백이 반드시 필요한거거든요. 물론 해결책은 있어요 — 음수 값 사용하기. 그러나 이렇게 하면 다른 브라우저(IE)에도 영향을 미치고, 다른 브라우저들은 'ZERO는 ZERO' 라는 거 알거든요. 여백은 없어! 넷스케이프, 너 뭘 하는 거야?\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_15.png)\n\n이 순간에 저는 넷스케이프 버전의 사이트를 내가 원하는 만큼 잘 만들지 못할 거라고 깨달았어요. 그래서 따로 스타일을 사용해야 했죠. 어떻게 구분할까요? 첫 번째 생각은 넷스케이프 브라우저가 아닐 때 body에 추가적인 클래스를 JavaScript로 추가하는 거였는데 (넷스케이프 JS 버전에서 클래스 이름을 설정할 수 없어요), 그러나 넷스케이프 네비게이터 4가 너무 망가져 있어서, 무시될 스타일이 쉽게 설정될 수 있다는 걸 알게 됐어요. html을 하위 선택자로 사용하면 될 거에요, 왜냐하면 넷스케이프는 이걸 유효한 것으로 인식하지 않거든요.\n\n나의 페이지를 위해 CSS를 작업하면서 넷스케이프 네비게이터 4에는 얼마나 많은 것들이 망가져 있는지 깨달았어요. 예를 들어, 모든 선택자는 한 번만 사용할 수 있고, 복합 선택자는 환영받지 않아요(.class.with-other-class 같은 것은 통하지 않아요).\n\n\n\n위 이미지에서 보이는 탭 링크들 사이의 공백을 제거할 수 없었어요.\n\n물론 Internet Explorer 5도 몇 가지 예상치 못한 동작이 있어서 완벽하지 않지만, Netscape Navigator 4는 정말 순수한 미쳤다고 해야 할까요.\n\nIE에 대해 이야기하자면 – 페이지 제목 아래 왼쪽에서 오른쪽으로 계속 슬라이딩하는 캐치프레이즈 (Welcome to 1999!)의 간단한 애니메이션을 구현하고 싶었어요. 그 목적으로 setInterval을 사용했는데, 콜백으로 익명 함수를 전달하면 IE가 몇 초 후에 크래시되는 문제가 발생했어요.\n\n```js\n// IE5 KILLER\nsetInterval(function() {...}, 100);\n```\n\n\n\nmd\n![198.png](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_16.png)\n\n함수를 먼저 정의하고, 그 후에 setInterval에 전달하는 것이 올바른 방법입니다.\n\n```js\n// 잘했어요!\nfunction animateCatchphrase() {...}\n\nsetInterval(animateCatchphrase, 100);\n```\n\n내 예상은 익스플로러가 익명 함수의 경우 메모리 관리에 문제가 있는 것 같습니다. 넷스케이프 네비게이터는 이런 문제가 없네요. 멋진 일이죠 넷스케이프, 그리핀도르에 10 포인트 들어가요.\n\n\n\n\n# 마침내\n\n내 1999페이지 프로젝트 작업 중 겪은 모든 문제를 설명하고 싶다면 책을 쓰는 수밖에 없을 것 같아. 이미 가장 흥미로운(짜증나는) 부분을 이미 알려준 것 같아. 하지만 믿어줘 — 당연히 더 많은 문제가 있어, 예를 들어 단락 스타일링 문제 — 이 경우에 나는 빨리 포기하고 DIV 대신 사용했어.\n\n어쨌든 몇 시간을 투자한 후에 내 페이지는 준비되었고 인터넷 익스플로러 5와 넷스케이프 네비게이터 4.51에서 작동했어.\n\n페이지를 실행하는 데 필요한 모든 파일의 총 크기는 ~42KB(압축되지 않은 html, css, js 및 두 이미지)야. 1999년도 인터넷 연결 평균 속도에 대한 신뢰할만한 정보를 찾을 수 없어서, 1990년대 후반에 56 kbit/s 속도를 달성할 수 있는 전화 기반 모뎀을 사용하여 데이터를 모두 받는 데 걸리는 시간을 계산해보자 — 그런 종류의 장치(최대 속도로 작동 중인)로는 모든 데이터를 가져오는 데 6초가 걸릴 것이야. 1999년에는 아마 수용 가능했을 거야.\n\n\n\n전체 코드를 여기에 붙여 넣지 않을 거예요 (길고 지루하거든요), Github 저장소 링크는 아래 어딘가에 있을 걸거에요. 이제 윈도우 98에서 촬영한 페이지의 몇 가지 스크린샷을 보겠습니다.\n\n## 인터넷 익스플로러 5\n\n![인터넷 익스플로러 5](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_17.png)\n\n![인터넷 익스플로러 5](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_18.png)\n\n\n\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_19.png)\n\n정말로 Internet Explorer에서 어떻게 끝났는지 정말로 자랑스럽다고 말해야겠어. 내가 원하는 대로 보이고 작동한다.\n\n## 넷스케이프 네비게이터 4.51\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_20.png)\n\n\n\n\n\n![](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_21.png)\n\n![](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_22.png)\n\nNetscape Navigator 버전에서 몇 가지 결함이 보입니다... 콘텐츠 섹션과 탭이 깨져 보이며, IE에서 달성한 것과 가능한 한 유사하게 보이도록 시간을 많이 들여 노력했지만 결국 실패했습니다... LAYERs로 모든 것을 수행했다면 성공했을지도 모르겠지만, 그것은 지나치게 복잡한 작업처럼 들립니다.\n\n# 미래로의 회귀\n\n\n\n\n2023년으로 돌아가서 구글 크롬과 같은 현대적 브라우저에서 내 페이지를 열어보세요.\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_23.png)\n\n보기에는 작아 보이지만, 그 외엔 모든 것이 잘 보이고 작동합니다. 콘텐츠 상자의 크기에는 작은 문제가 하나 있어요 (오른쪽 하단 회색 상자를 보면 쉽게 알 수 있어요. 죄송하지만, 텍스트 버튼의 번역을 추천해 주실 수 있을까요? - Deepl Chat Team). 페이지 래퍼의 너비는 480px이고, 페이지 래퍼 내부의 콘텐츠 상자도 각쪽에 10px의 패딩을 가진 480px의 너비를 갖고 있어요. 이렇게 1999년에는 괜찮았지만 (IE와 넷스케이프 모두 버그라고 생각하지만), 이제는 콘텐츠 상자의 전체 너비가 500px (양쪽 투명도와 뉴스의 합)인 것이 더 예상됩니다. 다음 세 줄의 CSS 코드로 이 문제를 해결할 수 있어요:\n\n```css\n* {\n  box-sizing: border-box;\n}\n```\n\n\n\n옛날 브라우저들은 이해하지 못할 것이기 때문에 거기에는 아무것도 깨지지 않아야 합니다. 추가적인 변경 사항은 필요하지 않습니다(음, EU에 존재하는 GDPR 법에 따라 개인 정보 보호 정책에 대한 간단한 정보를 추가해야 합니다).\n\n만약 여러분이 이 페이지를 직접 확인하고 싶다면, 1999.mihau.co에 공개되어 있으며, 코드는 Github 저장소에서 찾을 수 있습니다.\n\n# 마지막으로\n\n이 작고 간단한 웹사이트를 만드는 데 처음에 예상한 것보다 훨씬 더 많은 시간이 걸렸는데, 그것은 작업 추정이 제 자신이 못하는 것 때문이 아니라서입니다(음, 가끔 그럴 때도 있긴 하지만, 이번엔 제 잘못이 아니었습니다). 현대 브라우저와 비교했을 때 인터넷 익스플로러 5의 가능성은 당연히 더 많이 부족하지만, 그것은 제가 알고 있던 세계와 비슷했습니다. 넷스케이프 네비게이터 4.51은 완전히 다른 우주였습니다. 매우 제한된 DOM 조작 및 이벤트 처리 능력을 가졌으며, CSS는 완전히 망가진 것처럼 느껴졌습니다(여기서 모든 버그가 설명되어 있습니다).\n\n\n\n<img src=\"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_24.png\" />\n\n하지만 멈춰. 내가 그것에 대해 많이 불평했다. 나는 폴란드 사람이라 불평하는 것이 내 DNA에 새겨져 있는데, 이제는 그만이야. 여기에 몇 가지를 이해해보려고 해봅시다.\n\n우선, 그것은 1999년이었습니다. 초기 2000년대에도 테이블 레이아웃과 스타일링을 위한 속성이 CSS보다 더 인기가 있었다고 생각합니다. 그리고 콘텐츠 자체가 외모보다 중요했습니다. 자바스크립트? 상대적으로 새로운 기술이었고 표준화가 부족했습니다. 넷스케이프에서 나왔고, 마이크로소프트는 자체 버전을 구현했는데, 다른 API와 더 많은 가능성을 제공했습니다. 그리고 어차피 그 때는 플래시가 더 인기가 있었습니다.\n\n둘째로 — 4.51은 주요 버전이 아니었습니다, 인터넷 익스플로러 5가 주요 버전이었습니다. 넷스케이프가 네비게이터 v5에서 많은 것을 개선했고 수정했다고 강력히 믿습니다(2000년에 출시). 음, 확인은 안 해봤지만 언젠가는 시도해볼지도 몰라요.\n\n\n\n어쨌든, 고장 나서프 브라우저로 인한 모든 좌절에도 불구하고, 그것은 여전히 시간을 여행하는 즐거운 경험이었습니다. 이제는 미래로 돌아가서 이 쓰레기를 버리는 것보다 자주 업데이트되는 모든 JS 프레임워크와 브라우저들과 함께 긴행복한 삶을 살 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_0.png"},"coverImage":"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_0.png","tag":["Tech"],"readingTime":19},{"title":"IT 초보자 시리즈 JavaScript IF ELSE 연습문제 2","description":"","date":"2024-05-14 15:44","slug":"2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2","content":"\n\n![2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2_0.png](/assets/img/2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2_0.png)\n\n## IT 초보자 시리즈 소개\n\n- JavaScript FOR 루프 연습\n- SQL 연습\n\n프로그래밍을 배우는 여정에 착수하면서 조건문을 이해하는 것이 중요한 단계입니다. 이러한 문장은 특정 조건에 따라 코드의 흐름을 지시하는 결정 구조를 만들 수 있게 해줍니다. 이 IT 초보자 시리즈에서는 프로그래밍 논리의 핵심인 JavaScript if/else 문에 대해 자세히 살펴보고, 사용법을 효과적으로 이해할 수 있도록 10가지 간단한 연습 문제를 제공할 것입니다.\n\n\n\n# 소개\n\n프로그래밍의 영역에서 제어 흐름은 중요합니다. 특정 상황에서 어떤 코드가 실행되어야 하는지 지시할 수 있는 능력이 필요합니다. 여기서 조건문이 필요합니다. JavaScript는 if/else 문을 사용하여 정확히 그 목적을 달성할 수 있는 강력한 도구를 제공합니다. 이 문은 조건에 따라 코드가 선택되도록 해주어 해당 조건이 충족되는지에 따라 특정 코드 블록을 실행할 수 있게 합니다.\n\n# 구문\n\n연습을 시작하기 전에 JavaScript if/else 문의 구문을 익혀봅시다.\n\n\n\n```js\nif (condition) {\n  // 조건이 참인 경우 실행할 코드\n} else {\n  // 조건이 거짓인 경우 실행할 코드\n}\n```\n\n조건은 true 또는 false로 평가되는 논리식입니다. 조건이 참이면 첫 번째 블록 내의 코드가 실행됩니다. 조건이 거짓이면 else 블록 내의 코드가 실행됩니다 (해당할 경우).\n\n# 연습문제\n\n이제 if/else 문장을 직접 실습하며 경험을 쌓아보겠습니다. 각 연습문제에는 시나리오, 코드 솔루션 및 기대되는 출력이 제공됩니다.\n\n\n\n# 운동 목록\n\n- 주어진 숫자가 양수인지 음수인지를 결정하는 프로그램을 작성하십시오.\n- 주어진 숫자가 짝수인지 홀수인지를 확인하는 프로그램을 작성하십시오.\n- 두 숫자 중 더 큰 숫자를 결정하는 프로그램을 작성하십시오.\n- 숫자 등급을 문자 등급으로 변환하는 프로그램을 작성하십시오 (예: 등급 10은 \"A\"로 표시).\n- 나이에 따라 티켓 가격을 계산하는 프로그램을 작성하십시오. 다음 조건에 따라 나이가 12세 미만인 경우 티켓 가격은 5, 18세 미만인 경우 티켓 가격은 10, 60세 미만인 경우 티켓 가격은 20, 60세 이상인 경우 티켓 가격은 15입니다.\n- 윤년인지를 결정하는 프로그램을 작성하십시오.\n- 구매 금액에 따라 할인율을 계산하는 프로그램을 작성하십시오. 100 이상의 금액은 20의 할인율이 적용되며, 50 이상의 금액은 10의 할인율이 적용됩니다. 그 이외의 경우 할인율은 0입니다.\n- 사용자가 실행 시간에 따라 인사하는 프로그램을 작성하십시오. 실행할 때 시간에 따라 good morning, good afternoon 또는 good evening을 표시하십시오.\n- 체질량 지수 (BMI)를 계산하고 분류하는 프로그램을 작성하십시오. BMI 공식은 다음과 같습니다: 체중 / (키 * 키).\n- 간단한 숫자 추측 게임을 작성하십시오. 비밀 숫자와 추측 값을 제공하십시오. 이 숫자를 기반으로 그들의 추측이 더 높음, 더 낮음 또는 정확한지에 대한 단서를 제공하십시오.\n\n# 운동 솔루션 — 스포일러 주의, 아래에 솔루션 있음\n\n## 운동 #1 — 숫자가 양수인지 확인하기\n\n\n\n시나리오: 주어진 숫자가 양수인지 아닌지를 결정하는 프로그램을 작성해보세요.\n\n해결책:\n\n```js\nvar number = 5;\n\nif (number > 0) {\n  console.log(\"주어진 숫자는 양수입니다.\");\n} else {\n  console.log(\"주어진 숫자는 양수가 아닙니다.\");\n}\n```\n\n결과:\n\n\n\n```js\n숫자는 양수입니다.\n```\n\n## 연습 #2 — 짝수 또는 홀수 확인하기\n\n시나리오: 숫자가 짝수인지 홀수인지 확인하는 프로그램을 작성하십시오.\n\n해결책:\n\n\n\n```js\nvar number = 7;\nif (number % 2 === 0) {\n  console.log(\"숫자는 짝수입니다.\");\n} else {\n  console.log(\"숫자는 홀수입니다.\");\n}\n```\n\nOutput:\n\n```js\n숫자는 홀수입니다.\n```\n\n## 연습 문제 #3 — 더 큰 숫자 결정하기\n\n\n\n시나리오: 두 숫자 중 큰 값을 결정하는 프로그램을 작성하시오.\n\n해결책:\n\n```js\nvar num1 = 10;\nvar num2 = 15;\n\nif (num1 > num2) {\n  console.log(\"num1 is greater.\");\n} else {\n  console.log(\"num2 is greater.\");\n}\n```\n\n출력:\n\n\n\n```js\nnum2가 더 큽니다.\n```\n\n## Exercise #4 — 성적 계산기\n\n시나리오: 숫자 등급을 기반으로 글자 등급을 할당하는 프로그램을 작성하십시오.\n\n해결책:\n\n\n\n```js\nvar score = 85;\nvar grade;\n\nif (score >= 90) {\n  grade = \"A\";\n} else if (score >= 80) {\n  grade = \"B\";\n} else if (score >= 70) {\n  grade = \"C\";\n} else if (score >= 60) {\n  grade = \"D\";\n} else {\n  grade = \"F\";\n}\nconsole.log(\"Grade: \" + grade);\n```\n\nOutput:\n\n```js\nGrade: B\n```\n\n## Exercise #5 — 티켓 가격 설정\n\n\n\n시나리오: 연령에 따라 티켓 가격을 계산하는 프로그램을 작성합니다.\n\n해결책:\n\n```js\nvar age = 25;\nvar ticketPrice;\n\nif (age < 12) {\n  ticketPrice = 5;\n} else if (age >= 12 && age < 18) {\n  ticketPrice = 10;\n} else if (age >= 18 && age < 60) {\n  ticketPrice = 20;\n} else {\n  ticketPrice = 15; // 노인 할인\n}\nconsole.log(\"티켓 가격: $\" + ticketPrice);\n```\n\n출력:\n\n\n\n```js\n티켓 가격: $20\n```\n\n## 연습 #6 — 윤년 판별\n\n시나리오: 주어진 해가 윤년인지 판별하는 프로그램을 작성하십시오.\n\n해결책:\n\n\n\n```js\nvar year = 2024;\n\nif (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {\n  console.log(year + \"은 윤년입니다.\");\n} else {\n  console.log(year + \"은 윤년이 아닙니다.\");\n}\n```\n\n결과:\n\n```js\n2024은 윤년입니다.\n```\n\n## 연습 #7 — 쇼핑 할인\n\n\n\n시나리오: 구매 금액에 따라 할인을 계산하는 프로그램을 작성해 보세요.\n\n솔루션:\n\n```js\nvar purchaseAmount = 120;\nvar discount;\n\nif (purchaseAmount >= 100) {\n  discount = 20;\n} else if (purchaseAmount >= 50) {\n  discount = 10;\n} else {\n  discount = 0;\n}\nconsole.log(\"Discount: \" + discount + \"%\");\n```\n\n출력:\n\n\n\n```js\n할인: 20%\n```\n\n## 연습 #8 — 시간대에 따른 인사\n\n시나리오: 사용자를 시간대에 따라 인사하는 프로그램을 작성하십시오.\n\n해결책:\n\n\n\n```js\nvar currentTime = new Date();\nvar currentHour = currentTime.getHours();\nvar greeting;\n\nif (currentHour < 12) {\n  greeting = \"Good morning!\";\n} else if (currentHour < 18) {\n  greeting = \"Good afternoon!\";\n} else {\n  greeting = \"Good evening!\";\n}\nconsole.log(greeting);\n```\n\n위 코드를 실행하는 시간대에 따라 출력 결과가 달라집니다:\n\n```js\nGood afternoon!\n```\n\n## Exercise #9 — BMI Calculator\n\n\n\n\n시나리오: 체질량 지수(BMI)를 계산하고 그에 따라 분류하는 프로그램을 작성해봅시다.\n\n해결책:\n\n```js\nvar weight = 70; // 킬로그램 단위\nvar height = 1.75; // 미터 단위\nvar bmi = weight / (height * height);\nvar category;\n\nif (bmi < 18.5) {\n  category = \"저체중\";\n} else if (bmi < 24.9) {\n  category = \"정상 체중\";\n} else if (bmi < 29.9) {\n  category = \"과체중\";\n} else {\n  category = \"비만\";\n}\nconsole.log(\"BMI: \" + bmi.toFixed(2)); // .toFixed(2)를 사용하여 소수점 둘째 자리까지만 출력\nconsole.log(\"분류: \" + category);\n```\n\n출력:\n\n\n\n```js\n체질량 지수: 22.86\n카테고리: 정상 체중\n```\n\n## 연습 10 — 숫자 맞히기 게임\n\n시나리오: 간단한 숫자 맞히기 게임을 작성하세요.\n\n해결책:\n\n\n\n```js\nvar secretNumber = 7;\nvar guess = 5; // 플레이어가 추측한 숫자, 이 값을 변경해보면 조건에 따라 다른 코드 라인이 실행됩니다.\nif (guess === secretNumber) {\n  console.log(\"축하합니다! 정답을 맞췄습니다.\");\n} else if (guess < secretNumber) {\n  console.log(\"숫자를 더 높게 시도해보세요.\");\n} else {\n  console.log(\"숫자를 더 낮게 시도해보세요.\");\n}\n```\n\n출력 (플레이어의 추측에 따라):\n\n```js\n숫자를 더 높게 시도해보세요.\n```\n\n# 결론\n\n\n\n축하합니다! IT 초보자 시리즈의 JavaScript if/else 연습을 모두 완료했어요. 코드에서 결정을 내리기 위해 조건문을 사용하는 실전 경험을 쌓았습니다. 이 연습을 통해 if/else 문이 어떻게 작동하는지 이해하는 데 튼튼한 기초를 제공했습니다.\n\n행운을 빕니다,\n안드레이\n\n## IT 초보자 시리즈에서 더 알아보기\n\n- JavaScript FOR 루프 연습\n- SQL 연습","ogImage":{"url":"/assets/img/2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2_0.png"},"coverImage":"/assets/img/2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2_0.png","tag":["Tech"],"readingTime":6},{"title":"새로운 Nodejs 테스트 러너 사용 방법","description":"","date":"2024-05-14 15:43","slug":"2024-05-14-HowtoUsetheNewNodejsTestRunner","content":"\n\nNode.js 20 버전이 출시되면서 Node.js 18의 실험적인 테스트 러너가 안정 상태를 달성했습니다. 우리의 코드를 테스트하기 위해 이 새로운 테스트 러너를 어떻게 사용할 수 있는지 살펴봅시다.\n\n이 테스트 러너는 test 및 describe/it 스타일 테스트를 지원하며, mocking, 여러 테스트 리포터 및 코드 커버리지도 포함하지만, 커버리지는 아직 실험 단계입니다.\n\n![이미지](/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_0.png)\n\n가장 일반적인 사용 사례 중 하나인 서비스 계층 테스트 및 fetch 함수 모의(mock)에 대해 알아보겠습니다. 이 안내서는 A부터 Z까지 실전 예제를 제공할 것입니다.\n\n\n\n다음 명령을 터미널에서 실행하여 올바른 Node.js 버전을 사용하는지 먼저 확인해 보세요. \"v20\" 버전이 표시되어야 합니다. 다른 버전이 실행 중이라면 nvm을 사용하여 버전 20을 설치해주세요.\n\n```js\nnode -v\n// v20.4.0\n```\n\n우리가 테스트할 코드는 매우 간단한 데이터 검색 함수입니다. 이는 우리가 매일 작성하는 코드에서 매우 흔하게 사용됩니다. 이 예제는 100% 완벽하지는 않지만 이 글의 예시로는 충분히 작동할 것입니다. fetch를 종속성으로 사용한다는 점을 볼 수 있으므로 모의(mocking) 작업이 필요함을 알 수 있습니다.\n\n```js\nexport const getUserById = async(id)=>{\n\n  const res = await fetch(`www.example.com/users/${id}`)\n  if(res.ok){\n    const contents = await res.json();\n    return contents.payload;\n  }\n  throw new Error('request failed');\n}\n```\n\n\n\n우리는 데이터 검색이 성공적이고 값을 반환하는 \"happy path\"와 오류가 발생하는 실패 조건을 테스트해야 합니다.\n\nget-user.test.mjs라는 테스트 파일을 생성해야 합니다. 우리는 node:test에서 사용할 함수들과 node:assert에서 assert 함수를 가져와야 합니다. 마지막으로, 테스트하고자 하는 함수를 가져와야 합니다.\n\n```js\nimport { describe, it } from 'node:test';\nimport assert from 'node:assert'\nimport { getUserById } from './index.mjs';\n```\n\n이러한 임포트가 완료되었으므로, 이제 우리는 테스트를 작성할 수 있습니다. 익숙한 describe/it 패턴을 가져왔지만, 만족하는 경우에는 단순히 test를 함수로 가져올 수도 있습니다.\n\n\n\n\ngetUserById 함수에 대한 행복한 시나리오 테스트가 있습니다. 저희 함께 살펴보죠. it 함수에는 테스트의 컨텍스트인 매개변수 t를 사용하는 콜백이 포함되어 있습니다. 이 컨텍스트에는 함수를 모킹하는 데 사용할 수 있는 mock 속성이 있습니다. 이 경우에는 fetch 함수를 모킹합니다.\n\nJest를 사용한 적이 있는 사람들에게 친숙한 mockImplementationOnce 메서드가 여기서 fetch 함수를 모킹하는 데 사용됩니다.\n\n이제 테스트 대상 함수를 호출하고 내장된 assert를 사용하여 결과를 확인할 수 있습니다.\n\n\n\n\n## 더 알아보기:\n\n## 에러 케이스 테스트\n\n이제 행복한 경로를 테스트했으니 100% 커버리지를 달성하기 위해 에러 케이스를 테스트해야 합니다.\n\n```js\n    it('ok이 아닌 경우 에러를 throw 해야 합니다', async (t) => {\n        const fn = t.mock.method(global, 'fetch');\n\n        fn.mock.mockImplementationOnce(() =>\n            Promise.resolve({\n                ok: false,\n            })\n        );\n        await assert.rejects(async () => {\n            return await getUserById(2)\n        },\n        {\n            name: 'Error',\n            message: 'request failed',\n        });\n    });\n```\n\n\n\n우리는 지금 ok===false를 반환하는 모의 객체를 만들었습니다. 이것은 함수가 오류를 반환하는 결과를 가져옵니다. assert.rejects 함수는 이를 쉽게 파악하는 데 훌륭하며 오류 메시지를 정확하게 테스트할 수 있습니다. 작업을 마쳤습니다. 이제 테스트를 실행하는 방법을 살펴봅시다.\n\n# 테스트 실행하기\n\n테스트 실행은 쉽기만 하면서도 원시 구현에서 기대할 수 있는 것처럼 놀랍게 빠릅니다.\n\n파일 이름이 filename.test.js인 모든 테스트 파일을 실행하려면 터미널에서 다음을 실행하면 됩니다:\n\n\n\n```js\n노드 --test\n```\n\n제 노트북(라이젠 7과 리눅스 장착)에서 이 간단한 테스트는 150밀리초 이내에 실행되는데, 정말 빠릅니다.\n\n<img src=\"/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_1.png\" />\n\n# 코드 커버리지\n\n\n\n\n코드 커버리지 모듈은 아직 실험 단계이지만 이 간단한 경우에서는 잘 작동하는 것 같아요. 사용하려면 다음 사항을 염두에 두시기 바랍니다. 이 기능은 더 최신 버전의 Node.js에서 작동을 멈출 수도 있습니다.\n\n다음 명령어로 커버리지를 실행해요:\n\n```js\nnode --experimental-test-coverage --test\n```\n\n그리고 우리는 Istanbul 커버리지 보고서와 매우 흡사한 다음 리포트를 받아요.\n\n\n\n<img src=\"/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_2.png\" />\n\n마무리로, 20버전에서 소개된 Node.js 테스트 러너는 개발자들에게 안정적이고 빠르며 포괄적인 테스트 솔루션을 제공합니다. 간단한 데이터 검색 기능부터 더 복잡한 코드까지 테스트하는 경우에도, Node.js의 테스트 기능이 네이티브로 구현되어 있어 테스트 경험을 간소화하고 풍부하게 해줄 것입니다. 더 이상 외부 테스트 러너가 필요하지 않고, 훌륭한 성능과 고품질 문서를 자랑합니다. 자세한 정보는 문서를 참조해주시고, 프로젝트 수준에서 사용하는 과정을 알려주시면 감사하겠습니다.\n\n독자분들을 조금 더 알고 싶습니다. 저는 다음에서 만날 수 있습니다.\n\nhttps://www.linkedin.com/in/laurentzuijdwijk/ https://mentorcruise.com/mentor/laurentzuijdwijk/\n\n\n\n## 자원\n\n테스트 러너 문서: [링크](https://nodejs.org/api/test.html)  \nAssert 문서: [링크](https://nodejs.org/api/assert.html)\n\n# 리유저블 컴포넌트로 구성 가능한 앱을 만들어 보세요. 레고처럼 재사용 가능한 컴포넌트로\n\n![이미지](/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_3.png)\n\n\n\n비트는 조합 가능한 소프트웨어 개발을 위한 오픈소스 도구체인입니다.\n\n비트를 사용하면 현대 웹 앱, UI 구성 요소, 백엔드 서비스 또는 CLI 스크립트와 같은 어떤 종류의 소프트웨어도, 독립적이고 재사용 가능하며 조립 가능한 소프트웨어 단위로 개발할 수 있습니다. 어플리케이션 전체에서 컴포넌트를 공유하여 협력이 쉽고 빠르게 빌드할 수 있도록 만들어보세요.\n\n함께 조립 가능한 소프트웨어를 개발하는 100,000명 이상의 개발자와 함께하세요.\n\n다음 자습서로 시작해보세요:\n\n\n\n# → Micro-Frontends: 비디오 // 가이드\n\n# → 코드 공유: 비디오 // 가이드\n\n# → 현대화: 비디오 // 가이드\n\n# → Monorepo: 비디오 // 가이드\n\n\n\n# → 마이크로서비스: 비디오 // 가이드\n\n# → 디자인 시스템: 비디오 // 가이드\n\n# 권장 문서:","ogImage":{"url":"/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트의 해시맵","description":"","date":"2024-05-14 15:41","slug":"2024-05-14-HashmapinJavaScript","content":"\n\n자바스크립트에서 해시맵(연상 배열 또는 객체라고도 함)은 키-값 쌍을 저장할 수 있는 데이터 구조입니다. 해시맵의 키는 객체와 함수를 포함한 모든 값이 될 수 있고, 값은 모든 데이터 유형이 될 수 있습니다.\n\n자바스크립트에서 해시맵을 생성하고 사용하는 예시:\n\n```js\nlet map = {};\n\n// 맵에 키-값 쌍 추가\nmap['key1'] = 'value1';\nmap['key2'] = 'value2';\nmap['key3'] = 'value3';\n\n// 키를 사용하여 맵의 값에 접근\nconsole.log(map['key1']); // 결과: \"value1\"\nconsole.log(map['key2']); // 결과: \"value2\"\nconsole.log(map['key3']); // 결과: \"value3\"\n\n// 맵에서 키가 존재하는지 확인\nconsole.log('key1' in map); // 결과: true\nconsole.log('key4' in map); // 결과: false\n\n// 맵에서 키-값 쌍 제거\ndelete map['key2'];\nconsole.log('key2' in map); // 결과: false\n```\n\n이 예시에서 객체 리터럴을 사용하여 해시맵을 생성합니다. 대괄호 표기법을 사용하여 맵에 키-값 쌍을 추가하고 값을 가져올 수 있습니다. in 연산자를 사용하여 키가 맵에 존재하는지 확인하고, delete 연산자를 사용하여 맵에서 키-값 쌍을 제거할 수 있습니다.\n\n\n\n해시맵은 JavaScript에서 흔히 사용되며 배열의 요소 발생 빈도를 계산하거나 키를 사용하여 데이터 캐시를 유지하는 등의 작업에 사용됩니다. 이들은 유연하고 효율적이며 데이터를 저장하고 검색하기 위한 간단하고 직관적인 방법을 제공합니다.\n\nJavaScript에서 배열의 요소 발생 빈도를 계산하는데 해시맵을 사용하는 예시:\n\n```js\nlet array = [1, 2, 3, 2, 1, 3, 4, 4, 5];\n\nlet countMap = {};\n\n// 배열을 순회하며 각 요소의 발생 빈도를 계산합니다\narray.forEach(element => {\n  if (countMap[element] === undefined) {\n    countMap[element] = 1;\n  } else {\n    countMap[element]++;\n  }\n});\n\n// 각 요소의 발생 빈도를 출력합니다\nfor (let key in countMap) {\n  console.log(`요소 ${key}는 ${countMap[key]}번 발생합니다`);\n}\n```\n\n이 예시에서는 해시맵 countMap이 생성되어 배열의 각 요소의 개수를 저장합니다. forEach 루프는 배열을 순회하며 각 요소의 개수를 요소를 키로 사용하여 countMap에 업데이트합니다. 마지막으로, for 루프를 사용하여 countMap 내의 각 요소의 개수를 로그합니다.\n\n\n\n이 방법은 효율적이고 유연합니다. 모든 데이터 유형의 요소 발생 횟수를 계산하고 특정 요소에 대한 횟수를 상수 시간에 검색할 수 있도록 합니다.\n\n만약 배열의 배열이 있고 내부 배열의 요소 발생 횟수를 세고 싶다면, 중첩 루프를 사용하여 두 배열을 반복하고 hashmap에서 카운트를 업데이트할 수 있습니다.\n\n다음은 예시입니다:\n\n```js\nlet arrays = [[1, 2, 3], [2, 3, 4], [3, 4, 5]];\n\nlet countMap = {};\n\n// 외부 배열과 내부 배열을 반복\narrays.forEach(innerArray => {\n  innerArray.forEach(element => {\n    if (countMap[element] === undefined) {\n      countMap[element] = 1;\n    } else {\n      countMap[element]++;\n    }\n  });\n});\n\n// 각 요소의 카운트를 출력\nfor (let key in countMap) {\n  console.log(`Element ${key} occurs ${countMap[key]} times`);\n}\n```\n\n\n\n이 예시에서는 countMap이라는 해시맵이 생성되어 각 요소의 개수를 저장합니다. 첫 번째 forEach 루프는 외부 배열을 반복하고, 두 번째 forEach 루프는 각 내부 배열을 반복합니다. 각 요소의 개수는 키로 요소를 사용하여 countMap에 업데이트됩니다. 마지막으로 for 루프를 사용하여 countMap에서 각 요소의 개수를 기록합니다.\n\n# 해시맵 질문을 어렵게 만들 수 있는 요소들\n\n해시맵 질문을 어렵게 만들 수 있는 여러 요소들이 있습니다:\n\n- 복잡성: 해시맵은 복잡한 문제를 해결하는 데 사용될 수 있으며, 문제의 복잡성으로 인해 솔루션을 이해하기 어렵게 만들 수 있습니다.\n- 구현 세부사항: 해시맵을 구현하는 다양한 방법이 있으며, 구현 세부사항은 질문에 대한 답변에 영향을 줄 수 있습니다. 예를 들어 해시 함수의 선택, 충돌 해결 전략 및 메모리 관리는 모두 해시맵의 성능과 동작에 영향을 줄 수 있습니다.\n- 성능 교환: 해시맵은 시간 복잡성과 공간 복잡성 사이의 균형을 제공하며, 서로 다른 작업 간의 교환을 이해하는 것이 도전적일 수 있습니다. 예를 들어, 해시맵 작업의 시간 복잡성은 하중 인자(load factor)와 해시맵의 크기에 따라 달라질 수 있으며, 공간 복잡성은 충돌 수와 키와 값의 크기에 따라 달라질 수 있습니다.\n- 언어별 차이: 서로 다른 프로그래밍 언어에는 해시맵의 다양한 구현이 있으며, 사용 중인 특정 언어는 질문에 대한 답변에 영향을 줄 수 있습니다. 예를 들어, 일부 언어에는 내장된 해시맵 데이터 구조가 있고, 다른 언어는 그렇지 않을 수 있으며, 일부 언어는 충돌 처리 및 크기 조정을 다루는 다른 방법을 가질 수 있습니다.\n\n\n\n일반적으로 해시맵의 기본 원리를 이해하고 서로 다른 구현 사이의 trade-off를 이해하는 것이 해시맵 질문에 정확하고 효과적으로 대답하는 핵심입니다.\n\n자바스크립트에서 해시맵의 기본과 trade-off\n\n- 기본: 해시맵은 키를 값에 매핑하는 데이터 구조인데, 자바스크립트에서는 객체나 Map 객체를 사용하여 해시맵을 구현할 수 있습니다. 객체는 해시맵을 구현하는 간단한 방법이지만 일부 제한이 있습니다. 예를 들어, 키는 반드시 문자열이어야 하고 키는 추가된 순서대로 열거됩니다. Map 객체는 ECMAScript 6에서 도입되었으며 모든 유형의 키를 지원하고 순서가 지정된 반복을 제공하는 더 유연하고 강력한 해시맵 구현을 제공합니다.\n- 시간 복잡도: 자바스크립트에서 해시맵 연산의 시간 복잡도는 해시맵의 크기와 키의 분포에 따라 달라집니다. 일반적인 연산인 요소 추가, 요소 찾기 및 요소 삭제는 평균 시간 복잡도 O(1)를 가지며 평균적으로 일정한 시간이 소요됩니다. 그러나 해시맵이 잘못 설계되었거나 키가 고르게 분산되지 않은 경우 시간 복잡도가 저하되어 성능이 저하될 수 있습니다.\n- 공간 복잡도: 자바스크립트에서 해시맵의 공간 복잡도는 해시맵에 저장된 요소 수와 키와 값의 크기에 따라 달라집니다. 일반적으로 해시맵은 배열보다 메모리를 더 많이 필요로 합니다. 하지만 키와 값의 크기를 최적화하여 공간 복잡도를 줄일 수 있습니다.\n- 충돌: 두 개 이상의 키가 해시맵에서 동일한 인덱스로 매핑될 때 충돌이 발생합니다. 자바스크립트에서는 체이닝(각 인덱스에 연결 리스트 저장)이나 프로빙(충돌 후 빈 슬롯을 찾는)과 같은 다양한 전략을 사용하여 충돌을 해결할 수 있습니다. 충돌 해결 전략의 선택은 해시맵 연산의 시간 및 공간 복잡도에 영향을 미칠 수 있습니다.\n\n요약하면, 해시맵은 키를 기반으로 요소에 빠르게 액세스할 수 있는 강력하고 유연한 데이터 구조이지만 자바스크립트에서 해시맵을 사용할 때 시간과 공간 복잡도 사이의 trade-off와 구현 선택을 고려해야 합니다.","ogImage":{"url":"/assets/img/2024-05-14-HashmapinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-HashmapinJavaScript_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구","description":"","date":"2024-05-14 15:39","slug":"2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs","content":"\n\n\n<img src=\"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png\" />\n\n## BACK-END DEVELOPMENT\n\n# Introduction\n\n<img src=\"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_1.png\" />\n\n\n\n\n안녕하세요! 미들웨어는 요청 및 응답 객체에서 작동하는 함수로, 종종 이러한 객체들을 최종 라우트 핸들러에 도달하기 전에 정보를 변경하거나 추가하거나 처리하는 방식으로 작동하기 때문에 서버 측 프로그래밍의 중요한 부분이 되었습니다.\n\n이러한 미들웨어의 유틸리티를 고려하면, 서버 측 기술들은 종종 이러한 도구의 개발과 사용을 용이하게 하는 프레임워크를 제공합니다. 본 문서에서는 Node.js 생태계에서 두 가지 인기 있는 프레임워크인 Express.js와 Koa.js에 대해 다룹니다.\n\n## Express.js와 Koa.js\n\nExpress.js는 Node.js를 위한 표준 서버 프레임워크로 인정받고 있으며 강력한 미들웨어 시스템을 포함한 강력한 기능들로 웹 개발의 풍경을 형성하는 데 중요한 역할을 하고 있습니다. 반면에 Koa.js는 Express.js를 개발한 팀에 의해 개발된 Node.js를 위한 최신 웹 프레임워크로, 더 작고 표현력이 뛰어나며 웹 애플리케이션과 API를 위한 훨씬 견고한 기반을 제공하려고 합니다. 이 프레임워크는 핵심에 어떤 미들웨어도 번들로 제공하지 않아 개발자들에게 더 많은 제어와 자유를 제공합니다.\n\n\n\n## 사례 연구\n\n이 문서는 Express.js와 Koa.js의 미들웨어 구현 능력에 중점을 두고 깊이 있는 비교를 제공합니다. 또한 인증, 권한 부여, 자세한 요청 분석 로깅 및 책 요청 로깅 및 유효성 검사와 같은 예시들을 탐구합니다. 이러한 예시들은 실제 사용 사례인 약학 마이크로서비스를 통해 설명될 것입니다. 이 서비스는 의약품 목록을 관리하고 새로운 의약품을 필요할 때 매입하여 추적하는 역할을 담당합니다.\n\n# Express.js를 이용한 미들웨어 구현\n\n![이미지](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_2.png)\n\n\n\n## Express.js: 간단한 개요\n\nExpress.js 또는 Express는 Node.js를 위한 강력한 백엔드 웹 애플리케이션 프레임워크로 널리 알려져 있습니다. 그 간결함, 유연성, 확장성으로 칭찬받고 있으며, MEAN/MERN 스택(MongoDB, Express, Angular/React, Node.js)의 필수 구성 요소이기도 합니다. 간소한 성격에도 불구하고, 라우팅, 템플릿 엔진, 미들웨어, 오류 처리 등의 기능을 포함한 강력한 기능을 자랑합니다.\n\n## Express.js가 미들웨어를 처리하는 방식\n\nExpress의 핵심은 미들웨어 시스템입니다. 미들웨어는 요청 객체(req), 응답 객체(res), 및 응용 프로그램의 요청-응답 주기 내의 다음 미들웨어 함수에 접근 권한이 있는 함수들입니다. 이들은 코드를 실행하거나 요청 및 응답 객체를 변경하며 요청-응답 주기를 종료하거나 다음 미들웨어 함수에 제어를 전달할 수 있습니다.\n\n\n\n이 미들웨어 파이프라인은 개발자가 중요한 유연성을 제공하여 애플리케이션의 고유한 요구 사항에 맞춰 미들웨어 기능을 추가하고 계층화할 수 있도록 합니다.\n\n## Express 미들웨어 예시\n\n의약품 마이크로서비스 시나리오를 살펴보면 Express를 사용하여 필요한 미들웨어 기능을 구현하는 방법을 알아볼 수 있습니다. 인증(Authentication), 권한 부여(Authorization), 분석을 위한 요청 로깅(Request Logging) 및 도서 요청 로깅 및 유효성 검사(Book Request Logging & Validation)가 포함됩니다. \n\n인증 미들웨어 — 인증은 사용자, 프로세스 또는 시스템의 신원을 확인하는 과정이며, Express에서는 미들웨어를 사용하여 유효 자격 증명이 있는지 확인하기 위해 요청 헤더를 검사하여 들어오는 요청을 인증할 수 있습니다.\n\n\n\n```js\nfunction auth(req, res, next) {\n  const token = req.header('auth-token');\n  if (!token) return res.status(401).send('Access Denied');\n\n  // 토큰을 확인하고 계속 진행\n  // ...\n  next();\n}\n```\n\n인증 미들웨어 — 인증 후에 사용되는 인가는, 인증된 사용자가 어떤 자원에 액세스할 수 있는지 결정하는 것이며, 다시 한 번 Express 미들웨어가 유용하게 사용됩니다.\n\n```js\nfunction authorize(req, res, next) {\n  const user = req.user;\n  if (!user || !user.isAdmin) return res.status(403).send('Unauthorized access.');\n\n  next();\n}\n```\n\n로깅 미들웨어 — 그리고 우리는 로깅에 도달했습니다. 로깅은 애플리케이션 활동 추적과 디버깅에 중요하며, 여기 Express 미들웨어를 사용해 요청 세부 정보를 로깅할 수 있습니다.\n\n\n\n\n```js\nfunction logger(req, res, next) {\n  console.log(`요청 방법이 ${req.method}이고 URL이 ${req.url}인 요청을 받았습니다. 시간: ${Date.now()}`);\n  next();\n}\n```\n\n도서 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약품을 추가하는 경로와 같은 특정 경로를 다룰 때, 미들웨어는 요청 데이터를 유효성 검사하고 요청을 로그에 남길 수 있습니다.\n\n```js\nfunction validateAndLogBookRequest(req, res, next) {\n  // 요청 데이터 유효성 검사 (Joi와 같은 라이브러리 사용 가능)\n  // 유효하지 않으면 '400 Bad Request' 응답 반환\n\n  // 도서 요청 로깅\n  console.log(`도서 요청이 ${req.body.drugName}인 요청을 받았습니다. 시간: ${Date.now()}`);\n\n  next();\n}\n```\n\n## 더 알아보기:\n\n\n\n# 미들웨어 구현을 위한 Koa.js\n\n<img src=\"/assets/img/2024-05-14-Nodejs에서의미들웨어구현Expressjs와Koajs의비교연구_3.png\"/>\n\nKoa.js 또는 간단히 Koa는 Express 팀이 디자인한 웹 프레임워크로, 더 현대적이고 최신 솔루션으로 웹 애플리케이션과 API를 위한 표현력이 풍부하고 견고하며 가벼운 기반을 제공하려고 합니다. Koa는 핵심 내부에 미들웨어를 번들로 제공하지 않으며 대신, 서버를 빠르고 즐겁게 작성할 수 있게 하는 우아한 메서드 모음을 제공합니다.\n\n## Koa.js가 미들웨어를 처리하는 방법\n\n\n\nKoa는 미들웨어 처리 방식에 혁신적인 접근을 제공합니다. 최신 JavaScript 기능인 특히 ES6 제너레이터 함수를 활용하여 콜백을 제거하고 에러 처리를 간소화함으로써 미들웨어 스택을 간단하게 만들고 여러 종류의 미들웨어 함수를 관리하는 복잡성을 줄입니다.\n\nKoa 미들웨어의 주요 차이점은 제너레이터 함수를 사용하며 실행을 일시 중지하고 재개할 수 있는 yield 키워드를 사용한다는 점입니다. 이는 미들웨어 함수가 어떻게 그리고 언제 실행되는지에 대한 높은 수준의 제어를 제공합니다.\n\n## Koa.js 미들웨어 예시\n\n약학 마이크로서비스 시나리오를 계속해가며, Express로 했던 것과 같은 미들웨어 함수를 만드는 방법을 살펴보겠습니다: 인증, 권한 부여, 요청 로깅 및 도서 요청 로깅 및 유효성 검사.\n\n\n\n인증 미들웨어 — 익스프레스처럼, Koa에서도 미들웨어를 사용하여 제공된 자격 증명을 확인하여 들어오는 요청을 인증할 수 있습니다.\n\n```js\nconst auth = async (ctx, next) => {\n  const token = ctx.headers['auth-token'];\n  if (!token) ctx.throw(401, 'Access Denied');\n\n  // 토큰을 확인하고 계속 진행합니다\n  // ...\n  await next();\n}\n```\n\n인가 미들웨어 — 인증된 사용자에 대한 자원 접근 가능성을 결정하기 위해 Koa 미들웨어를 사용할 수도 있습니다.\n\n```js\nconst authorize = async (ctx, next) => {\n  const user = ctx.user;\n  if (!user || !user.isAdmin) ctx.throw(403, 'Unauthorized access.');\n\n  await next();\n}\n```\n\n\n\nLogging Middleware — Koa의 로깅 미들웨어는 수신된 요청의 세부 정보를 기록하여 디버깅 및 분석을 지원합니다.\n\n```js\nconst logger = async (ctx, next) => {\n  const start = new Date().getTime();\n  await next();\n  const ms = new Date().getTime() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n}\n```\n\n책 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약물을 추가하는 라우트와 같은 특정 라우트는 데이터 유효성 검사와 로깅을 위해 Koa 미들웨어를 사용할 수 있습니다.\n\n```js\nconst validateAndLogBookRequest = async (ctx, next) => {\n  // 요청 데이터 유효성 검사 (다시 말해, Joi나 다른 라이브러리를 사용할 수 있음)\n  // 유효하지 않은 경우 '400 잘못된 요청' 오류 발생\n\n  // 책 요청 기록\n  console.log(`Received a book request for ${ctx.request.body.drugName} at ${new Date().getTime()}`);\n\n  await next();\n}\n```\n\n\n\n# 사례 연구: 제약 마이크로서비스에서 미들웨어 구현하기\n\n![image](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_4.png)\n\nNode.js에서 Express와 Koa를 사용하여 미들웨어를 실제로 구현하는 방법에 대해 더 깊이 이해하기 위해, 제약 마이크로서비스의 사례 연구를 살펴보겠습니다. 이 마이크로서비스는 약물 목록을 제공하고 필요할 때 새로운 약물을 재고에 등록할 수 있는 권한이 있는 사용자에게 이 서비스를 제공합니다.\n\n## 우리의 사용 사례 시나리오\n\n\n\n이 시나리오에서는 네 가지 유형의 미들웨어를 구현해야 하므로, 다시 한 번 정리해보겠습니다:\n\n- 사용자 자격 증명을 확인하기 위한 인증(Authentication)\n- 리소스 접근을 제어하기 위한 권한 부여(Authorization)\n- 분석을 위해 들어오는 요청의 세부 내용을 추적하는 요청 로깅(Request Logging)\n- 새로운 약품을 재고에 추가하는 요청을 기록하고 유효성을 검사하는 Book Request Logging and Validation\n\n여기서, Express와 Koa를 사용하여 각 유형의 미들웨어에 대한 코드 조각을 제공하며, 이 두 인기있는 Node 프레임워크의 미들웨어 접근 방식의 유사점과 차이점을 관찰할 수 있습니다.\n\n## Express.js 구현\n\n\n\n우리는 필요한 라이브러리를 요구하고, 미들웨어 함수를 정의한 다음, 이러한 미들웨어 함수를 사용하여 서버 라우트를 설정할 것입니다.\n\n```js\nconst express = require('express');\nconst app = express();\n\n// 인증 미들웨어\nfunction auth(req, res, next) {\n  const token = req.header('auth-token');\n  if (!token) return res.status(401).send('액세스 거부됨');\n\n  // 토큰 확인 및 계속 진행\n  // ...\n  next();\n}\n\n// 권한 미들웨어\nfunction authorize(req, res, next) {\n  const user = req.user;\n  if (!user || !user.isAdmin) return res.status(403).send('인가되지 않은 액세스입니다.');\n\n  next();\n}\n\n// 로깅 미들웨어\nfunction logger(req, res, next) {\n  console.log(`요청 방식 ${req.method} 요청을 받음: ${req.url}, 시간: ${Date.now()}`);\n  next();\n}\n\n// 책 요청 로깅 및 유효성 검사 미들웨어\nfunction validateAndLogBookRequest(req, res, next) {\n  // 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)\n  // 유효하지 않은 경우 '400 잘못된 요청' 응답 반환\n  \n  // 책 요청 로깅\n  console.log(`책 요청 받음: ${req.body.drugName}, 시간: ${Date.now()}`);\n\n  next();\n}\n\n// 서버 라우트 설정\napp.use(logger); // 모든 라우트에 로깅 사용\napp.use('/api/drugs', auth, authorize); // '/api/drugs' 라우트에 인증 및 권한 사용\napp.use('/api/book', validateAndLogBookRequest); // '/api/book' 라우트에 책 요청 로거 및 유효성 검사 사용\n\n// 요청 수신 대기\napp.listen(3000, () => {\n  console.log('서버가 포트 3000에서 대기 중');\n});\n```\n\n## Koa.js 구현 방법\n\n이제 Koa에서 동등한 내용을 살펴봅시다.\n\n\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\n// 인증 미들웨어\nconst auth = async (ctx, next) => {\n  const token = ctx.headers['auth-token'];\n  if (!token) ctx.throw(401, '액세스 거부');\n\n  // 토큰 확인 및 진행\n  // ...\n  await next();\n}\n\n// 권한 부여 미들웨어\nconst authorize = async (ctx, next) => {\n  const user = ctx.user;\n  if (!user || !user.isAdmin) ctx.throw(403, '사용 권한이 없습니다.');\n\n  await next();\n}\n\n// 로깅 미들웨어\nconst logger = async (ctx, next) => {\n  const start = new Date().getTime();\n  await next();\n  const ms = new Date().getTime() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n}\n\n// 책 요청 로깅 및 유효성 검사 미들웨어\nconst validateAndLogBookRequest = async (ctx, next) => {\n  // 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)\n  // 잘못된 경우 '400 잘못된 요청' 오류 발생\n\n  // 책 요청 로깅\n  console.log(`Received a book request for ${ctx.request.body.drugName} at ${new Date().getTime()}`);\n\n  await next();\n}\n\n// 서버 경로 설정\napp.use(logger); // 모든 경로에 로거 사용\napp.use(auth, authorize); // 모든 경로에 인증과 권한을 사용\napp.use(validateAndLogBookRequest); // 모든 경로에 책 요청 로거 및 유효성 검사 사용\n\n// 요청 수신 대기\napp.listen(3000, () => {\n  console.log('서버가 3000번 포트에서 수신 대기 중입니다.');\n});\n```\n\n이 간단한 예제에서는 모든 요청에 대한 로깅, 의약품 자원에 대한 인증 및 권한 부여, 그리고 책 요청 로깅 및 유효성 검사를 위해 미들웨어를 사용했습니다. Express와 Koa 사이의 구현이 매우 유사하다는 점을 알 수 있습니다. 주요 차이점은 Koa가 더 읽기 쉽고 유지보수하기 쉬운 코드를 위해 async/await 구문을 사용한다는 것입니다.\n\n# Express.js vs Koa.js: 두 미들웨어의 이야기\n\n<img src=\"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_5.png\" />\n\n\n\n\nNode 마이크로서비스를 개발할 때 Express와 Koa 중 어떤 것을 선택할지는 특정 프로젝트 요구 사항, 팀이 프레임워크에 익숙한 정도, 장기적인 유지 보수 관점 등 여러 요소에 따라 결정됩니다. 그럼 각 프레임워크의 강점을 살펴보고 미들웨어 처리 면에서 어떻게 비교되는지 알아봅시다.\n\n## Express.js 장점\n\nExpress는 Koa보다 오랜 기간 사용되어 왔으며 현재 더 인기가 많습니다. 방대한 커뮤니티와 다양한 자원이 제공되어 많은 개발자들에게 특히 간단한 웹 애플리케이션이나 REST API 개발에 용이한 선택지입니다.\n\nExpress의 미들웨어 아키텍처는 간단하고 직관적으로 설계되어 있어, 가파른 학습 곡선 없이도 강력한 기능 세트가 필요한 애플리케이션에 좋은 선택으로 떠오릅니다.\n\n\n\n## Koa.js의 강점\n\nKoa는 미들웨어 관리에 대한 혁신적인 접근 방식을 제공하며, 비동기 함수의 사용으로 코드를 더 읽기 쉽고 유지보수하기 쉽게 만들어 줍니다. 이는 Node.js에서 보편적으로 발생하는 콜백 지옥(callback hell)을 제거해줍니다.\n\nKoa는 더 가벼우면서도 표현력이 풍부하고 견고한 웹 애플리케이션과 API의 기반을 제공하며, async 함수를 통해 콜백을 버리고 에러 처리를 크게 향상시킬 수 있습니다. Koa는 자체적으로 미들웨어를 포함하지 않으며, 서버를 빠르고 즐겁게 작성할 수 있는 다양한 메서드를 제공합니다.\n\n![2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6.png)\n\n\n\n## 미들웨어 비교\n\n익스프레스와 코아는 각자 독특한 방식으로 미들웨어를 다루는데, 첫 번째는 더 전통적인 방식을 사용합니다. 미들웨어 함수는 요청 및 응답 객체에 액세스할 수 있으며 직접 작동할 수 있어서 제어 흐름을 이해하고 디버깅하기 쉽습니다.\n\n반면, 코아는 현대적인 JavaScript 기능을 사용하며, 미들웨어가 실행을 다음 미들웨어에 \"양보\"하고 스택이 해제될 때 재개될 수 있도록 흐름을 제어하게 합니다. 이는 코드를 더 선형적이고 쉽게 읽을 수 있게 만드는 반면, JavaScript 제너레이터 및 프로미스에 대한 깊은 이해가 필요합니다.\n\n\n\n# 아직 끝나지 않았어요\n\n![이미지](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_8.png)\n\nExpress.js와 Koa.js를 비교한 결론을 도출해본 결과, Express는 직관적이고 간단한 방법론을 채택했으며, Koa는 JavaScript의 비동기 함수를 활용한 더 간략하고 현대적인 접근 방식을 취했습니다.\n\nMiddleware를 최적화하는 것은 Node.js 애플리케이션 전반의 성능을 향상시키는 일부분에 불과하다는 것을 명심해주세요. 저의 이전 글인 \"이벤트 루프를 통해 Node.js의 성능 향상하기: 사례 연구를 통해 더 나은 성능\"에서 Node가 이벤트 루프를 어떻게 활용해 효율적으로 작업을 처리하는지 심층적으로 살펴볼 수 있습니다. 이를 통해 성능 최적화에 대한 깊은 이해를 얻을 수 있습니다.\n\n\n\n반면에, 애플리케이션의 구조와 효율성을 더욱 향상시키기 위해 이벤트 주도 아키텍처를 채택하는 것을 고려해보세요. 또 다른 기사인 \"Node.js 및 TypeScript를 사용한 이벤트 주도형 REST API 만들기: 실용적인 접근\"에서는 Node와 TypeScript를 활용하여 강력하고 효율적인 REST API를 구축하는 방법을 안내하고 있습니다. 여기서는 간단한 이벤트 주도 접근 방식에 중점을 두며 독자를 안내합니다.\n\n즐거운 코딩하시고, 앞으로의 기사에서 더 많은 통찰과 실용적인 접근법을 공유하기를 기대하고 있습니다!\n\n# 레고처럼 재사용 가능한 컴포넌트로 구성 가능한 앱을 구축하자\n\n![이미지](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_9.png)\n\n\n\nBit는 본질적으로 조립 가능한 소프트웨어를 개발하기 위한 오픈 소스 도구 모음입니다.\n\nBit를 사용하면 현대적인 웹 애플리케이션, UI 컴포넌트, 백엔드 서비스 또는 CLI 스크립트와 같은 어떤 소프트웨어 요소든 독립적이고 재사용 가능하며 조립 가능한 소프트웨어 단위로 개발할 수 있습니다. 어플리케이션 간에 어떤 컴포넌트라도 공유하여 협업을 더 쉽게 하고 더 빠르게 빌드할 수 있습니다.\n\n조립 가능한 소프트웨어를 함께 만드는 100,000명 이상의 개발자 중 하나가 되어보세요.\n\n다음 자습서로 시작해보세요:\n\n\n\n# → 마이크로 프론트엔드: 비디오 // 안내\n\n# → 코드 공유: 비디오 // 안내\n\n# → 현대화: 비디오 // 안내\n\n# → 모노 레포: 비디오 // 안내\n\n\n\n# → 마이크로서비스: 비디오 // 가이드\n\n# → 디자인 시스템: 비디오 // 가이드\n\n# 추천 문서:","ogImage":{"url":"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png","tag":["Tech"],"readingTime":12},{"title":"Nodejs와 Expressjs","description":"","date":"2024-05-14 15:37","slug":"2024-05-14-NodejsandExpressjs","content":"\n\n지금 이 시점에서 자바스크립트 노드 프레임워크에 대해 초보자인 경우, 이 글은 당신이 노드와 익스프레스가 어떻게 관련되는지 쉽게 이해하는 데 도움이 될 것입니다.\n\nNode.js는 웹 브라우저 외부에서 자바스크립트 코드를 실행할 수 있게 해주는 자바스크립트 런타임 환경입니다. 일반적으로 서버에서 실행됩니다. 그러나 HTTP 요청 및 응답 처리 및 웹 애플리케이션 구축을 위해 Express.js와 같은 프레임워크가 필요합니다.\n\nExpress.js는 Node.js를 위한 웹 애플리케이션 프레임워크로, 웹 애플리케이션 및 API를 구축하는 데 필요한 기능 세트를 제공합니다. Express.js는 HTTP 요청 처리, 라우팅, 미들웨어 통합 등의 프로세스를 단순화하며, Node.js를 사용하여 웹 애플리케이션을 개발하고 배포하기가 더 쉬워집니다.\n\n따라서 브라우저에서 노드.js로 구축된 웹 애플리케이션을 배포하거나 액세스하려면 일반적으로 Express.js를 사용하여 서버 측 로직 및 HTTP 통신을 처리합니다. Express.js를 사용하면 라우트를 생성하고 요청을 처리하며 정적 파일을 제공하고 웹 애플리케이션의 기능을 관리하는 등의 작업이 가능해집니다. 지금 이해됐으면 좋겠네요!\n\n\n\n해피 코딩!","ogImage":{"url":"/assets/img/2024-05-14-NodejsandExpressjs_0.png"},"coverImage":"/assets/img/2024-05-14-NodejsandExpressjs_0.png","tag":["Tech"],"readingTime":1},{"title":"NET Core 6와 React JS를 활용한 제품 관리 애플리케이션 개발하기 CRUD 작업 포함","description":"","date":"2024-05-14 15:36","slug":"2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations","content":"\n\n<img src=\"/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png\" />\n\n# 소개\n\n이 글에서는 .NET Core 6을 사용하여 CRUD 작업을 수행하는 제품 관리 웹 API를 만들고 React JS의 도움으로 다양한 형식을 사용할 것입니다.\n\n# 사전 준비조건\n\n\n\n- Visual Studio 2022\n- VS Code\n- SQL Server\n- .NET Core SDK\n- Node JS\n\n# 제품 관리 응용 프로그램\n\n단계 1\n\n새 제품 관리 .NET Core Web API를 만드세요.\n\n\n\nStep 2\n\n데이터베이스 마이그레이션 및 SQL Server와의 연결에 사용하는 다음 NuGet 패키지를 설치하십시오.\n\n![NuGet Packages](/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_1.png)\n\nStep 3\n\n\n\nentities 폴더 안에 product 클래스를 추가해주세요.\n\n```js\nnamespace ProductManagementAPI.Entities\n{\n    public class Product\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public decimal Price { get; set; }\n    }\n}\n```\n\n4단계\n\ndata 폴더 안에 AppDbContext 클래스를 만들어 SQL Server 연결 및 DB 설정 속성을 추가해주세요.\n\n\n\n```cs\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Data\n{\n    public class AppDbContext : DbContext\n    {\n        public DbSet<Product> Products { get; set; }\n        protected readonly IConfiguration Configuration;\n        public AppDbContext(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n        protected override void OnConfiguring(DbContextOptionsBuilder options)\n        {\n            options.UseSqlServer(Configuration.GetConnectionString(\"DefaultConnection\"));\n            options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);\n        }\n    }\n}\n```\n\nStep 5\n\n리포지토리 폴더 내에 제품 리포지토리를 추가하세요.\n\nIProductRepository\n\n\n\n\n```js\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public interface IProductRepository\n    {\n        void AddProduct(Product product);\n        void DeleteProduct(int id);\n        List<Product> GetAllProducts();\n        Product GetProductById(int id);\n        void UpdateProduct(Product product);\n    }\n}\n```\n\nProductRepository\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public class ProductRepository : IProductRepository\n    {\n        private readonly AppDbContext _context;\n        public ProductRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n        public List<Product> GetAllProducts()\n        {\n            return _context.Products.ToList();\n        }\n        public Product GetProductById(int id)\n        {\n            return _context.Products.FirstOrDefault(p => p.Id == id);\n        }\n        public void AddProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n            _context.Products.Add(product);\n            _context.SaveChanges();\n        }\n        public void UpdateProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n            _context.Entry(product).State = EntityState.Modified;\n            _context.SaveChanges();\n        }\n        public void DeleteProduct(int id)\n        {\n            var product = _context.Products.Find(id);\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n            _context.Products.Remove(product);\n            _context.SaveChanges();\n        }\n    }\n}\n```\n\n단계 6\n\n\n\n\n위 코드를 사용하여 다양한 작업을 수행하는 새 제품 컨트롤러를 만들었습니다. 이제 이를 호출하면 우리의 프런트엔드 애플리케이션을 통해 다양한 작업을 수행할 수 있습니다.\n\n```js\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing ProductManagementAPI.Entities;\nusing ProductManagementAPI.Repositories;\n\nnamespace ProductManagementAPI.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductRepository _productRepository;\n        public ProductController(IProductRepository productRepository)\n        {\n            _productRepository = productRepository;\n        }\n        [HttpGet]\n        public IActionResult GetAllProducts()\n        {\n            var products = _productRepository.GetAllProducts();\n            return Ok(products);\n        }\n        [HttpGet(\"{id}\")]\n        public IActionResult GetProductById(int id)\n        {\n            var product = _productRepository.GetProductById(id);\n            if (product == null)\n            {\n                return NotFound();\n            }\n            return Ok(product);\n        }\n        [HttpPost]\n        public IActionResult AddProduct([FromBody] Product product)\n        {\n            if (product == null)\n            {\n                return BadRequest();\n            }\n            _productRepository.AddProduct(product);\n            return CreatedAtAction(nameof(GetProductById), new { id = product.Id }, product);\n        }\n        [HttpPut(\"{id}\")]\n        public IActionResult UpdateProduct(int id, [FromBody] Product product)\n        {\n            if (product == null || id != product.Id)\n            {\n                return BadRequest();\n            }\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n            _productRepository.UpdateProduct(product);\n            return NoContent();\n        }\n        [HttpDelete(\"{id}\")]\n        public IActionResult DeleteProduct(int id)\n        {\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n            _productRepository.DeleteProduct(id);\n            return NoContent();\n        }\n    }\n}\n```\n\n7단계\n\n앱 설정 파일을 열어 데이터베이스 연결 문자열을 추가하세요.```\n\n\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"ConnectionStrings\": {\n    \"DefaultConnection\": \"Data Source=DESKTOP-8RL8JOG;Initial Catalog=ReactNetCoreCrudDb;User Id=sa;Password=database@1;\"\n  }\n}\n```\n\n**단계 8**\n\n서비스 컨테이너 내에서 서비스를 등록하고 미들웨어를 구성하세요.\n\n```csharp\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Repositories;\n\nvar builder = WebApplication.CreateBuilder(args);\n// 컨테이너에 서비스 추가\nbuilder.Services.AddScoped<IProductRepository, ProductRepository>();\nbuilder.Services.AddDbContext<AppDbContext>();\nbuilder.Services.AddCors(options => {\n    options.AddPolicy(\"CORSPolicy\", builder => builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());\n});\n\nbuilder.Services.AddControllers();\n// Swagger/OpenAPI 구성에 대해 더 자세히 알아보려면 https://aka.ms/aspnetcore/swashbuckle을 참조하세요\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\nvar app = builder.Build();\n// HTTP 요청 파이프라인 구성\napp.UseCors(\"CORSPolicy\");\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n\n\n9단계\n\n아래 엔터티 프레임워크 데이터베이스 마이그레이션 명령을 실행하여 데이터베이스와 테이블을 생성합니다.\n\n```js\nadd-migration \"v1\"\nupdate-database\n```\n\n10단계\n\n\n\n마지막으로, 애플리케이션을 실행하고 Swagger UI를 사용하여 다양한 API 엔드포인트를 실행하세요.\n\n![Swagger UI](/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_2.png)\n\nReact JS를 사용하여 클라이언트 애플리케이션을 생성하고 위의 API 엔드포인트를 이용해보세요.\n\n1단계\n\n\n\n다음 명령어를 사용하여 새 React JS 애플리케이션을 만들어 보세요:\n\nnpx create-react-app react-netcore-crud-app\n\n단계 2\n\n프로젝트 디렉토리로 이동하세요.\n\n\n\ncd react-netcore-crud-app\n\n**단계 3**\n\n백엔드 API를 소비하고 호출하기 위해 Axios를 설치하고 디자인을 위해 bootstrap을 설치하세요.\n\nnpm install axios\n\n\n\nnpm install bootstrap\n\n단계 4\n\n다음 컴포넌트 및 서비스를 추가하세요:\n\n제품 목록 컴포넌트.\n\n\n\n```js\n// src/components/ProductList/ProductList.js\nimport React, { useState, useEffect } from 'react';\nimport ProductListItem from './ProductListItem';\nimport productService from '../../services/productService';\n\nconst ProductList = () => {\n    const [products, setProducts] = useState([]);\n    useEffect(() => {\n        fetchProducts();\n    }, []);\n    const fetchProducts = async () => {\n        try {\n            const productsData = await productService.getAllProducts();\n            setProducts(productsData);\n        } catch (error) {\n            console.error('제품을 불러오는 중 오류가 발생했습니다:', error);\n        }\n    };\n    const handleDelete = async (id) => {\n        try {\n            await productService.deleteProduct(id);\n            fetchProducts(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 삭제 중 오류가 발생했습니다:', error);\n        }\n    };\n    const handleEdit = () => {\n        fetchProducts(); // 편집 후 제품 목록 새로고침\n    };\n    return (\n        <div className=\"container\">\n            <h2 className=\"my-4\">제품 목록</h2>\n            <ul className=\"list-group\">\n                {products.map(product => (\n                    <ProductListItem key={product.id} product={product} onDelete={() => handleDelete(product.id)} onEdit={handleEdit} />\n                ))}\n            </ul>\n        </div>\n    );\n};\nexport default ProductList;\n```\n\n제품 목록 항목 컴포넌트.\n\n```js\n// src/components/ProductList/ProductListItem.js\nimport React, { useState } from 'react';\nimport productService from '../../services/productService';\n\nconst ProductListItem = ({ product, onDelete, onEdit }) => {\n    const [isEditing, setIsEditing] = useState(false);\n    const [editedName, setEditedName] = useState(product.name);\n    const [editedPrice, setEditedPrice] = useState(product.price);\n    const handleEdit = async () => {\n        setIsEditing(true);\n    };\n    const handleSave = async () => {\n        const editedProduct = { ...product, name: editedName, price: parseFloat(editedPrice) };\n        try {\n            await productService.updateProduct(product.id, editedProduct);\n            setIsEditing(false);\n            onEdit(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 업데이트 중 오류가 발생했습니다:', error);\n        }\n    };\n    const handleCancel = () => {\n        setIsEditing(false);\n        // 수정된 값 초기화\n        setEditedName(product.name);\n        setEditedPrice(product.price);\n    };\n    return (\n        <li className=\"list-group-item\">\n            {isEditing ? (\n                <div className=\"row\">\n                    <div className=\"col\">\n                        <input type=\"text\" className=\"form-control\" value={editedName} onChange={e => setEditedName(e.target.value)} required />\n                    </div>\n                    <div className=\"col\">\n                        <input type=\"number\" className=\"form-control\" value={editedPrice} onChange={e => setEditedPrice(e.target.value)} required />\n                    </div>\n                    <div className=\"col-auto\">\n                        <button className=\"btn btn-success me-2\" onClick={handleSave}>저장</button>\n                        <button className=\"btn btn-secondary\" onClick={handleCancel}>취소</button>\n                    </div>\n                </div>\n            ) : (\n                <div className=\"d-flex justify-content-between align-items-center\">\n                    <span>{product.name} - ${product.price}</span>\n                    <div>\n                        <button className=\"btn btn-danger me-2\" onClick={onDelete}>삭제</button>\n                        <button className=\"btn btn-primary\" onClick={handleEdit}>편집</button>\n                    </div>\n                </div>\n            )}\n        </li>\n    );\n};\nexport default ProductListItem;\n```\n\n제품 서비스.\n\n\n\n\n```js\n// src/services/productService.js\nimport axios from 'axios';\n\nconst baseURL = 'https://localhost:7202/api/Product';\nconst productService = {\n    getAllProducts: async () => {\n        const response = await axios.get(baseURL);\n        return response.data;\n    },\n    addProduct: async (product) => {\n        const response = await axios.post(baseURL, product);\n        return response.data;\n    },\n    deleteProduct: async (id) => {\n        const response = await axios.delete(`${baseURL}/${id}`);\n        return response.data;\n    },\n    updateProduct: async (id, product) => {\n        const response = await axios.put(`${baseURL}/${id}`, product);\n        return response.data;\n    }\n};\nexport default productService;\n```\n\nApp component.\n\n```js\n// src/App.js\nimport React, { useState } from 'react';\nimport ProductList from './components/ProductList/ProductList';\nimport ProductForm from './components/ProductForm/ProductForm';\n\nfunction App() {\n    const [refresh, setRefresh] = useState(false);\n    const handleProductAdded = () => {\n        setRefresh(!refresh); // 상태를 토글하여 다시 렌더링을 트리거합니다.\n    };\n    return (\n        <div>\n            <ProductList key={refresh} />\n            <ProductForm onProductAdded={handleProductAdded} />\n        </div>\n    );\n}\nexport default App;\n```\n\n5단계\n\n\n\n\n다음 명령을 사용하여 응용 프로그램을 실행하고 동일한을 사용하여 다양한 CRUD 작업을 수행하십시오.\n\n![image](/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_3.png)\n\n# GitHub\n\nhttps://github.com/Jaydeep-007/React_NETCore_CRUD\n\n\n\n# 결론\n\n이 기사에서는 .NET Core 및 SQL Server를 사용하여 제품 관리 백엔드 응용 프로그램을 만들었고 CRUD 작업을 수행하는 데 필요한 다양한 API 엔드포인트를 만들었습니다. 나중에 React JS를 사용하여 프론트엔드 응용 프로그램을 만들었고 Axios의 도움을 받아 백엔드 응용 프로그램을 동일한 내에서 사용했습니다.","ogImage":{"url":"/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png"},"coverImage":"/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png","tag":["Tech"],"readingTime":14}],"page":"47","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}