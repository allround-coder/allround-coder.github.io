{"pageProps":{"posts":[{"title":"누군가가 저에게 자가학습 프로그래머들이 부족한 점을 물어봤어요","description":"","date":"2024-05-14 13:11","slug":"2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack","content":"\n\n## 프로그래밍 의견\n\n![이미지](/assets/img/2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack_0.png)\n\n이 경우 서두르지 말 것이 좋습니다. 또한, 자습 중이라면 형식적인 교육을 받은 사람들의 가정에 대해서 당신 스스로 발목을 잡는 것입니다.\n\n저는 자습으로 배웠고, 거의 모든 사람들이 나보다 더 좋은 기술을 가지고 있다는 생각이 들지 않았습니다.\n\n\n\n두 명의 프로그래머 사이의 차이는 대학에서 공부했느냐 자기 학습을 했느냐와 같은 문제들보다는 그가 무엇을 배우기 위해 동기부여 받았는지, 무엇을 배웠는지, 실제로 얼마나 배웠는지, 그리고 어느 정도의 재능을 가지고 있는지가 훨씬 중요합니다.\n\n나는 IT 분야에서 학위를 받은 많은 사람들이 나 같이 많은 해가 지난 후 고등학교를 졸업한 이후 프로그래머로서의 자리를 잘 표현하지 못하는 것을 많이 보았습니다. 그리고 예, 자가 학습형 개발자로서 어떤 사람을 나눌 필요가 있다는 가정을 보면 좀 짜증나기도 합니다. \n\n나는 이런 이유 중 하나로 이 주제에 대해 이야기하고 싶었습니다. 자가 학습형 개발자가 교육을 받은 개발자만큼 좋은 프로그래머가 되기 위해 할 일은 무엇인지 물어봤던 적이 있었거든요. 음, 아주 많은 경우 그는 아무 것도 해야 할 필요가 없을 수도 있습니다. 그리고 뭔가를 해야 한다면, 그것은 자가 학습을 했기 때문이 아니라 특정한 단점 때문에이므로 그런 질문에 대한 일반적인 답은 없습니다.\n\n특히 정식 교육을 받은 사람들도 동일하거나 다른 단점을 가질 수 있습니다. 그렇습니다, 컴퓨터 공학 분야의 범위를 재검토하는 것이 좋을 수도 있습니다. 예를 들어, Warsaw 대학에서 제공하는 매우 포괄적인 자료는 자가 학습을 하는 학생들에게도 유용할 수 있습니다. 당신이 만나지 못한 학습에서 다루는 주제가 있는지 알아보는 것이 가치가 있습니다.\n\n\n\n자학하는 사람들도 많아서 그룹으로 다루는 것은 매우 불합리합니다. 제가 프로그래밍을 시작한 지 15년이 넘었습니다. 많은 사람들이 몇 달의 과정을 수료한 후에는 가장 재능 있는 사람이 아니면 작업 준비가 되기 힘듭니다. 동기부여도 서로 다릅니다.\n\n가치 있는 직원이 되고 싶다면 학생 자료를 검토하는 것보다 첫 직장을 얻고 무엇을 할 수 없는지 확인하는 것이 훨씬 더 유용할 것입니다. 배워야 할 것이 너무 많아서 아무 대학의 선택을 당연시하고 최고로 여기는 것은 적절하지 않습니다. 그러나 만족을 위해 학습하고 즐거움을 얻는다면, 놓친 것에 대해 궁금해해야 합니다.\n\n그에 반해, 대학 프로그램의 불합리성을 고려할 때, 이론적으로 프로그래머로 취업하거나 다른 직책에서 일을 시작하고 대학 대신 전문 분야에서 5년의 경험을 쌓을 수 있는 사람이 전반적으로 시장에서 훨씬 더 나은 역량을 갖게 될 것입니다. \n\n하지만 저의 경우처럼 이 경로나 저 경로를 따르는 것보다 그냥 자신이 좋아하는 일을 하는 것이 최선이라고 생각합니다. 자신만의 밀폐된 대학 환경을 갖고 있지만 종종 시장의 현실과 부합하지 않거나 아예 맞지 않고 객관적인 허튼 소리를 가르치는 사람들이 유용하다고 여기는 것에 집중하지 마세요. 하지만 대기업의 동적인 매니저들이 우리에게 기대하는 능력만 습득하지 말아야 합니다. 그렇게 하면 정말 지루할 것입니다.\n\n\n\n프로그래밍을 정말 좋아한다면 많은 것을 알고 많은 돈을 벌게 될 거예요. 누군가가 당신을 자학한 사람으로 레이블 붙이려고 해도, 댓글을 심지어 할 수 없으며, 단지 그에게 얼마나 많이 벌고 싶은지 말하고 그에게 결정하도록 하세요.\n\n제 인생에서 면접을 봤었고, 세 가지 종류의 기술 질문을 받은 적이 있어요:\n\n1. 이력서에 포함했던 주제에 관한 질문 – 아마도 저에게는 너무나 단순한 질문일 겁니다.\n2. 내가 관심 있는 주제에 관한 질문 – 잘 모르겠다고 해도, 항상 \"논리적으로 기반을 둔\" 정답을 추측하려 노력했어요.\n3. 누군가가 만들어낸 미친 질문 – 결코 사용되지 않는 것에 관한 질문이었고, 기적적으로 필요하다면 구글에서 확인됐어요.\n\n그리고 누군가가 위대한 기술을 갖고 있음에도 불구하고 인정받지 못할까봐 두렵다면, 앉아서 자신의 모든 역량을 나타내는 좋은 프로젝트를 작성해보는 걸 추천해요. 언어 사용 능력, 소프트웨어 엔지니어링 이해, 노출하고 싶은 관련 주제에 대한 지식, 즉 컴퓨터 아키텍처, 시스템, 네트워크, 그래픽 따위에 대한 지식 등을 보여주는 것이 중요합니다.\n\n\n\n하지만 프로그래밍을 배우는 사람이 프로젝트를 작성하는 것은 보편적인 일이라고 생각합니다. 저는 15년 전에 시작했지만 특별한 것을 보여줄 것이 없다고 생각해요. 그러나 제 경력이 막히고 해결해야 할 문제가 생긴다면, 5년 동안 공부하는 대신 3개월 만에 그런 일을 처리할 것 같아요.\n\n대학을 졸업한 사람들 중에서는 어떤 면에서는 제가 능가하지만, 제가 그들보다 나은 점도 있을 거예요. 하지만 제 학업을 완료한 사람들보다 제가 뛰어나다고 생각하는 사람이 더 많아요. 그러니 모든 사람이 자신이 원하는 방식으로 배우도록 하고, 그들의 실력을 직접 평가하도록 하죠.\n\n누군가에게 학업을 완료하라고 권유한 적이 없으니, 누군가는 나에게 그들을 향해 자신을 깎아내리라고 말하지 말아주세요. 왜냐하면 그 이유를 보지 못하기 때문이에요.\n\n# Stackademic 🎓\n\n\n\n고맙습니다. 끝까지 읽어주셔서!\n\n- 작가를 클로밍하고 팔로우해주시면 감사하겠습니다! 👏\n- 다음을 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해주세요: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인해주세요.","ogImage":{"url":"/assets/img/2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack_0.png"},"coverImage":"/assets/img/2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack_0.png","tag":["Tech"],"readingTime":3},{"title":"JavaScript에서 Promise의 사용법과 이유","description":"","date":"2024-05-14 13:05","slug":"2024-05-14-TheHowandWhyofPromisesinJavaScript","content":"\n\n![Promises](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_0.png)\n\n프로미스는 자바스크립트의 덤블도르라고 생각됩니다. JS에서 비동기적인 모든 것은 이 마법사에 의존합니다. 프로미스를 연구하는 두 종류의 사람이 있습니다. 첫째는 \"오케이, Resolve와 Reject를 매개변수로 받는 함수를 전달하여 프로미스 생성자에 전달하고 비동기 작업을 수행하면 끝이야. 응, 쉬워서 쉽네\" 하고 하는 사람들이고, 둘째는 프로미스의 작동에 관한 복잡한 질문이나 까다로운 질문을 생각해내는 사람들입니다. 이 영문은 정확히 그에 관한 것입니다. 프로미스 \"Under the Hood\".\n\n# 이 영문에서 다룰 내용은 다음과 같습니다:\n\n- 기본 프로미스 생성부터 시작하기.\n- 여러 프로미스를 연결하는 방법 (프로미스 체이닝).\n- .then()과 .catch()에서 반환하는 이유 (및 반환할 수 있는 모든 것).\n- then()/catch()/finally() 내부의 핸들러 메소드의 부재.\n- 동일한 프로미스 객체에 여러 핸들러 연결.\n- .then()의 동기적 성격과 핸들러 메소드의 비동기적 성격.\n- 처리되지 않은 프로미스의 [[Promise]] 슬롯의 연결.\n- .then()으로 isRejected() 핸들러 vs. .catch()으로 isRejected() 핸들러.\n- 몇 가지 tricky 코드 스니펫의 출력 예측.\n- 프로미스 작동 방식을 이해하기 위해 커스텀 프로미스 생성하기.\n\n\n\n노트-: 먼저 약속의 A-Z 작동 방식을 이해하는 데 도움이 되도록 익명 및 화살표 함수를 사용하지 않겠습니다. 그러나 이해도가 높아지면 코드에 이들을 도입할 것입니다.\n\n## 자바스크립트에서 Promise는 무엇인가요?\n\n![Promise](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_1.png)\n\n이걸 꺾어 말해야해서 죄송하지만, Promise들은 덤블도어가 아니에요. 그냥 Promise 클래스의 객체일 뿐이죠. Promise들은 일련의 콜백 함수에 엮이는 거죠. MDN에서 이를 다음과 같이 정의했습니다:\n\n\n\n조금 덜 무서운 비유적인 얘기로 말하자면, 엄마가 냄비에 우유를 담아 끓이기 위해 가스레인지에 놓고 급히 다른 일을 처리해야 할 때, 우유를 지켜보라고 너에게 부탁할 것이고 너는 필요한 양의 끓는 정도에 도달하면 버너를 끄거나 너무 끓어 넘치면 쏟아진 우유를 닦아내야 할 거야.\n\n이 비유에서 당신의 엄마는 JS 해석기인데, 이 해석기는 단일 스레드이며 동기화 방식이니 main 쓰레드가 블록되지 않도록 (비동기 작업은 실행에 시간이 걸릴 수 있으므로, JS 해석기의 유일한 쓰레드인 main 쓰레드는 그 작업에 의해 블록됩니다.) 대기 중인 작업들을 계속 실행해야 합니다. 우유 끓이기는 비동기 작업을 나타냅니다. 버너를 끄는 것은 비동기 작업의 성공적인 완료시 수행해야 할 동작을 나타내며, 쏟아진 우유를 닦아내는 것은 비동기 작업 실행 중에 실패를 만났을 때 수행해야 할 동작을 나타냅니다. 그리고 마지막으로 당신은 Promise 객체입니다.\n\n# 섹션 1: 기본 Promises\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_2.png)\n\n\n\n비유는 여기까지입니다. 자 이제 상황을 Promises를 사용하여 구현하는 코드를 작성해 보겠습니다-:\n\n```js\nfunction boilMilk(resolve, reject) {\n  let milkBoiled = Math.random();\n  if (milkBoiled >= 0.5) resolve(\"우유가 성공적으로 끓었습니다\");\n  else reject(new Error(\"우유가 너무 끓어 넘쳤습니다\"));\n}\n\nfunction shutBurner(resolveValue) {\n  console.log(`${resolveValue} 그리고 버너가 꺼졌습니다`);\n}\n\nfunction cleanSpilledMilk(rejectValue) {\n  console.log(`${rejectValue} 따라서 넘친 우유를 청소합니다`);\n}\n\nfunction isResolved(resolveValue) {\n  return shutBurner(resolveValue);\n}\n\nfunction isRejected(rejectValue) {\n  return cleanSpilledMilk(rejectValue);\n}\n\nconst motherPromise = new Promise(boilMilk);\n\nmotherPromise\n  .then(isResolved)\n  .catch(isRejected);\n```\n\n쉽죠? 그렇지 않다면 코드를 부분별로 살펴보세요:\n\n- `new Promise(……)`는 Promise 클래스의 생성자 호출로 Promise 객체를 반환합니다. Promise 객체는 다음과 같습니다:\n\n\n\n\n![Promise States](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_3.png)\n\n여기서 [[PromiseState]]는 Promise 객체의 상태를 나타냅니다. Promise는 다음 중 하나의 상태를 가질 수 있습니다:\n\na. pending-: Promise 객체가 생성될 때의 초기 상태입니다. Promise 객체의 해결 또는 거부에 의해 변경될 것을 기다리고 있습니다.\n\nb. fulfilled-: Promise가 해결되었음을 나타내는 상태이거나 비동기 작업이 성공했음을 의미합니다.\n\n\n\n\nc. rejected-: 이것은 Promise의 상태로, Promise가 거부되었거나 비동기 작업이 실패했다는 것을 나타냅니다.\n\n[[PromiseResult]]은 비동기 작업에 의해 반환된 실제 데이터, 메시지 또는 오류가 저장된 위치입니다.\n\n2. 약속 생성자(boilMilk())에 전달된 함수는 Executor 함수로 알려져 있습니다. Executor 함수는 즉시 호출되는 콜백 함수로, 수행할 비동기 작업을 나타냅니다.\n\n3. resolve()와 reject()는 약속 클래스의 도우미 함수로, 약속 객체의 상태를 대기 중인 상태에서 이행된 상태로 변이시키거나 반대로 거부된 상태로 변이하는 책임이 있습니다.\n\n\n\n노트: Executor 함수의 인수로 흔히 볼 수 있는 resolve와 reject는 단순히 변수이기 때문에 아래 예시처럼 다른 이름을 지을 수 있습니다. 이들은 내부적으로 Promise 생성자에 의해 전달된 resolve()와 reject() 함수를 저장하는 데 사용됩니다. 섹션 10에서 사용자 정의 Promise를 만들 때 이를 실제로 보게 될 것입니다.\n\n```js\nfunction boilMilk(resolveMethod, rejectMethod) {\n  let milkBoiled = Math.random();\n  if (milkBoiled >= 0.5)    \n    resolveMethod(\"우유가 성공적으로 끓었습니다\");\n  else \n    rejectMethod(new Error(\"우유가 과도하게 끓어 넘쳤습니다\"));\n}\n\nconst motherPromise = new Promise(boilMilk);\n```\n\n4. \"약속이 처리되었다\"라고 말할 때, 이는 Promise가 최종 상태(이행되었거나 거부된 상태)에 도달했다는 것을 의미합니다. 처리된 Promise는 비동기 작업을 완료하고 결과가 결정된 Promise입니다.\n\n5. .then(), .catch() 및 .finally()는 Promise 클래스에 정의된 함수들입니다. 이러한 메서드를 사용하면 Promise에 \"핸들러\"를 연결하고 Promise가 성공 또는 실패할 때 무엇을 해야 하는지 지정할 수 있습니다. 이러한 메서드는 JS 해석기에 의해 \"동기적으로\" 호출됩니다. 각각의 메서드는 반환될 때 \"보류 중\" 상태인 새로운 Promise를 반환하며, 현재 Promise의 상태에 관계없이 해당됩니다. 이러한 메서드 각각은 Handler 메서드(우리의 경우 isResolved() 및 isRejected())라고 불리는 콜백 함수를 허용합니다. 반환된 Promise의 최종 상태는 이러한 핸들러에 달려 있습니다. 위 세 가지 메서드의 구문은 다음과 같습니다:\n\n\n\na. then(onFulfillment, onRejected) -: 여기서 onRejected 핸들러는 선택 사항입니다.\n\nb. catch(onRejected) -: 위 체인에서 거부된 프로미스를 잡습니다.\n\nc. finally(onFinally) -: 현재 프로미스의 상태에 관계없이 항상 실행됩니다. 주로 프로미스가 해결된 후 처리하거나 정리하는 데 사용됩니다.\n\n6. onFulfillment(), onRejection() 및 onFinally()은 .then(), .catch() 및 .finally() 메서드에 전달되는 핸들러입니다. 현재 프로미스가 해결되면 onFulfillment() 핸들러가 \"비동기적으로\" 호출되고, 현재 프로미스가 거부되면 onRejection() 핸들러가 \"비동기적으로\" 호출되며, onFinally() 핸들러는 프로미스의 상태에 관계없이 항상 실행됩니다. 이러한 핸들러는 데이터, 오류 또는 새로운 프로미스를 반환할 수 있으며, 이를 .then() 및 .catch()로 계속 연결할 수 있습니다. 첫 번째 경우 .then()은 해당 데이터로 해결된 프로미스를 반환하고, 두 번째 경우 .then() 또는 .catch()는 오류가 포함된 거부된 프로미스를 반환합니다.\n\n\n\n만약 위의 이야기가 어려운 것 같다면, 실제로 무슨 일이 일어나는지 더 잘 이해하기 위해 우리 코드의 제어 흐름을 살펴보겠습니다:\n\n단계 1: JS Interpreter의 실행 단계에서, 먼저 새 Promise 인스턴스가 생성됩니다 (이 때 Promise의 상태는 \"대기 중\"입니다) 그리고 Executor 함수(boilMilk())가 Promise 생성자에 의해 즉시 호출됩니다.\n\n단계 2: Executor 함수는 무작위로 생성된 값에 따라 즉시 resolve() 또는 reject() 함수를 호출하며, 메시지나 에러와 함께 해당 함수를 호출합니다. resolve()/reject() 함수는 Promise 객체의 상태([[PromiseState]])를 변경하고 [[PromiseResult]]에 메시지나 에러를 할당합니다.\n\n참고: Promise 객체의 상태 변경은 resolve() 또는 reject()가 일정 지연 후에 호출될 때(비동기 실행을 모방하기 위해) 다음과 같이 확인할 수 있습니다:\n\n\n\n```js\nfunction boilMilk(resolve, reject) {\n  setTimeout(() => {\n    let milkBoiled = Math.random();\n    if (milkBoiled >= 0.5)\n        resolve(\"우유 끓였어요\");\n    else\n        reject(new Error(\"우유가 넘쳐서 쏟았어요\"));\n  }, 2000);\n}\n\nfunction shutBurner(resolveValue) {\n  console.log(`${resolveValue} 후에 버너를 끕니다`);\n}\n\nfunction cleanSpilledMilk(rejectValue) {\n  console.log(`${rejectValue} 이라서 쏟아진 우유를 청소합니다`);\n}\n\nfunction isResolved(resolveValue) {\n  return shutBurner(resolveValue);\n}\n\nfunction isRejected(rejectValue) {\n  return cleanSpilledMilk(rejectValue);\n}\n\nvar motherPromise = new Promise(boilMilk);\nconsole.log(motherPromise);\n\nmotherPromise\n  .then(isResolved)\n  .catch(isRejected);\n\nsetTimeout(() => console.log(motherPromise), 3000);\n```\n\nboilMilk() 함수는 이제 setTimeout()을 사용하여 2초 후에 resolve() 또는 reject()를 호출하며, 첫 번째 console.log 문이 실행될 때 promise 객체의 상태가 \"대기 중\"이 됩니다. 이후 \"이행됨\"으로 변경됩니다:\n\n<img src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_4.png\" />\n\n단계 3: 이제 .then() 도우미 메서드가 \"동기적으로\" 호출되며, 여기서 핸들러 콜백은 \"비동기적으로\" 호출됩니다. 이는 \"대기 중\" promise를 반환합니다.```\n\n\n\n### 단계 4: 현재 Promise 객체의 상태가 \"이행(fulfilled)\" 상태가 된 것을 고려하면 isResolved() 핸들러가 호출됩니다. 이때 현재 Promise 객체의 [[PromiseResult]]를 인수로 전달받습니다.\n\n### 단계 5: isResolved() 핸들러는 .then()으로 반환된 Promise의 상태를 \"이행(fulfilled)\"으로 변경합니다. 그리고 shutBurner() 메소드가 아무 것도 반환하지 않기 때문에 새로 반환된 Promise의 [[PromiseResult]]에는 undefined가 들어갑니다. 아래에서 이를 설명했습니다:\n\n```js\nfunction boilMilk(resolve, reject) {\n  setTimeout(() => {\n    let milkBoiled = Math.random();\n    if (milkBoiled >= 0.5) \n        resolve(\"우유가 성공적으로 끓었습니다\");\n    else \n        reject(new Error(\"우유가 너무 끓어 넘쳐버림\"));\n  },5000);\n}\n\nfunction shutBurner(resolveValue) {\n  console.log(`${resolveValue} 그리고 버너를 끕니다`);\n}\n\nfunction cleanSpilledMilk(rejectValue) {\n  console.log(`${rejectValue} 그래서 넘쳐난 우유를 청소합니다`);\n}\n\nfunction isResolved(resolveValue) {\n  return shutBurner(resolveValue);\n}\n\nfunction isRejected(rejectValue) {\n  return cleanSpilledMilk(rejectValue);\n}\n\nconst motherPromise = new Promise(boilMilk);\n\nconst thenPromise = motherPromise.then(isResolved).catch(()=>{});\nconsole.log(thenPromise);\nsetTimeout(()=>console.log(thenPromise),6000);\n\nconst catchPromise = motherPromise.catch(isRejected);\n```\n\n\n\n<img src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_5.png\" />\n\n참고: .then() 메소드에 .catch()를 첨부하는 이유는 나중에 섹션 7에서 설명될 예정입니다.\n\n단계 6: 해결된 프로미스는 .catch() 메소드가 첨부된 체인으로 전달됩니다. 그러나 isRejected() 핸들러는 호출되지 않으며, 마지막으로 .catch()는 \"보류 중\"인 프로미스를 반환하며, 이는 우리 코드에서 나중에 사용되지 않기 때문에 가비지 컬렉션됩니다.\n\n# 섹션 2: 프로미스 체이닝\n\n\n\n<img src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_6.png\" />\n\n이 섹션에 도달하여 축하합니다. 이제 \"기본 프로미스가 작동하는 방법\"에 대한 이해가 있습니다. 더 나아가서 여러 프로미스가 연속적으로 실행되거나 1개의 프로미스의 완료 또는 거부가 다른 프로미스를 처리하는 상황을 살펴봅시다.\n\n문제 설명:\n\n엄마로부터 (우유 끓이기)라는 작업을 할당 받은 후에, 작업을 성공적으로 수행하면 엄마가 오늘 저녁을 만들어야 하고 당신은 다른 작업을 수행할 수 있어야 한다고 말합니다. 그리고 저녁으로 페스토 스파게티를 먹기를 희망하고 있습니다. 보관함을 검사하고 파스타가 충분히 있다는 것을 발견하면, 파스타 요리는 성공적이지만, 1인분조차 충분하지 않는다면 실패합니다.\n\n\n\n위의 코드는 두 개의 Promise 기능을 사용하여 우유 끓이기와 스파게티 요리하기를 나타냅니다. 우유를 끓일 때는 `boilMilk` 함수를 사용하고, 스파게티를 요리할 때는 `cookSpaghetti` 함수를 사용합니다. 그리고 제대로 끓였을 때와 재료가 부족했을 때에 따라 다른 결과를 반환합니다. 코드를 실행하면서 발생하는 결과는 아래 이미지와 같습니다:\n\n![Possible outcomes](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_7.png)\n\n\n\n![표 이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_8.png)\n\n![표 이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_9.png)\n\n이렇게 간단했어요. 하나의 promise가 또 다른 promise로 이어지고, 두 promise 모두 작동 방식은 같아요.\n\n이제 Promise를 구현하는 방법을 알았으니, 위 코드에서 모든 함수 정의를 익명 함수와 화살표 함수로 바꾼 것을 보셔도 무서워하지 마세요.\n\n\n\n## Section 3: .then() 및 .catch()에서 반환하기\n\n```js\nconst motherPromise = new Promise((resolve, reject) => {\n  let milkBoiled = Math.random();\n  if (milkBoiled >= 0.5) \n    resolve(\"우유가 성공적으로 끓었어요\");\n  else \n    reject(new Error(\"과도한 끓임으로 우유가 흘렀어요\"));\n})\n  .then((resolveValue) => {\n    console.log(`${resolveValue} 그리고 버너가 꺼졌어요`);\n    return new Promise((resolve, reject) => {\n      let spaghettiStock = Math.random();\n      if (spaghettiStock >= 0.5)\n        resolve(\"스파게티가 성공적으로 요리되었어요\");\n      else \n        reject(new Error(\"충분한 파스타가 없어요\"));\n    })\n      .then((resolveValue) => console.log(`${resolveValue} 그리고 접시에 담겼어요`))\n      .catch((rejectValue) => console.log(`${rejectValue} 그래서 지루한 음식이 요리되고 접시에 담겼어요`));\n  })\n  .catch((rejectValue) => {\n    console.log(`${rejectValue} 그래서 흘린 우유를 청소하고`);\n    return \"마지막으로 바닥을 닦았어요\";\n  });\n```\n\n비슷하게, 우유가 흐르게 되었을 때 엄마가 수행해야 할 추가 작업에 대한것을 생각할 수 있고, 쓰레기 처리를 하고 원래 Promise의 catch() 메서드에서 그것을 반환할 수 있어요.\n\n\n\n![image](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_10.png)\n\n3.1. .then() 및 .catch()에서 반환할 수 있는 모든 것은 무엇인가요?\n\n기술적으로 .then() 및 .catch()에서는 어떤 것이든 반환할 수 있습니다. 다만, 연쇄(chain)에서 위에서 전달된 값이 받아들이거나 catch해야 할 것이 있어야 합니다. 그렇지 않으면 Uncaught error 예외가 발생할 수도 있고, 로그에 예상치 못한 출력이 나올 수도 있습니다.\n\n예시 1:\n\n\n\n```js\nconst promise = new Promise((resolve,reject) => {\n    let num = Math.random();\n    setTimeout(num >= 0.5? resolve(\"Promise resolved\") : reject(\"Promise rejected\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(resolveValue);\n})\n.catch(function(rejectValue) {\n    console.log(rejectValue);\n});\n```\n\n위의 코드는 명확하게 \"Promise Resolved\" 또는 \"Promise Rejected\" 둘 중 하나의 결과를 얻을 수 있습니다. 내부적으로 then()은 [[PromiseResult]]가 undefined인 처리된 Promise를 반환합니다. 이는 catch()로 처리할 필요 없이 코드가 종료됩니다. 그렇다면 체인에 다른 then()이 있는 경우 어떻게 될까요? 확인해 봅시다:\n\n예시 2:\n\n```js\nconst promise = new Promise((resolve,reject) => setTimeout(() => resolve(\"Promise resolved\"),2000))\n.then(function (resolveValue) {\n    console.log(resolveValue);\n})\n.then((resolveValue) => {\n    console.log(resolveValue);\n})\n.catch(function(rejectValue) {\n    console.log(rejectValue);\n});\n```\n\n\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_11.png)\n\n여기서 왜 undefined를 얻었을까요? 이건 초기 프로미스가 해결되었을 때 then()의 onFulfillment() 핸들러가 실행됐기 때문입니다. 그리고 핸들러가 아무것도 반환하지 않았기 때문에 then()으로 반환된 프로미스의 [[PromiseResult]]가 undefined로 저장됐다는 것입니다.\n\n이 문제는 원래 프로미스로부터 전달된 해결된 값이 없는 경우 반환문이 없어서 연쇄에서 아래에서 사용할 수 없게 되는 것입니다. 이를 수정해봅시다:\n\n예제 3:\n\n\n\n```js\nconst promise = new Promise((resolve,reject) => {\n    let num = Math.random();\n    setTimeout(() => resolve(\"Promise resolved\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(`First then: ${resolveValue}`);\n    return resolveValue;\n})\n.then((resolveValue) => console.log(`Second then: ${resolveValue}`))\n.catch(function(rejectValue) {\n    console.log(rejectValue);\n});\n```\n\n![Example](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_12.png)\n\n와 그럼, 예시 4:```\n\n\n\n```js\n//Code 1:\nconst promise = new Promise((resolve,reject) => {\n    let num = Math.random();\n    setTimeout(() => resolve(\"약속 지켜짐\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(`첫 번째 then: ${resolveValue}`);\n    throw new Error(\"버려진 오류\");\n})\n.then((resolveValue) => console.log(`두 번째 then: ${resolveValue}`))\n.catch(function(rejectValue) {\n    console.log(`catch 안: ${rejectValue}`);\n});\n/*\n출력:\n첫 번째 then: 약속 지켜짐\ncatch 안: Error: 버려진 오류\n*/\n\n//Code 2:\nconst promise1 = new Promise((resolve,reject) => {\n    let num = Math.random();\n    setTimeout(() => resolve(\"약속 지켜짐\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(`첫 번째 then: ${resolveValue}`);\n    return new Error(\"버려진 오류\");\n})\n.then((resolveValue) => console.log(`두 번째 then: ${resolveValue}`))\n.catch(function(rejectValue) {\n    console.log(`catch 안: ${rejectValue}`);\n});\n/*\n출력:\n첫 번째 then: 약속 지켜짐\n두 번째 then: Error: 버려진 오류\n*/\n```\n\n이건 중요한 사례야. 코드 1에서, then() 내부의 Handler 함수가 오류를 \"throw\" 했어. 이는 핸들러 메서드에서 무언가가 실패했기 때문에 then()에서 반환된 프로미스가 오류로 거부된 것을 의미해. 그러나 코드 2에서는 아무 문제가 없어. 핸들러 메서드에서 새 Error 객체가 반환되었을 뿐이라서 then()에서 반환된 프로미스가 이행되고 이제 그 [[PromiseResult]]에는 Error 객체가 포함돼.\n\n\n\n[마지막] 예시 5:\n\n```js\nvar v;\nconst promise = new Promise((resolve,reject) => {\n    let num = Math.random();\n    setTimeout(() => resolve(\"약속 지켜짐\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(`첫 번째 then: ${resolveValue}`);\n    v = new Promise((resolve, reject) => resolve(\"하위 프로미스 지켜짐\"));\n    return v;\n})\n.catch(function(rejectValue) {\n    console.log(`catch 안: ${rejectValue}`);\n});\nsetTimeout(() => console.log(v), 2000);\n\n/*\n출력:\n첫 번째 then: 약속 지켜짐\nPromise {<fulfilled>: '하위 프로미스 지켜짐'}\n[[Prototype]]: Promise\n[[PromiseState]]: \"fulfilled\"\n[[PromiseResult]]: \"하위 프로미스 지켜짐\"\n*/\n```\n\n\n\n이 경우에는 하위 프로미스가 해결되지만 호출할 핸들러가 없기 때문에 프로그램이 종료됩니다. (좋은 방식이 아닙니다).\n\n# 섹션 4: then()/catch()/finally()에 핸들러 메서드가 없는 경우\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_13.png)\n\n지금까지 우리는 모든 then() 또는 catch()에 핸들러 메서드(onRejection()/onFulfillmemnt())가 인자로 전달된 (보통) 경우를 살펴보았습니다. then() 또는 catch() 내부에 핸들러 메서드를 전달하지 않는다면 어떻게 될까요? 문법 오류가 발생할까요?\n\n\n\n실제로는 아니에요. 이는 약속(Promises)이 내부적으로 구현된 방식으로 잘 처리됩니다. onFulfillment() 핸들러가 then()에 전달되지 않을 경우, 내부적으로 Identity 함수 ( (x) => x )로 대체되어 그냥 완료 값을 체인으로 전달합니다. 마찬가지로, onRejection() 핸들러가 then()에 전달되지 않으면 내부적으로 Thrower 함수 ( (x) => throw x )로 대체되어 받은 거부 값을 throw합니다. 예시 -:\n\n```js\nconst promise = new Promise((resolve, reject) => reject(\"거부됨!\"));\npromise.catch();\n```\n\n그 결과는 다음과 같습니다:\n\n<img src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_14.png\" />\n\n\n\n내부적으로는 다음과 같이 보입니다:\n\n```js\n/*\n  내부적으로는 다음과 같이 대체됩니다:\n\n  promise.catch((reason) => throw reason);\n*/\n\n/*\n  실제 onRejected 함수를 전달하는 경우:\n  \n  promise.catch(reason => console.log(reason));\n*/\n```\n\n로그에서 \"Uncaught Rejected Promise\"가 표시되는 이유는 새로 대체된 핸들러가 \"return\"이 아닌 \"throw\" 키워드를 사용하기 때문입니다.\n\nthen()의 경우:\n\n\n\n```js\nconst promise = new Promise((resolve, reject) => resolve(\"Resolved!\"));\npromise.then();\n\n/*\n  내부적으로 다음과 같이 변경됩니다:\n\n  promise.then((value) => value);\n*/\n```\n\n위의 코드는 로그에 아무 내용도 출력하지 않기 때문에 거기에 무언가를 보고 싶다면 다음과 같이 해야합니다:\n\n```js\nconst promise = new Promise((resolve, reject) => resolve(\"Resolved!\"));\npromise.then()\n  .then((value) => console.log(value)); //logs \"Resolved!\"\n```\n\n# 섹션 5: 동일한 Promise 객체에 여러 핸들러를 첨부하기\n\n\n\nmd\n![](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_15.png)\n\n동일한 Promise 객체에 여러 핸들러를 연결하고 싶은 이유를 묻는다면? 동일한 비동기 작업의 결과에 여러 부분이 의존할 때 이 작업이 수행됩니다.\n\n예를 들어, 우유를 성공적으로 끓일 수 있다면, 불을 끄고 부엌을 닫아야 할 것입니다. 이 경우 코드는 다음과 같이 보일 것입니다-:\n\n```js\nfunction turnOffLights(resolveValue) {\n  console.log(`${resolveValue} 불 끄기`);\n}\n\nfunction closeTheKitchen() {\n  console.log(\"부엌 문 닫기.\");\n}\n\nconst motherPromise = new Promise((resolve, reject) => {\n  let milkBoiled = Math.random();\n  if (milkBoiled >= 0.5)\n    resolve(\"우유가 성공적으로 끓었고 버너가 꺼졌습니다. 이제\");\n  else \n    reject(new Error(\"우유가 너무 끓어서\"));\n});\n\nmotherPromise.then(turnOffLights)\n    .catch(() => {});\nmotherPromise.then(closeTheKitchen)\n    .catch(() => {});\nmotherPromise.catch((resolveValue) =>\n  console.log(`${resolveValue} 따라서 엎어진 우유를 씁니다`)\n);\n\n/*\n가능한 결과 1:\n\n우유가 성공적으로 끓었고 버너가 꺼졌습니다. 이제 불 끄기\n부엌 문 닫기.\n\n가능한 결과 2:\n\nError: 우유가 너무 끓어서 따라서 엎어진 우유를 씁니다\n*/\n```\n\n\n\n\n참고: 각 then() 뒤에 catch()를 붙이는 것은 필수입니다. 그렇지 않으면 Uncaught Rejected Promise 예외가 발생합니다. 이에 대한 이유는 나중에 섹션 7에서 설명하겠습니다.\n\n위 코드의 작동 방식은 해결된 motherPromise가 then()의 모든 onFulfillment() 핸들러를 트리거하는 것입니다. 그리고 모든 핸들러는 정의된 순서대로 실행됩니다.\n\n이 작업은 Promise 체이닝을 사용하여 수행할 수 있다고 말할 수 있지만, 필요한 추가(중첩된) 프로미스를 만들어야 할 필요가 있는지 생각해보겠습니다. 또한, 수행해야 할 후속 작업이 동기적일 수도 있으므로 프로미스가 필요하지 않을 수도 있습니다.\n\n# 섹션 6: .then()의 동기적 성격 및 핸들러 메서드의 비동기적 성격.\n\n\n\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_16.png)\n\nPromises로 시작한 사람들이 가장 헷갈리는 것 중 하나에요. 일반적인 오해는 then()/catch()/finally()이 비동기적으로 실행된다는 것, 즉 프로미스가 해결되거나 거부될 때만 실행된다는 것입니다. 하지만 실제로는 그렇지 않아요. 실제로 이들은 현재 프로미스가 해결되거나 거부될 때까지 기다리지 않고 JS 해석기에 의해 동기적으로 실행됩니다. 그 결과 then()/catch()/finally() 메소드는 \"pending\" 상태의 프로미스를 반환하게 됩니다. 참고: 이 상태는 후속 핸들러 메소드의 반환 값에 따라 나중에 변경될 수 있어요. 실제로는 핸들러 메소드(onFulfillment(), onRejection() 및 onFinally())가 비동기적으로 실행되며, then()/catch()/finally() 메소드에 의해 현재 프로미스 인스턴스의 상태에 따라 실행될 예정입니다. 아래에서 확인할 수 있어요:\n\n```js\nfunction boilMilk(resolve, reject) {\n    setTimeout(() => {\n      let milkBoiled = Math.random();\n      if (milkBoiled >= 0.5) \n          resolve(\"우유가 성공적으로 끓었어요\");\n      else \n          reject(new Error(\"우유가 너무 끓어 넘쳤어요\"));\n    },1000);\n  }\n  \n  function shutBurner(resolveValue) {\n    console.log(`${resolveValue}을(를) 끓인 후 버너를 끄세요`);\n  }\n  \n  function cleanSpilledMilk(rejectValue) {\n    console.log(`${rejectValue} 때문에 넘쳐 흐른 우유를 청소하세요`);\n  }\n  \n  function isResolved(resolveValue) {\n    return shutBurner(resolveValue);\n  }\n  \n  function isRejected(rejectValue) {\n    return cleanSpilledMilk(rejectValue);\n  }\n  \n  const motherPromise = new Promise(boilMilk);\n  \n  const thenPromise = motherPromise.then(isResolved).catch(()=> console.log(\"예외 발생\"));\n  console.log(thenPromise);\n  setTimeout(()=>console.log(thenPromise),2000);\n  \n  const catchPromise = motherPromise.catch(isRejected);\n```\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_17.png)\n\n\n\n\n위 코드에서는 .then()이 동기적으로 실행되었다는 것이 명확합니다 (그래서 로그가 \"보류 중\" Promise를 보여줍니다) 하지만 나중에 onFulfillment() 핸들러가 실행된 후에는 동일한 Promise의 상태가 \"이행\"으로 변경됩니다. 이러한 기능의 이유는 핸들러 간의 경합 상태를 피하기 위해서입니다: .then()이 비동기적이면 (여러 then() 메소드의 경우) 어떤 핸들러가 먼저 예약되는지에 따라 예측할 수없는 결과로 이어질 수 있습니다.\n\n참고: 위 코드에서 .then() 메소드에 .catch()를 첨부하는 이유는 다음 섹션에서 설명될 것입니다.\n\n# 섹션 7: 미처리된 Promise의 [[Promise]] 슬롯의 연결\n\n<img src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_18.png\" />\n\n\n\n지금까지 우리는 부모 프로미스에 직접 .then()과 .catch()이 추가된 시나리오를 보았습니다. 이 경우에는 위에 .then()에 .catch()를 연결해야 했습니다. 그러나 이를 하지 않았을 때 무슨 일이 발생하는지 살펴보지는 않았습니다:\n\n```js\nconst p0 = new Promise((resolve,reject) => {\n    let num = Math.random();\n    setTimeout(()=>reject(\"Promise rejected\"), 5000);\n});\n\nconst p1 = p0.then(function (resolveValue) {\n    console.log(\"Then 핸들러가 실행되었습니다\");\n    console.log(resolveValue);\n})\nconsole.log(\"P1\");\nconsole.log(p1);\n\nconst p2 = p0.catch((rejectValue) => {\n    console.log(\"Catch 핸들러가 실행되었습니다\");\n    console.log(rejectValue);\n})\nconsole.log(\"P2\");\nconsole.log(p2);\nsetTimeout(()=> {\n    console.log(\"P1\");\n    console.log(p1);\n}, 10000);\nsetTimeout(()=> {\n    console.log(\"P2\");\n    console.log(p2);\n}, 15000);\n```\n\n<img src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_19.png\" />\n\n이 일이 왜 발생했을까요? \"거부된\" 프로미스가 이미 catch()의 onRejection() 핸들러에 의해 처리되었다면 콘솔에 추가로 Uncaught Rejected Promise가 나타나는 이유는 무엇일까요? onRejection() 핸들러를 then() 메서드에 전달하지 않았을 때 P1의 상태가 \"보류 중\"에서 \"거부됨\"으로 변경된 이유는 무엇일까요?\n\n\n\n이유를 이야기하자면 정말 간단한 것이 아니며 많은 사람들이 잘 알지 못하는 내용입니다. 이 문제에 대해 알아내기 위해 3~4일 동안 삽질한 기억이 납니다.\n\n여기 그 이유가 있습니다: 각 Promise 객체(예: P1)에는 [[Promise]] 슬롯이 있습니다. 이 슬롯은 P1이 속한 Promise 객체를 가리키거나 발생시킨 부모 Promise 객체를 가리킵니다. 따라서 위 코드에서 P1이 생성될 때 상태가 \"대기 중(pending)\"인 이유는 onFulfillment() 핸들러가 비동기적으로 실행되기 때문입니다. 그리고 나중에 P0가 \"거부(rejected)\"되면 catch()에 예약된 onRejection() 핸들러가 실행되어 메시지를 기록하고 마지막으로 P2가 undefined로 \"이행(fulfilled)\"됩니다. 그러나 만약 코드가 여기서 끝났다면, P1은 영원히 \"대기 중(pending)\" 상태로 남아 있었을 것입니다. 그러나 P1의 [[Promise]] 슬롯이 P0를 가리키므로, P0가 \"거부(rejected)\"된 즉시 P1은 P0의 상태와 결과를 취하게 됩니다. 여기서 주목할 점은 이 현상이 매번 모든 상황에서 발생한다는 점입니다. 우리가 이 현상을 보지 못하는 이유는 그때 then()에 전달된 핸들러 메서드가 실행될 때, then() 메서드에 의해 반환된 Promise의 상태와 결과가 핸들러 메서드의 반환 값의 유형에 따라 결정되기 때문입니다. 따라서, 흐름은 다음과 같습니다:\n\na. P0의 이행/거부\n\nb. P1은 P0의 상태와 결과를 취합니다\n\n\n\nc. P1의 상태와 결과가 다시 변경되었습니다. 이번에는 Handler 메서드의 반환 값 유형에 의해 변경되었습니다.\n\n참고: 이것은 Promise가 영원히 대기 상태에 있을 수 없다는 것을 의미하는 것은 아닙니다. 루트 또는 첫 번째 Promise 인스턴스는 resolve() 또는 reject()가 호출되지 않는 한 \"대기 중\" 상태로 남을 수 있습니다.\n\n# 섹션 8: .then() 대비 .catch()를 사용한 isRejected() 핸들러.\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_20.png)\n\n\n\n지금까지 우리의 코드에서는 then()과 함께 onFulfillment() 핸들러만 사용해 왔지만 섹션 1에서 보았듯이 then() 메서드의 구문은 다음과 같습니다: then(onFulfillment, onRejected) 여기서 onRejection()은 선택 사항입니다. 그래서 then() 내부에서 거부된 promise를 처리하는 것과 catch() 내부에서 처리하는 것의 차이는 무엇일까요? 다음 코드를 살펴봅시다:\n\n```js\n//코드 1:\nPromise.reject('거절된:')\n  .then(() => console.log(\"만세!!\"), (rejectValue) => console.log(`${rejectValue} 부우!!`));\n\n//코드 2:\nPromise.reject('거절된:')\n  .then(() => console.log(\"만세!!\"))\n  .catch((rejectValue) => console.log(`${rejectValue} 부우!!`));\n```\n\n위 예제의 두 코드는 모두 \"거절된: 부우!!\"를 로그로 출력합니다. 그러나 내부적으로 두 코드는 매우 다르게 실행됩니다. 코드 1에서 onRejected() 핸들러는 직접 부모 promise 객체에 작용하지만 코드 2에서 onRejected() 핸들러는 실제로 .then()이 반환하는 promise에 작용합니다(이 promise은 부모 promise의 상태와 결과를 획득합니다). 두 가지 방법의 다른 점은 부모 promise가 해결되고 then()이 거부된 promise를 반환하는 경우 코드 1에서는 아무도 처리하지 않고 Uncaught Rejected Promise 예외가 발생한다는 것입니다. 아래 예제를 참조하세요:\n\n```js\n//코드 1:\nPromise.resolve('해결됨:')\n  .then(() => Promise.reject(\"거절된 자식 Promise\"), (rejectValue) => console.log(`${rejectValue} 부우!!`));\n\n//코드 2:\nPromise.resolve('해결됨:')\n  .then(() => Promise.reject(\"거절된 자식 Promise\"))\n  .catch((rejectValue) => console.log(`${rejectValue} 부우!!`));\n```\n\n\n\n\n![이미지1](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_21.png)\n\n![이미지2](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_22.png)\n\n이렇게 하는 이유는 코드 2에서 반환된 거부된 하위 프로미스가 연쇄적으로 처리기인 onRejection() 핸들러에 의해 처리되지만, 코드 1에서는 그렇지 않기 때문입니다.\n\n# 섹션 9: 몇 가지 까다로운 코드 스니펫의 출력 예측\n\n\n\n\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_23.png)\n\n이 섹션의 제목은 이 기사의 첫 번째 섹션이었다면 더 적절했을 것 같습니다. 지금까지 프로미스에 대해 충분히 익숙할 텐데 말이죠. 하지만 여전히 살펴봐야 할 복잡한 경우들이 있을 수 있다고 생각합니다. 그래서 이제 시작해 볼게요-:\n\n문제 1:\n\n```js\n(() => {\n    return (new Promise((resolve, reject) => {\n        resolve();\n        console.log(\"일요일 -> \");\n    }).then(() => console.log(\"화요일\")));\n})();\n\n(()=>console.log(\"월요일-> \"))();\n```\n\n\n\n\n이 코드 조각의 출력물은 무엇이 될 것이라고 생각하시나요? 아래 내용을 읽기 전에 먼저 출력물에 대해 생각해보세요.\n\n많은 사람들이 resolve() 메서드가 \"보류 중\" 프로미스의 상태를 \"이행됨\"으로 변경하고(그 외 다른 일들도 수반되며) onFulfillment() 콜백 핸들러를 호출한다고 생각합니다. 하지만 이것은 사실이 아닙니다. resolve() 메서드는 어떤 핸들러에도 호출을 하지 않습니다. JS Interpreter는 Executor 함수를 완전히 실행하고, 그 후에 Promise 생성자가 프로미스의 새 상태에 따라 각 예약된 콜백 핸들러(단일 \"핸들러\"가 아니라 여러 개의 핸들러가 등록될 수 있으므로)에 대한 호출을 수행합니다. 따라서 위 코드의 출력물은 \"Sunday - Monday - Tuesday\"이 될 것입니다.\n\n문제 2:\n\n```js\nvar letsResolveThisOutside, letsRejectThisOutside;\n\nnew Promise((resolve, reject) => { \n    letsResolveThisOutside = resolve; \n    letsRejectThisOutside = reject; \n})\n.then((resolveValue) => console.log(`${resolveValue}`));\n\nletsResolveThisOutside(\"나 죽었나?\");\n```\n\n\n\n위의 Promise가 질문을 한 콘솔을 볼 수 있을 거라고 생각하십니까? 생각해보신 후에 계속 읽어주세요.\n\n기술적으로 말하면, Executor의 범위 외에서 Promise를 해결/거부하는 것이 가능할까요? 네, 가능합니다. 로그가 그것을 말해주고 있습니다.\n\nMarkdown 형식의 표입니다:\n\n\n| Syntax | Description |\n| ----------- | ----------- |\n| Header | Title |\n| Paragraph | Text |\n\n\n이것은 두 가지 이유 때문입니다. 첫 번째로, \"var\" 변수가 전역 공간에 정의되어 있고 Executor 함수 내부가 아닌 곳에 있기 때문에 코드 어디에서든 접근이 가능합니다 (심지어 Promise 클래스 내부에서도). 두 번째로, JS가 동기적 언어이므로 onFulfillment() 핸들러가 이미 실행이 예약되어 있었기 때문에, 우리가 마지막으로 letsResolveThisOutside() 메서드를 호출했을 때 Promise가 해결되고 Callback 핸들러가 호출되었습니다.\n\n\n\n문제 3:\n\n다음 이미지에 나와 있는 과제에 대한 솔루션을 보여 드리겠습니다. 그리고 해당 코드 조각의 출력물이 무엇인지 알아내셔야 합니다. 출력물이 예상치 못한 것으로 나타난다면 코드를 크게 변경하지 않고도 예상된 출력물을 얻는 방법을 찾아내셔야 합니다. 과제:\n\n![task image](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_25.png)\n\n먼저, 위 과제를 직접 구현해보시거나 아래 솔루션을 읽고 후속 질문에 답해보시기 바랍니다...\n\n\n\n해결책:\n\n```js\nconst cleanRoom = (resolve, reject) => {\n    let num = Math.random();\n    if (num >= .5) { \n      resolve(num); //방 청소 완료\n    } else {\n      reject(new Error(num)); //방 청소 미완료\n    }\n  }\nconst roomCleaningPromise = new Promise(cleanRoom);\n\nroomCleaningPromise.then(function goFootballAfterCleaning(resolveValue) { // then1\n  console.log(`방이 청소되어 축구를 하러 갑니다 -: ${resolveValue}`);\n  return new Promise(function makeGoal(resolve, reject) {\n    let number = Math.random();\n    if (number >= .5) { //콘서트 가기\n      resolve(number);\n    } else {\n      reject(number); //강아지 케어\n    }\n  }) \n}).then(function goConcertAfterGoal(resolveValue) { // then2\n  console.log(`방이 청소되어 축구를 하고 골을 넣었습니다!! 이제 음악 콘서트로 갑니다 -: ${resolveValue}`);\n}).catch(function cleanDogAfterlosing(errorValue) { // catch1\n  console.log(`방이 청소되어 축구를 하러 갔지만 골을 못 넣어서 강아지 케어 -: ${errorValue}`);\n})\n  \nroomCleaningPromise.catch(function goLaundryAfterNoCleaning(errorValue) { // catch2\n  console.log(`방이 청소되지 않아 세탁을 하러 갑니다 -: ${errorValue}`);\n  return new Promise(function doLaundry(resolve, reject) {\n    let number_2 = Math.random();\n    if (number_2 >= .5) { //콘서트 가기\n      resolve(number_2);\n    } else {\n      reject(number_2); //강아지 케어\n    }\n  })\n}).then(function goConcertAfterLaundry(resolveValue) { // then3\n  console.log(`방이 청소되지 않아 세탁을 했지만 완료하지 못했어요. 그래서 강아지 케어 -: ${resolveValue}`);\n}).catch(function cleanDogAfterNoLaundry(errorValue){ //catch3\n  console.log(`방이 청소되지 않아 세탁을 하러 갔지만 완료하지 못해 강아지를 케어합니다 -: ${errorValue}`)\n}); \n```\n\n이제 위 코드에서 방이 청소되지 않고 세탁도 완료되지 않는 경우의 출력 결과를 찾아보세요. 그럼 아래 코드 로그를 확인해서 답을 확인하실 수 있습니다:\n\n```js\n방이 청소되지 않아 세탁을 하러 갑니다 -: Error: 0.10282616920143206\n방이 청소되어 축구를 하러 갔지만 골을 못 넣어서 강아지 케어 -: Error: 0.10282616920143206\n방이 청소되지 않아 세탁을 하러 갔지만 완료하지 못해 강아지를 케어합니다 -: 0.3140749736813231\n```\n\n\n\n이것은 좀 까다로울 거에요. 콘솔에서 위 출력물을 보고 있을 때 머리를 맞은 적이 있어요. 방이 깨끗한데 왜 두 번째 줄에 \"방이 청소되지 않았다...\"라고 나왔을까요?\n\n제가 이게 작은 실수라고 말하면 돌을 던지지 마세요. 자세히 살펴보면 이 코드가 혼란스럽고 오류가 있습니다. 바로 then2가 then1에 연결돼 있고 goFootballAfterCleaning() 핸들러가 반환한 프로미스에 연결되지 않았다는 거죠. 비슷하게 catch2도 catch1에 연결돼 있고 goLaundryAfterNoCleaning() 핸들러가 반환한 프로미스에 연결돼 있지 않다는 문제가 있어요. 그러니 이러한 오류를 수정해볼게요:\n\n```js\nconst cleanRoom = (resolve, reject) => {\n  let num = Math.random();\n  if (num >= 0.5)\n    resolve(num); // 방이 깨끗함\n  else\n    reject(new Error(num)); // 방이 청소되지 않음\n};\nconst roomCleaningPromise = new Promise(cleanRoom);\n\nroomCleaningPromise.then(function goFootballAfterCleaning(resolveValue) {// then1\n  console.log(`방이 깨끗해요. 축구를 하러 갑니다 -: ${resolveValue}`);\n  return new Promise(function makeGoal(resolve, reject) {\n    let number = Math.random();\n    if (number >= 0.5)\n      resolve(number); // 콘서트에 감\n    else\n      reject(number); // 강아지를 씻겨야 해요\n  })\n    .then(function goConcertAfterGoal(resolveValue) {// then2\n      console.log(`방이 깨끗해요. 축구를 한 다음 골을 넣었어요!! 이제 음악 콘서트에 갑니다 -: ${resolveValue}`);})\n    .catch(function cleanDogAfterlosing(errorValue) {// catch1\n      console.log( `방이 깨끗해요. 축구를 했지만 골을 넣지 못해서 강아지를 씻겨야 합니다 -: ${errorValue}`);\n    });\n});\n\nroomCleaningPromise.catch(function goLaundryAfterNoCleaning(errorValue) {// catch2\n  console.log(`방이 청소되지 않았어요. 세탁하러 가요 -: ${errorValue}`);\n  return new Promise(function doLaundry(resolve, reject) {\n    let number_2 = Math.random();\n    if (number_2 >= 0.5) // 콘서트에 가요\n      resolve(number_2);\n    else\n      reject(number_2); // 강아지를 씻겨야 해요\n  })\n    .then(function goConcertAfterLaundry(resolveValue) {// then3\n      console.log(`방이 청소되지 않았어요. 세탁을 하러 간 후 완료했으니 이제 음악 콘서트에 갑니다 -: ${resolveValue}`);\n    })\n    .catch(function cleanDogAfterNoLaundry(errorValue) {//catch3\n      console.log(`방이 청소되지 않았어요. 세탁을 하러 갔지만 완료하지 못해서 강아지를 씻겨야 합니다 -: ${errorValue}`);\n    });\n});\n```\n\n이렇게 돌린다면 잘 될 거 같죠? 글쎄요, 잘 되지 않았어요. 가능한 결과 중 하나는 다음과 같았습니다:\n\n\n\n\n![Image](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_26.png)\n\n로그에 추가로 Uncaught Rejected Promise 오류가 표시되고 이미 섹션 7에서 왜 이러한 오류가 발생하는지, 이 문제에 대한 해결책을 이미 알고 있습니다. 이 문제를 빠르게 해결해 봅시다:\n\n```js\nconst cleanRoom = (resolve, reject) => {\n  let num = Math.random();\n  if (num >= 0.5)\n    resolve(num); // 방청소 완료\n  else\n    reject(new Error(num)); // 방청소 실패\n};\nconst roomCleaningPromise = new Promise(cleanRoom);\n\nroomCleaningPromise.then(function goFootballAfterCleaning(resolveValue) {// then1\n  console.log(`방을 청소했으니 축구를 하러 갑니다 -: ${resolveValue}`);\n  return new Promise(function makeGoal(resolve, reject) {\n    let number = Math.random();\n    if (number >= 0.5)\n      resolve(number); // 콘서트로 가기\n    else\n      reject(number); // 강아지 돌보기\n  })\n    .then(function goConcertAfterGoal(resolveValue) {// then2\n      console.log(`방을 청소했으니 축구를 하러 갔고 골을 넣었어요!! 이제 음악 콘서트에 갑니다 -: ${resolveValue}`);})\n    .catch(function cleanDogAfterlosing(errorValue) {// catch1\n      console.log( `방을 청소했으니 축구를 하러 갔지만 골을 못 넣어서 강아지를 돌봅니다 -: ${errorValue}`);\n    });\n})\n.catch(()=>{});\n\nroomCleaningPromise.catch(function goLaundryAfterNoCleaning(errorValue) {// catch2\n  console.log(`방을 청소하지 않았으니 세탁을 하러 갑니다 -: ${errorValue}`);\n  return new Promise(function doLaundry(resolve, reject) {\n    let number_2 = Math.random();\n    if (number_2 >= 0.5) // 콘서트로 가기\n      resolve(number_2);\n    else\n      reject(number_2); // 강아지 돌보기\n  })\n    .then(function goConcertAfterLaundry(resolveValue) {// then3\n      console.log(`방을 청소하지 않았으니 세탁을 하러 갔고 완료했으니 이제 음악 콘서트에 갑니다 -: ${resolveValue}`);\n    })\n    .catch(function cleanDogAfterNoLaundry(errorValue) {// catch3\n      console.log(`방을 청소하지 않았으니 세탁을 하러 갔지만 완료하지 못했으니 강아지를 돌봅니다 -: ${errorValue}`);\n    });\n});\n```\n\n이 코드는 완벽하게 작동하지만 전문적이지 않은 방식으로 작성된 코드입니다. .catch(()=`''')를 보고 목적을 알기 어려울 것입니다. 따라서 이 작업을 더 나은 방법으로 해결하고 전문적인 모듈식 코드를 작성하는 것이 좋습니다. 같은 해결책을 생각했을 것으로 기대합니다:\n\n\n\n\n```js\nconst cleanRoom = (resolve, reject) => {\n  let num = Math.random();\n  if (num >= 0.5) resolve(num); // 방을 청소했어요\n  else reject(new Error(num)); // 방을 못 청소했어요\n};\n\nfunction goConcertAfterGoal(resolveValue) {\n    console.log(`방을 청소해서 축구를 하러 갔다가 골을 넣었어요!! 이제 음악 회관으로 갑니다 -: ${resolveValue}`);\n}\n\nfunction cleanDogAfterlosing(errorValue) {\n    console.log(`방을 청소해서 축구를 하러 갔지만 골을 못 넣어서 개를 씻고 있어요 -: ${errorValue}`);\n}\n\nfunction goConcertAfterLaundary(resolveValue) {\n    console.log(`방을 청소하지 않았어요. 빨래를 하러 가는데 완료했어요. 이제 음악 회관에 갑니다 -: ${resolveValue}`);\n}\n\nfunction cleanDogAfterNoLaundary(errorValue) {\n    console.log(`방을 청소하지 않았어요. 빨래를 하러 가는데 못 했어서 개를 씻고 있어요 -: ${errorValue}`);\n}\n\nfunction goFootballAfterCleaning(resolveValue) {\n  console.log(`방을 청소해서 축구를 하러 가요 -: ${resolveValue}`);\n  return new Promise(function makeGoal(resolve, reject) {\n    let number = Math.random();\n    if (number >= 0.6) resolve(number); // 음악 회관으로 가요\n    else reject(number); // 개 씻음\n  })\n    .then((resolveValue) => goConcertAfterGoal(resolveValue), (errorValue) => cleanDogAfterlosing(errorValue));\n}\n\nfunction goLaundaryAfterNoCleaning(errorValue) {\n  console.log(`방을 청소하지 않았어요. 빨래를 하러 가요 -: ${errorValue}`);\n  return new Promise(function doLaundary(resolve, reject) {\n    let number_2 = Math.random();\n    if (number_2 >= 0.4) resolve(number_2); // 음악 회관으로 가요\n    else reject(number_2); // 개 씻음\n  })\n    .then((resolveValue) => goConcertAfterLaundary(resolveValue), (errorValue) => cleanDogAfterNoLaundary(errorValue));\n}\n\nconst roomCleaningPromise = new Promise(cleanRoom);\n\nroomCleaningPromise\n  .then((resolveValue) => goFootballAfterCleaning(resolveValue), (errorValue) => goLaundaryAfterNoCleaning(errorValue));\n```\n\n위 문제에 대한 참고 자료: 과제의 출처.\n\n# 섹션 10: 프로미스가 어떻게 구현되는지 이해하기 위해 사용자 정의 프로미스 만들기.\n\n<img src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_27.png\" />\n\n\n\n\n\"How\" Promises가 실제로 작동하는 방식과 Promises를 구현할 때 왜 그렇게 하는지에 대해 이야기하려면 Bottom-up 방식을 채택해야 합니다. 즉, 우리는 다음과 같이 기본부터 직접 Custom Promises를 만들어가면서 이러한 두 가지에 대해 배우게 됩니다:\n\n```js\nclass CustomPromise {\n  constructor(executor) {\n    this.state = \"pending\";\n    this.result = null;\n    this.onResolveCallbacks = []; // 모든 예약된 resolve 콜백을 저장하는 곳\n    this.onRejectCallbacks = []; // 모든 예약된 reject 콜백을 저장하는 곳\n\n    const resolve = (resolveValue) => {\n      if (this.state === \"pending\") {\n        this.state = \"fulfilled\";\n        this.result = resolveValue;\n        this.executeCallbacks(this.onResolveCallbacks, resolveValue);\n      }\n    };\n\n    const reject = (reason) => {\n      if (this.state === \"pending\") {\n        this.state = \"rejected\";\n        this.result = reason;\n        this.executeCallbacks(this.onRejectCallbacks, reason);\n      }\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n\n  executeCallbacks(callbacks, arg) {\n    // 다음 tick에서 실행되도록 콜백들을 대기열로 지정합니다\n    setTimeout(() => {\n      callbacks.forEach((callback) => {\n        try {\n          const result = callback(arg);\n          if (result instanceof CustomPromise) {\n            // 콜백이 프로미스를 반환하는 경우 연쇄화합니다\n            result.then(\n              (value) => this.resolveChainedPromise(value),\n              (reason) => this.rejectChainedPromise(reason)\n            );\n          } else {\n            // 콜백이 프로미스가 아닌 값을 반환하는 경우 해당 값으로 프로미스를 해결합니다\n            this.resolveChainedPromise(result);\n          }\n        } catch (error) {\n          // 예외가 발생하는 경우 프로미스를 거부합니다\n          this.rejectChainedPromise(error);\n        }\n      });\n    }, 0); // 비동기 실행을 위해\n  }\n\n  resolveChainedPromise(result) {\n    // 주어진 결과로 프로미스를 해결합니다\n    this.state = \"fulfilled\";\n    this.result = result;\n    this.executeCallbacks(this.onResolveCallbacks, result);\n  }\n\n  rejectChainedPromise(reason) {\n    // 주어진 이유로 프로미스를 거부합니다\n    this.state = \"rejected\";\n    this.result = reason;\n    this.executeCallbacks(this.onRejectCallbacks, reason);\n  }\n\n  then(onFulfilled, onRejected) {\n    return new CustomPromise((resolve, reject) => {\n      if (this.state === \"fulfilled\") {\n        this.queueCallbackForExecution(\n          onFulfilled,\n          this.result,\n          resolve,\n          reject\n        );\n      } else if (this.state === \"rejected\") {\n        this.queueCallbackForExecution(\n          onRejected,\n          this.result,\n          resolve,\n          reject\n        );\n      } else {\n        this.onResolveCallbacks.push((result) => {\n          this.queueCallbackForExecution(onFulfilled, result, resolve, reject);\n        });\n        this.onRejectCallbacks.push((reason) => {\n          this.queueCallbackForExecution(onRejected, reason, resolve, reject);\n        });\n      }\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  queueCallbackForExecution(callback, arg, resolve, reject) {\n    setTimeout(() => {\n      try {\n        const result = callback ? callback(arg) : arg;\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    }, 0); // 비동기 실행을 위해\n  }\n}\n```\n\n참고: 위의 Custom Promise는 교육 목적으로 제공되었으며 많은 기능이 누락되었으며 실제로 구현된 방식과 다를 수 있습니다. 또한 위의 코드가 모든 시나리오에 작동하지 않을 수도 있습니다 (P.S. 저는 프로그래밍 언어 개발자가 아닙니다 🙃)\n\n위의 Promise는 확실히 설득력 있지만 동시에 압도적입니다. 따라서 Promise가 해결될 때 위의 코드의 제어 흐름을 살펴봅시다.\n\n\n\n단계 1: Constructor가 Executor 함수로 호출됩니다. 여기서 먼저 상태, 결과, onResolveCallbacks, onRejectCallbacks 필드가 기본값으로 할당됩니다. 또한 resolve와 reject 메서드가 여기서 정의되고 변수에 저장됩니다 (나중에 Executor 함수에 전달될 것임).\n\n단계 2: Executor 함수가 실행되어 resolve() 함수 또는 reject() 함수를 호출합니다. 예를 들어, resolve() 메서드가 호출되었다고 가정합니다.\n\n단계 3: resolve() 메서드는 Promise의 상태를 변경하고 결과를 저장합니다. 또한 이 메서드는 나중에 비동기적으로 실행될 executeCallbacks() 메서드를 \"예약\"합니다.\n\n단계 4: JS 해석기는 Executor 함수를 계속 실행한 다음, then() 메서드를 실행합니다.\n\n\n\n단계 5: 제어가 then() 메서드로 전달됩니다. 먼저 약속이 아직 \"대기 중\" 상태에 있으므로 executeCallbacks() 메서드가 아직 실행되지 않았기 때문에 else 부분이 실행됩니다.\n\n단계 6: 약속이 \"이행\" 상태가 되면 executeCallbacks()가 호출되어 onResolveCallbacks에 저장된 콜백을 실행합니다.\n\n이로써 JavaScript의 Promise에 관한 6000단어가 넘는 기사가 끝이 났습니다. 마음에 드셨기를 바랍니다.","ogImage":{"url":"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_0.png","tag":["Tech"],"readingTime":36},{"title":"자바스크립트 CircleQueue  Map  빠르고 덮어쓸 수 있는 큐","description":"","date":"2024-05-14 13:03","slug":"2024-05-14-JSCircleQueueMapUltra-fastoverwritablequeue","content":"\n\n시퀀셜하게 실행해야 하는 작업들을 대기열에 넣고 일정 간격으로 처리하는 시스템은 매우 흔합니다. 프론트엔드용 새로운 뷰 시스템을 개발하는 도중, 프레임별로 대기열에서 처리할 수 있는 작업량만 시간 제한 내에 처리하는 메커니즘을 도입했습니다. 초당 60프레임 제한으로 한 프레임 당 실행 시간은 16밀리초입니다. 대기열 작업 처리가 16밀리초를 초과하면 남은 작업은 다음 프레임에서 처리됩니다.\n\n대기열에 누적된 많은 작업들이 매 프레임마다 실행되어야 하는 경우, 빠른 속도로 대기열 작업을 디큐하는 과정이 필요했습니다. 또한, 대기열에 이미 동일한 식별 키를 갖는 작업이 존재할 경우 해당 작업은 무시되고 새 작업으로 덮어쓰이는 기능을 구현해야 했습니다.\n\n- 고속 인큐 및 디큐 작업.\n- 각 작업에 할당된 키가 동일한 경우 덮어쓰기.\n\n먼저 간단한 자바스크립트로 이 문제를 해결해 보겠습니다. 가장 먼저 떠오르는 방법은 서큘러 큐입니다. 버퍼 크기를 초과하지 않는 한 요소를 인큐하고 디큐하는 것은 쉽습니다. 저는 이를 단순한 버전으로 구현했습니다.\n\n\n\n```js\nclass MapQueue{\n  #size;\n  #front = 0;\n  #rear = 0;\n  #length = 0;\n  constructor(size){this.#size = size;}\n  length(){return this.#length;}\n  add(value){\n    if(this.#length === this.#size) throw new Error('overflow');\n    this[this.#rear++] = value;\n    if(this.#rear === this.#size) this.#rear -= this.#size;\n    this.#length++;\n  }\n  shift(){\n    if(!this.#length) return null;\n    this.#length--;\n    const data = this[this.#front++];\n    if(this.#front === this.#size) this.#front -= this.#size;\n    return data;\n  }\n}\n```\n\n원과 리어 포인터를 사용하는 원형 큐의 매우 전형적인 구현으로, 모듈로 연산 대신에 사이즈를 미리 빼는 약간의 성능적 이점이 있습니다.\n\n객체가 배열이 아니기 때문에 이미 이것만으로 초고속 큐가 완성되었습니다. 이제 두 번째 요구사항에 대해 다룰 차례입니다: 같은 키에 대한 덮어쓰기입니다.\n\n```js\nconst EMPTY = Object.create(null);\nclass MapQueue{\n  #keys = Object.create(null);\n  #size;\n  #front = 0;\n  #rear = 0;\n  #length = 0;\n  constructor(size){this.#size = size;}\n  length(){return this.#length;}\n  set(key, value){\n    if(this.#keys[key] === undefined){\n      if(this.#length === this.#size) throw new Error('overflow');\n      this.#keys[key] = this.#rear;\n      this[this.#rear++] = value;\n      if(this.#rear === this.#size) this.#rear -= this.#size;\n      this.#length++;\n    }else{\n      const old = this[this.#keys[key]];\n      this[this.#keys[key]] = value;\n      return old;\n    }\n  }\n  get(key){\n    if(this.#keys[key] === undefined) return null;\n    return this[this.#keys[key]];\n  }\n  remove(key){\n    if(this.#keys[key] === undefined) return;\n    this[this.#keys[key]] = EMPTY;\n    delete this.#keys[key];\n    this.#length--;\n  }\n  shift(){\n    if(!this.#length) return null;\n    while(this[this.#front] === EMPTY){\n      delete this[this.#front];\n      this.#front++;\n      if(this.#front === this.#size) this.#front -= this.#size;\n    }\n    const data = this[this.#front];\n    delete this[this.#front];\n    this.#front++;\n    if(this.#front === this.#size) this.#front -= this.#size;\n    this.#length--;\n    return data;\n  }\n}\n```\n\n\n\n특성:\n- #keys: 키와 해당 키의 인덱스를 큐에 저장하는 맵으로 사용되는 객체입니다.\n- #size: 큐의 최대 크기입니다.\n- #front: 큐의 맨 앞 요소의 인덱스입니다.\n- #rear: 다음 요소가 큐에 추가될 인덱스입니다.\n- #length: 큐 안 현재 요소의 수입니다.\n\n메서드:\n- constructor(size): 주어진 최대 크기로 큐를 초기화하는 생성자 메서드입니다.\n- length(): 큐 안 현재 요소의 수를 반환합니다.\n- set(key, value): 지정된 키와 값으로 새 요소를 큐에 추가합니다. 키가 이미 존재하는 경우 해당 값이 업데이트되고 이전 값을 반환합니다. 큐가 꽉 찬 경우 'overflow' 오류를 발생시킵니다.\n- get(key): 큐에서 지정된 키와 관련된 값을 검색합니다. 키가 존재하지 않는 경우 null을 반환합니다.\n- remove(key): 큐에서 지정된 키를 가진 요소를 제거합니다. 키가 존재하지 않는 경우 아무 작업도 수행하지 않습니다. 제거된 요소를 EMPTY로 표시합니다.\n- shift(): 큐에서 맨 앞 요소를 제거하고 반환합니다. 큐가 비어 있는 경우 null을 반환합니다. 큐의 맨 앞에 있는 EMPTY 요소를 건너뛰고 제거합니다.\n\n이 코드는 객체 기반의 원형 큐 접근 방식을 사용하여 빠른 큐를 구현합니다. 고유한 키로 요소를 추가하고, 기존 키에 대한 값 업데이트, 키별로 요소 제거, 맨 앞 요소 검색을 지원합니다. 큐는 요소가 큐 중간에서 제거될 때 해당 요소를 EMPTY로 표시하고, 앞에서 요소를 이동할 때 해당 요소를 건너뛰는 방식으로 효율적으로 처리합니다.","ogImage":{"url":"/assets/img/2024-05-14-JSCircleQueueMapUltra-fastoverwritablequeue_0.png"},"coverImage":"/assets/img/2024-05-14-JSCircleQueueMapUltra-fastoverwritablequeue_0.png","tag":["Tech"],"readingTime":4},{"title":"우리가 AWS를 떠나 1백만 달러에서 20만 달러로 80 절감한 연간 서버 비용 경험 공유","description":"","date":"2024-05-14 13:00","slug":"2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS","content":"\n\n## Prerender의 기술 리드이자 총괄 매니저 인 Zsolt Varga와의 인터뷰\n\n![이미지](/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_0.png)\n\n이번 주에 Prerender.io의 기술 리드 및 매니저 인 Zsot Varga와 인터뷰했습니다. 그는 Prerender가 AWS에 의존하지 않고 인프라를 직접 구축하여 트래픽 및 캐시된 데이터를 처리함으로써 80만 달러를 절약한 경험을 공유했습니다.\n\n## Prerender와 해결하고 있는 가장 흥미로운 기술적 문제를 설명해 줄 수 있나요?\n\n\n\n간단히 말해서, 프리렌더는 JavaScript 페이지를 캐시하고 사이트에 적절한 미들웨어가 설치된 상태로 검색 엔진이 순수한 HTML 파일을 크롤링하고 인덱싱할 수 있도록 해줍니다. 이를 통해 사용자들이 비실용적이고 시간이 많이 소요되는 JavaScript 우회 방법으로 번거로움을 겪지 않게 됩니다.\n\n그러나 이 모든 데이터와 프로세스는 서버에서 발생해야 하며 물론, 우리는 AWS를 사용했습니다. 몇 년간의 성장 이후, 우리는 분당 7만 페이지 이상을 처리하며, 약 5억 6천만 페이지를 저장하고 있으며, 연 당 100만 달러 이상을 지불하고 있습니다.\n\n물론 AWS에 머무른다면 그만큼 많은 비용이 발생할 것입니다. 대신, 우리는 아웃 오브 더 박스 사고와 명확한 계획을 통해 3개월도 안 되어 80% 비용을 절감할 수 있었습니다. 여러분도 다음과 같이 할 수 있습니다.\n\n## 이주 계획: 단계별 안내\n\n\n\n최근까지 Prerender는 클라이언트들을 위해 캐시하고 렌더링하는 페이지를 Amazon Web Services (AWS)에서 호스팅하는 서버와 서비스를 사용했습니다. AWS는 최대 규모의 클라우드 제공업체 중 하나로, 가상 서버와 관리 서비스를 제공합니다.\n\n이전까지 Prerender는 Google, Facebook 또는 다른 콘텐츠를 색인화하려는 봇/스파이더에 의해 가져가기 준비가 된 때까지 캐시를 저장하는 데 AWS를 사용해왔습니다. 이것은 Prerender의 기능 중 상당 부분을 차지하며, Google 및 다른 검색 엔진에 정적 HTML을 제공하고 인간 사용자에게 동적인 상호작용형 JavaScript를 제공했습니다.\n\n문제는 무려 테라바이트 단위의 사전 렌더링된 웹 페이지 콘텐츠를 3자 서버에 이렇게 저장하는 것이 매우 비용이 많이 든다는 것이었습니다. 이 방식으로 캐시된 페이지를 저장하는 것은 Prerender에게 유지 및 호스팅 비용만으로 엄청나게 많은 비용이 들었습니다.\n\n하지만 이것은 고려해야 할 또 다른 함정이 있었고, 많은 스타트업들이 고려하지 않는 것이며 그에 대한 논의가 많이 부족한 문제: 트래픽 비용입니다.\n\n\n\nAWS로 데이터를 가져 오는 것은 기술적으로 무료이지만, 대부분의 소프트웨어에 정적 데이터가 어떻게 유용한가요? 데이터를 이동하면 Prerender에게는 엄청난 비용이 들었고, 우리는 우리를 제한하고 있는 병목 현상에 대해 알아차리기 시작했습니다.\n\n해결책은 무엇이었나요? 캐시된 페이지와 트래픽을 Prerender의 내부 서버로 이전하고 AWS에 대한 의존도를 최대한 빨리 줄이는 것이었습니다.\n\n비용 예측을 하자, 호스팅 비용을 40% 줄일 수 있을 것으로 추정하고, 서버 이전을 통해 Prerender와 고객의 비용을 모두 줄일 수 있을 것으로 결정했습니다.\n\n목표는 비용을 줄이면서 렌더링 속도와 서비스 품질을 동일하게 유지하는 것이었습니다. 이러한 이주는 신중하게 계획되고 실행되어야 하며, 잘못된 구성 또는 잘못된 실행이 고객 웹 페이지 및 소셜 미디어 클릭의 다운 타임을 초래하고 검색 순위에 영향을 미칠 수 있으며, 우리의 이탈률을 증가시킬 수 있습니다.\n\n\n\n잠재적인 결과를 완화하기 위해 이전 단계로 쉽게 되돌아갈 수 있는 3단계 과정을 계획했습니다. 새 서버가 작동하지 않는 경우를 대비해 변경 사항을 쉽게 롤백하여 고객에게는 고객에게 눈에 띄지 않는 다운타임이나 서비스 저하가 발생하지 않습니다.\n\n계속적이고 체계적인 테스트의 주요 한계는 수주 및 수개월에 걸쳐 진행된다는 것입니다.\n\n# AWS에서 Prenderer 이동: 주간 개요\n\n## 1단계 — 테스트 (4~6주)\n\n\n\nPhase 1은 주로 베어 메탈 서버를 설정하고 스케일링하기 전에 작은 규모에서 마이그레이션을 시험해 보는 것을 포함했습니다. 이 단계에서는 소프트웨어를 최소한으로 적용하여 Linux의 KVM 가상화에서 실행하기로 결정했습니다.\n\n5월 초에는 첫 번째 일괄 서버가 가동되었고 Prerender 트래픽의 1%가 새로운 서버로 전달되었습니다. 마이그레이션 시작 후 2주 만에 하루에 800달러를 절약하고 있었습니다. 한 달이 끝날 때쯤에는 대부분의 트래픽 워크로드를 AWS로부터 이전하여 일일 Chrome 렌더링 워크로드 비용을 45%로 줄였습니다.\n\n서버 비용 부분에서 현재 우리의 비용은 월 13,000달러입니다. AWS와 결합하여 이미 비용을 22% 절감했습니다.\n\n![이미지](/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_1.png)\n\n\n\n테스트 단계가 매끄럽게 진행될 수 있도록 중요했습니다. 더 많은 모니터링 및 더 나은 오류 처리로 시스템의 견고성을 향상시키는 데 노력했습니다. 이미 보유하고 있던 서버 모니터링 대시보드 외에도 발생한 오류나 성능 문제를 식별할 수 있는 새로운 렌더링 모니터링 대시보드를 설정했습니다.\n\n![Image](/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_2.png)\n\n지속적인 모니터링과 명확한 커뮤니케이션 덕분에 테스트는 성공적이었고, 절약 예산은 초과되었으며 이사의 제2 단계를 시작할 준비가 모두 마련되었습니다.\n\n## 제2 단계 — 기술적인 설정(4 주)\n\n\n\n6월 중순부터 7월 초까지의 이관 기간은 대부분 마이그레이션의 첫 단계가 컨셉 검증을 위한 작업으로 기술적인 설정에 사용되었습니다. 두 번째 단계의 구현은 대부분 캐시 저장소를 베어 메탈 서버로 이동하는 작업을 포함했습니다.\n\n6월 중순에 이관이 진행되었을 때, 300대의 서버가 매우 원활하게 작동하며 전체 2억 개의 캐시 페이지가 있었습니다. 각 서버에는 AWS S3와 호환되는 Apache Cassandra 노드를 사용했습니다.\n\n온라인 마이그레이션을 한 단계씩, 한 주 또는 두 주 간격으로 네 단계로 나누어 실행했습니다. Prerender 페이지가 S3와 미니오에서 캐시될 수 있는지 테스트한 후, AWS S3로의 트래픽을 점진적으로 중단하고 미니오로 유도했습니다. S3로의 쓰기가 완전히 중지된 후에는 Prerender가 S3 API 비용을 하루에 200달러 절약하며, 우리의 Cassandra 클러스터에 이미 캐시된 데이터를 삭제할 준비가 되었음을 나타냈습니다.\n\n하지만, 이 단계의 마무리는 6월 24일쯤에 이루어졌습니다. 지난 네 주 동안, 우리는 대부분의 캐시 작업 부하를 AWS S3에서 우리 자체의 Cassandra 클러스터로 옮겼습니다. AWS의 일일 비용이 1.1K 달러로 감소되어 월 35K로 추산되며, 새로운 서버의 월 반복 비용은 약 14K로 추산되었습니다.\n\n\n\n이 시점에서 S3에는 하루에 약 60달러가 드는 일부 잔여물이 남아 있었고, 자연스럽게 몇 주 안에 완전히 소멸할 것으로 예상되었습니다. 모든 데이터를 이동하여 즉시 비용을 제로로 줄일 수도 있었지만, AWS에서 데이터를 이동하면 한 번에 5천 달러의 \"돈 낭비\"가 발생할 것이었습니다.\n\n데이터 이동은 엄청난 병목 현상에 직면하게 될 때입니다. 우리의 신규 CTO(Zsolt Varga)의 말을 빌리자면:\n\n\"AWS의 진정한 숨겨진 비용은 트래픽 비용에서 나옵니다. 그들은 합리적인 가격의 저장소를 판매하고 업로드는 무료입니다. 그러나 꺼낼 때는 막대한 비용을 지불해야 합니다.\n\n작은 스타트업에서는 종종 트래픽 비용을 계산하지 않습니다. 비용 중 90%에 해당할 수도 있다는 사실을 인식하지 못합니다\"\n\n\n\n예를 들어, 미국 서부(오레곤) 지역에 계시면, 1GB당 0.080달러를 내야 하지만, 아시아 태평양(서울) 지역으로 이동하면 1GB당 0.135달러로 올라갑니다.\n\n저희 경우에는 매달 약 3만 달러에서 5만 달러 사이였습니다. 제2단계가 끝나면 월 총 서버 비용을 41.2%로 줄일 수 있었어요.\n\n![이미지](/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_3.png)\n\n## 제3단계 — 구현 및 확장 (4~6주)\n\n\n\n이 시점에서 이주 작업은 이미 원활하게 진행 중이었고 이미 Prerender가 상당한 금액을 절약하고 있었습니다. 할 일으로 남은 것은 다른 모든 데이터를 네이티브 서버로 이주하는 것뿐이었습니다.\n\n이 단계에서는 Amazon RDS 인스턴스를 Shard 단위로 모두 이동하는 것이 포함되었습니다. 이것이 전체 프로세스 중에서 가장 오류가 발생하기 쉬운 부분이었지만, 이미 많은 양의 데이터가 이주되어 있었기 때문에 어떠한 결멍이나 병목 현상도 전체 이주를 망가뜨리지 않았을 것입니다.\n\n이주 프로세스의 마지막 단계를 큰 그림에서 보면:\n\n- 우리는 캐시된 URL 테이블을 저장하는 PostgreSQL 샤드를 Cassandra로 미러링했습니다.\n- 우리는 Cloudflare 로드 밸런서로 서비스.prerender.io를 전환하여 동적 트래픽 분배를 허용했습니다.\n- 우리는 새로운 EU Private-recache 서버를 설정했습니다.\n- 성능 문제를 해결하기 위해 계속해서 스트레스 테스트를 실시하고 있습니다.\n\n\n\n마이그레이션은 결과적으로 대성공을 거뒀습니다. 모든 캐시된 페이지가 리디렉션된 이후에 월간 서버 요금은 초기 추정액 40% 밑으로 내려가 전체 80%까지 감소했습니다.\n\n## 우리가 배운 것\n\n서버 마이그레이션에서는 잘못되거나 일정을 따라가지 못하는 것이 막대한 위험을 안겨 줄 수 있습니다. 그래서 우리는 마이그레이션 각 단계마다 실패 방지장치를 구현하여 무언가 잘못되었을 때 대비할 수 있도록 보장했습니다. 또한 나머지 마이그레이션을 진행하기 전에 소규모로 테스트하여 안전하게 진행할 수 있도록 했습니다.\n\n마이그레이션의 각 단계를 주의 깊게 계획하고, 확장하기 전 각 구현 단계를 테스트하며, 문제가 발생할 경우 오류를 수정하기 쉽도록 만들어 위험을 최소화했습니다. 이렇게 함으로써 서버 비용을 절약하면서 잠재적인 위험을 최소화할 수 있었습니다.\n\n\n\n## Prerender가 해결하는 문제에 대해 일하게 된 동기는 무엇이었나요?\n\n웹을 발전시키는 데 도움을 주는 플랫폼에서 일할 생각에 흥분했습니다.\n\nPrerender를 사용하면 고객들이 사용자 경험에 중점을 둔 웹사이트를 제공하고 SEO에 집중하는 대신 고객들에게 최상의 서비스를 제공할 수 있습니다. 지난 몇 년 동안 새로운 랜딩 페이지를 만들 때마다 우리는 항상 최고의 SEO를 얻기 위해 Wordpress를 사용하고 관리 섹션과 같은 색인되지 않은 페이지에만 SPA의 장점을 활용해 왔습니다. 그러나 이제는 과거에 나를 막아 두었던 문제를 해결하는 회사와 함께 일하고 있습니다 :)\n\n## 어떤 기술 스택을 사용하시나요? 그리고 이 스택을 선택한 이유는 무엇인가요?\n\n\n\n우리는 JavaScript를 어디서나 사용합니다. JavaScript 렌더링으로 인한 \"이슈\"들을 해결하기 때문에, 이 분야에서 가능한 한 많은 전문 지식을 쌓고 싶습니다. 그러나 다른 부분들에 대해서는, 빠른 응답과 글로벌 확장성을 위해 CloudFlare의 분산 시스템을 활용하고 있습니다. 또한 우리의 가용성 보증은 Digital Ocean의 클라우드 플랫폼에서 지원받고 있습니다. 우리는 효율성을 극대화하기 위해 다양한 다른 SaaS 제공업체를 활용하고 있습니다.\n\n## 회사가 비전을 달성했을 때 세상이 어떻게 보일 것인가요?\n\n\"새로운 사이트에 React를 사용할 수 있을까?\"라는 질문이 나오면 \"물론!\"이라고 대답할 것입니다. 왜냐하면 현재의 마케팅 부서들은 항상 SEO 순위를 낮출 수 있는 것들을 거부하고 있기 때문입니다. 그것이 옳다고 말할 것입니다. 고객들에 대해서는, 심지어 효율성이 1%라도 감소하면, 그들은 광고 예산을 수십만 달러로 증액해야 할 것입니다.\n\n## 당신에게 전형적인 하루는 어떻게 보이나요?\n\n\n\n하하, 고객 전화가 많이 오네요! 우리는 헌신적인 팀을 작고 효과적으로 유지하기를 목표로 하고 있어서, 대부분의 시간을 그들과 온보딩 통화에 사용하고 있어요. 그러나 이 일을 하는 건 즐겁죠! 항상 고객들과 대화하고, 그들의 상황에 대해 배우고, 해결책에 대해 이야기하는 걸 좋아해요. 이런 식으로 하니 제 업무가 훨씬 수월해지죠. 우리가 아이디어를 생각할 필요가 없어서, 고객들이 필요한 모든 정보를 우리에게 알려주기 때문이죠. 고객 중심적인 상황이 가장 좋다고 믿고 있어요. 제 목표는 행복한 고객들의 수를 늘리는 거죠.\n\n## 컴퓨터 하드웨어 설정 설명\n\n오, 이건 정말 기사로서 쓸 만한 가치가 있을 것 같아요. 저는 조금은 게이머 같은데요, 집에 전용 서버 8대가 있어요. 하지만 편의상 대부분 맥북에서 작업을 하고 있어요. 그러나 프로그래밍을 할 시간이 생기면 Manjaro가 돌아가는 \"작업용\" 컴퓨터를 사용해요. 그리고 가끔 나만의 시간을 갖게 되면, 비밀리에 게임을 즐기려고 운영체제가 윈도우인 PC를 가동시켜요. 지금 이 글을 쓰는 순간에는 노트북, 라즈베리파이, 태블릿으로 둘러싸여 있어요.\n\n늦은 밤에 기계를 조립하고 축소된 테스트를 실행하는 것이 제 취미거든요.\n\n\n\n## 내 컴퓨터 소프트웨어 설정 설명\n\nVSCode는 저에게 완벽한 솔루션이에요. 프로그래밍 언어에 대해서 그렇게 애정이 없지만, 확장 프로그램을 설치하고 IDE에서 지원하는 코드를 바로 작성할 수 있는 자유를 제공해줘요. 게다가 CoPilot의 베타 그룹에 들어간 운이 있었는데, 이것은 분명한 게임 체인저에요.\n\n소스 제어로는 GitHub이 멋지지만, 다른 솔루션을 무시하지는 않아요. GitLab은 최근 몇 년 동안 정말 멋진 도구로 발전했어요.\n\n메시징 측면에서는 Slack이 여전히 가장 널리 쓰이는 전문적인 선택지라고 생각되고, 그 일을 잘하니까, 다른 것으로 옮겨가야 할 이유가 없어요. 그러나 최근에 Spike라는 매우 흥미로운 소프트웨어를 발견했고, 지난 3개월 동안 이것을 이메일 클라이언트로 사용해왔어요. 회화 스타일로 이메일을 보낼 수 있어서 훨씬 편리해요.\n\n\n\n중요한 도구: 도커, 다른 방법이 없어요. 이것이 업계를 가장 좋게 변화시켰어요. 아직도 의존성을 설치하고 패키지 충돌을 해결해야 했던 어두운 옛날을 기억해요…\n\n하지만, 그래도 쿠버네티스가 점차 적응 수준이 비슷해져 가고 있어요.\n\n## 시작 단계의 소프트웨어 엔지니어를 위한 조언이 있나요?\n\n고객과 대화할 때 두려워하지 마세요. 제 경력 동안, 최고의 소프트웨어 엔지니어는 고객과 협력하여 문제를 해결한 분들이었어요. 때로 한 줄의 코드로 고객의 문제를 해결할 수 있다는 것을 배우면 개발 시간을 6개월 이상 줄일 수 있어요. 저는 최고의 엔지니어들은 실제 세계의 문제에 대한 해결책을 창조한다고 생각해요.\n\n\n\n## 채용 중이신가요? 어떤 역할을 모집하고 계신가요?\n\n언제나 채용 중이에요! 우리는 항상 새로운 동료들이 의미 있는 역할을 맡고 분명한 기여를 할 수 있는 경우에만 고용하려고 노력해요. 현재까지 우리는 많이 성장했기 때문에 각 부서에서 팀원을 더 모집해야 하는 상황입니다. 그래서 목록으로 나열하는 대신에 저희의 채용 페이지를 확인해주세요 :D https://saas.group/career\n\n## 좀 더 자세히 알고 싶은 경우 어디서 확인할 수 있나요?\n\n저희 사이트인 prerender.io를 확인해보세요! 그리고 prerendering에 대해 어떻게 웹을 변경하는지 궁금하시다면 varga@prerender.io로 이메일을 보내 저와 통화를 나누고 싶다면 언제든지 연락해주세요. 항상 여러분의 상황과 사용 사례에 대해 배우고 싶어하는 마음으로 통화에 참여할 준비를 하고 있어요 ^.^\n\n\n\nZsolt Varga는 12,000개 이상의 기업에서 사용되는 Google에서 추천하는 소프트웨어 도구 Prerender의 총괄 매니저입니다. 이 도구는 검색 엔진이 JavaScript 웹사이트를 더 잘 크롤링하고 인덱싱할 수 있도록 합니다.\n\n# Level Up 코딩\n\nLevel Up은 매달 3백만명의 개발자 커뮤니티입니다. 더 많은 정보를 원하거나 스타트업 인터뷰를 읽으려면 팔로우해주세요. 우리는 최고의 스타트업과 가장 혁신적인 기술 기업과 함께 일하고 있어요.🔥\n\n- 개발자이신가요? 최고의 기업들이 여러분을 고용하도록 요청하세요\n➡️ Level Up Talent Collective에 가입하기\r\n- ➡️ FAANG 수준의 엔지니어 고용하기\r\n- ➡️ 인터뷰 요청서를 제출하여 귀사를 인터뷰 받을 수 있도록 하세요\n\n\n\n우리는 개발자들의 경력 성장을 돕기 위한 무료 도구도 제공해요: 코딩 인터뷰 코스, 자동 이력서 빌더, 포트폴리오 API\n\n우리를 팔로우해요: Twitter | LinkedIn | Newsletter","ogImage":{"url":"/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_0.png"},"coverImage":"/assets/img/2024-05-14-Howwereducedourannualservercostsby80from1Mto200kbymovingawayfromAWS_0.png","tag":["Tech"],"readingTime":9},{"title":"TypeScript 인덱스 시그니처에 대한 설명","description":"","date":"2024-05-14 12:59","slug":"2024-05-14-TypeScriptIndexSignatureExplained","content":"\n\n<img src=\"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png\" />\n\nTypeScript의 인덱스 시그니처는 객체의 속성이 미리 알려지지 않았지만 속성의 유형이 알려진 경우 동적 데이터 구조를 정의하는 방법을 제공합니다. 이들은 동적 속성 액세스를 허용하며 키의 변수 집합을 가진 객체와 작업할 때 특히 유용합니다.\n\n이 게시물에서는 인덱스 시그니처에 대해 자세히 알아보고, TypeScript에서 사용하는 방법 및 사용 시기에 대해 설명할 것입니다.\n\n## 인덱스 시그니처란 무엇인가요?\n\n\n\n인덱스 시그니처는 대괄호 []와 키에 대한 유형, 콜론 및 해당 값에 대한 유형을 사용하여 정의됩니다. 이를 통해 TypeScript는 객체의 예상 구조를 이해하고 강제할 수 있게 됩니다.\n\n```js\ninterface MyStats {\n  [key: string]: number;\n}\nconst scores: MyStats = {\n  total: 50,\n  average:80\n}\n// 인덱스 시그니처는 유형 제약을 강제합니다\n// 여기서 값은 반드시 숫자여야 합니다\nconst scores2: MyStats = {\n  total: \"50\", // 'string' 유형은 'number' 유형에 할당할 수 없습니다.(2322)\n  average: 80\n}\n```\n\n이 예에서 MyStats는 어떤 문자열 키도 가질 수 있고, 해당 키와 연관된 값은 반드시 숫자형이어야 합니다.\n\n인덱스 시그니처의 구문은 인터페이스나 유형 선언 내에서 [] 표기법을 사용하는 것을 포함합니다. 아래 예시는 인터페이스와 유형에 대한 동일한 인덱스 시그니처를 보여줍니다.\n\n\n\n\n인덱스 시그니처는 다양한 키 유형을 사용할 수 있으며 연관 값 유형은 유효한 TypeScript 유형일 수 있음에 유의하세요.\n\n## 인덱스 시그니처를 명시적 멤버와 섞어 사용하기\n\nTypeScript에서 인덱스 시그니처를 명시적 멤버 선언과 혼합할 수 있습니다. 알려진 및 동적 속성을 조합해야 하는 경우에 유용합니다.\n\n\n\n\n```js\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자;\n  가격: 숫자;\n}\n```\n\n인덱스 시그니처와 명시적 멤버를 섞을 때는 모든 명시적 멤버가 인덱스 시그니처 유형을 준수해야 합니다.\n\n```js\n// 유효하지 않은 경우\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자;\n  가격: 숫자;\n  모델: 문자열; // 오류: '모델' 속성의 '문자열' 유형은 '숫자' 인덱스 유형에 할당할 수 없습니다.\n}\n\n// 유효한 경우\n인터페이스 자동차구성 {\n  [기능: 문자열]: 숫자 | 문자열;\n  가격: 숫자;\n  모델: 문자열;\n}\n```\n\n## 읽기 전용 인덱스 시그니처\n\n\n\n인덱스 시그니처는 읽기 전용 수정자를 지원합니다. 읽기 전용 수정자를 적용하면 객체 내의 속성이 변경 불가능해집니다.\n\n```js\ninterface Car {\n  readonly [key: string]: boolean;\n}\n\nconst toyota: Car = {hybrid: true, luxury: false};\ntoyota.hybrid = false; //에러: 'Car' 타입의 인덱스 시그니처는 오직 읽기만 허용됩니다.(2542)\n```\n\n위 예시에서 'hybrid' 속성을 수정하려고 하면 오류가 발생합니다. 왜냐하면 인터페이스가 읽기만 허용하기 때문이죠.\n\n## 인덱스 시그니처 사용 방법\n\n\n\n실제로 인덱스 시그니처가 어떻게 사용될 수 있는지에 대한 실제 예시를 살펴봅시다. 여러 기능을 포함하는 웹 애플리케이션을 개발하고 있다고 상상해보세요. 각 기능은 해당하는 설정을 가지고 있으며, 이를 활성화하거나 비활성화할 수도 있습니다.\n\n```js\ninterface FeatureConfig {\n  [feature: string]: {\n    enabled: boolean;\n    settings: Record<string, boolean>;\n  }\n}\n```\n\n이 예시에서는 FeatureConfig라는 인터페이스를 정의합니다. 이 인터페이스는 문자열 타입의 동적 속성 이름을 허용하도록 인덱스 시그니처를 사용하며, 해당 속성과 설정 객체와 연결된 enabled 불리언 속성이 포함되어 있습니다. 동적 기능 이름과 관련된 설정을 나타내는 데 유용합니다. 예를 들어, 다음과 같은 객체에 이 인터페이스를 적용할 수 있습니다.\n\n```js\nconst features: FeatureConfig = {\n  profile: {\n    enabled: true,\n    settings: {\n      showPhoto: true,\n      allowEdit: false,\n    },\n  },\n  notification: {\n    enabled: false,\n    settings: {\n      richText: true,\n      batchMode: true\n    },\n  }\n};\n```\n\n\n\n기능 객체에서는 기능 이름이 달라질 수 있지만, 각 기능의 구조는 일관적으로 유지됩니다. 각 기능은 활성화된 부울 값과 설정 객체가 있어야 합니다.\n\n위 인터페이스에서 기능 이름에 유니언 타입 제약을 적용할 수 있을까요?\n\n만약 애플리케이션에서 사용하는 기능 집합이 알려져 있다면, 문자열 리터럴의 유니언인 FeatureType을 정의할 수 있습니다.\n\n```js\ntype FeatureType = '프로필' | '알림' | '리포팅';\n```\n\n\n\n색인 시그니처 키는 유니언 타입을 지원하지 않지만, 맵드 타입을 사용하여 해결할 수 있습니다.\n\n```js\ntype FeatureConfig2 = {\n  [feature in FeatureType]: {\n    enabled: boolean;\n    settings: Record<string, boolean>;\n  }\n}\n```\n\n[feature in FeatureType]는 유니온 타입 FeatureType(프로필, 알림 및 보고서를 포함)의 각 문자열 리터럴을 반복하는 맵드 타입이며, 각 값을 결과 타입의 속성 이름으로 사용합니다.\n\n다음은 사용 예시입니다:\n\n\n\n```js\nconst allFeatures: FeatureConfig2 = {\n   profile: {\n      enabled: true,\n      settings: {\n         showPhoto: true,\n         allowEdit: false,\n      },\n   },\n   notification: {\n      enabled: false,\n      settings: {\n         richText: true,\n         batchMode: true\n      },\n   },\n   reporting: {\n      enabled: true,\n      settings: {\n         template: false,\n         advanceExport: true\n      },\n   },\n};\n```\n\n모든 기능이 FeatureType에 정의된 모든 기능과 일치해야 합니다.\n\n만약 일부 기능을 허용하려면 색인 서명 유형을 \"?\"를 선택적 플래그로 하는 형태로 수정해야 합니다. 그런 다음, FeatureConfig2 유형을 사용하여 일부 기능만 포함하는 객체를 만들 수 있습니다.\n\n```js\ntype FeatureType = 'profile' | 'notification' | 'reporting';\n\ntype FeatureConfig2 = {\n  [feature in FeatureType]?: {\n    enabled: boolean;\n    settings: Record<string, boolean>;\n  }\n}\n\nconst subsetFeatures: FeatureConfig2 = {\n   profile: {\n      enabled: true,\n      settings: {\n         showPhoto: true,\n         allowEdit: false\n      },\n   }\n};\n```\n\n\n\n## 인덱스 시그니처를 효과적으로 사용하는 방법\n\n일반적으로 사용되는 시나리오에는 다음이 포함됩니다:\n\n- 설정 객체: 위 예제에서 보듯, 인덱스 시그니처는 설정 객체가 동적 키와 관련 값이 있을 수 있는 시나리오에서 뛰어난 성능을 발휘합니다.\n- 데이터 변환: 데이터 변환이나 구문 분석을 다룰 때 인덱스 시그니처는 유용할 수 있습니다. 입력 데이터의 구조가 다양한 경우 유연하게 처리할 수 있습니다.\n- 확장성: 플러그인 아키텍처나 모듈식 시스템과 같이 확장성이 중요한 프로젝트에서는 새 구성 요소를 추가할 때 기존 코드를 수정하지 않고 인덱스 시그니처를 이용할 수 있습니다.\n\n인덱스 시그니처는 강력하지만 남용해서는 안 됩니다. 인덱스 시그니처를 구현하기 전에 데이터 구조를 더 명시적인 인터페이스나 타입 정의로 대체할 수 있는지 고려해야 합니다, 특히 키가 특정 의미를 가질 때입니다.\n\n\n\n다른 고려 사항은 인덱스 시그니처를 엄격하게 테스트하는 것입니다. 이는 동적 구조의 특성이 예기치 못한 문제를 발생시키지 않도록 다양한 키-값 조합을 테스트하여 확인하는 것을 포함합니다.\n\n흔한 실수를 피하고 최선의 방법을 따르면 TypeScript 코드를 더 유연하고 탄력적으로 만드는 데 인덱스 시그니처를 사용할 수 있습니다.\n\n즐거운 프로그래밍 되세요!","ogImage":{"url":"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png"},"coverImage":"/assets/img/2024-05-14-TypeScriptIndexSignatureExplained_0.png","tag":["Tech"],"readingTime":5},{"title":"JavaScript에서 웹 브라우저가 접근 불가능할 때 카운터 상태를 유지하는 가장 쉬운 방법localStorage에서 재생성","description":"","date":"2024-05-14 12:58","slug":"2024-05-14-TheeasiestwaytokeepcounterstateafterwebbroswerisnotaccessiblerehydrateitfromlocalStorageinJavaScript","content":"\n\n최근 QA 팀에서 흥미로운 질문을 받았어요. 그 질문은, 왜 우리 이메일 토큰 카운터가 그들이 컴퓨터를 절전 상태로 변경할 때 멈추는지였어요? 처음에는 웹 브라우저가 실행 중이 아니면 우리의 JavaScript 애플리케이션이 작동하지 않는다는 일반적인 가정을 공유했어요. 하지만 그들의 우려는 사용자가 시간을 조작하여 이메일로 토큰을 다시 보낼 수 있는 보안 문제로 유효한 지점을 제기했어요.\n\n아래는 문제가 된 기능인데요, 시작시간이 5분이고 토큰이 만료될 때까지 0으로 감소하는 간단한 카운터였어요. 중요한 점은 모든 논리가 백엔드에서 처리되었고, 프론트엔드는 단순히 카운터의 시각적인 표현을 담당했다는 것이었어요.\n\n팀원 중 한 명이 작성한 카운터 코드의 간단한 부분이에요:\n\n\n\n```js\nclass TimeCounter {\n    minutes = null\n    seconds = null\n    dateStored = null\n    minutesStored = null\n    secondsStored = null\n\n    constructor(minutes = 0, seconds = 0) {\n        this.minutes = minutes\n        this.seconds = seconds\n    }\n\n    start() {\n        this.saveTimer()\n        this.timer = setInterval(() => {\n            this.callback()\n        }, 1000)\n    }\n\n    stop() {\n        clearInterval(this.timer)\n    }\n\n    callback() {\n        if(this.minutes === 0 && this.seconds === 0) {\n            this.stop() // Stop counter\n            return\n        }\n\n        if (this.seconds === 0) {\n            this.seconds = 59\n            this.minutes--\n        } else {\n            this.seconds--\n        }\n    }\n}\n```\n\n문제점\n\n사용자가 컴퓨터를 절전하여 카운터를 중지할 수 있습니다. 다시 작동시킬 때 타이머는 중단한 지점부터 다시 시작하여 사용자가 토큰 유효기간을 효과적으로 연장할 수 있습니다.\n\n해결책 — 로컬스토리지```\n\n\n\n이 문제에 대처하기 위해 LocalStorage를 활용한 해결책을 구현했습니다. 콜백 메서드가 호출될 때마다 현재 분, 초, 타임스탬프를 저장했습니다. 이 타임스탬프를 현재 시간과 비교하여 어떤 차이가 있는지 감지하여 토큰 만료 로직이 유지되도록 했습니다.\n\n![이미지](/assets/img/2024-05-14-TheeasiestwaytokeepcounterstateafterwebbroswerisnotaccessiblerehydrateitfromlocalStorageinJavaScript_1.png)\n\n이제 해결책을 적용한 코드입니다:\n\n```js\nclass TimeCounter {\n    minutes = null\n    seconds = null\n    dateStored = null\n    minutesStored = null\n    secondsStored = null\n\n    constructor(minutes = 0, seconds = 0) {\n        this.minutes = minutes\n        this.seconds = seconds\n    }\n\n    start() {\n        this.saveTimer()\n        this.timer = setInterval(() => {\n            this.callback()\n        }, 1000)\n    }\n\n    stop() {\n        clearInterval(this.timer)\n    }\n\n    saveTimer() {\n        const timeElapsed = Date.now();\n\n        if (timeElapsed != 0) {\n            localStorage.setItem('dateStored', timeElapsed)\n            localStorage.setItem('minutes', this.minutes)\n            localStorage.setItem('seconds', this.seconds)\n        }\n    }\n\n    getTimer() {\n        this.dateStored = Number(localStorage.getItem('dateStored'))\n        this.minutesStored = Number(localStorage.getItem('minutes')) \n        this.secondsStored = Number(localStorage.getItem('seconds'))   \n    }\n\n    checkDifference() {\n        this.getTimer()\n\n        const nowElapsed = Date.now();\n        const diff = nowElapsed - this.dateStored\n        \n        // check if time is 5 seconds late compared to stored\n        if (diff > 5000) {\n            this.setCurrentTimer(diff)\n        }\n    }\n\n    setCurrentTimer(diff) {\n        const elapsedStored = (this.minutesStored * 60000) + (this.secondsStored * 1000)\n        const currentTimeLeft = elapsedStored - diff\n        const now = new Date(currentTimeLeft)\n        const minutes = now.getMinutes()\n        const seconds = now.getSeconds()\n\n        if (minutes > tokenTimersEnum.VALIDATION_MINUTES) {\n            this.minutes = 0\n            this.seconds = 0\n        } else {\n            this.minutes = minutes\n            this.seconds = seconds\n        }\n    }\n\n\n    callback() {\n        this.checkDifference()\n\n        if(this.minutes === 0 && this.seconds === 0) {\n            this.stop()\n            return\n        }\n\n        if (this.seconds === 0) {\n            this.seconds = 59\n            this.minutes--\n        } else {\n            this.seconds--\n        }\n        \n        this.saveTimer()\n    }\n}\n```\n\n\n\n요약\n\nLocalStorage는 사용자 브라우저 내에서 데이터를 지속시키는 데 유용한 도구로 입증되었습니다. 이를 활용함으로써 토큰 만료 메커니즘의 무결성을 유지할 수 있었고, 시간을 조작하려는 사용자의 시도가 있더라도 문제없이 작동했습니다.\n\n프론트엔드 처리나 동작이 중요한 유사한 상황에서는 LocalStorage 솔루션을 고려하는 것이 유익할 수 있으며, 원활하고 안전한 사용자 경험을 보장할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-TheeasiestwaytokeepcounterstateafterwebbroswerisnotaccessiblerehydrateitfromlocalStorageinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-TheeasiestwaytokeepcounterstateafterwebbroswerisnotaccessiblerehydrateitfromlocalStorageinJavaScript_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular에서의 코드 스멜  심층 분석  Part II","description":"","date":"2024-05-14 12:56","slug":"2024-05-14-CodesmellsinAngularDeepDivePartII","content":"\n\n내 최근 블로그 게시물 중 하나에서 런타임 성능과 관련한 상위 5개 코드 스멜에 대해 깊이 파고들었습니다. 이번에는 프로젝트의 유지 관리성과 관련된 코드 스멜에 대해 더 많은 이야기를 나누고 싶습니다. 이 내용은 이전 블로그 게시물 [1]에 명시되어 있어요.\n\n하지만, 하나의 코드 스멜을 추가하고 싶은데요, 바로 모듈 경계와 DRY 원칙입니다. 왜 이것을 추가하려고 하는 걸까요? 여러 달 동안 DRY 원칙이 제대로 이해되지 않았다는 것을 알게 되었기 때문에, 이 주제에 대해 더 내용을 발전시키고자 합니다.\n\n![이미지](/assets/img/2024-05-14-CodesmellsinAngularDeepDivePartII_0.png)\n\n## 1a. 모듈 경계와 DRY 원칙\n\n\n\n이전 블로그 게시물 중 하나에서 프론트엔드에 DDD 개념을 추가하는 것을 제안했습니다. 이는 프로젝트를 쉽게 유지보수할 수 있도록 도와줄 것입니다 [2]. 다음 다이어그램은 예약 및 오퍼 서브도메인 뿐만 아니라 공유 도메인을 보여줍니다.\n\n이 방식의 큰 장점은 무엇일까요?\n\n- 모듈 경계를 쉽게 정의할 수 있음\n- 모듈 간 느슨한 결합\n- 구성 요소 및/또는 모델을 공유하기 위한 명시적 API\n\n![다이어그램](/assets/img/2024-05-14-CodesmellsinAngularDeepDivePartII_1.png)\n\n\n\n하지만 더 중요한 것이 하나 더 있어요. 바로 DRY 원리에 관한 것인데요. DRY 원리는 코드를 중복해서 작성하지 말고 재사용해야 한다는 원칙을 말해요. 실제로 각 하위 도메인 안에서도 그렇게 되어 있어요. 즉, 예약 부분에서는 코드를 중복해서 작성하면 안 돼요. 그렇다면 해당 부분을 예약 하위 도메인 안에 공유 모듈로 이동해 주세요.\n\n하지만 이는 두 개의 하위 도메인 사이에 중복된 코드가 없어야 한다는 것을 의미하는 건 아니에요. 사실 유지보수성을 고려하면 모델이나 컴포넌트를 중복해서 작성하는 것이 오히려 합리적일 수도 있어요. 그 이유는 하위 도메인 간의 느슨한 결합을 보장하고 싶기 때문이에요.\n\n계층 구조에도 동일한 원리가 적용돼요. 모듈 간에 강하게 결합되어 있다면 이를 제거하려 노력해야 하며, 이를 위해서 코드를 중복해야 하는 경우라도 꺼려서는 안 돼요.\n\n그래서 프론트엔드 아키텍처와 모듈 경계는 어떤 프로젝트의 유지보수성에 큰 영향을 미친답니다. 프론트엔드에 DDD 개념을 적용할 필요는 없지만 모듈 간의 느슨한 결합을 유지하려 노력하는 것이 중요하답니다.\n\n\n\n## 1b. Imports 처리 - 모듈 해결 없음\n\n자주 볼 수있는 코드 스멜 중 하나는 모듈 해결이 없다는 것입니다. 왜 코드 스멜인가요? 모듈 해결이 없으면 import 경로에 매우 강하게 결합되어 있습니다. 경로가 변경되면 import도 변경해야 합니다. 우리가 원하는 행동은 아닙니다.\n\n```js\nimport {Offers} from '../../../offers/models/offers.model';\nimport {Receipt} from '../../../booking/models/receipt.model';\nimport {StringUtils} from '../../shared/utils/string.utils';\n```\n\n각 디렉토리에 대한 배럴 파일을 도입하여 이러한 import에 어떤 영향을 미치는지 살펴봅시다.\n\n\n\n```js\nimport {Offers} from '../../../offers/models';\nimport {Receipt} from '../../../booking/models';\nimport {StringUtils} from '../../shared/utils';\n```\n\n위의 해결책은 개선되었지만 여전히 상대 경로 대신 절대 경로를 사용합니다. 수동으로 변경할 수 있지만 꽤 귀찮고 시간이 오래 걸립니다. 그래서 모듈 해결책을 소개해보겠습니다.\n\n다음 코드 스니펫을 tsconfig.json 파일에 추가합니다.\n\n```js\n\"compilerOptions\": {\n   ...\n   \"paths\": {\n       \"@offers/*\": [\"/src/app/offers/*\"],\n       \"@booking/*\": [\"/src/app/booking/*\"],\n       \"@shared/*\": [\"/src/app/shared/*\"],\n   }\n   ...\n}\n```\n\n\n\n지금부터는 기존 컴포넌트 내에서 imports를 간소화하기 위해 알림을 받게 될 것입니다. 그리고 모든 새로운 imports는 자동으로 새로운 모듈 해상도를 사용하게 됩니다.\n\n```js\nimport {Offers} from '@offers/models';\nimport {Receipt} from '@booking/models';\nimport {StringUtils} from '@shared/utils';\n```\n\n## 2. 컴포넌트 내에서의 다중 책임\n\n지금까지 접했던 또 다른 코드 냄새는 컴포넌트 내에서의 다중 책임입니다. 이는 단일 책임 원칙(SRP)과 충돌될 수 있습니다. SRP는 컴포넌트가 한 가지 일을 잘 처리해야 하지만 여러 가지 역할을 해서는 안 된다는 것을 명시합니다.\n\n\n\n예시를 살펴보겠습니다. 다음 코드 조각은 예약을 검색하는 구성 요소를 보여줍니다. 그러나 더 자세히 살펴보면 이 구성 요소는 오퍼를 추가할 수 있는 기능도 제공합니다. 오퍼와 예약은 서로 다른 것이며(두 개의 서로 다른 서브도메인이기도 합니다), 하나의 구성 요소에서 다루어지면 안됩니다.\n\n```js\nexport class SearchBookingComponent implements OnInit {\n\n  bookings: Booking[];\n  searchControl = new UntypedFormControl();\n  filteredBookings$: Observable<Booking[]>;\n\n  constructor(private bookingService: BookingService,\n              private offerService: OfferService) {\n    bookingService.getAll()\n      .pipe(first())\n      .subscribe((bookings) => {\n        this.bookings = bookings;\n      });\n  }\n\n  ngOnInit() {\n    this.filteredBookings$ = this.searchControl.valueChanges.pipe(\n      switchMap((searchText) => this.bookingService.search(searchText)),\n      startWith(this.bookings)\n    );\n  }\n\n  bookOffer(offer: Offer) {\n    this.offerService.bookOffer(offer);\n  }\n}\n```\n\n또 다른 예시는 구성 요소 템플릿이 너무 복잡하다는 것입니다. 다음 코드 조각은 검색 입력 필드나 예약 목록 항목 뿐만 아니라 정보 대화상자까지 포함되어 있음을 보여줍니다.\n\n```js\n<form autocomplete=\"off\" class=\"form-container\">\n  <div class=\"form-content\">\n    <h2 mat-subheader>Search bookings</h2>\n    <div class=\"pl-3 pr-3\">\n      <mat-form-field>\n        <input matInput [formControl]=\"searchControl\" placeholder=\"Searching\">\n        <mat-icon matSuffix>search</mat-icon>\n      </mat-form-field>\n    </div>\n    <mat-list>\n      <section class=\"scroll-container\">\n        <ng-container>\n          <ng-container *ngFor=\"let booking of (filteredBookings$ | async)\">\n            <mat-list-item>\n              <h4 mat-line>{booking?.header}</h4>\n              <p mat-line>{booking?.content} </p>\n              <button\n                      type=\"button\"\n                      mat-icon-button\n                      (click)=\"showBookingDetailsAction.emit()\">\n                <mat-icon aria-label=\"Side nav toggle icon\">info</mat-icon>\n              </button>\n              <button\n                      type=\"button\"\n                      mat-icon-button\n                      (click)=\"bookOfferAction.emit()\">\n                <mat-icon aria-label=\"Side nav toggle icon\">add_shopping_cart</mat-icon>\n              </button>\n              <ng-content></ng-content>\n            </mat-list-item>\n          </ng-container>\n        </ng-container>\n      </section>\n      <section class=\"info-dialog\" *ngIf=\"(dialogVisible$ | async)\">\n        <button type=\"button\" mat-button.mat-small class=\"button-dismiss\"\n            (click)=\"close.next(true)\"><i class=\"fal fa-times\"></i>\n        </button>\n        <h1 mat-dialog-title><b>{ title }</b></h1>\n        <div mat-dialog-content>\n          <div class=\"font-settings\" [innerHTML]=\"infos\"></div>\n        </div>\n        <div mat-dialog-actions class=\"flex-content-end\">\n          <button type=\"button\" mat-raised-button\n                  (click)=\"close.next(true)\">Close\n          </button>\n        </div>\n      </section>\n    </mat-list>\n  </div>\n</form>\n```\n\n\n\n첫 번째 개선 사항은 info-dialog을 별도의 컴포넌트로 이동하는 것입니다. 그러나 이것이 우리가 해야 할 유일한 개선 사항일까요? 아니요, 아닙니다. 단일 컴포넌트는 가능한 적은 사용자 상호 작용(또는 사용 사례)을 가져야 합니다.\n\n사용 사례는 무엇인가요?\n\n- 예약 검색\n- 예약을 장바구니에 추가\n- 예약 정보 표시\n\n따라서 예약 목록 항목 컴포넌트도 도입할 것입니다.\n\n\n\n## 3. 서비스 내 유틸리티 기능\n\n테스트 작성은 정말 힘들 수 있어요. 시간이 지날수록 서비스와 컴포넌트는 복잡해지는 경향이 있어요. 그래서 매번 컴포넌트 및 서비스 테스트를 조정해야 해요. 거의 항상 추가해야 하는 종속성 때문이죠.\n\n그래서 나는 언제나 비즈니스 로직을 서비스나 컴포넌트가 아닌 유틸 클래스로 옮길 거예요. 먼저, 유틸은 테스트하기가 훨씬 쉽고, 둘째로, 각 서브도메인의 비즈니스 로직을 단일 파일에 두고 싶어요. 전체 서브도메인을 훑어가며 비즈니스 로직을 찾지 않길 원하거든요.\n\n```typescript\nexport class BookingUtil {\n\n    public static isBookingSold(status: BookingStatus): boolean {\n        return [\n            bookingStatus.Reserved,\n            bookingStatus.WaitingForCustomer,\n            bookingStatus.Sold\n        ].includes(status);\n    }\n\n    public static isBookingCancelable(status: BookingStatus, alterationType: BookingAlterationType): boolean {\n        return (\n            [\n             bookingStatus.WaitingForCustomer\n            ].includes(status) &&\n            [\n             bookingAlterationType.Cancelable,\n             bookingAlterationType.CancelableOnWaiting\n            ].includes(alterationType)\n        );\n    }\n\n    public static getNextBookingNumber(bookings: Booking[]): number {\n        const bookingNumbers = bookings\n                    .filter((booking) => isNotEmpty(booking.bookingNumber))\n                    .map((booking) => booking.bookingNumber));\n        \n        return Math.max(...bookingNumbers);\n    }\n\n    public static mergeBookings(firstBooking, secondBooking): number {\n        ...\n    } \n}\n```\n\n\n\n## 4. 중첩된 구독\n\n다음으로 지적하고 싶은 코드 스멜은 중첩된 구독입니다. 중첩된 구독은 필요 이상으로 코드 라인이 더 많을 뿐만 아니라 원하지 않는 부작용을 일으킬 수도 있습니다.\n\n예를 들어, 다음 코드 조각을 살펴보겠습니다. 검색 입력 필드의 텍스트가 변경될 때마다 HTTP 요청이 생성됩니다. 그러나 사용자가 문자를 추가할 때마다 HTTP 요청이 한 번만 실행되지 않고 여러 번 실행될 수 있습니다. 왜냐하면 두 번째 구독이 닫히지 않았기 때문입니다.\n\n```js\nconst filteredBookings$ = new BehaviorSubject<Booking[]>([]);\nthis.searchControl.valueChanges.pipe(takeUntil(this.destroy$))\n     .subscribe((text) => {\n          this.bookingService.search(text).pipe(takeUntil(this.destroy$))\n              .subscribe((bookings) => {\n                  this.filteredBookings$.next(bookings);\n              });\n      });\n```\n\n\n\n이건 쉽게 수정할 수 있어요. takeUntil(this.destroy$)을 first()로 교체하면 됩니다. 하지만 여전히 많은 코드가 남아 있네요.\n\n```js\nconst filteredBookings$ = new BehaviorSubject<Booking[]>([]);\nthis.searchControl.valueChanges.pipe(takeUntil(this.destroy$))\n     .subscribe((text) => {\n          this.bookingService.search(text).pipe(first())\n              .subscribe((bookings) => {\n                  this.filteredBookings$.next(bookings);\n              });\n      });\n```\n\n그래서 아래와 같이 코드를 간소화할 거예요. 이제 훨씬 깔끔하고 유지보수가 쉬워졌어요.\n\n```js\nconst filteredBookings$ = this.searchControl.valueChanges.pipe(\n  switchMap(text => this.bookingService.search(text))\n)\n```\n\n\n\n다음 예시는 ngOnInit에서 사용할 수 없는 ViewChild입니다. 그러므로 BehaviorSubject를 사용하는 setter를 추가하여 PdfViewerComponent의 초기화에 대해 쉽게 알림을 받을 수 있습니다.\n\n```js\n@ViewChild('viewer')\nset viewer(viewer: PdfViewerComponent | undefined) {\n    this.viewer$.next(viewer);\n}\n```\n\n이제 PdfViewerComponent에 의해 트리거된 모든 텍스트 선택 변경 사항에 구독하려고 합니다. 첫 번째 해결 방법은 다음과 같을 수 있습니다. 그러나 PdfViewer의 첫 번째 유효한 값만 필요하고 그 후에 변경 사항에 구독하려고 합니다. 중첩된 구독 없이 또는 그렇지 않을까요? \n\n```js\nconst ranges$ = new BehaviorSubject<Range[]>([]);\nthis.pdfViewer$.pipe(filter((viewer) => viewer != null), takeUntil(this.destroy$))\n     .subscribe((viewer) => {\n        this.textSelectionDestroy$.next();\n        viewer?.textSelection.pipe(takeUntil(this.textSelectionDestroy$))\n              .subscribe((ranges) => {\n                  ranges$.next(ranges);\n              });\n});\n```\n\n\n\n물론, 이 문제에 대한 해결책이 있어요. 다음 코드를 살펴봐요. 하지만 잠시만요, 실수가 있네요. 모든 텍스트 선택 변경에 대해 알림을 받지 않고 첫 번째 변경에 대해서만 알게 될 거예요.\n\n```js\nconst ranges$ = this.pdfViewer$.pipe(\n      filter((viewer): viewer is NonNullable<PdfViewerComponent> => viewer != null),\n      switchMap((viewer) => viewer.textSelection$)\n);\n```\n\n오, 네 맞아요. 첫 번째 observable에서 구독을 취소해야 해요. `first()`를 추가해야 해요. 이제 코드가 잘 작동해요.\n\n```js\nconst ranges$ = this.pdfViewer$.pipe(\n      filter((viewer): viewer is NonNullable<PdfViewerComponent> => viewer != null),\n      first(),\n      switchMap((viewer) => viewer.textSelection$)\n);\n```\n\n\n\n## 5. Mutable 대신 immutable을 사용하세요\n\n객체나 배열을 직접 수정할 필요가 없습니다. 성능상의 이유일 때만 예외적으로 배열 조작을 직접 할 수 있습니다. 그 외에는 항상 immutable을 유지하는 것을 권장합니다.\n\n```js\narray.sort(...)   =>  array.slice().sort(...)\narray.splice(...) =>  [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)] \nobj.test = \"123\"  =>  obj = {...obj, test: \"123\"} \n\nObject.assign(obj, {test: \"123\"})  =>  obj = {...obj, test: \"123\"};\n \narray.push(...)   =>  array = array.concat(...)\ndelete obj.test   =>  const {test, ...objWithoutTest} = obj;\n```\n\nAngular에서 왜 이것이 중요한가요?\n\n\n\n만약 전에 작성한 블로그 포스트 [1] (코드 스멜의 첫 번째 부분)를 읽었다면, ChangeDetection 및 OnPush-Strategy에 익숙할 것입니다. 이는 뷰가 개체를 조작해도 다시 렌더링되지 않지만, 개체 참조가 변경되면 다시 렌더링됨을 의미합니다.\n\n따라서 우리는 불변해야 합니다. 이는 구성 요소뿐만 아니라 순수 파이프에도 적용됩니다. 순수 파이프는 입력 참조가 변경된 경우에만 변환 기능을 트리거합니다.\n\n# 요약\n\n지금까지 경험한 상위 5가지 코드 스멜에 대해 심층적으로 살펴보았습니다. 따라서 모듈 해결 방법을 사용하고, 불변성을 유지하며, 중첩된 구독을 피하고, 비즈니스 로직을 단일 테스트 가능한 파일로 이동시키고, 구성 요소에 여러 책임을 부여하지 않도록 주의해주시기 바랍니다.\n\n\n\n## 링크\n\n- [1] [여기](https://medium.com/@robert.maiersilldorff/code-smells-in-angular-deep-dive-part-i-d63dd5f5215e)\n- [2] [여기](https://blog.bitsrc.io/clean-frontend-architecture-2995c68702fb)","ogImage":{"url":"/assets/img/2024-05-14-CodesmellsinAngularDeepDivePartII_0.png"},"coverImage":"/assets/img/2024-05-14-CodesmellsinAngularDeepDivePartII_0.png","tag":["Tech"],"readingTime":11},{"title":"오프라인 사용 가능한 웹 애플리케이션 개발하기","description":"","date":"2024-05-14 12:54","slug":"2024-05-14-DevelopingOffline-ReadyWebApplications","content":"\n\n![IMG](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png)\n\n네, 제목을 제대로 읽으셨어요. 대부분의 웹 애플리케이션에서는 네트워크 접근이 가능할 것이라는 내제적인 가정이 있습니다. 사이트가 서버 측 렌더링, 정적 생성 또는 브라우저를 통해 완전히 작성되었는지에 상관없이 HTML, CSS 및 JS는 네트워크를 통해 HTTP 요청을 통해 가져옵니다. 각 페이지가 로드될 때 추가 리소스를 가져오거나 타사 API와 통신할 수 있습니다. 네트워크 탭을 빠르게 살펴보면 사이트가 대화형임을 알 수 있습니다. Google Analytics 이벤트부터 Stripe 위젯, 버그 추적 소프트웨어까지, 단일 페이지가 사용자 입력 없이도 계속 네트워크에 액세스할 수 있습니다. 기본적인 가정에 도전했을 때 어떻게 해야 할까요? 네트워크가 사용할 수 없을 때 웹 개발자로서 사용자에게 어떻게 서비스를 제공할 수 있을까요?\n\n# Service Workers - 오프라인 문제에 대한 해답\n\n이 문제를 해결하기 위해 Google, Samsung, Mozilla 및 기타 회사들이 협력하여 2014년 5월에 서비스 워커의 W3C 초안을 처음 소개했습니다. 그 전에 기본적인 웹 워커를 살펴보겠습니다 - 주 프로그램의 “백그라운드\"에서 실행되는 JavaScript 파일입니다. 웹 워커는 자체 스레드를 가지고 있지만 주 JavaScript 스레드와 계속 통신할 수 있습니다. 이 별도의 스레드를 통해 주 프로그램의 코드 실행을 차단하지 않으면서 백그라운드에서 계산적으로 비용이 많이 드는 작업을 수행할 수 있으므로 사용자 경험을 방해하지 않습니다. 웹 워커는 현재 창과는 별개의 컨텍스트에서 실행되며 DOM이나 창 객체에 액세스할 수 없습니다.\n\n\n\n## 서비스 워커란\n\n서비스 워커는 귀하의 사이트와 제삼자 간에 프록시처럼 작동하는 전문화된 웹 워커입니다. 요청이 서비스 워커에 의해 가로채지며 응답은 그를 통해 라우팅됩니다. 서비스 워커는 원본과 경로 또는 패턴(URL의)에 바인딩되어 해당 원본에서 발생하는 이벤트(예: fetch)에 응답합니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_1.png)\n\n이 경로 또는 패턴은 서비스 워커의 범위와 관련이 있으며 등록된 경로 및 해당 경로 내의 모든 중첩된 경로를 포함합니다. 서비스 워커가 mysite.com/puppies/sw.js에서 등록된 경우 mysite.com/puppies/labs 및 mysite.com/puppies/boxers에 대해 작동합니다. 이는 서비스 워커가 실행되는 범위이며 한 범위에는 하나의 서비스 워커만 등록될 수 있습니다. 그러나 선택적으로 이 기본 범위를 좁힐 수 있습니다.\n\n\n\n웹 워커들과는 다르게, 서비스 워커들은 시간 제한이 있어서 밀리초 단위로 생성되어 작업을 수행한 뒤 소멸될 수 있습니다. 이러한 의도적으로 짧은 수명은 스크립트 내에서 전역 상태에 의존하는 것을 불가능하게 만듭니다. 대신, 이들은 브라우저의 IndexedDB나 캐시 API에 기본 액세스 권한을 부여받아 데이터를 저장하고 검색할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_2.png)\n\n서비스 워커는 보완 기능으로서, 비공식 브라우저에서도 여전히 사이트의 모든 콘텐츠에 액세스할 수 있습니다. 그리고 그 보완 기능은 광범위합니다 — 캐싱, 백그라운드 동기화, 푸시 알림 및 오프라인 기능을 포함합니다.\n\n## 서비스 워커 생명 주기\n\n\n\n서비스 워커에는 라이프사이클이 있어 엔드 사용자의 브라우저와 상호작용하는 방식을 규정합니다. 서비스 워커가 등록되고 설치될 때까지 클라이언트로의 네트워크 흐름을 제어하지 않습니다. 심지어 서비스 워커도 해당 범위로의 다음 탐색으로 들어가기 전까지 요청을 프록시로 전달하지 않습니다.\n\n- 등록 — 이 첫 번째 단계는 사용자가 서비스 워커의 범위 내에서 URL을 입력할 때 발생합니다. 서비스 워커는 브라우저가 지원되는지 확인하고, 그렇다면 등록 함수가 호출되어 스크립트의 URL을 범위에 연결합니다. 대부분의 모던 브라우저에서 애플리케이션 탭의 개발자 도구에서 서비스 워커 등록을 확인할 수 있습니다. 주어진 서비스 워커에 대해 최대 한 번만 발생할 수 있는 단계입니다.\n- 다운로드 — 등록이 성공하면 서비스 워커가 클라이언트 브라우저로 다운로드됩니다. 사용자로부터 권한을 요청하지 않고 백그라운드에서 조용히 진행됩니다. 업데이트 후 다운로드가 진행되면 이전 서비스 워커 코드와 최신으로 다운로드된 코드 간의 바이트 단위 비교가 이루어집니다. 다른 경우 설치가 진행됩니다.\n- 설치 — 새로 다운로드된 서비스 워커 파일이 있으면 설치가 시작됩니다. 범위로 처음으로 서비스 워커가 다운로드된 경우 즉시 활성화됩니다. 업데이트 이후 설치가 발생하면 즉시 활성화되지 않고 대기합니다.\n- 대기 — 이는 업데이트 중에만 발생합니다. 이전 서비스 워커는 클라이언트의 프록시로 계속 작동하며 현재 서비스 워커를 사용하는 웹 페이지가 더 이상 없을 때까지 기다립니다. 그러나 대기 기간을 건너뛰기 위해 특정 함수를 호출함으로써 대기를 우회할 수도 있습니다.\n- 활성화 — 대기 또는 설치 직후에 활성화 이벤트가 발생하며 그 순간 캐시를 정리하거나 다른 작업을 실행할 수 있습니다.\n- 업데이트 — 사용자가 서비스 워커의 범위 내 페이지로 돌아가거나 등록 함수가 호출되거나 이벤트가 발생하지만 지난 24시간 동안 업데이트가 발생하지 않은 경우 업데이트가 발생합니다. 업데이트 중에 단계 2~5가 반복됩니다 (단계 2, 3은 기울임꼴로 표시됨).\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_3.png)\n\n## 서비스 워커가 오프라인 웹 사이트를 가능하게 하는 방법\n\n\n\n서비스 워커는 프록시로 작동합니다. 이 서비스 워커는 fetch 이벤트에 접근을 제공하여 다양한 조건에 따라 애플리케이션의 동작을 변경할 수 있게 해줍니다. 또한 강력한 캐싱 API를 가지고 있습니다.\n\n뉴욕시에 사는 사용자라고 상상해봅시다. 지역 유기농 식품을 판매하는 웹사이트를 둘러보고 지하철에 올라탔더니 신호가 끊겼습니다. 갑자기 고장난 웹페이지가 보입니다. 사이트를 새로고침해봐도 고장나 있습니다. 뒤로 가기 버튼을 눌러봐도 여전히 고장났습니다. 서비스가 없다면 브라우저의 HTTP 요청은 어떤 API에도 전달되지 않습니다. 페이지가 로드되지 않고, 양식이 전송되지 않습니다 — 오프라인 상태입니다. 이런 상황을 우리는 모두가 사용자로서 경험해봤습니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_4.png)\n\n이제 이 웹사이트가 서비스 워커를 활용한다고 상상해봅시다. 이제 지하철에 들어가서도 웹사이트를 계속해서 둘러볼 수 있습니다. 경험은 매끄럽습니다 — 하지만 숨긴 데이터 불일치가 있을 수 있습니다. 양식을 제출해보려고 하면 오프라인임을 알려주고 나중에 다시 시도하라는 메시지가 표시됩니다 (PWA를 통해 연결이 다시 활성화되면 이 양식이 전송될 수 있습니다, 아래 참조). 바 현황을 한번 봐보시면, 맞습니다 — 오프라인입니다. 언제 그런 일이 발생했을까요?\n\n\n\n사용자에게 완벽한 경험이 아니더라도, 고장난 웹페이지보다 훨씬 나은 것입니다. 특히 이는 블로그와 같이 다양한 상호작용이 불필요한 사이트에 이상적입니다. 이는 서비스 워커 캐시를 활용하여 구현됩니다. 네트워크 요청이 전송되면 서비스 워커가 데이터나 페이지를 캐시할 수 있습니다. 네트워크 연결이 끊어진 경우, 캐시로부터 해당 페이지를 제공하여 사용자에게 더욱 편리한 경험을 제공할 수 있습니다.\n\n# 서비스 워커와 PWA\n\n우리는 이미 서비스 워커가 최종 사용자에게 오프라인 접근성을 제공하는 방법을 명확히 알아보았습니다. 그런데, 그 외에도 어떤 일을 할 수 있을까요? 이것은 관련 개념인 점진적 웹 애플리케이션(Progressive Web Applications, PWAs)로 이어집니다.\n\nPWA는 웹 기반 앱이지만 기기에서 네이티브 애플리케이션과 유사한 경험을 제공합니다. 다른 웹사이트와 마찬가지로 기본적인 HTML, CSS, JS로 작성되어 창에 액세스할 수 있고 API에 네트워크 요청을 보낼 수 있습니다. 그러나 다른 웹사이트에는 없는 강력한 기능이 여러 가지 있습니다.\n\n\n\n## PWA를 설치할 수 있습니다\n\n일반 웹사이트와는 달리 PWA는 웹 앱 매니페스트의 명세에 따라 설치할 수 있습니다. 이를 통해 브라우저에 설치할 방법을 알려줍니다. 매니페스트에는 설치된 PWA의 경험을 사용자 정의하는 데 많은 특성을 포함할 수 있습니다.\n\n또한, 설치된 PWA는 앱과 같이 기기에 아이콘이 표시됩니다. 브라우저에 액세스하지 않고도 실행할 수 있으며 독립적인 애플리케이션으로 작동합니다. 어떤 경우에는 앱 스토어에서 직접 설치할 수도 있습니다.\n\n## Service Workers가 PWA와 통합되는 방법\n\n\n\nPWA의 많은 기능은 서비스 워커 덕분입니다. 서비스 워커는 PWA에서의 외부 요청을 위한 프록시 역할을 계속하며, 브라우저에 의해 활성화되어 사용자가 PWA와 상호 작용하지 않아도 백그라운드에서 실행될 수도 있습니다.\n\n서비스 워커의 양방향 통신과 프록시 기능의 존재는 다양한 유용한 기능을 제공합니다.\n\n- 브라우저를 통해 구독한 사용자에게 푸시 알림을 보내고, 이를 서비스 워커를 통해 클라이언트 장치에 표시할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_5.png)\n\n\n\n- 사용자가 응용 프로그램과 상호 작용하지 않을 때 배경에서 사이트 상태를 업데이트합니다. 예를 들어, 사용자가 응용 프로그램을 열 준비 중인 경우에 계산이 많이 필요한 엔드포인트를 호출하여 수분이 끊김없이 이루어지도록 합니다.\n- 연결 가능 상태가 되면 보낼 메시지를 저장합니다.\n- 연결이 실패할 때 표시할 정적 웹페이지의 캐시된 버전을 보관합니다.\n- 연결 상태에 따라 UI의 수분을 변경합니다. 예를 들어, 동적 전자 상거래 사이트를 구축 중이라면, 장바구니의 마지막 알려진 버전, 사용자의 기본 프로필 및 기타 쉽게 저장할 수 있는 정보를 표시합니다.\n\n이러한 예들은 PWA가 기본 웹 애플리케이션보다 신뢰성이 높고 성능이 우수한 것을 보여줍니다. 캐싱 API와 서비스 워커를 통해 제공되는 양방향 통신은 많은 개선을 제공하기 때문에 PWA가 왜 더 보급되지 않는지 궁금할 정도입니다...\n\n## 아니면 그렇지 않나요?\n\n이 기사를 통해 PWA에 대해 처음 들었거나 기기에 PWA가 하나도 설치되지 않았다면, 모든 브라우저에서 지원되지 않고 모든 기기에서 풀 네이티브 기능을 갖추고 있지 않기 때문일 것입니다 (Apple씨, 여기서 얘기하는 건 당신입니다). 이것은 새로운 개념이 아닙니다. 2007년에는 스티브 잡스가 처음으로 \"웹 2.0 앱\"을 대중화하고 첫 번째 iPhone을 출시하면서 네이티브 앱을 쉽게 지원하지 않았습니다. Forbes가 후에 그것을 그의 가장 큰 실수라고 표현하기도 했습니다. 그 당시 이러한 웹 애플리케이션은 Facebook 및 기타 회사에 의해 개발되었지만, 그들의 성능은 단순히 네이티브 앱과 비교할 수 없을 정도로 좋지 않았습니다. 이것은 대부분 현재 서비스 워커가 제공하는 능력 부족 때문이었습니다.\n\n\n\n![개발 중인 오프라인 준비 웹 애플리케이션](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_6.png)\n\n애플은 빠르게 방향을 바꿨어요. 오늘날, 그들이 애플 스토어에서 누적된 수익을 보호하기 위해 PWA에 대한 완전한 네이티브 지원을 제공하는 데 느리게 움직인 것으로 추정됩니다. 애플 제품을 사용해본 적이 있다면, 하나의 기기를 구입한 후 애플 제품이 바이러스처럼 자동으로 늘어난 것을 알 수 있을 거에요 — 헤드폰, 컴퓨터, 코드, 시계, 아쉽게도 앱까지. 제가 사용하는 것도 정말 그랬어요. 모두가 매끄럽게 함께 작동하기 때문에 더 편리하죠. 그러나 이에는 PWAs를 완전히 활용할 기회를 놓치는 것과 같은 단점이 따릅니다.\n\n애플과 사파리를 제외하고 파이어폭스도 PWAs에 대한 완전한 지원을 채택하는 데 더 느렸어요. 실제로 오늘날까지도 iOS에서 PWA에 대한 지원이 없습니다. 크로미엄 기반 브라우저는 다른 어떤 브라우저보다 빨리 PWA를 지원했어요. 이는 구글 엔지니어들이 2015년에 처음으로 'Progressive Web Application'이라는 용어를 만든 것이기 때문에 놀라운 일이 아니에요.\n\n지난 시간 동안 완전한 채택이 느리게 진행되어 왔지만, 상황이 빠르게 변화하고 있습니다. 올해 초 애플은 일부 기기에서 푸시 알림을 허용하기 시작했어요. 게다가 서비스 워커가 지속적으로 개선되고 새로운 기능들이 계속해서 제공되고 있어요.\n\n\n\n이것이 미래의 방향이 될 수 있을까요? 결국, 네이티브 응용 프로그램을 웹사이트와 연결할 때 전용 프로그래밍 언어와 생태계를 왜 굳이 사용해야 할까요? 기본 웹 도구를 사용하고 사용자에게 향상된, 거의 네이티브 경험을 제공할 수 있기 때문에요. 단점과 위험도 있고, 네이티브 앱은 여러 면에서 우위를 지니고 있지만요. 그러나 웹 기술과 속도가 계속 발전함에 따라, 근시일안에 많은 프로그레시브 웹 앱을 더 많이 보게 될 것이라 예상합니다.\n\n# Stackademic\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 박수를 보내주시고 저자를 팔로우해주시길 바랍니다! 👏\n- 트위터(X), 링크드인, 유튜브에서 팔로우해주세요.\n- Stackademic.com 방문하여 전 세계에서 무료 프로그래밍 교육을 민주화하는 방법에 대해 더 많은 정보를 얻으세요.","ogImage":{"url":"/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png"},"coverImage":"/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png","tag":["Tech"],"readingTime":7},{"title":"자바스크립트에서 간단한 반환과 프로미스 반환의 차이","description":"","date":"2024-05-14 12:53","slug":"2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS","content":"\n\n자바스크립트에서 단순 반환과 프로미스 반환은 서로 다른 목적을 가지고 있어요.\n\n## 단순 반환:\n\n함수에서 값을 직접 반환할 때, 이는 동기 작업입니다. 함수가 실행되고 결과를 즉시 반환해요.\n\n![이미지](/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png)\n\n\n\n## 아래는 코드 분석입니다:\n\n1. 함수 정의: 두 개의 매개변수 a와 b를 받는 add라는 함수를 정의합니다.\n\n2. 반환문: add 함수 내에서 a와 b의 합을 반환하는 return a + b;를 사용합니다.\n\n3. 함수 호출: 그런 다음 매개변수 10과 20을 사용하여 add 함수를 호출합니다.\n\n\n\n4. 결과 저장: 반환된 값(10과 20의 합인 30)이 result 변수에 저장됩니다.\n\n5. 출력: 마지막으로, 우리는 결과값 30을 콘솔에 출력합니다.\n\n단순하고 동기적입니다. 함수는 값을 즉시 반환합니다.\n\n# Promise Return:\n\n\n\nPromise는 비동기 작업에 사용됩니다. 지금이나 미래에 사용할 수 있는 값이나 결코 사용할 수 없는 값을 나타냅니다. 함수가 Promise를 반환하면 비동기 작업을 수행하고 그 작업의 결과에 따라 Promise를 해결하거나 거부할 수 있습니다.\n\n![Promise Image](/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_1.png)\n\n이 코드에서:\n\n- reject()에 new Error(\"Strings are not equal\")를 인수로 추가하여 오류에 대한 자세한 정보를 제공했습니다.\n- catch 블록에서 (error)를 콜백 함수의 인수로 추가하여 오류 객체를 캐치하고 해당 메시지를 기록했습니다.\n\n\n\n이제 코드가 오류 없이 실행되고 적절한 출력을 제공해야 합니다. str1과 str2가 동일한 경우 \"Success message. Both names are equal.\"을 출력합니다. 그 외에는 \"Error: Strings are not equal\"을 출력합니다.\n\n## 차이점:\n\n실행 컨텍스트:\n\n- 간단한 반환: 동기적으로 실행됨.\n- Promise 반환: 비동기 실행을 허용함.\n\n\n\n비동기 작업 다루기:\n\n- Simple return: 비동기 작업을 처리할 수 없습니다.\n- Promise return: 특별히 비동기 작업을 처리하기 위해 설계되었습니다.\n\n사용 방법:\n\n- Simple return: 동기 작업에 사용됩니다.\n- Promise return: 비동기 작업에 사용됩니다.","ogImage":{"url":"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png"},"coverImage":"/assets/img/2024-05-14-DifferencebetweenSimplereturnandPromisereturninJS_0.png","tag":["Tech"],"readingTime":2},{"title":"부적합한 프로그래머일지도 모르는 5가지 신호","description":"","date":"2024-05-14 12:51","slug":"2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer","content":"\n\n## 프로그래밍 의견\n\n![프로그래밍](/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png)\n\n아무도 완벽하지 않으며 아래 목록 중 하나 또는 두 개의 항목이 모두 해당될 것입니다. 그러나 그 중 세 가지 이상이 해당된다면, 스스로를 비판하거나 다른 일을 찾아보는 것이 좋을 수도 있습니다.\n\n프로그래밍은 오랜 시간 약한 조건과 많은 스트레스 아래에서 가끔 열심히 할 필요가 있으므로 그것을 즐기지 않는다면 의미가 없습니다. 거기에 이르기까지의 교육 과정은 김이며, 실제로 좋아지려면 십 년의 경험이 필요합니다. 처음부터 그런 감정이 느껴지지 않는다면, 다른 것을 찾아보는 것이 좋은 이유가 될 수 있습니다.\n\n\n\n우리는 더 많은 우수한 프로그래머가 필요해요. 프로그래밍은 인지적 프로세스를 자동화하며, 이러한 합리화는 현재 세상에서 진보의 주요 원동력이자 번영의 주된 요인이에요. 제 시선에서 모든 프로그래머는 우리의 존경을 받을 만한 영웅이에요.\n\n당신이 하는 일에 대한 오피서, 신사, 데이터 전사가 되어주세요.\n\n프로그래밍은 일자리가 아니에요. 이는 일종의 사명이에요. 빠르게 돈을 벌 수 있는 다른 방법이 있지만, 프로그래밍은 오늘날 일의 가장 높은 가치 중 하나로 사회에 봉사하는 것이기도 해요.\n\n그러니 당신이 프로그래머라 자부심을 갖지만 오만해지지 마세요. 당신은 사회의 종복이며, 기계가 읽을 수 있는 책을 쓰고, 스크롤을 통해 작동되는 로프의 골렘을 프로그래밍하는 현대적 수도사이기도 해요.\n\n\n\n당신이 되어야 하는 사이버 수도승은 겸손과 자발성, 자신의 한계를 이해하는 것뿐만 아니라 프로그래밍보다는 예술과 철학, 윤리와 정치를 필요로 합니다. 또한 개인으로서와 창조적인 힘으로서 사회에서의 역할에 대한 인식도 필요합니다.\n\n이것과 자아가 충돌하지 않을 수도 있습니다. 자아는 자신의 가치를 알아야 하며, 당신의 의견에서 벗어나는 것에 확신을 가져야 합니다. 하지만 납득할 수 있고 생각을 바꿀 수 있는 능력 또한 이 중요합니다. 당신이 소왈되지 않은 자아를 가지고 있을 때만 이 위대함을 얻을 수 있습니다.\n\n만약 이 이상적인 것을 달성한다면, 당신은 좋은 프로그래머입니다. 목표는 이를 달성하기 위한 길입니다.\n\n그래서 여기 목록입니다:\n\n\n\n- 프로그래밍을 즐기지 않아요.\n- 참고 자료, 라이브러리 및 설명서를 읽지 않고, 그냥 주물러버려요.\n- 자기를 돌아보지 않고, 자신이나 자신의 프로그램, 사용 가능한 도구에 대해 자기비판이 없어요.\n- 듣는 모든 말을 믿어요. 스스로 생각하지 않고 해결책을 찾지 않아요.\n- \"그렇다고?\" 라는 질문을 하지 않아요. 과학적인 작업을 하지 않아요.\n- 자신의 프로그램을 오류로 테스트해보지 않아요.\n- 해결하려는 것이 이미 존재하는지 확인하려고 하지 않아요.\n- 기능의 작은 부분만 사용하려 할 때도 프레임워크를 사용해요.\n- 유행과 이데올로기에 영향을 받아요 - \"이달의 패러다임\".\n- 다른 사람의 코드를 테스트하지 않고 신뢰해요.\n- 필요하지 않은 자원인 CPU 및 처리 시간을 낭비해요.\n- 문제에 합리적인 알고리즘을 찾지 않아요.\n- 시스템의 하드웨어를 무시하고, 다른 방법으로 쉽게 할 수 있는 것도 있음에도 특히 취약한 작업을 해요.\n- 어떤 컴퓨터 아키텍처에서 작업하는지에 대한 이해가 없으며, 자부심을 갖고 있어요 (\"HLL 무지\").\n- 문제 해결에 집중하는 대신 힙 이데올로기를 사용해요 (\"OOP Mad Cow Disease\").\n- 형태의 중요성을 높이는 태도\n- 시스템을 이해하지 못하고 스스로 시스템 기능을 구현하려 하면 대개 실패합니다.\n- \"최적화\"를 무시해요.\n- 어셈블리에 관심을 둬요.\n- 디버거를 사용하는 방법을 모르겠어요.\n- 프로그램을 역공학적으로 분석해본 적이 없고, 그에 대한 호기심이 없어요.\n- 그냥 그 때 표준으로 인해 일을 하지만 그것에 대해 비판적으로 생각하거나 다른 사람과 의견을 교환하지 않아요. 요약하자면, 반성이 부족해요.\n- 자신의 도구의 한계 및 사용된 언어, 알고리즘, 시스템의 강점과 약점에 대한 지식이 전혀 없어요.\n- 목적지에 빨리 도착한다고 생각해서 항상 최적의 경로를 선택해요.\n- 세심하고 철저하게 일하지 않고, 어질어질하게 일해요.\n- 새로운 사람들이나 유지보수 담당자 앞에서 오만하게 행동하며 도우려 하지 않아요. 의자를 통해서 음해하고 협조적이지 않은 경력의 사고방식도 포함돼요. 안타깝게도 일반적이에요. 하지만 그렇게 일할 수 없어요. 누구든 그런 사람과 일할 수 없어요.\n- 일을 마음대로 처리하지 않고, 의도적으로 암호화된 코드로 직업을 안전하게 만들어요. 만약 필요하거나 아프다면 더 나은 사람으로 대체할 기회나 자리를 주지 않습니다. 이를 간단히 아 불효한 행동이라고 부릅니다. 질질짜는 질질짜기 대신에 실질적인 안전이 품질을 통해 실현돼요.\n- 일을 속이고, 자립적으로 결점을 드러내거나 인정하지 않아요. 스스로에게 대안을 제시하지 않아요.\n- 엔지니어로서의 자질이 당신에게 말하지만, 관리부와의 대면에서 등을 빼지 못할 때가 있어요. 이것은 종종 프로젝트의 파괴적 결과나 더 나쁜 일로 이어지곤 해요. 챌린저의 엔지니어들은 발사를 거부해야 했어요. 그 추운 날, 그들의 거부로 인해 일곱 명이 불필요하게 사망하게 됐어요. 나쁜 프로그래머들은 용기가 없고 직장에 대한 두려움이 있어요.\n- 경우에 따라 결론을 내릴 대신, 자격 없는 사람들이 무엇을 해야 하는지 지시하는 것을 허용해요. 프로그래머와 엔지니어로서, 살아가야 하는 엄청난 책임이 있어요. 혹은 그 분야에 위치할 자격이 없는 경우도 있어요.\n- 저지른 실수를 인정하지 않고, 오히려 숨기고 감추려 해요. (BOfH 현상)\n- 교육을 이어가지 않고, 새로운 것을 배우거나 시도할 의지가 없어요. 또한 능동적인 태도를 나타내지 않아요. 상투적인 길을 시도해보지 않아요.\n- 두려움.\n\n위 목록에 속하지 않는 것은 여러분의 프로그램 중 하나에 오류가 있다는 것이 아니에요. 모든 프로그램에는 오류가 있어요. 또한 예상보다 더 오랜 시간이 걸리는 것 역시 정상적이에요.\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n\n\n- 작가에게 박수를 보내 주시고 팔로우도 부탁드립니다! 👏\n- 팔로우하기 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png"},"coverImage":"/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png","tag":["Tech"],"readingTime":4}],"page":"56","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}