{"pageProps":{"posts":[{"title":"7가지 리액트 상태 관리 방법(2024년 최신)","description":"","date":"2024-05-12 22:22","slug":"2024-05-12-7BestPracticesReactStateManagement","content":"\n<img src=\"/assets/img/2024-05-12-7BestPracticesReactStateManagement_0.png\" />\n\n리액트 JS 애플리케이션이 상태들의 엉키는 꼬리에 끼게 된다면 지치셨나요? 컴포넌트 간 데이터 흐름을 계속 추적하기 어렵다고 느끼시나요? 이런 질문 중 어느 하나라도 \"네\"라고 대답하셨다면 행운이시군요! 이 글에서는 React JS에서 상태를 관리하는 최상의 방법을 탐구하고, 앱의 상태를 효과적으로 관리하는 방법을 안내해 드리겠습니다.\n\n목차:\n\n∘ 상태 관리의 중요성은 무엇인가요?\n∘ 1. React의 로컬 컴포넌트 상태 이해하기\n∘ 2. 상태를 사용하는 곳에 가깝게 유지하기\n∘ 3. 상태 업데이트에 불변성 사용하기\n∘ 4. 고급 상태 관리를 위해 Redux 또는 MobX 활용하기\n∘ 5. 메모이제이션으로 상태 업데이트 최적화하기\n∘ 6. React Context API 사용 고려하기\n∘ 7. React의 최신 기능과 라이브러리 업데이트에 주의하기\n\n## 상태 관리가 왜 중요할까요?\n\n최적의 방법에 대해 자세히 살펴보기 전에, React JS에서 상태 관리가 왜 중요한지 간단히 되짚어 보겠습니다. 상태는 애플리케이션에서 시간이 지남에 따라 변하는 데이터를 나타내며, 이를 적절하게 관리함으로써 앱이 올바르게 작동함을 보장할 수 있습니다.\n\n이를 통해 데이터 불일치, props 전달, 불필요한 다시 렌더링과 같은 일반적인 함정을 피할 수 있습니다. 이러한 최적의 방법을 따르면 앱을 더 잘 유지, 확장 가능하고 효율적으로 만들 수 있습니다.\n\n## 1. React의 로컬 컴포넌트 상태 이해하기\n\n<img src=\"/assets/img/2024-05-12-7BestPracticesReactStateManagement_1.png\" />\n\nReact에서는 useState 또는 useReducer 훅을 사용하여 컴포넌트 내에서 상태를 관리합니다. 로컬 컴포넌트 상태와 Redux 또는 MobX와 같은 전역 상태 관리 라이브러리와 어떻게 다른지 이해하는 것이 중요합니다.\n\n로컬 상태는 단일 컴포넌트에 특정한 데이터에 사용되며 전체 응용 프로그램에서 공유할 필요가 없는 경우에 사용되어야 합니다. 복잡한 앱의 경우 여러 컴포넌트가 있는 경우 전역 상태 관리 솔루션을 고려해보세요.\n\n## 2. 상태를 사용하는 곳에 가까이 유지하기\n\n<img src=\"/assets/img/2024-05-12-7BestPracticesReactStateManagement_2.png\" />\n\n상태를 가능한 한 필요로 하는 구성 요소 가까이에 유지하는 것이 좋은 습관입니다. 이 접근 방식인 \"상태 끌어올리기\"는 복잡성을 줄이고 응용 프로그램을 이해하기 쉽게 만듭니다.\n\n여러 구성 요소가 동일한 상태에 액세스해야 하는 경우 해당 상태를 가장 가까운 공통 조상으로 끌어올리세요. 그렇게 함으로써 해당 상태에 대한 단일 진실의 원천을 만들어 해당 상태를 관리하고 업데이트하기 쉬워집니다.\n\n## 3. 상태 업데이트에 불변성 사용하기\n\n<img src=\"/assets/img/2024-05-12-7BestPracticesReactStateManagement_3.png\" />\n\n리액트의 상태는 직접 변형해서는 안 됩니다. 대신 불변 데이터 구조와 기술을 사용하여 상태를 업데이트하세요. Immutable.js, Immer 또는 전개 연산자는 원본을 변형하지 않고 새로운 상태 객체를 만드는 데 인기 있는 선택지입니다. 이 관행을 따르면 상태 업데이트가 예측 가능하고 디버깅하기 어려운 부작용을 일으키지 않게 됩니다.\n\n## 4. 고급 상태 관리를 위해 Redux 또는 MobX 활용하기\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*jxPIxkKoyu-eN0Zr55zIMA.gif\" />\n\nReact JS 애플리케이션이 더 복잡해지면 더 견고한 상태 관리 솔루션이 필요할 수 있습니다. Redux와 MobX는 전역 상태를 관리하고 대규모 애플리케이션을 처리하는 강력한 도구를 제공하여 인기 있는 선택지입니다. 그러나 진정으로 필요한 경우에만 이러한 라이브러리를 도입하세요. 작은 프로젝트의 경우에는 로컬 컴포넌트 상태 관리만으로도 충분할 수 있습니다.\n\n## 5. 메모이제이션을 활용해 상태 업데이트 최적화하기\n\n![이미지](/assets/img/2024-05-12-7BestPracticesReactStateManagement_4.png)\n\nReact의 조정 알고리즘은 앱에 많은 상태와 복잡한 UI 컴포넌트가 있는 경우에 비용이 많이 들 수 있습니다. 성능을 최적화하려면 React.memo나 useMemo와 같은 메모이제이션 기법을 사용하여 불필요한 다시 렌더링을 방지하세요. 이러한 함수들을 사용하면 컴포넌트의 결과를 종속성에 기반하여 캐시하여 React의 조정 프로세스에 부하를 줄일 수 있습니다.\n\n## 6. React Context API 사용을 고려해보세요\n\n![React Context API](/assets/img/2024-05-12-7BestPracticesReactStateManagement_5.png)\n\nReact의 Context API는 전역 상태 관리 라이브러리를 사용하지 않고 컴포넌트 간 상태를 공유하기 위한 내장 솔루션입니다. 각 레벨에서 명시적으로 props를 전달하지 않고도 컴포넌트 트리를 통해 데이터를 전달할 수 있게 해줍니다.\n\nContext는 작은 애플리케이션이나 몇 개의 밀접한 관련 컴포넌트 사이에서 상태를 공유할 때 이상적입니다. 그러나 Context를 사용할 때 과용하면 성능 문제가 발생할 수 있으니 주의해야 합니다.\n\n## 7. React의 최신 기능과 라이브러리를 알아두세요\n\n![React](/assets/img/2024-05-12-7BestPracticesReactStateManagement_6.png)\n\nReact JS는 지속적으로 발전하는 프레임워크로, 새로운 기능과 라이브러리가 지속적으로 소개됩니다. 앱의 성능과 효율성을 유지하기 위해 최신 동향을 계속해서 파악하는 것이 중요합니다.\n\n이러한 모범 사례를 따라가면 React JS 애플리케이션에서 상태 관리에 대한 도전에 잘 대처할 수 있을 것입니다. 프로젝트의 규모와 복잡성에 맞는 적절한 접근 방식을 선택하고, 항상 간단하고 유지보수 가능한 코드를 지향해야 합니다.\n\n당신의 학습 여정은 여기서 끝나지 않아요! 만약 이 글에서 가치를 발견했다면, 더 많은 것이 준비되어 있어요. 흥미로운 업데이트를 받으려면 저희를 팔로우해주세요.\n","ogImage":{"url":"/assets/img/2024-05-12-7BestPracticesReactStateManagement_0.png"},"coverImage":"/assets/img/2024-05-12-7BestPracticesReactStateManagement_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular16 애플리케이션에서 CORS 문제 해결하기","description":"","date":"2024-05-12 22:21","slug":"2024-05-12-CORSIssuesFixinginAngular16Application","content":"\n\n```\n![이미지](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_0.png)\n\nCross-Origin Resource Sharing (CORS)은 웹 브라우저가 제한하는 필수적인 보안 메커니즘입니다.\n\nCORS는 HTTP 헤더 기반 메커니즘으로, 서버가 브라우저가 리소스를로드 허용해야 하는 자신의 도메인, 스키마 또는 포트 이외의 모든 출처를 나타낼 수 있도록 허용합니다.\n\n여기에서는 Angular 애플리케이션에서 CORS 문제를 해결하는 방법과 CORS 문제 없이 애플리케이션을 실행하는 방법을 논의할 것입니다.\n```\n\n\n\n<img src=\"/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_1.png\" />\n\n# CORS 문제를 어떻게 해결할 수 있을까요?\n\n<img src=\"/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_2.png\" />\n\n- 적절한 헤더를 제공하기 위해 HTTP Interceptor를 생성하면 문제를 해결할 수 있습니다.\n- 또 다른 방법은 Proxy.conf.js 파일을 생성하는 것입니다.\n\n\n\nAngular 애플리케이션을 독립적으로 만들어 봅시다. 그리고 HTTP Interceptors를 생성해 보겠습니다.\n\n![이미지](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_3.png)\n\n인터셉터 파일 안에 다음 코드를 추가해주세요.\n\n![이미지](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_4.png)\n\n\n\n사이트를 설정하여 해당 사이트에 액세스할 수 있도록 허용할 수도 있습니다. \"*\" 와일드카드를 사용하여 모든 사이트에 액세스할 수 있도록 설정할 수 있습니다. 이것은 공개 API에만 사용해야 합니다. 비공개 API에는 *를 사용해서는 안 되며 대신 특정 도메인 또는 도메인이 설정되어야 합니다. 또한 와일드카드는 crossorigin 속성이 익명으로 설정된 요청에만 작동하며, 요청에 쿠키와 같은 자격 증명을 전송하는 것을 방지합니다.\n\n```js\nAccess-Control-Allow-Origin: *\n```\n프라이빗 API에 모든 사이트가 액세스할 수 있도록 \"*\" 와일드카드를 사용하는 것은 좋지 않은 방법입니다.\n\n일부 경우에는 헤더를 추가해도 CORS 문제가 해결되지 않을 수 있습니다. 이런 경우에는 프록시 서버를 추가하여 문제를 해결해야 합니다.\n\n\n\n글로벌 수준에서 proxy.conf.js 파일을 추가해주세요\n\n![그림](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_5.png)\n\n해당 파일 안에 다음 코드를 추가해야 합니다\n\n![그림](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_6.png)\n\n\n\nproxy.conf.js 파일에 프록시 설정을 추가한 후에는 이제 angular.json 파일에 해당 파일을 다음과 같이 등록해야 합니다.\n\n![Proxy Configuration](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_7.png)\n\nCORS 프록시를 사용하면 클라이언트와 서버 사이에 브릿지 역할을 하는 프록시 서버를 사용하여 CORS 오류를 우회할 수 있습니다. 그래서 대상 서버에 요청하는 대신에 요청을 대신하여 프록시 서버로 보냅니다. 요청은 다음과 같이 보입니다: https://proxy.com/https://server.com.\n\n이 내용이 도움이 되었으면 좋겠네요!\n\n\n\n\"이 기사를 즐겼나요? 더 많은 유익한 콘텐츠를 위해 계속 연락을 유지하세요. 트위터와 링크드인에서 제를 팔로우하여 내 최신 기사, 튜토리얼, 발표 자료를 받아보세요. 함께 학습하는 여정을 떠나 새로운 아이디어를 탐험해봅시다! 놓치지 마세요, 지금 바로 팔로우하세요!\"","ogImage":{"url":"/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_0.png"},"coverImage":"/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_0.png","tag":["Tech"],"readingTime":3},{"title":"상태 관리자인 Zustand와 JS 메모리","description":"","date":"2024-05-12 22:19","slug":"2024-05-12-ZustandStateManagerAndJSMemory","content":"\n\n이 기사에서는 매우 간단하고 쉽게 관리할 수 있는 Zustand 상태 관리자를 검토할 것이며, 사용 시 고려해야 할 몇 가지 사항이 있습니다. 또한 기본적으로 JavaScript 메모리 관리가 어떻게 작동하는지 설명하겠습니다.\n\n![Zustand 상태 관리자 및 JS 메모리](/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png)\n\n여기 Zustand 상태 관리자에서의 기본 이슈 설명이 있습니다. 매우 간단한 구조를 가진 store를 선언했는데, 이 store는 목록으로 간단한 데이터를 유지하도록 설계되었고 setStoreData라는 단일 메서드만 있습니다. store를 사용할 수 있겠죠? 내가 store를 가져왔다면 모든 컴포넌트에서 store 데이터를 사용할 수 있고, setStoreData 메서드를 가져오면 store 데이터를 편집할 수도 있을 것입니다. 하지만 setStoreData 메서드를 가져오지 않아도 store 데이터를 편집할 수 있다면 어떨까요? 네, 그렇게 되어서는 안 될 것 같지만 Zustand에서 그렇게 되고 있어서 React 프로젝트에서 Zustand 상태 관리자를 사용할 때 매우 조심해야 합니다. 어떻게 그런 일이 발생하는지 살펴보겠습니다...\n\n![Zustand 상태 관리자 및 JS 메모리](/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_1.png)\n\n\n\n우리가 간단한 상점 예제를 보여드립니다. 꽤 기본적인 내용이죠. 하지만 이 상점을 사용하는 중에 작은 문제가 있습니다.\n\n![image](/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_2.png)\n\n이 조건하에, `setStoreDATA` 함수를 전혀 사용하지 않는다는 점을 볼 수 있습니다. 그런데 이 함수가 메소드를 사용하지 않아도 상점 데이터를 설정할 수 있습니다. 어떻게 그런 일이 가능한 걸까요?\n\nJavaScript에서 기본 데이터 유형(숫자, 문자열, 불리언, null, undefined, 심볼, BigInt)은 변수가 액세스하는 위치에 직접 저장됩니다. 그러나 객체, 배열 및 함수와 같은 비-기본 유형은 참조로 저장되기 때문에 우리가 참조로 호출하면 데이터 유형을 조작할 수 있습니다. 이것은 프로그램 전체에 직접 영향을 미치며 우리가 수정한 공간이 아닌 모든 곳에서 변경을 가져옵니다. 그래서 데이터를 참조로 저장하는 것은 무엇인가요?\n\n\n\n참조에 의한 전달 및 값에 의한 전달\n\n## 값에 의한 전달\n\n값에 의한 전달을 사용할 때, 원래 데이터의 사본이 함수에 전달됩니다. 함수 내부에서 매개변수를 변경해도 원본 데이터에는 영향을 미치지 않습니다. 이는 함수에 전달된 값이 실제로 원래 값의 사본이기 때문입니다. 대부분의 기본 데이터 유형(정수, 부동 소수점 및 부울과 같은)은 보통 값에 의해 전달됩니다.\n\n```js\nfunction modifyValue(num) {\n    num = 15;\n    console.log(\"함수 내부 값:\", num);\n}\n\nlet x = 5;\nmodifyValue(x);\nconsole.log(\"함수 호출 후 x 값:\", x);\n```\n\n\n\n이 예시의 결과\n\n```js\n함수 내부의 값: 15\n함수 호출 후 x 값: 5\n```\n\n이 예시에서는 함수 내에서 x의 값이 변경되었지만 x의 값이 변하지 않았습니다. 이는 함수가 x의 사본만을 접근했기 때문입니다.\n\n# 참조로 전달\n\n\n\n자바스크립트에서 객체(배열 및 함수 포함)를 함수에 전달할 때, 기술적으로 \"공유\"로 전달됩니다 (간단히 말하면 참조에 의한 전달이라고도 합니다). 실제로 객체에 대한 참조를 전달하므로 함수 내에서 객체를 수정하면 원본 객체에 영향을 줍니다.\n\n```js\nfunction modifyArray(arr) {\n    arr.push(4);\n    console.log(\"함수 내부의 배열:\", arr);\n}\n\nlet myArray = [1, 2, 3];\nmodifyArray(myArray);\nconsole.log(\"함수 호출 후 배열:\", myArray);\n```\n\n이 예제의 출력\n\n```js\n함수 내부의 배열: [1, 2, 3, 4]\n함수 호출 후 배열: [1, 2, 3, 4]\n```\n\n\n\n요약하자면, 자바스크립트에서:\n\n- 값을 전달 (원시 값): 값만 전달되므로 함수 내부의 매개변수 변경은 원래 변수에 영향을 미치지 않습니다.\n- 참조로 전달 (객체): 객체에 대한 참조가 전달되므로 매개변수 변경은 원래 객체에 영향을 미칩니다.\n\n그렇다면 Zustand는 무엇일까요?\n\nZustand에서는 사용자가 스토어를 변경할 때 setStoreData 메서드를 사용하도록 강제하는 보호 기능이 배열을 유지하는 경우에는 없습니다.\n\n\n\n# 결론\n\n만약 당신이 리스트 구조를 유지하는 상점을 가지고 있다면, 자바스크립트에서 배열인 리스트는 참조 호출로 편집될 것입니다. 즉, 당신이 상점 데이터를 호출하고 그 데이터를 함수에서 사용하고 다른 리스트나 값을 동일하게 만들었다고 가정해봅시다. 이러한 경우, 선언한 설정 방법을 사용하지 않아도 상점이 변경될 것입니다.\n\n아마도 이것은 간단한 부족한 보호 또는 고의적으로 포기된 자유일 수 있습니다. 특히 상점이 리스트 구조를 포함하는 경우, Zustand 상점을 사용할 때 극도로 조심해야 합니다.\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요! 👏\n- X를 팔로우하고 LinkedIn, YouTube, Discord에서 우리를 만나보세요.\n- 다른 플랫폼을 방문해보세요: In Plain English, CoFeed, Venture, Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png"},"coverImage":"/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022","description":"","date":"2024-05-12 22:17","slug":"2024-05-12-SettingESLintonaReactTypescriptproject2022","content":"\n\n<img src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png\" />\n\n# 소개\n\n내 React Typescript 프로젝트에 ESLint를 설치하고 이해하려는 데 많은 어려움을 겪은 후, React Typescript 프로젝트에 ESLint를 설정하는 확정 가이드를 작성하기로 결정했습니다.\n\n이 튜토리얼의 주요 목표는 단계별로 설정하고 추가 또는 실행된 각 줄을 설명하는 것입니다. 단순히 여러 구성을 가진 많은 파일을 제공하고 무엇이 일어나고 있는지를 이해할 수 있기를 바랄 뿐인 대신 설명합니다.\n\n\n\n그럼 시작해볼까요!\n\n## 준비물\n\n참고: Node 버전 `= 10`이 설치되어 있어야 합니다. 설치되어 있지 않다면 NodeJS 웹사이트로 이동하여 로컬 머신에 다운로드하고 설치해 주세요. (https://nodejs.org/en/)\n\n## 단계 1: TypeScript로 React 프로젝트 생성\n\n\n\n다음 명령어는 my-app이라는 폴더 내에 프로젝트를 생성합니다.\n\n터미널에서 다음을 실행하세요:\n\n```js\nnpx create-react-app my-app --template typescript\n```\n\n# 단계 2: React 프로젝트에서 미리 설정된 ESLint 구성 제거하기\n\n\n\n래스크는 eslint 설정이 미리 설정되어 있어요. 이 설정을 제거해서 더 나은 설정을 할 수 있도록 해봐요. 이를 위해 'package.json' 파일에서 아래 코드를 제거해주세요.\n\n```js\n\"eslintConfig\": {\n   \"extends\":[\n      \"react-app\",\n      \"react-app/jest\"\n   ]\n}\n```\n\n# 단계 3: ESLint 패키지 설치하기\n\n프로젝트 디렉토리 안에서 터미널을 열어주세요.\n\n\n\n터미널에서 다음을 실행해 주세요:\n\n```js\nnpm install eslint --save-dev\n```\n\n위 명령을 실행하면 'package.json' 파일에서 \"eslint\"가 개발용 종속성으로 추가된 것을 확인할 수 있습니다.\n\n```js\n\"devDependencies\": {\n   \"eslint\": \"^7.20.0\"\n}\n```\n\n\n\n# 단계 4: ESLint 설정\n\n프로젝트 디렉토리 안에서 터미널을 열어주세요.\n\n터미널에서 다음을 실행하세요:\n\n\n\n```js\nnpx eslint --init\n```\n\n이 명령을 실행할 때 설정에 관한 몇 가지 질문에 답변해야합니다.\n\n이후, 설치해야 할 종속 항목을 확인한 다음 다음과 같이 물어볼 것입니다:\n\n그런 다음 필요한 모든 패키지를 설치합니다. 설치 프로세스가 완료되면 \"package.json\" 파일의 'devDependencies'는 다음과 같이 보여야 합니다:\n\n\n\n```js\n\"devDependencies\": {\n\"@typescript-eslint/eslint-plugin\": \"^4.15.1\",\n\"@typescript-eslint/parser\": \"^4.15.1\",\n\"eslint\": \"^7.20.0\",\n\"eslint-config-airbnb\": \"^18.2.1\",\n\"eslint-plugin-import\": \"^2.22.1\",\n\"eslint-plugin-jsx-a11y\": \"^6.4.1\",\n\"eslint-plugin-react\": \"^7.22.0\",\n\"eslint-plugin-react-hooks\": \"^4.2.0\"\n}\n```\n\nPS: 위 예시와 버전이 일치하지 않아도 괜찮아요.\n\n# Step 5: ESLint 실행하기\n\n프로젝트 디렉토리에서 터미널을 열어주세요.\n\n\n\nESLint를 실행하고 가리키는 오류를 확인하려면 다음을 실행하세요:\n\n```js\nnpx eslint <대상파일>\n```\n\n일부 오류를 자동으로 수정하려면 '--fix'를 사용할 수 있어요:\n\n```js\nnpx eslint <대상파일> --fix\n```\n\n\n\n만약 경고를 무시하고 싶다면 ‘--quiet’를 사용할 수 있어요.\n\n```js\nnpx eslint <대상파일> --quiet\n```\n\n# 단계 5.1: 실행해봅시다!\n\n만약 'src' 디렉토리 안의 모든 파일에 대해서 eslint를 실행하면 35개의 오류가 나타날 거예요. 와우!\n\n\n\n```js\nnpx eslint src/* \n```\n\nESLint 출력:\n\n<img src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_1.png\" />\n\n자동 수정으로 실행하면 무서운 부분은 줄어들었지만 해결해야 할 오류가 여전히 22개 남아 있어요. 대박이에요!\n\n\n\n```bash\nnpx eslint src/* --fix\n```\n\nESLint의 출력:\n\n![Setting ESLint on a React Typescript project](/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_2.png)\n\n그래서 우리는 모든 단계를 거치고 Typescript로 ReactJS의 '안녕, 세계' 프로젝트를 수행했는데도 이 모든 오류가 발생했습니다. 대부분의 오류는 확장 파일 오류나 심지어 React 자체의 사용과 같은 무의미한 것들이었습니다.\n\n\n\n짜증나는 일이죠?\n\n좋은 소식은 이미 이 지옥을 겪어가며 이 문제들을 해결했고, 이제 ESLint를 제대로 사용할 수 있도록 모든 구성을 끝마칠 수 있습니다. 이 문제를 하나씩 살펴보고 어떻게 해결해야 하는지 알아보겠습니다!\n\n## 남은 문제 해결하기\n\n### 문제: \"'no-use-before-define'\"\n\n\n\n에러 샘플: 'React'가 정의되기 전에 사용되었습니다.\n\n## 해결 방법\n\n'eslintrc.json' 파일에서 \"rules\" 섹션 아래에 다음을 추가하십시오:\n\n```js\n\"rules\": {\n  \"no-use-before-define\": \"off\",\n  \"@typescript-eslint/no-use-before-define\": [\"error\"]\n}\n```\n\n\n\n위 설명은 이 스택 오버플로 포스트에 있어요 (https://stackoverflow.com/questions/63818415/react-was-used-before-it-was-defined/64024916#64024916)\n\n# 문제: \"'react/jsx-filename-extension\"\n\n에러 샘플: 확장자 '.tsx'를 가진 파일에서 JSX가 허용되지 않음\n\n## 해결책\n\n\n\n'eslintrc.json' 파일에서 \"rules\" 아래에 다음을 추가하세요:\n\n```js\n\"rules\": {\n...\n\"react/jsx-filename-extension\": [ \"warn\", {\"extensions\": [\".tsx\"]} ]\n}\n```\n\n# 문제: \"import/no-unresolved\"\n\n에러 샘플: './App' 모듈에 대한 경로를 해결할 수 없음\n\n\n\n## 해결 방법\n\n- 프로젝트 디렉토리 내에서 터미널을 열고 eslint-import-resolver-typescript 패키지를 설치하세요.\n\n```js\nnpm install eslint-import-resolver-typescript --save-dev\n```\n\n- 'eslintrc.json' 파일에 다음과 같이 새로운 \"settings\" 속성을 추가하세요:\n\n\n\n```json\n\"settings\": {\n    \"import/resolver\": {\n        \"typescript\": {}\n    }\n}\n```\n\n# 문제: \"import/extensions\"\n\n에러 샘플: './App'에 대한 'tsx' 파일 확장자 누락\n\n## 해결책\n\n\n\n'eslintrc.json' 파일에서 \"rules\" 아래에 다음을 추가해 주세요:\n\n```js\n\"rules\": {\n…\n\"import/extensions\": [\n\"error\",\n\"ignorePackages\",\n{\n\"ts\": \"never\",\n\"tsx\": \"never\"\n}\n]\n}\n```\n\n# 문제: \"no-undef\"\n\n에러 샘플: 'test'가 정의되지 않았습니다\n\n\n\n## 해결 방법\n\n'eslintrc.json' 파일에서 \"extends\" 항목에 \"plugin:@typescript-eslint/recommended\"를 추가하십시오:\n\n```js\n\"extends\": [\n…\n\"plugin:@typescript-eslint/recommended\"\n],\n```\n\n# 문제: \"no-shadow\"\n\n\n\n에러 샘플: 'Enum'이 이미 상위 스코프에서 선언되었습니다.\n\n## 해결 방법\n\n‘eslintrc.json’ 파일에서 \"rules\" 아래에 다음을 추가하십시오:\n\n```js\n\"rules\":{\n…\n\"no-shadow\": \"off\",\n\"@typescript-eslint/no-shadow\": [\"error\"]\n}\n```\n\n\n\n스택 오버플로우 게시물에 설명이 있습니다(https://stackoverflow.com/questions/63961803/eslint-says-all-enums-in-typescript-app-are-already-declared-in-the-upper-scope)\n\n# 문제: 'js', 'jsx', 'ts', 또는 'tsx' 확장자 파일이 아닌 파일에 대한 오류\n\n## 해결책:\n\n‘.eslintignore’ 파일에 추가하여 ESLint가 특정 파일을 무시하도록 할 수 있습니다.\n\n\n\n그럼,\n\n- 프로젝트 루트에 '.eslintignore' 파일을 만듭니다.\n- 다음 텍스트를 추가합니다:\n\n```js\n*.css\n*.svg\n```\n\n# 추가:\n\n\n\n# 적용해 볼 좋은 규칙들\n\n## 모든 함수에 명시적인 반환 유형을 강제로 적용하기\n\n‘eslintrc.json’ 파일에서 \"rules\" 아래에 다음을 추가해주세요:\n\n```js\n\"rules\":{\n...\n\"@typescript-eslint/explicit-function-return-type\": [\n\"error\",\n{\n\"allowExpressions\": true\n}\n]\n}\n```\n\n\n\n## 코드 라인의 최대 길이\n\n'.'eslintrc.json' 파일에 \"rules\" 항목 아래에 다음 코드를 추가해주세요:\n\n```js\n\"rules\":{\n…\n\"max-len\": [\"warn\", { \"code\": 80 }]\n}\n```\n\n## React Hooks 규칙\n\n\n\n'**eslintrc.json**' 파일에서 \"plugins\" 섹션에 다음을 추가해주세요:\n\n```js\n\"plugins\": [\n…\n\"react-hooks\"\n],\n```\n\n그리고 \"rules\" 섹션에도 다음을 추가해주세요:\n\n```js\n\"rules\":{\n…\n\"react-hooks/rules-of-hooks\": \"error\",\n\"react-hooks/exhaustive-deps\": \"warn\"\n}\n```\n\n\n\n# 무시할 몇 가지 규칙:\n\n## 기본 내보내기 사용 선호\n\n`eslintrc.json`에서 \"rules\" 아래에 다음을 추가해주세요:\n\n```js\n\"rules\":{\n…\n\"import/prefer-default-export\": \"off\"\n}\n```\n\n\n\n## 프롭 타입 규칙\n\n`eslintrc.json` 파일에서 \"rules\" 항목에 다음 내용을 추가해 주세요:\n\n```js\n\"rules\":{\n…\n\"react/prop-types\": \"off\"\n}\n```\n\n# 결론\n\n\n\n그래서 이러한 구성을 통해 ReactJS with Typescript 프로젝트의 코드 품질을 향상시킬 수 있습니다. 즐기세요! :)\n\n# VS Code: 저장할 때 파일에서 ESLint 자동 수정 실행\n\n게다가, VS Code에서 자동 수정을 구성하는 방법을 보여드리겠습니다. 그러나 이는 선택 사항입니다. 코드를 저장할 때마다 ESLint를 자동 수정하려면 다음 단계를 수행하실 수 있습니다.\n\n- 프로젝트 루트에 '.vscode' 폴더를 생성합니다.\n- '.vscode/' 폴더 안에 'settings.json' 파일을 생성하고 다음 코드를 삽입합니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_3.png\" />\n\n```js\n{\n\"editor.defaultFormatter\": \"dbaeumer.vscode-eslint\",\n\"editor.formatOnSave\": true,\n\"eslint.alwaysShowStatus\": true,\n\"editor.codeActionsOnSave\": {\n\"source.fixAll.eslint\": true\n}\n}\n```\n\n- VS Code ESLint 확장 프로그램 설치\n\nVS Code 'Extensions' 섹션으로 이동하여 수동으로 설치할 수 있습니다:\n\n\n\n![이미지](/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_4.png)\n\n또는 VS Code 빠른 열기(Ctrl+P)를 실행하고 다음 몤령어를 실행하세요:\n\n```js\next install dbaeumer.vscode-eslint\n```\n\n- VS Code에서 ESLint 익스텐션 사용 허용하기:\n\n\n\n처음 사용하는 경우 ESLint 확장 프로그램이 차단될 것입니다. 그럼에도 불구하고 허용해야 합니다:\n\n1. 상태 표시줄 아이콘을 클릭합니다.\n\n![이미지](/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_5.png)\n\n2. 팝업이 나타납니다. '허용' 옵션을 선택합니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_6.png\" />\n\n완료되었습니다! 이제 모든 파일을 저장할 때마다 ESLint 규칙을 자동으로 수정할 수 있습니다.\n\n# 참고","ogImage":{"url":"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png"},"coverImage":"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트 네이티브 이미지 피커 구현에 대한 심층 탐구","description":"","date":"2024-05-12 22:16","slug":"2024-05-12-DeepDiveintoImplementingreact-native-image-picker","content":"\n\n<img src=\"/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png\" />\n\n현대 애플리케이션에서 사용자가 프로필에 사진을 업로드할 수 있는 기능을 제공하는 것은 표준입니다. 사용자들이 계속해서 앱을 방문할 수 있도록 최상의 경험을 제공하는 것이 매우 중요합니다.\n\nReact-Native로 모바일 앱을 개발 중이라면, react-native-image-picker 덕분에 이것을 아주 쉽게 구현할 수 있습니다.\n\n# 내 앱은 어떤 이미지 형식을 지원해야 할까요?\n\n\n\n첫 번째로 해야 할 질문은 \"내 앱이 지원해야 하는 이미지 유형은 무엇인가?\"입니다. 다양한 이미지 유형이 존재하며, 모든 종류의 사람들을 대상으로 하는 앱을 원한다면 특히 혼란스럽고 압도될 수 있습니다. React Native는 이를 우리에게 아주 쉽게 만들어줍니다.\n\n그래서 선택지를 좁힐 수 있습니다. 이 목록에 언급되지 않은 것 중 하나는 Base64입니다. Base64는 이진 데이터를 나타내는 이진-텍스트 인코딩 체계의 한 그룹입니다.\n\n# React-Native-Image-Picker\n\n## React Native Image Picker란 무엇인가요?\n\n\n\nReact-Native-Image-Picker은 React Native 모듈로, 기기 라이브러리에서 미디어를 선택하거나 직접 카메라에서 가져 올 수 있도록 네이티브 UI를 사용할 수 있게 해줍니다. 현재 약 60,000명의 개발자가 사용 중이며, 제공되는 기능이 매우 견고하기 때문에 많은 사람들이 사용하고 있습니다.\n\n## React-Native-Image-Picker 설치 및 설정하는 방법\n\n먼저 패키지를 프로젝트에 설치합니다:\n\nAndroid:\n\n\n\n```js\nyarn add react-native-image-picker\n```\n\niOS:\n\n```js\nnpx pod-install ios\n```\n\nreact-native-image-picker 레포지토리에는 몇 가지 추가 설치 단계에 대한 조언이 있습니다. 그 중 일부는 다음과 같습니다:\n사용자가 사진 또는 비디오를 선택할 수 있도록 하는 경우 NSPhotoLibraryUsageDescription을 추가하세요.```\n\n\n\niOS\n\nAndroid\n\n`saveToPhotos` 속성을 `true`로 설정하지 않는 한 권한이 필요하지 않습니다.\n\niOS의 권한은 다음과 같이 test 폴더 내의 Info.plist 파일에 들어갑니다:\n\n\n\n```js\n<key>NSPhotoLibraryUsageDescription</key>\n <string>$(PRODUCT_NAME)님의 사진 갤러리에 접근하려고 합니다</string>\n<key>NSCameraUsageDescription</key>\n <string>$(PRODUCT_NAME)님의 카메라를 사용하려고 합니다</string>\r\n```\n\n## Android의 권한은 AndroidManifest.xml 파일에 작성해주세요 :\n\nReact-Native-Image-Picker 모듈은 사용자에게 작동을 위해 권한이 필요하지 않지만, 사용자가 앱에서 촬영한 이미지를 갤러리에 저장하는 옵션을 설정한 경우, 다음 권한이 필요합니다:\n\n```js\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n\n\n위에서 사용자에게 겔러리 접근 권한과 애플리케이션에서 캡처한 이미지를 사용자의 갤러리에 저장할 것인지에 대한 동의를 요청하는 것입니다.\n\n## React-Native-image-Picker 구현하기\n\n프로필 컴포넌트 Profile.js를 생성하십시오. react-native-image-picker에는 사용할 수 있는 두 가지 메서드가 있습니다. launchCamera()는 카메라를 실행하여 사진을 찍고, launchImageLibrary()는 갤러리를 실행하여 사진이나 비디오를 선택합니다. 이를 파일에 import할 것입니다.\n\nlaunchLibrary 메서드는 사용자의 갤러리를 열고 이미지 설정과 응답 두 가지 매개변수를 사용합니다.\n\n\n\n`launchCamera` 메소드는 사용자의 카메라를 실행하며 이미지의 구성 및 응답에 대한 두 개의 매개변수를 가져옵니다.\n\n`pickerResponse` 상태 변수는 이미지 피커에서의 응답을 저장하는 데 사용됩니다. `imageFromDB` 상태 변수는 데이터베이스에서 이미지를 저장하여 나중에 액세스할 수 있도록 합니다.\n\nImage 컴포넌트는 다음과 같이 사용됩니다:\n\n```js\n<Card style=//카드 스타일, 특히 이미지에 고도를 원하는 경우>\n    <Image\n        source={\n          uri: `data:image/*;base64,${imageFromDB}`,\n          width: ..,\n          height: ...,\n        }\n        style=//추가 이미지 스타일\n    />\n</Card>\n```\n\n\n\n이 코드 라인\n\n```js\nuri: `data:image/*;base64,${imageFromDB}`,\n```\n\n은 우리가 데이터베이스에서 이미지를 렌더링하는 데 `uri` 속성을 사용하고 `image/*`가 지정된 이미지 유형을 렌더링하도록 보장합니다.\n\n또한 사용자가 갤러리 또는 카메라에 액세스하여 이미지를 업로드할 수 있도록 모달을 활성화하는 프레서블 아이콘을 추가할 수도 있습니다.\n\n\n\n```js\n <Pressable\n    style={({ pressed }) => [\n        {\n            ...styles.cameraIconView,\n            opacity: pressed ? 0.5 : 1,\n        },\n    ]}\n    onPress={() => setVisible(true)}\n>\n    <IconComponent\n        source={icons.camera}\n        tintColor={themeColor.primaryWhite}\n    />\n</Pressable>\r\n```\n\n저희는 프로필 컴포넌트에 모달을 넣고 필요한 모든 속성을 전달하고 싶어요.\n\n```js\r\n<ImagePickerModal\n    isVisible={visible}\n    onClose={() => setVisible(false)}\n    onImageLibraryPress={onImageGalleryPress}\n    onCameraPress={onCameraPress}\n/>\r\n```\n\n마지막으로 ImagePickerModal 컴포넌트를 만들어야 할 것입니다.\n\n\n\n데이터베이스로 이미지를 그대로 보내기보다 base64 이미지를 사용하는 이유를 궁금해하는 분들을 위해, base64 인코딩을 사용하면 데이터 크기를 최대 33%까지 줄일 수 있으며 많은 프로그래밍 언어가 base64 인코딩을 내장 지원하고 있습니다.\n\n# 페이지 상태에 따라 이미지를 조건부로 렌더링하기\n\n이미지를 렌더링하기 위해 우리는 다음 3가지 경우를 살펴볼 것입니다:\n\n- 사용자가 로그인하지 않았을 때\n- 사용자가 로그인했지만 프로필 이미지가 없는 경우\n- 사용자가 로그인하고 프로필 이미지가 있는 경우\n- 사용자가 로그인하고 방금 프로필 이미지를 변경한 경우\n\n\n\n```js\nuserLoggedIn ? {\n  uri ? (\n    <Card style={styles.userDBImageView}>\n        <Image\n            source={\n                uri: uri,\n                width: styles.userDBImage.width,\n                height: styles.userDBImage.height,\n            }\n            style={styles.userDBImage}\n        />\n    </Card>\n) : imageFromDB ? (\n    <Card style={styles.userDBImageView}>\n        <Image\n            source={\n                uri: `data:image/*;base64,${imageFromDB}`,\n                width: styles.userDBImage.width,\n                height: styles.userDBImage.height,\n            }\n            style={styles.userDBImage}\n            // tintColor={colors.primaryWhite}\n        />\n    </Card>\n) : (\n    <Card\n        style={\n            ...styles.userImageView,\n            marginTop: '8%',\n            width: '25%',\n        }\n    >\n        <Image\n            source={icons.profileImage}\n            style={styles.userImage}\n            tintColor={colors.primaryWhite}\n        />\n    </Card>\n)\n) : (\n<Card style={styles.userImageView}>\n    <Image\n        source={icons.profileImage}\n        style={styles.userImage}\n        tintColor={colors.primaryWhite}\n    />\n</Card>\n         )\n}\n```\n\n## 사용자가 로그인하지 않은 경우\n\n마지막 컴포넌트는 사용자가 로그인하지 않았을 때 호출될 것이므로 해당 이미지의 소스는 기본/대체 이미지여야합니다.\n\n## 사용자는 로그인했지만 프로필 이미지가 없습니다\n\n\n\n사용자가 로그인했지만 프로필 이미지가 없는 경우, 코드에서 두 번째로 나타나는 그림과 동일한 이미지를 표시할 것입니다.\n\n## 사용자가 로그인하고 프로필 이미지가 있는 경우\n\n두 번째 구성 요소는 사용자가 로그인했는지와 데이터베이스에서 이미지를 가지고 있는지 확인한 후 렌더링됩니다.\n\n## 사용자가 로그인하고 방금 프로필 이미지를 변경한 경우\n\n\n\n이 코드 조각은 먼저 사용자가 uri 변수를 사용하여 새 이미지를 선택/캡처했는지 확인합니다. uri에 값이 있는 경우, 삼항 연산자에서 다른 변수들 보다 우선순위가 높기 때문에 즉시 표시됩니다.\n\n# 결론\n\nreact-native-image-picker를 사용하면 이미지 업로드 기능을 쉽게 구현할 수 있습니다. 사용자가 이미지와 비디오를 업로드할 수 있는 애플리케이션을 쉽게 구축할 수 있을 정도로 강력합니다. 사용자 경험을 즐겁게 만들어주지만, 더 중요한 점은 개발자 경험까지 더욱 즐겁게 만들어준다는 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png"},"coverImage":"/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png","tag":["Tech"],"readingTime":6},{"title":"함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기","description":"","date":"2024-05-12 22:15","slug":"2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents","content":"\n\n<img src=\"/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png\" />\n\nReact Higher Order Components (HOC)은 React 애플리케이션에서 코드 재사용, 로직 공유 및 추상화를 위한 강력한 패턴입니다. 보통 클래스 컴포넌트와 관련이 있지만, 고차 컴포넌트는 함수형 컴포넌트와 함께 효율적으로 활용할 수도 있습니다. 이 글에서는 함수형 컴포넌트에서 고차 컴포넌트를 구현하고 활용하는 방법에 대해 살펴보겠습니다.\n\n고차 컴포넌트 이해하기:\n\n고차 컴포넌트는 컴포넌트를 인수로 받아 향상된 기능을 갖춘 새로운 컴포넌트를 반환하는 함수입니다. 인증, 권한 부여, 로깅 및 상태 관리와 같은 교차 관심사를 여러 컴포넌트에서 캡슐화하고 공유할 수 있도록 합니다.\n\n\n\n함수형 컴포넌트에서 고차 컴포넌트 구현하기:\n\n함수형 컴포넌트에서는 고차 컴포넌트를 일반 JavaScript 함수로 구현하며, 이 함수는 컴포넌트를 인수로 받아 새로운 함수형 컴포넌트를 반환합니다.\n\n다음 예제를 살펴보겠습니다:\n\n```js\nimport React from 'react';\n\nconst withLogging = (WrappedComponent) => {\n  const WithLogging = (props) => {\n    console.log('Component rendered:', WrappedComponent.name);\n    return <WrappedComponent {...props} />;\n  };\n\n  return WithLogging;\n};\n\nconst MyComponent = () => {\n  return <div>Hello, World!</div>;\n};\n\nconst EnhancedComponent = withLogging(MyComponent);\n\nexport default EnhancedComponent;\n```\n\n\n\n이 예시에서 withLogging은 렌더링된 컴포넌트의 이름을 콘솔에 로그하는 Higher Order Component입니다. 이는 컴포넌트(WrappedComponent)를 인수로 받아 원래 컴포넌트를 래핑하고 로깅 기능을 추가한 새로운 함수형 컴포넌트(WithLogging)를 반환합니다.\n\n함수형 컴포넌트에서 Higher Order Components 사용하기:\n\n한 번 Higher Order Component가 정의되면, 그것을 사용하여 함수형 컴포넌트를 래핑하여 향상시킬 수 있습니다. 다음은 withLogging Higher Order Component를 함수형 컴포넌트와 함께 사용하는 방법입니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = () => {\n  return <div>안녕, 세상!</div>;\n};\n\nconst EnhancedComponent = withLogging(MyComponent);\n\nconst App = () => {\n  return (\n    <div>\n      <EnhancedComponent />\n    </div>\n  );\n};\n\nexport default App;\n```\n\n\n\n이 예시에서 MyComponent는 일반 함수형 컴포넌트이고, EnhancedComponent는 withLogging Higher Order Component를 MyComponent에 적용한 결과입니다. App 컴포넌트 내에서 EnhancedComponent를 렌더링하면 감싸진 컴포넌트의 이름(MyComponent)이 콘솔에 기록됩니다.\n\n함수형 컴포넌트와 Higher Order Components의 장점:\n\n- 코드 재사용을 촉진하고 교차 관심사의 캡슐화를 장려합니다.\n- 로직을 표현으로부터 분리하여 관심사의 분리를 가능하게 합니다.\n- 여러 Higher Order Components를 함께 조합할 수 있는 합성 기능을 향상시킵니다.\n- 컴포넌트를 보다 집중적이고 격리된 상태로 테스트할 수 있도록 돕습니다.\n\n결론\n\n\n\n리액트 고차 컴포넌트는 재사용 가능한 로직과 동작을 확장하는 강력한 방법을 제공합니다. 공통 기능을 고차 컴포넌트 내에 캡슐화함으로써, 개발자들은 리액트 애플리케이션에서 코드 구성, 유지 관리성, 그리고 재사용성을 향상시킬 수 있습니다. 인증, 로깅 또는 기타 교차 관심사를 구현하려는 경우, 고차 컴포넌트는 기능 컴포넌트 강화를 위한 유연하고 효과적인 해결책을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png"},"coverImage":"/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 네이티브에서 페이지와 함께 페이지네이션하기","description":"","date":"2024-05-12 22:14","slug":"2024-05-12-PaginationinReactNativewithPage","content":"\n\n소개:\n\n페이지네이션은 React Native에서 대량의 데이터 목록을 효율적으로 관리하고 표시할 수 있게 해주는 강력한 기술입니다. 이 글에서는 FlatList와 페이지네이션 버튼을 사용하여 고급 페이지네이션을 구현하는 방법에 대해 알아볼 것입니다. 페이지네이션의 논리, 각 페이지별 데이터 검색 방법 및 렌더링 프로세스의 최적화에 대해 논의할 것입니다. 함께 React Native 페이지네이션을 마스터해봅시다!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Vj09FpPeRuOC7tDLGpBrsg.gif)\n\n```js\n..... 구성 요소 구조 ....\nconst handlePageClick = (p: number) => setCurrentPage(p);\n\n  const renderItem = ({item}: {item: ScoreCard}) => {\n    return <Card item={item} key={item.id} />;\n  };\n\nreturn (\n<SafeAreaView style={styles.container}>      \n      <FlatList\n        data={items}\n        renderItem={renderItem}\n        keyExtractor={item => item.id}\n        ListEmptyComponent={handleEmpty}\n        windowSize={10} // VirtualizedList의 기능 추가\n        refreshControl={\n          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />\n        }\n      />\n      <View style={styles.paginationContainer}>\n        {renderPaginationButtons()}\n      </View>\n    </SafeAreaView>\n)\n...\n```\n\n\n\n- 페이지네이션 로직\n\n저희 페이지네이션 구현의 핵심은 'Institution' 컴포넌트에 있습니다. 이 컴포넌트는 'useState'와 같은 React 훅을 사용하여 중요한 상태 변수를 관리합니다. 'currentPage' 상태는 현재 표시되는 페이지를 나타내고, 'totalPages'는 전체 목록에 대한 총 페이지 수를 저장합니다. 'itemsPerPage'를 설정하여 페이지 당 표시할 항목 수를 결정하여 로딩 프로세스를 최적화합니다.\n\n```js\nconst [totalPages, setTotalpages] = useState(0);\nconst [currentPage, setCurrentPage] = useState(0);\nconst [items, setItems] = useState([]);\nconst [refreshing, setRefreshing] = useState(false);\nconst itemsPerPage = 16;\n```\n\n2. 각 페이지의 데이터 가져오기\n\n\n\n'fetchData' 함수는 페이지네이션 로직의 중요한 부분입니다. 'Institution' 컴포넌트가 마운트되거나 'currentPage'가 변경될 때마다 해당 함수를 호출하여 현재 페이지의 데이터를 검색합니다. 우리는 데이터를 가져오는 작업을 처리하는 'fetcher' 유틸리티 함수를 사용합니다.\n\n```js\nuseEffect(() => {\n  fetchData();\n}, [currentPage]);\n\nasync function fetchData() {\n  setRefreshing(true);\n  try {\n    let response = await fetcher(currentPage, itemsPerPage);\n    setTotalpages(response.metadata.total / itemsPerPage);\n    let data: [] = response.results;\n    setItems(data);\n    setRefreshing(false);\n  } catch (error) {\n    setRefreshing(false);\n    console.log(error);\n  }\n}\n```\n\n3. 페이지네이션 버튼 처리\n\n사용자가 페이지별 목록을 탐색할 수 있도록 하기 위해, 페이지네이션 버튼을 렌더링할 때 TouchableOpacity 요소를 사용합니다. 'renderPaginationButtons' 함수는 'currentPage', 'totalPages', 그리고 표시할 최대 버튼 수('maxButtonsToShow')를 기반으로 표시할 페이지를 계산한 다음 적절한 버튼을 생성합니다.\n\n\n\n```js\nconst renderPaginationButtons = () => {\n  const maxButtonsToShow = 5;\n  let startPage = Math.max(0, currentPage - Math.floor(maxButtonsToShow / 2));\n  let endPage = Math.min(totalPages, startPage + maxButtonsToShow - 1);\n\n  if (endPage - startPage + 1 < maxButtonsToShow) {\n    startPage = Math.max(0, endPage - maxButtonsToShow + 1);\n  }\n\n  const buttons = [];\n\n  for (let i = startPage; i <= endPage; i++) {\n    buttons.push(\n      <TouchableOpacity\n        key={i}\n        onPress={() => handlePageClick(i)}\n        style={[\n          styles.paginationButton,\n          i === currentPage ? styles.activeButton : null,\n        ]}>\n        <Text style={{color: 'white'}}>{i}</Text>\n      </TouchableOpacity>,\n    );\n  }\n\n  return buttons;\n};\n```\n\n4. Pull-to-Refresh 및 데이터 없음 처리\n\n더 나은 사용자 경험을 제공하기 위해 'RefreshControl'를 사용하여 pull-to-refresh 기능을 구현했습니다. 사용자는 필요할 때 목록을 수동으로 새로 고칠 수 있습니다. 추가로, 표시할 기관이 없는 시나리오를 처리하기 위해 '기관 없음' 메시지를 렌더링합니다.\n\n```js\nconst handleRefresh = () => {\n  setRefreshing(true);\n  setTimeout(() => setRefreshing(false), 1000);\n};\n\nconst handleEmpty = () => {\n  return <Text>기관이 없습니다!</Text>;\n};\n```\n\n\n\n5. 더 나은 사용자 경험을 위한 스타일링\n\n저희는 컴포넌트에 시각적 매력을 더하기 위해 StyleSheet를 활용합니다. 페이지네이션 버튼은 활성화될 때 색상과 크기가 변경되어 사용자에게 시각적 피드백을 제공하여 전체 앱 경험을 향상시킵니다.\n\n```js\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  paginationContainer: {\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingVertical: 8,\n    backgroundColor: 'transparent',\n  },\n  paginationButton: {\n    justifyContent: 'center',\n    alignItems: 'center',\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    marginHorizontal: 4,\n    backgroundColor: 'gray',\n  },\n  activeButton: {\n    backgroundColor: '#22c55d',\n    width: 50,\n    height: 50,\n    borderRadius: 25,\n  },\n  buttonText: {\n    color: 'white',\n  },\n});\n```\n\n맺음말\n\n\n\n이 코드에 대한 링크는 여기에서 확인할 수 있습니다 - ` paginate. React Native pagination을 FlatList와 페이지 버튼으로 마스터하여 대량의 데이터 목록을 손쉽게 처리하여 부드러운 성능과 더 나은 사용자 경험을 보장할 수 있습니다. 페이지네이션은 렌더링을 크게 최적화하며 네트워크 리소스 부하를 줄이고 전반적인 앱 대응성을 향상시킵니다. React Native 애플리케이션에서 고급 페이지네이션을 구현하는 것은 고품질이고 성능이 우수한 모바일 앱을 제공하는 데 유용한 기술입니다.","ogImage":{"url":"/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png"},"coverImage":"/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png","tag":["Tech"],"readingTime":5},{"title":"React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다","description":"","date":"2024-05-12 22:13","slug":"2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment","content":"\n\n![이미지](/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png)\n\n페이스북에서 개발한 JavaScript 라이브러리인 React는 탄생 이후 현대 웹 개발의 최전선에 있었습니다. 각 버전마다 혁신적인 기능을 도입하여 견고한 사용자 인터페이스를 더 쉽고 효율적으로 구축할 수 있게 해 왔습니다. 이제 React 19가 출시되면서 커뮤니티는 최신 기능과 혁신에 대한 기대감으로 들뜹니다. 함께 React 19가 가져다주는 흥미로운 새로운 기능을 살펴보겠습니다.\n\n# 동시 렌더링\n\nReact 19의 가장 중요한 진보 중 하나는 동시 렌더링의 도입입니다. 이 혁신적인 기능을 통해 React는 여러 작업을 동시에 처리할 수 있어 응용 프로그램의 성능과 응답 시간을 크게 향상시킵니다. 동시 렌더링을 통해 React는 UI의 가장 중요한 부분을 렌더링하는 것을 우선시하고 덜 중요한 업데이트는 연기함으로써 더 부드러운 사용자 경험과 더 빠른 로드 시간을 제공할 수 있습니다.\n\n\n\n# 데이터 가져오기를 위한 Suspense\n\nReact 19에서는 이전 버전에서 소개된 suspense 개념을 발전시켜 데이터 가져오기에 특화된 suspense를 소개합니다. 이 강력한 메커니즘은 개발자가 로딩 상태와 오류 처리를 선언적으로 지정할 수 있도록 해줍니다. 이로써 API로부터 데이터를 가져오는 등의 비동기 작업을 간편하게 관리할 수 있습니다. React 생태계에 suspense를 원활하게 통합함으로써, 개발자는 복잡한 상태 관리 라이브러리를 사용하지 않고도 더 직관적이고 원활한 사용자 경험을 제공할 수 있습니다.\n\n# 개선된 서버 측 렌더링 (SSR)\n\n서버 측 렌더링은 빠른 초기 페이지 로드를 제공하고 SEO를 개선하는 데 필수적입니다. React 19에서는 SSR 능력에 상당한 향상이 이루어져 서버 렌더링된 애플리케이션을 구축하기가 더욱 쉬워졌습니다. 스트리밍 및 수분화 기능이 개선되어, React 19가 개발자에게 클라이언트 및 서버 환경 모두에 완벽하게 최적화된 동적 대화형 경험을 제공할 수 있게 되었습니다.\n\n\n\n# 더 나은 TypeScript 지원\n\nTypeScript는 초기에 오류를 미리 파악하고 코드 유지 관리를 개선하는 능력으로 React 커뮤니티에서 점차 인기를 얻고 있습니다. React 19는 TypeScript 지원을 한층 더 강화하여 더 나은 유형 추론, 인기 있는 TypeScript 기능과의 향상된 호환성, 향상된 개발자 도구를 제공합니다. 경험 많은 TypeScript 사용자이든 막 시작한 사용자이든, React 19를 통해 React 프로젝트에서 정적 유형의 혜택을 누리기가 이전보다 쉬워졌습니다.\n\n# 번들 크기 개선을 위한 선택적 기능\n\n번들 크기를 최적화하고 성능을 개선하기 위해 React 19는 선택적으로 필요한 컴포넌트와 기능만 포함할 수 있는 옵션 기능을 도입했습니다. 이러한 세부적인 번들링 접근법은 애플리케이션이 가볍고 효율적으로 유지되도록 보장하여 불필요한 오버헤드를 최소화하고 상호 작용 시간을 줄입니다. React 19가 개발자들에게 번들 크기를 더 많은 제어권을 부여함으로써 더 빠르고 더 스트리밍된 경험을 사용자에게 제공할 수 있도록 돕습니다.\n\n\n\n# 결론\n\nReact 19 버전을 통해 React 팀은 한 번 더 웹 개발의 기준을 높였으며, 사용자 인터페이스를 구축하는 방식을 바꿀 혁신적인 기능과 개선 사항을 제공했습니다. 병행 렌더링부터 향상된 TypeScript 지원까지, React 19는 개발자들에게 빠르고 기능이 풍부한 응용 프로그램을 만드는 데 필요한 도구를 제공합니다. React 생태계가 계속 발전함에 따라 확실한 것은 웹 개발의 미래가 이전보다 밝아졌다는 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png"},"coverImage":"/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png","tag":["Tech"],"readingTime":2},{"title":"CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기","description":"","date":"2024-05-12 22:12","slug":"2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt","content":"\n\n## AWS S3를 사용하여 GitHub Actions로 React.js 앱을 배포하고 호스팅하는 포괄적인 가이드\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png)\n\nAWS S3와 GitHub Actions의 강력함을 느껴보세요. 이 포괄적인 가이드는 GitHub Actions를 사용하여 AWS S3에 React.js 앱을 배포하고 호스팅하는 간소화된 과정을 안내합니다. 워크플로우를 간소화하고 확장성을 확보하여 사용자에게 탁월한 경험을 제공하세요. AWS S3 및 GitHub Actions의 잠재력을 펼쳐보세요!\n\n# 목표:\n\n\n\n- React.js 애플리케이션의 배포 프로세스를 간단하게 만들어보세요.\n- GitHub Actions를 활용하여 배포 파이프라인을 자동화하세요.\n- AWS S3를 사용하여 React.js 앱을 확장 가능하게 호스팅하세요.\n- 신뢰할 수 있는 배포를 통해 사용자에게 뛰어난 경험을 제공하세요.\n- 효율적인 배포와 호스팅을 위한 지식과 도구로 개발자를 지원하세요.\n\n# 요구 사항 :\n\n- React.js에 대한 기본적인 이해\n- GitHub 계정으로 저장소 호스팅 및 GitHub Actions 사용\n- AWS S3 계정으로 React.js 애플리케이션 호스팅\n- GitHub 및 AWS S3에 대한 액세스 및 권한\n- YAML 설정에 익숙함\n- 명령 줄 인터페이스(CLI) 능숙함\n\n# 따라 할 단계:\n\n\n\n- IAM 사용자를 생성하고 AmazonS3FullAccess 정책을 연결하세요.\n- 비밀 액세스 키의 .csv 파일을 다운로드하세요.\n- S3 버킷을 생성하세요: ACL을 활성화하고 모든 공개 액세스 차단 옵션을 해제하세요.\n- GitHub으로 이동하여 공개 저장소를 만드세요.\n- 설정으로 이동하여 시크릿을 클릭하세요.\n- 다음을 저장할 새로운 리포지토리 시크릿 생성: 액세스 키 ID(AWS_ACCESS_KEY_ID), 비밀 액세스 키(AWS_SECRET_ACCESS_KEY) 및 버킷 이름(AWS_S3_BUCKET).\n- React 애플리케이션을 만들고 GitHub 워크플로우를 추가하세요.\n- GitHub에 푸시하세요.\n- 작업 섹션으로 이동하여 애플리케이션 빌드부터 S3로 업로드까지의 모든 단계를 확인하세요.\n- S3의 정적 파일 호스팅을 활성화하고 호스팅된 웹 앱을 볼 수 있는 엔드포인트를 열어보세요.\n\n## 단계 1: IAM 사용자 생성\n\n![이미지 제목](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_1.png)\n\n![이미지 제목](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_2.png)\n\n\n\n<img src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_3.png\" />\n\n## 단계 2: 새로 생성된 사용자의 보안 자격 증명 섹션에서 액세스 키 생성\n\n<img src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_4.png\" />\n\n## 단계 3: S3 버킷 만들기\n\n\n\n버킷에 이름을 지어주시고 ACL을 활성화해주세요.\n\n<img src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_5.png\" />\n\n모든 공개 액세스 차단 해제를 선택 해제하고 경고를 읽은 후에 선택하세요.\n\n<img src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_6.png\" />\n\n\n\n위의 표를 Markdown 형식으로 변경해주세요.\n\n\n\n## 5단계: 레포지토리의 설정으로 이동하여 왼쪽 섹션에서 시크릿을 선택합니다.\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_8.png)\n\n## 6단계: 새로운 레포지토리 시크릿을 클릭하고 모든 세부 정보를 추가합니다.\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_9.png)\n\n\n\n\n![Image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_10.png)\n\n![Image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_11.png)\n\nAfter creating this, you can see like this\n\n![Image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_12.png)\n\n\n\n## 단계 7: React 앱을 만들고 GitHub Actions 워크플로우 추가하기\n\n```js\nnpx create-react-app react-gh-action-s3\n```\n\nReact 앱을 만든 후에, \".github\\workflows\" 라는 폴더를 하나 추가하고 새 파일을 만들어 \"main.yaml\"이라고 이름 짓습니다. 아래 코드를 main.yaml 파일에 복사하세요:\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_13.png)\n```\n\n\n\n```yaml\nname: 웹사이트 업로드\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: 코드 확인\n        uses: actions/checkout@v2\n\n      - name: Node.js 설정\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: 의존성 설치\n        run: npm install\n\n      - name: 앱 빌드\n        run: npm run build\n\n      - name: S3에 업로드\n        uses: jakejarvis/s3-sync-action@master\n        with:\n          args: --acl public-read\n        env:\n          SOURCE_DIR: build/\n          AWS_S3_BUCKET: ${ secrets.AWS_S3_BUCKET }\n          AWS_ACCESS_KEY_ID: ${ secrets.AWS_ACCESS_KEY_ID }\n          AWS_SECRET_ACCESS_KEY: ${ secrets.AWS_SECRET_ACCESS_KEY }\n```\n\n## 단계 8: GitHub에 추가하기\n\n<img src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_14.png\" />\n\n## 단계 9: Action 섹션으로 이동하여 프로세스 보기하기\n\n\n\n코드를 업로드한 후 Action 섹션으로 이동하여 GitHub Actions가 코드를 빌드하고 S3로 업로드하는 과정을 확인해보세요. 처음에는 시간이 조금 걸릴 수 있지만 첫 번째 푸시 이후에는 변경 사항이 처음과 비교했을 때 적으므로 시간이 줄어들 것입니다.\n\n클릭한 후 최근 커밋을 볼 수 있습니다. 그리고 빌드를 클릭하세요. 진행 중인 모든 프로세스를 볼 수 있습니다. 모든 작업이 완료되면 다음을 볼 수 있습니다:\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_15.png)\n\n이것은 모든 프로세스가 완료되었고 빌드 파일이 aws에서 제공된 버킷 이름으로 업로드되었음을 의미합니다.\n\n\n\n## 단계 10: S3를 웹 호스팅으로 구성\n\nGitHub에서 업로드된 파일을 여기서 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_16.png)\n\n이제 프로퍼티 섹션으로 이동하여 맨 아래로 스크롤합니다. 정적 웹사이트 호스팅 옵션을 볼 수 있습니다. 편집을 클릭하고 활성화하고 index.html을 index 문서 섹션에 작성하십시오. 그런 다음 변경 사항을 저장하십시오.\n\n\n\n![Main image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_17.png)\n\n이제 정적 웹사이트 호스팅 섹션에 링크가 보입니다. 새 탭에서 열어보세요.\n\n![Image 18](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_18.png)\n\n![Image 19](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_19.png)\n\n\n\nReact 애플리케이션이 이제 실시간으로 작동 중이에요. 코드를 변경하고 GitHub에 푸시하면, 여기서 몇 초 내에 새로운 변경 사항이 보입니다.\n\n이 게시물을 읽어주셔서 감사합니다! AWS S3에서 GitHub Actions를 사용하여 React.js 애플리케이션을 배포하고 호스팅하는 여정에서 도움이 되었기를 바랍니다. 질문, 피드백 또는 제안이 있으시면 언제든지 연락해주세요. 여러분의 의견은 소중하고 큰 도움이 됩니다.\n\n## 추가 읽을거리:","ogImage":{"url":"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png","tag":["Tech"],"readingTime":6},{"title":"Nextjs 프로젝트에서 ApexCharts를 사용하는 방법","description":"","date":"2024-05-12 22:10","slug":"2024-05-12-HowToUseApexChartsinaNextjsProject","content":"\n\n![이미지](/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png)\n\nNext.js는 확실히 프런트엔드 랜드스케이프에서 주요 메타 프레임워크 중 하나입니다. 그러나 인기 있는 차트 라이브러리인 ApexCharts를 Next.js와 함께 사용할 때 특정 문제가 발생하는 것 같습니다. 이 글에서는 그 문제가 무엇인지와 해결 방법에 대해 논의하겠습니다.\n\n# 새 프로젝트를 초기화하는 방법을 살펴봅시다\n\n다음은 새 Next.js 프로젝트를 초기화하는 명령 프롬프트입니다(이미 초기화하는 방법을 잘 알고 계실 것 같지만, 문서를 열 필요 없이 편리하게 확인하실 수 있도록 제공드립니다)\n\n\n\n```js\n#npm\nnpx create-next-app@latest\n\n#pnpm\npnpm create next-app\n```\n\nApexCharts를 위한 필요한 의존성을 모두 설치하는 것을 잊지 마세요. 리액트 래퍼를 포함하면 됩니다.\n\n```js\n#npm\nnpm i react-apexcharts apexcharts\n\n#pnpm\npnpm i react-apexcharts apexcharts\n```\n\n우리는 기존의 신뢰받는 페이지와 새롭고 반짝이는 앱 디렉토리를 함께 사용할 것입니다. 두 가지의 구현 차이는 크지 않으니 시작해 봅시다.```\n\n\n\n두 가지 디렉토리 유형 중에서, 저는 개인적으로 폴더 구조를 이렇게 선호합니다 (특히 components 폴더 위치). 여러분은 자신의 구조 선호도에 맞게 조정하시면 됩니다.\n\n```js\nnextjs_project\n├── node_modules\n├── public\n└── src\n    ├── components\n    └── pages/app\n```\n\n# 그래프 컴포넌트 만들기\n\ncomponents 폴더 안에, charts.tsx/jsx 파일을 만들어 보겠습니다.\n\n\n\n```js\n// charts.tsx/jsx\n\n'use client' // 앱 디렉토리를 사용한다면, 이 줄을 빼먹지 마세요\n\nimport dynamic from \"next/dynamic\";\nconst ApexChart = dynamic(() => import(\"react-apexcharts\"), { ssr: false });\n\n\nexport function ExampleChart(){\n\n    const option = {\n        chart: {\n          id: 'apexchart-example'\n        },\n        xaxis: {\n          categories: [1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999]\n        }\n      }\n\n    const series = [{\n        name: 'series-1',\n        data: [30, 40, 35, 50, 49, 60, 70, 91, 125]\n      }]\n\n    return(\n        <>\n            <ApexChart type=\"line\" options={option} series={series} height={200} width={500} />\n        </>\n    )\n    \n}\n```\n\n만약 react-apexcharts — npm (npmjs.com)에서 아래와 같이 가져오려고 한다면\n\n```js\nimport Chart from 'react-apexcharts'\n```\n\n아마도 이런 에러를 마주하게 될 것입니다```\n\n\n\n마크다운 형식을 사용하면 더 좋을 것 같아요.\n\n![HowToUseApexChartsinaNextjsProject_1](/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_1.png)\n\n혹은 터미널에서는 이렇게 보일지도 몰라요.\n\n![HowToUseApexChartsinaNextjsProject_2](/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_2.png)\n\n이 에러는 Next.js의 자동 프리랜더링(렌더링: 자동 정적 최적화 | Next.js (nextjs.org)) 때문에 발생한 것 같아요. ApexChart 라이브러리는 클라이언트 쪽에 있는 window 인터페이스에 의존하기 때문에 본문 작성 시점에는 서버에서 프리랜더링할 수 없는 것으로 보입니다.\n\n\n\n그래서 Next.js가 이 경우를 해결하기 위해 제공한 솔루션은 내장된 next/dynamic을 사용하여 동적 가져오기를 수행하고 서버 측 사전 렌더링을 중지하도록 명시적으로 구성하는 것입니다.\n\n```js\n'use client' // 전체 파일을 클라이언트 측 컴포넌트로 표시하려면 앱 디렉터리를 사용하는 경우 이 부분을 잊지 마세요\n\nimport dynamic from \"next/dynamic\";\nconst Chart = dynamic(() => import(\"react-apexcharts\"), { ssr: false });\n```\n\n# 직접 해 보세요!\n\n이것은 페이지 디렉터리를 위한 것입니다.\n\n\n\n그리고 이것은 앱 디렉토리를 위한 것입니다.\n\n지금까지 제가 전달할 내용은 여기까지입니다. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png"},"coverImage":"/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png","tag":["Tech"],"readingTime":3}],"page":"75","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}