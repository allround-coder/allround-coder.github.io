{"pageProps":{"posts":[{"title":"문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다","description":"","date":"2024-05-13 00:16","slug":"2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF","content":"\n\n만약 TypeScript를 사용해 보셨다면, 다음과 같은 컴파일 에러를 만날 기회가 많을 것입니다:\n\n만약 저와 같이, 왜 ... 음 ... 다른 누군가의 코드가 그런 식으로 에러가 발생한 이유를 전혀 모를 때가 있었다면, 이 기사는 typing 시스템에서 무슨 일이 벌어지고 있는지에 대해 더 잘 이해하도록 도와줄 수 있습니다.\n\n# JavaScript는 duck-typed입니다\n\n![error](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png)\n\n\n\n자바스크립트는 덕 타이핑을 사용하기 때문에, 함수에 모든 올바른 속성을 갖춘 값을 전달하면 값의 출처가 어디인지에 상관없이 작동합니다.\n\nTypeScript는 구조적 유형 시스템을 사용하여 이를 처리하는데, 이는 타입 체커가 유형의 속성만을 비교할 때만 신경 쓴다는 것을 의미합니다. 때로는 예상치 못한 동작으로 이어질 수 있습니다.\n\n# TypeScript 구조적 유형 모델\n\n다음 인터페이스와 함수를 고려해보세요:\n\n\n\n```js\n인터페이스 Person {\n  firstName: string;\n  lastName: string;\n}\n\nfunction getFullName(person: Person): string {\n  return `${person.firstName} ${person.lastName}`;\n}\n```\n\n이제 다른 인터페이스를 만들어 봅시다:\n\n```js\n인터페이스 계정 {\n  id: number;\n  email: string;\n  firstName: string;\n  lastName: string;\n}\n```\n\n만약 Person 대신에 Account를 getFullName() 함수에 전달하려고 하면 어떻게 될까요?\n\n\n\n```js\nconst francesco: 계정 = { id: 123, email: 'borzifrancesco@gmail.com', firstName: 'Francesco', lastName: 'Borzì' };\n\nconst result = getFullName(francesco);\n```\n\n놀랍게도… 이건 오류가 발생하지 않아요!\n\ngetFullName() 함수는 firstName과 lastName 속성을 가진 typeAccount 입력을 받습니다.\n\n다시 말해, 함수는 구조상 적절한 속성을 가진 모든 객체를 허용할 거예요 (이것이 구조화된 타이핑이라 불리는 이유에요).\n\n\n\n하지만... 사물이 다른 속성을 가지고 있어도 관심이 없습니다.\n\n## 구조적 타이핑의 결과\n\n함수를 정의할 때 항상 선언된 속성만 가지고 호출된다고 가정하는 것이 유혹적일 수 있습니다. 이것은 \"봉인된\" 유형이라고 불릴 수 있지만 TypeScript에서는 그렇지 않습니다.\n\n이를 이해하기 위해 새로운 시나리오를 고려해보십시오: 사용자가 서로 다른 색상의 보석을 모으는 게임을 구현 중이라고 상상해보겠습니다:\n\n\n\n```js\n인터페이스 GemCollection {\n  blueCount: number;\n  greenCount: number;\n  redCount: number;\n  yellowCount: number;\n  // purpleCount: number; // 나중에 구현 예정\n}\n```\n\n이제 GemCollection을 입력으로 받아 총 보석 개수를 반환하는 함수를 구현해야 합니다. 나중에 새로운 보라색이 추가될 것을 알고 있으므로 다음과 같이 함수를 유연하게 만드는 것이 좋다고 생각합니다:\n\n```js\nfunction getTotalGemsCount(gemCollection: GemCollection): number {\n  let totalGemsCount = 0;\n\n  for (const key of Object.keys(gemCollection)) {\n    totalGemsCount += gemCollection[key];\n  }\n\n  return totalGemsCount;\n}\n```\n\n논리적으로는 이해가 되고 잘 작동할 것으로 기대하지만 타입 체커는 gemCollection[key]에서 에러를 발생시킬 것입니다:```\n\n\n\n\n![Issue Screenshot](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_1.png)\n\n이 문제는, 예상했던 것과는 다르게, 타입 검사기가 gemCollection 입력이 GemCollection 인터페이스에서 지정된 속성을 최소한 가지고 있다는 것을 보장한다는 것입니다. 그러나 이는 추가 속성이 없음을 보장하지는 않습니다.\n\n우리의 함수는 다음과 같이 다시 작성되어야 합니다:\n\n```js\nfunction getTotalGemsCount(gemCollection: GemCollection): number {\n  return gemCollection.blueCount\n    + gemCollection.greenCount\n    + gemCollection.redCount\n    + gemCollection.yellowCount;\n}\n```\n\n\n\n그리고 우리는 게임에 자주색이 구현되어야 할 때에는 수동으로 gemCollection.purpleCount를 추가해주어야 합니다.\n\n# 구조적 타이핑의 장점\n\n구조적 타이핑은 잠재적인 예상치 못한 행동 때문에 주의해야 하는 것만이 아닙니다. 이것은 우리에게 유연성을 제공하는 등 여러 이점을 줄 수도 있습니다.\n\n![이미지](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_2.png)\n\n\n\n이제 우리의 보석 수집 게임에서는 특정 사용자가 수집한 보석을 반환하는 API를 쿼리해야 합니다. 어쩌면 우리는 외부 라이브러리를 사용하여 특별한 HTTP 클라이언트인 SuperHttpClient를 제공하는 이유가 있습니다.\n\n또한 호출하는 API 엔드포인트는 사용자가 존재하지 않거나 지금까지 어떤 보석도 수집하지 않은 경우에는 GemCollection 객체 또는 undefined를 반환한다고 가정합시다. 그래서 우리는 getGemsCollection() 함수를 다음과 같이 구현합니다:\n\n```js\nimport { SuperHttpClient } from '@some-library/http-client';\n\nfunction getGemsCollection(httpClient: SuperHttpClient, userId: number): GemCollection {\n  const gemsCollection = httpClient.get(`https://game.gems.org/users/${userId}/gems`) as GemCollection | undefined;\n\n  if (gemsCollection) {\n    return gemsCollection;\n  }\n\n  return {\n    blueCount: 0,\n    greenCount: 0,\n    redCount: 0,\n    yellowCount: 0,\n  };\n}\n```\n\n예를 들어, 이제 위의 함수에 대한 단위 테스트를 작성하려면 SuperHttpClient의 모의(mock)를 제공해야 합니다. 이겢은 가끔 까다로울 수 있는데, 구조적 타입화를 활용하고 함수에 더 유연한 정의를 제공할 수 있는 방법이 있습니다:\n\n\n\n```js\n인터페이스 HttpClient {\n  get: (query: string) => unknown;\n}\n\nfunction getGemsCollection(httpClient: HttpClient, userId: number): GemCollection {\n  // 구현 내용은 이전과 동일합니다\n}\n```\n\n저희는 HttpClient인터페이스를 정의했는데, 이는 getGemsCollection 함수에서 필요한 최소한의 것들을 포함한 새로운 추상화입니다. 이는 우리가 SuperHttpClient 타입의 객체를 전달할 수 있기 때문에 제품 환경에서 잘 작동할 것입니다. SuperHttpClient는 필요한 get 속성을 가지고 있기 때문입니다.\n\n또한 이것은SuperHttpClient를위한 목 라이브러리가 필요하지 않고 해당 함수를 단위 테스트할 수 있게 해 줄 것입니다. 우리의 단위 테스트는 다음과 같이 수행될 수 있습니다:\n\n```js\ndescribe('getGemsCollection', () => {\n  it('지정된 사용자에 대해 사용 가능한 보석 컬렉션을 반환해야합니다', () => {\n    // 스텁 보석 컬렉션을 준비합니다\n    const testCollection: GemCollection = {\n      blueCount: 2,\n      greenCount: 4,\n      redCount: 1,\n      yellowCount: 7,\n    };\n    // 스텁 HttpClient를 준비하고 스텁 보석 컬렉션을 반환합니다\n    const testHttpClientWithGems = {\n      get: (_url: string) => testCollection,\n    };\n\n    // getGemsCollection이 스텁 보석 컬렉션을 반환하는지 확인합니다\n    expect(getGemsCollection(testHttpClientWithGems, 10)).toEqual(testCollection);\n  });\n\n  it('지정된 사용자에 대해 사용할 수 없는 경우 새로운 빈 보석 컬렉션을 반환해야합니다', () => {\n    // 아무것도 반환하지 않는 스텁 HttpClient를 준비합니다\n    const testHttpClientWithoutGems = {\n      get: (_url: string) => undefined,\n    };\n\n    // getGemsCollection이 새로운 빈 보석 컬렉션을 반환하는지 확인합니다\n    expect(getGemsCollection(testHttpClientWithoutGems, 10)).toEqual({\n      blueCount: 0,\n      greenCount: 0,\n      redCount: 0,\n      yellowCount: 0,\n    });\n  });\n});\n```\n\n\n\n새 HttpClient 추상화 덕분에 로직과 유닛 테스트를 써드 파티 라이브러리에서 제공되는 HTTP 클라이언트 구현으로부터 분리할 수 있게 되었어요.\n\n팁: 위 구현 및 유닛 테스트를 심플하게 유지하여 Structural Typing의 잠재력을 보여주었어요. 실제 시나리오에서는 다르게 처리할 부분이 여러 가지 있을 거예요. 위 코드는 주로 학습용이라고 생각해주세요.\n\n# 결론\n\n- 자바스크립트는 덕 타이핑을 사용합니다: 개체가 할 수 있는 일은 해당 메서드 또는 속성이 있는지에 달려있고, 특정 유형에 의존하지 않아요;\n- 이러한 동적 특성을 관리하기 위해 TypeScript는 Structural Typing을 사용하며, 개발자는 그 작동 방식을 이해해야 해요;\n- Structural Typing은 예상치 못한 동작이 발생할 수 있음에 주의해야 해요;\n- Structural Typing은 더 큰 유연성을 제공합니다. 개발자는 이를 활용하여 새로운 추상화를 만들어 관심사 분리를 장려하고 전체 코드 아키텍처를 개선할 수 있어요.\n\n\n\n## 참고 사항\n\nDan Vanderkam이 쓴 Effective TypeScript 책에서 영감을 받았습니다.","ogImage":{"url":"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png"},"coverImage":"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png","tag":["Tech"],"readingTime":6},{"title":"앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다","description":"","date":"2024-05-13 00:13","slug":"2024-05-13-Angularisnotforeveryoneandprobablynotforyou","content":"\n\n![이미지](/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png)\n\n2023년, Angular 팀은 커뮤니티에서 요청한 중요한 변경 사항들을 많이 반영했고, 정말 멋진 일이죠. 하지만 항상 그랬던 것은 아니었습니다.\n\n이 이야기에서 나는 4년 동안 Angular을 사용하면서 얻은 경험에 대해 이야기하고 싶습니다.\n\n우선, Angular은 애플리케이션을 개발하는 데 처음으로 선택할 기술이 되지 않아야 한다고 생각합니다.\n\n\n\n앵귤러가 발생시키는 문제와 개발자 및 팀 빌딩에 미치는 영향을 강조하고 싶어요. 이를 식별한 문제들에 대한 해결책도 제시하려고 해요. 이미 앵귤러를 사용하거나 사용하고 싶다면 도움이 될 거예요.\n\n아쉽게도 어떤 이유로 인해 일부 팀이나 회사들은 업그레이드를 미루는 경우가 있어요. 따라서 여기서 설명한 일부 문제는 여전히 관련이 있을 수 있어요.\n\n신입 개발자라면 이 글이 유용할 것이며 여러분이 첫 개발 스택을 선택하는 데 도움이 될 걸 거예요.\n\n# 편리함의 함정\n\n\n\n앵귤러는 라이브러리가 아닌 UI 프레임워크로 알려져 있어요. 앵귤러는 프론트엔드 애플리케이션 개발에 대한 자체 포괄적인 솔루션으로 위치하고 있어요. 앱마다 \"기술의 동물원\"같은 것은 없고, 모든 것이 일관되고 단조로운데, 이에는 단점도 있어요. 앵귤러가 제공하는 편의성에 익숙해지면, 나중에 그것들을 포기하기가 더 어려워질 수 있어요.\n\n## ReactiveForms\n\n한 때, 앵귤러 팀이 제안한 접근 방식, 폼과 해당 컨트롤을 HTML 템플릿과 JS 컨트롤러로 분리하는 것은 정말 폼 개발에 편리했던 것이 증명되었어요.\n\n그 문제는 다르네요. ReactiveForms에서 제공하는 유효성 검사에 의지하는 것에 너무 익숙해져서, HTML이 입력 필드를 유효성 검사하는 데 필요한 모든 속성을 제공한다는 것을 잊어버리곤 해요 — min, max, pattern, required, read-only 등.\n\n\n\n이 문제는 무엇인가요? — Angular을 넘어서면 ReactiveForms이 독립 라이브러리로 존재하지 않는다는 것을 알게 됩니다. 폼 개발 방법을 다시 배워야 할 것입니다 — 이벤트 (제출, 변경) 및 입력 필드 속성.\n\n## 애플리케이션 빌드\n\n애플리케이션 빌드를 사용자 정의할 필요가 없습니다. 그냥 \"build\" 또는 \"serve\" 명령을 실행하여 시작하면 됩니다. 빌더의 webpack.config.js 또는 vite.config.js 구성 파일을 보지 못할 것입니다.\n\n네 말씀하세요:\n\n\n\n- 어떻게 귀하의 애플리케이션이 구성되었나요?\n- 어떤 파일이 진입 지점인가요?\n- 어떤 도구가 귀하의 애플리케이션을 빌드하나요?\n- SCSS 파일이 CSS로 변환되는 방법은 무엇인가요?\n- HRM은 어떻게 작동하나요?\n\nAngular만 사용하면 애플리케이션을 빌드하는 기술을 키우는 성장 단계를 놓치게 될 거예요. Webpack, Gulp, Rollup, Vite, Esbuild 등에 대해 알지 못할 거예요. 만약 Angular 없이 HTML과 SCSS로 간단한 웹 페이지를 만들라고 하면, 아마 할 수 없을 거예요.\n\n## HTTP 클라이언트\n\n이것은 최근 XHR2 기능을 활용하여 Observable 패턴을 사용하는 XHR을 감싸주는 편리한 래퍼입니다. 이것을 통해 다중 매개변수로 쿼리를 생성하고, 쿼리의 진행 상황을 추적하며, 단 하나의 매개변수로 응답을 원하는 데이터 유형으로 변환할 수 있습니다.\n\n\n\n하지만 앵귤러 개발자로서 다음을 말할 수 있나요?\n\n- 네이티브 메서드(fetch 또는 XHR)를 사용하여 최근 HTTP를 처리한 적이 있나요?\n- 인터셉터를 사용하지 않고 전역적으로 요청과 오류를 처리할 수 있나요?\n- switchMap을 사용하지 않고 HTTP 요청을 되돌릴 수 있는 방법을 말할 수 있나요?\n- axios나 node-fetch 라이브러리를 알고 있나요?\n\n편의성은 좋지만, 앵귤러 없이 쿼리를 작성하는 방법을 알아야 합니다. 심지어 시니어 개발자도 부트스트랩 애플리케이션을 시작하기 전에 요청을 보내는 방법을 모르거나 RxJS.Ajax의 존재를 모르는 것에 놀라곤 합니다.\n\n요청과 응답의 본질에 대한 이해가 있어야 다음과 같은 작업을 수행할 수 있습니다:\n\n\n\n## 테이블을 마크다운 형식으로 변경\n\n- 에러 처리\n- 응답 분석\n- 요청 진행 상황 추적\n- FormData와 함께 작업\n\n# Zone.js\n\nAngular의 신기함과 골칫거리. Zone.js는 모든 브라우저 이벤트를 위임하고 그 후 Angular에게 알릴 도구로 소개되었습니다. 그 목적은? — 업데이트의 \"마법\"을 제공하기 위해서:\n\n- 마우스 클릭? — 업데이트\n- 요청 종료? — 업데이트\n- setTimeout 종료? — 업데이트\n\n\n\n전체 애플리케이션이 어떻게 업데이트되는지에 대해 생각해 본 적이 없죠. 그러나 이 프로세스를 이해하지 못하면 미래의 최적화에 큰 문제가 될 수 있습니다.\n\n루트 및 자식 존, 기본 및 OnPush, runOutsideAngular, ComponentsTree, ViewTree, Async-pipe 등 다양한 생각할 수 없는 주제와 라이브러리 변경 감지에 대한 글들이 많이 쓰였습니다.\n\n이 글들은 \"용기를 잡는 법\"을 이해하기 위해 필요한 것뿐입니다. 네, ChangeDetectorRef나 NoopZone를 통해 컴포넌트 및 애플리케이션 업데이트를 간접적으로 관리할 수 있지만, 이것은 편리함이 아니라 유지 관리 과제입니다.\n\n\n\n# 앵귤러는 RxJS를 제공했지만 어떻게 사용해야 하는지 알려주진 않았어요\n\n앵귤러에서 RxJS에 관한 가장 빈발한 주제는 무엇일까요? - 구독 관리와 메모리 누수입니다. 그리고 이게 아무 이유 없는 얘기가 아니에요.\n\n앵귤러에서 개발을 시작하는 개발자들은 Observable을 Promise처럼 then()으로 처리하려고 해요. 많은 멋진 코드와 좋지 않은 구현을 봤어요. RxJS에 대한 지식이 없으면 앵귤러에서 효과적으로 작업할 수 없기 때문에 강좌와 자료를 만드는 이유를 이해해요.\n\n일반적으로 알려진 앵귤러는 반응적인 접근이 아니라 스트림 접근에 관한 것이에요. 모든 값들은 '스트림'이에요. 스트림으로 생각하고 스트림과 어떻게 작업할지 알지 못한다면 어려움을 겪을 거에요.\n\n\n\n2024년에도 이런 주제들이 면접에서 확인됩니다:\n\n- 고차 연산자 — concatMap, mergeMap, switchMap, exhaustMap\n- 결합 연산자 — zip, forkJoin, combineLatest\n- 메모리 누수 모니터링\n- \"Hot\"과 \"cold\" Observables\n- takeUntil, takeWhile, takeUntilDestroyed(new)\n\n## RxJS의 사로잡힌 자\n\nAngular에서 스트림과 함수형 프로그래밍으로 마음가짐을 전환했다 하더라도, 모든 값이 스트림이 될 수 있는 것은 아니라는 점을 주의하세요.\n\n\n\n문제가 무엇인가요? — 기본형과 객체를 다루는 법을 까먹었나요? 이제는 필요하지 않은 값이 스트림에 있습니다. BehaviorSubject를 통해 모든 클래스 필드를 생성하려는 충동이 생길 것입니다. 이것은 큰 문제입니다. 이로 인해 여러 조합과 내부 구독을 가진 각 필드에 대해 10개 이상의 BehaviorSubject가 있는 상태 서비스의 많은 구현을 볼 수도 있습니다.\n\n# DI\n\n많은 개발자가 Angular를 선택하게 만드는 기능입니다. 하지만 스스로 발목을 쏘지 않는 방법을 알아야 합니다.\n\n## ProvidedIn과 사용하지 않는 코드\n\n\n\n@Injectable 데코레이터에서의 ProvidedIn 함수는 Angular에 서비스를 등록해야 하는 위치를 알려주는 용도로 만들어졌어요. 이를 통해 초기 스크립트의 크기를 최적화할 수 있었고, 필요하다면 사용되지 않는 서비스를 빌드에서 제거할 수도 있었죠. 이 접근 방식은 라이브러리 개발에 사용할 수 있어요. 여러분이 만든 라이브러리에서 다른 개발자가 얼마나 많은 서비스를 사용할지 모르는 경우에 유용해요.\n\n하지만 이 방식은 단일 앱을 갖는 통합형 저장소에는 적합하지 않아요. Angular가 불필요한 코드를 제거해주는 것은 좋지만, 코드베이스를 최신 상태로 유지하는 책임을 Angular에게 넘기게 된다는 문제가 있어요.\n\n## 제공의 마법\n\nProvidedIn은 모든 서비스를 자동으로 등록해주는데, 이 부분은 편리한 면이 있어요. 하지만 providedIn: root를 사용할 때 문제가 발생하기 시작해요.\n\n\n\n개발자들은 트리 쉐이킹 메커니즘에 매우 의지하고 있습니다. 이에 따라 응용 프로그램의 일부분에서만 사용되는 서비스도 리포지토리의 가장 깊은 곳에서 전역으로 등록합니다. 이렇게 하면 전역적인 요소를 만들어 리포지토리 구조를 파괴하게 된다는 점을 명심해주세요.\n\n## 서비스의 트리 쉐이킹은 코드의 트리 쉐이킹과 같습니다\n\n많은 사람들이 서비스의 트리 쉐이킹이 코드 전체에 적용되는 것으로 잘못 알고 있지만, 실상은 그렇지 않습니다.\n\nProvidedIn은 프로바이더 트리의 생성 및 그 안에 포함될 서비스의 수에만 영향을 줍니다. 최대로 절약할 수 있는 용량은 전체 빌드 중 10-15 kb로 매우 작은 값입니다.\n\n\n\n# 항상 현재 프론트엔드 기능의 뒤쳐지게 될 거에요\n\nAngular은 '프론트엔드 세계'에서 애플 제품으로 생각해야 합니다. 다른 브랜드들이 몇 달에 한 번씩 새로운 기능을 결합하고 개발하는 동안, 애플은 새로운 기능을 서둘러 추가하지 않고 제품을 연마다 조금씩 개선하는 것을 선호해요.\n\nAngular의 종속성이 닫힌 생태계를 가지고 있어, 어떤 종속성을 새로운 것으로 교체하는 것이 어려울 수 있어요. 중요한 것은 Angular 버전을 최신으로 유지해야 한다는 점이에요. 예를 들어, Angular 9에서 Typescript 5나 Webpack 5를 사용할 수 없어요 — 올바른 버전으로 업그레이드해 주세요. 업그레이드를 실패하거나 미룰 경우, 모든 기능이 그대로 지나가게 될 거에요.\n\nAngular 팀이 기대하는 기능이나 도구 지원을 추가하지 않기로 결정하면, 그대로 사용해야 할 수 있습니다. 영원히 무엇을 가지고 작업해야 할지도 모를 거에요.\n\n\n\n# 더 많은 사람 — 더 많은 아이디어 — 더 많은 해결책\n\nAngular는 현재 앱 개발을 위한 세 가지 가장 인기 있는 기술 중 하나입니다.\n\n만약 React나 Vue로 어플리케이션의 복제본을 구현하려고 한다면, 이 어플리케이션의 모든 종속성이 Angular에서는 대응하는 것이 없다는 것이 드러날 것입니다. 그것들은 존재하지 않거나 js 라이브러리에 대한 Ng-wrapper가 없거나 그런 래퍼가 있더라도 다른 기능을 가지고 있을 수 있습니다.\n\nReact나 Vue보다 커뮤니티가 작아서 이러한 도구들을 만들지 않았기 때문에 자체 솔루션을 구현하는 데 시간이 걸릴 것입니다.\n\n\n\n# 개발자 편의가 비즈니스보다 앞섭니다.\n\n인기 있는 도구와 Angular을 비교하는 모든 글과 토론은 내부 구현에 대해 이야기하지만 한 가지를 잊고 있습니다 — 성능, SEO, 빌드 크기 및 그 결과를 달성하는 데 소요된 시간이 동일할 때만 도구를 비교해야 한다는 것을 잊습니다.\n\n우선, 당신은 제품을 개발하는 대신 돈을 지급하는 비즈니스를 위해 일하고 있습니다. 최종 사용자는 제품을 누가 만들었는지, 몇 명이 만들었는지, 어떤 기술로 만들어졌는지는 모릅니다. 그가 중요하게 생각하는 것은 응답성이 뛰어나고 예상대로 작동하는 빠른 사이트입니다.\n\n\"모든 것을 갖췄다\"는 마인드셋으로 Angular을 선택하면 초기 개발 단계에 빠르게 진입할 수 있을 뿐입니다. 당신은 의도적으로 개발 옵션을 좁혀 선택해야 할 것이며 이제 Angular이 제공할 수 있는 것에 의존해야 합니다. 2018년이 아니라는 것을 명심하세요. 숙련된 개발자는 1~2시간 만에 프로젝트를 처음부터 만들 수 있고 미래 제품의 요구사항을 반영하는 도구 스택을 선택할 수 있습니다. 무언가 변경되면 어떤 부분이든 더 나은 것으로 대체할 수 있습니다.\n\n\n\n프론트엔드 개발자이시군요! 먼저 표 태그를 마크다운 형식으로 변경해주세요.\n\n그리고 Angular를 선택한다면, 도구의 인기와 개발자 수는 직접적으로 연관되어 있기 때문에 새로운 인재를 찾는 것이 더 어려워질 수 있다는 것을 염두에 두는 것이 좋습니다. 비즈니스 전략이 신속한 성장을 포함한다면, 후보자를 찾을 가능성을 높일 수 있는 보다 인기있는 도구를 살펴보세요.\n\n# Angular는 필요 없는 것을 사용하라고 제안합니다\n\n## Protractor\n\n이게 무엇인지 모른다면 괜찮아요. 이것은 최근까지 Angular 작업 공간을 생성할 때 설치되었던 e2e 테스트 도구입니다.\n\n\n\n이 솔루션을 사용한 개발자가 매우 적다는 것을 쉽게 짐작할 수 있습니다. 또한, 이 도구에 대한 문서, 안내서, 지침도 거의 찾아볼 수 없을 것입니다.\n\n일반적으로 저장소에 e2e 테스트가 필요하면 익숙한 Cypress나 Puppeteer 도구로 마이그레이션하는 방법을 찾았습니다.\n\n## Karma + jasmine\n\nAngular 패키지에서 기본적으로 제공되는 또 다른 도구입니다. Protractor와 달리 사용이 중단되지 않았으며 개발자들 사이에서 인기가 있습니다.\n\n\n\nJest는 종종 이 조합과 대조됩니다. 테스트 작성에는 특별한 차이가 없지만 구성 방식과 일반적인 작업 방식이 다를 수 있습니다.\n\nKarma + Jasmine을 사용하기 전에 몇 가지 질문에 답해 보세요:\n\n- Jest를 알고 대체 도구로 전환할 준비가 되었나요?\n- 테스트를 실행하기 위해 브라우저 기반 환경이 실제로 필요한가요?\n- Karma와 생태계를 사용자 정의할 준비가 되었나요?\n- CI/CD에서는 에이전트에 브라우저를 설치하여 Karma에서 테스트를 실행해야 한다는 것을 알고 계셨나요?\n\n## Angular Material\n\n\n\n기본적으로 내장된 종속성은 아니지만, 이 라이브러리를 우회할 수 없는 것은 정말 어렵습니다.\n\n개발자들과 팀들이 다른 UI 라이브러리 대신 Angular Material을 선택하는 주된 이유 중 하나는 공식 Angular 팀의 지원입니다. 다른 UI 라이브러리는 새로운 Angular 버전이 출시되길 기다리고 업데이트를 기다리지만, Angular Material은 거의 Angular과 동시에 출시됩니다. 이 시점에서는 Angular Material을 지지하는 어떤 주장도 없어지죠.\n\n익숙해지기까지 다소 복잡한 개발용 도구입니다:\n- 스타일링. 컴포넌트 스타일링을 추천하는 방식을 따르지 않으면 이 라이브러리와 별개의 문제가 됩니다. Angular Material은 css 선택자를 변경하거나 요소의 중첩 순서를 일방적으로 변경할 수 있으므로 이에 대비해야 합니다.\n- Angular 업그레이드. Angular Material 번들의 경우, Angular의 새 버전으로 처음 업그레이드하는 것은 불가능할 수 있습니다. 빌드를 가지고 있더라도 인터페이스가 원래 렌더링을 유지할 것이라는 보장은 없습니다. 그에 따라 회귀 또는 QA가 필요합니다. 이에 대한 리소스가 없는 경우, 모든 것을 개인적으로 직접 확인해야 할 준비가 필요합니다.\n- 컴포넌트의 사용자 정의 감소. Taiga-UI와 같은 다른 라이브러리는 각 엔티티를 사용자 정의할 수 있는 도구와 방법의 많은 목록을 제공하는 반면, 여기서는 컴포넌트를 처음부터 구현하거나 ViewChild를 사용하여 컴포넌트를 필요에 맞게 관리해야 할 것입니다.\n\n\n\n# Angular Universal\n\n저에게 있어서 Angular의 SSR을 사용하는 것은 컴포넌트 렌더링 버그를 고치는 게으른 방법입니다 (잊혀진 trackBy, ChangeDetection.Default, Critical CSS 등) 그리고 초기 빌드 크기도 통제하는 방법이에요.\n\nAngular Hydration이 추가되기 전인 16 버전 이전에는 Angular의 SSR 사용을 무의미하게 생각할 수 있어요.\n\n먼저 Angular은 대규모 기업 애플리케이션을 위한 도구에요. 랜딩 페이지, 포트폴리오 페이지 또는 다른 \"가벼운\" 앱을 만들 때 선택하는 것이 아니에요. Angular를 선택했다면, 최적의 SEO나 FCP를 가진 애플리케이션을 만드는 관점에서 출발하기 어렵겠네요. 이미 알고 있듯이 최종 Angular 빌드는 다른 라이브러리보다 크게 될 거라고 가정하고 시작하는 거죠.\n\n\n\n## SSR이 필요해질 때 언제든지 라인\n\n의외로도 당신의 Angular 애플리케이션이 SSR을 가지고 있지 않더라도 SSR을 위해 개발해야 합니다. 전역 API인 window를 포함하여 서버 환경에는 존재하지 않는 것들을 토큰화해야 합니다. 이 접근 방법에는 문제가 없지만, 이 사실을 알고 서로 지키는 Angular 개발자가 얼마나 되겠습니까?\n\n브라우저에서만 작동하는 기능이나 도구를 사용하는 경우, SSR을 추가하여 즉시 애플리케이션을 실행할 수 없게 됩니다. 현재 애플리케이션을 위해 SSR을 지원하는 과정에서 시간과 리소스를 낭비하게 되며, 여러 버그를 만들 수도 있습니다.\n\n## 유연성 제로\n\n\n\n이제 가장 최근에 소개된 Angular Hydration을 가지고 있지만, Qwik와 Resumability에 대해 배웠습니다. 이 지식을 활용하여 Angular 내에서 재현할 수 있을까요? — 아닙니다. 여러분의 경험을 모두 갖고 있더라도, Angular 팀이 Angular Universal에 대한 지원을 추가하기를 결정할 때까지 사용할 수 없습니다.\n\n# 결론\n\n각 개발자는 다른 개발자가 만든 다른 기술을 사용하는 소비자입니다. 가장 중요한 것은 자신이 편안한 느낌을 가질 수 있는 장소를 찾는 것입니다.\n\n첫 번째 스택을 형성할 수 있는 방향을 찾는 초보 프론트엔드 개발자라면, Angular를 포기하는 것이 더 나을 수 있습니다. 네이티브 JS 및 HTML 기능에 기반을 둔 React, Vue, Svelte 또는 기타 가벼운 UI 라이브러리를 선택하는 것이 더 낫습니다. 엄격히 규제된 종속성이 없기 때문에 특정 작업에 어떤 도구를 적용할지 스스로 결정할 수 있습니다. 이를 통해 할당된 작업의 범위 내에서 \"도구 평가\" 및 \"도구에 대한 요구 사항 형성\" 기술을 발전시킬 수 있습니다.\n\n\n\n\"React를 \"기술의 동물원\"이라고 말하기는 어렵습니다. 이미 React 주변에는 각각의 작업 유형에 대해 2~3개의 추천 도구가 형성되어 있습니다. 프로젝트마다 그들의 조합을 변경할 수 있지만, 응용 프로그램을 구축하는 아주 기본적인 방식은 변하지 않습니다. 또한 Angular와 마찬가지로 프로젝트 구조에 빨리 익숙해질 것입니다.\n\n합리적인 질문. \"Angular가 필요한가요\"? — 놀랍게도, 네요.\n\nSPA를 위해 과거에 Angular가 제공할 수 있던 것은 아직까지 아무도 반복할 수 없었습니다.\n\n다른 도구들보다 뒤처지고 여러 해 동안 문제를 겪음에도 불구하고, 개발자들은 강력한 솔루션을 즉시 가져오기 위해 Angular를 선택했습니다. 언제나 프로젝트에서 알고 있는 기술과 함께 작업을 해왔고, 이는 학습에 리소스를 낭비하지 않고 교차 기능 팀을 구축하는 데 도움이 되었습니다.\"\n\n\n\n만약 Angular 이전에 RxJS를 사용해 보았다면, 이것은 좋은 전이 보너스가 될 것입니다. 만든 모든 애플리케이션에 RxJS를 추가할 수 없었던 이유는 팀의 승인과 사용 사유를 정당화해야 했기 때문입니다. Angular는 RxJS의 사용을 권장하며 개발을 쉽게 만들기 위한 자체 연산자를 제공합니다.\n\nAngular로 전환하기 전에 재사용 가능한 솔루션을 개발하면서 오류 및 기술을 경험해보는 것이 좋습니다. 사용성을 느끼기 위해 Angular로 이주하기 전에 몇 가지 경험이 필요합니다.","ogImage":{"url":"/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png"},"coverImage":"/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png","tag":["Tech"],"readingTime":10},{"title":"TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험","description":"","date":"2024-05-13 00:10","slug":"2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper","content":"\n\n![My experience learning Rust as a TypeScript developer](/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png)\n\n많은 개발자들처럼, 나 또한 웹 기술에 중점을 두며 프로그래밍 경력을 시작했습니다. 이것은 시작하기에 좋은 곳이라고 생각하며, 인터넷의 언어이자 많은 기능을 갖춘 JavaScript는 매우 다재다능한 선택이라고 생각합니다.\n\n저는 JavaScript와 같은 고수준 언어에 대한 경험이 쌓을수록, 어떻게 작동하는지에 대해 더 많은 관심을 가지기 시작했습니다. 그들은 어떤 선택과 타협을 하고 있는지, 고수준 추상화의 혜택과 비용은 무엇인지 궁금해졌습니다.\n\n저에게 이러한 깊은 이해를 얻는 가장 좋은 방법 중 하나는 저수준 프로그래밍 언어를 배우는 것입니다. 결국 이러한 언어들은 일반적으로 JavaScript 코드를 구문 분석하고 해석하는 언어입니다. 예를 들어, Google Chrome 및 Node.js에서 사용되는 V8 엔진 및 Safari 및 Bun에서 사용되는 WebKit은 모두 C++로 작성되어 있습니다. 그러나 저수준 프로그래밍의 주력언어인 C++이 내 선택 언어는 아니었습니다...\n\n\n\n# 왜 Rust를 선택해야 할까요?\n\n저에게 가장 흥미로운 저수준 프로그래밍 언어 중 하나인 Rust는 매우 흥미롭습니다. 작년에도 8년 연속으로 Rust가 Stack Overflow의 연간 설문 조사에서 가장 존경받는 프로그래밍 언어였습니다.\n\nRust 언어는 C 및 C++과 같은 런타임 성능을 약속하면서도 엄격한 타입 시스템, 많은 메모리 안전 기능 및 보다 적극적인 오류 처리 접근 방식을 제공합니다. 따라서 쓰레기 수집기의 오버헤드를 피하고, C와 같은 언어에서 만들기 쉬운 메모리 누수의 위험에서 안전합니다.\n\nRust는 다중 패러다임을 갖추고 있어 객체 지향 및 함수형 프로그래밍에서의 개념들을 결합하고 있습니다. Web Assembly을 위해 가장 많이 사용되는 언어로 세 번째 해를 맞이하고, Linux 커널에서도 중요한 언어로 자리매김하고 있습니다. Rust는 JavaScript 세계에서도 주목을 받고 있으며, Deno와 같은 중요한 프로젝트 및 최근에는 LLRT (Amazon의 서버리스 함수용 저지연 런타임)과 같은 프로젝트를 개발하는 데 사용되고 있습니다.\n\n\n\n# 러스트 배우는 방법\n\n다른 프로그래밍 언어와 마찬가지로, 러스트를 배우는 가장 좋은 방법은 그 언어로 무언가를 프로그래밍해 보는 것이라고 생각해요.\n\n다만, 러스트의 초기 학습 곡선이 최근 몇 년 동안 시도해 본 다른 언어들보다 가파르다는 느낌을 받으셔서, 그 언어를 사용하기 전에 입문 자료를 더 여유롭게 공부하는 것이 가치가 있다고 생각해요.\n\n러스트 기관의 웹사이트에는 좋은 권장사항들이 있어요. 현재로는 더 테스트하기, Rustlings 코스, Rust by Example이 그렇고요. 또한 Rust by Practice도 추천해요. 이것은 Rustlings와 유사한 대화형 코스예요.\n\n\n\n유튜브에서 NoBoilerplate 채널을 통해 언어에 대해 흥분하게 되었고 일반 Rust 개념에 대한 좋은 설명 소스입니다. Rust를 호스팅에 관심이 있다면, AWS는 플랫폼에서 Rust 지원을 확대하는 좋은 블로그 게시물이 있습니다.\n\n본문의 나머지는 Rust에 대한 초심자 안내서가 아닙니다. 그런 정보를 찾고 계시다면, 위의 링크를 따라가는 것을 추천합니다. 대신, 전문가로서 매일 사용하는 TypeScript와 비교하여 Rust를 사용할 때 개발자 경험에서 가장 중요한 차이점 중 일부에 대한 나의 생각을 공유하겠습니다.\n\n# 컴파일러\n\nRust 컴파일러는 종종 Rust의 가장 좋은 부분 중 하나로 인용되지만 초심자들에게는 가장 짜증이 나는 부분으로 느껴질 수도 있습니다!\n\n\n\nTypeScript에서 왔는데, 컴파일러가 코딩 경험을 얼마나 바꾸는지 놀랐어요. 많은 개발자들처럼, 보통 제가 값들을 자유롭게 로깅하는 방식의 적절한 디버깅 도구를 피하곤 해왔어요. 하지만 Rust에서는, 컴파일러가 만족할 때까지만 값들을 로깅할 수 있어요.\n\n이런 경우에 당황했던 일들이 있어요: 예를 들어, 역직렬화 단계의 엄격한 유형을 작성하기 전에 요청된 JSON 페이로드를 로그로 남기고 싶었어요. (나중에, serde_json::Value 유형을 사용하면 이것을 할 수 있다는 것을 배웠어요).\n\n그러나 일반적으로, 컴파일러를 만족시키기 위해 노력하는 것은 보통 제 코드를 실행했을 때, 기대했던 대로 동작한다는 것을 의미했어요. 여기서의 절충안은 꽤 명확해 보여요. 적어도 초보자들에게는 코드를 실행하는 데 더 많은 시간이 걸리지만, 코드가 실행될 때, 더 안전하고 예측 가능하며 성능이 더 좋아요. 쓰기 단계에서 더 많은 작업을 해야하지만, 오류나 메모리 또는 성능 문제의 가능성이 더 낮아지는 경향이 있어요 — 그리고 이러한 이점들은 점점 중요해지는 대형, 커지는 프로젝트의 맥락에서 더욱 중요하게 느껴져요.\n\n오류 메시지가 덜 유용한 언어에서 온 개발자들은 오류를 빨리 훑어 넘어가야 한다는 성격을 갖고 있을 수 있어요. 그러나 지금까지 제가 발견한 Rust 컴파일러 오류는 매우 좋았어요. 종종 코드를 실행시키기 위해 무엇을 해야하는지 정확히 말해줘요— 언어와 그 유형에 대해 더 많은 경험과 지식을 쌓을수록, 컴파일러가 무엇을 말하려는지 이해하는 데 더 능숙해지고 있는 것 같아요!\n\n\n\n# 유형 시스템\n\n모든 JavaScript 개발자가 TypeScript을 좋아하지는 않는다는 것을 알고 있어요. 예를 들어, 이 유명한 블로그 포스트를 보세요. 하지만 저는 타입 없이 큰 JavaScript 앱을 작성하는 것이 상상이 되지 않아요. 그러나 TypeScript에도 약점이 있고, 타입이 일등 시민인 언어를 가지는 것에는 많은 장점이 있다는 것을 깨달았어요. Rust의 유형 시스템은 그 중에서도 최고의 기능 중 하나로 칭찬을 받는 편이에요.\n\n그렇지만, 저에겐 새로운 개념인 Rust의 유형 시스템의 일부는 Rust에만 있는 것은 아니라는 걸 알았어요. 대부분의 저수준 언어와 마찬가지로, Rust는 변수가 메모리에서 얼마만큼의 공간을 차지할지 매우 구체적으로 지정할 수 있도록 해줘요. 예를 들어, 숫자 값이 항상 0에서 255 사이의 정수일 것을 알고 있다면 8비트 길이를 가진 u8에 할당할 수 있어요. 또는 숫자가 255 이상일 수 있지만, 65,535 미만이라는 것을 알고 있다면, 16비트 u16 유형에 할당할 수 있어요 — 그리고 계속해서 할당해 나갈 수 있어요.\n\n그러나 Rust도 다른 저수준 언어보다 한 걸음 더 나아간다고 할 수 있어요. 예를 들어, C의 char[] 유형 대신에 적어도 여덟 가지 문자열 유형을 제공하며, 우리에게 '발목을 쐐는 일'을 피할 수 있도록 도와줘요. (물론, 걱정하지 마세요, 대부분의 사용 사례는 &str과 String으로 충분히 커버돼 있어요!)\n\n\n\n물론 TypeScript는 메모리 관리에 대한 이러한 세밀한 수준을 제공하지 않습니다. 왜냐하면 JavaScript는 메모리 관리에 대해 걱정하지 않도록 설계되어 있기 때문에 메모리를 할당합니다. 이는 우리에게 일을 줄여주지만 JavaScript 엔진은 프로그램이 실행되는 동안 동적으로 메모리를 할당해야 하므로 덜 효율적입니다. 소규모로는 큰 차이가 없지만 대규모 응용 프로그램에서 더 효율적이고 목적적인 메모리 할당은 프로그램이 훨씬 작은 메모리 공간을 차지할 수 있게 해줍니다.\n\n## 메모리 할당\n\nTypeScript에서는 우리의 타입을 읽지 않는 JavaScript 위에 타입 주석을 덧붙입니다. TypeScript 코드가 빌드될 때마다 이 주석들은 제거됩니다.\n\nRust와 같이 타입이 일급 시민인 다른 언어들에서는 타입 주석이 주석 이상의 역할을 하며 해당 특정 타입에 대해 메모리를 할당하고 그 값이 주어진 타입을 가질 것임을 우리에게 보장합니다.\n\n\n\n예를 들어, 아래의 parse 메서드에 i8 타입을 전달하면 small_int에 8비트의 메모리가 예약됩니다.\n\n```rust\nlet small_int = \"127\".parse::<i8>().unwrap();\n```\n\nparse 메서드는 변수의 타입에서도 타입을 추론할 수 있기 때문에 다음과 같이도 작성할 수 있습니다:\n\n```rust\nlet small_int: i8 = \"127\".parse().unwrap();\n```\n\n\n\n이 경우, 컴파일러는 주어진 형식이 허용하는 메모리를 초과하려고 시도하면 우리에게 소리를 질립니다. 따라서 문자열 \"128\"을 i8로 구문 분석하려고 하면 컴파일할 수 없게 됩니다.\n\n타입스크립트와 비교해보면, 타입 표시는 단지 마커일 뿐입니다. 그들은 밑바탕 타입이나 할당된 메모리를 변화시키지 않습니다. 아래 예시에서 타입스크립트는 x가 문자열이라고 예상합니다. 그러나 밑바탕 자바스크립트에서는 숫자로 취급됩니다.\n\n```js\nconst x = 10 as unknown as string;\n```\n\n이 예는 조금 불합리한 예제입니다; 우리는 잘못된 타입을 강제로 할당하려고 unknown을 탈출구로 사용하고 있습니다!\n\n\n\n그러나 이것은 이해하기 쉬운 간단한 예제입니다. 실제 응용 프로그램에서는 더 복잡한 데이터 유형이나 제3자로부터 가져온 데이터를 다룰 때 TypeScript가 현실을 잘못 표현하기 쉬워집니다.\n\n# 오류 처리\n\n다시 한번 문자열을 정수로 변환하는 예제를 살펴봅시다. 이번에는 사용자가 제공한 문자열을 정수로 취급하니, 우리가 정확히 파싱할 수 있다고 보장할 수 없게 됩니다.\n\n```js\nlet parsed_int = submitted_str.parse::<i32>().unwrap();\n```\n\n\n\n여기서는 성공적으로 구문 분석한 값을 가져오기 위해 unwrap을 사용하고 있습니다. 그러나 이 방식은 일반적으로 권장되지 않습니다. 대신 Rust는 오류를 수동으로 처리하도록 강제하는 Result 열거형을 제공합니다.\n\n우리는 여전히 panic! 매크로를 사용하여 프로그램을 패닉 상태로 만들 수 있지만, 잘못된 내용을 빠르게 이해할 수 있는 사용자 정의 오류 메시지를 전달할 수 있습니다:\n\n```js\nlet parsed_int_result = submitted_str.parse::<i32>();\n\nlet parsed_int = match parsed_int_result {\n    Ok(data) => data,\n    Err(error) => panic!(\n        \"주어진 문자열을 정수로 구문 분석할 수 없습니다: {:?}\",\n        error\n    ),\n};\n```\n\n또는 기본값을 반환할 수도 있습니다 — 이 경우에는 0:\n\n\n\n```js\nlet parsed_int_result = submitted_str.parse::<i32>();\n\nlet parsed_int = match parsed_int_result {\n    Ok(data) => data,\n    Err(error) => 0,\n};\n```\n\n이 작업에 대한 단축 방법도 있습니다: unwrap_or_default .\n\n물론 JavaScript에서도 이런 종류의 동작이 가능하지만, 차이점은 JavaScript에서는 선택으로 참여해야 하지만 Rust에서는 unwrap을 사용하여 선택으로 제외해야 합니다.\n\n또 다른 말로는 JavaScript에서는 에러를 의식적으로 처리해야 합니다. 반면에 Rust에서는 에러를 처리하든지 성공적인 경로만 신경 쓸 것이라고 의식적으로 결정해야 합니다.\n\n\n\n# 선택적 값\n\nRust는 선택적인 값 처리에 비슷한 접근법을 사용합니다. TypeScript에서는 편리한 ?를 사용하여 값이 정의되지 않을 수 있다는 것을 나타낼 수 있습니다.\n\n```js\ninterface User {\n  _id: string;\n  name?: string;\n}\n\nfunction sayHello(user: User) {\n  return `Hello ${user.name}!`;\n}\n```\n\n이 TypeScript 코드는 문제없이 컴파일될 것이지만, 우리가 원치 않는 값을 반환할 위험이 있습니다!\n\n\n\n하지만 Option 열거형을 사용하여 Rust에서 비슬한 내용을 작성하면 컴파일 시간 오류가 발생합니다.\n\n```rust\nstruct User {\n  _id: String,\n  name: Option<String>,\n}\n\nfn say_hello(user: User) -> String {\n    let name = user.name;\n    format!(\"Hello {name}!\")\n}\n```\n\n위의 코드는 Option을 format! 매크로 안에 사용할 수 없다는 경고를 보여줍니다. 이것은 예상치 못한 결과를 반환하는 것을 방지합니다. 대신, 이 가능성을 처리하도록 강제됩니다. 다음은 match를 사용한 하나의 해결책입니다:\n\n```rust\nstruct User {\n  _id: String,\n  name: Option<String>,\n}\n\nfn say_hello(user: User) -> String {\n  let name: String = match user.name {\n    Some(name) => name,\n    None => \"world\".to_string(),\n  };\n\n  format!(\"Hello {name}!\")\n}\n```\n\n\n\n한 번 더 말하지만, TypeScript에서는 이것을 달성할 수 있습니다. 그리고 더 간결합니다. 하지만 두 언어 간의 주요 차이점은 TypeScript에서는 개발자가 잠재적 문제를 인식해야 한다는 점입니다. 그래서 \"Hello undefined\"를 반환하지 않도록 주의를 기울여야 합니다. 그러나 Rust에서는 name이 사용 불가능한 시나리오를 처리하지 않을 경우 코드가 컴파일되지 않습니다.\n\n이 예제와 같이 간단한 경우에는 보다 번거로운 접근 방식의 이점을 인식하기가 어려울 수 있습니다. 왜냐하면 무엇이 잘못될 수 있는지 쉽게 알아볼 수 있기 때문입니다. 하지만 한 번이라도 대규모 응용 프로그램을 작업해본 적이 있다면, Rust의 opt-out 접근 방식이 많은 잠재적 사고로부터 우리를 구해낼 수 있다는 것이 분명해집니다.\n\n# 소유권과 대여\n\n마지막으로, 소유권과 대여에 대해 얘기하고 싶습니다. 이 개념들은 Rust와 같은 저수준 언어에서는 높은 수준의 TypeScript와는 달리 의미가 훨씬 크다는 것을 감안하면서요.\n\n\n\nTypeScript에서는 값을 변이(mutate)하거나 복제(clone)하는지 주의해야 합니다.\n\n```js\nconst arrayToBeMutated: string[] = [\"d\", \"c\", \"b\", \"a\"];\nconst arrayToBeCloned: string[] = [\"d\", \"c\", \"b\", \"a\"];\n\narrayToBeMutated.sort();\narrayToBeCloned.toSorted();\n\nconsole.log(arrayToBeMutated);  // [\"a\", \"b\", \"c\", \"d\"]\nconsole.log(arrayToBeCloned);   // [\"d\", \"c\", \"b\", \"a\"]\n```\n\n위의 TypeScript 코드에서 sort는 배열을 현재 위치에서 정렬하여 원래 값을 변경하여 변이합니다. 그러나 toSorted는 복제본을 생성하여 새 변수에 할당할 수 있으며, 원래 배열을 그대로 유지합니다.\n\n일반적으로 TypeScript와 같은 언어에서는 변이(mutate)를 피하기 위해 toSorted와 같은 비파괴적 메서드가 종종 선호됩니다. 변이된 변수를 추적하는 것은 까다로울 수 있고, 메모리나 성능에 명확한 이점이 없는 한 전혀 하지 않는 것이 보편적으로 더 나은 방법으로 여겨집니다.\n\n\n\n하지만 Rust를 사용하면 더 깊게 들어갈 수 있고, 값을 변이하거나 복제하는 데 훨씬 명시적일 수 있어서 메모리를 효율적으로 사용하고 값이 그 영광스러운 목적을 수행한 후에도 메모리를 더 쉽게 해제할 수 있습니다.\n\n먼저, 모든 변수는 기본적으로 불변이며, mut 키워드로 명시적으로 변경 가능하도록 표시해야 합니다.\n\n다음 코드는 오류를 발생시킵니다:\n\n```js\nlet foo = 10;\nfoo += 10;\n```\n\n\n\n이 코드는 다음을 수행하지 않습니다:\n\n```js\nlet mut foo = 10;\nfoo += 10;\n```\n\n이것은 JavaScript에서의 let와 const와 대략 동등한 것처럼 느껴집니다. 그러나 Rust는 더 나아갑니다.\n\n예를 들어, JavaScript에서는 배열과 같은 일부 변수 유형이 항상 가변적(mutable)입니다. const를 사용하여 생성하더라도 push, pop 및 인덱스 재할당을 할 수 있습니다. 그러나 Rust에서는 이 작업을 수행하려면 mut이 필요합니다:\n\n\n\n```js\nlet mut nums: Vec<i32> = vec![1, 2, 3, 4, 5];\nnums.push(6);\n```\n\n러스트는 또한 우리가 변수에서 다른 변수로 값을 소유권을 옮길 수 있도록 하는 기능을 제공합니다. 아래 예시를 살펴보세요:\n\n```js\nlet nums: Vec<i32> = vec![1, 2, 3, 4, 5];\nlet doubles: Vec<i32> = nums.into_iter().map(|n| n * 2).collect();\n\ndbg!(nums);     // 이 코드는 오류를 발생시킵니다.\ndbg!(doubles);\n```\n\n위 코드는 오류가 발생합니다. 왜냐하면 into_iter 메서드는 \"소비형 반복자(consuming iterator)\"를 생성하는데, 다시 말해 nums로부터 소유권을 가져와 doubles에게 주기 때문입니다. 그렇기 때문에 doubles를 만든 후에는 dbg!(nums)를 호출할 수 없습니다.```\n\n\n\nnums에 액세스할 수는 있지만 값을 복제하고 싶을 때, into_iter 대신에 iter 메서드를 사용할 수 있습니다. 중요한 점은 Rust가 우리에게 선택권을 주고 소유권을 전달할 수 있는 능력을 통해 메모리 할당을 더 효율적으로 관리할 수 있다는 것입니다.\n간단한 값을 이동시키는 것도 가능합니다. 아래 코드에서 str 변수가 calculate_length의 인수로 사용될 때, 해당 변수에 더 이상 액세스할 수 없게 됩니다.\n\n```js\nfn main() {\n    let str = String::from(\"Hello world!\");\n    let len = calculate_length(str);\n    dbg!(str); // 오류 발생\n}\n\nfn calculate_length(s: String) -> usize {\n    s.len()\n}\n```\n\n여기서 우리는 문자열을 전달하는 대신에 문자열의 참조를 전달하기 위해 앰퍼샌드 &를 사용하여 이 문제를 해결할 수 있습니다. 또한 함수의 인수를 참조를 기대하는 형태로 업데이트해야 합니다:\n\n\n\n```rust\nfn main() {\n    let str = String::from(\"hello\");\n    let len = calculate_length(&str);\n    dbg!(str, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\n또 반대로 값을 역참조하기 위해 별표 * 를 사용할 수 있습니다. 이러한 기능들은 우리가 메모리를 안전하고 효율적으로 제어하는 데 도움이 됩니다. 이로 인해 Rust는 가비지 컬렉터에 의존할 필요가 없으며, C와 같은 언어에서의 위험을 피하면서 더 높은 성능 수준을 발휘할 수 있게 됩니다. C 언어처럼 개발자에게 막대한 책임을 요구하는 언어와 다르게 안전하고 효율적으로 메모리를 관리할 수 있습니다!\n\n내가 Rust를 배우고 사용한 초기 경험은 매우 긍정적이었습니다. 다른 언어들에 비해서 시작하기가 조금 어려웠지만, Rust를 배우면서 내가 매일 사용하는 고수준 언어들의 기본적인 작동 방식에 대해 더 많은 인식을 가질 수 있었다고 느꼈습니다. 개인 프로젝트에서 더 많이 사용할 기대감이 있습니다.\n\nRust에 처음 입문하거나 해당 언어를 배워보고자 하는 분들에게, 특히 다른 고수준 언어에서 왔다면, 이 글이 유용했으면 좋겠습니다. 물론 이 글은 단순한 내용이며, 특성(traits)이나 라이프타임(lifetimes)과 같은 여러 주제들이 있으나 이 글의 범위를 벗어납니다. 더 알고 싶으면 The Book을 참고하고 아래 댓글에서 여러분의 경험을 공유해보세요!\n","ogImage":{"url":"/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png"},"coverImage":"/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png","tag":["Tech"],"readingTime":11},{"title":"MERN 스택을 위한 업계 모범 사례","description":"","date":"2024-05-13 00:09","slug":"2024-05-13-IndustryBestPracticesfortheMERNStack","content":"\n\n## MERN 스택(MongoDB, Express.js, React, 그리고 Node.js)은 강력한 웹 앱을 구축하는 데 인기 있는 도구입니다! 웹 개발 세계는 계속 변화하지만, 이 스택은 여전히 많은 사람들에게 사랑받고 있어요.\n\n전문가들의 통찰력을 얻기 위해, 설명서만 의지하는 것보다는 MERN 스택 작업에 직접 경험이 있는 분과 이야기를 해보는 게 어떨까 생각했어요. 그래서 이런 생각을 했더니, Diliru Nagahawaththa씨와의 인터뷰 기회가 찾아왔답니다. 그는 경험 많은 소프트웨어 엔지니어로서 MERN 스택에 대한 업계 Best Practices에 대해 이야기 나누어 주셨습니다. 함께 알아보도록 할까요?\n\n\n\n# 전문가 소개: 딜리루 나가하와타\n\n나가하와타 씨는 스리랑카 정보기술 연구소 출신으로, 현재 클라우드 솔루션 인터내셔널에서 소프트웨어 엔지니어로 일하고 있습니다. \n\n딜리루 씨는 대학 시절과 프리랜서 활동을 통해 MERN 스택을 다루는 데 풍부한 경험을 가지고 있습니다. \n\n# 저와 딜리루가 가진 대화 중 중요한 부분들을 살펴보겠습니다.\n\n\n\n## 1. MERN 스택을 선택한 이유는?\n\n기술적인 측면과 최선의 방법에 접근하기 전에 Diliru에게 MERN 스택을 사용하는 이유 및 개발자들에게 널리 받아들여지는 이유를 물었습니다.\n\n## 2. 아키텍쳐\n\nMERN 아키텍처는 JavaScript와 JSON을 사용하여 프론트 엔드, 백 엔드, 데이터베이스의 세 가지 레벨 구조를 간단하게 만들 수 있습니다.\n\n\n\n![MERN](/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_0.png)\n\n## 3. MERN과 함께 작업하기\n\nReact의 구성 요소 기반 아키텍처는 모듈식이고 재사용 가능한 코드를 가능하게 하여 효율성과 유지 보수성을 향상시킵니다. 백엔드에서 Express.js는 서버 측 로직을 단순화하여 경로와 미들웨어를 처리하기 쉽게 만듭니다.\n\nMERN의 주목할 만한 장점 중 하나는 클라이언트 및 서버 측에서 JavaScript를 통합적으로 사용한다는 것입니다. 이는 학습 곡선을 줄일뿐만 아니라 응용 프로그램의 다른 계층 간에보다 원활한 흐름을 용이하게 합니다. 데이터 처리에서 JSON의 강점은 이러한 일관성을 더욱 향상시킵니다.\n\n\n\n게다가, MongoDB의 유연성은 NoSQL 데이터베이스로서 스택에 매끄럽게 적응되며, 동적이고 발전하는 데이터 구조를 수용합니다. 이는 확장 가능한 애플리케이션을 위한 견고한 기반을 제공합니다.\n\n## 4. 도구 및 기술\n\n여러분도 알다시피, VS Code는 JavaScript 기반 개발에 널리 사용되는 인기 있는 IDE로, 코딩 경험을 향상시키기 위한 다양한 플러그인과 확장 기능을 제공합니다. Diliru와의 대화 중 그는 자신의 관점을 공유했어요\n\n![이미지](/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_1.png)\n\n\n\n- 버전 관리: Diliru는 Git을 사용한 버전 관리가 중요하다고 말합니다. 변경 사항을 추적하는 것이 매우 중요합니다. 새로운 기능을 위한 별도의 브랜치를 만들어 깔끔하고 조직적으로 유지하는 것을 권장합니다.\n\n![MERN 스택을 위한 업계 모베스트 프랙티스](/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_2.png)\n\n- 코드 품질: 그는 깨끗한 코드 작성이 중요하다고 생각합니다. ESLint 및 Prettier와 같은 도구를 사용하면 코드를 일관성 있게 작성하고 이해하기 쉽게 만들 수 있습니다. 모두가 동의하는 같은 스타일 가이드를 따르는 것과 같습니다.\n\n## 5. 모베스트 프랙티스\n\n\n\n- 데이터베이스 디자인: Nagahawaththa씨는 신중한 데이터베이스 디자인의 중요성을 강조합니다. MongoDB의 유연성을 활용하여, 응용 프로그램의 데이터 액세스 패턴과 스키마를 조율하는 것을 제안합니다.\n- 오류 처리: 견고한 오류 처리 메커니즘은 필수적입니다. Diliru는 서버 측과 클라이언트 측 오류 처리를 모두 구현하여 사용자 경험을 향상시키고 디버깅을 간소화할 것을 권장합니다.\n- 코드 모듈화: 모듈식 코드 구조를 유지하는 것은 확장성과 유지 관리성에 매우 중요합니다. Nagahawaththa씨는 코드를 작은 재사용 가능한 구성 요소로 분해하는 중요성을 강조합니다. 이 접근 방식은 개발자들 간의 협력을 강화하고 코드 테스트를 용이하게하며 미래의 업데이트나 수정을 간소화합니다.\n- 성능 최적화: 효율적인 성능은 모든 웹 응용 프로그램의 핵심 요소입니다. Diliru는 개발 프로세스 초기에 성능 최적화 전략을 통합하는 것을 권장합니다. 이는 데이터베이스 쿼리의 최적화, 서버 측 캐싱을 활용하고 클라이언트 측 렌더링 최적화를 위한 React 최상의 실천 방법을 채택하는 것을 포함합니다. 성능에 대한 선제적인 조치는 더 부드럽고 반응성 있는 애플리케이션으로 이어질 수 있습니다.\n- 보안 조치: 보안은 웹 개발에서 매우 중요합니다. Nagahawaththa씨는 잠재적인 취약점에 대비하기 위해 강력한 보안 조치를 시행하는 것을 강조합니다. 이는 사용자 입력을 유효성 검사하고 API 엔드포인트를 보안하며 최신 보안 관행에 대해 알아가는 것을 포함합니다. Diliru는 HTTPS와 같은 산업 표준 보안 프로토콜을 채택하여 데이터 무결성과 사용자 개인 정보 보호를 보장하는 것을 제안합니다.\n\n잘, 친구들, 이 훌륭한 엔지니어 Diliru Nagahawaththa와 함께 한 이 흥미로운 여정이 여기서 마무리됩니다. 그와 나눈 대화에서 많은 것을 배웠고, 그것을 여러분과 나누고 싶었기 때문에 여기 공유하게 되었습니다. 여러분도 가치 있는 인사이트를 얻으셨으면 좋겠어요. ☕💻\n\n제 SNS 계정:\n\n- GitHub\n- LinkedIn\n- Twitter","ogImage":{"url":"/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_0.png"},"coverImage":"/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_0.png","tag":["Tech"],"readingTime":3},{"title":"React 18에서 SSRServer Side Rendering을 구현하는 방법","description":"","date":"2024-05-13 00:08","slug":"2024-05-13-HowtoImplementSSRServerSideRenderinginReact18","content":"\n\n\"renderToPipeableStream\" 서버 API를 구현하는 방법을 배우세요. 이 API를 사용하면 React 트리를 HTML로 Node.js 스트림에 렌더링할 수 있습니다.\n\n![이미지](/assets/img/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18_0.png)\n\nReact 18은 상호작용적 사용자 인터페이스를 구축하기 위한 인기있는 JavaScript 라이브러리의 최신 버전이며, 많은 새로운 기능과 개선 사항을 제공합니다. 특히 서버 측 렌더링(SSR)의 향상된 성능은 주목할 만한 기능입니다.\n\n이 글에서는 React의 SSR 기능을 유용한 코드 샘플과 예시와 함께 살펴보겠습니다. 하지만 먼저 클라이언트 측 렌더링과 서버 측 렌더링의 차이를 알아보겠습니다.\n\n\n\n클라이언트 측 렌더링 (CSR)은 웹 페이지를 클라이언트 측에서 렌더링하는 프로세스를 말합니다 (즉, 사용자의 웹 브라우저에서). 서버는 단순히 원시 데이터나 콘텐츠를 제공하며, 클라이언트 측 JavaScript가 이를 활용하여 최종 렌더링된 페이지를 동적으로 구성합니다.\n\n서버 측 렌더링 (SSR)은 서버에서 웹 페이지를 렌더링한 후 해당 페이지를 클라이언트의 웹 브라우저로 보내는 프로세스를 의미합니다. 클라이언트 측에 의존하는 대신 서버가 웹 페이지의 최종 HTML 마크업을 생성하고 이를 클라이언트로 보내는 방식을 사용합니다.\n\n# \"renderToPipeableStream\" 서버 API 구현하기\n\n단계 1: create-react-app 명령줄 도구를 사용하여 새로운 React 애플리케이션을 만듭니다. 즐겨 사용하는 터미널을 열고 아래 명령어를 입력하세요.\n\n\n\n```js\nnpx create-react-app server-api-demo-app\n```\n\n단계 2: 새로 생성된 React 앱으로 이동합니다.\n\n```js\ncd server-api-demo-app\n```\n\n단계 3: 이제 프로젝트에 라우팅을 처리하기 위해 react-router-dom을 추가해주세요.\n\n\n\n```js\nnpm install react-router-dom\n```\n\n4단계: 애플리케이션에 몇 개의 페이지를 추가해 봅시다. app.js에 아래와 같이 추가할 수 있는 샘플 라우트를 추가해보세요:\n(i) 홈\n(ii) 소개\n\n```js\nconst App = () => (\n  <div>\n    <Routes>\n      <Route path=\"/\" element={<Home />}></Route>\n      <Route path=\"/about\" element={<About />}></Route>\n    </Routes>\n  </div>\n);\n```\n\n5단계: 두 페이지에 내용을 추가해보세요. 참고를 원하시면, 여기를 클릭하세요.\n\n\n\n6단계: 루트 수준에 \"server\"라는 새 폴더를 만들고, 그 안에 index.js와 server.js라는 새 파일을 만듭니다. 아래 코드를 해당 파일에 복사하여 붙여넣기하세요.\n\n```js\n// server/index.js\nrequire(\"ignore-styles\");\n\nrequire(\"@babel/register\")({\n  ignore: [/(node_modules)/],\n  presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\n});\n\nrequire(\"./server\");\n```\n\n이 코드 조각은 Babel을 코드 번역을 위해 설정하고, \"node_modules\"와 같은 특정 파일을 필터링하며, \"server\" 모듈을 가져와 서버를 실행합니다. 이 설정은 React 서버 측 렌더링에서 일반적으로 사용되며, 서버가 React 구성 요소를 처리하고 클라이언트에 제공할 수 있도록 합니다.\n\n```js\n// server/server.js\nimport express from \"express\";\nimport React from \"react\";\nimport ReactDOMServer from \"react-dom/server\";\nimport { StaticRouter } from \"react-router-dom/server\";\nimport App from \"../src/App\";\n\nconst app = express();\n\napp.get(\"/*\", (req, res) => {\n  const entryPoint = [\"/main.js\"];\n\n  const { pipe, abort: _abort } = ReactDOMServer.renderToPipeableStream(\n    <StaticRouter location={req.url}>\n      <App />\n    </StaticRouter>,\n    {\n      bootstrapScripts: entryPoint,\n      onShellReady() {\n        res.statusCode = 200;\n        res.setHeader(\"Content-type\", \"text/html\");\n        pipe(res);\n      },\n      onShellError() {\n        res.statusCode = 500;\n        res.send(\"<!doctype html><p>Loading...</p>\");\n      },\n    }\n  );\n});\n\napp.listen(3002, () => {\n  console.log(\"App is running on http://localhost:3002\");\n});\n```\n\n\n\n위 코드는 app.get(\"/*\", ...)을 사용하여 모든 경로에 대한 라우트 핸들러를 정의합니다. 이는 서버로 들어오는 모든 요청을 처리하는 라우트 핸들러를 의미합니다. 라우트 핸들러 내부에서:\n\n- entryPoint 배열은 main.js 값을 가지고 정의됩니다. 이는 클라이언트 측 코드를 부트스트랩하는 데 사용되는 JavaScript 파일을 가리킵니다.\n- ReactDOMServer.renderToPipeableStream()은 HTML 렌더링을 위한 React 노드와 스트리밍 옵션을 포함하는 선택적 옵션 객체 두 가지 인수를 받습니다. 이는 두 가지 메소드를 반환하는데, pipe와 abort입니다. pipe 메소드는 HTML을 지정된 Node.js 스트림으로 출력합니다. 우리는 onShellReady에서 스트리밍을 가능하게 하기 위해 pipe를 사용합니다. 정적 생성 및 크롤러를 위해 onAllReady도 사용할 수 있습니다.\n- onShellReady()는 렌더링 프로세스가 완료되고 HTML이 클라이언트 전송을 위해 준비된 경우 트리거됩니다. 이는 응답 상태 코드를 200으로 설정하고, 내용 유형 헤더를 text/html로 정의하며, 렌더링된 HTML을 응답에 pipe 메소드를 사용하여 보냅니다.\n- onShellError() 콜백은 렌더링 중 오류가 발생할 때 트리거됩니다. 이는 응답 상태 코드를 500으로 설정하고, HTML `p` 태그로 감싼 기본 오류 메시지를 전송합니다.\n\n7. 클라이언트 측에서는 index.js 파일에서 ReactDOM.createRoot를 ReactDOM.hydrateRoot로 업데이트해야 서버에서 생성된 HTML을 인터랙티브하게 만들 수 있습니다.\n\n```js\n// index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport App from \"./App\";\n\nReactDOM.hydrateRoot(\n  document,\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>\n);\n```\n\n\n\n8. 서버 측에서 코드를 실행하려면 package.json 파일에 아래 스크립트를 추가하세요.\n\n```js\n\"ssr\": \"npm run build && node server/index.js\"  \n```\n\n이 명령은 프로젝트를 빌드하고 서버 측에서 코드를 실행하여 localhost:3002에 출력물을 생성합니다.\n\n9. 이제 npm run ssr 명령을 실행하여 출력물을 확인하세요.\n\n\n\n![이미지](/assets/img/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18_1.png)\n\n여기에서는 \"renderToPipeableStream\" API만 소개했습니다. React는 \"renderToNodeStream\", \"renderToReadableStream\", \"renderToStaticMarkup\", \"renderToStaticNodeStream\" 및 \"renderToStream\"과 같은 다른 API도 제공하여 요구사항에 맞는 서버 측 렌더링을 지원합니다.\n\n이러한 API에 대한 자세한 정보는 공식 문서를 참조해주시기 바랍니다.\n\n# 결론\n\n\n\n새로운 서버 API로 React 컴포넌트를 서버 렌더링된 HTML로 렌더링할 수 있습니다. Node.js 스트림이나 웹 스트림으로 가능합니다.\n\n대부분의 경우에는 Next.js, Remix, Gatsby와 같은 프레임워크가 이 프로세스를 자동으로 처리합니다. 이 API는 앱의 최상위 수준에서 서버 렌더링된 HTML을 빌드하는 데만 사용됩니다. 초기 로드 시간, SEO, 사용자 경험 및 크로스사이트 스크립팅(XSS) 공격에 대한 취약성을 감소시킬 것입니다.\n\n그러나 SSR은 이점을 제공하면서도 복잡한 구현, 증가한 서버 부하로 인한 상당량의 처리 및 메모리 소비와 같은 단점도 가지고 있습니다. 또한 채팅 앱 및 멀티플레이어 게임과 같은 실시간 애플리케이션에는 적합하지 않을 수 있습니다.\n\n따라서 요구 사항을 고려하고 SSR 구현이 해당 요구 사항과 일치하는지 확인해 주세요.","ogImage":{"url":"/assets/img/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18_0.png"},"coverImage":"/assets/img/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18_0.png","tag":["Tech"],"readingTime":5},{"title":"개발자들이 가져야 할 미덕 게으름, 성급함, 오만함","description":"","date":"2024-05-13 00:06","slug":"2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue","content":"\n\n## 프로그래밍 이야기\n\n<img src=\"/assets/img/2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue_0.png\" />\n\n저는 회사에 처음 입사했을 때, 매일 통신 시스템의 테스트 결과 로그를 분석하는 작업을 맡았습니다. 그 당시는 90년대였고, UNIX 워크스테이션이 사용되고 있어서 핵심 작업은 텍스트를 시각적으로 따라가는 것이었습니다.\n\n각 경우마다 작업에 약 2시간이 걸렸습니다. 각 테스트마다 로그에는 200만에서 300만 줄이 들어있었는데, 물론 모든 것을 시각적으로 확인하는 것은 불가능했기 때문에 로그 분석 도구가 준비되었습니다. 그러나 여전히 많은 부분을 시각적으로 검사해야 했기 때문에 체크하기 쉽지 않았습니다. 시간이 많이 소요되는 작업이었습니다.\n\n\n\n그 일을 하루 이틀 해 본 후, 내 불만이 절정에 달했어(성급하게), 그래서 내 눈으로 탐색할 필요 없이 로그 분석 도구의 결과물을 자동으로 더 분석하기로 결정했어. 내가 했었던 것(1. 태만함).\n\n물론, 이 사실을 상사에게 이야기하면, 그들은 즉시 부인할 거야. 그래서 나는 혼자 시작하기로 결정했어(3. 오만함 → 그러나, 이게 맞는지는 모르겠어. 아마 아니야).\n\n첫 번째 버전을 만드는 데 10시간 이상이 걸렸어. 물론, 그동안 내 분석 작업은 전혀 진전되지 않았어. 그래서 실행해 보니 버그가 가득했어. 그런 걸 만드는 게 익숙하지 않아서, 이건 정상적인 일이야.\n\n그러나 나는 포기하지 않고 계속 수정작업을 반복했어. 복잡한 정규 표현식 패턴, 유한 오토마타 개념, 및 lexer와 parser를 만드는 방법을 배우며. 프로그램이 자동으로 분석할 수 있는 것을 시각적으로 확인할 필요가 없는 바보 같은 일을 하고 싶지 않았어.\n\n\n\n약 일주일 만에 우리는 간단한 언어로 확인하려는 테스트 순서를 정의할 수 있는 매우 기능적인 확인 도구를 만들었어요. 여러 차례 테스트해보았고, 완벽하게 작동함을 확인했어요.\n\n테스트 순서가 정의되면, 이 도구는 테스트 결과가 올바른지 약 10초 안에 확인할 수 있어요. 그래서 일주일 이상 방치되어 있던 분석 작업이 반나절 이내에 완료되었답니다.\n\n그래서 같은 작업을 하는 다른 팀원들에게도 사용해보라고 제안했어요. 당연히 팀의 작업 부담은 급격하게 줄었답니다.\n\n그 이후로, 몇 분 안에 수행할 수 있는 작업이라도 반복이 필요하다면 몇 시간이 걸리더라도 도구를 만들어 자동화하는 내 스타일을 고수해왔어요. 특히 업무 코딩할 때 많이 활용했답니다.\n\n\n\n가능한 한, 저는 입력 완성 기능이 없는 편집기가 없던 시절에 직접 입력하는 대신 프로그램을 자동으로 생성했어요.\n\n물론 처음에는 작업 효율이 비교적 낮았어요 (예를 들어, 2시간이 걸리는 작업을 10초로 자동화하여 10분이 걸리는 것으로 대체하는 것). 그래도 익숙해지면 약 10분 정도만에 빠르게 도구를 만들 수 있었어요.\n\n그 시기에 다른 사람들이 며칠이 걸리는 작업을 몇 시간 만에 프로그램을 만들 수 있는 사람이 되었고, 팀 내에서의 평판이 상당히 좋아졌어요.\n\n결과적으로, 내 이름은 다른 부서에도 알려지게 되었고, 회사의 운명에 따라 의존해야 하는 필수 프로젝트의 일원으로 채용되었어요. 그 중에서도 산업 최초의 Java 기반 프로젝트와 같은 중요한 프로젝트에 참여하게 되었죠.\n\n\n\n이야기가 회사에서의 네 번째 해까지의 이야기입니다. 나머지 이야기는 너무 길어서 생략하겠습니다.\n\n모든 사람들은 서로 다른 특성을 가지고 있고, 래리 월(Larry Wall)이 말하고자 하는 바와 얼마나 일치하는지 모르겠지만, 매우 일반적인 관점에서 보면 그렇게 멀지 않다고 생각해요. 그렇다고 무조건 그런 것은 아니라고 생각해요.\n\n하지만 당시에는 주변 사람들이 각자 자신만의 언어를 개발하고 그것을 전적으로 프로젝트에 활용했기 때문에, 나는 특별히 재능 있는 것은 아니었어요. 이에 대해 다른 사람이 이야기해야 한다고 생각해요. 또한 제 이야기가 그냥 '90년대 예시'에 불과하다는 점을 강조하고 싶어요.\n\n오늘날 IT 산업은 90년대보다 훨씬 밝은 발전 양식을 보여주고 있어요. 제 당시 스타일은 독이 되는 편일 것입니다. 현재의 나의 관점에서도 \"그게 무슨 문제가 있지?\"라고 생각하지만, 당시에는 그것이 통했어요. 위에 쓴 것은 참고용 예시가 아니라 설명을 위한 샘플일 뿐이에요.\n\n\n\n나에게 프로그래밍은 지루하지만 재미있고, 어려움을 겪어본 적이 없다. 처음에는 성별에 맞았던 것 같다. 사람마다 장단점이 있지요.\n\n한편, 친구는 프로그램을 몇 개 만들어도 재미있는 게 뭔지 모른다고 했다. 그런 사람들에게는 프로그래밍이 빈소 같은 건 아닐까 싶어요. \"특성\"이 이런 면을 포함한다고 말할 수 있습니다.\n\n가장 재능 없는 사람은 프로그래밍이 재밌다고 완전히 집착하고 있어요! 프로그래밍이 짐으로 여기지 않고 \"쓰는 걸 즐기는\" 사람들은 잘못된 프로그램을 만들더라도 계속해서 프로그램을 작성하는 경향이 있어요.\n\n프로그래밍 자체가 목적인 만큼, 이해가 돼요. \"유용한 도구\"를 만드는 걸 즐기고, 프로그래밍을 싫어해요. 그 차이가 클 것이라고 생각돼요.\n\n\n\n# 친절한 영어로 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클로밍하고 팔로우해 주세요️ 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue_0.png"},"coverImage":"/assets/img/2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue_0.png","tag":["Tech"],"readingTime":3},{"title":"JavaScript 이벤트 루프와 비동기 프로그래밍 이해하기","description":"","date":"2024-05-13 00:05","slug":"2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming","content":"\n\n<img src=\"/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_0.png\" />\n\n자바스크립트는 한 번에 하나의 작업을 이벤트 큐에서 처리하기 때문에 싱글 스레드 언어라는 점을 알고 계실 것입니다. 현재 작업이 완료되기 전까지는 다른 작업을 수행할 수 없습니다. 비동기 작업을 처리하는 방식을 이해하는 데 이 특징은 중요합니다.\n\n매우 명확해 보이죠? 그런데 비동기적으로 작업을 수행해야 한다면 어떻게 해야 할까요? 시간이 필요한 단계를 수행해야 하지만 사용자 인터페이스가 멈춰있는 것을 원치 않을 때는 어떻게 해야 할까요?\n\n예를 들어, setTimeout을 사용하여 타이머를 설정하거나 API에서 데이터를 가져올 때, 이와 같이 반만 로드된 웹 사이트를 사용자에게 보여주고 싶지는 않을 것입니다.\n\n\n\n![JavaScript Event Loop and Asynchronous Programming](/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_1.png)\n\n요약해보겠습니다. JavaScript를 단일 스레드 언어로 생각할 때, 위 스니펫은 \"Apple\" → \"Elephant\" → \"Orange\" 순서로 로그를 남길 것으로 생각할 수 있습니다.\n\n하지만 실제 결과는 \"Apple\" → \"Orange\" → \"Elephant\" 순서로 나타납니다.\n\n- console.log(‘Apple’) : 이 부분은 콘솔에 \"Apple\"을 동기적으로 기록합니다.\n- setTimeout(() => console.log('Elephant'), 0): 이 부분은 \"Elephant\"를 0밀리초의 지연 후 콘솔에 기록하기로 예약합니다. 그러나 지연이 0밀리초로 지정되어 있더라도, Node.js와 같은 JavaScript 엔진은 이 작업을 콜백 큐로 밀어 넣어 모든 동기적 작업이 완료된 후에 실행되도록 합니다.\n- console.log('Orange'): 이 부분은 첫 console.log('Apple') 문 이후에 콘솔에 \"Orange\"을 동기적으로 기록합니다.\n- 결국, 모든 동기적 작업이 완료된 후 이벤트 루프가 타임아웃 작업을 가져와 \"Elephant\"를 콘솔에 기록합니다.\n\n\n\n# 이벤트 루프\n\n이전에 언급한 대로 JavaScript는 한 번에 한 가지 일만 할 수 있기 때문에 비동기 작업을 관리하고 이러한 블로킹 함수가 다른 이벤트의 실행을 방해하는 것을 방지하는 메커니즘이 필요합니다.\n\n이 메커니즘을 \"이벤트 루프\"라고 합니다. 기본적으로 비동기 함수가 발견되면 이후에 실행할 콜백 대기열에 추가되어 런타임이 동기 코드를 계속 실행하도록 허용합니다.\n\n여기 JavaScript 이벤트 루프 모델이 있습니다:\n\n\n\n![이미지1](/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_2.png)\n\n![이미지2](/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_3.png)\n\n1. 호출 스택:\nJavaScript는 호출 스택을 사용하여 프로그램 내의 함수를 추적하고 동기 방식으로 함수 호출을 관리합니다. 함수가 호출되면 호출 스택의 맨 위에 추가되며, 함수가 반환되면 스택에서 제거됩니다. 이 프로세스는 나중에 추가된 것이 먼저 제거되는 (Last In, First Out, LIFO) 원칙을 따릅니다.\n\n2. 메모리 힙:\nJavaScript 런타임에서 메모리 힙은 동적으로 할당된 객체와 변수가 위치하는 메모리 영역입니다.\n\n\n\n3. Callback Queue:\n비동기 함수의 콜백이 대기열에 저장되어 있고, 호출 스택이 비어 있을 때 실행을 위해 대기하는 곳입니다. 이벤트 루프가 이를 처리하기 위해 가져와서 처리합니다.\n\n4. 이벤트 루프:\n이벤트 루프는 콜백 대기열과 호출 스택을 모니터링하는 계속적으로 실행되는 프로세스입니다. 호출 스택이 비어 있지 않으면, 이벤트 루프는 호출 스택이 비어질 때까지 기다렸다가 다음 함수를 콜백 대기열에서 호출 스택으로 이동시킵니다.\n\nJavaScript 자체는 본질적으로 동기적이지만, Web API 및 이벤트 루프와 같은 메커니즘을 통해 비동기 작업을 효과적으로 처리할 수 있습니다.\n\n# 작업 및 마이크로작업\n\n\n\n더 자세히 살펴보면, 실행 문맥에는 두 가지 다른 유형이 있습니다: 작업과 마이크로태스크가 있습니다. JavaScript의 이벤트 루프에서 언제 실행되는지에 따라 다른 우선순위를 갖습니다.\n\n호출 스택이 비어있을 때, 먼저 마이크로태스크 큐를 확인합니다. 마이크로태스크 큐도 비어있으면 태스크 큐에 있는 함수를 실행하기 시작합니다.\n\n태스크\n\n태스크는 이벤트 루프에서 더 높은 수준의 작업 단위입니다. 일반적으로 I/O 작업, 렌더링 및 사용자 입력 이벤트와 같은 다른 비동기 이벤트가 포함됩니다.\n\n\n\n일반적인 작업 예시로는 setTimeout, setInterval, DOM 조작, 그리고 사용자 상호작용을 위한 이벤트 리스너 등이 있습니다.\n\n마이크로태스크\n\n마이크로태스크는 이벤트 루프에서 작업보다 우선순위가 높은 하위 수준의 작업 단위입니다. 일반적으로 브라우저가 렌더링을 수행하거나 다른 상위 수준의 작업을 수행하기 전에 실행되어야 하는 비동기 작업에 사용됩니다.\n\n예시로는 프로미스(해결됨 또는 거부됨)과 변이 관찰자가 있습니다.\n\n\n\n![JavaScript Event Loop](/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_4.png)\n\n요약하자면, JavaScript의 이벤트 루프는 웹 API에 작업을 전달하고, 그 작업을 태스크 큐에서 가져와 콜 스택에서 실행하는 주기적인 프로세스를 포함합니다. 작업을 지속적으로 관리하는 이 프로세스는 JavaScript에서 실행 흐름을 주도합니다.\n\n# 참고 자료\n\n[Philip Roberts: 이벤트 루프가 도대체 뭐길래]\n(https://youtu.be/8aGhZQkoFbQ)\n\n\n\n[JavaScript의 콜 스택이란 무엇인가요?]\nhttps://www.linkedin.com/pulse/what-call-stack-javascript-jay-tillu-252vf/\n\n[이벤트 루프 - 친숙하면서도 낯선 것들]\nhttps://medium.com/@Hsu.Yang-Min/event-loop-a61631e0048b","ogImage":{"url":"/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_0.png"},"coverImage":"/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_0.png","tag":["Tech"],"readingTime":4},{"title":"네이드 포 스피드 C, NET 8 SSE  채널을 활용한 LLMs Beyond OpenAI, Llama3 및 Fireworksai","description":"","date":"2024-05-13 00:03","slug":"2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai","content":"\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*YtK6hvB_PrUvd7uwqrk0-w.gif\" />\n\n# 요약\n\n- OpenAI의 GTP-4는 일반적인 목적의 작업에 있어 압도적인 성능을 보여주지만, 전체적인 처리량(또는 오히려 그 부족함)이 많이 부족하다는 점이 매우 아쉽습니다. 이는 \"오프라인\" 작업에는 훌륭하지만, 사용자들이 더 많은 응답성을 기대하는 응용 프로그램에서는 적합하지 않을 수 있으며, 몇몇 사용 사례들은 하위 UX로 인해 배제될 수도 있습니다.\n- TheFastest.ai 팀의 최근 Hackernews 게시물은 모델과 플랫폼 모두에 대해 이런 차이가 얼마나 클 수 있는지를 강조하고 있습니다. 특히, Groq.com(Musk의 Grok와 혼동하지 말아야 합니다)와 Meta의 Llama 3 70B를 사용한 Fireworks.ai는 일부 작업에서 GPT-4와 비교했을 때 출력에 거의 희생 없이 빠른 처리량을 제공합니다.\n- C#/.NET 8 System.Threading.Channels와 서버 전송 이벤트(SSE)를 결합하면, OpenAI의 처리량과 높은 지연 시간으로 잘 동작하지 않은 작업을 구성할 수 있습니다.\n\n# 소개\n\n\n\nGPT-5를 기다리는 동안, 2024년 5월 OpenAI의 GPT-4가 여전히 LLM으로서 전반적인 성능 면에서 우수하다는 것에 대해 논쟁하는 사람은 거의 없을 것입니다. 그러나 해당 모델은 비교적 낮은 처리량과 높은 대기 시간으로 인해 UX가 더 상호 작용적인 경험을 요구하는 경우에는 최적이 아닐 수 있습니다.\n\n가장 빠른 LLM과 현재 사용 가능한 플랫폼과 OpenAI 간의 대기 시간 차이의 규모가 얼마나 큰지는 명백하지 않을 수 있습니다.\n\n최근 Hackernews 스레드를 통해 TheFastest.ai로 이동하게 되었고, Meta의 Llama 3의 높은 처리량과 Groq.com 및 Fireworks.ai라는 두 플랫폼에 흥미로웠습니다.\n\n(전자는 종종 머스크의 Grok AI와 혼동되기 때문에 불행합니다).\n\n\n\n이 기사에서는 Fireworks.ai, Meta Llama 3 8B/70B, .NET 8, System.Threading.Channels 및 Server Sent Events (SSE)를 사용하여 앱을 만드는 방법을 살펴볼 것입니다.\n\n# 차이를 측정하기\n\n스택의 상단은 Llama-3과 Groq가 지배하고 Fireworks.ai가 상위 5위를 차지하고 있습니다(각 팀이 Fireworks를 선택해야 할 이유에 대해 조금 뒤에 설명하겠습니다).\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_0.png)\n\n\n\n대조적으로, OpenAI의 GPT-4는 거의 맨 아래쪽에 위치합니다.\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_1.png)\n\nOpenAI의 GPT-4를 사용해본 사람이라면 이미 처리량이 얼마나 낮은지를 알고 있을 것입니다. 하지만 이렇게 측정된 값을 보면 그 간격이 얼마나 큰지 더욱 부각됩니다. Groq의 Llama-3 70B는 GPT-4보다 거의 10배 더 높은 처리량을 가지고 있습니다!\n\n이에 따라, GPT-4는 상호 작용이 필요하지 않은 경우에, 작업이 큰 문맥 창을 요구하는 경우에, 또는 복잡한 프롬프트와 문맥을 사용하여 \"벤치마크 품질\"의 결과가 필요한 경우에 실제로 매우 좋다고 생각했습니다.\n\n\n\n하지만 사용 사례에 다른 요구 사항이 있는 경우는 어떨까요? 속도가 필요한 경우는 어떨까요?\n\n# Groq와 Fireworks를 이용해 시동 걸기\n\nOpenAI의 처리량이 떨어져 사용자 경험을 나빠지게 만들 수 있는 문제 중 하나는, 최종적으로 콘텐츠가 가치를 추가한다 해도 주관적으로 사용자 경험을 나빠지게 할 수 있다는 것입니다.\n\nOpenAI의 ChatGPT를 사용할 때, 채팅 응답에 몇 초가 걸릴 수도 있다는 사실을 SSE가 가려버리기 때문에 명확하게 드러나지 않을 수 있습니다. GPT-4의 처리량이 낮다는 것은 다른 대안을 시도해보기 전까지는 쉽게 알아챌 수 없습니다.\n\n\n\n# Groq.com\n\nGroq는 LLM에 특별히 설계된 사용자 정의 하드웨어로 알려진 \"LPU\" 또는 \"언어 처리 유닛\"을 갖춘 흥미로운 플랫폼입니다:\n\n적어도 문서로 보면, 이것은 마케팅 허세 이상으로 보이며 플랫폼은 객관적으로 고 처리량을 자랑합니다.\n\n하지만 주요 문제는 현재의 SaaS 제공으로 이어집니다:\n\n\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_2.png)\n\n무료 티어는 실험 용도로만 사용 가능하며, 그것도 겨우 가능할 뿐입니다.\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_3.png)\n\n그래서 Groq은 꽤 빠르지만, 샌드박싱 용도 외에는 사용할 수 없으며, 가능하다면 엔터프라이즈 과금을 통해 사용할 수 있습니다.\n\n\n\n# Fireworks.ai\n\n현재 시점에서 Fireworks의 Llama-3 70B는 전체적으로 9위에 랭크되어 있으며 두 번째로 빠른 Llama-3 70B입니다:\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_4.png)\n\n마지막 토큰까지 260ms가 소요되며, 여전히 매우 빠르며 GPT-3.5와 GPT-4 사이의 성능을 제공하여 내 사용 사례에 대한 LLM 성능이 매우 좋습니다.\n\n\n\nFireworks.ai에는 중간 유료 티어가 없지만, 600 RPM은 작은 앱에 사용하기 적합하며 하드 토큰 제한이 없습니다.\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_5.png)\n\n오늘 빠르게 무언가를 구축하려는 팀들에게는 Fireworks.ai가 아마도 최선의 선택일 것입니다. (아니, 나는 그들로부터 돈을 받고 있지 않아요)\n\n# .NET 8, System.Threading.Channels 및 Server Sent Events (SSE)와 함께 실용적인 예제\n\n\n\n이 놀라운 처리량을 활용하기 위해서는 한 번에 여러 개의 스트림을 통해 생성한 다음 하나의 최종 출력 스트림으로 병합하는 동시 처리 전략이 필요합니다.\n\n이는 .NET의 System.Threading.Channels를 Server Sent Events (SSE)와 결합하여 이 처리량을 완전히 활용하고 높은 반응성을 갖는 생성 AI 경험을 구축하는 완벽한 사용 사례입니다.\n\n이전에 이 두 주제에 대해 별도로 다뤘었습니다:\n\n- .NET Task Parallel Library vs System.Threading.Channels\n- .NET 6의 System.Threading.Channels를 이용한 동시 처리 (보너스: 간격 트리)\n- .NET 7과 함께하는 Server Sent Events\n\n\n\n오늘은 .NET 8 채널, Semantic Kernel 및 gen AI와 함께 어떤 대화형 경험을 만들 수 있는지 함께 살펴보겠습니다!\n\n![image](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_6.png)\n\n저희 샘플 응용 프로그램은 준비된 재료 목록과 목표 조리 시간을 받아들여서 다음을 할 것입니다:\n\n- 해당 재료로 만들 수 있는 레시피 목록 생성\n- 레시피 중 하나를 무작위로 선택\n- 레시피를 위해 필요한 모든 재료 목록 생성\n- 레시피를 위한 소개 단락 생성\n- 준비된 각 재료에 대한 영양 정보에 대한 간략한 설명 생성\n- 제안된 사이드 디시 목록 생성\n- 순서 목록 생성\n\n\n\n단계 3~6은 병렬로 실행될 수 있지만, 레시피를 먼저 선택해야 하기 때문에 단계 1~2가 먼저 실행됩니다. 그리고 단계를 생성하기 전에 재료 전체 목록을 기다려야 합니다.\n\n# .NET 채널을 이용한 병행 실행\n\nAPI 호출의 진입점은 요청을 받을 단일 POST 엔드포인트입니다:\n\n```js\n// 👇 메인 진입점.\napp.MapPost(\"/generate\", async (\n  HttpContext context,          // 의존성 주입에서 가져옴\n  RecipeGenerator generator,    // 의존성 주입에서 가져옴\n  RecipeRequest request,        // 바디에서 가져옴\n  CancellationToken cancellation = default\n) =>\n{\n  context.Response.Headers.ContentType = \"text/event-stream\";\n\n  await generator.GenerateAsync(\n    request,\n    // 각 단편에 대한 스트리밍 응답을 작성하는 핸들러\n    async (Fragment f) => {\n      await context.Response.WriteAsync(\n        $\"data: {f.Part}|{f.Content}{Environment.NewLine}{Environment.NewLine}\",\n        cancellation\n      );\n      await context.Response.Body.FlushAsync(cancellation);\n    }\n  );\n});\n```\n\n\n\nRecipeGenerator.GenerateAsync 메서드에는 메인 플로우가 포함되어 있어요:\n\n```js\n/// <summary>\n/// 주요 시작점\n/// </summary>\npublic async Task GenerateAsync(\n  RecipeRequest request,\n  Func<Fragment, Task> handler, // 👈 이것은 HTTP 응답 스트림에 연결된 후크에요\n  CancellationToken cancellation = default\n) {\n\n  var (ingredientsOnHand, prepTime) = request;\n\n  // 👇 (1) 3개의 레시피 목록을 생성하고 무작위로 하나를 선택\n  var recipes = await GenerateRecipesAsync(ingredientsOnHand, prepTime, cancellation);\n\n  Console.WriteLine($\"생성된 레시피 수: {recipes.Length}.\");\n\n  var recipe = recipes[Random.Shared.Next(0, 2)];\n\n  // 👇 (2) 모든 레시피를 보유하여 HTML 문자열로 집계\n  var alternates = recipes\n    .Where(r => r.Name != recipe.Name)\n    .Aggregate(new StringBuilder(), (html, r) => {\n      html.Append($\"<li><b>{r.Name}</b> &nbsp;\");\n      html.Append($\"<i>{r.Intro}</i></li>\");\n\n      return html;\n    }).ToString();\n\n  // 👇 (3) 읽기 채널의 리더 측에 대한 반복 작업입니다; 먼저 시작해야 해요\n  var fragmentHandler = async () => {\n    while (await _channel.Reader.WaitToReadAsync()) {\n      if (_channel.Reader.TryRead(out var fragment)) {\n        await handler(fragment);\n      }\n    }\n  };\n\n  var completion = fragmentHandler();\n\n  // 👇 (4) 이제 세대 프롬프트를 동시에 실행해요\n  Task.WaitAll([\n    handler(new (\"alt\", alternates)),\n    GenerateIngredientsAsync(recipe, ingredientsOnHand, request.PrepTime, cancellation),\n    GenerateIntroAsync(recipe, cancellation),\n    GenerateIngredientIntroAsync(ingredientsOnHand, cancellation),\n    GenerateSidesAsync(recipe, cancellation)\n  ]);\n\n  // 👇 (5) 그리고 모든 작업이 완료될 때까지 기다려요.\n  _channel.Writer.Complete();\n\n  await completion;\n}\n```\n\n여기서 Task.WaitAll의 중요한 차이점은 JavaScript의 Promise.all과 개념적으로 비슷하지만, .NET에서는 멀티 스레드인 .NET 런타임 때문에 동시성과 병렬로 실행될 수 있어요. 이 경우 스레드 풀 스케줄러가 각 작업이 다른 스레드에서 실행될지 여부를 결정할 거에요. 채널을 사용하면 출력을 하나의 스레드에 바인딩된 리더에 병합하여 동기화된 액세스가 필요 없어졌어요.\n\n각 세대 작업은 비슷한 패턴을 따라가요:\n\n\n\n```js\nprivate async Task GenerateIntroAsync(\n  RecipeSummary recipe,\n  CancellationToken cancellation = default\n) {\n  var prompt = \"...\";\n\n  await ExecutePromptAsync(\n    \"int\", // 👈 이것은 프론트엔드 출력 대상의 ID와 일치합니다\n    prompt,\n    new () {\n      MaxTokens = 250,\n      Temperature = 0.55,\n      TopP = 0\n    },\n    cancellation: cancellation\n  );\n}\n```\n\n그리고 프롬프트를 실행하는 메서드:\n\n```js\n/// <summary>\n/// 프롬프트를 실행하고 결과를 채널에 작성합니다.\n/// </summary>\nprivate async Task ExecutePromptAsync(\n  string part,\n  string prompt,\n  OpenAIPromptExecutionSettings settings,\n  Action<string>? resultHandler = null,\n  string? modelOverride = null,\n  CancellationToken cancellation = default\n) {\n  // 👇 대화를 초기화합니다\n  var chat = _kernel.GetRequiredService<IChatCompletionService>(\n    modelOverride ?? \"70b\" // 명시된 오버라이드가 없으면 70b를 사용합니다.\n  );\n\n  var history = new ChatHistory();\n  var buffer = new StringBuilder();\n\n  history.AddUserMessage(prompt);\n\n  // 👇 응답을 스트리밍하고 각 부분을 채널에 작성합니다\n  await foreach (var message in chat.GetStreamingChatMessageContentsAsync(\n      history, settings, _kernel, cancellation\n    )\n  ) {\n      await _channel.Writer.WriteAsync( // 👈 채널의 라이터 엔드\n        new(part, message.Content ?? \"\"),\n        cancellation\n      );\n\n      buffer.Append(message.Content); // 👈 전체 출력을 보유하는 버퍼\n  }\n\n  var output = buffer.ToString();\n\n  // 👇 호출자가 전체 결과를 원하는 경우 여기에서 사용할 수 있습니다\n  resultHandler?.Invoke(output);\n}\n```\n\n애플리케이션 실행 중 의존성 주입을 통해 커널 인스턴스가 구성됩니다:```\n\n\n\n```js\r\n// Program.cs\nvar builder = WebApplication.CreateBuilder(args);\n\nvar fireworksEndpoint = new Uri(\"https://api.fireworks.ai/inference/v1/chat/completions\");\nvar groqEndpoint = new Uri(\"https://api.groq.com/openai/v1/chat/completions\");\n\nvar config = builder.Configuration\n  .GetSection(nameof(RecipesConfig))\n  .Get<RecipesConfig>();\n\n// Semantic Kernel을 설정하여 필요한만큼의 LLM을 등록합니다.\nvar kernelBuilder = Kernel.CreateBuilder();\nvar kernel = kernelBuilder\n  .AddOpenAIChatCompletion(\n    modelId: \"accounts/fireworks/models/llama-v3-70b-instruct\",\n    apiKey: config!.FireworksKey,\n    endpoint: fireworksEndpoint,\n    serviceId: \"70b\" // 👈 더 나은 결과를 위해 기본적으로 이 serviceId를 사용합니다\n  )\n  .AddOpenAIChatCompletion(\n    modelId: \"accounts/fireworks/models/llama-v3-8b-instruct\",\n    apiKey: config!.FireworksKey,\n    endpoint: fireworksEndpoint,\n    serviceId: \"8b\" // 👈 더 빠른 속도가 필요한 경우 이 serviceId를 사용합니다\n  )\n  .AddOpenAIChatCompletion(\n    modelId: \"llama3-8b-8192\",\n    apiKey: config!.GroqKey,\n    endpoint: groqEndpoint,\n    serviceId: \"groq-8b\" // 👈 최대 처리량을 위해 이 serviceId를 사용합니다\n  )\n  // 다른 LLM을 여기에 등록합니다.\n  .Build();\n\nbuilder.Services\n  .Configure<RecipesConfig>(\n    builder.Configuration.GetSection(nameof(RecipesConfig))\n  )\n  .AddCors()\n  .AddSingleton(kernel)  // 👈 설정된 kernel을 싱글톤으로 추가합니다\n  .AddScoped<RecipeGenerator>();\r\n```\n\nSemantic Kernel을 통해 여러 LLM 엔드포인트를 구성할 수 있습니다. 이를 사용하여 작은 빠른 LLM이 프로세스를 가속화할 수 있는 플로 구현을 단순화할 수 있습니다.\n\n# SSE를 활용한 동시 스트림\n\n컨텐츠가 생성되면 백엔드는 즉시 프론트엔드로 스트리밍하여 매우 반응이 뛰어난 사용자 경험을 제공합니다. 이 과정은 동시에(그리고 스레드 풀 스케줄러에 따라 확장하여 병렬로) 발생하며, 채널에 수집되어 클라이언트에서 소비될 응답 스트림으로 작성됩니다.```\n\n\n\n이 흐름을 시각화하기 위해 아래 다이어그램을 확인해보세요:\n\n![다이어그램](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_7.png)\n\nTask.WaitAll 코드 블록은 채널의 공유 가능하고 스레드 안전한 writer 엔드를 전달받은 상태이며, reader 엔드는 HTTP 응답 스트림과 콜백을 통해 연결됩니다.\n\n해당 콜백은 간단히 EventSource의 필요한 형식 명세에 따라 Fragment를 서식화합니다.\n\n\n\n이 경우:\n\n```js\ndata: ing|tomatoes\n\ndata: ing|basil\n\ndata: ste|3. Chop the\n```\n\n프론트엔드는 이러한 메시지 스트림을 받아 UI의 서로 다른 섹션에 누적합니다.\n\n- 첫 번째 부분인 ing은 이 내용이 속하는 프론트엔드 부분을 식별합니다 (이 경우에는 \"재료\")\n- | 이후의 텍스트는 LLM에 의해 작성된 출력 토큰 세트를 의미합니다.\n\n\n\n프론트엔드에서 @microsoft/fetch-event-source는 기본 EventSource를 대체하여 POST 사용을 가능하게 하는 폴리필(polyfill)로 사용됩니다.\n\n수신자는 각 메시지를 가져와 디코드합니다:\n\n```js\nonmessage: (msg) => {\n  var payload = msg.data\n\n  var [part, content] = payload.split('|')\n\n  if (!part || !$el(`#${part}`)) {\n    return // 이 메시지는 버립니다\n  }\n\n  // 👇 이 부분은 새 줄을 인코딩하고 여기서 대체하는 해킹입니다.\n  content = content.replace(/⮑/gi, \"\\n\")\n\n  $el(`#${part}`).innerHTML += content\n},\n```\n\ntext/event-stream의 특이점은 이중 줄바꿈이 메시지 블록의 끝을 나타낸다는 것입니다. 그래서 줄바꿈은 어떤 방식으로든 인코딩되어야 합니다 (다양한 방법이 있습니다). 이 경우, 단일 문자 ⮑을 사용하여 해당 문자를 찾아 \\n으로 대체하는 것이 간답습니다.\n\n\n\nCSS는 그냥 이 부분을 고려하면 됩니다:\n\n```js\n#add, #ing, #ste {\n  white-space: pre-line;\n}\n```\n\nHTML 자체는 간단합니다:\n\n```js\n<!-- 이 블록은 추가 재료를 보관합니다 -->\n<div class=\"additional\">\n  <h2>필요한 재료</h2>\n  <!-- 👇 이 ID는 Fragment.Part와 일치합니다 -->\n  <div id=\"add\"></div>\n</div>\n\n<!-- 이 블록은 단계를 보관합니다 -->\n<div class=\"recipe\">\n  <h2>조리 단계</h2>\n  <!-- 👇 이 ID는 Fragment.Part와 일치합니다 -->\n  <div id=\"ste\"></div>\n</div>\n```\n\n\n\n# 모두가 준비되었으니 이제 앱을 실행하면 다음과 같은 경험을 할 수 있습니다:\n\n![recipe app](https://miro.medium.com/v2/resize:fit:1400/0*uCMJGy8UoyaC4rFX.gif)\n\n레시피 목록을 생성하는 호출이 차단되므로 약간의 초기 지연이 있습니다.\n\n\n\n그러나 한 번 목록이 생성되고 무작위로 선택된 후, 추가적인 생성은 전체 재료 목록에 의해 차단되는 단계만 동시에 발생합니다. (전체 재료 목록을 사용하여 정확한 단계를 생성해야 하기 때문입니다).\n\n# 결론\n\n사용자 경험(UX)이 높은 처리량을 필요로 하며 작은 컨텍스트 창을 통해 작동할 수 있는 애플리케이션의 경우, Fireworks.ai와 Llama-3 8B/70B는 절대적으로 게임 체인저입니다. 그것은 팀이 OpenAI의 GPT 모델의 높은 지연 때문에 전반적인 UX를 희생시키지 않고 사용 사례에 대해 빌드할 수 있도록 해줍니다.\n\nSystem.Threading.Channels를 사용한 .NET 8 웹 API에 그것을 플러그인하고 SSE와 결합하면, 여러 콘텐츠 청크를 동시에 생성하고, 상호작용적인 생성 AI 경험을 더 많이 구축하거나 생성적인 워크플로우를 간단히 가속화하는 새로운 가능성을 열 수 있습니다.\n\n\n\n동일한 기술을 사용하면 (SSE를 제외하고) 낮은 지연 시간 + 높은 처리량 모델 및 플랫폼을 사용하여 여러 프롬프트를 병렬로 처리하여 서버 생성 워크로드의 처리량을 늘릴 수 있습니다.\n\n전체 repository:","ogImage":{"url":"/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_0.png"},"coverImage":"/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_0.png","tag":["Tech"],"readingTime":13},{"title":"프론트엔드 성능에 대해 이야기할 때, 우리는 무엇을 얘기하고 있는 걸까요","description":"","date":"2024-05-12 23:59","slug":"2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout","content":"\n\n<img src=\"/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_0.png\" />\n\n이 기사에서는 Google의 공식 도구 라이트하우스를 활용하여 최신 프런트엔드 페이지 성능 평가 표준을 분석하여 다양한 성능 지표를 이해하고 관련 프런트엔드 프로젝트를 개선하고 최적화하는 데 도움을 줍니다.\n\n프런트엔드 페이지 성능은 사용자 유지율이 페이지 로드 성능과 밀접한 연관이 있기 때문에 모두에게 항상 연속적인 관심사였습니다. 구글의 데이터 통계에 따르면, 페이지 방문 시간이 1초에서 3초로 증가할 때 사용자의 이탈률이 32% 증가합니다.\n\n프런트엔드 페이지 성능을 평가하는 두 가지 방법이 일반적으로 있습니다: 하나는 성능 분석 도구를 사용하여 온라인에서 다양한 지표를 점수화하고 평가하는 것이며, 다른 하나는 성능 모니터링을 사용하여 Performance API나 사용자의 실제 네트워크 액세스 상황을 보고한 후 통계 분석을 수행하는 것입니다.\n\n\n\n사용자 데이터를 통계적으로 수집하는 것이 더 현실적이지만 페이지 성능 평가에 대한 통일된 양적 기준을 갖기 위해 종종 페이지 성능을 평가하는 데 표준 평가 도구를 사용하기로 선택합니다.\n\n성능 분석 초기 단계에서는 Chrome 개발자 도구를 사용하여 웹 페이지를 분석하며, 로드 및 DOMContentLoaded와 같은 이벤트가 발생하는 시간을 확인합니다. 나중에 Webpage Analyzer, WebPageTest, YSlow 등과 같은 일련의 성능 분석 도구가 등장했습니다.\n\n이제 Google은 자체 개발한 Lighthouse를 공식적으로 개발자 도구 탭에 내장시켰으므로, Lighthouse를 표준 평가 도구로 고려합니다.\n\nLighthouse는 페이지의 최상의 사례에 관한 관련 권고 사항을 제공하는 오픈 소스 웹 페이지 성능 분석 도구입니다. Chrome DevTools에서 직접 사용할 수도 있을 뿐만 아니라 브라우저 확장 프로그램(Chrome 및 Firefox)이나 npm 패키지(Node API 또는 CLI)도 지원합니다.\n\n\n\nGoogle의 Web Measure 및 PageSpeed Insight와 같은 도구는 페이지를 분석하는 라이트하우스를 사용합니다.\n\n## 1. 라이트하우스의 반복 및 성능 지표 변경\n\n라이트하우스의 최초 오픈 소스 버전은 2016년으로 거슬러 올라가며, 2020년 10월 기준 최신 버전은 6.4.1이며, 총 89번의 반복을 거쳤습니다. 이들 몇 년 사이에, 라이트하우스는 성능 메트릭스(지표)를 업데이트해 왔습니다.\n\n최신 버전 6.X에서 Google은 5.X 버전과 비교해 세 가지 새로운 성능 메트릭스를 소개했습니다: FMP(첫 의미 있는 그림 렌더링), FCI(첫 CPU 비활성 및 mpFID(최대 잠재 첫 입력 지연)가 제거되었습니다.\n\n\n\nTBT (Total Blocking Time), LCP (Largest Contentful Paint), and CLS (Cumulative Layout Shift)가 추가되었습니다. 다음 섹션에서는 이러한 지표들에 대한 자세한 설명을 제공할 것입니다.\n\n![image](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_1.png)\n\n## 2. 페이지 성능 점수 계산 방법\n\n아래 그림에서 보듯이, 페이지 성능 섹션에서 Lighthouse는 6가지 주요 지표의 성능을 평가하고 페이지의 성능 점수를 계산할 것입니다.\n\n\n\n![표](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_2.png)\n\n최신 6.X 계산 방법에 따르면 각 성능 메트릭은 점수에 대응됩니다. 예를 들어, 위 그림에서 FCP, SI, LCP, TTI, TBT 및 CLS의 값은 각각 78, 62, 37, 5, 99, 92에 해당하는 개별 점수입니다. 일반적으로 메트릭 값이 작을수록 해당하는 점수가 높습니다.\n\n이 여섯 메트릭에 할당된 가중치는 각각 15%, 15%, 25%, 15%, 25%, 5%입니다. 전체 성능 점수는 가중 평균을 통해 60점으로 계산됩니다.\n\n각 메트릭 값이 해당하는 점수 계산 방법은 이 기사 끝에 있는 참고 자료 번호 다섯와 여섯에서 자세히 확인할 수 있습니다.\n\n\n\n라이트하우스 v6.0.에서는 FMP (First Meaningful Paint), FCI (First CPU Idle) 및 mpFID (Maximum Potential First Input Delay)와 같은 세 가지 핵심 성능 지표가 제거되었습니다.\n\n현재 버전이 그들의 메트릭을 선택하는 방식을 더 잘 이해하기 위해 이 세 가지 폐기된 지표의 정의를 살펴보겠습니다.\n\n## 1. FMP란 무엇이며 FCP와 어떤 차이가 있는가?\n\nFMP에 대해 이야기할 때에는 먼저 First Contentful Paint (FCP)를 소개해야 합니다: 첫 번째 콘텐츠 렌더링 시간입니다.\n\n\n\n위에서 언급한 대로, 브라우저가 처음으로 'First Page Paint' 이벤트를 트리거하면, 이 순간이 FCP가 됩니다. 하지만, 이때 렌더링되는 내용이 반드시 중요한 페이지 정보일 필요는 없습니다. 예를 들어, 헤더 액션바를 그리거나 심지어 가시적인 요소만 렌더링되는 경우도 있을 수 있습니다. Lighthouse 6.0에는 여전히 포함되어 있지만, 성능 점수에서의 비중은 23%에서 15%로 감소했습니다.\n\n그러므로, FCP는 사용자 관점에서 페이지 성능을 정확히 판단할 수 있는 지표로 사용할 수 없습니다.\n\n이 맥락에서 'FMP (First Meaningful Paint)'이 등장했습니다. 공식적인 정의에 따르면, FMP는 페이지 로딩이 시작된 후 초기 화면에 가장 많거나 주요 콘텐츠가 렌더링된 시점을 말합니다.\n\n그렇다면, FMP 타이밍은 어떻게 확인할까요? 먼저 가장 기본적인 계산 방법을 살펴보겠습니다:\n\n\n\n먼저 레이아웃 오브젝트의 수를 계산합니다 (테스트 계산을 위해 LayoutAnalyzer를 사용하십시오; 참조 17번을 참조하십시오).\n\n아래 그림에서 볼 수 있듯이 페이지 로딩 프로세스는 레이아웃 오브젝트가 레이아웃 트리로 점진적으로 들어가고 렌더링되는 과정입니다.\n\n![이미지](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_3.png)\n\nlayoutAnalyzer는 레이아웃 오브젝트의 수를 모으고, LayoutObjectsThatHadNeverHadLayout라는 카운터로 새로 추가된 레이아웃 오브젝트의 수를 나타냅니다.\n\n\n\n테스트를 통해 다른 카운터와 비교했을 때, 가장 변화가 많이 일어나는 순간은 종종 페이지에서 가장 중요한 요소들이 렌더링될 때입니다.\n\n따라서 FMP 지표의 계산 방법은 LayoutObjectsThatHadNeverHadLayout(새롭게 추가된 레이아웃 오브젝트)가 가장 큰 변화를 경험한 다음 순간입니다(가장 큰 레이아웃 변경을 따라오는 페인트).\n\n물론, 위의 상황이 적용되지 않는 몇 가지 시나리오도 있습니다:\n\na) 페이지가 긴 경우, 첫 화면 내에는 가시적인 레이아웃 오브젝트보다 보이지 않는 레이아웃 오브젝트가 더 많이 추가될 수 있습니다. 이 경우에는 FMP가 부정확해집니다.\n\n\n\nb) 웹 폰트를 로드하고 텍스트가 레이아웃을 위해 대체 글꼴을 사용하지만 로드 시작으로부터 3초 내에 그려지지 않는 경우; 이는 또한 FMP 계산에 영향을 줄 수 있습니다.\n\n시나리오 1의 경우, FMP는 이 문제를 해결하기 위해 \"레이아웃 중요성\" 개념을 도입했습니다; 시나리오 2의 경우, FMP는 통계를 지연시켜 지표가 페이지 상태를 더 정확하게 반영하도록 합니다. 자세한 해결책은 참조문헌 18을 참조해 주세요.\n\n그러나 FMP는 주요하게 다음 두 가지 이유로 버전 6.0에서 폐기되었습니다.\n\n- 실제 환경에서 FMP는 페이지의 작은 변경에 너무 민감하여 일관되지 않은 결과로 쉽게 이어질 수 있습니다.\n- 이 지표의 정의는 브라우저의 구체적인 구현 세부 사항에 심하게 의존하며 참조를 위한 표준화가 부족합니다.\n\n\n\n# 2. LCP가 FMP를 대체하고 나타났어요\n\n이전 섹션에서 FCP와 FMP의 단점을 언급했었는데요, 그래서 W3C의 성능 그룹은 페이지의 주요 콘텐츠를 사용자가 볼 수 있는 시간을 더 정확하게 반영하는 적절한 지표를 찾고 있었어요.\n\n가끔은 더 간단할수록 더 좋아요. 다양한 소스에서의 토론을 토대로 페이지 성능에 관한 보다 정확한 측정 방법, 즉 LCP (가장 큰 콘텐츠 렌더링)가 마침내 찾아졌어요.\n\nLCP는 뷰포트 내에서 가장 큰 콘텐츠 요소가 렌더링되는 시간을 의미해요. 이 지표는 Lighthouse 6.0에서 공식적으로 소개되었으며 최종 성능 점수에서 25%의 가중치를 갖고 있어요.\n\n\n\nLCP는 FCP와 함께 정의하기 가장 쉬운 메트릭 중 하나여야 합니다. 그 정의에는 비교할 요소 선택과 그 크기를 결정하는 두 가지 중요한 요소가 있습니다.\n\n공식 문서에 따르면, 다음 요소들이 가장 큰 콘텐츠 요소(Largest Contentful Element)의 일부로 고려될 것입니다:\n\n- `img`\n- `svg` 내부의 `image`\n- `video`\n- url() 함수를 통해 배경 이미지를 로드하는 요소\n- 텍스트 노드를 포함하거나 인라인 텍스트 자식 요소를 포함하는 블록 수준의 요소들\n\n요소의 크기를 어떻게 결정할까요? 주로 다음 네 가지 규칙에 기반하여 결정됩니다:\n\n\n\n- 화면 뷰포트 내에서 보이는 요소의 크기; 뷰포트를 벗어나거나 가려지거나 가려지거나 감춰진 경우 크기로 계산되지 않습니다.\n- 이미지 요소의 경우 크기는 실제 크기와 원래 크기 중 작은 것을 취함으로 결정됩니다.\n- 텍스트 요소의 경우 모든 텍스트를 덮는 최소 직사각형 영역만을 고려합니다.\n- 모든 요소의 경우 여백, 안쪽 여백, 테두리 등은 계산에 포함되지 않습니다.\n\n구글은 이 메트릭을 다음과 같이 평가합니다: LCP는 매우 중요한 사용자 중심 지표이며 사용자 수준에서 지각된 로딩 속도를 반영합니다. 주요 콘텐츠에서 가장 큰 콘텐츠 요소의 로딩이 완료된 것을 나타내며, 더 짧은 LCP 시간으로 사용자는 페이지를 더 빠르게 사용 가능하다고 인식하게 됩니다.\n\n# 3. 버려진 FCI와 TTI와 왜 밀접한 관련이 있는가?\n\nFCI(First CPU Idle: 첫 번째 CPU 대기)는 페이지가 최소 상호 작용 표준에 도달하는 데 얼마나 오래 걸리는지를 측정하는 메트릭입니다.\n\n\n\n최소 상호 작용성의 확인을 위해서는 다음 두 가지 조건을 동시에 충족해야 합니다:\n\na) 화면에 있는 대부분의 UI 요소가 상호 작용 가능해야 합니다\n\nb) 페이지가 일반적으로 합리적인 범위 내에서 사용자 입력에 응답해야 합니다\n\nTTI (Time To Interactive: 페이지 상호 작용까지의 시간)는 페이지가 완전히 상호 작용 가능한 상태에 도달하는 데 필요한 시간을 의미합니다.\n\n\n\n\"완전 대화형\"이란 다음 세 가지 조건을 모두 충족하는 것을 의미합니다:\n\na) FCP 이후 페이지에 유용한 콘텐츠가 렌더링되었습니다\n\nb) 가장 눈에 띄는 페이지 요소에 이벤트 콜백이 등록되었습니다\n\nc) 사용자 상호작용에 대한 페이지 응답 시간이 50ms 이내입니다\n\n\n\n2017년에 첫 번째 상호 작용 메트릭이 두 가지 메트릭, 즉 첫 상호 작용 및 일관적 상호 작용으로 나뉘었으며, 이어지는 해의 7월에 첫 상호 작용은 FCI로 변경되었고, 일관적 상호 작용은 TTI로 변경되었습니다. FCI와 TTI는 사용자 상호 작용 응답을 반영하는 두 가지 메트릭임을 볼 수 있습니다.\n\n그렇다면 최소 상호 작용 및 전체 상호 작용은 어떻게 계산되는 걸까요? 구체적인 계산 방법을 소개하기 전에 이 두 가지 메트릭이 모호하며 서로 다른 상황에서 계속 최적화되고 개선될 수 있다는 것을 알아야 합니다.\n\n- FCI의 최소 상호 작용 시간\n\n주 스레드의 타임라인에서 FMP부터 특정 작업이 끝난 후까지 길이가 f(t)인 시간 창 W를 찾습니다. W가 해당 기간 동안 어떤 지점에서도 250ms 이상의 연속적인 작업 집합이 없고, 그 끝과 직전 1초 내에 JS 실행 시간이 50ms를 초과하는 긴 작업이 없으면 해당 작업이 끝난 시점이 우리가 정의하는 FCI입니다. 여기서 f(t)=4e^(-0.045t)+1.\n\n\n\n아래 그림에서 빨간 상자로 표시된 지점이 FCI를 나타냅니다.\n\n![FCI](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_4.png)\n\n- TTI: 완전 상호 작용 시간\n\n네트워크 및 주 스레드의 타임라인에서 처음 5초 창기간 W을 찾으세요. W 기간 내에서 다음 조건을 충족해야 합니다: 어떤 순간에도 동시 네트워크 요청이 최대 두 개이고 50ms를 초과하는 긴 작업이 없습니다. W 이전의 마지막 긴 작업의 종료 시간을 TTI로 지칭합니다.\n\n\n\n아래 그림에서 빨간 상자로 표시된 시점은 TTI입니다:\n\n![Figure](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_5.png)\n\n일부 사람들은 FCI가 특정 시기에 TTI보다 의미가 더 있다고 지적했지만, 이들 사이의 차이는 여전히 라이트하우스가 두 가지 유사한 메트릭을 유지하는 것을 정당화하는데 충분하지 않습니다.\n\n그래서 라이트하우스 버전 6.0에서 최종 결정이 내려져 FCI 대신 TTI를 사용하기로 결정되었습니다.\n\n\n\n# 4. mpFID 및 새로 추가된 TBT 지표\n\nmpFID (최대 잠재적 첫 입력 지연)은 사용자 입력부터 페이지에서 이벤트 콜백을 처리하기 시작하는 실제 시간까지의 잠재적 최대 지연 시간을 나타냅니다.\n\nmpFID의 구체적인 계산 방법은 FCP부터 TTI까지의 JavaScript 실행 시간을 기준으로 가장 긴 작업을 선택한 다음 해당 작업이 소비한 시간에서 50ms를 뺀 것입니다.\n\n그러나 mpFID는 최대 지연 시간만을 나타내며, 사용자가 경험하는 실제 지연 시간과 다를 수 있습니다. 사용자가 다른 시간에 얻는 FID도 다를 수 있습니다. 따라서 mpFID는 페이지의 응답 시간을 사용자 입력에 대한 실제 반응 시간을 정확하게 반영하지 않습니다.\n\n\n\n5. X 버전에서 성능 점수를 계산할 때 mpFID는 가중치가 0으로 설정되어 점수에 기여하지 않습니다. 이 메트릭은 이제 더 이상 보고서에 나타나지 않지만, JSON 데이터에는 유지되며 공식적으로 인정받는 핵심 사용자 경험 지표로 남아 있습니다.\n\n그렇다면 TBT (Total Blocking Time)은 정확히 무엇이며 왜 성능 보고서에서 FID 대신 선택해야 하는 것인가요?\n\n먼저 정의를 살펴보겠습니다: TBT는 페이지에서 사용자 입력에 응답할 때 차단된 총 누적 시간을 의미합니다.\n\n구체적인 계산 방법은 매우 명확합니다 — FCP와 TTI 사이의 모든 긴 작업을 합산하고 그 차단 부분의 시간을 추가하여 TBT를 얻습니다. 차단 부분의 시간이란 긴 작업 실행 시간이 50ms를 초과하는 부분을 말합니다; 예를 들어, 긴 작업이 전체 70ms 걸리면 차단된 시간은 20ms가 됩니다.\n\n\n\nmpFID과 비교해 볼 때 TBT는 사용자 입력에 대한 페이지의 평균 지연 응답을 더 정확하게 반영할 수 있는 더 안정적인 지표입니다.\n\n## 5. 최근 추가된 CLS\n\nCLS (Cumulative Layout Shift)는 시각적 인터페이스의 안정성을 측정하는 지표입니다.\n\n데이터는 레이아웃 불안정성 API(참조 14 참조)에서 얻으며, 계산 방법은 다음과 같습니다:\n\n\n\n\n레이아웃 이동 점수 = 영향 분수 * 거리 분수\n\n영향 분수는 전체 뷰포트에 미치는 영향 정도를 나타냅니다. 예를 들어 아래 이미지에서 텍스트가 전체 뷰포트의 50%를 차지하고 다음 프레임에서 이전 프레임 대비 25% 아래로 이동한다면 전체 페이지의 75%에 영향을 줍니다. 따라서 영향 분수는 0.75입니다.\n\n![이미지](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_6.png)\n\n거리 분수는 비교적 이해하기 쉽습니다. 전체 뷰포트의 변경된 거리 비율을 의미합니다. 예를 들어 위 경우에서 25% 이동은 거리 분수가 0.25를 의미합니다.\n\n\n\n그래서, 그림으로 설명된 데모의 CLS 값은 0.75 * 0.25 = 0.1875로 계산됩니다. 더 자세한 계산 방법은 참고문헌 13과 14에서 확인할 수 있습니다.\n\nCLS가 사용자 경험에 미치는 영향을 설명하는 예시: 아래 다이어그램과 같이 사용자가 취소 버튼을 클릭하려고 할 때, 갑자기 페이지에서 레이아웃이 변경되어 취소 버튼이 있던 자리에 확인 버튼이 나타납니다...\n\n![다이어그램 이미지](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_7.png)\n\nCLS는 사용자 중심의 새로운 성능 평가 지표임을 알 수 있습니다.\n\n\n\n현재 CLS는 새로 추가된 지표로, 가중치가 5%뿐입니다. 하지만 Lighthouse는 다음 주요 버전에서 해당 가중치를 늘릴 계획이라고 합니다.\n\n## 6. 항상 사용되던 속도 지수\n\n속도 지수(Speed Index, SI)는 페이지에서 보이는 내용이 채워지는 속도를 측정하는 데 사용됩니다. 계산 과정은 오픈 소스 도구인 Speedline(참고 문헌 16)을 사용합니다.\n\nSpeedline은 페이지의 비디오를 기록하고 첫 프레임과 마지막 프레임 사이의 시간 차이를 측정하여 속도 지수의 값을 계산합니다.\n\n\n\nSI의 최종 점수는 데이터베이스에 있는 실제 웹 사이트의 SI 값과 비교하여 계산됩니다. 현재 SI 점수와 평가 기준은 아래 표에 표시되어 있습니다:\n\n| 항목 | 점수 |\n|:--:|:--:|\n| FMP to LCP | X |\n| FCI to TTI | Y |\n| FID to TBT | Z |\n\n위 지표들의 교체 과정을 검토하면, 성능 지표의 선택은 모두 더욱 안정적인 방향으로 나아가고 있음을 알 수 있습니다: 지표의 정의가 더욱 간결하고 명확해지고, 계산 방법 또한 표준화되는 방향으로 발전하고 있습니다.\n\n하지만 우리는 여기에 완벽한 해결책이 없다는 것을 알아야 합니다; 각 지표에는 한계가 있습니다. 많은 상황에서 낮은 점수가 반드시 페이지 경험의 품질이 나쁘다는 것을 의미하지는 않습니다. 성능 점수에 기반하여 페이지를 더 과학적으로 평가하기 위해서는 이러한 지표들 뒤의 원칙을 이해해야 합니다.\n\n\n\n성능 관련 기술의 신속한 변화로 이 문서에 빠뜨린 부분이 있을 경우 언제든지 의사 소통하여 수정해 주시기 바랍니다.\n\n- 새로운 산업 기준에 맞는 모바일 페이지 속도를 찾아보세요.\n- Performance.timing API\n- Lighthouse 6.0의 새로운 기능\n- Web Vitals\n- Lighthouse 점수 산출기\n- Lighthouse 성능 점수\n- WebPageTest 데모\n- 첫 의미 있는 페인트까지의 시간\n- 첫 상호작용 및 일관된 상호작용\n- 가장 큰 콘텐츠 페인트 (LCP)\n- 첫 상호작용 및 일관된 상호작용\n- Mercado Libre가 Web Vitals (TBT/FID)을 최적화한 방법\n- 누적 레이아웃 이동 (CLS)\n- 레이아웃 불안정성\n- 속도 지수\n- 속도 라인\n- 레이아웃 분석기\n- 첫 의미 있는 페인트까지의 시간","ogImage":{"url":"/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_0.png"},"coverImage":"/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_0.png","tag":["Tech"],"readingTime":10},{"title":"자바스크립트 실력 업그레이드 배열 조작 기술 마스터하기","description":"","date":"2024-05-12 23:57","slug":"2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques","content":"\n\nJavaScript에서 배열은 값들의 컬렉션을 저장하고 조작할 수 있게 해주는 기본 데이터 구조입니다.\n\n배열이 유용한 이유 중 하나는 내장된 다양한 메서드를 제공하여 배열 내 요소를 쉽게 추가, 제거, 조작할 수 있다는 점입니다.\n\n![이미지](/assets/img/2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques_0.png)\n\n## Push\n\n\n\n배열에 요소를 추가해야 할 때는 push 메서드를 사용하는 것이 좋습니다. 이 메서드는 배열의 끝에 요소를 추가하며 기존 요소에 영향을 주지 않습니다. 새 배열의 총 개수를 반환합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst totalCount = animals.push(\"bird\");\n\nconsole.log(totalCount) // 5\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\", \"shark\", \"bird\"]\n```\n\n## Pop\n\n배열에서 요소를 제거하는 것은 추가하는 것만큼 간단합니다. 이 작업을 수행하는 한 가지 방법은 pop 메서드를 사용하는 것입니다. pop 메서드는 배열에서 마지막 요소를 제거하고 해당 요소를 반환합니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst element = animals.pop();\n\nconsole.log(element); // shark\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\"]\n```\n\n## 연결하기\n\n만약 여러 값을 추가하고 싶다면 어떻게 해야 할까요? push로는 예상한 대로 작동하지 않을 것입니다. 이럴 때는 concat 메서드를 사용하여 두 개 이상의 배열을 결합할 수 있습니다.\n\n```js\nlet animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nanimals.push([\"bird\", \"eagle\"]);\nconsole.log(animals); // Nope [\"dog\", \"cat\", \"chicken\", \"shark\", [\"bird\", \"eagle\"]]\n\nanimals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst extendedAnimals = animals.concat([\"bird\", \"eagle\"]);\n\nconsole.log(extendedAnimals); // [\"dog\", \"cat\", \"chicken\", \"shark\", \"bird\", \"eagle\"]\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\", \"shark\", \"bird\"]\n```\n\n\n\n## 슬라이스\n\n슬라이스 메소드는 전체 배열의 새로운 사본을 만들거나 배열의 일부를 추출하여 새 배열에 저장하는 데 사용할 수 있습니다.\n\n음수 인덱스를 사용하면 배열 끝에서 요소에 접근해야 할 때 정확한 길이를 모르더라도 편리합니다.\n\n그러나 슬라이스에 의해 생성된 사본은 얕은 복사입니다. 이는 원래 배열이 중첩된 배열이나 객체를 포함하는 경우 사본 내의 해당 중첩된 요소에 대한 수정이 원래 배열에도 반영된다는 것을 의미합니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst last = animals.slice(-1);\nconst lastTwo = animals.slice(-2);\nconst first = animals.slice(0, 1);\nconst catChicken = animals.slice(1, 3);\n\nconsole.log(last); // [\"shark\"]\nconsole.log(lastTwo) // [\"chicken\", \"shark\"]\nconsole.log(first); // [\"dog\"]\nconsole.log(catChicken); // [\"cat\", \"chicken\"]\n\nconst copy = animals.slice();\n\nconsole.log(copy);\n\ncopy.push(\"spider\");\n\nconsole.log(copy); // [\"dog\", \"cat\", \"chicken\", \"shark\", \"spider\"]\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\", \"shark\"]\n```\n\n## Join\n\n가끔 배열을 문자열로 변환해야 할 때가 있습니다. 배열 항목을 출력해야 할 때 유용합니다. 항목 사이에 끼워넣을 구분자를 지정해야 합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\nconsole.log(animals.join(\", \")); // dog, cat, chicken, shark\n```\n\n\n\n## 스플라이스\n\n특정 위치에서 배열에 요소를 추가하거나 제거해야 할 때는 splice 메소드가 유용합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\nconst removed = animals.splice(1, 2);\n\nconsole.log(removed); // [\"cat\", \"chicken\"]\nconsole.log(animals); // [\"dog\", \"shark\"]\n```\n\n## Shift\n\n\n\n배열에서 요소를 제거해야 할 때는 shift 메소드가 편리한 선택지입니다. 또한 제거된 요소를 반환합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst removed = animals.shift();\nconsole.log(removed); // \"dog\"\nconsole.log(animals); // [\"cat\", \"chicken\", \"shark\"]\n```\n\n## Unshift\n\nunshift 메소드를 사용하면 배열의 시작 부분에 하나 이상의 요소를 추가할 수 있습니다. push와 유사합니다. 배열의 새로운 길이를 반환합니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst totalCount = animals.unshift(\"deer\", \"tiger\");\nconsole.log(totalCount); // 6\nconsole.log(animals); // [\"deer\", \"tiger\", \"dog\", \"cat\", \"chicken\", \"shark\"]\n```\n\n## IndexOf\n\nindexOf 메서드를 사용하여 배열에서 항목의 위치를 쉽게 찾을 수 있습니다. 이 메서드는 배열에서 지정된 요소의 첫 번째 발생을 검색하고 해당 인덱스를 반환합니다. 요소를 찾지 못하면 indexOf는 -1을 반환합니다.\n\n추가로, indexOf에 두 번째 인수를 제공하여 배열에서 검색을 시작할 인덱스를 지정할 수 있습니다. 요소의 인덱스를 알게 되면 splice와 같은 메서드를 사용하여 쉽게 해당 요소를 교체하거나 제거할 수 있습니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nlet index = animals.indexOf(\"cat\");\nconsole.log(index); // 1\n\nindex = animals.indexOf(\"cat\", 2);\nconsole.log(index); // -1\n```\n\n## 찾기\n\n특정 조건에 맞는 요소를 찾아야 하는 경우가 있었나요? `find` 메소드는 배열에서 원하는 조건에 맞는 첫 번째 요소를 찾아줍니다.\n\n```js\nconst animals = [\n    {\n        id: 1, type: \"dog\", name: \"Luna\",\n    },\n    {\n        id: 2, type: \"cat\", name: \"Smokey\",\n    },\n];\n\nconst found = animals.find(animal => animal.id === 2);\nconst notFound = animals.find(animal => animal.id === 10);\n\nconsole.log(found); // { id: 2, type: 'cat', name: 'Smokey' }\nconsole.log(notFound); // undefined\n```\n\n\n\n## 포함 여부 확인\n\n배열에서 항목의 존재 여부를 확인해야 하는 경우 includes 메서드가 유용합니다! 이 메서드는 부울 값으로 반환됩니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst hasChicken = animals.includes(\"chicken\");\nconst hasTiger = animals.includes(\"tiger\");\n\nconsole.log(hasChicken); // true\nconsole.log(hasTiger); // false\n```\n\n## ForEach\n\n\n\nforEach는 배열을 반복하는 동안 현재 요소와 함께 인덱스 매개변수를 제공합니다. 이는 콜백 함수를 사용하는 장점으로 전통적인 for 루프와 유사하게 작동합니다.\n\nfor 루프와는 달리 forEach에서 탈출하는 내장 메커니즘이 없습니다. 그러나 콜백 내에서 예외를 throw하거나 조건문을 사용하여 조기 종료를 달성할 수 있습니다. 이러한 경우, 다른 옵션을 찾아보는 것이 좋습니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nanimals.forEach((animal, index) => {\n    console.log(animal, index);\n});\n\n// dog 0\n// cat 1\n// chicken 2\n// shark 3\n```\n\n## Map\n\n\n\n만약 배열의 데이터를 수정하고 수정된 데이터로 새로운 배열을 만들어야 한다면, map 메서드를 사용할 수 있어요. 콜백 함수를 통해 각 요소에 대해 원하는 작업을 수행하고 수정된 값을 반환할 수 있어요.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"salmon\"];\n\nconst indexed = animals.map((animal, index) => {\n    return `${index}.${animal}`;\n});\n\nconsole.log(indexed);\n// [\"1.dog\", \"2.cat\", \"3.chicken\", \"4.salmon\"]\n```\n\n## Filter\n\n커스텀 조건에 따라 배열에서 일부 요소를 제거하고 원하는 요소만 포함하는 새로운 배열을 얻어야 한다면, filter 메서드를 사용할 수 있어요. 이는 원본 배열을 수정하지 않고 새로운 배열을 생성한다는 점에서 map과 다릅니다.\n\n\n\n필터에 제공하는 콜백 함수는 새 배열에 포함될 요소에 대해 true를 반환하고 제외될 요소에 대해 false를 반환해야 합니다.\n\n```js\nconst animals = [\n    {\n        id: 1, type: \"dog\", name: \"Luna\", age: 1\n    },\n    {\n        id: 2, type: \"cat\", name: \"Smokey\", age: 3,\n    },\n    {\n        id: 3, type: \"dog\", name: \"Charlie\", age: 5,\n    },\n    {\n        id: 4, type: \"cat\", name: \"Boo\", age: 1,\n    },\n];\n\nconst adultAnimals = animals.filter(animal => animal.age > 1);\nconsole.log(adultAnimals);\n// [\n//     { id: 2, type: 'cat', name: 'Smokey', age: 3 },\n//     { id: 3, type: 'dog', name: 'Charlie', age: 5 }\n// ]\n```\n\n## Reduce\n\n리듀스 메서드는 맵(map)과 필터(filter)보다 직관적이지 않습니다. 이 메서드는 배열 내 각 요소에서 작동하는 콜백 함수와 누적값(accumulated value)을 고려합니다. 누적값은 이전 반복에서 콜백 함수의 결과이며 현재 반복에서 콜백 함수에 첫 번째 인수로 전달됩니다.\n\n\n\nreduce는 다양한 작업에 사용할 수 있는 다재다능한 함수입니다. 배열의 합을 계산하거나, 다차원 배열을 평평하게 만들거나, 조건에 따라 배열을 변형하는 등의 작업에 사용할 수 있습니다.\n\n```js\nconst ages = [10, 45, 45, 8, 6, 44, 43];\nconst totalCount = ages.reduce((이전값, 현재값) => {\n    return 이전값 + 현재값;\n}, 0);\n\nconsole.log(totalCount); // 201\nconsole.log(Math.round(totalCount / ages.length)); // 29\n```\n\n## ReduceRight\n\n이 함수는 reduce와 거의 비슷하지만, 오른쪽에서 왼쪽으로 요소를 읽어옵니다. 순서가 중요할 때 유용하게 활용할 수 있습니다.\n\n\n\n```js\nconst ages = [10, 45, 45, 8, 6, 44, 43];\nconst totalCount = ages.reduceRight((previous, current) => {\n    console.log(current); // 43, 44, 6 ...\n    return previous + current;\n}, 0);\n\nconsole.log(totalCount); // 201\nconsole.log(Math.round(totalCount / ages.length)); // 29\n```\n\n## Every\n\nevery 메서드는 제공된 콜백 함수에 의해 구현된 테스트를 통과하는 배열의 모든 요소를 검증하는 데 사용됩니다.\n\nevery는 모든 요소가 콜백 함수에서 지정된 조건을 충족하는 경우에만 true를 반환합니다. 콜백 함수에서 요소 중 하나라도 테스트를 통과하지 못하면 (콜백이 false를 반환하면) every는 즉시 반복을 중지하고 false를 반환합니다.```\n\n\n\n```js\nconst ages = [31, 10, 45, 8, 6, 44, 43];\nconst allOver18 = ages.every(age => {\n   console.log(age); // 31, 10\n   return age > 18\n});\nconsole.log(allOver18); // false\n```\n\n## 일부\n\nevery와 반대로 사용하며 하나 이상의 요소가 사용자 정의 조건을 충족하는지 확인하려면 some 메서드를 사용할 수 있습니다.\n\n```js\nconst ages = [10, 45, 45, 8, 6, 44, 43];\nconst isSomeoneChild = ages.some(age => age < 18);\nconsole.log(isSomeoneChild); // true\n```\n\n\n\n## Flat\n\nflat 메서드는 모든 하위 배열 요소가 연결된 새 배열을 생성합니다. 이 프로세스는 재귀적일 수 있으며 지정된 깊이까지 중첩된 하위 배열을 평탄화합니다.\n\n이전에는 reduce 메서드를 사용하여 평탄화를 수행할 수 있었지만, flat은 이 작업에 대해 더 간결하고 내장된 솔루션을 제공합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"salmon\", [\"spider\", \"horse\"]];\nconsole.log(animals.flat()); // [ \"dog\", \"cat\", \"chicken\", \"salmon\", \"spider\", \"horse\" ]\n```\n\n\n\n## FlatMap\n\n이전에 평탄화할 수 있었던 것은 map과 flat을 결합함으로써 이루어졌었습니다. 그러나 flatMap은 더 간결한 방식을 제공합니다.\n\n이 메소드는 사실상 이 두 가지 방법을 하나의 단계로 결합합니다. flatMap은 배열의 각 요소에 콜백 함수를 적용한 다음 결과를 한 단계로 평탄화하여 새 배열을 생성합니다.\n\nfilter + map을 사용한 첫 번째 예제를 살펴보겠습니다.\n\n\n\n```js\nconst owners = [\n  { name: \"Alice\", pets: [{ type: \"cat\", name: \"Luna\" }] },\n  { name: \"Bob\", pets: [{ type: \"dog\", name: \"Charlie\" }, { type: \"cat\", name: \"Whiskers\" }] },\n  { name: \"Charlie\", pets: [] },\n];\n\nconst catNames = owners.flatMap(owner => owner.pets)\n  .filter(pet => pet.type === \"cat\")\n  .map(cat => cat.name);\n\nconsole.log(catNames);\n```\n\n이제 flatMap을 사용하여 다시 작성해 봅시다.\n\n```js\nconst owners = [\n  { name: \"Alice\", pets: [{ type: \"cat\", name: \"Luna\" }] },\n  { name: \"Bob\", pets: [{ type: \"dog\", name: \"Charlie\" }, { type: \"cat\", name: \"Whiskers\" }] },\n  { name: \"Charlie\", pets: [] },\n];\n\nconst catNames = owners\n  .flatMap(owner => owner.pets.flatMap(pet => (pet.type === \"cat\" ? pet.name : [])));\n\nconsole.log(catNames); //  [\"Luna\", \"Whiskers\"]\n```\n\n## ToSpliced\n```\n\n\n\n이 기능은 splice와 유사하게 작동합니다.\n\n그러나 중요한 차이점이 있습니다: splice는 원래 배열을 직접 수정하지만 toSpliced는 제거된 요소를 제외한 새로운 배열을 생성합니다. 게다가 splice는 제거된 요소를 별도의 배열로 반환하는 반면 toSpliced는 변경된 배열 자체에 중점을 둡니다.\n\n```js\nconst animals = [\"개\", \"고양이\", \"닭\", \"상어\"];\n\nconst cleanedArray = animals.toSpliced(1, 2);\n\nconsole.log(removed); // [\"개\", \"상어\"]\nconsole.log(animals); // [\"개\", \"고양이\", \"닭\", \"상어\"]\n```\n\n## 정렬\n\n\n\n배열의 요소를 기본적으로 오름차순으로 정렬합니다. 이 메서드는 정렬된 동일한 배열에 대한 참조를 반환하며, 이제 정렬되었습니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nanimals.sort();\n\nconsole.log(animals); // [\"cat\", \"chicken\", \"dog\", \"shark\"]\n```\n\n## ToSorted\n\n원 배열을 직접 수정하는 sort 메서드와 달리, toSorted는 배열의 새로운 복사본을 만듭니다. 따라서 원래 배열은 그대로 유지됩니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst sortedAnimals = animals.toSorted();\n\nconsole.log(sortedAnimals); // [ \"cat\", \"chicken\", \"dog\", \"shark\" ]\nconsole.log(animals); // [\"cat\", \"chicken\", \"dog\", \"shark\"]\n```\n\n## With\n\n해당 인덱스의 값을 변경합니다. 주어진 값으로 주어진 인덱스를 대체한 새로운 배열을 반환합니다. 일반적으로 대괄호와 인덱스로 이 작업을 수행하지만 기존 배열을 수정합니다.\n\n```js\nlet animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nanimals[0] = \"spider\";\nconsole.log(animals); // [\"spider\", \"cat\", \"chicken\", \"shark\"]\n\nanimals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst newAnimals = animals.with(0, \"spider\");\n\nconsole.log(newAnimals); // [\"spider\", \"cat\", \"chicken\", \"shark\"]\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\", \"shark\"]\n```","ogImage":{"url":"/assets/img/2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques_0.png"},"coverImage":"/assets/img/2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques_0.png","tag":["Tech"],"readingTime":11}],"page":"68","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}