{"pageProps":{"posts":[{"title":"러스트를 사용한 것이 괜찮았나요","description":"","date":"2024-05-12 23:55","slug":"2024-05-12-WasRustWorthIt","content":"\n\n![2024-05-12-WasRustWorthIt_0](/assets/img/2024-05-12-WasRustWorthIt_0.png)\n\n몇 년 전에 나는 모든 것을 내려놓고 WebAssembly에 100% 집중하기로 결심했습니다. 그 당시에 Rust는 WebAssembly로 컴파일하는 데 가장 좋은 지원을 제공했으며, 가장 기능이 풍부한 WebAssembly 런타임은 Rust 기반입니다. Rust가 메뉴에서 최상의 선택이었습니다. 나는 그 호기심이 어디에서 나왔는지 알기 위해 들어갔습니다.\n\n그 이후로 나는(다른 멋진 사람들과 함께) WebAssembly를 핵심 모듈 시스템으로 사용하는 응용 프레임워크 및 런타임인 Wick를 만들었습니다.\n\n![2024-05-12-WasRustWorthIt_1](/assets/img/2024-05-12-WasRustWorthIt_1.png)\n\n\n\n수년의 경력, 다양한 제품 배포, ebook, 그리고 crates.io에 배포된 ~100개의 패키지가 있으니 Rust에 대한 생각을 공유할 시간이 된 것 같아요.\n\n# 좋은 점\n\n## 더 많은 것을 적은 노력으로 유지할 수 있어요\n\n저는 테스트 주도 개발을 강력히 지지해요. 자바, 자바스크립트 같은 언어에서 테스트에 익숙해졌어요. Rust에서도 다른 언어와 마찬가지로 테스트를 작성했지만, 실패할 수 없는 테스트를 작성하게 된 걸 발견했어요. Rust 코드가 컴파일될 수 있는 지점에 도달하면 많은 오류를 고려하여 많은 일반적인 테스트 사례가 관련이 없어집니다. ''unsafe'' 블록이나 .unwrap()과 같은 패닉이 발생할 수 있는 메서드를 피한다면, 기본으로 많은 문제를 우회하는 기반이 생기게 됩니다.\n\n\n\n러스트의 빌림 검사자의 강인함, 러스트의 타입 시스템의 풍부함, 함수형 패턴 및 라이브러리, 그리고 \"null\" 값이 없는 것은 테스트하는 데 들이는 노력이 적은 상태로 더 많은 것을 유지하도록 이끕니다. Wick 프로젝트의 70,000줄 이상의 코드를 다른 언어에서 필요한 것보다 훨씬 적은 테스트로 유지했습니다.\n\n테스트를 작성해야 할 때, 그냥 추가해도 괜찮은 거예요. 러스트의 통합 테스트 하네스를 사용하면 코드 옆에 거의 생각 없이 테스트를 추가할 수 있습니다.\n\n## 이제 다른 언어에서 더 잘 코딩합니다\n\n러스트에서 코딩하는 것은 감정적으로 학대를 당하는 것과 같습니다. 러스트는 하루 종일 당신에게 소리치고, 종종 다른 생활에서는 완전히 정상적으로 여겼을 일에 대해 소리를 질러요. 결국, 그 소리를 듣는 데 익숙해져요. 그것들이 일상이 되어요. 당신은 컴파일러의 화를 부르지 않도록 갈고리를 걷는 법을 배워요. 그리고 실제 생활에서처럼, 그 행동 변화는 영원히 당신과 함께 남아 있습니다.\n\n\n\n정서적 학대는 일반적으로 변화를 격려하는 건 건강한 방법으로 여기지 않지만, 그럼에도 불구하고 변화를 일으킵니다.\n\n다른 언어로 코드를 작성할 때 순서가 맞지 않을 때나 반환 값이 확인되지 않을 때 불편함을 느낍니다. 런타임 오류가 발생하면 이성적으로 화가 나게 됩니다.\n\n![이미지](/assets/img/2024-05-12-WasRustWorthIt_2.png)\n\n## Clippy 정말 좋아요!\n\n\n\n크리피는 러스트의 린터입니다, 하지만 그것을 그냥 린터라고 부르는 것은 조금 과분한 것 같아요. 컴파일러가 당신을 울게 할 수 있는 언어에서, 크리피는 린터보다는 오히려 친절한 친구 같아요.\n\n러스트 표준 라이브러리는 거대해요. 많은 기능이 다양한 작은 유형, 트레이트, 매크로, 함수에 걸쳐 퍼져 있기 때문에 이미 존재할 것으로 알고 있는 함수를 찾기가 어려워요. 많은 크리피 규칙들(예: `manual_is_ascii_check`)은 표준 라이브러리의 메서드나 유형이 더 나은 대체물이 될 수 있는 일반적인 패턴을 찾아냅니다.\n\n크리피는 성능, 가독성 및 불필요한 간접 참조를 다루는 수백 개의 규칙을 가지고 있습니다. 가능한 경우 대체 코드를 자주 제시해 줄 거예요.\n\n또한 (곧) 프로젝트용 전역 린트를 구성할 수 있게 될 것 같아요. 지금까지는 프로젝트의 일관성을 유지하기 위해 해킹 해야만 했어요. Wick에서는 몇 십 개의 크레이트에 대한 인라인 린트 구성을 자동으로 업데이트하는 스크립트를 사용해요. 러스트 커뮤니티가 이를 위한 해결책을 찾아내기까지 몇 년이 걸렸는데, 그 결과가 이런 것이 되었군요...\n\n\n\n# 나쁜 점\n\n## 살아가야 할 공백이 있습니다\n\n제가 위의 Clippy 문제로 다시 돌아올 때마다 제 정신을 의심했어요. 분명히 제가 잘못했을 거예요. 빠뜨린 설정이 있을 테니까요. 그것을 믿을 수 없었어요. 지금도 그런 생각이 들어요. 린트를 전역으로 구성할 수 있는 방법이 있을 텐데요. 이 글을 쓸 때 현실감 있는지 확인하려고 네 번이나 확인했어요. 이제는 그 문제들이 해결되었지만 그동안 몇 년 동안 계속되었었어요.\n\nClippy는 멋지지만 이러한 사용 사례가 러스트 세계 여러 곳에서 자주 발생합니다. 내 사용 사례가 다루지 않는 라이브러리나 도구를 자주 만나게 돼요. 새로운 언어나 프로젝트에서 이것이 일반적이죠. 소프트웨어는 시간(사용)이 걸려 성숙해져야 해요. 하지만 러스트는 그렇게 새로운 게 아니에요. 러스트에는 다른 느낌이 있는 거거든요.\n\n\n\n오픈 소스에서 에지 케이스는 초기 채택자와 새로운 사용자들에 의해 자주 다뤄집니다. 그들이 바로 에지 케이스를 가지고 있는 사람들이죠. 그들의 PR은 프로젝트를 개선하여 다음 사용자들에게 더 좋은 환경을 제공합니다. Rust는 거의 10년 동안 \"가장 사랑받는 언어\"로 선정되었습니다. 새로운 사용자를 유치하는 데는 어려움이 없지만, 이로 인해 혁신적으로 개선된 라이브러리나 도구가 나오지는 않습니다. 대신 특정 사용 사례를 다루는 일회성 포크가 나오는 것이 일반적입니다. 저 또한 그 중 하나인데요, 그것은 PR을 제출하려는 노력 부족 때문은 아닙니다.\n\n왜 그럴까요. 안정적인 API를 유지하는 압력과 Rust의 세밀한 유형 시스템으로 인해 라이브러리 소유자들이 반복적인 작업을 하는 것이 어려울 수 있습니다. 만약 작은 변경 사항이 큰 버전 상향을 야기하는 경우 소수의 변경 사항을 수용하기가 어려울 수 있습니다.\n\n아니면 모든 사람을 위해 모든 일을 처리하는 Rust 코드를 작성하는 것이 극도로 어렵기 때문에 사람들이 그것을 다루고 싶어하지 않을 수도 있습니다.\n\n## Cargo, crates.io 및 프로젝트 구조화 방법\n\n\n\n다른 인기있는 프로젝트를 보고 Wick 저장소 구조를 모델로 만들었어요. 합리적으로 보였고 제대로 작동했어요, 근데 언젠가부터는 문제가 발생했어요.\n\nCargo를 이용하면 모듈 크기의 상자를 쉽게 만들고 테스트할 수 있어요. 하지만 crates.io로 배포하는 건 전혀 다른 이야기네요.\n\ncrates.io로 패키지를 게시하려면 각각의 참조된 크레이트가 개별로 게시되어 있어야 해요. 그게 납득이 가는 부분이죠. 저차원의 파일시스템에만 존재하는 패키지에 의존하고 싶지 않잖아요.\n\n하지만 많은 개발자들이 큰 프로젝트를 자연스럽게 작은 모듈로 분할하는데, 자기 자신 안에만 존재하는 하위 크레이트를 가진 상위 크레이트를 게시할 수 없어요. 심지어 로컬 개발 의존성을 가진 크레이트도 게시할 수 없답니다. 이 문제를 피하려면 무작위 유틸리티 크레이트를 게시할지, 프로젝트를 다시 구조화할지 선택해야 해요. 이 제약은 임의적이고 불필요하다는 느낌이 들어요. 이렇게 구조화된 프로젝트를 만들 수는 있지만, 게시할 수는 없다는 게 함정이죠.\n\n\n\n카고는 역시 우수한 작업 공간 지원이 있어요! 카고의 작업 공간은 대부분의 언어보다 큰 프로젝트를 더 잘 관리할 수 있는 경험을 제공해줘요. 하지만 배포 문제를 해결해 주지는 않아요. 사실, 작업 공간을 설정하는 방법은 수십 가지중 어느 것도 배포를 쉽게 해결해 주지 않아요.\n\n이 문제는 실용적인 유틸리티 크레이트 수가 많아서 발생합니다. 각각은 일부 구성과 함께 작동하며, 아직까지 작업 공간을 설정하는 \"진정한 방법\"은 제가 아직 찾지 못했어요. Wick를 게시할 때, 수동적이고 반복적인 작업을 부분적으로만 작동하는 도구와 결합하는 노력이 자주 1시간 이상 걸려요.\n\n## Async\n\nRust는 시작 이후에 비동기성을 언어에 추가했어요. 이것은 나중에 생각한 것처럼 느껴지고, 그렇게 작동하며, 종종 이해하고 해결하기 어려운 오류로 인해 방해를 받을 수 있어요. 해결책을 찾을 때는 다양한 런타임 및 이들의 비동기 스타일을 기반으로 필터링해야 해요. 비동기 라이브러리를 사용하고 싶으세요? 특정 비동기 런타임 외에서 사용할 수 없는 가능성이 있어요.\n\n\n\n두 10년 이상의 JavaScript 경험에 Go 언어로 우수한 경험이 있는 만큼, Rust에서 가장 큰 단점이자 괴로움의 원천은 비동기 처리와 관련된 부분일 것입니다. 극복할 수 있는 문제이지만, 비동기 처리 기능이 필요할 때 항상 준비돼 있어야 합니다. 다른 언어들에서는 비동기 처리가 거의 눈에 띄지 않는데, Rust에서는 그렇지 않습니다.\n\n# 까다로운 부분\n\n## 리팩터링은 지루할 수 있습니다\n\nRust의 풍부한 유형 시스템은 축복이자 저주입니다. Rust 유형으로 생각하는 것은 꿈같은 경험이 될 수 있습니다. 그러나 Rust의 유형 관리는 악몽이 될 수 있습니다. 데이터와 함수 시그니처에는 일반 유형, 일반 수명 및 특성 제약사항이 포함될 수 있습니다. 이러한 제약 조건에는 고유의 일반 유형 및 수명이 포함될 수 있습니다. 때로는 실제 코드보다 유형 제약이 더 많을 수도 있습니다.\n\n\n\n\n![이미지](/assets/img/2024-05-12-WasRustWorthIt_3.png)\n\n첫 번째로 작성할 때 일일히 제네릭을 모두 정의해야 합니다. 처음에 쓸 때는 지루하지만 리팩토링할 때는 작은 변경도 연쇄적인 문제로 이어질 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-WasRustWorthIt_4.png)\n\n하나의 작업을 진행하기 전에 14개의 다른 정의를 조정해야 한다면 빠른 진전을 이루기 어려울 것입니다.\n\n\n\n이해해 줘서 고마워요! 의견에 대해 수정한 내용을 적용했습니다.\n\n# 결론\n\n러스트를 좋아해요. 무엇이든 할 수 있고 다재다능한 모습을 사랑합니다. CLI 앱, 웹 서버 및 웹 클라이언트를 동일한 언어로 작성할 수 있습니다. 웹어셈블리를 사용하면 브라우저에서도 LLM을 실행할 때와 동일한 이진 파일을 사용할 수 있습니다. 이것이 여전히 제 머릿속을 뒤흔들어요.\n\n러스트 프로그램이 얼마나 견고한지 사랑합니다. 러스트가 보호해주는 것들을 깨달은 후에는 다른 언어로 돌아가기 힘들어요. 잠시 동안 Go로 돌아갔다가 빠른 개발 속도에 다시 빠지게 되었어요. 그리고 런타임 패닉이 발생하고 유리가 깨지더라구요.\n\n\n\n하지만 러스트에는 문제점이 있어요. 채용이 어렵고 배우는 데 시간이 오래 걸리며 빠르게 반복할 수 없을 정도로 엄격해요. 특히 async 코드를 다룰 때 메모리 및 성능 문제를 해결하는 게 어렵죠. 모든 라이브러리가 안전한 코드에 대해 동일하게 좋지는 않고, 개발 도구도 많이 부족해요. 시작할 때 어려움이 많고 다른 것들도 많이 방해하겠지만, 그 장애물을 극복하면 모두를 앞지를 수 있을 거예요. 하지만 이건 커다란 가정이에요.\n\n우리에게 러스트는 가치가 있었을까요? 아직 일러본도 못했어요. 작은 팀으로 놀라운 일을 해냈지만 방해요소도 많았죠. 러스트를 더 적합하게 만든 기술적 이유도 있었어요.\n\n당신에게는 가치가 있을까요? 빠르게 반복해야 한다면 아마 그렇지 않을 거예요. 알려진 범위가 있거나 초기 비용을 조금 더 감당할 수 있다면? 분명히 고려해보세요. 견고한 소프트웨어를 만들 수 있을 거예요. 매월 더 강해지는 WebAssembly 각도로 봤을 때, 한 번 완벽한 소프트웨어를 작성하고 어디서든 재사용하는 전망이 더 빨리 현실이 될 것 같아요.","ogImage":{"url":"/assets/img/2024-05-12-WasRustWorthIt_0.png"},"coverImage":"/assets/img/2024-05-12-WasRustWorthIt_0.png","tag":["Tech"],"readingTime":6},{"title":"힙 메모리 프로파일링이 나에게 메모리 누수에 대해 가르쳐준 것","description":"","date":"2024-05-12 23:53","slug":"2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks","content":"\n\n![메모리 누수에 대한 Heap 메모리 프로파일링이 가르쳐 준 것](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_0.png)\n\n웹 개발자로서, 보통은 JavaScript(사실 TypeScript)로 코딩을 즐겨하며, 애플리케이션이 브라우저에서 실행될 때 관리되는 메모리 관리와 가비지 수집의 복잡성에 무감각하게 살아갑니다. 메모리 관리? 응, 그건 브라우저가 걱정해야 하는 문제야!\n\n가끔은 사소한 코드 변경으로 우리의 한 때는 원활하게 작동하던 애플리케이션이 녹슬은 보트처럼 갑자기 물고기처럼 움직이기 시작합니다. 느린 반응, 응달한 인터페이스, 그리고 두려운 충돌이 제 친절치 않은 동반자가 되곤 했습니다. 그래서 가끔씩, 나는 브라우저 JavaScript 메모리 개발 도구 패널의 신비한 동굴 속에서 자신을 발견하곤 합니다.\n\n개발 도구 메모리 탭의 깊은 곳으로 다시 돌아가려면 언제나 어려운 작업이 필요합니다. 거의 갈 일이 없는 이곳을 방문하려면 상기시키기가 언제나 필요하죠. 리프레셔를 통과한 후, 내 시간을 거기서 즐기기 시작했습니다. 거기에는 애플리케이션의 효율성 또는 종종 비효율성, 그리고 숨겨진 메모리 누수에 대한 통찰과 비밀이 가득한 지식의 보물창고가 있습니다.\n\n\n\n잠시만요, 브라우저 메모리 패널을 빠르게 살펴보며 만들어지는 골드를 발굴해 보겠습니다. Chrome DevTools에서 자바스크립트 힙과 메모리 할당의 신비를 풀기 위해 함께 여행을 떠날 준비가 되셨나요?\n\n# 힙이란?\n\n자바스크립트 힙은 웹 브라우저 내부의 특정 메모리 공간을 가리키며, 자바스크립트 코드에서 사용하는 데이터를 저장하는 데 전용되어 있습니다. 이는 웹 애플리케이션 실행에 특별히 예약된 대규모 메모리 풀로 이해하시면 됩니다.\n\n- 런타임 중에 자바스크립트 코드에 의해 할당된 동적 데이터를 저장합니다. 이에는 객체, 배열, 함수 및 스크립트에서 생성된 다른 데이터 구조가 포함됩니다.\n- 스택에 있는 변수(숫자나 문자열과 같은 고정 크기 데이터에 사용)와는 달리, 힙은 코드의 필요에 따라 유연하게 메모리를 할당할 수 있습니다.\n- 자바스크립트 엔진은 힙을 자동으로 관리하여 새로운 객체에 대해 메모리를 할당하고 사용되지 않는 것들에 대해서는 가비지 수집(garbage collection)이라는 과정을 통해 메모리를 회수합니다.\n\n\n\n우리는 다행히도 코드에서 직접 메모리 할당 또는 해제를 관리하지 않습니다. 하지만 힙이 작동하는 방식을 이해하면 더 효율적이고 성능이 우수한 JavaScript 코드를 작성하는 데 도움이 될 수 있어요.\n\n## 우리는 공간을 세 가지 부분으로 나눌 수 있어요\n\n- 살아 있는 객체: 현재 코드에서 사용 중인 객체로 힙 공간을 차지하고 있어요.\n- 죽은 객체: 코드에서 더는 필요하지 않지만 쓰레기 수집에 의해 회수되지 않은 객체들이에요.\n- 빈 공간: 새로운 객체를 할당하기 위해 사용 가능한 사용되지 않은 메모리공간이에요.\n\n## 이 정보를 활용해서 무엇을 할 수 있을까요?\n\n\n\n- 힙(heap)이 어떻게 작동하는지 이해하면 효율적인 메모리 관리가 가능해지며, 이는 성능과 안정성에 직접적으로 영향을 미칩니다.\n- 더 이상 필요하지 않은 객체가 의도하지 않게 보관되는 메모리 누수는 메모리 고갈, 느려짐 및 최종적으로 충돌로 이어질 수 있습니다. (오늘 이 글을 쓰게 된 동기입니다)\n\n자바스크립트 힙은 웹 애플리케이션의 메모리를 관리하는 데 중요한 역할을 합니다. 용도, 관리 전략 및 구성 요소를 이해함으로써, 보다 숙련되고 책임감 있는 개발자가 되어 효율적이고 성능이 우수한 코드를 작성하여 부드러운 사용자 경험을 제공할 수 있습니다.\n\n# 메모리 사용 분석을 위한 메모리 탭 활용 방법\n\n힙 스냅샷\n\n\n\n- 특정 시점에 전체 JavaScript 힙에 대한 스냅샷을 촬영할 수 있게 해줘요. 메모리 사용량을 캡처하는 것과 같아요. 살아있는 모든 객체와 그들의 관계를 포함하고 있어요.\n- 다른 애플리케이션 상태 간의 스냅샷을 비교하여 메모리 누수를 식별할 수 있어요.\n- 다른 객체 유형이 사용하는 메모리의 전반적인 분포를 분석할 수 있어요.\n- 불필요한 데이터를 유지하고 있는 이유를 이해하기 위해 개별 객체와 속성을 검사할 수 있어요.\n\n![이미지 파일](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_1.png )\n\n![이미지 파일](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_2.png)\n\n상호작용해보세요! 애플리케이션의 작업 흐름의 다른 단계에서 스냅샷을 찍어 메모리 사용량을 비교하고 잠재적인 누출을 식별하세요. \"스냅샷 찍기\" 버튼을 내일이 없는 것처럼 클릭해보세요!\n\n\n\n## 타임라인에 할당 계측\n\n이 옵션은 웹 애플리케이션에서 메모리 사용량을 분석하는 강력한 방법을 제공합니다. 힙 스냅숏(Heap Snapshots)과 할당 샘플링(Allocation Sampling)의 측면을 결합하여 애플리케이션 실행에 따른 메모리 할당 및 해제 이벤트를 자세히 보여줍니다.\n\n- 일정 간격으로 JavaScript 힙의 스냅숏과 해당 스냏텟들 사이에 할당 및 해제된 모든 객체에 대한 정보를 기록합니다.\n- 객체 생성(메모리 할당 이벤트) 및 객체 해제(메모리 해제 이벤트)를 나타내는 표식이 있는 시각적 타임라인을 생성합니다.\n\n![이미지](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_3.png)\n\n\n\n- 특정 사용자 상호 작용이나 코드 실행 중에 메모리 사용량이 어떻게 변화하는지 확인해 보세요.\n- 할당된 메모리를 정리하는 쓰레기 수집 주기의 효과를 분석하세요.\n\n![image](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_4.png)\n\n- 시간이 지남에 따라 메모리가 어떻게 변하는지 명확하게 시각적으로 표현하여 잠재적인 문제를 식별하기가 더 쉬워집니다.\n\n전반적으로 할당 기기 프로필 형식은 응용 프로그램의 메모리 사용량에 대한 깊은 통찰력을 얻을 수 있는 소중한 도구이며, 잠재적인 메모리 누수를 식별하는 데 도움이 됩니다. 메모리 변화를 이해하는 데 중요한 복잡한 응용 프로그램이나 상황에 특히 유용합니다.\n\n\n\n## 할당 샘플링\n\n프로필은 애플리케이션 실행 중 특정 기간 동안 새로 할당된 JavaScript 객체에 대한 정보를 기록합니다. 다른 프로필 유형과 달리 전체 힙의 스냅샷을 캡처하지는 않지만 대신 시간 경과에 따른 메모리 할당 패턴을 추적하는 데 초점을 맞춥니다.\n\n- 메모리 핫스팟 식별: 가장 많은 메모리 할당을 담당하는 애플리케이션 내 함수 또는 코드 블록을 파악하는 데 도움이 됩니다. 이를 통해 코드의 어느 부분이 전체 메모리 사용량에 가장 크게 기여하는지 이해할 수 있습니다.\n- 시간별 메모리 변화 분석: 기간 동안 데이터를 수집하여 특정 사용자 상호작용이나 코드 실행 중 메모리 사용량이 어떻게 변하는지 볼 수 있습니다. 이를 통해 할당 증가와 관련된 메모리 누수나 병목 현상을 식별할 수 있습니다.\n- 빈번한 가비지 컬렉션 진단: 애플리케이션이 빈번한 가비지 컬렉션 주기를 겪는 경우, 할당 샘플링을 통해 가장 수명이 짧은 객체를 생성하는 코드 섹션이 어디인지 이해할 수 있습니다. 이를 통해 불필요한 할당을 줄이고 가비지 컬렉션 효율성을 향상시킬 수 있습니다.\n\n<img src=\"/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_5.png\" />\n\n\n\n<img src=\"/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_6.png\" />\n\n## 할당 샘플링 프로필에 대한 추가 참고 사항\n\n- 전체 힙을 표시하지 않습니다: \"힙 스냅샷\"과 달리 특정 시점에 전체 JavaScript 힙을 캡처하지 않습니다. 이는 누수 가능성이 있는 객체를 직접 식별할 수 없지만 어느 영역이 많이 할당되는지만 볼 수 있음을 의미합니다.\n- 자원을 많이 소비할 수 있습니다: 많은 양의 할당된 객체를 샘플링하는 것은 응용 프로그램 실행에 약간의 부하를 추가합니다. 성능에 영향을 미치지 않도록 짧은 기간 동안 신중하게 사용하십시오.\n\n할당 샘플링 프로필은 JavaScript 애플리케이션에서 메모리 할당 패턴을 프로파일링하는 데 유용한 도구입니다. 높은 메모리 사용을 가진 코드 영역을 식별하고, 시간 경과에 따른 메모리 변화를 이해하며, 빈번한 가비지 수집과 관련된 잠재적인 성능 문제를 진단하는 데 도움이 됩니다.\n\n\n\n우리 Memory Tab 프로필 중 \"Heap Snapshots\" 또는 \"Allocation instrumentation on timeline\"과 같은 다른 프로필을 대체하려는 것이 아닙니다. 서로 다른 통찰력을 제공하는 다른 도구를 선택하세요. 특정한 요구사항과 메모리 분석 목표에 따라 올바른 도구를 선택해야 합니다.\n\n힙과 메모리 프로파일링을 탐구한 결과, JavaScript 응용 프로그램 내의 메모리 관리 세계를 탐구하기 흥미롭고 비교적 편안한 곳이라는 것을 발견했습니다.\n\n메모리 누수는 때때로 발생하는 것조차 모르기 어려울 뿐 아니라 어플리케이션이 수십만 줄 또는 수백만 줄의 코드로 이루어진 상황에서 어디서 발생했는지 정확히 파악하는 것이 어렵습니다. 실수로 유지된 객체에 대한 의도하지 않은 참조로 인한 메모리 누수는 메모리 고갈, 성능 저하 및 최종적으로 어플리케이션 충돌과 같은 여러 문제를 야기할 수 있습니다. 이는 JavaScript 힙 안에서 메모리가 어떻게 할당되고 사용되며 회수되는지를 이해하는 것이 상당히 중요하다는 것을 강조합니다.\n\n이러한 지식을 바탕으로 메모리 누수를 효과적으로 식별하고 해결하는 방법 뿐만 아니라 더 효율적이고 성능이 우수한 코드를 설계하는 방법도 익혔습니다. 브라우저의 JavaScript 힙을 탐험하는 여정은 계몽적이고 능력을 부여하는 경험이 되었습니다.\n\n\n\n```\n만약 이 콘텐츠를 즐겼고 이러한 노력을 지원하고 싶다면 여기를 방문해주세요: https://ko-fi.com/jacobmacinnis.\n\n# 쉽고 날 것의 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 박수를 보내고 작가를 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io 에서 더 많은 콘텐츠 확인하기\n```","ogImage":{"url":"/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_0.png"},"coverImage":"/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_0.png","tag":["Tech"],"readingTime":6},{"title":"JavaScript로 Command-Line Tool 만드는 방법","description":"","date":"2024-05-12 23:52","slug":"2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge","content":"\n<img src=\"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png\" />\n\n# 소개:\n\n이 가이드에 오신 것을 환영합니다! JavaScript를 사용하여 명령줄 도구를 구축하는 코딩 챌린지에 도전하게 됩니다. 우리의 목표는 텍스트 파일을 분석하고 줄 수, 단어 수, 문자 수 등 다양한 메트릭을 제공할 수 있는 다재다능한 도구를 만드는 것입니다.\n\n여기에서 다룰 도전 과제를 찾을 수 있습니다. 이 작업에는 JavaScript (JS)을 사용하겠습니다. 이제 구현 세부 정보로 바로 들어가 봅시다.\n\n# 환경 설정하기\n\n명령줄 도구를 만들 때 가장 먼저 해야 할 일 중 하나는 코드를 작성할 위치를 결정하는 것입니다. 통합 개발 환경(IDE)에서의 전통적인 개발과는 달리, 스크립팅은 약간 다른 절차를 따릅니다.\n\n먼저, 컴퓨터에 Node.js가 설치되어 있는지 확인하세요. 그런 다음 다음 단계를 따르세요:\n\n- 프로젝트의 루트 디렉토리로 이동합니다.\n- mkdir bin 명령을 사용하여 'bin'이라는 새 폴더를 만듭니다.\n- 'bin' 폴더 내부에 새 파일을 만듭니다. touch `파일이름`을 사용할 수 있습니다.\n- 텍스트 편집기로 파일을 열기 위해 nano `파일이름`을 사용합니다.\n- 파일의 맨 위에 다음 해시뱅( shebang) 라인을 추가합니다: #!/usr/local/bin/node. 이 라인은 컴파일러에게 코드를 Node.js를 사용해 해석하도록 지시합니다.\n- Ctrl + O를 눌러 변경 사항을 저장한 후 Enter를 누르고 Ctrl + X를 눌러 편집기를 종료합니다.\n- chmod +x `파일이름`을 사용하여 스크립트에 실행 권한을 부여합니다.\n- bin 폴더 내부에 export PATH=\"$HOME/bin:$PATH\"를 입력합니다.\n- 이제이 스크립트를 실행할 때마다 Node.js 스크립트로 해석됩니다.\n\n# 챌린지 해결하기\n\n## 단계 1: 파일의 바이트 수 세기\n\n우리의 첫 번째 작업은 파일의 바이트 수를 계산하고 터미널에서 제공된 인수가 ‘-c’인지 감지하는 함수를 만드는 것입니다. 다음은 이를 어떻게 달성할 수 있는지입니다:\n\n```js\nconst fs = require(\"fs\");\nfunction readFileContent(fileName) {\n  if (!fs.existsSync(fileName)) {\n    console.log(`파일을 찾을 수 없습니다: ${fileName}`);\n    process.exit(1);\n  }\n\n  fs.readFile(fileName, \"utf8\", (err, data) => {\n    if (err) throw err;\n    const fileSizeInBytes = Buffer.byteLength(data, \"utf8\");\n    displayResult(fileSizeInBytes);\n  });\n}\nfunction displayResult(fileSizeInBytes) {\n  if (commandLineOption === \"-c\") {\n    console.log(`${fileSizeInBytes} ${fileName}`);\n  }\n}\nlet fileName = process.argv[2];\nconst commandLineOption = process.argv[3];\nreadFileContent(fileName);\n```\n\n이 코드 스니펫에서는 fs.readFile 메서드를 사용하여 파일 내용을 읽고 Buffer.byteLength를 사용하여 파일 크기를 바이트 단위로 계산합니다. 그런 다음 명령줄 옵션이 ‘-c’와 일치하는 경우 결과를 표시합니다.\n\n## 단계 2: 줄, 단어 및 문자수 계산하기\n\n다음으로, 파일의 줄 수, 단어 수 및 문자 수를 계산하는 도구를 확장합니다. readFileContent 함수를 재사용하여 ‘-l’, ‘-w’ 및 ‘-m’과 같은 추가 옵션을 지원하도록 향상시킬 수 있습니다.\n\n```js\nfunction readFileContent(fileName) {\n  // 이전과 동일\n  fs.readFile(fileName, \"utf8\", (err, data) => {\n    if (err) throw err;\n    const { charactersCount, wordsCount, numberOfLines } = parseFile(data);\n    displayResult(charactersCount, wordsCount, numberOfLines);\n  });\n}\nfunction parseFile(data) {\n  const charactersCount = data.length;\n  const wordsCount = data.split(\" \").length;\n  const numberOfLines = data.split(\"\\n\").length;\n  return { charactersCount, wordsCount, numberOfLines };\n}\nfunction displayResult(charactersCount, wordsCount, numberOfLines) {\n  // 이전과 동일하며 '-l', '-w', '-m'에 대한 추가 조건이 있습니다.\n}\nlet fileName = process.argv[2];\nconst commandLineOption = process.argv[3];\nreadFileContent(fileName);\n```\n\n이 수정된 코드에서는 파일 내용을 구문 분석하여 줄 수, 단어 수 및 문자 수를 계산합니다. 그런 다음 제공된 명령줄 옵션에 따라 해당 카운트를 표시합니다.\n\n## 단계 3: 표준 입력 처리\n\n파일 이름이 지정되지 않은 경우 표준 입력에서 읽기를 지원하기 위해 코드를 수정하여 다른 명령에서 입력이 파이프될 때 (예: cat test.txt | ccwc -l) 입력이 감지되는지 확인해야 합니다. 다음과 같이 이를 달성할 수 있습니다:\n\n```js\nif (!process.stdin.isTTY) {\n  let data = \"\";\n  process.stdin.setEncoding(\"utf8\");\n  process.stdin.on(\"data\", (chunk) => {\n    data += chunk;\n  });\n  process.stdin.on(\"end\", () => {\n    const { charactersCount, wordsCount, numberOfLines } = parseFile(data);\n    displayResult(charactersCount, wordsCount, numberOfLines);\n  });\n} else {\n  // 이전과 동일하지만 약간 수정된 부분이 있음\n}\n```\n\n표준 입력이 제공되는지 확인함으로써 (!process.stdin.isTTY), 우리는 적절하게 파이프로 연결된 입력을 처리할 수 있습니다.\n\n## 결론\n\n이 안내서에서는 코딩 도전 과제를 해결하기 위해 JavaScript로 명령줄 도구를 만드는 과정을 안내했습니다. 환경 설정, 파일에서 바이트, 라인, 단어 및 문자 수를 세는 기능 구현, 그리고 표준 입력 처리까지 다루었습니다.\n\n이 튜토리얼을 따라와 주셔서 CLI 도구 구축, Node.js 파일 처리, 그리고 동적으로 명령줄 인수를 처리하는 방법에 대한 통찰력을 얻었습니다.\n\nGitHub에서 완전한 코드 솔루션과 테스트 파일을 살펴보세요.\n\n이 안내서가 도움이 되었기를 바랍니다. 궁금한 사항이나 제안 사항이 있으면 아래에 댓글을 남겨주세요. 더 많은 튜토리얼을 기대해주세요!\n\n다음 포스트에서 뵙겠습니다!\n","ogImage":{"url":"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png","tag":["Tech"],"readingTime":4},{"title":"자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시","description":"","date":"2024-05-12 23:51","slug":"2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases","content":"\n\n\n![Image](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png)\n\nIt's one of those cool things you can do in JavaScript that's immensely powerful in the real world.\n\n# Powerful practical use cases\n\n## Action (A) waiting for another (B)\n\n\n\nA는 진행 중입니다만 사용자는 B를 하고 싶지만 A가 먼저 발생해야 합니다.\n\n예시: 사용자가 게시물을 생성, 저장 및 게시할 수 있는 소셜 앱. 마치 Medium처럼.\n\n![이미지1](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_1.png)\n\n![이미지2](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_2.png)\n\n\n\n만약 사용자가 저장 중에 게시물을 발행하길 원한다면 어떻게 할까요?\n\n해결책: 발행되기 전에 게시물이 저장되도록 확인하세요.\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_3.png)\n\n![이미지](https://miro.medium.com/v2/resize:fit:588/0*u7Littlul1VVDuUU.gif)\n\n\n\n이 논리를 Deffered 클래스로 추상화하면 더욱 좋아집니다:\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_4.png)\n\n리팩토링✅:\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_5.png)\n\n\n\n그리고 이전과 정확히 같이 작동합니다:\n\n![image](https://miro.medium.com/v2/resize:fit:588/0*dv5w4HYCmh1giS5w.gif)\n\nDeferred는 훨씬 깔끔합니다. 그래서 우리는 ts-deferred, deferred, promise-deferred와 같은 수많은 NPM 라이브러리를 가지고 있습니다.\n\n![image](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_6.png)\n\n\n\n## 이벤트 스트림 Promisifying하기\n\n이건 내가 여러 번 사용해 본 멋진 설정이야.\n\n실제로 이벤트 스트림이 발생할 때 대기하는 비동기 작업을 수행하는 것입니다. 내부적으로:\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_7.png)\n\n\n\n# 마무리\n\n외부에서 약속을 이행하는 것은 강력한 패턴을 발휘합니다.\n\n사용자 조치부터 이벤트 스트림까지 깔끔하고 유연한 코드를 유지합니다. 그리고 ts-deferred와 같은 라이브러리를 사용하면 더 나은 처리가 가능합니다.\n\n# 자바스크립트가 하는 모든 미친 일\n\n\n\n알고 있던 것이 모두라 생각했을 때 새로운 것을 알려드릴게요.\n자바스크립트의 세심한 주의사항과 잘 알려지지 않은 부분들을 담은 Every Crazy Thing JavaScript Does 가이드로 고통스러운 버그를 피하고 소중한 시간을 절약하세요.\n\n오늘 여기서 무료로 받아보세요.\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_8.png)","ogImage":{"url":"/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png"},"coverImage":"/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png","tag":["Tech"],"readingTime":2},{"title":"브라우저 아키텍처의 과거와 현재","description":"","date":"2024-05-12 23:47","slug":"2024-05-12-ThePastandPresentofBrowserArchitecture","content":"\n\n\n<img src=\"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png\" />\n\n브라우저 아키텍처는 단일 프로세스 브라우저에서 멀티 프로세스 브라우저로의 전환을 거쳤습니다. 안정성, 부드러움, 보안을 강조하며, 프로세스는 렌더링, GPU, 네트워크 및 플러그인으로 분해되어 아키텍처의 청결성이 향상되었습니다. 브라우저 아키텍처를 검토하려면 페이지를 열고, 페이지 렌더링 프로세스, 브라우저 플러그인 메커니즘을 더 잘 이해해야 합니다. 특히 Manifest V1에서 Manifest V3로의 전환을 중심으로 Chrome 확장 프로그램 버전 타임라인을 정리함으로써 브라우저의 진화 과정을 비교적 포괄적으로 이해할 수 있습니다.\n\n# 1. 브라우저 아키텍처의 진화\n\n2007년 이전에 전형적인 브라우저 아키텍쳐는 이러했습니다:\n\n\n\n![브라우저 아키텍처의 과거와 현재](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_1.png)\n\n단일 프로세스 브라우저 아키텍처는 전체 웹 브라우저를 단일 운영 체제 프로세스에서 실행하여 네트워크 처리, 플러그인, JavaScript 런타임, 렌더링 엔진, 페이지 관리 및 사용자 인터페이스 요소 등의 작업을 하나의 실행 공간으로 통합합니다. 자원 관리를 단순화하는 반면, 이 아키텍처 디자인은 다음과 같은 주요 문제점이 있습니다:\n\n- 불안정함 — 플러그인 및 렌더링 엔진은 웹 비디오 및 게임과 같은 기능을 처리하는 동일한 프로세스에서 실행됩니다. 플러그인이나 렌더링 엔진의 충돌로 인해 전체 브라우저가 다운될 수 있으며, 특히 복잡한 JavaScript 코드를 처리할 때 이러한 불안정성이 두드러집니다.\n- 부드러움 부족 — 모든 모듈(페이지 렌더링, JavaScript 실행, 플러그인 포함)이 하나의 스레드를 공유합니다. 스크립트가 매우 시간이 많이 걸리면 전체 스레드를 독점하여 다른 페이지가 응답하지 않게 만들고 전체 브라우저에서 지연이 발생할 수 있습니다.\n- 보안성 부족 — 페이지에서 실행되는 플러그인은 운영 체제 자원에 액세스할 수 있습니다. 악성 플러그인은 이런 액세스를 악용하여 보안을 침해하거나 사용자 자격 증명과 같은 민감한 정보를 탈취할 수 있습니다.\n\n단일 프로세스 브라우저의 장점은 브라우저 구성 요소가 하나의 프로세스 내에서 작동하여 자원 관리와 조정을 간단하게 만든다는 것입니다. 단일 프로세스 브라우저는 보통 낮은 메모리 사용률을 나타내어 자원 효율성 향상에 도움을 줍니다. 작업은 통합된 프로세스 내에서 순차적으로 실행됩니다.\n\n\n\n2008년에 출시된 Chrome 프로세스 아키텍처는 다음 다이어그램을 통해 볼 수 있듯이 멀티 프로세스 브라우저의 한 예입니다:\n\n![다이어그램](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_2.png)\n\n이른 시기에 사용된 브라우저 아키텍처는 기능을 브라우저, 플러그인, 렌더링의 세 가지 주요 프로세스로 나눴습니다. 각 페이지와 해당 플러그인은 전용 렌더링 및 플러그인 프로세스에서 독립적으로 실행되며, IPC를 통해 통신합니다.\n\n프로세스간 통신(IPC)은 프로세스가 컴퓨터에서 통신하고 작업을 동기화하는 메커니즘입니다. 이를 통해 다른 프로그램 간에 효율적인 데이터 교환과 조정이 가능해집니다. 주요 IPC 메커니즘에는 공유 메모리가 포함되어 있어 프로세스 간의 세마포어를 사용하여 공유된 공용 메모리 영역에 대한 액세스를 동기화합니다. Named 및 unnamed 파이프는 단방향 통신을 제공하며, Linux에서의 IPC는 일반적으로 세마포어를 사용하여 파일이나 공유 메모리 저장소를 공유합니다. 메시지 큐는 비동기 통신을 지원하여 송신자 및 수신자 프로세스를 분리하는 데 도움을 줍니다. 또한, 프로세스는 이벤트나 요청을 통지하기 위해 시그널을 통해 통신할 수 있습니다. 소켓은 네트워크 프로토콜을 사용하여 서로 다른 기계 간에 IPC를 확장합니다.\n\n\n\n멀티 프로세스 브라우저는 안정성을 향상시킵니다. 격리된 프로세스 덕분에 충돌이 전체 브라우저에 영향을 미치지 않습니다. 페이지나 플러그인의 충돌은 해당 프로세스에만 영향을 미치며, 다른 페이지와 브라우저 전체의 안정성을 보장합니다. JavaScript를 별도의 렌더링 프로세스에서 실행하는 것도 영향을 격리시킵니다. 만약 스크립트가 렌더링 프로세스를 차단한다면, 현재 페이지에만 영향을 미치고 다른 페이지에는 영향을 미치지 않습니다. 각 페이지가 별도의 렌더링 프로세스에서 스크립트를 실행하기 때문에 브라우저 전체가 영향을 받지 않습니다. 더불어 Chrome은 플러그인과 렌더링 프로세스를 샌드박스 환경에 배치하여 데이터에 대한 읽기/쓰기 액세스를 제한합니다. 악성 소프트웨어가 이러한 프로세스 내에서 실행되더라도 시스템 권한을 획들할 수 없습니다. 이것이 구획화된 아키텍처 패턴의 한 예입니다.  \n\n샌드박스는 전체 시스템의 작동에 영향을 미치지 않고 프로그램을 실행하거나 파일을 열 수 있는 테스트 환경입니다. 사이버 보안 분야에서 산드박스는 잠재적으로 해로운 코드 실행을 분석하여 위협을 탐지하고 완화하는 용도로 사용됩니다. \n\n최신 버전의 Chrome 브라우저에는 아래와 같은 주요 구성 요소가 있습니다:\n\n![Chrome Browser Components](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_3.png)\n\n\n\n브라우저 프로세스는 디스플레이 인터페이스, 사용자 상호작용 및 서브프로세스 조정을 관리하며, 저장 기능을 제공합니다. 이는 다른 프로세스를 조정하는 \"스케줄러\"로 작용하여, 예를 들어 URL을 입력할 때 네트워크 프로세스를 호출합니다. 렌더링 프로세스는 HTML, CSS 및 JavaScript를 대화형 웹 페이지로 변환하고 V8 엔진을 실행합니다. 보안상의 이유로 Chrome은 각 탭에 대해 별도의 렌더링 프로세스를 샌드박스 모드로 생성합니다.\n\nGPU 프로세스는 초기에 3D CSS 효과를 위해 설계되었지만 나중에 웹 페이지 및 Chrome UI 인터페이스를 그리는 데 확장되었습니다. 공통 브라우저 요구 사항을 충족하기 위해 Chrome의 다중 프로세스 아키텍처에 소개되었습니다. 네트워크 프로세스는 페이지 네트워크 리소스를 독립적으로 로드하며, 원래 브라우저 프로세스 내의 모듈이었지만 지금은 별도의 프로세스로 실행됩니다. 플러그인 프로세스는 플러그인을 관리하여 브라우저 및 페이지에 플러그인의 내재적 불안정성으로 인한 충돌을 방지합니다.\n\n현대적인 브라우저 아키텍처는 아래 다이어그램에서 보실 수 있습니다:\n\n![Diagram](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_4.png)\n\n\n\n# 2. 브라우저 페이지 열리는 과정\n\n- 탭 추가는 기본 프로세스 생성을 시작합니다: 시스템 브라우저, 렌더링, GPU 및 네트워크 프로세스.\n- 사용자 입력은 브라우저 프로세스를 활성화하여 프로토콜을 확인하고 완전한 URL을 구성합니다.\n- 브라우저 프로세스는 URL 요청을 네트워크 프로세스로 보냅니다. 여기서 인터프로세스 통신이 이루어집니다.\n- 네트워크 프로세스는 요청된 리소스를 로컬 캐시에서 확인합니다. 캐시에서 찾을 경우 브라우저 프로세스로 반환합니다.\n- 캐시에 없는 경우, 네트워크 프로세스는 웹 서버로 HTTP 요청을 보냅니다.\n- 네트워크 프로세스는 응답을 구문 분석하고 상태 코드를 확인합니다. 비-200 상태 코드는 특정 처리 논리를 유도합니다.\n- 200 응답의 경우, 브라우저 프로세스는 Content-Type을 확인합니다. 바이트 스트림은 다운로드 관리자를 활성화하고 HTML은 렌더링 준비를 신호로 합니다.\n- 브라우저 프로세스는 현재 URL이 기존 렌더링 프로세스의 루트 도메인과 일치하는지 확인합니다. 다를 경우, 새로운 렌더링 프로세스를 시작합니다.\n- 브라우저는 네트워크 프로세스와 데이터 전송 파이프라인을 설정하기 위해 렌더링 프로세스에 \"문서 제출\" 메시지를 보냅니다.\n- 데이터 수신 후, 렌더링 프로세스는 브라우저로 확인을 보냅니다. 브라우저는 보안 표시기, 주소 표시줄 URL, 브라우징 기록 및 웹페이지 컨텐츠를 업데이트합니다.\n\n# 3. 렌더링 프로세스\n\n현대 브라우저는 성능을 우선시하는 방법으로 레이지 로딩 및 캐싱 같은 전략을 사용합니다. 브라우저는 렌더링 프로세스를 통해 웹 콘텐츠를 표시합니다. 핵심 단계는 HTML 구문 분석, CSS 스타일링, 레이아웃 생성 및 그리기가 되며, 구체적인 단계는 다음과 같습니다:\n\n\n\n- 사용자 입력 — 브라우저 주소 표시줄에 URL을 입력하세요.\n- URL 구문 분석 — URL을 구문 분석하여 프로토콜, 호스트, 포트 및 경로를 식별합니다.\n- DNS 조회 — 호스트 이름을 IP 주소로 변환하기 위해 DNS 조회를 수행합니다.\n- 소켓 연결 — 사용자와 서버 IP 간의 연결 설정.\n- HTTP 요청 — 프로토콜을 지정하는 HTTP 요청을 서버로 보냅니다.\n- 서버 처리 — 서버는 요청을 평가하고 처리 플러그인(예: PHP, Java)을 결정합니다.\n- 플러그인을 통한 처리 — HTTP 응답의 일부로 데이터베이스 또는 다른 리소스에 액세스합니다.\n- 브라우저 응답 — HTTP 응답을 브라우저로 다시 보냅니다.\n- 응답 분석 — 브라우저에서 응답의 HTML 데이터를 분석합니다.\n- DOM 트리 생성 — 구문 분석된 HTML에서 문서 객체 모델(DOM) 트리를 구성합니다.\n- 스타일시트 구문 분석 — 프레젠테이션 데이터를 DOM 노드에 연결하는 스타일시트를 구문 분석합니다.\n- JavaScript 실행 — DOM 요소를 수정하기 위해 JavaScript 코드를 실행합니다.\n- 페이지 렌더링 — DOM 및 스타일 데이터를 사용하여 웹 페이지를 표시합니다.\n\n## 3.1 HTML 구문 분석\n\n브라우저가 HTML을 문자 단위로 읽어 요소, 속성 및 텍스트를 식별한 후, 웹 페이지의 구조를 표현하는 DOM 트리를 구성하여 HTML 코드가 올바르게 표시되도록 합니다.\n\n## 3.2 CSS Object Model\n\n\n\nCSS Object Model는 HTML 요소에 적용된 스타일을 표현하며, DOM 트리의 구조적 계층과 유사하게 특정성과 스타일의 캐스캐이딩 성질을 고려하여 스타일에 대한 접근, 조작 및 계산을 허용합니다.\n\n## 3.3 레이아웃 관리자\n\n레이아웃 관리자는 DOM과 CSS object model을 결합하여 렌더링 트리를 형성하고, 내용, 패딩 등을 기반으로 상자의 크기를 결정하며, 특정 위치를 구축하는 데 다양한 메소드를 사용합니다. 동시에 겹치는 요소를 처리하기 위해 쌓임 맥락과 Z-인덱스를 사용하고, 배치 변경을 최적화하기 위해 일괄 처리 기술을 사용합니다. 마지막으로 화면에 요소가 그려지고 사용자 상호작용 중에 지속적으로 업데이트됩니다.\n\n# 4 플러그인 메커니즘\n\n\n\n## 4.1 플러그인 개발 역사\n\n플러그인 메커니즘의 개발 과정은 다음과 같습니다:\n\n- 2012년 8월 — 매니페스트 V1: Chrome 플러그인은 처음에 매니페스트 V1을 기반으로 했으며, 기본 기능 및 권한을 정의했습니다.\n- 2013년 4월 — Chrome26 안정 버전: 매니페스트 V1 플러그인 지원이 포함되었습니다.\n- 2014년 5월 — Chrome35 안정 버전: 브라우저의 점진적 업데이트가 계속해서 ManifestV1 플러그인을 지원했습니다.\n- 2014년 9월 — Chrome 37 안정 버전: Manifest V1 플러그인을 위한 추가 개선 및 버그 수정이 이루어졌습니다.\n- 2015년 5월 — Chrome43 안정 버전: Manifest V1 계속 지원됩니다.\n- 2015년 12월 — Manifest V2 등장: ManifestV2가 도입되어 더 나은 보안 및 추가 기능을 제공했습니다.\n- 2016년 6월 — Chrome51 안정 버전: Manifest V2가 플러그인 개발의 표준이 되었습니다.\n- 2016년 9월 — Chrome53 안정 버전: Manifest V2의 지속적인 개선 및 최적화가 이루어졌습니다.\n- 2019년 1월 — Manifest V3 출시: 보안, 성능 및 개발 유연성에 초점을 맞춥니다.\n- 2020년 3월 — Chrome80 안정 버전: Manifest V2는 플러그인의 표준이지만, Manifest V3는 테스트용으로 제공되었지만 아직 필수는 아닙니다.\n- 2021년 3월 — Chrome89 안정 버전: Manifest V2가 여전히 기본이지만 Manifest V3로의 관심이 증가하고 있습니다.\n- 2021년 10월 — Chrome94 안정 버전: Manifest V3가 일부 기능을 강화하기 시작하며, 이전 버전에서의 이전 가이드 및 도구가 개발자에게 제공됩니다.\n- 2022년 3월 — Chrome98 안정 버전: Manifest V3가 새로운 플러그인 버전의 기본이 됩니다. 그러면서 Manifest V2도 계속 지원됩니다.\n- 2022년 8월 — Chrome104 안정 버전: 모든 플러그인이 공식적으로 Manifest V3로 전환되어, Manifest V2의 추가 지원이 중단되었습니다.\n- 2023년 3월 — Chrome108 안정 버전: 모든 플러그인이 Manifest V3를 온전히 지원하며, 매끄러운 전환을 보장합니다.\n- 2023년 7월 — Manifest V3 미리보기: 개발자들이 다가오는 변경 사항을 탐색하고 유용한 피드백을 제공할 수 있도록 합니다.\n- 2023년 10월 — Chrome Z 안정 버전에서 ManifestV3 지원을 더 개선하며, 미리보기 단계에서 보고된 모든 문제를 해결합니다.\n- 2024년 1월 — Manifest V3 사전 안정 버전 배포: Manifest V3가 안정 상태에 도달하여, 개발자들이 확장 프로그램을 V3로 이전하고 모든 문서 및 이전 가이드가 제공됩니다.\n- 2024년 3월 — Chrome116 안정 버전: Manifest V3를 완전히 지원하며, 개발자들은 플러그인을 최신 표준과 호환되도록 업데이트합니다.\n\n총적으로, Chrome 익스텐션(또는 애드온)은 3가지 주요 버전인 Manifest V1, Manifest V2 및 Manifest V3의 개발 과정을 거쳤습니다.\n\n\n\nManifest V1 (MV1)은 Chrome 확장 프로그램 매니페스트의 초기 버전이었으며 오래되었습니다. Manifest V2 (MV2)는 현재 Chrome 확장 프로그램에서 널리 사용되는 주요 버전으로, 확장 프로그램을 더 많은 브라우저 기능과 기능으로 구축할 수 있는 견고한 프레임워크를 제공합니다. Manifest V3은 점차 MV2를 대체하는 최신 버전으로, 보안 및 성능 문제에 대응하기 위해 보안 조치를 강화하고 확장 프로그램 개발 시 더 나은 성능을 촉진하는 것을 목표로 합니다. Chrome 127 (2024년 6월)부터 Google은 안정화되지 않은 Chrome 버전에서 Manifest V2 확장 프로그램을 비활성화하기 시작할 예정이며, 개발자들이 MV3로 전환하도록 권장합니다.\n\n## 4.2 Manifest의 기능 및 버전 이전\n\nManifest V2의 기능:\n\n- Content-Security-Policy (CSP)를 설정하여 script-src 'self'; object-src 'self';를 사용하여 기본 콘텐츠 보안 정책을 설정합니다.\n- 플러그인 패키지 리소스는 외부로 더 이상 사용할 수 없으며, 허용 목록은 매니페스트의 web_access_resources 속성을 통해 나열됩니다.\n- 브라우저 작업 API 및 페이지 작업 API에 변경 사항이 있으며, chrome.extension이 플러그인 자체를 가리키는 chrome.self를 대체하고, chrome.tension.getTabContentses는 tension.getView로 대체되고, Port.tab은 runtime.Port로 대체됩니다.\n\n\n\nManifest V3의 기능:\n\n- Manifest V3은 백그라운드 페이지를 대체하는 서비스 워커를 도입했습니다.\n- 네트워크 요청 수정은 더 이상 사용되지 않는 webRequest API 대신 새로운 선언적 넷 요청 API를 사용합니다.\n- 원격 코드 실행이 허용되지 않으며, 확장 프로그램 패키지 내의 JS만 실행할 수 있습니다.\n- Promises가 많은 메소드에 추가되었고, 콜백은 여전히 지원됩니다.\n- Browser Action API 및 Page Action API가 하나의 액션 API로 통합되었습니다.\n- 웹 접근 가능한 리소스는 지정된 사이트 및 확장 프로그램으로 제한됩니다.\n- 콘텐츠 보안 정책 (CSP)은 다른 실행 컨텍스트에 대해 별도의 CSP를 지정할 수 있습니다. executeScript는 스크립트 파일과 함수만 실행하고 임의의 문자열은 실행할 수 없습니다.\n\nManifest V3은 Chrome이 개인 정보 보호, 보안 및 전반적인 확장 프로그램 성능 향상에 대한 약속으로부터 비롯된 V1과 V2로부터의 중요한 전환을 나타냅니다. 이전 버전과는 달리, Manifest V3은 자원 효율성을 우선시하여 Chrome의 과거 높은 자원 사용량에 대한 우려 사항을 해결합니다. 핵심 목표는 확장 프로그램을 통해 시스템 자원 소비를 제한하여 브라우저 성능을 최적화하는 것입니다. 추가 제약 사항을 부과하면서도, Manifest V3은 중요한 이점을 소개합니다. 서비스 워커 기능을 통해 확장 프로그램이 계속해서 백그라운드에 상주하지 않고도 작동할 수 있어, 확장 프로그램 자원을 재활용하고 브라우저 전반적인 오버헤드를 효과적으로 줄일 수 있습니다. 규칙 계산에 대한 제약 사항은 개별 확장 프로그램이 자원을 과도하게 소비하지 않도록 제어 메커니즘으로 작용합니다. 이러한 변경 사항들은 Chrome에서 더 부드러운 브라우징 경험을 제공하며, 향상된 브라우저 효율성에 대한 사용자 기대를 충족합니다.\n\nV2에서 V3로 이전시, 페이지 배경을 구성하기 위한 background.html이 없다는 이유로 백그라운드.html에서 AJAX 요청을 구성하는 데 윈도우 개체의 XMLHttpRequest를 사용할 수 없습니다. 대신, 데이터를 추출하는 방법을 사용하여 데이터를 검색해야 합니다.\n\n\n\n또한, 서비스 워커의 짧은 수명과 비활성 기간 동안의 종료로 인해 가끔 발생하는 시작, 실행 및 종료로 플러그인 수명주기 동안 불안정성이 발생합니다. MV2에서는 전역 변수가 데이터 저장에 직접 사용되었으므로 이러한 상황 하에서 안정성과 기능성을 향상시키기 위해 backound.js 로직을 수정해야 합니다. 또한 webRequest API에서 statativeNetRequest API로 전환하면 상당한 코드 리팩터링이 필요합니다.\n\n## 4.3 Chrome 확장 프로그램의 주요 구성 요소\n\n4.3.1 매니페스트 파일\n\n매니페스트.json 파일은 루트 디렉토리에 위치한 Chrome 확장 프로그램에 매우 중요합니다. 이 파일을 통해 Manif_version, 이름, 버전과 같은 기본 매개변수를 포함하여 모든 플러그인 설정을 구성합니다.\n\n\n\nManifest V2의 예시는 다음과 같습니다:\n\n```js\n{\n  \"manifest_version\": 2,\n  // 플러그인 이름\n  \"name\": \"...\",\n  // 플러그인 버전\n  \"version\": \"1.0.0\",\n  // 플러그인 설명\n  \"description\": \"...\",\n  \"icons\": {\n    \"16\": \"img/icon16.png\",\n    \"48\": \"img/icon48.png\",\n    \"128\": \"img/icon128.png\"\n  },\n  // 브라우저의 백그라운드 JS 또는 백그라운드 페이지\n  \"background\": {\n    \"scripts\": [\"js/background.js\"]\n  },\n  // 브라우저 아이콘 설정: browser_action, page_action, app\n  \"browser_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\",\n    \"default_popup\": \"popup.html\"\n  },\n  // 특정 페이지가 열릴 때에만 표시되는 아이콘\n  \"page_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\",\n    \"default_popup\": \"popup.html\"\n  },\n  // 페이지에 직접 주입되는 JS\n  \"content_scripts\": [{\n    \"matches\": [\"<all_urls>\"],\n    \"js\": [\"js/content-script.js\"],\n    \"css\": [\"css/custom.css\"],\n    // 코드 주입 시기, 기본값은 document_idle\n    \"run_at\": \"document_start\"\n  }],\n  // 요청되는 권한\n  \"permissions\": [\n    \"contextMenus\", // 우클릭 메뉴\n    \"tabs\", // 탭\n    \"notifications\", // 알림\n    \"webRequest\", // 웹 요청\n    \"webRequestBlocking\",\n    \"storage\", // 플러그인 로컬 저장소\n    \"https://*/*\" // executeScript 또는 insertCSS를 통해 접근 가능한 웹 사이트\n  ],\n  // 일반 페이지에서 직접 액세스할 수있는 플러그인 자원 목록  \"web_accessible_resources\": [\"js/inject.js\"],\n  \"homepage_url\": \"...\", // 플러그인 홈페이지\n  \"chrome_url_overrides\": { // 브라우저 기본 페이지 재정의\n    \"newtab\": \"newtab.html\"\n  },\n  \"options_ui\": { // 플러그인 옵션 페이지\n    \"page\": \"options.html\",\n    \"chrome_style\": true\n  },\n  \"omnibox\": { \"keyword\" : \"...\" }, // 검색 제안을위한 주소 표시줄에 키워드 등록, 하나의 키워드 만 설정 가능\n  \"default_locale\": \"en\", // 기본 언어\n  \"devtools_page\": \"devtools.html\", // Devtools 페이지 진입점, HTML 파일만 지정 가능    \"content_security_policy\": \"...\", // 보안 정책\n  \"web_accessible_resources\": [ // 로드 가능한 리소스\n    \"RESOURCE_PATHS\"\n  ]\n}\n```\n\nManifest V3의 예시는 다음과 같습니다:\n\n```js\n{\n  \"manifest_version\": 3,\n  \"name\": \"...\", \n  \"version\": \"1.0.0\",\n  \"description\": \"...\", \n  \"icons\": {\n    \"16\": \"img/icon16.png\",\n    \"48\": \"img/icon48.png\",\n    \"128\": \"img/icon128.png\"\n  },\n  \"background\": {\n    \"service_worker\": \"js/background.js\"\n  },\n  \"action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\", \n    \"default_popup\": \"popup.html\"\n  },\n  \"content_security_policy\": {\n    \"extension_pages\": \"...\",\n    \"sandbox\": \"...\"\n  },\n  \"web_accessible_resources\": [\n    {\n      \"resources\": [\"RESOURCE_PATHS\"]\n    }\n  ],\n  \"permissions\": [\n    \"contextMenus\",\n    \"tabs\",\n    \"notifications\",\n    \"webRequest\",\n    \"webRequestBlocking\",\n    \"storage\",\n    \"https://*/*\"\n  ],\n  \"web_accessible_resources\": [\"js/inject.js\"],\n  \"homepage_url\": \"...\", \n  \"chrome_url_overrides\": {\n    \"newtab\": \"newtab.html\"\n  },\n  \"options_ui\": {\n    \"page\": \"options.html\",\n    \"chrome_style\": true\n  },\n  \"omnibox\": {\n    \"keyword\": \"...\"\n  },\n  \"default_locale\": \"zh_CN\", \n  \"devtools_page\": \"devtools.html\",\n  \"content_security_policy\": \"...\",\n  \"web_accessible_resources\": [\"RESOURCE_PATHS\"]\n}\n```\n\n\n\n4.3.2 콘텐츠 스크립트\n\n크롬 익스텐션의 콘텐츠 스크립트는 구성을 통해 지정된 페이지에 JS 및 CSS를 삽입합니다. 그들은 원래 페이지와 DOM을 공유하지만 JavaScript는 공유하지 않습니다. 페이지 JS 변수에 액세스하려면 JS를 삽입해야 합니다. 콘텐츠 스크립트는 다음을 제외한 대부분의 Chrome API에 액세스할 수 없습니다.\n\n- chrome. extension\n- chrome.i18n\n- chrome. runtime\n- chrome.storage\n\n다른 API의 경우, 통신은 백그라운드 또는 서비스 워커를 통해 수행되어야 합니다.\n\n\n\n### 4.3.3 배경 스크립트\n\n크롬 확장프로그램의 배경 스크립트는 수명이 가장 길며 브라우저가 열려 있는 동안 계속 실행됩니다. 이들은 광범위한 권한을 가지고 있어 대부분의 크롬 확장프로그램 API에 액세스하고 CORS 제한 없이 교차 출처 요청을 할 수 있습니다. Manifest V3에서 배경 페이지는 수명이 짧고 이벤트 기반으로 실행되는 서비스 워커로 대체되어 글로벌 변수를 저장하기에 적합하지 않습니다.\n\n### 4.3.4 팝업 창\n\n팝업 창은 웹페이지의 작은 창으로, 오른쪽 상단의 아이콘을 클릭하면 나타납니다. 사용자가 웹페이지 외부에서 상호 작용하면 빠르게 닫힙니다. 일시적 상호작용에 사용되며 배경과 유사한 권한 수준을 가지지만 수명은 짧습니다.\n\n\n\n### 4.3.5 스크립트 삽입\n\n크롬 확장 프로그램 개발 중 개발자들이 \"스크립트 삽입\"이라는 용어를 만들었습니다. 이 용어는 DOM 조작을 통해 페이지에 주입된 JavaScript를 가리킵니다. 콘텐츠 스크립트는 DOM을 조작할 수 있지만 액세스 제한으로 인해 직접 액세스할 수 없습니다. 이 제한은 특히 이벤트 바인딩에서 잘 나타납니다. 웹 페이지에서 플러그인을 실행하는 버튼을 추가하는 일반적인 요구 사항을 충족하기 위해 개발자들은 스크립트 삽입 방식을 채택했습니다.\n\n## 4.4 크롬 확장 프로그램의 통신 메커니즘\n\n크롬 확장 프로그램에서 통신은 다섯 가지 유형의 스크립트에 의존합니다:\n\n\n\n- 인젝션 스크립트는 보통 window.postMessage에 의존하는 웹페이지에 동적으로 삽입되는 스크립트를 나타냅니다.\n- 컨텐츠 스크립트는 특정 웹페이지 컨텍스트에서 실행되는 스크립트로, window.postMessage, chrome.runtime.sendMessage 및 chrome.runtime.connect를 사용하여 스크립트 간 통신을 합니다.\n- 팝업 스크립트는 플러그인 팝업 인터페이스와 관련되며, 일반적으로 통신을 위해 chrome.tabs.sendMessage 및 chrome.tabs.connect를 사용합니다.\n- 백그라운드 스크립트는 다양한 방법을 활용하며 백그라운드에서 독립적으로 실행되는 스크립트이며, \"chrome.tabs.sendMessage\", chrome.tabs.connect, chrome.extension.getBackgroundPage 및 chrome.extension.getViews 등의 메서드를 사용합니다.\n- 개발 도구는 chrome.devtools.inspectedWindow.eval 및 chrome.runtime.sendMessage과 같은 특정 API를 사용하여 상호 작용하는 개발 도구의 추가 기능을 제공합니다.\n\n각 스크립트에는 통신의 중요성을 강조하는 다른 권한이 있습니다. 이 상호 작용은 포괄적인 플러그인 기능을 활성화하는 데 중요합니다.\n\n과거를 되짚어 새로운 것을 배우는 것은, 현대 인터넷의 기반인 브라우저 아키텍처가 다중 반복과 혁신을 거쳐 사용자와 웹 콘텐츠 간의 다리로서 항상 역할하고 있다는 것을 생각해봅니다. 초기에는 단일 렌더링 엔진부터 오늘날의 멀티 프로세스, 멀티 스레드 아키텍쳐까지, 각 변화는 더 스무스하고 안전한 브라우징 경험을 가져왔습니다. 앞으로 브라우저 아키텍처는 성능 최적화와 보안 강화를 더욱 심화시켜 사용자에게 더 나은 웹 브라우징 경험을 제공하기 위해 발전할 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png"},"coverImage":"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png","tag":["Tech"],"readingTime":15},{"title":"디자인 패턴 더 나은 코드 작성하기","description":"","date":"2024-05-12 23:46","slug":"2024-05-12-DesignPatternsBuildingBetterCode","content":"\n\n<img src=\"/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png\" />\n\n## 소개\n\n소프트웨어 개발 세계에서 효율적이고 유지보수 가능하며 확장 가능한 코드를 작성하는 것이 매우 중요합니다. 하지만 프로젝트가 복잡해지면 이를 관리하는 것이 점점 어려워집니다. 여기서 디자인 패턴이 필요해집니다.\n\n## 디자인 패턴이란 무엇인가요?\n\n\n\n디자인 패턴은 코딩에서 흔히 발생하는 문제에 대한 준비된 솔루션과 같아요. 그들은 개발자들이 항상 직면하는 까다로운 코딩 퍼즐을 해결하기 위한 레시피 같습니다. 요리를 할 때 레시피를 사용하는 것처럼, 개발자들은 디자인 패턴을 사용하여 똑똑한 방식으로 코드를 작성해요.\n\n## 디자인 패턴을 사용하는 이유는?\n\n디자인 패턴은 유용합니다:\n\n코드 재사용성: 재사용 가능한 솔루션을 제공하기 때문에, 개발자들은 문제를 만날 때마다 바퀴를 다시 발명할 필요가 없어요.\n\n\n\n# 확장성: 새로운 기능을 추가하거나 프로젝트의 규모를 확장하는 데 도움을 줍니다. 이렇게 함으로서 코드를 엉망으로 만들지 않고 처리할 수 있습니다.\n\n# 유지보수성: 프로젝트가 시간이 지나도 코드를 조직화하고 이해하기 쉽게 도와줍니다.\n\n# 오류 감소: 정해진 패턴을 따름으로써 개발자는 흔한 실수와 버그를 피할 수 있습니다.\n\n# 성능 향상: 디자인 패턴은 효율적인 코딩 방법을 장려하여 더 나은 성능의 소프트웨어로 이끕니다.\n\n\n\n협업: 여러 개발자가 동일한 코드베이스에서 작업하기가 더 쉽습니다. 팀워크와 생산성을 촉진합니다.\n\n## 디자인 패턴의 종류\n\n주요 세 가지 유형이 있습니다:\n\n생성 패턴: 이러한 패턴은 객체가 어떻게 생성되는지 다룹니다. 객체를 언제, 어떻게 생성할지 결정하는 데 도움이 됩니다. 코드의 유연성과 성능을 향상시킬 수 있습니다.\n\n\n\n구조 패턴: 이러한 패턴은 클래스와 객체가 대형 구조를 형성하는 방식에 중점을 둡니다. 코드를 이해하고 유지 관리하기 쉬운 방식으로 구조화하는 데 도움을 줍니다.\n\n행동 패턴: 이러한 패턴은 객체 간의 통신 방식을 정의합니다. 코드를 유연하고 결합도가 낮은 방식으로 설계할 수 있게 도와줍니다. 이는 코드의 다른 부분이 서로에게 지나치게 의존하지 않도록 합니다.\n\n## 일반적으로 사용되는 디자인 패턴\n\n생성 패턴:\n\n\n\n- 팩토리 메서드: 이 패턴은 구체적으로 인스턴스화할 클래스를 지정하지 않고 객체를 생성하는 데 도움을 줍니다. 이는 느슨한 결합을 촉진하고 코드를 더 유연하게 만듭니다.\n\n```js\n{\nclass Fruit {\nconstructor(name) {\nthis.name = name;\n}\neat() {\nconsole.log(`${this.name}을(를) 먹는 중`);\n}\n}\nclass FruitStand {\nstatic create(name) {\nreturn new Fruit(name);\n}\n}\nconst fruit1 = FruitStand.create(\"사과\");\nconst fruit2 = FruitStand.create(\"오렌지\");\nfruit1.eat(); // 사과를 먹는 중\nfruit2.eat(); // 오렌지를 먹는 중\n}\n```\n\n- 싱글톤: 이 패턴은 클래스가 하나의 인스턴스만 가지도록 보장하고 해당 인스턴스에 대한 전역 액세스 지점을 제공합니다. 설정 또는 로깅에 유용하지만 남용하면 결합이 강화될 수 있으므로 삼가 사용하세요.\n\n```js\nclass Singleton {\nconstructor() {\nif (Singleton.instance) {\nreturn Singleton.instance;\n}\nSingleton.instance = this;\n}\n// 여기에 코드 작성\n}\nmodule.exports = Singleton;\n```\n\n\n\n프론트엔드 개발자님 안녕하세요!\n\n- Builder: 복합 객체의 생성을 표현으로부터 분리하여 동일한 생성 프로세스가 다양한 표현을 만들 수 있게 합니다. 많은 선택적 매개변수나 구성을 갖는 객체를 다룰 때 매우 유용합니다.\n\n구조 패턴:\n\n- Adapter: 이 패턴을 사용하면 호환되지 않는 인터페이스끼리 함께 작동할 수 있습니다. 서로 다른 인터페이스를 가진 두 클래스 사이에 다리 역할을 합니다.\n\n```js\n// 기존 Animal 클래스\nclass Animal {\nconstructor(name) {\nthis.name = name;\n}\nspeak() {\nconsole.log(`${this.name} makes a sound.`);\n}\n}\n// Adapter 클래스\nclass LionAdapter {\nconstructor(animal) {\nthis.animal = animal;\n}\nroar() {\nconsole.log(`${this.animal.name} roars loudly!`);\n}\n}\n// 사용법\nconst genericAnimal = new Animal(\"일반 동물\");\nconst lion = new LionAdapter(genericAnimal);\nlion.roar(); // 일반 동물이 크게 웁니다!\n```\n\n\n\n- 데코레이터: 이 패턴은 기존 객체에 동적으로 새로운 기능을 추가합니다. 핵심 기능을 수정하지 않고 여러 데코레이터를 추가할 수 있습니다.\n\n행동 패턴:\n\n- 옵저버: 이 패턴은 객체 간의 일대다 종속성을 정의합니다. 한 객체의 상태 변경 시 모든 종속 객체에게 알립니다. 이는 이벤트 처리나 실시간 업데이트와 같은 기능을 구현하는 데 유용합니다.\n\n```js\nclass FruitObserver {\nconstructor() {\nthis.observers = [];\n}\nsubscribe(fn) {\nthis.observers.push(fn);\n}\nunsubscribe(fn) {\nthis.observers = this.observers.filter(fruitListener => fruitListener !== fn);\n}\nnotify(data) {\nthis.observers.forEach(observer => observer(data));\n}\n}\nconst fruitObserver = new FruitObserver();\nfruitObserver.subscribe(data => console.log(`Subscribed to ${data}`));\nfruitObserver.notify(\"Apple\"); // Subscribed to Apple\n```\n\n\n\n- 전략: 이 패턴은 알고리즘의 동작을 실행 중에 동적으로 변경할 수 있게 합니다. 클라이언트 코드를 수정하지 않고 다양한 전략 사이를 전환할 수 있습니다.\n\n## 결론\n\n디자인 패턴을 코드의 구성 요소로 생각해보세요. 프로그래머들이 자주 마주치는 문제에 대한 검증된 솔루션이죠. 이러한 패턴을 배움으로써, 초보자든 전문가든 상관없이 빠르게 더 좋은 코드를 작성할 수 있습니다.\n\n읽어주셔서 감사합니다! 🎉","ogImage":{"url":"/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png"},"coverImage":"/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러에서의 HTTP Interceptors","description":"","date":"2024-05-12 23:44","slug":"2024-05-12-HTTPInterceptorsinAngular","content":"\n\n<img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png\" />\n\n안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.\n\n# 안내\n\n- Angular란 무엇인가요?\n\n\n\n**HTTP Interceptor란 무엇인가요?**\n\n**Angular에서의 HTTP Interceptor**\n\n**HTTP Interceptor의 장점**\n\n**실용적인 구현**\n\n\n\n# 선행 요건\n\n- TypeScript와 Angular에 대한 기본적인 이해\n- Angular CLI\n- NodeJS\n\n\n\n- VS Code\n\n## Angular이란 무엇인가요?\n\nAngular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.\n\n## HTTP Interceptor란 무엇인가요?\n\n\n\n- HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.\n\n- 이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.\n\n## Angular의 HTTP 인터셉터\n\n- Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png\" />\n\n- HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.\n\n- HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.\n\n# HTTP 인터셉터의 장점\n\n\n\n아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:\n\n테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.\n\n크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.\n\n전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.\n\n\n\n오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.\n\n캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.\n\n역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.\n\n보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.\n\n\n\n세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:\n\n| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool. \n\n## 실용적인 구현\n\n실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.\n\n이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.\n\n\n\n1. 로깅 인터셉터\n\nAngular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.\n\n단계 1\n\n다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.\n\n\n\n이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpResponse,\n} from '@angular/common/http';\nimport { Observable, tap } from 'rxjs';\n\n@Injectable()\nexport class LoggingInterceptor implements HttpInterceptor {\n  constructor() {}\n\n  intercept(\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    console.log('Outgoing HTTP request', request);\n    return next.handle(request).pipe(\n      tap((event: HttpEvent<any>) => {\n        console.log('Incoming HTTP response', event);\n      })\n    );\n  }\n}\n```\n\n- 여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.\n\n- HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.\n\n\n\n- 우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.\n\n- next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.\n\n- 그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.\n\n- tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.\n\n\n\n단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { LoggingInterceptor } from './interceptors/logging.interceptor';\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true\n    }\n]\n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.\n\n\n\nHTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:\n\n![HTTPInterceptorsinAngular_2](/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png)\n\n실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.\n\n2. 요청에 헤더 추가\n\n\n\n앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.\n\n단계 1\n\n다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeadersInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n    console.log(request)\n    const GUID = 'f4179b26-21ac-432c-bcd8-cb4bc6e50981'\n    const modifiedRequest = request.clone({\n      setHeaders:{\n        GUID\n      }\n    })\n    return next.handle(modifiedRequest);\n  }\n}\n```\n\n\n\n먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\n\n### 단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { HeadersInterceptor } from './interceptors/headers.interceptor'\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: HeadersInterceptor, multi: true\n    }\n  ]\n```\n\n\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.\n\n![HTTP Interceptors in Angular](/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png)\n\n실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.\n\n3. 에러 처리 Interceptor\n\n\n\n앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.\n\n서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.\n\n각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.\n\n에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.\n\n\n\n**단계 1**\n\n다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { Observable, catchError, throwError } from 'rxjs';\n\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return next.handle(request).pipe(\n      catchError((error: HttpErrorResponse) => {\n        // 여기서 오류를 처리합니다\n        console.error('오류 발생:', error);\n        // 요구에 따라 오류 throw\n        return throwError(error);\n      })\n    );\n  }\n}\n```\n\n- `intercept()` 메서드 내에서 RxJS의 `catchError` 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.\n\n\n\n**단계 1**\n\n· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.\n\n**단계 2**\n\n· 앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { ErrorInterceptor } from './interceptors/error.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true\n  }\n]\n```\n\n\n\n· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.\n\n4. Authentication Interceptor\n\nAngular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.\n\n단계 1\n\n\n\n다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n//import { AuthService } from './auth.service';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(/*private authService: AuthService*/) {}\n\n  intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA\";//his.authService.getToken();\n\n    if (authToken) {\n      // 요청을 복제하고 토큰을 첨부합니다\n      const authReq = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${authToken}`\n        }\n      });\n\n      return next.handle(authReq);\n    }\n\n    // 토큰이 없는 경우 원본 요청을 전달합니다\n    return next.handle(req);\n  }\n}\n```\n\n여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다. \n\nStep 2\n\n\n\n앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { AuthInterceptor } from './interceptors/auth.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true\n  }\n]  \n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.\n\nHTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png\" />\n\n여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.\n\n# GitHub URL\n\nhttps://github.com/Jaydeep-007/angular-http-interceptor-demo\n\n\n\n# 결론\n\n이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.\n\n코딩하세요!\n\n# 간단히 말해서\n\n\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 칭찬하고 팔로우해 주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입해주세요. 🗞️\n- 트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png"},"coverImage":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png","tag":["Tech"],"readingTime":10},{"title":"Gulp v5를 발표 내용 정리","description":"","date":"2024-05-12 23:43","slug":"2024-05-12-AnnouncingGulpv5","content":"\n![Announcing Gulp v5.0](/assets/img/2024-05-12-AnnouncingGulpv5_0.png)\n\ngulp 5로 가는 길은 길었지만, 우리가 여기까지 왔어요! 이 릴리스에는 60개 이상의 프로젝트에 대한 4년치 작업이 포함되어 있습니다. 함께하여 팀은 200개 이상의 이슈와 풀 리퀘스트를 마무리했어요. 🤯\n\n# Streamx\n\n처음부터 gulp는 스트림을 중심으로 만들어졌어요. gulp 5에서는 mafintosh의 우수한 streamx 라이브러리로 전환했어요. Streamx에는 Node.js 코어 스트림 대비 여러 이점이 있습니다. `pipe()` 함수에서 객체 및 버퍼 모드를 투명하게 처리하며 에러 처리가 가능해요.\n\n저희는 이 훌륭한 스트림 구현에 대해 더 많은 글을 쓸 시간을 갖고 싶어합니다. 그러나 대부분의 사용자들은 Node.js 코어 스트림과의 호환성을 유지하려는 노력 덕분에 차이를 느끼지 못할 것입니다. gulp 5 개발 과정에서 Mathias님의 도움과 버그 수정에 감사드립니다! 그의 작업을 후원해주시기를 고려해 주세요.\n\n# 종속성\n\n이번 릴리스의 주요 초점은 의존성 트리를 줄이고 대부분 유지하는 것으로 통합하는 데 있습니다. gulp 4가 발표된 이후 사용하던 많은 종속성이 유지되지 않았고, 따라서 이를 제거하거나 유지 책임을 갖기로 결정했습니다.\n\ngulpjs GitHub 조직은 70개 이상의 저장소로 성장했습니다. 이 세분화된 분리는 우리가 빠르게 작은 수정을 할 수 있게 하며, 다른 프로젝트들이 우리 패키지의 일부에 의존할 수 있게 합니다. 그러나 이에 대한 희생은 프로젝트 전체에 대한 대규모 변화를 만들기까지 시간이 걸린다는 것입니다.\n\n# 주요 변경 사항\n\n\"breaking changes\"가 없는 SemVer 주요 릴리스는 없겠죠. 유저들이 업그레이드할 때 문제가 없거나 거의 없기를 바라지만, 변경된 사항을 꼭 숙지하셔야 합니다.\n\n이번 대규모 릴리스에서 여기서 다루는 변경 사항은 일부분에 불과하기 때문에, 무언가가 다르게 느껴지는 것이 있다면 저희의 종합 변경 로그와 개별 프로젝트 변경 로그를 확인해주세요.\n\n## 스트림 인코딩\n\n저희 스트림은 이제 UTF-8 인코딩이 기본 설정으로 적용됩니다. 이전에는 스트림이 발생한 데이터를 인코딩을 고려하지 않고 그대로 가져왔었는데, 이번 릴리스에서는 10년 된 문제를 해결하여 사용자 정의 인코딩을 지원하고 이를 기본값으로 UTF-8로 설정했습니다. 대부분의 사용 방법은 gulp을 변경할 필요가 없을 것이지만, 일부 플러그인은 UTF-8이 아닌 출력물을 생성할 수 있으며 gulp 스트림에서 `' encoding: false '`로 설정해야 할 수 있습니다.\n\n## 글롭(Globs)\n\n또한 모든 API에서 글로빙 라이브러리를 통일했습니다. 이전에는 `src()`가 node-glob 라이브러리를 사용하고 `watch()`가 anymatch 라이브러리를 chokidar를 통해 사용했었습니다. 몇 년 동안 특정 글로브들이 이러한 함수 간에 동일하게 작동하지 않는 문제가 여러 개 개설되었었습니다. gulp 5부터는 글로브 지원으로 일관되게 anymatch를 사용합니다.\n\n게다가 “순서가 있는 글로브(ordered globs)\"를 더 이상 지원하지 않습니다. “순서가 있는 글로브\"는 음수 글로브가 배열에서 뒤에 나오는 양수 글로브에 의해 무시될 수 있는 기능이었습니다. 다른 글로빙 라이브러리에서는 이것이 흔하지 않기 때문에 모든 음수 글로브는 생태계에 일관성을 주기 위해 모든 양수 글로브에서 경로를 필터링합니다. 순서가 있는 스트림이 필요하면, ordered-read-streams 라이브러리를 제공합니다.\n\n## CLI\n\n우리는 `swc`, `esbuild`, 그리고 `sucrase`의 로더를 추가했어요. 많은 사용자들이 `.mjs`와 `.cjs` 확장자를 지원해줄 것을 요청했기 때문에, 이제 이 둘을 사용할 수 있어요. 의존성 트리를 간소화하는 과정에서 많은 구식이며 폐기된 로더들을 제거했어요. 만약 우리가 지원했던 더 색다른 로더들을 사용 중이셨다면, 더 현대적인 것으로 변경해야 할지도 모르겠어요.\n\n우리는 `—verify` 플래그를 마침내 제거했어요. 왜냐하면 오랫동안 플러그인 금지 목록을 유지하지 않고 있어서 그랬거든요. 그리고 `—require`를 `—preload`로 이름을 변경해야 했어요. 그렇게 함으로써 Node.js 플래그와 충돌을 피할 수 있어요.\n\n## Logging\n\n`gulplog`을 사용하는 모든 플러그인은 v1에서 v2로 업그레이드해야 하며, 만약 v1을 사용 중이면 사용자에게 사용 중단 경고가 표시됩니다.\n\n# 노드 지원\n\n우리는 오랫동안 gulp가 안정적인 소프트웨어임을 말해 왔으며, 가능한 많은 사용자를 지원하는 것에 관심이 있습니다. Gulp 4는 릴리스 시점에 널리 사용되었던 Node.js v0.10 사용자를 목표로 지원하는 것을 명시적으로 설정하였습니다. 10년이 지난 지금, 플랫폼이 성장하고 JavaScript가 발전함에 따라 Node.js는 이제 6개월마다 새로운 안정 버전을 출시하며, LTS 지원 기간은 30개월입니다. 이러한 새로운 버전에는 gulp를 더 나아지고 더 안정적으로 만들기 위해 활용하길 원하는 기능이 포함되어 있어서, 우리는 Node.js v10.13.0 미만의 모든 버전을 지원 중단했습니다.\n\n지원하는 Node.js 버전을 제한함으로써 의존성 트리에서 많은 플랫폼 및 JavaScript 쉼들을 제거할 수 있었습니다. 이 중 많은 부분은 유지보수되지 않았거나 스캐너에 의해 문제가 발견된 것입니다. 2018년에 발표된 Node.js 버전(그리고 LTS 지원 기간 외부)을 계속 지원함으로써 희망을 갖고 있습니다. 모든 사용자가 gulp 5로 원활하게 업그레이드할 수 있기를 바랍니다.\n\n마침내, 우리는 Windows, Mac 및 Linux을 우선 플랫폼으로 고려해 왔기 때문에 v3, v4 및 v5 사이의 인프라에 상당한 변동이 있었습니다. 이 세 가지 운영 체제를 일관되게 지원하고 사용하기 쉬운 지속적 통합 서비스를 찾는 데 많은 시간이 소요되었습니다. 우리는 우리 주요 대상을 지원하고 release-please와 같은 도구를 활용할 수 있는 GitHub Actions을 중심으로 인프라를 안정화하는 데 상당한 시간을 투자했습니다.\n\n# 앞으로\n\n할 일은 언제나 더 많이 남아 있습니다. 다가오는 몇 주 동안, 나는 우리 v5 이후 프로젝트 보드를 검토하고 중단되지 않는 후속 작업을 위한 토의를 만들 계획입니다. 우리는 gulp 5를 일정 기간 안정화한 후 다음 주요 버전을 계획하기 전에 문제가 발생하면 수정할 수 있도록 할 것입니다.\n\n우리는 더 넓은 커뮤니티로부터 피드백을 받기 위해 설문 조사를 작성 중입니다. 5월 경에 발표될 예정이니 주목해주시기 바랍니다.\n\n지금은 새 릴리스를 즐기시길 바라며, 프로젝트에 기여하거나 저희의 작업을 후원해주시면 감사하겠습니다!\n","ogImage":{"url":"/assets/img/2024-05-12-AnnouncingGulpv5_0.png"},"coverImage":"/assets/img/2024-05-12-AnnouncingGulpv5_0.png","tag":["Tech"],"readingTime":4},{"title":"데이터 스크레이퍼의 도구 상자 필수 도구와 전략","description":"","date":"2024-05-12 23:39","slug":"2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies","content":"\n\n![이미지](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png)\n\n# 1. 웹 스크래핑이란?\n\n웹 스크래핑은 웹사이트에서 데이터를 추출하는 기술입니다. 이 과정은 자동화된 도구를 사용하여 가격 목록, 제품 세부정보, 이메일 주소 및 심지어 이미지와 같은 특정 정보를 수집하는 것을 포함합니다. 수집된 데이터는 시장 조사, 경쟁 분석 또는 온라인 데이터베이스 업데이트와 같은 다양한 목적으로 사용될 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/0*MwktrV5bs-basgRX.gif)\n\n\n\n일반적으로 시작하는 과정은 스크레이퍼 프로그램이 웹 페이지에 요청을 보내는 것으로 시작합니다. 그런 다음 페이지의 HTML 콘텐츠를 구문 분석하여 특정 데이터 요소를 검색합니다. 웹 스크래핑의 유연성 덕분에 웹 사이트에서 보이는 거의 모든 유형의 정보를 캡쳐할 수 있어 데이터 기반 의사 결정에 귀중한 도구가 됩니다.\n\n## 2. 웹 스크래핑의 이점\n\n가격 모니터링:\n\n웹 스크래핑의 첫 번째 이점은 시장에서 제품 가격을 모니터링하는 것입니다. 예를 들어, 특정 유형의 식품을 판매하는 비즈니스를 소유하고 있다면, 유사한 항목이 판매되는 가격 범위를 항상 알고 있어야 합니다. 웹 스크래핑을 통해 가격을 쉽게 추적할 수 있습니다. 경쟁 업체가 얼마를 청구하는지 알면 자신의 제품 가격을 설정하는 것이 훨씬 간단해집니다.\n\n\n\n다른 회사로부터 정보 수집:\n\n다른 회사와 파트너십을 맺으려고 할 때 그들에 대해 더 많이 알아야 합니다. 웹 스크레이핑을 사용하면 잠재적인 파트너들에 대한 방대한 데이터를 수집할 수 있습니다. 이 정보를 통해 회사가 신뢰할 만하고 협력에 적합한지를 판단할 수 있습니다. 따라서 이 과정은 탄탄한 비즈니스 결정에 중요한 역할을 합니다.\n\n시장 조사:\n\n시장 조사는 모든 비즈니스에 있어 중요합니다. 사용자들이 원하는 것을 밝혀내고 효과적인 마케팅 전략을 구축하기 위한 기초 역할을 합니다. 시장 조사에는 가장 정확한 정보가 필수이며, 웹 스크레이핑은 이를 달성하는 데 도움을 줄 수 있습니다. 웹 스크레이핑을 통해 소비자들이 선호하는 최신 트렌드를 발견할 수 있습니다. 이 데이터를 분석하여 당신의 타겟 시장을 겨냥한 제품 개발을 안내하는 데 활용할 수 있습니다.\n\n\n\n뉴스 및 콘텐츠 모니터링:\n\n브랜드를 구축하는 가장 쉬운 방법 중 하나는 미디어를 새 제품 출시 행사로 초대하는 것입니다. 미디어는 행사를 취재하고 제품을 검토하여 귀중한 홍보를 만들어내어 비즈니스에 큰 도움이 됩니다. 미디어 보도를 모니터링하는 것은 웹 스크레이핑을 통해 손쉽게 할 수 있어 여러분의 제품 및 비즈니스에 대한 보도 내용을 확인할 수 있습니다.\n\n리드 생성:\n\n새로운 리드를 확보하기 위한 중요한 전략은 잠재고객으로부터 가능한 많은 연락처 정보를 수집하는 것입니다. 웹 스크레이핑은 잠재고객의 연락처 정보를 획득하는 데 매우 효과적인 방법으로, 새로운 고객을 대상으로 하는 데 도움이 됩니다.\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:960/0*LjUSDEg8no_fYQ64.gif)\n\n# 3. 웹 스크래핑 기술\n\n![image](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_1.png)\n\n일반적으로 웹 스크래핑에는 두 가지 방법이 있습니다:\n\n\n\n수동: 이 방법은 웹 페이지에서 데이터를 직접 복사하여 붙여넣기해야 합니다. 직관적이지만 대규모 데이터셋과 작업할 때 극도로 시간이 많이 걸리고 지루할 수 있습니다.\n\n자동: 이 방법은 코딩, 소프트웨어 응용 프로그램 또는 브라우저 확장 프로그램을 활용합니다. 자동화는 데이터를 신속하게 스크래핑할 수 있는 능력으로 인해 인기를 얻고 있습니다. 사용 중인 구체적인 도구 또는 소프트웨어에 따라 방법이 다르지만, 모든 웹 스크래핑 봇은 세 가지 기본 원칙을 따릅니다:\n\n- 요청:\n이 과정은 GET 방법을 사용하여 대상 웹 사이트에 HTTP 요청을 보내는 것으로 시작됩니다. 프로그램은 원하는 웹 페이지에 액세스하여 정보를 가져옵니다. 이 단계를 통해 봇이 연결을 설정하고 데이터 추출을 위해 웹 페이지를 식별할 수 있도록 합니다.\n- 파싱:\n웹사이트로부터 응답을 받은 후, 프로그램은 파싱 프로세스를 시작합니다. 파싱은 데이터 스크래핑 기술을 활용하여 웹 페이지에서 특정 데이터 포인트를 추출하는 것을 의미합니다. 프로그램은 HTML 마크업 또는 다른 구조적 형식을 기반으로 관련 정보를 식별하고 분리합니다.\n- 표시:\n파싱을 통해 원하는 데이터를 수집하고 식별한 후, 읽기 쉬운 보고서나 표시로 변환됩니다. 데이터는 테이블, 그래프 또는 이전에 정의된 사양이나 필요에 맞는 구조와 일치하는 다양한 형식으로 제시될 수 있습니다. 최종 목표는 정보를 쉽게 이해할 수 있는 형식으로 제공하여 추가 분석이나 전략적 의사 결정에 활용할 수 있도록 하는 것입니다.\n\n# 4. 웹 스크래핑 방법\n\n\n\n- 대상 웹사이트 선택\n스크래이핑할 웹사이트를 식별하여 시작하세요. 예를 들어, 고객 서평을 분석하려면 Amazon, Goodreads 또는 LibraryThing과 같은 웹사이트를 고려할 수 있습니다.\n- 페이지 검사\n코드에 뛰어들기 전에 스크래이핑할 데이터를 식별하는 것이 중요합니다. 페이지를 마우스 오른쪽 버튼으로 클릭하고 \"요소 검사\" 또는 \"페이지 소스 보기\"를 선택하여 웹사이트의 기본 HTML 코드를 확인합니다. 이를 통해 데이터의 구조를 파악할 수 있습니다.\n- 원하는 데이터 식별\nAmazon의 책 평가에 집중한다면, 페이지의 HTML 코드에서 평가가 있는 위치를 찾으세요. 대부분의 브라우저는 선택된 프런트엔드 콘텐츠와 해당 백엔드 코드를 강조합니다. 여기서 목표는 관련 데이터를 격리하는 데 도움이 되는 고유한 태그를 식별하는 것입니다.\n- 코드 작성\n관련 태그를 정확하게 찾았다면, 해당 태그를 스크래이핑 소프트웨어에 통합하세요. 이를 위해 파이썬이 주로 사용되며, 스크래이핑 프로세스를 단순화하는 강력한 라이브러리를 갖추고 있습니다. 분석하고 저장할 정확한 데이터를 책 제목, 작가 이름, 평점 등으로 지정하는 것을 잊지 마세요.\n- 코드 실행\n코드를 작성한 후에는 다음 단계인 실행 단계로 넘어가세요. 스크레이퍼는 사이트 접근을 요청하고 데이터를 추출하여 분석할 것입니다.\n- 데이터 저장\n추출, 분석 및 관련 데이터 수집을 마치면, 그것을 저장해야 합니다. 코드에 추가 라인을 넣어 알고리즘에 그 기능을 수행하도록 지시할 수 있습니다. 선택한 형식은 중요하지 않지만 가장 일반적인 Excel 형식에 준수해야 합니다. Python 정규식 모듈을 통해 코드를 실행하여 데이터셋을 더 깔끔하게 추출하는 것도 가능합니다.\n\n# 5. 웹 스크래이핑 도구\n\n웹 스크래이핑 도구는 웹사이트로부터 데이터를 자동으로 추출하기 위해 설계된 필수 소프트웨어 응용프로그램입니다. 이 도구들은 인터넷에서 대량의 정보를 수집하여 시장 조사, 감정 분석, 경쟁 분석 및 학술 연구와 같은 다양한 목적으로 정보를 접근 가능하고 사용 가능하게 만듭니다.\n\n![이미지](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_2.png)\n\n\n\n서버 측 스크래핑을 위해 개발자들은 효율성과 속도 때문에 Node.js를 자주 사용합니다. Playwright와 같은 라이브러리는 무해한 브라우저를 제어할 수 있어 실제 사용자가 웹 페이지를 탐색하는 것처럼 상호 작용을 자동화할 수 있습니다. 이는 웹 사이트에 로그인하거나 사용자 상호 작용 시에만로드되는 동적 AJAX 콘텐츠를 캡처하는 것을 포함할 수 있습니다. 인기 있는 라이브러리 Cheerio는 HTML 분석을 간단하게 제공하여 jQuery와 유사하게 데이터를 선택하고 조작하기 쉽게합니다. 또한 서버 작업에 적합한 속도와 효율성이 추가되어 있습니다.\n\nPlaywright의 주요 기능 중 하나는 브라우저 콘텍스트의 사용으로, 별도 및 독립적인 브라우저 세션을 모의합니다. 이는 여러 페이지 또는 시나리오를 동시에 처리할 수 있기 때문에 대용량 데이터 집합을 스크래핑하거나 여러 웹 페이지를 동시에 모니터링하는 데 적합합니다. 이러한 브라우저 콘텍스트를 다양한 네트워크 조건이나 장치와 일치하도록 사용자 정의함으로써, 안티 봇 조치를 우회하고 정확한 데이터를 수집할 수 있습니다.\n\nPlaywright는 현대 웹 기술의 복잡성을 탐색하는 데 특히 뛰어납니다. 이러한 기술들은 클라이언트 측 렌더링을 위해 JavaScript에 매우 의존하기 때문입니다. Playwright는 실제 사용자가 콘텐츠와 상호 작용하는 방식을 복제하기 위해 전체 브라우저 세션을 시작하여 데이터가 완전히로드 될 때까지 스크래핑 작업을 수행합니다. 이 기능은 전통적인 스크래핑 방법으로 종종 놓치는 동적 콘텐츠를 정확하게 캡처하기 위한 필수적인 요소입니다.\n\n뿐만 아니라, JavaScript 웹 스크래핑 도구는 일정 간격으로 데이터 수집을 자동화하거나 특정 트리거에 응답하여 대량의 데이터를 효율적으로 처리할 수 있습니다. 캡처된 데이터는 JSON 또는 CSV와 같은 다양한 형식으로 내보낼 수 있으며, 데이터베이스 및 분석 파이프라인에 직접 공급하여 데이터 주도 애플리케이션과 프로세스에 쉽게 통합할 수 있습니다.\n\n\n\n자동화는 Playwright가 빛나는 또 다른 영역입니다. Node.js를 기반으로 한 이 프레임워크는 자동화된 스크레이핑 작업을 정기적으로 예약하거나 특정 이벤트에 의해 트리거할 수 있도록 가능하게 합니다. 이 수준의 자동화는 데이터셋을 최신 상태로 유지하고 수동 개입을 줄여 비즈니스 및 연구자들 모두에게 데이터 수집을 간소화합니다.\n\n# 6. HTML — HTML이란 무엇인가요?\n\n웹 스크레이핑에서 HTML은 중요합니다. 데이터가 추출되는 웹 페이지의 구조를 형성하기 때문입니다. 각 웹 페이지의 HTML 코드는 콘텐츠의 구조와 조직을 나타내며, 스크레이퍼가 특정 데이터 포인트를 탐색하고 찾는 데 도움을 줍니다. HTML 프레임워크에는 `div`, `a`, `table`과 같이 다양한 태그가 있으며, 각각이 단락, 링크, 이미지 및 테이블과 같은 다른 구성 요소를 나타냅니다.\n\nHTML의 계층 구조는 스크레이퍼가 콘텐츠가 어떻게 구성되어 있는지 이해하는 데 도움을 줍니다. 태그에는 id 및 class와 같은 속성이 포함되어 있으며, 이는 요소에 대한 고유한 식별자로 작용하여 스크레이퍼가 특정 정보를 빨리 찾을 수 있게 합니다. 예를 들어, 스크레이퍼가 특정 클래스 속성이 있는 'table'을 찾아 테이블 데이터를 추출하거나 고유한 id를 가진 'div' 내의 링크를 대상으로 할 수 있습니다.\n\n\n\n특별한 스크레이핑 도구와 라이브러리를 사용하여 HTML을 파싱하면 개발자는 스크레이퍼가 필요로 하는 정확한 태그 또는 패턴을 찾도록 지시할 수 있습니다. 예를 들어, 전자 상거래 사이트에서 제품 리뷰를 수집한다면, 스크레이퍼는 각 리뷰를 둘러싼 HTML 태그와 속성을 식별하며 사용자 평가, 댓글 및 제품 이름을 추출할 것입니다.\n\nJavaScript를 사용하여 콘텐츠를 비동기적으로 로드하는 동적 웹 페이지는 도전을 제기할 수 있습니다. 그러나 브라우저 자동화 도구를 갖춘 스크레이퍼는 실제 브라우징 세션을 시뮬레이트하여 원하는 데이터를 추출하기 전에 페이지가 완전히 렌더링되도록 할 수 있습니다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>간단한 HTML 예제</title>\n</head>\n<body>\n    <h1>안녕, 세상아!</h1>\n    <p>기본 HTML 페이지에 오신 것을 환영합니다.</p>\n    <a href=\"https://www.example.com\">예제 방문하기</a>\n</body>\n</html>\n```\n\n# 설명:\n\n\n\n- `!DOCTYPE html`: 이 선언은 직접적으로 웹 스크래핑에 사용되지는 않지만 HTML5 표준을 기대한다는 것을 파서에 알려줍니다.\n- `html lang=\"en\"`: 페이지의 루트 요소로, 언어를 영어로 지정합니다. 언어 속성(lang)은 직접적으로 대상이 되지 않을 수 있지만, 언어 특정 사항에 기반한 조건부 스크래핑에 유용할 수 있습니다.\n- `head`:\n\n- `meta charset=\"UTF-8\"`: 이 태그는 문자 인코딩을 UTF-8로 설정합니다. 텍스트를 올바르게 해석하는 데 중요하며, 특히 영어가 아닌 콘텐츠를 스크래핑할 때 인코딩 문제를 피하기 위해 중요합니다.\n- `title`Simple HTML Example`/title`: 문서의 제목은 웹 스크래핑의 흔한 대상입니다. 페이지의 내용을 빨리 이해하거나 검색 결과 사이에서 페이지를 분류하는 데 자주 사용됩니다.\n\n4. `body`:\n\n- `h1`Hello, World!`/h1`: 제목은 스크래핑의 주요 대상이며, 주로 중요 정보나 요약을 포함합니다. 이 h1은 주제를 식별하는 데 사용되거나 웹 사이트를 통해 페이지 구조를 이해하는 데이터 세트의 일부로 사용될 수 있습니다.\n- `p`Welcome to a basic HTML page.`/p`: 단락 태그는 페이지의 본문 텍스트를 주로 담고 있습니다. 이 데이터를 스크래핑하여 설명, 세부 사항 또는 관련 텍스트 콘텐츠를 추출하는 데 유용할 수 있습니다.\n- `a href=\"https://www.example.com\"`Visit Example`/a`: 하이퍼링크는 스크래핑 중에 웹 탐색에 중요합니다. href 속성은 URL을 제공하여 링크를 따르거나 리소스를 수집하거나 연결된 페이지를 스크래핑하는 데 사용할 수 있습니다. 이는 재귀적 기술을 사용하여 연결된 페이지 전체에서 데이터를 검색하는 깊은 웹 스크래핑에 필수적입니다.\n\n\n\n# 7. HTTP - HTTP 개념\n\nHTTP 또는 HyperText 전송 프로토콜은 월드 와이드 웹에서 데이터 통신의 기본 프로토콜로, 웹 브라우저를 서버와 연결합니다. 웹 스크래핑에 있어서 HTTP의 복잡성을 이해하는 것은 웹 사이트에서 데이터에 효과적으로 접근하고 검색하는 데 중요합니다.\n\n![이미지](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_3.png)\n\n웹 스크래핑과 관련된 HTTP의 기본적인 측면:\n\n\n\n요청 및 응답: HTTP의 핵심은 요청과 응답 프로세스에 있습니다. 웹 스크래퍼는 브라우저 요청을 시뮬레이트하여 웹 페이지를 검색합니다. 각 요청은 GET과 같은 다양한 방법을 활용할 수 있습니다. 페이지 내용을 가져 오는 데 일반적으로 사용되는 방법과 POST, 종종 폼 데이터를 제출하거나 사이트에 로그인하는 데 사용되는 방법을 사용할 수 있습니다.\n\n헤더: HTTP 요청 및 응답의 헤더는 중요한 메타 데이터를 전달합니다. 웹 스크래핑을 위해 User-Agent와 같은 헤더는 스크래퍼를 합법적인 브라우저로 위장시켜 기본적인 안티-스크래핑 검사를 우회하는 데 도움이 됩니다. 헤더 내의 쿠키는 세션 상태를 관리하여 스크래퍼가 여러 페이지를 걸쳐 로그인 상태를 유지할 수 있도록합니다.\n\n상태 코드: 이 코드는 클라이언트에게 요청 상태에 대해 알려줍니다. 예를 들어, 200 상태 코드는 성공을 나타내고 404는 요청한 리소스가 없음을 나타냅니다. 이러한 코드를 이해하면 스크래퍼가 오류와 리디렉션을 효과적으로 처리 할 수 있습니다.\n\n요청 제한: 많은 웹 사이트는 액세스 빈도를 제어하기 위해 요청 제한을 시행합니다. 웹 스크래퍼는 이러한 제한을 트리거하지 않도록 요청 속도를 관리해야하며, 그렇지 않으면 차단된 액세스 또는 법적 문제가 발생할 수 있습니다.\n\n\n\n안녕하세요! 아래는 Markdown 형식으로 새롭게 구성된 내용입니다:\n\n**보안 통신:** HTTP 요청은 HTTPS로 보안될 수 있습니다. 이를 통해 브라우저와 서버 간에 교환되는 데이터가 암호화됩니다. 이는 민감한 데이터를 수집할 때 개인 정보 보호와 보안을 유지하는 데 매우 중요합니다.\n\n**APIs:** API를 통해 데이터를 제공하는 웹사이트는 HTML 파싱보다 데이터에 접근하는 구조화된 방법을 제공하며 종종 더 신뢰할 수 있습니다. API는 일반적으로 JSON 또는 XML과 같은 형식으로 데이터를 응답하며, 이는 스크래퍼가 처리하기에 편리합니다.\n\n**8. PlayWright Javascript를 사용하여 가격 및 제품 정보 스크랩 합니다**\n\nJavaScript에서 Playwright를 사용하여 웹 스크래핑 스크립트를 생성하기 전에 필요한 개발 환경을 설정하는 것이 중요합니다. 이 준비 단계를 통해 효율적이고 효과적인 웹 스크래핑에 필요한 모든 도구와 라이브러리가 마련됩니다.\n\n\n\n개발 환경 설정하기\n\n1. Visual Studio Code (VS Code) 설치:\n\n- Visual Studio Code은 Microsoft에서 제공하는 가벼우면서도 강력한 소스 코드 편집기입니다. JavaScript와 Node.js를 기본으로 지원하며, 디버깅, 지능형 코드 완성 (IntelliSense), 쉬운 탐색을 포함한 다양한 확장 기능을 제공합니다.\n- 먼저, 공식 Visual Studio Code 웹사이트에서 Visual Studio Code를 다운로드하고 설치하세요. 운영 체제 (Windows, macOS 또는 Linux)에 맞는 설치 지침을 따릅니다.\n\n2. Node.js와 npm 설치:\n\n\n\n- Node.js는 서버 측에서 JavaScript를 실행할 수 있게 해주는 런타임 환경이에요. Node.js에는 npm(node package manager)이 포함되어 있어서 Node.js 애플리케이션에 대한 의존성을 관리하는 데 도움을 줘.\n- 공식 Node.js 웹사이트에서 Node.js를 다운로드하세요. 기본 옵션으로 Node.js를 설치하면 npm도 함께 설치되어 Playwright를 포함한 다양한 라이브러리를 다룰 준비가 돼.\n- 설치 후에는 터미널이나 명령 프롬프트를 열어 node -v와 npm -v를 입력하면 시스템에 설치된 Node.js와 npm의 현재 버전을 확인할 수 있어.\n\n3. Node.js 프로젝트 설정하기:\n\n- Visual Studio Code를 열고 새 프로젝트 폴더를 만들거나 기존 폴더로 이동해.\n- VS Code에서 터미널을 열고(또는 운영 체제 터미널을 사용해) 프로젝트 디렉토리로 이동한 후 npm init을 실행하여 새 Node.js 프로젝트를 초기화해. 이 명령은 프로젝트 디렉토리에 package.json 파일을 생성하며 모든 의존성과 프로젝트 메타데이터를 추적할 거야.\n\n4. Playwright 설치하기:\n\n\n\n- Node.js 환경이 준비되었습니다. npm install playwright 명령어를 실행하여 Playwright를 설치해보세요. 이 명령어는 Playwright와 의존성을 다운로드하고 이를 프로젝트의 node_modules 디렉토리에 추가합니다. 또한 package.json을 업데이트하여 Playwright를 의존성으로 포함시킵니다.\n- Playwright 설치에는 Chromium, Firefox 및 WebKit용 브라우저 이진 파일이 포함되어 있어 스크립트가 다양한 브라우징 환경을 시뮬레이트할 수 있습니다.\n\n```js\nconst playwright = require('playwright');\nconst fs = require('fs');\nconst path = require('path');\n```\n\n- const playwright = require(`playwright`);:\n\n- 이 코드는 Playwright 라이브러리를 현재 파일로 가져옵니다. Playwright는 웹 스크레이핑 및 테스팅을 포함한 브라우저 자동화를 가능하게 하는 인기 있는 도구입니다.\n- 이 import를 통해 다양한 브라우저(Chromium, Firefox, WebKit)에서 프로그래밍 방식으로 웹 페이지와 상호 작용하는 Playwright API를 사용할 수 있습니다.\n\n\n\n2. const fs = require(`fs`);:\n\n- 이는 Node.js의 fs (파일 시스템) 모듈을 가져와요. 이 모듈은 로컬 파일 시스템과 상호작용하기 위한 함수들을 제공해요.\n- 이를 통해 스크립트는 파일을 읽고 쓸 수 있어요. 이는 로깅, 데이터 저장, 또는 기존 파일 작업에 유용해요.\n\n3. const path = require(`path`);:\n\n- 이는 Node.js의 path 모듈을 가져와요. 이 모듈은 파일 경로를 일관적이고 크로스 플랫폼으로 다루는 데 도움이 돼요.\n- 파일 및 디렉토리 경로를 처리하는 유틸리티를 제공하며, 운영 체제에 관계없이 올바른 구문을 사용하도록 해줘요.\n\n\n\n함께 해보기:\n\n- 이러한 import를 사용하면 스크립트가 Playwright를 기반으로 한 웹 스크래핑이나 브라우저 자동화 프로젝트를 위한 기반을 설정합니다.\n- playwright는 브라우저를 제어하여 URL로 이동하거나 요소를 클릭하고 데이터를 캡처하는 등의 상호작용을 가능하게 합니다.\n- fs는 스크래핑 프로세스 중에 수집된 데이터를 저장하는 데 도움을 주며, JSON이나 CSV 파일로 저장하는 것도 가능합니다.\n- path는 파일 경로를 적절하게 관리하여 어떤 운영 체제에서도 효율적으로 데이터를 저장하거나 읽을 수 있도록 도와줍니다.\n\n예시 사용 사례:\n\n- Playwright를 사용하여 웹페이지에 이동하고 정보를 스크래핑합니다.\n- fs를 사용하여 수집한 데이터를 구조화된 형식으로 저장합니다.\n- path를 사용하여 출력 파일을 효과적으로 정리합니다.\n\n\n\n```js\n(async () => {\n  const browser = await playwright.chromium.launch();\n  const page = await browser.newPage();\n```\n\n- (async () =` '...')():\n\n- 이 구조는 즉시 호출되는 함수 표현식 (IIFE)으로, 코드가 정의된 즉시 실행되도록합니다.\n- async 키워드는 함수에 비동기 작업이 포함되어 있음을 나타내며, 함수 내부에서 await을 사용할 수 있도록 합니다.\n- 이 함수를 즉시 실행함으로써 비동기 작업을 깔끔하게 처리하고 전역 범위를 깔끔하게 유지할 수 있습니다\n\n2. const browser = await playwright.chromium.launch();:\n\n\n\n- 이 코드는 Playwright의 크로미움 엔진을 사용하여 브라우저 인스턴스를 초기화합니다.\n- playwright.chromium은 Playwright의 크로미움 브라우저 자동화 엔진을 가리킵니다. 비슷한 옵션으로는 firefox와 webkit이 있습니다.\n- launch()는 새로운 헤드리스(기본값) 브라우저 세션을 시작하는 비동기 메서드입니다.\n- await 키워드는 함수가 브라우저가 완전히 로드될 때까지 실행을 일시 중지하고, 그 후에 로드된 브라우저 인스턴스를 browser 변수에 할당합니다.\n\n3. const page = await browser.newPage();:\n\n- 이 코드는 시작된 브라우저 인스턴스 내에서 새 페이지(또는 탭)를 생성합니다.\n- 새 페이지는 독립적으로 작동하며, 한 페이지에서의 동작은 동일한 브라우저에서 열린 다른 페이지에 영향을 주지 않습니다.\n- await 키워드는 다시 한 번 새 페이지가 준비될 때까지 실행을 일시 중지하고, 이를 page 변수에 할당합니다.\n\n```js\n\n  await page.goto('https://www.unitedbike.com/bikes');\n```\n\n\n\n- await: 이 키워드는 프로미스가 해결될 때까지 함수 실행을 일시 중지합니다. 이 경우에는 페이지가 완전히로드될 때까지 기다린 후 다음 라인으로 진행합니다.\n- page.goto(url):\n- 'goto'는 Playwright가 제공하는 메소드로, 브라우저 페이지를 지정된 URL로 이동하도록 지시합니다.\n- 여기서 'url'은 방문할 웹 주소로, `https://www.unitedbike.com/bikes`로 지정되어 있습니다.\n- 이 라인이 실행되면 Playwright 페이지 인스턴스는 주어진 URL로 이동하여 실제 브라우저처럼 페이지를 완전히 렌더링하고 JavaScript 기반 동적 콘텐츠를 포함합니다.\n\n```js\n  const productInfoElements = await page.$$eval('.product-information', elements => elements.map(el => {\n    const caption = el.querySelector('.caption').textContent.trim();\n    const price = el.querySelector('.price').textContent.trim();\n    return `${caption},${price}`;\n```\n\n이 코드 스니펫은 Playwright 페이지 객체를 사용하여 특정 제품 정보를 추출하는 더 큰 웹 스크래핑 스크립트의 일부입니다. 각 부분의 설명을 보여드릴게요:\n\n- const productInfoElements = await page.$$eval(...):\n\n\n\n- const: 이 키워드는 페이지에서 추출된 데이터를 저장할 변수 productInfoElements를 선언합니다.\n- await: 이 함수는 작업이 완료될 때까지 실행을 일시 중지하여 데이터가 준비되면 변수에 할당됩니다.\n- page.$$eval:\n- $$eval은 페이지의 모든 일치하는 요소에 대해 함수를 평가하는 Playwright 메서드입니다.\n- 첫 번째 인수인 `.product-information`은 클래스가 .product-information인 모든 HTML 요소를 대상으로 하는 CSS 셀렉터입니다.\n- 두 번째 인수는 선택된 요소에 대해 실행할 함수이며, 이 함수는 해당 요소들을 매개변수 elements로 받습니다.\n\n2. elements.map(el => ` '...'):\n\n- 이 map 함수는 elements 배열의 각 HTML 요소를 반복하며 각각의 요소를 처리하여 필요한 정보를 추출합니다.\n\n3. const caption = el.querySelector(`.caption`).textContent.trim();:\n\n\n\n- 코드는 각 .product-information 요소 내에서 클래스가 .caption인 자식 요소를 검색합니다.\n- textContent는 해당 요소의 텍스트 콘텐츠를 가져오고, trim()은 앞뒤 공백을 제거합니다.\n- 결과는 caption 변수에 저장됩니다.\n\n4. const price = el.querySelector(`.price`).textContent.trim();:\n\n- 캡션과 유사하게, 이 줄은 클래스가 .price인 자식 요소를 검색합니다.\n- textContent는 .price 요소의 내부 텍스트를 추출하는데, 일반적으로 제품의 가격을 나타냅니다.\n- trim()은 추가로 공백이 포함되지 않도록 합니다.\n\n5. return $'caption',$'price';:\n\n\n\n- 각 반복은 캡션과 가격 값을 쉼표로 구분된 형식으로 반환하는 문자열을 생성합니다.\n\n```js\nconst outputFilePath = path.join(__dirname, 'product_information.csv');\n\nfs.writeFileSync(outputFilePath, productInfoElements.join('\\n'), 'utf8');\n\nconsole.log(`Data telah diekspor ke file: ${outputFilePath}`);\nawait browser.close();\n```\n\n- const outputFilePath=path.join(__dirname,`product_information.csv`);:\n\n- path.join:\n- join은 여러 경로 세그먼트를 하나의 일관된 경로 문자열로 결합하는 path 모듈의 메서드입니다.\n- 올바른 경로 구분자를 자동으로 적용하여 경로를 크로스 플랫폼으로 만듭니다(예: Windows의 백슬래시, Linux/macOS의 슬래시).\n- __dirname:\n- 이 특별한 변수는 현재 실행 중인 스크립트가 위치한 디렉토리의 절대 경로를 보유합니다.\n- `product_information.csv`:\n- 이것은 데이터가 저장될 CSV 파일의 이름입니다.\n- path.join을 사용하면 실행 중인 스크립트의 디렉토리 내에 product_information.csv라는 이름의 파일의 전체 경로가 생성됩니다.\n\n\n\n2. fs.writeFileSync(outputFilePath, productInfoElements.join(`\\n`), `utf8`);:\n\nfs.writeFileSync:\n\n- fs 모듈의 이 동기 방식 메서드는 지정된 파일에 데이터를 직접 작성합니다.\n- 세 가지 주요 인수를 취합니다.\n\n- productInfoElements는 문자열의 배열(아마 제품 데이터를 포함한 것으로 예상)이어야 합니다.\n- join(`\\n`)은 이러한 문자열을 새 줄 문자(\\n)로 구분하여 하나의 문자열로 연결하므로 CSV 데이터로 작성하기에 적합합니다.\n\n\n\n- UTF-8로 지정된 인코딩 형식을 사용하여 파일에 올바른 텍스트 표현을 보장합니다.\n\n3. console.log('데이터가 파일로 내보내졌습니다: $'outputFilePath');:\n\n- 생성된 파일의 경로를 제공하고 데이터가 내보내졌음을 확인하는 콘솔 메시지를 출력합니다.\n\n4. await browser.close();:\n\n\n\n- 이전에 스크립트를 시작할 때 열었던 Playwright 브라우저 인스턴스를 종료합니다.\n- 시스템 자원을 해제하고 모든 웹 스크래핑 작업이 완료된 후 깔끔하게 종료됩니다.\n\n이제 터미널에서 다음 코드를 실행하세요:\n\n```js\n$ node scrap.js\n```\n\n출력 결과는 다음과 같을 것입니다.\n\n\n| 모델명          | 가격                              |\n|----------------|-------------------------------|\n| VITESSA 2.00   | Rp 9,820,000, Rp 9,820,000   |\n| VITESSA 1.00   | Rp 7,960,000, Rp 7,960,000   |\n| STYGMA LITE   | Rp 14,060,000, Rp 14,060,000 |\n| STYGMA        | Rp 18,640,000, Rp 18,640,000 |\n| STERLING R2 DISC | Rp 33,260,000, Rp 33,260,000 |\n| STERLING R1 DISC | Rp 26,200,000, Rp 26,200,000 |\n| STERLING PRO DISC | Rp 75,000,000, Rp 75,000,000 |\n| OXYDE PRO     | Rp 67,725,000, Rp 67,725,000 |\n| OXYDE ONE     | Rp 20,370,000, Rp 20,370,000 |\n| KYROSS 2.1    | Rp 18,140,000, Rp 18,140,000 |\n| KYROSS 2.00+  | Rp 17,630,000, Rp 17,630,000 |\n| KYROSS 1.1    | Rp 12,850,000, Rp 12,850,000 |\n| KYROSS 1.00   | Rp 12,850,000, Rp 12,850,000 |\n| GAVRIIL       | Rp 16,620,000, Rp 16,620,000 |\n| E-GAVRIIL     | Rp 48,280,000, Rp 48,280,000 |\n| EPSILON T6    | Rp 45,350,000, Rp 45,350,000 |\n\n여기에 전체 코드가 있습니다:\n\n```js\nconst playwright = require('playwright');\nconst fs = require('fs');\nconst path = require('path');\n\n(async () => {\n  const browser = await playwright.chromium.launch();\n  const page = await browser.newPage();\n\n  await page.goto('https://www.unitedbike.com/bikes');\n\n  const productInfoElements = await page.$$eval('.product-information', elements => elements.map(el => {\n    const caption = el.querySelector('.caption').textContent.trim();\n    const price = el.querySelector('.price').textContent.trim();\n    return `${caption},${price}`;\n  }));\n\n  const outputFilePath = path.join(__dirname, 'product_information.csv');\n\n  fs.writeFileSync(outputFilePath, productInfoElements.join('\\n'), 'utf8');\n\n  console.log(`데이터가 파일로 내보내졌습니다: ${outputFilePath}`);\n  await browser.close();\n})();\n```\n\n아마도 여기까지 JavaScript 플레이 라이팅 소개의 끝입니다. 웹 스크래핑과 playwright에 대해 더 깊이 파고들고 싶다면 이 웹 사이트를 방문해보세요.\n```\n\n\n\n감사합니다! :3","ogImage":{"url":"/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png"},"coverImage":"/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png","tag":["Tech"],"readingTime":17},{"title":"Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기","description":"","date":"2024-05-12 23:37","slug":"2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia","content":"\n\n![이미지](/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png)\n\nVue 2에서 Vue 3로 이주하면서 Pinia가 이제 Vue 3를 위한 권장 스토어 플러그인이 되었고 Vuex가 아니게 되어 전환이 필요했습니다. 우리 아키텍처와 팀 전체가 Vuex와 작업하는 데 익숙했기 때문에 모든 스토어를 하나의 전역 변수 $store로 액세스하고 모든 곳에서 손쉽게 액세스할 수 있을 때를 좋아합니다!\n\n그래서 우리는 Pinia에서 부족해 보이는 3가지 핵심 기능을 지원하기 위해 일부 사항을 수정했습니다.\n\n- 우리 아직까지 사용 중인 this.$store를 통해 스토어에 액세스하기\n- 중첩 구조의 스토어 보유\n- 액션 내에서 Vue Router에 액세스하기\n\n\n\n# 기본 설정\n\n우리는 src/stores 안에 비슷한 디렉토리 구조를 가진 모든 스토어를 생성했습니다.\n\n```javascript\n- src\n  -> store\n     -> auth\n        -> getters.js\n        -> index.js\n        -> state.js\n     -> index.js\n     -> state.js\n```\n\n주요 index.js는 중첩과 모든 것을 포함한 완전한 스토어의 진입점 역할을 하며, 중첩이 어떻게 작동하는지 등에 대한 설명은 다음 단계에서 설명하겠습니다.\n\n\n\n```js\n// src/store/index.js\nimport state from \"./state.js\"\nimport authStore from \"./auth\"\n\nexport const useStore = defineStore('core', {  \n  state: () => state,\n  actions: {\n    setStores() {\n      this.auth = authStore()\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/state.js\nexport default {   \n    auth: null,\n    version: \"1.0.0\",\n}\n```\n\n```js\n// src/store/auth/index.js\nimport state from \"./state.js\"\nimport getters from \"./getters.js\"\n\nexport const useStore = defineStore('auth', {  \n  state: () => state,\n  getters,\n  actions: {\n    updateUserToken (token) {\n      this.token = token\n      localStorage.setItem('token', token)\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/auth/state.js\nexport default {\n  token: null\n}\n```\n\n\n\n```js\n// src/store/auth/getters.js\n\nexport default {}\n```\n\n# 1. Pinia에서 스토어 중첩하기\n\n기본적으로 Pinia는 필요할 때 스토어를 직접 가져와서 사용하는 것이지만, 우리가 원하는 것은 그게 아닙니다. Vuex에서 했던 것처럼 쉽게 접근하고 싶습니다. 그래서 다음과 같이 했습니다.\n\n메인 스토어에 스토어 이름(예: auth)으로 새로운 상태 변수를 만듭니다.\n\n\n\n```js\n// src/store/state.js\nexport default {\n  auth: null\n}\n```\n\n이 변수를 사용하려는 Pinia 스토어에 초기화하고 설정하세요. 예를 들어, authStore 를 사용하시려면 주요 스토어의 액션에 추가하여 필요한 모든 스토어를 초기화할 수 있습니다. 예를 들어, setStores()에 다음을 추가하세요.\n\n```js\n// src/store/index.js\n\n...\nimport authStore from \"./auth\"\n...\n\nexport const useStore = defineStore('core', {  \n  state: () => state,\n  actions: {\n    setStores() {\n      this.auth = authStore() // 액션 내에서 스토어를 초기화합니다.\n    },\n    ... // 다른 메서드\n  }\n})\n```\n\n주요 스토어를 초기화한 후에 이 액션을 호출하세요.```\n\n\n\n```js\n// main.js\n...\nimport { createPinia } from 'pinia'\n...\nimport store from \"@/store\"\n...\napp.use(createPinia()) // Pinia 생성\nexport const $store = store() // 메인 스토어 초기화\n$store.setStores() // 모든 중첩 스토어 초기화하는 액션 호출\n```\n\n그게 다야! 이제 모든 스토어에 메인 스토어에서 직접 액세스할 수 있습니다. 다음은 예시입니다 (Options API),\n\n```js\n<script>\nimport { $store } from \"@/main.js\"\n\nexport default {\n    mounted() {\n       console.log($store.auth.token) // auth 상태에 액세스\n       console.log($store.auth.setToken(\"12345\")) // auth 액션 호출\n       console.log($store.someState) // 메인 스토어 상태에 액세스\n    }\n}\n\n</script>\n```\n\n# 2. 핀니아 스토어를 전역적으로 접근 가능하게 만들기```\n\n\n\n이제 한 변수를 통해 중첩된 상점에 접근할 수 있게 되었으니, 이제 그것을 컴포넌트 내에서 직접 액세스할 수 있도록 만들어보겠습니다. 그렇게 하려면 vue의 Global Properties를 사용하여 매핑해야 합니다. 다음과 같이 해보세요.\n\n- main.js에서 메인 상점을 초기화하십시오.\n- $store라는 전역 속성을 설정하고 해당 상점을 할당하십시오.\n- 즐기세요!\n\n```js\n// main.js\n\n...\nimport { createPinia } from 'pinia'\n...\nimport store from \"@/store\"\n...\napp.use(createPinia()) // Pinia 생성\n\nexport const $store = store() // 주 상점 초기화\napp.config.globalProperties.$store = $store // 상점을 전역적으로 액세스 가능하게 만듦\napp.config.globalProperties.$store.setStores() // 모든 중첩된 상점을 초기화하는 작업 호출\n```\n\n이것으로 끝났습니다! 이제 옵션 API를 사용하는 컴포넌트 내에서 다음과 같이 액세스할 수 있습니다:\n\n\n\n```js\n<script>\nexport default {\n    mounted() {\n       console.log(this.$store.auth.token) // \"auth\" 상태에 접근하기\n       console.log(this.$store.auth.setToken(\"12345\")) // \"auth\" 액션 호출하기\n       console.log(this.$store.someState) // 메인 상점의 상태에 접근하기\n    },\n    watch: {\n        '$store.auth.token'() { console.log(\"변경 발생\") } // 워치하여 변경 감지하기\n    } \n}\n\n</script>\n```\n\n# 3. 핀이아 액션 내부에서 Vue Router에 액세스하기\n\n우리는 상점에서 라우터 인스턴스를 직접 가져오고 사용하려고 시도했지만, 올바르지 않은 것처럼 보였습니다. 그때 우리는 특정 속성을 설정할 수 있는 방법을 찾았고 이렇게 설정할 수 있습니다.\n\n```js\n// main.js\n\n...\nimport router from '@/router'\n...\nimport { createPinia } from 'pinia'\n\nlet pinia = createPinia()\npinia.use({store} => {store.router = router}) // 여기서 라우터를 설정하여 상점 내에서 접근할 수 있도록 하기\napp.use(pinia)\n\n...\n```\n\n\n\n이렇게 하면 우리는 스토어 내에서 언제든지 라우터 인스턴스에 액세스할 수 있어요.\n\n```js\n// srcs/store/index.js\n\n...\nimport authStore from \"./auth\"\n...\n\nexport const useStore = defineStore('core', {  \n  state: () => state,\n  actions: {\n    logRoute() {\n       console.log(this.router) // Router Instance\n       console.log(this.router.currentRoute) // 현재 라우트 가져오기 (this.$route)\n    }\n    ... // 다른 메서드\n  }\n})\n```\n\n그리고 이렇게 함으로써 우리는 세 가지 고통을 해결했어요! 세 가지가 모두 구현된 완전한 스크립트는 다음과 같아요.\n\n```js\n디렉토리 구조\n- src\n  -> store\n     -> auth\n        -> getters.js\n        -> index.js\n        -> state.js\n     -> index.js\n     -> state.js\n  -> main.js\n  -> router\n     -> index.js\n```\n\n\n\n```js\n// src/store/index.js\n\nimport state from \"./state.js\"\nimport authStore from \"./auth\"\n\nexport const useStore = defineStore('core', {  \n  state: () => state,\n  actions: {\n    setStores() {\n      this.auth = authStore()\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/state.js\nexport default {   \n    auth: null,\n    version: \"1.0.0\",\n}\n```\n\n```js\n// src/store/auth/index.js\n\nimport state from \"./state.js\"\nimport getters from \"./getters.js\"\n\nexport const useStore = defineStore('auth', {  \n  state: () => state,\n  getters,\n  actions: {\n    updateUserToken (token) {\n      this.token = token\n      localStorage.setItem('token', token)\n    }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/auth/state.js\n\nexport default {\n  token: null\n}\n```\n\n\n\n```js \n// src/store/auth/getters.js\n\nexport default {}\n```\n\n```js\n// main.js\n...\nimport router from '@/router'\n...\nimport { createPinia } from 'pinia'\n\nlet pinia = createPinia()\npinia.use({store} => {store.router = router}) // 여기에 router를 설정하여 store 내부에서 접근할 수 있게 함\napp.use(pinia)\n...\n\nexport const $store = store() // 주요 Store 초기화\napp.config.globalProperties.$store = $store // Store를 전역적으로 접근 가능하게 함\napp.config.globalProperties.$store.setStores() // 모든 중첩 Store를 초기화하는 작업 호출\n```\n\n여기까지입니다! 같은 결과를 달성할 수 있는 다른 방법을 발견하면 알려주시기 바랍니다!","ogImage":{"url":"/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png"},"coverImage":"/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png","tag":["Tech"],"readingTime":7}],"page":"69","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}