{"pageProps":{"posts":[{"title":"Nodejs를 활용한 마이크로서비스 만드는 방법","description":"","date":"2024-05-27 18:27","slug":"2024-05-27-LeveragingMicroserviceswithNodejs","content":"\n\n## 궁극적인 확장성과 민첩성의 해제\n\n마이크로서비스는 거대한 앱을 독립적인 서비스로 분할합니다. Node.js와 함께 사용하면 다음과 같은 이점을 얻을 수 있습니다:\n\n- 개별 서비스의 확장\n- 각 서비스에 최적의 기술 스택 사용\n- 내구성을 위해 장애 격리\n- 병렬 개발을 통한 빠른 전달\n- 쉬운 유지보수 및 업그레이드\n\n## 소개\n\n<div class=\"content-ad\"></div>\n\n이른바 빠르게 변화하는 디지털 세상에서는 기업들이 시장 상황에 신속히 대응하고 대규모 트래픽 증가를 처리하며 새로운 기능을 매끄럽게 통합할 수 있는 애플리케이션을 요구합니다. 마이크로서비스는 개발자들이 이러한 유연하고 확장 가능한 시스템을 구축할 수 있도록 함께 부상한 혁명적인 아키텍처 패러다임입니다. Node.js의 효율성과 성능과 결합되면, 마이크로서비스는 새로운 수준의 잠재력을 발휘합니다. 이 블로그 포스트는 마이크로서비스의 기본 원칙, 혁신적인 이점 및 Node.js에서의 구현을 위한 모베스트 프랙티스를 안내해 드릴 것입니다.\n\n## 마이크로서비스란?\n\n전통적인 단일체 응용 프로그램을 거대하고 연결된 구조로 상상해보십시오. 여기에서 각 구성 요소는 꽉 결합되어 있고 서로 의존적입니다. 애플리케이션의 일부를 변경하거나 특정 부분을 확장하는 것은 어려운 일이 됩니다. 심지어 미세한 조정이라도 전체 시스템 전반에 파급 효과를 일으킬 수 있습니다. 마이크로서비스는 애플리케이션을 더 작고 독립적인 서비스로 분해하여 각각이 특정 비즈니스 기능을 담당하는 혁신적인 방식을 제시합니다.\n\n모든 고객을 위해 특정 중앙 주방에서 서비스되는 거대한 레스토랑을 상상해보십시오. 마이크로서비스 아키텍처에서는 레스토랑이 각각이 특정 요리나 음식에 전념한 여러 전문화된 주방을 가지고 있습니다. 이탈리아 주방은 모든 파스타와 피자 주문을 처리하고, 스시 주방은 신선한 초밥 롤을 준비하는 데만 전념합니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-27-LeveragingMicroserviceswithNodejs_0.png)\n\n이 모듈식 접근 방식은 효율적인 자원 할당, 빠른 서비스 및 쉬운 유지 보수를 가능하게 합니다. 각 주방이 독립적으로 작동하고 수요에 따라 확장할 수 있기 때문입니다.\n\n## 마이크로서비스의 변화를 가져다주는 혜택들\n\n- 비교할 수 없는 확장성: 마이크로서비스를 사용하면 수요에 따라 개별 서비스를 독립적으로 확장할 수 있습니다. 하나의 서비스에 트래픽이 급증하는 경우, 해당 서비스에 더 많은 자원을 할당할 수 있습니다. 예를 들어 전자 상거래 애플리케이션에서 대규모 할인 행사 중 주문 처리 서비스가 많은 주문을 받을 수 있습니다. 마이크로서비스를 사용하면 개별 서비스를 효율적으로 확장하여 늘어난 부하를 처리할 수 있으며, 원활한 운영과 최적의 성능을 보장하면서 비용을 절감할 수 있습니다.\n- 유연성과 기술 다양성: 각 서비스는 가장 적합한 기술 스택을 사용하여 개발할 수 있으므로 다른 언어, 프레임워크 및 데이터베이스의 장점을 활용할 수 있습니다. 예를 들어 고성능 API 서비스에 Node.js를 사용하고, 기계 학습 서비스에 Python을 사용하고, 유연한 데이터 저장소가 필요한 서비스에는 NoSQL 데이터베이스를 사용할 수 있습니다. 적절한 도구를 선택할 수 있는 이 자유는 개발자가 고품질 맞춤형 솔루션을 제공할 수 있도록 도와줍니다.\n- 개선된 오류 격리 및 복원력: 단일 지점의 장애가 전체 시스템을 다운시킬 수 있는 모놀리식 애플리케이션과 달리, 마이크로서비스를 사용하면 서비스 하나가 실패해도 전체 애플리케이션에 미치지 않습니다. 이 격리는 전체 시스템의 건강과 복원력을 유지하는 데 도움이 됩니다. 예를 들어 결제 처리 서비스에 문제가 발생하는 상황을 상상해보세요. 마이크로서비스를 사용하면 고객은 여전히 제품 카탈로그를 찾아보고 주문을 할 수 있으며, 결제 서비스는 별도로 처리됩니다.\n- 빠른 시장 진입: 마이크로서비스를 통해 팀이 각기 다른 서비스에 동시에 작업할 수 있어 개발 주기를 단축하고 빠른 릴리스를 가능하게 합니다. 예를 들어 한 팀은 케이터링 서비스에 대한 새로운 기능을 개발하고, 다른 팀은 제품 카탈로그 서비스를 개선함으로써 병렬 개발이 가능하며, 새로운 기능을 최종 사용자에게 빠르게 제공할 수 있습니다.\n- 쉬운 유지 보수 및 업그레이드: 작고 모듈식 코드베이스를 사용하면 개별 서비스의 유지 보수 및 업그레이드가 훨씬 쉬워집니다. 프레임워크나 언어의 새 버전으로 서비스를 리팩토링하거나 이주할 수 있으며 전체 애플리케이션을 방해하지 않고 진행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Node.js에서 마이크로서비스 구현하기\n\n마이크로서비스는 많은 장점을 제공하지만 효과적으로 구현하려면 신중한 고려와 모베스트 프랙티스 준수가 필요합니다. Node.js는 이벤트 기반, 논블로킹 I/O 모델과 가벼우며 효율적인 런타임으로, 마이크로서비스 구축에 탁월한 선택입니다. Node.js에서 마이크로서비스를 구현할 때 주의할 점 몇 가지를 살펴보겠습니다:\n\n- 서비스 디자인: 비즈니스 기능을 중심으로 서비스를 디자인하여 각 서비스가 단일 책임과 명확한 인터페이스를 갖도록 합니다. 이 관심사 분리 원칙은 모듈성, 테스트 가능성 및 유지보수성을 촉진합니다.\n- 통신: 마이크로서비스는 네트워크를 통해 서로 통신하며, 종종 HTTP/REST와 같은 가벼운 통신 프로토콜을 사용합니다. 비동기 통신 시나리오의 경우 RabbitMQ, Apache Kafka 또는 BullMq와 같은 메시지 브로커를 사용하여 서비스를 분리하고 이벤트 기반 아키텍처를 처리하는 것을 고려해보세요.\n- 배포: Docker와 같은 컨테이너화 기술은 마이크로서비스를 배포하는 데 필수적입니다. Docker 컨테이너는 각 서비스와 해당 종속성을 자체 포함된 단위로 패키징하여 서로 다른 환경에서 서비스를 배포하고 관리하기 쉽게 만듭니다.\n- 모니터링 및 로깅: 분산 시스템에서 여러 서비스가 실행되는 경우 전체 응용 프로그램의 건강 상태와 성능을 이해하기 위해 모니터링 및 로깅이 중요해집니다. Prometheus 및 Grafana 또는 Newrelic과 같은 모니터링 솔루션과 함께 Cloudwatch 로깅을 구현하여 생태계에 대한 더 많은 통찰력을 얻을 수 있습니다.\n- 보안: 서비스 수준에서 인증 및 권한 부여를 구현하여 서비스 간 안전한 통신을 보장합니다. npm 패키지를 사용하여 요청 제한, 요청 유효성 검사 및 액세스 제어와 같은 일반적인 보안 문제를 처리하세요.\n\n## 최상의 실천 방법\n\n<div class=\"content-ad\"></div>\n\n- 탈중앙화된 데이터 관리: 각 마이크로서비스는 자체 데이터베이스를 관리해야 하며, 단일 장애 지점을 피하고 서비스가 완전히 독립적이 될 수 있도록 해야 합니다. 이 \"서비스 당 데이터베이스\" 패턴은 데이터 격리와 확장성을 촉진합니다.\n- 버전 관리: API 버전 관리를 구현하여 기존 클라이언트에 영향을 주지 않고 변화와 업데이트를 처리할 수 있습니다. 이를 통해 역호환성을 유지하고 새로운 기능을 도입하거나 서비스를 리팩토링할 때 원활한 전환을 가능하게 합니다.\n- 자동화된 테스트: 각 서비스에는 단위, 통합 및 종단간 테스트를 포함한 포괄적인 자동화된 테스트 스위트가 있어야 합니다. 이는 개발 주기 초기에 문제를 발견하고 개별 서비스 및 전체 시스템의 신뢰성과 품질을 보장하는 데 도움이 됩니다.\n- 지속적 통합/지속적 배포 (CI/CD): CI/CD 파이프라인을 도입하여 테스트, 빌드 및 배포 프로세스를 자동화하고 일관된 신뢰할 수 있는 릴리스를 보장해야 합니다. 젠킨스, AWS 파이프라인과 같은 도구를 활용하여 이러한 프로세스를 간소화하고 빠른 이터레이션을 가능하게 할 수 있습니다.\n\n## 결론\n\n마이크로서비스는 응용 프로그램을 구축하고 확장하는 방식을 혁신적으로 바꿨으며, 우수한 유연성, 확장성 및 견고성을 제공합니다. 이러한 아키텍처 접근 방식이 Node.js의 효율성과 성능과 결합될 때, 이는 혁신과 민첩성에 새로운 차원을 열어줍니다.\n\n기본 개념, 이점 및 모범 사례를 이해하면 마이크로서비스의 잠재력을 활용하여 비즈니스 성공을 이끄는 견고하고 확장 가능하며 유지보수 가능한 응용 프로그램을 제공하는 데 잘 준비될 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-27-LeveragingMicroserviceswithNodejs_0.png"},"coverImage":"/assets/img/2024-05-27-LeveragingMicroserviceswithNodejs_0.png","tag":["Tech"],"readingTime":5},{"title":"모든 레벨의 개발자를 위한 필수 Nodejs 가이드","description":"","date":"2024-05-27 18:25","slug":"2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels","content":"\n\n![Node.js Guide](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_0.png)\n\n안녕하세요, Node.js 팬 여러분! 당신이 전문 개발자이건, JavaScript 백엔드에 막 입문한 사람이건, 이 블로그는 실제 Node.js 앱을 만들기에 완벽한 장소입니다.\n\n우리는 애플리케이션 아키텍처 및 코딩을 위한 권장 사항을 살펴보고, 앱을 성능적이고 안전하게 만들기 위한 몇 가지 추가 제안도 제공할 것입니다.\n\nNode.js 게임을 한 단계 업시키기 위해 준비하세요!\n\n<div class=\"content-ad\"></div>\n\n\n![image1](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_1.png)\n\n[Gmail](mailto:your.email@gmail.com) | [LinkedIn](https://www.linkedin.com/in/yourprofile)\n\n## Why These Practices Matter\n\n![image2](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n환영합니다!\n\nNode.js는 비동기 입출력(I/O)-바운드 작업(예: 데이터베이스 상호 작용 및 네트워크 요청과 유사)을 뛰어난 성능으로 수행합니다. 이는 논블로킹 I/O 모델과 이벤트 루프 덕분입니다.\n\n일반적인 멀티스레드 디자인과 대조적으로, Node.js는 병목 현상을 초래할 수 있는 여러 스레드 디자인과 달리 여러 요청을 동시에 처리하면서 성능이 떨어지지 않습니다.\n\n모듈화 디자인과 같은 특정 방법이 왜 Node.js에 유익한지 이해하는 것은 Node.js의 기능을 활용하는 데 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 애플리케이션 아키텍처 모범 사례\n\n![이미지](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_3.png)\n\n자, 이제 멋진 것을 만들어 봅시다! 다음은 염두에 둘 아키텍처적인 모범 사례입니다:\n\n## 모듈식 디자인\n\n<div class=\"content-ad\"></div>\n\n애플리케이션을 작은, 재사용 가능한 구성 요소로 나눠보세요.\n\n이렇게 하면 코드가 더 이해하기 쉽고 유지보수 및 테스트가 용이해집니다.\n\n작은, 집중된 부분이 서로 교차하여 복잡한 구조물을 만들어내는 레고 블록을 사용해보세요.\n\n모듈은 레고와 유사합니다. 각 모듈은 단일 작업을 수행하고 잘 정의된 기능을 가져야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이것을 통해 기능을 분리하고 응용 프로그램 전체에서 코드를 재사용할 수 있어요. 이렇게 함으로써 반복을 줄이고 유지 보수를 향상시킬 수 있어요.\n\n## 계층 구조\n\n프레젠테이션(앱의 인터페이스), 비즈니스 로직(핵심 기능) 및 데이터 액세스(데이터베이스와의 상호 작용)와 같은 계층을 사용하여 문제를 분리하세요.\n\n이렇게 하면 코드를 청소하고 복잡한 앱을 유지하기 쉽게 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n주방(비즈니스 로직)과 식당(프레젠테이션)을 분리하면 일을 원할하게 처리할 수 있어요.\n\nMVC(Model-View-Controller)와 마이크로서비스 같은 인기 있는 패턴을 여기에 적용할 수 있어요.\n\nMVC는 애플리케이션을 모델(Model), 데이터를 나타내는 뷰(View), 데이터 표시 방식을 제어하는 컨트롤러(Controller) 세 개의 층으로 나눠요. 사용자 입력을 받고 모델과 뷰를 적절하게 조정하는 역할을 하는 거죠.\n\n마이크로서비스는 API를 사용하여 상호 통신하는 작은 독립적인 서비스로 애플리케이션을 나누는 개념이에요.\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 변경하겠습니다.\n\n## Dependency Injection\n\n이 방법은 크고 복잡한 응용 프로그램에 가장 적합하며 확장성을 촉진합니다.\n\n이 멋진 용어는 의존성(예: 데이터베이스 또는 외부 서비스)를 코드에 하드코딩하는 대신 추가하는 것을 의미합니다.\n\n이렇게 하면 테스트가 개선되고 느슨하게 연결된 코드를 유지하므로 개별 구성 요소의 쉬운 대체가 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n의존성 주입을 사용하면 다른 데이터베이스로 쉽게 전환할 수 있어요.\n\nNode.js에서 의존성 주입을 구현하는 다양한 전략이 있지만, 일반적인 전략 중 하나는 의존성 주입 컨테이너를 사용하는 것입니다. 이 컨테이너는 의존성의 라이프사이클을 제어하고 필요할 때 코드에 주입합니다.\n\n## 이벤트 주도 아키텍처\n\n이벤트 이벤터와 메시지 큐를 사용하여 앱 내에서와 외부 서비스와의 비동기 통신을 제공하세요.\n\n<div class=\"content-ad\"></div>\n\n프로그램의 각 구성 요소가 효율적으로 이벤트에 응답하고 서로 대기하지 않고 작동할 수 있도록 합니다.\n\n알림 시스템과 유사하게, 각 구성 요소는 이벤트에 가입하고 발생할 때 대응 조치를 취할 수 있습니다.\n\n이벤트 주도 아키텍처는 실시간 애플리케이션 개발 및 대규모 프로세스 관리에 매우 유용합니다.\n\n메시지 큐를 사용하여 시스템에 일시적으로 장애가 있더라도 이벤트가 일관되게 전달됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 코드 수준의 최상의 실천 방법\n\n지금 우리가 견고한 아키텍처를 갖고 있으므로, 깨끗하고 효율적인 코드를 개발하는 데 중점을 둘 수 있습니다:\n\n## 깨끗한 코드와 가독성\n\n깨끗하고 간단하며 잘 서식이 지정된 코드를 목표로 해보세요.\n\n<div class=\"content-ad\"></div>\n\n린터, 포매터 및 스타일 가이드를 사용하여 일관성을 보장하세요. 잘 쓰인 레시피는 읽고 따르기 쉽습니다.\n\n명확한 변수와 함수 이름이 있는 잘 서식이 맞춰진 코드는 미래에 그것을 작업해야 할 수도 있는 다른 개발자들과 여러분 모두가 이해하기 쉽게 만들어 줍니다.\n\n린터와 포매터는 코드 표준을 유지하면서 프로세스를 자동화하는 데 도움이 될 수 있습니다.\n\n## 비동기 프로그래밍\n\n<div class=\"content-ad\"></div>\n\nPromises나 async/await을 사용하여 비동기 프로그래밍을 마스터하세요.\n\n이 작업을 통해 Node.js에서 I/O 작업을 이벤트 루프를 막지 않고 처리할 수 있습니다.\n\n이것을 공을 던지면서 생각해보세요: 여러 작업을 함께 완료할 수 있고 아무것도 떨어뜨리지 않을 수 있습니다! 비동기 작업에는 데이터베이스 호출, 네트워크 요청 및 파일 I/O가 포함됩니다.\n\nPromises와 async/await을 사용하면 이러한 작업의 비동기적인 성격을 처리하면서 코드를 깔끔하고 가독성 있게 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 오류 처리 및 로깅\n\n효과적인 오류 처리 구조 및 로깅 접근 방식을 구현하세요.\n\n이것은 애플리케이션 성능을 디버깅하고 모니터링하는 데 중요합니다.\n\n로그 및 오류 메시지는 앱의 문제를 경고하는 엔진 라이트 버전입니다.\n\n<div class=\"content-ad\"></div>\n\n적절한 오류 처리는 부드럽게 오류를 잡아내고, 디버깅을 위한 필수 정보를 문서화하며 사용자에게 유용한 오류 메시지를 제공하는 것을 의미합니다.\n\n# 코드 예제: 최상의 관행을 실천으로\n\n우리는 많은 것을 다루었지만, 이제 이러한 최상의 관행들이 코드에 어떻게 적용되는지 살펴봅시다. 기본 개념을 보여주는 몇 가지 실제 예제가 여기 있습니다:\n\n## 모듈화된 디자인:\n\n<div class=\"content-ad\"></div>\n\n```js\n// user.service.js\nfunction getUserById(id) {\n  // 데이터베이스에서 사용자 데이터를 가져오는 로직\n}\n\nfunction updateUser(user) {\n  // 데이터베이스에서 사용자 데이터를 업데이트하는 로직\n}\n\nmodule.exports = {\n  getUserById,\n  updateUser,\n};\n```\n\n위 코드는 사용자 데이터를 가져오고 업데이트하는 여러 방법을 제공하는 사용자 서비스 모듈입니다. 이는 재사용성을 향상시키고 코드를 보다 쉽게 읽고 유지보수할 수 있도록 만듭니다.\n\n## 의존성 주입(Dependency Injection):\n\n```js\n// database.js\nclass Database {\n  constructor(config) {\n    // config를 사용하여 데이터베이스에 연결하는 로직\n  }\n\n  getUserById(id) {\n    // 사용자를 위한 데이터베이스 쿼리 로직\n  }\n}\n\n// user.service.js (의존성 주입 사용)\nfunction __getUserById(database, id) {\n  // 데이터베이스 인스턴스를 사용하여 사용자 데이터를 가져오는 로직\n}\n\nconst userService = {\n  getUserById: __getUserById.bind(null, new Database(config)), // 데이터베이스 의존성 주입\n};\n\nmodule.exports = userService;\n```\n\n<div class=\"content-ad\"></div>\n\nuserService는 데이터베이스와 직접 상호 작용하지 않습니다. 대신, 의존성으로 데이터베이스 인스턴스를 수신합니다.\n\n이를 통해 더 쉬운 테스트가 가능해지고 서비스를 더 유연하게 만들 수 있습니다 - 핵심 로직을 수정하지 않고 데이터베이스 구현을 교체할 수 있습니다.\n\n# 성능 최적화 팁\n\n## 캐싱\n\n<div class=\"content-ad\"></div>\n\n데이터베이스 호출 및 API 요청 수를 줄이기 위해 캐싱 전략을 구현해보세요.\n\n자주 액세스되는 데이터의 성능을 크게 향상시킬 수 있습니다.\n\n잘 갖춘 식료품 저장실을 상상해보세요 — 재료가 필요할 때마다 식료품점에 가실 필요가 없습니다! Node.js에서 자주 사용되는 캐싱 전략에는 인메모리 캐싱과 브라우저 캐싱 메커니즘을 사용한 클라이언트 측 캐싱이 포함됩니다.\n\n## I/O 작업 최소화\n\n<div class=\"content-ad\"></div>\n\n애플리케이션이 수행하는 I/O 작업 횟수를 줄이세요.\n\n데이터베이스 호출, 파일 I/O 및 네트워크 요청이 여기에 포함됩니다.\n\n이들은 비동기적이지만, 너무 많은 호출은 여전히 이벤트 루프에 부담을 줄 수 있습니다.\n\n너무 많은 공을 토스하듯이 생각해보세요 — 추적하기 어려워집니다! I/O 작업을 최적화하면 이벤트 루프의 효율성을 유지하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 효율적인 이벤트 루프 활용\n\n이벤트 루프를 사용하는 방법에 유의하세요.\n\n콜백 내에서 긴 실행 시간이 소요되는 작업을 피하십시오. 해당 작업은 이벤트 루프를 차단하고 다른 요청이 처리되는 것을 방해할 수 있습니다.\n\n계산 집약적인 작업에는 워커 스레드와 같은 기술을 활용하십시오.\n\n<div class=\"content-ad\"></div>\n\n따로 할당된 어시스턴트가 있다면 좋겠죠. 이렇게 하면 주 이벤트 루프가 다른 요청을 처리할 수 있게 해줍니다.\n\n성능을 높이려면 프로파일링 도구를 사용하여 프로그램의 오류를 발견해 보세요.\n\n이 도구들은 코드가 대부분의 시간을 보내는 곳을 파악하고 개선할 위치를 찾는 데 도움이 될 것입니다.\n\n# 보안 팁\n\n<div class=\"content-ad\"></div>\n\n보안을 잊지 마세요! Node.js 어플리케이션은 많은 위협에 노출될 수 있으므로 전략을 세워보세요:\n\n- 알려진 보안 취약점을 해결하기 위해 주기적으로 종속성을 업데이트하세요.\n- SQL 인젝션 및 XSS와 같은 인젝션 위협에 대비하려면 사용자 입력을 살균하세요.\n- 민감한 데이터 접근을 제한하기 위해 강력한 인증 및 권한 부여 기술을 사용하세요.\n\nNode.js 보안에 대해 더 많이 배울 수 있는 온라인 자료가 여러 개 있습니다.\n\n이런 제안을 따르면 보통의 보안 위험을 줄이고 더 안전한 어플리케이션을 만들 수 있을 거예요.\n\n<div class=\"content-ad\"></div>\n\n# 확장성 전략\n\n프로젝트가 성장할수록 확장성은 중요한 요소입니다. 여기에 몇 가지 접근 방식이 있습니다:\n\n## 클러스터링\n\n노드 JS 어플리케이션을 여러 서버에 다른 인스턴스로 실행하여 작업 부하를 분산시킵니다. 이렇게 하면 보다 많은 동시 요청을 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n요리사 팀이 함께 일한다고 상상해보세요 — 그들은 더 적은 시간에 더 많은 식사를 준비할 수 있어요!\n\n## 부하 분산\n\n단일 서버에 과부하를 피하기 위해 들어오는 트래픽을 여러 응용 프로그램 인스턴스로 분산합니다.\n\n이는 교통 안내원과 유사하게 작동하여 요청을 가장 이용 가능한 서버로 라우팅하여 원활한 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 Node.js 앱을 확장하는 몇 가지 기본적인 방법 중 일부에 불과해요.\n\n선택하는 특정 방법은 귀하의 애플리케이션의 기능 및 트래픽 패턴에 의존합니다.\n\n## 마지막으로\n\n이 블로그에서 소개된 모범 사례를 따르면 사용자 베이스가 확대됨에 따라 계속 유지될 강력하고 확장 가능하며 안전한 Node.js 앱을 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n웹 개발의 다양한 측면에 대해 더 자세히 다룰 향후 블로그를 기대해 주세요!\n\n![image 1](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_4.png)\n\n![image 2](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_5.png)\n\n# 간단하게 설명하기 🚀\n\n<div class=\"content-ad\"></div>\n\n인 플레인 영어 커뮤니티에 참여해 주셔서 감사합니다! 떠나기 전에:\n\n- 작가를 클랩하고 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠와 거래하도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- 더 많은 콘텐츠: PlainEnglish.io","ogImage":{"url":"/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_0.png"},"coverImage":"/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_0.png","tag":["Tech"],"readingTime":8},{"title":"Routing으로 나만의 파일 경로 기반 라우터 만들기","description":"","date":"2024-05-27 18:24","slug":"2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter","content":"\n\n## 모든 현대 프레임워크에서 사용하는 기능, 왜 비밀로 유지해야합니까?\n\n![image](/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_0.png)\n\n대부분의 JavaScript 프레임워크가 채택하고 있는 한 가지 트렌드는 경로 기반 라우팅을 제공하는 것입니다. 이는 방문하려는 URL과 프로젝트 내의 특수 폴더 사이에 1:1 관계가 있다는 의미입니다. 이 특수 폴더에는 라우트 핸들러 함수들이 포함되어 있습니다.\n\n즉, http://`호스트`/users/list를 방문한다면 users/list.js 파일(또는 사용자의 선호에 따라 users/list/index.js 내부에 있을 수도 있음) 내에 핸들러 함수가 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 정말 멋진 기능이에요. Next, Fresh 또는 다른 프레임워크와 같이 당연하게 사용하는 기능 중 하나에요.\n\n하지만, 저는 당연한 것을 싫어해요. 그래서 이 기능이 어떻게 작동하는지 역공학을 시도해 보겠어요.\n\nExpress를 사용하여 경로 기반 라우팅의 자체 버전을 구현하는 방법을 살펴보겠어요.\n\n# 이 작업을 하는 이유?\n\n<div class=\"content-ad\"></div>\n\n거의 모든 현대 프레임워크에 깊게 자리한 기능을 명확히 설명하는 데 있어서 이것은 개발 경험을 향상시키는 매우 좋은 기능입니다. 이 형식은 라우트 핸들러를 설정하는 방법을 단순화하며 이전에 사용했던 단일 라우트 매핑 파일과 같은 하위 최적화 방법 대신 새로운 방식을 제공합니다.\n\n이전에는 모든 라우트와 해당 핸들러 파일을 포함하는 단일 라우트 매핑 파일을 사용하여 해결책을 찾았습니다. 이런 식으로:\n\n그것은 작은 앱과 몇 개의 라우트만 있는 경우 좋은 해결책이었습니다. 심지어 라우트 핸들러를 다른 위치에 저장할 수 있는 유연성을 가지고도 했습니다. 그러나 반면에 대규모 기업 애플리케이션을 작업 중이라면 이 파일 내에 수백 줄에 달하는 코드를 다뤄야 할 수도 있습니다. 아마도 짐작할 수 있겠지만, 그런 파일을 유지하는 것은 아무도 원치 않았고 그것에 버그를 추가하는 것은 너무 쉬웠습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 여기서 \"구성보다 규약\"을 사용하여 우리의 코드가 어떤 라우트를 처리하는지 정의하는 \"더 간단한\" 방법을 유지할 필요가 없게 되었어요. 이것은 또 다른 파일을 유지할 필요없이 코드의 어느 부분이 어떤 라우트를 처리하는지 정의하는 \"더 단순한 방법\"을 제공합니다. 이 부분을 유지하는 것이 승리라고 생각해요!\n\n저는 이러한 유형의 기능이 개발자 경험(DX)을 향상시키기 때문에 정말 좋아해요.\n\n물론, 이를 수행하는 것은 웹 프로젝트의 구조에 대해 많은 것을 결정할 수 있지만, 라우터를 직접 구축하는 경우에는 필요한 수정 사항을 정확히 필요한 대로 수행할 수도 있어요.\n\n그럼 이 구현이 어떻게 보이는지 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 우리만의 라우터 구현하기\n\n이 예제에서는 ExpressJS를 사용할 것입니다. 하지만 ExpressJS의 기본 라우터를 사용하는 것은 말이 안 되기 때문에 사용하지 않을 것입니다. 대신에 웹 서버를 생성하는 과정을 좀 더 간단하게 추상화해주니까, 이것이 주된 목적은 아니지만 여러분들이 일을 더 쉽게 처리할 수 있게 해줄 겁니다.\n\n우리가 만들고자 하는 라우터는 다음과 같은 구조를 다룰 수 있도록 하는 것이 목표입니다:\n\n![라우터 구조](/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_1.png)\n\n<div class=\"content-ad\"></div>\n\n라우트 폴더의 내용을 확인해보세요:\n\n- 우리는 앱의 주요 라우트에 해당해야 할 index.js 파일이 있습니다.\n- 파일 이름을 사용하여 핸들러를 가질 수 있습니다. users.js는 /users로의 요청을 처리하고, books/index.js 파일은 /books로의 요청을 처리할 것입니다.\n- /books/addresses URL을 처리하는 books/addresses/index.js와 같이 더 깊게 중첩된 라우트도 있습니다.\n- 마지막으로, /books/[book].js 파일 덕분에 동적 라우트를 사용할 수도 있습니다. 해당 파일은 루트나 /books/addresses가 아닌 /books 내의 모든 경로를 처리할 것입니다.\n\n총평하자면 매우 완벽한 구조이며, 보다시피, 동적 라우트를 처리하는 유일한 복잡한 로직이 있고, 나머지는 상당히 간단합니다.\n\n## 파일 경로 기반 라우팅 추가하기\n\n<div class=\"content-ad\"></div>\n\n먼저 간단한 논리를 살펴봅시다: 동적 경로를 제외한 모든 것입니다.\n\nExpressJS를 설치한 후에는 all 메서드를 사용하여 catch-all 핸들러를 설정해 봅시다:\n\n이 코드는 모든 라우트를 캐치하고(all 메서드 덕분) 모든 HTTP 동사를 다루고(*/ 라우트 덕분) 있습니다.\n\n이 핸들러에 의해 요청이 캐치될 때마다 URL을 가져와 routes 폴더 안에 .js 확장자가 있는 파일이 있는지 확인합니다. 파일이 없으면 폴더로 가정하고 해당 폴더 안에 있는 index.js 파일을 찾습니다.\n\n<div class=\"content-ad\"></div>\n\n해결되었으니, executeRoute 함수를 호출하고 결과 값을 얻겠습니다. 만약 false이면, 파일을 찾을 수 없어 실행에 실패한 것으로 간주하겠습니다. 그래서 그 오류를 \"404 — 찾을 수 없음 응답\"으로 변환하겠습니다.\n\n이 퍼즐의 빠진 조각 executeRoute 함수는 다음과 같이 생겼습니다:\n\n동적 import 함수를 사용하고 있는데, 찾고 있는 파일이 존재한다면 계속 진행하고 요청에 사용된 HTTP 동사를 얻습니다. 이렇게 하면 catch-all 핸들러인 handler(네, 정말 좋은 이름!)를 정의하거나 동사의 이름을 메서드 이름으로 사용할 수 있습니다. 정의하면 코드가 대신 사용하겠죠.\n\n만약 import에 실패한다면(예외를 발생시킨다면) 그것은 가져올 파일이 없기 때문이며, 이는 해당 경로가 매핑되어 있지 않다는 의미입니다. 결과적으로 404 오류를 반환해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n믿든지 말든지, 파일 경로 라우팅을 달성하는 데 거의 필요한 것이 전부입니다.\n\n물론, 이전에 보여준 것처럼 동적 라우팅을 지원하려면 \"약간\"의 추가 코드가 필요합니다.\n\n# 동적 라우팅 지원 추가\n\n이제 URL에 따라 라우트 핸들러를 가져오는 방법을 알았으므로 executeRoute 함수가 false를 반환하는 시나리오에 대한 몇 가지 로직을 추가해야 합니다. 결국, 이는 라우트가 파일과 직접 매핑되지 않음을 의미하지만 \"와일드카드\" 파일을 지원하고자 하는 것이기도 합니다.\n\n<div class=\"content-ad\"></div>\n\n다음과 같은 로직을 추가하는 것이 좋습니다:\n\n- 직접 매핑된 파일이 없다면, 우선 동적 매개변수의 이름과 값을 추출합니다.\n- URL에서 이름을 제거하여 특수 파일이 있는 폴더를 이해합니다.\n- 동적 매개변수의 이름을 대괄호로 묶어 새 파일의 이름을 만듭니다.\n- 새 파일을 가져와서 executeRoute를 호출하려고 합니다.\n\n다음 예시를 상상해보세요:\n\n- 경로 /api/users/donald를 요청했습니다.\n- 파일 /routes/api/users/donald.js 또는 /routes/api/users/donald/index.js를 찾았지만 그 안에 아무 것도 없습니다.\n- 그래서 우리는 URL에서 \"donald\"를 제거하고, /routes/api/users 폴더 안에서 대괄호로 묶인 이름을 가진 파일을 찾아냅니다. 그리고 [user].js 파일을 찾습니다.\n- 이제 동적 매개변수가 \"user\"라는 것과 그 값이 \"donald\"인 것을 알게 되었습니다.\n- 이제 동적 파일을 가져와서 매개변수를 Request 객체에 추가하여 동적 핸들러가 그것을 사용할 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n상기는 우리 서버의 전체 코드입니다. 이미 알고 있는 부분은 무시하셔도 괜찮지만, 58번 줄에 추가한 false 절 내부의 논리를 살펴보세요. 이미 설명한 내용을 따르고 있습니다.\n\n파일 이름과 매개변수 이름의 결합을 “동적 핸들러”라고 부르며, URL에서 그것을 가져오는 함수를 작성했습니다.\n\n상기 코드 상단에 있는 getDynamicHandler 함수는 “특별” 파일이 있어야 하는 폴더를 탐색합니다. 그 폴더 안의 모든 파일을 읽고, 이름에 괄호가 있는 파일을 찾습니다. 루트 당 하나의 동적 핸들러만 갖는 것이 합리적이므로, 한 번 찾으면 더 이상 찾지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n정말 깔끔한 정규 표현식을 사용하면 파일 이름에서 대괄호로 둘러싸인 매개변수 이름도 캡처할 수 있어요.\n\n이제 매개변수의 이름과 핸들러 코드를 포함한 파일 이름을 모두 반환할 수 있어요. 기억해요, 매개변수의 실제 값은 URL에서 직접 가져와요.\n\n그게 바로 동적 라우터가 간단한 라우트, 다양한 HTTP 동사, 그리고 특별히 명명된 핸들러 파일을 사용하는 동적 라우트를 처리할 수 있게 한 거에요.\n\n이 모든 것이 100줄 미만의 단일 파일 안에 포함되어 있답니다.\n\n<div class=\"content-ad\"></div>\n\n물론, 제 비슷한 실험들과 마찬가지로, 이것은 학습용 연습입니다. 이 코드를 제품 환경으로 가져가려면 조금 정리하는 것과 아마도 동적 요청마다 디스크에서 읽는 것을 피하기 위해 캐싱을 추가하는 것을 권장합니다. 마지막으로 유닛 테스트를 추가하는 것이 좋습니다.\n\n그럼에도 불구하고, 이 글이 유용했기를 바라며, 이전에 자체 파일 경로 라우터를 작성한 경험이 있다면 댓글에 어떻게 했는지 알려주세요. 노트를 비교해보고 싶습니다!\n\n# 레고와 같은 재사용 가능한 구성 요소로 앱 만들기\n\n![이미지](/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_2.png)\n\n<div class=\"content-ad\"></div>\n\n비트의 오픈 소스 도구는 25만 명 이상의 개발자들이 컴포넌트로 앱을 빌드할 수 있도록 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 컴포넌트로 변환하고, 여러 애플리케이션들 간에 공유하세요. 협업하고 더 빠르게 빌드하는 것이 더 쉬워집니다.\n\n→ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 쉽게 만들고, 원하는 워크플로에 대해 최상의 경험을 즐기세요:\n\n<div class=\"content-ad\"></div>\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포(repository)\n\n<div class=\"content-ad\"></div>\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_0.png"},"coverImage":"/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_0.png","tag":["Tech"],"readingTime":6},{"title":"Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기","description":"","date":"2024-05-27 18:22","slug":"2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram","content":"\n\n이 블로그 포스트에서는 Node.js 애플리케이션에서 Python 스크립트를 호출하여 이메일을 보내는 방법을 살펴보겠습니다. 우리는 프로젝트 구조를 설계하여 관심사를 분리하고 코드베이스를 깔끔하게 유지할 것입니다.\n\n## 목차\n\n- 소개\n- 프로젝트 구조\n- 환경 설정\n- Python 이메일 발신 스크립트 생성\n- Node.js 컨트롤러 생성\n- 라우트 설정\n- 서버 생성\n- 결론\n\n### 1. 소개\n\n<div class=\"content-ad\"></div>\n\n어떤 경우에는 Node.js 애플리케이션에서 Python의 기능을 활용하고 싶을 수 있습니다. 이 튜토리얼은 Node.js 백엔드에서 Python을 사용하여 이메일을 보내는 방법을 보여줍니다. 우리는 Node.js의 child_process 모듈에서 spawn 함수를 사용하여 Python 스크립트를 호출할 것입니다.\n\n# 2. 프로젝트 구조\n\n다음은 우리 프로젝트의 구조입니다:\n\n\nserver/\n  ├── Controller/\n  │   └── mailController.js\n  ├── route/\n  │   └── mailRoute.js\n  ├── Utils/\n  │   └── mailSender.py\n  └── server.js\n  └── .env\n\n\n<div class=\"content-ad\"></div>\n\n# 3. 환경 설정하기\n\n## 단계 1: Node.js 프로젝트 초기화\n\n```js\nmkdir email-sender\ncd email-sender\nnpm init -y\nnpm install express dotenv body-parser\n```\n\n## 단계 2: 환경 변수 설정\n\n<div class=\"content-ad\"></div>\n\n루트 디렉토리에 다음 내용을 사용하여 .env 파일을 만들어주세요:\n\n```js\nGMAIL_USER=your-email@gmail.com\nGMAIL_APP_PASSWORD=your-app-password\n```\n\nyour-email@gmail.com 및 your-app-password를 실제 Gmail 주소 및 앱 비밀번호로 교체해주세요. Gmail 보안 탭 내에서 앱 비밀번호를 얻을 수 있습니다.\n\n# 4. 파이썬 이메일 발신 스크립트 만들기\n\n<div class=\"content-ad\"></div>\n\nUtils 디렉토리에 mailSender.py라는 Python 스크립트를 만들어주세요:\n\n```python\nimport smtplib\nimport os\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\ndef send_email(to_email, subject, body):\n    from_email = os.environ['GMAIL_USER']\n    app_password = os.environ['GMAIL_APP_PASSWORD']\n\n    msg = MIMEMultipart()\n    msg['From'] = from_email\n    msg['To'] = to_email\n    msg['Subject'] = subject\n    msg.attach(MIMEText(body, 'plain'))\n\n    try:\n        server = smtplib.SMTP('smtp.gmail.com', 587)\n        server.starttls()\n        server.login(from_email, app_password)\n        text = msg.as_string()\n        server.sendmail(from_email, to_email, text)\n        server.quit()\n        print(\"이메일을 성공적으로 전송했습니다.\")\n    except Exception as e:\n        print(f\"이메일 전송에 실패했습니다: {str(e)}\")\n\nif __name__ == \"__main__\":\n    import sys\n    to_email = sys.argv[1]\n    subject = sys.argv[2]\n    body = sys.argv[3]\n    send_email(to_email, subject, body)\n```\n\n# 5. Node.js Controller 생성\n\nController 디렉토리에 mailController.js라는 파일을 만들어주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nexports.sendEmail = (req, res) => {\n  const { to, subject, body } = req.body;\n  const pythonProcess = spawn('python3', [path.join(__dirname, '../Utils/mailSender.py'), to, subject, body]);\n\n  pythonProcess.stdout.on('data', (data) => {\n    console.log(`stdout: ${data}`);\n  });\n\n  pythonProcess.stderr.on('data', (data) => {\n    console.error(`stderr: ${data}`);\n  });\n\n  pythonProcess.on('close', (code) => {\n    console.log(`child process exited with code ${code}`);\n    res.send('Email sent');\n  });\n};\n```\n\n# 6. Setting Up the Routes\n\n라우트 설정하기\n\nroute 디렉토리에 mailRoute.js라는 파일을 만드세요:\n\n```js\nconst express = require('express');\nconst router = express.Router();\nconst mailController = require('../Controller/mailController');\n\nrouter.post('/send-email', mailController.sendEmail);\n\nmodule.exports = router;\n```\n\n<div class=\"content-ad\"></div>\n\n# 7. 서버 생성\n\n루트 디렉토리에 server.js라는 파일을 생성하세요:\n\n```js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst dotenv = require('dotenv');\nconst mailRoute = require('./route/mailRoute');\n\ndotenv.config();\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.use('/api', mailRoute);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n# 8. 결론\n\n<div class=\"content-ad\"></div>\n\n이 블로그 포스트에서는 Node.js 애플리케이션에서 Python 스크립트를 호출하여 이메일을 보내는 방법을 소개했습니다. 프로젝트 구조 설정, 환경 변수 구성, Python 전자 메일 발신자 스크립트 작성, 그리고 Node.js 백엔드를 설정하여 spawn 함수를 사용하여 Python 스크립트를 호출하는 방법에 대해 다뤘습니다. 이 접근 방식은 Node.js와 Python의 강점을 활용하여 유연하고 강력한 이메일 발송 솔루션을 제공합니다.\n\n이 단계를 따라가면 Python 스크립트를 Node.js 애플리케이션에 매끄럽게 통합하여 두 언어의 최상의 기능을 활용할 수 있습니다.\n\n더 나아가 향상된 이메일 처리 및 추가 기능을 위해 Python의 smtplib의 능력과 다양한 이메일 콘텐츠 및 첨부 파일을 처리하는 방법을 탐색하고 싶을 것입니다. 즐거운 코딩 하세요!","ogImage":{"url":"/assets/img/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram_0.png"},"coverImage":"/assets/img/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram_0.png","tag":["Tech"],"readingTime":5},{"title":"네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유","description":"","date":"2024-05-27 18:21","slug":"2024-05-27-NestJSTheGoodTheBadandTheUgly","content":"\n\n## 다음 프로젝트에 NestJS를 선택하시겠습니까?\n\n![이미지](/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png)\n\n지난 몇 년 동안 수백, 수천, 심지어 수백만 명의 유럽 고객에 의해 활용된 여러 애플리케이션을 NestJS를 사용하여 개발했습니다. 이러한 애플리케이션은 다양한 규모의 팀(스타트업, 스케일업, 기업 조직)에서 구축되었습니다. 모듈화된 단일체에서 이벤트 기반 마이크로서비스, GraphQL 및 REST까지 NestJS를 사용하여 개발했습니다. 그러나 모든 좋은 면이 있는 동시에 나쁜 면과 심지어 추악한 면이 있습니다.\n\n본 기사에서는 이 기간 동안 NestJS를 사용한 후 내 생각을 공유하려고 합니다. 개발자, 기술 리더 및 팀 리더가 NestJS 사용 중 발생할 수 있는 잠재적인 문제를 예상하고 해결하는 데 필요한 도구를 제공하는 것이 목표입니다.\n\n<div class=\"content-ad\"></div>\n\n# 좋은 점\n\n다양한 크기의 팀에서 깨끗한 코드에 대한 다른 의견과 응용프로그램이 완료되었을 때의 정의에 대한 다른 의견을 가지고 일해 왔습니다. 회사마다, 팀마다, 심지어 사람마다 다르게 다양합니다. 팀 내 개인의 의견은 종종 주관적이며, 이로 인해 개발 가이드라인과 코딩 스타일을 형성하기 어렵게 만들 수 있습니다. 실제로, 모든 팀이 언젠가는 다이어그램이 나타내는 것처럼 동일한 학습 곡선 단계를 따릅니다.\n\n![Diagram](/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_1.png)\n\n여기서 Nest가 실제로 가치를 증명합니다. Nest는 팀을 특정 방향으로 안내하고 이미 작업을 대부분 처리하는 디자인 패턴을 제공합니다. Nest는 매우 주관적이며, 그것이 좋은 것입니다.\n\n<div class=\"content-ad\"></div>\n\n팀용 Nest의 가치는 팀 간 일관성 및 코드베이스의 일관성에서 그 자체를 입증합니다. 프레임워크를 사용하면 GraphQL 애플리케이션에 실제로 참여할 수 있으며, 내부를 깊이 파악할 필요 없이 즉시 사용할 수 있습니다. Nest는 훌륭한 코드 예제들을 제공하여 이를 가능하게 만듭니다.\n\n비즈니스가 빠르게 움직이는 가운데, 비즈니스 방향성에 따라 유연하게 이동할 수 있는 개발 프레임워크를 사용하는 것은 큰 장점입니다. Nest를 사용하면 팀이 온보딩 프로세스보다는 제품 출시에 집중할 수 있습니다. 새로운 개발자를 쉽게 통합할 수 있으며, 훌륭한 문서와 발전하는 커뮤니티 덕분에 신입 개발자도 즉시 기여하기 시작할 수 있습니다.\n\n# 아쉬운 점\n\n좋은 것과 함께 항상 나쁜 점이 있습니다. 솔직히 말해서 이것은 프레임워크 자체보다는 종종 팀 또는 개인이 프레임워크 내에서 개념을 오용하거나 오해하는 데 직접적으로 책임이 있는 경우가 많습니다. 하지만 내가 경험한 Nest의 몇 가지 부분에서 어떤 팀들이 반복해서 고민하는 부분을 지적하고 싶습니다.\n\n<div class=\"content-ad\"></div>\n\n## 원형 의존성 문제\n\nSooner or later each NestJS project will face the moment that circular dependencies are introduced. Not only can I relate from experience, but also Nest elaborates on this common issue and the community-built package nestjs-spelunker identifies similar problems as well (even though it’s focused a bit more on the dependency injection tree in general).\n\nThe circular dependency issue is quite a nasty one, that could potentially slow down the entire development team in the long run — if not solved properly. Fortunately, quite recently an article about circular dependencies was published by Trilon, where a core contributor of Nest points out a tool, called Madge, to identify circular dependencies early.\n\n## Swallowed logs on application startup\n\n<div class=\"content-ad\"></div>\n\n\n서로 의존하는 문제가 발생하는 경우 종종 나타나는 또 다른 문제는 시작 시 오류가 발생할 때 로그가 소진되는 것입니다. 이로 인해 개발자들이 실제로 무슨 일이 발생했는지 이해하기가 매우 어려워집니다.\n\n오류를 식별하기 위한 일반적인 접근 방식은 오류 발생 시 중단을 비활성화하고 오류 메시지를 다시 던지는 것입니다.\n\n이제 콘솔에 실제 오류가 기록됩니다.\n\n# 실망하기 쉬운 부분\n\n<div class=\"content-ad\"></div>\n\n좋은 것과 나쁜 것이 있는 것처럼 추악한 면도 존재합니다. 솔직히 말해서, 이것은 항상 프레임워크가 직접 책임지는 것은 아니라, 그보다는 팀 또는 개인들이 프레임워크 내의 개념을 오용하거나 오해하는 경우가 많습니다. 저는 함께 일한 팀들이 Nest의 일부 영역에서 여러 번 고민을 겪었다는 점을 지적하고 싶습니다.\n\n## 단위 테스트\n\nNest에서의 단위 테스트는 프레임워크 자체와 매우 통합되어 있습니다. 단위와 통합 테스트 사이의 차이를 정의하는 것은 팀마다, 심지어 사람마다 달라집니다. Nest 내에서 가장 작은 단위를 테스트하려면 상당한 부가 코드와 다양한 기술에 대한 지식이 필요합니다. 특히 새로운 개발자들에게는 테스트 작성이 복잡할 수 있습니다. 왜냐하면 Nest가 어떻게 의존성 주입 트리를 해결하는지에 대한 지식이 필요하기 때문입니다.\n\n간단한 애플리케이션을 테스트하려고 하면 아래와 비슷한 테스트 파일에 맞닥뜨리게 되실 것입니다:\n\n<div class=\"content-ad\"></div>\n\n대부분의 실제 응용 프로그램에서 하나의 제공 업체에 대해 여러 종속성이 있을 것이며, 이로 인해 단위 테스트의 복잡성이 심각하게 증가할 것입니다. 시간이 지남에 따라 이러한 테스트는 팀이 단위 자체를 테스트하는 대신 어떻게 테스트를 작성하고 종속성 주입 트리를 구축할지에 더 많은 주의를 기울이면서 병목 현상이 될 수도 있습니다.\n\n다르게 할 수 있을까요? 물론, 테스트의 복잡성을 해결하는 팀들을 본 적이 있습니다. 클래스 메소드에 구현하는 대신 별도의 함수에 로직을 구현함으로써 테스트의 복잡성에 대응합니다. 이 접근 방식의 장점은 테스트가 간편해지고, 새로운 개발자가 JavaScript를 알고 있기 때문에 더 쉽게 익힐 수 있다는 것입니다. 다음을 고려해 보세요:\n\n모든 좋은 면에는 단점이 따르지만, 이러한 접근 방식의 구현으로 단위 테스트의 복잡성을 해결할 수 있을 뿐 아니라 다른 일면에서도 타협 사항이 있을 수 있습니다.\n\n## 동적 컨트롤러의 부재\n\n<div class=\"content-ad\"></div>\n\nNest에는 강력한 프로바이더 개념이 함께 제공됩니다. 이러한 프로바이더는 사용자 정의된 것이며 어떤 형태든 될 수 있습니다. 프로젝트가 더 성숙해지면 이러한 프로바이더는 매우 유용해집니다. 하지만 Nest의 의존성 주입 트리를 해결하는 방법에 대해 알아야 하는 개발자들에게는 어느 정도의 지식이 필요합니다.\n\n어쨌든, 실제로 필요한 것은 이러한 사용자 정의 프로바이더에 해당하는 사용자 정의 컨트롤러의 대응물입니다. Nest의 창시자에 따르면 이러한 컨트롤러는 Nest의 아이디어와 완전히 반대되지만, 프로젝트가 성장할 때 실제로 매우 유용합니다. Nest의 한계를 극복하기 위해 이러한 접근 방식을 구현할 수 있습니다. GitHub 쓰레드에 설명된 factory 접근 방식으로 구현할 수 있습니다:\n\n(하지만 오직 이것만이 아닌) Dynamic Modules를 통해 이 factory를 사용할 수 있습니다.\n\n하지만 모든 것은 좋음으로 이어지는 나쁨이 따르며, 이러한 접근 방식을 구현하면 동적 컨트롤러를 다루게 되는 반면에 한편으로는 Nest의 컨트롤러에 대한 의견이 있는 패턴을 포기하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nNest는 Node 랜드스케이프 내에서 정말 성숙하고 잘 문서화되어 있어서 많은 사람들이 선택하는 프레임워크입니다. 하지만 모든 것에는 좋은 점뿐만 아니라 나쁜 점과 가장 나쁜 점 등도 있습니다. 그러니 NestJS와 같은 프레임워크를 선택할 때 팀이 직면할 수 있는 잠재적인 문제점을 식별하는 것이 중요합니다.\n\n마지막 질문은 — 다음 프로젝트에 NestJS를 선택할 것인가. 음, 항상 그렇지만, 상황에 따라 다를거에요 ;)!","ogImage":{"url":"/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png"},"coverImage":"/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png","tag":["Tech"],"readingTime":5},{"title":"structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법","description":"","date":"2024-05-27 18:19","slug":"2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript","content":"\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png\" />\n\n# 1. 서문\n\n왜 지금까지 JavaScript에 완전한 복제 함수가 만들어지지 않았을까요? 데이터 유형에 관계 없이 객체와 해당 모든 내용을 완전히 복제하는 것은?\n\n이건 놀랍고, 때로는 객체를 깊은 복제해야 하는 경우가 많이 있어서 일에 많은 어려움을 야기하죠.\n\n<div class=\"content-ad\"></div>\n\n# 2. 객체를 깊은 복제하는 두 가지 방법\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_1.png)\n\n내 친구야, 객체를 깊은 복제하는 방법을 아시나요? 위 표의 데이터 유형을 복제하는 것이 가장 좋을 겁니다.\n\n```js\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  domNode: document.createElement(\"div\")\n}\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 testData를 테스트 데이터로 사용할 것입니다.\n\n# 2.1# JSON.parse와 JSON.stringify\n\n이 기능을 사용하면 객체를 깊이 복제할 수 있지만, 유감스럽게도 데이터 유형의 일부만 복사될 뿐이며, 순환 참조가 있는 객체는 복사할 수 없습니다.\n\n```js\ntry {\n  const jsonClone = JSON.parse(JSON.stringify(testData))\n  console.log(jsonClone)\n} catch (error) {\n  console.log(\"JSON 메서드가 이 데이터를 처리할 수 없습니다\")\n}\n// 출력\n/*\n{\n  number: 123,\n  string: \"test\",\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }]\n}\n*/\n```\n\n<div class=\"content-ad\"></div>\n\n이미지를 포함한 코드 블록:\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nJSON.parse(JSON.stringify(obj))\n```\n\nMarkdown 형식으로 변환 된 표:\n\n# 2.2# lodash.clone\n\n<div class=\"content-ad\"></div>\n\n대부분의 사람들이 이 선택을 하겠지만 추가적인 npm 패키지를 가져와야 할 수도 있지만 그 가치는 충분히 합니다.\n\n```js\nconst _ = require('lodash')\nconst lodashClone = _.cloneDeep(testData)\nconsole.log(lodashClone)\n\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: [Function: function], // 함수 참조는 복사됩니다.\n  map: Map { 'key1' => 'value1', 'key2' => 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: HTMLDivElement {}\n}\n*/\n```\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_4.png)\n\n# 3.1# 새로운 API: structuredClone?\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_5.png\" />\n\nmdn에서 가져왔어요!\n\n2022년부터 크롬, 파이어폭스 등 다양한 주요 브라우저에서 지원되고 있어요. 우리에게 행운이네요!\n\n아직 이 데이터를 사용 중이지만, 먼저 함수와 DOM 유형을 숨기고, 그 이유를 나중에 설명할게요.\n\n<div class=\"content-ad\"></div>\n\n\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  // function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  // domNode: document.createElement(\"div\")\n}\n\nconst structuredCloneResult = structuredClone(testData)\nconsole.log(structuredCloneResult)\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: undefined, // Functions are not cloned\n  map: Map { 'key1' => 'value1', 'key2' => 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: undefined // DOM nodes are not cloned\n}\n*/\n\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_6.png\" />\n\n우리가 손에 들고 있는 잔을 들어 올려봐요. 이 결과는 축하해야 할 만하네요.\n\n# 3.2# structuredClone의 장점\n\n\n<div class=\"content-ad\"></div>\n\n친구야, structuredClone 함수를 좋아하시나요? 충분히 간단한가요? 네, 그것이 가장 큰 장점이죠.\n\n하지만 또 다른 큰 장점이 있습니다. 그것은 심지어 원형 참조가 있는 객체도 복사할 수 있다는 것이죠.\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nstructuredClone(obj)\n```\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_7.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 3.3 구조화된 복제의 일부 제한 사항\n\n친구들아, 함께 축배를 건넜지만, 구조화된 복제에는 여전히 몇 가지 제한 사항이 있음을 인정해야 합니다.\n\n함수나 Dom을 복사할 수 없습니다. 이를 하려고 시도하면 예외가 발생합니다. 이것이 저가 함수와 Dom을 숨긴 이유입니다.\n\n```js\nconst obj = { fn: () => {} }\n\nstructuredClone(obj)\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_8.png\" />\n\n```js\nconst obj = { domNode: document.createElement('div') }\n\nstructuredClone(obj)\n```\n\n<img src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_9.png\" />\n\n이 함수를 호출할 때 오류가 발생하지 않도록 하고, 메소드를 가진 객체를 깊게 복제하지만 메소드는 복제하지 않기를 원합니다.\n\n<div class=\"content-ad\"></div>\n\n# 친절한 한국어 번역 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수 보내고 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠에 강제로 노출되는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 개발자가 반드시 알아야 하는 10가지 도구","description":"","date":"2024-05-27 18:18","slug":"2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3","content":"\n\n\n![image](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png)\n\n10 fantastic web dev tools to level up your productivity and achieve your coding goals faster than ever.\n\nFrom breathtaking animations to rapid project creation, these tools will boost your workflow and make a lot of things easier.\n\n# 1. Fira Code\n\n\n<div class=\"content-ad\"></div>\n\n대부분의 코드 편집기의 기본 글꼴은 지루해요 (예: Consolas).\n\n대신 이 아름다운 고정폭 글꼴을 사용해보세요:\n\n![](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_1.png)\n\n글꼴 리거처는 항상 뛰어난 특징 중 하나였어요 — 일반적인 코딩 문자 그룹을 세련된 직관적인 방식으로 병합하는 기능이에요:\n\n<div class=\"content-ad\"></div>\n\nVS Code의 글꼴을 변경하는 것은 매우 간단해요. 설정으로 이동해 보시면 \"자주 사용하는\" 옵션 중에 있을 거에요:\n\n![image](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_2.png)\n\n# 2. Barba JS\n\n웹페이지에 창의적인 멋을 더하고 사용자들을 기쁘게 만들어줄 멋진 전환 효과를 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경된 텍스트입니다.\n\n![Image 1](https://miro.medium.com/v2/resize:fit:1400/0*X8tn7Y3ovmldXD_B.gif)\n\n당연히 클라이언트 측 라우팅을 사용하여 앱과 같은 경험을 제공합니다:\n\n![Image 2](https://miro.medium.com/v2/resize:fit:1400/0*hR4-kwV-JDKmMfW2.gif)\n\n# 3. Consola\n\n<div class=\"content-ad\"></div>\n\nConsolas을 방금 비난했는데, 그건 오타가 아니에요.\n\n이 아름다운 사용자 친화적인 콘솔 래퍼에요.\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_3.png)\n\n정교한 CLI 도구를 만드는 데 완벽해요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_4.png\" />\n\n# 4. Preact JS\n\n리액트의 빠른 대안 - 10 배 이상 가볍습니다!\n\n들어가 보면 훅, JSX, 함수형 컴포넌트가 있습니다... 사실상 드롭인 대체물입니다.\n\n<div class=\"content-ad\"></div>\n\nApp 컴포넌트를 확인해 보세요. 제 오른손으로 (아니면 왼손으로) 차이점을 거의 세어볼 수 있어요.\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_5.png)\n\n그리고 36,000개 이상의 GitHub 스타 — 진지하게 다룰 만하죠.\n\n# 5. Carbon\n\n<div class=\"content-ad\"></div>\n\n사람들을 지루하게 만들 필요는 없어요. \n\n카보너(Carbon)를 사용하여 코드 스니펫을 아름답게 만들어 세상에 아름다움을 더해보세요:\n\n![Carbon](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_6.png)\n\n여러 가지 테마 중에서 선택할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_7.png\" />\n\n# 6. Firestore\n\n아마도 가장 좋은 NoSQL 데이터베이스입니다.\n\n넓고 무료 제한으로 새로운 아이디어를 시도하기에 훌륭합니다. 제가 여러 차례 해봤던 것처럼요.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 표를 바꾼 것입니다.\n\n\n![Amazing Tools Part 1](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_8.png)\n\nJS 개발자로써 매우 쉽고 직관적일 것입니다.\n\n![Amazing Tools Part 2](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_9.png)\n\n심지어 클라이언트 측에서 사용하고 서버 요청을 완전히 건너뛸 수도 있습니다 — 비용 절감과 앱 성능 향상을 도모할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n나는 이전에 무료 웹 소켓 서버를 사용한 적이 있었는데, 서버 측 보호장치와 완벽하게 작동했었어요.\n\n# 7. react-input-autosize\n\n입력 자동 조절: 만연한 웹 디자인 문제: \n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*piupw_8S7ljNmEAL.gif)\n\n<div class=\"content-ad\"></div>\n\n그 이유로 react-input-autosize가 문제를 해결하고 나서 매주 수백만 번의 다운로드를 받게 되었습니다:\n\n![이미지1](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_10.png)\n\n매우 쉽게 사용할 수 있는 UI 컴포넌트:\n\n![이미지2](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_11.png)\n\n<div class=\"content-ad\"></div>\n\n# 8. VS Code용 라이브 서버\n\n정적 HTML 페이지를 신속하게 작성하는 강력한 도구 — 4800만 회 다운로드!\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_12.png)\n\n웹페이지를 수동으로 다시로드할 필요가 없습니다 — 브라우저에서 페이지를 불러오고 파일 내용과 화면을 동기화해줍니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*XyzPx0jn9viCwfGa.gif)\n\n# 9. Parcel\n\nParcel: 아무 설정 없이 제로 설정으로 사용 가능한 번들러 - 고대의 Create React App보다 훨씬 더 유연합니다.\n\n모든 최신 웹 기술을 지원하며 우수한 성능을 자랑합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_13.png)\n\n우리는 index.jsx에서 새로운 React 앱을 빠르게 생성할 수 있습니다:\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_14.png)\n\n# 10. SendGrid\n\n\n<div class=\"content-ad\"></div>\n\n강력하고 인기 있는 API로 마케팅 및 거래 이메일을 보내고 99%의 전달률을 유지하세요.\n\n스팸 폴더를 건너뛰고 인박스에 직접 도착하는 아름다운, 매력적인 이메일을 디자인하세요.\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_15.png)\n\n# 마지막으로\n\n<div class=\"content-ad\"></div>\n\n제품 생산성과 개발자의 삶의 질을 높이는 데 이 멋진 도구들을 사용해보세요.\n\n# 자바스크립트가 하는 모든 미친짓\n\n당신이 이미 모든 특이점을 알고 있다고 생각했을 때,\n자바스크립트가 하는 모든 미친짓은 자바스크립트의 세세한 함정과 잘 알려지지 않은 부분에 대한 흥미진진한 안내서로 귀하의 소중한 시간을 절약하면서 고통스러운 버그를 피하는 데 도움이 됩니다.\n\n오늘 무료 복사본을 받아보세요.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경한 코드입니다.\n\n\n![이미지 설명](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_16.png)\n","ogImage":{"url":"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png"},"coverImage":"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png","tag":["Tech"],"readingTime":5},{"title":"JavaScript와 TypeScript 비교 정리","description":"","date":"2024-05-27 18:10","slug":"2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years","content":"\n\n\n![2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png](/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png)\n\n이 기사는 지난 3년 동안 (그리고 그 이전에서도) JavaScript/ECMAScript와 TypeScript에서 발생한 거의 모든 변경 사항을 살펴봅니다.\n\n다음의 기능들 중 일부는 여러분에게 적용되지 않거나 실용적이지 않을 수 있지만, 이러한 언어에 대한 이해를 더 깊게 하고 가능한 기능을 보여주기 위한 것입니다.\n\n많은 TypeScript 기능들을 생략했는데, 그 이유는 \"이전과 달리 예상대로 작동하지 않았으나, 지금은 그렇게 됩니다\"로 요약할 수 있습니다. 따라서 과거에 작동하지 않았던 것이 있다면, 다시 시도해 보세요.\n\n\n<div class=\"content-ad\"></div>\n\n- JavaScript / ECMAScript (가장 오래된 것부터)\n- TypeScript (가장 오래된 것부터)\n\n# 내용\n\n# ECMAScript\n\n## 과거 (아직도 중요한 이전 소개들)\n\n<div class=\"content-ad\"></div>\n\n- Tagged template literals: 템플릿 리터럴 앞에 함수 이름을 붙이면 함수가 템플릿 리터럴 및 템플릿 값들을 전달받게 됩니다. 이 방법에는 재미있는 활용법이 있습니다.\n\n```js\n// 임의의 숫자를 포함한 문자열을 로깅할 때 숫자를 형식화하는 방법을 작성하고 싶다고 가정해 봅시다.\n// 그럴 때 태그드 템플릿을 사용할 수 있습니다.\nfunction formatNumbers(strings: TemplateStringsArray, number: number): string {\n  return strings[0] + number.toFixed(2) + strings[1];\n}\nconsole.log(formatNumbers`This is the value: ${0}, it's important.`); // This is the value: 0.00, it's important.\n\n// 문자열 내의 번역 키를 \"번역\"하고 싶을 때 (여기서는 소문자로 변경)\nfunction translateKey(key: string): string {\n  return key.toLocaleLowerCase();\n}\nfunction translate(strings: TemplateStringsArray, ...expressions: string[]): string {\n  return strings.reduce((accumulator, currentValue, index) => accumulator + currentValue + translateKey(expressions[index] ?? ''), '');\n}\nconsole.log(translate`Hello, this is ${'NAME'} to say ${'MESSAGE'}.`); // Hello, this is name to say message.\n```\n\n- Symbols: 객체에 대한 고유 키: Symbol(\"foo\") === Symbol(\"foo\"); // false. 내부적으로 사용됩니다.\n\n```js\nconst obj: { [index: string]: string } = {};\n\nconst symbolA = Symbol('a');\nconst symbolB = Symbol.for('b');\n\nconsole.log(symbolA.description); // \"a\"\n\nobj[symbolA] = 'a';\nobj[symbolB] = 'b';\nobj['c'] = 'c';\nobj.d = 'd';\n\nconsole.log(obj[symbolA]); // \"a\"\nconsole.log(obj[symbolB]); // \"b\"\n\n// 다른 심볼이나 심볼 없이는 키에 액세스할 수 없습니다.\nconsole.log(obj[Symbol('a')]); // undefined\nconsole.log(obj['a']); // undefined\n\n// for ... in을 사용할 때 키가 열거되지 않습니다.\nfor (const i in obj) {\n  console.log(i); // \"c\", \"d\"\n}\n```  \n\n<div class=\"content-ad\"></div>\n\n## ES2020\n\n- Optional chaining: 잠재적으로 정의되지 않은 객체의 값을 (인덱싱을 통해) 액세스하기 위해 부모 객체 이름 뒤에 ?를 사용하여 선택적 연결을 사용할 수 있습니다. 이는 인덱싱 ([...]) 또는 함수 호출에도 사용할 수 있습니다.\n\n```js\n// 이전:\n// 우리가 정확히 정의된 것인지 확신할 수 없는 객체 변수 (또는 다른 구조)가 있을 때,\n// 속성에 쉽게 액세스할 수 없습니다.\nconst object: { name: string } | undefined = Math.random() > 0.5 ? undefined : { name: 'test' };\nconst value = object.name; // 타입 오류: 'object' 가 'undefined' 일 수 있습니다.\n\n// 먼저 정의되었는지 확인해야 했지만, 이는 가독성을 해치며 중첩된 객체에 대해 복잡해집니다.\nconst objectOld: { name: string } | undefined = Math.random() > 0.5 ? undefined : { name: 'test' };\nconst valueOld = objectOld ? objectOld.name : undefined;\n\n// 새로운 방법:\n// 대신 선택적 연결을 사용할 수 있습니다.\nconst objectNew: { name: string } | undefined = Math.random() > 0.5 ? undefined : { name: 'test' };\nconst valueNew = objectNew?.name;\n\n// 이것은 인덱싱 및 함수에도 사용할 수 있습니다.\nconst array: string[] | undefined = Math.random() > 0.5 ? undefined : ['test'];\nconst item = array?.[0];\nconst func: (() => string) | undefined = Math.random() > 0.5 ? undefined : () => 'test';\nconst result = func?.();\n```\n\n- 널 병합 연산자 (??): 조건부 할당을 위해 || 연산자를 사용하는 대신 새로운 ?? 연산자를 사용할 수 있습니다. 모든 거짓 값에 적용되는 대신 undefined와 null에만 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst value: string | undefined = Math.random() > 0.5 ? undefined : 'test';\n\n// 이전:\n// 값이 undefined 또는 null인 경우 다른 값으로 조건적으로 할당하려면 \"||\" 연산자를 사용할 수 있었습니다.\nconst anotherValue = value || 'hello';\nconsole.log(anotherValue); // \"test\" 또는 \"hello\"\n\n// 이는 참 값 사용 시 잘 작동하지만, 0이나 빈 문자열과 비교할 경우에도 적용됩니다.\nconst incorrectValue = '' || 'incorrect';\nconsole.log(incorrectValue); // 항상 \"incorrect\"\nconst anotherIncorrectValue = 0 || 'incorrect';\nconsole.log(anotherIncorrectValue); // 항상 \"incorrect\"\n\n// 새로운 방법:\n// 이제 nullish 병합 연산자를 사용할 수 있습니다. 이는 오직 undefined와 null 값에만 적용됩니다.\nconst newValue = value ?? 'hello';\nconsole.log(newValue) // 항상 \"hello\"\n\n// 이제 falsy 값들이 교체되지 않습니다.\nconst correctValue = '' ?? 'incorrect';\nconsole.log(correctValue); // 항상 \"\"\nconst anotherCorrectValue = 0 ?? 'incorrect';\nconsole.log(anotherCorrectValue); // 항상 0\n```\n\n- import(): 변수를 사용하여 런타임에서 동적으로 import ... from ... 처럼 모듈을 가져올 수 있습니다.\n\n```js\nlet importModule;\nif (shouldImport) {\n  importModule = await import('./module.mjs');\n}\n```\n\n- String.matchAll(): 루프를 사용하지 않고 정규 표현식의 여러 일치 항목과 캡처 그룹을 모두 얻을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst stringVar = 'testhello,testagain,';\n\n// 이전:\n// 일치 항목만 검색되며 캡처 그룹은 포함되지 않습니다.\nconsole.log(stringVar.match(/test([\\w]+?),/g)); // [\"testhello,\", \"testagain,\"]\n\n// 캡처 그룹을 포함한 하나의 일치 항목만 검색합니다.\nconst singleMatch = stringVar.match(/test([\\w]+?),/);\nif (singleMatch) {\n  console.log(singleMatch[0]); // \"testhello,\"\n  console.log(singleMatch[1]); // \"hello\"\n}\n\n// 같은 결과를 얻지만 매우 직관적이지 않습니다 (exec 메서드는 마지막 인덱스를 저장합니다).\n// 루프 외부에서 정의되어야 하며 전역으로 선언되어야 하며 (/g) 모드여야 합니다.\nconst regex = /test([\\w]+?),/g;\nlet execMatch;\nwhile ((execMatch = regex.exec(stringVar)) !== null) {\n  console.log(execMatch[0]); // \"testhello,\", \"testagain,\"\n  console.log(execMatch[1]); // \"hello\", \"again\"\n}\n\n// 새로운 방법:\n// 정규식은 전역 (/g)이어야 합니다. 그렇지 않으면 작동하지 않습니다.\nconst matchesIterator = stringVar.matchAll(/test([\\w]+?),/g);\n// 순회해야 하거나 배열(Array.from())로 변환해야 하며 직접 색인화(인덱싱)할 수 없습니다.\nfor (const match of matchesIterator) {\n  console.log(match[0]); // \"testhello,\", \"testagain,\"\n  console.log(match[1]); // \"hello\", \"again\"\n}\n```\n\n- Promise.allSettled(): Promise.all()과 유사하지만 모든 Promise가 완료될 때까지 기다리며 첫 번째 reject/throw에서 반환하지 않습니다. 모든 오류 처리를 보다 쉽게 할 수 있습니다.\n\n```js\nasync function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n\n// 이전:\nconsole.log(await Promise.all([success1(), success2()])); // [\"a\", \"b\"]\n// 하지만:\ntry {\n  await Promise.all([success1(), success2(), fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 주의: 하나의 에러만 처리하고 성공 값에 액세스할 수 없습니다.\n\n// 이전 해결 방법 (정말 최적이 아님):\nconsole.log(await Promise.all([ // [\"a\", \"b\", undefined, undefined]\n  success1().catch(e => { console.log(e); }),\n  success2().catch(e => { console.log(e); }),\n  fail1().catch(e => { console.log(e); }), // \"fail 1\"\n  fail2().catch(e => { console.log(e); })])); // \"fail 2\"\n\n// 새로운 방법:\nconst results = await Promise.allSettled([success1(), success2(), fail1(), fail2()]);\nconst sucessfulResults = results\n  .filter(result => result.status === 'fulfilled')\n  .map(result => (result as PromiseFulfilledResult<string>).value);\nconsole.log(sucessfulResults); // [\"a\", \"b\"]\nresults.filter(result => result.status === 'rejected').forEach(error => {\n  console.log((error as PromiseRejectedResult).reason); // \"fail 1\", \"fail 2\"\n});\n// 또는:\nfor (const result of results) {\n  if (result.status === 'fulfilled') {\n    console.log(result.value); // \"a\", \"b\"\n  } else if (result.status === 'rejected') {\n    console.log(result.reason); // \"fail 1\", \"fail 2\"\n  }\n}\n```\n\n- BigInt: 새로운 BigInt 데이터 유형을 사용하여 큰 (정수) 숫자를 정확하게 저장하고 처리할 수 있어 JavaScript가 숫자를 부동 소수점으로 저장하는 것에 의한 오류를 방지할 수 있습니다. BigInt() 생성자를 사용하여 생성할 수 있고(불완전성을 방지하기 위해 문자열을 선호) 또는 숫자 끝에 n을 추가하여 생성할 수 있습니다.\n  \n\n<div class=\"content-ad\"></div>\n\n```md\n// 이전:\n// JavaScript는 숫자를 부동 소수점으로 저장하기 때문에 항상 약간의 부정확성이 있습니다.\n// 더 중요한 것은 특정 숫자 이후에 정수 연산에 부정확성이 시작됩니다.\nconst maxSafeInteger = 9007199254740991;\nconsole.log(maxSafeInteger === Number.MAX_SAFE_INTEGER); // true\n\n// 해당 숫자보다 큰 숫자와 비교하면 부정확성이 발생할 수 있습니다.\nconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2);\n\n// NEW:\n// BigInt 데이터 형식을 사용하면 이론적으로 무한히 큰 (정수) 숫자를 저장하고 조작할 수 있습니다.\n// 숫자 끝에 \"n\"을 추가하거나 BigInt 생성자를 사용하여 사용합니다.\nconst maxSafeIntegerPreviously = 9007199254740991n;\nconsole.log(maxSafeIntegerPreviously); // 9007199254740991\n\nconst anotherWay = BigInt(9007199254740991);\nconsole.log(anotherWay); // 9007199254740991\n\n// 안전한 정수(Number.MAX_SAFE_INTEGER)보다 큰 정수를 전달하면 안됩니다.\nconst incorrect = BigInt(9007199254740992);\nconsole.log(incorrect); // 9007199254740992\nconst incorrectAgain = BigInt(9007199254740993);\nconsole.log(incorrectAgain); // 9007199254740992\n// 오랜, 동일한 값으로 변환됩니다.\n\n// 대신 문자열을 사용하거나 더 좋은 다른 구문을 사용합니다.\nconst correct = BigInt('9007199254740993');\nconsole.log(correct); // 9007199254740993\nconst correctAgain = 9007199254740993n;\nconsole.log(correctAgain); // 9007199254740993\n\n// 16진수, 8진수 및 2진수도 문자열로 전달할 수 있습니다.\nconst hex = BigInt('0x1fffffffffffff');\nconsole.log(hex); // 9007199254740991\nconst octal = BigInt('0o377777777777777777');\nconsole.log(octal); // 9007199254740991\nconst binary = BigInt('0b11111111111111111111111111111111111111111111111111111');\nconsole.log(binary); // 9007199254740991\n\n// 대부분의 산술 연산은 예상대로 작동하지만 다른 연산자도 BigInt 여야합니다. 모든 연산도 BigInt를 반환합니다.\nconst addition = maxSafeIntegerPreviously + 2n;\nconsole.log(addition); // 9007199254740993\n\nconst multiplication = maxSafeIntegerPreviously * 2n;\nconsole.log(multiplication); // 18014398509481982\n\nconst subtraction = multiplication - 10n;\nconsole.log(subtraction); // 18014398509481972\n\nconst modulo = multiplication % 10n;\nconsole.log(modulo); // 2\n\nconst exponentiation = 2n ** 54n;\nconsole.log(exponentiation); // 18014398509481984\n\nconst exponentiationAgain = 2n ^ 54n;\nconsole.log(exponentiationAgain); // 18014398509481984\n\nconst negative = exponentiation * -1n;\nconsole.log(negative); // -18014398509481984\n\n// BigInt로 인한 정수 나눗셈은 조금 다르게 작동합니다.\nconst division = multiplication / 2n;\nconsole.log(division); // 9007199254740991\n// 나뉠 수 있는 정수에 대해서는 제대로 작동합니다.\n\n// 나누기가 안 되는 숫자에 대해서는 정수 나눗셈(내림)처럼 작동할 것입니다.\nconst divisionAgain = 5n / 2n;\nconsole.log(divisionAgain); // 2\n\n// 일치하는(엄격한) 비교가 BigInt 숫자에는 적용되지 않습니다.\nconsole.log(0n === 0); // false\nconsole.log(0n == 0); // true\n\n// 그러나 비교는 예상대로 작동합니다.\nconsole.log(1n < 2); // true\nconsole.log(2n > 1); // true\nconsole.log(2 > 2); // false\nconsole.log(2n > 2); // false\nconsole.log(2n >= 2); // true\n\n// 타입은 \"bigint\"입니다.\nconsole.log(typeof 1n); // \"bigint\"\n\n// 일반 숫자(부호있는 부호 없는 (음수 없음))로 다시 변환할 수 있습니다.\n// 그러나 이는 정확도를 희생합니다. 유효 숫자의 수를 지정할 수 있습니다.\n\nconsole.log(BigInt.asIntN(0, -2n)); // 0\nconsole.log(BigInt.asIntN(1, -2n)); // 0\nconsole.log(BigInt.asIntN(2, -2n)); // -2\n// 보통 더 높은 비트 수를 사용할 것입니다.\n\n// 음수 숫자는 부호가 있는 숫자로 변환될 때 2의 보수로 변환됩니다.\nconsole.log(BigInt.asUintN(8, -2n)); // 254\n```\n\n- globalThis: 환경(브라우저, NodeJS, ...)와 상관없이 전역 컨텍스트에서 변수에 액세스할 수 있습니다. 여전히 권장되지는 않지만 때로는 필요합니다. 브라우저의 최상위 수준에서 this와 유사합니다.\n\n```md\nconsole.log(globalThis.Math); // Math Object\n```\n\n- import.meta: ES-모듈을 사용할 때 현재 모듈 URL import.meta.url을 얻습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconsole.log(import.meta.url); // \"file://...\"\n```\n\n- export * as … from …: 쉽게 기본값을 하위 모듈로 다시 내보냅니다.\n\n```js\nexport * as am from 'another-module'\n```\n\n```js\nimport { am } from 'module'\n```\n\n<div class=\"content-ad\"></div>\n\n## ES2021\n\n- String.replaceAll(): 이제 문자열 내에서 부분 문자열의 모든 인스턴스를 대체할 수 있습니다. 더 이상 항상 전역 플래그(/g)를 사용하는 정규 표현식을 사용할 필요가 없습니다.\n\n```js\nconst testString = 'hello/greetings everyone/everybody';\n// 이전:\n// 첫 번째 인스턴스만 대체함\nconsole.log(testString.replace('/', '|')); // 'hello|greetings everyone/everybody'\n\n// 대체하기 위해 정규 표현식을 사용해야 했는데, 이는 성능이 좋지 않고 이스케이프가 필요합니다.\n// 전역 플래그(/g)를 참고하세요.\nconsole.log(testString.replace(/\\//g, '|')); // 'hello|greetings everyone|everybody'\n\n// 새로운 기능:\n// replaceAll을 사용하면 더 명확하고 빠릅니다.\nconsole.log(testString.replaceAll('/', '|')); // 'hello|greetings everyone|everybody'\n```\n\n- Promise.any(): 프로미스 목록 중 하나의 결과만 필요한 경우, 첫 번째 결과를 반환합니다. 모든 프로미스가 거부될 때만 거부하고 AggregateError를 반환하며, 즉시 거부되는 Promise.race가 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconsole.log(await Promise.race([success1(), success2()])); // \"a\"\n// 그러나:\ntry {\n  await Promise.race([fail1(), fail2(), success1(), success2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 유의: 하나의 오류만 catch하고 성공 값을 액세스할 수 없습니다.\n\n// 이전 수정 (정말 최적화되지 않음):\nconsole.log(await Promise.race([ // \"a\"\n  fail1().catch(e => { console.log(e); }), // \"fail 1\"\n  fail2().catch(e => { console.log(e); }), // \"fail 2\"\n  success1().catch(e => { console.log(e); }),\n  success2().catch(e => { console.log(e); })]));\n\n// 새로운:\nconsole.log(await Promise.any([fail1(), fail2(), success1(), success2()])); // \"a\"\n// 모든 프로미스가 거부될 때만 거부하고 모든 오류를 포함하는 AggregateError를 리턴합니다.\ntry {\n  await Promise.any([fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // [AggregateError: All promises were rejected]\n  console.log(e.errors); // [\"fail 1\", \"fail 2\"]\n}\n```\n\n- Nullish coalescing assignment (??=): 이전에 \"nullish\"였을 때만 값을 할당합니다 (null 또는 undefined).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () => 'b';\n\n// undefined는 nullish이므로 새 값이 x1에 할당됩니다.\nx1 ??= 'b';\nconsole.log(x1) // \"b\"\n\n// 문자열은 nullish가 아니므로 x2에 새 값이 할당되지 않습니다.\n// 또한 참고: getNewValue()가 실행되지 않습니다.\nx2 ??= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- Logical and assignment (&&=): 이전에 \"truthy\"였을 때만 값을 할당합니다 (true 또는 true로 변환되는 값).```\n\n<div class=\"content-ad\"></div>\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () => 'b';\n\n// 지정되지 않은 값인 x1에 새 값이 할당되지 않습니다. 왜냐하면 지정되지 않은 값은 참이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx1 &&= getNewValue();\nconsole.log(x1) // undefined\n\n// 문자열은 참이므로 새 값이 x2에 할당됩니다.\nx2 &&= 'b';\nconsole.log(x2) // \"b\"\n```\n\n- 논리 또는 할당 (||=): 이전에 \"거짓\"인 경우에만 값이 할당됩니다 (false 또는 false로 변환).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () => 'b';\n\n// x1에 새 값이 할당됩니다. 왜냐하면 지정되지 않은 값은 거짓이기 때문입니다.\nx1 ||= 'b';\nconsole.log(x1) // \"b\"\n\n// x2에 새 값이 할당되지 않습니다. 왜냐하면 문자열은 거짓이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx2 ||= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- WeakRef: 객체가 가비지 수집되는 것을 방지하지 않고 객체에 \"약한\" 참조를 보유합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst ref = new WeakRef(element);\n\n// 만약 객체/요소가 여전히 존재하고 쓰레기 수집되지 않았다면 값을 가져옵니다.\nconst value = ref.deref;\nconsole.log(value); // undefined\n// 객체가 더는 존재하지 않는 것 같습니다.\n```\n\n- 숫자 리터럴 구분자 (_): 가독성을 위해 숫자를 _로 구분합니다. 이는 기능에 영향을 미치지 않습니다.\n\n```js\nconst int = 1_000_000_000;\nconst float = 1_000_000_000.999_999_999;\nconst max = 9_223_372_036_854_775_807n;\nconst binary = 0b1011_0101_0101;\nconst octal = 0o1234_5670;\nconst hex = 0xD0_E0_F0;\n```\n\n## ES2022\n  \n\n<div class=\"content-ad\"></div>\n\n- 최상위 대기: await 키워드는 이제 ES 모듈의 최상위 수준에서 사용할 수 있습니다. 이는 래퍼 함수의 필요성을 제거하고 오류 처리를 개선합니다.\n\n```js\nasync function asyncFuncSuccess() {\n  return 'test';\n}\n\nasync function asyncFuncFail() {\n  throw new Error('Test');\n}\n\n// 이전:\n// 프로미스를 대기하려면 async 함수 내부에서만 가능했습니다.\n// await asyncFuncSuccess(); // SyntaxError: await is only valid in async functions\n// 따라서 async 함수 내부로 래핑해야 했고 이는 오류 처리와 최상위 동시성을 잃게 했습니다.\ntry {\n  (async () => {\n    console.log(await asyncFuncSuccess()); // \"test\"\n    try {\n      await asyncFuncFail();\n    } catch (e) {\n      // 오류 처리를 위해 필요합니다. 그렇지 않으면 오류가 캐치되지 않거나 적절한 추적 없이 너무 늦게 되어버립니다.\n      console.error(e); // Error: \"Test\"\n      throw e;\n    }\n  })();\n} catch (e) {\n  // 함수가 async여서 절대 호출되지 않거나(적절한 추적이 없거나 너무 늦게) 이유 때문에\n  console.error(e);\n}\n\n// 비동기 함수가 기다려지지 않았기 때문에 이 프로미스 결과보다 먼저 기록됩니다.\nconsole.log('Hey'); // \"Hey\"\n\n// 새로운:\n// 파일이 ES 모듈이라면(package.json에 설정되었고, exports가 있고, \".mts\"로 명명된 경우) 최상위 수준에서 바로 await할 수 있습니다.\nconsole.log(await asyncFuncSuccess()); // \"test\"\ntry {\n  await asyncFuncFail();\n} catch (e) {\n  console.error(e); // Error: \"Test\"\n}\n\n// 모든 비동기 호출이 기다려지기 때문에 이 프로미스 결과 뒤에 기록됩니다.\nconsole.log('Hello'); // \"Hello\"\n```\n\n- #private: 클래스 멤버(속성 및 메서드)를 이름이 #로 시작하게하여 비공개로 만듭니다. 따라서 이러한 멤버는 클래스 내부에서만 액세스할 수 있습니다. 삭제되거나 동적으로 할당할 수 없습니다. 잘못된 동작은 JavaScript(하지만 TypeScript가 아닌) 구문 오류를 발생시킵니다. TypeScript 프로젝트에서는 권장되지 않습니다. 대신 기존 private 키워드를 사용하십시오.\n\n```js\nclass ClassWithPrivateField {\n  #privateField;\n  #anotherPrivateField = 4;\n\n  constructor() {\n    this.#privateField = 42; // 유효\n    delete this.#privateField; // 구문 오류\n    this.#undeclaredField = 444; // 구문 오류\n    console.log(this.#anotherPrivateField); // 4\n  }\n}\n\nconst instance = new ClassWithPrivateField();\ninstance.#privateField === 42; // 구문 오류\n```\n\n<div class=\"content-ad\"></div>\n\n- static 클래스 멤버: 클래스 필드(속성 및 메서드)를 static으로 표시하세요.\n\n```js\nclass Logger {\n  static id = 'Logger1';\n  static type = 'GenericLogger';\n  static log(message: string | Error) {\n    console.log(message);\n  }\n}\n\nclass ErrorLogger extends Logger {\n  static type = 'ErrorLogger';\n  static qualifiedType;\n  static log(e: Error) {\n    return super.log(e.toString());\n  }\n}\n\nconsole.log(Logger.type); // \"GenericLogger\"\nLogger.log('Test'); // \"Test\"\n\n// 정적으로만 있는 클래스를 생성하는 것은 무의미하지만 여기선 시연을 위해 수행되었습니다.\nconst log = new Logger();\n\nErrorLogger.log(new Error('Test')); // 에러: \"Test\" (부모 클래스의 생성에 영향을 받지 않음)\nconsole.log(ErrorLogger.type); // \"ErrorLogger\"\nconsole.log(ErrorLogger.qualifiedType); // undefined\nconsole.log(ErrorLogger.id); // \"Logger1\"\n\n// log()가 인스턴스 메서드가 아닌 정적 메서드이기 때문에 예외를 발생시킵니다.\nconsole.log(log.log()); // log.log is not a function\n```\n\n- 클래스 내의 정적 초기화 블록: 클래스가 초기화될 때 실행되는 블록, 기본적으로 정적 멤버를 초기화하는 \"생성자\"입니다.\n\n```js\nclass Test {\n  static staticProperty1 = '속성 1';\n  static staticProperty2;\n  static {\n    this.staticProperty2 = '속성 2';\n  }\n}\n\nconsole.log(Test.staticProperty1); // \"Property 1\"\nconsole.log(Test.staticProperty2); // \"Property 2\"\n```\n\n<div class=\"content-ad\"></div>\n\n- 가져오기 어설션 (비표준, V8에서 구현됨): 가져온 항목의 유형을 확인하기 위해 사용할 수 있습니다. `import ... from ... assert ' type: `json` '`로 JSON을 직접 가져오고 구문 분석할 필요 없이 사용할 수 있습니다.\n\n```js\nimport json from './foo.json' assert { type: 'json' };\nconsole.log(json.answer); // 42\n```\n\n- 정규표현식 일치 인덱스: 정규표현식 일치 및 캡처 그룹의 시작 및 끝 인덱스를 가져올 수 있습니다. RegExp.exec(), String.match() 및 String.matchAll()에 대해 작동합니다.\n\n```js\nconst matchObj = /(test+)(hello+)/d.exec('start-testesthello-stop');\n\n// 이전:\nconsole.log(matchObj?.index);\n\n// 새로운:\nif (matchObj) {\n  // 전체 일치 항목의 시작 및 끝 인덱스(이전에 시작만 있었음).\n  console.log(matchObj.indices[0]); // [9, 18]\n\n  // 캡처 그룹의 시작 및 끝 인덱스.\n  console.log(matchObj.indices[1]); // [9, 13]\n  console.log(matchObj.indices[2]); // [13, 18]\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- Negative indexing (.at(-1)): 배열이나 문자열을 인덱싱할 때, at()을 사용하여 뒤에서부터 인덱싱할 수 있습니다. 값 가져오기(arr[arr.length - 1]와 동일)만 가능하며 값을 설정할 수는 없습니다.\n\n```js\nconsole.log([4, 5].at(-1)) // 5\n\nconst array = [4, 5];\narray.at(-1) = 3; // SyntaxError: Assigning to rvalue\n```\n\n- hasOwn: 객체가 어떤 속성을 가지고 있는지 obj.hasOwnProperty()을 사용하는 대신 추천되는 새 방법입니다. 일부 특수한 경우에 더 잘 작동합니다.\n\n```js\nconst obj = { name: 'test' };\n\nconsole.log(Object.hasOwn(obj, 'name')); // true\nconsole.log(Object.hasOwn(obj, 'gender')); // false\n```\n\n<div class=\"content-ad\"></div>\n\n- 오류 원인: 이제 오류에 대한 선택적 원인을 지정할 수 있습니다. 이는 다시 throw할 때 원래 오류를 지정할 수 있게 합니다.\n\n```js\ntry {\n  try {\n    connectToDatabase();\n  } catch (err) {\n    throw new Error('데이터베이스 연결에 실패했습니다.', { cause: err });\n  }\n} catch (err) {\n  console.log(err.cause); // ReferenceError: connectToDatabase is not defined\n}\n```\n\n## 미래 (이미 TypeScript 4.9에서 사용 가능)\n\n- Auto-Accessor: 속성을 자동으로 비공개로 만들고 get/set 접근자를 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass Person {\n  accessir name: string;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name) // 'test'\n  }\n}\n\nconst person = new Person('test');\n```\n\n# TypeScript\n\n## 기초 (추후 소개를 위한 문맥)\n\n- 제네릭: 다른 유형으로 유형을 전달합니다. 이를 통해 유형을 일반화 할 수 있지만 여전히 유형 안전성을 유지할 수 있습니다. 항상 `any` 또는 `unknown` 대신 이를 선호해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// WITHOUT:\nfunction getFirstUnsafe(list: any[]): any {\n  return list[0];\n}\n\nconst firstUnsafe = getFirstUnsafe(['test']); // typed as any\n\n// WITH:\nfunction getFirst<Type>(list: Type[]): Type {\n  return list[0];\n}\n\nconst first = getFirst<string>(['test']); // typed as string\n\n// In this case the parameter can even be dropped because it is inferred from the argument.\nconst firstInferred = getFirst(['test']); // typed as string\n\n// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.\nclass List<T extends string | number> {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nconst list = new List<string>();\nlist.push(9); // Type error: Argument of type 'number' is not assignable to parameter of type 'string'.\nconst booleanList = new List<boolean>(); // Type error: Type 'boolean' does not satisfy the constraint 'string | number'.\n```\n\n## 과거 (아직도 유효한 이전 소개)\n\n- 유틸리티 타입: TypeScript에는 많은 유틸리티 타입이 포함되어 있으며, 그 중 가장 유용한 몇 가지가 여기에서 설명되었습니다.\n\n```js\ninterface Test {\n  name: string;\n  age: number;\n}\n\n// Partial 유틸리티 타입은 모든 속성을 선택적으로 만듭니다.\ntype TestPartial = Partial<Test>; // typed as { name?: string | undefined; age?: number | undefined; }\n// Required 유틸리티 타입은 반대로 동작합니다.\ntype TestRequired = Required<TestPartial>; // typed as { name: string; age: number; }\n// Readonly 유틸리티 타입은 모든 속성을 읽기 전용으로 만듭니다.\ntype TestReadonly = Readonly<Test>; // typed as { readonly name: string; readonly age: string }\n// Record 유틸리티 타입은 객체/맵/사전을 간단하게 정의할 수 있습니다. 가능한 경우에는 인덱스 시그니처보다 선호됩니다.\nconst config: Record<string, boolean> = { option: false, anotherOption: true };\n// Pick 유틸리티 타입은 지정된 속성만 가져옵니다.\ntype TestLess = Pick<Test, 'name'>; // typed as { name: string; }\ntype TestBoth = Pick<Test, 'name' | 'age'>; // typed as { name: string; age: string; }\n// Omit 유틸리티 타입은 지정된 속성을 무시합니다.\ntype TestFewer = Omit<Test, 'name'>; // typed as { age: string; }\ntype TestNone = Omit<Test, 'name' | 'age'>; // typed as {}\n// Parameters 유틸리티 타입은 함수 타입의 매개변수를 가져옵니다.\nfunction doSmth(value: string, anotherValue: number): string {\n  return 'test';\n}\ntype Params = Parameters<typeof doSmth>; // typed as [value: string, anotherValue: number]\n// ReturnType 유틸리티 타입은 함수 타입의 반환 타입을 가져옵니다.\ntype Return = ReturnType<typeof doSmth>; // typed as string\n\n// 이 외에도 많은 유틸리티 타입이 있으며, 그 중 일부는 아래에서 소개됩니다.\n```\n\n<div class=\"content-ad\"></div>\n\n- 조건부 타입: 어떤 타입이 다른 타입과 일치/확장되면 그에 따라 타입을 조건부로 설정합니다. 이는 JavaScript의 조건부(삼항) 연산자와 비슷하게 해석될 수 있습니다.\n\n```js\n// 배열인 경우에만 배열 타입을 추출하고, 그렇지 않으면 동일한 타입을 반환합니다.\ntype Flatten<T> = T extends any[] ? T[number] : T;\n\n// 요소 타입을 추출합니다.\ntype Str = Flatten<string[]>; // string 타입으로 지정됨\n\n// 타입을 그대로 유지합니다.\ntype Num = Flatten<number>; // number 타입으로 지정됨\n```\n\n- 조건부 타입으로 추론: 모든 일반 타입이 소비자에 의해 명시적으로 지정되어야 하는 것은 아닙니다. 일부는 코드로부터 추론될 수도 있습니다. 추론된 타입을 기반으로 조건부 논리를 작성하려면 infer 키워드가 필요합니다. 이는 일시적인 추론된 타입 변수를 정의하는 방식입니다.\n\n```js\n// 이전 예제를 기반으로 해서 더 깔끔하게 작성할 수 있습니다.\ntype FlattenOld<T> = T extends any[] ? T[number] : T;\n\n// 배열에서 직접 인덱싱하는 대신, 배열에서 항목(Item)의 타입을 추론할 수 있습니다.\ntype Flatten<T> = T extends (infer Item)[] ? Item : T;\n\n// 함수의 반환 타입을 가져오고, 그 외의 경우에는 undefined로 지정하는 타입을 작성할 수도 있습니다.\ntype GetReturnType<Type> = Type extends (...args: any[]) => infer Return ? Return : undefined;\n\ntype Num = GetReturnType<() => number>; // number 타입으로 지정됨\n\ntype Str = GetReturnType<(x: string) => string>; // string 타입으로 지정됨\n\ntype Bools = GetReturnType<(a: boolean, b: boolean) => void>; // undefined 타입으로 지정됨\n```\n\n<div class=\"content-ad\"></div>\n\n- 튜플 Optional Elements와 Rest: 튜플에서 `?`를 사용하여 옵셔널 요소를 선언하고, 다른 타입을 기반으로 나머지 요소를 사용할 수 있습니다.\n\n```js\n// 튜플의 길이를 아직 알 수 없지만 적어도 한 개는 있는 경우, `?`를 사용하여 옵셔널 타입을 지정할 수 있습니다.\nconst list: [number, number?, boolean?] = [];\nlist[0] // number 타입으로 지정됩니다\nlist[1] // number 또는 undefined 타입으로 지정됩니다\nlist[2] // boolean 또는 undefined 타입으로 지정됩니다\nlist[3] // Type error: 길이가 '3'인 '[number, (number | undefined)?, (boolean | undefined)?]' 형식의 튜플에는 '3' 인덱스 요소가 없습니다.\n\n// 기존 타입을 기반으로 튜플을 사용할 수도 있습니다.\n// 배열의 시작 부분에 패딩을 추가하려면 나머지 연산자 `...`를 사용할 수 있습니다.\nfunction padStart<T extends any[]>(arr: T, pad: string): [string, ...T] {\n  return [pad, ...arr];\n}\n\nconst padded = padStart([1, 2], 'test'); // [string, number, number] 타입으로 지정됩니다\n```\n\n- 추상 클래스와 메소드: 클래스와 그 내부 메소드를 추상으로 선언하여 인스턴스화되지 않도록 할 수 있습니다.\n\n```js\nabstract class Animal {\n  abstract makeSound(): void;\n\n  move(): void {\n    console.log('roaming the earth...');\n  }\n}\n\n// 추상 메소드는 확장 시 구현되어야 합니다.\nclass Cat extends Animal {} // 컴파일 오류: 추상 클래스 'Animal'로부터 상속된 추상 멤버 'makeSound'가 구현되지 않은 비-추상 클래스 'Cat'입니다.\n\nclass Dog extends Animal {\n  makeSound() {\n    console.log('woof');\n  }\n}\n\n// 추상 클래스는 (인터페이스처럼) 인스턴스화할 수 없으며, 추상 메소드는 호출할 수 없습니다.\nnew Animal(); // 컴파일 오류: 추상 클래스의 인스턴스를 생성할 수 없습니다.\n\nconst dog = new Dog().makeSound(); // \"woof\"가 출력됩니다\n```\n\n<div class=\"content-ad\"></div>\n\n- 생성자 서명: 클래스 선언 외부에서 생성자의 유형을 정의합니다. 대부분의 경우에 사용되지 않아야 하며, 추상 클래스 대신 사용할 수 있습니다.\n\n```js\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass AnotherTest {\n  age: number;\n}\n\nfunction makeObj(n: ConstructsMyInterface) {\n  return new n('hello!');\n}\n\nconst obj = makeObj(Test); // Test로 타입 지정됨\nconst anotherObj = makeObj(AnotherTest); // 타입 오류: 'AnotherTest'의 유형은 'ConstructsMyInterface'의 매개변수에 할당할 수 없습니다.\n```\n\n- ConstructorParameters 유틸리티 타입: TypeScript 도우미 함수로, 생성자 타입에서 생성자 매개변수를 가져옵니다 (클래스에서 가져오는 것이 아닙니다).\n\n```js\n// makeObj 함수에 생성자 인수를 얻고 싶다면?\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nfunction makeObj(test: ConstructsMyInterface, ...args: ConstructorParameters<ConstructsMyInterface>) {\n  return new test(...args);\n}\n\nmakeObj(Test); // 타입 오류: 2개의 매개변수가 필요하지만 1개만 전달되었습니다.\nconst obj = makeObj(Test, 'test'); // Test로 타입 지정됨\n```\n\n<div class=\"content-ad\"></div>\n\n## TypeScript 4.0\n\n- Variadic Tuple Types: 튜플에서의 나머지 요소는 이제 제네릭할 수 있습니다. 여러 개의 나머지 요소를 사용하는 것도 허용됩니다.\n\n```js\n// 만약 길이와 타입이 정의되지 않은 두 튜플을 결합하는 함수가 있다면 어떨까요? 반환 타입을 어떻게 정의할 수 있을까요?\n\n// 이전:\n// 우리는 몇 가지 오버로드를 작성할 수 있었습니다.\ndeclare function concat(arr1: [], arr2: []): [];\ndeclare function concat<A>(arr1: [A], arr2: []): [A];\ndeclare function concat<A, B>(arr1: [A], arr2: [B]): [A, B];\n// 이하 생략\n\n// 대신에 타입을 결합할 수 있습니다.\ndeclare function concatBetter<T, U>(arr1: T[], arr2: U[]): (T | U)[];\n// 그러나 이것은 (T | U)[]로 타입이 지정됩니다.\n\n// 새로운 기능:\n// 가변 길이 튜플 타입을 사용하면 쉽게 정의할 수 있고 길이 정보를 유지할 수 있습니다.\ndeclare function concatNew<T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U];\n\nconst tuple = concatNew([23, 'hey', false] as [number, string, boolean], [5, 99, 20] as [number, number, number]);\nconsole.log(tuple[0]); // 23\nconst element: number = tuple[1]; // 타입 오류: 타입 'string'을 'number'에 할당할 수 없습니다.\nconsole.log(tuple[6]); // 타입 오류: 길이 '6'인 튜플 타입 '[23, \"hey\", false, 5, 99, 20]'에는 인덱스 '6'에 요소가 없습니다.\n```\n\n- Labeled Tuple Elements: 튜플 요소는 이제 [start: number, end: number]와 같이 이름을 지정할 수 있습니다. 요소 중 하나가 이름이 지정되면 모두 이름이 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n혹시 클래스 생성자에서 속성이 설정될 때 속성의 타입을 자동으로 추론할 수 있어서 더 이상 수동으로 설정할 필요가 없습니다.\n\n```js\nclass Animal {\n  // 생성자에서 할당될 때 타입을 설정할 필요가 없습니다.\n  name;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name); // 문자열로 타입이 지정됨\n  }\n}\n```\n\n- JSDoc @deprecated 지원: JSDoc/TSDoc의 @deprecated 태그가 TypeScript에서 인식됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n/** @deprecated 메시지 */\ntype Test = string;\n\nconst test: Test = 'dfadsf'; // 타입 오류: '테스트'가 사용되지 않습니다.\n```\n\n## TypeScript 4.1\n\n- 템플릿 리터럴 타입: 리터럴 타입을 정의할 때, '$'를 이용하여 템플릿을 활용할 수 있습니다. 이를 통해 여러 개의 문자열 리터럴을 조합하는 등 복잡한 문자열 타입을 만들 수 있습니다.\n\n```js\ntype VerticalDirection = 'top' | 'bottom';\ntype HorizontalDirection = 'left' | 'right';\ntype Direction = `${VerticalDirection} ${HorizontalDirection}`;\n\nconst dir1: Direction = 'top left';\nconst dir2: Direction = 'left'; // 타입 오류: '\"left\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\nconst dir3: Direction = 'left top'; // 타입 오류: '\"left top\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\n\n// 이는 제네릭 및 새로운 유틸리티 타입과도 결합할 수 있습니다.\ndeclare function makeId<T extends string, U extends string>(first: T, second: U): `${Capitalize<T>}-${Lowercase<U>}`;\n```\n\n<div class=\"content-ad\"></div>\n\n- 키 다시 매핑하기: 매핑된 타입을 다시 정의하여 그 값들을 사용할 수 있습니다. [K in keyof T as NewKeyType]: T[K].\n\n```js\n// 예를 들어, 객체를 다시 포맷하되 그 ID 앞에 밑줄을 추가하고 싶다고 가정해 봅시다.\nconst obj = { value1: 0, value2: 1, value3: 3 };\nconst newObj: { [Property in keyof typeof obj as `_${Property}`]: number }; // { _value1: number; _value2: number; value3: number; }로 타입이 지정됩니다.\n```\n\n- 재귀 조건부 타입: 조건부 타입을 해당 정의 내부에서 사용합니다. 이를 통해 무한히 중첩된 값을 조건부적으로 언패킹하는 타입을 생성할 수 있습니다.\n\n```js\ntype Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;\n\ntype P1 = Awaited<string>; // string으로 타입이 지정됩니다.\ntype P2 = Awaited<Promise<string>>; // string으로 타입이 지정됩니다.\ntype P3 = Awaited<Promise<Promise<string>>>; // string으로 타입이 지정됩니다.\n```\n\n<div class=\"content-ad\"></div>\n\n- JSDOC @see 태그를 지원하는 편집기: 이제 편집기에서 JSDoc/TSDoc @see 변수/유형/링크 태그가 지원됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * 다른 값의 복사본\n * @see originalValue\n */\nconst value = originalValue;\n```\n\n- tsc --explainFiles: --explainFiles 옵션은 TypeScript CLI에서 컴파일에 사용된 파일과 그 이유를 설명해주는 데 사용될 수 있습니다. 이는 디버깅에 유용할 수 있습니다. 경고: 대규모 프로젝트나 복잡한 설정의 경우 많은 출력물이 생성됩니다. 대신 tsc --explainFiles | less 또는 비슷한 방법을 사용하십시오.\n\n```js\ntsc --explainFiles\n\n<<output\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es5.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n...\noutput\n```\n\n<div class=\"content-ad\"></div>\n\n- Destructured 변수는 명시적으로 사용되지 않음을 표시할 수 있습니다: 구조 분해할 때 밑줄을 사용하여 변수가 사용되지 않음을 표시할 수 있습니다. 이를 통해 TypeScript에서 \"사용되지 않는 변수\" 오류를 방지할 수 있습니다.\n\n```js\nconst [_first, second] = [3, 5];\nconsole.log(second);\n\n// 심지어 더 짧게\nconst [_, value] = [3, 5];\nconsole.log(value);\n```\n\n## TypeScript 4.3\n\n- 속성에 대한 별도의 쓰기 유형: set/get 접근자를 정의할 때, 쓰기/설정 형식이 읽기/가져오기 형식과 다를 수 있습니다. 이를 통해 동일한 값의 여러 형식을 수락하는 setter를 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass Test {\n  private _value: number;\n\n  get value(): number {\n    return this._value;\n  }\n\n  set value(value: number | string) {\n    if (typeof value === 'number') {\n      this._value = value;\n      return;\n    }\n    this._value = parseInt(value, 10);\n  }\n}\n```\n\n- override: 상속된 클래스 메서드를 명확하게 오버라이드로 표시하기 위해 override를 사용하세요. 부모 클래스가 변경되면 TypeScript에서 부모 메서드가 더 이상 존재하지 않음을 알려줄 수 있습니다. 이를 통해 더 안전한 복잡한 상속 패턴을 구현할 수 있습니다.\n\n```js\nclass Parent {\n  getName(): string {\n    return 'name';\n  }\n}\n\nclass NewParent {\n  getFirstName(): string {\n    return 'name';\n  }\n}\n\nclass Test extends Parent {\n  override getName(): string {\n    return 'test';\n  }\n}\n\nclass NewTest extends NewParent {\n  override getName(): string { // Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.\n    return 'test';\n  }\n}\n```\n\n- static Index Signatures: 클래스에서 정적 속성을 사용할 때, 정적 [propName: string]: string을 사용하여 색인 서명을 설정할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이전 코드:\nclass Test {}\n\nTest.test = ''; // 타입 오류: 'test' 속성을 'Test' 형식에서 찾을 수 없습니다.\n\n// 새로운 코드:\nclass NewTest {\n  static [key: string]: string;\n}\n\nNewTest.test = '';\n```\n\n- JSDOC @link 태그를 위한 편집기 지원: JSDoc/TSDoc의 '@link 변수/타입/링크' 인라인 태그가 이제 지원되며 편집기에서 표시되고 해결됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * {@link originalValue}의 복사본\n */\nconst value = originalValue;\n```\n\n## TypeScript 4.4\n\n<div class=\"content-ad\"></div>\n\n- 정확한 선택적 속성 유형 (--exactOptionalPropertyTypes): 컴파일러 플래그 --exactOptionalPropertyTypes (또는 tsconfig.json에)를 사용하면, 암시적으로 undefined를 허용하는 속성에 대해 undefined로 할당하는 것이 허용되지 않습니다 (예: property?: string). 대신, property: string | undefined와 같이 명시적으로 undefined를 허용해야 합니다.\n\n```js\nclass Test {\n  name?: string;\n  age: number | undefined;\n}\n\nconst test = new Test();\ntest.name = undefined; // 타입 오류: 'exactOptionalPropertyTypes: true'를 사용하여 'undefined' 타입을 'string'에 할당할 수 없습니다. 대상의 유형에 'undefined'를 추가하는 것을 고려해보세요.\ntest.age = undefined;\nconsole.log(test.age); // undefined\n```\n\n## TypeScript 4.5\n\n- Awaited`` 유형 및 Promise 개선: 새로운 Awaited`` 유틸리티 유형은 무한히 중첩된 Promises에서 값 유형을 추출합니다 (값에 대해 await이 하는 것과 같이). 이는 또한 Promise.all()에 대한 유형 추론을 개선했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 제네릭 대기값을 가지고 싶다고 가정해 봅시다.\n// 이러한 경우 Awaited 유틸리티 타입을 사용할 수 있습니다 (소스 코드는 이전 예제의 일부였습니다).\n// 따라서 무한하게 중첩된 Promises가 모두 값으로 해결됩니다.\ntype P1 = Awaited<string>; // 문자열로 타입 지정\ntype P2 = Awaited<Promise<string>>; // 문자열로 타입 지정\ntype P3 = Awaited<Promise<Promise<string>>>; // 문자열로 타입 지정\n```\n\n- Import 이름에 대한 유형 수식어: 일반 (import type 아닌) import 문 안에서 type 키워드를 사용하여 해당 값이 유형 컴파일을 위해만 가져와야 함을 신호로 삼을 수 있습니다 (컴파일 후에 제거할 수 있습니다).\n\n```js\n// 이전:\n// 유형을 가져오는 가장 좋은 방법은 `import type` 키워드를 사용하여 컴파일 이후에 실제로 가져오지 않도록 하는 것입니다.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// 이 파일에 대해 두 개의 import 문이 필요했습니다.\n\n// 새로운:\n// 이제 이를 하나의 문으로 결합할 수 있습니다.\nimport { something, type SomeType } from './file';\n```\n\n- Const 어순: 상수를 정의할 때 const 키워드를 사용하여 이를 리터럴 타입으로 정확하게 지정할 수 있습니다. 이는 다양한 용례가 있으며 정확한 유형 정의가 쉬워집니다. 또한 상수 객체와 배열은 읽기 전용이 되어 상수 객체의 변이를 방지합니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\n// 이전:\nconst obj = { name: 'foo', value: 9, toggle: false }; // { name: string; value: number; toggle: boolean; }으로 타입 지정됨\n// 일반적으로 타입이 지정되어 있으므로 어느 값이든 할당 가능합니다.\nobj.name = 'bar';\n\nconst tuple = ['name', 4, true]; // (string | number | boolean)[]으로 타입 지정됨\n// 타입으로 길이와 정확한 형식을 결정할 수 없습니다. 어떤 값이든 어디에든 할당할 수 있습니다.\ntuple[0] = 0;\ntuple[3] = 0;\n\n// 새로운 방식:\nconst objNew = { name: 'foo', value: 9, toggle: false } as const; // { readonly name: \"foo\"; readonly value: 9; readonly toggle: false; }으로 타입 지정됨\n// 값을 할당할 수 없습니다 (\"foo\"(그리고 readonly로 정의되었기 때문).\nobjNew.name = 'bar'; // 타입 에러: 'name'에 할당할 수 없습니다. 읽기 전용 속성입니다.\n\nconst tupleNew = ['name', 4, true] as const; // readonly [\"name\", 4, true]으로 타입 지정됨\n// 이제 길이와 정확한 형식이 정의되어 있고, 값을 할당할 수 없습니다 (리터럴로 정의되었으며 readonly).\ntupleNew[0] = 0; // 타입 에러: '0'에 할당할 수 없습니다. 읽기 전용 속성입니다.\ntupleNew[3] = 0; // 타입 에러: 'readonly[\"name\", 4, true]'에 있는 인덱스 서명에는 읽기만 허용됩니다.\n```\n\n- 클래스 내의 메서드에 대한 코드 조각 완성: 클래스가 메서드 타입을 상속하면 편집기에서 코드 조각으로 제안됩니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:800/1*31No189vLt2Kdx5Ay_Ihig.gif\" />\n\n## TypeScript 4.6\n\n<div class=\"content-ad\"></div>\n\n- 인덱스된 액세스 추론 개선: 키로 직접 타입을 색인화할 때, 이제 같은 객체에 있는 경우 타입이 더 정확해집니다. 현대적인 TypeScript로 어떤 것이 가능한지 보여주는 좋은 예시입니다.\n\n```js\ninterface AllowedTypes {\n  'number': number;\n  'string': string;\n  'boolean': boolean;\n}\n\n// Record는 허용된 타입의 종류와 값 타입을 지정합니다.\ntype UnionRecord<AllowedKeys extends keyof AllowedTypes> = { [Key in AllowedKeys]:\n{\n  kind: Key;\n  value: AllowedTypes[Key];\n  logValue: (value: AllowedTypes[Key]) => void;\n}\n}[AllowedKeys];\n\n// 함수 logValue는 Record의 값만을 허용합니다.\nfunction processRecord<Key extends keyof AllowedTypes>(record: UnionRecord<Key>) {\n  record.logValue(record.value);\n}\n\nprocessRecord({\n  kind: 'string',\n  value: 'hello!',\n\n  // 값이 암묵적으로 string | number | boolean 타입을 가졌던 것이\n  // 이제 올바르게 오직 string으로 추론됩니다.\n  logValue: value => {\n    console.log(value.toUpperCase());\n  }\n});\n```\n\n- TypeScript 추적 분석기 (--generateTrace): --generateTrace '출력 폴더' 옵션을 사용하여 TypeScript CLI가 타입 검사 및 컴파일 프로세스에 대한 자세한 내용을 포함한 파일을 생성할 수 있습니다. 이는 복잡한 타입을 최적화하는 데 도움이 될 수 있습니다.\n\n```js\ntsc --generateTrace trace\n\ncat trace/trace.json\n<<출력\n[\n{\"name\":\"process_name\",\"args\":{\"name\":\"tsc\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"thread_name\",\"args\":{\"name\":\"Main\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"TracingStartedInBrowser\",\"cat\":\"disabled-by-default-devtools.timeline\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"program\",\"ts\":...,\"name\":\"createProgram\",\"args\":{\"configFilePath\":\"/...\",\"rootDir\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"E\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"X\",\"cat\":\"program\",\"ts\":...,\"name\":\"resolveModuleNamesWorker\",\"dur\":...,\"args\":{\"containingFileName\":\"/...\"},\n...\n출력\n\ncat trace/types.json\n<<출력\n[{\"id\":1,\"intrinsicName\":\"any\",\"recursionId\":0,\"flags\":[\"...\"]},\n{\"id\":2,\"intrinsicName\":\"any\",\"recursionId\":1,\"flags\":[\"...\"]},\n{\"id\":3,\"intrinsicName\":\"any\",\"recursionId\":2,\"flags\":[\"...\"]},\n{\"id\":4,\"intrinsicName\":\"error\",\"recursionId\":3,\"flags\":[\"...\"]},\n{\"id\":5,\"intrinsicName\":\"unresolved\",\"recursionId\":4,\"flags\":[\"...\"]},\n{\"id\":6,\"intrinsicName\":\"any\",\"recursionId\":5,\"flags\":[\"...\"]},\n{\"id\":7,\"intrinsicName\":\"intrinsic\",\"recursionId\":6,\"flags\":[\"...\"]},\n{\"id\":8,\"intrinsicName\":\"unknown\",\"recursionId\":7,\"flags\":[\"...\"]},\n{\"id\":9,\"intrinsicName\":\"unknown\",\"recursionId\":8,\"flags\":[\"...\"]},\n{\"id\":10,\"intrinsicName\":\"undefined\",\"recursionId\":9,\"flags\":[\"...\"]},\n{\"id\":11,\"intrinsicName\":\"undefined\",\"recursionId\":10,\"flags\":[\"...\"]},\n{\"id\":12,\"intrinsicName\":\"null\",\"recursionId\":11,\"flags\":[\"...\"]},\n{\"id\":13,\"intrinsicName\":\"string\",\"recursionId\":12,\"flags\":[\"...\"]},\n...\n출력\n```\n\n<div class=\"content-ad\"></div>\n\n## TypeScript 4.7\n\n- Node.js에서 ECMAScript 모듈 지원: CommonJS 대신 ES 모듈을 사용할 때, TypeScript가 이제 default를 지정할 수 있습니다. tsconfig.json에서 지정하세요.\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"module\": \"es2020\"\n]\n...\n```\n\n- package.json의 type: package.json의 type 필드를 \"module\"로 설정할 수 있습니다. 이것은 Node.js와 ES 모듈을 사용하기 위해 필요합니다. 대부분의 경우에 TypeScript에 충분하며 위의 컴파일러 옵션이 필요하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n\"type\": \"module\"\n...\n```\n\n- 인스턴스화 표현식: 인스턴스화 표현식을 사용하면 값을 참조할 때 유형 매개변수를 지정할 수 있습니다. 이를 통해 래퍼를 생성하지 않고 일반적인 유형을 좁힐 수 있습니다.\n\n```js\nclass List<T> {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nfunction makeList<T>(items: T[]): List<T> {\n  const list = new List<T>();\n  items.forEach(item => list.push(item));\n  return list;\n}\n\n// 특정 값만 허용하는 목록을 만드는 함수가 필요한 경우를 가정해 봅시다.\n// 이전:\n// 직접 래퍼 함수를 정의하고 인수를 전달해야 했습니다.\nfunction makeStringList(text: string[]) {\n  return makeList(text);\n}\n\n// 새로운 방법:\n// 인스턴스화 표현식을 사용하면 훨씬 쉽습니다.\nconst makeNumberList = makeList<number>;\n```\n\n- 추론된 유형 변수에 대한 extend 제한: 조건부 유형에서 유형 변수를 추론할 때, extends를 사용하여 직접 좁히거나 제한할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 배열의 첫 번째 요소가 문자열인 경우에만 해당 요소를 가져오는 유형을 작성하려고 한다고 가정해 봅시다.\n// 이를 위해 조건부 유형을 사용할 수 있습니다.\n\n// 이전:\ntype FirstIfStringOld<T> =\n  T extends [infer S, ...unknown[]]\n    ? S extends string ? S : never\n    : never;\n\n// 그러나 이 방법은 두 개의 중첩된 조건부 유형이 필요합니다. 이를 하나의 유형으로도 할 수 있습니다.\ntype FirstIfString<T> =\n  T extends [string, ...unknown[]]\n    // `T`에서 첫 번째 유형을 가져옵니다.\n    ? T[0]\n    : never;\n\n// 이것도 여전히 최적화되지 않은 상태이며 올바른 유형을 위해 배열을 인덱싱해야 합니다.\n\n// 새로운 방식:\n// 추론된 유형 변수에 extends 제약 조건을 사용하여 이를 더 간단하게 선언할 수 있습니다.\ntype FirstIfStringNew<T> =\n  T extends [infer S extends string, ...unknown[]]\n    ? S\n    : never;\n// 유형을 알아내는 방식은 이전과 동일하지만 더 깔끔한 구문입니다.\n\ntype A = FirstIfStringNew<[string, number, number]>; // string으로 유형 지정\ntype B = FirstIfStringNew<[\"hello\", number, number]>; // \"hello\"로 유형 지정\ntype C = FirstIfStringNew<[\"hello\" | \"world\", boolean]>; // \"hello\" 또는 \"world\"로 유형 지정\ntype D = FirstIfStringNew<[boolean, number, string]>; // never로 유형 지정\n```\n\n- 유형 매개변수를 위한 선택적 분산 주석: 제네릭은 \"일치하는지\" 확인할 때 다른 동작을 가질 수 있습니다. 예를 들어, 상속을 허용할 경우 getters 및 setters에 대해 반대로 반전됩니다. 이제 이를 명시적으로 지정할 수 있습니다.\n\n```js\n// 다른 인터페이스 / 클래스를 확장하는 인터페이스가 있다고 가정해 봅시다.\ninterface Animal {\n  animalStuff: any;\n}\n\ninterface Dog extends Animal {\n  dogStuff: any;\n}\n\n// 그리고 일반적인 \"getter\" 및 \"setter\"가 있습니다.\ntype Getter<T> = () => T;\n\ntype Setter<T> = (value: T) => void;\n\n// Getter<T1>과 Getter<T2> 또는 Setter<T1>과 Setter<T2>가 일치하는지 확인하려면 분산에 따라 달라집니다.\nfunction useAnimalGetter(getter: Getter<Animal>) {\n  getter();\n}\n\n// 이제 함수에 Getter를 전달할 수 있습니다.\nuseAnimalGetter((() => ({ animalStuff: 0 }) as Animal));\n// 당연히 작동합니다.\n\n// 그러나 Dog를 반환하는 Getter를 사용하려면 어떻게 해야 할까요?\nuseAnimalGetter((() => ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// 이 또한 작동합니다. 왜냐하면 Dog도 Animal이기 때문입니다.\n\nfunction useDogGetter(getter: Getter<Dog>) {\n  getter();\n}\n\n// useDogGetter 함수에 동일한 작업을 시도하면 동일한 동작을 얻지 못할 것입니다.\nuseDogGetter((() => ({ animalStuff: 0 }) as Animal); // Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.\n// 이는 Animal이 아닌 Dog가 필요하기 때문에 작동하지 않습니다.\n\nuseDogGetter((() => ({ animalStuff: 0, dogStuff: 0 }) as Dog);\n// 그러나 이 경우는 작동합니다.\n\n// 직관적으로 Setters가 같은 방식으로 작동할 것으로 기대할 수도 있지만, 사실은 그렇지 않습니다.\nfunction setAnimalSetter(setter: Setter<Animal>, value: Animal) {\n  setter(value);\n}\n\n// 동일한 유형의 Setter를 전달해도 작동합니다.\nsetAnimalSetter((value: Animal) => {}, { animalStuff: 0 });\n\nfunction setDogSetter(setter: Setter<Dog>, value: Dog) {\n  setter(value);\n}\n\n// 여기도 마찬가지로 작동합니다.\nsetDogSetter((value: Dog) => {}, { animalStuff: 0, dogStuff: 0 });\n\n// 그러나 Dog Setter를 setAnimalSetter 함수에 전달하면 Getter와는 반대로 동작이 반전됩니다.\nsetAnimalSetter((value: Dog) => {}, { animalStuff: 0, dogStuff: 0 }); // Type error: Argument of type '(value: Dog) => void' is not assignable to parameter of type 'Setter<Animal>'.\n\n// 이번에는 상황이 반대로 작동합니다.\nsetDogSetter((value: Animal) => {}, { animalStuff: 0, dogStuff: 0 });\n\n// 새로운 방법:\n// TypeScript에이를 표시하기 위해 (필수는 아니지만 가독성을 위해 유용), 유형 매개변수에 대한 선택적 분산 주석을 사용합니다.\ntype GetterNew<out T> = () => T;\ntype SetterNew<in T> = (value: T) => void;\n```\n\n- moduleSuffixes로 해상도 사용자 정의: 사용자 정의 파일 접미사를 사용하는 환경(예: 네이티브 앱 빌드에 .ios를 사용하는 경우)에서는 TypeScript가 가져오기를 정확하게 해석하도록 이 접미사를 tsconfig.json에 지정할 수 있습니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"moduleSuffixes\": [\".ios\", \".native\", \"\"]\n]\n...\n```\n\n```js\nimport * as foo from './foo';\n// 이 코드는 먼저 ./foo.ios.ts를 확인하고, 그 다음에는 ./foo.native.ts를, 마지막으로 ./foo.ts를 확인합니다.\n```\n\n- 에디터에서 소스 정의로 이동: 에디터에서 새로운 \"소스 정의로 이동\" 메뉴 옵션이 사용 가능합니다. 이는 \"정의로 이동\"과 유사하지만, .ts 및 .js 파일을 .d.ts 타입 정의 파일보다 우선합니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:800/1*y45nF8mb-nfBuVIUPt7KJQ.gif\" />\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*qvzGqfF844cXCPMeDrg_IQ.gif)\n\n## TypeScript 4.9\n\n- `satisfies` 연산자: `satisfies` 연산자는 실제로 그 타입을 할당하지 않고도 타입과의 호환성을 확인할 수 있게 해줍니다. 이를 통해 더 정확한 추론된 타입을 유지하면서도 호환성을 유지할 수 있습니다.\n\n```js\n// 이전:\n// 여러 항목과 그 색상을 저장하는 객체/맵/딕셔너리가 있다고 가정해 보겠습니다.\nconst obj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // { fireTruck: number[]; bush: string; ocean: number[]; } 타입으로 정의됨\n\n// 배열과 문자열에 대해 작업을 수행할 수 있도록 속성을 암시적으로 타입 지정합니다.\nconst rgb1 = obj.fireTruck[0]; // 숫자로 타입 지정\nconst hex = obj.bush; // 문자열로 타입 지정\n\n// 특정 객체만 허용하고 싶다면 Record 타입을 사용할 수 있습니다.\nconst oldObj: Record<string, [number, number, number] | string> = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // Record<string, [number, number, number] | string> 타입으로 정의됨\n// 하지만 이제 우리는 속성의 타입에 대한 정보를 잃어버립니다.\nconst oldRgb1 = oldObj.fireTruck[0]; // string 또는 number로 타입 지정\nconst oldHex = oldObj.bush; // string 또는 number로 타입 지정\n\n// 새롭게:\n// `satisfies` 키워드를 사용하여 타입과 호환성을 확인할 수 있습니다.\nconst newObj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} satisfies Record<string, [number, number, number] | string> // { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; } 타입으로 정의됨\n// 이제 속성의 타입에 대한 정보를 유지할 수 있을 뿐만 아니라 배열은 튜플로 더 정확해집니다.\nconst newRgb1 = newObj.fireTruck[0]; // 숫자로 타입 지정\nconst newRgb4 = newObj.fireTruck[3]; // 타입 오류: 길이가 '3'인 튜플 타입 '[number, number, number]'에는 인덱스 '3'에 해당하는 요소가 없습니다.\nconst newHex = newObj.bush; // 문자열로 타입 지정\n```\n\n<div class=\"content-ad\"></div>\n\n- 편집기의 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령: 편집기에서 새로운 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령(및 자동 수정)을 사용하면 Imports를 관리하는 것이 더 쉬워집니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*z5SG6BKwzyxrG6sG7OKciw.gif)\n\n## TypeScript 5.0\n\n- ES 데코레이터 지원: TypeScript는 이제 ES 데코레이터(곧 나올 ES 기능)를 지원하며, 기존 데코레이터와는 다릅니다. 이전에 TypeScript는 데코레이터에 대해 실험적인 지원을 했었는데, 이는 Angular와 같은 프레임워크에서 사용되는 것으로, --experimentalDecorators 플래그(또는 tsconfig.json에서)로 선택할 수 있었으며 약간 다르게 동작했습니다. 그러나 이제 새로운 ES 데코레이터는 이전 것과는 다르게 메타데이터를 내보내지 못하며 아직은 매개변수에서도 지원되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 주의: 2023년 5월 기준으로 이것은 예정된 ES 기능이므로 이 코드는 아직 작동하지 않습니다.\n\n// 디버깅 중에 메서드에 진입하거나 나갈 때마다 기록하려고 합니다.\n// 이것을 수동으로 하는 것은 상당히 지루할 수 있습니다. 자동화할 방법이 있을까요?\n// 네, 데코레이터를 사용하여 실행 컨텍스트를 대체할 수 있습니다.\n\n// 먼저 데코레이터 역할을 할 함수를 정의합니다. 이 함수는 원본 메서드와 컨텍스트 개체를 매개변수로 받아 새로운 실행 함수를 반환합니다.\nfunction logMethod<This, Args extends any[], Return>(originalMethod: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext) {\n  const methodName = String(context.name);\n\n  function replacementFunction(this: This, ...args: Args) {\n    console.log(`LOG: 메서드 '${methodName}' 진입 중.`)\n    const result = originalMethod.call(this, ...args);\n    console.log(`LOG: 메서드 '${methodName}' 나감.`)\n    return result;\n  }\n\n  return replacementFunction;\n}\n\n// 이제 이를 사용할 클래스를 정의합니다. 데코레이터는 클래스와 그 멤버에만 작동합니다.\n// 메서드에 '@'와 함수명을 사용하여 데코레이터를 적용합니다.\nclass Test {\n  @logMethod\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testObj = new Test();\n\n// 메서드를 실행하면 대체 메서드가 호출됩니다.\nconsole.log(testObj.doSomething()); // \"LOG: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"LOG: 메서드 'doSomething' 나감.\"\n\n// 사용자 정의 메시지와 같은 추가 인수를 전달하려면 데코레이터 팩토리(데코레이터 함수를 반환하는 함수)를 정의할 수 있습니다.\nfunction logMethodCustom(customMessage: string) {\n  return <This, Args extends any[], Return>(originalMethod: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext) => {\n    const methodName = String(context.name);\n\n    function replacementFunction(this: This, ...args: Args) {\n      console.log(`${customMessage}: 메서드 '${methodName}' 진입 중.`)\n      const result = originalMethod.call(this, ...args);\n      console.log(`${customMessage}: 메서드 '${methodName}' 나감.`)\n      return result;\n    }\n\n    return replacementFunction;\n  }\n}\n\n// 이번에는 함수 호출을 포함하는 `()`로 된 추가 인수를 사용하여 메서드에 데코레이터를 적용합니다.\nclass TestCustom {\n  @logMethodCustom('테스트 로그')\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testCustomObj = new Test();\n\n// 메서드 실행시 모든 작업이 예상대로 작동합니다.\nconsole.log(testCustomObj.doSomething()); // \"테스트 로그: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"테스트 로그: 메서드 'doSomething' 나감.\"\n\n// 데코레이터 함수에서 대체 메서드를 반환하지 않으면 원본 메서드가 호출되지만 관련 설정을 아직 설정할 수 있습니다.\n// 예를 들어 `constructor` 단계 이전에 `this`를 바인딩하여 클래스 외부에서 콜백으로 전달할 경우 동일하게 실행되도록합니다.\n// `constructor` 단계 이전에 코드를 실행하려면 컨텍스트 개체의 `addInitializer` 메서드를 사용할 수 있습니다.\nfunction bindThis(_: unknown, context: ClassMethodDecoratorContext) {\nconst methodName = context.name;\nif (context.private) {\n  throw new Error(`'bound'는 ${methodName as string}과 같은 비공개 속성을 데코레이션할 수 없습니다.`);\n}\ncontext.addInitializer(function (this: any) {\n  const methodName = context.name;\n    if (typeof methodName === 'string') {\n      this[methodName] = this[methodName].bind(this);\n    }\n  });\n}\n\n// 바인딩하지 않은 상태로 한번 정의합니다.\nclass TestUnbound {\n  private returnVal = '작업 중';\n\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testUnboundObj = new TestUnbound();\n\n// 메서드에 다시 \"데코레이터\"를 적용합니다.\nclass TestBound {\n  private returnVal = '작업 중';\n\n  @bindThis\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testBoundObj = new TestBound();\n\n// 클래스 컨텍스트 외부에 메서드를 저장하고 실행시키면 속성 값에 액세스할 수 없습니다.\nconst unboundFunc = testUnboundObj.doSomething;\nconsole.log(unboundFunc()); // 오류: \"Cannot read properties of undefined (reading 'returnVal')\"\n\n// 그러나 바인딩하면 예상대로 작동합니다.\nconst boundFunc = testBoundObj.doSomething;\nconsole.log(boundFunc()); // \"작업 중\"\n```\n\n- const 형식 매개변수: 형식 매개변수 앞에 const를 지정하는 const는 readonly 형식을 그대로 사용하는 것처럼 동작하도록 시도합니다. 그러나 변경 가능한 값을 형식화했다면 인자유추가 작동하지 않을 수 있습니다(왜냐하면 읽기전용 형식은 변경 가능한 형식에 할당할 수 없기 때문에 항상 readonly 형식을 상속해야 합니다). 이것은 여전히 허용된 매개변수를 제한하지 않습니다. 여전히 extends 내에서 제한해야 합니다.\n\n- 타입을 활용한 여러 구성 파일 지원: 복잡한 상속 구조를 만들거나 모든 \"tsconfig\"에서 항상 동일한 구성을 확장하거나 모든 설정을 복사하여 모두 복사하는 대신, \"tsconfig\" 파일에서 \"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"]를 지정함으로써 여러 파일을 확장하여 동작을 재정의할 수 있습니다. 후자의 파일이 오버라이드 동작을 우선시합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n...\n// 여기서 \"tsconfig1.json\"은 \"@tsconfig/strictest/tsconfig.json\"을 덮어씁니다. \"tsconfig2.json\"은 \"tsconfig1.json\"과 \"@tsconfig/strictest/tsconfig.json\"을 덮어쓰며, 이 파일은 모두 덮어씁니다.\n\"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"./tsconfig1.json\", \"./tsconfig2.json\"],\n...\n```\n\n- 모든 열거형이 합집합 열거형입니다: 동적으로 할당된 열거형 값은 이제 더 이상 예전의 열거형 전략 기본값을 갖지 않습니다(열거형 키에 대한 타입 없음, 값으로만 사용 가능하며 타입으로 사용할 수 없음). 대신 이제 타입으로도 사용할 수 있습니다.\n\n```js\n// 열거형은 각 값마다 다른 타입을 만듭니다.\nenum Color {\n  Red, Green, Blue, Orange, Yellow, Violet\n}\n\n// 이를 통해 그들을 좁히고 다른 타입처럼 사용할 수 있습니다.\ntype PrimaryColor = Color.Red | Color.Green | Color.Blue;\n\n// 하지만:\n// 값이 동적으로 할당되면 고정된 값이 없습니다.\n// 이전에는 예전 열거형 동작으로 되돌아가게 되었습니다.\n// 예전 열거형 동작에서 그 멤버는 값으로만 존재하며 타입으로는 존재하지 않음.\nenum ColorRandom {\n  Red = Math.random(),\n  Green = Math.random(),\n  Blue = Math.random(),\n  Orange = Math.random(),\n  Yellow = Math.random(),\n  Violet = Math.random()\n}\n\n// 그래서 이전에는 좁혀지지 못했습니다.\ntype PrimaryColorRandom = ColorRandom.Red | ColorRandom.Green | ColorRandom.Blue; // 이전 타입 오류: Enum 타입 'ColorRandom'은 리터럴이 아닌 초기화 값을 갖는 멤버를 가지고 있습니다.\n// 하지만 이제 그들에게도 자체 타입이 있기 때문에 작동합니다.\n```\n\n- --moduleResolution bundler: TS 4.7의 모듈 해결 전략 \"node16\"은 ES 모듈을 더 잘 모델링할 수 있게 해주지만 일부 불필요한 제약이 있었습니다(파일 확장자를 명시해야 했으며, ...). 번들러를 사용 중이라면, 새 전략은 최신 기능을 유지하면서 일부 제약을 제거하려고 시도합니다. 컴파일러 플래그 --moduleResolution bundle를 지정하여 사용할 수 있습니다(또는 tsconfig.json에서). 번들러를 사용할 때만 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"moduleResolution\": \"bundler\"\n]\n...\n```\n\n```json\nimport * as foo from './foo';\n// 이제는 파일 확장자가 지정되지 않아도 다시 허용됩니다.\n```\n\n- 해상도 Customization Flags: \"hybrid\" 모듈 해상도에 대한 규칙을 설정합니다. 규칙은 다음과 같습니다: allowImportingTsExtensions, resolvePackageJsonExports (imports를 위해 package.json exports을 고려함), resolvePackageJsonImports (#로 시작하는 경로를 위해 로컬 package.json을 참조함), allowArbitraryExtensions 및 customConditions (node16 및 bundler 전용, package.json에서 조건부 exports 및 imports을 위해 사용됨)입니다. 이러한 모든 설정은 --를 접두사로 하여 컴파일러 플래그로 지정하거나 tsconfig.json에 지정할 수 있습니다.\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"allowImportingTsExtensions\": false,\n  \"resolvePackageJsonExports\": true,\n  \"resolvePackageJsonImports\": true,\n  \"allowArbitraryExtensions\": false,\n  \"customConditions\": [\"my-condition\"]\n  // 이제는 `package.json`의 `exports` 및 `imports`에 대한 사용자 정의 조건을 해결하려고 시도합니다.\n  // TS는 그런 다음 해당 사용자 정의 조건에 맞도록 파일을 매칭하려고 할 것입니다 (이 경우 `foo.mjs`).\n]\n...\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  ...\n  \"exports\": {\n    \".\": {\n      \"my-condition\": \"./foo.mjs\",\n      \"node\": \"./bar.mjs\",\n      \"import\": \"./baz.mjs\",\n      \"require\": \"./biz.mjs\"\n    }\n  }\n}\n```\n\n- **--verbatimModuleSyntax:** 자동으로 import (import elision) 및 exports를 제거하지 않도록 TypeScript를 중지합니다. 이것은 import side effects가 사용될 때 또는 TS가 import가 어디에서 사용되는지 인식하지 못할 때 유용할 수 있습니다. import type 및 export type 문은 여전히 최종 컴파일에서 제거됩니다. 대개 import가 타입인지 아닌지 명시하는 것이 권장됩니다. compiler flag --verbatimModuleSyntax(또는 tsconfig.json에서)를 지정하여 사용할 수 있습니다.\n\n```js\n// `verbatimModuleSyntax`가 설정되지 않으면 이 import는 최종 컴파일에서 제거될 것입니다.\nimport { Car } from './car';\n// 이 import는 아무 경우에나 제거될 것입니다.\nimport type { Car } from './car';\n// 이 import는 절대로 제거되지 않습니다.\nimport { logCar } from './car';\n\nexport function drive(car: Car) {\n  logCar(car);\n  // ...\n}\n```\n\n- **export type * 지원:** 기본 형식을 하위 모듈로 쉽게 다시 내보낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 기본 타입들을 다른 모듈로서 서브모듈로 내보냅니다.\nexport type * as am from 'another-module';\n// 또는 다시 기본 내보낸 것으로 제공합니다.\nexport type * from 'another-module';\n```\n\n```js\nimport type { am } from 'module';\n// 또는\nimport type { } from 'module';\n```\n\n- --build 하위에서 Emit-Specific 플래그 전달: 빌드에 대한 동작을 지정하는 플래그들 (--build를 사용할 때). 이들은 --declaration, --emitDeclarationOnly, --declarationMap, --sourceMap 및 --inlineSourceMap를 포함합니다. 모두 이제 컴파일러 플래그로 지정할 수 있습니다. 이전에는 tsconfig.json에서만 설정할 수 있었어요.\n\n```js\n# 이것은 `tsconfig.json`에서 비활성화되어 있더라도 타입 선언을 생성합니다.\ntsc --build --declaration\n```\n\n<div class=\"content-ad\"></div>\n\n- 에디터에서 대소문자 구분 없는 import 정렬: 에디터에서 import를 정렬할 때 대소문자 구분 동작을 변경하세요. 이 기능은 VSCode의 JSON 설정 내 typescript.unstable 아래에서 활성화하고 구성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1032/1*Fei6JPgYzIgnl_IMekhOQg.gif)\n\n- Exhaustive switch/case 자동 완성: 에디터에서 이제 리터럴 타입의 case 문을 자동으로 완성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:656/1*e9FNtf4-kxU787rEl1w9lQ.gif)","ogImage":{"url":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png"},"coverImage":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png","tag":["Tech"],"readingTime":53},{"title":"Nodejs에서 CRON 작업으로 일정 관리하기","description":"","date":"2024-05-27 18:09","slug":"2024-05-27-SchedulingTaskswithCRONJobsinNodejs","content":"\n\nCRON 작업은 특정 간격으로 실행되는 작업을 예약하는 강력한 방법입니다. 이는 뉴스레터를 보내거나 정기 백업을 수행하거나 오래된 데이터를 정리하는 등 다양한 애플리케이션에 매우 유용합니다.\n\n예: 매주 월요일에 세일 소식을 기존 사용자에게 이메일로 보내고 싶다면, CRON이 그 역할을 수행해줄 것입니다.\n\n이것들은 OS에서 실행되는 주기적인 작업이며, 주어진 간격에 대해 OS에 명령을 내리고 특정 작업을 실행할 수 있습니다.\n\n이 블로그에서는 Node.js에서 CRON 작업을 설정하고 관리하는 방법을 알아볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\nCRON 작업을 왜 사용해야 하나요?\n\nCRON 작업은 다음과 같은 용도로 사용됩니다:\n\n- 백업하기: 정기적으로 데이터베이스나 파일을 백업합니다.\n- 로깅: 주기적으로 로그를 생성하고 저장합니다.\n- 통지: 이메일이나 푸시 알림을 사용자에게 보냅니다.\n- 정리: 데이터베이스에서 오래된 파일이나 레코드를 제거합니다.\n\nCRON 작업을 시작하려면, CRON 작업에 대한 좋은 지식이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n- Node.js\n- Npm\n\nNode.js에서 CRON 작업을 생성하는 방법\n\n1. Node.js 프로젝트 생성하기\n\n새로운 Node.js 프로젝트를 초기화하거나 기존 프로젝트를 사용하세요\n\n<div class=\"content-ad\"></div>\n\n2. 패키지 설치\n\n사용할 패키지는 \"node-cron\" 입니다.\n아래 명령을 실행하여 패키지를 설치하세요.\n\n```js\nnpm install node-cron\n```\n\n3. 서버용 express 패키지 설치\n\n<div class=\"content-ad\"></div>\n\n익스프레스 패키지를 설치하여 서버를 실행하거나 따르고자 하는 다른 방법을 사용할 수 있어요.\n\n지금은 익스프레스를 사용해보겠습니다.\n\n```js\nnpm install express \n```\n\n4. 크론 작업 작성하기\n\n<div class=\"content-ad\"></div>\n\n일정에 따라 실행되는 함수를 생성해보겠습니다. 이 예제에서는 콘솔에 메시지를 기록할 것입니다:\n\n```js\nfunction logMessage() {\n    console.log('작업이 실행됨:', new Date().toLocaleString());\n}\n```\n\n이제 함수를 만들었으니 주기적으로 실행해봅시다.\n\nCRON 작업의 문법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ncron.schedule(\"* * * * *\", function() {\n    // Task\n});\n```\n\n별표에 대해 이해해 봅시다.\n\n이제 각 별표가 무언가를 정의합니다.\n\n예를 들어 ( * * * * * * )\n\n\n<div class=\"content-ad\"></div>\n\n아래 표는 왼쪽부터 두 번째, 분, 시간, 월 별일, 월, 및 주를 나타냅니다.\n\n- 초 — 선택사항\n- 분: 0–59\n- 시간: 0–23\n- 월 별일: 1–31\n- 월: 1–12\n- 요일: 0–7 (0과 7은 모두 일요일을 나타냅니다)\n\n예시 :\n\n- ( * * * * * ) — 매 분 실행\n- ( 0 * * * * ) — 매 시간 실행\n- ( 0 15 15 * * ) — 매달 15일 오후 3시에 실행\n- ( * * 5 * * ) — 매월 5일에 실행\n\n<div class=\"content-ad\"></div>\n\n위의 내용을 한국어로 번역해 드리겠습니다. 친근한 어조로 작성되었습니다.\n\n```js\n// 일반적인 임포트\nconst cron = require(\"node-cron\");\nconst express = require(\"express\");\n\n// 익스프레스 초기화\napp = express();\n\n// 당신이 만든 함수\nfunction message() {\n    console.log('작업이 실행됨:', new Date().toLocaleString());\n}\n\n// cron 스케줄\ncron.schedule(\"* * * * *\", function() {\n    message();\n});\n\napp.listen(3000);\n```\n\n위 스크립트를 'script.js'로 저장하세요.\n\n5. 스크립트를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n노드.js 애플리케이션을 시작하세요\n\n```js\nnode script.js\n```\n\n파일 이름에 맞게 파일 이름을 변경해주세요\n\n이렇게 하면 코드가 실행되고 함수가 주어진 간격대로 작동할 것입니다\n\n<div class=\"content-ad\"></div>\n\n약간의 예시\n\n다음은 CRON 작업의 몇 가지 더 예시입니다:\n\n- 자정에 매일 정리\n\n```js\ncron.schedule('0 0 * * *', () => {\n    console.log('자정에 작업을 실행중입니다');\n    // 여기에 정리 코드를 추가하세요\n});\n```\n\n<div class=\"content-ad\"></div>\n\n- 매주 월요일에 보고서 생성\n\n```js\ncron.schedule('0 9 * * 1', () => {\n    console.log('주간 보고서 생성 중');\n    // 보고서 생성 코드를 여기에 추가\n});\n```\n\n일부 최상의 사례\n\n- 에러 처리: CRON 작업에 적절한 에러 처리가 있어 예기치 않은 실패를 피할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncron.schedule('0 0 * * *', () => {\n    try {\n        // 작업 내용\n    } catch (err) {\n        console.error('CRON 작업 중 오류가 발생했습니다:', err);\n    }\n});\n```\n\n- Logging: 작업이 실행되는 시간과 결과를 추적하기 위해 로깅 구현 필요\n\n가능한 함정\n\n- 시간대 문제: CRON 작업은 서버의 시간대에 따라 실행됩니다. 애플리케이션이 전 세계 사용자를 대상으로 하는 경우 시간대 차이에 유의해야 합니다.\n- 동시성: 작업이 CRON 간격보다 오래 걸릴 경우, 작업이 예기치 않게 겹쳐지지 않도록 주의해야 합니다.```\n\n<div class=\"content-ad\"></div>\n\n다음 절차를 따라서, Node.js 애플리케이션에서 CRON 작업을 효과적으로 활용하여 간단한 로깅부터 복잡한 데이터 처리까지 다양한 작업을 자동화할 수 있습니다.\n\n코딩해요!","ogImage":{"url":"/assets/img/2024-05-27-SchedulingTaskswithCRONJobsinNodejs_0.png"},"coverImage":"/assets/img/2024-05-27-SchedulingTaskswithCRONJobsinNodejs_0.png","tag":["Tech"],"readingTime":4},{"title":"React Hooks useState, useEffect를 제대로 사용하는 방법","description":"","date":"2024-05-20 23:26","slug":"2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect","content":"\n\n<img src=\"/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png\" />\n\n개발자로서, 우리는 종종 useState와 useEffect의 힘을 활용하여 애플리케이션에 생명을 불어넣는 황홀한 모험을 떠납니다. 그러나 흥분 속에, 조심하지 않는 이들을 덫에 걸릴 위험한 함정이 숨어 있습니다.\n\n걱정하지 마세요. 이 안내서에서는 이 위험한 영역을 통과하기 위한 코스를 제시하여 안전하게 항해할 수 있는 지식과 도구를 갖춰 드립니다. 함께 useState와 useEffect의 신비를 해독하고 모험을 떠나 봅시다! 🌟\n\n# useState\n\n<div class=\"content-ad\"></div>\n\n```js\nconst [state, setState] = useState(initialState);\n```\n\n- 상태와 상태를 변경하는 함수를 반환합니다.\n- 초기 렌더링 중에 반환된 상태(state)는 첫 번째 인수로 전달된 값(initialState)과 동일합니다.\n- setState 함수는 상태를 업데이트하는 데 사용됩니다. 새 상태 값을 받아 구성 요소의 다시 렌더링을 대기열에 넣습니다.\n\n## 상태 업데이트\n\nsetState 메서드를 통해 상태를 업데이트할 수 있습니다. 예를 들어:```\n\n<div class=\"content-ad\"></div>\n\n```js\nconst [count, setCount] = useState(0);\n\nfunction handleOnClick(){\n  setCount(prevCount => prevCount + 1)\n  setCount(prevCount => prevCount + 1)\n  setCount(prevCount => prevCount + 1)\n}\n\nreturn (\n    <div>\n        <div>\n            count: {count}\n        </div>\n        <button onClick={handleOnClick}>\n            +1\n        </button>\n    </div>\n);\n```\n\n버튼을 클릭할 때 setCount(count + 1)을 세 번 연속 호출하면 인터페이스에 표시된 카운트 값이 +3이 아니라 +1씩만 증가하는 것을 알 수 있어요. 🔄\n\n## 함수형 업데이트\n\n새 상태를 이전 상태를 사용하여 계산해야 할 경우 setState에 함수를 전달할 수 있어요. 이 함수는 이전 상태를 받고 업데이트된 값을 반환할 거예요.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nsetCount(count => count + 1);\nsetCount(count => count + 1);\nsetCount(count => count + 1);\n```\n\n## 객체 업데이트\n\nuseState의 값이 객체일 때, 뷰가 업데이트되지 않는 상황이 발생할 수 있습니다. 예를 들어:\n\n```js\nconst [list, setList] = useState([0, 1, 2]);\nconst [userInfo, setUserInfo] = useState({\n  name: 'Bob',\n  age: 20\n});\n\nfunction handleOnClick(){\n  list.push(4);\n  list.push(4);\n  setList([...list]);\n\n  userInfo.name = 'Jack';\n  userInfo.age = 30;\n  setUserInfo({...userInfo});\n}\n\nreturn (\n    <div>\n        <p>Name：{userInfo.name}</p>\n        <p>Age：{userInfo.age}</p>\n        <p>list.length: {list.length}</p>\n        <button onClick={handleOnClick}>\n            Edit\n        </button>\n    </div>\n);\n```\n\n<div class=\"content-ad\"></div>\n\n문제의 원인: 문제는 React의 기본 얕은 비교 메커니즘에서 발생합니다. 상태가 객체인 경우 React는 객체의 참조(주소)를 스택에 저장합니다. setState를 호출하면 힙에있는 데이터가 수정되지만 스택의 참조는 변경되지 않습니다. React의 얕은 비교는 참조가 변경되었는지 확인하고, 그렇지 않으면 상태가 변경되지 않았다고 가정하고 페이지를 다시 렌더링하지 않습니다. 🔄\n\n해결책: 단순히 원본 객체의 주소를 변경하면 이를 다음과 같은 방법으로 달성할 수 있습니다.\n\n- 원본 객체를 복제합니다.\n- ES6 전개 연산자를 사용합니다.\n\n배열의 경우 배열의 자체 메서드 중 일부를 사용하여 깊은 복사를 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// Array.slice\nconst nextList = list.slice(0);\nnextList.push(\"slice\");\nsetList(nextList);\n\n// Array.concat\nconst nextList = list.concat();\nnextList.push(\"concat\");\nsetList(nextList);\n```\n\n요약: useState에서나 함수로 전달된 매개변수에서, 객체 자체를 직접 조작하지 말아야 합니다. 먼저 복사본을 만들고 그 복사본을 조작하여 예상치 못한 문제가 발생하는 것을 피하세요.\n\n## setState 이후 최신 값 가져올 수 없음\n\nsetState는 즉시 업데이트되지 않기 때문에, React는 업데이트 전 어느 시점에서 여러 setState 호출을 병합합니다. 따라서 setState 이후 최신 값을 가져오는 것은 어려울 수 있습니다. 다음은 몇 가지 접근 방법입니다:```\n\n<div class=\"content-ad\"></div>\n\n1. useRef를 사용해보세요: 이 방법은 useState의 값을 저장하지만 화면 업데이트를 트리거하지 않습니다.\n\n2. useEffect를 활용하세요: 효과적이지만 항상 적합한 방법은 아닙니다. 왜냐하면 이 방법은 모든 업데이트마다 내용을 실행하기 때문에 특정 요구에 부합하지 않을 수 있습니다.\n\n3. 함수 업데이트를 사용하세요.\n\n4. [useGetstate 훅 사용 원칙]: 최신 상태에 안전하게 액세스할 수 있는 hand를 제공하기 위해 useState값을 저장하는 useRef를 활용하세요. 🔄\n\n```js\nconst [count, setCount] = useState(0);\nconst countRef = useRef(0);\n\nuseEffect(()=>{\n  console.log(\"useEffect\", count);\n},[count]);\n\nfunction handleOnClick(){\n  countRef.current += 1;\n  setCount(count + 1);\n  setCount((count) => {\n    return count;\n  });\n}\n\nreturn (\n    <div>\n        <div>\n            count: {count}\n        </div>\n        <button onClick={handleOnClick}>\n            +1\n        </button>\n    </div>\n);\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nconst useGetState = (initiateState) => {\n  const [state, setState] = useState(initiateState);\n  const stateRef = useRef(state);\n  stateRef.current = state;\n\n  const getState = useCallback(() => stateRef.current, []);\n\n  return [state, setState, getState];\n};\n```\n\n## 타이머에서 최신 값을 가져오기\n\n다음 예제에서는 뷰나 출력과 관계없이 count의 값은 항상 0입니다.\n\n```js\nconst [count, setCount] = useState(0);\nuseEffect(()=>{\n  const interval = setInterval(() => {\n    setCount(count + 1);\n  },1000);\n  return () => {\n    clearInterval(interval);\n  }\n},[]);\n```\n\n<div class=\"content-ad\"></div>\n\n문제의 원인: 타이머가 생성된 후에 정리되지 않아 내부 상태가 항상 초기값을 반영하게 되었습니다.\n\n해결책:\n\n1️⃣ 타이머는 최신 상태를 캡처하기 위해 함수 업데이트를 사용하여 내부적으로 상태를 업데이트해야 합니다. 이렇게 하면 화면 업데이트 문제가 해결되지만 타이머는 여전히 0을 출력합니다.\n\n2️⃣ useEffect에서 상태를 종속성으로 활용합니다. 이를 통해 상태 변경 후에 타이머가 다시 생성되어 문제가 해결됩니다. 🔄\n\n<div class=\"content-ad\"></div>\n\n# useEffect\n\ncomponentDidMount와는 달리, useEffect 훅에 전달된 함수는 브라우저가 레이아웃 및 그리기를 완료한 후 지연 이벤트로 호출됩니다. 🎨 이 특성은 구독 설정 및 이벤트 처리와 같은 여러 일반 부작용 시나리오에 적합하게 만듭니다. 🔄 이러한 작업은 일반적으로 브라우저의 화면 업데이트를 차단해서는 안됩니다.\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nfunction Example(){\n  const [count, setCount] = useState(0);\n\n  useEffect(()=>{\n    document.title = `You clicked &{count} times`;\n  });\n\n    return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\nuseEffect는 첫 번째 렌더링 및 모든 업데이트를 포함한 모든 렌더링 후에 실행됩니다. React는 효과가 실행될 때마다 DOM이 업데이트된 것을 보장합니다. 🔄✨\n\n<div class=\"content-ad\"></div>\n\n다음은 `useEffect`를 언제 실행할지 결정하는 두 번째 매개변수에 대한 설명입니다.\n\n```js\nimport { useState, useEffect } from \"react\";\n\nexport default () => {\n   const [count, setCount] = useState(0);\n   const [number, setNumber] = useState(0);\n\n   // 의존성이 없는 경우, 매번 다시 렌더링될 때마다 실행됩니다.\n   useEffect(() => {\n     console.log(\"null\", count);\n   });\n\n   // 의존성 값이 비어 있으며, 처음 렌더링 후 한 번만 실행됩니다.\n   useEffect(() => {\n     console.log(\"[]\", count);\n   }, []);\n\n   // 의존성 값이 변경될 때만 실행되며, 첫 렌더링 시에도 실행됩니다.\n   useEffect(() => {\n     console.log(\"count\", count);\n   }, [count]);\n\n    function addCount() {\n    setCount(count + 1);\n    }\n  \n    function addNumber() {\n      setNumber(number + 1);\n    }\n  \n    return (\n      <div>\n        <div>count: {count}</div>\n        <div>number: {number}</div>\n        <button onClick={addCount}>count+1</button>\n        <button onClick={addNumber}>number+1</button>\n      </div>\n    );\n}\n```\n\n## 의존성 값이 객체인 경우\n\n자주 객체를 사용하여 의존 관계를 설정합니다.\n\n<div class=\"content-ad\"></div>\n\nuseEffect에서 객체의 변경 사항 처리하는 것이 중요합니다. 보통은 객체의 내용이 변경되었을 때 특정 작업을 수행하고 싶어합니다. 그러나 실제 비즈니스 개발 중에는 이유를 알 수 없는 문제가 발생할 수 있습니다. 몇 가지 흔한 현상을 살펴보겠습니다:\n\n🤔 객체의 내용이 분명히 변경되었는데, 왜 useEffect가 작동하지 않을까요?\n\n🤔 객체의 내용이 분명히 변경되지 않았는데, 왜 useEffect가 항상 작동할까요?\n\n이것은 말장난처럼 들릴 수 있지만, 이 문제의 본질은 객체가 참조 유형이라는 점에 있습니다. 아래 예시를 통해 보다 깊은 이해를 얻을 수 있습니다. 🔄✨\n\n<div class=\"content-ad\"></div>\n\nCase 1️⃣: 객체의 속성 값을 변경하면 useEffect가 트리거되지 않습니다\n\n```js\nconst [info, setInfo] = useState({\n  name: \"Bob\",\n  age: 20\n});\n\nuseEffect(() => {\n  console.log(\"info\", info);\n},[info]);\n\nfunction handleChangeName(e){\n  const value = e.target.value;\n  setInfo((info)=>{\n    info.name = value;\n    return info;\n  });\n}\n\nreturn <input onChange={handleChangeName} />;\n```\n\n문제의 원인: setInfo를 호출할 때 입력 매개변수가 직접 변경됩니다. 이때 변경된 정보가 반환되며 그 참조가 변경되지 않습니다.\n\n참고: 어떠한 경우에도 입력 매개변수를 직접 변경하거나 상태 값을 직접 변경해서는 안 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n//잘못된 작성법\ninfo.name = value;\nsetInfo(info);\n\n//잘못된 작성법\nsetInfo((info) => {\n   info.name = value;\n   return info;\n});\n\n//올바른 작성법\nsetInfo({\n     ...info,\n     name: value\n});\n\n// 올바른 작성법\nsetInfo((info) => {\n   return {\n     ...info,\n     name: value\n   };\n});\n```\n\nCase 2️⃣: 부모 구성 요소의 객체 속성을 종속성으로 수락하여 useEffect가 자주 트리거됨\n\n컴포넌트를 개발할 때 일부 속성에 대한 기본 값을 설정하는 것이 종종 필요합니다. 전형적인 접근 방식은 props를 구조화하고 기본 값 동시에 할당하는 것입니다. 🛠️🔧\n\n```js\nconst {\n    count = 0,\n    list = []\n} = \n```\n \n\n\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트에서 \"list\" 속성을 전달하지 않으면, 자식 컴포넌트는 부모 컴포넌트가 다시 렌더링될 때마다 다시 렌더링되어 useEffect가 각 렌더링마다 트리거됩니다. 🔃\n\n```js\nimport { useState, useEffect } from \"react\";\n\nconst Com = () => {\n  const [count, setCount] = useState(0);\n  \n  function handleOnClick(){\n    setCount((count) => count + 1);\n  }\n\n  return (\n    <div>\n      <button onClick={hanleOnClick}>add</button>\n      <SubCom count={count} />\n    </div>\n  );\n};\n\nconst SubCom  = (props) => {\n  const { list = [], count } = props;\n  \n  useEffect(() => {\n    console.log(list)\n  },[list])\n\n  return <div>child component: {count}</div>;\n\n};\n\nexport default Com;\n```\n\n문제의 원인: 부모 컴포넌트가 업데이트될 때, 자식 컴포넌트가 다시 렌더링되어 각 렌더링마다 새로운 props.list 참조가 제공됩니다. 빈 배열로 표시되더라도, useEffect는 list의 참조 변경을 감지하여 실행됩니다. 복잡한 시나리오에서 빈번한 업데이트는 화면이 흰색으로 나타나는 문제를 야기할 수 있습니다.\n\n올바른 접근법: 컴포넌트가 사용된 곳에서 호환성 처리를 구현하고, 기본값을 직접 할당하는 것을 피하십시오. 🛠️\n\n<div class=\"content-ad\"></div>\n\nCase 3️⃣: 객체 내용이 변경되지 않았을 때 useEffect가 트리거되지 않도록 설정하고 싶어요.\n\n객체가 의존성으로 사용될 때, 해당 실행이 내용이 변경될 때 트리거되는 것이 일반적입니다. 그러나 useEffect의 본질은 참조 변경을 모니터하는 것이라, 실제 비즈니스 개발과 다소 일치하지 않을 수 있어요. 🤔\n\n- 비즈니스 레이어는 종종 일부 상태를 재설정하고, setState([]) 또는 setState('')을 사용합니다. 상태 값 자체가 [] 또는 ''일 수 있으며, 재설정 후 내용은 변경되지 않았지만 참조가 변경되어 useEffect가 트리거되는 경우가 생길 수 있어요.\n\n```js\nimport { useState, useEffect } from \"react\";\n\nconst Com = () => {\n   const [list, setList] = useState([]);\n\n   function reset() {\n     setList([]);\n   }\n\n   return (\n     <div>\n       <p>{list.join(\",\")}</p>\n       <button onClick={reset}>reset</button>\n       <SubCom list={list} />\n     </div>\n   );\n};\n\nconst SubCom = (props) => {\n   const { list } = props;\n\n   useEffect(() => {\n     console.log(list);\n   }, [list]);\n\n   return <div>자식 컴포넌트</div>;\n};\n\nexport default Com;\n```\n\n<div class=\"content-ad\"></div>\n\n솔루션:\n\n- 오브젝트를 문자열로 변환한 뒤 useEffect의 의존성으로 사용하세요.\n\n```js\nuseEffect(() => {\n  console.log(list);\n}, [JSON.stringify(list)]);\n```\n\n- 문제를 해결하기 위해 훅의 useDeepCompareEffect을 사용하세요. 사용 방법은 useEffect와 동일하지만 deps는 lodash isEqual을 통해 깊게 비교됩니다.\n\n<div class=\"content-ad\"></div>\n\n\nCase 4️⃣: 두 개의 useEffect 업데이트가 서로에게 의존하며 무한 업데이트로 인해 화면이 흰색으로 나타납니다.\n\n```js\nconst {\n     value,\n     defaultValue = 0.5,\n     onChange\n} = props;\n\nconst [innerValue, setInnerValue] = useState<number>(defaultValue);\n\n// useEffect1이라고 명명된 효과\nuseEffect(() => {\n     if (value !== undefined) {\n         setInnerValue(value);\n     }\n}, [value]);\n\n// useEffect2라고 명명된 효과\nuseEffect(() => {\n     onChange?.(innerValue);\n}, [innerValue]);\n```\n\n문제:\n\n\n<div class=\"content-ad\"></div>\n\n- 🔍 첫 번째 로드 시, useEffect2가 트리거되어 onChange 메서드가 호출됩니다.\n- 🔄 비즈니스 레이어에서 값이 수동으로 변경되면, onChange도 트리거됩니다.\n\n올바르게 작성하는 방법:\n\n- 🛠️ 실제로 양식 값 변경을 수동으로 하는 경우, useEffect를 직접 사용하는 대신 innerValue의 변경 사항을 모니터링하기 위해 onChange를 호출하세요.\n\nCase 5️⃣: useRef 값을 모니터링하는데 의존하면, 때로는 업데이트가 트리거될 수 있지만 때로는 업데이트가 트리거되지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { useState, useEffect, useRef } from \"react\";\n\nexport default () => {\n   const [count, setCount] = useState(0);\n   const countRef = useRef(0);\n    \n   // Named useEffect1\n   useEffect(() => {\n     console.log(\"count\", count);\n   }, [count]);\n\n   // Named useEffect2\n   useEffect(() => {\n     console.log(\"countRef\", countRef);\n   }, [countRef.current]);\n\n  \n\n   return (\n     <div>\n       <p>{count}</p>\n       <button onClick={() => setCount((c) => c + 1)}>button1</button>\n       <button onClick={() => (countRef.current += 1)}>button2</button>\n     </div>\n   );\n};\n```\n\n현상:\n🔘 버튼1을 클릭하면 useEffect1이 실행됩니다.\n🔘 버튼2를 클릭하면 useEffect2가 실행되지 않습니다.\n🔘 버튼1을 다시 클릭하면 useEffect1과 useEffect2가 모두 실행됩니다.\n\n문제의 원인:\n🔍 상태가 변경될 때만 업데이트가 트리거됩니다. useState와 useReducer는 업데이트를 시작할 수 있는 유일한 훅입니다.\n\n사용 안내:\n📌 useRef의 값은 useRef의 변경으로 상태 변경이 필요한 경우가 확실한 경우에만 의존성으로 사용하세요.```\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\nReact 개발의 광활한 바다에서 useState와 useEffect는 우리의 애플리케이션에 생명과 기능을 부여할 수 있는 강력한 동료들입니다. 그러나 강력한 도구처럼, 그들만의 문제와 함정이 따릅니다.\n\n올바른 상태 업데이트를 보장하고 의존성과 부작용을 처리하는 등, 이 안내서는 React 개발의 위험한 지형을 안전하게 탐험하기 위해 필요한 지식과 전략을 제공했습니다.\n\n여정을 계속하면서 주의를 기울이고 철저하게 테스트하며, 동료 개발자로부터 지식을 얻거나 신뢰할 만한 자료를 참고하는 것을 꺼리지 마세요. useState와 useEffect를 잘 이해하고 인내심을 가지면 가장 어려운 React 프로젝트도 정복하고 우수한 애플리케이션을 구축할 수 있습니다. 즐거운 코딩하세요! 🚀🌟","ogImage":{"url":"/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png"},"coverImage":"/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png","tag":["Tech"],"readingTime":12}],"page":"5","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}