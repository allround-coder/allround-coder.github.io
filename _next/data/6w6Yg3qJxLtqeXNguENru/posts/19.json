{"pageProps":{"posts":[{"title":"Nest JS에서 Redis 사용하는 방법","description":"","date":"2024-05-17 20:30","slug":"2024-05-17-UsingRedisinNestJS","content":"\n\n<img src=\"/assets/img/2024-05-17-UsingRedisinNestJS_0.png\" />\n\n# 소개\n\n확장 가능하고 고성능 응용 프로그램을 구축하는 기술은 모든 개발자가 추구하는 기술입니다.\n\n이 글에서는 Redis를 활용하여 응용 프로그램의 속도와 보안을 향상시키는 방법을 알아보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nNestJS와 함께 사용할 것입니다. 네스트는 Kamil Mysliwiec가 만든 간단하고 가벼운 프레임워크로, 강건함과 개발자 친화적인 아키텍처로 유명합니다.\n\n응용 프로그램이 복잡성이 증가하고 데이터 처리량이 증가함에 따라, 효율적인 데이터 캐싱은 응답 시간을 향상시키고 데이터베이스에 가해지는 부하를 줄이는 데 필수적입니다. 여기에서 Redis가 등장합니다. Redis는 강력한 인메모리 데이터 구조 저장소로, NestJS에서 캐싱 솔루션으로 사용될 수 있습니다.\n\n# NestJS와 Redis 설치\n\n가정: -\n\n\n<div class=\"content-ad\"></div>\n\n- NodeJS가 설치되어 있습니다.\n- VS Code 또는 원하시는 편집기가 설치되어 있습니다.\n- NestJS의 기본 지식\n\n시작하려면 명령줄을 실행하고 선택한 폴더로 이동하세요 (해당 폴더에 코드를 작성할 것입니다). 그리고 다음 명령을 실행하세요.\n\n```js\nnpm i -g @nestjs/cli \nnest new using-redis-in-nestjs #원하는 프로젝트 이름으로 \"using-redis-in-nestjs\"를 대체할 수 있습니다\n```\n\n해당 폴더로 이동하면 다음처럼 간단한 시작 코드가 있는 기본 NestJS 프로젝트가 표시됩니다…\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-17-UsingRedisinNestJS_1.png\" />\n\n새로 만든 NestJS 프로젝트를 위해 프로젝트 시작\n\n이 문서의 주요 관심사가 캐싱이므로 이 파일들이 무엇을 의미하고 하는지는 다루지 않고 캐싱과 Redis 사용에 초점을 맞출 것입니다.\n\n첫 번째 할 일은 NestJS의 캐시 매니저와 패키지 cache-manager 자체를 설치하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nnpm install @nestjs/cache-manager cache-manager\n```\n\n@nestjs/cache-manager은 원래 @nestjs/common 패키지의 일부였으며 NestJS 자체를 사용하여 캐시와 상호작용할 수 있게 해주는 패키지입니다. 캐시 패키지를 직접 사용하는 대신 NestJS의 통합 API를 사용하여 코드를 변경하지 않고도 더 편리하게 사용할 수 있습니다. 이는 우리가 나중에 캐시 공급업체를 변경하기로 결정해도 코드를 변경할 필요가 없기 때문에 우리에게 유리합니다.\n\n이제 캐시 모듈을 설정하려면 \"app.module.ts\" 파일로 이동하여 @nestjs/cache-manager에서 캐시 모듈을 import하고 매개변수 없이 register 메서드를 사용하면 됩니다.\n\n```js\nimport { CacheModule } from '@nestjs/cache-manager';\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n```\n\n\n<div class=\"content-ad\"></div>\n\n```js\n@Module({\n  imports: [CacheModule.register()],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n이 레지스트리를 통해 \"app.service.ts\" 파일에서 캐시 매니저를 사용하여 데이터를 저장하고 검색할 수 있게 되었습니다. 사용하려면 \"app.service.ts\"의 생성자에 주입해야 합니다.\n\n```javascript\nimport { CACHE_MANAGER } from '@nestjs/cache-manager';\nimport { Cache } from 'cache-manager'; // ! 이 import를 빠뜨리지 마세요\nimport { Inject, Injectable } from '@nestjs/common';\n```\n\n```javascript\n@Injectable()\nexport class AppService {\n  constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}\n  getHello(): string {\n    return 'Hello World!';\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n캐시 모듈은 NestJS의 다른 모듈과 마찬가지로 작동합니다. 따라서 사용 중인 모듈에서 가져오거나 전역으로 사용할 수 있도록 설정해야 합니다.\n\n```js\nCacheModule.register({isGlobal: true})\n```\n\n이제 사용 방법을 알아보겠습니다. 시작하려면 세 가지 메서드만 알아야 합니다.\n\n```js\nawait this.cacheManager.set('키', '값'); // 캐시에 데이터 설정\nconst value = await this.cacheManager.get<string>('키'); // 캐시에서 데이터 가져오기\nawait this.cacheManager.del('키'); // 캐시에서 데이터 삭제\n```\n\n<div class=\"content-ad\"></div>\n\n이 세 가지 메소드는 기본적으로 캐싱과 관련된 거의 모든 작업을 수행할 수 있도록 해줍니다. 이를 실제로 보기 위해 세 가지 메소드를 테스트할 수 있는 세 가지 라우트를 준비했는데요. 이를 따라오시면서 저의 GitHub을 방문하셔서 코드를 확인해보실 수 있어요.\n\n아래는 컨트롤러에서의 라우트들입니다.\n\n```js\nimport { Controller, Delete, Get, Post } from '@nestjs/common';\nimport { Body } from '@nestjs/common/decorators';\nimport { CreateDataDto } from 'dtos/create-data.dto';\nimport { AppService } from './app.service';\n```\n\n```js\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n  @Get()\n  async getData() {\n    try {\n      return await this.appService.getData();\n    } catch (error) {\n      console.log(error);\n      return error;\n    }\n  }\n  @Post()\n  async postData(@Body() createDataDto: CreateDataDto) {\n    try {\n      return await this.appService.postData(createDataDto);\n    } catch (error) {\n      console.log(error);\n      return error;\n    }\n  }\n  @Delete()\n  async deleteData() {\n    try {\n      return await this.appService.deleteData();\n    } catch (error) {\n      console.log(error);\n      return error;\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 이것이 서비스입니다.\n\n```js\nimport { CACHE_MANAGER } from '@nestjs/cache-manager';\nimport { Cache } from 'cache-manager'; // ! 이 임포트를 빠트리지 마세요\nimport { Inject, Injectable } from '@nestjs/common';\nimport { CreateDataDto } from 'dtos/create-data.dto';\n```\n\n```js\n@Injectable()\nexport class AppService {\n  constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}\n  async getData(): Promise<string | undefined> {\n    const value = await this.cacheManager.get<string>('key'); // ? 캐시에서 데이터를 가져옵니다\n    return value;\n  }\n  async postData(createDataDto: CreateDataDto) {\n    const { value } = createDataDto;\n    await this.cacheManager.set('key', value); // ? 캐시에 데이터를 설정합니다\n  }\n  async deleteData() {\n    await this.cacheManager.del('key'); // ? 캐시에서 데이터를 삭제합니다\n  }\n}\n```\n\nNestJS의 캐시 모듈을 사용하는 것은 매우 간단하고 쉬우며, 꽤 간단한 애플리케이션에서 필요한 모든 것일 수 있음을 확인할 수 있습니다. 물론, 여기에 그치지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# Redis\n\n네스트JS가 사용하는 기본 인메모리 스토어는 우리가 찾고 있는 체계적인 해결책이 아닐 수 있습니다. 스토어를 변경하려면 캐시 모듈 등록 방식을 변경해야 합니다.\n\n먼저 네스트JS 캐시 매니저 옵션을 살펴봅시다.\n\n```js\nexport interface CacheManagerOptions {\n    store?: string | CacheStoreFactory | CacheStore;\n    ttl?: number;\n    max?: number;\n    isCacheableValue?: (value: any) => boolean;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n옵션에 'store' 속성이 있는 것을 확인할 수 있습니다. 여기에는 Redis Store의 초기화가 필요합니다.\n\n먼저 캐시 매니저 Redis Store를 설치해야 합니다.\n\n```js\nnpm i --save cache-manager-redis-store\n```\n\n이제 레지스터 메서드를 변경해야 합니다. 코드를 깔끔하게 유지하기 위해 'configs'라는 폴더를 만들고 그 안에 'app-options.constants.ts'라는 파일을 생성하여 레지스터 메서드를 작성했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { CacheModuleAsyncOptions } from \"@nestjs/cache-manager\";\nimport { ConfigModule, ConfigService } from \"@nestjs/config\";\nimport { redisStore } from \"cache-manager-redis-store\";\n```\n\n```js\nexport const RedisOptions: CacheModuleAsyncOptions = {\n  isGlobal: true,\n  imports: [ConfigModule],\n  useFactory: async (configService: ConfigService) => {\n    const store = await redisStore({\n      socket: {\n        host: configService.get<string>('REDIS_HOST'),\n        port: parseInt(configService.get<string>('REDIS_PORT')!),\n      },\n    });\n    return {\n      store: () => store,\n    };\n  },\n  inject: [ConfigService],\n};\n```\n\n그리고 앱 모듈에서 간단히 사용하세요.\n\n```js\nimport { CacheModule } from '@nestjs/cache-manager';\nimport { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { RedisOptions } from 'configs/app-options.constants';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n```\n\n<div class=\"content-ad\"></div>\n\n```ts\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    CacheModule.registerAsync(RedisOptions),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n# 프로덕션 앱에서 Redis 활용하기\n\n이제 이 모듈을 활용하기 시작해봅시다. 우리가 프로덕션 앱에서 이 모듈을 어떻게 사용해야 하는지 살펴봅시다.\n\n- 응답 캐싱 (속도)\n- JWT 토큰 유효성 검사 (보안)\n- 채팅을 위한 소켓 ID 저장 (속도)```\n\n<div class=\"content-ad\"></div>\n\n그럼 하나씩 깊이 파고들어 봅시다.\n\n# 1. 응답 캐싱\n\n응답 캐싱은 API에 터보 부스트를 제공하는 것과 같습니다. 특정 위치(엔드포인트)에서 무언가를 요청하는 첫 번째 시간에, 우리는 받은 것을 캐시에 저장합니다. 그러니까, 짧은 시간 내에 같은 것을 다시 요청하면, 우리는 메인 저장소(데이터베이스)로 돌아가는 대신 저장된 버전을 그대로 전달합니다.\n\nNestJS로 이를 실현하려면, GET 요청에서 반환된 데이터를 추적하고 저장할 Interceptor를 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n물론 NestJS에서 인터셉터를 사용하는 것은 매우 간단합니다. 원하는 컨트롤러에 내장 인터셉터를 바인딩하기만 하면 됩니다.\n\n```js\nimport { CacheInterceptor } from '@nestjs/cache-manager';\nimport { Controller, Delete, Get, Post } from '@nestjs/common';\nimport { Body, UseInterceptors } from '@nestjs/common/decorators';\nimport { CreateDataDto } from 'dtos/create-data.dto';\nimport { AppService } from './app.service';\n```\n\n```js\n@Controller()\n@UseInterceptors(CacheInterceptor) // 여기에 추가하세요\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n  @Get()\n  async getData() {\n    try {\n      return await this.appService.getData();\n    } catch (error) {\n      console.log(error);\n      return error;\n    }\n  }\n  @Post()\n  async postData(@Body() createDataDto: CreateDataDto) {\n    try {\n      return await this.appService.postData(createDataDto);\n    } catch (error) {\n      console.log(error);\n      return error;\n    }\n  }\n  @Delete()\n  async deleteData() {\n    try {\n      return await this.appService.deleteData();\n    } catch (error) {\n      console.log(error);\n      return error;\n    }\n  }\n}\n```\n\n이렇게 캐싱 인터셉터를 추가하면 기본 TTL에 따라 모든 GET 라우트 핸들러 응답이 캐시됩니다. 물론 이는 register 메서드에서 수정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  ttl: 5, // 초\n  max: 10, // 캐시에 저장될 최대 항목 수\n}\n```\n\n우리 앱 전체의 모든 GET 요청을 캐시하려면 앱 모듈에서 전역으로 바인딩해야 합니다.\n\n```js\nimport { CacheInterceptor, CacheModule } from '@nestjs/cache-manager';\nimport { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { APP_INTERCEPTOR } from '@nestjs/core';\nimport { RedisOptions } from 'configs/app-options.constants';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    CacheModule.registerAsync(RedisOptions),\n  ],\n  controllers: [AppController],\n  providers: [\n    AppService,\n    {\n      provide: APP_INTERCEPTOR, // 인터셉터를 전역으로 바인딩\n      useClass: CacheInterceptor,\n    },\n  ],\n})\nexport class AppModule {}\n```\n\n<div class=\"content-ad\"></div>\n\n캐시의 지속 시간이나 라우트에 저장된 키를 사용자 정의하는 경우 NestJS의 데코레이터를 사용할 수 있습니다.\n\n- 기본 킷 값은 엔드포인트의 이름이며, 이를 변경하면 쿼리 매개변수와 함께 요청에 영향을 주므로 코드가 손상되지 않도록 주의하는 것이 중요합니다.\n\n```js\nimport { CacheInterceptor, CacheKey, CacheTTL } from '@nestjs/cache-manager';\nimport { Controller, Delete, Get, Post } from '@nestjs/common';\nimport { Body, UseInterceptors } from '@nestjs/common/decorators';\nimport { CreateDataDto } from 'dtos/create-data.dto';\nimport { AppService } from './app.service';\n```\n\n```js\n@Controller()\n@UseInterceptors(CacheInterceptor)\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n  @Get()\n  @CacheKey('custom_key') // 키 제어\n  @CacheTTL(20) // 지속시간 제어\n  async getData() {\n    try {\n      return await this.appService.getData();\n    } catch (error) {\n      console.log(error);\n      return error;\n    }\n  }\n  @Post()\n  async postData(@Body() createDataDto: CreateDataDto) {\n    try {\n      return await this.appService.postData(createDataDto);\n    } catch (error) {\n      console.log(error);\n      return error;\n    }\n  }\n  @Delete()\n  async deleteData() {\n    try {\n      return await this.appService.deleteData();\n    } catch (error) {\n      console.log(error);\n      return error;\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 2. JWT 토큰 유효성 검사\n\n이 섹션을 읽기 전에 사용자 인증하는 방법을 알고 있는 것이 명백하게 선행되어야 합니다.\n\n현재 JWT 기반 인증을 사용하는 사람들의 주요 문제점은 JWT가 쉽게 가져가지고, 디코딩하며, 복사할 수 있다는 것을 잊는다는 것이며, 모든 사람이 민감한 데이터를 내부에 저장한다는 문제점도 있습니다.\n\n이외에도, 대다수의 자습서들은 사용자가 로그인할 때 JWT가 특정 기간 동안 생성되지만 해당 사용자가 로그아웃했을 때에도 일정 기간이 지나지 않았더라도 토큰을 폐기해야 하는 것에 대해 언급하지 않는 것 같습니다.\n\n<div class=\"content-ad\"></div>\n\n그럼 이 경우에는 무엇을 해야 할까요? Redis를 세션 관리자로 사용할 수 있어요!\n\n사용자의 ID를 키로 저장하고 값으로 JavaScript 오브젝트를 만들면, 그 안에 \"accessToken\": \"...\"를 저장할 수 있어요!\n\n이게 무슨 말인지 알려 드릴게요.\n\n```js\n{\n  \"64c900a9d01c8c1a4351040c\": {\n    \"accessToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsIndoeSBhcmUgeW91IjoibG9va2luZyBoZXJlPyJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.l_2-T20JUdnz5rrOORgH6zfI6nrEzmIHMH5JlU76IIE\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n물론 \"HEST\" 명령어를 사용하여 순수 Redis로 구현할 수도 있고, Redis 명령어를 NestJS 캐시 매니저를 사용하여 추상화하여 통일된 API 아이디어를 유지할 수도 있어요.\n\n아래의 코드를 원하는 곳에 자유롭게 넣어보세요. 단, 캐시 모듈과 함께 연결되어 있는지 확인해주세요.\n\n```js\nasync hset(key: string, field: string, value: string) {\n    const stringObject = await this.cache.get<string>(key);\n    const object = checkNullability(stringObject)\n      ? JSON.parse(stringObject!)\n      : {};\n    object[field] = value;\n```\n\n```js\n    await this.cache.set(key, JSON.stringify(object));\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n만약 순수한 Redis를 사용하고 싶다면, underline client를 가져와서 'HSET' 메서드를 호출할 수 있어요.\n\n```js\nprivate readonly redisStore!: RedisStore;\nconstructor(@Inject(CACHE_MANAGER) private readonly cache: Cache) {\n    this.redisStore = cache.store as unknown as RedisStore;\n}\n```\n\n그리고 함수 내부에서 client를 호출하고 'HSET' 명령을 실행할 수 있어요.\n\n```js\nconst client = this.redisStore.getClient();\nawait client.HSET('KEY', 'FIELD', 'VALUE')\n```\n\n<div class=\"content-ad\"></div>\n\n이제 서버 캐시에 액세스 토큰을 저장할 수 있으므로 사용자 로그아웃시 이를 제거하고 이 아이디어를 기반으로 논리를 구축할 수 있습니다.\n\n# 3. 채팅을 위한 소켓 ID 저장\n\n이전에 채팅 애플리케이션을 구축한 사람은 두 사람 간의 채팅을 위한 소켓 ID를 어디에 저장해야 할지에 대한 질문에 직면했습니다. 인터넷에서 본 바로는 대부분의 사람들이 이 정보를 DB에 저장하거나 인메모리 변수 내에 저장하는 것으로 보여집니다. 둘 다 실행 가능한 방법이지만 최적은 아닙니다.\n\n일반적인 DB에 저장하는 것의 문제점은 당연히 속도 입니다. 우리는 이전에 얼마나 느릴 수 있는지에 대해 논의했던 것을 기억할 겁니다.\n\n<div class=\"content-ad\"></div>\n\n그 반면, 메모리 변수에 저장하는 것은 많은 사용자 수에 대응할 수 없는 해결책입니다.\n\n이제 두 가지 옵션이 남았습니다. 소켓.io 내장 기능을 활용하거나 이전 섹션에서 논의한 캐시된 사용자 객체에 저장하는 방법입니다.\n\n```js\n{\n  \"64c900a9d01c8c1a4351040c\": {\n    \"accessToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsIndoeSBhcmUgeW91IjoibG9va2luZyBoZXJlPyJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.l_2-T20JUdnz5rrOORgH6zfI6nrEzmIHMH5JlU76IIE\",\n    \"socketID\": \"소켓 ID\"\n  }\n}\n```\n\n이제 상담 중인 상대방으로부터 소켓 ID를 받아와 두 당사자 간 쉽게 메시지를 전송할 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n- 이 글이 제 첫 글이니, 내가 실수를 한 경우 언제든지 연락주세요\n\n# 결론\n\nRedis를 NestJS 애플리케이션에 사용하면 성능을 향상시키고 보안을 강화하며 실시간 기능을 활성화하는 다면적인 접근 방법을 제공합니다.\nRedis를 캐싱 솔루션으로 원활하게 통합하여 응답 시간을 크게 개선하고 데이터베이스 부하를 줄이면서 전반적인 사용자 경험을 향상시킬 수 있습니다.\n또한 Redis는 JWT 토큰 유효성 검사를 위한 신뢰할 수 있는 세션 관리자로 작용하며, 실시간 애플리케이션의 소켓 연결을 관리하는 전략적 방법을 제공하여 애플리케이션 보안을 보장하는 데 귀중한 역할을 합니다.\n본 문서를 통해 개발자들은 Redis의 전체 잠재력을 깨달을 수 있어서, NestJS 프로젝트를 확장 가능성, 효율성 및 견고성을 향상시키는 데 도움이 될 것입니다.\n\n🚀 전문 풀스택 개발자로 프로젝트를 강화하세요 🚀\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 저는 요르단 암만을 기반으로 활동하는 숙련된 시니어 풀스택 웹 개발자, 무틀락 알사따입니다.\n원활한 디지털 경험을 만들어내는 데 열정을 가지고 문제 해결에 능숙한 저는 아이디어를 기능적이고 매력적인 웹 솔루션으로 변환하는 데 전문화되어 있습니다.\n\n👨‍💻 기술 전문성: 전체 웹 개발 스펙트럼에 걸쳐 전문 지식을 확보하고 있습니다. Angular와 같은 프런트엔드 기술부터 NestJS와 같은 백엔드 프레임워크까지 다룹니다.\n기능과 디자인을 완벽하게 조화시키는 응용 프로그램 설계에서 힘을 발휘합니다.\n\n🔗 엔드 투 엔드 솔루션: 사용자 중심 인터페이스 구축, 백엔드 성능 최적화, 서드파티 서비스 통합 등 다양한 프로젝트 요구 사항을 충족하는 종합적인 솔루션을 만드는 데 능숙합니다.\n\n💡 혁신적인 문제 해결자: 복잡한 도전에 직면하는 것을 즐깁니다.\n캐싱 전략을 통한 성능 최적화 경험 및 안전한 사용자 인증 솔루션 구현을 통해 혁신에 대한 저의 헌신을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n🛠️ 맞춤형 개발: 모든 프로젝트는 같지 않습니다. 저는 각 클라이언트의 고유한 요구 사항에 맞게 접근 방식을 맞춤화하는 데 자부심을 갖고 있습니다. 전자 상거래 플랫폼부터 동적 웹 앱까지, 영향을 주는 맞춤 솔루션을 전달하는 데 헌신하고 있습니다.\n\n🌐 글로벌 시각: 글로벌 기술 분야의 통찰력을 활용하여 다양한 시각을 제공합니다. 협동적인 성향과 다양한 산업 트렌드에 적응하는 능력을 바탕으로 프로젝트가 최첨단 기술을 유지하도록 보장합니다.\n\n🌱 지속적인 학습: 끊임없이 변화하는 기술 세계에서 앞서 나가는 것이 저에게 중요합니다. 새로운 도구, 프레임워크 및 모베스트 프랙티스를 지속적으로 탐색하여 제공하는 솔루션이 기술의 선두에 있도록 합니다.\n\n📊 결과 중심: 제 관심사는 코드 작성뿐만 아니라 측정 가능한 결과를 제공하는 데 있습니다. 사용자 참여도 개선, 사이트 속도 향상 또는 전환율 최적화 등 명확한 결과를 달성하기 위해 헌신하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n🤝 고객 중심 접근: 효과적인 커뮤니케이션과 이해는 제 프리랜스 실무의 핵심입니다. 저는 고객과 긴밀히 협력하여 그들의 비전이 기능적 현실로 옮겨지고 기대를 뛰어넘는 결과물이 되도록 합니다.\n\n🌟 함께 협업해요: 디지털 포부를 실현해 줄 전문 풀스택 개발자를 찾고 계시다면, 여러분의 프로젝트에 참여할 수 있는 기회를 소개해드릴게요. MutlaqAlsadeed@gmail.com 으로 연락 주시거나, 어떻게 제가 여러분의 성공에 기여할 수 있는지 알아보세요.\n\nLinkedIn에서 저와 연결하세요: Mutlaq Alsadeed\nGitHub에서 제작물을 탐험하세요: Mut1aq","ogImage":{"url":"/assets/img/2024-05-17-UsingRedisinNestJS_0.png"},"coverImage":"/assets/img/2024-05-17-UsingRedisinNestJS_0.png","tag":["Tech"],"readingTime":15},{"title":"JavaScript에서 이벤트 기반 API를 Promises로 적용하기","description":"","date":"2024-05-17 20:29","slug":"2024-05-17-BuildingaSyncBridge","content":"\n\n## JavaScript에서 이벤트 기반 API를 Promises로 적응하기\n\n![이미지](/assets/img/2024-05-17-BuildingaSyncBridge_0.png)\n\n이벤트 기반 아키텍처(EDA)는 느슨하게 결합되고 성능이 우수하며 확장 가능한 웹 앱을 구축하는 강력한 방법입니다. 이것은 푸시 알림, 공동 편집 및 멀티플레이어와 같은 풍부한 경험을 제공하며 실시간 상호작용 및 모듈화를 장려합니다.\n\n하지만 때로는 모델이 개발자로서 우리가 해야 할 일과 일치하지 않을 수 있습니다. 두 응용 프로그램 계층이 비동기 메시지 전달을 통해만 통신할 수 있는 경우, 코드를 서투르게 구조화해야 할 수도 있습니다. 요청 코드를 수신 코드와 함께 동일한 위치에 두지 못하고, 청취기 또는 구독을 직접 관리해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 이벤트 기반 API를 편리한 Promise 기반 API로 적응하는 일반적인 솔루션을 소개하고 있습니다. 이를 통해 메시지 전달의 복잡성과 보일러플레이트를 숨기고 응용 프로그램 경계를 가로지르는 선형 코드를 작성할 수 있습니다.\n\n## 요청/응답 대 이벤트 기반 아키텍처\n\n웹의 전통적인 응용 프로그램은 REST, GraphQL, RPC 및 기타 요청/응답 모델을 따르는 사양을 통해 HTTP를 통해 경계를 가로지를 통신을 처리합니다. 이 모델은 요청자가 메시지를 보낸 다음 응답자가 메시지를 받아들이고 처리하고 응답하기를 기다리는 방식으로 특징 지어집니다. 이는 자바스크립트의 비동기 함수 안에서 발생할 수 있지만, 이를 \"동기식\" 또는 \"인밴드\"로 일반적으로 참조할 수 있습니다. 요청에 대한 응답이 즉시 기대되고 요청을 실행하는 컨텍스트가 해당 응답을 기다리게 된다는 점에서입니다.\n\n![Building a Sync Bridge - 1](/assets/img/2024-05-17-BuildingaSyncBridge_1.png)\n\n<div class=\"content-ad\"></div>\n\nEDA(이벤트 기반 아키텍처) 또는 발행/구독 모델이라고도 불리는 것은 데이터 요청 및 수신 프로세스가 분리되어 논블로킹 및 비동기적으로 수행된다는 특징이 있어요. 일반적으로 클라이언트는 서버로부터 메시지를 구독하고, 서버는 클라이언트로부터 메시지를 받습니다. 클라이언트가 데이터를 요청할 때, 단순히 메시지를 보내고 실행을 계속합니다. 서버는 이 메시지를 받아 처리하고 어느 시점에서 다시 클라이언트로 다른 메시지를 보낼 것이에요. 클라이언트는 구독자로서 이 메시지를 \"원래 요청으로부터 외줄로\" 받아 유용한 대로 처리할 수 있습니다. 중요한 점은 이것이 다른 시간에 이루어지거나 다른 네트워크 요청 또는 다른 프로토콜을 사용해도 된다는 것이에요.\n\n![이미지](/assets/img/2024-05-17-BuildingaSyncBridge_2.png)\n\n이벤트 기반 모델의 능력에는 몇 가지 주요 장점이 있어요. 먼저, EDA는 클라이언트에게 요청하지 않아도 서버에서 이벤트를 알릴 수 있습니다. 이는 비싼 폴링을 제거하고, 다른 곳에서 발생한 알림 및 이벤트에 대한 \"푸시\" 동작을 가능하게 합니다. 둘째, 이는 메시지 처리를 메시지 전송과 분리할 수 있어서 덜 결합된 코드를 유도할 수 있습니다. 셋째, 이는 개발자에게 병렬 처리를 할 수 있게 하고, 견고하고 이해하기 쉬운 시스템을 구축할 수 있게 합니다. 넷째, 오직 인식된 메시지만이 구독자에 의해 처리되므로 시스템이 기본적으로 내결함적입니다.\n\n웹 기술인 웹훅(Webhooks), 웹소켓(WebSockets), 서버-전송 이벤트(Server-Sent Events)와 MQTT, AMQP와 같은 프로토콜, 이러한 것 위에 구축된 다양한 도구를 사용하여 강력한 이벤트 기반 응용 프로그램을 구현할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## EDA(이벤트 주도 아키텍처)가 방해할 때\n\n복잡한 앱에서 이벤트 주도 아키텍처는 많은 장점을 제공할 수 있습니다. 하지만 때로는 데이터를 특정 실행 컨텍스트에서 즉시 필요로 하는 경우도 있습니다. 때로는 원격 리소스나 절차를 마치 로컬인 것처럼 다루고 싶은 경우도 있습니다.\n\n다소 인위적인 예로, 사용자 입력에 대해 비용이 많이 드는 계산을 수행해야 하는 애플리케이션이 있다고 가정해 봅시다. 이 계산을 웹 워커에서 수행하는 것이 가장 좋다고 판단하여, 이 작업을 메인 UI 스레드에서 사이클을 소비하지 않고 작업을 수행하는 별도의 스레드를 사용하는 방법으로 설정했습니다. 앱에서 워커와 통신하기 위해 몇 가지 간단한 로직을 설정했습니다:\n\n우리의 Worker 모듈은 메인 스레드로부터 메시지를 수신하고, 비용이 많이 드는 계산을 수행한 후 결과를 메인 스레드로 응답하는 리스너 역할을 합니다:\n\n<div class=\"content-ad\"></div>\n\n우리가 기대하는 대로 작동합니다. 고객이 계산을 요청한 다음 나중에 결과를 받아 doSomethingWithResult를 수행할 수 있습니다. 그러나 이 솔루션은 expensiveComputation을 수행할 위치에 제한을 가합니다. 우리는 요청을 하고 응답을 동일한 위치에서 사용할 수 없습니다. 이것은 외부 라이브러리 코드나 비동기 함수의 중간과 같은 우리가 제어력이 부족한 컨텍스트에서 해당 기능을 사용하려고 할 때 도전이 될 수 있습니다. \"이 데이터가 필요하고 여기서 기다리겠다\"라고 말할 수 있다면 좋을텐데요.\n\nSync Bridge가 나타났습니다.\n\n## Sync Bridge\n\n이벤트 스트림을 \"동기적\" 방식으로 사용하려면 인터페이스를 Promise를 사용하는 방식으로 변환해야 합니다. 즉, Sync Bridge가 필요합니다. 이벤트 기반 API를 Promise 기반 API로 변환하는 과정은 몇 가지 단계로 나눌 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 클라이언트에서 메시지를 보내기 전에 요청자를 고유하게 식별할 수 있는 ID나 방법을 메시지에 첨부하십시오. 이것이 우리의 \"회신 주소\"입니다.\n- \"빈\" Promise를 만들고 이 Promise와 연결된 해결 및 거부 콜백에 메시지의 ID를 연결하여 보류 중인 데이터 구조에 저장하십시오. Map을 사용하는 것이 좋습니다.\n- Promise를 요청자에게 반환하고 메시지를 보냅니다.\n- 호스트에서 클라이언트 메시지를 구독하십시오. ID를 가진 메시지를 받으면 보통대로 처리하되, 응답 메시지에 동일한 ID를 포함하십시오.\n- 클라이언트에서 호스트 메시지를 구독하십시오. ID를 가진 메시지가 수신되면 해당 ID에 대해 보류 중인 Promise가 있는지 확인하십시오. 해당 Promise를 데이터 구조에서 빼내어 호스트 메시지의 내용에 따라 적절히 해결하거나 거부하십시오.\n\n여기서 \"클라이언트\"와 \"호스트\"는 메시지 전달에 참여하는 모든 엔티티가 될 수 있습니다. 때로는 클라이언트가 호스트로 작용하거나 그 반대로 작용할 수 있으므로, 사용되는 문맥에 따라 이러한 엔티티를 \"요청자\"와 \"응답자\"로도 참조할 수 있습니다.\n\n우리는 클라이언트와 호스트 간의 계약을 체결하여 EDA의 제한을 극복할 수 있습니다. 요청과 해당 응답 메시지에 공통적이고 고유한 ID를 표시하는 것에 동의함으로써, 응답을 올바른 요청자에게 \"라우팅\"할 수 있습니다. 우리는 요청 측에 약속을 열어 놓아 메시지를 받았을 때 기다리고 있는 메시지에 실제 데이터를 채워넣습니다.\n\n우리가 이를 이전에 다룬 웹 워커 예제에 적용해 보기 위해, 위에 나열된 프로세스를 추상화하는 도우미 클래스를 작성해 보겠습니다. 메시지에 ID를 할당하고 보류 중인 요청을 추적하고 응답을 청취하는 클라이언트 추상화가 필요할 것입니다. 이를 WorkerClient라고 부르겠습니다 :\n\n<div class=\"content-ad\"></div>\n\n호스트 쪽에서는, 우리가 관심 없는 메시지를 걸러내고 어떤 작업을 수행하며, 요청자의 \"반송 주소\"로 메시지를 다시 보내는 컨트롤러가 필요할 것입니다. 일종의 프록시 메시지 핸들러, 그렇게 해주는 것이 WorkerHost입니다.\n\n이러한 도우미들을 사용하여 새로운 Promise 기반 API를 사용하도록 애플리케이션 코드를 다시 작성할 것입니다. 이제 클릭 핸들러에서 데이터를 직접 기다릴 수 있다는 점에 유의해 주세요.\n\n우리의 워커도 비슷해 보이지만, 핸들러가 메시지를 게시하는 대신 값만 반환한다는 점이 다릅니다 (메시지 전달은 이미 처리되었습니다).\n\n자, 상당량의 코드를 작성했습니다. 정확히 어떤 이득을 얻었을까요?\n\n<div class=\"content-ad\"></div>\n\n신크 브릿지 어댑터는 실제로 미래에 어떤 메시지를 받을 것을 기대하는 것을 약속으로 변환합니다. 이를 통해 원격 컨텍스트에서 데이터와 코드를 로컬처럼 처리할 수 있습니다. 무엇보다도, 동일한 위치에서 원격 데이터를 요청하고 사용할 수 있게 해줍니다. 데이터베이스 트랜잭션 가운데서 비싼 계산을 해야 하거나 임의 이벤트 핸들러에서, 심지어 다른 이벤트 스트림의 메시지 핸들러에서도 그냥 전화를 해서 처리할 수 있습니다.\n\n또한 이제 다른 유형의 메시지를 이산 채널에 제한하여 메시지 처리를 구체적이고 빠르게 유지하고 코드를 필요한 곳에만 로컬라이징할 수 있습니다. 원한다면 여러 WorkerClient 객체가 동일한 채널을 공유할 수도 있습니다.\n\n이 패턴은 대부분의 이벤트 주도 시스템으로 쉽게 일반화될 수 있습니다. 예제의 helpers를 수정해서 자체 Worker를 구성하는 대신 어떤 EventTarget을 가져오도록 만들어 임의의 메시지 스트림에 대한 일반적이고 동기적인 인터페이스를 제공할 수 있습니다. 또는 figments와 같이 특정 인터페이스에 대한 래퍼 라이브러리를 작성할 수도 있습니다. 최근에 Figma 플러그인 API의 이벤트 주도 부분을 \"브릿지\"한 래퍼 세트인 figments와 같이 말입니다.\n\n## 실제 세계에서\n\n<div class=\"content-ad\"></div>\n\n이벤트 주도 시스템에서 작업할 때 \"이벤트로 생각하는 것\"이 가장 좋지만, 때로는 탈출구가 필요할 수 있습니다. Sync Bridge는 여기 유용한 도구가 될 수 있지만, 구현하기 전에 이 접근 방식이 필요한지 고려해보세요. 대부분의 경우에는 이벤트 처리가 그냥 작동합니다.\n\n오늘 하루 즐겁고 유익한 일들 가득하길 바라요!\n\n```js\n추가 정보 & 자료\n---------------------------\n\n이 기사의 예시 코드\n• rektdeckard/promisize\n\nEDA에 대한 더 많은 정보\n• 이벤트 주도 API – 원리 이해하기\n• 이벤트 주도 아키텍처가 뭐죠?\n\nasync/await 및 Promises에 대한 깊은 논의\n• 이벤트 루프는 대체 뭐죠?\n• Loupe\n• sindresorhus/promise-fun\n```\n\n```js\n나와 내가 하는 일\n-----------------\n\n• 트위터\n• GitHub\n• Phosphor 아이콘\n```\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 포맷으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-05-17-BuildingaSyncBridge_0.png"},"coverImage":"/assets/img/2024-05-17-BuildingaSyncBridge_0.png","tag":["Tech"],"readingTime":6},{"title":"Redis를 활용한 NodeJs에서 이벤트 주도 시스템 사용하기","description":"","date":"2024-05-17 20:27","slug":"2024-05-17-UsingDistributedLockingwithRedisinNodeJsinanEvent-DrivenSystem","content":"\n\n<img src=\"/assets/img/2024-05-17-UsingDistributedLockingwithRedisinNodeJsinanEvent-DrivenSystem_0.png\" />\n\n공유 리소스를 작업할 때 분산 시스템을 다루다보면 어려움이 있을 수 있어요. 분산 락킹 개념은 일반적으로 데이터베이스, 공유 파일 시스템 및 분산 컴퓨팅 환경에서 사용됩니다.\n\n최근에 저는 직장에서 현재 인보이스 및 결제 시스템에서 작업 중인 시스템에서 경쟁 조건 문제를 마주쳤어요. 이는 실제 결제 인보이스를 덮어쓰고 막대한 고통이 되었습니다. 결제는 실시간으로 이루어지며, 때문에 추적 가능성과 책임 추적이 중요합니다.\n\n맥락을 이해하기 위해 프로세스 및 시스템 아키텍처에 대해 간단히 설명하겠어요. 서비스는 NodeJS로 작성되었으며 Kubernetes 클러스터에 배포되어 있으며 언제든 동일한 서비스의 여러 인스턴스가 실행됩니다. 인보이스 시스템은 단계별로 분할되어 각 이벤트에 의해 순차적으로 실행되는 유한 상태로 구성되어 있습니다. 결제 프로세스는 언제든지 어느 상태에 있을 수 있습니다. 먼저 결제해야 할 최종 금액이 계산됩니다. 그런 다음 인보이스가 생성되며, 마지막으로 해당 인보이스에 대한 결제가 즉시 이루어집니다. 어떤 결함이 있을 경우 여러 인보이스가 생성되는 것을 피하기 위해 여러 체크 및 균형이 유지되고 있지만 여전히 무언가가 잘못되고 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n이 문제의 근본 원인은 여러 팟에서 송장 생성 상태를 동시에 실행했기 때문에, 이를 추적하는 것이 조금 까다로웠습니다. RabbitMQ는 메시지 패킷이 지정된 기간 내에 확인되지 않으면 재큐됩니다. 이 조건은 멀티 팟이 활성화되고 API 호출이 느릴 가능성이 높을 때 시스템에서만 발생했습니다. 상태 실행이 예상보다 오래 걸려 timeout이 발생하고 실행이 진행 중일 때 이벤트가 재큐됩니다. 부하 상태에서 API 호출이 실패하면 상태가 예외 상태로 전환되고, 상태를 다시 시도하는 새 이벤트가 대기열에 추가됩니다. 이는 대기열에 두 개 이상의 중복 이벤트가 결과로 생기게 되며, 다른 팟이 소비하면 동시 실행이 발생하여 양쪽 실행이 모두 확인을 통과하고 마지막 실행이 이전 송장을 덮어쓰지만 결제가 이미 완료된 상태에 대해 발생합니다. 다행히도, 우리는 결제 중에 결제가 성사된 경우에 대한 추가 확인 사항이 있었습니다. 휴!\n\n나는 이 문제에 대한 해결책을 찾기 위해 연구를 시작했고, 내 첫 번째 생각은 상태에 잠금을 구현하는 것이었습니다. 그 후에 Redis를 사용한 분산 잠금 개념을 알게 되었는데, 이미 산업계에서 다양한 응용 분야에 널리 사용되고 있습니다. 그래서 표준 구현을 사용하고 우리의 필요에 맞게 적용하기로 결정했습니다. 이것이 간단하고 영리한 Redis 사용이 얼마나 강력할 수 있는지 흥미롭습니다. 기본 개념은 리소스 실행 시작 시 Redis에 키가 설정되며, 그 키는 실행이 끝날 때 지워질 수 있습니다. 키는 리소스에 고유해야 합니다. 실행 전마다 Redis에서 해당 키가 있는지 확인하여 이미 잠그인 리소스가 있으면 실행을 계속하지 말아야 합니다. 데드락을 피하려면 잠금에 만료 시간을 설정해야 하는 몇 가지 유의사항이 있습니다. 또한, 잠금 키에 대해 매번 고유한 값을 설정하고 이를 해제 시 검사하여 잠금된 리소스를 시도하는 것을 보장해야 합니다. 이러한 기능들은 모두 쉽게 구현할 수 있습니다. 더불어 분산 Redis 클러스터에 구현하는 것은 훨씬 더 까다로울 것입니다. 서로 다른 프레임워크용 많은 라이브러리가 이미 제공되고 있어 같은 기능을 제공합니다. NodeJS의 경우, 공식 권장 라이브러리는 RedLock입니다.\n\nRedis는 다양한 용도로 확장할 수 있는 다재다능한 도구입니다.","ogImage":{"url":"/assets/img/2024-05-17-UsingDistributedLockingwithRedisinNodeJsinanEvent-DrivenSystem_0.png"},"coverImage":"/assets/img/2024-05-17-UsingDistributedLockingwithRedisinNodeJsinanEvent-DrivenSystem_0.png","tag":["Tech"],"readingTime":2},{"title":"자바스크립트에서 Rest 매개변수 사용하는 방법","description":"","date":"2024-05-17 20:26","slug":"2024-05-17-WhatIstheRestParameterinJavaScript","content":"\n\n## ES6 REST 문법\n\n![이미지](/assets/img/2024-05-17-WhatIstheRestParameterinJavaScript_0.png)\n\n# 소개: REST 파라미터의 힘\n\n자바스크립트 세계는 끊임없이 발전하는 풍경 속에서, 코딩을 더 효율적이고 유연하며 재미있게 만들어주는 멋진 기능들로 가득 차있습니다.\n\n<div class=\"content-ad\"></div>\n\nECMAScript 6 (ES6)에서 소개된 하나의 기능은 ...나머지 매개변수이며 ...rest 매개변수로도 쓰입니다. \n\n이 마법같은 구문을 사용하면 함수 인수를 하나의 배열로 쉽게 수집할 수 있습니다.\n\n시작하기 전에 REST와 ...나머지가 완전히 다른 개념임을 언급해야 합니다. REST(API와 관련된 REST)에 대해서는 이 기사들을 확인해주세요:\n\n이제 재미있는 이모지 예제를 활용하여 나머지 파라미터의 기능을 탐험해 봅시다. 어떻게 하는지 알고 있겠죠?\n\n<div class=\"content-ad\"></div>\n\n# 🚀 자바스크립트의 ES6 Rest 파라미터로 미사일 발사\n\n...rest 파라미터는 자바스크립트 함수로 전달된 다양한 수의 인수를 처리하는 간단하면서도 강력한 방법입니다.\n\n여러 개의 이모지 인수를 받아들이는 함수가 있다고 상상해보세요. 이들을 모두 출력해야 할 때의 과제가 생겼다고 가정해 봅시다.\n\n...rest 파라미터를 사용하지 않으면 arguments 객체를 처리해야 할 것입니다. 그러나 ...rest 파라미터를 사용하면 보다 우아하게 처리할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction printEmojis(...emojis) {\n  emojis.forEach(emoji => console.log(emoji))\n}\n\nprintEmojis(\"🚀\", \"🌕\", \"👩‍🚀\")\n// 출력:\n// 🚀\n// 🌕\n// 👩‍🚀\n```\n\n이 예제에서 ...rest 파라미터는 모든 이모지들을 하나의 배열로 모아줍니다. 그리고 우리는 배열을 반복하여 각각을 개별적인 줄에 출력합니다.\n\n# 🧙‍♂️ Rest 파라미터와 구조 분해(Destructuring) 결합하기\n\nRest 파라미터를 destructuring과 결합하여 더욱 강력하게 사용할 수 있습니다. 이런 조합은 마치 마술처럼 보일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기술은 이모지 배열에서 특정 요소를 추출하고 별도로 처리할 수 있게 해줍니다. 이것이 어떻게 동작하는지 실습을 통해 살펴보겠습니다:\n\n```js\nfunction emojiParty(firstEmoji, ...otherEmojis) {\n  console.log(`첫 번째 이모지: ${firstEmoji}`)\n  console.log(`다른 이모지들: ${otherEmojis}`)\n}\n\nemojiParty(\"🎉\", \"🎈\", \"🎊\", \"🎁\")\n// 출력:\n// 첫 번째 이모지: 🎉\n// 다른 이모지들: 🎈,🎊,🎁\n```\n\n이 예제에서는 함수 인수를 구조 분해하여 첫 번째 이모지를 firstEmoji 변수에 할당합니다.\n\n그런 다음, ... rest 파라미터 구문을 사용하여 나머지 이모지를 otherEmojis 배열에 수집합니다.\n\n<div class=\"content-ad\"></div>\n\n이 마술 묘기로, 첫 번째 이모지와 나머지 이모지를 쉽게 나눠서 표시할 수 있어요.\n\n여러 개의 첫 번째 매개변수를 포함하고, 끝에 ...rest 구문만 사용하면 돼요.\n\n# 🔧 인수 객체의 단점을 수정하기\n\n나머지 매개변수는 특히 옛날 ES5 기능인 arguments 객체와 비교할 때 상쾌한 기운을 불어넣어요.\n\n<div class=\"content-ad\"></div>\n\n인수 개체와는 달리, 나머지 매개변수는 실제 배열이며 모든 유용한 배열 메서드를 사용할 수 있습니다.\n\n```js\nfunction printArguments() {\n  // 인수 객체를 배열로 변환\n  const argsArray = Array.from(arguments)\n  // 배열을 순환하며 각 인수를 출력\n  argsArray.forEach(arg => console.log(arg)); \n}\n\nprintArguments(\"🍔\", \"🍟\", \"🥤\")\n// 출력:\n// 🍔\n// 🍟\n// 🥤\n```\n\n인수 개체와는 달리 인수 개체의 forEach 메서드를 사용할 수 없습니다. 이는 열거 가능한 속성을 가진 객체가 아닌 배열류 객체이기 때문입니다.\n\n나머지 매개변수가 배열이므로 \"나머지\"의 사용은 훨씬 더 간단하고 즐거워집니다. 한번 살펴보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction sumEmojisLength(...emojis) {\n  return emojis.reduce((total, emoji) => total + emoji.length, 0);\n}\n\nconst totalLength = sumEmojisLength(\"🎂\", \"🥳\", \"🎈\", \"🎉\")\n\nconsole.log(`Total emoji length: ${totalLength}`)\n// Output: Total emoji length: 8\n// Each emoji has a string length of 2 characters, and 2×4 === 8\n```\n\n이 예시에서는 이모티콘 배열에 reduce 메서드를 사용하여 모든 이모티콘의 총 길이를 계산할 수 있습니다.\n\n나머지 매개변수를 사용함으로써, Array.from()을 사용하여 먼저 인자 객체를 배열로 변환할 필요 없이 번거로움을 줄일 수 있습니다.\n\nJavaScript의 화살표 함수 구문을 사용하면 이 코드가 더 짧아지면서도 여전히 매우 가독성이 높아집니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\nconst calculateEmojiLength = (...emojis) => emojis.reduce((total, emoji) => total + emoji.length, 0)\n\nconst totalLength = calculateEmojiLength(\"🎂\", \"🥳\", \"🎈\", \"🎉\")\n\nconsole.log(`Total emoji length: ${totalLength}`)\n// 출력: Total emoji length: 8\n// 각 이모지는 2개의 문자로 이루어져 있으며, 2×4 === 8\n```\n\n# 🤹 조작하기: 스프레드 연산자 + 나머지 매개변수\n\n나머지 매개변수의 동생인 스프레드 연산자도 세 개의 점 구문을 사용하지만 다른 목적을 가지고 있습니다.\n\n나머지 매개변수는 함수 인수를 배열로 수집하는 반면, 스프레드 연산자는 반대로 작용합니다.\n\n\n<div class=\"content-ad\"></div>\n\n펼침 연산자(Spread)는 배열이나 객체를 개별 요소로 확장하거나 얕은 복사를 하는 데 사용됩니다.\n\n나머지 매개변수와 함께 사용되는 펼침 연산자는 데이터를 쉽게 조작하고 전달할 수 있는 강력한 동료를 만듭니다.\n\n다음 코드 예제에서 이들의 힘을 결합해 보겠습니다:\n\n```js\nconst mixEmojis = (...emojis) => emojis.join(\" \")\n\nconst partyEmojis = [\"🎉\", \"🎈\", \"🎁\"]\nconst celebration = mixEmojis(\"🥳\", ...partyEmojis, \"🎂\")\n\nconsole.log(`Celebration: ${celebration}`)\n// 출력: Celebration: 🥳 🎉 🎈 🎁 🎂\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 partyEmojis 배열 요소를 개별 인수로 mixEmojis 함수에 전달하기 위해 전개 연산자를 사용합니다.\n\n그런 다음 나머지 매개변수가 이를 단일 배열로 수집하고 문자열로 결합합니다. 축하할 일이네요!\n\n# 결론: ... 나머지 매개변수 활용하기\n\n우리가 보았듯이, 나머지 매개변수는 다양한 수의 함수 인수를 우아하게 처리할 수 있는 다재다능한 도구입니다.\n\n<div class=\"content-ad\"></div>\n\nES6 해체 및 전개 연산자와 ...rest 매개변수를 결합하여 더 나은, 더 간단한 코드를 작성할 수 있어요.\n\n물론, React 규칙을 따르고 매개변수로 객체를 전달하는 것이 좋아요. ...rest는 필요없어요!\n\n다른 쪽으로, Tailwind CSS와 함께 작업할 때 항상 간단한 classNames 함수가 필요해서 ... rest 구문을 매일 사용하고 있지만:\n\n```js\nconst classNames = (...args: string[]) => args.filter(Boolean).join(' ')\n```\n\n<div class=\"content-ad\"></div>\n\n여기 아이디어는 문자열 목록을 전달하고, Prettier로 정렬된 Tailwind CSS 클래스 이름을 합치는 것입니다.\n\n만약 그 필터 트릭이 이해되지 않는다면, 왜 이것이 멋지다고 생각하는지 설명한 이전 게시물로 돌아가보세요.\n\n...나머지 매개변수의 마법을 받아들이고, 코드에 이 \"스놀랙스 구문\"을 뿌려넣어 코드를 휴식 시키는 것을 바랍니다!\n\n코딩을 즐기세요! 😴\n\n<div class=\"content-ad\"></div>\n\n# 더 읽을 거리\n\n- Yug Shah이 GeeksforGeeks.org에서 나머지 매개변수에 대해 쓴 글을 참고해보세요.\n\n- 웹 관련 내용을 학습할 때 항상 MDN 문서를 먼저 참고합니다.\n\n- Dhanajay kumar이 Telerik에서 나머지(rest)에 대해 이야기합니다.","ogImage":{"url":"/assets/img/2024-05-17-WhatIstheRestParameterinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-17-WhatIstheRestParameterinJavaScript_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트의 기본 타입과 참조 타입 이해하기","description":"","date":"2024-05-17 20:25","slug":"2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript","content":"\n\nJavaScript을 다룰 때, 원시(primitive) 타입과 참조(reference) 타입의 차이를 알고 데이터가 가변(mutable)인지 불변(immutable)인지 이해하는 것이 매우 중요합니다. 간단한 용어로 설명해보겠습니다.\n\n원시 타입\n원시 타입은 자신의 값을 직접 저장하는 기본 데이터 유형입니다. 이에는 다음이 포함됩니다:\n\n```js\n- Number: 1, 2.5, 100과 같은 숫자\n- String: \"hello\", \"123\"과 같은 문자열\n- Boolean: true 또는 false\n- Null: 어떠한 객체 값도 의도적으로 없음을 나타내는 특별한 값\n- Undefined: 할당된 값이 없는 변수를 나타냄\n```\n\n변수에 원시 값을 할당할 때, 값을 복사합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n```js\nlet x = 10;\nlet y = x;\ny = 20;\nconsole.log(x); // 10\nconsole.log(y); // 20\n```\n\n참조형 타입\n객체(Object)와 배열(Array)과 같은 참조형 타입은 데이터가 메모리에 어디에 저장되어 있는지를 가리키는 참조(또는 주소)를 저장합니다.\n\n```js\nlet obj1 = { name: \"Ali\" };\nlet obj2 = obj1;\nobj2.name = \"Reza\";\nconsole.log(obj1.name); // \"Reza\"\nconsole.log(obj2.name); // \"Reza\"\n```\n\n<div class=\"content-ad\"></div>\n\n가변이란 무엇을 의미합니까?\n가변이란 데이터가 생성된 후에 변경될 수 있다는 것을 의미합니다. JavaScript의 객체, 배열 및 함수는 가변입니다.\n\n```js\nlet person = { name: \"Ali\", age: 25 };\nperson.name = \"Reza\";\nconsole.log(person); // { name: \"Reza\", age: 25 }\n// 배열을 사용한 예시:\n\nlet numbers = [1, 2, 3];\nnumbers.push(4);\nconsole.log(numbers); // [1, 2, 3, 4]\n```\n\n불변이란 무엇을 의미합니까?\n불변이란 데이터가 생성된 후에는 변경할 수 없다는 것을 의미합니다. 숫자, 문자열 및 불리언과 같은 기본 유형은 불변입니다.\n\n문자열을 사용한 예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nlet greeting = \"Hello\";\nlet newGreeting = greeting.replace(\"H\", \"J\");\nconsole.log(greeting); // \"Hello\"\nconsole.log(newGreeting); // \"Jello\"\n```\n\n왜 중요한가요?\n- 메모리 관리: 가변 데이터는 변경이 원본 데이터에 직접적으로 반영되기 때문에 메모리 사용을 최적화하는 데 도움이 됩니다.\n\n실용적인 팁:\n객체나 배열을 다룰 때, 하나의 변수를 변경하면 다른 변수에도 같은 데이터를 참조하고 있다면 영향을 줄 수 있습니다. 이를 피하기 위해 깊은 복사(deep copy)를 사용할 수 있습니다.\n\n```js\n#### 객체의 깊은 복사:\n```javascript\nlet original = { name: \"Ali\", age: 25 };\nlet copy = JSON.parse(JSON.stringify(original));\ncopy.name = \"Reza\";\nconsole.log(original); // { name: \"Ali\", age: 25 }\nconsole.log(copy); // { name: \"Reza\", age: 25 }\n```\n\n<div class=\"content-ad\"></div>\n\n깊은 복사를 통해 원본 객체의 완전히 독립적인 복사본을 생성하므로 복사본을 변경해도 원본에는 영향을 미치지 않습니다.\n\n---\n\n이 개념을 이해하면 더 나은 코드를 작성하고 잠재적인 문제를 피할 수 있습니다. 이에 대해 어떻게 생각하시나요? 생각과 경험을 공유해 주세요!","ogImage":{"url":"/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png","tag":["Tech"],"readingTime":2},{"title":"TypeScript 55 버전에 추가된 3가지 내용 정리","description":"","date":"2024-05-17 20:24","slug":"2024-05-17-3ExcitingNewFeaturesinTypeScript55","content":"\n\n<img src=\"/assets/img/2024-05-17-3ExcitingNewFeaturesinTypeScript55_0.png\" />\n\nTypeScript 세계에서는 항상 개발자 경험을 업그레이드하기 위해 새로운 기능들이 지속적으로 추가됩니다.\n\n오늘도 예외는 아닙니다. TypeScript 버전 5.5가 공식적으로 발표되었습니다!\n\n이 기사에서는 TypeScript의 이 새로운 장을 준비하는 3가지 혁신적인 기능을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n거두 절미하고... 지금 시작해 봐요!\n\n## 1. 추론된 유형 예측\n\n이게 무슨 의미인지 살펴보기 전에, 유형 예측이 무엇인지 정의해 봅시다.\n\n다음은 어떤 입력의 유형을 문자열로 좁히는 유형 예측의 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nlet x = \"test\"\n\n// `is` 키워드로 표시된 타입 예측자.\nfunction isString(variable: any): variable is string {\n  return typeof variable === \"string\"\n}\n\nif (isString(x)) {\n  console.log(x.trim())\n}\n```\n\n이제 타입 예측자에 대해 이해했으니, 유추된 부분은 어디에 있는 걸까요?\n\n인덱스 3에 하나의 null 값만 있는 숫자 배열을 상상해보세요.\n\n```js\nconst nums = [1, 2, 3, null, 5].filter((x) => x !== null)\n\n// nums = [1, 2, 3, 5]\n// 하지만 타입은 여전히 (number | null)[] 유지됩니다!\n```\n\n<div class=\"content-ad\"></div>\n\n- Null 값을 제외하기 위해 필터 함수를 적용했어요.\n- 필터링된 배열에 더 이상 null 값이 없으므로 nums의 타입이 number[]가 되기를 기대합니다.\n\n하지만 아쉽게도 현재 이것은 불가능하여 nums의 타입은 그대로 유지됩니다.\n\n하지만 TypeScript 5.5에서 이 문제가 해결됩니다!\n\nTS 5.5에서는 filter 함수가 결과 배열의 타입을 정확하게 추론하기 위해 암시적으로 타입 예측자를 호출합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 유형 예측 함수가 실제로 어떻게 보일 수 있는지 예시입니다:\n\n```js\n// `filter` 함수 내 각 요소에 대해 호출됨\nfunction isNotNull(x: number | null) {\n  return x !== null;\n}\n```\n\n# 2. 정규식 검사\n\n또 다른 멋진 기능은 TypeScript 유형 검사기를 통해 정규식을 유효성 검사할 수 있는 능력입니다.\n\n<div class=\"content-ad\"></div>\n\nTS 5.5 발표에서 문법 오류가 정규 표현식에서 캐치되는 훌륭한 예시가 있어요:\n\n```js\nlet myRegex = /@robot(\\s+(please|immediately)))? do some task/\n//                                            ~\n// error!\n// Unexpected ')'. Did you mean to escape it with backslash?\n```\n\n또한, 이 기능은 구문 분석만이 아닙니다!\n\n네 맞아요, 타입 체커는 이 예시에서 보여준 것처럼 정규 표현식에서 존재하지 않는 역참조와 같은 의미론적 문제도 잡아낼 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n```js\nlet myRegex = /@typedef \\{import\\((.+)\\)\\.([a-zA-Z_]+)\\} \\3/u;\n//                                                        ~\n// 오류!\n// 이 역참조는 존재하지 않는 그룹을 가리킵니다.\n// 이 정규식에는 캡처 그룹이 2개만 있습니다.\n```\n\n# 3. 상수 인덱스 액세스 범위 좁히기\n\n이제 TypeScript는 obj[key] 형식의 표현식을 좁힐 수 있습니다. 이는 obj와 key가 상수여야만 가능합니다.\n\n다음은 TypeScript 5.5 공식 발표의 예제를 적용한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction changeUnkownValue(obj: Record<string, unknown>, key: string) {\n  if (typeof obj[key] === \"string\") {\n    // Now okay, previously was error\n    obj[key].toUpperCase()\n  }\n}\n```\n\n이전에는 색인 액세스를 사용하여 알 수 없는 Record 값의 유형을 추론할 수 없었습니다.\n\n이 경우 typeof 키워드를 사용하여 알 수없는 타입을 추론하지 못했기 때문에 obj[key].toUpperCase()가 에러를 발생시켰습니다.\n\nTypeScript 5.5에서는 이 문제가 해결되었으며 코드에서 더 이상 문제가 발생하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nTypeScript 5.5에서는 커뮤니티에서 오랫동안 기다려온 많은 흥미로운 기능들이 소개되었습니다.\n\n이러한 기능 중에서 이 3가지를 강조하여 이번에 꼭 필요한 업그레이드의 중요성을 부각했습니다.\n\n# 더 많은 읽기 📖 \n\n<div class=\"content-ad\"></div>\n\n# 제휴사\n\n- All-in-One SaaS 프로젝트 템플릿\n- Figma Home: 내 모든 프로젝트에서 사용하는 UI 디자인 도구.\n- Figma Professional: 당신이 필요로 하는 유일한 UI 디자인 도구.\n- FigJam: 직관적인 다이어그램 및 아이디어 회의로 마음을 자유롭게 발산시킬 수 있습니다.\n\n- Notion: 내 전체 인생을 조직하는 데 사용되는 도구.\n- Notion AI: ChatGPT를 능가하는 AI 도구로 Notion 워크플로우를 급속히 향상시킬 것입니다.\n\n# 참고문헌\n\n<div class=\"content-ad\"></div>\n\n- 맷 포콕 쓰레드\n- TS 5.5 마이크로소프트 블로그\n- 타입 프레디케이트","ogImage":{"url":"/assets/img/2024-05-17-3ExcitingNewFeaturesinTypeScript55_0.png"},"coverImage":"/assets/img/2024-05-17-3ExcitingNewFeaturesinTypeScript55_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러 라우트를 제대로 사용하는 방법 3가지","description":"","date":"2024-05-17 20:22","slug":"2024-05-17-3KeyRecipestoNavigateYourAngularRoutes","content":"\n\n![Angular](/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png)\n\n정직하게 말하자면, 나는 Angular과 사랑과 미움이 공존하는 관계를 가지고 있어. 모든 것이 제대로 작동할 때는 정말 멋져. 그렇지만 그렇지 않고 나에게 힌트나 '더 어려운' 자료가 없는 경우, 그때는 너무나 짜증이 나.\n\n하지만 결국, 어떤 라이브러리, 프레임워크 또는 구글에 직면한 직관적인 답변이 없는 이상한 오류도 마찬가지로 그렇다.\n\n많은 사람들에게 Angular 라우팅은 포기하고 싶게 만드는 문제다. 일부로, 온라인 튜토리얼 중 많은 것들이 기본 라우트를 구현하는 예제들뿐이기 때문이다. 복잡한 시나리오에 적합한 것을 찾는 것은 갑자기 시간 소모적인 시행착오 과정이 될 수 있다.\n\n<div class=\"content-ad\"></div>\n\n앵귤러는 프레임워크이기 때문에 내재적으로 이해하는 데 시간이 걸릴 수 있어도 라우팅 방식이 구현되는 방식은 때로는 지루하게 느껴질 수 있습니다. 그러나 이해하고 난 뒤에는 실제로 과소평가된 보석이라고 생각해요.\n\n리액트와 같은 것과 비교해보면, 리액트는 다양한 방법론의 아드혹 패치워크일 수 있지만, 앵귤러의 '이게 우리가 하는 방식이다' 접근 방식은 여러 팀 간 협업 시 덜 괴로울 수 있어요.\n\n앵귤러에서는 라우트를 별도 모듈(일반적으로 AppRoutingModule)에서 정의하고 RouterModule.forRoot() 메서드를 사용하여 라우트를 등록해요. 라우트는 객체 배열로 정의되며, 각 객체는 경로와 연결된 컴포넌트를 포함해요. 반면 리액트에서는 라우트가 Route, Switch, BrowserRouter와 같은 React Router 라이브러리에서 제공되는 컴포넌트를 사용하여 정의돼요. 이러한 컴포넌트들은 JSX 코드 내에서 직접 사용되며, 라우트 구성이 더 선언적이에요.\n\n앵귤러 라우팅의 장점(AppRoutingModule 및 RouterModule.forRoot()을 통해)은 구성이 중앙 집중화되어 있고 강력한 타입 지정으로 일관된 접근 방식을 제공한다는 점이에요. 반면, 리액트 라우팅(Route, Switch, BrowserRouter 컴포넌트를 통해)은 중앙 집중화가 부족하고 내장된 유형 확인이 없으며, 일관성 부족으로 인한 높은 불일치가 발생할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n제 이야기는 여기까지 하고, 본문의 요점으로 넘어가 봅시다. 이 글에서 다루는 Angular 라우팅 시나리오/레시피 중 가장 중요한 것은 바로 세 가지입니다. 이 세 가지는 모든 앱 개발 작업과 프로젝트를 다루며, 이해하기 어려웠던 부분을 간단하게 설명해줬으면 했던 것들입니다.\n\n# 레시피 1: 여러 수준과 동적 경로를 가진 중첩 라우팅\n\nAngular 라우트에서 동적 경로를 가진 다중 수준의 탐색 구조는 정보가 층층이 쌓인 정체를 푸는 것 같은 신비한 상자와 같은 느낌을 줄 수 있습니다.\n\n라우팅을 처음 배울 때, 우리는 종종 한 수준에서 시작하여 종료하는, 다음 페이지로 이동하고 다시 돌아오는 정도의 시나리오로 끝나곤 합니다. 하지만 90년대가 아니라는 것을 기억해야 합니다. 실제로 레알 앱/사이트는 카테고리, 서브카테고리, 사용자가 작성한 콘텐츠를 통해 동적 경로로 이어지는 필수 요소들이 많습니다.\n\n<div class=\"content-ad\"></div>\n\n이 예시를 위해 상상해 봅시다. 우리는 그것만 있는 전자상거래 애플리케이션을 개발하고 있다고 상상해 봅시다.\n\n## 단계 1: 카테고리, 하위 카테고리 및 제품 컴포넌트를 생성합시다\n\n```js\nng generate component category\nng generate component subcategory\nng generate component product\n```\n\n## 단계 2: AppRoutingModule에서 라우트를 정의합시다\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { CategoryComponent } from './category/category.component';\nimport { SubcategoryComponent } from './subcategory/subcategory.component';\nimport { ProductComponent } from './product/product.component';\n\nconst routes: Routes = [\n  {\n    path: 'category/:categoryId',\n    component: CategoryComponent,\n    children: [\n      {\n        path: 'subcategory/:subcategoryId',\n        component: SubcategoryComponent,\n        children: [\n          {\n            path: 'product/:productId',\n            component: ProductComponent,\n          },\n        ],\n      },\n    ],\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n위 예제에서는 전자 상거래 앱의 각 수준에 대한 경로를 정의했습니다. 경로에서 :categoryId, :subcategoryId 및 :productId 자리 표시 자를 사용한 점에 주목하세요. 이러한 세그먼트는 앱을 통해 탐색할 때 실제 값으로 대체됩니다.\n\n## 단계 3: 컴포넌트 템플릿에 라우터 아웃렛을 추가하여 Angular이 자식 컴포넌트를 렌더링할 위치를 알 수 있도록 합니다:\n\n```js\n<!-- category.component.html -->\n<h1>Category</h1>\n<router-outlet></router-outlet>\n\n<!-- subcategory.component.html -->\n<h2>Subcategory</h2>\n<router-outlet></router-outlet>\n\n<!-- product.component.html -->\n<h3>Product</h3>\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 4: 앱을 통해 이동할 수 있는 몇 가지 라우터 링크를 생성합니다\n\n```js\n<!-- app.component.html -->\n <nav>\n   <ul>\n     <li *ngFor=\"let category of categories\">\n       <a [routerLink]=\"['/category', category.id]\">{ category.name }</a>\n     </li>\n   </ul>\n </nav>\n <router-outlet></router-outlet>\n \n```\n\n이 예에서는 카테고리 배열이 id와 name 속성이 있는 카테고리 데이터를 포함하고 있다고 가정합니다. [routerLink] 지시문은 카테고리, 하위 카테고리 및 제품을 통해 이동할 때 적절한 URL을 생성합니다.\n\n그게 다입니다! 이제 다중 수준 및 동적 경로를 포함하는 중첩 라우팅 구조의 기본 뼈대가 완성되었습니다. 사용자는 이제 카테고리, 하위 카테고리, 제품을 손쉽게 탐색할 수 있으며 앱의 구조는 깔끔하고 조직적입니다.\n\n<div class=\"content-ad\"></div>\n\n# 레시피 2: 라우트 가드 및 역할 기반 액세스와 canActivate\n\n오케이, 멋져요. 중첩된 내용들이 있고, 특정 사람들에게만 보기 권한을 부여하고 특정 작업을 할 수 있게끔 하는 건 어떻게 하는지 궁금하신가요? 예를 들어, 사용자들?\n\n이것이 바로 canActivate 및 RoleGuard의 역할입니다.\n\nAngular에서 역할 기반 액세스 제어를 구현하는 데 Route guards와 canActivate 가드를 사용할 수 있습니다. 이를 통해 응용 프로그램의 특정 부분에 대한 액세스 권한이 있는 사용자만 해당 부분에 액세스할 수 있도록 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n일반 사용자와 관리자 사용자가 있는 응용 프로그램을 개발 중이라고 상상해 봅시다. 이제 사용자의 역할에 따라 특정 경로로의 액세스를 제한하려고 합니다. 이를 위해 RoleGuard라는 사용자 지정 라우트 가드를 만들 수 있습니다.\n\n## 단계 1: RoleGuard 생성\n\n```js\nng generate guard role\n```\n\n## 단계 2: RoleGuard를 생성하고 CanActivate 인터페이스를 구현하여 사용자의 역할을 확인하도록 수정하세요.\n\n<div class=\"content-ad\"></div>\n\n위의 예시에서는 사용자 역할을 확인하고 해당 사용자가 관리자인 경우 true를 반환합니다. 사용자가 관리자가 아닌 경우 홈 페이지로 리디렉션하고 false를 반환합니다.\n\nRoleGuard를 CanActivate 인터페이스를 구현하도록 수정하면, Angular에게이 가드가 사용자의 역할에 기반하여 경로를 활성화 할 수 있는지를 결정해야한다고 말하는 것과 같습니다. 이 경우 사용자의 역할을 확인하는 사용자 정의 로직을 검사합니다.\n\nCanActivate 인터페이스를 구현하려면, 경로를 활성화 할 수 있는지(true) 아니면 할 수 없는지(false)를 나타내는 boolean 또는 boolean을 해결하는 observable 또는 promise를 반환하는 canActivate 메서드를 제공해야합니다. canActivate 메서드가 false를 반환하면, 탐색이 취소되고 사용자가 경로에 액세스하는 것이 방지됩니다.\n\n<div class=\"content-ad\"></div>\n\n사용자의 역할을 확인하여 canActivate 메서드 내에서 특정 라우트에 대한 액세스를 제어할 수 있습니다. 예를 들어 응용 프로그램에 관리자 영역이 있다면, 사용자가 관리자인지 확인하는 canActivate 메서드가 포함된 RoleGuard를 사용하여 액세스를 허용하기 전에 확인할 수 있습니다. 사용자가 관리자가 아닌 경우 가드가 false를 반환하고 탐색이 취소되어 권한이없는 액세스를 방지합니다.\n\n특정 라우트에 대한 액세스를 제어하는 유연하고 안전한 방식을 제공하기 위해 RoleGuard를 수정하여 CanActivate 인터페이스를 구현하고 사용자의 역할을 확인해야합니다. 이는 Angular 응용 프로그램 내에서 사용자 역할이나 권한에 따라 액세스 제어하는 방식입니다.\n\n## 단계 3: 관리자만 액세스할 수 있는 관리자 구성 요소 생성\n\n```js\nng generate component admin\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 4: AppRoutingModule에 관리자 컴포넌트를 위한 새 경로를 추가하고 RoleGuard를 canActivate 가드로 사용하세요.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { AdminComponent } from './admin/admin.component';\nimport { RoleGuard } from './role.guard';\n\nconst routes: Routes = [\n  // ... 다른 경로들 ...\n  {\n    path: 'admin',\n    component: AdminComponent,\n    canActivate: [RoleGuard]\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n## 단계 5: 관리자 페이지로 이동하는 라우터 링크 생성하기\n\n```js\n<!-- app.component.html -->\n<nav>\n  <ul>\n    <!-- ... 다른 링크들 ... -->\n    <li>\n      <a routerLink=\"/admin\">Admin</a>\n    </li>\n  </ul>\n</nav>\n<router-outlet></router-outlet>\n```\n\n<div class=\"content-ad\"></div>\n\n그걸로 끝이에요! ‘admin’ 역할을 가진 사용자만 관리자 경로에 액세스할 수 있고, 다른 사용자는 홈페이지로 리디렉트됩니다.\n\n# 레시피 3: 404 오류 및 리디렉션 처리\n\n언젠가는 사용자가 리디렉트나 404 에러를 만나게 될 것이고, 이를 다룰 필요가 있을 겁니다. 다음은 그 방법입니다.\n\n## 단계 1: 존재하지 않는 경로에 방문한 사용자에게 표시될 NotFoundComponent를 생성하세요\n\n<div class=\"content-ad\"></div>\n\n```js\nng generate component not-found\n```\n\n## Step 2: NotFoundComponent 템플릿을 수정하여 친근한 에러 메시지를 표시하도록 사용자 정의하기\n\n```js\n<!-- not-found.component.html -->\n<h1>이런!</h1>\n<p>찾고 있는 페이지가 없는 것 같아요.</p>\n<a routerLink=\"/\">홈페이지로 돌아가기</a>\n```\n\n## Step 3: AppRoutingModule에 NotFoundComponent를 위한 라우트 추가하기.\n\n<div class=\"content-ad\"></div>\n\n모든 일치하지 않는 경로를 캐치할 수 있는 ** 경로와 와일드카드 라우트를 사용할 것입니다.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { NotFoundComponent } from './not-found/not-found.component';\n\nconst routes: Routes = [\n  // ... 다른 라우트 ...\n  {\n    path: '**',\n    component: NotFoundComponent\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n이 설정을 사용하면 사용자가 존재하지 않는 경로로 이동할 때마다 NotFoundComponent가 표시됩니다.\n\n# 그렇다면 리다이렉트는 어떻게 하죠?\n\n<div class=\"content-ad\"></div>\n\n예전 경로에서 새 경로로 사용자를 리디렉션하고 싶을 때 AppRoutingModule에 리디렉트 경로를 추가하여 이 작업을 수행할 수 있습니다:\n\n```js\nconst routes: Routes = [\n   // ... 다른 경로들 ...\n   {\n     path: 'old-route',\n     redirectTo: '/new-route',\n     pathMatch: 'full'\n   },\n   {\n     path: '**',\n     component: NotFoundComponent\n   },\n ];\n```\n\n이 예제에서 /old-route를 방문하는 사용자는 /new-route로 리디렉션이 됩니다. pathMatch: `full` 옵션은 전체 URL 경로가 일치해야 리디렉션이 발생합니다.\n\n다양한 리디렉트 유형에 대한 설명은 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n## 기본 리다이렉트\n\n기본적으로는 방금 한 것과 똑같지만 목록을 대충 훑는 사람들을 위해 여기에 가져 두는 게 좋다고요.\n\n```js\n{\n   path: 'old-page',\n   redirectTo: '/new-page',\n   pathMatch: 'full'\n}\n```\n\n## 매개변수를 사용한 리다이렉트\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n   path: 'user/:userId/profile',\n   redirectTo: '/profile/:userId',\n   pathMatch: 'full'\n }\n```\n\n이 경우, /user/123/profile을 방문하는 사용자는 /profile/123로 리디렉션이 됩니다. 경로의 :userId 매개변수가 자동으로 새 경로로 전달됩니다.\n\n## 와일드카드를 사용한 리디렉션\n\n```js\n{\n   path: 'legacy/**',\n   redirectTo: '/new-section'\n }\n```\n\n<div class=\"content-ad\"></div>\n\n/legacy/로 시작하는 모든 경로를 방문하는 사용자(e.g., /legacy/some-page, /legacy/another-page)들은 /new-section으로 리디렉션됩니다. ** 와일드카드는 legacy/ 뒤의 모든 하위 경로와 일치시키기 위해 사용됩니다.\n\n## 쿼리 매개변수와 함께 리디렉션하기\n\n쿼리 매개변수를 유지하면서 리디렉션하기 위해서 컴포넌트의 로직을 수정해야 합니다. 다음은 예시입니다:\n\n```js\nimport { ActivatedRoute, Router } from '@angular/router';\n\n constructor(private route: ActivatedRoute, private router: Router) {}\n \n ngOnInit() {\n   const queryParams = this.route.snapshot.queryParams;\n   this.router.navigate(['/new-route'], { queryParams });\n }\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 이전 경로와 관련된 컴포넌트가 초기화될 때 현재 쿼리 매개변수를 읽고, 쿼리 매개변수를 보존한 채 새 경로로 이동합니다.\n\n## 조건부 리디렉션\n\n조건부 리디렉션을 수행하려면 Route Guards를 사용할 수 있습니다. 이전 예시에서 RoleGuard로 보여졌듯이 사용자 지정 Route Guard를 생성하여 특정 조건을 확인하고 그에 따라 리디렉션할 수 있습니다.\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ConditionalRedirectGuard implements CanActivate {\n  constructor(private router: Router) {}\n\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {\n    const condition = // 여러분의 사용자 정의 조건;\n\n    if (condition) {\n      this.router.navigate(['/new-route']);\n      return false;\n    }\n\n    return true;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그럼, 다음 가드를 라우트 구성에 사용해 보세요:\n\n```js\n{\n   path: 'some-page',\n   component: SomePageComponent,\n   canActivate: [ConditionalRedirectGuard]\n }\n```\n\n# 마무리\n\n거의 다 다룬 것 같아요. 이 내용이 유용하게 사용되기를 바라요. Angular 라우팅에는 여기서 다룬 것 이외에도 보안 취약점을 다루고 앱을 망가뜨리는 것을 방지하는 방법 등이 있어요. 하지만 아마도 그건 다음에 해보죠. 지금은 Angular 라우트를 구현하는 방법, 조각으로 만들어둔 레시피에 대해 이야기해 봤어요.\n\n<div class=\"content-ad\"></div>\n\n끝까지 와 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png"},"coverImage":"/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png","tag":["Tech"],"readingTime":11},{"title":"독일, 모든 비용을 통해 FFmpeg 보호하기","description":"","date":"2024-05-17 20:21","slug":"2024-05-17-GermanyToProtectFfmpegAtAllCost","content":"\n\n![Image](/assets/img/2024-05-17-GermanyToProtectFfmpegAtAllCost_0.png)\n\n# 독일 공개 소스 기금이 인터넷 비디오의 기반인 ffmpeg에 대한 엄청난 기부를 발표했습니다.\n\n그거 아시는 분들은 많지 않지만, 온라인 비디오 보기의 붐은 실제로 ffmpeg 덕분에 시작되었습니다.\n\nFfmpeg는 비디오 파일을 변환, 최적화 및 편집하는 명령줄 유틸리티입니다. 초기에는 서버에서 비디오를 처리하는 것이 매우 어려웠기 때문에 온라인 비디오가 인기가 없었던 것입니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 더 빠른 인터넷 연결과 ffmpeg 온라인 플랫폼 덕분에 비디오를 웹 및 브라우저가 이해하는 형식으로 최적화할 수 있었습니다.\n\n오늘날까지 ffmpeg는 많은 애플리케이션에서 널리 사용되며 필요한 모든 비디오 작업을 처리합니다.\n\n그러나 누구도 그것에 대해 알지 못합니다. 왜냐하면 그것은 그 뒤에서 작동하기 때문입니다. 흥미롭게도, 이것은 주요 기술 회사에서 만들어진 것이 아닙니다.\n\n이것은 초기에 프랑스의 천재 컴퓨터 프로그래머인 Fabrice Bellard에 의해 만들어졌습니다. 이후에는 오늘날까지 작업하는 다른 개발자들이 참여했습니다.\n\n<div class=\"content-ad\"></div>\n\n이전 글 중 하나에 썼던 것처럼, 오픈 소스 프로젝트의 유지보수자들은 지원받아야 합니다. 그렇게 하면 프로젝트를 보호하고 유지할 수 있습니다.\n\n독일의 주권 기술 기금을 통해 그와 관련된 흥미로운 이니셔티브가 이루어졌습니다.\n\n이 특별 기금은 중요한 프로젝트에 기부합니다. 그리고 오늘 딱 오늘은 ffmpeg가 그 목록에 추가되었습니다.\n\n2024년과 2025년을 위해 15만 7천 유로 이상의 기부를 받았습니다. 그 너그러운 기부금은 이 프로젝트를 유지하는 데 도움이 될 것입니다. 이는 그 도구가 얼마나 중요한지 때문에 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n깃허브에서 11,000개 이상의 포크가 있습니다. 그리고 깃허브 저장소는 프로젝트의 미러일 뿐입니다!\n\n지금까지 기부를 받은 다른 프로젝트로는 OpenJS 재단, Fortran, curl, systemd, Gnome 또는 Mamba 등이 있습니다.","ogImage":{"url":"/assets/img/2024-05-17-GermanyToProtectFfmpegAtAllCost_0.png"},"coverImage":"/assets/img/2024-05-17-GermanyToProtectFfmpegAtAllCost_0.png","tag":["Tech"],"readingTime":2},{"title":"아니요, 제가 줌에서 당신을 보고 싶지 않아요","description":"","date":"2024-05-17 04:29","slug":"2024-05-17-NoIDontWanttoLookAtYouonZoom","content":"\n\n![NoIDontWanttoLookAtYouonZoom](/assets/img/2024-05-17-NoIDontWanttoLookAtYouonZoom_0.png)\n\nZoom를 항상 싫어했던 유일한 사람인가요?\n\n잘못 이해하지 마세요. 필요한 때에 나타났고, COVID가 거리를 패달아 다녔을 때 나타났죠. 모든 건물이 닫혀 있었고, 마스크를 쓰지 않은 사람은 보지도 못했어요.\n\n저는 대학 시절 COVID를 겪은 사람으로서 이 모든 것을 잘 알고 있어요.\n\n<div class=\"content-ad\"></div>\n\n수업에 가지 않아도 되는 아이디어를 좋아했는데, Zoom 덕분에 교수님들과 매니저들이 완전히 긴장된 상태가 되었어요.\n\n지금은 Zoom 콜을 위해 사람들이 만든 모든 규칙들을 싫어해요:\n\n- 카메라를 꼭 켜야 합니다\n- 좋은 소리를 꼭 설정해야 합니다\n- 채팅에 댓글/질문을 하나 꼭 써야 합니다\n- 프로필 사진이 있어야 합니다\n- 멋진 배경을 가져야 합니다\n\n정말 말도 안 되게 되고 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 내가 어떻게 생겼는지 이미 아는데 내 얼굴을 왜 보려고 하나요?\n\n뻔한 농담을 할 때마다 가짜 미소를 보려고 하는 거예요? 내가 뭘 입었는지 보려고?\n\n진지해져요.\n\n대부분의 경우, 줌 콜이 예정되어 있을 때, 저는 잠옷을 입고 있어요. 화장도 안 하고 머리는 엉망이 되어 있을 거예요. 마치 방금 일어난 것처럼 보일 거예요.\n\n<div class=\"content-ad\"></div>\n\n그건 내가 너나 누구에게도 보고 싶어하는 것이 아닌 걸.\n\n집에서는 칙칙한 모습을 보여주고 싶지 않아. 그건 직장에서 해야 할 일이지.\n\nZoom은 거의 개인 정보 침해로 변모했어.\n\n왜 내 배경이 어떤지 볼 필요가 있어? 내가 어디에 있는지 알고 싶어?\n\n<div class=\"content-ad\"></div>\n\n내 위치는 당신의 사업이 아닙니다.\n\n그리고 온라인에서 사용할 수 있는 멋진 배경에 대해 전혀 신경 쓰지 않습니다. 내 카메라는 꺼져 있어야 하기 때문에 배경을 찾아야 할 이유가 없습니다!\n\n이것은 오디오 통화여야만 합니다.\n\n## 그 큰 불평을 한 이유는 다시 일반 전화 통화를 정상화해야 한다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n저는 서로 얼굴을 본 적이 없고 자신을 소개하거나 화면 공유를 통해 중요한 내용을 논의하고 싶다면 Zoom 콜의 필요성을 이해합니다. 완전히 이해할 수 있어요.\n\n하지만 월간 또는 주간 상호작용에는 Zoom 콜이 필요하지 않아요.\n\n그 순간에, 당신은 누군가를 감시하거나 신뢰하지 않는 사람을 조사하기 위해 Zoom 콜을 진행하고 있어요. 이제 이런 일에 시간을 할애할 여유가 없어요.\n\n오디오 콜이 돌아오기를 바래요 (이전에는 그것이 불편했던 사람으로서).\n\n<div class=\"content-ad\"></div>\n\n저는 빛을 보았어요.\n\n당신의 얼굴을 보고 싶지 않고, 제 얼굴도 보고 싶지 않아요, 알겠죠?\n\n화가 풀렸어요.\n\n90일 안에 글쓰기 습관을 시작하고 싶나요? 여기서 무료 글쓰기 습관 안내서를 받아보세요.","ogImage":{"url":"/assets/img/2024-05-17-NoIDontWanttoLookAtYouonZoom_0.png"},"coverImage":"/assets/img/2024-05-17-NoIDontWanttoLookAtYouonZoom_0.png","tag":["Tech"],"readingTime":2},{"title":"오픈CTI 61의 텔레메트리","description":"","date":"2024-05-17 04:28","slug":"2024-05-17-TelemetryinOpenCTI61","content":"\n\n<img src=\"/assets/img/2024-05-17-TelemetryinOpenCTI61_0.png\" />\n\n6.1부터 OpenCTI는 플랫폼과 관련된 일부 측정 값을 수집합니다. 현재 사용량은 이전보다 매우 많은 데이터 양을 의미하기 때문에 플랫폼 성능을 개선하기 위해 이러한 메트릭 수집은 이제 필수적입니다. 또한 우리에게는 워크플로우를 향상시키고 커뮤니티 사용 패턴에 맞게 적응시키는 것이 중요합니다. 데이터는 익명화되어 통계적으로 처리됩니다. 사용자 개인 정보와 기밀 데이터는 수집되지 않습니다.\n\n함께 이 과정을 알아보도록 합시다! 🙂\n\n# 기밀성과 익명화\n\n<div class=\"content-ad\"></div>\n\n수집된 모든 데이터는 익명화되어 있으며 IP 주소, 이메일 주소 또는 사용자 이름과 같은 개별 사용자를 식별할 수 있는 데이터는 수집하지 않습니다. 따라서 사용자의 개인 정보는 개인정보 규정을 준수하여 보호받고 있습니다.\n\n또한 위협 인식 지식과 관련된 정보를 수집하지 않습니다: 플랫폼에서 소비된 데이터 및 분석 데이터는 엄격히 기밀을 유지합니다.\n\n# 텔레메트리의 목적\n\n수집된 데이터는 다음을 위해 사용됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 플랫폼 사용을 더 잘 이해하여 응용 프로그램의 기능과 성능을 향상시킵니다.\n- 사용자 행동을 분석하여 사용자 경험을 향상시킵니다.\n- 내부 측정항목 및 KPI를 위해 집계 및 익명화된 통계를 생성합니다.\n\n미래에는 외부 보고를 위해 이 통계 데이터도 사용할 계획이며, OpenCTI 사용에 대한 직접적인 통찰을 사용자 및 고객 커뮤니티에 제공할 것입니다.\n\n# 텔레메트리 데이터 계산\n\n텔레메트리 데이터를 수집, 관리 및 내보내기하기 위해 OpenTelemetry 라이브러리를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n메트릭은 텔레메트리 관리자에 의해 매 시간 수집됩니다. 플랫폼 수명 중 변하지 않는 버전과 같은 일부 메트릭은 텔레메트리 관리자 시작 시에 한 번만 수집됩니다.\n\n## 텔레메트리 데이터 내보내기\n\n데이터는 두 가지 방법으로 매 6시간마다 내보냅니다:\n\n- 파일 내보내기 — 메트릭은 파일 내보내기자를 통해 특정 로그 파일에 기록됩니다. 이 파일은 로컬 OpenCTI 폴더(경로: opencti/opencti-platform/opencti-graphql/telemetry/)에서 찾을 수 있으므로 내보낸 데이터에 액세스할 수 있습니다. 이 파일들은 지원 패키지에 포함되어 있습니다. 이 파일들은 항상 생성되며 비활성화할 수 없습니다.\n- OTPL 내보내기 — 연결된 플랫폼의 경우 메트릭은 OTLP 프로토콜을 통해 HTTPS를 통해 telemetry.filigran.io 호스트에 전송됩니다. 이 내보내기는 OpenCTI가 텔레메트리 관리자 시작 시에 호스트명에 연결할 수없는 경우 비활성화됩니다(연결 끊긴 플랫폼).\n\n<div class=\"content-ad\"></div>\n\n내보낸 데이터는 OpenTelemetry JSON 형식으로 작성됩니다.\n\n![그림](/assets/img/2024-05-17-TelemetryinOpenCTI61_1.png)\n\n## 수집된 데이터\n\n다음은 OpenCTI 6.1에서 수집된 플랫폼 사용에 관련된 메트릭 목록입니다:\n\n<div class=\"content-ad\"></div>\n\n- 현재 플랫폼 버전,\n- 플랫폼 고유 식별자,\n- 플랫폼 생성 날짜,\n- 노드(인스턴스) 수,\n- 총 사용자 수,\n- 활성 사용자 수 (즉, 텔레미트리 매니저에 의해 마지막 데이터 수집 이후 세션을 활성화한 사용자 수),\n- 엔터프라이즈 에디션 상태 (EE가 활성화되었는지 여부),\n- 활성 커넥터 수.\n\n# 다음 단계\n\n향후 플랫폼 사용 상황을 더 잘 이해하기 위해 다른 데이터가 수집될 수 있습니다:\n\n- 엔터프라이즈 에디션 활성화 원점 (EE 팝업이 열린 페이지) 등, 어떤 기능이 사용자가 EE를 가장 많이 채택하게 하는지 알아내기.\n- 시간 경과에 따른 평균 세션 기간, 시간이 지남에 따른 사용자 플랫폼 사용 변화 평가.\n- 기능 채택률을 평가하기 위한 몇 가지 메트릭, 시간이 지남에 따른 특정 기능 사용량 파악하는 데 도움이 됩니다. 예를 들어 세션당 특정 기능의 API 호출 수를 통해 계산될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nFiligran을 위한 텔레메트리 데이터 수집은 사용자의 개인 정보와 데이터 기밀성을 고려하며, 플랫폼 이용 방식을 더 잘 이해할 수 있게 해줍니다. 이를 통해 사용자들의 행동에 적합한 솔루션과 기능을 제안하고, 우리 커뮤니티를 위해 OpenCTI 경험과 기능을 가장 잘 개선할 수 있습니다.\n\nSlack 커뮤니티 채널에서 언제든지 관련 질문을 자유롭게 해 주세요! 📢","ogImage":{"url":"/assets/img/2024-05-17-TelemetryinOpenCTI61_0.png"},"coverImage":"/assets/img/2024-05-17-TelemetryinOpenCTI61_0.png","tag":["Tech"],"readingTime":3}],"page":"19","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}