{"pageProps":{"posts":[{"title":"리액트 컴포넌트 이해하기 함수 vs 클래스  모듈화된 UI 만들기를 간단하게 만들기","description":"","date":"2024-05-14 12:03","slug":"2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple","content":"\n\n리액트에서 컴포넌트는 사용자 인터페이스의 주요 구성 요소입니다. 이를 사용하면 UI를 독립적이고 재사용 가능한 조각으로 나눌 수 있으며, 각각이 자체 동작 및 렌더링 로직을 캡슐화합니다. 이 모듈식 접근 방식은 애플리케이션을 유지하고 확장하기 쉽게 만들어줍니다.\n\n![이미지](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_0.png)\n\n리액트에서 컴포넌트는 두 가지 주요 방법으로 정의할 수 있습니다: Function Components(함수 컴포넌트)와 Class Components(클래스 컴포넌트).\n\n# Function Components\n\n\n\n기능 구성 요소는 복잡한 상태 관리나 라이프사이클 메서드에 액세스할 필요가 없는 컴포넌트에 권장되며 더 간단합니다. 이들은 본질적으로 React 엘리먼트를 반환하는 JavaScript 함수입니다. 기본 예제를 살펴보겠습니다:\n\n![Welcome function component example](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_1.png)\n\n이 예제에서 Welcome은 프롭스 객체를 수락하고 간단한 인사 메시지인 React 엘리먼트를 반환하는 함수 컴포넌트입니다. 이 컴포넌트는 이름 프롭을 전달하여 UI에서 사용할 수 있습니다:\n\n![Using the Welcome function component](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_2.png)\n\n\n\n# 클래스 구성요소\n\n클래스 구성요소는 더 많은 기능을 가지고 있으며, 구성요소가 상태를 관리하거나 라이프사이클 이벤트를 처리해야 할 때 사용됩니다. 이들은 React.Component를 확장한 ES6 클래스로 정의되어 있어야 하며, React 요소를 반환하는 render() 메서드를 반드시 포함해야 합니다:\n\n![Class Components](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_3.png)\n\n이 Welcome 클래스 구성요소는 위에서 보여진 함수 구성요소와 유사하게 작동하지만 클래스로 정의되어 있습니다. 또한 render 메서드 내에서 this.props를 사용하여 props에 액세스합니다.\n\n\n\n# 컴포넌트 조합하기\n\n컴포넌트는 출력에서 다른 컴포넌트를 참조할 수 있습니다. 이 조합 기능은 리액트의 강력한 기능 중 하나로, 간단한 구성 요소에서 복잡한 UI를 구축할 수 있게 합니다. 다음은 Welcome 컴포넌트를 사용하여 부모 App 컴포넌트 안에 넣은 예제입니다:\n\n![이미지](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_4.png)\n\n이 App 컴포넌트는 세 개의 다른 이름을 가진 Welcome 컴포넌트를 렌더링하여, 컴포넌트가 다른 속성(props)과 함께 재사용될 수 있는 방법을 보여줍니다.\n\n\n\n# 컴포넌트 추출하기\n\n자주 컴포넌트가 너무 복잡해지면 작은 컴포넌트로 추출하는 것이 좋은 방법입니다. 예를 들어, Comment 컴포넌트가 있다면 Avatar와 UserInfo 컴포넌트를 추출하여 Comment 컴포넌트를 단순화할 수 있습니다:\n\n![Component Extraction](/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_5.png)\n\n이 예에서 Avatar 및 UserInfo는 Comment 컴포넌트의 특정 부분을 처리하는 작은 컴포넌트이며, 주 컴포넌트를 더 깔끔하고 관리하기 쉽게 만듭니다.\n\n\n\n# 결론\n\nReact 컴포넌트는 동적이고 인터랙티브한 사용자 인터페이스를 구축하는 강력하고 다재다능한 도구입니다. 함수 컴포넌트와 클래스 컴포넌트를 이해하고 활용하며, 구성과 추출을 통해 잘 정리되고 유지보수가 쉬운 React 애플리케이션을 만들 수 있습니다.\n\n# 관련 기사\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해 주시면 좋겠어요! 👏\n- 다음 링크에서 우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 저희 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 기반 콘텐츠를 다루는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_0.png"},"coverImage":"/assets/img/2024-05-14-UnderstandingReactComponentsFunctionvsClassBuildingModularUIsMadeSimple_0.png","tag":["Tech"],"readingTime":3},{"title":"마이크로 프론트엔드 Vite를 이용한 React용 모듈 페더레이션","description":"","date":"2024-05-14 12:00","slug":"2024-05-14-MicroFrontendModuleFederationwithViteforReact","content":"\n\n![image](/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_0.png)\n\n백엔드 개발자를 위한 마이크로서비스 아키텍처 소개 후, 우리는 프론트엔드 애플리케이션을 위한 비슷한 아키텍처인 '마이크로 프론트엔드'를 개발하고자 합니다. 이 아키텍처는 마이크로서비스와 비슷한 이점과 단점을 가지고 있습니다. 이 아키텍처를 구현하는 방법 중 하나는 웹팩과 Vite와 같은 번들링 도구에서 제공되는 '모듈 페데레이션'입니다.\n\n# 모듈 페데레이션이란?\n\n모듈 페데레이션은 다양한 빌드가 하나의 애플리케이션을 구성하기 위해 함께 동작하는 개념입니다. 대부분의 경우 하나는 모든 다른 원격 구성 요소를 가져와 공유할 수 있도록 구축된 호스트 애플리케이션일 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_1.png\" />\n\n위의 도식은 작동 방식에 대한 간략한 설명을 보여줍니다. 호스트 애플리케이션에는 각 원격 컴포넌트에 대한 참조가 가져오기(import)나 Lazy Loaded 모듈로 포함됩니다. 각각 \"홈페이지 앱\"과 \"결제 앱\"이 호스팅된 원격 서버에서 공유 컴포넌트는 자바스크립트 모듈로 패키징되어 빌드된 자바스크립트 파일로써 공개적으로 사용 가능합니다(위의 예제에서 \"homepage.js\"와 \"payment.js\"로 확인됨). 그런 다음 호스트 애플리케이션에서 이러한 원격 컴포넌트들을 런타임에 자바스크립트 모듈로 가져와서 호스팅된 애플리케이션에서 컴포넌트로 처리됩니다.\n\n모듈 페더레이션에 대한 더 자세한 내용은 여기서 확인할 수 있습니다.\n\n# Vite에서 모듈 페더레이션을 사용하는 방법?\n\n\n\n모듈 연합 기능을 얻으려면 Vite에 플러그인을 추가해야 합니다. 플러그인은 다음에서 찾을 수 있어요!\n\n모듈 연합 기능을 얻기 위해 설정해야 할 최소한 두 군데가 항상 있어요. 하나는 공유할 컴포넌트가 있는 원격 어플리케이션에 적용돼야 해요. 이 곳에서 Vite에게 어떤 컴포넌트가 모듈로 공유될지, 빌드를 위한 진입점 이름이 무엇인지 알려주는 것이에요. 다른 설정은 모듈 연합을 사용할 호스트 어플리케이션에서 적용돼야 해요.\n\n양쪽에 적용해야 할 구성은 다음과 같아요.\n\n## 원격 어플리케이션 기본 구성\n\n\n\n```js\nexport default defineConfig({\n    plugins: [\n        react(),\n        federation({\n             name: 'remotecomponent1',\n             filename: 'remotecomponent1.js',\n             exposes: {\n                 './Button': './src/components/buttons.tsx'\n             },\n             shared: ['react', 'react-dom', 'react-router-dom'],\n        }),\n    ]\n});\n```\n\n패더레이션 플러그인의 각 필드를 살펴봅시다.\n\nName: 공유 컴포넌트를 포함한 JavaScript 모듈에 할당할 모듈 이름입니다. 필수입니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\nFileName: JavaScript 모듈의 진입 파일의 파일 이름입니다. 이 필드는 필수가 아니며, 기본값은 `remoteEntry.js`입니다. 자세한 내용은 여기에서 확인할 수 있습니다.```\n\n\n\n공개합니다: 원격 모듈로 공개할 구성 요소를 나열해야 하는 곳입니다. 자세한 내용은 여기에서 찾을 수 있습니다.\n\n참고: 모든 노출 구성 요소는 리액트 구성 요소를 기본 내보내기로 내보내야 합니다. 그렇지 않으면 호스트 응용 프로그램 측에서 문제없이 통합할 수 없습니다. 리액트 구성 요소에서 개별 내보내기를 가져올만한 충분한 세부 정보가 없기 때문입니다.\n\n공유: 이것은 조금 복잡한 속성입니다. 라이브러리와 관련하여 리액트와 같은 경우 모든 라이브러리 사이에서 상태를 처리하기 위해 모든 라이브러리 사이에서 하나의 인스턴스를 공유해야 합니다. 따라서 원격 모듈을 사용할 때 리액트 인스턴스를 원격 모듈과 호스트 응용프로그램 모두에서 사용하는 방법이 필요합니다. 이를 위해 호스트 측 구성 및 원격 응용 프로그램 측 구성에 이 속성을 추가하고 공유할 라이브러리 목록을 양쪽에 모두 추가하면 됩니다. 무엇을 공유할지 알리려면 이 속성을 사용하면 됩니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\n# 호스트 응용 프로그램 기본 구성\n\n\n\n호스트 애플리케이션을 구성하는 두 가지 방법이 있습니다. 하나는 원격 모듈 진입 파일의 URL을 직접 참조하는 것이고, 다른 하나는 동적으로 참조를 채우는 것입니다. 두 가지 모두 원격 측에 대한 속성 세트가 비슷하지만 remotes 속성을 제외하고는 동일한 Name과 Shared 속성이 있습니다. 이에 대한 설명은 다음과 같습니다.\n\nRemotes: 원격 모듈의 진입 파일에 대한 참조를 보관합니다. 아래는 remotes 속성을 사용하는 예시입니다. 더 많은 세부 정보는 여기에서 찾을 수 있습니다.\n\n## URL을 사용하여 원격 컴포넌트 가져오기\n\n```js\nexport default defineConfig({\n    plugins: [\n        react(),\n        federation({\n             name: 'remotecomponent1',\n             remotes: {\n                 sharedComp: 'http://localhost:3001/assets/remotecomponent1.js',\n             },\n             shared: ['react', 'react-dom', 'react-router-dom'],\n        }),\n    ]\n});\n```\n\n\n\n## URL을 동적으로 적용하여 Remote 컴포넌트 가져오기\n\n```js\nexport default defineConfig({\n    plugins: [\n        react(),\n        federation({\n             name: 'remotecomponent1',\n             remotes: [\n                 {\n                     sharedComp: {\n                         external: `Promise.resolve(window.remoteURL)`,\n                         from: 'vite',\n                         externalType: 'promise',\n                     },\n                 },\n             ],\n             shared: ['react', 'react-dom', 'react-router-dom'],\n        }),\n    ]\n});\n```\n\n외부: 원격 모듈의 주소가 될 수 있으며, 기본적으로 URL 또는 `string` 형식의 Promise일 수 있습니다. 더 많은 세부 정보는 여기에서 확인할 수 있습니다.\n\nFrom: 원격 모듈이 어디에서 오는지 Vite가 알 수 있도록 하는 속성입니다. Webpack 또는 Vite에서 오는지 여부를 나타냅니다. 더 많은 세부 정보는 여기에서 확인할 수 있습니다.\n\n\n\nExternalType:는 외부 속성에서 사용할 외부 참조 유형을 설정합니다. 이 값은 url 또는 promise가 될 수 있습니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\n참고: 여기 예제에서는 window.remoteURL을 사용하여 url을 가져오고 있습니다. 따라서 이것은 호스트 애플리케이션 시작 시 설정됩니다. 따라서 이 속성은 애플리케이션의 루트 구성 요소인 app.tsx 또는 다른 곳에 설정할 수 있습니다.\n\n# 호스트 애플리케이션 내에서 원격 모듈 사용하는 방법\n\n호스트 애플리케이션의 구성 요소에서 원격 모듈을 사용하는 두 가지 방법이 있습니다.\n\n\n\n## 정적 임포트로 사용\n\n리액트 컴포넌트 내에서 원격 모듈을 항상 정적 임포트할 수 있습니다.\n\n```js\nimport Button from 'sharedComp/Button';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"card\">\n        <Button />\n      </div>\n    </div>\n  )\n}\n\nexport default App;\n```\n\n이 방법도 좋지만 성능과 신뢰성 측면에서는 가장 유망한 방법은 아닙니다. 이 방법을 사용할 때 몇 가지 문제가 발생했습니다. 또한 이 방법을 사용하면 네트워크 수준의 문제를 처리하기 어렵습니다.\n\n\n\n## 레이지로드된 모듈로\n\n이것은 성능을 향상시키고 네트워크 문제를 처리하기 위해 레이지 로딩을 사용하여 원격 모듈을 로드하는 것입니다.\n\n```js\nimport {lazy, Suspense} from 'react';\nconst Button = lazy(() => import('sharedComp/Button') as any);\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"card\">\n        <Suspense fallback={<div>Loading...</div>}>\n          <Button />\n        </Suspense>\n      </div>\n    </div>\n  )\n}\n\nexport default App;\n```\n\n이것은 원격 모듈을 사용하는 권장 방법으로, 이를 통해 네트워크 관련 문제와 성능 관련 문제를 처리할 수 있습니다.\n\n\n\n알림: 만약 TypeScript를 사용하여 구현하고 싶다면, 소스 루트에 사용자 정의 타입 선언 파일을 추가하고 remotes 구성의 이름을 모듈로 추가해야 합니다. 파일 이름은 module.d.ts와 같이 지정할 수 있습니다.\n\n```js\ndeclare module 'sharedComp/*' {}\n```\n\n# 어플리케이션 실행\n\n호스트 및 원격 어플리케이션을 실행할 때 몇 가지 주의할 점이 있습니다.\n\n\n\n- 개발 중일 때 파일 서비스가 작동하려면 개발 모드 대신 미리보기 모드에서 원격 응용 프로그램 및 호스트 응용 프로그램을 실행해야합니다. 그렇지 않으면 파일이 제공되지 않기 때문에 모듈 페더레이션이 개발 모드에서 작동하지 않습니다.\n- 또한 구성 요소를 공유할 때 javascript 모듈로 공유되고 응용 프로그램으로 공유되지 않는다는 것을 기억해야합니다. 응용 프로그램의 책임은 공유 모듈을 가져와 사용할 호스트 응용 프로그램에 의해 수행됩니다. 따라서 원격 구성 요소가 환경 변수나 기타 프로세스 관련 데이터를 사용하는 경우 호스트 응용 프로그램을 통해 원격 구성 요소로 전달될 것입니다. 따라서 원격 구성 요소를 사용할 때 항상 호스트 응용 프로그램이 해당 원격 구성 요소가 실행 중인 플랫폼이라는 것을 기억해주셔야 합니다. 외부 서버에서 실행 중이더라도 모듈 페더레이션을 사용할 때 전달되는 것은 파일만이며, 그 이상이 아닙니다. URL을 통해 원격 서버 측 응용 프로그램이 실행 중인 것을 볼 수는 있지만, 호스트 응용 프로그램 측에서는 단지 공유 javascript 모듈 진입 .js 파일을 참조하고 있을 뿐입니다. 따라서 원격 응용 프로그램 측에서 제공되더라도 호스트 응용 프로그램에서 모든 프로세스 관련 데이터를 제공하도록하십시오.\n\n# 지금까지 배운 내용을 기반으로 기본 시나리오를 구현해 봅시다\n\n여러 팀 간에 나눌 수 있는 다른 구성 요소가있는 사용 사례를 고려해 보겠습니다. E-Commerce 사이트를 시나리오로 삼아보겠습니다. 호스트로 E-Commerce 웹 앱을 개발하고 결제 구성 요소 및 홈페이지 구성 요소를 가져오겠습니다. 기본 시나리오로서 지금은 홈페이지 사용 사례만 구현해 보겠습니다.\n\n나는 react 및 Vite에 대한 vite-plugin-federation 샘플에서 일부 코드를 빌려와 기본 애플리케이션을 가져 와서 모듈 페더레이션의 기본 사용 사례를 보여주는 다음 애플리케이션을 만들었습니다.\n\n\n\n이 샘플에서는 웹사이트의 홈페이지를 원격 모듈로 개발했습니다. 이 모듈은 웹사이트(호스트 애플리케이션)에서 참조됩니다. 원격 모듈은 이 샘플(Main 브랜치)에서 정적 임포트로 가져오며, 원격 모듈은 정적 URL을 사용하여 참조됩니다.\n\n따라서 원격 애플리케이션에서 'Button'과 'Home' 두 가지 컴포넌트를 노출시켰습니다. 그리고 이들을 'homepage.js'라는 entry 파일 이름을 가진 모듈에 추가했습니다.\n\n이제 원격 애플리케이션에서 공유된 Home 컴포넌트를 살펴보겠습니다.\n\n여기서 컴포넌트를 자세히 살펴보면 default로 노출된 것을 볼 수 있습니다. 공유된 컴포넌트를 default로 내보내는 것이 중요합니다. 컴포넌트를 default로 내보내지 않으면 호스트 애플리케이션 측에서 이를 참조하는 것이 어려워집니다.\n\n\n\n호스트 애플리케이션 측에서 원격 모듈을 사용할 때 정적 임포트를 사용할 수 있습니다.\n\n그리고 각 구성 요소를 가져온 후에는 일반 구성 요소와 마찬가지로 사용할 수 있습니다. 그러나 실제 프로덕션 환경에서는 원격 모듈이 시간에 따라 사용할 수 없을 수 있으므로 정적 임포트 사용 시 문제가 발생할 수 있습니다. 따라서 이러한 모듈에 대한 지연 로딩을 사용하면 네트워크 관련 문제를 처리할 때 도움이 됩니다. 이 브랜치의 지연 로딩 예제를 여기에서 찾을 수 있습니다.\n\n지연 로딩을 사용하면 호스트 애플리케이션 측에서 원격 모듈을 사용하는 방법은 다음과 같습니다.\n\n6행과 7행에서 원격 모듈에서 구성 요소를 지연 로딩했습니다. 그런 다음 Suspense 구성 요소 내에서 해당 구성 요소를 사용하여 비동기로로드하고 로드하는 데 시간이 걸리는 경우 대체 구성 요소를 적용했습니다.\n\n\n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n\nAlso when importing these from remote modules if you are using typescript remember to add a custom definition file for types. So here in my implementation I have added the custom.d.ts file. This file help you to get rid of the compilation error Module not found .\n\n# Lets look in to implementing a bit advance scenario\n\nLet’s add the payment component in to the story and make this a bit more complicated. Implementation for the advance scenario can be found in this branch.\n\nThis adds bit of complexity as this uses two different remote modules to load home and payment pages and also added the complexity of react routing on to the host app. Also in this sample the payment page is loaded using a dynamically set URL which is pushed during the runtime through window object.\n\n\n\n\n호스트 애플리케이션 측에서 이 고급 사용 사례를 위한 Vite 구성은 다음과 같이 보입니다.\n\n여기 구성에서는 결제 및 홈 원격 모듈을로드하기 위해 두 가지 다른 원격 구성을 추가했음을 볼 수 있습니다. 각각에 대해 두 가지 다른 외부 유형을 추가했습니다. 여기서 이전 예제에서 한 것처럼 홈 컴포넌트를 설정된 URL로 로드하고 있지만 결제 모듈을 로드하기 위해 외부 유형인 promise를 사용하고 있습니다. 이것은 빌드 단계에서 결제 리모트 모듈이 호스팅되는 URL이 무엇인지 모른다면 런타임에서 설정할 수 있어야 한다는 것을 보여주기 위해 사용하고 있습니다. 이는 애플리케이션을 호스팅하고 모든 URL을 런타임에 해결하는 경우 유용합니다. 그래서 라인 25에서 결제 리모트 모듈의 URL을 런타임 중에 promise를 사용하여 로드하는 아래 구성을 사용하고 있습니다.\n\n```js\nremotes: [\n...\n{\n  payment: {\n     external: 'Promise.resolve(window.paymentUrl)',\n     from: 'vite',\n     externalType: 'promise'\n  },\n}\n...\n```\n\n그리고 호스트 애플리케이션의 App.tsx 컴포넌트 내부에 결제 리모트 모듈 URL을 window 객체에 설정하고, 홈 페이지 리모트 모듈에 추가하여 게으르게 로드하고 있습니다.\n\n\n\n# 개발 중 발생할 수 있는 오류 및 해결 방법\n\n- React, React Router Dom 및 다른 공유 라이브러리가 정의되지 않은 경우.\n\n확인해야 할 사항\n\n- 원격 앱 Vite 구성 또는 호스트 앱 Vite 구성의 공유 속성에 올바른 공유 라이브러리 목록이 추가되지 않은 경우입니다. 양쪽의 공유 목록이 동일해야 합니다.\n- 원격 앱과 호스트 앱 간에 공유해야 하는 모든 것이 공유 목록에 추가되었는지 확인해보세요.\n\n\n\n2. 원격 모듈을 로드하지 못했습니다.\n\n![이미지](/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_2.png)\n\n확인해야 할 사항은 다음과 같습니다.\n\n- 호스트 측 Vite 구성에서 각 원격 모듈 이름이 고유한지 확인하세요.\n- 원격 측 Vite 구성에 올바른 컴포넌트 이름이 명시되어 있는지 확인하세요. 구성 내에서 컴포넌트 이름은 공유하려는 컴포넌트와 비슷해야 합니다.\n- 원격 애플리케이션 측에서 컴포넌트가 기본으로 내보내졌는지 확인하세요.\n\n\n\n3. 만약 모든 패키지가 monorepo 구조에 있다면 npm 호이스팅과 호스트 및 원격 모듈 간의 라이브러리 공유에 문제가 발생합니다.\n\n이는 vite-plugin-federation 쪽에서 열린 이슈입니다. 그러나 모노리포 구조를 유지해야 한다면 위 샘플 프로젝트에서 한 것처럼 각 개별 애플리케이션에서 노드 모듈을 설치해야 합니다.\n\n# 결론\n\n- 원격 모듈을 가져오는 경우 정적 임포트 대신 지연 로딩을 사용하는 것이 좋습니다.\n- 원격 호스팅 모듈의 URL을 알고 있다면 구성에서 정적 URL을 사용하고, 실행 중에 동적으로 URL을 해결해야 할 경우 URL을 해결하기 위해 프로미스 방법을 사용하세요.\n- 문제없이 작동하도록 하려면 모든 것을 공유 컴포넌트에 추가해야 합니다. 예시: 원격 애플리케이션 루트 수준에서 적용한 프로바이더가 있는 경우 이를 공유 컴포넌트 내에 추가하거나 호스트 애플리케이션 측에서 프로바이더를 생성하여 해당 원격 컴포넌트를 감싸야 합니다(이 방법은 테스트하지 않았음)… 이것은 원격 모듈에 함께 패킹될 컴포넌트 및 해당에 필요한 임포트만 공유되기 때문입니다. 따라서 원격 앱의 루트 컴포넌트에 추가한 내용은 공유 컴포넌트 내에서 사용할 수 없습니다.\n- 항상 호스트 및 원격 간에 vue 및 react와 같은 핵심 라이브러리를 공유하세요.","ogImage":{"url":"/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_0.png"},"coverImage":"/assets/img/2024-05-14-MicroFrontendModuleFederationwithViteforReact_0.png","tag":["Tech"],"readingTime":10},{"title":"Nextjs를 사용하여 Resend를 이용해 사용자에게 직접 메일을 보내는 방법","description":"","date":"2024-05-14 11:58","slug":"2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend","content":"\n\nNext.js는 매우 다재다능한 프론트엔드를 제공해줘요. 이를 단독으로 사용하여 웹 사이트의 대부분 요구 사항을 해결할 수 있어요. 프로젝트 구조 자체에 서버 측 렌더링을 활용하고 API를 생성할 수 있는 기능이 내장되어 있어 Next.js 앱의 기능을 확장할 수 있어요.\n\n![Resend 이미지](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_0.png)\n\n이 기사에서는 개발자를 위한 이메일 API인 Resend를 탐색하고 앱과 통합해볼 거예요. 우리는 간단한 연락처 양식을 만들어서 제출하면 제출된 정보와 함께 이메일을 우리 받은 편지함으로 전송할 거에요. 이 통합은 문의, 대기 목록 또는 기타 양식 정보를 받고 바로 우리 받은 편지함으로 전달하고 싶을 때 아주 유용해요.\n\n# 우리 Next.js 앱\n\n\n\n간단한 Next.js 앱을 만들 계획이에요. contact form을 사용해서. yarn create next-app를 사용해서.\n\n```js\nyarn create next-app\n```\n\n프로젝트 구성을 위해 다음 설정을 사용했어요. tailwind를 스타일링에 선택하고 코드를 정리하기 위해 src 디렉토리를 사용했어요.\n\n![이미지](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_1.png)\n\n\n\n## 연락 양식 만들기\n\n간결하게 유지하려고 하며 이름과 이메일을 요청하는 연락 양식을 만들겠습니다.\n\n다음과 같이 index.js 페이지 컴포넌트를 업데이트 해보세요:\n\n```js\nimport { useState } from \"react\";\nimport Head from \"next/head\";\n\nexport default function Home() {\n    const [name, setName] = useState(\"\");\n    const [email, setEmail] = useState(\"\");\n    const [loading, setLoading] = useState(false);\n\n    const handleSubmit = () => {\n      console.log(\"여기에 API 호출하기\")\n    }\n    return (\n        <main\n            className={`flex flex-col items-center p-24 min-h-screen`}\n        >\n            <Head>\n                <title>Contact Me | Coffeed</title>\n            </Head>\n\n            <div className=\"relative flex flex-col gap-4 \">\n                <div className=\"flex flex-col place-items-center gap-4\">\n                    <h1 className={`m-0 text-center text-3xl`}>연락하기</h1>\n                </div>\n                <form\n                    className=\"mt-6 flex flex-col max-w-xl gap-4 z-10\"\n                    onSubmit={handleSubmit}\n                >\n                    <label htmlFor=\"name\" className=\"sr-only\">\n                        이름\n                    </label>\n                    <input\n                        id=\"name\"\n                        name=\"name\"\n                        type=\"text\"\n                        autoComplete=\"name\"\n                        required\n                        value={name}\n                        className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이름\"\n                        onChange={(e) => setName(e.target.value)}\n                    />\n                    <label htmlFor=\"email-address\" className=\"sr-only\">\n                        이메일 주소\n                    </label>\n                    <input\n                        id=\"email-address\"\n                        name=\"email\"\n                        type=\"email\"\n                        autoComplete=\"email\"\n                        required\n                        value={email}\n                        className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이메일\"\n                        onChange={(e) => setEmail(e.target.value)}\n                    />\n                    <button\n                        type=\"submit\"\n                        className=\"flex justify-center rounded-md bg-blue-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-blue-500\"\n                    >\n                        {loading ? (\n                            <div\n                                style={\n                                    borderTopColor: \"transparent\",\n                                }\n                                className=\"w-6 h-6 border-4 border-white border-solid rounded-full animate-spin\"\n                            ></div>\n                        ) : (\n                            \"제출\"\n                        )}\n                    </button>\n                </form>\n            </div>\n        </main>\n    );\n}\n```\n\n\n\n테일윈드를 사용하여 스타일을 입히고 사용자로부터 이름과 이메일을 받는 간단한 양식을 만들었습니다. 양식을 제출할 때 Send Mail API 호출을 트리거합니다.\n\n다음 단계를 진행하기 위해 Next.js에서 Resend 및 필수 API를 설정해봅시다.\n\n# Resend로 시작하기\n\nresend.com으로 이동하여 계정에 로그인하세요. 이메일이나 Github를 사용하여 새로운 계정을 만들 수 있습니다.\n\n\n\nResend는 플랫폼에서 도메인을 소유하고 확인한 경우에만 사용자에게 이메일을 보낼 수 있습니다. 이를 통해 해당 도메인 이름을 사용하여 어떤 이메일 주소에서든 이메일을 보낼 수 있습니다. 예를 들어, noreply@coffeed.com에서 사용자에게 이메일을 보내려면 coffeed.com 도메인을 Resend에 추가한 다음 해당 도메인 이름 레코드를 추가하여 해당 도메인을 소유하고 있는 것을 확인해야 합니다.\n\n## 도메인 추가\n\n도메인을 추가하려면 도메인으로 이동한 다음 도메인 추가를 클릭하세요.\n\n![도메인 추가](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_2.png)\n\n\n\n도메인 이름을 입력하고 지역을 선택해주세요. 기본값인 \"us-east-1\"은 무료이며 저희가 사용하는 용도에 적합합니다.\n\n![도메인 설정](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_3.png)\n\n도메인을 추가하면 DNS 레코드 세트가 표시되며, 해당 레코드들을 도메인 서비스 제공업체에서 업데이트해야 합니다. MX 및 2개의 TXT 레코드를 DNS에 추가한 후에 \"DNS 레코드 확인\"을 클릭하여 도메인을 확인할 수 있습니다.\n\n![DNS 레코드 확인](/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_4.png)\n\n\n\n도메인을 확인하는 것은 이메일 전달성을 보장하는 데 필수적입니다. 한 번 도메인을 확인하면 이메일을 보낼 수 있는 권한이 부여됩니다.\n\n## API 키 생성\n\nAPI 키는 요청을 인증하는 비밀 토큰입니다.\n\n- 사이드바의 API 키로 이동합니다.\n- API 키 생성을 클릭합니다.\n- API 키에 이름을 지정합니다.\n- 허가로 보내기 액세스를 선택하고 액세스를 제한하려는 특정 도메인을 선택하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_5.png\"/>\n\n또한 \"전체 액세스\" 권한이 있지만 보안을 위해 단일 도메인에 제한된 \"전송 액세스\" 권한을 사용하는 것이 좋습니다. .env 파일에 생성된 이 API 키를 RESEND_API_KEY 변수로 추가하세요.\n\n# Next.js 앱에 Resend 추가하기\n\n이제 프로젝트로 돌아가서 Resend sdk 라이브러리를 추가해봅시다. 터미널에서 다음 명령을 실행하세요:\n\n\n\n```js\nyarn add resend\n```\n\n## 1. 이메일 템플릿 추가하기\n\n먼저 src 폴더의 components 폴더에 새로운 이메일 템플릿 폴더를 만들어보세요. src/components/email/ 폴더에 contact-form.jsx라는 새로운 이메일 템플릿을 추가해주세요.\n\n```js\nexport const EmailTemplate = ({\n  name,\n  email\n}) => (\n  <div>\n    <p>안녕하세요 Kavya,</p>\n    <p>\n        {name}님이 웹사이트에서 연락 양식을 제출했습니다. 그들의\n        이메일은 {email} 입니다!\n    </p>\n    <p>\n        감사합니다,\n        <br />\n        Coffee\n    </p>\n  </div>\n);\n```\n\n\n\n이메일 본문을 스타일링하기 위해 HTML을 사용하여 이름과 이메일을 입력할 수 있는 간단한 템플릿을 만들었습니다. React 컴포넌트로 구성된 이 템플릿을 보면 프로젝트에서 디자인한 React 컴포넌트를 사용하거나 수정할 수 있습니다.\n\n## 2. 이메일을 보내는 API 생성하기\n\npages/api/ 디렉토리 아래에 send.js라는 API 파일을 생성하세요. 요청 본문에서 이름과 이메일을 가져와서 Resend 라이브러리의 sendEmail 함수를 호출하고 EmailTemplate과 함께 사용하세요.\n\n```js\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nconst data = await resend.sendEmail({\n    from: `${process.env.FROM_EMAIL}`,\n    to: `${process.env.TO_EMAIL}`,\n    subject: \"🎉 연락 양식으로 새로운 제출이 도착했습니다!\",\n    html: \"\",\n    react: EmailTemplate({ name, email })\n});\n```\n\n\n\n다음 변수들은 .env 파일에 선언되어야 합니다:\n\n- RESEND_API_KEY — Resend 관리자 섹션에서 생성된 API 키.\n- FROM_EMAIL — 메일이 보내지는 이메일 주소. Resend 관리자에서 확인된 도메인으로부터 보내진 것으로 나타나야 합니다.\n- TO_EMAIL — 메일이 전송될 이메일 주소. 이 경우에는 내 이메일 주소로 메일을 보내고 있습니다.\n\n```js\nimport { EmailTemplate } from '../../components/email/contact-form';\nimport { Resend } from 'resend';\n\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nexport default async (req, res) => {\n  try {\n    const { name, email } = JSON.parse(req.body);\n\n    const data = await resend.sendEmail({\n        from: `${process.env.FROM_EMAIL}`,\n        to: `${process.env.TO_EMAIL}`,\n        subject: \"🎉당신의 연락 양식으로의 새로운 제출!\",\n        html: \"\",\n        react: EmailTemplate({ name, email })\n    });\n\n    res.status(200).json(data);\n  } catch (error) {\n    res.status(400).json(error);\n  }\n};\n```\n\n대신 제출된 이메일 주소로 설정하여 사용자에게 바로 이메일이 전송되도록 할 수도 있습니다.\n\n\n\n## 3. 양식 제출 시 이메일 트리거\n\nhandleSubmit 함수를 만들고 이름과 이메일을 본문의 매개변수로 사용하여 이메일을 트리거할 수 있습니다.\n```js\nconst [name, setName] = useState(\"\");\nconst [email, setEmail] = useState(\"\");\nconst [loading, setLoading] = useState(false);\n\nconst handleSubmit = async (e) => {\n    setLoading(true);\n    e.preventDefault();\n\n    if (name == \"\" && email == \"\") {\n        setLoading(false);\n        alert(\"이름과 이메일을 모두 입력해주세요\");\n        return false;\n    }\n\n    await fetch(\"/api/send\", {\n        method: \"POST\",\n        body: JSON.stringify({ name, email }),\n    })\n        .then((res) => res.json())\n        .then((data) => {\n            setLoading(false);\n            if (data && data.id) {\n                alert(`${name}님, 관심 표현해 주셔서 감사합니다! 곧 연락 드리겠습니다!`);\n                setName(\"\");\n                setEmail(\"\");\n            } else {\n                alert(\"죄송합니다! 다시 시도해주세요.\");\n            }\n        })\n        .catch((err) => {\n            setLoading(false);\n            alert(\"우왕! 불행하게도 오류가 발생했습니다.\");\n        });\n    return true;\n};\n```\n\n이렇게 하면 Next.js 앱에 Resend 기능을 연결할 수 있습니다. 여기에 인덱스 페이지의 최종 코드가 있습니다:\n\n\n\n```js\r\nimport { useState } from \"react\";\nimport Head from \"next/head\";\n\nexport default function Home() {\n    const [name, setName] = useState(\"\");\n    const [email, setEmail] = useState(\"\");\n    const [loading, setLoading] = useState(false);\n\n    const handleSubmit = async (e) => {\n        setLoading(true);\n        e.preventDefault();\n\n        if (name == \"\" && email == \"\") {\n            setLoading(false);\n            alert(\"이름과 이메일 주소를 모두 입력해주세요!\");\n            return false;\n        }\n\n        await fetch(\"/api/send\", {\n            method: \"POST\",\n            body: JSON.stringify({ name, email }),\n        })\n            .then((res) => res.json())\n            .then((data) => {\n                setLoading(false);\n                if (data && data.id) {\n                    alert(`${name}님, 저희에게 관심 가져주셔서 감사합니다! 곧 연락드리겠습니다!`);\n                    setName(\"\");\n                    setEmail(\"\");\n                } else {\n                    alert(\"죄송합니다! 다시 시도해주세요.\");\n                }\n            })\n            .catch((err) => {\n                setLoading(false);\n                alert(\"앗! 죄송하지만 오류가 발생했습니다.\");\n            });\n        return true;\n    };\n    return (\n        <main\n            className={`flex flex-col items-center p-24 min-h-screen`}\n       >\n            <Head>\n                <title>나에게 연락하기 | Coffeed</title>\n            </Head>\n\n            <div className=\"relative flex flex-col gap-4 \">\n                <div className=\"flex flex-col place-items-center gap-4\">\n                    <h1 className={`m-0 text-center text-3xl`}>나에게 연락하기</h1>\n                </div>\n                <form\n                    className=\"mt-6 flex flex-col max-w-xl gap-4 z-10\"\n                    onSubmit={handleSubmit}\n                >\n                    <label htmlFor=\"name\" className=\"sr-only\">\n                        이름\n                    </label>\n                    <input\n                        id=\"name\"\n                        name=\"name\"\n                        type=\"text\"\n                        autoComplete=\"name\"\n                        required\n                        value={name}\n                       className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이름\"\n                        onChange={(e) => setName(e.target.value)}\n                    />\n                    <label htmlFor=\"email-address\" className=\"sr-only\">\n                        이메일 주소\n                    </label>\n                    <input\n                        id=\"email-address\"\n                        name=\"email\"\n                        type=\"email\"\n                        autoComplete=\"email\"\n                        required\n                        value={email}\n                        className=\"rounded-md bg-white/5 px-3.5 py-2.5 text-white ring-1 ring-inset focus:ring-blue-600 text-sm md:w-96\"\n                        placeholder=\"이메일\"\n                        onChange={(e) => setEmail(e.target.value)}\n                    />\n                    <button\n                        type=\"submit\"\n                        className=\"flex justify-center rounded-md bg-blue-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-blue-500\"\n                    >\n                        {loading ? (\n                            <div\n                                style={{\n                                    borderTopColor: \"transparent\",\n                                }}\n                                className=\"w-4 h-4 border-2 border-white border-solid rounded-full animate-spin\"\n                            ></div>\n                        ) : (\n                            \"제출하기\"\n                        )}\n                    </button>\n                </form>\n            </div>\n        </main>\n    );\n}\r\n```\n\n양식을 제출하면 이메일이 .env 파일에 설정된 TO_EMAIL로 전송됩니다.\n\n<img src=\"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_6.png\" />\n\n이메일 API를 활용하여 다른 사용 사례에 통합하여 직접 알림을 받을 수도 있습니다.\n\n\n\nNext.js playbook **Coffee** 팀에서 작업 중인 페이지입니다. 대기 목록에 추가하려면 coffee@coffeeinc.in으로 이메일을 보내주세요.","ogImage":{"url":"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_0.png"},"coverImage":"/assets/img/2024-05-14-HowtosendmailtousersdirectlyfromNextjsusingResend_0.png","tag":["Tech"],"readingTime":13},{"title":"리액트에서 반응형 디자인 구축하기 어떤 기기에서도 멋있게 보이는 반응형 디자인을 만들기 위한 최상의 방법","description":"","date":"2024-05-14 11:57","slug":"2024-05-14-BuildingaresponsivedesigninReactBestpracticesforcreatingaresponsivedesignthatlooksgreatonanydevice","content":"\n\n반응형 디자인은 현대 웹 개발의 중요한 측면이 되었습니다. 이 기사에서는 React에서 반응형 디자인을 구축하는 최상의 방법과 어떻게 모든 기기에서 멋지게 보이는 디자인을 만들 수 있는지 알아보겠습니다.\n\n## 반응형 디자인 원리 활용하기\n\nReact에서 반응형 디자인을 만들기 위해서는 반응형 디자인 원리를 활용하는 것이 중요합니다. 이는 웹사이트가 데스크톱, 태블릿 또는 스마트폰 등 모든 기기에서 멋지게 보이도록 보장합니다. 이러한 원리에는 상대적인 단위를 사용해 글꼴 크기를 조절하고 유연한 레이아웃을 사용하며 다양한 화면 크기에 맞게 이미지를 최적화하는 것이 포함됩니다.\n\n## CSS 프레임워크 사용하기\n\n\n\nCSS 프레임워크를 사용하면 빠르고 쉽게 반응형 디자인을 만들 수 있어요. 리액트와 함께 사용할 수 있는 여러 CSS 프레임워크가 있습니다. 부트스트랩, 마테리얼라이즈, 시맨틱 UI 등이 있어요. 이러한 프레임워크들은 사전 제작된 구성 요소와 반응형 레이아웃을 제공하며 필요에 맞게 사용자 정의할 수 있어요.\n\n# 미디어 쿼리 활용\n\n미디어 쿼리는 화면 크기를 기반으로 웹사이트에 다른 스타일을 적용할 수 있는 CSS 기능이에요. 미디어 쿼리를 사용하여 레이아웃, 폰트 크기 및 기타 디자인 요소를 조정하여 모든 기기에서 웹사이트가 멋지게 보이도록 할 수 있어요.\n\n```js\n@media (max-width: 768px) {\n .container { flex-direction: column;\n  } \n} \n@media (min-width: 768px) { \n.container {\n flex-direction: row; \n  } \n}\n```\n\n\n\n이 예시에서 두 개의 미디어 쿼리를 정의했습니다. 첫 번째 쿼리는 화면 크기가 768픽셀 이하일 때 적용됩니다. 이 쿼리는 flex-direction 속성을 column으로 설정하여 레이아웃을 단일 열로 변경합니다. 두 번째 쿼리는 화면 크기가 768픽셀 이상일 때 적용됩니다. 이 쿼리는 flex-direction 속성을 row로 설정하여 레이아웃을 여러 열로 변경합니다.\n\n# Flexbox 사용\n\nFlexbox는 유연한 레이아웃을 생성할 수 있는 CSS 기능입니다. Flexbox를 사용하면 다양한 화면 크기와 방향에 맞춰 레이아웃을 조정할 수 있습니다. Flexbox를 이용하면 모든 기기에서 멋지게 보이는 반응형 디자인을 쉽게 만들 수 있습니다.\n\n```js\n.container {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n}\n```\n\n\n\n이 예제에서는 유연한 레이아웃을 만들기 위해 flexbox를 사용하는 컨테이너 요소를 정의했습니다. display 속성을 flex로 설정하여 브라우저에 flexbox를 사용하도록 지시했습니다. flex-direction 속성을 row로 설정하여 레이아웃이 행으로 표시되도록 했습니다. justify-content 속성을 space-between으로 설정하여 항목을 주축을 따라 균등하게 배치했습니다. align-items 속성을 center로 설정하여 항목을 교차 축을 따라 가운데 정렬했습니다.\n\n# React 반응형 라이브러리 사용하기\n\n다양한 React 반응형 라이브러리를 사용하면 반응형 디자인을 보다 편리하게 구축할 수 있습니다. 이러한 라이브러리에는 react-responsive, react-device-detect, react-media 등이 있습니다. 이러한 라이브러리는 기기 유형을 감지하고 레이아웃을 그에 맞게 조정하는 데 도움이 되는 컴포넌트를 제공합니다.\n\n```js\nimport { useMediaQuery } from \"react-responsive\";\n\nfunction MyComponent() {\n  const isTabletOrMobile = useMediaQuery({ maxWidth: 768 });\n\n  return (\n    <div> {isTabletOrMobile ? <MobileComponent /> : <DesktopComponent />} </div>\n  );\n}\n```\n\n\n\n이 예시에서는 react-responsive 라이브러리의 useMediaQuery 훅을 사용하여 기기가 태블릿 또는 모바일 장치인지 감지했습니다. isTabletOrMobile 변수를 사용하여 MobileComponent 또는 DesktopComponent 중 하나를 조건부로 렌더링했습니다.\n\n# 결론\n\nReact에서 반응형 디자인을 구축하는 것은 웹사이트가 모든 기기에서 훌륭하게 보이도록 보장하는 데 중요합니다.","ogImage":{"url":"/assets/img/2024-05-14-BuildingaresponsivedesigninReactBestpracticesforcreatingaresponsivedesignthatlooksgreatonanydevice_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaresponsivedesigninReactBestpracticesforcreatingaresponsivedesignthatlooksgreatonanydevice_0.png","tag":["Tech"],"readingTime":3},{"title":"React TypeScript 마스터하기 개발자를 위한 포괄적인 가이드","description":"","date":"2024-05-14 11:54","slug":"2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers","content":"\n\n![이미지](/assets/img/2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers_0.png)\n\nReact 능력을 더 높이고 싶은 개발자이신가요? TypeScript로 React를 마스터하려면 더 이상 찾을 필요가 없어요. 이 포괄적인 안내서는 React 응용 프로그램을 TypeScript로 구축하는 데 필요한 모든 것을 알려줄 거에요. 처음 시작하는 중이거나 React를 한동안 사용해온 분이더라도, 이 안내서는 깨끗하고 효율적이며 확장 가능한 코드를 작성하는 데 필요한 도구와 지식을 제공할 거예요. 그러니 함께 React TypeScript의 세계를 탐험해 봐요!\n\n# 1. 함수 컴포넌트\n\n## 1.1 외부 선언\n\n\n\n저희 컴포넌트의 props에 대한 타입을 정의하기 위해 인터페이스를 사용하세요.\n\n```js\ninterface GreetingProps {\n  name: string;\n}\n\nconst Greeting = ({ name }: GreetingProps) => <div>Hello, {name}!</div>;\n```\n\n## 1.2 Inline Declaration\n\n조금 더 간단한 props를 가진 컴포넌트의 경우, 인라인으로 선언할 수 있습니다.\n\n\n\n```js\nconst Greeting = ({ name }: { name: string }) => <div>환영합니다, {name}님!</div>;\n```\n\n## 1.3 제네릭 사용하기\n\n제네릭은 컴포넌트 props의 유연성을 향상시킵니다.\n\n```js\n// 제네릭 타입 정의\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n}\n\n// 그 제네릭 타입을 사용하여 함수 컴포넌트 생성\nconst List: React.FC<ListProps<string>> = ({ items, renderItem }) => (\n  <ul>{items.map((item, index) => <li key={index}>{renderItem(item)}</li>)}</ul>\n);\n\nconst UserList = () => {\n  const users = [\"Alice\", \"Bob\", \"Charlie\"];\n  return <List items={users} renderItem={(user) => <strong>{user}</strong>} />;\n};\n```\n\n\n\n# 2. 훅\n\n## 2.1 useState\n\n간단히 초기값을 제공하면 TypeScript가 해당 유형을 자동으로 유추해줍니다.\n\n```js\nconst [counter, setCounter] = useState(0);\n// 'counter'는 숫자로 추론됩니다\n// 'setCounter'는 숫자나 숫자를 반환하는 함수를 입력으로 받는 함수입니다\n```\n\n\n\n초기 상태가 정의되지 않을 수 있는 경우에는 상태의 타입을 명시적으로 정의할 수 있습니다.\n\n```js\ninterface User {\n  name: string;\n  id: number;\n  email: string;\n}\n\nfunction UserProfile() {\n  const [user, setUser] = useState<User | undefined>();\n\n  // 'user'은 User 객체이거나 undefined일 수 있습니다.\n}\n```\n\n`User | undefined`와 같이 undefined일 수 있는 제네릭을 사용할 때, 객체가 undefined일 수 있다는 오류가 발생할 수 있습니다. 이 경우 다음 두 가지 방법으로 처리할 수 있습니다:\n\n- 옵셔널 체이닝 연산자 `?.`을 사용하는 것입니다.\n\n\n\n```js\nfunction UserProfile() {\n  const [user, setUser] = useState<User | undefined>();\n\n  return (\n    <div>\n      Name: {user?.name} {/* 여기서 선택적 체이닝을 사용했습니다. */}\n    </div>\n  );\n}\n```\n\n- 초기값으로 빈 객체 제공 및 타입 어설션 사용\n\n```js\nconst [user, setUser] = useState<User>({} as User);\n// 여기서 우리는 빈 객체가 실제로 User 객체라고 말하고 있습니다.\n```\n\n## 2.2 useCallback\n\n\n\n\n위의 텍스트를 부탁하신 대로 친절하게 한국어로 번역해 드리겠습니다.\n\n함수의 타입은 첫 번째 인수에서 추론됩니다.\n\n버튼이 클릭될 때 작업을 수행해야 하는 함수가 있고, 그러나 이 함수가 컴포넌트가 렌더링될 때마다 재생성되지 않도록 하고 싶다면 useCallback을 사용할 수 있습니다.\n\n```js\nconst saveUser = useCallback(\n  (id: number, userData: User) => {\n    // 이 함수가 사용자 데이터를 서버로 보내는 상황을 상상해보세요\n    api.updateUser(id, userData);\n  },\n  [],\n); // 의존성 배열이 비어 있으므로, 이 함수는 한 번 생성되고 재생성되지 않음\n\n// 'saveUser'는 다음과 같이 추론됩니다: (id: number, userData: User) => void\n```\n\n## 2.3 useMemo\n\n\n\n제공된 첫 번째 인수의 반환 값을 기반으로 유형이 추론됩니다.\n\n카트에 있는 항목들의 총 가격을 계산하는 시나리오를 고려해 보세요. 세금을 포함한 가격을 계산하려면:\n\n```js\nconst totalPrice = useMemo(() => {\n  const price = items.reduce((total, item) => total + item.price, 0);\n  return (price * (1 + taxRate)).toFixed(2);\n}, [items, taxRate]); // 'totalPrice'은 toFixed로 인해 문자열로 추론됩니다\n```\n\n값의 반환 유형을 명시적으로 지정할 수도 있습니다.\n\n\n\n그러나 제네릭을 사용하여 명시적으로 잘못된 유형을 설정하려고하면 TypeScript에서 경고가 발생할 것입니다:\n\n```js\n// toFixed로 인해 반환 유형이 문자열인 경우 오류가 발생합니다.\nconst totalPrice = useMemo<number>(() => {\n  const price = items.reduce((total, item) => total + item.price, 0);\n  return (price * (1 + taxRate)).toFixed(2);\n}, [items, taxRate]); // 오류: 'string' 형식은 'number' 형식에 할당할 수 없습니다.\n```\n\n## 2.4 useRef\n\nDOM 노드에 액세스하려면 null의 초기값을 제공할 수 있습니다.\n\n\n\n페이지가 로드될 때 텍스트 입력란에 초점을 맞추어야 할 때:\n\n```js\nconst inputRef = useRef<HTMLInputElement>(null);\n\nuseEffect(() => {\n  // 컴포넌트가 마운트된 후 입력 요소에 초점을 맞춥니다\n  inputRef.current?.focus();\n}, []);\n```\n\nuseRef는 업데이트되어도 다시 렌더링을 발생시키지 않는 타이머 참조와 같은 변경 가능한 값을 저장하는 데에도 사용할 수 있습니다.\n\n2초마다 메시지를 기록하는 타이머를 설정하고 싶다고 가정해봅시다:\n\n\n\n```js\nconst timerRef = useRef<NodeJS.Timer>();\n\nuseEffect(() => {\n  timerRef.current = setInterval(() => {\n    console.log(\"Timer tick\");\n  }, 2000);\n\n  // 컴포넌트가 언마운트 될 때 interval을 정리합니다.\n  return () => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n    }\n  };\n}, []);\n```\n\n## 2.5 useImperativeHandle\n\nuseImperativeHandle은 ref를 사용할 때 노출되는 인스턴스 값을 사용자 정의하는 데 사용됩니다. 타입은 forwardRef 지점에서 정의되며, 제네릭이 전달되는 순서를 주의해야 합니다—ref는 props 앞에 옵니다.\n\n부모 컴포넌트에서 리셋할 수 있는 사용자 정의 입력 컴포넌트가 있는 시나리오를 상상해봅시다.```\n\n\n\n```js\nimport { useRef, forwardRef, useImperativeHandle, useState } from \"react\";\n\n// 사용자 정의 ref 타입 정의\ninterface CustomInputHandle {\n  clear: () => void;\n}\n\nconst Form = () => {\n  // null로 초기화\n  const inputRef = useRef<CustomInputHandle>(null);\n\n  const handleClearClick = () => {\n    inputRef.current?.clear();\n  };\n\n  return (\n    <div>\n      <CustomInput ref={inputRef} />\n      <button onClick={handleClearClick}>Clear Input</button>\n    </div>\n  );\n};\n\n// props와 ref 타입 정의의 역순에 유의하세요\nconst CustomInput = forwardRef<CustomInputHandle, {}>((props, ref) => {\n  const [text, setText] = useState(\"\");\n\n  useImperativeHandle(ref, () => ({\n    clear: () => {\n      setText(\"\");\n    },\n  }));\n\n  return (\n    <input type=\"text\" value={text} onChange={(e) => setText(e.target.value)} />\n  );\n});\n\nexport default Form;\n```\n\n## 2.6 useContext\n\nuseContext를 사용하면 컴포넌트에서 context 객체를 소비할 수 있습니다. 자동으로 타입이 유추되므로 createContext 단계에서 타입을 정의하는 것이 중요합니다.\n\n초기 값 설정이 가능하며 TypeScript가 자동으로 타입을 추론합니다.\n  \n\n\n\n```js\nconst ThemeContext = createContext({\n  theme: \"light\",\n  toggleTheme: () => {},\n});\n\n// 'ThemeContext'는 다음과 같이 추론됩니다:\n// const ThemeContext: React.Context<{\n//   theme: string;\n//   toggleTheme: () => void;\n// }>\n```\n\n만약 컨텍스트 타입을 더 엄격하게 보장하고 싶다면, 빈 객체와 타입 어순화를 사용하여 제네릭을 사용할 수 있습니다.\n\n```js\ninterface ThemeContextType {\n  theme: string;\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType>({} as ThemeContextType);\n\n// 'ThemeContext'는 이제 'theme'와 'toggleTheme'을 갖는 객체를 엄격하게 요구합니다.\n```\n\n## 2.7 useReducer\n\n\n\n\nuseReducer은 React에서 상태 관리에 사용되는 훅으로, 여러 하위 값이 관련되거나 다음 상태가 이전 상태에 의존하는 복잡한 상태 논리가 있는 경우 특히 유용합니다. TypeScript는 상태와 액션에 대한 타입을 제공하여 useReducer를 매우 효과적으로 활용할 수 있습니다.\n\n예를 들어, 항목을 추가하거나 제거할 수 있는 쇼핑 카트를 관리하는 경우:\n\n```js\nimport { useReducer } from \"react\";\n\nconst initialCart = {\n  items: [],\n  total: 0,\n};\n\n// 1. 초기 상태 타입 정의\ntype CartState = typeof initialCart;\n\n// 2. 액션 타입 정의\ntype CartActionType =\n  | { type: \"addItem\"; payload: { item: string; price: number } }\n  | { type: \"removeItem\"; payload: { index: number } };\n\nfunction cartReducer(state: CartState, action: CartActionType) {\n  switch (action.type) {\n    case \"addItem\":\n      return {\n        ...state,\n        items: [...state.items, action.payload.item],\n        total: state.total + action.payload.price,\n      };\n    case \"removeItem\":\n      const newItems = state.items.filter((_, index) => index !== action.payload.index);\n      return {\n        ...state,\n        items: newItems,\n        total: state.total - state.items[action.payload.index].price,\n      };\n    default:\n      throw new Error();\n  }\n}\n\nconst ShoppingCart = () => {\n  const [cart, dispatch] = useReducer(cartReducer, initialCart);\n  return (\n    <>\n      총액: {cart.total}\n      <button onClick={() => dispatch({ type: \"addItem\", payload: { item: 'Apple', price: 1 } })}>\n        사과 추가\n      </button>\n      <button onClick={() => dispatch({ type: \"removeItem\", payload: { index: 0 } })}>\n        항목 제거\n      </button>\n      {/* 상품 목록 */}\n      {cart.items.map((item, index) => (\n        <div key={index}>{item}</div>\n      ))}\n    </>\n  );\n};\n\nexport default ShoppingCart;\n```\n\n## 2.8 useEffect / useLayoutEffect\n\n\n\nuseEffect와 useLayoutEffect은 함수 컴포넌트에서 부작용을 수행하는 데 사용되는 훅입니다. 이들은 componentDidMount, componentDidUpdate 및 componentWillUnmount과 같은 클래스 컴포넌트의 라이프사이클 메서드와 유사합니다. TypeScript에서 이러한 훅에 대한 타입을 명시적으로 정의할 필요가 없는 이유는 이러한 훅이 타입 정의를 필요로 하는 것이 없기 때문입니다.\n\n다음은 API에서 사용자 데이터를 가져와야 하는 애플리케이션에서 useEffect를 사용한 실제 예시입니다:\n\n```js\nimport { useEffect, useState } from \"react\";\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst UserProfile = () => {\n  const [user, setUser] = useState<User | null>(null);\n\n  useEffect(() => {\n    const fetchUserData = async () => {\n      const response = await fetch(\"https://api.example.com/user\");\n      const userData: User = await response.json();\n      setUser(userData);\n    };\n\n    fetchUserData();\n  }, []); // 의존성 배열이 비어 있으면, 이 효과는 componentDidMount와 유사하게 한 번만 실행됩니다.\n\n  if (!user) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n};\n\nexport default UserProfile;\n```\n\n# 3. 내장 타입\n\n\n\n## 3.1 스타일 속성 유형\n\nReact에서 자식 컴포넌트에 인라인 스타일을 전달하려면 React.CSSProperties를 사용할 수 있습니다.\n\n```js\ninterface Props {\n  style?: React.CSSProperties;\n}\n```\n\n## 3.2 자식 요소 유형\n\n\n\n3.2.1 React.ReactNode\n\nJSX에서 렌더링할 수 있는 모든 유형의 연합체입니다. 문자열, 숫자, React 엘리먼트 및 이러한 유형의 배열이 포함됩니다.\n\n```js\ninterface Props {\n  children?: React.ReactNode;\n}\n```\n\n이 유형을 사용하면 children prop이 JSX에서 렌더링할 수 있는 어떤 유형이든 될 수 있음을 TypeScript에 알리는 것입니다. 매우 유연합니다.\n\n\n\n3.2.2 React.ReactElement\n\n이 유형은 문자열이나 숫자와 같은 JavaScript 기본 유형을 제외하고 JSX 요소만 포함합니다. 이는 주로 함수 컴포넌트의 반환 유형을 정의하는 데 사용됩니다.\n\n```js\ninterface Props {\n  children?: React.ReactElement;\n}\n```\n\n## 3.3 컴포넌트 속성 유형 가져오기\n\n\n\n만약 자식 컴포넌트가 인라인으로 props를 정의하고 부모 컴포넌트가 자식의 props 유형을 참조해야 할 경우, React.ComponentProps를 사용하여 자식 컴포넌트의 props 유형을 추론할 수 있습니다.\n\n```js\nconst ChildComponent = ({ message }: { message: string }) => <div>{message}</div>;\n\ntype ChildPropsType = React.ComponentProps<typeof ChildComponent>;\n\n// ChildPropsType는 다음과 같이 추론됩니다:\n// type ChildPropsType = {\n//   message: string;\n// }\n```\n\n# 4. 이벤트 처리\n\n## 4.1 이벤트 유형\n\n\n\n리액트에서 이벤트를 다룰 때는 이벤트 핸들러 내에서 예상한 속성에 액세스할 수 있도록 올바른 이벤트 유형을 지정하는 것이 중요합니다.\n\n### 4.1.1 onClick 이벤트\n\n버튼 요소에서 마우스 이벤트를 처리할 때, React.MouseEvent에 HTMLButtonElement를 제네릭 매개변수로 전달하세요.\n\n```js\ninterface Props {\n  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;\n}\n```  \n\n\n\n4.1.2 onChange 이벤트\n\n입력 요소에서의 변경 이벤트에 대해 React.ChangeEvent에 HTMLInputElement를 일반적인 매개변수로 전달하십시오.\n\n```js\nfunction App() {\n  const [value, setValue] = useState(\"\");\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setValue(event.target.value);\n  };\n\n  return <input value={value} onChange={handleChange} />;\n}\n```\n\n4.1.3 공통 이벤트 유형\n\n\n\n가장 일반적인 몇 가지입니다:\n\n- React.MouseEvent: 클릭이나 마우스 이동과 같은 마우스 이벤트에 사용됩니다.\n- React.ChangeEvent: 값이 변경될 때 주로 폼 요소에서 변경 이벤트에 사용됩니다.\n- React.KeyboardEvent: 키 입력을 캡처하는 키보드 이벤트에 사용됩니다.\n- React.DragEvent: 드래그 앤 드롭 상호작용에 사용됩니다.\n- React.FocusEvent: onFocus 및 onBlur와 같은 포커스 관련 이벤트에 사용됩니다.\n- React.FormEvent: 관련된 모든 폼 상호작용을 포함하는 폼 이벤트에 사용됩니다.\n- React.WheelEvent: 스크롤링과 같은 마우스 휠 이벤트에 사용됩니다.\n- React.TouchEvent: 터치 기능 장치에서 터치 이벤트에 사용됩니다.\n- React.ClipboardEvent: 복사 및 붙여넣기와 같은 클립보드 이벤트에 사용됩니다.\n- React.AnimationEvent: CSS 애니메이션 이벤트에 사용됩니다.\n- React.TransitionEvent: CSS 전환 이벤트에 사용됩니다.\n\n4.1.4 HTML 태그 및 유형 매핑\n\nReact와 TypeScript를 함께 사용할 때 이벤트를 처리하거나 참조를 만들 때 HTML 태그를 해당 유형으로 매핑하는 것이 중요합니다. 이러한 매핑을 통해 이벤트 핸들러나 참조가 해당 요소에 특정한 속성과 메서드에 액세스할 수 있도록 보장됩니다. TypeScript에서 일반적인 HTML 태그와 해당 유형은 다음과 같습니다:\n\n\n\n```js\n인터페이스 HTMLElementTagNameMap {\n  \"a\": HTMLAnchorElement;\n  \"article\": HTMLElement;\n  \"aside\": HTMLElement;\n  \"body\": HTMLBodyElement;\n  \"br\": HTMLBRElement;\n  \"button\": HTMLButtonElement;\n  \"canvas\": HTMLCanvasElement;\n  \"div\": HTMLDivElement;\n  \"dl\": HTMLDListElement;\n  \"dt\": HTMLElement;\n  \"dd\": HTMLElement;\n  \"em\": HTMLElement;\n  \"footer\": HTMLElement;\n  \"form\": HTMLFormElement;\n  \"h1\": HTMLHeadingElement;\n  \"h2\": HTMLHeadingElement;\n  \"h3\": HTMLHeadingElement;\n  \"h4\": HTMLHeadingElement;\n  \"h5\": HTMLHeadingElement;\n  \"h6\": HTMLHeadingElement;\n  \"head\": HTMLHeadElement;\n  \"header\": HTMLElement;\n  \"html\": HTMLHtmlElement;\n  \"iframe\": HTMLIFrameElement;\n  \"img\": HTMLImageElement;\n  \"input\": HTMLInputElement;\n  \"label\": HTMLLabelElement;\n  \"link\": HTMLLinkElement;\n  \"main\": HTMLElement;\n  \"nav\": HTMLElement;\n  \"p\": HTMLParagraphElement;\n  \"picture\": HTMLPictureElement;\n  \"section\": HTMLElement;\n  \"select\": HTMLSelectElement;\n  \"span\": HTMLSpanElement;\n  \"strong\": HTMLElement;\n  \"table\": HTMLTableElement;\n  \"tbody\": HTMLTableSectionElement;\n  \"textarea\": HTMLTextAreaElement;\n  \"tfoot\": HTMLTableSectionElement;\n  \"thead\": HTMLTableSectionElement;\n  \"title\": HTMLTitleElement;\n  \"tr\": HTMLTableRowElement;\n  \"ul\": HTMLUListElement;\n  \"li\": HTMLLIElement;\n  \"video\": HTMLVideoElement;\n}\n```\n\n## 4.2 Event Handler Function Types\n\nReact는 이벤트 핸들러 함수 유형을 제공하여 이벤트 핸들러의 타입을 지정할 수 있습니다. 이러한 유형은 요소 유형을 매개변수로 사용할 수 있는 제네릭입니다.\n\n4.2.1 onChange 이벤트\n\n\n\n\n이벤트 유형을 직접 사용하는 것 외에도 React의 이벤트 핸들러 유형을 사용할 수 있습니다. 이전에 언급한 input의 change 이벤트에 대해:\n\n```js\nconst handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n  setValue(event.target.value);\n};\n```\n\nReact.ChangeEventHandler 유형을 사용하여 다시 작성할 수 있습니다:\n\n```js\nconst handleChange: React.ChangeEventHandler<HTMLInputElement> = (event) => {\n  setValue(event.target.value);\n};\n```\n\n\n\n이벤트 객체는 자동으로 `React.ChangeEvent<HTMLInputElement>` 유형으로 추론됩니다.\n\n4.2.2 일반 이벤트 핸들러 함수 유형\n\n이벤트의 유형에 따라 React는 사용할 수 있는 다양한 이벤트 핸들러 함수 유형을 제공합니다:\n\n- React.MouseEventHandler: 클릭 또는 마우스 이동과 같은 마우스 이벤트에 대해.\n- React.ChangeEventHandler: 값이 변경될 때 주로 폼 요소 내의 변경 이벤트에 대해.\n- React.KeyboardEventHandler: 키 누름을 캡처하는 키보드 이벤트에 대해.\n- React.DragEventHandler: 드래그 앤드 드롭 상호작용에 대해.\n- React.FocusEventHandler: onFocus 및 onBlur와 같은 포커스 관련 이벤트에 대해.\n- React.FormEventHandler: 모든 관련 폼 상호작용을 아우르는 폼 이벤트에 대해.\n- React.WheelEventHandler: 스크롤링과 같은 마우스 휠 이벤트에 대해.\n- React.TouchEventHandler: 터치 기능 장치에서 터치 이벤트에 대해.\n- React.ClipboardEventHandler: 복사 및 붙여넣기와 같은 클립보드 이벤트에 대해.\n- React.AnimationEventHandler: CSS 애니메이션 이벤트에 대해.\n- React.TransitionEventHandler: CSS 전환 이벤트에 대해.\n\n\n\n위의 특정 함수 유형을 사용함으로써 이벤트 핸들러가 처리하는 이벤트 유형에 따라 올바르게 입력된 것을 보장하여 타입 안전성을 높이고 이벤트 처리 로직에서 잠재적인 버그를 방지할 수 있습니다.\n\n# 5. 유틸리티 타입\n\nTypeScript는 타입을 쉽게 조작할 수 있도록 도와주는 여러 유틸리티 타입을 제공하며, 수많은 타입을 수동으로 정의할 필요 없이 코드를 유연하고 재사용 가능하게 만들어줍니다.\n\n다음은 일반적으로 사용되는 유틸리티 타입에 대한 간단한 개요입니다:\n\n\n\n- Partial`T`: 이 유틸리티 타입은 타입 T를 가져와서 그 모든 속성을 옵션으로 만듭니다. 원본 타입의 모든 속성을 포함하지 않는 객체를 만들고 싶을 때 유용합니다.\n- Required`T`: Partial의 반대로, 이 유틸리티 타입은 타입 T를 가져와서 그 모든 속성을 필수로 만듭니다.\n- Readonly`T`: 이 유틸리티 타입은 타입 T를 가져와서 그 모든 속성을 읽기 전용으로 만듭니다. 즉, 값이 변경될 수 없습니다.\n- Record`K, T`: 이 유틸리티 타입은 타입 T의 일련의 속성 K를 가진 타입을 생성합니다. 고정된 키 집합으로 객체 타입을 만드는 데 유용합니다.\n- Pick`T, K`: 이 유틸리티 타입은 타입 T에서 속성 K 집합을 선택하여 타입을 생성합니다.\n- Omit`T, K`: 이 유틸리티 타입은 타입 T에서 속성 K 집합을 제외하여 타입을 생성합니다.\n- ReturnType`T`: 이 유틸리티 타입은 함수 타입을 가져와서 해당 반환 타입을 생성합니다.\n- InstanceType`T`: 이 유틸리티 타입은 생성자 함수 타입을 가져와서 해당 생성자에 의해 만들어진 인스턴스의 타입을 생성합니다.\n\n더 자세한 정보를 원하시면 이전의 기사를 참고해주세요:\n\n# 결론\n\n요약하면, TypeScript는 React 개발 경험을 향상시키는 강력한 기능 세트를 제공합니다. 엄격한 타입을 사용하여 컴포넌트의 속성과 상태를 정의하고 이벤트를 처리하며 유틸리티 제너릭을 활용하면 TypeScript는 코드 신뢰성과 유지 관리성을 보장합니다. 이 개념을 숙지하면 개발자는 더 예측 가능하고 오류에 강한 응용 프로그램을 만들 수 있습니다. TypeScript의 다양한 타입 및 유틸리티를 탐험하여 버그를 줄이고 팀원 간 협업을 개선할 수 있습니다. 즐거운 코딩 하세요!\n\n\n\n# 친절하게 말해보자 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 격려하고 팔로우하세요 ️👏️️\n- 팔로우해요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringReactTypeScriptAComprehensiveGuideforDevelopers_0.png","tag":["Tech"],"readingTime":15},{"title":"useEffect vs useLayoutEffect를 쉽게 이해하기","description":"","date":"2024-05-14 11:53","slug":"2024-05-14-useEffectvsuseLayoutEffectinplainlanguage","content":"\n\nuseEffect vs useLayoutEffect에 대한 차이점과 유사점을 발견하고, 언제 각각을 사용해야 하는지 배워보세요.\n\n![이미지](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_0.png)\n\n본 글에서는 useEffect와 useLayoutEffect의 기능, 차이점, 그리고 각각을 언제 사용해야 하는지 다룰 것입니다.\n\n시작하기 전, 간단하고 빠른 답변을 찾는 분들을 위해:\n\n\n\n이 두 가지 리액트 훅은 비슷한 기능을 하며 동일한 방식으로 작동합니다.\n\n차이점은 useLayoutEffect가 화면의 변경 사항을 사용자가 볼 수 있는 렌더링 이전에 호출되는 반면, useEffect는 사용자가 화면의 변경 사항을 볼 수 있는 렌더링 이후에 호출된다는 것입니다.\n\n나중에 이것이 무슨 의미인지 자세히 살펴보겠습니다.\n\n지금은 useLayoutEffect 예제와 useEffect 예제를 간단히 살펴보며 시작해보겠습니다.\n\n\n\n![이미지](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_1.png)\n\n# useLayoutEffect와 useEffect의 유사점은 무엇인가요?\n\nReact 훅인 useLayoutEffect와 useEffect는 실제로 사용법과 역할 측면에서 완전히 동일합니다. 두 훅의 서명(signature)은 동일합니다.\n\n그러므로 질문에 대한 대답은 매우 유사합니다. 두 훅을 구분하는 핵심적인 차이점이 단 하나뿐이라는 것입니다.\n\n\n\n이러한 훅은 React 컴포넌트에서 작업을 수행할 수 있게 해줍니다. 이 작업들은 조건부로 실행되어 매번 렌더링할 때마다 실행하는 것을 피해 비용이 많이든다.\n\n이제 useEffect에 대해 구체적으로 이야기해 보겠습니다. 이것은 React 내에서 사용되는 핵심 훅 중 하나로, useState와 함께 React에서 사용하는 중요한 요소입니다.\n\nuseEffect 훅은 API 호출, 상태 설정, 타이머 사용, 구독, 변이 등과 같은 다양한 작업을 수행하는 데 사용됩니다.\n\n다시 말해, 첫 번째 렌더링 시 또는 프롭이 변경될 때와 같이 가끔 실행하고 싶은 코드가 있다면, useEffect를 사용하여 실행할 수 있습니다.\n\n\n\nuseEffect를 사용하는 예제입니다:\n\n![useEffect Example](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_2.png)\n\n보시다시피 useEffect 후크가 있고, 이를 두 가지로 제공하고 있습니다. 콜백 함수와 의존성 배열입니다.\n\n콜백 함수에는 실행하려는 모든 코드와 해당 코드가 실행되어야 하는 조건이 포함될 것입니다 (필요한 경우).\n\n\n\n의존성 배열은 useEffect가 호출될 때 콜백을 조건부로 실행할 수 있는 변수 배열입니다.\n\n이 훅이 호출되면 리액트는 의존성 배열의 각 항목을 이전 버전과 비교합니다.\n\n만약 두 항목이 참조적 동일성(비교했을 때 동일함)을 가지고 있다면 콜백이 호출되지 않습니다. 그러나 일치하지 않는다면 콜백이 호출됩니다.\n\n여기 참조적 동일성의 빠른 예시입니다:\n\n\n\n![image](/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_3.png)\n\n# useLayoutEffect vs useEffect의 차이점은 무엇인가요?\n\n이제 이 두 훅 간의 차이점에 대해 이야기해보겠습니다.\n\n이 게시물의 시작 부분에서 useEffect가 페이지와 상호 작용할 수 있는 시점에 실행되고, useLayoutEffect는 페이지와 상호 작용하기 전에 실행된다고 말했습니다. 그것에 대해 조금 더 자세히 살펴보고 코드에 대한 실제로 무슨 의미인지 이해해 봅시다.\n\n\n\n## 1. 실행 순서\n\nuseLayoutEffect은 화면을 그리기 위해 DOM을 기다리지 않고 즉시 실행됩니다. 이것은 실행 순서에 영향을 미칩니다.\n\nuseEffect 훅 안에서,\n\n```js\nuseEffect(() => {\nconsole.log(\"log 1\")\n}, [])\nuseEffect(() => {\nconsole.log(\"log 2\")\n}, [])\n```\n\n\n\n위 코드는 다음과 같이 출력됩니다:\n\n```js\nlog 1\nlog 2\n```\n\n이것은 useEffect와 함께 작업할 때 예상되는 동작입니다. 지정된 순서대로 실행됩니다.\n\n이제 두 번째 훅을 useLayoutEffect로 바꿔봅시다:\n\n\n\n```js\nuseEffect(() => {\nconsole.log(\"log 1\")\n}, [])\nuseLayoutEffect(() => {\nconsole.log(\"log 2\")\n}, [])\n```\n\n위의 출력결과,\n\n```js\nlog 2\nlog 1\n```\n\n예상대로, useLayoutEffect는 DOM 변이와 관계없이 실행되므로 useEffect 훅보다 더 빠르게 실행됩니다.\n\n\n\n## 2. 시각적 불일치\n\n복잡한 사용자 상호작용에 애니메이션이 포함된 경우 ref를 다룰 때 useEffect 대신 useLayoutEffect를 사용하는 것이 좋을 수 있습니다.\n\n```js\nReact.useLayoutEffect(() => {\n  console.log(ref.current)\n})\n```\n\n위의 예시에서 useLayoutEffect는 기다렸다가 값을 업데이트한 후 다른 코드 조각으로 넘어갑니다. useEffect 훅에서 발생하는 애니메이션 깜빡임을 개선할 수 있을 수도 있습니다.\n\n\n\n이것은 비싼 후크 실행과 부드러운 애니메이션 사이의 타협점입니다. 그러나 React는 작은 사용 사례에 대해 최적화되어 충분히 빠르기 때문에 두 가지 사이에 신경 쓸 필요가 없을 겁니다.\n\n## 3. useLayoutEffect 및 SSR\n\n악명 높은 useLayoutEffect 경고가 있습니다.\n\n“경고: 서버에서 useLayoutEffect는 아무것도 수행하지 않습니다. 왜냐하면 해당 효과가 서버 렌더러의 출력 형식으로 인코딩될 수 없기 때문입니다…\"\n\n\n\nSSR을 다룰 때는 JavaScript가 제대로 로드될 때까지 useEffect 및 useLayoutEffect가 작동하지 않습니다. 따라서 콘솔에서 위와 같은 경고 메시지를 볼 수 있습니다. useEffect는 컴포넌트의 렌더 주기와 상관이 없기 때문에 해당 경고가 발생하지 않는 것이며, useLayoutEffect는 사용자가 컴포넌트를 처음으로 렌더링할 때 사용자가 보게 될 사항을 고려하고 중요시합니다.\n\nReact 커뮤니티는 이 문제를 해결하기 위해 두 가지 방법을 제안합니다.\n\n1. 물론 가능하다면 useEffect 훅으로 변환해 보는 것이 첫 번째 시도입니다.\n\n2. useEffect에서 깜빡거림 문제가 있는 경우나 개발자가 useLayoutEffect를 필요로 하는 경우, 다른 방법으로는 JavaScript가 제대로 로드될 때까지 해당 훅을 사용하는 컴포넌트를 지연시키는 것이 될 수 있습니다. 다시 말해, React 컴포넌트를 게으르게 로드하는 방법입니다.\n\n\n\n# useLayoutEffect와 useEffect를 사용할 때에 대한 요약\n\nuseEffect를 사용하여 시작하는 것이 좋습니다. 대부분의 경우 그냥 그대로 두어도 될 것입니다.\n\n만약 useEffect를 사용할 때 DOM 변이가 있고 문제가 발생한다면, 예를 들어 UI가 한 가지에서 빠르게 다른 것으로 변경되는 상황이라면, useEffect가 시각적 변경 후에 로드되기 때문에 useLayoutEffect로 전환하는 것을 고려해야 합니다.\n\n마지막으로 useLayoutEffect와 useEffect의 차이를 기억하기 위한 도움이 되는 글:\n\n\n\n- useLayoutEffect: DOM 변경 후, 시각적 변화 전 그리고 브라우저가 그리기 전에 발생합니다. 이는 사용자가 코드를 기다려야 한다는 것을 의미합니다.\n- useEffect: DOM 변경 후, 시각적 변화 후, 그리고 브라우저가 이미 그린 후에 발생합니다. 이는 사용자가 코드를 기다릴 필요가 없다는 것을 의미합니다.\n\n만일 이 이야기를 즐겼다면 👏 버튼을 클릭하고 공유해 주세요. 다른 사람들도 발견할 수 있도록! 아래에 댓글을 남겨주시면 감사하겠습니다.\n\nGroww 엔지니어링팀은 기술 습작, 최신 기술 및 일반적인 프로그래밍 문제를 해결하는 더 나은 방법을 게시합니다. 최신 업데이트를 받으려면 여기에서 구독해주세요.\n\n저희는 채용 중입니다. 채용 공고를 확인하려면 여기를 클릭해주세요.","ogImage":{"url":"/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_0.png"},"coverImage":"/assets/img/2024-05-14-useEffectvsuseLayoutEffectinplainlanguage_0.png","tag":["Tech"],"readingTime":5},{"title":"React Vite Typescript에서 SVG 사용하는 방법","description":"","date":"2024-05-14 11:52","slug":"2024-05-14-HowtoUseSVGinReactViteTypescript","content":"\n\nSVG(Scalable Vector Graphics)은 확장 가능성과 유연성으로 현대 웹 개발에서 중요한 역할을 하고 있어요. React와 결합하면 동적이고 시각적으로 멋진 사용자 인터페이스를 만들 수 있는 무궁무진한 가능성이 열립니다. 이 안내서에서는 SVG를 React 프로젝트에 효과적으로 통합하는 방법을 살펴볼 거에요.\n\n구현 세부 사항에 들어가기 전에, React 내에서 SVG 기초를 이해하는 게 중요해요. React에서 SVG 요소는 일반 HTML 요소와 마찬가지로 JSX 내에 매끄럽게 통합될 수 있어요. 이 통합은 React의 상태와 프롭 메커니즘을 활용하여 SVG 요소를 동적으로 조작하는 데 개발자들에게 힘을 실어줘요. 결과적으로 SVG 그래픽은 애플리케이션 상태 변경에 반응하여 매우 유연하며 매력적인 사용자 인터페이스를 만드는 데 도움이 돼요.\n\n```js\nnpm install vite-plugin-svgr\n```\n\n- vite-plugin-svgr: 이것은 설치되는 npm 패키지의 이름이에요. \"vite-plugin-svgr\"은 Vite와 함께 작동하도록 설계된 플러그인이에요. Vite는 빠른 개발 서버, 최적화된 프로덕션 빌드 등 다양한 기능을 제공하는 차세대 프런트엔드 도구에요. 이 특정 플러그인을 사용하면 Vite로 구동되는 React 프로젝트에서 SVG 파일을 직접 구성 요소로 사용할 수 있어요. SVGR 라이브러리를 활용하는 거죠.\n\n\n\nTypeScript로 작업하는 Vite 프로젝트에서는 컴포넌트, 모듈 또는 기타 TypeScript 파일에 대해 TypeScript 선언 파일(.d.ts 파일)을 생성해야 할 수 있습니다. 선언 파일은 TypeScript 코드에 대한 유형 정보를 제공하고 더 나은 IDE 지원, 유형 확인 및 코드 문서화를 가능하게 합니다.\n\n```js\nnpm install vite-plugin-dts\n```\n\n```js\nimport { defineConfig } from \"vite\";\nimport svgr from \"vite-plugin-svgr\";\nimport dts from \"vite-plugin-dts\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  build: {\n    outDir: \"build\",\n  },\n  plugins: [ svgr(), dts(), react()],\n});\n```\nvite.config.ts 파일을 해당 내용으로 변경하세요.\n\n\n\n루트 디렉토리에 svg.d.ts라는 파일을 만들어주세요.\n\n```js\ndeclare module \"*.svg?react\" {\n  import { FunctionComponent, SVGAttributes } from \"react\";\n  const content: FunctionComponent<SVGAttributes<SVGElement>>;\n  export default content;\n}\n```\n\n위의 코드를 svg.d.ts 파일에 붙여넣기해주세요.\n\n```js\n\"include\": [\"src\",\"src/vite-env.d.ts\"],\n```\n\n\n\n이제 tsconfig.json에 위 src, src/vite-env.d.ts를 추가하세요.\n\n그런 다음 Svg를 Component로 가져와서 React Component로 사용할 수 있습니다.\n\n```js\nimport CollectHoverIcon from \"../../assets/Collections.svg?react\";\n```\n\n이제 이 Svg를 React Component로 가져올 수 있습니다. 가져오는 디렉토리 끝에 ?react을 추가하는 것을 잊지 마세요.\n\n\n\n파일 경로에 \"?react\"가 추가되어 있는 경우, 보통 이는 SVG 파일이 React 사용을 위해 특정 최적화나 변환을 적용하여 가져오고 있음을 나타냅니다. 많은 경우, 이는 SVG 파일이 정적 자산이 아닌 React 구성 요소로 가져올 수 있다는 의미일 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-HowtoUseSVGinReactViteTypescript_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoUseSVGinReactViteTypescript_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 네이티브 또는 엑스포 앱에서의 I18n","description":"","date":"2024-05-14 11:51","slug":"2024-05-14-I18ninYourReactNativeorExpoApps","content":"\n\n<img src=\"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png\" />\n\n현대 기술 생태계에서 지리적 경계를 넘어 전 세계 관객을 대상으로 서비스를 제공하는 것이 예외가 아닌 표준이 되었습니다.\n\ni18n-js로 시작하기\n\n# 설치\n\n\n\n```js\n# npm\nnpm install i18n-js expo-localization\n\n# yarn\nyarn add i18n-js expo-localization\n\n# pnpm\npnpm add i18n-js expo-localization\n\n# bun\nbun add i18n-js expo-localization\n```\n\n## 그런 다음 루트 또는 src 폴더에 i18n.ts 파일을 생성하십시오.\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n  en: {\n    hello: \"hello %{name}!\"\n  },\n  zh: {\n    hello: \"안녕하세요 %{name}!\"\n  },\n});\n\ni18n.defaultLocale = deviceLanguage;\n\ni18n.locale = deviceLanguage;\n```\n\n## 그러면 locales 폴더에 다국어 JSON 파일을 생성할 수 있습니다.\n\n\n\n```js\n// (root)/src/locales/en.json\n{\n hello: \"안녕 %{name}!\"\n}\n```\n\n```js\n// (root)/src/locales/zh.json\n{\n hello: \"안녕하세요 %{name}!\"\n}\n```\n\ni18n.ts 변경사항\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\n+import en from '../locales/en.json';\n+import zh from '../locales/zh.json';\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n+  en,\n+  zh,\n});\n\ni18n.defaultLocale = deviceLanguage;\n\ni18n.locale = deviceLanguage;\n```\n\n\n\n이제 컴포넌트에서 사용할 수 있어요. 여기 컴포넌트에서 translate 함수를 사용하는 예시가 있어요.\n\n```js\n// example.tsx\nimport { i18n } from '../lib/i18m';\n\nfunction Example() {\n return <div>{i18n.t(\"hello\", {name: \"Toy\"})}</div>\n}\n```\n\n하지만 로컬을 변경하고 싶어요, 어떻게 해야 할까요?\n\n걱정 마세요, i18n.ts 파일에 changeLanguage 함수를 정의할 수 있어요.\n\n\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\nimport en from '../locales/en.json';\nimport zh from '../locales/zh.json';\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n  en,\n  zh,\n});\n\ni18n.defaultLocale = deviceLanguage;\ni18n.locale = deviceLanguage;\n\n+ export function changeLanguage(lang: string) {\n+  i18n.locale = lang;\n+ }\n```\n\n그런 다음 이 함수를 언어 변경 컴포넌트에 사용할 수 있습니다.\n\n```js\n// example.tsx\nimport { i18n, changeLanguage } from '../lib/i18n';\nimport { View, Button } from 'react-native';\n\nfunction Example() {\n return (\n  <View>\n   <View>{i18n.t(\"hello\", {name: \"Toy\"})}</View>\n   <Button onPress={() => changeLanguage('zh')} title=\"언어 변경\"/>\n  </View>\n );\n}\n```\n\n너무 간단해 보이지 않나요? 이 패키지는 매우 강력하고 실용적입니다.\n\n\n\n\n이 라이브러리는 Rails-i18n에서 제공하는 기본 번역을 사용할 수 있습니다.\n\n마지막으로, i18n-js에서 더 많은 정보를 읽으려면 공식 문서로 이동할 수 있습니다.\n\nReact Native 및 Expo 앱에서 i18n을 채택하면 미래를 대비한 글로벌 확장의 길이 열립니다. 국제화는 일회성 작업이 아닌 앱이 전 세계에서 관련성을 유지하고 접근성이 있으며 사용자 친화적인 지속적인 의무라는 것을 명심해야 합니다.\n\n경험 많은 개발자이든 처음 국제화를 시작하는 중이든, 전 세계적인 모바일 앱을 개발하는 길은 당신 손안에 있으며, i18n-js는 이 추구에서 믿을 수 있는 동료입니다. React Native 및 Expo 앱의 최대 잠재력을 발휘하여 세계의 언어로 강화시키는 시간입니다.\n\n\n\n이 기사를 읽어 주셔서 감사합니다. 최대한 많이 박수/추천 해 주시고 친구들과 공유도 꼭 해주세요. 제게는 매우 중요한 일이죠.","ogImage":{"url":"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png"},"coverImage":"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png","tag":["Tech"],"readingTime":3},{"title":"React에서 네비게이션 이벤트를 모의하고 테스트하는 방법 Vitest","description":"","date":"2024-05-14 11:50","slug":"2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest","content":"\n\n리액트 페이지 탐색 이벤트를 테스트하고 싶어서 노력 중이었는데, 가져온 모듈 함수를 MOCK 하는 것이 필요해 전혀 익숙하지 않았어요. \n\n마침내 어떻게 해결했는지 공유하고 싶어요. 물론, 이 예제는 정교하거나 높은 자격 요건을 갖춘 것은 아니라서 여러분의 생각과 추천 대안을 공유해주시면 정말 감사하겠어요. 이 글이 몇몇 독자들에게 도움이 되었으면 좋겠어요.\n\n** 이 문서는 테스트 환경 설정에 대한 내용을 다루지 않고 직접 내용으로 들어갑니다.\n\n## 무엇을 테스트할 것인가\n\n\n\n리액트 애플리케이션이 두 가지 접근 가능한 경로, /와 /todos를 가지고 있습니다. StartPage.test.tsx 파일은 홈 경로에 대한 유닛 테스트 파일이며, \"todos\" 텍스트를 가진 버튼이 클릭되었을 때 애플리케이션이 사용자를 /todos 페이지로 이동시키는지 테스트하고 싶습니다.\n\n## 문제 발생\n\n하지만 테스트 라이브러리 관점에서 이야기를 해보겠습니다. \"사용자를 다른 페이지로 이동시킨다\"는 것의 의미는 무엇인가요?\n\n```js\nimport useNavigation from \"@hooks/useNavigation\";\n\nexport default function StartPage() {\n  const { push } = useNavigation();\n  return (\n    <div>\n      <h1>start</h1>\n      <button\n        onClick={() => {\n          push(\"/todos\");\n        }\n      >\n        todos\n      </button>\n    </div>\n  );\n}\n```\n\n\n\n사용자가 \"todos\" 버튼을 클릭하면, onclick 핸들러가 실행되고, 그런 다음 push 함수가 실행됩니다. push 함수는 useNavigation 훅 호출에서 반환된 함수 중 하나입니다. 문제는 테스트 코드가 push 또는 useNavigation이 어떻게 구성되어 있는지를 모르기 때문에, 테스트 함수에 이 함수들이 어떻게 되어야 하는지 알려주어야 합니다. 이 과정을 함수 모의(mocking functions)라고 합니다.\n\n## `MemoryRouter` 내부의 단위\n\n테스트 함수를 작성하기 전에, 테스트된 컴포넌트가 react-router-dom의 Router 내에 있어야 한다는 점을 명확히해야 합니다. 그렇지 않으면 여러 경로가 없을 수 있고, 컴포넌트 함수에서 useNavigation 훅을 사용할 수 없습니다. 이 문제는 단위 컴포넌트를 react-router-dom의 `MemoryRouter` 컴포넌트로 감싸면 쉽게 처리할 수 있습니다. Router에 initialEntries prop을 제공하여 애플리케이션의 위치를 지정할 수 있습니다.\n\n```js\n// ...\n\nbeforeEach(() => {\n   render(<StartPage />, {\n    wrapper: ({children}) => (\n      <MemoryRouter initialEntries={[\"/\"]}>\n        {children}\n      </MemoryRouter>\n    ),\n  });\n});\n\n// ...\n```\n\n\n\n## 목 역할 하는 방법\n\n테스트 작업 환경인 jest와 비슷한 기능을 가진 vitest는 jest testing 환경의 vi 속성을 제공하여 변수와 함수를 mock할 수 있습니다. vi.fn 메소드는 \"함수를 스파이로 생성\"하고, vi.mock 메소드는 첫 번째 인수로 지정된 경로에서 import된 모든 모듈을 대체합니다.\n\n```js\nimport { vi } from \"vitest\";\n\nconst mockPush = vi.fn();\n\nvi.mock(\"@hooks/useNavigation\", () => {\n  return {\n    // useNavigation\n    default: () => ({\n      push: mockPush,\n    }),\n  };\n});\n```\n\n위의 예시에서 vi.mock은 \"@hooks/useNavigation\" 경로에서 import된 모듈의 형태를 정의합니다. 이 모듈은 \"push\"라는 함수를 반환하는 기본 내보내기를 가지고 있습니다. 이제 모듈의 구조가 알려졌으며, 테스트 함수 내에서 스파이 변수인 mockPush를 사용하여 push 메소드에 접근할 수 있습니다. 이 모킹된 함수가 호출될 때 어떤 인수와 함께 호출되었는지 mockPush.mock.calls 또는 mockPush.mock.lastCall을 사용하여 확인할 수 있습니다. 이는 인수 목록을 제공합니다.\n\n\n\n```js\ntest(\"버튼 클릭 시 /todos 페이지로 이동해야 함\", async () => {\n  const button = (await screen.findAllByText(\"todos\"))[0];\n  expect(button).toBeDefined();\n  await userEvent.click(button);\n\n  console.log(\"호출\", mockPush.mock.calls);\n  // calls [ [ '/todos' ] ]\n  console.log(\"마지막 호출\", mockPush.mock.lastCall);\n  // last call [ '/todos' ]\n});\n```\n\n여기서 만약 lastCall의 첫 번째 항목이 \"/todos\"이면, \"todos\" 버튼 클릭 이벤트의 예상 결과로써 push 메소드가 \"/todos\" 인자와 함께 호출된 것이라고 말할 수 있습니다.\n\n```js\ntest(\"버튼 클릭 시 /todos 페이지로 이동해야 함\", async () => {\n  const button = (await screen.findAllByText(\"todos\"))[0];\n  expect(button).toBeDefined();\n  await userEvent.click(button);\n\n  expect(mockPush.mock.lastCall[0]).toEqual(\"/todos\");\n});\n```\n\n마지막으로, 각 테스트 후에 mock 기록을 제거하기 위해 vi.clearAllMocks 메소드를 호출하는 것이 좋습니다.```\n\n\n\n```js\nconst mockPush = vi.fn();\n\nvi.mock(\"@hooks/useNavigation\", () => {\n  return {\n    // useNavigation\n    default: () => ({\n      push: mockPush,\n    }),\n  };\n});\n\ndescribe(\"start page test\", () => {\n  beforeEach(() => {\n    render(<StartPage />, {\n      wrapper: ({children}) => (\n        <MemoryRouter initialEntries={[\"/\"]}>\n          {children}\n        </MemoryRouter>\n      ),\n    });\n  });\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  test(\"should navigate to /todos page on button click\", async () => {\n    const button = (await screen.findAllByText(\"todos\"))[0];\n    expect(button).toBeDefined();\n    await userEvent.click(button);\n\n    expect(mockPush.mock.lastCall[0]).toEqual(\"/todos\");\n  });\n});\n```","ogImage":{"url":"/assets/img/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest_0.png"},"coverImage":"/assets/img/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest_0.png","tag":["Tech"],"readingTime":4},{"title":"SSR와 CSR란 무엇인가 간단히 설명하기","description":"","date":"2024-05-14 11:49","slug":"2024-05-14-WhatisSSRandCSRAsimpleexplanation","content":"\n\n웹 개발 세계에서 자주 만나는 두 용어는 SSR (서버 측 렌더링)와 CSR (클라이언트 측 렌더링)입니다. 두 용어는 웹 애플리케이션에서 콘텐츠가 표시되고 처리되는 방식에 상당한 영향을 미칩니다. 이 글에서는 이러한 개념을 자세히 살펴보고 그 차이점과 유사점을 알아보며, 어떤 경우에 한 가지를 다른 것보다 선호해야 하는지 이해해보겠습니다.\n\n![SSR](/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png)\n\n# 서버 측 렌더링 (SSR)\n\n## SSR이란?\n\n\n\n서버 측 렌더링(SSR)은 웹 페이지가 브라우저로 전송되기 전에 서버에서 생성되는 방식입니다. 다시 말해, 서버가 페이지의 로직과 구조를 처리하고 완전히 렌더링된 페이지를 사용자의 브라우저로 보냅니다.\n\n## SSR의 장점\n\n- SEO 개선: 서버에서 렌더링된 페이지는 컨텐츠가 이미 클라이언트로 전송되는 초기 HTML에 포함되어 있기 때문에 검색 엔진 친화적입니다.\n- 초기 성능 개선: 사용자들이 페이지 렌더링이 완료된 페이지를 처음부터 받기 때문에 컨텐츠를 빠르게 볼 수 있습니다.\n\n## React를 사용한 SSR의 예시\n\n\n\nNext.js는 인기 있는 React 프레임워크로, SSR을 간단하게 구현할 수 있게 해줘요.\n\n## Step 1: Next.js 설치하기\n\n```js\nnpx create-next-app my-nextjs-app\ncd my-nextjs-app\n```\n\n## Step 2: SSR 페이지 만들기\n\n\n\nIn pages/index.js 파일:\n\n```js\n// pages/index.js\nconst HomePage = ({ data }) => {\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n};\n\nexport async function getServerSideProps() {\n  // API나 데이터베이스에서 데이터 가져오는 로직\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n\n  return {\n    props: { data },\n  };\n}\n\nexport default HomePage;\n```\n\n# 클라이언트 사이드 렌더링 (CSR)\n\n## CSR이란?\n\n\n\n클라이언트 측 렌더링(CSR)은 브라우저가 빈 페이지를로드하고 JavaScript를 사용하여 해당 페이지를 콘텐츠로 채우는 것을 의미합니다. 이 경우 브라우저는 사용자 인터페이스를 만들고 제공하는 데 더 활발한 역할을 합니다.\n\n## CSR의 장점\n\n- 향상된 상호 작용: CSR 애플리케이션은 전체 페이지를 다시로드할 필요없이 사용자 인터페이스를 업데이트할 수 있어 더 많은 상호 작용성을 제공합니다.\n- 낮은 초기 로드: 초기 페이지로드가 더 빠를 수 있으며 브라우저로는 애플리케이션의 뼈대만 전송됩니다.\n\n## React를 활용한 CSR의 예시\n\n\n\nCreate React App를 사용하여 간단한 클라이언트 측 렌더링 예제를 만들어보겠습니다.\n\n## 단계 1: React 앱 만들기\n\n```js\nnpx create-react-app my-react-app\ncd my-react-app\n```\n\n## 단계 2: 클라이언트 측 렌더링 구현하기\n\n\n\n[src/App.js 파일]\n\n```js\n// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () => {\n  const [data, setData] = useState({});\n\n  useEffect(() => {\n    // 앱이 로드된 후 데이터를 가져오기 위한 로직\n    fetch('https://api.example.com/data')\n      .then((response) => response.json())\n      .then((data) => setData(data));\n  }, []);\n\n  return (\n    <div>\n      <h1>{data.title}</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n# 각 접근 방식의 비교 및 언제 사용해야 하는지\n\n두 가지 방법에는 각각 장단점이 있습니다. SSR과 CSR 중 어떤 것을 선택할지는 애플리케이션의 특정 요구 사항에 따라 다릅니다. 일반적인 지침은 다음과 같습니다:\n\n\n\nSSR을 사용해보세요:\n\n- SEO를 개선하고 싶을 때.\n- 초기 성능을 향상시키고 싶을 때.\n\nCSR을 사용해보세요:\n\n- 매우 상호 작용형 애플리케이션을 갖고 있을 때.\n- 더 빠른 초기 로드를 원할 때.\n\n\n\n# 요약\n\n요약하자면, SSR과 CSR은 웹 페이지를 렌더링하는 데 사용되는 서로 다른 방법론입니다. SSR은 SEO 및 초기 성능 향상에 도움이 되지만, CSR은 보다 인터랙티브한 경험을 제공합니다. 둘 중 어떤 것을 선택할지는 애플리케이션의 목표와 구체적인 요구 사항에 따라 다릅니다.\n\n애플리케이션을 디자인할 때 사용자 요구 사항, 성능 요구 사항, 그리고 선택 사항이 검색 엔진에서 콘텐츠의 가시성에 어떻게 영향을 미칠지를 고려해야 합니다. 많은 경우, SSR과 CSR을 결합한 \"수분화\" 기술을 사용하는 것이 최상의 선택일 수 있습니다. 프로젝트의 고유한 특성에 따라 실험하고 조정해보세요.\n\n이 문서가 도움이 되었다면 망설이지 말고 팔로우, 구독, 박수를 부탁드립니다. 감사합니다!","ogImage":{"url":"/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png"},"coverImage":"/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png","tag":["Tech"],"readingTime":3}],"page":"60","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}