{"pageProps":{"posts":[{"title":"바닐라 JS로 만들어진 웹캠 인피니티 미러","description":"","date":"2024-05-27 19:14","slug":"2024-05-27-MirrorMirrorAWebcamInfinityMirrorwithVanillaJS","content":"\n\n<img src=\"/assets/img/2024-05-27-MirrorMirrorAWebcamInfinityMirrorwithVanillaJS_0.png\" />\n\n# 소개\n\n프로그래머로서, 종종 기술 스택 레이어, 복잡한 구조 및 다양한 통합이 포함된 대규모 프로젝트에 참여합니다. 때로는 기본으로 돌아가 간단한 것을 만드는 것도 재미있죠.\n\n이 프로젝트에서는 HTML 및 JavaScript만 사용하여 브라우저 기반 웹 애플리케이션을 만들어 실시간 인피니티 미러를 생성하고 이미지 뒤집기/회전/저장 버튼을 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n지금까지 데스크톱, iOS 및 안드로이드 브라우저에서 작동하는 것으로 확인했습니다.\n\n## 컨셉\n\n아이디어는 간단합니다: 웹캠 피드를 사용하여 브라우저에서 직접 시각적으로 매력적인 효과를 만드는 것입니다. 프로젝트는 비디오 피드를 수평으로 뒤집는, 회전하는, \"무한 거울\" 효과를 적용하는 및 현재 뷰를 이미지 파일로 저장하는 기능을 구현하는 것을 목표로 했습니다. 이는 HTML5 비디오 요소와 캔버스 API의 응용을 현실세계 시나리오에서 탐색하는 간단한 방법을 제공합니다.\n\n## 도구 및 기술\n\n<div class=\"content-ad\"></div>\n\n- HTML5: 비디오 표시 및 제어 요소를 구성하는 데 사용됩니다.\n- CSS3: 웹 페이지를 스타일링하여 요소가 시각적으로 매력적이고 기능적으로 배치되도록 합니다.\n- JavaScript: 상호작용의 핵심으로 웹캠 액세스를 처리하고 실시간으로 비디오 피드를 조작합니다.\n- Bootstrap: 빠르고 반응형 버튼 스타일링을 위해 Bootstrap을 조금 사용합니다.\n- WebRTC(웹 실시간 통신): 이 기술은 사용자 카메라에서 비디오를 직접 캡처하고 스트리밍하는 수단을 제공합니다.\n\n## 레이아웃 설정\n\nHTML 페이지는 비디오 요소와 캔버스를 호스팅하도록 설정되었습니다. 비디오 요소는 웹캠 피드를 캡처하고, 캔버스는 다양한 그래픽 변환을 적용하는 데 사용됩니다.\n\n```js\n<div class=\"title\">Mirror Mirror</div>\n<div class=\"btn-group\" role=\"group\">\n    <button id=\"btnToggle\" class=\"btn btn-success\">켜기</button>\n    <button id=\"btnEffect\" class=\"btn btn-warning\">무한 효과</button>\n    <button id=\"btnEdge\" class=\"btn btn-dark\">가장자리 감지</button>\n    <button id=\"btnFlip\" class=\"btn btn-primary\">수평 뒤집기</button>\n    <button id=\"btnRotate\" class=\"btn btn-secondary\">회전</button>\n    <button id=\"btnSave\" class=\"btn btn-info\">사진 저장</button>\n</div>\n</div>\n<div id=\"canvas-container\">\n    <canvas id=\"canvas\"></canvas>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n## 자바스크립트에서 제어 버튼 설정하기\n\n사용자 클릭을 감지하고 기능을 선택하려면 각 버튼에 대한 클릭 핸들러를 추가합니다. 이 버튼들은 비디오 피드를 켜고 끄거나, 무한 거울 또는 가장자리 감지와 같은 특수 효과를 적용하고, 이를 모바일 기기나 태블릿에서 사용하는 경우 뒤집거나 회전할 수 있습니다.\n\n만약 비디오 피드가 일시 중지된 경우 이미지는 마지막 이미지를 유지합니다. 언제든지 save 버튼을 사용하여 장치의 로컬 파일 시스템에 마지막 사진을 저장할 수 있습니다.\n\n```js\n document.addEventListener('DOMContentLoaded', function () {\n  const canvas = document.getElementById('canvas');\n  const context = canvas.getContext('2d');\n  let videoStream = null;\n  let video = document.createElement('video');\n  let flipHorizontal = false;\n  let infinityEffect = false;\n  let rotationAngle = 0;\n  let edgeDetectionEnabled = false;\n\n  const btnToggle = document.getElementById('btnToggle');\n  const btnFlip = document.getElementById('btnFlip');\n  const btnEffect = document.getElementById('btnEffect');\n  const btnRotate = document.getElementById('btnRotate');\n  const btnSave = document.getElementById('btnSave');\n\n  document.getElementById('btnEdge').addEventListener('click', function () {\n      edgeDetectionEnabled = !edgeDetectionEnabled;\n  });\n\n  btnToggle.addEventListener('click', function () {\n      if (videoStream) {\n          videoStream.getTracks().forEach(track => track.stop());\n          videoStream = null;\n          btnToggle.textContent = 'Turn On';\n          btnToggle.classList.replace('btn-danger', 'btn-success');\n      } else {\n          navigator.mediaDevices.getUserMedia({ video: true })\n              .then(stream => {\n                  videoStream = stream;\n                  video.srcObject = stream;\n                  video.play();\n                  btnToggle.textContent = 'Turn Off';\n                  btnToggle.classList.replace('btn-success', 'btn-danger');\n                  draw();\n              })\n              .catch(error => {\n                  console.error('Error accessing the camera: ', error);\n              });\n      }\n  });\n\n  btnFlip.addEventListener('click', function () {\n      flipHorizontal = !flipHorizontal;\n  });\n\n  btnEffect.addEventListener('click', function () {\n      infinityEffect = !infinityEffect;\n  });\n\n  btnRotate.addEventListener('click', function () {\n      rotationAngle = (rotationAngle + 90) % 360;\n      canvas.style.transform = `rotate(${rotationAngle}deg)`;\n  });\n\n  btnSave.addEventListener('click', function () {\n      if (canvas) {\n          const link = document.createElement('a');\n          link.download = 'infinity-mirror.png';\n          link.href = canvas.toDataURL('image/png');\n          link.click();\n      }\n  });\n```\n\n**이 상태유지 메시지가 도움이 돼셨나요?**\n\n<div class=\"content-ad\"></div>\n\n## 카메라 접근하기\n\n`navigator.mediaDevices.getUserMedia` API를 사용하여 웹캠 피드를 설정했어요. 이 API는 간단해서 미디어 입력을 사용할 수 있는 방법을 제공해요. 카메라를 사용할 권한을 요청하는 대화 상자가 나타날 거예요.\n\n```js\nnavigator.mediaDevices.getUserMedia({ video: true })\n.then(stream => {\nconst video = document.createElement('video');\nvideo.srcObject = stream;\nvideo.play();\n})\n.catch(error => {\nconsole.error('카메라에 접근하는 중 오류 발생: ', error);\n});\n```\n\n## 미러 효과를 위한 비디오 피드 조작\n\n<div class=\"content-ad\"></div>\n\n비디오 피드를 다루는 것이 더 재미있어질 때입니다. 저는 비디오를 수평으로 뒤집거나 회전하거나 무한 거울 효과를 적용하는 함수를 작성했습니다. 이 효과는 비디오 피드의 여러 배율 및 반투명 복사본을 생성하여 거울 효과를 만듭니다. scaleFactor 및 alphaFactor 변수로 거울 이미지의 인스턴스 수나 안쪽 여백을 변경할 수 있습니다. 제 데스크탑에서 실행 속도가 얼마나 빠른지 고려할 때, 나중에 업데이트에서 해당 슬라이더를 추가할 수도 있겠죠. 이에 관심이 있다면 GitHub 레포지토리에 이슈를 남겨주세요.\n\n```js\nfunction applyInfinityEffect(context, width, height) {\n    const numberOfReflections = 5;\n    let scaleFactor = 0.5;\n    let alphaFactor = 0.9;\n\n    for (let i = 0; i < numberOfReflections; i++) {\n        context.globalAlpha = Math.pow(alphaFactor, i + 1);\n        const newWidth = width * Math.pow(scaleFactor, i + 1);\n        const newHeight = height * Math.pow(scaleFactor, i + 1);\n        const dx = (width - newWidth) / 2;\n        const dy = (height - newHeight) / 2;\n\n        context.drawImage(canvas, 0, 0, width, height, dx, dy, newWidth, newHeight);\n    }\n\n    context.globalAlpha = 1.0;\n}\n```\n\n## 소벨 필터를 사용한 에지 검출\n\n이미지 처리에 익숙한 사람을 위해 비디오의 각 프레임을 가져와 \"에지\" 또는 각 객체의 경계를 탐지하는 필터를 실행할 수 있습니다. 이 작업은 각 프레임에 2D 그라디언트를 적용하는 소벨 연산자를 사용하여 수행됩니다. 우리는 이를 보여주기 위해 회색조로 변환합니다. 소벨 연산자에 대한 추가 배경 정보는 여기서 볼 수 있습니다. 코드를 수정하고 다른 이미지 처리 작업을 추가할 수도 있습니다. 추가할 수 있는 많은 고전적인 신호 처리 필터가 있지만 UI 컨트롤의 수가 상당히 늘어날 것입니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction applyEdgeDetection(context, width, height) {\n    const imageData = context.getImageData(0, 0, width, height);\n    const grayScaled = grayscale(imageData.data, width, height);\n    const edgeData = sobelFilter(grayScaled, width, height);\n    context.putImageData(new ImageData(edgeData, width, height), 0, 0);\n}\n\nfunction grayscale(data, width, height) {\n    const result = new Uint8ClampedArray(width * height * 4);\n    for (let i = 0; i < data.length; i += 4) {\n        const avg = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];\n        result[i] = avg; // red\n        result[i + 1] = avg; // green\n        result[i + 2] = avg; // blue\n        result[i + 3] = 255; // alpha\n    }\n    return result;\n}\n\n\nfunction sobelFilter(data, width, height) {\n    const kernelX = [\n        [-1, 0, 1],\n        [-2, 0, 2],\n        [-1, 0, 1]\n    ];\n    const kernelY = [\n        [-1, -2, -1],\n        [0, 0, 0],\n        [1, 2, 1]\n    ];\n\n    const sobelData = new Uint8ClampedArray(width * height * 4); // Correctly sized array\n\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            let px = (y * width + x) * 4;\n            let gx = 0;\n            let gy = 0;\n\n            for (let cy = -1; cy <= 1; cy++) {\n                for (let cx = -1; cx <= 1; cx++) {\n                    const cpx = ((y + cy) * width + (x + cx)) * 4;\n                    gx += data[cpx] * kernelX[cy + 1][cx + 1];\n                    gy += data[cpx] * kernelY[cy + 1][cx + 1];\n                }\n            }\n\n            const magnitude = Math.sqrt(gx * gx + gy * gy);\n            sobelData[px] = sobelData[px + 1] = sobelData[px + 2] = magnitude;\n            sobelData[px + 3] = 255; // alpha\n        }\n    }\n    return sobelData;\n}\n```\n\n## Canny Filter를 사용한 Edge Detection\n\nSobel은 그 연산 부하가 비교적 적은 편이기 때문에 인기 있는 선택지입니다. Canny Filter 또한 엣지 검출을 제공하지만 이미지를 그라디언트를 취하기 전에 블러처리하여 연산량이 많이 필요합니다. 이로 인해 라인 드로잉 형식의 효과를 더 많이 만들어 냅니다. Canny Filter에 대해 더 알고 싶다면 여기를 참고하세요. Canny Filter (및 해당 파생)는 콘크리트 입자나 작은 직물 패턴과 같은 '질감있는' 가장자리보다는 덜 민감합니다.\n\n코드에서 Canny 필터를 활성화하는 방법은 아래에 나와 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n function applyCannyEdgeDetection(context, width, height) {\n    const imageData = context.getImageData(0, 0, width, height);\n    const grayScaled = grayscale(imageData.data, width, height);\n    const blurred = gaussianBlur(grayScaled, width, height);\n    const edgeData = cannyFilter(blurred, width, height);\n    context.putImageData(new ImageData(edgeData, width, height), 0, 0);\n}\n\nfunction grayscale(data, width, height) {\n    const result = new Uint8ClampedArray(width * height * 4);\n    for (let i = 0; i < data.length; i += 4) {\n        const avg = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];\n        result[i] = avg; // red\n        result[i + 1] = avg; // green\n        result[i + 2] = avg; // blue\n        result[i + 3] = 255; // alpha\n    }\n    return result;\n}\n\nfunction gaussianBlur(data, width, height) {\n    const kernel = [\n        [1, 2, 1],\n        [2, 4, 2],\n        [1, 2, 1]\n    ];\n    const kernelWeight = 16;\n    const blurredData = new Uint8ClampedArray(width * height * 4);\n\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            let sum = 0;\n            let sumAlpha = 0;\n\n            for (let cy = -1; cy <= 1; cy++) {\n                for (let cx = -1; cx <= 1; cx++) {\n                    const pixel = ((y + cy) * width + (x + cx)) * 4;\n                    const weight = kernel[cy + 1][cx + 1];\n                    sum += data[pixel] * weight;\n                    sumAlpha += data[pixel + 3];\n                }\n            }\n\n            const pixelIndex = (y * width + x) * 4;\n            blurredData[pixelIndex] = sum / kernelWeight;\n            blurredData[pixelIndex + 1] = sum / kernelWeight;\n            blurredData[pixelIndex + 2] = sum / kernelWeight;\n            blurredData[pixelIndex + 3] = sumAlpha / kernelWeight;\n        }\n    }\n    return blurredData;\n}\n\nfunction cannyFilter(data, width, height) {\n    // Simplified Canny edge detection\n    const sobelData = sobelFilter(data, width, height);\n    const result = new Uint8ClampedArray(width * height * 4);\n\n    for (let i = 0; i < sobelData.length; i += 4) {\n        const magnitude = sobelData[i];\n        if (magnitude > 50) {\n            result[i] = result[i + 1] = result[i + 2] = 255; // white\n            result[i + 3] = 255; // alpha\n        } else {\n            result[i] = result[i + 1] = result[i + 2] = 0; // black\n            result[i + 3] = 255; // alpha\n        }\n    }\n\n    return result;\n}\n```\n\n## 결론\n\n이 프로젝트는 간단한 웹 기술을 사용하여 얼마나 많은 작업을 수행할 수 있는지를 상기시켜주는 것이었습니다. HTML5, JavaScript 및 최신 웹 기술을 사용하면 비디오 스트림을 실시간으로 프레임별로 처리할 수 있습니다.\n\n이를 통해 재미있는 경험을 할 수 있기를 바라며, 웹 기술 선택에 대한 의견을 주시면 감사하겠습니다.```","ogImage":{"url":"/assets/img/2024-05-27-MirrorMirrorAWebcamInfinityMirrorwithVanillaJS_0.png"},"coverImage":"/assets/img/2024-05-27-MirrorMirrorAWebcamInfinityMirrorwithVanillaJS_0.png","tag":["Tech"],"readingTime":11},{"title":"HTML 학습 로드맵(2024년 최신)","description":"","date":"2024-05-27 19:13","slug":"2024-05-27-RoadmapforlearningHTML","content":"\n\n\n![Learning HTML](/assets/img/2024-05-27-RoadmapforlearningHTML_0.png)\n\n웹 개발을 시작하는 좋은 출발점은 HTML(Hypertext Markup Language)을 배우는 것입니다. 이 과정을 안내하는 로드맵이 있어요:\n\n시작하려면 다음 링크를 참조하세요: [https://www.w3schools.com/html/default.asp](https://www.w3schools.com/html/default.asp)\n\n# 초보자 레벨:\n\n\n<div class=\"content-ad\"></div>\n\n- 기본 사항 이해하기:\n\n- HTML이 무엇이며 웹 개발에서의 역할을 배웁니다.\n- HTML 문서의 구조를 이해합니다.\n- `html`, `head`, `body`, `p`, `h1`에서 `h6`, `a`, `img` 등과 같은 기본 HTML 태그를 살펴봅니다.\n\n2. 텍스트 서식 지정:\n\n- `strong`, `em`, `u`, `del`, `ins`, `sup`, `sub`와 같은 태그를 사용하여 텍스트 서식을 지정하는 방법을 배웁니다.\n\n<div class=\"content-ad\"></div>\n\n3. 리스트: (네비게이션 바에 중요한 개념)\n\n- 순서가 있는 (`ol`) 및 순서가 없는 (`ul`) 목록 작성 방법과 목록 항목 (`li`)을 배웁니다.\n\n4. 링크 및 네비게이션:\n\n- `a` 태그로 하이퍼링크를 만드는 방법 이해하기.\n- 외부 페이지, 내부 페이지 및 페이지 내 특정 섹션으로 연결하는 방법 탐구하기.\n\n<div class=\"content-ad\"></div>\n\n5. 이미지:\n\n- `img` 태그를 사용하여 이미지를 삽입하는 방법을 배워보세요.\n\n6. 폼:\n\n- `form`, `input`, `textarea`, `select`, 그리고 `button`과 같은 태그를 사용하여 폼을 만드는 기본적인 방법을 이해해보세요.\n\n<div class=\"content-ad\"></div>\n\n7. 시멘틱 HTML:\n\n- `header`, `nav`, `main`, `article`, `section`, `footer`와 같은 시멘틱 HTML 요소에 대해 알아보고 구조화된 문서를 생성하는 데 이들이 어떤 역할을 하는지 이해하세요.\n\n8. 속성:\n\n- HTML 태그 안에서 속성을 사용하는 방법을 이해하세요.\n- `class`, `id`, `src`, `alt`, `href` 등과 같은 일반적인 속성을 살펴보세요.\n\n<div class=\"content-ad\"></div>\n\n# 중급 레벨:\n\n- 테이블:\n\n  - `table`, `tr`, `td`, `th`와 같은 태그를 사용하여 테이블을 만드는 방법 배우기\n  - 테이블 구조와 형식 이해하기\n\n- 내장 콘텐츠:\n\n<div class=\"content-ad\"></div>\n\n- `iframe`, `audio`, `video`을 사용하여 비디오 및 오디오와 같은 멀티미디어 콘텐츠를 임베딩하는 방법을 탐색해보세요.\n\n3. HTML 양식과 입력 유형:\n\n- 텍스트, 체크박스, 라디오, 제출 등 다양한 입력 유형을 이해하여 양식에 대해 깊이 파고들어보세요.\n- 양식 유효성 검사에 대해 알아보세요.\n\n4. HTML5의 새로운 기능:\n\n<div class=\"content-ad\"></div>\n\n- 새로운 HTML5 기능인 `article`, `section`, `header`, `footer`, `nav`, `figure`, `figcaption` 등을 살펴보세요.\n\n5. HTML DOM (지금은 선택 사항입니다. JavaScript의 기본 지식이 필요합니다)\n\n# 고급 레벨:\n\n- 접근성:\n\n<div class=\"content-ad\"></div>\n\n- HTML 접근성을 높이기 위한 ARIA 역할과 속성 사용 방법에 대해 배워보세요.\n\n2. 반응형 디자인:\n\n- 미디어 쿼리와 유연한 그리드 시스템을 사용하여 반응형 레이아웃을 만드는 방법을 이해하세요.\n\n3. SEO 기본 사항:\n\n<div class=\"content-ad\"></div>\n\n- 기초 SEO (검색 엔진 최적화) 원리에 대해 배워보세요.\n\n4. HTML 의미론과 모범 사례:\n\n- 깨끗하고 의미 있는 HTML 코드를 작성하는 모범 사례를 이해하세요.\n\n# 참고: — 연습하고 프로젝트를 만들어 보세요:\n\n<div class=\"content-ad\"></div>\n\n- 작은 프로젝트를 만들어 지식을 적용해보세요.\n- 개인 웹사이트나 포트폴리오를 만들어 자신의 기술을 소개해보세요.\n- 오픈 소스 프로젝트에 기여하거나 GitHub에서 협업해보세요.\n\n# 추가 자료:\n\n- HTML에 대한 우수한 온라인 참고 자료로 W3Schools와 MDN Web Docs가 있습니다 (MDN은 선택 사항).\n- Codecademy, Udemy 또는 freeCodeCamp와 같은 플랫폼의 온라인 강의를 통해 구조화된 학습 경로를 제공받을 수 있습니다.\n\nHTML 마스터하기의 핵심은 꾸준한 실습입니다. 발전하면 CSS 같은 스타일링, 그리고 JavaScript 같은 상호 작용성을 제공하는 다른 웹 개발 기술들을 탐험할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 보너스 :-\n\n더 빨리 학습하기 위해 구현하는 방법은 https://www.w3schools.com/html/default.asp 웹 사이트를 방문하여 VS Code나 선호하는 다른 IDE를 열어보세요.\n\nW3school에서 읽은 내용을 IDE에서 직접 실습해보세요. 이것이 가장 빠르게 배우는 방법입니다.\n\n이후에는 HTML과 기본 CSS로 프로젝트를 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n# 빙고: - HTML 작업이 준비되었습니다 🤩🤩\n\n팔로우하지 않는 걸 잊지 마세요 !!!","ogImage":{"url":"/assets/img/2024-05-27-RoadmapforlearningHTML_0.png"},"coverImage":"/assets/img/2024-05-27-RoadmapforlearningHTML_0.png","tag":["Tech"],"readingTime":3},{"title":"라이트닝 웹 컴포넌트에 대해 SalesForce 개발자가 알아야 할 5가지 중요 사항","description":"","date":"2024-05-27 19:11","slug":"2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents","content":"\n\n\n![image](/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_0.png)\n\n솔루션 아키텍트이자 전 프론트엔드 개발자로 활동한 저는 많은 Salesforce 프로젝트에서 UI 개발의 지식과 품질에 항상 놀라곤 합니다. 최근 몇 년 동안 Lightning Web Components (LWC)와 Lightning Web Security (LWS)의 도입으로 Salesforce가 일반 웹 표준을 지원하려는 움직임이 계속 확대되었다 하더라도, Aura 및 Lightning Locker와 같은 개념 이후 Salesforce 개발자들은 종종 이 분야에서 중요한 지식 갭을 갖고 Backend 중심적인 경향을 보입니다.\n\n그래서, 이 블로그 포스트를 통해 LWC 개발에서 선수해야 할 몇 가지 중요한 사항을 명확하게 하고자 합니다. 그러나 그에 앞서, 가능한 UI 지식 갭이 왜 존재하는지 알아보기 위해 간단하게 되돌아보겠습니다.\n\n# Salesforce 개발자가 왜 Backend 중심적인지?\n\n\n\n<div class=\"content-ad\"></div>\n\n내 의견으로는 Salesforce 생태계에서 UI 개발에 대한 깊은 지식 부족은 역사적인 문제입니다. 이는 주로 LWC가 2018/19에 출시된 이후에만 사용 가능한 Web Components 기반 UI 프레임워크가 현재 일반적으로 인정받는 웹 표준을 사용하기 때문입니다. 이는 당연히 Salesforce 개발자들 사이에서 JavaScript를 사용한 개발 시 일반적인 표준, 규칙, 그리고 최선의 실행 방법에 대한 인식이 부족하다는 것을 의미합니다. 물론, LWC 이전에도 Salesforce의 맞춤형 UI 개발을 위한 다른 솔루션이 있었지만(Aura 및 Visualforce), 이러한 솔루션들은 일반적인 UI 원칙을 준수하지 않고 플랫폼별이며 개별적이었습니다.\n\n![이미지](/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_1.png)\n\n그러나 지난 몇 년 동안 Salesforce는 이 방향으로 발전하고 일반적인 UI 개념을 적용하여 플랫폼을 JavaScript 개발자에게 더 매력적으로 만들었습니다. 2020년부터는 Salesforce JavaScript 개발자 1 자격증이 있으며, 시험 자체가 Salesforce 플랫폼과 독립적으로 JavaScript의 일반적인 이해를 테스트합니다.\n\n이제 실질적으로 다가가서, LWC에 대해 꼭 알아야 할 5가지 중요한 사항을 함께 살펴보겠습니다!\n\n<div class=\"content-ad\"></div>\n\n# 1. Apex 없이 작동하는 경우가 많습니다\n\nSalesforce에서는 일반적으로 \"사용자 정의보다 표준\"이라는 지침을 따르며, 이는 일정 부분 UI 개발에도 적용되어야 합니다. 이전에 설명한 바와 같이 백엔드 중심의 개발자들은 종종 UI 구성요소에서 데이터를 로드하고 표시하기 위해 사용자 정의 Apex 컨트롤러를 작성하는 경향이 있습니다. 그러나 Salesforce에는 이러한 사용 사례에 대한 \"표준\" 솔루션이 많이 존재합니다.\n\n![Salesforce](/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_2.png)\n\nSalesforce는 레코드 및 메타데이터 정보를 로드하는 LWC 개발을 위한 표준 UI API를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n- UI Record API — 레코드를 위한 일반적인 CRUD 작업을 허용합니다.\n- UI Object Info API — 객체 메타데이터 및 픽리스트 값 가져오기\n- GraphQL API — 라이트닝 데이터 서비스 및 GraphQL을 사용하여 데이터 관리\n\n여기에 언급된 API 외에도 더 많은 API가 있습니다. 이러한 표준화된 UI API의 사용은 종종 LWC 코드를 훨씬 더 가독성 있게 만들어주며 Apex 컨트롤러 및 관련 테스트 클래스의 구현과 유지보수를 줄여줍니다.\n\n매우 간단한 예제로 전체 내용을 설명하기 위해, 여기에는 Apex를 사용하여 계정 정보, 즉 이름을 표시하는 LWC로 시나리오를 제시합니다. 이 예에서 \"Apex를 사용하지 않는\" UI Record API를 사용하는 것이 명백하게 선호되는 옵션이 될 것입니다. 솔루션이 단순화되었으므로 필요한 Apex 테스트 클래스 및 오류 처리와 같은 것들은 무시되었습니다.\n\n## Apex와 함께\n\n<div class=\"content-ad\"></div>\n\n\n![Image 3](/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_3.png)\n\n![Image 4](/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_4.png)\n\n## Without Apex\n\n![Image 5](/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 2. UI 스타일링을 간단하게 유지하세요\n\n시간이 지남에 따라 알게 된 한 가지는 Salesforce 개발자의 공통 \"좋아하는 작업\"은 UI 스타일링입니다. 먼저, Apex와는 달리 UI 개발, 특히 LWC의 경우 여러 언어로 구성되어 있습니다. 이는 JavaScript로 구성 요소의 비즈니스 로직을 설명하는 것뿐만 아니라 HTML로 구조 및 요소를 설명하고 CSS로 스타일링하는 것을 필요로 한다는 것을 의미합니다.\n\n그러나 Salesforce 개발자들이 가끔 소홀히 하는 경향이 있는 것은 스타일링과 관련해 항상 복잡하게 만들 필요가 없다는 점입니다. 올바른 접근 방법을 알지 못한 결과로 종종 나쁜, 때로는 불필요한 사용자 정의 CSS 코드가 발생합니다. 대부분의 경우 올바른 룩 & 필을 얻기 위해 사용자 정의 CSS가 전혀 필요하지 않습니다. 일반적으로 올바른 솔루션 방법을 찾기 위해서는 최대 3 단계만 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n- LWC 구성 요소 참조: 먼저 재사용 가능한 표준 구성 요소를 찾아보는 것이 좋습니다. Salesforce는 미리 구축된 UI 요소, 예를 들어 버튼, 아이콘 또는 데이터 테이블과 같은 미리 만들어진 표준 컴포넌트 라이브러리를 제공하여 작업 또는 구성 요소를 구현하는 데 유용하게 사용할 수 있습니다.\n- SLDS 블루프린트: 1번에서 설명한 미리 만들어진 솔루션을 사용하여 원하는 기능을 구현할 수 없는 경우 SLDS가 도움이 될 수 있습니다. Salesforce Lightning Design System은 Salesforce 룩 & 필을 따르는 LWC를 디자인하는 데 사용할 수 있는 템플릿 및 도구를 제공합니다. 이를 통해 Salesforce UI에 완벽하게 통합되는 개별 기능을 디자인할 수 있습니다. 또한 SLDS는 정렬, 테두리, 안쪽 여백 등과 같은 표준 스타일링 요구 사항을 해결하는 많은 CSS 유틸리티 클래스를 제공하여 사용자 정의 CSS를 작성하지 않아도 됩니다.\n- 사용자 정의 CSS: 1번과 2번이 적용되지 않을 때에만 사용자 정의 CSS 스타일링을 고려해야 합니다. 예를 들어 고객의 기업 이미지에 맞추어 Experience 사이트용 LWC를 구축할 때 특정 디자인 요구 사항을 충족해야 하는 경우에 사용될 수 있습니다.\n\n# 3. 웹 API 활용\n\n특히 더 복잡한 UI 요구 사항을 구현할 때, 개발자들로부터 종종 \"Salesforce에서는 불가능하다\" 또는 \"Salesforce 문서에서 이에 대한 정보를 찾을 수 없다\"라는 말을 듣곤 합니다. Salesforce 개발자들은 주로 자체 생태계와 관련된 표준 및 문서 내에서만 활동하는 경향이 있습니다. 이는 Salesforce에 특화된 백엔드 프레임워크인 Apex에 대해서는 완벽히 타당한 이유이지만, LWC의 경우에는 종종 기본 웹 표준에 기반하므로 다양한 가능성을 확장하는 경우가 많습니다.\n\n![이미지](/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_6.png)\n\n<div class=\"content-ad\"></div>\n\n물론, 항상 LWC 프레임워크 자체에서 제공하는 도구와 옵션부터 시작해야 합니다. 그러나 이들이 항상 충분하지는 않거나 모든 것을 다루지 않을 수 있습니다. 이 경우에는 해당 웹 API에 의존하거나 아니면 적절한 해결책을 찾기 위해 제3자 라이브러리를 통합해야 할 수도 있습니다. MDN 웹 문서는 사용 가능한 웹 API에 대한 포괄적인 문서화를 제공하는 적절한 소스입니다. 그럼에도 불구하고, 항상 주의해서 이를 처리하고 해당 이유를 신중하게 고려해야 합니다.\n\n다양한 웹 API와 LWC로 어떤 것을 달성할 수 있는지에 대한 영감이 필요하다면, 몇 가지 예제를 담고 있는 다음 블로그 포스트들을 살펴보시기 바랍니다:\n\n# 4. 시간을 절약하고 로컬에서 개발하기\n\nLWC 개발의 시간 소모적인 측면 중 하나는 종종 개발이 Visual Studio Code(또는 다른 IDE)에서만 가능하다는 점이며, 최신 변경 사항을 검토하고 테스트하기 위해 새 코드를 연결된 Salesforce 조직에 계속 푸시해야 한다는 필요성을 포함합니다. 특히 미세한 스타일 조정에서는 이것이 신속하게 지루하고 피곤한 작업이 될 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n판매 포스를 제외한 다른 UI 프레임워크에서는 React나 Angular 같은 로컬 개발 서버 사용이 흔한 표준이므로 이런 상황을 피할 수 있어요. 여기서 큰 장점은 변경 사항을 먼저 배포할 필요가 없고, 대신 해당 파일을 저장하면 자동으로 업데이트되는 로컬 서버에서 직접 표시되는 점이에요. 그러나 많은 판매 포스 개발자들이 인식하지 못하는 것은 판매 포스에서도 LWC 개발을 위한 이 옵션이 존재한다는 점이죠. 아마도 이 기능이 여전히 베타 상태이기 때문일 것입니다. 하지만 저는 이미 많이 사용해봤고, 제 의견으로는 신뢰성 있게 사용할 수 있고, 그러므로 굉장히 과소평가된 기능이라고 말할 수 있어요.\n\n![로컬 개발 GIF](https://miro.medium.com/v2/resize:fit:1400/1*WrIe8vWhnDGLkBjLZKLGgQ.gif)\n\n로컬 개발에 대한 자세한 내용 및 설정 단계에 대한 필수 정보가 있는 블로그 포스트를 여기에서 찾을 수 있어요:\n\n# 5. UI 단위 테스트를 고려하세요\n\n<div class=\"content-ad\"></div>\n\n제가 Salesforce와 함께 일하면서 전반적인 테스트 방법론에 대해 생각한 질문 중 하나는:\n\n![이미지](/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_7.png)\n\n일부 Salesforce 개발자들은 LWC에 대해 Jest를 사용하여 단위 테스트를 작성할 수 있다는 것을 알고 있지만, 직접 작성해 본 사람은 매우 적습니다. 실제로 Salesforce 외부에서 UI를 위한 단위 테스트 작성이 웹 개발에서 흔한 관행인데, 사용자가 상호 작용하게 되는 첫 번째 요소가 UI이므로 이는 직관적으로도 이해됩니다.\n\n모든 Salesforce 개발자와 아키텍트는 프로덕션 배포를 수행할 때 75% 코드 커버리지의 잘 알려진 임계값에 익숙합니다. 그러나 왜 이것이 Apex에만 해당되는 것일까요? 이에 대한 이유는 여러 가지가 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n- 역사적으로 Aura에는 실제 테스트 옵션이 없었지만 LWC의 도입으로 이를 해결할 수 있게 되었습니다.\n- LWC 테스트는 로컬에서만 실행되며, Apex와 달리 메타데이터의 일부로 조직에 푸시되지 않아 조직 수준의 코드 커버리지 대상을 강제로 설정할 수 없습니다.\n\n그러나 무시해서는 안 되는 것은 UI 구현의 일반적인 안정성과 품질 향상에 더해, LWC 테스트가 제공하는 추가적인 이점이 있습니다:\n\n- 표준 구문 → 기존 테스트 프레임워크로서 검증된 Jest의 사용, 이는 다른 UI 프레임워크에서도 표준으로 사용됩니다.\n- 빠른 피드백 → Apex 테스트와 비교했을 때 조직이나 데이터 연결에 대한 의존성이 없어서 (스텁/모의 사용).\n- 코드 커버리지 보고 → LWC 및 Apex 구현의 결합 조직 커버리지를 모니터링하는 Sonar와 같은 도구에서 볼 수 있는 다양한 형식의 테스트 보고서 생성을 지원합니다.\n\n![이미지](/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_8.png)\n\n<div class=\"content-ad\"></div>\n\n# 주요 포인트 및 권장 사항\n\n이 블로그 포스트가 Lightning Web Components에 대해 고찰해 볼 기회를 제공했으면 좋겠습니다. 저는 Salesforce 개발자로써 논의된 주제에 대한 인식을 높이는 것이 중요하다고 생각합니다. 만약 여러분이 개발자이고 앞으로의 Salesforce 프로젝트에서 더 나은 성과를 얻고 싶다면 다음 사항을 고려해보세요:\n\n- 사용자 경험을 항상 염두에 두세요!\n- JavaScript 및 일반적인 개념에 대해 더 많이 학습하세요.\n- Salesforce JavaScript Developer 1 자격증을 취득하려면 노력해보세요. 이 자격증은 JavaScript의 기술적 이해를 테스트합니다. LWC 프레임워크 이해와 해당 자격증 획득은 관련 LWC 슈퍼배지를 완료한 후에 이루어집니다.\n- 제가 준비한 Lightning Web Components 트레일믹스를 확인해보세요. 이 트레일믹스에는 프레임워크에 대해 알아야 할 모든 정보가 포함되어 있습니다.","ogImage":{"url":"/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_0.png"},"coverImage":"/assets/img/2024-05-27-5ThingsSalesforceDevelopersshouldknowaboutLightningWebComponents_0.png","tag":["Tech"],"readingTime":8},{"title":"Google Apps Script의 스크립트 편집기에서 HTML 및 Javascript 개발 기능 향상하기 서식 지정 문제 극복하기","description":"","date":"2024-05-27 19:09","slug":"2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges","content":"\n\n\n![EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScript](/assets/img/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges_0.png)\n\n# 개요\n\n2022년 4월에 시작된 Google Apps Script IDE가 개선되었음에도 불구하고 HTML 및 Javascript 개발에 대한 어려움이 발생합니다. 특히 스크립트 편집기의 내장된 언어 형식 지정은 큰 Javascript 코드베이스에 대해 불충분하며, 잠재적으로 오류를 일으킬 수 있습니다. 본 보고서는 이러한 형식 지정 문제를 해결하고 스크립트 편집기 내에서 개발을 원활하게 할 수 있는 솔루션을 제안합니다.\n\n# 소개\n\n\n<div class=\"content-ad\"></div>\n\nGoogle Apps Script 통합 개발 환경(IDE) 스크립트 편집기가 2022년 4월 13일에 중요한 업데이트를 받아 더 현대적이고 간소화된 개발 환경으로 변모했습니다. 이 향상된 IDE를 통해 개발자들은 그들의 조직을 위해 구글 워크스페이스 애플리케이션의 기능을 확장하는 사용자 정의 솔루션을 만들 수 있습니다.\n\n스크립트 편집기는 Google Apps Script 개발에 유용한 도구지만, HTML 및 Javascript를 사용할 때 문제가 발생할 수 있습니다. 현재 스크립트 편집기 내에서 HTML 및 Javascript 개발은 직접 HTML 파일에서 발생합니다. 편집기는 서식 지원 기능을 제공하지만, Javascript 코드 포맷팅은 HTML 포맷팅과 비교했을 때 덜 견고해 보입니다. 이로 인해 큰 Javascript 코드베이스를 다룰 때 특히 오류가 발생할 수 있습니다.\n\n본 보고서는 이 특정 문제에 대한 해결책을 제안합니다. Google Apps Script 스크립트 편집기 내에서 HTML 및 Javascript를 효과적으로 개발하는 방법을 탐구하고, 개발 효율성을 향상시키고 오류를 줄일 수 있도록 올바른 Javascript 코드 포맷팅을 보장합니다.\n\n# 사용법\n\n<div class=\"content-ad\"></div>\n\n# 1. Google Apps Script 프로젝트 만들기\n\n이 샘플에서는 HTML 및 Javascript를 사용하기 위해 Google Spreadsheet에서 대화 상자를 사용합니다. 따라서 새 Google Spreadsheet를 만들고 스크립트 편집기를 열어주세요.\n\n# 2. 샘플 스크립트 1\n\n이 섹션에서 현재 문제를 설명합니다. 아래 스크립트와 HTML을 복사하여 스크립트 편집기에 붙여넣어주세요.\n\n<div class=\"content-ad\"></div>\n\n# code.gs\n\n```js\nfunction openDialog() {\n  const html = HtmlService.createHtmlOutputFromFile(\"index\");\n  SpreadsheetApp.getUi().showModalDialog(html, \"sample\");\n}\n```\n\n# index.html\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n<base target=\"_top\">\n</head>\n<body>\n<div id=\"sample\"></div>\n<script>\nconst array = [[\"A1\", \"B1\", \"C1\"],[\"A2\", \"B2\", \"C2\"],[\"A3\", \"B3\", \"C3\"]];\nconst div = document.getElementById(\"sample\");\nconst table = document.createElement('table');\ntable.border = \"1\";\ntable.style.width = \"100%\";\ntable.style[\"border-collapse\"] = \"collapse\";\nfor (let i = 0; i < array.length; i++) {\n  const tr = document.createElement('tr');\n  for (let j = 0; j < array[i].length; j++) {\n    const td = document.createElement('td');\n    const text = document.createTextNode(array[i][j]);\n    td.appendChild(text);\n    tr.appendChild(td);\n  }\n  table.appendChild(tr);\n}\ndiv.appendChild(table);\n</script>\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n# 테스트\n\nopenDialog 함수를 실행하면 대화 상자가 열리고 대화 상자에서 다음 테이블을 볼 수 있습니다. HTML과 JavaScript가 잘 작동하는 것을 확인할 수 있습니다.\n\n![Table Image](/assets/img/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges_1.png)\n\n다음 단계로 넘어가면 index.html을 볼 때 JavaScript 형식이 지정되지 않았고 가독성이 낮다는 것을 알 수 있습니다. 이 코드를 스크립트 편집기에서 형식을 맞추면 다음과 같이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/0*AQlYdIS3NlLn6zcy.gif\" />\n\n코드를 서식화하면 HTML이 올바르게 서식이 적용됩니다. 그러나 Javascript는 올바르게 서식이 적용되지 않는 것을 볼 수 있습니다. 이 상황은 Javascript를 개발하는 데 문제가 될 수 있다고 생각합니다.\n\n# 3. 샘플 스크립트 2\n\n본 섹션에서는 상기 상황을 피하기 위한 해결책으로 샘플 스크립트 2를 소개하고자 합니다. 따라서 아래 스크립트를 복사하기 전에 상기 섹션에서 사용된 code.gs 및 index.html을 지우고, 다음 스크립트와 HTML을 스크립트 편집기에 복사하여 붙여넣어 주세요.\n\n<div class=\"content-ad\"></div>\n\n# code.gs\n\n```js\nfunction javascript_() {\n  const array = [[\"A1\", \"B1\", \"C1\"],[\"A2\", \"B2\", \"C2\"],[\"A3\", \"B3\", \"C3\"]];\n  const div = document.getElementById(\"sample\");\n  const table = document.createElement('table');\n  table.border = \"1\";\n  table.style.width = \"100%\";\n  table.style[\"border-collapse\"] = \"collapse\";\n  \n  for (let i = 0; i < array.length; i++) {\n    const tr = document.createElement('tr');\n    \n    for (let j = 0; j < array[i].length; j++) {\n      const td = document.createElement('td');\n      const text = document.createTextNode(array[i][j]);\n      td.appendChild(text);\n      tr.appendChild(td);\n    }\n    \n    table.appendChild(tr);\n  }\n  \n  div.appendChild(table);\n}\n\nfunction openDialog() {\n  const html = HtmlService.createTemplateFromFile(\"index\");\n  html.javascript = javascript_\n    .toString()\n    .match(/^function javascript_\\(\\) {([\\s\\S\\w]*)}$/)[1];\n  SpreadsheetApp.getUi().showModalDialog(html.evaluate(), \"sample\");\n}\n```\n\n# index.html\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n<base target=\"_top\">\n</head>\n<body>\n<div id=\"sample\"></div>\n<script>\n<?!= javascript ?>\n</script>\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n# 테스팅\n\nopenDialog 함수를 실행하면 대화 상자가 열리고 대화 상자에서 다음 표를 볼 수 있습니다. 위 섹션에서 동일한 결과를 볼 수 있습니다.\n\n다음 단계로, 현재 index.html 및 code.gs를 확인하면 두 형식 모두 미완료되고 가독성이 낮음을 알 수 있습니다. 이러한 코드가 스크립트 편집기로 형식이 지정되면 다음과 같이 됩니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*Sszz38pwq-gqhqju.gif)\n\n<div class=\"content-ad\"></div>\n\nindex.html과 code.gs를 형식화하면 두 파일 모두 적절한 서식으로 표시되어 가독성이 향상됩니다. 또한 JavaScript 코드는 대화 상자 내에서 올바르게 작동합니다.\n\n이전에 언급했듯이 스크립트 편집기는 현재 code.gs 스크립트 파일 내의 Google Apps 스크립트를 형식화할 수 있습니다. 이 보고서는이 기능을 해결책으로 활용합니다. JavaScript는 code.gs 스크립트 파일에서 개발되며 개발된 코드는 index.html HTML 파일로 가져옵니다. 이 작업 흐름을 통해 JavaScript 코드를 적절히 형식화하여 개발할 수 있습니다.\n\n# 중요\n\nJavaScript 코드에 스크립트 편집기와 호환되지 않는 구문이 포함된 경우 이 해결책을 적용할 수 없음에 유의해 주세요. 이러한 시나리오에서 주의해 주시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n# 참고\n\n- 최상단의 추상 이미지는 Gemini에게 이 보고서를 제공하여 생성되었습니다.","ogImage":{"url":"/assets/img/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges_0.png"},"coverImage":"/assets/img/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges_0.png","tag":["Tech"],"readingTime":6},{"title":"Reset.css로 프로젝트 스타일을 초기화 하는 방법","description":"","date":"2024-05-27 19:08","slug":"2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024","content":"\n\n\n![Reset CSS](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_0.png)\n\n웹 사이트 소스를 확인하면 이곳저곳에서 이 reset.css를 만날 수 있습니다. CSS Reset은 무엇이며 왜 필요한 걸까요?\n\n이 기사에서 다양한 reset.css를 확인할 수 있는 간단한 코드펜을 만들었어요! CSS Reset을 느껴보기 위해 한 번 시도해보세요!\n\nCSS Reset 스타일 시트는 기본 브라우저 스타일을 모두 재정의하는 CSS 스타일 목록입니다. 대부분의 브라우저는 테두리, 패딩 및 마진, 확대 축소, 글꼴 등에 자체 스타일을 가지고 있습니다. reset.css를 사용하면 이러한 기본 동작을 모두 제거하고 다양한 브라우저에서 일관된 UI/UX를 유지할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n크롬\n- 사파리\n- 파이어폭스\n- 엣지\n\n웹 디자인을 일관되게 유지하는 옵션을 찾고 있다면, reset.css 외에도 normalize.css를 사용할 수 있는 옵션이 있습니다.\n\nreset.css와는 다르게 normalize.css는 브라우저 기본값을 지우는 대신 일부를 보존합니다. 이는 sub와 같은 요소를 사용하는 경우 유용할 수 있습니다. 이 경우 reset.css 대신 normalize.css를 사용하면 일반 텍스트와 거의 동일하게 보입니다.\n\n<div class=\"content-ad\"></div>\n\n또한 normalize.css를 사용하면, 사전 서식이 지정된 텍스트의 글꼴 크기를 수정하는 등의 일반적인 버그를 수정할 수 있습니다.\n\n그러나 저는 기본 스타일을 모두 초기화하고 싶습니다! 그래서 reset.css를 사용하기로 결정했고, 이 문서에서 제 추천을 공유하려고 합니다!\n\n# reset.css 사용하기\n\nreset.css를 다른 스타일 시트처럼 사용할 수 있습니다. 여기서 염두에 두어야 할 유일한 것은 reset.css가 가장 먼저 와야 한다는 것입니다!\n\n<div class=\"content-ad\"></div>\n\n\n<head>\n    <link rel=\"stylesheet\" href=\"reset.css\" />\n    <link rel=\"stylesheet\" href=\"otherStyles.css\" />\n</head>\n\n\n# 2024년을 위한 추천\n\n안녕하세요! 실제로 reset.css는 서로 다른 방식으로 서로 다른 정도의 스타일을 초기화합니다. 여기서 내가 정말 좋아하는 것들 중 일부를 공유하고 싶어요!\n\n자세히 알아보거나 시각화를 더 잘 하고 싶다면, 우리가 이 글에 포함시킨 모든 다른 reset.css를 비교할 수 있는 간단한 코드펜을 사용해보세요. 이 글에는 normalize.css도 포함되어 있으며 스타일시트를 추가하지 않은 선택 사항도 비교할 수 있도록 포함해 두었어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*wjXmIrPgLX_afnYKDhvj4w.gif\" />\n\n(PS: CSS 내용은 무시해도 괜찮아요, 시각화를 위한 것뿐이에요!)\n\n## 현대 CSS 리셋\n\n여기서 제공하는 것은 아마도 현대 브라우저에 가장 흔하게 사용되는 CSS 리셋 중 하나일 것입니다. 테일윈드에서 리셋 스타일시트로 사용되었던 것으로 알고 있는데요 (이제는 normalize.css를 사용하러 가는 것 같아요). (그런 의미로, 이것은 제가 독특하다고 보지 않아서 가장 마음에 들지 않는 것이에요!)\n\n<div class=\"content-ad\"></div>\n\n이 reset.css의 가장 좋은 부분 중 하나는 파일을 작고 유지하기 때문에 로딩 속도가 정말 빠르다는 점입니다. 또한 모든 요소에 대해 box-sizing을 border-box로 정의하고 양식과 목록을 정의하는 데 많은 주의를 기울입니다.\n\n이 리셋은 실제로 내 개인적인 의견으로는 모든 `h1`과 같은 태그에 대해 글꼴 크기를 유지해 normalize.css에 더 가깝다고 생각합니다.\n\n저자는 GitHub 저장소를 성공적으로 이루었고 reset.css를 여기에 게시했습니다. 로컬 파일에 복사하여 붙여 넣거나 CDN인 https://unpkg.com/modern-css-reset/dist/reset.min.css를 사용하여 추가할 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_1.png)\n\n<div class=\"content-ad\"></div>\n\n## Reboot.css\n\n부트스트랩에서 사용하는 리셋 CSS입니다. 퀄리티가 보장되죠!\n\n사실 이건 normalize.css에 더 가깝습니다. 위의 것과 비교했을 때 요소들의 폰트 크기(`h1` 등)를 유지합니다. 아래 스크린샷에서 보시다시피 패딩도 그대로 유지됩니다.\n\n(사실 이거 쓰고 아무것도 안 쓰는 거랑 차이가 크게 느껴지지는 않았던 것 같아요…)\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_2.png)\n\n다음 방법으로 추가할 수 있어요\n\n- CDN 사용: [https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/css/bootstrap-reboot.css](https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/css/bootstrap-reboot.css), 또는\n- Github에서 다운로드하세요.\n\n## @acab/reset.css\n\n\n<div class=\"content-ad\"></div>\n\n@acab/reset.css는 최신 CSS 기능을 활용한 스타일 리셋이에요. 이 리셋 스타일시트를 다른 것과 구별하는 두 가지 주요 기능이 있어요.\n- iOS Safari에서 100vh가 전체 높이를 채우지 않는 문제를 해결했어요.\n- color-scheme을 활용하여 자동 다크 모드를 지원해요.\n\n@acab/reset.css를 사용하는 방법:\n- npm을 이용해 설치하기: npm install @acab/reset.css,\n- CDN 이용: https://unpkg.com/@acab/reset.css,\n- 소스 코드 다운로드 후 로컬 파일로 추가하기.\n\n해보세요! 🙂\n\n<div class=\"content-ad\"></div>\n\n그리고 보시다시피, 위의 것과 많이 다른데요, 제 지역의 컬러 스킴에 적응하고 있어요!\n\n![이미지](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_3.png)\n\n### 새로운 CSS 초기화\n\n이 새로운 CSS 초기화는 제가 가장 좋아하는 스타일이에요!\n\n<div class=\"content-ad\"></div>\n\n기본 스타일을 제외한 모든 것이 제거됩니다. 그러나 display 속성 및 iframe, canvas, img, svg, video와 같은 특수 HTML 요소는 유지됩니다.\n\n![이미지1](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_4.png)\n\n![이미지2](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_5.png)\n\n네, 스타일이 하나도 남지 않습니다. 입력 상자나 라디오 버튼조차 없어요! 모든 것을 제거하고 처음부터 직접 디자인하고 싶다면 완벽해요!\n\n<div class=\"content-ad\"></div>\n\n너무 복잡한 것 같나요? 특정 요소의 기본 스타일을 되찾는 데는\n\n- 전역 CSS 리셋 키워드, unset 및 revert 키워드.\n- 모든 속성을 초기화하는 all 속성을 결합할 수 있어요.\n\n특정 HTML 요소의 브라우저 기본 스타일을 되찾으려면, 예를 들어 input의 경우, 다음과 같이 할 수 있어요\n\n```js\ninput {\n    all: revert;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 이제 우리가 사용하는 일반적인 형식으로 돌아왔어요!\n\n![2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_6.png](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_6.png)\n\n이 새로운 CSS 리셋은 특정성을 제거하는 :where() 가상 클래스와 여러 인수를 가진 :not() 가상 클래스와 같은 다른 CSS 기능도 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n저기요!\n\n저희 프로젝트에서는 다음 방법으로 사용할 수 있어요:\n\n- CDN을 이용하는 방법: https://cdn.jsdelivr.net/npm/the-new-css-reset@1.11.2/css/reset.min.css,\n- 최신 버전 다운로드하는 방법, 또는\n- NPM 패키지로 사용하는 방법\n\n읽어 주셔서 감사합니다! 마음에 드는 방법을 찾으셨나요?\n\n즐거운 스타일링 되세요!","ogImage":{"url":"/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_0.png"},"coverImage":"/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_0.png","tag":["Tech"],"readingTime":5},{"title":"인라인 스타일과 CSS의 성능 차이 정리 및 비교","description":"","date":"2024-05-27 19:06","slug":"2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences","content":"\n\n![Are inline styles better than CSS? Performance differences](/assets/img/2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences_0.png)\n\n웹 개발에 있어서 인라인 스타일과 CSS 스타일 시트의 성능 차이에 대한 논쟁이 일반적으로 있습니다. 각 접근 방식의 미묘한 차이를 이해하는 것은 효율적이고 유지보수가 용이하며 확장 가능한 웹 애플리케이션을 만드는 데 중요합니다. 이 블로그 포스트에서는 인라인 스타일과 CSS에 대한 성능 측면, 실용적 사용 및 최선의 방법에 대해 탐구해 보겠습니다.\n\n# 인라인 스타일과 CSS 이해하기\n\n# 인라인 스타일:\n\n<div class=\"content-ad\"></div>\n\n인라인 스타일은 HTML 요소 내에서 직접 정의됩니다. 스타일 속성을 사용하여 스타일을 지정할 수 있습니다. 예시:\n\n```html\n<div style=\"color: red; font-size: 16px;\">Hello, World!</div>\n```\n\n# CSS 스타일시트:\n\nCSS 스타일은 별도의 CSS 파일에 정의할 수 있고, HTML 문서에 연결하거나 HTML 문서 내에 `style` 태그를 사용하여 포함시킬 수 있습니다. 예시:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- 외부 CSS -->\n<link rel=\"stylesheet\" href=\"styles.css\">\n\n<!-- 내장 CSS -->\n<style>\n  .example {\n    color: red;\n    font-size: 16px;\n  }\n</style>\n<div class=\"example\">Hello, World!</div>\n```\n\n# 성능 고려사항\n\n# 로딩과 구문 분석\n\n## 인라인 스타일:\n\n<div class=\"content-ad\"></div>\n\n- 이니셜 로드 시간: 인라인 스타일은 HTML 내에서 직접 정의되기 때문에 브라우저는 외부 스타일 시트를 로드하기 위해 추가적인 요청을 보내지 않아도 됩니다. 특히 소규모 웹사이트의 경우, 이는 초기 로드 시간을 약간 줄일 수 있습니다.\n- 구문 분석 속도: 인라인 스타일은 HTML이 처리됨과 동시에 즉시 구문 분석됩니다. 소수의 인라인 스타일의 경우, 성능 차이는 무시할 수 있습니다. 그러나 인라인 스타일의 수가 증가함에 따라 오버헤드가 상당히 증가할 수 있습니다.\n\n## CSS 스타일시트:\n\n- 이니셜 로드 시간: 외부 스타일 시트는 추가적인 HTTP 요청이 필요하며, 이는 초기 로드 시간을 증가시킬 수 있습니다. 그러나 HTTP/2와 캐싱과 같은 현대적인 기술을 사용하면 이 영향을 최소화할 수 있습니다.\n- 구문 분석 속도: 스타일 시트는 한 번 해석되고 문서에 적용되므로, 많거나 복잡한 스타일이 있는 페이지에 효율적입니다. 브라우저 최적화와 캐싱은 후속 페이지 로드의 성능을 크게 향상시킬 수 있습니다.\n\n# 렌더 성능\n\n<div class=\"content-ad\"></div>\n\n## 인라인 스타일:\n\n- 효율성: 인라인 스타일은 즉시 적용되어 위험하거나 페이지의 상위 부분 콘텐츠를 빠르게 렌더링하기 위해 유용할 수 있습니다. 그러나 너무 많은 인라인 스타일을 사용하면 HTML 크기가 커져 렌더링 속도가 느려질 수 있습니다.\n- 특이성과 오버헤드: 인라인 스타일은 가장 높은 특이성을 가지고 있어 다른 스타일을 무력화시킬 수 있으며, 이는 코드의 복잡성 증가와 유지보수가 어려워지는 가능성이 있습니다.\n\n## CSS 스타일시트:\n\n- 효율성: 외부 스타일시트는 한 번 로드되고 해석되면 여러 요소와 페이지에 스타일을 적용하는 데 효과적입니다. 중복을 줄이고 재사용성을 촉진하는 데 도움이 됩니다.\n- 브라우저 최적화: 최신 브라우저는 대용량 CSS 파일을 효율적으로 처리할 수 있는 최적화된 기능을 갖추고 있으며, CSS 최소화와 압축과 같은 기술은 성능을 더욱 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n# 실용적인 용도 및 최선의 방법\n\n## 인라인 스타일을 사용해야 하는 경우\n\n**빠른 프로토타이핑:**\n\n전체 스타일시트에 영향을 미치지 않으면서 특정 스타일을 빠르게 테스트하거나 프로토타입을 만들 때 인라인 스타일은 빠르고 효과적인 해결책이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 동적 스타일링:\n\n사용자 상호작용이나 데이터에 따라 동적으로 생성된 스타일이 필요할 때 JavaScript와 함께 인라인 스타일을 효과적으로 사용할 수 있습니다. 예를 들어, 버튼 클릭 시 요소의 배경색을 변경하는 방법은 다음과 같습니다:\n\n```js\ndocument.getElementById(\"myDiv\").style.backgroundColor = \"blue\";\n```\n\n# Critical Rendering Path:\n\n<div class=\"content-ad\"></div>\n\n중요하거나 화면 상단에 표시되는 콘텐츠에는 인라인 스타일을 사용하여 외부 스타일시트가 로드될 때까지 기다리지 않고 즉시 필수 스타일이 적용될 수 있습니다.\n\n# CSS 스타일시트 사용 시기\n\n## 확장성 및 유지보수성:\n\n대규모 프로젝트의 경우 CSS 스타일시트를 사용하면 조직화, 유지보수 및 확장성이 더 잘 이루어집니다. 스타일은 콘텐츠와 분리되어 관리되며 관심사의 분리 원칙을 준수합니다.\n\n<div class=\"content-ad\"></div>\n\n## 재사용성:\n\nCSS 스타일시트에 정의된 스타일은 여러 페이지와 요소에서 재사용될 수 있어 중복을 줄이고 웹 사이트 전체에서 일관성을 유지할 수 있습니다.\n\n## 브라우저 캐싱:\n\n외부 스타일시트는 브라우저에 의해 캐싱될 수 있어, 스타일시트를 한 번로드한 후에는 이후 페이지로드에 재사용할 수 있어 성능을 획기적으로 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 인라인 스타일과 CSS의 조합에 대한 최상의 방법\n\n인라인 스타일이 CSS보다 빠른지에 대한 일반적인 해답은 없지만, 일반적으로 두 가지 방법을 결합하여 각 방법의 강점을 활용하는 것이 최상의 방법입니다. 다음은 몇 가지 최상의 방법입니다:\n\n## 1. 중요한 CSS:\n\n렌더링 차단 문제를 줄이기 위해 인쇄 스타일을 사용하여 필요한 중요한 CSS를 사용하여 위에서부터 페이지 콘텐츠를 로드합니다. 그런 다음 페이지의 나머지 부분을위한 외부 CSS를 로드하세요.\n\n<div class=\"content-ad\"></div>\n\n## 2. 과도한 인라인 스타일 피하기:\n\n너무 많은 인라인 스타일을 사용하지 않도록 주의하세요. 이는 HTML 크기와 복잡성을 증가시킬 수 있습니다. 인라인 스타일은 성능이나 조직적 이점이 명확한 경우에만 사용하세요.\n\n## 3. 재사용 가능성을 위해 외부 스타일시트 사용하기:\n\n비 비상요 속성과 재사용 가능한 스타일에 대해 외부 스타일시트를 선호하세요. 이렇게 하면 HTML을 깔끔하게 유지하고 스타일을 중앙 집중화하여 관리와 유지보수가 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n# 4. CSS 전달 최적화:\n\n- 최소화 및 압축: CSS 파일을 최소화하고 압축하여 로드 시간을 줄입니다.\n- HTTP/2: HTTP/2를 활용하여 여러 CSS 파일을 로드하는 효율을 향상시킵니다.\n- 사전로드 및 사전요청: `link rel=”preload”` 또는 `link rel=”prefetch”`를 사용하여 중요한 CSS 파일을 우선적으로 처리합니다.\n\n# 5. JavaScript를 활용한 동적 스타일링:\n\n동적으로 스타일을 적용할 때는 인라인 스타일보다 클래스 토글링을 선호합니다. 이렇게 하면 CSS의 힘을 활용하면서 HTML을 더 깔끔하게 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 웹 애플리케이션의 성능 영향을 더 잘 이해하기 위해,\n// 가상의 웹 애플리케이션 사례 연구를 고려해 보겠습니다.\n\n# 시나리오:\n```\n\n<div class=\"content-ad\"></div>\n\n뉴스 웹사이트는 사용자 기호에 따라 동적으로 생성된 테마를 기반으로 기사를 표시해야 합니다. 이 테마에는 다양한 색상 구성표와 글꼴 스타일이 포함됩니다.\n\n# 방법 1: 인라인 스타일\n\n- 장점: 사용자 기호에 따라 스타일을 빠르게 적용할 수 있습니다.\n- 단점: HTML 크기 증가, 유지 관리가 줄어들고 기사 수가 많아질수록 성능 저하 가능성이 있습니다.\n\n# 방법 2: CSS 스타일시트\n\n<div class=\"content-ad\"></div>\n\n- 장점: 스타일의 중앙 집중 관리, 캐싱을 통한 성능 향상, HTML 크기 감소.\n- 단점: 사용자 환경에 따라 올바른 클래스를 적용하기 위해 추가 로직이 필요합니다.\n\n# 해결책:\n\n화면 상단 콘텐츠에 대한 중요한 스타일은 인라인으로 적용하여 빠른 화면 표시를 보장하고, 나머지 스타일은 외부 CSS를 통해 관리하는 혼합 접근 방식을 사용합니다. 다음과 같이 달성할 수 있습니다:\n\n## 인라인 중요 스타일:\n\n<div class=\"content-ad\"></div>\n\n\n```css\n/* 뷰포트 상단 컨텐츠를 위한 필수 스타일 */\n.header {\n  font-family: Arial, sans-serif;\n  color: #333;\n}\n```\n\n## 스타일된 테마용 외부 CSS:\n\n```html\n<link rel=\"stylesheet\" href=\"themes.css\">\n<script>\n  // 올바른 테마 클래스 적용을 위한 JavaScript\n  function applyTheme(theme) {\n    document.body.classList.add(theme);\n  }\n\n  // 예시: 사용자 선호도 적용\n  applyTheme('dark-theme');\n</script>\n```\n\n## Themes.css:\n\n\n<div class=\"content-ad\"></div>\n\n```js\ndark-theme {\n  background-color: #121212;\n  color: #ffffff;\n}\n\nlight-theme {\n  background-color: #ffffff;\n  color: #000000;\n}\n```\n\n# 결론\n\n인라인 스타일이 CSS 스타일시트보다 빠른지에 대한 논쟁은 프로젝트의 크기와 복잡성, 고려되는 특정 성능 측정 항목, 그리고 웹 응용 프로그램의 전체 구조 등 다양한 요소에 달려있습니다.\n\n일부 소스에 따르면, 특정 시나리오에서 인라인 스타일은 CSS 스타일시트보다 최대 2.4배 빠를 수 있으며 특히 중요한 내용 또는 화면 상단에 있는 내용을 렌더링할 때 이점이 있을 수 있습니다. 이 성능 향상은 스타일을 즉시 적용하면서 추가 HTTP 요청이나 외부 파일의 구문 분석 없이 가능하기 때문에 발생할 수 있습니다.```\n\n<div class=\"content-ad\"></div>\n\n인라인 스타일은 핵심 렌더링 경로 및 동적 스타일링에 대한 성능 이점을 제공할 수 있지만, 사용량이 증가함에 따라 처리하기 번거로워지고 유지 관리하기 어려워질 수 있습니다. 반면 CSS 스타일시트는 더 나은 확장성과 유지 관리성을 제공하며 여러 페이지 로드에서 성능을 향상시키기 위해 브라우저 캐싱을 활용할 수 있습니다.\n\n최종적으로, 인라인 스타일과 CSS 스타일시트의 장점을 모두 활용하는 균형 잡힌 접근 방식이 현대 웹 애플리케이션의 성능과 유지 관리성을 최대화할 것입니다. 각 방법을 언제 어떻게 사용할지 신중히 고려함으로써 개발자는 빠르고 유지 관리 가능한 웹 애플리케이션을 만들 수 있습니다.\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n<div class=\"content-ad\"></div>\n\n- 작가에게 박수를 보내 주시고 팔로우 부탁드려요! 👏\n- 저희를 팔로우해주세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠에 대한 강요를 받는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences_0.png"},"coverImage":"/assets/img/2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences_0.png","tag":["Tech"],"readingTime":7},{"title":"사용자 경험(UX) 크로스 문서 뷰 전환 하는 방법","description":"","date":"2024-05-27 19:05","slug":"2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions","content":"\n\n## 파워포인트 슬라이드쇼처럼 웹사이트를 만드는 방법\n\n![Image](/assets/img/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions_0.png)\n\n웹사이트의 링크를 클릭하면서 왜 PowerPoint 슬라이드쇼처럼 부드럽지 않을까 궁금했던 적이 있나요?\n\n표준적인 불편한 페이지 로딩에 짜증이 나시나요?\n\n<div class=\"content-ad\"></div>\n\n다행히도 매우 간단한 해결책이 있습니다. CSS와 JavaScript에 대한 약간의 경험만 있으면 사용자 정의 전환을 시작할 수 있습니다.\n\n이 문서에서는 다음 프로젝트에서 이를 사용해야 하는 이유를 설명하고, 웹사이트에 구현하는 방법을 보여드릴 것입니다.\n\n# 왜 Cross-Document View 전환을 사용해야 하는가?\n\n- 웹사이트를 사용할 때 사용자 경험과 만족도가 향상되고 개선됩니다.\n- 이는 웹사이트의 일관성을 높이고, 내용에 대한 이해를 증진시켜줍니다.\n- 특수 효과를 위해 일반적으로 외부 라이브러리 및 프레임워크를 사용하지만, 이는 성능 손실로 이어질 수 있습니다. 반면 내부 방법은 더 빠르고 효과적인 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 문서 간 보기 전환 구현\n\n문서 간 보기 전환을 구현하려면 HTML, CSS, 그리고 JavaScript를 조합하여 사용해야 합니다.\n\n아래에서는 이러한 전환을 설정하고 구현하는 데 필요한 단계를 안내해 드리겠습니다.\n\n## 기본 설정\n\n<div class=\"content-ad\"></div>\n\n다중 페이지 애플리케이션을 위한 기본적인 HTML 구조부터 시작해보겠습니다. 두 개의 간단한 HTML 페이지를 생성해보겠습니다.\n\n페이지 1: index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>페이지 1</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <h1>페이지 1</h1>\n        <a href=\"page2.html\" class=\"transition-link\">페이지 2로 이동</a>\n    </div>\n    <script src=\"transition.js\"></script>\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>페이지 2</title>\n    <link rel=\"stylesheet\" href=\"styles.css\">\n</head>\n<body>\n    <div class=\"container\">\n        <h1>페이지 2</h1>\n        <a href=\"index.html\" class=\"transition-link\">페이지 1로 이동</a>\n    </div>\n    <script src=\"transition.js\"></script>\n</body>\n</html>\n```\n\n## 트랜지션을 위한 CSS\n\n트랜지션을 위한 CSS 스타일을 정의합니다. 여기서는 간단한 페이드 인 및 페이드 아웃 효과를 사용할 것입니다.\n\n```js\n/* styles.css */\nbody {\n    margin: 0;\n    font-family: Arial, sans-serif;\n}\n\n.container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    height: 100vh;\n    transition: opacity 0.5s ease;\n}\n\n.hidden {\n    opacity: 0;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 페이지 전환 처리를 위한 JavaScript\n\n페이지 간 전환을 처리하는 JavaScript 로직을 구현하세요. 이는 링크에 이벤트 리스너를 추가하고 전환 효과를 관리하는 것을 포함합니다.\n\n```js\n// transition.js\ndocument.addEventListener('DOMContentLoaded', () => {\n    const links = document.querySelectorAll('.transition-link');\n\n    links.forEach(link => {\n        link.addEventListener('click', event => {\n            event.preventDefault();\n            const targetUrl = event.target.href;\n\n            document.body.classList.add('hidden');\n\n            setTimeout(() => {\n                window.location.href = targetUrl;\n            }, 500);\n        });\n    });\n});\n\nwindow.addEventListener('pageshow', () => {\n    document.body.classList.remove('hidden');\n});\n```\n\n# 모두 함께 적용하기\n\n<div class=\"content-ad\"></div>\n\nindex.html과 page2.html 모두 CSS와 JavaScript 파일이 올바르게 연결되어 있는지 확인해주세요. 사용자가 다른 페이지로 이동하려는 링크를 클릭하면 현재 페이지가 페이드아웃되고 새 페이지가 페이드인되어 부드러운 전환 효과가 만들어집니다.\n\n![다음 수준의 사용자 경험을 위한 문서 간 뷰 전환](/assets/img/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions_1.png)\n\n## 고급 전환\n\n기본 페이드 전환은 좋은 시작점이지만, 슬라이드, 스케일 또는 사용자 정의 애니메이션과 같은 더 복잡한 전환으로 창의적으로 구성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 슬라이드 전환의 예시입니다:\n\n```css\n/* styles.css */\n.container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    height: 100vh;\n    transition: transform 0.5s ease, opacity 0.5s ease;\n}\n\n.hidden {\n    opacity: 0;\n    transform: translateX(-100%);\n}\n```\n\n또한 다양한 탐색 컨텍스트에 따른 다양한 종류의 전환을 처리하기 위해 더 복잡한 JavaScript를 추가할 수도 있습니다.\n\n더 많은 정보를 위해 이 웹사이트도 확인해보세요: [https://developer.chrome.com/docs/web-platform/view-transitions/cross-document](https://developer.chrome.com/docs/web-platform/view-transitions/cross-document)\n\n<div class=\"content-ad\"></div>\n\n# 최종 인사\n\n문서 간 보기 전환이란 기능은 멀티페이지 애플리케이션의 사용자 경험을 향상시키는 강력한 기능입니다.\n\n페이지간 부드럽고 일관된 전환을 구현함으로써, 웹 애플리케이션을 더 현대적이고 반응성있게 느끼게 할 수 있습니다.\n\n서로 다른 종류의 전환을 실험하여 애플리케이션 디자인과 사용자 경험 목표에 가장 적합한 것을 찾아보세요.\n\n<div class=\"content-ad\"></div>\n\n행운을 빕니다!","ogImage":{"url":"/assets/img/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions_0.png"},"coverImage":"/assets/img/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions_0.png","tag":["Tech"],"readingTime":5},{"title":"웹사이트를 TailwindCSS로 만들어야하는 이유 ","description":"","date":"2024-05-27 19:04","slug":"2024-05-27-Tailwindischangingthelandscapeofuserexperience","content":"\n\n다르실 자댭, Think In Bytes의 풀스택 엔지니어가 말하길, Tailwind는 개발자들 사이에서 널리 사용되어 동적이고 매력적이며 견고한 프런트엔드 애플리케이션을 구축하는 데 인기를 끌고 있다.\n\n![이미지](/assets/img/2024-05-27-Tailwindischangingthelandscapeofuserexperience_0.png)\n\n## 소개\n\nThink In Bytes에서는 Tailwind CSS를 사용하여 고객을 위한 동적이고 인터랙티브한 웹 인터페이스를 만들기 시작했습니다. 이 블로그는 Tailwind가 웹 개발을 혁신하고 있는 방식에 대해 탐구하며, 이에 대한 모든 기본적인 질문에 대답하고 여러분의 팀 또는 프로젝트에 적합한지 결정하는 데 도움이 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n우리 조직은 주로 Next.js를 사용하여 제품을 개발하는데, 이는 Tailwind와 시원하게 통합됩니다. 이를 통해 우리는 프로젝트 전반에 걸쳐 Tailwind를 널리 사용할 수 있게 되었습니다. 그러나 이는 Next.js에만 국한된 것이 아닙니다; 우리는 Angular 및 React 앱에도 성공적으로 통합시켰습니다. 이 다양성은 Tailwind의 유연성을 보여줍니다. 한 번 마스터하면 거의 모든 프레임워크에 구현할 수 있습니다. 이 프레임워크에 대해 더 알고 싶다면, Tailwind가 빛나게 만드는 것에 대해 자세히 알아보겠습니다.\n\n## Tailwind란?\n\nTailwind는 전통적인 방법보다 더 빠르게 웹 사이트를 스타일링하는 데 도움이 되는 현대적인 CSS 프레임워크입니다. 부트스트랩과 비슷하게, Tailwind는 인라인 스타일처럼 보이는 사전 구축 클래스를 제공하지만 실제로는 인라인 스타일이 아닙니다.\n\nTailwind는 반응형 디자인을 크게 향상시키는 모바일 우선 접근 방식을 채택했습니다. 이는 CSS를 더 빠르고 효율적이며 더 깨끗하게 작성하는 것을 단순화합니다. 예를 들어:\n\n<div class=\"content-ad\"></div>\n\n```js\n# Hello world!\n\nIn this snippet, we use three classes:\n\n- text-3xl: sets the font size to 3xl.\n- font-bold: makes the text bold.\n- underline: adds an underline.\n\nThis is more straightforward than traditional CSS, where you need to define and name each class, adding extra steps to the process. Tailwind strikes a balance between the customization of vanilla CSS and the speed of frameworks like Bootstrap.\n```\n\n<div class=\"content-ad\"></div>\n\n\n![테일윈드 로고](/assets/img/2024-05-27-Tailwindischangingthelandscapeofuserexperience_1.png)\n\n## 왜 테일윈드를 사용해야 할까요?\n\n- 개발 속도 향상: 테일윈드를 사용하여 프로젝트 일정을 크게 단축했습니다. 개발자들이 쉽게 습득할 수 있어 CSS와 HTML 사이의 격차를 줄이고 꾸준한 소통 필요성을 제거했습니다.\n- 독특한 디자인: 종종 비슷해 보이는 부트스트랩 기반 사이트와는 달리, 테일윈드는 고유하고 맞춤형 디자인을 가능하게 하여 귀하의 웹사이트를 돋보이게 만들어줍니다.\n- 고급 기능: 테일윈드에는 호버 상태, 비활성 상태 및 다크 모드와 같은 클래스가 포함되어 있어 사용자 선호도에 자동으로 적응할 수 있습니다. 예를 들어 사용자가 다크 모드로 기기를 전환하는 경우가 있습니다.\n\n아래는 다크 모드를 고려한 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n\n<div class=\"bg-white dark:bg-slate-800 rounded-lg px-6 py-8 ring-1\">\n  <div>test</div>\n  <h3 class=\"text-slate-900 dark:text-white\">some text</h3>\n</div>\n\n\n\n<!-- dark:text-white will be applied to dark mode only, for light mode it will take \ntext-slate-900 -->\n\n\n- Enhanced Workflow: Tailwind를 사용하기 전에 일반 CSS에 의존했던 개발자로서, 저는 Tailwind가 효율성을 20~30% 향상시켰다는 사실을 발견했습니다. 반응형 디자인을 간소화하여 최근 Angular과 Tailwind를 사용하여 개발한 학교 정적 웹사이트 프로젝트 등에 도움이 되었습니다.\n\nTailwind 사용 방법\n\n\n<div class=\"content-ad\"></div>\n\n설치 지침은 다음을 방문하십시오: Tailwind CSS 설치\n\n자바스크립트 프레임워크에서 Tailwind는 tailwind.config.js에서 글로벌 스타일을 정의할 수 있도록 해주며, 다음과 같은 클래스를 사용하여 반응형 디자인을 최적화할 수 있습니다:\n\n```js\n<img class=\"w-16 md:w-32 lg:w-48\" src=\"...\">\n```\n\n이 모바일 우선 접근 방식은 디바이스 크기에 따라 적절한 스타일이 적용되도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n테일윈드 사용 시기\n\n- 경험이 풍부한 CSS 사용자에게: CSS에 대한 견고한 이해가 있는 경우 테일윈드는 생산성을 향상시킬 수 있습니다.\n- 중대형 프로젝트에 적합: 개발 속도가 중요한 큰 규모의 프로젝트에는 특히 효과적입니다.\n- Next.js를 사용할 때: Next.js는 테일윈드를 내장 지원하므로 설정이 매우 간편합니다.\n\n테일윈드 사용하지 말아야 할 때\n\n- CSS 초보자에게: CSS에 익숙하지 않다면 테일윈드로 시작하는 것이 어려울 수 있습니다.\n- 매우 사용자 정의된 디자인에: 프로젝트가 복잡한 애니메이션이나 독특한 효과를 요구하는 경우 전통적인 CSS가 더 적합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n테일윈드의 장단점\n\n장점:\n\n- 시간을 절약하고 노력을 줄입니다.\n- 부트스트랩보다 더 많은 유연성을 제공합니다.\n- 개발자 커뮤니티 내에서 강력한 지원을 제공합니다.\n- 모바일 우선 접근 방식을 채택하여 인터넷 사용량이 모바일 기기로 이동함에 중요합니다.\n\n단점:\n\n<div class=\"content-ad\"></div>\n\n- 복잡한 디자인에 대해 베니야 CSS보다는 덜 유연합니다.\n- 설정 및 구성 중에 특히 초보자에게 압도적일 수 있습니다.\n\n테일윈드의 미래\n\n테일윈드는 매일 더 많은 개발자가 채택하면서 인기를 누리고 있습니다. Next.js와 같은 플랫폼에 통합되면 사용량이 더욱 증가할 것으로 예상됩니다. 테일윈드를 사용하는 주목할만한 기업으로는 OpenAI, Netlify, Shopify, Vercel, 1Password, Brave 등이 있으며, 기술 산업에서의 영향력이 계속 성장하고 있음을 강조합니다.\n\n블로그 크레딧: Think In Bytes의 Fullstack 개발자 Darshil Jadav.","ogImage":{"url":"/assets/img/2024-05-27-Tailwindischangingthelandscapeofuserexperience_0.png"},"coverImage":"/assets/img/2024-05-27-Tailwindischangingthelandscapeofuserexperience_0.png","tag":["Tech"],"readingTime":4},{"title":"프론트엔드 주간 뉴스 - 2024년 5월 20일","description":"","date":"2024-05-27 19:03","slug":"2024-05-27-FrontendWeeklyDigest3642026May2024","content":"\n\n\n![Web-development](/assets/img/2024-05-27-FrontendWeeklyDigest3642026May2024_0.png)\n\n- Web-development\n\n  - Switching It Up With HTML’s Latest Control\n  - How Spotify used the Picture-in-Picture API to build the Spotify Miniplayer\n  - When should we use components and when should we just use HTML?\n  - Understand errors and warnings better with Gemini\n  - Animating the Dialog Element\n\n- Performance\n  - Visualize Your Website’s Render-Blocking Scripts\n  - Quantifying the Impact of Styled Components on Server Response Times\n  - How Do Chrome Extensions Impact Website Performance In 2024?\n  - Comprehensive guide to JavaScript performance analysis using Chrome DevTools\n\n\n<div class=\"content-ad\"></div>\n\n# CSS\n\n- Pigment CSS 소개: CSS-in-JS의 차세대\n- 현대적인 CSS 레이아웃: 프레임워크가 필요하지 않을 수도 있습니다\n- 적합성 대 가독성: CSS로 텍스트 색상 생성하기\n- 우리는 이제 컨테이너 쿼리를 가지고 있지만, 실제로 사용하고 있을까요?\n- contrast-color()은 좋은 것입니다만, 잘못된 레이어에서 문제를 해결하고 있기도 합니다\n- 헤드라인에 text-emphasis CSS 속성을 사용해야 할까요?\n- Bulma CSS 도입 안내: 개요, 예시 및 대안\n- Velvette로 CSS 뷰 전환을 더욱 향상시키세요\n\n# JavaScript\n\n- JavaScript 프레임워크의 새로운 소식 (2024년 5월)\n- 최신 JavaScript 기술 5가지\n- 웹소켓 대안: Firestore를 사용하여 실시간 이벤트를 듣는 방법\n\n<div class=\"content-ad\"></div>\n\n- React\n  - React Conf 2024 Recap\n  - React Conf 2024 Highlights\n  - Auto Generate Open Graph Images in NextJS\n  - How to Style React Components\n  - Restyle — Zero Config CSS for React\n  - React Compiler With React 18\n  - Merging Remix and React Router\n  - Using Mountaineer to develop a React app with Python\n- Vue\n  - Building Real-Time Applications with Vue.js and WebSockets\n  - Building CatGPT: A Vue 3 and Vuetify Guide for Cat Image Lovers\n- Angular\n  - Angular v18 is now available!\n  - Saying Goodbye to Zone.js: What’s New in Angular 18?\n  - Updating to Angular Material 18: Keeping Support for Material 2 and Adding Support for Material 3\n  - Debugging techniques — Angular DevTools\n  - Debugging techniques — Chrome DevTools\n  - Angular Tutorial: Using @HostBinding with Signals","ogImage":{"url":"/assets/img/2024-05-27-FrontendWeeklyDigest3642026May2024_0.png"},"coverImage":"/assets/img/2024-05-27-FrontendWeeklyDigest3642026May2024_0.png","tag":["Tech"],"readingTime":2},{"title":"앵귤러에서 마이크로 프론트엔드 애플리케이션 만드는 방법","description":"","date":"2024-05-27 19:02","slug":"2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1","content":"\n\n<img src=\"/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png\" />\n\n# 안내 내용\n\n이 안내서에서 다룰 내용은 다음과 같습니다:\n\n- Angular에서 Micro-Frontend 애플리케이션 소개\n- Angular에서 간단한 호스트 및 Micro-Frontend 애플리케이션 생성\n\n<div class=\"content-ad\"></div>\n\n# 소개\n\n크고 화려한 생일 파티를 준비한다고 상상해보세요. 엄청나게 큰 케이크를 굽고, 장식을 꾸미고, 게임을 설치하고, 음식을 준비해야 합니다. 이 모든 것을 혼자 다 처리하려고 하면 압도될 수 있습니다. 하지만 친구들에게 작업을 분담할 수 있다면 어떨까요? 한 명은 케이크를 굽고, 다른 한 명은 장식을 하고, 또 다른 한 명은 게임을 설치하고, 한 명은 음식을 책임지죠. 모두가 독립적으로 일하지만 모여서 멋진 파티를 만들어냅니다.\n\n웹 애플리케이션이 커지고 복잡해지면 단일 대규모 코드베이스를 유지하는 것이 어려워질 수 있습니다. 이러한 문제를 해결하기 위해 마이크로 프론트엔드와 모듈 연합이라는 개념이 소개되었습니다. 이러한 개념을 활용하면 개발자들이 모듈식, 확장 가능하며 유지보수가 쉬운 웹 애플리케이션을 만들 수 있습니다. 이 기사에서는 마이크로 프론트엔드의 기본 개념, Webpack 5의 기능, 그리고 Angular 프로젝트에서 모듈 연합을 구현하는 방법에 대해 자세히 살펴보겠습니다.\n\n# 마이크로 프론트엔드란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n마이크로 프론트엔드 아키텍처를 생각해보면 번화한 쇼핑몰의 푸드코트와 비슷합니다. 각 음식점(마이크로 프론트엔드)은 독립적으로 운영되어 독특한 요리를 제공합니다. 피자 전문점, 스시 전문점, 햄버거 전문점 등이 있습니다. 각 음식점은 독립적으로 관리되고 운영되며 재고가 구비되지만, 함께하면 쇼핑몰 방문객들에게 즐거운 다이닝 경험을 선사합니다.\n\n마이크로 프론트엔드는 이 개념을 웹 애플리케이션에 적용한 것입니다. 큰 웹 애플리케이션을 더 작고, 준 독립적인 \"마이크로\" 애플리케이션으로 분할합니다. 각 마이크로 프론트엔드는 별도로 개발, 배포, 유지보수할 수 있습니다. 이 접근 방식을 통해 서로 다른 팀이 서로 다른 프론트엔드 부분에 작업을 할 수 있으며, 서로 간섭하지 않게 되어 확장성, 유지보수성이 향상되며 동일한 애플리케이션 내에서 다른 기술을 사용할 수 있습니다.\n\n# 웹팩 5이란?\n\n캠핑용품을 준비하는 것과 같습니다. 텐트, 음식, 옷, 캠핑 장비가 필요합니다. 이 모든 것을 하나의 큰 가방에 랜덤하게 넣는 대신, 특정 카테고리에 지정된 여러 작은 가방을 사용합니다. 이렇게 하면 물건을 싸고, 찾고, 사용하는 것이 훨씬 쉽고 효율적입니다.\n\n<div class=\"content-ad\"></div>\n\n웹팩 5은 자바스크립트 애플리케이션을 위한 궁극적인 패킹 시스템 같아요. 자바스크립트 파일, 스타일, 이미지, 그리고 다른 에셋들을 효율적으로 정리하고 패킹하는 모듈 번들러에요. 아래는 웹팩 5의 주요 기능들이에요:\n\n- 모듈 연맹: 다른 캠퍼들 사이에서 공급을 공유하는 것처럼, 모듈 연맹은 여러 웹팩 빌드가 함께 작동하도록 하여, 애플리케이션 간의 코드 공유를 가능하게 함.\n- 개선된 캐싱: 미래의 패킹을 빠르게 만들어주는, 잊지 않게 해주는 매우 체계적인 체크리스트와 같은 것으로 생각해봐요.\n- Tree Shaking: 가방에서 불필요한 물건을 제거하여 가벼우고 효율적으로 만드는 것과 같아요.\n- 에셋 모듈: 에셋 파일(예: 이미지와 폰트)을 다루기 쉽게 해주어 모든 것이 제 위치에 있도록 해요.\n- 웹 어셈블리 지원: WebAssembly에 대한 향상된 지원으로, 여러 가지 고급 캠핑 가전들을 위한 특별한 칸나 있는 것처럼 생각해봐요.\n\n# 독립형 컴포넌트란 무엇인가요?\n\n레고 블럭을 사용해 건물을 지을 때, 각각의 레고 블럭은 독립적인 부분으로, 독립적으로 사용하거나 다른 블럭들과 결합하여 더 큰 것을 만들 수 있어요. 각 블럭이 어느 세트에서 왔는지 고민할 필요는 없어요; 어디에 놓든 그대로 작동해요.\n\n<div class=\"content-ad\"></div>\n\nAngular에서 독립형 컴포넌트는 다양하고 다재다능한 레고 블록과 같습니다. 이들은 특정 NgModule에 바인딩되지 않은 Angular 컴포넌트로, NgModule 선언 내에서 명시적으로 가져오기 및 내보내기가 필요 없이 응용 프로그램의 여러 부분에서 사용할 수 있습니다.\n\n- 높은 재사용성: 레고 블록처럼 독립형 컴포넌트는 서로 다른 모듈 및 프로젝트에서 사용할 수 있습니다.\n- 관계 단순화: 복잡한 가져오기/내보내기 관계가 제거되어 컴포넌트 계층 구조가 단순화됩니다.\n- 지연 로드 모듈과 함께 작동: 독립형 컴포넌트는 지연 로드된 모듈과 원활하게 통합됩니다.\n- 제3자 라이브러리 통합: NgModule 선언을 수정하지 않고 제3자 라이브러리와 함께 사용할 수 있습니다.\n- 복잡성 감소: 의존성 관리가 쉬워지며, 마치 레고 모형을 조직하는 것과 같습니다.\n- 더 깔끔한 코드 분리 유도: 코드베이스가 깔끔하고 모듈식으로 유지되어, 마치 레고 모형의 구분된 섹션을 구성하는 것과 같습니다.\n- 더 이동 가능: 독립형 컴포넌트는 이동, 리팩토링 또는 이주가 쉽습니다. 마치 레고 조각을 재배열하는 것과 같습니다.\n\n독서해 주셔서 감사합니다. 즐거운 코딩되세요! :)\n\n# 관련 링크:\n\n<div class=\"content-ad\"></div>\n\n- **Angular에서 모듈 연합 및 마이크로 프론트엔드 애플리케이션 가이드 - 파트 1**  \n- **Angular에서 모듈 연합 및 마이크로 프론트엔드 애플리케이션 가이드 - 파트 2**  ","ogImage":{"url":"/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png"},"coverImage":"/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png","tag":["Tech"],"readingTime":3}],"page":"2","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}