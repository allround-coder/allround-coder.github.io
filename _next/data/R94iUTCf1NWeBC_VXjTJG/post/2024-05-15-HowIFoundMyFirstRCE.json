{"pageProps":{"post":{"title":"첫 번째 RCE를 발견한 방법","description":"","date":"2024-05-15 11:46","slug":"2024-05-15-HowIFoundMyFirstRCE","content":"\n\n안녕하세요 여러분! 이 글에서는 제 첫 RCE 경험에 대해 이야기하려고 해요. 제가 Apache ActiveMQ에서 발생한 CVE-2023-46604로 발생한 사건이죠. 전문적인 버그 헌터를 위한 새로운 정보를 제공하는 것보다는 어떻게 발견했는지에 더 초점을 맞출 거에요.\n\n저의 탐색 과정에서, 매주 서브도메인 목록을 업데이트하고 3일마다(하루에 한 번 하는 것이 더 좋겠지만) 열린 포트를 스캔했어요. 서브도메인 열람을 위해 Subfinder와 Amass 같은 도구를 사용했어요.\n\n```js\nsubfinder -dL domains.txt -o subdomains.txt\n#그리고 서브도메인의 서브도메인\nsubfinder -dL subdomains.txt -o more-subdomains.txt\n\n#Amass 사용\namass enum -passive -norecursive -noalts -df domains.txt -o subs.txt\n#그리고 서브도메인의 서브도메인\namass enum -passive -norecursive -noalts -df subs.txt -o more-subs.txt\n```\n\n\n\n아래와 같이 하세요:\n\n```bash\ncat more-subdomains.txt subdomains.txt subs.txt more-subs.txt | sort -u > targets.txt\n```\n\n이후에는 몇 가지 경우에는 많은 수의 서브도메인이 생기기도 하는데, 때로는 5천개 이상이 될 때도 있습니다. DNSx를 사용하여 서브도메인을 확인하는 간단한 스크립트를 만들어 15개씩 그룹으로 나누었습니다. 그런 다음, 백그라운드에서 계속 실행하기 위해 nohup을 사용하여 Naabu를 실행했습니다.\n\n사용한 스크립트\n\n\n\n```sh\n#!/bin/bash\n\nif [ $# -eq 0 ]; then\n    echo \"사용법: $0 <file>\"\n    exit 1\nfi\n\ncat $1 | dnsx -o $1_ok.txt\n\nsplit -l 15 $1_ok.txt 15_file_\n\nfor file in 15_file_*; do\n    nohup naabu -list \"$file\" -p - -o \"${file}.out\"&\ndone\n```\n\n그리고\n\n```sh\ncat 15*out | sort -u > ports.out \n```\n\n많은 시간 동안 그 목록을 수동으로 확인했습니다. 저는 허니팟일 가능성이 있는 호스트를 필터링했고, 때로는 Naabu가 신뢰할 수 없는 결과를 제공했습니다.```\n\n\n\n그리고 그 이후에, 3부터 10 사이의 열린 포트를 가진 호스트를 수동으로 확인했어요. 이상한 열린 포트를 발견했을 때, Nmap을 이용해서 어떤 서비스가 작동 중인지 확인했어요.\n\n한 사례에서 bamboo.target.com이라는 호스트가 있었고, 포트 54663이 열려 있다는 것을 알았어요.\n\n-sSCV 플래그와 함께 Nmap을 사용했을 때, Apache ActiveMQ가 실행 중이라는 것을 확인했고, 최신 버전의 CVE-2023-46604가 있었어요.\n\n그런 다음 해당 취약점을 쉽게 적용했는데, 바로 작동했어요. 상세 보고서를 작성했고, 이는 현명한 선택이었어요. 트리저와 보안팀에 필요한 모든 정보를 제공하는 것은 자신의 노력에 대한 좋은 보상을 가져다주곤 해요.\n\n\n\n아래는 제 결과에 대한 이미지입니다\n\n![이미지1](/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png)\n\n그 결과에 대한 이미지도 있습니다\n\n![이미지2](/assets/img/2024-05-15-HowIFoundMyFirstRCE_1.png)\n\n그게 다야! 시간 내어 주셔서 감사합니다. LinkedIn이나 Twitter도 부담 갖지 마시고 방문해주세요 — 거기서 친구를 찾고 있어요!\n\n\n\n# 찬양합니다. 주님, 우리에게 깨닫는 것은 주님의 가르침밖에 없습니다. 우리의 마지막 기도는 모든 찬양을 받으시는 세계의 주님 하나님께로부터 오는 것입니다.","ogImage":{"url":"/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png"},"coverImage":"/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png","tag":["Tech"],"readingTime":2},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\",\n    h1: \"h1\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"안녕하세요 여러분! 이 글에서는 제 첫 RCE 경험에 대해 이야기하려고 해요. 제가 Apache ActiveMQ에서 발생한 CVE-2023-46604로 발생한 사건이죠. 전문적인 버그 헌터를 위한 새로운 정보를 제공하는 것보다는 어떻게 발견했는지에 더 초점을 맞출 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저의 탐색 과정에서, 매주 서브도메인 목록을 업데이트하고 3일마다(하루에 한 번 하는 것이 더 좋겠지만) 열린 포트를 스캔했어요. 서브도메인 열람을 위해 Subfinder와 Amass 같은 도구를 사용했어요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"subfinder -dL domains.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"txt\"\n        }), \" -o subdomains.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"txt\"\n        }), \"\\n#그리고 서브도메인의 서브도메인\\nsubfinder -dL subdomains.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"txt\"\n        }), \" -o more-subdomains.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"txt\"\n        }), \"\\n\\n#\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Amass\"\n        }), \" 사용\\namass enum -passive -norecursive -noalts -df domains.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"txt\"\n        }), \" -o subs.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"txt\"\n        }), \"\\n#그리고 서브도메인의 서브도메인\\namass enum -passive -norecursive -noalts -df subs.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"txt\"\n        }), \" -o more-subs.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"txt\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래와 같이 하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"cat\"\n        }), \" more-subdomains.txt subdomains.txt subs.txt more-subs.txt | \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"sort\"\n        }), \" -u > targets.txt\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이후에는 몇 가지 경우에는 많은 수의 서브도메인이 생기기도 하는데, 때로는 5천개 이상이 될 때도 있습니다. DNSx를 사용하여 서브도메인을 확인하는 간단한 스크립트를 만들어 15개씩 그룹으로 나누었습니다. 그런 다음, 백그라운드에서 계속 실행하기 위해 nohup을 사용하여 Naabu를 실행했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용한 스크립트\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-sh\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#!/bin/bash\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" [ \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"$#\"\n        }), \" -eq 0 ]; \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"then\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"echo\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"사용법: \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$0\"\n          }), \" <file>\\\"\"]\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"exit\"\n        }), \" 1\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fi\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"cat\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"$1\"\n        }), \" | dnsx -o \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"$1_ok\"\n        }), \".txt\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"split\"\n        }), \" -l 15 \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"$1_ok\"\n        }), \".txt 15_file_\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" file \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" 15_file_*; \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"nohup\"\n        }), \" naabu -list \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$file\"\n          }), \"\\\"\"]\n        }), \" -p - -o \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"${file}\"\n          }), \".out\\\"\"]\n        }), \"&\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"done\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-sh\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"cat\"\n        }), \" 15*out | \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"sort\"\n        }), \" -u > ports.out \\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"많은 시간 동안 그 목록을 수동으로 확인했습니다. 저는 허니팟일 가능성이 있는 호스트를 필터링했고, 때로는 Naabu가 신뢰할 수 없는 결과를 제공했습니다.```\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 그 이후에, 3부터 10 사이의 열린 포트를 가진 호스트를 수동으로 확인했어요. 이상한 열린 포트를 발견했을 때, Nmap을 이용해서 어떤 서비스가 작동 중인지 확인했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한 사례에서 bamboo.target.com이라는 호스트가 있었고, 포트 54663이 열려 있다는 것을 알았어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"-sSCV 플래그와 함께 Nmap을 사용했을 때, Apache ActiveMQ가 실행 중이라는 것을 확인했고, 최신 버전의 CVE-2023-46604가 있었어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 해당 취약점을 쉽게 적용했는데, 바로 작동했어요. 상세 보고서를 작성했고, 이는 현명한 선택이었어요. 트리저와 보안팀에 필요한 모든 정보를 제공하는 것은 자신의 노력에 대한 좋은 보상을 가져다주곤 해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 제 결과에 대한 이미지입니다\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png\",\n        alt: \"이미지1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그 결과에 대한 이미지도 있습니다\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-HowIFoundMyFirstRCE_1.png\",\n        alt: \"이미지2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그게 다야! 시간 내어 주셔서 감사합니다. LinkedIn이나 Twitter도 부담 갖지 마시고 방문해주세요 — 거기서 친구를 찾고 있어요!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"찬양합니다. 주님, 우리에게 깨닫는 것은 주님의 가르침밖에 없습니다. 우리의 마지막 기도는 모든 찬양을 받으시는 세계의 주님 하나님께로부터 오는 것입니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}