{"pageProps":{"post":{"title":"QQ Plot 마스터하기 데이터 과학자의 비밀 무기","description":"","date":"2024-05-17 04:00","slug":"2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon","content":"\n\n## QQ Plot을 사용하여 Python | Statsmodel QQ Plot | SciPy QQ Plot\n\n![QQ Plot](/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_0.png)\n\nQuantile-quantile(QQ plot) 그림은 데이터 세트가 특정 확률 분포를 따르는지 또는 두 데이터 샘플이 동일한 모집단에서 왔는지 확인하는 데 사용되는 시각적 방법입니다.\n\nQQ Plot은 데이터가 정규 분포를 따르는지 확인하는 데 사용할 수 있는 그래픽 방법 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\nQQ Plot에서는 이론상 분포의 분위수를 X축에, 데이터의 분위수를 Y축에 그립니다. 이러한 점들이 일직선(y=x)상에 있으면, 데이터가 해당 분포를 따른다는 것을 나타냅니다.\n\n이제 데이터를 가져와 정규 분포와 비교하고, 해당 데이터가 정규 분포에서 나온 것인지 확인해봅시다.\n\n우선, 다양한 라이브러리를 가져오겠습니다.\n\n```js\nimport numpy as np\nimport scipy.stats as stats\nimport pandas as pd\nimport seaborn as sns\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\n```\n\n<div class=\"content-ad\"></div>\n\n이제, 데이터셋을 불러올게요.\n\n```js\ndf1=pd.read_csv(\"https://gist.githubusercontent.com/stoicsapien1/4c0d96aa3b6f99178f5ee071bef23d10/raw/281efb659ff1713ac64b680a9bf44a53ce367e38/data.csv\")\n```\n\nScipy 라이브러리를 사용하여 QQ Plot을 생성해볼까요?\n\n우선 데이터를 표준화한 다음 QQ Plot을 만들어볼 거에요.\n\n<div class=\"content-ad\"></div>\n\n```js\ndf.head(5)\n```\n\n<img src=\"/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_1.png\" />\n\n```js\ndf[\"Z\"]=(df[\"data\"]-df[\"data\"].mean())/df[\"data\"].std()\n```\n\n새롭게 표준화된 데이터 열을 생성했어요. 데이터의 상위 내용은 아래에 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![QQ Plot](/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_2.png)\n\n이제 Scipy 라이브러리를 사용하여 QQ 플롯을 생성해 봅시다.\n\n```python\nstats.probplot(df[\"Z\"], dist=\"norm\", plot=plt)\nplt.show()\n```\n\n![QQ Plot](/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_3.png)\n\n\n<div class=\"content-ad\"></div>\n\nstatsmodels 라이브러리를 사용하여 QQ Plot을 생성할 수도 있습니다. 그럼 시작해 보겠습니다.\n\n```python\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\n\nsm.qqplot(df[\"Z\"], line=\"45\")\nplt.show()\n```\n\n![QQ Plot](/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_4.png)\n\n대부분의 점이 직선(빨간 선) 위에 있는 경우, 데이터가 정규 분포를 따른다고 추정할 수 있습니다. 여기서는 대부분의 데이터가 직선 위에 있는 것을 관찰할 수 있지만, 추가적인 통계 검정을 통해 정규성을 확인해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n깃허브 저장소: EDA-Projects/QQ Plot at main · stoicsapien1/EDA-Projects (github.com)\n\n여러 가지 통계적 검정 방법 중 하나는 콜모고로프-스미르노프 검정입니다. 이에 대해 더 알아보려면 콜모고로프-스미르노프 검정에 대한 내 블로그를 읽어주세요.\n\n안녕히 가세요!","ogImage":{"url":"/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_0.png"},"coverImage":"/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"QQ Plot을 사용하여 Python | Statsmodel QQ Plot | SciPy QQ Plot\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_0.png\",\n        alt: \"QQ Plot\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Quantile-quantile(QQ plot) 그림은 데이터 세트가 특정 확률 분포를 따르는지 또는 두 데이터 샘플이 동일한 모집단에서 왔는지 확인하는 데 사용되는 시각적 방법입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"QQ Plot은 데이터가 정규 분포를 따르는지 확인하는 데 사용할 수 있는 그래픽 방법 중 하나입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"QQ Plot에서는 이론상 분포의 분위수를 X축에, 데이터의 분위수를 Y축에 그립니다. 이러한 점들이 일직선(y=x)상에 있으면, 데이터가 해당 분포를 따른다는 것을 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 데이터를 가져와 정규 분포와 비교하고, 해당 데이터가 정규 분포에서 나온 것인지 확인해봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우선, 다양한 라이브러리를 가져오겠습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" numpy \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" np\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" scipy.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"stats\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" stats\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" pandas \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" pd\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" seaborn \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" sns\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" statsmodels.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"api\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" sm\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" matplotlib.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"pyplot\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" plt\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제, 데이터셋을 불러올게요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"df1=pd.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_csv\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://gist.githubusercontent.com/stoicsapien1/4c0d96aa3b6f99178f5ee071bef23d10/raw/281efb659ff1713ac64b680a9bf44a53ce367e38/data.csv\\\"\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Scipy 라이브러리를 사용하여 QQ Plot을 생성해볼까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우선 데이터를 표준화한 다음 QQ Plot을 만들어볼 거에요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"df.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"head\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_1.png\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"df[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Z\\\"\"\n        }), \"]=(df[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"data\\\"\"\n        }), \"]-df[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"data\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean\"\n        }), \"())/df[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"data\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"std\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새롭게 표준화된 데이터 열을 생성했어요. 데이터의 상위 내용은 아래에 제공됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_2.png\",\n        alt: \"QQ Plot\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 Scipy 라이브러리를 사용하여 QQ 플롯을 생성해 봅시다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"stats.probplot(df[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Z\\\"\"\n        }), \"], dist=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"norm\\\"\"\n        }), \", plot=plt)\\nplt.show()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_3.png\",\n        alt: \"QQ Plot\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"statsmodels 라이브러리를 사용하여 QQ Plot을 생성할 수도 있습니다. 그럼 시작해 보겠습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" statsmodels.api \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" sm\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" matplotlib.pyplot \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" plt\\n\\nsm.qqplot(df[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Z\\\"\"\n        }), \"], line=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"45\\\"\"\n        }), \")\\nplt.show()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-MasteringQQPlotsADataScientistsSecretWeapon_4.png\",\n        alt: \"QQ Plot\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"대부분의 점이 직선(빨간 선) 위에 있는 경우, 데이터가 정규 분포를 따른다고 추정할 수 있습니다. 여기서는 대부분의 데이터가 직선 위에 있는 것을 관찰할 수 있지만, 추가적인 통계 검정을 통해 정규성을 확인해야 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"깃허브 저장소: EDA-Projects/QQ Plot at main · stoicsapien1/EDA-Projects (github.com)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여러 가지 통계적 검정 방법 중 하나는 콜모고로프-스미르노프 검정입니다. 이에 대해 더 알아보려면 콜모고로프-스미르노프 검정에 대한 내 블로그를 읽어주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안녕히 가세요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}