{"pageProps":{"posts":[{"title":"제목 UTM을 사용하여 MacOS에서 Any CPU 아키텍처 실행하기","description":"","date":"2024-05-15 16:02","slug":"2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM","content":"\n\n<img src=\"/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_0.png\" />\n\n저는 맥용 Parallels를 오랫동안 사용해왔는데, 이 제품은 플랫폼을 위한 최고의 가상화 소프트웨어 옵션 중 하나로 널리 인정받고 있어요. 그러나 Parallels는 M1, M2, M3과 같은 Apple Silicon 프로세서가 장착된 시스템에서 Rosetta를 사용하여 x86_64 응용 프로그램을 실행할 수 있는 능력이 있긴 하지만, 호환성 문제로 인해 x86_64 응용 프로그램이 제대로 작동하지 않거나 전혀 작동하지 않는 경우가 종종 있어요.\n\n최근에 x86_64 기반 소프트웨어를 실행해야 할 필요가 있을 때, CPU 에뮬레이션을 제공하는 대체 가상화 소프트웨어를 찾았습니다. UTM은 이러한 공백을 완벽하게 채워주며, Apple Silicon 맥에서 x86_64 응용 프로그램을 실행할 수 있는 신뢰할 수 있는 솔루션을 제공해요.\n\nUTM은 Apple 스토어에서 9.99달러에 구매할 수 있으며, 자동 업데이트가 포함되어 있어요. 또는 https://docs.getutm.app/installation/macos/에서 무료로 UTM을 다운로드하고 설치할 수도 있어요. 그러나 무료 옵션을 선택하는 경우, 자동 업데이트를 받을 수 없음을 참고해 주세요.\n\n\n\n## 주요 UTM 기능\n\nUTM은 Parallels와 같은 다른 가상화 소프트웨어와 다르게 x86_64와 같은 아키텍처의 완전 에뮬레이션을 제공하기 위해 QEMU(Quick Emulator)를 이용한다는 점에서 차별화됩니다. 이 접근 방식은 해당 특정 아키텍처를 위해 설계된 소프트웨어를 실행하려고 할 때 가장 호환성이 높은 환경을 제공하지만, 다른 가상화 방법에 비해 다소 효율성이 떨어질 수 있습니다.\n\nUTM은 x86, x86–64, ARM32, ARM64, MIPS, PowerPC 및 RISC-V를 포함한 30개 이상의 프로세서 아키텍처를 지원하는 다재다능한 에뮬레이션 플랫폼입니다. 이 높은 호환성으로 UTM은 특정 아키텍처를 필요로 하는 개발자와 열렬한 지지자들에게 이상적인 선택지가 됩니다.\n\n## UTM을 사용하여 가상 머신 생성하기\n\n\n\n가상 머신을 생성할 때 다음과 같은 옵션이 제공됩니다.\n\n![가상머신 생성 옵션](/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_1.png)\n\n가상화 모드는 빠르게 실행되지만 네이티브 CPU 아키텍처만 실행할 수 있습니다. 예를 들어 시스템에 M1 프로세서가 있는 경우 가상 머신은 동일한 M1 CPU 아키텍처를 사용합니다.\n\n두 번째 옵션 \"에뮬레이트\"는 시스템이 다른 아키텍처를 에뮬레이트할 수 있도록 합니다.\n\n\n\n다른 옵션은 UTM 갤러리에서 미리 구축된 이미지를 다운로드하는 것입니다. Arch Linux, 다양한 Debian 배포판, Fedora, Kali Linux, macOS, ReactOS, Sun Solaris, Ubuntu, Windows 10, Windows 11, Windows 7, 그리고 Windows XP 등의 여러 운영 체제를 찾을 수 있습니다.\n\n\"Emulate\" 옵션을 선택하면 Windows, Linux 및 기타 옵션을 포함한 미리 구성된 선택지 목록이 표시됩니다. 설치할 운영 체제에 해당하는 항목을 선택하세요.\n\n![이미지](/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_2.png)\n\n설치 후에 좌측 패널에서 새로 만든 가상 머신을 마우스 오른쪽 버튼으로 클릭하고 구성을 조정할 수 있습니다. CPU 코어 수, RAM 크기, 네트워크 어댑터 유형과 같은 설정을 선호에 맞게 수정할 수 있습니다. 또한 필요한 경우 QEMU 설정을 사용자 정의할 수도 있습니다.\n\n\n\nUTM에서 제공하는 사전 구성된 VM 이미지 중 하나를 사용하면 공유 디스크 및 공유 클립보드와 같은 기능이 사전 구성되어 있습니다. 필요한 기능을 제공하는 경우 사전 구성된 이미지를 사용하는 것이 좋습니다. 그러나 다른 OS 또는 아키텍처를 사용해야 하는 경우 자체 원하는 구성으로 ISO 파일에서 설치할 수 있습니다.\n\n중요한 점은 ISO에서 설치하는 경우 설치 후 VM 구성에서 ISO를 제거해야만 ISO에서 부팅을 계속하지 않습니다.\n\n![이미지](/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_3.png)\n\nVM 구성으로 이동하여 ISO를 지워주세요.\n\n\n\n<img src=\"/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_4.png\" />\n\n## 공유 디스크\n\nUTM에서 공유 디스크를 사용하려면 VirtFS 또는 Spice WebDAV를 선택할 수 있습니다. UTM은 주로 Linux 게스트와 폴더를 공유하기 위해 9pfs를 사용하지만, RHEL9 또는 Rocky Linux 9와 같은 9p 파일 시스템을 지원하지 않는 시스템에서 9p 대신 Spice WebDAV를 대안으로 사용할 수 있습니다.\n\n원하는 구성을 게스트 VM 구성 화면에서 선택하세요.\n\n\n\n## 9p 파일 시스템 사용 방법\n\n9p 파일 시스템은 WebDAV보다 빠릅니다. 이를 선호하는 선택입니다. QEMU의 9p 파일 시스템을 사용하면 사용자가 가상 파일 시스템 장치를 만들고 이를 게스트 가상 머신에 노출할 수 있습니다. 이를 통해 호스트 머신의 디렉토리를 게스트 운영 체제가 직접 액세스할 수 있게하는 9P 네트워크 프로토콜을 사용하여 호스트와 게스트 간의 통신이 가능해집니다.\n\n호스트에서 공유된 9p 파일 시스템을 마운트하는 것은 그다지 간단하지 않습니다. 인터넷에 많은 정보가 있지만 대부분이 틀린 것 같았어요. 제가 도움이 되었던 정보를 공유하겠습니다.\n\n아래 단계는 RPM 기반 시스템에서도 유사하지만 예시로 우분투를 사용할 것입니다.\n\n\n\n저의 경우에는 Downloads 디렉토리를 내보냈습니다. \"Downloads\"를 사용하여 마운트할 수 있을 것으로 예상했지만, UTM이나 QEMU는 볼륨을 \"share\"로 내보내는 것으로 나타났습니다.\n\n공유 이름을 보려면 VM용 QEMU 설정을 내보내세요. 아래에 표시된 것처럼 공유 이름이 거기에 표시됩니다:\n\n![share](/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_5.png)\n\n이 경우의 마운트 태그인 export 이름은 \"share\"입니다:\n\n\n\n\"공유는 'share'로 불립니다. 다만, 다운로드 폴더를 공유하도록 구성했음에도 불구하고 'Downloads'로 불리길 기대했습니다.\n\n수동으로 마운트하려면 다음을 실행하세요:\n\nfstab에 추가하여 부팅 시 파일 시스템을 자동으로 마운트할 수 있습니다.\n\n## WebDAV 파일 공유\"\n\n\n\nWebDAV는 호스트와 게스트 가상 머신 간의 파일 시스템을 공유하는 대안으로 작용합니다. 9p 파일 시스템을 통한 파일 공유는 더 빠를 수 있지만 널리 지원되지는 않습니다. 예를 들어, Rocky Linux 9는 9p 파일 시스템을 지원하지 않습니다.\n\n다음 지침은 Ubuntu를 사용하여 수행되지만, 다른 리눅스 배포판에 대해서도 비슷하게 적용될 것입니다.\n\n먼저, 게스트 구성에서 Spice WebDAV를 선택하십시오:\n\n![Spice WebDAV](/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_6.png)\n\n\n\n우분투 24에서는 /etc/default/spice-vdagentd 파일을 추가하지 않으면 spice-vdagentd가 시작되지 않습니다. 이 파일을 만들기 전까지 오류 메시지가 나타날 것입니다:\n\n![image](/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_7.png)\n\n다음 내용으로 `/etc/default/spice-vdagentd` 파일을 만드세요:\n\n그런 다음 다음 명령어로 spice.vdagentd를 다시 시작할 수 있습니다:\n\n\n\n서비스를 다시 시작하고 나면 WebDAV를 사용하여 공유를 마운트할 수 있습니다. 예를 들어:\n\n![example](/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_8.png)\n\n호스트에서 공유된 localhost:9843을 사용하여 공유를 마운트할 때 사용자 이름이나 비밀번호를 지정할 필요가 없었어요.\n\n필요한 경우 fstab에도 추가할 수 있습니다.\n\n\n\n## 공유 클립보드\n\n공유 클립보드는 UTM 가상화에서 사용자가 호스트 운영 체제와 가상 머신 간에 텍스트를 원활하게 복사하고 붙여 넣을 수 있는 편리한 기능입니다. 그러나 ISO에서 수동 설치할 때는 자동으로 설치되지 않을 수 있습니다.\n\n복사 및 붙여 넣기를 활성화하려면 가상 머신의 구성에서 클립보드 공유가 활성화되어 있는지 확인하십시오. 그런 다음 가상 머신 내에서 'spice-vdagentd' 및 'spice-vdagent' 패키지를 설치하십시오. 설치 후에는 systemctl을 사용하여 spice-vdagentd를 시작하십시오. 그런 다음 spice-vdagent 소프트웨어를 시작하십시오. X11이 시작될 때 spice-vdagentd를 시작하려면 ~/.xinitrc에 추가할 수 있습니다.\n\n## 설치 중 발생할 수 있는 문제들\n\n\n\n특정 운영 체제나 아키텍처를 UTM을 사용하여 실행하는 것은 도전적일 수 있습니다. 이것은 Parallels처럼 간단히 연결하고 사용하는 것처럼 간단하지 않습니다. 유연성은 더 복잡한 설정으로 이어질 수 있습니다.\n\n예를 들어, 기본 CPU 설정은 x86_64 에뮬레이션을 사용하는 Rocky Linux 9에서 작동하지 않습니다. AMD EPYC 프로세서를 에뮬레이션하는 경우 Rocky Linux 9에서 x86_64 에뮬레이션 아래에서 잘 작동합니다.\n\n또한, 기본 디스플레이 설정은 작동하지 않으며 '디스플레이 출력이 활성화되지 않았다'는 오류 메시지가 표시됩니다. 이 문제를 해결하려면 VM의 설정으로 이동하여 기본 'virtio-gpu-pci'에서 'virtio-vga'로 변경하십시오. 이것은 콘솔 전용 디스플레이에 표준 VGA를 제공합니다.\n\n\n\n또한, 기본 디스플레이 설정이 작동하지 않고 \"디스플레이 출력이 활성화되지 않았다\"는 오류가 발생하는 경우, VM 설정으로 들어가서 \"Emulated Display Card\"를 기본값인 \"virtio-gpu-pci\"에서 \"virtio-vga\"로 변경해 보세요. 이렇게 하면 콘솔 전용 디스플레이에 표준 VGA가 제공됩니다.\n\n## 결론\n\n도움이 되셨으면 좋겠습니다. 작동하는 해결책을 찾기 위해 많은 시행착오를 겪었습니다. 이 정보가 여러분의 시간을 절약하는 데 도움이 되기를 바랍니다.","ogImage":{"url":"/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_0.png"},"coverImage":"/assets/img/2024-05-15-RunningAnyCPUArchitectureonMacOSusingUTM_0.png","tag":["Tech"],"readingTime":6},{"title":"VMware Workstation 및 Fusion Pro 이제 개인 사용자에게 무료로 제공됩니다","description":"","date":"2024-05-15 16:01","slug":"2024-05-15-VMwareWorkstationFusionProNowFreeforPersonalUse","content":"\n\n\n![VMware Workstation Pro is now available for personal use at no cost, but the integration with Broadcom is still a messy affair, to put it down mildly.](/assets/img/2024-05-15-VMwareWorkstationFusionProNowFreeforPersonalUse_0.png)\n\nTo help others who may have encountered difficulties navigating Broadcom’s site to download VMware Fusion or Workstation Pro, I’ve noted down these steps for a more direct approach. Hopefully, it’ll help streamline the process for those who, like me, found themselves lost in the maze of menus hiding the download link.\n\n- Go to [broadcom.com](https://www.broadcom.com)\n- In the upper right corner, select ‘Support Portal’\n- Either log in by clicking ‘Go To Portal’ or ‘Register’ for a basic Broadcom account Quick link to the registration form\n- Once logged in, go to [support.braodcom.com](https://support.broadcom.com) if you’re not redirected there\n- Click the dropdown to choose the VMware Cloud Foundation division\n- On the left, click ‘My Downloads’\n- Search for either Fusion or Workstation\n- Click the product name (VMware Fusion or VMware Workstation Pro )\n- Notice the dropdown for the Personal Use edition (it is the exact same binaries as the Commercial one)\n- Select 17.5.2 or 13.5.2\n- Download and install\n\n\n\n\n앞으로의 소식을 공유하고 Broadcom의 교활한 짓에 어려움을 겪고 있는 다른 사람들을 도와주세요.\n\n이 글의 저자를 응원하고 싶다면 커피 한 잔 사주는 건 어떨까요?","ogImage":{"url":"/assets/img/2024-05-15-VMwareWorkstationFusionProNowFreeforPersonalUse_0.png"},"coverImage":"/assets/img/2024-05-15-VMwareWorkstationFusionProNowFreeforPersonalUse_0.png","tag":["Tech"],"readingTime":2},{"title":"iOS 175은 우리가 기대했던 것보다 훨씬 더 크다 - 놀라운 15가지 기능","description":"","date":"2024-05-15 15:58","slug":"2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures","content":"\n\niOS 17.5 업데이트가, 4차례의 엄격한 베타 버전 테스트 끝에 드디어 어제 공개되었어요.\n\n모든 iOS 사용자에겐 좋은 소식이지만, EU 지역 사용자들에겐 더욱 큰 소식이에요. 왜냐하면 이제 그들은 웹에서 직접 앱을 설치하고 아이폰에서 여러 앱 시장을 관리할 수 있어요.\n\n세계의 나머지 사람들은 '수리 상태', 새로운 배경 화면, 새로운 게임, 그리고 iOS 18에서 기대했던 많은 소소한 개선 사항을 시도해 볼 수 있어요.\n\niOS 17.5가 큰 업데이트라는 사실에 기분이 좋네요.\n\n\n\n요약한 기능 및 업데이트 내용을 모두 소개해드리겠습니다. iOS를 최적화할 수 있는 모든 크고 작은 변화를 알아두세요.\n\n## 본 문서에서 다루는 내용\n\n— 유럽 전용 변경 사항 —\n1. 개발자 웹사이트에서 앱 직접 다운로드 가능\n2. 타사 앱 마켓플레이스 지원\n— 일반 변경 사항 —\n3. 새로운 프라이드 배경화면\n4. 새로운 수리 모드\n5. AirTag 이외의 추적기에 대한 추적 알림\nApple News+의 새로운 변경 사항\n6. 새로운 4분할 퍼즐\n7. 뉴스+가 게임 센터에 연결\n8. 오프라인 모드\n책의 새로운 변경 사항\n9. 새로운 독서 목표 카운터\n10. 새로운 책 목표 카운터\n위젯의 새로운 변경 사항\n11. 팟캐스트 위젯이 표지 색상을 모방합니다\n12. 날씨 위젯의 온도가 작은 글꼴로 표시됩니다\n기타 새로운 변경 사항\n13. Apple TV+ 쇼를 시청 중인 동안 공유\n14. '웹 브라우저용 패스키 엑세스'의 글리프 아이콘\n15. 미발표된 Beats Pill 스피커 발견\n16. 잘못된 스위치 설정 무시하기(접근성)\n\n# — 유럽 전용 변경 사항 —\n\n\n\n# #1. 개발자 웹사이트에서 앱을 직접 다운로드 받기\n\niOS 17.4에서 Apple은 이미 유럽 연합(EU) 사용자가 대체 앱 마켓 플레이스(예: AltStore)를 설치할 수 있도록 사이드로딩을 활성화했습니다. 이제 iOS 17.5에서 새로운 사이드로딩 옵션인 웹 배포가 추가되었습니다.\n\n이를 통해 개발자는 자신의 웹사이트(앱 스토어 커넥트에 등록된)에서 앱을 직접 배포할 수 있습니다. 따라서 브라우저에서 앱 패키지를 다운로드하여 안드로이드의 .apk 파일처럼 설치할 수 있습니다.\n\n주의할 점은 개발자가 소유하지 않고 애플에 등록되지 않은 웹사이트는 사용자 안전을 보장하기 위해 해당 개발자의 앱을 배포할 수 없습니다.\n\n\n\n웹 배포를 위한 앱의 자격 요건은 다음과 같습니다.\n\n- 앱은 Apple의 인증 과정을 통과해야 합니다.\n- 지난 달력 연도에 EU에서 최소 100만 명 이상의 첫 연간 설치를 가져야 합니다.\n- 개발자는 Apple 개발자 프로그램에 두 연속 연도 이상 가입해 있어야 합니다.\n- 개발자는 사용자를 안전하게 유지하고 데이터 수집에 대해 투명해야 하며 적용 가능한 정부 법률을 준수해야 합니다.\n\n하지만 개발자들은 왜 앱 스토어 대신 자사 웹사이트에서 앱을 제공하려고 생각할까요?\n\n- 자신의 웹사이트로의 트래픽이 증가하고 사용자 데이터를 더 많이 얻을 수 있는 기회가 생깁니다.\n- 애플 수수료를 면할 수 있지만, 지난 12개월 동안 100만 회 이상의 첫 연간 설치당 €0.50의 \"코어 기술 수수료\"를 지불해야 합니다.\n\n\n\n# #2. 제3자 앱 마켓 플레이스 지원\n\n말했듯이, iOS 17.4 버전에서는 이미 대체 앱 마켓 플레이스를 지원했습니다.\n\n하지만 iOS 17.5 버전에서는 단일 기기에서 여러 앱 마켓 플레이스를 조합하는 방법을 볼 수 있습니다. 다음과 같습니다:\n\n- 설정에 새로운 '앱 설치' 섹션이 추가되었습니다.\n\n\n\n경고: Markdown 파일에 \\<img\\> 태그를 사용하면 이미지를 삽입할 수 없습니다. 대신 다음 같은 형식을 사용하여 이미지를 링크할 수 있습니다.\n\n- 기본 앱 마켓을 변경하세요:\n\n![이미지1](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_1.png)\n\n![이미지2](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_2.png)\n\n\n\n- 특정 앱 마켓에 대한 정보 확인:\n\n![이미지](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_3.png)\n\n- 앱이 설치된 위치 확인:\n\n![이미지](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_4.png)\n\n\n\n설정 ⚙️ ` app_name에서 찾을 수 있어요.\n\n- 화면 시간에서 대안 앱 마켓플레이스에서 앱 설치 제한:\n\n![image](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_5.png)\n\n예를 들어, App Store가 아닌 앱 마켓플레이스에서 앱을 설치하는 것을 제한할 수 있어요.\n\n\n\n# — 일반적인 변경 사항 —\n\n# #3. 새로운 프라이드 배경화면\n\n매년 애플이 관행적으로 하던 대로, iOS 및 iPadOS를 위한 새로운 프라이드 배경화면 시리즈, 프라이드 라디언스 워치 페이스, 그리고 애플 워치를 위한 프라이드 에디션 브레이디드 솔로 루프가 출시되었습니다.\n\n하지만 우리 주제는 현재 iOS입니다. 여기 새로운 프라이드 배경화면 중 하나가 있습니다:\n\n\n\n![이미지](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_6.png)\n\n이 배경화면 너무 좋아요.\n화면을 위로 스와이프하면 문자열이 동적으로 이동합니다.\n\n애플의 뉴스룸 기사에 따르면 아래와 같은 색상으로 구성되어 있습니다:\n\n- 검정과 갈색: 흑인, 히스패닉 및 라틴 사회, 그리고 HIV/AIDS로 영향받은 사람들을 상징합니다.\n- 분홍색, 연한 파랑색, 그리고 흰색: 트랜스젠더 및 논바이너리 인물을 대표합니다.\n\n\n\n아래는 제공되는 다른 색상입니다:\n\n![Color Image](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_7.png)\n\n## #4. 새로운 수리 모드\n\niOS 17.5에는 모든 새로운 \"수리 상태\" 기능이 포함되어 있습니다. 이 작동 방식에 대해 설명하겠습니다.\n\n\n\n일반적으로, Apple Store에서는 iPhone을 수리하러 맡기기 전에 Find My를 비활성화해주기를 바랍니다. 이는 iPhone을 소유하고 있는지 확인하고 도난당한 기기를 수리하는 것이 아닌지 확인하기 위한 조치입니다.\n\n그러나 이에는 두 가지 단점이 있습니다:\n- iPhone이 수리 중일 때 위치를 추적할 수 없습니다 (하지만 Apple Store는 믿을 만한 곳이므로 문제가 되지는 않을 것입니다).\n- iOS 17.3의 '도난 당한 기기 보호' 기능 때문에 많은 사용자들이 Find My를 비활성화하고 iPhone을 맡기기까지 한 시간을 기다려야 했는데, 이것은 짜증나는 일입니다.\n\n이제 Repair State를 통해 Find My를 꺼내지 않고도 Apple 기술자에게 당신의 iPhone임을 입증할 수 있습니다.\n\n\n\n수리 상태를 활성화하는 방법은?\nFind My 앱을 열고 계정에서 iPhone을 제거해 보세요. 다음 화면이 표시될 것입니다:\n\n![이미지](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_8.png)\n\n\"계속\"을 클릭하여 수리 상태를 활성화하세요. 이제 아래에 표시된 것이 iPhone이 수리 상태에 있다는 표시입니다:\n\n![이미지](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_9.png)\n\n\n\n이유 없이 수리 상태를 활성화하지 마세요. 수리 상태는 아이폰 기능에 영향을 미치지 않지만 현재는 비활성화할 수 없는 방법이 없습니다.\n\n두 가지 이론:\n\n- 아직 Apple이 이를 비활성화할 수 있는 옵션을 추가하지 않았습니다.\n- 수리가 완료된 것을 확신한 기술자만이 비활성화할 수 있습니다.\n\n# #5. AirTag가 아닌 추적기에 대한 추적 알림\n\n\n\n에어텍이라는 것으로 애플이 여러 논란에 휘말렸다는 걸 아시겠지요.\n\n가방이나 차량 유리 등에 달린 비밀 에어텍으로 스토킹을 당한 피해자들이 있습니다.\n\n(한편으로는 에어텍 덕분에 분실된 물건을 찾을 수 있는 사람들도 있죠.)\n\n피해자의 안전을 위해, 알 수 없는 에어텍이 저희들과 함께 움직이는 것이 감지되면, 8시간에서 24시간 사이의 임의의 시간에 알림을 받게 됩니다.\n\n\n\n안드로이드 사용자들이 조금 복잡한 상황에 처해 있어요 — Tracker Detect 앱을 설치하고 알 수 없는 AirTag을 수동으로 스캔해야 자신을 보호할 수 있어요.\n\n하지만 이것은 AirTag/Find My Certified 추적기에만 해당돼요 — 만약 스토커가 Tile, Galaxy SmartTag, 또는 Chipolo ONE을 사용한다면 어떨까요? 그들로부터 안전하지 않을 거라고요?\n\n그러나 Google과 Apple의 협업 노력 덕분에, iOS 17.5에서 그들은 통합된 크로스 플랫폼 솔루션을 도입했어요. 이로써 사용자들에게 AirTag 비밀 사용 뿐만 아니라 Chipolo, eufy, Jio, Motorola, Pebblebee와 같은 다른 인기 기업의 추적기에 대한 경고를 제공하죠.\n\n가장 좋은 점은, 이 프로토콜은 Bluetooth 추적기에만 한정되지 않고 GPS, 셀룰러, 그리고 Wi-Fi를 사용하는 추적기까지 포함돼 있다는 거에요.\n\n\n\niOS 17.5의 코드에는 다음 내용이 포함되어 있습니다. 9to5Mac에서 발견한 정보에 따르면:\n\n### 새로운 News+ 변경 사항\n\n#### #6. 새로운 Quartiles 퍼즐\n\n기존 크로스워드 및 미니 크로스워드 게임과 함께, Apple News+ 구독자들은 이제 새로운 게임인 Quartiles를 즐길 수 있습니다.\n\n\n\n<img src=\"/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_10.png\" />\n\n이 게임은 매일 플레이어들에게 의미 있는 단어를 형성할 수 있도록 2~4자 글자를 포함한 타일을 연결해 보라는 도전을 줍니다. 단어의 길이에 기반하여 점수를 받습니다.\n\n```js\n뉴스에서 4분위수를 찾기 < 다음으로 🔍 < 퍼즐 🧩.\n```\n\n## #7. 뉴스+는 게임 센터에 연결됩니다.\n\n\n\n일반 게임 경험 외에도 이제 뉴스+ 퍼즐 점수를 친구들과 비교하고 전 세계적으로 순위를 확인할 수 있습니다. Game Center에 연결되어 뉴스에 이제 가능합니다.\n\n![image](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_11.png)\n\n이를 위해 설정 ⚙️ `뉴스` 뉴스+ 퍼즐에서 Game Center를 켜세요.\n\n## #8. 오프라인 모드\n\n\n\n만약 Apple News+ 구독자이시면 최신 및 저장된 이야기, 잡지 호, 퍼즐 플레이, 그리고 오프라인으로 오디오 이야기를 감상할 수 있습니다.\n\n![image](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_12.png)\n\n(iOS 17.4 이전에는 잡지 호 및 오디오 이야기만 다운로드할 수 있었습니다.)\n\n이를 활성화하려면 설정 ⚙️ `뉴스` 뉴스+ 오프라인 모드에서 자동 다운로드를 토글하세요.\n\n\n\n\n![image](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_13.png)\n\n당신의 iPhone은 Wi-Fi와 전원에 연결되어 있고 배경 앱 새로 고침이 뉴스에 대해 켜져 있을 때 새 콘텐츠를 다운로드합니다.\n\n다운로드 옵션 안에 들어가면 iPhone이 오프라인 상태로 유지하는 콘텐츠를 관리할 수 있습니다. 또한 '저장 공간 최적화'를 통해 iPhone이 이야기의 이미지의 작은 버전을 다운로드하도록 설정할 수도 있습니다.\n\n![image](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_14.png)\n\n\n\n\n아이폰 저장 공간이 부족할 때 '저장 공간 최적화’가 자동으로 활성화됩니다.\n\n# • 새 책 기능 변경\n\n## #9. 새로운 독서 목표 카운터\n\n아마 애플은 당신의 독서 목표를 더 이루고 싶어하는 것 같아요 — Books 앱의 우측 상단에 독서 목표 카운터가 있어요.\n\n\n\n\n![이미지](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_15.png)\n\nApple Books의 '독서 목표'는 아주 새로운 기능이 아닙니다; 이미 하단에 있었죠. 그저 이제 Apple이 눈에 잘 띄고 동기부여하기 쉽도록 최상단에도 표시해 줍니다.\n\n그것을 탭하면 '독서 목표' 메뉴로 이동하는데, 여기서 사용자들은 매일 특정 분량의 독서 목표를 설정하고 달성할 수 있습니다.\n\n카운터는 ebook을 읽을 때마다 분마다 증가합니다. 만약 가득 찬다면, 축하합니다, 그날의 독서 목표를 달성했습니다.\n\n\n\n\n읽기 목표를 하루에 1분부터 1440분(24시간) 사이로 설정할 수 있어요 — 하지만 후자는 너무 공격적이지 않나요?\n\n## #10. 신규 도서 목표 카운터\n\n이것은 'Books' 독자들을 위한 새로운 기능입니다 — 도서 목표.\n\n홈 화면을 스크롤하면 이것을 보실 수 있어요:\n\n\n\n<img src=\"/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_16.png\" />\n\n올해 당신이 완료한 책의 숫자입니다. ' ` ' 기호를 클릭하여 독서 목표를 조정할 수 있습니다.\n\n상한 한도를 아시나요? 하루에 한 권의 책을 읽는 거, 365권! 불가능한 건가요? 불가능이라는 말 자체가 '나는 가능하다'라고 말하는 책벌레가 말했습니다.\n\n# • 새로운 위젯 변경\n\n\n\n## #11. 팟캐스트 위젯이 이제 커버 아트의 색상을 모방합니다\n\niOS 17.4까지는 팟캐스트 위젯이 항상 핑크색을 유지했습니다. 뭐가 재생되든 상관없이 원래 아이콘의 색상을 고수했습니다.\n\n하지만 iOS 17.5부터, 현재 듣고 있는 팟캐스트의 커버 아트에 따라 위젯의 색상이 변경됩니다.\n\n![이미지](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_17.png)\n\n\n\n## #12. 날씨 위젯의 온도가 작은 글꼴로 표시됩니다\n\n날씨 앱에는 총 여섯 가지 홈 화면 위젯이 있습니다. 그 중 다섯 가지는 현재 온도를 표시합니다.\n\niOS 17.5에서 위젯에 표시되는 온도가 약간 작아졌습니다. 이로 인해 위젯이 덜 부담스럽게 보입니다. iOS 17.4와 iOS 17.5 날씨 예보 위젯을 비교해보겠습니다:\n\n![iOS 17.5와 iOS 17.4 날씨 예보 위젯 비교](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_18.png)\n\n\n\n# • 새로운 잡다한 변경 사항\n\n## #13. Apple TV+ 쇼를 시청 중일 때 공유하기\n\niOS 17.4 이전, Apple TV+ 시리즈 에피소드를 시청하는 중에 좋아하면서 친구와 공유하고 싶을 때,\n\n- 가로 모드인 경우, 왼쪽 상단의 공유 아이콘을 클릭하시면 됩니다.\n\n\n\n\n![Screenshot 1](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_19.png)\n\n- If you’re on portrait mode, you’d click on the three dots menu at the bottom-right corner.\n\n![Screenshot 2](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_20.png)\n\nHowever, this way, you could only share the current episode — but not the full show. But on iOS 17.5,\n\n\n\n\n- 언제든지 화면을 가로로 돌리더라도 왼쪽 상단에 공유 아이콘을 볼 수 있습니다.\n- 현재 에피소드를 공유할지 전체 쇼를 공유할지 묻는 옵션을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_21.png)\n\n## #14. '웹 브라우저용 패스키 액세스'를위한 글리프 아이콘\n\niOS 17.4에서 '앱 설정 ⚙️ ` 개인정보 및 보안 ✋'에서 '웹 브라우저용 패스키 액세스' 섹션을 얻었습니다.\n\n\n\n애플이 당신이 저장한 패스워드를 볼 수 있는 앱들이 요청한 능력을 나열하는 곳이에요. 거기서 그들의 액세스를 쉽게 켜거나 끌 수 있어요.\n\n하지만 이전에는 글리프 아이콘이 없었어요. 이제 iOS 17.5에서 하나가 생겼어요.\n\n![이미지](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_22.png)\n\n## #15. 미발표 Beats Pill 스피커 발견\n\n\n\niOS 17.5 RC의 코드에서 발견된 내용을 AppleInsider가 보도했습니다. 발표되지 않은 Beats Pill 스피커를 보여주는 새로운 에셋 네 개가 있어요. 출시가 임박한 것을 시사하는군요.\n\n그 이미지들을 보면 빨강, 검정, 그리고 금 세 가지 색상으로 출시될 것으로 보입니다.\n\n![Beats Pill 스피커](/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_23.png)\n\n그리고 이것은 연결 시 나타나는 애니메이션입니다:\n\n\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*x0-p_vCLKz7cGpQO3Xu4GA.gif)\n\n## #16. 잘못된 스위치 설정 무시하기 (접근성)\n\n아이폰을 제어할 때 스위치를 사용 중이라면 새로운 옵션이 있습니다.\n\n이제 '설정' ⚙️ ` 접근성 🚹 ` 스위치 제어 🎛️ ` 스위치`에서 '잘못된 스위치 설정 무시'를 토글할 수 있습니다. 이렇게 하면 스위치 구성이 잘못된 경우 알림을 받지 않습니다.\n\n\n\n\n<img src=\"/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_24.png\" />\n\n## iOS 17 정말 멋지지 않아요?\n\n## iOS 17의 305개 이상의 새로운 기능: 컴필레이션 (항상 업데이트): \n\n## 마지막으로,\n\n\n\n만약 새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면(나와 마찬가지로), Setapp에 가입해 보세요. 매달 $9.99에 240개 이상의 놀라운 앱들을 엄선된 컬렉션으로 이용할 수 있습니다. 이것들은 개별 구매 시 수백 달러에 달할 수도 있어요.\n\n- Setapp 여정을 시작하는 제 제휴 링크를 사용해보세요! (30일간 무료입니다)\n- Setapp에서 제 무료 100개 이상의 Ultimate macOS Apps 목록을 받아보세요.\n\n새로운 이야기를 발행할 때마다 알림을 받으려면 475명 이상의 다른 사람들과 함께 가입하세요!","ogImage":{"url":"/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_0.png"},"coverImage":"/assets/img/2024-05-15-iOS175IsWayBiggerThanWeveExpected15AmazingFeatures_0.png","tag":["Tech"],"readingTime":10},{"title":"Dagger를 사용하여 컴포저블을 주입시키되, 그것을 잃지 않는 방법","description":"","date":"2024-05-15 15:54","slug":"2024-05-15-InjectingComposableswithDaggerwithoutlosingit","content":"\n\n\n![Injecting Composables with Dagger without losing it](/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png)\n\nEveryone is using Hilt/Koin or some other fancy DI framework that just works™.\n\nIn this house, we still use plain Dagger2. It’s… not going great.\n\nConsider the predicament of a composable that can only work with certain parameters:\n\n\n\n\n가끔 composable들이 호출자에게 너무 많은 것을 요구하는 경우가 있어요.\n\n이 때는 아마도 이미 너무 깊이 들어간 상황일 것이고, 이를 바꾸려면 다른 10가지 것들을 깨뜨려야 할 수도 있어요.\n\n## 정리\n\n이 게시물의 목표는 독립적인 composable을 만드는 방법을 찾는 것입니다:\n\n\n\n- 자체 Dagger 컴포넌트를 생성합니다.\n- 자신을 주입합니다.\n- 사용자 정의 팩토리로 ViewModel을 빌드합니다.\n- ViewModels 및 Compose에 대한 자세한 정보는 이 미미/블로그를 확인해주세요.\n\n## 요약\n\n## 시작점\n\nDagger2로 활동/프래그먼트를 일반적으로 사용합니다.\n\n\n\n- 자체 Dagger 컴포넌트를 빌드합니다\n- 또는 애플리케이션 컴포넌트에서 일부 의존성을 가져옵니다\n\n그런 다음 의존성을 파라미터로 컴포저블에 아래로 전달할 것입니다 (현재 그대로 또는 함수를 통해):\n\n정보는 CompositionLocals로도 전달할 수 있습니다.\n\n이 방법은 논란의 여지가 있는데, 최소한 이 글에서는 다루지 않겠습니다.\n\n\n\n<img src=\"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_1.png\" />\n\n## 이주\n\nFirstScreen을 독립적으로 만들기 위해서는 주입된 종속성을 별도의 클래스로 분리해야 합니다.\n\n@Stable 주석을 사용하면 생성된 후에 실제로 변경되지 않을 것을 compose 컴파일러에 알릴 수 있습니다.\n\n\n\n## Dagger 구성 요소\n\n## Compose 레이어\n\n이 방법은 처음에는 작동하지만 매번 재구성할 때마다 Dagger 구성 요소가 다시 생성됩니다.\n\n이와 같이 무해한 예제에 대해서는 성능에 거의 영향을 미치지 않을 것입니다. 그러나 보다 복잡한 화면에 대해서는 그렇지 않을 수 있습니다.\n\n\n\n\nLet’s use the classic remember keyword, then:\n\n![image](/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_2.png)\n\n## Should someone actually do this?\n\nThis approach goes against most compose guidelines. Composables should really be pure functions, fast, idempotent, and free of side effects.\n\n\n\n\n하지만 주요 리팩터링이 실현 가능하지 않을 때, 너무 많은 노력을 들이지 않고 작동시킬 수 있어요.\n\n## 잊지말고요 (미안해요😑)\n\n효율성이 중요하다면, 간단히 처리할 수 없을 거에요. Ian Lake가 여기에서 왜 설명하는지 알려줄게요:\n\n위와 같은 경우에는 DI 구성 요소가 다시 생성되어 composable로 주입될 거예요.\n\n\n\n세계의 끝은 아니지만, 특히 무거운 Dagger 구성 요소의 경우에는 약간의 단점이 있습니다.\n\n만약 기억하는 값을 너무 쉽게 잃어버리지 않을까 걱정된다면, 더 고급 스코핑 옵션 2가지가 있습니다:\n\n- **resaca**\n    - sebaslogen에 의해 만들어졌습니다. 정말 좋아요! 👍\n- **Circuit**\n    - Slack에 의해 만들어졌습니다. 더 강력한 기억 형태 이외에도 더 많은 기능들을 제공합니다. 개인적인 경험은 없습니다.\n\n## 그래도요\n\n\n\n조금이나마 도움이 되었기를 바랍니다.\n\n@markasduplicate\n\n나중에 봐요.","ogImage":{"url":"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png"},"coverImage":"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png","tag":["Tech"],"readingTime":3},{"title":"데이터폼 용어 및 인증 흐름 이해하기","description":"","date":"2024-05-15 15:52","slug":"2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow","content":"\n\n## MLOPS: 데이터 파이프라인 오케스트레이션\n\n![이미지](/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_0.png)\n\nDataform은 팀이 복잡한 SQL 기반 데이터 파이프라인을 개발하고 운영할 수 있게 해주는 GCP 서비스의 일환으로 추가된 새로운 서비스입니다. Dataform은 소프트웨어 엔지니어링의 최고 관행인 테스팅, 환경, 버전 제어, 종속성 관리, 오케스트레이션 및 자동 문서화를 데이터 파이프라인에 적용할 수 있습니다. 이는 GCP 내에서 서버리스, SQL 워크플로 오케스트레이션의 주요 요소입니다. 위의 이미지에서 볼 수 있듯이 Dataform은 원시 데이터를 가져와 소프트웨어 엔지니어링의 최고 관행을 적용하여 구조화가 잘 된 데이터를 생산합니다.\n\n이 게시물의 영감은 저희 프로젝트 중 하나인 기존 Dataform의 웹 UI에서 GCP BigQuery로의 마이그레이션 중 발생했습니다. 마이그레이션 중, 릴리스 구성, 워크플로 구성 및 개발 워크스페이스와 같은 용어들이 정말 혼란스럽고 납득하기 어려웠습니다. 이것이 GCP Dataform에서 사용되는 일부 새로운 용어를 설명하는 게시물을 작성하게 된 동기가 되었습니다. 또한 GCP에서 단일 저장소 다중 환경 Dataform 작업의 기본 흐름을 강조할 것입니다. Dataform을 설정하는 다양한 방법이 있으므로 구글의 모베스트 관행을 확인해보세요.\n\n\n\n이것은 데이터폼의 기초와 설정을 다룬 2부작 시리즈 중 첫 번째 부분입니다. 제2부에서는 데이터폼을 프로비저닝할 때 최소 액세스 제어를 구현하는 방법을 보여드리겠습니다. 이에 대한 미리보기를 원하신다면 저장소를 확인해보세요.\n\n# 용어\n\n데이터폼에서의 구현은 GitHub 워크플로우와 유사합니다. 두 가지 간 유사성을 대조하고 이해하기 쉽도록 비유를 만들어보겠습니다. 데이터폼을 로컬 GitHub 저장소로 상상하는 것은 쉽습니다. 데이터폼을 설정할 때 로컬 GitHub이 원격 소스와 함께 연결되는 것과 유사한 방식으로 원격 저장소가 구성되도록 요청될 것입니다. 이 시나리오 설정을 염두에 두고 빠르게 데이터폼 용어를 살펴보겠습니다.\n\n## 개발 워크스페이스\n\n\n\n로컬 GitHub 브랜치와 유사한 개념입니다. GitHub의 main에서 브랜치를 만드는 것과 유사하게, 새로운 Dataform 개발 워크스페이스는 main Dataform 저장소 코드의 편집 가능한 사본을 체크아웃합니다. 개발 워크스페이스는 GitHub 브랜치처럼 서로 독립적입니다. 코드 개발과 실험은 개발 워크스페이스 내에서 진행되며, 코드가 커밋되고 푸시되면 개발 워크스페이스와 유사한 이름의 원격 브랜치가 생성됩니다. 개발 워크스페이스로 코드를 체크아웃하는 GitHub 저장소는 구성 가능하며, main 브랜치나 원격 저장소의 다른 브랜치 중 어디서든 가능합니다.\n\n## 릴리스 구성\n\nDataform은 데이터 변환과 로직을 위해 .sqlx 스크립트와 Javascript .js를 혼합하여 사용합니다. 결과적으로 코드베이스의 표준적이고 재현 가능한 파이프라인 표현을 얻기 위해 먼저 코드베이스의 컴파일을 생성하고 스크립트가 데이터로 구체화될 수 있는지 확인합니다. 릴리스 구성은 이 컴파일이 수행되는 자동화된 프로세스입니다. 구성된 시간에, Dataform은 원격 main 저장소의 코드를 체크아웃하고 JSON 구성 파일로 컴파일합니다. 코드를 체크아웃하고 컴파일을 생성하는 과정이 릴리스 구성이 다루는 내용입니다.\n\n## Workflow 구성\n\n\n\n릴리즈 구성의 출력물은 .json 구성 파일입니다. 워크플로 구성은 구성 파일을 언제 실행할지, 누가 실행해야 하는지 및 어느 환경에 구성 파일 출력물이 표시되거나 작성될지를 결정합니다.\n\n워크플로 구성은 릴리즈 구성의 출력물이 필요하기 때문에, 릴리즈 구성보다 이후에 실행되도록하는 것이 합리적입니다. 그 이유는 릴리즈 구성이 먼저 원격 저장소에 인증해야 하고(때로 실패할 수 있음), 코드를 체크아웃하고 컴파일해야 하기 때문입니다. 이러한 단계는 몇 초 안에 발생하지만 네트워크 연결 장애의 경우 더 많은 시간이 소요될 수 있습니다. 워크플로 구성은 릴리즈 구성에 의해 생성된 .json 컴파일 파일이 필요하기 때문에, 릴리즈 구성보다 나중에 예약하는 것이 의미가 있습니다. 동시에 예약하면 워크플로 구성이 이전 컴파일을 사용할 수 있으므로, 최신 변경 사항이 바로 BQ 테이블에 반영되지 않을 수 있습니다. 다음 워크플로 구성이 실행될 때까지 또는 BQ 테이블에 반영되지 않습니다.\n\n## 환경\n\n<img src=\"/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_1.png\" />\n\n\n\nDataform의 기능 중 하나는 코드를 개발, 스테이징 및 프로덕션과 같은 다른 환경으로 변환할 수 있는 기능입니다. 여러 환경에서 작업하는 것은 Dataform의 설정 방법에 어려움을 가져올 수 있습니다. 여러 환경에서 데이터 형성이 더 좋을까요? 단일 환경에서만 형성해야 할까요? Google은 Dataform 최상의 실천법 섹션에서 이러한 Trade-offs에 대해 논의했습니다. 이 게시물은 단일 리포지토리로 스테이징 및 프로덕션 환경에 Dataform을 설정하는 방법을 보여줍니다.\n\n환경들은 각각 사용자 지정 서비스 계정이 있는 GCP 프로젝트로 설정됩니다. Dataform은 스테이징 환경/프로젝트에만 생성되며 많은 변경 사항을 가지고 있기 때문에 스테이징(또는 비 프로덕션) 환경에서 실험하는 것이 좋습니다. 또한, 개발 코드가 나타나는 환경으로 스테이징 환경이 선택됩니다. 이는 개발 워크스페이스에서 생성된 데이터셋과 테이블이 스테이징 환경 안에서 나타나게 됨을 의미합니다.\n\n개발이 완료되면 코드가 커밋되고 원격 리포지토리에 푸시됩니다. 그 후, 리뷰를 거친 후 PR을 올릴 수 있으며 메인 리포지토리에 병합됩니다. 예약된 워크플로에서 릴리스 및 워크플로 구성이 실행됩니다. Dataform은 메인 브랜치에서 코드를 컴파일하고 프로덕션 환경 내에서 실행되도록 구성되어 있습니다. 따라서, 리뷰를 거친 코드만이 프로덕션으로 이동하고 개발 코드는 스테이징 환경에 남아 있습니다.\n\n요약하면, 위 Dataform 아키텍처 플로우에서 개발 워크스페이스에서 개발된 코드는 스테이징 환경에 나타내거나 원격 GitHub으로 푸시되어 피어 리뷰를 거치고 메인 브랜치에 병합됩니다. 릴리스 구성은 주요 브랜치에서 코드를 컴파일하고 워크플로 구성은 컴파일된 코드를 가져와 프로덕션 환경에 데이터를 나타냅니다. 따라서, GitHub 메인 브랜치에 있는 리뷰된 코드만이 프로덕션 환경에 나타납니다.\n\n\n\n# 인증\n\n데이터폼의 인증은 특히 여러 환경을 설정할 때 복잡하고 까다로울 수 있습니다. 스테이징 및 프로덕션 환경의 예제를 사용하여 이를 어떻게 수행하는지 설명하겠습니다. 어디에 인증이 필요하고 그 방법에 대해 알아봅시다.\n\n![그림](/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_2.png)\n\n위의 도표는 인증이 필요한 위치와 리소스에 대해 추적할 수 있는 간단한 데이터폼 워크플로우를 보여줍니다. 이 흐름은 개발 워크스페이스에서 데이터폼이 실행되고 일정에 따라 실행될 때(릴리스 및 워크플로 구성) 무엇이 발생하는지를 기록합니다.\n\n\n\n기계 사용자\n\n기계 사용자에 대해 이야기해봅시다. Dataform은 원격 저장소에 저장된 코드를 확인할 때 GitHub에 액세스하기 위한 자격 증명이 필요합니다. 개별 자격 증명을 사용할 수 있지만, 최선의 방법은 조직 내에서 기계 사용자를 사용하는 것입니다. 이러한 방법을 통해 Dataform 파이프라인 조종은 개별 신원과 독립적이며 그들의 이탈에 영향받지 않습니다. 기계 사용자를 설정하는 것은 여기에 자세히 설명된대로 개인에 속하지 않은 신원을 사용하여 GitHub 계정을 설정하는 것을 의미합니다. Dataform의 경우, 기계 사용자 계정을 위해 개인 액세스 토큰(PAT)이 생성되고 GCP 시크릿 매니저에 비밀로 저장됩니다. 또한 기계 사용자는 Dataform 원격 저장소에 읽기 및 쓰기 액세스 권한을 가진 외부 공동 작업자로 추가되어야 합니다. 나중에 테라폼 코드에서 Dataform이 비밀에 액세스할 수 있도록 구성되는 방법을 살펴볼 것입니다. 사용자가 기계 사용자 대신 자신의 신원을 사용하기로 결정할 경우, 여기에 자세히 설명된대로 토큰을 생성해야 합니다.\n\nGitHub 인증 흐름\n\n![GitHub 인증 흐름](/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_3.png)\n\n\n\n데이터폼은 구현을 위해 기본 서비스 계정을 사용합니다. 따라서 데이터폼 작업을 수행할 때 기본 서비스 계정부터 시작됩니다. 기계 사용자를 설정했다고 가정하고, 해당 사용자를 원격 저장소의 공동 작업자로 추가하고 해당 사용자 PAT를 GCP 시크릿 매니저에 비밀로 추가해야 합니다. GitHub에 인증하기 위해 기본 서비스 계정은 시크릿 매니저로부터 비밀을 추출해야 합니다. 기본 서비스 계정은 비밀을 액세스하기 위해 secretAccessor 역할이 필요합니다. 비밀에 액세스한 후, 기본 서비스 계정은 이제 기계 사용자를 표현할 수 있으며, 기계 사용자가 원격 Git 리포지토리의 공동 작업자로 추가되었기 때문에 기본 서비스 계정은 이제 해당 원격 GitHub 리포지토리에 공동 작업자로서 액세스할 수 있습니다. 이 흐름은 GitHub 인증 워크플로우 그림에 표시되어 있습니다.\n\n개발 워크스페이스 인증\n\n개발 워크스페이스에서 실행이 트리거되면, 기본 서비스 계정은 스테이징 환경 사용자 지정 서비스 계정으로 교체하여 스테이징 환경 내부에서 결과를 표시합니다. 스테이징 환경 사용자 지정 서비스 계정을 나타내기 위해 기본 서비스 계정이 필요한 것은 스테이징 서비스 계정에 대한 iam.serviceAccountTokenCreator 역할입니다. 이를 통해 기본 서비스 계정이 스테이징 사용자 지정 서비스 계정을 나타내기 위해 사용되는 기계 사용자를 표현하는 데 사용되는 PAT과 유사한 짧은 수명의 토큰을 생성할 수 있게 되며, 이를 통해 나타낼 수 있습니다. 따라서 스테이징 사용자 지정 서비스 계정은 BigQuery 테이블에 쓰기 권한이 모두 부여되고, 기본 서비스 계정은 스테이징 사용자 지정 서비스 계정을 나타낼 때 이러한 권한을 상속받을 수 있습니다.\n\n워크플로 구성 인증\n\n\n\n리포지토리를 확인한 후 릴리스 구성은 컴파일된 config .json 파일을 생성합니다. 이 파일에서 workflow 구성은 데이터를 생성합니다. 프로덕션 BQ 테이블에 데이터를 쓰기 위해 기본 서비스 계정은 프로덕션 사용자 정의 서비스 계정에 대해 iam.serviceAccountTokenCreator 역할이 필요합니다. 스테이징 사용자 정의 서비스 계정을 위해 수행한 것과 유사하게, 프로덕션 서비스 계정은 프로덕션 환경 BQ 테이블에 쓰기 위해 필요한 모든 권한을 부여받고, 기본 서비스 계정은 이 서비스 계정을 표시할 때 모든 권한을 상속합니다.\n\n요약\n\n요약하자면, 기본 서비스 계정이 주요 인물입니다. 기계 사용자를 표시할 때 기계 사용자 PAT를 사용하여 GitHub에 공동 작업자로 인증합니다. 또한 serviceAccountTokenCreator 역할로 생성된 단기 토큰을 사용하여 각각의 사용자 정의 서비스 계정을 표시하여 스테이징 및 프로덕션 환경에 인증합니다. 이해한 내용을 바탕으로 GCP 내에서 Terraform을 사용하여 Dataform을 프로비저닝할 시간입니다. 이에 대한 자세한 내용은 블로그의 Part 2를 기대하거나 코드를 확인하세요.\n\n이미지 출처: 본 게시물의 모든 이미지는 저자가 제작했습니다.\n\n\n\n## 참고 자료\n\n- [Dataform 소개 페이지](https://cloud.google.com/dataform?hl=ko)\n- [Dataform 이전 가이드 문서](https://cloud.google.com/dataform/docs/migration)\n- [Dataform 모범 사례 문서](https://cloud.google.com/dataform/docs/best-practices)","ogImage":{"url":"/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_0.png"},"coverImage":"/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_0.png","tag":["Tech"],"readingTime":7},{"title":"쿠버네티스 배포와 ArgoCD NGINX를 사용한 실전 예제","description":"","date":"2024-05-15 15:51","slug":"2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX","content":"\n\n<img src=\"/assets/img/2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX_0.png\" />\n\n쿠버네티스 배포는 복잡할 수 있지만, ArgoCD와 같은 도구를 사용하면 프로세스가 훨씬 순조롭게 진행됩니다. 이 안내서에서는 ArgoCD를 사용하여 쿠버네티스에 NGINX 웹 서버를 배포하는 방법을 실용적인 코딩 예제와 함께 안내해 드리겠습니다.\n\n- ArgoCD 설정하기:\n제공된 YAML 매니페스트를 사용하여 쿠버네티스 클러스터에 ArgoCD를 설치합니다. 이는 ArgoCD가 애플리케이션을 원활하게 관리할 수 있도록 설정해 줍니다.\n\n```js\n# ArgoCD 설치 YAML\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: nginx-app\n  namespace: argocd\nspec:\n  destination:\n    namespace: default\n    server: 'https://kubernetes.default.svc'\n  project: default\n  source:\n    path: nginx\n    repoURL: 'https://github.com/yourusername/your-repo.git'\n    targetRevision: HEAD\n  syncPolicy:\n    automated: {}\n```\n\n\n\n2. 애플리케이션 구성 정의하기:\nNGINX 배포 구성을 정의하는 nginx.yaml 파일을 생성하세요.\n\n```yaml\n# NGINX 배포 구성 (nginx.yaml)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n```\n\n3. GitOps 워크플로우 따르기:\nnginx.yaml 파일을 Git 저장소에 커밋하여 ArgoCD의 동기화 프로세스를 실행하세요.\n\n```bash\n# Git에 변경 사항 커밋하고 푸시하기\ngit add nginx.yaml\ngit commit -m \"NGINX 배포 구성 추가\"\ngit push origin main\n```\n\n\n\n4. 모두를 동기화 유지하기:\nArgoCD는 Git 저장소의 변경 사항을 자동으로 감지하고 원하는 상태를 Kubernetes 클러스터와 동기화합니다.\n\n```js\n# 응용 프로그램 동기화 상태 확인\n argocd app get nginx-app\n```\n\n5. 배포 문제 처리:\n문제가 발생하면 ArgoCD를 사용하여 서비스 연속성을 유지하기 위해 원할한 롤백 또는 롤포워드 작업을 수행할 수 있습니다.\n\n```js\n# 이전 상태로 롤백\n argocd app rollback nginx-app\n```\n\n\n\n\n# 새로운 버전으로 롤포워드\n argocd app rollforward nginx-app\n\n\n6. 워크플로우 사용자화하기:\nArgoCD를 사용하여 CI/CD 파이프라인, 모니터링 시스템 또는 알림 서비스와 통합하여 필요에 맞게 맞춤 설정하세요.\n\nArgoCD는 Kubernetes 배포를 간소화하는 데 사용되며, 기본 통합, 간단한 구성, GitOps 워크플로우, 자동 동기화, 롤백/롤포워드 기능 및 확장성을 제공합니다. ArgoCD를 채택함으로써 팀은 배포 프로세스를 최적화하고 생산성을 높이며, Kubernetes 클러스터에서 실행되는 응용 프로그램의 신뢰성과 확장 가능성을 보장할 수 있습니다. ArgoCD로 뛰어나게 Kubernetes 여정을 시작해보세요!\n\n관련 기사: Kubernetes 환경에서 ArgoCD가 필수적인 이유\n\n\n\n\n행복한 코딩하세요 🙂","ogImage":{"url":"/assets/img/2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX_0.png"},"coverImage":"/assets/img/2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX_0.png","tag":["Tech"],"readingTime":3},{"title":"개발 컨테이너 - 왜 필요하고 어떻게 개발 환경을 변화시키는지","description":"","date":"2024-05-15 15:49","slug":"2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment","content":"\n\n소프트웨어 개발 세계에서 일관성 있는 신뢰할 수 있는 개발 환경은 생산성과 효율성에 중요합니다. 전통적인 로컬 개발 환경은 모든 것을 수동으로 설치하는 것으로, 호환성 문제, 의존성 및 버전 충돌 문제, 그리고 광범위한 설정과 구성이 필요한 문제에 직면할 수 있습니다. 여기서 도커 개발 컨테이너가 나오면 개발 경험을 혁신할 수 있습니다.\n\n🇧🇷 Portuguese version here!\n\n![이미지](/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_0.png)\n\n## 도커 개발 컨테이너란 무엇인가요?\n\n\n\n특정 프로젝트를 만들기 위한 모든 도구가 들어 있는 상자를 상상해 보세요. 목공에 필요한 공구 상자처럼 망치, 톱 등이 들어 있습니다. Docker 개발 컨테이너는 이와 같은 상자와 비슷하지만 소프트웨어 개발을 위한 것입니다. 가상 환경에 사전 설치된 필수 소프트웨어가 모두 포함되어 사용할 준비가 된 상태입니다.\n\nDocker 개발 컨테이너는 Docker 기술을 활용하여 완전한 개발 환경을 포장한 가벼운, 격리된 환경입니다 (당신의 공구 상자!). 이러한 컨테이너는 특정 프로젝트를 개발하는 데 필요한 모든 도구, 라이브러리 및 런타임 구성을 캡슐화합니다. 개발자가 개발 컨테이너를 실행하면 로컬에서 작업한 코드 변경 사항이 클라우드로 배포될 때나 여러 사람이 함께 작업할 때와 동일하게 잘 작동함을 보장합니다.\n\n# 일관되고 재사용 가능한 환경\n\n개발 컨테이너를 사용하면 팀 내 모든 사람이 자신이 사용하는 컴퓨터에 상관없이 동일한 설정을 사용할 수 있습니다. 모두가 약간 다른 오븐과 재료로 케이크를 구워야 하는 대신, 개발 컨테이너는 모두가 정확히 같은 오븐과 같은 레시피를 사용하도록 보장합니다. 이는 한 명이 작업한 프로젝트가 다른 사람에게도 동일하게 작동하며, 새 팀원이 합류할 때 자신의 환경을 처음부터 설정하지 않고도 즉시 코딩을 시작할 수 있음을 의미합니다.\n\n\n\n# Visual Studio Code에서 개발 컨테이너 확장 기능 사용하기\n\nVisual Studio Code의 Dev Containers 확장 기능을 사용하면 개발 컨테이너를 쉽게 다룰 수 있어요. 이렇게 사용하는 방법에 대해 간단히 설명해 드릴게요:\n\n- 복잡한 설정을 건드릴 필요 없이 VS Code 내에서 새로운 개발 컨테이너를 설정할 수 있어요. 미리 만들어진 템플릿 중 하나를 사용하거나 직접 정의해서 시작할 수 있어요.\n- 이 확장 기능을 사용하면 다른 개발 환경간에 매끄럽게 전환할 수 있어요. 여러 대의 컴퓨터 환경을 여러 개 설정하지 않아도 되고, 일반적으로 발생하는 복잡함이 없어요.\n- 코드 작업은 로컬 데스크탑에서 작업하는 것과 같아요. 실제 코드가 컨테이너 안에서 실행되더라도, VS Code 내에서 프로젝트를 수정, 실행, 디버그할 수 있어요. 이미 익숙한 인터페이스를 통해 작업할 수 있어요.\n\n\n\n`devcontainer.json` 파일은 실제로 개발 컨테이너의 청사진입니다. 개발 환경에 필요한 모든 것을 지정합니다. \n\n- 사용할 기본 이미지: 이는 개발 환경의 \"OS\"를 선택하는 것과 같습니다. 간단한 Ubuntu 환경이나 좀 더 사용자 정의된 것이 될 수 있습니다.\n- 필요한 소프트웨어: 컨테이너에 미리 설치되어야 하는 모든 도구와 프로그램을 나열합니다. 이는 이러한 설정을 수동으로 설정하는 시간을 낭비하지 않아도 된다는 것을 의미합니다.\n- 설정과 확장: 파일은 또한 VS Code의 구성 설정을 포함하거나 자동으로 설치되어야 하는 확장을 나열할 수도 있습니다.\n\n이 구성 파일을 사용하면 누구나 이 개발 컨테이너를 사용할 때 개인 컴퓨터에 관계없이 정확히 동일한 설정을 가질 수 있으며, \"내 컴퓨터에서는 잘 되는데\" 문제를 피하는 데 도움이 됩니다.\n\n제 CDK에 관한 글에서 devcontainer.json을 살펴보겠습니다:\n\n\n\n```json\n{\n    \"name\": \"aws-dev-container\",\n    \"image\": \"mcr.microsoft.com/devcontainers/typescript-node:1-18-bookworm\",\n    \"features\": {\n        \"ghcr.io/devcontainers/features/aws-cli:1\": {},\n        \"ghcr.io/devcontainers-contrib/features/aws-cdk:2\": {}\n    },\n    \"customizations\": {\n        \"vscode\": {\n            \"extensions\": [\n                \"dbaeumer.vscode-eslint\",\n                \"eamodio.gitlens\",\n                \"firsttris.vscode-jest-runner\",\n                \"ryanluker.vscode-coverage-gutters\",\n                \"humao.rest-client\"\n            ]\n        }\n    },\n    \"remoteUser\": \"root\"\n}\n```\n\n- name: 이 키는 여러 개의 컨테이너 중에서 쉽게 식별할 수 있게 도와주는 개발 컨테이너의 친근한 이름을 할당합니다.\n- image: 개발 컨테이너의 기본으로 사용할 Docker 이미지를 지정합니다. 이것은 운영 체제와 미리 설치된 언어나 프레임워크를 결정합니다. 위 예에서는 이미 NodeJS와 Typescript가 설치된 이미지를 사용했습니다.\n- features: 이것이 개발 컨테이너의 가장 좋은 ... 기능 중 하나입니다. \"기능\"은 컨테이너에 자동으로 설치되는 추가적인 도구나 유틸리티입니다. 이것들은 일반적으로 특정 기능을 가진 컨테이너의 기본 기능을 확장하기 위해 사용됩니다. 이 예에서는 AWS CLI와 CDK를 추가했습니다. 컨테이너에 추가할 수 있는 전체 기능 목록을 여기에서 찾을 수 있습니다.\n- customizations: VS Code를 위해 개발 환경을 사용자 정의할 수 있게 합니다.\n- extensions: 컨테이너에 자동으로 설치할 VS Code 확장 목록을 나열합니다. 수동으로 설정하지 않고 개발 경험을 향상시키는 데 사용됩니다.\n- remoteUser: 컨테이너 내에서 VS Code 서버가 실행될 기본 사용자를 지정합니다. 이는 컨테이너 내 파일과 프로세스에 대한 권한 및 액세스에 영향을 미칩니다. 예를 들어 root는 일반적으로 컨테이너 내의 모든 것을 수정할 수 있는 루트 사용자로 작동한다는 것을 의미합니다.\n\n# 개발 컨테이너 사용\n\n개발 컨테이너를 사용하려면 먼저 Dev Containers 확장을 설치해야 합니다.\n\n\n\n\n디브 컨테이너 구성 파일(devcontainer.json)은 프로젝트의 루트인 .devcontainer 폴더에 위치합니다.\n\n이 구성으로 처음으로 프로젝트를 열 때 VS Code가 제안을 안내해줍니다.\n\n![이미지](/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_1.png)\n\nVS Code는 컨테이너 구성을 감지하고 프로젝트를 컨테이너 내에서 열지 원하는 지 물어봅니다. \"컨테이너에서 다시 열기\"를 선택하면 Docker 이미지와 컨테이너가 생성됩니다. 화면이 다시 로드되고 VS Code가 컨테이너에 연결됩니다.\n\n\n\n\"Command Palette\"를 통해 컨테이너를 빌드/재빌드할 수도 있습니다.\n\n![이미지](/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_2.png)\n\n컨테이너가 생성되면, devcontainer.json 구성에 설명된 대로 환경을 갖게 됩니다.\n\n# devcontainer.json을 사용한 기본 구성\n\n\n\ndevcontainer.json 파일은 dev container 구성의 핵심입니다. 위에서 보신 것처럼 다양한 설정 및 기능을 직접 지정할 수 있어 개발 환경을 쉽게 설정하고 \"features\"로 매우 사용자 정의할 수 있습니다.\n\n# Dockerfile로 고급 설정하기\n\n더 많은 사용자 정의 및 모듈식 설정이 필요한 경우 Dockerfile을 가리키는 방식으로 devcontainer.json 구성을 확장할 수 있습니다. 이 방법을 통해 환경에 대한 보다 큰 유연성과 제어가 가능해집니다.\n\n```json\n{\n    \"name\": \"aws-dev-container\",\n    \"build\": {\n        \"dockerfile\": \"Dockerfile\"\n    },\n    \"customizations\": {\n        \"vscode\": {\n            \"extensions\": [\n                \"dbaeumer.vscode-eslint\",\n                \"eamodio.gitlens\",\n                \"firsttris.vscode-jest-runner\",\n                \"ryanluker.vscode-coverage-gutters\",\n                \"humao.rest-client\"\n            ]\n        }\n    },\n    \"remoteUser\": \"root\"\n}\n```\n\n\n\n질문이나 제안이 있으면 댓글을 남겨주세요. 함께 배우는 모두에게 도움이 될 거에요! 🤠","ogImage":{"url":"/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_0.png"},"coverImage":"/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_0.png","tag":["Tech"],"readingTime":5},{"title":"RAG 모델 구축하기  Databrick으로 쉽게 만들기","description":"","date":"2024-05-15 15:48","slug":"2024-05-15-RAGyourmodelSimplifiedwithDatabrick","content":"\n\n# RAG 이론 (간단 버전)\n\n언어 모델이 지식을 배우는 몇 가지 방법이 있습니다. 전통적으로는 모델을 처음부터 훈련하거나 기존 모델을 세밀 조정하는 방법이 있습니다. 이는 모델 가중치를 업데이트하여 모델을 더 훈련시키는 것을 의미합니다. 다른 방법은 상대적으로 새롭고 직접적으로 프롬프트 공학과 연관이 있습니다. 여기서는 지식을 모델 입력값으로 전달합니다. 모델은 이를 문맥으로 편입하여 지식을 통합합니다. 왜 모델에 처음부터 문맥을 전달하는 걸까요? 모델에게 문맥을 전달하는 것은 모델에게 오픈 노트로 시험을 보는 것과 같습니다. 모델은 참고할 사실을 손에 넣게 됩니다. 다만 전달할 수 있는 문맥의 크기에는 제한이 있습니다. 보통 5 페이지이며, 이는 대부분의 산업용 사례에 부족할 정도입니다. 그래서 모델 문맥 문제용 새로운 모델 구조 - 'RAG'가 등장했습니다!\n\n# RAG 아키텍처—\n\nContext 데이터/지식을 임베드된 벡터로 변환하고 이를 저장하는 모델(임베딩 모델)을 추가(Vector 스토어). 쿼리(프롬프트)가 전달되면 프롬프트를 캡처하여 임베드된 벡터로 변환하고, 저장소에서 유사한 벡터를 찾아 메인 모델에게 컨텍스트 강화된 프롬프트(쿼리 벡터 + 저장소로부터의 유사 벡터)를 전달합니다. 이것이 여러분이 제공한 문맥을 통합하여 정확한 응답을 생성하는 RAG입니다.\n\n\n\n아래는 Markdown 형식으로 변경된 표입니다.\n\n\n![이미지](/assets/img/2024-05-15-RAGyourmodelSimplifiedwithDatabrick_0.png)\n\n# RAG의 세부 내용:\n\nRAG는 다음과 같은 네 가지 주요 구성 요소로 구성됩니다:-\n\n1. 벡터 검색 - 주의할 점은 우리가 아무런 검색을 하기 전에 문맥/지식을 임베딩 벡터로 변환한다는 것입니다. 모든 데이터 객체인 오디오, 비디오 또는 텍스트는 임베드 벡터로 변환되어 벡터 저장소에 저장될 수 있습니다.\n  \n\n\n\n두 가지 종류의 검색이 있습니다. 정확한 검색과 근사 검색. 이름에서 알 수 있듯이 정확한 검색은 가장 가까운 방법을 찾는 무차별 대입 방법입니다. 전통적인 KNN과 유사합니다. 반면에 근사 검색은 가장 가까운 이웃을 찾는 데 정확도가 낮지만 속도가 빠릅니다. 가장 인기 있는 벡터 검색 알고리즘은 ANN을 사용합니다.\n\n공통의 인덱싱 알고리즘은 몇 가지 있습니다 — Spotify의 ANNOY(트리 기반), Facebook의 FAISS(클러스터링), LSH(해싱), 그리고 Google의 SCaNN(벡터 압축). 이러한 알고리즘들은 모두 효율적인 검색을 수행하기 위한 모든 필요한 정보를 보유한 vector Index라는 데이터 구조를 반환합니다.\n\n2. Vector Store: 벡터를 저장하는 데 사용하는 두 가지 전략이 있습니다. 하나는 가벼운 벡터 라이브러리를 사용하는 것이고, 다른 하나는 고급 기능을 제공하는 벡터 데이터베이스를 사용하는 것입니다.\n\n- 벡터 라이브러리: 벡터 인덱스를 생성하고 이 인덱스는 메모리에 저장됩니다. 라이브러리는 일반적으로 작고 정적인 데이터에 대해 충분합니다. 저장된 벡터에 대한 CRUD 작업을 지원하지 않습니다. 즉, 데이터가 변경될 때마다 인덱스를 다시 만들어야 합니다. 데이터 복제가 없습니다.\n\n\n\nb. 벡터 데이터베이스 — 다른 한편으로는 구조화되지 않은 데이터를 저장하는 데 특화된 데이터베이스입니다. 데이터베이스의 CRUD 속성을 상속하며 오프라인에서 색인을 사전 처리하고 나서 벡터를 데이터베이스에 저장하여 모델에 온라인으로 제공할 수 있도록 합니다.\n\n3. 필터링 — 필터링은 생성 프로세스에 통합하기 전에 검색된 지식 베이스에서 관련 정보를 선택하고 우선순위를 정하는 메커니즘을 참조합니다. 이를 통해 검색된 컨텍스트가 정보를 제공할 뿐만 아니라 일관성 있고 맥락에 부합하는 응답을 생성하는 데 도움이 됩니다.\n\n세 가지 전략 — Pre-Query, In-Query, Post-Query 필터링.\n\n4. 프롬프트 엔지니어링 — LLM에 응답 생성이나 작업 완료를 요청하는 텍스트입니다. 원하는 출력을 생성하도록 모델을 안내하는 명확하고 구체적이며 잘 구조화된 입력을 작성하는 것을 포함합니다. 모델이 사실을 찾지 못했을 때 억지로 내용을 만들지 않도록 안내하는 지침을 제공하는 것, 예시와 데모 사용, 그리고 더 중요한 것은 작업을 더 잘 이해할 수 있도록 맥락을 제공하는 것을 모두 포함합니다. 위에서 설명한 RAG 워크플로우에 주목하세요. 마지막으로, 우리는 맥락 문서를 프롬프트를 통해 모델에 전달하고 있기 때문에 RAG가 프롬프트 엔지니어링과 밀접하게 연관되어 있다고 할 수 있습니다.\n\n\n\n# RAG Nvidia/Llama3 model with Databricks\n\n## Assets -\n\nModel - nvidia/Llama3-ChatQA-1.5-8B ([링크](https://huggingface.co/nvidia/Llama3-ChatQA-1.5-8B))\n\nVector Database - ChromaDb\n\n\n\nDatabricks ML 런타임 -13.3.x-cpu-ml-scala2.12 / 13.3.x-gpu-ml-scala2.12\n\n이 두 Databricks 런타임은 호환됩니다. 그러나이 모델은 8B 매개변수를 가지고 있어 노트북에서 추론을 위해 로드하기에 너무 큽니다. 충분한 메모리와 코어가 있는 CPU 머신에서 응답을 생성하는 데 오랜 시간이 걸렸습니다. 당신의 요구에 적합하고 예산에 맞는 런타임을 선택하세요.\n\n## 데모 -\n\n감사합니다.","ogImage":{"url":"/assets/img/2024-05-15-RAGyourmodelSimplifiedwithDatabrick_0.png"},"coverImage":"/assets/img/2024-05-15-RAGyourmodelSimplifiedwithDatabrick_0.png","tag":["Tech"],"readingTime":3},{"title":"폭풍 속을 네비게이팅하며 소프트웨어 엔지니어로서 가장 어려웠던 순간","description":"","date":"2024-05-15 15:46","slug":"2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer","content":"\n\n## 소프트웨어 엔지니어링, 성장\n\n![Image](/assets/img/2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer_0.png)\n\n작년, 소프트웨어 아키텍처에 관한 에버하르트 볼프의 팟캐스트에서 특별한 기회를 가졌습니다.\n\n최근에 에버하르트가 다시 초대해 \"일로서의 소프트웨어 아키텍처\"에 대해 깊이 탐구하는 시간을 가졌는데, 12가지 생각할 거리 질문에 대답을 해야했습니다. 그중 한 질문이 돋보여 제가 잠시 망설이게 했습니다:\n\n\n\n이제, 내가 경력 동안 많은 힘든 시간과 좋지 않은 순간들을 겪었다는 것을 알려줄게. 그것은 우리 모두가 경험하는 일이야. 하지만 젊은 전문가들이 다음과 같은 친절한 말로 나에게 다가오면:\n\n- \"당신으로부터 배우고 싶어요,\"\n- \"멘토가 되어주세요?\"\n- 또는 \"당신은 소프트웨어 산업에서 귀중한 자산이에요,\"\n\n내가 종종 마음속으로 생각한다. \"그들이 내가 겪은 모든 좌절과 실패에 대해 알고 있다면 참 좋겠다.\" 그들은 내가 몇 번이나 직장을 해고당했는지 알아주겠는가? 아마 그렇지 않을 거야.\n\n내 불행했던 전문가 경험 중에서, 에버하르트의 질문에 대답하기 위해 가장 나쁜 순간을 선택해야 했어. 처음에는 간단한 대답이 될 거라고 생각했던 것이 기사로 공유할 만한 내러티브가 되었거든.\n\n\n\n그래서, 자리를 잡고 함께해요.\n\n# 초기 어려움\n\n많은 사람과 마찬가지로, 제 직업 시작은 가파른 학습 곡선과 사기 신드롬의 변화로 가득했습니다. 평범할 수 있지만, 이러한 어려움은 각 개인마다 고유하며 자신의 자신감, 단호함, 취약성 및 커뮤니케이션 기술 수준에 의해 형성됩니다.\n\n독일로 이사를 가서 새로운 언어로 일하다보니 고유한 어려움이 있었습니다. 내 능숙도 부족으로 소통 문제가 생기고, 그 당시에는 소프트 스킬이 미숙해서 더 어려웠죠.\n\n\n\n하지만, 가장 힘든 전문적 순간은 아직 오지 않았어요.\n\n# 가장 어려웠던 순간\n\n수천 명의 사용자와 약 5,000 QPS(초당 쿼리 수)를 처리하는 시스템에서 AWS DevOps 개발자로 첫 직장을 시작했을 때가 제 경력 중 가장 어려운 시기로 기억됩니다. 그 당시에는 AWS에 대한 경험이 실제보다 이론적인 면이 더 많았고, 파이썬에 대한 배경 지식이 없었습니다.\n\n갑자기 나는 Java와 Python으로 구현된 약 60개의 마이크로서비스가 있는 복잡한 시스템에 던져졌고, Axon Server를 사용한 CQRS와 이벤트 주도 아키텍처를 사용하고 있었습니다.\n\n\n\nIaC, Terraform, Fargate, EKS, CloudWatch 및 실시간 지표를 표시하는 대규모 Grafana 대시보드와 같은 용어들에 둘러싸인 새내기 같은 느낌을 받았습니다. 정말 압도되었죠.\n\n그중에서도 가장 어려웠던 점은 무엇일까요?\n\n저는 주니어 개발자가 아니었습니다. 소프트웨어 엔지니어로 10년 이상 경험을 쌓은 저는 기술적 역량에 확신을 갖게 되었고, 종종 동료들에게 조언하고 지도해왔습니다.\n\n제 기술을 자신하며 적극적이고 쉽게 이 복잡한 시스템을 탐험할 수 있기를 기대했지만, 새로운 기술을 습득하는 시간은 주니어 개발자에 비해 제한적이었습니다.\n\n\n\n우리 팀은 이미 시스템에 익숙했지만, 나의 직면한 복잡성을 보지 못했습니다. 그 결과로 저의 노고와 성과에 대한 압박이 더욱 심해졌죠.\n\n# 새로운 도구에 압도되다\n\n일반적으로 소스 코드를 검토하고 분석하는 초기 날들을 보내야 할 터였지만, 나는 자주 구글에 다음과 같은 질문을 하게 되었습니다:\n\n- Tasklib은 무엇인가요?\n- Terraform은 무엇인가요?\n- 인프라스트럭처와 코드란 무엇인가요?\n- Axon Server는 무엇이며, 왜 관계형 데이터베이스를 대체할 수 있을까요?\n- LocalStack은 무엇인가요?\n- Grafana와 CloudWatch가 어떻게 함께 작동할까요?\n- 일부 람다 함수가 Python으로 작성된 이유와 다른 함수들이 Java로 작성된 이유는 무엇일까요?\n- 람다와 파게이트(Fargate)의 차이점은 무엇이며, 언제 파게이트를 선택하는 것이 더 좋나요?\n- Flask는 무엇인가요? 파이썬 앱을 람다에서 Flask로 변경하는 방법은 무엇인가요?\n- AWS에서 Flask를 위한 서비스가 있나요?\n\n\n\n이 프로젝트 특정 구현에 대한 질문이어야 했던 이 질문들은 도구와 개념 자체에 대한 기본 문의였어요.\n\n# 산업 전문가들의 인사이트\n\nKlotho의 공동 창업자이자 이전 Microsoft 및 Riot 엔지니어인 Ala Shiban과의 대화를 기억했습니다. 그는 현대 클라우드 및 인프라 기술이 FAANG 수준의 기술 전문가를 필요로 한다고 언급했는데, 이는 항상 기능 개발 속도를 높이지는 않는다고 했습니다.\n\n제가 생산적으로 얼마나 오랜 시간이 걸릴지 궁금해서 AWS 인증을 받은 친구에게 연락했어요.\n\n\n\n\"AWS 자격증 시험을 준비하는 데 얼마나 시간이 걸릴까요? 1주일이면 충분한가요?\" 제가 물었습니다.\n\n\"1주일?!\" 그는 놀라며 대답했습니다.\n\n\"아니면 2~3일만에 가능할까요,\" 제가 농담을 했습니다.\n\n그는 웃으며 \"적어도 한 달은 걸릴 것 같아요\" 라고 말했습니다.\n\n\n\n# 도전에 맞서보기\n\n나의 여정을 되돌아보며, 내 처음의 자신감이 내 역량과 시장 상황에 대한 잘못된 가정에 바탕을 두고 있음을 깨달았다. 기술적 변화의 빠른 속도에 맞추기 위해 필요한 복잡성과 고통을 과소평가했다.\n\n하지만 가치 있는 교훈도 얻었다. 내가 깨우친 것은 심층적인 도메인 지식의 중요성과 지속적인 학습의 필요성이었다. 나는 애플리케이션에 대한 고민을 인프라에 대한 것으로부터 분리하여 개발 프로세스를 간소화하는 Klotho와 같은 도구를 탐색하기 시작했다.\n\n# 앞으로 나아가기\n\n\n\n요약하자면, 제가 경험한 최악의 전문적인 순간은 도전으로 가득 찼지만, 결국 그것이 저의 개인적이고 전문적인 성장의 길을 열어 주었습니다.\n\n경력에서 어려운 시기를 겪고 있다면, 이러한 경험들이 더 큰 성공으로 나아가는 발판이 될 수 있다는 것을 기억해 주세요. 도전을 받아들이고 그것으로부터 배우며, 계속 전진해 나가세요.\n\n괴물에 대항하는 법을 배우기 위해 기다리지 말고 이미 앞서서 준비를 하세요. 적극적으로 행동하고 호기심을 가지며 계속해서 발전해 나가세요.\n\n이 이야기가 여러분에게 자신의 도전에 참을성 있게 이겨 나가도록 영감을 주고, 그 동안 배운 교훈의 가치를 인지할 수 있기를 바랍니다.\n\n\n\n# 더 알고 싶으세요?\n\n🧠💡 저는 공학, 기술, 리더십에 대해 똑똑하고 호기심 많은 사람들을 위한 커뮤니티에 글을 씁니다. 제 이메일 뉴스레터에 가입하시면 제 비디오 강의에 무료로 액세스할 수 있는 기회를 드립니다 📚.","ogImage":{"url":"/assets/img/2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer_0.png"},"coverImage":"/assets/img/2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer_0.png","tag":["Tech"],"readingTime":4},{"title":"Dev Log  Unity GAS를 사용하여 더 많은 능력 구성하기","description":"","date":"2024-05-15 15:44","slug":"2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS","content":"\n\n# 개요\n\n이전의 개발일지에서 Unreal Gameplay Ability System의 매우 기본적인 개념적 개요, 사용 중이며 확장 중인 Unity GAS 구현의 구체적인 내용, 그리고 프레임워크 내에서 구성된 몇 가지 기본 능력 예제를 제공했습니다. 이 기사에서는 몇 가지 더 간단한 능력들을 논의하고 GAS 내에서 어떻게 구현했는지에 대해 알아보겠습니다.\n\n# 요약\n\n이전에 논의된 대로, 내가 작업 중인 첫 번째 플레이어 클래스는 스택 메커니즘을 기반으로 하고 있습니다. 플레이어가 적에게 특정 방식으로 영향을 미치면(기본 공격 데미지 또는 특정 능력 효과), 적에게 5초 동안 스택이 추가됩니다. 동일한 적에 4개의 스택이 누적되면 추가 데미지가 입히고 스택이 지워지며 몇 초 동안 Mark 상태 효과로 대체됩니다. 이 논리를 보여주는 GIF는 다음과 같습니다:\n\n\n\n이 스태킹 메커니즘은 이 배 클래스의 기초가 되도록 의도되어 있어, 이 클래스의 대부분의 능력 효과는 적들에게 스택이 쌓인 상태에 의존하게 될 거에요. 예를 들어, 저번 데브로그에서 다룬 첫 번째 능동 능력은 스택이 적용된 적들 주변을 데미지를 입히고 기절시킵니다. 데미지와 기절 지속 시간은 주어진 적의 스택 수에 따라 증가합니다. 아래는 이 능력의 모습을 시각적으로 보여드린 그림입니다:\n\n# 플레이어 능력 세트 완성하기\n\n이 배의 처음 몇 가지 능력은 좋은 시작이지만, 분명 플레이어는 더 많은 옵션이 필요할 거에요. 저는 현재 GAS 구현에서의 작업 흐름을 개발하기 위해 몇 가지 추가 능력을 프로토타입으로 만들었어요. 일단, 플레이어는 잠정적으로 세 개의 능력 슬롯에 액세스할 수 있고, 이를 잠긴 능동 능력 집합에서 선택해 채울 수 있게 될 거에요. 앞서 언급한 능력을 포함하여 이러한 능력들이 있어요:\n\n## 스택 기반 힐링\n\n\n\n- 플레이어가 받는 데미지를 잠시 동안 줄이고 범위 내의 적의 패시브 스택을 소비하여 해당 스택이 소모된 만큼 플레이어를 치유함\n- 지속력을 위해 사용하거나 갑작스러운 대미지 발생을 완화하는 데 사용될 수 있음\n\n## 폭발성 발사체\n\n- 접촉 시 추가로 데미지를 입히는 대형 직진 발사체로, 접촉 시 폭발하며 범위 내에서 추가로 데미지를 입힘\n- 주로 대규모 피해를 입히려고 사용되며, 접촉과 폭발 데미지는 별개의 데미지 타입이므로 초기 발사체에 맞은 적은 사실상 추가 데미지와 함께 2개의 패시브 스택을 받음\n\n## 충격 탑\n\n\n\n- 매 초 틱을 하는 작은 물체를 소환하여 주변 적들을 간단히 중심으로 끌어안는다\n- AoE 콤보나 철회를 위한 집합/CC 능력으로 사용할 수 있다\n\n이전 로그를 읽어 보셨다면, 어떻게 이러한 능력들이 구현될 수 있는지 대략적인 개념을 이미 가지고 있을 것입니다. 현재의 GAS 워크플로우와 가까운 미래에 개선할 수 있는 통증점과 가능한 개선점을 이해하기 위해 조금 더 깊게 파고들어 보겠습니다.\n\n# 스택 기반 치유 구현\n\n가장 복잡한 것부터 시작해 보죠. 이 능력은 이전 기사에 구현된 스택 기반 스턴 능력과 유사하게 작동합니다. 그러나 능력이 활성화될 때 일부 추가 작업이 필요하다는 점에서 추가 복잡성이 조금 더 있습니다. 위의 설명을 다시 요약해보면, 이 능력은 \"일부 초 동안 플레이어가 받는 피해를 줄이고 범위 내의 적들로부터 패시브 스택을 소비하여, 소비된 스택에 기반하여 플레이어를 회복하는\" 기능을 합니다. 즉, 능력이 활성화될 때 다음을 해야 합니다:\n\n\n\n- 플레이어 주변 범위 내의 모든 적 캐릭터를 대상으로 총 스택 인스턴스 수를 결정합니다.\n- 잠정적으로 플레이어가 받는 피해를 줄입니다.\n- 주변 적 캐릭터의 총 스택 수에 기반하여 플레이어를 회복합니다.\n- 범위 내의 각 적 캐릭터에서 기존 스택(마크를 제외한)을 제거합니다. 능력은 영향을 받는 적 캐릭터로부터 스택을 소모하며, 스택을 소모하면 플레이어가 가할 수 있는 피해가 더 이상 줄어들어, 더 많은 스택이 적용될 때까지 플레이어가 언제 어떻게 사용할지 신중히 고려해야 합니다.\n\n다행히도 이러한 기능 대부분을 꽤 기본적인 GameplayEffect로 수행할 수 있습니다. 능력의 각 측면을 따라 최상위에서부터 작업을 시작해봅시다.\n\n다음은 검사 원격에 나타나는 능력 정의입니다:\n\n![이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_0.png)\n\n\n\n## 일정 기간 동안 플레이어의 받는 피해를 줄이기\n\n이전에 피해 증감을 조정하기 위해 애트리뷰트를 추가했기 때문에 아주 간단합니다. 플레이어의 IncomingDamageScalar 애트리뷰트를 반으로 줄이는 GameplayEffect가 필요합니다. 이후 몇 초 동안 지속됩니다:\n\n![이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_1.png)\n\n## 주변 스택 수에 따라 플레이어 치료하기\n\n\n\n이것은 가장 복잡한 측면입니다. 우리는 플레이어에 적용되는 GameplayEffect를 생성하여 각 영향을 받는 적마다 플레이어를 회복시킬 수 있습니다. 이 GameplayEffect는 현재 적의 스택 수에 기반하여 플레이어를 회복시키며, 각 적에 맞게 실행하므로 우리에게 원하는 효과를 제공합니다. 이 일을 처리하는 코드 조각은 다음과 같습니다:\n\n```js\n// apply per-enemy player gameplayEffects, e.g. healing (do this before applying enemy GEs, \n// since that will remove all stack instances which we need for healing calculations)\nforeach (var ge in typedAbilityDefinition.perEnemyPlayerGameplayEffects) {\n    // note: target is still the enemy because we want to get tags from them, not the player\n    var geSpec = Owner.MakeOutgoingSpec(ge, source: Owner, target: hitAsc);\n    Owner.ApplyGameplayEffectSpecToSelf(geSpec);\n}\n```\n\n이 GameplayEffect는 지정된 적의 스택 수를 제공하기 위해 사용자 정의 TagCountBackedModifierMagnitude를 사용하며, 다음과 같이 구성됩니다 :\n\n![이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_2.png)\n\n\n\n게임플레이 효과 자체:\n\n![게임플레이 효과 이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_3.png)\n\n## 영향받는 적에서 기존 스택 제거하기\n\n이것은 적용 시 모든 패시브 스택 태그 인스턴스를 제거하도록 구성된 간단한 게임플레이 효과를 통해 수행할 수 있습니다. 게임플레이 효과 구성은 다음과 같습니다:\n\n\n\n\n![이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_4.png)\n\n그리고 GE를 적용하는 능력 정의의 작은 부분은 이렇게 생겼어요:\n\n```js\n// apply enemy gameplayEffects\nforeach (var gameplayEffect in typedAbilityDefinition.enemyGameplayEffects) {\n    var geSpec = Owner.MakeOutgoingSpec(gameplayEffect, Owner, hitAsc);\n    hitAsc.ApplyGameplayEffectSpecToSelf(geSpec);\n}\n```\n\n여기서 설명할 내용은 대략 이 정도네요! 다음 능력으로 넘어가겠습니다.\n  \n\n\n\n\n# 폭발성 발사체 구현\n\n이 능력은 BaseProjectileAbilityScriptableObject의 인스턴스로, ASC 호스트의 WeaponSystem 구성 요소를 참조하여 WeaponConfiguration을 로드하고 무기를 발사합니다. WeaponConfiguration은 다음과 같습니다:\n\n```js\npublic class BaseWeaponConfiguration : ScriptableObject {\n    \n    // 이 무기의 발사체가 어떻게 발사될 것인가? (숫자, 분산, 각도 등)\n    public ShootConfiguration shootConfiguration;\n    \n    // 이 무기가 발사하는 발사체는 무엇인가? (프리팹, 이동 및 충돌 동작 등)\n    public ProjectileConfiguration projectileConfiguration;\n    \n    [SerializeField]\n    private List<GameplayEffectScriptableObject> onHitGameplayEffects;\n    \n    [SerializeField]\n    private List<GameplayTagScriptableObject> fireWeaponGameplayCues;\n}\n```\n\n실제 능력 구현의 관련 부분은 여기에 있습니다:\n\n\n\n```js\nprotected override IEnumerator ActivateAbility() {\n    ... // 쿨다운 적용 같은 보일러플레이트 작업\n    \n    // 능력 구성에서 GameplayEffects를 프로젝타일 구성으로 복사\n    weaponConfiguration.OnHitGameplayEffects = projectileGameplayEffects;\n    \n    // 계산된 조준 각도로 WeaponSystem 호출\n    weaponSystem.TryFireWeapon(aimAngle, weaponConfiguration);\n    \n    EndAbility();\n    yield return null;\n}\n```\n\n그거면 GAS 관련 내용이 거의 다에요! WeaponSystem 구성요소는 프로젝타일을 생성하고 설정하며, 실제 프로젝타일 프리팹은 모든 이동 및 충돌 로직을 처리하여 관심사를 명확히 구분하고 코드를 정리합니다. 만약, 프로젝타일이 어떤 것과 충돌할 때 어떤 로직을 수행해야 하는 더 복잡한 능력을 구현하고 싶다면, 충돌 게임 플레이 이벤트를 기다리고 그 후 작업을 수행하려면 AbilityTask를 시작할 수 있습니다. 아직 도달하지 못했지만, 미래 로그에서 AbilityTasks의 구현을 다루겠습니다.\n\n# 탄도 탑 구현\n\n이 능력은 주위의 RigidBody에 힘을 적용하는 개체를 생성하며, 사실상 위에서 설명한 폭발성 프로젝타일 능력과 동일한 방식으로 구현됩니다: 프리팹을 소환하기 위해 WeaponSystem을 호출합니다. 앞에서 언급한 폭발성 프로젝타일 능력과 마찬가지로, 탄도 탑 능력 정의는 매우 가볍습니다. 능력 기능의 대부분은 생성된 탑 GameObject에 있습니다. 특히, ImpulseSourceComponent가 틱할 때 힘의 강도, 작용 범위 반경을 결정합니다. 다음이 에디터에서 이 구성 요소가 어떻게 보이는지에 대한 예시입니다:\n\n\n\n\n![2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_5](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_5.png)\n\nThe actual logic is also very straightforward:\n\n- when the Ability spawns the pylon prefab, it sets its parameters such as radius, impulse strength, tick rate, and time to live\n- the ImpulseSourceComponent `Update()` determines when to tick the pylon\n- when it’s time to tick, we simply identify `RigidBody2D` instances within the pylon’s radius and apply an impulse force to them in the direction of the center of the pylon\n\nAs can be seen from the screenshot above, I’ve also added fields to allow the component to pull period and force values from the owner’s attribute system. This easily facilitates upgrades that modify the parameters of this ability — for example, one upgrade may reduce the period (thereby increasing the impulse’s trigger frequency) while also reducing the force, altering the overall function of the ability.\n\n\n\n\n# 결론\n\n지금 이 시점에서, 개념적 프레임워크로서의 GAS의 힘은 더욱 분명해지고, 이미 한 번에 처리한 보일러플레이트 작업의 가치를 볼 수 있게 됩니다. 우리는 여러 가지 다양한 능력의 구현을 더욱 탐구했으며, 시스템을 추가로 세부적으로 확장하고 개선할 수 있는 더 많은 방법들이 존재합니다. 다음 로그에서는 이러한 개선사항 중 일부에 대해 깊이 파헤치겠습니다. 예를 들어:\n\n- AbilityTasks는 여러 프레임에 걸쳐 동작하는 능력을 가능하게 하며, 능력이 이벤트에 반응할 수 있는 콜백 스타일 메커니즘을 제공합니다. 예를 들어, 우리가 플레이어를 치유하는 업그레이드를 원할 때, 주변의 가시적 마법진이 사라질 때 플레이어를 치유하는 능력이있다면, 해당 마법진 GameObject가 비활성화되고 풀로 반환될 때 일부 로직을 트리거하는 AbilityTask를 생성할 수 있습니다.\n- GameplayCues는 GameplayEffects 및 Abilities가 단순히 구성에 특정 GameplayTags를 포함시킴으로써 애니메이션, 사운드 또는 입자 효과를 재생할 수 있는 기능을 제공합니다.\n\n읽어 주셔서 감사합니다. 다음에 만나요!","ogImage":{"url":"/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_0.png"},"coverImage":"/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_0.png","tag":["Tech"],"readingTime":8}],"page":"93","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}