{"pageProps":{"posts":[{"title":"Nestjs 오류 처리","description":"","date":"2024-06-19 23:16","slug":"2024-06-19-NestjsErrorHandling","content":"\n\n<img src=\"/assets/img/2024-06-19-NestjsErrorHandling_0.png\" />\n\n# 1. 소개\n\nNestJs는 백엔드 시스템을 개발하는 데 사용되는 프레임워크입니다. 이 프레임워크는 컨트롤러 레이어에서 오류 처리에 대한 규칙을 정의했지만, 이는 대규모 프로젝트에는 충분하지 않을 수 있습니다. 본 문서에서는 오류를 우아하게 처리하고 신중하게 대우하는 더 효과적이고 구조화된 접근 방식을 소개합니다.\n\n# 2. 오류 처리 전략\n\n<div class=\"content-ad\"></div>\n\n# 에러 유형\n\n코드에서 발생할 수 있는 에러 유형을 정의해보겠습니다:\n\n- 유효성 검사 에러\n- 제삼자 에러\n- 데이터베이스 에러\n- 일반(예기치 않은) 에러\n\n언급된 모든 종류의 에러에 특히 주의해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n특정 오류, 예를 들어 유효성 검사 오류와 같은 경우 적절한 응답이나 상태 코드로 처리할 수 있습니다. 그러나 일반 오류와 같은 다른 종류의 오류의 경우, 유지보수자에게 알리거나 높은 우선순위로 티켓을 생성하는 등의 추가 조치가 필요할 수 있습니다. 또 다른 오류 유형인 데이터베이스 오류는 복구와 복원 논리가 필요할 수 있습니다.\n\n# 3. 다른 계층에서의 오류 처리\n\n저는 우리의 응용프로그램 계층을 다음과 같이 분류하는 것을 선호합니다:\n\n- 요청 계층\n- 인터셉터\n- 가드\n- 컨트롤러 계층(*)\n- 서비스 계층\n- 모델\n- 데이터베이스\n- 예외 처리 계층\n\n<div class=\"content-ad\"></div>\n\n컨트롤러 레이어 아래의 모든 레이어에서 오류가 발생하면 상위 레이어로 throw해야 합니다. 예를 들어:\n\n- 데이터베이스 CRUD 함수(ORM 함수 등)에서 오류가 발생하면 Database Error 유형을 throw해야 합니다.\n- 서드파티 호출(Stripe 등)에서 오류가 발생하면 Third-party 에러 유형을 throw해야 합니다.\n- 예기치 않은 오류가 발생하면 Generic 에러 유형으로 간주해야 합니다.\n- 등등\n\n```js\nasync sampleFucntion(@AuthenticatedUser() jwtPayload: JwtDto) {\n        try {\n            return this.utilsService.apiResponse(200, await this.sampleService.sampleServiceFucntion(jwtPayload.id))\n        } catch (error) {\n            this.utilsService.handleError(error, jwtPayload, {}, 'description')\n        }\n    }\n```\n\n언급한 모든 오류는 상위 레이어로 throw되어야 하며, throw된 오류를 받은 해당 레이어도 Controller 레이어가 `try-catch` 블록에서 오류를 받게 될 때까지 throw해야 합니다. 그런 다음 Controller 레이어는 잡힌 오류를 utils 모듈이나 errors 모듈에 포함된 `ErrorHandler` 함수로 전달해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 오류 처리기 함수\n\n이 함수는 받은 오류 유형을 Switch-case 또는 if-else 방식으로 감지하여 처리해야 합니다.\n\n```js\nhandleError(error, jwt: JwtDto, additionalInfo: any, description: string): void {\n        if (error instanceof CheckingException) {\n            throw new CheckingException(error.message, error.statusCode,error.messageData)\n        } else if (error instanceof DatabaseException) {\n            throw new DatabaseException(error.message, error, error.queryParams, description)\n        } else if (error instanceof StripeErrorException) {\n            throw new StripeErrorException(error as Stripe.errors.StripeError, error.stack, description)\n        } else if (error instanceof HttpException){\n                throw error\n        } else {\n            throw new GenericException(error.message, error, jwt, additionalInfo, description)\n        }\n    }\n```\n\n유형을 감지한 후, 각 오류 유형에 적합한 매개변수로 오류 유형을 생성하고 해당 오류를 throw해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n샘플 Exception 클래스:\n\n```js\nexport class DatabaseException extends Error {\n    queryParams: any\n    description: any\n    stack:any\n    message : string\n    constructor(message: string,error: Error, q: any, description?: string) {\n        super(`데이터베이스 오류가 발생했습니다: ${message}`)\n        this.queryParams = q\n        this.description = description\n        this.stack = error.stack\n        this.message = error.message\n    }\n}\n```\n\n특정 APP_FILTER를 정의하고 app.module에서 등록해야 합니다:\n\n```js\nproviders: [\n    {\n        provide: APP_FILTER,\n        useClass: GenericExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: checkingExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: DatabaseExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: StripeExceptionFilter,\n    },\n    AppService,\n    UtilsService,\n    JwtService,\n    LoggerService,\n]\n```\n\n<div class=\"content-ad\"></div>\n\n예외 필터에서는 이제 이러한 오류 중 하나에 완벽하게 대응해야 합니다:\n다음 조건을 고려해 주세요:\n\n- 데이터베이스 및 일반적인 오류는 유지보수자에게 알리고 처리된 오류에 대한 사용자 응답이 있어야 합니다.\n- Stripe 및 Checking(유효성) 오류는 사용자에게만 응답해야 합니다.\n\n데이터베이스 및 일반적인 오류에 대한 샘플 예외 필터:\n\n```js\n// database.filter.ts\nimport { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common'\nimport { LoggerService } from '../../../../logger/logger.service'\nimport { GenericException } from './generic.exception'\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@Catch(GenericException)\nexport class GenericExceptionFilter implements ExceptionFilter {\n    constructor(private readonly loggerService: LoggerService) {}\n    catch(exception: GenericException, host: ArgumentsHost) {\n        const ctx = host.switchToHttp()\n        const response = ctx.getResponse()\n        const errorData = {\n            description: exception.description,\n            stack: exception.stack,\n            jwtPayload: exception.jwtPayload,\n            additionalInfo: exception.additionalInfo,\n            message: exception.message,\n        }\n        this.loggerService.error(exception.message, errorData)\n        response.status(500).json({\n            statusCode: 500,\n            message: exception.message,\n            error: 'Error',\n        })\n    }\n}\n```\n\nWinston 로거를 사용하여 오류 수준 로그를 송신 및 티켓 생성을 위해 로그 전송기를 정의했습니다:\n\nthis.loggerService.error(exception.message, errorData)\n\n일반적인 오류(외부 라이브러리 또는 유효성 검사 오류)에 대한 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common'\nimport { CheckingException } from './checking.exception'\n```\n\n```js\n@Catch(CheckingException)\nexport class checkingExceptionFilter implements ExceptionFilter {\n    catch(exception: CheckingException, host: ArgumentsHost) {\n        const ctx = host.switchToHttp()\n        const response = ctx.getResponse()\n        response.status(exception.statusCode).json({\n            statusCode: exception.statusCode,\n            message: exception.messageData,\n            error: exception.message,\n        })\n    }\n}\n```\n\n# 모니터링 도구\n\n더 나은 오류 처리를 위해 몇 가지 도구를 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- Sentry\n- Raygun\n- Winston\n- 등\n\n이 프로젝트에서는 Raygun을 사용하여 오류 모니터링 및 보고를 합니다.\n\n## Raygun\n\nRaygun은 개발자가 애플리케이션에서 문제를 식별하고 전체 소프트웨어 품질을 향상시키는 종합 오류, 충돌 및 성능 모니터링 솔루션입니다.\n\n<div class=\"content-ad\"></div>\n\n```typescript\nasync createUser(createUserDto: CreateUserDto): Promise<User> {\n    try {\n      // 사용자 생성을 위한 비즈니스 로직\n    } catch (error) {\n      this.raygunLoggerService.error('사용자 생성 실패', error.stack);\n      throw new Error('사용자 생성 실패');\n    }\n```\n\n성능 모니터링\n\n- Raygun은 성능 메트릭을 추적하고 응용 프로그램의 병목 현상을 식별하는 실제 사용자 모니터링 (RUM) 및 응용 프로그램 성능 모니터링 (APM)도 제공합니다.\n\nRaygun 대시보드\n\n<div class=\"content-ad\"></div>\n\nRaygun 대시 보드에 액세스하여 자세한 오류 보고서를 확인하고 응용 프로그램 성능을 추적하며 중요한 문제에 대한 경보 및 알림을 설정할 수 있습니다.\n\nRaygun을 NestJS 애플리케이션에 통합하면 오류 및 성능 문제에 대한 강력한 통찰력을 얻어 문제를 선제적으로 해결하고 소프트웨어의 전반적인 안정성과 신뢰성을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-NestjsErrorHandling_0.png"},"coverImage":"/assets/img/2024-06-19-NestjsErrorHandling_0.png","tag":["Tech"],"readingTime":7},{"title":"초보자를 위한 Nestjs","description":"","date":"2024-06-19 23:15","slug":"2024-06-19-Nestjsforbeginners","content":"\n\nNest.js는 TypeScript를 사용하여 확장 가능한 서버 측 애플리케이션을 구축하기 위한 Node.js 프레임워크입니다.\n\n![Nest.js](/assets/img/2024-06-19-Nestjsforbeginners_0.png)\n\n# Nest.js를 선택하는 이유\n\n아마 이미 알고 계시다시피, 인기 있는 Node.js 프레임워크 중 하나는 Express입니다. 디자인상으로 매우 미니멀하게 설계되어 있습니다. 몇 가지 기능을 소개하여 서버 측 애플리케이션을 구축할 수 있지만, 백엔드의 전반적인 아키텍처는 사용자에게 달려 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Nestjsforbeginners_1](/assets/img/2024-06-19-Nestjsforbeginners_1.png)\n\nExpress 문서를 살펴보면 라우팅, 미들웨어, 일부 오류 처리를 수행할 수 있는 몇 가지 기능을 제공합니다. 이렇게 보면 이것이 거의 전부입니다. 이러한 아키텍처의 부재는 굉장히 유연하다는 점을 의미합니다. Express로 원하는 대로 거의 무엇이든 할 수 있습니다.\n\n그러나 프로젝트나 팀이 성장함에 따라 여러분은 매우 쉽게 스파게티로 변할 수 있다는 것을 발견할 것입니다. 여러분은 실제로 규칙과 구조가 필요합니다. 특히 GraphQL, REST 또는 Swagger와 같은 것들을 통합해야 할 때 이것들은 매우 중요합니다.\n\n이제 Nest가 나와서 말합니다: \"에이, 우리가 서버 쪽 애플리케이션의 아키텍처를 돌보겠다고. 그리고 가장 좋은 부분은 무엇일까요? Express를 여전히 사용할 수 있다는 것입니다!\"\n\n\n<div class=\"content-ad\"></div>\n\n# Nest.js가 작동하는 방식\n\nNest.js는 빠른 개발과 예측 가능하고 가독성 있는 코드를 위해 express (Fastify도 포함)를 활용하는 도구 모음을 제공합니다. 기본적으로 REST 및 GraphQL API를 지원하거나 Laravel이나 Ruby on Rails와 같은 프레임워크를 사용하여 모델-뷰-컨트롤러(MVC) 설계 패턴을 활용하여 풀 스택 애플리케이션을 구축하는 데 사용할 수 있습니다.\n\n데이터베이스 작업을 처리하거나 보안을 다루는 등 서버 측 애플리케이션에서 수행할 수 있는 작업을 상상할 수 있는 모듈이 풍부하게 포함되어 있습니다.\n\n![Nest.js 이미지](/assets/img/2024-06-19-Nestjsforbeginners_2.png)\n\n\n<div class=\"content-ad\"></div>\n\nNest.js에는 훌륭한 문서가 있어요. 모든 핵심 개념에 대한 개요를 제공할 뿐만 아니라 테스팅, 데이터베이스 연결, 작업 스케줄링, 큐, 이벤트, 웹소켓, GraphQL 등 다른 작업 방법에 대한 지침도 볼 수 있어요.\n\n그리고 TypeScript에 매우 중점을 두고 있어요. OOP와 FP의 요소를 결합했는데, 데코레이터에 큰 비중을 두고 있어요. 스프링부트 프레임워크를 사용해봤다면 익숙할 수도 있겠죠.\n\n# Nest CLI\n\nNest에는 자체 강력한 Command Line Tool이 있어요. nest new 명령어로 새 프로젝트를 손쉽게 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\n> nest new server-side-app\n```\n\n이 명령은 Jest를 통해 미리 구성된 코드베이스를 제공하고, 타입스크립트를 설정하여 더 가독성이 있고 믿을만한 코드를 작성할 수 있도록 합니다. 이제 Nest.js로 시작할 준비가 되었습니다!\n\n독자 여러분 감사합니다 🎉\n","ogImage":{"url":"/assets/img/2024-06-19-Nestjsforbeginners_0.png"},"coverImage":"/assets/img/2024-06-19-Nestjsforbeginners_0.png","tag":["Tech"],"readingTime":2},{"title":"Nodejs에서 첫 번째 REST API를 만드는 방법","description":"","date":"2024-06-19 23:14","slug":"2024-06-19-HowtomakeyourfirstRESTAPIinNodejs","content":"\n\n## 5분 이내로\n\n![이미지](/assets/img/2024-06-19-HowtomakeyourfirstRESTAPIinNodejs_0.png)\n\nNode.js에서 REST API (Representational State Transfer Application Programming Interface)를 만드는 것은 현대 웹 개발자에게 필수적인 기술입니다. 이 유형의 API는 웹 애플리케이션과 같은 다양한 클라이언트가 상태를 유지하지 않는 일련의 작업을 사용하여 서버와 상호 작용할 수 있게 합니다. 이 튜토리얼에서는 Node.js에서 간단한 REST API를 설정하는 기본 사항을 살펴보며, 데이터 유형, 클래스 및 다양한 HTTP 메서드를 사용한 코드 예제를 다룰 것입니다.\n\n# 필수 사항\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 시스템에 Node.js가 설치되어 있는지 확인해주세요. Node.js는 nodejs.org에서 다운로드할 수 있습니다. 또한 JavaScript, Node.js, 그리고 인기 있는 Node.js 프레임워크 Express에 대한 기본적인 이해가 필요합니다.\n\n# 단계 1: 프로젝트 설정하기\n\n먼저, 프로젝트를 위한 새 디렉토리를 만들고 그 안에서 새 Node.js 프로젝트를 초기화하세요.\n\n```js\nmkdir my-rest-api\ncd my-rest-api\nnpm init -y\n```\n\n<div class=\"content-ad\"></div>\n\n위 작업은 당신의 프로젝트 종속성을 관리할 package.json 파일을 디렉토리에 생성합니다.\n\n# 단계 2: Express 설치하기\n\nHTTP 요청을 쉽게 처리하려면 Express를 설치하세요.\n\n```js\nnpm install express\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: 첫 번째 엔드포인트 생성하기\n\n이제 프로젝트 디렉토리에 index.js 파일을 생성하세요. 이것이 진입점이 될 것입니다.\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.listen(3000, () => {\n console.log(\"포트 3000에서 실행 중인 서버\");\n});\n```\n\n이 코드는 포트 3000에서 수신 대기하는 기본 Express 서버를 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 4: HTTP 메소드 처리\n\nREST API는 다양한 HTTP 메소드와 함께 작동합니다. 가장 일반적인 메소드는 GET, POST, PUT 및 DELETE입니다.\n\n# GET 요청\n\n간단한 메시지를 반환하는 GET 엔드포인트를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\napp.get(\"/msg\", (req, res, next) => {\n  res.json({\"message\": \"안녕, 세계!\"});\n});\n```\n\n# POST 요청\n\nPOST 요청을 할 때는 종종 데이터를 받게 됩니다. 예시를 보겠습니다.\n\n```js\napp.use(express.json()); // for parsing application/json\n\napp.post(\"/msg\", (req, res, next) => {\n  const message = req.body.message;\n  res.json({\"receivedMessage\": message});\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 5: 클래스와 데이터 유형 사용하기\n\n더 나은 코드 구성을 위해 클래스를 사용하여 코드를 구성할 수 있습니다. Message 클래스를 만들어 봅시다.\n\n```js\nclass Message {\n  constructor(content) {\n    this.content = content;\n  }\n\n  getContent() {\n    return this.content;\n  }\n}\n```\n\n이제 이 클래스를 사용하여 POST 엔드포인트를 리팩토링할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\napp.post(\"/msg\", (req, res, next) => {\n  const newMessage = new Message(req.body.message);\n  res.json({\"receivedMessage\": newMessage.getContent()}); \n});\n```\n\n# 단계 6: API 테스트하기\n\nAPI를 테스트하려면 Postman이나 cURL과 같은 도구를 사용할 수 있습니다. GET 요청의 경우 브라우저에서 http://localhost:3000/msg 로 간단히 방문할 수 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\nNode.js에서 REST API를 만드는 것은 연습을 통해 더 직관적인 과정이 되는 간단한 일입니다. Express의 사용은 다양한 HTTP 메소드를 간단하게 처리하게 해주며, 클래스와 적절한 데이터 유형을 사용하여 코드를 조직화하면 유지 관리 및 가독성을 크게 향상시킬 수 있습니다.\n\n기억하세요, 이것은 시작점에 불과합니다. 더 편안해지면 API를 더 복잡한 라우트로 확장하거나 데이터베이스에 연결하거나 인증을 구현하는 등 다양한 기능을 추가할 수 있습니다. 계속해서 탐험하고 실험하여 더 견고하고 효율적인 API를 만들어 보세요!","ogImage":{"url":"/assets/img/2024-06-19-HowtomakeyourfirstRESTAPIinNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-HowtomakeyourfirstRESTAPIinNodejs_0.png","tag":["Tech"],"readingTime":3},{"title":"NestJS에서 의존성 주입은 어떻게 처리될까요","description":"","date":"2024-06-19 23:13","slug":"2024-06-19-HowDoesNestJSHandleDependencyInjection","content":"\n\nNestJS와 TypeScript를 사용하여 백엔드를 개발할 때, NestJS에서 @Injectable 데코레이터를 사용하는 것이 일반적입니다. EmailService가 @Injectable이고 다른 서비스에서 이를 주입하고 사용하려는 시나리오를 고려해 보겠습니다. 아래 코드를 살펴보세요:\n\n```js\n@Injectable()\nclass MyService {\n  constructor(private readonly emailService: EmailService) {}\n}\n```\n\n첫눈에 보기에는 모든 것이 잘 동작하는 것처럼 보입니다. 그러나 자세히 살펴보면 이 코드가 조금 이상해 보일 수 있습니다. TypeScript 코드가 JavaScript로 변환될 때, 타입 주석이 제거되기 때문입니다. 그래서 문제는 다음과 같이 발생합니다: NestJS는 EmailService와 같은 타입만으로 어떻게 주입할 서비스를 결정할까요?\n\n![How Does NestJS Handle Dependency Injection](/assets/img/2024-06-19-HowDoesNestJSHandleDependencyInjection_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 설명:\n\nNestJS는 TypeScript의 메타데이터 및 리플렉션 기능을 활용하여 런타임에서 의존성에 대한 필요한 정보를 유지합니다. 이를 위해 reflect-metadata라는 라이브러리를 사용합니다. 이 라이브러리를 사용하면 NestJS가 의존성 주입에 사용할 수 있는 클래스와 메소드에 메타데이터를 추가할 수 있습니다.\n\nNestJS는 의존성 주입을 처리하기 위해 데코레이터를 사용합니다. 위 예시에서 @Injectable() 데코레이터는 NestJS에 EmailService 클래스에 대한 메타데이터를 저장하도록 알려줍니다. 런타임에서 NestJS는 이 메타데이터를 활용하여 의존성을 식별하고 주입합니다.\n\n이 프로세스가 올바르게 작동하도록 하려면 프로젝트에 reflect-metadata를 설치하고 주 파일(예: main.ts)에서 import해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'reflect-metadata';\n```\n\n이렇게 하면 NestJS가 JavaScript로 변환될 때 타입 주석이 제거되어도 메타데이터 정보를 사용하여 의존성을 올바르게 식별하고 주입할 수 있습니다.\n\n# 결론\n\nNestJS는 TypeScript에서 메타데이터와 리플렉션을 사용하여 의존성을 효과적으로 관리합니다. 이 기능을 통해 NestJS는 타입 주석이 제거되어도 올바르게 의존성을 식별하고 주입할 수 있습니다. TypeScript로 서버 측 응용 프로그램을 개발할 때 NestJS의 강점 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\nNestJS가 메타데이터와 리플렉션을 통해 의존성 주입을 처리하는 방식을 이해하면 TypeScript와 NestJS의 힘을 최대로 발휘하면서 더 견고하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n\n나의 Linkedin | 나의 Github","ogImage":{"url":"/assets/img/2024-06-19-HowDoesNestJSHandleDependencyInjection_0.png"},"coverImage":"/assets/img/2024-06-19-HowDoesNestJSHandleDependencyInjection_0.png","tag":["Tech"],"readingTime":2},{"title":"Golang 대 Nodejs","description":"","date":"2024-06-19 23:12","slug":"2024-06-19-GolangvsNodejs","content":"\n\n소프트웨어 개발자로서, 언제나 앱을 개발하는 데 최적화된 가장 빠르고 효율적인 도구를 찾고 있어요. 속도와 복잡한 작업 처리에 관한 것이라면, Golang과 Node.js가 두 강자로 뽑히죠. 둘 다 성능 면에서 뛰어난 평판을 자랑하지요. 그런데 고민거리는 여전히 존재합니다 — Golang과 Node.js 중 어느 쪽이 더 빠를까요? 이 논쟁을 해결하기 위해, 내가 이 두 기술을 철저히 비교하는 벤치마크 테스트의 여정에 나섰어요. 자세한 결과를 분석하여, 빠른 속도면에서 어떤 플랫폼이 우위를 차지하는지 확인하는 게 제 목표에요. 데이터를 통해 어느 플랫폼이 고성능 앱을 개발하는 데 분명한 장점을 가지고 있는지 밝혀낼 거예요.\n\n<img src=\"/assets/img/2024-06-19-GolangvsNodejs_0.png\" />\n\n# 소개\n\n최근 몇 년 동안 Golang과 Node.js는 주목을 받아왔어요. 각각의 강점과 장점을 가지고 있죠.\nGolang, Go로도 알려진, 구글에서 개발한 정적 타입의 컴파일된 프로그래밍 언어입니다. Golang은 간결성, 고루틴을 통한 동시성 지원, 그리고 빠른 성능으로 칭찬을 받아왔어요. 반면에 Node.js는 Chrome의 V8 JavaScript 엔진 위에 구축된 이벤트 기반, 논 블로킹 I/O 플랫폼입니다. 비동기 프로그래밍 모델, npm을 통한 확장 패키지 생태계, 빠른 개발 능력으로 인정을 받았죠.\n\n<div class=\"content-ad\"></div>\n\n# 성능 평가 방법론\n\n벤치마킹 테스트 결과를 살펴보기 전에 공정하고 정확한 비교를 보장하기 위해 표준화된 방법론을 수립하는 것이 중요합니다. 저희의 벤치마킹 테스트에서는 응답 시간, 처리량 및 리소스 이용률과 같은 일반적인 성능 지표에 집중할 것입니다. 벤치마킹 테스트 환경에서는 Golang 및 Node.js 애플리케이션에 대해 동일한 하드웨어 사양 및 구성을 적용할 것입니다. 또한 신뢰할 수 있는 벤치마킹 도구와 프레임워크를 활용하여 모든 실험의 신뢰성과 일관성을 보장할 것입니다.\n\n# 응답 시간 비교\n\n웹 서버 성능을 평가하는 데 중요한 지표 중 하나인 응답 시간은 요청을 보내고 응답을 받는 지속 시간을 측정합니다. 저희의 벤치마킹 테스트에서는 Golang과 Node.js로 작성된 동일한 웹 서버 애플리케이션을 배포하여 각각 간단한 HTTP 요청을 제공하고 처리 오버헤드를 최소화할 것입니다. 서로 다른 수준의 동시 클라이언트 연결을 시뮬레이션하고 해당 응답 시간을 분석함으로써 Golang과 Node.js의 성능을 현실적인 작업 부하 시나리오에서 평가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// Node.js HTTP 서버\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.writeHead(200);\n  res.end('안녕, 세상아!');\n});\n\nserver.listen(3000);\n```\n\n<img src=\"/assets/img/2024-06-19-GolangvsNodejs_1.png\" />\n\n초당 요청 횟수\n\n```js\n// Golang HTTP 서버\npackage main\n\nimport (\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"안녕, 세상아!\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":3000\", nil)\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 처리량 분석\n\n응답 시간 외에도 처리량은 시스템이 수신 요청을 처리하는 속도를 측정하는 또 다른 중요한 성능 지표입니다. 높은 처리량 값은 동시 연결을 처리하고 응답을 즉시 전달할 능력을 나타냅니다. Golang 및 Node.js 애플리케이션의 처리량을 비교하기 위해 동시 클라이언트 요청 수를 증가시키고 각 플랫폼의 요청 처리 능력에 대한 확장성을 모니터링할 것입니다.\n\n# 자원 활용\n\n응답 시간과 처리량 외에도, 부하 하에서 Golang 및 Node.js 애플리케이션의 자원 활용 평가는 매우 중요합니다. 이는 CPU 사용률, 메모리 소비 및 네트워크 활동을 모니터링하여 잠재적인 병목 현상이나 비효율성을 찾아내는 것을 포함합니다. 자원 활용 지표를 면밀히 살펴봄으로써 각 플랫폼의 전체 효율성과 확장성에 대한 통찰력을 얻을 수 있으며, 프로젝트에 적합한 최적 기술 스택을 선택할 때 개발자들이 정보에 기반한 결정을 내릴 수 있게 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n# CPU 사용량:\n\n- Golang은 기계 코드를 컴파일하여 CPU를 효율적으로 사용합니다. 벤치마크 테스트 결과 Golang은 CPU 자원 활용에서 Node.js를 능가하는 것으로 지속적으로 증명되고 있습니다.\n- Node.js는 단일 스레드에서 작동하며 비동기 I/O 호출에 의존하므로 CPU 자원을 미적절하게 사용하고 오버헤드가 증가할 수 있습니다.\n\n# 메모리 사용량:\n\n- 정적 타입 및 컴파일된 성격으로 인해 Golang은 Node.js보다 낮은 메모리 사용량을 보입니다. 덜 필요한 런타임 메타데이터를 요구합니다.\n- Node.js는 동적 타입 및 V8 JavaScript 엔진에 의존하여 유형 정보와 힙을 저장하는 데 더 많은 메모리가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 스레딩 모델:\n\n- Golang은 경량 스레드(고루틴)를 활용하여 동시성을 간단하게 다루고 병렬성을 달성합니다.\n- Node.js는 단일 스레드, 논블로킹 I/O 모델을 채택합니다. 동시성은 Worker Threads를 사용하여 명시적으로 코딩해야 합니다.\n\n# 확장성:\n\n- 경량 고루틴 스레드를 통해 Golang은 수평적으로 뛰어난 확장성을 갖추어 대규모 동시 요구를 처리할 수 있습니다.\n- Node.js는 단일 기계에서 수직적으로 확장성이 뛰어나지만, 단일 스레드 특성으로 인해 확장성을 넓히는 동안 병목 현상을 겪을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 동시성 성능\n\nGolang의 탁월한 기능 중 하나는 가벼운 고루틴과 채널을 통한 동시성을 네이티브로 지원한다는 것입니다. 이를 통해 Golang 애플리케이션은 수천 개의 동시 작업을 효율적으로 처리하면서 오버헤드를 최소화할 수 있어 웹 서버, 마이크로서비스 및 분산 애플리케이션과 같이 높은 동시성 시스템을 구축하는 데 이상적입니다. 반면에 Node.js는 이벤트 기반 비차단 I/O 모델을 통해 동시성을 처리하며 비동기 함수와 이벤트 루프를 활용합니다. 우리는 두 플랫폼에서 고도의 동시성 작업을 스트레스 테스트하여 동시성 성능을 비교하고, 반응성과 확장성을 평가할 것입니다.\n\n# 결론\n\n벤치마크 테스트 결과는 Golang과 Node.js 간의 성능 차이를 생생하게 보여줍니다. 두 플랫폼 모두 장단점을 가지고 있지만, Golang은 순수 속도, 동시성 및 자원 효율성 면에서 우수한 성능을 뽐내고 있습니다. 컴파일된 성격, 가벼운 고루틴 및 효율적인 런타임으로 인해 빠른 응답 시간과 확장 가능한 동시성을 필요로 하는 고성능 애플리케이션에 매력적인 선택이 됩니다.\n반면 Node.js는 탁월한 개발자 생산성, 광범위한 생태계 지원 및 JavaScript 프론트엔드 프레임워크와의 원활한 통합을 제공합니다.\n최종적으로 Golang과 Node.js 중 어느 것을 선택할지는 프로젝트의 특정 요구사항과 우선순위에 따라 결정됩니다 - 성능 최대화, 기존 JavaScript 전문성 활용 또는 개발자 효율성 최적화 등을 고려해야 합니다.","ogImage":{"url":"/assets/img/2024-06-19-GolangvsNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-GolangvsNodejs_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs를 사용한 서버 측 렌더링 운영화","description":"","date":"2024-06-19 23:08","slug":"2024-06-19-OperationalizingNodejsforServerSideRendering","content":"\n\n## Airbnb이 서버 측 렌더링을 중심으로 Frontend를 더 많이 구축함에 따라, 서버 구성을 최적화하는 방법을 살펴보았습니다.\n\nAirbnb에서는 몇 년 동안 Frontend 코드를 일관된 아키텍처로 이주시켜 왔습니다. 전체 웹 페이지가 API에서 제공하는 데이터를 활용하여 React 구성 요소의 계층 구조로 작성되었습니다. Ruby on Rails가 브라우저로 웹을 가져오는 방식에서의 역할은 매일 줄어들고 있습니다. 사실, 곧 우리는 노드.js로 완전한 형태의 서버 렌더링 웹 페이지를 제공할 새로운 서비스로 이행할 것입니다. 이 서비스는 모든 Airbnb 제품의 대부분의 HTML을 렌더링할 것입니다. 이 렌더링 엔진은 우리가 실행하는 대부분의 백엔드 서비스와는 다르며, 루비나 자바로 작성되지 않았음을 특징으로 합니다. 그러나 이 렌더링 엔진은 우리가 생각하는 일반적인 I/O 집중적인 노드.js 서비스와도 다릅니다.\n\n노드.js를 떠올렸을 때, 여러분은 고도로 비동기식인 애플리케이션이 효율적으로 수백 또는 수천 개의 연결을 동시에 처리하는 모습을 상상합니다. 서비스는 동네 곳곳에서 데이터를 가져와 상당히 가볍게 처리하여 많은 클라이언트가 사용할 수 있도록 만듭니다. 아마도 여러분은 수많은 오랜 기간 유지되는 WebSocket 연결을 처리하고 있습니다. 여러분은 이 잘 튠된 경량 동시성 모델로 업무에 완벽히 적합하다는 점에 만족하고 확신하고 있습니다.\n\n서버 측 렌더링(SSR)은 이러한 상상을 일부 깨는 연산 집약적인 작업입니다. 노드.js에서 사용자 코드는 단일 스레드에서 실행되므로 연산 작업(즉, I/O가 아닌 작업)의 경우 동시에 실행할 수 있지만 병렬로 실행할 수는 없습니다. 노드.js는 많은 양의 비동기 I/O를 병렬로 처리할 수 있지만 연산에 한계가 있습니다. 요청의 연산 부분이 I/O에 상대적으로 더 많아질수록 동시 요청은 CPU 경합으로 인해 지연에 미치는 영향이 증가할 것입니다¹.\n\nPromise.all([fn1, fn2])를 고려해보세요. fn1 또는 fn2가 I/O에 의해 해결되는 promise이면 이와 같이 병렬성을 달성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 fn1과 fn2이 연산되면, 대신 이렇게 실행될 것입니다:\n\n![OperationalizingNodejsforServerSideRendering_1](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_1.png)\n\n두 작업 중 하나가 완료될 때까지 다른 하나는 기다려야 합니다. 왜냐하면 실행 스레드가 하나뿐이기 때문입니다.\n\n서버 측 렌더링에서는 서버 프로세스가 여러 동시 요청을 처리할 때 이 문제가 발생합니다. 동시 요청이 처리 중인 다른 요청들에 의해 지연될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_2.png)\n\n현실에서는 요청이 여러 가지 다른 비동기 단계로 구성되는 경우가 많습니다. 심지어 대부분이 계산에 대한 경우라도요. 이는 더 나쁜 교차 결과로 이어질 수 있습니다. renderPromise().then(out => formatResponsePromise(out)).then(body => res.send(body))와 같은 체인으로 요청이 구성된 경우, 다음과 같은 요청 교차가 발생할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_3.png)\n\n이 경우, 두 요청 모두 두 배로 오래 걸릴 수 있습니다. 이 문제는 동시성이 증가함에 따라 심각해집니다.\n\n게다가 SSR의 일반적인 목표 중 하나는 클라이언트와 서버 모두에서 동일하거나 유사한 코드를 사용할 수 있어야 한다는 것입니다. 이러한 환경 간의 큰 차이점 중 하나는 클라이언트 컨텍스트가 본질적으로 단일 테넌트인 반면 서버 컨텍스트는 다중 테넌트입니다. 클라이언트 측에서 쉽게 작동하는 싱글톤이나 다른 전역 상태와 같은 기법은 서버에서 동시 요청 부하하에 대해 버그, 데이터 누출 및 일반적인 혼돈을 초래할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 문제들은 병행성이 발생할 때만 문제가 됩니다. 낮은 부하 수준이거나 개발 환경의 독점적인 단일 테넌시에서는 대부분 잘 작동합니다.\n\n이는 노드 애플리케이션의 전형적인 예제들과 매우 다른 상황을 초래합니다. 우리는 JavaScript 런타임을 사용하여 라이브러리 지원과 브라우저의 특성을 활용하기 위해 사용하고 있습니다. 병행성 모델 대신 이러한 애플리케이션에서는 비동기 병행성 모델이 그 모든 비용을 부과하지만 그 혜택은 별로 없거나 거의 없습니다.\n\n# Hypernova에서 배운 점\n\n저희의 새로운 렌더링 서비스인 Hyperloop은 Airbnb 웹 사이트 이용자가 상호 작용하는 주요 서비스가 될 것입니다. 따라서 그 신뢰성과 성능은 사용자 경험에 절대적으로 중요합니다. 새 서비스로의 프로덕션 전환에 따라 이제는 사전 SSR 서비스인 Hypernova에서 배운 교훈을 통합하고 있습니다.\n\nHypernova는 새 서비스와 다르게 작동합니다. 그것은 순수한 렌더러입니다. 우리의 레일즈 단일체 Monorail에서 호출되고, 특정 렌더링된 컴포넌트에 대한 HTML 조각만 반환합니다. 대부분의 경우 \"조각\"은 페이지의 대부분이며, 레일즈는 단지 바깥 쪽 레이아웃만 제공합니다. 레거시의 경우, 페이지의 구성 요소를 ERB를 사용하여 연결할 수 있습니다. 그러나 어느 경우든 Hypernova는 데이터를 자체로 가져오지 않습니다. 데이터는 레일즈에서 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n위에서 언급한대로, Hyperloop과 Hypernova는 컴퓨트에 관한 유사한 운영 특성을 공유합니다. 실제 트래픽을 처리하는 서비스로, Hypernova는 그 대체품이 프로덕션 환경에서 어떻게 동작할지 이해하는 데 좋은 테스트 대상을 제공합니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_4.png)\n\n사용자로부터 요청이 주요 Rails 앱 Monorail에 들어오며, Monorail은 React 컴포넌트를 해당 페이지에 렌더링하고자 하는 속성을 조합하고 해당 속성과 컴포넌트 이름을 Hypernova에 요청합니다. Hypernova는 속성과 함께 컴포넌트를 렌더링하여 Monorail로 반환할 HTML을 생성하고, Monorail은 페이지 템플릿에 내장시키고 전체를 클라이언트에게 되돌려보냅니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_5.png)\n\n<div class=\"content-ad\"></div>\n\n렌더링 중 실패(오류 또는 타임아웃으로 인한) 발생 시, 하이퍼노바 렌더링의 대체 방법은 렌더링된 HTML 없이 페이지에 구성 요소와 해당 속성을 삽입하는 것입니다. 이렇게 함으로써 클라이언트 렌더링이 성공적으로 수행될 수 있습니다. 이로 인해 하이퍼노바를 선택적 종속성으로 간주하고, 일부 타임아웃과 실패를 허용할 수 있게 되었습니다. 호출에 대한 타임아웃 시간은 서비스의 관찰된 p95 값과 유사하게 설정되었습니다. 기본적으로 5% 미만의 타임아웃이 발생하는 것이 예상대로였습니다.\n\n최대 일일 트래픽로드 배포 중에는 모노레일에서 하이퍼노바에 대한 요청 중 최대 40%가 타임아웃되는 경우가 발생했습니다. 하이퍼노바로부터 배포 중 BadRequestError: Request aborted의 오류율이 증가하는 것을 보았습니다. 이러한 오류는 다른 모든 응용 프로그램/코딩 오류를 효과적으로 숨겨버리는 상당한 기준 오류율 또한 존재했습니다.\n\n이러한 동작은 선택적 종속성으로, 높은 우선순위가 아닌 번거로움으로 여겨졌습니다. 저희는 타임아웃 및 오류를 초기 GC가 비용이 많이 드는 초기 시작 동작, JIT 부족, 캐시 채움, 빗물과 같은 요소의 예상으로 충분히 설명할 수 있다고 합리적으로 생각했습니다. React 또는 Node의 새로운 릴리스가 느린 시작을 완화하기 위한 충분한 성능 개선을 제공할 것을 희망했습니다.\n\n이는 배포 중에 나쁜 로드 밸런싱이나 용량 문제로 인한 확실한 결과로 의심되어질 수 있습니다. 동일한 프로세스에서 거의 100%의 계산 요청을 동시에 처리함으로써 늘어난 대기 시간을 볼 수 있었고, 여러 요청이 한 번에 실행되는 경우가 있을 때에는 해당하는 프로세스에서 동시에 처리된 요청 수를 로그하는 미들웨어를 추가했습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 실제로 CPU 사용을 기다리는 동시 요청 때문에 발생한 지연을 시작 지연으로 원망했습니다. 우리의 성능 지표에서 다른 실행 중인 요청 때문에 실행을 대기하는 시간은 요청을 실행하는 데 소비된 시간과 구별할 수 없습니다. 이는 동시성으로 인한 지연이 개별 요청의 비용을 실제로 증가시키는 새로운 코드 경로 또는 기능에서 발생하는 지연과 동일하게 나타날 것이라는 것을 의미합니다.\n\n또한 BadRequestError: Request aborted 오류가 일반적인 느린 시작 성능으로 충분히 설명되지 않는다는 사실이 점점 더 분명해지고 있었습니다. 이 오류는 body parser에서 발생하며 특히 클라이언트가 서버가 요청 본문을 완전히 읽기 전에 요청을 중단한 경우에 발생합니다. 클라이언트가 포기하고 연결을 끊어가면 우리가 처리를 계속하기 위해 필요한 소중한 데이터를 가져가는데, 개별 요청의 비용을 증가시키는 것이 실제로 더 가능성이 높습니다.\n\nHypernova의 요청 페이로드도 평균적으로 수백 킬로바이트로 상당히 크기 때문에 이 문제가 더 복잡해집니다.\n\n<img src=\"/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_7.png\" />\n\n우리는 이 문제를 해결하기 위해 우리에게 많은 양의 운영 경험을 제공하는 두 가지 외부 구성 요소를 사용하기로 결정했습니다: 역방향 프록시(nginx) 및 로드 밸런서(haproxy).\n\n<div class=\"content-ad\"></div>\n\n# Reverse Proxying 및 로드 밸런싱\n\n우리의 하이퍼노바 인스턴스에 존재하는 여러 CPU 코어를 활용하기 위해 노드.js 클러스터 모듈을 통해 여러 하이퍼노바 프로세스를 실행합니다. 이러한 프로세스들은 독립적이기 때문에 동시 요청을 병렬로 처리할 수 있습니다.\n\n![image](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_8.png)\n\n여기서 문제는 각 노드 프로세스가 요청이 완료될 때까지 효과적으로 점유되며, 이는 클라이언트(모노레일)로부터 요청 본문을 읽는 작업을 포함합니다. 하나의 프로세스에서 병렬로 여러 요청을 읽을 수는 있지만, 이는 작업을 렌더링할 때 연산이 교차되는 문제로 이어집니다. 노드 프로세스의 이용률은 클라이언트 및 네트워크의 속도에 결합됩니다.\n\n<div class=\"content-ad\"></div>\n\n솔루션은 클라이언트와의 통신을 처리하기 위해 버퍼링 리버스 프록시를 사용하는 것입니다. 이를 위해 nginx를 사용합니다. Nginx는 클라이언트로부터의 요청을 버퍼에 읽고, 완전히 읽힌 후에만 전체 요청을 노드 서버에 전달합니다. 이 전송은 머신 내에서 루프백 또는 유닉스 도메인 소켓을 통해 이루어지며 이는 머신 간 통신보다 빠르고 안정적입니다.\n\n![image](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_9.png)\n\nnginx가 요청을 읽는 작업을 처리하면, 노드 프로세스의 사용률을 높일 수 있습니다.\n\n![image](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_10.png)\n\n<div class=\"content-ad\"></div>\n\n우리는 몇 가지 요청을 처리하기 위해 nginx를 사용하여 Node.js 프로세스로 직행할 필요 없이 처리합니다. 우리의 서비스 검색 및 라우팅 레이어는 호스트 간의 연결 상태를 확인하기 위해 낮은 비용의 /ping 요청을 사용합니다. 이를 nginx에서 완전히 처리함으로써 Node.js 프로세스로의 (비록 저렴하지만) 상당한 처리량 출처를 제거합니다.\n\n다음은 부하 분산입니다. 어떤 Node.js 프로세스가 어떤 요청을 받아야 하는지에 대한 스마트한 결정을 내려야 합니다. 클러스터 모듈은 라운드 로빈 방식으로 요청을 분배합니다. 각 프로세스는 차례로 요청을 받습니다. 라운드 로빈은 요청 지연 시간에 큰 변동이 없을 때 훌륭합니다. 그림 1을 참고하세요.\n\n다루는 시간이 극명하게 다른 다양한 유형의 요청이 있는 경우 라운드 로빈은 좋지 않습니다. 프로세스의 후속 요청은 이전 요청이 모두 완료될 때까지 기다려야 합니다. 이에 대처할 수 있는 또 다른 처리 용량이 있는 다른 프로세스가 있더라도요.\n\n<div class=\"content-ad\"></div>\n\n\n![데이터](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_12.png)\n\n이 요청의 더 나은 분배 방식은 다음과 같습니다:\n\n![데이터](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_13.png)\n\n대기 시간을 최소화하고 응답을 빠르게 반환할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 작업은 요청을 대기열에 유지하고 프로세스가 다른 요청으로 쓰여지지 않게 될 때에만 해당 요청을 프로세스에 할당하여 달성할 수 있습니다. 이를 위해 우리는 haproxy를 사용합니다.\n\n![이미지](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_14.png)\n\n이를 Hypernova에 적용하면 배포시에 타임아웃 스파이크와 BadRequestErrors가 완전히 제거되었습니다. 동시 요청은 정상 작동 중에 높은 백분위 지연의 주요 원인이기도 했기 때문에 이로 인해 그 지연도 감소하였습니다. 이러한 결과 중 하나는 구성된 타임아웃이 같더라도 타임아웃 비율이 5%에서 2%로 줄어든 것입니다. 40%의 배포 실패에서 2%로 감소한다는 것은 승리 같은 느낌입니다. 오늘날 사용자들은 로딩 화면이 훨씬 덜 나타납니다. 내일은 Hypernova의 오류 대비 기능이 없는 새 랜더러를 위해 우리에게 매우 중요한 배포를 통한 안정성이 될 것입니다.\n\n# 자세한 내용과 설정\n\n<div class=\"content-ad\"></div>\n\n이 설정을 위해 nginx, haproxy 및 우리 노드 애플리케이션을 구성해야 합니다. 이 설정을 이해하는 데 사용할 수 있는 nginx 및 haproxy 구성이 포함된 샘플 노드 앱을 준비했습니다. 이러한 구성은 우리가 프로덕션 환경에서 실행하는 것을 기반으로 하지만, 단순화되고 비특권 사용자로 전경에서 실행되도록 수정되었습니다. 프로덕션 환경에서는 모든 것을 프로세스 감독자(저희는 runit 또는 점점 더 많이 사용하는 kubernetes를 사용합니다)로 구성해야 합니다.\n\nNginx 구성은 매우 표준적이며, 포트 9000에서 듣는 서버를 구성하여 요청을 포트 9001(저희 환경에서는 Unix 도메인 소켓을 사용)에 듣는 haproxy로 프록시하는 것입니다. 또한 /ping 엔드포인트를 가로채서 연결성 확인을 직접 제공합니다. 내부 표준 nginx 구성과의 차이점은 worker_processes를 1로 줄였다는 것인데, 단일 nginx 프로세스가 단일 haproxy 프로세스와 노드 애플리케이션을 충분히 포화시키기 때문입니다. 또한 hypernova를 위한 컴포넌트의 속성으로 큰 요청 및 응답 버퍼를 사용하고 있습니다(수백 킬로바이트 단위). 자신의 요청/응답 크기에 기반하여 버퍼 크기를 조정해야 합니다.\n\nNode의 클러스터 모듈은 로드 밸런싱과 프로세스 생성을 모두 처리합니다. 로드 밸런싱을 위해 HAProxy로 전환하려면 클러스터의 프로세스 관리 부분을 대체해야 했습니다. 이는 worker 프로세스 풀을 유지하는 데에 대해 클러스터보다 약간 더 의견을 갖추는 pool-hall로 구성되었는데, 로드 밸런싱 게임과는 완전히 무관합니다. 예제 앱은 pool-hall을 사용하여 다른 포트에서 듣는 네 개의 worker 프로세스를 시작하는 방법을 보여줍니다.\n\nHAProxy 구성은 포트 9001에서 듣는 프록시를 구성하여 포트 9002에서 9005까지 듣는 네 개의 worker로 트래픽을 라우팅합니다. 각각의 worker에 대해 가장 중요한 설정은 maxconn 1 입니다. 이는 각 worker가 한 번에 하나의 요청을 처리하도록 제한합니다. 이는 HAProxy 통계 페이지(포트 8999에서 실행하도록 구성됨)에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![HAProxy Configuration](/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_15.png)\n\n안녕하세요!\n\nHAProxy는 각 워커와의 현재 열린 연결 수를 추적합니다. maxconn을 통해 구성된 제한이 있습니다. 라우팅은 static-rr (정적 라운드 로빈)으로 설정되어 있어 일반적으로 각 워커에게 순서대로 요청이 제공됩니다. 제한이 설정된 경우 라우팅은 라운드 로빈으로 진행되지만 현재 요청 제한에 도달한 워커는 건너뛰게 됩니다. 연결 제한 이하의 워커가 없는 경우 요청은 대기열에 들어가며 가장 먼저 사용 가능해진 워커에게 배달됩니다. 이것이 우리가 원하는 동작입니다.\n\n이 구성은 아마도 사용하려는 것과 매우 가까운 것일 것입니다. 여기에는 다른 흥미로운 설정(그리고 필요한 복사 붙여넣기)이 있습니다. 이 구성을 준비하는 일안하며, 우리는 일반적이고 이상적인 상황에서 여러 테스트를 수행하고 그에 기반하여 구성 값을 유도했습니다. 이는 깊이 들어가는 내용으로서 설정을 사용하는 데까지 꼭 이해할 필요는 없지만, 다음 섹션에서 제공됩니다.\n\n# HAProxy 심층 분석\n\nHAProxy 구성이 우리가 원하는 대로 정확히 작동하는 것에 많은 것이 달려 있었습니다. 동시 요청 제한 또는 대기열매 확인되지 않았다면 잘못된 것입니다. 또한 각종 종류의 실패가 어떻게 처리되는지(또는 처리되지 않는지)를 이해하는 것이 중요했습니다. 현재 클러스터 설정에 대한 적합한 대체물인지 확인할 필요가 있었습니다. 이를 확인하기 위해 여러 테스트를 수행했습니다.\n\n<div class=\"content-ad\"></div>\n\n테스트의 일반적인 형태는 Apache Benchmark을 사용하여 다양한 동시성 수준에서 10,000개의 요청을 실행하는 것이었습니다. \n\n```js\nab -l -c <CONCURRENCY> -n 10000 http://<HOSTNAME>:9000/render\n```\n\n저희 설정에서는 예시 앱의 4개 대신 15개의 워커를 사용했고, 벤치마킹 및 시스템 테스트 간 간섭을 피하기 위해 앱을 실행하는 인스턴스와 별도 인스턴스에서 ab를 실행했습니다. 저희는 낮은 부하 (동시성=5), 높은 부하 (동시성=13), 대기 부하 (동시성=20)에서 테스트를 실행했습니다. 대기 부하를 통해 haproxy가 항상 대기열을 처리하도록 했습니다.\n\n첫 번째 테스트 세트는 그저 정상 작동을 확인하는 것이었고, 다음 테스트 세트는 배포 중 발생할 수 있는 모든 프로세스의 우아한 재시작을 확인하였습니다. 마지막 테스트 세트는 제가 일부 프로세스를 무작위로 종료하는 시나리오를 확인하는 것이었습니다. 이는 발생하지 않은 예외가 프로세스를 비정상적으로 종료시키는 상황을 시뮬레이션한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션 코드에서 무한 루프가 별도로 문제가 되었기 때문에 무한 루프가 포함된 엔드포인트에 대해 단일 요청을 실행했습니다.\n\n이러한 테스트는 우리의 구성 및 작동 방식을 이해하는 데 도움이 되었습니다.\n\n일반 작업에서 maxconn 1은 한 번에 하나의 요청을 처리하도록 각 프로세스를 제한하는 대로 정확히 기대했던 대로 작동했습니다. 백엔드에는 HTTP 또는 TCP 헬스체크를 구성하지 않았습니다. 이는 혼란을 야기하고 가치가 없다는 것을 발견했기 때문입니다. 헬스체크는 maxconn을 존중하지 않는 것으로 보입니다. 그러나 코드에서 이를 확인한 적은 없습니다. 우리의 예상 동작은 프로세스가 건강하고 서비스를 제공할 수 있는지 여부이거나 리스닝 중이지 않아 즉시 연결 오류를 발생시킬 것임을 의미합니다 (이에는 한 가지 주요 예외가 있습니다). 우리는 이러한 헬스체크를 우리 사례에 유용할 정도로 충분히 제어 가능하지 않아서 다른 헬스체킹 regime의 예측 불가능성을 피하기로 결정했습니다.\n\n연결 오류는 다룰 수 있는 문제입니다. 우리는 옵션 redispatch 및 retries 3을 설정하여 연결 오류를 수신하는 요청을 더 협조적인 다른 백엔드로 전달할 수 있게 했습니다. 연결이 거부되면 즉시 오류가 발생하여 우리는 비즈니스를 계속할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n거부된 연결에만 적용됩니다. 지금은 수신 대기 중이 아니라는 이유로 연결이 거부됩니다. 로컬 네트워크를 다루고 있기 때문에 연결 제한 시간은 별로 유용하지 않습니다. 무한 루프에 갇힌 워커를 방지하기 위해 낮은 연결 제한 시간을 설정할 수 있을 것으로 예상했습니다. 100밀리초의 타임아웃을 설정했을 때, 이벤트 루프로 제어가 되돌아가지 않았음에도 클라이언트/서버에서 설정된 10초 타임아웃 후에 우리 요청이 타임아웃되는 것에 놀랐습니다. 이는 커널이 서버가 수락하기 전에 클라이언트 관점에서 연결을 설정하는 것을 처리하기 때문에 발생합니다.\n\n주목할 만한 점으로, 백로그를 설정하여도 백로그 길이는 서버가 SYN-ACK에 응답한 후에 평가되어 연결이 설정되지 않는 것으로 결과되지 않습니다 (실제로는 서버가 클라이언트에서 돌아온 ACK 응답을 놓는 것을 구현/처리). 이로 인해 연결이 설정된 요청은 백엔드가 해당 요청을 처리했는지 여부를 판단할 수 있는 방법이 없기 때문에 다시 보내거나 다시 시도할 수 없습니다.\n\n또 다른 흥미로운 결과로, 무한 계산 루프에 갇힌 프로세스에서 수행한 테스트에서 클라이언트/서버 타임아웃은 예상치 못한 동작을 허용합니다. 무한 루프에 빠지게 하는 프로세스로 요청을 보낼 때, 백엔드의 연결 개수가 1로 설정됩니다. maxconn의 경우에는 우리가 원하는대로 작동하여 다른 요청이 연결될 수 없게 합니다. 클라이언트/서버 타임아웃이 만료되면 연결 개수가 다시 0으로 감소되며, 요청처리가 성공했는지 여부를 알 수 없어 우리의 1대1 보장이 위반되고 이전 요청은 실패로 이끌게 됩니다. 클라이언트가 타임아웃이나 변덕 때문에 연결을 닫을 때, 연결 개수는 영향을 받지 않고 라우팅은 계속해서 작동합니다. abortonclose를 설정하면 클라이언트가 닫는 즉시 연결 개수가 감소됩니다. 이에 따라 최선의 조치는 이러한 타임아웃에 높은 값을 설정하고 abortonclose를 해제하는 것입니다. 더 강력한 타임아웃은 클라이언트 또는 nginx 측에서 설정할 수 있습니다.\n\n또한 고부하 사례에서 적용되는 상당히 불편한 매력 요소를 발견했습니다. 만약 서버가 안정적인 대기열을 갖고 있는 상태에서 워커 프로세스가 충돌한다면 (이는 매우 드문 경우여야 합니다), 요청은 해당 백엔드에서 시도될 것이지만 프로세스가 수신 대기 중이기 때문에 연결에 실패합니다. 그럼 HAProxy는 그 후 다음 열린 연결 슬롯을 가진 다음 백엔드로 다시 배분하지만, 실제로 작업 중인 다른 백엔드는 없기 때문에 실패했던 이전 백엔드만 다시 시도됩니다. 이렇게 되면 재시도가 빠르게 소모되어 연결 오류가 HTML 렌더링보다 더 빠르게 발생하여 실패한 요청으로 이어집니다. 이 과정은 대기열이 완전히 소진될 때까지 나머지 요청에 계속 반복됩니다. 이는 좋지 않은 상황이지만, 프로세스 충돌이 드문 데에, 지속적인 대기열이 드문 데에 (계속해서 대기 중이면 공급이 부족한 것입니다) 그리고 특정한 경우에는 서비스 검색의 건강 검사를 빠르게 마킹하므로 전체 인스턴스를 건강하지 않게 표시하고 새 요청을 처리할 수 없게 만듭니다. 이는 좋지 않지만 위험을 최소화합니다. 미래의 작업은 HAProxy 통합을 통해 이를 해결할 수 있으며, 감독자 프로세스가 프로세스의 종료를 감지하고 haproxy stats 소켓을 통해 MAINT로 표시할 수 있는 깊은 HAProxy 통합을 통해 처리할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n다른 변경 사항 중 하나는 Node에서 server.close가 기존 요청이 완료될 때까지 기다리지만 HAProxy 대기열에 있는 것은 서버가 아직 받지 않은 요청을 기다릴지 모르기 때문에 실패할 것입니다. 인스턴스가 요청을 받지 않는 시간과 서버 재시작 프로세스를 시작하는 시간 사이에 충분한 드레인 시간을 보장하는 것이 대부분의 경우 이 문제를 해결해야 합니다.\n\n또한, 대부분의 트래픽을 처음에 사용 가능한 워커에 지시하는 'balance first'를 설정하면 (기본적으로 worker1을 포화시키는) 앱의 지연 시간이 'balance static-rr'보다 15% 감소했습니다. 이 효과는 합성 및 프로덕션 로드에서 지속되었으며, 웜 업으로 쉽게 설명되지 않는 결과였습니다. 이는 배포 후 몇 시간 동안 지속되었습니다. 성능은 시간이 지남에 따라 (12시간 동안) 점점 악화되었지만, 아마도 핫 프로세스의 메모리 누수 때문이었을 것입니다. 또한, 차가운 프로세스가 매우 차가웠기 때문에 트래픽의 급증에는 적응이 덜했습니다. 이에 대한 좋은 설명을 아직 찾지 못했습니다.\n\n마지막으로, Node의 server.maxConnections 설정은 여기에서 유용할 것으로 보였지만 (적어도 저에게는 그랬습니다), 실제로는 많은 효용성을 제공하지 않았으며 때때로 오류를 일으켰습니다. 이 설정은 서버가 maxConnections 이상의 새 핸들을 받지 않도록 하여 제한을 초과한 것을 확인한 후 새 핸들을 닫습니다. 이 확인은 JavaScript에서 적용되므로 무한 루프 상황에 대비하지 않습니다 (이벤트 루프로 돌아가면 요청을 올바르게 중단합니다...기다려). 또한 요청이 중단되면서 정상 작동 중에도 이로 인한 연결 오류가 발생했으며 다른 요청이 여러 개 실행 중인 증거는 없었습니다. 이는 연결이 언제 시작하고 끝나는지에 대한 약간의 타이밍 문제 또는 haproxy와 Node 간의 의견 차이로 의심됩니다. 상호 배타적 보증을 보유하는 것은 개발자가 싱글톤 또는 다른 전역 상태를 안전하게 사용할 수 있게 해주는 좋은 것입니다. 이는 익스프레스 미들웨어로 프로세스별 대기열을 구현함으로써 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n서버 측 렌더링은 주로 I/O 워크로드와는 다른 작업 부하를 나타냅니다. 이는 노드(Node)가 뛰어난 부분입니다. 이상적인 동작의 원인을 파악함으로써, 우리는 기존 운영 경험이 있는 제품을 사용하여 문제에 대처했습니다.\n\n에어비앤비에서는 세계적 수준의 프론트엔드 경험 구축에 크게 투자하고 있습니다. 이 글을 읽는 것이 즐거우셨고 이것이 흥미로운 도전이라고 생각하셨다면, 우리는 항상 역량 있는 호기심 많은 분들을 팀에 초대하고 있습니다. 여러분의 소식을 기다립니다!\n\n이 게시물을 검토하고 수정해준 Brian Wolfe, Joe Lencioni, Adam Neary에게 감사드립니다.\n\n## 각주\n\n<div class=\"content-ad\"></div>\n\n- 비동기 렌더링의 경우 여전히 자원 경합이 발생합니다. 비동기 렌더링은 프로세스나 브라우저의 응답성에 중점을 두지만 병렬 처리나 지연을 해결하지는 않습니다. 이 블로그 포스트는 순수 컴퓨팅 작업의 간단한 모델에 초점을 맞출 것입니다. IO 및 컴퓨팅의 혼합된 작업에서 요청 동시성이 증가하면 지연 시간이 증가하지만 더 높은 처리량을 얻을 수 있다는 장점이 있습니다.\n- 유니콘 웹 서버에서 영감을 받아 우리의 Rails 애플리케이션을 제공하는 데 사용합니다. 유니콘 철학은 특히 잘 설명하고 있습니다.\n- 대부분은 반응이 없는 프로세스를 우회하려고 시도합니다.\n- 클러스터는 요청이 아니라 연결을 분배하므로 예기치 않은 동작을 하며, 특히 지속적인 연결을 사용할 때 더 나빠집니다. 클라이언트로부터의 지속적인 연결은 특정한 워커 프로세스에 바인딩되어 있으므로 작업을 효율적으로 분배하기가 더 어려워집니다.","ogImage":{"url":"/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_0.png"},"coverImage":"/assets/img/2024-06-19-OperationalizingNodejsforServerSideRendering_0.png","tag":["Tech"],"readingTime":15},{"title":"GraphQL 이해하기 효과적인 사용, 장단점 및 TypeScript와 Nodejs로 구현한 실용적인 사례","description":"","date":"2024-06-19 23:06","slug":"2024-06-19-UnderstandingGraphQLEffectivenessProsandConsandaPracticalUseCasewithTypeScriptandNodejs","content":"\n\nAPI에 대한 쿼리 언어인 GraphQL은 데이터 요청을 관리하는 효율성과 유연성으로 개발자들 사이에서 급속히 인기를 얻고 있어요. 2012년 Facebook에서 개발되어 2015년에 오픈 소스 프로젝트로 공개된 GraphQL은 REST에 대한 효율적이고 강력하며 유연한 대안을 제공해요. 이 글에서는 GraphQL의 효과를 탐구하고, 장단점을 살펴보고, TypeScript와 Node.js를 사용한 구체적인 사용 사례를 제시할 거에요.\n\nGraphQL의 효과\n\nGraphQL의 효과는 클라이언트가 정확히 필요한 데이터만 요청할 수 있는 능력에 있어요. 이는 네트워크 상에서 전송되는 데이터 양을 줄이고 애플리케이션의 성능을 최적화해요. 다음은 이 효과를 증진시키는 몇 가지 주요 기능들이에요:\n\n1. 정확한 데이터 가져오기\n\n<div class=\"content-ad\"></div>\n\nGraphQL을 사용하면 클라이언트가 응답 구조를 지정하여 필요한 데이터만 받을 수 있습니다. 이를 통해 과다 검색(필요 이상의 데이터 검색) 및 부족 검색(충분하지 않은 데이터 검색)을 방지할 수 있습니다.\n\n2. 단일 엔드포인트\n\nREST와 달리 데이터를 위해 여러 엔드포인트가 필요한 경우가 많은데, GraphQL은 다양한 리소스에 액세스하기 위해 단일 엔드포인트를 사용합니다. 이는 API를 단순화하고 여러 엔드포인트를 관리하는 복잡성을 줄여줍니다.\n\n3. 강력한 유형 지정 스키마\n\n<div class=\"content-ad\"></div>\n\nGraphQL API는 강력한 유형 시스템을 사용하여 스키마로 정의됩니다. 이 스키마는 클라이언트와 서버 간의 계약 역할을 하며 API와 상호 작용하기 쉽게 만들어줍니다.\n\n4. 구독을 통한 실시간 데이터\n\nGraphQL은 구독을 통해 실시간 데이터를 지원하여 클라이언트가 서버에서 특정 이벤트 발생 시 업데이트를 받을 수 있습니다. 실시간 업데이트가 필요한 애플리케이션에는 채팅 애플리케이션이나 실시간 대시보드 등이 특히 유용합니다.\n\nGraphQL의 장단점\n\n<div class=\"content-ad\"></div>\n\nGraphQL은 많은 이점을 제공하지만 일부 도전 과제도 함께 가지고 있습니다. 이점과 단점을 살펴보겠습니다:\n\n장점\n\n- 효율적인 데이터로딩: 클라이언트는 필요한 것만 요청할 수 있어 대역폭 사용량을 줄이고 성능을 향상시킬 수 있습니다.\n\n- 유연성: GraphQL은 버전 관리 없이 발전할 수 있습니다. 클라이언트는 새로운 필드와 타입을 쿼리할 수 있으며 새로운 API 버전이 필요하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n• 강력한 유형: 스키마는 데이터 유형을 강제하므로 오류를 줄이고 API가 더 예측 가능해집니다.\n\n• 인트로스펙션: GraphQL API는 인트로스펙션할 수 있어서 도구가 자동으로 문서와 클라이언트 라이브러리를 생성할 수 있습니다.\n\n• 개발자 경험: GraphiQL 및 Apollo Client와 같은 도구는 실시간 쿼리 테스트 및 캐싱과 같은 기능으로 개발 경험을 향상시킵니다.\n\n단점:\n\n<div class=\"content-ad\"></div>\n\n• 복잡성: GraphQL의 유연성으로 인해 복잡한 쿼리와 서버 측 리졸버의 복잡성이 증가할 수 있습니다.\n\n• 학습 곡선: REST에 익숙한 개발자들은 GraphQL로 전환할 때 학습 곡선에 직면할 수 있습니다.\n\n• 성능: 최적화되지 않은 GraphQL 쿼리는 데이터베이스 액세스의 N+1 문제와 같은 성능 문제를 일으킬 수 있습니다.\n\n• 캐싱 도전: 전통적인 HTTP 캐싱 전략은 GraphQL에서 덜 효과적이며, 더 정교한 캐싱 메커니즘이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n실용 사례: TypeScript와 Node.js로 GraphQL API 구축하기\n\nGraphQL의 실용적인 사용 사례를 설명하기 위해 TypeScript와 Node.js를 사용하여 간단한 GraphQL API를 구축할 것입니다. 이 API는 책과 저자 목록을 관리할 것입니다.\n\n프로젝트 설정\n\n먼저, 새로운 Node.js 프로젝트를 초기화하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nmkdir graphql-api\ncd graphql-api\nnpm init -y\nnpm install express express-graphql graphql typescript ts-node @types/node @types/express\n```\n\n타입스크립트 구성을 위한 tsconfig.json 파일을 생성하세요:\n\n```js\nimport { buildSchema } from 'graphql';\n\nconst schema = buildSchema(`\n  type Query {\n    books: [Book]\n    authors: [Author]\n  }\n\n  type Book {\n    id: ID!\n    title: String!\n    author: Author!\n  }\n\n  type Author {\n    id: ID!\n    name: String!\n    books: [Book]\n  }\n`);\n\nexport default schema;\n```\n\n리졸버 생성하기\n\n\n<div class=\"content-ad\"></div>\n\n```js\ninterface Book {\n  id: string;\n  title: string;\n  authorId: string;\n}\n\ninterface Author {\n  id: string;\n  name: string;\n}\n\nconst books: Book[] = [\n  { id: '1', title: '1984', authorId: '1' },\n  { id: '2', title: 'Brave New World', authorId: '2' },\n];\n\nconst authors: Author[] = [\n  { id: '1', name: 'George Orwell' },\n  { id: '2', name: 'Aldous Huxley' },\n];\n\nconst resolvers = {\n  books: () => books,\n  authors: () => authors,\n};\n\nexport default resolvers;\n```          \n\n서버 설정하기\n\nExpress 서버를 GraphQL과 함께 설정하기 위해 index.ts 파일을 생성하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport express from 'express';\nimport { graphqlHTTP } from 'express-graphql';\nimport schema from './schema';\nimport resolvers from './resolvers';\n\nconst app = express();\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: resolvers,\n  graphiql: true,\n}));\n\napp.listen(4000, () => console.log('서버가 http://localhost:4000/graphql 주소에서 실행 중입니다.'));\n```\n\n서버 실행\n\n서버를 실행하려면 TypeScript 코드를 컴파일하고 서버를 시작하면 됩니다:\n\n```js\nnpx tsc\nnode dist/index.js\n```\n\n<div class=\"content-ad\"></div>\n\n이제 http://localhost:4000/graphql에 방문하여 GraphiQL을 사용하여 GraphQL API와 상호 작용할 수 있어요.\n\n예시 쿼리\n\n모든 책과 저자를 쿼리할 수 있어요:\n\n```js\n{\n  books {\n    id\n    title\n    author {\n      name\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n아니면 모든 작가와 그들의 책들을 조회할 수도 있습니다:\n\n```js\n{\n  authors {\n    id\n    name\n    books {\n      title\n    }\n  }\n}\n```\n\n결론\n\nGraphQL은 API 디자인에 강력하고 유연한 접근 방식을 제공하여 클라이언트가 필요한 데이터를 정확히 요청할 수 있습니다. 복잡성 및 캐싱 문제와 같은 도전 과제가 있지만, 이러한 단점을 능가하는 이점이 많습니다. TypeScript와 Node.js를 사용하여 개발자는 GraphQL을 활용하여 효율적이고 확장 가능하며 견고한 API를 작성할 수 있으며 개발자 경험과 응용 프로그램 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nFynd Node.js.","ogImage":{"url":"/assets/img/2024-06-19-UnderstandingGraphQLEffectivenessProsandConsandaPracticalUseCasewithTypeScriptandNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-UnderstandingGraphQLEffectivenessProsandConsandaPracticalUseCasewithTypeScriptandNodejs_0.png","tag":["Tech"],"readingTime":5},{"title":"NodeJS 작동 방식 뒷담화부터 전달합니다","description":"","date":"2024-06-19 23:05","slug":"2024-06-19-HowNodeJSWorksBehindtheScenes","content":"\n\n\n![How Node.js Works Behind the Scenes](/assets/img/2024-06-19-HowNodeJSWorksBehindtheScenes_0.png)\n\nNode.js는 Google의 오픈 소스 V8 JavaScript 엔진을 기반으로 한 JavaScript 런타임입니다. 또한 웹 서버로 사용하기에 이상적이며, 서버 측 웹 개발에 JavaScript를 사용할 수 있는 장점을 제공합니다. Node.js는 V8 JavaScript 엔진과 런타임 환경 내의 Libuv와 같은 몇 가지 핵심 라이브러리에 의존합니다.\n\n- V8 엔진은 JavaScript 코드를 컴퓨터가 실제로 이해할 수 있는 기계 코드로 변환합니다.\n- Libuv는 비동기 I/O에 강점을 가진 오픈 소스 라이브러리입니다. 이 레이어를 통해 Node는 기본 컴퓨터 운영 체제, 파일 시스템, 네트워킹 등에 대한 액세스 권한을 얻습니다. 또한 libuv는 Node.js의 두 가지 매우 중요한 기능인 이벤트 루프와 스레드 풀도 구현합니다.\n\n# 스레드 풀\n\n\n<div class=\"content-ad\"></div>\n\n컴퓨터에서 Node를 사용할 때는 해당 컴퓓에서 실행 중인 프로그램을 나타내는 Node 프로세스가 있음을 의미합니다. 이 프로세스 내에서 Node.js는 단일 스레드에서 작동합니다. 이는 Node 애플리케이션을 실행할 때 해당 애플리케이션이 단일 스레드에서 실행된다는 것을 의미합니다. \n\n- 프로그램이 초기화될 때 모든 최상위 코드가 실행되는데, 이는 어떠한 콜백 함수 내부에 있지 않은 모든 코드를 의미합니다.\n- 추가로, 애플리케이션에 필요한 모든 모듈이 로드되고, 모든 콜백이 등록됩니다.\n- 그 다음, 이벤트 루프가 마침내 실행을 시작합니다.\n\n파일 시스템 API, 암호화, 압축 및 DNS 조회와 같은 일부 작업은 이벤트 루프 내에서 실행하기에는 너무 많은 리소스가 필요하거나 비용이 많이 드는 작업이므로 단일 스레드를 차단할 수 있습니다. 이것이 스레드 풀이 필요한 이유입니다. 이 스레드 풀은 이벤트 루프와 마찬가지로 Node.JS에 Libuv 라이브러리로 제공됩니다.\n\n- 스레드 풀은 메인 단일 스레드와 완전히 분리된 4개의 추가 스레드를 제공합니다.\n- Node.js를 최대 128개의 스레드까지 사용하도록 구성할 수 있지만, 대개 4개의 스레드만으로 대부분의 애플리케이션에 충분합니다. 그렇다면 기본 스레드 풀 크기 4를 다른 숫자로 변경하는 방법은 무엇일까요?\n\n<div class=\"content-ad\"></div>\n\n```js\nprocess.env.UV_THREADPOOL_SIZE = 1;\n```\n\n- 그런 다음 이벤트 루프는 무거운 작업을 스레드 풀로 자동으로 오프로드할 수 있습니다. 이 모든 것은 자동으로 백그라운드에서 발생합니다.\n- 개발자는 스레드 풀에 할당할 항목을 결정할 권한이 없습니다.\n\n# 이벤트 루프\n\nNode.js에서는 애플리케이션 내에서 중요한 사건이 발생할 때마다 명명된 이벤트를 방출하는 이벤트 발생자라는 특정 개체가 있습니다. 이 사건에는 서버에 요청이 도착하거나 타이머가 만료되거나 파일이 읽기 작업을 완료하는 등의 중요한 일이 포함될 수 있습니다. 이러한 이벤트는 개발자가 설정한 이벤트 리스너에 의해 수집되며, 각 리스너에 첨부된 콜백 함수가 실행됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst server = http.createServer(); server.on('request',(req,res) => { res.end('Request received'); });\n```\n\n- 서버를 생성하려면 createServer() 메서드를 사용하고 서버 변수에 저장합니다.\n- server.on 메서드는 \"request\" 이벤트를 위해 리스너를 생성하는 데 사용됩니다.\n- 서버는 이벤트를 발생시키는 발신자 역할을 하며 요청이 서버에 도달할 때마다 \"request\" 이벤트를 자동으로 발생시킵니다.\n- 이 리스너에 연결된 콜백 함수는 자동으로 호출됩니다.\n- 함수는 그런 다음 데이터를 클라이언트에 다시 보냅니다.\n\nJavaScript 프로그래밍에서 이벤트 발생자 논리는 관찰자 패턴이라고 합니다. 결론적으로 이벤트 루프는 콜백 실행 및 네트워킹 I/O와 같은 간단한 작업을 처리하는 것을 담당하며, 스레드 풀은 파일 액세스나 압축과 같은 더 많은 작업을 처리합니다.","ogImage":{"url":"/assets/img/2024-06-19-HowNodeJSWorksBehindtheScenes_0.png"},"coverImage":"/assets/img/2024-06-19-HowNodeJSWorksBehindtheScenes_0.png","tag":["Tech"],"readingTime":3},{"title":"자바스크립트의 this 키워드 설명 및 해석하기","description":"","date":"2024-06-19 23:03","slug":"2024-06-19-JavaScriptsthiskeywordexplainedanddemystified","content":"\n\n<img src=\"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_0.png\" />\n\n\"this\" 키워드는 양날의 검이에요. 복잡한 오류의 원인이 될 수도 있고, 실제로 어떻게 작동하는지 알면 개발자로서 여러분에게 삶을 쉽게 만들어 줄 수도 있어요. 요즘에는 커뮤니티가 언어를 더 함수형 패러다임으로 밀고 있어요. \"this\" 키워드를 그렇게 많이 사용하지는 않아요. 그런데 여전히 문맥에 따라 의미가 달라 혼란스러울 수 있어요. 그래서 이 글에서는 \"this\" 키워드를 설명해 실제로 어떻게 작동하는지 잘 이해하도록 도와드릴게요.\n\n# 소개\n\n이 글은 모든 자바스크립트 개발자를 위한 것입니다. 다음을 배울 수 있을 거에요:\n\n<div class=\"content-ad\"></div>\n\n- 자바스크립트에서 this 키워드란 무엇인가요?\n- 노드에서 this 키워드가 나타내는 바는 무엇인가요?\n- 전역 및 함수 실행 컨텍스트에서 this 키워드가 어떻게 결정되나요?\n- 함수가 호출되는 다양한 방법 및 이와 this의 관계\n- call() 및 apply() 메서드를 사용하여 this의 값을 제어하는 방법\n- bind() 메서드를 사용하는 방법\n- 화살표 함수에서 this가 동작하는 방식\n\n# this 키워드란 무엇인가\n\nthis 키워드는 자바스크립트에서 함수가 호출될 때 객체 참조를 저장하는 변수입니다. this 키워드가 참조하거나 가리키는 객체는 사용된 컨텍스트에 따라 달라집니다. 개념적으로, this는 영어 문법의 대명사와 유사합니다. 대명사가 명사를 참조하는 방식처럼 this는 객체를 참조하기 위해 사용됩니다.\n\n예를 들어: “Mary is running fast because she is trying to catch the bus.”\n\n<div class=\"content-ad\"></div>\n\n위 구문에서는 대명사 \"she\"가 선행사 \"Mary\"를 가리키는 데 사용됩니다. 이 개념을 JavaScript의 this 키워드와 연관시켜보겠습니다.\n\n```js\nconst person = { name: \"Mary\",\n                 pronoun: \"she\", \n                 Activity: function () { // this = person\n                     console.log(`${person.name} is running fast because ${this.pronoun} is trying to catch the bus`);\n                 } \n               }\nperson.Activity(); // Mary is running fast because she is trying to catch the bus\n```\n\n위 코드에서 this는 person 객체의 참조값으로 사용되며, 마치 대명사 \"she\"가 \"Mary\"를 가리키는 것처럼 사용됩니다.\n\n# this의 값은 어떻게 결정됩니까?\n\n<div class=\"content-ad\"></div>\n\n`table` 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n글로벌 실행 컨텍스트에서 this 키워드는 웹 브라우저의 창 객체인 글로벌 객체를 참조합니다.\n\n```js\nconsole.log(window === this ) // true this.color = 'Green' console.log(window.color) // Green\n```\n\n위 코드에서는 this 키워드를 사용하여 전역 window 객체에 속성을 추가하고 있습니다.\n\n참고: 전역 실행 컨텍스트에서는 JavaScript가 strict mode 인지 아닌지에 상관없이 this 키워드가 항상 글로벌 객체를 참조합니다.\n\n<div class=\"content-ad\"></div>\n\n## Node.js에서의 'this' 키워드\n\nNode.js 문서에 따르면,\n\n위 문장의 의미는 'this' 키워드가 Node.js에서 전역 객체를 참조하지 않는다는 것입니다. 대신, 현재 사용 중인 모듈을 가리킨다는데요. 즉, module.exports를 통해 내보낸 객체를 가리킵니다.\n\n예를 들어, 가상의 모듈인 app.js를 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\n┣ 📄 app.js \nconsole.log(this); \nmodule.exports.color = 'Green'; \nconsole.log(this);\n```\n\noutput:\n\n```js\n┣ $ node app.js \n{} \n{color: 'Green'}\n```\n\n![JavaScript this keyword explained and demystified](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_1.png)\n\n<div class=\"content-ad\"></div>\n\n위의 코드에서 먼저 app.js 모듈에 module.exports에 값이 없기 때문에 빈 객체가 로깅됩니다. 그런 다음 color 속성이 module.exports 객체에 추가되고, 이를 다시 로깅하면 업데이트된 module.exports 객체가 반환되어 color 속성이 포함됩니다.\n\n## 노드(Node)에서 전역 객체에 액세스하는 방법\n\n이제 우리는 브라우저와 달리 노드에서는 this 키워드가 전역 객체를 참조하지 않는다는 것을 알았습니다. 노드에서는 전역 객체에 global 키워드를 사용하여 액세스하며, 전역 키워드가 사용된 위치와 관계없이 전역 객체에 액세스할 수 있습니다.\n\n```js\n┣ 📄 app.js console.log(global);\n```\n\n<div class=\"content-ad\"></div>\n\n출력:\n\n```js\n┣ $ node app.js // 노드 글로벌 객체를 기록합니다.\n```\n\n<img src=\"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_2.png\" />\n\n글로벌 객체는 노드 환경에 대한 여러 유용한 속성을 노출합니다.\n\n<div class=\"content-ad\"></div>\n\n# 함수 실행 컨텍스트\n\n함수 실행 컨텍스트에서 this 키워드가 어떻게 결정되는지는 함수가 호출되는 방식에 따라 다릅니다.\n\n자바스크립트 함수는 네 가지 방법으로 호출될 수 있습니다:\n\n- 함수로서 호출\n- 메소드로서 호출\n- 생성자로서 호출\n- apply 및 call 메서드를 사용하여 호출\n\n<div class=\"content-ad\"></div>\n\n함수가 호출될 때(즉, 함수가 () 연산자를 사용하여 호출될 때) this는 비엄격 모드에서 전역 창 객체를 참조하고 엄격 모드에서는 undefined로 설정됩니다.\n\n예시\n\n```js\nfunction A() { console.log(this === window) // true }\nfunction B() { \"use strict\" console.log(this === window) // false } function C() { \"use strict\" console.log(this === undefined) // true}\n\nA(); // true\nB(); // false\nC(); // true\n```\n\n함수가 메소드로 호출될 때(즉, 객체 속성을 통해), this는 메소드의 \"소유\" 객체를 참조합니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n```js\nlet Nigeria = { continent: 'Africa', getContinent: function () { return this.continent; } } \nconsole.log(Nigeria.getContinent()); // Africa\n```\n\n함수를 생성자로 호출하려면 함수 호출 앞에 new 연산자를 사용합니다.\n\n예시\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction Context() {return this; } \nnew Context();\n```\n\n함수가 생성자로 호출될 때(new 연산자를 통해) 몇 가지 특별한 동작이 발생합니다:\n\n- 새로운 비어있는 객체가 생성됩니다.\n- 이 객체가 생성자에 this 참조 객체로 전달됩니다. 즉, 함수가 호출될 때 this가 가리키는 객체입니다.\n- 새로 생성된 객체가 new 연산자의 값으로 반환됩니다.\n\n예제\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction Person() { this.name = 'Mary', this.age = 20 }\nconst person1 = new Person(); \nconsole.log(person1.age) // 20\n```\n\n![Reference Image](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_3.png)\n\n위 코드와 다이어그램에서는 함수가 생성자로 호출될 때 this가 객체를 참조하는 방법을 보여주고 설명합니다.\n\nnew 연산자 없이 생성자 함수를 호출하려고 하면 this는 객체가 아니라 undefined를 가리킵니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n```js\nfunction Person() { this.name = 'Mary', this.age = 20 } const person2 = Person(); console.log(person2.age) // // => TypeError: Cannot read property 'age' of undefined\n```\n\nPerson() 함수가 항상 생성자 호출을 통해 실행되도록 하기 위해 Person() 함수 시작 부분에 체크를 추가합니다:\n\n```js\nfunction Person() { if (!(this instanceof Person)) { throw Error('Must use the new operator to call the function'); } \nthis.name = 'Mary',\nthis.age = 20 } \nconst person2 = Person(); console.log(person2.age) // // => Must use the new operator to call the function\n```\n\n<div class=\"content-ad\"></div>\n\nES6에서는 생성자로 호출되었는지 또는 간단하게 호출되었는지를 탐지할 수 있는 new.target이라는 메타 프로퍼티를 도입했습니다.\n\nPerson() 함수를 수정하여 new.target 메타프로퍼티를 사용할 수 있습니다:\n\n```js\nfunction Person() { \nif (!new.target) { throw Error('Must use the new operator to call the function'); }\n this.name = 'Mary', this.age = 20 }\n const person2 = Person(); \nconsole.log(person2.age)\n // => Must use the new operator to call the function\n```\n\n함수는 객체이며, 모든 JavaScript 객체와 같이 메소드가 있습니다. 이 중 두 가지 메소드인 call()과 apply()는 함수를 간접적으로 호출합니다. 이 두 메소드를 사용하면 호출에 대해 명시적으로 this 값(객체 참조)을 지정할 수 있어 어떤 함수든 해당 객체의 메소드로 호출할 수 있습니다. call()과 apply()는 호출에 대한 인수를 지정할 수도 있습니다. call() 메소드는 함수에 대해 자체 인수 목록을 함수의 인수로 사용하며, apply() 메소드는 인수로 사용할 값의 배열을 기대합니다. call() 및 apply() 모두 첫 번째 인수는 함수가 호출될 객체를 나타내는 this 키워드입니다.\n\n<div class=\"content-ad\"></div>\n\n예시\n\n```js\nfunction getContinent(prefix) { console.log(`${prefix} ${this.continent}`); } \nlet nigeria = { continent: 'Africa' };\nlet china = { continent: 'Asia' }; \ngetContinent.call(nigeria, \"나이지리아는\"); getContinent.call(china, \"중국은\");\n```\n\n출력:\n\n```js\n나이지리아는 Africa 중국은 Asia\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 getContinent() 함수를 간접적으로 호출하기 위해 getContinent() 함수의 call() 메소드를 사용했습니다. call() 메소드의 첫 번째 인자로 nigeria와 china 오브젝트를 전달했기 때문에 각 호출에서 해당 국가의 대륙을 얻었습니다.\n\napply() 메소드는 call() 메소드와 유사하지만, 두 번째 인자로 argument 배열을 사용한다는 것을 이미 알고 계실 것입니다.\n\n```js\ngetContinent.apply(nigeria, [\"나이지리아는\"]); getContinent.apply(china, [\"중국은\"]);\n```\n\nOutput:\n\n<div class=\"content-ad\"></div>\n\n```js\n나이지리아는 아프리카에 있고 중국은 아시아에 있습니다.\n```\n\n화살표 함수에서 JavaScript는 this를 렉시컬하게 설정합니다. 이는 화살표 함수 내부의 this 값이 가장 가까운 \"비-화살표\" 함수에 의해 정의된다는 것을 의미합니다. 또한, 화살표 함수 내부에서 this의 값은 변경할 수 없습니다. 이는 함수의 전체 수명 주기 동안 동일한 상태를 유지합니다.\n\n몇 가지 예시를 살펴봅시다:\n\n```js\nlet getThis = () => this; console.log(getThis() === window); // true\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 this 값이 전역 객체인 즉, 웹 브라우저의 창 객체로 설정됩니다. 스택과 힙을 이용해 이전 코드를 더 자세히 이해해 봅시다.\n\n![이미지](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_4.png)\n\n- getThis 화살표 함수는 전역 window 객체를 반환하는 Global() \"non-arrow\" 함수에 렉시컬 스코프를 갖습니다.\n- getThis 화살표 함수 내의 this 값은 해당 객체를 가리키는 함수의 this 값이 렉시컬로 스코프된 것이므로 전역 window 객체입니다.\n\n다른 예시를 살펴보죠:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction confirmThis () { let getThis = () => this; console.log(getThis() === window); // true } confirmThis();\n```\n\n결과:\n\n일반 함수의 this 값은 \"비 엄격 모드\"에서 전역 window 객체를 가리킨다. this 값은 confirmThis() 함수의 렉시컬 스코프에 바인딩되므로 window 객체를 가리킬 것이다. 그러나 \"엄격\" 모드에서는 상황이 다릅니다.\n\n```js\nfunction confirmThis () { \"use strict\"; let getThis = () => this; console.log(getThis() === window); // true } confirmThis();\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 strict 모드에서 confirmThis() 함수의 this 값이 undefined로 설정되며, getThis 화살표 함수도 마찬가지입니다.\n\n예시\n\n```js\nconst module = { x: 42, getX: function() { return this.x; } };\nconst unboundGetX = module.getX; console.log(unboundGetX());\n// 함수는 전역 범위에서 실행됩니다\n// 기대 출력: undefined\nconst boundGetX = unboundGetX.bind(module); console.log(boundGetX()); // 기대 출력: 42\n```\n\n<div class=\"content-ad\"></div>\n\n앞선 코드에서는 모듈 객체의 메서드인 getX()이 전역 범위에서 \"함수\"(대신 모듈의 메서드로)로 호출됩니다. 이로 인해 이 참조가 모듈 객체에서 누락됩니다. getX 메서드가 \"함수\"로 호출될 때 이 참조가 여전히 모듈 객체를 가리키게 하려면 bind() 메서드를 통해 모듈 객체에 \"바인딩\"되어야 합니다. - const boundGetX = unboundGetX.bind(module);.\n\n# 결론\n\n이제 이 키워드가 어떻게 작동하는지와 적용되는 다양한 컨텍스트를 알게 되었습니다. 필요한 경우 편안하게 사용할 수 있을 것입니다.\n\n# 요약\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 다음을 배웠습니다:\n\n- JavaScript에서 this 키워드가 무엇인지에 대해 알게 되었습니다.\n- Node에서 this 키워드가 무엇을 나타내는지에 대해 알게 되었습니다.\n- 전역 및 함수 실행 컨텍스트에서 this 키워드가 어떻게 결정되는지에 대해 알게 되었습니다.\n- 함수가 호출되는 다양한 방법 및 this와의 관련성에 대해 알게 되었습니다.\n- call() 및 apply() 메소드를 사용하여 this의 값을 제어하는 방법에 대해 알게 되었습니다.\n- bind() 메소드를 사용하는 방법에 대해 알게 되었습니다.\n- 화살표 함수에서 this의 동작 방식에 대해 알게 되었습니다.\n\n# 용어 해설\n\nStack 또는 CallStack: 스택은 후입선출(LIFO) 원칙을 따르는 데이터 구조입니다. 그러나 실행 스택은 코드 실행 중에 생성된 모든 실행 컨텍스트를 추적하는 스택입니다. 또한 스택은 JavaScript에서 정적 데이터(변수 및 참조 값)를 저장합니다. 자세히 알아보세요.\n\n<div class=\"content-ad\"></div>\n\n힙: 힙은 JavaScript에서 동적 데이터를 저장하는 데 사용되는 데이터 구조입니다. 이 곳에는 모든 JavaScript 객체가 저장됩니다. 더 알아보려면 [여기](링크)를 확인해보세요.\n\n렉시컬 스코프: 보다 잘 이해하기 위해 [스택 오버플로우 답변](링크)을 참고하십시오.\n\nJavaScript 엄격 모드: [MDN](링크)\n\n![이미지](/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_5.png)","ogImage":{"url":"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_0.png"},"coverImage":"/assets/img/2024-06-19-JavaScriptsthiskeywordexplainedanddemystified_0.png","tag":["Tech"],"readingTime":10},{"title":" Nx Affected에 대한 심층 탐구","description":"","date":"2024-06-19 23:00","slug":"2024-06-19-DeepDiveintoNxAffected","content":"\n\n## 모놀리포의 Nx 영향을 이해하고 최적화하기\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_0.png)\n\n- 😵‍ 왜 이대로 내버려둔 프로젝트가 영향을 받는가?\n- 🤓 영향 받은 요소\n  - 영향 받은 프로젝트\n  - 영향 받은 작업\n- 🤩 영향 받은 명령\n  - 영향 받은 실행\n  - 명령 표시\n  - Nx 그래프\n- 😶‍🌫️ 영향 받은 규칙\n  - 단계 1 - 터치된 파일 찾기\n  - 단계 2.1 - 경로별 영향 받는 노드 찾기\n  - 단계 2.2 - 작업별 영향 받는 노드 찾기\n  - 단계 2.3 - 플러그인별 영향 받는 노드 찾기\n  - 단계 2.4 - Npm 의존성으로부터 영향 받는 노드 찾기\n  - 단계 2.5 - TypeScript 구성에서 영향 받는 노드 찾기\n  - 단계 2.6 - 글로벌 파일에서 영향 받는 노드 찾기\n  - 단계 3 - 영향 받는 그래프 생성\n- 🧐 영향 조사\n  - Nx 그래프 사용\n  - 디버깅\n- 🤕 영향 해결\n  - 앱/라이브러리를 잘 분리\n  - 엄격한 명명된 입력\n  - 영향 수정\n  - Nx 패치\n- 🙂 마지막으로\n\n# 😵‍ 왜 이대로 내버려둔 프로젝트가 영향을 받게 되었을까?\n\n<div class=\"content-ad\"></div>\n\n이 질문은 매일 듣는 질문입니다! 이 질문은 제가 Nx Affected 프로세스의 디버깅 세션으로 많은 시간을 소비하게 한 질문입니다.\n\n본 문서에서는 Nx의 영향을 받는 프로세스가 어떻게 작동하는지 이해하는 데 필요한 모든 통찰력을 제공하여 그 질문에 대한 답변을 도와드리겠습니다.\n\n# 🤓 영향 프로세스 알림\n\nMonorepo에서 큰 코드베이스에서 작업할 때 여러 응용 프로그램과 라이브러리를 포함하는 저장소가 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n당신의 Monorepo가 성장함에 따라 CI에서 모든 앱/라이브러리를 재빌드하는 데 시간이 오래 걸릴 수 있습니다. 영향을 받는 앱/라이브러리만 다시 실행할 수 있는 능력은 소프트웨어 개발 주기를 크게 단축시킬 수 있습니다.\n\n## 영향을 받는 프로젝트\n\n앱/라이브러리를 수정하면 해당 앱/라이브러리 및 이에 종속된 다른 모든 앱/라이브러리에도 영향을 줍니다:\n\n![영향을 받는 프로젝트](/assets/img/2024-06-19-DeepDiveintoNxAffected_1.png)\n\n<div class=\"content-ad\"></div>\n\n앱/라이브러리 간의 종속성을 이해하기 위해 Nx는 모든 노드(앱/라이브러리), 외부 노드(npm) 및 그들 간의 모든 종속성을 포함한 프로젝트 그래프를 생성합니다.\n\n## 영향 받는 작업\n\n전체 앱/라이브러리에 대한 수정의 영향을 고려하는 것만으로 충분하지 않습니다. 예를 들어, 앱 내의 테스트를 변경한다고 해서 그 앱 전체를 다시 빌드해야 하는 것은 아닙니다. 테스트만 다시 실행하면 됩니다:\n\n![Afftected Task](/assets/img/2024-06-19-DeepDiveintoNxAffected_2.png)\n\n<div class=\"content-ad\"></div>\n\n앱/라이브러리 간 작업 종속성을 이해하기 위해 Nx는 작업에 의해 앱/라이브러리가 연결된 노드로 Task Graph를 생성합니다.\n\n## 🤩 영향을 받는 명령어\n\nNx는 어떤 프로젝트/작업이 영향을 받았는지 식별하는 여러 방법을 제공합니다.\n\n### 영향을 받는 실행\n\n<div class=\"content-ad\"></div>\n\n주로 CI에서 사용하는 주요 명령어는 Nx 영향을 받는 명령어입니다:\n\n```js\nnx affected -t lint test build\n```\n\n![Deep Dive into Nx Affected](/assets/img/2024-06-19-DeepDiveintoNxAffected_3.png)\n\n이 명령어를 사용하면 영향을 받는 작업 목록만 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Show Command\n\n또 다른 유용한 명령어는 직접적인 개요를 얻을 수 있는 Nx show 명령어입니다:\n\n```js\nnx show projects --affected\n```\n\n<img src=\"/assets/img/2024-06-19-DeepDiveintoNxAffected_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 명령은 콘솔에서 영향을 받는 프로젝트/작업을 직접 확인하고 결과를 JSON 파일로 내보내는 것을 가능하게 합니다.\n\n## Nx 그래프\n\n만약 영향을 받는 프로젝트/작업의 경로를 추적하고 UI 시각화가 필요하다면, 다음 명령을 사용하여 Nx 그래프를 열 수 있습니다:\n\n```js\nnx graph --affected\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식의 코드입니다.\n\n\n![이미지1](/assets/img/2024-06-19-DeepDiveintoNxAffected_5.png)\n\n그래프를 확인할 수 있는 웹 페이지가 열립니다:\n\n![이미지2](/assets/img/2024-06-19-DeepDiveintoNxAffected_6.png)\n\n## 😶‍🌫️ 영향 받는 규칙\n\n\n<div class=\"content-ad\"></div>\n\nNx 영향을 받는 프로세스는 여러 단계를 거치며 어떤 프로젝트가 영향을 받을 수 있는지 결정하기 위해 여러 파일 및 구성을 고려합니다:\n\n![Nx 영향 받은 내용 탐색](/assets/img/2024-06-19-DeepDiveintoNxAffected_7.png)\n\n## 단계 1 - 변경된 파일 찾기\n\nNx는 영향을 받는 프로젝트의 목록을 계산하기 전에 수정/변경된 파일 목록을 로드합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_8.png)\n\nNx는 대상 영향을 받은 베이스 이후의 수정된 파일을 계산합니다.\n\n기본적으로 베이스는 기본 브랜치이지만, -base 및 -head 옵션을 사용하여 수정할 수 있습니다.\n\n아직 커밋되지 않거나 추적되지 않은 모든 수정된 파일도 추가됩니다. -uncommitted 또는 -untracked 옵션을 사용하여 동작을 변경할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n만약 Nx에게 파일 목록을 계산하지 않았으면, -files 옵션을 사용하여 직접 파일 목록을 제공할 수 있습니다.\n\n.gitignore 또는 .nxignore에서 패턴과 일치하는 파일들은 무시됩니다.\n\n## 단계 2.1 - 경로에서 영향을 받는 노드 찾기\n\n모든 변경된 파일이 정의되었을 때, Nx는 해당 파일들이 프로젝트에 어떻게 영향을 줄 수 있는지 확인합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_9.png)\n\n가장 일반적인 규칙은 파일 경로가 프로젝트 루트 경로와 일치하는지 확인하는 것입니다.\n\n## 단계 2.2 - 작업에서 영향을받는 노드 찾기\n\nNx 작업을 실행할 때 두 가지 개념이 고려됩니다:\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-DeepDiveintoNxAffected_10.png)\n\n- 작업 실행 중에 소스 자산을 정의하는 데 사용되는 입력입니다.\n- Nx에 의해 캐시되는 작업 결과인 출력입니다.\n\n자바스크립트의 순수 함수와 유사하게, 입력이 변경되지 않았다면 출력도 동일해야 합니다.\n\n입력 목록을 재사용하기 쉽게 하려면 nx.json 또는 project.json에서 Named Inputs를 사용하여 정의할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  \"namedInputs\": {\n    \"default\": [\"{projectRoot}/**/*\", \"sharedGlobals\"], // 기본 입력값\n    \"production\": [\"default\", \"!{projectRoot}/jest.config.ts\"], // 프로덕션 입력값\n    \"sharedGlobals\": [] // 공유 전역 입력값\n  }\n}\n```\n\n그런 다음, 해당 값을 nx.json 또는 project.json의 대상 또는 실행기에 할당하십시오:\n\n```js\n\"targetDefaults\": {\n  \"build\": {\n    \"inputs\": [\"production\", \"^production\"]\n  },\n  \"test\": {\n    \"inputs\": [\"default\", \"^production\", \"{workspaceRoot}/jest.preset.js\"],\n  },\n}\n```\n\n파일을 변경하더라도 해당 작업 목록에는 영향을 미치지 않습니다:\n\n<div class=\"content-ad\"></div>\n\n아래 이미지를 확인해주세요👇\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_11.png)\n\n만약 파일을 터치하면, 영향을 받는 프로젝트 목록은 각 작업/실행자의 입력 구성에 따라 달라집니다.\n\n## 단계 2.3 - 플러그인에서 영향 받은 노드 찾기\n\nNx 프로젝트 크리스털과 추론된 구성을 통한 Nx 플러그인의 일반화로 인해 Nx는 플러그인 패턴이 터치된 파일 목록에 영향을 받는지도 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-DeepDiveintoNxAffected_12](/assets/img/2024-06-19-DeepDiveintoNxAffected_12.png)\n\n예를 들면, 파일을 삭제하거나 이동하면 Nx는 해당 프로젝트가 삭제되었다고 가정하고 모든 프로젝트를 영향을 받는 것으로 표시합니다.\n\n## 단계 2.4 - Npm 종속성에서 영향받는 노드 찾기\n\n만약 package.json이 수정되면, Nx는 어떤 것이 정확히 변경되었는지 이해하기 위해 스마트한 접근법을 사용합니다.\n\n\n<div class=\"content-ad\"></div>\n\n만약 npm 라이브러리를 수정한다면, Nx는 해당 라이브러리를 사용하는 모든 프로젝트를 찾아서 영향을 받는 것으로 표시합니다. 만약 @types/* 라이브러리를 수정한다면, Nx는 관련 라이브러리를 추출하여 동일한 원리로 라이브러리를 수정하는 것과 같은 원리를 적용합니다.\n\n만약 nx.json 플러그인에서 사용하는 라이브러리를 수정하거나 삭제한다면, 모든 프로젝트가 영향을 받는 것으로 간주됩니다:\n\n![image](/assets/img/2024-06-19-DeepDiveintoNxAffected_13.png)\n\n기본적으로 패키지 매니저 락 파일을 수정하는 것은 모든 프로젝트에 영향을 줍니다:\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 표현해 보겠습니다.\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_14.png)\n\n이 동작은 nx.json 파일의 projectsAffectedByDependencyUpdates를 사용하여 수정할 수 있습니다:\n\n```js\n\"pluginsConfig\": {\n    \"@nx/js\": { \n        \"projectsAffectedByDependencyUpdates\": \"auto\"\n    }\n}\n```\n\n옵션:\n\n<div class=\"content-ad\"></div>\n\n- 모든: 모든 프로젝트에 영향을 미칩니다.\n- 자동: 수정된 종속성과 관련된 프로젝트에만 영향을 줍니다.\n- 문자열[]: 프로젝트 목록을 정의합니다.\n\n## 단계 2.5 - TypeScript 구성에서 영향 받는 노드 찾기\n\n전역 TypeScript 구성을 수정하면 영향을 받는 노드 목록도 변경될 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-DeepDiveintoNxAffected_15.png)\n\n<div class=\"content-ad\"></div>\n\n만약 경로가 수정되면, Nx는 루트 경로와 일치하는 관련 프로젝트에 영향을 줍니다. 그러나 전역 구성을 수정하거나 경로를 삭제할 경우 모든 프로젝트에 영향을 줍니다.\n\n## 단계 2.6 - 글로벌 파일로부터 영향을 받는 노드 찾기\n\n기본적으로 nx.json을 수정하면 모든 프로젝트에 영향을 줍니다.\n\n![Nx Affected](/assets/img/2024-06-19-DeepDiveintoNxAffected_16.png)\n\n<div class=\"content-ad\"></div>\n\n## 단계 3 - 영향을 받은 그래프 생성\n\n영향을 받는 모든 노드를 식별한 후에, Nx는 영향을 받는 노드, 외부 노드 및 종속성이 최종적으로 영향을 받는지 확인하기 위해 영향을 받는 그래프를 생성합니다.\n\nNx는 영향을 받는 노드를 가져와 프로젝트 그래프의 모든 종속성을 재귀적으로 검색합니다:\n\n![Afftected Graph Example](/assets/img/2024-06-19-DeepDiveintoNxAffected_17.png)\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 영향을 받는 노드인 lib10이 lib4에서 사용되고 lib4는 app1에서 사용된다면, 이 모든 노드가 영향 받는 프로젝트 그래프에 추가됩니다.\n\nNx는 externalNodes에도 동일한 원칙을 적용합니다:\n\n![image](/assets/img/2024-06-19-DeepDiveintoNxAffected_18.png)\n\n예를 들어, 영향을 받는 npm 라이브러리인 enquirer가 npm 라이브러리인 nx에 의해 사용되고 nx가 내부 라이브러리 tools에 사용되는 경우입니다.\n\n<div class=\"content-ad\"></div>\n\n지금까지 영향을 받는 그래프가 완전한지 확인하려면 Nx가 관련 종속성을 추가할 것입니다.\n\n# 🧐 영향 분석\n\n여전히 특정 브랜치에서 일부 프로젝트가 영향을 받는 이유를 모르겠다면 언제든지 Nx 영향 프로세스를 디버깅할 수 있습니다.\n\n## Nx 그래프 사용하기\n\n<div class=\"content-ad\"></div>\n\n만약 영향을 받는 명령어로 Nx 그래프를 열면, 🤓 영향을 받는 프로젝트 섹션에 명시된 대로 모든 영향을 받는 프로젝트를 볼 수 있습니다.\n\n그런 다음 워크스페이스를 탐색하고 프로젝트 포커스나 의존성 추적기와 같은 여러 기능을 사용할 수 있습니다.\n\n## 디버깅\n\n그러나 대규모 저장소의 경우, 그래프는 디버깅에 사용하기 어려울 수 있습니다. 제가 선호하는 방법은 Nx-affected 프로세스를 디버깅하여 정확히 어떤 단계가 책임을 지고 있는지를 확인하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n패키지/nx/src/command-line/affected/affected.ts에서 중단점을 설정하고 디버그 모드에서 nx show project --affected를 실행해보세요.\n\n# 🤕 영향을 받는 수정 사항\n\n영향을 받는 프로세스를 사용자 정의하는 것은 간단하지 않습니다. 각 수정에 너무 많은 프로젝트가 영향을 받는다고 생각한다면 몇 가지 권장 사항을 살펴보세요:\n\n## 어플리케이션/라이브러리의 잘 구분된 분리\n\n<div class=\"content-ad\"></div>\n\n앱/라이브러리를 정확히 분할했는지 확인해 주세요.\n\n자주 사용되는 라이브러리는 한 프로젝트에서 필요로 하는 유틸리티들로 구성될 수 있습니다. 이런 경우 라이브러리를 수정하는 것이 모든 프로젝트에 영향을 줄 수 있습니다.\n\n## 엄격한 Named Inputs\n\nNamed Inputs가 올바르게 구성되었는지 확인하세요. Named Inputs는 파일을 수정했을 때 해당 대상의 출력에 영향을 줄 수 있는지를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 스펙 파일을 수정하면 테스트에 영향을 미칠 수 있지만 빌드에는 영향을 주지 않을 수 있습니다. 기본 명명된 입력을 사용하면 한 파일을 수정하면 프로젝트의 모든 대상에 영향을 줄 수 있습니다.\n\n## 영향을 받는 사용자 정의\n\n현재, 영향을 받는 프로세스에 대한 사용자 정의가 제한적으로 제공됩니다. 의존성을 업데이트할 때 configuration projectsAffectedByDependencyUpdates를 사용하여 사용자 정의할 수 있습니다(Step 2.4 — Npm Dependencies로부터 영향을 받는 노드 찾기).\n\n## Nx 패치\n\n<div class=\"content-ad\"></div>\n\n이것은 조작적인 해결책이지만, 나는 영향을 받는 프로세스를 사용자 정의하기 위해 그것을 사용합니다. 패키지 관리자의 패치 시스템을 사용하여 Nx 라이브러리를 패치하여 규칙을 변경할 수 있습니다.\n\n예를 들어, 수정하는 데 시간이 걸리는 경우 \"Affected All\" 사용 사례를 비활성화할 수 있습니다:\n\n```js\ndiff --git a/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js b/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js\nindex 72e78e7..7793bea 100644\n--- a/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js\n+++ b/node_modules/nx/src/plugins/js/project-graph/affected/npm-packages.js\n@@ -20,7 +20,8 @@ const getTouchedNpmPackages = (touchedFiles, _, nxJson, packageJson, projectGrap\n             c.path.length === 2) {\n             // 패키지가 삭제되었으므로 모든 워크스페이스 프로젝트를 터치로 표시합니다.\n             if (c.type === json_diff_1.JsonDiffType.Deleted) {\n-                touched = Object.keys(projectGraph.nodes);\n+                // 패키지가 삭제된 경우 영향을받은 모든 프로젝트에 적용하지 않도록 패치\n+                // touched = Object.keys(projectGraph.nodes);\n                 break;\n             }\n             else {\ndiff --git a/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js b/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js\nindex bac7008..37ae136 100644\n--- a/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js\n+++ b/node_modules/nx/src/plugins/js/project-graph/affected/tsconfig-json-changes.js\n@@ -24,7 +24,8 @@ const getTouchedProjectsFromTsConfig = (touchedFiles, _a, _b, _c, graph) => {\n         }\n         // 경로가 삭제된 경우 모든 것이 터치됩니다\n         if (change.type === json_diff_1.JsonDiffType.Deleted) {\n-            return Object.keys(graph.nodes);\n+            // 경로가 삭제된 경우 영향을 받은 모든 프로젝트에 적용하지 않도록 패치\n+            // return Object.keys(graph.nodes);\n         }\n         touched.push(...getProjectsAffectedByPaths(change, Object.values(graph.nodes)));\n     }\ndiff --git a/node_modules/nx/src/project-graph/affected/affected-project-graph.js b/node_modules/nx/src/project-graph/affected/affected-project-graph.js\nindex 5665c8d..d5a69aa 100644\n--- a/node_modules/nx/src/project-graph/affected/affected-project-graph.js\n+++ b/node_modules/nx/src/project-graph/affected/affected-project-graph.js\n@@ -12,7 +12,8 @@ async function filterAffected(graph, touchedFiles, nxJson = (0, configuration_1.\n     const touchedProjectLocators = [\n         workspace_projects_1.getTouchedProjects,\n         workspace_projects_1.getImplicitlyTouchedProjects,\n-        project_glob_changes_1.getTouchedProjectsFromProjectGlobChanges,\n+        // 플러그인 패턴 일치 변경 파일에 영향을주지 않도록 패치\n+        // project_glob_changes_1.getTouchedProjectsFromProjectGlobChanges,\n         touched_projects_1.getTouchedProjects,\n     ];\n     const touchedProjects = [];\ndiff --git a/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js b/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js\nindex c5aec64..edaa989 100644\n--- a/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js\n+++ b/node_modules/nx/src/project-graph/affected/locators/workspace-projects.js\n@@ -16,7 +16,8 @@ const getTouchedProjects = (touchedFiles, projectGraphNodes) => {\n exports.getTouchedProjects = getTouchedProjects;\n const getImplicitlyTouchedProjects = (fileChanges, projectGraphNodes, nxJson) => {\n     const implicits = {\n-        'nx.json': '*',\n+        // nx.json이 변경된 경우 영향을받은 모든 파일에 적용하지 않도록 패치\n+        // 'nx.json': '*',\n     };\n     Object.values(projectGraphNodes || {}).forEach((node) => {\n         const namedInputs = {\n```\n\n# 🙂 마지막으로 생각해보세요\n\n<div class=\"content-ad\"></div>\n\n보시다시피, 영향을 받는 프로세스는 수정된 파일 목록을 고려하는 것뿐만 아니라 다른 여러 요소를 기반으로 프로젝트 목록을 계산합니다.\n\n이로 인해 조사가 항상 간단하지는 않고 종종 영향을 받는 모든 상황으로 이어질 수 있습니다.\n\n일부 부분을 명확히 하고 영향을 받는 프로세스를 더 잘 이해하기 위한 핵심을 제공했기를 바랍니다.\n\n미래에는 종속성 업데이트에 의해 영향을 받는 프로젝트와 같은 옵션 목록을 일반화하여 영향을 받는 프로세스에 대한 더 많은 사용자 정의 옵션이 있기를 희망합니다.\n\n<div class=\"content-ad\"></div>\n\n곧 시작됩니다 🚀\n\n# 관련된","ogImage":{"url":"/assets/img/2024-06-19-DeepDiveintoNxAffected_0.png"},"coverImage":"/assets/img/2024-06-19-DeepDiveintoNxAffected_0.png","tag":["Tech"],"readingTime":13}],"page":"57","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}