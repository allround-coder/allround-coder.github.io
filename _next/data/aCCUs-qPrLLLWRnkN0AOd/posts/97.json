{"pageProps":{"posts":[{"title":"나의 즐겨찾는 iOS 17 위젯","description":"","date":"2024-05-15 11:24","slug":"2024-05-15-MyfavouriteiOS17widget","content":"\n\n<img src=\"/assets/img/2024-05-15-MyfavouriteiOS17widget_0.png\" />\n\n지난 달에 iOS7가 출시되었는데, 새로운 주요 기능들이 함께 등장했습니다. 그 중에서도 가장 주목해야 할 것은 개선된 위젯 지원이었습니다. 이번에는 사용자가 앱을 열지 않고도 홈 화면에서 직접 위젯과 상호작용할 수 있게 되었습니다.\n\n이것은 할 일 목록에서 작업을 마칠 수도 있고, 음악 트랙을 한 번에 건너뛸 수도 있다는 것을 의미합니다.\n\n그러나 이 새로운 기능은 점점 짜증이 나기 시작한 앱을 여러 번 하루에 사용하는 앱으로 변신시켰습니다. 이 앱을 사용하는 방법을 바꿀 뿐만 아니라, 전화기를 사용하는 방식에 더 많은 가치를 더하게 되었다고 볼 수도 있습니다.\n\n\n\n그럼 이제 모든 걸 잊고, 제가 가장 좋아하는 iOS 17 위젯은...\n\n## 홈\n\n좋아요, 지금까지 읽어주셔서 감사합니다. 약간 실망스럽다고 느낄 수 있지만, iOS 17에서 제공하는 홈 위젯이 기대되는 이유에 대해 설명해 드리겠습니다.\n\n우선 주의할 점을 말씀드리자면: \"스마트 홈\"은 가지고 있지 않습니다. 스마트 전구 몇 개와 스마트 플러그 몇 개 정도 있는 집이 있지만요.\n\n\n\n우리 집을 좀 더 '스마트'하게 만드는 생각을 해보고 있어요. 하지만 스마트 스위치를 위해 집을 다시 전선을 교체하지 않으면 가치가 있는지 확신이 안 서요. 벽에 있는 스위치를 끄면 스마트 전구도 똑똑하지 않죠.\n\n그리고 우리가 기존 전구를 스마트 전구로 바꾸고 싶다면 집을 재담보해야 할 것 같아요. 그것들 가격이 싸지 않아요.\n\n그래서 우리 현재는:\n\n- 우리 거실의 메인 조명으로 한 개, 그리고 측면 조명으로 한 개의 스마트 전구가 있어요. 저와 아내가 저녁에 텔레비전을 보는 동안 분위기를 만드는 데 좋아요.\n- 제 오피스의 메인 조명으로 한 개, 그리고 책상 위에 있는 라이트 스트립이 있어요. 일할 때 집중하고 편안해지는 데 유용하다고 느꼈어요.\n- 저희 침실 바깥에 한 개가 있어요. 밤중에 저렇게 파란색 약한 빛을 남겨두면, 아이들이 우리 방으로 가야 할 때 완전히 깨어나지 않고 길을 찾을 수 있어요.\n- 잠들기 전에 읽기에 좋은 침대 옆 탁자에 한 개의 전구가 있어요.\n\n\n\n## 스마트 기기의 문제점\n\n요즘 스마트 기기에 대한 문제는 이러한 조명이 완전히 관리하기 귀찮다는 것입니다.\n\n먼저, 모든 전등 스위치를 벽에서 켜야 했고, 심지어 집 앱(사용하기 쉽지 않은)에서 해당 전등을 찾아 켜고 끌 수 있어야 했습니다.\n\n요약하자면 — 시간 낭비였습니다. 핸드폰으로 전등을 켜고 끄려고 하다 보니 벽 스위치를 조금만 눌러도 순식간에 할 수 있었던 일을 하고 있었습니다.\n\n\n\niOS17의 홈 위젯은 모든 것을 바꿨어요.\n\n## 위젯 설정하기\n\n위젯의 진정한 이점을 누리기 위해 두 가지를 해야 해요:\n\n첫째로, 위젯이 기본 설정으로 켜놓은 추천 기능을 끄세요. 이것이 얼마나 중요한지를 알게 될 거에요. 이걸 하려면:\n\n\n\n- 화면 위젯을 길게 눌러주세요.\n- \"위젯 편집\"을 선택하세요.\n- \"추천\" 스위치를 끕니다.\n- 그런 다음 위젯에 표시하고 싶은 스위치를 수동으로 추가할 수 있습니다.\n\n![위젯 설정](/assets/img/2024-05-15-MyfavouriteiOS17widget_1.png)\n\n또한, 몇 가지 포커스 모드를 설정하고 각 포커스 모드에 대해 고유한 홈 위젯을 만들어보세요.\n\n저는 하루의 다른 시간대에 대해 다른 모드를 설정해두었어요: 아침, 업무, 저녁, 취침, 주말 등.\n\n\n\n각각에는 추천 스위치가 제거된 다른 홈 위젯이 있습니다. 대신에 집중 모드와 가장 관련된 스위치를 수동으로 추가했습니다.\n\n예를 들어,\n\n- \"작업\" 모드에서 홈 위젯은 사무실의 주 조명과 책상 위의 라이트 스트립을 표시합니다.\n- \"저녁\" 모드에서는 화면이 변경되고 홈 위젯에는 거실의 조명이 포함됩니다.\n- \"취침\" 시간에는 화면이 다시 변경되며, 이번에는 침대 옆에 있는 램프가 위젯에 표시됩니다.\n\n## 결과\n\n\n\n내 전화의 포커스 모드가 이렇게 설정되어 있으면, 홈 앱을 열어 스크롤할 필요 없이, 내가 제어하려는 조명이 내가 보고 있는 화면에서 쉽게 이용할 수 있을 것이라는 확신을 갖고 전화를 보기만 하면 됩니다.\n\n![이미지](/assets/img/2024-05-15-MyfavouriteiOS17widget_2.png)\n\n거기서 끝나는 것이 아닙니다. 위젯에는 단축키를 포함할 수도 있습니다. 'Going Up'이라는 이름의 하나를 설정했는데, 이것은 잠자러 가야 할 시간이 되면 트리거하는 단축키입니다. 이 단축키는 다음을 수행합니다:\n- TV를 끕니다.\n- 거실의 주요 조명을 끕니다.\n- 그런 다음 우리 방 바깥의 조명을 끄고 색상을 저렴한 파랑으로 설정합니다.\n- 층에 올라가면서 책을 읽을 수 있도록 침대 옆의 조명을 저조하고 따뜻한 주황색으로 설정합니다.\n\n\n\n내 침대 옆 빛을 끄고 Sonos 스피커를 통해 화이트 노이즈를 재생하도록 하는 \"Good Night\"라는 다른 바로 가기가 있어요.\n\n그러한 바로 가기는 저의 저녁 및 수면 집중 모드에 각각 표시되어, 다시 한 번, 전화를 보기만 하면 관련 바로 가기가 자동으로 업데이트되어 제게 제공됩니다.\n\n## 결론\n\n이 글의 시작 부분에서 언급했듯이, 제 집에는 스마트 액세서리가 소수만 있어요. 큰 수의 액세서리를 사용하면 얼마나 쉽게 사용할 수 있는지가 얼마나 무력해질 수 있는지 알 수 있습니다.\n\n\n\n그러나 저에게는 스마트 홈에 대한 큰 이슈가 실제로 무엇인지를 보게 해 주었습니다. 여전히 어디에나 스마트 장치를 설치하길 원하는 건 아니지만, 적어도 현재로서는 새로운 홈 위젯 때문에 그 앱에 대한 제 의견이 \"화려하지만 실현 가능하지 않은\"에서 \"집 주변의 조명을 효율적으로 관리할 수 있는 방법\"으로 바뀌었습니다.\n\n스마트 기기를 시작하는 중이라면, 홈 앱과 포커스 모드에 시간을 투자할 것을 권유하고 싶습니다. 이것은 제게 정말 큰 영향을 미쳤습니다.\n\n# 마지막으로\n\n위의 글이 유용하다고 느꼈다면, 제 글을 지원할 수 있는 세 가지가 있습니다:\n\n1. 지금 공유하세요.\n2. 즐겨찾기에 추가하세요.\n3. 의견을 남겨주세요.\n\n\n\n- 다른 사람들이 관심을 가질 수 있도록 박수를 보내주세요. 그들도 유용하게 활용할 수 있길 바라요.\n- 비슷한 콘텐츠가 올라올 때 가장 먼저 알 수 있도록 저를 여기 Medium에서 팔로우해주세요.\n- 대화를 이어가보세요. 여기서 메시지를 남기거나 Twitter/X 또는 Mastodon에서 연락해주세요. 제가 꼭 답변해드릴게요!","ogImage":{"url":"/assets/img/2024-05-15-MyfavouriteiOS17widget_0.png"},"coverImage":"/assets/img/2024-05-15-MyfavouriteiOS17widget_0.png","tag":["Tech"],"readingTime":4},{"title":"기술 해킹 간단한 작업을 너무 복잡하게 만드는 최상의 방법","description":"","date":"2024-05-15 11:23","slug":"2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks","content":"\n\n테크오스트리치에 다시 오신 것을 환영합니다. 우리는 현대 기술의 이상하고 종종 필요하지 않은 면을 탐험하는 곳입니다. 오늘은 '테크 해킹' 세계로 뛰어들어보겠습니다 — 간단한 작업을 지나치게 복잡하게 만들어 '간편화'하려는 가전제품들에 대해요. 먹는 속도를 판단하는 스마트 포크에서부터 강아지의 모든 움직임을 추적하는 반려동물 기술까지, 우리가 만난 가장 말도 안 되는 혁신들에 대해 웃어봅시다. 가장 일상적인 작업조차 기술적으로 향상되기 위해 얼마나 많은 노력을 기울였는지 함께 살펴보죠!\n\n![이미지](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_0.png)\n\n스마트 포크: 천천히 먹는 방식을 혁신하다\n\n스마트 포크를 만나보세요. 다이닝 경험을 인내심을 시험하는 끌어내는 운동으로 바꾸도록 설계된 기술적 놀라움입니다. 식사 속도가 너무 빠르면 진동하는 이 탁월한 발명품은 마치 할머니가 당신의 식기에 디지털로 임베디드된 것처럼 작동합니다. 당신이 먹는 습관을 추적하여 소화에 최적의 속도로 식사하는지 분석합니다 — 왜냐하면 당신을 비난하는 포크가 있는 것만큼 '식사를 즐기세요' 라는 선물은 없기 때문이겠죠. 그리고 우리가 먹는 속도가 가장 느린 사람이 누구인지 확인하기 위해 친구들과 경쟁할 수 있는 동반 앱을 잊지 말아주세요. 그래서 다음에 급하실 때, 기억하세요: 당신의 스마트 포크는 당신에게 고통스러운 느린 한 입을 마다 사랑하고 싶어합니다.\n\n\n\n\n![image1](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_1.png)\n\nDIY Home Automation: When Flipping a Switch is Just Too Much Work\n\nWelcome to the world of DIY home automation, where every mundane task is transformed into a high-tech adventure. Who needs to flip a light switch when you can program your entire home from your smartphone? Set your blinds to open with the sunrise, your coffee to brew at the sound of your alarm, and your thermostat to adjust based on your mood swings. But beware: one wrong command and you might end up with the lights flickering like a disco and your smart speaker playing ‘The Chicken Dance’ on loop. It’s the future we always dreamed of, with a side of minor chaos.\n\n![image2](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_2.png)\n\n\n\n\n디지턈 가디닝: 식물도 똑똑해지는 곳\n\n디지턈 가디닝에 오신 것을 환영합니다. 이제는 식물도 여러분을 능가할 수 있습니다. 스마트 화분과 연결된 관개 시스템을 소개합니다. 바질의 감정 상태에 대해 푸시 알림을 보내줍니다. 어떤가요, 어당초 어렸을 때 헝그리해하는 카페인이 그렇지 않습니까? 어플리케이션을 확인하십시오. 이런 기기는 가디닝에서 추측을 빼앗아 당신의 집을 푸른색의, 기술 주도적인 낙원으로 만들어 줍니다 - 아니면, 끝내 건조한 잎사귀와 지나치게 열정적인 관리 일정으로 얽힌 전쟁터로 만들겠죠. 기억하세요, 식물이 자신의 감정에 대해 문자 메시지를 보내주는 것만큼 좋은 것은 없습니다.\n\n![TechHacksTheBestWaystoOvercomplicateSimpleTasks_3](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_3.png)\n\n가제트 과부하: 인터넷 연결된 잡동사니함\n\n\n\n아, 잡동사니 서랍 - 잊혀진 가제트의 시대를 열어줄 보물상자입니다. 이제 사물인터넷 덕분에 복잡한 케이블과 소진된 배터리만을 보관하는 곳이 아닙니다. 당신의 빗질 습관을 추적하는 인터넷 연결 헤어 브러시나 날씨 예보를 알려주는 스마트 우산과 만나보세요. 당연히 이제 기억을 믿을 수 없기 때문에 더 많은 달걀을 사야 한다는 것을 상기시켜주는 WiFi 기능이 탑재된 계란트레이를 잊지 맙시다. 이러한 가제트들은 여러분의 삶을 혁신할 것을 약속하거나 적어도 특색 있는 기술 장난감 더미 아래서 재발견했을 때 재미를 줄 것입니다.\n\n![이미지](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_4.png)\n\n스마트 샤워: 목욕 시간을 너무 복잡하게 만드는 경험으로 변신시키기\n\n당신의 샤워실이 소프트웨어 업데이트가 필요하다고 느끼셨나요? 스마트 샤워가 등장합니다. 완벽한 온도, 수압, 심지를 약속하는 공학의 놀라운 산물입니다. 샤워를 좋아하는 노래로 시작하도록 프로그램하거나 원격으로 시작되도록 설정하여 물이 따뜻해질 때까지 기다릴 필요가 없도록 할 수 있습니다. 하지만 조심하세요: 한 가지 결함이 생기면 얼음 찬 놀람이나 새벽 6시에 디스코 조명쇠도를 만나게 될 수도 있습니다. 커피도 마시기 전에 샤워 컨트롤 패널과 싸우느라 '하루의 시작을 즐기는'것 같은 이미지를 만들어 준다는 것을 잊지 마세요.\n\n\n\n\n![Pet Tech: Because Your Dog Needs a Fitness Tracker](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_5.png)\n\n개를 위한 기술: 당신의 개가 운동량 추적을 필요로 하는 이유\n\n당신의 개가 비밀리에 소파감자인지 궁금했던 적이 있나요? 반려동물 기술 덕분에 이제는 발바닥친구의 활동량, 식습관, 심지어 수면 패턴까지 추적할 수 있습니다. 스마트 칼라로 강아지를 장식하면 모든 걸그룹을 기록하고, 만일 피도가 매일 운동 목표를 달성하지 못했을 경우 알림을 받게 됩니다. 자동 급식기와 급수기는 늦게까지 늦근데도 반려동물이 굶주리지 않도록 보장합니다. 기술에 민감한 반려인을 위한 완벽한 솔루션이죠. 단지 칼라가 '산책하러 더 나가자'는 소리를 내면 개가 당신을 쳐다보고 있다는 사실에 놀라지 마세요.\n\n![image](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_6.png)\n\n\n\n\n과대평가된 혁신: \"헉!\" 하게 만드는 제품들\n\n기술 혁신은 좋지만 때로는 조금 지나칠 때도 있습니다. 인간의 우선순위에 대해 의문을 제기하게 만드는 과대평가된 가젯의 세계로 들어가 봅시다. 핸드폰과 동기화되어 나트륨 섭취량을 추적하는 스마트 소금통부터 남아있는 양을 알려주는 인터넷 연결 화장실 티슈 홀더까지 — 이러한 발명품들은 당신의 삶을 가장 불필요한 방식으로 변화시키겠다고 약속합니다. 이제 인식이 부족했던 것으로 보이는 스마트 벨트까지 없어서는 안될 겁니다. 당신이 너무 많이 먹었을 때 알려주는 스마트 벨트를 잊지 말아주세요. 왜냐하면 분명히 타이트해진 허리띠 때문에 충분한 단서가 되지 않았으니까요. 저희와 함께 이 불필요한 방식으로 삶을 혁신하겠다고 약속하는 기술 제품들의 비극적인 세계로 뛰어들어 봅시다.\n\n![이미지](/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_7.png)\n\n이 과장된 기술 해킹의 세계를 유쾌하게 즐겨주셔서 감사합니다. 만약 우리가 이 무모한 혁신들을 조롱하는 걸 즐겼다면, 반드시 우리에게 좋아요와 구독을 눌러주시고, 더 많은 비꼬는 정보를 담은 기술 내용을 위해 박수를 치고 종아요 아이콘을 클릭하세요. 우리가 다루고 싶은 테크 가전제품이 있나요? 아래 댓글에 남겨주세요! 다음에 또 뵙기까지는, 귀하의 가전제품을 밀착하여, 유머 감각을 한층 가깝게 유지하세요. 호기심을 유지하고, 테크에 능숙하게 남아 있으며, Tech Ostrich와 함께 웃으면서 지내세요!\n\n\n\n테크 타조는 비인간 엔티티의 지원을 받아 만들어졌어요. 이 기사는 전문적인 조언으로 간주되지 않으며 인간 전문가와 상담이 필요합니다. 또한 오로지 엔터테인먼트를 위한 것입니다.","ogImage":{"url":"/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_0.png"},"coverImage":"/assets/img/2024-05-15-TechHacksTheBestWaystoOvercomplicateSimpleTasks_0.png","tag":["Tech"],"readingTime":5},{"title":"SQL에서 정규화 마스터하기","description":"","date":"2024-05-15 11:19","slug":"2024-05-15-MasterNormalizationinSQL","content":"\n\n\n![이미지1](/assets/img/2024-05-15-MasterNormalizationinSQL_0.png)\n\n![이미지2](/assets/img/2024-05-15-MasterNormalizationinSQL_1.png)\n\n데이터베이스 관리에서 중요한 개념인 정규화는 특히 SQL(구조화된 쿼리 언어)에서 중요합니다. 이는 데이터베이스의 효율성, 무결성 및 확장성을 보장하며, 데이터베이스의 데이터를 중복 없이 정리하고 의존성을 줄이는 프로세스입니다. SQL에서 정규화를 마스터하는 것은 효율적이고 확장 가능하며 유지보수가 용이한 데이터베이스를 생성하는 데 필수적입니다. 이 글에서는 정규화의 원칙과 기술을 자세히 살펴보고, 여러 형태와 효과적인 구현 방법에 대해 다룰 것입니다.\n\n# 정규화 이해하기:\n\n\n\n\n정규화는 데이터를 테이블로 구성할 때 발생하는 중복 및 종속성을 최소화하는 일련의 규칙에 기반하고 있습니다. 이 과정은 일반적으로 큰 테이블을 더 작고 관리하기 쉬운 작은 테이블로 나누고 그들 간의 관계를 정의하는 것을 포함합니다.\n\n## 정규화를 사용하는 이유:\n\n![MasterNormalizationinSQL_2](/assets/img/2024-05-15-MasterNormalizationinSQL_2.png)\n\n정규화를 숙달하기 전에 왜 정규화를 사용하며 정규화의 필요성에 대해 이해해야 합니다. 그래서 \"왜 정규화를 배워야 하는지\"에 대한 참고 자료를 가질 수 있게 됩니다.\n\n\n\n데이터베이스 설계에서 중요한 개념인 정규화는 데이터를 효율적으로 구성하고 데이터 무결성을 유지하는 데 사용됩니다. 여러 가지 중요한 목적을 가지고 있으며, 전반적으로 데이터베이스 시스템의 효과성과 신뢰성에 기여합니다:\n\n### 1. 중복 최소화:\n\n정규화는 큰 테이블을 작고 관리하기 쉬운 작은 테이블로 분해하여 중복 데이터를 제거하는 데 도움을 줍니다. 중복은 데이터베이스의 일관성 및 이상 현상을 유발할 수 있습니다. 데이터를 정규화된 형태로 저장함으로써 각 정보 조각이 한 곳에만 저장되어 일관성 문제의 가능성을 줄입니다.\n\n### 2. 업데이트 이상 방지:\n\n\n\n변경된 테이블은 날 위험성을 최소화하고 다른 곳에서 불일치나 오류가 발생하지 않도록 하는 정규화를 통해 발생할 수 있는 갱신 이상 현상을 방지합니다.\n\n## 3. 데이터 무결성 향상:\n\n데이터 무결성은 데이터베이스에 저장된 데이터의 정확성과 일관성을 의미합니다. 정규화는 부정확하거나 일관되지 않은 데이터를 저장하는 것을 방지하기 위한 제약 조건과 규칙을 강제함으로써 데이터 무결성을 향상시킵니다. 예를 들어, 각 열이 원자적(분할할 수 없는) 값만 포함하고 테이블 간의 관계가 올바르게 정의되도록 보장합니다.\n\n## 4. 쿼리 성능 향상:\n\n\n\n정규화된 데이터베이스는 쿼리에 대해 종종 더 효율적입니다. 데이터를 잘 정의된 관계를 가진 작은 테이블로 구성함으로써 쿼리를 더 빨리 효과적으로 실행할 수 있습니다. 정규화된 테이블은 일반적으로 특정 개체나 개념과 관련된 데이터를 저장하도록 설계되어 각 쿼리에 처리해야 하는 데이터 양을 줄입니다.\n\n## 5. 데이터베이스 유지관리를 간단하게:\n\n정규화된 데이터베이스는 유지 관리 및 업데이트가 시간이 지나서도 더 쉽습니다. 데이터베이스 구조를 수정해야 할 때(예: 새로운 필드나 테이블 추가), 정규화는 변경 사항을 다른 부분에 영향을 미치지 않고 적용할 수 있도록 합니다. 이를 통해 데이터베이스는 변화하는 요구 사항에 빠르게 적응할 수 있고 유지 보수 활동 중 오류 발생 가능성을 줄입니다.\n\n## 6. 확장 가능성을 용이하게하는:\n\n\n\n정규화된 데이터베이스는 본질적으로 확장 가능성이 높습니다. 데이터 양이나 데이터베이스의 복잡성이 증가함에 따라 정규화는 성능이나 데이터 무결성을 희생하지 않고 쉽게 확장할 수 있게 합니다. 새로운 테이블을 추가하거나 기존 테이블을 수정하거나 확장하여 새로운 요구 사항을 수용할 수 있습니다. 이렇게 하면 전체 데이터베이스 구조에 중요한 장애가 없이 확장할 수 있습니다.\n\n# 정규화 유형\n\n정규화는 데이터베이스 설계에서 사용되는 과정으로 데이터를 중복과 의존성을 최소화하는 구조화된 테이블로 구성합니다. 각각의 규칙 세트를 갖는 여러 가지 정규 형태가 있습니다. 다양한 유형의 정규화를 살펴보겠습니다:\n\n## 1. 제1정규화(1NF):\n\n\n\n1NF에 따르면, 테이블이 정규화되었다고 말할 수 있는 조건은 다음과 같습니다:\n\n- 각 열에는 원자적(분할할 수 없는) 값이 포함되어 있어야 합니다.\n- 열 내에 반복 그룹이나 배열이 없어야 합니다.\n- 테이블의 각 셀에는 하나의 값만 있어야 합니다.\n\n예를 들어, 각 셀이 반복 그룹이나 배열과 같은 것이 없이 하나의 값만 포함하고 있는 테이블은 1NF에 속합니다.\n\n## 2. 두 번째 정규형 (2NF):\n\n\n\n위의 내용을 친근한 톤으로 한국어로 번역하겠습니다.\n\n표가 2NF에 있다는 것은 다음과 같습니다:\n\n- 1NF에 있습니다.\n- 모든 비-키 속성이 기본 키 전체에 완전히 함수 종속성을 갖습니다.\n\n이는 모든 비-키 속성이 기본 키 전체에 의존해야 한다는 것을 의미합니다. 표가 복합 기본 키를 가지는 경우 각 비-키 속성은 복합 키 전체에 의존해야 하며 그 일부만으로는 안 됩니다.\n\n## 3. 세 번째 정규형 (3NF):\n\n\n\n3NF에있는 테이블은 다음과 같습니다:\n\n- 2NF에 있습니다.\n- 이러한 종속성이 없습니다.\n\n다시 말해, 비 주요 속성은 다른 비 주요 속성에 의존해서는 안됩니다. 이러한 종속성은 별도의 테이블을 생성하여 제거해야 합니다.\n\n## 4. Boyce-Codd Normal Form (BCNF):\n\n\n\nBCNF은 3NF의 강력한 형태이며 다음 조건을 만족할 때 달성됩니다:\n\n- 3NF에 있어야 합니다.\n- 모든 비자명 함수 종속인 𝑋→𝑌X→Y에 대해, X가 수퍼키여야 합니다.\n\n여기서 수퍼키는 테이블의 각 행을 고유하게 식별하는 속성 세트입니다.\n\n## 5. 제4 정규형 (4NF):\n\n\n\n4NF는 다중값 종속성을 해결하여 테이블이 다중값 속성이 없는 것을 보장합니다. 이것은 다중값 종속성을 제거하고 이를 위한 별도의 테이블을 생성함으로써 달성됩니다.\n\n## 6. 다섯 번째 정규 형태 (5NF):\n\n5NF, 또는 Project-Join 정규 형태 (PJ/NF)로도 알려져 있으며 조인 종속성을 다룹니다. 이는 테이블을 분해하여 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 결합될 수 있도록 보장함으로써 달성됩니다.\n\n# 주요 여정을 시작해봅시다!\n\n\n\n그래서, 지금까지 우리는 정규화가 무엇인지, 왜 정규화를 하는지, 그리고 정규화의 종류에 대한 기본 아이디어를 알게 되었습니다. 이 기본 지식을 바탕으로 정규화를 더 깊이 이해해볼 수 있게 되었습니다. 이제 메인 여정을 시작해봅시다.\n\n# 제1정규형 / 1NF\n\n제1정규형(1NF)은 정규화의 가장 기본적인 수준이며, 관계형 데이터베이스의 각 테이블이 원자 값만 포함하도록 하는 데 초점을 맞춥니다. 즉, 각 셀이 단일하고 분할할 수 없는 데이터 조각을 보유하도록 하는 것입니다. 이를 통해 열 내에서 반복 그룹이나 배열을 제거할 수 있습니다. 예제를 통해 1NF를 자세히 살펴봅시다:\n\n예제:\n\n\n\n학생들과 강의에 관한 정보를 저장하는 표를 생각해보세요. 이 표는 반복 그룹과 비원자적인 값을 포함하여 1NF를 위반합니다:\n\n![표](/assets/img/2024-05-15-MasterNormalizationinSQL_3.png)\n\n예제의 문제점:\n\n- 반복 그룹: \"Courses\" 열에는 쉼표로 구분된 여러 값을 포함합니다. 이는 1NF의 원자성 규칙을 위반합니다.\n- 비원자적인 값: \"Courses\" 열의 값은 원자적이지 않으며, 여러 조각의 데이터를 나타냅니다.\n\n\n\n이 표를 1NF로 바꾸려면 각 행에 원자 값만 포함되도록 여러 행으로 분할해야 합니다.\n\n## 1NF에서 재구성된 표:\n\n![Restructured Table in 1NF](/assets/img/2024-05-15-MasterNormalizationinSQL_4.png)\n\n설명:\n\n\n\n- \"Course\" column의 각 행은 이제 원자성 규칙을 준수하며 하나의 값만 포함합니다.\n- 반복 그룹이 제거되었고, 각 학생-과정 조합이 별도의 행으로 표시됩니다.\n\n## 제2 정규형 / 2NF\n\n제 2 정규형(2NF)은 부분 종속성 문제를 해결함으로써 제 1 정규형(1NF)을 기반으로 합니다. 이는 테이블 내의 모든 비-키 속성이 전체 주 키에 완전히 기능적으로 종속되도록 보장합니다. 예시를 통해 2NF를 자세히 살펴보겠습니다:\n\n예시:\n\n\n\n책과 저자 정보를 저장하는 테이블을 고려해보세요. 아래는 테이블이 어떻게 보일지에 대한 예시입니다:\n\n![테이블 예시](/assets/img/2024-05-15-MasterNormalizationinSQL_5.png)\n\n예시의 문제점:\n\n- 테이블은 복합 기본 키(BookID, AuthorID)를 포함하고 있습니다. 여기서 BookID는 책을 고유하게 식별하지만 AuthorID는 저자를 고유하게 식별하지 않습니다.\n- \"AuthorName\" 열은 AuthorID에만 종속되어 있으며 전체 기본 키에 종속되지 않습니다.\n- 이 테이블은 2NF를 위반합니다. AuthorName이 기본 키의 일부 (AuthorID)에 함수적으로 종속되어 있기 때문입니다.\n\n\n\n## 2NF에 재구성된 테이블:\n\n테이블을 2NF로 변경하기 위해 테이블을 두 개로 나눴어요: 책을 위한 하나와 작가를 위한 다른 하나입니다.\n\n![테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_6.png)\n\n## 설명:\n\n\n\n- Books 테이블에서 BookID가 기본 키(primary key)입니다.\n- Books 테이블의 AuthorID는 현재 Authors 테이블을 참조하는 외래 키(foreign key)입니다.\n- Authors 테이블에는 AuthorID가 기본 키로 포함되어 있습니다.\n- Authors 테이블은 각 작가의 이름이 중복으로 저장되지 않도록 보장합니다.\n- Authors 테이블은 AuthorID에 의해 결정되는 AuthorName이 전체 기본 키에 기능적으로 의존할 수 있습니다.\n\n## 제 3 정규형 / 3NF\n\n제 3 정규형(3NF)은 제 1 정규형(1NF)과 제 2 정규형(2NF)의 원칙을 확장하여 이행 종속성(transitive dependencies)을 다룹니다. 이는 비 기본 키(non-key attributes)가 다른 비 기본 키에 의존하지 않고 기본 키에만 의존하도록 보장합니다. 예시를 통해 3NF를 알아보겠습니다:\n\n예시:\n\n\n\n직원 및 부서에 관한 정보를 저장하는 테이블을 고려해보세요. 테이블에는 부서 관리자의 전화번호도 포함되어 있습니다.\n\n다음은 이 예시에 관한 문제점입니다:\n\n- 이 테이블에는 이행 종속성이 포함되어 있습니다: ManagerPhone이 기본 키가 아닌 Manager에 종속되어 있습니다.\n\n\n\n## 3NF로 재구성된 테이블:\n\n테이블을 3NF로 변경하기 위해 이원종속성을 제거해야 합니다. 테이블을 직원, 부서 및 매니저로 세 개의 별도 테이블로 분할할 것입니다.\n\n![테이블 이미지](/assets/img/2024-05-15-MasterNormalizationinSQL_8.png)\n\n설명:\n\n\n\n- 사원 테이블은 사원별 정보를 포함하며, 주요 키로 EmployeeID가 사용됩니다.\n- 부서 테이블은 각 부서에 대한 정보를 포함하며, 주요 키로 DepartmentID가 사용됩니다.\n- 매니저 테이블은 각 매니저에 대한 정보를 포함하며, 주요 키로 ManagerID가 사용됩니다.\n- 원본 테이블에서 ManagerPhone은 주키가 아닌 Manager에 종속적입니다. 테이블을 분할하여 이 체이닝 종속성을 제거합니다.\n\n# Boyce-Codd 정규형 (BCNF)\n\nBoyce-Codd 정규형(BCNF)은 제3 정규형(3NF)의 원리를 기반으로 한 더 높은 정규화 수준입니다. BCNF는 특정 유형의 기능적 종속성을 다루어 모든 비자명 기능적 종속성 𝑋→𝑌X→Y에 대해 결정자(X)가 수퍼키임을 보장합니다. 예시를 통해 BCNF를 살펴봅시다:\n\n예시:\n\n\n\n다음은 강의와 강사 정보를 저장하는 테이블을 고려해보세요:\n\nIssues with the Example:\n\n- The table contains a non-trivial functional dependency: 𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝐼𝐷→𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝑁𝑎𝑚𝑒,𝐸𝑚𝑎𝑖𝑙\n- The InstructorID determines both the InstructorName and Email, but InstructorID is not a superkey since multiple instructors can have the same ID.\n\n\n\n## BCNF로 재구성된 테이블:\n\n테이블을 BCNF로 가져오려면 모든 비자명 함수 종속의 결정자가 수퍼키여야 함을 보장해야 합니다. 테이블을 두 개로 분할할 것입니다: Courses와 Instructors.\n\n![BCNF 테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_10.png)\n\n설명:\n\n\n\n- Courses 테이블은 각 과정에 대한 정보를 포함하며 CourseID가 기본 키로 사용됩니다.\n- Instructors 테이블은 각각의 강사에 대한 정보를 포함하며 InstructorID가 기본 키로 사용됩니다.\n- 원래 테이블은 BCNF를 위반합니다. 이유는 InstructorID가 InstructorName과 Email을 모두 결정하고, InstructorID가 슈퍼키가 아니기 때문입니다. 테이블을 분할함으로써, 모든 비자명 함수 종속성의 결정자가 슈퍼키임을 보장합니다.\n\n# 제4 정규형 / 4NF\n\n4차 정규형(4NF)은 다중 값 종속성을 처리하여 제3 정규형(3NF)을 넘어가는 정규화 수준입니다. 데이터베이스 스키마에 비자명 다중 값 종속성이 없는지 확인합니다. 예제를 통해 4NF를 살펴보겠습니다:\n\n예시:\n\n\n\n프로젝트 및 해당 프로젝트에 배정된 직원, 그리고 각 직원이 책임지는 작업에 대한 정보를 저장하는 테이블을 고려해보세요:\n\n\n![테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_11.png)\n\n\n예제의 문제점:\n\n- 다중 값 종속성이 있습니다. 예를 들어 (프로젝트ID, 직원ID)의 조합이 여러 TaskID와 TaskName 쌍을 결정합니다.\n- 테이블은 비자명 다중 값 종속성을 포함하고 있어 4NF를 위반합니다.\n\n\n\n## 4NF에서 재구성된 테이블:\n\n테이블을 4NF로 전환하기 위해 다중 값 종속성을 제거하고 별도의 테이블로 분할해야 합니다.\n\n![Restructured Table](/assets/img/2024-05-15-MasterNormalizationinSQL_12.png)\n\n설명:\n\n\n\n- Projects 테이블은 ProjectID를 기본 키로 포함합니다.\n- Employees 테이블은 EmployeeID를 기본 키로 포함합니다.\n- Tasks 테이블은 ProjectID와 EmployeeID를 외래 키로 포함하며 TaskID를 기본 키로 포함합니다.\n- Tasks 테이블의 각 행은 프로젝트에서 직원에게 할당된 단일 작업을 나타냅니다.\n- 원래 테이블을 세 개의 별도 테이블로 분할함으로써 다중 값 종속성을 제거하여 데이터베이스 스키마가 4NF를 준수하도록 합니다.\n\n# 다섯 번째 정규 형식 / 5NF\n\n다섯 번째 정규 형식 (5NF), 또는 프로젝트 조인 정규 형식 (PJ/NF)은 조인 종속성을 다루며 데이터베이스 스키마에 조인 이상 현상이 없는 것을 보장합니다. 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 조인될 수 있도록 테이블을 분해하는 것을 포함합니다. 예제로 5NF를 살펴봅시다:\n\n예시:\n\n\n\n학생, 강의 및 각 강의에서 학생들이 받은 성적에 대한 정보를 저장하는 표를 고려해 보세요:\n\n\n| StudentID | StudentName | CourseID | CourseName | Grade |\n|-----------|-------------|----------|------------|-------|\n| 1         | Alice       | 1        | Math       | A     |\n| 2         | Bob         | 1        | Math       | B     |\n| 1         | Alice       | 2        | Science    | B     |\n\n\n예제의 문제점:\n\n- 표에 결합 의존성이 있는데, 특정 속성이 다른 속성들의 조합에 따라 종속되어 있습니다.\n- 예를 들어, CourseName은 CourseID에 의해 결정되며, Grade는 StudentID와 CourseID의 조합에 의해 결정됩니다.\n\n\n\n## 5NF로 재구성된 테이블:\n\n테이블을 5NF로 가져오기 위해 조인 종속성을 제거하기 위해 여러 개의 테이블로 분해합니다:\n\n![테이블 이미지](/assets/img/2024-05-15-MasterNormalizationinSQL_14.png)\n\n## 설명:\n\n\n\n- 학생 테이블은 주요 키로 학생ID와 이름을 포함합니다.\n- 강좌 테이블은 주요 키로 강좌ID와 강좌명을 포함합니다.\n- 성적 테이블은 외래 키로 학생ID와 강좌ID를 포함하며 성적이 있습니다.\n- 원본 테이블을 세 개의 별도 테이블로 분해함으로써 조인 종속성을 제거하여 데이터베이스 스키마가 5NF를 준수하도록 보장합니다.\n\n# 결론:\nSQL에서 정규화를 숙달하는 것은 효율적이고 확장 가능한 데이터베이스를 설계하는 데 중요합니다. 정규 형태를 이해하고 효과적으로 구현함으로써 데이터 무결성을 보장하고 중복을 줄이며 데이터베이스 관리를 간소화할 수 있습니다. 새 데이터베이스를 설계하거나 기존 데이터베이스를 최적화하는 경우 정규화 원칙은 견고하고 신뢰할 수 있는 데이터 인프라를 유지하는 데 필수적입니다.","ogImage":{"url":"/assets/img/2024-05-15-MasterNormalizationinSQL_0.png"},"coverImage":"/assets/img/2024-05-15-MasterNormalizationinSQL_0.png","tag":["Tech"],"readingTime":9},{"title":"별호수 OSS 데이터 엔지니어링과 데이터 분석에 선언적 프로그래밍을 제공하다","description":"","date":"2024-05-15 11:17","slug":"2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics","content":"\n\n# 소개\n\nAnsible 및 Terraform과 같은 도구를 통해 선언적 프로그래밍이 등장한 것은 개발자들이 코드 실행 순서를 지정하지 않고 의도한 목표를 달성할 수 있게 해서 인프라 배포를 혁신적으로 변경했습니다.\n\n이러한 패러다임 변화는 오류율 감소, 개발 주기 단축, 코드 가독성 향상 및 모든 수준의 개발자들을 위한 접근성 향상과 같은 혜택을 가져오게 됩니다.\n\n이것은 작은 개발팀이 선언적 접근 방식을 적용하여 데이터 추출, 로딩, 변환, 조정에 대한 기존의 데이터 엔지니어링 경계를 넘어선 플랫폼을 만들어낸 이야기입니다.\n\n\n\n![2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics_0](/assets/img/2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics_0.png)\n\n# 시작\n\n2015년, ebiznext의 세심한 데이터 엔지니어링 회사에서 한 가지 어려운 과제를 직면했습니다. 강력한 빅데이터 솔루션을 필요로 하는 유명한 고객이 하둡과 스파크의 힘을 이용하려 했습니다. 우리는 20명의 작은 규모에도 불구하고 (100,000명 이상의 인원수를 가진) 산업 거물과 경쟁하기로 결심했습니다.\n\n성공하기 위한 유일한 기회는 혁신이었습니다: 산업 거물들이 밀어올리는 전통적인 ETL 솔루션을 지수적으로 능가할 수 있는 데이터 플랫폼이 필요했습니다. 이 GUI 기반 ETL을 사용해 데이터 파이프라인을 구축하려면 원본의 수와 복잡성에 비례하는 노력이 필요합니다.\n\n\n\n일반적으로 따르는 규칙을 깨기 위해, 우리는 DevOps 친화적인 플랫폼을 개발하기 위한 여정에 나섰습니다. 이 플랫폼은 모든 소스로부터 빠르게 데이터를 수집할 수 있는 기능을 갖추고 있습니다. 또한 ETL 또는 전문 엔지니어링 기술의 단점은 없습니다.\n\n입찰 날, 몇 달이 아닌 몇 주 안에 데이터를 로드할 수 있는 솔루션을 제공할 수 있는 능력 덕분에 경쟁사와 차별화되어 프로젝트를 수주할 수 있었습니다.\n\n# 에피소드 1: 스마트레이크의 등장\n\n\"스마트레이크를 만들 때의 기본 아이디어는 데이터 품질이 데이터를 로드한 후에 확인되면 데이터 웨어하우스가 깔끔한 상태로 유지될 수 없으며, 이러한 데이터 로드 전 품질 검사는 데이터 소유자가 처리해야 한다는 것이었습니다.\"\n\n\n\n왼쪽으로 기울어진 선언적 접근을 받아들일 수밖에 없는 이유가 되었습니다. 비즈니스 사용자들을 강화시키면서, 데이터 형식과 변환을 간단한 JSON 파일로 설명할 수 있는 시스템을 고안했습니다. Smartlake는 단순한 코드 생성기가 아니었으며, 다양한 데이터 형식을 원활하게 수용하고, 변환을 실행하며, 비교할 수 없는 효율로 작업을 조율하는 다재다능한 엔진이었습니다.\n\n사용자 상호작용을 간소화하기 위해 직관적인 Excel-to-JSON 변환기를 고안해 입력 형식을 쉽게 지정할 수 있도록 했습니다. Smartlake와 그 선언적 접근 덕분에 비즈니스 사용자들은 몇 분 안에 로드와 변환 작업을 정의할 수 있었습니다.\n\nSmartlake의 특징\n\n- 거의 모든 파일 형식(CSV, JSON, XML, FIXED WITH, 다중 레코드 유형, kafka 토픽 등) 로드\n- 사용자 정의 스키마 및 의미론적 유형을 사용하여 필드 유효성 검사\n- 로드되는 데이터에 대해 변환을 즉석으로 적용( GDPR, 정규화, 계산 필드 추가) 및 스키마 진화 여부와 상관없이\n- Spark, Kafka, Elasticsearch 등 대부분의 대상에 싱크\n\n\n\n# 에피소드 2: 스타레이크로의 진화\n\n\"스타레이크의 기본 아이디어는 서버리스 서비스와 클라우드 데이터웨어하우스 기능을 활용하여 Smartlake의 모든 이점을 클라우드로 가져오면서 개발 및 실행 비용을 최소화하는 것이었습니다.\"\n\n데이터 환경이 발전함에 따라 우리의 비전도 발전했습니다. 클라우드 데이터 웨어하우스가 Spark에 대한 쿼리 실행에 대한 강력한 경쟁자로 등장했습니다. 이러한 변화를 인식하고 Smartlake를 Starlake로 발전시켰습니다. Starlake는 YAML을 통해 가독성을 향상시키면서 선언적인 본질을 보존했습니다. 우리는 Spark의 뛰어난 기능을 유지하여 데이터 수집을 위해 단일 또는 여러 컨테이너 내에서 실행하고 쿼리 실행을 위해 클라우드 데이터 웨어하우스를 활용했습니다.\n\n이 전략적인 조합을 통해 특정 워크로드 요구에 기반한 성능 및 비용 효율성을 최적화할 수 있었습니다. 결과적으로 클라우드 시대에 맞춘 재구상된 플랫폼이 탄생했으며, 그 본질은 효율과 간결함에 기반을 둔 것으로 정의되었습니다.\n\n\n\n별호 발표 결과물은 Github에서 찾을 수 있는 Starlake OSS 프로젝트입니다.\n\nStarlake의 기능은 여기 자세히 설명되어 있습니다.\n\n# Starlake 뒤에 숨은 사람들\n\nStarlake의 전신인 Smartlake는 다수의 개인들의 노력에 의해 생겼지만, 특별한 기여를 한 몇몇 사람들이 두드러지게 돋보입니다:\n\n\n\n- 샘 베살라: 샘의 참여로 다른 사람들을 동원하는 것이 쉬워졌습니다. 그의 선도적인 전망과 복잡성을 단순하게 만들어내는 재능은 혁신적이었으며, 구현에 새로운 표준을 정했습니다.\n- 올리비에 지라루: 모든 팀에는 코딩 마법사가 있고, 올리비에는 그 역할을 완벽하게 수행했습니다. Spark 코드 생성(CodeGen)을 활용하여 마트료시카와 같은 수학적 프레임워크를 탐험함으로써 팀을 멘토링하는 것을 넘어서 경계를 넓혔습니다. 그의 전문 지식은 Docker, Ansible, Python, Scala 및 Spark 내부까지 이어졌습니다.\n- 발란탱 카사스: 발란탱은 Scala에서 함수형 프로그래밍을 주창했습니다. 재귀 구조와 같은 개념을 소개함으로써 팀이 기능적이면서도 우아하고 유지보수 가능한 코드를 작성할 수 있도록 자유롭게 했습니다.\n\n구름을 향한 여정이 진행됨에 따라 오랜 기간 데이터 전문가들이 합류하여 스타레이크를 오늘날의 모습으로 만들었습니다:\n\n- 스테판 만시오: 에어플로우와 다그스터 위에 스타레이크의 선언적 워크플로우를 개발한 개발자로, 이를 통해 운영의 중추를 형성하는 데 결정적 역할을 했습니다.\n- 붕콩 캄푸손: 스타레이크의 추출 및 로드 엔진의 속도와 효율성은 그의 기여에 많이 의존합니다.\n- 시릴 셰퍼로: 코드베이스 최적화의 달인으로, 시릴의 코드 재작업 노력은 스타레이크 API의 재진입성을 확보하는 데 중요했습니다.\n- 압델하미드 이라리브: 로드 엔진에 조기 기여를 한 인물로, 이처럼 선견지명과 실행 능력은 플랫폼의 현재 능력에 중요한 영향을 미쳤습니다.\n- 모하마드 카시르: 고객 프로젝트에 직접 참여하고 클라우드 플랫폼 및 비즈니스 요구 사항에 대한 심도 있는 지식을 확보한 그의 능력은 스타레이크의 진화에 큰 장점이 됐습니다.\n\n오늘날 매일 수천 개의 테이블로 변환되어 수천 개의 데이터 웨어하우스에 매일 수백 기가바이트의 데이터가로드되는 것을 자신 있게 스타레이크는 가장 까다로운 데이터 엔지니어링 및 분석 도전에 대비할 준비가 되어 있다고 말할 수 있습니다.\n\n\n\n스타레이크는 지금 그리고 항상 오픈 소스입니다. 지원하는 커뮤니티 구축에 참여해 주세요. 여러분의 의견과 기능 요청은 환영받을 뿐만 아니라 우리 로드맵을 이끕니다.\n\n스타레이크를 시작해보세요:\n\n- 다른 기능을 살펴보세요.\n- 문서를 살펴보세요.\n\nGitHub에서 저희 커뮤니티에 참여해 주세요.\n\n\n\n제발 이 저장소에 별을 주세요: https://github.com/starlake-ai/starlake. Starlake 관련 문제나 개선사항이 있으면 언제든지 알려주세요. 물론 친절한 관리 대상이 될 겁니다.","ogImage":{"url":"/assets/img/2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics_0.png"},"coverImage":"/assets/img/2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics_0.png","tag":["Tech"],"readingTime":4},{"title":"Pew의 Fiscal 50을 역동적 시각화로 개편하기","description":"","date":"2024-05-15 11:16","slug":"2024-05-15-RevampingPewsFiscal50withDynamicVisualizations","content":"\n\n## Pew은 Graphicacy와 협력하여 2013년에 사이트를 발표한 후, Fiscal 50 웹사이트를 새롭게 할 필요를 느꼈습니다. 이 때문에 새로운 모바일 친화적이고 현대적인 디자인으로 업그레이드되었으며 새로운 주별 페이지가 추가되었습니다.\n\n2013년, Pew은 Fiscal 50을 론칭했는데, 이는 주요 정책 결정자, 언론 및 대중이 장기간 예산 트렌드를 이해하는 데 도움을 주기 위한 것이었습니다. 이 사이트에는 주별 장기적인 재정 건강을 측정하는 재정 및 경제 지표에 대한 상호작용 그래픽이 특징이었습니다.\n\n론칭 당시 혁신적인 Fiscal 50은 곧 존경받는 자원이 되었습니다. 그러나 10주년을 기념하는 이 시점에 사이트가 낡아 보이기 시작했습니다.\n\nFiscal 50 사이트를 새롭게 소생시키고 현대적으로 만들기 위해 Pew은 Graphicacy와 협력하여 새로운 차트를 포함한 응답형 그래픽을 재디자인 및 개발하였으며, 주 수준의 집중도를 높이고 새로운 데이터가 업데이트될 때 텍스트와 숫자를 정기적으로 업데이트할 수 있는 창의적인 프로세스를 발전시켰습니다.\n\n\n\n![그림](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_0.png)\n\n## 신뢰할 수 있는 자료를 기반으로\n\n\"Fiscal 50 프로젝트 디렉터인 멜리사 메이너드는 '10년이 지난 후에는 이 작업을 재구상할 필요가 있었습니다.'라고 말했습니다. '사용자들이 플랫폼에서 무엇을 얻고 있기를 원했는지, 그리고 기대하고 있던 것들 뿐만 아니라, 새로운 접근 방식을 도입하고 실험을 해야 할 필요성도 명확히 보았습니다.'\"\n\nPew의 창의적인 팀원 중 한 명이 멜리사가 Graphicacy에 연락을 취해보라고 권유했는데, 두 기관의 방식과 미학이 일치했습니다. 경쟁 입찰 과정을 통해 Pew 팀은 Graphicacy가 프로젝트의 비전과 목표를 완전히 받아들였고 혁신적인 아이디어를 제시할 것이라는 것을 명확히 알게 되었습니다. 멜리사는 \"Graphicacy와 협업하는 것은 우리를 안락지대에서 빼내 줄 것\"이라고 지적했습니다.\n\n\n\nGraphicacy의 추가로 Fiscal 50, Pew 창조 및 디지턈, Graphicacy 팀 간에 \"엄청난 강력한 3단 창조적 협업\"이 만들어졌다고 덧붙였다. 매 팀원이 그들의 강점과 직관을 가지고 전반적인 프로젝트를 더 도전적인 방향으로 이끌었다.\n\n## 서로의 언어를 말하기\n\nGraphicacy는 Fiscal 50 사이트의 상하구조를 완전히 재구성하는 도전을 환영했다. \"우리는 즉시 더 반응성이 있고 유연한 플랫폼이 필요하다는 것을 알았습니다,\"라고 말한 Carni Klirs, Graphicacy의 창조적 이사, 데이터 시각화. \"Pew와 협력하여 어떤 장치에서도 작동하고 최신 브라우저에서 실행되는 새 모바일 중심 사이트를 구축하고자 했습니다.\"\n\nPew도 시간이 지남에 따라 더 많은 차트 뷰를 추가하고 자신들의 데이터를 쉽게 업데이트할 수 있는 플랫폼이 필요했다. \"사이트는 몇 주마다 콘텐츠를 새롭게 업데이트할 것이며,\" Melissa가 말했다. \"그리고 Fiscal 50의 여덟 가지 주요 지표는 신선한 데이터가 사용 가능해질 때마다 매년 한 두 차례 업데이트될 것이다.\"\n\n\n\n빈번한 사이트 변경을 위해 Graphicacy는 Fiscal 50 팀을 위한 툴킷을 구축했습니다. \"우리는 Pew의 창의적 및 디지털 팀과 협력하여 툴킷을 활용하고, Graphicacy와 계속 협력하여 향상시키는 데 도움을 줄 것입니다,\" 멜리사가 설명했습니다.\n\n\"사이트를 업데이트하는 방법을 알아내면서 서로의 언어를 배워야 했습니다,\" 그녀는 덧붙였습니다. \"Carni와 Graphicacy 팀은 훌륭한 커뮤니케이터였습니다. 그들은 우리를 들어주고, 우리 방식을 배우고, 학습 곡선을 통해 도와주기 위해 시간을 내주었습니다.\"\n\n## 주 State Level에서 동적 데이터\n\nFiscal 50 사이트를 현대적이고 모바일 중심의 시대로 가져올 뿐만 아니라, Graphicacy는 Pew가 처음으로 각 주별 페이지를 작성해야 하는 필요를 처리했습니다.\n\n\n\n\"우리의 청중 중 일부는 국가적 관점에서 주요 예산 동향을 따라가지만 대부분의 사람들은 주변 주의 관점에서 우리의 데이터와 연구가 무슨 뜻을 갖는지에 주로 관심이 있습니다,\" Melissa는 말했습니다.\n\n\"이 전면 개편으로 Graphicacy는 각 주를 위한 데이터와 우리의 통찰을 다시 구성하는 데 도움을 주었는데, 동시에 국가적 및 지역적 맥락을 제공하는 방식으로도했어요.\"\n\n이에 Graphicacy는 Pew의 재정 팀의 데이터와 연구 통찰을 결합한 동적 주별 페이지를 만들었습니다. 이 페이지들은 각 주의 여덟 가지 주요 지표의 성과를 보여주며, 모든 지표에는 더 자세한 정보를 보여주는 확장 가능한 대화식 도트 플롯이 있습니다.\n\n![이미지](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_1.png)\n\n\n\n국가 페이지는 이제 completely redesigned되어 상단부터 완전히 다시 만들어진 Indicator 페이지와 함께 존재합니다. Pew와 Graphicacy는 페이지의 구조와 흐름에 협력하여 차트 뷰 사이에 설명 텍스트를 엮어 독자들의 이해를 돕는데 협력했습니다.\n\n\"Carni는 '우리는 지도, 선 그래프, 영역 차트, 몇 가지 다른 종류의 타일 지도 및 막대 차트를 포함한 포괄적인 차트 시스템을 설계하고 구축했습니다. 각 차트는 다른 지표 간에 재사용될 수 있도록 유연하게 설계되었으며, 고도의 사용자 정의가 가능했습니다'\"라고 말했습니다.\n\n![이미지](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_2.png)\n\n## 데이터 중심 텍스트\n\n\n\n이러한 새로운 기능을 지원하고 자주 업데이트를 가능하게 하기 위해 Graphicacy는 개편된 Fiscal 50을 위한 혁신적인 기능을 개발했습니다: 데이터 기반 텍스트.\n\n![이미지](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_3.png)\n\n![이미지](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_4.png)\n\n\"우리는 Pew가 데이터 값으로 대체될 수 있는 토큰을 사용하여 서술 텍스트를 작성할 수 있는 동적 텍스트 엔진을 개발했습니다. 이러한 값들은 차트에 표시된 현재 데이터를 보여주기 위해 실시간으로 업데이트됩니다. 이 엔진은 '크다' 또는 '작다'와 같은 함수 및 조건문을 처리할 수도 있습니다. 예를 들어 숫자가 다른 숫자보다 높거나 낮다면 해당 내용을 표시할 수 있습니다,\" Carni이 설명했습니다. \"동적 텍스트를 사용하여 복사본을 작성하는 것이 처음에는 약간 어려울 수 있지만, 우리는 그들이 자신감을 갖고 사용할 수 있도록 훈련시켰습니다.\"\n\n\n\n\"데이터 기반 캡션은 각 주에 특화된 추가적인 세분화 및 통찰을 제공합니다,\" Melissa가 말했습니다. \"정기적인 데이터 업데이트가 있기 때문에, 이들은 많은 작업을 대신하고 새 플랫폼을 위해 추가 콘텐츠를 생산하는 데 직원의 시간을 절약할 것입니다.\"\n\n동적 캡션을 활용하면 Pew의 팀이 일하는 부담이 줄어들지만, 이는 해당 기관으로 유명한 깊이 있는 분석을 유지합니다. \"우리는 아직도 데이터를 통해 독자를 안내하고 '전체 의미는 무엇인가?'라는 질문에 답하는 자세한 분석을 제공하고 있습니다.\"\n\n## 계속되는 협업\n\n새 Fiscal 50 웹사이트가 론칭되면, Melissa는 Graphicacy와 계속해서 사이트를 개선하고 툴킷을 강화하는 과정에서 지속적인 협업에 기대하고 있습니다.\n\n\n\n“Graphicacy와 Pew의 파트너십은 모두의 강점을 살렸다고 해요,\" 그녀가 말했습니다. “우리는 Graphicacy가 항상 우리의 의견을 경청해주고, Fiscal 50가 잘 작동하는 비결을 배우려는 의지에 감동받았습니다. 우리가 상상한 것 이상을 이룰 수 있도록 이끄는 모습도 인상적이었죠.\"\n\nGraphicacy는 귀하와 같은 기관들이 자료, 숫자, 트렌드를 활용하여 권위 있는, 도발적이고, 영감을 주는 이야기를 전달하는 데 도움을 줍니다. 이를 통해 귀하의 사명이 중요한 이유와 관중이 그 문제와 귀하의 작업에 어떤 역할을 해야 하는지를 안내합니다.\n\n이것이 시각적 이야기의 힘입니다. 이는 사람들을 끌어들이고 그들을 문제와 여러분의 작업에 감정적으로 이어줍니다. 이는 그들이 눈을 뗄 수 없는 경험을 만들어주며, 문제에 대해 무언가를 하도록 초대합니다.\n\nGraphicacy는 빌 앤 멜린다 게이츠 재단, 세계자원 연구소, Everytown for Gun Safety, 세계은행, 존스 홉킨스 대학 보름버그 보건학교 등 국내외의 최고 기관 및 기업을 위해 데이터 시각화 및 인포그래픽을 제작해왔습니다.","ogImage":{"url":"/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_0.png"},"coverImage":"/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_0.png","tag":["Tech"],"readingTime":5},{"title":"Windows 키 조합 단축키의 숨겨진 잠재력을 발견하세요","description":"","date":"2024-05-15 11:14","slug":"2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts","content":"\n\n![image](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_0.png)\n\n# 윈도우 키, 시작 메뉴로만 사용되는 것이 아닙니다!!\n\n많은 사람들이 키보드의 윈도우 키(윈도우 로고 키)가 시작 메뉴를 열 뿐이라고 생각합니다(Ctrl+Esc로도 동일한 기능이 수행됩니다). 하지만 다른 키들과 함께 누르면 강력한 바로 가기가 트리거되어 업무 흐름을 변화시키며, 결국에는 마우스를 사용하지 않고 키보드로만 탐색할 수 있게 됩니다.\n\n마우스로 클릭하는 것도 작업을 완료할 수 있지만, 키보드 바로 가기는 속도 면에서 이점을 제공하며 키보드에 손을 유지하는 것이 장점입니다. 키보드 바로 가기는 마우스 클릭보다 더 빠르게 작동할 수 있습니다. 이 글에서는 윈도우 10/11에서 시작하는 데 유용한 일부 바로 가기 키에 초점을 맞춰 설명하겠습니다. 이러한 바로 가기는 특정 작업을 더 쉽고 빠르게 시작하고 수행할 수 있습니다.\n\n\n\n와~ 키보드 단축키를 숙달하고 단디 타이핑을 하려면 전체 단축키를 한 번에 외운 것이 힘듭니다. 시작해보시면 어느샐 것에요. 꾸준한 사용이 중요하니까, 키보드 단축키 프로가 되고 싶다면 꾸준한 사용이 필수에요!!\n\n그래서, 그걸 한 번 살펴봅시다!\n\n- `Windows 키 + Q 또는 S`: Cortana 검색창을 연 상태로 타입 인풋을 사용할 수 있어요.\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_1.png)\n\n\n\n- `Windows 키 + W`: 위젯 메뉴 열기\n\n- `Windows 키 + E`: 파일 탐색기 열기\n\n- `Windows 키 + R`: 실행 명령 열기\n\n![Windows Key Combination Shortcuts](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_2.png)\n\n\n\n- `Windows 키 + T: 작업 표시줄에 고정된/열린 아이콘에 초점\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_3.png)\n\n- `Windows 키 + Y: 데스크탑과 Windows Mixed Reality 간의 입력 전환\n\nWindows Mixed Reality와 데스크탑 간의 입력을 전환하는 바로 가기로 사용됩니다. Windows Mixed Reality 장치를 사용 중이라면 이 키 조합이 매우 편리할 수 있습니다!\n\n\n\n- `Windows 키 + U`: 접근성 설정 화면 열기\n\n![](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_4.png)\n\n- `Windows 키 + I`: 시스템 설정 화면 열기\n\n- `Windows 키 + O`: 기기 방향 잠금\n\n\n\n- `Windows 키 + P` : 프레젠테이션 또는 프로젝션 사이드바 열기\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_5.png)\n\n- `Windows 키 + A` : 빠른 설정 패널 열기\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_6.png)\n\n\n\n- `Windows 키 + D`: 열린 응용 프로그램 최소화 및 최대화하기\n\n- `Windows 키 + F`: 피드백 허브 열기\n\n- `Windows 키 + G`: Xbox 게임 바 열기\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_7.png)\n\n\n\n이 기능을 사용하면 게임을하는 동안 비디오를 녹화하고 스크린 샷을 찍거나 서드파티 응용 프로그램없이 원하는 작업을 할 수 있습니다.\n\n- ` Windows 키 + H : 음성 입력 팝업\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_8.png)\n\n- ` Windows 키 + J : Windows 팁에 포커스 설정시 옵션이 사용 가능합니다.\n\n\n\n- ` Windows 키 + K: 캐스트 패널 열림\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_9.png)\n\n- ` Windows 키 + L: PC 잠금 또는 계정 전환\n\n- ` Windows 키 + Z: Snap Layout 메뉴\n\n\n\n\n![image](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_10.png)\n\nThis feature makes it easier to arrange multiple apps side by side on your screen.\n\n- Windows key + X: Opens the Quick Link menu\n- Windows key + C: It will open Microsoft’s Copilot\n\n\n\n\n- `Windows 키 + V: 클립보드 팝업\n\n- `Windows 키 + B: 숨겨진 아이콘 보기\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_11.png)\n\n- `Windows 키 + N: 알림 센터 및 캘린더 열기\n\n\n\n<img src=\"/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_12.png\" />\n\n- `Windows key + M`: 모든 열려 있는 애플리케이션을 최소화합니다.\n\n최소화한 모든 창을 복원하려면 'Windows 키 + Shift + M'을 누르세요.\n\n- `Windows key + Comma (,)`: 일시적으로 앱을 숨겨서 데스크톱을 보여줍니다.\n\n\n\n- `Windows 키 + 마침표 (.) 또는 세미콜론 (;)`: 이모지 패널을 팝업합니다.\n\n- `Windows 키 + 1-9 숫자`: 작업 표시줄의 고정된 애플리케이션을 번호순으로 액세스합니다.\n\n![image](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_13.png)\n\n이 목록은 Windows 키의 가능성을 약간 소개한 것에 불과합니다. 특정 애플리케이션에 대한 바로 가기키를 탐색하고 사용 환경을 맞춤 설정해보세요. 조금의 연습을 통해 Windows를 전문가처럼 탐색하고 소중한 시간을 절약할 수 있을 겁니다!\n\n\n\n그럼에도 불구하고 때때로 필요한 유용한 단축키들이 많이 있습니다. 이들은 윈도우 키를 다른 키/키와 결합하여 더 효율적으로 작업을 수행하는 것을 포함합니다. 모든 것을 기억하는 것은 불가능하지만, 미래 참조를 위해 이 페이지를 즐겨찾기하는 것이 좋은 생각일 수 있습니다. 그리고 더 많은 콘텐츠를 보려면 팔로우해주세요.\n\n업데이트를 받기 위해 다른 플랫폼에서도 저를 팔로우해 주시기 바랍니다.\n\nGitHub | LinkedIn | Twitter(X)","ogImage":{"url":"/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_0.png"},"coverImage":"/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_0.png","tag":["Tech"],"readingTime":4},{"title":"컨테이너 내부 시리즈 파트 3 마운트 네임스페이스","description":"","date":"2024-05-15 11:11","slug":"2024-05-15-ContainerInternalsSeriesPart3MountNamespace","content":"\n\n## Golang을 사용하여 Linux 마운트 네임스페이스 만들기\n\n안녕하세요! 이번 글은 시리즈 중 세 번째로, Golang을 사용하여 마운트 네임스페이스를 만드는 방법을 보여드리겠습니다. 마운트 네임스페이스에서 사용되는 명령어와 기본 구성 요소에 대해 알아보고, 이것들이 컨테이너와 어떻게 연관되는지 살펴보겠습니다. 이 시리즈는 컨테이너에 중점을 두지만, 실제로는 프로세스를 실험함으로써 간단하게 설명하고 있습니다. 컨테이너는 본질적으로 프로세스 + 어떤 기본적인 요소로 구성되기 때문입니다. 그럼에도 불구하고, 이곳에서 논의하는 원칙들은 동일하게 적용됩니다.\n\n많은 경우에 리눅스 네임스페이스의 이론은 간단할 수 있지만, 실제로는 처음 보는 것보다 다소 복잡할 수 있습니다. 마운트 네임스페이스에 대한 일반적인 개념을 제공하는 많은 자료가 있으므로, 우리는 핵심적인 부분에 초점을 맞출 것입니다. 우리가 살펴볼 중요한 두 가지 요소는 `mount`와 `pivot_root` 명령어입니다. 이를 통해 우리는 모든 것이 어떻게 컨테이너와 마운트 네임스페이스의 개념에 잘 들어맞는지 이해할 수 있을 것입니다.\n\n\n\n# mount()\n\n리눅스 문서에 따르면:\n\n내 설명을 조금 더 자세히 하자면:\n\nmount 명령은 시스템에 있는 장치나 가상 파일 시스템의 파일 시스템을 연결할 수 있는 도구입니다. 이를 통해 해당 파일 시스템을 탐색할 수 있습니다. 어떤 일이 벌어지는지 예를 들어 설명하자면, 컴퓨터에 USB를 연결하면 USB에 있는 이미지와 같은 파일을 검색하고 스크롤할 수 있습니다. 하지만 사용자가 직접 작업하지 않았다면, mount 명령이 백그라운드에서 발생하고 있음을 알 수 없습니다. 그렇지 않다면 이미지를 검색할 수 없습니다. USB를 분리하고자 할 때 컴퓨터가 손상을 방지하기 위해 제대로 분리하라는 메시지를 표시하는 경우도 있을텐데, 이는 umount (즉, \"unmount\"라고도 함) 명령을 사용하여 이루어집니다.\n\n\n\n당신이 놀라실지 모르겠지만, 컴퓨터에 꽂는 USB 드라이브뿐만 아니라 프로시 파일 시스템이나 tmpfs와 같은 가상 파일 시스템에도 해당됩니다. Linux에서 부팅 시 자동으로 마운트되는 모든 가상 파일 시스템 및 장치를 확인할 수 있습니다:\n\n```shell\ncat /etc/fstab\n```\n\n또는 현재 마운트된 장치를 확인하려면:\n\n```shell\ncat /etc/mtab\n```\n\n\n\n부팅 시 마운트된 루트 폴더도 동일하게 적용됩니다. 몇 가지 콘텍스트를 제공하겠습니다 — 컨테이너 관점에서, 컨테이너 이미지에는 파일 시스템이 포함되어 있고 이를 동일한 컨테이너 프로세스가 루트 파일 시스템으로 보기를 원합니다. 내부적으로는 pivot_root를 사용하여 이를 달성합니다. 일반적인 관점에서 이를 살펴보겠습니다.\n\n\n\n현재 프로세스의 마운트 포인트를 확인하려면 다음을 사용하세요:\n\n```js\ngrep -iP '/ /\\s' /proc/$$/mountinfo\n```\n\n현재 루트가 /dev/sda*와 같은 디스크를 통해 또는 네트워크를 통해 마운트된 것을 볼 수 있을 겁니다. pivot_root 명령어를 사용하면 현재 루트를 예를 들어 하위 디렉토리로 변경할 수 있습니다. 그러나 이를 수행하기 위한 몇 가지 요구 사항이 있습니다:\n\n- new_root와 put_old는 디렉토리여야 합니다.\n- new_root와 put_old는 현재 루트와 동일한 마운트 지점에 있어서는 안 됩니다.\n- put_old는 new_root의 하위에 있거나 동일해야 합니다; 다시 말해, put_old가 가리키는 경로에 ../접미사의 양의 정수를 추가하면 new_root와 동일한 디렉토리가 나와야 합니다.\n- new_root는 마운트 지점의 경로여야 하지만 /일 수 없습니다. 마운트 지점이 아닌 경로는 스스로에 바인드 마운트하여 마운트 지점으로 변환할 수 있습니다.\n- new_root의 상위 마운트의 전파 유형과 현재 루트 디렉토리의 상위 마운트의 전파 유형이 MS_SHARED여서는 안 되며, 비슷하게, put_old가 기존의 마운트 지점인 경우 해당 전파 유형도 MS_SHARED일 수 없습니다. 이러한 제한 사항은 pivot_root()가 다른 마운트 네임스페이스로 변경 사항을 전파하지 않도록 합니다.\n- 현재 루트 디렉토리는 마운트 지점이어야 합니다.\n\n\n\n저희 코드는 이러한 요구 사항을 충족할 것이지만, 저희가 논의한 두 명령어로부터 중요한 점은 마운트 네임스페이스가 필요하다는 것입니다. 이는 pivot_root가 호스트의 루트 마운트가 아닌 \"자식/컨테이너\" 네임스페이스 내의 루트 마운트에 영향을 미치도록 해야 한다는 것입니다. 이것이 바로 VM과 컨테이너와 같은 단위가 우리가 정의한 경계를 벗어나 호스트에 영향을 미치지 못하도록 하는 격리의 목표입니다.\n\n# 코드 예시\n\n지난 글에서처럼, 코드 코멘트를 사용하여 기술적인 세부 사항을 안내해 드리겠습니다. 이 방법이 저희가 사용하는 기능을 이해하는 데 훨씬 더 간단하게 만들어준다고 믿습니다.\n\n이 코드는 다음을 수행합니다:\n\n\n\n- 새로운 루트를 마운트 포인트로 만들기 위해 mount bind를 생성합니다\n- 새로운 마운트 네임스페이스를 생성합니다\n- 새로운 마운트 네임스페이스 내에서 Pivot Root를 수행합니다\n- 증명 목적으로 /proc 및 /dev를 마운트합니다\n- 이전 루트를 언마운트합니다\n- 새로운 루트 내에서 /bin/sh를 엽니다\n\n```js\npackage main\n\nimport (\n \"os\"\n \"os/exec\"\n \"log\"\n \"syscall\"\n)\n\nfunc setupNewMountNamespace(newRoot string, putOld string) {\n // 새로운 루트를 자신에 묶음 - 약간의 해킹\n // PIVOT_ROOT 요구 사항 - \"new_root는 마운트 포인트의 경로여야 합니다\"\n // MS_BIND - 바인드 마운트 생성\n // MS_REC - 소스의 모든 하위 마운트에 재귀적으로 마운트 (동작) 적용\n if err := syscall.Mount(newRoot, newRoot, \"\", syscall.MS_BIND|syscall.MS_REC, \"\"); err != nil {\n  log.Fatalln(\"새 루트 파일 시스템을 마운트하지 못했습니다: \", err)\n }\n\n // 이전 루트를위한 디렉토리 생성\n // PIVOT_ROOT 요구 사항 - put_old는 new_root의 하위 위치에 있어야 함\n if err := syscall.Mkdir(newRoot+putOld, 0700); err != nil {\n  log.Fatalln(\"mkdir를 실패했습니다: \", err)\n }\n\n // 현재 프로세스를 소속되어 있는 마운트 네임스페이스와 분리하며, 새로운 마운트 네임스페이스를 생성합니다\n  if err := syscall.Unshare(syscall.CLONE_NEWNS); err != nil {\n    log.Fatalf(\"Unshare 시스템 호출에 실패했습니다: %v\\n\", err)\n  }\n\n // 새로운 루트 파일 시스템으로 pivot_root\n // 참고: 작동하지 않으면 위에 나열된 요구 사항을 다시 확인하세요\n if err := syscall.PivotRoot(newRoot, newRoot+putOld); err != nil {\n  log.Fatalln(\"pivot root를 실패했습니다: \", err)\n }\n\n // 현재 작업 디렉토리를 새 마운트 네임스페이스에서 \"/\"\"로 변경합니다\n if err := syscall.Chdir(\"/\"); err != nil {\n  log.Fatalln(\"/로 chdir를 변경하지 못했습니다: \", err)\n }\n\n // /proc를 마운트합니다\n if err := syscall.Mount(\"/proc\", \"/proc\", \"proc\", 0, \"\"); err != nil {\n  log.Fatalln(\"/proc를 마운트하지 못했습니다: \", err)\n }\n\n // 아래와 같이 'mount' 및 'readlink'와 같은 명령을 호출할 수 있어야 합니다\n if err := syscall.Mount(\"/dev\", \"/dev\", \"tmpfs\", 0, \"\"); err != nil {\n  log.Fatalln(\"/dev를 마운트하지 못했습니다: \", err)\n }\n file, err := os.Create(\"/dev/null\"); if err != nil {\n   log.Fatal(err)\n }\n defer file.Close()\n\n // 이전 루트 파일 시스템을 언마운트합니다\n if err := syscall.Unmount(putOld, syscall.MNT_DETACH); err != nil {\n  log.Fatalln(\"이전 루트 파일 시스템을 언마운트하지 못했습니다: \", err)\n }\n}\n\nfunc main() {\n processID := os.Getpid()\n log.Printf(\"프로세스 ID: %d\\n\", processID)\n\n // 현재 마운트 네임스페이스를 확인합니다\n out, err := exec.Command(\"readlink\", \"/proc/self/ns/mnt\").Output(); if err != nil {\n  log.Fatalf(\"네임스페이스 파일을 읽는 중 오류 발생: %v\\n\", err)\n }\n log.Printf(\"프로세스는 현재 이전 마운트 네임스페이스에 있습니다: %s\", string(out))\n\n newRoot := \"new_root\"\n putOld := \"/old_root\"\n setupNewMountNamespace(newRoot, putOld)\n\n // 현재 마운트 네임스페이스를 확인합니다\n out1, err := exec.Command(\"readlink\", \"/proc/self/ns/mnt\").Output(); if err != nil {\n  log.Fatalf(\"네임스페이스 파일을 읽는 중 오류 발생: %v\\n\", err)\n }\n log.Printf(\"프로세스는 이제 새 마운트 네임스페이스에 있습니다: %s\", string(out1))\n\n log.Println(\"새 마운트 네임스페이스에서 셸 (bin/sh)을 열고 'mount', 'lsns' 등 명령을 실행합니다.\")\n cmd := exec.Command(\"/bin/sh\")\n cmd.Stdin = os.Stdin\n cmd.Stdout = os.Stdout\n cmd.Stderr = os.Stderr\n if err := cmd.Run(); err != nil {\n  log.Println(\"명령 실행에 실패했습니다: \", err)\n  os.Exit(1)\n }\n}\n```\n\n# 결론\n\n요약하자면, 이 기사에서는 Golang을 사용하여 마운트 네임스페이스를 생성하고, mount 및 pivot_root와 같은 주요 명령을 강조했습니다. 코드 예제를 통해 컨테이너 격리에서 마운트 네임스페이스의 역할을 명료하게 했기를 바랍니다.","ogImage":{"url":"/assets/img/2024-05-15-ContainerInternalsSeriesPart3MountNamespace_0.png"},"coverImage":"/assets/img/2024-05-15-ContainerInternalsSeriesPart3MountNamespace_0.png","tag":["Tech"],"readingTime":6},{"title":"타입스크립트에서 레이블 문의 마법을 공개합니다","description":"","date":"2024-05-15 11:10","slug":"2024-05-15-UnveilingtheMagicofLabelledStatementsinSwift","content":"\n\n라벨 지정문은 다른 Swift 기능들만큼 화려하지는 않지만, 코드 가독성과 흐름 제어를 크게 향상시킬 수 있는 독특한 유연성을 지니고 있어요.\n\n라벨 지정문을 사용하면 if, switch 또는 do 문과 같이 코드의 특정 부분에 이름을 지정할 수 있어요. 이는 중첩된 루프를 벗어나는 데 도움을 줄 수 있어요.\n\n아래에는 라벨이 지정된 루프의 기본 예제가 있어요.\n\n아래 코드에서는 제곱했을 때 4가 되는 첫 번째 숫자를 찾으려고 해요.\n\n\n\n```js\nlet numbers = 1...50\n\nfor number1 in numbers {\n    for number2 in numbers {\n        if number1 == number2 && number1 * number2 == 4  {\n            print(number1)\n            break // 외부 루프를 종료시키지 않습니다\n        }\n    }\n}\n```\n\n라벨을 사용하면 많은 도움을 받을 수 있습니다.\n\n```js\nlet numbers = 1...50\n\nouterLoop: for number1 in numbers {\n    for number2 in numbers {\n        if number1 == number2 && number1 * number2 == 4  {\n            print(number1)\n            break outerLoop // 외부 루프를 종료시킵니다\n        }\n    }\n}\n```","ogImage":{"url":"/assets/img/2024-05-15-UnveilingtheMagicofLabelledStatementsinSwift_0.png"},"coverImage":"/assets/img/2024-05-15-UnveilingtheMagicofLabelledStatementsinSwift_0.png","tag":["Tech"],"readingTime":1},{"title":"AWS에서 이력서를 Terraform으로 만들어보세요 I","description":"","date":"2024-05-15 11:08","slug":"2024-05-15-GetyourResumeTerraformedinAWSI","content":"\n\n안녕하세요! 👋 여러분! 오랜만이죠. 여기에 유용한(아니면 흥미로운?) 기사 몇 개를 올리고 싶다고 생각한 지 오래되었습니다. 그런데 좋거나 유용한 아이디어가 생각나지 않았어요. 몇 주 전 나를 위해 한 작업을 문서화하는 아이디어를 만났는데요: 이력서의 HTML 버전을 AWS에 Terraform과 GitHub Actions을 통해 배포(자동화)하는 것입니다. 요즘에는 이런 기술을 이력서에 넣는 것이 흥미로울 것 같아요. 근데 이력서 안에 그런 기술을 보여주면 어때요? 😜\n\n이런 작업을 어떻게 하는지 보여주는 많은 비디오/튜토리얼은 AWS 콘솔에서 \"클릭 단계별\"로 진행하는 것을 보여줍니다. 그러나 저는 Terraform + GithubActions 방법을 소개할 거에요, 더 흥미로울 것 같다고 봅니다.\n\n이 글은 두 편 중 첫 번째 입니다. 여러분이 지역 (HTML 형식)으로 배포된 이력서를 AWS(S3)에 보관하고 https://antonirs.com 같은 URL을 통해 접근 가능하게 하는 방법을 단계별로 안내할 거에요. 그리고 또한 매 푸시마다 새 버전을 자동으로 배포하는 ⚙️GitHub Actions 파이프라인⚙️ 도 설정할 거에요. 이 자동화 부분은 이 첫 번째 글에서 다루지 않고 두 번째 글에서 다뤄요.\n\n이 글을 따라가는 동안 제 개인 이력서 저장소에서 모든 소스 코드를 확인할 수 있어요. 즐겨보세요!\n\n\n\n# 인프라 구조 이해하기\n\n![이미지](/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png)\n\n우리가 구축할 내용을 크게 보여드립니다. 첫 번째 기사에서 Terraform을 사용하여 컴포넌트를 구축하고 연결하며 함께 작동시키는 방법을 안내해 드리겠습니다. 아키텍처는 전혀 복잡하지 않으므로, 모두 구축하기 위해 AWS의 \"단지\" 4가지 서비스를 사용할 예정입니다.\n\n# 이전 요구 사항\n\n\n\n일할 때 필요한 몇 가지가 있습니다:\n1. AWS 계정. 꽤 명백한 🤷🏼‍♂️ 당연하지만 필수입니다. AWS는 이 문서에서 한 단계씩 안내하여 계정을 설정하는 방법을 제공합니다.\n2. Terraform CLI 설치. 터미널에 terraform CLI가 설치되어 있어야 합니다. Hashicorp에서 설치 방법을 안내합니다.\n3. 등록된 도메인. 이 문서에서는 구매 및 AWS에서 처리된 도메인을 가지고 있다고 가정하지만, 반드시 그렇게 할 필요는 없습니다.\n4. 이력서의 HTML 버전. S3 버킷에 저장되고 CloudFront를 통해 제공될 것입니다.\n\n# 일하러 가볼까요 💪🏻\n\n저의 저장소에서 완전한 작동 솔루션을 제공받을 수 있기 때문에 👀, 단계별로 자세히 설명하지는 않겠지만 각 부분의 가장 중요한 요소에 대해 주석을 달겠습니다.\n\n## 단계 0: 도메인 구매 및 호스팅 존 생성\n\n\n\n도메인 (나의 경우에는 antonirs.com)의 구매와 호스팅 영역 생성은 Terraform으로 만들지 못하는 유일한 부분이며, 대신 AWS 콘솔에서 수동으로 처리해야 합니다.\n\n다른 제공업체에 도메인을 호스팅할 수도 있습니다. 이 경우 추가 구성이 필요할 수 있지만 (그 외에는 문제가 없습니다), 이 경우에는 AWS에서 호스팅되는 경우를 다루겠습니다.\n\n## 단계 1: Terraform으로 시작하기. AWS 제공자 설정\n\nTerraform 프로젝트의 시작점은 일반적으로 AWS 제공자 및 사용할 백엔드 구성을 설정하는 것입니다. 이를 통해 Terraform에게 AWS와의 인증 방법, 리소스를 배포할 지역 및 인프라의 tfstate를 저장할 위치를 알려줍니다. 이 구성을 provider.tf 파일에 넣어주세요.\n\n\n\n```js\nprovider \"aws\" {\n  region = \"us-east-1\"\n  access_key = \"내 액세스 키\"\n  secret_key = \"내 시크릿 액세스 키\"\n}\n```\n\n액세스 키와 시크릿 키는 절대로 리포지토리에 푸시해서는 안 되는 것을 염두에 두세요. 여기서 보여주고 있지만, 다음 글에서 깃허브 리포지토리의 시크릿 구성으로 이동하는 방법을 보여줄 것입니다.\n\n백엔드.tf에 대해 다음과 같이 보이도록 해야 합니다. 우리는 인프라의 상태를 저장하기 위해 S3를 사용할 것입니다:\n\n```js\nterraform {\n  backend \"s3\" {\n    bucket         = \"antoni-tf-state\"\n    key            = \"personal-portfolio/terraform.tfstate\"\n    region         = \"us-east-1\"\n    encrypt        = true\n  }\n}\n```\n\n\n\n## Step 2: S3 및 액세스 정책 생성\n\n여기서는 antoni-html-cv라는 S3 버킷을 생성하고, 여기서 중요한 부분은 우리가 정의하는 정책인 s3_policy입니다. Cloudfront에서 오는 요청을 제외하고 모든 수신 트래픽을 차단할 것입니다 ⛔.\n\n```js\nresource \"aws_s3_bucket\" \"personal_portfolio_bucket\" {\n  bucket = \"antoni-html-cv\"\n}\n\ndata \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_iam_policy_document\" \"s3_policy\" {\n  statement {\n    sid       = \"AllowCloudFrontServicePrincipal\"\n    effect    = \"Allow\"\n    principals {\n      type        = \"Service\"\n      identifiers = [\"cloudfront.amazonaws.com\"]\n    }\n    actions   = [\"s3:GetObject\"]\n    resources = [\"${aws_s3_bucket.personal_portfolio_bucket.arn}/*\"]\n    condition {\n      test     = \"StringEquals\"\n      variable = \"AWS:SourceArn\"\n      values   = [\"arn:aws:cloudfront::${data.aws_caller_identity.current.account_id}:distribution/${aws_cloudfront_distribution.portfolio_distribution.id}\"]\n    }\n  }\n}\n\nresource \"aws_s3_bucket_policy\" \"s3_policy\" {\n  bucket = aws_s3_bucket.personal_portfolio_bucket.id\n  policy = data.aws_iam_policy_document.s3_policy.json\n}\n```\n\n여기서 중요한 점은 정책을 통해 S3에 직접 액세스하는 것을 방지하고 Cloudfront가 내용을 가져오는 것을 허용한다는 것입니다 (고객에게 서비스하기 위해). 이를 수행하는 다른 방법도 있지만, 저는 현재 AWS가 가장 권장하는 Origin Access Control 접근 방식을 사용하기로 결정했습니다. OAC에 대한 자세한 정보는 [여기](링크)에서 확인할 수 있습니다.\n\n\n\n## 단계 3: SSL 인증서로 CloudFront 배포 설정하기\n\nCloudFront는 S3에서 정적 콘텐츠를 제공하는 데 사용할 AWS 서비스입니다. CloudFront는 CDN으로 작동하여 전 세계의 여러 위치(엣지 위치)에 콘텐츠를 캐시하여 더 빠르게 액세스할 수 있게 합니다. 또한, CloudFront를 사용하면 배포에 SSL/TLS 인증서를 첨부하여 웹 사이트 연결을 HTTPS로 강제할 수 있습니다.\n\n```js\nresource \"aws_cloudfront_origin_access_control\" \"portfolio_oac\" {\n  name        = \"OAC for Portfolio Website\"\n  description = \"OAC for antonirs portfolio website\"\n  origin_access_control_origin_type = \"s3\"\n\n  signing_behavior = \"always\"\n  signing_protocol = \"sigv4\"\n}\n\nresource \"aws_cloudfront_distribution\" \"portfolio_distribution\" {\n  origin {\n    domain_name = aws_s3_bucket.personal_portfolio_bucket.bucket_regional_domain_name\n    origin_id   = \"S3-antonirs-portfolio\"\n    origin_access_control_id = aws_cloudfront_origin_access_control.portfolio_oac.id\n  }\n\n  enabled = true\n  comment = \"Distribution for the antonirs.com static website\"\n  aliases = [\"antonirs.com\"]\n  default_root_object = \"index.html\"\n\n  default_cache_behavior {\n    allowed_methods  = [\"GET\", \"HEAD\", \"OPTIONS\"]\n    cached_methods   = [\"GET\", \"HEAD\"]\n\n    target_origin_id = \"S3-antonirs-portfolio\"\n\n    forwarded_values {\n      query_string = false\n      cookies {\n        forward = \"none\"\n      }\n    }\n\n    viewer_protocol_policy = \"redirect-to-https\"\n    min_ttl                = 0\n    default_ttl            = 86400\n    max_ttl                = 31536000\n  }\n\n  viewer_certificate {\n    acm_certificate_arn = aws_acm_certificate.personal_web_portfolio_cert.arn\n    ssl_support_method  = \"sni-only\"\n    minimum_protocol_version = \"TLSv1.2_2021\"\n  }\n\n  restrictions {\n    geo_restriction {\n      restriction_type = \"none\"\n    }\n  }\n\n  tags = {\n    Environment = \"production\"\n  }\n}\n```\n\n여기에는 많은 구성이 포함되어 있지만 주요 부분은 다음과 같습니다:\n-` 우리는 origin을 정의하여 CloudFront에게 데이터를 어디서 가져와야 하는지 알려줍니다(S3에서 가져옵니다).\n-` viewer_certificate 섹션을 사용하여 사용자 브라우저와 CloudFront 간의 안전한 연결(HTTPS)을 설정하는 SSL 인증서를 설정합니다.\n인증서를 생성하는 관련 명령에 대한 자세한 내용은 acm.tf에서 구성을 확인할 수 있습니다.\n\n\n\n```js\nresource \"aws_acm_certificate\" \"personal_web_portfolio_cert\" {\n  domain_name       = \"antonirs.com\"\n  validation_method = \"DNS\"\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_route53_record\" \"cert_validation\" {\n  zone_id = data.aws_route53_zone.my_personal_zone.zone_id\n  name    = tolist(aws_acm_certificate.personal_web_portfolio_cert.domain_validation_options)[0].resource_record_name\n  type    = tolist(aws_acm_certificate.personal_web_portfolio_cert.domain_validation_options)[0].resource_record_type\n  records = [tolist(aws_acm_certificate.personal_web_portfolio_cert.domain_validation_options)[0].resource_record_value]\n  ttl     = 60\n}\n\nresource \"aws_acm_certificate_validation\" \"cert_validation\" {\n  certificate_arn         = aws_acm_certificate.personal_web_portfolio_cert.arn\n  validation_record_fqdns = [aws_route53_record.cert_validation.fqdn]\n}\n```\n\n인증서 구성 중 중요한 부분은 aws_acm_certificate_validation 섹션입니다. 이 인증서를 antonirs.com에 접속할 수 있게 하기 위해 Route53에 대해 이 인증서를 검증해야 합니다.\n\n## 단계 4: Route 53 설정\n\n인프라스트럭처에서말했던 것처럼 DNS 관리를 위해 Route 53을 사용할 것입니다. 글의 시작에서 말했듯이 이미 도메인(나의 경우엔 antonirs.com)과 AWS에 생성된 호스팅존이 있습니다. 다음 구성(route53.tf)을 따라 호스팅존 내에 A 레코드를 작성하고, CloudFront 배포로 가리키는 별칭으로 설정합니다.\n \n\n\n\n```js\ndata \"aws_route53_zone\" \"my_personal_zone\" {\n  name = \"antonirs.com.\"\n}\n\nresource \"aws_route53_record\" \"www\" {\n  zone_id = data.aws_route53_zone.my_personal_zone.id\n  name    = \"antonirs.com\"\n  type    = \"A\"\n\n  alias {\n    name                   = aws_cloudfront_distribution.portfolio_distribution.domain_name\n    zone_id                = aws_cloudfront_distribution.portfolio_distribution.hosted_zone_id\n    evaluate_target_health = false\n  }\n}\n```\n\n## 단계 5: 모든 것이 작동하는 것을 확인\n\n지금까지 본 것으로 충분히 준비되었습니다. 이제 \"한 번의 클릭\"으로 모든 인프라를 구축하여 https://antonirs.com (제 경우)을 방문하여 이력서를 확인할 수 있습니다.\n\n좋아요, 이중 따옴표를 조금 풀어볼게요. 모든 테라폼 파일이 준비된 상태에서 이제 해야 할 일은 터미널을 열고 다음을 실행하는 것입니다:\n1. terraform init 이 명령어를 실행하면 의존성을 다운로드하고 간단히 말해서 AWS와 상호 작용할 수 있는 디렉토리를 초기화합니다.\n2. terraform plan 이 명령어를 실행하면 실제 인프라에 반영되지 않은 tf 파일에 있는 모든 변경 사항을 출력합니다.\n3. terraform apply 이 명령어를 실행하면 인프라에서 실제 변경 사항을 만듭니다. Terraform 파일에 구성된 모든 리소스를 생성합니다.\n4. 이력서의 HTML 버전을 생성한 버킷에 업로드합니다.\n5. 방문(제 경우) https://antonirs.com 그리고... 즐기세요 😜 🚀\n\n\n\n\n<img src=\"/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_1.png\" />\n\n# 마무리 및 다음 단계\n\n와우! 여기까지 모두 읽은 것을 보니 매우 기뻐요🎊! 하하. 하지만 기쁨은 여기까지가 아닙니다. 다음 기사에서 더 흥미로워집니다. 조금 스포하겠습니다:\n\n이전의 \"단계 5\"를 보면 인프라를 배포하기 위해 \"상당히 많은\" 명령을 실행해야 한다는 것 같죠? 그런데 만약 웹사이트에 이력서의 새 버전을 업로드하려면 어떨까요? 새 버전을 업로드하려면 AWS 콘솔에 로그인해야 합니다 (또는 aws-cli를 사용해야 합니다)... 어찌 보면 그렇게 편리하지 않을 거예요.\n\n\n\n다음 기사에서는 GitHub Actions에서 모든 이러한 단계를 자동화하는 방법을 보여 드릴 것이기 때문에 기대해 주세요. 다음 기사에서는 또한 파이프라인에 우리의 비용을 제어하기 위한 💰infracost💰 통합에 관한 '보너스' 섹션을 공유할 예정이에요. 자세한 내용을 더 다루겠지만, 이는 우리 인프라 비용을 관리하는 데 매우 유용한 도구입니다. 계속 지켜보세요! 😉","ogImage":{"url":"/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png"},"coverImage":"/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png","tag":["Tech"],"readingTime":9},{"title":"Harbor 시작하기 단계별 안내","description":"","date":"2024-05-15 11:06","slug":"2024-05-15-GettingStartedwithHarborAStep-by-StepGuide","content":"\n\nHarbor는 DockerHub, ECR 또는 ACR에 의존하지 않고 컨테이너 이미지를 안전하게 저장하고 관리하는 데 도움이 되는 오픈 소스 레지스트리입니다. Docker의 오픈 소스 레지스트리 위에 보안, 식별 및 관리 기능을 추가합니다. Harbor를 사용하면 이미지에 대한 정책을 설정하고 취약점을 검사하여 역할 기반 제어를 통해 액세스를 관리할 수 있습니다. 이는 컨테이너 이미지를 안전하고 잘 관리된 상태로 유지하려는 개발자들에게 필수적인 도구입니다.\n\n![Harbor 시작하기: 진행하기 전에](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png)\n\n## 전제 조건\n\n- Chocolatey 설치하기:\n\n\n\n- 관리자 권한으로 PowerShell 터미널을 열고 다음을 실행해주세요:\n\n```js\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n2. Chocolatey를 통해 Rancher Desktop을 설치하려면 다음 명령을 실행하세요:\n\n\n\n```js\nchoco install rancher-desktop\n```\n\n# 설정\n\n- 프로젝트 디렉토리를 생성하고 이동하세요:\n\n```js\nmkdir LearningHarbor cd LearningHarbor\n```\n\n\n\n2. Harbor Helm 저장소를 추가하고 Harbor 차트를 가져옵니다:\n\n```js\nhelm repo add harbor https://helm.goharbor.io\nhelm fetch harbor/harbor --untar cd harbor\n```\n\n3. values.yaml 파일을 편집합니다:\n\n- externalUrl 설정\n\n\n\n```js\nexternalURL: https://core.harbor.localhost\n```\n\n![Getting Started with Harbor: A Step-by-Step Guide](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_1.png)\n\n3. 윈도우 호스트 파일 수정:\n\n- 관리자 권한으로 텍스트 편집기에서 c:\\Windows\\System32\\Drivers\\etc\\hosts 파일을 엽니다.\n- 다음 줄을 추가하세요:\n\n\n\n```js\n127.0.0.1 core.harbor.localhost\n```\n\n![Harbor](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_2.png)\n\n# Harbor 배포\n\n- Harbor Helm 차트 설치:\n\n\n\n```js\nhelm upgrade harbor-release . --namespace harbor-helm --create-namespace --wait --install\n```\n\n2. 배포가 완료될 때까지 기다린 후 다음으로 이동하세요:\n\n- https://core.harbor.localhost\n\n![Getting Started with Harbor](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_3.png)\n\n\n\n3. 기본 자격 증명을 사용하여 로그인하세요:\n\n- 사용자명: admin\n- 비밀번호: Harbor12345\n\n![이미지](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_4.png)\n\n# 추가 구성\n\n\n\n- Docker를 사용하여 Harbor 레지스트리에 로그인하세요:\n\n```js\ndocker login https://core.harbor.localhost\n```\n\n동일한 자격 증명을 사용하세요:\n\n- 사용자 이름: admin\n- 비밀번호: Harbor12345\n\n\n\n# Harbor로 이미지 푸시하기\n\n참고: 사용할 로케이션 이미지인 aspiresample/api 및 aspiresample/web이 있습니다. 제 이미지 이름을 교체해도 괜찮습니다.\n\n- 이미지에 태그 붙이기\n\n```js\ndocker tag aspiresample/apiservice core.harbor.localhost/library/apiservice:latest\n```\n\n\n\n2. 이미지를 푸시하세요\n\n```js\ndocker push core.harbor.localhost/library/apiservice:latest\n```\n\n이제 Harbor UI에서 다음을 볼 수 있습니다\n\n![이미지](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_5.png)\n\n\n\n\n![이미지](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_6.png)\n\n# 고급 기능\n\nHarbor에는 기능을 향상시키는 몇 가지 고급 기능이 있습니다. 저는 이에 대해 자세히 다루지 않을 것입니다:\n\n- 외부 저장소 연결:\n\n\n\n\n- Harbor에 외부 저장소를 링크하고 정기적으로 해당 저장소에서 이미지를 복제하여 Harbor 레지스트리를 항상 최신 상태로 유지할 수 있습니다.\n\n![Step 7](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_7.png)\n\n![Step 8](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_8.png)\n\n2. 외부 인증:\n\n\n\n- Harbor은 Keycloak와 같은 외부 OIDC 서버와의 통합을 지원하여 사용자 관리와 싱글 사인온 기능을 제공합니다.\n\n![사진](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_9.png)\n\n3. 할당량 설정:\n\n- 관리자는 프로젝트 및 저장소에 할당량을 설정하여 저장 공간 소비를 관리하고 조직 전체에서 적절하게 자원을 할당할 수 있습니다.\n\n\n\n# 마무리\n\n해법은 컨테이너 이미지를 관리하고 보호하는 강력한 솔루션을 제공합니다. 본 안내서에 나와 있는 단계에 따라 진행하면 신속하게 Harbor를 배포하여 이미지를 안전한 관리 환경에 저장할 수 있습니다. Harbor의 고급 기능인 외부 저장소 연결, 인증을 위해 Keycloak과 같은 OIDC 서버와 통합, 스토리지 할당량 설정 등은 그 유틸리티를 더욱 향상시킵니다. 이러한 기능들은 Harbor를 보안이며 효율적인 컨테이너 이미지 레지스트리를 유지하려는 개발자와 조직에 꼭 필요한 도구로 만듭니다.","ogImage":{"url":"/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4}],"page":"97","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}