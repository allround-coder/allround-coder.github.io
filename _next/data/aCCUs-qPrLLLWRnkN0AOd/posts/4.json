{"pageProps":{"posts":[{"title":"Android Jetpack Compose로 Custom TopAppBar 만드는 방법","description":"","date":"2024-06-30 22:49","slug":"2024-06-30-CustomTopAppBarusingAndroidJetpackCompose","content":"\n\n현대적인 안드로이드 앱을 개발할 때 TopAppBar composable을 사용하면 디자인이나 사용자 경험을 보완하는 데 문제가 발생할 수 있다는 것을 확신합니다.\n\n문제점 몇 가지 예시:\n\n- TopAppBar에서 SearchBar를 사용할 수 없습니다(호환이 되지 않습니다).\n- TopAppBar의 높이를 사용자 정의할 수 없습니다.\n- 기본 높이를 초과하는 다른 composable를 정의할 수 없습니다. 즉, Text composable만 사용해야 합니다(물론 \"title\"이라는 매개변수 때문에 Text composable만 사용하는 것이 권장됩니다).\n\n여기 참고할 만한 \"title\" 매개변수에 대한 내용이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Composable\nfun TopAppBar(\n    title: @Composable () -> Unit,\n    modifier: Modifier = Modifier,\n    navigationIcon: @Composable () -> Unit = {},\n    actions: @Composable RowScope.() -> Unit = {},\n    windowInsets: WindowInsets = TopAppBarDefaults.windowInsets,\n    colors: TopAppBarColors = TopAppBarDefaults.topAppBarColors(),\n    scrollBehavior: TopAppBarScrollBehavior? = null\n) { ... }\n```\n\n왜 정확히 TopAppBar를 사용자 정의해야 하나요? 그게 꼭 필요한 건가요? 그냥 Scaffold 내부의 composable을 사용자 정의하고 TopAppBar(topBar)를 사용하지 않으면 안 되나요?\n\n모든 것을 맥락을 가지고 대답하겠습니다. 여기서 시작해봅시다.\n\n아래 gif를 보세요. 거기서 무엇을 보셨나요? 경험을 개선할 방법은 없을까요?\nGoogle이라는 걸 알고 있고, 개발자들의 작업을 칭찬합니다. 그래도 여전히 TopAppBar의 추가 색상 패딩 대신 투명 컨테이너 색상이면 좋겠다고 생각합니다. (여기서 statusBar 색상과 패딩을 무시합시다)\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1172/1*AxYM9552OKFCjkjQIh4Y_A.gif\" />\n\n이 것이 간단한 수정이겠지 생각하고 있을 것입니다. 하지만 문제는 그렇게 쉽게 해결되지 않는다는 것입니다. TopAppBar가 SearchBar가 확장될 때의 높이 제한에 갇히고 예기치 않은 동작을 볼 것입니다.\n\n```js\n  // TopAppBar에 대한 매개변수\ncolors = TopAppBarDefaults.topAppBarColors().copy(\n      containerColor = Color.Transparent,\n      scrolledContainerColor = Color.Transparent,\n  )\n```\n\n기대했던 것 vs 실제 결과, (또한 아래의 SearchBar 뒤의 리스트와 Gmail을 비교해봅시다)\n\n<div class=\"content-ad\"></div>\n\n'TopAppBar'의 \"content\" 안에 있는 SearchBar를 사용하는 것이 좋은 방법으로 보일 수 있습니다. 그러나 scrollState를 관리하고 scrollBehavior를 제어하는 것은 더 어려운 작업일 수 있고 머리 아플 수도 있습니다. Scaffold는 이미 우리에게 topBar를 제공하므로 동일한 목적으로 body content를 사용하는 까닭이 무엇인가요?\n\n그것은 SearchBar에만 해당되는 경우일 뿐입니다. 사용하고 싶은 사용자 정의 컴포넌트는 어떻게 해야 할까요? 배너나 브랜드 이름 하이라이트와 같은 Composables와 같은 것입니다.\n\nTopAppBar의 가장 좋은 점은 scrollBehavior를 관리하고 적응할 수 있는 여러 동작을 갖고 있다는 것입니다. 예를 들면,\n\n- enterAlwaysScrollBehavior\n- pinnedScrollBehavior\n- exitUntilCollapsedScrollBehavior 등이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 이유로 TopAppBar의 nestedScroll을 사용하여 topBar 동작을 제어하는 것이 더 쉽습니다. 이 모든 것은 이를 만들어낸 개발자들 덕분입니다!\n\n이제, 해결책은,\n\n다양한 기술을 시도해 보고 원하는 결과를 얻기 위해 매우 오랜 시간을 검색했지만 예상했던 동작을 얻지 못했습니다. 마침내, 긴 시간 뒤에 디폴트 TopAppBar로 발생한 문제와 이를 수정하여 원하는 동작을 얻는 방법을 기술한 Oya Canlı의 기사를 발견했습니다. 그녀는 TopAppBar의 내장된 scrollBehaviors의 장점을 살리면서 원하는 동작을 얻기 위해 코드를 수정하는 방법을 설명했습니다.\n\n요약하면, Oya Canlı 씨는 더 많은 사용자 정의를 허용하면서 다양한 scrollBehaviors를 지원하는 사용자 정의 FlexibleTopBar를 만들었습니다.\n\n<div class=\"content-ad\"></div>\n\n이 솔루션은 topBar의 무한한 사용 사례를 열어줬어요. 여기서는 사용자 정의 composables를 사용할 수 있으면서도 topBar scrollBehavior를 활용할 수 있는 곳이 많아요.\n\nTopAppBar composable에 익숙하다면 사용자 정의 TopAppBar(i.e. Oya Canlı의 FlexibleTopBar)에서는 거의 차이를 찾아보기 어려울 거에요. 제목, navigationIcon, actions가 지금은 composables를 취하는 content로 대체되었고 더 유연성을 제공합니다.\n다음은 코드 조각이에요,\n\n```js\n@Composable\nfun CustomFlexibleTopAppBar(\n    modifier: Modifier = Modifier,\n    colors: FlexibleTopBarColors = FlexibleTopBarDefaults.topAppBarColors(),\n    scrollBehavior: TopAppBarScrollBehavior? = null,\n    content: @Composable () -> Unit,\n) { ... }\n```\n\n매개변수들에 대해 안내해 드릴게요,\n\n<div class=\"content-ad\"></div>\n\n- color: 이 커스텀 색상 클래스는 FlexibleTopBarColors와 같이 사용되어 이 상단 앱 바의 다른 상태에 사용되는 색상을 해결하는 데 사용됩니다.\n- scrollBehavior: 콘텐츠가 스크롤된 양에 따라 topBar의 높이와 색상을 조정합니다. 이를 통해 앱 콘텐츠를 스크롤할 때 top 바가 동적으로 모양을 변경하게 됩니다. (기본 동작)\n- content: Scaffold의 topBar에서 사용하려는 조직 가능한 콘텐츠입니다. (topBar에 그리려고 시도한 콘텐츠)\n\n아래는 사용 예시입니다. 이 커스텀 FlexibleTopAppBar 조직 가능성으로 많은 가능성이 있습니다.\n\n전체 코드를 보시려면 파일을 참조하시거나 문서를 따르세요.\n전체 앱은 이 리포지토리에서 확인할 수 있습니다.\n\n이 글 작성에 유용한 참고 자료로 Oya Canlı 님의 기사에 대해 특별히 감사를 전합니다.\n\n<div class=\"content-ad\"></div>\n\n방문해 주셔서 감사합니다!\n\n잊지 말고, 항상 더 나은 방법이 있어요!","ogImage":{"url":"/assets/img/2024-06-30-CustomTopAppBarusingAndroidJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-30-CustomTopAppBarusingAndroidJetpackCompose_0.png","tag":["Tech"],"readingTime":4},{"title":"루비에서 싱글턴 메서드 사용하는 방법 입문 가이드","description":"","date":"2024-06-30 22:48","slug":"2024-06-30-IntroductiontoSingletonMethodsinRuby","content":"\n\n\n![이미지](/assets/img/2024-06-30-IntroductiontoSingletonMethodsinRuby_0.png)\n\n싱글톤 메서드는 루비의 강력한 기능 중 하나로, 개발자가 전체 클래스가 아닌 단일 객체에 메서드를 정의할 수 있게 합니다. 이 기능은 클래스의 다른 인스턴스에 영향을 미치지 않고 개별 객체에 맞게 동작을 지정해야 하는 시나리오에서 중요합니다.\n\n# 싱글톤 메서드 이해\n\n## 싱글톤 메서드의 정의\n\n\n<div class=\"content-ad\"></div>\n\n루비에서의 싱글톤 메소드는 단일 객체에 대해 정의된 메소드입니다. 클래스 메소드가 클래스의 모든 인스턴스에 적용되는 반면, 싱글톤 메소드는 특정 객체를 대상으로 합니다.\n\n## 싱글톤 메소드의 중요성\n\n이러한 메소드는 클래스 자체를 변경하지 않고 객체의 동작을 사용자 정의하는 데 중요합니다. 이러한 맞춤 설정은 객체지향 프로그래밍에서 유연성과 정확성을 제공합니다.\n\n# 왜 싱글톤 메소드를 사용해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n## 싱글톤 메서드의 장점\n\n- 맞춤화: 개별 객체의 동작을 맞춤 설정합니다.\n- 캡슐화: 고유한 메서드를 단일 객체의 범위 내에 유지합니다.\n- 유연성: 객체의 기능을 쉽게 수정하거나 확장할 수 있습니다.\n\n## 싱글톤 메서드의 사용 사례\n\n- 구성 설정: 특정 인스턴스에 대한 고유한 설정 정의\n- 이벤트 처리: 특정 객체에 대한 이벤트 응답을 사용자 정의합니다.\n- 프로토타이핑: 실험적 목적으로 기능을 빠르게 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n# Singleton 메소드 생성\n\n![이미지](/assets/img/2024-06-30-IntroductiontoSingletonMethodsinRuby_1.png)\n\n## Singleton 메소드 문법\n\nSingleton 메소드를 정의하는 것은 간단합니다. 해당 메소드를 객체에 직접 지정하는 것을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nobject = Object.new\ndef object.singleton_method\n  \"This is a singleton method\"\nend\n```\n\n## Singleton 메소드의 예시\n\n다음은 싱글톤 메소드의 생성과 호출을 보여주는 기본적인 예시입니다.\n\n```js\nclass MyClass\nend\n\nobj = MyClass.new\n\ndef obj.unique_method\n  \"This method is unique to obj\"\nend\n\nputs obj.unique_method  # 출력: \"This method is unique to obj\"\n```\n\n<div class=\"content-ad\"></div>\n\n# 싱글톤 메서드 vs 클래스 메서드\n\n![이미지](/assets/img/2024-06-30-IntroductiontoSingletonMethodsinRuby_2.png)\n\n## 싱글톤 메서드와 클래스 메서드의 차이점\n\n- 범위: 싱글톤 메서드는 개별 객체를 위한 것이며, 클래스 메서드는 클래스에 적용됩니다.\n- 사용: 싱글톤 메서드는 단일 인스턴스를 수정하는 반면, 클래스 메서드는 모든 인스턴스에서 공유됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 유사점\n\n두 유형의 방법 모두 일반 인스턴스 메소드를 넘어 기능을 확장하는 방법을 제공합니다.\n\n# 설정을 위한 싱글톤 메소드 사용\n\n## 실용적인 예제\n\n<div class=\"content-ad\"></div>\n\n싱글톤 메서드는 설정용으로 유용합니다. 예를 들어 인스턴스에 고유한 속성을 설정하는 것 등이 있습니다.\n\n```js\nclass Config\nend\n\napp_config = Config.new\n\ndef app_config.set(setting, value)\n  @settings ||= {}\n  @settings[setting] = value\nend\n\napp_config.set(:timeout, 30)\n```\n\n# 싱글톤 메서드와 디자인 패턴\n\n## 싱글톤 디자인 패턴\n\n<div class=\"content-ad\"></div>\n\n싱글톤 메서드와는 조금 다르지만, 싱글톤 디자인 패턴은 클래스가 하나의 인스턴스만 가지고 그 인스턴스에 전역적으로 접근할 수 있도록 하는 것을 보장합니다.\n\n## 루비에서의 예제\n\n루비에서의 싱글톤 디자인 패턴은 싱글톤 메서드를 사용하여 인스턴스화를 제어하는 방식을 취합니다.\n\n```js\n# 싱글톤 클래스는 클라이언트가 고유한 싱글톤 인스턴스에 액세스할 수 있게 하는 `instance` 메서드를 정의합니다.\nclass Singleton\n  @instance = new\n\n  private_class_method :new\n\n  # 싱글톤 인스턴스에 대한 액세스를 제어하는 정적 메서드입니다.\n  #\n  # 이 구현은 싱글톤 클래스를 서브클래스화하여 각 서브클래스의 인스턴스를 딱 하나씩 유지할 수 있습니다.\n  def self.instance\n    @instance\n  end\n\n  # 마지막으로, 모든 싱글톤은 몇 가지 비즈니스 로직을 정의해야 합니다. 이 비즈니스 로직은 해당 인스턴스에서 실행될 수 있습니다.\n  def some_business_logic\n    # ...\n  end\nend\n\n# 클라이언트 코드\n\ns1 = Singleton.instance\ns2 = Singleton.instance\n\nif s1.equal?(s2)\n  print '싱글톤이 작동 중입니다. 두 변수 모두 동일한 인스턴스를 포함합니다.'\nelse\n  print '싱글톤이 실패했습니다. 변수는 서로 다른 인스턴스를 포함합니다.'\nend\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예시는 다음 주소에서 확인할 수 있습니다: https://refactoring.guru/design-patterns/singleton\n\n# 싱글톤 메서드의 실제 응용 사례\n\n## 사례 연구\n\n많은 Ruby 애플리케이션은 특별한 로깅, 고유 구성 및 객체 동작의 예외적인 경우를 처리하기 위해 싱글톤 메서드를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n## 프로젝트\n\n대규모 루비 프로젝트는 종종 각 구성 요소의 구성 및 동적 행위를 관리하기 위해 싱글톤 메서드를 사용합니다.\n\n## 싱글톤 메서드의 한계\n\n### 잠재적인 단점\n\n<div class=\"content-ad\"></div>\n\n- 오버헤드: 과도한 사용은 혼란과 유지보수 노력 증가로 이어질 수 있습니다.\n- 복잡성: 싱글톤 메서드의 이해와 디버깅은 일반 메서드보다 더 복잡할 수 있습니다.\n\n## 대안\n\n싱글톤 메서드가 불필요한 복잡성을 추가할 수 있는 경우에는 클래스 메서드나 인스턴스 변수 사용을 고려해보세요.\n\n# 싱글톤 메서드 사용에 대한 최상의 적용 방법\n\n<div class=\"content-ad\"></div>\n\n## 효과적인 사용 팁\n\n- 명확성: 싱글톤 메서드가 잘 문서화되어 있는지 확인하세요.\n- 목적: 평범한 또는 클래스 메서드보다 명확한 장점이 있는 경우에만 사용하세요.\n- 일관성: 코드베이스 전반에 걸쳐 일관된 방식을 유지하세요.\n\n## 흔한 함정\n\n- 남용: 싱글톤 메서드를 지나치게 사용하지 않도록 주의하세요. 이는 지저분하고 유지하기 어려운 코드로 이어질 수 있습니다.\n- 오용: 싱글톤 메서드가 문제 해결에 적합한 도구인지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n# 싱글톤 메서드와 객체 지향 프로그래밍\n\n## OOP의 원칙\n\n싱글톤 메서드는 캡슐화 및 다형성을 촉진하며 OOP 원칙과 일치합니다.\n\n## OOP 개념과의 통합\n\n<div class=\"content-ad\"></div>\n\n그들은 클래스 구조의 무결성을 해치지 않고 객체별 동작을 추가할 수 있는 방법을 제공합니다.\n\n# 싱글턴 메서드 테스트\n\n## 테스트 기법\n\n- 단위 테스트: 싱글턴 메서드를 분리하여 개별적으로 테스트합니다.\n- 목 객체(Mocking): 목 객체를 사용하여 싱글턴 메서드가 있는 객체의 동작을 모방합니다.\n\n<div class=\"content-ad\"></div>\n\n## 테스트 도구\n\nRSpec와 MiniTest와 같은 도구를 사용하면 싱글톤 메소드에 대한 효과적인 테스트를 작성할 수 있어요.\n\n# 싱글톤 메소드에 대한 고급 개념\n\n## 싱글톤 메소드와 메타프로그래밍\n\n<div class=\"content-ad\"></div>\n\n루비의 메타프로그래밍 기능을 통해 싱글톤 메서드의 동적 정의가 가능해져 유연성이 증가합니다.\n\n```js\nobject = Object.new\nobject.define_singleton_method(:dynamic_method) do\n  \"This method was defined dynamically!\"\nend\n\nputs object.dynamic_method  # 출력: \"This method was defined dynamically!\"\n```\n\n## 동적 정의\n\n런타임에서 메서드를 동적으로 정의하는 것은 유연한 애플리케이션 구축에 강력한 도구가 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 루비 라이브러리 및 젬에서의 싱글톤 메서드\n\n## 라이브러리에서의 싱글톤 메서드 예제\n\n많은 루비 라이브러리와 젬은 구성 가능한 옵션과 설정을 제공하기 위해 싱글톤 메서드를 활용합니다.\n\n## 인기 있는 젬에서의 사용\n\n<div class=\"content-ad\"></div>\n\nActiveRecord 및 Rails 자체와 같은 보석들은 설정 및 초기화를 위해 싱글톤 메서드를 활용합니다.\n\n# 싱글톤 메서드와 코드 유지보수\n\n## 장기 유지보수\n\n싱글톤 메서드는 이해하기 쉽고 유지보수가 용이하도록 정기적으로 문서화 및 검토되어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 가독성\n\n코드를 읽고 유지보수하기 쉽도록 명확하고 간결하며 잘 문서화된 싱글톤 메서드를 작성하세요.\n\n# 싱글톤 메서드를 배우는 커뮤니티 자료\n\n## 블로그\n\n<div class=\"content-ad\"></div>\n\n- Ruby Flow: 다양한 루비 주제에 대한 포스트가 있는 커뮤니티 사이트입니다.\n\n## 튜토리얼\n\n- RubyGuides: 싱글톤 메소드를 포함한 다양한 루비 개념에 대한 튜토리얼과 안내서를 제공합니다.\n- Learn Ruby the Hard Way: 싱글톤 메소드와 같은 고급 주제를 포함한 루비 학습에 대한 포괄적인 안내서입니다.\n\n## 포럼\n\n<div class=\"content-ad\"></div>\n\n- Ruby Forum: 루비 개발자들과 지식을 공유하고 질문을 할 수 있는 곳입니다.\n- Stack Overflow: 루비 질문에 대한 답변을 찾을 수 있는 Q&A 사이트입니다.\n\n# 결론\n\n싱글톤 메소드는 루비에서 다양하고 강력한 기능을 제공하며, 개발자들이 개별 객체의 동작을 정교하게 사용자화할 수 있습니다. 이는 유연성과 캡슐화를 포함하여 중요한 이점을 제공하며, 루비 개발자들에게 필수적인 도구입니다. 그러나 높은 복잡성과 유지 관리 문제와 같은 잠재적인 문제를 피하기 위해 신중하게 사용하는 것이 중요합니다. 사용 사례, 최상의 실행 방법 및 일반적인 함정을 이해하여, 개발자들은 싱글톤 메소드를 효과적으로 활용하여 루비 애플리케이션을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-IntroductiontoSingletonMethodsinRuby_0.png"},"coverImage":"/assets/img/2024-06-30-IntroductiontoSingletonMethodsinRuby_0.png","tag":["Tech"],"readingTime":6},{"title":"AWS Lambda와 DynamoDB로 확장 가능한 CRUD 애플리케이션 구축 Java 사용","description":"","date":"2024-06-30 22:47","slug":"2024-06-30-BuildingaScalableCRUDApplicationwithAWSLambdaandDynamoDBinJava","content":"\n\n오늘날의 클라우드 컴퓨팅 환경에서는, 서버리스 아키텍처가 확장성, 비용 효율성, 그리고 쉬운 관리로 많은 인기를 얻고 있습니다. AWS Lambda와 DynamoDB가 결합된 것은 서버리스 애플리케이션을 개발하는 데 강력한 조합을 제공합니다.\n\n이 포괄적인 가이드에서는, Java를 사용하여 AWS Lambda와 DynamoDB를 활용하여 견고하고 확장 가능한 서버리스 애플리케이션을 구축하는 과정에 대해 자세히 살펴보겠습니다. DynamoDB 테이블 설정부터 Lambda 함수 작성, 그리고 애플리케이션 배포까지 각 단계를 자세하게 다룰 것입니다. AWS Lambda와 DynamoDB의 서버리스 컴퓨팅의 힘을 활용하기 위한 여정에 동참해 보죠.\n\n준비물: 시작하기 전에, AWS Lambda, DynamoDB 및 Java 프로그래밍에 대한 기본적인 이해가 있다고 가정합니다. 로컬 개발 환경에선 AWS SDK for Java가 설치 및 구성되어 있어야 합니다. 추가로, 실습을 따라가려면 활성화된 AWS 계정이 필요합니다.\n\n단계 1: DynamoDB 테이블 설정하기:\n\n<div class=\"content-ad\"></div>\n\n저희 서버리스 애플리케이션에 데이터를 저장하기 위해 DynamoDB 테이블을 설정해야 합니다. 아래 단계를 따라 진행해보세요:\n\n1. AWS Management Console에 액세스하고 DynamoDB 테이블 설정 섹션으로 이동합니다.\n   \n- 적절한 이름으로 새 테이블을 생성하고 \"id\"와 같은 기본 키를 정의합니다. 애플리케이션 요구에 따라 추가 속성을 추가할 수 있습니다.\n   \n2. AWS Lambda 함수 구성: Lambda 함수를 작성하기 전에 AWS Lambda 환경을 구성해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n- 시작하려면 선호하는 통합 개발 환경(IDE)에서 새 Java 프로젝트를 만드세요.\n- 프로젝트에 AWS SDK for Java와 같은 필수 종속성을 추가하세요.\n- 서버리스 응용 프로그램을 위한 CRUD 작업을 처리할 새 Java 클래스를 만드세요. 필요한 AWS SDK 라이브러리를 가져오세요.\n\n### 단계 3: 람다 함수 작성\n이제 람다 함수 작성으로 넘어갑시다. 이 함수는 서버리스 응용 프로그램의 CRUD 작업을 처리할 것입니다.\n\n1. 람다 함수 핸들러 메서드 정의:\n\n```java\npublic class CrudLambdaHandler implements RequestHandler<Request, Response> {\n    public Response handleRequest(Request request, Context context) {\n        // 구현 내용을 여기에 작성하세요\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n2. DynamoDB 테이블과 연결 설정: handleRequest 메서드 내부에서 AWS SDK에서 AmazonDynamoDBClient 클래스의 인스턴스를 생성합니다. Step 1에서 생성한 DynamoDB 테이블에 연결하는 방법은 다음과 같습니다:\n\n```js\nAmazonDynamoDB client = AmazonDynamoDBClientBuilder.standard().build();\nDynamoDB dynamoDB = new DynamoDB(client);\nTable table = dynamoDB.getTable(\"테이블_이름\");\n```\n\n3. CRUD 작업 구현: handleRequest 메서드 내부에서 응용 프로그램의 요구 사항에 따라 CRUD 작업을 수행하는 코드를 작성합니다. 여기에 몇 가지 예시가 있습니다:\n\n- 생성(CREATE) 작업:\n\n<div class=\"content-ad\"></div>\n\n```java\nItem item = new Item().withPrimaryKey(\"id\", request.getId())\n    .withString(\"title\", request.getTitle())\n    .withString(\"description\", request.getDescription())\n    .withBoolean(\"status\", request.getStatus());\ntable.putItem(item);\n```\n\n- Read operation\n\n```java\nItem item = table.getItem(\"id\", request.getId());\nResponse response = new Response(item.getString(\"title\"), item.getString(\"description\"), item.getBoolean(\"status\"));\n```\n\n- Update operation:\n\n<div class=\"content-ad\"></div>\n\n```js\nUpdateItemSpec updateItemSpec = new UpdateItemSpec()\n    .withPrimaryKey(\"id\", request.getId())\n    .withUpdateExpression(\"set #titleAttr = :titleValue, #descAttr = :descValue, #statusAttr = :statusValue\")\n    .withNameMap(new NameMap().with(\"#titleAttr\", \"title\").with(\"#descAttr\", \"description\").with(\"#statusAttr\", \"status\"))\n    .withValueMap(new ValueMap().withString(\":titleValue\", request.getTitle())\n        .withString(\":descValue\", request.getDescription())\n        .withBoolean(\":statusValue\", request.getStatus()));\ntable.updateItem(updateItemSpec);\n```\n\n- Delete operation:\n\n```js\ntable.deleteItem(\"id\", request.getId());\n```\n\nStep 4: Lambda 함수를 배포하고 테스트하기:\n이제 Lambda 함수를 배포하고 테스트하세요.  \n\n<div class=\"content-ad\"></div>\n\n1. 람다 함수 코드와 해당 컴파일된 클래스 파일 및 종속성을 단일 JAR(Java Archive) 파일로 패키징합니다.\n2. AWS Management Console에 액세스하여 AWS Lambda로 이동하고 새 함수를 생성합니다.\n3. 함수의 런타임, 핸들러 및 필요한 권한을 구성합니다.\n4. 람다 함수 코드가 포함된 JAR 파일을 업로드합니다.\n5. 함수가 배포된 후 AWS Lambda 콘솔의 테스트 탭을 사용하여 샘플 데이터로 호출하고 기능을 확인합니다.\n\n결론:\n이 블로그 포스트에서는 Java를 사용하여 AWS Lambda 및 DynamoDB를 활용한 확장 가능한 서버리스 CRUD 애플리케이션을 개발하는 여정에 참여했습니다. DynamoDB 테이블 설정, AWS Lambda 함수 구성, CRUD 작업 작성, 함수 배포 및 테스트와 같은 중요한 단계를 다뤘습니다. 이 안내를 따라가면 AWS 플랫폼에서 자체 서버리스 애플리케이션을 만들기 위한 지식과 기술을 습득할 수 있습니다. AWS Lambda 및 DynamoDB로 확장 가능하고 비용 효율적인 애플리케이션을 만드는 즐거움을 느껴보세요!","ogImage":{"url":"/assets/img/2024-06-30-BuildingaScalableCRUDApplicationwithAWSLambdaandDynamoDBinJava_0.png"},"coverImage":"/assets/img/2024-06-30-BuildingaScalableCRUDApplicationwithAWSLambdaandDynamoDBinJava_0.png","tag":["Tech"],"readingTime":4},{"title":"CSS Position  Absolute와 Relative 비교 올바르게 사용하는 방법","description":"","date":"2024-06-30 18:37","slug":"2024-06-30-CSSPositionAbsoluteRelative","content":"\n\n# 위치: 상대적(relative);\n\n요소가 상대적으로 위치할 때는 문서 흐름에서의 정상적인 위치를 기준으로 배치됩니다. 주변 요소에 영향을 미치지 않으며 문서 흐름 상에서의 위치를 유지합니다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>상대적 위치 설정 예시</title>\n    <style>\n        .relative-box {\n            width: 200px;\n            height: 100px;\n            background-color: lightblue;\n            position: relative;\n            top: 20px;\n            left: 30px;\n        }\n        .text {\n            background-color: lightgreen;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"relative-box\">\n        상대적으로 위치한 상자입니다.\n    </div>\n    <div class=\"text\">\n        상자 아래에 있는 일부 텍스트입니다.\n    </div>\n</body>\n</html>\n```\n\n# 위치: 절대적(absolute);\n\n<div class=\"content-ad\"></div>\n\n절대 위치로 요소를 배치하면 이 요소는 가장 가까운 위치 지정된 조상에 대해 배치됩니다 (즉, 정적이 아닌 위치를 가진 가장 가까운 조상). 이러한 조상이 없는 경우 초기 포함 블록에 대해 배치됩니다 (일반적으로 뷰포트).\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>절대 위치 지정 예시</title>\n    <style>\n        .relative-container {\n            position: relative;\n            width: 300px;\n            height: 200px;\n            background-color: lightgray;\n        }\n        .absolute-box {\n            position: absolute;\n            top: 20px;\n            right: 30px;\n            width: 100px;\n            height: 50px;\n            background-color: lightcoral;\n        }\n        .text {\n            background-color: lightgreen;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"relative-container\">\n        <div class=\"absolute-box\">\n            저는 절대 위치로 배치된 상자입니다.\n        </div>\n        컨테이너\n    </div>\n    <div class=\"text\">\n        컨테이너 아래의 텍스트입니다.\n    </div>\n</body>\n</html>\n```\n\n또는\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>상대 및 절대 위치 지정 예시</title>\n    <style>\n        .outer-container {\n            width: 400px;\n            height: 300px;\n            background-color: lightgray;\n            position: relative;\n            margin-bottom: 20px;\n        }\n\n        .inner-container {\n            width: 300px;\n            height: 200px;\n            background-color: lightblue;\n            position: relative;\n            top: 20px;  /* inner-container의 위치에서 아래로 20px 이동 */\n            left: 20px; /* inner-container의 위치에서 오른쪽으로 20px 이동 */\n        }\n\n        .absolute-box {\n            width: 100px;\n            height: 50px;\n            background-color: lightcoral;\n            position: absolute;\n            bottom: 10px; /* 상자를 inner-container의 하단에서 10px로 배치 */\n            left: 10px;   /* 상자를 inner-container의 왼쪽에서 10px로 배치 */\n        }\n\n        .text {\n            background-color: lightgreen;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"outer-container\">\n        <div class=\"inner-container\">\n            <div class=\"absolute-box\">\n                저는 절대 위치로 배치된 상자입니다.\n            </div>\n            저는 상대적 위치로 배치된 내부 컨테이너입니다.\n        </div>\n        저는 상대적 위치로 배치된 외부 컨테이너입니다.\n    </div>\n    <div class=\"text\">\n        외부 컨테이너 아래의 텍스트입니다.\n    </div>\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n# 읽어 주셔서 감사합니다\n\n- 장기 멘토십을 위해 Preplaced.com에서 연락하세요,\n\n무료 체험 신청하세요! — https://www.preplaced.in/profile/sonika-maheshwari\n\n📰 코딩 및 디자인 라운드 인터뷰에 대한 더 많은 콘텐츠 보기 - https://sonikamaheshwari067.medium.com/\n\n<div class=\"content-ad\"></div>\n\n🔔 Follow me on LinkedIn! — [https://www.linkedin.com/in/sonika-maheshwari-81542220/](https://www.linkedin.com/in/sonika-maheshwari-81542220/)\n\n저는 항상 개선할 부분이 있을 것이라고 믿어요. 의견을 자유롭게 공유해주세요.","ogImage":{"url":"/assets/img/2024-06-30-CSSPositionAbsoluteRelative_0.png"},"coverImage":"/assets/img/2024-06-30-CSSPositionAbsoluteRelative_0.png","tag":["Tech"],"readingTime":4},{"title":"2024년에 Bootstrap과 Tailwind 비교 어떤 CSS 프레임워크가 더 나은가","description":"","date":"2024-06-30 18:36","slug":"2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks","content":"\n\n![img](/assets/img/2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks_0.png)\n\n안녕하세요, 개발자 여러분! CSS 프레임워크에 관한 많은 이야기가 있지만, 여기에 제 의견을 덧붙이겠습니다.\n\n두 프레임워크는 각자의 장점과 약점을 가지고 있고, 이 글에서는 자세히 살펴보며 여러분이 필요에 맞는 것을 선택하는 데 도움이 될 것입니다. 게다가, HNG에서 React로 작업하며 기대하는 것과 인턴십 중에 이루고 싶은 목표에 대해 나누도록 하겠습니다.\n\n부트스트랩:\n부트스트랩은 포괄적인 미리 디자인된 UI 구성 요소, 레이아웃 및 유틸리티를 제공하는 인기 있는 CSS 프레임워크입니다. 12열 그리드 시스템을 사용하며 다양한 사용자 정의 옵션을 제공합니다. 부트스트랩은 큰 커뮤니티와 방대한 문서를 가지고 있어 빠른 프로토타이핑과 개발에 좋은 선택입니다.\n\n<div class=\"content-ad\"></div>\n\n테일윈드:\n테일윈드는 유틸리티 중심의 CSS 프레임워크로, 스타일링에 독특한 접근 방식을 제공합니다. 구성 중심의 접근 방식을 사용하며 HTML 요소에 스타일링할 수 있는 다양한 유틸리티 클래스를 제공합니다. 테일윈드는 맞춤화에 강조를 두며 맞춤 UI 컴포넌트를 구축하기 위한 강력한 도구 세트를 제공합니다.\n\n비교:\n부트스트랩과 테일윈드는 각각의 장점을 가지고 있습니다. 부트스트랩은 미리 디자인된 UI 컴포넌트와 광범위한 커뮤니티 지원에 뛰어납니다. 한편, 테일윈드는 유틸리티 중심의 접근 방식과 맞춤화 옵션에서 빛을 발합니다. 부트스트랩은 포괄적인 UI 컴포넌트 세트로 빠른 프로토타이핑에 이상적이지만, 테일윈드의 유틸리티 클래스는 맞춤 UI 개발에 적합합니다.\n\n맞춤화:\n맞춤화에 있어서는 테일윈드가 선도합니다. 구성 중심의 접근 방식을 통해 확장 가능한 맞춤화 옵션을 제공하여 프로젝트에 독특한 룩 앤 필을 쉽게 만들 수 있습니다. 다른 한편으로, 부트스트랩은 일부 맞춤화 옵션을 제공하지만 테일윈드와 비교하면 제약이 있습니다.\n\n커뮤니티 지원:\n부트스트랩은 더 큰 커뮤니티와 더 많은 문서를 가지고 있어 필요할 때 리소스와 지원을 쉽게 찾을 수 있습니다. 테일윈드의 커뮤니티는 작지만 여전히 활발하고 지원적입니다.\n\n<div class=\"content-ad\"></div>\n\n성능:\n두 프레임워크 모두 성능이 우수하지만 Tailwind의 유틸리티 중심 접근 방식은 CSS 파일 크기와 로드 시간 측면에서 더 효율적입니다.\n\n이제 HNG로...!\n\n![이미지](/assets/img/2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks_1.png)\n\nHNG 인턴십 소개:\nHNG의 인턴십 프로그램은 React를 사용한 프런트엔드 개발을 실무 경험을 제공하도록 디자인되었습니다. 이 프로그램은 포괄적인 커리큘럼, 멘토십, 그리고 인턴들이 스킬을 향상시킬 수 있도록 현실적인 프로젝트를 제공합니다. (HNG의 인턴십 프로그램에 대해 더 알아보려면 [여기](https://hng.tech/internship)를 방문하세요). 게다가, HNG는 인턴들이 전문 포트폴리오를 구축하고 잠재적인 고용주들과 연결할 수 있도록 프레미엄 서비스를 제공합니다. (HNG의 프리미엄 서비스를 탐색하려면 [여기](https://hng.tech/premium)에서 확인하세요).\n\n<div class=\"content-ad\"></div>\n\n리액트 — 프론트엔드 개발을 위한 프레임워크:\n리액트는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리입니다. 컴포넌트 기반 접근 방식, 가상 DOM 및 효율적인 업데이트 메커니즘을 제공하여 프론트엔드 개발을 위한 최고의 선택지가 되고 있습니다. 인턴십 중에는 빠르고 확장 가능하며 유지 보수가 용이한 애플리케이션을 만들기 위해 리액트를 사용할 예정입니다.\n\n나의 기대:\n리액트를 통해 실무 경험을 쌓고, 경험 많은 멘토로부터 배우며, 도전적인 프로젝트에 참여할 것을 기대합니다. 프론트엔드 커뮤니티에 기여하고 나의 기술을 쇼케이스하는 전문 포트폴리오를 개발하는 것에 흥미를 느낍니다.\n\n결론:\n종합하면, 부트스트랩과 테일윈드는 각각 독특한 장점을 가진 강력한 CSS 프레임워크입니다. 이들의 차이를 이해함으로써 개발자들은 프로젝트에 가장 적합한 도구를 선택할 수 있습니다. HNG 여정을 시작하면서, 리액트의 가능성을 탐험하고 프론트엔드 커뮤니티에 기여하는 것에 기대됩니다.","ogImage":{"url":"/assets/img/2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks_0.png"},"coverImage":"/assets/img/2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks_0.png","tag":["Tech"],"readingTime":3},{"title":"React vs Angular 최고의 선택을 위한 대결 분석","description":"","date":"2024-06-30 18:35","slug":"2024-06-30-ReactvsAngularPickingTheGiantForTheBestUse","content":"\n\n## 목차\n\n- 첫인상\n- React 및 그 기능들\n- Angular 및 그 기능들\n- React와 Angular 비교\n- React와 Angular의 장점\n- React와 Angular의 단점\n- 최적의 사용 사례\n- 최종 생각\n\nReact와 Angular는 웹 애플리케이션의 프론트엔드를 구축하는 데 사용되는 매우 인기있는 기술입니다. React는 학습의 용이성, 높은 채택률 및 방대한 생태계로 잘 알려져 있으며, Angular는 코드 구조의 견고함으로 높은 수준의 응용프로그램에 가장 적합한 옵션으로 알려져 있습니다. 이 기사에서는 이 두 거인, 그들의 차이점, 강점 및 약점을 살펴보고 가장 유용한 분야를 알아보겠습니다.\n\n# React\n\n<div class=\"content-ad\"></div>\n\nReact은 사용자 인터페이스를 만드는 데 중점을 둔 JavaScript 라이브러리로서, Meta(이전 Facebook)에서 구축 및 유지보수되며 재사용 가능한 컴포넌트와 선언적 프로그래밍 패러다임을 활용합니다. React는 가상 DOM을 사용하여 웹 페이지의 메모리에 대한 표현을 제공하여 웹 애플리케이션이 UI 변경을 쉽게 수행할 수 있도록 합니다.\n\n컴포넌트 기반 아키텍처와 가상 DOM의 사용으로, React를 사용하면 웹 애플리케이션의 다음 동작을 예측하기가 쉬워지며, 개발자 커뮤니티가 크기 때문에 새로운 개발자들도 쉽게 학습할 수 있습니다.\n\n## 특징\n\n- 컴포넌트 기반 아키텍처와 선언적 프로그래밍에 중점을 두기 때문에 웹에서 사용자 인터페이스를 쉽게 구축하고 전체 코드 결과를 예측할 수 있습니다.\n- JSX(JavaScript XML)의 사용으로 HTML과 JavaScript의 능력을 결합하여 단일 페이지 애플리케이션(SPA)을 효과적으로 구축할 수 있습니다.\n- 상태(state), 속성(props), 훅(hooks)을 활용하여 애플리케이션의 동적 데이터를 처리할 수 있습니다.\n- 가상 DOM을 통해 웹 애플리케이션을 효과적이고 효율적으로 렌더링할 수 있습니다.\n- 큰 커뮤니티는 특정 작업을 위한 라이브러리 및 React를 기반으로 한 프레임워크를 만들어 다양성을 촉진하므로 개발자 경험을 즐겁게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n# Angular\n\nAngular은 Google에서 만들고 유지보수하는 JavaScript 프레임워크로, 강력하고 복잡한 웹 애플리케이션을 개발하는 데 사용됩니다. TypeScript를 사용하며, TypeScript는 JavaScript의 슈퍼셋으로, 타입 체크와 같은 기능을 추가하여 코드를 구성하고 유지보수를 쉽게 할 수 있도록 합니다. 전반적으로, Angular는 사용자가 웹에서 데스크톱 앱을 사용하는 경험을 할 수 있도록 도와줍니다.\n\n## 특징\n\n- 추가 라이브러리를 설치하거나 가져오지 않아도 애플리케이션을 개발할 수 있는 풍부한 기능 세트를 제공합니다.\n- TypeScript를 사용하여 코드를 더 깔끔하고 타입 체크를 통해 버그 발생 가능성을 줄입니다.\n- 컴포넌트 구조로 인해 매우 높은 캡슐화 수준을 갖습니다.\n- 서비스와 의존성 주입을 사용하여 컴포넌트 간에 데이터를 공유할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 장점\n\n## React\n\n- 커뮤니티가 크기 때문에 라이브러리와 프레임워크를 만들어 패키지로 제공하여 개발자가 새로운 멋진 기능을 추가할 수 있습니다.\n- JSX 사용으로 브라우저에 표시될 내용을 프로그래밍 방식으로 결정하는 것이 쉬워집니다.\n- 가상 DOM을 통해 UI를 브라우저에 빠르게 렌더링할 수 있습니다.\n- 배우기 쉬운 곡선을 가지고 있어 초보자가 배우기가 쉽습니다.\n\n## Angular\n\n<div class=\"content-ad\"></div>\n\n- TypeScript을 사용하여 코드 구조를 더 견고하게 만들어 버그가 덜 발생하고 유지 관리하기 쉽습니다.\n- 필요한 패키지를 가져오지 않아도 되어 개발자들이 라우팅, 상태 관리 등 특정 작업에 대해 추가 패키지를 사용하지 않아도 됩니다.\n- 서버 측 렌더링을 보다 쉽고 빠르게 만들어 줍니다.\n\n# 단점\n\n## 리액트\n\n- 큰 생태계가 많은 라이브러리와 프레임워크로 인해 개발자들에게 압도적일 수 있습니다, 특히 처음 시작하는 사람들에겐 어려울 수 있습니다.\n- 빠른 개발 속도는 개발자들이 최신 상태를 유지하기 어렵게 만듭니다.\n- 생태계의 특성으로 인해 리액트 응용프로그램을 구축하는 표준 방법이 없어 개발 프로세스에서 복잡성을 야기할 수 있습니다.\n- 부실한 문서로 리액트 라이브러리의 깊은 부분을 이해하기 어렵습니다.\n\n<div class=\"content-ad\"></div>\n\n## Angular\n\n- 초보자에게는 배우기 어려운 러닝 커브가 있어요.\n- 대규모 제품에서 사용되는데 호환성 문제가 있어요.\n- 인터넷 연결이 느릴 때 특히 다운로드하기 어려운 무거운 프레임워크에요.\n\n# 최적의 사용 사례\n\n## React\n\n<div class=\"content-ad\"></div>\n\n- Single Page Applications (SPAs)\n- 대시보드 및 데이터 시각화\n- React Native를 활용한 모바일 앱\n\n## Angular\n\n- 기업 수준의 웹 애플리케이션\n- 동적 콘텐츠를 갖춘 웹페이지\n- Progressive Web Applications (PWAs)\n\n# 마지막으로 생각해볼 내용\n\n<div class=\"content-ad\"></div>\n\n제 프로젝트에서는 다양성과 JSX 사용 때문에 React를 주로 사용합니다. JSX를 사용하면 작업이 더 쉬워지기 때문에 좋습니다.\n\n이 기사는 제가 Medium에서 처음 쓴 기사이자 온라인 블로그에서 쓴 첫 기사입니다. 이 기사는 HNG Tech의 무료 인턴십 프로그램에서 주어진 과제였습니다.\n\n행사에 등록하려면 여기를 클릭하거나 https://hng.tech/internship로 이동하세요.\n\n귀사를 위해 인재를 고용하려면 여기를 클릭하거나 https://hng.tech/hire로 이동하세요.\n\n<div class=\"content-ad\"></div>\n\n이 기사를 즐겁게 읽으셨기를 바랍니다. 궁금한 점이나 생각이 있으시면 댓글란에 달아주세요.\n\n고맙고 즐거운 하루 되세요 😊","ogImage":{"url":"/assets/img/2024-06-30-ReactvsAngularPickingTheGiantForTheBestUse_0.png"},"coverImage":"/assets/img/2024-06-30-ReactvsAngularPickingTheGiantForTheBestUse_0.png","tag":["Tech"],"readingTime":4},{"title":"TypeScript Enum이 정말 별로인 이유 5가지","description":"","date":"2024-06-30 18:34","slug":"2024-06-30-TypeScriptEnumsareTerrible","content":"\n\n\n![TypeScript Enums](/assets/img/2024-06-30-TypeScriptEnumsareTerrible_0.png)\n\n## Enum의 역사\n\nTypeScript는 2012년에 등장하여 컴파일 시간에 타입을 확인하는 새로운 시대를 연 했습니다.\n\nTypeScript는 JavaScript의 하위 집합이므로 개발자들이 구현하기 쉬웠으며, 코드는 마침내 JavaScript로 컴파일되었습니다.\n\n\n<div class=\"content-ad\"></div>\n\nTypeScript에는 클래스와 같은 새로운 기능이 도입되었습니다. 이 기능은 2015년 JavaScript에 도입되었습니다.\n\n또한 TypeScript에 추가된 열거형(enum)이라는 또 다른 기능이 있는데, 이 기능은 아직 JavaScript에 구현되지 않았습니다.\n\n이것이 JavaScript에 왜 아직 구현되지 않았는지 궁금해지는 이유입니다.\n\n# 열거형(enum)이란 무엇을 하는 것인가요?\n\n<div class=\"content-ad\"></div>\n\n열거형은 사용할 때 반드시 원본 개체를 참조해야하는 값을 정의하는 방법입니다.\n\n```js\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nconst move = (direction: Direction) => {};\n\nmove(Direction.Up);\nmove(Direction.Down);\n```\n\n우리는 이들이 어떻게 작동하는지 배워보고, 어쩌면 왜 클래스처럼 JavaScript에 아직 추가되지 않았는지 알아봅시다.\n\n# TypeScript의 열거형은 어떻게 작동하나요?\n\n<div class=\"content-ad\"></div>\n\n이전 예제를 가져와서 변환된 JavaScript 코드를 살펴보겠습니다.\n\n열거형은 실행 중에 약간 예측할 수 없는 동작을 합니다.\n\n다음과 같이 Direction 열거형이 있다고 가정해 봅시다.\n\n```js\nenum Direction {\n  Up,\n  Down,\n}\n```\n\n<div class=\"content-ad\"></div>\n\n기본적으로 Up의 값은 0이 되고 Down은 1이 됩니다. 자연스레 모두가 이 enum이 객체처럼 끝날 것이라고 생각할 것입니다.\n\n```js\nconst Direction = {\n  Up: 0,\n  Down: 1,\n}\n```\n\n그러나 JavaScript의 변환 코드를 살펴보면, 우리가 예상한 것과 약간 다른 복잡하고 심상치 않은 코드를 발견할 수 있습니다.\n\n```js\n\"use strict\";\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"Up\"] = 0] = \"Up\";\n    Direction[Direction[\"Down\"] = 1] = \"Down\";\n})(Direction || (Direction = {}));\n```\n\n<div class=\"content-ad\"></div>\n\n요런 객체가 나올 거에요. 예상했던 것과 매우 다르죠.\n\n```javascript\nconst Direction = {\n  Up: 0,\n  0: 'Up',\n  Down: 1,\n  1: 'Down'\n}\n```\n\n만약 Object.values(Direction)을 실행하면 [\"Up, \"Down\", 0, 1]과 같은 결과를 얻게 됩니다. 이것은 예상치 못한 결과이며 제대로 된 객체가 아닙니다.\n\n이것이 enum에 대해 짜증나는 첫 번째 점입니다. 기대에 맞게 동작하지 않는다는 것이죠.\n\n<div class=\"content-ad\"></div>\n\n문자열 열거형의 경우에는 적절한 객체가 생성됩니다.\n\n```js\nenum Direction  {\n  UP = \"Up\",\n  DOWN = \"Down\",\n}\n\n// 변환된 코드 \n\n\"use strict\";\nvar Direction;\n(function (Direction) {\n    Direction[\"UP\"] = \"Up\";\n    Direction[\"DOWN\"] = \"Down\";\n})(Direction || (Direction = {}));\n\n// 적절한 JS 객체 \n\nconst Direction = {\n  \"UP\": \"Up\",\n  \"DOWN\": \"DOWN\"\n}\n```\n\n그럼에도 불구하고 이에는 문제가 있습니다. 이를 보여드릴게요.\n\n어떤 함수에서 Direction 열거형 값을 액세스하려고 하는 경우를 가정해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n\n열거형 Direction {\n  UP= \"위\",\n  DOWN = \"아래\",\n}\n\n함수 logDirection(direction: Direction) {\n  콘솔.로그(direction)\n}\n\n✅ 잘 작동합니다\nlogDirection(Direction.UP)\n\n❌ 작동하지 않습니다 - 열거형의 멤버값으로 함수를 호출할 수 없습니다\nlogDirection(\"위\")\n\n\nlogDirection 함수를 Direction의 멤버 값으로 호출할 수 없다는 것을 알 수 있습니다.\nTypeScript를 보면 런타임 값보다는 이름에 신경을 쓴다는 저의 기대대로 동작합니다.\n\nDirection.UP와 Up의 값은 동일하며 이상적으로 TypeScript는 신경 쓰지 않을 것으로 예상되지만 열거형의 경우 이 규칙이 깨집니다.\n\n또한 const 열거형도 있으며 열거형을 사용하고 싶다면 유용할 수 있지만 주의할 점도 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst enum Direction  {\n  UP = \"Up\",\n  DOWN = \"Down\",\n}\n\n// transpile code\n\n\"use strict\";\n// nothing\n```\n\n보면 알 수 있듯이 enum을 const로 만드는 즉시, transpile code가 없다는 것은 이 경우 TypeScript에서 처리되며 구현 세부 사항에 대해 끝 사용자를 혼동시키지 않습니다. 멋지죠 😎 하지만 다시 한 번 주의할 점이 있어요.\n\n이를 사용해서 **왜 절대 사용해서는 안 되는지**에 대해 강조한 문서의 별도 섹션이 있습니다.\n\n[여기](https://www.typescriptlang.org/docs/handbook/enums.html#const-enum-pitfalls)를 참조해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 열거형의 혼란을 해결하는 방법\n\n열거형 대신 값을 수정하지 않을 객체와 함께 항상 as const를 사용해야 합니다.\n빠르게 예시를 살펴보겠습니다.\n\n```js\nconst Direction = {\n  UP: \"Up\",\n  DOWN: \"Down\"\n} as const\n\n\ntype GetValues<T> = T[keyof T]\n\ntype UnionOfObjectValues = GetValues<typeof Direction>\n\nfunction logDirection(direction: UnionOfObjectValues) {\n  console.log(direction)\n}\n\n✅ 동작합니다\nlogDirection(Direction.UP)\n\n✅ 또한 동작합니다\nlogDirection(\"Up\")\n```\n\n이 방법은 TypeScript의 기대에 완벽히 부합하며 작동 방식을 이해하기 쉽게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n만약 더 쉽게 만들고 싶다면, 오브젝트 값 대신 Direction의 키에서 union을 유도할 수 있어요.\n\n```js\nconst Direction = {\n  UP: \"Up\",\n  DOWN: \"Down\"\n} as const\n\ntype Directions = keyof typeof Direction\n\nfunction logDirection(direction: Directions) {\n  console.log(`${Direction[direction]} is present`)\n}\n\n✅ 잘 작동해요\nlogDirection(\"UP\")\n\n✅ 잘 작동해요\nlogDirection(\"DOWN\")\n```\n\nMatt Pocock와 Aaron이 이넘의 최악의 악몽을 설명하는 아주 좋은 비디오가 있어요. 이 비디오가 이 기사를 쓰게 된 동기가 되었죠.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n우리는 항상 enum을 사용하는 대신 간단한 객체와 어떤 종류의 매직을 사용해야 합니다. enum은 이해하기 쉽고 어떤 놀라움도 주지 않습니다.\n\nTypeScript는 OOP를 더 중시하기 위해 enum을 도입했지만, 제 생각에 그것은 좋은 결정이 아니었습니다.","ogImage":{"url":"/assets/img/2024-06-30-TypeScriptEnumsareTerrible_0.png"},"coverImage":"/assets/img/2024-06-30-TypeScriptEnumsareTerrible_0.png","tag":["Tech"],"readingTime":5},{"title":"useActionState  React의 새로운 Hook ","description":"","date":"2024-06-30 18:33","slug":"2024-06-30-useActionStateANewHookinReact","content":"\n\n<img src=\"/assets/img/2024-06-30-useActionStateANewHookinReact_0.png\" />\n\n안녕하세요 개발자 여러분 👋, 저는 Md Taqui Imam입니다. 오늘은 React의 새로운 흥미로운 훅인 useActionState에 대해 설명하려고 합니다.\n\n## useActionState란 무엇인가요?\n\nuseActionState는 폼 작업의 결과에 기반하여 상태를 업데이트하는 데 도움을 주는 새로운 React 훅입니다.\n\n<div class=\"content-ad\"></div>\n\n우리를 위해 기억하고 양식을 제출할 때 변경할 수 있는 스마트 도우미 같아요.\n\n공식 문서를 확인해보세요🚀\n\n## useActionState를 사용하는 방법은?\n\n이 훅을 사용하려면 먼저 React에서 가져와야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { useActionState } from 'react';\n```\n\n이제, 우리는 컴포넌트에서 다음과 같이 사용할 수 있어요:\n\n```js\nconst [state, formAction] = useActionState(actionFunction, initialState);\n```\n\n여기서 각 부분이 의미하는 바입니다:\n\n<div class=\"content-ad\"></div>\n\n- ‘state’은 현재 양식 상태입니다.\n- ‘formAction’은 양식에서 사용할 새로운 액션입니다.\n- ‘actionFunction’은 양식을 제출할 때 실행되는 함수입니다.\n- ‘initialState’은 상태의 초기값입니다.\n\n## useActionState를 사용하는 시기:\n\n이 훅을 사용하면 서버 구성 요소를 사용하며 더 빠른 응답을 원할 때 포르를 제출하여 상태를 업데이트할 때 사용하세요.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n간단한 카운터 양식을 useActionState를 사용하여 만들어봅시다:\n\n```js\nimport { useActionState } from \"react\";\n\nasync function increment(previousState, formData) {\n  return previousState + 1;\n}\n\nfunction StatefulForm() {\n  const [state, formAction] = useActionState(increment, 0);\n  return (\n    <form>\n      {state}\n      <button formAction={formAction}>Increment</button>\n    </form>\n  );\n}\n```\n\n이 예시에서 우리가 버튼을 클릭할 때마다 숫자가 하나씩 증가합니다. useActionState 훅이 양식이 제출될 때마다 상태를 업데이트하는 것을 관리해줘요.\n\n## 이게 전부에요 😅\n\n<div class=\"content-ad\"></div>\n\n기억하세요! 배우는 가장 좋은 방법은 경험하는 것입니다.\n\n그래서 useActionState가 보다 널리 사용 가능해지면, 여러분의 프로젝트에서 사용해보세요. 어떻게 양식을 개선할 수 있는지 확인해 보세요!\n\n코딩 즐기세요!\n\n[사진](/assets/img/2024-06-30-useActionStateANewHookinReact_1.png)","ogImage":{"url":"/assets/img/2024-06-30-useActionStateANewHookinReact_0.png"},"coverImage":"/assets/img/2024-06-30-useActionStateANewHookinReact_0.png","tag":["Tech"],"readingTime":2},{"title":"파이썬으로 GenAI 개발하기 최신 LLM과 RAG 완벽 튜토리얼","description":"","date":"2024-06-30 18:30","slug":"2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial","content":"\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png\" />\n\n이 기사에서는 개인 문서에서 지식을 효과적으로 학습하고 질문에 대답할 수 있는 간단한 AI를 구축하는 방법을 보여드리겠습니다.\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_1.png\" />\n\n## 소개\n\n<div class=\"content-ad\"></div>\n\n자연어 처리(NLP)는 기계와 인간 언어 간의 상호작용을 연구하는 인공 지능 분야입니다. 지금까지 NLP의 정점은 거대한 양의 텍스트 데이터로 훈련된 대형 언어 모델(LLM)의 등장이었습니다. LLM은 언어 패턴과 변형을 학습할 수 있는 능력을 갖추고 있습니다. \"언어 모델\"이라는 용어는 딥 러닝과 신경망의 발전과 함께 흔해졌습니다. 특히 2018년 구글이 Transformer 기반 아키텍처를 소개한 후에는 NLP 모델의 성능이 크게 향상되었습니다.(구글의 BERT 및 OpenAI의 GPT).\n\n오늘날 LLM은 일반적으로 텍스트 간 작업 또는 \"텍스트 생성\"(즉, 번역, 요약, 챗봇 및 가상 비서, 심지어 전체 책 작성)에 사용됩니다. 이를 통해 우리는 새로운 콘텐츠(텍스트, 이미지, 오디오, 비디오 등) 작성에 초점을 맞춘 산업 분야인 생성적 인공지능(GenAI)의 부상을 목격하고 있습니다.\n\n최신 LLM 풍경:\n\n- OpenAI의 ChatGPT, 가장 많이 사용됨 (여기서 시도해보기)\n- Anthropic의 Claude(여기서 시도해보기)\n- Google의 Gemini(여기서 시도해보기)\n- Meta의 Llama(여기서 시도해보기)\n- Microsoft의 Phi, 사용 가능한 모델 중 가장 작은 모델로 GPU 없이도 노트북에서 실행 가능(여기서 시도해보기)\n- StabilityAI의 StableLM\n- Cohere의 CommandR(여기서 시도해보기)\n- Snowflake의 Arctic(여기서 시도해보기)\n- Alibaba의 Qwen(여기서 시도해보기)\n- 01AI의 Yi\n- X의 Grok\n- NVIDIA의 Megatron\n- 아마존의 Olympus(아직 출시 예정)\n- Apple의 MM1(아직 출시 예정)\n\n<div class=\"content-ad\"></div>\n\nChatGPT은 가장 일반적으로 사용되는 LLM입니다. 그러나 회사들은 그것으로 업로드하기 어려운 문제가 있습니다. (대부분은 개인 정보 및 보안 상의 이유로) OpenAI에 민감한 데이터를 업로드할 수 없습니다. 따라서 회사들은 비공개 지식베이스에서 LLM의 파워를 활용하기 위해 내부 AI 서비스를 개발하고 있습니다. 이러한 종류의 작업을 검색 증강 생성(RAG)이라고 합니다. 이 기술은 외부 소스에서 가져온 지식 사실을 LLM에 추가하여 검색 및 생성 모델을 결합하는 방법입니다.\n\n조직 내에서, 지식 베이스는 일반적으로 다중 모달 콘텐츠(예: 텍스트, 이미지, 스프레드시트)를 포함한 문서로 구성되어 있으므로, 기계가 이해할 수 있도록 모든 것들을 처리하는 것이 가장 큰 도전입니다. 간단히 말해서, 먼저 모든 문서를 임베딩으로 변환한 다음 사용자 쿼리를 동일한 벡터 공간으로 변환하여 코사인 유사도 검색을 수행합니다.\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_2.png)\n\n이 자습서에서는 GPU 없이 일반 노트북에서 실행 가능한 LLMs 및 다중 모달 데이터를 사용하여 RAG 앱을 만들 것입니다. 다른 유사한 경우에 쉽게 적용할 수 있는 유용한 Python 코드 몇 가지를 제시하고 있으며 (그저 복사하여 붙여넣기하고 실행하면 됩니다), 각 코드 라인에 대한 설명을 포함하여 이 예제를 복제할 수 있도록 안내할 것입니다 (전체 코드에 대한 링크는 아래에 있습니다).\n\n<div class=\"content-ad\"></div>\n\n특히 다음을 살펴볼 것입니다:\n\n- 설정: Pdf2image로 데이터 가져오기, PyTesseract로 OCR 처리하기.\n- 전처리: Ollama를 사용하여 LLM으로 데이터를 보강하기.\n- 데이터베이스: ChromaDB로 데이터를 벡터로 저장하고 쿼리하기.\n- 백엔드: Ollama를 사용하여답변 생성하기.\n- 프론트엔드: Streamlit으로 사용자가 AI와 상호작용할 수 있는 인터페이스 구축하기.\n\n## 설정\n\n현실 세계에서 회사들은 대부분의 문서를 공유하기 전에 해당 형식으로 변환하는 PDF를 광범위하게 사용합니다. 또한 이미지, 테이블, 텍스트가 포함된 문서들이 많이 있어 좋은 사용 사례를 나타냅니다. 따라서 이 예제에서는 PDF 형식의 공개 회사의 재무 보고서를 데이터셋으로 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_3.png)\n\nPDF 문서를 처리하는 두 가지 대안적 방법이 있습니다: 텍스트로 읽거나 이미지로 구문 분석합니다. 둘 다 사용 사례에 따라 다르기 때문에 완벽하지는 않지만, OCR (광학 문자 인식) 기능이 더 잘 작동하는 경향이 있으므로 이를 사용하겠습니다.\n\n이 기사의 초점이 OCR에 있지는 않으며, 작동 방식에 대해 자세히 설명하는 데 너무 많은 시간을 할애하지는 않을 것입니다. 만약 해당 주제를 깊이 파고들고 싶다면, 이 기사를 확인하고 LayoutParser와 Unstructured 같은 고급 OCR 라이브러리를 사용해 보세요.\n\n우선 문서를 이미지로 변환해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n# conda install -c conda-forge poppler\nimport pdf2image #1.17.0\n\ndoc_img = pdf2image.convert_from_path(\"data/doc_nvidia.pdf\", dpi=300)\n\n# 예시로 한 페이지 출력\ndoc_img[35]\r\n\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_4.png\" />\n\n그런 다음, 페이지(이미지)에서 텍스트를 인식하겠습니다. 이를 위해 HP에서 1985년에 만들어진 주요 OCR 시스템 Tesseract를 사용하고 있으며 현재 Google에서 개발 중에 있습니다.\n\n\nimport pytesseract #0.3.10\n\ndoc_txt = []\nfor page in doc_img:\n    text = pytesseract.image_to_string(page)\n    doc_txt.append(text)\n\ndoc_txt[35]\r\n\n\n<div class=\"content-ad\"></div>\n\n![2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png)\n\n이제 우리는 생 텍스트를 가지고 있으니, 무엇보다 처리를 해야 할 것입니다. 우리는 언어 모델을 사용할 것입니다. 현재 여러 가지 대체 라이브러리들이 있어서 LLM의 힘을 활용할 수 있습니다: Ollama, HuggingFace, DSPy, LangChain. 제가 사용하는 Ollama는 강력하면서 사용하기 쉽습니다.\n\n먼저, 웹사이트에서 프로그램을 다운로드해야 합니다. 그런 다음, 명령 프롬프트에서 아래 명령을 입력하여 노트북에서 LLM을 실행합니다 (저는 Phi3와 LLaVa를 사용하고 있습니다):\n\n![2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png)\n\n<div class=\"content-ad\"></div>\n\n마지막으로, Python 라이브러리를 설치하면 끝입니다 (pip install ollama).\n\n## 전처리\n\n어떤 데이터 과학 프로젝트든 마찬가지로, 언제나 가장 어려운 부분은 데이터셋입니다. 머신러닝을 얼마나 많이 사용하더라도 데이터가 좋지 않다면 AI가 제대로 작동하지 않을 것입니다.\n\nLLM(대형 언어 모델)의 경우, 임베딩이 포함되어 있기 때문에 표준 플랙티스는 모든 것을 텍스트로 변환하는 것입니다. 가장 일반적인 다중모달 콘텐츠 (텍스트, 테이블, 이미지, 플롯)의 처리 방법을 보여드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n텍스트 — 문서는 서로 다른 구조와 레이아웃을 가질 수 있기 때문에 데이터 세트를 단락으로 분할해야 합니다. 원시 텍스트 외에도 제목, 태그, 링크와 같은 추가 정보를 활용하여 데이터를 보강할 수 있습니다. 이를 메타데이터 보강이라고 합니다.\n\n```js\n# 목차를 사용하여 단락에 태그 지정하기\ntitle_map = {\n    \"4-12\":\"비즈니스\",\n    \"13-33\":\"위험 요인\",\n    \"34-44\":\"재무\",\n    \"45-46\":\"이사\",\n    \"47-83\":\"데이터\"\n}\n\nlst_docs, lst_ids, lst_metadata = [], [], []\nfor n,page in enumerate(doc_txt):\n    try:\n        ## 제목 가져오기\n        title = [v for k,v in title_map.items() \n                 if n in range(int(k.split(\"-\")[0]), \n                               int(k.split(\"-\")[1])+1)][0]\n        ## 페이지 정리\n        page = page.replace(\"Table of Contents\",\"\")\n        ## 단락 가져오기\n        for i,p in enumerate(page.split('\\n\\n')):\n            if len(p.strip())>5:  ##<--단락 정리\n                lst_docs.append(p.strip())\n                lst_ids.append(str(n)+\"_\"+str(i))\n                lst_metadata.append({\"title\":title})\n    except:\n        continue\n\n\n## 예시 출력\nfor id,doc,meta in zip(lst_ids[375:378], \n                       lst_docs[375:378], \n                       lst_metadata[375:378]):\n    print(id, \"-\", meta, \"\\n\", doc, \"\\n\")\r\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_7.png\" />\n\n언어 모델을 사용한 메타데이터 보강은 문서 검색을 크게 향상시킬 수 있습니다. 예를 들어, 각 단락을 몇 가지 키워드로 요약하는 데 Phi3를 사용할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport ollama #0.2.1\n\ndef keyword_generator(p, top=3):\n    prompt = \"다음 단락을 3개의 키워드로 요약해주세요, 각각 ,로 구분: \"+p\n    res = ollama.generate(model=\"phi3\", prompt=prompt)[\"response\"]\n    return res.replace(\"\\n\",\" \").strip()\n\n\n## test\np = '''Professional artists, architects and designers use NVIDIA partner products accelerated with our GPUs and software platform for a range of creative and design\nuse cases, such as creating visual effects in movies or designing buildings and products. In addition, generative Al is expanding the market for our workstation-\nclass GPUs, as more enterprise customers develop and deploy Al applications with their data on-premises.'''\nprint(keyword_generator(p))\n```\n\n결과: “창의적 디자인, NVIDIA 파트너십, AI 확장”. 위와 같이 모든 단락에 적용하겠습니다:\n\n```js\nfrom tqdm.notebook import tqdm\n\nfor i,doc in tqdm(enumerate(lst_docs)):\n    lst_metadata[i][\"keywords\"] = keyword_generator(doc)\n\n## 예시 출력\nfor id,doc,meta in zip(lst_ids[375:378], \n                       lst_docs[375:378], \n                       lst_metadata[375:378]):\n    print(id, \"-\", meta, \"\\n\", doc, \"\\n\")\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_8.png\" />\n\n<div class=\"content-ad\"></div>\n\nTABLES - LLM(Large Language Model)는 순차 텍스트를 현저한 정확도로 처리할 수 있는 것으로 잘 알려져 있습니다. 그러나 이제 구조화된 데이터도 이해하기 시작했기 때문에 테이블은 일반 텍스트로 전달될 수 있습니다. 이를 다시 한번 확인해보겠습니다:\n\n```js\ntable = lst_docs[376]\nprint(\"테이블:\\n\", table)\n\nprompt = f\"다음 테이블을 요약해주세요: {table}\"\nres = ollama.generate(model=\"phi3\", prompt=prompt)[\"response\"]\n\nprint(\"\\n요약:\\n\", res)\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_9.png)\n\n이미지 - 이미지의 임베딩은 상당히 까다로울 수 있습니다(3D 배열의 차원을 벡터로 축소해야 함). 따라서 일반적인 실천 방법은 이미지를 설명하는 캡션을 생성하기 위해 AI를 사용하고 가능한 경우 정보를 텍스트로 처리하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom matplotlib import image, pyplot\n\nimage_file = \"data/image.jpeg\"\n\npyplot.imshow(image.imread(image_file))\npyplot.show()\n```\n\n![image](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_10.png)\n\nLLM을 위해 이미지를 문자열로 변환해야 합니다:\n\n```python\n## 이미지를 base64 문자열로 인코딩\nimport base64\n\ndef encode_image(path):\n    with open(path, \"rb\") as file:\n        return base64.b64encode(file.read()).decode('utf-8')\n\nimg = encode_image(image_file)\nimg[:1000]\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 테이블 태그를 Markdown 형식으로 변경한 예시입니다.\n\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_11.png\" />\n\n모델에 이미지 설명을 요청하는 문자열을 전달할 수 있습니다. 안타깝게도 Phi3은 시각 모델이 아니기 때문에 이 작업에 적합하지 않습니다:\n\n```js\nprompt = \"이미지를 설명해주세요\"\nres = ollama.generate(model=\"phi3\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_12.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n따라서 적절한 시각 모델을 구해야 합니다. Microsoft의 LLaVa는 GPU 없이도 실행할 수 있어 효율적인 선택입니다 (여기에서 시도해 보세요).\n\n```js\n## LLaVA\nprompt = \"이미지를 설명해주세요\"\nres = ollama.generate(model=\"llava\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_13.png\" />\n\nPLOTS — 이미지와 마찬가지로, 시각 모델은 플롯/차트를 읽고 요약할 수 있지만 결과가 정확하지는 않습니다. 예를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n이미지_파일 = \"data/plot.png\"\n\npyplot.imshow(image.imread(image_file))\npyplot.show()\n\nimg = encode_image(image_file)\n\nprompt = \"그래프와 같은 그림에 대해 구체적으로 설명해주세요.\"\nres = ollama.generate(model=\"llava\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_14.png\" />\n\n## 데이터베이스\n\n우리는 데이터를 벡터 데이터베이스에 저장할 수 있습니다. 이는 비구조적 데이터를 효율적으로 저장하고 색인화하고 검색하는 가장 좋은 해결책입니다. 요즘 가장 많이 사용되는 벡터 데이터베이스는 Microsoft의 AISearch입니다. 최고의 오픈 소스 도구는 유용하고 쉽고 무료인 ChromaDB입니다.\n\n<div class=\"content-ad\"></div>\n\n빠르게 \"pip install chromadb\"를 입력하면 Python을 사용하여 세 가지 다른 방법으로 db와 상호 작용할 수 있습니다:\n\n- chromadb.Client()는 디스크 공간을 차지하지 않고 메모리에 일시적으로 유지되는 db를 만듭니다.\n- chromadb.PersistentClient(path)는 로컬 기계에서 db를 저장하고 로드합니다.\n- chromadb.HttpClient(host='localhost', port=8000)는 브라우저에서 클라이언트-서버 모드를 사용할 수 있습니다.\n\nChromaDB에 문서를 저장할 때 데이터는 벡터로 저장되어 일치하는 레코드를 검색할 때 쿼리 벡터를 사용할 수 있습니다. 참고로, 그렇게 명시하지 않으면 기본 임베딩 방법은 문장 변환 모델 (all-MiniLM-L6-v2)입니다.\n\n```js\nimport chromadb #0.5.0\n\ndb = chromadb.PersistentClient()\n\ncollection_name = \"nvidia\"\ncollection = db.get_or_create_collection(name=collection_name, \n               embedding_function=chromadb.utils.embedding_functions.DefaultEmbeddingFunction())\n\ncollection.add(documents=lst_docs, ids=lst_ids, metadatas=lst_metadata, \n               images=None, embeddings=None)\ncollection.peek(1)\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_15.png\" />\n\n어떤 것을 쿼리해보세요:\n\n```js\nquery = \"수익은 얼마인가요?\"\ncollection.query(query_texts=[query])\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_16.png\" />\n\n<div class=\"content-ad\"></div>\n\n쿼리가 동일한 벡터 공간에 포함되어 있고 ChromaDB가 가장 가까운 문서를 검색했습니다. 그들을 결합해서 db에서 최종 응답을 얻을 수 있습니다:\n\n```js\nres_db = collection.query(query_texts=[query])[\"documents\"][0][0:10]\ncontext = ' '.join(res_db).replace(\"\\n\", \" \")\ncontext\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_17.png)\n\ndb 응답은 컨텍스트로 사용될 수 있으며, 이는 LLM이 저장하고 액세스할 수 있는 소량의 정보 세트입니다. 프롬프트를 사용하여 모델이 컨텍스트 내 정보만 사용할지 훈련 중에 학습한 지식도 사용해야 하는지 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# Context만으로 대화하기\nres = ollama.chat(model=\"phi3\", \n                  messages=[{\"role\":\"system\", \"content\":\"다음 정보만을 사용하여 가장 정확한 답변을 제공하세요: \\n\"+context},\n                            {\"role\":\"user\", \"content\":query}])\nprint(res[\"message\"][\"content\"])\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_18.png)\n\n또는 모델의 지식을 추가하여:\n\n```js\n# 지식 및 Context로 대화하기\nres = ollama.chat(model=\"phi3\", \n                  messages=[{\"role\":\"system\", \"content\":\"귀하의 지식과 다음 추가 정보를 사용하여 가장 정확한 답변을 제공하세요: \\n\"+context},\n                            {\"role\":\"user\", \"content\":query}])\nprint(res[\"message\"][\"content\"])\n``` \n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_19.png)\n\n데이터베이스가 설정되어 정상적으로 작동 중입니다. 다음 단계로 진행하여 문서에 관한 질문을 할 수 있는 챗봇 앱을 만들 수 있습니다.\n\n## 프론트엔드\n\n요즘 가장 많이 사용되는 Python 라이브러리인 Streamlit은 NLP 애플리케이션 개발을 간편하게 만들어주는 스트리밍 기능으로 알려져 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 먼저 레이아웃을 정의해 봅시다: 화면에는 사용자가 채팅 기록을 볼 수 있는 사이드바가 있기를 원합니다.\n\n```python\nimport streamlit as st #1.35.0\n\n## 레이아웃\nst.title('💬 궁금한 점을 적어주세요')\nst.sidebar.title(\"채팅 기록\")\napp = st.session_state\n\nif \"messages\" not in app:\n    app[\"messages\"] = [{\"role\":\"assistant\", \"content\":\"정보를 검색할 준비가 되어 있습니다.\"}]\n\nif 'history' not in app:\n    app['history'] = []\n\nif 'full_response' not in app:\n    app['full_response'] = '' \n```\n\n앱 객체(또는 session_state)는 다음과 같은 구조를 갖는 딕셔너리입니다:\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_20.png)\n\n<div class=\"content-ad\"></div>\n\n만약 채팅에서 메시지가 사라지는 것을 원하지 않는다면, 다음 코드를 추가하세요:\n\n```js\n## 채팅 메시지 유지\nfor msg in app[\"messages\"]:\n    if msg[\"role\"] == \"user\":\n        st.chat_message(msg[\"role\"], avatar=\"😎\").write(msg[\"content\"])\n    elif msg[\"role\"] == \"assistant\":\n        st.chat_message(msg[\"role\"], avatar=\"👾\").write(msg[\"content\"])\n```\n\n이제 채팅 코어를 코드화해야 합니다: 사용자의 질문은 메시지 목록에 추가되어 AI로 전달되고, 앱은 응답을 스트리밍할 것입니다.\n\n```js\n## 채팅\nif txt := st.chat_input():\n    ### 사용자 입력\n    app[\"messages\"].append({\"role\":\"user\", \"content\":txt})\n    st.chat_message(\"user\", avatar=\"😎\").write(txt)\n\n    ### AI가 채팅 스트림으로 응답\n    app[\"full_response\"] = \"\"\n    st.chat_message(\"assistant\", avatar=\"👾\").write_stream( xxx ) )\n    app[\"messages\"].append({\"role\":\"assistant\", \"content\":app[\"full_response\"]})\n    \n    ### 사이드바 히스토리 보여주기\n    app['history'].append(\"😎: \"+txt)\n    app['history'].append(\"👾: \"+app[\"full_response\"])\n    st.sidebar.markdown(\"<br />\".join(app['history'])+\"<br /><br />\", unsafe_allow_html=True)\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 사용자 질문에 응답하는 기능을 완성한 후 \"xxx\"로 대체할 자리 표시자를 삽입했습니다. 앱을 실행하면 다음과 같이 보입니다:\n\n![앱 실행 화면](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_21.png)\n\n## 백엔드\n\n우리는 이미 이 부분에 익숙합니다. 이것을 클래스 내에 넣기만 하면 됩니다. 강조할 몇 가지 포인트가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- ChromaDB에서 컬렉션 이름을 호출하면, 이미 존재하는 경우 db는 새로 만들지 않고 \"가져오게\" 됩니다.\n- Ollama 채팅 기능의 스트리밍 매개변수는 (stream=True)로 전환하여 완전한 응답 대신 텍스트 청크를 반환합니다.\n- LLM을 호출할 때마다 이전 메시지에 대한 참조를 이해할 수 있도록 전체 채팅 기록을 입력으로 전달합니다.\n\n```js\nimport chromadb #0.5.0\nimport ollama  #0.5.0\n\nclass AI():\n def __init__(self):\n  db = chromadb.PersistentClient()\n  self.collection = db.get_or_create_collection(\"nvidia\")\n\n def query(self, q, top=10):\n  res_db = self.collection.query(query_texts=[q])[\"documents\"][0][0:top]\n  context = ' '.join(res_db).replace(\"\\n\", \" \")\n  return context\n\n def respond(self, lst_messages, model=\"phi3\", use_knowledge=False):\n  q = lst_messages[-1][\"content\"]\n  context = self.query(q)\n\n  if use_knowledge:\n   prompt = \"Give the most accurate answer using your knowledge and the folling additional information: \\n\"+context\n  else:\n   prompt = \"Give the most accurate answer using only the folling information: \\n\"+context\n\n  res_ai = ollama.chat(model=model, \n        messages=[{\"role\":\"system\", \"content\":prompt}]+lst_messages,\n                      stream=True)\n  for res in res_ai:\n   chunk = res[\"message\"][\"content\"]\n   app[\"full_response\"] += chunk\n   yield chunk\n\nai = AI()\n```\n\nStreamlit 앱을 실행하려면 다음 명령을 사용해야 합니다: streamlit run rag_app.py\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*C722wXvi4JCn3OrN8TbLLA.gif\" />\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n본 글은 Python과 LLMs를 사용하여 RAG 앱을 만드는 방법을 보여주는 튜토리얼이었습니다. 우리는 언어 모델을 사용하여 멀티모달 콘텐츠를 처리하고, 그 데이터를 벡터 데이터베이스에 저장했습니다. ChatGPT와 비슷한 AI가 우리의 질문에 답변할 때 사용하는 데이터베이스입니다. 마지막으로 모델과 채팅할 수 있는 사용자 친화적인 인터페이스를 만들었습니다.\n\n즐겁게 즐겼으면 좋겠습니다! 질문이나 피드백이 있으시면 언제든지 저에게 연락해 주시거나 귀하의 흥미로운 프로젝트를 공유해 주세요.","ogImage":{"url":"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png"},"coverImage":"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png","tag":["Tech"],"readingTime":16},{"title":"OAuth는 삶을 쉽게 만들어 준다 사용 방법, 이점 및 실전 예제","description":"","date":"2024-06-30 18:28","slug":"2024-06-30-OAuthMakesLifeEasy","content":"\n\n저와 같이 기술의 발전으로 게으를 갖고 있는 분이세요? 솔직히 말씀드리자면, 스트레스 받을 건 전혀 가망이 없죠. 보안은 기술에서 매우 중요한 측면이며, 진지하게 고려해야 합니다. 그러나 솔직히 말해요, 우리 중 얼마나 많은 사람들이 안전한 암호를 생성하고 안전하게 보관하는 필요한 단계를 취하는 것을 선호할까요? 이 세대의 기술 사용자들은 그래 할 만큼 게으르죠.\n\n이전에 사람들이 일반적으로 했던 방식은 하나의 강력한 암호를 생성하여 모든 웹 사이트에 사용하는 것이었습니다. 그러나 한 사이트가 침해당한다면, 암호가 노출됩니다. 중요한 사람인 경우, 해커들은 그를 활용하여 소셜 미디어에 로그인할 수 있습니다. 만약 은행 앱에도 같은 암호를 사용하는 무모한 짓을 하려한다면? — \"Otilor\"(요르바어로 \"사라졌거나 망했다\"는 뜻)입니다.\n\n그렇다면, 저와 같이 게으른 사람들에게 좋은 대안은 무엇일까요? 그 대답은 OAuth(Open Authorization)입니다.\n\nOAuth(Open Authorization)란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nOAuth은 Google, Facebook 또는 GitHub과 같은 신뢰할 수 있는 플랫폼을 사용하여 인증할 수 있도록 합니다. 이러한 대표적인 사이트들은 보안에 수십억을 투자하고 있습니다. 만약 해커가 Google 또는 Facebook을 성공적으로 해킹할 수 있다면, 나의 계정을 해킹해도 된다고 생각할 수도 있겠지만, 그건 농담이에요. 하지만 사실은 이들에게 우리의 보안을 맡길 수 있다는 것이죠. 그래서 내가 해야 할 일은 구글에 로그인하는 것 뿐이에요. 적어도 그건 하나의 비밀번호일 뿐이니까, 이건 안전하게 지킬 수 있어야겠죠.\n\n구글, Facebook 또는 GitHub에 로그인한 후, 다른 웹사이트에게 내 이름, 프로필 사진 및 계정에서 사용 가능한 기타 정보와 같은 몇 가지 사용자 정보에 대한 접근 권한을 부여할 수 있어요. 이렇게 하면 해당 웹사이트가 나의 인증을 수행할 수 있어요.\n\nOAuth 유형\n\n더 나아가기 전에, Open Authorization에는 OAuth 1.0과 OAuth 2.0 두 가지 유형이 있다는 것을 간략히 언급하고 싶어요. 오늘날 가장 일반적으로 사용되는 버전인 OAuth 2.0은 더 간단하고 유연성이 더 높은 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n2. 필요한 npm 패키지를 설치해주세요:\n\n\nnpm install express passport passport-google-oauth20 express-session\n\n\n3. index.js 파일을 만들고 Express 애플리케이션을 설정해주세요:\n\n```javascript\nconst express = require('express');\nconst passport = require('passport');\nconst GoogleStrategy = require('passport-google-oauth20').Strategy;\nconst session = require('express-session');\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\nconst app = express();\n\napp.use(session({\n    secret: 'your_secret_key', // Replace with a secure key\n    resave: false,\n    saveUninitialized: true\n}));\n\napp.use(passport.initialize());\napp.use(passport.session());\n\n// Configure Passport to use Google OAuth\npassport.use(new GoogleStrategy({\n    clientID: 'YOUR_GOOGLE_CLIENT_ID',\n    clientSecret: 'YOUR_GOOGLE_CLIENT_SECRET',\n    callbackURL: 'http://localhost:3000/auth/google/callback'\n},\nfunction(token, tokenSecret, profile, done) {\n    return done(null, profile);\n}));\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\npassport.serializeUser((user, done) => {\n  done(null, user);\n});\n\npassport.deserializeUser((obj, done) => {\n  done(null, obj);\n});\n\n// Define routes\napp.get('/auth/google',\n  passport.authenticate('google', { scope: ['profile'] }));\n\napp.get('/auth/google/callback',\n  passport.authenticate('google', { failureRedirect: '/' }),\n  (req, res) => {\n    res.redirect('/');\n  });\n```\n\n<div class=\"content-ad\"></div>\n\n\napp.get('/', (req, res) => {\n  res.send(`<h1>Home</h1><a href=\"/auth/google\">Login with Google</a>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});\n\n4. Start your Node.js server with “node index.js”. Open your browser and go to http://localhost:3000. Click on \"Login with Google\" to start the OAuth process.\n\nTo get the Google Client ID and Secret, follow these steps:\n\n\n<div class=\"content-ad\"></div>\n\n- Google Cloud Console로 이동하세요.\n- 새 프로젝트를 만들거나 기존 프로젝트를 선택하세요.\n- API 및 서비스 `자격 증명` 페이지로 이동하세요.\n- `자격 증명 만들기`를 클릭하고 OAuth 클라이언트 ID를 선택하세요.\n- 필수 필드를 작성하여 동의 화면을 구성하세요.\n- 애플리케이션 유형으로 웹 애플리케이션을 선택하세요.\n- http://localhost:3000/auth/google/secrets와 같은 승인된 리디렉션 URI를 추가하세요.\n- 생성을 클릭하여 클라이언트 ID 및 시크릿을 가져오세요.\n\n![OAuthMakesLifeEasy](/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png)\n\n만약 기술에 미숙하다면, 위의 기술 용어에 머리 아프지 마세요. 다음에 \"Google로 가입\"을 보면 안전하니 그냥 사용하세요. 요약하면 이렇습니다. 어쩌다 이런 글을 써야 했네요. HNG 인턴십은 나이지리아와 아프리카의 떠오르는 기술인들에게 흥미로운 기회입니다. HNG 웹사이트를 통해 HNG 인턴십, HNG 채용, 또는 HNG 프리미엄을 확인할 수 있습니다. 안녕히 가세요!","ogImage":{"url":"/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png"},"coverImage":"/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png","tag":["Tech"],"readingTime":4}],"page":"4","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}