{"pageProps":{"posts":[{"title":"리액트 19의 새로운 기능 - 새로운 리액트 훅","description":"","date":"2024-05-12 21:07","slug":"2024-05-12-NewFeaturesinReact19NewReactHooks","content":"\n\n🚀 React 19의 새로운 시대를 탐험하다: 혁명적인 훅의 일단 봐 🌟\n\n![이미지](/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png)\n\n안녕하세요, React 팬 여러분! 우리의 컴포넌트와 상호 작용하는 방법을 재정의할 새로운 훅이 등장하는 React 19의 미래로 여행을 떠나 봅시다. React Hooks의 팬이라면, 놀라운 일이 기다리고 있어요!\n\nReact Hooks의 진화:\n\n\n\n리액트 훅스는 처음 소개된 이후로 게임 체인저 역할을 했어요. 상태 관리와 라이프사이클 메서드를 간편하게 만들어주죠. 만약 리액트의 내장 훅을 사용하거나 사용자 정의 훅을 만들었다면, 당신의 애플리케이션에 가져다주는 힘과 유연성을 고맙게 느낄 거예요.\n\n리액트 19에서는 useMemo, forwardRef, useEffect, useContext의 사용 방법이 바뀔 거에요. 이는 새로운 훅, use가 소개되기 때문이죠.\n\nuseMemo()로 간단한 메모이제이션:\n\n주목할만한 변경 중 하나는 useMemo() 훅의 단순화입니다. 리액트 19 이후에는 useMemo()을 명시적으로 사용할 필요가 없어요. 새 리액트 컴파일러가 메모이제이션을 자동으로 처리할 거예요. 이는 더 깨끗한 코드와 향상된 성능을 가져다줘요. 아래 예시에서 보여드릴게요:\n\n\n\nReact 19 이전:\n\n```js\nimport React, { useState, useMemo } from 'react';\n\nfunction ExampleComponent() {\n  const [inputValue, setInputValue] = useState('');\n\n  // 입력 값이 비어 있는지 확인 결과를 메모이제이션합니다\n  const isInputEmpty = useMemo(() => {\n    console.log('입력 값이 비어 있는지 확인 중...');\n    return inputValue.trim() === '';\n  }, [inputValue]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      />\n      <p>{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}</p>\n    </div>\n  );\n}\n\nexport default ExampleComponent;\n```\n\nReact 19 이후:\n\n```js\nimport React, { useState } from 'react';\n\nfunction ExampleComponent() {\n  const [inputValue, setInputValue] = useState('');\n\n  const isInputEmpty = () => {\n    console.log('입력 값이 비어 있는지 확인 중...');\n    return inputValue.trim() === '';\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      />\n      <p>{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}</p>\n    </div>\n  );\n}\n\nexport default ExampleComponent;\n```\n\n\n\n아래 예제에서 확인할 수 있듯이 React19 이후에는 값에 memo를 적용할 필요가 없습니다. React19에서는 이 기능을 자체적으로 처리합니다. 코드가 훨씬 깔끔해졌죠.\n\nforwardRef()로 리팩터링:\n\nReact 19에서 forwardRef()를 사용하는 컴포넌트를 리팩터링하는 것은 간단해졌습니다. forwardRef()를 사용하는 대신 ref를 직접 속성으로 전달할 수 있으며, 코드의 복잡성을 줄일 수 있습니다:\n\n```js\n// React 19 이전\nconst ExampleButton = forwardRef((props, ref) => (\n  <button ref={ref}>\n    {props.children}\n  </button>\n));\n\n// React 19 이후\nconst ExampleButton = ({ ref, children }) => (\n  <button ref={ref}>\n    {children}\n  </button>\n);\n```\n\n\n\n새로운 'use' Hook을 소개합니다:\n\nReact 19에서 가장 흥미로운 추가 기능은 'use' 훅인데요, 이를 통해 우리는 약속, 비동기 코드 및 컨텍스트를 다루는 방법을 단순화할 수 있습니다. 이 훅은 다음 예시에서 보여지는 것처럼 더 깔끔하고 간결한 코드를 작성할 수 있습니다:\n\n```js\nconst users = use(fetchUsers());\n```\n\n'use' 훅을 통해 비동기 작업 및 컨텍스트를 처리하는 새로운 가능성을 엽니다.\n\n\n\n아래 코드는 fetch 요청이 ne \"use\" 훅과 함께 처리되는 방법을 보여줍니다.\n\n```js\nimport { use } from \"react\";\n\nconst fetchUsers = async () => {\n    const res = await fetch('https://jsonplaceholder.typicode.com/users');\n    return res.json();\n};\n\nconst UsersItems = () => {\n    const users = use(fetchUsers());\n\n    return (\n        <ul>\n            {users.map((user) => (\n                <div key={user.id} className='bg-blue-50 p-2 my-4 rounded-lg'>\n                    <h2 className='text-xl font-bold'>{user.name}</h2>\n                    <p>{user.email}</p>\n                </div>\n            ))}\n        </ul>\n    );\n};\n\nexport default UsersItems;\n```\n\n이 코드는 다음과 같은 방식으로 작동합니다: fetchUsers 함수가 GET 요청을 처리합니다.\nuse 훅을 사용하여 fetchUsers 함수를 실행합니다. useEffect나 useState 훅을 사용하는 대신에 사용합니다.\nuseState 훅의 반환값은 사용자가 될 것이고, 이는 GET 요청의 응답(사용자)을 갖게 됩니다.\nreturn 블록에서는 사용자를 사용하여 매핑하고 목록을 생성합니다.\n\n새로운 훅을 사용할 수 있는 다른 곳은 Context입니다. React에서 Context API는 외부 상태 관리 라이브러리를 필요로하지 않고 컴포넌트 전체에서 전역 상태를 효과적으로 관리하는 강력한 방법을 제공합니다. use 훅의 도입으로 Context 작업이 더욱 간단해졌습니다.\n\n\n\n표 태그를 마크다운 형식으로 변경하세요.\n\n\n\n두 번째 예시는 테이블 태그가 아닌 HTML5로 렌더링된 SVG이미지를 사용하는 방법입니다. HTML5의 캔버스 요소를 사용하여 그래픽을 생성하고 작업할 수 있습니다. 이 예시에서는 표시되는 SVG이미지와 사용된 JavaScript 코드를 확인할 수 있습니다.\n\n\n\n```js\nconst { status } = useFormStatus()\n```\n\npending: Form이 보류 상태에 있으면 true가 되고, 그렇지 않으면 false가 됩니다.\ndata: parent `form`이 제출하는 데이터가 포함된 FormData 인터페이스를 구현한 객체입니다.\nmethod: HTTP 메소드 — GET 또는 POST. 기본적으로 GET일 것입니다.\naction: 함수 참조\n\nuseFormStatus()를 사용하여 Form 제출 상태에 따라 UI를 업데이트하는 반응형 Form을 만들 수 있습니다.\n\n다음은 코드 예시입니다:\n\n\n\n```js\nimport { useFormStatus } from \"react-dom\";\n\nfunction Submit() {\n  const status = useFormStatus();\n  return <button disabled={status.pending}>{status.pending ? '제출 중...' : '제출'}</button>;\n}\n\nconst formAction = async () => {\n  // 2초 지연 시뮬레이션\n  await new Promise((resolve) => setTimeout(resolve, 3000));\n}\n\nconst FormStatus = () => {\n  return (\n    <form action={formAction}>\n      <Submit />\n    </form>\n  );\n};\n\nexport default FormStatus;\n```\n\n위의 코드에서, 폼을 제출하면 useFormStatus 훅에서 보류 상태를 가져옵니다. 보류 중일 때 UI에 \"제출 중...\"이라는 텍스트가 표시됩니다. 보류가 false가 되면 \"제출\"으로 텍스트가 변경됩니다.\n\nuseFormState() 훅\n\nuseFormState() 훅을 사용하면 폼 제출 결과를 기반으로 상태를 업데이트할 수 있습니다. 이는 특히 폼의 결과에 따라 UI 요소를 업데이트하거나 동작을 트리거하는 데 유용합니다:\n\n\n\n\n여기가 문법입니다:\n\n```js\nconst [state, formAction] = useFormState(fn, initialState, permalink?);\n```\n\nfn: 폼이 제출되거나 버튼이 눌릴 때 호출되는 함수입니다.\ninitialState: 상태가 초기에 가질 값입니다. 직렬화 가능한 값이어야 합니다. 이 인수는 처음 액션이 호출된 후 무시됩니다.\npermalink: 옵션입니다. fn이 서버에서 실행될 경우 페이지가 permalink으로 리디렉트됩니다.\n\n이 훅은 반환할 것입니다:\n\n\n\n초기 상태: initialState로 전달한 값이 초기 상태로 설정됩니다.\nformAction: 폼 액션으로 전달될 액션입니다. 이 값의 반환값이 상태에서 사용 가능합니다.\n\nuseFormState()를 사용하면 복잡한 상태 관리 로직 없이 폼 상태를 쉽게 관리하고 폼 제출에 기반한 작업을 수행할 수 있습니다.\n\nuseOptimistic() 훅:\n\nuseOptimistic() 훅을 사용하면 비동기 작업이 진행 중일 때 다른 상태를 표시하여 더 반응성 있는 사용자 경험을 제공할 수 있습니다. 요청이 성공할 것이라 가정하고 즉시 UI를 업데이트하여 서버로부터 응답을 받기 전에도 UI가 갱신됩니다.\n\n\n\n여기 문법이에요:\n\n```js\nconst [ optimisticMessage, addOptimisticMessage] = useOptimistic(state, updatefn)\n```\n\n예를 들어, 응답이 오는 중일 때 사용자에게 즉각적인 응답을 제공하기 위해 \"상태\"를 표시할 수 있어요. 실제 응답이 서버로부터 반환되면 \"낙관적\" 상태가 그것으로 대체될 거예요.\n\n`useOptimistic` 훅은 요청이 성공할 것으로 가정하고 즉시 UI를 업데이트할 거예요. 이름이 \"낙관적\"인 이유는 사용자가 작업을 수행하는 낙관적(성공) 결과를 보게 되지만 실제 작업 완료까지 시간이 걸리기 때문이에요.\n\n\n\nuseOptimistic()을 사용하면 양식의 인지 성능을 향상시키고 사용자에게 즉각적인 피드백을 제공할 수 있습니다.\n\n다음 섹션에서는 useOptimistic 훅의 실제 구현에 대해 실제 예제로 자세히 살펴보겠습니다. 코드 실습과 즐거운 코딩을 기대해주세요!! 🚀\n\n관련 링크\n\nReact 19의 새로운 기능\n\n\n\nReact 19의 새로운 기능 — React 컴파일러\n\nReact 19의 새로운 기능 — 서버 컴포넌트\n\nReact 19의 새로운 기능 — 액션\n\nReact 19의 새로운 기능 — 웹 컴포넌트\n\n\n\nReact 19의 새로운 기능 — 문서 메타데이터\n\nReact 19의 새로운 기능 — 자산 로딩","ogImage":{"url":"/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png"},"coverImage":"/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png","tag":["Tech"],"readingTime":7},{"title":"12부 setTimeout  클로저 인터뷰 문제 ","description":"","date":"2024-05-12 21:06","slug":"2024-05-12-Part12setTimeoutClosuresInterviewQuestions","content":"\n\n# 사전 준비 사항:\n\n만약 클로저(Closures) 개념이 잘 이해되지 않는다면, 아래 내용을 꼭 읽어보세요:\n\n- Part 11: 자바스크립트(JS)에서의 클로저(Closures) 🤷🏻‍♀️\n\n![이미지](/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png)\n\n\n\n## 이 프로그램을 실행하면 콘솔에서 무엇을 기대하시나요?\n\n출력:\n\n![Output](/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_1.png)\n\n1초 후에 i의 값인 1이 출력됩니다.\n\n\n\n아래와 같이 시간 초가 지난 후 출력이 됩니다.\n\nsetTimeout()을 사용하면 3초 후에 i를 출력한 다음 \"Learn\"을 출력할 것으로 생각할 수 있습니다. 하지만, 그렇지 않습니다. \"Learn\"을 먼저 출력하고 3초를 기다린 후 i의 값을 출력할 것입니다.\n\n## setTimeout()이 실제로 하는 일은 무엇인가요?\n\n- 3줄에서, function ()이 클로저를 형성합니다. 이 함수는 i에 대한 참조를 기억합니다.\n- setTimeout()은 해당 콜백 함수를 실행하고 어딘가에 저장하고 타이머를 부착합니다. JS는 다음 줄로 진행합니다.\n- 타이머가 만료되면 해당 함수를 가져와서 호출 스택에 넣고 실행합니다.\n\n\n\n다음은 복잡한 문제의 예를 살펴보겠습니다.\n\n## 콘솔에 1부터 10까지의 숫자를 매 초마다 출력하려고 합니다. 즉, 1초 후에 1을, 2초 후에 2를, 그리고 3초 후에 3을 출력하는 방식입니다. 이를 어떻게 해결할 수 있을까요?\n\n첫 번째 떠오르는 해결책은 for 루프를 사용하고 그 안에 setTimeout()을 넣는 것입니다. 아래와 같이 말이죠?\n\n이제 결과를 확인해 보겠습니다:\n\n\n\n<img src=\"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_2.png\" />\n\n이건 우리가 기대했던 것과 다릅니다. 왜 그런 건가요? 무슨 일이 있었나요? 🧐\n\n두 가지 이유가 있어요:\n\n1. 우리는 클로저가 함수와 그 렉시컬 환경이 어떻게 동작하는지 배웠거든. 그래서 함수가 자신의 원래 범위에서 벗어나더라도 여전히 자신의 원래 범위를 기억할 거에요. 클로저는 렉시컬 범위의 변수에 접근할 수 있어요.\n\n\n\n그래서 setTimeout()이 이 함수를 취하고 어딘가에 저장하고 타임아웃을 부착하면, i에 대한 참조를 기억합니다.\n\n따라서 루프가 처음 실행될 때, 함수의 복사본을 만들어 타이머를 부착하고 i에 대한 참조를 기억합니다.\n\n마찬가지로, 모든 10개의 함수 복사본은 i에 대한 참조를 기억하고 있으며, 값이 아닙니다. 그리고 모두 같은 i에 대한 참조를 가리키고 있습니다.\n\n## 왜 젠장 같은 i에 대한 참조를 가리키고 있는 걸까요? 😳\n\n\n\n모든 이러한 기능들의 환경은 같기 때문이에요. setTimeout()의 콜백 함수 복사본들은 모두 같은 메모리 공간에서 i를 참조하고 있어요. 🤷🏻‍♀️\n\n2. JS는 아무것도 기다리지 않아요. 그래서 루프가 계속 실행될 거예요 🔄. 그래서 setTimeout()은 모든 10개의 함수를 저장하고 JS는 계속 진행할 거예요. JS는 타이머가 만료되기를 기다리지 않아요. \"Learn\"을 출력하고, 타이머가 만료되면 이미 너무 늦어요. 이제 i의 값이 변경되었어요. 왜냐하면 루프가 계속 실행되었으니까요. 이 콜백 함수가 실행될 때에는 이미 메모리 위치에 var i = 11의 값이 되어 있어요.\n\n그래서 매번 11이 출력되는 거죠 🤷🏻‍♀️. 왜냐하면 이러한 콜백 함수 복사본들이 모두 같은 메모리 위치를 참조하기 때문이에요 🤦🏻‍♀️. 해당 위치는 이제 10번 실행되었고 루프에서 값이 1씩 증가했기 때문에 11이 되었답니다 🙄.\n\n## 이제, 어떻게 이 문제를 해결할 수 있을까요? 💡💡\n\n\n\nlet 대신 var 대신 사용하세요. 왜냐하면 let은 블록 범위를 가지고 있기 때문에 각각의 반복에서 i는 매번 새로운 변수가 됩니다. 메모리에는 매번 i의 새 복사본이 있습니다. \n\nsetTimeout()이 실행될 때, 콜백 함수는 새로운 i의 복사본을 가질 것입니다. \n\n실행해보고 결과를 확인해봅시다:\n\n<img src=\"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_3.png\" />\n\n잘 작동했어요 🎉🎉\n\n\n\n## 다시 한 번 수정해 봅시다. let 키워드 때문에 실제로 일어난 일에 대해:\n\n1. i = 1로 시작한 루프에서, 함수가 자체적으로 새 변수와 클로저를 형성했습니다.\n2. i++ 이후에 함수가 다시 클로저를 형성했을 때, 값이 2인 새 변수를 가지고 있으며 이를 저장했습니다.\n3. 이런 식으로 계속 진행됩니다. 이렇게 하면 변수 i의 10개의 복사본을 만들어 각 함수마다 클로저를 형성합니다.\n\n## 그래서, 다음에 누군가 아래 두 경우의 출력 차이와 그 이유에 대해 물으면? 당신은 답을 알고 있습니다 😎\n\n## 경우 1:\n\n\n\n```js\nfunction x(){\n  for (var i = 1; i <= 10; i++){  // 이 부분에서 var을 사용했어요 \n    setTimeout(function (){\n    console.log(i);\n    }, i * 1000);\n  }\n  console.log(\"배워요\")\n}\nx();\r\n```\n\n## Case 2:\n\n```js\nfunction x(){\n  for (let i = 1; i <= 10; i++){  // 이 부분에서 let을 사용했어요 \n    setTimeout(function (){\n    console.log(i);\n    }, i * 1000);\n  }\n  console.log(\"배워요\")\n}\nx();\r\n```\n\nAnswer: let은 블록 스코프이며 루프가 실행될 때마다 매번 새로운 복사본을 생성합니다.\n\n\n\n## 다시 뒤로 돌아가기 🤭: 만약 var만 사용하고 매 초 1,2,3,..10을 출력해야 한다면 어떻게 해야 할까요? \n\n조금만 생각해 보세요. 어떤 해결책이 될 수 있을까요?\n요령은 매번 변수 i의 새 복사본을 만들어야 한다는 것입니다.\n\n그래서, 새로운 함수 close()를 만들고 그 안에 setTimeout()을 랩핑합니다. 그리고 호출할 때마다 i를 전달합니다.\n\n## 왜 이 방법이 동작할까요? 😬\n\n\n\n매번 i와 함께 close() 함수를 호출할 때마다 setTimeout()을 위한 새로운 i 복사본이 생성된다고 해요 😎.\n\n그게 전부에요. setTimeout()이 어떻게 작동하는지와 클로저랑 어떻게 연관되는지 다루었어요. 👏🏼\n\n## 다음 👩🏻‍🏫 ⏭️ : 제13부 : 클로저 JS 인터뷰 질문들 🤯\n\n이 기사를 읽어 주셔서 감사합니다 ❤️\n\n\n\n# ⭐️ 즐겁게 코딩해요. ⭐️\n\n오늘 무엇인가를 배웠으면 좋겠네요! 떠나시기 전에:\n\n- 👏 스와티 레드후를 따르고 스토리에 박수를 보내주세요 👩🏻‍💻\n- 📰 2023 자바스크립트 학습 로드맵에서 더 많은 콘텐츠를 확인해보세요 — 최고의 안내서 ❤️\n- 🔔 LinkedIn을 팔로우해주세요\n\n🚀👉 자바스크립트 기본을 확실히 다지고 멋진 직장을 찾아보세요","ogImage":{"url":"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png","tag":["Tech"],"readingTime":4},{"title":"React에서 Axios를 사용하여 중앙 집중식 API 클라이언트 파일 만들기","description":"","date":"2024-05-12 21:05","slug":"2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios","content":"\n\n리액트 애플리케이션을 구축할 때 API와 상호 작용하는 경우, API 호출을 처리하는 깔끔하고 조직화된 방식을 유지하는 것이 중요합니다. 이를 달성하는 효과적인 방법 중 하나는 중앙 집중식 API 클라이언트 파일을 생성하는 것입니다. 이 튜토리얼에서는 Axios를 사용하여 이러한 파일을 구조화하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png)\n\n# API 호출을 중앙 집중화하는 이유\n\nAPI 호출을 중앙 집중화하는 것에는 여러 가지 이점이 있습니다:\n\n\n\n- 모듈성: API 로직을 하나의 파일로 분리함으로써 응용 프로그램 전반에 걸쳐 모듈성과 재사용성을 촉진합니다.\n- 조직화: 모든 API 관련 코드가 하나의 파일에 포함되어 있어 관리하고 유지하는 것이 더 쉬워집니다.\n- 일관성: 일반적인 설정 및 오류 처리 전략을 한 곳에 정의함으로써 응용 프로그램 전체에서 일관성을 보장할 수 있습니다.\n\n# Axios 설정하기\n\n먼저 프로젝트에 Axios가 설치되어 있는지 확인하세요. npm이나 yarn을 통해 설치할 수 있습니다:\n\n```js\nnpm install axios\n# 또는\nyarn add axios\n```\n\n\n\n# API 클라이언트 파일 만들기\n\nAPI 호출을 처리할 apiClient.js 파일을 생성해 봅시다:\n\n```js\n// apiClient.js\n\nimport axios from 'axios';\n\nconst BASE_URL = process.env.REACT_APP_BASE_URL || 'https://api.example.com';\n\nconst apiClient = axios.create({\n  baseURL: BASE_URL,\n  headers: {\n    'Content-Type': 'application/json',\n    // 여기에 인증 토큰과 같은 다른 헤더를 추가할 수 있습니다\n  },\n});\n\n// 공통 API 메서드 정의\nconst _get = (url, config = {}) => {\n  return apiClient.get(url, config);\n};\n\nconst _delete = (url, config = {}) => {\n  return apiClient.delete(url, config);\n};\n\nconst _put = (url, data = {}, config = {}) => {\n  return apiClient.put(url, data, config);\n};\n\nconst _post = (url, data = {}, config = {}) => {\n  return apiClient.post(url, data, config);\n};\n\n// API 메서드 내보내기\nexport { _get, _delete, _put, _post };t api;\n```\n\n위 파일에서:\n\n\n\n- Axios 인스턴스를 생성하여 기본 URL과 기본 헤더를 설정합니다.\n- 각 엔드포인트에 해당하는 다양한 API 기능을 정의합니다.\n\n환경 변수 설정: 먼저, 각 환경에 맞게 환경 변수를 설정해야 합니다. 일반적으로 각 환경에 대한 .env 파일을 생성하여 이 작업을 수행할 수 있습니다. 예를 들어:\n\n- .env.development: 개발 환경을 위한 변수를 포함합니다.\n- .env.qa: QA 환경을 위한 변수를 포함합니다.\n- .env.staging: 스테이징 환경을 위한 변수를 포함합니다.\n- .env.production: 프로덕션 환경을 위한 변수를 포함합니다.\n\n각 .env 파일 내에서 기본 URL을 정의하세요.\n\n\n\nREACT_APP_BASE_URL=https://api.example.com\n\n- 다른 환경에 접속하기: 환경에 따라 (예: 개발, QA, 스테이징) React는 자동으로 해당 .env 파일을로드하고 BASE_URL이 그에 맞게 설정됩니다.\n\n예를 들어, 개발 중일 때 React는 .env.development를로드하고 BASE_URL이 해당 파일에 지정된 값으로 설정됩니다.\n\n마찬가지로 다른 환경 (예: QA, 스테이징)에서도 React는 해당 .env 파일을로드합니다.\n\n\n\n2. React 컴포넌트에서의 사용법: 이전 예시에서 보았던 것처럼 React 컴포넌트에서 api 객체를 계속 사용할 수 있습니다. 기본 URL은 환경에 따라 동적으로 결정됩니다.\n\n이 설정을 사용하면 다른 환경에 대해 쉽게 다른 기본 URL을 관리할 수 있어 React 애플리케이션이 실행 중인 환경에 따라 적절한 백엔드와 통신할 수 있도록 보장합니다.\n\n# 컴포넌트에서 API 클라이언트 사용하기\n\n이제 React 컴포넌트에서 이 API 클라이언트를 사용하는 방법을 살펴보겠습니다:\n\n\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { _get, _post, _put, _delete } from './apiClient'; // 필요에 따라 경로를 조정하세요\n\nfunction ExampleComponent() {\n  const [data, setData] = useState([]);\n\n  useEffect(() => {\n    // 컴포넌트가 마운트될 때 데이터 가져오기\n    fetchData();\n  }, []);\n\n  const fetchData = async () => {\n    try {\n      const response = await _get('/data', { headers: { Authorization: 'Bearer 여기에 토큰 입력' } });\n      setData(response.data);\n    } catch (error) {\n      console.error('데이터를 가져오는 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  const addData = async () => {\n    try {\n      const newData = { name: '새 데이터' };\n      await _post('/data', newData);\n      fetchData(); // 추가 후 데이터 새로고침\n    } catch (error) {\n      console.error('데이터 추가 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  const updateData = async (id, updatedData) => {\n    try {\n      await _put(`/data/${id}`, updatedData);\n      fetchData(); // 업데이트 후 데이터 새로고침\n    } catch (error) {\n      console.error('데이터 업데이트 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  const deleteData = async (id) => {\n    try {\n      await _delete(`/data/${id}`);\n      fetchData(); // 삭제 후 데이터 새로고침\n    } catch (error) {\n      console.error('데이터 삭제 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  return (\n    <div>\n      <h1>예시 컴포넌트</h1>\n      <button onClick={addData}>데이터 추가</button>\n      <ul>\n        {data.map(item => (\n          <li key={item.id}>\n            {item.name}\n            <button onClick={() => updateData(item.id, { name: '업데이트된 아이템' })}>업데이트</button>\n            <button onClick={() => deleteData(item.id)}>삭제</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default ExampleComponent;\n```\n\nAxios에서 config 매개변수를 사용하면 HTTP 요청에 대한 추가 구성을 전달할 수 있습니다. 일반적으로 사용되는 구성에는 헤더, 쿼리 매개변수, 요청 시간 초과, 인증 토큰 등이 있습니다.\n\n참고: axios.create()로 Axios 인스턴스를 만들 때 baseURL 옵션을 BASE_URL로 설정합니다. 이렇게 하면 이 Axios 인스턴스로 작성된 모든 요청에 기본 URL이 URL에 접두사로 붙습니다.\n\n예를 들어, ExampleComponent에서 _get(`/data`)를 호출하면 Axios는 `https://api.example.com/data`로 GET 요청을 보냅니다.\n\n\n\n# 결론\n\nAxios를 사용하여 React 애플리케이션에서 API 호출을 중앙화하는 것은 API 로직을 관리하기 위한 깔끔하고 조직된 방법을 제공합니다. 중앙 집중화된 API 클라이언트 파일을 만들면 코드베이스에서 모듈화, 조직화 및 일관성을 달성할 수 있습니다. 이 방법을 통해 유지 보수가 간단해지며 애플리케이션 전체에서 코드 재사용을 장려합니다.\n\n오늘부터 API 호출을 조직화하고 React 프로젝트에 가져다 주는 혜택을 경험해보세요!","ogImage":{"url":"/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png"},"coverImage":"/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png","tag":["Tech"],"readingTime":5},{"title":"왜 효과가 필요하지 않을 수도 있습니다 React 컴포넌트 최적화하기","description":"","date":"2024-05-12 21:04","slug":"2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents","content":"\n\n<img src=\"/assets/img/2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents_0.png\" />\n\n요즘 리액트 개발에서 useEffect 훅은 강력한 도구입니다. 그러나 종종 과도하게 사용되거나 잘못 사용되어 불필요한 복잡성과 성능 문제를 야기할 수 있습니다. useEffect에 항상 의지하는 대신, 고려할 가치가 있는 대안들이 있습니다. 이 글에서는 그러한 대안을 탐구하고 실용적인 코딩 예제를 제공합니다.\n\n# 흔한 오용 사례\n\n# 1. 상태 동기화\n\n\n\n일반적인 사용 사례는 상태 변수를 동기화하는 것입니다. 하지만 리액트의 onChange 및 다른 이벤트 핸들러들은 대부분의 상태 업데이트를 직접 처리할 수 있습니다.\n\n잘못된 예시:\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [double, setDouble] = useState(0);\n\n  useEffect(() => {\n    setDouble(count * 2); // 이중 값 계산을 위한 사이드 이펙트\n  }, [count]);\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>증가</button>\n      <p>카운트: {count}</p>\n      <p>이중: {double}</p>\n    </div>\n  );\n}\n```\n\n최적화된 솔루션:\n\n\n\n```js\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const double = count * 2; // useEffect 없이 직접 계산\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>증가</button>\n      <p>카운트: {count}</p>\n      <p>더블: {double}</p>\n    </div>\n  );\n}\n```\n\n# 2. 데이터 가져오기\n\nuseEffect에서 데이터를 가져오는 것은 필수적이지만, react-query나 React의 새로운 Server Components와 같은 데이터 가져오기 라이브러리를 사용하여 간단히할 수 있습니다.\n\n잘못된 예시:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [profile, setProfile] = useState(null);\n  useEffect(() => {\n    async function fetchProfile() {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      setProfile(data);\n    }\n    fetchProfile();\n  }, [userId]);\n  return profile ? <div>{profile.name}</div> : <p>Loading...</p>;\n}\n```\n\nReact 서버 구성 요소를 사용한 최적화된 해결책:\n\n```js\n// components/UserProfile.server.js\nimport React from 'react';\n\nexport default async function UserProfile({ userId }) {\n  const response = await fetch(`https://api.example.com/users/${userId}`);\n  const profile = await response.json();\n\n  return <div>{profile.name}</div>;\n}\n```\n\n클라이언트 컴포넌트에서의 사용법:\n\n\n\n\n// components/App.client.js\nimport UserProfile from './UserProfile.server';\n\nfunction App({ userId }) {\n  return (\n    <div>\n      <h1>User Profile</h1>\n      <UserProfile userId={userId} />\n    </div>\n  );\n}\n\nexport default App;\n\n\n## 3. Form Inputs and Debounced Updates\n\nInstead of debouncing updates through useEffect, handle it directly via controlled input components.\n\nIncorrect Example:\n\n\n\n\n```js\r\nimport { useState, useEffect } from 'react';\n\nfunction Search() {\n  const [query, setQuery] = useState('');\n  const [debouncedQuery, setDebouncedQuery] = useState(query);\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedQuery(query);\n    }, 300);\n    return () => clearTimeout(timer);\n  }, [query]);\n  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;\n}\r\n```\n\n커스텀 훅을 사용한 최적화된 솔루션:\n\n```js\r\nimport { useState } from 'react';\nimport useDebounce from './useDebounce';\n\nfunction Search() {\n  const [query, setQuery] = useState('');\n  const debouncedQuery = useDebounce(query, 300);\n  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;\n}\r\n```\n\nuseDebounce 커스텀 훅은 디바운싱 로직을 캡슐화합니다:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n  return debouncedValue;\n}\nexport default useDebounce;\n```\n\n# 4. Prop이 변경될 때 모든 상태를 재설정하는 방법\n\n다른 항목 간을 이동할 때 폼 필드나 필터와 같은 상태 변수를 재설정하는 것이 중요합니다. 이 재설정을 처리하는 비효율적인 방법은 useEffect 훅을 사용하여 prop 변경에 따라 상태를 수동으로 지우는 것입니다. 그러나 이렇게 하면 추가 렌더링 사이클이 발생하고 불필요한 복잡성을 야기합니다.\n\n올바르지 않은 예시:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nexport default function ItemDetails({ itemId }) {\n  const [input, setInput] = useState('');\n  // 🔴 비효율적: 효과를 이용해 상태를 재설정\n  useEffect(() => {\n    setInput(''); // itemId가 변경될 때 입력 필드를 지움\n  }, [itemId]);\n\n  return <input value={input} onChange={(e) => setInput(e.target.value)} />;\n}\n```\n\n효과에 의존하는 대신 key prop을 사용하여 자동으로 재설정되도록 할 수 있습니다. 컴포넌트를 둘로 분리하고 내부 컴포넌트에 고유한 key prop을 전달하면 React가 새로운 인스턴스로 처리하여 모든 내부 상태를 재설정합니다.\n\n최적화된 솔루션:\n\n```js\nexport default function ItemDetails({ itemId }) {\n  return <ItemForm itemId={itemId} key={itemId} />;\n}\n\nfunction ItemForm({ itemId }) {\n  // ✅ key 변경 시 상태 자동 재설정\n  const [input, setInput] = useState('');\n  return (\n    <div>\n      <h2>아이템 {itemId}에 대한 세부정보</h2>\n      <input value={input} onChange={(e) => setInput(e.target.value)} />\n    </div>\n  );\n}\n```\n\n\n\n# 결론\n\nReact의 useEffect는 가치가 있지만 종종 잘못 적용될 수 있습니다. 많은 경우, 이벤트 핸들러, react-query와 같은 라이브러리, 또는 커스텀 훅과 같은 대안적인 접근 방식을 사용하면 더 깔끔하고 유지보수가 쉬운 해결책을 제공할 수 있습니다. 더 많은 정보를 원하신다면 React의 가이드를 확인해보세요.","ogImage":{"url":"/assets/img/2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents_0.png"},"coverImage":"/assets/img/2024-05-12-WhyYouMightNotNeedanEffectOptimizingReactComponents_0.png","tag":["Tech"],"readingTime":5},{"title":"Vite React 프로젝트에서 절대 상대 경로 Imports를 사용하면 안되는 이유","description":"","date":"2024-05-12 21:03","slug":"2024-05-12-AbsolutelyDontUseRelativePathsImportsInYourViteReactProject","content":"\n우리 모두는 코드를 작성하기 전에 파일 시스템을 700번이나 탐색하는 것을 멈춰야 합니다. 배워봅시다.\n\n새로운 React 프로젝트를 Vite로 설정했다고 가정하겠습니다. 아니라면, 이전 게시물을 참조하여 시작해보세요.\n\n기본적으로 이렇게 import 경로를 작성해야 합니다:\n\n```js\nimport SomeDefaultExport from \"../../../lib/usefulthings\";\nimport { NamedExport } from \"../../shared/things/NamedThing\";\n```\n\n이건 엄청난 문제는 아니지만, 깨끗한 코드란 wtf(정말 멍청한 질문) 수를 줄이는 거야. 그래서 이걸 훨씬 직접적이고 쉽게 이해할 수 있도록 수정해볼게. vite.config.js를 편집해보자.\n\n```js\n  resolve: {\n    alias: {\n      src: \"/src\",\n    },\n  },\n```\n\n여러분의 설정은 다음과 같이 보일 거에요:\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      src: \"/src\",\n    },\n  },\n});\n```\n\n이제, IDE도 우리와 함께 잘 작동하도록 도와줄 차례입니다. 프로젝트 루트 디렉토리에 새 파일을 추가해야 하며 jsconfig.json이라는 파일을 만들어야 합니다. 그리고 아래 내용을 추가해주세요:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"src/*\": [\"./src/*\"],\n    }\n  }\n}\n```\n\n위와 같이 작성할 수 있는 절대경로를 사용할 수 있게 해줍니다.\n\n```js\nimport SomeDefaultExport from \"src/lib/lib/usefulthings\";\nimport { NamedExport } from \"src/components/shared/things/NamedThing\";\n```\n\n제 삶을 훨씬 쉽게 만드는 데 이렇게 확장하고 싶어요:\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      src: \"/src\",\n      components: \"/src/components\",\n      assets: \"/src/assets\",\n      lib: \"/src/lib\",\n    },\n  },\n});\n```\n\njsconfig.json과 tsconfig.json을 잊지 마세요.\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"src/*\": [\"./src/*\"],\n      \"components/*\":[\"./src/components/*\"],\n      \"assets\": [\"./src/assets/*\"],\n      \"lib\": [\"./src/lib/*\"],\n    }\n  }\n}\n```\n\n여기 간단한 메모가 있어요. 몇 가지 예에서 개발자들이 이들 앞에 @ 기호를 사용하는 것을 본 적이 있는데, 저는 이것이 가독성이 좋은 개선이라고 생각해요. 하지만 @s 및 @c 등을 사용하여 이 이름을 더 줄이는 데 주의하세요. 빨리 배워도 명확한 코드 접근 방식을 장려하여, 필요한 것만큼 말하고 더 이상 또는 덜 이야기하지 않는 명확한 이름을 사용하는 것이 좋을 거예요.\n\n나는 Paul van Zyl이에요. 저는 Sigma Digital의 주요 컨설턴트이고, 작고 특화된 분산 형 제품 디자인 및 개발 팀입니다. 귀하의 다음 혁신적인 프로젝트를 실제로 제공할 수 있는 파트너를 찾고 있다면, 귀하와 귀하의 팀이 게임을 더 재미있게 즐길 수 있도록 도와 드릴 수 있는 파트너를 찾고 있다면, 혹은 그냥 인사를 하고 싶다면, 언제든지 연락 주세요: paul [at] sigmadigital.io\n","ogImage":{"url":"/assets/img/2024-05-12-AbsolutelyDontUseRelativePathsImportsInYourViteReactProject_0.png"},"coverImage":"/assets/img/2024-05-12-AbsolutelyDontUseRelativePathsImportsInYourViteReactProject_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 제어 및 비제어 훅","description":"","date":"2024-05-12 21:02","slug":"2024-05-12-Reactcontrolledanduncontrolledhooks","content":"\n\n<img src=\"/assets/img/2024-05-12-Reactcontrolledanduncontrolledhooks_0.png\" />\n\n리액트에서, 제어 및 비제어 컴포넌트는 폼 입력을 관리하는 데 사용되는 패턴입니다. 리액트 훅은 함수형 컴포넌트 내에서 상태를 관리하기 위한 제어 및 비제어 훅의 개념을 도입했습니다. 여기에 대한 개요입니다:\n\n## 제어 훅(Controlled Hooks):\n\nuseState 훅: 제어 훅을 사용하면 상태가 직접적으로 리액트에 의해 관리됩니다. useState 훅을 사용하면 상태 변수를 선언하고, 리액트가 제공하는 setter 함수를 사용하여 해당 변수를 업데이트할 수 있습니다. 컴포넌트의 상태가 변경되면 리액트가 업데이트된 상태로 컴포넌트를 다시 렌더링합니다.\n\n\n\n```js\nimport React, { useState } from 'react';\n\nfunction ControlledComponent() {\n  const [value, setValue] = useState('');\n\n  const handleChange = (event) => {\n    setValue(event.target.value);\n  };\n\n  return (\n    <input\n      type=\"text\"\n      value={value}\n      onChange={handleChange}\n    />\n  );\n}\n```\n\n이 예시에서는 입력 필드의 값이 'value' 상태 변수에 의해 제어되며, 업데이트는 'setValue' 함수로 처리됩니다.\n\n## Uncontrolled Hooks:\n\nuseRef Hook: Uncontrolled hooks를 사용하면 DOM 내부에서 상태를 직접 관리할 수 있습니다. React의 상태 관리 시스템을 통해가 아니라 직접 DOM 내에서 관리할 수 있습니다. useRef 훅은 렌더링 간에 다시 렌더링을 유발하지 않고 지속되는 값(current 속성)을 보유할 수 있는 가변 ref 객체를 생성합니다. \n\n\n\n\n```js\nimport React, { useRef } from 'react';\n\nfunction UncontrolledComponent() {\n  const inputRef = useRef(null);\n\n  const handleClick = () => {\n    console.log(inputRef.current.value);\n  };\n\n  return (\n    <div>\n      <input type=\"text\" ref={inputRef} />\n      <button onClick={handleClick}>Log Value</button>\n    </div>\n  );\n}\n```\n\n이 예제에서 입력 필드의 값은 inputRef.current.value를 통해 DOM에 의해 직접 관리되며 변경 사항은 React의 상태 관리 시스템을 거치지 않고 액세스됩니다.\n\n# 제어 및 비제어 훅 사이 선택하기:\n\n- 제어된 훅(Controlled Hooks): React가 응용 프로그램 전체의 form 입력 상태를 관리하고 동기화해야 할 때 제어된 훅을 사용하세요. 제어된 컴포넌트는 form 데이터에 대한 단일 진실의 원천을 제공하여 변경 사항을 추적하고 관리하기 쉽게 만듭니다.\n- 비제어 훅(Uncontrolled Hooks): DOM 요소에 직접 액세스해야 하는 경우나 제어된 컴포넌트가 성능 문제를 일으킬 수 있는 대형 폼을 다룰 때 비제어 훅을 사용하세요. 비제어 컴포넌트는 모든 상태 변경마다 다시 렌더링을 유발하지 않아 더 빠를 수 있습니다. 그러나 복잡한 응용 프로그램에서는 특히 추적하고 관리하기 어려울 수 있습니다.\n\n\n\n제어 및 비제어 훅은 각자의 사용 사례가 있으며 선택은 특정 요구 사항과 선호도에 따라 다릅니다.","ogImage":{"url":"/assets/img/2024-05-12-Reactcontrolledanduncontrolledhooks_0.png"},"coverImage":"/assets/img/2024-05-12-Reactcontrolledanduncontrolledhooks_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트에서 return null을 사용하지 마세요","description":"","date":"2024-05-12 21:01","slug":"2024-05-12-StopusingreturnnullinReact","content":"\n\n<img src=\"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png\" />\n\nReact를 사용할 때 컴포넌트에서 반환된 값의 의미를 이해하는 것이 중요합니다. 컴포넌트가 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용하는 것이 유혹스러울 수 있지만, 이는 의도하지 않은 결과를 초래할 수 있습니다. 이 게시물에서는 React 컴포넌트에서 return null을 사용하는 것이 나쁜 습관으로 여겨지는 이유와 return false가 더 좋은 대안인 이유에 대해 살펴보겠습니다.\n\n# \"return null\" 사용에 대한 문제점\n\n컴포넌트에서 return null을 사용하는 주된 문제점은 애플리케이션에서 예상치 못한 동작을 일으킬 수 있다는 것입니다. 특히, null은 React에서 렌더링할 유효한 값으로 처리되며, 이로 인해 컴포넌트의 자식 요소가 트리에서 분리될 수 있습니다. 이는 예기치 않은 다시 렌더링이나 상태 불일치 등 다양한 문제를 초래할 수 있습니다.\n\n\n\n이것이 발생하는 이유를 이해하기 위해서는 React가 어떻게 작동하는지에 대해 알아야 도움이 됩니다. 컴포넌트가 렌더링될 때, React는 현재 UI 상태를 나타내는 가상 DOM 트리를 생성합니다. 그런 다음 이 트리는 이전 트리와 비교되어 UI의 어느 부분을 업데이트해야 하는지를 결정합니다. 컴포넌트가 null을 반환하면, React에게 아무것도 렌더링할 필요가 없다고 알립니다. 그러나 이는 컴포넌트의 자식들이 업데이트되어야 하는 상태나 프롭을 가지고 있을 때 문제를 일으킬 수 있습니다.\n\n다음 예시를 살펴보세요:\n\n```js\nfunction Parent() {\n  return (\n    <div>\n      <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Child rendered');\n  });\n\n  if (count === 0) {\n    return null;\n  }\n\n  return (\n    <div>\n      <button onClick={() => setCount(count - 1)}>-</button>\n      {count}\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n이 예시에서, Child 컴포넌트는 count가 0과 같을 때 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용합니다. 그러나 이는 Child 컴포넌트가 count의 값이 0이 아닌 값으로 다시 렌더링될 때 문제를 일으킬 수 있습니다. 이 경우에 React는 Child 컴포넌트를 트리에 다시 연결해야 하며, 예상치 못한 동작을 일으킬 수 있습니다.\n\n\n\n# \"return false\"의 장점\n\nreturn null 대신에 return false를 사용하는 것이 더 좋은 방법입니다. 컴포넌트가 false를 반환하면 React는 이를 null을 반환한 것처럼 처리하지만, 또한 React에게 해당 컴포넌트의 자식들을 렌더링하지 말라고 말합니다. 이렇게 하면 컴포넌트와 해당 자식들이 트리에 연결된 채로 유지되어, return null을 사용했을 때 발생할 수 있는 문제점을 회피할 수 있습니다.\n\n다음은 return false를 사용하는 이전 예제의 업데이트된 버전입니다:\n\n```js\nfunction Parent() {\n  return (\n    <div>\n      <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Child rendered');\n  });\n\n  if (count === 0) {\n    return false;\n  }\n\n  return (\n    <div>\n      <button onClick={() => setCount(count - 1)}>-</button>\n      {count}\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n\n\n이 버전에서 Child 컴포넌트는 count가 0과 동일할 때 null 대신 false를 반환합니다. 이렇게 하면 컴포넌트와 해당 하위 요소가 렌더링할 필요가 없을 때에도 트리에 연결된 상태를 유지합니다. 결과적으로, 컴포넌트가 더 예측 가능하게 동작하고 return null을 사용할 때 발생할 수 있는 문제를 피할 수 있습니다.\n\n# \"return false\"를 사용하는 경우\n\n일반적으로 return null 대신에 return false를 사용하는 것이 더 나은 실천 방법이지만, 적용하기에 적절하지 않을 수 있는 경우가 있음을 기억하는 것이 중요합니다. 구체적으로, 컴포넌트가 렌더링할 필요가 없음을 나타내야 하는 경우에만 return false를 사용해야 합니다. 컴포넌트가 조건에 따라 무언가를 렌더링해야 하는 경우에는 if 문이나 삼항 연산자와 같은 조건부 렌더링 기술을 사용해야 합니다.\n\n다음은 if 문을 사용한 조건부 렌더링 예시입니다:\n\n\n\n```js\nfunction MyComponent({ isLoggedIn }) {\n  if (!isLoggedIn) {\n    return <LoginForm />;\n  }\n\n  return <Dashboard />;\n}\n```\n\n이 예에서 MyComponent 컴포넌트는 사용자가 로그인했는지에 따라 LoginForm 또는 Dashboard를 조건부로 렌더링하는 if 문을 사용합니다. 이는 return false 대신 조건부 렌더링을 사용하는 더 적절한 방법입니다.\n\n# 결론\n\n결론적으로, React 컴포넌트에서 return null을 사용하면 예기치 않은 동작을 유발하므로 일반적으로 피해야 합니다. 대신 컴포넌트가 렌더링하지 말아야 함을 나타내어야 할 때는 return false를 사용해야 합니다. 이렇게 함으로써 컴포넌트와 그 하위 요소는 트리에 연결된 상태를 유지하고 return null 사용으로 발생할 수 있는 문제를 피할 수 있습니다.\n\n\n\n\n그러나 return false를 사용하는 경우는 컴포넌트가 아무것도 렌더링하지 말아야 하는 경우에만 사용해야 한다는 점을 명심해야 합니다. 컴포넌트가 조건부로 렌더링해야 하는 경우에는 조건부 렌더링 기술을 사용해야 합니다.","ogImage":{"url":"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png"},"coverImage":"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 JS에서 가짜 API 서버로 JSON 파일을 사용하는 방법","description":"","date":"2024-05-12 21:00","slug":"2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS","content":"\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_0.png)\n\n이 튜토리얼에서는 React JS에서 가짜 API를 위한 서버로 JSON 파일을 어떻게 사용하는지 배워보겠습니다. 실제 API에 의존하지 않고 애플리케이션을 테스트하고자 할 때 유용합니다. JSON 파일을 가짜 API로 사용함으로써 API 응답을 쉽게 모의하고 실제 API 호출을 하지 않고 다양한 시나리오를 테스트할 수 있습니다.\n\n# 요구 사항\n\n- json-server\n\n\n\n단계 1: JSON 파일 만들기\n리액트 프로젝트에서 새로운 JSON 파일을 만들고 \"db.json\"으로 이름 짓기. 이 파일에서 우리는 모킹하고 싶은 API 응답을 정의할 거에요. 아래는 예시입니다:\n\n단계 2: json-server 설치하기\nJSON 파일로부터 REST API를 시뮬레이트하기 위해 json-server 패키지를 사용할 거에요. 설치하려면 터미널에서 다음 명령어를 실행하세요:\n\n```js\nnpm install -g json-server\n```\n\n단계 3: JSON 서버 시작하기\nJSON 서버를 시작하려면 터미널에서 다음 명령어를 실행하고 JSON 파일의 경로를 지정하세요:\n\n\n\n```json\njson-server --watch db.json --port 3030\n```\n\n참고: React는 서버를 실행하는 데 사용되는 3000 포트를 사용하므로 포트를 수정하기 위해 —port 3030을 사용했습니다.\n\n단계 4: API 테스트\n이제 브라우저에서 http://localhost:3030/posts를 열면 데이터를 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_1.png)\n\n\n\n5단계: React에서 API 요청 만들기\nReact 컴포넌트에서 fetch API 또는 다른 HTTP 클라이언트 라이브러리를 사용하여 JSON 서버에 API 요청을 만듭니다. 다음은 fetch를 사용한 예시입니다:\n\n우리는 가짜 API 요청을 성공적으로 만들고 해당 요청을 통해 React 컴포넌트로 데이터를 가져왔습니다. GET 요청뿐만 아니라 POST 요청을 사용하여 데이터를 JSON 파일에 삽입하고, PUT 요청을 사용하여 데이터를 업데이트하고, DELETE 요청을 사용하여 JSON 데이터를 삭제할 수 있습니다. 이를 Postman에서 확인해 봅시다.\n\nPOST 요청\n\nJSON 파일에 새로운 게시물을 추가하려면 POST 요청을 만들고 본문을 사용하여 JSON 데이터를 추가해야 합니다. 다음은 예시입니다:\n\n\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_2.png)\n\nPUT 요청\n\n만약 데이터를 업데이트해야 한다면 PUT 요청을 사용하여 업데이트할 수 있습니다. 다음은 예시입니다:\n\n![이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_3.png)\n\n\n\n삭제 요청\n\nJSON 파일에서 데이터를 삭제하려면 DELETE 요청을 사용할 수 있습니다. 예시는 다음과 같습니다:\n\n![예시 이미지](/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_4.png)\n\n여기까지입니다! React JS에서 가짜 API로 JSON 파일을 사용함으로써 실제 API에 의존하지 않고 응용 프로그램을 쉽게 테스트할 수 있습니다. 이는 테스트 목적으로 빠르고 쉬운 솔루션이며, 실제 API 호출을 하지 않고도 다양한 API 응답을 모방하고 다양한 시나리오를 테스트할 수 있습니다.\n\n\n\n문의 사항이 있으시면 LinkedIn을 통해 연락 주세요.\n\n오늘은 여기까지입니다. 아래에서 GitHub 저장소를 찾을 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_0.png"},"coverImage":"/assets/img/2024-05-12-HowtouseJSONfileasaserverforfakeAPIinReactJS_0.png","tag":["Tech"],"readingTime":2},{"title":"React  Vite  React에서 Tailwind CSS가 작동되지 않는 문제 해결 2024년 업데이트","description":"","date":"2024-05-12 21:00","slug":"2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated","content":"\n\n<img src=\"/assets/img/2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated_0.png\" />\n\n가끔 Tailwind CSS가 작동하지 않고 Vite에 특히 지정된 방법으로 사전 설치를 따르지 않을 때 프로젝트에 적용할 수 없습니다.\n\n# 해결책\n\n간단합니다. 'vite.config.js' 파일에 아래와 같이 tailwindcss 및 css: ' ... '를 가져오는 부분을 추가해야 합니다.\n\n\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport tailwindcss from \"tailwindcss\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  css: {\n    postcss: {\n      plugins: [tailwindcss()],\n    },\n  },\n\n});\n```\n\n# 단계별 설치 안내\n\n또는 Vite + React 프로젝트에 Tailwind CSS 설정을 시작부터 따라갈 수도 있습니다.\n\n- Vite에 Tailwind CSS를 설치하는 명령어는 조금 다릅니다. postcss와 autoprefixer가 추가로 필요합니다.\n\n\n\n```js\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n2. 'tailwind.config.js' 파일을 아래와 같이 편집하여 모든 파일과 확장자를 추가하여 Tailwind CSS를 적용할 수 있습니다.\n\n```js\n/** @type {import('tailwindcss').Config} */\nexport default {\n  content: [\"./index.html\", \"./src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n3. 이것들을 당신의 CSS 파일 맨 위에 추가하세요.\n\n\n\n```js\n@tailwind 기본;\n@tailwind 컴포넌트;\n@tailwind 유틸리티;\n```\n\n완료! npm run dev로 이동해요.\n\n이제 일반적인 지시사항과 다른 부분을 보셨나요? output.css 파일을 생성하고 html 파일에 연결하는 단계가 필요하지 않아요.\n\nVite + React에서는 사실 더 간단하고 쉬워요.\n\n\n\n행복한 React! 🌐","ogImage":{"url":"/assets/img/2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated_0.png"},"coverImage":"/assets/img/2024-05-12-ReactTailwindCSSIsNotWorkingInViteReactSolution2024updated_0.png","tag":["Tech"],"readingTime":2},{"title":"NextAuthJS를 Discord와 함께 사용하는 방법","description":"","date":"2024-05-12 20:57","slug":"2024-05-12-HowtouseNextAuthJSwithDiscord","content":"\n\n## Discord API를 사용하여 NextJS에서 NextAuth.JS를 통한 \"Discord를 사용한 로그인\"을 구현하는 방법을 배워보세요.\n\n<img src=\"/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png\" />\n\n최근 대시보드 프로젝트를 작업하던 중에 Discord 사용자들이 애플리케이션에 로그인하고 그들의 서버 중 하나를 수정할 수 있도록 하는 작업을 하게 되었습니다.\n\n이전에 NextJS로 인증을 구현해본 적이 없던 사람으로써 전혀 감이 안 왔습니다. NextAuth, Auth0, Clerk 및 Supabase 사이를 계속 왔다갔다했습니다. 오류가 발생했을 때, 처음 몇 초만에 NextAuth를 포기했습니다.\n\n\n\n신입 개발자로 시작하는 것은 어렵습니다. 대부분의 경우, 처음으로 선택한 옵션이 가장 이상적인 경우가 많아요. 저는 모든 것을 시도해보고 결국 NextAuth로 돌아왔어요. 어떻게 구현하는지 알아내고 끝없는 시간을 보냈기 때문에 당신은 그럴 필요가 없어요!\n\n이 글을 통해 우리가 어떻게 인증을 구현할 수 있는지 살펴보도록 하죠.\n\n# NextAuth를 위한 Discord 제공자\n\nNextAuth를 활용하면 Google, Facebook, Apple, Github 등 다양한 서비스를 위한 인증을 설정할 수 있어요. NextAuth는 이러한 서비스와 플랫폼을 제공자(provider)라고 부르죠. 다시 말해, 이러한 제공자는 서비스이며 사용자들은 이를 통해 애플리케이션에 로그인할 수 있어요.\n\n\n\n이 기사에서는 Discord Provider를 사용할 것입니다. 다른 공급업체와 달리, Discord는 인증 설정을 위해 추가 구성이 필요합니다. 우리는 먼저 이러한 요구 사항을 정렬해야 합니다.\n\nDiscord Developer Portal에서 애플리케이션을 생성하여 Discord API 및 Discord 인프라에 액세스해야 합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*2IOmhM7_ZtM_Mf8zc6u5Dg.gif)\n\n그런 다음 Client ID와 Client Secret을 가져와야 합니다. 보안 목적을 위해 Client Secret을 재설정해야 합니다.\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*fXb5ABTdet-g_6FIqRwUpA.gif)\n\n필요한 자격 증명을 획득한 후 다음 단계로 진행할 수 있습니다. 관련 정보를 얻을 수 없는 경우, 선택한 브라우저에서 기본 검색을 수행하고 누군가가 안내해 줄 것입니다.\n\n## NextJS 앱 초기화\n\n이미 하지 않았다면 NextJS 애플리케이션을 설정해야 합니다. 다음 명령어를 터미널에서 사용하여 NextJS 애플리케이션을 초기화하고 단계를 따르세요.\n\n\n\n```js\nnpx create-next-app@latest\n```\n\n데모를 위해 프론트 엔드에서 인증 기능을 보여주기 위해 TypeScript보다는 JavaScript를 선택했어요 (화 angry지 마세요) 그리고 API 라우트를 용이하게 하기 위해 최신 App Router를 사용하고 전반적으로 더 나은 경험을 위해 TailwindCSS를 사용했어요.\n\n또한, src/ 구성을 선택하지 않았어요. 우리는 모든 것을 app/ 디렉토리 안에서 할 거예요. 그러나 당신의 어플리케이션에 맞춰 동일한 단계를 따르고 코드 스니펫을 조정할 수 있어요.\n\n## NextAuth 설치하기\n\n\n\n프로젝트에 NextAuth를 설치하려면 다음 명령을 사용해야 합니다.\n\n```js\nnpm install next-auth\n```\n\n설치가 완료되면 권한 부여와 관련된 다양한 요청을 처리하기 위한 새로운 API route를 생성해야 합니다. 먼저 app/ 디렉토리 안에 api/라는 폴더를 만듭니다.\n\n그런 다음 api/ 디렉토리 내에 nested 폴더를 만들어 auth/로 이름 지어주세요. 마지막으로 auth/ 디렉토리 내에 […nextauth]라는 디렉토리를 만듭니다. NextAuth는 이 디렉토리 구조를 엄격히 요구하므로 이러한 작업이 마법처럼 이루어질 것입니다.\n\n\n\n들어오는 요청을 처리하기 위해 app/api/auth/[...nextauth]/route.js 경로에 route.js 파일을 생성하세요. 이 파일은 동적 경로 핸들러입니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_1.png)\n\n## NextAuth를 위한 API Route 생성\n\n이 동적 경로 핸들러는 NextAuth 구성을 저장하고 NextAuth와 관련된 들어오는 요청을 처리할 것입니다.\n\n\n\n먼저 라우트 핸들러 파일에 NextAuth를 가져와보세요. 그런 다음 NextAuth에서 Discord Provider를 가져와주세요. 이 두 항목을 가져온 후, NextAuth를 구성하기 시작하겠습니다.\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n```\n\n이제 클라이언트 ID와 클라이언트 시크릿이 필요합니다. 준비해두세요. 이제 AuthOptions라는 객체를 만들 것입니다. 이 객체는 인증에 필요한 값들을 가진 객체입니다. 기억해주세요, 객체를 초기화할 때 export 키워드를 사용해야 합니다.\n\n이 객체를 사용하여 서버 컴포넌트에서 현재 세션에 액세스할 것입니다. 그런데, 세션은 서버 기반이며 DB와는 무관합니다.\n\n\n\n여기 파일이 보이는 모양입니다.\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n\nexport const AuthOptions = {\n  providers: [\n    DiscordProvider({\n      clientId: \"클라이언트_시크릿\",\n      clientSecret: \"클라이언트_시크릿\",\n    }),\n  ],\n};\n```\n\n이제 NextAuth 함수를 사용하여 인증을 초기화해야 합니다. 이 함수는 AuthOptions와 해당 속성을 매개변수로 필요로 합니다. 따라서 AuthOptions 객체를 매개변수로 전달할 것입니다.\n\n```js\nconst handler = NextAuth(AuthOptions);\n```\n\n\n\nNextAuth와 구성 옵션을 성공적으로 통합했습니다. 하지만, 더 있습니다. 누군가가 계정에 Discord를 사용하여 로그인하는 경우, Discord가 애플리케이션이 처리하고 로그인한 사용자의 계정에 액세스하기 위한 코드를 생성합니다.\n\n이 고유 코드를 사용하여 직렬화된 토큰을 얻을 수 있습니다. 토큰은 로그인한 사용자를 나타내는 문자열의 일련 번호이며 Discord API에 액세스할 수 있는 열쇠 역할을 합니다. 우리는 봇의 토큰 또는 유효한 Discord 사용자의 토큰이 있을 때만 Discord API에 액세스할 수 있습니다.\n\n해당 고유 코드가 어디에 있는지 궁금해하는 분들도 있을 것입니다. Discord는 사용자가 로그인에 성공한 후 애플리케이션이 사용자를 리디렉션하는 URL에 넣습니다. 다음은 NextAuth가 어떻게 도와주는지에 대한 설명입니다.\n\n\n\n우리가 사용자 정의 리디렉션 URL을 대신 사용하는 대신 NextAuth의 도움을 받을 것입니다. Discord 개발자 포털에서 선택한 애플리케이션의 OAuth 섹션에 다음과 같은 리디렉션 URL을 삽입할 것이며, 이 URL은 사용자가 로그인에 성공한 후 NextAuth의 라우트 핸들러로 사용자를 리디렉션할 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*deLjJ2UZeiuCS8AcNZzm9A.gif)\n\n리디렉션 URL은 이전에 로컬로 저장된 애플리케이션에서 미리 만든 동적 라우트 핸들러의 경로입니다. 프로덕션 빌드에서는 localhost:3000을 여러분의 도메인 이름이나 VPS IP로 바꿔야 합니다.\n\n사용자가 로그인하면 NextAuth의 라우트 핸들링 시스템으로 리디렉션되며, NextAuth가 즉시 코드를 토큰으로 교환하고 저장합니다.\n\n\n\n## NextAuth 콜백\n\n유저가 로그인하면 다른 페이지로 리디렉션되기를 원합니다. 기본 NextAuth 페이지에 머무르지 않도록 하거나 기본적으로 루트 디렉토리(홈페이지)로 리디렉션되지 않도록 하고 싶습니다. 따라서 NextAuth에서 리디렉션을 처리하기 위해 콜백을 사용할 것입니다.\n\nNextAuth는 개발자가 고유한 사용 사례에 맞게 구성할 수 있는 콜백을 제공합니다. 특정 이벤트가 트리거될 때마다 NextAuth 콜백이 호출됩니다. 예를 들어, signIn() 콜백은 유저가 로그인했을 때 실행됩니다.\n\n우리의 경우, redirect() 콜백을 재정의할 것입니다. 이 콜백은 두 개의 매개변수를 가져야 하지만, 우리는 일반적으로 루트 디렉토리의 URL(localhost:3000/)을 필요로 합니다.\n\n\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n\nexport const AuthOptions = {\n  providers: [\n    DiscordProvider({\n      clientId: \"YOUR_CLIENT_ID\",\n      clientSecret:\n        \"YOUR_CLIENT_SECRET\",\n    }),\n  ],\n\n  callbacks: {\n    async redirect({ url, baseUrl }) {\n      return baseUrl + \"/dashboard\";\n    },\n  },\n};\n\nconst handler = NextAuth(AuthOptions);\n```\n\n또한 route 핸들러에서 NextAuth() 함수를 호출한 결과를 내보내야 합니다. 그렇지 않으면 세션에 액세스하거나 처리할 GET 및 POST 요청이 작동하지 않습니다.\n\n다음은 route.js 파일이어야 합니다. /dashboard를 원하는 경로로 바꿀 수 있습니다.\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n\nexport const AuthOptions = {\n  providers: [\n    DiscordProvider({\n      clientId: \"YOUR_CLIENT_ID\",\n      clientSecret:\n        \"YOUR_CLIENT_SECRET\",\n    }),\n  ],\n\n  callbacks: {\n    async redirect({ url, baseUrl }) {\n      return baseUrl + \"/dashboard\";\n    },\n  },\n};\n\nconst handler = NextAuth(AuthOptions);\n\nexport { handler as GET, handler as POST };\n```\n\n\n\n# 디스코드 권한\n\n기본적으로 로그인한 사용자의 사용자 이름과 이메일에만 액세스할 수 있습니다. 더 많은 정보에 액세스하려면 디스코드 API 및 엔드포인트를 사용해 볼 수 있지만, 디스코드는 접근을 거부할 것입니다. 이는 디스코드가 개인 정보 보호와 보안을 강화하기 때문입니다.\n\n더 많은 정보에 액세스하려면 사용자의 권한이 필요합니다. 사용자가 로그인을 시도할 때 그들로부터 권한을 얻을 수 있습니다. 주목했을 것인데, 디스코드는 사용자가 로그인 시도할 때 응용 프로그램에 부여하는 권한을 나열합니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_2.png)\n\n\n\n만약 무작위로 보였다면, 그것은 오산이었습니다. 개발자는 이러한 권한을 요청하며, 사용자들은 보통 그것을 무시합니다. 우리는 권한을 요청하기 위해 그것들을 권한 URL에 추가함으로써 실현할 수 있습니다. route.js 파일로 돌아가는 시간입니다.\n\nDiscordProvider 함수 안에, authorization이라는 또 다른 속성을 추가해야 합니다. 이 속성의 값은 애플리케이션 요구 사항에 따라 다를 것입니다. 이전에 말한대로, 저는 로그인한 사용자의 길드에 액세스하고 그것들을 표시하려고 합니다.\n\n그러므로, 저는 해당 권한을 요청하고 몇 가지 다른 것들도 포함할 것입니다. Discord 개발자 포털에서 그것들을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_3.png)\n\n\n\n페이지 URL 쿼리 매개변수에서 모든 권한 이름이 ' + ' 기호를 사용하여 연결될 것입니다.\n\n```js\nproviders: [\n    DiscordProvider({\n      clientId: \"YOUR_CLIENT_ID\",\n      clientSecret:\n        \"YOUR_CLIENT_SECRET\",\n      authorization:\n        \"https://discord.com/api/oauth2/authorize?scope=identify+guilds\",\n    }),\n],\n```\n\n이제 프론트 엔드를 구성하여 로그인 프로세스를 시작해 보겠습니다.\n\n# 프론트 엔드 구성하기\n\n\n\n새로운 애플리케이션을 시작했기 때문에 루트 디렉토리에서 수정을 할 것입니다. 만약 로그인 버튼을 다른 곳에 넣고 싶다면 그렇게 할 수 있어요. 단계 자체는 동일해요.\n\n루트 디렉토리에 LoginUsingDiscord.jsx라는 클라이언트 컴포넌트를 만들어서 onClick 이벤트를 처리할 거에요. 주요 페이지.js 파일은 여전히 기본 서버 컴포넌트 모드로 유지될 거에요.\n\n컴포넌트 내부에서는 \"next-auth/react\"에서 signIn() 함수를 import하여 \"Login\" 버튼을 클릭했을 때 호출할 거에요. signIn() 함수에는 하나의 매개변수를 전달할 수 있어요. 바로 클릭했을 때 호출될 로그인 버튼이 표현하는 프로바이더의 이름이에요.\n\n```js\n\"use client\";\n\nimport { signIn, signOut } from \"next-auth/react\";\n\nexport default function LoginUsingDiscord() {\n  return (\n    <section className=\"flex gap-8 items-center justify-center mt-12\">\n      <p className=\"font-bold text-lg\">Discord를 사용하여 로그인</p>\n      <button\n        onClick={() => signIn(\"discord\")}\n        className=\"text-base py-3 px-4 bg-[#5865F2]\"\n      >\n        로그인\n      </button>\n    </section>\n  );\n}\n```\n\n\n\n그것이에요. 버튼을 클릭하면 Discord 로그인 화면으로 리디렉션됩니다. 토큰의 직렬화가 완료되면 redirect() 콜백에서 선택한 URL로 이동합니다. 제 경우에는 /dashboard로 이동했어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*6VWH3jSGprzfSPkHbafQfA.gif)\n\n성공적으로 로그인한 후에는 localhost:3000/api/auth/session에서 세션에 액세스할 수 있어요. 이 세션은 기본적으로 사용자 이름과 이메일만 포함하고 있어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*L3cZJJjMjQNvcKrWFXPAFw.gif)\n\n\n\nroute.js 파일 내에서 signIn()이라는 다른 콜백 함수를 덮어쓸 것입니다. 보안을 위해 토큰은 NextAuth의 범위 내에서만 접근할 수 있습니다.\n\n```js\nasync signIn({ account }) {\n  const discordToken = account.access_token;\n\n  return true;\n},\n```\n\nsignIn() 콜백은 사용자, 계정, 자격증명 등 다른 값들을 매개변수로 제공합니다. 우리는 access token을 검색하기 위해 account 매개변수만 필요합니다.\n\n대시보드 프로젝트에서 토큰을 해싱한 후 DB에 저장했습니다. 그러나 이곳에서는 그렇게 하지 않을 것입니다. 토큰을 사용하여 사용자에 대한 정보에 액세스하고 간소화를 위해 콘솔에 출력하려고 합니다.\n\n\n\n디스코드 API를 라우트나 서버 구성요소에서 사용하려면 토큰을 어딘가에 저장해야 합니다. 디스코드 API로의 모든 요청에는 디스코드 사용자 토큰이 필요합니다. 이 기사를 복잡하게 만들 수 없기 때문에 토큰을 어디에도 저장하지 않고 가져온 데이터를 콘솔에 표시할 것입니다.\n\n토큰을 어디에도 저장하지 않으므로 route.js 파일 외부에서 사용할 수 없습니다. 따라서 signIn() 콜백 내에서 디스코드 API에 대한 API 요청을 만들고 동작하는 방법을 보여드리겠습니다.\n\n# 디스코드 API 사용하기\n\nsignIn() 콜백을 계속 수정해보겠습니다. 사용자에 대한 정보를 가져와 콘솔에 출력하여 간단하게 표시하겠습니다. 이러한 API 요청의 엔드포인트는 디스코드 문서에 나와 있습니다.\n\n\n\nDiscord에서 제공하는 api/users/@me 엔드포인트로 GET 요청을 보내고, 로그인한 사용자의 정보가 포함된 객체를 받아오고 있어요. 사용자가 로그인했는지에 대해서는 중요하지 않아요. 각 액세스 토큰은 고유한 사용자를 나타내요.\n\n토큰은 매달 만료되며 갱신이 필요해요. 저는 사용자의 토큰을 사용할 때마다 그들을 대신해서 API 요청을 보내고 있어요. Discord는 저를 중재자로 취급해요.\n\n```js\nasync signIn({ account }) {\n   const discordToken = account.access_token;\n\n   const discordUser = await fetch(`https://discord.com/api/users/@me`, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${discordToken}`,\n      },\n    }).then((res) => res.json());\n  \n    console.log(discordUser);\n\n    return true;\n},\n```\n\n액세스 토큰을 header의 Authorization 속성에 전달하면, 모든 것을 올바르게 수행했다면 API 엔드포인트로부터 응답을 받을 수 있어요.\n\n\n\n![Screenshot](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_4.png)\n\n결국 LoginUsingDiscord 구성 요소 내에 로그아웃 버튼을 추가했어요. signOut() 함수를 사용했어요. 이 함수는 매개변수 없이 작동합니다. 왜냐하면 하나의 서비스만 활성 세션을 가질 수 있거든요. 여기에 코드가 있어요.\n\n```js\n<button\n  onClick={() => signOut()} className=\"text-base py-3 px-4 bg-[#ED4245]\">\n  Sign Out\n</button>\n```\n\n# 결론\n\n\n\n대부분의 애플리케이션에서 인증 구현은 어려운 작업입니다. NextAuth를 사용하면 이 작업을 더 쉽게 할 수 있습니다. 세션을 만드는 방법, 사용자가 Discord를 사용해 로그인할 수 있도록 하는 방법, 토큰을 사용해 Discord API에 API 요청을 보내는 방법 등을 배웠습니다.\n\n마찬가지로 Google과 같은 다른 제공업체를 사용할 수도 있습니다. 이 글이 도움이 되었기를 바랍니다. 소프트웨어 엔지니어로 취직하고 싶다면 대기 목록에 가입하는 것을 권장합니다.\n\n질문이 있다면 director@afankhan.com 이나 다른 곳에서 @whyafan 으로 연락해 주세요.\n\n# 평문으로 🚀\n\n\n\n플레인 영어 커뮤니티에 참여해 주셔서 감사합니다! 다음에 가시기 전에:\n\n- 작가를 추천하고 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png"},"coverImage":"/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png","tag":["Tech"],"readingTime":11}],"page":"138","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}