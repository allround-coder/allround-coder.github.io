{"pageProps":{"posts":[{"title":"ERR_BLOCKED_BY_RESPONSENotSameOrigin 에 대한 간단한 해결 방법","description":"","date":"2024-05-20 23:04","slug":"2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin","content":"\n\n<img src=\"/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png\" />\n\n\"ERR_BLOCKED_BY_RESPONSE.NotSameOrigin\"은 일반적으로 웹 브라우저에서 발생하는 오류입니다. 이 오류는 웹페이지가 접근하려는 리소스가 페이지 자체와 다른 출처(또는 도메인)를 가지고 있는 경우에 발생합니다. 이는 웹 브라우저에 내장된 보안 기능으로, 다중 사이트 스크립팅 공격을 방지하기 위한 것입니다.\n\n웹 페이지가 다른 출처로 요청을 시도할 때, 브라우저는 해당 요청을 차단하고 \"ERR_BLOCKED_BY_RESPONSE.NotSameOrigin\" 오류 메시지를 반환합니다. 이는 요청을 허용할 경우 민감한 정보가 노출되거나 악성 코드가 페이지에서 실행될 수 있기 때문입니다.\n\n이 오류를 해결하려면 페이지가 접근하려는 모든 리소스(예: 이미지, 스크립트 및 기타 파일)가 페이지 자체와 동일한 도메인에 호스팅되어 있는지 확인해야 합니다. 또는 특정 출처가 리소스에 액세스할 수 있도록 크로스 출처 리소스 공유(CORS)를 사용할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n제 프로젝트에서 가져온 간단한 예시입니다:\n\n이미지 파일 위치를 지정하는 src 속성이 있는 HTML img 태그입니다. 이는 제3자 API입니다.\n\n```js\n<img src={`https://countryflagsapi.com/png/${country.alpha3Code.toLowerCase()}`} alt=\"flag\"/>\n```\n\nimg 태그에 crossorigin 속성을 간단히 추가할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<img crossorigin='anonymous' src={`https://countryflagsapi.com/png/${country.alpha3Code.toLowerCase()}`} alt=”flag”/>\n```\n\n문제를 해결할 수 있는 또 다른 고급 방법이 있습니다. Helmet을 사용하여 crossOriginEmbedderPolicy 미들웨어를 비활성화하는 방법도 있습니다. 더 많은 세부 정보는 여기에서 확인할 수 있습니다.\n\n추가 자료:\nRFC 섹션-3.4.2\n","ogImage":{"url":"/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png"},"coverImage":"/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png","tag":["Tech"],"readingTime":2},{"title":"웹사이트로 계산기 프로젝트 만들기","description":"","date":"2024-05-20 23:03","slug":"2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects","content":"\n\n\n![Simple Calculator](/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png)\n\nAs a 1st year IT undergraduate, I always work on pet projects to enhance my skills. I thought I would share my little pet project with you - a simple calculator.\n\n## How did I create this?\n\nI used HTML, CSS, and JavaScript to create this project and used Visual Studio Code as my code editor.\n\n\n<div class=\"content-ad\"></div>\n\n# 하는 일의 중요성 반려동물 프로젝트\n\n요즘에는 인터넷에서 프로그래밍, 코딩 또는 원하는 것을 배울 수 있어요. 기술이 발전함에 따라 지금은 모든 것이 손끝에 있어요. 무엇을 배우든 모든 것을 기억할 수 없을 거예요. 그게 인간의 본성이에요. 하지만 배운 것을 실천해보려고 노력하면 기억에 큰 도움이 될 거예요. 저는 IT 학부생으로 항상 반려동물 프로젝트를 합니다. 반려동물 프로젝트를 통해 당신은\n\n- 이전에 배운 것을 상기시킬 수 있어요.\n- 이론의 실제 응용을 알 수 있어요.\n- 코딩과 프로그래밍을 연습할 수 있어요.\n- 실수로부터 배울 수 있어요.\n- 기술을 향상시키는 좋은 방법이에요.\n- 천천히 산업 수준으로 진입할 수 있어요.\n\n또한, 이렇게 만든 반려동물 프로젝트를 취업 면접에서 보여줄 수 있어요. 분명히 당신에게 이점을 줄 거예요. 아직 시작하지 않았다면, 지금 반려동물 프로젝트에 착수하세요.\n\n<div class=\"content-ad\"></div>\n\n# 내 간단한 계산기에 관한 작은 비디오\n\n# 내 간단한 계산기를 확인해 보세요","ogImage":{"url":"/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png"},"coverImage":"/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png","tag":["Tech"],"readingTime":1},{"title":"웹 개발에 필요한 내용들 전반적으로 소개","description":"","date":"2024-05-20 23:02","slug":"2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT","content":"\n\n웹 개발은 웹 사이트 및 웹 애플리케이션을 만들고 유지 보수하는 동적이고 끊임없이 발전하는 분야입니다. 이 블로그에서는 웹 개발의 개요를 제공하고 프론트엔드, 백엔드, 풀스택 개발 간의 차이를 살펴보며 필수 도구와 기술을 소개할 것입니다. 이 분야에 처음 발을 딛는 초보자이든, 지식을 업데이트하고자 하는 경험 많은 개발자이든, 이 안내서가 안정적인 기반을 제공할 것입니다.\n\n![웹 개발 소개](/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png)\n\n웹 개발은 웹 사이트 및 웹 애플리케이션을 만드는 모든 활동을 포괄합니다. 코딩 및 마크업, 스크립팅, 네트워크 구성, CMS(콘텐츠 관리 시스템) 개발 등이 모두 포함됩니다. 주요 목표는 기능적이고 사용자 친화적이며 시각적으로 매력적인 사이트를 만드는 것입니다.\n\n- 웹 디자인: 웹 사이트의 레이아웃, 색상 구도, 타이포그래피, 전반적인 사용자 경험(UX) 및 사용자 인터페이스(UI) 디자인과 같은 미학적 측면을 다룹니다.\n- 웹 콘텐츠: 웹사이트에서 사용자 경험의 일부로 만나는 텍스트, 시각적 또는 청각적 콘텐츠를 말합니다.\n- 클라이언트 측 스크립팅: 사용자의 웹 브라우저에서 실행되는 코드를 작성하여 상호 작용성과 사용자 경험을 향상시킵니다. HTML, CSS, JavaScript와 같은 기술이 일반적으로 사용됩니다.\n- 서버 측 스크립팅: 서버에서 실행되고 데이터베이스와 상호작용하며 사용자 인증을 처리하고 사용자에게 웹 페이지를 제공하는 코드를 작성하는 것을 말합니다. PHP, ASP.NET, Node.js, Python과 같은 기술이 널리 사용됩니다.\n- 데이터베이스 관리: 웹 애플리케이션을 위해 데이터를 저장하는 데이터베이스를 생성하고 관리하는 작업입니다. MySQL, PostgreSQL, MongoDB와 같은 인기있는 데이터베이스가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n웹 개발은 일반적으로 프론트엔드, 백엔드 및 풀스택 개발 세 가지 주요 범주로 나뉩니다. 각각은 기능적인 웹 애플리케이션을 구축하는 데 중요한 역할을 합니다.\n\n프론트엔드 개발, 또는 클라이언트 측 개발로도 알려져 있으며 사용자가 직접 상호작용하는 웹 사이트 부분에 초점을 맞춥니다. 이는 사용자가 웹 브라우저에서 보거나 상호작용하는 모든 것을 포함합니다. 레이아웃, 버튼, 이미지 및 폼 등이 포함됩니다.\n\n- HTML (Hyper Text Markup Language): 웹 페이지를 생성하는 데 사용되는 표준 마크업 언어로, 웹의 내용을 구조화합니다.\n- CSS (Cascading Style Sheets): HTML로 작성된 문서의 표현을 설명하는 스타일시트 언어로, 레이아웃, 색상, 폰트 및 전반적인 스타일을 제어합니다.\n- JavaScript: 상호작용적인 웹 페이지를 만들 수 있는 프로그래밍 언어로, 동적 콘텐츠 생성, 멀티미디어 제어, 이미지 애니메이션 등 다양한 용도에 사용됩니다.\n- 프론트엔드 프레임워크 및 라이브러리: React, Angular, Vue.js와 같은 도구를 사용하여 재사용 가능한 컴포넌트와 효율적인 상태 관리를 제공하여 프론트엔드 개발을 단순화하고 향상시킵니다.\n\n![이미지](/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_1.png)\n\n<div class=\"content-ad\"></div>\n\n백엔드 개발 또는 서버 측 개발은 웹 사이트의 서버 측에 초점을 맞춥니다. 이는 데이터를 처리하고 전면에서 의도한 대로 작동하도록 하는 메커니즘을 생성하고 유지하는 작업을 포함합니다. \n\n- 서버 사이드 언어: Python, Ruby, Java, PHP, C#과 같은 언어들이 서버 측 로직을 작성하는 데 일반적으로 사용됩니다.\n- 프레임워크: Express(Node.js), Django(Python), Ruby on Rails(Ruby), ASP.NET(C#)과 같은 프레임워크는 견고한 백엔드 애플리케이션을 개발하기 위한 구조와 도구를 제공합니다.\n- 데이터베이스: MySQL, PostgreSQL, MongoDB, SQL Server 등의 데이터베이스는 웹 애플리케이션의 데이터를 저장하고 관리합니다.\n- API (Application Programming Interfaces): RESTful 및 GraphQL API는 전면 및 백엔드 간, 백엔드 서비스 간의 통신을 활성화하는 데 사용됩니다.\n\n<img src=\"/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_2.png\" />\n\n풀 스택 개발은 개발자가 웹 애플리케이션의 전면 및 백엔드 부분 모두에 작업하는 포괄적인 접근 방식을 의미합니다. 풀 스택 개발자는 넓은 스킬 세트를 갖추고 프로젝트를 처음부터 끝까지 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n주요 기술:\n\n- 프론트엔드 및 백엔드 기술 능숙\n- 데이터베이스 및 데이터 관리 이해\n- Git과 같은 버전 관리 시스템에 대한 이해\n- API 작업 및 다른 서비스 통합 능력\n\n숙련된 웹 개발자가 되기 위해서는 다양한 도구와 기술에 익숙해져야 합니다. 여기 몇 가지 필수 요소가 있습니다:\n\n텍스트 편집기 및 통합 개발 환경(IDE): Visual Studio Code, Sublime Text, IntelliJ IDEA와 같은 도구는 코딩에 효율적인 환경을 제공합니다.\n버전 관리 시스템: Git은 가장 인기 있는 버전 관리 시스템이며, GitHub, GitLab, Bitbucket과 같은 플랫폼은 협력 개발과 코드 공유를 용이하게 합니다.\n패키지 관리자: npm(Node Package Manager)와 yarn과 같은 도구는 프로젝트 의존성 및 라이브러리를 관리하는 데 도움을 줍니다.\n\n<div class=\"content-ad\"></div>\n\n- HTML/CSS/JavaScript: 웹 페이지를 구축하고 스타일링하는 데 필수적인 핵심 기술들입니다.\n- 프런트엔드 프레임워크/라이브러리: React, Angular, Vue.js는 동적 사용자 인터페이스를 구축하는 데 인기 있는 선택지입니다.\n- 반응형 디자인: Bootstrap 및 Foundation 같은 프레임워크는 반응형 및 모바일 친화적인 디자인을 도와줍니다.\n\n- 서버 사이드 언어: JavaScript (Node.js), Python, Ruby, Java, C#과 같은 언어들이 있습니다.\n- 백엔드 프레임워크: Express (Node.js), Django (Python), Ruby on Rails (Ruby), ASP.NET (C#) 등이 있습니다.\n- 데이터베이스: MySQL, PostgreSQL와 같은 SQL 데이터베이스와 MongoDB와 같은 NoSQL 데이터베이스가 있습니다.\n\n- 버전 관리: Git과 GitHub 같은 플랫폼입니다.\n- 작업런너 및 모듈 번들러: Gulp, Grunt, Webpack과 같은 도구들은 반복적인 작업을 자동화하고 JavaScript 파일을 번들링하는 데 도움이 됩니다.\n- API 테스팅 도구: Postman 및 Insomnia는 API를 테스트하고 디버깅하는 데 유용합니다.\n\n웹 개발은 다양한 기술과 지식을 요구하는 다각적인 분야입니다. 프런트엔드, 백엔드 및 풀스택 개발의 차이를 이해하고 필수 도구와 기술에 익숙해지면 능숙한 웹 개발자로 나아갈 수 있습니다. 앞으로의 블로그에서는 웹 개발의 각 측면을 더 자세히 살펴보며 실전 예제와 상세한 설명을 제공하여 견고하고 동적인 웹 애플리케이션을 만드는 과정을 안내할 예정입니다.","ogImage":{"url":"/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png"},"coverImage":"/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png","tag":["Tech"],"readingTime":4},{"title":"Tailwind CSS로 가독성 좋은 웹사이트 만드는 방법","description":"","date":"2024-05-20 23:01","slug":"2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS","content":"\n\n\n![Tips for Writing Maintainable and Readable Code with Tailwind CSS](/assets/img/2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS_0.png)\n\n웹 개발에서 깔끔하고 확장 가능한 코드베이스를 유지하는 것은 매우 중요합니다. 특히 대규모 프로젝트에서 스타일을 관리할 때는 더욱 그렇습니다. Tailwind CSS는 유용성이 우선인 CSS 프레임워크로, 애플리케이션을 효율적으로 스타일링하는 구조화된 방법을 제공합니다. 그러나 모든 도구와 마찬가지로, Tailwind의 장점을 최대로 발휘하려면 최상의 관행을 준수해야 합니다. 아래에서는 유지보수 가능하고 가독성 있는 Tailwind CSS 코드를 작성하는 핵심 전략에 대해 실용적인 예제를 통해 살펴봅니다.\n\n## 유틸리티 클래스의 일관된 순서\n\nHTML 요소에서 유틸리티 클래스의 일관된 순서를 유지하면 스타일을 쉽게 스캔하고 수정할 수 있습니다. 예를 들어, 표시 속성(display: flex, grid)으로 시작하여 위치 지정 (m, p), 그 다음에 글꼴 (text-, font-), 마지막으로 색상 및 그림자와 같은 코스메틱 스타일로 끝나는 규칙을 정의하세요.\n\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n이 예시에서는 레이아웃 속성(flex, flex-col)이 먼저 정의되고, 간격(p-4, md:p-8), 배경(bg-white), 그림자(shadow-lg), 그리고 둥근 모서리(rounded-lg)가 따릅니다. 타이포그래피 속성 (text-2xl, font-bold, text-gray-900)은 텍스트 요소에 적용됩니다.\n\n## 반응형 접두사 활용하기\n\n시스템적으로 반응형 접두사를 사용하면 스타일이 기기에 맞게 신속하게 적응합니다. 항상 가장 작은 브레이크포인트부터 시작하여 일관성을 유지하면서 작업해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n이 `div`는 텍스트 크기를 뷰포트 너비에 따라 조정합니다. 텍스트 크기는 모바일에서 `text-base`부터 태블릿에서 `text-lg`, 데스크톱에서 `text-xl`로 증가합니다.\n\n## 반복되는 유틸리티 패턴에 @apply 활용\n\n다양한 컴포넌트에서 동일한 유틸리티 클래스 조합을 반복적으로 사용할 때, @apply 지시문을 사용하여 CSS 파일에서 이를 결합하여 중복을 줄일 수 있는 사용자 지정 클래스로 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n여기서 일반 버튼 스타일링은 .btn-primary 및 .btn-secondary 클래스로 추상화되어 HTML을 깔끔하고 집중할 수 있습니다.\n\n## 복잡한 컴포넌트용 컴포넌트 클래스 구현\n\n더 복잡한 컴포넌트의 경우 특정 컴포넌트 클래스를 만드는 것이 더 실용적일 수 있습니다. 이렇게 하면 세부 스타일을 캡슐화할 수 있으면서도 작은 조정에 유틸리티 클래스를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n이 예시에서는 .card 클래스가 모든 일반적인 스타일을 다루며, 유틸리티 클래스는 카드 내의 요소에 직접 추가하여 특정 조정을 할 수 있습니다.\n\n## PurgeCSS 통합\n\nPurgeCSS를 빌드 프로세스에 통합하면 실제로 사용되는 스타일만 제작 파일에 포함되어 파일 크기가 크게 줄어듭니다.\n\n<div class=\"content-ad\"></div>\n\n이 구성은 PurgeCSS를 설정하여 HTML 및 Vue 파일을 스캔하여 최종 CSS에서 사용되지 않는 Tailwind 클래스를 제거합니다.\n\n# 결론\n\nTailwind CSS에 대한 이러한 모범 사례를 채택하면 코드의 가독성과 유지 관리성뿐만 아니라 응용 프로그램의 전반적인 성능도 향상됩니다. 일관된 패턴을 설정하고 내장 유틸리티를 지능적으로 활용하며 깨끗한 코드베이스를 유지하여 개발자는 Tailwind CSS의 강력함을 완전히 활용하여 멋진 효율적인 웹 인터페이스를 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS_0.png"},"coverImage":"/assets/img/2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS_0.png","tag":["Tech"],"readingTime":3},{"title":"웹사이트 속도와 품질 테스트하기","description":"","date":"2024-05-20 22:55","slug":"2024-05-20-TestingWebsiteSpeedAndQuality","content":"\n\n\n![Speed and Quality](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_0.png)\n\n웹 사이트나 애플리케이션의 속도, 크기 및 효율성은 사용자뿐만 아니라 백엔드에서도 가장 중요한 요소 중 하나입니다. 큰, 뚱뚱하고 부풀어 올라간 코드베이스는 프레임워크 팬보이들의 반대 주장에도 불구하고 작업이 어려워지며, 초과 서버 부하를 초래합니다.\n\n접근성 및 효율성 컨설턴트로 프리랜싱을 하면서 지난 15년 동안 수많은 웹사이트를 살펴본 적이 있습니다. 이러한 웹사이트들은 매우 낮은 트래픽을 처리하기 위해 고군분투하고 있는 것으로 나타났습니다. 콘텐츠와 기능이 $10/mo VPS보다 더 필요하지 않은 매니지드 전용 호스팅 계획으로 다중 프로세서 비용이 많이 드는 것입니다.\n\n그러나 가장 끔찍한 것은 해당 사이트들이 \"반드시 그렇게\" 되어야 하는 무수한 엘리베이터들이다. \"기업용 등급\"이라고 주장하며 (\"그게 실제로 무엇을 의미하는지. \"바보들이기 때문에 쓰레기인가 봅니다\"); \"협업을 위해 필요한 코드를 십 배로 작성해야한다\" 또는 \"새로운 입사자를 빠르게 숙달\" 시킬 필요가 있다고 주장하는 등 자신의 무능함을 덮기 위한 모든 헛소리와 함께. 내 이전 기사의 댓글을 다시 읽어보면 많은 귀찮은 변명들을 볼 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n살인범은 빠른 웹사이트를 만드는 것이 어렵지 않다는 것이 가장 중요한데요. 그에 대해 이전에 글을 썼었습니다:\n[여기를 클릭하세요!](https://medium.com/codex/so-you-want-to-make-your-website-faster-d2a00db39097)\n\n하지만 기존 웹사이트의 속도를 분석하는 것은 대부분의 사람들이 처리하기 어려운 기술을 요구합니다. HTML, CSS를 알고 있고 관심을 가지고 있다면 쉬울텐데요. 안타깝게도, 프레임워크를 사용하는 바보들, 백엔드 개발자들이 프런트엔드를 다룰 수 있다고 속이는 사람들, \"웹 디자이너\"라는 착각에 빠진 예술가들, 전체 과정에 대한 큰 문제를 일으키는 많은 다른 사람들이 거의 제로로 기술합니다.\n\n이를 해결해보겠습니다.\n\n# 추천 도구\n\n<div class=\"content-ad\"></div>\n\n자동화는 일반적으로 플레이스보로 사용됩니다. 머리 속에 있는 것을 활용하지 않으면 정확하지 않습니다. 모든 것이 약간의 출발점으로 사용할 수는 있지만 그것이 하는 일을 큰 그릇으로 받아들여야 한다는 것이죠.\n\nGoogle Lighthouse은 대부분의 Blink 기반 Chrome과 유사한 브라우저(Chrome, Vivaldi, Opera, \"최신\" Edge 릴리스)의 검사 도구로 내장되어 있습니다. Lighthouse는 속도, 사용성, 접근성, 이미지 최적화, 파일 형식과 관련된 여러 문제를 지적할 수 있습니다. 아마도 우리에게 주어진 최고의 자동화 도구일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 그러나\n\n저는 등대가 수백 개의 개별 파일로 구성된 2MB 페이지에 100% 완벽한 속도 점수를 주는 것을 본 적이 있고, 동시에 6개 이하의 파일로 만든 50k 페이지에는 50%의 점수를 주었습니다. 물론 등대가 제시하는 내용을 사용하여 최적화하는 것을 권장하지만, 페이지가 빠른지 여부를 확인하는 데는 좋은 도구가 아니라고 생각합니다. 이 도구는 페이지가로드된 후에 \"렌더(render)\"와 같은 것을 과대평가하고 파일 수와 크기를 지나치게 과소평가합니다.\n\n예를 들어, 이 FailwindUI 쓰레기 코드를 살펴보십시오:\nhttps://spotlight.tailwindui.com/about\n\n이는 26개 파일에서 615k이며, 압축 해제하면 218k로 감소됩니다. 따라서 파일 수만으로 최악의 경우 18초의 오버헤드가 발생합니다. 실제 세계에서는 3초 정도로 설명하겠습니다. 그런데 왜 이러는 걸까요? 1.4k의 일반 텍스트와 하나의 콘텐츠 미디어(우주 비행사 이미지)인가요? 심지어 파일 9개로 52k도 안 되는 일입니다.\n\n<div class=\"content-ad\"></div>\n\n캐시를 활용하지 않도록 작성되었고, 효율성을 덮어두려는 것보다는 \"아무것도 아닌 SPA\"로 스크립트를 던져 처리하려고 하며, 이는 \"더 많은 코드를 던져 더 빠르게 만들 수 있다\"는 어리석음의 전형입니다.\n\n그럼에도 불구하고, 이것의 라이트하우스 점수는 무엇인가요?\n\n![텍스트](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_2.png)\n\n저는 \"성능\"을 주면서 60점을 줄 것입니다. 그런데 왜 그렇게 후하다고 생각하나요?\n\n<div class=\"content-ad\"></div>\n\n라이트하우스는 실제 세계의 제한 없이 당신의 연결 속도와 그들의 연결 속도에 기반을 두고 있어요. 광섬유의 마법 땅에 있는 우리에게는 어떤 쓰레기도 꽤 괜찮은 점수를 얻을 수 있어요.\n\n하지만 그 기준으로 대부분을 가리킴을 살펴보세요. 전송 시간은 심지어 나열되지 않았어요. First paint, contentful paint? 그것은 렌더링이죠. 최적화하기에 유용하지만, 확실히 페이지 속도의 전부가 아니에요.\n\n이것은 이전 게시물을 위해 한 페이지의 리라이트를 사용하여 명백해져요: https://cutcodedown.com/for_others/medium_articles/failwindUI/shotlightFull/about.php\n\n여기에서 라이트하우스 점수가 거의 동일합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![TestingWebsiteSpeedAndQuality](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_3.png)\n\n전송 크기의 1/5이지만 파일 개수의 1/4, DOMContentReady에 도달하는 시간은 1/3로 단축되며 서브 페이지에 대한 사전 캐싱을 활용하여 SPA / CSR JavaScript의 90%가 무의미한 코드 팽창으로 소멸되는 경우가 있습니다...\n\n그러나 통계와 마케팅을 진지하게 검토하는 사람들이 이 두 숫자를 매우 심각하게 받아 듭니다. 사용자가 사이트를 3초 안에 포기할 수 있다는 사실을 알기 때문입니다! 4초 이상이면 25% 이상의 탈퇴 위험이 있으며, 그 이후로매초마다 16%가 증가합니다.\n\n탈퇴란 사용자가 \"이건 말아먹겠다. 다른 데 가야지!\" 하는 것을 비하한 용어입니다.\n\n\n<div class=\"content-ad\"></div>\n\n그 접속 속도가 관련이 있는 것 뿐만 아니라 속도 점수는 도구가 만들어진 시간에 다른 웹 사이트와 상대적으로 기반을 두고 있습니다. 따라서 웹이 만들어진 시점에 좋지 않았다면, 어떤 시점을 넘어서면 더 나은 것이 있다고 말할 \"여력\"이 없습니다.\n\n또한 이러한 높은 평가를 개발자로서 우리 스스로에게 돌릴 수도 있습니다. 두 예제 모두 저 트래픽 환경에서 운영되며 괜찮은 호스팅 환경에서 작동합니다. 이 데모 템플릿들이 다뤄야 할 연결 제한, 서버 부하 또는 다른 여러가지 실제 웹 사이트에서 다뤄야 하는 것들과 부딪히지 않습니다.\n\n그래서 라이트하우스에 대해서는 \"수리해야 할 것을 수리하라\"고 말합니다. 그것은 그런 일에 대한 놀라운 도구입니다. 그 수리를 하면 페이지가 더 빨라지고 더 접근 가능해질 것입니다. 그저 \"100 성능\" 평가를 신뢰하지 마세요. 이것은 실제 사이트 속도의 좋은 지표가 아닙니다.\n\n## 파이어폭스\n\n<div class=\"content-ad\"></div>\n\n\n![Testing Website Speed and Quality](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_4.png)\n\n브라우저는 속도 평가에 중요한 부분입니다. 자동화를 믿지 말고 실제 브라우저에서 실제 환경에서 테스트하는 것이 더 현명합니다.\n\n각 브라우저 엔진은 파티에 자신만의 특별한 도구를 가져옵니다. 파이어폭스의 검은 네트워크 탭은 실제 파일 크기를 보여줍니다. 압축된 크기뿐만 아니라 실제 크기를 보여주죠. 크롬 같은 세부사항은 보여주지 않습니다!\n\n파이어폭스에서 페이지를 로드하고 문서 인스펙터를 열려면 마우스 오른쪽 버튼을 클릭하고 \"검사\"를 선택하거나 F12를 누르세요 — 그 안에 탭이 나타납니다. 위의 FailwindUI 템플릿을 사용하여 \"네트워크\" 탭으로 이동하고 캐시를 지우고 페이지를 다시 로드하세요: CTRL-F5\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_5.png)\n\n우리는 모든 파일에 대한 \"폭포수\"를 얻습니다. 기본 정렬 순서는 파일이 로드된 순서이며, 오른쪽의 그래프에서는 지연, 핸드셰이킹, 전송 시간을 보여줍니다. 두 가지 파일 크기를 얻을 수 있습니다: 실제 파일 크기 및 전송될 때의 크기. 후자의 숫자는 일반적으로 파일이 gzip 압축으로 전송된 경우 더 작을 것입니다.\n\n푸터에 있는 정보도 중요합니다. DOMContentLoaded는 브라우저가 페이지 렌더링을 시작하기에 충분한 정보를 갖고 있다고 판단하는 시간이며, \"로드\"는 기본적으로 렌더링이 완료된 시점입니다. 자주 JavaScript의 로드 후 파일이 있을 수 있으며, 이는 Reflow를 강제할 수도 있습니다(결과적으로 불편한 동작이 발생할 수 있음) 또는 사용자가 아직 수행하지 않은 조치를 위해 로드될 수 있습니다.\n\n또한 파비콘은 항상 페이지가 \"완료\"된 후에 로드됨을 기억해 주세요.\n\n\n<div class=\"content-ad\"></div>\n\n사람들이 종종 내게 물어보는 질문 중 하나는 내가 얼마나 많은 파일이 로드되었는지 또는 총 크기가 얼마인지를 어떻게 알 수 있는지이다. 여기 있습니다.\n\n## Chrome처럼\n\n![이미지](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_6.png)\n\n속도 테스트에 대한 가장 큰 실수 중 하나는 자기 연결이 \"일반 사람들이 얻는 것\"을 대표한다고 믿는 것입니다. \"하지만 내게는 빠르다\"란 오류로 이어집니다. 여러분은 항상 내가 말하는대로 알고 있어요:\n\n<div class=\"content-ad\"></div>\n\n당신과 당신의 마법 같은 판타지 세계의 네트워크 연결이나 완벽한 5G 수신만이 중요한 건 아니에요, 다른 사람들도 중요한 거예요.\n\n특히 바보 같은 사람들이 그런 사용자들을 \"가난뱅이\"라고 불러서 더욱 짜증스러울 수 있어요. 실제로 그냥 '계급 전쟁'으로 빠지는 거죠.\n\n따라서 연결을 인위적으로 제한하면, 허위 인식을 없앨 수 있어요. 안타깝게도 Firefox의 네트워크 탭은 연결 제한이 활성화되면 종종 페이지의 하위 파일을 다시로드하지 않을 수 있어요. 그러면 제한하는 의미가 없어지죠. 그래서 Chrome과 비발디(Vivaldi)와 같은 브라우저의 동등한 기능을 사용해야만 해요. 그렇게 하면 됩니다. 저의 일상용 운전사람이에요.\n\n파일 크기를 실제로 보여주지 않지만, 테스트 단계에서 우리는 실제로 전송되는 것에 더 관심이 있어요.\n\n<div class=\"content-ad\"></div>\n\n두 번째 툴바 아래에 \"스로틀링 없음\"이라고 쓰인 드롭다운이 있어요. 그 드롭다운의 기본 값은... 좀 부족해요.\n\n그래서 보통 이런 설정을 추가해서 \"실제 세계\"를 시뮬레이션해요:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_9.png\" />\n\n다운로드 속도 2 Mbits, 업로드 속도 512kbits, 지연 시간 200ms입니다. 패킷 손실은 걱정하지 마세요. 이것은 우리의 요구를 충분히 제한할 것입니다.\n\n이 속도 제한으로 동일한 네트워크 폭포도를 가져올까요?\n\n<img src=\"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_10.png\" />\n\n<div class=\"content-ad\"></div>\n\n그렇게 끔찍하게 보이지는 않을 수도 있어요 — 25개 요청이 있는 병렬처리는 여전히 많은 나쁜 선택지들을 집어삼키고 있답니다. 하지만 그래서 연결 제한을 조절할 수 없는 자동화에 대해 우리 스스로 속임수를 부리고 있는 것 아닐까 싶어요. 그래도 제가 쓴 것과 비교해보세요:\n\n![image](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_11.png)\n\n어쨌든, 저는 한 가지 방안을 제안해요 — Blink(크롬과 비슷한 엔진)과 Gecko(파이어폭스, 아이스위젤 등) 모두를 사용해보세요. 호환성 뿐만 아니라 속도와 도구 사이의 차이점을 테스트하기 위해서죠. 네트워킹 워터폴은 여러분의 친구입니다. 여러분의 로드 순서에서 병목 현상이 발생하는 곳을 정확히 파악하는 데 도움이 될 거예요.\n\n# 페이지스피드 인사이트: 비추천!\n\n<div class=\"content-ad\"></div>\n\n\"구글 '페이지속도'는 한때 — 10년이 넘게 전— 유용한 도구였습니다. 그러나 그 이후로 그 저의는 희석되었고, 오도된, 오해되고, 오늘날에는 사실보다는 플래이스보로 여겨지고 있습니다. 어느 순간에는 마케팅 사기 같은 느낌까지 들었죠!\n\n그 하락 추세는 실질적인 해를 가져오는 요소에 중점을 두기 시작했을 때 시작되었습니다. 이에 대한 한 예로 '페이지의 폴드 위' CSS를 마크업에 넣는 어리석은 방법이 있습니다. 이것은 '캐시를 비우는 첫 번째 로딩'을 가속화할 수 있지만, Bootcrap이나 Failwind 같은 멍청한 쓸모없는 쓰레기의 비용을 지불하게 됩니다. 예를 들어, 지연된 HTTP 병렬성, 하위 페이지 전체에 걸쳐 공유하는 스타일에 대한 사전 캐싱 기회의 놓침, 재방문 시 캐싱 놓침 등이 있습니다. 'text-center col-4-s col-6-m text-400-red'와 같은 클래스가 무식한 헛소리라는 것과 마찬가지로 정적 마크업에 'style' 태그의 순수 존재도 무식한 헛소리라고 말할 수 있습니다. 주목할 점은 그게 마크업 안에 있다는 것이며, 페이지 로드 후 스크립팅 전용 스타일로 추가되는 것에는 문제가 없습니다.\n\n그리고, 문서 검사기는 소스/마크업을 표시하지 않습니다. 그것은 DOM을 보여줍니다!\n\nPageSpeed에 나쁜 조언이 스며들기 시작할 때 그것들이 끌어 당겼던 상황이 확실해졌습니다. 우리에게 유용한 도구를 제공하여 우리를 중독시킨 후, \"페이지속도 서비스\"라는 우리를 속이려는 쓰레기 'CDN 대체'를 이용하도록 조장하는 마케팅 플랫폼으로 사용했습니다.\"\n\n<div class=\"content-ad\"></div>\n\n\"서비스\" 라는 말은 고객을 정말로 섬기고 있습니다. \"속도\"를 불필요하게 느린 것을 고쳐 사용할 수 없는 클라이언트 측 스크립팅의 꼬마 조각들로 만드는 동시에 그렇지 않으면 건강한 사이트를 운영하는 데 더 비싼 방향으로 만들고 있어요!\n\n사기, 사기, 사기 같은 말을 자주 쓰는 건 알아요... 하지만 정말… 제발요.\n\nGoogle PageSpeed가 말하는 거 하나 믿지 말라고 권하고 싶네요. 라이트하우스가 비슷한 운명을 맞이하지 않기를 바랄 뿐이에요.\n\n# 진정 중요한 것은 무엇인가\n\n<div class=\"content-ad\"></div>\n\n도구가 무엇인가를 알려준다고 해서 항상 그 의미를 완전히 이해한다는 것은 아니에요. 마찬가지로, 자동화된 도구는 주로 시작하는 지점이며 여전히 올바르게 사용하기 위해 약간 자신의 뇌를 사용해야 합니다. 라이트하우스의 숫자를 보고 \"괜찮아\"라고 생각하기가 너무 쉽습니다. 심지어 그렇지 않을 때도요.\n\n실제로 걱정해야 할 세 가지 주요 요소가 있어요. 도구들은 당신이 가진 것을 말해줄 뿐, 꼭 필요한 것이나 여전히 문제가 있는지를 반드시 알려주진 않아요.\n\n## #1 대역폭과 파일 크기\n\n이것은 가장 쉽게 평가하고 문제 해결할 수 있는 부분이에요. 또한, 무능한 사기꾼들이 때때로 \"모두가 이제 브로드밴드를 갖고 있다\"고 사측적으로 무시하거나 피할 다른 쓸데없는 변명을 찾기 때문에 그들이 가장 쉽게 무시하는 부분 중 하나에요.\n\n<div class=\"content-ad\"></div>\n\n이러한 \"무시\"의 실제 예시로 최근 다른 프로그래머가 내가 개선할 때 \"최적\" AVIF 대신 PNG 사용했어야 했다며 화를 내서 몹시 화를 내는 상황이 있었습니다. 20k를 절약할 수 있었다고 했죠. 그는 내가 \"허튼 소리만 한다\"는 예시로 사용했습니다. 전 그냥 2.5 메가바이트의 \"아무 의미없는\" JS를 12k의 코드로 교체했다는 사실을 완전히 무시했습니다. 더구나 해당 클라이언트는 의료 시설로, IE7이 최첨단이었던 Win ME 기반의 얇은 클라이언트를 사용하고 있습니다. IE에서 AVIF나 webp는 지원되지 않습니다.\n\n많은 개발자들은 반복적으로 자신의 HTML, CSS 및 JavaScript 크기를 무시하면서 대역폭을 절약하기 위해 가능한 모든 자동화를 시도합니다. 그래서 무능한 jQuery, Tailwind, Bootstrap과 같은 것들이 위험한 이유입니다. 제가 계속 강조해 온 것처럼:\n\n사실 미디어 파일 - 오디오, 비디오, 이미지 - 가 코드보다 세 배 이상이나 작아지는 것이 흔해졌습니다. 그 중 대부분의 책임은 JavaScript의 몫입니다. 또한 며칠전에도 말한 바 있듯이, jQuery로 수행된 것 중 세 가지 범주에 속하지 않는 것은 본 적이 없습니다:\n\n- JavaScript 없이 할 수 있는 HTML 및 CSS 작업\n- jQuery 없이 더 간단하고 코드가 적은 작업\n- 웹사이트나 어플리케이션에서 하면 안 되는 작업들\n\n<div class=\"content-ad\"></div>\n\n이제는 JavaScript를 사용하여 80% 이상을 수행하는 작업에 대해서도 확장해야 한다고 생각합니다. Typescript와 같은 Transpiler는 출력 코드의 크기가 얼마나 크든 상관하지 않고, 더 복잡하고 유지보수하기 어려운 코드를 작성하도록 장려합니다; React나 Angular와 같은 쓸데없는 프런트엔드 프레임 워크가 서버의 \"잘못된 쪽\"에서 작업을 수행함; 모달 대화 상자나 햄버거 메뉴와 같은 스크립팅 요소를 사용하여 `esc` 키를 눌러 닫히도록 하는 일이 정말 필요한 일인데도 불구하고 1k가 딱 헤더에 들어가도록 presentational한 디자인이 해결되어 있는 것처럼 표시하지 않습니다.\n\nBootcrap나 Failwind와 같은 프런트엔드 프레임워크 쓰레기통과 같은 무능한 재앙도 마찬가지 입니다. 이러한 것들을 사용하도록 속이거나, 사용하지 않았을 때보다 훨씬 더 많은 코드를 작성할 수 있게끔 꾀어냅니다; HTTP 병렬 처리를 지연시키며, 캐싱 기회를 놓치게 하며, 작업을 수행하는 데 필요한 코드 양의 2배에서 10배까지 배포합니다.\n\n그리고 사람들이 \"Simple Jack\"이 멋진 여자 앞에서 마주하는 것 처럼 자신들의 사이트나 앱이 느리다고 궁금해 할 때도 있습니다.\n\n<img src=\"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_12.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 모든 것에 대해 생각하는 것은 자동화된 도구가 사람들을 잘못된 안전감에 빠트리고 있다는 점이라고 생각해요. 이미지 최적화, 파일 축소? 모두 좋고 필요한 작업이죠. 하지만 거기서 멈추어선 안 돼요!\n\n코드 부풀림; 의존성 지옥; 아무 의미 없는 파일들을 위해 개별 파일; 아무 의미 없는 파일을 위한 통합 파일 (모든 것을 마크업에 넣는 것 같은 행위); 아무 의미 없는 추가 함수들. 지금 대부분의 쓰레기를 만드는 사람들의 능력에 대해 의문을 제기하게 되는 부분들이 점점 더 성능, 지속 가능성, 유지 관리성과 관련하여 더욱 걱정되는 부분이죠.\n\n의미 있는 그림이 나타나기 전에 HTML의 크기와 스크립팅이 얼마나 큰지는 아마도 가장 중요한 파일들 중 하나이자 무시되는 부분일 수도 있어요. 왜냐하면 HTTP 병렬성을 연기하고 캐싱 기회를 놓치고 있기 때문이거든요.\n\nFF와 Chrome과 같은 워터폴을 보세요. 문서가 완료될 때까지 다른 것들이 로딩 될 수 없다는 것을 보세요. 저의 계산기 데모에서 가져온 것들 처럼요.\n\n<div class=\"content-ad\"></div>\n\n하위 파일이 HTML 작성이 완료될 때까지 다운로드를 시작할 수 없습니다. 그리고 HTTP 2.0 푸시 또는 HTML 5 사전로드 / 모듈 사전로드도 이를 해결하지 못합니다! 다른 사람들이 말하는 대로라고 주장할 수 있을지라도.\n\n그래서 HTML 파일에 불필요한 것들을 넣을수록( \"text-large text-center text-400-red\"와 같이) 다른 모든 파일의 다운로드를 지연시키며, HTTP가 여러 파일을 동시에 전송할 수 있는 능력을 최대한 활용할 수 없게 됩니다. (여러 패킷이 A지점에서 B지점 사이의 다른 경로를 통해 이동할 수 있기 때문입니다)\n\n같은 스타일을 여러 페이지에 걸쳐 공유할 경우 캐싱 기회를 놓치게 됩니다. 각 방문뿐만 아니라 같은 방문 내에서 페이지 간에도 캐싱이 가능한 외부 파일로 모든 것을 이동시킬 수 있는데, 이러한 부분이 CSS가 존재하는 이유입니다. 스타일을 정적으로 설정하는 것이 아니라 마크업에서 \"style\"을 지정해야하며 외관을 고르게 만들기 위해 \"style = \"\"을 사용해야 합니다. 그리고 \"이 것은 작은 화면에 4열, 큰 화면에는 6열로 중앙 정렬된 텍스트와 빨간색으로 표시되는 것\"을 나타내는 클래스가 무지하고 무능력한 반대표! 프레임워크뿐만 아니라 전체 \"컴포넌트\"의 어리석은 사고도 물어뜯어야 합니다. HTML 3.2 이해의 최전선이 미래가 되어서는 안됩니다.\n\n<div class=\"content-ad\"></div>\n\n아니요, \"원자적\"이나 \"유틸리티\" 클래스가 얼마나 무지하고 불행하며 쓸모 없는 쓰레기인지 정말로 표현할 수 있는 공손한 말은 없습니다.\n\nHTML의 미리 정의된 태그들이 의미를 갖기 때문에, 관심사의 분리를 실천하면 실제로 콘텐츠와 목적에 따라 HTML의 크기를 추정할 수 있습니다... 적어도 대부분의 전통적인 웹 페이지에 대해 해당합니다. 저는 다음 공식을 사용합니다 (모든 값은 바이트 단위)\n\n2048 +\n일반 텍스트 * 1.5 +\n앵커 (또는 A의 작업을 하는 버튼) * 192 +\n폼 요소 (input, select, textarea, option) * 128 +\n미디어 (img, video, audio) * 256\n\n2k는 `!DOCTYPE`에서 `/head`까지의 모든 것이 포함되어야 하는 상한선이며, 콘텐츠 당 50% 비용은 완전히 합리적입니다. 192는 URL이나 INPUT/TEXTAREA/SELECT/OPTION 크기에 대한 관대한 추정치이며, 미디어 요소에 대한 256바이트 역시 그러한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n보통 견적을 50% 이상 초과하면 페이지에 문제가 있습니다. 그러면 이를 두 배 이상 초과하면, 웹 기술과 전혀 관련이 없는 사람들이 만든 무식하고 무능한 쓰레기입니다.\n\n웃기게도, 웹 앱이라면? 4k. 플랫. 그 이유는 마크업에 있는 건 헤더 안의 내용(스타일시트 로드, 프리로드, 제목), 'script' 로드, 그리고 'noscript' 경고뿐이어야 하기 때문입니다. 당신의 \"마크업\"이 스크립팅이 있는 상태에서만 기능한다면, 그것을 블러디 HTML이 아닌 스크립트에 구축하세요!\n\n\"일반 텍스트\"를 가져오는 방법이 궁금하다면, 그냥 HTML 없는 페이지 텍스트를 의미합니다. 바로 'body' 내의 모든 CDATA (문자 데이터)입니다. 기존 페이지에서 그것을 추출하는 가장 쉬운 방법은 브라우저에서 열고, CTRL-A를 눌러 전체 선택한 후, CTRL-C로 복사하고, 그것을 평문 편집기에 CTRL-V하여 얼마나 많은 텍스트가 있는지 확인하는 것입니다.\n\n퇴보한 부트스트랩의 가격표 페이지를 예로 들어 보겠습니다:\nhttps://getbootstrap.com/docs/5.3/examples/pricing/\n\n<div class=\"content-ad\"></div>\n\n평문 888바이트, 앵커(또는 버튼) 20개 및 미디어 요소 하나를 포함하고 있어야 할 텐데, 그렇게 되면 5,428바이트가 되겠네요. 그들은 어느 정도의 HTML을 사용했을까요? 17.3k! 사람들은 내가 그들의 무능한 쓰레기를 계속해서 비난하는 이유에 대해 궁금해할 것입니다.\n\n몇 년 전에 쓴 것을 고려해보세요:\nhttps://cutcodedown.com/for_others/medium_articles/bootStrapRewrites/pricing/pricing.template.html\n\n이는 HTML을 올바르게 사용하며, 마크업에 형식화 클래스를 주입하지 않습니다. 그 결과 5,528바이트에 불과합니다. 나의 공식이 제공한 \"대략값\"과 거의 일치하죠.\n\nCSS도 상당히 예측 가능합니다. 사이트의 단일 페이지에 대해 약 20k 정도가 대체로 정상이지만, 전체 사이트에 대해서는 공유되어야 하는 스타일 양 때문에 미디어 대상에 대한 상한선은 48k입니다. 많은 웹 사이트에서 필요로 하는 것은 48k으로 media=\"screen\"용 하나 또는 두 개의 파일이고, 대체로 인쇄의 역할은 쓸모없는 것들을 제거하고 단색으로 가기 때문에 media=\"print\"용 32k의 CSS로도 충분합니다. 전체 사이트에 대해서 말이죠!\n\n<div class=\"content-ad\"></div>\n\n스크린과 인쇄용으로 총 80k가 넘는 CSS 파일이 세 개나 네 개 필요 없어. 그거야!\n\n...그리고 왜 저 부끄럽고 무식한 것들이 있는 부트크랩 페이지는 엉성하고 느리고 작업하기 힘든 말도 안 되는 것으로 만들어졌는지, 웹 기술을 사용하는 방법을 아는 게 아닌 사람들에 의해 만들어졌다! (Failwind도 마찬가지야!). 어떻게 말해야 할까?\n\n![이미지](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_13.png)\n\n그렇게 말이야. 부트크랩은 압축 시 최소한 전체 사이트의 2/3는 되는데, 왜냐하면 계속해서 마크업에 당신을 허술하게 만들기 때문이야? 압축하지 않았을 때, 그들의 라이브러리가 아닌 CSS는 14k이며, 그것들을 합쳐도 전체 페이지는 HTML+CSS로 32k이야... 즉, 현재 단일 페이지이며, 그들의 독특한 코드 — 부트스트랩을 제외한 것 —은 10.3k인 내 리라이트와는 달리 세 배가 돼. 그들의 단독 HTML만 해도, 나와 비교하면 HTML과 CSS 합쳐도 70%가 더 커! \n\n<div class=\"content-ad\"></div>\n\n그렇게하면 체중이 늘어나고, 느려지며 유지보수하기 어려운 웹사이트가 되어버릴 거예요. 사용성과 접근성을 무시하는 결과는 더할 나위 없는 형편입니다.\n\n계속해서 언급했듯이:\n\n그리고 그 증거는 숫자 속에 있어요. 숫자에 대해 이야기해보겠습니다...\n\n## #2 파일 개수\n\n<div class=\"content-ad\"></div>\n\n페이지에 있는 별도 파일 수는 로드 시간에 막대한 영향을 줄 수 있습니다. 경우에 따라 전체 파일 크기보다 더 많은 영향을 미칠 수도 있죠!\n\nFTP를 사용해 본 적이 있다면 100개의 별도 1k 파일을 전송하는 데 단일 100k 파일을 전송하는 것보다 훨씬 오래 걸린다는 것을 알아챌 수 있을 겁니다. 이는 서버와 시스템이 파일이 있는지, 작성해야 하는지, 이미 캐시되어 있는지 등을 계속 확인하며 소통하는 \"핸드셰이킹\" 오버헤드에서 비롯됩니다. HTTP도 동일한 문제를 겪지만, 병렬 처리(동시에 여러 전송)를 활용하여 패널티를 줄이고, HTTP 2 푸시 및 HTML 5 사전로드와 같은 새로운 기술을 사용하여 문제를 더욱 완화할 수 있습니다.\n\n하지만 이 문제가 마술처럼 사라진다는 것은 아닙니다.\n\n이제 일부 사람들은 \"모든 것을 한 파일에 모아놓으면 왜 안 되지?\"라고 과도하게 반응하기도 합니다. 사실 많은 사람들이 이 방식을 취하고 있지만, 해당 방법은 많은 문제를 야기할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 하나의 파일에 모든 것이 들어 있고 하위 페이지가 동일한 데이터를 공유하는 경우 - 표현 이미지, 아이콘, 메뉴, 헤더, 푸터, 일반 스타일링 - 서브 페이지에 대해 캐싱/미리로드를 하지 않습니다. 각 페이지 로드마다 이를 로드해야 하기 때문에 서브 페이지의 속도를 희생하는 것입니다. 캐시가 비어 있는 첫 번째 로드를 위해 속도를 포기합니다.\n- HTTP의 파일 병렬로 로드하는 능력을 활용하고 있지 않습니다. 이는 단일 연결이 가질 수 있는 \"속도 제한\"을 피할 수 있습니다.\n- 이는 서버가 동적 페이지를 구성하는 데 더 많은 노력을 들게 만듭니다.\n\n다른 말로 하면 Bootstrap, Tailwind, HTMX 및 수십 개의 기타 \"나도 인터넷 할 수 있어요\" 개발과 같은 어리석은 문제입니다.\n\n파일의 수를 줄이려고 하지 않는 이유는 없습니다. 다른 것처럼 지나칠 수도 있습니다. 캐싱 등을 위해 별도의 파일이 필요하지만 핸드셰이크 오버헤드 때문에 페이지 로드 속도가 느려지는 개별 파일이 너무 많아서도 안됩니다.\n\n푸시 또는 프리로드를 사용하지 않는 경우, 좋은 규칙은 첫 번째 여덟 개의 파일이 \"무료\"라는 것입니다. 그 이후의 각 파일은 실제로 200ms의 현실적인 벌칙을 받습니다. 최악의 경우 일부 사람들은 1초정도까지 느낄 수도 있습니다. 따라서 48개의 별도 파일로 이루어진 전통적인 \"올드 스쿨\" 페이지는 8부터 40초의 핸드셰이킹 오버헤드를 볼 수 있습니다. 이는 80% 이상의 이탈 영역입니다.\n\n<div class=\"content-ad\"></div>\n\n알겠어요, 20ms 정도로 더 적은 숫자가 나올 수도 있어서 즉시 통신 중단은 아니지만, 그건 서버나 주요 백본에 가깝다는 뜻이에요. \"당신의 일이 아니니까\"라고 다시 말하자면, 여러분 모두에게 영향을 미치는 거잖아요.\n\n푸시/사전로드를 사용하면 초기 HTML 파일과 동일한 연결에서 핸드셰이킹이 처리돼요. 이렇게 하면 이러한 파일에 대한 핸드셰이킹 오버헤드가 없어져요... 어느 정도, 말이에요.\n\n이 더 최신 기술을 사용할 때는 주의를 기울여야 해요. 조금은 수익이 줄어들 수도 있답니다. 브라우저 구현 문제인지, 시간이 많이 걸리는 것인지 잘 모르겠지만, 파일이 8개를 넘어가면 효과가 크게 떨어진다고 해요. 그래서 푸시/사전로드를 사용할 때는 다음과 같이 제한하는 것을 제안해요:\n\n- media=\"screen\" CSS(하나 또는 두 개의 파일이어야 함)\n- 외부 JavaScript(세 개 또는 네 개의 파일로 제한)\n- 웹폰트\n- \"대규모\" 배경 이미지와 같은 중요한 정적 요소들\n\n<div class=\"content-ad\"></div>\n\n그 목록에서 4번 항목은 정말 필요없는 항목이에요. 하지만 난 ‘디자이너’를 자칭하는 예술적인 사람들이 그런 종류의 사물을 좋아하는 걸 알아요. 기본적인 디자인 지식이 없더라도요. 그리고 rel=\"modulepreload\"도 있어요. 이건 새로운 \"JavaScript 모듈\"과 함께 사용되지만, 로딩에 제한이 없어 보여요. 서버가 허용하는 한 전송/연결을 많이 사용할 수 있는 이유를 알아내기 위해 더 많이 실험을 해봐야 할 것 같아요.\n\n하지만 서버나 브라우저가 처리할 수 있는 연결에는 한계가 있다는 걸 기억해야 해요. 서버에 트래픽이 많을수록 사용자에게 유지할 수 있는 연결이 점점 줄어들게 돼요. Google, Xitter, 또는 Facebook과 같은 큰 기업들에겐 큰 문제가 아니겠지만, 대부분의 일반적인 사이트 소유자나 기업들에게는 쉽지 않은 문제일 수 있어요.\n\n예를 들어, 한가한 시간대에 근처 캠퍼스의 혼잡한 무료 인터넷에 연결된 상황을 상상해보세요. 혹은 집에서 pooky가 지하실에서 게임과 영화를 얻어다 주는 동안, 부인이 Mando를 보면서 다섯 개의 소셜미디어 사이트를 동시에 스크롤하고 있는 경우… 집의 인터넷 연결 한도는 얼마나 남을까요?\n\n<div class=\"content-ad\"></div>\n\nGoogle은 하드웨어를 그냥 투입하는 것만으로 해결할 수 있는 문제도 있지만, 그들은 네트워킹, 프로토콜 및 명세 변경을 추진하여... 최소한으로 줄일 수 있도록 노력하고 있습니다. 오늘날 우리가 HTTP 2.0 푸시라고 부르는 것은 Google SPDY라는 이름으로 출발했습니다. 크롬을 위해 만들지 않고 오픈 소스로 공개하고 HTTP 명세로 적용시킨 덕분에 Google이 절약한 돈은 상당히 많을 것입니다.\n\n우리 모두가 이로 인해 혜택을 받는다구요? 저는 이에 불만을 품지 않겠습니다.\n\n모든 이런 개선 사항에도 불구하고, 일반적인 사이트에 HTML+CSS+JS 파일이 8개 이상, 또는 실제로 애플리케이션이 될만한 \"웹 애플리케이션\"에는 24개의 파일이 넘어간다면, 여러분의 코드는 아마 성능이 좋지 않을 겁니다. 특히 자바스크립트 부분에서 이 코드 한 줄마다 추가 함수를 만들고, 각 함수를 위한 파일을 만드는 것이 \"좋은 행위\"가 된 것에 대해 충격을 받고 있습니다. 정말 부정직한 일이죠!\n\n하지만 전체 파일 수를 효율적으로 관리하는데 도움을 줄 수 있는 기술도 더 많이 있습니다. 가장 고전적인 기법 중 하나인 \"CSS 스프라이트\"는 모든 디자인 이미지/아이콘을 한 이미지에 넣고, 배경으로 적용하고, 배경 위치를 조정하여 원하는 부분만 나타내는 것을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n대부분의 경우 SVG 및 웹폰트로 대체되었습니다. 이러한 방법을 사용하면 핸드셰이크 수를 줄일 뿐만 아니라 해상도 감소 없이 어떤 크기에도 완벽하게 확장이 가능합니다.\n\n단색 아이콘이 있다면 \"Font-awesome\"와 같은 폰트에 넣는 것은 여러 아이콘을 한 고작한 파일로 효율적으로 사용할 수 있는 좋은 방법입니다. 다양한 색상 지원이 준비 중이지만 아직은 다소 불안정합니다. 그러나 마크업을 건드리지 않고 색상을 변경하고 싶다면 SVG보다 우수합니다.\n\n일반적으로 아이콘에 대해 SVG를 사용하는 것에는 여러 문제가 있습니다. 가장 큰 문제 중 하나는 대부분의 사람들이 HTML에 그것들을 잘못 넣어 반복해서 사용하며 공유된 페이지 간에 캐시되지 않고 HTTP 병렬성을 지연시킨다는 것입니다. 이 문제의 해결책은 CSS로 이동하여 배경 이미지로 사용하는 것입니다. XML 텍스트이기 때문에 CSS로 쉽게 인코딩할 수 있습니다.\n\n그러나 CSS에 넣었음에도 불구하고 CSS에서 색상을 제어할 수 없고, 반복해서 사용해야 합니다. (필터를 사용하면 몇 가지 귀여운 트릭을 사용할 수 있습니다.)\n\n<div class=\"content-ad\"></div>\n\n여전히 SVG 및 웹 폰트는 수백 개의 파일을 하나로 교체하는 능력을 발휘하고 있습니다. 이를테면 캐싱과 병렬성을 희생하지 않고요.\n\n요점은 무엇일까요? 파일 수를 적게 유지하되, 할 일이 도리보다 더 나쁘게 되지 않도록 지나치게 너무 열중하지 마세요.\n\n솔직히 말해서, 이 조언은 대부분 웹 관련 모든 것에 적용됩니다. 사람들은 한 가지 방법을 배우고는 모든 것에 적용하려고 하거나, 어떤 \"속도 향상\" 기술에 대해 듣고 나서는 아무도 그것을 이해하고 싶어하지않아 너무 지나치게 적용하곤 하죠. 그냥 건드리지 않았더라면 하는 것보다 더 많은 피해를 줄 때도 있죠!\n\n## #3 렌더링 시간\n\n<div class=\"content-ad\"></div>\n\n간단히 말해서, 브라우저가 서버에서 검색한 코드를 사용 가능한 페이지로 변환하는 데 소요되는 시간은 충분한 파일이 있는 이후입니다.\n\n이것은 많은 사람들이 나쁜 습관을 정당화하기 위해 사용하는 비열한 수식어로 많이 사용됩니다. 개발자들이 실제로 코드 크기를 두 배나 네 배로 늘려 브라우저가 \"페이지를 렌더링하는 데 소요되는 시간\"을 몇 밀리초 짜내려고 할 때 이 중 가장 나쁜 경우입니다. 그들이 코드 부풀리기로 전체 로드 시간을 더 느리게 만든다는 것에 대해 깨닫지 못합니다.\n\n이것은 \"레이아웃에 테이블을 사용하지 마십시오\"를 \"테이블을 절대 사용하지 말아라!!!\" 라고 하며 변형한 어리석은 구호로 발전한 바보들이 돌아다닌 엽기적인 지들을 향한 가증스럽게 병적인 변명이 되어왔습니다. 그들은 \"테이블은 렌더링하는 데 너무 느리다\"라고 말한 것은 그들의 무지를 정당화하는 겨우란 어림짐작의 변명으로 사용했습니다.\n\n옛날에 웃기며 말한 것처럼:\n\n<div class=\"content-ad\"></div>\n\n지금, \"렌더 시간\"이 하찮다는 걸 의미하나요? 전혀 아니에요. 그냥 많은 사람들이 그것에 대해 어리석은 부분에 집착한다는 거죠 (라이트하우스가 레이어드 선형 그라디언트에 열광하면서 거대한 이미지 위의 텍스트에는 신경쓰지 않는 것을 보세요), 이것은 방정식에서 아주, 아주 작은 부분일 뿐입니다.\n\n더 나쁜 것은 CSS와 같은 것을 탓하는 사람들이 있지만, 그들은 두 자리 이상의 킬로바이트 업무를 하는 메가바이트의 JavaScript를 가지고 있습니다.\n\n더 많은 코드가 있을수록, 렌더가 시작되기 전에 걸리는 시간이 더 오래 걸립니다. 더 많은 마크업, CSS 규칙 및 스크립팅을 사용할수록 렌더 시간이 더 오래 걸립니다. 그래서 Failwind나 Bootcrap과 같은 어리석음은 비성능적인 쓰레기인 것이죠. 이들은 자신들과는 반대되는 근거 없는 주장을 하지만요.\n\n그리고 확실히 선형 그라디언트, 박스 그림자, 텍스트 그림자 등은 처리 성능과 렌더 시간이 많이 소요되는 것이 사실입니다. 그러나 정적 이미지를 사용하는 것과 비교했을 때, 오래된 하드웨어를 제외하고 모든 것에 대한 소요 시간/오버헤드가 분원인 것을 보면요.\n\n<div class=\"content-ad\"></div>\n\n… 그리고 우리는 영원히 \"와 응 응 아이 던즈 워나 스탑 유징 윈블로우즈 XP 앤 머 겟 빈티엄 4\" 사람들을 위해 유연하게 휘어져서 서 있을 수 없어요.\n\n## 내 Tandy 1000SX가 윈도우 XP를 실행할 것을 기대하는 것만큼 터무니없어요.\n\n![이미지](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_14.png)\n\n완전히 헛소리는 아니지만, 나는 Lighthouse가 당신에게 말하는 대로 해 보라고 말할 거예요... 그래도 명백히 헛소리인 것으로 약간의 성능 점수를 받아도? 어쨌든 그래도 될 거예요. 대부분 \"렌더링\"에서 지연을 초래하는 실제 근본적인 원인들은 다 다루기 쉽기 때문에요:\n\n<div class=\"content-ad\"></div>\n\n- DOM 요소가 너무 많이 있어요. 즉, 마크업을 적게 사용해주세요.\n- CSS 규칙이 너무 많아요. 적은 CSS를 사용하고 모든 것에 클래스를 부착하지 마세요.\n- JavaScript가 너무 많이 사용되었어요. JavaScript 없이 할 수 있는 경우에는 반드시 그렇게 하세요!\n- 파일이 너무 많아요. 렌더링은 \"window.onload\"이 발생하기 전까지 시작할 수 없음을 기억해주세요.\n\n다시 말해서, 제가 거의 모든 기사, 포럼 게시물, 소셜 미디어 등에서 수십 년 동안 계속 말해 온 것들이에요. 그리고 Resig, Otto, Thornton, Wathan과 같은 사기꾼들이 치켜 들고 있는 것들이에요.\n\n# 요약\n\n웹사이트의 90% 이상이 속도에 있어 코드 크기, 코드 복잡성, 개별 파일 수 및 전체 파일 크기 등과 관련이 있어요. 이 중에서 파일 크기는 실제로 지난 10년 동안 가장 큰 문제가 될 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n파일 수를 살펴보세요. HTML 파일의 크기와 전달하려는 실제 내용을 비교해 보세요. 전체 코드 양과 작업과 비교해서 얼마나 많은 코드가 있는지 살펴보세요. 대부분의 \"속도 문제\"는 여기서 기인합니다. 계속 말하고 있는 것처럼, 블라인드로 코드를 복사하거나 붙여넣기하여 \"프레임워크 덤비\"하거나 HTML, CSS, JavaScript를 제대로 사용하는 가장 기본적인 개념에 대한 무지의 결과입니다.\n\n텍스트 4k와 이미지 1다스를 전달하기 위해 4십 때의 파일에 메가바이트의 코드가 있다면, \"여기가 문제의 근원입니다.\" 또한, 기사 작성에 있던 공백에 대해 사과드립니다. 이 기사는 90% 정도 완성된 채로 두 달 동안 오픈 탭에 열려 있었고, 이와 유사한 여러 기사들도 마찬가지였습니다. 지금은 내 일정이 매우 바쁘고 봄/여름이 시작되어 상황이 더욱 악화되고 있습니다.","ogImage":{"url":"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_0.png"},"coverImage":"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_0.png","tag":["Tech"],"readingTime":20},{"title":"앵귤러 대비 리액트 비즈니스 요구사항에 가장 적합한 프레임워크는 무엇일까요","description":"","date":"2024-05-20 22:53","slug":"2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds","content":"\n\n<img src=\"/assets/img/2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds_0.png\" />\n\n웹 애플리케이션을 위한 적절한 프레임워크를 선택하는 것은 성공적이고 확장 가능한 제품을 보장하는 데 중요합니다. 다양한 선택지 가운데 Angular와 React는 두 가지 인기 있는 프레임워크로 두드러지며 가장 강력한 옵션입니다. 두 프레임워크는 각각 독특한 장점과 약점을 가지고 있어 귀사의 특정 비즈니스 요구에 매우 의존하게됩니다. 이 블로그에서는 Angular와 React의 주요 차이점, 장단점, 그리고 잠재적인 단점을 살펴보고 정보를 토대로 결정을 내릴 수 있도록 돕겠습니다.\n\n# Angular과 React 이해하기\n\n## Angular\n\n<div class=\"content-ad\"></div>\n\nAngular은 구글에서 개발 및 유지보수하는 강력한 프론트엔드 프레임워크입니다. 2010년에 먼저 AngularJS로 출시되었으며 그 이후로 상당한 변화를 거쳐 현재 버전인 Angular 또는 Angular 2+로 불리고 있습니다.\n\n주요 특징:\n\n- 포괄적인 프레임워크: Angular는 데이터 바인딩, 의존성 주입, 강력한 CLI와 같은 내장 기능을 제공하는 완전한 솔루션을 제공합니다.\n- 양방향 데이터 바인딩: 이 기능은 UI의 변경 사항이 즉시 기저 데이터 모델에 반영되고 그 반대도 보장합니다.\n- TypeScript: Angular는 정적 유형을 추가하는 JavaScript의 슈퍼셋인 TypeScript로 개발되었습니다. 이를 통해 코드 품질과 유지보수성이 향상됩니다.\n- 구성 요소 기반 아키텍처: Angular 애플리케이션은 재사용 가능한 구성 요소를 사용하여 개발을 더 체계적이고 확장 가능하게 만듭니다.\n\n## React\n\n<div class=\"content-ad\"></div>\n\nReact는 Facebook이 개발한 JavaScript 라이브러리로 사용자 인터페이스를 구축하는 데 사용됩니다. 2013년에 출시된 이후 React는 그 간단함과 유연성으로 매우 인기가 높아졌습니다.\n\n중요 기능:\n\n- 가상 DOM: React는 변경된 부분만 업데이트하여 렌더링 성능을 최적화하기 위해 가상 DOM을 사용합니다.\n- 일방향 데이터 바인딩: React의 일방향 데이터 바인딩은 데이터 흐름을 더 잘 제어하며, 애플리케이션을 디버그하기 쉽게 만듭니다.\n- JavaScript XML (JSX): React는 JSX를 사용하며, JavaScript 내에서 HTML과 유사한 코드를 작성할 수 있어 코드의 가독성과 구조를 향상시킵니다.\n- 컴포넌트 기반 아키텍처: Angular와 유사하게, React도 재사용 가능한 컴포넌트의 사용을 촉진합니다.\n\n# Angular와 React 비교\n\n<div class=\"content-ad\"></div>\n\n## 학습 곡선\n\nAngular: Angular은 포괄적인 성격으로 인해 학습 곡선이 가파릅니다. TypeScript 및 복잡한 구문에 익숙해져야 합니다. 의존성 주입, 서비스 및 RxJS와 같은 프레임워크의 포괄적인 기능 및 개념은 초보자에게 혼란스러울 수 있습니다.\n\nReact: React는 부드러운 학습 곡선으로 유명합니다. JavaScript에 익숙한 개발자는 빠르게 React를 시작할 수 있습니다. JSX의 간결함과 재사용 가능한 컴포넌트 구축에 대한 집중으로 새로운 개발자들이 학습하고 사용하기 쉬워집니다.\n\n## 성능\n\n<div class=\"content-ad\"></div>\n\nAngular: Angular의 성능은 미리 컴파일(AOT) 및 트리 쉐이킹을 통해 최적화되었습니다. 그러나 양방향 데이터 바인딩과 프레임워크의 복잡성 때문에 때로는 React와 비교하여 성능이 느릴 수 있습니다.\n\nReact: React는 가상 DOM을 사용하여 효율적인 업데이트와 렌더링을 보장하여 높은 성능을 제공합니다. 일방향 데이터 바인딩은 데이터 흐름을 간소화하여 더 나은 성능을 제공합니다.\n\n## 유연성과 확장성\n\nAngular: Angular는 완전한 프레임워크로, 필요한 모든 것을 제공합니다. 일관된 구조가 필요한 대규모 애플리케이션에 유용할 수 있습니다. 그러나 Angular의 방식을 따르도록 개발자가 제한될 수 있어 유연성이 제한될 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\nReact: React은 더 큰 유연성을 제공하여 개발자가 라우팅, 상태 관리 및 기타 기능에 대해 자체 라이브러리 및 도구를 선택할 수 있습니다. 이 모듈식 접근 방식은 아키텍처에 대한 더 많은 제어를 제공하여 확장 가능한 응용 프로그램을 구축하는 데 유용할 수 있습니다.\n\n## 커뮤니티 및 생태계\n\nAngular: Angular는 Google의 강력한 후원을 받고 강력한 커뮤니티를 갖고 있습니다. 방대한 문서와 다양한 제삼자 라이브러리와 도구를 제공합니다. 그러나 때로는 React와 비교하면 프레임워크의 생태계가 덜 다이나믹할 수 있습니다.\n\nReact: React는 Facebook의 지원을 받은 크고 활발한 커뮤니티를 자랑합니다. 다양한 제삼자 라이브러리, 도구 및 풍부한 자습서와 리소스가 포함된 풍부한 생태계를 제공합니다. React의 인기는 지속적인 업데이트와 혁신을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n## 사용 사례\n\n**Angular:** Angular은 기업급 애플리케이션, 복잡한 SPA(Single Page Application) 및 많은 내장 기능 및 일관된 아키텍처를 필요로 하는 애플리케이션을 구축하는 데 이상적입니다.\n\n**React:** React는 동적 및 대화형 UI, 점진적 웹 앱 및 고성능 및 유연성이 필요한 애플리케이션에 적합합니다. React Native와 결합하면 모바일 앱 개발에도 좋습니다.\n\n# 확장 가능한 솔루션을 위한 적절한 프레임워크 선택: 황제 브레인을 위한 비교 분석\n\n<div class=\"content-ad\"></div>\n\n- Angular: 종합적인 특성과 내장된 기능으로 Angular은 견고한 프레임워크와 광범위한 기능이 필수적인 프로젝트에 적합합니다. 이는 기업급 응용 프로그램 및 복잡한 SPA에 이상적입니다. Angular의 구조화된 아키텍처는 조직화되고 확장 가능한 개발이 필요한 부분과 조화를 이루며, 고품질 솔루션을 제공하는 Emperor Brains의 목표와 일치하는 전문적인 접근을 반영합니다.\n- React: React의 유연성과 성능 최적화는 동적이고 인터랙티브한 사용자 인터페이스, 점진적 웹 앱 및 확장성과 혁신이 중요한 시나리오에 적합합니다. React의 모듈식 접근 방식은 Emperor Brains의 개발자들이 프로젝트별 최적의 도구와 라이브러리를 활용할 수 있도록 하며, 선순환적이고 적응력 있는 전략에 부합합니다.\n\nEmperor Brains는 종합적인 프레임워크와 내장된 기능, 일관된 아키텍처를 요구하는 프로젝트에 Angular을 고려하는 것이 유리할 것입니다. 반면에 React는 고도의 유연성, 성능 최적화, 사용자 인터페이스 디자인에서의 혁신이 필요한 프로젝트에 적합합니다. 최종적으로 Angular와 React 중 선택은 특정 프로젝트 요구사항, 확장성 요구사항 및 개발팀의 전문성과 부합해야 합니다.","ogImage":{"url":"/assets/img/2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds_0.png"},"coverImage":"/assets/img/2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular로 컴포넌트 만드는 방법","description":"","date":"2024-05-20 22:51","slug":"2024-05-20-AngularAdvancedComponents","content":"\n\n\n![Screenshot](/assets/img/2024-05-20-AngularAdvancedComponents_0.png)\n\n# 안녕하세요 여러분,\n\n오늘은 우리의 작업을 더 쉽게 만들어주는 Angular의 두 가지 데코레이터, ViewChild와 ViewChildren에 대해 이야기하겠습니다.\n\nAngular의 ViewChild와 ViewChildren 데코레이터는 컴포넌트 내에서 요소에 접근하기 위해 사용되는 특별한 데코레이터입니다.\n  \n\n<div class=\"content-ad\"></div>\n\n태그를 Markdown 형식으로 변경해 보겠습니다.\n\n## ViewChild\n\n는 컴포넌트 클래스 내에서 DOM에 있는 객체를 나타낼 수 있게 해주는 데코레이터입니다. 이론적으로 설명할 때는 조금 지루해 보일 수 있지만, 실제 예시로 넘어가 봅시다.\n\n![Image](/assets/img/2024-05-20-AngularAdvancedComponents_1.png)\n\n<div class=\"content-ad\"></div>\n\n간단한 구성 요소를 만들었고 Child1Component로 이름을 지었습니다. 기본적으로 셀렉터에는 'app-child1'이라는 값이 할당됩니다. 이 값을 사용하면 HTML 태그를 사용하여 메인 컴포넌트의 HTML에서 이 컴포넌트를 호출할 수 있습니다.\n\n![image](/assets/img/2024-05-20-AngularAdvancedComponents_2.png)\n\n그런 다음, 주 컴포넌트(app)에서 컴포넌트1을 호출하고 가져옵니다. 이처럼 `app-child2 #h``/app-child2` `br` 이렇게 하죠.\n여기서 볼 수 있듯이 'h' 값으로 DOM 개체를 표시하고 있습니다. 이렇게 함으로써 주요 컴포넌트에 접근하고 있습니다.\n\n이제 어떻게 진행해야 합니까?\n\n<div class=\"content-ad\"></div>\n\n우리의 의도는 이 표시된 DOM 객체에 우리의 데코레이터를 적용하는 것이었죠, 맞나요? 네, 지금 그것을 하러 가보겠습니다.\n\n\n![Angular Advanced Components](/assets/img/2024-05-20-AngularAdvancedComponents_3.png)\n\n\nViewChild 데코레이터를 사용하면 주요 컴포넌트 아래에서 원하는 값으로 표시된 DOM 객체에 개입할 수 있습니다. ElementRef 타입으로 표시된 것이기 때문에, 우리는 이 방법으로 'h' 값을 사용해 DOM 객체를 포착합니다.\n\n지금까지 좋은가요?\n\n<div class=\"content-ad\"></div>\n\n아래 예시에서는 또 다른 예시를 보실 수 있습니다. 걱정하지 마세요, 완전히 동일한 동작을 수행합니다. 다만 이번에는 이 DOM 객체에 컴포넌트를 통해 접근하고 있습니다. 같은 방식으로 child1Component와 Child1Component 유형으로 이 값을 캡처합니다.\n\n<img src=\"/assets/img/2024-05-20-AngularAdvancedComponents_4.png\" />\n\n이제 'static'이 무엇을 의미하는지 궁금하신가요? 간단히 설명드리겠습니다.\n\nstatic: true는 프로그램이 실행될 때 이 값이 필요한 DOM 객체(컴포넌트)가 생성되어야 함을 나타냅니다. 제 말이 무엇을 의미하는지 궁금하시면, 예시를 통해 설명해 드리도록 하죠.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경되었습니다.\n\n\n![Angular Advanced Components 5](/assets/img/2024-05-20-AngularAdvancedComponents_5.png)\n\n인터넷 사이트에서 양식 프로세스를 상상해보십시오. 해당 양식 작업을 수행할 의도가 없는 사용자에게 양식을로드하는 것은 비용을 증가시키고 사용자에게 느린 경험을 제공할 수 있습니다. 따라서 사이트가 열릴 때 설정해야 하는 DOM 객체에 대해서는 그 옆에 'true' 값을 반환합니다. 그러나 예제와 같은 양식 프로세스의 경우 'false' 값을 반환하는 것이 더 논리적일 것입니다.\n\n![Angular Advanced Components 6](/assets/img/2024-05-20-AngularAdvancedComponents_6.png)\n\n이제 이것을 이해했으니 계속해보겠습니다...\n\n\n<div class=\"content-ad\"></div>\n\n만일 DOM에서 데코레이터를 사용하여 다른 작업을 수행하는 방법에 대해 궁금하다면, 한 가지 속성에 대해 알려드릴게요. 좀 더 심화된 접근 방식에서는, 우리는 컴포넌트 내에 제공된 제공자를 통해 컴포넌트에 액세스할 수 있습니다. 이를 통해 제공자에서 지정된 데이터에 액세스할 수 있게 됩니다.\n\n이것을 read라고 부릅니다. 아래에 표시된 것처럼, 이 속성을 사용하여 컴포넌트의 제공자를 통해 액세스된 DOM 객체에 필요한 작업을 수행할 수 있습니다.\n\n![이미지 1](/assets/img/2024-05-20-AngularAdvancedComponents_7.png)\n\n![이미지 2](/assets/img/2024-05-20-AngularAdvancedComponents_8.png)\n\n<div class=\"content-ad\"></div>\n\n# 이거도 얻었어요! 조작은 어디로 가나요??\n\n이렇게 캡처한 후에는 컴포넌트 내에서 이러한 객체에 필요한 작업을 수행합니다. 일반적으로 이는 ngOnInit() 및 ngAfterViewInit() 두 가지 특별한 함수를 통해 수행됩니다.\n\n![이미지](/assets/img/2024-05-20-AngularAdvancedComponents_9.png)\n\n여기서는 간단히 콘솔에 로그를 기록했지만, 필요에 따라 컴포넌트 내에서 이러한 객체에 대해 필요한 작업을 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n지금 다른 질문이 있어요: 왜 이 모든 것이 한 함수에 없는 거죠? 이러한 함수들의 차이는 무엇인가요? 간단히 설명해 드릴게요. 폼 프로세스의 맥락에서 생각해 보세요:\n\nngOnInit 함수는 프로그램이 실행되기 시작할 때 호출되며, 시작할 때 수행해야 하는 초기 프로세스를 호출하는 데 사용됩니다.\n\n반면에 ngAfterViewInit은 폼이 필요할 때 호출할 함수로 생각할 수 있습니다. 이를 바탕으로, `false`로 표시된 데코레이터는 ngOnInit 함수로 호출할 수 없다고 말할 수 있습니다.\n\n# ViewChildren\n\n<div class=\"content-ad\"></div>\n\n\n특정 컴포넌트 내에서 특정 유형의 모든 요소에 액세스하는 데 사용됩니다. 다시 말해, 하나의 컴포넌트 내에서 여러 자식 컴포넌트에 액세스하려고 할 때 사용됩니다.\n\n이러한 개념을 설명한 후에는 지금 무슨 일이 일어나고 있는지 충분히 이해했을 것으로 믿습니다. :D 명확한 그림이 그려졌는지 확인하기 위해 예제를 제공하겠습니다. 그런 다음 더 이상 문제가 되지 않을 것입니다.\n\n아래에서 생성한 세 개의 컴포넌트가 있다고 가정해 봅시다. 이 세 개는 모두 동일한 공급자를 가지지만 다른 값을 갖습니다. 이를 어떻게 처리할 수 있을까요? 즉시 설명해 드리겠습니다.\n\n<img src=\"/assets/img/2024-05-20-AngularAdvancedComponents_10.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-20-AngularAdvancedComponents_11.png)\n\n![이미지](/assets/img/2024-05-20-AngularAdvancedComponents_12.png)\n\n그런 다음 사용하는 모든 구성 요소를 가져와야합니다. 아래에서 볼 수 있듯이 모든 구성 요소에는 동일한 \"h\" 태그가 있습니다.\n\n![이미지](/assets/img/2024-05-20-AngularAdvancedComponents_13.png)\n\n<div class=\"content-ad\"></div>\n\n5번째 예제에서 확인할 수 있듯이, 같은 'h' 값을 가진 모든 요소를 캡처하기 위해 @ViewChildren을 사용했습니다. 그런 다음 ‘read’ 속성을 사용하여 이러한 구성 요소 내부의 값을 읽고 'list' 변수에 저장했습니다. 보시다시피 QueryList로 모든 값을 캡처하여 데이터 유형을 지정했습니다. 그리고 이제 원하는대로 조작할 수 있습니다. :)\n\n<img src=\"/assets/img/2024-05-20-AngularAdvancedComponents_14.png\" />\n\n결론적으로, Angular에서 강력한 데코레이터 @ViewChild와 @ViewChildren을 탐구했습니다. 이들을 사용하여 구성 요소 내의 요소와 상호 작용하고 조작할 수 있는 방법을 이해했습니다. 실제 예제를 통해 이러한 데코레이터를 사용하여 DOM 요소에 액세스하고 특정 시나리오에 기반한 작업을 수행하는 방법을 알아보았습니다. 또한, 고급 조작을 위한 구성 요소 제공자를 통한 'read' 속성에 대해 다뤄보았습니다.\n\n더 많은 고급 주제로 계속 읽어주셔서 감사합니다!!","ogImage":{"url":"/assets/img/2024-05-20-AngularAdvancedComponents_0.png"},"coverImage":"/assets/img/2024-05-20-AngularAdvancedComponents_0.png","tag":["Tech"],"readingTime":5},{"title":"알폰소 안드레스 로페즈 몰리나와 함께하는 Angular 및 React","description":"","date":"2024-05-20 22:50","slug":"2024-05-20-AngularandReactwithAlfonsoAndrsLpezMolina","content":"\n\n## Angularidades 팟캐스트 41회 요약\n\n이번 에피소드에서는 \n베네수엘라 출신이자 현재 콜롬비아 보고타에 거주 중인 경력 많은 소프트웨어 개발자 인 \nAlfonso Andrés López Molina \n를 환영합니다. Alfonso는 컴퓨터 공학 학위를 가진 학자로 하드웨어 개발 경험 또한 있으며, 이를 통해 전기 공학과 컴퓨터 과학을 연결하는 경험을 가지고 있습니다. 그는 \nReact Miami\n 에서\nMayra Rodriguez\n를 통해\nAlejandro Cuba Ruiz\n을 만나 이번 에피소드에 참여하는 것에 흥분했습니다.\n\n# 다루는 주제\n\n- Angular가 React와 작업하는 데 미치는 영향\n- 규칙 설정 및 코드 품질 유지를 위한 도구 사용\n- Angular와 React에서 컴포넌트 작성의 차이점\n- 각각의 프레임워크의 강점\n- JavaScript 생태계의 트렌드에 대한 최신 정보 유지\n- React와 Angular의 의존성 관리의 차이점\n- React와 Angular에서 서버 측 렌더링 옵션 탐색\n- Angular와 React 간의 개념 공유\n- 현대 프런트엔드 개발에서 유효성 유지하기\n\n<div class=\"content-ad\"></div>\n\n이 에피소드의 타이밍이 완벽합니다. 팟캐스트 에피소드가 Angular 18의 런칭 주에 방영되며, Angular 커뮤니티 모임에서 Angular 신호에 관한 발표를 한 지 6일 후입니다.\n\n알폰소는 AngularJS에서 최신 Angular 버전으로의 전환 과정과 TypeScript의 C#과 유사성이 처음에 그의 전환을 용이하게 한 점을 이야기합니다. Angular가 그의 경력에 상당한 영향을 미쳐 소프트웨어 개발의 최고의 실천 방법과 디자인 원칙을 가르쳐 주었으며, 응용 프로그램 성능을 최적화하는 데 도움이 된 Angular의 안정성과 유지 보수성을 칭찬합니다.\n\n이번 에피소드에서는 또한 알폰소가 React로 전환하는 과정과 Angular의 기본 지식이 학습 곡선을 간소화하는 데 어떻게 도움이 되었는지에 대해 다룹니다. Angular의 포괄적인 프레임워크 접근과 비교하여 React의 라이브러리 지향적인 성격은 두 환경 모두에서 유사한 디자인 패턴과 원칙을 적용할 수 있도록 해 주었습니다.\n\n또한, 알폰소는 Angular와 React 간의 기술적인 차이점, 특히 각각의 데이터 바인딩, 의존성 주입 및 아키텍처 패턴 처리 방식에 대해 이야기합니다.\n\n<div class=\"content-ad\"></div>\n\n알폰소는 앵귤러의 미래와 기술 분야에서의 역할에 대해 반성하며, 기술 발전에 발맞추기 위해 커뮤니티와 계속적인 학습의 중요성을 강조합니다. 그는 기술 채택에 대한 적극적인 접근을 옹호하며, 새로운 도구 및 관행을 받아들여 개발 경험을 향상시키고 더 견고한 애플리케이션을 만들도록 청취자들을 격려합니다.\n\n에피소드는 알폰소가 기술 트렌드를 파악하고 지속적인 교육 및 혁신을 위해 유연한 마인드셋을 취해야 한다는 중요성을 재강조하며 마무리됩니다.\n\n# 핵심 내용\n\n- 앵귤러 경험은 리액트 작업에 영향을 미칠 수 있으며, 두 프레임워크 간에는 많은 개념과 디자인 패턴이 유사합니다.\n- 개발 팀 내에서 규칙을 정립하고 ESLint와 같은 도구를 사용하여 코드 품질을 유지하는 것이 중요합니다.\n- JavaScript 생태계의 트렌드를 계속 파악하고 배운 접근법과 기술을 프로젝트에 적용하는 것이 중요합니다.\n- 앵귤러 Material의 소스 코드를 검토하는 것은 앵귤러 애플리케이션 개발에 사용되는 좋은 관행과 접근 방식을 배우는 훌륭한 방법입니다.\n- 앵귤러는 시간이 지남에 따라 서버 측 렌더링 지원을 개선하고, 새로운 SSR 모드에서 강력한 가수화 과정을 제공하고 있습니다.\n- 현대 세계에서 주목받기 위해서는 커뮤니티를 구축하고 앵귤러 생태계의 성장에 기여하며, 다른 기술로부터 학습할 수 있는 것에 개방적이어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n곧 발표되는 향후 에피소드 인터뷰 대상을 확인하려면 https://twitter.com/angularidades 또는 LinkedIn을 방문해주세요.\n\n![이미지](/assets/img/2024-05-20-AngularandReactwithAlfonsoAndrsLópezMolina_0.png)","ogImage":{"url":"/assets/img/2024-05-20-AngularandReactwithAlfonsoAndrsLpezMolina_0.png"},"coverImage":"/assets/img/2024-05-20-AngularandReactwithAlfonsoAndrsLpezMolina_0.png","tag":["Tech"],"readingTime":3},{"title":"(2024년 최신) Angular 면접 질문 및 답변 90가지","description":"","date":"2024-05-20 22:25","slug":"2024-05-20-Top90AngularInterviewQuestionsAndAnswersfor2024","content":"\n\n\n![Angular Interview Questions](/assets/img/2024-05-20-Top90AngularInterviewQuestionsAndAnswersfor2024_0.png)\n\nSource:- Angular Interview Questions\n\nFor more questions and answers visit our website at [Frontend Interview Questions](https://www.example.com)\n\n# Angular Interview Questions For Freshers\n\n\n<div class=\"content-ad\"></div>\n\n- Angular이란 무엇이며 주요 기능은 무엇인가요?\n\nAngular는 구글에서 개발한 인기 있는 오픈 소스 웹 애플리케이션 프레임워크입니다. 동적인 싱글 페이지 애플리케이션(SPA) 및 복잡한 웹 애플리케이션을 구축하는 데 널리 사용됩니다. Angular는 Model-View-Controller(MVC) 아키텍처 패턴을 따르며 개발 프로세스를 간소화하기 위한 포괄적인 기능 세트를 제공합니다. 다음은 Angular의 주요 기능 몇 가지입니다:\n\n1. TypeScript: Angular는 TypeScript로 개발되었으며 JavaScript의 정적 타입 지원 및 기능을 추가한 TypeScript로 만들어졌습니다. TypeScript는 JavaScript를 더 견고하고 유지보수하기 쉽게 만들어주는 정적 타이핑 및 다른 기능을 추가합니다.\n\n2. 양방향 데이터 바인딩: Angular는 강력한 데이터 바인딩 시스템을 제공하여 모델과 뷰 간의 데이터 동기화를 가능케 합니다. 모델의 변경은 자동으로 뷰에 반영되며 그 반대의 경우도 마찬가지로 수동 업데이트가 필요하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n3. 구성 요소 기반 아키텍처: Angular 애플리케이션은 구성 요소를 사용하여 구축되며, 이는 독립적이고 재사용 가능한 구성 요소입니다. 각 구성 요소는 자체 HTML 템플릿, CSS 스타일 및 비즈니스 로직을 캡슐화하여 모듈화와 유지 관리성을 촉진합니다.\n\n4. 의존성 주입 (DI): Angular에는 구성 요소 및 서비스 간의 의존성을 관리하는 데 도움이 되는 내장형 의존성 주입 시스템이 있습니다. DI를 사용하면 필요한 의존성을 자동으로 제공하여 구성 요소를 쉽게 만들고 관리하며 테스트할 수 있습니다.\n\n5. 라우팅: Angular는 강력한 라우팅 모듈을 제공하여 다중 뷰를 가진 싱글 페이지 애플리케이션을 만들 수 있습니다. 개발자는 라우트를 정의하고 다른 뷰 간을 이동하며 현재 라우트에 따라 동적으로 구성 요소를 로드할 수 있습니다.\n\n6. 반응형 폼: Angular는 유효성 검사, 값 추적 및 사용자 입력 처리와 같은 기능을 갖춘 복잡한 양식을 구축하는 데 강력한 지원을 제공합니다. 반응형 폼은 폼 상태와 데이터 흐름을 처리하는 데 옵저버블 기반 접근 방식을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n7. 지시문: Angular에는 HTML을 사용자 정의 돌출로 확장하는 다양한 지시문이 있습니다. 지시문을 사용하면 DOM의 동적 조작, 요소의 추가 또는 제거, 스타일 적용 및 이벤트 처리가 가능해집니다.\n\n8. 테스트: Angular은 애플리케이션을 테스트하는 데 훌륭한 지원을 제공합니다. TestBed라는 테스트 프레임워크를 포함하고 있어 개발자들이 Angular 애플리케이션에 대해 단위 테스트, 통합 테스트 및 end-to-end 테스트를 작성할 수 있습니다.\n\n9. 성능 최적화: Angular에는 ahead-of-time(AOT) 컴파일, 모듈의 지연 로딩 및 tree shaking과 같은 여러 성능 최적화 기술이 포함되어 있습니다. 이러한 기능들은 애플리케이션의 초기 로딩 시간을 줄이고 전반적인 성능을 향상시켜 줍니다.\n\n10. 모바일 지원: Angular은 Angular Mobile Toolkit 및 Angular Material과 같은 도구를 제공하여 모바일 반응형 애플리케이션을 개발하는 데 도움을 줍니다. 다양한 기기와 화면 크기에 걸쳐 일관된 경험을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\nAngular은 생산성과 성능에 중점을 둔 견고하고 확장 가능하며 유지 관리가 용이한 웹 애플리케이션을 구축하기 위한 포괄적인 프레임워크를 제공합니다.\n\n1. 싱글 페이지 애플리케이션이란 무엇인가요?\n\n싱글 페이지 애플리케이션은 사용 중에 페이지를 다시로드할 필요가 없고 브라우저 내에서 작동하는 앱입니다.\n\n올바르게 구성된 SPA의 가장 큰 장점 중 하나는 사용자 경험(UX)입니다. 사용자는 페이지를 다시로드하거나 기타 작업을 기다릴 필요 없이 앱의 자연스러운 환경을 즐깁니다. 페이지는 JavaScript 프로그래밍 언어로 구동됩니다.\n\n<div class=\"content-ad\"></div>\n\n계속 진행하기 전에, 이 기사에서 볼 수 있는 세 가지 약어가 있어요: SPA — 싱글 페이지 어플리케이션 (위에서 언급한 것처럼)\n\nMPA — 멀티 페이지 어플리케이션 (링크를 클릭할 때 새 페이지를 로드하는 전통적인 어플리케이션)\n\nPWA — 프로그레시브 웹 어플리케이션 (자바스크립트 또는 프레임워크를 사용하여 구축된 웹사이트로, 앱처럼 행동할 수 있습니다. 예를 들어, 핸드폰 홈페이지에 앱으로 추가할 수 있어요)\n\n장점\n\n<div class=\"content-ad\"></div>\n\n단일 페이지 응용 프로그램의 주요 장점은 속도입니다. 대부분의 SPA가 필요로하는 자원(HTML + CSS + 스크립트)은 응용 프로그램을 시작할 때 로드되며 사용 중에 다시로드할 필요가 없습니다. 변하는 것은 서버로부터 전송된 데이터뿐입니다. 결과적으로 응용 프로그램은 사용자의 쿼리에 매우 빠르게 반응하고 클라이언트-서버 통신을 항상 기다릴 필요가 없습니다.\n\n3. Angular에서 컴포넌트란 무엇인가요?\n\nAngular에서 컴포넌트는 응용 프로그램의 사용자 인터페이스의 기본적인 구성 요소입니다. 특정 뷰와 동작을 제어하는 UI의 일부를 나타냅니다. 컴포넌트는 일반적으로 세 가지 주요 부분으로 구성됩니다: 컴포넌트 클래스, 컴포넌트 템플릿(HTML), 그리고 컴포넌트 스타일시트(CSS).\n다음은 Angular 컴포넌트의 예시입니다:\n\n사용자에 관한 정보를 표시하는 간단한 컴포넌트를 만들고 싶다고 가정해 봅시다:\n\n<div class=\"content-ad\"></div>\n\n- 컴포넌트 클래스를 생성해주세요:\n\n```js\n// user.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-user', // HTML 템플릿에서 사용되는 컴포넌트 셀렉터\n  templateUrl: './user.component.html', // HTML 템플릿 파일 경로\n  styleUrls: ['./user.component.css'] // 이 컴포넌트용 CSS 스타일 파일 경로\n})\nexport class UserComponent {\n  userName: string = 'test user';\n  age: number = 30;\n}\n```\n\n2. 컴포넌트 템플릿을 생성해주세요:\n\n```js\n<!-- user.component.html -->\n<div>\n  <h2>User Information</h2>\n  <p><strong>Name:</strong> { userName }</p>\n  <p><strong>Age:</strong> { age }</p>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n3. 컴포넌트 스타일시트를 생성합니다 (선택 사항):\n\n```js\n/* user.component.css */\ndiv {\n  border: 1px solid #ccc;\n  padding: 10px;\n  margin: 10px;\n}\n```\n\n4. AppModule (또는 다른 관련 모듈)에 컴포넌트를 등록합니다:\n\n```js\n// app.module.ts\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { UserComponent } from './user.component'; // UserComponent를 가져옵니다\n\n@NgModule({\n  imports: [BrowserModule],\n  declarations: [UserComponent], // UserComponent를 선언합니다\n  bootstrap: [UserComponent] // UserComponent를 부트스트랩 컴포넌트로 설정합니다\n})\nexport class AppModule { }\n```\n\n<div class=\"content-ad\"></div>\n\n이제 애플리케이션의 HTML에서 `app-user` 선택기를 사용하여 사용자 정보를 표시할 수 있습니다.\n\n```js\n<!-- app.component.html -->\n<div>\n  <app-user></app-user> <!-- 이것은 UserComponent를 렌더링합니다 -->\n</div>\n```\n\n애플리케이션이 실행되면 다음 출력이 표시됩니다.\n\n```js\n사용자 정보\n이름: 테스트 사용자\n나이: 30\n```\n\n<div class=\"content-ad\"></div>\n\n이것은 Angular 컴포넌트의 기본 예제입니다. 실제 애플리케이션에서는 컴포넌트가 조합되고 필요에 따라 중첩되어 복잡한 사용자 인터페이스를 구축하는 데 널리 사용됩니다.\n\n3. Angular 컴포넌트의 라이프사이클 훅은 무엇입니까?\n\nAngular에서 컴포넌트는 다양한 단계와 이벤트로 구성된 라이프사이클을 가지고 있습니다. 이러한 단계는 라이프사이클 훅이라고 불리며, 컴포넌트의 생성, 렌더링 및 소멸 중 특정 시점에 작업을 수행할 수 있는 기회를 제공합니다. 다음은 Angular 컴포넌트에서 사용할 수 있는 라이프사이클 훅입니다:\n\n- ngOnChanges: 이 훅은 컴포넌트가 입력 속성을받을 때 호출되며 `ngOnInit()` 이전에 실행됩니다. 입력 속성의 변경에 반응할 수 있습니다.\n- ngOnInit: 이 훅은 컴포넌트가 초기화된 후 최초 `ngOnChanges()` 후 한 번 호출됩니다. 일반적으로 서버에서 데이터를 검색하는 것과 같은 초기화 논리에 사용됩니다.\n- ngDoCheck: 이 훅은 변경 감지 작업 중에 호출되며 사용자 정의 변경 감지 로직을 구현할 수 있습니다. 자주 호출되므로 성능 문제를 피하려면 신중하게 사용하세요.\n- ngAfterContentInit: 이 훅은 컴포넌트의 콘텐츠가 뷰로 프로젝트된 후에 호출됩니다. 콘텐츠 자식 컴포넌트와 상호 작용해야 하는 경우 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 Angular 컴포넌트에서 `ngAfterContentInit` 훅을 사용하는 방법의 예시입니다:\n\n```js\nimport { Component, AfterContentInit, ContentChild } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  template: `\n    <ng-content></ng-content>\n  `\n})\nexport class MyComponent implements AfterContentInit {\n  @ContentChild('myContent') myContent: ElementRef;\n  ngAfterContentInit() {\n    // 이 코드는 컴포넌트로 프로젝트된 내용이 초기화된 후에 실행됩니다\n    console.log('콘텐츠가 초기화되었습니다:', this.myContent.nativeElement.textContent);\n  }\n}\n```\n\n이 예시에서 `MyComponent` 컴포넌트에는 템플릿이 포함된 ``ng-content`` 태그가 있는데, 이 태그는 컴포넌트를 사용할 때 콘텐츠가 프로젝트되는 위치를 나타냅니다.\n\n컴포넌트 클래스 내에서는 `@ContentChild` 데코레이터를 사용하여 프로젝트된 콘텐츠에 대한 참조를 얻습니다. 이 경우에는 템플릿 레퍼런스 변수 `myContent`를 가진 요소를 찾고 있습니다. 특정 사용 사례에 따라 CSS 클래스나 컴포넌트 유형과 같은 다른 선택기를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n`ngAfterContentInit` 메소드는 `AfterContentInit` 인터페이스의 일부로 구현됩니다. 이를 통해 컴포넌트의 라이프사이클에 훅을 걸 수 있습니다. 이 메소드 내에서는 프로젝트된(content projection) 콘텐츠를 기반으로 필요한 초기화 또는 로직을 수행할 수 있습니다. 이 예시에서는 프로젝트된 엘리먼트의 텍스트 콘텐츠를 콘솔에 기록합니다.\n\n다른 템플릿에서 `MyComponent` 컴포넌트를 사용하고 프로젝트할 콘텐츠를 제공하는 경우, `ngAfterContentInit` 메소드는 콘텐츠가 초기화된 후 호출됩니다.\n\n```js\n<app-my-component>\n  <div #mycontent>This content will be projected</div>\n</app-my-component>\n```\n\n위 코드가 실행되면 `MyComponent`의 `ngAfterContentInit` 메소드가 트리거되고, 프로젝트된 ``div`` 엘리먼트의 텍스트 콘텐츠를 콘솔에 기록합니다. Angular 컴포넌트에서 `Component`, `AfterContentInit`, `ContentChild`에 대한 필요한 임포트를 `@angular/core` 모듈에서 포함시켜야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n5. ngAfterContentChecked: 이 훅은 Angular의 변경 감지 메커니즘에 의해 컴포넌트의 콘텐츠가 확인된 후 호출됩니다. 콘텐츠 자식들의 확인이 모두 완료된 후에 호출됩니다.\n\n6. ngAfterViewInit: 이 훅은 컴포넌트의 뷰가 초기화된 후에 호출됩니다. 뷰 내에 포함된 자식 컴포넌트와 상호 작용해야 할 때 유용합니다.\n\n다음은 Angular 컴포넌트에서 `ngAfterViewInit` 훅을 사용하는 예제입니다:\n\n```js\nimport { Component, AfterViewInit, ViewChild, ElementRef } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  template: `\n    <div #myDiv>Some content</div>\n  `\n})\nexport class MyComponent implements AfterViewInit {\n  @ViewChild('myDiv') myDiv: ElementRef;\n  ngAfterViewInit() {\n    // 이 코드는 컴포넌트의 뷰가 초기화된 후에 실행됩니다\n    console.log('뷰가 초기화되었습니다:', this.myDiv.nativeElement.textContent);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 `MyComponent` 컴포넌트는 `myDiv` 템플릿 참조 변수를 포함하는 `div` 요소를 포함하는 템플릿을 가지고 있습니다. `@ViewChild` 데코레이터를 사용하여 이 요소에 대한 참조를 컴포넌트 클래스에서 가져올 수 있습니다.\n\n`ngAfterViewInit` 메소드는 `AfterViewInit` 인터페이스의 일부로 구현되며, 컴포넌트 뷰의 라이프사이클에 연결할 수 있도록 합니다. 이 메소드 내에서 컴포넌트의 뷰의 DOM 요소에 액세스하고 조작할 수 있습니다. 이 예에서는 `div` 요소의 텍스트 내용을 콘솔에 로깅합니다.\n\n컴포넌트의 뷰가 초기화될 때, Angular는 `ngAfterViewInit` 메소드를 호출하며, 컴포넌트 뷰나 해당 하위 뷰에 엑세스해야 하는 모든 필요한 작업을 수행할 수 있습니다.\n\n다음은 다른 템플릿에서 `MyComponent` 컴포넌트를 사용하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<app-my-component></app-my-component>\n```\n\n위 코드가 실행되면 `MyComponent` 내의 `ngAfterViewInit` 메소드가 호출되어, ``div`` 엘리먼트의 텍스트 내용이 콘솔에 로깅될 것입니다.\n\nAngular 컴포넌트에서 `Component`, `AfterViewInit`, `ViewChild`, 그리고 `ElementRef`를 위한 필요한 `@angular/core` 모듈의 임포트를 포함시키는 것을 잊지 마십시오.\n\n7. ngAfterViewChecked: 이 훅은 Angular의 변경 감지 메커니즘에 의해 컴포넌트의 뷰가 확인된 후에 호출됩니다. 이는 컴포넌트의 뷰 및 해당 자식 뷰가 확인된 후에 호출됩니다.\n\n<div class=\"content-ad\"></div>\n\n8. ngOnDestroy: 컴포넌트가 제거되고 DOM에서 제거되기 직전에 호출되는 훅입니다. 이는 옵저버블 구독 취소 또는 타이머 취소와 같은 리소스 정리에 사용됩니다.\n\n이 라이프사이클 훅을 사용하면 컴포넌트의 라이프사이클의 다른 단계에서 특정 작업을 수행할 수 있습니다. 이러한 훅을 구현하고 사용함으로써 컴포넌트의 수명 동안 행위를 제어하고 리소스를 효과적으로 관리할 수 있습니다.\n\n4. Angular 웹 구성요소에서 라우팅을 구현하는 방법은 다음 단계를 따릅니다:\n\n<div class=\"content-ad\"></div>\n\n1) Angular의 @Component 데코레이터를 사용하여 웹 컴포넌트를 만드세요. 이것은 컴포넌트의 템플릿, 스타일 및 입력 또는 출력 속성을 정의할 것입니다.\n\n2) 컴포넌트 모듈의 Routes 배열을 사용하여 웹 컴포넌트의 라우트를 정의하세요. 각 라우트에는 경로와 컴포넌트가 포함되어야 합니다.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { MyWebComponent } from './my-web-component.component';\n\nconst routes: Routes = [\n  { path: 'my-component', component: MyWebComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class MyWebComponentRoutingModule { }\n```\n\n3) RouterModule와 MyWebComponentRoutingModule 모듈을 컴포넌트 모듈에 가져와서 imports 배열에 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n\n1. 테이블 태그를 마크다운 형식으로 변경하세요.\n\n\n```js\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { MyWebComponent } from './my-web-component.component';\nimport { MyWebComponentRoutingModule } from './my-web-component-routing.module';\n\n@NgModule({\n  declarations: [MyWebComponent],\n  imports: [\n    CommonModule,\n    RouterModule,\n    MyWebComponentRoutingModule\n  ],\n  exports: [MyWebComponent]\n})\nexport class MyWebComponentModule { }\n```\n\n2. 웹 컴포넌트의 템플릿에서 router-outlet 지시문을 사용하여 라우팅된 컴포넌트를 표시하세요.\n\n```js\n<router-outlet></router-outlet>\n```\n\n3. 다른 컴포넌트나 템플릿에서 routerLink 지시문을 사용하여 웹 컴포넌트 루트로 이동하세요.\n\n\n<div class=\"content-ad\"></div>\n\n\n[My Web Component](/my-component)\n\n\n6) 위 단계를 따라 애플리케이션을 빌드하고 실행하여 라우팅이 적용된 웹 컴포넌트를 확인할 수 있습니다.\n\n이러한 단계를 따르면 Angular를 사용하여 라우팅이 포함된 웹 컴포넌트를 만들 수 있습니다. routerLink 지시문을 사용하여 웹 컴포넌트의 경로로 이동하고 router-outlet 지시문을 사용하여 웹 컴포넌트 내에서 라우팅된 컴포넌트를 표시할 수 있습니다.\n\n5. Angular에서의 레이지 로딩이란 무엇인가요?  \n\n\n<div class=\"content-ad\"></div>\n\nAngular의 Lazy Loading은 응용 프로그램이 시작될 때 모든 모듈과 관련 리소스를 미리 로드하는 대신 필요할 때 모듈과 관련 리소스(컴포넌트, 서비스 등)를 필요할 때 로드하는 기술입니다. 이를 통해 응용 프로그램의 초기 로드 시간을 줄이고 전체 성능을 최적화할 수 있습니다.\n\n기본적으로 Angular는 응용 프로그램이 시작될 때 모든 모듈과 관련 리소스를 로드합니다. 그러나 Lazy Loading을 사용하면 응용 프로그램을 기능 모듈로 분할하고 필요할 때만 동적으로 로드할 수 있습니다. 이렇게 하면 초기 번들 크기를 줄이고 현재 라우트나 기능에 필요한 코드만 로드할 수 있습니다.\n\nAngular에서 Lazy Loading을 구현하려면 다음 단계를 따라야 합니다:\n\n- 기능 모듈 생성: 응용 프로그램을 관련 컴포넌트, 서비스 및 기타 리소스를 캡슐화하는 기능 모듈로 나눕니다. 각 기능 모듈은 자체 라우팅 구성을 갖게 됩니다.\n- 라우트 구성: 응용 프로그램의 주 라우팅 구성에서 `component` 대신 `loadChildren` 속성을 사용하여 기능 모듈의 라우트를 설정합니다. `loadChildren` 속성은 지연 로드할 모듈 파일의 경로를 지정합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst routes: Routes = [\n     { path: '대시보드', component: DashboardComponent },\n     { path: '제품', loadChildren: () => import('./products/products.module').then(m => m.ProductsModule) },\n     // 다른 경로...\n   ];\n```\n\n3. 피처 모듈 생성: 각 피쳐 모듈에서는 `RouterModule.forChild()` 메서드를 사용하여 해당 모듈의 라우팅 구성을 정의합니다.\n\n```js\nconst routes: Routes = [\n     { path: '', component: ProductListComponent },\n     { path: '상세/:id', component: ProductDetailsComponent },\n     // 피쳐 모듈에 특정한 다른 경로들...\n   ];\n\n@NgModule({\n     imports: [RouterModule.forChild(routes)],\n     exports: [RouterModule]\n   })\n   export class ProductsRoutingModule { }\n```\n\n4. 빌드 및 실행: Angular CLI를 사용하여 Angular 애플리케이션을 빌드합니다. 지연로딩 모듈과 관련된 경로로 이동할 때, Angular는 필요한 모듈과 해당 리소스를 요청에 따라 가져와 로드합니다.\n \n\n<div class=\"content-ad\"></div>\n\n게으른 로딩을 사용하면 필요할 때로 로드될 수 있는 작은 모듈로 애플리케이션의 성능을 최적화할 수 있습니다. 초기 로딩 시간을 줄이고 특히 여러 기능을 갖춘 대규모 애플리케이션에 대해 사용자 경험을 향상시킬 수 있습니다.\n\n더 자세한 내용은 아래 Angular의 공식 링크에서 게으른 로딩에 대해 이해할 수 있습니다 — [Angular에서 게으른 로딩](https://angular.io/guide/lazy-loading-ngmodules)\n\n2개의 컴포넌트 간에 데이터를 공유하는 방법은 무엇인가요?\n\n## Angular에서 2개의 컴포넌트 간에 데이터를 공유하는 여러 방법이 있습니다. 여기에는 일반적인 몇 가지 방법이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 상위 구성 요소에서 하위 구성 요소로 데이터 공유(입력 바인딩): Angular에서는 상위 구성 요소에서 하위 구성 요소로 데이터를 공유할 수 있습니다. 이를 위해 입력 속성을 사용합니다. 상위 구성 요소는 하위 구성 요소의 입력 속성에 값을 바인딩합니다. 예시:\n\n상위 구성 요소:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    \n  `\n})\nexport class ParentComponent {\n  sharedData: string = 'Hello from parent!';\n}\n```\n\n하위 구성 요소:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    { data }\n  `\n})\nexport class ChildComponent {\n  @Input() data: string;\n}\n```\n\n2. 부모와 자식 간 통신 (EventEmitter): 자식 컴포넌트에서 부모 컴포넌트로 데이터를 공유해야 할 경우 EventEmitter 클래스를 사용할 수 있습니다. 자식 컴포넌트는 이벤트를 발생시켜 부모 컴포넌트가 이를 수신합니다. 예시:\n\n자식 컴포넌트:\n\n```js\nimport { Component, EventEmitter, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    Send Data\n  `\n})\nexport class ChildComponent {\n  @Output() dataEvent = new EventEmitter();\n  sendData() {\n    const data = 'Hello from child!';\n    this.dataEvent.emit(data);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    { receivedData }\n  `\n})\nexport class ParentComponent {\n  receivedData: string;\n  receiveData(data: string) {\n    this.receivedData = data;\n  }\n}\n```\n\n3. 서비스 (공유 서비스): 컴포넌트 간의 데이터 공유 매개체 역할을 하는 공유 서비스를 생성할 수 있습니다. 서비스는 공유 데이터를 보유하며, 컴포넌트는 이를 읽고 쓸 수 있습니다. 예시:\n\n공유 서비스:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class DataService {\n  sharedData: string = 'Hello from service!';\n}\n```\n\nComponent A:\n\n```js\nimport { Component } from '@angular/core';\nimport { DataService } from 'path-to-data-service';\n\n@Component({\n  selector: 'app-component-a',\n  template: `\n    { dataService.sharedData }\n  `\n})\nexport class ComponentA {\n  constructor(public dataService: DataService) {}\n}\n```\n\nComponent B:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { DataService } from 'path-to-data-service';\n\n@Component({\n  selector: 'app-component-b',\n  template: `\n    Update Data\n  `\n})\nexport class ComponentB {\n  constructor(public dataService: DataService) {}\n  updateData() {\n    this.dataService.sharedData = 'New data!';\n  }\n}\n```\n\nAngular에서 두 개의 컴포넌트 간에 데이터를 공유하는 일반적인 방법들입니다. 선택하는 방법은 컴포넌트 간의 관계 및 애플리케이션의 특정 요구 사항에 따라 다릅니다.\n\n7. Angular에서 사용자 정의 지시자(custom directives)란 무엇이며, 어떻게 만드는지 설명해주세요.\n\n사용자 정의 지시자는 Angular의 기능으로, 개발자가 자체적으로 사용자 정의 HTML 요소나 속성을 만들어 HTML의 기능을 확장할 수 있게 합니다. 사용자 정의 지시자를 사용하면 이벤트 리스너 추가, DOM 수정 또는 데이터 조작과 같은 동작을 정의할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\nAngular에서 사용자 정의 지시문을 만드는 방법은 다음과 같습니다:\n\n- @Directive 데코레이터를 사용하여 새로운 지시문을 만듭니다. 데코레이터는 지시문의 선택기와 입력, 출력 및 기타 옵션을 지정합니다.\n- 지시문 클래스를 정의합니다. 이 클래스에는 지시문의 논리가 포함되어야 합니다. OnInit 및 OnDestroy 인터페이스를 구현하여 지시문의 초기화와 파괴를 처리해야 합니다.\n- 이를 사용할 모듈의 declarations 배열에 지시문을 추가합니다. 이렇게 하면 Angular에 지시문을 해당 모듈에서 사용할 수 있음을 알립니다.\n\n다음은 요소의 배경색을 변경하는 간단한 사용자 정의 지시문의 예시입니다:\n\n```js\nimport { Directive, ElementRef, Renderer2 } from '@angular/core';\n\n@Directive({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n  constructor(private el: ElementRef, private renderer: Renderer2) { }\n  ngOnInit() {\n    this.renderer.setStyle(this.el.nativeElement, 'background-color', 'yellow');\n  }\n  ngOnDestroy() {\n    this.renderer.removeStyle(this.el.nativeElement, 'background-color');\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 HighlightDirective가 요소의 배경색을 초기화할 때 노란색으로 설정하고 제거할 때 배경색을 삭제합니다. ElementRef 및 Renderer2 클래스를 사용하여 DOM에서 요소에 액세스하고 조작합니다.\n\n이 지시문을 템플릿에서 사용하려면 요소에 appHighlight 속성을 간단히 추가하십시오:\n\n```js\n<p apphighlight>\n  이 텍스트는 새로운 노란색 배경이 생깁니다.\n</p>\n```\n\n템플릿이 렌더링되면 HighlightDirective가 요소에 적용되어 배경색을 노란색으로 변경할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n8. ng serve와 npm start의 차이점은 무엇인가요?\n\nng serve와 npm start는 둘 다 웹 개발에서 사용되는 명령어이지만, 상황에 따라 다른 목적으로 사용됩니다. `ng serve`와 `npm start`의 차이를 몇 가지 예제와 함께 살펴보겠습니다:\n\n1. `ng serve` 예제:\n\n예를 들어 Angular 프로젝트에서 작업하고 있고, 개발 목적으로 로컬에서 실행하고 싶다고 가정해봅시다. 프로젝트 디렉토리로 이동하여 다음 명령어를 실행하면 됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nng serve\n```\n\n이 명령어는 Angular 애플리케이션을 컴파일하고 에셋을 번들로 묶은 후 개발 서버를 시작하고 변경 사항을 감시합니다. 그런 다음 브라우저에서 애플리케이션을 액세스하고 테스트할 수 있는 로컬 URL(일반적으로 http://localhost:4200)을 제공합니다. 코드를 수정할 때마다 개발 서버는 애플리케이션을 자동으로 다시 로드할 것입니다.\n\n2. `npm start` 예시:\n\n`package.json` 파일에 `start` 스크립트가 정의된 Node.js 프로젝트에서 작업 중이라고 가정해보겠습니다. `start` 스크립트는 주 애플리케이션 파일인 `index.js`를 실행하도록 설정되어 있습니다. 애플리케이션을 시작하려면 프로젝트 디렉토리로 이동하여 다음 명령어를 실행하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm start\n```\n\n이 명령은 `package.json` 파일의 `start` 스크립트에 지정된 명령을 실행합니다. 이 경우에는 `index.js`를 실행합니다. 지정한 명령은 웹 서버를 시작하거나 빌드 프로세스를 시작하거나 애플리케이션을 프로덕션 또는 배포 환경에서 시작하는 데 필요한 기타 작업을 수행할 수 있습니다.\n\n요약:\n\n`ng serve`는 개발 중에 Angular 프로젝트를 로컬에서 실행하는 데 사용되며 개발 서버와 자동 새로 고침을 제공합니다. 반면, `npm start`는 Node.js 프로젝트에서 일반적으로 사용되는 보다 일반적인 명령으로, `start` 스크립트에 지정된 명령을 실행하는 데 사용되며 종종 프로덕션 환경에서 응용 프로그램을 시작하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n9. ng add와 npm install의 차이는 무엇인가요?\n\nng add와 npm install의 주요 차이점은 Angular 생태계 내에서의 목적과 기능에 있습니다.\n\n- ng add: 이것은 Angular CLI(명령줄 인터페이스)에 특화된 명령어입니다. Angular 프로젝트에 새로운 패키지, 라이브러리 또는 스키매틱을 추가하는 데 사용됩니다. `ng add`를 실행하면 필요한 패키지를 자동으로 설치하고 프로젝트를 구성하며 프로젝트 파일에 필요한 변경 사항을 적용하는 여러 작업이 수행됩니다. `ng add` 명령은 서드파티 라이브러리나 확장 기능을 최소한의 노력으로 Angular 프로젝트에 빠르게 통합하는 데 자주 사용됩니다. 예를 들어 Angular 프로젝트에 Angular Material 라이브러리를 추가하려면 Angular Material을 수동으로 구성하고 설치하는 대신 `ng add` 명령을 사용하여 프로세스를 간단히 할 수 있습니다.\n\n다음은 그 방법입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nng add @angular/material\n```\n\n이 명령을 실행하면 Angular CLI가 다음 작업을 수행합니다:\n\n- `npm install`을 사용하여 `@angular/material` 패키지 및 해당 종속성 설치.\n- `angular.json` 파일을 업데이트하여 프로젝트가 Angular Material을 사용하도록 구성.\n- 프로젝트 파일(e.g., `app.module.ts` 및 `styles.scss`)에 필요한 모듈 및 스타일을 가져오고 구성.\n\n`ng add`는 필요한 설정 단계를 자동화하면서 프로젝트에 Angular 관련 패키지 또는 스키마틱을 추가하는 편리한 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n2. npm install: 이 명령어는 npm(Node Package Manager)이 제공하는 일반적인 명령어로, npm 레지스트리에서 패키지를 설치하는 데 사용됩니다. Angular에 특화된 것은 아니지만 JavaScript와 Node.js 프로젝트 전반에 걸쳐 사용됩니다. `npm install `을 실행하면 지정된 패키지와 해당 종속성이 프로젝트에 설치됩니다. 보통 이 명령은 `package.json` 파일을 업데이트하여 설치된 패키지를 종속성으로 포함시킵니다. 그러나 `npm install`은 프로젝트 파일의 특정 구성 또는 수정을 수행하지 않습니다.\n\n예를 들어, JavaScript용 인기있는 유틸리티 라이브러리인 `lodash`를 설치하려면 다음과 같이 `npm install` 명령을 직접 사용할 수 있습니다:\n\n```js\nnpm install lodash\n```\n\n이 명령을 실행하면 다음을 수행할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- `lodash` 패키지 및 해당 종속성을 npm 레지스트리에서 가져옵니다.\n- 패키지를 프로젝트의 `node_modules` 디렉토리에 로컬로 설치합니다.\n- `package.json` 파일을 업데이트하여 `lodash`를 종속성으로 포함시킵니다. npm install은 특정 프레임워크나 라이브러리의 종류와 관계없이 npm 레지스트리에서 프로젝트로 패키지를 설치하는 일반 명령어입니다.\n\n요약\n\n요약하자면, ng add는 Angular 프로젝트용으로 특별히 설계된 패키지를 자동으로 설치하고 구성하는 Angular CLI의 전문화된 명령어입니다. 반면에 npm install은 Angular 프로젝트를 포함한 JavaScript 또는 Node.js 프로젝트에 npm에서 패키지를 설치하는 일반 명령어입니다.\n\njQuery를 Angular 2/4/5에서 사용할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n네, 다음 단계를 따라 할 수 있어요: \n\n단계 1 — 설치\n\n```js\n// 콘솔에 입력\n// 먼저 jQuery를 설치하세요\nnpm install --save jquery\n// 그리고 jQuery 정의 파일도 설치하세요\nnpm install -D @types/jquery\n```\n\n단계 2 — 가져오기\n\n<div class=\"content-ad\"></div>\n\n```js\n// 지금, 어플리케이션 파일 중 어디에서든 (ES2015 스타일)\nimport * as $ from 'jquery';\n//\n$('#elemId').width();\n\n// OR\n\n// CommonJS 스타일 - \"require\"와 함께 작동\nimport $ = require('jquery')\n//\n```\n# ES6 업데이트\n\nES6에서는 '* as $'이 필요하지 않습니다.\n\n```js\nimport $ from 'jquery';\n//\n$('#elemId').width();\n```\n\n<div class=\"content-ad\"></div>\n\n11. Angular에서 API를 호출하는 방법은?\n\nAngular에서는 HTTP 요청을 손쉽게 만들어주는 'HttpClient' 모듈을 사용하여 API를 호출할 수 있습니다. Angular에서 API를 호출하는 단계별 가이드는 다음과 같습니다:\n\n- 'HttpClient' 모듈을 가져와서 컴포넌트 또는 서비스에 주입합니다. 반드시 '@angular/common/http'에서 가져왔는지 확인하세요.\n\n```js\nimport { HttpClient } from '@angular/common/http';\n\nconstructor(private http: HttpClient) {}\n```\n\n<div class=\"content-ad\"></div>\n\n2. 원하는 HTTP 요청을 만들기 위해 `http.get()`, `http.post()`, `http.put()`, 또는 `http.delete()` 메소드를 사용하세요. 이러한 메소드들은 응답을 처리하기 위해 구독(subscribe)할 수 있는 `Observable`을 반환합니다.\n\n다음은 API에서 데이터를 검색하기 위해 GET 요청을 보내는 예시입니다:\n\n```js\nthis.http.get('https://api.example.com/data').subscribe(response => {\n  // 응답 데이터 처리\n});\n```\n\n3. API가 헤더, 매개변수 또는 요청 본문을 필요로 하는 경우, HTTP 요청에 옵션으로 전달할 수 있습니다. 예를 들어, 헤더 또는 쿼리 매개변수를 포함하기 위해서는 `@angular/common/http`에서 제공하는 `HttpHeaders` 및 `HttpParams` 클래스를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { HttpHeaders, HttpParams } from '@angular/common/http';\n\n// 헤더 및 쿼리 매개변수를 이용한 GET 요청\nconst headers = new HttpHeaders().set('Authorization', 'Bearer token');\nconst params = new HttpParams().set('param1', 'value1').set('param2', 'value2');\n\nthis.http.get('https://api.example.com/data', { headers, params }).subscribe(response => {\n  // 응답 데이터 처리\n});\n```\n\n4. POST, PUT 또는 DELETE 요청의 경우, 두 번째 매개변수로 요청 본문을 전달할 수도 있습니다.\n\n```js\nconst book = { title: 'Example Book', author: 'John Doe' };\n\nthis.http.post('https://api.example.com/books', book).subscribe(response => {\n  // 응답 데이터 처리\n});\n```\n\n위 예시는 HTTP 요청을 간단히 처리하는 방법을 보여줍니다. 실제 상황에서는 에러 처리, 메모리 누수 방지를 위한 `Observable` 구독 해제, 그리고 `HttpClient` 모듘에서 제공하는 다른 옵션과 기능을 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n어플리케이션의 루트 또는 피처 모듈에 `HttpClientModule`을 import하여 `HttpClient` 서비스를 활성화하세요. 일반적으로 모듈의 `imports` 배열에서 다음과 같이 수행됩니다:\n\n```js\nimport { HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n  imports: [HttpClientModule],\n  // 다른 모듈 구성\n})\nexport class AppModule {}\n```\n\n이 단계를 따라가면 Angular에서 API를 쉽게 호출하고 응답을 어플리케이션에서 처리할 수 있습니다.\n\n12. `package.json` 파일의 ‘dependencies’와 ‘dev-dependencies’ 속성의 차이점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n`package.json` 파일에서 `dependencies` 및 `devDependencies` 속성은 Node.js 프로젝트에서 다른 종류의 종속성을 관리하는 데 사용됩니다. 여기에 둘 간의 차이가 있습니다:\n\n- `dependencies`:\n\n— `dependencies` 속성은 프로덕션 또는 배포 환경에서 프로젝트가 실행되기 위해 필요한 패키지를 나열하는 데 사용됩니다.\n\n— 이러한 패키지는 애플리케이션의 핵심 기능에 필요하며 일반적으로 런타임에서 요구됩니다.\n\n<div class=\"content-ad\"></div>\n\n— `npm install` 명령어로 프로젝트 종속성을 설치하면 `dependencies` 섹션에 나열된 패키지들이 설치됩니다. \n\n예시:\n\n```js\n\"dependencies\": {\n     \"express\": \"^4.17.1\",\n     \"lodash\": \"^4.17.21\"\n   }\n```\n\n2. `devDependencies`:\n\n<div class=\"content-ad\"></div>\n\n— `devDependencies` 속성은 개발 중에만 필요한 패키지를 나열하는 데 사용됩니다. 예를 들어, 테스트 프레임워크, 빌드 도구 및 개발 전용 유틸리티가 있습니다.\n\n— 이러한 패키지는 애플리케이션이 프로덕션 환경에서 실행되는 데 필수적이지 않지만, 개발 및 테스트 단계에서 유용합니다.\n\n— `npm install`을 사용하여 프로젝트 종속성과 dev 종속성을 모두 설치할 때, `dependencies` 및 `devDependencies` 섹션에 나열된 패키지가 모두 설치됩니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```json\n\"devDependencies\": {\n     \"mocha\": \"^9.0.3\",\n     \"nodemon\": \"^2.0.13\"\n   }\n```\n\n의존성을 `dependencies`와 `devDependencies`로 분리함으로써, 프로덕션에 필요한 패키지와 개발에 필요한 패키지를 구분할 수 있습니다. 이 분리는 프로덕션 배포 크기를 줄이는 데 도움이 되며, 불필요한 개발 관련 패키지를 배제할 수 있습니다.\n\n결론 :\n\n요약하면, `dependencies`는 프로덕션 환경에서 애플리케이션이 실행되는 데 필요한 패키지가 포함되며, `devDependencies`에는 개발 및 테스트 중에 필요하지만 프로덕션 배포에는 필요하지 않은 패키지가 포함됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 경험있는 분들을 위한 Angular 인터뷰 질문\n\n1. Angular에서 replay subject란 무엇인가요?\n\nAngular에서 ReplaySubject는 RxJS 라이브러리에서 제공되는 Subject 타입입니다. Subject 클래스의 변형으로, 여러 구독자에게 값을 다중으로 브로드캐스트할 수 있습니다.\n\nReplaySubject는 특정 수의 값을 기억하고 다른 구독자에게 값을 리플레이합니다. ReplaySubject에 구독자가 구독하면 지정된 버퍼 크기나 시간 범위까지 버퍼된 값들을 즉시받습니다. ReplaySubject의 주요 기능은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 버퍼링: ReplaySubject는 내가 방출한 값들을 버퍼로 유지합니다. ReplaySubject를 만들 때 버퍼 크기 매개변수를 사용하여 버퍼에 저장할 최대 값 수를 지정할 수 있습니다.\n- 구독: 새 구독자가 ReplaySubject에 구독을 시작하면 즉시 버퍼에 저장된 값들을 받습니다. 버퍼 크기에 도달하면, 구독자들이 새 값들을 수용하기 위해 이전 값들은 버퍼에서 사라집니다.\n- 시간대: 버퍼 크기 외에도 ReplaySubject에 대해 시간대를 지정할 수 있습니다. 시간대를 설정하면, ReplaySubject는 지정된 시간 창 내에서 방출된 값들만 버퍼에 저장합니다. ReplaySubject는 나중에 구독해도 이전에 방출된 값을 받기를 원할 때 유용합니다. 예를 들어, 초기화 시 일부 초기 데이터를 가져와야 하는 컴포넌트가 있을 경우, ReplaySubject를 사용하여 데이터를 캐시하고 후속 구독자가 캐시된 값들을 받을 수 있도록 할 수 있습니다.\n\n아래는 Angular에서 ReplaySubject를 사용하는 예시입니다:\n\n```js\nimport { ReplaySubject } from 'rxjs';\n\n// 3개의 값을 버퍼 크기로 가지는 ReplaySubject 생성\nconst subject = new ReplaySubject(3);\n// ReplaySubject에 값들을 방출\nsubject.next('Value 1');\nsubject.next('Value 2');\nsubject.next('Value 3');\n// ReplaySubject에 구독\nsubject.subscribe(value => console.log('Received:', value));\n// 출력: Received: Value 1, Received: Value 2, Received: Value 3\n// 다른 값 추가 방출\nsubject.next('Value 4');\n// 출력: Received: Value 4 (새 구독자는 최신 값 수신)\n// 시간이 지난 후 다시 구독\nsetTimeout(() => {\n  subject.subscribe(value => console.log('Received later:', value));\n}, 2000);\n// 출력: Received later: Value 2, Received later: Value 3, Received later: Value 4\n```\n\n위 예시에서 ReplaySubject는 마지막으로 방출된 3개의 값들을 버퍼에 저장합니다. 새 구독자가 구독하면 즉시 버퍼에 저장된 값들을 받습니다. 시간이 지난 후에 구독하는 두 번째 구독자는 지정된 시간대 내에 방출된 값들을 받습니다.\n\n<div class=\"content-ad\"></div>\n\nReplaySubjects는 Angular에서 여러 구독자 사이에서 값을 공유하고 재생할 때 특히 비동기 데이터 스트림을 다룰 때 강력한 도구입니다.\n\n2. angular.json에 스타일과 스크립트를 추가하는 것과 index.html에 스타일과 스크립트를 추가하는 것의 차이는 무엇인가요?\n\nAngular에서 `angular.json` 구성 파일에 스타일과 스크립트를 추가하는 것과 `index.html` 파일에 직접 추가하는 것 사이에는 몇 가지 주요 차이점이 있습니다. 이것이 주요 차이점에 대한 설명입니다:\n\n- `angular.json`:\n\n<div class=\"content-ad\"></div>\n\n`angular.json` 파일은 Angular 프로젝트의 구성 파일입니다. 프로젝트 빌드 프로세스와 관련된 여러 설정 및 옵션을 포함하며, 스타일 및 스크립트 구성을 포함합니다.\n\n`angular.json` 파일에서 프로젝트 빌드 프로세스의 일부로 포함해야 할 스타일 및 스크립트를 지정할 수 있습니다. 일반적으로 스타일은 CSS 또는 Sass 파일의 파일 경로 배열을 수락하는 `”styles”` 속성을 사용하여 지정합니다. 스크립트는 일반적으로 JavaScript 또는 TypeScript 파일의 파일 경로 배열을 수락하는 `”scripts”` 속성을 사용하여 지정합니다.\n\n`angular.json` 파일에 정의된 이러한 스타일 및 스크립트는 빌드 프로세스의 일부로 자동으로 포함되고 번들로 묶입니다. 애플리케이션 실행 중에 이들은 로드되어 적용됩니다.\n\n2. `index.html`:\n\n<div class=\"content-ad\"></div>\n\n`index.html` 파일은 Angular 애플리케이션의 주요 HTML 파일입니다. 이 파일은 애플리케이션의 진입점이며 HTML 문서의 기본 구조를 포함합니다.\n\n`index.html` 파일에서는 ``link`` 및 ``script`` 태그를 사용하여 외부 스타일시트나 스크립트를 직접 추가할 수 있습니다. 이러한 태그는 서버에서 호스팅되거나 CDN에서 가져온 외부 CSS 또는 JavaScript 파일을 참조합니다. `index.html` 파일에 포함하면 애플리케이션이 액세스될 때 브라우저에서 로드됩니다.\n\n`index.html` 파일에 직접 추가된 스타일 및 스크립트는 `angular.json` 파일에서 지정된 것과 별개입니다. 이것들은 Angular에서 수행하는 빌드 프로세스나 번들링의 일부가 아닙니다. 대신, `index.html` 파일이 로드될 때 브라우저에서 직접로드되고 적용됩니다.\n\n요약하면, 주요 차이점은:\n\n<div class=\"content-ad\"></div>\n\n- `angular.json` 파일에서 지정된 스타일 및 스크립트는 Angular 빌드 프로세스의 일부이며 빌드 시 애플리케이션과 번들로 결합됩니다.\n- `index.html` 파일에 직접 추가된 스타일 및 스크립트는 브라우저에서 런타임에 로드되며 Angular 빌드 프로세스와 별도로 처리됩니다.\n\n일반적으로 프로젝트의 일부이며 Angular에서 관리되는 스타일 및 스크립트를 포함할 때는 `angular.json` 파일을 사용하는 것이 좋습니다. 반면에 `index.html` 파일에 외부 스타일시트나 스크립트를 추가하는 것은 Angular에서 관리되지 않는 써드파티 라이브러리나 사용자 정의 스타일 및 스크립트를 포함하는 데 유용합니다.\n\n3. Cold observables와 hot observables의 차이점은 무엇인가요 ?\n\nRxJS에서 반응형 프로그래밍을 위한 인기 있는 라이브러리인 RxJS에서 옵저버블은 Cold 옵저버블과 Hot 옵저버블 두 가지 유형으로 분류할 수 있습니다. 이 두 유형의 주요 차이점은 값의 방출 및 구독을 처리하는 방식에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- Cold Observables:\n\nCold Observable은 구독을 시작할 때 값의 방출을 시작합니다. Cold Observable에 대한 각 구독은 Observable의 로직을 별도로 실행합니다. 다시 말해, 데이터 스트림은 각 구독자마다 독립적이며, 각 구독자는 처음부터 발행된 값의 전체 시퀀스를 받게 됩니다.\n\n예를 들어:\n\n```js\nimport { Observable } from 'rxjs';\n\nconst coldObservable = new Observable(observer => {\n  console.log('Observable logic');\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n});\n\ncoldObservable.subscribe(value => console.log('Subscriber 1:', value));\ncoldObservable.subscribe(value => console.log('Subscriber 2:', value));\n```\n\n<div class=\"content-ad\"></div>\n\n아래의 예시에서 각 구독자는 Observable 로직의 실행을 개별적으로 유발하며, 두 구독자 모두 발행된 값의 시퀀스를 완전히 받습니다.\n\n2. 핫 옵저버블:\n\n<div class=\"content-ad\"></div>\n\n핫 옵저버블은 구독 여부에 관계없이 값들을 방출합니다. 생성과 동시에 즉시 값들을 방출하기 시작하며, 구독 이후에만 방출된 값들을 구독자가 받습니다. 데이터 스트림은 구독자들 사이에서 공유되며, 후에 구독하는 구독자는 이전에 방출된 값들을 놓칠 수 있습니다.\n\n예를 들어:\n\n```js\nimport { Subject } from 'rxjs';\n\nconst hotObservable = new Subject<number>();\n\nhotObservable.next(1);\nhotObservable.next(2);\nhotObservable.next(3);\n\nhotObservable.subscribe(value => console.log('Subscriber 1:', value));\n\nhotObservable.next(4);\nhotObservable.next(5);\n\nhotObservable.subscribe(value => console.log('Subscriber 2:', value));\n\nhotObservable.next(6);\nhotObservable.next(7);\n```\n\n출력 결과:\n\n<div class=\"content-ad\"></div>\n\n```js\n가입자 1: 4\n가입자 1: 5\n가입자 1: 6\n가입자 1: 7\n가입자 2: 6\n가입자 2: 7\n```\n\n위 예시에서, 핫 옵저버블은 즉시 값들을 방출하기 시작합니다. 가입자 1은 처음 세 개의 값이 방출된 후에 가입하며 그 이후의 값들을 받습니다. 가입자 2는 나중에 가입하며 해당 가입 이후에만 값들을 받습니다.\n\n핫 옵저버블은 주로 이벤트나 지속적인 데이터 스트림에 사용되며, 해당 값들은 구독과는 독립적으로 생성됩니다.\n\n요약하면, 콜드 옵저버블과 핫 옵저버블의 주요 차이점은 콜드 옵저버블은 구독 시 값들을 방출하고 각 구독은 별도의 실행을 트리거하며, 핫 옵저버블은 구독과 관계없이 값들을 방출하며 늦은 구독자는 이전에 방출된 값들을 놓칠 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n4. @ngModule 데코레이터 내부에 있는 속성들은 무엇인가요?\n\n![링크](/assets/img/2024-05-20-Top90AngularInterviewQuestionsAndAnswersfor2024_1.png)\n\n5. CLI 명령을 사용하여 특정 구성 요소의 spec 파일을 만들지 않고 구성 요소를 생성하는 방법은 무엇인가요?\n\nAngular `8 CLI`용으로 업데이트되었습니다. 한 개의 컴포넌트를 생성하려면 아래 명령을 사용하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nng generate component --skipTests=true component-name\n```\n\n한 프로젝트에서 angular.json 파일에서 다음을 변경하거나 추가하십시오:\n\n```js\n{ \n  \"projects\": {\n    \"{프로젝트_이름}\": {\n      \"schematics\": {\n        \"@schematics/angular:component\": {\n          \"skipTests\": true\n        }\n      }\n    }\n  }\n}\n```\n\n모든 프로젝트에 대한 전역 설정을 변경하려면 angular.json 파일에서 다음을 변경하거나 추가하십시오:\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  \"schematics\": {\n    \"@schematics/angular:component\": {\n      \"skipTests\": true\n    }\n  }\n}\n```\n\n또는 명령 줄을 사용하여\n\n```js\nng config schematics.@schematics/angular:component.skipTests true\n```\n\nAngular `8`에서는 angular-cli.json에서 spec.component 매개변수를 false로 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 위와 같은 테이블 태그를 마크다운 형식으로 변경하고 싶다면, 아래와 같이 변경하시면 됩니다.\n\n\n{\n   ...\n   \"defaults\" : {\n       ...\n       \"spec\": {\n           ...\n           \"component\": false\n       }\n   }\n}\n\n\n또는 생성 시 `— spec=false` 옵션을 사용할 수 있습니다.\n\n\nng generate component --spec=false component-name\n\n\n6. RxJS는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nRxJS(JavaScript용 Reactive Extensions)은 함수형 프로그래밍 개념을 활용하여 비동기 또는 이벤트 기반 프로그램을 조합하는 것을 보다 쉽게 만들어주는 Observables를 사용하는 반응형 프로그래밍을 위한 라이브러리입니다. RxJS는 비동기 데이터 스트림을 Observables로 나타내는 방법을 제공하며, 이를 연산자를 사용하여 선언적으로 변환, 결합 및 사용할 수 있습니다. RxJS는 원래 .NET을 위해 개발된 ReactiveX API를 기반으로 하고 있으나 Java, Swift 및 JavaScript를 포함한 여러 프로그래밍 언어에서 구현되었습니다.\n\nRxJS는 JavaScript에서 비동기 데이터 스트림을 효과적으로 관리할 수 있는 강력한 도구 세트를 제공하여 개발자가 더 효율적이고 유연한 애플리케이션을 만들 수 있게 합니다. 이는 웹 애플리케이션에서 이벤트와 네트워크 요청을 관리하는 데 주로 사용되지만, 반응형 프로그래밍이 유용한 다른 맥락에서도 사용될 수 있습니다.\n\n다음은 JavaScript에서 RxJS를 사용하여 숫자 시퀀스를 방출하고 짝수를 제외한 Observable을 생성하는 예시입니다:\n\n```js\nconst { Observable } = require('rxjs');\n\nconst source$ = new Observable(subscriber => {\n  let count = 0;\n  const intervalId = setInterval(() => {\n    subscriber.next(count);\n    count++;\n  }, 1000);\n  \n  return () => clearInterval(intervalId);\n});\nconst filtered$ = source$.pipe(\n  filter(num => num % 2 !== 0)\n);\nconst subscription = filtered$.subscribe(\n  num => console.log(num),\n  err => console.error(err),\n  () => console.log('Complete')\n);\n\nsetTimeout(() => {\n  subscription.unsubscribe();\n}, 5000);\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 setInterval 함수를 사용하여 숫자 시퀀스를 발생하는 source$라는 Observable을 만듭니다. 그런 다음 source$ Observable에 filter 연산자를 적용하여 순서에서 짝수를 제거한 filtered$라는 새 Observable을 만듭니다. 마지막으로 filtered$ Observable을 구독하고 콘솔에 발생한 값을 기록한 후 5초 후에 Observable이 값을 더 이상 방출하지 않도록 구독을 취소합니다.\n\n7. HttpClientModule는 무엇에 사용되나요?\n\nHttpClientModule은 Angular 버전 4.3.0에서 소개되었습니다.\n\nAngular 4.3.0 이전에는 `HttpModule`이 HTTP 요청 및 응답을 처리하는 데 사용되었습니다. 그러나 Angular 4.3.0부터는 `HttpModule`이 폐기되고 새로운 `HttpClientModule`이 권장됩니다.\n\n<div class=\"content-ad\"></div>\n\n`HttpClientModule`은 HTTP 요청을 만들고 응답을 처리하기 위한 더 현대적이고 개선된 API를 제공합니다. 이 모듈은 인터셉터 지원, 응답 유형 지정 및 개선된 오류 처리와 같은 기능을 포함하고 있습니다.\n\n`HttpClientModule`을 사용하려면 Angular 모듈에서 다음과 같이 해당 모듈을 가져와야 합니다:\n\n```js\nimport { HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n  imports: [\n    HttpClientModule\n  ],\n  // ...\n})\nexport class AppModule { }\n```\n\n모듈을 가져온 후에는 `HttpClient` 서비스를 컴포넌트나 서비스에 주입하여 HTTP 요청을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable()\nexport class MyService {\n  constructor(private http: HttpClient) {\n  }\n\n  getData() {\n    return this.http.get('https://api.example.com/data');\n  }\n}\n```\n\n`HttpClientModule`은 Angular 애플리케이션에서 HTTP를 다루는 더 견고하고 기능이 풍부한 방법을 제공하며, Angular 4.3.0부터 권장되는 접근 방식입니다.\n\n8. 컴포넌트에서 생성자를 정의해야 할 필요가 있나요?\n\nAngular에서는 컴포넌트에 생성자를 정의할 필요가 없습니다. Angular는 컴포넌트에 대한 기본 생성자를 제공하며, 컴포넌트 클래스에 생성자를 정의하지 않으면 기본 생성자가 사용됩니다.\n\n\n<div class=\"content-ad\"></div>\n\nAngular이 제공하는 기본 생성자는 매개변수를 필요로하지 않으며 종종 비어있을 수 있습니다. 컴포넌트가 인스턴스화될 때 암시적으로 호출됩니다.\n\n다음은 생성자가 없는 컴포넌트의 예시입니다:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  template: 'Hello, Angular!'\n})\nexport class MyComponent {\n  // 명시적인 생성자가 정의되어 있지 않음\n}\n```\n\n이 예시에서 `MyComponent` 클래스에는 생성자가 정의되어 있지 않습니다. `MyComponent`의 인스턴스를 만들 때 Angular는 자동으로 기본 생성자를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 컴포넌트에서 초기화 작업이나 의존성 주입이 필요한 경우, 생성자를 정의하고 필요한 매개변수를 제공할 수 있습니다. 생성자는 의존성을 주입하고 컴포넌트 속성을 초기화하는 방법입니다.\n\n```js\nimport { Component } from '@angular/core';\nimport { MyService } from './my.service';\n\n@Component({\n  selector: 'app-my-component',\n  template: 'Hello, Angular!'\n})\nexport class MyComponent {\n  constructor(private myService: MyService) {\n    // 여기서 초기화 또는 다른 로직 수행\n  }\n}\n```\n\n이 예제에서 `MyComponent` 클래스에는 `MyService` 의존성을 주입하는 생성자가 있습니다. 생성자를 사용하여 프로퍼티를 초기화하거나 컴포넌트가 생성될 때 필요한 작업을 수행할 수 있습니다.\n\n따라서 컴포넌트에서 생성자를 정의하는 것이 필수는 아니지만, 필요한 경우 의존성을 주입하고 초기화를 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n9. Angular에는 어떤 보안 기능이 있나요?\n\nAngular는 개발자가 안전한 웹 애플리케이션을 구축하는 데 도움이 되는 여러 가지 보안 기능과 모범 사례를 제공합니다. 다음은 Angular에서 중요한 보안 기능 몇 가지와 함께 사용 예시입니다:\n\n- 템플릿 살균화(Template Sanitization):\n\nAngular는 템플릿에서 사용자 제공 입력을 자동으로 살균화하여 Cross-Site Scripting (XSS) 공격을 방지합니다. 예를 들어, 다음과 같은 템플릿을 고려해보세요:\n\n<div class=\"content-ad\"></div>\n\n\n{{ user.name }}\n\n\nIf the `user.name` property contains potentially harmful HTML code, Angular automatically sanitizes it and renders it as plain text, preventing any script execution.\n\n- We have to add code to sanitize untrusted values. The security contexts are HTML (binding inner HTML), style (CSS), attributes (binding values), and resources (referring files). We should convert the untrusted values provided by users into trusted values with DomSanitizer.\n\n```ts\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { DomSanitizer } from '@angular/platform-browser';\n \n@Injectable()\nexport class SecurityService {\n  constructor(private sanitizer: DomSanitizer) {\n  }\n  getSafeHtml(html: string) {\n    return this.sanitizer.bypassSecurityTrustHtml(html);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n아래 메서드는 값의 유형에 따라 값을 신뢰할 수 있게 표시하는 데 사용됩니다:\n\n- bypassSecurityTrustScript\n- bypassSecurityTrustStyle\n- bypassSecurityTrustUrl\n- bypassSecurityTrustResourceUrl\n\n2. Cross-Site Scripting (XSS) 방지: Angular에서는 기본적으로 보간된 값을 및 데이터 바인딩을 자동으로 이스케이프하여 XSS 공격을 방지합니다. 예를 들어, 다음 템플릿을 고려해보세요:\n\n```js\n{ user.bio }\n```\n\n<div class=\"content-ad\"></div>\n\n`user.bio` 속성에 스크립트 태그나 기타 HTML 코드가 포함되어 있으면 Angular는 문자를 이스케이프하고 일반 텍스트로 렌더링하여 스크립트 실행을 방지합니다.\n\n3. 콘텐츠 보안 정책 (CSP) 지원:\n\nAngular는 어플리케이션에 엄격한 콘텐츠 보안 정책을 강제 적용할 수 있게 해줍니다. 이를 통해 애플리케이션이 리소스를로드 할 수 있는 소스를 정의하여 XSS 공격으로부터 보호할 수 있습니다. 예를 들어, 다음과 같이 HTML 헤더에 CSP를 구성할 수 있습니다:\n\n```js\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self' https://trusted-cdn.com;\">\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시는 스크립트의 로딩을 동일한 출처와 신뢰할 수 있는 CDN에 제한하는 방법을 보여줍니다.\n\n4. HTTP 인터셉터:\n\nAngular의 HttpClient 모듈은 인터셉터를 제공하여 HTTP 요청과 응답을 수정할 수 있습니다. 인터셉터를 사용하여 인증 헤더를 추가하거나 CSRF 토큰을 처리하는 것과 같은 보안 관련 기능을 구현할 수 있습니다. 예를 들어, 모든 외부 요청에 인증 토큰을 추가하기 위한 인터셉터를 만들 수 있습니다:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest, next: HttpHandler): Observable> {\n    const token = 'your-auth-token';\n    const authReq = req.clone({\n      headers: req.headers.set('Authorization', `Bearer ${token}`)\n    });\n    return next.handle(authReq);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 인터셉터는 각 나가는 HTTP 요청에 Bearer 토큰이 포함된 `Authorization` 헤더를 추가합니다.\n\n5. 인증 및 권한:\n\nAngular는 인증 및 권한 메커니즘을 구현하기 위한 유연한 프레임워크를 제공합니다. 라우트 가드, 인증 서비스 및 토큰 기반 인증(JWT 등)과 같은 기능을 활용하여 루트를 보안하고 보호된 리소스에 대한 액세스를 제어할 수 있습니다. 특정 루트에 대한 액세스를 제한하는 라우트 가드 예제는 다음과 같습니다:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  constructor(private router: Router) {}\n  canActivate(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {\n    // 사용자가 인증되었는지 확인합니다. 예: 유효한 토큰 유무 확인\n    const 인증됨 = ...;\n    if (인증됨) {\n      return true;\n    } else {\n      // 로그인 페이지로 리다이렉트하거나 액세스 거부 메시지 표시\n      this.router.navigate(['/login']);\n      return false;\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n사용자가 인증되었는지 확인하고 보호된 경로에 대한 액세스를 허용하거나 거부하는 가드입니다.\n\n6. 위험한 Angular API 피하기\n\n\"보안 위험\"으로 표시된 Angular API를 피하세요. 우리가 가장 많이 사용하는 위험한 API는 ElementRef입니다. 이 API는 DOM에 직접 액세스를 허용하며 애플리케이션을 XSS 공격에 노출시킬 수 있습니다. 코드에서 ElementRef의 사용을 주의 깊게 검토하세요. DOM에 직접 액세스해야 할 때에만 이 API를 마지막 수단으로 사용하세요. Angular이 제공하는 템플릿 및 데이터 바인딩을 사용하세요. 또는 네이티브 엘리먼트에 직접 액세스할 수 없는 경우에도 안전하게 사용할 수 있는 Renderer2를 살펴보세요.\n\n이것들은 Angular에서 제공하는 보안 기능의 일부 예시에 불과합니다. 애플리케이션의 요구 사항에 따라 입력 유효성 검사, 안전한 통신 프로토콜(HTTPS), 적절한 오류 처리 및 의존성 및 라이브러리의 정기적인 보안 업데이트와 같은 추가 보안 조치를 구현하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n**10. Jasmine에서 testbed는 무엇인가요?**\n\nJasmine의 맥락에서 TestBed는 Angular이 제공하는 유틸리티로, Angular 컴포넌트, 디렉티브, 서비스 및 다른 Angular 구조물을 테스트하기 위한 것입니다. TestBed는 구성 및 테스트할 컴포넌트 및 서비스를 생성하고 초기화할 수 있는 테스트 모듈 환경을 생성합니다.\n\nTestBed는 Angular 테스팅 유틸리티의 일부이며, 주로 Karma 또는 Jest와 같은 다른 테스팅 프레임워크와 함께 사용됩니다. 이는 컴포넌트 생성, 의존성 주입 및 변경 감지를 용이하게 하는 Angular 전용 환경을 제공합니다.\n\n다음은 Jasmine에서 TestBed를 사용하는 기본 예제입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { TestBed } from '@angular/core/testing';\nimport { MyComponent } from './my.component';\n\ndescribe('MyComponent', () => {\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [MyComponent],\n    }).compileComponents();\n  });\n  it('should create the component', () => {\n    const fixture = TestBed.createComponent(MyComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeTruthy();\n  });\n  // Other test cases...\n});\n```\n\n여기 예제에서 `beforeEach` 함수는 각 테스트 케이스 전에 호출되며, 그 안에서 `TestBed.configureTestingModule`를 사용하여 테스팅 모듈을 구성합니다. `declarations` 속성을 사용하여 테스트할 컴포넌트를 선언합니다. 이 경우 `MyComponent`를 선언하였습니다.\n\n`compileComponents` 함수는 컴포넌트의 템플릿과 종속성을 컴파일하는 비동기 작업입니다.\n\n개별 테스트 케이스 내에서 `TestBed.createComponent`을 사용하여 테스트할 컴포넌트의 인스턴스를 생성합니다. 이는 `ComponentFixture` 객체를 반환하며, 해당 컴포넌트 인스턴스 (`componentInstance`)와 관련된 DOM 요소 (`nativeElement`)에 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nTestBed과 ComponentFixture를 사용하면 구성 요소의 속성, 메서드 및 렌더링된 DOM과 상호 작용하고 테스트할 수 있습니다.\n\nTestBed는 테스트 모듈을 구성하는 데 사용되는 다른 유용한 메서드도 제공합니다. 모의 서비스 제공, 라우트 구성 및 의존성 주입 처리와 같은 것들이 가능합니다.\n\n전반적으로, Jasmine의 TestBed은 Angular 애플리케이션에 대해 강력한 테스트 환경을 제공하여 Angular 구성 요소와 서비스를 격리되고 제어된 방식으로 생성하고 테스트할 수 있게 합니다.\n\n11. Subject와 Behaviour Subject의 차이점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n자바스크립트에서 반응형 프로그래밍을 위한 인기 있는 라이브러리인 RxJS에는 Subject와 BehaviorSubject 두 가지 유형의 subjects가 있습니다. 두 subject 모두 Subject 클래스의 구현체이지만 동작에 몇 가지 중요한 차이점이 있습니다.\n\n- Subject: Subject는 여러 옵저버에 의해 구독될 수 있는 멀티캐스트 옵저버블입니다. 옵저버블 및 옵저버 모두 역할을 수행하며, `next()` 메서드를 사용하여 값을 푸시하거나 값을 받기 위해 Subject를 구독할 수 있습니다. Subject가 새 값을 발행하면 구독된 모든 옵저버가 해당 값을 받습니다.\n- BehaviorSubject: BehaviorSubject는 \"현재 값\" 개념을 갖는 Subject의 일종입니다. 최신 값을 유지하고 새 구독자에게 최신 값을 발행합니다. BehaviorSubject를 생성할 때 초기 값이 필요합니다. BehaviorSubject를 구독하는 구독자는 즉시 현재 값 또는 최신으로 발행된 값을 받게 됩니다.\n\n다음은 Subject와 BehaviorSubject 간의 주요 차이점입니다:\n\n— 초기 값: Subject는 초기 값이 없지만, BehaviorSubject는 생성 시 초기 값이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n— 지연 구독: `Subject`를 구독하면 이전에 발생한 값들을 받지 않습니다. 그러나 `BehaviorSubject`를 구독할 때 값이 이미 발행된 후라면, 구독 즉시 최신 값이 전달됩니다.\n\n— 기본값: 구독하기 전에 `BehaviorSubject`에서 발행된 값이 없는 경우, 생성 시 제공된 초기 값이 발행됩니다. 이는 일부 값이 발행된 후에 구독하는 경우에도 구독자가 기본값을 갖도록 하는 데 유용합니다.\n\n다음은 차이를 설명하는 예시입니다:\n\n```js\nimport { Subject, BehaviorSubject } from 'rxjs';\n\nconst subject = new Subject();\nconst behaviorSubject = new BehaviorSubject('초기 값');\n// Subject에 구독\nsubject.subscribe(value => console.log('Subject:', value));\n// BehaviorSubject에 구독\nbehaviorSubject.subscribe(value => console.log('BehaviorSubject:', value));\n// 값 발행\nsubject.next('값 1');\nbehaviorSubject.next('값 2');\n// 값 발행 후에 구독\nsubject.subscribe(value => console.log('Subject에 지연 구독:', value));\nbehaviorSubject.subscribe(value => console.log('BehaviorSubject에 지연 구독:', value));\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nBehaviorSubject: Initial Value\nSubject: Value 1\nBehaviorSubject: Value 2\nLate Subscription to BehaviorSubject: Value 2\n```\n\n예시에서, `subject`를 사용하여 `Value 1`을 발행할 때, 발행 전에 가입한 구독자만 값 수신합니다. 그러나 `behaviorSubject`를 사용하여 `Value 2`를 발행할 때, 기존 구독자와 나중에 가입한 구독자 모두 즉시 최신 값을 수신합니다.\n\n결론:\n\n<div class=\"content-ad\"></div>\n\n요약하면 `Subject`와 `BehaviorSubject`의 주요 차이점은 `BehaviorSubject`가 초기 값이 있으며 가장 최근의 값을 유지하고 새로운 구독자들에게 값을 발행한다는 것입니다. 이것은 구독자가 일부 값이 발행된 후에 구독해도 기본값이나 가장 최신 값이 전달되도록 보장해야 하는 시나리오에서 유용합니다.\n\n12. HTTP 요청에 대한 Promise 대신에 Observable을 사용하는 장점은 무엇인가요?\n\nPromise는 단일 값만 발행하는 반면 Observable은 여러 값을 발행합니다. 따라서 HTTP 요청을 처리하는 중에, Promise는 동일한 요청에 대해 단일 응답을 관리할 수 있지만, 동일한 요청에 대해 여러 응답이 있는 경우에는 Observable을 사용해야 합니다. 네, Observable은 동일한 요청에 대해 여러 응답을 처리할 수 있습니다. 예시로 구현해보죠.\n\n```typescript\n프로미스 예시\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nconst promise = new Promise((data) => { \n  data(1);\n  data(2);\n  data(3);\n }).then(element => console.log('Promise ' + element));\n\nOutput:- Promise 1\n```\n\nObservable e.g\n\n```js\nconst observable = new Observable((data) => {\ndata.next(1);\ndata.next(2);\ndata.next(3);\n}).subscribe(element => console.log('Observable ' + element));\n\n// Output\nObservable 1\nObservable 2\nObservable 3\n```\n\n13. 권한 부여와 인증의 차이점. 기본 차이를 설명하되, 앵귤러 애플리케이션의 맥락에서도 설명해 주세요.\n\n<div class=\"content-ad\"></div>\n\n인증(Authentication)과 권한 부여(authorization)는 사용자의 액세스와 소프트웨어 애플리케이션의 보안과 관련된 두 가지 다른 개념입니다. 이 내용은 Angular 애플리케이션을 포함한 소프트웨어 애플리케이션에 적용됩니다.\n\n**인증(Authentication):**\n\n인증은 사용자 또는 엔티티 신원을 확인하는 프로세스입니다. 사용자가 주장하는 대로 본인인지 확인합니다. 인증은 일반적으로 사용자 이름과 비밀번호와 같은 자격 증명을 제시하여 신원을 증명하는 과정을 포함합니다. 한 번 인증되면 사용자는 애플리케이션에 액세스할 수 있습니다.\n\nAngular 애플리케이션의 맥락에서, 인증은 사용자의 신원을 확인한 후 애플리케이션의 보호받는 부분에 액세스를 허용하기 전의 과정입니다. 사용자가 자격 증명을 제공하고 애플리케이션이 저장된 사용자 데이터나 인증 서비스와 비교하여 검증하는 로그인 시스템을 구현함으로써 달성할 수 있습니다. 인증에 성공하면 사용자는 인증 토큰이나 세션을 받게 되는데, 이를 사용하여 사용자를 식별하고 애플리케이션의 제한된 영역에 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n인증:\n\n인증은 응용 프로그램 내에서 특정 리소스나 기능에 대한 액세스 권한을 부여하거나 거부하는 프로세스입니다. 사용자가 인증된 신분과 할당된 권한에 기반하여 사용자가 어떤 작업을 수행하거나 어떤 리소스에 액세스할 수 있는지 결정합니다. 권한은 응용 프로그램 내에서 사용자가 수행할 수 있는 작업 또는 작업을 제어합니다.\n\nAngular 애플리케이션에서는 인증 후에 인가가 이루어집니다. 사용자가 인증된 후에 애플리케이션은 사용자가 특정 작업을 수행하거나 특정 부분에 액세스할 필요 권한이 있는지 결정하는 액세스 제어 규칙을 시행해야 합니다. 이 과정에는 역할, 권한 또는 기타 액세스 제어 메커니즘이 포함될 수 있습니다. 예를 들어, 관리자는 특정 관리 기능 또는 데이터에 액세스할 수 있지만 일반 사용자는 제한된 액세스만 허용될 수 있습니다.\n\nAngular 애플리케이션에서 인가를 구현하기 위해 개발자들은 일반적으로 역할과 권한을 정의한 다음 응용 프로그램 전체에 걸쳐 검사 및 가드를 적용하여 특정 작업을 수행하거나 특정 경로 또는 구성 요소에 액세스할 수 있는 사용자가 인가된 사용자만 수행할 수 있도록 보장합니다. 이는 역할 기반 액세스 제어 (RBAC)를 구현하거나 다른 인가 프레임워크나 라이브러리를 사용하는 것을 포함할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n간단히 말해, 인증과 권한 부여의 기본적인 차이점은 인증이 사용자의 신원을 확인하는 반면, 권한 부여는 인증된 사용자가 응용 프로그램 내에서 어떤 작업 또는 자원에 접근할 수 있는지를 제어합니다. 인증은 누구인지 확인하는 것이고, 권한 부여는 신원이 확인된 후 무엇을 할 수 있는지를 결정하는 것입니다.\n\n14. Angular에서 AOT란 무엇인가요?\n\n더 잘 이해하기 위해서는 Angular 8까지 기본 Angular 컴파일 모드였던 JIT부터 이해하는 것이 먼저 중요합니다. JIT 이후에는 AOT가 어떻게 작동하며 JIT와 어떤 차이가 있는지 살펴보겠습니다:\n\nJust-in-Time (JIT)\n\n<div class=\"content-ad\"></div>\n\nJIT 컴파일 모드에서는 개발자가 작성한 TS 코드가 빌드 생성 중에 JS 코드로 컴파일됩니다. 이제 이 컴파일된 JS 코드에는 브라우저에서 다시 실행 시간에 JIT 컴파일러와 함께 전송되어 컴파일된 일부 Angular 특정 코드(컴포넌트, 데코레이터, 변경 감지, 의존성 주입 등)가 포함되어 있습니다.\n\nJIT 모드에서 Angular 애플리케이션이 브라우저에서 부트스트랩될 때, JIT 컴파일러는 실행 시간에 애플리케이션의 컴포넌트를 분석하고 메모리에 코드를 생성하기 위해 많은 작업을 수행합니다. 페이지가 새로고침되면 수행된 모든 작업이 삭제되고 JIT 컴파일러가 다시 작업을 수행합니다.\n\n시간 앞에(AOT)\n\n개발자가 작성한 TS 코드가 JS 코드로 컴파일되며, 이 JS 코드는 이미 Angular을 위해 컴파일되었습니다. 이제 이 컴파일된 JS 코드가 브라우저에 의해 다시 한 번 컴파일되어 HTML이 렌더링됩니다. 하지만 여기서 함정은 AOT 컴파일러가 Angular의 기능을 이미 처리했으므로 브라우저가 컴포넌트 생성, 변경 감지, 의존성 주입에 대해 크게 걱정할 필요가 없다는 점입니다. 따라서 우리는:\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n더 나은 보안\n\nAOT는 HTML 템플릿과 컴포넌트를 클라이언트에 제공되기 훨씬 이전에 JavaScript 파일로 컴파일합니다. 읽을 템플릿도 없고 위험한 클라이언트 측 HTML 또는 JavaScript 평가도 없어서, 인젝션 공격 기회가 적어집니다.\n\nAngular 공식 문서 링크를 참조하여 AOT 이해하기\n\n15. Angular에서 커스텀 pipe를 생성하는 방법은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nAngular에서 사용자 정의 파이프를 만들려면 다음 단계를 따를 수 있어요:\n\n- 파이프 생성: Angular CLI를 사용하여 `ng generate pipe` 명령어를 사용해 새 파이프를 생성하세요. 터미널을 열고 Angular 프로젝트의 루트 디렉토리로 이동한 다음 다음 명령어를 실행하세요:\n\n```js\nng generate pipe custom\n```\n\n이 명령어를 실행하면 `custom.pipe.ts` 파일이 생성되고 프로젝트의 적절한 디렉토리에 추가될 거예요.\n\n<div class=\"content-ad\"></div>\n\n2. 파이프 구현하기:\n\n`custom.pipe.ts` 파일을 열고 `CustomPipe` 클래스의 `transform` 메서드 안에 사용자 정의 파이프 로직을 구현하세요. `transform` 메서드는 입력 값을 받고 옵션 매개변수를 사용하여 원하는 변환을 수행한 후 결과를 반환합니다.\n\n다음은 주어진 숫자를 두 배로 만드는 사용자 정의 파이프 예시입니다:\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'custom'\n})\nexport class CustomPipe implements PipeTransform {\n  transform(value: number): number {\n    return value * 2;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 `transform` 메서드는 숫자를 입력으로 받아들이고(`value`) 입력 숫자를 두 배로 만든 결과를 반환합니다(`value * 2`).\n\n3. 파이프 등록:\n\nAngular 애플리케이션에서 사용자 정의 파이프를 사용하려면 해당 모듈에 등록해야 합니다. 사용할 모듈 파일을 열어서(e.g., `app.module.ts`) `CustomPipe` 클래스를 import하세요. 그런 다음 모듈의 데코레이터 안의 `declarations` 배열에 `CustomPipe`를 추가하세요.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppComponent } from './app.component';\nimport { CustomPipe } from './custom.pipe';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    CustomPipe\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n<div class=\"content-ad\"></div>\n\n4. 사용자 정의 파이프 사용하기:\n\n이제 사용자 정의 파이프가 등록되었으므로 해당 이름을 참조하여 템플릿에서 사용할 수 있습니다. 예를 들어, 컴포넌트의 템플릿(`app.component.html`)에서 다음과 같이 사용자 정의 파이프를 사용할 수 있습니다:\n\n```js\n<h1>{ 5 | custom }</h1>\n```\n\n이 예에서 `custom` 파이프가 값 `5`에 적용되고 변환된 결과(10)가 `<h1>` 요소에 표시됩니다. 이 것으로 사용자 정의 파이프를 Angular에서 생성했습니다. 이제 해당 파이프를 사용하여 템플릿 내에서 데이터에 사용자 정의 변환을 적용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n16. 내장 Angular 파이프란 무엇인가요?\n\nAngular은 여러 내장 파이프를 제공하여 Angular 애플리케이션에서 데이터를 변환하고 형식화하는 데 사용할 수 있습니다. 다음은 일반적으로 사용되는 내장 Angular 파이프 몇 가지입니다:\n\n1. DatePipe: 지정된 형식에 따라 날짜 값을 형식화합니다.\n\n```js\n<p>{ today | date }</p>\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n<p>{{ today | date: 'short' }}</p>\n```\n\n2. UpperCasePipe와 LowerCasePipe: 문자열을 대문자 또는 소문자로 변환합니다.\n\n```js\n<p>{{ 'Hello World' | uppercase }}</p>\n\n<p>{{ 'Hello World' | lowercase }}</p>\n```\n\n3. DecimalPipe: 숫자를 지정된 정밀도에 따라 10진수 형식으로 서식화합니다.\n\n<div class=\"content-ad\"></div>\n\n\n1. NumberPipe: 지정된 형식에 따라 숫자를 포맷합니다.\n\n```js\n<p>{{ 3.14159 | number: '1.2-3' }}</p>\n```\n\n2. DecimalPipe: 소수점 이하 자릿수를 조절하여 숫자를 포맷합니다.\n\n```js\n<p>{{ 12345.6789 | number: '1.2-3'}}</p>\n```\n\n3. CurrencyPipe: 특정 통화 코드에 따라 숫자를 통화로 변환합니다.\n\n```js\n<p>{{ 1000 | currency: 'USD' }}</p>\n```\n\n4. PercentPipe: 숫자를 백분율로 포맷합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<p>{ 0.75 | percent }</p>\n```\n\n6. SlicePipe: 문자열이나 배열의 일부를 반환합니다.\n\n```js\n<p>{ 'Hello World' | slice: 0:5 }</p>\n\n<p>{ [1, 2, 3, 4, 5] | slice: 0:3 }</p>\n```\n\n7. AsyncPipe: 비동기 값에 대한 처리를 수행하며 observable 또는 promise를 구독하여 값이 변경될 때 자동으로 뷰를 업데이트합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<p>{ asyncData$ | async }</p>\n```\n\n위는 내장 Angular 파이프의 몇 가지 예시에 불과합니다. Angular는 `KeyValuePipe`, `JsonPipe`, `PercentPipe`와 같은 더 많은 파이프를 제공하는데, 각각이 특정한 목적을 제공합니다. 이전 응답에서 설명한 대로 자체 사용자 정의 파이프도 만들 수 있습니다.\n\n17. 소프트웨어 버전 명명법(의미 있는 버전)을 설명해 주세요.\n\n의미 있는 버전(semantic versioning) 또는 SemVer은 소프트웨어 프로젝트에서 사용되는 버전 지정 방식으로, 소프트웨어의 다양한 릴리즈에서의 호환성, 기능 및 변경 사항에 대한 정보를 전달합니다. 특정 형식을 따릅니다: `..`.\n\n<div class=\"content-ad\"></div>\n\n1. 주 버전(``major``): 주 버전은 소프트웨어에 중대한 변경사항을 나타냅니다. 이는 하위 호환되지 않는 변경사항, 주요 새로운 기능 또는 중요한 아키텍처 변경을 포함합니다.\n\n2. 부 버전(``minor``): 부 버전은 소프트웨어에 하위 호환적인 추가 또는 향상을 나타냅니다. 기존 기능을 망가뜨리지 않으면서 추가된 새로운 기능 또는 기능을 포함합니다.\n\n3. 패치 버전(``patch``): 패치 버전은 하위 호환적인 버그 수정, 보안 패치 또는 새로운 기능을 도입하지 않는 작은 업데이트를 나타냅니다. 이러한 업데이트는 일반적으로 소프트웨어의 문제, 버그 또는 보안 취약점을 해결합니다.\n\n아래는 의미론적 버전 관리의 몇 가지 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n— Version `1.0.0`: 소프트웨어의 초기 릴리스로 안정적인 상태에 도달했음을 나타냅니다. 일반적으로 첫 번째 안정적 릴리스에서 주 버전은 `1`로 시작합니다.\n\n— Version `1.2.3`: 이 버전은 이전 릴리스 이후에 (`1`) 역호환성 특징 추가나 향상이 있었음을 나타내며, 역호환성 버그 수정이나 패치 (`2`) 및 소규모 버그 수정 또는 작은 업데이트 (`3`)가 있었음을 나타냅니다.\n\n— Version `2.0.0`: 이 버전은 소프트웨어에서 역호환되지 않는 변경 사항이나 주요 업데이트를 소개하는 주요 릴리스를 나타냅니다.\n\n시맨틱 버전 관리는 개발자와 사용자가 소프트웨어 버전의 업데이트와 변경 사항의 영향을 이해하는 데 도움이 됩니다. 이것은 다양한 릴리스의 호환성과 중요성을 전달하기 위한 일관된 표준화된 방법을 제공하여 개발자가 종속성을 관리하고 업그레이드를 처리하며 프로젝트 간의 호환성을 보장할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n노트해야 할 점은 의미론적 버전 관리가 소프트웨어 프로젝트에만 적용되는 것이 아니라는 것입니다. 라이브러리, API, 프레임워크 또는 버전 관리 체계를 따르는 다른 프로젝트에도 적용할 수 있습니다.\n\n18. Angular에서 스토리북이 무엇인가요?\n\n자세한 설명은 여기를 확인해주세요.\n\n19. Angular에서 사용되는 디자인 패턴은 무엇이 있나요?\n\n<div class=\"content-ad\"></div>\n\n앵귤러는 웹 애플리케이션을 구축하는 인기 있는 JavaScript 프레임워크로, 코드를 구조화하고 조직하는 데 일반적으로 사용되는 여러 디자인 패턴이 있습니다. 이러한 디자인 패턴은 개발자가 유지보수 가능하고 확장 가능하며 모듈화된 애플리케이션을 만들 수 있도록 돕습니다.\n\n다음은 앵귤러에서 자주 사용되는 몇 가지 디자인 패턴입니다:\n\n1. 싱글톤 패턴: 앵귤러 서비스는 종종 싱글톤 패턴을 사용하여 구현됩니다. 서비스는 한 번 인스턴스화되며 여러 구성 요소간에 공유되어 통신하고 데이터를 공유할 수 있게 합니다.\n\n앵귤러에서 싱글톤 패턴을 구현하려면 다음 단계를 따를 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\na. Angular CLI를 사용하여 서비스를 생성하세요:\n\n```js\nng generate service MySingletonService\n```\n\nb. Angular에서 단일 서비스를 만드는 두 가지 방법이 있습니다:\n\n- `providedIn` 속성\n\n<div class=\"content-ad\"></div>\n\n- NgModule providers 배열\n\nc. 생성된 서비스 파일(`my-singleton-service.service.ts`)을 열어서 다음과 같이 수정하십시오:\n\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MySingletonService {\n  // 서비스 구현 내용을 여기에 작성합니다\n}\n```\n\nd. `@Injectable` 데코레이터 안의 `providedIn: 'root'` 속성은 Angular에서 싱글톤 패턴을 구현하는 데 중요합니다. 이는 Angular에 서비스를 루트 수준에서 제공하도록 알려주어 애플리케이션 전반에서 접근 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\ne. 이제 `MySingletonService`를 단일 인스턴스 서비스로 사용하기 위해 구성 요소에서 이를 생성자에 주입할 수 있습니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { MySingletonService } from './my-singleton-service.service';\n\n@Component({\n  selector: 'app-my-component',\n  template: '...',\n})\nexport class MyComponent {\n  constructor(private mySingletonService: MySingletonService) {\n    // 여기서 공유 서비스 인스턴스에 액세스할 수 있습니다\n  }\n}\n```\n\n`MySingletonService`를 여러 구성 요소에 주입하면 응용 프로그램 전체에서 동일한 서비스 인스턴스에 액세스하여 데이터 일관성과 공유를 보장할 수 있습니다.\n\n단일 인스턴스 서비스의 수명주기는 Angular 자체에서 관리됩니다. Angular는 서비스의 단일 인스턴스를 생성하고 유지하며 이를 요청하는 구성 요소들 사이에서 공유합니다.\n\n<div class=\"content-ad\"></div>\n\nNgModule providers 배열의 경우, providers 배열에 서비스를 값으로 전달하여 싱글톤 서비스를 생성하며, NgModule이 루트 앱 모듈인 경우 해당 서비스는 응용 프로그램 전체에서 싱글톤 서비스로 사용할 수 있습니다.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { MySingletonService } from './my-singleton-service.service';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  providers: [MySingletonService], // 서비스를 여기에 추가\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\nAngular에서 서비스를 사용하여 싱글톤 패턴을 구현하는 방법입니다. 이를 통해 데이터를 공유하고 상태를 유지하며 응용 프로그램 전체에서 중앙화된 기능을 제공할 수 있습니다.\n\n2. 의존성 주입 (DI) 패턴: Angular는 의존성 주입 패턴을 활용하여 컴포넌트와 서비스 간의 의존성을 관리합니다. DI를 사용하면 필요한 의존성이 구성자 주입 또는 속성 주입을 통해 컴포넌트나 서비스에 제공되어느 느슨한 결합을 촉진하고 테스트 가능성을 높입니다.\n\n<div class=\"content-ad\"></div>\n\n```typescript\n// DI를 사용하는 컴포넌트\nconstructor(private productService: ProductService) {\n  // productService 사용하기\n}\n```\n\n3. 옵저버 패턴: Angular은 EventEmitter 클래스와 RxJS 라이브러리를 통해 옵저버 패턴을 활용합니다. 컴포넌트는 EventEmitters를 사용하여 이벤트를 발생시키고, 다른 컴포넌트는 이러한 이벤트에 구독하여 이에 맞게 반응할 수 있습니다.\n\n```typescript\n// 이벤트를 발생시키는 컴포넌트\n@Output() productSelected = new EventEmitter();\n\nselectProduct(product: Product) {\n  this.productSelected.emit(product);\n}\n// 이벤트를 구독하는 컴포넌트\n```\n\n4. 전략 패턴: 전략 패턴을 통해 런타임에 특정 조건이나 요구 사항에 따라 동적으로 다양한 전략을 선택하고 전환할 수 있습니다. 이러한 동작을 별도의 클래스에 캡슐화하여 컴포넌트는 특정 조건에 따라 전략을 전환할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서 전략 패턴을 구현하는 예시를 보여드릴게요:\n\na. 전략들의 공통 동작을 나타내는 인터페이스를 정의해봅시다. 여기서는 지불 처리 시나리오를 가정해보겠습니다:\n\n```js\n// payment-strategy.interface.ts\nexport interface PaymentStrategy {\n  processPayment(amount: number): void;\n}\n```\n\nb. `PaymentStrategy` 인터페이스를 구현하는 별도의 클래스를 생성하여 여러 전략을 구현해봅시다. 각 클래스는 `processPayment` 메서드의 고유한 구현을 제공할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// credit-card-strategy.ts\nexport class CreditCardStrategy implements PaymentStrategy {\n  processPayment(amount: number): void {\n    console.log(`$${amount}의 신용카드 결제 처리 중`);\n    // 여기에 신용카드 결제 처리 로직을 수행합니다\n  }\n}\n\n// paypal-strategy.ts\nexport class PaypalStrategy implements PaymentStrategy {\n  processPayment(amount: number): void {\n    console.log(`$${amount}의 PayPal 결제 처리 중`);\n    // 여기에 PayPal 결제 처리 로직을 수행합니다\n  }\n}\n```\n\nc. 전략을 사용하고 활성 전략을 설정하는 메서드를 제공할 context 클래스를 생성하세요:\n\n```js\n// payment-context.ts\nimport { PaymentStrategy } from './payment-strategy.interface';\n\nexport class PaymentContext {\n  private strategy: PaymentStrategy;\n\n  setStrategy(strategy: PaymentStrategy): void {\n    this.strategy = strategy;\n  }\n\n  processPayment(amount: number): void {\n    this.strategy.processPayment(amount);\n  }\n}\n```\n\nd. 이제 Angular 컴포넌트나 서비스에서 전략을 활용할 수 있습니다. 예를 들어:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { PaymentContext } from './payment-context';\nimport { CreditCardStrategy } from './credit-card-strategy';\nimport { PaypalStrategy } from './paypal-strategy';\n\n@Component({\n  selector: 'app-payment-component',\n  template: '...',\n})\nexport class PaymentComponent {\n  constructor(private paymentContext: PaymentContext) {}\n  processCreditCardPayment(amount: number): void {\n    this.paymentContext.setStrategy(new CreditCardStrategy());\n    this.paymentContext.processPayment(amount);\n  }\n  processPaypalPayment(amount: number): void {\n    this.paymentContext.setStrategy(new PaypalStrategy());\n    this.paymentContext.processPayment(amount);\n  }\n}\n```\n\ne. 이 예제에서 `PaymentComponent`는 사용자 조작 또는 조건에 따라 `CreditCardStrategy`와 `PaypalStrategy`와 같은 다른 지불 전략으로 전환하기 위해 `PaymentContext`를 사용합니다. `setStrategy`를 통해 활성 전략을 설정하여 `processPayment`에서 지불 처리 로직의 동적 변경이 가능합니다.\n\n이 구현은 `PaymentStrategy` 인터페이스를 구현하여 새로운 전략을 추가하고, `PaymentComponent` 또는 지불 처리 기능이 필요한 다른 구성 요소 내에서 서로 교환할 수 있도록 함으로써 쉬운 확장성을 제공합니다.\n\n전략 패턴은 클라이언트 코드로부터 다른 알고리즘이나 동작의 구현을 분리하여 기존 코드 수정 없이 전략을 변경하거나 확장할 수 있도록 함으로써 유연성과 유지 보수성을 제공합니다.\n\n\n<div class=\"content-ad\"></div>\n\n5. 데코레이터 패턴: Angular 데코레이터인 @Component와 @Injectable과 같은 데코레이터들은 데코레이터 패턴에 기반을 두고 있습니다. 데코레이터는 기본 코드를 직접 수정하지 않고 클래스나 클래스 멤버의 동작을 향상시키거나 수정하는 방법을 제공합니다.\n\na. 핵심 기능을 나타내는 기본 컴포넌트를 만드세요:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-base-component',\n  template: 'Base Component',\n})\nexport class BaseComponent {}\n```\n\nb. 기본 컴포넌트를 확장하는 데코레이터 컴포넌트를 만드세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, ViewChild } from '@angular/core';\nimport { BaseComponent } from './base-component';\n\n@Component({\n  selector: 'app-decorator',\n  template: `\n    <div>\n      <p>This is the decorator component</p>\n      <ng-content></ng-content>\n    </div>\n  `,\n})\nexport class DecoratorComponent extends BaseComponent {}\n```\n\n이 예시에서 `DecoratorComponent`는 `BaseComponent`의 기능을 확장한 자식 컴포넌트입니다. 자신 안에 `BaseComponent`를 감싸고 `\"ng-content\"`를 사용하여 추가 콘텐츠를 추가합니다. 이렇게 하면 기본 컴포넌트 주위에 추가적인 동작이나 템플릿 콘텐츠를 주입할 수 있습니다.\n\nc. 애플리케이션에서 데코레이터 컴포넌트를 사용하세요:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <app-decorator>\n      <app-base-component></app-base-component>\n    </app-decorator>\n  `,\n})\nexport class AppComponent {}\n```\n\n<div class=\"content-ad\"></div>\n\n`AppComponent` 템플릿에서 `BaseComponent`는 `DecoratorComponent` 내에서 셀렉터 ``app-decorator``를 사용하여 감싸집니다. `DecoratorComponent` 내에 다른 컴포넌트, 템플릿 또는 HTML 콘텐츠를 삽입하여 `BaseComponent`의 동작을 확장하거나 수정할 수 있습니다.\n\nAngular에서 데코레이터 패턴을 사용하면 데코레이터 컴포넌트 내에서 기존 컴포넌트를 감싸면서 기존 컴포넌트의 기능을 동적으로 확장하거나 수정할 수 있습니다. 이 접근 방식은 유연성, 코드 재사용성 및 유지 보수성을 제공하며 필요에 맞게 특정 동작 또는 콘텐츠를 추가하여 기본 컴포넌트를 재사용할 수 있습니다.\n\n6. Facade Pattern: Facade 패턴은 복잡한 서브시스템에 간소화된 인터페이스를 제공하여 사용 및 이해를 쉽게 만드는 구조적 디자인 패턴입니다. Angular에서 Facade 패턴을 적용하여 복수의 컴포넌트, 서비스 또는 모듈과의 상호작용 복잡성을 캡슐화하는 간소화된 API 또는 서비스를 생성할 수 있습니다.\n\n다음은 Angular에서 Facade 패턴을 구현하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\na. 사용자가 쉽게 사용할 수 있도록 간소화하고 싶은 복잡한 하위 시스템 또는 관련 구성 요소/서비스를 식별하세요.\n\nb. 복잡한 하위 시스템과의 상호 작용을 캡슐화하는 Facade 서비스를 생성하세요. Facade 서비스는 클라이언트가 하위 시스템 기능에 간단하게 액세스할 수 있는 단순화된 인터페이스를 제공할 것입니다.\n\n```js\nimport { Injectable } from '@angular/core';\nimport { ComplexServiceA } from './complex-service-a';\nimport { ComplexServiceB } from './complex-service-b';\n\n@Injectable()\nexport class FacadeService {\n  constructor(private serviceA: ComplexServiceA, private serviceB: ComplexServiceB) {}\n  // 적절한 복잡한 하위 시스템 메서드를 내부적으로 호출하는 간소화된 메서드를 제공합니다.\n  performOperation(): void {\n    this.serviceA.complexOperationA();\n    this.serviceB.complexOperationB();\n  }\n}\n```\n\nc. Facade 서비스가 상호 작용하는 복잡한 하위 시스템 구성 요소/서비스를 구현하세요. 이러한 구성 요소/서비스는 실제 복잡한 로직을 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n```ts\n@Injectable()\nexport class ComplexServiceA {\n  complexOperationA(): void {\n    // Service A의 복잡한 로직\n    console.log('복잡한 작업 A 수행 중');\n  }\n}\n\n@Injectable()\nexport class ComplexServiceB {\n  complexOperationB(): void {\n    // Service B의 복잡한 로직\n    console.log('복잡한 작업 B 수행 중');\n  }\n}\n```\n\nd. 복합 서브시스템을 간단하게 사용하기 위해 컴포넌트에서 Facade 서비스를 사용하세요:\n\n```ts\nimport { Component } from '@angular/core';\nimport { FacadeService } from './facade.service';\n\n@Component({\n  selector: 'app-client-component',\n  template: '...',\n})\nexport class ClientComponent {\n  constructor(private facadeService: FacadeService) {}\n  performFacadeOperation(): void {\n    this.facadeService.performOperation();\n  }\n}\n```\n\ne. 이 예제에서 `ClientComponent`는 복잡한 서비스(`ComplexServiceA` 및 `ComplexServiceB`)와 직접 상호 작용하지 않아도 복잡한 작업을 수행하기 위해 `FacadeService`를 사용합니다. `FacadeService`는 복잡성을 캡슐화하고 간단한 인터페이스를 제공하여 클라이언트 컴포넌트가 상호 작용할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\nAngular에서 Facade 패턴을 사용하면 복잡한 하위 시스템의 사용을 간소화하고 구현 세부 정보를 숨기며 클라이언트에게 직관적이고 쉽게 사용할 수 있는 인터페이스를 제공할 수 있습니다. 이를 통해 여러 구성 요소나 서비스와 상호 작용의 복잡성을 단일 Facade 뒤에 숨김으로써 코드 유지보수성, 가독성 및 모듈성을 촉진할 수 있습니다.\n\n7. Composite Pattern: Composite 디자인 패턴은 객체를 트리 구조로 조합하는 데 사용되는 구조적 디자인 패턴입니다. 구성 요소는 다른 구성 요소로 구성될 수 있으며, 트리 구조를 형성합니다. 이 패턴을 사용하면 재사용 가능하고 계층적인 UI 구성 요소를 만들 수 있습니다.\n\nAngular에서 Composite 패턴을 적용하여 구성 요소나 서비스 간에 계층적인 관계를 나타낼 수 있습니다.\n\n다음은 Angular에서 Composite 패턴을 구현하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\na. 개별 객체와 그룹을 위한 공통 동작을 나타내는 추상 클래스 또는 인터페이스를 만들어보세요:\n\n```js\n// component.interface.ts\nexport interface ComponentInterface {\n  operation(): void;\n}\n```\n\nb. 개별 객체를 위해 추상 클래스나 인터페이스를 구현해보세요:\n\n```js\n// leaf.component.ts\nimport { ComponentInterface } from './component.interface';\n\nexport class LeafComponent implements ComponentInterface {\n  operation(): void {\n    console.log('단일 구성요소에 대한 작업을 수행합니다.');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nc. 복합 객체를 구현하는 추상 클래스 또는 인터페이스를 구현하세요. 이 객체는 개별 객체와 다른 복합 객체를 포함할 수 있습니다:\n\n```js\n// composite.component.ts\nimport { ComponentInterface } from './component.interface';\n\nexport class CompositeComponent implements ComponentInterface {\n  private children: Component[] = [];\n  add(component: ComponentInterface): void {\n    this.children.push(component);\n  }\n  remove(component: ComponentInterface): void {\n    const index = this.children.indexOf(component);\n    if (index > -1) {\n      this.children.splice(index, 1);\n    }\n  }\n  operation(): void {\n    console.log('Performing operation on the composite component.');\n    for (const child of this.children) {\n      child.operation();\n    }\n  }\n}\n```\n\nd. 컴포넌트의 트리 모양 구조를 생성하기 위해 복합 객체를 사용하세요:\n\n```js\nimport { ComponentInterface } from './component.interface';\nimport { LeafComponent } from './leaf.component';\nimport { CompositeComponent } from './composite.component';\n\n// 개별 컴포넌트 생성\nconst leaf1: ComponentInterface = new LeafComponent();\nconst leaf2: ComponentInterface = new LeafComponent();\n// 복합 컴포넌트 생성\nconst composite: ComponentInterface = new CompositeComponent();\ncomposite.add(leaf1);\ncomposite.add(leaf2);\n// 또 다른 복합 컴포넌트 생성\nconst composite2: ComponentInterface = new CompositeComponent();\ncomposite2.add(composite);\ncomposite2.add(leaf1);\n// 복합 구조에 작업 수행\ncomposite2.operation();\n```\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 본 예제에서는 Composite 패턴을 사용하여 트리 구조를 만들었습니다. `CompositeComponent`는 개별 `LeafComponent` 객체와 다른 `CompositeComponent` 객체를 모두 포함할 수 있습니다. 최상위 `CompositeComponent`에서 `operation()` 메서드를 호출하면 leaf 컴포넌트나 다른 복합 컴포넌트에 대해 모두 재귀적으로 작업을 호출합니다.\n\nAngular에서 Composite 패턴을 사용하면 컴포넌트 또는 서비스 간의 복잡한 계층 구조 관계를 일관된 방식으로 표현할 수 있습니다. 개별 객체와 객체 그룹을 일관된 방식으로 처리하여 코드를 단순화하고 복합 구조에 대한 재귀적 작업을 가능하게 합니다.\n\n8. Factory Pattern: 팩토리 패턴은 생성 패턴으로, 생성될 객체의 정확한 클래스를 지정하지 않고 객체를 생성하는 인터페이스를 제공합니다. Angular에서 Factory 패턴을 적용하여 객체 생성 로직을 캡슐화하고 다른 클래스의 인스턴스를 생성하는 중앙 집중화된 장소를 제공할 수 있습니다.\n\n다음은 Angular에서 Factory 패턴을 구현하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\na. 생성하려는 객체의 공통 동작을 나타내는 추상 클래스 또는 인터페이스를 정의하십시오:\n\n```js\n// product.interface.ts\nexport interface Product {\n  operation(): void;\n}\n```\n\nb. `Product` 인터페이스를 준수하는 여러 클래스를 구현하십시오:\n\n```js\n// product-a.ts\nexport class ProductA implements Product {\n  operation(): void {\n    console.log('Product A operation.');\n  }\n}\n\n// product-b.ts\nexport class ProductB implements Product {\n  operation(): void {\n    console.log('Product B operation.');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nc. 객체 생성 로직을 캡슐화하는 팩토리 클래스를 생성하세요:\n\n```js\n// product-factory.ts\nimport { Product } from './product.interface';\nimport { ProductA } from './product-a';\nimport { ProductB } from './product-b';\n\nexport class ProductFactory {\n  createProduct(type: string): Product {\n    if (type === 'A') {\n      return new ProductA();\n    } else if (type === 'B') {\n      return new ProductB();\n    }\n    throw new Error('유효하지 않은 제품 타입입니다');\n  }\n}\n```\n\nd. 원하는 제품의 인스턴스를 생성하기 위해 팩토리 클래스를 사용하세요:\n\n```js\nimport { Component } from '@angular/core';\nimport { ProductFactory } from './product-factory';\nimport { Product } from './product.interface';\n\n@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent {\n  constructor(private productFactory: ProductFactory) {}\n  createProduct(type: string): void {\n    const product: Product = this.productFactory.createProduct(type);\n    product.operation();\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 `ExampleComponent`는 제공된 유형에 기반하여 다양한 제품의 인스턴스를 생성하기 위해 `ProductFactory`를 사용합니다. 원하는 유형(‘A’ 또는 ‘B’)으로 `createProduct` 메서드를 호출하면 해당 제품 클래스의 인스턴스를받고 `operation()` 메서드를 호출할 수 있습니다.\n\nAngular에서 Factory 패턴을 사용하면 객체를 생성하기 위한 집중화된 장소를 제공하며 클라이언트 코드를 구체적인 클래스로부터 격리시킵니다. 이는 유연한 객체 생성을 허용하며 새로운 제품 클래스를 추가하고 관련된 팩토리 로직을 업데이트하여 쉽게 확장할 수 있습니다.\n\nAngular에서 일반적으로 사용되는 몇 가지 디자인 패턴을 살펴보았습니다. 하지만 Angular 자체는 컴포넌트가 컨트롤러 역할을 하고 템플릿이 뷰를 나타내며 서비스가 모델로 작동하는 MVC(Model-View-Controller) 아키텍처 패턴을 따른다는 점을 유념해야 합니다.\n\nAOT의 단점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n주요 제한 사항은 AoT가 원시 코드를 컴파일하는 방식 때문에 일반적인 코드 패턴과 함께 사용할 수 없다는 점입니다. 예를 들어, 모듈에서의 기본 내보내기, 템플릿을 위한 템플릿 리터럴, 그리고 프로바이더, 라우트, 또는 선언에서의 함수와 같은 코드 패턴이 포함됩니다.\n\nAoT 작업 및 지양사항\n\n이 섹션에서는 위에 나열된 사례들을 설명하고, 각각이 어떻게 실패하고 동작하는지를 보여줄 것입니다.\n\n- `화살표 함수 내보내기`\n\n<div class=\"content-ad\"></div>\n\n화살표 함수는 NgModule에 전달될 때 AoT와 함께 작동하지 않습니다.\n\n```js\n피하세요:\n\nexport const couterReducer = (state, action: Action) => {\n  // ...\n}\n\n대신에:\n\nexport function counterReducer(state, action: Action) {\n  // ...\n}\n```\n\n- `컨트롤\n\n이것은 가장 간단한 작동 케이스로 사용됩니다. default-exports 기본 익스포트는 AoT에서 지원되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n디폴트 익스포트는 AoT에서 지원되지 않습니다.\n\n```js\n다음과 같이 하지 마십시오:\nexport default class AppComponent {};\n\n다음과 같이 하십시오:\nexport class AppComponent {};\n\n-> 폼 컨트롤\n\n폼 컨트롤을 검색하려면 this.helloForm.controls[\"greetingMessage\"]을(를) 사용하십시오.\n```\n\n-` form-control-error\n\n<div class=\"content-ad\"></div>\n\n문법 오류?은 AoT에서 지원되지 않습니다.\n\n```js\n하지 말 것:\n{helloForm.controls[\"greetingMessage\"].errors?.minlength}\n\n해보세요:\n{helloForm.controls[\"greetingMessage\"].hasError(\"minlength\")}\n```\n\n- `func-in-routes`\n\n루트에서 함수를 직접 사용하는 것은 AoT에서 지원되지 않습니다. 사용을 피하거나 다른 모듈에서 내보내기하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n하지 말아주세요:\n\nfunction random() {\n  return [{\n    path: \"\",\n    component: AppViewComponent\n  }];\n}\nconst SAMPLE_APP_ROUTES: Routes = random();\n\n올바른 방법은:\n\nconst SAMPLE_APP_ROUTES: Routes = [{\n  path: \"\",\n  component: AppViewComponent\n}];\n```\n\n자세한 내용은 여기를 클릭하세요.\n\n21. package.json 파일에서 물결(~)과 케어트(^) 기호의 사용용도는 무엇인가요?\n\n캐럿(^) 기호\n\n\n<div class=\"content-ad\"></div>\n\n```js\n\"dependencies\": {\n  \"express\": \"^3.9.2\"\n}\n```\n\nCarets (`^`) allow you to:\n\n- Include backward compatible new functionalities\n- Perform large internal refactorings\n- Apply bug fixes\n- Deprecate old functionalities while they are still operational\n- With the caret, you can get releases like 3.x.x, where the wildcard characters (*) will match the highest version number available. Changes in the major digit, like 4.0.0, will not be used in this case.\n\nThe tilde sign (~) indicates that only the last digit specified should change.\n\n<div class=\"content-ad\"></div>\n\n```js\n\"dependencies\": {\n  \"express\": \"~3.9.2\"\n}\n```\n\n틸드(~)는\n\n- 버그 수정\n- 틸드를 사용하면 3.9.*와 같은 릴리스를 얻을 수 있습니다. 틸드를 사용하면 최신 버그 수정만 허용됩니다.\n\n그래서 우리는 요령(`~`) 문자를 사용해야 하는 결론에 이를 수 있습니다. 패치 번호를 고정하고 싶을 때는 이 문자를 사용해야 합니다. 이것은 버그 수정만 수용하려고 하고 잠재적으로 호환되지 않는 변경 사항에 부딪히고 싶지 않을 때 사용해야 합니다. 반면에 업스트로크(^) 문자는 패치 및 마이너 버전 번호를 고정하는 역할을 합니다. 역호환성을 가진 새 기능과 버그 수정을 원할 때 사용해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n22. Angular에서 인터셉터란 무엇인가요?\n\nAngular에서 인터셉터는 HTTP 요청 및 응답을 가로채고 조작하는 데 사용할 수 있는 클래스입니다. 이들은 서버로 전송되기 전에 HTTP 요청을 수정하거나 HTTP 응답을 호출 코드로 전달되기 전에 수정할 수 있는 방법을 제공합니다. 인터셉터는 인증 헤더 추가, 로깅, 오류 처리, 캐싱 등과 같은 작업에 유용합니다.\n\nAngular에서 인터셉터를 생성하려면 HttpInterceptor 인터페이스를 구현하고 요청 및 응답을 가로채는 논리를 정의해야 합니다.\n\n다음은 나가는 요청에 인가 헤더를 추가하는 HTTP 인터셉터의 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n- 인터셉터 클래스를 생성하세요:\n\n```js\n// auth-interceptor.ts\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  intercept(\n    request: HttpRequest,\n    next: HttpHandler\n  ): Observable> {\n    // 요청에 인증 헤더 추가\n    const authToken = '여기에 귀하의 인증 토큰을 입력하세요';\n    const authRequest = request.clone({\n      setHeaders: { Authorization: `Bearer ${authToken}` },\n    });\n\n    // 수정된 요청을 다음 인터셉터 또는 HTTP 핸들러로 전달합니다.\n    return next.handle(authRequest);\n  }\n}\n```\n\n2. 인터셉터 등록해주세요:\n\n인터셉터를 사용하려면 AppModule이나 HTTP 요청을 하는 모듈에서 인터셉터를 제공해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```javascript\n// app.module.ts\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { AuthInterceptor } from './auth-interceptor';\n\n@NgModule({\n  imports: [BrowserModule, HttpClientModule],\n  providers: [\n    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n  ],\n})\nexport class AppModule {}\n```\n\n이 예제에서는 AuthInterceptor를 HTTP_INTERCEPTORS multi-provider 토큰의 프로바이더로 등록합니다. `multi: true` 옵션은 이 인터셉터가 여러 개 중 하나일 수 있음을 나타냅니다. 여러 인터셉터를 제공할 수 있기 때문입니다.\n\n이제 애플리케이션에서 HTTP 요청이 발생할 때마다 AuthInterceptor가 요청을 가로채고 인증 헤더를 추가한 후 다음 인터셉터나 실제 HTTP 핸들러로 전달합니다. 이를 통해 일반적인 HTTP 요청 관련 작업을 중앙 집중화하고 코드를 깔끔하고 유지 관리 가능하게 유지할 수 있습니다.\n\nAngular 프로젝트에서 dist 폴더의 이름을 변경할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\nangular.json 파일에서 outputPath 속성의 값을 변경하십시오.\n\n```js\n{\n  \"projects\": {\n    \"my-app-name\": {\n    \"architect\": {\n      \"options\": {\n         \"outputPath\": \"변경하고 싶은 값\",\n``` \n\n브라우저가 당신의 앱이 Angular 기반 앱임을 어떻게 알게 되나요?\n\n브라우저 콘솔에서 getAllAngularRootElements()를 실행하면 결과가 나옵니다. 현재는 [app-root]을 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n25. Angular에서 사용자 정의 데코레이터를 만드는 방법은 무엇인가요?\n\n데코레이터는 클래스의 수정 또는 장식을 원본 소스 코드를 수정하지 않고 분리하는 데 사용되는 디자인 패턴입니다. Angular에서 데코레이터는 서비스, 디렉티브 또는 필터를 사용하기 전에 수정할 수 있게 하는 함수입니다.\n\n데코레이터 만들기\n\n```js\nfunction log(target, name, descriptor) {\n  const original = descriptor.value;\n  descriptor.value = function(...args) {\n    console.log('이 함수가 해킹되었습니다');\n    const result = original.apply(this, args);\n    console.log(\"함수의 결과는 \", result);\n    return result;\n  };\n  original();\n  return descriptor;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n데코레이터 사용법\n\n```js\n@log\nsum(a,b) {\n  return a+b;\n}\n// 데코레이터로 오버라이드된 함수 호출\nsum(2,3)\n\n// 결과\n이 함수가 해킹당했습니다\n 함수의 결과는 5입니다\n```\n\n26. Angular에서 병렬로 여러 개의 HTTP 호출을 하는 방법은?\n\n이는 forkJoin을 사용하여 달성할 수 있습니다. 이 오퍼레이터는 옵저버블 배열을 가져와 모든 소스 옵저버블의 완료를 기다립니다. 모든 옵저버블이 완료되면 각 옵저버블에서 마지막으로 발행된 값의 배열을 발행합니다. 예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { forkJoin, of, throwError } from 'rxjs';\n\nconst observables = [\n    of(1,2,3).pipe(delay(500)),\n    from([10,11,12])\n]\n\nconst $forkJoin = forkJoin(observables);\n\n$forkJoin.subscribe(data=>{\n    console.log('forkjoin data', data); // [3,12] as forkJoin will return last emitted values of each observable\n})\n```\n\n이 예제에서 `forkJoin`은 지연 후 각각 'A'와 'B'를 발행하는 두 옵저버블 및 지연 후 오류를 throw하는 옵저버블을 포함한 옵저버블 배열을 가져옵니다. `forkJoin`은 모든 옵저버블이 완료될 때까지 기다린 다음 각 옵저버블의 마지막으로 발행된 값을 배열로 반환합니다. 그러나 `forkJoin`에 있는 옵저버블 중 하나라도 오류를 throw하면 해당 오류는 `subscribe` 메서드의 오류 콜백으로 전달됩니다.\n\n27. TypeScript에서 모듈이란 무엇이며 어떻게 사용할 수 있나요?\n\nTypeScript에서 모듈은 응용 프로그램의 서로 다른 부분 간에 가져오고 내보낼 수 있는 재사용 가능한 독립 단위 코드로 코드를 구성하는 방법입니다. 모듈에는 클래스, 함수, 인터페이스 및 기타 코드가 포함될 수 있으며 프로젝트 내부 또는 외부 라이브러리일 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\nTypeScript에서 모듈을 사용하려면 `export` 키워드를 사용하여 모듈을 정의해야 합니다. 이는 해당 모듈의 멤버를 애플리케이션의 다른 부분에서 사용할 수 있도록 만듭니다. 그런 다음 `import` 키워드를 사용하여 해당 모듈을 가져와 코드에서 해당 멤버를 사용할 수 있습니다.\n\n다음은 TypeScript에서 모듈을 정의하고 사용하는 예시입니다:\n\n```js\n// myModule.ts\nexport function myFunction() {\n  // 코드 작성\n}\n\nexport class MyClass {\n  // 코드 작성\n}\n```\n\n이 예시에서는 `myModule`이라는 모듈을 정의하고, `myFunction` 함수와 `MyClass` 클래스를 내보냅니다. `export` 키워드를 사용하여 이러한 멤버들을 모듈 외부에서 사용할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n`myModule` 모듈의 멤버를 다른 파일에서 사용하려면 `import` 키워드를 사용하여 가져올 수 있어요:\n\n```js\n// main.ts\nimport { myFunction, MyClass } from \"./myModule\";\n\nmyFunction();\nconst myInstance = new MyClass();\n```\n\n이 예시에서는 `myModule` 모듈로부터 `myFunction` 함수와 `MyClass` 클래스를 비구조화하여 가져오고 있어요. 그리고 가져온 이름을 사용하여 `myFunction` 함수를 호출하고 `MyClass` 클래스의 인스턴스를 만들 수 있어요.\n\nTypeScript에서 모듈을 가져오고 내보내는 다양한 방법이 있어요. `* as` 구문을 사용하여 모든 멤버를 가져오거나, 기본 내보내기를 가져오거나, 가져온 멤버에 대한 별칭을 사용하는 등 다양한 방법이 있어요. 프로젝트의 규모와 복잡성에 따라 다른 구문과 그 영향을 이해하는 것이 중요해요.\n\n<div class=\"content-ad\"></div>\n\n모듈을 사용하면 TypeScript에서 코드를 더 모듈식으로 작성하고 유지 관리하기 쉽게 할 수 있습니다. 기능을 격리시키고 이름 충돌을 줄이기 때문입니다. 하지만, 적절하게 사용하고 너무 많은 작은 모듈을 만들지 않는 것이 중요합니다. 그렇게 하면 코드베이스의 복잡성이 증가할 수 있습니다.\n\n28. 애플리케이션 컴포넌트를 로드하기 전에 API를 호출하는 방법은?\n\n@angular/router 패키지에는 라우트를 위한 Resolve 속성이 있습니다. 이를 사용하여 라우트 뷰를 렌더링하기 전에 데이터를 쉽게 해결할 수 있습니다. 아래 예제는 요청된 라우트를 활성화하기 위해 필요한 데이터를 검색하는 resolve() 메서드를 구현한 것입니다.\n\n```js\n@Injectable({ providedIn: 'root' })\nexport class HeroResolver implements Resolve {\n  constructor(private service: HeroService) {}\n\n  resolve(\n      route: ActivatedRouteSnapshot,\n      state: RouterStateSnapshot\n    ): Observable|Promise|any {\n      return this.service.getHero(route.paramMap.get('id'));\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n아래에 제공된 resolve() 함수는 라우터 구성의 Route 객체의 일부로 제공됩니다:\n\n```js\n@NgModule({\n  imports: [\n    RouterModule.forRoot([\n      {\n        path: 'detail/:id',\n        component: HeroDetailComponent,\n        resolve: {\n          hero: HeroResolver\n        }\n      }\n    ])\n  ],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}\n```\n\n만일 NPM을 통해 사용할 수 없는 패키지(또는 라이브러리)가 있다면, Angular 애플리케이션에서 어떻게 사용할지 궁금하실 것입니다.\n\nNPM 패키지가 없는 경우, 해당 파일을 다운로드하고 프로젝트 어딘가에 넣어야 합니다 — vendor나 lib이라는 디렉토리에 넣는 것을 추천합니다. import 문은 사용하려는 모듈에 대한 상대 경로를 사용할 수 있으므로 간단할 것입니다. 예를 들어, 서드 파티 모듈을 vendor/some-lib.js에 넣었다면 다음과 같이 import 할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변환한 코드입니다.\n\n```js\n// src/foo.js\nimport './../vendor/some-lib';\nIf you want to get fancy, you can use resolve.alias in your webpack config so that you never have to work out the relative path.\n\n// webpack.config.js\nconst path = require('path');\n// ...\nresolve: {\n  alias: {\n    vendor: path.resolve(__dirname, 'vendor')\n  }\n},\n// src/foo.js\nimport 'vendor/some-lib';\n```\n\n30. Angular에서 Tree shaking을 구현하는 방법은?\n\nTree shaking은 마지막 제품 번들로부터 사용되지 않는 모듈을 식별하고 제거하는 데드 코드 제거 프로세스입니다. 이 기법은 개발자들이 종종 다양한 라이브러리와 종속성을 포함하는 대규모 응용 프로그램에서 특히 중요합니다. 사용되지 않는 코드를 제거함으로써 Tree shaking은 번들 크기를 최적화하고 더 효율적인 응용 프로그램을 만들 수 있도록 돕습니다.\n\n<div class=\"content-ad\"></div>\n\nAngular은 인기있는 프론트엔드 프레임워크로, 응용 프로그램의 성능을 향상시키기 위해 트리 쉐이킹을 활용합니다. 이는 Webpack과 같은 기본 빌드 도구를 활용하여 코드를 분석하고 사용되지 않는 부분을 제거합니다.\n\nAngular에서의 트리 쉐이킹 예시:\n\n@Injectable 데코레이터의 'providedIn' 속성을 사용하여 서비스를 주입하면, 해당 서비스는 모듈에서 명시적으로 요청될 때에만 주입됩니다. 모듈이 서비스를 요청하지 않는 경우, 트리 쉐이커는 해당 서비스를 제외시킵니다. 'providedIn'의 사용을 통해 Angular에 서비스 등록이 되어야 하는 모듈을 지정할 수 있습니다.\n\n```js\n// logger.service.ts\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class LoggerService {\n  log(message: string): void {\n    console.log(message);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n빌드 프로세스 중에 Angular의 빌드 도구와 Webpack은 트리 쉐이킹을 수행하여 사용되지 않는 코드를 제거합니다. 트리 쉐이킹은 최종 번들이 실제로 사용되는 코드만 포함되도록 보장하여 더 작은 번들 크기를 얻게 됩니다. 이는 코드베이스가 커질수록 Angular 애플리케이션의 성능을 최적화하는 데 중요합니다.\n\nAngular에서의 트리 쉐이킹 구성:\n\nAngular 자체가 트리 쉐이킹을 지원하지만, 이 최적화를 활성화하려면 프로젝트를 올바르게 구성해야 합니다. 다음은 몇 가지 주요 단계입니다:\n\n- 프로덕션 모드 사용: Angular 애플리케이션을 프로덕션 모드로 빌드하는 것을 확인하세요. 다음 명령어를 실행하여 이를 달성할 수 있습니다:\n- Webpack 구성: Angular 프로젝트는 종종 Webpack을 내부 빌드 도구로 사용합니다. Webpack 구성이 트리 쉐이킹을 활성화하도록 설정되어 있는지 확인하세요. 기본 Angular CLI 구성에는 이미 트리 쉐이킹을 위한 필요한 설정이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n결론:\n\n요약하면, Angular에서의 트리 쉐이킹은 사용되지 않는 코드를 제거하여 애플리케이션 번들의 크기를 줄이는 가치 있는 최적화 기술입니다. 예제에서 보듯이, Angular의 빌드 도구와 웹팩은 프로덕션 빌드 과정 중에 분석하고 사용되지 않는 코드를 제거하는 방식으로 함께 작동합니다. Angular 프로젝트에 트리 쉐이킹을 통합함으로써, 애플리케이션의 성능과 로딩 시간을 현격히 향상시킬 수 있어 사용자에게 더 부드러운 경험을 제공할 수 있습니다.\n\n31. @injectable 데코레이터의 'providedIn' 속성의 값으로 올 수 있는 것은 무엇인가요?\n\n@injectable 데코레이터에는 다음과 같은 값이 올 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- ‘providedIn’: root — 이것은 서비스가 애플리케이션의 루트 주입기에서 제공되며 애플리케이션의 모든 모듈 및 컴포넌트에서 액세스할 수 있다는 것을 의미합니다. 애플리케이션이 지연 로드된 모듈을 갖고 있더라도, 동일한 서비스 인스턴스가 그들과 공유됩니다.\n- ‘providedIn’: moduleClassName — 이것은 서비스가 'providedIn' 키에 지정된 이름을 가진 특정 모듈의 주입기에 제공된다는 것을 의미합니다. 따라서 해당 모듈 수준에서 액세스할 수 있습니다.\n- ‘provideIn’: any — 이것은 서비스가 애플리케이션의 루트 주입기에 존재할 것이며, 애플리케이션에 지연 로드되는 모듈이 있는 경우에는 그들 자체 서비스 인스턴스를 얻게 됩니다.\n- ‘providedIn’: platform — 이것은 하나의 페이지에 여러 Angular 요소( Angular 웹 컴포넌트)가 있는 경우에 사용할 수 있으며, 서비스의 같은 인스턴스가 모든 Angular 요소 전체에 공유되기를 원할 때 사용됩니다.\n\n32. OnPush 변경 감지 전략을 사용하여 Angular 애플리케이션을 최적화하는 방법\n\nAngular에서 'OnPush' 변경 감지 전략은 변경 감지 주기의 수를 줄이어 성능을 최적화하는 데 사용됩니다. 이는 불변성 개념에 기반하며 입력 속성 및 명시적 변경 감지 트리거에 의존합니다.\n\n## `OnPush` 전략을 사용하여 Angular 애플리케이션을 최적화하는 방법은 다음 단계를 따르십시오:\n\n<div class=\"content-ad\"></div>\n\n가정해보겠습니다. `ParentComponent`라는 부모 구성 요소와 `ChildComponent`라는 자식 구성 요소가 있다고 가정해봅시다. 자식 구성 요소는 항목 배열을 입력 속성으로 받아와 목록으로 표시합니다. 이 시나리오를 `OnPush` 전략을 사용하여 최적화하겠습니다.\n\n- 컴포넌트에서 `OnPush` 변경 감지 전략 사용:\n\n```js\n// parent.component.ts\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <app-child [items]=\"items\"></app-child>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ParentComponent {\n  items: string[] = ['Item 1', 'Item 2', 'Item 3'];\n  addItem() {\n    this.items.push('New Item'); // 배열을 업데이트하는 잘못된 방법\n  }\n}\n```\n\n```js\n// child.component.ts\nimport { Component, Input, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    <ul>\n      <li *ngfor=\"let item of items\">{ item }</li>\n    </ul>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ChildComponent {\n  @Input() items: string[];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위 코드에서 `ParentComponent`와 `ChildComponent` 모두 `OnPush` 변경 감지 전략을 사용하고 있습니다.\n\n2. 입력 속성에 불변 데이터를 사용하세요:\n\n```js\n// parent.component.ts\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <app-child [items]=\"items\"></app-child>\n    <button (click)=\"addItem()\">Add Item</button>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ParentComponent {\n  items: string[] = ['Item 1', 'Item 2', 'Item 3'];\n  addItem() {\n    this.items = [...this.items, 'New Item']; // 스프레드 연산자를 사용하여 배열을 업데이트하는 올바른 방법\n  }\n}\n```\n\n`ParentComponent`에서 `items` 배열에 새로운 항목을 추가할 때, spread 연산자 `[…this.items]`를 사용하여 새 배열을 생성한 후 새 항목을 추가합니다. 이렇게 하면 새로운 참조가 만들어지며, 입력 속성이 변경될 때 `ChildComponent`에서 변경 감지가 트리거됩니다.\n\n<div class=\"content-ad\"></div>\n\n결론:\n\n이러한 최적화 기술을 적용함으로써 변경 감지 전략인 `OnPush`를 사용하여 Angular 애플리케이션의 성능을 향상시킬 수 있습니다. 불변 데이터는 불필요한 변경 감지 주기를 최소화하여 효율성과 응답성을 향상시킵니다.\n\n33. 최신 Angular 버전은 무엇이며 어떤 새로운 기능이 추가되었습니까?\n\n글쓴 시점인 2024년 2월 기준으로, 최신 Angular 버전은 Angular 17입니다. 해당 기능에 대한 자세한 내용은 다음 링크에서 확인하실 수 있습니다:https://blog.angular.io/introducing-angular-v17-4d7033312e4b\n\n<div class=\"content-ad\"></div>\n\n34. Angular에서 사용 가능한 양식 유형은 무엇인가요? 구문을 사용하여 설명해주세요.\n\nAngular에서는 사용자 입력을 처리하고 유효성을 검사하기 위해 다양한 유형의 양식을 사용할 수 있습니다. Angular에서 주로 사용되는 두 가지 주요 양식 유형은 템플릿 기반 양식과 반응형 양식입니다.\n\n- 템플릿 기반 양식:\n\n— 템플릿 기반 양식은 주로 Angular 지시문을 사용하여 구성 요소의 HTML 템플릿 내에서 정의됩니다.\n\n<div class=\"content-ad\"></div>\n\n- 템플릿에서 양식 컨트롤 및 유효성 검사 규칙이 추론되어 구성 요소 코드에서 명시적인 양식 컨트롤 선언이 필요성이 줄어듭니다.\n\n- 템플릿 주도 방식 양식은 기본적인 유효성 검사 요구 사항이 있는 간단한 양식에 적합합니다.\n\n구문:\n\n```js\n<form #myform=\"ngForm\" (ngsubmit)=\"onSubmit()\">\n     <label for=\"name\">이름:</label>\n     <input type=\"text\" id=\"name\" name=\"name\" ngmodel=\"\" required=\"\">\n     \n     <label for=\"email\">이메일:</label>\n     <input type=\"email\" id=\"email\" name=\"email\" ngmodel=\"\" required=\"\" email=\"\">\n     \n     <button type=\"submit\">제출</button>\n   </form>\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예에서 `ngForm`은 전체 양식을 나타내는 지시자입니다. 각 입력 요소는 양방향 데이터 바인딩을 위해 `ngModel` 지시자를 사용하며 `required` 및 `email`과 같은 유효성 검사를 위한 추가 지시자도 포함됩니다.\n\n2. 반응형 양식:\n\n- 반응형 양식은 TypeScript를 사용하여 구성 요소 클래스에서 프로그래밍적으로 생성됩니다.\n- 양식 컨트롤은 구성 요소 코드에서 명시적으로 정의되어 더 많은 제어와 유연성을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n- 리액티브 폼은 동적 검증 요구사항과 고급 상호 작용을 가진 복잡한 폼에 적합합니다.\n\n구문:\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { FormGroup, FormControl, Validators } from '@angular/forms';\n\n@Component({\n     selector: 'app-my-form',\n     template: `\n       <form [formGroup]=\"myForm\" (ngSubmit)=\"onSubmit()\">\n         <label for=\"name\">이름:</label>\n         <input type=\"text\" id=\"name\" formControlName=\"name\">\n         \n         <label for=\"email\">이메일:</label>\n         <input type=\"email\" id=\"email\" formControlName=\"email\">\n         \n         <button type=\"submit\">전송</button>\n       </form>\n     `,\n   })\n   export class MyFormComponent implements OnInit {\n     myForm: FormGroup;\n     ngOnInit() {\n       this.myForm = new FormGroup({\n         name: new FormControl('', Validators.required),\n         email: new FormControl('', [Validators.required, Validators.email]),\n       });\n     }\n     onSubmit() {\n       if (this.myForm.valid) {\n         // 폼 제출 처리\n       }\n     }\n   }\n```\n\n위 예제에서 `FormGroup`는 전체 폼을 나타내며, `FormControl`은 개별 폼 컨트롤을 나타냅니다. 각 폼 컨트롤에는 유효성 검증 규칙을 정의하기 위해 Validators가 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\n결론:\n\nAngular에서 사용할 수 있는 주요 형식 유형은 템플릿 중심형(form-driven forms)과 반응형(forms) 형식입니다. 폼의 복잡성과 요구 사항에 따라 Angular 응용 프로그램에 적합한 폼 유형을 선택할 수 있습니다.\n\n35. Angular에서 동적 폼(dynamic forms)이란 무엇이며 어떻게 만드는가?\n\nAngular에서의 동적 폼은 폼의 구조와 컨트롤이 런타임에서 동적으로 생성되는 것을 허용합니다. 폼의 구조와 컨트롤은 데이터나 사용자 상호 작용에 따라 동적으로 결정됩니다. 이는 필드 수가 다양한 폼을 처리하거나 폼 구조를 동적으로 생성해야 하는 경우에 특히 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n## Angular에서 동적 폼을 만들려면 이 단계를 따르면 됩니다:\n\n- 데이터 모델 정의: 우선, 폼 필드와 속성을 표현하는 데이터 모델을 정의하세요. TypeScript의 클래스나 인터페이스를 사용하여 이 작업을 수행할 수 있습니다.\n- 폼 그룹 생성: 컴포넌트 클래스에서 동적 폼 컨트롤을 보유할 `FormGroup` 인스턴스를 생성하세요. `FormBuilder` 서비스를 사용하여 폼 그룹을 간단히 생성할 수 있습니다.\n- 동적으로 폼 컨트롤 추가: 요구 사항이나 데이터에 따라 폼 그룹에 동적으로 폼 컨트롤을 추가하세요. 폼 그룹에서 `addControl()` 또는 `setControl()`과 같은 메서드를 사용하여 이 작업을 수행할 수 있습니다.\n- 템플릿에서 폼 컨트롤 생성: 컴포넌트의 템플릿에서 폼 그룹의 폼 컨트롤을 반복하고 `ngFor`와 같은 디렉티브를 사용하여 해당 입력 필드나 컨트롤을 동적으로 생성하세요.\n- 폼 제출 처리: 컴포넌트에서 폼 제출을 처리하는 로직을 구현하세요. 폼 값에 액세스하고 필요한 작업을 수행하기 위해 `FormGroup` 인스턴스를 활용하세요.\n\nAngular에서 동적 폼을 생성하는 기본 예제를 살펴봅시다:\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-dynamic-form',\n  templateUrl: './dynamic-form.component.html',\n})\nexport class DynamicFormComponent implements OnInit {\n  dynamicForm: FormGroup;\n  constructor(private formBuilder: FormBuilder) {}\n  ngOnInit() {\n    // 빈 폼 그룹 생성\n    this.dynamicForm = this.formBuilder.group({});\n    \n    // 동적 폼 컨트롤 추가\n    this.addFormControl('name', Validators.required);\n    this.addFormControl('email', [Validators.required, Validators.email]);\n  }\n  addFormControl(fieldName: string, validators: any[] = []) {\n    this.dynamicForm.addControl(fieldName, this.formBuilder.control('', validators));\n  }\n  onSubmit() {\n    if (this.dynamicForm.valid) {\n      const formValues = this.dynamicForm.value;\n      // 폼 제출 처리\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예시에서 `dynamicForm`은 `FormBuilder`를 사용하여 생성된 `FormGroup`입니다. `addFormControl()` 메서드는 필드 이름과 유효성 검사 규칙을 기반으로 `dynamicForm`에 동적으로 폼 컨트롤을 추가하는 데 사용됩니다. 폼 컨트롤은 템플릿에서 생성되며 `ngFor`를 사용하여 폼 그룹의 컨트롤을 반복합니다.\n\n이러한 단계를 따라서 Angular에서 변경 요구 사항이나 데이터에 동적으로 대응하는 동적 폼을 만들 수 있습니다.\n\n36. 폼 컨트롤에서 오류 메시지를 표시하는 방법은?\n\nAngular 폼에서 유효성 검증 또는 오류 메시지를 표시하는 방법에 대한 정보는 다음 링크를 참조해주세요 — Angular Forms에서 유효성 검증 또는 오류 메시지 표시 방법\n\n<div class=\"content-ad\"></div>\n\n37. 특정 컴포넌트에서 모듈 전체가 아닌 서비스를 사용하는 방법은 무엇인가요?\n\n이 작업은 모듈의 데코레이터의 providers 배열 대신 컴포넌트의 데코레이터 내에 서비스 이름을 넣어서 수행할 수 있습니다. 또한 서비스의 데코레이터에서 'provided in: root' 속성을 제공하지 않아야 합니다.\n\n38. ngIf와 ngFor를 같은 요소에 넣을 수 있나요?\n\nAngular 버전 2 이상에서는 1개의 요소에 1개 이상의 구조 지시문을 넣을 수 없습니다. ngIf와 ngFor를 모두 사용해야 한다면 둘 중 하나를 ng-container 내에 넣을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n39. 옵저버블과 서브젝트의 차이점은 무엇인가요?\n\n다음은 옵저버블과 서브젝트의 차이점입니다:\n\n- 옵저버블과 서브젝트를 생성하는 구문이 다릅니다\n\n옵저버블:\n\n<div class=\"content-ad\"></div>\n\n\n1. Subjects let you send data to multiple subscribers, while Observables send data to each subscriber individually. Therefore, when you add a new subscriber to a Subject, they will all receive the same data, but with Observables, each subscriber may get different data as the Observable source is re-executed for each new subscriber.\n2. Observables are cold by default because the data source is contained within the Observable itself, as shown in the code above. On the other hand, Subjects are not cold.\nFor more detailed differences, refer to the following YouTube links:\n\n\n<div class=\"content-ad\"></div>\n\n- Subject와 Behavior Subject의 차이점 – RxJS.\n- RxJS Subject와 RxJS Observable의 차이점은 무엇인가요?\n\n40. ng serve는 어떻게 작동하나요?\n\n기본적으로 ng serve 명령은 애플리케이션을 빌드하고 제공합니다. 변경 사항이 발생하면 애플리케이션을 다시 빌드합니다. 더 자세한 설명은 이 YouTube 동영상을 참고해주세요: Angular이 내부적으로 어떻게 작동하는지\n\n41. Angular 앱 성능을 향상시키는 방법은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n이것은 Angular 앱 성능을 크게 향상시킬 수 있는 몇 가지 필수 해킹들입니다:\n\n- AoT 컴파일 사용하기.\n- OnPush 변경 감지 전략 사용하기.\n- 순수 파이프 사용하기.\n- Observables 구독 해제하기.\n- 지연 로딩.\n- For 루프에 trackBy 옵션 사용하기.\n- 웹 워커 사용하기.\n\n42. Angular에서 AuthGuard란 무엇인가요?\n\nAngular에서 Auth Guard는 라우트를 보호하고 사용자가 인증 상태나 사용자 역할에 따라 특정 경로에 액세스할 수 있는지 여부를 결정하는 데 사용됩니다. Auth Guard는 서비스로 구현되며 일반적으로 Angular의 라우팅 시스템과 함께 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n앵귤러에서 Auth 가드(Auth Guards)가 작동하는 방법을 설명하는 예시입니다:\n\n- Auth 가드(Auth Guard) 서비스를 생성하세요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivate, Router } from '@angular/router';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  constructor(private router: Router) {}\n  canActivate(): boolean {\n    // 사용자의 인증 상태 또는 역할을 확인합니다.\n    const isAuthenticated = /* 여기에 인증 확인 */;\n    const userRole = /* 사용자 역할 가져오기 */;\n    if (isAuthenticated && userRole === 'admin') {\n      return true;  // 경로에 대한 액세스 허용\n    } else {\n      this.router.navigate(['/login']);  // 로그인 페이지나 권한이 없는 페이지로 리디렉션합니다.\n      return false; // 경로에 대한 액세스 거부\n    }\n  }\n}\n```\n\n2. 앱 모듈에서 라우트를 정의하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { HomeComponent } from './home.component';\nimport { AdminComponent } from './admin.component';\nimport { LoginComponent } from './login.component';\nimport { AuthGuard } from './auth.guard';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'admin', component: AdminComponent, canActivate: [AuthGuard] },\n  { path: 'login', component: LoginComponent }\n];\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n이 예시에서, 세 가지 라우트를 가지고 있습니다: 홈 라우트, 어드민 라우트, 로그인 라우트입니다. 어드민 라우트는 `AuthGuard`로 보호되어 `[AuthGuard]`를 `canActivate` 속성에 설정하여 보호되어 있습니다.\n\n3. 보호된 컴포넌트를 구현하세요:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-admin',\n  template: 'Admin Page'\n})\nexport class AdminComponent { }\n```\n\n<div class=\"content-ad\"></div>\n\n4. 템플릿 또는 컴포넌트에서 Auth Guard 사용하기:\n\n```js\n<!-- 템플릿에서 Auth Guard 사용하는 예시 -->\n<button [routerlink]=\"['/admin']\" *ngif=\"isAuthenticated\">Admin 페이지로 가기</button>\n\n<!-- 컴포넌트에서 Auth Guard 사용하는 예시 -->\nimport { Component } from '@angular/core';\nimport { Router } from '@angular/router';\n@Component({\n  selector: 'app-some-component',\n  template: `\n    <button (click)=\"goToAdmin()\" *ngif=\"isAuthenticated\">Admin 페이지로 가기</button>\n  `\n})\nexport class SomeComponent {\n  isAuthenticated: boolean;\n  constructor(private router: Router) {}\n  goToAdmin() {\n    if (this.isAuthenticated) {\n      this.router.navigate(['/admin']);\n    }\n  }\n}\n```\n\n위의 두 예시에서는 사용자의 인증 상태에 따라 조건부로 관리자 경로를 표시하거나 탐색합니다. 사용자가 인증되어 있고 적절한 역할('admin'인 경우)인 경우에만 경로에 액세스가 허용됩니다. 그렇지 않은 경우 로그인 페이지로 리디렉션되거나 권한이 없는 페이지로 이동합니다.\n\n결론:\n\n<div class=\"content-ad\"></div>\n\nAuth Guards는 Angular 애플리케이션의 인증 및 권한 부여 규칙에 따라 경로를 보호하고 다른 부분의 액세스를 제어하는 데 중요한 역할을 합니다. Auth Guards를 구현하고 활용함으로써 특정 경로가 보호되어 권한이 있는 사용자만 액세스할 수 있도록 보장할 수 있습니다.\n\n43. canActivateChild 라우트 가드를 설명해주세요.\n\nAngular에서 canActivateChild 라우트 가드는 사용자가 자식 라우트를 활성화할 수 있는지 확인할 수 있습니다. 특정 조건이 충족되지 않았을 때 특정 경로의 자식 라우트를 보호하는 데 사용됩니다.\n\n사용자가 자식 라우트로 이동할 때 Angular는 부모 라우트의 라우트 구성에서 관련 canActivateChild 가드가 있는지 확인합니다. 가드가 존재한다면, Angular는 자식 라우트를 활성화하기 전에 가드를 실행합니다.\n\n<div class=\"content-ad\"></div>\n\ncanActivateChild 가드는 CanActivateChild 인터페이스를 구현하는 서비스로 구현됩니다. 이 인터페이스는 canActivateChild()라는 하나의 메서드를 가지고 있으며, boolean 값을 반환하거나 boolean으로 해결되는 프로미스를 반환합니다. 해당 메서드가 true를 반환하면 자식 라우트가 활성화됩니다. false나 false로 해결되는 프로미스를 반환하면 자식 라우트가 활성화되지 않고 사용자는 다른 라우트로 리디렉션되거나 사용자 정의 오류 페이지가 표시됩니다.\n\n다음은 canActivateChild 라우트 가드를 사용하는 방법의 예시입니다:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivateChild, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivateChild {\n  canActivateChild(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean | Promise<boolean> | boolean {\n    // 사용자가 인증되었는지 확인\n    if (this.authService.isAuthenticated()) {\n      return true;\n    } else {\n      // 사용자가 인증되지 않았다면 로그인 페이지로 리디렉션\n      this.router.navigate(['/login']);\n      return false;\n    }\n  }\n}\n```\n\n이 예시에서는 CanActivateChild 인터페이스를 구현하는 AuthGuard 서비스를 가지고 있습니다. canActivateChild() 메서드는 AuthService에서 제공하는 isAuthenticated() 메서드를 사용하여 사용자가 인증되었는지 확인합니다. 사용자가 인증되었다면 메서드는 true를 반환하여 자식 라우트가 활성화됩니다. 사용자가 인증되지 않았다면 메서드는 로그인 페이지로 이동하고 false를 반환하여 자식 라우트의 활성화를 방지합니다.\n\n<div class=\"content-ad\"></div>\n\nAuthGuard 서비스를 사용하려면 그것을 자식 경로를 지키는 부모 경로의 경로 구성에 있는 canActivateChild 속성에 추가할 수 있습니다:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { AuthGuard } from './auth.guard';\nimport { ParentComponent } from './parent.component';\nimport { ChildComponent } from './child.component';\n\nconst routes: Routes = [\n  {\n    path: 'parent',\n    component: ParentComponent,\n    canActivateChild: [AuthGuard],\n    children: [\n      {\n        path: 'child',\n        component: ChildComponent\n      }\n    ]\n  }\n];\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n이 예제에서 canActivateChild 속성은 AuthGuard 서비스를 포함하는 배열로 설정됩니다. AuthGuard로 자식 경로를 지킵니다.\n\n아직 헷갈리나요? 그렇다면 설명을 확인하기 위해 canActivateChild 링크를 참조해보세요 - tektutorialshub\n\n<div class=\"content-ad\"></div>\n\nCanLoad 가드는 Lazy Loaded 모듈의 로딩을 확인합니다. 이 가드는 모듈의 어떤 경로로도 접근하지 못하도록 하고 모듈의 소스 코드를 보는 것조차 막고 싶을 때 사용합니다.\n\nCanActivate 가드는 인가되지 않은 사용자가 경로에 접근하는 것을 막습니다. 그러나 모듈의 다운로드를 중지하지는 않습니다. 사용자는 크롬 개발자 콘솔을 사용하여 소스 코드를 볼 수 있습니다.\n\n스위치 맵, 머지 맵, forkJoin, combineLatest, concatMap, exhaustMap을 설명해주세요. 스위치 맵, 머지 맵 또는 forkJoin 중 하나의 요청이 실패하면 어떻게 될까요?\n\n<div class=\"content-ad\"></div>\n\n## 각 연산자를 하나씩 살펴보고 예제와 함께 설명해보겠습니다. 또한 `switchMap`, `mergeMap`, 또는 `forkJoin`을 사용할 때 요청이 실패하는 경우에 대해서도 논의할 겁니다.\n\n- switchMap: 이 연산자는 각 소스 값을 내부 observable로 매핑하고, 최신 내부 observable에서만 값을 방출합니다. 이전의 내부 observable이 완료되기 전에 새로운 소스 값이 도착하면, 새 내부 observable로 전환하고 이전 것은 구독을 취소합니다.\n\n예시:\n\n```js\nimport { of, interval } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nconst $switchMap = from([1,2,3,4]).pipe(switchMap(data=>{\n  return of(data).pipe(delay(500))\n}));\n\n$switchMap.subscribe(data=>{\n  console.log('switch map data', data); // 새 observable이 발생할 때, switchMap은 모든 이전 observable을 취소하므로 4가 출력됩니다.\n})\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 `sourceObservable`은 매 초마다 값을 발생시킵니다. 발생된 각 값마다, `switchMap`은 `from` 연산자를 사용하여 내부 observable을 생성하고 소스 observable에서 값이 1초 후에 발생하도록 합니다. 이전 내부 observable이 완료되기 전에 새 값이 발생하면, 새 내부 observable로 전환되어 이전 것이 취소됩니다. 따라서, 가장 최근의 내부 observable 값만이 발생됩니다.\n\n2. mergeMap: 이 연산자는 각 소스 값을 내부 observable로 매핑하고 여러 내부 observable에서 값을 하나의 observable로 병합합니다. 그러므로, 어떤 내부 observable에서도 취소하거나 구독 취소되지 않습니다.\n\n예시:\n\n```js\nimport { of } from 'rxjs';\nimport { mergeMap, delay } from 'rxjs/operators';\n\n// 세 개의 값이 발생하는 observable 생성\nconst sourceObservable = of(1, 2, 3);\n// mergeMap을 사용하여 내부 observables에서 값들을 병합\nconst resultObservable = sourceObservable.pipe(\n  mergeMap((value) => {\n    // 값이 1초 후에 발생하는 내부 observable 생성\n    return of(value).pipe(delay(1000));\n  })\n);\n// 결과 observable을 구독\nresultObservable.subscribe((value) => {\n  console.log(value); // 1 2 3 \n});\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 `sourceObservable`은 1, 2, 3 세 개의 값을 방출합니다. 각 값이 방출될 때마다, `mergeMap`은 `of` 연산자를 사용하여 내부 observable을 생성하고 1초의 지연 후 값을 방출합니다. `mergeMap`은 내부 observables를 취소하거나 전환하지 않기 때문에, 각 내부 observable에서 모든 값이 하나의 observable로 병합되어 완료된 순서대로 방출됩니다.\n\n3. forkJoin: 이 연산자는 observable 배열을 가져와 모든 소스 observables가 완료될 때까지 기다립니다. 모두 완료되면 각 observable에서 마지막으로 방출된 값의 배열을 방출합니다.\n\n예시:\n\n```js\nimport { forkJoin, of, throwError } from 'rxjs';\n\nconst observables = [\n     of(1,2,3).pipe(delay(500)),\n    from([10,11,12])\n  ]\n  const $forkJoin = forkJoin(observables);\n  $forkJoin.subscribe(data=>{\n    console.log('forkjoin data', data); // [3,12] as forkJoin will return last emitted values of each observable\n  })\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 `forkJoin`은 지연 후 각각 'A' 및 'B'를 내보내는 두 옵저버블과 일정 시간 후 에러를 발생시키는 옵저버블을 포함하는 옵저버블 배열을 가져옵니다. `forkJoin`은 모든 옵저버블이 완료될 때까지 기다린 후, 완료되면 각 옵저버블에서 마지막으로 내보낸 값을 포함하는 배열을 내보냅니다. 그러나 `forkJoin`의 옵저버블 중 하나라도 에러를 발생시키면, 그 에러는 `subscribe` 메소드의 에러 콜백으로 전달됩니다.\n\n4. combineLatest: 이 연산자는 여러 옵저버블에서 최신 값을 결합하여 단일 옵저버블로 만듭니다. 소스 옵저버블 중 어떤 것이라도 새 값이 나올 때마다 최신 값을 포함하는 배열을 내보냅니다.\n\n예시:\n\n```js\nimport { combineLatest, interval } from 'rxjs';\n\nconst observables = [\n    of(1,2,3,4),\n    from([10,11,12])\n]\n\nconst $combineLatest = combineLatest(observables);\n$combineLatest.subscribe(data => {\n    console.log('combineLatest data', data);\n})\n/*  출력 */\n// [4, 10]\n// [4, 11]\n// [4, 12]\n```\n\n<div class=\"content-ad\"></div>\n\n만약 관찰 가능한 것이 아래와 같다면:\n\n```js\nconst observables = [\n    of(1,2,3,4).pipe(delay(500)), \n    from([10,11,12])\n ]\n\n다음은 출력됩니다\n// [12,1]\n// [12,2]\n// [12,3]\n// [12,4]\n```\n\n프로젝트 함수에서 console.log() 출력은 첫 번째로 완료된 observable에서 마지막으로 발행된 값이 모든 계산에 사용된다는 것을 보여줍니다. 이 값은 두 번째 observable 값들과 각각 결합됩니다. 따라서: 하나의 observable이 다른 observable들보다 값들을 먼저 발행하는 경우, 그 값들은 손실됩니다.\n\n5. concatMap:이 연산자는 각 소스 값을 내부 observable에 매핑하고 각 내부 observable의 값을 순차적으로 연결합니다. 각 내부 observable이 완료될 때까지 기다렸다가 다음으로 넘어갑니다. 순서가 중요한 경우 mergeMap 대신 concatMap을 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n```js\nimport { of } from 'rxjs';\nimport { concatMap, delay } from 'rxjs/operators';\n\n// 세 개의 값을 방출하는 observable 생성\nconst sourceObservable = of(1, 2, 3);\n// 내부 observable로부터 값을 연결하기 위해 concatMap 사용\nconst resultObservable = sourceObservable.pipe(\n  concatMap((value) => {\n    // 지연 후 값을 방출하는 내부 observable 생성\n    return of(value).pipe(delay(1000));\n  })\n);\n// 결과 observable에 구독\nresultObservable.subscribe((value) => {\n  console.log(value); // 1  2  3\n});\n```\n\n이 예시에서는, `sourceObservable`이 1, 2, 3 세 개의 값을 방출합니다. 각 값이 방출될 때마다, `concatMap`은 `of` 연산자를 사용하여 내부 observable을 생성하고 1초의 지연 후 해당 값을 방출합니다. 내부 observable이 완료되기 전에는 다음으로 넘어가지 않으므로, 각 내부 observable에서의 값은 매핑된 순서대로 순차적으로 방출됩니다.\n\n6. exhaustMap: exhaustMap 연산자는 각 소스 값을 observable에 매핑한 다음 해당 observable에 구독하는 방식으로 작동합니다. 한 번에 하나의 내부 observable이 활성화되도록 보장합니다. 활성화된 내부 observable이 있는 상태에서 새로운 소스 값이 도착하면, 내부 observable이 완료될 때까지 새 값은 무시됩니다.\n\n<div class=\"content-ad\"></div>\n\n여기 Angular에서 exhaustMap을 사용하는 예제가 있어요:\n\n```js\nconst $exhaustMap = from([1,2,3,4]).pipe(\n    exhaustMap(data=>{\n      return of(data).pipe(delay(500)); \n    })\n )\n\n$exhaustMap.subscribe(data=> {\n    console.log('exhaustMap data', data); //1\n })\n```\n\n만약 `switchMap`, `mergeMap`, 또는 `forkJoin`에서 어떤 요청이 실패한다면 다음과 같은 일이 발생합니다:\n\n— switchMap: `switchMap`에 의해 생성된 내부 observable 중 하나가 오류를 throw하면, 해당 오류는 `subscribe` 메서드의 에러 콜백으로 전파됩니다. 또한, 이전 내부 observable에 대한 구독이 취소되고, `switchMap`은 새로운 내부 observable로 전환됩니다.\n\n<div class=\"content-ad\"></div>\n\n— mergeMap: `mergeMap`으로 생성된 내부 Observable 중 하나라도 오류가 발생하면 해당 오류는 `subscribe` 메서드의 오류 콜백으로 전파됩니다. 그러나 한 내부 Observable의 오류가 다른 내부 Observables에 영향을 미치지 않습니다. `mergeMap`은 계속해서 다른 내부 Observables에서 값을 병합할 것입니다.\n\n— forkJoin: `forkJoin`에 전달된 Observable 중 하나라도 오류가 발생하면 해당 오류는 `subscribe` 메서드의 오류 콜백으로 전파됩니다. 이 경우 `forkJoin`은 결과 값을 전달하지 않을 것입니다. `forkJoin`에서 각 Observable의 개별 오류를 처리해야 하는 경우, `forkJoin`에 전달하기 전 각 Observable 내에서 `catchError` 연산자를 사용할 수 있습니다.\n\n특정 사용 사례 및 코드 내에서 오류 처리 전략과 동작이 달라질 수 있다는 점을 유의해야 합니다.\n\n46. 의존성 주입이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n소프트웨어 엔지니어링에서 — 의존성 주입은 클래스 A의 인스턴스(객체)를 생성하고 이 인스턴스를 클래스 B에 제공하여 클래스 A의 기능을 클래스 B에서 사용할 수 있도록 하는 프로세스입니다.\n\nAngular의 맥락에서 — 의존성 주입은 서비스의 인스턴스(객체)를 생성하고 이 인스턴스를 구성 요소에 제공하여 서비스의 기능을 구성 요소에서 사용할 수 있도록 하는 프로세스입니다. 의존성 주입을 구현하는 한 가지 방법은 구성 요소의 생성자 메서드를 통해 이루어집니다.\n\n디바운싱과 setTimeout의 차이점은 무엇인가요?\n\n디바운싱은 JavaScript에서 사용되는 기술로, 짧은 시간 내에 반복해서 트리거되는 함수 호출의 빈도를 제한하는 것입니다. 종종 스크롤, 크기 조정 또는 검색 입력 변경으로 인한 API 호출과 같은 이벤트에서 함수 호출이 자주 발생할 수 있지만, 해당 이벤트가 멈췄을 때 일정한 지연 이후에 함수가 한 번만 실행되도록 보장하고 싶을 때 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\nJavaScript에서 'Debounce'를 구현하는 방법:\n\nHTML 코드:\n\n```js\n<input type=\"text\" onkeyup=\"search()\">\n```\n\nJavaScript 코드:\n\n<div class=\"content-ad\"></div>\n\n```js\nlet timerId;\nlet delay=1000;\n\nfunction debounce(callback, delay) {\n  if(timerId) {\n    clearTimeout(timerId);\n  }\n  timerId = setTimeout(()=>{\n     callback();\n  },delay)\n}\nfunction api() {\n   console.log('api call code here');\n}\nfunction search() {\n  debounce(api, delay);\n}\n```\n\nsetTimeout은 지정된 지연 시간 후에 함수를 실행하는 내장 JavaScript 함수입니다. 일정 기간 이후에 수행해야 하는 작업에 일반적으로 사용됩니다. 이 작업에는 애니메이션, 타임아웃 또는 지연된 작업 등이 포함될 수 있습니다.\n\nsetTimeout의 예시:\n\n버튼 클릭 후 2초 후에 알림을 표시하고 싶은 간단한 시나리오를 고려해 봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\nconst showNotification = () => {\n  console.log('Notification: Button clicked!');\n};\n\nconst button = document.getElementById('my-button');\nbutton.addEventListener('click', () => {\n  setTimeout(showNotification, 2000);\n});\n```\n\n이 예제에서는 버튼이 클릭되면 showNotification 함수가 2000밀리초 (2초) 지연 후 실행됩니다.\n\n48. RxJS의 주요 기능은 무엇인가요 ?\n\nRxJS에는 JavaScript에서 비동기 데이터 스트림을 처리하는 강력한 도구로 만드는 몇 가지 주요 기능이 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- Observables: RxJS는 비동기 데이터 스트림을 나타내는 Observables 개념을 중심으로 구축되었습니다. Observables는 연산자(operator)를 사용하여 선언적 방식으로 변형, 결합 및 소비할 수 있습니다.\n- Operators: RxJS에는 Observables를 변형하고 조작하는 데 사용할 수 있는 다양한 연산자가 제공됩니다. 이러한 연산자에는 `map`, `filter`, `reduce`, `scan`, `merge`, `concat`, `switchMap` 등이 포함됩니다.\n- 오류 처리: RxJS는 `catchError` 및 `retry`와 같은 연산자를 제공하여 Observables에서 발생하는 오류를 처리합니다.\n- 스케줄러: RxJS는 Observables의 타이밍과 실행 컨텍스트를 제어하기 위한 스케줄러를 제공합니다. 스케줄러를 사용하여 Observables의 동시성을 제어하거나, 발행을 지연하거나 스로틀링하거나, 다른 스레드나 프로세스에서 Observables를 실행할 수 있습니다.\n- 백프레셔 핸들링: RxJS는 데이터를 생성하는 Observables가 소비될 수 있는 속도보다 빠르게 생성되는 경우를 다루기 위한 백프레셔 핸들링 메커니즘을 제공합니다. 이러한 메커니즘에는 `buffer`, `throttle`, `debounce` 등이 포함됩니다.\n- 상호 운용성: RxJS는 Angular, React, Node.js 등 다른 라이브러리 및 프레임워크와 함께 사용할 수 있습니다. 또한 ReactiveX 및 RxJava와 같은 다른 반응형 프로그래밍 라이브러리 및 플랫폼과 통합을 지원합니다.\n- 테스트 가능성: RxJS는 단위 테스트에서 Observables를 만들고 조작하는 데 사용되는 테스트 유틸리티를 제공합니다. 이를 통해 비동기 코드를 테스트하고 Observables이 예상한 값을 방출하는지 확인하는 작업이 쉬워집니다.\n\n49. RxJS Observables에서 오류를 처리하는 방법은 무엇인가요?\n\nRxJS는 Observables에서 발생하는 오류를 처리하기 위한 여러 연산자를 제공합니다. 오류 처리를 위한 두 가지 주요 연산자는 `catchError`와 `retry`입니다.\n\n- catchError: `catchError` 연산자는 Observable에서 발생할 수 있는 오류를 처리하고 고급 방법으로 처리하는 데 사용됩니다. 함수를 인수로 받아오며 해당 함수는 다른 Observable을 반환하거나 오류를 throw할 수 있습니다. 함수가 Observable을 반환할 경우 소스 Observable은 반환된 Observable로 대체됩니다. 함수가 오류를 throw할 경우 오류는 구독자에게 전파됩니다.\n\n<div class=\"content-ad\"></div>\n\n여기 예제가 있습니다:\n\n```js\nimport { of } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nof(1, 2, 3).pipe(\n  map(num => {\n    if (num === 2) {\n      throw new Error('Oops!');\n    }\n    return num;\n  }),\n  catchError(err => {\n    console.error(err.message);\n    return of(4, 5, 6);\n  })\n).subscribe(\n  num => console.log(num),\n  err => console.error(err),\n  () => console.log('Complete')\n);\n```\n\n이 예제에서 `map` 연산자는 숫자 2를 만나면 오류를 throw합니다. `catchError` 연산자는 오류를 catch하고 오류 메시지를 콘솔에 기록합니다. 그런 다음 소스 Observable을 새로운 Observable로 대체하여 숫자 4, 5 및 6을 방출합니다. 2. retry: `retry` 연산자는 오류가 발생했을 때 Observable을 자동으로 재시도하는 데 사용됩니다. 최대 재시도 횟수를 지정하는 선택적 인수를 취합니다.\n\n여기 예제가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\nimport { map, retry } from 'rxjs/operators';\n\nof(1, 2, 3).pipe(\n  map(num => {\n    if (num === 2) {\n      throw new Error('Oops!');\n    }\n    return num;\n  }),\n  retry(2)\n).subscribe(\n  num => console.log(num),\n  err => console.error(err),\n  () => console.log('Complete')\n);\n```\n\n이 예제에서 `map` 오퍼레이터는 숫자 2를 만나면 오류를 발생시킵니다. `retry` 오퍼레이터는 오류를 구독자에 전파하기 전에 최대 2번까지 Observable을 다시 시도합니다.\n\n50. RxJS에서 백프레셔를 어떻게 구현하나요?\n\n백프레셔는 반응형 프로그래밍에서 사용되는 메커니즘으로, Observable이 데이터를 소비될 속도보다 빠르게 방출할 때의 상황을 처리하는 데 사용됩니다. 이로 인해 메모리 사용량이 높아지거나 처리 속도가 느려지는 문제 등이 발생할 수 있습니다. RxJS에는 `buffer`, `throttle`, `debounce`, `sample`, `switchMap`를 포함한 여러 오퍼레이터가 있는데, 이를 사용하여 백프레셔를 구현할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n- 버퍼: `버퍼` 연산자는 소스 Observable에서 발행된 값을 배열로 수집하고 지정된 크기에 도달하면 배열을 발행합니다. 처리할 수 있을 때까지 발행된 값을 임시로 저장하는 데 사용할 수 있습니다.\n\n다음은 예제입니다:\n\n```js\nimport { interval } from 'rxjs';\nimport { bufferTime } from 'rxjs/operators';\n\ninterval(100).pipe(\n  bufferTime(1000)\n).subscribe(\n  values => console.log(values),\n  err => console.error(err),\n  () => console.log('Complete')\n);\n```\n\n이 예제에서 `interval` Observable은 매 100밀리초마다 값을 발행합니다. `bufferTime` 연산자는 발행된 값을 배열로 수집하고 1000밀리초마다 배열을 발행합니다.\n\n<div class=\"content-ad\"></div>\n\n2. throttle: `throttle` 연산자는 지정된 시간 창 내에 발생한 이벤트를 제거하여 원본 Observable의 이벤트를 쓰로틀링합니다. 이를 사용하여 원본 Observable에서의 이벤트 발생 속도를 제한할 수 있습니다.\n\n다음은 예시입니다:\n\n```js\nimport { interval } from 'rxjs';\nimport { throttleTime } from 'rxjs/operators';\n\ninterval(100).pipe(\n  throttleTime(1000)\n).subscribe(\n  num => console.log(num),\n  err => console.error(err),\n  () => console.log('Complete')\n);\n```\n\n위 예시에서 `interval` Observable은 100밀리초마다 값을 방출합니다. `throttleTime` 연산자는 이전 이벤트 발생 후 1000밀리초 내에 발생한 이벤트를 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n3. 디바운스: `debounce` 연산자는 소스 Observable에서 발행되는 값을 마지막 발행 이후 지정된 시간이 경과할 때까지 지연시킵니다. 이를 사용하여 빠른 발행을 필터링하고 마지막 값만을 발행할 수 있습니다.\n\n다음은 예제입니다:\n\n```js\nimport { fromEvent } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\nfromEvent(document, 'keyup').pipe(\n  debounceTime(1000)\n).subscribe(\n  event => console.log(event.target.value),\n  err => console.error(err),\n  () => console.log('Complete')\n);\n```\n\n이 예제에서 `fromEvent` Observable은 문서에서 키를 뗄 때마다 값을 발행합니다. `debounceTime` 연산자는 1000밀리초의 경과 후에만 값을 발행하도록 지연시킵니다.\n\n<div class=\"content-ad\"></div>\n\n4. 샘플: `sample` 연산자는 지정된 시간 간격에 source Observable에서 가장 최근의 값이 방출됩니다. 몇 개의 값이 방출되었는지에 관계없이 정기적인 간격으로 가장 최근의 값을 방출하는 데 사용할 수 있습니다.\n\n여기 예시가 있습니다:\n\n```js\nimport { interval } from 'rxjs';\nimport { sampleTime } from 'rxjs/operators';\n\ninterval(100).pipe(\n  sampleTime(1000)\n).subscribe(\n  num => console.log(num),\n  err => console.error(err),\n  () => console.log('완료')\n);\n```\n\n5. switchMap: `switchMap` 연산자는 소스 Observable에서 동시 방출 수를 제한하는 데 사용할 수 있습니다. `switchMap`을 사용하여 백프레셔를 구현하는 예시가 여기 있습니다:\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 `source$` Observable은 매 100밀리초마다 값을 방출합니다. `processValue` 함수는 1초 후에 resolve되는 Promise를 반환하여 처리 시간을 시뮬레이트합니다. `switchMap` 연산자는 최대 2개의 동시 방출을 허용하도록 설정되어 있어, 한 번에 2개의 값만 처리됩니다. `limitedSource$` Observable은 구독되어 처리된 값들을 방출합니다.\n\n이렇게 `switchMap`을 사용하면 일정한 수의 값만 동시에 처리하여, 시스템이 한 번에 처리해야 할 값들로 넘쳐나는 것을 방지할 수 있습니다.\n\nRxJS에서 연산자의 목적은 값을 방출하고 조작하거나 조합하는 것입니다. 대표적인 연산자 예시로는 `map`, `filter`, `mergeMap`, `switchMap`, `concatMap` 등이 있습니다.\n\n<div class=\"content-ad\"></div>\n\nRxJS의 오퍼레이터는 옵저버블이 방출하는 데이터를 변환, 필터링 또는 결합하는 데 사용할 수 있는 함수입니다. 오퍼레이터는 RxJS의 주요 기능 중 하나이며, 개발자가 복잡한 데이터 처리 파이프라인을 쉽게 작성할 수 있도록 도와줍니다.\n\nRxJS에서 가장 흔한 오퍼레이터 중 하나는 `map` 오퍼레이터입니다. `map` 오퍼레이터는 옵저버블에서 방출된 값을 각각의 값에 함수를 적용하여 변환하는 데 사용됩니다.\n\n다음은 예시입니다:\n\n```js\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source$ = of(1, 2, 3);\nconst doubled$ = source$.pipe(\n  map(value => value * 2)\n);\n\ndoubled$.subscribe(\n  value => console.log(value), // 결과: 2, 4, 6\n  err => console.error(err),\n  () => console.log('완료')\n);\n```\n\n<div class=\"content-ad\"></div>\n\n이 예에서는 `of` 함수가 사용되어 1, 2 및 3 값을 방출하는 observable을 생성합니다. 그런 다음 `map` 연산자가 사용되어 observable에 의해 방출된 각 값이 두 배가 됩니다. `doubled$` observable이 구독되어 변환된 값이 발생하고 이 값들이 콘솔에 기록됩니다.\n\n`map` 연산자는 RxJS에서 사용할 수 있는 다양한 연산자 중 하나에 불과합니다. 다른 일반적인 연산자에는 `filter`, `reduce`, `scan`, `merge`, `concat`, `switchMap` 등이 있습니다. 이러한 연산자는 다양한 방식으로 결합되어 실제 시나리오를 처리할 수 있는 복잡한 데이터 처리 파이프라인을 만들 수 있습니다.\n\nRxJS에서 스케줄러를 사용하는 목적에 대해 설명하고 일반적인 스케줄러의 예를 들어주세요.\n\nRxJS에서 스케줄러는 발생한 이벤트의 타이밍을 제어하는 방법을 제공하는 객체입니다. 스케줄러는 특정 시간에 작업을 예약하거나 작업의 실행을 지연하거나 작업을 실행해야 하는 스레드를 지정할 수 있습니다. 스케줄러를 사용하는 목적은 개발자가 observable의 타이밍과 실행에 대해 더 세밀한 제어를 제공하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\nRxJS에서 일반적으로 사용되는 스케줄러 중 하나는 `observeOn()` 연산자입니다. `observeOn()` 연산자는 observable이 값을 방출하는 스케줄러를 지정하는 데 사용됩니다. 예를 들어보겠습니다:\n\n```js\nimport { from } from 'rxjs';\nimport { observeOn } from 'rxjs/operators';\nimport { asyncScheduler } from 'rxjs';\n```\n\n```js\nconst source$ = from([1, 2, 3]);\nconst async$ = source$.pipe(\n  observeOn(asyncScheduler) // async 스케줄러에서 값 방출\n);\nasync$.subscribe(\n  value => console.log(value), // 출력: 1, 2, 3\n  err => console.error(err),\n  () => console.log('완료')\n);\n```\n\n이 예제에서 `from()` 함수를 사용하여 값을 1, 2, 3을 방출하는 observable을 생성합니다. 그런 다음 `observeOn()` 연산자를 사용하여 observable이 값을 async 스케줄러에서 방출하도록 지정하며, 이렇게 하면 값이 비동기적으로 방출됩니다. `asyncScheduler`는 `setTimeout()`을 사용하여 비동기적으로 실행할 작업을 스케줄링하는 RxJS의 일반적인 스케줄러입니다.\n\n<div class=\"content-ad\"></div>\n\n스케줄러는 작업 실행을 지연시키거나 작업 실행 순서를 제어하거나 작업을 실행할 스레드를 지정하는 데 사용될 수 있습니다. RxJS에서 일반적으로 사용되는 몇 가지 스케줄러에는 `async`, `queue`, `animationFrame`, `immediate` 등이 있습니다.\n\n파이프 가능 연산자와 패치 연산자의 차이점은 무엇인가요?\n\nRxJS에서 버전 5.5부터 파이프 가능 연산자는 연산자를 사용하는 권장 방법입니다. 파이프 가능 연산자는 독립적인 함수로 가져와서 `pipe()` 함수로 연결하여 함께 사용하는 방식입니다. 파이프 가능 연산자는 순수 함수로, 옵저버블을 입력으로 사용하고 새로운 옵저버블을 출력으로 반환하여 여러 연산자를 함께 조합하여 파이프라인을 형성할 수 있도록 합니다.\n\n## 파이프 가능 연산자를 사용하여 옵저버블을 변환하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\nconst source$ = of(1, 2, 3, 4, 5);\nconst filtered$ = source$.pipe(\n  filter(value => value % 2 === 0),\n  map(value => value * 2)\n);\nfiltered$.subscribe(\n  value => console.log(value), // Output: 4, 8\n  err => console.error(err),\n  () => console.log('Complete')\n);\n```\n\n이 예시에서 `filter()`와 `map()` operator는 독립적인 함수로 import 되어 있고, 이후 `pipe()` 함수와 함께 사용하여 새로운 observable을 생성합니다. `filter()` operator는 짝수 값만 통과시키도록 사용되었고, `map()` operator는 나머지 값들을 두 배로 만듭니다.\n\n반면, 패치 오퍼레이터는 RxJS 5.5 이전에 오퍼레이터를 사용하는 원래 방식이었습니다. 패치 오퍼레이터들은 `Observable` 클래스의 메소드로 import되어 그 후 직접 observable에 바로 호출함으로써 사용됩니다. 패치 오퍼레이터는 호출된 observable 인스턴스의 동작을 수정하며, pipeable 오퍼레이터와 같은 방식으로 함께 조합될 수 없습니다.\n\n# 다음은 observable을 변환하는 패치 오퍼레이터 사용 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nimport { of } from 'rxjs';\n\nconst source$ = of(1, 2, 3, 4, 5);\nconst filtered$ = source$\n  .filter(value => value % 2 === 0)\n  .map(value => value * 2);\n\nfiltered$.subscribe(\n  value => console.log(value), // Output: 4, 8\n  err => console.error(err),\n  () => console.log('Complete')\n);\n```\n\n이 예제에서는 `filter()`와 `map()` 연산자가 직접 `source$` observable 인스턴스에 호출되어 해당 인스턴스의 동작을 수정하여 짝수 값만 통과하고 나머지 값을 두 배로 만듭니다. RxJS에서는 여전히 패치 연산자를 사용할 수 있지만, 조합성과 모듈성이 향상된 파이프 연산자가 권장됩니다.\n\n54. Angular에서 서비스란 무엇인가요?\n\nAngular에서 서비스는 서로 다른 구성 요소 간이나 응용 프로그램 전반에 걸쳐 데이터, 로직 및 기능을 공유할 수 있도록 하는 아키텍처의 중요한 부분입니다. 서비스는 서버로부터 데이터 검색, 데이터 조작, 인증, 로깅 등과 같은 재사용 가능한 기능을 캡슐화하고 제공하는 데 사용됩니다. Angular에서 서비스의 주요 측면 및 특성은 다음과 같습니다: \n\n\n<div class=\"content-ad\"></div>\n\n- 싱글톤 패턴: Angular 서비스는 일반적으로 싱글톤으로 구현됩니다. 이는 애플리케이션 전반에 하나의 서비스 인스턴스만 존재하며 여러 컴포넌트에서 공유할 수 있다는 것을 의미합니다. 서비스를 여러 컴포넌트에 주입하면 모든 컴포넌트가 동일한 인스턴스를 받아 데이터 일관성과 효율적인 메모리 사용을 보장합니다.\n- Injectable 데코레이터: 클래스를 Angular 서비스로 작동하도록 만들려면 `@Injectable` 데코레이터로 장식해야 합니다. 이 데코레이터는 의존성 주입을 활성화하고 서비스를 다른 Angular 컴포넌트에 제공하고 주입할 수 있도록 합니다.\n- 의존성 주입 (DI): Angular의 의존성 주입 시스템은 필요한 서비스 인스턴스를 제공하기 위해 사용됩니다. 컴포넌트는 생성자 매개변수에서 서비스에 대한 의존성을 선언할 수 있으며 Angular의 DI 시스템은 자동으로 해당 서비스 인스턴스를 해결하고 주입합니다.\n- 비즈니스 로직과 데이터 조작: 서비스는 일반적으로 비즈니스 로직을 구현하고 데이터 조작을 수행하는 데 책임이 있습니다. 예를 들어 서비스에서 HTTP 요청을 처리하여 서버에서 데이터를 검색하거나 데이터 변환을 수행하거나 데이터베이스와 상호작용할 수 있습니다.\n- 데이터 공유 및 통신: 서비스는 컴포넌트 간에 데이터를 공유하기 위한 중개자 역할을 합니다. 서비스는 공유 데이터를 저장하고 관리하여 컴포넌트가 이를 엑세스하고 수정할 수 있게 합니다. 서비스는 부모-자식 관계가 아닌 컴포넌트 간의 통신과 조정을 용이하게 합니다.\n- 관심사 분리: 서비스는 비즈니스 로직과 데이터 관련 작업을 프레젠테이션 계층 (컴포넌트 및 템플릿)에서 분리하는 데 도움이 됩니다. 이는 코드 재사용성, 유지보수성 및 테스트 가능성을 증진시키며, 로직이 UI와 독립적으로 분리되어 테스트하기 쉬워집니다.\n- 라이프사이클 및 상태 관리: 서비스는 고유한 라이프사이클을 갖고 상태를 관리할 수 있습니다. 애플리케이션 시작 시 초기화되거나 필요할 때 지연로드될 수 있습니다. 또한 서비스는 애플리케이션 전역 상태를 관리할 수 있어 컴포넌트가 공유 데이터를 상호작용하고 업데이트할 수 있게 합니다.\n- 테스트: 서비스는 UI 컴포넌트와 별도로 단위 테스트가 쉽습니다. 서비스를 격리하고 독립적으로 테스트함으로써 비즈니스 로직, 데이터 조작 및 외부 시스템 또는 API와의 상호작용의 정확성을 확인할 수 있습니다.\n\nAngular 서비스를 설명하기 위한 예제를 살펴봅시다.\n\n사용자가 도서를 볼 수 있고 개인 서재에 책을 추가할 수 있는 도서 관리 애플리케이션을 개발 중이라고 가정해봅시다. 책 관련 데이터를 검색하고 관리할 `BookService`라는 서비스를 구현하려고 합니다.\n\n먼저, Angular CLI 명령어를 사용하여 새로운 Angular 서비스를 만들 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nng generate service book\n```\n\n이 명령어를 입력하면 초기 서비스 구조가 담긴 `book.service.ts` 파일이 생성됩니다.\n\n`book.service.ts` 파일에서 `BookService` 클래스를 정의하고 다양한 메서드와 속성을 구현할 수 있습니다. 다음은 예시 구현입니다:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { Book } from './book.model';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class BookService {\n  private apiUrl = 'https://api.example.com/books';\n\n  constructor(private http: HttpClient) {}\n\n  getAllBooks(): Observable {\n    return this.http.get(this.apiUrl);\n  }\n\n  addBook(book: Book): Observable {\n    return this.http.post(this.apiUrl, book);\n  }\n\n  deleteBook(bookId: number): Observable {\n    const url = `${this.apiUrl}/${bookId}`;\n    return this.http.delete(url);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 `BookService`는 `@Injectable` 데코레이터로 꾸며져 있습니다. 이는 이 서비스가 다른 Angular 컴포넌트에 주입될 수 있다는 것을 나타냅니다. `providedIn: ‘root’` 옵션은 서비스가 애플리케이션 전반에 걸쳐 싱글톤으로 사용 가능하도록 합니다. `BookService`에는 세 가지 메소드가 있습니다:\n\n- `getAllBooks()`: 이 메소드는 API 엔드포인트(`this.apiUrl`)로 HTTP GET 요청을 보내 책 목록을 `Book` 객체의 배열로 가져옵니다.\n- `addBook(book: Book)`: 이 메소드는 새 책을 데이터베이스에 추가하기 위해 API 엔드포인트로 HTTP POST 요청을 보냅니다. `Book` 객체를 매개변수로 받고 추가된 책을 반환합니다.\n- `deleteBook(bookId: number)`: 이 메소드는 API 엔드포인트로 HTTP DELETE 요청을 보내 지정된 ID(`bookId`)의 책을 삭제합니다.\n\n`BookListComponent`나 `BookAddComponent`와 같은 애플리케이션의 다른 컴포넌트들은 이후에 `BookService`를 주입하고 책 관련 데이터와 상호 작용하기 위해 메소드를 사용할 수 있습니다.\n\n예를 들어, `BookListComponent`에서는 `BookService`를 주입하고 `getAllBooks()` 메소드를 사용하여 책 목록을 가져올 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { Book } from './book.model';\nimport { BookService } from './book.service';\n\n@Component({\n  selector: 'app-book-list',\n  templateUrl: './book-list.component.html',\n  styleUrls: ['./book-list.component.css']\n})\nexport class BookListComponent implements OnInit {\n  books: Book[];\n\n  constructor(private bookService: BookService) {}\n\n  ngOnInit() {\n    this.bookService.getAllBooks().subscribe(books => {\n      this.books = books;\n    });\n  }\n}\n```\n\n이 예제에서 `BookListComponent`는 생성자를 통해 `BookService`를 주입받고 `getAllBooks()` 메서드를 사용하여 도서 목록을 비동기적으로 검색합니다. 검색된 도서는 컴포넌트의 `books` 속성에 저장되어 템플릿에서 렌더링될 수 있습니다.\n\n`BookService`를 중앙 데이터 관리 서비스로 사용함으로써 Angular 애플리케이션의 여러 컴포넌트간에 책과 관련된 데이터 및 작업을 쉽게 공유하고 관심사를 분리할 수 있습니다.\n\n서비스를 사용하여 복잡한 로직과 데이터 작업을 처리할 수 있으므로 컴포넌트를 가볍게 유지할 수 있고 컴포넌트 간의 효율적인 통신과 데이터 공유를 가능하게 합니다.\n\n\n<div class=\"content-ad\"></div>\n\nAOT와 JIT의 차이점은 무엇인가요?\n\n더 잘 이해하기 위해서 먼저 Angular 8까지 기본 Angular 컴파일 모드였던 JIT를 이해하는 것이 중요합니다. JIT 이후에는 AOT가 어떻게 작동하며 JIT와 어떻게 다른지 살펴보겠습니다:\n\nJust-in-Time (JIT)\n\nJIT 컴파일 모드에서 개발자가 작성한 TS 코드는 빌드 생성 중에 JS 코드로 컴파일됩니다. 이제 이 컴파일된 js 코드에는 여전히 일부 Angular 특정 코드(컴포넌트, 데코레이터, 변경 감지, 의존성 주입 등)가 포함되어 있으며, 이는 JIT 컴파일러의 도움으로 다시 브라우저에서 런타임에 컴파일됩니다.\n\n<div class=\"content-ad\"></div>\n\nJIT 모드에서 Angular 애플리케이션이 브라우저에서 부트스트랩될 때, JIT 컴파일러는 런타임에서 애플리케이션의 구성 요소를 분석하고 메모리에 코드를 생성하는 많은 작업을 수행합니다. 페이지를 새로고침하면 수행된 모든 작업이 폐기되고 JIT 컴파일러가 모든 작업을 다시 수행합니다.\n\n**Ahead-of-Time (AOT)**\n\n개발자가 작성한 TS 코드는 JS 코드로 컴파일되며, 이 JS 코드는 이미 Angular를 위해 컴파일되었습니다. 이제 브라우저가 이 컴파일된 js 코드를 다시 컴파일하여 html을 렌더링할 수 있습니다. 그러나 여기서 주의해야 할 점은 AOT 컴파일러가 이미 Angular의 기능을 다 처리했으므로 브라우저가 구성 요소 생성, 변경 감지, 의존성 주입에 대해 걱정할 필요가 없다는 것입니다. 따라서 다음과 같은 이점이 있습니다:\n\n**보다 빠른 렌더링**\n\n<div class=\"content-ad\"></div>\n\n앵귤러 컴파일러를 이미 컴파일한 경우에는 앵귈러 컴파일러를 다운로드할 필요가 없습니다. 컴파일러는 앵귈러의 절반 정도이므로 생략하면 애플리케이션 페이로드가 크게 줄어듭니다.\n\n템플릿 오류 빠르게 감지\n\nAOT 컴파일러는 사용자가 볼 수 있기 전에 빌드 단계에서 템플릿 바인딩 오류를 감지하고 보고합니다.\n\n보안 강화\n\n<div class=\"content-ad\"></div>\n\nAOT는 클라이언트에 제공되기 전에 HTML 템플릿과 컴포넌트를 JavaScript 파일로 컴파일합니다. 읽을 템플릿도 없고, 위험한 클라이언트 측 HTML 또는 JavaScript 평가도 없기 때문에, 삽입 공격 기회가 적어집니다.\n\nAngular의 공식 문서 링크에서 AOT를 이해하는 데 참고할 수도 있어요.\n\nAngular의 다양한 구성 요소란 무엇인가요?\n\nAngular는 함께 작동하여 견고한 웹 애플리케이션을 만드는 여러 구성 요소로 구성되어 있습니다. Angular의 주요 구성 요소는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 구성 요소: 구성 요소는 Angular 애플리케이션의 기본 구성 요소입니다. UI 및 로직을 캡슐화하여 사용자 인터페이스의 다른 부분을 나타냅니다. 구성 요소는 템플릿(HTML 마크업), 스타일(CSS), 구성 요소 동작을 정의하는 TypeScript 클래스로 구성됩니다.\n- 템플릿: 템플릿은 구성 요소의 UI의 구조와 레이아웃을 정의합니다. Angular의 템플릿 구문, 디렉티브, 데이터 바인딩 및 기타 기능을 결합한 HTML 마크업을 사용하여 데이터를 동적으로 조작하고 표시합니다.\n- 디렉티브: 디렉티브는 HTML 마크업에 적용되는 동작이나 모양을 수정하는 지시사항입니다. Angular에는 조건부 렌더링, 반복, 로직 전환을 위한 `ngIf`, `ngFor`, `ngSwitch`와 같은 내장 디렉티브가 제공됩니다. 또한, Angular에서는 사용자 지정 디렉티브를 만들어 응용 프로그램의 기능을 확장할 수 있습니다.\n- 서비스: 서비스는 여러 구성 요소 사이에서 공통 기능을 구성하고 공유하는 방법을 제공합니다. 서비스는 API에서 데이터 검색, 데이터 조작, 인증, 로깅 등의 작업을 처리합니다. 보통 의존성 주입을 사용하여 구성 요소나 다른 서비스에 서비스를 주입합니다.\n- 모듈: 모듈은 관련된 구성 요소, 디렉티브, 서비스 및 기타 코드를 응집된 단위로 그룹화하는 컨테이너입니다. Angular 응용 프로그램은 루트 모듈(`AppModule`) 및 피처 모듈을 포함한 여러 모듈로 구성됩니다. 모듈은 응용 프로그램 내에서 조직, 캡슐화 및 종속성 관리에 도움이 됩니다.\n- 의존성 주입(DI): 의존성 주입은 Angular에서 구성 요소와 서비스의 종속성을 관리하는 데 사용되는 설계 패턴과 메커니즘입니다. 의존성 주입을 사용하면 클래스에 의존성을 명시적으로 생성하거나 관리하지 않고 의존성을 주입할 수 있습니다. Angular의 의존성 주입 시스템은 생성자 매개변수 또는 property 주입을 통해 종속성을 선언, 제공 및 주입할 수 있는 방법을 제공합니다.\n- 라우팅: Angular의 라우터 모듈을 사용하면 클라이언트 측 탐색을 구현하고 다른 구성 요소에 대한 경로를 정의할 수 있습니다. 경로 구성, 매개 변수 전달, 인증 및 권한 부여를 위한 경로 가드, 모듈의 지연 로딩 등과 같은 기능을 제공합니다. 라우팅을 통해 단일 페이지 애플리케이션(SPA)을 다중 뷰로 만들 수 있습니다.\n- 폼: Angular는 템플릿 기반 폼과 반응형 폼을 포함한 강력한 폼 처리 기능을 제공합니다. 폼을 사용하면 사용자 입력을 캡처하고 유효성 검사를 수행하며 폼 제출을 처리할 수 있습니다. Angular 폼은 양방향 데이터 바인딩, 폼 유효성 검사, 폼 컨트롤, 폼 그룹 및 폼 빌더와 같은 기능을 제공합니다.\n- 파이프: 파이프는 템플릿에서 데이터를 변환하고 형식화하는 방법입니다. 필터 적용, 날짜 조작, 숫자 형식 지정, 텍스트 케이스 변환 등을 수행할 수 있습니다. Angular에는 내장 파이프인 `date`, `uppercase`, `lowercase`, `currency`와 같은 것이 제공되며 특정 변환 요구에 맞게 사용자 정의 파이프를 작성할 수 있습니다.\n\n이러한 구성 요소들은 구조화되고 모듈화된 Angular 애플리케이션을 만드는 데 함께 작용합니다. 구성 요소는 UI를 정의하고, 템플릿은 UI를 렌더링하고, 서비스는 일반 기능을 제공하며, 모듈은 응용 프로그램을 구성하고, DI는 종속성을 관리하며, 라우팅은 탐색을 가능하게 하고, 폼은 사용자 입력을 다루며, 파이프는 데이터를 표시하기 위해 변환합니다. 이러한 구성 요소들을 이해하고 효과적으로 활용하는 것은 Angular 애플리케이션 개발에 있어 필수적입니다.\n\n57. RxJS에서 retry() 연산자를 어떻게 사용하며, 그 목적은 무엇인가요?\n\n`retry()` 연산자는 RxJS에서 오류가 발생할 경우 옵저버블을 다시 구독하는 데 사용됩니다. 이 연산자는 자동으로 소스 옵저버블을 다시 구독하고, 지연이나 다른 사용자 정의 옵션을 사용하여 구독자에게 계속 값을 방출합니다. `retry()` 연산자는 옵저버블이 간헐적인 네트워크 오류 또는 다른 문제로 실패할 수 있는 상황에서 유용하며, 애플리케이션이 이러한 오류로부터 복구하고 계속 작동할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n여기 `retry()` 연산자를 사용하는 예시가 있습니다:\n\n```js\nimport { of } from 'rxjs';\nimport { map, mergeMap, retry } from 'rxjs/operators';\n\nconst source$ = of('http://my-api.com/data');\nconst data$ = source$.pipe(\n  mergeMap(url => fetch(url)), // fetch() 함수가 데이터와 함께 해결되는 프로미스를 반환한다고 가정합니다\n  map(response => response.json()),\n  retry(3) // 에러 발생 시 최대 3회까지 시도\n);\n\ndata$.subscribe(\n  data => console.log(data),\n  err => console.error(err),\n  () => console.log('완료')\n);\n```\n\n이 예시에서 `source$` 옵저버블은 API 엔드포인트를 가리키는 URL 하나를 방출합니다. `mergeMap` 연산자는 URL을 사용하여 `fetch()` 함수를 호출하고 응답 데이터를 반환하는 프로미스를 만듭니다. 그 후에 `map` 연산자를 사용하여 응답 데이터를 JSON으로 파싱합니다.\n\n`retry()` 연산자는 `map()` 연산자 이후에 사용되어, 에러 발생 시 observable이 최대 3회까지 재시도되어야 함을 지정합니다. 만약 observable 실행 중 에러가 발생하면 RxJS가 자동으로 최대 3회까지 원본 observable을 다시 구독하여 네트워크 에러 등에서 회복할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n우선 `retry()` 연산자는 추가 옵션과 함께 사용자 정의할 수 있다는 점을 강조해 드리고 싶습니다. 이러한 옵션에는 재시도 간의 지연이나 재시도를 트리거하는 오류를 결정하는 술어 함수와 같은 것이 포함될 수 있습니다. 이러한 옵션은 더 복잡한 시나리오를 처리하는 데 유용할 수 있습니다.\n\nAngular의 변경 감지는 응용 프로그램의 데이터 모델의 변경 사항을 감지하고 전파하여 해당 뷰를 업데이트하는 메커니즘입니다. 이를 통해 UI가 데이터의 현재 상태를 반영하도록 보장합니다. 응용 프로그램의 데이터에 변경 사항이 발생하면 Angular의 변경 감지 시스템이 자동으로 영향을 받은 구성 요소 및 해당 자식 구성 요소를 업데이트합니다. Angular의 변경 감지 작동 방식은 다음과 같습니다:\n\n- 초기화: 구성 요소가 생성되면 Angular은 그 변경 감지기를 초기화합니다. 변경 감지기는 구성 요소의 속성을 추적하고 변경 사항을 수신합니다.\n- 변경 감지 트리: Angular은 구성 요소 계층 구조를 나타내는 트리 구조인 변경 감지 트리를 구성합니다. 각 구성 요소는 자체의 변경 감지기를 가지며 자식 구성 요소는 부모의 변경 감지기 내에 중첩됩니다.\n- 변경 감지: Angular는 변경 감지 주기를 실행하여 변경 감지를 수행합니다. 이 주기는 사용자 상호 작용, 타이머 또는 비동기 작업과 같은 다양한 이벤트에 의해 트리거됩니다. 기본적으로 Angular는 이러한 이벤트 후 전체 응용 프로그램에 대해 자동으로 변경 감지를 트리거합니다.\n- 변경 감지 주기: 변경 감지 주기 동안 Angular는 루트 구성 요소의 변경 감지기에서 시작하여 위에서 아래 방향으로 변경 감지 트리를 횡단합니다.\n- 변경 사항 확인: 각 구성 요소에서 Angular는 구성 요소의 템플릿에 바인딩된 속성을 확인합니다. 각 속성의 현재 값과 이전 값과 비교합니다.\n- 뷰 업데이트: Angular가 구성 요소의 속성에서 변경 사항을 감지하면 해당 값을 반영하는 뷰를 업데이트합니다. 이는 DOM을 업데이트하고 구성 요소의 템플릿을 다시 렌더링하고 필요한 재흐름을 촉발하는 것을 포함합니다.\n- 자식 구성 요소 확인: 현재 구성 요소를 업데이트한 후 Angular는 변경 감지 주기를 계속하여 변경 감지 트리 내의 자식 구성 요소로 이동합니다. 각 자식 구성 요소에 대해 재귀적으로 변경 감지를 수행합니다.\n- 바인딩 전파: 부모 구성 요소에서 변경 사항이 발생하면 Angular는 이러한 변경 사항을 자식 구성 요소로 전파합니다. 이는 영향을 받은 자식 구성 요소가 적절하게 업데이트되도록 보장합니다.\n- 불변 데이터: Angular의 변경 감지는 변경 사항을 감지하기 위해 객체 참조를 사용합니다. 객체에 대한 참조가 같은 경우 Angular는 해당 객체가 변경되지 않았다고 가정합니다. 따라서 불변 데이터 패턴을 사용할 때는 변경 사항을 나타내기 위해 새로운 객체를 만드는 것이 중요합니다.\n- 성능 최적화: Angular의 변경 감지 시스템에는 여러 성능 최적화 기능이 포함되어 있습니다. 변경 사항이 없는 구성 요소에 대해 변경 감지 주기를 건너뛰기 때문에 성능이 최적화됩니다. Angular는 또한 컴포넌트가 입력 속성을 변경할 때에만 변경 사항을 확인해야 한다고 지정할 수 있는 OnPush 변경 감지 전략을 지원합니다.\n\n<div class=\"content-ad\"></div>\n\nAngular의 변경 감지 시스템은 변경을 효율적으로 감지하고 전파하여 응용 프로그램의 UI를 기반 데이터 모델과 동기화시키는 데 도움이 됩니다. 이를 통해 반응적이고 최신의 사용자 경험을 제공할 수 있습니다.\n\nAngular에서 zone.js는 무엇인가요?\n\nzone.js는 Angular에서 사용되는 JavaScript 라이브러리로, 실행 컨텍스트와 비동기 작업에 대한 후크를 제공합니다. 이를 통해 Angular는 이벤트 처리, 타이머, 프라미스, XHR 요청과 같은 비동기 작업의 실행을 추적하고 관리할 수 있습니다. zone.js를 통해 Angular는 비동기 작업이 완료되면 변경 감지를 수행하고 UI를 업데이트할 수 있습니다.\n\n다음은 Angular에서 zone.js 사용 예시입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <button (click)=\"simulateAsyncTask()\">Simulate Async Task</button>\n    <p>Status: { status }</p>\n  `\n})\nexport class ExampleComponent {\n  status: string = 'Not started';\n  simulateAsyncTask() {\n    this.status = 'Processing...';\n    setTimeout(() => {\n      // Simulating an asynchronous task completion\n      this.status = 'Completed';\n    }, 2000);\n  }\n}\n```\n\n이 Angular 컴포넌트에서는 비동기 작업의 상태를 표시하는 버튼과 문단이 있습니다. 버튼을 클릭하면 `simulateAsyncTask()` 메서드가 호출됩니다. 메서드 내에서는 작업이 처리 중임을 나타내기 위해 `status` 속성을 업데이트하고, `setTimeout` 함수를 사용하여 2초의 지연을 시뮬레이션합니다.\n\n내부적으로 Zone.js는 `setTimeout` 호출을 가로채고 비동기 작업에 훅을 설치합니다. 이를 통해 Angular이 작업의 실행을 추적하고 작업이 완료되면 변경 감지가 트리거됩니다. 타임아웃이 경과하면 콜백 함수가 실행되고, `status` 속성이 작업이 완료되었다는 것을 나타내도록 업데이트됩니다. 결과적으로 UI가 새로운 상태를 반영하도록 자동으로 업데이트됩니다.\n\n결론:\n\n<div class=\"content-ad\"></div>\n\nZone.js는 Angular에 비동기 작업을 변경 감지 메커니즘으로 원활하게 통합할 수 있는 방법을 제공하여, 비동기 작업이 완료되면 UI를 효율적으로 업데이트할 수 있습니다. 비동기 코드 처리를 간소화하고 Angular가 비동기 컨텍스트 내에서 발생하는 변경 사항을 인식하도록 보장합니다.\n\n60. Angular에서 FormArray를 사용하여 동적으로 폼 필드를 생성하는 방법은?\n\n## Angular에서 `FormArray`를 사용하여 동적으로 폼 필드를 생성하려면 다음 단계를 따를 수 있습니다:\n\n- 필요한 모듈 및 서비스를 가져오세요: — `@angular/forms`에서 `FormBuilder` 및 `FormGroup`를 가져옵니다.\n- 컴포넌트에서 폼 그룹과 폼 어레이를 동적으로 생성하세요: — 컴포넌트 클래스에서 `FormBuilder`를 사용하여 폼 그룹을 생성하고 그 안에 폼 어레이를 정의하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { FormBuilder, FormGroup, FormArray, Validators } from '@angular/forms';\n\n@Component({\n     selector: 'app-dynamic-form',\n     templateUrl: './dynamic-form.component.html',\n   })\n   \nexport class DynamicFormComponent implements OnInit {\n     dynamicForm: FormGroup;\n     constructor(private formBuilder: FormBuilder) {}\n     ngOnInit() {\n       this.dynamicForm = this.formBuilder.group({\n         formArrayName: this.formBuilder.array([]),\n       });\n     }\n     get formArray(): FormArray {\n       return this.dynamicForm.get('formArrayName') as FormArray;\n     }\n     // Other methods for adding, removing, and accessing form array controls\n }\n```\n\n3. Add and remove form array controls:\n\n— Implement methods to add and remove form array controls within the component.\n\n— These methods should use the `FormArray` methods `push()` and `removeAt()` to add or remove form array controls.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n//...\n\naddFormControl() {\n   const control = this.formBuilder.control('', Validators.required);\n   this.formArray.push(control);\n }\n   \nremoveFormControl(index: number) {\n   this.formArray.removeAt(index);\n}\n//...\n```\n\n4. Generate form fields dynamically in the template:\n\n— In the component’s template, use `*ngFor` to iterate over the form array controls and generate the corresponding form fields dynamically.\n\n```js\n<form [formgroup]=\"dynamicForm\" (ngsubmit)=\"onSubmit()\">\n     <div formarrayname=\"formArrayName\">\n       <div *ngfor=\"let control of formArray.controls; let i = index\">\n         <input [formcontrolname]=\"i\" type=\"text\">\n         <button (click)=\"removeFormControl(i)\">Remove</button>\n       </div>\n     </div>\n     <button (click)=\"addFormControl()\">Add Field</button>\n     <button type=\"submit\">Submit</button>\n </form>\n```  \n\n\n<div class=\"content-ad\"></div>\n\n위의 예제에서 `formArray`를 `formArrayName` 속성을 사용하여 액세스하고, `*ngFor`를 사용하여 폼 배열 컨트롤을 반복 처리합니다. 각 컨트롤은 입력 필드로 렌더링되며 해당 컨트롤을 제거하는 \"제거\" 버튼이 제공됩니다.\n\n5. 폼 제출 처리하기:\n\n— `FormGroup` 인스턴스를 사용하여 컴포넌트에서 폼 제출 로직을 구현하고, 폼 값에 액세스하여 필요한 작업을 수행합니다.\n\n```js\n//...\n\nonSubmit() {\n     if (this.dynamicForm.valid) {\n       const formValues = this.dynamicForm.value;\n       // 폼 제출 처리\n     }\n   }\n   //...\n```\n\n<div class=\"content-ad\"></div>\n\n위의 단계를 따라하면 Angular에서 `FormArray`를 사용하여 동적으로 폼 필드를 생성할 수 있습니다. 폼 배열을 사용하면 동적으로 폼 컨트롤을 추가하거나 제거할 수 있으며, 폼 값에 필요한 대로 액세스하고 처리할 수 있습니다.\n\n61. Angular에서 ngZone은 무엇인가요?\n\nAngular에서 `NgZone`은 비동기 작업과 변경 감지의 실행을 관리하고 제어하는 Angular 프레임워크에서 제공하는 서비스입니다. 변경 감지를 트리거하고 변경이 발생할 때 뷰를 업데이트하는 것을 담당합니다.\n\n`NgZone`의 주요 목적은 Angular의 존(Zone) 바깥에서 실행되는 코드(세 번째 자료 라이브러리에서의 이벤트 또는 타이머, AJAX 요청 또는 웹소켓과 같은 비동기 작업)를 처리하고 최적화하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n기본적으로 Angular는 \"Angular zone\"이라는 존에서 실행됩니다. 이 존 내에서 코드가 실행되면 Angular의 변경 감지 메커니즘이 자동으로 트리거되어 뷰가 업데이트됩니다. 그러나 Angular 존 외부에서 코드가 실행될 때는 Angular가 변경 사항을 감지하지 못할 수 있어 응용 프로그램 상태와 뷰 동기화에 문제가 발생할 수 있습니다.\n\n`NgZone`은 Angular 존 내부나 외부에서 코드를 명시적으로 실행할 수 있는 방법을 제공합니다. 코드를 실행하는 두 가지 방법을 제공합니다: `run()`과 `runOutsideAngular()`.\n\n1. run() : `run()` 메서드는 Angular 존 내부에서 제공된 함수를 실행합니다. 이로써 함수에서 트리거된 모든 변경 사항이 감지되어 뷰에서 업데이트되도록 보장됩니다.\n\n```js\nimport { Component, NgZone } from '@angular/core';\n\n@Component({\n     selector: 'app-example',\n     template: `\n       <button (click)=\"onClick()\">NgZone 내부에서 코드 실행</button>\n     `,\n })\n   \nexport class ExampleComponent {\n     constructor(private ngZone: NgZone) {}\n     onClick() {\n       this.ngZone.run(() => {\n         // NgZone 내에서 실행되는 코드\n         // Angular 변경 감지가 트리거됨\n       });\n     }\n   }\n```\n\n<div class=\"content-ad\"></div>\n\n위 예제에서 `onClick()` 메서드는 `NgZone`의 `run()` 메서드 내에 포함되어 있습니다. 버튼을 클릭하면 `run()` 함수 내부의 코드가 Angular zone 내에서 실행되어 변경사항이 감지되고 뷰에 업데이트됩니다.\n\n2. runOutsideAngular() : `runOutsideAngular()` 메서드를 사용하면 Angular zone 바깥에서 코드를 실행할 수 있습니다. Angular의 변경 감지가 필요하지 않거나 UI에 영향을 미치지 않는 작업에 대해 성능을 최적화할 때 유용합니다.\n\n```js\nimport { Component, NgZone } from '@angular/core';\n\n@Component({\n    selector: 'app-example',\n    template: `\n      <button (click)=\"onClick()\">Run Code Outside NgZone</button>\n    `,\n  })\n\nexport class ExampleComponent {\n    constructor(private ngZone: NgZone) {}\n    onClick() {\n      this.ngZone.runOutsideAngular(() => {\n        // NgZone 바깥에서 실행되는 코드\n        // Angular 변경 감지가 트리거되지 않음\n      });\n    }\n}\n```\n\n위의 예에서 `onClick()` 메서드는 `runOutsideAngular()` 메서드 내부의 코드를 실행합니다. 이를 통해 코드가 Angular zone 밖에서 실행되어 불필요한 변경 감지와 뷰 업데이트를 방지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n결론 :\n\n`NgZone`을 사용하여 Angular 존 내부 및 외부에서 코드의 실행을 제어하고 최적화하여 효율적인 변경 감지와 응용 프로그램 상태 및 뷰 간의 동기화를 보장할 수 있습니다.\n\n62. Angular에서 OnPush 전략을 사용하는 하위 구성 요소에서 부모에서 트리거된 이벤트가 변경 감지를 일으킬 수 있나요?\n\n아니요, 부모 구성 요소에서 트리거된 이벤트는 Angular의 `OnPush` 변경 감지 전략을 사용하는 하위 구성 요소에서 직접적으로 변경 감지를 일으킬 수 없습니다. `OnPush` 전략은 다음 조건 중 하나가 충족될 때에만 구성 요소에서 변경 감지를 트리거합니다.\n\n<div class=\"content-ad\"></div>\n\n- 컴포넌트의 입력 속성이 변경됩니다.\n- 컴포넌트 자체 또는 그 자식 컴포넌트 중 하나에서 발생한 이벤트가 수신되었습니다.\n\n## 이를 설명하기 위해 부모 컴포넌트와 자식 컴포넌트를 사용하는 예제를 살펴보겠습니다. 두 컴포넌트 모두 `OnPush` 변경 감지 전략을 사용합니다:\n\n```js\n// parent.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <button (click)=\"triggerEvent()\">이벤트 트리거</button>\n    <app-child [inputproperty]=\"inputProperty\"></app-child>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ParentComponent {\n  inputProperty: string = '초기값';\n  triggerEvent() {\n    // 부모 컴포넌트에서 트리거된 이벤트\n    console.log('부모 컴포넌트에서 트리거된 이벤트');\n  }\n}\n```\n\n```js\n// child.component.ts\nimport { Component, Input, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    { inputProperty }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ChildComponent {\n  @Input() inputProperty: string;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 `ParentComponent`에는 `triggerEvent()` 메서드를 트리거하는 버튼이 있습니다. 그러나 `ParentComponent`와 `ChildComponent` 모두 `OnPush` 변경 감지 전략을 사용하므로 부모 구성 요소에서 트리거된 이벤트는 직접적으로 자식 구성 요소에서 변경 감지를 트리거하지 않습니다.\n\n부모에서 자식 구성 요소로 변경 사항을 전파하려면 자식 구성 요소의 입력 속성을 업데이트해야 합니다. 예를 들어, `ParentComponent`의 `triggerEvent()` 메서드를 다음과 같이 수정할 수 있습니다:\n\n```js\ntriggerEvent() {\n  this.inputProperty = '새 값'; // 자식 구성 요소의 입력 속성 업데이트\n}\n```\n\n입력 속성 값을 업데이트함으로써, Angular의 변경 감지 메커니즘은 변경 사항을 감지하고 `OnPush` 전략을 사용하는 자식 구성 요소 내에서 변경 감지를 트리거합니다. 이렇게 하면 자식 구성 요소의 뷰가 그에 맞게 업데이트됩니다.\n\n<div class=\"content-ad\"></div>\n\n결론:\n\n요약하자면, 부모 구성 요소에서 트리거된 이벤트는 `OnPush` 전략을 사용하는 자식 구성 요소의 변경 감지를 직접적으로 유발하지 않습니다. 그러나 부모 구성 요소에서 자식 구성 요소의 입력 속성을 업데이트하여 간접적으로 변경 감지를 트리거할 수 있습니다.\n\n따라서, 부모 구성 요소에서 이벤트가 트리거된 경우, `OnPush` 전략을 사용하는 자식 구성 요소에서 자동으로 변경 감지가 트리거되지 않습니다. 이 동작은 성능을 최적화하여 불필요한 변경 감지 주기를 줄이는 데 목적이 있습니다.\n\n63. Angular에서 OnPush 전략을 사용하는 자식 구성 요소에서 트리거된 이벤트가 부모 구성 요소의 변경 감지를 유발할 수 있나요?\n\n<div class=\"content-ad\"></div>\n\n아니요, Angular에서 `OnPush` 변경 감지 전략을 사용할 때 자식 컴포넌트에서 트리거된 이벤트는 직접적으로 부모 컴포넌트의 변경 감지를 호출하지 못합니다. `OnPush` 전략은 컴포넌트의 입력 프로퍼티 중 하나가 변경되거나 컴포넌트 자체 또는 해당 자식 컴포넌트에서 발생한 이벤트를 수신할 때에만 변경 감지를 트리거합니다.\n\n하지만, EventEmitter나 공유 서비스와 같은 기술을 사용하여 자식 컴포넌트에서 부모 컴포넌트로 변경 사항을 전파할 수 있습니다. 다음 예제를 통해 이를 어떻게 구현할 수 있는지 살펴보겠습니다:\n\n```js\n// child.component.ts\nimport { Component, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    <button (click)=\"triggerEvent()\">이벤트 트리거</button>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ChildComponent {\n  @Output() childEvent: EventEmitter = new EventEmitter();\n  triggerEvent() {\n    this.childEvent.emit(); // 자식 컴포넌트에서 이벤트 발생\n  }\n}\n```\n\n```js\n// parent.component.ts\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <app-child (childEvent)=\"handleChildEvent()\"></app-child>\n    <p>받은 이벤트: {{ eventReceived }}</p>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ParentComponent {\n  eventReceived: boolean = false;\n  handleChildEvent() {\n    this.eventReceived = true; // 부모 컴포넌트에서 상태 업데이트\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 `ChildComponent`는 버튼을 클릭할 때 `childEvent` EventEmitter를 사용하여 사용자 정의 이벤트를 방출합니다. `ParentComponent`는 이 이벤트를 청취하고 `handleChildEvent()` 메서드를 트리거하여 부모 컴포넌트의 `eventReceived` 속성을 업데이트합니다.\n\n결론:\n\n부모 컴포넌트의 상태를 업데이트함으로써 Angular의 변경 감지 메커니즘이 변경 사항을 감지하고 이에 따라 부모 컴포넌트에서 변경 감지를 트리거하여 뷰를 업데이트합니다.\n\n부모 컴포넌트에서의 변경 감지는 자식 컴포넌트에서 방출된 이벤트로 인한 반응으로 트리거되지만, 실제로 이벤트 자체로 인해 발생되는 것은 아닙니다. 대신 부모 컴포넌트 상태의 변경이 변경 감지를 트리거합니다.\n\n<div class=\"content-ad\"></div>\n\n64. Angular 애플리케이션을 최적화하는 방법\n\nAngular 애플리케이션을 최적화하는 것은 성능과 효율성을 향상시키기 위한 다양한 전략과 기술을 포함합니다. Angular 애플리케이션을 최적화하기 위해 몇 가지 단계를 살펴보겠습니다:\n\n- 코드 압축과 번들링: Angular CLI와 같은 빌드 도구를 사용하여 애플리케이션 코드를 압축하고 번들링하세요(ng build --prod). 이렇게 하면 파일 크기를 줄이고 애플리케이션의 로드 시간을 개선할 수 있습니다.\n- 모듈의 lazy loading: 애플리케이션을 작은 모듈로 분할하고 필요할 때 lazy loading하세요. 이 방법을 통해 초기 번들 크기를 줄이고 애플리케이션의 초기 로드 시간을 개선할 수 있습니다.\n- Ahead-of-Time (AOT) 컴파일 사용: Angular 애플리케이션에서 AOT 컴파일을 활성화하세요. AOT는 빌드 프로세스 중에 템플릿을 컴파일하여 보다 빠른 렌더링과 성능 향상을 제공합니다.\n- 네트워크 요청 최적화: HTTP 요청 수를 줄여 여러 요청을 하나로 결합하는 HTTP 배치 또는 서버 측 렌더링 (SSR)과 같은 기술을 사용하여 페이지를 사전 렌더링하여 HTTP 요청 수를 줄입니다. 자주 액세스되는 데이터를 저장하고 재사용하기 위해 캐싱 메커니즘을 구현하세요.\n- 렌더링 최적화: `OnPush` 변경 감지 전략과 `ChangeDetectionRef` API를 사용하여 구성 요소의 불필요한 다시 렌더링을 피하세요.\n- Angular Universal 사용: Angular Universal을 사용하여 서버 측 렌더링 (SSR)을 구현하는 것을 고려하세요. SSR은 초기 렌더링 시간을 개선하고 완전히 렌더링된 페이지를 검색 엔진 크롤러에 제공함으로써 검색 엔진 최적화 (SEO)를 향상시킬 수 있습니다.\n- Angular 성능 도구 최적화: Angular DevTools 및 Lighthouse와 같은 Angular 성능 도구를 활용하여 애플리케이션의 성능 병목 현상, 메모리 누수 및 기타 문제를 식별하세요. 성능 프로파일링 기능을 사용하여 코드를 분석하고 최적화하세요.\n- Tree shaking 및 죽은 코드 제거: 빌드 프로세스를 구성하여 tree shaking 및 죽은 코드 제거를 수행하도록 확인하세요. 이렇게 하면 애플리케이션에서 사용되지 않는 코드가 제거되어 번들 크기가 줄어듭니다.\n- CSS와 이미지 최적화: CSS를 최적화하여 셀렉터 수를 줄이고 사용하지 않는 스타일을 제거하고 CSS 파일을 압축하세요. 이미지 스프라이트를 사용하세요. 많은 이미지가 있는 웹 페이지는 로드하는 데 오랜 시간이 걸리고 여러 서버 요청을 생성할 수 있습니다. 이미지 스프라이트를 사용하면 서버 요청 수가 줄어들고 대역폭을 절약할 수 있습니다.\n\n결론:\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n\nRemember that optimization is an iterative process, and the specific optimizations required may vary depending on the nature of your application. Monitor your application’s performance and gather feedback from users to identify areas that need further optimization.\n\n65. Explain pure and impure pipe in Angular ?\n\nIn Angular, pipes are used to transform data in templates. They can be categorized as pure pipes and impure pipes based on their behavior and performance characteristics.\n\n- Pure Pipes: Pure pipes are the default type of pipes in Angular. They are designed to be pure functions that take an input value and return a transformed output value. Pure pipes are stateless and deterministic, meaning their output is solely dependent on their input, and they don’t have any side effects. Angular optimizes pure pipes by executing them only when their input values change.\n\n\n<div class=\"content-ad\"></div>\n\n여기에 Angular에서의 순수 파이프 예제가 있습니다:\n\n```javascript\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n     name: 'testPipe',\n     pure: true\n })\n export class TestPipe implements PipeTransform {\n     transform(value: string): string {\n       Object.keys(value).forEach(function(key,index) {\n            // key: 객체 키의 이름\n            // index: 객체 내의 키의 순서\n            value[key] = value[key].toUpperCase()\n        });\n        return value;\n     }\n }\n```\n\n위 예제에서 `TestPipe`는 문자열을 대문자로 변환하는 순수 파이프입니다. `@Pipe` 데코레이터의 `pure: true` 설정은 이 파이프가 순수함을 나타냅니다. 입력 `value`가 변경될 때에만 `transform` 함수가 실행됩니다.\n\n다음과 같은 HTML 코드가 있다고 가정해봅시다:\n\n<div class=\"content-ad\"></div>\n\n```js\n{ user | testPipe} in HTML\n```\n\n참고로 컴포넌트 코드는 다음과 같습니다:-\n\n```js\nuser = { name:'test', city: 'test city'};\n```\n\n그리고 새로운 변경 사항은 다음과 같습니다:-\n\n\n<div class=\"content-ad\"></div>\n\n```js\nthis.user.city = \"new test city\"\n```\n\n위의 예시에서, testPipe은 객체 참조가 변경되지 않아 실행되지 않습니다. Pipe를 실행하려면 testPipe의 순수 속성을 false로 설정하거나 컴포넌트 코드에 다음 변경 사항을 해야합니다:-\n\n```js\nthis.user = {\n    name: 'new test',\n    city: 'new test city'\n}\n```\n\n위의 코드에서는 객체 참조가 변경되어 testPipe이 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n2. 순수하지 않은 Pipes:\n\n한편, 순수하지 않은 파이프는 부작용을 가질 수 있고 더 자주 실행될 수 있는 파이프입니다. `@Pipe` 데코레이터 내에서 `pure` 속성을 `false`로 설정하여 명시적으로 순수하지 않음을 표시합니다. Angular에 의해 변경 감지를 위해 최적화되지 않으며 입력 값이 변경되지 않았더라도 여러 번 실행될 수 있습니다.\n\n다음은 Angular에서 순수하지 않은 파이프의 예시입니다:\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n    name: 'testPipe',\n    pure: false\n})\nexport class TestPipe implements PipeTransform {\n    transform(value: string): string {\n        Object.keys(value).forEach(function(key,index) {\n            // key: 객체 키의 이름\n            // index: 객체 내 키의 순서 위치\n            value[key] = value[key].toUpperCase()\n        });\n        return value;\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음과 같은 HTML 코드와 컴포넌트 코드가 있습니다:-\n\n```js\n{ user | testPipe } in HTML\n```\n\n```js\nuser = { name:'test', city: 'test city'};\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 새로운 변경 사항은 :-\n\n\njs\nthis.user.city = \"new test city\"\n\n\n위 예제에서는 testPipe가 실행됩니다. Impure pipes는 입력 값의 변경 여부와 상관없이 Angular가 변경을 감지할 때마다 실행됩니다.\n\n결론:\n\n<div class=\"content-ad\"></div>\n\n순수 파이프는 Angular에서 성능 최적화로 기본 및 권장되는 유형이지만, 상태를 가진 또는 결정론적이지 않은 변환을 처리할 때 일부 시나리오에서 비순수 파이프를 사용하는 게 유용할 수 있습니다. 그러나 비순수 파이프를 과도하게 또는 부적절하게 사용하면 Angular 애플리케이션의 성능에 영향을 줄 수 있습니다.\n\n66. Angular에서의 단위 테스트를 설명하시오.\n\nAngular에서의 단위 테스트는 개별 구성 요소, 서비스 및 다른 코드 단위를 격리하여 올바르게 작동하는지 확인하기 위한 것입니다. Angular는 단위 테스트를 용이하게 하는 TestBed 및 다양한 테스트 유틸리티를 제공합니다. 다음은 Angular에서의 단위 테스트를 설명하는 예시입니다:\n\n## `CalculatorComponent` 라는 간단한 산술 연산을 수행하는 구성 요소를 고려해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-calculator',\n  template: `\n    <div>\n      <input type=\"number\" [(ngmodel)]=\"num1\">\n      <input type=\"number\" [(ngmodel)]=\"num2\">\n      <button (click)=\"add()\">Add</button>\n      <p>Result: { result }</p>\n    </div>\n  `\n})\nexport class CalculatorComponent {\n  num1: number;\n  num2: number;\n  result: number;\n\n  add() {\n    this.result = this.num1 + this.num2;\n  }\n}\n```\n\n이 구성요소에 대한 단위 테스트를 작성하려면 Angular에서 제공하는 테스트 프레임워크를 활용할 수 있습니다. 다음은 Jasmine 테스트 프레임워크를 사용한 예제 테스트입니다:\n\n```js\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { CalculatorComponent } from './calculator.component';\n\ndescribe('CalculatorComponent', () => {\n  let component: CalculatorComponent;\n  let fixture: ComponentFixture;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [ CalculatorComponent ]\n    }).compileComponents();\n  });\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(CalculatorComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should add two numbers', () => {\n    component.num1 = 5;\n    component.num2 = 10;\n    component.add();\n    expect(component.result).toBe(15);\n  });\n});\n```\n\n위의 테스트에서 `describe` 함수를 사용하여 `CalculatorComponent`에 대한 테스트 스위트를 정의합니다. `beforeEach` 함수 내에서 `TestBed.createComponent`를 사용하여 구성요소의 인스턴스를 생성하고, 이를 `fixture`에 할당합니다. 그런 다음 테스트 내에서 구성요소 인스턴스를 `component`에 할당하여 편리하게 테스트에서 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n`it` 함수는 개별 테스트 케이스를 정의합니다. 이 경우에는 `num1`과 `num2`를 각각 5와 10으로 설정하고 `add` 메소드를 호출한 뒤 `result`가 15가 될 것으로 기대합니다.\n\n단위 테스트를 실행하려면 Angular의 CLI 명령어 `ng test`를 사용할 수 있습니다. 이 명령은 Karma 테스트 러너를 사용하여 테스트를 실행합니다.\n\n결론:\n\n단위 테스트를 작성함으로써 개별 컴포넌트, 서비스 및 기타 코드 단위가 예상대로 작동하는지 확인할 수 있습니다. 이를 통해 버그를 일찍 발견하고 Angular 애플리케이션의 코드 품질을 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n67. Angular 서비스를 테스트하는 방법\n\nAngular 서비스를 테스트하려면 Angular의 테스트 유틸리티와 기술을 사용할 수 있습니다. 다음은 Angular 서비스를 테스트하는 방법을 보여주는 예시입니다:\n\n간단한 사용자 관련 작업을 수행하는 `UserService`라는 서비스가 있다고 가정해봅시다:\n\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class UserService {\n \n private users: string[] = [];\n  \n addUser(user: string) {\n    this.users.push(user);\n  }\n  \n getUserCount() {\n    return this.users.length;\n  }\n  \n deleteUser(user: string) {\n    const index = this.users.indexOf(user);\n    if (index !== -1) {\n      this.users.splice(index, 1);\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 Angular의 테스트 유틸리티를 사용하여 `UserService`에 대한 단위 테스트를 작성해 봅시다:\n\n```js\nimport { TestBed } from '@angular/core/testing';\nimport { UserService } from './user.service';\n\ndescribe('UserService', () => {\n  let service: UserService;\n  beforeEach(() => {\n    TestBed.configureTestingModule({});\n    service = TestBed.inject(UserService);\n  });\n  \n it('사용자 추가가 되어야 합니다', () => {\n    service.addUser('John');\n    expect(service.getUserCount()).toBe(1);\n  });\n \n it('사용자 삭제가 되어야 합니다', () => {\n    service.addUser('John');\n    service.addUser('Jane');\n    service.deleteUser('John');\n    expect(service.getUserCount()).toBe(1);\n  });\n});\n```\n\n위의 테스트에서는 `describe`를 사용하여 `UserService`에 대한 테스트를 그룹화하고, `TestBed.configureTestingModule()`를 사용해 설정을 합니다. 그 후 `TestBed.inject()`를 사용하여 `UserService`를 주입하고 `service` 변수에 할당합니다.\n\n`it` 함수는 개별 테스트 케이스를 정의합니다. 첫 번째 테스트에서는 'John' 사용자를 추가하고 사용자 수가 1인지를 기대합니다. 두 번째 테스트에서는 'John'과 'Jane' 두 명의 사용자를 추가한 후 'John'을 삭제한 뒤 사용자 수가 1인지를 기대합니다.\n\n<div class=\"content-ad\"></div>\n\n서비스의 단위 테스트를 실행하려면 Angular CLI 명령어 `ng test`를 사용할 수 있습니다. 이 명령은 Karma 테스트 러너를 사용하여 테스트를 실행합니다.\n\n결론:\n\nAngular 서비스에 대한 테스트를 작성함으로써 서비스가 예상대로 기능하고 있는지 확인할 수 있습니다. 이는 메서드 및 데이터 조작을 포함합니다. 이를 통해 오류를 찾고 동작을 검증하며 서비스 로직의 정확성을 유지할 수 있습니다.\n\n68. ngAfterContentInit 훅을 설명해주세요.\n\n<div class=\"content-ad\"></div>\n\n`ngAfterContentInit` 훅은 Angular에서 컴포넌트로 프로젝트된 콘텐츠가 초기화된 후에 호출되는 라이프사이클 훅입니다. 이 훅은 컴포넌트로 프로젝트된 콘텐츠가 초기화된 후에 초기화 또는 설정 로직을 수행하고 싶을 때 유용합니다.\n\n다음은 Angular 컴포넌트에서 `ngAfterContentInit` 훅을 사용하는 예입니다:\n\n```js\nimport { Component, AfterContentInit, ContentChild } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  template: `\n    <ng-content></ng-content>\n  `\n})\nexport class MyComponent implements AfterContentInit {\n  @ContentChild('myContent') myContent: ElementRef;\n  \n  ngAfterContentInit() {\n    // 콘텐츠가 컴포넌트로 프로젝트된 후에 이 코드가 실행됩니다\n    console.log('콘텐츠가 초기화되었습니다:', this.myContent.nativeElement.textContent);\n  }\n}\n```\n\n위 예제에서 `MyComponent` 컴포넌트에는 템플릿이 ``ng-content``/ng-content`` 태그를 포함하고 있습니다. 이 태그는 컴포넌트를 사용할 때 콘텐츠가 프로젝트될 자리 표시자 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n컴포넌트 클래스 내부에서는 `@ContentChild` 데코레이터를 사용하여 프로젝트된 콘텐츠에 대한 참조를 가져옵니다. 이 경우에는 템플릿 참조 변수 `myContent`가 있는 요소를 찾고 있습니다. 특정 사용 사례에 따라 CSS 클래스나 컴포넌트 유형과 같은 다른 셀렉터를 사용할 수도 있습니다.\n\n`ngAfterContentInit` 메서드는 `AfterContentInit` 인터페이스의 일부로 구현되어 있어 컴포넌트의 라이프사이클에 훅을 걸 수 있습니다. 이 메서드 내부에서 프로젝트된 콘텐츠를 기반으로 필요한 초기화나 로직을 수행할 수 있습니다. 이 예제에서는 프로젝트된 요소의 텍스트 콘텐츠를 콘솔에 로그로 출력합니다.\n\n다른 템플릿에서 `MyComponent` 컴포넌트를 사용하고 프로젝트할 콘텐츠를 제공할 때, `ngAfterContentInit` 메서드는 콘텐츠가 초기화된 후에 호출됩니다.\n\n```js\n<app-my-component>\n  <div #mycontent>This content will be projected</div>\n</app-my-component>\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드가 실행되면 `MyComponent`의 `ngAfterContentInit` 메서드가 트리거되어, 프로젝트된 `div` 요소의 텍스트 내용을 콘솔에 로그로 기록합니다.\n\nAngular 컴포넌트에서 `Component`, `AfterContentInit`, 그리고 `ContentChild`에 대한 필요한 가져오기를 `@angular/core` 모듈에서 포함해야 합니다.\n\n69. 예제와 함께 ngAfterViewInit 훅을 설명해보세요.\n\n`ngAfterViewInit` 훅은 Angular에서의 라이프사이클 훅으로, Angular이 컴포넌트의 뷰 및 해당 자식 뷰를 초기화한 후 호출됩니다. 이 훅은 컴포넌트의 뷰나 해당 자식 뷰에 액세스할 필요가 있는 로직 또는 작업을 수행해야 할 때 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n여기 Angular 컴포넌트에서 `ngAfterViewInit` 훅을 사용하는 방법 예제가 있어요:\n\n```js\nimport { Component, AfterViewInit, ViewChild, ElementRef } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  template: `\n    <div #myDiv>내용</div>\n  `\n})\nexport class MyComponent implements AfterViewInit {\n  @ViewChild('myDiv') myDiv: ElementRef;\n  \n  ngAfterViewInit() {\n    // 이 코드는 컴포넌트의 뷰가 초기화된 후 실행됩니다\n    console.log('뷰가 초기화됨:', this.myDiv.nativeElement.textContent);\n  }\n}\n```\n\n이 예제에서 `MyComponent` 컴포넌트는 템플릿에 템플릿 참조 변수 `myDiv`를 가진 `div` 요소가 포함되어 있어요. 우리는 `@ViewChild` 데코레이터를 사용하여 이 요소에 대한 참조를 컴포넌트 클래스에서 가져옵니다.\n\n`ngAfterViewInit` 메서드는 `AfterViewInit` 인터페이스의 일부로 구현되어 있으며 컴포넌트 뷰의 라이프사이클에 연결할 수 있게 합니다. 이 메서드 내에서 컴포넌트 뷰의 DOM 요소에 액세스하고 조작할 수 있어요. 이 예에서는 `myDiv`의 텍스트 내용을 로깅합니다.\n\n<div class=\"content-ad\"></div>\n\n` 요소를 콘솔에 기록합니다. 컴포넌트 뷰가 초기화될 때 Angular은 `ngAfterViewInit` 메소드를 호출하며, 이때 컴포넌트 뷰나 해당 자식 뷰에 액세스해야 하는 필요한 작업을 수행할 수 있습니다.\n\n다음은 다른 템플릿에서 `MyComponent` 컴포넌트를 사용하는 예시입니다:\n\n```js\n<app-my-component></app-my-component>\n```\n\n위 코드가 실행되면, `MyComponent`의 `ngAfterViewInit` 메소드가 트리거되어 ``div`` 요소의 텍스트 내용을 콘솔에 기록하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n`@angular/core` 모듈에서 `Component`, `AfterViewInit`, `ViewChild`, 그리고 `ElementRef`을 가져와야 합니다.\n\n결론:\n\n참고: `ngAfterViewInit` 훅을 사용할 때는 주의해야 합니다. DOM에 직접 접근하고 조작하는 것이 Angular의 선언적 접근 방식의 원칙에 어긋날 수 있습니다. 가능한 경우에는 DOM을 직접 조작하는 대신 Angular의 데이터 바인딩과 컴포넌트 상호 작용 매커니즘을 사용하는 것이 좋습니다.\n\n70. `ngAfterContentInit`과 `ngAfterViewInit`의 차이점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n`ngAfterContentInit`와 `ngAfterViewInit` 후크는 둘 다 Angular에서 라이프사이클 후크이지만, 서로 다른 맥락에서 사용되며 다른 목적을 갖습니다.\n\n`ngAfterContentInit`은 Angular이 컴포넌트로 프로젝트된 내용을 초기화한 후 호출되는 라이프사이클 후크입니다. 이는 컴포넌트로 프로젝트된 내용에 의존하는 초기화 또는 설정 로직을 수행해야 할 때 사용됩니다. 이 후크는 일반적으로 부모 컴포넌트로부터 콘텐츠를 프로젝트하기 위해 템플릿에 ``ng-content`` 태그를 사용하는 컴포넌트에서 사용됩니다. `@ContentChild` 데코레이터를 사용하여 프로젝트된 콘텐츠에 접근할 수 있습니다.\n\n반면에, `ngAfterViewInit`은 Angular이 컴포넌트의 뷰 및 해당 하위 뷰를 초기화한 후 호출되는 라이프사이클 후크입니다. 이는 컴포넌트의 뷰나 해당 하위 뷰에 액세스가 필요한 로직이나 작업을 수행해야 할 때 사용됩니다. 이 후크는 주로 DOM 조작, ViewChild 요소에 액세스, 완전히 렌더링된 뷰가 필요한 타사 라이브러리와 상호 작용하는 데 사용됩니다. `@ViewChild` 데코레이터를 사용하여 뷰 요소에 액세스할 수 있습니다.\n\n`ngAfterContentInit`와 `ngAfterViewInit` 간의 주요 차이를 요약하면 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 목적:\n\n— `ngAfterContentInit`: 프로젝트된 컨텐츠에 의존하는 초기화 또는 설정 로직에 사용됩니다.\n\n— `ngAfterViewInit`: 컴포넌트의 뷰 또는 자식 뷰에 액세스가 필요한 논리 또는 작업에 사용됩니다.\n\n2. Timing:\n\n<div class=\"content-ad\"></div>\n\n— `ngAfterContentInit`: 컨텐츠 프로젝션 초기화 후 호출됨.\n\n— `ngAfterViewInit`: 컴포넌트의 뷰 및 자식 뷰가 초기화된 후 호출됨.\n\n3. 데코레이터:\n\n— `ngAfterContentInit`: 프로젝션된 컨텐츠에 액세스하려면 `@ContentChild` 데코레이터를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n— `ngAfterViewInit`: `@ViewChild` 데코레이터를 사용하여 뷰 요소에 액세스합니다.\n\n4. 사용 방법:\n\n— `ngAfterContentInit`: 일반적으로 상위 컴포넌트에서 콘텐츠를 프로젝트하는 컴포넌트에서 사용됩니다.\n\n— `ngAfterViewInit`: 일반적으로 DOM 조작, 뷰 요소 액세스 또는 서드 파티 라이브러리와 상호 작용하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n결론:\n\n요약하면, `ngAfterContentInit`는 프로젝트된 콘텐츠를 기반으로 초기화를 수행해야 할 때 사용되고, `ngAfterViewInit`는 컴포넌트의 뷰 또는 자식 뷰에 액세스가 필요한 로직 또는 작업을 수행해야 할 때 사용됩니다.\n\n71. Angular에서 View Encapsulation이란 무엇인가요?\n\nAngular에서 View Encapsulation은 스타일이 구성 요소에 적용되고 범위가 제어되는 기능입니다. 구성 요소에서 정의된 스타일을 캡슐화하여 다른 구성 요소에 영향을주지 않도록하는 메커니즘입니다.\n\n<div class=\"content-ad\"></div>\n\n기본적으로 Angular는 ViewEncapsulation.Emulated 모드가 사용됩니다. 또는 \"그림자 DOM\" 모방이라고도 합니다. 이 모드에서 Angular는 컴포넌트의 HTML 요소에 고유한 속성을 추가하여 이러한 속성을 사용하여 스타일을 적용하여 그림자 DOM의 동작을 모방합니다. 이 방법으로 컴포넌트 내에서 정의된 스타일은 해당 컴포넌트의 템플릿 내 요소에만 영향을 미치고 응용 프로그램의 다른 부분으로 유출되지 않습니다.\n\nAngular에서 사용할 수 있는 세 가지 ViewEncapsulation 모드가 있습니다:\n\n- ViewEncapsulation.Emulated (기본값): 이 모드는 고유한 속성을 컴포넌트의 요소에 추가하여 그림자 DOM을 흉내냅니다. 컴포넌트 템플릿 내에서 정의된 스타일은 해당 컴포넌트에만 범위가 있습니다. ViewEncapsulation.Emulated는 웹 사이트의 head 섹션에 css 스타일을 추가하고 컴포넌트의 고유한 id(_ngcontent)를 참조하여 적용합니다.\n- ViewEncapsulation.None: 이 모드에서는 컴포넌트 템플릿에서 정의된 스타일이 캡슐화되지 않고 전체 응용 프로그램에 영향을 줄 수 있습니다. 이 모드를 사용할 때 주의해야 하며, 동일한 스타일을 사용하는 여러 컴포넌트에서 스타일 충돌 및 의도하지 않은 부작용이 발생할 수 있습니다.\n- ViewEncapsulation.ShadowDom: 이 모드는 원래 브라우저의 그림자 DOM 구현을 사용하여 스타일을 캡슐화합니다. 이 모드는 브라우저가 그림자 DOM을 지원해야 합니다. 이 모드에서 컴포넌트의 스타일은 실제로 컴포넌트 내에서 완전히 격리되며 다른 컴포넌트나 전역 스타일로 유출되지 않습니다. ViewEncapsulation.ShadowDom은 컴포넌트의 생성된 DOM 내에 css 스타일을 추가합니다.\n\n컴포넌트의 ViewEncapsulation 모드를 지정하려면 컴포넌트 메타데이터에서 `encapsulation` 속성을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component, ViewEncapsulation } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css'],\n  encapsulation: ViewEncapsulation.Emulated // 또는 ViewEncapsulation.None 또는 ViewEncapsulation.ShadowDom\n})\nexport class MyComponent {\n  // 컴포넌트 로직을 여기에 작성합니다.\n}\n```\n\n요약:\n\n앵귤러에서 ViewEncapsulation을 이해하고 활용함으로써 애플리케이션의 컴포넌트 간 스타일 간섭을 방지하고 스타일을 더 잘 제어할 수 있습니다.\n\n72. 폴리필(polyfills)의 사용 목적은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n폴리필(Polyfills)은 모든 브라우저에서 지원하지 않는 기능이나 API에 대한 호환성을 제공하는 추가 스크립트입니다. 이러한 스크립트들은 빌드 프로세스 중에 Angular 애플리케이션에 자동으로 포함되어 오래된 버전을 포함한 여러 브라우저에서 애플리케이션이 실행될 수 있도록 보장합니다.\n\n다음은 Angular 애플리케이션에서 폴리필의 사용법을 설명하는 예시입니다:\n\n- \"polyfills.ts\" 파일 열기: Angular 프로젝트에서 \"polyfills.ts\" 파일을 찾아보세요. 보통 \"src\" 폴더에 위치해 있습니다. 이 파일에는 폴리필의 구성이 포함되어 있습니다.\n- 필요한 폴리필 주석 처리 또는 추가하기: \"polyfills.ts\" 파일 내부에는 필요한 폴리필을 주석 처리하거나 추가할 수 있는 섹션이 있습니다. 각 폴리필은 모든 브라우저에서 지원되지 않을 수 있는 특정 기능이나 API에 대응합니다.\n\n예를 들어, 특정 JavaScript 기능을 지원하지 않는 오래된 브라우저를 지원해야 한다면, 해당 특정 기능에 대한 폴리필을 주석 처리하거나 추가할 수 있습니다. 모든 브라우저에서 `Array.from` 메소드를 지원하려고 한다면, 다음 라인을 주석 처리하거나 추가할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// 아래의 주석을 해제하여 이전 버전 브라우저에서 'Array.from'을 지원할 수 있도록 설정\n   // import 'core-js/es/array/from';\n```\n\n이 줄은 'core-js' 라이브러리에서 폴리필을 가져와서 `Array.from` 메서드가 기본적으로 지원되지 않는 브라우저에서도 작동하도록 합니다.\n\n비슷하게, 필요한 기능 또는 API를 지원하기 위해 다른 폴리필을 주석 처리하거나 추가할 수 있습니다.\n\n3. 애플리케이션 빌드 및 배포: \"polyfills.ts\" 파일에 필요한 폴리필을 구성한 후, Angular CLI나 선호하는 빌드 프로세스를 사용하여 Angular 애플리케이션을 보통대로 빌드하고 배포할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n빌드 프로세스 중에 Angular는 지정된 폴리필과 함께 응용 프로그램을 번들링합니다. 이러한 폴리필은 응용 프로그램 코드와 함께 브라우저에서 자동으로 로드됩니다.\n\n결론:\n\n적절한 폴리필을 포함시킴으로써 Angular 응용 프로그램은 현대적인 기능과 API를 활용하면서 더 많은 브라우저(오래된 버전 포함)와의 호환성을 유지할 수 있습니다. 폴리필은 응용 프로그램이 서로 다른 브라우저에서 일관된 동작을 보이도록 보장하며, 부드럽고 기능적인 사용자 경험을 제공합니다.\n\n응용 프로그램의 성능을 최적화하고 브라우저 표준의 진화에 대한 호환성을 확보하기 위해 폴리필을 주기적으로 검토하고 업데이트해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n73. RxJS의 scan 연산자란 무엇인가요?\n\nRxJS(JavaScript용 Reactive Extensions)에서 scan 연산자는 observable 시퀀스에서 발생한 값에 대해 누산 작업을 수행하는 데 사용됩니다. 이는 JavaScript의 Array.prototype.reduce() 함수와 유사하지만, 배열 대신 값의 observable 스트림에서 작동합니다.\n\nscan 연산자는 누산기 함수와 선택적으로 시드 값이 파라미터로 전달됩니다. 누산기 함수는 원본 observable에서 발생한 각 값에 대해 호출되며, 이전에 누적된 값과 소스에서의 현재 값에 기반하여 중간 결과를 누적합니다. 그리고 이 누적된 값은 결과 observable 시퀀스로 전달됩니다.\n\n아래는 scan 연산자의 일반적인 구문입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst $scanOperator = from([1,2,3,4]).pipe(\n      scan((sum,num) => sum+num)\n    );\n\n$scanOperator.subscribe(data=> {\n      console.log('scan operator data', data);\n    });\n // output :\n // scan operator data 1\n // scan operator data 3\n // scan operator data 6\n // scan operator data 10\n```\n\n참고: scan 연산자에서는 중간 결과가 발행되지만 reduce 연산자에서는 중간 결과가 발행되지 않고 최종 결과만 발행됩니다.\n\n결론:\n\nscan 연산자는 상태를 유지하거나 값들을 시간이 지남에 따라 누적해야 하는 경우 유용합니다. 전체 카운트 추적, 평균 계산 또는 러닝 합을 시뮬레이션하는 경우와 같이 시간이 지남에 따라 값을 누적해야 하는 시나리오에 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n74. Angular에서 spyOn이 작동하는 방법은 무엇인가요?\n\nAngular에서 `spyOn`은 Jasmine 테스팅 프레임워크에서 제공하는 유틸리티로, 테스트 스파이를 생성하는 데 사용됩니다. 스파이는 테스트 중에 함수의 동작을 관찰하고 제어할 수 있게 해줍니다. 특정 기능 구현을 사용자 정의한 것으로 바꾸거나, 함수 호출을 추적하고 그 동작에 대해 어서트(assert)하는 데 일반적으로 사용됩니다.\n\n## Angular에서 `spyOn`이 작동하는 방법을 보여주는 예시입니다:\n\n가정해봅시다. `DataService`라는 서비스가 외부 API와 상호 작용하는 경우:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class DataService {\n  fetchData(): Promise {\n    return new Promise((resolve) => {\n      // 비동기 API 호출을 시뮬레이션합니다\n      setTimeout(() => {\n        const data = 'API에서 가져온 데이터';\n        resolve(data);\n      }, 1000);\n    });\n  }\n}\n```\n\n이제 `spyOn`을 사용하여 `DataService`의 유닛 테스트를 작성해보겠습니다:\n\n```js\nimport { TestBed } from '@angular/core/testing';\nimport { DataService } from './data.service';\n\ndescribe('DataService', () => {\n  let service: DataService;\n  beforeEach(() => {\n    TestBed.configureTestingModule({});\n    service = TestBed.inject(DataService);\n  });\n  it('API에서 데이터를 가져와야 함', () => {\n    const apiResponse = '모킹된 API 응답';\n    spyOn(service, 'fetchData').and.returnValue(Promise.resolve(apiResponse));\n    service.fetchData().then((data) => {\n      expect(data).toBe(apiResponse);\n      expect(service.fetchData).toHaveBeenCalled();\n    });\n  });\n}\n```\n\n위의 테스트에서, `spyOn` 함수를 사용하여 `DataService`의 `fetchData` 메서드에 스파이를 생성합니다. `and.returnValue` 메서드를 사용하여 스파이의 반환 값을 지정합니다. 이 값은 모킹된 API 응답이 포함된 해결된 프로미스입니다.\n\n<div class=\"content-ad\"></div>\n\n그런 다음 `fetchData` 메서드를 호출하고 반환된 데이터가 모의 API 응답과 일치하는지 `expect` 함수를 사용하여 확인합니다. 또한 `toHaveBeenCalled` matcher를 사용하여 `fetchData` 메서드가 호출된 것을 확인합니다.\n\n`spyOn`을 사용하면 `fetchData` 메서드의 원래 구현을 모의 구현으로 대체하고 테스트 중에 그 동작을 제어할 수 있습니다. 이를 통해 서비스를 격리시키고 실제 API 호출을 하지 않고 상호작용을 테스트하는 데 집중할 수 있습니다.\n\n테스트 파일에서 적절한 패키지(`@angular/core/testing`, `jasmine`, 등)에서 필요한 테스트 유틸리티(`TestBed`, `spyOn` 등)를 가져와야 합니다.\n\n참고: `spyOn`은 Angular에 특정한 것이 아니라 Angular 단위 테스트에서 일반적으로 사용되는 Jasmine 테스팅 프레임워크의 일부입니다.\n\n<div class=\"content-ad\"></div>\n\n75. Angular에서 HTTP 요청을 모킹하는 방법\n\nAngular 단위 테스트에서 HTTP 요청을 모킹하려면 Angular의 테스트 유틸리티에서 제공하는 `HttpClientTestingModule`과 `HttpTestingController`를 사용할 수 있습니다.\n\n## 다음은 Angular에서 HTTP 요청을 모킹하는 방법을 보여주는 예시입니다:\n\n가정해보겠습니다. Angular의 `HttpClient`를 사용하여 HTTP 요청을 하는 `DataService`라는 서비스가 있다고 가정해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable()\nexport class DataService {\n  constructor(private http: HttpClient) {}\n  fetchData(): Promise<string> {\n    return this.http.get<string>('https://api.example.com/data').toPromise();\n  }\n}\n```\n\n이제 `DataService`에 대한 단위 테스트를 작성하고 HTTP 요청을 모의(mock)해 봅시다:\n\n```js\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { DataService } from './data.service';\n\ndescribe('DataService', () => {\n  let service: DataService;\n  let httpMock: HttpTestingController;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [DataService]\n    });\n    service = TestBed.inject(DataService);\n    httpMock = TestBed.inject(HttpTestingController);\n  });\n  afterEach(() => {\n    httpMock.verify();\n  });\n  \n it('API에서 데이터를 가져와야 합니다', () => {\n    const mockResponse = '모의 API 응답';\n    service.fetchData().then((data) => {\n      expect(data).toBe(mockResponse);\n    });\n    const req = httpMock.expectOne('https://api.example.com/data');\n    expect(req.request.method).toBe('GET');\n    req.flush(mockResponse);\n  });\n});\n```\n\n위의 테스트에서는 `HttpClientTestingModule`을 가져오고 `TestBed.configureTestingModule()`에서 사용하여 테스트 모듈을 구성했습니다. 또한 `HttpTestingController`를 주입하여 HTTP 요청과 상호 작용합니다.\n\n\n<div class=\"content-ad\"></div>\n\n테스트 내부에서는 `DataService`의 `fetchData` 메서드를 호출하고 응답 데이터를 확인합니다. 그런 다음, `httpMock.expectOne()`을 사용하여 HTTP 요청을 가로채고 `req.flush()`를 사용하여 목 응답을 반환합니다. 마지막으로, `afterEach` 블록에서 `httpMock.verify()`를 사용하여 예기치 않은 요청이 없는지 확인합니다.\n\n결론:\n\n`HttpClientTestingModule`과 `HttpTestingController`를 사용하면 HTTP 요청을 모방하고 응답을 제어하여 실제 API 호출 없이 서비스의 동작을 테스트할 수 있습니다. 참고: 테스트 파일에서 적절한 패키지(`@angular/core/testing`, `@angular/common/http/testing` 등)에서 필요한 테스트 유틸리티(`TestBed`, `HttpClientTestingModule`, `HttpTestingController` 등)를 가져와야 합니다.\n\n76. RxJS에서 'from'과 'of' 연산자 간의 차이점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nRxJS에서는 `from` 및 `of` 연산자를 사용하여 다양한 데이터 원본에서 옵저버블을 생성합니다. 비슷해 보일 수 있지만, 이 둘 사이에 근본적인 차이가 있습니다:\n\n- `from`: `from` 연산자는 배열 형태, 이터러블 또는 프로미스 기반 데이터 원본에서 옵저버블을 생성하는 데 사용됩니다. 이는 원본의 각 항목을 하나씩 방출합니다.\n\n```js\nimport { from } from 'rxjs';\n\nconst arraySource = from([1, 2, 3, 4, 5]);\n// 방출: 1, 2, 3, 4, 5\n\nconst stringSource = from('Hello');\n// 방출: 'H', 'e', 'l', 'l', 'o'\n\nconst promiseSource = from(fetch('https://api.example.com/data'));\n// 프로미스의 해결된 값 방출\n```\n\n`from` 연산자는 배열 또는 이터러블과 같은 항목의 컬렉션이 있고 각 항목을 순차적으로 방출하고자 할 때 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n2. `of`: `of` 연산자는 값의 시퀀스를 방출하는 옵저버블을 생성하는 데 사용됩니다. 제공된 모든 값을 즉시 방출합니다.\n\n```js\nimport { of } from 'rxjs';\n\nconst source = of(1, 2, 3, 4, 5);\n// 방출: 1, 2, 3, 4, 5\n```\n\n`of` 연산자는 비동기 작업이나 반복이 필요하지 않고 즉시 여러 값을 방출하는 옵저버블을 만들고 싶을 때 유용합니다.\n\n결론:\n\n<div class=\"content-ad\"></div>\n\n요약하면 `from`과 `of`의 주요 차이점은 그들이 처리할 수 있는 데이터 소스의 유형과 값의 방출 방식에 있습니다. `from`은 배열과 유사한 iterable 또는 promise 기반 데이터 소스에 사용되며, 값들을 하나씩 방출합니다. `of`는 즉시 값 시퀀스를 방출하는 데 사용됩니다.\n\nRxJS에서 reduce 연산자란 무엇인가요?\n\nRxJS에서 reduce 연산자는 observable 시퀀스에서 발생한 값에 누적 함수를 적용하고 한 번 누적된 결과를 발행하는 데 사용됩니다. JavaScript의 Array.prototype.reduce() 함수와 유사합니다.\n\nreduce 연산자는 누적 함수와 선택적 초기값을 매개변수로 취합니다. 누적 함수는 소스 observable에서 발행된 각 값에 대해 호출되며, 직전 누적 값을 기반으로 중간 결과를 누적하고 소스의 현재 값에 따라 계산합니다. 누적된 값은 소스 observable이 완료될 때 최종 결과로 발행됩니다.\n\n<div class=\"content-ad\"></div>\n\n여기 reduce 연산자의 일반적인 구문입니다:\n\n```js\nconst $reduceOperator = from([1,2,3,4]).pipe(\n      reduce((sum,num) => {\n        return sum+num;\n      })\n    );\n\n$reduceOperator.subscribe(data=> {\n      console.log('reduce operator data', data); \n    })\n// 출력\n// reduce operator data 10\n```\n\n참고: reduce 연산자에서는 중간 결과가 발행되지 않고 마지막 결과만 발행되며, scan 연산자에서는 중간 결과가 발행됩니다.\n\n결론:\n\n<div class=\"content-ad\"></div>\n\nreduce 연산자는 값의 시퀀스에서 단일 누적 결과를 얻고 싶을 때 유용합니다. 값들을 합하거나 최대값 또는 최소값을 찾는 등 최종 결과를 생성하는 계산에 일반적으로 사용됩니다. 또는 방출된 값들에 대한 기타 축소 작업을 수행할 때도 사용됩니다.\n\n앵귤러에서 `trackBy`는 무엇에 사용되나요?\n\n앵귤러에서 `trackBy` 함수는 `ngFor` 지시문과 함께 사용되어 항목 목록을 렌더링할 때 성능을 향상시키는 데 사용됩니다. `trackBy` 함수를 제공하면 Angular가 목록 내 개별 항목을 추적하고 업데이트할 수 있어 변경이 발생할 때 목록 전체를 다시 렌더링하는 대신 개별 항목을 업데이트할 수 있습니다.\n\n`trackBy` 함수는 두 개의 인수를 받습니다: 목록 내 항목의 인덱스와 항목 자체입니다. 각 항목에 대해 고유 식별자를 반환해야 합니다. Angular는 이 식별자를 사용하여 항목을 추적하고 목록 내에서 변경되었거나 이동되었는지 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 `ngFor` 루프에서 `trackBy`를 사용하는 예시입니다:\n\n```js\n<!-- my-component.component.html -->\n<ul>\n  <li *ngfor=\"let item of items; trackBy: trackByFn\">{ item.name }</li>\n</ul>\n```\n\n```js\n// my-component.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent {\n  items = [\n    { id: 1, name: 'Item 1' },\n    { id: 2, name: 'Item 2' },\n    { id: 3, name: 'Item 3' }\n  ];\n  \n  trackByFn(index: number, item: any): number {\n    return item.id; // 각 항목의 고유 식별자\n  }\n}\n```\n\n이 예시에서 `trackByFn` 함수는 각 항목의 `id` 속성을 고유 식별자로 반환합니다. Angular는 이 식별자를 사용하여 항목을 추적하고 변화가 발생할 때 효율적으로 DOM을 업데이트합니다.\n\n<div class=\"content-ad\"></div>\n\n`trackBy`를 사용하면 Angular가 항목이 추가, 제거 또는 이동될 때 전체 목록을 다시 렌더링하거나 업데이트하지 않습니다. 대신 변경된 특정 항목만 업데이트하여 성능을 향상시키고 대량 목록을 처리할 때 더 부드러운 사용자 경험을 제공합니다.\n\n참고:\n\n`trackBy` 함수가 반환하는 고유 식별자는 각 항목에 대해 안정적으로 유지되어야 합니다. 항목이 업데이트될 때 식별자가 변경된다면 Angular는 해당 항목을 새 항목으로 처리하고 다시 렌더링합니다. 따라서, 항목의 수명 동안 변경되지 않는 식별자를 사용하는 것이 좋습니다, 예를 들어 데이터 원본에서 가져온 고유 ID와 같은 식별자를 사용하는 것이 좋습니다.","ogImage":{"url":"/assets/img/2024-05-20-Top90AngularInterviewQuestionsAndAnswersfor2024_0.png"},"coverImage":"/assets/img/2024-05-20-Top90AngularInterviewQuestionsAndAnswersfor2024_0.png","tag":["Tech"],"readingTime":151},{"title":"Angular를 사용하여 단일 SPA로 마이크로 프론트엔드를 만드는 방법","description":"","date":"2024-05-20 22:23","slug":"2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA","content":"\n\nANGULAR 17을 사용한 마이크로프론트엔드 애플리케이션 (독립형).\n\nSingle SPA는 마이크로프론트엔드(MF) 애플리케이션을 만드는 데 도움이 되는 JavaScript 라이브러리입니다. (node.js v18. 13 또는 그 이상)\n\n# Single SPA를 사용하여 Angular 마이크로프론트엔드를 생성하는 방법은?\n\n시작하기 전에 single SPA CLI를 글로벌로 설치해야 합니다. —\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm i -g create-single-spa\n```\n\n설치가 완료되면 첫 번째 마이크로 프론트엔드를 만들 준비가 된 것입니다. JavaScript 라이브러리 중에 사용할 수 있는 MFs 를 만들 수 있습니다. 그러나 여기서는 Angular MFs 를 만들 것입니다. 터미널에서 다음 명령어를 입력하세요.\n\n```js\ncreate-single-spa\n```\n\n싱글 스파 프로젝트를 생성하기 위해 아래 데이터를 요청합니다.\n\n<div class=\"content-ad\"></div>\n\n새 프로젝트의 디렉토리 (.): testProject\n\n생성할 유형 선택: 프로젝트를 처음 생성하기 때문에 목록에서 single-spa 루트 구성 옵션을 선택해야 합니다.\n\n어떤 패키지 매니저를 사용하시겠습니까?: Angular 프로젝트를 생성하고 npm 패키지를 사용하므로 매니저로 npm을 선택해야 합니다.\n\n이 프로젝트에서 TypeScript를 사용합니까? (y/N): 당연히 yes\n\n<div class=\"content-ad\"></div>\n\n`프로젝트를 시작할 때 single-spa 레이아웃 엔진을 사용하시겠습니까? (Y/n) -` single-spa 레이아웃 엔진을 사용하려면 Y를 선택하세요. 그렇지 않다면 N을 입력하세요.\n\n`조직 이름 (영문자, 숫자, 대시 또는 언더바 사용 가능) -` 조직 이름을 입력해주세요. 아무 이름이나 상관 없습니다. 루트 구성이 생성 중이며 완료되면 루트 디렉토리에서 npm install을 입력하고 npm start를 실행해주세요.\n\n프로젝트 실행 정보는 터미널 화면에 나타납니다. 대부분의 경우 9000 포트에서 실행되므로 브라우저에서 http://localhost:9000/을 열어서 확인해주세요. 화면에 다음과 같은 내용이 표시됩니다.\n\n![이미지](/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_0.png)\n\n<div class=\"content-ad\"></div>\n\n축하합니다! 앱 루트가 잘 작동하고 있어요. 다음 단계는 Angular MFs를 만드는 것입니다.\n\n만들어진 디렉토리로 이동해서 다음 단계를 따르세요. Angular 앱을 만들기 위해서는 루트 구성 생성 시 묻는 몇 군데의 옵션을 변경해야 합니다.\n\n마이크로프론트엔드를 생성하려면 새 터미널을 열고 아래 명령어를 실행하세요.\n\n```js\ncreate-single-spa\n```\n\n<div class=\"content-ad\"></div>\n\n아래 제공된 단계를 따라주세요.\n\n```js\n? 새 프로젝트를 위한 디렉토리를 지정하세요.\n? 단일-SPA 애플리케이션 / 패럴 생성 유형을 선택하세요.\n? 어떤 프레임워크를 사용하시겠습니까? angular\n? 프로젝트 이름 (문자, 숫자, 대시 또는 밑줄 사용 가능) login\n? 어떤 스타일시트 포맷을 사용하시겠습니까? Sass (SCSS)     [https://sass-lang.com/documentation/syntax#scss]\n? 서버 측 렌더링 (SSR) 및 정적 사이트 생성(SSG/프리랜더링)을 활성화하시겠습니까? \n아니요\n```\n\n성공적으로 실행되면, 뼈대 파일이 생성될 것입니다. 그런 다음\n\n앵귤러의 분석 활성화 여부를 물을 것입니다. (귀하는 요구에 따라 선택하십시오)\n\n<div class=\"content-ad\"></div>\n\n```js\n? 이 프로젝트에 대한 익명의 사용 데이터를 구글의 개인정보 보호 정책인 Google의 개인정보 처리방침에 따라 구글 Angular 팀과 공유하시겠습니까? 자세한 내용 및 이 설정을 변경하는 방법은 https://angular.io/analytics를 참조하십시오. 예\n```\n\n그런 다음 single-spa-angular가 설치됩니다.\n\n```js\nsingle-spa-angular@9.1.2 패키지가 설치되고 실행됩니다.\n계속 진행하시겠습니까? 예\n```\n\n그런 다음 라우팅 및 포트를 요청합니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n? Does your application use Angular routing? Yes\n? What port should your project run on? 4200\n```\n\n다음 단계는 기능을 활성화하는 것입니다 —\n\n단계 -1 → 루트 디렉토리 내의 src/index.ejs 파일을 열어 앱이 호스팅된 위치를 import 맵 내에 추가합니다. 현재는 로컬 호스트이지만 앞으로는 배포된 서버 위치가 될 것입니다.\n\n![How to create an angular micro frontend using single SPA](/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_1.png)\n\n\n<div class=\"content-ad\"></div>\n\nStep-2 → Angular 앱을 실행하려면 index.ejs 파일에서 아래 이미지에 표시된 대로 zone 스크립트를 활성화해야 합니다.\n\n![Zone Script](/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_2.png)\n\nStep -3 → microfrontend-layout.html 파일을 열고 다음 사항을 변경하세요 -\n\nroute 태그 내부에 새로 생성한 MF의 경로를 라우트 경로로 추가하세요 —\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_3.png)\n\nStep -4 → login 폴더 내 angular.json 파일에서 다음 변경 사항을 수행합니다.\n\n![image](/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_4.png)\n\nStep -5 → login/src/main.single-spa.ts로 이동하여 라이프사이클이 AppModule와 구성되어 있는 것을 볼 수 있지만, Angular 17에서는 더 이상 AppModule을 사용하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_5.png)\n\n그래서 아래 필요한 변경사항을 처리해야 합니다.\n\n- 일단 환경 파일을 제거하고 프로덕션을 활성화하는 조건을 제거합니다. (만약 프로덕션, 개발 및 스테이징을 위해 환경이 필요하다면, login/src/environment에 환경 파일을 생성하고 환경 설정을 해 주세요.)\n- AppModule 대신에 AppComponent와 몇 가지 프로바이더 구성을 사용할 것입니다.\n\n![image](/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_6.png)\n\n<div class=\"content-ad\"></div>\n\n최종 단계 -\n\n이제 새로 생성된 앱 터미널에 다음 명령어를 입력해 주세요 —\n\n```js\nnpm run serve:single-spa:login\n```\n\n만약 오류가 발생한다면 npm i를 입력한 뒤 위 명령어를 실행해 주세요.\n\n<div class=\"content-ad\"></div>\n\n지금 브라우저를 열고 microfrontend-layout.html 파일에서 언급된 URL 경로를 변경해주세요. (저희 경우에는 루트 파일의 경우 http://localhost:9000 및 로그인 페이지의 경우 http://localhost:9000/login을 엽니다).\n\n![이미지](/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_7.png)\n\n다시 한번 축하드립니다. Angular 17에서 MF를 성공적으로 생성하였으며 스탠드얼론 애플리케이션에서도 작동 중입니다.","ogImage":{"url":"/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_0.png"},"coverImage":"/assets/img/2024-05-20-HowtocreateanangularmicrofrontendsusingsingleSPA_0.png","tag":["Tech"],"readingTime":5}],"page":"65","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}