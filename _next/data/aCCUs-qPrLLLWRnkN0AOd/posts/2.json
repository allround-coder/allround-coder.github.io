{"pageProps":{"posts":[{"title":"iOS 앱을 위한 맞춤형 푸시 알림 레이아웃 만들기 방법","description":"","date":"2024-07-01 17:06","slug":"2024-07-01-BuildacustomPushNotificationlayoutforiOSApps","content":"\n\n## 푸시 알림을위한 사용자 정의 레이아웃을 만드는 방법에 대한 빠르고 쉬운 안내서입니다. NotificationExtendedContent를 사용하세요.\n\n![Push Notification Layout](/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_0.png)\n\n## 소개\n\n푸시 알림은 매우 유용합니다. 우리 모두가 알고 있고, 2009년에 출시된 이후로 이 기능을 광범위하게 사용해 왔습니다.\n몇 년 동안 알림은 여러 가지 방법으로 개선되어 왔으며, 이제는 푸시 알림 레이아웃의 더 풍부한 버전을 구현할 수 있습니다. 이를 위해 Notification Content Extension을 사용할 것입니다.\n이 유형의 알림은 사용자 지정 레이아웃을 즉시 표시하지 않으며, 사용자가 알림을 길게 누르면 새 레이아웃이 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:640/1*ZbjLnYTAZtthoD0Y2FzxuA.gif\" />\n\n이 기사에서는 GitHub에서 샘플 프로젝트를 찾을 수 있는 작은 저장소를 만들었습니다.\n\n## 시작하는 방법\n\n알림에 대해 이야기하고 있기 때문에 먼저 프로젝트에 필요한 기능을 추가해야 합니다. 프로젝트의 주요 대상의 Signing & Capabilities 탭으로 이동하여 Push Notifications 기능을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지1](/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_1.png)\n\n유저에게 푸시 알림을 보여주기 위해 권한을 요청해야 합니다. 이를 프로젝트의 App 파일에서 처리할 수 있습니다.\n\n프로젝트에 푸시 알림 컨텐츠 익스텐션을 위한 필요한 파일들을 추가해야 합니다. 이를 위해 올바른 타겟을 추가해야 하니, File - New - Target을 선택해주세요.\n\n![이미지2](/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n여기서 Notification Content Extension을 검색하고 새 대상에 이름을 적어주세요.\n\n작업을 마치면 새 스키마를 Xcode에서 제안하는 대로 활성화시키기만 하면 됩니다. \n이제 프로젝트에서 우리가 반짝이는 새 알림을 만들기 위해 필요한 모든 파일이 포함된 새 대상을 볼 수 있어야 합니다.\n\n![이미지](/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_3.png)\n\n각 파일이 어떤 역할을 하는지 이해하기 쉽지만 꼼꼼하게 살펴봅시다:\n\n<div class=\"content-ad\"></div>\n\n**알림 뷰 컨트롤러**\n\n이 클래스는 알림 레이아웃의 로직과 이행을 책임지는 단순하고 명확한 역할을 합니다.\n뷰 컨트롤러는 didReceive(_ notification:) 함수에서 현재 수신한 푸시 알림(그리고 그 안의 페이로드)을 가져와 데이터를 우리가 필요한 대로 사용할 것입니다.\n\n**주요 인터페이스**\n\n<img src=\"/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n여기에서는 새로운 유형의 알림이 표시될 레이아웃을 찾을 수 있습니다. 이것은 UIKit 스토리보드이며 여기에 설정할 제약 조건에 대해 매우 주의해야 합니다. 왜냐하면 무언가 잘못되면 알림이 완전히 비어 보일 수 있습니다.\n\nINFO.PLIST\n\n![image](/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_5.png)\n\n이것은 우리의 NotificationContentExtension의 유용한 속성을 추가할 수 있는 클래식한 Info.plist입니다. 생성될 때 기본값이 이미 포함되어 있으며 각각은 특정한 용도가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- NSExtensionMainStoryboard: 레이아웃에 사용되는 스토리보드 이름만 정의하는 것이에요. 우리 경우에는 MainInterface입니다.\n- NSExtensionPointIdentifier: Apple stuff은 우리에겐 유용하지 않아요.\n- UNNotificationExtensionCategory: 이는 우리의 알림 콘텐츠 익스텐션의 사용자 정의 식별자로, 이 알림 레이아웃을 일반적인 것 대신에 언제 보여줄지 앱이 이해할 수 있게 하는 목적이에요. 푸시 알림 페이로드를 빌드할 때 백엔드 서비스에서 사용해야 해요.\n- UNNotificationExtensionInitialContentSizeRatio: 이는 기기에 초기에 표시될 때 사용자 정의 알림 인터페이스의 가로 세로 비율 소수값이에요. 값이 1이면 높이와 너비가 동일하고, 0.5이면 높이가 너비의 반 정도 됩니다. \"초기에 표시될 때\" 라고 써 놓은 이유는 사용자 지정 알림 레이아웃이 표시된 후에는 제약에 따라 자동으로 크기가 조정될 것이기 때문이에요. 이것을 컨텐츠에 따라 실제로 완전히 로드되고 표시되기 전에 보고 있는 알림의 가로 세로 비율로 생각해보세요. \n(참고: 시뮬레이터에서는 이를 알아차리지 못할 것입니다. 적어도 제가 테스트를 진행한 동안에는, 기기에서만 차이를 볼 수 있었어요)\n\n기본 키-값 쌍 외에도 몇 가지 더 추가할 수 있는 다른 것들이 있어요. 그러니 함께 해봅시다:\n\n![customPushNotificationLayout](/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_6.png)\n\n- UNNotificationExtensionUserInteractionEnabled: 이는 실제로 알림 UI 요소가 사용자와 상호작용할 수 있는지 여부를 정의하는 쌍이에요. \n  - 값이 NO인 경우, 푸시 알림의 어느 부분을 눌러도 앱이 열리고 푸시 알림을 누를 때 사용되는 기본 델리게이트 메소드가 호출될 뿐이에요.\n  - 값이 YES인 경우, 사용자는 UI 요소(예: 버튼)와 상호작용할 수 있지만, 앱을 열 수 있는 방법은 없습니다. 심지어 상호작용이 없는 UI 요소를 누르는 것도 앱을 열 수 없어요.\n- UNNotificationExtensionUserContentHidden: 이는 표준 푸시 알림 UI를 사용자 정의 레이아웃 위에 표시할지 여부를 정의하는 데 사용되어요. ​​예시에서 보이는 것처럼요.\n\n<div class=\"content-ad\"></div>\n\n레이아웃은 숨겨지지 않은 콘텐츠의 경우, 잘 표시되도록 몇 가지 조정이 필요할 수 있음을 유의해야 합니다.\n\n## 알림 페이로드\n\n푸시 알림의 페이로드에는 내부에 \"category\" 요소를 가져야 하며, 이를 \"aps\" 필드 내부에 배치해야 합니다. 여기서는 콘텐츠 익스텐션 대상 Info.plist에 설정한 UNNotificationExtensionCategory 값을 명시해야 합니다.\n\n```js\n{\n  \"aps\": {\n      \"category\": \"customNotificationIdentifier\",\n      \"alert\" : {\n            \"title\" : \"EXTENDED NOTIFICATION\",\n            \"subtitle\" : \"Subtitle of the push payload\",\n            \"body\" : \"This is the text inside the body of the payload. This is displayed below the subtitle and above the footer.\"\n      },\n      \"footer\": \"Footnote inside the push payload\",\n      \"firstButton\": \"Main Button\",\n      \"secondButton\": \"Secondary Button\",\n      \"imageUrl\": \"https://raw.githubusercontent.com/MarkWarriors/MGExtendedNotifications/main/mount_fuji.jpg\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n남은 페이로드는 당연히 당신의 요구에 맞게 사용자 정의할 수 있습니다. 이 경우에는 우리의 사용자 정의 레이아웃에서 무엇을 할 수 있는지 보여주기 위해 다양한 사용자 정의 필드를 추가했습니다.\n\n## 알림 레이아웃 만들기\n\n이제 실제로 푸시 알림 사용자 정의 레이아웃을 만드는 시간입니다. 이 예제에서는 레이블, 버튼 및 이미지 뷰를 추가했습니다.\n\n![이미지](/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_7.png)\n\n<div class=\"content-ad\"></div>\n\nNotificationViewController에서는 당연히 UI 요소의 모든 참조를 만들고 버튼용 탭 제스처 인식기를 구현했어요.\n\n이제 푸시 알림 페이로드에서 다양한 정보를 올바른 UI 요소에 바인딩합시다.\n\ndidReceive(_ notification:)에서 모든 매개변수를 매핑했음을 볼 수 있어요. 푸시 알림의 기본 속성(제목, 부제목, 본문)은 notification.request.content 개체에서 가져오며, 페이로드의 모든 사용자 정의 매개변수는 notification.request.content.userInfo[\"aps\"] 사전에 포함되어 있습니다. 페이로드 구조를 반영하고 있어요.\n\nimageView의 경우 loadImage(withUrl:)이라는 사용자 정의 함수를 사용하는 것을 볼 수 있고, 이미지를 URL에서로드할 것이에요. 이를 위해 UIImageView 확장에 이 메서드를 추가했어요.\n\n<div class=\"content-ad\"></div>\n\n그럼요, 페이로드를 UI에 매핑했어요. 이제 결과를 확인해볼 시간입니다.\n\n## 알림 테스트\n\n이제 모든 설정이 완료되었으니, 알림을 테스트하기만 하면 됩니다. 가장 좋은 방법은 시뮬레이터와 Mac 터미널을 사용하는 것입니다. 먼저, 푸시 알림을 위한 올바른 JSON 페이로드를 만들어 파일로 저장하세요. 위에서 사용한 것과 같은 형식입니다:\n\n```js\n{\n  \"aps\": {\n      \"category\": \"customNotificationIdentifier\",\n      \"alert\" : {\n            \"title\" : \"EXTENDED NOTIFICATION\",\n            \"subtitle\" : \"푸시 페이로드의 부제목\",\n            \"body\" : \"페이로드의 본문 안의 텍스트입니다. 이는 부제목 아래에 표시되며 푸터 위에 표시됩니다.\"\n      },\n      \"footer\": \"푸시 페이로드 내 푸터\",\n      \"firstButton\": \"주 버튼\",\n      \"secondButton\": \"보조 버튼\",\n      \"imageUrl\": \"https://raw.githubusercontent.com/MarkWarriors/MGExtendedNotifications/main/mount_fuji.jpg\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n터미널을 열어서 다음 명령어를 입력해주세요\n\n\npush booted $'YOUR_APP_BUNDLE_IDENTIFIER' $'PATH_TO_YOUR_PAYLOAD_FILE'\n\n\n예를 들어,\n\n\npush booted com.medium.myProject /Users/MyProject/payload.json\n\n\n<div class=\"content-ad\"></div>\n\n만약 제대로 작업을 했다면, 시뮬레이터에서 알림이 나타날 것입니다\n\n![Notification](/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_8.png)\n\n그리고 알림을 길게 누르면 확장되어 사용자 정의 레이아웃이 표시됩니다\n\n![Custom Layout](https://miro.medium.com/v2/resize:fit:640/1*Du9uBOmOM_YAN1MVaORlRw.gif)\n\n<div class=\"content-ad\"></div>\n\n이제 제가 언급한 대로 작업을 했고 Info.plist 파일에서 키-값 속성 UNNotificationExtensionUserInteractionEnabled을 YES로 설정했다면, 알림 내부의 버튼과 상호 작용할 수 있어야 합니다. 그러나 다른 곳을 탭하여 앱을 열 수 있는 방법이 없다는 것을 알 수 있을 거예요.\n\n![image](https://miro.medium.com/v2/resize:fit:640/1*yQlzTlTu7LyR4NuBsGvNyA.gif)\n\n물론 값이 NO로 설정된 경우, 알림의 모든 부분을 탭하면 기대한 대로 앱이 열릴 것입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:640/1*qZXP5DIua2MrnzERDOtENA.gif)\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 푸시 알림을 위한 사용자 정의 레이아웃을 만들었어요.","ogImage":{"url":"/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_0.png"},"coverImage":"/assets/img/2024-07-01-BuildacustomPushNotificationlayoutforiOSApps_0.png","tag":["Tech"],"readingTime":7},{"title":"Objective-C 프로젝트에 SwiftUI 통합 두 가지 효과적인 방법","description":"","date":"2024-07-01 17:05","slug":"2024-07-01-IntegratingSwiftUIintoObjective-CProjectsTwoEffectiveApproaches","content":"\n\n\n![2024-07-01-IntegratingSwiftUIintoObjective-CProjectsTwoEffectiveApproaches_0](/assets/img/2024-07-01-IntegratingSwiftUIintoObjective-CProjectsTwoEffectiveApproaches_0.png)\n\niOS 개발이 계속 진화함에 따라 SwiftUI는 강력하고 직관적인 프레임워크로 사용자 인터페이스를 구축하는 데 사용되어 왔습니다. 선언적 구문과 Swift와의 원활한 통합을 통해 새로운 프로젝트에 이 프레임워크를 선택하는 것이 좋습니다. 그러나 많은 개발자들은 Objective-C로 작성된 기존 코드베이스를 유지하고 향상시키고자 합니다. SwiftUI를 이러한 프로젝트에 통합하면 완전히 다시 작성하지 않고도 현대적인 UI 디자인과 향상된 성능을 제공할 수 있습니다.\n\n![2024-07-01-IntegratingSwiftUIintoObjective-CProjectsTwoEffectiveApproaches_1](/assets/img/2024-07-01-IntegratingSwiftUIintoObjective-CProjectsTwoEffectiveApproaches_1.png)\n\n본 문서에서는 Objective-C 프로젝트에 SwiftUI 뷰를 통합하는 두 가지 효과적인 방법을 탐구할 것입니다: UIHostingController를 직접 사용하는 방법과 SwiftUI 래퍼를 만드는 방법. 하나의 SwiftUI 뷰를 추가하거나 전체 UI를 점진적으로 이전하려는 경우, 이러한 방법을 통해 최상의 결과를 얻을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 방법 1: UIHostingController 직접 사용하기\n\nUIHostingController은 SwiftUI와 UIKit 간의 다리 역할을 수행하여 SwiftUI 뷰를 UIKit 뷰 컨트롤러 내에서 호스팅할 수 있게 해줍니다. 이렇게 하면 됩니다.\n\n## 단계 1: SwiftUI View 만들기\n\n먼저 Swift 파일에서 SwiftUI 뷰를 정의하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport SwiftUI\n\nstruct MySwiftUIView: View {\n    var body: some View {\n        Text(\"안녕 SwiftUI!\")\n            .padding()\n    }\n}\n```\n\n## 단계 2: SwiftUI 뷰 컨트롤러 생성\n\nUIHostingController를 사용하여 SwiftUI 뷰를 호스팅하는 Swift 뷰 컨트롤러를 생성하세요.\n\n```js\nimport SwiftUI\nimport UIKit\n\nclass MySwiftUIViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let swiftUIView = MySwiftUIView()\n        let hostingController = UIHostingController(rootView: swiftUIView)\n        \n        addChild(hostingController)\n        view.addSubview(hostingController.view)\n        \n        hostingController.view.translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            hostingController.view.leadingAnchor.constraint(equalTo: view.leadingAnchor),\n            hostingController.view.trailingAnchor.constraint(equalTo: view.trailingAnchor),\n            hostingController.view.topAnchor.constraint(equalTo: view.topAnchor),\n            hostingController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)\n        ])\n        \n        hostingController.didMove(toParent: self)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: 스위프트 뷰 컨트롤러를 Objective-C에 노출시키기\n\n스위프트 클래스를 Objective-C에서 볼 수 있도록 하려면, 브리징 헤더를 만들어야 합니다.\n\n- 'YourProjectName-Bridging-Header.h'라는 브리징 헤더 파일을 생성합니다. (예: 프로젝트명이 HelloWorld인 경우, 브리징 헤더 파일명은 HelloWorld-Bridging-Header.h이어야 합니다.)\n- 스위프트 생성 헤더를 import하도록 import 문을 추가합니다.\n\n```js\n// YourProjectName-Bridging-Header.h\n#import \"YourProjectName-Swift.h\"\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 4: Objective-C에서 Swift 뷰 컨트롤러 사용하기\n\n이제 Objective-C 코드에서 Swift 뷰 컨트롤러를 인스턴스화하고 사용할 수 있습니다.\n\n```js\n// Objective-C ViewController\n#import \"YourProjectName-Bridging-Header.h\"\n#import \"YourProjectName-Swift.h\"\n\n@interface YourObjectiveCViewController ()\n@end\n\n@implementation YourObjectiveCViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    MySwiftUIViewController *swiftUIViewController = [[MySwiftUIViewController alloc] init];\n    [self addChildViewController:swiftUIViewController];\n    [self.view addSubview:swiftUIViewController.view];\n    \n    swiftUIViewController.view.frame = self.view.bounds;\n    [swiftUIViewController didMoveToParentViewController:self];\n}\n\n@end\n```\n\n# 방법 2: SwiftUI 래퍼 사용하기\n\n<div class=\"content-ad\"></div>\n\n이 방법은 SwiftUI 뷰를 래핑하는 Swift 클래스를 생성하여 관리하고 재사용하기 쉽게 만드는 것을 포함합니다.\n\n## 단계 1: SwiftUI 뷰 생성하기\n\nSwift 파일에서 SwiftUI 뷰를 정의하세요. 이전과 같습니다.\n\n## 단계 2: SwiftUI Wrapper 생성하기\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\nimport UIKit\n\n@objc public class SwiftUIWrapper: NSObject {\n    @objc public func createSwiftUIViewController() -> UIViewController {\n        let swiftUIView = MySwiftUIView()\n        let hostingController = UIHostingController(rootView: swiftUIView)\n        return hostingController\n    }\n}\n```\n\n## Step 3: Make the Wrapper Accessible to Objective-C\n\nEnsure the wrapper class is accessible from Objective-C by adding the appropriate bridging header: Same as before.\n\n\n<div class=\"content-ad\"></div>\n\n- 이미 존재하지 않는 경우 \"YourProjectName-Bridging-Header.h\"라는 브릿징 헤더 파일을 생성하십시오.\n- 다음과 같은 임포트 문을 추가하십시오:\n\n```js\n// YourProjectName-Bridging-Header.h\n#import \"YourProjectName-Swift.h\"\n```\n\n## 단계 4: Objective-C에서 SwiftUI 래퍼 사용하기\n\n이제 Objective-C 코드에서 SwiftUIWrapper 클래스를 사용하여 SwiftUI 뷰를 표시하십시오.\n\n<div class=\"content-ad\"></div>\n\n\n```objc\n// Objective-C ViewController\n#import \"YourProjectName-Bridging-Header.h\"\n#import \"YourProjectName-Swift.h\"\n\n@interface YourObjectiveCViewController ()\n@end\n\n@implementation YourObjectiveCViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    SwiftUIWrapper *swiftUIWrapper = [[SwiftUIWrapper alloc] init];\n    UIViewController *swiftUIViewController = [swiftUIWrapper createSwiftUIViewController];\n    \n    [self addChildViewController:swiftUIViewController];\n    [self.view addSubview:swiftUIViewController.view];\n    \n    swiftUIViewController.view.frame = self.view.bounds;\n    [swiftUIViewController didMoveToParentViewController:self];\n}\n\n@end\n```\n\n## 결론\n\n### UIHostingController 직접 사용의 장단점\n\n장점:\n\n\n<div class=\"content-ad\"></div>\n\n- 단순성: SwiftUI 뷰를 UIKit에 직접 포함시키면 설정 과정이 간단해집니다.\n- 성능: 표준 UIKit 뷰 컨트롤러를 사용하기 때문에 오버헤드가 최소화됩니다.\n- 유연성: 임베드된 SwiftUI 뷰의 라이프사이클을 완전히 제어할 수 있습니다.\n\n단점:\n\n- 보일러플레이트 코드: 제약 조건 설정 및 뷰 계층 구조 관리를 위해 추가 보일러플레이트 코드가 필요합니다.\n- 대규모 프로젝트에서의 복잡성: 여러 UIHostingController 인스턴스를 관리하는 것이 대규모 프로젝트에서는 복잡해질 수 있습니다.\n\n## SwiftUI 래퍼 사용의 장단점\n\n<div class=\"content-ad\"></div>\n\n장점:\n\n- 모듈화: SwiftUI 코드를 별도의 클래스에 캡슐화하여 관리 및 재사용이 쉬워집니다.\n- 깔끔한 통합: Objective-C 뷰 컨트롤러에서의 보일러플레이트 코드를 줄입니다.\n- 확장성: 프로젝트의 다양한 부분에 여러 SwiftUI 뷰를 추가하는 프로세스를 간소화합니다.\n\n단점:\n\n- 추가적인 추상화: 간단한 통합에 필요하지 않을 수 있는 또 다른 추상화 계층을 도입합니다.\n- 학습 곡선: Swift 및 Objective-C 상호 운용성 세부 사항을 모두 이해해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nSwiftUI를 Objective-C 프로젝트에 통합하는 것은 어렵게 느껴질 수 있지만, 올바른 방법을 사용하면 단순해집니다. 이 안내서에서 보여주는 것처럼 UIHostingController를 직접 사용하거나 SwiftUI 래퍼를 만드는 것은 최신 기술을 활용하여 앱을 점진적으로 효율적으로 현대화할 수 있게 해줍니다.","ogImage":{"url":"/assets/img/2024-07-01-IntegratingSwiftUIintoObjective-CProjectsTwoEffectiveApproaches_0.png"},"coverImage":"/assets/img/2024-07-01-IntegratingSwiftUIintoObjective-CProjectsTwoEffectiveApproaches_0.png","tag":["Tech"],"readingTime":7},{"title":"약한 참조 vs 강한 참조 vs 알 수 없는 참조 차이점 비교","description":"","date":"2024-07-01 17:04","slug":"2024-07-01-DifferencesbetweenWeakvsStrongvsUnknownreferences","content":"\n\n<img src=\"/assets/img/2024-07-01-DifferencesbetweenWeakvsStrongvsUnknownreferences_0.png\" />\n\nSwift에서 객체에 대한 참조는 3가지 유형의 참조(weak, strong, unowned)를 사용하여 관리할 수 있습니다. 각각은 다른 목적으로 사용되며 메모리를 관리하여 순환 참조와 같은 문제를 예방하는 데 도움이 됩니다. 각 유형의 내용은 다음과 같습니다:\n\n## Weak References\n\n- 소유권 없음: 약한 참조는 참조하는 객체에 강력한 소유권을 유지하지 않습니다.\n- 옵셔널: 약한 참조는 항상 옵셔널(weak var)입니다. 즉, nil이 될 수 있습니다.\n- 순환 참조 없음: 약한 참조 사용은 객체의 참조 횟수가 증가되지 않도록하여 강한 참조 순환을 방지하는 데 도움이 됩니다.\n- 자동 Nil 할당: 약한 참조가 가리키는 객체가 해제되면, 약한 참조는 자동으로 nil로 설정됩니다.\n- 사용 방법: 약한 참조를 사용하여 강한 참조 순환을 피하십시오. 일반적으로 부모-자식 관계에서 부모가 살아 있어야 하는 경우에는 자식은 부모를 유지하지 않아야 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 강력한 참조\n\n- 기본 참조 유형: Swift에서 참조는 기본적으로 강력합니다.\n- 소유권: 강력한 참조는 해당 객체의 소유자로 계산됩니다.\n- 메모리 관리: 객체에 대한 적어도 하나의 강력한 참조가 있는 한, 해당 객체는 해제되지 않습니다. 새로운 강력한 참조가 생성될 때 객체의 참조 횟수가 증가하고, 강력한 참조가 제거될 때는 감소합니다.\n- 사용: 객체의 소유권을 유지하고 싶을 때 강력한 참조를 사용하세요.\n\n## 무소유 참조\n\n- 소유권 없음: 약한 참조와 유사하게, 무소유 참조는 해당 객체에 강한 보유를 유지하지 않습니다.\n- 옵셔널이 아님: 약한 참조와 달리, 무소유 참조는 옵셔널이 아니며, 액세스되는 한 항상 값을 가질 것으로 예상됩니다.\n- 자동적으로 nil 할당하지 않음: 무소유 참조는 참조하는 객체가 해제될 때 자동으로 nil이 되지 않습니다. 객체가 해제된 후에 액세스하면 런타임 충돌이 발생합니다.\n- 사용: 참조하는 객체가 무소유 참조가 사용 중인 한 해제되지 않을 것이 확실한 경우에 사용하며, 일반적으로 참조하는 객체가 더 긴 수명주기를 가지는 경우에 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n## ARC(자동 참조 계산)는 클래스 인스턴스의 메모리 관리에 어떤 영향을 미치나요?\n\nARC(자동 참조 계산)는 컴파일 시간 기능으로, 코드 내 객체에 대한 참조 횟수를 추적하고 컴파일 시간에 자동으로 메모리 관리 호출을 삽입합니다.\nARC의 주요 장점 중 하나는 반복 순환(메모리 누수로 알려진)을 방지할 수 있는 능력입니다. 두 개 이상의 객체가 서로 강력한 참조를 유지하고 있어서 삭제되지 못하는 반복 순환 문제가 발생하는데, ARC는 약한 참조를 사용하여 이러한 반복 순환을 해결하는 데 도움을 줍니다.\nARC는 컴파일 시간에 정의된 객체의 범위에 따라 retain, release, autorelease 호출을 삽입합니다. 이를 통해 런타임에서 메모리 관리 오버헤드가 최소화됩니다.\n\n## 자동 참조 계산이 어떻게 작동하나요?\n\n새로운 클래스 인스턴스를 만들 때마다, ARC는 해당 인스턴스에 대한 데이터를 저장할 메모리를 할당합니다. 필요 없어지면 해당 인스턴스에 사용된 메모리를 해제하여 메모리를 다른 목적으로 사용할 수 있게 합니다. 클래스의 각 인스턴스에는 참조 횟수라는 속성이 있으므로, 참조 횟수가 0보다 크다면 인스턴스는 여전히 메모리에 유지되고, 그렇지 않으면 메모리에서 제거됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n요약하면, 객체 참조를 관리하는 것은 효율적인 메모리 관리를 위해 중요하며, 메모리 누수와 예기치 않은 충돌을 방지하는 데 결정적입니다. 강한, 약한 및 미소유 참조 사이의 미묘한 차이를 이해하면, 개발자는 객체 관계를 적절히 처리하고 효율적이고 안정적인 코드를 유지할 수 있습니다.\n\n강한 참조는 기본 설정이며, 객체를 소유하여 필요한만큼 메모리에 유지합니다. 그러나 과용 또는 잘못된 사용은 특히 부모-자식 계층 구조 내의 객체 간과 같이 복잡한 관계에서 메모리 누수를 일으킬 수 있는 잠재적인 Cycle을 초래할 수 있습니다.\n\n약한 참조는 특히 한 객체가 다른 객체의 할당 해제를 막아서는 안 되는 경우에 메모리 누수를 방지하기 위한 중요한 도구입니다. 참조 대상 객체가 할당 해제되면 자동으로 nil로 설정되므로 약한 참조를 통해 메모리 누출을 피하고 깨끗한 객체 라이프사이클을 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n소유권이 유지되지 않지만 참조가 사용 중 일 때 항상 유효하다고 예상되는 중간 지점을 제공하는 미소유 참조(unowned references)가 있습니다. 이러한 미소유 참조는 참조된 객체가 미소유 참조가 스코프 내에 있는 한 살아 있음을 보장하는 명확하고 장기적인 소유권 관계가 있는 경우 특히 유용합니다. 그러나 개발자는 조심해야 합니다. 미소유 참조가 할당 해제된 객체에 액세스하면 실행 중에 충돌이 발생할 수 있습니다.\n\n이러한 참조 유형을 숙달하면 견고하고 효율적인 Swift 애플리케이션을 설계하는 능력이 향상됩니다. 특정 사용 사례에 따라 강한 참조(strong), 약한 참조(weak) 및 미소유 참조 중에서 신중하게 선택함으로써 적절한 메모리 관리를 보장하고 일반적인 함정을 피하며 안정적이고 고성능 소프트웨어를 구축할 수 있습니다.\n\n여기까지입니다! 기본 사항을 설명했습니다. 입문자들이 이해하기 쉽도록 최대한 간단하게 유지하려고 노력했습니다. 요점을 이해했으면 좋겠습니다. 추가 질문이 있으시면 아래에 댓글을 달아주시면 도와드리겠습니다.","ogImage":{"url":"/assets/img/2024-07-01-DifferencesbetweenWeakvsStrongvsUnknownreferences_0.png"},"coverImage":"/assets/img/2024-07-01-DifferencesbetweenWeakvsStrongvsUnknownreferences_0.png","tag":["Tech"],"readingTime":3},{"title":"SwiftData 마스터하기 고급 사용 방법 대공개","description":"","date":"2024-07-01 17:02","slug":"2024-07-01-UseSwiftDatalikeaboss","content":"\n\n\n![이미지](/assets/img/2024-07-01-UseSwiftDatalikeaboss_0.png)\n\nSwiftData의 @Query 매크로는 MainActor에서 실행됩니다. 작업 부하가 많은 경우 UI를 블록할 수 있습니다. 한 가지 해결책은 백그라운드 스레드에서 SwiftData 모델을 가져오는 것입니다. 이 문서는 Swift 컴파일러 동시성 경고를 유발하지 않는 빠른 구현을 제공합니다.\n\n# 이 문서의 목적\n\nSwift의 동시성 모델을 이해하는 데는 가파른 학습 곡선이 있습니다. 제 자신의 앱을 구축할 때 성능을 유지하고 반응성을 유지하는 데 어려움을 겪었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![2024-07-01-UseSwiftDatalikeaboss_1.png](/assets/img/2024-07-01-UseSwiftDatalikeaboss_1.png)\n\n가끔은 동작하는 접근 방식을 함께 해킹해 냅니다만, Swift 컴파일러의 엄격한 동시성 검사를 \"완료\"로 설정하는 것에 두려움을 느낍니다.\n\n![2024-07-01-UseSwiftDatalikeaboss_2.png](/assets/img/2024-07-01-UseSwiftDatalikeaboss_2.png)\n\n하지만 무지는 불행함이 아닙니다; 이러한 경고는 앱이 데이터 레이스와 같은 동시성 관련 문제에 취약할 수 있음을 나타냅니다. 미래의 Swift 버전에서 이러한 경고 중 일부는 오류가 될 것입니다. 지금 이를 처리하는 것이 합리적입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 기사 구조\n\n안녕하세요! 저는 대량의 SwiftData 모델을 백그라운드 스레드에서 안전하게 가져올 수 있는 일련의 구성 요소를 구현하는 방법을 보여드릴 거에요. 이 기사에서는 다음 섹션에서 구현 방법을 차례로 소개할 거에요:\n\n- SwiftData 모델;\n- ModelActor;\n- ViewModel 및 View.\n\n전체 프로젝트 코드는 해당 GitHub 저장소에서 찾을 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n만약 코드를 읽고 있어서 \"응, 하지만 처음에 SwiftData 모델을 생성하고 유지하는 방법이 뭐야?\" 라고 궁금해 한다면 걱정하지 마세요. 전체 프로젝트에는 백그라운드 스레드에서 SwiftData 모델을 생성하고 유지하는 코드가 추가로 포함되어 있어서 안전한 방법으로 이루어집니다.\n\n시작하기 전에 두 가지 더 알아두어야 할 점이 있습니다:\n\n(i) 이 글은 SwiftData, Swift actors 및 Sendable 프로토콜에 대한 기본적인 이해를 가정합니다. Swift actors에 대한 훌륭한 설명을 보려면 다음 링크를 확인해주세요:\n\n(ii) 이 글 전반에서 서로 다른 Swift 컴파일러 경고에 언급할 것입니다. 만약 함께 코딩하고 이러한 경고를 직접 확인하고 싶다면 Xcode 프로젝트 설정을 변경해야 합니다: 프로젝트를 선택하고 \"Build Settings\" 탭으로 이동하고 \"concurrency\"를 검색하여 \"Strict Concurrency Checking\"을 \"Complete\"로 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-07-01-UseSwiftDatalikeaboss_3.png)\n\n그럼 시작해볼까요?\n\n# 1. SwiftData 모델\n\n먼저 User라는 SwiftData 모델을 설정합니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// User.swift\nimport Foundation\nimport SwiftData\n\n@Model\nclass User {\n    let id: UUID\n    let name: String\n    \n    init(id: UUID = UUID(), name: String) {\n        self.id = id\n        self.name = name\n    }\n}\n```\n\n저희 목표는 백그라운드 액터에서 이러한 User 모델들을 대량으로 가져오는 것입니다. 즉, 주 스레드를 차단하지 않고 가져와야 하며, 한번 가져오면 이를 메인 액터에 전달하여 앱의 UI를 업데이트해야 합니다. 이를 \"액터 경계를 넘어서는 것\"이라고 합니다 (즉, 한 액터에서 다른 액터로 값 전달).\n\nSwiftData 모델 및 Sendable 프로토콜\n\n타입을 Sendable로 표시하면 Swift 컴파일러에게 그 값이 실행 스레드 간에 안전하게 공유될 수 있음을 알려줍니다. 즉, 이들 값은 MainActor와 백그라운드 액터 사이의 경계를 넘나들 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n그러나 우리는 사용자 값이 액터 경계를 통과하는 것을 원한다는 예상에 따라 클래스를 final로 만들고 단순히 Sendable 프로토콜로 표시하려고 한다면, Xcode에서 다음 경고가 표시됩니다:\n\n<img src=\"/assets/img/2024-07-01-UseSwiftDatalikeaboss_4.png\" />\n\n이것은 @Model 매크로가 주석을 추가하는 클래스에 자동으로 var _id를 추가하기 때문입니다. 변수 저장 속성이 있는 클래스는 Sendable이 될 수 없습니다. 왜냐하면 액터 간에 가변 상태를 공유하면 데이터 레이스가 발생할 수 있기 때문입니다. 어쨌든, 일반적인 규칙은 SwiftData 모델이 Sendable이 아니라는 것입니다. 그러므로 사용자의 값을 액터 경계를 통해 전달하려면 다른 접근 방식이 필요합니다. 이때 데이터 전송 객체(DTO) 클래스가 필요합니다:\n\n```js\n// User.swift\nfinal class UserDTO: Sendable, Identifiable {\n    let id: UUID\n    let name: String\n    \n    init(id: UUID, name: String) {\n        self.id = id\n        self.name = name\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 클래스의 목적은 사용자 모델에서 필요한 데이터를 Actor 경계를 통해 전달하는 것입니다. UserDTO의 모든 저장된 속성이 변경할 수 없는 속성(즉, 상수로 선언됨)이기 때문에 해당 클래스는 경고 없이 Sendable 프로토콜을 준수합니다.\n\n# 2. ModelActor\n\n다음으로, 백그라운드 스레드에서 SwiftData 작업을 관리하기 위해 ModelActor를 작성합니다:\n\n```js\n// ThreadsafeBackgroundActor.swift\n\nimport Foundation\nimport SwiftData\n\n@available(iOS 17, *)\n@ModelActor\nactor ThreadsafeBackgroundActor: Sendable {\n    \n    private var context: ModelContext { modelExecutor.modelContext }\n    \n    func fetchData() async throws -> [UserDTO] {\n        let fetchDescriptor = FetchDescriptor<User>(sortBy: [SortDescriptor(\\User.name)])\n        let users: [User] = try context.fetch(fetchDescriptor)\n        let userDTOs = users.map{UserDTO(id: $0.id, name: $0.name)}\n        return userDTOs\n    }\n    \n}\n```\n\n<div class=\"content-ad\"></div>\n\n`fetchData` 메서드는 User 모델을 검색하고 이를 UserDTO 객체로 변환하여 안전하게 액터 경계를 넘어갈 수 있도록 합니다.\n\n## @ModelActor는 무엇을 하는 건가요?\n\nXcode에서 @ModelActor 매크로를 마우스 오른쪽 버튼으로 클릭하고 \"매크로 펼치기\"를 선택하면 다음 보일러플레이트가 액터에 추가되었음을 확인할 수 있습니다:\n\n```js\n// ThreadsafeBackgroundActor.swift\n// This code is Auto-generated by the @ModelActor annotation\nnonisolated let modelExecutor: any SwiftData.ModelExecutor\n\nnonisolated let modelContainer: SwiftData.ModelContainer\n\ninit(modelContainer: SwiftData.ModelContainer) {\n    let modelContext = ModelContext(modelContainer)\n    self.modelExecutor = DefaultSerialModelExecutor(modelContext: modelContext)\n    self.modelContainer = modelContainer\n}\n```\n\n<div class=\"content-ad\"></div>\n\nSwiftData에서 ModelContainer는 @Model 어노테이션 클래스에서 생성된 스키마를 사용하여 해당 Model 클래스의 인스턴스를 보유할 수있는 데이터베이스를 생성합니다.\n\nModelContext는 모델에 대한 변경 사항을 관찰하고 그러한 모델을 조작하는 데 많은 작업을 제공합니다. 구체적으로 데이터를 가져오고 변경 사항을 저장하는 인터페이스입니다. SwiftData 모델의 상태를 변경할 수 있는 능력이 있기 때문에 ModelContext는 Sendable이 아니며, 따라서 ModelContext가 실행하는 작업이 스레드 안전한지 확인하려면 ModelContext를 액터 간에 공유할 수 없습니다.\n\n그러나 ModelContainer는 모델 상태를 변경하지 않기 때문에 Sendable입니다. 때문에 위의 보일러플레이트 코드에서 MainActor에서 생성된 ModelContainer로 ModelActor를 초기화하는 것이 가능합니다.\n\n이니셜라이저는 DefaultSerialModelExecutor를 설정합니다. 이 객체는 액터 내부에서 생성된 actor-분리된 ModelContext를 사용하여 SwiftData 작업을 수행합니다. 이 실행기는 ModelContext가 일렬로 작동하도록 보장하여 SwiftData에 의해 관리되는 모델이 동시 작업에 의해 손상되는 것을 방지합니다.\n\n<div class=\"content-ad\"></div>\n\n# 3. ViewModel 및 View\n\n이제 ViewModel을 정의할 수 있습니다. async 함수 backgroundFetch를 사용하여 ViewModel을 정의합니다. 이 함수는 ModelActor를 사용하여 메인 스레드가 아닌 곳에서 SwiftData 모델을 검색합니다. 이 ViewModel을 Sendable로 만들어 Swift 컴파일러가 안전하게 여러 컨텍스트 간에 공유할 수 있음을 알 수 있습니다:\n\n```js\n// UserQueryView.swift\n\nimport SwiftData\n\n@Observable\nfinal class UsersQueryViewModel: Sendable { \n    \n    let modelContainer: ModelContainer\n    \n    init(modelContainer: ModelContainer) {\n        self.modelContainer = modelContainer\n    }\n    \n    func backgroundFetch() async throws -> [UserDTO] {\n        let backgroundActor = ThreadsafeBackgroundActor(modelContainer: modelContainer)\n        let result = try await backgroundActor.fetchData()\n        return result\n    }\n    \n}\n```\n\n그런 다음 백그라운드 검색을 트리거하는 버튼과 결과를 표시하는 List 뷰가 있는 SwiftUI View를 구현합니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\n// UserQueryView.swift\nimport SwiftUI\nstruct UsersQueryView: View {\n    let modelContainer: ModelContainer\n    @State var isFetchingUsers = false\n    @State private var users: [UserDTO] = []\n    var viewModel: UsersQueryViewModel\n    \n    \n    init(modelContainer: ModelContainer) {\n        self.modelContainer = modelContainer\n        viewModel = UsersQueryViewModel(modelContainer: modelContainer)\n    }\n    \n    var body: some View {\n        VStack {\n            Button(\"백그라운드 검색\") {\n                isFetchingUsers = true\n                Task {\n                    users = try await viewModel.backgroundFetch()\n                    isFetchingUsers = false\n                }\n            }\n            .buttonStyle(.bordered)\n            \n            if isFetchingUsers {\n                List {\n                    Text(\"사용자 정보 가져오는 중...\")\n                }\n            } else {\n                if users.count == 0 {\n                    ContentUnavailableView(\"가져온 사용자 없음\", systemImage: \"person.crop.circle.badge.exclamationmark\")\n                } else {\n                    List(users) { model in\n                        Text(model.name)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nViewModel의 fetchData 메서드는 actor에서 정의되었기 때문에 await 키워드를 사용하여 actor 외부에서만 호출할 수 있습니다. 따라서 이 함수는 비동기 컨텍스트 내에서 호출되어야 합니다. 이것이 함수 backgroundFetch가 비동기인 이유입니다. backgroundFetch는 View 내에서 분리된 Task 내에서 호출되며 함수가 백그라운드 스레드에서 작업을 수행하는 동안 대기합니다. 함수가 반환되면 ViewModel에서 정의된 변수 users로 백그라운드 actor의 값이 전달됩니다. 이것이 ViewModel이 Sendable이어야 하는 이유입니다.\n\n백그라운드에서 호출된 backgroundFetch 함수를 SwiftUI View 내에서 정의할 수도 있었지만 그런 경우 해당 View 자체가 Sendable 이어야 했습니다. 이는 원하는 유연성을 제공하지 않을 수 있습니다. 그러나 별도의 ViewModel을 가지는 것은 설계 선택이며 엄격히 필수적인 것은 아닙니다.\n\nThreadsafeBackgroundActor를 메인 스레드에서 초기화하는 것이 반드시 필요합니다. 이는 이로 인해 해당 저장된 속성 modelContext가 메인 스레드에서 실행되도록 보장합니다. 이는 처음에 ThreadsafeBackgroundActor를 생성한 이유 때문입니다 - SwiftData 작업이 백그라운드에서 진행되는 동안 UI가 반응할 수 있게 유지하기 위해서입니다. 예를 들어 View의 이니셜라이저 내에서 ThreadsafeBackgroundActor를 생성하고 이를 ViewModel의 backgroundFetch 함수에 속성으로 전달한다면 fetchData 함수는 MainActor에서 실행되어 UI를 블록할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 주의: 작업 우선순위를 \".background\"로 설정하지 마세요!\n\n일부 튜토리얼에서는 분리된 작업의 우선순위를 명시적으로 \".background\"로 설정하는 것을 권장합니다:\n\n![이미지](/assets/img/2024-07-01-UseSwiftDatalikeaboss_5.png)\n\n이 경우 성능에 상당한 영향을 줄 수 있습니다. 제가 테스트한 결과, 요청 처리 시간이 5배나 늘어난 것으로 나왔어요! 그러니 이렇게 하지 마세요 ;)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n저희 데모 앱은 UI를 차단하지 않고 백그라운드 스레드에서 대량의 SwiftData 모델을 성공적으로 가져와 Swift 컴파일러로부터의 동시성 경고 없이 작동합니다!\n\n아래 GIF에서 앱을 확인할 수 있어요:\n\n![앱 GIF](https://miro.medium.com/v2/resize:fit:1200/1*FjjKhsvvwxWUeTU529rx5w.gif)\n\n<div class=\"content-ad\"></div>\n\n\"\\\"배경 검색\\\" 버튼을 누르면 즉시 해제됩니다. 그러나 \\\"주 스레드 검색\\\" 버튼을 누를 때는 모델이 반환된 순간에만 해제되며 주 스레드가 검색 중에 차단된 것을 시사합니다.\n\n이는 GIF에서 작업이 수행되는 동안 앱이 프로필링될 때 Instruments에서 해당 창을 통해 확인할 수 있습니다:\n\n![2024-07-01-UseSwiftDatalikeaboss_6](/assets/img/2024-07-01-UseSwiftDatalikeaboss_6.png)\n\n시간 프로필 도구에서 첫 번째 큰 파란색 블록은 어떤 멈춤이 발생하지 않았음을 나타냅니다. 이는 배경 검색과 일치합니다. 그러나 Hangs 도구에서 두 번째 큰 파란색 블록 옆에 \"심각한 멈춤\"이 표시되는데, 이는 주 스레드 검색이 UI를 차단하고 있는 것을 나타냅니다.\"\n\n<div class=\"content-ad\"></div>\n\n이 앱의 전체 구현 내용은 해당 프로젝트용 GitHub 저장소에서 확인할 수 있어요.\n\n읽으신 것이 즐거우셨다면, 이 게시물을 좋아요하거나 저를 팔로우해 주시거나 둘 다 해주세요!\n\n* 고지: 저의 아바타는 DALL-E에 의해 생성되었으며 제 모습과는 무관합니다 — 그는 훨씬 더 잘 생겼어요.","ogImage":{"url":"/assets/img/2024-07-01-UseSwiftDatalikeaboss_0.png"},"coverImage":"/assets/img/2024-07-01-UseSwiftDatalikeaboss_0.png","tag":["Tech"],"readingTime":10},{"title":"SwiftUI에서 무한 갤러리를 쉽게 만드는 방법","description":"","date":"2024-07-01 17:01","slug":"2024-07-01-TheSimplestWaytoCreateanInfiniteGalleryinSwiftUI","content":"\n\n안녕하세요 여러분! iOS 앱에서 무한 갤러리를 만들어야 하는 일이 있었나요? 사진 목록이나 배송 앱에서 제품 목록을 만들 때 이런 필요성을 마주할 수 있습니다. 이 짧은 글에서는 가장 정확하고 간단한 방법을 보여드리겠습니다.\n\n![간단한 무한 갤러리를 만드는 가장 간단한 방법](/assets/img/2024-07-01-TheSimplestWaytoCreateanInfiniteGalleryinSwiftUI_0.png)\n\nSwiftUI는 UIKit 시대에는 꿈에도 못 꾸던 많은 것들을 구현할 수 있는 강력한 프레임워크입니다. 이 글에서는 SwiftUI의 내부 API인 PagingView를 사용할 것인데, 이 뷰는 문서화되어 있지 않지만 iOS 14부터 사용할 수 있는 매우 강력한 뷰입니다.\n\n우선, 빈 ContentView를 메인 화면으로 하는 SwiftUI 프로젝트를 만들어봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport SwiftUI\n\n@main\nstruct InfiniteGalleryApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}\n```\n\n좋은 작업이에요! ContentView에서는 우리의 데이터 배열을 생성할 거예요 - 세 가지 색상(빨강, 초록, 파랑) - 이를 무한 갤러리에 배치할 거에요.\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    let colors: [Color] = [.red, .green, .blue]\n    \n    var body: some View {\n        // some body\n    }\n}\n```\n\n뷰의 본문에는 _PagingView의 인스턴스를 하나 넣을 거예요.\n\n<div class=\"content-ad\"></div>\n\n```js\nlet colors: [Color] = [.red, .green, .blue]\n@State private var currentCard: Int = 0\n\nvar body: some View {\n    _PagingView(\n        config: .init(direction: .horizontal, margin: 8, spacing: 8),\n        page: $currentCard,\n        views: cards\n    )\n}\n\nprivate var cards: [AnyView] {\n    // 우리의 색깔을 뷰 배열로 매핑합니다.\n}\n```\n\n_PagingView는 이 코드의 가장 흥미로운 부분입니다. 수평 또는 수직 방향으로 카드 세트를 분배하고 간격 및 정렬을 관리하며 심지어 페이지네이션도 제공합니다. SwiftUI의 ScrollView에서 iOS 17부터 사용 가능한 기능 중 하나입니다.\n\n이제 cards 속성을 정의해 보겠습니다. 단순히 우리의 색깔을 색칠된 직사각형 배열로 매핑합니다.\n\n```js\nprivate var cards: [AnyView] {\n    colors.map { color in\n        AnyView(\n            Rectangle()\n                .fill(color)\n                .frame(height: 72)\n        )\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드로 인해 갤러리가 이미 잘 작동합니다. 그러나 우리는 무한 스크롤 효과를 얻을 수 없습니다. _PagingView에 유한한 배열을 제공했기 때문에 그러합니다. 마지막 요소 이후에 아무것도 없기 때문에 _PagingView 내부의 ScrollView는 간단히 콘텐츠 가장자리를 향해 튕겨져 다시 돌아올 뿐입니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*tqZDRqYekPSCW1IPBcDzRg.gif\" />\n\n진정한 무한 행동을 달성하기 위해 _PagingView는 views의 RandomAccessCollection을 인자로 받는다는 것을 기억해야 합니다. 우리는 이를 활용해서 무한 반복되는 사용자 정의 컬렉션을 만들어야 합니다. 마지막 요소 이후에 첫 번째 요소로 다시 돌아가는 InfiniteArray라는 컬렉션을 만들어 무한 행동을 보장할 수 있습니다. 이것을 살펴보세요:\n\n```js\nfinal class InfiniteArray<Content>: RandomAccessCollection {\n    private var elements: [Content]\n    \n    init(elements: [Content]) {\n        self.elements = elements\n    }\n    \n    var startIndex: Int { Int.min }\n    var endIndex: Int { Int.max) }\n    \n    subscript(position: Int) -> Content {\n        let index = (elements.count + (position % elements.count)) % elements.count\n        return elements[index]\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n우리가 반복하고 싶은 요소 배열에서 초기화할 수 있으며, n번째 요소 다음에 (n+1)번째 요소를 생성할 수 있습니다. 이제 cards 속성을 이 새로운 컬렉션을 사용하도록 수정해봅시다.\n\n```js\nprivate var cards: InfiniteArray<AnyView> {\n    InfiniteArray(elements: colors.map { color in\n        AnyView(\n            Rectangle()\n                .fill(color)\n                .frame(height: 72)\n        )\n    )\n}\n```\n\n이 수정으로 갤러리가 어떻게 변화되었는지 확인할 수 있습니다. 이제 우리가 원했던 무한한 동작을 갖고 있습니다!\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*y49T8uq9HNmc30b10WNoCg.gif\" />\n\n<div class=\"content-ad\"></div>\n\n여러분, 이 글을 여기까지 읽어주셔서 감사합니다. 이 포스트에서는 40줄의 코드로 무한 페이징 갤러리를 구현했습니다. 이 프로젝트의 전체 코드에 관심이 있다면 여기에서 찾을 수 있어요 — https://github.com/maxoog/InfiniteGallery.","ogImage":{"url":"/assets/img/2024-07-01-TheSimplestWaytoCreateanInfiniteGalleryinSwiftUI_0.png"},"coverImage":"/assets/img/2024-07-01-TheSimplestWaytoCreateanInfiniteGalleryinSwiftUI_0.png","tag":["Tech"],"readingTime":4},{"title":"러스트 프로그래밍을 위한 최고의 실천 방법 10가지","description":"","date":"2024-07-01 16:59","slug":"2024-07-01-BestPracticesforRustProgramming","content":"\n\n![라스트 프로그래밍 최상의 실천 방법](/assets/img/2024-07-01-BestPracticesforRustProgramming_0.png)\n\n라스트는 안전성, 동시성 및 성능으로 알려진 시스템 프로그래밍 언어입니다. 이 언어는 널 포인터 역참조 및 데이터 경합과 같은 함정을 피하면서 빠르고 안전한 소프트웨어를 작성할 수 있는 도구를 제공합니다. 이 블로그 글에서는 라스트 프로그래밍의 최상의 실천 방법 중 일부를 상세한 예제와 함께 탐구하여 효율적이고 유지보수 가능한 코드를 작성하는 데 도움이 될 것입니다.\n\n# 1. 라스트의 소유권 모델 채택하기\n\n라스트의 소유권 모델은 안전성을 보장하는 핵심 요소입니다. 이 모델을 이해하고 활용하는 것이 중요합니다. 라스트의 각 값은 단일 소유자를 가지며, 소유자가 범위를 벗어나면 값이 삭제됩니다. 이는 가비지 컬렉터 없이도 메모리 안전성을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1; // s1이 s2로 이동되었으므로 s1은 더 이상 유효하지 않음\n\n    // println!(\"{}\", s1); // 이것은 컴파일 시 오류를 발생시킴\n\n    println!(\"{}\", s2); // 유효함\n}\n```\n\n공통 함정을 피하기 위해:\n\n- 적절한 곳에서 참조(&T) 및 가변 참조(&mut T)를 사용하세요.\n- 복사와 이동의 차이를 이해하세요. Copy 트레이트를 구현하는 타입(예: 정수, 부동 소수점 수)은 소유권을 이동시키지 않습니다.\n\n참조를 사용한 예시:\n\n\n<div class=\"content-ad\"></div>\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let len = calculate_length(&s1);\n    println!(\"'{}'의 길이는 {}입니다.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\n# 2. 패턴 매칭 활용하기\n\n패턴 매칭은 러스트에서 강력한 기능으로, 더 표현력이 풍부하고 간결한 코드를 작성할 수 있도록 합니다. match, if let, while let과 함께 사용할 수 있습니다.\n\n```rust\nfn main() {\n    let number = 7;\n    match number {\n        1 => println!(\"하나!\"),\n        2 | 3 | 5 | 7 | 11 => println!(\"이 수는 소수입니다!\"),\n        13..=19 => println!(\"10대 숫자입니다!\"),\n        _ => println!(\"다른 숫자입니다!\"),\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n친절하게 말씀드리면, if-else 체인 대신에 패턴 매칭을 사용하여 코드를 더 읽기 쉽게 만들어보세요. 더 복잡한 조건의 경우 if let이나 while let을 고려해보세요.\n\nif let을 사용한 예시:\n\n```js\nlet favorite_color: Option<&str> = Some(\"blue\");\n\nif let Some(color) = favorite_color {\n    println!(\"Your favorite color is {}.\", color);\n} else {\n    println!(\"You don't have a favorite color.\");\n}\n```\n\n# 3. Result 및 Option 유형 사용하기\n\n<div class=\"content-ad\"></div>\n\n러스트의 Result와 Option 타입은 오류 처리와 선택적 값 다루기에 필수적입니다. 이들은 잠재적 오류와 값의 부재를 컴파일 시간에 처리할 수 있도록 강제합니다.\n\nResult를 사용한 예제:\n\n```js\nfn divide(dividend: f64, divisor: f64) -> Result<f64, String> {\n    if divisor == 0.0 {\n        Err(String::from(\"Cannot divide by zero\"))\n    } else {\n        Ok(dividend / divisor)\n    }\n}\n\nfn main() {\n    match divide(4.0, 2.0) {\n        Ok(result) => println!(\"결과: {}\", result),\n        Err(e) => println!(\"에러: {}\", e),\n    }\n}\n```\n\nOption을 사용한 예제:\n\n<div class=\"content-ad\"></div>\n\n```rust\nfn find_word(s: &str, word: &str) -> Option<usize> {\n    s.find(word)\n}\n\nfn main() {\n    let text = \"The quick brown fox jumps over the lazy dog\";\n    match find_word(text, \"fox\") {\n        Some(index) => println!(\"Found 'fox' at index {}.\", index),\n        None => println!(\"'fox' not found.\"),\n    }\n}\n```\n\n항상 이러한 유형을 사용하여 잠재적인 오류를 신중하게 처리해 주세요.\n\n# 4. 변경 가능한 것보다는 변경 불가능한 것을 선호합니다.\n\nRust는 변경 불가능성을 장려하여 예상치 못한 변경을 방지하고 코드를 더 쉽게 이해할 수 있도록 돕습니다. 기본적으로 변수는 변경할 수 없습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```rust\nfn main() {\n    let x = 5;\n    println!(\"x의 값은: {}\", x);\n    println!(\"x의 값은: {}\", x);\n}\n```\n\n`mut`은 필요할 때만 사용하여야 합니다. 변경할 수 없는 변수는 의도하지 않은 수정에 관련된 버그를 방지할 수 있습니다.\n\n# 5. 이터레이터와 클로저 사용\n\n이터레이터와 클로저는 코드를 더 표현력 있고 간결하게 만들 수 있습니다. 종종 기존 루프를 사용하는 것보다 더 효율적일 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```rust\nfn main() {\n    let v = vec![1, 2, 3, 4, 5];\n    let v2: Vec<i32> = v.iter().map(|x| x + 1).collect();\n    println!(\"{:?}\", v2); // [2, 3, 4, 5, 6]\n}\n```\n\n컬렉션에서 map, filter, collect와 같은 이터레이터 메서드를 사용하여 작업할 수 있습니다. 이들은 함수형 프로그래밍 스타일을 가능하게 하며 종종 성능이 더 우수합니다.\n\nfilter를 사용한 예시:\n\n```rust\nfn main() {\n    let v = vec![1, 2, 3, 4, 5, 6];\n    let even_numbers: Vec<i32> = v.into_iter().filter(|x| x % 2 == 0).collect();\n    println!(\"{:?}\", even_numbers); // [2, 4, 6]\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 6. 러스트 우아한 코드 작성하기\n\n관용적인 가이드라인을 따르면 코드를 읽기 쉽고 유지보수하기 쉽게 만들 수 있습니다. 러스트는 명확하고 관용적인 코드 작성에 강한 강조를 두고 있습니다.\n\n- unwrap과 expect를 신중하게 사용하세요.\n- 회복할 수 없는 오류에는 panic!을 선호하세요.\n- 유의미한 변수 이름을 사용하세요.\n- 러스트의 네이밍 규칙을 따르세요 (예: 변수와 함수에는 snake_case, 타입과 트레이트에는 CamelCase).\n\nunwrap과 expect를 사용한 예시:\n\n<div class=\"content-ad\"></div>\n\n```rust\nfn main() {\n    let guess: i32 = \"42\".parse().expect(\"숫자가 아닙니다!\");\n    println!(\"추측: {}\", guess);\n}\n```\n\n디버깅을 돕기 위해 의미 있는 오류 메시지와 함께 expect를 사용하십시오.\n\n# 7. Rust의 동시성 활용\n\nRust는 스레드와 채널과 같은 안전한 동시성 프리미티브를 제공합니다. 소유권 모델은 데이터 레이스가 불가능하다는 것을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n쓰레드를 사용한 예시:\n\n```js\nuse std::thread;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(std::time::Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(std::time::Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n```\n\njoin을 사용하여 스레드가 종료될 때까지 기다리고 데이터 레이스를 방지합니다. 더 복잡한 동시성 패턴을 위해 채널을 사용하는 것을 고려해보세요.\n\n채널을 사용한 예시:\n\n<div class=\"content-ad\"></div>\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n```\n\n## 8. Cargo로 최적화하기\n\nRust의 패키지 매니저 및 빌드 시스템인 Cargo는 코드를 최적화하고 종속성을 관리하는 다양한 도구를 제공합니다.\n\n- 코드 포맷팅을 위해 cargo fmt를 사용합니다.\n- 린팅을 위해 cargo clippy를 사용합니다.\n- 벤치마킹을 위해 cargo bench를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncargo fmt\ncargo clippy\ncargo bench\n```\n\nCargo는 종속성 관리와 프로젝트 빌드도 처리해주어 Rust 프로젝트의 유지 관리와 배포를 쉽게 만들어 줍니다.\n\n# 9. 라이프타임 이해와 활용\n\n라이프타임은 완료되지 않은 참조를 방지하고 메모리 안전성을 보장합니다. 라이프타임은 Rust 컴파일러가 참조가 유효한 기간을 이해하도록 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}\n```\n\n참조가 유효함을 보장하기 위해 수명을 정의하고 사용하세요. 러스트의 복잡한 데이터 구조 및 함수 작업에 필수적인 수명 이해가 중요합니다.\n\n# 10. 코드 문서화\n\n마지막으로, 러스트의 문서화 주석 (///)을 사용하여 코드에 대한 문서를 생성하세요. 이렇게 하면 다른 개발자 (그리고 미래의 본인)가 코드의 목적과 사용법을 이해하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/// 주어진 숫자에 1을 더합니다.\n///\n/// # 예시\n///\n/// \n/// let five = 5;\n/// assert_eq!(6, add_one(five));\n/// \nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\ncargo doc으로 문서를 생성하세요.\n\n이러한 최상의 관행을 따르면 효율적이고 안전하며 유지보수 가능한 Rust 코드를 작성할 수 있습니다. Rust의 특이점과 관용구를 받아들여 이 강력한 언어의 잠재력을 최대로 발휘하세요.\n\n즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-07-01-BestPracticesforRustProgramming_0.png"},"coverImage":"/assets/img/2024-07-01-BestPracticesforRustProgramming_0.png","tag":["Tech"],"readingTime":7},{"title":"소프트웨어 품질 향상의 열쇠 개발자 경험 개선하는 방법","description":"","date":"2024-07-01 16:57","slug":"2024-07-01-OneKeytoBetterSoftwareImprovingtheDeveloperExperience","content":"\n\n![OneKeytoBetterSoftwareImprovingtheDeveloperExperience](/assets/img/2024-07-01-OneKeytoBetterSoftwareImprovingtheDeveloperExperience_0.png)\n\n페어 프로그래밍 세션은 잘 진행되지 않았어요. 까다로운 버그의 근원을 찾으려고 노력했지만 전혀 진전이 없었어요. 계속 발전이 없다는 느낌이 난 것이 참으로 좌절스러웠어요.\n\n하지만, 진전이 없던 것보다 더 좌절스러운 것은 진전이 없는 이유였어요.\n\n관찰자로 차례가 돌아왔을 때, 동료들이 자신들의 코드를 로컬에서 실행시키지 못하고 있음을 깨달았어요. 그들은 앱을 디버그할 수 있는 재현 가능한 방법을 설정하지 못했고 (IDE나 다른 방법으로), 코드 전체에 프린트 문을 넣은 것으로 타협해야 했어요. 테스트를 신뢰할 수 없었기 때문에 테스트를 믿을 수 없었어요. 때로는 테스트가 실패하고 예상치 못하게 실패하기도 했어요. 더 나빠진 것은, Docker 컨테이너의 혼란스러운 무리와 화면에 텍스트를 흘리는 네 개 이상의 터미널 창을 이용해 싸운다는 것이었어요.\n\n<div class=\"content-ad\"></div>\n\n진행을 못한 이유는 애플리케이션을 독립적으로 쉽고 신뢰성 있게 실행하거나 디버깅할 수 없었기 때문이었습니다. 코드는 바로 있었지만 접근하기 어려웠습니다.\n\n이 짧은 이야기에 대해 이야기할 것이 많습니다. 하지만 분명히 확인된 큰 문제 중 하나는 이 코드베이스가 개발자 경험에 투자 부족으로 인해 고통받았다는 것입니다.\n\n오늘의 글에서는 카이제니(Kaizen) 개념을 적용하고 지속적으로 개발자 경험을 개선하는 방법에 대해 이야기하고 싶습니다. 새로운 경로나 기술을 발표하기 위한 새로운 방법은 없습니다(이미 많은 것들이 존재합니다). 대신, 왜 일상적인 작업의 개선을 가장 중요한 작업으로 만들고 시작하는 방법에 대해 전달하고 싶습니다.\n\n# 가장 중요한 작업\n\n<div class=\"content-ad\"></div>\n\n피닉스 프로젝트를 처음 읽고 나서 멈출 수가 없었어요. 나 같이 느리게 읽는 사람이 이 책을 일주일도 안에 다 읽는 거야. 등장인물과 분위기에 공감할 수 있는 느낌이 짙었어요. 사실, 몇 부분은 읽는 게 힘들 정도로 공감이 느껴졌어요.\n\n유니콘 프로젝트도 집어들고 나서 비슷한 반응을 보였어요. 젠 킴(Gene Kim) 작가는 나의 개발 경력 중 겪은 모든 고통을 잘 표현해 냈어요! 막신이 코드와 정치적 지뢰의 복잡함을 인내심과 기술로 넘어가는 것을 보면서 환성을 질렀었어요(소리 내어).\n\n이 책들과 다른 책들은 조직 구조, 실험, 그리고 개발자와 관련된 여러 아이디어에 대한 나의 시각을 크게 바꿔 놨어요. 하지만 가장 중요한 것은 개발자로서 가장 중요한 일이 무엇인가에 대해 다짐해 줬던 것이죠: 매일 작업을 개선하는 것.\n\n젠의 삼 가지 방법과 다섯 가지 이상(Three Ways and Five Ideals)이 이것에 관해 날보다 더 잘 설명해 주지만, 이 아이디어와 매일 개선에 대한 요약은 이렇습니다: 안전하고 쉽게 코드를 팀의 코드베이스에 기여하는 데 어떤 개선도 시간이 지남에 따라 누적된 혜택을 가져다줄 것이라는 거예요.\n\n<div class=\"content-ad\"></div>\n\n만약 오늘 코드 작성 능력을 5% 향상시킨다면, 내일은 팀 전체가 그 5%의 향상을 경험할 것입니다. 그 5%의 향상은 다음주에 개발자 경험을 개선하는 중요한 단계를 더 쉽게 만들어줍니다.\n\n기술 부채를 상환하거나 메이크 또는 Ansible 스크립트를 통해 환경 설정을 자동화하는 등 개선 작업이 모두 쌓여서 비교적 빨리 눈에 띕니다.\n\n# 개선된 개발자 경험이 더 좋은 코드로 이어집니다\n\n개발자가 빠르고 안전하게 코드를 기여할 수 없을 때에는 코드에 여러 문제가 발생하기 시작합니다.\n\n<div class=\"content-ad\"></div>\n\n- 테스트가 너무 어려워서 건너뛰기 시작합니다.\n- 좋은 코드 구조가 없기 때문에 팀이 같은 작업을 반복적으로 다시 작성하기 시작합니다.\n- 무엇이 깨질지 두려워해서 대부분 미미한 변화만 제외하고는 아무것도 변경하고 싶어하지 않습니다.\n\n시간이 흐름에 따라 이러한 패턴들은 부정적인 상황으로 이어집니다. 팀이 코드를 빠르고 안전하게 기여할 수 없기 때문에 개선을 하지 않습니다. 아무도 코드를 개선하거나 이를 세심히 다루길 원하지 않아서 코드는 부패됩니다. 이제 어제보다 변경하기가 더 어려워집니다.\n\n반면에, 매일 일을 개선하기 위해 투자하는 것은 반대 효과를 가져옵니다. 팀이 신뢰할 수 있는 테스트를 작성하고 자주 실행하는 데 에너지를 투자했기 때문에 테스트를 쉽게 작성할 수 있습니다. 일반적인 패턴이 식별되고 재사용성과 효율적인 코딩을 위해 추상화됩니다. 모든 사람은 변화를 자신 있게 만들 수 있습니다. 테스트와 코드를 믿기 때문에 어디를 놓칠지를 알려줄 것이라고 믿기 때문입니다.\n\n이러한 패턴은 매일 변경하기가 더 쉬워지는 선순환을 만듭니다. 이는 더 나은 코드, 더 빠른 제품 출시 시간(코드가 더 이상 방해가 되지 않습니다) 및 종종 제품의 더 적은 버그를 유발합니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 코드를 보다 쉽게 기여할 수 있게 하는 것은 코드에만 도움이 되는 것이 아닙니다. 팀에 상당한 혜택이 됩니다.\n\n# 개선된 개발자 경험은 더 나은 팀 동료 의욕으로 이어집니다\n\n코드를 빠르고 안전하게 기여하는 능력은 코드나 제품 전달 속도에 도움이 되는 것 이상의 의미를 갖습니다. 이는 팀 동료들의 의욕을 높입니다.\n\nSPACE 프레임워크와 다른 연구에서 언급한 것처럼, 개발자들은 작업에 즐거움이 있을 때 가장 효과적입니다. 이 때의 '즐거움'은 개발자가 일상적인 업무에 만족하고 기쁨을 느끼는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n개발자들이 자신의 일을 즐기면 팀이 자신들의 일, 팀 그리고 방향에 대해 긍정적이고 자신감을 느끼는 데 훨씬 더 수월해집니다.\n\n일반적으로 팀이 어려운 코드베이스에서 기능을 배포해야 하는 상황을 고려해보세요. 테스트는 부서지기 쉽고, 로컬 환경 설정은 고통스럽고, 문서화가 거의 없습니다. 팀은 프로젝트의 처음 몇 주를 모든 사람이 진입하도록 하는 데 집중하며 보내게 됩니다.\n\n프로젝트가 진행되고 마감일이 다가올수록, 이 코드베이스에서 작업하는 어려움이 영향을 미치기 시작합니다. 팀은 코드에 짜증을 내며 마감일의 압박을 느끼게 됩니다. 그리고 얼마 지나지 않아 팀 내에서 스트레스가 높아지고 모두에게 느껴집니다. 이러한 스트레스 상황에서 실력 좋은 팀조차도 고생할 것입니다.\n\n이제 이 프로젝트 전에 코드베이스를 개선할 시간을 가져주었다면 팀은 어땠을지 상상해보세요. 기능을 출시하는 데 초점을 맞추기보다는 코드베이스를 개선하는 데 시간을 할애했다면 어땠을까요. 부서지기 쉬운 테스트를 수정하거나, 환경 설정을 자동화하거나, 단순히 코드의 결합된 부분을 리팩토링하기 시작했을 수도 있습니다. 혹은 이 모든 것을 약간씩 할 수도 있겠죠.\n\n<div class=\"content-ad\"></div>\n\n이 경우에는 일상적인 업무의 개선이 팀에 큰 영향을 미쳤을 것입니다. 팀은 코드베이스에 대한 소유감을 느끼고 긍정적인 흐름을 타고 있으며, 전반적으로 높은 사기를 가지게 될 것입니다. 이러한 사기와 긍정적인 마음가짐은 더 많은 가치를 창출하며 일상적인 업무를 개선하는 데 큰 역할을 합니다.\n\n우리는 훌륭한 코드를 작성하는 능력을 향상시킴으로써 팀이 운영하는 방식을 변화시킬 수 있습니다.\n\n# 개선 방법\n\n만약 이것이 중요한 아이디어라고 확신한다면, 아마도 이미 \"하지만 어떻게하면 일상적인 업무를 개선할 수 있을까?\"라고 물을 수도 있습니다. 좋은 질문입니다. 코드베이스를 살펴보고 어떠한 개선을 해야할지 알아내는 것은 어려운 일입니다. 하나의 개선을 하기도 어려운데 더 말이죠.\n\n<div class=\"content-ad\"></div>\n\n제가 작업한 코드베이스를 개선하는 데 도움이 된 몇 가지 지침이 여기 있습니다.\n\n# 옵저버가 되세요\n\n어떤 개선을 하려면 먼저 개선이 필요한 것을 찾아야 합니다. \"문제가 없다면 고치지 마세요\"는 여기에 너무 강한 표현이지만, 긍정적인 영향을 미치고 싶다는 열망으로 지나치게 급해질 수 있습니다. 모든 클래스, 모듈 또는 명령을 리팩토링할 필요는 없습니다. 모든 단계를 자동화할 필요도 없습니다 (적어도 즉시는).\n\n어떤 경우에도, 코드 내에서 올바른 지렛대 지점을 식별해야 합니다. 이를 위해 옵저버가 되어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n코드와 상호작용하는 방식에 주의를 기울이세요. 테스트를 실행하는 방법은 무엇인가요? 자동화된 테스트의 결과를 어떻게 확인하나요? 비유적으로 문에 \"들어오지 마세요!\"라는 표시가 붙은 코드 부분은 있나요? 사용하고 이해하기 어려운 추상화가 있나요?\n\n이들은 모두 노력과 시간을 할 가치가 있는 부분에 대한 신호들입니다. 경험하는 것에 대해 일부 정신적인 노트(또는 실제 노트)를 유지해보세요. 그러면 집중해야 할 올바른 영역을 찾을 수 있을 겁니다.\n\n# 판단을 보류하세요\n\n어떤 것에 객관적으로 대할 때 판단하기는 쉽습니다. 정치부터 스포츠(쇼파에서의 수비수들)에 이르기까지, 다른 사람에 대해 판단을 내리는 것은 멀리 떨어져 있을 때 쉽게 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n코드베이스에도 동일한 것이 적용될 수 있습니다. 우리는 코드를 파헤치기 시작하면서 모든 결함을 볼 수 있고 코드와 기여한 개발자들을 비판하기 시작할 수 있습니다. \"도대체 왜 그렇게 했을까?\" 라는 생각을 머릿속에 하게 됩니다.\n\n해당 코드베이스 내에서 개발자 경험을 향상시키기 위해 어떠한 진전을 이루기 위해서는 이 심사를 보류해야 합니다. 특히 새로 합류하는 팀에서는 이것이 매우 중요합니다.\n\n발견한 것을 비판하는 대신, 코드가 현재의 상태로 이끈 힘과 결정을 이해하려고 노력해야 합니다. 코드베이스는 종종 서비스하는 제품이 변경됨에 따라 많은 변형을 겪습니다. 이러한 변경은 때로 갑작스럽거나 너무 빨리 발생할 수 있습니다. 팀은 빠르게 작동하여 뭔가를 만들어내야 합니다.\n\n이러한 변형은 종종 코드에 이상한 \"공백\"을 생성하는데, 이를 코드가 작동하기 위해 메꿔지거나 덮어야 합니다. 이는 너무 빨리 추가가 이루어진 집에 대한 일어나는 현상과 유사합니다. 방들이 이상하게 느껴지고 레이아웃이 이해되지 않을 수 있으며 (문자 그대로) 실제적인 공백과 갈라진 곳이 시멘트나 페인트로 가려져 있을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n맥락을 이해하면 코드가 문제가 있을 수 있지만 그 목적을 충족했다는 것을 기억할 수 있습니다. 이 마음가짐을 갖게 되면 코드를 즉시 수정하는 대신 어디로 코딩을 이끌어야 하는지에 대해 더 나은 질문을 하게 될 것입니다. 아이러니하게도, 즉행으로 변화를 주는 것이 바로 그런 코드의 처음 되는 방식일 수 있네요 :)\n\n코드에 대한 판단을 유보함으로써 더 나은 세상으로 향할 수 있는 방법을 더 잘 이해할 수 있습니다.\n\n# 작은 시작\n\n개선할 점을 식별하기 시작하면, 바로 뛰어들고 싶어질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 조심해야 해요. 대규모 리팩토링과 거대한 재작성은 비참하게 실패하는 경향이 있어요. 많은 경우, 그 이유는 단순히 변경이 너무 커서 그렇습니다.\n\n대신, 작은 개선을 목표로 삼아보세요. 일반적인 작업을 위한 npm 스크립트를 추가하는 것조차도 큰 이점을 가진 작은 변경일 수 있어요(터미널 히스토리를 Ctrl+r로 계속 찾느라 낭비하는 시간이 줄어듭니다). 여러분의 문제의 규모에 따라 중요하지 않아 보일 수도 있지만, 작은 승리가 복리 효과를 만드는 중요한 부분이랍니다.\n\n작은 개선에 집중함으로써 여러분은 그 작업을 다른 작업에 조화롭게 결합할 수 있는 능력을 얻게 됩니다. 예를 들어, 구현하는 데 두-세 시간밖에 걸리지 않는 작업이라면 특별한 권한이 필요하지 않을 거예요. 이런 식으로 더 많은 개선을 할 수 있게 되는 것이죠. 또 다른 이점은 일상적인 작업에 개선 사항을 편집할 수 있다는 점입니다. 매일 코드를 다루면서 비로소 그 클래스에 대한 이상한 API를 발견할 수 있습니다.\n\n물론, 더 많은 사고, 계획, 시간이 필요한 변경이 있을 수 있어요. 이런 경우에는 코드와 개발자 경험에 대한 개선의 영향을 추정하기 위해 최선을 다하셔야 해요. \"왜 이것을 하죠?\"와 \"지금 이걸 왜 하죠?\"에 대한 좋은 답변을 가지는 것이 중요합니다. 달러로 표기하거나 구체적인 시간 추정을 할 수 없을 수도 있지만, 지연된 프로젝트, 장애, 또는 지속적인 긴급 호출 문제를 지적할 수 있다면 그런 곳을 시작 지점으로 삼아보세요.\n\n<div class=\"content-ad\"></div>\n\n# 함께 이야기하기\n\n마지막으로, 다른 사람들을 함께 이끄는 것을 잊지 말아주세요. '다른 사람들을 함께 이끄는 것'이라고 말하는 내 의미는 미래의 세상이 어떻게 변화할 수 있는지 보기 위해 그들을 초대하는 것입니다. 그들을 당신의 작업에 참여시키고 팀원들과 아이디어를 공유하세요. 그들이 모두 참여한다면 어느 정도 나아질 수 있는지 보여주세요.\n\n만약 이를 올바르게 수행한다면, 다른 사람들이 개선할 수 있는 다른 장소를 알게 되고, 이를 실현시키는 데 도움을 제안해 줄 것입니다. 사람들은 의미 있는 일에 기여하는 것을 좋아합니다. 팀원들이 시간을 투자할 가치가 있는 것을 찾아내고 이를 실현하기 위해 노력해주세요.\n\n물론 모두가 동의할 수 있는 것은 아닙니다. 모든 팀에는 회의론자나 냉소주의자들이 있습니다. 그들은 당신의 진전에 어려운 장애물을 제공할 수 있습니다. 우리는 그들을 완전히 배척하길 원하지는 않지만, 팀이 흥분할만한 좋은 일을 방해하는 것을 허용하고 싶지도 않습니다.\n\n<div class=\"content-ad\"></div>\n\n아직 배우는 중이지만, 효과가 있을 것 같은 몇 가지 조합을 본 적이 있어요.\n\n먼저, 그들을 퇴짜냅니다 마세요. 그들을 무시하지 말아주세요. 그 행동은 팀 내에 건설되고 이겨가는 엄청난 격차와 긴장을 야기할 것입니다.\n\n둘째, 공통 분모를 찾으려고 노력해보세요. 그들이 당신의 아이디어 중 80%에 동의하지 않을 수도 있지만, 만약 20%에 동의한다면, 먼저 그 20%를 어떻게 실행할지 집중해보세요. 이 방법으로 관계를 구축하면 서로 어떤 문제에 대해 어떻게 생각하는지 알 수 있습니다. 또한 여기서 그들이 동의하는 부분이 있는 경우 그 공통 분모를 가진 그들의 아이디어에도 도움을 줄 의향이 있음을 보여줄 수 있습니다.\n\n마지막으로, 모든 변경 사항이나 개선 사항에 대해 합의를 반드시 이룰 필요는 없다는 것을 기억하세요. 팀 중 나머지가 찬성을 할 때 일관적으로 한 명만 반대하는 경우 — 이루세요. 악의적인 방식으로 하거나 어떤 사람의 견해를 무시하게 되는 방식으로 하지는 마세요. 그러나 코드를 병합하는 데 너무 겁먹지도 마세요. 항상 누구든지 만족시킬 수는 없습니다.\n\n<div class=\"content-ad\"></div>\n\n오늘 요약은 명확합니다: 일상 업무의 개선을 일상 업무에 통합하는 데 노력하세요.\n\n올바른 방향으로 조정하는 데 시간이 걸리고, 다른 개발자들에게 협력을 부탁하기 위해 몇 가지 설득이 필요할 수도 있지만, 이것은 이기고 싶어하는 팀에게 필수적입니다.\n\n이것은 개발자로서 우리가 할 수 있는 가장 중요한 일이죠: 다른 모든 사람이 보다 효과적인 개발자가 되도록 돕는 것입니다.\n\n즐거운 코딩되세요!\n\n<div class=\"content-ad\"></div>\n\n만약 이 기사를 즐겼다면, 제 뉴스레터에 가입해보세요! 매주 화요일마다, 저는 여러분에게 훌륭한 소프트웨어를 만드는 멋진 팀을 구축하는 데 도움이 되는 도구, 자료 및 새로운 기사를 보내드립니다.\n\nhttps://dangoslen.me에서 최초 발행되었습니다.","ogImage":{"url":"/assets/img/2024-07-01-OneKeytoBetterSoftwareImprovingtheDeveloperExperience_0.png"},"coverImage":"/assets/img/2024-07-01-OneKeytoBetterSoftwareImprovingtheDeveloperExperience_0.png","tag":["Tech"],"readingTime":8},{"title":"데이터 과학자가 되기 위해 필요했던 5가지 습관","description":"","date":"2024-07-01 16:56","slug":"2024-07-01-5HabitsThatMadeMeADataScientist","content":"\n\n<img src=\"/assets/img/2024-07-01-5HabitsThatMadeMeADataScientist_0.png\" />\n\n데이터 과학자가 되는 것은 쉬운 일이 아니지만, 몇 가지 중요한 습관들이 제게 도움이 되었습니다. 오늘 여러분과 공유할 것이며, 아마도 여러분도 여러분의 여정에서 습득할 수 있는 습관들일 것입니다. 나는 장기적으로 좋은 데이터 과학자가 될 것이라고 생각합니다.\n\n# 행동 지향적\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-07-01-5HabitsThatMadeMeADataScientist_1.png)\n\n데이터 과학을 배우기 시작할 때는 그냥 빠져들어라. 생각하지 말고 일단 시작해봐.\n\n지나치게 생각하지 말고 즉시 학습을 시작하는 것이 가장 좋은 방법이며 거의 모두가 이것을 말합니다.\n\n예를 들어, 언제나 \"가장 좋은 강의\"라는 것은 없다고 언급합니다. 물론 어떤 자습서가 다른 것보다 나을 수 있지만, 입문 강좌는 일반적으로 동일한 내용을 다룹니다.\n\n\n<div class=\"content-ad\"></div>\n\n어떤 강의를 수강해야 할지 수시간을 고민하는 대신, 실제 학습과 공부에 시간을 투자하면 얼마만큼의 진전을 이룰 수 있는지 상상해 보세요.\n\n마찬가지로, \"완벽한 프로젝트\"를 찾는 데 시간을 낭비하지 마세요. 그냥 마음에 드는 하나를 찾아서 시작하세요. 나중에 새로운 프로젝트를 시작하거나 현재 프로젝트를 변경할 수 있습니다. 여정을 시작할 때 특히, 프로젝트 결과물보다는 학습이 중요합니다.\n\n행동 중심이 되기 위한 제일 중요한 조언은 \"생각\"과 \"조사\" 시간을 시간 단위로 블록 처리하여 시간을 너무 많이 들이지 않도록 하는 것입니다. 이렇게 하면 \"스코핑\"이 끝날 때, 배경 작업을 모두 끝내지 않았더라도 어떤 작업을 시작해야 하는지 알 수 있습니다.\n\n# 일관된 학습\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-07-01-5HabitsThatMadeMeADataScientist_2.png)\n\n가장 중요한 습관은 지속적인 학습입니다. 계속된 실습과 매일 조금씩 하는 것으로만 능숙해지게 됩니다. 매일 1%씩 향상되면 지수적인 성장을 이룰 수 있다는 것을 지금쯤은 다 들어봤을 거에요.\n\n- 매일 1%씩 향상되면 1.0¹³⁶⁵ ~ 38이 됩니다.\n- 매일 1%씩 감소하면 0.9⁹⁹³⁶⁵ ~ 0.026이 됩니다.\n\n![image](/assets/img/2024-07-01-5HabitsThatMadeMeADataScientist_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n이것은 흔한 속담이지만 매우 정확합니다. 최대한 이를 잘 활용해야 합니다.\n\n매일 새로운 주제 학습이나 기술 향상에 시간을 할애합니다. ML 이론 공부, 코딩 문제 도전, 온라인 기사 읽기 등이 해당됩니다. 정말 간단한 것도 괜찮으니 복잡하게 생각하지 마세요.\n\n조금씩 하는 모든 것이 중요하니, 하루에 시간을 할애하려 노력해보세요. 아무리 30분이라도 괜찮습니다.\n\n이 습관을 위해 추천하는 조언 몇 가지는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 하루를 시간 블록으로 나누어 학습과 공부 시간을 확보하세요. 저는 통근 시간을 학습 시간으로 활용하는 흔한 습관을 가지고 있어요.\n- Medium과 뉴스레터 등 다양한 플랫폼에 가입하고 데이터 과학 및 머신 러닝 YouTube 채널을 구독하세요.\n- 배우고 싶은 것들을 항상 기록으로 남겨두어 아이디어가 항상 있도록 해보세요.\n\n# 목표와 로드맵\n\n![Data Scientist](/assets/img/2024-07-01-5HabitsThatMadeMeADataScientist_4.png)\n\n앞서 말한 습관들은 매우 중요하지만, 명확한 로드맵이나 목표 없이는 방향성이 부족할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n목표를 가지고 성취하려는 것이 도움이 될 거예요. 예를 들어, 때로는 \"신경망을 배우고 PyTorch로 구현해보기\"와 같은 목표가 있습니다. 현실적으로 말하면 매우 모호하지만, 공부하고 배우는 동안 목표를 향해 나아갈 수 있는 방향을 제공합니다.\n\n로드맵은 대학에서 받는 공부 계획서와 비슷하므로 구조적인 학습을 도와주고 각 부분이 서로 이어질 수 있도록 합니다. 일반적으로 사용해야 하는 자료들도 함께 제시되므로 이를 통해 시간을 절약할 수 있습니다.\n\n저는 데이터 과학과 시계열, 그리고 딥러닝과 같은 기술 영역을 공부할 때 로드맵을 따랐습니다. \"다음에 뭘 해야할까?\"나 \"이건 어떻게 배워야할까?\"라는 생각하는 시간을 아낄 수 있어서 공부 속도가 매우 빨라졌습니다. 모든 것이 포괄적으로 제공되어서 제반 여건에 구애받지 않고 자료에 순수하게 집중할 수 있었죠.\n\n수많은 로드맵이 있으며, 제가 직접 만든 로드맵도 아래에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n이 습관에 대한 내 주요 조언은:\n\n- 이루고 싶은 명확한 최종 목표를 설정하세요.\n- 로드맵을 만드세요; 거의 모든 것이 충분합니다.\n\n# 자신을 비교하지 마세요\n\n![이미지](/assets/img/2024-07-01-5HabitsThatMadeMeADataScientist_5.png)\n\n<div class=\"content-ad\"></div>\n\n요즘 사회에서 흔한 문제 중 하나는 비교입니다. 온라인 세계 덕분에 많은 사람들과 비교하게 되는데, 종종 사람들은 자신의 실패를 거의 올리지 않기 때문에 그들의 하이라이트만 보게 됩니다(나도 이 점에 대해서 반성해야 합니다).\n\n또한, 당신보다 앞서 있는 모든 사람들을 보게 되고, 우리는 대개 상승하는 방향으로 비교를 하며, 한 번도 뒤를 돌아보지 않는 경향이 있습니다.\n\n괜히 지나치게 감상적이 되지 않으면서, 당신은 오직 자기 자신과만 비교해야 합니다. 다른 사람들은 불필요하며, 항상 내적인 관심에 초점을 맞춰야 합니다.\n\n매튜 맥커너히의 생각을 한 번 받아들이세요. 그는 2014년 아카데미 시상식에서 최우수 남우주연상을 받았을 때 이렇게 말했습니다...\n\n<div class=\"content-ad\"></div>\n\n자기 자신을 믿고 스스로를 개선하려는 마음가짐이 우리 모두가 추구해야 하는 태도입니다. 항상 자기 자신과의 싸움이죠.\n\n다른 사람들을 걱정하기보다 자신의 발전에 초점을 맞춰보세요. 더 오래 걸릴지도 모르고 아니면 더 빠를지도 모르지만, 그건 중요하지 않아요. 중요한 건 여러분이 나아지고 있다는 것입니다. 모두에게 걱정하는 대신에 자신에게 집중할수록 발전 속도가 더 빨라지고 즐겁게 느껴질 거예요.\n\n데이터 과학은 가장 혁신적이고 지적이며 열심히 일하는 사람들로 가득찬 분야입니다. 세계 최고의 데이터 과학자가 되지는 못할 것이고 항상 여러분보다 더 나은 사람이 있을 거에요.\n\n여러분을 막으려는 것이 아니라 자신을 비교하는 것이 헛된 일이라는 것을 보여주려는 것이에요. 따라서 방금 말했던 것처럼 항상 내적으로 바라보고 발전하려 노력해보세요.\n\n<div class=\"content-ad\"></div>\n\n내 주요 조언은:\n\n- 남들과 그들의 성취에 대해 지나치게 많이 읽는 걸 피하세요.\n- 다른 사람들에게 영감을 받으려고 하고, 시기하는 대신 그들로부터 영감을 받으세요.\n\n# 인내\n\n![이미지](/assets/img/2024-07-01-5HabitsThatMadeMeADataScientist_6.png)\n\n<div class=\"content-ad\"></div>\n\n큰 성과를 이루는 데에는 시간이 걸립니다. 데이터 과학의 경우, 인내심을 가지고 학습 과정을 경주가 아닌 여정으로 받아들이는 것이 중요합니다.\n\n내 개인적인 여정을 되돌아보면, 데이터 과학과 같이 복잡한 분야를 마스터하는 데에는 장기적인 헌신이 필요하다는 것을 받아들였습니다. 거의 3년간 데이터 과학자로 일해왔지만, 여전히 기초만 다진 느낌이 드는 것 같아요.\n\n온라인 동영상과 기사들에서는 3개월 만에 데이터 과학을 배우고 취업할 수 있다고 말하는 경우가 많습니다. 이는 이전 코딩 지식이나 STEM 학과 박사 학위와 같은 상당한 이점을 가진 일부 사람들에게는 사실일 수 있지만, 다수에게는 해당되지 않을 수 있습니다.\n\n그래서, 여정을 몇 달 진행했을 때 정보를 습득하기 힘들고 이해하기 어려운 경우가 있다면, 시간을 주세요. 지금은 데이터 과학이나 기계 학습과 같은 분야를 배울 때 고려해야 할 시간적 척도를 보여주는 전문 대학에서 3년간의 본전문 학사 과정이 이미 존재합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 저는 현재 데이터 과학과 머신 러닝의 엔지니어링 및 배포 측면에 대해 더 배우고 싶어합니다. 이것을 숙달하는 데 몇 년이 걸릴 것이라는 사실을 잘 알고 있습니다. 이 점에 편안함을 느낍니다.\n\n이 부분에 대한 제 주요 조언은 다음과 같습니다:\n\n- 스스로에게 충분한 시간을 주고 필요 이상의 기한을 설정하세요.\n- 여유롭게 여정을 즐기세요!\n\n# 요약 및 추가 생각\n\n<div class=\"content-ad\"></div>\n\n빠르게 습관을 요약해보겠습니다\n\n- 행동 중심: 많이 행동하고 많이 생각하지 말기\n- 일관된 학습: 매일 무언가를 배우려고 노력하기\n- 도메인 지식 및 목표: 명확한 목표를 가지거나 로드맵/강의 계획을 따르기\n- 비교: 다른 사람과 비교하는 대신 자기 자신과 비교하기\n- 인내: 데이터 과학을 배우는 데 시간이 걸립니다; 달보다는 연 단위로 생각하기\n\n이러한 습관을 받아들일 수 있기를 바랍니다. 이 습관들은 저의 능력을 데이터 과학자로 변화시켰으며, 분명히 여러분에게도 똑같은 효과를 가져다 줄 것입니다.\n\n# 또 하나의 중요한 점!\n\n<div class=\"content-ad\"></div>\n\n무료 뉴스레터 'Dishing the Data'를 운영 중이에요! 매주 더 나은 데이터 과학자가 되는 데 도움이 되는 조언, 제 경험, 그리고 최근 주에 생각한 것들을 공유하고 있어요.\n\n# 함께 소통해요!\n\n- LinkedIn, X (Twitter), 또는 Instagram.\n- 기술적인 데이터 과학과 머신 러닝 개념을 배울 수 있는 내 YouTube 채널!","ogImage":{"url":"/assets/img/2024-07-01-5HabitsThatMadeMeADataScientist_0.png"},"coverImage":"/assets/img/2024-07-01-5HabitsThatMadeMeADataScientist_0.png","tag":["Tech"],"readingTime":6},{"title":"Android window-size 클래스를 사용하여 대화면에 최적화하기","description":"","date":"2024-07-01 16:54","slug":"2024-07-01-Getyourandroidappreadyforlargerscreensizesusingwindow-sizeclassesonandroid","content":"\n\n## 왜 우리는 더 큰 화면 크기를 지원해야 할까요?\n\n안드로이드는 스마트폰 뿐만 아니라 태블릿, 데스크톱 (크롬 OS), 폴더블, 자동차 및 스마트 TV에도 실행됩니다. 현재 30억 대 이상의 활성 장치에서 실행되고 있습니다. 개발자로써 우리는 모든 플랫폼에서 원활한 경험을 제공하기 위해 노력합니다. 폴더블 기기는 현재 핫 토픽으로 각 스마트폰 브랜드가 자체 버전을 출시하고 있습니다. 이러한 기기는 폰부터 태블릿 크기의 디스플레이로 동적으로 화면 크기를 변경합니다.\n\n## 대형 화면 크기를 지원하는 방법은?\n\n모든 화면 크기를 지원하려면 레이아웃을 적응형으로 만들어야 합니다. 이렇게 하면 화면 크기에 따라 크기를 조정할 수 있습니다. 안드로이드에서는 윈도우 사이즈 클래스를 사용하여 이를 달성합니다. 이 클래스는 화면 크기의 고수준 추상화를 제공하여 간단한 유형인 compact, medium, expanded를 제공하므로 화면 크기에 기반한 UI 디자인 결정을 쉽게 할 수 있습니다. 예를 들어, compact 모드에서는 네비게이션 바나 모델 네비게이션 드로어를 표시합니다. 이 클래스에는 2가지 윈도우 사이즈 클래스가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 높이\n- 너비\n\n![이미지](/assets/img/2024-07-01-Getyourandroidappreadyforlargerscreensizesusingwindow-sizeclassesonandroid_0.png)\n\n현재 윈도우 크기를 얻으려면 libs.versions.toml에 의존성을 추가해보세요.\n\n```js\n[versions]\nmaterial3AdaptiveNavigationSuite = \"1.3.0-beta04\"\n\n[libraries]\nandroidx-material3-adaptive-navigation-suite = { module = \"androidx.compose.material3:material3-adaptive-navigation-suite\", version.ref = \"material3AdaptiveNavigationSuite\" }\n```\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 변경하고 build.gradle.kts(module:app) 파일에 이를 정의하세요.\n\n```kotlin\ndependencies {\n    // NavigationSuiteScaffold\n    implementation(libs.androidx.material3.adaptive.navigation.suite)\n}\n```\n\n이 종속성을 추가하면 다음과 같은 두 가지 이점이 있습니다.\n\n- 첫 번째로, currentWindowAdaptiveInfo() 함수를 사용하여 높이와 너비에 대한 창 크기 클래스에 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nval windowSizeClass = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass\n```\n\n그래서 우리가 이런 식으로 UI 디자인 결정을 할 수 있어요.\n\n```kotlin\n@OptIn(ExperimentalMaterial3AdaptiveApi::class)\n@Composable\nfun App(\n    widthSizeClass: WindowWidthSizeClass\n) {\n    // 크기 클래스에 따라 네비게이션 레일을 표시할지 결정하는 로직을 수행합니다.\n    val isExpanded = windowSizeClass == WindowWidthSizeClass.EXPANDED\n\n    Row {\n        if (isExpanded) {\n            NavigationRail {\n                NavigationRailItem(\n                    /* ... */\n                )\n            }\n        }\n        DefaultNavGraph(/* ... */)\n    }\n}\n```\n\n2. 두 번째로, NavigationSuiteScaffold에 액세스할 수 있어서 창 크기에 따라 네비게이션 UI 결정 로직을 단순화할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n윈도우 크기가 콤팩트하거나 테이블-탑(수평) 위치에 있으면 하단 탐색바가 표시되고, 그 외에는 네비게이션 레일이 표시됩니다.\n\n## 어느 화면 크기에 어떤 네비게이션 레이아웃이 가장 적합한가요?\n\nMaterial Design 가이드라인에 따르면, 윈도우 크기 클래스는 다음과 같습니다.\n\n- 콤팩트(너비 ` 600 dp): 네비게이션 바, 모달 네비게이션 드로어 사용\n- 중간(600 dp≤ 너비 ` 840 dp): 네비게이션 레일, 모달 네비게이션 드로어 사용\n- 확장(840 ≤ 너비 ` 1200*): 네비게이션 레일, 모달 또는 표준 네비게이션 드로어 사용 (확장되었을 경우 ListDetailPaneScaffold를 사용하여 목록-세부 화면을 사용할 경우 2 패인 레이아웃 사용)\n\n<div class=\"content-ad\"></div>\n\n## 실제 데모를 확인해 보겠습니다\n\n이미 언급했듯이 NavigationSuiteScaffold를 사용하면 우리의 작업이 정말 간단해집니다. 창 크기 클래스를 기반으로 한 로직을 직접 작성할 필요가 없습니다. NavigationSuiteScaffold가 제공해주는 기능입니다. 데모를 살펴보겠습니다. 그리고 창 크기 클래스를 기반으로 네비게이션 레이아웃을 수동으로 표시하는 방법도 배워보겠습니다.\n\n## 무엇을 만들까요??\n\n![image](/assets/img/2024-07-01-Getyourandroidappreadyforlargerscreensizesusingwindow-sizeclassesonandroid_1.png)\n\n<div class=\"content-ad\"></div>\n\n이 앱에서는 화면의 내용에 집중하지 않고 현재 위치인 텍스트만 표시합니다. 창 크기에 따라 네비게이션 레이아웃을 표시하는 것이 우리의 목표입니다.\n\n이를 구현해 봅시다.\n\n이미 필요한 종속 항목인 마테리얼 3의 네비게이션 스위트를 추가했으므로 코드에 집중해 봅시다.\n\n최상위 목적지로, 열거형 클래스를 추가했습니다. 그 코드는 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nenum class AppDestinations(\n    @StringRes val label: Int,\n    val icon: ImageVector,\n    @StringRes val contentDescription: Int\n) {\n    HOME(R.string.home, Icons.Default.Home, R.string.home),\n    DRAWING(R.string.draw, Icons.Default.Draw, R.string.draw),\n    EDIT(R.string.edit, Icons.Default.Edit, R.string.edit),\n    SETTINGS(R.string.profile, Icons.Default.Person, R.string.settings),\n}\n```\n\n그리고 NavigationSuiteScaffold를 호출하고 필요한 인수를 전달합시다.\n\nNavigationSuiteScaffold를 사용할 때 창 크기 클래스를 기반으로 하는 네비게이션 레이아웃을 구현하는 것이 얼마나 쉬운지 코드에서 확인할 수 있습니다. Window-size 클래스에 대한 단일 조건문을 작성할 필요가 없습니다.\n\n원한다면 더 맞춤화할 수도 있습니다. 창 크기에 따라 다른 네비게이션 레이아웃을 표시하려면 NavigationSuiteScaffold에 layoutType이라는 매개변수를 전달하여 할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nval adaptiveInfo = currentWindowAdaptiveInfo()\n\n/* 선택 사항 */\nval customNavSuiteType = with(adaptiveInfo) {\n    if (windowSizeClass.windowWidthSizeClass == WindowWidthSizeClass.EXPANDED) {\n        NavigationSuiteType.NavigationRail\n    } else {\n        NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(adaptiveInfo)\n    }\n}\n```\n\n여기서는 창 클래스를 기반으로 네비게이션 레이아웃을 사용자 정의합니다. 현재 EXPANDED 화면에 있는 경우 네비게이션 바 대신 네비게이션 레일을 표시하며, 아래 조건을 충족하면 레이아웃 화면이 EXPANDED로 고려됩니다:\n\n- 가로 방향으로 사용하는 휴대전화\n- 가로 방향으로 사용하는 태블릿\n- 가로 방향으로 사용하는 폴더블 (펼쳐진 상태)\n- 데스크톱 (Chrome OS)\n\n이제 NavigationSuiteScaffold를 사용하는 방법을 알아보았습니다. 이제 더 맞춤화된 옵션으로 넘어가 봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n# Window-Size-Classes를 사용하여 네비게이션 레이아웃 결정 처리하기\n\n이제 Window-Size-Class를 기반으로 한 네비게이션 레이아웃 처리 방법을 살펴보겠습니다.\n\n코드에서 보듯이, 화면 크기에 따라 조건부로 Navigation Rail을 표시하는 방법은 다음과 같습니다.\n\n```js\nval isExpanded = widthSizeClass == WindowWidthSizeClass.EXPANDED\n```\n\n<div class=\"content-ad\"></div>\n\nMainActivity.kt에서 이 함수를 호출해보세요.\n\n```kotlin\nYourAppTheme{\n    val windowWidthSizeClass = currentWindowAdaptiveInfo().windowSizeClass\n    OsbApp(windowWidthSizeClass.windowWidthSizeClass) // 여기서 너비 사이즈 클래스를 사용합니다.\n}\n```\n\n앱을 실행하면 창 크기에 따라 적절한 내비게이션 레이아웃이 표시됩니다.\n\n<img src=\"/assets/img/2024-07-01-Getyourandroidappreadyforlargerscreensizesusingwindow-sizeclassesonandroid_2.png\" />\n\n<div class=\"content-ad\"></div>\n\nNavigationSuiteScaffold 데모의 소스 코드는 이 저장소에서 확인할 수 있습니다:\n\n이 글에서는 대형 화면 크기에서 최고의 사용자 경험을 제공하는 방법과 사용 사례에 대해 배웠습니다. 이 글이 마음에 드시길 바랍니다. 그렇다면, 이 이야기에 박수를 보내고 친구나 가족과 공유해주세요. 다음 흥미로운 주제로 다가오는 글에서 뵙겠습니다.\n\n무바라크.엠 바샤 드림","ogImage":{"url":"/assets/img/2024-07-01-Getyourandroidappreadyforlargerscreensizesusingwindow-sizeclassesonandroid_0.png"},"coverImage":"/assets/img/2024-07-01-Getyourandroidappreadyforlargerscreensizesusingwindow-sizeclassesonandroid_0.png","tag":["Tech"],"readingTime":6},{"title":"Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법","description":"","date":"2024-07-01 16:51","slug":"2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose","content":"\n\n![image](/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png)\n\nℹ: 가끔 실수를 하거나 완전히 정확하지 않은 정보를 공유할 수도 있어요. 완벽하지 않으니 참고용으로만 사용해 주세요. 뭔가 이상하다고 느껴지면 공식 문서나 블로그를 확인하는 것이 좋아요.\n\n# ✨ 소개\n\n\"설정\" 메뉴를 응용 프로그램에 포함시키는 것이 표준적인 규칙이 되었습니다. 사용자의 선호에 맞춰 인터페이스를 사용자 정의할 수 있는 기능을 제공하여, 예를 들어 밝은 테마와 어두운 테마 간 전환 또는 알림을 켜거나 끄기 등이 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n“Settings” 정보는 사용자 기기에 지속적으로 저장되어 있어야 합니다 (앱이 삭제될 때까지). 그렇지 않으면 사용자가 앱을 닫을 때마다 저장된 사용자 설정이 손실되어 설정을 다시 처음부터 구성해야 합니다.\n\n이를 염두에 두고 오늘은 앱 설정 정보를 지속적으로 저장하기 위해 주로 사용되는 DataStore (Preferences)의 기본 구현 방법을 소개하겠습니다!\n\n# ☛ 구현 전 고려사항\n\nDataStore (Preferences) API를 사용하면 데이터를 키-값 형식으로 저장하고 관리할 수 있습니다. 그 자체로는 과도하게 복잡하지 않지만 구현에는 다음과 같은 기본 지식을 이해해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n- ViewModel을 사용한 UI 상태 관리의 기본 사항\n- Kotlin에서 비동기 처리의 기본 사항 (Coroutine)\n- DI (의존성 주입)의 기본적인 이해\n\n만약 이러한 주제들을 이해하지 못하고 있다면, 제가 소개할 샘플 코드의 역할을 이해하기 어려울 수도 있습니다.\n\n제가 작성한 글 속 코드에 대해 가능한 많은 설명을 제공하겠지만, 모든 세부 내용을 다 다루기는 이 글의 범위를 벗어나므로, 일정 수준의 이전 지식을 갖고 있다고 가정하겠습니다. 샘플 코드가 무엇을 하는지 완전히 이해할 수 없다면, Jetpack Compose와 Kotlin의 기본을 다시 공부하는 것이 좋을 수도 있습니다.\n\n아래는 참고 링크입니다 (공식 Google 및 Kotlin 문서):\n\n<div class=\"content-ad\"></div>\n\n- ViewModel: [라이브러리 안드로이드 뷰모델 참조](https://developer.android.com/reference/kotlin/androidx/lifecycle/ViewModel)\r\n- Kotlin 코루틴: [코루틴 개요 코틀린 문서](https://kotlinlang.org/docs/coroutines-overview.html)\r\n- Kotlin Flow: [코틀린 Flow 문서](https://kotlinlang.org/docs/flow.html)\r\n- DI (의존성 주입): [의존성 주입 안드로이드 교육](https://developer.android.com/training/dependency-injection)\n\n하지만 저자로서 제 생각으로는 코드를 즉시 이해하지 못해도 전혀 괜찮습니다. 코드를 그대로 복사하여 붙여넣고 '세부 정보를 모르겠지만 작동했다!' 라고 생각하는 지점에 도달하는 것도 중요한 단계입니다.\n\n기본을 이해하는 것은 필수적이지만, 코드의 의미가 처음에 분명하지 않더라도 진행하는 것은 괜찮습니다. 완전한 이해 없이 전진하는 것은 학습 과정의 중요한 부분일 수 있습니다.\n\n# ☛ 앱의 UI 확인\n\n<div class=\"content-ad\"></div>\n\n이번에는 사용자가 사용자 이름을 입력하고 SAVE 버튼을 탭하면 해당 사용자 이름이 기기에 영구적으로 저장되고 저장된 사용자 이름이 표시되는 앱을 만들고 싶어요.\n\n완성된 앱은 아래 이미지처럼 보일 거예요.\n\n![Image](/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_1.png)\n\n완료되면 \"SAVE\" 버튼을 탭한 후에도 앱을 닫아도 사용자 이름이 계속 저장되어 있어야 합니다. 그러나 \"SAVE\" 버튼을 탭했을 때 아무런 작업도 수행되지 않도록 해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n사용자 이름이 표시되는 부분은 \"Hi, Name?\"으로 일단 고정 값으로 설정해보겠습니다.\n\n아래는 앱의 메인 화면(MainScreen.kt)에 대한 임시 코드입니다:\n\n```kotlin\n@Composable\nfun MainScreen(\n   modifier: Modifier = Modifier\n) {\n\n   var userInput by remember {\n       mutableStateOf(\"\")\n   }\n\n   Column(\n       modifier = modifier.fillMaxSize(),\n       verticalArrangement = Arrangement.Center,\n       horizontalAlignment = Alignment.CenterHorizontally\n   ) {\n       Text(\n           text = \"Hi, Name?\",\n           style = MaterialTheme.typography.displaySmall,\n           modifier = Modifier\n               .padding(top = 32.dp)\n       )\n       TextField(\n           value = userInput,\n           onValueChange = { userInput = it },\n           modifier = Modifier\n               .padding(vertical = 32.dp)\n       )\n       Button(\n           onClick = { /*TODO*/ }\n       ) {\n           Text(text = \"SAVE\")\n       }\n   }\n}\n```\n\n현재 SAVE 버튼을 누르면 아무 일도 일어나지 않으며, 앱을 닫으면 입력한 사용자 이름 정보가 손실됩니다.\n\n<div class=\"content-ad\"></div>\n\n# ☛ 1) Dependencies 설정하기\n\n이제 우리가 완성품의 명확한 비전을 갖고 있다면, DataStore (Preferences)의 소개를 진행해 봅시다.\n\n먼저, 의존성을 설정해야 합니다. 다음 의존성을 모듈 레벨의 build.gradle.kts 파일에 추가해주세요. (참고: ViewModel도 필요하므로 DataStore와 함께 나열되어 있습니다.)\n\n```js\n/* build.gradle.kts */\n// ViewModel 추가\nimplementation(\"androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0\")\n\n// DataStore preferences 추가\nimplementation(\"androidx.datastore:datastore-preferences:1.0.0\")\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드에서는 이 글을 작성하는 시점에서 사용 가능한 최신 안정 버전을 지정했습니다. 그러나 구현할 때 사용 가능한 최신 안정 버전을 확인하고 지정하는 것이 좋습니다.\n\n코드를 추가한 후 '지금 동기화'를 클릭하여 동기화하세요. 이 시점에서 특별히 어려운 점은 없어야 합니다.\n\n# ☛ 2) UserRepository.kt 추가\n\n이제 본격적으로 시작합니다. 이 부분에서는 DataStore(Preferences)를 사용하여 기기에 사용자 설정 정보(이 경우 사용자 이름)를 영구적으로 저장하는 논리를 작성할 겁니다.\n\n<div class=\"content-ad\"></div>\n\n우선, 이 패키지와 파일이 UI가 아닌 데이터를 관리하는 것임을 명확히 하기 위해 \"data\"라는 이름의 패키지를 생성하세요.\n\ncom.example.projectname 패키지에서 마우스 오른쪽 버튼을 클릭하고 \"새 패키지\"를 선택한 후 \"data\"라고 입력하여 생성하세요.\n\n![image](/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_2.png)\n\ndata 패키지를 생성한 후에 이 패키지 내부에 UserRepository란 이름의 Kotlin 파일을 만드세요. 만들 때 Class를 선택해주세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_3.png\" />\n\n특정 패키지에 파일을 추가하는 프로세스는 이후 단계에서도 동일합니다.\n\n지금은 생성된 UserRepository.kt 파일의 UserRepository 클래스에서 DataStore(Preferences)를 사용하는 로직을 작성할 예정입니다.\n\n먼저 DataStore를 사용할 때는 애플리케이션의 최상위 컨텍스트를 사용해야 하므로, 생성자로 dataStore라는 DataStore 타입을 지정해줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n/* UserRepository.kt */\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\n\nclass UserRepository(private val dataStore: DataStore<Preferences>) {\n  \n}\n\n\n이렇게 하면 UserRepository 클래스 내에서 컨텍스트를 정의할 필요가 없고, UserRepository 클래스는 오직 DataStore에 대한 로직만을 처리할 수 있습니다.\n\nDataStore(Preferences)에서 데이터는 키 및 값으로 관리되며, 여기서 다루는 값은 문자열인 사용자 이름입니다. 따라서 stringPreferencesKey()를 사용하여 다음과 같이 문자열 값이 포함된 키를 정의합니다:\n\n\n/* UserRepository.kt */\nimport androidx.datastore.preferences.core.stringPreferencesKey\n\nclass UserRepository(private val dataStore: DataStore<Preferences>) {\n    private companion object {\n        val USER_NAME = stringPreferencesKey(\"user_name\")\n    }\n}\n\n\n<div class=\"content-ad\"></div>\n\n프라이빗 컴패니언 객체로 정의하면 각 Preferences 키를 클래스 내에서 한 번만 존재하는 정적 객체(싱글톤)로 관리할 수 있습니다. 사용자 이름만 관리하는 것은 쉽지만, 다른 설정을 토글하거나 관리해야 하는 경우처럼 여러 키를 관리해야 하는 경우에는 컴패니언 객체를 사용하는 것이 더욱 유리합니다.\n\n다음으로, 장치에 저장된 문자열 타입 값에 대한 속성을 정의합니다. 이는 데이터 스토어를 생성자로 받은 데이터의 데이터를 map()으로 확장하고, 앞서 컴패니언 객체에서 정의한 키를 지정하여 달성할 수 있습니다.\n\n```js\n/* UserRepository.kt */\nclass UserRepository(private val dataStore: DataStore<Preferences>) {\n   private companion object {\n       val USER_NAME = stringPreferencesKey(\"user_name\")\n   }\n\n   val currentUserName: Flow<String> =\n       dataStore.data.map { preferences ->\n           preferences[USER_NAME] ?: \"Unknown\"\n       }\n}\n```\n\n⚠️참고: 실제로는 데이터를 읽는 작업이 실패할 경우를 대비하여 에러를 처리하고 해당 코드를 포함해야 합니다. 그러나 코드를 간단하게 유지하기 위해 여기에서는 생략하였습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 이 설정으로 데이터를 읽을 수만 있기 때문에, 데이터를 저장하거나 업데이트하는 메소드를 추가해 봅시다. edit()를 사용하여 전달된 문자열을 저장하는 메소드를 추가해 보세요.\n\n```js\n/* UserRepository.kt */\nclass UserRepository(private val dataStore: DataStore<Preferences>) {\n   private companion object {\n       val USER_NAME = stringPreferencesKey(\"user_name\")\n   }\n\n   val currentUserName: Flow<String> =\n       dataStore.data.map { preferences ->\n           preferences[USER_NAME] ?: \"알 수 없음\"\n       }\n\n   suspend fun saveUserName(userName: String) {\n       dataStore.edit { preferences ->\n           preferences[USER_NAME] = userName\n       }\n   }\n}\n```\n\n이로써 DataStore (Preferences)를 사용하기 위한 세 가지 필수 구성 요소가 완성되었습니다:\n\n- 문자열을 값으로 가지는 키를 설정하는 것\n- 값을 읽을 수 있는 프로퍼티\n- 값을 저장할 수 있는 메소드\n\n<div class=\"content-ad\"></div>\n\nUserRepository.kt 파일의 코드 작성이 완료되었습니다.\n\n하지만 우리는 아직 데이터 저장소를 생성자로 받을 준비를 하지 않았기 때문에 아직 작동하지 않을 것입니다. 다음 단계에서는 애플리케이션 컨텍스트를 사용할 준비를 하겠습니다.\n\n# ☛ 3) MyApplication 클래스 추가 및 설정\n\n이 단계에서는 UserRepository에서 사용할 애플리케이션 컨텍스트를 구성할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n먼저, com.example.projectname 패키지 내에 MyApplication.kt라는 파일을 만들어주세요 (클래스로 지정).\n\n그런 다음, MyApplication.kt 파일의 MyApplication 클래스 바깥에서 dataStore를 Context 확장 속성으로 정의하고 특정 DataStore 인스턴스에 위임해주세요.\n\n```js\n/* MyApplication.kt */\nprivate val Context.dataStore: DataStore<Preferences> by preferencesDataStore(\n   name = \"setting\"\n)\nclass MyApplication {\n}\n```\n\n이를 통해 어플리케이션의 모든 부분이 동일한 Context를 통해 DataStore에 액세스할 수 있게 되어 데이터 일관성을 보장하고 코드 재사용성을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* MyApplication.kt */\nprivate val Context.dataStore: DataStore<Preferences> by preferencesDataStore(\n  name = \"setting\"\n)\nclass MyApplication: Application() {\n  lateinit var userRepository: UserRepository\n  override fun onCreate() {\n    super.onCreate()\n    userRepository = UserRepository(dataStore)\n  }\n}\n```\n\nuserRepository은 이전 단계에서 생성된 UserRepository 클래스를 상속받지만, 당연히 여기에서 초기화할 수 없습니다(데이터 스토어인 생성자를 지정할 수 없기 때문). 따라서 애플리케이션이 초기화될 때 이전에 정의한 Context.dataStore가 UserRepository 클래스로 전달되어야 합니다.\n\n이 과정은 애플리케이션 전체에서 일관된 데이터 저장 메커니즘을 제공하여 UserRepository 클래스가 이 데이터 스토어를 사용하여 사용자 설정 및 정보를 관리할 수 있도록 합니다. 결과적으로 데이터 저장, 검색 및 업데이트가 애플리케이션 내의 어디에서든 쉽게 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 단계의 마지막에 AndroidManifest.xml 파일의 애플리케이션 태그에 android:name을 다음과 같이 추가하는 것을 잊지 마세요:\n\n```js\n<!-- AndroidManifest.xml -->\n<application\n   android:name=\".MyApplication\">\n```\n\n이 사양을 따르면 MyApplication 클래스에 정의된 종속성이 MainActivity가 시작되기 전에 초기화됩니다.\n\nMyApplication 클래스와 관련된 코딩 및 설정이 이제 완료되었지만, 코드의 역할과 의미가 간결함 때문에 이해하기 어려울 수 있다는 것을 이해합니다.\n\n<div class=\"content-ad\"></div>\n\n이 단계에서는 \"DataStore(Preferences)와 애플리케이션 컨텍스트(전체 앱을 통틀어 말하는 맥락)를 사용할 수 있게 해준다\"는 넓은 이해를 바탕으로 시작하는 것이 좋아요.\n\n# ☛ 4) ViewModel 추가 및 구성하기\n\n이전 단계에서 DataStore(Preferences)를 사용할 준비가 되었지만, 현재 상태에서는 UI가 어떤 변경 사항도 반영하지 않을 것입니다. 이번 단계에서는 ViewModel을 사용하여 UI의 책임을 처리하여 앱을 완성에 더 가깝게 이끌 것입니다.\n\n먼저, 샘플.com.프로젝트명 `ui` 패키지 내에 MyAppViewModel이라는 파일을 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n자연스럽게 MyAppViewModel 클래스는 응용 프로그램 컨텍스트에 따라 다르게 구성된 UserRepository 클래스의 속성 및 메서드를 활용할 것입니다. 따라서 MyAppViewModel 내에서 UserRepository를 직접 사용할 수 없습니다. 대신에 다음과 같이 생성자로 userRepository를 지정합니다:\n\n```js\n/* MyAppViewModel.kt */\nimport androidx.lifecycle.ViewModel\nimport com.example.datastoresample.data.UserRepository\n\nclass MyAppViewModel(\n   private val userRepository: UserRepository\n): ViewModel() {\n  \n}\n```\n\n이렇게 함으로써 UserRepository 클래스가 응용 프로그램 컨텍스트에 의존하고 있고, MyAppViewModel 클래스가 UserRepository 클래스에 의존하고 있는 관계를 설정했습니다. MyAppViewModel이 초기화될 때 UserRepository가 초기화되어야 하므로 ViewModel을 사용하기 어렵다고 걱정할 수도 있겠지만, 이 의존성 문제를 이번 단계의 끝에서 해결할 것입니다.\n\n지금은 의존성 해결을 제외하고, 저장된 사용자 이름을 검색하는 속성을 정의하기 위해 시작하겠습니다. 그 전에, UI 상태를 관리하는 UiState라는 데이터 클래스를 MyAppViewModel 클래스 외부에 정의해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* MyAppViewModel.kt */\ndata class UiState (\n   val userName: String\n)\n\nclass MyAppViewModel(\n   private val userRepository: UserRepository\n): ViewModel() {\n  \n}\n```\n\n그리고 UiState 데이터 클래스를 사용하여 UserRepository 클래스에 정의된 currentUserName 속성에서 데이터를 비동기적으로 로드합니다.\n\n```js\n/* MyAppViewModel.kt */\nclass MyAppViewModel(\n   private val userRepository: UserRepository\n): ViewModel() {\n   val uiState: StateFlow<UiState> =\n       userRepository.currentUserName.map { userName ->\n           UiState(userName)\n       }.stateIn(\n           scope = viewModelScope,\n           started = SharingStarted.WhileSubscribed(5000),\n           initialValue = UiState(\"Unknown\")\n       )\n}\n```\n\nViewModel의 UI 상태(UiState)는 StateFlow 형식으로 관리되어야 하므로, Flow 형식에서 StateFlow 형식으로 변환하고, .stateIn()을 사용하여 구독을 설정하고 초기 값이 설정되도록 합니다.\n\n<div class=\"content-ad\"></div>\n\nSharingStarted.WhileSubscribed(5000)은 구독이 종료된 후 5초 동안 여전히 값이 방출되며, 구독을 취소한 후에도 잠시 동안 UI 구성 요소가 데이터 업데이트를 받을 수 있습니다. 값 구독을 최적화하기 위한 이 조정은 복잡해 보일 수 있지만, 이를 \"값 구독을 최적화하는 설정\"으로 생각할 수 있습니다.\n\n그렇게 하면, 저장된 사용자 이름(문자열) 정보를 UI 상태 관리를 위한 값으로 읽을 준비가 되었습니다. 그 다음으로, 값을 저장하거나 업데이트하는 메서드를 추가해 봅시다. 이는 UserRepository 클래스에서 정의된 것과 비슷한 방식으로 구현할 수 있습니다.\n\n```kotlin\n/* MyAppViewModel.kt */\nfun saveUserName(userName: String) {\n    viewModelScope.launch {\n        userRepository.saveUserName(userName)\n    }\n}\n```\n\nUserRepository 클래스에서 정의된 saveUserName() 메서드는 suspend fun으로 정의되어 있기 때문에 coroutine scope 내에서 호출되어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 값을 읽고 저장(업데이트)할 수 있게 되었는데, 남은 문제는 MyViewModel이 UserRepository에 의존하고 UserRepository가 애플리케이션 컨텍스트에 의존하는 문제입니다. 이를 해결해 봅시다.\n\n다음과 같이 MyViewModel 클래스에 companion object를 정의하세요:\n\n```js\n/* MyAppViewModel.kt */\ncompanion object {\n   val Factory: ViewModelProvider.Factory = viewModelFactory {\n       initializer {\n           val application = (this[APPLICATION_KEY] as MyApplication)\n           MyAppViewModel(application.userRepository)\n       }\n   }\n}\n```\n\n이전 코드와 비교했을 때, 처음에는 더욱 불분명해 보일 수 있습니다. 그러나 이 코드의 목적은 MyAppViewModel의 인스턴스를 생성할 때 애플리케이션 컨텍스트로부터 필요한 종속성(이 경우 userRepository)을 주입하는 것입니다. 이를 통해 ViewModel을 테스트하고 재사용하기 쉬워지며 종속성을 명시적으로 관리할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n본질적으로, 이 사용자 정의는 ViewModel (MyAppViewModel)을 초기화할 때 발생하여 MyAppViewModel이 UserRepository에 의존하는 문제를 해결합니다.\n\n마지막 단계는 초기에 제시된 MainScreen.kt를 수정하여 버튼을 탭할 때 데이터(사용자 이름)를 영구적으로 저장하고 저장된 데이터를 문자열로 표시하여 앱을 완성하는 것입니다.\n\n# ☛ 5) 뷰 업데이트\n\n지금까지의 단계에서 DataStore (Preferences)를 사용하여 지속적인 데이터 저장 및 검색을 준비했으며 ViewModel을 사용하여 UI를 관리했습니다. 이제 MainScreen.kt를 업데이트하여 ViewModel을 통해 저장된 데이터가 UI에 반영되도록 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n먼저, 다음과 같이 MainScreen()에 MyAppViewModel을 매개변수로 지정하세요.\n\n```js\n/* MainScreen.kt */\n@Composable\nfun MainScreen(\n   modifier: Modifier = Modifier,\n   myAppViewModel: MyAppViewModel = viewModel(factory = MyAppViewModel.Factory)\n) { … }\n```\n\nMyAppViewModel에서 정의된 Factory를 factory 매개변수에 전달함으로써, 이 MyAppViewModel의 초기화는 이전 챕터에서 설정한 사용자 지정 초기화 설정이 적용됩니다.\n\n다음으로 UI 상태(이 경우 저장된 사용자 이름)를 정의하려면 MainScreen 함수 내에서 savedUserName을 다음과 같이 정의하세요:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n/* MainScreen.kt */\nval savedUserName by myAppViewModel.uiState.collectAsState()\n\nText(\n   text = \"안녕하세요, ${savedUserName.userName}님\",\n   style = MaterialTheme.typography.displaySmall,\n   modifier = Modifier\n       .padding(top = 32.dp)\n)\n```\n\n마지막으로, TextField에 입력된 문자열이 버튼을 클릭했을 때 저장되도록 하려면, onclick 매개변수에 전달할 함수를 설정하면 됩니다. 이렇게 하면 끝이죠.\n\n```kotlin\n/* MainScreen.kt */\nButton(\n   onClick = { myAppViewModel.saveUserName(userInput) }\n) {\n   Text(text = \"저장\")\n}\n```\n\n앱을 빌드하고 사용자 이름을 입력한 후 SAVE 버튼을 탭한 다음, 앱을 완전히 종료하고 다시 엽니다.\n\n\n<div class=\"content-ad\"></div>\n\n아래 저장된 데이터가 앱을 종료한 후에도 지워지지 않고 유지되는 것을 확인할 수 있습니다.\n\n잘 했어요! 이렇게 하면 DataStore (Preferences)의 기본 구현이 완료됩니다.\n\n<div class=\"content-ad\"></div>\n\n# ☛ 마무리로\n\n개발 초보자들이 필요한 코드를 외우기에 집중하는 경향이 있다는 것을 알았어요. 하지만, 중요한 것은 코드를 외우는 것이 아니에요. 시험이 아니기 때문에, 과거에 작성한 코드를 잊어버렸을 때는 열심히 다시 작성하기보다는 그냥 복사해서 붙여넣는 것이 괜찮아요.\n\n실제로, 무언가를 구현할 때마다 코드를 처음부터 쓰는 대신, 한 번 작성한 코드를 템플릿으로 관리하는 것이 더 효율적하다고 생각해요. Git이나 클라우드 서비스를 사용해서 작성한 코드를 손쉽게 재사용할 수 있게 만들어두면 좋아요.\n\n하지만, 코드를 복사하고 붙여넣을 때도 그 코드가 무엇을 의미하는지와 어떤 역할을 하는지 이해하는 것이 중요해요.\n\n<div class=\"content-ad\"></div>\n\n\"I'm happy to help you out! However, I might not fully understand the requested change. It's important to avoid blindly copying and pasting code; instead, try to understand its purpose to improve your coding skills. Here is the code snippet in Markdown format:\n\n\n```js\n<aside>\n <p>\n   Thank you for reading!<br>\n   If you enjoyed this post, <br>\n   I'd appreciate claps. 😄\n </p>\n</aside>\n```","ogImage":{"url":"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png","tag":["Tech"],"readingTime":15}],"page":"2","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}