{"pageProps":{"posts":[{"title":"Nestjs에서 구조화된 API 응답 처리 방법","description":"","date":"2024-06-22 02:19","slug":"2024-06-22-NestjsStructuredAPIResponse","content":"\n\n\n![이미지](/assets/img/2024-06-22-NestjsStructuredAPIResponse_0.png)\n\nNest.js에는 미리 정의된 HTTP 응답 JSON 구조가 있습니다:\n\n```js\n{\n  \"statusCode\": 500,\n  \"message\": \"Internal server error\"\n}\n```\n\n응답 구조를 변경해야 하는 경우 더 많은 세부 정보를 추가하거나 이름이나 구조를 변경해야 할 수도 있습니다.\n때로는 클라이언트(프론트엔드 또는 다른 서비스 클라이언트)를 위해 보다 구체적인 응답 구조를 정의해야 할 수도 있습니다.\n컨트롤러 라우트의 끝에 사용자 정의 구조 응답을 작성하거나, 어디에서나 사용자 정의 응답을 보내기 위해 객체를 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n가끔은 클라이언트(프론트엔드 또는 다른 서비스 클라이언트)에 대한 보다 구체적인 응답 구조를 정의하는 것이 필요할 수 있습니다.\n\n어떤 경우에는 커스텀한 응답 구조를 작성해야 할 것이라고 생각할 수 있으며, 이를 위해 컨트롤러 루트의 끝에 커스텀 응답을 작성하거나 Response 객체를 사용하여 어디서든지(custom response를 전송할) 다음과 같이 사용할 수 있습니다:\n\n```js\nresponse\n  .status(status)\n  .json({\n    statusCode: status,\n    timestamp: new Date().toISOString(),\n    path: request.url,\n  });\n```\n\n# Class-Validator 응답이 커스텀 API 응답과 충돌합니다!\n\n<div class=\"content-ad\"></div>\n\n우리 모두는 프로젝트에서 입력값을 유효성 검사하는 데 사용하고 있어요.\n이 패키지는 다음과 같은 사전 정의된 오류 구조를 사용해요:\n\n모두, 우리는 프로젝트에서 입력값을 유효성 검사하는 데 class-validator를 사용하고 있어요.\n이 패키지는 다음과 같은 사전 정의된 오류 구조를 사용해요:\n\n```js\n{\n  \"statusCode\": 400,\n  \"message\": [\n    {\n      \"property\": \"firstName\",\n      \"message\": \"firstName must be longer than or equal to 1 characters\"\n    }\n  ],\n  \"error\": \"Bad Request\"\n}\n```\n\n이 패키지를 사용할 때 코드에서는 class-validator 응답 구조와 호환되는 API 응답 구조를 사용하는 것이 좋아요. \"property\"를 클라이언트 측에 활용하여 오류를 적절한 위치(예: \"property\" 하단)에 표시할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 서버에서 다국어 API 응답\n\n다국어 플랫폼에서는 서버 측에서 오류 또는 메시지를 생성해야 할 경우가 있습니다. 클라이언트 측에서는 단순히 서버에서 받은 메시지를 표시해야 합니다. 이러한 경우에는 API 응답에 메시지를 포함해야 하며 이때 클라이언트가 메시지를 적절한 위치에 표시할 수 있도록 가이드하는 속성 필드가 포함되어야 합니다.\n\n# 사용자 정의 응답 구조를 어떻게 정의할까요?\n\n코드를 DRY하게 작성하고 복잡성을 줄이며 코드를 유지보수 가능하고 개발 가능하도록 해결해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Let's Magic 🪄\n\n다국어 및 class-validator와 호환되는 사용자 지정 응답을 정의하는 좋은 방법을 찾아봅시다:\n\n- API 응답 유형 정의:\n\n```js\nexport class messagesType {\n  message: string\n  property:string\n}\nexport class ApiResponseDto<T> {\n  statusCode: number;\n  messages: messagesType[] | [];\n  data: T;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n응답 데이터를 처리하기 위해 일반 유형을 사용하고 메시지를 메시지와 속성 필드를 포함한 배열로 만듭니다.\n\nutils 서비스 또는 더 나은 곳에서 이 메서드를 정의할 수 있습니다:\n\n```js\napiResponse<T>(statusCode: number, data: any = null, message: { message: string, property: string }[] | [] = []): ApiResponseDto<T> {\n    return {\n        statusCode,\n        message,\n        data,\n    };\n}\n```\n\n이 메서드는 API 응답 구조를 생성하여 반환하며, 유효성 검사, 살균 또는 원하는 모든 것을 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3. 이제 컨트롤러에서 메소드를 사용하여 반환하세요:\n\n```js\nreturn this.utilsService.apiResponse(\n    HttpStatus.OK,\n    functionReult,\n    [{message:\"email subscribed to newsletter\",property:\"email\"}]\n )\n```\n\n4. apiResponseDto에 timeStamp, route 등의 데이터를 추가할 수 있어요. ✌️\n\n이제 API 응답 결과를 즐기세요 ❤️.\n질문은 언제든 환영이고, API 응답 구조에 대한 의견을 남겨주세요. 더 나아지도록 도와드릴게요.","ogImage":{"url":"/assets/img/2024-06-22-NestjsStructuredAPIResponse_0.png"},"coverImage":"/assets/img/2024-06-22-NestjsStructuredAPIResponse_0.png","tag":["Tech"],"readingTime":3},{"title":"NodeJS에서 자식 프로세스 멀티태스킹을 구현하는 방법","description":"","date":"2024-06-22 02:16","slug":"2024-06-22-ChildProcessesMultitaskinginNodeJS","content":"\n\n## 자식 프로세스, Spawn, Exec, ExecFile, Fork, IPC의 심층 탐험\n\n![Child Processes](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_0.png)\n\n이 글은 시니어 엔지니어를 위한 고급 NodeJS 시리즈의 다섯 번째 글입니다. 이 글에서는 자식 프로세스가 어떻게 작동하는지, 왜 필요한지, 어떻게 사용하는지를 자세히 설명하고 자식 프로세스를 사용하여 최상의 성능을 얻는 방법을 알려드리겠습니다. 공식 문서에서 자식 프로세스에 대한 자세한 내용을 확인할 수 있습니다.\n\n[고급 NodeJS 시리즈의 다른 글들](#)\n\n\n글 시리즈 로드맵\n\n* V8 JavaScript 엔진\n* NodeJS의 비동기 I/O\n* NodeJS의 이벤트 루프\n* 워커 스레드: NodeJS에서의 멀티태스킹\n* 자식 프로세스: NodeJS에서의 멀티태스킹 (이 글)\n* 클러스터링과 PM2: NodeJS에서의 멀티태스킹\n* NodeJS에 대한 흔한 오해의 해소\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\n콘텐츠 테이블\n\n* 자식 프로세스란 무엇인가요?\n* 왜 필요한 것인가요?\n  * 외부 프로그램 실행\n  * 향상된 격리성\n  * 향상된 확장성\n  * 향상된 견고성\n* 자식 프로세스 생성\n  * 프로세스 생성을 위해 .spawn() 사용\n  * 프로세스 생성을 위해 .fork() 사용\n  * 프로세스 생성을 위해 exec() 사용\n  * 프로세스 생성을 위해 execFile() 사용\n  * 동기식 프로세스 생성\n  * 언제 어떤 것을 사용해야 할까요?\n* 자식 프로세스 중단/중지/종료하기\n* 자식 및 부모 프로세스 간 I/O 처리\n  * 스트림을 함께 연결하기\n* 명령 실행 시 보안\n* 자식 프로세스가 부모 프로세스와 독립적으로 실행되도록 설정\n* spawn을 사용하여 쉘 구문 및 부모의 표준 I/O 상속 사용\n```\n\n# 자식 프로세스란 무엇인가요?\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1080/1*4FmkxDXT9kOVn-b2x6onYA.gif\" />\n\nNodeJS 애플리케이션을 실행하면 VS Code, VLC Player 등과 같이 다른 애플리케이션을 실행할 때와 마찬가지로 자체 프로세스를 가집니다. 이 프로세스의 속성은 글로벌 객체의 process 변수에 사용 가능하며 해당 값을 Node 앱 코드에서 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nNodeJS는 본질적으로 단일 스레드이지만 동기화, CPU 집약 작업을 실행해야 하는 경우와 같이 멀티 프로세스가 필요한 경우가 있을 수 있습니다. 여기서 자식 프로세스가 등장합니다. node:child_process 모듈을 사용하면 부모 프로세스와 자식 프로세스 간의 통신 채널인 IPC(Inter Process Communication)을 설정할 수 있습니다.\n\n이 모듈은 긴 작업을 처리하는 데만 한정되지 않고 운영 체제와 쉘 명령을 실행하는 능력이 있습니다. 간단히 말해, 이는 JavaScript뿐만 아니라 Git, Python, PHP 또는 다른 언어도 실행할 수 있도록 해줍니다.\n\n# 그렇다면 왜 필요했을까요?\n\n이미 CPU 집약 작업을 처리하기 위한 워커 스레드가 있는데 왜 자식 프로세스가 필요한지 궁금할 수 있습니다. 워커 스레드는 자체 힙(heap), V8 인스턴스 및 이벤트 루프를 갖고 있기 때문입니다. 하지만 동일한 프로세스 내에서 스레드보다 별도의 서브 프로세스가 더 바람직한 경우가 있습니다. 왜 그런지 설명하겠습니다:\n\n<div class=\"content-ad\"></div>\n\n## 외부 프로그램 실행\n\n자식 프로세스를 사용하면 외부 프로그램이나 스크립트를 별도의 프로세스로 실행할 수 있습니다. 다른 실행 파일과 상호 작용해야 할 때 매우 유용합니다.\n\n## 향상된 격리성\n\n워커 스레드와 달리, 자식 프로세스는 전체 Node.js 런타임의 별도 인스턴스를 제공합니다. 각 자식 프로세스는 자체 메모리 공간을 가지고 IPC(Inter-Process Communication)를 통해 주 프로세스와 통신합니다. 이러한 수준의 격리는 자원 충돌이나 분리되어야 하는 종속성이 있는 작업에 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n## 향상된 확장성\n\n자식 프로세스는 여러 프로세스 사이에서 작업을 분산하여 멀티 코어 시스템의 성능을 활용할 수 있습니다. 이를 통해 더 많은 동시 요청을 처리하고 응용 프로그램의 전체적인 확장성을 향상시킬 수 있습니다.\n\n## 향상된 안정성\n\n자식 프로세스가 어떤 이유로 인해 충돌하더라도 주 프로세스는 함께 무너지지 않습니다. 이는 응용 프로그램이 실패에도 불구하고 안정적이고 강건하게 유지됨을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n일꾼 스레드는 특정 시나리오에서 좋지만, 자식 프로세스는 외부 프로그램 실행, 격리 제공, 확장성 향상 및 견고성을 보장하는 멋진 장점을 제공합니다.\n\n# 자식 프로세스 생성\n\nchild_process 모듈을 사용하면 운영 체제 기능에 액세스할 수 있습니다. 해당 모듈은 자식 프로세스 내에서 시스템 명령을 실행하는 경우에 사용됩니다. 이러한 자식 프로세스는 동기적 및 비동기적으로 생성할 수 있습니다.\n```javascript\nconst { spawn, fork, exec, execFile } = require('child_process');\n```\n\nchild_process.spawn(), child_process.fork(), child_process.exec(), child_process.execFile() 메서드는 서브 프로세스를 비동기적으로 생성하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n각 메소드는 ChildProcess 인스턴스를 반환합니다. 이러한 객체들은 Node.js EventEmitter API를 구현하며, 부모 프로세스가 자식 프로세스의 라이프 사이클 중 특정 이벤트가 발생할 때 호출되는 리스너 함수를 등록할 수 있습니다. 예시는 다음과 같습니다.\n\n- `disconnect` 이벤트는 부모 프로세스에서 subprocess.disconnect() 메소드를 호출한 후에 발생하거나 자식 프로세스에서 process.disconnect() 메소드를 호출한 후에 발생합니다.\n- 에러 이벤트는 프로세스가 스폰되거나 종료되거나 자식 프로세스로 메시지를 보내는 데 실패했거나 자식 프로세스로 메시지를 보내는 데 실패할 때 발생합니다.\n- `close` 이벤트는 자식 프로세스의 stdio 스트림이 닫힐 때 발생합니다. 이는 `exit` 이벤트와 구별됩니다. 여러 프로세스가 동일한 stdio 스트림을 공유할 수 있기 때문입니다. `close` 이벤트는 항상 `exit`가 이미 발생한 후에 발생하거나 자식이 스폰에 실패한 경우에는 `error`가 발생합니다.\n- `exit` 이벤트는 자식 프로세스가 종료된 후에 발생합니다.\n- 메시지 이벤트는 가장 중요한 이벤트입니다. 이 이벤트는 자식 프로세스가 process.send() 함수를 사용하여 메시지를 보낼 때 발생합니다. 부모/자식 프로세스가 서로 통신하는 방법입니다.\n- `spawn` 이벤트는 자식 프로세스가 성공적으로 생성되면 한 번 발생합니다. 자식 프로세스가 성공적으로 생성되지 않으면 `spawn` 이벤트가 발생하지 않고 대신 `error` 이벤트가 발생합니다.\n\n## 프로세스 생성을 위해 .spawn() 사용하기\n\n.spawn() 메소드를 사용하여 명령어를 실행할 때 전달하려는 인수, 명령을 실행할 때 사용할 인수의 문자열 배열 형식, 마지막으로 프로세스 생성 시 일부 설정을 재정의할 수 있는 options 객체를 전달하여 자식 프로세스를 생성할 수 있습니다. 이 설정에는 환경 변수인 env, 명령을 셸 내에서 실행할지 여부인 shell, 부모가 종료된 후에도 자식 프로세스를 계속 실행할지 여부인 detached, 자식 프로세스를 중단하는 데 사용할 수있는 signal 등이 포함됩니다. 이러한 옵션에 대한 자세한 정보는 spawn의 공식 문서에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n.spawn() 메서드가 다른 프로세스 생성 메서드와 다른 점은 외부 응용 프로그램을 새로운 프로세스에서 생성하고 I/O용 스트리밍 인터페이스를 반환한다는 것입니다. 이때문에 데이터가 많이 생성되는 애플리케이션을 처리하거나 데이터가 읽히는 대로 작업하는 데 좋습니다. 스트림 기반의 I/O는 다음과 같은 이점을 제공할 수 있습니다:\n\n- 낮은 메모리 풋프린트.\n- 백프레셔를 자동으로 처리합니다.\n- 버퍼링된 청크 단위로 데이터를 게으르게 생성하거나 소비합니다.\n- 이벤트 기반이며 논블로킹입니다.\n- 버퍼를 사용하여 V8 힙 메모리 제한을 회피할 수 있습니다.\n\n각각의 자식 프로세스는 세 가지 표준 stdio 스트림을 갖는데, 이를 child.stderr, child.stdout(각각 읽기 가능한 스트림), child.stdin(쓰기 가능한 스트림)을 통해 액세스할 수 있습니다. 이러한 스트림들은 이벤트 이밋터입니다. 각 자식 프로세스에 연결된 stdio 스트림 들에서 다양한 이벤트를 감지할 수 있습니다. child.stdout와 child.stderr의 경우 데이터 이벤트를 수신하여 명령의 출력이나 명령 실행 중 발생한 오류를 확인할 수 있습니다.\n\n예를 들어 ls -lh /usr를 실행하고 stdout, stderr 및 종료 코드를 캡처하는 예제를 살펴보겠습니다. 이 예제는 리눅스/유닉스 시스템에서 실행해보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { spawn } = require('node:child_process');\nconst ls = spawn('ls', ['-lh', '/usr']);\n\nls.stdout.on('data', (data) => {\n    console.log(`stdout: ${data}`);\n});\n\nls.stderr.on('data', (data) => {\n    console.error(`stderr: ${data}`);\n});\n\nls.on('close', (code) => {\n    console.log(`child process exited with code ${code}`);\n});\n```\n\n<img src=\"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_1.png\" />\n\n한 발 더 나아가 복잡한 예제로 가보죠. 여기서는 ps | grep bash를 실행해볼 겁니다. ps 명령은 현재 진행 중인 프로세스를 반환하고 grep은 일치하는 패턴을 찾을 때 유용한 명령입니다. 여기서는 'bash'를 찾아보겠습니다. ps를 위해 하나의 프로세스가 시작될 것이며, ps.stdout의 출력 스트림을 grep의 입력 스트림으로 작성하려고 합니다. ps가 끝나면 grep의 입력 스트림을 끝내고 grep 명령이 실행될 것입니다. 아래 내용은 index.js 내부에 작성해야 합니다.\n\n```js\nconst { spawn } = require('node:child_process');\nconst ps = spawn('ps');\nconst grep = spawn('grep', ['bash']);\n\nps.stdout.on('data', (data) => {\n    grep.stdin.write(data);\n});\n\nps.stderr.on('data', (data) => {\n    console.error(`ps stderr: ${data}`);\n});\n\nps.on('close', (code) => {\n    if (code !== 0) {\n        console.log(`ps process exited with code ${code}`);\n    }\n    grep.stdin.end();\n});\n\ngrep.stdout.on('data', (data) => {\n    console.log(data.toString());\n});\n\ngrep.stderr.on('data', (data) => {\n    console.error(`grep stderr: ${data}`);\n});\n\ngrep.on('close', (code) => {\n    if (code !== 0) {\n        console.log(`grep process exited with code ${code}`);\n    }\n});\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_2.png)\n\n한번 더 예시를 살펴보겠습니다. 여기서는 명령을 실행하는 과정에서 spawn이 실패하는 예제입니다.\n\n```js\nconst { spawn } = require('node:child_process')\nconst subprocess = spawn('bad_command')\n\nsubprocess.on('error', (err) => {\n console.error('서브프로세스 시작 실패.')\n})\n```\n\n![Image](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_3.png)\n\n\n<div class=\"content-ad\"></div>\n\nWindows에서 실행할 때는 .bat 및 .cmd 파일을 shell 옵션을 설정하여 child_process.spawn()로 호출하거나 child_process.exec()를 사용하거나 cmd.exe를 생성하고 .bat 또는 .cmd 파일을 인수로 전달하는 방법(즉 shell 옵션과 child_process.exec()가 하는 방식)으로 호출할 수 있습니다. 어떤 경우에도 스크립트 파일 이름에 공백이 포함되어 있다면 인용 부호로 감싸야 합니다.\n\n## 프로세스 생성에 .fork() 사용하기\n\n.fork()는 Node.js 스크립트를 새로운 프로세스에서 실행하고 두 프로세스 간에 IPC 통신 채널을 원할 때 특히 유용합니다. child_process.fork() 메서드는 새로운 Node.js 프로세스를 생성하는 데 사용하는 child_process.spawn()의 특수한 경우입니다. child_process.spawn()과 마찬가지로 ChildProcess 객체가 반환됩니다. 반환된 ChildProcess에는 부모와 자식 간에 메시지를 교환할 수 있는 추가 통신 채널이 내장되어 있습니다.\n\nfork 메서드는 노드 프로세스 간 메시지 전달을 허용하는 IPC 채널을 열게 됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 자식 프로세스에서는 process.on('message')와 process.send('부모에게 메시지')를 사용하여 데이터를 수신하고 전송할 수 있습니다.\n- 부모 프로세스에서는 child.on('message')와 child.send('자식에게 메시지')를 사용합니다.\n\n간단한 예시를 살펴봅시다. index.js 파일입니다.\n\n```js\nconst { fork } = require('child_process');\n\nconst forked = fork('child_program.js');\n\nforked.on('message', (msg) => {\n  console.log('자식으로부터 메시지:', msg);\n});\n\nforked.send('안녕 세계');\n```\n\nchild_program.js 파일에서는\n\n<div class=\"content-ad\"></div>\n\n```js\nprocess.on('message', (msg) => {\n  console.log('부모로부터 온 메시지:', msg);\n});\n\nlet counter = 0;\n\nsetInterval(() => {\n  process.send({ counter: counter++ });\n}, 1000);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*CpWRroHhVhSmzrIwyE4zbw.gif\" />\n\n부모로부터 자식에게 메시지를 전달하려면 포크된 객체 자체에서 send 함수를 실행하고, 자식 스크립트에서는 전역 process 객체의 메시지 이벤트를 수신할 수 있습니다.\n\n상기 parent.js 파일을 실행하면 먼저 `hello world`를 포크된 자식 프로세스에서 출력하도록 전송한 다음, 포크된 자식 프로세스는 매 초마다 증가된 카운터 값을 부모 프로세스가 출력하도록 전송합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 더 실용적인 내용의 예시를 살펴보겠습니다. 아래 예시는 각각 \"일반\" 또는 \"특별\" 우선순위로 연결을 처리하는 두 개의 자식 프로세스를 생성합니다:\n\nindex.js 파일에서:\n\n```js\nconst { fork } = require('node:child_process');\nconst normal = fork('child_program.js', ['normal']);\nconst special = fork('schild_program.js', ['special']);\n\n// 서버를 열고 소켓을 자식 프로세스로 전달합니다. 소켓이 자식 프로세스로 전송되기 전에 읽히지 않도록 pauseOnConnect를 사용합니다.\nconst server = require('node:net').createServer({ pauseOnConnect: true });\nserver.on('connection', (socket) => {\n\n  // 특별한 우선순위인 경우...\n  if (socket.remoteAddress === '74.125.127.100') {\n    special.send('socket', socket);\n    return;\n  }\n  // 일반 우선순위인 경우.\n  normal.send('socket', socket);\n});\nserver.listen(1337); \n```\n\nchild_program.js 파일에서:\n\n<div class=\"content-ad\"></div>\n\n```js\nprocess.on('message', (m, socket) => {\n  if (m === 'socket') {\n    if (socket) {\n      // 클라이언트 소켓이 있는지 확인합니다.\n      // 소켓이 전송된 후 자식 프로세스에서 수신되는 동안 소켓이 닫힐 수 있습니다.\n      socket.end(`Request handled with ${process.argv[2]} priority`);\n    }\n  }\n}); \n```\n\n상기 예제에 따르면 remoteAddress에 따라 소켓이 해당 자식 프로세스로 전달됩니다. 특정 remoteAddress인 경우 특별한 서브프로세스로, 그렇지 않은 경우 일반 서브프로세스로 전달됩니다. 서브프로세스에 전달된 소켓에 .maxConnections를 사용하지 마십시오. 부모 프로세스는 소켓이 소멸된 시점을 추적할 수 없습니다. 서브프로세스의 `message` 핸들러는 소켓이 존재하는지 확인해야 합니다. 소켓이 전달되는 동안 연결이 닫힐 수 있습니다.\n\n## process 생성을 위한 exec() 사용\n\nexec 함수는 쉘 구문을 사용해야 하고 명령에서 예상되는 데이터의 크기가 작은 경우 좋은 선택입니다. exec 함수는 명령에서 생성된 출력을 버퍼링하고 전체 출력 값을 콜백 함수에 전달합니다 (spawn이 스트림 대신에 사용하는 것입니다).\n\n<div class=\"content-ad\"></div>\n\n워커가 셸을 설정하고 해당 셸 내에서 명령을 실행합니다. 콜백 함수가 제공된 경우에는 해당 함수가 (error, stdout, stderr) 인자를 사용하여 호출됩니다. 성공할 경우 error는 null이 됩니다. 오류 발생 시 error는 Error의 인스턴스가 됩니다. error.code 속성은 프로세스의 종료 코드가 됩니다. 콜백에 전달된 stdout 및 stderr 인자에는 자식 프로세스의 표준 출력 및 표준 오류 출력이 포함됩니다.\n\n간단한 예제를 살펴봅시다. cat 명령어로 index.js 파일을 읽고 wc -l 명령어로 결과의 라인 수를 세어 보겠습니다.\n\n```js\nconst { exec } = require('node:child_process')\nexec('cat index.js | wc -l', (error, stdout, stderr) => {\n if (error) {\n  console.error(`exec error: ${error}`)\n  return\n }\n console.log(`stdout: ${stdout}`)\n console.error(`stderr: ${stderr}`)\n})\n```\n\n![그림](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_4.png)\n\n<div class=\"content-ad\"></div>\n\n이 exec에 추가할 수있는 흥미로운 특징은 Options 개체에서 몇 가지 설정을 제공하는 것입니다. 예를들어 cwd 옵션을 사용하여 스크립트의 작업 디렉토리를 변경할 수 있습니다. 예를들어, 위의 예제를 다른 디렉토리에서 실행하도록 설정할 수 있습니다.\n\n아래의 Markdow 형식으로 표를 변경해주셔야합니다.\n\nSince the exec function uses a shell to execute the command, we can use the shell syntax directly here making use of the shell pipe feature.\n\n## Using execFile() for process creation\n\n<div class=\"content-ad\"></div>\n\n그 파일을 쉘을 사용하지 않고 실행해야 할 경우, execFile 함수가 필요합니다. 이 함수는 exec 함수와 정확히 동일하게 작동하지만 쉘을 사용하지 않기 때문에 조금 더 효율적입니다.\n\n```js\nconst { execFile } = require('node:child_process');\nconst child = execFile('node', ['--version'], (error, stdout, stderr) => {\n  if (error) {\n    throw error;\n  }\n  console.log(stdout);\n});\n```\n\n![Child Processes in Node.js](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_6.png)\n\nWindows에서는 .bat 또는 .cmd 확장자와 같이 특정 파일은 자체로 실행할 수 없습니다. 이러한 파일은 execFile로 실행할 수 없으며, 실행하려면 exec 또는 spawn을 shell 속성을 true로 설정하여 실행해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 동기적 프로세스 생성\n\n.spawnSync, .execSync 및 .execFileSync 메서드는 동기적이며 Node.js 이벤트 루프를 차단하며, 생성된 프로세스가 종료될 때까지 추가 코드의 실행을 일시 중지합니다.\n\n이러한 차단 호출은 주로 일반 스크립팅 작업을 간소화하고 시작시 응용 프로그램 구성의 로드/처리를 간단화하는 데 유용합니다.\n\n## 언제 어떻게 사용해야 하나요?\n\n<div class=\"content-ad\"></div>\n\n\n![Child Processes Multitasking in NodeJS](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_7.png)\n\n# 자식 프로세스 중지 및 종료\n\n자식 프로세스를 종료하는 몇 가지 방법이 있습니다.\n\n- ChildProcess 객체에서 .kill()을 사용하여.\n- 옵션 객체의 타임아웃 옵션을 사용함으로서. 프로세스가 실행되는 최대 시간을 밀리초로 설정해야 합니다. 기본값: 정의되지 않음\n- 시그널을 사용하여, 시그널 옵션이 활성화된 경우, 해당 AbortController에서 .abort()를 호출하는 것은 child 프로세스에서 .kill()을 호출하는 것과 유사하게 동작하지만 콜백에 전달된 오류가\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { spawn } = require('node:child_process');\nconst controller = new AbortController();\nconst { signal } = controller;\nconst grep = spawn('grep', ['ssh'], { signal });\ngrep.on('error', (err) => {\n  // controller가 중단되면 AbortError가 err로 전달될 것입니다\n});\ncontroller.abort(); // 차일드 프로세스를 중지합니다\n```\n\n# 자식 및 부모 프로세스 간의 I/O 처리\n\nstdio 옵션은 자식 프로세스의 입/출력 대상을 결정하는 데 책임이 있습니다. 이는 배열 또는 문자열로 할당할 수 있습니다. 문자열 값은 흔히 사용되는 배열 구성으로 자동 변환되는 편리한 바로 가기로 작동합니다.\n\n기본적으로 stdio는 다음과 같이 구성됩니다\nstdio: 'pipe'\n다음과 같은 배열 값의 단축키입니다:\nstdio: [ 'pipe', 'pipe', 'pipe' ]\n\n\n<div class=\"content-ad\"></div>\n\n위 코드는 ChildProcess 객체가 파일 기술자 0부터 2까지 액세스 제공하는 스트림 (child.stdio[0], child.stdio[1], child.stdio[2])를 갖게 됨을 의미합니다.\n\n만약 입출력을 다른 곳으로 보내려면 파일 기술자를 할당할 수 있는 옵션이 있습니다. 반면, 완전히 무시하고 싶다면 'ignore'를 사용할 수도 있습니다.\n\n예를 통해 설명해보겠습니다. 예를 들어 입력을 제공하지 않을 자식 프로세스를 생성하고자 한다면 입력 FD 0 (stdin)을 무시하고 출력 FD 1(stdout)과 오류 FD 2(stderr)를 별도의 로그 파일에 기록하려는 경우에 대해 알아봅시다. 이렇게 구현할 수 있습니다.\n\n```js\nlet fs = require('fs')\nlet cp = require('child_process')\n\nlet outFd = fs.openSync('./outputlogs', 'a')\nlet errFd = fs.openSync('./errorslogs', 'a')\nlet child = cp.spawn('ls', [], {\n stdio: ['ignore', outFd, errFd]\n})\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_8.png\" />\n\n## 스트림을 연쇄시키기\n\n한 프로세스의 출력이 다음 프로세스에 공급되는 프로그램을 작성해 봅시다. cat 명령어는 데이터를 파일에서 읽고, 이 데이터를 sort 명령어의 입력으로 전달하여 정렬된 라인을 출력으로 제공할 것이며, 이것은 다시 중복된 줄을 제거할 uniq 명령어의 입력으로 제공되어야 합니다.\n\nin filesToBeChecked.txt\n\n<div class=\"content-ad\"></div>\n\n\nLOL\nLMAO\nROLF\nLOL\nGTG\n\n\n`index.js` 파일에서:\n\n```javascript\nlet cp = require('child_process')\nlet cat = cp.spawn('cat', ['filesToBeChecked.txt'])\nlet sort = cp.spawn('sort')\nlet uniq = cp.spawn('uniq')\ncat.stdout.pipe(sort.stdin)\nsort.stdout.pipe(uniq.stdin)\nuniq.stdout.pipe(process.stdout)\n```\n\n<img src=\"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_9.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n## 명령 실행과 보안\n\n자식 프로세스가 셸에 액세스할 수 있도록 허용할 때 주의해야 합니다. 셸 구문을 사용하는 것이 보안 위험을 초래할 수 있음을 인식하는 것이 중요합니다, 특히 외부 소스에서 동적 입력을 다룰 때 그렇습니다. 이는 사용자가 셸 구문 문자인 ';' 나 '$' 와 같은 문자를 이용하여 악성 명령을 실행할 수 있는 명령 주입 공격의 가능성을 남겨둡니다. 예를 들어 사용자가 command + '; rm -rf ~' 와 같은 명령을 입력하여 중요 파일을 삭제할 수 있습니다.\n\n예시를 살펴보겠습니다. (시스템에서 하지 마세요)\n\n<div class=\"content-ad\"></div>\n\n유저 입력을 받아 명령어를 실행하는 프로세스가 있다고 가정해 봅시다. 이 때, 입력을 받아 실행하는 명령어가 exec를 이용하여 다음과 같이 구성된 경우가 있습니다.\ncp.exec(`고정된 명령어` + req.query.userInput);\n악의적인 사용자가 \" ; rm -rf / ;\" 와 같이 입력을 제공했다고 가정해 봅시다.\n아직 이해가 안 된 분들을 위해 설명드리자면, 이 메시지는 정확히 \"새로운 명령어(;)를 실행하여 파일 시스템의 중심부에 있는 모든 파일과 디렉토리를 강제로 철저히 삭제하고(; rm -rf /), 명령어를 종료시킵니다(;), 뒤에 뭔가가 더 올 경우 처리합니다.\" 를 의미합니다.\n\n만약 셸 기능을 필요로 하지 않고 응용 프로그램을 실행하려면, 실제로 execFile을 사용하는 것이 더 안전하고(그리고 약간 빠릅니다).\ncp.execFile('고정된 명령어', [req.query.schema]);\n\n여기서 악의적인 인젝션 공격은 셸에서 실행되지 않으므로 실패하고, 외부 응용 프로그램은 전달된 인수를 이해하지 못하고 오류를 발생시킬 가능성이 높습니다.\n\n# 부모 프로세스와 독립적으로 실행되는 자식 프로세스\n\n<div class=\"content-ad\"></div>\n\n아래 사항을 주의해야 합니다:\n- 기본적으로 부모 프로세스는 분리된(떨어져 있는) 자식 프로세스의 종료를 기다릴 것입니다.\n- 부모 프로세스와 노드를 연결하는 몇 가지 사항이 있습니다. 부모 프로세스와 자식 프로세스 사이의 참조인 ref 및 부모와 자식 간에 형성된 통신 채널이 있습니다.\n\n자식 프로세스가 독립적으로 실행되도록 만드는 방법은 다음과 같습니다:\n\n- 부모 프로세스가 자식 프로세스 종료 후에도 계속되도록 원한다면, 옵션 객체 중 하나인 option.detached 옵션을 사용할 수 있습니다.\nWindows에서 options.detached를 true로 설정하면 부모 프로세스가 종료된 후에도 자식 프로세스가 계속 실행됩니다. 한 번 활성화되면 다시 비활성화할 수 없습니다.\nWindows 이외의 플랫폼에서 options.detached가 true로 설정된 경우, 자식 프로세스는 새로운 프로세스 그룹 및 세션의 리더로 만들어집니다. 자식 프로세스는 분리되었든 그렇지 않든 부모가 종료되어도 계속 실행할 수 있습니다.\n- 부모의 이벤트 루프에서 자식 프로세스의 참조를 유지하면 부모가 종료되지 않습니다. 이 참조를 제거하려면 해당 childprocess에 .unref()를 호출하면 됩니다. (참조를 다시 추가하려면 .ref()를 호출할 수도 있습니다.)\n- options.stdio는 부모와 자식 간의 채널을 나타냅니다. options.stdio 옵션은 부모와 자식 프로세스 간에 설정되는 파이프를 구성하는 데 사용됩니다. 이 옵션을 'ignore'로 설정하면 이 통신 채널을 무시하도록 지시합니다. 더 많은 정보는 공식 문서를 참조하세요.\n\n부모의 종료를 무시하려면 부모의 stdio 파일 디스크립터를 무시하여 자식 프로세스를 분리하고 또한 부모의 stdio 파일 디스크립터를 무시하도록 설정한 장기 실행 프로세스의 예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { spawn } = require('node:child_process');\n\nconst subprocess = spawn(process.argv[0], ['child_program.js'], {\n  detached: true,\n  stdio: 'ignore',\n});\n\nsubprocess.unref();\n```\n\n더 복잡한 예제를 살펴봅시다. options.stdio를 사용하면 스트림을 어떻게 정의할지 알려줍니다.\n예를 들어, 입력 스트림으로 pipe를 전달하고 출력 스트림으로 파일 설명자를 전달하며 현재 주 프로세스의 에러 스트림을 오류 스트림으로 전달하려면 이 옵션이 [`pipe`, fd, process.stderr]와 같이 설정됩니다.\n모든 std 스트림을 무시하려면 이전 예제와 같이 'ignore'를 전달하면 됩니다. ignore를 전달하는 것은 ['ignore', 'ignore', 'ignore']를 전달하는 것과 동일합니다. ignore 외에도 pipe, inherit, overlapped, ipc, null, undefined와 같은 다른 옵션이 있습니다. 자세한 내용은 공식 문서를 참조하세요.\n\n파일 설명자를 자식 프로세스에게 출력 스트림으로 전달하여 자식이 지정된 파일에 출력을 작성할 수 있도록 하는 방법을 통해 이를 설명해 보겠습니다.\nindex.js에서\n\n```js\nconst fs = require('node:fs')\nconst { spawn } = require('node:child_process')\nconst out = fs.openSync('./out.log', 'a')\n\nconst subprocess = spawn('node', ['child_program.js'], {\n detached: true,\n stdio: ['ignore', out, process.stderr]\n})\n\nsubprocess.unref()\n```\n\n<div class=\"content-ad\"></div>\n\nchild_program.js 파일에는 아래와 같은 내용이 있습니다.\n\n```js\nconst { spawn } = require('node:child_process')\nconst ls = spawn('ls', ['-lh', '/usr'])\n\nls.stdout.on('data', (data) => {\n console.log(`stdout: ${data}`)\n})\n\nls.stderr.on('data', (data) => {\n console.error(`stderr: ${data}`)\n})\n\nls.on('close', (code) => {\n console.log(`child process exited with code ${code}`)\n})\n```\n\n![여기](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_10.png)에서 설명한 예제는 fork를 사용하여 동일한 결과를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst fs = require('node:fs')\nconst { fork } = require('node:child_process')\nconst out = fs.openSync('./out.log', 'a')\n\nconst subprocess = fork('child_program.js', [], {\n detached: true,\n stdio: ['ipc', out, process.stderr]\n})\n\nsubprocess.unref()\r\n```\n\n# 스폰을 사용하여 쉘 구문 및 부모의 표준 IO 상속하기\n\n만약 우리가 원한다면, 생성된 자식 프로세스가 부모의 표준 IO 객체들을 상속받게 할 수 있지만, 더 중요한 것은 스폰 함수가 쉘 구문을 사용하도록 만들 수 있다는 것입니다.\n\n아래 예시를 살펴봅시다.\n\n\n<div class=\"content-ad\"></div>\n\nchild_program.js에 위의 코드를 붙여넣기해주세요.\n\n```js\nconst { spawn } = require('node:child_process')\nconst ls = spawn('ls', ['-lh', '/usr'])\nls.stdout.on('data', (data) => {\n console.log(`stdout: ${data}`)\n})\nls.stderr.on('data', (data) => {\n console.error(`stderr: ${data}`)\n})\nls.on('close', (code) => {\n console.log(`child process exited with code ${code}`)\n})\n```\n\nstdio: `inherit` 및 shell: true을 사용하지 않고\n\nindex.js에서 실행해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { spawn } = require('node:child_process');\nconst ps = spawn('node child_program.js', {\n\n});\n```\n\n![Child Processes Multitasking in Node.js](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_11.png)\n\nspawn 함수가 쉘 구문을 이해하지 못해서 에러가 발생했어요.\n\n새로운 옵션인 shell을 추가해보는 건 어때요?\n\n<div class=\"content-ad\"></div>\n\nin index.js\n\n```js\nconst { spawn } = require('child_process');\nconst ps = spawn('node child_program.js', { shell: true });\n```\n\n![Child Processes Multitasking in NodeJS](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_12.png)\n\nThere are a few things to note here. With the use of `shell: true`, the `spawn` method is now able to interpret the shell syntax and run the `child_program.js`. However, the output of the child process is not visible because the terminal/console we are currently viewing is connected to the main process's standard IO streams, not the subprocess's. To display the output of the child process in the main process's terminal, we need to share the main IO stream with the child process. This can be achieved by using the `stdio: 'inherit'` option.\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 바꿔보세요.\n\n```js\nconst { spawn } = require('node:child_process')\nconst ps = spawn('node child_program.js', {\n stdio: 'inherit',\n shell: true\n})\n```\n\n![Child Processes Multitasking in NodeJS](/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_13.png)\n\n`stdio: 'inherit'` 옵션을 추가해보세요. 코드를 실행하면, 자식 프로세스가 주 프로세스의 stdin, stdout 및 stderr를 상속받게 됩니다. 이로 인해 자식 프로세스 데이터 이벤트 핸들러가 주 프로세스 stdout 스트림에서 트리거되어 결과를 즉시 출력하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n위의 shell: true 옵션 덕분에 전달된 명령어에서 exec와 마찬가지로 셸 구문을 사용할 수 있었습니다. 그러나 이 코드로는 spawn 함수가 제공하는 데이터의 스트리밍 이점도 누릴 수 있습니다.\n\n# 떠나기 전에!\n\n- 더 많은 통찰을 기대해 주세요! 팔로우하고 구독해주세요.\n- 박수 👏 버튼을 클릭하고 누르면 무슨 일이 벌어지는지 보셨나요?","ogImage":{"url":"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_0.png"},"coverImage":"/assets/img/2024-06-22-ChildProcessesMultitaskinginNodeJS_0.png","tag":["Tech"],"readingTime":20},{"title":"LinkedIn에서 만난 수상한 블록체인 구직 제안, 어떻게 대처해야 할까","description":"","date":"2024-06-22 02:14","slug":"2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn","content":"\n\n\n<img src=\"/assets/img/2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn_0.png\" />\n\n몇 일 전에 한 사람이 블록체인 관련 직업으로 나에게 LinkedIn을 통해 연락했어. 그는 내 GitHub 계정을 공유해달라고 하고 나에게 그의 프로젝트를 실행하여 해결책을 확인하라고 했지.\n\n초대장을 받자, 리포지토리가 포크되거나 Codespaces에서 사용되지 않는 걸 깨달았어. 그래도 처음에는 그렇게 심각하게 생각 안 했어. 노트북이 많이 무겁고, 더 이상 불필요한 프로젝트를 설치하고 싶지 않았기 때문에, 결국 Hostinger의 작은 개발 서버에서 실행하기로 결정했어.\n\n코드를 실행하고 결과를 그에게 보냈어. 그는 몇 가지 오류를 지적하고, 특히 node_modules를 설치하기 위해 다음을 강조한 지침을 공유했어.\n\n<div class=\"content-ad\"></div>\n\n\n# 노드 버전 16.20.0이 필요합니다.\nnpm i --force\nnpm start\n\n\n--force 플래그는 레지스트리에서 강제로 설치하여 기존 종속성을 제거하고 새로운 종속성을 설치합니다. 그는 \"적절한\" 종속성이 설치되었는지 확인하기 위해 현재 node_modules 폴더를 지우고 다시 설치하라고 지시했습니다. 물론 나는 의심 없이 그의 지시에 따랐어요.\n\n업데이트된 결과물을 보내자, 그는 VPN, VPS 또는 WSL을 사용했는지 물어보았습니다. 나는 VPN과 VPS를 둘 다 사용했다고 확인했습니다. 그러자, 그는 미안하다며 그의 프로젝트는 VPN을 지원하지 않고 로컬 설치를 요구한다고 말했습니다. 그 순간부터 조금 수상한 것을 느끼기 시작했습니다. 결과가 명확했고 오류도 없었는데 문제가 무엇인지 물어보았습니다. 그는 API가 잘 작동하지 않았다고 주장했습니다.\n\nVPN이 문제가 아니라고 말했는데, 나는 자체 서버에서 실행하고 있고 VPN을 끄어도 아무 영향도 없다고 말했습니다. 그는 그 후 내 OS에 대해 물었고, 나는 Ubuntu를 사용한다고 대답했습니다. 그에게서는 그의 개발팀 문화가 Mac 또는 Windows를 선호하며 개발할 때 VPN을 사용하지 않는다고 응답했습니다 (흠?). \n\n\n<div class=\"content-ad\"></div>\n\n내가 그에게 말했어, \"당신의 프로젝트에 대해 더 많은 세부 정보를 가지게 되면 내 로컬 맥북을 사용해서 개발할 거야.\" 그는 팀 문화 때문에 곧잘 고치길 바란다며 내게 말했어. 난 당신이 이해하길 바랐지만\n\n나는 대답했어, \"프로젝트를 이해하고 뭘 업그레이드할지 더 자세히 말해주시면 당신의 요구 사항에 적응할게요. 지금은 테스트를 위해 배포만 했습니다.\"\n\n그는 괜찮다고 하고 작업 목록을 공유하기 시작했고 예산을 세팅해달라고 했어. 난 주변을 확인하고 나중에 알려줄 거라고 했어.\n\n하루가 지나 그가 다시 나에게 연락해 일이 어떻게 되고 있는지 물었어. 나는 사과하고 그의 요구 사항에 대한 타임라인, 다른 개발자, 그리고 이 프로젝트의 급여에 대해 물었어. 그는 매달 5천-1만 달러를 제안했어.\n\n<div class=\"content-ad\"></div>\n\n깃허브를 다시 확인하기로 결정했는데, 레포에서 제 이름이 지워져 있었어요. 그래서 다시 초대장을 받도록 요청했어요. 새 초대장을 받고 보니 레포가 단 3시간 전에 만들어진 것을 알게 됐어요. 이제 제 의심은 90%까지 올랐어요.\n\n그래도 계속 대화를 이어가기 위해 몇 가지 조건을 제안했어요. 그 모든 것에 동의를 해주었어요. 심지어 첫 달에 $9,000을 요청했을 때도요.\n\n그 동안 다른 격리된 개발 환경을 설정하여 레포를 파헤치기 시작할 수 있도록 했어요. 하루를 들여서 조사를 시작했지만 아무 것도 찾지 못해서 그만두고 제 사업으로 돌아갔어요.\n\n며칠 후, 클라우드 제공업체로부터 서버에 악성 소프트웨어가 발견되었음을 알리는 이메일을 받았어요. 이후 2시간 후, 서버가 리소스 한도를 초과하여 남용으로 중단되었음을 알리는 다른 이메일을 받았어요. 서버를 다시 활성화하기 위해 제공업체에 연락해야 했어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn_1.png\" />\n\n# 의심스러운 조직 제안과 배운 점\n\n처음부터 발견한 몇 가지 의심스러운 점은 다음과 같습니다:\n\n- GitHub 레포지토리가 포킹되거나 Codespaces에서 사용되지 않았습니다.\n- 레포지토리는 최신의 최소한의 커밋으로 새롭게 만들어졌습니다.\n- 로컬 종속성 대신 종속성을 강제로 설치하는 것이 필요했습니다.\n- 팀 및 프로젝트에 대한 의심스러운 정보가 있었습니다.\n- 다양한 조건이 포함된 높은 제안이 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n마침내, 이 경험을 공유하여 다른 사람들에게 새로운 공격 벡터에 대해 알리고 싶어요. 다른 개발자들과 공유해주세요.\n\n그리고 모르는 것을 실행하지 말라는 경고를 꼭 기억해주세요!\n\n관련해서 유용한 기사를 찾아보았습니다:\n\n블록체인 활동을 모니터링하기 위한 도구를 개발했는데, 이는 여기에서 확인할 수 있어요: [https://www.crypitor.com/](https://www.crypitor.com/)\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트는 오픈소스입니다. https://github.com/crypitor/blockchain-webhook\n\n테스트, 피드백 및 생각을 공유해주시면 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn_0.png"},"coverImage":"/assets/img/2024-06-22-IEncounteraSuspiciousBlockchainJobOfferfromLinkedIn_0.png","tag":["Tech"],"readingTime":3},{"title":"BabylonJS 급속 교정 코스 빠르게 배우는 방법","description":"","date":"2024-06-22 02:10","slug":"2024-06-22-CrashcourseinBabylonJS","content":"\n\n이 가이드와 함께 사용할 수 있는 GitHub 저장소가 있습니다. 저장소는 여기에서 찾을 수 있습니다. GitHub 페이지에서 호스팅 된 라이브 앱은 여기에서 볼 수 있습니다.\n\n# Babylon.js란?\n\nBabylon.js는 웹 브라우저 내에서 3D 그래픽을 실시간으로 렌더링할 수 있는 강력한 오픈 소스 3D 엔진입니다. 플러그인이 필요하지 않고 WebGL, WebXR 등의 웹 표준을 활용하여 웹 환경에서 풍부하고 상호 작용적이며 몰입적인 경험을 제공합니다. Babylon.js는 초심자도 쉽게 사용할 수 있도록 설계되었지만, 숙련된 개발자가 복잡하고 고성능의 3D 애플리케이션을 만들기 위해 필요한 심도와 기능을 제공합니다. 이 가이드에서 언제든지 문서를 더 자세히 살펴보고 싶다면 여기에서 찾을 수 있습니다.\n\n![BabylonJS 이미지](/assets/img/2024-06-22-CrashcourseinBabylonJS_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 기본 개발 환경 설정하기\n\nBabylon.js로 몰입형 3D 애플리케이션을 만들기 위해서는 적절한 개발 환경을 설정해야 합니다. 이 설정을 통해 Babylon.js 프로젝트를 효율적으로 개발, 테스트, 배포할 수 있는 필수 도구와 소프트웨어를 갖추게 됩니다. 아래에서 시작하는 데 필요한 주요 사항을 살펴보겠습니다.\n\n소스 파일을 보관할 새 폴더를 만드세요. 이 폴더를 src로 이름 짓을 수 있습니다. 해당 폴더에 다음 내용을 가진 index.html을 추가하세요:\n\n```html\n<html>\n    <head>\n        <title>BabylonJS</title>\n        <!-- 스타일 가져오기 -->\n        <link rel=\"stylesheet\" href=\"./index.css\">\n    </head>\n    <body>\n        <canvas id=\"main\"></canvas>\n        <!-- 스크립트 가져오기 -->\n        <!-- 스크립트 태그에 type=\"module\"을 추가하는 것을 잊지 마세요 -->\n        <script type=\"module\" src=\"./index.js\"></script>\n    </body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n알림: BabylonJS에서 제공하는 CDN 배포를 사용할 수 있습니다. NPM에서 설치하려면 npm install --save babylonjs 명령을 실행한 다음 import * as BABYLON from `babylonjs`; 를 사용하여 자바스크립트 파일에서 가져와야 합니다.\n\n이제 src 디렉토리에 index.css라는 css 파일을 만들어 보겠습니다. 다음 내용을 포함하도록 합니다 (이 파일은 선택 사항이지만 기본 패딩 및 여백과 같은 항목을 제거하여 애플리케이션을 깔끔하게 유지하는 데 도움이 됩니다):\n\n```js\nhtml, body {\n    overflow: hidden;\n    width: 100%;\n    height: 100%;\n    margin: 0;\n    padding: 0;\n}\n#main {\n    width: 100%;\n    height: 100%;\n}\n```\n\n이제 흥미로운 부분, index.js 파일을 만들어 기본 씬을 생성해 보겠습니다. 기본 씬을 생성하는 내용을 파일에 추가해주세요. (지금은 씬이로드되는 것만 확인하려고 합니다. 세부 정보는 나중에 다룰 예정입니다.)\n\n<div class=\"content-ad\"></div>\n\n```js\nvar createScene = function () {\n    // 기본 Babylon Scene 객체를 생성합니다.\n    var scene = new BABYLON.Scene(engine);\n    // 자유 카메라를 생성하고 위치를 조절합니다.\n    var camera = new BABYLON.FreeCamera(\"camera1\", new BABYLON.Vector3(0, 5, -10), scene);\n    // 카메라를 씬의 원점으로 이동시킵니다.\n    camera.setTarget(BABYLON.Vector3.Zero());\n    // 카메라를 캔버스에 부착합니다.\n    camera.attachControl(canvas, true);\n    // 하늘을 향하도록 조명을 생성합니다.\n    var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\n    // 기본 강도는 1입니다. 조명을 약간 어두운 양으로 설정합니다.\n    light.intensity = 0.7;\n    // 구 모양을 생성합니다.\n    var sphere = BABYLON.MeshBuilder.CreateSphere(\"sphere\", {diameter: 2, segments: 32}, scene);\n    // 구를 높이의 반만큼 위로 이동시킵니다.\n    sphere.position.y = 1;\n    // 바닥 모양을 생성합니다.\n    var ground = BABYLON.MeshBuilder.CreateGround(\"ground\", {width: 6, height: 6}, scene);\n    return scene;\n};\n\nvar canvas = document.getElementById(\"main\"); // 캔버스 요소를 가져옵니다.\nvar engine = new BABYLON.Engine(canvas, true); // BABYLON 3D 엔진을 생성합니다.\nvar scene = createScene(); // createScene 함수를 호출합니다.\n// 씬을 반복적으로 렌더링하는 렌더 루프를 등록합니다.\nengine.runRenderLoop(function () {\n    scene.render();\n});\n\n// 브라우저/캔버스 크기 조정 이벤트를 감지합니다.\nwindow.addEventListener(\"resize\", function () {\n    engine.resize();\n});\n```\n\n지금 Parcel로 앱을 실행하면, `npx parcel src/index.html` 명령어로 실행할 수 있습니다. 그러면 구면이 평평한 표면 위에 있는 기본 3D 환경이 출력될 것입니다. BabylonJS 애플리케이션을 만들어서 축하드립니다!\n\n# Babylon.js 애플리케이션 구조 이해\n\nBabylon.js 애플리케이션은 몇 가지 핵심 개념을 중심으로 구성됩니다: 엔진, 씬, 카메라, 조명 및 메쉬입니다. 이러한 요소를 이해하는 것은 Babylon.js 개발을 탐색하고 마스터하는 데 중요합니다. 이 구성 요소가 Babylon.js 애플리케이션의 전체 구조에 어떻게 맞는지 더 자세히 살펴보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 엔진\n\n엔진은 Babylon.js 애플리케이션의 핵심입니다. 브라우저의 캔버스 요소에 그려지는 그래픽을 렌더링하는 역할을 합니다. 엔진은 WebGL과의 인터페이싱과 렌더링 프로세스의 최적화와 같은 복잡한 작업들을 처리합니다.\n\n# 씬\n\n씬은 모든 객체, 조명, 카메라 등을 담는 컨테이너입니다. 3D 세상이 존재하는 가상 공간을 나타냅니다. 씬은 3D 객체가 배치되고 상호 작용하는 무대로 생각할 수 있습니다. Babylon.js에서 씬을 만드는 것은 간단합니다. 엔진을 초기화한 후에는 카메라, 조명, 객체를 모두 포함할 씬 객체를 만들면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar scene = new BABYLON.Scene(engine);\n```\n\n\"scene\"은 여러분이 객체를 추가하고 물리학을 정의하며 안개나 배경색과 같은 환경 조건을 설정할 곳입니다. 이것은 여러분이 3D 세계를 그릴 캔버스입니다. 여기서 Babylon.js 문서에서 Scene에 대해 더 알아볼 수 있습니다.\n\n# Camera\n\n카메라는 장면을 렌더링할 시점을 정의합니다. Babylon.js는 다양한 유형의 카메라를 제공하여 여러 요구 사항을 충족하며, 예를 들어 첫 번째 시점 시점의 자유 카메라나 물체 주위를 공전하는 Arc Rotate Camera와 같은 카메라가 있습니다. 카메라를 설정하는 것은 장면을 보는 데 중요합니다. 간단한 Arc Rotate 카메라를 설정하면 사용자가 한 지점 주위를 공전할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar camera = new BABYLON.ArcRotateCamera(\"카메라\", Math.PI / 2, Math.PI / 4, 10, BABYLON.Vector3.Zero(), scene);\ncamera.attachControl(canvas, true);\n```\n\n이 카메라는 장면의 중심을 중심으로 회전하며 사용자 상호 작용을 위한 컨트롤이 있습니다. 자세한 내용은 여기에서 카메라에 대한 설명서를 확인하세요.\n\n# 빛\n\n빛은 장면의 객체를 조명합니다. 간단한 포인트 라이트는 다음과 같이 생성하고 배치할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nvar light = new BABYLON.PointLight(\"pointLight\", new BABYLON.Vector3(0, 10, 0), scene);\nlight.intensity = 0.95;\n```\n\n이 빛은 공간의 한 점에서 빛을 쏘아 객체에 깊이를 줄 것입니다. Babylon.js 문서에서 더 많은 정보를 찾을 수 있어요.\n\n# 렌더 루프\n\n렌더 루프는 장면을 지속적으로 업데이트하고 렌더링하는 역할을 합니다. 이것은 당신의 Babylon.js 애플리케이션의 게임 루프로, 애니메이션과 상호작용을 펼쳐지게 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nengine.runRenderLoop(function () {\n    // 상자를 y축을 중심으로 회전시킵니다.\n    scene.getMeshByName(\"box\").rotation.y += 0.01;\n    scene.render();\n});\n```\n\n# 도형 및 모델 작업\n\nBabylon.js는 기본적인 기하학적 도형부터 다양한 형식에서 가져온 복잡한 3D 모델까지 다룰 수 있는 포괄적인 기능 세트를 제공합니다. 이 섹션에서는 기본 도형을 만들고 모델을 가져오며 변환 및 애니메이션을 적용하는 방법을 안내합니다.\n\nBabylon.js에는 다양한 미리 정의된 도형이 포함되어 있어 쉽게 장면에 추가할 수 있습니다. 이러한 기본 도형에 대해 자세히 알아보려면 **[Babylon.js documentation](https://doc.babylonjs.com/)**를 확인하십시오.\n\n<div class=\"content-ad\"></div>\n\n간단한 도형을 만드는 방법을 알려드릴게요:\n\n## 구:\n\n```js\nvar sphere = BABYLON.MeshBuilder.CreateSphere(\"sphere\", {diameter: 2, segments: 32}, scene);\nsphere.position = new BABYLON.Vector3(0, 1, 0);\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nvar box = BABYLON.MeshBuilder.CreateBox(\"box\", {height: 2, width: 2, depth: 2}, scene);\nbox.position = new BABYLON.Vector3(5, 1, 0);\n```\n\n# Cylinder:\n\n```js\nvar cylinder = BABYLON.MeshBuilder.CreateCylinder(\"cylinder\", {height: 3, diameter: 2}, scene);\ncylinder.position = new BABYLON.Vector3(-5, 1.5, 0);\n```\n\n이 도형들은 position 속성을 사용하여 월드 공간에 배치되며, 이 속성은 BABYLON.Vector3를 사용하여 X, Y 및 Z축에서의 위치를 지정합니다.\n\n<div class=\"content-ad\"></div>\n\n복잡한 모델로 장면을 풍부하게 만들기 위해서는 그것들을 가져와야 할 것입니다. Babylon.js는 원활한 사용자 경험을 보장하기 위해 비동기 모델 로딩을 지원합니다. .glb, .gltf, .obj 등 다양한 형식의 모델을 가져올 수 있습니다. Babylon.js 문서에서 모델 가져오기에 대해 더 알아보세요.\n\n다음은 ImportMeshAsync를 사용하여 모델을 가져오는 방법입니다:\n\n# 단일 모델 로드:\n\n```js\nBABYLON.SceneLoader.ImportMeshAsync(\"\", \"/models/\", \"house.glb\", scene).then((result) => {\n    const house = result.meshes[0];\n    house.position = new BABYLON.Vector3(0, 0, 0);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 여러 모델 불러오기:\n\n```js\nBABYLON.SceneLoader.ImportMeshAsync([\"model1\", \"model2\"], \"/models/\", \"town.glb\", scene).then((result) => {\n    result.meshes.forEach(mesh => {\n        if (mesh.name === \"model1\") {\n            mesh.position.x = 20;\n        }\n    });\n    const model2 = scene.getMeshByName(\"model2\");\n    if (model2) {\n        model2.rotation.y = Math.PI / 4;\n    }\n});\n```\n\n예제에서 모델을 로드한 후 위치를 변경하려면 Promises를 사용하여 변형을 수행합니다. 그러나 렌더링 루프에서 모델을 변형하려면 모델이 이미 로드되었는지 확인한 후에 변경을 가해야 합니다.\n\n```js\nvar createScene = function () {\n    …\n    BABYLON.SceneLoader.ImportMeshAsync(\"semi_house\", \"https://assets.babylonjs.com/meshes/\", \"both_houses_scene.babylon\");\n    …\n}\n…\nengine.runRenderLoop(function () {\n    // 집을 y축 주위로 회전시킵니다\n    if (scene.getMeshByName(\"semi_house\")) {\n        scene.getMeshByName(\"semi_house\").rotation.y -= 0.01;\n    }\n    scene.render();\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 모델 로딩 및 애니메이션\n\n바빌론.js 프로젝트에 복잡한 모델과 애니메이션을 통합하려면, 모델의 파일 형식에 따라 추가적인 로더를 사용해야 할 수도 있습니다. 바빌론.js는 다양한 파일 유형을 지원하며, 각각의 파일 형식에 따라 해당 로더를 사용해야 할 수 있습니다. 지원되는 파일 유형에 대한 자세한 정보와 해당 로더를 사용하는 방법은 모델 가져오기에 관한 바빌론.js 문서에서 확인할 수 있습니다.\n\n이러한 모델을 처리할 수 있도록 프로젝트에 필요한 로더 스크립트를 HTML에 포함시키세요. .glb 및 .gltf를 포함한 대부분의 3D 모델 형식의 경우, 일반 로더 스크립트가 필요합니다:\n\n```js\n<script src=\"https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js\"></script>\n```\n\n<div class=\"content-ad\"></div>\n\n적절한 로더를 통합하면 Babylon.js 씬 내에서 모델을 가져와 애니메이션을 적용할 수 있습니다. 다음 예시는 .glb 모델을 로드하고, 크기를 조정하며, 미리 정의된 애니메이션을 시작하는 방법을 보여줍니다.\n\n다음 예시는 여기에서 찾을 수 있는 Babylon.js 문서에 있는 모델 가져오는 예시를 기반으로 합니다.\n\n```js\nBABYLON.SceneLoader.ImportMesh(\"\", \"https://assets.babylonjs.com/meshes/\", \"HVGirl.glb\", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {\n var hero = newMeshes[0];\n // 모델 크기 축소\n hero.scaling.scaleInPlace(0.1);\n // 옵션: 캐릭터에 카메라 고정\n // 씬 내에 'camera1'라는 카메라가 있는 경우, 로드된 모델에 초점을 맞추려면 다음 줄의 주석을 해제하세요\n // camera1.target = hero;\n // 'Samba'라는 이름의 특정 애니메이션 그룹을 가져옵니다\n const sambaAnim = scene.getAnimationGroupByName(\"Samba\");\n // 'Samba' 애니메이션 실행\n sambaAnim.start(true, 1.0, sambaAnim.from, sambaAnim.to, false);\n});\n```\n\n이 예시는 지정된 URL에서 \"HVGirl.glb\"라는 모델을 로드하고, 적절한 씬 크기를 위해 크기를 축소한 후 \"Samba\"라는 이름의 애니메이션 그룹을 찾아 재생하는 과정을 보여줍니다. 씬의 상세 정보와 카메라 설정, 모델과 연관된 애니메이션의 이름과 유형에 맞게 예시를 수정하는 것이 중요합니다. 로딩 과정은 비동기적으로 진행되므로 응용 프로그램이 로드되는 중에도 반응성을 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 카메라와 조명\n\nBabylon.js에서 몰입감 있는 3D 장면을 만들기 위해 카메라와 조명을 이해하는 것이 중요합니다. 이러한 요소들은 뷰어가 볼 수 있는 것뿐만 아니라 장면을 어떻게 인식하는지도 제어합니다. 이 섹션에서는 Babylon.js에서 제공되는 다양한 종류의 카메라와 조명을 소개하고 그림자와 반사를 구현하는 기술을 소개하여 장면의 현실성과 깊이를 높이는 방법을 알려드리겠습니다.\n\n다양한 종류의 카메라 및 사용 시기\n\n- FreeCamera: 첫인칭 또는 탐험 중심 경험에 이상적인 FreeCamera는 사용자가 키보드와 마우스 입력으로 장면을 자유롭게 탐색하고 뷰를 제어할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar camera = new BABYLON.FreeCamera(\"freeCamera\", new BABYLON.Vector3(0, 5, -10), scene);\ncamera.attachControl(canvas, true);\n```\n\n- ArcRotateCamera: 특정 지점이나 객체 주변을 공전하기에 가장 적합한 ArcRotateCamera는 제품 쇼케이스나 주제가 중심에 남아 있고 카메라가 그 주제 주변을 공전하는 경우에 자주 사용됩니다.\n\n```js\nvar camera = new BABYLON.ArcRotateCamera(\"arcCamera\", Math.PI / 2, Math.PI / 4, 10, new BABYLON.Vector3(0, 0, 0), scene);\ncamera.attachControl(canvas, true);\n```\n\n- UniversalCamera: FreeCamera와 TouchCamera의 기능을 결합한 UniversalCamera는 입력 방법(키보드, 마우스, 터치)을 지원하는 다용도 카메라로 다양한 응용 분야에 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar camera = new BABYLON.UniversalCamera(\"universalCamera\", new BABYLON.Vector3(0, 5, -10), scene);\ncamera.attachControl(canvas, true);\n```\n\n- FollowCamera: 물체가 움직일 때 일정한 거리와 각도를 유지하면서 카메라를 따라가야 할 때 FollowCamera를 사용하세요. 게임이나 시뮬레이션에서 써드-퍼슨 시점에 적합합니다.\n\n```js\nvar camera = new BABYLON.FollowCamera(\"followCamera\", new BABYLON.Vector3(0, 5, -10), scene);\ncamera.lockedTarget = movingObject; // 따라다닐 오브젝트\n```\n\n# 기본 조명 기법과 광원 종류\n\n<div class=\"content-ad\"></div>\n\n바빌론.js의 조명은 장면의 분위기, 톤 및 현실감에 극적인 영향을 미칠 수 있습니다. 여기에는 사용할 수있는 기본 조명 유형이 있습니다:\n\n- PointLight: 단일 지점에서 모든 방향으로 빛을 발산합니다. 전구 또는 양초와 같은 광원을 시뮬레이션하는 데 유용합니다.\n\n```js\nvar light = new BABYLON.PointLight(\"pointLight\", new BABYLON.Vector3(0, 10, 0), scene);\n```\n\n- DirectionalLight: 특정 방향으로 발산되는 평행한 빛 선. 해나 기타 먼 거리의 방향성 있는 광원을 시뮬레이션하는 데 이상적입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar light = new BABYLON.DirectionalLight(\"dirLight\", new BABYLON.Vector3(0, -1, 0), scene);\n```\n\n- SpotLight: 특정 지점부터 특정 방향으로 광선을 방출하는 라이트입니다. 무대 공연이나 객체 강조와 같이 특정 장면 요소에 초점을 맞출 때 사용하기 좋습니다.\n\n```js\nvar light = new BABYLON.SpotLight(\"spotLight\", new BABYLON.Vector3(0, 10, 0), new BABYLON.Vector3(0, -1, 0), Math.PI / 3, 2, scene);\n```\n\n- HemisphericLight: 하늘에 비춰지는 듯한 방향에서 모든 객체를 동일하게 조명하여 주변 빛을 모방합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar light = new BABYLON.HemisphericLight(\"hemiLight\", new BABYLON.Vector3(0, 1, 0), scene);\n```\n\n카메라와 조명을 사용하여 Babylon.js 씬을 만들면 시각적으로 매력적이고 적절한 분위기와 심도를 전달하여 3D 프로젝트를 훨씬 몰입적이고 매력적으로 만들 수 있습니다.\n\n# 소재와 텍스처\n\n소재와 텍스처는 3D 그래픽에서 중요한 구성 요소로서 씬에 현실감과 깊이를 더해줍니다. Babylon.js에서 소재는 메시의 색상, 광택, 투명도 및 질감과 관련된 시각적 외관을 정의합니다. 반면에 텍스처는 이러한 소재의 표면에 매핑된 이미지로, 목재 무늬, 금속 또는 직물과 같은 자세한 외관을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\nBabylon.js에서 재료와 질감에 대해 더 자세히 알고 싶다면 이 문서를 확인해보세요.\n\n# 객체에 재료 적용하기\n\nBabylon.js에서 재료는 빛을 반사하고 색상을 표시하는 방식을 지정하는 데 사용됩니다. StandardMaterial은 다양한 시각 효과를 제공하는 다재다능한 재료 유형입니다. StandardMaterial을 생성하고 속성을 구성하는 방법은 다음과 같습니다:\n\n```js\nvar box = BABYLON.MeshBuilder.CreateBox(\"box\", {size: 2}, scene); // 상자 생성\nvar material = new BABYLON.StandardMaterial(\"standardMaterial\", scene);\nmaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // 빨간색\nmaterial.specularColor = new BABYLON.Color3(0, 1, 0); // 녹색 하이라이트\nmaterial.emissiveColor = new BABYLON.Color3(0, 0, 1); // 파란색 빛\nmaterial.ambientColor = new BABYLON.Color3(0.5, 0.5, 0.5); // 중간 회색 주변광\nbox.material = material;\n```\n\n<div class=\"content-ad\"></div>\n\n- diffuseColor: 백색 광선에 밝혀진 재료의 기본 색상을 정의합니다.\n- specularColor: 광선이 재료에서 반사될 때 생성되는 하이라이트의 색상과 강도를 결정합니다.\n- emissiveColor: 재료가 방출하는 것처럼 보이는 색상을 나타냅니다. 이 색상은 조명의 영향을 받지 않고 재료의 전체 색상에 추가됩니다.\n- ambientColor: 장면의 주변 조명에 따라 재료의 색상에 영향을 미치며, 전체 색상에 더해집니다.\n\n# 재료에 이미지 적용하기\n\n텍스처를 사용하면 재료의 표면에 이미지를 적용하여 현실감을 더할 수 있습니다. 이미지로 재료에 텍스처를 적용하는 방법은 다음과 같습니다:\n\n```js\nvar box = BABYLON.MeshBuilder.CreateBox(\"box\", {size: 2}, scene); // 상자 생성\nvar material = new BABYLON.StandardMaterial(\"textureMaterial\", scene);\nmaterial.diffuseTexture = new BABYLON.Texture(\"이미지/경로/여기에/입력.png\", scene);\nbox.material = material;\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 텍스처가 재질의 diffuseTexture로 적용되어, 직접 빛 아래 재질의 색상과 모양에 영향을 줍니다. 이는 현실적인 표면을 만들거나 물체에 브랜드나 스티커를 적용하는 데 특히 유용할 수 있습니다.\n\n텍스처는 diffuse 맵에만 국한되지 않습니다. Babylon.js는 표면 불규칙을 시뮬레이션하는 bum maps, 투명도를 위한 opacity maps, 그리고 반사 면을 만들기 위한 reflection maps를 포함한 다양한 텍스처 유형을 지원합니다. 각 텍스처 유형은 장면을 보다 동적이고 시각적으로 복잡하게 만드는 데 기여합니다.\n\n# 상호작용과 사용자 입력\n\n상호작용적인 3D 장면을 만들기 위해서는 키보드 입력과 마우스 클릭과 같은 사용자 입력에 반응하고, 물체를 조작하거나 장면을 탐색해야 합니다. Babylon.js는 사용자 입력을 처리하는 간단하고 강력한 시스템을 제공하여, 동적이고 상호작용적인 경험을 만들 수 있습니다. 이 섹션은 키보드와 마우스 입력을 다루는 기본 사항을 다루며, Babylon.js 프로젝트 내에서 물체를 상호작용적으로 만드는 방법을 보여줍니다. 더 많은 내용은 여기의 문서에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 키보드 입력 처리\n\n키보드 이벤트에 반응하려면 scene의 onKeyboardObservable 이벤트를 사용할 수 있습니다. 이 observable을 사용하면 키보드 이벤트를 청취하고 눌린 키 또는 해제된 키에 따라 코드를 실행할 수 있습니다. 다음은 특정 키가 눌렸을 때 객체를 이동시키는 예제입니다:\n\n```js\nscene.onKeyboardObservable.add((kbInfo) => {\n    switch (kbInfo.type) {\n        case BABYLON.KeyboardEventTypes.KEYDOWN:\n            console.log(\"KEY DOWN: \", kbInfo.event.key);\n            // 앞으로 이동\n            if (kbInfo.event.key === \"w\" || kbInfo.event.key === \"W\") {\n                box.position.z -= 0.1;\n            }\n            // 뒤로 이동\n            if (kbInfo.event.key === \"s\" || kbInfo.event.key === \"S\") {\n                box.position.z += 0.1;\n            }\n            // 왼쪽으로 이동\n            if (kbInfo.event.key === \"a\" || kbInfo.event.key === \"A\") {\n                box.position.x -= 0.1;\n            }\n            // 오른쪽으로 이동\n            if (kbInfo.event.key === \"d\" || kbInfo.event.key === \"D\") {\n                box.position.x += 0.1;\n            }\n            break;\n        case BABYLON.KeyboardEventTypes.KEYUP:\n            console.log(\"KEY UP: \", kbInfo.event.key);\n            break;\n    }\n});\n```\n\n이 코드는 방향 키 눌림을 청취하고 WASD 키를 누르면 상자 객체를 해당 방향으로 이동시킵니다. 이를 통해 당신의 scene 내에서 키보드로 조작되는 네비게이션 또는 움직임을 만드는 간단한 방법을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 마우스 클릭 처리\n\n마우스 입력을 캡처하여 선택, 드래그 또는 객체와 상호 작용과 같은 작업을 구현할 수 있습니다. Babylon.js 씬은 자동으로 캔버스에서 마우스 이벤트를 캡처하며, 이러한 이벤트를 사용하여 상호 작용을 트리거할 수 있습니다. 예를 들어, 메시가 클릭되었을 때 작업을 수행하려면 ActionManager와 ExecuteCodeAction을 활용할 수 있습니다:\n\n```js\nvar box = BABYLON.MeshBuilder.CreateBox(\"box\", {size: 2}, scene); // 상자 만들기\nbox.actionManager = new BABYLON.ActionManager(scene);\nbox.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, function (evt) {\n    // 상자가 클릭됐을 때 수행할 작업\n    box.scaling.x *= 1.1;\n    box.scaling.y *= 1.1;\n    box.scaling.z *= 1.1;\n}));\n```\n\n# 마우스 드래그 처리\n\n<div class=\"content-ad\"></div>\n\nBabylon.js에서 상자(또는 어떤 메쉬든)를 드래깅하는 기능을 구현하려면 PointerDragBehavior를 사용할 수 있어요. 이 행동은 몇 줄의 코드로 씬 내에서 객체를 드래그할 수 있도록 쉽게 만들어줍니다. 다음은 그 방법이에요:\n\n메쉬에 PointerDragBehavior를 연결합니다: 먼저 PointerDragBehavior의 인스턴스를 생성하고 메쉬에 연결해야 해요. 이 행동은 필요한 모든 이벤트를 처리하고 메시를 마우스로 드래그할 때 업데이트할 거에요.\n\n```js\nvar box = BABYLON.MeshBuilder.CreateBox(\"box\", {size: 2}, scene); // 상자 생성\nvar dragBehavior = new BABYLON.PointerDragBehavior({dragPlaneNormal: new BABYLON.Vector3(0,1,0)});\nbox.addBehavior(dragBehavior);\n```\n\n이 예제에서 dragPlaneNormal은 (0, 1, 0)으로 설정되어 있어요. 이는 드래그 평면이 Y축과 수직이라는 뜻이에요. 이를 통해 상자를 땅 평면을 따라 드래그할 수 있어요. 이 벡터를 조정하여 필요에 맞게 드래깅 평면을 변경할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 웹XR\n\n웹XR는 개발자가 외부 소프트웨어나 앱 없이 웹 브라우저에서 직접 VR(가상 현실) 및 AR(증강 현실) 체험을 만들 수 있도록 하는 산업 수준 기술입니다. Babylon.js는 WebXR을 효과적으로 지원하여 3D 프로젝트에 몰입형 경험을 통합하기 쉽게 만들어줍니다. 이 섹션에서는 Babylon.js를 사용하여 WebXR을 통해 기본 AR 세션을 설정하는 방법에 대해 알아보겠습니다. 자세한 내용은 여기를 확인하세요.\n\n# 웹XR AR 세션 설정\n\nBabylon.js에서 웹XR을 시작하려면 VR/AR 하드웨어 액세스와 관련된 브라우저 보안 제약 사항 때문에 프로젝트가 서버에서 실행 중인지 확인해야 합니다. 그런 다음 createDefaultXRExperienceAsync 메서드를 사용하여 WebXR 경험을 시작할 수 있습니다. 이 메서드는 장면에서 WebXR을 위해 필요한 구성 요소를 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n다음 예제는 몰입형 AR 세션을 시작하는 방법을 보여줍니다:\n\n```js\nvar xr = await scene.createDefaultXRExperienceAsync({\n    uiOptions: {\n      sessionMode: \"immersive-ar\",\n    },\n    optionalFeatures: true,\n});\n```\n\ncreateDefaultXRExperienceAsync를 사용하면 AR 경험을 향상시키는 기능과 옵션을 구성할 수 있습니다. hit testing 및 plane detection과 같이 AR 경험을 향상시키는 옵션을 선택할 수 있습니다. sessionMode는 \"immersive-ar\"로 설정되어 브라우저로부터 AR 세션을 요청합니다.\n\n- uiOptions: WebXR 세션에 대한 사용자 인터페이스 옵션을 정의합니다. sessionMode를 “immersive-ar”로 설정하면 브라우저로부터 AR 세션을 요청합니다.\n- optionalFeatures: 이 옵션을 활성화하면 Babylon.js가 hit testing, plane detection 등의 AR 경험을 향상시키는 추가 WebXR 기능을 요청할 수 있습니다.\n- Babylon.js의 WebXR의 주요 개념\n- 몰입형 AR: 이 모드는 장치 카메라를 통해 본 실제 세계 위에 디지털 콘텐츠를 오버레이하여 완전히 몰입형 AR 경험을 제공합니다.\n- 세션 관리: WebXR 세션을 조작하는 것은 중요합니다. Babylon.js는 WebXR 세션을 쉽게 시작, 관리 및 종료할 수 있는 방법을 제공합니다.\n- 사용자 상호작용: AR에서 가상 객체와 상호작용하는 것은 전통적인 3D 씬과 다른 방식이 필요합니다. Babylon.js는 WebXR을 위한 다양한 상호작용 모델을 지원합니다.\n- 성능 고려사항: AR 및 VR 경험은 요구가 많을 수 있습니다. 모델 및 논리를 성능 최적화하여 원활한 사용자 경험을 보장하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 여정을 계속하세요\n\nBabylon.js에 대한 이 간략한 과정을 성공적으로 마친 것을 축하드립니다! 지금쯤이면, 3D 장면 작성, 사용자 입력 처리, WebXR 통합 등에 대한 견고한 기초를 쌓았을 것입니다. 그러나 3D 웹 개발로의 여정은 여기서 끝나지 않아요. Babylon.js는 방대하고 다재다능한 엔진으로, 이 입문 과정에서 자세히 다루지 못한 많은 기능과 능력을 제공합니다. 프로젝트와 기술을 더욱 향상시키기 위해 Babylon.js의 추가 측면을 탐험하는 것이 중요합니다. 이어서 파고들어볼 핵심 영역 몇 가지를 살펴보겠습니다:\n\n# 그림자와 반사\n\n그림자와 반사를 추가하면 장면의 현실감을 크게 높일 수 있습니다. Babylon.js는 빛이 물체에 드리우는 동적 그림자와 물, 거울, 광택이 있는 금속과 같은 표면에 현실적인 반사를 만들기 위한 정교한 도구를 제공합니다. 이러한 기능을 숙달하면 시각적 프레젠테이션을 다음 차원으로 끌어올릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 물리와 충돌\n\nBabylon.js 씬에 물리를 통합하면 더 많은 상호 작용성과 현실감이 추가됩니다. 이 엔진은 중력, 충돌 및 물체 간의 복잡한 상호 작용을 지원합니다. 게임 또는 대화형 시뮬레이션을 개발하고 있다면, 물리를 적용하고 충돌을 관리하는 방법을 이해하는 것이 중요합니다.\n\n# 성능 최적화\n\n시각적으로 멋진 씬을 만드는 것은 흥미진진하지만, 다양한 기기에서 원활하게 실행되도록 보장하는 것은 성능 최적화에 주의를 기울여야 합니다. Babylon.js는 LOD(레벨 오브 디테일), 메시 인스턴싱 및 텍스처 압축과 같은 여러 도구와 기술을 제공하여 씬을 최적화하는 데 도움을 줍니다. 이러한 도구를 효과적으로 활용하는 방법을 배우면 아름답고 성능이 우수한 복잡한 씬을 만들 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 디버깅 및 도구\n\nBabylon.js는 프로젝트를 해결하고 세부 조정하는 데 도움이 되는 강력한 디버깅 및 진단 도구 세트를 갖추고 있습니다. 예를 들어 Babylon.js Inspector는 실시간으로 장면의 속성을 검사하고 수정하는 데 유용한 도구입니다. 이러한 도구에 익숙해지면 개발 프로세스를 크게 가속화하고 프로젝트의 품질을 향상시킬 수 있습니다.\n\n# 마치며\n\n공식 Babylon.js 문서는 이러한 고급 기능 및 그 이상을 탐색하기에 훌륭한 자원입니다. 튜토리얼, API 참조 및 엔진의 모든 측면을 다루는 예제가 정기적으로 업데이트됩니다. 또한 Babylon.js 커뮤니티는 다른 개발자들로부터 배우고 프로젝트를 공유하며 질문하는 데 도움이 되는 활발하고 지원적인 공간입니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 기능을 탐험하며 기술을 키워 나가는 동안, 연습과 실험은 중요하답니다. 프로젝트에 새로운 요소를 통합해 보거나, 더 복잡한 씬에 도전해 보며, Babylon.js로 만들어낼 수 있는 가능성을 넓혀보세요.\n\n이번 빠른 코스에 참여해 주셔서 감사합니다. Babylon.js를 활용한 3D 웹 개발 세계로의 여정이 시작이니, 상상이 가능한 한계 없는 가능성을 느껴보시기 바랍니다.","ogImage":{"url":"/assets/img/2024-06-22-CrashcourseinBabylonJS_0.png"},"coverImage":"/assets/img/2024-06-22-CrashcourseinBabylonJS_0.png","tag":["Tech"],"readingTime":20},{"title":"웹 개발을 위한 Rust와 WebAssembly 모던 접근법","description":"","date":"2024-06-22 02:09","slug":"2024-06-22-RustforWebAssemblyAModernApproachtoWebDevelopment","content":"\n\n<img src=\"/assets/img/2024-06-22-RustforWebAssemblyAModernApproachtoWebDevelopment_0.png\" />\n\n요즘 몇 년 동안 웹 개발 분야는 상당한 변화를 겪고 있습니다. 가장 흥미로운 발전 중 하나는 웹어셈블리(WebAssembly 또는 Wasm)의 등장입니다. 이는 스택 기반 가상 머신을 위한 이진 명령 형식으로, 프로그래밍 언어의 이식 가능한 컴파일 대상이 되어 웹에서 고성능 응용프로그램을 사용할 수 있게 합니다. 웹어셈블리로 컴파일된 언어 중에서 러스트(Rust)는 성능, 안전 기능, 그리고 성장하는 생태계로 인해 놀라운 선택지로 떠오르고 있습니다. 이 글에서는 왜 러스트가 웹어셈블리에 우수한 선택인지, 어떻게 동작하는지, 그리고 웹 개발의 미래에 미치는 의미에 대해 다뤄보겠습니다.\n\n# 웹어셈블리(WebAssembly)란?\n\n웹어셈블리는 종종 Wasm으로 줄여서 부르며, 근사하게 원시 성능을 갖는 저수준 이진 형식입니다. 이는 자바스크립트를 보완하고 웹에서 고성능 코드 실행을 가능하게 하기 위해 만들어졌습니다. 웹어셈블리는 다음과 같이 설계되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 빠르게: 공통 하드웨어 기능을 활용하여 거의 원래 속도로 실행됩니다.\n- 안전하게: 메모리 안전하고 격리된 환경에서 실행됩니다.\n- 개방적으로: 크로스 브라우저 지원 및 W3C에서 웹 표준으로 개발됩니다.\n- 효율적으로: 해석 및 실행하기 쉬운 콤팩트한 이진 형식을 제공합니다.\n\nWebAssembly는 C, C++, Rust와 같은 언어를 사용하여 응용 프로그램의 일부를 작성할 수 있는 웹 개발에 새로운 가능성을 엽니다.\n\n# WebAssembly에 Rust를 선택하는 이유?\n\nRust는 성능과 안정성으로 유명한 시스템 프로그래밍 언어로, 특히 동시성 처리를 다룰 수 있는 능력으로 알려져 있습니다. Rust가 WebAssembly에 이상적인 후보인 이유는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n## 성능\n\nRust의 성능은 C나 C++과 같은 언어와 유사하여, 계산 집약적인 작업에 이상적입니다. WebAssembly로 컴파일된 Rust 코드는 거의 네이티브 속도로 실행되어, 무거운 계산 작업에 대한 JavaScript보다 상당한 성능 향상을 제공합니다.\n\n## 안전성과 신뢰성\n\nRust는 안전에 대한 강한 강조를 통해 컴파일 시 많은 일반적인 버그, 특히 메모리 관리와 관련된 null 포인터 역참조나 버퍼 오버플로우와 같은 버그를 제거합니다. 이는 Rust의 소유권 시스템을 통해 실현되며, 엄격한 대여 및 수명 규칙을 강제하여 가비지 컬렉터 없이도 메모리 안전성을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n## 상호 운용성\n\n러스트는 JavaScript와의 상호 운용성을 훌륭하게 지원하여 개발자가 러스트 함수를 JavaScript에서 호출하거나 그 반대로 할 수 있습니다. 이는 각 언어의 장점을 살려 기존 웹 애플리케이션에 러스트 코드를 쉽게 통합할 수 있게 해줍니다.\n\n## 성장하는 생태계\n\n웹어셈블리용 러스트 생태계는 빠르게 성장하고 있으며 개발을 더 쉽게 만드는 도구와 라이브러리가 있습니다. 예를 들어 wasm-bindgen 라이브러리는 러스트와 JavaScript 간의 고수준 상호 작용을 용이하게 해줍니다. 또한 Yew와 Seed와 같은 프레임워크는 개발자가 러스트로 전체 웹 애플리케이션을 구축할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 시작하기\n\nRust를 WebAssembly에 사용하기 위해, Rust 툴체인과 WebAssembly 타겼을 설정해야 합니다. 아래는 시작하는 단계입니다:\n\n## 1. Rust 설치\n\n아직 Rust를 설치하지 않은 경우, Rust 툴체인 설치자인 rustup을 사용하여 Rust를 설치하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n## 2. Add the WebAssembly Target\n\nAdd the wasm32-unknown-unknown target to your Rust toolchain:\n\n```js\nrustup target add wasm32-unknown-unknown\n```\n\n<div class=\"content-ad\"></div>\n\n## 3. 새 프로젝트 만들기\n\n새로운 Rust 프로젝트를 만들어보세요:\n\n```js\ncargo new hello-wasm\ncd hello-wasm\n```\n\n## 4. 의존성 추가\n\n<div class=\"content-ad\"></div>\n\n친절한 마음으로 변경된 Markdown 형식의 테이블 태그를 보여드립니다:\n\n\n| Header 1 | Header 2 | Header 3 |\n| -------- | -------- | -------- |\n| Data 1   | Data 2   | Data 3   |\n| Data 4   | Data 5   | Data 6   |\n\n\n<div class=\"content-ad\"></div>\n\n```rust\nuse wasm_bindgen::prelude::*;\n\n// 이 함수는 JavaScript에서 호출 가능할 것입니다.\n#[wasm_bindgen]\npub fn greet(name: &str) -> String {\n    format!(\"안녕, {}!\", name)\n}\n```\n\n## 6. 프로젝트 빌드\n\nWebAssembly 타겟으로 프로젝트를 빌드하세요:\n\n```bash\ncargo build --target wasm32-unknown-unknown --release\n```\n\n<div class=\"content-ad\"></div>\n\n## 7. wasm-bindgen 사용하기\n\nJavaScript 바인딩을 생성하기 위해 wasm-bindgen을 사용하세요:\n\n```js\nwasm-bindgen target/wasm32-unknown-unknown/release/hello_wasm.wasm --out-dir .\n```\n\n## 8. JavaScript와 통합하기\n\n<div class=\"content-ad\"></div>\n\n이제 생성된 WebAssembly 모듈을 JavaScript 코드와 통합할 수 있습니다:\n\n```js\nimport init, { greet } from './hello_wasm.js';\n\nasync function run() {\n    await init();\n    console.log(greet('World'));\n}\n\nrun();\n```\n\n# 실제 응용 프로그램\n\nRust와 WebAssembly는 이미 다양한 실제 응용 프로그램에서 사용되고 있습니다. 몇 가지 예시를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n## Figma\n\nFigma는 인기있는 디자인 도구로, 편집기의 일부 기능을 구동하는 데 Rust와 WebAssembly를 사용하여 빠르고 반응이 빠른 사용자 경험을 제공합니다.\n\n## AutoCAD\n\nAutoCAD의 웹 애플리케이션은 핵심 로직 중 일부를 실행하기 위해 WebAssembly를 사용하여 사용자가 브라우저에서 강력한 CAD 도구에 직접 액세스할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n## Google Earth\n\nGoogle Earth는 복잡한 지리 공간 계산을 처리하기 위해 WebAssembly을 도입하여 성능과 상호 작용성을 향상시켰어요.\n\n# 도전과 고려사항\n\nRust와 WebAssembly는 많은 이점을 제공하지만, 고려해야 할 도전도 있어요:\n\n<div class=\"content-ad\"></div>\n\n## 디버깅\n\n웹어셈블리 디버깅은 자바스크립트 디버깅보다 복잡할 수 있습니다. 왜냐하면 웹어셈블리 모듈은 바이너리 형식이기 때문입니다. 그러나 웹어셈블리 디버깅을 위한 도구와 지원이 지속적으로 개선되고 있습니다.\n\n## 바이너리 크기\n\n웹어셈블리 모듈은 동등한 자바스크립트 코드보다 크기가 커서 로드 시간에 영향을 줄 수 있습니다. 코드 분할과 최적화 같은 기술을 사용하여 이 문제를 해결하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n## 생태계 성숙도\n\nRust 및 WebAssembly 생태계는 빠르게 성장하고 있지만 아직 성숙하게 발전 중에 있습니다. 일부 라이브러리와 도구는 초기 단계에 있어서 포괄적인 문서나 기능이 부족할 수 있습니다.\n\n# 다음은 무엇인가요?\n\nRust와 WebAssembly의 결합은 웹 개발 분야에서 상당한 발전을 나타냅니다. 이는 개발자들이 브라우저에서 원할하게 작동하는 고성능, 안전하고 신뢰할 수 있는 코드를 작성할 수 있게 합니다. 생태계가 성숙해지고 더 많은 도구와 라이브러리가 등장함에 따라, 우리는 Rust와 WebAssembly이 웹 개발의 미래에서 점점 더 중요한 역할을 할 것으로 기대할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 웹 응용 프로그램을 처음부터 구축하거나 기존 응용 프로그램을 최적화하고 있다 하더라도, Rust와 WebAssembly는 발전할 가치가 있는 매력적인 솔루션을 제공합니다. 두 기술의 장점을 활용하여 개발자들은 더 빠르고 효율적이며 안전한 웹 응용 프로그램을 만들어내어 웹에서 가능한 가능성을 넓힐 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-RustforWebAssemblyAModernApproachtoWebDevelopment_0.png"},"coverImage":"/assets/img/2024-06-22-RustforWebAssemblyAModernApproachtoWebDevelopment_0.png","tag":["Tech"],"readingTime":5},{"title":"NestJS 애플리케이션의 코드 보안을 극대화하는 방법 파트 1","description":"","date":"2024-06-22 02:07","slug":"2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1","content":"\n\nNestJS 개발자를 위한 최고의 안전한 코드 작성 방법\n\n![이미지](/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png)\n\n개발자로서, 우리는 모두 코드 보안이 얼마나 중요한지 알고 있습니다. Optus와 Medibank에서 발생한 최근 데이터 침해 사례는 코드 보안의 중요성을 다시 한 번 강조합니다. 그래서, 질문은 다음과 같습니다: 우리는 어떻게 안전한 코드를 작성하여 웹 애플리케이션에서 다양한 유형의 공격을 방지할 수 있을까요? 안전한 코드를 작성하기 위한 최고의 방법을 따르는 것은 취약점과 위협으로부터 우리 앱을 보호하는 데 필수적입니다.\n\n우리가 어떻게 보안 위험을 방지할 수 있는지에 대해 들어가기 전에, 먼저 가장 흔한 유형의 보안 위험을 살펴보겠습니다. 이것은 우리 앱을 보호하는 과제에 대한 더 나은 이해를 제공할 것입니다.\n\n<div class=\"content-ad\"></div>\n\nOWASP Top 10은 웹 애플리케이션의 가장 중요한 보안 위험을 널리 인정받는 목록으로, 산업 전문가들 간의 합의를 통해 결정됩니다. 아래는 2017년과 2021년의 상위 10위 위험 목록입니다.\n\n![OWASP Top 10](/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_1.png)\n\n상위 10위 중 많은 것들이 웹 앱의 보안에 매우 중요합니다.\n\n두 부분으로 구성된 글의 첫 번째 부분으로, 몇 가지 위험과 위험을 방지하는 데 따를 수 있는 최상의 실천 방법에 대해 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n아래와 같습니다:\n\n- 액세스 제어 오류\n- 서버 측 요청 위조 (SSRF)\n- 대량 할당\n- 민감한 정보 노출\n\n## 액세스 제어 오류\n\n액세스 제어 오류는 가장 흔한 위험 중 하나입니다. 공격자가 무단으로 기능이나 자원에 액세스할 수 있는 경우 발생합니다. 2014년 1월 Snapchat 사건이 실제로 발생한 사례 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 위험을 방지하기 위해 최소 권한 원칙을 따르는 것이 중요합니다. 액세스는 기본적으로 거부되어야하며 권한은 필요한 경우에만 부여해야합니다.\n\n사용자의 역할이나 권한에 기반하여 기능이나 자원에 대한 액세스를 제한하는 역할 기반 액세스 제어 (RBAC) 또는 액세스 제어 목록 (ACL)과 같은 액세스 제어 메커니즘을 사용할 수 있습니다.\n\n다음은 NestJS 애플리케이션에서 가드를 사용한 RBAC의 예입니다:\n\n```js\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\n\n@Injectable()\nexport class AdminRoleGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n    return user.role === 'admin';\n  }\n}\n\n@Controller('cats')\nexport class CatsController {\n  @UseGuards(AdminRoleGuard)\n  @Get()\n  async findAll(): Promise<Cat[]> {\n    return this.catsService.findAll();\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드 스니펫에서는 CanActivate 인터페이스를 구현하는 AdminRoleGuard를 생성합니다. 현재 사용자의 역할을 확인하여 사용자가 관리자 인 경우 true를 반환합니다. 그런 다음 @UseGuards 데코레이터를 사용하여 AdminRoleGuard를 findAll 메서드에 적용하고 상세하게 접근을 제한하여 관리자 역할을 가진 사용자에게만 엔드포인트에 액세스 할 수 있도록 합니다.\n\n접근 제어 메커니즘은 안전하고 유지 관리하기 쉬운 프레임워크에서 중앙 집중식 함수를 사용하여 적용해야 합니다.\n\n또한 컨트롤러에 적용된 필수 가드를 테스트하는 단위 테스트를 작성하는 것이 좋습니다. 따라서 가드가 실수로 제거되었을 때 단위 테스트가 문제를 감지할 것입니다.\n\n## 서버 측 요청 위조 (SSRF)\n\n<div class=\"content-ad\"></div>\n\nSSRF는 공격자가 서버에 의도하지 않은 요청을 보내게 하는 사이버 공격입니다. 이러한 요청은 내부 네트워크의 제한된 자원에 액세스하는 데 사용될 수 있습니다.\n\nSSRF를 방지하려면 사용자 입력을 적절히 확인하는 것이 중요합니다. 아래는 SSRF 위험에 노출된 엔드포인트의 예시입니다.\n\n```js\nimport { Controller, Get, Res, HttpStatus, Query } from '@nestjs/common';\n\n@Controller()\nexport class CatsController {\n  @Get()\n  async getData(@Query('url') url: string, @Res() res) {\n    const response = await fetch(url);\n    return await response.json();\n  }\n}\n```\n\n위 예시에서 앱은 url 쿼리 매개변수에서 가져온 URL로 요청을 보내고 응답 데이터를 클라이언트에 반환합니다. 공격자가 내부 네트워크의 제한된 자원에 액세스하는 악성 URL을 포함한 요청을 서버로 보낼 수 있기 때문에 명백히 SSRF 공격에 취약합니다.\n\n<div class=\"content-ad\"></div>\n\n아래의 위험을 방지하기 위해 URL 매개변수를 유효성 검사해야 합니다.\n\n```js\nimport { Controller, Get, Res, HttpStatus, Query } from '@nestjs/common';\nimport { isURL } from 'validator';\n\n@Controller()\nexport class CatsController {\n  @Get()\n  async getData(@Query('url') url: string, @Res() res) {\n    if (!isURL(url)) {\n      return res.status(HttpStatus.BAD_REQUEST).send('유효하지 않은 URL입니다');\n    }\n\n    const response = await fetch(url);\n    return await response.json();\n  }\n}\n```\n\n더 나아가 보안을 더 강화하기 위해 사용자가 직접 쿼리 매개변수에 URL을 전달하도록 허용해선 안 됩니다. 대신 신뢰할 수 있는 API에서 데이터를 가져 오기 위해 기존 서비스를 사용해야 합니다.\n\n```js\n@Controller()\nexport class CatsController {\n  @Get()\n  async getData(@Query('name') dataName: string, @Res() res) {\n    const response = await dataService.GetDataByName(dataName);\n    return await response.json();\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nSSRF 공격을 방지하는 다른 방법이 있습니다:\n\n- 신뢰할 수 있는 소스(즉, 알려진 API 또는 서비스)로만 요청을 보냅니다.\n- 보안 헤더를 구현합니다(예: “X-Frame-Options”와 같은 헤더) 클릭재킹 공격 및 기타 악의적 요청을 방지합니다.\n- CSP(Content Security Policy)를 사용하여 응용 프로그램 대신 요청을 허용할 소스를 지정합니다.\n\nNestJS에서는 helmet을 사용하여 보안 헤더 및 CSP를 쉽게 설정할 수 있습니다.\n\n## 대량 할당\n\n<div class=\"content-ad\"></div>\n\n대량 할당은 취약점입니다. 공격자가 앱에 악의적인 요청을 보내어 여러 객체 속성을 수정할 수 있기 때문입니다.\n\n아래 예시에서, 요청 본문에서 오는 데이터를 기반으로 새 사용자가 생성됩니다. 이것은 대량 할당 공격에 취약합니다. 왜냐하면 공격자가 클라이언트 객체의 중요한 필드(예: 역할 또는 비밀번호)를 덮어쓰는 악의적인 데이터를 보낼 수 있기 때문입니다.\n\n```js\nimport { Controller, Post, Body } from '@nestjs/common';\n\n@Controller(\"client\")\nexport class ClientController {\n  @Post()\n  create(@Body() body) {\n    const client = new Client(body);\n    return await client.save();\n  }\n}\n```\n\n대량 할당을 방지하기 위해 우리는 각 객체에 허용된 속성 목록을 정의할 수 있습니다. 우리는 아래 예시에서 중요한 필드를 덮어쓰는 것을 막기 위해 속성의 화이트리스트를 구현했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity()\nexport class Client{\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column()\n  role: string;\n\n  @Column()\n  password: string;\n\n  @Column(})\n  email: string;\n}\n\n@Controller('client')\nexport class ClientController {\n  constructor(private clientService: ClientService) {}\n\n  @Post()\n  async create(@Body() client: Pick<User, 'name' | 'email'>) {\n    return await this.clientService.create(client);\n  }\n}\n```\n\n여기서 TypeScript의 Pick 유형을 사용하여 User 엔티티의 속성을 화이트리스트로 정의합니다. 그런 다음 @Body 데코레이터를 사용하여 요청 본문을 user 매개변수에 바인딩합니다. 이 매개변수에는 허용된 속성만 포함될 것입니다. 이를 통해 공격자가 대량 할당을 통해 다른 엔티티 속성을 수정하는 것을 방지합니다.\n\n대량 할당을 방지하는 다른 방법은 다음과 같습니다:\n\n- 일반 DTO 대신 축소된 DTO를 사용합니다. 예를 들어 InsertClientEntity 및 UpdateClientEntity를 만듭니다. 이러한 DTO에는 삽입 및 업데이트 작업에서 허용된 속성만 포함됩니다.\n- 클라이언트 측에서 오는 객체에 직접 바인딩하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n## 민감한 정보 노출\n\n민감한 정보에는 암호, API 키 및 기타 비밀 데이터가 포함됩니다. 개인 정보나 결제 관련 정보가 포함된 데이터는 모두 민감합니다.\n\n웹 API를 설계할 때, 종종 클라이언트로 과도한 데이터가 반환됩니다.\n\n```js\nimport { Controller, Get, Param } from '@nestjs/common';\nimport { Client} from './client/client.entity';\n\n@Controller()\nexport class ClientController {\n  @Get('clients/:id')\n  async getClient(@Param('id') id: string): Promise<Client> {\n    // 클라이언트를 위한 모든 필드를 반환합니다\n    return await Client.findById(id);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 getClient 메서드가 클라이언트에 대한 모든 필드를 반환하는데, 이는 role 또는 비밀번호와 같은 민감한 데이터를 포함합니다. 클라이언트는 이러한 데이터를 사용하거나 표시하지 않지만, 공격자가 이를 가로채어 노출시킬 수 있습니다.\n\n민감한 개인 데이터 노출을 방지하기 위해, 우리는 클라이언트가 필요로 하는 데이터인 이름과 이메일 필드만을 반환해야 합니다. 요약하자면, 최소한의 데이터만 노출해야 합니다.\n\n```js\nimport { Controller, Get, Param, UseGuards } from '@nestjs/common';\nimport { Client} from './client/client.entity';\n\n@Controller()\nexport class ClientController {\n  @Get('clients/:id')\n  async getClient(@Param('id') id: string): Promise<Client> {\n    // Only return the name and email\n    return await Client.findById(id).map(c => {c.name, c.email});\n  }\n}\n```\n\n민감한 데이터 노출을 방지하기 위해, 아래는 따라야 할 다른 지침들입니다:\n\n<div class=\"content-ad\"></div>\n\n- 민감한 정보를 버전 관리에 저장하지 마세요. 이 정보에는 환경 변수 또는 구성 파일이 포함됩니다.\n- 시스템 내의 민감한 정보 (GDPR, PCI, 및 PII 데이터)를 식별하고 암호화를 통해 안전하게 보호하세요.\n- 앱이 클라이언트와 서버를 연결할 때 HTTPS를 사용하도록 하세요. 이렇게 하면 민감한 데이터가 전송 중 가로채지 못하게 할 수 있습니다.\n\n## 요약\n\n이 글은 NestJS의 맥락에서 발생하는 네 가지 일반적인 위험과 그 방지를 위한 모범 사례에 대해 논의합니다.\n\n이러한 모범 사례를 따르면 NestJS 앱의 보안을 보장할 수 있는 안전한 코드를 작성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위 글의 제 2부에서는 다른 상위 OWASP 위험에 대해 계속 논의하고 있어요.\n\n만일 이미 Medium의 유료 구독자가 아니라면, 이 링크를 방문하여 구독할 수 있어요. Medium의 모든 이야기에 무제한으로 접근할 수 있을 거에요. 저는 회원 비용의 일부를 추천 수수료로 받게 될 거에요.\n\n즐거운 프로그래밍 되세요!","ogImage":{"url":"/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png"},"coverImage":"/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png","tag":["Tech"],"readingTime":8},{"title":"NextJS와 ReactJS를 사용한 이메일 서비스 시스템 디자인 방법","description":"","date":"2024-06-22 02:06","slug":"2024-06-22-SystemDesignForEmailSericeusingNextJSandRectJS","content":"\n\n# 소개\n\n이메일 템플릿을 동적으로 구축하고 이를 이메일 클라이언트에 전송하는 시스템을 어떻게 설계하면 좋을까요?\n\n주문 정보를 업데이트하고 고객에게 최신 정보를 제공하고자 하는 여러 애플리케이션에서 널리 사용되는 모듈입니다. 저는 NextJS와 React JS를 사용하여 이 시스템을 설계하는 데 최선을 다해 봤습니다.\n\n![이미지](/assets/img/2024-06-22-SystemDesignForEmailSericeusingNextJSandRectJS_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 성공을 향한 5단계 :)\n\n# React 이메일\n\n- React 이메일은 React를 사용하여 이메일 템플릿을 쉽게 만들 수 있도록 설계된 프레임워크입니다. React의 익숙한 컴포넌트 기반 접근 방식을 활용하여 이메일 콘텐츠를 구축하고 관리할 수 있으며, 동적이고 재사용 가능한 이메일 템플릿을 만들 수 있습니다.\n\n# 왜 React 이메일을 사용해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n- React Email은 React를 이미 알고 있는 개발자들에게 학습 곡선이 쉽고 즉시 이메일을 구축할 수 있는 기회를 제공합니다. React에서의 많은 개념들이 React Email로 이어지며, 컴포넌트와 프롭스와 같이 쉽게 전환할 수 있습니다.\n- TypeScript를 이용한 유형 안정성: React Email은 코드에 정적 유형을 추가하기 위해 TypeScript를 함께 제공합니다. 이는 개발 초기에 오류를 더 빨리 발견하고 보다 견고한 코드를 작성하는 데 도움이 됩니다.\n- 개발 중에 이메일 테스트 가능: React Email은 테스트 이메일을 보낼 수 있는 Resend API를 활용하여 개발 중에 이메일을 테스트할 수 있습니다. 이를 통해 이메일의 모습을 다양한 이메일 클라이언트에서 미리 확인하고 필요한 조정을 할 수 있는 기회를 제공합니다.\n- 다른 이메일 서비스 제공업자와의 원활한 통합: React Email 템플릿은 쉽게 이메일 친화적 HTML로 변환되어 Nodemailer, SendGrid 또는 Resend와 같은 다른 이메일 서비스와 통합할 수 있습니다.\n- 오픈 소스 커뮤니티: React Email은 무료이며 오픈 소스 라이브러리로, 개발 기여를 환영합니다. 커뮤니티는 지속적으로 개선 사항을 추가하고 버그를 수정하며 새로운 기능을 개발합니다.\n\n# 이메일 컴포넌트 생성\n\nReact Email을 사용하여 이메일 템플릿용 재사용 가능한 컴포넌트를 생성할 수 있습니다. 다음은 간단한 이메일 컴포넌트를 만드는 방법입니다:\n\n![image](/assets/img/2024-06-22-SystemDesignForEmailSericeusingNextJSandRectJS_1.png)\n\n<div class=\"content-ad\"></div>\n\n# HTML로 변환하기\n\n이메일 컴포넌트를 HTML로 렌더링하려면 @react-email/render 패키지의 render 함수를 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-SystemDesignForEmailSericeusingNextJSandRectJS_2.png)\n\n# NextJS API를 사용하여 이메일 템플릿 HTML 생성\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-SystemDesignForEmailSericeusingNextJSandRectJS_3.png)\n\n# 참고문헌\n","ogImage":{"url":"/assets/img/2024-06-22-SystemDesignForEmailSericeusingNextJSandRectJS_0.png"},"coverImage":"/assets/img/2024-06-22-SystemDesignForEmailSericeusingNextJSandRectJS_0.png","tag":["Tech"],"readingTime":2},{"title":"Web Workers 자바스크립트 멀티스레딩 잠재력 해방하기 ","description":"","date":"2024-06-22 02:05","slug":"2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential","content":"\n\n<img src=\"/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_0.png\" />\n\nJavaScript은 초기에 Brendan Eich에 의해 고안된대로 시작되어 웹 페이지 내 간단한 동적 기능을 위해 설계된 간결한 스크립팅 언어로 출발했습니다. JavaScript는 오늘날의 웹 애플리케이션에서 볼 수 있는 복잡성을 다루기 위해 만들어진 것이 아니었습니다. 이것이 JavaScript가 단일 스레드 언어로 구축된 이유입니다. 동시에 다중 스레드가 동일한 DOM 요소를 동시에 사용하려고 한다면 어떤 혼란이 벌어질지 상상해보세요! 🤯\n\n# 단일 스레드 현실\n\n단일 스레드는 JavaScript의 핵심입니다. 브라우저는 JavaScript 이벤트를 한 번에 하나씩 처리할 수 있도록 설계되었습니다. 이에는 중요한 영향이 몇 가지 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 동시 실행 불가: JavaScript가 실행 중일 때 이벤트 핸들러나 타이머와 같은 다른 작업은 차례를 기다립니다.\n- 반응성이 중요합니다: 오랫동안 실행되는 JavaScript 함수는 브라우저를 멈출 수 있어 사용자 경험이 불편해질 수 있습니다.\n\n이것이 바로 현대의 fetch()와 같은 비동기 API가 만들어진 이유입니다 - 메인 스레드를 막힘 없이 유지하기 위해서!\n\n# 웹 워커로 진입 💪\n\n웹 앱이 더 복잡해지고 데이터 조작 및 복잡한 논리 처리를 위해 더 많은 처리 능력을 요구함에 따라 JavaScript의 단일 스레드 모델의 한계가 드러납니다. 이때 웹 워커가 구원에 나서는 것입니다. 🎉\n\n<div class=\"content-ad\"></div>\n\n웹 워커는 HTML5 사양의 일부로 실제로 오랫동안 사용되어 왔습니다! 이 개념은 2009년에 처음 제안되었습니다. 웹 워커를 사용하면 백그라운드 스레드에서 스크립트를 실행할 수 있어서 주 웹페이지의 스레드와 독립적으로 작동합니다. 이는 더 부드러운 성능과 더 만족스러운 사용자 경험을 제공합니다. 😃\n\n# 웹 워커의 종류\n\n웹 워커에는 세 가지 주요 유형이 있습니다:\n\n- 전용 워커(Dedicated Workers): 이 워커는 생성된 특정 스크립트에 연결됩니다. 즉, 일대일 관계입니다.\n- 공유 워커(Shared Workers): 이름에서 알 수 있듯이, 이 워커는 동일한 도메인에 속하는 여러 창 또는 아이프레임에서 실행되는 여러 스크립트에서 공유할 수 있습니다.\n- 서비스 워커(Service Workers): 이 특별한 워커는 웹 앱, 브라우저, 네트워크 사이에 위치하여 프록시처럼 동작합니다. 이를 통해 견고한 오프라인 경험을 구축하고, 네트워크 요청을 가로채는 기능과 푸시 알림과 같은 기능을 활성화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 웹 워커 사용하기: 간단한 예제\n\n기본 예제를 살펴보겠습니다:\n\n메인 스레드:\n\n```js\nconst worker = new Worker(\"/worker.js\");\n\nworker.onmessage = (e) => {\n  console.log(e.data); // 출력: \"안녕, 주인님!\"\n};\nworker.postMessage(\"안녕하세요, 워커!\");\n```\n\n<div class=\"content-ad\"></div>\n\n워커 스레드(worker.js):\n\n```js\nself.onmessage = (e) => {\n  console.log(e.data); // 출력: \"안녕, 워커!\" \n  self.postMessage(\"안녕하세요, 마스터!\");\n};\n```\n\n# 웹 워커 생성\n\n웹 워커를 생성하는 것은 간단합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst worker = new Worker(aURL, options);\n```\n\n위의 코드를 보겠습니다:\n\n- aURL: 워커가 실행할 JavaScript 파일의 경로입니다. 중요한 점은, 워커 스크립트가 메인 웹페이지와 동일한 도메인에 호스팅되어야 한다는 동일 출처 정책을 따라야 합니다.\n- options (옵션): 이 인자를 사용하여 워커의 몇 가지 측면을 사용자 정의할 수 있습니다.\n\n# 웹 워커를 이용한 오류 처리\n\n\n<div class=\"content-ad\"></div>\n\n웹 워커는 두 가지 유용한 오류 처리 이벤트를 제공합니다:\n\n- error: 워커 내에서 오류가 발생했을 때 트리거됩니다.\n- messageerror: 이 이벤트는 워커가 올바르게 역직렬화할 수 없는 메시지를 수신했을 때 발생합니다.\n\n![웹 워커 이미지](/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_1.png)\n\n# 스레드 간 데이터 교환: 평범하지 않은 통신\n\n<div class=\"content-ad\"></div>\n\nJavaScript의 Web Workers는 스레드 간 데이터 교환을 용이하게 하는 간단한 메커니즘을 사용합니다:\n\n- 구조화된 복제 알고리즘: 이것은 기본 및 가장 호환성 있는 방법입니다. 객체의 깊은 복사본을 안전하게 공유할 수 있는 견고한 방법입니다.\n- 전송 가능한 객체: 최적의 성능을 요구하는 시나리오에서는 전송 가능한 객체를 사용하는 것이 좋습니다. 이들은 ArrayBuffers와 같은 특정 데이터 유형의 소유권 이전을 가능하게 하여, 불필요한 복사를 없애줍니다.\n- SharedArrayBuffer: 이것은 스레드 간의 진정한 공유 메모리를 활성화합니다. 동시 액세스와 수정을 허용하며, 그러나 경쟁 조건을 방지하고 데이터 무결성을 보장하기 위해 추가적인 주의가 필요합니다.\n\n![이미지](/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_2.png)\n\n# 실용적인 응용: 웹 워커의 작동 방식\n\n<div class=\"content-ad\"></div>\n\n웹 워커는 이런 경우에 빛을 발합니다:\n\n- CPU 집약적 작업: 데이터 처리, 이미지 조작 또는 암호화와 같은 작업을 워커에 넘겨서 메인 UI 스레드를 반응성 있게 유지하세요.\n- 비동기 작업: 데이터 가져오기 또는 기타 비동기 작업을 처리할 때, 웹 워커는 이러한 작업이 사용자 인터페이스의 원할한 흐름을 방해하지 않도록 합니다.\n\n# 웹 워커를 사용해야 할 때 (그리고 사용하지 말아야 할 때)\n\n웹 워커는 강력하지만 항상 필요한 것은 아닙니다. 간단하고 단기적인 작업의 경우에는, 웹 워커를 사용하면 오히려 불필요한 작업부하가 생길 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 몇 가지 지침입니다:\n\n- 장기적인 워커: 워커를 자주 생성하고 파괴하는 대신, 작업 스트림을 처리하는 지속적인 워커를 만드는 것이 좋습니다.\n- 스레드 관리: 과도한 워커 생성은 시스템 자원을 과도하게 소모할 수 있습니다. 최적의 성능을 위해 활성 워커 수를 신중하게 고려해야 합니다.\n\n# 결론: 웹 워커, 귀하의 아뮬렛에 담긴 강력한 도구\n\n웹 워커는 JavaScript 개발자 툴킷에 중요한 요소로, 고성능 및 응답성이 뛰어난 웹 응용 프로그램을 구축할 수 있도록 도와줍니다. 이들의 능력과 한계를 이해함으로써, 브라우저에서 멀티스레딩의 참 꽃을 펼칠 수 있습니다. 즐거운 코딩하세요! 😄\n\n<div class=\"content-ad\"></div>\n\n# 평문으로 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 👏 둘썽 박수를 치고 작성자를 팔로우하세요!\n- 저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼도 방문해보세요: CoFeed | Differ\n- PlainEnglish.io 에서 더 많은 콘텐츠를 확인하세요.","ogImage":{"url":"/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_0.png"},"coverImage":"/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_0.png","tag":["Tech"],"readingTime":4},{"title":"고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법","description":"","date":"2024-06-22 02:03","slug":"2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree","content":"\n\n## 최적화에 실패한 보통의 데이터 구조\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png)\n\n가끔 데이터 구조는 직접적이고 매우 실용적인 사용 사례를 가지고 있어 누군가 그것을 고안할 만한 이유를 이해할 수 있습니다.\n\n그런데 항상 그렇지만은 않습니다. 때로는 데이터 구조가 그저 어떤 이점이나 성능 향상을 제공하기 위해 존재하는 경우도 있습니다. 항상 사용하실 건가요? 아마도 그렇지 않을 것입니다. 하지만 실제로 유용하게 사용할 때 알아 두어서 기뻐할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n오늘은 BIT 또는 다른 말로 이진 인덱스 트리에 대해 이야기하고 싶어요. 이 데이터 구조는 검색 및 삽입을 최적화하려고 노력하지만 그것을 실패하는 특징을 가지고 있어요.\n\n# BITs 뒤에 숨겨진 의도\n\nBITs를 \"보통인 데이터 구조\"라고 부르고 싶어요. 다른 데이터 구조들이 트리에서 삽입 또는 읽기 연산 중 하나를 최적화하려고 하는데 그 결과를 O(1)로 만들고 다른 하나는 O(n)으로 놓는 것에 집중하는 반면, BITs는 두 가지 모두를 개선하려고 해요.\n\n그런데 트리에 삽입하고 읽기를 상수 시간 안에 수행하는 것은 불가능하기 때문에, 이 구조체가 시도하는 것에 실패한다고 말하는 건 정말 그렇게 생각해요.\n\n<div class=\"content-ad\"></div>\n\n말이 그렇게 되면, 실제로 BITs는 O(Log n) 성능으로 데이터를 삽입하고 읽을 수 있게 해줍니다. 대단하지도 않고 최악도 아니라서, 그러니까 그냥 보통 정도입니다.\n\n농담은 그만두고, BITs를 사용하면 트리를 쿼리하고 업데이트하는 데 합리적인 성능을 제공합니다. 따라서 트리 모양의 구조물을 다루고 논리가 그것에 많은 읽기 및 쓰기를 수행하는 경우, 이것이 당신에게 적합한 데이터 구조일 수 있습니다.\n\n이 데이터 구조의 주요 사용 사례는 배열 내 요소들의 효율적인 접두사 합계(즉, n번째까지의 모든 요소의 합)를 가질 수 있는 능력입니다. 이것은 산술 코딩을 사용할 때 편리하다고 합니다. 그러나 우리는 지금 그 무한한 토끼굴에 들어가지 않겠습니다.\n\n# JavaScript에서 이진 색인 트리 구현\n\n<div class=\"content-ad\"></div>\n\n이 코드를 구현할 때, 예상과는 다르게 할 것입니다. 클래스로 트리 구조를 구현하는 대신, 이 구조를 배열로 나타내고 트래버스하는 방법으로 이해할 수 있도록 특수한 비트 연산을 사용할 것입니다.\n\n두 가지 작업에 초점을 맞출 것입니다: 업데이트와 특정 위치까지의 합을 얻는 것입니다.\n\n업데이트 작업은 주어진 값을 원하는 위치에 추가하고, 또한 구조를 트래버스하여 모든 하위 항목을 업데이트 할 것입니다.\n\n\"getSum\" 작업은 원하는 노드까지의 서브트리의 합을 반환할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## BIT 생성하기\n\n처음 다룰 주제는 어떻게 만드는 지입니다. 앞서 말했듯이 배열로 표현하고, 현재 인덱스의 마지막 설정 비트를 계산하여 이동하며, 트리를 탐색할 때 이를 추가하거나 제거합니다.\n\n먼저, BIT를 초기 생성할 때는 아래로 이동하므로, 마지막 설정된 비트를 추가합니다.\n\n초기에 BIT 배열은 모두 0으로 설정되어 있고, 우리는 원본 값의 배열을 지나가며 이 논리를 따릅니다:\n\n<div class=\"content-ad\"></div>\n\n- 첫 번째 인덱스(이 경우에는 0)부터 시작합니다.\n- 인덱스에 1을 추가합니다(BIT 배열은 초기 요소가 비어 있는 상태입니다).\n- 현재 인덱스의 배열 값과 BIT 배열 내의 새 위치에 값을 추가합니다.\n- 인덱스의 마지막으로 설정된 비트(즉, 1)을 가져와 인덱스에 추가하여 2로 바꿉니다.\n- 단계 1로 돌아갑니다.\n\n시작할 배열이 다음과 같다고 가정해 봅시다: [2, 1, 1, 3, 2, 3], 그리고 BIT에 접두사 합을 저장하려고 할 때:\n\n- 인덱스 0에서 2의 값을 얻습니다.\n- BIT 배열에 가서 1을 추가하여 BIT 인덱스를 1로 만듭니다.\n- BIT 배열의 위치 1에 있는 값에 2를 추가하여 2로 만듭니다.\n- 1의 마지막 설정된 비트인 1을 가져와 BIT 인덱스에 추가하여 2로 만듭니다.\n- BIT 배열의 인덱스 2에서는 다시 2를 추가하여 2가 됩니다.\n- 2의 마지막 설정된 비트(10)는 2이므로 BIT 인덱스 4로 이동합니다.\n- BIT 인덱스 4에 2를 추가하여 마찬가지로 2가 됩니다.\n- 4의 마지막 설정된 비트(100)도 4이므로 존재하지 않는 8로 이동하게 되고 여기서 종료됩니다.\n\n이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 2, 0, 2, 0, 0]\n\n<div class=\"content-ad\"></div>\n\n그리고 우리는 원래 배열의 첫 번째 2개만 추가했습니다. 이제 우리 배열의 두 번째 요소에도 같은 작업을 수행합니다(위치 1):\n\n- 원래 인덱스 1은 BIT 인덱스 2를 의미합니다(시작 시 인덱스에 1을 추가하는 것을 기억하세요).\n- 우리는 BITArray[2]의 값에 1을 추가하여 3으로 만듭니다.\n- 2가 4로 변하기 때문에 BIT 배열의 4번째 위치에 1을 추가하여 또한 3으로 만듭니다.\n- 그리고 이제 4가 8로 변하면서 다시 범위를 벗어나게 되므로 여기서 멈춥니다.\n\n이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 3, 0, 3, 0, 0]\n\n그리고 계속 진행하면 다음과 같은 결과를 얻게 됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nIdx — BIT 배열\n0 — [0, 0, 0, 0, 0, 0, 0] - 초기 상태\n1 — [0, 2, 2, 0, 2, 0, 0] - 첫 번째 반복\n2 — [0, 2, 3, 0, 3, 0, 0] - 두 번째 반복 (위에서 설명한대로)\n3 — [0, 2, 3, 1, 4, 0, 0]\n4 — [0, 2, 3, 1, 7, 0, 0]\n5 — [0, 2, 3, 1, 7, 2, 2]\n6 — [0, 2, 3, 1, 7, 2, 5]\r\n```\n\n모든 값을 BIT 배열에 추가한 후에는 [0, 2, 3, 1, 7, 2, 5]가 됩니다.\n\n이해를 돕기 위해 다음과 같이 구현을 살펴보겠습니다:\n\nconstructBITree 함수는 배열을 초기화하고 각 값에 대해 업데이트하는 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 배열이 설정되면, 원하는 색인까지의 접두사 합을 요청할 수 있는 쿼리를 시작할 수 있습니다.\n\n## 트리 쿼리\n\n트리를 쿼리하는 것은 이전과 유사한 접근 방식을 따릅니다만, 역으로 진행됩니다.\n\n인덱스 0 대신 우리가 찾고 있는 인덱스에서 (물론 1을 더한 값으로) 시작하고, 해당 인덱스의 마지막 비트를 제거하여 0 또는 그 이하로 이동하면서 트리를 \"위로\" 이동합니다.\n\n<div class=\"content-ad\"></div>\n\n우리의 BIT 배열 [0, 2, 3, 1, 7, 2, 5]에서 트리에 쿼리하여 5번째 요소의 접두사 합을 얻고 싶다고 합시다. 물론, 이는 원래 배열의 모든 값을 더하는 것과 동일하다는 것을 의미합니다 (6개의 값이 있음).\n\n- 이제, 인덱스 5에서 시작하지만 1을 추가하여 6이 되었습니다.\n- BIT 배열의 6번째 인덱스의 값은 5입니다.\n- 이제, 인덱스의 마지막 설정된 비트 (6이며 2진법으로 110입니다)를 빼서 4로 만듭니다.\n- 우리의 BIT 배열에서 4번째 인덱스의 값은 7이므로 5에 추가하여 약 12가 됩니다.\n- 4의 마지막 설정된 비트는 4이므로, 빼서 0이 됩니다.\n- 끝났습니다.\n\n원래 배열을 모두 순회하여 모든 숫자를 더하는 대신, 우리는 BIT 배열에서 2개의 값을 필요로 했습니다. 이 변경으로 O(n)을 O(Log2(n)) 알고리즘으로 변환했습니다. 꽤 멋지죠?!\n\n<div class=\"content-ad\"></div>\n\n자, 이제 구현을 살펴봅시다:\n\n이것은 간단한 구현입니다. 핵심은 8번 라인이며, 여기서 현재 인덱스에서 마지막으로 설정된 비트를 뺍니다. 여기서 모든 마법이 벌어집니다.\n\n읽어주셨나요? IT 산업에서 2 십년의 지혜를 무료로 공유하는 제 뉴스레터를 구독해보세요. \"늙은 개발자의 헛소리\"에 가입하세요!\n\n이진 색인 트리는 그 뒤의 논리를 이해하면 매우 멋집니다. 첫 시도에서 이해하기 어려워 해도 걱정하지 마세요. \"이해하는 데 오랜 시간이 걸렸어요\". 중간값을 저장된 배열에서 확인하고 위에 보여준 단계를 따라 가는 것이 내 추천입니다.\n\n<div class=\"content-ad\"></div>\n\nBITs를 사용해 보신 적이 있나요? 그것으로 무엇을 하셨나요? 이 데이터 구조의 실제 구현에 대해 알고 싶어요! 그러니까 의견란에 공유해 주세요!\n\n# 레고처럼 재사용 가능한 구성 요소로 앱 구축하기\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_1.png)\n\nBit의 오픈소스 도구는 25만 명 이상의 개발자가 구성 요소로 앱을 만드는 데 도와주고 있어요.\n\n<div class=\"content-ad\"></div>\n\n어떤 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 변환하여 여러 애플리케이션 간에 공유하세요. 협업하기가 더 쉽고 빠르게 빌드할 수 있어요.\n\n→ 자세히 알아보기\n\n앱을 구성 요소로 분할하여 앱 개발을 더 쉽게 만들고 원하는 작업 흐름에 대한 최상의 경험을 누리세요:\n\n## → 마이크로 프론트엔드\n\n<div class=\"content-ad\"></div>\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 저장소\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png"},"coverImage":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png","tag":["Tech"],"readingTime":5},{"title":"거북이와 토끼의 이야기 승리의 비결은 무엇일까","description":"","date":"2024-06-22 02:02","slug":"2024-06-22-thetaleoftortoiseandhare","content":"\n\n# 소개\n\n거북이와 토끼 알고리즘 또는 플로이드의 순환 감지 알고리즘은 연결 리스트의 경우에 매우 일반적으로 사용되는 알고리즘입니다. 이는 기초 역학 법칙과 직관에 기반을 둔 것입니다. 본문은 본 알고리즘에 대해 간단히 설명하고, 이 마법 같은 알고리즘에 대해 모두에게 알려주려고 합니다.\n\n# 직관\n\n우리에게 루프가 있는 연결 리스트가 있다고 가정해 봅시다. 만약 여러분이 연결 리스트의 루프가 무엇인지 모르는 경우, 마지막 노드가 리스트의 중간 노드를 자신의 노드로 가지고 있는 경우를 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n이건 무한 루프를 만들어버리네요!!!\n\n![image](/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png)\n\n하지만 어떻게 해결할 수 있을까요?\n\n한 순간 동안 이 문제를 내버려두고 다른 영역으로 들어가볼까요?\n\n<div class=\"content-ad\"></div>\n\n고속과 저속(토끼와 거북이) 두 개의 포인터를 만들어서 거북이와 토끼를 반영하겠습니다. 빠른 포인터는 2의 속도(반복당 두 노드)로 이동하고, 느린 포인터는 1의 속도(반복당 한 노드)로 이동합니다. 두 포인터가 만난다면 이는 반복이 있음을 의미합니다.\n\n하지만 이 두 포인터가 어떻게 만나게 되는지 아십니까?\n\n<div class=\"content-ad\"></div>\n\n# 수학적 증명\n\n알고리즘이 왜 동작하는지 자세히 살펴보겠습니다.\n\n지금 우리는 느린 포인터와 빠른 포인터가 서로 다른 시간에 루프에 들어간다는 것을 알고 있습니다. 느린 포인터는 속도가 1이므로 각 반복에서 링크를 한 번씩만 건너뜁니다. 빠른 포인터는 속도가 2입니다. 따라서 매 반복마다 빠른 포인터는 1단계씩 느린 포인터에 접근하게 되고, 루프에 들어갈 때 느린 포인터와 빠른 포인터 사이의 거리는 항상 1로 나눌 수 있으므로, 빠른 포인터는 한 번의 루프 이내에 느린 포인터를 잡아내게 됩니다.\n\n또 다른 방식으로 생각해 보실 수도 있습니다. 느린 포인터가 한 위치에 갇혀 있고 전체 링크드 리스트가 속도 1로 움직인다고 상상해 보십시오. 이것은 빠른 포인터가 느린 포인터에 대해 매 반복에서 노드 1개씩만 움직인다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지 1](/assets/img/2024-06-22-thetaleoftortoiseandhare_2.png)\n\n![이미지 2](/assets/img/2024-06-22-thetaleoftortoiseandhare_3.png)\n\n빠른 속도와 느린 속도 사이의 거리와 시작 위치와는 관계없이 루프가 있다면 결국 만날 것을 증명했습니다.\n\n# 코드\n\n\n<div class=\"content-ad\"></div>\n\n내감으로 코드를 작성해볼까요?\n\n우선, 노드를 만들어봅시다.\n\n```js\nclass Node {\n    constructor(name = null) {\n        this.val = name;\n        this.next = null;\n    }\n}\n```\n\n그런 다음 두 개의 포인터를 생성하고, 이를 헤드를 가리키도록 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar isLoop = function(head) {\n    let slow = head;\n    let fast = head;\n}\n```\n\n제거 사례 설정 중입니다.\n\n```js\nvar isLoop = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast != null && fast.next != null) {\n\n    }\n    return false\n}\n```\n\n포인터를 이동합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar isLoop = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast != null && fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n        if (fast == slow) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n이제 우리의 코드가 완성되었어요. 우리는 드디어 루프를 감지할 수 있는 코드를 작성했어요.\n\n그게 다일까요? 이 알고리즘의 유일한 용도인가요?\n\n# 사용 사례\n\n\n<div class=\"content-ad\"></div>\n\n이 알고리즘의 주요 사용 사례 중 하나가 사이클 탐지인데, 단순히 그것만이 아닙니다. 다른 사용 사례를 살펴봅시다.\n\n연결 리스트의 중간을 찾아 봅시다. 우연히도 이를 수행하는 최적 알고리즘은 토끼와 거북이 알고리즘입니다.\n\n두 대의 차량이 있는 트랙이 있다고 가정해 봅시다. 차량 1은 차량 2의 반 속도입니다. 따라서 차량 2가 트랙 끝에 도달할 때, 차량 1은 트랙의 중간에 있을 것입니다. 이것이 우리의 직관입니다.\n\n이를 코딩해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 코드 함수 변환\nvar mid = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast != null || fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    return slow;\n}\n```\n\n다른 예제 사용 사례로는 연결 리스트의 중간 노드를 삭제하는 것이 있습니다.\n\n이전 솔루션을 이 질문에 구현하려고 하면 문제가 발생합니다. 만약 중간 노드를 삭제해야 한다면, 우리는 slow가 중간 노드 직전 노드에서 멈추길 원합니다. 어떻게 할 수 있을까요?\n\n한 가지 분명한 해결책은 slow 포인터보다 한 단계 이전인 이전 포인터를 사용하는 것일 수 있고, 실제로 이것은 좋은 해결책입니다. 그러나 더 나은 해결책은 fast 포인터에 앞서 시작하는 기회를 주는 것입니다. 이렇게 하면 slow가 이전 알고리즘보다 한 단계 더 적게 이동합니다. 그러므로 우리는 해결책을 찾았습니다.\n\n\n<div class=\"content-ad\"></div>\n\n솔루션을 코드로 작성해 보겠습니다.\n\n```js\nvar midRemover = function(head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    let slow = head;\n    let fast = head.next.next;\n    while (fast != null && fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    slow.next = slow.next.next;\n    return head;\n}\n```\n\n그래서 Linked Lists의 경우 거북이와 토끼 알고리즘은 매우 유용하지만, 시간 복잡도와 공간 복잡도는 어떨까요?\n\n# 시간 복잡도\n\n<div class=\"content-ad\"></div>\n\n이 알고리즘의 시간 복잡도를 찾아 봅시다. 머리와 루프의 시작 사이에 거리 x가 있다고 가정하고, 루프의 길이가 y이라고 합시다. slow가 루프의 시작점에 도달할 때, 걸린 반복 횟수는 x일 것입니다. 또한, fast 포인터가 slow가 루프의 시작점에 도달할 때 어디에 있든, fast가 slow에 도달하는 데 걸릴 수 있는 최대 반복 횟수는 y입니다. 왜냐하면 두 지점 사이의 최대 가능한 거리는 y-1이기 때문에, 거리는 1단위로 감소하므로 fast가 slow에 도달하는 데 걸리는 최대 시간은 y-1이지만 우리는 y로 근사합니다.\n\n따라서 알고리즘의 시간 복잡도는 O(N)입니다.\n\n# 공간 복잡도\n\n이 알고리즘은 두 개의 포인터만 사용합니다. 따라서 링크드 리스트의 크기가 변경되더라도 알고리즘에 사용되는 추가 공간은 변하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n이 알고리즘에 사용된 추가 공간은 O(1)입니다.","ogImage":{"url":"/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png"},"coverImage":"/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png","tag":["Tech"],"readingTime":5}],"page":"32","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}