{"pageProps":{"posts":[{"title":"자바스크립트 앱이 정상적으로 작동할 때 리액트 네이티브 문제를 해결하는 방법","description":"","date":"2024-05-12 19:29","slug":"2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks","content":"\n\n지난번에 React Native 앱을 작업한 건 이미 3년 전이에요. 그리고 이에 대해 글을 쓰고 싶은 마음은 오랫동안 가지고 있었는데 항상 잊어버렸었어요. 그 때는 블록체인 NFT 프로젝트도 함께 진행했었는데, 그 이야기는 다른 날에 별도로 다룰 거예요 (이 \"팁\" 글 말고 흥미로운 이야기가 될 거라고 약속해요). 비슷한 문제에 직면하고 있다면 임시 방편을 이용할 아이디어를 제공하려고 해요.\n\n# 상황\n\n이전 프로젝트는 '비전을 가진' 창업자들이 이끄는 스타트업 회사에 관련된 건데, 안타깝게도 구체적인 계획이 부족했고 성공적인 자금 마련을 할 수 없었기 때문에 제 봉급을 지급하지 못했어요 🤷‍♂️. 저는 랜딩 페이지와 모바일 앱을 동시에 만드는 것을 담당한 유일한 개발자였어요.\n\n앱은 3D 아바타를 특징으로 하는 모바일 커뮤니케이션(채팅) 플랫폼이었고, 사용자들은 채팅 앱 내에서 사용할 NFT를 구매할 수 있었어요. React에 익숙했기 때문에 3D 렌더링 라이브러리를 조사하고 React로 작동하는 PoC를 몇 시간 동안 개발한 후, React Native를 사용하여 앱을 만들기로 결정했어요. \"결국 React인데; 얼마나 다를까?\" 라고 생각했어요.\n\n\n\n# 문제\n\n“채팅 앱\"을 마치고 기분 좋았는데, 팔을 걷어내고 내 헤비 메탈 플레이리스트에서 고함 소리를 들으며 흥을 냈습니다. 간단한 3D 모델들은 잘 작동했지만, 이후 이를 렌더링할 수 없는 문제가 발생했어요. 이는 애니메이션이 포함된 3D .FBX 파일인 이진 파일을 렌더링할 수 없었던 것이었습니다. 찾아봐도 (그 때 chatGPT는 그리 도움이 되지 못했습니다) React Native 자체가 배열 버퍼를 지원하지 않는다는 것을 알 수 없었죠. 현재 해결되었는지는 확실하지 않습니다.\n\n시간이 없어서 일반 React 앱에서 로드해보았는데, 잘 작동했어요. 핸드폰으로 웹 앱을 시작해봤을 때도 문제없이 작동했습니다. 데모 날이 다가오고 있어서 그 주에 문제를 해결해야 했어요.\n\n그래서 React Native 기술 스택을 사용하는 시니어 모바일 개발자인 전 동료에게 도움을 요청했지만, 안타깝게도 그도 문제를 해결하지 못했습니다.\n\n\n\n내가 가진 제한된 시간과 기술로 React Native 코어에 깊게 파보는 일은 할 수 없었어요. 그 당시에는 절망에 빠져 있었습니다.\n\n# “가끔 어둠이 너에게 빛을 비춰줄 수도 있어\" — Disturbed\n\n어둔 시기에 멘토가 제안했어요: “React Native 앱에 웹 앱을 넣어본다면 어떨까?\"\n\n![이미지](/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png)\n\n\n\n그래서, 나는 React 앱을 Vercel에 호스팅하고 React Native 앱으로 WebView로로드하는 것을 시도했고 완벽하게 작동했어요.\n\niframe과 상호 작용하기 위해 수백만 개의 블로그가 안내를 제공하고 있어, 또는 그냥 chatGPT에게 물어보면 돼요, 그래서 여기에는 넣을게 없어요.\n\n문제는 해결됐지만, 문제는 전체 블록체인 및 NFT 트렌드가 붕괴되었을 때 피칭이 잘못된 시간에 있었고, 정말 필요한 때에 돈을 사칭 당했어요—내 결혼식을 위해서!!!\n\n고객 중심적 사고 방식을 가지고 있다면(https://medium.com/@whoz_/beyond-code-dont-just-be-a-coder-a9bad8007dca), 다양한 경우에이 해결책이 도움이 될 수 있어요. 시장을 빨리 점령하기 위해 제대로 작동하도록 시간을 낭비하지 않아도 돼요. 시장에 올 때 좋은 앱을 가지고 있다해도, 고객이 정말 필요하지 않을 때나 피드백에 따라 다시 작업하기에 너무 늦었을 때 그 점이 어떤 의미가 있겠어요?\n\n\n\ntldr; 만약 React Native 앱에 문제가 있지만 React 앱은 핸드폰 브라우저에서 잘 작동한다면 WebView을 통해 React Native에 임베드해보세요.","ogImage":{"url":"/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png"},"coverImage":"/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png","tag":["Tech"],"readingTime":2},{"title":"패키지-락json 완전 가이드","description":"","date":"2024-05-12 19:28","slug":"2024-05-12-package-lockjsonTheCompleteGuide","content":"\n\n## package-lock.json이란 무엇이고, 왜 신경 써야 하나요?\n\n### package.json이란?\n\npackage.json은 주로 당신의 Node.js 프로젝트가 실행되기 위해 필요한 종속성(라이브러리) 목록을 포함하는 버전 파일입니다.\n\n또한 스크립트, 저자 및 라이센스 정보, 설명, 프로젝트 속성 등과 같은 다른 메타 정보도 포함하고 있습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png\" />\n\n# 고유한 문제\n\n위의 package.json에서 \"dependencies\" 객체가 package-name을 버전 범위로 매핑하는 것을 볼 수 있습니다.\n\n<img src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_1.png\" />\n\n\n\n이것은 npm install을 결정론적이지 않게 만듭니다. 그래서 오늘 npm install을 실행하고 3개월 후에 다시 실행하면 동일한 node_modules 트리를 얻을 수 없을 수 있습니다.\n\n게다가, 만약 다른 개발자가 여러분의 프로젝트를 복제하고 그것에 몇 일 후에 npm install을 실행한다면, 그들은 다른 node_modules 의존성 트리를 가질 수 있습니다. 여러 명의 개발자가 같은 저장소에서 작업하는 경우(이는 대부분의 경우 조직 내에서 발생할 것으로 예상됩니다),이는 큰 문제를 일으킬 수 있으며 설치된 의존성에 일관성이 없거나 더 나빠른 변경으로 이어질 수 있습니다.\n\n그래서 해결책은 무엇일까요? 먼저, 버전 범위가 무엇을 의미하는지 이해해 봅시다. 버전 범위는 하나 이상의 공백으로 구분된 숫자가 포함된 문자열입니다. 이 숫자들은 ^ ~ ` ||와 같은 일부 특수 기호도 포함합니다. 예: ^1.0.4, ~2.3, 4.4.x, `=2.3.4, `1.0.9 ||\n\n![image](/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_2.png)\n\n\n\n이 기호들은 npm에게 다른 정보를 전달해요:\n\n예를 들어, \"foo\" 패키지를 설치하고 싶다고 해봅시다. npm i foo를 실행한 후에, 내 package.json 파일에는 대부분 다음과 같은 항목이 있을 거에요:\n\n```js\n{\n  \"dependencies\": {\n    \"foo\": \"^2.3.0\",\n    ...\n    ...\n  }\n}\n```\n\n여기서 foo는 2.3.0 [주 버전 부 버전 패치 버전] 버전으로 설치되었어요. 이 caret 기호는 또 다른 정보를 알려줘요:\n\n\n\n^2.3.0 — Caret Symbol: npm에게 마이너 및 패치 버전을 업그레이드하도록 지시하지만 메이저 버전은 업그레이드하지 않습니다. 기본적으로 2.3.4, 2.3.9, 2.4.5, 2.8는 가능하지만 3.0.0부터는 불가능합니다. (마이너 및 패치는 업그레이드하지만 메이저는 제외)\n\n~2.3.0 — Tilde Symbol: npm에게 패치 버전을 업그레이드하도록 지시하지만 마이너 및 메이저 버전은 업그레이드하지 않습니다. 따라서 2.3.4, 2.3.9는 가능하지만 2.4.0부터는 불가능합니다. (패치는 업그레이드하지만 마이너 및 메이저는 제외)\n\n다른 npm 버전 업데이트 전략을 표시하는 여러 기호가 있습니다. 공식 npm 웹사이트가 좋은 참고자료가 될 것입니다.\n\n따라서 \"foo\": \"^2.3.0\"의 경우, 며칠 후에 npm install을 실행하면 자동으로 마이너/패치 버전이 업그레이드될 수 있습니다. 이는 바람직하지 않습니다...\n\n\n\n# 패키지 잠금파일(package-lock.json)이란?\n\n![이미지](/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_3.png)\n\n패키지 잠금파일(package-lock.json)은 노드.js 프로젝트에 설치된 종속성/패키지들과 정확한 버전 번호에 대한 정보를 포함하는 잠금 파일(lockfile)입니다 (*중요).\n\n- 이 파일은 동일한 저장소에서 작업하는 다른 개발자들이 이전에 설치된 정확한 패키지 버전을 설치할 수 있도록 도와줍니다. 새 버전의 패키지가 출시되어도 다른 기기/환경에서 동일한 node_modules 트리를 유지할 수 있습니다.\n- 패키지 잠금파일(package-lock.json)은 종속성을 특정 버전 번호로 잠그는 데 주로 사용됩니다.\n- 이 파일은 node_modules 트리나 package.json 파일 중 하나라도 변경이 있을 때 자동으로 생성(또는 재생성)됩니다.\n- 저장소를 복제하고 새 기기에서 npm i를 실행할 때, npm은 먼저 패키지 잠금파일(package-lock.json)이 있는지 확인합니다. 있을 경우 해당 파일에 있는 패키지를 설치합니다. 그렇지 않으면 package.json 파일을 확인하고 필요한 종속성 패키지를 설치합니다. (📦 이에 대한 주의사항은 뒤의 글에서 설명됩니다)\n\n\n\n<img src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_4.png\" />\n\n# 패키지 잠금 파일(package-lock.json)은 커밋해야 하나요?\n\n네, 이 파일은 소스 저장소에 커밋해야 합니다. 이렇게 하면 개발자가 귀하의 리포지토리를 클론할 때 귀하의 컴퓨터/환경에 설치된 의존성과 정확히 일치하는 의존성을 설치할 수 있습니다. 다른 컴퓨터에서 node.js 환경을 복제하는 데 도움이 됩니다.\n\n# 참고로\n\n\n\n저는 YouTube에서 아름다운 자바스크립트 체험을 보여주는 비디오를 만들고 있어요. (참고로 코딩 튜토리얼 채널은 아니에요...) 제 비디오를 확인해보세요:\n\n# npm install이 package-lock.json을 다시 작성하는 이유 / 시기\n\n- 📦 주의: npm install은 package.json의 버전 범위 내에 설치할 패키지가 있는 경우에만 package-lock.json을 고려합니다.\n- 잠금 파일에 지정된 패키지 버전이 package.json 파일의 버전 범위 내에 없는 경우, 패키지가 업데이트되고 package-lock.json 파일이 덮어씌워집니다.\n- package-lock.json을 덮어쓰기 대신 설치를 실패하게 하려면 npm ci를 사용하세요.\n\n예를 들어,\n\n\n\n패키지.json에서는 종속성을 다음과 같이 선언합니다:\n\n```js\n\"foo\": \"^2.3.0\"\n```\n\n그리고 npm install을 실행하면, 다음과 같은 package-lock.json이 생성됩니다:\n\n```js\n\"foo\": \"2.3.0\"\n```\n\n\n\n몇 일 후에, \"foo\"의 새로운 부 버전인 \"2.4.0\"이 출시됩니다. 그리고 이렇게 됩니다:\n\nnpm install — package-lock 버전이 범위 내에 있으므로(예: ^2.3.0) 2.3.0이 설치됩니다.\nnpm ci — 이 명령은 어차피 package-lock.json만을 보기 때문에 2.3.0이 설치됩니다.\n\n다음으로, package.json을 수동으로 업데이트합니다:\n\n```js\n\"foo\": \"^2.4.0\"\n```\n\n\n\n그럼 다시 실행해주세요:\n\nnpm install 명령어를 실행하면 package-lock 파일의 버전이 범위 내에 없기 때문에 (예: ^2.4.0), 2.4.0 버전으로 설치되며 package-lock.json 파일은 이제 다음과 같이 다시 작성됩니다:\n\"foo\": \"2.4.0\"\n\nnpm ci 명령어를 실행하면 package-lock.json 파일만 고려하지만 버전이 범위 내에 없기 때문에 오류가 발생합니다.\n\nnpm ci 명령어는 npm install과 유사하지만 테스트 플랫폼, 지속적인 통합, 배포 등과 같은 자동 환경에서 사용하기 위한 명령어입니다. 즉, 종속성을 깔끔하게 설치하고 싶은 경우에 유용합니다. (출처: npm 문서)\n\n\n\n# 간단히 말해요:\n\n- npm install은 결정론적이지 않아서, 수천 개의 종속성이 포함된 리포지토리(다수의 개발자들이 참여)에서 작업할 때 문제가 발생할 수 있어요.\n- package-lock.json 파일은 npm install이 실행될 때 항상 동일한 node_modules 트리가 생성되도록 보장해줘요.\n- 최신 명령어인 npm ci는 항상 동일한 node_modules 트리를 생성하도록 보장하며, 그렇지 않으면 오류를 발생시켜요.","ogImage":{"url":"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png"},"coverImage":"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"React-js를 이용한 초보자를 위한 Socketio를 활용한 간단한 채팅 애플리케이션","description":"","date":"2024-05-12 19:26","slug":"2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners","content":"\n\n안녕하세요 여러분! 이 글에서는 socket.io와 React js를 사용하여 간단한 채팅 애플리케이션을 만드는 방법에 대해 알아볼 거에요. 특히 초보자분들을 위한 내용으로 모든 단계를 차근차근 알려드릴 거에요. 마지막에는 React-js로 간단한 채팅 애플리케이션을 만들게 될 거에요.\n\n![SimpleChatappusingSocketioInReact-jsForBeginners](/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png)\n\n## Socket.io란 무엇인가요?\n\nSocket.IO는 웹 클라이언트와 서버 간 실시간 양방향 통신을 용이하게 하는 강력한 JavaScript 라이브러리입니다. 사용자와 응용 프로그램 간 즉각적인 데이터 교환을 허용하는 다리 역할을 하며, 라이브 채팅, 멀티플레이어 게임 및 협업 편집 도구와 같은 참여형 경험을 만들기에 이상적입니다. 강력한 기능과 사용 편의성을 갖춘 Socket.IO는 현대적이고 인터랙티브한 웹 애플리케이션을 구축하기 위한 주요 기술로 자리잡았습니다.\n\n\n\n단계 1: 새 폴더 생성하기\n\n여기서 빈 폴더를 생성합니다. 이 폴더 안에 클라이언트 측(react)과 서버 측(socket.io)의 2개 개별 폴더를 생성합니다.\n\n```js\nmkdir react-chatapp\ncd react-chatapp\n```\n\n단계 2: socket.io를 사용하여 소켓 만들기\n\n\n\n먼저 서버 측 작업을 위해 서버 폴더를 만들어야 해요. 다음 명령어를 사용하세요.\n\n```js\nmkdir server\ncd server\n```\n\n새로운 Node.js 프로젝트를 초기화하세요:\n\n```js\nnpm init -y\n```\n\n\n\n\nsocket.io 라이브러리 설치하기\n\n```js\nnpm install socket.io\n```\n\nsocket.io를 설치한 후 server.js 파일을 만들고 아래 코드를 추가해주세요.\n\n```js\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nconst server = http.createServer((req, res) => {\n    res.end('Hello World');\n});\n\nconst io = new Server(server, {\n    cors: {\n        origin: \"*\",\n        methods: [\"GET\", \"POST\"]\n    }\n});\n\nio.on('connection', (socket) => {\n    console.log('사용자가 연결되었습니다.');\n\n    socket.on('message', (message) => {\n        io.emit('message', message);\n    });\n\n    socket.on('disconnect', () => {\n        console.log('사용자가 연결을 끊었습니다.');\n    });\n});\n\nconst PORT = process.env.PORT || 4000;\n\nserver.listen(PORT, () => {\n    console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n\n\n여기, 이 코드는 Node.js의 내장 http 모듈을 사용하여 기본 HTTP 서버를 설정하고 Socket.IO 서버를 연결하는 방법을 보여줍니다. Socket.IO 서버는 클라이언트 연결을 수신하고 모든 연결된 클라이언트에 메시지를 브로드캐스트하며 클라이언트가 연결 또는 연결 해제될 때 로그를 기록합니다.\n\n단계 3: React js에서 Socket.io 구현\n\n\"react-chatapp\" 폴더로 이동하여 리액트 프로젝트를 만듭니다.\n\n```sh\nnpx create-react-app client\n```\n\n\n\n리액트 프로젝트를 설치한 후 프로젝트 안으로 이동하여 의존성을 설치하세요.\n\n```js\ncd client\nnpm start\n```\n\n리액트 기본 의존성을 설치한 후 socket.io-client와 부트스트랩 라이브러리를 리액트에 설치하세요.\n\n```js\nnpm install socket.io-client bootstrap\n```\n\n\n\n- Socket.IO-Client:\n\n- socket.io-client은 Socket.IO를 위한 클라이언트 측 라이브러리로, 실시간 양방향 통신 라이브러리입니다.\n- 이를 통해 웹 클라이언트(예: 브라우저)가 Socket.IO 서버와 연결을 설정하고 실시간으로 통신할 수 있습니다.\n- 서버에 이벤트를 전송하거나 서버로부터 받은 이벤트를 처리하는 방법을 제공합니다.\n- socket.io-client를 사용하면 채팅, 실시간 업데이트, 협업과 같은 기능을 지원하는 대화형 웹 애플리케이션을 개발할 수 있습니다.\n\n2. Bootstrap:\n\n- Bootstrap은 반응형 및 모바일 우선 웹 프로젝트를 구축하기 위한 인기 있는 프론트엔드 프레임워크입니다.\n- 버튼, 폼, 내비게이션 바와 같은 사전 스타일이 적용된 CSS 컴포넌트 및 모달, 툴팁과 같은 JavaScript 플러그인을 제공합니다.\n- Bootstrap의 그리드 시스템을 통해 다양한 화면 크기와 장치에 대응하는 반응형 레이아웃을 생성할 수 있습니다.\n- Bootstrap을 사용하면 다양한 준비가된 컴포넌트와 스타일을 제공하여 웹 애플리케이션을 디자인하고 스타일링하는 데 시간과 노력을 절약할 수 있습니다.\n\n\n\n그럼 src/App.js 파일로 이동하여 다음 코드로 교체하세요\n\nsrc/App.js\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport '../src/App.css';\nimport io from 'socket.io-client';\n\nconst socket = io('http://localhost:4000');\n\nfunction App() {\n  const [messages, setMessages] = useState([]);\n  const [username, setUsername] = useState('');\n  const [isUsernameSubmitted, setIsUsernameSubmitted] = useState(false);\n  const [inputMessage, setInputMessage] = useState('');\n  const [isUsernameSet, setIsUsernameSet] = useState(false);\n\n  useEffect(() => {\n    const storedUsername = localStorage.getItem('username');\n    if (storedUsername) {\n      setUsername(storedUsername);\n      setIsUsernameSet(true);\n    }\n\n    socket.on('message', (message) => {\n      setMessages((prevMessages) => [...prevMessages, message]);\n    });\n\n    return () => {\n      socket.off('message');\n    };\n  }, []);\n\n  const handleUsernameChange = (e) => {\n    setUsername(e.target.value);\n  };\n\n  const handleUsernameSubmit = () => {\n    localStorage.setItem('username', username);\n    setIsUsernameSubmitted(true);\n  };\n\n  const handleMessageSend = () => {\n    if (!inputMessage.trim()) return;\n\n    socket.emit('message', {\n      username,\n      text: inputMessage\n    });\n\n    setInputMessage('');\n  };\n\n  return (\n    <div className=\"container mt-5\">\n      <div className=\"row justify-content-center\">\n        <div className=\"col-md-6\">\n          <div className=\"card\">\n            <div className=\"card-body\">\n              <h5 className=\"card-title text-center mb-4\">Chat App</h5>\n              {!isUsernameSubmitted ? (\n                <div>\n                  <div className=\"mb-3\">\n                    <input\n                      type=\"text\"\n                      className=\"form-control\"\n                      placeholder=\"사용자 이름 입력\"\n                      value={username}\n                      onChange={handleUsernameChange}\n                    />\n                  </div>\n                  <button\n                    className=\"btn btn-primary btn-block\"\n                    onClick={handleUsernameSubmit}\n                  >\n                    사용자 이름 설정\n                  </button>\n                </div>\n              ) : (\n                <div>\n                  <h4 className=\"text-center mb-4\">환영합니다, {username}님!</h4>\n                  <div className=\"message-container row\">\n                    {messages.map((msg, index) => (\n                      <div key={index} className=\"message col-md-8 offset-md-2\">\n                        <strong>{msg.username}:</strong> {msg.text}\n                      </div>\n                    ))}\n                  </div>\n                  <div className=\"input-group mb-3\">\n                    <input\n                      type=\"text\"\n                      className=\"form-control\"\n                      placeholder=\"메시지 입력...\"\n                      value={inputMessage}\n                      onChange={(e) => setInputMessage(e.target.value)}\n                    />\n                    <button\n                      className=\"btn btn-primary\"\n                      onClick={handleMessageSend}\n                    >\n                      전송\n                    </button>\n                  </div>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n이 코드에서는 React와 Socket.IO를 사용하여 실시간 채팅 애플리케이션을 만드는 과정을 안내하겠습니다. 우리는 먼저 애플리케이션의 기본 구조를 설정한 다음 사용자가 실시간으로 메시지를 보내고 받을 수 있도록 기능을 점진적으로 추가할 것입니다.\n\n\n\n단계 1: 사용자 이름 입력 컴포넌트 생성\n\n- 먼저 UsernameInput이라는 React 컴포넌트를 만드세요. 이 컴포넌트는 사용자가 사용자 이름을 입력할 수 있는 입력 필드를 렌더링합니다.\n- useState 훅을 사용하여 사용자 이름 입력 필드의 상태를 관리하세요.\n- 사용자 이름이 제출되었는지 여부에 따라 채팅 인터페이스를 조건부로 렌더링하세요.\n\n단계 2: 채팅 인터페이스 표시\n\n- 사용자가 사용자 이름을 제출하면 채팅 인터페이스를 표시하세요.\n- 메시지를 입력할 수있는 입력 필드와 메시지를 전송하는 버튼을 제공하세요.\n- 사용자 이름이 제출되었을 때에만 채팅 인터페이스를 표시하도록 조건부 렌더링을 사용하세요.\n\n\n\n단계 3: 메시지 제출 처리\n\n- 메시지 제출을 처리하기 위해 handleMessageSend라는 함수를 정의하십시오.\n- 사용자가 전송 버튼을 클릭하면이 함수를 호출하여 Socket.IO를 통해 서버로 메시지를 전송하십시오.\n- useState 훅을 사용하여 입력 메시지 필드의 상태를 관리하고, 메시지를 전송 한 후에 필드를 지우십시오.\n\n단계 4: 실시간 통신을 위한 Socket.IO 통합\n\n- socket.io-client 라이브러리를 가져와 Socket.IO 서버에 연결을 설정하십시오.\n- 서버에 io 함수를 사용하여 연결하고 서버 URL을 제공하십시오.\n- 서버에서 수신된 메시지를 처리하는 이벤트 리스너를 정의하십시오.\n- 사용자가 메시지를 보낼 때 서버로 메시지를 발신하고, 클라이언트와 서버 간의 양방향 통신을 보장하십시오.\n\n\n\n그럼 src/App.css 파일 안으로 들어가서 다음 코드를 다음과 같이 바꿔주세요.\n\nsrc/App.css\n\n```css\nbody{\n  background-color: cadetblue;\n}\n\n/* Card를 가운데 정렬 */\n.card {\n  margin-top: 50px;\n}\n\n/* 메시지 컨테이너를 스타일링 */\n.message-container {\n  max-height: 300px;\n  overflow-y: auto;\n  padding: 10px;\n}\n\n/* 각각의 메시지 스타일링 */\n.message {\n  background-color: burlywood;\n  padding: 10px;\n  margin-bottom: 5px;\n  border-radius: 5px;\n}\n\n/* 입력 그룹을 스타일링 */\n.input-group {\n \n  /* bottom: 0;\n  left: 0;\n  right: 0; */\n  padding: 15px;\n  /* background-color: #f9f9f9;\n  border-top: 1px solid #ccc; */\n}\n```\n\n위 단계를 모두 완료하면 서버를 실행할 시간입니다.\n서버 폴더로 이동하여 다음 명령어를 실행하세요.\n\n\n\n```js\nnode server.js\n```\n\n다음으로, client 폴더로 이동하여 다음 명령어를 실행하세요\n\n```js\nnpm start\n```\n\n결과:\n\n\n\n![이미지 1](/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_1.png)\n\n![이미지 2](/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_2.png)\n\n도움이 되길 바라요...","ogImage":{"url":"/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png"},"coverImage":"/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png","tag":["Tech"],"readingTime":8},{"title":"모든 개발자가 알아야 할 5가지 커스텀 React Hooks","description":"","date":"2024-05-12 19:25","slug":"2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow","content":"\n\n경력 있는 ReactJS 개발자로서, 애플리케이션을 개발하는 동안 다양한 도전과 성공을 경험해왔어요. 여행을 하면서 저는 코드의 재사용성과 효율성을 향상시키기 위해 사용자 정의 React 훅에 많은 의존을 하게 되었어요. 이 글에서는 모든 개발자가 알아야 할 다섯 가지 사용자 정의 React 훅을 공유하고 싶어요. 각 훅을 하나씩 살펴보며 예시를 제시하고 제 경험도 함께 공유할 거에요.\n\n![이미지](/assets/img/2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow_0.png)\n\n\n# useLocalStorage\n\n브라우저 스토리지 관리는 React 애플리케이션에서 흔한 요구사항입니다. useLocalStorage 훅을 사용하면 값을 localStorage와 동기화할 수 있어요. 최근 프로젝트에서 이를 어떻게 활용했는지 예시를 보여드릴게요:\n\n\n\n```js\nimport { useState, useEffect } from 'react';\n\nconst useLocalStorage = (key, defaultValue) => {\n  const [value, setValue] = useState(() => {\n    const storedValue = localStorage.getItem(key);\n    return storedValue ? JSON.parse(storedValue) : defaultValue;\n  });\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n  return [value, setValue];\n};\n```\n\n이 훅 안에서는 상태 값을 로컬 스토리지에 저장된 값이나 제공된 기본 값으로 초기화합니다. 값이 변경될 때마다 스토리지를 업데이트하기 위해 useEffect를 사용합니다. 컴포넌트에서 이렇게 사용할 수 있습니다:\n\n```js\nconst App = () => {\n  const [name, setName] = useLocalStorage('name', 'John Doe');\n\n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <p>Hello, {name}!</p>\n    </div>\n  );\n};\n```\n\n# useMediaQuery\n\n\n\n\n지금은 애플리케이션을 반응형으로 만들어서 다양한 화면 크기에 적응하는 것이 중요합니다. useMediaQuery 훅을 사용하면 리액트에서 미디어 쿼리를 쉽게 처리할 수 있습니다. 저는 이를 어떻게 활용했는지의 예시를 보여드리겠습니다:\n\n```js\nimport { useState, useEffect } from 'react';\n\nconst useMediaQuery = (query) => {\n  const [matches, setMatches] = useState(\n    () => window.matchMedia(query).matches\n  );\n  useEffect(() => {\n    const mediaQuery = window.matchMedia(query);\n    const handleChange = (e) => setMatches(e.matches);\n    mediaQuery.addEventListener('change', handleChange);\n    return () => {\n      mediaQuery.removeEventListener('change', handleChange);\n    };\n  }, [query]);\n  return matches;\n};\n```\n\n이 예시에서는 이벤트 리스너와 matchMedia를 사용하여 미디어 쿼리의 변경 사항을 추적하고 있습니다. 다음은 컴포넌트에서 이를 사용하는 방법입니다:\n\n```js\nconst App = () => {\n  const isMobile = useMediaQuery('(max-width: 768px)');\n\n  return (\n    <div>\n      <h1>{isMobile ? '모바일 뷰' : '데스크톱 뷰'}</h1>\n    </div>\n  );\n};\n```\n\n\n\n# useDebounce\n\nDebouncing은 일정 시간 동안의 작업 실행을 지연시키는 기술입니다. useDebounce 훅을 사용하면 어떤 값을 디바운스할 수 있습니다. 아래는 예시입니다:\n\n```js\nimport { useState, useEffect } from 'react';\n\nconst useDebounce = (value, delay) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n};\n```\n\n이 훅을 사용하면 사용자 입력, API 요청 등을 디바운스할 수 있습니다. 다음은 실용적인 예시입니다:\n\n\n\n```js\n상태로써 App을 만들었어요. \nsearchTerm이란 상태와 setSearchTerm 함수를 만들었고, debouncedSearchTerm은 searchTerm을 500 밀리초로 지연시키는 함수를 사용하고 있어요.\n\nuseEffect 안에서는 debouncedSearchTerm을 감시하며 API 호출을 수행합니다.\n\n<input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />\n\n# useFetch\n\n비동기적으로 데이터를 가져오는 것은 현대 웹 개발에서 흔한 작업입니다. 이를 간단하게 처리해주는 useFetch 훅을 알아봅시다.\n\nimport { useState, useEffect } from 'react';\n\nconst useFetch = (url) => {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(true);\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        const json = await response.json();\n        setData(json);\n      } catch (error) {\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n  return { data, error, loading };\n};\n\n\n\n이 훅은 fetch 요청의 복잡성을 추상화하고 응답, 오류 및 로딩 상태를 제공합니다. 이 훅을 사용하는 방법은 다음과 같습니다:\n\nconst App = () => {\n  const { data, error, loading } = useFetch('https://api.example.com/data');\n\n  if (loading) {\n    return <p>데이터 불러오는 중...</p>;\n  }\n  if (error) {\n    return <p>오류 발생: {error.message}</p>;\n  }\n  return (\n    <div>\n      <ul>\n        {data.map((item) => (\n          <li key={item.id}>{item.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\n# useToggle\n\n토글 및 부울 상태를 관리하는 것은 때로는 복잡해질 수 있습니다. useToggle 훅을 사용하면 부울 상태를 쉽게 다룰 수 있습니다. 여기에 간단한 구현 방법이 있습니다:\n\n\n\nimport { useState } from 'react';\n\nconst useToggle = (initialValue = false) => {\n  const [value, setValue] = useState(initialValue);\n  const toggle = () => {\n    setValue((prevValue) => !prevValue);\n  };\n  return [value, toggle];\n};\n\n이 훅은 상태를 토글하는 프로세스를 간단하게 해줍니다. 아래는 사용 예시입니다:\n\nconst App = () => {\n  const [isModalOpen, toggleModal] = useToggle(false);\n\n  return (\n    <div>\n      <button onClick={toggleModal}>모달 토글</button>\n      {isModalOpen && <Modal />}\n    </div>\n  );\n};\n\n# 결론\n\n\n\n커스텀 React 훅은 개발 경험을 혁신적으로 향상시킬 수 있는 강력한 도구입니다. 이 글에서는 useLocalStorage, useMediaQuery, useDebounce, useFetch, 그리고 useToggle이라는 다섯 가지 커스텀 훅을 탐구했습니다. 이러한 훅을 활용하여 제 코드베이스를 최적화하고 코드 재사용성을 높이며 고품질 애플리케이션을 제공할 수 있었습니다. 여러분이 이 훅들을 저만큼 유용하게 느끼셨으면 좋겠네요. 즐거운 코딩 되세요!\n\n이 문서가 유용하다고 생각되면 박수를 치는 것을 고려해보세요. 한 번에 50번까지 박수를 칠 수 있어요!\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나기 전에:\n\n\n\n- 작가를 박수로 격려해주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-05-12-5CustomReactHooksEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":6},{"title":"React Nextjs에서 Boxicons 사용하는 방법","description":"","date":"2024-05-12 19:24","slug":"2024-05-12-BoxiconsReactNextjsTypeScriptIntegration","content":"\n<img src=\"/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_0.png\" />\n\n박스 아이콘(Boxicons)은 많은 오픈 소스 아이콘을 제공하여 웹사이트나 애플리케이션에 원활하게 통합할 수 있도록 도와주는 패키지입니다. 이 패키지는 JavaScript로 작성되어 있으며 온라인 저장소에 TypeScript 정의 파일이 없습니다. 이는 TypeScript 프로젝트에 통합하기가 조금 어렵다는 것을 의미합니다. 이 글은 React/Next.js TypeScript 프로젝트에 박스 아이콘을 통합하는 단계별 가이드를 제공합니다.\n\n# Next.JS\n\n## 1. 프로젝트 설정\n\n다음 명령어를 실행하여 Next.js 애플리케이션을 시작하세요.\n\n```js\nnpx create-next-app@latest\n```\n\n프로젝트에 이름을 지정하고 설치 프롬프트에서 기본 옵션을 선택하세요.\n\n```js\n프로젝트 이름은 무엇인가요? boxicons-nextjs-ts\nTypeScript를 사용하시겠습니까? No / Yes\nESLint를 사용하시겠습니까? No / Yes\nTailwind CSS를 사용하시겠습니까? No / Yes\n`src/` 디렉토리를 사용하시겠습니까? No / Yes\nApp Router를 사용하시겠습니까? (추천) No / Yes\n기본 import 별칭을 사용자 지정하시겠습니까? No / Yes\n구성할 import 별칭을 입력해주세요. @/*\n```\n\n다음은 프로젝트 구조가 설정된 Next.js 애플리케이션의 시작 코드를 생성해야 합니다.\n\n![Next.js Starter Code](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_1.png)\n\n## 2. 의존성 설치\n\nBoxicons 설치하기\n\n```js\nnpm install boxicons --save\n```\n\n## 3. 유형 정의\n\n“src\" 디렉토리에 “types\" 폴더를 만들고 그 안에 “boxicons.d.ts\"라는 파일을 생성하세요. 이 파일은 boxicons 패키지의 유형 정의를 담고 있을 것입니다. 다음 코드 스니펫을 \"boxicons.d.ts\" 파일에 붙여넣으세요.\n\nsrc/types/boxicons.d.ts\n\n```js\ndeclare module \"boxicons\" {\n  export type IconName = string;\n}\n```\n\n위의 코드 조각에서 boxicons 패키지를 위한 모듈 선언을 생성합니다. TypeScript가 모듈을 가져올 때 해당 모듈을 해결할 수 있도록 합니다. 또한, \"IconName\"이라는 문자열 타입이 내보내집니다. 이를 통해 아이콘 이름이 모두 문자열임을 보장하고, 발생 가능한 일부 버그를 미리 방지합니다.\n\n## 4. 스타일시트 임포트\n\n프로젝트에 boxicons 스타일시트를 추가하세요. 이는 애플리케이션의 메인 스타일시트 맨 위에 CSS import를 추가하여 수행할 수 있습니다. 기본적으로 Next.js의 \"src/pages\" 디렉토리에 있는 \"global.css\" 파일이 메인 애플리케이션 스타일시트입니다.\n\n동일한 결과를 얻으려면 \"src/pages\" 디렉토리의 \"layout.tsx\" 파일에 헤드 태그에 링크 태그를 추가하면 됩니다.\n\nsrc/pages/layout.tsx\n\n```js\nimport type { Metadata } from \"next\";\nimport { Inter } from \"next/font/google\";\nimport \"./globals.css\";\n\nconst inter = Inter({ subsets: [\"latin\"] });\n\nexport const metadata: Metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode,\n}>) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <link href=\"https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css\" rel=\"stylesheet\"></link>\n      </head>\n      <body className={inter.className}>{children}</body>\n    </html>\n  );\n}\n```\n\nOR\n\nsrc/pages/globals.css\n\n```js\n@import \"~boxicons/css/boxicons.min.css\";\n# OR\n@import url(\"boxicons/css/boxicons.min.css\");\n```\n\n## 5. 아이콘 컴포넌트 생성\n\n애플리케이션에 다양한 \"boxicons\"를 가져올 수 있는 아이콘 컴포넌트를 생성하세요. 이를 위해 \"src\" 디렉터리에 \"components\"라는 폴더를 만들고 그 안에 \"Icon.tsx\" 파일을 만드세요.\n\nsrc/components/Icon.tsx\n\n```js\nimport React from \"react\";\nimport { IconName } from \"boxicons\";\n\ninterface IconProps {\n  name: IconName;\n  size?: string;\n  color?: string;\n}\n\nconst Icon: React.FC<IconProps> = ({ name, size = \"24px\", color = \"\" }) => {\n  return <i className={`bx ${name}`} style={{ fontSize: size, color }} />;\n};\n\nexport default Icon;\n```\n\n`name` 속성은 표시할 아이콘을 변경하는 데 사용됩니다. 사용할 수 있는 모든 아이콘을 확인하려면 boxicons 웹 사이트를 확인하십시오. `size` 및 `color` 속성은 각각 아이콘의 크기 및 색상을 변경하는 데 사용됩니다.\n\n컴포넌트 디렉토리의 내용을 내보내는 \"index.ts\" 파일을 만듭니다. 이는 가져오기를 \"깔끔하게\" 유지하기 위한 것이며, 이 단계를 건너 뛰어도 괜찮습니다.\n\nsrc/components/index.ts\n\n```js\nimport Icon from \"./Icon\";\n\nexport { Icon };\n```\n\n## 6. Icon 사용법\n\n프로젝트 전반에 걸쳐 사용하기 위해 components 디렉토리에서 Icon 컴포넌트를 import합니다. 아래는 예시입니다:\n\nsrc/pages/pages.tsx\n\n```js\nimport { Icon } from \"@/components\";\n\nexport default function Home() {\n  return (\n    <main className=\"flex min-h-screen flex-col items-center justify-center py-24 gap-3\">\n      <Icon name=\"bx-run\" size=\"108px\" />\n      <h2 className=\"text-6xl\">함께 떠나요</h2>\n      <div className=\"flex mt-4 gap-3\">\n        <Icon name=\"bx-rocket\" size=\"64px\" />\n        <Icon name=\"bx-rocket\" size=\"64px\" />\n      </div>\n    </main>\n  );\n}\n```\n\n개발 서버를 실행하여 아이콘이 표시되는지 확인해 보세요.\n\n```js\nnpm run dev\n```\n\nViolaaa 🚀\n\n![image](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_2.png)\n\n이 프로젝트의 소스 코드가 포함된 GitHub 저장소 링크입니다:\n\n[https://github.com/Quarcoo-arc/boxicons-nextjs-ts.git](https://github.com/Quarcoo-arc/boxicons-nextjs-ts.git)\n\n# React\n\nReact와 TypeScript 프로젝트에 boxicons를 통합하는 것은 Next.js와 TypeScript 프로젝트에 통합하는 것과 유사합니다. 그러나 몇 가지 차이가 있습니다. 이를 아래에서 강조했습니다.\n\n## 1. 프로젝트 설정\n\nReact 프로젝트를 설정하는 가장 쉬운 방법은 create-react-app 또는 Vite를 사용하는 것입니다. 저는 Vite를 선호합니다. 왜냐하면 이름이 시사하는 대로 빠르기 때문입니다. Vite는 \"신속\"을 뜻하는 프랑스어 단어이며 /vit/으로 발음합니다. 충분히 어휘적인 얘기는 여기까지 하고 아이콘들을 표시해봅시다 🚀.\n\n다음 명령어를 실행하여 Vite를 사용한 React + TypeScript 프로젝트를 시작하세요:\n\n```js\nnpm create vite@latest\n```\n\n프로젝트 이름 (boxicons-react-ts), 프레임워크 (React), 그리고 변형 (TypeScript)을 옵션에 설정하세요. 프로젝트 디렉토리로 이동하고 애플리케이션 종속성을 설치하세요.\n\n```js\ncd boxicons-react-ts\nnpm install\n```\n\n위 명령들을 실행하면 다음과 같은 폴더 구조를 갖는 프로젝트가 생성됩니다.\n\n![폴더 구조](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_3.png)\n\n## 2. 종속성 설치\n\nboxicons를 설치하세요. Next.JS 부분의 두 번째 섹션에 설명된 대로 진행하시면 됩니다.\n\n## 3. 유형 정의\n\nReact 및 Next.js에 대한 유형 정의 파일을 생성하는 방법은 동일합니다.\n\n## 4. 스타일시트 가져오기\n\nNext.js와 마찬가지로 React에서 boxicons 스타일시트를 가져오는 두 가지 옵션이 있습니다; head 태그 내부에 링크 태그를 사용하거나 CSS를 가져오는 것입니다. 차이점은 src/pages/layout.tsx가 아닌 프로젝트의 루트 디렉토리의 index.html 파일에 링크 태그가 추가된다는 점입니다. 또한 CSS를 가져오는 위치는 src/pages/globals.css가 아닌 React 애플리케이션의 기본 주 스타일시트인 src/index.css에 위치합니다.\n\n한 가지 더 알려드릴게요. 이 CSS import를 사용하면 오류가 발생합니다:\n\n```js\n# 오류가 발생합니다 ❌\n@import \"~boxicons/css/boxicons.min.css\";\n```\n\n이것을 대신 사용하세요:\n\n```js\n# 이것을 대신 사용하세요 ✅\n@import url(\"boxicons/css/boxicons.min.css\");\n```\n\n```css\n@import url(\"https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css\");\n```\n\n## 6. 아이콘 사용법\n\n이제 아이콘 컴포넌트를 가져와 프로젝트 전반에 사용할 수 있습니다. 아래에서 확인할 수 있습니다.\n\nsrc/App.tsx\n\n```jsx\nimport \"./App.css\";\nimport { Icon } from \"./components\";\n\nfunction App() {\n  return (\n    <div>\n      <Icon name=\"bxl-typescript\" size=\"36px\" />\n      <Icon name=\"bx-plus\" size=\"36px\" />\n      <Icon name=\"bxl-react\" size=\"36px\" />\n      <h1>We go again</h1>\n      <Icon name=\"bx-rocket\" size=\"36px\" />\n      <Icon name=\"bx-rocket\" size=\"36px\" />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n개발 서버를 실행해서 아이콘들을 확인해보세요.\n\n```js\nnpm run dev\n```\n\n![아이콘 이미지](/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_4.png)\n\n이 프로젝트의 소스 코드가 포함된 GitHub 저장소 링크입니다:\n\n위의 링크를 통해, React/Next.js + TypeScript 프로젝트에서 boxicons를 사용할 준비가 끝났어요. TypeScript 프로젝트에서 typings이 제공되지 않는 JavaScript 패키지를 사용하는 방법도 비슷하게 따를 수 있어요.\n","ogImage":{"url":"/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_0.png"},"coverImage":"/assets/img/2024-05-12-BoxiconsReactNextjsTypeScriptIntegration_0.png","tag":["Tech"],"readingTime":7},{"title":" 당신의 React 프로젝트를 위한 전화 입력 - react-international-phone","description":"","date":"2024-05-12 19:23","slug":"2024-05-12-PhoneinputforyourReactprojectreact-international-phone","content":"\n\n## React 코드베이스에 멋진 국제 전화번호 입력 컴포넌트를 구현해보세요\n\n## 배경 이야기\n\n저는 React를 UI 빌딩 라이브러리로 사용하는 내 작업 프로젝트 중 하나에서 휴대전화 번호를 입력하는 컴포넌트를 구현하는 문제를 마주쳤어요. 사용하던 한 인기 있는 전화 입력 라이브러리를 사용하는 컴포넌트가 있었지만, 스타일링하기 불편하고 작업하기도 어려웠어요.\n\n일부 npm 패키지를 조사한 후, 제 요구 사항을 충족시키는 라이브러리가 없다는 것을 알게 되었어요:\n\n\n\n- 전화 번호 형식은 모든 입력 구성 요소에 쉽게 통합할 수 있어야 합니다 (Material UI, Chakra UI, Ant Design 등과 같은 모든 UI 프레임워크와 통합 가능).\n- 쉽게 스타일링할 수 있는 독립적인 전화 번호 입력 구성 요소를 제공해야 합니다.\n- 입력 시 편안한 느낌이어야 합니다. 입력 캐럿 위치가 제대로 처리되어야 하며, 복사/붙여넣기/실행 취소/다시 실행이 예상대로 작동해야 합니다.\n- 입력된 전화 번호를 확인할 수 있는 방법을 제공해야 합니다.\n\n그래서 이러한 기능을 모두 지원하는 내 라이브러리를 작성하기로 결정했습니다.\n\n# react-international-phone\n\n🎉 react-international-phone을 소개합니다! 🎉\n\n\n\n라이브러리는 React 애플리케이션용 전화 입력 컴포넌트를 제공합니다. 국제 지원을 포함한 전화 번호를 위한 사용자 정의 가능하고 쉽게 사용할 수 있는 입력 필드를 제공합니다.\n\n![전화 입력 컴포넌트](https://miro.medium.com/v2/resize:fit:642/1*4NHcF2JMyXfeqVlCRJD9PQ.gif)\n\nreact-international-phone의 주요 기능:\n\n- 🌈 입력란 내에서 타이핑, 복사/붙여넣기, 실행취소/다시실행이 자연스럽게 작동\n- 🔍 전화 번호 형식(국가 추측과 함께)\n- 🏁 국가 깃발 렌더링(Twemoji와 함께)\n- ✅ 기본 제공 전화 유효성 검사\n- 🔒 제3자 의존성 없음(낮은 번들 크기)\n- 🔧 쉽게 사용자 정의 가능합니다\n\n\n\n## 기본 사용법\n\n이 라이브러리는 통합하기 매우 쉽습니다. PhoneInput 컴포넌트와 스타일을 가져오기만 하면 됩니다. 다음은 기본 사용법 코드 스니펫입니다:\n\n```js\nimport { useState } from 'react';\nimport { PhoneInput } from 'react-international-phone';\nimport 'react-international-phone/style.css';\n\nconst App = () => {\n  const [phone, setPhone] = useState('');\n\n  return (\n    <div>\n      <PhoneInput\n        defaultCountry=\"ua\"\n        value={phone}\n        onChange={(phone) => setPhone(phone)}\n      />\n    </div>\n  );\n};\n```\n\nCodeSandbox에서 라이브 데모를 확인하세요\n\n\n\n## UI 라이브러리 통합\n\nreact-international-phone은 Material UI, Ant Design, 또는 Chakra UI와 같은 거의 모든 기존 UI 라이브러리와 통합할 수 있습니다.\n\n보통 사용하는 입력 필드와 함께 전화 번호 형식 지정 로직을 제공하는 usePhoneInput 훅을 사용하고, 국가 선택 드롭다운을 제공하는 `CountrySelector/` 하위 구성 요소를 함께 사용할 수 있습니다.\n\nMUI, Chakra, 그리고 Antd를 사용한 라이브러리 사용 예제가 있습니다:\n\n\n\n## ✔️ 유효성 검사\n\n이 패키지는 (당연히) 전화번호 유효성 검사를 제공하는 usePhoneValidation 훅을 제공합니다.\n\n```js\nconst [phone, setPhone] = useState(\"\");\nconst phoneValidation = usePhoneValidation(phone);\n\n// 이제 `phoneValidation.isValid`를 사용하여 전화번호가 유효한지 확인할 수 있습니다\n```\n\n## 🔧 사용자 정의\n\n\n\n라이브러리는 전화 입력의 기본 동작과 모양을 사용자 지정하는 방법을 제공합니다. 다음은 가능한 작업의 일부입니다:\n\n- 프롭 또는 CSS를 통해 `PhoneInput/` 컴포넌트의 어떤 부분에도 사용자 정의 스타일 적용\n- 다이얼 코드 강제 (선택된 국가 다이얼 코드를 삭제/변경하지 못하도록 함)\n- 국가 선택기 드롭다운 숨기기\n- 초기 국가 자동 입력 비활성화\n- 국가 다이얼 코드 숨기기\n- 국가 목록 필터링 및 수정\n\n이러한 사용 사례의 데모를 이 스토리북에서 확인할 수 있습니다:\nhttps://react-international-phone-storybook.vercel.app/\n\n## 📚 문서\n\n\n\n아래에 전체 설명서를 찾을 수 있습니다:\nhttps://react-international-phone.vercel.app/\n\n## 🌟 감사합니다\n\nreact-international-phone 패키지가 마음에 드시면 GitHub 저장소에 별을 남겨주세요.\n문제, 버그, 또는 질문이 있으면 GitHub에 이슈를 열거나 토론을 해주세요.\n\n도움이 되었다면 박수를 잊지 마세요!\n즐거운 코딩하세요 👋","ogImage":{"url":"/assets/img/2024-05-12-PhoneinputforyourReactprojectreact-international-phone_0.png"},"coverImage":"/assets/img/2024-05-12-PhoneinputforyourReactprojectreact-international-phone_0.png","tag":["Tech"],"readingTime":3},{"title":"ESLint 구성 이해 eslintrcjs 대 eslintrc 대 eslintrcjson","description":"","date":"2024-05-12 19:22","slug":"2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson","content":"\n\nESLint은 JavaScript 생태계에서 중심 도구로 작용하여 개발자가 코드 품질을 유지하고 코딩 표준을 준수할 수 있도록 돕습니다. 그러나 ESLint를 구성하는 것이 항상 간단하지는 않습니다, 특히 .eslintrc.js, .eslintrc 및 .eslintrc.json과 같은 다양한 구성 형식 중에서 선택해야 할 때에는 더욱 그렇습니다. 각 형식의 세부 사항을 자세히 살펴보고 그 차이와 가장 적합한 사용 사례에 대해 알아봅시다.\n\n# .eslintrc.js 해석하기\n\n.eslintrc.js는 JavaScript 파일로, JavaScript 코드를 사용하여 ESLint를 동적으로 구성할 수 있는 구성 객체를 익스포트합니다. 이 형식은 복잡한 로직과 환경별 구성을 설정에 포함시킬 수 있는 가장 탁월한 유연성을 제공합니다.\n\n다음은 .eslintrc.js 파일이 어떻게 보일 수 있는지 한 눈에 들어보세요:  \n\n\n\n<img src=\"/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_0.png\" />\n\n# JSON 형식의 .eslintrc 탐구하기\n\n.eslintrc는 ESLint 구성을 캡슐화하는 JSON 형식의 파일입니다. .eslintrc.js와 달리 이 형식은 JavaScript 표현식이나 동적 로직을 지원하지 않습니다. 더 단순하고 선언적인 설정 방식을 제공합니다.\n\n다음은 .eslintrc 파일의 예시입니다:\n\n\n\n\n![이미지](/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_1.png)\n\n# .eslintrc.json 이해하기\n\n.eslintrc.json은 .eslintrc와 유사하게 ESLint 구성을 JSON 형식으로 제공합니다. 파일 이름 규칙이 다르지만 동일한 목적을 제공합니다. 두 형식 모두 대부분의 프로젝트에서 간편하게 사용할 수 있도록 간결하고 사용이 간편합니다.\n\n![이미지](/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_2.png)\n\n\n\n# 비교: 적합한 옵션 찾기\n\n- 유연성: .eslintrc.js는 유연성 면에서 우수하며, 개발자들이 동적 논리를 포함하고 다양한 환경에 기반한 구성을 맞춤 설정할 수 있습니다.\n\n- 간결함: .eslintrc 및 .eslintrc.json은 더 간단하고 직관적인 방식으로, 표준 구성 요구 사항을 갖는 프로젝트에 이상적입니다.\n\n- 커뮤니티 표준: .eslintrc.js가 복잡한 설정에 선호되는 반면, .eslintrc 및 .eslintrc.json은 간단한 구성에 선호되며, 커뮤니티 표준에 부합합니다.\n\n# 결론: 개발 실무 능력 강화\n\nESLint 구성 형식 선택은 프로젝트 복잡도와 팀 선호도에 달려 있습니다. .eslintrc.js는 뛰어난 유연성을 제공하나, .eslintrc 및 .eslintrc.json은 대부분의 프로젝트에 대한 간소화된 옵션을 제공합니다. 이 차이를 이해하면 개발자들이 ESLint를 효과적으로 구성하여 일관된 코드 품질을 유지할 수 있습니다.\n\n\n\n본질적으로, 당신의 선호 및 프로젝트 요구 사항에 따라 ESLint 구성 형식을 선택합니다. 그럼에도 불구하고, .eslintrc.js의 동적 성격은 복잡한 설정과 전문화된 구성에 대한 매력적인 선택으로 작용합니다.\n\n# 인사이트 공유\n\n당신이 선호하는 ESLint 구성 형식은 무엇이며, 그 이유는 무엇인가요? 프로젝트에 ESLint를 구성하는 동안 어려움을 겪은 적이 있나요? 혹은 혜택을 본 적이 있나요? 아래 댓글에서 당신의 경험과 인사이트를 공유해주세요!","ogImage":{"url":"/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_0.png"},"coverImage":"/assets/img/2024-05-12-UnderstandingESLintConfigurationeslintrcjsvseslintrcvseslintrcjson_0.png","tag":["Tech"],"readingTime":2},{"title":"React 및 Framer Motion을 사용하여 무한 아이콘 슬라이더 구현하기","description":"","date":"2024-05-12 19:21","slug":"2024-05-12-ImplementinganInfiniteIconSliderinReactwithFramerMotion","content":"\n\n무한 슬라이더는 웹 개발에서 인기 있는 UI 패턴으로, 이미지나 기타 미디어와 같은 콘텐츠를 연속적인 루프로 표시하는 데 사용됩니다. 무한 슬라이더의 핵심 원칙은 콘텐츠 항목의 집합을 중단 또는 간격 없이 매끄럽게 순환하면서 부드럽고 중단되지 않는 뷰잉 경험을 만드는 것입니다.\n\n잘 디자인된 슬라이더는 멋진 모던한 미적 감각을 유지하면서 상당한 양의 정보를 단일 구성 요소로 압축할 수 있습니다. 이는 사용자 참여를 향상시키고 웹 페이지에서 공간을 최적화하는 데 탁월한 도구로, 특히 시각적 영향이 필수적인 포트폴리오, 전자 상거래 사이트 및 뉴스 플랫폼에서 매우 유용합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*fEvCBFUBUUM-HggRUqK1tQ.gif)\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*Nz6dhLM2nwazz_7vTR_2rg.gif)\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*XQuY6aY78mpNcJ7C8mtZ4Q.gif\" />\n\n이 글은 무한 슬라이더를 만드는 기초와 기본 사항을 안내합니다. 30분 이상 YouTube 비디오를 시청하는 것보다 더 효율적인 학습 방법을 제공합니다. 이 튜토리얼을 마치면 이 기능을 구현하는 방법 뿐만 아니라 코드를 선호에 따라 사용자 정의하고 향상시킬 수 있는 방법을 이해할 수 있습니다.\n\n# 전제 조건\n\n시작하기 전에 다음 사항을 준비해야 합니다:\n\n\n\n- 리액트 프로젝트 설정이 완료되었습니다.\n- Tailwind 의존성이 설치되었습니다. npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p\n- Framer Motion 이 설치되었습니다. npm install framer-motion\n- Radix 아이콘 패키지가 설치되었습니다. npm install @radix-ui/react-icons\n\n![Icon Slider](/assets/img/2024-05-12-ImplementinganInfiniteIconSliderinReactwithFramerMotion_0.png)\n\n# 무한 슬라이더 구현하기\n\n# 단계 1: 기본 슬라이더 만들기\n\n\n\nSliderNumber.jsx\n\n```js\nimport React from 'react';\nimport { motion } from 'framer-motion';\n\n// 숫자로 된 슬라이드 배열 정의\nconst slides = [\n    { number: 1 },\n    { number: 2 },\n    { number: 3 },\n    { number: 4 },\n    { number: 5 },\n];\n\nconst SliderNumber = () => {\n    // 신속한 루핑을 보장하기 위해 슬라이드 배열을 복제합니다.\n    const duplicatedSlides = [...slides, ...slides];\n\n    return (\n        <div className=\"relative w-full overflow-hidden\">\n            {/* 신속한 루핑을 위한 래핑 div */}\n            <motion.div\n                className=\"flex\"\n                animate={{\n                    x: ['-100%', '0%'],\n                    transition: {\n                        ease: 'linear',\n                        duration: 5,\n                        repeat: Infinity,\n                    },\n                }}\n            >\n                {/* 복제된 슬라이드 렌더링 */}\n                {duplicatedSlides.map((slide, index) => (\n                    <div key={index} className=\"flex-shrink-0\" style={{ width: `${100 / slides.length}%` }}>\n                        <div className=\"flex flex-col items-center justify-center h-full text-6xl\">\n                            {slide.number}\n                        </div>\n                    </div>\n                ))}\n            </motion.div>\n        </div>\n    );\n};\n\nexport default SliderNumber;\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*gFdYciuJgTYyJj2evLgauw.gif)\n\nFramer Motion의 강력한 애니메이션 기능과 몇 줄의 코드만으로 무한 슬라이더의 기반을 마련했습니다.\n\n\n\n해설:\n\n- 슬라이드 배열: 표시할 슬라이드를 나타내는 간단한 배열입니다. 각 슬라이드는 숫자를 포함하는 객체입니다.\n- 중복된 슬라이드: 무한 루프 효과를 얻기 위해 슬라이드 배열이 복제됩니다. 이 복제는 한 세트의 슬라이드가 보이는 영역을 벗어나면 동일한 세트가 나타나도록하여 끝없는 싸이클을 만드는 환상을 창출합니다.\n- Motion Div: Framer Motion에서 제공하는 애니메이션을 담당하는 래퍼 div입니다. animate 속성은 콘텐츠를 100% (오른쪽에서 약간 벗어난 위치에서 시작)에서 0% (뷰포트를 채우는 위치)로 수평으로 이동하도록 구성되어 있습니다. 전환은 선형 팽창으로 설정되며, 반복 횟수는 무한대(Infinity)이며, 지속 시간은 5초입니다.\n- 슬라이드 렌더링: 각 슬라이드(원본 및 복제본 모두)는 자체 div 내에 렌더링되며, 전체 슬라이드 수에 대한 비율에 따라 너비가 제어됩니다. 이를 통해 슬라이더 내에서 각 슬라이드가 수평 공간의 동일한 부분을 차지하도록 합니다.\n\n이 기본 설정은 추가 스타일, 상호작용 요소 또는 다양한 콘텐츠 유형과 함께 확장하고 사용자 참여를 향상시킬 수 있는 다양한 애플리케이션에 적합한 다목적 구성 요소로 사용할 수 있습니다. 이미지, 텍스트 또는 동적 콘텐츠를 표시하든, 이 무한 슬라이더는 사이트에서 사용자 참여를 높이는 현대적이고 세련된 솔루션으로 제공됩니다.\n\n더 멋진 것을 만들어 봅시다!\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*fEvCBFUBUUM-HggRUqK1tQ.gif\" />\n\n# 단계 2: 고급 아이콘 슬라이더 생성하기\n\n슬라이더에 깊이와 주목을 끌기 위한 효과적인 방법 중 하나는 아이콘이 뷰포트에 들어오거나 빠져나갈 때 페이드 인 및 페이드 아웃 효과를 적용하는 것입니다. 이는 슬라이더 구성 요소의 가장자리에 흐릿한 효과를 적용하여 달성할 수 있습니다.\n\nSliderDesign2.jsx\n\n\n\n```js\r\nimport React from 'react';\nimport { motion } from 'framer-motion';\nimport {\n    FigmaLogoIcon,\n    FramerLogoIcon,\n    SketchLogoIcon,\n    TwitterLogoIcon,\n    GitHubLogoIcon,\n    VercelLogoIcon,\n    NotionLogoIcon,\n    DiscordLogoIcon,\n    InstagramLogoIcon,\n    LinkedInLogoIcon,\n} from \"@radix-ui/react-icons\";\n\nconst slides = [\n    { icon: <FigmaLogoIcon /> },\n    { icon: <TwitterLogoIcon /> },\n    { icon: <GitHubLogoIcon /> },\n    { icon: <InstagramLogoIcon /> },\n    { icon: <LinkedInLogoIcon /> },\n    { icon: <DiscordLogoIcon /> },\n    { icon: <SketchLogoIcon /> },\n    { icon: <NotionLogoIcon /> },\n    { icon: <VercelLogoIcon /> },\n];\n\n\n\nconst SliderDesign2 = () => {\n    const duplicatedSlides = [...slides, ...slides];\n\n    return (\n        <div className=\"relative h-full overflow-hidden py-12 bg-white mx-auto\" style={ width: \"50%\" }>\n\n            <div className=\"absolute inset-0 z-20 before:absolute before:left-0 before:top-0 before:w-1/4 before:h-full before:bg-gradient-to-r before:from-white before:to-transparent before:filter before:blur-3 after:absolute after:right-0 after:top-0 after:w-1/4 after:h-full after:bg-gradient-to-l after:from-white after:to-transparent after:filter after:blur-3\"></div>\n\n            <motion.div\n                className=\"flex\"\n                animate={\n                    x: ['0%', '-100%'],\n                    transition: {\n                        ease: 'linear',\n                        duration: 15,\n                        repeat: Infinity,\n                    }\n                }\n            >\n                {duplicatedSlides.map((slide, index) => (\n                    <div key={index} className=\"flex-shrink-0\" style={ width: `${100 / slides.length}%` }>\n                        <div className=\"flex items-center justify-center h-full\">\n                            {slide.icon}\n                        </div>\n                    </div>\n                ))}\n            </motion.div>\n        </div>\n    );\n};\n\nexport default SliderDesign2;\r\n```\n\n이 고급 슬라이더 설정은 웹페이지에서 로고나 아이콘을 더 상호작용적이고 시각적으로 매력적으로 표현하는 방법을 제공하여, 포트폴리오, 회사 페이지 또는 브랜드 가시성이 중요한 모든 응용 프로그램에 이상적입니다.\n\n이제 무한 슬라이더가 작동하는 방법을 이해했으니, 여러분들만의 디자인을 시작해보세요!\n\n전체 디자인을 다운로드할 수 있는 GitHub을 확인해보세요!\r\n","ogImage":{"url":"/assets/img/2024-05-12-ImplementinganInfiniteIconSliderinReactwithFramerMotion_0.png"},"coverImage":"/assets/img/2024-05-12-ImplementinganInfiniteIconSliderinReactwithFramerMotion_0.png","tag":["Tech"],"readingTime":6},{"title":"Vite React 앱을 Azure App Service에 CI CD 파이프라인GitHub Actions을 사용하여 배포하는 방법","description":"","date":"2024-05-12 19:18","slug":"2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions","content":"\n\n개인 React 프로젝트를 시작하거나 제품용 대규모 웹 애플리케이션을 구축하든, React 앱을 호스팅하는 다양한 옵션이 많습니다. 최근에 Azure를 좀 더 전문적으로 다뤄보면서, Vite + React 앱을 Azure에 배포하고 CI/CD 파이프라인을 통해 성공적으로 실행 및 지속적으로 배포하는 방법을 공유하고 싶었어요.\n\n시작하기 전에 다음 사항을 필요로 합니다:\n\n- 활성 구독이 있는 Microsoft Azure 계정\n- 시스템에 최신 Node LTS (v18.16.1 현재 버전)이 설치되어 있어야 합니다\n- GitHub 계정\n\n다음과 관련해서 편안해야 해요:\n\n\n\n- Bash/Zsh을 사용한 명령 줄\n- Git\n- npm, yarn, pnpm과 같은 모든 Node 패키지 관리 시스템\n- YAML: [YAML이란 무엇인가요? - 초보자를 위한 안내서](https://circleci.com/blog/what-is-yaml-a-beginner-s-guide/)\n- Azure 포털: [Azure 포털](https://portal.azure.com/)\n\n시작하기 전에, 제목에서 언급된 중요한 개념 몇 가지를 먼저 명확히해 보겠습니다: Azure App Service 및 CI/CD 파이프라인.\n\n# Azure App Service란\n\nAzure App Service는 웹 앱, RESTful API 및 모바일 백엔드를 호스팅하기 위한 Azure의 플랫폼 서비스(PaaS)입니다. GitHub Actions를 사용한 지속적인 배포를 포함한 내장된 DevOps 기능도 제공됩니다.\n\n\n\nAzure App Service에는 Web App, Web App + Database 및 Static Web App이라는 세 가지 서비스 옵션이 있어요.\n\n![Azure App Service](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_0.png)\n\n이 세 가지 옵션의 이름은 자명해요. Static Web App Service의 중요한 점은 백엔드 API 측면에서 제약 사항이 있다는 것이에요: https://learn.microsoft.com/en-us/azure/static-web-apps/apis-overview#constraints.\n\n백엔드 API를 사용하는 정적 웹사이트를 디플로이할 때 Azure Functions만 사용한다면 Static Web App을 사용해도 문제가 없어요. 공식 Vite 문서에는 Azure Static Web App으로의 배포 방법에 대한 안내가 있어요: https://vitejs.dev/guide/static-deploy.html#azure-static-web-apps\n\n\n\n그러나 더 복잡한 사용 사례의 경우, 웹 앱 또는 Web 앱 + 데이터베이스를 사용하고 싶을 것입니다. 저는 웹 앱 서비스를 사용하고 있지만 귀하의 요구에 가장 적합한 것을 선택할 수 있습니다.\n\n# CI/CD란 무엇인가요?\n\nCI는 지속적인 통합(Continuous Integration)을 의미하고, CD는 지속적인 전달 및 배포(Continuous Delivery and Continuous Deployment)를 의미합니다. CI/CD는 소프트웨어를 유연한 환경에서 빈번한 배포를 보장하는 데 중요한 프로세스입니다.\n\n지속적인 통합(CI)은 새 코드 변경사항을 자동으로 공유 저장소에 통합하는 프로세스입니다. 이는 \"우리는 새로운 코드 변경을 만들었는데, 그것을 기존 코드베이스에 어떻게 통합할까요?\"라는 질문에 대답합니다.\n\n\n\n지속적 전달과 지속적 배포 (CD)는 보통 함께 그룹화되지만, 두 가지를 구별하는 것이 중요합니다:\n\n지속적 전달은 테스트, 버그 확인, 통합된 코드 변경이 언제든지 저장소에서 프로덕션으로 이동할 수 있는 자동화된 프로세스를 가지는 것을 의미합니다. 이는 \"우리는 변경 사항을 저장소에 통합했는데, 이제 어떻게 효율적으로 작업물을 전달할까?\"라는 질문에 대응합니다.\n\n지속적 배포는 저장소에서 프로덕션으로의 배포 프로세스를 자동화하는 것을 의미합니다. 이는 \"우리는 작업물을 전달했는데, 이제 어떻게 배포해서 최종 사용자가 경험할 수 있게 할까?\"라는 질문에 대응합니다.\n\nCI/CD 파이프라인은 소프트웨어를 빌드, 테스트하고 프로덕션으로 릴리스하는 자동화된 프로세스이며, 이 프로세스를 돕는 여러 도구들이 있습니다.\n\n\n\nGitHub Actions은 GitHub의 자체 CI/CD 플랫폼으로, 빌드, 테스트 및 배포 파이프라인을 GitHub 내에서 자동화할 수 있습니다. 2018년에 출시된 이후로 개발자들 사이에서 인기를 얻고 있습니다. 이전에 CircleCI와 같은 다른 CI/CD 플랫폼을 사용해본 적이 있다면, GitHub Actions를 사용하는 것이 쉬울 것입니다.\n\nCI/CD에 처음 접하는 경우 걱정하지 마세요. 나중에 이 글에서 워크플로우 설정에 대해 자세히 설명하겠습니다. GitHub Actions를 사용하여 애플리케이션을 테스트하고 빌드하며, 코드 변경이 main 브랜치에 푸시될 때마다 Azure App Service에 배포하는 배포 워크플로우를 설정하는 방법을 배울 수 있을 것입니다.\n\n# 단계별 가이드\n\n## Azure 포털을 통해 Azure 앱 서비스 만들기\n\n\n\n- 홈으로 이동하십시오 — 리소스 그룹 — 만들기.\n\n'앱이름'_dev로 이름을 지정한 리소스 그룹을 귀하의 지역에 만들고, 검토 + 생성을 클릭하세요. 이것은 우리의 개발 리소스 그룹이 될 것입니다. 필요하면 나중에 테스트 및 프로덕션 그룹을 만들 수도 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_1.png)\n\n2. 홈으로 이동하십시오 — 앱 서비스 — 만들기 — 웹 앱\n\n\n\n구독을 선택하고 방금 만든 같은 리소스 그룹을 선택하십시오:\n\n![image](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_2.png)\n\n다음과 같이 인스턴스 세부 정보를 입력하십시오:\n\n이름: 'your_app의_이름'\n\n\n\n발행: 코드\n\n런타임 스택: Node 18 LTS\n\n운영 체제: 리소스 그룹에 따라 Linux 또는 Windows를 선택하실 수 있습니다. 저는 여기서는 Linux를 선택했습니다.\n\n지역: 리소스 그룹과 동일한 지역\n\n\n\n가격제도: 당신만의 요금제를 선택하세요. 개인 프로젝트의 경우, 무료 F1 요금제가 충분할 것입니다.\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_3.png)\n\n모든 필드를 채운 후에는 배포를 구성하기 위해 다음을 클릭할 수 있습니다.\n\n만약 당신의 애플리케이션이 Windows에서 실행 중이라면, 직접 지속적인 배포를 설정할 수 있습니다. Azure는 Linux에서 F1 요금제로 실행 중인 앱에 대해 이 기능을 지원하지 않습니다. 걱정마세요, 앱 서비스가 생성된 후 지속적인 배포를 설정할 것입니다.\n\n\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_4.png)\n\n나머지 단계는 선택 사항입니다. 빠르게 \"검토 + 만들기\"로 이동할 수 있어요. 만들기를 클릭하면 앱 서비스 배포가 진행 중임을 확인할 수 있어요.\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_5.png)\n\n3. 배포가 완료되면 몇 분만 걸릴 것입니다. \"홈 - 앱 서비스\"로 이동하면 새로운 앱 서비스가 표시되며 확인할 수 있을 거예요.\n\n\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_6.png)\n\n브라우즈 버튼을 클릭하거나 다음 URL(https://'name_of_your_app'.azurewebsites.net)로 이동하여 아래 페이지를 확인할 수 있습니다. Azure에서 웹 앱에 대한 콘텐츠를 받지 못했다는 일반적인 문제 해결 페이지입니다.\n\n![다른 이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_7.png)\n\n그러니 이제 프로젝트를 배포하고 Azure에서 지속적인 배포를 설정해 봅시다.\n\n\n\n## 프로젝트 설정 (GitHub에서 이미 레포지토리를 가지고 있으면 이 부분을 건너뛰세요)\n\n이미 프로젝트를 설정한 적이 없다면, 이 섹션에서는 React 앱을 Vite를 사용하여 설정하는 방법을 보여드립니다. 저는 개인적으로 Microsoft 튜토리얼에서는 Create React App을 사용하는 경향이 있지만, Vite를 사용하는 것을 선호합니다.\n\n제 경험상, Vite 같은 빠른 빌드 도구를 사용하면 개발 프로세스를 가속화할 수 있어 개발자 경험을 향상시키고 응용 프로그램 구축에 더 집중할 수 있습니다. Vite의 테스트 러너 Vitest 역시 속도가 빠르며 빠른 피드백을 제공해주어 테스트 주도 개발(TDD)을 할 때 특히 큰 도움이 됩니다.\n\n일반적으로 사용하는 빌드 도구가 Create React App인 경우, 여러분이 평소처럼 React 애플리케이션을 구동시키세요.\n\n\n\nVite와 npm을 사용하는 경우, 다음 명령어로 새 React 애플리케이션을 만들 수 있어요:\n\n```js\nnpm create vite@latest\n```\n\nVite로 빌드하는 데 더 많은 정보를 원하시면 여기를 확인해 보세요: https://vitejs.dev/guide/\n\n프로젝트 이름을 입력하고, React를 선택하고, JavaScript/TypeScript를 선택하도록 프롬프트를 따라가세요.\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_8.png\" />\n\n이제 Vite가 마법을 부리며 프로젝트 구조를 설정할 것입니다. 완료되면 터미널에서 다음 명령어를 입력하세요:\n\n```js\ncd {name_of_your_app} # 프로젝트 디렉토리로 이동\nnpm install # 프로젝트 의존성 설치\nnpm run dev # 개발 모드에서 어플리케이션 실행. 기본적으로 5173포트에서 실행됩니다.\n```\n\nhttp://localhost:5173으로 이동하여 방금 생성한 React 프로젝트를 확인하세요.\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_9.png\" />\n\n지금 깃허브에서 새 저장소를 생성하고 프로젝트 코드를 모두 커밋해주세요. 그럼 GitHub Actions를 사용하여 Azure App Service로 배포할 수 있게 됩니다.\n\n## GitHub Actions를 활용한 지속적 배포\n\nAzure App Service는 BitBucket, GitHub, Local Git, 그리고 Azure Repos와 같은 다양한 플랫폼과의 연속적 배포를 통합할 수 있습니다.\n\n\n\n깃허브 액션을 사용하여 Azure로 배포하는 두 가지 방법이 있습니다. 이 방법 중 하나는 앱 서비스 배포 센터를 사용하는 것입니다. Azure는 배포 센터를 사용하는 방법에 대해 자세한 안내를 제공하고 있습니다: [링크](https://learn.microsoft.com/en-us/azure/app-service/deploy-github-actions?tabs=applevel#use-the-deployment-center)\n\n배포 센터를 사용하는 것이 빠르고 간단하긴 하지만, 처음으로 배포하는 경우에는 Azure가 워크플로 파일을 자동으로 생성하여 선택한 브랜치로 푸시하고, 이로 인해 워크플로 실행이 트리거됩니다. 처음 실행은 실패할 것입니다. 이는 워크플로 파일의 배포 경로가 루트 경로(\".\")로 설정되어 있고, GitHub 액션이 전체 소스 코드가 아닌 'dist' 폴더만을 배포하도록 시도하기 때문입니다.\n\n자동으로 생성된 파일의 다른 부분을 수정하여 워크플로에서 폐기된 액션을 사용하지 않도록 변경하고 싶을 것입니다.\n\n\n\n나는 필요하다면 배포 센터를 사용하는 대신에 나만의 워크플로 파일을 구성하는 것을 선호해요.\n\n이를 위해 프로젝트 루트 디렉토리에 .github/workflows/ 폴더를 만들고 main_'name_of_your_app'.yml로 명명된 다음의 워크플로 파일을 추가해주세요:\n\n```js\n# Azure Web Apps 배포 동작에 대한 문서: https://github.com/Azure/webapps-deploy\n# Azure를 위한 더 많은 GitHub Actions: https://github.com/Azure/actions\n\nname: Azure Web App로 Node.js 앱 빌드 및 배포 - {name_of_your_app}\n\n# 변경이 main 브랜치로 푸시될 때마다 워크플로를 실행합니다\non:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\n# 선택 사항: 여기서 환경 변수를 주입할 수 있습니다\n# 이러한 변수를 저장소 설정 - Secrets 및 변수 - Actions - 변수에 추가할 수 있어요\nenv:\n  VITE_ENV_VAR1: ${ env.VITE_ENV_VAR1 }\n  VITE_ENV_VAR2: ${ env.VITE_ENV_VAR2 }\n\n# 이 워크플로에는 빌드와 배포 두 가지 작업이 있습니다\njobs:\n # 애플리케이션을 프로덕션용으로 빌드합니다\n # 프로덕션 환경을 가능한 가깝게 구성해야 합니다. 예: 리눅스 앱에는 Ubuntu를 사용하고, 동일한 Node 버전을 사용하는 등\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Node.js 버전 설정\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18.x'\n\n      - name: 의존성 설치, 빌드 및 테스트\n        run: |\n          npm install\n          npm run build --if-present\n          npm run test --if-present\n         # 다른 스크립트가 구성되어 있다면 이곳에 추가해주세요. 예: linting, 포맷팅\n\n      - name: 배포 작업용 아티팩트 업로드\n        uses: actions/upload-artifact@v3\n        with:\n          name: node-app\n          path: dist # 배포 경로여야 합니다. 루트 경로가 아니에요\n \n # Azure로 애플리케이션 배포\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'Production'\n      url: ${ steps.deploy-to-webapp.outputs.webapp-url }\n\n    steps:\n      - name: 빌드 작업으로부터 아티팩트 다운로드\n        uses: actions/download-artifact@v3\n        with:\n          name: node-app\n\n      - name: 'Azure Web App로 배포'\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@v2\n        with:\n          app-name: {name_of_your_app}\n          slot-name: 'Production'\n          publish-profile: ${ secrets.AZUREAPPSERVICE_PUBLISHPROFILE } # 발행 프로필은 항상 Secrets에 저장되어야 합니다.\n          package: .\n```\n\n이 파일을 main 브랜치에 커밋하기 전에 Secrets와 환경 변수(있는 경우)를 구성해야 합니다. Secrets는 기본적으로 기밀 환경 변수입니다. 비밀이 생성되면 삭제하거나 덮어씌울 수 있지만 표시할 수는 없어요.\n\n\n\nAzure 게시 프로필에는 Azure 앱 서비스로 배포하는 데 필요한 기밀 정보가 포함되어 있습니다. 이는 민감한 데이터이므로 이를 비밀로 저장해야 합니다. 이후 워크플로에서 반복적으로 사용할 수 있습니다.\n\n게시 프로필을 얻기 위해 앱 서비스의 개요 페이지로 이동하고 게시 프로필 다운로드를 클릭할 수 있습니다.\n\n![게시 프로필 다운로드](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_11.png)\n\n다운로드한 파일의 내용을 복사하여 GitHub 시크릿의 값으로 다음 단계에서 사용할 수 있도록 합니다. 이제 Azure 포털을 떠나 GitHub 프로젝트 페이지로 다시 이동할 수 있습니다.\n\n\n\nSettings — Secrets and variables — Actions — secrets 에서 Secrets 및 변수를 추가할 수 있어요.\n\n![이미지1](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_12.png)\n\n![이미지2](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_13.png)\n\n그럼 다음 시크릿을 만들게요:\n\n\n\nAZUREAPPSERVICE_PUBLISHPROFILE='발행 프로필 내용'\n\n이제 모든 설정이 완료되었습니다. 워크플로 파일을 메인 브랜치에 푸시하면 GitHub의 작업 탭에서 워크플로 실행을 볼 수 있어야 합니다.\n\n워크플로가 성공적으로 실행된 경우, React 앱이 Azure에 배포된 것을 의미합니다.\n\n애플리케이션이 Windows에서 실행 중이라면, 축하합니다! 이제 https://'앱의_이름'.azurewebsites.net를 클릭하여 애플리케이션을 실행할 수 있어야 합니다.\n\n\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_14.png)\n\n## Linux를 사용하는 경우의 마지막 단계\n\nLinux를 사용하고 위의 모든 단계를 올바르게 따르셨서 Azure가 콘텐츠를 인식하지 않는 이유에 대해 궁금하실 수 있습니다:\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_15.png)\n\n\n\n이는 Linux에서 실행되는 응용 프로그램이 추가적인 시작 명령인 pm2 serve /home/site/wwwroot --no-daemon이 필요하기 때문입니다. 이를 추가하려면 Azure App Service 페이지로 이동하여 - 설정 - 구성 - 일반 설정 - 시작 명령으로 이동한 다음, pm2 serve /home/site/wwwroot --no-daemon을 붙여 넣고 저장하시면 됩니다.\n\n![이미지](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_16.png)\n\nPM2는 Linux에서 NodeJS 애플리케이션을 제공하고 관리할 수 있는 NodeJS 프로세스 관리자입니다. Azure App Service Linux의 Node.js 컨테이너에는 기본적으로 PM2가 설치되어 있으므로 기본적으로 CLI를 사용할 수 있습니다. App Service Linux에서 PM2를 사용하는 자세한 정보는 여기에서 확인할 수 있습니다: https://azureossd.github.io/2022/02/22/Using-PM2-on-App-Service-Linux/\n\n이제 https://'name_of_your_app'.azurewebsites.net으로 돌아가서 응용 프로그램이 성공적으로 제공되는 것을 확인할 수 있습니다.\n\n\n\n![image](/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_17.png)\n\n여기에 있습니다. 이제 Azure App Service에서 호스팅되는 Vite + React 애플리케이션이 있습니다. 또한 코드 변경이 메인 브랜치로 푸시될 때마다 GitHub Actions가 워크플로를 실행하여 앱을 Azure로 테스트, 빌드 및 배포합니다.\n\nGitHub의 예제 프로젝트: https://github.com/d3v-g/medium-deploy-react-app","ogImage":{"url":"/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_0.png"},"coverImage":"/assets/img/2024-05-12-HowtodeployaViteReactapptoAzureAppServiceusingCICDPipelinesGitHubActions_0.png","tag":["Tech"],"readingTime":11},{"title":"2024년 최신 React Native Expo용 보일러플레이트 라이브러리","description":"","date":"2024-05-12 19:16","slug":"2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024","content":"\n지금은 2024년입니다. 프로그래밍에서는 항상 우리가 선택할 수 있는 최신하이팅 라이브러리들이 있지만, 최신하이팅 라이브러리들이 항상 완벽하지는 않습니다.\n\n여러 해 전에 웹 개발자로써, 저는 네이티브 앱을 어떻게 시작할지 완전히 이해하지 못했습니다. 이 블로그에서는 나의 선택한 라이브러리들과 함께 새로운 React Native/Expo 앱을 어떻게 만들 것인지 보여드리겠습니다. React Native에서 새로운 개발자이며 시작점을 모르는 경우, 이 블로그가 도움이 될 것입니다.\n\n# Component Library\n\nReact Native 컴포넌트 라이브러리 중 인기 있는 것들은:\n\n- react-native-paper\n- react-native-elements\n- gluestack\n\nNpm trends: [https://npmtrends.com/native-base-vs-react-native-elements-vs-react-native-paper](https://npmtrends.com/native-base-vs-react-native-elements-vs-react-native-paper)\n\n![Image](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_0.png)\n\n이 모든 라이브러리들은 테마를 적용할 수 있고, 좋은 접근성 지원이 가능하며, 좋은 문서와 유사한 구성 요소 세트를 제공합니다.\n\n## 리액트 네이티브 엘리먼츠\n\n이 블로그를 작성하는 시점에서, 리액트 네이티브 엘리먼츠가 가장 많은 컴포넌트를 제공하고 있어요. 하지만, AirbnbRating, PricingCard 또는 SocialIcon 같은 몇몇 컴포넌트는 제 프로젝트에서 사용할 일이 없어 보여요.\n\n<img src=\"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_1.png\" />\n\n하지만, 이 라이브러리는 가장 유연한 테마 설정을 제공하는 것 같아요. 이 라이브러리를 사용하면 개발자들이 각 컴포넌트 유형에 맞게 테마를 사용자 정의할 수 있어요: https://reactnativeelements.com/docs/customizing#using-themeprovider.\n\n```js\nconst theme = createTheme({\n  components: {\n    [themeKey]: {\n      // ... props\n    },\n  },\n});\n```\n\n## react-native-paper\n\nreact-native-paper는 구글의 머티리얼 디자인을 따릅니다. 만약 머티리얼 디자인을 사용하는 웹사이트가 있다면, react-native-paper가 일관성을 제공해줍니다.\n\n<img src=\"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_2.png\" />\n\n\n## gluestack\n\ngluestack은 유틸리티 우선이에요. 이 말은 컴포넌트가 마진, marginTop, fontFamily와 같은 props를 가지고 있는 것을 의미해요. 반면에 react-native-paper와 react-native-elements는 하나의 스타일 prop만 사용해요.\n\n예를 들어, React Native에서 컴포넌트를 스타일링하기 위해 스타일 시트를 생성해야 해요:\n\n```js\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: \"#0891b2\",\n    paddingVertical: 16,\n    paddingHorizontal: 12,\n    borderRadius: 5,\n    alignSelf: \"center\",\n    width: 375,\n    maxWidth: \"100%\",\n  },\n});\n```\n\n그럼 컴포넌트에 스타일을 적용해야 해요: `View style='styles.topContainer'`.\n\n네이티브 베이스에서는 해당 컴포넌트의 속성에 간단히 추가할 수 있어요: `Box bg=\"primary.600\" py=\"4\" px=\"3\" borderRadius=\"5\" rounded=\"md\" width='375' maxWidth=\"100%\"`.\n\n## 제 의견 기반\n\n- react-native-paper\n\n새로운 프로젝트를 처음부터 시작하려는 신입 개발자라면, npm 다운로드 수가 가장 많아 커뮤니티가 크고, 웹에서 쉽게 사용할 수 있다는 이유로 react-native-paper를 선택할 것입니다.\n\n# CSS 유틸리티\n\nCSS 유틸리티 라이브러리는 flex, pt-4, text-center, rotate-90과 같은 미리 정의된 CSS 클래스 목록을 제공합니다.\n\n위에서 언급된 native-base는 유틸리티 중심 스타일링에 대해 언급되었습니다; 그러나 React Native용 tailwind나 tachyons와 유사한 CSS 유틸리티 라이브러리가 있을까요? 네, 있습니다.\n\n나 이전에 사용한 라이브러리들은:\n\n- Native Wind\n- react-native-style-tachyons\n\nNpm trends: [https://npmtrends.com/nativewind-vs-react-native-style-tachyons](https://npmtrends.com/nativewind-vs-react-native-style-tachyons)\n\n![이미지](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_3.png)\n\n## 내 주관적인 선택\n\n- 소규모 프로젝트: 내장 스타일링, 라이브러리 사용하지 않음\n- 대규모 프로젝트: Native Wind\n\n소규모 프로젝트의 경우 내장 스타일링이 충분할 것입니다. 대규모 프로젝트의 경우, 팀원들이 이미 Tailwind에 익숙하다면 Native Wind를 선택할 것입니다. 저는 이미 Tailwind 라이브러리에 익숙하며, 네이티브 프로젝트에 이 라이브러리를 사용하기 시작하는 것이 꽤 쉬웠습니다.\n\n# 네비게이션\n\n인기 있는 선택지는 다음과 같습니다:\n\n- react-router-native\n- @react-navigation/native\n- expo-router (Expo 전용)\n\nNpm trends: https://npmtrends.com/@react-navigation/native-vs-expo-router-vs-react-router-native\n\n![이미지](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_4.png)\n\n엑스포 전용 라이브러리로 expo-router가 있습니다. 이는 파일 기반 라우팅 규칙으로, Next.js를 떠올리게 합니다.\n\nReact 웹 개발자이면 아마 react-router에 익숙할 것입니다. 이의 네이티브 버전인 react-router-native도 있지만, 널리 사용되지는 않습니다.\n\n## 제 개인적인 선택\n\n- @react-navigation/native\n\n이 라이브러리는 이제 React-Native 네비게이션을 위한 주요 라이브러리로 거의 사용되고 있어요.\n\n# 상태 관리\n\n상태 관리를 위해 선택할 수 있는 라이브러리가 더 많이 있거나 라이브러리를 전혀 사용하지 않을 수도 있어요. 인기 있는 라이브러리는 다음과 같아요:\n\n- Redux\n- TanStack Query (또는 React Query로 더 잘 알려져 있어요)\n- Redux Toolkit Query (또는 RTK Query로 더 잘 알려져 있어요)\n- React Context (내장되어 있어 라이브러리가 필요하지 않아요)\n- MobX\n- Jotai\n- Recoil\n- XState\n\nNpm trends: https://npmtrends.com/@tanstack/react-query-vs-@xstate/react-vs-jotai-vs-mobx-vs-react-redux-vs-recoil\n\n![Screenshot](/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_5.png)\n\n## 내 주관적인 선택\n\n- 친숙한 올드 Redux + TansSack Query\n\n이 두 개는 가장 인기 있는 것들 중 하나이고 많은 해 동안 사용되었습니다. 그것들은 방탄이며 개발자 커뮤니티도 넓게 보유하고 있어요.\n\nRedux와 Transack Query를 사용한 상태 관리하는 방법에 대한 나의 블로그 포스트를 확인해보세요:\n\n# Monorepo\n\n모노레포란 무엇인가요?\n\n여러 개의 React Native 앱이 필요하거나 웹 및 네이티브 앱 간에 공통 로직을 공유해야 한다면, 모노 저장소는 좋은 도구가 될 것입니다.\n\n이는 인기 있는 선택지들 중 하나로, 여기에는 다음이 포함됩니다:\n\n- yarn workspace\n- Lerna\n- Turborepo\n- @nx/react-native / @nxl/expo\n\n내 주관적인 의견은 @nx/react-native / @nx/expo입니다.\n\n내용을 표 기호(Markdown format)로 변경하면 아래와 같습니다.\n\nFor yarn workspace and Lerna, developers need to do their configuration and setup. Turborepo provides a starter app; however, it is locked to the Expo and Next.js tech stack; if developers want to use a different tech stack, they still need to do their configuration.\n\nFor new developers, @x/react-native and @nx/expo provide a good developer experience and documentation to start; nevertheless, it still gives developers flexibility on the tech stack. To start, run this command:\n\n\n# react-native\nnpx create-nx-workspace --preset=react-native\n\n# expo\nnpx create-nx-workspace --preset=expo\n\n\n# Summary\n\n새로운 React Native / Expo 앱을 만들 때 선택할 수 있는 라이브러리 목록입니다. 이 리스트는 유일한 선택지는 아닙니다.\n\n아름다운 React Native 앱을 만들어 봅시다.\n\n- 공식 @nx/expo 플러그인: https://nx.dev/packages/expo\n- 공식 @nx/react-native 플러그인: https://nx.dev/packages/react-native\n\n# 더 알아보기\n\n- 🧠 Nx 문서\n- 👩‍💻 Nx GitHub\n- 💬 Nx 커뮤니티 Slack\n- 📹 Nx 유튜브 채널\n- 🥚 무료 Egghead 강좌\n- 🚀 CI를 빠르게 실행\n","ogImage":{"url":"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_0.png"},"coverImage":"/assets/img/2024-05-12-BoilerplatesLibrariesforReactNativeExpo2024_0.png","tag":["Tech"],"readingTime":6}],"page":"145","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":17,"currentPageGroup":7},"__N_SSG":true}