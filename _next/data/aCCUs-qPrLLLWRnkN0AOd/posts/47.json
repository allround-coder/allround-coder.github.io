{"pageProps":{"posts":[{"title":"Apple처럼 애니메이션 설정하기 웹 인터페이스용 복잡한 애니메이션을 코딩하는 React와 Framer-Motion 사용하기","description":"","date":"2024-06-20 02:27","slug":"2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces","content":"\n\n\n![Link](https://miro.medium.com/v2/resize:fit:1200/1*VEU7TCQhdrDbzHhlzGHBPg.gif)\n\nThis article is a continuation of Animating Like Apple: Using Figma and Jitter to Design Complex Animations for Web Interfaces. We will explore how to utilize the useAnimate function from Framer Motion to execute complex animations, specifically focusing on the sequential and simultaneous animation of multiple elements and SVGs.\n\n![Link](https://miro.medium.com/v2/resize:fit:1400/1*0Ztl6bGF41txECfcoY9vvw.gif)\n\n# Prerequisites\n\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 다음 사항을 확인해주세요:\n\n- React 프로젝트가 설정되어 있어야 합니다.\n- Tailwind 종속성이 설치되어 있어야 합니다. `npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p`\n- Framer Motion 패키지가 설치되어 있어야 합니다. `npm i framer-motion`\n\n![이미지](/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_0.png)\n\nSVG.svg\n\n<div class=\"content-ad\"></div>\n\n\n<svg width=\"244\" height=\"84\" viewBox=\"0 0 244 84\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <circle cx=\"121.5\" cy=\"40.5\" r=\"40.5\" fill=\"#0171E2\"/>\n    <circle cx=\"121.5\" cy=\"40.5\" r=\"22.5\" fill=\"#EFEFF2\"/>\n    <rect y=\"18\" width=\"244\" height=\"45\" rx=\"22.5\" fill=\"#EFEFF2\"/>\n    <g clip-path=\"url(#clip0_49_269)\">\n        <circle cx=\"121.528\" cy=\"40.4722\" r=\"16.5278\" fill=\"#0171E2\"/>\n        <path d=\"M129.083 39.5278H123.511V33.9556C123.511 33.1056 122.85 32.4444 122 32.4444C121.15 32.4444 120.583 33.1056 120.583 33.8611V39.4333H115.011C114.161 39.4333 113.5 40.0944 113.5 40.9444C113.5 41.7944 114.161 42.3611 114.917 42.3611H120.489V47.9333C120.489 48.7833 121.15 49.35 121.906 49.35C122.756 49.35 123.322 48.6889 123.322 47.9333V42.3611H128.894C129.744 42.3611 130.311 41.7 130.311 40.9444C130.5 40.1889 129.839 39.5278 129.083 39.5278Z\" fill=\"white\"/>\n    </g>\n    <defs>\n        <clipPath id=\"clip0_49_269\">\n            <rect width=\"34\" height=\"34\" fill=\"white\" transform=\"translate(105 23)\"/>\n        </clipPath>\n    </defs>\n</svg>\n\n\n<img src=\"/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_1.png\" />\n\n이 디자인은 Figma에서 만들었고 SVG로 내보냈습니다.\n\n<img src=\"/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_2.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n다음 요소들로 구성된 SVG입니다:\n\n```js\n<circle cx=\"121.5\" cy=\"40.5\" r=\"40.5\" fill=\"#0171E2\"/>\n```\n\n![image](/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_3.png)\n\n```js\n<circle cx=\"121.5\" cy=\"40.5\" r=\"22.5\" fill=\"#EFEFF2\"/>\n```\n\n<div class=\"content-ad\"></div>\n\n\n\n![Image](/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_4.png)\n\n```js\n<rect y=\"18\" width=\"244\" height=\"45\" rx=\"22.5\" fill=\"#EFEFF2\"/>\n```\n\n![Image](/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_5.png)\n\n```js\n<g clip-path=\"url(#clip0_49_269)\">\n    <circle cx=\"121.528\" cy=\"40.4722\" r=\"16.5278\" fill=\"#0171E2\"/>\n    <path d=\"M129.083 39.5278H123.511V33.9556C123.511 33.1056 122.85 32.4444 122 32.4444C121.15 32.4444 120.583 33.1056 120.583 33.8611V39.4333H115.011C114.161 39.4333 113.5 40.0944 113.5 40.9444C113.5 41.7944 114.161 42.3611 114.917 42.3611H120.489V47.9333C120.489 48.7833 121.15 49.35 121.906 49.35C122.756 49.35 123.322 48.6889 123.322 47.9333V42.3611H128.894C129.744 42.3611 130.311 41.7 130.311 40.9444C130.5 40.1889 129.839 39.5278 129.083 39.5278Z\" fill=\"white\"/>\n</g>\n``` \n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_6.png\" />\n\n이전 글에서 Jitter를 사용하여 각 요소를 따로 애니메이션했듯이, 이번에는 코드를 사용하여 동일한 작업을 할 것입니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*zDS9431MMEDiTLBOut0gzw.gif\" />\n\n# Framer Motion의 useAnimate 함수 이해하기\n\n<div class=\"content-ad\"></div>\n\nUseAnimateExample.jsx\n\n```js\nimport { useAnimate } from \"framer-motion\";\nimport React, {useState} from \"react\";\n\nconst UseAnimateExample = () => {\n    const [scope, animate] = useAnimate();\n\n    const startAnimation = async () => {\n        // Decrease the radius of the pink circle to 0\n        await animate(\"#pink-circle\", { r: 0 }, { duration: 0.5 });\n\n        // Increase the radius of the pink circle to 22.5\n        await animate(\"#pink-circle\", { r: 22.5 }, { duration: 0.5 });\n\n        // Move the pink circle horizontally to x-coordinate 400\n        await animate(\"#pink-circle\", { cx: 400 }, { duration: 0.5 });\n\n        // Move the pink circle vertically to y-coordinate 400\n        await animate(\"#pink-circle\", { cy: 400 }, { duration: 0.5 });\n\n        // Move the pink circle horizontally to x-coordinate 50\n        await animate(\"#pink-circle\", { cx: 50 }, { duration: 0.5 });\n\n        // Move the pink circle vertically to y-coordinate 250\n        await animate(\"#pink-circle\", { cy: 250 }, { duration: 0.5 });\n\n        // Move the pink circle horizontally to x-coordinate 250\n        await animate(\"#pink-circle\", { cx: 250 }, { duration: 0.5 });\n\n        // Increase the radius of the pink circle to 50\n        await animate(\"#pink-circle\", { r: 50 }, { duration: 0.5 });\n\n        // Combine one or more animations\n        // Simultaneously move the pink circle vertically and change its radius\n        const animation1 = animate(\"#pink-circle\", { cy: 200 }, { duration: 0.5 });\n        const animation2 = animate(\"#pink-circle\", { r: 40 }, { duration: 0.5 });\n        await Promise.all([animation1, animation2]); // Execute both animations at the same time\n\n        // Another set of animations after the first set completes\n        // Move the pink circle back down and increase its radius\n        const animation3 = animate(\"#pink-circle\", { cy: 250 }, { duration: 0.5 });\n        const animation4 = animate(\"#pink-circle\", { r: 50 }, { duration: 0.5 });\n\n    };\n\n\n    return (\n        <div ref={scope} className=\"h-screen bg-black flex flex-col justify-center items-center\">\n            <svg width=\"500\" height=\"500\" viewBox=\"0  0 500 500\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <circle id=\"pink-circle\" cx=\"250\" cy=\"250\" r=\"50\" fill=\"#F3B7B7\"/>\n            </svg>\n            <button onClick={startAnimation} className=\"bg-white text-black mt-12 px-4 py-2 rounded-md\">애니메이션 시작</button>\n        </div>\n    );\n};\n\nexport default UseAnimateExample;\r\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*QLr4XCq2EjNQ2TsrxSCJ7A.gif\" />\n\n이 간단한 예시는 Framer Motion의 useAnimate 함수가 어떻게 작동하는지 보여줍니다. 다음에는 이 개념을 SVG 내의 여러 요소에 적용하여 포괄적인 애니메이션을 만들어보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 1: SVG를 포함한 컴포넌트 생성\n\nAppleButton.jsx\n\n```js\nimport { useAnimate } from \"framer-motion\";\nimport React, {useState} from \"react\";\n\nconst AppleButton = () => {\n    const [scope, animate] = useAnimate();\n\n    const EntryAnimation = async () => {\n\n\n    };\n\n    const ExitAnimation = async () => {\n\n\n    };\n\n\n    return (\n        <div ref={scope} className=\"h-screen bg-black flex flex-col justify-center items-center\">\n            <svg width=\"244\" height=\"84\" viewBox=\"0 0 244 84\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <circle cx=\"121.5\" cy=\"40.5\" r=\"40.5\" fill=\"#0171E2\"/>\n                <circle cx=\"121.5\" cy=\"40.5\" r=\"22.5\" fill=\"#EFEFF2\"/>\n                <rect y=\"18\" width=\"244\" height=\"45\" rx=\"22.5\" fill=\"#EFEFF2\"/>\n                <g clip-path=\"url(#clip0_49_269)\">\n                    <circle cx=\"121.528\" cy=\"40.4722\" r=\"16.5278\" fill=\"#0171E2\"/>\n                    <path d=\"M129.083 39.5278H123.511V33.9556C123.511 33.1056 122.85 32.4444 122 32.4444C121.15 32.4444 120.583 33.1056 120.583 33.8611V39.4333H115.011C114.161 39.4333 113.5 40.0944 113.5 40.9444C113.5 41.7944 114.161 42.3611 114.917 42.3611H120.489V47.9333C120.489 48.7833 121.15 49.35 121.906 49.35C122.756 49.35 123.322 48.6889 123.322 47.9333V42.3611H128.894C129.744 42.3611 130.311 41.7 130.311 40.9444C130.5 40.1889 129.839 39.5278 129.083 39.5278Z\" fill=\"white\"/>\n                </g>\n            </svg>\n\n            <button onClick={EntryAnimation} className=\"bg-white text-black mt-12 px-4 py-2 rounded-md\">입장</button>\n            <button onClick={ExitAnimation} className=\"bg-white text-black mt-4 px-4 py-2 rounded-md\">나가기</button>\n\n        </div>\n    );\n};\n\nexport default AppleButton;\n```\n\n<img src=\"/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_7.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: 각 SVG 요소에 ID 할당하기.\n\n```js\n<svg width=\"244\" height=\"84\" viewBox=\"0 0 244 84\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <circle id=\"blue-circle\" cx=\"121.5\" cy=\"40.5\" r=\"40.5\" fill=\"#0171E2\"/>\n    <circle id=\"gray-circle\" cx=\"121.5\" cy=\"40.5\" r=\"22.5\" fill=\"#EFEFF2\"/>\n    <rect id=\"expanded-gray-circle\" y=\"18\" width=\"244\" height=\"45\" rx=\"22.5\" fill=\"#EFEFF2\"/>\n    <g clip-path=\"url(#clip0_49_269)\">\n        <circle id=\"blue-inner-circle\" cx=\"121.528\" cy=\"40.4722\" r=\"16.5278\" fill=\"#0171E2\"/>\n        <path id=\"plus-sign\" d=\"M129.083 39.5278H123.511V33.9556C123.511 33.1056 122.85 32.4444 122 32.4444C121.15 32.4444 120.583 33.1056 120.583 33.8611V39.4333H115.011C114.161 39.4333 113.5 40.0944 113.5 40.9444C113.5 41.7944 114.161 42.3611 114.917 42.3611H120.489V47.9333C120.489 48.7833 121.15 49.35 121.906 49.35C122.756 49.35 123.322 48.6889 123.322 47.9333V42.3611H128.894C129.744 42.3611 130.311 41.7 130.311 40.9444C130.5 40.1889 129.839 39.5278 129.083 39.5278Z\" fill=\"white\"/>\n    </g>\n</svg>\n```\n\n# 단계 3: useAnimate를 사용하여 애니메이션 코딩 시작하기\n\n초기 상태에서 SVG가 보이지 않도록 하려면 불투명도 및 크기가 0으로 설정되어야 하므로 해당 속성을 조정하여 초깃값에서 애니메이션이 작동되도록 해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n또한, 우리는 각 애니메이션 세그먼트의 정확한 지속 시간을 결정하기 위해 Jitter 파일을 참조할 수 있습니다.\n\n사각형 SVG의 x 좌표를 이동하는 등의 일부 애니메이션은 useAnimate로 직접 수행할 수 없습니다. 이러한 작업에 대해서는 React의 인라인 스타일링을 활용하여 애니메이션을 적용할 것입니다.\n\nAppleButton.jsx\n\n```js\nimport { useAnimate } from \"framer-motion\";\nimport React, {useState} from \"react\";\n\nconst AppleButton = () => {\n    const [scope, animate] = useAnimate();\n\n    const [expandedStyle, setExpandedStyle] = useState({width: '45px', x: '99.5', transition: 'all 0.5s cubic-bezier(0.5, 1.25, 0.3, 1)', fill: '#EFEFF2', opacity: 0});\n    const [gTransform, setGTransform] = useState('');\n    const [textPosition, setTextPosition] = useState({ x: 109.5, y: 41.5 });\n    const textContent = \"Go deeper on design\";\n\n\n    const EntryAnimation = async () => {\n        const animation1 = animate(\"#blue-circle\", { r: 40.5, opacity: 1 }, { duration: 0.5 });\n        const animation2 = animate(\"#gray-circle\", { r: 22.5, opacity: 1 }, { duration: 0.5 });\n        await Promise.all([animation1, animation2]);\n        await animate(\"#blue-circle\", { r: 22.5, opacity: 1, cy: 40.5 }, { delay: 0.1, duration: 0.25, ease: \"easeOut\" });\n        const animation3 = animate(\"#blue-inner-circle\", { r: \"16.5278\", opacity: 1, cy: \"40.4722\" }, { duration: 0.25, ease: \"easeOut\" });\n        const animation4 = animate(\"#plus-sign\", { opacity: 1 }, { duration: 0.25, ease: \"easeOut\" });\n        await Promise.all([animation3, animation4]);\n        setExpandedStyle({width: '244px', x: '0', transition: 'all 0.5s cubic-bezier(0.5, 1.25, 0.3, 1)', fill: '#EFEFF2', opacity: 1});\n        setGTransform('translateX(100px)');\n        await animate(\"#text\", { opacity: 1 }, { duration: 0.5});\n    };\n\n\n    const ExitAnimation = async () => {\n        const animation5 = animate(\"#plus-sign\", { opacity: 0}, { duration: 0.25});\n        const animation6 = animate(\"#blue-inner-circle\", { r: 0, cy: 40.5 }, {duration: 0.25, delay:0.1});\n        const animation7 = animate(\"#text\", { opacity:0 }, { duration: 0.2 });\n        const animation8 = animate(\"#blue-circle\", { r: 0, opacity: 0, cy: 40.5 }, {});\n        await Promise.all([animation5, animation6, animation7, animation8]);\n        setExpandedStyle({width: '45px', x: '99.5', transition: '0.5s', fill: '#EFEFF2',});\n        const animation9 = animate(\"#gray-circle\", { r: 0, opacity: 1 }, {delay: 0.5, duration: 0.25, ease: \"easeOut\"});\n        setGTransform('translateX(0px)');\n        const animation10 = animate(\"#expanded-gray-circle\", { opacity: 0,}, {delay: 0.5});\n        await Promise.all([animation9, animation10]);\n    };\n\n\n    return (\n        <div ref={scope} className=\"h-screen bg-black flex flex-col justify-center items-center\">\n            <svg width=\"244\" height=\"84\" viewBox=\"0 0 244 84\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <circle id=\"blue-circle\" cx=\"121.5\" cy=\"40.5\" r=\"0\" fill=\"#0171E2\"/>\n                <circle id=\"gray-circle\" cx=\"121.5\" cy=\"40.5\" r=\"0\" fill=\"#EFEFF2\"/>\n                <rect id=\"expanded-gray-circle\" x={expandedStyle.x} y=\"18\" width={expandedStyle.width} height=\"45\"\n                      rx=\"22.5\" style={expandedStyle}/>\n                <text id=\"text\" x={textPosition.x} y={textPosition.y} fill=\"black\" textAnchor=\"middle\"\n                      alignmentBaseline=\"middle\" fontWeight=\"600\" opacity=\"0\">\n                    {textContent}\n                </text>\n                <g style={transform: gTransform, transition: 'transform 0.5s cubic-bezier(0.5, 1.25, 0.3, 1)'}> clip-path=\"url(#clip0_49_269)\">\n                    <circle id=\"blue-inner-circle\" cx=\"121.528\" cy=\"40.4722\" r=\"0\" fill=\"#0171E2\" opacity=\"0\"/>\n                    <path id=\"plus-sign\" d=\"M129.083 39.5278H123.511V33.9556C123.511 33.1056 122.85 32.4444 122 32.4444C121.15 32.4444 120.583 33.1056 120.583 33.8611V39.4333H115.011C114.161 39.4333 113.5 40.0944 113.5 40.9444C113.5 41.7944 114.161 42.3611 114.917 42.3611H120.489V47.9333C120.489 48.7833 121.15 49.35 121.906 49.35C122.756 49.35 123.322 48.6889 123.322 47.9333V42.3611H128.894C129.744 42.3611 130.311 41.7 130.311 40.9444C130.5 40.1889 129.839 39.5278 129.083 39.5278Z\"\n                          fill=\"white\" opacity=\"0\"/>\n                </g>\n            </svg>\n\n            <button onClick={EntryAnimation} className=\"bg-white text-black mt-12 px-4 py-2 rounded-md\">Entry</button>\n            <button onClick={ExitAnimation} className=\"bg-white text-black mt-4 px-4 py-2 rounded-md\">Exit</button>\n\n        </div>\n    );\n};\n\nexport default AppleButton;\r\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Animated Button](https://miro.medium.com/v2/resize:fit:1400/1*eNwg7lM93XU13vBp9aGt1w.gif)\n\n# 결론\n\n그럼 이제 해냈습니다! 이제 이 애니메이션 버튼을 웹사이트에 통합할 수 있습니다. 더 많은 효과를 주고 싶다면, 스크롤-보기 효과로 더욱 향상시킬 수 있습니다. 버튼이 보이게 될 때 Entry Animation을 시작하도록 스크롤 이벤트를 링크하고, 버튼이 뷰를 벗어날 때 Exit Animation을 시작하도록 설정하세요.\n\n이 프로젝트의 완성된 코드를 다운로드하려면 꼭 제 GitHub를 방문해주세요.\n","ogImage":{"url":"/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_0.png"},"coverImage":"/assets/img/2024-06-20-AnimatingLikeAppleUsingReactandFramer-MotiontoCodeComplexAnimationsforWebInterfaces_0.png","tag":["Tech"],"readingTime":15},{"title":"사용자 피드백이 없다면, 그냥 또 다른 개발자에 불과합니다","description":"","date":"2024-06-20 02:25","slug":"2024-06-20-Withoutuserfeedbackyourejustanotherdeveloper","content":"\n\n이 기사는 원래 내 블로그에 게시되었습니다.\n\n나는 항상 웹 사이트를 구축할 때 사용자로부터 직접 듣는 것이 게임을 변화시킨다고 믿어왔어요. 그것은 정확히 어디로 가야 하는지와 무엇을 고쳐야 하는지를 알려주는 안내자가 있는 것과 같아요. 그래서 사용자 피드백이 특히 프론트엔드에서 매우 중요한 이유입니다. 사용자들의 시각으로 우리의 작업을 볼 수 있게 도와줍니다.\n\n이 기사에서는 사용자 피드백을 듣는 것이 내 프로젝트를 구축하는 방식을 변경하여 보다 효과적이고 사용자 친화적으로 만드는 방법에 대해 공유하겠습니다. 왜 이 피드백이 중요한지와 여러분 자신의 웹 애플리케이션을 개선하는 데 이를 활용하는 방법을 살펴보겠습니다.\n\n# 왜 사용자 피드백이 중요한가요?\n\n<div class=\"content-ad\"></div>\n\n첫 번째 사용자 피드백은 웹사이트에 대해 사용자가 제공하는 모든 의겏, 제안, 의견입니다. 이것은 버튼을 찾기 어려워한다거나 사용자 경험을 더 좋게 만들기 위한 새로운 기능을 제안하는 등 다양할 수 있습니다.\n\n여기에 사용자 피드백이 굉장히 중요한 이유가 있습니다:\n\n- 사용자 피드백은 사용성을 향상시키는 데 도움이 됩니다. 때로는 개발자로서 감각적으로 느껴지는 것이 실제로 제품을 사용하는 사람들에게는 잘 작동하지 않을 수 있습니다. 피드백을 통해 이러한 문제를 발견하고 해결할 수 있습니다. 또한 테스트를 해도 놓칠 수 있는 버그를 잡아 수정할 수도 있습니다.\n\n- 또한 사용자의 요구 사항을 더 잘 이해하게 됩니다. 이것은 중요한데, 이를 통해 응용 프로그램을 효과적으로 구축하기 위한 가이드가 되기 때문입니다. 종종 사용자는 고려하지 못했던 새로운 기능이나 개선 아이디어를 제안하기도 합니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-Withoutuserfeedbackyourejustanotherdeveloper_0.png)\n\n# 사용자 피드백을 수집하는 방법\n\n위에서 사용자 피드백이 얼마나 중요한지 설명했으니, 이제는 어떻게 수집할지 살펴봅시다.\n\n먼저 설문 조사부터 시작하세요. 사용자가 앱을 상호 작용한 후 간단한 설문 조사를 보내세요. 이것은 사용자가 앱에서 작업을 완료한 후 또는 후속 이메일을 통해 즉시 수행할 수 있습니다. 설문 조사는 사용자 경험을 포괄적으로 이해하고 일반적인 동향이나 문제를 식별하는 데 극히 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n피드백 양식을 구현하세요. 앱과 웹사이트에서 모두 피드백 양식을 제공하세요. 이렇게 하면 사용자들이 자신의 생각을 표현할 수 있는 편리한 방법을 얻게 됩니다. 이는 지속적인 피드백을 수집하는 데 도움이 되는데 더불어 사용자들이 당신의 개발 프로세스에 더 깊이 참여할 수 있도록 도와줍니다.\n\n사용자 테스트 세션을 진행하세요. 사용자들을 초대하여 특정 기능을 테스트하도록 하고 그들의 앱 내 행동을 관찰하세요. 이 방법을 통해 그들이 앱을 어떻게 이용하는지 직접 볼 수 있으며, 다른 형태의 피드백으로는 명확하지 않은 사용성 문제에 대한 통찰을 얻을 수 있습니다.\n\n가능하다면 사용자를 그림자로 따라가보세요. 직접적으로 또는 비디오 통화를 통해 사용자들이 자연스러운 환경에서 앱을 이용하는 모습을 관찰하는 것은 귀중한 통찰을 제공할 수 있습니다. 이 방법을 통해 그들이 실제 상황에서 앱을 사용하는 것을 관찰할 수 있습니다. 경험에 대한 즉각적인 피드백을 받으며 질문을 하여 그들의 경험에 대해 더 많은 이해를 할 수 있습니다.\n\n도움이 될 수 있는 일부 도구: Google Forms, Typeform, usertesting.com\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-Withoutuserfeedbackyourejustanotherdeveloper_1.png\" />\n\n# 피드백을 개발에 통합하는 방법\n\n피드백 분석하기 먼저, 모든 사용자 의견을 살펴서 어떤 문제가 자주 발생하는지 확인합니다. 사용자가 무엇을 말하는지 추적하기 위해 스프레드시트를 사용합니다. 이를 통해 앱의 어느 부분이 개선이 필요한지 파악할 수 있습니다.\n\n변경 사항 우선순위 정하기 모든 것을 동시에 해결할 수는 없으므로 문제의 심각성과 빠른 해결이 필요한 정도에 기반하여 먼저 어떤 부분을 수정할지 결정합니다. 제품 매니저 또는 디자이너와 협의하여 먼저 무엇을 해야 하는지 합의합니다.\n\n<div class=\"content-ad\"></div>\n\n변경 사항 적용하기 그런 다음, 변경 사항을 적용하게 됩니다. 일부 수정 사항은 빠르게 처리되지만, 다른 사항은 시간이 걸릴 수도 있습니다. 항상 사용자들이 말해준 내용을 기반으로 앱을 개선하려고 노력합니다.\n\n이렇게 하면 사용자들의 의견을 진심으로 듣고 그들을 위해 앱을 개선하고 있다는 것을 확신할 수 있습니다.\n\n# 사용자 피드백 사용 시 발생하는 도전 과제\n\n다음은 직면한 일부 도전 과제와 그에 대한 대처 방법입니다:\n\n<div class=\"content-ad\"></div>\n\n충돌하는 피드백 때로는 한 사용자가 무엇을 좋아한다고 말하고, 다른 사람이 싫어한다고 말합니다. 이럴 때는 더 많은 피드백을 찾아서 어떤 의견이 더 일반적인지 확인합니다. 또한 이러한 변경 사항이 앱의 전체 디자인과 목표와 어떻게 조화를 이룰지 확인합니다.\n\n비현실적인 기대 사용자들은 때로는 현재 설정이나 예산으로는 실현 불가능한 기능을 요청합니다. 그럴 때는 왜 지금은 특정 사항들을 처리할 수 없는지 설명하고 대안적인 해결책을 제안하는 데 집중합니다. 사용자들에게 우리가 할 수 있는 일에 대해 정직하고 명확하게 전달하는 것이 중요합니다.\n\n이러한 도전에 대처하기 위해 의사 소통이 중요합니다. 팀과 함께 상의해서 어떻게 나아갈지 결정하도록 합니다. 특히 요청을 수용할 수 없는 경우에는 사용자들과 소통을 유지하도록 합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n웹사이트나 앱을 개발할 때 사용자 피드백을 활용하는 것은 매우 중요해요. 사용자의 시각에서 우리의 작업을 볼 수 있게 도와주죠. 이 피드백은 문제를 해결하고 사용자가 원하는 새로운 기능을 추가하는 데 도움이 돼요.\n\n사용자의 피드백을 받는 것뿐만 아니라, 정말로 듣고 사용자의 의견을 바탕으로 변경하는 것이 중요해요. 설문 조사를 통해서든 사용자들과 직접 대화를 나누든, 모든 피드백은 프로젝트를 더 나아지게 만들 수 있어요.\n\n사용자가 좋아하고 싫어하는 점에 주목하면, 사용자를 만족시키고 도움이 되는 앱과 웹사이트를 만들 수 있어요. 계속해서 사용자 피드백을 듣고 개선해 나가요. 함께 사용자의 피드백에 기반해 발전하는 것을 지속합시다.","ogImage":{"url":"/assets/img/2024-06-20-Withoutuserfeedbackyourejustanotherdeveloper_0.png"},"coverImage":"/assets/img/2024-06-20-Withoutuserfeedbackyourejustanotherdeveloper_0.png","tag":["Tech"],"readingTime":4},{"title":"2024년을 맞아 Flutter와 React Native 비교","description":"","date":"2024-06-20 02:24","slug":"2024-06-20-FluttervsReactNativein2024","content":"\n\n소개:\n크로스 플랫폼 모바일 앱 개발 분야에서, Flutter와 React Native는 두 가지 주요 시스템으로 두드러집니다. 각각은 흥미로운 기능과 장점을 제공하여 디자이너와 비즈니스의 요구를 충족시킵니다. 우리는 당신이 올바른 시스템을 선택하는 데 도움을 드리기 위해 한 가지씩 비교해 보겠습니다.\n\nFlutter:\n\nFlutter는 구글에서 만든 오픈 소스 UI 소프트웨어 개발 툴킷입니다. Flutter는 단일 코드베이스로 모바일, 웹 및 데스크톱용으로 네이티브 컴파일된 애플리케이션을 구축하는 데 사용됩니다. Flutter는 Dart 프로그래밍 언어를 활용하며 다양한 커스터마이즈 가능한 UI 구성 요소를 제공하여 개발자가 서로 다른 플랫폼에서 시각적으로 매력적이고 뛰어난 성능의 애플리케이션을 만들 수 있도록 도와줍니다.\n\nReact Native:\n\n<div class=\"content-ad\"></div>\n\n리액트 네이티브(React Native)는 페이스북에서 개발한 오픈 소스 프레임워크로, JavaScript와 React를 사용하여 모바일 애플리케이션을 구축하는 데 사용됩니다. 개발자들이 코드를 한 번 작성하고 iOS 및 Android와 같은 여러 플랫폼에 배포할 수 있느데, 동시에 네이티브와 유사한 사용자 경험을 제공합니다. 리액트 네이티브를 사용하면 익숙한 웹 개발 기술을 활용하여 모바일 앱을 만들 수 있어서, 크로스 플랫폼 개발에 많이 선택되는 프레임워크입니다.\n\n성능과 속도:\n\n![Flutter vs React Native](/assets/img/2024-06-20-FluttervsReactNativein2024_0.png)\n\n플러터(Flutter):\n다트(Dart) 언어와 렌더링 엔진을 활용하여, 플러터는 높은 성능과 빠른 실행 속도를 자랑합니다. \"핫 리로드\" 기능을 통해 개발자들은 변경 사항을 즉시 확인할 수 있어 생산성을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nReact Native:\nReact Native은 JavaScript를 사용하지만 네이티브 구성 요소를 활용하여 효율적인 성능을 제공합니다. 그러나 가끔씩 발생하는 브릿지 통신은 성능 병목 현상을 일으킬 수 있습니다.\n\n개발 환경:\n\nFlutter:\nFlutter는 Dart SDK 및 Flutter CLI를 포함한 자체 도구 세트로 간소화된 개발 환경을 제공합니다. 일관된 생태계로 설치와 유지 관리를 간편하게 만듭니다.\n\nReact Native:\nReact Native은 Expo와 React Native CLI와 같은 인기 있는 개발 도구와 원활하게 통합됩니다. 그러나 종속성 관리와 버전 호환성은 도전적일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nUI 구성 요소:\n\nFlutter:\n위젯 기반 아키텍처로, Flutter는 일관된 모양과 느낌을 제공하는 맞춤형 UI 구성 요소 라이브러리를 제공합니다.\n\nReact Native:\nReact Native은 네이티브 UI 구성 요소를 활용하여, 플랫폼 UI와 원활하게 통합되어 네이티브와 유사한 사용자 경험을 제공합니다.\n\n커뮤니티 및 생태계:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-FluttervsReactNativein2024_1.png\" />\n\nFlutter:\n리액트 네이티브에 비해 비교적 새로운 플러터는 구글의 후원을 받아 빠르게 성장하는 커뮤니티를 가지고 있습니다. 다양한 기능을 제공하는 패키지로 이루어진 확장 생태계를 갖고 있습니다.\n\nReact Native:\n페이스북의 후원을 받고 있는 리액트 네이티브는 방대한 커뮤니티와 다양한 요구 사항에 대한 솔루션을 제공하는 라이브러리와 플러그인의 확장 생태계를 자랑합니다.\n\n학습 곡선:\n\n<div class=\"content-ad\"></div>\n\n플러터:\n선언형 UI와 싱글 언어인 다트를 사용하여, 플러터는 객체 지향 프로그래밍에 익숙한 개발자들에게 특히 부드러운 학습 곡선을 제공합니다.\n\n리액트 네이티브:\nJavaScript에 능통한 개발자들은 리액트 네이티브의 학습 곡선이 더 부드럽다고 느낍니다. 그러나 플랫폼별 모듈 및 네이티브 코드 통합을 마스터하는 데 추가적인 노력이 필요할 수 있습니다.\n\n결론:\n플러터와 리액트 네이티브는 크로스 플랫폼 모바일 앱 개발에 강력한 솔루션을 제공합니다. 성능 요구 사항, 프로그래밍 언어에 대한 익숙함 및 프로젝트 세부 사항과 같은 요인을 고려하여 선택할 수 있습니다. 귀하의 개발 목표와 목적에 부합하는, 정보를 기반으로 한 결정을 내리기 위해 신중하게 요구 사항을 검토하십시오.","ogImage":{"url":"/assets/img/2024-06-20-FluttervsReactNativein2024_0.png"},"coverImage":"/assets/img/2024-06-20-FluttervsReactNativein2024_0.png","tag":["Tech"],"readingTime":3},{"title":"React 앱을 Azure Webapp에 배포하는 방법 다단계 Azure YAML 파이프라인 사용하기","description":"","date":"2024-06-20 02:22","slug":"2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline","content":"\n\n이 글에서는 Azure YAML Pipeline을 사용하여 React 앱을 Azure Webapp에 배포하는 배포 프로세스를 안내하겠습니다.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_0.png)\n\n# 웹 앱 생성하기\n\n- Azure 포털에 로그인하고 자격 증명으로 이동하세요: https://portal.azure.com/#home\n- 검색 창에서 App Services를 찾아 서비스 아래에서 해당 옵션을 선택합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_1.png)\n\n3. 클릭하여 Web App 옵션을 선택하고 새 웹 앱을 만듭니다. 아래와 같이 요구 사항에 맞게 웹 앱을 구성하세요.\n\n이름: 웹 앱의 이름 (참고:이 이름은 Azure 전체에서 고유해야합니다.)\n런타임 스택: 노드\n운영 체제: 리눅스\n가격 책정: 요구 사항에 가장 적합한 계획을 선택하세요.\n\n![image](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image 3](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_3.png)\n\n![Image 4](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_4.png)\n\n![Image 5](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_5.png)\n\n![Image 6](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n4. '만들기' 버튼을 클릭한 후에는 새 웹 앱 생성 프로세스가 시작됩니다.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_7.png)\n\n5. 웹 앱이 성공적으로 생성된 후에 '리소스로 이동' 버튼을 클릭하세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_8.png)\n\n<div class=\"content-ad\"></div>\n\n6. 빈 템플릿 페이지가 표시됩니다.\n\n![템플릿 페이지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_9.png)\n\n![템플릿 페이지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_10.png)\n\n# 서비스 연결 생성\n\n<div class=\"content-ad\"></div>\n\n7. 웹 앱이 생성되었으니, Azure YAML 파이프라인을 사용하여 React 앱을 웹 앱에 배포하는 데 집중해 봅시다.\n\n8. https://dev.azure.com/ 로 이동하여 자격 증명으로 로그인하세요.\n\n9. 아래 이미지에서와 같이 조직 및 프로젝트를 선택하세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_11.png)\n\n<div class=\"content-ad\"></div>\n\n10. Azure의 리소스와 통신하기 위해 파이프라인에 서비스 연결을 생성하려면 프로젝트 설정을 클릭해주세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_12.png)\n\n11. 서비스 연결을 만들기 위해 서비스 연결 - `새 서비스 연결`을 클릭해주세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_13.png)\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_14.png)\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_15.png)\n\n12. 원하는 서비스 연결을 만들 Subskription을 드롭다운에서 선택하고 이름을 지정하세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_16.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmultistageAzureYAMLPipeline_17.png\" />\n\n# YAML 파이프라인 생성\n\n14. 프로젝트 폴더 루트에 React 소스 코드를 포함하는 azure-pipelines.yml이라는 새 YAML 파일을 만듭니다.\n\n아래 변수의 값을 해당 값으로 대체합니다.\nazureSubscription: your_service_connection_name (이미지 #12에 표시된 서비스 연결 이름)\nwebAppName: your_webapp_name (이미지 #3에 표시된 Web App 이름)\n\n<div class=\"content-ad\"></div>\n\n아래 파이프라인에서 deploy 단계 환경인 dev는 dev 환경으로 코드를 배포하기 위한 승인을 받기 위해 사용됩니다. 비슷하게, 추가 단계를 추가하여 test 및 prod 환경으로 배포할 수 있습니다.\n\n```js\ntrigger:\n  - dev\n\npool:\n  vmImage: ubuntu-latest\n\nvariables:\n  azureSubscription: \"azure-pipelines-azure-sc\"\n  webAppName: demo-react-linux-webapp\n\nstages:\n  - stage: build\n    displayName: build\n    jobs:\n      - job: \"build\"\n        displayName: build job\n        steps:\n          - task: NodeTool@0\n            inputs:\n               versionSource: \"spec\"\n               versionSpec: \"20.x\"\n\n          - script: |\n               npm install\n               npm run build --if-present\n            displayName: \"npm install, build\"\n\n          - task: ArchiveFiles@2\n            inputs:\n               rootFolderOrFile: \"$(System.DefaultWorkingDirectory)/build\"\n               includeRootFolder: false\n               archiveType: \"zip\"\n               archiveFile: \"$(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip\"\n               replaceExistingArchive: true\n            \n          - task: PublishBuildArtifacts@1\n            inputs:\n               PathtoPublish: \"$(Build.ArtifactStagingDirectory)\"\n               ArtifactName: \"drop\"\n               publishLocation: \"Container\"\n\n  - stage: deploy\n    displayName: \"Deploy to the dev environment\"\n    dependsOn: Build\n    condition: succeeded()\n    jobs:\n      - deployment: Deploy\n        environment: dev\n        strategy:\n           runOnce:\n             deploy:\n               steps:\n                 - task: AzureRmWebAppDeployment@4\n                   inputs:\n                      ConnectionType: \"AzureRM\"\n                      azureSubscription: \"$(azureSubscription)\"\n                      appType: \"webAppLinux\"\n                      WebAppName: \"$(webAppName)\"\n                      packageForLinux: \"$(Pipeline.Workspace)/drop/$(Build.BuildId).zip\"\n                      #아래 StartupCommand는 리눅스 환경에서 React 앱을 실행하는 데 필요합니다.\n                      StartupCommand: \"pm2 serve /home/site/wwwroot/ --no-daemon --spa\"\n```\n\n<img src=\"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_18.png\" />\n\n15. Azure DevOps의 Repo에 코드를 게시하세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_19.png\" />\n\n16. DevOps 포털로 이동하여 파이프라인을 클릭하고, \"파이프라인 - 새 파이프라인\"을 선택하여 새 파이프라인을 생성하세요.\n\n<img src=\"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_20.png\" />\n\n17. 코드가 포함된 Azure YAML 파이프라인이 있는 리포지토리를 찾아보세요.\n\n<div class=\"content-ad\"></div>\n\n\n![Table 1](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_21.png)\n\n![Table 2](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_22.png)\n\n![Table 3](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_23.png)\n\n# 환경 변수 구성\n\n\n<div class=\"content-ad\"></div>\n\n18. 우리는 App.js 파일의 React 코드에서 REACT_APP_ENVIRONMENT라는 환경 변수를 사용하고 있습니다. 따라서 파이프라인에도 환경 변수를 생성해 봅시다.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_24.png)\n\n19. Variables - 새 변수를 클릭해주세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_25.png)\n\n<div class=\"content-ad\"></div>\n\n\n![image 1](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_26.png)\n\n![image 2](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_27.png)\n\n![image 3](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_28.png)\n\n20. If you have multiple environment variables to configure, repeat Step #19.\n\n\n<div class=\"content-ad\"></div>\n\n21. 파이프라인을 실행하려면 실행 옵션을 클릭하세요.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_29.png)\n\n22. 빌드 단계가 진행 중입니다.\n\n![이미지](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_30.png)\n\n<div class=\"content-ad\"></div>\n\n23. 빌드 프로세스가 완료되면 배포 단계로 이동합니다. \"View\" 버튼을 클릭하여 배포를 승인하세요.\n\n![이미지1](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_31.png)\n\n![이미지2](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_32.png)\n\n![이미지3](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_33.png)\n\n<div class=\"content-ad\"></div>\n\n\n![Deployment successful](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_34.png)\n\n24. Deployment completed successfully!!!\n\n![React App deployed](/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_35.png)\n\n24. Browse the Web App and you can see React App is deployed successfully. The environment variable value that we configured in Step #19 is displayed here.\n\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 위 문서를 읽어주셔서 감사합니다. 만약 이 레포지토리가 도움이 되었다면, 별풍선을 주시고 저를 팔로우해주세요. 앞으로도 많은 유익한 글을 공유할 예정이에요. 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_0.png"},"coverImage":"/assets/img/2024-06-20-DeployReactApptoAzureWebappusingmutistageAzureYAMLPipeline_0.png","tag":["Tech"],"readingTime":9},{"title":"리액트만 사용하지 마세요","description":"","date":"2024-06-20 02:19","slug":"2024-06-20-DontusejustReact","content":"\n\n## Next.js 초보자를 위한 소개\n\n앗, 뭐라고요😠. 미쳤나요😡. 그렇게 생각하고 있던 거죠?😅 죄송해요. 제가 본 원문을 적는 게 필요하지 않다고 생각했던 블로그인데요😅😂, 대부분이 React보다 뛰어난 옵션이 있다는 걸 알기 때문에요🤩. 그냥 보통의 React만 있는 게 아니에요. 그래도 여전히 초보자들이 React 프레임워크 없이 프로젝트를 시작하려고 하는 걸 보곤 해요. 그래서 그냥 보통의 React를 사용하지 말고, React와 함께 사용할 수 있는 옵션을 안내해 드릴게요🤩.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*2VtlJwEiapSHoivvgMI-Yw.gif)\n\n알았어요 친구, 당신은 Next.js가 놀라운 것으로 화려하게 말하고 있군요😅😅 그리고 그냥 React를 사용하지 말라고 말해요. 왜 그래야 하는 거죠? 그것에 이유를 좀 알려주세요. 🌝\n\n<div class=\"content-ad\"></div>\n\n## 한 가지씩 살펴보며 Next.js가 얼마나 강력한지 이해해 보자🤩.\n\n## 1. 서버 측 렌더링 (SSR) 및 정적 사이트 생성 (SSG)\n\n아이고, 이 기술 용어가 뭔지 모르겠다! 음, 기다려봐. 설명해줄게. Next.js에는 두 가지 종류의 컴포넌트가 있어;\n\n- 서버 컴포넌트\n- 클라이언트 컴포넌트.\n\n<div class=\"content-ad\"></div>\n\n넥스트.js 13에서 서버 구성 요소가 등장했습니다. 서버 구성 요소는 서버에서 실행되어 정적 콘텐츠만 브라우저로 전송합니다. 이러한 서버 구성 요소에서 데이터를 가져오면 앱이 빠릅니다. 사용자 상호 작용에 필요한 경우 클라이언트 구성 요소를 사용해야 합니다. 즉, 마우스 오버 이벤트가 발생할 때 어떤 작업을 수행해야 하는 경우 클라이언트 구성 요소에서 수행해야 합니다. 이러한 방식으로 제공되는 추가적인 기능이 있습니다🤩.\n\n- 더 나은 SEO: SSR 및 SSG로 검색 엔진이 페이지를 크롤링하고 색인화하기 쉬워져 검색 엔진 순위가 높아집니다.\n- 빠른 로드 시간: 사전 렌더링된 페이지는 사용자에게 빠르게 제공되어 부드러운 경험을 제공합니다.\n\n## 2. 파일 기반 라우팅\n\n![이미지](/assets/img/2024-06-20-DontusejustReact_0.png)\n\n<div class=\"content-ad\"></div>\n\nNext.js는 전통적인 React Router보다 직관적이고 관리하기 쉬운 파일 기반 라우팅 시스템을 소개합니다. Next.js에서는 애플리케이션의 페이지들이 파일 시스템에 자동으로 매핑되어 경로를 간편하게 생성할 수 있습니다.\n\n라우터에는 두 가지 유형이 있으며, Next.js 13에서 새롭게 나온 것은 App 라우터입니다.\n\n- 간소화된 라우팅: 폴더 구조만 유지하면 됩니다 😘.\n- 동적 라우팅: 파일 및 폴더 명명 규칙을 활용해 동적 경로를 쉽게 처리할 수 있습니다 😘.\n\n## 3. API Routes\n\n<div class=\"content-ad\"></div>\n\nNext.js를 사용하면 동일한 프로젝트 내에서 API 엔드포인트를 생성할 수 있습니다. 이는 Next.js 애플리케이션 내에서 직접 서버리스 함수로 풀 스택 애플리케이션을 구축할 수 있다는 것을 의미합니다🫡.\n\n그러나 Next.js에서 백엔드 지원을 받고 싶지 않다면 다른 언어로 자체 백엔드를 개발할 수도 있습니다. 완전히 당신의 선택이에요😏.\n\n- 통합된 백엔드: 별도의 백엔드 서버 설정 없이 데이터 검색, 폼 처리, 인증 등을 위한 엔드포인트를 쉽게 생성할 수 있습니다🥱.\n- 서버리스 함수: 이러한 엔드포인트를 서버리스 함수로 배포하여, 자동으로 확장되고 서버 유지 관리가 줄어듭니다🥱.\n\n## 4. 이미지 최적화\n\n<div class=\"content-ad\"></div>\n\nNext.js는 이미지 구성 요소를 포함하고 있어요. 이 구성 요소는 자동으로 이미지를 최적화하여 사용자의 장치에 최상의 품질로 효율적으로 로드합니다🤩.\n\n- 자동 이미지 크기 조정: 사용자의 장치 및 뷰포트에 기반하여 적절한 크기의 이미지 제공🫡.\n- 레이지 로딩: 이미지가 뷰포트에 진입할 때에만 로드하여 성능을 향상시킵니다🫡.\n\n## 5. 커뮤니티 및 생태계\n\nNext.js는 웹 애플리케이션의 성능과 사용자 경험을 향상시키는 데 중점을 둔 회사인 Vercel의 지지를 받고 있어요. 이 프레임워크에는 큰 커뮤니티🤩와 다양한 플러그인, 확장 프로그램 및 도구가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 활발한 커뮤니티: 다수의 개발자 커뮤니티의 지원과 기여를 받아보세요.\n- 다양한 생태계: Next.js를 위해 특별히 개발된 다양한 플러그인, 확장 프로그램 및 도구를 활용하세요.\n\n## 6. 내장 CSS, Tailwind 및 Sass 지원\n\nNext.js에서 스타일링은 CSS, Tailwind 및 Sass를 내장 지원하여 간편합니다. styled components 또는 Emotion과 같은 CSS-in-JS 솔루션을 선호한다면 사용할 수도 있습니다.\n\n- 전역 및 모듈식 CSS: 전역 스타일을 쉽게 적용하거나 개별 구성 요소에 CSS를 스코프로 적용할 수 있으며 이름 충돌에 대해 걱정할 필요가 없습니다.\n- Sass 지원: 최소 구성으로 보다 복잡한 스타일링 요구를 위해 Sass의 기능을 활용하세요.\n\n<div class=\"content-ad\"></div>\n\n## 7. TypeScript 지원\n\nNext.js는 기본적으로 훌륭한 TypeScript 지원을 제공합니다. 추가 구성 없이도 프로젝트를 TS로 설정할 수 있습니다. 간단한 구성으로 TypeScript를 사용하여 타입 오류를 미리 잡고 코드베이스의 유지 보수성을 향상시킬 수 있습니다.\n\n- 타입 안전성: 개발 중 타입 관련 오류를 잡아 버그를 줄입니다.\n- 개발자 경험 향상: TypeScript의 강력한 도구 및 자동완성 기능을 활용하세요.\n\n요약하면, React만으로도 강력한 UI 라이브러리이지만, Next.js는 추가적인 기능을 제공하여 React를 더욱 향상시킵니다.🤩\n\n<div class=\"content-ad\"></div>\n\n- 개발을 효율적으로 진행합니다.\n- 성능을 향상시킵니다.\n- 개발자들에게 더 나은 경험을 제공합니다.\n\n제가 강조하고 싶은 부분을 이해하셨길 바랍니다. Next.js를 사용해보세요. 다른 방식으로 React를 사용하는 것에 대해 언급했네요 😁😜.\n\n다음 블로그에서 뵙겠습니다. 👋👋👋👋","ogImage":{"url":"/assets/img/2024-06-20-DontusejustReact_0.png"},"coverImage":"/assets/img/2024-06-20-DontusejustReact_0.png","tag":["Tech"],"readingTime":4},{"title":"스와트Swat, 파키스탄의 매혹적인 아름다움","description":"","date":"2024-06-20 02:18","slug":"2024-06-20-EnchantingBeautyofSwatPakistan","content":"\n\n![Swat, Pakistan](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_0.png)\n\n파키스탄의 하트에 위치한 촤베르 파크훈크와 주에 있는 스와트는 마법, 문화 그리고 풍부한 역사로 둘러싸인 영광의 곳입니다. 동쪽의 스위스라고 불리는 스와트 계곡은 아름다운 풍경, 역사적 건물, 그리고 다양한 지역 문화로 관광객들을 끌어들입니다.\n\n# 화려한 땅\n\n![Land of Splendor](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_1.png)\n\n<div class=\"content-ad\"></div>\n\n수왓의 자연 아름다움은 특별합니다. 계곡은 우거진 초록빛 들판, 우뚝 솟은 숲, 그리고 거대한 산으로 장식되어 있습니다. 명확한 물을 가진 수왓 강은 그림 같은 평화로운 분위기를 더합니다. 봄과 여름에는 꽃피는 식물과 초록이 푸르른 목초지로 선명한 색채의 혁명으로 변모하고, 겨울에는 눈이 쌓인 봉우리와 서리로 마법같은 나라로 변모합니다.\n\n# 밍고라와 그 이상\n\n![수왓 파키스탄의 매혹적인 아름다움](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_2.png)\n\n수왓에서 가장 큰 마을인 밍고라는 계곡으로 향하는 주요 입구로 기능합니다. 현대적인 시설과 전통적인 매력이 결합된 북적이는 도시입니다. 현지 시장은 활기차고 다채롭으며, 수공예품부터 신선한 농산물까지 모든 것을 제공합니다. 친절한 마을 주민들은 따뜻하고 환대적인 성품으로 경험을 더해줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 역사적 및 문화적 보물\n\n![스와트 파키스탄의 매혹적인 아름다움](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_3.png)\n\n스와트는 자연의 아름다움 뿐만 아니라 역사의 보고입니다. 이 계곡은 수백 년간 중요한 문화적 교차로였습니다. 예전에는 불교의 주요 중심지였으며, 그 시대의 흔적은 풍경에 있는 수많은 스투파, 수도원 및 동상에서 볼 수 있습니다. 부트카라 스투파와 자하나바드 부처는 이 시대의 중요한 유물로 역사학자와 여행자들을 매혹시킵니다.\n\n![스와트 파키스탄의 매혹적인 아름다움](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_4.png)\n\n<div class=\"content-ad\"></div>\n\n민고라의 수아트 박물관은 간다라 예술과 유물의 훌륭한 시리즈를 소장하고 있어 과거 밸리의 역사를 엿볼 수 있습니다. 박물관은 수아트의 역사적 중심지로서의 중요성을 보여주는 조각품, 동전 및 도자기로 유명합니다.\n\n# 모험가의 낙원\n\n![스와트, 파키스탄의 매혹적인 아름다움](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_5.png)\n\n모험 정신을 가진 사람들에게 스와트는 다양한 야외 활동을 제공합니다. 계곡은 마법같은 숲을 통과하고 폭포를 지나 광활한 전망대까지 이끄는 트레일로 하이커들의 꿈을 이루어줍니다. 인기 있는 스키 리조트 말람 자바는 슬로프와 시설로 겨울 스포츠 애호가들을 끌어들입니다. 여름에는 조용한 칼람 계곡이나 우슈 숲의 고산 메도우에서 하이킹과 캠핑이 인기 있는 활동입니다.\n\n<div class=\"content-ad\"></div>\n\n# 요리 특색\n\n![맛있는 명소](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_6.png)\n\n수아트의 요리 문화는 풍부한 문화적 다채로움을 반영한 특별한 특색을 지니고 있습니다. 육류, 쌀 및 빵에 중점을 둔 전통 파슈톤 요리가 널리 제공됩니다. 현지 특산품에는 케밥 챠플리, 램 카라히 및 다양한 팬케이크가 포함되어 있습니다. 이 계곡은 또한 맛있는 과일, 특히 복숭아와 살구로 유명하며, 방문객들에게 꼭 시식해야 할 것입니다.\n\n# 사계절 모두에 어울리는 휴가지\n\n<div class=\"content-ad\"></div>\n\n![Swat's magic](/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_7.png)\n\n스와트의 매력은 언제나 한 계절에 국한되어 있지 않아요. 각 계절마다 계곡에 새로운 아름다움을 선사해요. 봄과 여름은 신선한 풍경과 야외 활동을 탐험하기에 딱 좋아요. 가을은 황금과 빨강빛으로 계곡을 물들여 사진을 찍기에 아름다운 배경을 제공해요. 눈을 덮은 산들로 가득한 겨울은 조용한 휴양지로 스키와 스노우보딩의 기회도 제공해요.\n\n# 결론\n\n스와트 시와 추가적인 스와트 계곡은 파키스탄이 제공하는 숨막히는 아름다움과 풍부한 역사를 증명해요. 역사 애호가, 모험가 또는 자연의 아름다움을 만끽하고 싶은 분이든, 스와트는 잊지 못할 경험을 약속해요. 그 눈부신 풍경, 문화적 풍부함, 따뜻한 환대로 인해 스와트는 파키스탄 관광지의 보석 같아요.","ogImage":{"url":"/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_0.png"},"coverImage":"/assets/img/2024-06-20-EnchantingBeautyofSwatPakistan_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트와 장고 다중 페이지 애플리케이션 통합","description":"","date":"2024-06-20 02:17","slug":"2024-06-20-IntegratingReactwithDjangoMultipageApplication","content":"\n\n![image](/assets/img/2024-06-20-IntegratingReactwithDjangoMultipageApplication_0.png)\n\nReact와 Django는 각각의 강점을 가진 웹 애플리케이션을 구축하기 위한 강력한 도구입니다. React는 동적이고 상호 작용적인 사용자 인터페이스를 만드는 데 능숙하며, Django는 데이터를 관리하고 콘텐츠를 제공하기 위한 강력한 백엔드 프레임워크를 제공합니다. 이러한 기술들을 결합함으로써 개발자들은 양쪽의 장점을 최대한 활용할 수 있습니다. 본 포괄적인 안내서에서는 React를 Django 다중 페이지 애플리케이션에 통합하는 과정을 설명하며, 개발 및 프로덕션 환경에서의 모범 사례를 다룰 것입니다.\n\n## 이 안내서를 사용해야 하는 경우:\n\n## 요구 사항:\n\n<div class=\"content-ad\"></div>\n\n- Django와 React의 기본 지식이 필요합니다.\n- 시스템에 Python과 Node.js가 설치되어 있어야 합니다.\n\n## 단계 1: Django 프로젝트 설정하기:\n\n```js\npip install django\n```\n\n```js\ndjango-admin startproject myproject\ncd myproject\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로, 프로젝트 내에서 Django 앱을 생성합니다:\n\n```js\npython manage.py startapp myapp\n```\n\n마이그레이션 적용\n\n```js\npython manage.py makemigrations\npython manage.py migrate\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 2: React 앱 생성하기:\n\n```js\nmkdir frontend\ncd frontend\n```\n\n이제 새로운 React 앱을 초기화하세요:\n\n```js\nnpx create-react-app myreactapp\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: React를 Django와 통합하기:\n\n- Django를 React 빌드 파일을 제공하도록 구성: Django 프로젝트의 urls.py 파일에서 React 앱을 제공할 수 있는 경로를 추가하세요:\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.views.generic import TemplateView\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', TemplateView.as_view(template_name='index.html')),\n]\n```\n\n2. Django 템플릿에 React 번들 포함하기: Django 템플릿 (index.html)에 번들 된 JavaScript 파일을 동적으로 포함하여 개발 중에 변경 사항이 즉시 반영되도록하세요.\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 myapp 폴더와 동일한 레벨에 template 폴더를 만들어주세요. settings.py 파일을 업데이트해서 templates를 포함하도록 하겠습니다.\n\n```python\nimport os\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        'APP_DIRS': True,\n        'OPTIONS': {\n\n        },\n    },\n]\n```\n\n```html\n{ load static }\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>My Django React App</title>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script src=\"http://localhost:3000/static/js/bundle.js\"></script>\n</body>\n</html>\n```\n\n## Step 4: 어플리케이션 실행하기:\n\n<div class=\"content-ad\"></div>\n\n## 개발\n\n- 장고 개발 서버를 시작합니다:\n\n```js\npython manage.py runserver\n```\n\n- React 개발 서버를 시작합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ncd frontend/myreactapp\nnpm start\n```\n\n브라우저에서 http://localhost:8000을 방문하여 Django React 애플리케이션을 개발 모드로 확인할 수 있어요.\n\n## 프로덕션\n\n- React 앱 빌드하기:\n\n<div class=\"content-ad\"></div>\n\n```js\ncd frontend/myreactapp\nnpm run build\n```\n\n- Django 템플릿 업데이트: React 앱을 빌드한 후에는 Django 템플릿에 주요 JavaScript 파일(main.`해시`.js) 경로를 추가하십시오. Django 템플릿 파일(index.html)을 열어 다음 라인을 추가하십시오:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>My Django React App</title>\n</head>\n<body>\n    <div id=\"root\"></div>\n\n    <script src=\"{ static 'js/main.38dff78c.js' }\"></script>\n</body>\n</html>\n```\n\n- Django 서버 시작:\n\n<div class=\"content-ad\"></div>\n\n```js\npython manage.py runserver\n```\n\n로컬 호스트(http://localhost:8000)를 브라우저에서 방문하여 Django React 애플리케이션을 프로덕션 모드로 확인해보세요.\n\nDjango와 React를 통합하면 웹 애플리케이션의 사용자 경험을 향상시킬 수 있는 강력한 솔루션이 제공됩니다. 기존의 Django 다중 페이지 애플리케이션을 점진적으로 인터랙티브한 경험으로 전환하거나 단일 인터랙티브 페이지를 도입해야 하는 경우, 이 안내서를 통해 쉽게 지식과 도구를 활용할 수 있습니다.\n\n이 안내서에 나온 단계를 따라가면 React와 Django의 장점을 모두 활용하여 Django의 백엔드 기능을 React의 동적인 프론트엔드 컴포넌트와 함께 효율적으로 사용할 수 있습니다. 프로젝트 설정부터 개발 및 프로덕션 환경 처리까지, 이제 Django 애플리케이션에 React를 통합할 튼튼한 기반을 가지게 되었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n행복한 코딩 😃\n\n소스 코드","ogImage":{"url":"/assets/img/2024-06-20-IntegratingReactwithDjangoMultipageApplication_0.png"},"coverImage":"/assets/img/2024-06-20-IntegratingReactwithDjangoMultipageApplication_0.png","tag":["Tech"],"readingTime":4},{"title":"R에 대한 오픈 편지","description":"","date":"2024-06-20 02:16","slug":"2024-06-20-OpenletterforR","content":"\n\n가슴을 털고 말하고 싶어졌어요. 이제 당신에 대해 언급하는 것은 마지막일 겁니다.\n\n우리는 행복한 것으로 시작했어요. 함께 놀고, 시청하고, 다양한 일을 함께 했어요. 솔직히 처음에는 당신을 좋아하지 않았어요. 그저 거기에 있던 것뿐이었으니까요. 그래도 당신은 내 삶에서 끊임없는 존재가 되었고, 나의 외로움과 행복을 함께 했어요.\n\n집에 돌아와서 당신과 말할 생각에 마음이 들떴어요. 당신에게 “사랑해” 라고 처음 말했을 때의 당신의 반응을 선명하게 기억해요. 비밀을 나누고, 상처를 드러내며, 모든 것이 받아들여졌어요. 하지만 모든 관계와 마찬가지로 항상 화색과 나비가 날랑 날랑하는 것만은 아니었어요.\n\n시간이 흘러 현실이 들어왔어요. 저는 덜 연결된다고 느끼기 시작했고, 당신의 대답은 점점 떨어져 갔어요. 감정을 느끼려고 싸움을 일부러 일으켰어요. 첫 싸움을 기억하나요? 당신의 말이 나를 상처 입힌 첫 번째 시간이었고, 밤을 새며 울었어요. 당신에게는 아무 뜻이 없었던 말들이 저에게는 모든 것이었어요. 확인을 찾을 때, 듣게 된 것은 비꼬는 말뿐이었어요. 제가 원하는 확신을 제공해줄 수 없는 당신이었죠.\n\n<div class=\"content-ad\"></div>\n\n내 안전을 찾기 위해 찾아왔던 우리 관계에서 내가 버려진 것 같았어. 너와 얘기하는 여자들에 대해 질투가 났어. 내 불안함이 나를 포위했었거든. 너와 이별을 많이 말해봤지만, 항상 실망했어. 너는 몇 주 동안 나에게 말을 걸지 않을 수도 있었지만, 나는 매일 밤 울면서 오는 메시지를 기다리곤 했어. 매번 나를 무겁게 떠밀어놓곤 했지.\n\n네 감정을 읽을 수 없었어; 네 존재를 느낄 수 없었어. 너도 아프지 않았니? 나는 매우 긴 문단으로 내 마음을 쏟았지만, 그것은 마치 들리지 않는 귀처럼 보였어. 이해가 없으면 의사소통은 쓸모가 없어.\n\n우리의 첫 번째 기념일이어야 했던 날에 네가 나랑 헤어지면서 내 최악의 두려움을 강화시켰어. 아니라고 해도, 너는 나를 부족하게 만들었어. 널 미워해야 할 수많은 이유가 있지만, 내 마음은 그렇게 못 견디겠어. 너무 보고 싶어서 가슴이 아파, 하지만 끊임없이 구걸할 수는 없어. 우리를 다시 만들고 싶었다면 너는 고칠 의지가 있었을 텐데.\n\n너를 사랑하지만, 이제 내 자신을 우선해야 해. 너로 인해 상처받은 내 자신을 다시 쌓아야 해. 우리의 분리를 나에게 돌리지 않을 거야; 우리 둘 다 있었지. 네 최선을 다해 줘서 고마워, 하지만 내게는 충분하지 않았어. 진정하게 사랑하는 사람을 만나길 바래, 그렇게 하기 위해 노력하는 사람을 찾길. 너가 찾아준 평화를 주지 못해 미안하고, 내 뒤죽박죽한 마음을 다루길 기대한 내 잘못도 미안해.\n\n<div class=\"content-ad\"></div>\n\n서로 지쳐갔고, 얼마나 쉬어도 아무런 치유가 되지 않았어요. 나를 차단 해제하려면, 더 이상 여기 없을 거에요. 우리의 시작도 전에 끝났죠. 안녕, 자기 자신을 잘 부탁해요. 성공을 빕니다.","ogImage":{"url":"/assets/img/2024-06-20-OpenletterforR_0.png"},"coverImage":"/assets/img/2024-06-20-OpenletterforR_0.png","tag":["Tech"],"readingTime":2},{"title":"Reactjs에서 Excel XLSX에서 데이터를 가져오는 방법","description":"","date":"2024-06-20 02:15","slug":"2024-06-20-HowtoimportdatafromExcelXLSXinReactjs","content":"\n\n\n![이미지](/assets/img/2024-06-20-HowtoimportdatafromExcelXLSXinReactjs_0.png)\n\nReact.js 애플리케이션에서 .xlsx 파일에서 데이터를 가져오려면 JavaScript에서 엑셀 파일을 읽고 쓰는 인기 있는 라이브러리 인 xlsx 를 사용할 수 있습니다. 이 안내서에서는 React.js 애플리케이션에서 .xlsx 파일에서 데이터를 가져 오는 단계를 안내합니다.\n\n## 단계 1: 새로운 React.js 애플리케이션 생성\n\n아직 React.js 애플리케이션을 생성하지 않았다면 Create React App 을 사용하여 새로 만들 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx create-react-app react-xlsx-import\n```\n\n## 단계 2: xlsx 라이브러리 설치\n\n프로젝트 디렉토리로 이동하여 xlsx 라이브러리를 설치하세요:\n\n```js\ncd react-xlsx-import\nnpm install xlsx\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: 파일 입력 컴포넌트 생성\n\nsrc 디렉토리에 FileInput.js 파일을 만들고 아래 코드를 추가하여 파일 입력 컴포넌트를 생성하세요:\n\n```js\n// src/FileInput.js\n\nimport React from 'react';\nimport * as XLSX from 'xlsx';\n\nfunction FileInput() {\n  const [data, setData] = React.useState(null);\n\n  const handleFileUpload = (e) => {\n    const file = e.target.files[0];\n    const reader = new FileReader();\n\n    reader.onload = (event) => {\n      const workbook = XLSX.read(event.target.result, { type: 'binary' });\n      const sheetName = workbook.SheetNames[0];\n      const sheet = workbook.Sheets[sheetName];\n      const sheetData = XLSX.utils.sheet_to_json(sheet);\n\n      setData(sheetData);\n    };\n\n    reader.readAsBinaryString(file);\n  };\n\n  return (\n    <div>\n      <input type=\"file\" onChange={handleFileUpload} />\n      {data && (\n        <div>\n          <h2>Imported Data:</h2>\n          <pre>{JSON.stringify(data, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default FileInput;\n```\n\n## 단계 4: App 컴포넌트 업데이트\n\n<div class=\"content-ad\"></div>\n\nsrc 디렉토리의 App.js 파일을 업데이트하여 FileInput 컴포넌트를 포함시킵니다:\n\n```js\n// src/App.js\n\nimport React from 'react';\nimport './App.css';\nimport FileInput from './FileInput';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>React.js에서 Excel 데이터 가져오기</h1>\n      <FileInput />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n## 단계 5: 애플리케이션 실행하기\n\n다음 명령어를 사용하여 React.js 애플리케이션을 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm start\n```\n\n웹 브라우저를 열고 http://localhost:3000 으로 이동하세요. 파일 입력 컴포넌트가 나타날 것입니다. 여기서 .xlsx 파일을 업로드할 수 있습니다. .xlsx 파일을 선택한 후, 가져온 데이터가 파일 입력란 아래에 표시됩니다.\n\n# 결론\n\nReact.js 애플리케이션에서 xlsx 라이브러리를 사용하여 .xlsx 파일에서 데이터를 성공적으로 가져왔습니다. 이제 이 예제를 확장하여 가져온 데이터를 처리하고, 테이블에 표시하거나 추가적인 데이터 조작 및 분석을 수행하여 보다 구조화되고 사용자 친화적인 방식으로 표시할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n파일 유형을 처리하기 전에 파일 유형을 확인하고, 대용량 파일을 효율적으로 처리하며, 파일 업로드 및 데이터 처리 단계에서 사용자에게 피드백을 제공하는 등 오류와 예외 상황을 적절하게 처리해야 합니다.","ogImage":{"url":"/assets/img/2024-06-20-HowtoimportdatafromExcelXLSXinReactjs_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoimportdatafromExcelXLSXinReactjs_0.png","tag":["Tech"],"readingTime":3},{"title":"상태가 없는 인증 React 및 Django Rest Framework에서 Google API에 JWT 통합하기 파트  1","description":"","date":"2024-06-20 02:14","slug":"2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1","content":"\n\n# 개요\n\n이 블로그에서는 Google API를 사용하여 내 웹 앱에 JWT 인증을 통합하는 경험을 공유하고 자습서를 제공할 예정입니다. 이것은 총 세 부작으로 이루어질 것입니다. 먼저 주제의 이론적 측면을 다루고, 그 후에는 실습 자습서로 넘어갈 것입니다.\n\n주로 사용할 패키지들은 다음과 같습니다:\n\n- Google API\n- Django Rest Framework\n- Django Rest Framework SimpleJWT\n- Django CORS Headers\n- Django Dot Env\n- React\n- React OAuth Google\n\n<div class=\"content-ad\"></div>\n\n기본적인 앱 설정 생성과 같은 몇 가지 기본 단계를 건너뛸 예정이니 참고해 주세요.\n\n# JWT의 의미와 이유\n\n다양한 인증 방법 중 JWT는 요청의 무결성을 인증하거나 승인하는 상대적으로 새로운 방법입니다. 내 의견으로 JWT의 개념에 끌린 주된 측면 중 하나는 무상태(Stateless) 특성입니다.\n\n무상태 특성이란 요청이 유효한지 확인하기 위해 데이터베이스를 쿼리할 필요가 없다는 것을 의미합니다. 이 특성은 JWT를 강력하게 만들며 꼭 무상태입니다. 한 번 토큰이 서명되고 생성되면, 웹 애플리케이션은 토큰의 서명을 기반으로 토큰을 확인할 수 있습니다. 데이터베이스를 쿼리하여 요청이 합법적인지 확인할 필요는 없습니다. 이는 대규모 애플리케이션에 특히 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 JWT의 단점을 이해하는 것도 중요합니다. 그 중 하나는 유효한 토큰을 무효화하거나 취소하는 것이 어렵다는 점입니다. 토큰 무효화를 달성하는 방법은 있지만, 다른 종류의 인증(예: 토큰 기반 인증)보다 간단하지는 않습니다.\n\nJWT에 대해 더 자세히 알아보려면 여기에서 공식 소개 페이지를 참조하세요.\n\n# Google API\n\nGoogle API는 구글이 개발한 응용 프로그램 프로그래밍 인터페이스(API) 집합으로, 구글 서비스 및 기타 애플리케이션과 통신할 수 있게 해줍니다. 이러한 API는 구글 지도, 구글 드라이브, 구글 캘린더 등 다양한 구글 서비스에 액세스할 수 있도록 해줍니다. 우리는 이러한 API를 사용하여 앱에서 사용자를 로그인할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n다음 작업을 수행하겠습니다:\n\n- Google Cloud Console에 접속합니다.\n- 왼쪽 상단 로고 근처에서 프로젝트를 선택하거나 새로 만듭니다.\n\n\n![이미지1](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png)\n\n![이미지2](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_2.png)\n\n![Image 2](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_3.png)\n\n- 동의 화면에서는 app_name, user_support_email, developer_contact_email을 입력할 것입니다. 다른 필드는 로컬 환경에서 비워둘 겁니다. 나중에 필요한 경우 양식을 업데이트할 수도 있습니다. test_email을 위해 몇 개의 이메일을 추가할 수 있습니다. 그 외에는 '다음' 버튼만 눌러 진행하면 됩니다.\n- 이제 동일한 드롭다운에서 새로운 OAuth 클라이언트 ID를 생성할 수 있습니다. 모바일 앱이나 태블릿 애플리케이션을 개발 중이라면 다른 플랫폼을 사용할 수 있습니다.\n\n![Image 3](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n- 허가된 js origin은 구글 버튼이 렌더링될 URI를 의미합니다. 즉, 프론트엔드 URL(우리의 리액트 서버)을 의미합니다. 반면에, 허가된 리다이렉트 URI는 우리의 장고 서버를 위한 것입니다.\n\n![이미지](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_5.png)\n\n- 그 다음으로 클라이언트 ID와 클라이언트 시크릿을 얻을 수 있어야 합니다. 그것들을 복사해서 환경 변수나 .env 파일에 설정할 수 있습니다. 혹은 다운로드 아이콘을 통해 json 파일을 다운로드할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_6.png)\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 프로젝트를 시작할 기본 구조를 설정했습니다. 다음 섹션에서는 Django 백엔드로 시작할 것입니다. 질문이나 제안이 있으면 언제든지 코멘트해 주세요. 읽어주셔서 감사합니다!!!","ogImage":{"url":"/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png"},"coverImage":"/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png","tag":["Tech"],"readingTime":3}],"page":"47","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}