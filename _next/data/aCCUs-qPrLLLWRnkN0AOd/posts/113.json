{"pageProps":{"posts":[{"title":"익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션","description":"","date":"2024-05-14 13:28","slug":"2024-05-14-ExpressgatewayYournextAPIGatewaySolution","content":"\n\n<img src=\"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png\" />\n\n안녕하세요 개발자 여러분! 이 블로그 포스트에 오신 것을 환영합니다. 이 포스트에서는 Express 게이트웨이에 대해 자세히 살펴보겠습니다. 왜 사용해야 하며 언제 사용해야 하는지, 그리고 어떤 문제를 해결할 수 있는지 알아봅시다. 시작해봅시다! 🚀\n\nAPI 게이트웨이는 현대 소프트웨어 아키텍처에서 중요한 구성 요소로, 백엔드 서비스와 API에 대한 모든 클라이언트 요청의 단일 진입점 역할을 합니다. 인증, 권한 부여, 속도 제한 및 라우팅과 같은 작업을 처리하며 클라이언트와 다양한 마이크로서비스 간의 통신을 간소화합니다. 이러한 기능을 중앙 집중화함으로써 API 게이트웨이는 분산 시스템의 보안, 확장성 및 관리 용이성을 향상시킵니다. 인기 있는 API 게이트웨이 솔루션에는 Kong, AWS API 게이트웨이 및 Traefik 등이 있으며, 이러한 서비스를 관리하는 UI와 함께 훌륭한 API 관리 시스템을 제공하지만 Express 게이트웨이는 이 문제에 대한 오픈 소스 솔루션이며 우리가 곧 살펴볼 모든 편리한 구성을 제공합니다.\n\nAPI 게이트웨이는 특히 분산 아키텍처에서 여러 마이크로서비스나 API를 관리할 때 사용해야 합니다. 통합된 진입점을 제공함으로써 클라이언트 액세스를 간소화하고 인증, 권한 부여 및 트래픽 관리와 같은 필수 기능을 제공합니다. 게다가 API 게이트웨이는 복잡한 서비스 지향 환경에서 보안 정책을 강화하고 잠재적인 위험을 완화하는 데 유용합니다.\n\n\n\n\n![Express Gateway 이미지 1](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_1.png)\n\n![Express Gateway 이미지 2](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_2.png)\n\nExpress Gateway는 미리 정의된 라우팅 규칙에 따라 들어오는 HTTP 요청을 가로채어 적절한 마이크로 서비스 또는 API로 보내는 방식으로 작동합니다. 인증, 권한 부여, 속도 제한 및 로깅과 같은 작업을 처리하여 클라이언트와 서비스 간의 안전하고 효율적인 통신을 보장합니다. Express Gateway의 정책 시스템은 사용자 정의 및 확장성을 허용하여 개발자가 특정 요구 사항에 맞게 조정할 수 있도록 합니다. Express Gateway에서 사용 가능한 정책 목록을 확인하고 그에 맞게 구성하는 방법을 알아봅시다.\n\n이제 Express Gateway의 설치부터 시작하여 우리의 요구 사항에 맞게 구성하는 방법을 살펴봅시다.\n\n\n\n\n```js\n$ bun add -g express-gateway\n```\n\n- 익스프레스 게이트웨이를 추가합니다.\n\n```js\n$ eg gateway create\n```\n\n몇 가지 질문에 답하면 기본 구성으로 준비된 게이트웨이 프로젝트가 생성됩니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_3.png\" />\n\n- server.js: 게이트웨이의 진입점이며 구성이 로드되고 응용 프로그램이 API 엔드포인트를위한 포트 8080 및 관리 API 엔드 포인트를위한 포트 9876에서 수신 대기를 시작하는 위치입니다.\n- system.config.yml: 게이트웨이의 시스템 수준 구성 및 글로벌 매개 변수가 정의되어 있으며 system.config.yml에 설명되어 있습니다. 이 구성 파일은 게이트웨이를 실행하는 데 사용되는 인프라 구성 설정을 설명합니다.\n- gateway.config.yml: 게이트웨이의 모든 기능이 정의되어 있으며 gateway.config.yml에 설명되어 있습니다. 이 구성 파일은 게이트웨이의 마이크로 서비스 및 API 연산 전체를 한눈에 보여줍니다.\n- models: models 디렉토리에는 Express Gateway 엔티티의 JSON 스키마를 설명하는 모델 구성 파일이 포함되어 있습니다. 이는 사용자 정의 및 확장 가능한 항목입니다.\n\nExpress Gateway 구성을 시도해보기 위해 각각 다른 포트 3000, 3001 및 3002에서 실행 중인 local-server에 세 개의 Express 서버를 만들었습니다.\n\n<img src=\"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_4.png\" />\n\n\n\n이제 gateway.config.yml을 구성하여 익스프레스 게이트웨이의 라우트에 마이크로 서비스를 포함시켜서 요청을 지정된 마이크로 서비스로 리디렉션할 수 있도록 설정하십시오.\n\n```js\nhttp:\n  port: 8080\nadmin:\n  port: 9876\n  host: localhost\napiEndpoints:\n  ms1:\n    host: localhost\n    paths: /api/ms1/*\n  ms2:\n    host: localhost\n    paths: /api/ms2/*\nserviceEndpoints:\n  ms1:\n    url: 'http://localhost:3000'\n  ms2:\n    url: 'http://localhost:3001'\npolicies:\n  - basic-auth\n  - cors\n  - expression\n  - key-auth\n  - log\n  - oauth2\n  - proxy\n  - rate-limit\npipelines:\n  ms1:\n    apiEndpoints:\n      - ms1\n    policies:\n      - proxy:\n          - action:\n              serviceEndpoint: ms1\n              changeOrigin: true\n  ms2:\n    apiEndpoints:\n      - ms2\n    policies:\n      - proxy:\n          - action:\n              serviceEndpoint: ms2\n              changeOrigin: true\n```\n\n- http: 익스프레스 게이트웨이가 수신하는 HTTP 요청의 포트를 지정합니다 (포트 8080).\n- admin: 관리 인터페이스에 액세스하기 위한 포트 (9876) 및 호스트 (localhost)를 정의합니다.\n- apiEndpoints: 지정된 경로를 기반으로 서로 다른 마이크로 서비스 (ms1 및 ms2)를 위한 엔드포인트를 구성합니다.\n- serviceEndpoints: 서비스 엔드포인트 (ms1 및 ms2)를 해당 URL과 연결합니다.\n- policies: API 라우트에 적용할 수 있는 사용 가능한 정책을 나열합니다. 기본 인증, CORS, 속도 제한 등이 포함됩니다.\n- pipelines: 각 마이크로 서비스에 대해 처리 파이프라인을 정의하고 적용할 API 엔드포인트 및 정책을 지정합니다. 예를 들어, ms1에 대한 파이프라인은 요청을 ms1 서비스 엔드포인트로 프록시하고 출처 변경을 가능하게 합니다. 마찬가지로, ms2에 대한 파이프라인은 출처 변경이 가능한 상태로 요청을 ms2 서비스 엔드포인트로 프록시합니다.\n\n게이트웨이 구성에 대해 더 알아보려면 이 링크를 따르세요 [링크](내부 링크 주소를 입력하세요).\n\n\n\n이제 구성 변경으로 인해 localhost:8080/api/ms1/에 요청을 보낼 수 있으며 해당 요청을 serviceEndpoint에 리디렉션할 것입니다.\n\n또한 다음은 이 구성을 편집할 수 있는 관리자 API 엔드포인트를 사용할 수 있습니다. 아래는 예시입니다.\n\n- API 엔드포인트 생성\n\n![이미지](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_5.png)\n\n\n\n- 서비스 엔드포인트 생성\n\n![이미지](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_6.png)\n\n- 서비스 엔드포인트용 파이프라인 생성\n\n![이미지](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_7.png)\n\n\n\n이 요청에서 다른 가능한 정책도 구성하세요.\n\napiEndpoints, serviceEndpoint 및 piplines을 나열할 수도 있습니다. 이러한 엔드포인트에 대해 GET 요청을 만들어 읽을 수 있습니다. 익스프레스 게이트웨이는 관리자 API를 자체 도메인이나 서브도메인으로 유지하고 이를 퍼블릭으로 사용할 수 없도록 권장하며, 이러한 엔드포인트에 인증을 추가할 수도 있습니다.\n\n관리자 API 엔드포인트에 대한 자세한 정보는 다음 문서를 읽는 것을 권장합니다.\n\nAPI 관리 여정에 착수하면서 익스프레스 게이트웨이의 공식 문서를 탐험하는 것을 잊지 마세요. 이 강력한 도구에 대한 이해와 능력을 향상시키는 데 소중한 자원으로 작용합니다. 즐거운 코딩👨‍💻️!","ogImage":{"url":"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png"},"coverImage":"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png","tag":["Tech"],"readingTime":5},{"title":"디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까","description":"","date":"2024-05-14 13:27","slug":"2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem","content":"\n\n![이미지](/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png)\n\n웹 개발자이시라면, 짧은 시간 간격으로 반복적으로 실행되는 코드의 성능을 최적화해야 하는 상황에 직면할 수 있습니다. 예를 들어, 사용자가 타이핑하는 동안 백엔드에서 제안을 가져오는 검색 창이나 페이지 레이아웃을 조정하는 크기 조정 이벤트 핸들러 등이 있을 수 있습니다. 이러한 경우에 코드가 너무 자주 실행되지 않도록 하고, 불필요한 네트워크 요청, 느린 사용자 인터페이스 또는 고 CPU 사용량을 유발하지 않도록 하려면 좋지 않습니다.\n\n이 문제를 해결하기 위해 디바운싱(debouncing)과 쓰로틀링(throttling)이라는 두 가지 기술을 사용할 수 있습니다. 이러한 기술을 사용하면 코드가 실행되는 속도를 제어하고 호출되는 횟수를 줄일 수 있습니다. 이 기사에서는 디바운싱과 쓰로틀링이 무엇인지, 어떻게 다른지, 그리고 JavaScript에서 이를 구현하는 방법에 대해 설명하겠습니다.\n\n## 디바운싱이란 무엇인가요?\n\n\n\n디바운싱은 사용자가 특정 작업을 수행하지 않을 때까지 함수의 실행을 지연시키는 기술입니다. 예를 들어, 사용자가 타이핑하는 동안 백엔드에서 제안을 가져오는 검색 창이 있다면, API 호출을 수행하는 함수를 디바운싱할 수 있습니다. 이렇게 하면 사용자가 몇 초 동안 타이핑을 멈춘 후에만 해당 함수가 실행되도록 할 수 있습니다. 이렇게 함으로써 서버를 과부하로 만들거나 관련이 없는 결과를 반환하는 API 호출을 피할 수 있습니다.\n\n자바스크립트에서 디바운싱을 구현하려면 지연 기간을 추적하는 타이머 변수를 사용할 수 있습니다. setTimeout 함수를 사용하여 지연 기간 후에 함수를 실행할 타이머를 설정할 수 있습니다. 사용자가 동작을 다시 수행하기 전에 지연 기간이 끝나면 clearTimeout 함수를 사용하여 타이머를 취소할 수도 있습니다. 이렇게 함으로써 사용자가 동작을 멈춘 후에 함수가 한 번만 실행되도록 할 수 있습니다.\n\n다음은 자바스크립트에서 디바운싱을 구현하는 예시입니다:\n\n```js\n// 검색 쿼리로 API 호출을 수행하는 함수\nfunction searchHandler(query) {\n    // 검색 쿼리로 API 호출 수행\n    getSearchResults(query);\n}\n\n// 함수와 지연 시간을 매개변수로 받는 debounce 함수\nfunction debounce(func, delay) {\n    // 지연 기간을 추적하는 타이머 변수\n    let timer;\n    // 인수를 받는 함수를 반환\n    return function(...args) {\n        // 이전 타이머를 지우기\n        clearTimeout(timer);\n        // 지연 기간 후 함수를 실행할 새로운 타이머 설정\n        timer = setTimeout(() => {\n            // 인수와 함께 함수 적용\n            func.apply(this, args);\n        }, delay);\n    };\n}\n\n// 500ms 지연을 가진 검색 핸들러의 디바운스 버전\nconst debouncedSearchHandler = debounce(searchHandler, 500);\n\n// 검색 바 입력에 이벤트 리스너 추가\nsearchBar.addEventListener(\"input\", (event) => {\n    // 입력란의 값 가져오기\n    const query = event.target.value;\n    // 쿼리로 디바운스된 검색 핸들러 호출\n    debouncedSearchHandler(query);\n});\n```\n\n\n\n이 예제에서는 검색 쿼리로 API 호출을 하는 searchHandler 함수가 있습니다. 또한 함수와 지연을 매개변수로 사용하여 해당 함수의 디바운스 버전을 반환하는 debounce 함수도 있습니다. 우리는 이 debounce 함수를 사용하여 500ms 지연을 가진 debouncedSearchHandler 함수를 만듭니다. 그런 다음 검색 창 입력란에 이벤트 리스너를 추가하고 입력 값으로 debouncedSearchHandler 함수를 호출합니다. 이렇게 함으로써 사용자가 500ms 동안 타이핑을 멈추면 단 하나의 API 호출만 한다는 것을 보장할 수 있습니다.\n\n## 쓰로틀링이란?\n\n쓰로틀링은 함수의 실행을 지정된 시간 간격마다 한 번씩 제한하는 기술입니다. 예를 들어 페이지 레이아웃을 조정하는 리사이즈 이벤트 핸들러가 있는 경우, 레이아웃을 업데이트하는 함수를 쓰로틀링하여 100ms마다 한 번씩만 실행되도록 할 수 있습니다. 이렇게 함으로써 코드를 너무 자주 실행하는 것을 피하고, 사용자 인터페이스가 끊기거나 높은 CPU 사용률을 유발하는 것을 방지할 수 있습니다.\n\nJavaScript에서 쓰로틀링을 구현하려면 함수가 이미 실행 중인지 여부를 추적하는 플래그 변수를 사용할 수 있습니다. setTimeout 함수를 사용하여 시간 간격 이후에 플래그를 재설정할 타이머를 설정할 수 있습니다. 또한 함수를 실행하기 전에 플래그가 true인지 확인하는 if문을 사용할 수도 있습니다. 이렇게 함으로써 함수가 지정된 시간 간격마다 한 번만 실행되도록 보장할 수 있습니다.\n\n\n\n자바스크립트에서 쓸데없는 반복을 줄이는 방법 중 하나인 쓸데없는 실행을 빈번하게 하는 데바운싱(Debouncing)과 쓸데없는 실행을 일정 간격으로 제한하는 스로틀링(Throttling)을 구현하는 방법을 보여드렸어요.\n\n아래 코드는 페이지 레이아웃을 업데이트하는 updateLayout 함수와 함수 및 간격을 매개변수로 받아 해당 함수의 스로틀링된 버전을 반환하는 throttle 함수를 보여줍니다. 이 throttle 함수를 사용하여 100ms 간격의 throttledUpdateLayout 함수를 생성합니다. 그런 다음 창 크기 조정 이벤트에 대한 이벤트 리스너를 추가하고 throttledUpdateLayout 함수를 호출합니다. 이렇게 하면 100ms마다 레이아웃을 업데이트하는 것을 보장할 수 있어요.\n\n## 데바운싱(Debouncing)과 스로틀링(Throttling)의 차이점은 무엇인가요?\n\n\n\nDebouncing(디바운싱)과 Throttling(슈로틀링)의 주요 차이점은 디바운싱은 일정 시간 동안 기다린 후 함수를 실행하는 반면, 스로틀링은 일정 간격으로 함수를 실행한다는 것입니다. 두 기법 모두 코드의 성능을 향상시키는 데 유용하지만 각각 다른 사용 사례와 효과가 있습니다.\n\n디바운싱은 특정 작업을 수행하는 사용자가 멈출 때까지 코드의 실행을 지연시키고 싶을 때 유용합니다. 예를 들어 사용자가 백엔드에서 제안을 불러오기 전에 사용자가 입력을 멈출 때까지 기다리고 싶은 경우 자동 완성에 디바운싱을 사용할 수 있습니다. 디바운싱을 사용하면 코드 실행 횟수를 줄일 수 있지만 사용자 인터페이스에 지연이 발생할 수도 있습니다.\n\n스로틀링은 코드 실행을 일정 주기로 제한하고 싶을 때 유용합니다. 예를 들어 페이지 레이아웃을 일정한 속도로 업데이트하고 싶을 때 리사이즈에 대해 스로틀링을 사용할 수 있습니다. 스로틀링을 사용하면 사용자 인터페이스의 응답성을 향상시킬 수 있지만 코드의 일부 정보 누락이나 정확도 손실을 가져올 수도 있습니다.\n\n## 결론\n\n\n\n디바운싱과 쓰로틀링은 짧은 시간 동안 반복적으로 실행되는 코드의 성능을 최적화하는 데 도움이 되는 두 가지 기술입니다. 디바운싱은 사용자가 특정 작업을 일정 시간 동안 수행하지 않을 때까지 코드 실행을 지연시킵니다. 쓰로틀링은 코드 실행을 지정된 시간 간격마다 한 번으로 제한합니다. 두 기술은 서로 다른 사용 사례와 효과를 가지고 있으며, 여러분의 요구에 가장 잘 맞는 방법을 선택해야 합니다.","ogImage":{"url":"/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png"},"coverImage":"/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png","tag":["Tech"],"readingTime":4},{"title":"카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기","description":"","date":"2024-05-14 13:24","slug":"2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard","content":"\n\n<img src=\"/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png\" />\n\n만약 누군가가 나에게 비가 오는 오후를 보내며 'q-테이블'을 통한 강화 학습 데모를 만들어 오래된 친구들의 집에서 얼 그레이 차를 찾는 캡틴 피카드를 쫓는다고 말해 준다면, 나는 그들을 미친 사람이라고 부를 것이다.\n\n그런데, 여기에 우리가 있네요.\n\n(여기 내가 연례 휴가를 즐기며 지루해질 때 일어나는 일이지...)\n\n\n\n여러분이 8월 '23을 되돌아보자면, 저는 강화학습 기초에 관한 가이드를 작성하는 데 시간을 할애했었죠.\n\n이 가이드에서는 '다중암 기계' 문제를 살펴보고, 무작위 선택을 통해 보상을 최대화하는 다양한 방법을 탐색해보았습니다. 욕심 부리는 선택, 그리고 욕심부리는 엡실론 사용까지 비교해보았죠. 적어도 나에게는 정말 즐거운 경험이었어요! 하지만 그것은 강화학습 세계의 극표면을 다루는 것에 불과합니다. 'RL'이라 불리는 광범위한 세계에 대해 읽어보기 시작하면, 컴퓨터에게 보상을 극대화하는 법을 가르치기 위한 다양한 알고리즘, 방법론, 프레임워크로 가득한 깊고 복잡한 세계임을 알게 됩니다.\n\n본 후속 글에서는 강화학습 세계를 더 심도 있게 파헤치고, 문제를 해결하기 위해 강화학습을 사용하는 더 복잡하지만 흥미로운 방법 중 하나를 탐구할 것입니다. 최종적으로는 우리만의 강화학습 실험을 직접 구축하는 과정까지 이어질 것입니다! 만약 이 기사의 나머지 부분을 따라주신다면, 여러분은 여러분만의 브라우저에서 체험할 수 있는 강화학습의 작은 기술 데모를 즐길 수 있을 겁니다.\n\n# Q 누구?\n\n\n\n![image](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_1.png)\n\n특정 강화 학습 메커니즘인 'Q-러닝'에 대해 배우게 될 거에요. 그게 무엇인지 이해하려면 1989년으로 모습을 돌려봐야해요. 그 해, Christoper Watkins 교수라는 창의적인 학자가 나타났어요.\n\nWatkins는 AI/ML 엔터프라이즈에 중요한 공헌을 한 인물로, 기계 학습에 관한 다수의 논문(텍스트 해석 방식에서 큰 언어 모델과 사람 간의 유사성을 제시한 2022년 연구 포함)의 저자 또는 공동 저자로 활동했어요. 그 중 1989년에 'Q-러닝' 개념을 소개한 논문에 우리는 오늘 초점을 맞출 거에요.\n\n논문에는 \"Q-러닝(Watkins, 1989)은 에이전트가 제어된 Markov 도메인에서 최적으로 행동하는 법을 배우는 간단한 방법이다\"라고 나와 있어요. (Markov 도메인에 대한 자세한 내용은 나중에 설명할게요)\n\n\n\n첫째로, Q-학습은 다른 강화 학습 방법 및 알고리즘과 마찬가지로 에이전트가 환경을 이해하여 주어진 시나리오에서 보상을 극대화하기 위한 방법입니다. 강화 학습에 대한 첫 번째 글을 생각해보면 'RL 루프'를 다음과 같이 상상했습니다:\n\n![RL 루프 이미지](/assets/img/2024-05-14-BuildingaQ-tableReinforcementLearningAgentwithCaptainPicard_2.png)\n\nQ-학습에도 동일한 다이어그램이 적용됩니다. 추상적으로 말하면 에이전트가 환경에서 행동을 취하여 보상을 얻고, 실제 세계의 사용 사례에서는 온라인 마케팅에 사용하여 고객에게 구매 습관에 가장 적합한 광고를 제공하는 최적화 작업에 사용할 수 있습니다 (고객이 광고를 클릭할 때 보상이 제공됩니다).\n\nQ 학습에서 에이전트는 특정 상태에서 작업을 시도하고, 즉시 받은 보상이나 패널티 및 해당 상태의 가치에 대한 추정을 평가합니다. 모든 상태에서 모든 작업을 반복적으로 시도함으로써 장기적으로 할인된 보상에 의해 평가된 전체적으로 가장 좋은 작업을 학습합니다.\n\n\n\n환경 내에서 행동의 가치에 대한 정보를 저장하기 위해 Q-러닝은 'Q-테이블'을 사용합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_3.png)\n\nQ 테이블을 그냥 그런 테이블로 생각해보세요. 이 테이블은 환경에서 가능한 상태와 행동을 나타내는 열과 행의 조회 테이블입니다.\n\nQ 테이블의 각 '셀'은 초기에 0으로 설정됩니다(이를 '미발견됨'으로 생각할 수 있습니다) 하지만 에이전트가 발견하면 상태와 행동의 각 조합에 대해 얻은 보상으로 Q-테이블을 업데이트합니다. 시간이 지남에 따라, 아이디어는 에이전트가 Q 테이블에서 지속적으로 업데이트되는 정보를 활용하여 보상을 극대화하기 위한 최상의 조치에 수렴할 것입니다.\n\n\n\n우리 이전의 기사에서 3개의 팔잡이 문제에 대한 관점을 고려해보면, 초기 q-테이블은 다음과 같이 보일 수 있어요:\n\n```js\n| State | Arm 1 | Arm 2 | Arm 3 |\n|-------|-------|-------|-------|\n|   1   |   0   |   0   |   0   |\n```\n\n슬롯 머신에는 실제로 손잡이를 당기는 하나의 상태만 있고, 3개의 기계를 가진 3개의 팔잡이 문제에서, 위와 같은 결과를 얻게 됩니다. 몇 번의 슬롯을 당겨본 후에는 몇 가지 보상 값이 나올 수 있어요:\n\n```js\n| State | Arm 1 | Arm 2 | Arm 3 |\n|-------|-------|-------|-------|\n|   1   |  0.5  |   1   |   4   |\n```\n\n\n\n에이전트가 상태에 있을 때, 그 상태에 대한 Q-테이블의 행을 확인하고 대부분의 경우, 그 행에서 가장 높은 Q-값을 갖는 행동을 선택합니다 (지금까지 알고 있는 가장 좋은 행동). '탐험률' (에이전트가 새로운 행동을 탐험할지 알려진 좋은 행동을 활용할지를 선택하는 빈도)과 '탐험 감소' (에이전트가 최대 보상 경로로 수렴하고 고수하는 속도)와 같은 요소들은 에이전트가 Q-테이블에서 찾은 값에 얼마나 의존할지에 영향을 미칩니다.\n\nQ-테이블과 상호 작용하는 공식인 '벨만' 방정식은 다음과 같습니다:\n\n새로운 Q-값 = 이전 Q-값 + 학습률 × (보상 + 할인율 × 최상의 미래 Q-값 - 이전 Q-값)\n\n벨만 방정식의 아이디어는 상태-행동 쌍의 가치가 즉시 보상뿐만 아니라 최선의 예상 미래 보상에도 기반하여 업데이트되며, 학습률에 의해 조정된다는 것입니다. 하지만 지난 보상들은 어떨까요? 이전에 있었던 일들의 역사는 어떻게 될까요?\n\n\n\n# 마르코프 성질의 역할\n\n![이미지](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_4.png)\n\n'마르코프(Markov)' 성질을 따르는 환경에 대해 얘기할 때 q-테이블 및 q-러닝 방법을 사용하는 것이 가장 적합하다는 점을 주목하는 것이 중요합니다.\n\n그게 뭔지 궁금하신가요?\n\n\n\n본질적으로 환경은 '마르코프'로 간주됩니다(러시아의 수학자 안드레이 마르코프에서 유래된 용어). 여기서 '마르코프'란 환경 안의 에이전트의 미래 상태가 현재 상태와 그 상태에서 취하는 행동에만 의존하며, 그 전에 발생한 사건이나 상태 순서에는 영향을 받지 않는 것을 의미합니다. 즉, 과거는 중요하지 않고, 현재와 즉각적인 미래만 고려하여 최상의 보상을 얻는 데 집중됩니다.\n\n마르코프 환경의 한 예로는 연결 네 개 보드가 있습니다. 연결 네에서 움직일 때마다, 실제로 중요한 것은 해당 시점의 보드 상태뿐이며, 5번 전에 누가 무슨 일을 했는지는 중요하지 않습니다(물론 그 때 중요했던 사항이지만, 움직일 때는 현재 보드 상태와 플레이 중인 모든 조각들만 알면 됩니다).\n\n마르코프 환경이 아닌 좋은 예시로는 포커 게임을 들 수 있습니다. 현재 카드와 베팅 풀뿐만 아니라, 상대의 베팅 이력과 블러핑 등의 맥락도 고려해야 합니다. 이러한 사항들은 현재와 미래 패를 플레이하기 위해 전략을 수정할 수 있습니다.\n\n강화학습에는 마르코프와 비마르코프 환경으로 처리하는 메커니즘이 있지만, Q-러닝은 전자를 위해 설계되었습니다.\n\n\n\n# 얼 그레이, 뜨겁게!\n\n이제 기다리고 계셨던 순간이 왔어요. 속 내용이 어떻게 스타 트렉: 다음 세대의 캡틴, 쟌 루크 피카드와 연결되는 건지 궁금하셨죠? 음, 여기서는 상기된 스타 플릿 선장과 그의 유명한 얼 그레이 차에 대한 애정을 사용해서 Q-러닝의 우리만의 구현을 보여드릴 거예요!\n\n그를 위해, '얼 그레이, 뜨겁게!' 라는 이름의 스타 트렉 우주를 기반으로 한 간단한 아케이드 게임을 디자인하기로 결정했어요.\n\n![Earl Grey, HOT!](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_5.png)\n\n\n\n우리의 강화학습 기반 게임을 만들기 위해 몇 가지가 필요할 거에요. 끝에 GitHub 레포지토리 링크를 제공할 테니, 여정 동안 함께 하실 거예요. 실험에서는 다음을 선택했어요:\n\n- Phaser (웹 기반 게임 개발 툴킷). 브라우저에서 호스팅할 빠르게 프로토타입을 만들고 싶어서 선택했어요. Phaser에 대해 더 알고 싶다면 여기를 참고하세요 https://phaser.io/\n- JavaScript (브라우저/클라이언트 기반으로 무언가를 만들기 때문에 순수 바닐라 JavaScript를 사용할 거에요).\n- AWS AppRunner (마지막 솔루션을 호스팅하기 위해 사용할 거예요. AppRunner에 대한 지식은 필요하지 않지만, GitHub와 AWS AppRunner 사이의 효과적인 연동이 간단하고 효과적이어서 선택했어요. 더 알아보려면 여기를 참고하세요 https://docs.aws.amazon.com/apprunner/latest/dg/service-source-code.html\n\n제 이야기는 이렇습니다. 불쌍한 Picard가 우주 병원에 감염되었어요. 이 바이러스로 뇌의 논리와 결정 센터가 덮어씌워져 동물처럼 허기진 듯이 얼그레이 차를 찾는 무모한 욕망이 일어났는데요. 그 결과, 그는 더 많은 얼그레이를 찾기 위해 지역 양로원을 뒤지고 다닌다고 해요. 이것이 우리 게임의 핵심이 될 거예요:\n\n- 에이전트 (Picard 선장)\n- 환경 (어린이집, 우리 경우 8 * 8 그리드)\n- 목표 (얼그레이 찻잔)\n- 일부 장애물 (Picard의 진행을 막는 양로원 간호원들!)\n\n\n\n저희 어플리케이션은 매우 간단하게 유지하고 있습니다. 우리 게임을 표시하는 index.html이 있고, RL 로직을 포함한 game.js, 게임을 호스팅하는 node.js 스크립트인 server.js, 그리고 몇 개의 .png 에셋이 있습니다. 완성된 에셋은 다음 저장소에 있어서 즐거운 시간을 보내실 수 있습니다:\n\n우리의 Web UI에는 우리의 에이전트의 성능에 영향을 미칠 수 있는 강화 학습 매개변수가 몇 가지 있습니다! 이들은 다음과 같습니다:\n\n- 학습률 — 에이전트가 경험으로부터 학습하는 속도를 나타냅니다. 높은 학습률은 에이전트가 더 빨리 학습하지만, 오버피팅에 민감할 수도 있습니다.\n- 할인 계수 — 할인 계수는 에이전트가 미래 보상을 얼마나 중요하게 생각하는지 결정합니다. 높은 할인 계수는 에이전트가 미래 보상을 더 중요하게 생각하게 만들고, 그 반대도 마찬가지입니다.\n- 탐험 비율 — 탐험 비율은 에이전트가 새로운 행동을 얼마나 자주 탐구할지 결정합니다. 높은 탐험 비율은 에이전트가 더 자주 탐구하게 만들고, 그 반대도 마찬가지입니다.\n- 탐험 감소 — 탐험 감소는 탐험 비율이 시간이 지남에 따라 얼마나 빨리 감소할지 결정합니다. 높은 탐험 감소는 탐험이 더 빨리 감소하게 만들고, 그 반대도 마찬가지입니다.\n\n자바스크립트 코드를 비롯한 모든 내용을 하나하나 검토하는 것보다, 강화 학습 구현과 관련된 부분에 중점을 둘 것입니다. Phaser 게임의 기본 설정(스프라이트, 환경 등)에 대한 정보는 Phaser 웹사이트를 참조해주세요.\n\n\n\nQ-learning을 사용하기 때문에 q-테이블을 생성해야 하는데, 이전에 간단히 언급한 것보다 더 복잡한 q-테이블이 필요합니다. 강화학습 환경을 생각해 보면, 8x8 그리드가 있으므로 64개의 다른 상태가 있습니다. 게다가, Picard는 각 그리드 타일에서 위, 아래, 왼쪽 또는 오른쪽으로 이동할 수 있으므로 8x8x4로 이어지게 됩니다. 따라서 이를 위해 3차원 배열이 필요합니다!\n\n게임.js에서 이를 수행하기 위해 q-테이블을 다음과 같이 생성합니다:\n\n```js\nfunction create() {\n    // gridSize x gridSize x 4 (4는 행동의 수)\n    qTable = Array(gridSize).fill().map(() => Array(gridSize).fill().map(() => Array(4).fill(0)));\n```\n\n\n\n기본적으로 우리는 격자의 길이를 가진 배열을 생성하고, 각 요소가 격자의 길이인 배열 내에 배열을 생성한 다음, 그 배열 내에 배열을 만들어 각 요소가 4가지 작업 상태에 대한 배열을 포함하도록합니다.\n\n우리 게임에서 무슨 일이 일어날까요? 의사 결정 프로세스의 핵심은 update(time) 메서드에서 처리됩니다.\n\n여기에서 우리의 에이전트는 행동을 결정하고, 그 행동을 취하며 보상이 업데이트되고, q-테이블이 업데이트되고 목표가 달성될 때까지 진행됩니다. update(time) 내에는 위치를 업데이트하고 스프라이트 또는 텍스트를 렌더링하는 데 관련된 많은 코드가 있지만, 검토해야 할 두 가지 핵심 요소는 chooseAction(position) 함수와 takeAction(position, action) 함수입니다.\n\n다음은 우리의 chooseAction 메서드입니다:\n\n\n\n```js\nfunction chooseAction(position) {\n    var action;\n\n    // 마지막 이동을 되돌리는 행동을 피합니다.\n    var avoidActions = lastActions(); // 최근 몇 가지 작업을 피하기 위한 함수 호출\n\n    if (Math.random() < explorationRate) {\n        do {\n            action = Math.floor(Math.random() * 4); // 탐험\n        } while (avoidActions.includes(action));\n    } else {\n        // 최선으로 알려진 행동을 활용하며, 가능한 경우 최근 작업의 반대를 피합니다.\n        var currentQValues = [...qTable[position.y][position.x]]; // 현재 Q-값을 복제합니다.\n        avoidActions.forEach(a => currentQValues[a] = Math.min(...currentQValues)); // 반대 행동을 방지합니다.\n        var maxQValue = Math.max(...currentQValues);\n        action = currentQValues.indexOf(maxQValue);\n    }\n\n    updateLastActions(action); // 최근 작업을 업데이트합니다.\n    return action;\n}\n```\n\n우리는 탐험(새로운 영역 찾기) 또는 활용(알려진 좋은 보상 선택)을 선택할 때 약간의 무작위성을 사용하지만, explorationRate의 값에 따라 어느 정도 제어되는 것을 알 수 있습니다.\n\n탐험하기로 결정하면, 무작위로 위/아래/왼쪽/오른쪽 움직임을 선택합니다 (하지만 최근 작업 중에서 선택하지 않도록 확인을 추가해야 했습니다. 이렇게 함으로써 에이전트가 말하자면, 예를 들어 2개의 타일 사이를 오가며 무한 루프에 갇히는 것을 막았습니다).\n\n활용하기로 결정하면, 우리의 Q-테이블이 가장 좋은 알려진 행동이 무엇인지 알려줍니다 (시간이 지날수록 더 나아지고 더 \"알려진\" 상태가 됩니다). 그런 다음 행동을 선택하고 움직이며, 간호사, 격자 상의 일반 공간 또는 목표 자체 - 맛있는 얼그레이 티를 만났는지 확인하는 등의 작업을 수행합니다.\n\n\n\n\n우리의 takeAction() 메서드에서는 구체적으로 '보상' 기능을 구현했습니다. 가능하다면 Picard를 이동하고 목표를 발견한 경우 긍정적인 보상을 제공하거나 장애물에 부딪힌 경우 약간 부정적인 보상(누적)을 제공합니다:\n\n```js\nfunction takeAction(position, action) {\n    var reward = -0.01;\n    var newPosition = { x: position.x, y: position.y };\n\n    // 새 위치가 유효한지 확인합니다(장애물이 아니며 그리드 범위 내에 있는지)\n    function isValidMove(newX, newY) {\n        if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize) {\n            return false; // 그리드 범위 초과\n        }\n        return !obstacles.some(obstacle => obstacle.x / tileSize === newX && obstacle.y / tileSize === newY);\n    }\n\n    // 동작에 따라 새 위치 결정\n    switch (action) {\n        case 0: // 위\n            if (isValidMove(position.x, position.y - 1)) newPosition.y -= 1;\n            break;\n        case 1: // 오른쪽\n            if (isValidMove(position.x + 1, position.y)) newPosition.x += 1;\n            break;\n        case 2: // 아래\n            if (isValidMove(position.x, position.y + 1)) newPosition.y += 1;\n            break;\n        case 3: // 왼쪽\n            if (isValidMove(position.x - 1, position.y)) newPosition.x -= 1;\n            break;\n    }\n\n    if (newPosition.x !== position.x || newPosition.y !== position.y) {\n        // 유효한 이동인 경우 에이전트 위치 업데이트\n        agentPosition = newPosition;\n\n        if (agentPosition.x === goalPosition.x && agentPosition.y === goalPosition.y) {\n            reward = 1; // 목표에 도달한 경우 보상\n        }\n    } else {\n        // 잘못된 이동(경계를 벗어나거나 장애물로 이동함)\n        reward -= 0.1;\n    }\n\n    return reward;\n}\n```\n\nPicard를 결정하고 이동한 후에는 q-테이블을 다음과 같이 업데이트해야 합니다:\n\n```js\nfunction updateQTable(position, action, reward) {\n    var nextState = agentPosition;\n    var maxQValueNextState = Math.max(...qTable[nextState.y][nextState.x]);\n    qTable[position.y][position.x][action] += learningRate * (reward + discountFactor * maxQValueNextState - qTable[position.y][position.x][action]);\n}\n```\n\n\n\n다음은 Q-테이블을 업데이트하는 데 사용되는 JavaScript 구현입니다:\n\nQ(state, action)←Q(state, action) + α×(reward+γ×maxaQ(nextState, a)−Q(state, action))\n\n간단히 말하면: 새 점수 = 이전 점수 + 학습 계수 × (최근 점수 + 미래 잠재력 - 이전 점수).\n\n행동을 선택하고 수행하며 Q-테이블을 업데이트하는 것 외에도, 업데이트 방법에서 수행하는 몇 가지 다른 작업이 있으며, 이는 에이전트가 탐험할지 또는 이용할지에 대한 가중치와 관련이 있습니다.\n\n\n\n먼저, 각 단계마다 탐사하는 양을 감소시켜 최대 보상 경로로 수렴할 수 있도록 천천히 줄입니다 (저희 감쇠율에 따라):\n\n```js\nexplorationRate = Math.max(explorationRate - explorationDecay, 0.01);\n```\n\n이에 추가하여, 에이전트가 '멈춰 있는' 것처럼 보일 때 임시로 결정을 탐사하는 가능성을 증가시키는 작은 조정을 업데이트 메서드에 추가해야 했습니다.\n\n```js\nif (samePositionCount > 3) {\n    explorationRate = Math.min(explorationRate + 0.1, 1.0);\n    samePositionCount = 0; // 카운터를 재설정합니다\n}\n```\n\n\n\n이전에는 에이전트가 어딘가에서 루프에 자주 걸렸었지만, 추가하면서 멈춰있다가 얼마 동안 같은 위치에 있으면 약간의 '후드'를 줍니다. 이 변경 사항은 일시적이며 에이전트가 다시 움직일 때까지만 유효합니다.\n\n게임은 피카드가 소중한 얼 그레이에 도착할 때마다 보상을 평가하며, 5번의 연속 시도에서 최대 보상에 수렴할 때 실험이 완료/이루어집니다. 이 시점에서 우리는 에이전트가 가능한 한 작업에 '적합하게' 되었다고 생각합니다.\n\n완성품? 정말 멋진 ('알아요, 알아요 - 이것은 매우 유치하지만, 여전히 재미 있겠죠!') '얼 그레이, HOT1' 게임을 만들었는데요, 아래 링크에서 확인해보세요:\n\nhttps://earlgreyhot.org/\n\n\n\n![Building a Q-table Reinforcement Learning Agent with Captain Picard](/assets/img/2024-05-14-BuildingaQ-tableReinforcementLearningAgentwithCaptainPicard_6.png)\n\n재밌게 즐기고, 매개변수를 조정해보세요. 에이전트가 완료할 때까지 시도 횟수를 최소화해보세요! 그리고 덤으로, 누군가에게 다양한 보상(긍정적이고 부정적인 것, 또는 새로 만들기?)을 조정할 수 있는 기능을 추가하여 그것이 에이전트의 성능에 미치는 영향을 사용자들이 볼 수 있도록 소스 코드를 업데이트하도록 초대합니다.\n\n이 글이 재밌게 보이셨기를 바라며 — 항상 트레키한 방식으로 Q-러닝을 통한 강화 학습 개념을 다룬 것에 흥미를 느끼셨으면 이 기사를 즐기셨다면 박수를 보내거나 댓글을 남겨주세요 — 다음에 또 만나요!","ogImage":{"url":"/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png","tag":["Tech"],"readingTime":12},{"title":"ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작","description":"","date":"2024-05-14 13:22","slug":"2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem","content":"\n\n# 아이디어의 시작\n\n모든 것은 간단한 필요성에서 시작되었습니다: 내 스크립트에서 함수로 관리되는 레이어의 시각적 표현이 포함된 코멘트를 작성하고 싶었습니다. 몇 가지 특수 문자(ASCII 문자)가 존재하여 상자의 변에는 직선, 모퉁이에는 각도, 교차점에는 십자가 있는 다이어그램을 만드는 데 복사하여 붙여넣을 수 있다는 것을 알고 있었습니다.\n\n![다이어그램](/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png)\n\n모든 이러한 문자들은 함께 작동하고 정렬하기 위해 설계되었습니다. 이러한 문자들은 상자 그리기 문자로 알려져 있습니다. 그러나 문자를 복사하여 붙여넣어 복잡한 다이어그램을 수동으로 만드는 것은 지루하고 실수할 여지가 많습니다.\n\n\n\n```js\n┌─┬┐  ╔═╦╗  ╓─╥╖  ╒═╤╕\n│ ││  ║ ║║  ║ ║║  │ ││\n├─┼┤  ╠═╬╣  ╟─╫╢  ╞═╪╡\n└─┴┘  ╚═╩╝  ╙─╨╜  ╘═╧╛\n┌───────────────────┐\n│  ╔═══╗ 일부 텍스트  │▒\n│  ╚═╦═╝ 상자 안에    │▒\n╞═╤══╩══╤═══════════╡▒\n│ ├──┬──┤           │▒\n│ └──┴──┘           │▒\n└───────────────────┘▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n```\n\n이 작업을 간단하게 처리할 수있는 도구의 잠재력을 깨달았을 때, 기존 솔루션을 검색했지만 제 요구 사항을 충족하는 것은 없었습니다. 우리가 \"프로그래머의 저주\"라고 부를 수있는 것에 격려되어, 제 즉각적인 문제를 수동으로 해결하지 않고 누구나 사용할 수있는 프로세스를 자동화하는 솔루션을 생성하기로 결정했습니다.\n\n## 비전 정의\n\n내 비전은 분명했습니다: 누구나 ASCII 상자를 그리고 클릭하고 드래그하여 코멘트를 추가 할 수있는 직관적이고 쉽게 접근할 수있는 웹 앱을 개발하는 것 — Adobe Illustrator와 같은 도구의 간단함과 강력함을 반영하는 것입니다.\n\n\n\n# 핵심 구축: ASCII 아트의 로제타 스톤\n\n이 도구(ASCII Box Editor)의 기초를 다지기 위해, 나는 디지털 캔버스 상에서 서로 다른 ASCII 문자들이 어떻게 결합되는지에 대한 도전에 직면했습니다. 예를 들어, 수직 선 위에 수평 선을 그리는 것은 단순히 겹치는 것이 아니라 교차점을 형성해야 합니다.\n이러한 과정에서 나는 \"로제타\"라는 시스템을 설계하기로 결심했습니다. 이 시스템은 서로 다른 타격과 문자가 어떻게 병합되는지를 정의하는 복잡한 배열 기반 객체입니다.\n이 아이디어는 각 문자를 함수에 의해 해석될 수 있는 표현으로 변환하는 것입니다. 각 문자마다 그 카디널 포인트에 경로의 존재에 대응하는 등가 배열을 얻게 됩니다.\n\n```js\n[ ╳, ╳, ╳, ╳ ]                         \n  │  │  │  │                           \n  └──┼──┼──┼──▶ 상단에 경로가 있나요?  \n     └──┼──┼──▶ 우측에 경로가 있나요?  \n        └──┼──▶ 하단에 경로가 있나요?  \n           └──▶ 좌측에 경로가 있나요?  \n\n왼쪽 상단 모서리 문자 '┌'의 예\n       ┌┄┄┄┄┄┄┄┄┄┄┄┄┐           \n       ┆            ▽           \n    ╔══╧══╗ '┌' = [ 0, 1, 1, 0 ]   > 0 = 없음\n    ║     ║            ▲  ▲  △     > 1 = 경로가 이 위치에 있음\n  ┌┄╢  ┏━╸╟────────────┘  │  ┆  \n  ┆ ║  ┃  ║               │  ┆  \n  ┆ ╚══╤══╝               │  ┆  \n  ┆    └──────────────────┘  ┆  \n  └┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┘  \n```\n\n이러한 논리를 기반으로, 각 문자에 대한 모든 등가 배열을 보관할 asciiBox_Rosetta 객체를 생성했으며, 문자('char') 표현에서 배열('code')로 변환하고 그 반대로 변환하는 두 가지 함수를 첨부했습니다.\n\n\n\n```js\n// ROSETTA: ASCII 문자를 배열 표현으로 매핑하기\nclass asciiBox_Rosetta {\n  constructor() {\n    this.rosetta = {\n      '─': [0, 1, 0, 1], // 수평선\n      '│': [1, 0, 1, 0], // 수직선\n      '┼': [1, 1, 1, 1], // 교차점\n      // 기타 등등...\n    };\n  }\n  // 문자와 코드 사이의 변환을 위한 메소드\n  getCharFromCode(code) {…}\n  getCodeFromChar(char) {…}\n}\n```\n\n로제타를 사용하면, 나는 이제 문자들 간 상호작용에 기반한 동적 문자 변환을 수행할 수 있는 간단한 중첩 문자 논리를 구성할 수 있었습니다. 이는 디지털 회로의 논리 연산을 모방하지만 텍스트 캔버스 상에서 이루어집니다.\n\n```js\n'─'와 '│' 사이의 조합 예제\n\n '─' + '│' = [0, 1, 0, 1] + [1, 0, 1, 0] = [1, 1, 1, 1] = '┼'   \n└┈┈┈┈┈┈┈┈┈┘ └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘ └┈┈┈┈┈┈┈┈┈┈┈┈┘ └┈┈┈┘  \n수평선      배열 표현          최종 배열       교차점\n& 수직선                                          \n```\n\n이 간단한 논리 알고리즘은 문자 간의 중첩을 효과적으로 처리하는 데 매우 효과적이었습니다. 이 알고리즘을 통해, 나는 그림을 그리기 위해 마우스 이벤트를 캡처하고, 굵은 글꼴, 점선, 이중 선 등의 스타일 변경 및 화살표와 같은 방향 표시용 끝 캡슐을 통합하는 것만으로도 가능했습니다.\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*tPD4T6_yVr6wBlKDj6RKGw.gif\" />\n\n# 기능 구현: 선 그리기를 넘어서\n\n정적 디자인으로부터 완전히 상호작용형 웹 애플리케이션으로의 여정은 다양한 사용자 도구를 관리하는 것을 포함하여 수많은 도전을 안겨주었습니다. 각 도구마다 고유한 특성과 동작이 있기 때문에 그것을 관리하는 것이 쉽지 않았습니다.\n\nASCII Box Editor의 핵심은 asciiBox_ToolManager인데, 이 동적 시스템은 사용자의 작업에 따라 도구를 전환할 수 있도록 설계되었습니다. 이 시스템은 부드러운 사용자 경험을 제공할 뿐만 아니라 코드베이스를 획기적으로 간소화하는 데 중요합니다.\n\n\n\n```js\n// 도구 관리자: 도구의 활성화와 사용을 관리합니다\nclass asciiBox_ToolManager {\n    constructor(db, styleContainer) {\n        this.currentTool = null;  // 현재 활성화된 도구\n        this.previousTool = null;  // 빠른 전환을 위해 이전에 사용한 도구\n        // 일련의 도구로 초기화\n        this.tools = {\n            \"직선 그리기\": new asciiBox_DrawLine(this),\n            \"상자 그리기\": new asciiBox_DrawBox(this),\n            \"지우개\": new asciiBox_Erase(this),\n            // 여기서 더 많은 도구를 초기화합니다...\n        };\n    }\n    // 사용자 선택에 따라 도구를 설정하는 함수\n    setTool(toolName) {\n        this.previousTool?.deactivate();  // 이전 도구 비활성화\n        this.currentTool = this.tools[toolName];\n        this.currentTool.activate();  // 새 도구 활성화\n    }\n}\n```\n\n전통적인 절차적 코드는 각 도구를 별도의 함수로 처리하거나 if-else 문의 일련의 문장으로 처리할 수 있었으며, 이는 코드가 비대하고 반복적이며 유지보수하기 어렵게 만들었습니다. 반면, 객체지향 접근 방식은 각 도구의 기능을 클래스 내부에 캡슐화합니다. 이로 인해 코드가 더 깨끗하고 디버깅하기 쉬워지면서 확장성도 향상됩니다. 새로운 도구를 추가하는 것은 새 클래스를 정의하고 도구 관리자에 추가하는 것만으로 간단해집니다.\n\n각 도구는 일반 asciiBox_Tool 클래스에서 상속을 받으며 활성화 및 비활성화와 같은 공통 동작을 정의하고 특정 동작은 각 도구의 필요에 맞게 하위 클래스에 재정의됩니다. 이 다형성은 asciiBox_ToolManager가 도구 세부 사항에 대해 무관하게 유지되면서 다양한 기능을 활성화할 수 있도록 합니다.\n\n```js\n// 일반 도구 클래스\nclass asciiBox_Tool {\n    constructor(name, manager) {\n        this.name = name;\n        this.manager = manager;\n        this.isActive = false;\n    }\n    activate() { this.isActive = true; }\n    deactivate() { this.isActive = false; }\n    onMouseDown(args) { /* 기본 마우스 다운 동작 */ }\n}\n\n// 특정 도구 생성\nclass asciiBox_Select extends asciiBox_Tool {\n    constructor(manager) {\n        super('선택', manager);\n        // 더 많은 초기화 변수\n    }\n    // 사용자 입력 이벤트 처리를 위한 함수 로직\n}\n```\n\n\n\n사용자 상호작용의 세부 사항을 주의 깊게 고려하여 필요한 모든 도구를 설정했습니다. 간단한 클릭부터 복잡한 드래그 앤 드롭 제스처까지 ASCII Box Editor가 모든 단계에서 직관적으로 유지될 수 있도록했습니다.\n이 유연한 아키텍처는 많은 시간을 절약했습니다. 앱이 발전함에 따라 asciiBox_ToolManager의 유연성으로 인해 새로운 도구와 스타일을 소개할 수 있었지만 이전 기능의 핵심 기능을 방해하지 않았습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*jJFHQSLocMxTWVT5nMofiA.gif)\n\n# 여정이 계속됩니다\n\n처음부터 비전은 간단한 필요성을 보편적인 해결책으로 변형하는 것이었습니다. ASCII Box Editor는 그 비전의 실행입니다. ASCII 코멘트를 생성하는 것을 간소화하면서도 정교한 디자인 도구의 간편함과 강력함을 유지합니다.\n\n\n\n위 설명에서 볼 수 있듯이, 때로는 \"프로그래머의 저주\"가 초기 도전을 벗어나 혁신적인 해결책을 이끌어낼 수 있습니다.\n\n어떻게 작동하는지 궁금하신가요? ASCII Box Editor를 한 번 시도해 보세요!\ntheokva.github.io/ascii-box-editor 👋\n\n![출력](/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_1.png)\n\n—Theo\n\n\n\n만약 이 기사가 마음에 드셨다면 👏 클랩(clap)을 부탁드려요. \n더 많은 이야기를 보시려면 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png"},"coverImage":"/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png","tag":["Tech"],"readingTime":6},{"title":"LWC에서 LMS를 통한 커뮤니케이션","description":"","date":"2024-05-14 13:20","slug":"2024-05-14-CommunicationThroughLMSinLWC","content":"\n\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png)\n\nSalesforce의 Lightning Message Service (LMS)는 돔 계층 구조 전체에서 Lightning Web Components (LWC) 간의 통신을 가능하게 하는 강력한 기능입니다. 이것은 요소가 직계 부모-자식 관계를 필요로하지 않고 서로 통신할 수 있도록 해주므로 복잡한 애플리케이션을 구축하는 유연한 도구입니다. 이 블로그에서는 LWC 간 통신을 위해 LMS를 사용하는 방법과 구현 예시를 살펴볼 것입니다.\n\n# Lightning Message Service란?\n\nLightning Message Service (LMS)는 Salesforce가 제공하는 통신 프레임워크로, Lightning 페이지의 다른 구성 요소와 Lightning Web Components (LWC) 간에 효과적인 통신을 가능하게 합니다.\n\n\n\n\n그것은 계층적 관계에 관계없이 컴포넌트 간에 통신할 수 있도록 해줘서 모듈식이고 연결된 애플리케이션을 쉽게 구축할 수 있습니다.\n\nLMS는 컴포넌트가 데이터를 포함하는 메시지를 게시하고, 다른 컴포넌트가 이러한 메시지를 구독하고 반응할 수 있는 방법을 제공합니다. 이러한 분리된 통신 접근 방식은 Lightning 애플리케이션의 유연성과 유지 보수성을 향상시킵니다.\n\n아래는 Lightning Message Service Flow 다이어그램입니다. Lightning Message Channels의 도움으로 다양한 컴포넌트 간의 통신을 보여줍니다.\n\n\n\n# 라이트닝 메시지 서비스(LMS) 이해하기:\n\nLMS는 컴포넌트가 메시지(이벤트)를 발행하고 구독하여 해당 메시지를 수신할 수 있는 pub-sub (publish-subscribe) 메시징 패턴을 제공합니다. 이 분리된 통신 메커니즘은 컴포넌트 간의 느슨한 결합을 촉진하여 재사용성과 유지 보수성을 향상시킵니다.\n\n라이트닝 메시지 서비스에는 두 가지 주요 개념이 있습니다: 발행자(Publishers)와 구독자(Subscribers).\n\n## 1. 발행자(Publisher):\n\n\n\n- Publisher 구성 요소는 특정 메시지 채널로 메시지를 보내는 역할을 합니다.\n- 이러한 메시지는 데이터를 전달하거나 비어 있을 수 있으며, 구독자는 이에 따라 반응할 수 있습니다.\n- Publisher 구성 요소를 생성할 때는 `@salesforce/messageChannel` 모듈에서 `publish()` 함수를 import해야 합니다.\n- 이 함수를 사용하면 Lightning Message Channel을 통해 메시지를 보낼 수 있습니다.\n\n## 2. Subscriber:\n\n- Subscriber 구성 요소는 특정 메시지 채널을 주시적으로 듣습니다.\n- 이 채널에서 메시지가 발행될 때마다 해당 메시지에 응답할 수 있는 모든 구독된 구성 요소가 반응할 수 있습니다.\n- 중요한 점은 Subscriber가 Publisher에 대한 구체적인 세부 정보를 알 필요가 없어서 유연하고 느슨하게 결합된 시스템을 유지하는 데 도움이 된다는 것입니다.\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_2.png)\n\n\n\n## 주의 !\n\n# LWC에서 라이트닝 메시지 서비스(LMS)를 통해 컴포넌트가 어떻게 통신하는지\n\n## 메시지 채널 메타데이터 정의:\n\n컴포넌트 간에 통신 채널을 설정하려면 먼저 Salesforce 조직에서 메시지 채널 메타데이터를 정의해야합니다. 아래 단계를 따르세요:\n\n\n\n- Salesforce 프로젝트 구조의 `force-app/main/default` 하위에 \"messageChannels\"라는 폴더를 생성해주세요.\n\n2. 이 폴더 안에 \"messageChannelName.messageChannel-meta.xml\" 형식의 XML 파일을 만들어주세요. 여기서 \"messageChannelName\"을 원하는 채널 이름으로 바꿔주세요.\n\n3. 아래 코드를 참고하여 .xml 파일에 `lightning message field`를 정의해주세요:\n\n\nsampleMessageChannel.messageChannel-meta.xml\n\n\n\n\nmd\n```js\n<!--?xml version=\"1.0\" encoding=\"UTF-8\"?-->\n<lightningmessagechannel xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n    <masterlabel>SampleMessageChannel</masterlabel>\n    <isexposed>true</isexposed>\n    <description>This is a sample Lightning Message Channel.</description>\n     \n    <!-- Define message payload fields -->\n    <lightningmessagefields>\n        <fieldname>recordId</fieldname>\n        <description>This is the record Id that changed</description>\n    </lightningmessagefields>\n    <lightningmessagefields>\n        <fieldname>recordData</fieldname>\n        <description>The current data representing the record that changed</description>\n    </lightningmessagefields>\n</lightningmessagechannel>\n```\n\n## 설명:\n\n- `isExposed` 태그는 컴포넌트를 사용할 수 있게 만드는 데 사용됩니다.\n- `lightningMessageFields` 태그를 사용하여 필드를 정의하는데 특정 정보를 전달할 수 있습니다. 예를 들어 `recordId`를 정의할 수 있습니다.\n- `description` 태그를 사용하여 Lightning 메시지 채널에 대한 설명을 추가하면 이 메시지 채널을 만드는 목표에 대해 설명할 수 있습니다.\n- `.messageChannel-meta.xml` 파일이 작성되면 Salesforce org에 배포하세요.\n\n## 메시지 서비스 기능 가져오기:\n\n\n\n\n번역 : \n\n당신의 Lightning 웹 컴포넌트에서 필요한 메시지 서비스 기능을 다음과 같이 가져오세요:\n\n```js\nimport { publish, subscribe, unsubscribe, APPLICATION_SCOPE, MessageContext } from 'lightning/messageService';\nimport msgService from '@salesforce/messageChannel/messageChannelName__c';\n```\n\n## 메시지 서비스 범위 정의:\n\n`@wire 어댑터`를 사용하여 메시지 서비스의 범위를 정의할 수 있습니다.\n라이트닝 웹 컴포넌트에서는 `@wire 어댑터`로만 스코핑이 가능합니다.\n\n\n\n예시:\n\n```js\n@wire(MessageContext)\nmessageContext;\n```\n\n# 메시지 채널 발행:\n\n메시지 채널에 메시지를 발행하려면 라이트닝 메시지 서비스의 `publish()` 메서드를 사용하십시오. 이 메서드는 메시지 컨텍스트, 메시지 채널, 메시지 페이로드를 매개변수로 받습니다.\n\n\n\n```js\nconst messagePayload = {\n    recordId: '0012y00000L5R6jAAF',\n    recordData: { /* 레코드를 나타내는 데이터 */ }\n};\npublish(this.messageContext, msgService, messagePayload);\n```\n\n`publish()` 메소드는 3개의 파라미터를 받습니다 :\n\n- 메시지 컨텍스트 (객체 타입)\n- 메시지 채널 (객체 타입)\n- 메시지 페이로드 (메시지 페이로드는 JSON 객체입니다)\n\nmessageContext : `MessageContext` 객체는 Lightning 메시지 서비스를 사용하는 Lightning 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\nmessageChannel: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 `@salesforce/messageChannel`과 같은 scoped 모듈을 사용하세요. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하세요.\n\nmessage: 가입자에게 발행된 메시지를 포함하는 직렬화 가능한 JSON 객체입니다. 메시지에는 함수나 심볼을 포함할 수 없습니다.\n\n# 메시지 채널 구독:\n\n\n\n특정 메시지 채널의 메시지를 구독하려면 `subscribe()` 메서드를 사용하세요. 받은 메시지를 처리하기 위한 리스너 함수를 제공해주세요.\n\n```js\nthis.subscription = subscribe(\n    this.messageContext,\n    msgService,\n    (message) => this.handleMessage(message)\n);\n```\n\n`subscribe()` 메서드는 4개의 매개변수를 받습니다:\n\n- 메시지 컨텍스트 (객체 형식)\n- 메시지 채널 (객체 형식)\n- 리스너 (함수 형식)\n- 구독자 옵션 (객체 형식)\n\n\n\n메시지 컨텍스트: `MessageContext` 객체는 라이트닝 메시지 서비스를 사용하는 라이트닝 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터를 통해 가져오거나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\n메시지 채널: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 scoped 모듈인 `@salesforce/messageChannel`을 사용하십시오. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하십시오.\n\n리스너: 발행된 메시지를 처리하는 함수입니다.\n\n\n\nsubscriberOptions: (선택 사항) 이 객체는 `'scope: APPLICATION_SCOPE'`로 설정되었을 때, 애플리케이션 전반에서 메시지 채널에서 메시지를 수신할 수 있는 능력을 지정합니다. `lightning/messageService`에서 `APPLICATION_SCOPE`를 가져와야 합니다.\n\n# 메시지 채널 구독 취소:\n\n메시지 채널 구독을 취소하려면 `unsubscribe()` 메서드를 사용하고, `subscribe()` 함수에 의해 반환된 구독 객체를 제공하면 됩니다.\n\n```js\nunsubscribe(this.subscription);\n```\n\n\n\n# Salesforce Lightning Message Service를 언제 사용해야 할까요?\n\n라이트닝 메시지 서비스는 Visualforce 페이지, Aura 및 LWC 간에 정보를 교환하거나 전달하는 방법입니다. LMS는 특히 구성 요소가 구성 요소 계층구조에서 직접적으로 관련되어 있지 않지만 서로 상호 작용해야 하는 시나리오에서 유용합니다. 다음은 LMS를 사용할 수 있는 몇 가지 상황입니다:\n\n- 부모-자식 구성 요소 간 통신: 부모 구성 요소와 여러 자식 구성 요소가 있고, 이들 간에 데이터를 전달하거나 작업을 트리거하려는 경우입니다.\n- 동료 구성 요소 간 통신: 페이지에 동료 구성 요소가 있고, 이들의 상태를 동기화하거나 데이터를 공유해야 하는 경우입니다.\n- 크로스 도메인 통신: 관리되는 패키지와 사용자 지정 구성 요소와 같이 서로 다른 네임스페이스에 거주하는 구성 요소 간에 통신해야 하는 경우입니다.\n- 동적 구성 요소 간 통신: 구성 요소가 런타임에서 동적으로 생성되거나 파괴되고, 이들 사이에 통신 채널을 설정할 유연한 방법이 필요한 경우입니다.\n\n다음은 Lightning Message Service의 사용 예시 시나리오입니다:\n\n\n\n당신이 Lightning 페이지에서 두 개의 컴포넌트를 가지고 있는 상황을 상상해봅시다: 계정 목록을 표시하는 부모 컴포넌트와 선택된 계정의 세부 정보를 보여주는 자식 컴포넌트가 있습니다. 사용자가 부모 컴포넌트에서 계정을 선택할 때, 자식 컴포넌트가 동적으로 업데이트되어 선택된 계정의 세부 정보를 표시하고 싶습니다.\n\n# Salesforce Lightning Message Service의 제한 사항\n\n- LMS는 Salesforce 모바일 앱, AppExchange, Lightning Out 및 Lightning Communities와 통합할 수 있는 능력이 없습니다.\n- LMS는 iframe에서 작동하지 않습니다.\n- LMS는 Salesforce 클래식에서 작동하지 않습니다.\n- Salesforce UI에서 직접 라이트닝 메시지 채널을 생성하는 것을 지원하지 않습니다.\n\n# 결론:\n\n\n\n라이트닝 메시지 서비스(Lightning Message Service)는 Salesforce의 라이트닝 웹 컴포넌트(Lightning Web Components) 간 효율적인 통신을 가능케 하는 강력한 도구입니다. pub-sub 패턴을 구현함으로써 컴포넌트들은 분리된 방식으로 통신할 수 있으며, 이는 라이트닝 애플리케이션의 유연성과 확장성을 향상시킵니다. 올바른 사용법과 이해를 통해 LMS는 Salesforce에서 복잡하고 동적인 사용자 인터페이스를 원활하게 구축할 수 있도록 도와줍니다.\n\n\"더 많은 흥미로운 LWC 주제를 기대해주시고 Salesforce 개발 전문가가 되기 위해 라이트닝 웹 컴포넌트의 세계를 계속 탐험해보세요.\"\n\n즐거운 LWC 코딩하세요!\n\n더 자세한 내용은 아래 링크를 방문해주세요:","ogImage":{"url":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png","tag":["Tech"],"readingTime":7},{"title":"네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여","description":"","date":"2024-05-14 13:18","slug":"2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG","content":"\n\n![지도 시각화](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png)\n\nGeoJSON 데이터셋과 JavaScript d3.js를 사용한 SVG 시각화의 결합은 지리적 데이터(지역, 국가, 주, 성, 도시 등)에 대한 풍부하고 상호 작용적인 시각화를 만드는 데 매우 가치가 있습니다. 이 기사에서는 저의 거주 지역인 네덜란드에 이 강력한 결합을 적용할 것입니다. 네덜란드의 12개 성에 대한 데이터가 포함된 GeoJSON 파일을 찾아서 d3.js를 사용하여 간단한 웹 애플리케이션에서 국가와 그 성을 시각화할 것입니다. 그런 다음, 저가 CTO로서 역할을 맡고 있는 Conclusion 회사들의 사무실 위치를 나타내는 마커를 추가할 것입니다.\n\n최근 몇 개의 기사에서는 세계 데이터셋에서 특정 속성에 따라 국가에 색상을 할당한 테마별 세계지도를 사용한 데이터 시각화에 대해 d3.js 라이브러리의 사용법을 소개했습니다. 이를 위해 SVG와 함께 사용하는 방법을 소개했는데, GeoJSON 데이터 형식은 국가 및 주에서 도시, 호수 및 산림까지 다양한 지리적 정의가 가능합니다. 어떻게 지도를 다른 속성 간에 쉽게 전환하고 상호 작용성을 추가할 수 있는지(국가를 클릭하여 선택하고 지도의 회전 또는 동서 방향 이동 변경)를 보여 주었습니다. 네 번째 기사에서는 프로그래밍 방식과 사용자 시작으로 확대(그리고 다시 축소)하는 두 가지 다른 방법에 대해 논의했습니다.\n\n이 기사에서는 이전 기사에서 만든 것을 적용하여 네덜란드 관련 데이터를 다룰 것입니다.\n\n\n\n# 네덜란드 시각화\n\nd3.js를 사용하여 세계의 일부를 시각화하는 첫 단계는 분명히 지리 정보를 제공하는 GeoJSON 파일을 찾는 것입니다. 조금 찾아보니 Cartomap GitHub 저장소를 발견했는데, 다양한 지역 시스템에 대한 지리 정보를 제공하는 유용한 GeoJSON 파일이 많이 있습니다. 재판소, 소방서, 노동시장, 관광, 보건, 자치구, 도시지역, 청소년, 상공회의소, 농업, 공공시설, 경찰, 지방, 소속기관, 동네, 안전 지역 등을 위한 파일들이 많이 있습니다. 대부분의 파일은 여러 해에 대해 사용 가능합니다.\n\n저는 wgs84/provincie_2023.geojson 파일을 활용하기로 결정했습니다. 이 파일은 12개의 지방에 대한 경계 점의 지리 좌표를 포함하고 있습니다. 각 지방의 이름도 포함되어 있습니다. 이것만 있으면 지도를 그릴 수 있습니다.\n\n![네덜란드 지역의 공식 위치 시각화 지도](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_1.png)\n\n\n\n저는 세계를 시각화하는 기사에서 대부분 했던 작업을 가져왔어요. \"country/countries(국가/국가들)\"에 대한 모든 참조를 \"area/areas(지역/지역들)\"로 변경했어요. 여기서 적절한 초기 축척 요소(네덜란드는 작은 국가이기 때문에 대규모 축척로 했을 때 거의 보이지 않는다)와 적절한 투영 회전을 찾았어요. d3.geoEquirectangular 투영 대신에 이제 d3.geoMercator를 사용하고 있어요(지구의 모양이 투영에 방해가 되지 않는 더 작은 국가에 더 적합해요). 국가의 형태에 따라 mapHeight(너비에 비해 상대적으로 높이를 증가했어요).\n\nGeoJSON 기능에서 제공되는 제목(마우스 호버 텍스트) 및 식별에 관한 내용을 제공하는 상수를 정의했어요:\n\n이러한 변경 사항은 redrawMap() 함수에서 나타납니다:\n\n\n\n![그림1](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_3.png)\n\n아래는 영역을 선택하거나 해제하는 논리에 대한 코드 예시입니다:\n\n![그림2](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_4.png)\n\n현재 index.html 파일의 상태입니다. GitHub Pages에서 데모를 확인해보세요.\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*GUemI5VHeyQPqQiATAoNZQ.gif\" />\n\n# 지도상의 위치 표시\n\n이것은 좋은 첫걸음입니다: 네덜란드와 그 주요 지역 구획의 시각화입니다.\n\n한 발 더 나아가서 지도에 위치를 추가해봐요. 도시를 대표하는 지리적 지점들이나, Conlusion 사무실 위치 등을 예로 들 수 있습니다.\n\n\n\n이 GeoJSON 파일에는 대도시 지역이 포함되어 있습니다. 이 지역은 다각형을 통해 다시 정의됩니다. 이들은 지방에 그려질 수 있으며, 해당 국가의 주요 도시를 나타낼 수 있습니다.\n\n도시 지역을 포함하려면 필요한 변경 사항은 다음과 같습니다:\n\n- 도시 지역을 위한 스타일 클래스를 정의합니다.\n- City GeoJSON을 로드하고 이를 지방 세부 정보와 병합합니다.\n- 각각 지방과 도시에 대한 생성된 모양에 적절한 스타일 클래스를 할당합니다.\n\n클래스 도시:\n\n\n\n<img src=\"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_5.png\" />\n\n도시 GeoJSON을 로딩하고 병합:\n\n<img src=\"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_6.png\" />\n\nSVG 모양을 렌더링할 때 적절한 스타일 클래스 할당하기:\n\n\n\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_7.png)\n\n생성된 지도는 다음과 같이 보입니다:\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_8.png)\n\n모든 도시 지역이 강조되어 있습니다. 각각에는 호버 텍스트에 해당하는 이름이 있습니다. 그리고 도시 지역도 마찬가지로 선택할 수 있습니다:\n\n\n\n\n<img src=\"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_9.png\" />\n\n이 시점의 index.html 파일입니다. 그리고 라이브 데모입니다.\n\n이제 도시를 다각형 영역으로 그리는 대신, 각 도시를 원으로 나타내는 것이 더 나을 것 같습니다. 이것은 Polygon 대신 GeoJSON Point에서 파생됩니다.\n\n이를 달성하기 위해 해야 할 일은 도시 GeoJSON의 모든 요소를 처리하고 각각을 만들어 집합니다. 그런 다음 치에서 파생된 geojsonData에 추가하는 것입니다.\n\n\n\n\n![사무실 위치 지도 시각화](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_10.png)\n\n생성된 지도:\n\n![사무실 위치 지도 시각화](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_11.png)\n\n네덜란드 지리에 익숙하신 분들은 이 도시 원들이 실제 도시가 위치한 곳에 모두 있는 것이 아니라는 점을 알 수 있을 것입니다. 분명히, 도시 영역을 경계 지정하는 직사각형의 중심이 항상 실제 도시 중심과 같은 곳에 있는 것이 아닙니다.\n\n\n\n\n점(도시)의 시각화 크기와 색상을 조절할 수 있어요. 가장 간단한 방법은 원의 반지름을 사용자 정의하여 경로 생성기를 정의하는 것입니다: d3.geoPath().pointRadius(custom-circle-radius);\n\nGeoJSON 기능을 위한 SVG 객체를 만들 때 사용되는 경로 생성기 함수를 수정하여 Points에 대한 사용자 지정 함수를 호출할 수 있어요.\n\n사용자 정의 함수를 구현한 예시 중 하나는 간단한 집 모양(사실 직사각형과 삼각형입니다)을 그리는 경로를 만드는 함수입니다:\n\n\n\n![Map Visualization](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_13.png)\n\n지도 상에 각 도시의 위치에 간단한 집 모양이 표시되었습니다:\n\n![Map Update](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_14.png)\n\n이 시점에서의 index.html 파일 상태 및 실시간 데모 페이지입니다.\n\n\n\n# 컨클루전 사무실 위치 추가\n\n2023년 5월 1일 현재, 저는 IT 기업 그룹인 컨클루전의 CTO입니다. 컨클루전은 각기 다른 전문성, 문화, 역사(및 미래), 제안 및 고객을 갖춘 30개 이상의 자율적인 회사들로 구성되어 있습니다. 이러한 회사들은 내부적으로 협력하여 더 스마트하고 효율적으로 일을 처리하고, 노하우와 경험을 공유하는 좋은 실천 방법을 기반으로 한 활동, 스포츠 이벤트, 문화 활동 및 자선 행사에서 더 즐거운 시간을 보내며, 동료들이 자매 회사의 다른 역할에서 경력을 쌓을 수 있도록 가능하게 하며, 외부적으로는 고객에게 상호 일치하는 다양한 서비스를 제공하기 위해 협력합니다.\n\n네덜란드 내에서 컨클루전은 12개 이상의 장소에 사무실을 두고 있습니다. 대부분은 개별 회사용이며 일부는 여러 회사를 수용하고 있습니다. 대부분의 동료들은 사무실에 출근하고 싶은 경우 모든 사무실을 이용할 수 있습니다.\n\n모든 컨클루전 사무실 위치를 시각화하기 위해 네덜란드의 지도를 사용할 예정입니다.\n\n\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_15.png)\n\n결론 사무실의 위치를 나타내는 새로운 GeoJSON 파일을 추가할 거에요. 이 파일은 저 혼자 만들어야 해요. 이 위치들은 Point 유형의 특징이며 방금 도시들에 사용한 집 아이콘으로 시각화되어야 해요.\n\n사무실을 위한 새로운 CSS 스타일을 정의했어요.\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_16.png)\n\n\n\n새로운 파일이 로드되고 사무실 위치에 대한 데이터가 geojsonData 세트에 포함되었습니다\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_17.png)\n\n기능이 사무실 위치를 설명하는 경우 작은 집 아이콘을 그릴 사용자 정의 기능이 호출됩니다:\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_18.png)\n\n\n\n다음과 같은 지도가 생성됩니다:\n\n<img src=\"/assets/img/2024-05-14-네덜란드의사무소위치시각화-GeoJSON, D3, SVG_19.png\" />\n\n실시간 데모에서 직접 이 결과를 확인할 수 있습니다. index.html의 현재 상태도 확인할 수 있습니다.\n\n다음 단계로는 오피스를 클릭하면 해당 위치와 그 안에 위치한 회사에 대한 정보를 보여주는 팝업 창을 구현할 수 있습니다 (필요한 정보는 이미 GeoJSON 파일에 포함되어 있습니다).\n\n\n\n# 결론\n\n이 글에서는 GeoJSON 데이터를 네덜란드의 맥락에서 시각화할 수 있다는 것을 보여드렸어요. 전 세계 지도에 대한 모든 코드를 재사용하여 네덜란드의 지방 및 도시 데이터가 포함된 GeoJSON 파일을 손쉽게 추가하고 시각화할 수 있습니다 (매우 조정된 스케일 요인을 사용). 그리고 커스텀 포인트 표현을 소개했어요 - 결론 생태계의 사무실 위치를 보여주기 위해 (네덜란드에 있습니다.; 독일, 벨기에, 포르투갈, 스페인, 남아프리카에도 위치가 있어요. 혹시 다음 글에서 이를 추가할지도 몰라요).\n\n# 자료\n\n이 글에 대한 코드가 포함된 GitHub 저장소, 새로운 GeoJSON 파일을 포함하고 있어요 - 결론 사무실 위치를 나타내기 위해 제가 직접 만들어야 했던 파일이에요.\n\n\n\n내 이전 기사들을 통해 세계지도 데이터 시각화에 대해 소개하겠습니다:\n\n1. 나라 데이터 시각화를 위한 대화형 세계지도 생성하기 - https://medium.com/@lucasjellema/create-interactive-world-map-to-visualize-country-data-baa5b242bfbb - d3, SVG 및 JavaScript를 사용한 세계지도 데이터 시각화 소개.\n\n2. 세계지도 시각화를 활용한 데이터로 세계를 소개하기 - https://medium.com/@lucasjellema/presenting-the-world-in-data-using-world-map-visualization-d3-kaggle-world-data-set-7c16ca207fb0 - 첫 번째 기사에서 데이터 시각화에 대한 간단한 접근 방식과 Kaggle의 풍부한 데이터 세트를 결합하여 세계의 모든 국가에 대한 교육, 건강, 경제, 인구 통계, 기후 등 많은 흥미로운 세부 정보를 제공합니다.\n\n3. 세계지도 내 대화형 데이터 시각화 - 확대, 이동, 범례 - https://medium.com/@lucasjellema/interactive-data-visualization-in-world-map-translate-select-legend-popup-4d28261110df - 세계지도에 상호 작용을 추가하는 것에 대해 자세히 살펴보겠습니다. 특히: 지도의 회전을 변경, 나라 선택(클릭으로), 나라 세부 정보 팝업 창 표시 및 범례 - 색상 스케일 (히트맵 색상을 숫자 값에 매핑) 표시하기.\n\n\n\n4. World Map Data Visualization with d3.js, GeoJSON and SVG - Zooming, Panning and Dragging\n- 더 자세한 내용은 [여기](https://medium.com/@lucasjellema/world-map-data-visualization-with-d3-js-geojson-and-svg-zooming-and-panning-and-dragging-194fb16dec9a)를 확인해보세요!  \n- 월드맵에 확대/축소, 이동 및 드래그 기능을 사용자 및 프로그램으로 구현했습니다.\n- 원본 게시물은 2024년 1월 2일에 [여기](https://technology.amis.nl)에서 확인하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png"},"coverImage":"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png","tag":["Tech"],"readingTime":8},{"title":"대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요","description":"","date":"2024-05-14 13:16","slug":"2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays","content":"\n\n## 프로그래밍\n\n![이미지](/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png)\n\n대학이나 대학교에 다니는 것이 프로그래밍에 도움이 되는 이유를 정리해 보았어요.\n\n1. 대학에 다니면 전문가로 성장할 수 있어요. 직업에 상관없이 공부를 하면 뚜렷한 차이가 있어요. 대학은 교육을 제공하고 그 기반이 되는 것으로 각자 자아를 세워나가게 해줘요. 니든, 버핏, 또는 빌 게이츠처럼 천재가 아닌 이상, 대학은 무궁무진한 장점을 줄 거예요.\n\n\n\n2. 요즘에는 온라인으로 모든 것을 배울 수 있어요. Coursera나 Udemy와 같은 무료 또는 믿을 수 없을 만큼 저렴한 강좌를 제공하는 플랫폼이 많이 있어요. 어떤 대학들은 수업을 녹화해서 유튜브에 무료로 올리기도 해요.\n\n문제는 여전히 자격 증명과 학위를 높이 평가하는 사회에서 살고 있다는 거예요. 그래서 대학을 가지 않은 사람이 일자리를 구하는 데 훨씬 더 어려움을 겪을 확률이 매우 높아요. 좋은 프로그래머가 되려면 반드시 대학에 다녀야 하는 것은 아니지만, 다녀도 안 하지 않는 게 무의미한 건 아니에요.\n\n3. 대학의 주요 기능은 많은 주제에 대한 비교적 기본적인 개요를 제공하는 것이에요. 유용하긴 하지만 스스로 계속 공부해야 해요. 스스로 공부하거나 대학에서 배우는 차이는 대학이 당신이 도움이 되지 않을 것 같아서 무시하거나 지루하다고 생각하던 주제를 봐야 한다는 점이에요. 또한 고려해야 할 내용이라고 전혀 모르던 주제까지 볼 수도 있어요. 대학은 또한 당신에게 (컨퍼런스, 강좌, 인턴쉽과 같은) 문을 여는데, 이를 통해 당신의 시야를 넓힐 수 있게 해줄 거에요.\n\n4. 대학은 좋은 프로그래머를 보장해 줄 수준이 아니에요. 프로그래밍에 전념하지 않는 가득 찬 강의가 많이 있어서 소중한 시간을 낭비하게 될 수도 있어요. 게다가, 이 수업은 스스로 알고 있거나 모르는지 알려줘야 하는 학생들을 대상으로 같은 내용을 가르치기 때문에, 많은 대학들이 특정 언어의 여러 레벨을 제공하지 않아요. 하지만 당신이 지식의 표면을 긁어 보는 데는 도움이 될 거에요.\n\n\n\n5. 보통 프로그래머들이 더 나아지고 있다고 생각해요. 왜냐하면 그들은 더 좋은 기반으로 시작하기 때문이에요. 이 직업에서는 매일 무언가가 발명되고, 많은 해를 경험을 통해 배우는 것은 처음부터 그 가치가 무엇이며 막다른 길에 뉴런을 낭비하지 않는 것과는 다릅니다.\n\n6. 대학교는 말하자면, 어떻게 배우는지를 가르쳐줍니다. 자원을 찾아내고 어디에서 찾을 수 있는지를 아는 것이죠. 대학교가 당신을 좋은 프로그래머로 만든다고 생각하지 않아요. IDE(코드를 작성하는 환경)과 처음으로 대면했을 때, 색깔에 놀랐어요. 첫 디버깅을 했을 때, 브레이크포인트를 설정할 수 있다는 것을 보고 놀랐어요.\n\n아직도 세상에는 직업 세계를 접하지 않은 공룡 교수님들이 있는 대학교가 있어요. 그들은 실제로 어떻게 하는지 알지 못해요. 오늘날은 어떤 IDE나 버전 관리 도구, 모든 친구들에게도 참을 수 없어요.\n\n7. 대학교에서는 배우는 법을 배웁니다. 미래의 프로그래머로, 당신은 스스로 학습하는 습관을 길러야 합니다. 때로는 강제적인 속도로 학습해야 할 때도 있죠.\n\n\n\n프로그래밍 스킬의 90%를 스스로 얻는다는 것을 이해한다면, 대학 외부에서 공부하거나 동료 학생들과 협력하면서 얻게 될 것이다.\n\n그래서, 네, 대학은 당신을 더 나은 프로그래머로 만들어줄 것입니다. 교과목들이 당신에게 가르치는 것만으로 충분히 숙련된 프로그래머로 성장할 수 있다고 기대한다면, 그렇지 않습니다. 대학은 당신을 더 나은 프로그래머로 만들어주지 않을 것입니다.\n\n훈련을 통해 많은 계획이 오랜 시간 동안 세심하게 고안되고 개선되어온 것을 알 수 있습니다. 이는 과거의 프로그래머들에 의해 잘 계획된 구조와 체계의 유형과 문제 분류를 교육합니다. 좋은 코드를 만드는 것은 창의력의 문제이지만, 그 창의력이 더 복잡한 구조와 체계에서 작동하며, 과거에 다른 사람들이 잘 계획한 것들을 이용한다면, 엄청난 힘이 됩니다.\n\n나는 코드를 작성하는 데에 특별히 전념하지는 않지만, 주로 계산 소프트웨어를 사용하여 무척 뛰어난 방식으로 \"프로그래밍\"하는 라인들을 사용합니다. 물론, 대학에서 가르쳐준 것이 매우 유용했기 때문에 처음부터 쓰는 것이 아니라 모든 것을 더 효율적으로 만드는 순차적인 구조를 사용합니다.\n\n\n\n좋은 프로그래머가 되는 데에는 개인적인 기술이 필요하지만, 수십 년 동안 다른 사람들이 개발한 구조를 활용하여 자신의 재능을 향상시키는 것은 명백한 이점이 있어요!\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 이 포스트를 나가기 전에:\n\n- 반드시 체리와 작가를 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 컨텐츠를 처리해야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io 에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png"},"coverImage":"/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png","tag":["Tech"],"readingTime":3},{"title":"Fetch API CORS 및 no-cors에 대한 궁극의 가이드","description":"","date":"2024-05-14 13:16","slug":"2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors","content":"\n\n\n<img src=\"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png\" />\n\n웹 애플리케이션에서 제3자 API 또는 서버에서 데이터를 가져와야 하는 경우가 있나요? 그렇다면, 요청한 데이터에 액세스하는 데 방해가 되는 Cross-Origin Resource Sharing (CORS) 오류를 만날 수도 있습니다.\n\n이 블로그 포스트에서는 Fetch API에서 CORS 및 No-CORS 모드를 사용하여 이러한 제약을 극복하고 외부 소스에서 데이터를 성공적으로 가져오는 방법을 살펴볼 것입니다.\n\n먼저, CORS가 무엇이며 왜 중요한지 이해해 봅시다.\n\n\n\n\n그러나 웹 애플리케이션에서 제3자 API 또는 서버로 요청을 보내야 할 때는 장애가 될 수도 있습니다.\n\n![image](/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_1.png)\n\nFetch API는 웹 애플리케이션에서 HTTP 요청을 보내는 방법을 제공합니다. Fetch를 사용하면 fetch() 함수의 mode 옵션을 사용하여 요청의 모드를 지정할 수 있습니다.\n\nmode 옵션은 `cors`, `no-cors`, `same-origin`, 또는 `navigate` 중 하나로 설정할 수 있습니다.\n\n\n\n`cors` 모드에서는 브라우저가 요청에 Origin 헤더를 포함하며, 서버가 허용 여부를 나타내는 Access-Control-Allow-Origin 헤더로 응답할 것을 기대합니다.\n\n서버가 적절한 헤더로 응답하면, 브라우저는 요청을 계속 진행하도록 허용하고 응답을 웹 페이지에 제공합니다. 이 모드는 제3자 API나 서버에 요청을 보낼 때 유용합니다.\n\n```js\nfetch('https://example.com/api/data', {\n  mode: 'cors',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    key1: 'value1',\n    key2: 'value2'\n  })\n})\n.then(response => response.json())\n.then(data => console.log(data))\n.catch(error => console.error(error));\n```\n\n`no-cors` 모드에서는 브라우저가 요청에 Origin 헤더를 포함하지 않으며, 서버의 응답이 불투명하게 처리되어 JavaScript 코드로 액세스할 수 없습니다. 이 모드는 서버로부터의 응답이 필요하지 않은 경우, 예를 들어 제3자 애널리틱스 서비스에 요청을 보낼 때 사용됩니다.\n\n\n\n이제 Fetch API에서 CORS 및 No-CORS 모드를 사용하는 방법을 이해했으므로, 언제 사용해야 하는지에 대해 이야기해보겠습니다.","ogImage":{"url":"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png"},"coverImage":"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png","tag":["Tech"],"readingTime":2},{"title":"Vue 3 올바른 방법으로 기본 입력 컴포넌트 구현하기","description":"","date":"2024-05-14 13:14","slug":"2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay","content":"\n\n대규모 애플리케이션을 만드는 것은 아주 큰 탑을 짓는 것과 같을 수 있어요. 하지만 그 탑들이 작고 간단한 건물 블록들로 이루어져 있는 것처럼 말이죠. 이 기본 부품 중 하나가 입력 상자인데요. 기본적으로 보일 수도 있지만, 복잡한 기능을 갖추게 하면 정말 복잡해질 수 있어요.\n\n함께 기본 입력 컴포넌트를 구현해봐요. 이것은 어떤 애플리케이션을 만들 때 중요한 작은 단계일 거예요.\n\n## 네이밍\n\n명명하는 것은 어렵죠. 다행히 Vue 스타일 가이드는 기본 컴포넌트의 이름을 Base App 또는 V 접두사와 함께 사용하는 것을 강하게 권장하고 있어요.\n\n\n\nAppInput.vue 이름은 우리의 사용 사례에 딱 맞는 것 같아요.\n\n## 초기화\n\n먼저 일관성을 위해 CSS 초기화가 필요해요.\n\n```js\nnpm install normalize.css\n```\n\n\n\n```js\n/* main.css */\n@import 'normalize.css'\n```\n\n## Basic Styles\n\n기본 스타일부터 시작해봅시다. 우선 입력란에 대한 기본 구현부터 해보겠습니다. 지금은 모든 입력란이 동일한 모양과 느낌을 가지도록 하는 것이 목표입니다.\n\n```js\n<template>\n  <input\n    type=\"text\"\n    class=\"input\"\n  />\n</template>\n\n<style lang=\"scss\" scoped>\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: #f5f8fa;\n  border: 1px solid #cccccc;\n  padding: 8px 20px;\n  outline: 0;\n  border-radius: 8px;\n}\n</style>\n```\n\n\n\n사용법이 간단합니다.\n\n```js\n<script setup lang=\"ts\">\nimport AppInput from '@/components/AppInput.vue'\n</script>\n\n<template>\n  <main>\n    <h1>기본 입력란 데모</h1>\n    <AppInput placeholder=\"이름을 입력해주세요\" />\n  </main>\n</template>\n```\n\n플레이스홀더에 fallthrough 속성을 사용 중임을 유의하세요. 이것은 컴포넌트의 루트 요소로 자동 전달됩니다.\n\n![이미지](/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_0.png)\n\n\n\n## 검색 변형\n\n이제 더 둥근 UI를 가진 검색을 위해 다른 변형을 만들어보겠습니다. 이를 위해 pill이라는 프롭을 사용할 것입니다.\n\n```js\n<script lang=\"ts\" setup>\ndefineProps({\n  pill: {\n    type: Boolean,\n  },\n});\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    class=\"input\"\n    :class=\"{\n      pill,\n    }\"\n  />\n</template>\n\n<style lang=\"scss\" scoped>\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: #f5f8fa;\n  border: 1px solid #cccccc;\n  padding: 8px 20px;\n  outline: 0;\n  border-radius: 8px;\n\n  &.pill {\n    border-radius: 32px;\n  }\n}\n</style>\n```\n\n```js\n<AppInput pill placeholder=\"검색\" />\n```\n\n\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n| The only interesting thing is | `:class=\"'pill'\"` | It will apply the class pill if the prop variable with the same name is truthy. |\n|------------------------------|-------------------|--------------------------------------------------|\n| Remove Hardcoded CSS Values  | Before moving on let’s tackle the hardcoded values in our styles. As our application grows larger we should have our pallete, typography, and spacings declared in a centralized place for everyone to use. This can be done with CSS variables or SCSS variables. We will use SCSS this time. |\n\n\n\n다음 내용을 포함한 _variables.scss 파일을 만들어주세요.\n\n```scss\n$color-light: #f5f8fa;\n$color-border: #cccccc;\n\n@function spacing($factor: 1) {\n  @return $factor * 4px;\n}\n\n$border-radius-input: spacing(2);\n$border-radius-pill: spacing(8);\n```\n\n스페이싱 믹스인은 4픽셀 그리드를 강제하는 방법으로, 시각적 리듬을 가진 쾌적한 UI를 만드는 데 도움이 됩니다.\n\n이제 공통 변수를 사용하여 스타일을 업데이트할 수 있습니다.\n\n\n\n```js\n...\n\n<style lang=\"scss\" scoped>\n@import \"@/assets/styles/_variables.scss\";\n\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: $color-light;\n  border: 1px solid $color-border;\n  padding: spacing(2) spacing(5);\n  outline: 0;\n  border-radius: $border-radius-input;\n  &.pill {\n    border-radius: $border-radius-pill;\n  }\n}\n</style>\n```\n\n반면에 모든 컴포넌트에 import하는 것을 피하기 위해 vite.config.ts 파일을 다음과 같이 업데이트할 수도 있습니다:\n\n```js\nexport default defineConfig({\n  ...\n  css: {\n    preprocessorOptions: {\n      scss: {\n        additionalData: `\n          @import \"@/assets/styles/_variables.scss\";\n        `\n      }\n    }\n  }\n  ...\n})\n```\n\n## 레이블\n\n\n\n플레이스홀더를 레이블로 사용하는 것은 접근성이 떨어지고 전체적으로 사용자 경험이 좋지 않습니다. 이 문제를 해결하기 위해 플로팅 레이블을 구현해 봅시다. 이를 위해 우선 입력란을 래퍼로 감싸고 약간 정리해야 합니다.\n\n```js\n<script lang=\"ts\" setup>\ndefineOptions({\n  inheritAttrs: false,\n});\ndefineProps({\n  pill: {\n    type: Boolean,\n  },\n});\n</script>\n\n<template>\n  <div class=\"input-wrapper\">\n    <input\n      type=\"text\"\n      class=\"input\"\n      v-bind=\"$attrs\"\n      :class=\"{\n        'has-label': $slots.label,\n        pill,\n      }\"\n    />\n    <div class=\"label\">\n      <slot name=\"label\" />\n    </div>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.input-wrapper {\n  position: relative;\n}\n\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: $color-light;\n  border: 1px solid $color-border;\n  padding: spacing(2) spacing(5);\n  outline: 0;\n  border-radius: $border-radius-input;\n  &.pill {\n    border-radius: $border-radius-pill;\n  }\n  &.has-label {\n    padding-top: spacing(6);\n    &::placeholder {\n      color: transparent;\n    }\n  }\n}\n\n.label {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  padding: spacing(4) spacing(5);\n  pointer-events: none;\n  transform-origin: 0 0;\n  transition: opacity 0.1s ease-in-out, transform 0.1s ease-in-out;\n}\n\n.input:focus ~ .label,\n.input:not(:placeholder-shown) ~ .label {\n  opacity: 0.65;\n  transform: scale(0.85) translateY(-0.5rem) translateX(0.15rem);\n}\n</style>\r\n```\n\n이제 입력란이 더 이상 루트 요소가 아니기 때문에 inheritAttrs 옵션을 false로 설정하고 수동으로 $attrs를 바인딩해야 합니다.\n\n실제 레이블은 동일한 이름의 슬롯을 사용하여 전달됩니다. 이 레이블은 절대 위치에 있으며 상태 간에 전환에 사용되는 트랜지션을 가지고 있습니다.\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*l91i6d4b3MVHxv1QMUP5tA.gif\" />\n\n## 접두사 및 접미사\n\n입력란은 일반적으로 통화, 아이콘 또는 동작이 있는 다른 컴포넌트와 같은 추가 정보와 관련이 있습니다. 기본 컴포넌트는 슬롯을 사용하여 나타나기 전이나 나타난 후에 사용자 정의 콘텐츠를 지원해야 합니다.\n\n```js\n<script lang=\"ts\" setup>\ndefineOptions({\n  inheritAttrs: false,\n});\ndefineProps({\n  pill: {\n    type: Boolean,\n  },\n});\n</script>\n\n<template>\n  <div class=\"input-wrapper\">\n    <input\n      type=\"text\"\n      class=\"input\"\n      v-bind=\"$attrs\"\n      :class=\"{\n        'has-prefix': $slots.prefix,\n        'has-suffix': $slots.suffix,\n        'has-label': $slots.label,\n        pill,\n      }\"\n    />\n    <div class=\"label\">\n      <slot name=\"label\" />\n    </div>\n    <div class=\"prefix\">\n      <slot name=\"prefix\" />\n    </div>\n    <div class=\"suffix\">\n      <slot name=\"suffix\" />\n    </div>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.input-wrapper {\n  position: relative;\n  + .input-wrapper {\n    margin-top: spacing(4);\n  }\n}\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: $color-light;\n  border: 1px solid $color-border;\n  padding: spacing(2) spacing(5);\n  outline: 0;\n  border-radius: $border-radius-input;\n  &.pill {\n    border-radius: $border-radius-pill;\n  }\n  &.has-prefix {\n    padding-left: spacing(12);\n  }\n  &.has-suffix {\n    padding-right: spacing(12);\n  }\n  &.has-label {\n    padding-top: spacing(6);\n    &::placeholder {\n      color: transparent;\n    }\n  }\n}\n\n.label {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  padding: spacing(4) spacing(5);\n  pointer-events: none;\n  transform-origin: 0 0;\n  transition: opacity 0.1s ease-in-out, transform 0.1s ease-in-out;\n}\n.input.has-prefix ~ .label {\n  left: spacing(7);\n}\n\n.input:focus ~ .label,\n.input:not(:placeholder-shown) ~ .label {\n  opacity: 0.65;\n  transform: scale(0.85) translateY(-0.5rem) translateX(0.15rem);\n}\n\n.prefix, .suffix {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.prefix {\n  left: spacing(4);\n}\n.suffix {\n  right: spacing(4);\n}\n</style>\n```\n\n\n\n이것은 prefix와 suffix라는 두 가지 추가 슬롯이 있는 레이블과 동일한 기술을 사용합니다.\n\n## 변경 사항을 듣기\n\n반응하는 것이 빠진 유일한 부분입니다. V-모델은 바로 이를 위해 Vue에서 제공됩니다.\n\n우리의 데이터를 보유하는 반응형 객체인 userInfo가 있다고 가정해 봅시다. v-model=\"userInfo.name\"을 추가해야 합니다.\n\n\n\n```js\r\n<script setup lang=\"ts\">\r\nimport { reactive } from \"vue\";\r\n\r\nconst userInfo = reactive({\r\n  name: \"Fotis\",\r\n  ...\r\n});\r\n</script>\r\n\r\n<template>\r\n  <main>\r\n    <h1>Base Input Demo</h1>\r\n\r\n    <AppInput v-model=\"userInfo.name\" placeholder=\"이름\">\r\n      <template #label> 이름 </template>\r\n    </AppInput>\r\n  </main>\r\n</template>\r\n```\r\n\r\nv-model은\r\n\r\n```js\r\n :value=\"modelValue\"\r\n @input=\"emit('update:modelValue', $event.target.value)\"\r\n```\r\n\r\n의 단축 버전입니다.\r\n\r\n이를 반영하여 AppInput을 업데이트해보겠습니다.\n\n\n\n```js\r\n<script lang=\"ts\" setup>\ndefineOptions({\n  inheritAttrs: false,\n});\n\ndefineProps({\n  modelValue: {\n    type: String\n  },\n  pill: {\n    type: Boolean,\n  },\n});\n\nconst emit = defineEmits(['update:modelValue'] )\nconst updateValue = (e: Event) => {\n  emit('update:modelValue', (e.target as HTMLInputElement).value)\n};\n</script>\n\n<template>\n  <div class=\"input-wrapper\">\n    <input\n      type=\"text\"\n      class=\"input\"\n      v-bind=\"$attrs\"\n      :value=\"modelValue\"\n      @input=\"updateValue\"\n      :class=\"{\n        'has-prefix': $slots.prefix,\n        'has-suffix': $slots.suffix,\n        'has-label': $slots.label,\n        pill,\n      }\"\n    />\n    ...\n  </div>\n</template>\r\n```\n\n위의 변경 사항은 다음과 같습니다:\n\n- modelValue prop을 추가했습니다.\n- update:modelValue 이벤트를 선언했습니다.\n- input 요소의 value와 input 속성에 둘 다 바인딩됐습니다.\n\n이제 input 값을 변경하면 반응성 있는 userInfo 객체에 반영될 것입니다.\n\n\n\n## 모든 것을 모아보기\n\n마지막으로, 간단한 폼을 만들어 입력 사용법을 보여드릴게요.\n\n```js\n<script setup lang=\"ts\">\nimport AppInput from \"@/components/AppInput.vue\";\nimport AppIcon from \"@/components/AppIcon.vue\";\nimport { reactive } from \"vue\";\n\nconst userInfo = reactive({\n  name: \"Fotis\",\n  bio:\n    \"Lorem ipsum dolor sit amet consectetur adipisicing elit. Expedita deleniti laboriosam eligendi. Incidunt dolores dicta veritatis. Quaerat ad, magnam esse, illo atque delectus minus, nihil adipisci tempora nobis iusto. Excepturi?\",\n  location: \"Barcelona\",\n  website: \"fadamakis.com\",\n});\n\nfunction submitForm() {\n  alert('Info submitted: ' + JSON.stringify(userInfo))\n}\n</script>\n\n<template>\n  <main>\n    <h1>Base Input Demo</h1>\n\n    <AppInput v-model=\"userInfo.name\" placeholder=\"이름\">\n      <template #label> 이름 </template>\n    </AppInput>\n\n    <AppInput v-model=\"userInfo.bio\" placeholder=\"소개\">\n      <template #label> 소개 </template>\n    </AppInput>\n\n    <AppInput v-model=\"userInfo.location\" placeholder=\"위치\">\n      <template #label> 위치 </template>\n      <template #prefix>\n        <AppIcon icon=\"pin\" />\n      </template>\n    </AppInput>\n\n    <AppInput v-model=\"userInfo.website\" placeholder=\"웹사이트\">\n      <template #label> 웹사이트 </template>\n      <template #prefix>\n        <AppIcon icon=\"link\" />\n      </template>\n    </AppInput>\n\n    <button @click=\"submitForm\">\n      제출하기 <AppIcon size=\"2x\" icon=\"arrow-right-circle\" />\n    </button>\n\n    <hr />\n\n    <AppInput pill name=\"search\" placeholder=\"검색\">\n      <template #prefix>\n        <AppIcon icon=\"search\" />\n      </template>\n    </AppInput>\n\n    <AppInput placeholder=\"메시지를 보내주세요...\">\n      <template #suffix>\n        <AppIcon size=\"2x\" icon=\"arrow-right-circle\" />\n      </template>\n    </AppInput>\n\n  </main>\n</template>\n```\n\n결과는 다음과 같습니다:\n\n\n\n<img src=\"/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_1.png\" />\n\n실제로 테스트해보고 GitHub에서 소스 코드를 확인할 수 있어요.\n\n구현에 대한 피드백, 아이디어 또는 다른 의견이 있다면 매우 환영합니다.\n\n<img src=\"/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_2.png\" />\n\n\n\nⓘ 이 글은 Base Component 구현 시리즈의 일부입니다:\n\n- AppInput.vue (여기 있습니다!)\n- AppModal.vue\n- AppIcon.vue\n\n추가로 하고 싶은 내용이 있으시면 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_0.png"},"coverImage":"/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_0.png","tag":["Tech"],"readingTime":11},{"title":"앵귤러의 조화 인젝터와 디렉티브의 힘","description":"","date":"2024-05-14 13:13","slug":"2024-05-14-HarmonizingAngularThePowerofInjectorsDirectives","content":"\n\n앵귤러는 여러 해 동안 크게 발전해 왔어요. 불과 10년 만에 v2부터 v17로 왔지요! 이 기간 동안 앵귤러에 많은 변화가 있었지만, 핵심 개념과 철학은 동일하게 유지되었어요. 우리는 이 중요한 앵귤러 컴포넌트 두 가지를 사용하여 강력한 것을 만들어보려고 해요.\n\n## 샘플 애플리케이션\n\n예시로 파일 업로드 컴포넌트를 만들어볼 거예요. 이 컴포넌트는 사용자가 로컬 기기에서 파일을 애플리케이션으로 업로드할 수 있도록 하는 기능을 맡을 거에요. 업로드되는 파일의 최대 크기를 제한하고, 이를 사용자 정의할 수 있어야 해요. 이는 Input 데코레이터 패턴을 사용하여 쉽게 구현할 수 있어요.\n\n이 구현은 업로드된 파일 크기가 허용된 크기보다 큰지 확인하고, 그에 적절하게 경고를 보여줍니다.\n\n\n\n보시는 대로 파일 업로드 한도를 컴포넌트의 입력으로 가져오고 있습니다. 이 컴포넌트의 모든 소비자는 요구 사항에 따라 이를 입력으로 전달할 수 있습니다.\n\n이 방법은 작동하지만 조금 번거로울 수 있습니다. 컴포넌트를 사용할 때마다 파일 크기 제한을 전달해야 합니다. 실제로 이러한 제한은 대부분 응용 프로그램/라이브러리 또는 있는 모듈에 따라 달라집니다. 예를 들어, 모든 고객을 대상으로 하는 파일 업로드는 5MB로 제한되어야 하지만 모든 관리자 구성 요소는 최대 10MB까지 업로드할 수 있어야 합니다. 관리자 구성 요소는 원칙적으로 항상 10MB로 제한되어야 한다는 것을 알고 있지만, 관리자 페이지에서 컴포넌트를 사용할 때마다 이 데이터를 입력으로 전달해야합니다.\n\n## Injector 패턴\n\n여기서 Angular 인젝터가 유용하게 사용됩니다. Injector 패턴을 사용하여이 컴포넌트를 다시 작성해 봅시다.\n\n\n\n우리는 InjectionToken을 만들고 기본값으로 7MB를 제공했습니다. 그런 다음 새로운 inject 기능 덕분에 유틸 메서드를 사용하여 이 토큰을 컴포넌트에서 소비합니다.\n\n기본적으로 이 컴포넌트를 사용하는 모든 곳에서 업로드 제한으로 7MB가 설정될 것입니다.\n\n이전에 언급했듯이, 모든 관리자 컴포넌트는 10MB 제한이어야 합니다. 이제 단순히 관리자 모듈(또는 상위/라우트 수준 컴포넌트)로 이동할 수 있습니다.\n\n고객 모듈의 경우,\n\n\n\n요약하자면 우리는 Angular injectors를 사용하여 응용 프로그램에서 데이터 공급자를 효과적으로 사용자 정의했습니다. 이것은 더 결정론적이며 데이터가 더 높은 수준에서 제공되기 때문에 오류 발생 가능성이 줄어듭니다.\n\n하지만, 같은 구성 요소에서 앱 파일 업로드의 두 인스턴스를 각각 다른 파일 크기 제한을 가지고 싶다면 어떻게 해야 할까요? Angular에서 주입기 트리의 가장 낮은 수준은 컴포넌트 데코레이터이며 여기서 주입기를 제공할 수 있는 곳입니다. 템플릿 수준에서 주입기를 제공하는 것은 불가능합니다.\n\n## 디렉티브로 승리!\n\nAngular에서 디렉티브는 템플릿의 요소에 새로운 동작을 추가하거나 기존 동작을 수정할 수 있는 클래스입니다. 디렉티브는 템플릿이 없는 컴포넌트로 생각할 수 있습니다. 즉, 우리는 디렉티브에 여러 가지를 제공할 수 있고 디렉티브가 템플릿의 일부에 적용될 수 있기 때문에 템플릿 수준에서 데이터를 제공하는 데 사용할 수 있습니다!\n\n\n\n본문을 요약하면 템플릿에 데이터 제공자로서 지시문을 사용할 수 있다는 것을 알 수 있습니다. 이제 이를 사용하여 동일한 컴포넌트에 여러 인젝터를 제공하여 인젝터를 통해 동일한 컴포넌트에서 두 가지 다른 파일 크기를 가질 수 있습니다.\n\n우리는 각각 10MB와 2MB용 데이터 제공자로 두 개의 지시문을 생성할 것입니다.\n\n이제 간단히 컴포넌트에 이를 적용해 봅시다.\n\n## 결론\n\n\n\nAngular에서는 지시문을 데이터 제공자로 사용할 수 있어요. 지시문과 인젝터를 결합하여 모듈식이고 유연한 강력한 컴포넌트 디자인 패턴을 만들 수 있어요.\n\n샘플 애플리케이션은 여기에서 확인할 수 있어요 - https://github.com/BharathRavi27/angular-injector-decorator\n\nAngular에서 더 많은 디자인 패턴을 배우고 싶나요? 아래의 이전 기사를 확인해보세요!","ogImage":{"url":"/assets/img/2024-05-14-HarmonizingAngularThePowerofInjectorsDirectives_0.png"},"coverImage":"/assets/img/2024-05-14-HarmonizingAngularThePowerofInjectorsDirectives_0.png","tag":["Tech"],"readingTime":3}],"page":"113","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}