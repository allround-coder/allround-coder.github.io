{"pageProps":{"posts":[{"title":"30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법","description":"","date":"2024-06-22 02:01","slug":"2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode","content":"\n\n\n![image](/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png)\n\n# 1. Why\n\n## Why Control Concurrency?\n\nControlling concurrency is essential for effectively managing system resources, preventing overload, improving performance and response time, ensuring system stability, and maintaining a good user experience. By limiting the number of concurrent requests, the system can continue to operate normally even under high load conditions.\n\n\n<div class=\"content-ad\"></div>\n\n# 2. 무엇\n\n## 2.1 동시성이란 무엇인가요?\n\n동시성은 시스템 또는 프로그램이 동시에 여러 작업이나 요청을 처리할 수 있는 능력을 의미합니다. 일반적으로 이는 여러 프로세스나 스레드가 동시에 작업을 실행하여 시스템의 처리량과 응답 속도를 높이는 것을 포함합니다. 동시 환경에서 여러 작업이 번갈아가며 실행되어 리소스 활용이 더 효율적으로 이루어집니다. 그러나 리소스 충돌, 성능 저하, 데드락과 데이터 불일치 등의 문제를 방지하기 위해 효과적인 관리와 제어가 필요합니다.\n\n## 2.2 일반적인 동시 작업\n\n<div class=\"content-ad\"></div>\n\n웹 개발에서 일반적인 동시 작업이 많이 있습니다. 프론트엔드, 백엔드, 데이터베이스 작업 및 시스템 수준의 작업 처리 등을 다룹니다. 웹 개발에서 일반적인 동시 작업의 몇 가지 예는 다음과 같습니다:\n\n- 여러 동시 인터페이스 요청: 프론트엔드 개발에서는 데이터를 가져오기 위해 동시에 여러 API 엔드포인트에 요청을 보내는 것이 일반적입니다.\n- 동시에 여러 요청 처리: 웹 서버는 동시에 여러 클라이언트 요청을 처리합니다.\n- 병렬로 작업 실행: 예를 들어 Node.js의 비동기 기능을 사용하여 여러 작업을 병렬로 실행하는 것입니다.\n\n# 3. 방법\n\n## 3.1 Promise.all\n\n<div class=\"content-ad\"></div>\n\n프론트엔드에서 동시 요청을 보낼 때 Promise.all을 많이 사용합니다. 예를 들어:\n\n```js\n// 비동기 작업을 시뮬레이션하는 함수\nfunction asyncOperation(duration) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`총 ${duration}밀리초 소요`);\n    }, duration);\n  });\n}\n\n// 모든 비동기 작업이 완료될 때까지 기다리기 위해 Promise.all 사용\nfunction simulatePromiseAll() {\n  const promise1 = asyncOperation(1000);\n  const promise2 = asyncOperation(2000);\n  const promise3 = asyncOperation(3000);\n\n  Promise.all([promise1, promise2, promise3])\n    .then((results) => {\n      console.log('모든 작업이 완료되었습니다:');\n      results.forEach(result => console.log(result));\n    })\n    .catch((error) => {\n      console.error('오류 발생:', error);\n    });\n}\n\n// Promise.all 함수 시뮬레이션 실행\nsimulatePromiseAll();\r\n```\n\n그러나 Promise.all은 동시성을 제어할 수 없거나 정확히는 이 능력을 가지고 있지 않습니다. 따라서 각 asyncOperation을 수정하여 Promise.all이 Promise를 실행할 때 동시성 제어를 지원하도록 몇 가지 수정을 해야 합니다.\n\n## 3.2 구현 방법\n\n<div class=\"content-ad\"></div>\n\n기본 아이디어는 100개의 동시 작업이 있고 최대 동시성을 10으로 설정한다면 다음 단계를 따릅니다:\n\n1. 먼저 10개의 슬롯을 설정합니다.\n2. 처음 10개의 동시 작업이 슬롯을 차지하고 실행됩니다.\n3. 어떤 슬롯이 먼저 작업을 완료했는지 모니터링한 후, 나머지 작업에서 다른 작업을 가져와 슬롯을 채웁니다.\n4. 모든 동시 작업이 완료될 때까지 단계 3을 반복합니다.\n\n```js\n// 우리가 구현해야 하는 함수\nconst simulateLimit = () => {\n  // 코드 작성 \n}\n\n// 비동기 작업을 시뮬레이션하는 함수\nfunction asyncOperation(duration) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`Completed in ${duration} ms`);\n    }, duration);\n  });\n}\n\n// 동시성을 제한하기 위해 simulateLimit을 사용합니다\nfunction simulateControlledPromiseAll() {\n  const limit = simulateLimit(10);\n\n  const tasks = [\n    limit(() => asyncOperation(1000)),\n    limit(() => asyncOperation(2000)),\n    limit(() => asyncOperation(3000)),\n    limit(() => asyncOperation(1500)),\n    limit(() => asyncOperation(2500)),\n    limit(() => asyncOperation(3500)),\n    // 여기에 더 많은 작업을 추가하세요\n    // ...\n  ];\n\n  Promise.all(tasks)\n    .then((results) => {\n      console.log('모든 작업이 완료되었습니다:');\n      results.forEach(result => console.log(result));\n    })\n    .catch((error) => {\n      console.error('에러가 발생했습니다:', error);\n    });\n}\n\nsimulateControlledPromiseAll();\r\n```\n\n3.3 30줄의 코드로 simulateLimit를 구현하는 방법\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 바꿔주세요.\n\n<div class=\"content-ad\"></div>\n\n반환된 함수 내부에서는 실제 작업 함수 fn을 래핑하는 작업 함수를 만듭니다. task가 호출되면 activeCount를 증가시키고 작업 함수 fn을 실행합니다. 작업이 완료되면 성공 또는 실패 여부에 상관없이 다음 함수가 호출됩니다.\n\n```js\nconst task = () => {\n  activeCount++;\n\n  fn(...args).then(\n    (value) => {\n      resolve(value);\n      next();\n    },\n    (error) => {\n      reject(error);\n      next();\n    }\n  );\n};\n```\n\n현재 작업이 완료된 후 next 함수가 호출됩니다. activeCount를 감소시키고 대기 중인 작업이 있고 동시성 제한이 아직 초과되지 않았다면 대기열에서 다음 작업을 가져와 실행합니다.\n\n```js\nconst next = () => {\n  activeCount--;\n  if (queue.length > 0 && activeCount < concurrency) {\n    const nextTask = queue.shift();\n    nextTask();\n  }\n};\n```\n\n<div class=\"content-ad\"></div>\n\n반환된 함수 내부에서 현재 활성 작업 수 activeCount가 동시성 제한(concurrency)보다 작은지 확인합니다. 작업 수가 모자라면 해당 작업을 즉시 실행하고, 그렇지 않다면 해당 작업을 대기열에 추가합니다.\n\n```js\nif (activeCount < concurrency) {\n  task();\n} else {\n  queue.push(task);\n}\n```\n\n전체 코드 구현은 아래와 같습니다:\n\n```js\nfunction simulateLimit(concurrency) {\n  const queue = [];\n  let activeCount = 0;\n\n  return function (fn, ...args) {\n    return new Promise((resolve, reject) => {\n      const task = () => {\n        activeCount++;\n        fn(...args).then(\n          (value) => {\n            resolve(value);\n            next();\n          },\n          (error) => {\n            reject(error);\n            next();\n          }\n        );\n      };\n\n      const next = () => {\n        activeCount--;\n        if (queue.length > 0 && activeCount < concurrency) {\n          const nextTask = queue.shift();\n          nextTask();\n        }\n      };\n\n      if (activeCount < concurrency) {\n        task();\n      } else {\n        queue.push(task);\n      }\n    });\n  };\n}\n```\n\n<div class=\"content-ad\"></div>\n\n실제로 이것은 유명한 라이브러리인 p-limit의 소스 코드입니다. 더 완벽한 사용법과 정제된 코드를 보려면 npm에서 p-limit을 참조해주세요. 배워갔나요?\n\n# 간단하고 쉬운 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우하기 ️👏️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서 만나기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 만나보기","ogImage":{"url":"/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png","tag":["Tech"],"readingTime":6},{"title":"파이썬에서 Boolean 연산자, 정말 우리가 생각하는 것과 다를까","description":"","date":"2024-06-22 02:00","slug":"2024-06-22-BooleanOperatorsinPythonArentWhatYouThink","content":"\n\n\n![Boolean Operators in Python](/assets/img/2024-06-22-BooleanOperatorsinPythonArentWhatYouThink_0.png)\n\n파이썬 프로그래머로서 나름 꽤 괜찮은 실력을 가지고 있다고 생각해요. 과거에 이 언어를 광범위하게 사용해 온 경험이 있고, 일반적으로 가장 편안하게 사용할 수 있는 언어라고 느껴지죠.\n\n하지만 편안한 영역 안에서도 가끔씩 익숙하지 않은 \"어?\"란 순간을 만나곤 해요. 최근에 저도 이런 순간을 겪었는데, 그것은 어딜 봐도 상상할 수 없는 곳에서 일어난 거였어요: Boolean 연산자들입니다.\n\n제가 보기에는 그 순간까지 True와 False, \"abc\"와 \"\", None 또는 0과 같은 표현식들이 모두 False로 평가될 것이라고 생각했어요. 왜냐하면 파이썬은 False, None, 빈 문자열, 모든 종류의 숫자 0, 그리고 다른 값들을 거짓 값으로 해석하기 때문이라고 생각했거든요.\n\n\n<div class=\"content-ad\"></div>\n\n그래서 이게 왜 일어날 수 있는지 생각해봐도 되지 않을까요? 결국, 우리는 계속해서 if 문을 사용해온 만큼 그것들이 결코 실망시켜 준 적이 없습니다.\n\n```js\nif 1 and 0:\n    print(\"이 문구는 절대 출력 안 됩니다...\")\nif 1 or 0:\n    print(\"하지만 이건 볼 수 있을 겁니다!\")\n```\n\n명백하죠, 1 and 0은 False에 해당하며 1 or 0은 True에 해당합니다, 맞나요?\n\n하지만 여기서 한 가지 주목할 점이 있습니다: Python은 특정한 비-부울 값들(예: 1 또는 \"\")을 부울 문맥(즉, 부울 연산자와 함께 사용되었을 때)에서 True 또는 False로 해석하더라도 해당 문맥의 반환 값을 결정하는 데 아무 영향도 미치지 않습니다. 다시 말해, val = True and 1은 어떤 결과를 얻게 될까요?\n\n<div class=\"content-ad\"></div>\n\n불리언 연산은 마지막으로 평가된 인수의 값을 반환한다는 것을 알게 되었습니다. and의 경우에는 non-true (또는의 경우에는 true) 값이 발견되자마자 표현식이 중단됩니다. 그렇지 않은 경우, 모든 인수의 참값을 확인해야 합니다.\n\n따라서 위 표현식의 경우, 1이 마지막으로 평가된 인수이며, val은 결과적으로 1의 값을 받게 됩니다.\n\n여기 몇 가지 더 예제가 있습니다:\n\n```js\nval = False and True # val = False\nval = \"abc\" and \"\" # val = \"\"\nval = \"\" or \"abc\" # val = \"abc\"\nval = None or 0 # val = 0\n```\n\n<div class=\"content-ad\"></div>\n\n# 왜 이겢 유용한가요?\n\n이를 알면 예를 들어 이러한 동작을 활용하여 대입 중에 간결한 null 확인을 수행할 수 있습니다.\n\n대안은 명시적으로 person이 None인지 확인해야 합니다:\n\n```js\nage = person.age if person else None\n```\n\n<div class=\"content-ad\"></div>\n\n# Python에는 특이하지 않아요\n\n사실, Python이 이와 같은 방식으로 동작하는 유일한 프로그래밍 언어는 아닙니다. 일부 Reddit 사용자들이 언급했듯이, 특히 JavaScript는 비슷하게 동작하며 선택적 체이닝 연산자 (?.)를 제공하여 한 단계 더 나아갑니다.\n\n만약 우리의 Person 클래스를 JavaScript로 옮겼다고 가정하면, 이 연산자를 사용하여 다음과 같이 수행할 수 있습니다:\n\n```js\nperson = new Person(18)\nage = person?.age // age = 18\nperson = undefined\nage = person?.age // age = undefined\nname = person?.name ?? \"John Doe\" // name = \"John Doe\"\n```\n\n<div class=\"content-ad\"></div>\n\n또한, ??를 사용하여 후속 값들을 지정할 수 있습니다.\n\n참고: 루트 개체(우리 예시에서는 person)가 None(Python)이나 undefined/null(JavaScript)이 될 수 있지만 반드시 선언되어 있어야 합니다.\n\n# 결론\n\n이 작은 정보가 유용했으면 좋겠습니다. 생각을 공유해 주시고 궁금한 점이 있으면 언제든지 물어보세요.\n\n<div class=\"content-ad\"></div>\n\n# 자료\n\n- 불리언 연산 | 파이썬 문서\n- 단락 평가 | 위키백과\n- 파이썬의 불리언 연산자는 불리언을 반환하지 않음 | 레딧\n- 선택 연쇄 (?.) | MDN 웹 문서","ogImage":{"url":"/assets/img/2024-06-22-BooleanOperatorsinPythonArentWhatYouThink_0.png"},"coverImage":"/assets/img/2024-06-22-BooleanOperatorsinPythonArentWhatYouThink_0.png","tag":["Tech"],"readingTime":3},{"title":"Formik과 Yup 라이브러리로 React 폼 유효성 검사를 간편하게 하는 방법","description":"","date":"2024-06-22 01:59","slug":"2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries","content":"\n\n가끔 React 애플리케이션에서 유효성 검사를 구현하는 것은 꽤 짜증날 수 있어요. 최근 이 분야를 탐험해본 결과, Formik과 Yup이라는 두 라이브러리를 발견했어요.\n\n**Formik**: Formik은 상태를 관리하는 데 도움이 되는 오픈 소스 라이브러리에요 (이렇게 생각해보세요: 필드 내용을 수정할 때, 필드 값이 자동으로 업데이트됩니다) 그리고 폼 제출을 처리합니다.\n\n**Yup**: Yup은 검사를 효율적으로 간단하게 만드는 또 다른 오픈 소스 라이브러리에요.\n\n유효성을 갖춘 어떤 형식으로든 폼을 만들 때, 최소한의 코드를 사용하여 이것을 달성하는 것은 다른 방법에 비해 불가능하다고 느낄 수 있어요. 이러한 라이브러리를 사용하는 목표는 기존 솔루션을 활용하는 것에요. 누군가 이미 작업을 완료했다면, 왜 우리는 처음부터 시작해야 할까요? 이 도구들을 사용해서 프로세스를 더 간단하고 정확하게 만들어봐요.\n\n<div class=\"content-ad\"></div>\n\n위에 나온 사용자 작성 코드를 통해 회원 가입 페이지에 대해 설명해 드리겠습니다:\n\nFormik 태그는 모든 코드를 감싸고 그 안의 각 필드 상태를 관리합니다. initialValues는 모든 필드의 기본값을 설정합니다. validationSchema은 Yup을 사용하여 각 필드를 유효성 검사합니다. 요구 사항에 따라 로직을 작성하는 스키마를 정의합니다. handleSubmit 함수는 폼이 제출될 때 트리거됩니다. isSubmitting 속성은 폼에 문제가 있거나 필드가 제대로 입력되지 않았을 때 버튼을 비활성화하는 데 도움을 줍니다. setSubmitting 함수는 제출 버튼이 활성화되거나 비활성화되는지 제어하는 상태를 변경하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries_0.png)\n\n참고: 오픈 소스를 활용하고, 그들의 신뢰성을 확인하고 적용하세요.\n","ogImage":{"url":"/assets/img/2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries_0.png"},"coverImage":"/assets/img/2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries_0.png","tag":["Tech"],"readingTime":2},{"title":"adamant-api v240 출시 v200 이후 달라진 점은","description":"","date":"2024-06-22 01:56","slug":"2024-06-22-adamant-apiv240isoutWhatschangedsincev200","content":"\n\nadamant-api는 패키지의 가장 큰 업데이트 이후 중요한 개선 사항과 수정 사항을 거쳐 상당한 향상을 이루었습니다. 전체적인 개발자 경험과 버그 수정을 목표로 한 패키지의 최대 업데이트 이후 주요 변경 사항을 살펴봅시다.\n\n![image](/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png)\n\n# 버그 수정\n\n- voteForDelegate() 유효성 검사 (v2.4.0): API.voteForDelegate() 메서드 내에서 공개 키 및 대표자 이름의 유효성 검사를 수정하였으며, 주소가 실제 대표자인지 체크하여 ADM 토큰의 낭비를 방지하였습니다.\n- 노드 체크 버그 (v2.3.1): 헬스 체크 프로세스 중에 랜덤 노드가 한 개만 체크되던 버그를 해결하였습니다.\n- 전역 설치 (v2.3.0): adamant-api에 의존하는 패키지의 전역 설치 문제를 해결하였습니다.\n\n<div class=\"content-ad\"></div>\n\n# DX 개선 사항\n\n- 로그 메시지 (v2.3.1): 보건 점검에 대한 로그 메시지를 개선하여 문제를 진단하고 시스템 상태를 모니터링하기 쉽게 했습니다.\n- 트랜잭션 쿼리 메서드 (v2.3.0): 트랜잭션 쿼리 언어를 사용하는 엔드포인트에 대해 중첩 객체를 사용하도록 변경하였습니다:\n\n```js\nconst blocks = await api.getTransactions({\n  fromHeight: 7585271,\n  and: {\n    toHeight: 7586280, // 'and:toHeight' 대신 7586280 사용\n  },\n  or: {\n    senderId: 'U18132012621449491414', // 'or:senderId' 대신 '...' 사용\n  },\n});\n```\n\n- WebSocket 초기화 (v2.1.0): api.initSocket() 메서드는 이제 WebSocketClient의 인스턴스를 수락합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst socket = new WebSocketClient({ /* ... */ });\napi.initSocket(socket);\n```\n\n- 메시지 인코딩 및 디코딩 (v2.1.0): encodeMessage() 및 decodeMessage() 함수가 퍼블릭 키를 Uint8Array 또는 Buffer로 받고, 패스프레이스 대신 키 쌍을 직접 전달할 수 있도록 업그레이드되었습니다:\n\n```js\nimport {encodeMessage, createKeypairFromPassphrase} from 'adamant-api';\nconst {publicKey} = createKeypairFromPassphrase('...');\nconst message = encodeMessage(,, publicKey);\n```\n\n```js\nimport {decodeMessage, createKeypairFromPassphrase} from 'adamant-api';\nconst keyPair = createKeypairFromPassphrase('...');\nconst message = decodeMessage(,, keyPair);\n```\n\n<div class=\"content-ad\"></div>\n\n# 유틸리티 함수\n\n- Validator 유틸리티(v2.2.0): API 내에서 여러 엔티티의 유효성을 향상시키기 위해 다양한 validator 유틸리티 함수를 내보냈습니다:\n\n```js\nfunction isPassphrase(passphrase: unknown): passphrase is string;\nfunction isAdmAddress(address: unknown): address is AdamantAddress;\nfunction isAdmPublicKey(publicKey: unknown): publicKey is string;\nfunction isAdmVoteForPublicKey(publicKey: unknown): publicKey is string;\nfunction isAdmVoteForAddress(address: unknown): boolean;\nfunction isAdmVoteForDelegateName(delegateName: unknown): delegateName is string;\nfunction validateMessage(message: string, messageType: MessageType = MessageType.Chat): {success: false; error: string} | {success: true};\nfunction isDelegateName(name: unknown): name is string;\nfunction admToSats(amount: number): number;\n```\n\n- 거래 쿼리 객체 변환(v2.3.0): transformTransactionQuery 함수를 소개하여 거래 쿼리를 간결화하고 구조화하여 더 읽기 쉽고 관리하기 쉽도록 만들었습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n상수 transformed를 transformTransactionQuery 함수로 변환했습니다. {\n  fromHeight: 7585271,\n  and: {\n    toHeight: 7586280,\n  },\n  or: {\n    senderId: 'U18132012621449491414',\n  },\n});\nconsole.log(transformed); // {'and:toHeight': 7586280, 'or:senderId': /* ... */}\n```\n\n# 타입 정의\n\n- 많은 메소드 내에서 트랜잭션 id에 대한 유형 정의가 수정되었으며, ChatTransactionData 인터페이스 내의 amount 속성 및 주 클래스의 options 내의 logLevel에 대한 유형 정의가 수정되었습니다.\n\nGitHub의 릴리스 노트를 확인하십시오: [여기](https://github.com/Adamant-im/adamant-api-jsclient/blob/master/CHANGELOG.md)\n","ogImage":{"url":"/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png"},"coverImage":"/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내","description":"","date":"2024-06-20 07:36","slug":"2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide","content":"\n\n![이미지](/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png)\n\n소개:\nReact.js와 Node.js는 효율성, 확장성 및 유연성으로 현대적인 웹 애플리케이션을 구축하는 데 인기 있는 선택지가 되었습니다. 이 블로그 포스트에서는 이러한 기술을 사용하여 풀 스택 웹 애플리케이션을 만드는 과정을 안내하겠습니다.\n\n필수 준비물:\n다음이 설치되어 있는지 확인하십시오:\n- Node.js (버전 14 이상)\n- npm (Node 패키지 관리자)\n- React.js (프론트엔드를 설정하기 위한 create-react-app)\n- Express.js (백엔드 서버를 설정하기 위해)\n\n단계 1: 환경 설정하기\n프로젝트용 새 디렉터리를 생성하고 프론트엔드와 백엔드를 설정하십시오:\n\n<div class=\"content-ad\"></div>\n\n\nmkdir fullstack-app\ncd fullstack-app\n\n# 프론트엔드 설정하기 - create-react-app 사용\nnpx create-react-app client\ncd client\n\n# 백엔드 설정하기 - Express.js 사용\nmkdir server\ncd server\nnpm init -y\nnpm install express\n\n\n단계 2: 백엔드 API 생성하기\n`server` 디렉토리 내에 Express.js 서버용 `index.js` 파일을 만들어 보세요:\n\n```js\nconst express = require('express');\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\napp.get('/api/data', (req, res) => {\n  const data = [\n    { id: 1, name: 'John Doe' },\n    { id: 2, name: 'Jane Smith' },\n    // 필요한 만큼 데이터 추가\n  ];\n  res.json(data);\n});\n\napp.listen(PORT, () => {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n단계 3: React.js로 프론트엔드 설정하기\n`client` 디렉토리 (create-react-app에서 생성됨)에서 `App.js`를 수정하여 백엔드 API에서 데이터를 가져올 수 있도록 설정하세요:\n\n\n<div class=\"content-ad\"></div>\n\n```jsx\r\nimport React, { useEffect, useState } from 'react';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  const [data, setData] = useState([]);\r\n\r\n  useEffect(() => {\r\n    fetch('/api/data')\r\n      .then(res => res.json())\r\n      .then(data => setData(data))\r\n      .catch(err => console.error('데이터를 가져오는 중 오류가 발생했습니다:', err));\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <h1>풀 스택 웹 애플리케이션</h1>\r\n      <ul>\r\n        {data.map(item => (\r\n          <li key={item.id}>{item.name}</li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\nStep 4: 애플리케이션 실행하기\r\n프론트엔드와 백엔드 서버를 동시에 실행하세요:\r\n\r\n\n# 'client' 디렉토리에서\r\nnpm start\r\n\r\n# 'server' 디렉토리에서\r\nnode index.js\r\n\n\r\n결론:\r\n이 블로그 포스트에서 React.js와 Node.js를 사용하여 풀 스택 웹 애플리케이션을 구축하는 기본적인 내용을 다뤘습니다. 환경을 설정하는 방법, Express.js를 사용하여 백엔드 API를 생성하는 방법, 그리고 백엔드에서 데이터를 가져와 React.js 프론트엔드에 표시하는 방법을 배웠습니다. 이 프로젝트를 확장하여 더 많은 기능을 추가하거나 MongoDB와 같은 데이터베이스를 통합하거나 Heroku나 AWS와 같은 플랫폼에 애플리케이션을 배포하는 등의 작업을 자유롭게 진행해보세요.\r\n\n\n<div class=\"content-ad\"></div>\n\n# 더 많은 자료:\n\n- React.js 문서: [reactjs.org](https://reactjs.org/)\n- Node.js 문서: [nodejs.org](https://nodejs.org/)\n- Express.js 문서: [expressjs.com](https://expressjs.com/)\n\nReact.js와 Node.js의 더 심화된 주제를 탐색하여 풀스택 개발 능력을 향상시키세요. 떠오르는 기술들에 대한 더 많은 튜토리얼과 프로젝트를 기대해주세요!","ogImage":{"url":"/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내","description":"","date":"2024-06-20 07:36","slug":"2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide","content":"\n\n로컬호스트에서 HTTPS를 실행하는 것은 안전한 웹 애플리케이션을 개발하고 테스트하는 데 필수적입니다.\n보안 소켓 계층(SSL) 또는 전송 계층 보안(TLS)은 인터넷을 통해 안전한 통신을 제공하는 방법을 제공합니다. 로컬호스트에서 HTTPS 서버를 실행하면 제품 서버에 배포될 때 웹 애플리케이션이 작동할 안전한 환경을 시뮬레이션할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png)\n\n이 안내서에서는 자체 서명된 인증서 및 Node.js 서버를 사용하여 로컬 머신에서 HTTPS를 설정하는 과정을 안내하겠습니다.\n\n#  준비 사항\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 다음 사전 요구 사항을 준비해 주세요:\n\n- Node.js 및 npm: 시스템에 Node.js 및 npm이 설치되어 있는지 확인하세요. 이것들은 nodejs.org에서 다운로드할 수 있습니다.\n- HTTPS의 기본 지식\n\n# 단계 1: 자체 서명 루트 인증서 생성\n\n첫 번째 단계는 자체 서명 루트 인증서를 생성하는 것입니다. 해당 인증서를 컴퓨터에 설치하고 서버에서 사용할 다른 인증서를 서명할 것입니다. 루트 인증서를 설치하면 해당 루트 인증서로 서명된 다른 인증서를 신뢰하는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n- 터미널이나 명령 프롬프트를 열고 인증서를 저장할 디렉토리로 이동하세요.\n- 다음 명령을 실행하여 루트 인증서용 개인 키를 생성하세요:\n\n```js\nopenssl genrsa -out root.key 2048\n```\n\n3. 이제 해당 개인 키를 사용하여 자체 서명된 루트 인증서를 생성하세요:\n\n```js\nopenssl req -x509 -new -nodes -key root.key -sha256 -days 365 -out root.crt\n```\n\n<div class=\"content-ad\"></div>\n\n4. macOS를 사용 중이라면, root.crt 파일을 두 번 클릭하여 시스템의 신뢰할 수 있는 인증서에 루트 인증서를 추가할 수 있습니다. Keychain Access 애플리케이션이 열릴 것입니다. \"System\" 키체인을 선택한 후, \"추가\"를 클릭하여 root.crt 파일을 찾아 선택하고 다시 \"추가\"를 클릭합니다. 인증서가 신뢰할 수 있는 것으로 표시되었는지 확인해주세요.\n\n이러한 단계를 거친 후, 우리는 자체 서명 루트 인증서를 만들어 신뢰할 수 있는 저장소에 추가했습니다.\n\n# 단계 2: 서버 인증서 생성\n\n다음으로, 로컬호스트를 위한 서버 인증서를 만들 것입니다. 이 인증서를 사용하면 로컬 서버가 안전한 연결을 설정할 수 있습니다. 서버의 인증서를 루트 인증서로 서명하여 컴퓨터가 서버의 신뢰성을 보장할 수 있도록 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n- 서버용 개인 키 생성:\n\n```js\nopenssl genrsa -out server.key 2048\n```\n\n2. 서버용 개인 키를 사용하여 인증서 서명 요청 (CSR) 생성:\n\n```js\nopenssl req -new -key server.key -out server.csr\n```\n\n<div class=\"content-ad\"></div>\n\n3. 이 명령은 공통 이름 (CN) 및 조직 세부 정보와 같은 CSR에 대한 일부 정보를 제공하도록 요구합니다. 공통 이름을 서버와 연결된 호스트명 또는 도메인 이름 (예: localhost)으로 설정해야 합니다.\n\n4. 루트 인증서로 CSR에 서명하여 서버 인증서를 만듭니다:\n\n```js\nopenssl x509 -req -in server.csr -CA root.crt -CAkey root.key -CAcreateserial -out server.crt -days 365 -sha256\n```\n\n5. 이 명령은 루트 인증서와 개인 키를 사용하여 CSR에 서명하고, 365일 동안 유효한 새로운 서버 인증서인 server.crt를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 단계를 거치면 서버에서 사용할 인증서를 만들고 PC가 신뢰하는 인증서로 설정합니다.\n\n# 단계 3: Node.js 서버 생성\n\n이제 서버 인증서를 준비했으니, HTTPS로 콘텐츠를 제공하기 위한 간단한 Node.js 서버를 만들어봅시다. 이 예시에선 Node.js와 Express 프레임워크를 사용하지만, 다른 언어와 프레임워크에 이 단계를 적용할 수도 있습니다.\n\n- server.js 라는 파일을 생성하고 다음 코드를 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n// server.js\nconst app = require('express')();\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n    key: fs.readFileSync('~/certs/practice/server.key'), // 귀하의 키 경로로 대체하세요\n    cert: fs.readFileSync('~/certs/practice/server.crt'), // 귀하의 인증서 경로로 대체하세요\n}\n\nhttps.createServer(options, (req, res) => {\n  res.writeHead(200);\n  res.end('Hello, HTTPS World!');\n}).listen(443, () => {\n  console.log('서버가 443 포트에서 실행 중입니다');\n});node\n```\n\n2. 파일을 저장한 후 터미널에서 아래 명령어를 실행하여 서버를 시작하세요:\n\n```js\nnode server.js\n```\n\n3. HTTPS 서버가 443 포트에서 실행 중이며, https://localhost 에서 액세스할 수 있습니다\n\n\n<div class=\"content-ad\"></div>\n\n# 단계 4: 루트 인증서 신뢰 (macOS 전용)\n\n만약 macOS를 사용 중이라면, 루트 인증서를 신뢰하기 위해 다음 추가 단계를 따라주세요:\n\n- Keychain Access 애플리케이션을 엽니다.\n- 왼쪽 사이드바에서 \"시스템\" 키체인을 선택합니다.\n- \"파일\"을 클릭한 후 \"항목 가져오기\"를 선택하고 root.crt 파일을 선택합니다.\n- 가져온 인증서를 더블 클릭하고 \"신뢰\" 섹션을 확장한 후 \"이 인증서 사용 시\"를 \"항상 신뢰함\"으로 설정합니다.\n\n# 단계 5: 최종 스크립트 (옵션)\n\n<div class=\"content-ad\"></div>\n\n인증서 생성 및 서버 설정을 자동화하려면 다음 스크립트를 사용할 수 있어요:\n\n```js\necho \"루트 서버 생성 중\"\nopenssl genrsa -out root.key 2048\nopenssl req -x509 -new -nodes -key root.key -sha256 -days 365 -out root.crt\n\necho \"서버 인증서 생성 중\"\nopenssl genrsa -out server.key 2048\nopenssl req -new -key server.key -out server.csr\nopenssl x509 -req -in server.csr -CA root.crt -CAkey root.key -CAcreateserial -out server.crt -days 365 -sha256\n\necho \"서버 파일 생성 중\"\ntouch server.js\necho \"\n// server.js\nconst app = require('express')();\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n    key: fs.readFileSync('/Users/akshitdev/certs/practice/server.key'),\n    cert: fs.readFileSync('/Users/akshitdev/certs/practice/server.crt'),\n}\n\nhttps.createServer(options, (req, res) => {\n  res.writeHead(200);\n  res.end('Hello, HTTPS World!');\n}).listen(443, () => {\n  console.log('서버가 포트 443에서 실행 중입니다');\n});\n\" >> server.js\n\necho \"서버를 루트에 추가 중\"\nsudo security add-trusted-cert -d -r trustRoot -k \"/Library/Keychains/System.keychain\" <인증서_파일_경로>\n\necho \"서버 실행 중\"\nnode server.js\n```\n\n이 스크립트를 사용하면 인증서 생성 및 서버 설정 과정을 자동화할 수 있어요.\n\n끝났어요! 셀프 사이닝된 인증서를 사용하여 로컬호스트에서 HTTPS를 성공적으로 구성했어요.","ogImage":{"url":"/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기","description":"","date":"2024-06-20 07:35","slug":"2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend","content":"\n\n오늘날 연결된 세상에서 안전한 웹 앱을 만드는 것은 매우 중요합니다. 애플리케이션의 통신 링크는 민감한 사용자 데이터를 관리하거나 거래를 돕는 경우 모두 안전해야 합니다. 다른 이의 엿보는 데서 민감한 데이터를 보호하기 위해, 리액트 프로젝트에서 API 호출을 안전하게 하는 방법에 대해 살펴보면서 업계 모베스트 프랙티스를 준수합니다.\n\n소개\n프런트엔드와 백엔드 간의 통신을 보호하는 것은 웹 애플리케이션 보안에서 가장 중요한 부분 중 하나입니다. 이는 API 엔드포인트를 보호하고 데이터 통신을 암호화하며 강력한 인증 절차를 수립하는 것을 포함합니다. 이러한 안전장치를 구현함으로써 무단 접근, 데이터 유출 및 기타 보안 결함의 가능성을 줄일 수 있습니다.\n\n# Node.js 백엔드 설정하기\n\n우리의 여정은 Node.js와 Express.js를 사용하여 백엔드를 설정하는 것으로 시작됩니다. Express.js는 Node.js를 위한 인기 있는 웹 애플리케이션 프레임워크입니다. 우리는 인증 기능을 갖춘 간단한 RESTful API를 만들어 보호된 리소스에만 인증된 사용자가 접근할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n저희 Node.js 백엔드에서는:\n\n- Express.js를 사용하여 서버를 생성하고 HTTP 요청을 처리합니다.\n- 인증은 현대적인 웹 애플리케이션에서 널리 사용되는 stateless 인증 메커니즘인 JSON Web Tokens (JWT)를 사용하여 구현됩니다.\n- 사용자 로그인 (/login) 및 보호된 데이터 검색 (/api/data)을 위한 라우트를 정의하고, 후자에 대한 인증을 강제합니다.\n\n```js\n// server.js\nconst express = require('express');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\nconst SECRET_KEY = 'your_secret_key';\n\napp.use(express.json());\n\n// 사용자 데이터 모의 (실제 시나리오에서는 데이터베이스에서 검색됨)\nconst users = [\n  { id: 1, username: 'user1', password: 'password1' },\n  { id: 2, username: 'user2', password: 'password2' }\n];\n\n// JWT 토큰 생성을 위한 로그인 라우트\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) {\n    return res.status(401).json({ message: '유효하지 않은 사용자 이름 또는 비밀번호' });\n  }\n  const token = jwt.sign({ userId: user.id }, SECRET_KEY);\n  res.json({ token });\n});\n\n// 보호된 라우트\napp.get('/api/data', verifyToken, (req, res) => {\n  res.json({ message: '보호된 데이터' });\n});\n\nfunction verifyToken(req, res, next) {\n  const token = req.headers.authorization;\n  if (!token) {\n    return res.status(401).json({ message: '인가되지 않음' });\n  }\n  jwt.verify(token, SECRET_KEY, (err, decoded) => {\n    if (err) {\n      return res.status(401).json({ message: '유효하지 않은 토큰' });\n    }\n    req.userId = decoded.userId;\n    next();\n  });\n}\n\napp.listen(PORT, () => {\n  console.log(`서버가 http://localhost:${PORT}에서 실행 중입니다.`);\n});\n```\n\n# React로 프론트엔드 구현하기\n\n<div class=\"content-ad\"></div>\n\n백엔드 설정이 완료되어, 이제 프론트엔드에 주력하게 됩니다. 리액트 애플리케이션을 구축하여 백엔드 API와 상호작용할 것입니다. 리액트 앱은 사용자 인증을 용이하게 하며, 보호된 데이터를 가져오기 위해 백엔드로 요청을 보냅니다.\n\n우리의 리액트 프론트엔드에서 주요한 부분은 다음과 같습니다:\n\n- React 컴포넌트 내에서 백엔드 엔드포인트에 HTTP 요청을 보내기 위해 fetch API를 사용합니다.\n- 성공적으로 인증된 후, JWT 토큰을 클라이언트의 로컬 상태에 저장합니다.\n- 토큰은 보호된 API 엔드포인트로의 후속 요청의 Authorization 헤더에 포함됩니다.\n\n```js\n// App.js\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [token, setToken] = useState('');\n  const [data, setData] = useState('');\n\n  const login = async () => {\n    const response = await fetch('/login', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ username: 'user1', password: 'password1' })\n    });\n    const { token } = await response.json();\n    setToken(token);\n  };\n\n  const fetchData = async () => {\n    const response = await fetch('/api/data', {\n      method: 'GET',\n      headers: {\n        'Authorization': token\n      }\n    });\n    const result = await response.json();\n    setData(result.message);\n  };\n\n  return (\n    <div>\n      <button onClick={login}>로그인</button>\n      {token && <button onClick={fetchData}>데이터 가져오기</button>}\n      <div>{data}</div>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n# API 호출 및 데이터 전송 보안\n\nAPI 호출을 보호하는 것은 여러 층의 보호를 포함합니다:\n\n- HTTPS: 백엔드 API가 HTTPS를 통해 제공되도록하여 클라이언트와 서버 간에 전송되는 데이터를 암호화하여 도청과 변경을 방지합니다.\n- JWT 인증: JWT 토큰을 사용하여 클라이언트가 자신을 인증하고 안전하게 보호된 리소스에 액세스할 수 있도록 인증합니다.\n- 권한 부여: 민감한 정보에 액세스할 수 있는 사용자가 인증되었는지 확인하기 위해 보호된 엔드포인트에 권한 확인을 구현합니다.\n- 프록시된 요청: 클라이언트에게 백엔드 API의 세부 정보를 숨기기 위해 서버를 통해 요청을 프록시 처리하여 보안을 강화하고 백엔드 엔드포인트가 직접 노출되는 것을 방지합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\nReact 프로젝트에서 Node.js 백엔드와 API 호출을 할 때는 최상의 방법을 준수하고 견고한 보안 메커니즘을 적용하여 안전하게 보호할 수 있습니다. JWT 토큰으로 인증 설정부터 서버를 통해 요청 프록시하는 것까지, 각 단계는 미인가된 접근으로부터 민감한 데이터를 보호하고 잠재적인 보안 문제를 예방하는 데 중요합니다.\n\n데이터 프라이버시와 보안이 중요한 점이 갈수록 높아지는 현대 세계에서는 이러한 보안 원칙을 구현하는 것이 권장 사항뿐만 아니라 사용자 신뢰와 확신을 구축하기 위한 필수 요소입니다. 보안을 강조함으로써, 우리는 웹 애플리케이션이 증가하는 위협과 취약점에 강건하게 대응하여 사용자에게 안전하고 안전한 경험을 제공할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend_0.png"},"coverImage":"/assets/img/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend_0.png","tag":["Tech"],"readingTime":5},{"title":"올바른 Docker 없이 Open WebUI를 설치하는 방법","description":"","date":"2024-06-20 07:33","slug":"2024-06-20-HowtoinstallOpenWebUIwithoutDocker","content":"\n\n![image](/assets/img/2024-06-20-HowtoinstallOpenWebUIwithoutDocker_0.png)\n\n이 안내서는 도커 없이 올라마 웹 UI를 설정하는 방법을 안내합니다. 도커는 편의 및 지원을 위해 공식적으로 권장되지만, 이 매뉴얼 방법은 제약 사항이 있는 개발자나 환경에 유용할 수 있습니다. 기억하세요, 지원되지 않는 설치 문제 해결은 개별 노력이 필요할 수 있습니다.\n\n## 프로젝트 구성 요소:\n\n- 프론트엔드: 상호 작용하는 웹 인터페이스입니다.\n- 백엔드: 뒷면에서의 통신 및 기능을 처리합니다. 두 구성 요소는 동시에 실행되어야 개발할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 요구 사항:\n\n- Node.js `= 20.10`: 프론트엔드 빌드에 사용됨.\n\n- Python `= 3.11`: 백엔드 실행에 사용됨.\n\n- Ollama: 모델용.\n\n<div class=\"content-ad\"></div>\n\n# 시작해보자! 설치 단계:\n\n- Ollama 웹 UI 저장소를 복제하세요:\n\n```js\ngit clone https://github.com/open-webui/open-webui.git\n```\n\n- 프로젝트 디렉토리로 이동하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\ncd ollama-webui/\n```\n\n- 환경 파일을 복사합니다:\n\n```js\ncp -RPp example.env .env\n```\n\n참고: 이 파일에는 설정과 구성이 저장됩니다. 필요에 따라 업데이트하세요.\n\n<div class=\"content-ad\"></div>\n\n## 프론트엔드 빌드:\n\n- 노드를 사용하여 프론트엔드 빌드하기\n\n```js\nnpm install\n```\n\n```js\nnpm run build\n```\n\n<div class=\"content-ad\"></div>\n\n## 백엔드 시작:\n\n- 가상 환경 만들기:\n\n```js\ncd ./backend\n\n# virtualenv 패키지 설치\npip install -U virtualenv\n\n# backend 폴더에 가상 환경 생성\nvirtualenv venv\n\n# 가상 환경 활성화\nsource venv/Scripts/activate\n```\n\n- 백엔드와 함께 프론트엔드 제공\n\n<div class=\"content-ad\"></div>\n\n```js\npip install -r requirements.txt -U\n```\n\n```js\nbash start.sh\n```\n\n## Ollama 웹 UI에 액세스하기:\n\n- 웹 브라우저에서 http://localhost:8080/을 열어주세요. 인터페이스가 실행 중이어야 합니다!\n\n<div class=\"content-ad\"></div>\n\n## 팁 및 문제 해결:\n\n에러가 발생하면 단서를 찾기 위해 콘솔 출력을 확인해보세요. 추가 구성 옵션 및 고급 기능에 대한 정보는 Ollama Web UI 설명서를 참조하세요. Docker가 아닌 설정은 공식적으로 지원되지 않으므로 문제 해결 작업에 대비해야 합니다.\n\nOllama Web UI를 즐기세요!\n\n이 튜토리얼은 Docker 없이 Ollama Web UI를 시작하는 데 도움이 될 것입니다. 일반적으로 Docker를 선호하지만 이 설명서 방식은 특정 상황에 대해 유연성을 제공합니다. 약간의 노력으로 이 강력한 대화형 도구를 시작할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-HowtoinstallOpenWebUIwithoutDocker_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoinstallOpenWebUIwithoutDocker_0.png","tag":["Tech"],"readingTime":2},{"title":"Node Boost 클러스터, 스레드","description":"","date":"2024-06-20 07:33","slug":"2024-06-20-NodeBoostClustersThreads","content":"\n\n<img src=\"/assets/img/2024-06-20-NodeBoostClustersThreads_0.png\" />\n\nNode.js 어플리케이션 성능 최적화 전략\n\n이 글에서는 이러한 상황을 효과적으로 관리하는 다양한 전략에 대해 살펴볼 것입니다.\n\n# 이벤트 루프 도전 이해하기\n\n<div class=\"content-ad\"></div>\n\nNode.js에서 이벤트 루프는 비동기 작업을 처리하는 핵심 개념입니다. 그러나 이벤트 루프 내에 너무 많은 작업이 존재하면 성능 병목 현상이 발생할 수 있습니다. 이 문제는 특히 많은 작업을 효율적으로 처리해야 하는 고성능 응용 프로그램에서 특히 중요해집니다.\n\n# 전략 1: Node.js 클러스터 모듈 활용\n\n성능 문제를 처리하는 효과적인 방법 중 하나는 Node.js의 클러스터 모듈을 활용하는 것입니다. 이 모듈을 사용하면 여러 인스턴스의 Node.js 애플리케이션을 각각 독립적인 이벤트 루프를 가지고 동일한 서버 포트를 공유하여 실행할 수 있습니다. 작동 방식은 다음과 같습니다:\n\n- 여러 Node 인스턴스: 클러스터 모듈을 통해 여러 Node.js 인스턴스를 생성할 수 있습니다. 각 인스턴스는 별도의 프로세스로 실행되어 응용 프로그램이 여러 CPU 코어를 효과적으로 활용할 수 있게 합니다.\n- 부하 분산: Node.js 클러스터 모듈은 여러 인스턴스 사이에 들어오는 요청을 분산하여 부하를 균형 있게 유지하고 단일 인스턴스에 병목 현상이 발생하지 않도록 합니다.\n- 성능 향상: 요청을 처리하는 여러 인스턴스가 존재하므로 애플리케이션 전체의 성능이 향상되며, 작업이 서로 다른 인스턴스 간에 동시에 처리되어 효율적으로 이루어집니다.\n\n<div class=\"content-ad\"></div>\n\n클러스터 모듈은 노드.js를 다중 스레딩으로 만들지는 않지만 병렬로 동작하는 여러 이벤트 루프를 생성하여 다중 스레딩을 시뮬레이트합니다.\n\n개요:\n노드.js의 클러스터 모듈은 애플리케이션이 CPU의 별도 코어에서 실행되는 노드.js 프로세스의 여러 인스턴스를 생성할 수 있도록 합니다. 이를 통해 부하를 분산시키고 무거운 작업에 의해 단일 인스턴스가 과부하되는 것을 방지할 수 있습니다.\n\n구현:\n\n- 설정:\n\n<div class=\"content-ad\"></div>\n\n- 클러스터 모듈을 사용하여 Node.js 애플리케이션을 설정하세요.\n- 클러스터 모듈을 사용하여 기본 프로세스를 여러 워커 프로세스로 포크하세요.\n\n- 장점:\n  \n- 각 워커 프로세스는 독립적인 이벤트 루프를 실행합니다.\n- 부하가 여러 CPU 코어에 분산됩니다.\n- 스케일링 및 장애 허용성이 향상되며, 한 워커 프로세스의 실패가 다른 프로세스에 영향을 미치지 않습니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\nif (cluster.isMaster) {\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('Hello World\\n');\n  }).listen(8000);\n}\n```\n\n# 전략 2: 워커 스레드 활용\n\n성능을 향상시키는 또 다른 방법은 워커 스레드를 사용하는 것입니다. 워커 스레드는 CPU 집약적인 작업을 실행하는 데 유용합니다. 다음은 워커 스레드를 통합하는 방법입니다:\n\n- 스레드 풀: Node.js에는 libuv 라이브러리를 통해 기본 스레드 풀이 포함되어 있습니다. 워커 스레드는 이 스레드 풀에 무거운 계산을 할당하여 주 이벤트 루프를 다른 작업 처리에 확보할 수 있습니다.\n- 병행성: 워커 스레드를 이용하면 작업이 병렬로 실행되어 응용 프로그램의 처리량과 응답성을 크게 향상할 수 있습니다.\n- 구현: 워커 스레드를 설정하는 것은 함수를 독립적으로 실행할 수 있는 스레드 풀을 만드는 과정을 포함합니다. 이 설정은 데이터 처리, 이미지 처리 및 복잡한 계산과 같은 작업에 이상적입니다.\n\n\n<div class=\"content-ad\"></div>\n\n개요:\n워커 스레드는 여러 스레드에서 JavaScript를 병렬로 실행하여 중요한 계산을 메인 이벤트 루프에서 벗어나 실행하는 방법을 제공합니다.\n\n구현:\n\n- 설정:\n\n- worker_threads 모듈을 사용하여 워커 스레드를 생성합니다.\n- CPU 집약적인 작업을 이 워커 스레드에 위임합니다.\n\n<div class=\"content-ad\"></div>\n\n- 혜택:\n\n- 주요 스레드가 차단되지 않도록 무거운 계산을 완화합니다.\n- 하나의 Node.js 프로세스 내에서 다중 스레딩 기능을 활용합니다.\n- 애플리케이션의 반응성을 향상시킵니다.\n\n예시:\n\n```js\nconst { Worker, isMainThread, parentPort } = require('worker_threads');\nif (isMainThread) {\n  const worker = new Worker(__filename);\n  worker.on('message', message => {\n    console.log(`Received message from worker: ${message}`);\n  });\n  worker.postMessage('Start work');\n} else {\n  parentPort.on('message', message => {\n    // 무거운 계산 수행\n    let result = heavyComputation();\n    parentPort.postMessage(result);\n  });\n  function heavyComputation() {\n    // 무거운 작업 시뮬레이션\n    let sum = 0;\n    for (let i = 0; i < 1e9; i++) {\n      sum += i;\n    }\n    return sum;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 최적의 방법과 권장 사항\n\n클러스터 모듈과 워커 스레드는 모두 상당한 성능 향상을 제공하지만, 적절한 사용 시나리오를 고려하는 것이 중요합니다:\n\n- 먼저 클러스터 모듈을 사용해 보세요: 대부분의 애플리케이션에 대해, 클러스터 모듈을 사용하는 것이 좋습니다. 이는 여러 CPU 코어를 효율적으로 활용하여 애플리케이션 코드를 크게 수정할 필요 없이 작동합니다.\n- CPU 집약적인 작업에 워커 스레드 활용: 애플리케이션이 무거운 계산 작업을 포함하는 경우, 워커 스레드를 통합하는 것을 고려해 보세요. 이 방법은 실험적이지만 특정 사용 사례에 대해 상당한 성능 향상을 제공할 수 있습니다.\n- 모니터링과 테스트: 항상 다양한 부하와 시나리오에서 애플리케이션의 성능을 모니터링하세요. 성능 테스트 도구를 사용하여 병목 현상을 식별하고 이러한 최적화의 영향을 평가하세요.\n\n# 성능 최적화를 위한 권장 사항\n\n<div class=\"content-ad\"></div>\n\n- 클러스터 모듈부터 시작해 보세요:\n\n- 클러스터 모듈은 성능을 향상시키는 것에 검증된 신뢰할 수 있는 방법입니다.\n- 개선된 부하 처리와 오류 허용이 필요한 애플리케이션에 이상적입니다.\n\n- 워커 스레드로 실험해 보세요:\n\n- 특정한 무거운 계산 작업이 있는 애플리케이션에 대해 워커 스레드를 사용하면 매우 효과적입니다.\n- 이 접근 방식은 실험적이지만 특정 사용 사례에 대해 상당한 성능 향상을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n- 전략 통합:\n\n- 일부 시나리오에서는 클러스터 모듈과 워커 스레드를 결합하여 양쪽의 장점을 최대로 활용할 수 있습니다.\n- 이 하이브리드 방식은 시스템 리소스의 활용을 극대화할 수 있습니다.\n\n# 결론\n\n성능을 위해 Node.js 애플리케이션을 최적화하는 것은 클러스터 모듈과 워커 스레드와 같은 사용 가능한 도구를 전략적으로 활용하는 것을 포함합니다. 작업 부하를 효과적으로 분산하고 무거운 계산을 처리하는 방식으로 개발자는 애플리케이션이 반응적이고 효율적으로 유지될 수 있도록 할 수 있습니다. 신뢰성을 갖춘 클러스터 모듈부터 시작하여 특정 작업에 대해 워커 스레드를 통합하면 상당한 성능 향상이 기대됩니다. 이 알고리즘에 대한 이해를 더 깊이 파고 싶다면, 제 GitHub 저장소(algorithms-data-structures)를 탐험해보세요. 여기에서는 실험하고 연습하며 지식을 확고히 하는 데 도움이 되는 다양한 알고리즘 및 데이터 구조가 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n언젠가는 완성될 예정인 몇 개 섹션들이 있습니다. 제 꾸준한 학습 여정을 반영한 것입니다. 이 프로세스는 완료되기까지 2-3년이 소요될 것으로 예상됩니다. 그러나 저장소는 끊임없이 발전하고 있습니다.\n\n탐험으로 끝나는 것이 아니에요! 여러분의 피드백을 소중히 생각합니다. 도전적인 상황을 마주했거나 건설적인 비평을 하고 싶거나 알고리즘과 성능 최적화에 대해 토론하고 싶다면 언제든지 연락해 주세요. Twitter에서 @m_mdy_m으로, Telegram에서는 @m_mdy_m으로 저에게 연락할 수 있습니다. 또한 GitHub 계정인 m-mdy-m에서 토론에 참여할 수도 있습니다. 지식을 공유하고 우리의 이해 범위를 넓히는 활기찬 학습 커뮤니티를 함께 만들어봐요. 함께 해요!","ogImage":{"url":"/assets/img/2024-06-20-NodeBoostClustersThreads_0.png"},"coverImage":"/assets/img/2024-06-20-NodeBoostClustersThreads_0.png","tag":["Tech"],"readingTime":5},{"title":"우분투 2204, 2004 및 1804에서 Intel x64, AMD, ARM64 CPU용 Nodejs 20 설치하는 방법","description":"","date":"2024-06-20 07:32","slug":"2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs","content":"\n\n<img src=\"/assets/img/2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs_0.png\" />\n\n이 이야기에서는 Intel/AMD 및 ARM64 CPU에서 실행 중인 Ubuntu 22.04, 20.04 및 18.04에 Node.js v20.x를 무인으로 설치하는 방법을 배우게 됩니다.\n\n# 가장 오래된 버전의 Node.js 삭제하기\n\n선택적 단계: Node.js 버전 20.x를 설치하기 전에 아래의 BASH 명령어를 사용하여 가장 오래된 Node.js 버전을 삭제할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```sh\nsudo apt-get remove nodejs\n```\n\n## 우분투 Intel/AMD CPU에 NodeJS 설치 방법:\n\n아래는 INTEL/AMD CPU에 Node.js 버전 20.x를 설치하는 데 필요한 문장들입니다:\n\n```sh\nsudo apt update\nsudo apt install -y ca-certificates curl gnupg\nsudo mkdir -p /etc/apt/keyrings\ncurl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg\nNODE_MAJOR=20\necho \"deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_$NODE_MAJOR.x nodistro main\" | sudo tee /etc/apt/sources.list.d/nodesource.list\nsudo apt update\nsudo apt install -y nodejs\n```\n\n<div class=\"content-ad\"></div>\n\n# 우분투 ARM64 CPU에 NodeJS 설치 방법:\n\n아래는 ARM64 CPU에서 Node.js 버전 20.x을 설치하는 데 필요한 문장들입니다:\n\n```js\nnodeVersion=20.14    \nsudo apt-get remove nodejs\nwget \"https://nodejs.org/dist/v${nodeVersion}.0/node-v${nodeVersion}.0-linux-arm64.tar.gz\"\ntar -xvf \"node-v${nodeVersion}.0-linux-arm64.tar.gz\"\nsudo cp \"node-v${nodeVersion}.0-linux-arm64\" \"/etc/node${nodeVersion}\" -r\nsudo ln -s \"/etc/node${nodeVersion}/bin/node\" /usr/bin/node\nsudo ln -s \"/etc/node${nodeVersion}/bin/npm\" /usr/bin/npm\n```\n\n# Node.js 설치 확인\n\n<div class=\"content-ad\"></div>\n\n아래 명령을 실행하여 설치가 완료되었는지 확인해보세요:\n\n```js\nguillermo@kopi-vm:~$ node -v\nv20.14.0\n```\n\n이게 전부에요! 만약 이 이야기를 좋아했다면, 👏을 눌러 지원을 보여주세요. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs_0.png","tag":["Tech"],"readingTime":2}],"page":"33","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}