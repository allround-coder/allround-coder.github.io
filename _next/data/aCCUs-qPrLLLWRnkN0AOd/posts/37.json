{"pageProps":{"posts":[{"title":"Angular 인증 Angular 18로 업그레이드하기 ","description":"","date":"2024-06-20 05:45","slug":"2024-06-20-AngularAuthenticationUpgradetoAngular18","content":"\n\n아래는 Markdown 형식의 표입니다.\n\nCover Photo by Gareth Davies on Unsplash.\n\n사용자 인증 흐름에 대한 최상의 실천 방법을 보여주는 Angular 애플리케이션입니다.\n\n## 라이브 데모\n\n라이브 애플리케이션: angular-authentication.netlify.app\n\n<div class=\"content-ad\"></div>\n\n# 도전! 🤔\n\n세 해 전에, Angular 애플리케이션에서 인증 및 권한 부여를 보여주기 위해 Angular Authentication이라는 오픈 소스 프로젝트를 만들었습니다. 이 프로젝트는 Angular 13로 구축되었으며 사용자 인증 및 권한 흐름, 보호된 경로 등을 특징으로 하였습니다. 그러나 Angular가 발전함에 따라 성능 향상, 새로운 기능, 향상된 보안을 갖춘 새로운 버전이 출시되었습니다. 프로젝트를 최신 상태로 유지하고 최신 기술을 활용하기 위해 Angular 13에서 Angular 18로 업그레이드하기로 결정했습니다.\n\nAngular 프로젝트를 업그레이드하는 것은 주요 버전을 여러 개 걸쳐서 업데이트하는 것처럼 보일 수 있지만, Angular CLI의 강력함, 성능 향상의 장점, 새로운 기능 및 향상된 보안은 노력을 충분히 가치 있게 만듭니다. 이 글에서는 Angular 인증 오픈 소스 프로젝트를 Angular 13에서 Angular 18로 업그레이드하는 과정을 안내하겠습니다. 의존성 업데이트, 새로운 Angular 기능 채택, UI 구성 요소 이전 등을 다룰 것입니다.\n\n# 간단 요약 🎯\n\n<div class=\"content-ad\"></div>\n\n- ✅ Angular 버전: 13 ➡️ 18\n- ✅ 종속성: 종속성을 최신 버전으로 업데이트합니다.\n- ✅ UI 이주: 새로운 Angular Material Design Components (Material 3)를 사용해보세요.\n- ✅ 릴리스 관리: versioning 및 changelog 생성을 위해 release-it으로 이주합니다.\n- ✅ 기능: 새로운 Angular 18 기능을 채용합니다.\n- ✅ 내장 제어 흐름: 새로운 제어 흐름 구문으로 이주합니다.\n- ✅ 독립형 구성 요소: 모듈성을 위해 독립형 구성 요소를 활용합니다.\n- ✅ 라우트 가드: 라우트 가드를 함수로 리팩토링합니다.\n- ✅ 타입드 폼: 개선된 타입 안전성을 위해 타입드 폼을 사용합니다.\n- 🕣 시그널 API 사용: 새로운 시그널 입력, 시그널 기반 쿼리, 그리고 새로운 출력 구문으로 이주를 시도해보세요.\n- 🕣 Zoneless 변경 감지: zone.js를 종속성에서 제거합니다.\n- 🕣 미루기 가능한 뷰: 미루기 가능한 뷰를 위한 새로운 화려한 기능을 사용합니다.\n\n# 점진적 업그레이드 프로세스 🚀\n\n# 초기 설정\n\n[단계 1] ⏩ Angular 업그레이드 가이드 방문하기:\n\n<div class=\"content-ad\"></div>\n\n- Angular 업데이트 가이드는 각 버전 업그레이드에 대한 자세한 단계와 정보를 제공합니다.\n\n[단계 2] ⏩ Node 16용 의존성 설치:\n\n```js\nnpm install\n```\n\n[단계 3] ⏩ Node 18로 전환: 저는 Node 버전 관리자(nvm)를 사용하여 Node 18로 전환했습니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\nnvm 사용 18\n\n# Angular 업데이트 점진적으로 진행하기\n\n[단계 4] ⏩ Angular 14로 업데이트하기:\n\nng update @angular/core@14 @angular/cli@14 --force\n\n<div class=\"content-ad\"></div>\n\n- --force 플래그를 사용하면 버전 호환성 검사를 우회합니다. 나중에 수동으로 문제를 수정할 거에요.\n\n[단계 5] ⏩ 순차적인 업데이트:\n\nng update @angular/core@15 @angular/cli@15 --force\nng update @angular/core@16 @angular/cli@16 --force\nng update @angular/core@17 @angular/cli@17 --force\n\n[단계 6] ⏩ Node 20으로 전환:\n\n<div class=\"content-ad\"></div>\n\nnvm 사용 20\n\n[Step.7] ⏩ 최신 Angular 버전(v18)으로 업데이트:\n\nng update @angular/core@latest @angular/cli@latest --force\n\n# 조정 및 비교\n```  \n\n<div class=\"content-ad\"></div>\n\n[단계 8] ⏩ 비교를 위해 새 Angular 프로젝트 생성하기:\n\n- 최신 버전의 Angular 프로젝트를 생성하여 구성을 비교하고 필요한 조정 사항을 식별합니다.\n\n```js\nng new new-angular-project\n```\n\n[단계 9] ⏩ 개발 의존성 업데이트하기:\n\n<div class=\"content-ad\"></div>\n\n- 모든 패키지를 최신 버전으로 업데이트해주세요.\n- eslint 문제를 수정해주세요.\n- package.json에 있는 모든 명령어를 테스트하여 호환성을 확인해주세요.\n\n# 최종 Angular 업데이트\n\n[Step.10] ⏩ Node 버전 20으로 강화하기:\n\n- package.json의 engines 필드를 업데이트하여 Node 20.x를 사용하도록 설정해주세요.\n\n<div class=\"content-ad\"></div>\n\n```json\n\"engines\": {\n  \"node\": \"20.x\"\n}\n```\n\n[Step.11] ⏩ 기능 및 구성 요소 분리:\n\n- 기능을 분리하고 하나씩 Angular 18로 마이그레이션을 시작하세요. 이 방법을 통해 문제를 식별하고 점진적으로 수정할 수 있습니다. — Angular CLI schematics를 사용하여 최신 Angular 18 기능을 갖춘 새로운 컴포넌트와 서비스를 생성하세요. 예를 들어:\n\n```js\nng g @angular/core:control-flow # 새로운 제어 플로우로 이주\n```\n\n<div class=\"content-ad\"></div>\n\n# UI 및 의존성 이주\n\n[Step.12] ⏩ TaigaUI에서 Angular MDC로 UI 이주:\n\n- Angular Material Design Components (MDC)로 전환합니다. TaigaUI도 훌륭한 라이브러리이지만 새로운 Material 3 컴포넌트는 이제 안정화되었고 저는 시도해 보기로 결정했습니다.\n- TaigaUI 컴포넌트를 MDC와 대체합니다.\n\n[Step.13] ⏩ 사용되지 않는 종속성 제거:\n\n<div class=\"content-ad\"></div>\n\n- angular-in-memory-web-api를 제거하고 대안적인 데이터 모킹 솔루션이나 실제 백엔드 서비스를 사용하도록 프로젝트를 업데이트해주세요.\n- API 요청과 응답을 처리하기 위한 사용자 지정 HTTP 인터셉터를 구현해주세요.\n\n[Step.14] ⏩ 독립 구성 요소 채택:\n\n- Angular의 독립 컴포넌트 기능을 활용하여 모듈 관리를 간단화하고 코드 모듈성을 개선해보세요.\n\n```typescript\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-standalone',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './standalone.component.html',\n  styleUrls: ['./standalone.component.css'],\n})\nexport class StandaloneComponent {}\n```\n\n<div class=\"content-ad\"></div>\n\n[단계 15] ⏩ 새로운 내장 제어 흐름 사용:\n\n- Angular 18에서 소개된 새로운 내장 제어 흐름 기능을 사용하여 비동기 작업을 간소화하고 코드 가독성을 향상시킵니다. 구체적으로 ngIf 대신 @if 키워드를 사용하고 ngFor 대신 @for를 사용해주세요.\n\n[단계 16] ⏩ 가드를 함수로 리팩토링:\n\n- 라우트 가드를 함수로 리팩토링하여 코드를 간소화하고 유지보수성을 향상시키세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nexport const canActivate = (\n  route: ActivatedRouteSnapshot,\n  state: RouterStateSnapshot\n) => {\n  // 가드 로직\n};\n```\n\n[Step.17] ⏩ 타입드 폼:\n\n- 유형화된 폼을 사용하여 폼 처리에서의 유형 안전성을 향상시키고 오류를 줄입니다.\n\n```js\nloginForm = new FormGroup({\n  username: new FormControl(/* ... */),\n  password: new FormControl(/* ... */),\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 기타 향상된 기능\n\n[Step.18] ⏩ 릴리즈를 release-it으로 마이그레이션:\n\n- 프로젝트 standard-version이 더 이상 사용되지 않아 release-it으로 버전 관리와 변경 로그 생성을 마이그레이션하기로 결정했습니다.\n- release-it을 사용하여 릴리즈 프로세스를 간단히 만들어 버전 관리와 변경 로그 생성을 자동화합니다.\n\n```js\nnpm install --save-dev release-it\n```\n\n<div class=\"content-ad\"></div>\n\n- .release-it.json 파일을 사용하여 release-it을 구성하세요:\n\n```js\n{\n  \"git\": {\n    \"commitMessage\": \"chore(release): ${version}\",\n    \"requireBranch\": [\"main\"]\n  }\n  // ... 다른 구성\n}\n```\n\n# 향후 개선 사항 💡\n\n- 더 많은 Angular 기능 채택하기: Angular 18에서 소개된 향상된 성능, 업데이트된 API 및 향상된 도구 등 새로운 기능과 개선 사항을 탐색하세요.\n- 독립형 컴포넌트 사용하기: 컴포넌트에서 모든 @NgModule 선언을 제거하고 더 나은 모듈화를 위해 독립형 컴포넌트를 사용하세요.\n- Zoneless 변경 감지: 성능을 향상시키고 오버헤드를 줄이기 위해 zoneless Angular로 마이그레이션을 고려하세요.\n- Signal API 사용하기: Angular 18에서 소개된 새 Signal API를 통해 비동기 작업을 간단하게 해보세요.\n- 지연 가능한 뷰: 렌더링 성능과 사용자 경험을 향상시키기 위해 지연 가능한 뷰를 구현하세요.\n\n<div class=\"content-ad\"></div>\n\n# 결론 ✅\n\nAngular 프로젝트를 13버전에서 18버전으로 업그레이드하는 것에는 종속성 업데이트, 이슈 수정 및 새로운 기능 적용 등 여러 단계가 필요합니다. 이 체계적인 방법을 따르면 원활한 업그레이드 경로를 보장하고 Angular의 최신 기술 발전을 활용할 수 있습니다.\n\n만약 이 글이 도움이 되었다면 👏을 눌러 더 많은 사람들에게 도움이 되도록 지원해주세요. 🙏\n\n질문이 있으시면 언제든지 연락해 주세요 — 아래에 댓글을 남기거나 X에서 DM을 보내거나 LinkedIn에서 연락해주세요.","ogImage":{"url":"/assets/img/2024-06-20-AngularAuthenticationUpgradetoAngular18_0.png"},"coverImage":"/assets/img/2024-06-20-AngularAuthenticationUpgradetoAngular18_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular 및 GCP를 활용한 PDF 오픈 소스 서비스 구축 - 클라우드 런으로 서비스 배포하기","description":"","date":"2024-06-20 05:44","slug":"2024-06-20-BuildingPDFOpenSourceServiceswithAngularGCPDeployservicestoCloudRun","content":"\n\n![image](/assets/img/2024-06-20-BuildingPDFOpenSourceServiceswithAngularGCPDeployservicestoCloudRun_0.png)\n\n안녕하세요! Angular (Analogjs), Firestore, Cloud Storage, 그리고 CloudRun을 이용하여 오픈 소스 PDF 서비스를 구축하는 여정에 오신 것을 환영합니다. 이 프로젝트는 제 지식을 공유하고 지속적으로 최상의 사례를 학습하며 동시에 커뮤니티에 기여하는 플랫폼으로 제공됩니다.\n\n파트 1: 아키텍처 개요\n파트 2: Cloud Run에 서비스 배포\n\n데모: https://pdfun.xyz\n\n<div class=\"content-ad\"></div>\n\n해결책은 GCP 생태계를 중심으로 구축되었으므로 프로젝트를 GCP에 배포하는 것이 좋습니다. 그렇게 하면 서비스에 액세스할 수 있습니다. 해결책은 두 부분으로 구성됩니다:\n\n- 웹 UI (Analogjs — Angular): 사용자 상호작용 처리\n- 백엔드 (Node — Express): PDF 파일 처리\n\n# 왜 Cloud Run에 배포해야 하는가?\n\nCloud Run은 Google Cloud Platform(GCP)에서 제공하는 완전히 관리되는 컴퓨팅 플랫폼으로 stateless 컨테이너를 자동으로 확장시킵니다. 그렇다면 왜 우리는 서비스를 배포할 때 Cloud Run을 선택해야 할까요? 여기에 몇 가지 이유가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- Cloud Run은 장기 실행 작업을 지원하여 서비스를 배포하기에 훌륭한 선택입니다. 서비스는 최대 60분 동안 실행되며, 계산 시간이 많이 필요한 작업을 수용할 수 있습니다.\n- 이외에도 Cloud Run은 자동 스케일링, 개발자 친화적 환경, 통합 로깅 및 모니터링, 사용량에 따른 요금 체계, 다양한 플랫폼 간 이식성 등의 혜택을 제공합니다. 이로써 PDF 서비스를 배포하기 위한 다목적이고 비용 효율적인 솔루션이 됩니다.\n\n## 도커를 사용한 Google Cloud Run 배포\n\nCloud Run은 서비스를 배포하기 위해 도커 이미지를 사용하므로, 필요한 작업은 애플리케이션을 이미지로 랩핑하는 것입니다.\n\n### Prerequisites\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 다음 사항을 확인해주세요:\n\n- 활성화된 과금이 설정된 Google Cloud 프로젝트\n- 로컬 머신에 설치된 도커\n- 설치 및 초기화된 Google Cloud SDK\n\n더 자세한 지시 사항을 위해 클라우드런에 배포하는 방법 문서를 참고해주세요.\n\n## 도커 이미지 빌드하기\n\n<div class=\"content-ad\"></div>\n\n다음으로 프로젝트와 Docker 이미지를 빌드해야 합니다. 이는 docker build 명령을 사용하여 수행할 수 있습니다. 이미지에 레지스트리 이름을 태그하는 것을 잊지 마세요. 예를 들어:\n\n```js\n// build-new-image.sh\n\nimageTag=${REGION}-docker.pkg.dev/$GCLOUD_PROJECT/$REPO/$image\n\ndocker build -t $imageTag -f Dockerfile --platform linux/x86_64 .\n```\n\nREGIONS, GCLOUD_PROJECT, REPO 및 image를 Google Cloud 프로젝트 ID, 이미지 이름 및 이미지 태그로 대체해주세요.\n\n## Artefact Registry로 이미지 푸시\n\n<div class=\"content-ad\"></div>\n\n이미지를 빌드하고 나면, docker push 명령어를 사용하여 Artifact Registry에 이미지를 푸시할 수 있어요:\n\n```js\ndocker push $imageTag\n```\n\n## 클라우드 런(Cloud Run)에 새 서비스 생성하기\n\n이미지가 Artifact Registry에 등록되었으니, 클라우드 런에 새 서비스를 생성할 수 있어요. PDF 서비스를 배포하려면 다음 명령어를 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```bash\ngcloud run deploy pdfun \\\n  --image=us-central1-docker.pkg.dev/pdfun-prod/pdf/pdfun \\\n  --platform=managed --project=pdfun-prod --region=us-central1 \\\n  --allow-unauthenticated\n```\n\n이 명령은 서비스 이름이 pdfun인 Web UI를 Cloud Run에 배포하고 웹 사이트에 모두 접근할 수 있도록 허용합니다(`--allow-unauthenticated`).\n\n# 보너스: Nx를 활용하여 서비스 배포하기\n\n서비스를 배포할 때 Nx는 간편한 프로세스를 제공합니다. 구성 후에는 영향을 받는 앱만 배포할 수 있도록 하기 위해 yarn deploy를 실행하기만 하면 됩니다. 예를 들어 프론트엔드만 업데이트하는 경우 프론트엔드만 빌드되고 배포됩니다.\n\n<div class=\"content-ad\"></div>\n\n저희가 배포 명령어를 실행한 후 무슨 일이 벌어지는지에 대해, 커밋을 비교하여 main 브랜치의 최신 커밋과 함께 영향 받는 프로젝트에 대해 배포 대상을 실행합니다.\n\npdfun 애플리케이션의 project.json을 확인해 봅시다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// project.json\n\n...\n\n\"deploy\": {\n  \"executor\": \"nx:run-commands\",\n  \"options\": {\n    \"commands\": [\"nx deploy-docker pdf\", \"nx deploy-cloudrun pdf\"],\n    \"color\": true,\n    \"parallel\": false\n  },\n  \"dependsOn\": [\n    {\n      \"target\": \"build\"\n    }\n  ]\n},\n\"deploy-cloudrun\": {\n  \"command\": \"gcloud run deploy pdfun --image=us-central1-docker.pkg.dev/pdfun-prod/pdf/pdfun --platform=managed --project=pdfun-prod --region=us-central1 --allow-unauthenticated\"\n},\n\"deploy-docker\": {\n  \"command\": \"./build-new-image.sh --dir dist/pdf/analog --image pdfun\",\n  \"parallel\": false,\n  \"dependsOn\": [\n    {\n      \"target\": \"copy\"\n    }\n  ]\n},\n```\n\n그래서 deploy 대상이 실행되면 두 개의 다른 명령이 트리거됩니다:\n\n```js\nnpx nx deploy-docker pdf\nnpx nx deploy-cloudrun pdf\n```\n\n이 명령들은 이어서 도커 이미지를 빌드하고 해당 이미지를 푸시한 후 Artifact Registry에 업로드된 이미지를 기반으로 Cloud Run 서비스를 배포할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n여기 결과입니다:\n\n```js\ndalenguyen$ yarn deploy\n\nyarn run v1.22.19\n$ npx nx affected -t deploy --base=main~1 --head=main\n\n NX   Running target deploy for 2 projects and 3\n NX   Running target deploy for 2 projects and 3 tasks they depend on\n\n   ✔  nx run domain:build (6초)\n———————————————————————————————————————————————\n   ✔  nx run pdf:build:production (17초)\n———————————————————————————————————————————————\n   ✔  nx run pdf:deploy (17초)\n   ✔  nx run pdf-on-create:deploy (29초)\n———————————————————————————————————————————————\n\n NX   2개의 프로젝트 및 해당 종속 작업들을 위한 타겟 deploy가 성공적으로 실행되었습니다 (37초)\n```\n\n로컬 환경에서 빌드 캐시를 활용하여 약 1분 내에 두 개의 서비스가 빌드되고 배포되었다는 것을 확인할 수 있어요!\n\n# 궁금한 점이 있으신가요?\n\n<div class=\"content-ad\"></div>\n\n문제가 있거나 궁금한 점이 있으면 언제든지 GitHub 레포지토리에 이슈를 생성해주세요. 또는 채팅을 통해 저와 대화할 수도 있어요. 도와드리고 피드백을 받는 것을 기쁘게 생각할 거예요.\n\n다음 파트도 기대해주세요. 그때까지 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-20-BuildingPDFOpenSourceServiceswithAngularGCPDeployservicestoCloudRun_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingPDFOpenSourceServiceswithAngularGCPDeployservicestoCloudRun_0.png","tag":["Tech"],"readingTime":5},{"title":"앵귤러 시그널 해킹하기","description":"","date":"2024-06-20 05:43","slug":"2024-06-20-HackingAngularSignals","content":"\n\n앵귤러 시그널이 무엇인지 살펴보고, 기능을 확장하고 디버깅하는 데 어떻게 활용할 수 있는지 알아봅시다.\n\n## 앵귤러 시그널이란\n\n앵귤러 시그널은 다음과 같은 메서드가 있는 함수입니다:\n\n```js\nconst $val = signal(0);\n\n// 함수:\nconst value = $val();\n\n// 객체:\n$val.set(4);\n$val.update((v) => v * 2);\n```\n\n<div class=\"content-ad\"></div>\n\n어떻게 가능한 걸까요? JavaScript에서는 함수가 객체이기 때문입니다:\n\n```js\n// 함수 선언\nconst double = (val: number) => val * 2;\n\n// 메소드 추가\ndouble.isEven = (number: number) => number % 2 === 0;\n\n// 객체처럼 사용하기\ndouble.isEven(15) // false\n\n// 함수처럼 사용하기\ndouble(8) // 16\n```\n\n어떻게 활용할 수 있을까요?\n\n우리는 가능합니다:\n\n<div class=\"content-ad\"></div>\n\n- 새로운 메서드 추가하기\n- 수정 사항을 가로챌 수 있도록 set() 및 update() 메서드를 오버라이딩하기\n- 신호의 내부 상태 변수 및 메서드 읽기\n- 읽기를 가로챌 프록시 신호 생성하기\n\n## 신호 확장하기\n\n가끔 변수를 신호로 사용해야 하지만 코드의 일부는 대신 Observable로 사용하려고 할 수 있습니다.\n\n다행히도 신호 및 Observable의 인터페이스는 메서드 이름에서 충돌이 없습니다. 그러니 하이브리드를 만들어 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```typescript\n// 여기서는 단순히 기존 객체에 새로운 메서드를 추가하고 있습니다.\n\n또는 Proxy 객체를 만들어서 요청된 메서드를 가지고 있지 않은 Signal에 대해서만 Observable의 메서드를 반환할 수 있습니다:\n\nexport function toObservableSignal<T>(s: Signal<T>) {\n\n  const obs = toObservable(s, options); \n   \n  return new Proxy(s, {\n    get(_, prop) {\n      if (prop in s) {\n        return (s as any)[prop];\n      }\n      return (obs as any)[prop];\n    }\n  });\n}\n\n<div class=\"content-ad\"></div>\n\n아래는 사용 예시입니다:\n\n@Component({\n  //...\n  template: `\n    <h4>Signal A: { a() }</h4>\n    <h4>Observable A: {a|async}</h4>\n    <h4>Signal C (computed() A*3): {c()}</h4>\n\n    {quote()}\n  `,\n})\nexport class App {\n  a = toObservableSignal(signal<number>(1));\n\n  // use as Observable\n  b = this.a.pipe(\n    debounceTime(500),\n    distinctUntilChanged(),\n    switchMap((v) => this.http.get('https://dummyjson.com/quotes/' + v))\n  );\n\n  // use as Signal\n  c = computed(() => this.a() * 3);\n\n  quote = toSignal(this.b);\n\n  increment() {\n    // \"a\" will not stop being a Signal after \n    // we used it as an Observable\n    this.a.update((v) => v + 1);\n  }\n\n  decrement() {\n    this.a.update((v) => Math.max(1, v - 1));\n  }\n}\n\nNG Extension Platform에서 이 기능을 찾을 수 있습니다. \n\n원하는 함수로 Signal을 확장할 수 있습니다. 여기서 상상력에는 거의 제한이 없습니다. 단, set, update, asReadonly라는 이름은 사용하지 않도록 주의하세요.\n\n<div class=\"content-ad\"></div>\n\n## 기존 메서드 재정의\n\n저희 Signal에 값을 입력 변환하거나 다른 곳에 정보를 복제하거나 디버깅을 위해 쓰기를 중간에서 가로채고 싶다고 가정해 봅시다.\n\nfunction skipNonEvenNumbers(s: WritableSignal<number>) {\n  const srcSet = s.set; // 재귀를 피하기 위해 소스 메서드가 필요합니다\n\n  s.set = (value: number) => {\n    if (value % 2 !== 0) {\n      console.warn('[set] skipping:', value);\n      return;\n    }\n    console.log('[set]:', value);\n    srcSet(value);\n  };\n  s.update = (updateFn: (value: number) => number) => {\n    const value = updateFn(s());\n    if (value % 2 !== 0) {\n      console.warn('[update] skipping:', value);\n      return;\n    }\n    console.log('[update]:', value);\n    srcSet(value);\n  };\n}\n\n사용 예시:\n\n<div class=\"content-ad\"></div>\n\n이 기법은 Reactive Storage: getWritableSignal()에서 사용됩니다.\n\n## 시그널 내부\n\nAngular 시그널은 단순히 함수가 아니라 객체입니다. 이 객체에는 흥미로운 데이터와 함수가 담긴 숨겨진 필드 SIGNAL이 있습니다. 이것을 가지고 있어서 좋고, 남용하지 않았으면 좋겠습니다. 왜냐하면 위의 기법들은 \"약간 꼼수적\"이었고, 아래의 기법들은 디버깅, 개발 도구 생성, 재미를 위해서만 사용할 수 있습니다.\n\n모든 Angular 시그널은 ReactiveNode를 확장합니다:\n\n<div class=\"content-ad\"></div>\n\n// packages/core/primitives/signals/src/graph.ts\n\nexport const REACTIVE_NODE: ReactiveNode = {\n  version: 0 as Version,\n  lastCleanEpoch: 0 as Version,\n  dirty: false,\n  producerNode: undefined,\n  producerLastReadVersion: undefined,\n  producerIndexOfThis: undefined,\n  nextProducerIndex: 0,\n  liveConsumerNode: undefined,\n  liveConsumerIndexOfThis: undefined,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {},\n};\n\n이렇게:\n\n// packages/core/primitives/signals/src/signal.ts\n\nexport const SIGNAL_NODE = {\n  ...REACTIVE_NODE,\n  equal: defaultEquals,\n  value: undefined,\n}\n\n하지만 실제로 Signal 객체가 인스턴스화되면 이들이 모두 직접적으로 포함되지 않습니다. 모두 Symbol을 이름으로 사용하는 필드 아래에 숨겨져 있습니다:\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// packages/core/primitives/signals/src/signal.ts\n\nexport function createSignal<T>(initialValue: T): SignalGetter<T> {\n  const node: SignalNode<T> = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  const getter = (() => {\n                   producerAccessed(node);\n                   return node.value;\n                 }) as SignalGetter<T>;\n\n  // 다음 줄은 SIGNAL 필드에 SignalNode를 추가합니다:\n  (getter as any)[SIGNAL] = node;\n  return getter;\n}\n```\n\n그래서 signal $value를 가지고 있고 SIGNAL 필드에 액세스하는 경우, SIGNAL_NODE가 가지고 있는 모든 필드를 얻게 됩니다.\n\n어떻게 사용할 수 있을까요?\n\n우리는 필드를 읽고 액세스를 가로채어 디버깅에 사용하거나 Signal 내부에서 무슨 일이 일어나는지를 설명하는 멋진 도구를 생성하는 데 사용할 수 있습니다. 종속성 그래프를 렌더링할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n심지어 일부 필드를 엑세서로 변환할 수도 있습니다:\n\n```js\nfunction getSignalVersion<T>(s: WritableSignal<T>): Signal<number> {\n  const node = s[SIGNAL];\n  const $version = signal(0);\n\n  Object.defineProperty(node, 'version', {\n    get: () => {\n      const v = untracked($version);\n      console.log('🟢 reading:', v);\n      return v;\n    },\n    set: (v) => {\n      untracked(() => $version.set(v));\n      console.log('🔴 writing:', v);\n    },\n  });\n\n  return $version.asReadonly();\n}\n```\n\nStackBlitz:\n\n또는 `effect()` 없이 Signal 읽기를 감시할 수 있는 프록시를 생성할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction watchSignalReads<T, M extends Signal<T> | WritableSignal<T>>(s: M): M {\n  const node = s[SIGNAL];\n  const newGetter = () => {\n    const value = s();\n    console.log('Read:', value);\n    return value;\n  };\n  (newGetter as any)[SIGNAL] = node;\n  if (s.hasOwnProperty('set')) {\n    const w = s as WritableSignal<T>;\n    newGetter.set = w.set;\n    newGetter.update = w.update;\n    newGetter.asReadonly = w.asReadonly;\n  }\n\n  return newGetter as M;\n}\n```\n\n사용 예시:\n\n다시 말하지만, 이를 \"배포 환경\"에서 사용하지 말고, 대신에 멋진 도구를 만들고 인정을 받아 Angular 생태계를 풍요롭게 하는 데 활용하길 바래요 😎","ogImage":{"url":"/assets/img/2024-06-20-HackingAngularSignals_0.png"},"coverImage":"/assets/img/2024-06-20-HackingAngularSignals_0.png","tag":["Tech"],"readingTime":6},{"title":"앵귤러 서비스를 활용한 깔끔한 코드","description":"","date":"2024-06-20 05:42","slug":"2024-06-20-CleanCodeUsingAngularServices","content":"\n\n서비스/추상화 계층 패턴을 추가하여 복잡성을 줄입니다.\n\n![이미지](/assets/img/2024-06-20-CleanCodeUsingAngularServices_0.png)\n\n앵귤러 애플리케이션이 초기화되기 전에 Keycloak 세부 정보를 가져오기 위해 APP_INITIALIZER를 구성합니다.\n\n```js\nimport { APP_INITIALIZER, Injectable } from '@angular/core';\nimport { KeycloakService } from './keycloak.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AppInitializer {\n  constructor(private keycloakService: KeycloakService) {}\n\n  initializeKeycloak(): () => Promise<any> {\n    return () => this.keycloakService.init();\n  }\n}\n\nexport function initializeApp(appInitializer: AppInitializer) {\n  return () => appInitializer.initializeKeycloak();\n}\n\nexport const appInitializerProviders = [\n  AppInitializer,\n  { provide: APP_INITIALIZER, \n    useFactory: initializeApp, \n    deps: [AppInitializer], \n    multi: true \n  }\n];\n```\n\n<div class=\"content-ad\"></div>\n\n나쁜 코드 예시:\n\n![이미지](/assets/img/2024-06-20-CleanCodeUsingAngularServices_1.png)\n\n모든 컴포넌트에 Keycloak DI를 추가하여 사용자가 버튼을 표시할 권한이 있는지 확인합니다. 기본 예제를 살펴보았지만 역할에 따라 숨겨질 수 있는 템플릿 부분이거나 제한된 로그인 사용자가 지정된 역할을 가지고 있지 않을 때 API 호출에 기반한 것이어야 합니다.\n\n```js\n// 테스트 A 컴포넌트\n\nimport { Component, OnInit } from '@angular/core';\nimport { KeycloakService } from 'keycloak-angular';\nimport { Role } from './role.enum';\n\n@Component({\n  selector: 'app-component-a',\n  template: `<button *ngIf=\"showAdminButton\">Admin Button</button>`\n})\nexport class TestAComponent implements OnInit {\n  showAdminButton = false;\n  userRoles: string[];\n\n  constructor(private keycloakService: KeycloakService) {\n    this.userRoles = this.keycloakService.getUserRoles();\n  }\n\n  ngOnInit() {\n    this.showAdminButton = this.userRoles.includes(Role.Admin);\n  }\n}\n\n// 테스트 B 컴포넌트\n\nimport { Component, OnInit } from '@angular/core';\nimport { KeycloakService } from 'keycloak-angular';\nimport { Role } from './role.enum';\n\n@Component({\n  selector: 'app-component-b',\n  template: `<button *ngIf=\"showProviderButton\">Provider Button</button>`\n})\nexport class TestBComponent implements OnInit {\n  showUserButton = false;\n  userRoles: string[];\n\n  constructor(private keycloakService: KeycloakService) {\n    this.userRoles = this.keycloakService.getUserRoles();\n  }\n\n  ngOnInit() {\n    this.showUserButton = this.userRoles.includes(Role.Provider);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 방식은 컴포넌트 내에서 인증 세부 정보에 직접 액세스하여 모범 사례를 위반합니다.\n\n제가 매우 기본적인 예제를 제공하고 있지만 중대형 프로젝트에서는 복잡한 로직을 처리하고 사용자 역할에 따라 기능 액세스를 부여해야 하는 경우가 있습니다. 인터페이스를 단순화하기 위한 래퍼 서비스 또는 패싸드 레이어를 사용하는 것이 매우 유익할 것입니다. 이를 통해 복잡성을 줄이고 유연성을 높일 수 있습니다.\n\n나쁜 코드의 문제점\n\n- 강한 결합: 컴포넌트에 직접 서드 파티 서비스를 주입하는 것은 해당 종속성과 강하게 결합될 수 있습니다.\n- 코드 중복: 각 컴포넌트가 사용자 역할을 가져오고 역할에 따라 권한을 확인하기 위해 각각 서드 파티 서비스를 주입하면 불필요한 중복이 발생합니다.\n- 테스트: 새로운 종속성을 주입하는 것은 컴포넌트를 테스트하려는 복잡도를 추가하므로 컴포넌트를 분리하고 단위 테스트를 위해 종속성을 모의로 처리하기가 어려워집니다. 각 단위 테스트에서 Keycloak 서비스와 메서드를 모의 처리해야 하므로 결국 더 많은 보일러플레이트 코드가 생성됩니다.\n- SRP 원칙 위반: 인증 논리를 처리하는 여러 컴포넌트로 인해 각 컴포넌트가 다중 로직을 처리하기 때문에 관리가 어려워지고 유지 보수가 더 어려워집니다.\n- 확장성: 비즈니스 로직을 업데이트하거나 특정 기능에 역할을 추가해야 하는 경우 해당 변경 사항이 필요한 모든 컴포넌트에서 업데이트해야 합니다.\n- 유연성: 다른 인증 공급자로 전환하려는 경우, 각 컴포넌트에 인증이 구현되어 있기 때문에 전환하기 어려우며 더 많은 작업이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n따라서 공통 인터페이스를 제공하고 단일 서비스 DI를 사용하는 공유 서비스 레이어를 소개하면, 로직을 1개의 레이어로 유지할 수 있으며, 더 나아가 SRP, 캡슐화 및 Keycloak에서 역할 로직을 가져오는 추상화 소프트웨어 원칙을 준수하는 데 도움이 됩니다. 예를 들어 각 구성 요소에서 Wrapper 메서드 대신 내부 구현 방식에 따라 역할을 가져오기 위해 구성 요소에서 역할 로직을 가져오지 않아야 합니다. 이렇게 하면 구성 요소는 역할을 어떻게 가져오는지 알 필요가 없습니다.\n\n좋은 코드 예시:\n\n![CleanCodeUsingAngularServices_2](/assets/img/2024-06-20-CleanCodeUsingAngularServices_2.png)\n\n사용자 권한 서비스\n\n<div class=\"content-ad\"></div>\n\n```ts\nimport { Injectable } from '@angular/core';\nimport { KeycloakService } from './keycloak.service';\nimport { Role } from './role.enum';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserAuthorizationService {\n  private userRoles: string[];\n\n  constructor(private keycloakService: KeycloakService) {\n    this.userRoles = this.keycloakService.getUserRoles();\n  }\n\n  hasRoleAdmin(): boolean {\n    return this.userRoles.includes(Role.Admin);\n  }\n\n  hasRoleUser(): boolean {\n    return this.userRoles.includes(Role.User);\n  }\n}\n```\n\n의존성 주입 서비스.\n\n```ts\n// 테스트 A 컴포넌트\n\nimport { Component, OnInit } from '@angular/core';\nimport { KeycloakService } from 'keycloak-angular';\nimport { Role } from './role.enum';\n\n@Component({\n  selector: 'app-component-a',\n  template: `<button *ngIf=\"showAdminButton\">Admin Button</button>`\n})\nexport class TestAComponent implements OnInit {\n  showAdminButton = false;\n\n  constructor(private userAuthorizationService: UserAuthorizationService) {}\n\n  ngOnInit() {\n    this.showAdminButton = this.userAuthorizationService.hasRoleAdmin()\n  }\n}\n\n// 테스트 B 컴포넌트\n\nimport { Component, OnInit } from '@angular/core';\nimport { KeycloakService } from 'keycloak-angular';\nimport { Role } from './role.enum';\n\n@Component({\n  selector: 'app-component-b',\n  template: `<button *ngIf=\"showUserButton\">User Button</button>`\n})\nexport class TestBComponent implements OnInit {\n  showUserButton = false;\n\n constructor(private userAuthorizationService: UserAuthorizationService) {\n    this.userRoles = this.userAuthorizationService.getUserRoles();\n  }\n\n  ngOnInit() {\n    this.showUserButton = this.userAuthorizationService.hasRoleUser()\n  }\n}\n```\n\n서비스 계층 또는 추상화 계층을 추가하면 모든 컴포넌트로 중복하는 로직을 간단하게 만들 수 있습니다. 이제 서비스가 권한 로직을 처리하고 컴포넌트는 서비스를 사용하여 권한을 확인하므로 권한을 가져오고 할당하는 데 명확한 (SoC)이 생깁니다. 컴포넌트는 비즈니스 로직을 분리하는 뿐만 아니라 테스트 관점에서도 도움이 됩니다. 모든 기본적인 작업이 제거되며, 이제 서비스는 독립적으로 테스트할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 블로그는 외부 라이브러리를 사용할 때 일부 추상화 계층에 대해 고려하는 좋은 실천 가이드를 안내합니다. 이 방법은 코드를 유지하는 데 도움이 되는 것뿐만 아니라 External library와 상호 작용하는 복잡성을 캡슐화합니다. 이 접근 방식은 Angular 애플리케이션 내에서 코드 조직, 유지 관리 및 유연성을 향상시킵니다.\n\n만약 이 글이 도움이 되었거나 새로운 것을 배웠다면, 좋은 독자의 박수를 얻는 것을 정말로 감사히 생각할 것입니다 👏 몇 초만 투자하면 됩니다.\n\n지원을 계속해 주시고 계속 배우세요. 🙏\n\n<div class=\"content-ad\"></div>\n\n저를 응원해 주시면 커피 한 잔 사주시는 방법이 있어요. ☕\n\n감사합니다 :)","ogImage":{"url":"/assets/img/2024-06-20-CleanCodeUsingAngularServices_0.png"},"coverImage":"/assets/img/2024-06-20-CleanCodeUsingAngularServices_0.png","tag":["Tech"],"readingTime":6},{"title":"앵귤러에서의 기능적인 라우트 가드","description":"","date":"2024-06-20 05:41","slug":"2024-06-20-FunctionalRouteGuardsinAngular","content":"\n\n<img src=\"/assets/img/2024-06-20-FunctionalRouteGuardsinAngular_0.png\" />\n\n# tldr;\n\nAngular v14.2에서 기능적 라우트 가드가 도입되어 Angular 애플리케이션의 일부를 보호하는 새로운 방법이 소개되었습니다. 이전에는 라우트 가드를 작성하는 유일한 방법이 클래스 기반 가드를 사용하는 것이었습니다. 클래스 기반 가드는 잘 작동했지만 사용하려면 많은 추가 설정이 필요했습니다.\n\n기능적 라우트 가드는 하나의 함수만 필요로 하며 별도의 파일에 작성하거나 필요한 경우 라우트에 대해 인라인으로 작성할 수 있습니다. 이 글에서는 라우트 가드의 몇 가지 예시를 보여드리겠지만, 더 중요한 것은 기능적 라우트 가드에 대한 테스트를 작성하는 방법을 보여드릴 것입니다. 클래스 기반 가드를 기능적으로 변환하는 작업 중에 가드를 테스트하는 방법에 대한 정보를 찾을 수 없어 고민했는데, 이 글이 다른 이들을 위한 안내서 역할을 해줄 것을 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n# 기능적 가드 작성하기\n\n많은 면에서 기능적 라우트 가드를 작성하는 것이 이전보다 훨씬 쉽습니다. 인터페이스를 구현할 필요도 없고 그러한 것을 기억할 필요도 없습니다. 필요한 것은 함수를 반환하는 함수뿐입니다. 내부 함수는 CanMatchFn 또는 CanActivateFn과 같은 특정 타입의 함수입니다. 그러나 당신이 반환하는 함수의 타입을 정확히 알 필요는 없습니다. 여기에 canActivate 가드로 사용할 수 있는 매우 간단한 가드의 예가 있습니다:\n\n```js\nexport function authenticationGuardArrow = () => inject(AuthService).isAuthenticated()\n```\n\n이 가드에서는 AuthService를 주입하고 isAuthenticated 메서드를 호출하여 사용자가 지정된 경로로 계속 진행할 수 있는지 확인합니다. 이 경우 가드의 내부 메서드에서 반환되는 함수의 타입이 명시적으로 정의되지 않았다는 점을 주목해 주세요.\n\n<div class=\"content-ad\"></div>\n\n여기에는 인증 가드의 명확한 버전이 있어요:\n\n```js\nexport function authenticationGuard(): CanActivateFn {\n  return () => {\n    const oauthService: AuthService = inject(AuthService);\n    \n    if (oauthService.hasAccess() ) {\n      return true;\n    }\n    oauthService.login();\n    return false;\n  };\n}\n```\n\n이 가드의 버전에서는 사용자가 액세스 권한이 있는지 확인합니다. 권한이 있는 경우 경로로 계속합니다. 사용자에게 액세스 권한이 없는 경우에는 로그인 플로우를 시작하고 경로로 이동을 막습니다. CanActivateFn에는 ActivatedRouteSnapshot와 RouterStateSnapshot이라는 두 가지 선택적 매개변수가 있습니다. 이 매개변수들을 사용하지 않기 때문에 포함되지 않았습니다.\n\n함수형 라우트 가드를 사용하는 또 다른 쉬운 방법은 라우트 가드로 데이터를 전달해야 할 때입니다. 이 예시에서는 어떤 플래그를 확인해야 하는지와 필요한 경우 리디렉션할 위치를 알아야 하는 피처 플래그 가드를 살펴봅시다:\n\n<div class=\"content-ad\"></div>\n\n```ts\nexport function featureFlagGuard(\n  flagName: string,\n  redirectRoute: string\n): CanActivateFn {\n  return () => {\n    const featureFlagsService: FeatureFlagsService =\n      inject(FeatureFlagsService);\n    const router: Router = inject(Router);\n    const isFlagEnabled = featureFlagsService.isFeatureEnabled(flagName);\n    \n    return isFlagEnabled || router.createUrlTree([redirectRoute]);\n  };\n}\n```\n\n이 경우, featureFlagGuard는 두 가지 인수를 취하는데요, 확인할 플래그와 리디렉션 경로입니다. 플래그가 활성화되어있으면 사용자는 경로로 이동할 수 있습니다. 그렇지 않으면 제공된 경로로 리디렉션됩니다.\n\n이전에는 클래스 기반 경로의 경우이 유형의 가드를 사용하려면 매개변수를 라우트 데이터 객체에 전달해야 했습니다. 이 방법이 훨씬 간단하며 그게 무슨 일이 벌어지고 있는지 더 명확합니다.\n\n# 라우트에 함수형 라우트 가드 추가하기\n\n\n<div class=\"content-ad\"></div>\n\n한 번 함수형 라우트 가드를 작성했다면, 주어진 라우트에 적용해야 합니다. 좋은 점은 클래스 기반 라우트와 본질적으로 동일하다는 것입니다. 그러나 약간의 차이가 있습니다. 만약 당신의 함수가 위에서 보여준 authenticationGuardArrow 함수처럼 보인다면, 다음과 같이 라우트에 추가할 수 있습니다:\n\n```js\nconst routes: Route[] = [\n  { path: 'home', component: HomeComponent, canActivate: [authenticationGuardArrow]}\n]\n```\n\n이 예제에서 이전에 했던 것과 거의 같아 보입니다. 가드는 그냥 canActivate 배열에 추가됩니다. 가드가 화살표 함수를 반환하기 때문에, 가드는 자동으로 호출됩니다. 그러나 위에서 언급한 다른 두 가드에서는 함수를 명시적으로 호출해야 합니다.\n\n```js\nconst routes: Route[] = [\n  { path: 'home', component: HomeComponent, canActivate: [authenticationGuard()]},\n  { path: 'feature', component: HomeComponent, canActivate: [featureFlagGuard('checkFlag', '/home')]}\n]\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 이전과 같이 구성 요소에 가드를 추가하지만, 실제로 실행하려면 해당 함수를 호출해야 합니다.\n\n클래스를 기반으로 하는 가드와 마찬가지로 이러한 새로운 함수형 가드도 부울값, UrlTrees, Promises 및 Observables를 반환할 수 있습니다.\n\n# 라우트 가드 테스트\n\n가드를 작성한 다음의 다음 단계는 해당 가드에 대한 테스트를 추가하는 것입니다. 여기서 조금 막혔다가 다른 사람들에게 도움이 될 것 같아요. 이러한 테스트는 새로운 RouterTestingHarness를 사용하므로 Angular v15.2 이상이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 RouterTestingHarness를 사용하면 테스트가 실제 라우터가 생성된 것처럼 작동하며, 경비를 선언하고 특정 경로에 도달할 수 있는지 여부를 확인할 수 있습니다. 이를 위해서는 일반적으로 Angular 단위 테스트를 작성할 때 사용하지 않는 TestBed 사용이 필요합니다. 하지만 실제로 매우 부드럽고 사용하기 쉽습니다.\n\n위 경비에 대해 작성한 테스트의 몇 가지 예시를 제공하겠습니다. 이를 참고로 사용할 수 있습니다.\n\n```js\n// authentication.guard.spec.ts\n\n@Component({ standalone: true, template: \"\" })\nclass DashboardComponent {}\ndescribe(\"AuthenticationGuard\", () => {\n  let routes: Route[];\n\n  beforeEach(() => {\n    routes = [\n      {\n        path: \"dashboard\",\n        canActivate: [AuthenticationGuard()],\n        component: DashboardComponent,\n      },\n    ];\n  });\n\n  it(\"should initiate the login flow if there is no valid token\", async () => {\n    const mockOAuthService = {\n      hasValidAccessToken: jest.fn().mockReturnValue(false),\n      initCodeFlow: jest.fn(),\n    };\n    const mockAuthRedirectService = { saveRoute: jest.fn() };\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [\n        { provide: OAuthService, useValue: mockOAuthService },\n        { provide: AuthRedirectService, useValue: mockAuthRedirectService },\n        provideRouter(routes),\n      ],\n    });\n    await RouterTestingHarness.create(\"/dashboard\");\n    expect(mockOAuthService.initCodeFlow).toHaveBeenCalled();\n    expect(mockAuthRedirectService.saveRoute).toHaveBeenCalledWith(\n      \"/dashboard\"\n    );\n  });\n\n  it(\"should allow access to the dashboard if the token is valid\", async () => {\n    const mockOAuthService = {\n      hasValidAccessToken: jest.fn().mockReturnValue(true),\n      initCodeFlow: jest.fn(),\n    };\n    const mockAuthRedirectService = { saveRoute: jest.fn() };\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [\n        { provide: OAuthService, useValue: mockOAuthService },\n        { provide: AuthRedirectService, useValue: mockAuthRedirectService },\n        provideRouter(routes),\n      ],\n    });\n    await RouterTestingHarness.create(\"/dashboard\");\n    expect(TestBed.inject(Router).url).toEqual(\"/dashboard\");\n  });\n\n  it(\"should allow access to the dashboard if the token is not valid but there is a code query param\", async () => {\n    const mockOAuthService = {\n      hasValidAccessToken: jest.fn().mockReturnValue(false),\n      initCodeFlow: jest.fn(),\n    };\n    const mockAuthRedirectService = { saveRoute: jest.fn() };\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [\n        { provide: OAuthService, useValue: mockOAuthService },\n        { provide: AuthRedirectService, useValue: mockAuthRedirectService },\n        provideRouter(routes),\n      ],\n    });\n    await RouterTestingHarness.create(\"/dashboard?code=1234\");\n    expect(TestBed.inject(Router).url).toEqual(\"/dashboard?code=1234\");\n  });\n});\n```\n\n다음으로 여기에는 기능 플래그 가드에 대한 테스트가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({ standalone: true, template: \"\" })\nclass AdminComponent {}\n@Component({ standalone: true, template: \"\" })\nclass LoginComponent {}\n\ndescribe(\"FeatureFlagGuard\", () => {\n  let routes: Route[];\n  let httpMock: HttpTestingController;\n\n  beforeEach(() => {\n    routes = [\n      {\n        path: \"test\",\n        canActivate: [FeatureFlagGuard(\"test\", \"/\")],\n        component: AdminComponent,\n      },\n      { path: \"home\", component: LoginComponent },\n    ];\n  });\n\n  it(\"should route back to the home route if the flag is not present and it defaults to off\", async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        HttpClientTestingModule,\n        SharedUtilitiesFeatureFlagsModule.forRoot({\n          defaultToFlagOff: true,\n          jsonUrl: \"/assets/test.config.json\",\n        }),\n      ],\n      providers: [provideRouter(routes)],\n    });\n    httpMock = TestBed.inject(HttpTestingController);\n    const mockRequest = httpMock.expectOne(\"/assets/test.config.json\");\n    mockRequest.flush({});\n    await RouterTestingHarness.create(\"/test\");\n    expect(TestBed.inject(Router).url).toEqual(\"/\");\n  });\n\n  it(\"should route to the test route if the flag is not present and it does not default to off\", async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        HttpClientTestingModule,\n        SharedUtilitiesFeatureFlagsModule.forRoot({\n          defaultToFlagOff: false,\n          jsonUrl: \"/assets/test.config.json\",\n        }),\n      ],\n      providers: [provideRouter(routes)],\n    });\n    httpMock = TestBed.inject(HttpTestingController);\n    const mockRequest = httpMock.expectOne(\"/assets/test.config.json\");\n    mockRequest.flush({});\n    await RouterTestingHarness.create(\"/test\");\n    expect(TestBed.inject(Router).url).toEqual(\"/test\");\n  });\n\n  it(\"should route to the test route if the flag is turned on\", async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        HttpClientTestingModule,\n        SharedUtilitiesFeatureFlagsModule.forRoot({\n          defaultToFlagOff: true,\n          jsonUrl: \"/assets/test.config.json\",\n        }),\n      ],\n      providers: [provideRouter(routes)],\n    });\n    httpMock = TestBed.inject(HttpTestingController);\n    const mockRequest = httpMock.expectOne(\"/assets/test.config.json\");\n    mockRequest.flush({ test: true });\n    await RouterTestingHarness.create(\"/test\");\n    expect(TestBed.inject(Router).url).toEqual(\"/test\");\n  });\n\n  it(\"should not route to the test route if the flag is turned off\", async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        HttpClientTestingModule,\n        SharedUtilitiesFeatureFlagsModule.forRoot({\n          defaultToFlagOff: true,\n          jsonUrl: \"/assets/test.config.json\",\n        }),\n      ],\n      providers: [provideRouter(routes)],\n    });\n    httpMock = TestBed.inject(HttpTestingController);\n    const mockRequest = httpMock.expectOne(\"/assets/test.config.json\");\n    mockRequest.flush({ test: false });\n    await RouterTestingHarness.create(\"/test\");\n    expect(TestBed.inject(Router).url).toEqual(\"/\");\n  });\n});\n```\n\n이러한 테스트들은 테스트를 위한 라우팅 구성뿐만 아니라 필요할 때 주입된 서비스에 대한 가짜 값을 제공하기 위한 것을 보여줍니다. 가드가 작동하는지 여부를 확인하는 방법에 대한 예제도 볼 수 있습니다.\n\n좋은 테스트 커버리지를 갖고 가드가 예상대로 작동하는지 확인하는 것은 앱의 유지관리에 매우 중요합니다. 이 내용이 다른 사람들이 애플리케이션을 개발하는 데 도움이 되기를 바랍니다.\n\n# 주의사항\n\n<div class=\"content-ad\"></div>\n\nOne red flag to be aware of is ensuring that the `inject` method is placed correctly. It should be used inside the inner `return` method, not the outer one:\n\n```js\nexport function testGuard {\n  // Don't use inject here\n\n  return () => {\n    // Use inject here\n  }\n}\n```\n\nIf you use `inject` in the outer function, you may encounter an error as shown below:\n\n<img src=\"/assets/img/2024-06-20-FunctionalRouteGuardsinAngular_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n기능성 라우트 가드의 소개가 어떤 큰 변화인지 정말 확신이 없었지만, 이 방법으로 가드를 작성하는 것을 선호하는 것 같습니다. 중요한 점은 나는 이 방법을 선호하든 말든 중요하지 않습니다. 왜냐하면 클래스 기반 라우터는 폐기될 예정이기 때문입니다. 기능성 라우트 가드가 가까운 미래의 유일한 방법이 될 것입니다. 가드를 변환하는 데 미리 준비하는 것을 제안하며, 이 문서가 해당 작업에 도움이 되길 바랍니다.","ogImage":{"url":"/assets/img/2024-06-20-FunctionalRouteGuardsinAngular_0.png"},"coverImage":"/assets/img/2024-06-20-FunctionalRouteGuardsinAngular_0.png","tag":["Tech"],"readingTime":11},{"title":"앵귤러에서 환경 변수를 저장하기 위해 env 파일을 사용하는 방법","description":"","date":"2024-06-20 05:40","slug":"2024-06-20-UsingenvtostoreenvironmentvariablesinAngular","content":"\n\n\n![이미지](/assets/img/2024-06-20-UsingenvtostoreenvironmentvariablesinAngular_0.png)\n\nAPI 키가 포함된 Angular 프로젝트를 작업한 적이 있나요? 그리고 API 키를 사용자 정의 환경 변수에 저장하고 싶지 않았나요?\n\n다양한 이유가 있을 수 있지만, 기본적인 사용 사례는 항상 해당 키를 깃 저장소에 노출시키지 않고자 하는 것입니다.\n\n이 방법을 사용하고 싶은 이유와 장점은 많지만, 그에 대해 자세히 다루지는 않겠습니다. 왜냐하면 이 글을 읽고 계시다면 이미 해당 접근 방식의 이점을 알고 있으며, 이 방법이 필요하기 때문이라고 생각하기 때문입니다.\n\n\n<div class=\"content-ad\"></div>\n\n얘기는 그만하고 이제 시작해봐요. 이 글은 이미 기존의 앵귤러 프로젝트가 있다고 가정합니다. 따라서 이 글은 역순 접근 방식을 따를 것입니다. 즉, 최종 결과물부터 작업을 진행할 겁니다.\n\n최종 결과물은 무엇일까요? 최종 결과물은 아래와 같은 코드를 작성할 수 있도록 하는 것입니다:\n\nSTEP 1: 앱의 app.component.ts를 수정하세요.\n\n그리고 프로세스 환경에서 값을 읽어와 앵귤러 앱에 적용해보는 거죠.\n\n<div class=\"content-ad\"></div>\n\nprocess.env이란 무엇인가요? process.env 전역 변수는 노드에 의해 실행 시간에 응용 프로그램에서 사용할 수 있도록 주입되며, 시작할 때 응용 프로그램이 있는 시스템 환경의 상태를 나타냅니다. 예를 들어, 시스템에 PATH 변수가 설정되어 있으면 이 변수는 process.env를 통해 액세스할 수 있게 됩니다.\n\n위의 코드 스니펫을 실행하면 대부분의 경우 컴파일 오류가 발생할 가능성이 높습니다. 기본적으로 angular는 process.env가 무엇을 의미하는지 이해하지 못하기 때문입니다. 컴파일 오류를 해결하려면 패키지를 설치해야 합니다.\n\n단계 2: @types/node를 설치합니다.\n\n그런 다음 아래와 같이 tsconfig.app.json 파일을 수정해야 합니다. 이렇게 하면 angular가 노드 코드 \"process.env\"를 이해합니다.\n\n<div class=\"content-ad\"></div>\n\n**단계 3:** tsconfig.app.json을 수정합니다.\n\n이제 \"ng serve\"를 실행할 때 어플리케이션은 컴파일 오류에 빠지지 않지만, 여전히 값이 정의되지 않은 곳에서 읽을 수 없는 런타임 오류가 발생합니다. 이 문제를 해결하기 위해 몇 가지 패키지를 더 설치해야 합니다.\n\n**단계 4:** @angular-builders/custom-webpack과 dotenv-webpack을 설치합니다.\n\n**단계 5:** angular.json을 수정합니다.\n\n<div class=\"content-ad\"></div>\n\nangular.json 파일을 수정해야 합니다. projects.architect.build를 찾아서 아래와 같이 builder의 값 수정해야 합니다. 또한 options 속성과 값을 추가해야 합니다.\n\nprojects.architect.serve를 찾아서 builder의 값 수정해야 합니다.\n\n단계 6: custom-webpack.config.ts 파일 생성\n\n이제 src 폴더에 custom-webpack.config.ts 파일을 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n**단계 7: .env 파일 생성**\n\n루트 폴더에 .env 파일을 만들어주세요. 다음 형식으로 선언할 모든 변수를 추가할 수 있습니다. 이 파일은 우리의 프로세스 환경 변수 값을 보관합니다.\n\n**단계 8: .gitignore 파일에 .env 추가**\n\n.gitignore 파일에 .env를 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n이제 제어 C를 사용하여 노드 서버를 다시 시작하고 다시 \"ng serve\"를 실행해야 합니다.\n\n보너스:\n\n아래와 같이 process.env를 사용하여 environment.prod.ts 또는 environment.ts에서 환경을 설정할 수 있습니다.\n\n그런 다음 app.component.ts 파일은 다음과 같이 보일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n앱 자체에 비밀을 저장하는 것은 매우 좋지 않은 습관입니다. 그래서 프론트엔드이든 백엔드 앱이든 상관없습니다. 앱 비밀은 어떤 경우에도 공개되어서는 안 됩니다. 그래서 대부분의 호스팅 서비스에는 환경 변수를 노출시키지 않고 설정할 수 있는 기능이 있거나 보안 관리를 위해 Vault와 같은 서비스를 사용하는 경우가 많습니다.","ogImage":{"url":"/assets/img/2024-06-20-UsingenvtostoreenvironmentvariablesinAngular_0.png"},"coverImage":"/assets/img/2024-06-20-UsingenvtostoreenvironmentvariablesinAngular_0.png","tag":["Tech"],"readingTime":3},{"title":"시그널 signal, computed, effect을 테스트하는 방법은 무엇인가요","description":"","date":"2024-06-20 05:37","slug":"2024-06-20-HowdoItestSignalssignalcomputedeffect","content":"\n\n![image](/assets/img/2024-06-20-HowdoItestSignalssignalcomputedeffect_0.png)\n\n가벼운 \"반응형 기본 요소\"로서의 신호는 Angular 애플리케이션의 미래를 형성할 것입니다. 이 글을 쓰는 시점에서 signal() 및 computed()는 안정적이며, effect()는 개발자 미리보기 상태입니다.\n\n개발자 미리보기는 불안정한 기능을 가지고 있다는 것이 아니라 Angular 팀이 주요 버전 내에서 파괴적인 변경 사항을 도입할 수 있다는 것을 의미합니다. 해당 기능이 안정적이지 않다면 실험적인 레이블이 달려 있을 것입니다.\n\n특히 신호 입력과 함께, 신호는 일상적인 작업에서 더 많이 사용되고 있습니다. 이제 신호를 코드베이스에 통합하는 것을 고려할 때입니다.\n\n<div class=\"content-ad\"></div>\n\n그것은 우리가 테스트를 작성할 수 있어야 한다는 것을 요구합니다.\n\n시각적으로 더 잘 배우시는 분을 위해 영상이 준비되어 있습니다:\n\n# 신호 및 반응력 개요\n\ncomputed()와 effect()를 사용하여 파생된 신호를 생성하거나 신호의 값이 변경될 때 부수효과를 실행합니다. 그것이 신호의 반응성입니다.\n\n<div class=\"content-ad\"></div>\n\nRxJs와 비교할 때 반응성은 수동 구독이 필요하지 않습니다. Angular가 대신해줍니다.\n\nsignal()이나 computed()으로 생성된 신호는 의존성 주기가 발생하는 반응적인 컨텍스트 안에서 실행되어야 합니다. Angular에서는 두 가지가 있습니다:\n\n- 컴포넌트의 템플릿\n- effect() 함수\n\n다시 말해, 템플릿이나 effect() 안에서 Signal을 호출할 때마다 Signal은 반응성을 갖게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\"Reactive Signal(반응형 신호)”이 변경되면, 그 신호는 computed(), effect() 또는 템플릿을 구독하는 소비자들에게 알릴 것입니다. computed()은 더 많은 소비자들을 가질 수도 있고, 그 소비자들도 다시 소비자들을 가질 수 있습니다.\n\n반응형 컨텍스트에 따라 DOM 업데이트(템플릿) 또는 사이드 이펙트(effect() 실행)가 발생합니다.\n\n변경 감지(Change Detection) 중에 반응형 컨텍스트가 실행됩니다: 마지막 값만 통과됩니다. 변화 감지 실행 사이에 신호가 여러 번 변경되더라도 마지막 값을 처리합니다. 즉, computed(), effect(), 그리고 템플릿은 중간 값이 아닌 마지막 값을 처리합니다.\n\n이 동작은 프론트엔드 프레임워크의 관점에서 신호를 보면 완전히 이해할 수 있습니다. 만약 세 번의 동기(중간) 변경이 있다면, 왜 세 번 DOM을 업데이트해야 할까요? 기술적으로 가능하더라도 서로 다른 렌더링 프레임에서 값이 변경되기 때문에 최종 사용자는 새로운 값이 보이지 않을 것입니다. 신호가 “안정 상태”에 도달할 때까지 기다린 후에 DOM을 업데이트하는 것이 훨씬 나은 접근입니다.\"\n\n<div class=\"content-ad\"></div>\n\n이 동작은 \"Glitch-free effect\" 또는 \"Push/Pull\"로 알려져 있어요.\n\n어쩌면 이 애니메이션이 \"Glitch-free effect\"를 이해하는 데 도움이 될 수도 있어요.\n\n# 테스트 대상 구성 요소\n\n저희 구성 요소는 온라인 쇼핑몰의 바구니입니다. 사용자가 제품 수량을 증가시키거나 감소시킬 수 있는 곳이에요:\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n  selector: 'app-basket',\n  template: `<h2>Basket</h2>\n    <div class=\"w-[640px]\">\n      <div class=\"grid grid-cols-4 gap-4 auto-cols-fr\">\n        <div class=\"font-bold\">이름</div>\n        <div class=\"font-bold\">가격</div>\n        <div class=\"font-bold\">수량</div>\n        <div>&nbsp;</div>\n        @for (product of products(); track product.id) {\n          <div>{ product.name }</div>\n          <div>{ product.price }</div>\n          <div>{ product.amount }</div>\n          <div>\n            <button\n              mat-raised-button\n              (click)=\"decrease(product.id)\"\n              data-testid=\"btn-decrease\"\n            >\n              <mat-icon>remove</mat-icon>\n            </button>\n            <button\n              mat-raised-button\n              (click)=\"increase(product.id)\"\n              data-testid=\"btn-increase\"\n            >\n              <mat-icon>add</mat-icon>\n            </button>\n          </div>\n        }\n\n        <div class=\"font-bold\">총 가격</div>\n        <div class=\"font-bold\" data-testid=\"total\">{ totalPrice() }</div>\n      </div>\n    </div>`,\n  standalone: true,\n  imports: [MatButton, MatIcon],\n})\nexport default class BasketComponent {\n  products = signal([\n    { id: 1, name: '커피', price: 3, amount: 1 },\n    { id: 2, name: '슈니첼', price: 15, amount: 1 },\n  ]);\n\n  syncService = inject(SyncService);\n\n  constructor() {\n    effect(() => this.syncService.sync(this.products()));\n  }\n\n  totalPrice = computed(() =>\n    this.products().reduce(\n      (total, product) => total + product.price * product.amount,\n      0,\n    ),\n  );\n\n  decrease(id: number) {\n    this.#change(id, (product) =>\n      product.amount > 0 ? { ...product, amount: product.amount - 1 } : product,\n    );\n  }\n\n  increase(id: number) {\n    this.#change(id, (product) => ({ ...product, amount: product.amount + 1 }));\n  }\n\n  #change(id: number, callback: (product: Product) => Product) {\n    this.products.update((products) =>\n      // some logic to update the products\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@Injectable({ providedIn: 'root' })\nexport class SyncService {\n  sync(products: Product[]) {\n    console.log(products);\n  }\n}\n```\n\n그렇게 많지 않아요😀, 하지만 가능한 짧은 예제를 유지하고 싶습니다.\n\n# 변경 감지를 사용한 테스트\n\nSignals의 핵심인 변경 감지의 중요성을 고려하면, 변경 감지가 테스트의 일부인 경우 테스트가 훨씬 쉽다는 것이 명백해질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n우리의 테스트가 DOM을 통해 Component와 통신하고 TestBed.createComponent를 통해 Component를 생성할 때 항상 발생하는 경우입니다.\n\n## computed() 테스트\n\n이것은 DOM을 통해 총 가격을 확인하는 테스트입니다:\n\n```js\nit('상품의 수량을 증가시켜야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  fixture.detectChanges();\n\n  const total: HTMLDivElement = fixture.debugElement.query(\n    By.css('[data-testid=\"total\"]'),\n  ).nativeElement;\n  expect(total.textContent).toBe('18');\n\n  fixture.debugElement\n    .query(By.css('[data-testid=\"btn-increase\"]'))\n    .nativeElement.click();\n  fixture.detectChanges();\n\n  expect(total.textContent).toBe('21');\n});\n```\n\n<div class=\"content-ad\"></div>\n\n그 테스트가 예상대로 작동합니다. 깜짝 놀랄 일이 없네요!\n\n변경 감지를 올바른 위치에서 실행하면 모든 것이 잘 됩니다. 그 올바른 위치는 클릭과 같은 이벤트 이후와 컴포넌트를 초기화할 때입니다.\n\n## effect() 테스트\n\neffect()를 테스트에 포함하는 경우 약간 복잡해집니다.\n\n<div class=\"content-ad\"></div>\n\neffect() 함수가 SyncService를 실행하기 때문에 그 호출 횟수를 세고 싶습니다.\n\n매 변경 감지 시, effect() 함수는 products의 값이 변경되었는지 확인합니다. 값이 변경되면 effect() 함수는 SyncService를 실행합니다.\n\n우리는 DOM을 통해 SyncService의 실행을 단언할 수 없습니다. 그래서 SyncService 인스턴스에 스파이를 적용해야 합니다. 이를 위해 컴포넌트 인스턴스에 접근할 수 있어야 합니다.\n\n업데이트된 테스트:\n\n<div class=\"content-ad\"></div>\n\n```js\nit('SyncService를 실행해야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  fixture.detectChanges();\n\n  expect(spy).toHaveBeenCalledTimes(1);\n});\n```\n\n우리는 effect()가 제품이 변경되고 Change Detection이 실행될 때만 실행되는 것을 확인할 수 있습니다.\n\n다음 두 가지 테스트가 실패해야 합니다:\n\n```js\nit('SyncService를 실행해야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n\n  // Change Detection이 실행되지 않았습니다\n  expect(spy).toHaveBeenCalledTimes(1); \n})\n\nit('SyncService를 실행해야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  fixture.detectChanges();\n\n  expect(spy).toHaveBeenCalledTimes(1);\n  \n  // 총합이 변경되지 않아서 효과가 없습니다\n  fixture.detectChanges();\n  expect(spy).toHaveBeenCalledTimes(2); \n})\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 바구니에 있는 금액을 늘릴 수 있고, 변경 감지의 또 다른 실행 후에 SyncService가 두 번 실행된 것을 볼 수 있어야 합니다:\n\n```js\nit('SyncService를 실행해야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  fixture.detectChanges();\n\n  expect(spy).toHaveBeenCalledTimes(1);\n\n  const total: HTMLDivElement = fixture.debugElement.query(\n    By.css('[data-testid=\"total\"]'),\n  ).nativeElement;\n  expect(total.textContent).toBe('18');\n\n  fixture.debugElement\n    .query(By.css('[data-testid=\"btn-increase\"]'))\n    .nativeElement.click();\n\n  fixture.detectChanges();\n  expect(spy).toHaveBeenCalledTimes(2);\n});\n```\n\n다음으로 변경 감지가 사용 불가능한 다른 테스트 유형으로 넘어가 봅시다.\n\n# 변경 감지 없이 테스트하기\n\n<div class=\"content-ad\"></div>\n\nBasketComponent의 로직을 BasketService로 추출했습니다:\n\n```js\n@Injectable({ providedIn: 'root' })\nexport class BasketService {\n  products = signal([\n    {\n      id: 1,\n      name: 'Coffee',\n      price: 3,\n      amount: 1,\n    },\n    { id: 2, name: 'Schnitzel', price: 15, amount: 1 },\n  ]);\n\n  syncService = inject(SyncService);\n\n  constructor() {\n    effect(() => this.syncService.sync(this.products()));\n  }\n\n  totalPrice = computed(() =>\n    this.products().reduce(\n      (total, product) => total + product.price * product.amount,\n      0,\n    ),\n  );\n\n  decrease(id: number) {\n    this.#change(id, (product) =>\n      product.amount > 0 ? { ...product, amount: product.amount - 1 } : product,\n    );\n  }\n\n  increase(id: number) {\n    this.#change(id, (product) => ({ ...product, amount: product.amount + 1 }));\n  }\n\n  #change(id: number, callback: (product: Product) => Product) {\n    this.products.update((products) =>\n      products.map((product) => {\n        if (product.id === id && product.amount > 0) {\n          return callback(product);\n        } else {\n          return product;\n        }\n      }),\n    );\n  }\n}\n\n@Component({\n  selector: 'app-basket',\n  template: '<!-- 이전과 같은 템플릿 -->',\n  standalone: true,\n  imports: [MatButton, MatIcon],\n})\nexport default class BasketComponent {\n  basketService = inject(BasketService);\n\n  products = this.basketService.products;\n  totalPrice = this.basketService.totalPrice;\n\n  decrease(id: number) {\n    this.basketService.decrease(id);\n  }\n\n  increase(id: number) {\n    this.basketService.increase(id);\n  }\n}\n```\n\n이전의 테스트는 유지했습니다. 이제 Component와 두 개의 Service를 모두 커버합니다.\n\nBasketService만을 커버하는 테스트는 어떻게 작성할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n우리는 Component가 없으므로 이제 fixture.detectChanges()를 실행할 수 없습니다. 따라서 ComponentFixture도 없습니다.\n\n## computed() 테스트\n\ntotalPrice Signal을 확인하는 SignalService 테스트는 다음과 같이 보일 것입니다:\n\n```js\nit('BasketService를 테스트해야 합니다', () => {\n  const basketService = TestBed.inject(BasketService);\n  expect(basketService.totalPrice()).toBe(18);\n\n  basketService.increase(1);\n  expect(basketService.totalPrice()).toBe(21);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n위의 테스트는 작동합니다. 왜냐하면 totalPrice를 반응적으로 만들려면 변경 감지 실행이 필요한 것 아닌가요?\n\n맞아요. 그렇지만 우리의 경우에는 totalPrice를 반응적인 방식으로 사용하지 않아요. 우리는 totalPrice를 직접 호출해요.\n\ncomputed()를 기반으로 한 Signal은 언제든지, 종속성이 변경되었는지 알 수 있고 (즉, 더티 상태인지), 다시 처리해야 해요.\n\n다시 처리를 시작하려면, 누군가가 그 값을 요청할 때 까지 기다려야 해요.\n\n<div class=\"content-ad\"></div>\n\n'컴포넌트 테스트에서 \"호출자\"는 변경 감지였습니다. 테스트에서 우리가 그것을 했죠.\n\n## effect() 테스트하기\n\ncomputed() 신호는 변경 감지 없이 간단히 테스트할 수 있지만, 실제 어려움은 effect()에서 발생합니다.\n\ncomputed()과 마찬가지로 effect()는 내부적으로 먼저 변경 유무를 알고 있습니다(의존성 중 하나가 값이 변경되었을 경우). 유감스럽게도 computed() 신호처럼 접근할 수는 없습니다.'\n\n<div class=\"content-ad\"></div>\n\nAngular 16에서 effect()를 테스트하는 유일한 방법은 Service를 \"Helper Component\"로 감싸는 것이었습니다. 그러나 Angular 17부터는 새로운 함수가 등장했습니다. 이 함수는 effect를 \"호출\"합니다: TestBed.flushEffects().\n\n이제 실제로 코드를 보겠습니다:\n\n```js\nit('BasketService를 테스트해야 합니다', () => {\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n\n  const basketService = TestBed.inject(BasketService);\n  TestBed.flushEffects();\n\n  basketService.increase(1);\n  TestBed.flushEffects();\n  expect(spy).toHaveBeenCalledTimes(2);\n});\n```\n\n다시 한 번 강조하면 Component 테스트와 동일한 동작을 볼 수 있습니다. effect()를 실행하려면 두 가지가 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n1. effect() 함수는 더러워야 하고\n2. \"액티브 엑세스\"가 있어야 합니다.\n\n이 테스트들은 다시 실패할 것입니다:\n\n```js\nit('BasketService를 테스트해야 합니다', () => {\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  TestBed.inject(BasketService);\n\n  // effect가 실행되지 않았습니다\n  expect(spy).toHaveBeenCalledTimes(1);\n});\n\nit('BasketService를 테스트해야 합니다', () => {\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  TestBed.inject(BasketService);\n\n  TestBed.flushEffects();\n  expect(spy).toHaveBeenCalledTimes(1);\n\n  // effect가 더러우지 않았습니다\n  TestBed.flushEffects();\n  expect(spy).toHaveBeenCalledTimes(2);\n});\n```\n\n# 요약\n\n<div class=\"content-ad\"></div>\n\n우리는 시그널을 사용하는 코드를 테스트할 때 \"Glitch-free\" 효과를 알아야 합니다.\n\n테스트에 변경 감지(Change Detection)가 포함되어 있는 경우, 해당 테스트는 우리 애플리케이션과 동일하게 작동합니다.\n\n변경 감지가 포함되지 않은 테스트 유형의 경우, 시그널을 직접 호출하고 TestBed.flushEffects()를 실행하여 \"dirty side effects\"를 실행해야 합니다.\n\nRepository에 접근할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nhttps://github.com/rainerhahnekamp/how-do-i-test\n\n만약 여러분이 테스트 과제를 직면하고 저에게 도움 요청을 하고 싶다면 언제든지 연락해 주세요!\n\n추가 정보와 업데이트를 받으려면 LinkedIn에서 저와 연락하시거나 X와 함께 워크샵 및 테스팅에 관한 컨설팅 서비스를 탐색해 주세요.\n\nhttps://www.angulararchitects.io/en/training/professional-angular-testing-playwright-edition/","ogImage":{"url":"/assets/img/2024-06-20-HowdoItestSignalssignalcomputedeffect_0.png"},"coverImage":"/assets/img/2024-06-20-HowdoItestSignalssignalcomputedeffect_0.png","tag":["Tech"],"readingTime":12},{"title":"Nx 모노레포 애플리케이션을 도커화하는 방법 Angular과 NestJS를 사용한 단계별 안내","description":"","date":"2024-06-20 05:35","slug":"2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS","content":"\n\n<img src=\"/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_0.png\" />\n\n안녕하세요,\n저는 Medium에 처음으로 포스팅하는 중입니다 (사실 인생에서 처음이에요 😔). 요즘 작업 중이었고 다양한 시각을 검토하기 위해 이 플랫폼에서 많은 도움을 받은 소스를 스캔하는 동안 누락된 것 같다고 생각한 주제에 대해 첫 블로그를 쓰기로 결심했습니다. 수년 동안 써보고 싶었지만 시작하는 동기를 얻지 못했어요. 먼저 Aziz Nal에게 지원해주시고 글을 쓰라고 격려해 준 분께 감사드립니다.\n\n이 글은 Angular, NestJS 및 이들이 사용하는 라이브러리가 포함된 NX Monorepo 프로젝트에서 각 프로젝트에 대한 Dockerfile을 작성하는 방법과 각 프로젝트를 개별 컨테이너에 배포하는 방법을 단일 Docker-Compose 파일을 사용해 살펴볼 것입니다. \n\n이 글은 터키어로도 읽을 수 있습니다. 해당 링크에서 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n그럼 시작해 보죠 😄\n\n## 우리의 NX 프로젝트 만들기\n\n다음 명령어로 NX 워크스페이스를 생성해 봅시다.\n\n```js\nnpx create-nx-workspace@latest\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령을 실행한 후 워크스페이스 설정을 위해 몇 가지 선택지와 입력을 요청받게 됩니다.\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_1.png)\n\n여기서 우리의 주요 목적은 프로젝트를 생성하는 것이 아니기 때문에, 미리 구성된 프로젝트 설정을 위해 다음 옵션을 선택하였습니다:\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_2.png)\n\n<div class=\"content-ad\"></div>\n\n그 후 설정을 계속 진행할 구성을 선택해야 해요. 제 글의 시작 부분에서도 언급했듯이, Angular 및 NestJS 애플리케이션에 대해 마지막 옵션을 선택했어요.\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_3.png)\n\n마지막 단계로, 워크스페이스와 프로젝트 이름을 입력하고 Angular 프로젝트에 대한 몇 가지 설정을 선택해야 해요. 이 단계에서 'NXDockerDeployment'를 레포지토리 이름으로, 'MyApp'을 프로젝트 이름으로 지정했고, Angular 프로젝트 css 형식으로 'scss'를 선택했어요. 'NX Cloud'를 사용하고 싶지 않아서 'No' 옵션을 선택했어요.\n\n프로젝트 설정이 완료되면, 프로젝트 구조는 이렇게 보일 거에요:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_4.png)\n\n여기에는 'my-app'이라는 Angular 프로젝트, 'api'라는 NestJS 프로젝트, 그리고 함께 사용할 라이브러리 프로젝트가 있습니다.\n\nApi 및 My-app 프로젝트를 실행하고 브라우저에서 열면 다음 페이지가 표시됩니다.\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n작은 업데이트를 진행하겠습니다. NX의 미리 구성된 설정을 사용할 때 Angular 프로젝트를 위한 준비된 프록시 구성이 함께 제공됩니다. 이 글의 주제가 제품 환경에 맞게 프록시 구성을 조정하는 데 있지 않기 때문에 이 구성을 무시하고 나의 프로젝트에서 선호하는대로 작은 변경을 가할 것입니다.\n\n먼저, 'my-app/src/environments' 폴더 아래에 있는 'environment.ts' 파일을 열어 다음과 같이 업데이트합니다:\n\n```js\nexport const environment = {\n  production: false,\n  BACKEND_URL: 'http://localhost:3333', // 실제 백엔드 포트와 다를 경우 업데이트 해야 합니다.\n};\n```\n\n그 다음, 제품 환경으로 프로젝트를 컴파일하고 배포할 것이므로, 동일한 폴더 아래에 있는 'environment.prod.ts' 파일을 다음과 같이 업데이트합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nexport const environment = {\n  production: true,\n  BACKEND_URL: 'http://192.168.1.154:8080',\n};\n```\n\n마침내, 우리는 ‘my-app/src/app’ 폴더 아래의 ‘app.component.ts’ 파일을 열어 위에서 업데이트한 주소에 따라 api 프로젝트로 요청을 보낼 수 있도록 다음과 같이 업데이트합니다:\n\n```js\nimport { environment } from './../environments/environment';\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Message } from '@nxdocker-deployment/api-interfaces';\n```\n\n```js\n@Component({\n  selector: 'nxdocker-deployment-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss'],\n})\nexport class AppComponent {\n  hello$ = this.http.get<Message>(`${environment.BACKEND_URL}/hello`);\n  constructor(private http: HttpClient) {}\n}\n```\n\n<div class=\"content-ad\"></div>\n\n우리가 업데이트를 한 후에도, 애플리케이션을 실행하고 브라우저에서 열면 이전과 같은 화면을 볼 수 있을 거에요.\n\n<img src=\"/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_6.png\" />\n\n프론트엔드 작업을 완료한 후에는, API 프로젝트에서 CORS를 구성해야하는데, 이렇게 함으로써 배포 후에 문제가 없도록 할 수 있어요.\n\n'api/src' 폴더 아래의 'main.ts' 파일을 열어서, \"app.enableCors()\"라인을 추가하여 CORS를 활성화해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Logger } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\n```\n\n```js\nimport { AppModule } from './app/app.module';\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  const globalPrefix = 'api';\n  app.setGlobalPrefix(globalPrefix);\n  app.enableCors();\n  const port = process.env.PORT || 3333;\n  await app.listen(port);\n  Logger.log(\n    `🚀 Application is running on: http://localhost:${port}/${globalPrefix}`\n  );\n}\nbootstrap();\n```\n\n결과적으로, 프로젝트 배포를 위해 준비가 끝났습니다. 이제 두 번째 과정으로 넘어가서 'Dockerfile' 파일을 작성하는 것부터 시작하여 프로젝트를 배포할 준비를 완료할 수 있습니다.\n\n## Dockerfile 파일 작성하기\n\n\n<div class=\"content-ad\"></div>\n\n- 내 앱 Angular 프로젝트를 위한 Dockerfile\n\n저희 프론트엔드 프로젝트용 Dockerfile을 작성하는 것으로 시작해보겠습니다. 이를 위해 저희 프로젝트 내 apps/my-app 폴더 아래에 Dockerfile이란 이름의 파일을 생성하고 아래의 코드를 복사해 넣습니다.\n\n```js\nFROM node:16.13.0-alpine AS builder\n```\n\n```js\nWORKDIR /app\nCOPY package*.json ./\nRUN apk add --update python3 make g++ && rm -rf /var/cache/apk/*\nRUN npm install\nCOPY . .\nRUN npx nx build my-app --prod\nFROM nginx:stable-alpine\nWORKDIR /usr/share/nginx/html\nRUN rm -rf ./*\nCOPY --from=builder /app/dist/apps/my-app ./\nRUN sed -i '10i \\\\ttry_files $uri $uri/ /index.html;' /etc/nginx/conf.d/default.conf\nENTRYPOINT [\"nginx\", \"-g\", \"daemon off;\"]\n```  \n\n<div class=\"content-ad\"></div>\n\n이제 함께 한 작업을 다시 한 번 살펴봐요.\n먼저, Angular 프로젝트인 my-app에 대해 두 단계 배포를 진행하고 있어요. 첫 번째 단계에서는 프로젝트의 종속성을 설치하는 작업을 수행하고 빌드할 수 있는 node 이미지에서 프로젝트를 실행하고 빌드해요. 그리고 프로젝트를 컴파일하고 제품용으로 사용할 파일들을 생성해요. 두 번째 단계에서는 웹 서버에서 빌드 프로세스를 완료하고 컴파일된 프로젝트 파일을 게시할 수 있도록 필요한 조정을 완료해요. 저는 여기서 SPA (싱글 페이지 애플리케이션) 애플리케이션에서 흔히 사용되는 설정을 가진 nginx를 선호하고 설정했어요. 지금까지 우리가 한 작업을 대략적으로 살펴보았으니, 코드를 한 줄씩 자세히 살펴보려는 나와 같은 세부 사항에 관심 있는 친구들을 위해 코드를 살펴봐요.\n\n- 우리는 작업을 수행하기 위해 Node가 설치된 node-alpine 배포본을 사용할 것을 명시하고 AS를 사용하여 'builder' 이미지로 이름을 지정해요.\n- 다음 단계에서 사용할 /app 폴더를 작업 디렉토리로 지정해요.\n- 프로젝트에서 필요한 패키지를 포함한 package.json 및 package-lock.json 파일들을 프로젝트에서 이 디렉토리로 복사해요.\n- 성공적인 배포를 위해 필요한 종속성을 설치해요.\n참고: 사용하는 배포본에 따라 이 단계가 달라질 수 있고 다른 패키지 설치 요구사항이 있거나 전혀 필요하지 않을 수 있어요.\n- npm install 명령을 실행하여 앞서 복사한 패키지 파일에 따라 필요한 패키지를 설치해요.\n- 프로젝트 파일들을 작업 디렉토리로 모두 복사해요.\n- 프로덕션 환경을 위해 프로젝트를 빌드해요.\n- 다음 단계에는 nginx:stable-alpine 이미지를 사용할 것을 명시해요.\n- 작업 디렉토리를 /usr/share/nginx/html로 설정해요.\n- 작업 디렉토리와 함께 제공되는 기본 파일들을 삭제해요.\n- 첫 번째 단계에서는 'builder' 이미지 내에서 프로젝트를 컴파일한 위치에서 컴파일된 프로젝트 파일을 이 작업 디렉토리로 복사해요.\n- 싱글 페이지 애플리케이션에 필요한 nginx를 구성해요.\n- 마지막으로 nginx 서버를 시작해요. 참고: 이 설정에 따라 nginx 서버는 기본적으로 80번 포트에서 프로젝트를 게시할 거예요.\n\n2. NestJS 프로젝트용 Dockerfile\n\n이제 백엔드 프로젝트용 Dockerfile을 작성해보겠어요. 이를 위해 프로젝트의 apps/api 폴더 아래 Dockerfile이라는 파일을 만들고 다음 코드를 복사해 넣어주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nFROM node:alpine AS builder\n```\n\n```js\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN apk add --update python3 make g++ && rm -rf /var/cache/apk/*\nRUN npm install --only=development --silent\nCOPY . .\nRUN npx nx build api --prod\nFROM node:alpine\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN apk add --update python3 make g++ && rm -rf /var/cache/apk/*\nRUN npm install -g pm2@latest\nRUN npm install --only=production --silent\nRUN npm install express\nCOPY --from=builder /usr/src/app/dist/apps/api ./build\nENTRYPOINT [\"pm2-runtime\", \"build/main.js\"]\n```\n\n이제 여기서 차례대로 무엇을 하는지 살펴보겠습니다.\n먼저, NestJS 프로젝트인 api에 대해 두 단계 배포를 할 것입니다. 첫 번째 단계에서는 프로젝트 종속성을 설치하고 프로젝트를 실행하고 빌드할 수 있는 노드 이미지에서 작업을 수행합니다. 그런 다음 프론트엔드 프로젝트와 마찬가지로 프로젝트를 컴파일하고 프로덕션에서 사용할 파일을 생성합니다. 두 번째 단계에서는 첫 번째 이미지에서 컴파일된 프로젝트 파일을 복사하고 프로덕션에 필요한 npm 패키지 설치를 마무리하고 빌드 프로세스를 완료합니다. 여기서 프로젝트를 시작하는 데 pm2를 사용하도록 선택했습니다. 지금까지 우리가 무엇을 할 것인지 대략적으로 논의했으므로, 이제 우리가 무엇을 하는지 단계별로 살펴보며 설명해보겠습니다.\n\n- 우리는 운영을 수행할 노드 설치가 완료된 node-alpine 배포를 사용할 것임을 지정하며 'builder'로 이미지를 명명합니다.\n- 다음 단계에서 사용할 /usr/src/app 폴더를 작업 디렉토리로 지정합니다.\n- 프로젝트에서 필요한 패키지를 포함하는 package.json 및 package-lock.json 파일을 프로젝트에서 이 디렉토리로 복사합니다.\n- 성공적으로 배포하기 위해 필요한 종속성을 설치 중입니다.\n참고: 사용하는 배포에 따라 이 단계가 다를 수 있으며 다른 패키지 설치 요구 사항이 있을 수도 있습니다. 또는 전혀 필요하지 않을 수도 있습니다.\n- 이전에 복사한 패키지 파일에 따라 필요한 패키지만 설치하도록 지정하여 npm install 명령을 실행합니다.\n- 모든 프로젝트 파일을 작업 디렉토리로 복사합니다.\n- 프로덕션 환경을 위해 프로젝트를 빌드합니다.\n- 다음 단계의 작업을 계속하기 위해 새로운 node:alpine 이미지를 사용할 것임을 지정합니다.\n- 작업 디렉토리를 /usr/src/app으로 설정합니다.\n- 어플리케이션은 백엔드 어플리케이션이므로 로컬에 필요한 npm 패키지가 설치되어야 합니다. 따라서 여기에도 패키지 파일을 복사합니다.\n- 이 이미지 내에서 성공적으로 배포하기 위해 필요한 종속성을 다시 설치합니다.\n- 우리가 프로젝트 시작에 사용할 pm2 패키지를 전역으로 설치합니다.\n- 프로젝트의 프로덕션을 위해 필요한 npm 패키지를 설치합니다.\n- 이 단계에서 express 패키지를 설치합니다. 이 패키지를 별도로 설치해야 하는 이유는 express 패키지가 설치를 위한 package.json 파일에 포함되어 있지 않기 때문입니다. 이미 프로젝트에 express를 설치한 경우 이 단계가 필요하지 않을 것입니다.\n- 첫 번째 단계에서 'builder' 이미지 내에서 프로젝트를 컴파일한 위치에서 컴파일된 프로젝트 파일을 이 작업 디렉토리의 build 폴더로 복사합니다.\n- 그런 다음 main.js 파일에서 pm2-runtime 명령을 사용하여 백엔드 서버를 시작합니다.\n참고: 이 컨테이너를 시작하면 main.ts에서 지정된 포트에서 프로젝트가 실행됩니다. 저는 이를 3333으로 설정했으므로 프로젝트는 이 포트에서 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 도커 Compose 파일 준비\n\n이번 단계에서는 모든 프로젝트를 한 곳에서 설정하는 방법과, 각각을 별도의 컨테이너에서 실행하는 단일 명령으로 모두 실행하는 방법을 살펴봅시다.\n\n먼저, 프로젝트와 동일한 디렉토리에 docker-compose.yml이라는 파일을 다음 내용으로 생성해 보겠습니다.\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_7.png)\n\n<div class=\"content-ad\"></div>\n\n이제 도커 컴포즈 파일의 내용을 채워봅시다.\n\nVSCode에서 만든 docker-compose.yml 파일을 열고 다음 코드를 복사하여 붙여넣어주세요.\n\n```js\nversion: \"3\"\n```\n\n```js\nservices:\n  backend-app:\n    container_name: backend-app\n    restart: always\n    ports:\n      - \"8080:3333\"\n    build:\n      context: ./nxdocker-deployment\n      dockerfile: ./apps/api/Dockerfile\n      \n  frontend-app:\n    container_name: frontend-app\n    restart: always\n    ports:\n      - \"8090:80\"\n    depends_on:\n      - backend-app\n    build:\n      context: ./nxdocker-deployment\n      dockerfile: ./apps/my-app/Dockerfile\"\n```\n\n<div class=\"content-ad\"></div>\n\n이제 코드를 단계별로 살펴봅시다.\n\n- version : 우리는 docker-compose 버전 3을 사용할 것임을 명시합니다.\n- services: 이 docker-compose로 시작할 모든 서비스를 나열합니다.\n- backend-app: 우리의 백엔드 애플리케이션에 이름을 부여합니다.\n- container_name: 백엔드 애플리케이션이 실행될 컨테이너의 이름을 backend-app으로 지정합니다.\n- restart: 도커 서비스가 충돌하거나 다시 시작하거나 컴퓨터가 재부팅될 때 자동으로 다시 시작하도록 항상 설정합니다.\n- ports: 컨테이너 안에서 백엔드 프로젝트가 실행되는 3333 포트를 외부에서 접근할 수 있도록 8080 포트로 노출합니다.\n- build: mono repo 아키텍처로 인해 Dockerfile이 docker-compose 파일과 같은 위치에 있지 않을 것이므로 프로젝트의 메인 디렉터리와 함께 Dockerfile 파일이 있는 위치를 지정해서 서비스가 컴파일해야 하는 곳을 명시합니다.\n- frontend-app: 우리의 프론트엔드 애플리케이션에 이름을 부여합니다.\n- container_name: 프론트엔드 애플리케이션이 실행될 컨테이너의 이름을 frontend-app으로 지정합니다.\n- restart: 도커 서비스가 충돌하거나 다시 시작하거나 컴퓨터가 재부팅될 때 자동으로 다시 시작하도록 항상 설정합니다.\n- ports: 컨테이너 안에서 nginx로 실행되는 프론트엔드 프로젝트가 실행되는 80포트를 외부에서 접근할 수 있도록 8090포트로 노출합니다.\n- build: 프로젝트의 메인 디렉터리를 지정하고 프론트엔드 프로젝트를 빌드하고 도커 이미지를 생성할 Dockerfile 파일을 찾는 경로를 지정합니다.\n\n## 프로젝트 실행\n\n이제 코드를 하나씩 따라가면서 프로젝트를 실행해봅시다. 어느새 설정에 지쳤나요? 프로젝트 끝이 보이지 않나요? 언제쯤 끝날까요? 😊\n\n<div class=\"content-ad\"></div>\n\n믿기 어렵지만, 프로젝트를 시작할 준비가 모두 마련되었어요. 필요한 것은 터미널과 그 마법 같은 명령어만 남았네요 🙂\n\n저희 docker-compose.yml 파일이 위치한 디렉토리에서 터미널 창을 열고 다음 명령어를 실행해 보세요.\n\n```js\ndocker-compose up -d\n```\n\n이 명령어를 실행하면 docker-compose 파일에 있는 모든 설정이 실행됩니다. 필요한 이미지가 다운로드되고, Dockerfile 구성에 따라 레이어가 작성되며, 인터넷 속도에 따라 작업이 완료될 거예요. 작업이 끝나면 ‘-d’ 플래그가 터미널을 제어권으로 돌려줄 거에요. 🙏\n\n<div class=\"content-ad\"></div>\n\n이 마법 같은 명령을 함께 실행해보고 결과를 확인해봐요!\n\n![image](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_8.png)\n\n이제 모든 노력으로 우리 프로젝트가 원할하게 실행될 거에요.\n\n바로 브라우저에서 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n![image1](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_9.png)\n\n우리 해냈어요! 🎉🎊🍸🍾🥂 그게 다예요.\n\n![image2](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_10.png)\n\n## 결과\n\n<div class=\"content-ad\"></div>\n\n이 첫 블로그 포스트에서는 Nrwl NX Monorepo를 사용하여 프로젝트를 개발한 후 제작한 도커파일들이 어떻게 제작되는지 쉽게 설명해보려고 노력했어요. 그리고 단일 도커 컴포즈를 준비한 후 한 번의 명령으로 발행하는 방법을 알려드렸어요. 물론 이 과정은 프로젝트의 요구사항 및 필요에 따라 다양하게 달라질 수 있고, 배포는 간단하지 않지만, 이 글이 여러분에게 조금이나마 도움이 되었으면 좋겠어요.\n\n여러분의 글에 피드백을 제공해드릴 수 있어서 기쁩니다. 모든 건설적인 비평을 환영합니다.\n\n이 첫 번째 모험을 함께해줘서 감사합니다 🙏\n\n## 참고 자료 및 링크\n\n<div class=\"content-ad\"></div>\n\n- NX 문서\n- Docker 문서","ogImage":{"url":"/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_0.png","tag":["Tech"],"readingTime":12},{"title":"새로운 버전 18로 Angular 프로젝트를 업그레이드하는 방법","description":"","date":"2024-06-20 05:33","slug":"2024-06-20-HowtoUpgradeYourAngularProjecttotheLatestVersion18","content":"\n\nAngular은 웹 애플리케이션을 구축하기 위한 강력하고 널리 사용되는 프레임워크입니다. Angular 프로젝트를 최신 버전으로 유지하면 새로운 기능, 성능 향상, 보안 업데이트를 활용할 수 있습니다. Angular 18에는 개선 사항 및 업데이트가 여러 가지 포함되어 있어 개발 프로세스를 더욱 효율적으로 처리할 수 있습니다. 이 블로그 포스트에서는 Angular 프로젝트를 최신 버전 18로 업그레이드하는 과정을 안내해 드릴 것입니다.\n\n# Angular 18으로 업그레이드하는 단계별 안내서\n\n# 1. 현재 버전 및 의존성 확인\n\n업그레이드 프로세스를 시작하기 전에 현재 Angular 버전과 프로젝트의 의존성을 파악하는 것이 중요합니다. 이를 통해 업그레이드 단계를 효과적으로 계획할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트 디렉토리를 열어주세요.\n\n현재 사용 중인 Angular 버전을 확인하려면 다음 명령어를 실행해보세요:\n\n\nng version\n\n\nAngular CLI, Angular 프레임워크 및 기타 종속성을 확인하고 메모해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 2. Angular CLI 및 Angular Core 업데이트\n\nAngular CLI (Command Line Interface)는 Angular 프로젝트를 관리하는 데 중요한 도구입니다. 먼저 Angular CLI를 전역적으로 업데이트하세요:\n\n- 현재 Angular CLI를 제거하기 위해 다음 명령어를 실행하세요:\n\n```bash\nnpm uninstall -g @angular/cli\n```\n\n<div class=\"content-ad\"></div>\n\n가장 최신 Angular CLI를 설치해보세요:\n\n\nnpm install -g @angular/cli@latest\n\n\n프로젝트의 로컬 Angular CLI를 업데이트해보세요:\n\n\nng update @angular/cli\n\n\n<div class=\"content-ad\"></div>\n\n다음으로 Angular 코어 및 기타 관련 패키지를 업데이트해보세요:\n\nAngular 코어 및 기타 Angular 패키지 업데이트:\n\nng update @angular/core\n\n선택적인 업데이트가 있다면 Angular이 제안할 것입니다. Angular CLI에서 제공하는 지침에 따라 진행해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 3. 제3자 종속성 다루기\n\nAngular 18과 호환되기 위해 서드파티 종속성이 업데이트되어야 할 수도 있습니다. 오래된 패키지가 있는지 확인해보세요:\n\n다음 명령어를 실행하여 오래된 패키지를 확인해보세요:\n\n```bash\nnpm outdated\n```\n\n<div class=\"content-ad\"></div>\n\n#### 더 이상 사용되지 않는 패키지를 업데이트하세요:\n\n\nnpm update\n\n\n일부 패키지는 주요 업데이트나 호환되지 않는 변경사항이 있을 경우 수동 개입이 필요할 수 있습니다. 각 패키지의 설명서를 확인하여 특정 업데이트 지침을 확인하세요.\n\n#### 4. TypeScript 버전 업데이트\n\n<div class=\"content-ad\"></div>\n\nAngular 18은 특정 TypeScript 버전이 필요할 수 있습니다. 올바른 TypeScript 버전이 설치되어 있는지 확인해 주세요:\n\n필요한 TypeScript 버전을 확인하려면 Angular 문서를 참조하세요.\n\n필요한 버전으로 TypeScript를 업데이트하세요:\n\n```bash\nnpm install typescript@`required_version`\n```\n\n<div class=\"content-ad\"></div>\n\nAngular 문서에 명시된 버전으로 'required_version'을 바꿔주세요.\n\n## 5. Breaking Changes와 Deprecated 사항 수정하기\n\n업데이트 후에는 해결해야 할 Breaking Changes 또는 Deprecated 사항이 있을 수 있습니다. Angular CLI는 이러한 문제를 식별하고 수정하는 데 도움이 되는 도구를 제공합니다:\n\n다음 명령어를 실행하여 잠재적인 사항을 식별하십시오:\n\n<div class=\"content-ad\"></div>\n\nng lint\n\n문제를 고쳐주세요. 공식 안티 연규 및 문서를 참고하여 일반적인 호환성 문제에 대한 해결책을 확인할 수 있습니다.\n\n## 6. 애플리케이션 테스트하기\n\n업데이트를 완료한 후에는 애플리케이션을 철저히 테스트하여 모든 것이 올바르게 작동하는지 확인해주세요:\n\n<div class=\"content-ad\"></div>\n\n유닛 테스트를 실행하세요:\n\n\nng test\n\n\n엔드 투 엔드 테스트를 실행하세요:\n\n\nng e2e\n\n\n<div class=\"content-ad\"></div>\n\n귀하의 응용 프로그램의 주요 부분을 수동으로 테스트하여 모든 기능이 정상적으로 작동하는지 확인하세요.\n\n# 7. 문서와 종속성 업데이트\n\n마지막으로, 업그레이드 프로세스 중에 수행된 변경 사항을 반영하도록 내부 문서를 업데이트하세요. 또한 package.json을 업데이트하여 향후 개발자가 사용 중인 버전을 파악할 수 있도록 해주세요.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n앵귤러 프로젝트를 최신 버전 18로 업그레이드하는 것은 어려울 수 있지만, 이러한 단계를 체계적으로 따라가면 원활한 전환을 보장할 수 있습니다. 프로젝트를 최신 상태로 유지하는 것은 새로운 기능과 개선 사항뿐만 아니라 응용 프로그램의 보안과 안정성도 유지하는 데 도움이 됩니다. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-20-HowtoUpgradeYourAngularProjecttotheLatestVersion18_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoUpgradeYourAngularProjecttotheLatestVersion18_0.png","tag":["Tech"],"readingTime":3},{"title":"앵귤러와 리액트 앱에서의 마이크로프론트엔드의 까다로운 부분들","description":"","date":"2024-06-20 05:33","slug":"2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps","content":"\n\n<img src=\"/assets/img/2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps_0.png\" />\n\n이 게시물은 Angular/React 기업 애플리케이션의 마이크로프론트엔드에 대해 깊이 파고들기 위한 연재물 중 첫 번째입니다. 이번에는 Angular에서 셸 앱에 동적 원격 컴포넌트를로드하는 방법에 대해 이야기하겠습니다.\n\n웹 개발의 급속한 변화 속에서 모듈식이고 확장 가능한 아키텍처에 대한 수요는 마이크로프론트 엔드의 등장으로 이어졌습니다. 이 설계 접근 방식은 복잡한 웹 애플리케이션을 구축하고 관리하는 방식을 혁신하겠다는 약속을 합니다. 개발 프로세스를 간소화하는 잠재력과 성장하는 중요성에도 불구하고, 이 주제에 대한 포괄적인 자료 및 상세한 토론에는 뚜렷한 공백이 남아 있습니다.\n\n# 정신적 모델:\n\n<div class=\"content-ad\"></div>\n\n- 원격: 원격은 별도로 구축되고 배포되는 애플리케이션입니다. 다른 애플리케이션에서 로드할 수있는 ESM을 노출 할 수 있습니다.\n- 쉘: 쉘은 필요할 때 원격을 로드합니다. 프레임워크 관점에서 이 기능은 전통적인 지연 로딩과 비슷합니다. 큰 차이점은 컴파일 시간에 쉘이 원격을 모르는 것입니다.\n\n# 원격 앱\n\n독립 구성 요소를 노출합니다. 예를 들어 간단한 프로필 구성 요소를 만들고 federation.config.js로 구성을 업데이트합니다.\n\n```js\nconst {\n withNativeFederation,\n shareAll,\n} = require('@angular-architects/native-federation/config');\n\nmodule.exports = withNativeFederation({\n name: 'profile',\n exposes: {\n  './MyProfileComponent': './src/app/myprofile/myprofile.component.ts',\n },\n shared: {\n  ...shareAll({\n   singleton: true,\n   strictVersion: true,\n   requiredVersion: 'auto',\n  }),\n },\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 쉘\n\n```js\n{\n    \"profile\": \"http://profile-app.com/remoteEntry.json\",\n}\n```\n\n자, 우리는 독립형 컴포넌트를 만들어보자. 이름은 federated component로 하자!\n\n```js\n<ng-template #federatedComponent></ng-template>\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { loadRemoteModule } from '@angular-architects/native-federation';\nimport { Component, OnInit, ViewContainerRef, Input, ViewChild } from '@angular/core';\n\n@Component({\n    selector: 'app-federated-component',\n    templateUrl: './federated.component.html',\n    standalone: true,\n})\nexport class FederatedComponent implements OnInit {\n    @ViewChild('federatedComponent', { read: ViewContainerRef })\n    private federatedComponent: ViewContainerRef;\n\n    @Input() entryName: string = '';\n    @Input() module: string = '';\n    @Input() componentName: string = '';\n    @Input() additionalProps: Map<string, unknown> = new Map();\n\n    ngOnInit(): void {\n        loadRemoteModule(this.entryName, this.module).then((federated) => {\n            if (this.federatedComponent) {\n                const comp = this.federatedComponent.createComponent(federated[this.componentName]);\n\n                if (this.additionalProps.size > 0) {\n                    this.additionalProps.forEach((value, key) => {\n                        comp.setInput(key, value);\n                    });\n                }\n            }\n        });\n    }\n}\n```\n\nCreate an enum for exposed remotes where we can map remote apps\n\n```js\nexport const FederatedModuleMap = {\n    profile: {\n        name: 'profile',\n        modules: {\n            myprofile: {\n                name: './MyProfileComponent',\n                componentName: 'MyProfileComponent',\n            },\n        },\n    },\n};\n```\n\nNow let`s create the component that will load a remote application from our dynamic component, which we created — `app.federated.component /\n\n<div class=\"content-ad\"></div>\n\n```js\n<app-federated-component\n        [additionalProps]=\"props()\"\n        [entryName]=\"exposedName()\"\n        [module]=\"exposedModule()\"\n        [componentName]=\"exposedComponent()\"></ram-federated-component> \n```\n\n```js\nimport { Component, ViewEncapsulation, signal } from '@angular/core';\nimport { FederatedModuleMap } from '@enums';\n\n@Component({\n    selector: 'app-my-profile',\n    templateUrl: './my-profile.component.html',\n    encapsulation: ViewEncapsulation.Emulated,\n})\nexport class MyProfileComponent {\n    protected exposedName = signal(FederatedModuleMap.profile.name);\n    protected exposedModule = signal(\n        FederatedModuleMap.profile.modules.myprofile.name\n    );\n    protected exposedComponent = signal(\n        FederatedModuleMap.profile.modules.myprofile.componentName\n    );\n    protected props = signal(\n        new Map<string, unknown>([['canEdit', false]])\n    );\n}\n```\n\n원격 컴포넌트가 입력을 필요로 하는 경우 Map과 함께 모든 입력을 전달할 수 있습니다.\n\n이것은 Angular로의 마이크로 프론트엔드에 전념된 시리즈의 첫 번째 블로그이며, 앞으로 미래 게시물에서 MFE 통합의 보다 어려운 측면을 탐구할 예정입니다.","ogImage":{"url":"/assets/img/2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps_0.png"},"coverImage":"/assets/img/2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps_0.png","tag":["Tech"],"readingTime":5}],"page":"37","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}