{"pageProps":{"posts":[{"title":"장고로 대규모 프로젝트를 만드는 방법","description":"","date":"2024-05-18 22:36","slug":"2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest","content":"\n\n<img src=\"/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png\" />\n\n요즘 장고는 이미 잘 아시겠지만, 큰 아이디어를 현실로 만들 때 절대적인 선택지입니다. 몇 가지를 만들어본 코더로서, 때로는 뭔가 엄청난 일들을 하려다 보면 조금씩 자신감이 떨어지기도 합니다. 그렇죠? '음, 장고가 이걸 오랫동안 버틸 수 있을까?' 하고 걱정이 드는 건 당연한 일입니다. 장고의 속도와 구조는 정말 생명을 살려주죠. (첫 번째 어드민 패널을 사용했을 때의 마법 같은 경험을 기억하시나요?) 하지만 여러분과 같은 코더로서, 나중에 복잡한 병목 현상을 걱정하기 시작할 때의 기분을 잘 아실 거예요.\n\n그러니까, 팬보이들의 이야기는 좀 떠나서 진짜 개발자들끼리 진지한 대화를 나눠보자고요. 장고는 정말 비범한 프로젝트에 대응할 수 있는 걸까요? 어디가 한계일까요? 이것이 정말 올바른 선택이며, 나중에 후회하지 않을 결정인지 어떻게 확신할 수 있을까요? 구글부터 현재 파이썬을 가르치고 있는 저의 경험에 따르면, 파헤쳐야 할 것들이 많다고 생각합니다.\n\n# 장고가 빛을 발하는 곳: 아이디어를 가속화합니다\n\n<div class=\"content-ad\"></div>\n\n- 빠른 시작, 빠른 반복: Django의 '전부 구비'는 빈말이 아닙니다. 사용자 인증이 필요한가요? 퍼워, 이미 구현되어 있어요. 객체-관계 매핑은? 해결했어요. 초기 단계는 아이디어를 발전시키는 데 집중할 수 있는 시간이에요. 새 프로젝트를 시작할 때 항상 Django를 선택하는 이유죠.\n- 구조가 정신 건강을 지킨다: 사실 몇몇 프로젝트는 빨리 코드 공룡이 될 수 있어요. Django의 모델은 데이터 관계를 깔끔하게 유지시켜주고 관리 패널은 전체 구조를 한 눈에 볼 수 있게 해줘요. 몇 달 후 코드를 다시 보게 되었을 때, 이것은 과거의 자신으로부터의 선물 같이 느껴질 거에요.\n- Django 커뮤니티의 지혜: 이상한 버그에 걸렸나요? 대형 Django 커뮤니티 속에 이미 누군가가 그것을 보았을 가능성이 높아요. Stack Overflow, 포럼, 블로그 사이에서 진짜로 꼼꼼히 막히는 일은 드물죠. 데드라인에 쫓겨 있을 때는 그만한 가치가 있다고 생각해요.\n\n## 예시: 내 컨텐츠 집계기가 작동 중\n\n당신의 컨텐츠 집계기를 떠올려보세요. Django를 사용한다면 아마 이와 같은 모델을 갖게 될 거에요:\n\n```js\nclass Source(models.Model):\n    name = models.CharField(max_length=100)\n    url = models.URLField()\n    # ... 기타 업데이트 주기 추적을 위한 필드들 \n\nclass Article(models.Model):\n    title = models.CharField(max_length=255)\n    content = models.TextField()\n    source = models.ForeignKey(Source, on_delete=models.CASCADE)\n    # ... 발행일, 작가 등을 위한 필드들\n```\n\n<div class=\"content-ad\"></div>\n\n보니까 많이 깨끗하다, 맞지? Django는 데이터베이스 관련 작업을 맡아 처리해주기 때문에 당신은 콘텐츠를 가져오고 표현하는 로직에 주력할 수 있어요. \n\n# 야망이 Django를 넘어설 때\n\n- 트래픽 몬스터: 그만봐도 알겠지만, 만약 다음 바이럴 히트를 만들고 있다면, 로우 Django는 이에 대응하기 어려울 수도 있어요. 하지만 이것은 Django의 실패가 아니에요! 여기에는 스마트한 아키텍처가 필요해요. 캐싱(미리 생성된 콘텐츠), 로드 밸런서(작업 분산), 그리고 쿼리 최적화를 고려하면 Django를 놀랄 정도로 멀리 뻗을 수 있어요.\n- 픽셀 퍼펙션 애정: 맞춤 및 혁신적인 상호작용이 필요한 디자인이 있는가요? Django의 템플릿 및 내장 구성 요소는 강력하지만, 매우 맞춤화된 UI는 씨름이 될 수도 있어요. Django와 함께 JavaScript 프레임워크를 고려하는 것이 더 현명한 장기적인 계획일 수 있어요.\n- 최신 기술에 대응: Django는 안정성과 신뢰할 수 있는 패키지의 거대한 생태계를 기반으로 발전해요. 만약 핵심 아이디어가 최신 AI 라이브러리나 실험적인 기술에 의존한다면 어려움에 부딪힐 수 있어요. 불가능한 것은 아니지만 소매를 걷고 통합 작업을 하기 위해 소매를 걷어올려야 할 준비를 해야 해요.\n\n## 예시: 게임이 시작될 때\n\n<div class=\"content-ad\"></div>\n\n당신의 멋진 실시간 멀티플레이어 게임 아이디어를 상상해 보세요. 물리 시뮬레이션, 게임 상태에 대한 지속적인 업데이트... Django는 플레이어 계정, 로비 등을 처리할 수 있지만 실시간, 저지연의 액션은 아마도 그 부분을 위해 특화된 도구가 필요할 것입니다. Django는 '큰 그림'을 관리하게 됩니다.\n\n중요한 참고사항: Django가 나쁜 것은 아닙니다! 모든 시나리오에 완벽한 도구는 없다는 점을 솔직하게 인식하는 것입니다. 숙련된 개발자의 초능력은 전략적으로 도구를 조합할 때를 알 수 있는 데에 있습니다.\n\n# \"달라질 수 있다\" 요소: Django만의 문제가 아닙니다\n\n- 당신의 팀의 Django-기술: 알고 있는 Django 팀은 요령을 알고 있습니다. 쿼리 최적화하는 방법, 장기적인 데이터 구조, 그리고 언제 추가 도구를 전략적으로 도입할지 알고 있습니다. Django에 익숙한 팀이 아닌 경우? 그들도 그 수준에 도달할 것이지만, 학습 곡선이 프로젝트 기한과 겹칠 수 있습니다.\n- 데이터 중심 vs. 야생의 서쪽: Django는 구조화된 데이터에서 빛을 발합니다. 전자상거래 사이트, 콘텐츠 플랫폼, 심지어 내부 도구들... 거기서 잘 동작합니다. 그러나 만약 당신의 아이디어가 예측할 수 없는 데이터 유형이나 상호작용을 가진 매우 실험적인 경우, Django를 자신의 의지에 맞게 굽히느라 건설하는 것보다 더 많은 시간을 보낼지도 모릅니다.\n- 야심찬...어떻게, 정확히? 백만 명의 사용자는 말하는 건가요, 그러나 비교적 직관적인 기능들일까요? Django는 스마트한 최적화로 이를 처리하는 경우가 많습니다. 그러나 적은 사용자지만 괴로운 완전히 복잡한 기능과 톤의 맞춤 논리가 있는 경우는? 그건 다른 종류의 도전입니다.\n\n<div class=\"content-ad\"></div>\n\n코딩의 아름다움(그리고 때로는 좌절!)은 보편적으로 '최고'인 도구가 없다는 점입니다. 올바른 선택은 이러한 요소들과 어떻게 조화를 이루느냐에 따라 달라집니다. 판단은 여러분의 최대 자산인 경험에 달려있어요.\n\n간단한 시나리오를 보여드리죠: 여러분의 컨텐츠 집계기가 성공적입니다. 하지만 홈페이지가 다수의 소스에서 최신 기사를 가져오기 때문에 느려지고 있어요.\n\n초보적인 접근 방식:\n\n```js\ndef homepage_view(request):\n    latest_articles = Article.objects.all().order_by('-published_date')[:20] \n    return render(request, 'homepage.html', {'articles': latest_articles})\n```\n\n<div class=\"content-ad\"></div>\n\n문제: 이 방법은 모든 기사를 매번 가져와서 표시를 위해 슬라이스합니다. 데이터베이스가 커질수록 문제가 심각해집니다.\n\n최적화된 접근방식:\n\n```js\ndef homepage_view(request):\n    latest_articles = Article.objects.select_related('source').order_by('-published_date')[:20]\n```\n\n변경된 사항:\n\n<div class=\"content-ad\"></div>\n\n- select_related: 이것은 Django에게 각 기사에 대해 관련 'Source' 객체를 미리 가져오도록 지시하여 나중에 데이터베이스 작업을 줄입니다.\n- Queryset Slicing: 우리는 필요한 최상위 20개만 가져옵니다, 모든 것을 가져오지 않습니다.\n\n왜 중요한가: 이 문제는 작아 보일 수 있지만, 규모에 맞게 그 최적화 작업은 빠른 사이트와 부하 하에 격렬하게 돌아가는 사이트 사이의 차이를 만들어냅니다. 이것은 경험 많은 Django 개발자가 제공하는 사고 방식입니다.\n\n# 정직한 판단\n\n- Django: 스위스 아미 나이프, 레이저 빔이 아님 Django는 상상할 수 있는 모든 것을 구축하는 데 관한 것이 아닙니다. 대신, 수많은 웹 프로젝트를 빠르고 훌륭하게 구축하는 데 중점을 두고 있습니다. 때로는 전문화된 도구가 필요할 때도 있습니다. 그것은 괜찮습니다!\n- 구축을 시작하고, 답이 나타날 것입니다: 솔직히 말해서, Django가 장기적으로 적합한지 알아보는 가장 좋은 방법은 직접 해 보는 것입니다. 초기 속도를 통해 잠재적인 병목 현상이 실제 문제가 되기 훨씬 전에 발견할 수 있습니다. '만약' 때문에 시작하는 것을 막지 마세요.\n- Django보다 크게 생각하십시오: 데이터베이스가 중요합니다! 확장성을 고려하지 않고 나쁜 데이터베이스를 선택하면, Django 코드가 얼마나 좋든 손해를 입을 것입니다. 같은 이유로 엉성한 배포도 마찬가지입니다 - 느린 서버는 모든 것을 느리게 만듭니다. 전문가적인 마인드는 전체 시스템에 대한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## Django의 모든 문제가 아닙니다\n\n성능적인 한계에 부딪혔다고 가정해 봅시다. Django를 포기하기 전에 다음을 고려해 보세요:\n\n- 쿼리 시간: 데이터베이스 조회가 엉망인가요? 최적화는 매우 중요합니다 (이전 예시를 참고하세요!)\n- 외부 요소: 서버 성능이 좋지 않은가요? 의존하는 외부 API가 병목 현상을 일으키나요?\n\n핵심 포인트: Django는 여러분의 도구상자에서 강력한 도구일 뿐, 유일한 존재는 아닙니다. 성공은 이러한 조각들을 잘 맞물리게 하는 데에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 추가 맛\n\n- 장고 거인들: 인스타그램이 Django를 떠나기로 유명하다고 하지만, Disqus, Eventbrite, 심지어 NASA와 같은 사이트들은 여전히 시스템의 핵심 부분에 의지하고 있습니다. 규모는 상대적이며, Django의 매력 포인트는 생각보다 넓습니다.\n- 나의 Django '아하!' 순간: 프로젝트가 Django를 벗어나야 한다고 생각했어요. 복잡한 데이터, 수많은 맞춤 기능... 몇 가지 잘못된 쿼리가 문제의 원인이라는 것을 발견했습니다! 그것들을 다시 작업하니 Django가 새로운 존재처럼 느껴졌어요. 배운 교훈: 탈주하기 전에 최적화 작업을 하세요.\n- 전쟁 이야기를 나눠보세요: Django가 승리한 이야기나 실망했던 순간에 대한 이야기를 가지고 계신가요? 댓글에서 공유해주세요! 이런 경험들이 우리를 더 나아지게 하는 방법입니다. Django 커뮤니티가 강한 이유가 있습니다 — 우리는 이런 것에 대해 열정적으로 이야기하는 것을 좋아합니다.\n\n## 더 알아보기\n\n만약 이러한 해설이 도움이 되었다면, 중요한 Python과 Django 통찰을 좀 더 파헤치겠습니다. 제 Medium 페이지를 팔로우해주시고, 대화를 이어가고, 만약 가치 있다고 느끼시면 박수를 치세요. 또한, 곧 YouTube 채널을 시작할 준비 중이니, 더 많은 코딩 모험을 기대해주세요!\n\n<div class=\"content-ad\"></div>\n\n# 친절한 번역  🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 이렇게 가기 전에:\n\n- 작가를 클랩하고 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인해보세요","ogImage":{"url":"/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png"},"coverImage":"/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png","tag":["Tech"],"readingTime":6},{"title":"템플릿 간소화하기 Angular 17에서의 제어 흐름","description":"","date":"2024-05-18 22:35","slug":"2024-05-18-StreamlineYourTemplatesControlFlowinAngular17","content":"\n\n<img src=\"/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png\" />\n\n안녕하세요, Angular 열정가 여러분! 오늘은 Angular 17의 새로운 혁신인 내장 제어 흐름 구문을 발표하려고 왔어요! 이 새로운 기능을 사용하면 추가 지시문 (ngIf, ngFor, ngSwitch)을 버리고 집에 온 듯한 키워드를 사용하여 템플릿에서 제어 흐름 로직을 직접 작성할 수 있어요 (자바스크립트 같아요!). 이것이 어떻게 당신의 Angular 경험을 향상시키는 지 한번 알아봐요!\n\n우리는 여러 해 동안 조건부로 콘텐츠를 렌더링하고 데이터를 반복하는 데 지시문을 의존해 왔어요. 그들은 작동하지만 템플릿에 혼란과 복잡성의 추가 레이어를 덧붙일 수 있어요. Angular 17은 @if, @else if, @switch 및 @for 같은 익숙한 키워드를 사용하여 템플릿 내에서 직접 제어 흐름 로직을 작성할 수 있게 해줘요. 이러면 코드가 더 깔끔하고 읽기 쉽고 일반적인 자바스크립트를 작성하는 느낌이 들어요!\n\n## 왜 지시문 대신 제어 흐름을 선택해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n아래는 변경하는 것이 좋은 몇 가지 설득력 있는 이유입니다:\n\n- 뚜렷한 가독성: 제어 흐름 구문은 JavaScript의 제어 흐름 구조를 반영하여, JavaScript에 익숙한 사람들에게 이해하기 쉬운 템플릿을 만드는 데 도움이 됩니다.\n- 중복성 감소: ✂️ 제어 흐름을 통해 여분의 지시문이 필요 없어져 더 깔끔하고 간결한 템플릿을 생성할 수 있습니다.\n- 현대적인 개발 경험: 제어 흐름은 현대적인 JavaScript 관행과 일치하며, 일관되고 익숙한 개발 경험을 촉진합니다. 이는 더 적은 정신 부담과 놀라운 기능을 구축하는 데 더 많은 시간을 집중할 수 있다는 것을 의미합니다!\n\n# @if와 @else로 익숙함을 받아들이다\n\n참/거짓 변수에 따라 메시지를 표시하려는 시나리오를 상상해보십시오. 기존에는 다음과 같이 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n@if (isLoggedIn) {\n  <p>다시 오신 것을 환영합니다!</p>\n} @else {\n  <p>로그인해주세요.</p>\n}\n```\n\n이렇게 제어 흐름 구문을 사용하면 JavaScript에서 제어 흐름을 작성하는 방식과 더 자연스러워집니다. 더 복잡한 조건을 위해 @else if 문을 연결할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Level Up Loops with @for\n\n데이터 컬렉션을 반복하는 것은 Angular 애플리케이션의 기본적인 부분입니다. 이전에 우리는 *ngFor을 사용했습니다. 제어 흐름은 유사한 접근 방식을 제공합니다:\n\n```js\n<ul>\n  <li *ngFor=\"let fruit of fruits\">{ fruit.name }</li>\n</ul>\n```\n\n제어 흐름에 대한 비교:\n\n<div class=\"content-ad\"></div>\n\n```js\n<ul>\n  @for (과일 in 과일들; trackBy: 과일.name) {\n    <li>{ 과일.name }</li>\n  } @empty {\n    <li>과일이 없습니다.</li>\n  }\n</ul>\n```\n\n하지만 기능이 향상되었습니다! 제어 흐름 구문을 사용하려면 trackBy를 사용하여 추적 함수를 지정해야 합니다. 이렇게 하면 Angular가 컬렉션 내의 변경 사항을보다 효율적으로 식별하여 앱이 특히 대규모 데이터 세트로도 원활하게 실행되도록 지원합니다! ❤️\n\n# @switch로 결정 내리기 ⚖️\n\n여러 조건에 따라 콘텐츠를 렌더링해야 하는 경우 @switch 문이 구원의 손을 내밀어줍니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n@switch(selectedFruit) {\n  @case(apple){\n    <p>사과를 선택하셨네요!</p>\n  }\n  @case(banana){\n    <p>바나나는 포타슘의 좋은 원천입니다!</p>\n  }\n  @default {\n    <p>그것은 제가 알아듣는 과일이 아니에요.</p>\n  }\n}\n```\n\n이렇게 하면 템플릿 안에서 switch-case 로직을 보다 간결하고 가독성 있게 처리할 수 있어요. 멋지죠? ✨\n\n# 링크\n\n아래에서 제어 흐름 구문의 상세 정보를 찾을 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n- Angular — @for\n- Angular — @switch\n- Angular — @if","ogImage":{"url":"/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png"},"coverImage":"/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png","tag":["Tech"],"readingTime":3},{"title":"PHP 8.3에 추가된 20가지 흥미로운 기능들 정리","description":"","date":"2024-05-18 22:31","slug":"2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss","content":"\n\n## 웹 개발과 프로그래밍을 혁신하는 PHP 8.3의 최신 기능 및 개선 사항을 알아보세요.\n\n![이미지](/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png)\n\n인기 있는 서버 측 스크립팅 언어인 PHP의 최신 버전인 PHP 8.3은 새로운 기능과 개선 사항이 많이 포함되어 있어 웹 개발을 최적화하고 성능을 향상시킬 것을 약속합니다. readonly 클래스, 새 json_validate() 함수, Randomizer 클래스에 대한 추가, 더 적합한 날짜/시간 예외 등의 개선 사항을 통해 PHP 8.3은 PHP 개발 경험을 혁신할 것입니다. 이러한 업데이트는 PHP를 더 효율적, 안전하고 다양하게 만들어 웹 개발자와 기업의 변화하는 요구를 충족시키기 위해 목적을 두고 있습니다.\n\n# PHP 8.3의 20가지 흥미로운 기능 및 개선 사항\n\n<div class=\"content-ad\"></div>\n\n- 읽기 전용 클래스 개선 사항\n- 새로운 json_validate() 함수\n- Randomizer 클래스에 대한 추가 기능\n- 타입이 지정된 클래스 상수\n- 익명 읽기 전용 클래스\n- 동적 클래스 상수 검색\n- 보다 적절한 날짜/시간 예외 처리\n- 개선된 unserialize() 오류 처리\n- 트레이트 및 정적 속성\n- 스택 오버플로 감지\n- 일정 상수 가시성\n- Assert String Eval 정리\n- 향상된 FFI\\CData:void\n- posix_getrlimit() 매개변수 개선\n- gc_status() 개선\n- 내부 클래스에 대한 class_alias() 지원\n- mysqli_poll() 오류 처리\n- array_pad() 개선 사항\n- opcache.consistency_checks ini 지시문 제거\n- number_format()을 사용하여 소수점 처리를 올바르게 처리\n\n# 1. 읽기 전용 클래스 개선 사항\n\nPHP 8.3에서 읽기 전용 클래스에 중요한 개선 사항이 있어 개발자들이 코드를 더 유연하고 효율적으로 제어할 수 있게 되었습니다. 특정하지만 중요한 엣지 케이스를 해결하기 위해 생성 및 복제 시 읽기 전용 속성을 다시 초기화할 수 있는 기능이 추가되었습니다. 이번 업그레이드로 읽기 전용 속성의 딥 클론이 가능하게 되어 PHP에서 읽기 전용 클래스의 유틸리티가 확장되었습니다. 다음은 DateTime 속성을 가진 읽기 전용 클래스의 예시입니다:\n\n```js\nreadonly class Post {\n    public function __construct(public DateTime $createdAt) {\n        // 생성자 로직\n    }\n\n    public function __clone() {\n        $this->createdAt = new DateTime();\n        // 읽기 전용 속성을 다시 초기화하는 것이 이제 허용됩니다\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예에서 Post 클래스에는 읽기 전용 속성 $createdAt이 있습니다. 이 속성은 게시물의 생성 날짜를 나타냅니다. PHP 8.3에서 개선된 사항으로, __clone() 메서드를 사용하여 읽기 전용 속성을 다시 초기화할 수 있어 객체의 깊은 복제를 가능하게 하고 읽기 전용 속성의 무결성을 해치지 않습니다.\n\n# 2. 새로운 json_validate() 함수\n\njson_validate() 함수의 도입으로 개발자들은 JSON 문자열을 유효성 검사하는 더 효율적이고 직접적인 방법을 제공받게 되었습니다. 이 함수는 JSON 문자열의 유효성을 확인해야 할 때 복호화 과정 없이 바로 확인할 수 있어 매우 유용합니다.\n\n```js\n$jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}';\n\nif (json_validate($jsonString)) {\n    echo \"JSON 문자열이 유효합니다.\";\n} else {\n    echo \"JSON 문자열이 유효하지 않습니다.\";\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예에서는 json_validate() 함수를 사용하여 JSON 문자열 $jsonString을 직접 유효성 검사합니다. JSON 문자열이 유효하면 해당 메시지가 표시됩니다. 이 함수는 디코딩 및 오류 처리 없이 JSON 데이터를 유효성 검사하는 간단한 방법을 제공합니다.\n\n사용자 정의 깊이와 플래그를 지정할 수도 있습니다.\n\n```js\n$jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}';\n\n// 사용자 정의 깊이와 플래그로 JSON 문자열 유효성 검사\nif (json_validate($jsonString, 512, JSON_THROW_ON_ERROR)) {\n    echo \"JSON 문자열이 유효합니다.\";\n} else {\n    echo \"JSON 문자열이 유효하지 않습니다.\";\n}\n```\n\n이 예제에서는 사용자 정의 깊이와 플래그로 json_validate() 함수를 사용했습니다. 두 번째 매개변수는 JSON 문자열의 최대 깊이를 지정하고, 세 번째 매개변수는 유효성 검사를 위한 플래그를 설정합니다. 이를 통해 개발자는 특정 요구 사항에 맞게 유효성 검사 과정을 설정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nPHP 8.3에서 json_validate() 함수는 JSON 유효성 검사 프로세스를 간소화하여 JSON 문자열을 해독하는 대안으로 더 효율적인 메모리를 제공합니다. 이 향상된 기능은 JSON 데이터의 유효성만을 확인해야 하는 시나리오에서 특히 유용하며 PHP 애플리케이션에서 성능과 자원 활용을 향상시킵니다.\n\n# Randomizer 클래스에 추가된 내용\n\nRandomizer 클래스는 새로운 메서드로 확장되어 개발자가 더 많은 제어와 유연성을 가지고 무작위 데이터를 생성할 수 있게 되었습니다. 이러한 추가 기능은 Randomizer 클래스의 기능을 확장하여 지정된 범위와 제약 조건 내에서 무작위 값을 생성하는데 탁월한 지원을 제공합니다.\n\n```js\nuse Randomizer;\n\n$string = \"Hello, World!\";\n$length = 10;\n\n$randomBytes = Randomizer::getBytesFromString($string, $length);\nvar_dump($randomBytes);\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 Randomizer 클래스의 getBytesFromString() 메서드는 지정된 길이($length)의 랜덤 바이트 문자열을 주어진 입력 문자열($string)에서 생성하는 데 사용됩니다. 이 메서드는 랜덤 데이터 생성이 필요한 시나리오에 기반하여 소스 문자열을 기반으로 랜덤 바이트 시퀀스를 생성하는 편리한 방법을 제공합니다.\n\n또한 지정된 범위 내에서 랜덤 정수를 생성할 수도 있습니다.\n\n```js\nuse Randomizer;\nuse IntervalBoundary;\n\n$min = 10;\n$max = 20;\n\n$randomInteger = Randomizer::getRandomInteger($min, $max, IntervalBoundary::Closed);\necho $randomInteger;\n```\n\n이 예시에서 Randomizer 클래스의 getRandomInteger() 메서드는 $min과 $max로 정의된 범위 내에서 랜덤 정수를 생성하는 데 활용됩니다. IntervalBoundary::Closed 열거형은 최소값과 최대값을 범위에 포함해야 함을 나타내는 데 사용됩니다. 이 메서드는 개발자들이 특정 범위 내에서 랜덤 정수를 생성할 수 있도록 돕고 생성된 값에 대한 정확한 제어를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\nPHP 8.3의 Randomizer 클래스에 추가 사항은 더 향상된 랜덤 데이터 생성 기능을 제공하여, 다양한 제어된 무작위성을 필요로 하는 사용 사례에 맞춤 기능을 제공합니다. 이러한 방법들은 PHP 개발자들에게 사용 가능한 랜덤 데이터 생성 옵션의 범위를 풍부하게 하여 Randomizer 클래스의 전반적인 다양성과 유틸리티에 기여합니다.\n\n# 4. Typed class constants\n\n타입화된 클래스 상수의 도입은 특정 데이터 유형과 함께 클래스 상수를 정의할 수 있도록 하여, 클래스 정의 내에서 향상된 유형 안전성과 명확성을 제공합니다. 이 향상된 기능을 통해 개발자들은 클래스 상수에 대한 유형 제약을 강제할 수 있어 코드의 가독성을 향상시키고 의도하지 않은 데이터 유형 불일치 가능성을 줄일 수 있습니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass MathOperations {\n    public const PI: float = 3.14159;\n    public const MAX_ITERATIONS: int = 1000;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 MathOperations 클래스는 두 개의 클래스 상수, PI와 MAX_ITERATIONS을 특정 데이터 유형으로 정의합니다. PI 상수는 float로, MAX_ITERATIONS 상수는 INT로 유형이 지정됩니다. 이렇게 함으로써 이러한 상수가 지정된 데이터 유형의 값을 보유하도록 보장하여 유형 안전성을 증진시키고 코드 가독성을 높입니다.\n\n```js\nclass Configuration {\n    public const DEFAULT_TIMEOUT: int = 30;\n    public const ENABLE_LOGGING: bool = true;\n    \n    public function setRequestTimeout(int $timeout): void {\n        // Set the request timeout using the DEFAULT_TIMEOUT constant\n        // defined as an integer\n        // ...\n    }\n    \n    public function enableLogging(bool $enable): void {\n        // Enable or disable logging based on the ENABLE_LOGGING constant\n        // defined as a boolean\n        // ...\n    }\n}\n```\n\n이 예에서 Configuration 클래스는 유형화된 클래스 상수를 사용하여 기본 시간 초과 및 로깅 설정 옵션을 정의합니다. DEFAULT_TIMEOUT 상수는 INT로 유형이 지정되어 정수 값을 보유하도록 보장하고, ENABLE_LOGGING 상수는 boolean으로 유형이 지정되어 boolean 값을 보유함을 나타냅니다. 이를 통해 클래스 메서드 내에서 이러한 상수를 사용할 때 일관성과 유형 안전성이 증진됩니다.\n\nPHP 8.3에서 유형화된 클래스 상수의 도입은 클래스 정의의 표현성과 신뢰성을 향상시킵니다. 개발자가 클래스 상수에 대한 데이터 유형을 지정할 수 있어 코드 품질 향상, 더 나은 문서 작성, 클래스 상수 내 데이터 유형 오류 가능성 감소에 기여하며, 결국 PHP 애플리케이션의 견고성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n# 5. 익명 읽기 전용 클래스\n\n익명 읽기 전용 클래스의 소개는 객체 지향 프로그래밍에 새로운 유연성을 가져 왔습니다. 이러한 클래스를 사용하면 명명된 클래스를 명시적으로 정의할 필요 없이 가벼운 불변 객체를 생성할 수 있습니다. 이 기능은 일시적이거나 일회성 객체가 필요한 시나리오에서 특히 유용합니다. 포멀한 클래스 선언의 오버헤드 없이 필요한 임시 객체를 만들 수 있습니다. 이 기능을 몇 가지 예제를 통해 알아봅시다:\n\n```js\n$person = new class {\n    public function __construct(public string $name, public int $age) {}\n};\n\n$john = new $person('John Doe', 30);\necho $john->name; // 출력: John Doe\necho $john->age; // 출력: 30\n```\n\n이 예제에서는 '...' 구문을 사용하여 익명 읽기 전용 클래스를 생성합니다. 이 클래스에는 name 및 age에 대한 공용 속성이 있으며, 이 익명 클래스에서 $john 객체가 인스턴스화됩니다. 이를 통해 포멀한 클래스 선언이 필요 없이 간단하고 가벼운 객체를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n익명 읽기 전용 클래스를 데이터 구조로 사용할 수도 있습니다.\n\n```php\n$data = new class {\n    public array $values = [];\n\n    public function addValue($value): void {\n        $this->values[] = $value;\n    }\n};\n\n$data->addValue('A');\n$data->addValue('B');\n$data->addValue('C');\n\nprint_r($data->values); // 출력: Array ( [0] => A [1] => B [2] => C )\n```\n\n이 예제에서는 익명 읽기 전용 클래스를 사용하여 값을 저장하는 간단한 데이터 구조를 만듭니다. 클래스에는 배열을 보유하는 공개 속성 values와 배열에 값을 추가하는 addValue 메서드가 있습니다. 이 예는 공식 클래스 정의 없이 즉석에서 작성된 데이터 구조를 만들기 위해 익명 읽기 전용 클래스를 사용하는 방법을 보여줍니다.\n\nPHP 8.3에서 익명 읽기 전용 클래스가 소개되면서 개발자들은 불변의 객체와 데이터 구조를 가볍고 유연하게 즉석에서 만들 수 있게 되었습니다. 이 기능은 PHP의 객체 지향 기능을 보다 표현력 있고 다용도로 사용할 수 있게 하며, 특정 상황에 대해 전통적인 클래스 선언에 대한 편리한 대안을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 6. 동적 클래스 상수 가져오기\n\n이 기능은 개발자들이 클래스 상수를 더 동적인 구문을 사용하여 가져올 수 있게 해주어 클래스 상수를 다룰 때 더 큰 유연성과 표현력을 제공합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass Configuration {\n    public const DEFAULT_TIMEOUT = 30;\n    public const ENABLE_LOGGING = true;\n}\n\n$constantName = 'DEFAULT_TIMEOUT';\necho Configuration::{$constantName}; // 출력: 30\n```\n\n이 예제에서 DEFAULT_TIMEOUT 클래스 상수의 값을 변수 $constantName을 사용하여 동적으로 가져왔습니다. 이 동적 구문을 사용하면 실행 중 값에 따라 클래스 상수를 검색할 수 있어 클래스 상수를 다루는 더 유연한 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해도 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 7. 더 적절한 날짜/시간 예외 처리\n\n이 기능은 다양한 날짜 및 시간 관련 특이 케이스에 대한 전용 예외를 도입하여, 날짜 및 시간 연산에서 보다 세분화되고 구체적인 오류 처리를 제공합니다. 이 향상된 기능은 다양한 오류 시나리오에 대해 더 정확한 예외 유형을 제공하여, 날짜 및 시간 관련 코드의 견고성과 신뢰성을 향상시키고자 합니다. 몇 가지 예제와 함께 이 기능을 살펴봅시다:\n\n```js\ntry {\n    // 범위 오류가 발생하는 날짜 연산\n    // ...\n} catch (DateRangeError $e) {\n    // 특정 DateRangeError 예외 처리\n    // 에러 로깅, 사용자에게 통보 또는 적절한 조치 취하기\n    // ...\n} catch (Exception $e) {\n    // 일반적인 예외 처리로 이동\n    // ...\n}\n```\n\n이 예제에서는 범위 오류가 발생한 날짜 연산을 처리하기 위해 특정 DateRangeError 예외가 잡힙니다. 이를 통해 날짜 범위 오류에 특화된 오류 처리가 가능해지며, 특정 예외 유형을 기반으로 적절한 조치를 취할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n날짜 형식이 잘못된 간격 문자열 예외에 대해서도 처리할 수 있어요.\n\n```js\ntry {\n    // 날짜 간격 파싱 작업\n    // ...\n} catch (DateMalformedIntervalStringException $e) {\n    // 특정 DateMalformedIntervalStringException 처리\n    // ...\n} catch (Exception $e) {\n    // 일반적인 예외 처리로 이동\n    // ...\n}\n```\n\n이 예에서는 DateMalformedIntervalStringException을 사용하여 날짜 간격 문자열이 잘못된 경우 처리합니다. 이 특정 예외 유형을 사용하면 개발자가 날짜 간격 문자열이 잘못된 시나리오에 맞게 맞춤형 오류 처리를 구현할 수 있어요.\n\nPHP 8.3의 \"더 적절한 날짜/시간 예외\" 기능은 날짜 및 시간 관련 오류 처리에 대해 더 정확하고 체계적인 접근 방식을 제공해요. 특정 날짜 및 시간 예외를위한 전용 예외를 도입함으로써 이 개선 사항은 더 나은 오류 관리를 촉진하고 날짜 및 시간 관련 예외의 보다 효율적인 처리를 돕습니다. 이는 PHP 애플리케이션에서 날짜 및 시간 작업의 전체 신뢰성과 견고성에 기여합니다.\n\n<div class=\"content-ad\"></div>\n\n# 8. unserialize() 오류 처리 기능 개선\n\n이 기능은 unserialize() 함수의 오류 처리 메커니즘을 향상시켜, 데이터의 역직렬화 중 문제가 발생했을 때 더 일관되고 예측 가능한 동작을 제공합니다. 이 개선은 오류 보고를 간소화하고 unserialize() 오류를 보다 효과적으로 처리하여 더 나은 오류 관리와 디버깅 기능을 제공하고 있습니다. 이 기능을 몇 가지 예제와 함께 살펴보겠습니다:\n\n```js\n$data = '...'; // 직렬화된 데이터\n$result = unserialize($data);\nif ($result === false) {\n    $error = error_get_last();\n    if ($error && $error['type'] === E_WARNING) {\n        // unserialize() 오류를 E_WARNING으로 처리\n        // 오류 기록, 사용자에게 알림 또는 적절한 조치를 취합니다\n        // ...\n    } else {\n        // 일반적인 오류 처리로 이동\n        // ...\n    }\n}\n```\n\n이 예제에서는 데이터의 역직렬화를 시도한 후 결과가 false인지 확인하여 오류를 나타내는지 여부를 확인합니다. 그런 다음 error_get_last()를 사용하여 마지막 오류를 가져와 오류 유형을 확인합니다. 오류 유형이 E_WARNING인 경우, unserialize() 오류를 경고로 처리하여 unserialize() 문제에 대한 특정 오류 처리를 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n심지어 unserialize 메서드에서 예외 처리를 사용할 수도 있습니다.\n\n```js\n$data = '...'; // 직렬화된 데이터\ntry {\n    $result = unserialize($data);\n    // 직렬화 해제된 데이터 처리\n    // ...\n} catch (UnserializeException $e) {\n    // 특정 UnserializeException 처리\n    // 오류 기록, 사용자에게 알림 또는 적절한 조치 취함\n    // ...\n} catch (Exception $e) {\n    // 일반적인 예외 처리로 대체\n    // ...\n}\n```\n\n이 예제에서 코드는 직렬화 해제 프로세스를 처리하기 위해 try-catch 블록을 활용합니다. UnserializeException이 발생하면 unserialize() 예외에 대한 특정 오류 처리가 가능하며, 개발자들이 unserialize() 문제에 대한 대상적인 오류 관리를 구현할 수 있도록 합니다.\n\nPHP 8.3의 \"Improved unserialize() error handling\" 기능은 unserialize() 함수에 대한 더 일관적이고 구조화된 오류 처리를 도입하여, unserialize 데이터의 처리 중 오류 보고 및 관리에 대한 향상된 제어를 제공합니다. 더 예측 가능한 오류 처리 메커니즘을 제공함으로써, 이 개선 사항은 PHP 애플리케이션에서 직렬화된 데이터를 다룰 때 디버깅 능력과 전반적인 오류 내구성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n# 9. 특성과 정적 속성\n\n이 기능은 정적 속성을 사용하는 관련된 특성의 동작 변경을 소개합니다. 이 향상은 특성을 사용할 때 부모 클래스에서 상속받은 정적 속성의 재선언을 다루며, 각 클래스가 특성을 포함할 때 정적 속성에 대한 별도의 저장소를 유지하도록 보장합니다. 이 동작은 이제 특성 내에서 정적 속성을 직접 클래스에 추가하는 것과 유사해졌으며, 특성 내에서 정적 속성을 보다 예측 가능하고 일관된 방식으로 다루도록 장려합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\ntrait Loggable {\n    protected static $log = [];\n\n    public static function addToLog($message) {\n        self::$log[] = $message;\n    }\n\n    public static function getLog() {\n        return self::$log;\n    }\n}\n\nclass User {\n    use Loggable;\n}\n\nclass Product {\n    use Loggable;\n}\n\nUser::addToLog('사용자가 로그인했습니다');\nProduct::addToLog('새 제품이 추가되었습니다');\n\nvar_dump(User::getLog());\nvar_dump(Product::getLog());\n```\n\n이 예제에서 Loggable 특성은 $log라는 정적 속성과 로그에 메시지를 추가하고 로그를 검색하는 메서드를 포함합니다. User 및 Product 클래스는 Loggable 특성을 사용하여 로깅 기능을 통합합니다. 각 클래스는 정적 속성 $log을 위한 별도의 저장소를 유지함으로써 User 및 Product 클래스 간에 로그 데이터가 격리되고 구분되도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 바꿀 수도 있어요.\n\n```js\ntrait Counter {\n    protected static int $count = 0;\n\n    public static function increment() {\n        self::$count++;\n    }\n\n    public static function getCount() {\n        return self::$count;\n    }\n}\n\nclass Order {\n    use Counter;\n}\n\nclass Invoice {\n    use Counter;\n}\n\nOrder::increment();\nInvoice::increment();\nOrder::increment();\n\nvar_dump(Order::getCount()); // Output: int(2)\nvar_dump(Invoice::getCount()); // Output: int(1)\n```\n\n이 예시에서, Counter 트레이트는 정적 속성 $count를 초기화하고 카운트를 증가시키고 카운트 값을 검색하는 메서드를 제공합니다. Order와 Invoice 클래스는 카운트를 별도로 추적하기 위해 Counter 트레이트를 사용합니다. 각 클래스는 자체 카운트를 유지하며, 트레이트 내 정적 속성의 별도 저장을 보여 주어 다른 클래스의 정적 속성과는 별개로 작동하는 것을 보여줍니다.\n\nPHP 8.3의 \"Traits and static properties\" 기능은 여러 클래스에서 사용될 때 정적 속성을 일관되고 예측 가능하게 구현함으로써 trait를 사용한 코드 구조에서 정적 속성을 처리하는 강력하고 직관적인 메커니즘을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 10. 스택 오버플로 감지\n\n이 기능은 스택 오버플로 상황을 감지하고 방지하기 위해 zend.max_allowed_stack_size와 zend.reserved_stack_size라는 두 가지 새로운 ini 지시문을 소개합니다. 이 향상된 기능은 스택 오버플로 상황을 감지하고 처리함으로써 PHP 애플리케이션의 신뢰성과 안정성을 향상시키고 세그멘테이션 오류의 가능성을 줄이며 디버깅을 쉽게 만드는 것을 목표로 합니다. 몇 가지 예시를 통해 이 기능을 살펴보겠습니다:\n\n```js\n// php.ini\nzend.max_allowed_stack_size = 128K\n```\n\n이 예시에서는 php.ini 구성 파일에서 zend.max_allowed_stack_size 지시문이 128 킬로바이트로 설정되어 있습니다. 이 지시문은 PHP 프로그램의 최대 허용 스택 크기를 지정하는데, 개발자가 호출 스택 크기의 상한선을 정의할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// php.ini\nzend.reserved_stack_size = 16K\n\n// PHP 코드\nfunction recursiveFunction($n) {\n    if ($n <= 0) {\n        return;\n    }\n    recursiveFunction($n - 1);\n}\n\nrecursiveFunction(100000); // 큰 수로 재귀 호출\n\n```\n\n이 예제에서는 php.ini 구성 파일에서 zend.reserved_stack_size 지시문이 16 킬로바이트로 설정되어 있습니다. PHP 코드는 재귀 호출을 많이 수행하는 재귀 함수를 포함하고 있으며, 재귀 호출이 많아져 스택 오버플로 상황이 발생할 수 있습니다. zend.reserved_stack_size 지시문을 사용하면 PHP가 호출 스택이 오버플로우 직전에 있는지 감지하여 상황을 처리하고 오류를 throw하여 세그멘테이션 오류를 방지하며 디버깅을 용이하게 합니다.\n\nPHP 8.3의 \"스택 오버플로우 감지\" 기능은 개발자가 호출 스택 크기에 제한을 설정하고 잠재적인 스택 오버플로우 상황을 감지하는 수단을 제공하여 PHP 응용 프로그램의 안정성과 견고성을 향상시킵니다. 이 ini 지시문을 통해 PHP는 스택 오버플로우 상황에 대한 개선된 오류 처리를 제공하며 세그멘테이션 오류의 발생 가능성을 줄이고 더욱 효과적인 디버깅 과정을 용이하게 합니다.\n\n# 11. 불변 상수 가시성\n\n\n<div class=\"content-ad\"></div>\n\n이 기능은 invariant 키워드를 사용하여 클래스 상수를 선언하는 기능을 소개합니다. 이를 통해 클래스의 상수의 가시성이 하위 클래스에서 확장되더라도 불변으로 유지될 수 있습니다. 이 향상된 기능은 클래스 상수를 정의하는 더 명시적이고 제어된 방법을 제공하며, 상속 계층 구조에서 상수의 가시성을 유지할 수 있습니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass ParentClass {\n    public invariant int MAX_VALUE = 100;\n}\n\nclass ChildClass extends ParentClass {\n    // MAX_VALUE의 가시성을 변경하려고 시도하면 컴파일 오류가 발생합니다\n    protected invariant int MAX_VALUE = 200;\n}\n```\n\n이 예에서 ParentClass는 public invariant 상수인 MAX_VALUE를 값 100으로 선언합니다. ChildClass는 MAX_VALUE의 가시성을 protected로 변경하려고 시도하면 컴파일 오류가 발생하여 상속 계층 구조 전체에서 상수의 불변 가시성이 강제됩니다.\n\n인터페이스에서도 invariant 상수를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n인터페이스 Constants {\n    공개 불변의 문자열 VERSION = '1.0';\n}\n\n클래스 ImplementationClass는 Constants를 구현합니다 {\n    // VERSION의 가시성은 구현 클래스에서도 공개로 유지되어야 합니다\n    개인 불변의 문자열 VERSION = '2.0';\n}\n```\n\n이 예에서 Constants 인터페이스는 값이 ‘1.0’인 공개 불변 상수 VERSION을 선언합니다. ImplementationClass가 VERSION의 가시성을 개인으로 변경하려고 하면 컴파일 오류가 발생하여 상수의 가시성이 인터페이스에서 지정한 대로 불변으로 유지되도록 합니다.\n\nPHP 8.3의 “불변 상수 가시성” 기능은 클래스 상수를 정의하는 더 견고하고 명시적인 방법을 제공하여 상수의 가시성이 상속 계층 구조나 인터페이스 구현에서 일관되게 유지되도록 보장합니다. 이 개선은 코드의 유지 보수성을 높이고 상수의 가시성에 의도하지 않은 변경이 발생할 가능성을 줄여 PHP 코드베이스의 전체 신뢰성과 예측 가능성을 향상시킵니다.\n\n# 12. Assert String Eval Cleanup\n\n\n<div class=\"content-ad\"></div>\n\n이 기능은 문자열 평가 코드 어설션의 폐기를 포함하며, 더 안전하고 유지보수가 용이한 코딩 관행을 장려합니다. 이 개선은 문자열 평가 코드를 통한 어설션 사용을 억제하여 보안 취약점 및 코드 유지 관리 도전에 대응합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nassert('is_numeric($value)');\n```\n\n이 예에서는 assert 함수가 $value가 숫자인지 확인하기 위해 문자열 평가 코드 어설션과 함께 사용됩니다. 그러나 이 방식은 보안 위험에 노출되어 있으며 PHP 8.3에서는 폐기됩니다.\n\n여기서는 직접 표현식을 사용한 어설션의 업데이트된 버전을 표시합니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nassert(is_numeric($value));\n```\n\nPHP 8.3에서는 단언문에 문자열 평가 코드 대신 직접 표현식을 사용하는 것이 권장됩니다. 단언문 내에서 is_numeric 함수를 직접 호출함으로써 코드를 더 안전하고 유지보수하기 쉽게 만들 수 있습니다.\n\nPHP 8.3의 \"Assert String Eval Cleanup\" 기능은 개발자들이 단언문에 문자열 평가 코드 대신 직접 표현식을 사용하도록 전환하도록 권장하며, 더 안전하고 신뢰할 수 있는 코딩 관행을 촉진합니다. 이 접근 방식을 deprecated 처리함으로써 PHP는 코드 보안과 유지보수성을 향상시키고, PHP 애플리케이션의 전체적인 견고성에 기여하고 있습니다.\n\n# 13. 향상된 FFI\\CData:void\n\n\n<div class=\"content-ad\"></div>\n\n이 기능은 FFI (외부 함수 인터페이스) 확장 기능을 향상시켜 C 함수가 void 반환 유형을 가질 때 PHP에서 FFI\\CData`void` 인스턴스를 반환하는 대신 null로 표시할 수 있도록 합니다. 이 개선을 통해 값을 반환하지 않는 C 함수를 처리하기가 더 간편해지며, PHP에서 예상하는 null 반환 유형과 일치시킵니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\n// C 코드\nvoid myFunction() {\n    // 함수 구현\n}\n\n// PHP FFI\n$ffi = FFI::cdef(\"\n    void myFunction();\n\", \"mylib.so\");\n\n$ffi->myFunction(); // C 함수 호출\n```\n\n이 예제에서 C 함수 myFunction은 void 반환 유형을 가지고 있습니다. PHP 8.3에서 FFI를 사용하여이 함수를 호출할 때 반환 값은 FFI\\CData`void` 인스턴스가 아닌 null이 됩니다. void를 반환하는 C 함수를 처리하기가 간단해집니다.\n\n다음과 같이 반환 유형을 확인할 수도 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```php\n$result = $ffi->myFunction();\n\nif ($result === null) {\n    echo \"함수가 성공적으로 실행되고 null을 반환했습니다.\";\n} else {\n    echo \"예기치 않은 반환 값입니다.\";\n}\n```\n\n이 예제에서는 C 함수 myFunction의 반환 값을 확인합니다. 반환 값이 null이면 함수가 성공적으로 실행되고 값을 반환하지 않았음을 나타내며, void를 반환하는 함수에 대한 예상 동작과 일치합니다.\n\nPHP 8.3의 \"Improved FFI\\CData:void\" 기능은 PHP에서 void를 반환하는 C 함수를 간소화하여 FFI를 통한 이러한 함수와의 상호 작용을 단순화합니다. PHP에서 이러한 함수를 null로 표현할 수 있도록 함으로써, 이 향상은 값을 반환하지 않는 C 함수를 다룰 때 더 직관적이고 일관된 FFI 경험에 기여합니다.\n\n# 14. posix_getrlimit() 매개변수 향상\n\n<div class=\"content-ad\"></div>\n\n이 기능은 posix_getrlimit() 함수에 개선 사항을 소개합니다. 선택적 매개변수를 전달하여 단일 리소스 제한을 가져올 수 있도록 허용합니다. 이 향상된 기능은 특정 리소스에 대한 자원 제한을 검색할 때 더 큰 유연성과 정밀도를 제공함으로써 PHP 애플리케이션 내에서 자원 한도에 대한 자세한 정보를 획득하는 프로세스를 간소화합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\n// 최대 열린 파일 수에 대한 소프트 제한 가져오기\n$softLimit = posix_getrlimit(posix_RLIMIT_NOFILE, POSIX_RLIMIT_SOFT);\necho \"최대 열린 파일 수에 대한 소프트 제한: \" . $softLimit . \"\\n\";\n```\n\n이 예제에서 posix_getrlimit() 함수는 최대 열린 파일 수에 대한 소프트 제한을 가져오는 데 사용됩니다. 선택적 매개변수 POSIX_RLIMIT_SOFT를 사용하여 함수는 특정 리소스 제한을 검색하고 반환하여 리소스 사용에 대한 자세한 정보를 제공합니다.\n\n심지어 CPU 시간에 대한 하드 제한도 가져올 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// CPU 시간의 하드 제한을 가져오는 중\n$hardLimit = posix_getrlimit(posix_RLIMIT_CPU, POSIX_RLIMIT_HARD);\necho \"CPU 시간의 하드 제한: \" . $hardLimit . \"\\n\";\n```\n\n이 예제에서는 posix_getrlimit() 함수를 사용하여 CPU 시간의 하드 제한을 얻는 방법을 보여줍니다. 선택적 매개변수로 POSIX_RLIMIT_HARD를 지정하여 함수는 특정 리소스 제한을 검색하고 반환하여 리소스 사용 세부 정보에 정확하게 액세스할 수 있도록 합니다.\n\nPHP 8.3의 \"posix_getrlimit() 매개변수 개선\"은 개발자가 개별 리소스 제한을 쉽게 가져올 수 있는 능력을 부여합니다. 개별 리소스 제한을 가져오는 접근 방식을 제공하여 리소스 사용 정보를 더 세부적으로 확인할 수 있도록 합니다. 이 개선은 리소스 제한과 관련된 더 세밀하고 유연한 작업을 향상시키며, PHP 애플리케이션 내에서 유효한 리소스 관리에 필수적인 세부 리소스 제한 정보를 제공합니다.\n\n# 15. gc_status() 개선내용\n\n<div class=\"content-ad\"></div>\n\ngc_status() 함수가 개선되어 PHP 애플리케이션 내에서 메모리 관리 및 가비지 수집에 대한 상세 정보를 제공하는 총 여덟 가지 새로운 필드가 도입되었습니다. 이러한 필드는 실제 가비지 수집이 실행 중인지, 메모리 블록이 가비지 수집으로부터 보호되는지, 가득찬 가비지 수집 주기가 진행 중인지 등 다양한 측면에 대한 세부 정보를 제공합니다.\n새로운 필드 목록은 다음과 같습니다:\n\n- \"running\" =` bool: 현재 가비지 수집이 실행 중인지를 나타냅니다.\n- \"protected\" =` bool: 메모리 블록이 가비지 수집으로부터 보호되는지를 나타냅니다.\n- \"full\" =` bool: 완전한 가비지 수집 주기가 진행 중인지를 나타냅니다.\n- \"buffer_size\" =` int: 가비지 수집을 위한 버퍼 크기를 바이트 단위로 지정합니다.\n- \"application_time\" =` float: 가비지 수집 주기를 포함한 총 응용 프로그램 실행 시간을 나타냅니다.\n- \"collector_time\" =` float: 소멸자의 실행 및 값의 해제를 포함하여 수집 주기에 소요된 시간을 반영합니다.\n- \"destructor_time\" =` float: 수집 주기 동안 소멸자를 실행하는 데 사용된 시간을 나타냅니다.\n- \"free_time\" =` float: 수집 주기 동안 값들을 해제하는 데 사용된 시간을 나타냅니다.\n\n이러한 필드에 접근하여 개발자들은 가비지 수집 상태, 메모리 보호, 수집 주기 시간, 리소스 활용 등에 대한 가치 있는 통찰을 얻을 수 있습니다. 이러한 상세 정보는 개발자들이 메모리에 관련된 결정을 내릴 때 인포메이션을 바탕으로 신중한 판단을 할 수 있도록 돕습니다.\n\n<div class=\"content-ad\"></div>\n\n# 16. 내부 클래스에 대한 class_alias() 지원\n\n이 기능은 class_alias() 함수의 기능을 확장하여 내부 PHP 클래스에 대한 별칭을 생성할 수 있도록 지원합니다. 이 향상된 기능은 내부 클래스를 다룰 때 더 많은 유연성과 편의성을 제공하여, 기존 내부 클래스에 대한 대체 이름을 생성할 수 있게 해줍니다. 이를 통해 클래스 참조를 간단히 하고 코드 가독성을 높일 수 있습니다. 아래 예시를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass_alias('DateTime', 'MyDateTime');\n```\n\n이 예시에서는 class_alias() 함수를 사용하여 내부 PHP 클래스 DateTime에 대한 별칭 MyDateTime을 생성합니다. 이를 통해 개발자는 코드베이스 전반에서 MyDateTime이라는 별칭을 사용하여 DateTime 클래스에 참조할 수 있게 되며, 해당 클래스에 대해 더 명확하고 맥락적인 이름을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n내부 클래스 초기화를 위해 클래스 별칭을 사용할 수도 있어요.\n\n```js\n$date = new MyDateTime('2023-11-24');\necho $date->format('Y-m-d');\n```\n\n이 예제에서 MyDateTime 별칭은 내부 클래스 DateTime의 객체를 생성하는 데 사용되었어요. 이 별칭은 클래스 인스턴스 생성에 더 직관적이고 의미 있는 이름을 제공하여 코드의 가독성과 유지 보수성을 높여줍니다.\n\nPHP 8.3의 \"내부 클래스에 대한 class_alias() 지원\" 기능은 내부 클래스에 별칭을 만드는 프로세스를 간소화하여 개발자들에게 내부 클래스에 대한 대체 이름을 정의할 수 있는 편리한 메커니즘을 제공합니다. 이 개선으로 PHP 애플리케이션 내에서 보다 명확하고 읽기 쉬운 클래스 참조를 제공하여 더 표현적이고 일관성 있는 코드베이스로의 기여가 가능해집니다.\n\n<div class=\"content-ad\"></div>\n\n# 17. mysqli_poll() 오류 처리\n\n이 기능은 오류 처리와 관련된 동작 변경을 소개합니다. 특히, mysqli_poll() 함수를 호출할 때 읽기 및 오류 인수를 제공하지 않으면 이제 ValueError가 발생합니다. 이 향상은 mysqli_poll() 함수가 적절한 인수를 사용하여 사용되며, 비동기적 MySQL 쿼리 실행과 관련된 시나리오에서 더 견고하고 예측 가능한 오류 처리를 촉진합니다. 이 동작을 설명하기 위해 예제를 살펴봅시다:\n\n```js\n$links = [...]; // MySQL 링크 배열\n$read = $error = $reject = [];\nif (mysqli_poll($links, $read, $error, $reject, $timeout)) {\n    // 결과 처리\n    foreach ($read as $link) {\n        // 성공한 쿼리 실행 처리\n    }\n    foreach ($error as $link) {\n        // 쿼리 실행 오류 처리\n    }\n    foreach ($reject as $link) {\n        // 거부된 연결 처리\n    }\n} else {\n    // 폴링 오류 처리\n}\n```\n\n이 예제에서 mysqli_poll() 함수는 $read, $error, $reject 배열을 포함한 올바른 인수와 함께 호출됩니다. 이 사용법은 PHP 8.3의 업데이트된 동작을 준수하며, 폴링 작업 결과를 처리하기 위해 필요한 인수로 함수가 호출되도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\nread나 error 인자가 전달되지 않을 때 ValueError를 발생시키는 PHP 8.3은 더 명시적이고 신뢰할 수 있는 오류 처리 방법을 장려하며, mysqli_poll() 호출에 필요한 모든 인자를 제공하도록 개발자들을 격려합니다. 이 개선으로 PHP 애플리케이션에서 비동기 MySQL 쿼리 실행의 전체적인 견고성과 예측 가능성이 향상됩니다.\n\n## array_pad() 기능 향상\n\n이 기능은 array_pad() 함수를 사용하여 한 번에 추가할 수 있는 요소 수에 대한 이전 제한을 제거합니다. 이 개선 이전에 배열을 패딩할 때 한 번에 최대 1048576개의 요소만 추가할 수 있었습니다.\n\n그러나 PHP 8.3에서 소개된 개선으로, array_pad() 함수는 이제 배열이 가질 수 있는 최대 요소 수만 제한으로 나타냅니다. 이를 통해 개발자들은 더 큰 유연성을 가지고 이전의 배열 패딩 작업을 통해 추가할 수 있는 요소 수에 대한 제약을 제거할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 향상은 배열을 훨씬 많은 요소로 채우는 것을 가능하게 하며, 기존 제한으로 인해 배열 크기가 제한되지 않고 다양한 크기의 배열을 다룰 수 있도록 합니다. 결과적으로, 개발자는 array_pad() 함수를 보다 효과적으로 활용하여 배열 조작과 동적 크기 조정이 필요한 시나리오에서 유연성과 확장성을 향상시키는데 기여하며, PHP 애플리케이션 내에서 배열 패딩 작업의 유연성과 확장성을 향상시킵니다.\n\n# 19. opcache.consistency_checks ini 지시문 제거\n\n이 기능은 이전에 OPCache에서 일관성 검사를 활성화 또는 비활성화하는 데 사용되었던 opcache.consistency_checks ini 지시문의 제거를 나타냅니다. 이러한 제거로 인해 opcache.consistency_checks 지시문을 관리할 필요가 없어지며, OPCache 설정 및 유지 관리 프로세스를 간소화하여 OPCache 구성을 단순화합니다. 이 변경이 OPCache 구성에 미치는 영향에 대한 예시는 다음과 같습니다:\n\n이전 OPCache 설정과 opcache.consistency_checks.\n\n<div class=\"content-ad\"></div>\n\n```js\nopcache.consistency_checks=1\n```\n\n이 예제에서는 opcache.consistency_checks 지시문을 1로 설정하여 OPCache의 일관성 검사를 활성화합니다.\n\nPHP 8.3에서 opcache.consistency_checks 지시문이 삭제되면 OPCache의 일관성 검사 구성이 더 이상 필요하지 않아져 OPCache 구성 프로세스가 간소화됩니다.\n\n이 변경은 OPCache 구성에 대한 단순화된 접근 방식을 반영하며, OPCache의 일관성 검사를 관리하는 복잡성을 줄이고 PHP 8.3에서 OPCache의 전체 효율성과 사용 편의성을 향상시키는 목표와 일치합니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 20. number_format()을 사용하여 소수점 처리하는 방법\n\n이 함수는 $decimal 매개변수를 올바르게 처리하도록 개선되었습니다. 이제 $decimal에 음수 정수가 올바르게 처리됩니다. $decimal에 음수 값을 사용하여 반올림하면 $num이 소수점 이전의 지정된 유효 숫자 자릿수로 반올림됩니다. 이전에는 음수 $decimal이 무시되고 숫자가 소수점 이하 자릿수가 0으로 반올림되었습니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\n$num = 1234.56789;\n$formatted1 = number_format($num, 2); // 1,234.57\n$formatted2 = number_format($num, -2); // 1,200\n```\n\n이 예제에서 number_format() 함수는 음수 $decimal 값을 올바르게 처리하여 숫자를 지정된 유효 숫자 자릿수로 소수점 이전에 반올림합니다.\n\n<div class=\"content-ad\"></div>\n\n이 업그레이드는 number_format() 함수를 사용하여 숫자를 반올림할 때 더 일관성 있고 예측 가능한 동작을 보장하여 개발자들이 숫자 값의 형식을 더 잘 제어할 수 있도록 합니다.\n\n축하합니다! PHP 8.3에서 소개된 상위 20가지 기능과 개선 사항에 대해 학습을 완료했습니다. 이 최신 릴리스는 계속 변화하는 개발자들과 기업들의 요구에 부합하는 다양한 개선 사항을 제공하여 더 효율적이고 신뢰할 수 있으며 유지보수가 쉬운 코드를 작성할 수 있도록 지원합니다.","ogImage":{"url":"/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png"},"coverImage":"/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png","tag":["Tech"],"readingTime":23},{"title":"Ecotone과 RabbitMQ를 활용한 PHP 애플리케이션 통합","description":"","date":"2024-05-18 22:28","slug":"2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ","content":"\n\n<img src=\"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_0.png\" />\n\nPHP 애플리케이션(서비스) 간의 통합은 정말 어려울 수 있습니다. 많은 것들이 망가지고 실패할 수 있는 영역으로 진입하게 됩니다. 종종 서로 다른 팀이 소유한 서로 다른 애플리케이션이라는 점이 해결을 더 어렵게 만드는데요. 이러한 통합을 만들기 위해서는 의사소통 방식에 동의해야 하며, 양쪽이 서로 이해할 수 있도록 해야 합니다.\n\n가장 흔한 두 가지 통합 방법은 \"HTTP\" 또는 \"Message Broker\"입니다. HTTP 통합 시 고려해야 할 잠재적인 문제가 있지만, 이에 대한 논의는 이 글의 범위를 벗어납니다. 이 글에서는 Message Broker를 사용한 통합에 중점을 두고 있고, 보다 구체적으로는 RabbitMQ에 초점을 맞출 것입니다.\n\nMessage Broker를 사용한 통합은 메시징 및 경로 지정 패턴에 대한 다양한 지식이 필요하며 쉽게 복잡해질 수 있습니다. 그로 인해 종종 서비스 간의 통합이 복잡한 작업이 되어 논의가 많아지고 실패한 시도와 변경사항이 여러 번 일어나며 종종 몇 일 간이나 더 나쁜 경우에는 몇 주에 걸칠 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 문제의 해결책은 더 높은 수준의 추상화에서 작업하는 데에 있습니다. 우리가 메시지 브로커에서 저수준 라우팅 패턴을 직접 처리할 필요가 없도록 충분히 높은 수준의 추상화를 사용합니다. 목표는 진입 장벽을 낮추고 통합을 쉽게 이해하고 수행할 수 있도록 하는 것입니다. 따라서 통합은 몇 시간이나 몇 분 안에 완료될 수 있습니다. 이 글의 목표는 당신에게 PHP 및 RabbitMQ를 사용하여 Ecotone을 활용하는 방법과 도구를 제공하는 것입니다.\n\n그러나 Ecotone의 솔루션이 어디서 나왔는지 이해하려면 먼저 시스템의 논리적 부분과 물리적 부분 사이의 근본적인 차이를 이해해야 합니다.\n\n# 시스템의 논리적 부분과 물리적 부분\n\n우리가 서비스를 통합할 때, 우리는 시스템의 논리적 부분 또는 물리적 부분에 초점을 둘 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 논리 부분은 비즈니스 측면입니다. 여기에서는 \"결제 서비스에서 결제가 처리되면 배송 서비스가 주문을 전달할 것\"과 같은 비즈니스 개념을 사용하여 논의합니다.\n- 물리 부분은 기술적 세부 정보에 관한 것입니다. 여기에서는 \"소프트웨어.public.payment.order’라는 주제 기반 교환을 생성하고 'payment.ordered' 라우팅 키를 사용하여 메시지를 발행해 'order_shipping' 큐가 이에 바인딩할 수 있도록 해야 한다\"와 같은 메시지 브로커 특정 개념을 사용하여 논의합니다.\n\n우리가 작업하는 추상화 수준이 낮을수록, 논리적인 부분이 아닌 물리적인 부분에 더 많은 초점을 둘 것입니다. 이는 우리가 일을 하는데 더 많은 시간을 코드와 구성 작성, 유지 관리 및 이해에 투자할 것을 의미합니다. 이로 인해 왜 특정 작업을 수행하는지 추적하기 어려워질 수 있으며, 우리의 초점이 세부 사항에 맞추어지고 높은 수준의 그림이 아닙니다.\n\n# Ecotone의 분산 버스\n\nEcotone의 각 서비스는 \"shipping_service\" 또는 \"payment_service\"라는 지정된 이름으로 배포 메커니즘에 연결됩니다.\n여기서 논리적인 부분이 필요합니다. 실제로 비즈니스 경계(응용 프로그램)에 대한 명명을 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 이 이름을 사용하여 Ecotone의 분산 버스를 통해 서비스 간에 통신할 것입니다. 분산 버스는 높은 수준의 추상화를 제공하여 우리가 시스템의 논리적 부분에 집중할 수 있게 해줍니다. 이전에는 메시지 브로커의 저수준 개념에 주의를 기울였던 것과 달리, 분산 버스를 사용하면 더 많은 일을 수행할 수 있습니다.\n\n분산 버스를 사용하면 두 가지 다른 유형의 메시지인 명령(Command)과 이벤트(Event)와 함께 작동하게 됩니다. 이 둘 사이의 차이점은 중요하며, 곧 그 이유를 알게 될 것입니다.\n\n이제 분산 버스를 통해 명령 메시지를 보내는 것으로 시작해 봅시다.\n\n## Ecotone의 분산 메커니즘 활성화하기\n\n<div class=\"content-ad\"></div>\n\nDistributed Bus를 통해 메시지(명령 및 이벤트)를 전송하기 시작하려면 먼저 활성화해야 합니다. Ecotone의 ServiceContext 구성을 사용하여 RabbitMQ를 위해 활성화할 것입니다:\n\n결과적으로 의존성 컨테이너에 DistributedBus가 등록되어 바로 사용할 수 있게 됩니다.\n\nDistributed Bus로부터 메시지를 받으려면 Distributed Consumer를 활성화하고 싶습니다:\n\n이로 인해 새로운 메시지 컨슈머(작업 프로세스)가 등록되어, \"ecotone:run\" 콘솔 명령을 사용하여 실행할 수 있게 됩니다. 메시지 컨슈머의 이름은 이전에 정의한 서비스 이름과 동일할 것입니다:\n\n<div class=\"content-ad\"></div>\n\nSymfony:\n\nLaravel:\n\n# 명령어 전송\n\n우리가 \"order_service\"에서 새 주문을 처리한다고 가정해봅시다. 주문을 받은 후에는 결제를 진행하고 싶습니다. 결제를 진행하기 위해 별도의 \"payment_service\" 서비스를 사용할 것입니다.\n특정 서비스에서 작업을 트리거하고 싶을 때는 명령어를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 명령어(Command)에 대한 개념에 익숙하지 않다면, 이 문서에서 더 자세한 내용을 확인할 수 있습니다.\n\n![Command Concept](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_1.png)\n\n이제 한 번 위 다이어그램을 살펴보고 잠시 멈춰서 생각해 봅시다. 이 다이어그램에는 우리가 다음 질문에 대답하는 데 도움이 되는 두 가지 논리적인 지점이 있습니다:\n\n- 어디로 명령을 보내고 싶은가? — 우리는 명령을 결제 서비스로 보냅니다.\n- 거기서 어떤 조치를 취하고 싶은가? — 우리는 결제를 진행하기 원합니다.\n\n<div class=\"content-ad\"></div>\n\n위의 내용은 우리가 어떤 경계로 상호작용하며 어떻게 하는지를 설명하는 중요한 정보입니다.\n\n실제로 Ecotone의 분산 버스를 사용하여 이를 가능하게 합시다:\n\n코드는 위 다이어그램과 같은 질문에 답하므로 더 높은 수준의 관점을 이해하기 위해서는 필요하지 않습니다. 우리는 결제 서비스에 명령을 보내어 결제를 수행하는 것을 쉽게 이해할 수 있습니다.\n분산 버스가 트리거되면 명령 메시지가 \"payment_service\"로 전송됩니다.\n\n# 명령 수신\n\n<div class=\"content-ad\"></div>\n\n이제 Payment Service에서 명령을 받을 수 있게 되었으니, 분산 Command Handler를 등록합시다:\n\n여기서 CommandHandler 및 Distributed 속성을 사용하여 다음을 수행합니다:\n\n- 주어진 메서드를 CommandHandler 속성으로 표시함으로써 로컬 CommandBus에 의해 트리거될 수 있도록 합니다.\n- Distributed 속성을 추가함으로써 분산 Command Handler가 DistributedBus에서도 사용 가능하도록 지정합니다.\n\n이제 이 Command Handler는 \"payment.take\" 라우팅 키를 사용하여 분산 통신에 사용할 수 있습니다.\nEcotone을 사용하여 서비스 간 통신을 위해 할 일은 여기까지입니다.\n\n<div class=\"content-ad\"></div>\n\n# 명령어는 어떻게 작동합니까\n\n저희가 RabbitMQ와 직접 통합을 작성하지는 않겠지만, 더 높은 수준의 코드에서 작업 중이므로 사실상 어떻게 작동하는지 알아두는 것이 여러분에게 도움이 될 것입니다.\n\n명령어를 보낼 때, 사실은 서비스 이름을 라우팅 키로 하는 메시지를 보내는 것입니다:\n\n![image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_2.png)\n\n<div class=\"content-ad\"></div>\n\nService가 소비자로서 Ecotone의 분산 메커니즘에 연결되면 자동으로 해당 서비스 이름에 의해 바인딩된 Queue가 생성됩니다:\n\n![Queue Creation](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_3.png)\n\n이것은 결제 서비스로 명령이 전송될 때 이 서비스의 Queue로 전달됨을 의미합니다.\n그런 다음 결제 서비스 Queue에서 메세지가 소비되면 우리의 분산 명령 핸들러를 트리거합니다.\n\n# 이벤트 메세지 발행\n\n<div class=\"content-ad\"></div>\n\n지금까지 명령에 대해 논의했지만, 두 번째 유형의 메시지인 이벤트 메시지도 있습니다. 이벤트는 특정 서비스에 보내는 대신 게시되며, 관심이 있는 누구나 구독할 수 있습니다. 따라서 이벤트 메시지는 여러 서비스에 전달될 수 있습니다.\n\n이벤트 개념에 익숙하지 않다면 다음 기사에서 자세한 내용을 확인할 수 있습니다.\n\n성공적인 결제의 결과로 주문을 고객에게 전달하려고 합니다. 결제는 \"payment_service\"에서 처리되고 배송은 \"shipping_service\"에서 이루어집니다.\n\n우리가 이벤트 메시지를 게시할 때는 Ecotone의 분산 교환에 라우팅 키를 제공하여 메시지를 보내는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_4.png)\n\n# 이벤트 메시지 구독\n\n분산 이벤트를 구독하는 것은 매우 간단합니다. 라우팅 키 이름과 분산 속성을 EventHandler에 제공합니다.\n\nEcotone은 내부적으로 우리 서비스의 큐를 주어진 라우팅 키로 바인딩합니다:\n\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_5.png\" />\n\n모든 작업이 명령 및 이벤트를 사용하여 통신하는 데 필요한 것은, Ecotone을 사용하는 것이 매우 직관적이며 시스템의 논리 부분에 집중하려면 이것이어야 하는 방법입니다. Ecotone 분산 모듈을 설치하는 방법은 문서 페이지에서 읽을 수 있습니다.\n\n이제, 분산 통신을 시작할 때 자주 논의되는 몇 가지 다른 시나리오를 살펴볼 수 있습니다.\n\n# 이벤트 비공개 유지\n\n\n<div class=\"content-ad\"></div>\n\n시스템은 분산 통신을 명시적으로 처리하지 않는 경우가 많습니다. 이러한 상황에서 외부 서비스는 우리의 이벤트에 단순히 바인딩되어 있으며, 때로는 우리의 통제 없이 연결될 수 있습니다. 이벤트가 노출될지 여부가 결정되지 않은 상태에서 외부 서비스가 이벤트에 바인딩되면 추적하기 힘들어집니다.\n\n이에 따라 외부 서비스에 의해 소비되는 것이 무엇이고 어떻게 되는지 쉽게 잊어버릴 수 있으며, 명시적 서비스 경계가 퇴화될 수 있습니다:\n\n- 우연히 다른 시스템을 손상시킴 — 다른 서비스가 우리의 내부 이벤트에 직접 바인딩될 수 있으면, 그 서비스는 우리의 이벤트를 소비하는 측이 됩니다. 이벤트 구조를 변경하면 외부 서비스가 우연히 손상될 수 있습니다.\n- 현대화의 부재 — 우리의 이벤트는 공용 이벤트가 되었으므로, 우리는 더 이상 완전히 소유권을 가지지 않게 됩니다. 결과적으로 변경할 수 있는 것을 실제로 논의하고 상담해야 합니다. 이는 종종 사람들이 이벤트를 변경하려는 뜻을 내지 않게 만들어, 시간이 너무 많이 소요된다는 이유에서 그렇습니다.\n- 논리적 부분 손실 — 경계를 논의하고 비즈니스 언어를 사용한 서비스 간 통신은 종종 잊혀지거나 이해하기 어려울 수 있습니다. 우리는 비즈니스 개념이 적용되지 않는 저수준 프로그래밍으로 빠지게 되는 것입니다.\n\n반면 분산 버스를 사용하면 사항을 명확하게 처리하고 서비스 경계가 존중됩니다. 우리가 외부로 발행하고 싶은 것과 비공개로 유지하고 싶은 것을 명시적으로 명시합니다. 이러한 방식으로 팀 내 모두에게 경계의 가장자리에 무엇이 존재하고 무엇이 내부에 유지되는지 명확하게 보여줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 모든 이벤트 배포하기\n\n기본적으로 모든 시스템은 외부로 모든 이벤트를 발행하는 여러 시스템이 있습니다. 이는 위에서 설명한 문제를 상속받기 때문에 권장되지 않지만, 이미 해당 방식으로 시스템이 작동 중이라면 필요할 수 있습니다.\n\n레거시 시스템에서 Ecotone으로 마이그레이션할 때, 더 큰 변경을 피하기 위해 이 동작을 유지하고 싶을 수 있습니다. 이러한 상황에서는 대부분 이벤트 버스를 사용합니다. 이러한 상황에서는 현재의 이벤트 버스를 Ecotone의 이벤트 버스로 대체하여 내부적으로 이벤트를 발행할 수 있습니다.\n\n그리고 간단히 \"object\"에 구독하여 모든 이벤트를 구독하여 분배할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n객체 대신에 여기에 구현된 이벤트 집합을 전달하는 인터페이스를 사용할 수도 있습니다. 또는 이벤트 클래스의 합집합으로도 전달할 수 있습니다:\n\n# 비공개 대 공용 이벤트\n\n일반적으로 분산 이벤트(공용)와 단일 서비스 수준에서 처리해야 하는 이벤트(비공개) 사이의 구별을 따르는 것이 좋습니다.\n이렇게 하면 내부적으로만 사용되는 이벤트를 안전하게 변경할 수 있는지 여부를 알 수 있고 변경하기 전에 특별한 주의를 요하는 이벤트를 알 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이벤트 분배 중에 우리는 더 많은 단계를 거쳐 Public Event에 사용자 정의 구조를 제공할 수 있습니다. 이렇게 하면 내부 이벤트 구조가 외부 서비스와 완전히 분리될 것입니다.\n\n# 분리된 메시지 클래스\n\n어떤 프레임워크에서는 발행 및 수용 측에서 동일한 클래스를 사용해야 합니다. 즉, 이벤트나 명령을 역직렬화하려면 각 참여 서비스에서 동일한 이름과 네임스페이스를 가진 클래스가 필요합니다. 이는 서비스 간에 강력한 결합을 만들어내기 때문에 이 클래스 이름이 변경되면 쉽게 깨질 수 있습니다.\n\nEcotone에서는 메시지가 클래스가 아닌 라우팅을 기반으로 전달됩니다. 역직렬화해야 할 클래스는 메시지 핸들러 실행 전에 메서드의 매개변수를 기반으로 결정됩니다. 따라서 각 서비스에서 클래스 이름이 다르더라도 이를 역직렬화할 수 있습니다. 이는 더 나아 가서, 배열로 역직렬화할 수 있기 때문에 실제로 클래스를 사용할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n게시 측면이 분리되는 것처럼 원하는 유형을 사용할 수 있습니다. 예를 들어, 배열:\n\n서비스를 분리하는 방법에 대해 더 알고 싶다면, 해당 내용을 다룬 이전 기사 중 하나를 읽어보세요.\n\n# 한 번에 더 많은 이벤트를 구독\n\n주어진 서비스가 더 많은 이벤트를 구독할 때는 *, 즉 별표를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이렇게하면 \"billing.\" 접두사가 포함된 모든 이벤트에 등록합니다.\n\"billing.order_charged\", \"billing.refund.made\"가 포함됩니다.\n\n# 오류 모드\n\n주어진 메시지 처리에 문제가 발생하는 경우, Ecotone은 오류 처리를 제공합니다. 오류 처리는 서비스 수준 비동기 처리와 정확히 동일하게 작동합니다.\n예외가 발생하는 경우 구성에 따라 처리를 차단하거나 지연된 재시도를 사용할 수 있습니다:\n\n![이미지](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_6.png)\n\n<div class=\"content-ad\"></div>\n\n딜레이 재시도가 초과되면 메시지를 삭제하거나 Dead Letter Database에 저장할 수 있습니다.\n\n![image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_7.png)\n\n재시도와 Dead Letter에 대해 더 읽고 싶다면 문서 페이지를 확인해주세요.\n\n## 사용자 정의 오류 메커니즘 제공\n\n<div class=\"content-ad\"></div>\n\n에러 핸들링 프로세스를 완전히 맡을 수도 있습니다. 사용자 정의 에러 채널을 정의하여:\n\n그런 다음 서비스 활성화기를 사용하여 연결할 수 있습니다.\n\n# 누락된 명령 핸들러\n\n명령 라우팅 키가 실제로 변경되었거나 명령 핸들러가 단순히 삭제되었을 수 있습니다. 이러한 상황에서 메시지가 그냥 버려지거나 무시되는 것을 원치 않으며, 이는 해결해야 할 잠재적인 버그이므로 데이터를 보존해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_8.png\" />\n\n서비스 이름을 통해 명령이 라우팅되기 때문에 대상 서비스로 메시지가 전달됩니다. 대상 서비스에서 라우팅이 변경되어도 Ecotone은 실패 모드를 시작하며 해당 명령을 Dead Letter에 저장합니다.\n\n# Outbox Pattern을 사용하여 안전하게 이벤트 배포하기\n\n메시지를 RabbitMQ로 보내고 데이터베이스에 변경 사항을 저장하는 동시에 한 번에 변경사항을 저장하면 일관되지 않은 상태에 빠질 수 있습니다. 이는 두 개의 저장소에서 동시에 변경사항을 수행하고 있기 때문에 한쪽이 실패할 수 있기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_9.png)\n\nIn the code, it would look like this:\n\nTo solve this, we can use Ecotone's inbuilt feature to send messages over the Database:\n\n![Image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_10.png)\n\n\n<div class=\"content-ad\"></div>\n\n먼저 에코톤(Event Bus)을 사용하여 이벤트를 내부적으로 발행할 것입니다.\n\n각 Command Handler는 기본적으로 데이터베이스 트랜잭션으로 랩핑되므로 주문(Order)과 메시지(Message)가 함께 커밋됩니다.\n그런 다음 내부 이벤트를 구독하고 분배합니다.\n\n이벤트 핸들러가 데이터베이스에 메시지를 저장하려면 \"orders\"를 데이터베이스 메시지 채널로 정의해야 합니다.\n\n더 많은 내용을 보고 싶다면, 이전 게시물 중 하나를 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n# 메타데이터 전송\n\n명령 또는 이벤트와 함께 메타데이터를 전송하고 싶을 때가 있습니다. 이는 실행자 ID, 타임스탬프 또는 요청이 발생한 이벤트 HTTP 도메인과 같은 세부 정보일 수 있습니다.\n\n이러한 세부 정보는 주로 메시지 처리 관점에서 중요하지 않을 수 있지만, 나중에 트리거된 감사, 디버깅 또는 사이드 이펙트와 같은 부작용을 위해 중요할 수 있습니다. 이러한 정보를 명령 또는 이벤트에 직접 넣으면 목적이 흐릿해질 수 있고 전달하기 번거로울 수 있습니다.\n\nEcotone은 메타데이터를 주요 역할로 취급하여 명령과 이벤트와 함께 전달되도록 하여 이 문제를 해결합니다.\n\n<div class=\"content-ad\"></div>\n\nDistributed Event Handlers로 직접 액세스할 수 있습니다.\n\nMetadata 및 전파는 메시지 기반 시스템에서 중요하며 Ecotone은 여기에 표시된 것보다 더 많은 기능을 지원합니다. 해당 주제를 깊이 있게 탐구하고 싶다면, Laravel의 Multi-Tenant 또는 Symfony의 Multi-Tenant를 읽어보는 것을 추천합니다. 이 주제에 대해 더 자세히 설명되어 있습니다.\n\n# 별도의 대기열 및 처리\n\n지금까지 우리는 단일 메시지 대기열의 맥락에서 분산 메시지 처리에 대해 논의해 왔습니다. 그러나 대규모 시스템에서는 실제로 일부 메시지를 다른 것들과 별도로 또는 더 높은 우선순위로 처리하길 원할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n메시지 소비자를 따로 확장하려면 Taken Payments와 Failed Payments에 관련된 것을 분리할 수 있습니다. 그런 다음 이를 서로 다른 메시지 채널(큐)로 분리할 수 있습니다:\n\n![Image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_11.png)\n\n서비스 수준의 코드는 다음과 같이 보일 것입니다:\n\n그런 다음 Service Context 구성을 사용하여 \"taken_payments\" 및 \"failed_payments\" 메시지 채널을 정의합니다:\n\n<div class=\"content-ad\"></div>\n\n이를 통해 우리는 결제 요청에 대한 메시지 소비자를 확장할 수 있고 실패한 지불로부터 독립적으로 처리할 수 있으며 분산 큐를 단순한 프록시로 다룰 수 있습니다.\n\n# 개요\n\n우리가 작업하는 코드의 수준이 낮을수록 시스템의 논리적 부분에 높은 희생을 감수해야 할 것입니다. 기술적 세부 사항에 집중할수록 비즈니스 부분에 집중하기 어려워집니다.\n\n반면에 Ecotone은 우리에게 더 높은 수준의 추상화로 작업할 수 있는 도구를 제공하여 더 빠르게 제공하고, 덜 구성이 필요하며 비즈니스에 더 많은 초점을 둘 수 있습니다. 비즈니스 중심적인 접근은 강요되지 않아야 하며, 통합에 덜 시간을 쓰면 자연스럽게 비즈니스 부분에 초점을 맞출 것입니다. 이렇게 하면 사람들이 비즈니스 요구에 부합하는 고품질 소프트웨어를 생산할 수 있는 환경을 조성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 저장소의 분산 통신 예시 구현과 Symfony 및 Laravel로 작성된 완전한 애플리케이션 예시를 분산 버스를 통합하여 찾아 볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_0.png"},"coverImage":"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_0.png","tag":["Tech"],"readingTime":12},{"title":"NextJs 14에서 Route Groups이란 무엇인가?","description":"","date":"2024-05-18 22:26","slug":"2024-05-18-WhatareRouteGroupsinNextJs14","content":"\n\n안녕하세요 여러분! Next.js에서는 종종 페이지를 앱 디렉토리 내의 폴더로 구성하죠, 맞죠? 그런데 만약 URL 경로를 지저분하게 하지 않고 관련된 경로를 그룹화하고 싶다면 어떻게 할까요? 바로 Route Groups가 등장합니다!\n\n그러니 함께 살펴봅시다. NextJs의 이 개념에 익숙하실 것입니다. 우리는 각 폴더에 page.tsx 파일을 포함하여 앱 디렉토리 안에 폴더를 만들 수 있습니다. 이를 통해 URL 경로에 폴더 이름을 추가할 수 있게 됩니다. 아래는 이를 설명하는 예시입니다:\n\n![Route Groups in NextJs](/assets/img/2024-05-18-WhatareRouteGroupsinNextJs14_0.png)\n\n이것은 앱 폴더 내의 폴더 디렉토리로, 'button'이라는 폴더를 만들고 그 안에 page.tsx 파일을 만들었습니다.\n\n<div class=\"content-ad\"></div>\n\n/button으로 이동하면 page.tsx에 있는 내용을 볼 수 있습니다.\n\n기본 사항을 잘 이해하셨으니, 여기서 라우트 그룹이 어떻게 작용하는지 알아보겠습니다. 많은 경우, 우리는 만들어 둔 폴더를 표시하고 싶지 않거나 URL을 깔끔하게 유지하면서 관련 폴더를 그룹화해야 할 때가 있습니다. 이때 라우트 그룹이 마법을 부리는 시점입니다! 라우트 그룹을 사용하면 경로에 추가하지 않고 폴더 이름을 생성할 수 있습니다. 유일한 제한 사항은 NextJS가 어떤 이름을 회피해야 하는지 알기 위해서는 폴더 이름을 원형 괄호로 감싸야 한다는 것입니다.\n\n다음은 예시입니다:\n\n![라우트 그룹 예시](/assets/img/2024-05-18-WhatareRouteGroupsinNextJs14_1.png)\n\n<div class=\"content-ad\"></div>\n\n우리가 처음에 논의한 것에 따르면, 페이지.tsx의 콘텐츠를 표시할 때 URL이 example/button과 같아야 했지만 example이 괄호 안에 있기 때문에 NextJS는 경로에 포함할 필요가 없다는 것을 알고 있어 URL은 /button이 됩니다.\n\n그래서 언제 경로 그룹을 사용해야 할까요?\n1. 간소화된 URL 경로: 관련된 route를 그룹화하여 폴더에 넣고 URL 경로를 그룹 폴더의 이름으로 복잡하지 않게 만들고 싶을 때 사용합니다.\n\n2. 사용자 정의 레이아웃: 특정 폴더에 대해 다른 레이아웃을 사용하고 싶을 때 사용합니다. 한 폴더에 속하는 모든 파일은 레이아웃.tsx를 따르며 이를 통해 각 폴더에 맞게 사용자 정의 레이아웃을 가질 수 있습니다!\n\n경로 그룹에 대해 더 알아보려면, 공식 NextJS 문서를 읽는 것을 추천합니다: [NextJS 문서](https://nextjs.org/docs/app/building-your-application/routing/route-groups)","ogImage":{"url":"/assets/img/2024-05-18-WhatareRouteGroupsinNextJs14_0.png"},"coverImage":"/assets/img/2024-05-18-WhatareRouteGroupsinNextJs14_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter와 Firebase로 픽셀 아트 앱 만들기","description":"","date":"2024-05-18 22:24","slug":"2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase","content":"\n\n## 자신만의 r/place 만들기\n\n![이미지](/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_0.png)\n\n# 소개\n\n요즘 r/place나 z/place에 대해 들어보셨을 것 같은데, 듣지 못했다면 무슨 얘길 하는 건지 궁금하실 것입니다. 이것들은 협업 프로젝트이자 소셜 실험이며, 사용자들이 한 번에 한 픽셀의 색을 변경하여 캔버스를 편집할 수 있는 프로젝트입니다. 행사가 끝나면 대개 2~3일 후에 아름다운 픽셀 아트 작품이 완성됩니다. 모든 정보는 위키백과에서 찾아볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n음, 저의 GitHub 계정에서 전체 프로젝트를 찾을 수 있어요! 이 프로젝트는 클린 아키텍처 패턴을 따르지만 몇 가지 변형이 있어요. 이 글을 위해 완전히 맹목적이 될 필요를 느끼지 않았답니다.\n\n# 받게 되는 것\n\n# 필수 요구 사항\n\n- 픽셀을 그리고 색상을 선택하는 방법.\n- 픽셀을 저장하고 가장 중요한 것은 변경이 발생할 때 사용자에게 알릴 수 있는 실시간 데이터베이스.\n\n<div class=\"content-ad\"></div>\n\n## 당신처럼 나를 그려주세요...\n\n![image](/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_1.png)\n\n먼저, 픽셀을 설명하는 클래스를 생성해봅시다. 별로 복잡한 건 아닙니다. 그저 2D 위치를 설명하는 Offset이 필요한데요, 이것은 그릴 위치와 현재 색상을 알려줍니다. 고급 섹션에서는 추가 정보도 더할 수 있습니다.\n\n픽셀을 그리기 위해서는 캔버스를 제공하는 위젯이 필요합니다. 그것이 CustomPaint가 하는 일이며, 표현하고자 하는 내용과 방법을 지정하기 위해 CustomPainter가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n기본적으로 CustomPaint는 화면 전체를 차지하지만, 모두에게 동일한 그리기 경험을 제공하고 싶으므로 그냥 1920x1080으로 고정하겠습니다. 이는 200만 픽셀 이상이 됩니다. 충분할 거예요! 흥미로운 사실은 사용하지 않는 두 가지 추가 속성이 있답니다. isComplex와 willChange입니다. 열광적으로 개발한다면 캐시 이점을 얻기 위해 true로 설정해보세요.\n\n그런 다음, 우리는 CustomPainter와 그 Paint 설정을 생성해야 합니다.\n\n조금 더 복잡해졌어요. 우리의 painter는 CustomPainter를 확장한다는 점을 보실 수 있죠. 이렇게 함으로써 paint와 shouldRepaint 메서드를 재정의해야 합니다. 그리려는 List`Pixel`을 매개변수로 받아서... 그뿐이에요. repaint 인수는 필요하지 않습니다. 픽셀 목록이 업데이트될 때마다 뷰가 다시 빌드될 거에요. 그런 다음 간단합니다, 픽셀 목록을 반복하고 각각의 해당 좌표에 그려주기만 하면 되죠.\n\n게다가, 픽셀 좌표를 결정하는 방법이 필요해요. 가장 쉬운 방법은 CustomPaint를 Listener 위젯으로 감싸고 onPointerDown 콜백을 구현하는 겁니다. 그렇게 함으로써 localePosition 이벤트 매개변수를 활용하여 커서 위치를 얻을 수 있어요. position을 사용하지 마세요. 그렇게 하면 절대 위치가 아닌 캔버스 내에서의 상대 위치를 얻을 거에요.\n\n<div class=\"content-ad\"></div>\n\n드디어 색상을 선택하기 위해 flutter_colorpicker 패키지를 사용하기로 결정했어요. 제가 직접 위젯을 구현할 수도 있었지만, 어차피 이미 만들어진 것을 다시 만들 필요 없잖아요.\n\n별 다른 얘길 할 게 없어요. BlockPicker 위젯은 Scaffold AppBar에 위치해 있고, onColorChanged가 트리거될 때마다 새로운 색상을 저장하여 CustomPainter에 제공하고 있어요. 저는 제가 필요에 맞게 하나를 만들었지만, 기본 레이아웃을 사용하셔도 되요.\n\n# 지속성\n\n![이미지](/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_2.png)\n\n<div class=\"content-ad\"></div>\n\n데이터베이스를 빠르게 설정하는 가장 빠른 방법 중 하나는 아마도 Firebase를 사용하는 것입니다. 사용하기 쉽고 잘 문서화되어 있으며 기본적인 용법 대부분에 대해 무료로 제공됩니다. Firebase 콘솔에서 프로젝트를 만들고 Firebase 실시간 데이터베이스를 활성화하고 플러터 프로젝트에서 Firebase 데이터베이스를 구성하면 됩니다. 현재는 권한에 대해 걱정할 필요가 없습니다. 그냥 누구든지 데이터베이스를 읽고 쓸 수 있도록 허용하십시오.\n\n```js\n{\n  \"rules\": {\n    \".read\": true,\n    \".write\": true,\n  }\n}\n```\n\n최악의 경우 캔버스를 잃을 수도 있습니다. 하지만 우리는 그것을 대처할 수 있을 거예요, 분명합니다.\n\n# 네트워크 레이어\n\n<div class=\"content-ad\"></div>\n\n빠르고... 깔끔하게 진행해 봅시다! BLoC와 FirebasePixelsRepository를 설정하여 각각 프레젠테이션 레이어와 Firebase 데이터베이스와 상호 작용하도록 해보세요.\n\n저장소부터 시작해 봅시다. 소개에서 언급했듯이, 데이터베이스에서 변경 사항이 발생할 때마다 알림을 받아야 합니다. 그래서 우리는 실시간 데이터베이스와... 스트림을 사용합니다. 목표는 데이터 변경 사항을 수신하고 그에 따라 반응하는 것입니다.\n\nPixelsRepository는 간단한 인터페이스입니다. 실용적으로 생각해 봅시다. 우리에겐 두 가지 기능만 필요합니다.\n\n- createPixel은 좌표를 기반으로 한 고유 해시로 참조된 픽셀을 만듭니다. 이를 통해 색상을 변경할 때 쉽게 액세스할 수 있으며 계속해서 새로운 픽셀을 무조건적으로 만드는 것을 방지합니다.\n- listenPixels는 데이터베이스 내의 추가 또는 변경 사항에 구독하고, 스트림에 푸시하여 새로운 픽셀이 생성되거나 업데이트될 때 알립니다. StreamGroup에 대해 자세히 알아보세요.\n\n<div class=\"content-ad\"></div>\n\nPixelModel은 다음과 같습니다. (역)직렬화 개체를 원활하게 수행하기 위해 두 개의 컨버터를 만들었습니다. 비용이 거의 들지 않습니다. 많이 도와줍니다.\n\n이제, 저장소와 표현 계층 사이에 작은 다리를 만들어 봅시다. 관심사의 분리 원칙... 당신은 이미 알고 계시겠지만요!\n\n무서워하지 마세요! 정말 아무것도 아닙니다. 저희 BLoC는 PixelsEventListen 및 PixelsEventAdd에 대응하여 저장소 메서드를 수신합니다. 또한 customStream과 `Map<int, Pixel>`을 생성하여 이를 스트림을 통해 표현 계층에 제공합니다.\n\n언급할 가치가 있는 두 가지 사항: 먼저, 우리는 listen을 사용하여 스트림을 구독합니다. 두 번째, 우리는 cancelOnError를 사용하지 않습니다. (데이터의) 흐름을 계속 유지합시다.\n\n<div class=\"content-ad\"></div>\n\nBLoC를 뷰에 추가하고 Stream을 StreamBuilder 위젯에 제공하세요. 그런 다음 데이터를 캔버스로 전송하세요. 여러 창에서 실행하고 하나에서 픽셀을 만들면 다른 창에서도 복제되는 것을 볼 수 있어야 합니다.\n\n# Make It Shine\n\n![Build a Collaborative Pixel Art App with Flutter and Firebase](/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_3.png)\n\n<div class=\"content-ad\"></div>\n\n이제 조금 빨리 진행하겠습니다. 실제 r/place 규칙에 더 가까운 몇 가지 추가 기능을 제공하기 위해 노력할 거에요. 너무 제한적이지 않으면서도 사용자가 이를 변경할 수 없게 할 생각이에요.\n\n## 사용자 인증\n\nfirebase_auth 패키지를 추가하고, firebase 콘솔에서 인증 기능을 활성화하고 익명을 로그인 방법으로 허용해주세요. 그런 다음 firebase_auth_repository를 만들어 처리하도록 해봐요. 물론, 이메일, Google 등의 다른 가입 수단을 추가해도 되요.\n\n우리가 매우 기본적인 인증 개념을 가졌기 때문에 보안 규칙을 조금 업그레이드할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```json\n{\n  \"rules\": {\n    \".read\": true,\n    \".write\": \"auth != null\"\n  }\n}\n```\n\n와우! 이제 인증된 사용자만 픽셀 쓰기가 가능합니다. 다음으로 뷰와 상호 작용할 AuthCubit을 생성하고 해당에 버튼을 추가하면 끝입니다!\n\nCubit을 사용하면 BLoC과 달리 사용자 정의 이벤트를 만들 필요가 없습니다. 메소드를 바로 호출하면 됩니다!\n\n## 수정 이력\n\n\n<div class=\"content-ad\"></div>\n\n픽셀이 추가되거나 수정될 때마다 모든 변경 사항을 추적할 시간입니다. 우리가 픽셀을 저장하는 데 사용한 것과 동일한 Realtime 데이터베이스를 사용해 봅시다. 이를 위해 단순히 createPixel 메서드를 업데이트하면 됩니다.\n\n완료했습니다. 픽셀을 생성하는 동시에 새로운 고유한 참조를 푸시하고 해당 픽셀 정보를 설정합니다. 유일한 차이점은 모든 변경 사항을 영원히 유지할 것이라는 것입니다. 그것들을 사용하여 재생을 생성하는 데 사용할 수도 있겠죠?\n\n픽셀 생성에 했던 것과 마찬가지로 전용 스트림을 작성해 주세요. 프레젠테이션 레이어에서는 각각이 픽셀 업데이트인 ListTile 목록을 포함하는 ListView에 데이터를 제공하면 됩니다. 구현에 대한 레포지토리를 확인하시고, 쉬우니까요.\n\n## 확대/축소\n\n<div class=\"content-ad\"></div>\n\n이건 조금 어려울 거에요. 지금까지 사용자들은 전체 1920x1080 캔버스를 볼 수 있기 위해 매우 큰 스크린을 갖고 있어야 했어요. 이 문제를 해결하기 위해, 먼저 수직 및 수평 스크롤을 위한 double SingleChildScrollView 위젯을 추가하고 싶을 수 있지만, 이것은 실수일 수 있고 어차피 부드럽게 작동하지 않아요.\n\n캔버스를 InteractiveViewer 위젯 내에 감싸야 해요. constrained 속성을 false로 설정하고 minScale 및 maxScale을 필요에 맞게 조정해야 해요. 이렇게 하면 화면 크기에 상관없이 원하는 곳으로 이동할 수 있을 거예요. 자세한 정보는 문서를 참고해주세요.\n\n레이아웃 제약 조건을 처리하고 위젯을 올바르게 배치하는 방법에 대한 정보는 저장소를 확인해주세요.\n\n## 호스팅\n\n<div class=\"content-ad\"></div>\n\n정말 간단해요. 공식 문서를 따라하기만 하면 돼요.\n\n먼저 flutter build web --release 명령어를 실행하고, firebase init hosting 명령어를 실행해서 몇 가지 질문에 답하면 호스팅 URL을 얻을 수 있어요. 도메인을 더 세밀하게 설정하려면 Firebase 콘솔의 호스팅 구성을 확인하세요.\n\n```js\n? What do you want to use as your public directory? build/web\n? Configure as a single-page app (rewrite all urls to /index.html)? No\n? Set up automatic builds and deploys with GitHub? No\n✔ Wrote build/web/404.html\n```\n\nbuild/web을 공개 저장소로 설정하는 것이 중요해요. 여기에 소스 파일이 저장돼 있어요. 그런 다음 firebase deploy를 실행하면 웹사이트가 공개돼요!\n\n<div class=\"content-ad\"></div>\n\n제가 작성하는 것만큼 읽는 데 즐거움을 느끼셨기를 바랍니다. 이 글은 조밀하게 쓰여 있어 몇 가지 세부 내용을 건너뛴 것 같지만 필요하다면 저장소를 확인해 주세요.\n\n## 더 알고 싶으신가요?","ogImage":{"url":"/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_0.png"},"coverImage":"/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_0.png","tag":["Tech"],"readingTime":7},{"title":"패닉에서 준비 상태로 나의 면접 경험","description":"","date":"2024-05-18 22:22","slug":"2024-05-18-FromPanictoPreparedMyInterviewExperience","content":"\n\n<img src=\"/assets/img/2024-05-18-FromPanictoPreparedMyInterviewExperience_0.png\" />\n\n안녕하세요 👋 제 독자 여러분, 제목을 보시다시피 몇 분들이 무엇을 쓸 것인지 유추하셨을 거에요. 하지만 기다려주세요, 모든 걸 스스로 가정하지 마시고, 모두가 고유한 경험을 갖고 있기 때문이에요. 그리고 재미있는 사실은, 이 글은 제 인터뷰 경험에 대한 이야기입니다.\n\n이 글의 목적: 많은 분들이 이 글을 쓰는 이유가 궁금할 텐데, 그 이유는 제 인터뷰 의식주에 대한 통찰과 생각을 공유하고자 하는 것입니다.\n\n# 취업 인터뷰의 현실\n\n<div class=\"content-ad\"></div>\n\n요즘에 두 개의 취업 면접을 진행했는데, 자주 인위적으로 느껴지는 질문에 대비하는 데 얼마나 많은 시간을 소비했는지를 깨달았어요. \"자기 소개해주세요\", \"귀하는 약점이 무엇이라고 생각하나요\", \"귀하는 강점이 무엇이라고 생각하나요\", \"이 직무를 원하는 이유\", \"이전 직장에서 다른 직장으로 이동한 이유\" 등의 질문은 면접 과정에서 필수적인 질문들이에요. 저희를 포함한 많은 지원자들은 완벽한 대답을 준비하기 위해 ChatGPT와 같은 자원을 활용해요. 그런데, 왜 우리는 면접관들에게 완벽한 모습으로 보여주어야 하는 필요성을 느끼는 걸까요?\n   \n# 진정성을 받아들이기\n\n사실은, 모든 사람들은 각자의 약점을 갖고 있는데, 그것은 전혀 괜찮은 일이에요. 그럼에도 불구하고, 면접에 관한 관행적인 지혜는 종종 우리가 완벽해야 한다는 생각을 장려해요. 마치 면접이 두 사람 사이의 대화가 아닌 서로가 실제보다 나아보이려고 하는 거짓말쟁이들의 대화인 것 같아요. 이런 가장을 꾸밀 필요 없이 약점을 강점으로 내세우기 위해 허구적인 행동을 하는 것은 가짜 같고, 저의 실제 모습을 정확하게 대변하는 것이 아니에요.\n\n# 면접관들의 불완전함\n\n<div class=\"content-ad\"></div>\n\n생각해보세요: 인터뷰를 진행하는 사람도 완벽하지 않다는 사실을요. 그들에게도 약점과 결점이 있습니다. 그렇다면 우리 지원자로서 왜 진정한 모습을 숨겨야 하는지 강요받아야 할까요? 사실 아무도 완벽하지 않다는데, 완벽한 사람으로 자처하는 것이 어색하고 약간 죄책감을 느끼게하는 생각이에요.\n\n# 불완전함의 아름다움\n\n불완전함이 인간의 아름다움이에요. 인터뷰 관계자들이 후보자들을 그들이 진정으로 가진 강점과 약점을 받아들인다면, 인터뷰 프로세스가 더 진솔하고 의미있어질 거예요. 제처럼 자신을 솔직히 밝히기 위해 직장을 확보하기 위해 거짓말하고 싶지 않은 사람들이 많이 있어요. 인터뷰어들이 이를 이해하고 완벽보다는 진실성을 받아들이는 것이 때 되었다고 생각해요.\n\n모두에게 제 경험을 공유하자면, 솔직히 몇몇 인터뷰 질문이 마음에 들지 않아요. 대답에 어려움이 있는 것이 아니라, 제 답변을 진실하게 받아들이기 어려운 인터뷰어들 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n# 나의 첫 면접: 배운 경험\n\n나는 첫 면접을 준비할 때 정말 무척이나 긴장했어요. 많은 지원자들이 느낄 것 같아요. 부족한 자신감으로 더욱 불안해지고 때때로 심지어 패닉에 빠졌죠. 그럼에도 불구하고 나는 그 상황을 극복하고 면접을 완료했어요. 이 경험으로부터 몇 가지 소중한 교훈을 얻을 수 있었어요.\n\n# 주요 포인트:\n\n## 말 속도를 조절하세요\n\n<div class=\"content-ad\"></div>\n\n내가 먼저 깨달은 것 중 하나는 일정한 이야기 속도를 유지하는 중요성이었습니다. 때로는 너무 빨리 말하고 때로는 너무 느리게 말했습니다. 균형을 맞추고 보통 속도로 말하는 것이 중요합니다.\n\n**## 주의 깊게 듣기**\n\n질문을 주의 깊게 듣고 단계별로 대답하는 것이 중요합니다. 긴장으로 나에게 키 포인트를 놓치게 만들기도 했습니다. 차분하고 침착해지는 것이 중요합니다.\n\n**## 준비하다**\n\n<div class=\"content-ad\"></div>\n\n\nThere were topics I hadn’t studied, and this gap in my preparation affected my performance. Next time, I plan to cover all relevant topics thoroughly to ensure I am well-prepared.\n\n# 공동 경험에 대한 호소\n\n내 독자들의 면접 경험에 대해 듣고 싶어해요. 다른 사람들이 비슷한 어려움을 겪은 것을 알면 매우 동기부여가 될 것 같아요. 댓글에서 여러분의 경험을 공유해주세요. 궁금한 점이 있다면 댓글을 남겨주시면 제가 확실히 답변해드릴게요.\n\n# 마무리 당신을 위해\n\n<div class=\"content-ad\"></div>\n\n저쪽에서는 여기까지입니다! 제안이나 피드백이 있으시면 언제든지 연락해주세요. 특정 주제에 대해 글을 작성해 달라면 댓글에 언급해주세요.\n\nLinkedIn에서 연결해요!\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에 박수를 보내주시고 팔로우도 잊지 말아주세요! 👏","ogImage":{"url":"/assets/img/2024-05-18-FromPanictoPreparedMyInterviewExperience_0.png"},"coverImage":"/assets/img/2024-05-18-FromPanictoPreparedMyInterviewExperience_0.png","tag":["Tech"],"readingTime":3},{"title":"Dart Flutter에서의 믹스인 사용하기","description":"","date":"2024-05-18 22:20","slug":"2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance","content":"\n<img src=\"/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_0.png\" />\n\n안녕하세요!\n\n오늘은 믹스인에 대해 이야기해 보겠습니다. 한 가지 질문이 있는데요.\n\n믹스인이란 무엇인가요? 상속과 어떻게 다른가요? 상속과 어떤 점이 다른지 알고 계시면 섹션 2로 스크롤하셔서 믹스인을 구현하는 방법을 확인해보세요 :) 모르신다면 여기에서 자세히 설명해 드리겠습니다!\n\n<div class=\"content-ad\"></div>\n\n## 섹션 1: 정의부터 시작합시다\n\n맞죠? 대부분 mixins에 대해 검색할 때 가장 많이 볼 내용이죠. 대부분은 제처럼 상속과 혼동할 수도 있어요 :) . 그러니, mixins에 대해 시작하기 전에 is-a 관계(상속)와 has-a 관계(구성)에 대해 알아야 합니다.\n\n그러니 이 개념들에 대해 간단히 명확화해 볼까요? 이 이미지를 살펴보세요\n\n![이미지](/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_1.png)\n\n<div class=\"content-ad\"></div>\n\n무엇을 관찰하셨나요?\n\n첨부된 실시간 예제를 참고하면 다음과 같이 관찰할 수 있습니다.\n\n- 삼성은 모바일이에요.\n- 삼성은 카메라를 가지고 있고 블루투스도 가지고 있어요.\n\n자세한 통찰력을 얻기 위해 다음 정의를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\nis-a 관계: 두 클래스 간의 직접적인 관계로 정의될 수 있으며, 한 클래스(예: Class B)가 다른 클래스(예: Class A)의 하위 클래스인 경우입니다. 이를 상속이라고 합니다.\n\n---\n\nhas-a 관계: 한 클래스(예: Class A)가 다른 클래스(예: Class B)의 인스턴스를 멤버로 포함하는 관계로 정의될 수 있습니다. 이 관계를 통해 Class A가 Class B의 기능과 속성에 액세스할 수 있도록 해주므니다. 이런 관계를 합성이라고 합니다.\n\n마지막으로 이것이 프로그래밍적으로 어떻게 보이는지 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n_주의: 코멘트에 집중해주세요._\n\n```js\n// 부모 클래스\nclass Mobile {\n}\n\n// 하위 클래스 또는 자식 클래스\n// 삼성이 Mobile을 확장한 is-a 관계의 예시\nclass Samsung extends Mobile {\n\n// has-a 관계의 예시\n Wifi wifi = Wifi();\n Camera camera = Camera();\n}\n```\n\n이제 is-a 및 has-a 관계에 대해 분명히 이해하셨기를 바랍니다.\n\n이제 이미 mixin의 정의를 읽으셨다면, 다시 한번 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n믹신을 사용하는 클래스들은 모든 속성과 기능을 상속받지만 서브클래스로 지칭할 수는 없어요.\n\n그 이유는 뭘까요???\n\n믹신은 클래스와 믹신이 제공하는 기능 사이에 \"has-a\" 관계와 비슷하지만 정확히는 그렇지 않은 관계를 설정합니다. 이는 믹신에 정의된 메서드와 속성에 접근할 수 있게 합니다.\n\n하지만, 차이점은 클래스 자체가 믹신의 인스턴스를 보유하지 않고 그냥 상속한다는 것입니다. 엄격한 계층 구조는 엄격한 부모-자식 관계의 계층 구조와 결합되어 있지 않으므로 그렇죠.\n\n<div class=\"content-ad\"></div>\n\n이 유연성을 통해 클래스들은 믹스인이 제공하는 기능을 직접적인 \"is-a relationship\" 없이 활용할 수 있습니다.\n\n이해했어요? 그렇지 않다면, 기다려 주세요 — Section 2에서 자세히 설명하겠습니다. 금방 이해하실 거예요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:996/1*ETWMK2xQnq54XonmQMumIw.gif)\n\n## Section 2 : 믹스인 구현\n\n<div class=\"content-ad\"></div>\n\n이제 Dart와 Flutter에서 이들을 어떻게 구현할 수 있는지 살펴봐요.\n\n1. 믹신 선언: 믹신은 믹신 키워드를 사용하여 선언하며 믹신의 이름이 뒤따릅니다. 믹신에는 메서드와 프로퍼티가 포함될 수 있어요.\n\n```js\nmixin MixinLogger {\n\n void logMessage(String message) {\n   print(\"MESSAGE: $message\");\n }\n\n}\n```\n\n2. 믹신 사용: 클래스에서 믹신을 사용하려면 믹신의 이름이 따르는 with 키워드를 사용해요. 이를 통해 클래스는 믹신에서 정의된 기능을 상속받을 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass APIService with MixinLogger {\n\n  void getPosts() {\n    try {\n      final response = http.get('https://www.example.com/posts');\n     } catch (Exception e) {\n        // mixin 메소드 호출\n        logMessage(e.toString());\n     }\n    }\n\n  }\n```\n\n이제!\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*i7xIxer3Ijfhk9r7xR_USg.gif)\n\n```js\nvoid main(){\n  APIService apiService = APIService();\n\n  if(apiService.runtimeType is MixinLogger){\n    print(\"APIService는 MixinLogger 타입입니다.\");\n  }\n  else{\n    print(\"APIService는 MixinLogger 타입이 아닙니다.\");\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n무엇이 출력될까요?\n\n1 섹션을 모르거나 건너뛴 경우, 다시 살펴보세요.\n\n그래서 결과는 \"APIService is not off type MixinLogger\"가 될 것입니다.\n\n왜 그럴까요???? 같은 답변이지만 이번에는 이해하리라고 기대합니다.\n\n<div class=\"content-ad\"></div>\n\n믹신은 클래스와 믹신이 제공하는 기능 사이에 \"has-a\" 관계와 유사하지만 정확히 동일하지는 않는 관계를 수립합니다. 이를 통해 믹신에서 정의된 메서드와 속성에 액세스할 수 있습니다.\n\n그러나 차이점은 클래스 자체가 믹신의 인스턴스를 보유하지 않고 단순히 상속한다는 것입니다. 엄격한 계층 구조는 없습니다. 따라서 부모-자식 관계의 엄격한 계층 구조에 제한받지 않습니다.\n\n이 유연성을 통해 클래스는 믹신과 직접적인 \"is-a 관계\"를 형성하지 않고도 믹신이 제공하는 기능을 활용할 수 있습니다.\n\n이제 더 많은 기능을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*j5nDu39KHxe3669LfJKieg.gif)\n\n## 3. mixin에 있는 기능:\n\nmixin에서의 on 키워드:\n\n원하는 클래스의 하위 클래스에서만 사용되도록 mixin을 제한하려면 mixin 클래스를 on 키워드와 함께 선언해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식에 맞게 표 태그를 변경해주세요.\n\nmixin `mixinname` on `class_name_on_which_mixin_should_restricted`\n\n_주의: 주석에 집중_\n\n```js\nmixin MixinDiscount on Product{\n\n  performDiscountOperation(double price,double discount){\n     // perform discount operations\n    }\n\n}\n\n\nclass Product{\n\n}\n```\n\n여기서 Discount mixin은 제한되어서 Product 클래스 Type의 하위 클래스와 함께만 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 컴파일 시간에 오류가 발생하여 텔레비전이 Product를 구현해야 함을 지정\nclass Television with MixinDiscount {\n\n}\n```\n\n```js\n// 규칙을 준수하므로 작동합니다.\nclass Television extends Product with MixinDiscount {\n\n  void doSomeOperation() {\n    // 이제 메서드를 직접 호출할 수 있습니다\n    performDiscountOperation(1000, 10);\n  }\n\n}\n```\n\n여러 mixin 상속:\n\n하나의 함수를 포함하는 MixinA 및 MixinB를 선언해봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nmixin MixinA{\n\n  void functionA(){\n    print(\"function A\");\n   }\n\n}\n\nmixin MixinB{\n\n  void functionB(){\n    print(\"function B\");\n  }\n\n}\n```\n\n```js\nclass Consumer with MixinA, MixinB{\n\n}\n\nvoid main(){\n  final consumer = Consumer();\n  //Now consumer can be able to use both functions from mixin A and B\n  consumer.functionA();\n  consumer.functionB();\n}\n```\n\n만약 여러 가지믹신이 동일한 함수 시그니처를 갖는다면?\n\nDart가 대비할 준비가 되어 있습니다 :)\n\n<div class=\"content-ad\"></div>\n\n```js\nmixin MixinA {\n  void foo() {\n    print('A.foo');\n  }\n}\n\nmixin MixinB {\n  void foo() {\n    print('B.foo');\n  }\n}\n```\n\n이제 믹신 A와 B를 사용하는 클래스 C를 정의해 봅시다:\n\n```js\nclass ClassC with MixinA, MixinB {\n  // 클래스 구현...\n}\n\nvoid main() {\n  final c = ClassC();\n  c.foo(); // 결과: B.foo\n}\n```\n\n이 상황에서 클래스 C는 믹신 A와 B에서 foo() 메서드를 모두 얻게 됩니다. 하지만 충돌이 있기 때문에 Dart는 어떤 것을 사용할지 결정해야 합니다. Dart는 마지막으로 사용된 믹신인 B의 foo() 메서드를 선택합니다. 따라서 클래스 C의 인스턴스를 만들고 foo()를 호출하면 mixin B의 함수가 호출됩니다.\n\n<div class=\"content-ad\"></div>\n\n여러 상속을 지원하는 프로그래밍 언어는 다이아몬드 문제로 알려진 이러한 시나리오에 대한 복잡성을 가지고 있습니다. 그런데 Dart에는 쉽죠? :)\n\n지금까지입니다.\n\n읽어 주셔서 감사합니다 !!!\n\n![image](https://miro.medium.com/v2/resize:fit:1280/1*R6bQiuW46ycpDFAI2tSUcw.gif)\n\n<div class=\"content-ad\"></div>\n\n내 첫 블로그 포스팅이에요! 도움이 되었으면 좋겣아요 :)\n\n이브라힘 사이드.\n","ogImage":{"url":"/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_0.png"},"coverImage":"/assets/img/2024-05-18-MixinsinDartFlutterAndHowitisdifferentfromInheritance_0.png","tag":["Tech"],"readingTime":6},{"title":"플러터 데스크톱에서 러스트 없이는 살아남을 수 없는 이유","description":"","date":"2024-05-18 22:18","slug":"2024-05-18-WhyFlutterontheDesktopCantSurviveWithoutRust","content":"\n\n\n![image](/assets/img/2024-05-18-WhyFlutterontheDesktopCantSurviveWithoutRust_0.png)\n\nWriter's note: 이 기사에서는 Tim Sneath와 많은 노력을 기울인 다른 참여자들의 노력으로 만들어진 Win32 패키지에 대해 이야기합니다. Win32 패키지는 고품질이며 Tim은 Flutter 생태계에 큰 기여자입니다. 제가 언급한 내용은 이 패키지를 비하하려는 것이 아니라 제 경험 상으로 잘 작동하는 대안에 대해 논의한 것입니다.\n\n현재 Flutter on Desktop은 애매한 상황에 있습니다. 주요 데스크톱 플랫폼(Windows, macOS, Linux 등)에서 안정적이며, 일부 채택도 이루어지고 있습니다. 이는 휴대용 앱 개발에 대한 인기가 높지만 데스크톱 앱으로의 확장은 아직 그리 인기가 없는 것 같습니다.\n\n데스크톱 플랫폼의 안정성이 이동 플랫폼에 비해 훨씬 더 새로운 것은 사실이지만, 데스크톱에서 Flutter가 이동 플랫폼과 비교했을 때 덜 개선된 다른 중요한 영역이 있습니다. 이것은 확장성과 관련이 있으며, 더 구체적으로는 Flutter가 기본 운영 체제에서 네이티브 코드를 호출하는 것이 얼마나 어려운지에 관한 것입니다. Android 또는 iOS에서는 원하는 대로 작동할 Kotlin 또는 Swift를 조합하는 것이 그리 어렵지 않습니다. 그러나 데스크톱에서는 전혀 다른 이야기입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\"Flutter on Desktop\"은 Windows, Linux, 그리고 macOS를 포함한 매우 넓은 용어입니다. 이 기사에서는 Windows에만 초점을 맞출 것입니다. Windows가 데스크톱 시장을 주도하고 있는 만큼, 그것은 공정한 선택이라고 생각합니다.\n\n제 경우에는 'StagePlay'라는 데스크톱 앱을 개발 중이었습니다. 이 앱은 스마트 자전거와 연결되어 사용자에게 현재 기어가 무엇인지 알려줍니다. 이것이 작동하려면 스마트 자전거와 통신하기 위해 Bluetooth Low Energy(BLE)를 사용해야 합니다.\n\n데스크톱에서 BLE를 지원하는 것은 완전히 불가능한 것은 아니지만, 제 경우에는 기존 플러그인이 제대로 작동하지 않았습니다(앱이 데스크톱으로 충돌할 수도 있었습니다). 그래서 저는 이를 위한 내 자체 구현을 작성해야 했습니다.\n\n# 처음에 Flutter로 데스크톱 앱을 작성한 이유\n\n<div class=\"content-ad\"></div>\n\n만약 플러터의 데스크톱 지원이 평균 수준이라면, 왜 내 앱을 플러터로 작성했을까요? 그건 좀 자기 반박 같네요. 그렇다고요. 한동안 모바일 앱에 플러터를 사용했고, 간단히 말해서 플러터가 사용하는 레이아웃 시스템이 제가 본 것 중에서 가장 좋다고 생각했기 때문입니다. 이전에는 Windows WPF 앱이나 Xamarin Forms 앱의 레이아웃을 만들기 위해 XAML을 사용하려 했었습니다. 그러나 플러터의 레이아웃 시스템은 XAML을 넘어서는 수준이었습니다. 거의 비교할 수 없어요.\n\n그래서 결과적으로, 제가 플러터의 팬이 되어버려서 WPF/Xamarin Forms/MAUI에서 앱을 작성하기 위해 다시 XAML로 돌아가는 생각만으로도 우울해졌어요. 그래서 프레임워크 선택이 플러터가 될 것이라면, 내 Bluetooth 요구사항을 충족시키기 위해 더 어려운 길을 선택해야 했습니다.\n\n즉, 내가 선택한 BLE 장치에 연결하기 위한 네이티브 플랫폼 기능을 활용하는 방법을 찾아야 했습니다. 그리고 그에는 win32 패키지, 네이티브 C++ 플러그인 또는 Rust (flutter_rust_bridge를 사용해서) 세 가지 옵션이 있었습니다. 이 여정을 시작할 때는 세 번째 옵션 (또는 Rust 언어 자체에 대해 훨씬 더 잘 알지 못했습니다.\n\n# Win32 패키지 사용\n\n<div class=\"content-ad\"></div>\n\n평범한 크로스 플랫폼 개발자의 어려움은, 그들이 사용하는 크로스 플랫폼 프레임워크에서 사용하는 언어에 능숙하지만, 특정 플랫폼 언어에는 그렇게 능숙하지 않다는 것입니다. 제 경우에는 Dart, C# 및 아마도 TypeScript에 능숙하지만, C++과 같은 저수준 언어에는 능숙하지 않습니다. 당연히, 이것은 제가 Dart를 사용하려고 했던 이유였습니다. 이를 위해 Win32 패키지를 사용하는 것이 좋은 선택처럼 보였습니다.\n\n![Image](/assets/img/2024-05-18-WhyFlutterontheDesktopCantSurviveWithoutRust_1.png)\n\n이는 시작하기에 좋을 것처럼 보였고, 여기에서 Bluetooth를 사용하는 방법에 대한 샘플도 있었습니다. 그러나 win32 패키지를 사용하는 것은 두 가지 주요 문제점이 있었습니다.\n\n- BLE 장치에서 알림을 구독할 수 없었습니다. 이것이 사실상 Bluetooth를 이용해 하고 싶었던 유일한 작업이었습니다.\n- Win32 API를 활용하기 위해 상당히 어려운 Dart 코드를 작성해야만 했습니다.\n\n<div class=\"content-ad\"></div>\n\n\"‘Pretty difficult Dart code’라는 말의 의미는 무엇일까요? Win32 패키지를 사용해도 Dart를 사용할 수 있지만, 여전히 calloc(또는 C Allocate)과 같은 함수들을 호출하여 함수의 반환 값에 대한 메모리를 할당해야 합니다. 또한 더 이상 사용되지 않을 때 개체를 수동으로 삭제하여 직접 메모리 관리와 정리를 처리해야 합니다.\n\n위의 일들 외에도, Win32 패키지는 Win32 API 표면을 매핑하는 데 우수하지만, WinRT API 표면을 매핑하는 데는 덜 능합니다. WinRT API 표면은 BLE 기능과 같은 새로운 기술이 주로 포함되어 있는 곳이므로 이것은 출발할 수 없는 상황이었습니다.\n\n그래서 Win32 패키지는 버리고, 생각나는 유일한 대안은 네이티브 C++ 플러그인을 작성하는 것이었습니다.\n\n# C++에서 나만의 네이티브 플러그인 작성하기\"\n\n<div class=\"content-ad\"></div>\n\n내가 C++로 나만의 플러그인을 작성하려고 시도하기까지는 꽤 좋은 개발자라고 느끼고 있었어요. 소프트웨어 개발에 대해 충분히 알아서 앱을 디자인하고 만들 수 있는 실력을 가지고 있었죠 — API, 데이터베이스, 앱 등에 대해 알고 있었거든요.\n\nC++에서 가치 있는 것을 만들어보려고 앉아보니, 나에 대한 높은 평가는 완전히 무너졌어요. 보통 소프트웨어 개발 세계에서는 거물같은 사람들 사이에 유년기를 보낸 어린이 정도로 여겨졌어요. 포인터가 무엇인지, 그리고 그 앰퍼샌드가 무엇을 하는 건지 전혀 모르는 상태였죠.\n\n더욱이, C++로 작성된 좋은 플랫폼 간 BLE 플러그인을 찾았는데요. 내 플러터 앱에서 이 라이브러리로부터 명령어와 응답을 매핑해서 내 앱으로 다시 가져오기만 하면 됐어요. 그런데 전 대실패했죠.\n\n만약 C++을 알고 잘 다룰 줄 아는 사람이라면서 \"와, 이 사람은 정말 소프트웨어 개발을 못하는 것 같아\" 라고 생각하실지라도, 괜찮아요. 하지만 난 다소 많은 웹 개발, 데이터베이스 개발, 마지막으로 앱 개발에 대한 지식을 유지해야만 해요. 정말 그렇게 많은데요. 그리고 나는 내 앱에 안전하게 C++을 사용하는 법을 배우는 것이 정말 큰 요구사항이라고 생각해요.\n\n<div class=\"content-ad\"></div>\n\n피지온을 사용하여 바인딩 코드를 생성하려고 시도하거나 자체 플랫폼 바인딩 코드를 작성하려고 시도하는 중간에, 나는 포기하기 시작했습니다. 이루고자 하는 목표에 대해 배워야 할 것이 너무 많은 것 같았습니다. 게다가, C++에서 잘 작동하는 것처럼 보이는 것을 어떻게든 해낸다 해도, 메모리 손상이나 기타 문제가 클라이언트의 기기에서 발생하지 않을지 확신하지 못한 채로 그것을 배포하는 것은 책임이 부족한 일이었습니다.\n\n# 프로젝트를 일시 중단하기로 결정\n\n프로젝트에서 BLE를 활용할 수 있는 신뢰할 만한 방법이 없다면, 프로젝트를 계속할 수 없었습니다. BLE 연결이 불안정한 경우 BLE 기기에 연결하는 앱을 출시할 수 없으며, 앱이 가끔한 데스크톱 충돌로 인해 종료되는 경우 더욱 그렇습니다. 또 다른 방법이 있는지 알아보기 위해 노력했고, 그 과정에서 플러터 러스트 브릿지 프로젝트를 발견했습니다.\n\n![이미지](/assets/img/2024-05-18-WhyFlutterontheDesktopCantSurviveWithoutRust_2.png)\n\n<div class=\"content-ad\"></div>\n\n# Flutter Rust Bridge 사용하기\n\n지금 이 단계에서 나의 러스트에 대한 현재 인식은 다음과 같았습니다:\n\n- 그것은 프로그래밍 언어였다.\n- 그들의 매스코트는 게였다.\n\n이전에 사용해보지 않았던 새로운 언어로 복잡한 작업을 수행하는 것은 분명히 무서운 일이며, 성공할 수도 없는 것을 보장할 수도 없습니다. 몇 일 내에 허무하게 실패할 것으로 기대했습니다.\n\n<div class=\"content-ad\"></div>\n\n그 대신, 며칠 후에, 나는 Bluetooth 구현을 완료했고 모든 것이 원활하게 작동했습니다.\n\n내 경험이 정말 좋았기 때문에, 지금은 러스트가 플러터 데스크톱에서 성공을 거둘 수 있는 중요한 결핵 부분이라고 믿습니다. 이유는 여기에 있습니다:\n\n## C++보다 쉽고 win32 패키지보다 더 나은 선택\n\nWindows에서의 네이티브 기능에 대한 다른 대안들은 플러터 러스트 브릿지 사용과 비교했을 때 부족합니다. 이렇게 말하는 이유가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 만약 크로스 플랫폼 개발자라면, 아마도 C++에 대해 잘 알지 못할 것입니다. C++과 같이 어려운 언어를 사용해서 네이티브 기능을 구현하려고 한다면 거의 확실히 눈물로 끝나게 될 것입니다.\n- 또한 C++에서 잡히지 않는 예외는 앱을 그냥 다운시킵니다. C++에 새로운 당신이기 때문에(1번 참조), 처리되지 않은 예외가 많이 발생할 것입니다.\n- Win32 패키지를 통해 작업을 구현하려면 대부분의 함수 호출에 대한 API 문서를 읽어야 합니다. 이 자체만으로는 나쁘지 않지만, C++에서 예제를 읽고 Dart로 다시 써 보려는 노력은 calloc 및 destroy와 같은 기본 구조를 호출하는 것을 잊지 않으면서 많은 행복한 결과를 가져다주지 않습니다.\n\nRust 및 flutter_rust_bridge를 사용하면 이러한 문제(1번 및 2번)를 해결하거나(3번) 더 관리하기 쉽게 만들 수 있습니다. 예를 들어 Microsoft API 문서에서 찾을 수 있는 C++ 코드 샘플을 Rust로 다시 쓰는 것은 Dart로 win32 패키지를 통해 같은 작업을 수행하는 것보다 쉽습니다.\n\n## Rust 커뮤니티는 매우 크고 친절합니다\n\n프로그래밍 분야는 엘리티즘 문제를 가지고 있습니다. 어떤 개발자들은 그들이 당신보다 더 나은 개발자이거나 더 많은 것을 알고 있기 때문에 간단히 당신을 바보로 대할 수도 있거나 당신을 얕보기도 합니다. 나는 이 문제를 해결하는 데 특별히 많은 것을 할 수 없다는 것을 배웠고, 그냥 커뮤니티의 일반적인 분위기를 파악하고 나서 대부분의 시간을 디스코드에서 질문을 하느냐, 아니면 문서를 조립하고 GitHub 이슈에서 완전히 다른 문제를 가진 이들의 쾌활한 일들에서 다가올 나머지를 소화해보겠느냐를 결정하는 것이 더 쉽습니다.\n\n<div class=\"content-ad\"></div>\n\n내 경험상 러스트 커뮤니티 디스코드에 가입하고 #beginners 채널에서 어리석은 질문을 던져도 정말 즐거운 경험이었어요. 낯선 사람들이 항상 나에게 친절하게 도와줬어요, 매번 간단한 질문이라도요. 내가 이해를 보이고 말해준 내용을 논리적으로 이해하고 적용하면 필요한 모든 정보를 받을 수 있었어요.\n\n거기서 끝나지 않았어요 - 전엔 글로벌 상태와 데드락을 만드는 대형 코드를 멈추고 더 깔끔하고 우아한 솔루션을 작성할 수 있는 방법에 대한 유용한 제안도 받았어요. 지금 내가 가지고 있는 것은 이 Discord 채널의 봉사자들의 끈질긴 도움으로 인해 절대적으로 품질이 높아진 것입니다.\n\n## 플러터 러스트 브릿지 사용은 꿈 같아요\n\nWindows에서 플러터용 네이티브 C++ 플러그인을 작성 중이라면, 자신만의 바인딩을 작성해야 하거나 Pigeon 패키지 내에서 실험적인 플랫폼 지원에 의존해야 합니다. 그래도 Pigeon은 Stream을 생성하지 않기 때문에 직접 구현해야 해요. 직접 많은 보일러플레이트 코드를 작성해야 하며 문서가 전혀 없어서 실수할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\nflutter_rust_bridge를 사용하는 것은 매우 간단합니다. 이 기능들은 다양하지만, 몇 가지 제가 가장 좋아하는 요소를 강조해보겠습니다:\n\n- Rust 내에서의 함수는 자동으로 호출 가능한 함수로 매핑됩니다. Rust에서 새로운 pub async fn을 정의하고 flutter_rust_bridge의 코드 생성 도구를 실행하면, 즉시 네이티브 코드를 호출할 수 있습니다.\n- `StreamSink<T>`은 기본적으로 지원되므로 값을 시간에 따라 내보낼 수 있습니다. 이러한 스트림에 작성된 값을 Dart 객체로 직접 내보내므로 필요에 따라 조작할 수 있습니다.\n- Rust가 \"패닉\" 상태에 돌입해도 응용 프로그램이 데스크톱에 충돌하지 않습니다. 대신 flutter_rust_bridge 내부에서 발생한 패닉을 catch하여 무슨 일이 발생했는지 설명합니다.\n- Rust 내의 \"펜시한 열거형(Fancy enums)\"을 지원합니다. 예를 들어:\n\n다음은 rust 코드입니다...\n\n```js\npub enum TransportType{\n    Car{\n        capacity: u8,\n    },\n    Bike{\n        wheelCount: u8,\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n...Dart에서는 작동하지 않을 것입니다. 그것은 Dart 내에서 enum이 작동하는 방식이 아니며, 가까운 미래에도 바뀌지 않을 것입니다. 그래도 스트림에 대해서는 어떤 지루한 enum에도 특정 세부사항을 숨겨 놓을 수 있다는 것이 정말 멋진 점입니다.\n\nflutter_rust_bridge는 이러한 값을 매우 사용하기 쉬운 형식으로 변환하여 직관적이고 매우 합리적으로 만들어줍니다. 이를 다음과 같이 처리할 수 있습니다:\n\n```js\napi.transportTypeStream().listen((event) {\n  event.when(car: (capacity) {\n    print('the car has {capacity} capacity');\n  }, bike: (wheelCount) {\n    print('the bike has {wheelCount} wheels');\n  });\n});\n```\n\n그리고 모든 연결된 코드는 flutter_rust_bridge에 의해 자동으로 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n여러분에게, 만약 여러분이 개발자이고 Windows용 Flutter 앱을 작성 중이라면, 진지하게 Rust를 조금 배우고 flutter_rust_bridge를 사용하여 원하는 것을 달성하는 데 도움을 받는 것을 고려해 보세요. 사실, 이렇게 하면 여러분에게 이익이 되고 앱을 더 빨리 제공할 수 있게 될 것입니다.\n\n그러나 보다 넓은 관점에서 바라볼 때, Rust와 flutter_rust_bridge 없이 나의 앱이 데스크톱에서 성공적으로 실행되거나 실제로 작동할 수 있다고 상상하기 힘들어요. 저는 Flutter를 사용하여 데스크톱용 앱을 만들기로 결정한 사람들이 win32 패키지 사용이 제약적이고 이해하기 어렵다고 느끼게 될 것이라고 생각합니다. 또한, 그 같은 사람들은 원하는 기능에 대해 자체적으로 고품질의 네이티브 구현을 개발할 충분한 C++ 경험이 부족할 것입니다. 이 시점에서 그들은 목표를 달성하기 위해 다른 프레임워크를 사용할 가능성(또는 확률)이 높을 것입니다.\n\n따라서 (Flutter 내에서 컴파일된 .NET 코드를 로드하고 실행할 수 있는 등의 막대한 일이 발생하지 않는 한), 데스크톱에서의 Flutter 성공은 Rust와 flutter_rust_bridge와 강하게 연결되어 있는 것으로 보입니다. 제가 본인 경험에서 이 프로젝트가 어디로 나아갈지를 기대하고 있습니다. 이를 아직 들어보지 못했다면 확인해보시기 바랍니다. 이 프로젝트가 여러분의 프로젝트를 내가 한 것처럼 구해줄 수도 있으니 말이에요.","ogImage":{"url":"/assets/img/2024-05-18-WhyFlutterontheDesktopCantSurviveWithoutRust_0.png"},"coverImage":"/assets/img/2024-05-18-WhyFlutterontheDesktopCantSurviveWithoutRust_0.png","tag":["Tech"],"readingTime":9},{"title":"Flutter 322와 함께 사용할 수 있는 5가지 추가 패키지(2024년 최신)","description":"","date":"2024-05-18 22:17","slug":"2024-05-18-5extrapackagestousewithFlutter322in2024","content":"\n흥미로운 뉴스! 구글 I/O 2024에서 Flutter 3.22이 발표되었고, 물론 이전에 제가 즐겨 사용하는 Flutter 앱 개발용 패키지에 관한 기사를 사랑해주셔서 감사합니다. 많은 앱에서 사용하는 추가 기능 몇 가지를 공유하기로 결정했습니다. 오늘은 코드를 깔끔하고 조직적으로 유지할 뿐만 아니라 훌륭한 앱을 만드는 데 도움이 되는 5가지 Flutter 패키지를 소개하려고 합니다.\n\n- gap\n\nUI에 여백을 추가해야 하는 경우가 많은데, Row나 Column에서 Padding이나 SizedBox를 사용할 수 있습니다. 그러나 이 두 옵션은 제 취향에 조금 번잡스럽습니다. 이런 문제를 해결하기 위해 Gap이 나왔습니다. Gap은 SizedBox처럼 보이지만 보다 깔끔하며 Scrollable 내에서 작동하며 Column이나 Row에서 사용 가능한 MaxGap을 제공합니다.\n\n사용하기도 매우 쉽습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nColumn(\n  children: [\n    Container(color: Colors.red, height: 20),\n    const Gap(20), // 20픽셀의 빈 공간 추가\n    Container(color: Colors.red, height: 20),\n  ],\n);\n```\n\n이전에 언급했듯이 코드를 깔끔하고 체계적으로 유지하는 걸 좋아합니다. 일반적으로 앱의 스타일에 사용될 Gaps를 모두 포함하는 styles.dart 파일을 만들어 그 안에 Gaps를 추가하곤 합니다. 예:\n\n```js\nconst kGap0 = Gap(0);\nconst kGap5 = Gap(5);\nconst kGap8 = Gap(8);\nconst kGap10 = Gap(10);\nconst kGap15 = Gap(15);\nconst kGap20 = Gap(20);\nconst kGap25 = Gap(25);\nconst kGap30 = Gap(30);\nconst kGap35 = Gap(35);\nconst kGap40 = Gap(40);\nconst kGap50 = Gap(50);\nconst kGap60 = Gap(60);\nconst kGap100 = Gap(100);\n```\n\n이렇게 하면 UI 사양이 변경되면 앱 내의 공간을 빠르게 재정비할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 패키지를 확인할 수 있어요.\n\n2. Skeletonizer\n\n![](/assets/img/2024-05-18-5extrapackagestousewithFlutter322in2024_0.png)\n\n모두가 딱딱한 로딩 화면을 싫어하거나 더 나쁜 경우에는 아예 없을 때가 있죠. 사용자로서 무슨 일이 일어나고 있는지 전혀 모를 때. 데이터가 로딩 중인가요? 앱이 다운되었나요? 무슨 일이 벌어지고 있는 건가요? 저는 앱에 스켈레톤 로더를 추가하고 사용자 경험을 향상시키기 위해 스켈레터나이저를 사용해요. 스켈레톤 UI는 데이터가 이미 로딩된 것처럼 보이는 간단한 플레이스홀더 UI를 제공해요. 많은 유명한 앱이 이 기술을 사용하고 사용자들이 익숙해졌어요. 또한 앱에 쉽게 추가할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:776/0*SxYiRxewtRIFNa4e.gif)\n\nYou can check the package [here](link).\n\n\\*A simpler but now old alternative named Skeletons can be found here. This is an honorable mention as it was the first I used and still exists in at least 8 of my apps.\n\n3. toastification\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-18-5extrapackagestousewithFlutter322in2024_1.png)\n\n아름다운 UI와 사용자 경험에 대해 이야기할 때, 내가 개인적으로 가장 좋아하는 토스트 알림 패키지를 이 목록에서 빠뜨릴 수 없었어요. 이 사용하기 쉽고 매우 사용자 정의할 수 있는 패키지를 만나기 전까지 제가 사용했던 \"토스트 알림\" 구현을 사용해 왔어요. 주로 앱에서 무언가 발생한 사실을 사용자에게 알리기 위해 토스트를 사용했었어요. 예를 들면 \"게시물이 승인을 기다리고 있습니다\" 또는 \"앗, 문제가 발생했습니다\" 등이 있어요.\n\n해당 패키지는 여기에서 확인할 수 있어요.\n\n4. linkfy_text\n\n<div class=\"content-ad\"></div>\n\n이 패키지는 소형이고 간단하지만 다양한 애플리케이션에서 매우 유용함을 입증했습니다. 이는 URL, 이메일 주소, 해시태그 등과 같은 패턴을 감지하여 일반 텍스트를 클릭 가능한 요소로 변환합니다. 이 패키지를 자주 활용하여 다음과 같은 애플리케이션에서 사용합니다:\n\n- 푸시 알림: 알림 텍스트 내의 링크가 클릭 가능하도록 보장합니다.\n- 앱 내 정보 화면: 잠재적인 링크를 상호작용 가능한 요소로 변환하여 사용자 경험을 향상시킵니다.\n- 사용자 게시물: 특히 소셜 앱에서 멘션과 해시태그를 상호작용 가능하게 만들어 사용자 참여와 탐색을 용이하게 합니다.\n\n이 패키지를 사용하는 것은 간단합니다. Text() 위젯을 LinkifyText()로 교체하기만 하면 되어, 앱 텍스트 콘텐츠에 쉽게 상호작용성을 추가할 수 있습니다.\n\n이 패키지를 통합하면 최소한의 노력으로 앱의 기능성과 사용자 경험을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n여기에서 패키지를 확인할 수 있어요.\n\n5. flutter_native_splash\n\n마지막으로 여러분의 앱에 대한 네이티브 스플래시 화면을 만들어주는 패키지입니다. 다른 방법들이 있을 수 있지만, 패키지를 사용하지 않고 네이티브 방법에 따라 따르는 것도 가능하다는 것 알지만, 뭐라고 말할 수 있을까요, 나는 게을러... 이 패키지는 매우 사용자 정의 가능하며 Android 및 iOS에 필요한 어떤 종류의 스플래시 화면도 만들 수 있습니다. 더불어 앱 초기화가 원활하게 진행되도록 스플래시 화면을 유지할 수도 있습니다.\n\n여기에서 패키지를 확인할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n저의 이전 게시물 두 번째 부분을 마무리합니다. Flutter 앱을 개발할 때 가장 좋아하고 가장 많이 사용하는 패키지에 대해 이야기했습니다. Flutter 3.22 버전이 나오면서 더 많은 흥미로운 새로운 패키지들이 나올 것으로 기대됩니다. 함께 더 나은 앱을 만들 수 있는 도움이 되리라 믿어요!\n","ogImage":{"url":"/assets/img/2024-05-18-5extrapackagestousewithFlutter322in2024_0.png"},"coverImage":"/assets/img/2024-05-18-5extrapackagestousewithFlutter322in2024_0.png","tag":["Tech"],"readingTime":4}],"page":"68","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}