{"pageProps":{"posts":[{"title":"CSS 기초 문법 정리","description":"","date":"2024-05-02 00:01","slug":"2024-05-02-IntroductiontoCSSSyntax","content":"\n\n![CSS Syntax](/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png)\n\nCSS를 사용하는 규칙의 두 부분은 선언 블록과 선택자입니다.\n\n## CSS 구문:\n\n![CSS Syntax](/assets/img/2024-05-02-IntroductiontoCSSSyntax_1.png)\n\n<div class=\"content-ad\"></div>\n\n선택기는 스타일을 지정하려는 HTML 요소를 가리킵니다.\n\n각 선언은 콜론으로 구분된 CSS 속성 이름과 값으로 구성됩니다.\n\n# 예제:\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n<style>\np {\n  color: red;\n  text-align: center;\n} \n</style>\n</head>\n<body>\n\n<p>Hello World!</p>\n<p>These paragraphs are styled with CSS.</p>\n\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n## 예시 설명:\n\n- CSS에서 P는 셀렉터입니다 (스타일을 적용할 HTML 요소를 가리킵니다: `p`).\n- Red는 속성(property)의 값인 색상입니다.\n- 속성의 값은 'center'이고, 사용된 속성은 text-align입니다.\n\n![이미지](/assets/img/2024-05-02-IntroductiontoCSSSyntax_2.png)\n\n# 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png"},"coverImage":"/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png","tag":["Tech"],"readingTime":1},{"title":"Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기","description":"","date":"2024-05-02 00:00","slug":"2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers","content":"\n\nNode.js 개발 세계에서는 오류를 세련되게 처리하는 것이 탄력적이고 유지보수가 간편한 애플리케이션을 구축하는 데 중요합니다. Node.js에서 오류를 관리하는 효과적인 방법 중 하나는 전역 오류 이벤트 핸들러를 사용하는 것입니다. 이 블로그 포스트에서는 Node.js 애플리케이션에서 전역 오류 처리를 구현하는 방법을 살펴보겠습니다. 이를 통해 전체 코드 베이스에서 일관된 오류 관리를 보장할 수 있습니다.\n\nNode.js의 오류 이벤트 이해\n\nNode.js는 처리되지 않은 프라미스 rejections, 처리되지 않은 예외, 및 프로세스 경고 등 다양한 유형의 오류가 발생할 때 오류 이벤트를 발생시킵니다. 이러한 이벤트를 청취함으로써 애플리케이션의 어디에서 발생하든간에 일관되게 오류를 포착하고 처리할 수 있습니다.\n\n전역 오류 이벤트 핸들러 구현하기\n\n<div class=\"content-ad\"></div>\n\nNode.js에서 전역 오류 이벤트 핸들러를 만들려면 process 객체를 사용하여 다음과 같은 오류 이벤트를 수신할 수 있습니다:\n\n- uncaughtException — Node.js 프로세스 내에서 예외가 발생할 때 발생하는 이벤트입니다.\n- unhandledRejection — Node.js 프로세스 내에서 처리되지 않은 프로미스 거부가 발생했을 때 발생하는 이벤트입니다.\n- warning — Node.js 프로세스에서 경고가 발생할 때 발생하는 이벤트입니다.\n\n다음은 이러한 이벤트를 수신하고 오류를 기록하는 전역 오류 이벤트 핸들러의 간단한 예시입니다:\n\n```js\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n  // 옵션: 추가적인 오류 처리 수행, 예를 들어 오류 보고서를 전송하거나 프로세스를 종료합니다.\n});\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nprocess.on('unhandledRejection', (error) => {\n  console.error('Unhandled Rejection:', error);\n  // 선택 사항: 추가 에러 처리 수행, 예를 들어 에러 보고서 전송 또는 프로세스 종료.\n});\nprocess.on('warning', (warning) => {\n  console.warn('Warning:', warning);\n  // 선택 사항: 추가 에러 처리 수행, 예를 들어 경고 보고서 전송 또는 경고 로깅.\n});\n```\n\n에러 처리 사용자 정의\n\n전역 에러 이벤트 핸들러를 설정한 후에는 애플리케이션이 에러에 응답하는 방식을 사용자 정의할 수 있습니다. 가능한 조치에는 다음이 포함됩니다:\n\n- Sentry 또는 Rollbar와 같은 외부 에러 모니터링 서비스로 에러 보고 전송.\n- Winston 또는 Bunyan과 같은 전용 로깅 라이브러리를 사용하여 에러 로깅.\n- 메모리 부족과 같은 심각한 에러의 경우 Node.js 프로세스를 안전하게 종료.\n\n<div class=\"content-ad\"></div>\n\n최상의 방법\n\n올바른 오류 처리를 보장하기 위해 다음 최상의 방법을 따릅니다:\n\n- 코드에서 가능한 한 빨리 오류를 처리하여 전역 오류 처리기에 도달하는 것을 방지합니다.\n- 발생한 문제를 디버깅하는 데 도움이 되는 명확하고 설명적인 오류 메시지를 제공합니다.\n- 오류 모니터링 서비스와 로깅 라이브러리를 사용하여 오류를 추적하고 분석하여 문제에 예방적으로 대응하고 응용 프로그램의 안정성을 향상시킵니다.\n\nNode.js 애플리케이션에 전역 오류 이벤트 처리기를 구현함으로써 전체 코드베이스에서 오류를 효과적으로 관리할 수 있습니다. 이 방법을 통해 일관된 오류 처리 방식을 유지하고 오류에 효율적으로 대응하여 더 견고하고 안정적인 응용 프로그램을 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers_0.png"},"coverImage":"/assets/img/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers_0.png","tag":["Tech"],"readingTime":2},{"title":"웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지","description":"","date":"2024-05-01 23:58","slug":"2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite","content":"\n\nCSS나 PHP를 알지 못해도 멋진 웹사이트를 만들 수 있다면, 이 멋진 HTML 효과 트릭 8가지를 사용하여 멋진 웹사이트를 만들어보세요. 멋진 웹사이트를 구축하고 싶지만 웹 개발에 대한 마스터 스킬이 없다면 걱정하지 마세요! CSS와 PHP를 알 필요가 없다면 이 멋진 HTML 효과 8가지를 선택하세요. 그리고 이 태그들을 HTML에 복사하고 붙이는 방법을 배워보세요.\n\n![8 Cool HTML Effects](/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png)\n\n일부 멋진 HTML 효과를 시작할 수 있도록 무료 코드 템플릿을 모았습니다. 이들은 돈을 지불하지 않고도 기능성과 사용자 경험을 증가시킵니다. HTML에서 이 멋진 코드들은 대부분 CSS와 PHP를 포함하고 있습니다.\n\n# 웹사이트에 추가할 수 있는 8 가지 멋진 HTML 효과\n\n<div class=\"content-ad\"></div>\n\n## 1. 멋진 HTML 패럴랙스 효과\n\n다른 웹사이트에서 온라인 광고로 사용된 패럴랙스 효과를 보셨죠?\n\n이 효과를 즐기고 이 효과를 담은 간단한 패럴랙스 효과 코드를 W3Schools에서 복사해보세요. 이 효과는 HTML, CSS, 그리고 JavaScript가 결합된 것입니다.\n\n## 2. 스크롤 가능한 HTML 댓글 상자 코드\n\n<div class=\"content-ad\"></div>\n\n가로스크롤 가능한 HTML 코멘트 상자 코드는 텍스트를 간결한 형태로 포장하는 데 도움이 되는 간단하지만 유용한 HTML 요소입니다. 그래서 페이지가 전체 공간을 제공하지 않습니다.\n\n만약 상자의 크기와 색상을 원하는 대로 변경하여 맞추고 싶다면 쉽게 변경할 수 있습니다.\n\n입력:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <style>\n    main {\n      padding: 20px;\n      display: block;\n      min-height: 100vh;\n      min-width: 100vh;\n    }\n    h2 {\n      text-align: center;\n      color: #004aad;\n    }\n    .comment-section {\n      max-height: 50vh;\n      max-width: 100%;\n      background-color: #004aad;\n      overflow-y: scroll;\n    }\n    .comment {\n      height: 10%;\n      padding: 2%;\n      margin: 2%;\n      background-color: #ffff;\n      color: black;\n    }\n  </style>\n  <body>\n    <h2>Scrollable HTML Comment Box Code</h2>\n    <main>\n      <div class=\"comment-section\">\n        <div class=\"comment\">This is first comment.</div>\n        <div class=\"comment\">This is second comment.</div>\n        <div class=\"comment\">This is third comment.</div>\n        <div class=\"comment\">This is fourth comment.</div>\n        <div class=\"comment\">This is fifth comment.</div>\n        <div class=\"comment\">This is sixth comment.</div>\n      </div>\n    </main>\n  </body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n만약 무언가 좀 더 멋있게 추가하고 싶다면, Quackit에서 커스터마이즈 가능한 코멘트 상자에 대한 코드를 가져올 수도 있어요.\n\n## 3. 멋진 HTML 요령: 강조 효과\n\n`span` 태그를 사용하면 텍스트나 이미지에 여러 가지 멋진 HTML 효과를 줄 수 있어요. 이 모든 작업은 브라우저에서 처리되기 때문에 Google Chrome, Microsoft Edge 및 Mozilla Firefox에서 작업할 수 있어요. 왜냐하면 이 브라우저들은 미리 정의된 HTML 코드를 가지고 있기 때문이에요.\n\n`span` 태그로 둘러싸인 텍스트는 이 HTML 텍스트 효과에 의해 강조되어요.\n\n<div class=\"content-ad\"></div>\n\nInput:\n\n\n```js\n<span style=\"background-color: #004aad> highlighted text.</span>\n```\n\n## 4. 텍스트에 배경 이미지 추가\n\n텍스트의 배경 이미지를 변경할 수 있습니다. 또한 텍스트의 색상도 변경할 수 있습니다. 자신이 원하는 시각으로 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n입력:\n\n```js\n<span style=\"배경 이미지: url(https://i0.wp.com/www.learnically.com/wp-content/uploads/2023/05/html-strucher.jpg resize=768%2C432&ssl=1);  글꼴 크기: 20pt; \">Learnically가 제공하는...</span>\n```\n\n동일한 효과는 `strong` 태그 내의 텍스트에 스타일 및 글꼴 요소를 추가하여도 동일하게 구현됩니다.\n\n## 5. 제목 툴팁 추가\n\n<div class=\"content-ad\"></div>\n\n툴팁은 텍스트나 이미지 위로 마우스를 올리면 나타납니다. 웹사이트에서 이미지, 링크된 텍스트 또는 데스크톱 앱의 메뉴 항목에서도 볼 수 있어요. 간단한 HTML을 웹페이지에 추가하여 이 HTML 효과를 사용해보세요.\n\n입력:\n\n```js\n<span title=\"이것이 툴팁입니다.\">마우스를 올려보세요!</span>\n``` \n\n## 6. 텍스트 스크롤 또는 떨어지는 효과\n\n<div class=\"content-ad\"></div>\n\n구글에서 \"marquee HTML\"을 검색하면 상단에 검색 결과 수가 계속 스크롤되는 슬라이더가 있습니다. 이 효과는 현재 사용되지 않는 marquee 태그로 만들어집니다. 일부 브라우저에서는 이 효과가 제거되었지만 대부분의 브라우저에서는 여전히 지원합니다.\n\n입력:\n\n```js\n<marquee>I wanna scroll with it</marquee>\n```\n\n\"left\"를 \"right\"로 변경하여 텍스트를 스크롤하도록 스위치 추가하기.\n\n<div class=\"content-ad\"></div>\n\n## 7. 메뉴를 HTML로 변경해보세요\n\n이 코드는 동적으로 사용될 때 HTML이 잘 작동합니다. 그러나 이 스크립트 사용 시, 메뉴를 만들어내는 효과가 매우 훌륭해요.\n\n이 코드는 평범한 HTML 태그보다는 복잡해요. 스타일 시트와 스크립트를 통해 작동하기 때문이죠. 간단하게 Dynamic Drive에서 코드를 복사해 `html` head 섹션에 붙여넣으면 됩니다.\n\n## 8. Tableizer로 HTML 스프레드시트 얻기\n\n<div class=\"content-ad\"></div>\n\n만약 웹 사이트에 스프레드시트를 표시하고 싶다면, Tableizer를 사용해보세요! 데이터를 HTML 테이블로 변환해줍니다. 엑셀, 구글 문서 또는 다른 스프레드시트에서 데이터를 복사하여 tableizer.journalistopia.com의 변환 도구에 붙여넣으세요. 테이블 옵션을 클릭한 후 Tableize It을 클릭하여 HTML 출력을 받아보세요.\n\n이것은 또한 웹사이트의 전체 HTML 코드 중에서 가장 좋은 코드가 될 것입니다. Tableize It!이 모든 어려운 작업을 처리하기 때문이죠.\n\nHTML 코드를 클릭하고 복사하여 웹 사이트에 추가하세요. 필요에 따라 몇 가지 편집 속성을 추가할 수 있습니다.\n\nHTML, CSS 및 JavaScript는 멋진 웹 사이트를 만드는 가장 강력한 옵션입니다. 그러나 단 8가지 멋진 HTML 효과만을 사용하여 기본적이지만 멋진 웹 사이트를 구축할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 더 멋진 HTML 코드 사이트\n\n- HTML Goodies: 멋진 `span` 태그 아이디어를 제공합니다.\n- Dynamic Drive: 놀라운 동적 HTML 스크립트를 소개합니다.\n- Quackit: 멋진 HTML 코드를 제공합니다.\n\n이 8가지 멋진 HTML 효과들을 연습해보세요. 사용하면 사용할수록 익숙해질 거예요.\n\n이 글은 공식적으로 Learnically에 등재되어 있으며, 해당 사이트도 방문해보세요.","ogImage":{"url":"/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png"},"coverImage":"/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png","tag":["Tech"],"readingTime":5},{"title":"프론트엔드 개발자를 위한 필수 치트 8가지","description":"","date":"2024-05-01 23:57","slug":"2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1","content":"\n\n![이미지](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png)\n\n웹 개발자를 위한 궁극적인 자료인 \"웹 개발자를 위한 필수 치트 시트\"에 오신 것을 환영합니다: 에디션 1!\n\n이 대화식 기사에서는 HTML 및 CSS부터 JavaScript 이상의 필수 치트 시트를 살펴볼 것입니다. 이 치트 시트들은 웹 개발의 복잡성을 쉽게 탐색할 수 있도록 도와줄 것입니다.\n\n자, 이제 들어가서 코딩 실력을 향상시켜 보세요!🤍\n\n<div class=\"content-ad\"></div>\n\n- HTML Cheat Sheet\n\n![HTML Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_1.png)\n\nHTML Cheat Sheet는 HTML 요소, 속성 및 구문에 대한 포괄적인 개요를 제공합니다. \"div\" 및 \"p\"와 같은 기본 태그부터 양식 및 표와 같은 더 고급 개념까지, 이 치트 시트는 HTML을 사용하여 웹 페이지를 구조화하고 형식 지정하는 데 필요한 모든 내용을 다룹니다.\n\n2. CSS Cheat Sheet\n\n<div class=\"content-ad\"></div>\n\n![CSS Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_2.png)\n\nCSS Cheat Sheet은 CSS 선택자, 속성 및 값에 대한 go-to 참조 자료입니다. 텍스트 스타일링, 요소 위치 지정 또는 반응형 레이아웃 생성 등을 할 때, 이 치트 시트는 명확한 설명과 CSS 규칙 및 기술의 예제로 유용합니다.\n\n3. JavaScript Cheat Sheet\n\n![JavaScript Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_3.png)\n\n<div class=\"content-ad\"></div>\n\nJavaScript Cheat Sheet은 JavaScript 구문, 데이터 유형, 연산자 및 함수에 대한 편리한 참조 자료입니다. 동적 웹 상호작용을 위한 스크립트를 작성하거나 브라우저에서 데이터를 조작하는 경우, 이 치트 시트는 깔끔하고 효율적인 JavaScript 코드를 작성하고 변수, 반복문 및 조건문과 같은 주요 개념을 이해하는 데 도움이 될 것입니다.\n\n4. Git Cheat Sheet\n\n![](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_4.png)\n\nGit Cheat Sheet은 소프트웨어 개발 프로젝트에서 버전 관리 및 협업에 필수적입니다. `git add` 및 `git commit`과 같은 기본 Git 명령에서 브랜치 및 병합과 같은 더 고급 워크플로까지, 이 치트 시트는 Git을 사용하여 코드베이스를 효과적으로 관리하는 데 빠른 참조 자료를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n5. 부트스트랩 치트 시트\n\n![부트스트랩 치트 시트](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_5.png)\n\n부트스트랩 치트 시트는 부트스트랩 프레임워크에 대한 포괄적인 가이드로, 그리드 시스템, 구성 요소 및 유틸리티를 포함하고 있습니다. 반응형 레이아웃을 구축하거나 UI 요소에 스타일을 적용할 때, 이 치트 시트는 부트스트랩 클래스와 기능을 사용하여 개발 프로세스를 더욱 효율적으로 만들어주는 빠른 참고 자료를 제공합니다.\n\n6. jQuery 치트 시트\n\n<div class=\"content-ad\"></div>\n\n\n![jQuery Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_6.png)\n\njQuery Cheat Sheet은 DOM 조작과 이벤트 처리를 위한 인기 있는 JavaScript 라이브러리에 대한 안내서입니다. 요소 선택 및 CSS 조작, 애니메이션 및 AJAX 요청 처리부터 웹 프로젝트에서 상호작용 및 기능성을 향상하는 데 필요한 jQuery 메소드와 구문을 다룬다.\n\n7. React Cheat Sheet\n\n![React Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_7.png)\n\n<div class=\"content-ad\"></div>\n\n리액트 치트 시트는 사용자 인터페이스를 구축하는 데 리액트 라이브러리를 사용하는 개발자들에게 유용한 참고 자료입니다. 컴포넌트 생성 및 상태 관리, 이벤트 처리 및 동적 콘텐츠 렌더링까지, 이 치트 시트는 리액트 개념과 패턴에 대한 간략한 개요를 제공하여 강력하고 효율적인 리액트 애플리케이션을 개발하는 데 도움이 됩니다.\n\n8. Node.js 치트 시트\n\n![Node.js Cheat Sheet 이미지](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_8.png)\n\nNode.js 치트 시트는 Node.js를 사용한 서버 측 JavaScript 개발을 안내해주는 가이드입니다. 서버 설정 및 HTTP 요청 처리, 모듈 및 파일 시스템 작업부터 확장 가능하고 성능이 우수한 웹 애플리케이션을 구축하는 데 필수적인 Node.js API 및 기능을 다루는 치트 시트입니다.\n\n<div class=\"content-ad\"></div>\n\n이 필수 참고 자료들을 손끝으로 사용하면 어떤 웹 개발 프로젝트에도 자신감 있고 효율적으로 대응할 수 있을 거예요.\n\n이 자원들을 반드시 즐겨찾기 해 두세요✅ 그리고 필요할 때마다 빠르게 참고할 수 있도록 다시 돌아오세요.\n\n더 많은 유용한 기사를 탐색하고 싶다면, Medium에서 저를 팔로우해보세요 🔗 아래 댓글 💬을 남겨주시고 함께할 기술 모험 종류를 알려주세요! 의견을 듣고 싶어요.\n\n이 기사를 즐겼다면, 응원의 의미로 👏 박수를 주는 것을 잊지 마세요!","ogImage":{"url":"/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png"},"coverImage":"/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png","tag":["Tech"],"readingTime":4},{"title":"크로스 도메인에서 로컬스토리지 구현하기","description":"","date":"2024-05-01 23:55","slug":"2024-05-01-Howtoachievecross-domainlocalStorage","content":"\n\n\n![이미지](/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png)\n\nLocalStorage는 웹에 데이터를 저장하는 한 가지 방법입니다. 이는 클라이언트 컴퓨터 브라우저에 저장됩니다.\n\n데이터는 도메인별로 저장되며, 동일한 도메인을 가진 페이지만이 데이터에 액세스하고 수정할 수 있습니다. 다른 도메인의 페이지는 서로의 데이터에 액세스할 수 없습니다. 이는 브라우저 저장소 보안 문제이며, 사실 도메인 및 서브도메인 간에 LocalStorage/SessionStorage/IndexedDB를 공유할 수 없습니다. 이는 \"동일 출처 정책\"의 일부입니다.\n\n# 왜 localStorage를 공유해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n내가 겪은 실제 예시 중 하나는 회사에서 개발하지 않은 마케팅 사이트의 데이터에 접근해야 했을 때였어요. 우리 회사에서 개발하지 않은 사이트는 저희 응용 프로그램 사이트와 다른 도메인에 호스팅되어 있었거든요.\n마케팅 사이트가 www.marketing.com 도메인에 있고, 저희 응용 프로그램이 다른 도메인인 www.app-site.com에 있었다고 해봅시다. 사용 사례는 분석 목적을 위해 이 두 사이트 간의 전체 사용자 이동을 저장하는 것이었어요. 사용자는 localStorage에 저장된 사용자 ID를 받았고, 그 여정 중 각 이벤트가 그 ID와 함께 기록되었어요. 저는 도메인 간에 localStorage를 공유할 수 있는 방법이 필요했어요.\n\n# 어떻게 해결할까요?\n\nA 도메인이 www.aaa.com이고 B 도메인이 www.bbb.com일 때, B 도메인이 A 도메인의 localStorage를 읽고 쓸 수 있도록 하고 싶다고 해봅시다.\n\n## 요약\n\n<div class=\"content-ad\"></div>\n\n- 도메인 B에 있는 Iframe을 사용하여 도메인 A에서 작은 HTML을로드합니다.\n- 각 도메인(domain B 및 도메인 A의 Iframe)에서 리스너를 설정하고 postMessage를 통해 통신합니다.\n- 도메인 A는 localStorage에서 데이터를 가져와 메시지로 보냅니다.\n\n![이미지](/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_1.png)\n\n## 다른 localStorage에 쓰기\n\n먼저 도메인 B에 Iframe을 생성하고 도메인 A에서 작은 HTML 파일을로드하도록합니다. Iframe 스타일에는 높이, 너비 및 테두리가 없습니다. 또한 절대 위치에 떠 있습니다. DOM의 자연 흐름에 차지되지 않도록하기 위함입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// www.bbb.com\n<iframe id=\"iframe\" src=\"www.aaa.com/external.html\" onload=\"onMyFrameLoad()\"  style=\"width:0;height:0;border:none;position:absolute;\"></iframe>\n```\n\n그리고 도메인 A에서 호스팅된 작은 HTML 파일을 만들어서 리스너를 설정합니다:\n```js\n// www.aaa.com/external.html\n<html>\n    <head>\n      <script>\n          window.addEventListener('message', (message) => {\n            if (message.origin === 'http://www.bbb.com') {\n              const data = JSON.parse(message.data);\n              const { userId } = data;\n              if (userId){\n                localStorage.setItem('userId', userId);\n              }\n            }\n          });\n      </script>\n    </head>\n</html>\n```\n\n이제 도메인 A는 도메인 B로부터 userId와 같은 데이터가 포함된 메시지를 받을 준비가 되었습니다. 이 데이터를 localStorage에 저장합니다. 이 스크립트는 www.aaa.com 아래에 있음을 기억하세요. Iframe에 포함되어 있더라도 여전히 도메인 A의 localStorage를 사용합니다. 사용자가 도메인 B에서 도메인 A로 이동할 때, 우리는 이미 데이터를 갖고 있을 것입니다. 왜냐하면 도메인 B가 메시지를 보내고 도메인 A가 해당 데이터를 localStorage에 저장했기 때문입니다. 중요한 보안 점검으로 message.origin을 먼저 확인하는 것을 잊지 마세요! 우리는 익숙하지 않은 출처의 메시지에 응답하고 싶지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\n우리는 실제로 도메인 B에서 postMessage를 통해 메시지를 보내야 합니다. 이를 위해 Iframe의 onMyFrameLoad 함수 코드를 추가합니다:\n\n```js\n// www.bbb.com\n<script>\n  function onMyFrameLoad() {\n    var userId = getUserId();\n    var data = {userId: userId};\n    var iframeEl = document.getElementById(\"myIframe\");\n    iframeEl.contentWindow.postMessage(JSON.stringify(data), 'www.aaa.com');\n  };\n</script>\n\n<iframe id=\"iframe\" src=\"www.aaa.com/external.html\" onload=\"onMyFrameLoad()\"  style=\"width:0;height:0;border:none;position:absolute;\"></iframe>\n```\n\nIframe가로드 된 후에 onMyFrameLoad 함수가 실행되어야 하는 것이 중요합니다. 즉, onload에서 호출해야 합니다. 메시지를 보내기 전에 다른 쪽에서 이벤트 리스너를 추가해야 합니다.\n\n그래서 모든 것을 설정했습니다. 사용자가 도메인 B에 도달하면 Iframe이 로드되고, 그런 다음 도메인 A의 external.html이 호출되어 메시지를 위한 리스너를 설정합니다. 도메인 B는 이후 userId를 도메인 A로 전송할 postMessage를 실행한 후, 그것이 localStorage에 저장될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 반대 방향\n\n이제 사용자가 처음에 도메인 A를 방문한 경우를 고려해 봅시다. 우리는 도메인 A의 로컬 저장소에 저장된 사용자 ID와 같은 데이터를 도메인 B와 공유하고 싶습니다.\n\n이를 위해 외부.html에 이 데이터가 이미 있는지 확인하는 if 문을 추가해야 합니다. 데이터가 있는 경우, 도메인 B에게 postMessage를 보냅니다. 그렇지 않으면, 도메인 B가 데이터를 보내기를 대기합니다.\n\n```js\n// www.aaa.com/external.html\n<html>\n    <head>\n      <script>\n            const userId = localStorage.getItem('userId');\n            if (userId) {\n              const data = {userId: userId};\n              parent.postMessage(JSON.stringify(data), \"http://www.bbb.com\")\n            }\n            else {\n              window.addEventListener('message', (message) => {\n                if (message.origin === 'http://www.marketing.com') {\n                  const data = JSON.parse(message.data);\n                  const { userId } = data;\n                  if (userId){\n                    localStorage.setItem('userId', userId);\n                  }\n                }\n              });       \n            }  \n      </script>\n    </head>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n알림: 이제 postMessage는 iframe 요소가 아니라 부모의 속성입니다. 이는 iframe이 포함되어 있을 때 해당 window이 로드를 담당하는 부모 객체이기 때문입니다.\n\n그리고 도메인 A와 유사하게, 도메인 B에서 듣는 리스너를 추가할 것입니다.\n\n```js\n// www.bbb.com\n<script> \n    window.addEventListener('message', function(message) {\n    if (message.origin === 'wwww.aaa.com') {\n      var data = JSON.parse(message.data);\n      var userId = data.userId;\n      if (userId){\n        doSomethingWithTheData()\n      }\n    }\n  });\n</script>\n\n<script>\n  function onMyFrameLoad() {\n    var userId = getUserId();\n    var data = {userId: userId};\n    var iframeEl = document.getElementById(\"myIframe\");\n    iframeEl.contentWindow.postMessage(JSON.stringify(data), 'www.aaa.com');\n  };\n</script>\n\n<iframe id=\"myIframe\" src=\"www.aaa.com/external.html\" onload=\"onMyFrameLoad()\"  style=\"width:0;height:0;border:none;position:absolute;\"></iframe>\n```\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n우리는 localStorage에 저장된 데이터를 다른 도메인과 iframe을 사용하여 postMessage를 통해 공유할 수 있다는 것을 알았어요.\n\n이것은 물론 2개의 도메인 간에 정확히 공유하려는 매개변수에 대한 합의가 있는 구체적인 사용 사례에 적합합니다. 우리는 거의 없지만 교차 도메인 스토리지 규칙을 어길 용의가 있는 몇 가지 사용 사례가 있으므로, 당신의 경우가 적합한 사용 사례인지 신중히 생각해야 해요.","ogImage":{"url":"/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png"},"coverImage":"/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png","tag":["Tech"],"readingTime":6},{"title":"HTMX와 Express.JS를 이용해 얼굴 인식 기능 추가하기","description":"","date":"2024-05-01 23:54","slug":"2024-05-01-IntegratingFaceIOusingHTMXandExpressJS","content":"\n\n요즘 빠르게 발전하는 디지털 시대에는 보안과 사용자 경험이 중요한 고려 사항이며, 견고한 인증 솔루션을 찾는 노력이 더 커지고 있습니다. 암호와 같은 전통적인 방법은 더 많은 위협에 노출되고 사용자 불만을 증가시키므로 대체 메커니즘에 대한 탐구가 증가하고 있습니다. 얼굴 인증은 보안과 사용자 경험을 결합한 유망한 솔루션이 되어 나타났습니다.\n\n이 기사는 얼굴인식을 웹 애플리케이션에 쉽게 통합할 수 있는 FACEIO와 HTMX, Express.js의 융합을 탐구합니다. HTMX의 동적 기능과 Express.js의 견고함을 활용하여 이 통합은 웹 인증을 혁신하고 안전하고 사용자 친화적인 경험을 제공할 것으로 약속합니다. 실용적인 예제와 통찰을 통해, 이 융합이 개발자들에게 보안 및 사용자 만족도를 향상시키는 정교한 인증 시스템을 만들 수 있는 능력을 부여하는 방법을 살펴보겠습니다.\n\n![faceio](/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png)\n\nFaceIO 개요\n\nFACEIO는 원활한 통합과 실시간 이벤트 알림을 위한 포괄적인 API 및 Webhooks 기능을 제공합니다. API를 통해 개발자들은 애플리케이션을 관리하고 등록 및 인증과 같은 작업을 수행하고 분석을 수집할 수 있습니다. 이는 HTTP를 통해 작동하여 모든 요청에 대해 표준 응답 코드를 제공하고 JSON을 반환합니다. API 키를 FACEIO 콘솔을 통해 관리하여 안전한 액세스가 보장됩니다. Webhooks는 등록 및 인증과 같은 이벤트에 대한 실시간 알림을 가능하게 합니다. 이벤트가 트리거될 때, FACEIO는 사용자 ID, 이벤트 유형, 타임스탬프 및 IP 정보와 같은 이벤트 세부 정보가 포함된 HTTP POST 요청을 구성된 URL로 보내어 적시에 백엔드 업데이트와 적극적인 대응을 용이하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n![](https://miro.medium.com/v2/resize:fit:1400/1*Nc0gNijxAiCVb3-UfHcQSQ.gif)\n\nHTMX에 대한 간단한 설명\nHTMX는 HTML에서 브라우저 기능에 직접 액세스하여 JavaScript와 클라이언트-서버 통신 관리의 필요성을 줄이는 방식으로 웹 개발을 간소화합니다. 클라이언트 측 렌더링 기능을 통해 전체 페이지 새로고침을 최소화하여 웹 앱의 반응성을 향상시킵니다. HTMX는 hx-get 및 hx-post와 같은 직관적인 HTML 속성을 통해 폼 제출 및 실시간 업데이트와 같은 기능을 용이하게 지원합니다.\n\nHTMX와 FaceIO 통합\nFaceIO를 HTMX와 통합하는 것은 웹 애플리케이션에서 원활한 얼굴 인증을 가능하게 하는 여러 단계로 이뤄집니다. 아래는 이 통합 프로세스를 보여주는 주요 단계와 코드 샘플입니다:\n\n![](/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_1.png)\n\n<div class=\"content-ad\"></div>\n\nFaceIO 설정하기\nFaceIO 콘솔에서 FaceIO 애플리케이션의 공개 ID를 가져옵니다.\n웹 애플리케이션에서 FaceIO 얼굴 인식 엔진을 초기화합니다.\nFaceIO를 설정하는 샘플 코드:\n\n```js\n<head>\n  <script src=\"https://cdn.faceio.net/fio.js\"></script>\n  <script>\n    // 공개 ID로 FaceIO를 초기화합니다\n    const faceIO = new FaceIO('YOUR_PUBLIC_ID');\n  </script>\n</head>\n```\n\nHTMX 통합하기\nHTMX 라이브러리를 HTML에 스크립트 태그를 포함하여 프로젝트에 추가합니다.\nHTMX 속성을 활용하여 동적 상호작용을 정의하고, 예를 들어 버튼 클릭 시 FaceIO 인증을 트리거할 수 있습니다.\nHTMX를 통합하는 샘플 코드:\n\n```js\n<head>\n  <script src=\"https://cdn.jsdelivr.net/npm/htmx.org@1.6.1/dist/htmx.min.js\"></script>\n</head>\n<body>\n  <!-- 버튼 클릭으로 FaceIO 인증 트리거하기 -->\n  <button hx-get=\"/authenticate\" hx-trigger=\"click\">FaceIO로 인증하기</button>\n</body>\n```\n\n<div class=\"content-ad\"></div>\n\nNode.js와 Express를 사용하여 서버 측 엔드포인트 만들기\nFaceIO 인증 요청을 처리하기 위한 서버 측 엔드포인트를 정의하십시오.\nFaceIO API와 상호 작용하여 얼굴 인식을 기반으로 사용자를 인증하는 서버 측 로직 구현하기\n\n```js\nconst express = require('express');\nconst app = express();\n\n// FaceIO 인증을 처리하는 엔드포인트\napp.get('/authenticate', async (req, res) => {\n  try {\n    // 얼굴 인증을 수행하기 위해 FaceIO API 호출\n    const authenticationResult = await faceIO.authenticate();\n\n    // 인증 결과 처리 (예: 액세스 부여 또는 오류 메시지 표시)\n    res.send(authenticationResult);\n  } catch (error) {\n    // 오류 처리 (예: 오류 메시지 기록 또는 오류 응답 반환)\n    res.status(500).send('내부 서버 오류');\n  }\n});\n\n// 서버 시작\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`포트 ${PORT}에서 서버 실행 중`);\n});\n```\n\n원활한 인증 경험 설계하기\n사용자 인터페이스를 맞춤 설정하여 FaceIO 인증 프로세스 중에 피드백을 제공하기\n서버로부터의 인증 응답을 처리하여 UI를 그에 맞게 업데이트하기\n인증 결과에 따라 UI를 업데이트하는 샘플 코드:\n\n```js\n<script>\n  async function authenticateWithFaceIO() {\n    try {\n      // HTMX를 통해 FaceIO 인증 수행\n      const response = await hx.get('/authenticate');\n\n      // 인증 결과에 따라 UI 업데이트\n      if (response.success) {\n        alert('인증 성공!');\n      } else {\n        alert('인증 실패. 다시 시도해주세요.');\n      }\n    } catch (error) {\n      console.error('오류:', error);\n    }\n  }\n</script>\n```\n\n<div class=\"content-ad\"></div>\n\n결론\n\n요약하자면, FaceIO를 HTMX와 Express.js와 통합하는 것은 웹 애플리케이션에서 보안을 강화하고 사용자 경험을 향상시키는 강력한 해결책을 제공합니다. FaceIO를 통해 얼굴 인증을 활용하고, HTMX가 제공하는 동적 HTML 상호작용과 Express.js의 강력한 백엔드 기능을 결합하여 개발자는 견고하고 사용자 친화적인 인증 시스템을 구축할 수 있습니다. 이 통합은 비밀번호 관련 위반 사례를 완화함으로써 보안 조치를 강화할 뿐만 아니라, 인증 프로세스를 간소화하여 원활하고 효율적인 사용자 경험을 조성합니다. FaceIO, HTMX 및 Express.js 간의 협업을 더 심층적으로 탐구함으로써, 웹 개발에서 혁신적인 발전을 이루며 안전하고 동적인 애플리케이션이 접근 가능하면서도 최고의 개인 정보 보호와 사용 용이성 기준을 유지할 수 있도록 합니다.","ogImage":{"url":"/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png"},"coverImage":"/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러로 웹사이트 만들 때 캐시 함정을 피하는 방법","description":"","date":"2024-05-01 23:52","slug":"2024-05-01-AvoidcachetrapwhenservingAngularapp","content":"\n\n![이미지](/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png)\n\n가장 이상한 버그 중 하나는 대규모 디자인 변경 후 발생했어요. 매일 아침마다 문제가 생기는 건데, 왜 그런 걸까요? 이 기사 제목을 보셨으니 이미 캐시와 관련이 있다는 건 알겠죠. 그렇다면 이런 문제가 왜 발생하는 걸까요, 그리고 어떻게 예방할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n우리는 모두 캐시를 좋아합니다, 맞지요? 캐시는 앱을 더 빨리 로드하는 데 도움을 주고, 서버로부터 일부 부하를 줄여 주며, 사용자들이 우리 앱에서 좋은 사용자 경험을 느낄 수 있도록 합니다.\n\n하지만 때로는 이 캐시가 우리에게 반대로 작용하고 사용자들이 앱의 최신 버전을 얻지 못하도록 할 수 있습니다. 이는 아마도 서버의 잘못된 캐시 구성 때문인 경우가 많습니다.\n\n우리 Angular 애플리케이션에서 캐시 문제를 피하고 앱 버전 관리하기 위해서, 우리가 ng build --prod로 프로덕션용 앱을 빌드할 때 Angular는 (기본적으로) 우리의 js 파일에 해시를 추가하고 index.html 파일을 해시 파일을 참조하도록 업데이트합니다. 새 버전을 배포하면 해시 키가 변경되고 사용자가 사이트를 다시 요청하면 index.html은 서버에서 새 파일을 로드하도록 요청합니다. 브라우저에는 이러한 파일이 캐시되어 있지 않기 때문에 서버에서 파일을 받아옵니다.\n\n그래서 Angular 덕분에 문제가 해결됐다고 할 수 있을까요? 음, 완전히 그렇지는 않습니다. 문제는 index.html 파일이 캐시될 때 발생합니다. 새로운 앱 버전을 디플로이했고 정적 파일과 index.html 파일이 캐시되어 있는 상황에서 사용자가 메인 URL에서 앱을 시작하면 캐시된 index.html은 이전 js 파일을 로드하도록 요청할 것이고, 이 파일들은 브라우저 캐시로부터 로드될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 시나리오를 계속 진행하면서 약간 복잡해집니다. 사용자는 우리 앱을 사용하며(기억하세요 - 이전 버전으로), 화면 간 이동을 하고 몇 가지 작업을 합니다. 어느 시점에서 새로고침을 하기로 결정했는데, 이제 새 앱 버전을 받게 되었습니다.\n\n기다려주세요, 새 버전? 하지만 왜요? index.html이 캐시에 있고, 왜 새 버전을 받고 있을까요? 이는 SPA를 서버에서 제공할 때 리다이렉트하는 방식과 관련이 있습니다.\n\nSPA는 클라이언트 측에서 앱 내비게이션을 처리하며, Angular 라우터를 통해 새 경로로 이동할 때마다 주소 표시줄의 URL을 동적으로 변경합니다. 사용자가 브라우저 주소 표시줄에 앱의 루트를 입력하고, 예를 들어 https://some-domain.com/home을 입력하고 엔터를 클릭하면, 실제로 서버에 이 루트가 없지만, 404를 반환하는 대신 서버에서 index.html을 반환하도록 구성되어 있습니다. Angular 라우터가 작업을 수행하고 사용자를 올바른 화면으로 이동시킵니다.\n\n이제 우리 시나리오에서 무슨 일이 일어나고 있는지 이해할 수 있습니다. 메인 URL에서 앱에 접속하면 캐시에 이 엔드포인트가 있기 때문에 이전 버전을 받게 됩니다. 그러나 특정 경로를 요청하는 경우, 항상 서버에서 index.html을 받고 캐시에서가 아닌 새 버전을 보게 됩니다 - 따라서 새로 고침 후에 새 버전이 나타날 것입니다.\n\n<div class=\"content-ad\"></div>\n\n좋죠, 그렇죠? 덕분에 캐시에 있는 하나의 index.html 때문입니다.\n\n## index.html 파일이 캐시되었는지 확인하는 방법\n\nindex.html 파일이 캐시되어 있는지 확인하는 것은 매우 쉽습니다.\n\n- 브라우저 개발 도구를 엽니다.\n- 네트워크 탭으로 이동합니다.\n- 캐시 사용 확인란이 선택되지 않았는지 확인합니다.\n- 문서로 필터링합니다.\n- 화면을 새로 고칩니다.\n- 첫 번째 문서를 클릭합니다.\n- 캐시 제어 헤더를 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어 angular.io/docs 사이트를 살펴봅시다:\n\n![이미지](/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_1.png)\n\n캐시 제어 헤더를 보면 no-cache로 설정되어 있습니다. 캐시 제어 헤더에서 어떤 값이 우리에게 좋은지 알아봅시다.\n\n- no-cache — 이 값을 사용하면 index.html 파일이 캐시되지만, 캐시 시스템이 서버에 더 새로운 버전이 있는지 확인하도록 합니다. 우리에게 적합합니다.\n- no-store — 이 값을 사용하면 캐시 시스템이 index.html 파일을 캐시하지 않도록 합니다. 좋은 방법입니다.\n- max-age=0 — 이 값 또한 index.html을 캐시하지 않습니다.\n- max-age=31536000 — 이 값은 좋지 않습니다. max-age의 값은 초로 표현되며, index.html이 1년 동안 캐시됩니다. 어떤 값이 적합한지는 본인의 의견에 따라 다를 수 있지만, index.html을 1년 동안 캐시하고 싶지 않을 것이라는 점에 동의할 수 있을 것 같습니다.\n\n<div class=\"content-ad\"></div>\n\n그것들은 cache-control 헤더에 대한 인기있는 값들이에요; 응답에서 다른 것을 본다면, 여기서 확인해보실 수 있어요.\n\n## cache-control 헤더를 제공하지 않았을 경우에는 어떻게 될까요?\n\n음, 지금은 \"무인도\" 영역에 있다고 할 수 있어요.\n\n![이미지](/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_2.png)\n\n<div class=\"content-ad\"></div>\n\n이 문구는 w3.org 섹션 13.2.2에서 인용한 것입니다:\n\n여기서 몇 가지 종류의 캐시를 언급하는 것이 좋을 것 같습니다. 우리 브라우저의 캐시는 우리 브라우저에서만 우리에게 서비스하는 개인 캐시입니다. 그러나 여러 가지 가능성으로 사용자 간에 공유되는 공개 캐시도 있습니다: 프록시 캐시, 게이트웨이 캐시, CDN, 역방향 프록시 캐시 및 로드 밸런서 등이 있습니다.\n\n따라서, 우리는 indx.html을 캐시하는 방법에 대한 구체적인 지시를 제공하지 않았을 때 어떻게 캐시를 처리해야 하는지에 대한 명세가 없음을 이해했습니다. 기본적으로 모든 캐시나 브라우저는 우리가 제공하거나 제공하지 않는 다른 헤더에 기반한 자체 알고리즘을 적용하고 여전히 index.html을 캐시 할 수 있습니다. 게다가, 이러한 종류의 것들은 테스트할 수 없습니다. 사용자들이 사설 네트워크나 캐시 알고리즘을 적용하는 ISP에서 앱에 접속할 수 있으며 당신은 그 사실조차 알지 못할 수 있습니다. 이것이 W3가 적용을 권장하는 이유입니다. 우리가 명시적인 만료 시간을 제공하도록 하는 것입니다.\n\n따라서, index.html에 올바른 캐시 제어 헤더가 함께 제공되는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n## 캐시 함정\n\ncached index.html의 실제 문제는 캐시에 이미 파일을 받은 사용자들이 캐시된 파일로 갇혀 있을 수 있는 점입니다. 이 상황이 해결되는 방법은 두 가지 중 하나가 발생할 때까지 기다려야 합니다:\n\n- 사용자가 캐시를 수동으로 지우는 경우(브라우저 캐시에 파일이 캐시된 경우를 가정함).\n- 캐시 만료일이 도래하는 경우.\n\n걱정하지 마세요; 이러한 index.html 문제는 상당히 드뭅니다. 대부분의 호스팅 서비스들은 기본적으로 오랜 캐시 구성이 있는 정적 파일을 제공하지 않습니다. 그러나 Angular 앱을 제공하는 서버가 이미 존재하고 동적 파일을 제공하는 경우에는 이 문제가 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## index.html 폼이 캐싱되는 것을 방지하는 방법\n\n아마도 HTML 메타 태그로 캐시를 제어하려고 시도하라는 StackOverflow 답변을 몇 가지 찾을 수 있을 겁니다. 심지어 이를 테스트해 볼 수 있고, 브라우저에서 작동할 수도 있습니다. 하지만 좀 더 조사해 보면, 이는 캐시를 방지하는 효과적인 방법이 아님을 알게 될 것입니다. 이러한 태그들은 일부 브라우저에 의해 존중될 수 있지만 다른 유형의 캐시에는 존중되지 않을 수 있습니다.\n\n가장 좋은 방법은 서버의 index.html에 캐시 제어 헤더를 설정하는 것입니다. 이를 위해 서버 구성에 일부 변경이 필요하지만 이것이 캐시를 방지하는 가장 간단하고 효과적인 방법입니다.\n\n## 서비스 워커를 사용하고 있어요; 모두 좋아요!\n\n<div class=\"content-ad\"></div>\n\n죄송하지만 아니에요.\n\nangular.io의 예제에서 서비스 워커에서 서비스되는 파일을 주목했을 수 있습니다. 그러나 Angular 팀은 여전히 이 파일을 캐시 제어=no-cache 헤더와 함께 서버에서 보냅니다.\n\n서비스 워커는 멋져요! 풀 컨트롤을 제공하는 동시에 파일을 캐싱합니다. 그러나 이전에 언급한 대로 몇 가지 캐시 유형이 있죠. 서비스 워커는 그 중 하나일 뿐입니다. 요청이 통과하는 레이어 중 하나인 서비스 워커는 HTTP 캐시(브라우저 캐시)나 공용 캐시는 대신하지 않습니다. 서비스 워커가 서버에서 파일을 가져오기로 결정하면 브라우저는 여전히 해당 헤더를 확인하여 캐시에서 제공할지 여부를 결정할 것입니다.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n몇 가지 캐시 문제는 디버그하기 어렵고 재현하기 어렵며 쉽게 코드 문제로 오해될 수 있습니다. 보통 우리 앱의 최종 사용자로부터 발생하며 새 버전을 얼마나 자주 릴리스하는지에 따라 달라집니다. 일부 사용자는 문제가 있다고 신고하지 않을 수도 있고, 그냥 \"새로고침하면 사라지는 이상한 동작\"으로만 설명할 수도 있습니다.\n\n우리 모두는 사용자들을 위해 최상의 경험을 원합니다 — 자신이 확신이 없다면, 오늘은 캐시를 확인해보세요! 😏","ogImage":{"url":"/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png"},"coverImage":"/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png","tag":["Tech"],"readingTime":5},{"title":"Figma 디자인을 HTML과 CSS로 변환하는 플러그인 10가지","description":"","date":"2024-05-01 23:51","slug":"2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/0*63WG6R0wvA90tl3C.gif)\n\n요즘 디지털 세상에서 온라인 애플리케이션은 인터넷 생활을 이끌기 위한 필수 구성 요소 중 하나입니다. 그러한 애플리케이션을 만드는 것은 더 많은 노력이 필요합니다. 디자인부터 개발까지, 작업이 복잡했던 반면, 디자이너와 개발자 간의 협업은 특히 디자인 제품을 만들 때 항상 도전이었습니다.\n\nFigma 및 그 플러그인들은 전체 제품을 처음부터 수동 코드로 작성하는 과정과 같은 모든 소음을 제거하는 단일 소스로 나타났습니다. 따라서, 여기에서는 Figma 디자인을 HTML 및 CSS 코드 스니펫으로 변환하여 디자인부터 코드로의 여정을 이전보다 훨씬 원활하게 만들어주는 최고의 15가지 Figma 플러그인을 소개합니다.\n\n# 디자인을 HTML 및 CSS 코드로 변환하는 최고의 10개 Figma 플러그인\n\n<div class=\"content-ad\"></div>\n\n- 제플린\n\n![제플린](https://miro.medium.com/v2/resize:fit:1400/0*7-PK7dTGINR7K4O6.gif)\n\n제플린은 디자이너와 개발자 양쪽 모두에게 최고의 도구 중 하나입니다. 이 도구는 협업 작업을 간단화할 뿐만 아니라 Figma 디자인 및 요소를 픽셀 완벽한 CSS 및 HTML 스니펫으로 변환합니다. 가장 좋은 점은 생성된 코드를 수동 편집 없이 개발 프로세스에 직접 구현할 수 있다는 것입니다. 제플린을 사용하면 개발 프로세스를 더 효과적이고 생산적으로 더욱 촉진할 수 있습니다.\n\n2. Anima\n\n<div class=\"content-ad\"></div>\n\n\n![Anima](https://miro.medium.com/v2/resize:fit:1400/0*jCye8_4bx0e-doVR.gif)\n\n애니마(Anima)는 다른 유명한 도구로, 반응형 디자인을 통해 사용자 경험을 향상시키는 데 알려져 있습니다. 이 도구는 모든 요소를 서로 다른 화면 크기에 맞춰 유지함으로써 애플리케이션이 매력적이고 매력적으로 보이도록합니다. 사용자가 애플리케이션에 액세스할 때 화면 크기가 어떻게 되든 웹사이트가 일정하게 유지됩니다. 또한 Anima는 Figma 내에서 상호작용 및 애니메이션을 직접 결정하도록 하면서 모든 디자인에 대한 자동 HTML 및 CSS 코드를 생성합니다.\n\n3. Framer Web\n\n![Framer Web](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png)\n\n<div class=\"content-ad\"></div>\n\n프레이머 웹은 하나의 플러그인 내에서 세 가지 필수 코딩 측면을 제공하는 세 가지인-원 솔루션 툴입니다. 디자이너가 모델을 설계하고 프로토타입을 만들 수 있도록 도와주며, 개발자는 손쉽게 실행 가능한 HTML 및 CSS 코드로 변환할 수 있습니다. 이 모든 작업을 Figma와 프레이머 웹을 떠나지 않고 하나의 인터페이스에서 수행할 수 있습니다. 만약 올인원 디자인, 프로토타입 및 코딩 도구가 필요하다면 이 플러그인을 선택해야 합니다.\n\n4. HTML to Figma\n\n![HTML to Figma](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_1.png)\n\nHTML to Figma은 외부 HTML 및 CSS 코드를 Figma로 가져올 수 있는 기능으로 구성되어 다른 디자인-코드 변환 방식과는 다릅니다. 디자이너와 개발자가 기존 코드베이스를 개선하기 위해 협업할 수 있습니다. 이를 통해 디자이너와 협력하여 개발 주기를 가속화시키고 코드의 수동 업데이트 필요성을 제거할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n5. Figma를 HTML로\n\n![Figma to HTML](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_2.png)\n\nFigma를 HTML로 변환하여 개발 과정을 가속화할 수 있습니다. 이 플러그인은 Figma 디자인을 HTML 및 CSS 코드 조각으로 변환하여 코드가 반응형임을 보장합니다. 세부 사항에 주의를 기울이는 이 플러그인을 사용하면 프로젝트를 더 정확하고 효율적으로 만들 수 있습니다. 게다가 코드가 이미 반응형이므로 사용자 경험을 향상시킬 수 있습니다.\n\n6. Koncept\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*vdRtH-uxMhPYHYXX.gif)\n\nKoncept은 디자인을 코드로 변환하는 프로세스를 넘어서는 포괄적인 디자인 및 프로토타이핑 플랫폼입니다. 깔끔하고 조직적인 HTML 및 CSS 코드 조각을 생성하여 개발 프로세스에서 직접 구현할 수 있는 기본 기능 외에도 플랫폼 내에서 애니메이션 및 상호작용을 정의할 수 있습니다.\n\n7. Auto-Layout to HTML\n\n![image](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_3.png)\n\n<div class=\"content-ad\"></div>\n\nAuto-Layout to HTML 플러그인은 반응형 디자인에 중점을 둡니다. Figma의 자동 레이아웃 기능을 활용하여 요소를 유연한 CSS Grid 또는 Flexbox 레이아웃으로 변환합니다. Auto-Layout to HTML은 자동 레이아웃 기능에 의존하기 때문에 버튼은 텍스트에 따라 크기가 조절되고, 목록은 항목과 함께 재배열되며, 복잡한 인터페이스를 생성할 수 있습니다. 컨텐츠에 반응하는 웹사이트를 만들 수 있습니다. PixelPerfect은 Figma 디자인과 생성된 HTML 및 CSS 코드 간의 정확도를 높입니다. 번역된 코드는 완벽할 정도로 정확하여 실행된 코드가 Figma 디자인과 똑같은 결과를 제공합니다. 이 플러그인은 변환 프로세스 중에 디자인 일관성을 유지하는 데 안성맞춤입니다.\n\n<div class=\"content-ad\"></div>\n\n9. CSS Scan\n\n![CSS Scan](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_4.png)\n\nCSS Scan은 작은 수정 사항이 있는 동일한 디자인 세트에서 작업할 때 도와주는 시간을 절약하는 도구입니다. 코드에서 정확한 색상, 글꼴 크기 및 기타 스타일을 복제할 때 어떤 요소에서도 CSS 값들을 직접 추출할 수 있습니다. 몇 번의 클릭으로 모든 작업을 완료할 수 있어서 지루한 색상 코드를 기억할 필요도 없습니다.\n\n10. Figmify\n\n<div class=\"content-ad\"></div>\n\n![figmify](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_5.png)\n\n디자인에 복잡한 상호 작용이나 애니메이션이 필요하지 않은 경우 Figmify가 최적의 선택일 수 있습니다. 몇 번의 클릭으로 Figmify가 Figma 디자인을 깔끔한 HTML 및 CSS 코드 조각으로 변환하도록 자동화할 수 있습니다.\n\n# 요약:\n\n애플리케이션을 구축하는 것은 어렵습니다. 특히 디자이너와 개발자 간의 적절한 협력이 없을 때입니다. 이 모든 것을 연결하는 과정에서 Figma는 개발 프로세스를 용이하게 해주는 플러그인을 소개했습니다.\n\n<div class=\"content-ad\"></div>\n\n각 플러그인은 반응형 디자인부터 고급 상호 작용 프로토타이핑까지 다양한 기능을 제공하여 특정 요구 사항을 충족시킵니다. 이러한 플러그인을 사용하면 Figma 요소를 실행 가능한 HTML 및 CSS 코드로 변환하는 번거로운 작업을 완전히 제거할 수 있습니다. 넓은 Figma 커뮤니티를 탐험하고, 도전적인 디자인-코드 작업 프로세스를 향상시켜보세요!\n\nFigma의 기능과 업데이트를 보려면 Linkedin에서 팔로우하기를 잊지마세요.","ogImage":{"url":"/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png"},"coverImage":"/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png","tag":["Tech"],"readingTime":5},{"title":"실무에 적용하면 퇴근시간 단축하는 웹 스크래퍼 만들기","description":"","date":"2024-05-01 23:48","slug":"2024-05-01-BuildingaWebScraperforThreeCommonUseCases","content":"\n\n![이미지](/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_0.png)\n\n# 동기부여\n\n최근 지역 소매업체 웹사이트에서 새 노트북을 찾고 있었는데, 여러 페이지의 검색 결과를 통해 여러 노트북의 브랜드, 사양 및 가격을 수동으로 메모해야 했습니다(비교 목적). 이 매뉴얼한 방식에 대한 frustration을 파트너에게 털어놓자, e-커머스 웹사이트에서도 유사한 불만을 표현했습니다.\n\n그 후, 웹 스크래퍼를 사용하여 웹사이트의 내용을 구조화된(예: 테이블 형식) 데이터로 자동 변환하는 과정을 자동화하는 것에 대한 사례를 탐구했습니다. 본 문서는 다음 세 가지 일반적인 사용 사례에 대한 웹 스크래퍼의 실제 단계별 가이드를 제공합니다:\n\n<div class=\"content-ad\"></div>\n\n- 여러 페이지에 걸쳐 검색 결과를 반환하는 웹사이트를 찾을 때 (\"페이지별 검색\")\n- 수동으로 아래로 스크롤하여 더 많은 검색 결과를 반환하는 웹사이트를 찾을 때 (\"무한 스크롤\")\n- 웹사이트에 호스팅된 이미지를 다운로드할 때 (\"이미지 스크랩\")\n\n# 웹 스크레이핑에 대한 비 기술적 소개\n\n사용자가 웹사이트에서 만나는 대부분의 콘텐츠는 사실 HTML 코드의 출력물입니다. 이러한 코드는 일반적으로 모든 웹사이트가 따르는 일반 규칙과 함께 컴파일됩니다. 즉, 웹사이트의 '프론트엔드'에 사용자에게 표시되는 콘텐츠는 웹사이트의 HTML 코드의 관련 레이어를 쿼리하여 저장 및 다운로드할 수 있습니다.\n\n이 기사의 목적을 위해 사용된 웹 스크레이퍼는 주로 BeautifulSoup 및 Selenium 라이브러리를 사용하여 Python으로 개발되었습니다. 특히, BeautifulSoup 라이브러리는 웹사이트 뒤의 HTML 코드에서 데이터를 검색하고 쿼리하며 반환하는 기능을 제공하며, Selenium 라이브러리는 브라우저 자동화를 지원합니다(예: Google Chrome 또는 Firefox 브라우저에서 특정 작업 수행).\n\n<div class=\"content-ad\"></div>\n\n# 사용 사례 1: 페이지별 검색을 위한 웹 스크래퍼\n\n이 사용 사례를 보여주기 위해 세포라 웹 사이트에서 \"파운데이션\"과 관련된 데이터를 스크래핑 할 것입니다 (비난하지 마세요). 다음과 같이 Python 라이브러리를 가져오는 것으로 시작할 것입니다.\n\n```js\nfrom bs4 import BeautifulSoup\nfrom selenium import webdriver\nimport pandas as pd # 데이터를 데이터프레임에 저장하기 위해\n```\n\n그런 다음 Google Chrome을 사용하여 검색 '페이지 1'에서 관심 있는 데이터를 스크래핑하려고 시도한 다음, For-Loop를 사용하여 다른 모든 페이지에 대해이 스크래핑을 구축할 것입니다. 각각 화장품 제품의 브랜드, 설명 및 가격을 스크래핑하기 위해 웹 사이트의 HTML 코드를 파이썬 객체인 soup_sephora로 구문 분석하기 시작할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n## Sephora 웹 사이트에서 \"파운데이션\"을 검색한 결과 페이지 1의 URL\nurl = \"https://www.sephora.com.au/search?q=foundation&page=1\"\n## 아래 옵션은 Chrome이 실제로 열리는 것을 방지합니다\noptions = webdriver.ChromeOptions()\noptions.add_argument('--headless')\n## chromedriver 다운로드 및 위치 지정\ndriver = webdriver.Chrome(\n                          executable_path = r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe',\n                          chrome_options = options\n                           )\ndriver.get(url)\n## HTML 코드 반환\nsoup_sephora = BeautifulSoup(driver.page_source, 'lxml')\n```\n\n저장된 HTML 코드 (soup_sephora 객체에 저장된)를 Microsoft Word나 메모장과 같이 검색 가능한 문서 유형에 붙여 넣는 것이 좋습니다. 이렇게 하면 관심 있는 데이터를 반환하기 위해 쿼리해야 할 속성을 식별하는 데 도움이 됩니다. 예를 들어, 페이지 1의 각 제품의 가격 속성은 HTML 구조에서 \"product-price\" 클래스에 저장되어 있으며, 특정 제품의 가격을 확인하기 위해 가격에 대한 \"CTRL+F\"를 수행하여 식별할 수 있습니다. 첫 번째 이미지에서 보이는 가격 $95의 YSL 파운데이션이 경우, 이는 두 번째 이미지에서 \"product-price\" 클래스 아래의 텍스트 문자열로 soup_sephora 객체에 포함되어 있으며, Microsoft Word 문서에서 \"$95\"를 검색하여 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_1.png\" />\n\n<img src=\"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n아래 코드는 파이썬 리스트에 페이지 1의 모든 제품의 가격을 반환합니다.\n\n```js\nsoup_sephora.findAll(class_ = \"product-price\")\n```\n\n위 내용을 고려하면, 검색 결과 페이지 1에 있는 모든 제품의 브랜드, 설명, 가격을 다음과 같이 판다스 데이터프레임에 저장할 수 있습니다.\n\n```js\nbrand = []\ndescription = []\nprice = []\nurl = \"https://www.sephora.com.au/search?q=foundation&page=1\"\noptions = webdriver.ChromeOptions()\noptions.add_argument('--headless')\ndriver = webdriver.Chrome(\n                                 executable_path = r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe',\n                                 chrome_options = options\n                                )\ndriver.get(url)\nsoup_sephora = BeautifulSoup(driver.page_source, 'lxml')\ni = 0\nfor item in soup_sephora.findAll(class_ = \"product-card-brand\"):\n    i = i + 1\n    brand.append(item.get_text(strip = True))\nfor item in soup_sephora.findAll(class_ = \"product-card-product\"):\n    i = i + 1\n    description.append(item.get_text(strip = True))\n            \nfor item in soup_sephora.findAll(class_ = \"product-price\"):\n    i = i + 1\n    price.append(item.get_text(strip = True))\ndriver.close()\n## 판다스 데이터프레임으로 변환\ndf_sephora = pd.DataFrame(\n                        {'브랜드': brand,\n                         '설명': description,\n                         '가격': price\n                        })\ndf_sephora.head(10)\n```\n\n<div class=\"content-ad\"></div>\n\n위의 판다 데이터프레임의 출력은 아래 이미지에서 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_3.png)\n\n'Price' 열은 할인이 적용된 제품과 관련하여 추가 정제가 필요할 수 있음을 유의해주세요.\n\n이후 페이지를 스크랩하기 위해서는 단순히 위의 코드를 For-Loop로 감싸고 아래와 같이 url 객체를 소프트 코딩하면 됩니다 (데이터프레임으로 열을 결합하기 전에).\n\n<div class=\"content-ad\"></div>\n\n```js\n## For-Loop에 페이지 수를 지정하기\nfor j in range(1, 페이지 수):\n    url = \"https://www.sephora.com.au/search?q=foundation&page=\" + str(j)\n    **페이지별 크롤링 관련 코드 삽입**\n             .\n             .\n             .\n```\n\n# 사용 사례 2: 무한 스크롤용 웹 스크레이퍼\n\n무한 스크롤은 사용자가 페이지를 스크롤할 때 더 많은 콘텐츠를 로드하는 웹사이트 디자인으로, 페이지 이동을 클릭하지 않고 자동으로 더 많은 콘텐츠를 로드합니다. 이로 인해 Use Case 1용으로 작성된 For-Loop가 다소 유용하지 않을 수 있습니다.\n\n그러나 무한 스크롤은 더 스크롤하는 모션을 흉내 내는 웹 스크레이퍼로 자동화할 수도 있습니다. 이를 위해 스크레이퍼에게 먼저 전체 웹페이지 길이만큼 스크롤하도록 지시하고, 컨텐츠가 로드되기를 기다린 후 몇 초 동안 기다린 후 다시 전체 페이지 길이만큼 스크롤하여 무한 스크롤의 끝에 도달한 후 HTML 코드를 Python 객체로 파싱할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 사용 사례를 보여주기 위해, \"가방\" 검색과 관련된 Acne Studio 웹사이트에서 데이터를 스크래핑할 것입니다.\n\n필요한 Python 라이브러리는 대부분 Use Case 1과 일치하며 다음 추가 사항이 있습니다:\n\n```js\nimport time ## 대기 시간 설정에 사용\nfrom urllib.parse import urljoin ## url을 위한 문자열 결합에 사용\n```\n\n먼저 Google Chrome을 시작하고 Use Case 1에 기반해 URL을 설정하고 \"스크롤, 몇 초 대기한 후 다시 스크롤\" 이동 순서를 다음과 같이 지정합니다.\n\n<div class=\"content-ad\"></div>\n\n```python\noptions = webdriver.ChromeOptions()\noptions.add_argument('--headless')\ndriver = webdriver.Chrome(executable_path=r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe', chrome_options=options)\nurl_acne = \"https://www.acnestudios.com/au/en/search?q=bags\"\nprint(url_acne)\ndriver.get(url_acne)\ntime.sleep(2)  # 웹 페이지가 열리기까지 2초 기다립니다\nscroll_pause_time = 2  # 웹 페이지 로딩을 위해 2초 기다립니다\n\nscreen_height = driver.execute_script(\"return window.screen.height;\")  # 웹의 화면 높이 가져오기\ni = 1\nwhile True:\n   # 한 화면 높이씩 스크롤\n   driver.execute_script(\"window.scrollTo(0, {screen_height}*{i});\".format(screen_height=screen_height, i=i))\n   i += 1\n   time.sleep(scroll_pause_time)\n   # 각 스크롤 후 스크롤 높이 업데이트\n   scroll_height = driver.execute_script(\"return document.body.scrollHeight;\")\n   # 웹 페이지의 끝에 도달하면 루프 종료\n   if (screen_height) * i > scroll_height:\n       break\n```\n\nInfinite Scroll의 최하단에 도달했을 때, HTML 코드를 저장하고 Use Case 1과 동일한 방법으로 데이터를 다운로드할 수 있습니다. 이번 유스케이스에서는 각 핸드백의 설명, 가격 및 이미지 URL을 다운로드할 것입니다.\n\n```python\ndescription = []\nprice = []\nurl = []\nsoup = BeautifulSoup(driver.page_source, \"html.parser\")\nfor desc in soup.find_all(class_=\"product-tile__name\"):\n    \n    description.append(desc.get_text(strip=True))\n    \nfor desc in soup.find_all(class_=\"product-tile__price font--monospace\"):\n    \n    price.append(desc.get_text(strip=True))\n    \nfor item in soup.find_all(class_=\"tile__link\"):\n    \n    base = \"https://www.acnestudios.com/\"\n    link = item.attrs[\"href\"]\n    url_join = urljoin(base, link)\n    \n    url.append(url_join)\n## pandas 데이터프레임으로 변환\ndf_acne = pd.DataFrame(\n                        {\n                         'Description': description,\n                         'Price': price,\n                         'URL': url\n                        })\ndf_acne\n```\n\n데이터프레임 결과 샘플은 아래와 같습니다. Infinite Scroll이 없었다면 데이터프레임에는 아마 10개 정도의 기록만 포함되었을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_4.png\" />\n\n# 사용 사례 3: 이미지 스크래핑\n\n이미지 스크래핑은 웹사이트에 호스팅된 이미지를 다운로드하고 로컬 컴퓨터에 체계적으로 저장하는 자동화를 의미합니다. 이는 다음과 같은 이유로 유용할 수 있습니다:\n\n- 웹사이트에서 게시된 이미지가 나중에 제거될 수 있음\n- 다운로드한 이미지는 오프라인에서 다시 확인할 수 있음 (즉, 인터넷 없이)\n- 다운로드한 이미지는 더 포괄적인 방식으로 확인할 수 있음 (예: 특정 순서로 또는 명명 규칙에 따라)\n\n<div class=\"content-ad\"></div>\n\n이 사용 사례를 보여 주기 위해, MangaPark 웹 사이트에서 Manga 시리즈 아래의 모든 이미지를 스크랩하겠습니다. 개인 컴퓨터에 전체 Manga가 저장되어 있으면, 온라인에서 각 장에 대한 \"다음\" 버튼을 클릭하고 여러 개의 온라인 광고를 만나는 대신 Manga 페이지를 편리하게 넘길 수 있습니다.\n\n사용 사례 1과 2와 동일한 Python 라이브러리를 사용하여, 우리는 한 장의 이미지를 스크랩하기 위해 시작하고 For-Loop를 사용하여 다른 장의 이미지까지 스크랩해가는 작업을 확장합니다. 일본 Manga 시리즈 \"H2\"의 첫 번째 장에서:\n\n```js\nurl = \"https://v2.mangapark.net/manga/h2/i294558/c1\"\nprint(url)\noptions = webdriver.ChromeOptions()\noptions.add_argument('--headless')\ndriver = webdriver.Chrome( \n                          executable_path = r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe',\n                          chrome_options = options\n                         )\ndriver.get(url)\nsoup = BeautifulSoup(driver.page_source, 'html')\n## 장의 이미지 수는 다양하며, 오류 처리 덕분에\n## 인덱스 오류 없이 최대 50개까지 다운로드 가능함\n## 이미지는 시간순으로 H2 폴더에 저장됨\n## Python 스크립트가 저장된 경로에 저장됨\ntry:\nfor i in range(50):    \n        urllib.request.urlretrieve(str(soup.find_all(class_ = \"img\")[i].attrs[\"src\"]),\n                               \"H2/\" + str(i) + \".jpg\".format(i))\nexcept:\n    pass\n```\n\n위의 작업을 완료하면, \"다음\" 페이지의 URL을 찾고 위의 스크래핑을 반복하는 문제로 전환됩니다. 이 작업은 다음과 같이 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nurl = \"https://v2.mangapark.net/manga/h2/i294558/c1\"\nchapter_number = 338\nfor j in range(1, upper_limit + 1):\n      \n    print(url)\n    options = webdriver.ChromeOptions()\n    options.add_argument('--headless')\n    driver = webdriver.Chrome(\n                              executable_path = r'C:\\Users\\Jin\\Documents\\Webscraping\\Drivers\\chromedriver.exe',\n                              chrome_options = options\n                             )\n    driver.get(url)\n    soup = BeautifulSoup(driver.page_source, 'html')\ntry:\nfor i in range(50):    \n            urllib.request.urlretrieve(str(soup.find_all(class_ = \"img\")[i].attrs[\"src\"]),\n                                   \"H2/\" + str(j) + \"_\" + str(i) + \".jpg\".format(i))\nexcept: ## number of pictures may vary on a webpage\n        pass\n## 아래는 \"다음\" 페이지를 위한 URL을 찾습니다.\nbase_url = \"https://v2.mangapark.net/\"\n    next_page = soup.find_all(\"a\", href = True)[12].get(\"href\")\nurl = urljoin(base_url, next_page)\n```\n\n지금은 차 한 잔과 함께 H2 만화를 즐겨보세요! 정말 재미있어요.\n\n# 결론\n\n이 기사에서는 실행 가능한 코드로 웹 스크래핑의 세 가지 사용 사례를 소개했습니다. 이러한 사용 사례들은 쉽게 확장하여 웹사이트의 HTML 코드가 가지고 있는 추가 속성을 포함시킬 수 있습니다. 독자들이 자세히 살펴보면 됩니다!\n\n<div class=\"content-ad\"></div>\n\n다음으로, 행위 보험사/데이터 과학자 모자를 쓰고, 경쟁 업체 웹사이트의 변경 사항을 모니터링하거나 리뷰 웹사이트에서 고객의 긍정적/부정적 댓글을 스크래핑하는 등의 상업 기회를 탐색할 예정입니다. 계속 주목해주세요!","ogImage":{"url":"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_0.png"},"coverImage":"/assets/img/2024-05-01-BuildingaWebScraperforThreeCommonUseCases_0.png","tag":["Tech"],"readingTime":11},{"title":"알아두면 쓸모있는 잘 알려지지 않은 HTML 태그들","description":"","date":"2024-05-01 23:47","slug":"2024-05-01-UnearthingHiddenGemsLesser-KnownHTMLTags","content":"\n\n![UnearthingHiddenGemsLesser-KnownHTMLTags](/assets/img/2024-05-01-UnearthingHiddenGemsLesser-KnownHTMLTags_0.png)\n\n웹 개발의 광활한 풍경 속에서 특정 HTML 태그들이 빛나며 주목을 받고 있습니다. 우리는 모두 `div`, `p`, `a`와 같은 태그를 알고 있지만, 마크업의 미천한 영웅들에 대해 얼마나 알고 계신가요? 함께 HTML의 심연을 탐험하며 주목할 만한 몇 가지 알려지지 않은 보석을 발굴해봅시다.\n\n- `details`와 `summary`: 확장 가능한 콘텐츠\n\n웹페이지에서 보충 정보를 숨겨야 할 때 토글이나 버튼으로 페이지를 혼동시키기만 했던 적이 있나요? `details`와 `summary`가 나타나는 순간입니다. 이러한 태그를 사용하면 쉽게 접어지는 콘텐츠 섹션을 만들 수 있습니다. 콘텐츠를 `details`로 감싸고 `summary` 내에서 간단한 요약을 제공하여 사용자가 한 번의 클릭으로 추가 세부 정보를 공개할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<details>\n  <summary>더 많은 정보를 확인하려면 클릭하세요</summary>\n  <p>여기에 추가 정보가 들어갑니다...</p>\n</details>\n```\n\n2. `time`: 의미론적 시간 표현\n\n날짜와 시간을 수동으로 형식화하는 것은 잊어버리세요. `time`은 대신 그 일을 해 줄 겁니다. 종종 간과되는 이 태그는 날짜와 시간을 의미론적으로 표현하는 방법을 제공하여 접근성과 검색 엔진 최적화를 향상시킵니다. 최대 호환성을 위해 ISO 8601 형식으로 datetime 속성을 지정하세요.\n\n```js\n<p>게시일 <time datetime=\"2024-04-29T08:00:00Z\">2024년 4월 29일</time></p>\n```\n\n<div class=\"content-ad\"></div>\n\n3. `cite`: 간편한 인용\n\n오남용 시대에 올바른 인용은 이제보다 중요합니다. 그러나 많은 사람들이 평범한 텍스트나 이탤릭체 대신 `cite` 태그를 무시합니다. 이 의미 있는 태그로 인용을 더욱 강조하여 작품의 제목이나 저자 이름을 나타내세요.\n\n```js\n<blockquote>\n  <p>\"지식은 힘입니다.\" <cite>프란시스 베이컨</cite></p>\n</blockquote>\n```\n\n4. `mark`: 텍스트 동적 강조\n\n<div class=\"content-ad\"></div>\n\n텍스트를 동적으로 강조하는 것은 적절한 도구 없이는 번거로울 수 있습니다. `mark`가 등장했습니다. 텍스트 일부를 `mark`로 감싸면 강조 효과가 적용되어 검색 결과나 중요한 용어를 강조하는 데 안성맞춤입니다.\n\n```js\n<p>검색 결과: Lorem <mark>ipsum</mark> dolor sit amet...</p>\n```\n\n5. `wbr`: 단어 나누기 기회\n\n복잡한 단어 구조가 있는 언어나 긴 URL에서 올바른 줄 바꿈을 보장하기 위해 `wbr`이 등장합니다. 이 태그는 브라우저에 어디에 줄 바꿈을 삽입해야 하는지 힌트를 줌으로써 가독성을 보장하면서 콘텐츠 무결성을 보존합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<p>중단이 필요한 긴단어<wbr>중단이 필요한 긴단어</p>\n```\n\n6. `fieldset`와 `legend`: 양식 요소 그룹화\n\n사용자 경험을 위해서 양식을 적절하게 구성하는 것이 중요합니다. 그런데 `fieldset`와 `legend`는 종종 눈에 띄지 않는다. `fieldset`를 사용하여 관련된 양식 요소를 함께 그룹화하고 `legend`를 사용하여 해당 그룹에 캡션 또는 제목을 제공하세요. 이렇게 하면 양식이 더 구조화되고 접근성이 향상됩니다.\n\n```js\n<fieldset>\n  <legend>연락 정보</legend>\n  <!-- 여기에 양식 요소를 넣으세요 -->\n</fieldset>\n```\n\n<div class=\"content-ad\"></div>\n\n7. `dialog`: 모달 대화 상자\n\n모달 대화 상자를 만드는 것은 예전에 JavaScript와 CSS를 사용하여 지루한 작업이었습니다. 하지만 걱정하지 마세요, `dialog`가 나타나서 이 프로세스를 간단하게 해 줍니다. 이 태그는 HTML 문서 내에 대화 상자나 창을 정의하여 팝업 알림, 경고 또는 상호 작용 프롬프트를 쉽게 만들 수 있게 합니다.\n\n```js\n<dialog open>\n  <p>이것은 모달 대화 상자입니다!</p>\n  <button onclick=\"this.parentNode.close()\">닫기</button>\n</dialog>\n```\n\n8. `meter`: 스칼라 측정값 시각화\n\n<div class=\"content-ad\"></div>\n\n특정 범위 내에서 측정 값을 표시해야 한다면 `meter`태그를 사용해보세요. 이 태그는 디스크 사용량, 다운로드 진행률 또는 주관적 등급과 같은 알려진 범위 내의 스칼라 측정 값을 나타냅니다. 필요에 맞게 값을, 최소값(min), 최대값(max) 속성을 사용자 정의할 수 있습니다.\n\n```js\n<meter value=\"0.6\" min=\"0\" max=\"1\">60%</meter>\n```\n\n9. `progress`: 작업 진행률 추적\n\n작업 진행률을 추적하는 것은 웹 응용프로그램에서 흔한 요구 사항입니다. `progress`태그를 사용하면 쉽게 할 수 있습니다. 이 태그를 사용하여 파일 업로드, 양식 제출 또는 로딩 화면과 같은 작업의 완료 진행률을 나타낼 수 있습니다. 현재 진행 상황을 나타내기 위해 값(value) 속성을 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n<progress value=\"50\" max=\"100\">50%</progress>\n```\n\n10. `samp`: 샘플 출력\n\n프로그램이나 코드 스니펫의 샘플 출력을 표시할 때 `samp` 태그를 사용하면 의미론적으로 더 좋습니다. 이 태그는 컴퓨터 프로그램에서의 샘플 출력을 나타내어 사용자 입력이나 프로그램 코드와 구분짓습니다.\n\n```js\n<p>출력: <samp>Hello, World!</samp></p>\n```\n\n<div class=\"content-ad\"></div>\n\n11. `abbr`: 약어 및 두문자어\n\n`abbr`를 사용하면 접근성과 명확성을 쉽게 향상시킬 수 있어요. 이 태그를 사용하여 약어와 두문자어를 표시하고, 보조 기술에서 접근 가능한 확장 또는 설명을 제공하세요.\n\n```js\n<p><abbr title=\"Hypertext Markup Language\">HTML</abbr>은 멋져요!</p>\n```\n\n12. `slot`: 콘텐츠 분배\n\n<div class=\"content-ad\"></div>\n\n웹 컴포넌트의 등장으로 `slot`이 점점 더 중요해지고 있어요. 이 태그는 웹 컴포넌트의 템플릿에 동적 콘텐츠를 삽입할 수 있는 자리 표시자를 정의하여 유연한 콘텐츠 배포와 조합을 가능케 해줘요.\n\n```js\n<my-custom-element>\n  <p slot=\"header\">헤더 내용</p>\n  <p slot=\"footer\">푸터 내용</p>\n</my-custom-element>\n```\n\n프로젝트에 종종 간과되는 HTML 태그들을 통합함으로써 기능을 향상시키고 접근성을 개선하며 개발을 더욱 간편하게 할 수 있어요. 기억하세요, HTML의 진정한 힘은 익숙한 태그뿐만 아니라 발견되고 활용되기를 기다리는 숨은 보석들의 가치에 있어요.","ogImage":{"url":"/assets/img/2024-05-01-UnearthingHiddenGemsLesser-KnownHTMLTags_0.png"},"coverImage":"/assets/img/2024-05-01-UnearthingHiddenGemsLesser-KnownHTMLTags_0.png","tag":["Tech"],"readingTime":4}],"page":"151","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":17,"currentPageGroup":7},"__N_SSG":true}