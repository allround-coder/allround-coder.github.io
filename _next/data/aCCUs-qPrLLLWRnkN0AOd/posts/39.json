{"pageProps":{"posts":[{"title":"이전 화면으로 돌아갈 때 데이터 전송하기 React Native","description":"","date":"2024-06-20 05:15","slug":"2024-06-20-PassDataWhenbacktoPreviousScreenReactNative","content":"\n\n리액트 네비게이션에서 navigation.goBack 함수를 사용하면 스택 내비게이터에서 이전 화면으로 돌아갈 수 있어요. 이전 화면으로 돌아갈 때 데이터를 전달하고 싶다면 params 속성과 함께 navigation.goBack 함수를 사용할 수 있어요.\n\n예를 들어:\n\nScreenA와 ScreenB 두 개의 화면이 있다고 가정해봅시다. ScreenA에서 ScreenB로 이동한 다음 ScreenA로 돌아가면서 데이터를 전달하고 싶다면요.\n\nScreenA에서:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React, { useState } from 'react';\nimport { View, Text, Button } from 'react-native';\n\nconst ScreenA = ({ navigation }) => {\n  const [dataFromScreenB, setDataFromScreenB] = useState(null);\n\n  const navigateToScreenB = () => {\n    navigation.navigate('ScreenB', {\n      onGoBack: (data) => {\n        // ScreenB로부터 데이터를 처리하는 콜백 함수\n        setDataFromScreenB(data);\n      },\n    });\n  };\n\n  return (\n    <View>\n      <Text>ScreenB로부터의 데이터: {dataFromScreenB}</Text>\n      <Button title=\"ScreenB로 이동\" onPress={navigateToScreenB} />\n    </View>\n  );\n};\n\nexport default ScreenA;\n```\n\n```js\nimport React, { useState } from 'react';\nimport { View, TextInput, Button } from 'react-native';\n\nconst ScreenB = ({ route, navigation }) => {\n  const [dataToSendBack, setDataToSendBack] = useState('');\n\n  const handleGoBack = () => {\n    // onGoBack 콜백을 사용해 ScreenA로 데이터 전달\n    route.params.onGoBack(dataToSendBack);\n    navigation.goBack();\n  };\n\n  return (\n    <View>\n      <TextInput\n        placeholder=\"데이터 입력\"\n        value={dataToSendBack}\n        onChangeText={(text) => setDataToSendBack(text)}\n      />\n      <Button title=\"데이터와 함께 돌아가기\" onPress={handleGoBack} />\n    </View>\n  );\n};\n\nexport default ScreenB;\n```\n\n이 예시에서:\n- ScreenA는 navigation.navigate를 사용하여 ScreenB로 이동하고 매개변수로 콜백 함수(onGoBack)를 전달합니다.\n- ScreenB는 navigation route에서 콜백 함수를 추출하고 이를 사용하여 되돌아갈 때 ScreenA로 데이터를 전달합니다.\n\n<div class=\"content-ad\"></div>\n\n이 패턴은 navigation.goBack를 사용할 때 자식 화면(ScreenB)에서 부모 화면(ScreenA)로 데이터를 전달할 수 있는 방법입니다. 코드를 귀하의 특정 사용 사례와 데이터 요구 사항에 맞게 조정해주세요.\n\n감사합니다!!!","ogImage":{"url":"/assets/img/2024-06-20-PassDataWhenbacktoPreviousScreenReactNative_0.png"},"coverImage":"/assets/img/2024-06-20-PassDataWhenbacktoPreviousScreenReactNative_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 훅스 소개","description":"","date":"2024-06-20 05:14","slug":"2024-06-20-IntroductiontoReactHooks","content":"\n\n\n\n![React Hooks](/assets/img/2024-06-20-IntroductiontoReactHooks_0.png)\n\n리액트 훅(React Hooks)은 2018년 10월 React Conf에서 소개되었습니다. 이는 함수 컴포넌트에서 상태(state) 및 사이드 이펙트(side-effects)를 사용하는 방법으로, 훅(React Hooks) 이전에 함수 컴포넌트는 상태를 가지지 않고 라이프사이클 메서드를 관리할 수 없어 상태 관련 로직을 처리하기 위해 함수 컴포넌트를 클래스 컴포넌트로 변환해야 했습니다. 하지만 훅(React Hooks)을 사용하면 함수 컴포넌트에서도 상태와 사이드 이펙트를 처리할 수 있어 클래스 컴포넌트를 사용할 필요가 없어졌습니다.\n\n# React Hooks의 필요성\n\n리액트 훅(React Hooks)은 함수 컴포넌트에서 상태 관리와 사이드 이펙트를 도입하기 위해 설계되었습니다. 이를 통해 컴포넌트의 리팩터링을 방지할 수 있게 되었습니다. 훅(React Hooks) 이전에는 상태와 라이프사이클 메서드를 클래스 컴포넌트에서만 사용할 수 있었습니다. 리액트 훅(React Hooks)을 사용하면 이와 같은 불필요한 리팩터링을 방지하며 리액트 애플리케이션을 보다 우아하고 가벼운 방식으로 작성할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n```\n\n```js\nimport React from 'react';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\nexport default Counter;\n```\n\n# 부수효과 로직\n\n클래스 컴포넌트에서는 부수효과를 componentDidMount, componentDidUpdate 및 componentWillUnmount와 같은 라이프사이클 메소드에서 관리했습니다. React Hooks는 useEffect Hook을 사용하여 함수 컴포넌트에서 부수효과를 처리할 수 있도록 해줍니다. useEffect Hook은 설정(setup) 및 정리(cleanup) 단계 모두를 캡슐화합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    // 기능 1을 위한 리스너 추가\n    // 기능 2를 위한 리스너 추가\n  }\n\n  componentWillUnmount() {\n    // 기능 1을 위한 리스너 제거\n    // 기능 2를 위한 리스너 제거\n  }\n\n  ...\n}\n```\n\n```js\nimport React from 'react';\n\nfunction MyComponent() {\n  React.useEffect(() => {\n    // 기능 1을 위한 리스너 추가 (셋업)\n    return () => {\n      // 기능 1을 위한 리스너 제거 (정리)\n    };\n  });\n\n  React.useEffect(() => {\n    // 기능 2를 위한 리스너 추가 (셋업)\n    return () => {\n      // 기능 2를 위한 리스너 제거 (정리)\n    };\n  });\n\n  ...\n}\n```\n\n# React의 추상화 지옥\n\nReact에서의 고급 패턴인 고차 컴포넌트(HOCs) 및 렌더 프롭 컴포넌트는 종종 복잡한 컴포넌트 트리를 유발했습니다. React Hooks는 이를 단순화시켜 함수에 로직을 캡슐화하여 추가 컴포넌트 대신 더 평평한 컴포넌트 트리를 만들어냅니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\nimport { compose, withReducer } from 'recompose';\nimport { withRouter } from 'react-router-dom';\n\nfunction App({ history, state, dispatch }) {\n  return (\n    <ThemeContext.Consumer>\n      {theme => (\n        <Content theme={theme}>\n          ...\n        </Content>\n      )}\n    </ThemeContext.Consumer>\n  );\n}\n\nexport default compose(\n  withRouter,\n  withReducer(reducer, initialState)\n)(App);\n```\n\n```js\nimport React from 'react';\nimport { useTheme } from 'styled-components';\nimport { useRouter } from 'react-router-dom';\n\nfunction App() {\n  const theme = useTheme();\n  const history = useRouter();\n  const [state, dispatch] = React.useReducer(reducer, initialState);\n\n  return (\n    <Content theme={theme}>\n      ...\n    </Content>\n  );\n}\n\nexport default App;\n```\n\n# JavaScript Class Confusion\n\n자바스크립트 클래스는 'this', 클래스 바인딩 및 상속과 같은 개념 때문에 가파른 학습 곡선을 가지고 있습니다. React Hooks는 이러한 복잡성 없이 컴포넌트를 작성할 수 있도록 해주어 React 초심자에게 더 부드러운 학습 곡선을 제공합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  state = { value: 0 };\n\n  onIncrement = () => {\n    this.setState(state => ({\n      value: state.value + 1\n    }));\n  };\n\n  onDecrement = () => {\n    this.setState(state => ({\n      value: state.value - 1\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        {this.state.value}\n        <button onClick={this.onIncrement}>+</button>\n        <button onClick={this.onDecrement}>-</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n```\n\n## React Hooks와 어떻게 다른가요?\n\nReact Hooks는 React의 기본 사항을 변경하지는 않고, 단지 컴포넌트를 작성하는 새로운 방법을 제공합니다. 로컬 상태와 라이프사이클 메소드를 가진 클래스 컴포넌트는 여전히 작동하며, HOCs나 Render Props와 같은 고급 패턴도 유효합니다. React Hooks는 보다 간소화된 함수 컴포넌트를 가능케 함으로써 React의 미래 개발을 단순화하는 API를 추가합니다.\n\n## 다루어진 주제들\n\n\n\n<div class=\"content-ad\"></div>\n\n- 모든 것이 변화합니다: 훅스는 React 애플리케이션을 작성하는 방식을 변화시킬 것이지만 기존의 클래스 컴포넌트는 여전히 작동합니다.\n- React는 덩치가 커지고 있는 중: React는 날씬한 API를 유지하려 노력합니다. 훅스는 미래의 React API를 단순화하는 방향으로 나아가는 한 걸음입니다.\n- 클래스는 잘 작동했습니다: 훅스는 특히 React 초심자들에게 컴포넌트를 작성하는 더 간단한 방법을 제공합니다.\n- 마법 같아요: 훅스는 마법처럼 보일 수 있지만 클래스 컴포넌트와 마찬가지로 React의 내부 업데이트 큐를 활용합니다.\n\n# 일반적인 React 훅 사용하기\n\nuseState 훅은 함수 컴포넌트에서 로컬 상태를 관리하는 데 사용됩니다.\n\n- 예시: 항목 배열 관리하기\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\n\nconst INITIAL_LIST = [\n  { id: '0', title: 'React with RxJS', url: 'https://example.com/rxjs' },\n  { id: '1', title: 'React with Apollo', url: 'https://example.com/apollo' },\n];\n\nfunction App() {\n  const [list, setList] = React.useState(INITIAL_LIST);\n\n  const onRemoveItem = id => {\n    const newList = list.filter(item => item.id !== id);\n    setList(newList);\n  };\n\n  return (\n    <ul>\n      {list.map(item => (\n        <li key={item.id}>\n          <a href={item.url}>{item.title}</a>\n          <button type=\"button\" onClick={() => onRemoveItem(item.id)}>\n            Remove\n          </button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nexport default App;\n```\n\nuseEffect Hook은 함수 컴포넌트에서 사이드 이펙트를 처리하기 위해 사용됩니다.\n\n- 예시: 간단한 스톱워치 구현\n\n```js\nimport React from 'react';\n\nfunction App() {\n  const [isOn, setIsOn] = React.useState(false);\n  const [timer, setTimer] = React.useState(0);\n\n  React.useEffect(() => {\n    let interval;\n\n    if (isOn) {\n      interval = setInterval(() => setTimer(prevTimer => prevTimer + 1), 1000);\n    }\n\n    return () => clearInterval(interval);\n  }, [isOn]);\n\n  return (\n    <div>\n      {timer}\n\n      {!isOn && (\n        <button type=\"button\" onClick={() => setIsOn(true)}>\n          Start\n        </button>\n      )}\n\n      {isOn && (\n        <button type=\"button\" onClick={() => setIsOn(false)}>\n          Stop\n        </button>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 useEffect 훅은 스톱워치가 시작될 때(즉, isOn이 true일 때) 인터벌을 설정하고 스톱워치가 중지될 때(즉, isOn이 false일 때) 인터벌을 정리합니다. 이는 React Hooks를 사용하여 함수 컴포넌트에서 사이드 이펙트를 관리하는 방법을 보여줍니다.\n\n# 결론\n\nReact Hooks는 함수 컴포넌트에서 상태와 사이드 이펙트를 관리하는 강력한 방법을 제공하여 클래스 컴포넌트와 복잡한 추상화가 필요하지 않게 합니다. 특히 초보자에게 React 개발을 간단하고 기능적으로 작성할 수 있도록 돕습니다.\n\n즐거운 학습되세요! 😎","ogImage":{"url":"/assets/img/2024-06-20-IntroductiontoReactHooks_0.png"},"coverImage":"/assets/img/2024-06-20-IntroductiontoReactHooks_0.png","tag":["Tech"],"readingTime":7},{"title":"구글 파이어베이스를 React에서 활용하기","description":"","date":"2024-06-20 05:13","slug":"2024-06-20-MakinguseofGooglefirebaseinReact","content":"\n\n<img src=\"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_0.png\" />\n\n# React에서 Firebase 탐험하기\n\n환영합니다!\n\n저는 Firebase와 React의 흥미로운 세계로 다가가려 합니다. 그래서 Firebase는 무엇일까요? 구글이 제공하는 클라우드 기반 도구함으로 생각해보세요. 개발자로서 우리의 삶을 더 쉽게 만들어주는 도구들로 가득차 있습니다. 이는 우리가 웹 앱/React 앱에 멋진 기능을 추가하기 위해 빠르게 개발할 수 있는 초능력과 같습니다.\n\n<div class=\"content-ad\"></div>\n\nFirebase는 강력한 백엔드 서비스(BaaS) 솔루션이며, 개발자들에게 클라우드 서비스를 쉽게 React 애플리케이션에 통합할 수 있는 기회를 제공합니다.\n\n# 주요 Firebase 기능\n\n## 1. 실시간 데이터베이스 (Firestore)\n\nFirestore는 클라우드 저장소 장치로 생각해보세요. 이것은 실시간으로 데이터를 저장하고 공유할 수 있는 NoSQL 클라우드 데이터베이스입니다. 무언가를 업데이트하면 React 앱을 사용하는 모든 사용자가 수동 새로 고침 없이 즉시 보여주므로 부드럽고 반응이 빠른 사용자 경험을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 2. 인증\n\nFirebase Authentication은 웹/앱을 위한 VIP 목록을 갖는 것과 같습니다. 회원가입, 로그인 및 비밀번호 관리를 처리하여 누가 들어오고 나가는지를 관리하는 데 도움을 줍니다. 보안이 쉬워졌어요!\n\n## 3. 호스팅\n\nFirebase Hosting은 React 애플리케이션을 배포하고 호스팅하기 위한 번거로움 없는 솔루션을 제공합니다. 전 세계 사용자를 위한 빠른 로딩 시간을 위한 글로벌 콘텐츠 전송 네트워크(CDN)를 제공하여 전 세계 사용자에게 원활한 경험을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 4. 클라우드 함수\n\n이것들은 작은 도우미들 같아요. Firebase 클라우드 함수를 사용하면 Firebase 기능에서 트리거된 이벤트에 응답하여 서버 측 코드를 실행할 수 있어요. 이 서버리스 아키텍처는 서버를 관리할 필요 없이 React 애플리케이션에서 백엔드 로직을 실행하는 데 특히 유용할 수 있어요.\n\n## 5. 저장소\n\nFirebase 저장소는 디지털 저장 공간이에요. 이미지와 비디오를 안전하게 보관하여 React 앱에서 미디어를 손쉽게 표시할 수 있도록 도와줘요.\n\n<div class=\"content-ad\"></div>\n\n# React와 Firebase의 우정\n\nReact와 Firebase를 결합하면 마치 호두 버터와 쨈을 섞는 것과 같아요. React는 앱의 외관과 느낌을 다루고(프론트엔드), Firebase는 뒷단 작업을 처리해줘요(백엔드).\n\n액션 준비 완료!\n\n다가오는 레슨에서는 손을 놓지 않을 거예요. 프로젝트 설정부터 React 컴포넌트에서 Firebase 기능을 사용하기까지, 멋진 실시간 및 안전한 애플리케이션을 만들기 위해 준비하세요. 함께 Firebase의 특별 능력을 React 우주에서 발휘해보세요!\n\n<div class=\"content-ad\"></div>\n\n# Firebase와 React를 통합하는 단계별 안내서\n\n## 단계 1: Firebase 계정 설정\n\n시작하기 전에 구글 계정이 있어야 합니다. 계정이 없다면 하나 생성하십시오. Firebase 콘솔로 이동하여 로그인합니다.\n\n## 단계 2: 새 Firebase 프로젝트 생성\n\n<div class=\"content-ad\"></div>\n\n`<img src=\"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_1.png\" />`\n\n\"Create a Project\"을 탭하세요\n\n`<img src=\"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_2.png\" />`\n\n프로젝트에 제목을 입력하고 두 개의 상자를 체크하세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_3.png\" />\n\n이 프로젝트에서는 GOOGLE ANALYSIS를 사용하지 않을 것이므로 내 것을 비활성화했습니다. 여러분은 본인 것을 비활성화할지 여부를 결정할 수 있습니다.\n그런 다음 \"CREATE PROJECT\"를 클릭하세요.\n\n## 단계 3: 실시간 데이터베이스 설정\n\nReal-time database. Firebase 콘솔에서 \"Build\" 쪽으로 이동한 후 \"Realtime Database\"를 선택하세요. \"Create Database\"를 클릭하고 위치를 선택하세요. 간편함을 위해 테스트 모드에서 시작하세요.\n원하는 대로 나중에 바꿀 수 있는 형식으로 콘솔을 편집하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_4.png)\n\n## 단계 4: Firebase 구성\n\n프로젝트 대시보드에서 톱니바퀴 아이콘을 클릭한 후 \"프로젝트 설정\"을 선택합니다. \"일반\" 탭에서 아래로 내려가서 \"앱\"을 클릭한 후 웹 아이콘(`/`)을 클릭하세요. 프로젝트 이름을 작성하고 npm을 사용하여 제공된 구성 스니펫을 복사하세요.\n\n## 단계 5: React 앱 생성\n\n<div class=\"content-ad\"></div>\n\n터미널을 열고 다음을 실행해보세요:\n\n```js\nnpx create-react-app my-firebase-app\ncd my-firebase-app\n```\n\n## 단계 6: React 앱에 Firebase 설치하기\n\n프로젝트 디렉토리에서 Firebase 종속성을 설치하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install firebase\n```\n\n## 단계 7: React 애플리케이션 실행하기\n\n터미널에서 다음 명령을 실행하세요:\n\n```js\nnpm start\n```\n\n<div class=\"content-ad\"></div>\n\n만약 기본 브라우저에서 자동으로 열리지 않는 경우 http://localhost:3000을 방문하여 React 앱이 어떻게 작동하는지 확인할 수 있습니다.\n\n## 단계 8: React 앱에서 Firebase 구성하기\n\n“configuration.jsx” 파일을 생성하고 Step 4에서 Firebase 구성을 복사하여 src/index.js 파일에 붙여넣으세요.\n\n```js\n// 필요한 Firebase 모듈 가져오기\nimport { initializeApp } from \"firebase/app\";\n\n// 여기에 Firebase 구성 추가\nconst firebaseConfig = {\n  apiKey: \"YOUR_API_KEY\",\n  authDomain: \"YOUR_AUTH_DOMAIN\",\n  projectId: \"YOUR_PROJECT_ID\",\n  storageBucket: \"YOUR_STORAGE_BUCKET\",\n  messagingSenderId: \"YOUR_MESSAGING_SENDER_ID\",\n  appId: \"YOUR_APP_ID\",\n};\n\n// Firebase 초기화\nconst cong = initializeApp(firebaseConfig);\n\nexport default cong;\n// 이제 React 앱에서 Firebase 서비스를 사용할 수 있습니다!\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 9: React 구성 요소에서 데이터베이스 사용하기\n\n예를 들어, App.js 파일에서 데이터를 가져와서 표시하는 방법입니다.\n파일에서 기본 코드를 제거하고 아래 코드로 대체하세요.\n\n```js\nimport React, { useEffect, useState } from \"react\";\nimport cong from \"./configuration\"; // 구성 파일의 올바른 경로를 가정\nimport { getDatabase, ref, onValue } from \"firebase/database\";\n\n// App.js\n\nfunction App() {\n  const [data, setData] = useState([]);\n\n  useEffect(() => {\n    // 제공된 구성으로 Firebase 데이터베이스를 초기화합니다\n    const database = getDatabase(cong);\n    \n    // 데이터베이스의 특정 컬렉션에 대한 참조\n    const collectionRef = ref(database, \"your_collection\");\n\n    // 데이터베이스에서 데이터를 가져오는 함수\n    const fetchData = () => {\n      // 컬렉션의 변경 사항을 수신대기\n      onValue(collectionRef, (snapshot) => {\n        const dataItem = snapshot.val();\n\n        // 데이터가 있는지 확인\n        if (dataItem) {\n          // 객체 값을 배열로 변환\n          const displayItem = Object.values(dataItem);\n          setData(displayItem);\n        }\n      });\n    };\n\n    // 컴포넌트가 마운트될 때 데이터를 가져옵니다\n    fetchData();\n  }, []);\n\n  return (\n    <div>\n      <h1>데이터베이스에서 가져온 데이터:</h1>\n      <ul>\n        {data.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n브라우저를 확인하면 데이터베이스 콘솔에 나열된 항목과 일치하는 내용이 표시됩니다.\n\n![Google Firebase in React](/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_5.png)\n\n데이터베이스에 새 항목을 추가하고 실시간 업데이트를 확인하며 경험을 향상시켜보세요. 항목을 더 복잡하게 만들어 보거나 코드를 조정하여 콘솔에 이러한 변화를 반영하고, 원하는대로 프레젠테이션을 스타일링하여 창의력을 발휘해보세요. 가능성은 여러분이 탐험할 수 있도록 열려 있습니다!","ogImage":{"url":"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_0.png"},"coverImage":"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 API 가져오기 다섯 가지 방법으로 프로세스 간소화하기","description":"","date":"2024-06-20 05:12","slug":"2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods","content":"\n\n\n![image](/assets/img/2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods_0.png)\n\n# 소개\n\nAPI에서 데이터를 가져오는 것은 현대 웹 애플리케이션에 필수적입니다. React에서는 페이지 전체를 새로 고침하지 않고 콘텐츠를 로드하고 표시할 수 있습니다. 이 블로그에서는 API 가져오기 및 React에서 이를 수행하는 다섯 가지 쉬운 방법을 설명하겠습니다.\n\nAPI 가져오기 설명\n\n\n<div class=\"content-ad\"></div>\n\nAPI(Application Programming Interface)는 요청을 보내고 응답을 받습니다. 앱이 데이터를 요청하면, API가 데이터베이스에서 가져와 다시 전송합니다. 이 과정은 실시간으로 이루어지며, 페이지를 새로 고침할 필요가 없습니다.\n\n데이터 가져오기는 API에서 정보를 가져와 앱의 프론트엔드로 보내는 것을 의미합니다. React에서는 다음을 사용하여 데이터를 가져올 수 있습니다:\n\n- Fetch\n- Async/Await\n- Promises\n- Callbacks\n- Axios\n\n# 1. Fetch\n\n<div class=\"content-ad\"></div>\n\n자바스크립트의 fetch 함수를 사용하면 네트워크 요청을 할 수 있어요. 이 함수는 응답(response)을 반환하는 프로미스를 리턴하는데, 그 후에 이를 JSON으로 변환할 수 있어요.\n\n예시:\n\n```js\n// Fetch API 사용하기\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('데이터 가져오는 중 오류 발생:', error));\n```\n\n# 2. Async/Await\n\n<div class=\"content-ad\"></div>\n\n비동기/대기는 프로미스를 처리하는 더 간단한 방법입니다. 이를 사용하면 동기 코드처럼 보이는 비동기 코드를 작성할 수 있습니다.\n\n예시:\n\n```js\n// async/await 사용\nconst fetchData = async () => {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  }\n};\n\nfetchData();\n```\n\n# 3. 프로미스\n\n<div class=\"content-ad\"></div>\n\n약속은 비동기 작업을 처리할 수 있게 해줍니다. .then()과 .catch()를 연결하여 응답과 에러를 관리할 수 있어요.\n\n예시:\n\n```js\n// Promises 사용\nconst fetchData = () => {\n  fetch('https://api.example.com/data')\n    .then(response => response.json())\n    .then(data => console.log(data))\n    .catch(error => console.error('데이터를 가져오는 중 오류 발생:', error));\n};\n\nfetchData();\n```\n\n# 4. 콜백(callbacks)\n\n<div class=\"content-ad\"></div>\n\n콜백은 나중에 실행되도록 다른 함수에 전달된 함수입니다. 데이터를 가져오는 데는 복잡하기 때문에 자주 사용되지 않습니다.\n\n예시:\n\n```js\n// 콜백 사용\nconst fetchData = (callback) => {\n  fetch('https://api.example.com/data')\n    .then(response => response.json())\n    .then(data => callback(null, data))\n    .catch(error => callback(error, null));\n};\n\n\nfetchData((error, data) => {\n  if (error) {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  } else {\n    console.log(data);\n  }\n});\n```\n\n# 5. Axios\n\n<div class=\"content-ad\"></div>\n\nAxios는 HTTP 요청을 보다 간편하게 만들어주는 라이브러리로, async/await와 유사하게 작동하지만 더 많은 기능을 제공합니다.\n\n예시:\n\n```js\n// Axios 사용\nimport axios from 'axios';\n\nconst fetchData = async () => {\n  try {\n    const response = await axios.get('https://api.example.com/data');\n    console.log(response.data);\n  } catch (error) {\n    console.error('데이터를 불러오는 중 오류가 발생했습니다:', error);\n  }\n};\n\nfetchData();\n```\n\n맺음말\n\n<div class=\"content-ad\"></div>\n\nReact에서 데이터를 가져오는 간단한 방법들을 소개해 드렸어요. 각 방법마다 장단점이 있으니, 자신에게 가장 잘 맞는 방법을 선택할 수 있어요. 이러한 방법들을 알고 있으면 API를 효과적으로 다루고 동적인 React 애플리케이션을 만들 수 있을 거에요.","ogImage":{"url":"/assets/img/2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods_0.png"},"coverImage":"/assets/img/2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트에서 권한 기반 인증 및 권한 부여 - 인증 핸들러로 특정 권한 및 익명 인증 페이지","description":"","date":"2024-06-20 05:11","slug":"2024-06-20-Role-BasedAuthorizationandAuthenticationinReactwithAuthHandlersSpecificrole-basedandanonymousauthpages","content":"\n\nRole-based 인가 및 인증은 React 애플리케이션을 안전하게 유지하기 위해 사용자 역할에 따라 애플리케이션의 다른 부분에 대한 액세스를 제어하는 데 필수적입니다. 인증 핸들러를 사용하여 인증 및 권한 부여 논리를 관리할 것입니다.\n\n.Net Core와 유사한 구현은 다음에서 확인할 수 있습니다: https://medium.com/@siva.veeravarapu/role-based-authorization-in-net-core-a-beginners-guide-with-code-snippets-b952e5b952f7\n\nDotNet-FullStack-Dev와 함께 지속적인 학습과 탐험의 여정을 떠나보세요. 더 많은 정보를 알아보려면 저희 블로그 https://dotnet-fullstack-dev.blogspot.com 를 방문해 주세요.\n\n## 단계 1: 인증 컨텍스트 설정하기\n\n<div class=\"content-ad\"></div>\n\n사용자 인증 상태를 관리하고 구성 요소에 인증 방법을 제공하는 Authentication Context를 만들어보세요.\n\nAuthContext.js:\n\n```js\nimport React, { createContext, useContext, useState } from 'react';\n\nconst AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n\n  const login = (userData) => {\n    // 여기에 로그인 로직을 구현합니다 (예: API 호출)\n    setUser(userData);\n  };\n\n  const logout = () => {\n    // 여기에 로그아웃 로직을 구현합니다\n    setUser(null);\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, login, logout }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n```\n\n## 단계 2: 인증 구성 요소 구현\n\n<div class=\"content-ad\"></div>\n\n로그인, 로그아웃 및 보호된 경로용 구성 요소를 작성하십시오.\n\nLogin.js:\n\n```js\nimport React, { useState } from 'react';\nimport { useAuth } from './AuthContext';\n\nconst Login = () => {\n  const { login } = useAuth();\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleLogin = () => {\n    // 로그인 로직 구현 (예: AuthContext에서 로그인 메서드 호출)\n    login({ username, password });\n  };\n\n  return (\n    <div>\n      <input type=\"text\" value={username} onChange={(e) => setUsername(e.target.value)} />\n      <input type=\"password\" value={password} onChange={(e) => setPassword(e.target.value)} />\n      <button onClick={handleLogin}>로그인</button>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\nimport { useAuth } from './AuthContext';\n\nconst Logout = () => {\n  const { logout } = useAuth();\n\n  const handleLogout = () => {\n    // 로그아웃 로직 구현 (예: AuthContext에서 logout 메서드 호출)\n    logout();\n  };\n\n  return (\n    <div>\n      <button onClick={handleLogout}>로그아웃</button>\n    </div>\n  );\n};\n\nexport default Logout;\n```\n\nProtectedRoute.js:\n\n```js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useAuth } from './AuthContext';\n\nconst ProtectedRoute = ({ component: Component, roles, ...rest }) => {\n  const { user } = useAuth();\n\n  return (\n    <Route {...rest} render={(props) => {\n      if (!user) {\n        return <Redirect to='/login' />;\n      }\n\n      if (roles && !roles.includes(user.role)) {\n        return <Redirect to='/' />;\n      }\n\n      return <Component {...props} />;\n    } />\n  );\n};\n\nexport default ProtectedRoute;\n```\n\n## 단계 3: 인증 컴포넌트 사용하기\n\n\n<div class=\"content-ad\"></div>\n\n애플리케이션 루트에서 인증 구성요소를 사용하세요.\n\nApp.js:\n\n```js\nimport React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport { AuthProvider } from './AuthContext';\nimport Login from './Login';\nimport Logout from './Logout';\nimport ProtectedRoute from './ProtectedRoute';\nimport Home from './Home';\nimport AdminDashboard from './AdminDashboard';\n\nconst App = () => {\n  return (\n    <AuthProvider>\n      <Router>\n        <Switch>\n          <Route path='/login' component={Login} />\n          <Route path='/logout' component={Logout} />\n          <ProtectedRoute path='/admin' component={AdminDashboard} roles={['admin']} />\n          <ProtectedRoute path='/' component={Home} />\n        </Switch>\n      </Router>\n    </AuthProvider>\n  );\n};\n\nexport default App;\n```\n\n리액트 애플리케이션에서 역할 기반의 접근 제어를 갖는 About 및 Contact 페이지를 추가하는 방법에 대해, 추가 구성요소와 라우트로 확장할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## About 및 Contact 컴포넌트 구현\n\nAbout.js:\n\n```js\nimport React from 'react';\n\nconst About = () => {\n  return (\n    <div>\n      <h1>About Us</h1>\n      <p>Welcome to our website!</p>\n    </div>\n  );\n};\n\nexport default About;\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\n\nconst Contact = () => {\n  return (\n    <div>\n      <h1>Contact Us</h1>\n      <p>You can reach us via email or phone.</p>\n    </div>\n  );\n};\n\nexport default Contact;\n```\n\n## Update ProtectedRoute Component\n\nProtectedRoute.js:\n\n```js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useAuth } from './AuthContext';\n\nconst ProtectedRoute = ({ component: Component, roles, ...rest }) => {\n  const { user } = useAuth();\n\n  return (\n    <Route {...rest} render={(props) => {\n      if (!user) {\n        return <Redirect to='/login' />;\n      }\n\n      if (roles && !roles.includes(user.role)) {\n        return <Redirect to='/' />;\n      }\n\n      return <Component {...props} />;\n    }} />\n  );\n};\n\nexport default ProtectedRoute;\n```\n\n<div class=\"content-ad\"></div>\n\n## App 컴포넌트 및 라우팅 업데이트\n\nApp.js:\n\n```js\nimport React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport { AuthProvider } from './AuthContext';\nimport Login from './Login';\nimport Logout from './Logout';\nimport ProtectedRoute from './ProtectedRoute';\nimport Home from './Home';\nimport AdminDashboard from './AdminDashboard';\nimport About from './About';\nimport Contact from './Contact';\n\nconst App = () => {\n  return (\n    <AuthProvider>\n      <Router>\n        <Switch>\n          <Route path='/login' component={Login} />\n          <Route path='/logout' component={Logout} />\n          <ProtectedRoute path='/admin' component={AdminDashboard} roles={['admin']} />\n          <ProtectedRoute path='/about' component={About} roles={['user', 'admin']} />\n          <Route path='/contact' component={Contact} />\n          <ProtectedRoute path='/' component={Home} />\n        </Switch>\n      </Router>\n    </AuthProvider>\n  );\n};\n\nexport default App;\n```\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n이 가이드에 따라 React 함수형 컴포넌트에서 인증 핸들러를 사용하여 역할 기반 인가 및 인증을 구현할 수 있습니다. 이 방법은 React 애플리케이션을 안전하게 보호하기 위한 유연하고 확장 가능한 솔루션을 제공합니다. 다양한 인증 및 권한 부여 전략을 실험하여 애플리케이션의 특정 요구 사항을 충족시킬 수 있습니다.\n\n이 방법을 통해 'About' 페이지에 대한 역할 기반의 액세스 제어와 'Contact' 페이지에 대한 무제한 액세스를 보장할 수 있습니다. 애플리케이션의 요구 사항에 따라 역할과 권한을 조정해주세요.","ogImage":{"url":"/assets/img/2024-06-20-Role-BasedAuthorizationandAuthenticationinReactwithAuthHandlersSpecificrole-basedandanonymousauthpages_0.png"},"coverImage":"/assets/img/2024-06-20-Role-BasedAuthorizationandAuthenticationinReactwithAuthHandlersSpecificrole-basedandanonymousauthpages_0.png","tag":["Tech"],"readingTime":7},{"title":"데스크톱에서 모바일 UI 검사 마스터하기 단계별 가이드","description":"","date":"2024-06-20 05:10","slug":"2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide","content":"\n\n![이미지](/assets/img/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide_0.png)\n\n소개:\n데스크톱에서 모바일 UI 검사 여정을 시작하는 것은 웹 개발자에게 판을 뒤집는 일일 수 있습니다. 오늘은 Chrome Inspect를 활용하여 모바일 브라우저 테스트 프로세스를 간소화하는 단계별 안내서를 공유해 드리겠습니다. 바로 시작해 보죠!\n\n단계 1: 모바일 장치에서 USB 디버깅 활성화 먼저, 모바일 장치에서 USB 디버깅이 활성화되어 있는지 확인하세요. 이 설정을 통해 장치가 USB 연결을 통해 데스크톱과 통신할 수 있게 됩니다.\n[이미지](https://tenor.com/blXOu.gif)\n\n단계 2: 모바일 장치를 데스크톱에 연결 USB 케이블을 사용하여 모바일 장치와 데스크톱을 연결하세요. 연결되면 장치에서 USB 디버깅을 허용할 지 여부를 확인하는 메시지가 표시될 것입니다. 허용하고 계속 진행하세요.\n\n<div class=\"content-ad\"></div>\n\n### 단계 3: 데스크탑에서 크롬 실행\n데스크탑에서 Google Chrome을 열고 휴대폰에서 검사하려는 웹 페이지로 이동합니다.\n\n### 단계 4: 크롬 검사 열기\n크롬 브라우저의 주소 표시줄에 chrome://inspect를 입력하고 Enter 키를 누르세요. 이렇게 하면 크롬 검사 페이지가 열립니다.\n\n![이미지](/assets/img/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide_1.png)\n\n### 단계 5: 모바일 장치 확인\n크롬 검사 페이지의 \"장치\" 섹션에서 연결된 모바일 장치가 표시됩니다. 장치 이름 옆의 \"검사\" 버튼을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n**단계 6:** 모바일 UI 요소 살펴보기! 이제 데스크톱 화면에서 기기의 모바일 브라우저 인터페이스를 확인할 수 있어요. 모바일 기기에서 표시된 웹 페이지 요소들을 탐험해보세요.\n\n**단계 7:** 실시간으로 CSS 검사 및 수정하기 크롬 검사를 통해 실시간으로 CSS 속성을 검사하고 수정할 수 있어요. 웹 페이지의 요소 중 하나를 마우스 오른쪽 버튼으로 클릭하고 컨텍스트 메뉴에서 \"검사\"를 선택하세요. 이렇게 하면 개발자 도구 패널이 열리며 CSS 스타일을 확인하고 조작할 수 있어요.\n\n**단계 8:** 디버깅이 쉽습니다 모바일 웹 페이지에서 레이아웃 불일치나 스타일링 문제를 식별하고 개발자 도구 패널을 사용하여 실시간으로 조정할 수 있어요. 여백을 조정하거나 글꼴 크기를 조절하거나 색상을 미세하게 조정하는 등 필요한 조정이 필요할 때 크롬 검사를 통해 정밀하게 디버깅할 수 있어요.\n\n**단계 9:** 변경 사항 저장 및 적용 필요한 수정 사항을 완료했다면 변경 사항을 개발자 도구 패널에서 직접 저장할 수 있어요. 변경 사항을 실시간으로 웹 페이지에 적용하려면 \"저장\" 버튼을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n제 10 단계: 반응성 및 기능 테스트 마무리하기 전에 검사를 마무리하기 전에 다양한 화면 크기에서 웹 페이지의 반응성과 기능을 테스트하는 것을 잊지 마세요. Chrome Inspect를 사용하면 다른 기기 해상도를 시뮬레이트하여 사용자 경험을 원활하게 만들 수 있습니다.\n\n결론:\n\nChrome Inspect를 사용하여 데스크톱에서 모바일 UI 검사의 기술을 마스터한 것을 축하합니다! 이 단계별 가이드를 따라가면 웹 개발 워크플로를 혁신할 강력한 도구를 활용할 수 있습니다. 가능성을 받아들이고 다양한 기술을 실험하며 Chrome Inspect로 디버깅 능력을 향상시키세요.\n\nBaby Wolf Codes에게 심층적인 비디오 튜토리얼을 제공해준 특별한 감사를 표합니다. 여기에서 튜토리얼을 시청할 수 있습니다. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트를 배우기 전에 반드시 알아야 할 JavaScript ES6 기능들","description":"","date":"2024-06-20 05:09","slug":"2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact","content":"\n\n## React를 배우기 전에 이 개념들을 꼭 익히세요\n\n![JavaScript ES6 Features](/assets/img/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact_0.png)\n\nReact를 배우려는 경우, 당연히 JavaScript 기본 개념을 이해해야 합니다.\n\nReact는 또한 많은 ES6 개념을 사용하는데, 이미 알고 있어야 합니다. 이 튜토리얼에서는 React를 배우기 전에 꼭 알아야 할 가장 흔히 사용되는 ES6 기능을 다룰 것입니다. 이러한 개념을 학습하고 이해하는 것은 React 여행을 즐겁고 원할하게 만들어줄 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 템플릿 리터럴\n\nES6는 문자열 작업을 쉽게 만들어주었습니다. 문자열을 더하기(+) 기호로 연결하는 대신, 템플릿 문자열은 더 간단한 방법을 제공합니다.\n\n```js\n// 문자열 연결하는 예전 방법\nfunction sumNumbers(a, b) {\n  return \"The sum of \" + a + \" and \" + b + \" is \" + (a + b);\n}\n// 템플릿 리터럴 사용\nfunction sumNumbers(a, b) {\n  return `The sum of ${a}  and ${b} is ${a + b}`;\n}\n```\n\n템플릿 리터럴은 여러 줄 문자열을 다루는 것을 더 쉽게 만들어줍니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst multiLineString = `\n  Lorem ipsum dolor sit amet,\n  consectetur adipiscing elit.\n  Sed do eiusmod tempor incididunt\n  ut labore et dolore magna aliqua.\n`;\n\n``` \n\n# 화살표 함수\n\n화살표 함수를 사용하면 코드를 더 간결하게 만들 수 있어요. 일반 함수와 화살표 함수의 차이를 살펴봅시다.\n\n```js\n// 일반 함수\nfunction myFunction() {\n  // 표현식 또는 문장\n}\n// 화살표 함수\nconst myArrowFunction = () => {\n  // 표현식 또는 문장\n};\n```  \n\n<div class=\"content-ad\"></div>\n\n화살표 함수를 사용하면 function 키워드 대신 뚱뚱한 화살표(=>)를 사용하여 코드를 더 간결하게 만들 수 있어요.\n\n화살표 함수가 단일 표현식을 반환한다면 중괄호와 return 키워드를 생략할 수 있어요.\n\n화살표 함수가 단일 매개변수를 가진다면 매개변수 주위의 괄호를 생략할 수 있어요.\n```js\n// 명시적 반환 단일 표현식\nconst add = (a,b) => a + b;\n\n// 하나의 인수를 가져오는 경우 괄호를 생략해도 돼요\nconst squared = a => a * a;\n``` \n\n<div class=\"content-ad\"></div>\n\n화살표 함수는 map(), filter(), forEach()와 같은 배열 메소드에서 일반적으로 사용됩니다.\n\n```js\nconst names = [\"Carol\", \"jane\", \"alice\"];\nconst capitalizedNames = names.map((name) => name.toUpperCase());\nconsole.log(capitalizedNames);\n\n//출력  // [ 'CAROL', 'JANE', 'ALICE' ]\n```\n\n위의 예시에서 보듯이, 우리는 하나의 인자만 전달하므로 괄호를 생략했습니다.\n\n# 객체 해체화\n\n<div class=\"content-ad\"></div>\n\nJavaScript에서의 구조 분해는 배열에서 값이나 객체의 속성을 개별 변수로 푸는 과정을 말합니다. 이는 데이터베이스나 API와 같이 복잡한 데이터 구조를 다룰 때 유용합니다.\n\n예를 들어, 간단한 고양이를 설명하는 객체가 있다고 가정해봅시다.\n\n```js\nconst cat = {\n  catName: 'Whiskers',\n  age: 3,\n  color: 'gray',\n  breed: 'Persian'\n};\n```\n\n고양이의 이름을 얻기 위해서는 보통 점 표기법이나 대괄호 표기법을 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nconst cat = {\n  catName: \"Whiskers\",\n  age: 3,\n  color: \"gray\",\n  breed: \"Persian\",\n};\n\n// console.log(cat.catNname)\n```\n\nHowever, with object destructuring, you can unpack the properties into variable names and assign them to the cat object like this:\n\n```js\nconst { catNname, age, color, breed } = cat;\nconsole.log(`My cat ${catNname} is ${age} moths old`)\n```\n\nThe output will be:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n내 고양이 'Whiskers'는 3개월입니다.\n```\n\n# 배열 해체\n\n배열 해체는 객체 해체와 유사합니다. 직원 배열이 있다고 가정해봅시다:\n\n```js\nconst employees = [\n    'Carol kristen deck ',\n    'john weber Smith',\n    'Alice k Johnson'\n];\n```\n\n<div class=\"content-ad\"></div>\n\n직원 목록에서 1번 인덱스의 직원을 가져오려면 다음과 같이 할 수 있어요:\n\n```js\nemployees[1]\n```\n\n하지만 구조 분해를 사용하면 값을 이렇게 변수에 풀어낼 수 있어요:\n\n```js\nconst employees = [\n  \"Carol kristen deck \",\n  \"john weber Smith\",\n  \"Alice k Johnson\",\n];\n\nconst [E1, E2, E3] = employees;\n```\n\n<div class=\"content-ad\"></div>\n\nE1은 배열의 첫 번째 직원의 값이 되고, E2는 두 번째 직원의 값이 되는 식으로 진행됩니다. 만약 배열에서 첫 번째 직원만 필요하다면, 아래와 같이 나머지 부분을 비워두면 됩니다:\n\n```js\nconst [E1, ,] = employees;\nconsole.log(E1); \n// Carol kristen deck\n```\n\n# 객체 리터럴\n\n객체 리터럴을 사용하면 객체를 작성할 때 중복을 피할 수 있습니다. 예를 들어, 아래와 같은 Task 함수 생성자를 가진 경우를 생각해보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n기본 형식보다 더 짧게 ES6 객체 리터럴로 작성할 수 있어요. 아래와 같이 써보세요;\n\nfunction Task(title, description, priority) {\n  return {\n    title,\n    description,\n    priority,\n  };\n}\n\n# 전개 연산자\n```\n\n<div class=\"content-ad\"></div>\n\n전개 연산자는 iterable 객체의 요소를 전개하는 데 사용됩니다. Iterable 객체에는 배열, 객체 및 문자열이 포함됩니다.\n\n전개 연산자는 요소를 복사, 결합 또는 다른 함수에 인수로 전달하는 데 사용될 수 있습니다. 예를 들어, 배열을 다룰 때 원본 배열을 변경하지 않고 작업해야 할 때, 다음과 같이 전개 연산자를 사용하여 배열의 사본을 만들 수 있습니다:\n\n```js\nconst names = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Ethan\"];\nconst namesCopy = [...names]\nconsole.log(namesCopy)\n```\n\n# 나머지 연산자\n\n<div class=\"content-ad\"></div>\n\n램덤(…) 연산자는 세 개의 점을 사용하며 확산 연산자와 유사합니다. 하지만 램덤 연산자는 함수 매개변수 내에서 여러 인수를 하나의 배열로 수집하는 데 사용됩니다.\n\n예를 들어, 숫자의 합계를 얻는 함수를 작성해야 한다고 가정해보겠습니다. 우리 배열이 무한수의 인수를 가질 수 있는 경우, 램덤 연산자를 사용하여 인수를 배열로 수집할 수 있습니다.\n\n```js\nfunction sumNumbers(...arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n}\n```\n\n그런 다음, 해당 함수를 사용하여 어떤 수의 인수든 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnumbers = [1, 2, 4];\ngrades = [30, 40, 50, 60, 70];\nconsole.log(sumNumbers(...numbers)); // 출력 // 7\nconsole.log(sumNumbers(...grades));   // 출력 // 250\n```\n\n나머지 연산자는 구조 분해 할당에도 사용할 수 있습니다. 예를 들어, 성적 배열의 첫 번째 요소를 추출해야 한다고 가정해보세요. 변수로 추출하고 나머지 요소를 아래와 같이 배열로 수집할 수 있습니다.\n\n```js\ngrades = [30, 40, 50, 60, 70];\nconst [index0, ...arr] = grades;\nconsole.log(math);\n```\n\n# for of 루프\n\n<div class=\"content-ad\"></div>\n\n`for of` 루프는 배열, 문자열, 타입 배열, 맵, 세트 및 NodeList와 같은 반복 가능한 객체의 요소를 반복하는 데 사용됩니다. `for of` 루프의 구문은 다음과 같습니다:\n\n```js\nfor (variable of iterable) {\n  // 각 변수에 대해 실행할 코드\n}\n```\n\n# 배열 순회\n\n```js\nconst currencyCodes = [\"USD\", \"EUR\", \"GBP\", \"JPY\"];\nfor (const code of currencyCodes) {\n  console.log(code);\n}\n// USD\n// EUR\n// GBP\n// JPY\n```\n\n<div class=\"content-ad\"></div>\n\n# 객체 배열을 반복하는 방법\n\n예를 들어, 아래와 같이 여러 객체가 포함 된 배열이 있다고 가정 해 봅시다.\n\n```js\nconst currencies = [\n    { currency: \"US Dollar\", code: \"USD\" },\n    { currency: \"Euro\", code: \"EUR\" },\n    { currency: \"British Pound\", code: \"GBP\" },\n    { currency: \"Japanese Yen\", code: \"JPY\" }\n  ];\n```\n\ncurrencies 배열을 반복하면 각각의 개별 객체를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfor (const currency of currencies) {\n  console.log(currency);\n}\n```\n\n다음은 출력 결과입니다:\n\n```js\n{ currency: 'US Dollar', code: 'USD' }\n{ currency: 'Euro', code: 'EUR' }\n{ currency: 'British Pound', code: 'GBP' }\n{ currency: 'Japanese Yen', code: 'JPY' }\n```\n\n# NodeList을 반복하는 방법\n\n<div class=\"content-ad\"></div>\n\n노드 목록(NodeList)은 웹 페이지의 문서에서 추출된 노드들의 컬렉션입니다. 예를 들어, 페이지에 `li` 요소로 이루어진 `ul`이 있다고 가정해 보세요:\n\n```js\n<ul class=\"languages\">\n  <li>Python</li>\n  <li>JavaScript</li>\n  <li>Ruby</li>\n</ul>\n```\n\n위와 같은 요소들을 포함하는 NodeList를 얻기 위해 querySelectorAll 속성을 사용할 수 있습니다.\n\n```js\nconst listItems = document.querySelectorAll('.languages li')\n```\n\n<div class=\"content-ad\"></div>\n\n그럼, 각 요소의 textContent를 얻기 위해 for of 루프 개념을 사용해보세요.\n\n```js\nconst listItems = document.querySelectorAll(\".languages li\");\nfor (const item of listItems) {\n  console.log(item.textContent);\n}\n```\n\n<img src=\"/assets/img/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact_1.png\" />\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n거의 매일 사용하는 ES6 기능은 무엇인가요? 아래 댓글로 알려주세요.\n\n읽어주셔서 감사합니다.\n\nJavaScript를 마스터하는 가장 좋은 방법은 프로젝트를 만드는 것입니다. 실용적인 JavaScript 뉴스레터를 구독하여 JavaScript 기술을 향상시키세요.\n\n# 간단명료하게 🚀\n\n<div class=\"content-ad\"></div>\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 👏️️로 칭찬하고 팔로우하기\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact_0.png","tag":["Tech"],"readingTime":7},{"title":"React를 활용하여 접근성 테스팅의 힘을 발휘하세요","description":"","date":"2024-06-20 05:07","slug":"2024-06-20-UnlockthePowerofAccessibleTestingwithReact","content":"\n\n## 포괄적인 사용자 경험을 만들자, 한 번에 한 가지 테스트씩.\n\n![이미지](/assets/img/2024-06-20-UnlockthePowerofAccessibleTestingwithReact_0.png)\n\n테스트; 모든 개발자들이 가장 좋아하는 주제! 때로는 지루해 보일 수 있지만 견고한 테스트 작성은 좋은 소프트웨어 개발의 핵심입니다. 전체 개발자들이 고려해야 할 장치 및 차원이 무한대로 늘어나면서, 원활한 접근성을 보장하는 테스트 작성이 더 중요해졌습니다.\n\n본 문서에서는 리액트에서 테스트 접근성을 우선시하는 몇 가지 간단한 방법을 소개하겠습니다. 특정 라이브러리와 도구를 언급할 때, 일부 기본적인 이해를 전제로 하고 설정/설치 등과 같은 구체적인 세부 사항은 다루지 않겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# React Testing Library\n\n안녕하세요! React에서 테스트하는 데 가장 인기 있는 라이브러리 중 하나인 React Testing Library입니다. 현재 주간 다운로드 수가 900만을 넘습니다. React Testing Library는 React 컴포넌트를 테스트하는 가벼운 솔루션으로 사용자 상호작용 중심의 방법론을 가지고 있습니다. Jest를 사용하는 것을 추천하지만, Mocha와 같은 다른 자바스크립트 테스팅 프레임워크와 함께 사용할 수도 있습니다.\n\n## 쿼리\n\nReact 컴포넌트를 테스트할 때 쿼리는 가장 많이 사용되는 기능 중 하나입니다. 이것은 페이지에서 요소를 찾기위해 호출할 수 있는 방법입니다. 다양한 방법이 있지만, 페이지의 접근 가능한 요소들을 적절하게 테스트하는 데 있어서 모두 동일하지는 않습니다.\n\n<div class=\"content-ad\"></div>\n\n아래 테스트를 예로 들어보겠습니다:\n\n```js\nimport {render, screen} from '@testing-library/react'\n\ntest('로그인이 되어야 합니다', () => {\n  render(<LoginForm/>)\n  const username = screen.getByTestId('username-input')\n  ...\n}) \n```\n\n여기서는 간단한 로그인 폼 컴포넌트를 테스트하고 있습니다. 사용자명 입력 필드를 가져오기 위해 getByTestId 메서드를 사용했습니다. 이 요소가 페이지에 존재하고 올바른 테스트 ID가 할당되어 있다면 테스트가 정상적으로 실행되고 오류가 발생하지 않을 것입니다. 그러나 사용자가 볼 수 없고(들을 수 없는) 식별자를 사용하기 때문에 접근성에는 최적이지 않습니다.\n\n이제 접근성을 고려한 향상된 버전을 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {render, screen} from '@testing-library/react'\n\ntest('로그인이 되어야 합니다', () => {\n  render(<LoginForm/>)\n  const username = screen.getByRole('textbox', {name:'Username'})\n  ...\n})\n```\n\n이 예제에서는 getByTestId를 getByRole로 대체했습니다. 또한 요소를 특정하고 해당 요소의 역할 및 관련 이름에 따라 식별할 수 있도록 추가 매개변수를 전달했습니다.\n\n이 접근 방식은 접근성 면에서 훨씬 나아지며, 접근성 트리에 노출된 요소를 쿼리하기 때문에, 보조 기술(스크린 리더 등)이 요소를 인식하고 상호 작용하는 방식과 일치하는 방식으로 테스트를 수행합니다. 따라서 테스트 ID와 같은 것에 액세스할 수 없는 최종 사용자의 더 현실적인 사용자 경험을 시뮬레이션합니다.\n\n요소를 쿼리하기 위한 기본 메소드는 getByRole 메소드여야 합니다. 대부분의 경우에 적합하겠지만, 그렇지 않은 경우를 위해 아래에 우선순위대로 나열한 메소드 목록이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- getByRole\n- getByLabelText\n- getByPlaceholderText\n- getByText\n- getByDisplayValue\n- getByAltText\n- getByTitle\n- getByTestId\n\n하지만 이러한 다른 메서드 중 하나를 사용하기 전에 구성 요소가 어떻게 작성되었는지 더 깊이 살펴보세요. 역할의 더 나은 사용을 통해 더 접근성이 뛰어난 방식으로 작성할 수 있는 기회가 있을 수도 있습니다.\n\n이러한 메서드와 이들의 우선순위에 관한 자세한 내용은 여기서 확인할 수 있습니다.\n\n## fireEvent vs userEvent\n\n<div class=\"content-ad\"></div>\n\nReact 컴포넌트를 테스트하는 또 다른 중요한 부분은 사용자 조작을 수행할 수 있는 능력을 갖는 것입니다. React Testing Library에서 이를 달성하는 두 가지 주요 방법은 fireEvent 및 userEvent입니다.\n\n우리가 이전에 했던 테스트를 이어서, fireEvent를 사용한 예제를 먼저 살펴봅시다.\n\n```js\nimport {render, screen, fireEvent} from '@testing-library/react'\n\ntest('로그인해야 합니다', () => {\n  render(<LoginForm/>)\n  const username = screen.getByRole('textbox', {name:'Username'})\n  fireEvent.change(username, {target: {value: 'michaelscott'})\n})\n```\n\n이제 여기에 또 다른 예제가 있습니다. 이번에는 userEvent를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {render, screen} from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\n\ntest('로그인되어야 함', async () => {\n  const user = userEvent.setup()\n  render(<LoginForm/>)\n  const username = screen.getByRole('textbox', {name:'Username'})\n  await user.type(username, 'michaelscott')\n})\n```\n\n이 두 가지 방법은 같은 결과를 얻을 수 있지만, 내부적으로는 다르게 작동합니다. 여기에 문서에서 직접 인용한 내용이 있습니다:\n\n이것이 우리의 구성요소가 접근 가능한지 확인하는 능력에 어떤 영향을 미치는지 궁금할 것입니다. fireEvent는 구성요소 내에서 특정 동작을 테스트하는 데 유용할 수 있지만, 특히 보조 기술을 사용하는 사용자들이 구성요소와 상호작용하는 실제 방식을 잘 반영하지 않습니다.\n\n또한, fireEvent를 사용할 때 실제 사용자 상호작용에 트리거되는 모든 부작용을 트리거하지 않을 수도 있다는 점을 고려하는 것이 중요합니다.\n\n\n<div class=\"content-ad\"></div>\n\n따라서 가능한 경우 userEvent를 사용하고 사용자 조작을 시뮬레이션하는 데 이 방법을 기본값으로 사용하는 것이 좋습니다.\n\n# jest-axe\n\n이 강력한 라이브러리는 axe(접근성 엔진)를 React 테스트에서 쉽게 사용할 수 있게 해줍니다. 본문에서는 일관성을 위해 React Testing Library와 함께 사용하겠지만 다양한 다른 라이브러리와 함께 사용할 수도 있습니다. 추가 자세한 내용은 여기서 찾아볼 수 있습니다.\n\n로그인 양식 예제를 계속 진행할 것이며, 아래에는 쉽게 따를 수 있지만 좋은 접근성 표준을 준수하지 않는 구성 요소의 간단한 버전이 제시되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst LoginForm = () => (\n  <form>\n    <input type=\"text\" />\n    <input type=\"password\" />\n    <button type=\"submit\">Login</button>\n  </form>\n);\n```\n\n이제 jest-axe 라이브러리를 사용하여 이 컴포넌트에 대한 테스트를 만들 수 있습니다:\n\n```js\nimport { render } from '@testing-library/react';\nimport { axe, toHaveNoViolations } from 'jest-axe';\n\ntest('접근성 위반 사항이 없어야 합니다.', async () => {\n  const { container } = render(<LoginForm />);\n\n  const results = await axe(container);\n\n  expect(results).toHaveNoViolations();\n});\n```\n\n테스트를 실행하면 다음과 같은 출력이 생성되는데, 입력 필드에 레이블을 추가하는 것을 잊었다는 위반 사항을 식별했습니다!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-UnlockthePowerofAccessibleTestingwithReact_1.png\" />\n\n이 간단한 테스트에서 컴포넌트의 접근성 위반 사항을 식별했고, 제안된 변경 사항으로 빠르게 수정할 수 있습니다. 이것은 작은 예시지만 더 복잡한 컴포넌트에서 얼마나 강력한지 보실 수 있습니다.\n\n이 피드백을 통해 컴포넌트를 다음과 같이 개선할 수 있습니다:\n\n```js\nconst LoginForm = () => (\n  <form>\n    <label htmlFor=\"username\">사용자명</label>\n    <input type=\"text\" id=\"username\" />\n    <label htmlFor=\"password\">암호</label>\n    <input type=\"password\" id=\"password\" />\n    <button type=\"submit\">로그인</button>\n  </form>\n);\n```\n\n<div class=\"content-ad\"></div>\n\n여기에 접근성을 더 높일 수 있는 다른 여러 방법이 있음을 언급하는 것이 중요합니다. 예를 들어 스타일링, 양식 유효성 검사, 추가 ARIA 속성 등이 있습니다. 그러나 이것은 단지 라이브러리의 강점을 보여주고 컴포넌트의 기초를 쉽게 강화할 수 있는 작은 예시일 뿐입니다.\n\n# Storybook에서의 접근성\n\nStorybook은 UI 컴포넌트 및 페이지를 독립적으로 작성하는 데 널리 사용되는 라이브러리입니다. Storybook은 능력을 향상시킬 수 있는 멋진 애드온도 가지고 있습니다. 그 중 하나가 storybook-addon-a11y인데, 이 애드온은 컴포넌트 내의 접근성 위반 사항을 보여줍니다. 마치 jest-axe가 하는 것과 유사합니다.\n\nStorybook 구성에 이 애드온을 추가함으로써 시작할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst config: StorybookConfig = {\n  addons: [\n    '@storybook/addon-a11y',\n  ],\n};\nexport default config;\n```\n\n그런 다음 Storybook 환경을 시작하면 활성화성 탭이 나타나며, 여기에서 위반 사항 및 통과 사항을 볼 수 있습니다. 다소 접근하기 어려운 로그인 양식의 경우 아래 이미지와 유사한 모습이 될 것입니다.\n\n![이미지](/assets/img/2024-06-20-UnlockthePowerofAccessibleTestingwithReact_2.png)\n\n![이미지](/assets/img/2024-06-20-UnlockthePowerofAccessibleTestingwithReact_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n이는 구성 요소가 접근성 면에서 목적에 적합한지 확인하는 또 다른 강력한 방법입니다. 특히 이미 시각 테스트용으로 Storybook을 사용 중이라면 이것은 아주 좋은 추가 기능이 될 수 있습니다.\n\n# 결론\n\nReact 애플리케이션에 접근성 테스트를 점진적으로 통합하는 여러 가지 방법 중 일부만 강조했습니다. 이것은 시작점으로 작용하고 더 나은 발전을 위한 견고한 기반을 구축하는 데 도움이 될 것입니다.\n\n이 방법이 애플리케이션이 100% 접근 가능하다고 확신할 수 있는 방법은 아닙니다. 가능하다면 실제 사용자가 사용하는 접근성 기술로 소프트웨어를 테스트해 보는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n읽어주셔서 감사합니다 😊","ogImage":{"url":"/assets/img/2024-06-20-UnlockthePowerofAccessibleTestingwithReact_0.png"},"coverImage":"/assets/img/2024-06-20-UnlockthePowerofAccessibleTestingwithReact_0.png","tag":["Tech"],"readingTime":7},{"title":"프론트엔드 엔지니어를 위한 아마존 전화 인터뷰 경험","description":"","date":"2024-06-20 05:06","slug":"2024-06-20-AmazonPhoneInterviewExperienceforFront-EndEngineer","content":"\n\n프론트엔드 엔지니어 포지션(4-5년 경력)에 지원했어요. 인터뷰는 행동 질문, 프론트엔드 질문 및 역 인터뷰 세 가지 부분으로 나뉘었어요.\n\n## 행동 질문\n\n- 자기 소개해주실래요?\n- 기대 이상으로 노력한 적이 있나요?\n- 어떻게 하면 업무 효율성을 향상시키는지 알려주세요.\n\n<div class=\"content-ad\"></div>\n\n## 프론트엔드 질문\n\n- 제게 다음 그림이 주어졌고 사용자 인터페이스를 개발하고 해당 기능을 구현하라는 요청을 받았습니다.\n\n![이미지](/assets/img/2024-06-20-AmazonPhoneInterviewExperienceforFront-EndEngineer_0.png)\n\n인터뷰어는 위 그림을 구현해 달라고 했습니다. \"Language Name\" 및 \"Language Content\"를 제공하는 데이터를 가져오는 API 엔드포인트가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n탭을 클릭하면 콘텐츠가 변경되고 활성화된 탭이 강조 표시되어야 합니다.\n\n면접관은 API 엔드포인트에서 전송되는 데이터 구조를 상상할 수 있도록 했다.\n\n## 역면접\n\n- Amazon에서 자랑스러워하는 프로젝트는 무엇인가요?\n- Amazon에서 주니어 개발자에서 시니어 개발자가 되기까지 어떻게 되었나요?\n\n<div class=\"content-ad\"></div>\n\n## 내 생각들\n\n- 다음 라운드에 진출하지 못해 전화 인터뷰 라운드에서 거절당했습니다.\n- 되돌아보면 인터뷰는 간단했지만, 제가 최선을 다할 만큼 충분히 준비되지 않은 느낌입니다.\n- 제가 잘못했다고 믿는 곳은 '행동 질문'입니다.\n- 그리고 '프런트엔드 질문'에 관해서는, 인터뷰 이전에 전적으로 확신하지 못했습니까? 어떤 종류의 질문이 있을지 약간의 두려움이 들었습니다. 프런트엔드나 Leetcode 스타일 질문에 초점을 맞출지에 대해요.\n- 모든 프런트엔드 개발자들에게, 어떤 질문이 나오고 인터뷰에서 어떤 유형의 질문에 초점을 맞출지에 대한 감을 제대로 잡는 것은 이상한 느낌입니다. 그러나 인터뷰 방식이 향상되고 많은 프런트엔드 중심의 인터뷰가 보여지고 있다는 것에 대해서 말이죠.\n\n다음 인터뷰에서 좋은 결과 있길 바랍니다. 만약 이 게시물이 인터뷰 준비에 도움이 되었다면 👏 와 팔로우 🚶‍♂️를 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-20-AmazonPhoneInterviewExperienceforFront-EndEngineer_0.png"},"coverImage":"/assets/img/2024-06-20-AmazonPhoneInterviewExperienceforFront-EndEngineer_0.png","tag":["Tech"],"readingTime":2},{"title":"공포 주도 개발","description":"","date":"2024-06-20 05:05","slug":"2024-06-20-FearDrivenDevelopment","content":"\n\n\"Why Frontend Tech Choices Are Not Only Driven By Merit?\n\n어떻게 프론트엔드 프레임워크나 라이브러리를 선택하시나요?\n\n사실은, 프론트엔드 비즈니스는 매우 무자비한 곳이에요:\n\n계속해서 변화에 대해 인식하고 적절한 시점에 말을 바꾸지 않으면, 죽거나 거의 움직이지 않는 말과 함께 측면에 남게 될 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n\"헛소리!\"라고 말할 수 있겠죠... 하지만 저는 여러분이 이야기 속에 있는 것일 수도 있기 때문에 무서운 이야기를 하나 들려드리겠습니다:\n\n<img src=\"/assets/img/2024-06-20-FearDrivenDevelopment_0.png\" />\n\n안녕하세요, Tikal의 기술 리더인 Roy Kass입니다. 프론트엔드 산업에서 16년 이상의 경험이 있습니다.\n\n옛날 옛적에, 프론트엔드 산업이 매우 어렸던 때, 아름다운 기술인 Adobe Flex가 있었습니다.\nFlex는 Flash 인프라 위에서 동작하는 화려한 기술이었는데, 브라우저에 설치하여 작동하는 벡터 드로잉 플러그인을 사용했습니다. 가장 유명한 3버전은 2007년에 소개되었고, 그것은 혁명이었습니다. Flex는 가상 스크롤링, 동적 라이브러리, 전체 정적 타이핑 및 컴파일 중 트리 쉐이킹과 같은 이전에 존재하지 않았던 다양한 기능들을 소개했습니다. Flex 개발자들은 산업에서 가장 소중한 자산이었죠. 그러나 그의 종주인 스티브 잡스, 애플의 CEO가 Adobe Flash 플러그인을 iOS 하드웨어에서 허용하지 않겠다는 편지를 써서 이 모든것이 바뀌었습니다. 결과적으로, Adobe는 Flex를 커뮤니티에 전달했고(이름은 \"Apache Flex\"로 변경되었습니다) 플러그인은 프로프리에터리로 유지했습니다. 이는 그 기술의 버려짐을 의미했습니다. 2012년, 기술이 쇠퇴의 길을 걷고 있다는 사실이 명확해졌습니다.\n\n<div class=\"content-ad\"></div>\n\nFlex에 대한 높은 관심을 받던 개발자들이 AngularJS와 같은 다른 기술로 전환해야 했어요.\n\n이 모든 걸 어떻게 알게 되었냐구요? 제가 그 Flex 개발자 중 한 명이었거든요. Flex에서 HTML5 및 AngularJS로 이동하는 것은 힘든 일이었어요.\n\n\"하지만, 그건 한 가지 사례 뿐이잖아요!\" 라고 말할 수도 있겠죠.\n\n음, 이런 일이 또 일어난 건 AngularJS에서 Angular 2로의 이동 때도 있었어요.\n\n<div class=\"content-ad\"></div>\n\nAngularJS가 어느 정도로 느려지고 낡아졌을 때가 오게 되었습니다. 구글은 breaking changes가 있는 Angular 2를 만들었습니다. 여러분은 그 이동을 하는 데 시간을 투자할지, 다른 기술(예: React)을 찾을지, 아니면 쇠말에 머물러있는 대가를 치를지를 결정해야 했습니다.\nAngularJS에 오래 머무른 회사가 많았는데, 그 결과 아주 늦은 시간에 기술 전환이 이루어진 엄청난 노력을 하게 되었죠. 머무르는 것은 어렵기만 한 게 아니었어요 — 기술이 폐기된 상태여서 보안 리스크가 발생했습니다.\n\n그리고 얼마 지나지 않아, Angular 2(이젠 몇 버전 앞으로 나가 있는)가 시장에서 소멸하기 시작했습니다. 선택의 실수(예를 들면 매우 오랜 베타로 인한 버그와 성능 저하, 많은 breaking changes, 그리고 블랙 박스 형태의 복잡함) 때문이었습니다.\n\n곧, React가 시장을 석권했습니다. 대다수의 회사들이 React를 사용하고 있었죠.\n\nReact가 배우고 사용하기 더 간단하다는 이유 때문이라고 주장하는 사람들도 있습니다. Angular 애호가들은 더 구조화된 프레임워크가 필요한 대형 규모의 프로젝트에서 실패한다고 말할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그것은 중요하지 않았어요 — 왜냐면 결국 Meta(React)가 올바른 정치 결정들을 내려 시장에서 승리했기 때문이었어요. React와 Angular 중 뭘 선택할지에 대한 토론은 시간이 지남에 따라 사그라들었고, React가 즐겨찾기가 되었어요. Angular는 아직 살아있지만, 커뮤니티 크기는 React보다 훨씬 작아졌어요.\n\n그리고 이 글을 읽으면서 머리를 흔드는 모든 Angular 팬 여러분들께 — 저도 예전에 당신들 중 한 명이었기 때문에 정말 동정합니다.\n\n저는 JQuery, Ember, Haxe, CoffeeScript와 같은 기술들에 대해 언급하지도 않았는데, 이들도 비슷한 길을 걸어왔다는 것을 말씀드리고 싶어요. 그것들이 정말 수많다는 것을 기억해주세요.\n\n최종적으로, 이러한 프론트엔드 기술들은 오픈 소스입니다. 이는 만약 커뮤니티의 관심을 잃는다면, 지원이 줄어든다는 것을 의미해요. 토론은 더 인기 있는 라이브러리들로 방향을 전환할 것이에요. 여러분의 지식들은 새 달의 우물처럼 말라버릴 거에요. 마침내 업데이트를 받지 못할 뿐만 아니라 보안 문제도 발생할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n그리고 — 보다 인기 있는 기술에 대해서 높은 자격을 갖춘 인력을 채용하는 것이 훨씬 쉽습니다.\n\n![FearDrivenDevelopment_1](/assets/img/2024-06-20-FearDrivenDevelopment_1.png)\n\n프론트엔드 기술은 오래가지 않습니다. 시기를 맞추거나 큰 대가를 치르게 될지도 모릅니다.\n\n리액트는 이런 면에서 어딘가 이상한 존재이며, 곧 코쿤에 들어가 다음JS로 부활할 것입니다 (이에 관한 더 많은 정보는 다음 기사에서 소개될 예정입니다).\n\n<div class=\"content-ad\"></div>\n\n제가 이 상황을 좋아하지 않는다는 것을 말씀드릴 필요가 있습니다. 이것은 기술의 장점에 대한 냉정한 토론에서 인기로 물을 끓게 하는 선택으로 이어진다는 점이 제게 중요합니다. 일부 인기가 없는 기술은 그들의 능력만을 고려할 때 더 나은 선택일 수 있습니다. 또한 이 주제가 얼마나 논란이 많은지 이해하고 있습니다.\n\n하지만 — 이 \"공포로 이끌리는 선택\"이라는 것이 프론트엔드 분야가 15년 이상 진화해 온 방식입니다. 이를 다르게 하려면 매우 중요한 변화가 필요하며, 그 동안 이러한 고려를 주요하게 여겨야 합니다.\n\n# 그렇다면 기술의 인기를 어떻게 확인할까요?\n\n먼저, NPM Trends 웹사이트로 가서 관심 있는 기술을 해당 분야의 경쟁 상대와 비교해보세요.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, React, Angular 및 Vue를 테스트해 보겠습니다. 2022년 말에 Vue에 이상한 \"불일치\"가 있어서 무시할 필요가 있습니다. 아마 버그인 것 같아요.\n\n![그림](/assets/img/2024-06-20-FearDrivenDevelopment_2.png)\n\n그래프를 보면 React가 다운로드 측면에서 Vue와 Angular보다 훨씬 앞서 있다는 것을 알 수 있습니다. 이는 사용 범위를 파악하는 데 좋은 KPI입니다.\n\n이제 GitHub 통계를 비교해 봅시다:\nReact:\n\n<div class=\"content-ad\"></div>\n\n\n![Angular](/assets/img/2024-06-20-FearDrivenDevelopment_3.png)\n\n![Vue(core)](/assets/img/2024-06-20-FearDrivenDevelopment_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-FearDrivenDevelopment_5.png)\n\n패턴을 볼 수 있나요?\n리액트는 다른 2개와 합친 것보다 훨씬 더 많은 트래픽을 갖고 있습니다. 더 많은 사람들이 관심을 가지고 있고, 별표를 찍고, 관심을 갖고 있습니다!\n\n더 흥미로운 체크 방법은 최근 커밋이 언제, 어디서 이루어졌는지 보는 것입니다 (왜 그런지까지).\n\n이것은 새로운 코드가 라이브러리에 삽입되었는지, 아니면 실제로 정체되어 있는지 보는 좋은 테스트입니다.\n\n<div class=\"content-ad\"></div>\n\nReact:\n\n![React](/assets/img/2024-06-20-FearDrivenDevelopment_6.png)\n\nAngular:\n\n![Angular](/assets/img/2024-06-20-FearDrivenDevelopment_7.png)\n\n<div class=\"content-ad\"></div>\n\n# Vue:\n\n![FearDrivenDevelopment](/assets/img/2024-06-20-FearDrivenDevelopment_8.png)\n\n우리가 원하는 최상의 경우는 몇 일 이내입니다. 몇 주에서 최대 1~3개월 정도면 받아들일 수 있습니다. 하지만, 4개월 이상이 보인다면, 이 라이브러리의 유지보수에 문제가 있는 것을 의미합니다.\n\n이 경우, 모두가 최근 커밋에 따르면 (1~2일 전), 반응(React)이 다른 모든 측면에서 인기를 이끌고 있다는 것은 명확합니다. Vue와 Angular보다 인기가 더 많다는 것을 알 수 있습니다.\n그런데, 모든 면에서 절대로 더 나은 것을 의미합니까? 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 주요 고려 사항 인가요? 프론트엔드 세계에서는 — 대답은 반가운 YES 입니다.\n\n프론트엔드 기술을 검토할 때, 구성 요소 라이브러리 시스템이나 심지어 단일 구성 요소와 같이 작은 것들도 선택한 것이 가능한 살아있고 인기있는 것인지 확인하세요.\n\n인기도가 프론트엔드 기술의 생존과 지속 가능성에 대한 주요 KPI로 남아 있는 한, 기술을 선택할 때 이는 주요 고려 사항이어야 합니다.\n\n죽거나 쇠약한 말은 당신을 멀리 몰아가지 않으므로 가장 활발한 것을 선택하세요 — 그리고 인기 순위에서 2위 또는 3위에 근접해 있으면 주기적으로 활발성과 인기도를 확인하세요. 이것은 궁극적으로 교육된 내기일 뿐이라고 하더라도, 가끔은 갑작스러운 변화가 발생할 수 있습니다. 단지 그러한 변화에 대해 경계를 지켜야 합니다.\n\n<div class=\"content-ad\"></div>\n\n다음 기사에서는 왜 NextJS가 여러분이 선택해야 할 다음 필수 도구일 수 있는지 보여드릴게요.\n\n![Image](/assets/img/2024-06-20-FearDrivenDevelopment_9.png)","ogImage":{"url":"/assets/img/2024-06-20-FearDrivenDevelopment_0.png"},"coverImage":"/assets/img/2024-06-20-FearDrivenDevelopment_0.png","tag":["Tech"],"readingTime":6}],"page":"39","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}