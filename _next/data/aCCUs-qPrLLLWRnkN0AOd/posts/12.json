{"pageProps":{"posts":[{"title":"조심하세요 반품 정책 없는 온라인 쇼핑의 숨겨진 위험 5가지","description":"","date":"2024-06-23 13:40","slug":"2024-06-23-BewareTheHiddenRisksofOnlineShoppingWithoutReturnPolicies","content":"\n\n\n![Samsung A32](/assets/img/2024-06-23-BewareTheHiddenRisksofOnlineShoppingWithoutReturnPolicies_0.png)\n\n저는 최근에 온라인에서 삼성 A32 핸드폰을 구입했어요.\n\n그래서 제게 도착했을 때 너무 행복했는데, 그 행복 속에 실망이 가득했어요.\n\n폰을 잠금 해제한 후에 화면에 긁힌 흔적이 드러나서, 폰이 제게 도달하기 전에 손상되었음이 분명했어요.\n\n\n<div class=\"content-ad\"></div>\n\n웹사이트를 살펴보니 반품 정책이 있는지 확인했는데, 핸드폰을 교환하거나 환불받을 수 있을 것이라고 희망했지만 놀랍게도 이 구매에는 반환 정책이 없었습니다.\n\n돈을 많이 써서 손상된 제품을 갖게 되어 좌절하고 무력함을 느꼈어요.\n\n이것은 교훈이었습니다. 반환 또는 교환 정책이 없는 온라인 주문은 피하는 것이 좋습니다.\n\n구매할 제품을 개인적으로 방문하여 확인하고 상점에서만 사는 것이 최선입니다.\n\n<div class=\"content-ad\"></div>\n\n소중한 시간을 낭비하지 마시고 잠재적인 실망에서 스스로를 지켜주세요.","ogImage":{"url":"/assets/img/2024-06-23-BewareTheHiddenRisksofOnlineShoppingWithoutReturnPolicies_0.png"},"coverImage":"/assets/img/2024-06-23-BewareTheHiddenRisksofOnlineShoppingWithoutReturnPolicies_0.png","tag":["Tech"],"readingTime":1},{"title":"React용 스켈레톤 로더 라이브러리 구축 방법","description":"","date":"2024-06-23 13:40","slug":"2024-06-23-BuildingaSkeletonLoaderLibraryforReact","content":"\n\n웹 개발의 빠르게 변화하는 세상에서 UI 컴포넌트 라이브러리는 개발자들에게 귀중한 도구가 되어왔어요. Material-UI, Chakra UI, Ant Design, 그리고 ShadCN과 같은 이러한 라이브러리들은 다양한 사전 구축된 컴포넌트들을 제공하여 사용자 인터페이스의 신속하고 일관된 개발을 가능하게 합니다. 이들은 생산성을 향상시키고 디자인 일관성을 유지하며, 개발자들이 애플리케이션의 독특한 측면에 집중할 수 있게 하여 휠을 재창조하는 것보다 더 효율적입니다. 하지만 때로는 성능이나 디자인 요구 사항을 충족시키기 위해 보다 구체적으로 초점을 맞춰야 할 때도 있습니다. 이 글에서는 React를 위한 가벼운 스켈레톤 로더 컴포넌트 라이브러리인 @paul/skeleton-loader-react을 소개하겠습니다. 종합적인 UI 라이브러리와 달리, 이 프로젝트는 데이터가 로딩되는 동안 사용자 경험을 향상시키기 위한 간단하고 효과적인 스켈레톤 로더에 초점을 맞추고 있습니다.\n\n## 이 라이브러리를 개발하는 데 고려해야 할 주요 사항\n\n@paul/skeleton-loader-react 라이브러리를 개발하는 동안, 이 효과적이고 사용하기 쉬운 라이브러리를 보장하기 위해 몇 가지 중요한 요소가 고려되었습니다:\n\n<div class=\"content-ad\"></div>\n\n- Skeleton Loader Variants:\n라이브러리는 세 가지 유형의 스켈레톤 로더를 지원합니다: 원형, 직사각형 및 모서리가 둥근 직사각형.\n- 단일 구성요소 노출:\n라이브러리는 `Skeleton /`이라는 하나의 구성요소만을 노출하여 API 및 사용을 간소화합니다.\n- Variant 속성:\n`Skeleton /`의 variant 속성은 스켈레톤 로더의 유형(원형, 직사각형 또는 모서리가 둥근 직사각형)을 결정합니다.\n- Variant별 속성:\n선택한 variant에 따라 `Skeleton /`의 속성이 변경됩니다. 예를 들어, borderRadius 속성은 평범한 직사각형 variant에는 적용되지 않고, 모서리가 둥근 직사각형 variant에만 해당됩니다.\n- TypeScript 통합:\nTypeScript를 사용하면 각 variant의 속성에 대한 자동 제안과 힌트를 제공받아 개발을 더 직관적으로 만들고 오류 가능성을 줄일 수 있습니다.\n- 다양한 프로젝트 설정과의 호환성:\n이 라이브러리는 Create React App (CRA), Vite 및 기타 일반적인 React 프로젝트 설정을 사용하여 쉽게 사용할 수 있도록 구성되어 있습니다.\n- 재사용 가능한 보일러플레이트 코드:\n@paul/skeleton-loader-react의 코드베이스는 자신의 React 라이브러리를 만들고 싶은 개발자들을 위한 보일러플레이트로 사용될 수 있습니다. src 폴더의 내용을 제거함으로써, 개발자들은 기존 설정을 사용하여 사용자 정의 구성요소 또는 라이브러리를 구축할 수 있습니다.\n\n## 미리보기\n\n<img src=\"/assets/img/2024-06-23-BuildingaSkeletonLoaderLibraryforReact_1.png\" />\n\n## 설치\n\n<div class=\"content-ad\"></div>\n\nnpm을 사용하여 라이브러리를 설치하세요:\n\n```js\nnpm install https://github.com/souvik-pl/skeleton-loader-react.git\n```\n\n## 사용 방법\n\n```js\nimport React from \"react\";\nimport { Skeleton } from \"@paul/skeleton-loader-react\";\n\nconst App = () => {\n  return (\n    <div>\n      <h2>원형 스켈레톤</h2>\n      <Skeleton variant=\"circle\" height=\"100px\" width=\"100px\" animated={true} />\n\n      <h2>직사각형 스켈레톤</h2>\n      <Skeleton variant=\"rectangle\" height=\"100px\" width=\"50vw\" animated={true} />\n\n      <h2>둥근 직사각형 스켈레톤</h2>\n      <Skeleton\n        variant=\"rectangle-rounded\"\n        borderRadius=\"10px\"\n        width=\"50vw\"\n        height=\"15px\"\n        animated={true}\n      />\n    </div>\n  );\n};\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n## 마무리 맺는 글\n\n이 라이브러리를 꼭 프로젝트에 사용해보시기를 권장합니다. 저장소를 fork하여 원하는 대로 수정하거나 React 라이브러리의 기본으로 활용해보세요.\n\n이슈 보고, 기능 제안, 혹은 풀 리퀘스트 제출 등 모든 기여를 환영합니다.\n\n감사합니다. 즐거운 코딩 되세요 🚀","ogImage":{"url":"/assets/img/2024-06-23-BuildingaSkeletonLoaderLibraryforReact_0.png"},"coverImage":"/assets/img/2024-06-23-BuildingaSkeletonLoaderLibraryforReact_0.png","tag":["Tech"],"readingTime":3},{"title":"React에서 사용자 경험 향상하기  커스텀 페이지네이션 컴포넌트 만드는 방법","description":"","date":"2024-06-23 13:39","slug":"2024-06-23-BoostUserExperienceinReactCreateacustompaginationcomponent","content":"\n\n<img src=\"/assets/img/2024-06-23-BoostUserExperienceinReactCreateacustompaginationcomponent_0.png\" />\n\n## 소개:\n\n페이지네이션은 대규모 데이터를 처리하는 웹 앱에서 반드시 필요합니다. 사용자가 정보를 쉽게 탐색하도록 도와주어 경험을 향상시킵니다.\n\nReact는 미리 제작된 페이지네이션 라이브러리를 제공하지만, 사용자 정의 컴포넌트를 만들면 더 많은 제어력과 유연성을 얻을 수 있습니다. 이 단계별 튜토리얼은 React에서 자체 페이지네이션 컴포넌트를 구축하는 방법을 안내해주어 내부 작업과 구현 능력에 대한 견고한 이해를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 프로젝트 설정\n\n먼저 React 프로젝트를 설정해 봅시다. 시스템에 Node.js와 npm이 설치되어 있는지 확인해 주세요. 그런 다음 Create React App을 사용하여 새 React 앱을 만들어 봅시다:\n\n```js\nnpx create-react-app custom-pagination\ncd custom-pagination\n```\n\n## 페이지네이션 컴포넌트 구축\n\n<div class=\"content-ad\"></div>\n\n이제 우리가 만든 사용자 정의 페이지네이션 컴포넌트를 만들 차례입니다. Pagination.js로 이름을 지을 거에요. 첫 번째 컴포넌트 코드는 여기 있어요:\n\n```js\n// Pagination.js\n\nimport React from \"react\";\nimport { Button, Container, Row, Col, Form } from \"react-bootstrap\";\nimport { OPTIONSROWPERPAGESUSERS } from \"../config/constants\";\n\nfunction Pagination({\n  currentPage,\n  totalPages,\n  handleChangeRowsPerPage,\n  handleChangePage\n}) {\n  const paginationRange = () => {\n      // 페이지네이션 로직\n  };\n\n  return (\n    <Container fluid id=\"custom-pagination\">\n      <Row>\n          <Col md={\"auto\"}>\n            <Form.Select size=\"md\" onChange={handleChangeRowsPerPage}>\n              {OPTIONSROWPERPAGESUSERS.map((elem) => {\n                return (\n                  <option key={elem.value} value={elem.value}>\n                    {elem.label}\n                  </option>\n                );\n              })}\n            </Form.Select>\n          </Col>\n        <Col md={\"auto\"}>\n          <Button\n            className={currentPage === 1 ? \"disable page-item\" : \"page-item\"}\n            disabled={currentPage === 1}\n            onClick={() => handleChangePage(currentPage - 1)}\n          >\n            Prev\n          </Button>\n          {paginationRange().map((pageNumber, index) => (\n            <Button\n              key={index}\n              active={pageNumber === currentPage}\n              disabled={pageNumber === \"...\"}\n              className={\n                pageNumber === currentPage\n                  ? \"isActive page-item\"\n                  : pageNumber !== \"...\"\n                  ? \"page-item\"\n                  : \"disable page-item\"\n              }\n              onClick={() => pageNumber !== \"...\" && handleChangePage(pageNumber)}\n            >\n              {pageNumber}\n            </Button>\n          ))}\n\n          <Button\n            className={\n              currentPage === totalPages ? \"disable page-item\" : \"page-item\"\n            }\n            disabled={currentPage === totalPages}\n            onClick={() => {\n              handleChangePage(currentPage + 1);\n            }\n          >\n            Next\n          </Button>\n        </Col>\n      </Row>\n    </Container>\n  );\n}\n\nexport default Pagination;\n```\n\n## 페이지네이션 로직 구현\n\n이제 Pagination 컴포넌트 내부에 페이지네이션 로직을 구현할 차례입니다. 현재 페이지와 전체 페이지 수에 기반하여 표시할 페이지 번호를 결정하는 이 로직을 구현할 거에요.\n\n<div class=\"content-ad\"></div>\n\n```js\r\nconst paginationRange = () => {\n  const pages = [];\n\n  if (currentPage > 1) {\n    pages.push(1);\n    if (currentPage > 2) {\n      pages.push(\"...\");\n    }\n  }\n\n  const prevPage = currentPage - 1;\n  const nextPage = currentPage + 1;\n\n  if (prevPage > 1) {\n    pages.push(prevPage);\n  }\n\n  pages.push(currentPage);\n  if (nextPage <= totalPages) {\n    pages.push(nextPage);\n  }\n  if (currentPage < totalPages - 1) {\n    if (currentPage < totalPages - 2) {\n      pages.push(\"...\");\n    }\n    pages.push(totalPages);\n  }\n\n  return pages;\n};\r\n```\n\n## 구성 요소 스타일링\n\n이제 페이지 구성 요소에 기본 스타일을 추가하여 시각적으로 매력적으로 만들어 보겠습니다:\n\n```js\r\n/* styles.css */\n\n.pagination {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n.pagination button {\n  margin: 0 5px;\n  padding: 5px 10px;\n  border: 1px solid #ccc;\n  background-color: #f9f9f9;\n  cursor: pointer;\n}\n\n.pagination button.active {\n  background-color: #007bff;\n  color: #fff;\n}\n\n.pagination button.disable {\n  pointer-events: none;\n  opacity: 0.5;\n}\r\n```\n\n<div class=\"content-ad\"></div>\n\n## 통합 및 사용\n\n우리의 사용자 정의 페이징 컴포넌트를 사용하기 위해서는 데이터 및 페이징 상태를 관리하는 부모 컴포넌트에 통합해야 합니다. 이를 보여주기 위해 간단한 예제를 만들어보겠습니다.\n\nApp.js 파일을 만들고 상태와 데이터 처리를 설정해보세요.\n\n```js\n// App.js\n\nimport React, { useState } from \"react\";\nimport Pagination from \"./Pagination\";\n\nconst data = [...Array(100).keys()].map(i => `아이템 ${i + 1}`);\n\nconst App = () => {\n  const [currentPage, setCurrentPage] = useState(1);\n  const [rowsPerPage, setRowsPerPage] = useState(10);\n\n  const totalPages = Math.ceil(data.length / rowsPerPage);\n\n  const handleChangePage = (page) => {\n    setCurrentPage(page);\n  };\n\n  const handleChangeRowsPerPage = (event) => {\n    setRowsPerPage(Number(event.target.value));\n    setCurrentPage(1);\n  };\n\n  const paginatedData = data.slice(\n    (currentPage - 1) * rowsPerPage,\n    currentPage * rowsPerPage\n  );\n\n  return (\n    <div className=\"App\">\n      <ul>\n        {paginatedData.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n      <Pagination\n        currentPage={currentPage}\n        totalPages={totalPages}\n        handleChangePage={handleChangePage}\n        handleChangeRowsPerPage={handleChangeRowsPerPage}\n      />\n    </div>\n  );\n};\n\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n## 테스트 및 최적화\n\n마무리하기 전에, 페이지네이션 구성 요소를 철저히 테스트하고 성능을 최적화하는 것이 중요합니다. React Developer Tools 및 Lighthouse와 같은 도구를 사용하여 테스트하고 최적화할 수 있습니다.\n\n## 결론\n\n축하합니다! ReactJS에서 사용자 정의 페이지네이션 구성 요소를 성공적으로 구축했습니다. 프로젝트 설정부터 페이지네이션 로직 구현 및 구성 요소 스타일링까지 모두 다루었습니다. 필요에 맞게 구성 요소를 더 맞춤화하여 자유롭게 사용해보세요.\n\n<div class=\"content-ad\"></div>\n\n이제 여러분 차례입니다! 여러분의 프로젝트에서 이를 시도해보세요. 즐겁게 코딩하세요!\n\n## 도움이 되셨나요? 그렇다면:\n\n아래 👏 버튼을 눌러주셔서 더 많은 사람들이 이를 볼 수 있도록 도와주세요.\n\n## 궁금한 점이 있으신가요?\n\n<div class=\"content-ad\"></div>\n\n제안이나 개선 사항이 있으시면 언제든지 Medium에 의견을 남겨주세요. 또는 Linkedin에서 제게 연락해 주세요. 항상 당신의 의견을 듣고 싶어합니다. 👩‍💻","ogImage":{"url":"/assets/img/2024-06-23-BoostUserExperienceinReactCreateacustompaginationcomponent_0.png"},"coverImage":"/assets/img/2024-06-23-BoostUserExperienceinReactCreateacustompaginationcomponent_0.png","tag":["Tech"],"readingTime":6},{"title":"간단한 React 아코디언 컴포넌트 만들기Props와 Children props 사용","description":"","date":"2024-06-23 13:38","slug":"2024-06-23-SimpleReactAccordionComponentPropsChildrenprops","content":"\n\n\n![SimpleReactAccordionComponentPropsChildrenprops](/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_0.png)\n\n간단한 기본 React 아코디언을 만들 때에는 React의 기본 지식만 필요합니다. React props 및 useState를 사용하여 상태 관리하는 데 일부 기본 기술이 필요합니다.\n\nReact 컴포넌트는 props를 사용하여 서로 통신합니다. 모든 부모 컴포넌트는 자식 컴포넌트에 정보를 전달할 수 있습니다. 부모 컴포넌트에서 자식 컴포넌트로 데이터를 매핑하여 아코디언 항목을 표시하겠습니다.\n\n이 프로젝트에서는 정적 데이터를 사용할 것이며, 외부 API에서 데이터를 전달할 수도 있습니다. 아래는 사용할 데이터입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Img1](/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_1.png)\n\n첫 번째 할 일은 부모 Accordion.jsx 컴포넌트를 생성하는 것입니다. 이 컴포넌트에서 데이터를 AccordionItem.jsx 컴포넌트로 매핑할 것입니다;\n\n![Img2](/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_2.png)\n\n참고: 스타일링은 tailwind css를 사용했습니다\n\n\n<div class=\"content-ad\"></div>\n\n위의 구성 요소에서는 \"currOpen\" 상태를 사용하여 데이터 배열에서 현재 열린 데이터를 결정하므로 true이면 표시되고, 그렇지 않으면 표시되지 않습니다.\n\n데이터를 accordionItem 구성 요소에 매핑할 때 항목과 상태를 프롭으로 전달했는데, 이를 사용하여 자식 구성 요소에서 아코디언을 열고 닫을 수 있습니다.\n\n# 자식 구성 요소 내에서 프롭 읽기\n\n항목, currOpen 및 setCurrOpen과 같은 이름의 프롭을 ('와 ') 사이에 쉼표로 구분하여 AccordionItem 함수 바로 뒤에 나열하여 AccordionItem 코드 내에서 변수처럼 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![SimpleReactAccordionComponentPropsChildrenprops](/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_3.png)\n\n참고: 내 경우에는 외부 버튼 구성 요소를 사용했지만, 일반 버튼 요소를 사용하고 아코디언 상태를 변경하기 위한 onclick 메서드를 추가할 수도 있습니다.\n\n첫 번째로 하는 일은 \"item.Id\"를 \"currOpen\"으로 설정하는 것입니다. 이렇게 하면 한 번에 하나의 아코디언만 열리도록 보장되며, 동시에 두 개의 아코디언을 열 수 없습니다. 이는 상태 관리가 부모 구성 요소에서 제어되기 때문에 가능합니다.\n\ntoggleClick 메서드는 아코디언을 열고 해당 아코디언이 열려 있는지 확인하고 다시 클릭되었는지 확인한 후 상태가 null로 설정되어 아코디언이 닫힙니다.\n\n\n<div class=\"content-ad\"></div>\n\n아코디언이 열리지 않았을 경우, onclick 메서드를 사용하여 toggleClick이 항목의 id를 \"currOpen\"으로 설정한 후 아코디언을 엽니다.\n\n<img src=\"/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_4.png\" />\n\n페이지에서는 다른 아코디언은 닫힌 채로 두고 두 번째 아코디언만 열려 있습니다. 쉽죠!\n\n코딩 즐기세요!","ogImage":{"url":"/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_0.png"},"coverImage":"/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_0.png","tag":["Tech"],"readingTime":2},{"title":"DuckDB를 사용해 SQL 지원 네트워크 데이터베이스로 Pandas DataFrame 활용하는 방법","description":"","date":"2024-06-23 13:37","slug":"2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB","content":"\n\n만약 대규모 데이터셋을 생성하거나 수정한 다음 SQL 준비 데이터로 공유해야 하는 데이터 과학자라면 ChipmunkDB가 답입니다.\n\n![ChipmunkDB](/assets/img/2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB_0.png)\n\n# 대부분의 데이터베이스가 시계열 데이터에 취약한 이유\n\n일단 역사적 주식 데이터의 대규모 데이터셋을 다운로드하여 데이터를 수정하고 일부 지표를 추가한 다음 그 중에서 일부만 쿼리하여 프론트엔드에 표시하려고 할 때 상황을 가정해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n다음은 최소 요구 사항입니다:\n\n- 초당 50MB에서 500MB를 저장할 수 있는 매우 빠른 읽기 및 쓰기 데이터베이스가 필요합니다.\n- 모든 시계열에 대한 새 열을 추가하는 데 초단위로 작업이 완료되어야 하며, 모든 행을 반복하지 않아야 합니다.\n- SQL을 통해 시간 범위 내의 3개 열에 대한 쿼리만 가능해야 합니다.\n- 네트워크 데이터베이스여야 합니다.\n\n위에서 설명한 문제를 해결하기 위해 수백 개의 데이터베이스를 시도했지만, 이 중에서 모든 요구 사항을 충족하는 것은 없었습니다.\n\n# DuckDB는 좋은 솔루션입니다.\n\n<div class=\"content-ad\"></div>\n\n어느 날 DuckDB (https://duckdb.org/)을 우연히 발견했는데, 정말 놀라웠어요. 판다스 데이터프레임을 쉽게 SQL 데이터베이스로 변환할 수 있어요. 또한, 로컬 디스크에 저장하고 로드하는 속도도 숨막히게 빠릅니다.\n\nDuckDB의 유일한 단점은 시계열 데이터에 좀 부족한 부분이 있고, 네트워크 솔루션이 아니다.\n\n그래서 저는 ChipmunkDB를 시작했어요.\n\n# ChipmunkDB가 시계열 데이터에 강력한 이유의 예시입니다\n\n<div class=\"content-ad\"></div>\n\nyahofinance에서 DataFrame 몇 개를 다운로드합시다.\n\n```js\nimport yfinance as yf\n\n# 작은 데이터셋 다운로드\nprices_df = yf.download(tickers=[\"QQQ\", \"NVDA\", \"AMD\", \"AAPL\", \"TSLA\", \"MSFT\"], period='60d', interval='5m')\nprices_df = prices_df.stack()\nprices_df.index.names = ['date', 'symbol']\n\n# 이제 28037행과 6열을 가진 데이터프레임을 가지고 있습니다\n```\n\n이제 이 데이터를 데이터베이스에 매우 빠르게 저장하거나 기존의 시간 범위에 \"첨부\"하고 싶습니다.\n\n```js\nimport time\nfrom chipmunkdb.ChipmunkDb import ChipmunkDb\nchipmunkDb = ChipmunkDb(\"localhost\")\n\n# 데이터프레임을 chipmunkdb에 저장하는 데 걸린 시간 계산해 봅시다\nstart = time.time()\nchipmunkDb.save_as_pandas(prices_df, \"stock_prices\")\nprint(\"저장하는 데 걸린 시간: \", time.time()-start, \" 초\")\n```\n\n<div class=\"content-ad\"></div>\n\n와! 놀라울 정도로 빠릅니다! 데이터를 저장하는 데 190ms밖에 걸리지 않는군요. 다시 실행하면 새로운 행만 추가하기 때문에 60ms만 소요됩니다.\n\n이제 전체 DataFrame을 새로운 판다스 DataFrame으로 다시 읽어봅시다.\n\n```js\n# chipmunkdb에서 DataFrame을 읽어봅시다\nimport time\nfrom chipmunkdb.ChipmunkDb import ChipmunkDb\nchipmunkDb = ChipmunkDb(\"localhost\")\n\n# DataFrame을 다시 로드하고 시간을 측정해봅시다\nstart = time.time()\ndf = chipmunkDb.collection_as_pandas(\"stock_prices\")\nprint(\"로드 시간: \", time.time()-start, \" 초\")\n```\n\n전체 DataFrame을 로드하는 데 73ms가 소요됩니다. 이제 전체 DataFrame을 사용할 수 있고 새로운 열을 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 새 열을 추가합시다\ndf[\"Volume_Quote\"] = df[\"Volume\"] * df[\"Close\"]\n\n# 다시 chipmunkdb에 데이터프레임을 저장하는 데 걸리는 시간을 계산해봅시다\nstart = time.time()\nchipmunkDb.save_as_pandas(prices_df, \"stock_prices\")\nprint(\"저장하는 데 걸린 시간: \", time.time()-start, \" 초\")\n\n```\n\n새로운 \"Volume_Quote\" 열을 추가했고, 이를 ChipmunkDB에 저장했습니다.\n\n# 이제 멋진 DuckDB 지원이 됩니다\n\n하지만 이것은 ChipmunkDB의 많은 멋진 기능 중 하나에 불과합니다. 이제 위에서 생성한 DataFrame의 일부분만 쿼리합니다.\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom chipmunkdb.ChipmunkDb import ChipmunkDb\n# \"NVDA\" 및 \"AAPL\" 심볼에 대한 마지막 10행만 쿼리하겠습니다.\nstart = time.time()\nresults = chipmunkDb.query(\"select index_symbol, LAST(Close) from stock_prices WHERE index_symbol IN ('AAPL', 'NVDA') group by index_symbol \")\nprint(\"쿼리 시간: \", time.time()-start, \" 초\")\n```\n\n덕DB의 지원으로 ChipmunkDB 내부 데이터 프레임에서 SQL 쿼리를 실행할 수 있습니다.\n\n# 현재 클라이언트 라이브러리는 NodeJS 및 Python입니다\n\n2개의 클라이언트 라이브러리를 구축했습니다.\n\n\n<div class=\"content-ad\"></div>\n\nNodeJS 클라이언트 라이브러리는 ChipmunkDB에서 데이터를 쿼리하는 데 중점을 두고 있습니다. pandas DataFrame은 NodeJS에서 지원되지 않기 때문입니다.\n\nPython 클라이언트 라이브러리는 pandas 및 쿼리 기능의 전체 목록을 지원합니다.\n\nPython 클라이언트는 또한 SQL Alchemy 네트워크 기능을 지원합니다. 예를 들어 SuperSet 또는 기타 BI 시스템에서 pandas에서 데이터를 쿼리하는 데 사용할 수 있습니다. (가까운 미래에 관련 이야기를 쓸 예정입니다)\n\n# Docker, ContainerD 또는 Kubernetes에서 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n당신의 환경 안에서 ChipmunkDB를 데이터베이스 저장소로 사용할 수 있는 클라우드 컨테이너를 몇 개 만들었어요.\n\n여기서 헬름 차트를 찾을 수 있어요:\n\n그리고 여기서 도커 컨테이너를 찾을 수 있어요:\n\n# ChipmunkDB의 개발 계획\n\n<div class=\"content-ad\"></div>\n\n길고도 험난한 여정이긴 하겠지만, 다음 기능 업데이트 계획이 있어. \n\n- 클라이언트 라이브러리 업데이트\n- 컬렉션에 스키마 지원으로 JOIN 지원\n- 컬렉션 업데이트를 받기 위한 웹훅 지원 추가\n- 인증 지원 추가\n- 컬렉션에서 변경 사항을 찾기 위한 로그 엔진 지원\n- PgAdmin 지원 추가","ogImage":{"url":"/assets/img/2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB_0.png"},"coverImage":"/assets/img/2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB_0.png","tag":["Tech"],"readingTime":4},{"title":"파이썬으로 탐구하고 이해하는 석유물리학의 방정식들","description":"","date":"2024-06-23 13:36","slug":"2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics","content":"\n\n\n![Image](/assets/img/2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics_0.png)\n\n기술적인 주제를 학습할 때, 산유물리학 등 많은 방정식과 관련이 있는 경우, 모든 매개변수가 어떻게 관련되는지 이해하기 어려울 수 있습니다.\n\n여러 해 전에 산유물리학을 시작할 때, 저는 Archie Water Saturation 방정식과 같은 일반적인 방정식을 탐구하기 위해 Excel을 사용했습니다. 이 방법은 각 매개변수가 계산 결과에 미치는 영향을 이해하는 좋은 방법이었습니다.\n\n본 문서에서는 Python을 사용하여 방정식의 다른 매개변수가 결과에 미치는 영향을 배우고 이해하는 세 가지 방법을 살펴볼 것입니다. 사용된 예시 방정식은 암석 내에 채워진 물의 양을 계산하는 Archie Water Saturation (Sw) 방정식입니다. 이를 통해 암석 내에 얼마나 많은 탄화수소가 함유되어 있는지 추정할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n만약 석유물리학에 익숙하지 않다면, 동일한 작업 흐름과 예제를 원하는 방정식에 적용할 수 있습니다. 당신이 원하는 데이터를 보여주기 위해 최종 예제를 조정해야 할 수도 있습니다.\n\n# 함수로 간단한 방정식\n\n방정식을 탐색하는 가장 간단한 방법은 계산을 수행하는 함수를 만드는 것입니다. 이 함수는 여러 매개변수를 받아들이며, 각각의 매개변수에는 기본값이 할당됩니다.\n\n매개변수에 대한 기본값을 제공함으로써, 우리는 각각의 값을 매번 입력하는 대신 원하는 매개변수를 변경할 수 있게 됩니다. 예를 들어, rt 매개변수를 변경하려면, 다음과 같이 함수를 호출할 수 있습니다: archie_sw(rt=100)\n\n<div class=\"content-ad\"></div>\n\n```js\ndef archie_sw(a=1, phi=0.15, m=2, rw=0.2, rt=200, n=2):\n    Sw = ((a / phi**m) * (rw / rt))**(1/n)\n    return Sw\n```\n\n하지만, 일단 함수를 호출하고 매개변수를 제공하지 않으면 기본 값이 사용됩니다.\n\n```js\narchie_sw()\n```\n\n그리고 이 결과는 Sw가 됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\n0.21081851067789195\r\n```\n\n만약 투과성 (a) 및 다공성 (phi) 매개변수를 변경하면 다음과 같습니다:\n\n```js\r\narchie_sw(a=1.2, phi=0.25)\r\n```\n\n새로운 Sw 값이 반환됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n0.13856406460551018\n```\n\nArchie 방정식의 매개변수를 탐색하는 좋고 간단한 방법이지만 값들을 바꾸고 셀을 다시 실행해야 하는 것은 매우 지루하고 시간이 많이 소요될 수 있습니다.\n\n# ipywidgets를 사용한 상호 작용성 생성\n\n파라미터를 변경할 때마다 함수를 다시 실행하고 호출해야 하는 번거로움 대신 노트북 내에서 대화형 위젯을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 작업은 ipywidgets에서 위젯을 가져와 각 매개변수에 연결된 여러 하위 위젯을 설정하는 것으로 완료됩니다.\n\n먼저, 몇 가지 모듈을 가져와야 합니다. 첫 번째로는 ipywidgets에서 위젯들을 가져오고, 노트북 안에 위젯들을 표시하기 위해 IPython.display에서 display를 가져와야 합니다.\n\n다음으로, Archie Water Saturation 방정식과 관련 매개 변수들을 선언합니다. 이 함수는 그런 다음 update_widget 함수 내에서 호출됩니다. \n\n마지막으로, 표시할 위젯들과 그 종류, 기본값 및 허용 값 범위를 설정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport ipywidgets as widgets\nfrom IPython.display import display\n\n# Archie's Equation function\ndef archie_sw(a, PHI, m, Rw, Rt, n):\n    Sw = ((a / PHI**m) * (Rw / Rt))**(1/n)\n    return Sw\n\n# Interactive widget\ndef update_widget(a=1, PHI=0.2, m=2, Rw=0.1, Rt=2, n=2):\n    Sw = archie_sw(a, PHI, m, Rw, Rt, n)\n    print(f\"Water Saturation (Sw): {Sw:.2f}\")\n\nwidgets.interact(update_widget, \n                 a=widgets.FloatSlider(value=1, min=0.1, max=5, step=0.1, description='a:'),\n                 PHI=widgets.FloatSlider(value=0.2, min=0.01, max=0.4, step=0.01, description='PHI:'),\n                 m=widgets.FloatSlider(value=2, min=1, max=4, step=0.1, description='m:'),\n                 Rw=widgets.FloatSlider(value=0.1, min=0.01, max=1, step=0.01, description='Rw:'),\n                 Rt=widgets.FloatSlider(value=2, min=1, max=100, step=1, description='Rt:'),\n                 n=widgets.FloatSlider(value=2, min=1, max=4, step=0.1, description='n:'))\n```\n\n위 코드를 노트북에서 실행하면 다음과 같이 상호 작용하는 슬라이더가 표시됩니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:656/1*tKwrqeihgZYjPbCbbP4dyw.gif\" />\n\n슬라이더 중 하나를 조절하면 해당 Sw 값이 자동으로 업데이트됩니다.\n\n<div class=\"content-ad\"></div>\n\n# Jupyter에서 ipywidgets 사용하기 (데이터프레임 + 로그 플롯)\n\n암상해석을 다룰 때는 하나의 데이터 포인트가 아닌 연속된 데이터를 다루는 경우가 많습니다. 이전 방법은 하나의 Sw 값에 대해 각 매개변수와 그 영향을 탐색하려는 경우 간단하게 유지됩니다.\n\n우리는 위에서 한 작업을 확장하여 실제 데이터를 사용하고 어떤 매개변수가 변경되면 업데이트되는 기본 로그 플롯을 만들 수 있습니다.\n\n이 예시에서 공개적으로 사용 가능한 볼브(Volve) 데이터셋에서 포로시티( phi ) 커브와 저항도( rt ) 커브를 가지고 있습니다. 두 가지 모두 아키 워터 포화방정식의 필수 입력값입니다.\n\n<div class=\"content-ad\"></div>\n\n남은 매개변수를 조정하여 전체 저수지 부분에 미치는 영향을 설명할 수 있습니다.\n\n가장 위에 있는 서브플롯(트랙)에서 우리는 기본 매개변수를 사용하여 계산된 물 포화도를 기준으로 합니다. 이것은 대화식 매개변수를 사용하여 계산된 결과와 함께 플로팅됩니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*ousiE50m2vaWq5ME7RykYw.gif)\n\n상기 플롯을 생성하려면 다음 코드를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nfrom IPython.display import display\n\ndf = pd.read_csv('../data/Volve/15_9-19.csv', usecols=['DEPTH','PHIT', 'GR','RT'], na_values=-999)\n\n#Extract a small depth interval\ndf = df.query('3800 <= DEPTH <= 4100')\n\ndef archie_sw(a=1, phi=0.15, m=2, rw=0.2, rt=200, n=2):\n    Sw = ((a / phi**m) * (rw / rt))**(1/n)\n    return Sw\n\ndf['SW_ARCH_BASE'] = df.apply(lambda row: archie_sw(phi=row['PHIT'], rt=row['RT']), axis=1)\n\n@widgets.interact(a=(0.5, 1.5, 0.05),\n                  m=(1.5, 2.5, 0.05),\n                  rw = (0.1, 10, 0.1),\n                  n=(1.5, 2.5, 0.05))                  \ndef update_plot(a=1, m=2, rw=1, n=2):\n    depth = df['DEPTH']\n\n    df['SW_ARCH_NEW'] = df.apply(lambda row: archie_sw(phi=row['PHIT'], rt=row['RT'], \n                                                      a=a,\n                                                      m=m,\n                                                      rw=rw,\n                                                      n=n), axis=1)\n    \n    fig, ax = plt.subplots(nrows=4, ncols=1, sharex=True, figsize=(20, 10))\n    \n    ax[0].plot(depth, df['SW_ARCH_BASE'], c='k')\n    ax[0].plot(depth, df['SW_ARCH_NEW'], c='red')\n    ax[0].fill_between(depth, 1, df['SW_ARCH_NEW'], color='green')\n    ax[0].fill_between(depth, 0, df['SW_ARCH_NEW'], color='skyblue')\n\n    ax[1].plot(depth, df['RT'], c='k')\n    ax[2].plot(depth, df['PHIT'])\n    ax[3].plot(depth, df['GR'], c='green')\n\n    ax[0].set_ylim(0, 1.0)\n    ax[1].semilogy()\n    ax[2].set_ylim(0, 0.5)\n    ax[3].set_ylim(0, 150)\n\n    ax[0].set_ylabel('SW')\n    ax[1].set_ylabel('RT')\n    ax[2].set_ylabel('PHIT')\n    ax[3].set_ylabel('Gamma')\n    \n    plt.show()\n```\n\n# 요약\n\n학습 프로세스를 보다 인터랙티브하게 만들수록 학습한 정보를 더욱 잘 보존할 가능성이 높아집니다.\n\n이 글에서는 파이썬을 사용하여 석유물리학의 기본 방정식을 이해하는 데 도움이 되는 세 가지 다른 간단한 방법을 소개했습니다. 최종 예제에서 매개변수를 인터랙티브하게 만들어 실제 데이터에 대한 각각의 영향을 탐색할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 사용된 데이터셋\n\n이 튜토리얼에서 사용된 데이터는 2018년 Equinor가 공개한 Volve 데이터셋의 일부입니다. 데이터셋의 자세한 내용 및 라이선스는 아래 링크에서 확인할 수 있습니다.\n\n[Volve field data set download — Equinor](링크)\n\nVolve 데이터 라이선스는 CC BY 4.0 라이선스를 기반으로 합니다. 라이선스 협약의 자세한 내용은 여기에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nhttps://cdn.sanity.io/files/h61q9gi9/global/de6532f6134b9a953f6c41bac47a0c055a3712d3.pdf?equinor-hrs-terms-and-conditions-for-licence-to-data-volve.pdf\n\n읽어 주셔서 감사합니다. 나가시기 전에 반드시 내 콘텐츠를 구독하고 제 문서를 이메일로 받아보세요. 여기에서 구독할 수 있어요! 이 콘텐츠를 즐겼고 감사의 표시를 하고 싶으시다면 손뼉을 몇 번 치시는 것도 좋아요.","ogImage":{"url":"/assets/img/2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics_0.png"},"coverImage":"/assets/img/2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics_0.png","tag":["Tech"],"readingTime":7},{"title":"탁월한 프로그래머의 상위 10가지 습관","description":"","date":"2024-06-23 13:34","slug":"2024-06-23-TheTop10HabitsofExceptionalProgramers","content":"\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_0.png)\n\n이 세상에는 소프트웨어 개발에 열정적인 수백만 명의 사람들이 있습니다. 이들은 소프트웨어 엔지니어, 프로그래머, 코더, 개발자 등 다양한 이름으로 알려져 있습니다. 시간이 지나면서 이들은 능숙한 코더가 되어 컴퓨터 언어를 사용하여 작업을 수행하는 방법에 매우 익숙해집니다.\n\n그러나 프로그래머로 진정으로 뛰어나려면 몇 가지 추가적인 요소를 고려해야 합니다. 뛰어난 프로그래머가 되고 싶다면 특별히 주의해야 할 습관이 있습니다. 이 열 가지가 당신의 습관이 되어야만 참으로 우수한 프로그래머로 간주될 수 있습니다.\n\n# 1. 학습은 끝없는 여정입니다\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_1.png\" />\n\n프로그래밍 경험 10년이 넘게 쌓았다 해도, 끊임없는 지식 탐구는 여전히 중요합니다. 컴퓨터의 끝없는 발전 세계에서 창의력이 번성하여 매일 다양한 혁신이 탄생합니다. 시대에 발맞추기 위해 새로운 프로그래밍 언어와 새로운 프레임워크를 지속적으로 익히는 것이 중요합니다. 산업 소식을 파악하고 활기찬 커뮤니티 내에서 온라인 토론에 적극적으로 참여하여 소프트웨어 개발 트렌드의 펄스를 파악하는 것이 필수적입니다.\n\nGitHub, Stack Overflow, TechCrunch 등의 훌륭한 플랫폼은 귀중한 통찰과 리소스를 제공합니다. Reddit, Medium과 같은 세계적으로 인정받는 플랫폼은 다양한 블로그를 종합하여 기술적 발전의 종합적인 시각을 제공합니다. 이러한 지속적인 학습의 정신을 수용하는 것은 경력 있는 프로그래머들에게 필수적이며, 소프트웨어 개발의 역동적인 세계에서 탁월함을 향상시킬 수 있습니다.\n\n#2. 새로운 것에 열린 마음\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_2.png\" />\n\n우수한 프로그래머들의 영역에서 \"새로운 것에 열려있다\"는 그저 경솔한 태도보다는 지속적인 성장과 혁신을 이끄는 기본적인 마음가짐이라는 것을 인지해야 합니다. 우수한 프로그래머들은 기술 영역이 지속적으로 발전하고 새로운 언어, 도구 및 방법론이 지속적으로 등장하는 것을 알아차립니다. 낡은 관행에 집착하거나 기존 지식에 안주하지 않고, 새로운 기술과 접근법을 기꺼이 수용합니다.\n\n이 새로운 것에 대한 개방은 다음과 같은 여러 가지 키 요소로 나타납니다:\n\n- 호기심: 우수한 프로그래머들은 기술 세계에 대한 자연스러운 호기심을 가지고 있습니다. 글을 읽거나 워크샵에 참여하거나 자유 시간에 새로운 도구를 시도하는 등 새로운 정보를 적극적으로 찾습니다.\n- 적응성: 소프트웨어 개발의 빠른 세계에서 적응력은 필수적입니다. 우수한 프로그래머들은 기술, 산업 트렌드 또는 프로젝트 요구사항의 변화에 신속히 대응하여 자리를 유지하고 역할에서 효과적으로 활동합니다.\n- 실험: 우수한 프로그래머들은 편안한 지역을 벗어나 새로운 것을 시도하는 데 두려워하지 않습니다. 혁신은 종종 실험에서 나온다는 것을 이해하고, 새로운 아이디어나 접근법을 탐구하기 위해 계산된 위험을 감당하려고 합니다.\n- 협업: 새로운 것에 개방되어 있다는 것은 다른 사람들로부터 의견과 협업을 받아들일 수 있다는 것을 의미합니다. 우수한 프로그래머들은 다양한 시각을 중요시하며, 다른 사람과 협력함으로써 새로운 통찰력과 돌파구를 찾을 수 있다는 것을 인지합니다.\n\n<div class=\"content-ad\"></div>\n\n# 3. 여러 언어를 습득하세요\n\n![image](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_3.png)\n\n프로그래밍 언어마다 가장 적합한 영역이 있습니다. 해결해야 할 문제에 직면했을 때, 해당 문제를 해결하기에 가장 적합한 언어를 식별해야 합니다.\n\n예를 들어, 성능이 중요한 경우 C/C++이 선호될 수 있습니다. 다중 플랫폼 호환성이 중요한 경우 Java가 가장 적합할 수 있습니다. 웹 개발의 경우 PHP, ASP, Ajax 및 JSP와 같은 언어들을 선택할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n텍스트 처리 및 다른 응용 프로그램과 상호 작용할 때, Perl과 Python이 빛이 나는 경우가 많습니다. 따라서 아직 익숙하지 않은 다른 프로그래밍 언어를 탐험하는 데 시간을 투자해보세요. 시야를 넓힘으로써 여러분의 무기함을 강화하고, 보다 포괄적인 문제 해결이 가능해집니다. 이는 여러분과 프로젝트에 큰 혜택을 줄 것입니다.\n\n# 4. 다른 운영 체제나 기술에 이성적으로 접근하기\n\n![TheTop10HabitsofExceptionalProgramers_4](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_4.png)\n\n프로그래머들은 종종 우분투, 데비안, 윈도우, FreeBSD, MacOSX, 솔라리스 등 자신만의 선호하는 기술과 운영 체제를 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n일부 우수한 프로그래머들만이 서로 다른 운영 체제의 강점, 약점 및 세부 사항을 정말로 이해합니다. 이러한 이해는 그들이 감정적 편향 없이 시스템을 선택할 때 객관적이고 중립적인 결정을 내릴 수 있도록 합니다.\n\n마찬가지로, 프로그래밍 언어의 선택은 프로그래머들 사이에서 논쟁거리가 될 수 있습니다. Java와 Perl 같은 언어 또는 VC++과 Delphi와 같은 플랫폼을 비교하는 토론은 흔합니다. 그러나 이러한 논쟁에 참여하면 종종 깊이 있는 통찰보다 피상적이고 성급한 면을 보여줄 뿐입니다.\n\n우수한 프로그래머들은 이러한 방해 요소를 넘어서며 이성적인 분석과 명쾌한 사고로 언어와 플랫폼 선택에 접근합니다. 바로 이러한 이성적인 태도가 그들이 감정적인 부착이나 편향을 받지 않은 판단을 내릴 수 있게 합니다.\n\n\n# 5. 코드 관리를 위해 버전 관리 도구 활용하기\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_5.png)\n\n버전 관리 도구인 GitHub과 같은 도구를 적극적으로 활용하여 코드베이스를 효과적으로 관리하세요. 개발자가 버전 관리의 중요성을 무시할 여유가 있던 시절은 이미 지나갔습니다. 소스 코드 버전 관리의 이점을 모르겠다면, 산업 표준에 뒤쳐지지 않도록 이를 이해하는 것이 시급합니다.\n\nGitHub을 고려해보세요. 이 플랫폼은 강력한 버전 관리 기능으로 유명하며, 협업을 최적화하고 프로젝트 관리를 향상시키기 위한 다양한 기능에 액세스할 수 있습니다. 다수의 기여자 간 변경 사항 추적부터 인기 있는 개발 흐름과의 원활한 통합을 통해, GitHub은 현대 소프트웨어 개발 팀의 요구에 맞는 포괄적인 솔루션을 제공합니다.\n\n오해하지 마세요: 버전 관리 시스템을 구현하지 않는 것은 구식 관행에 고수하는 것과 같습니다. 민첩성과 협업이 요구되는 급변하는 개발 환경에서, 버전 관리를 받아들이는 것은 선택이 아닌 필수입니다.\n\n<div class=\"content-ad\"></div>\n\n# 6. 훌륭한 팀 플레이어가 되기\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_6.png)\n\n혼자서 즐거워하는 것이 아니라면, 혼자 늑대라고 생각하는 것이 아니라면, 오늘날 거의 모든 성숙한 소프트웨어 프로젝트를 혼자서 성취하기 어렵습니다. 당신이 팀의 MVP일지라도, 그것만으로는 훌륭한 팀 플레이어가 되는 것은 아닙니다. 당신의 스킬은 진정으로 빛을 발할 때 협업 노력의 한 부분일 때입니다.\n\n팀원들과 의사 소통을 할 때 공손한가요? 정기적으로 소통하고 모든 사람이 문제를 편안하게 논의할 수 있는 환경을 조성하나요? 축구 팀을 상상해보세요 - 다른 사람들과 잘 어울리나요? 경기장에서의 당신의 행동이 동료를 도와주나요? 당신의 스프린트, 패스 또는 태클을 통해 동료들을 영감을 주나요?\n\n<div class=\"content-ad\"></div>\n\n그러니까, 게임을 혼자 이기기 위해 계획이 없다면, 팀워크의 중요성을 받아들이세요. 다른 사람들의 기술과 노력과 결합할 때 당신의 기여는 더욱 커집니다. 자신만이 아닌 전체 팀을 끌어올리는 선수가 되어보세요.\n\n# 7. 작업을 문서화로 변환하기\n\n![image](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_7.png)\n\n이 지침은 당연히 코드에 주석을 달아야 한다는 것을 포함하지만, 그것이 시작에 불과합니다. 더 많은 일을 해야 합니다. 명확하고 간결한 주석이 달린 코드는 문서화의 기초를 형성하여 당신과 팀이 당신의 의도와 생각을 이해하기 쉽게 만듭니다. 당신의 작업을 문서화하는 것은 당신의 사고과정을 상기시키는 것뿐만 아니라 팀 내 오프라인 커뮤니케이션 수단 및 지식 전달 수단으로 작용합니다. 당신이 알고 있는 것을 모두 문서화하는 습관은 귀중합니다.\n\n<div class=\"content-ad\"></div>\n\n자, 솔직히 말해서, 가장 바쁠 때 다른 사람들이 계속 질문을 던지거나 휴가 중에 회사에서 전화를 받아 일에 관해 물어 들을 때 참기 어려운 건 아닐 겁니다. 당신의 지식을 저장함으로써, 당신은 자신의 영역에 갇히기만 할 뿐 더 많이 하기 위한 시간을 남기지 못할 것입니다. \"제자를 가르치면 선생님은 굶어죠\"라고 생각할 수도 있지만, 당신의 보수적인 태도는 당신이 더 큰 기회를 놓칠 뿐입니다. 믿어봐요, 저는 이 사항을 과장하려는 게 아니에요.\n\n# 8. 백업과 보안\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_8.png)\n\n백업의 중요성을 이미 알고 있기 때문에 이것이 \"뻔한 얘기\"라고 생각할 수 있겠지만, 여전히 강조하고 싶습니다. 물건을 잃는 것은 삶의 한 부분이며, 피할 수 없는 손실을 항상 경험하게 될 것입니다. 예를 들어, 노트북이 도난당할 수 있고, 하드 드라이브가 고장날 수 있으며, 컴퓨터에 바이러스가 감염될 수 있고, 시스템이 해킹당할 수도 있으며, 건물 전체가 불이 날 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그러므로 적절한 백업을 보장하는 것이 매우 중요합니다. 하드 드라이브는 믿을 수 없으므로 규칙적으로 CD나 테이프를 복사하는 것이 좋은 방법일 수 있습니다. 네트워크도 믿을만하지 않으니 바이러스와 해커에 대해 조심해야 합니다. 소프트웨어 기반 보안 조치만 사용하는 것뿐만 아니라 견고한 관리 시스템도 필요합니다. 또한, 데이터를 다른 위치에 저장하고 일일, 주간, 월간으로 정기적인 백업 전략을 수립하는 노력도 필요합니다.\n\n# 9. 발을 쏴버리지 않기\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_9.png)\n\n프로그래머들은 자신의 작업을 빨리 끝내려는 안 좋은 습관을 가지고 있습니다. 그러나 일은 항상 예정대로 진행되지 않습니다. 서두르면 서두를수록 문제가 발생할 가능성이 높아지거나 문제를 완전히 놓치게 됩니다. 결국 처음부터 충분한 시간을 들인다면 문제를 고치는 데 소비하는 시간과 에너지가 더 적게 들 것입니다. 서두르다가 오류가 나게 되니 서두르지 마세요.\n\n<div class=\"content-ad\"></div>\n\n우수한 프로그래머들의 습관은 추가 시간을 투자하여 다양한 해결책을 실험하고 조사하는 것입니다. 시간이 허용된다면, 프로그래밍 3시간마다 휴식을 취하고 다음 3시간에 다시 시작하는 것이 좋은 습관입니다.\n\n물론, 이는 사람에 따라 다를 수 있지만, 핵심은 꾸준히 진행 상황을 되돌아보고 자신에게 세 가지 질문을 던지는 것입니다:\n\n- 이 방법이 옳은가요?\n- 모든 가능한 시나리오를 고려했나요?\n- 더 나은 방법이 있을까요? 고민하고, 주기적으로 진행 상황을 검토하고 지난 경험을 되짚어보세요. 이 습관은 장기적으로 큰 도움을 줄 것입니다.\n\n# 10. 불편함에 익숙해지는 법을 배웁니다\n\n<div class=\"content-ad\"></div>\n\n![2024-06-23-TheTop10HabitsofExceptionalProgramers_10](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_10.png)\n\n이것은 성장과 발전의 필수적인 부분으로 불편함을 받아들이는 아이디어를 총망라하고 있습니다. 프로그래밍과 같은 전문적인 노력뿐만 아니라 인생의 다양한 측면에서 진전을 이루려면 자신의 편안한 영역을 벗어나서 익숙하지 않거나 어려울 수 있는 과제에 도전해야 합니다.\n\n프로그래머에게는 다음과 같은 개념이 함축됩니다:\n\n- 도전 수용: 어려운 과제나 익숙하지 않은 기술을 피하지 않고, 성공적인 프로그래머는 도전에 직면하기를 원합니다. 그들은 장애물을 극복하는 것이 학습과 성장의 필수적인 부분이라고 인식합니다.\n- 성장 기회 탐색: 안락함은 타성을 낳으며, 불편함은 성장을 촉진합니다. 우수한 프로그래머는 새로운 프로젝트를 맡거나 새로운 프로그래밍 언어를 배우거나 경계를 넓히는 복잡한 문제에 도전함으로써 스스로를 발전시키는 기회를 적극적으로 찾습니다.\n- 변화 대응: 기술의 빠른 세계에서 변화는 불가피합니다. 불편함을 받아들이는 프로그래머는 새로운 기술, 방법론 및 산업 동향에 적응하는 데 더 유연하게 대처하여 현재보다 앞섰고 분야에서 중요한 위치를 유지할 수 있습니다.\n- 탄력성 구축: 불편함을 받아들이는 것은 또한 탄력성을 키웁니다 - 실패로부터 튀어 올라오고 역경 속에서 끈질기게 버텨내는 능력입니다. 계획대로 되지 않을 때, 탄력 있는 프로그래머들은 실수에서 배우고 솔루션을 반복해 나가며 궁극적으로 성공을 거둘 수 있는 능력을 더 좋게 갖출 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_0.png"},"coverImage":"/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_0.png","tag":["Tech"],"readingTime":7},{"title":"데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드","description":"","date":"2024-06-23 13:33","slug":"2024-06-23-TheLatestinDataEngineering","content":"\n\n## 주요 개발 사항 및 그 영향\n\n최근 몇 주 동안 DuckDB, Snowflake, DataBricks 및 Polars에서 중요한 발표를 통해 데이터 엔지니어링 분야가 상당히 발전하고 있습니다. 이러한 발전은 데이터 생태계 내 중요성과 혁신의 증가를 강조하고 있습니다. 제 평소의 글과는 다르지만, 최근 이러한 발표들을 살펴보고 데이터 엔지니어링의 미래에 대해 어떤 의미를 갖을지 알아보겠습니다.\n\n![이미지](/assets/img/2024-06-23-TheLatestinDataEngineering_0.png)\n\n# 뉴스 속으로\n\n<div class=\"content-ad\"></div>\n\n## DuckDB v1.0.0 릴리스\n\nDuckDB는 SQL OLAP 데이터베이스 관리 시스템으로, 1.0.0 마일스톤에 도달했습니다. DuckDB에 대한 별도의 기사를 썼는데, 여기서 더 많은 정보를 찾을 수 있습니다. 이번 릴리스인 \"Nivis\"는 신화 속 눈오리 오리 이름을 지어 안정성과 하위 호환성을 강조했습니다. 대규모 테이블을 전체 트랜잭션 의미론과 최신 압축 기술을 사용하여 관리할 수 있도록 하는 DuckDB의 사용자 정의 저장 형식은 이제 버전 간 호환성을 보장합니다. 이 릴리스는 DuckDB의 성숙성과 신뢰성을 나타내며 데이터베이스 운영에 안정적인 선택지로 만듭니다. 릴리스에 대한 링크는 여기에서 확인할 수 있습니다.\n\n## Snowflake의 Polaris, 오픈 소스 아이스버그 카탈로그\n\nSnowflake은 Apache Iceberg를 위한 벤더 중립적 카탈로그 구현인 Polaris를 공개했습니다. 오픈 소스로 나아가는 이 전략적인 움직임은 데이터 관리 커뮤니티에서 보다 큰 협력과 표준화를 촉진하기 위한 것입니다. Polaris는 앞으로 3개월 동안 오픈 소스로 공개될 예정이며, Snowflake의 상호 운용성과 혁신에 대한 약속을 강화합니다. 오픈 소스를 채택함으로써 Snowflake는 생태계의 유연성을 향상시켜 사용자가 다양한 플랫폼에서 데이터를 보다 효율적으로 관리하고 쿼리할 수 있도록 합니다. 릴리스에 대한 링크는 여기에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## DataBricks 오픈소스 Unity 카탈로그\n\n스노우플레이크의 발표에 반응하여 DataBricks는 Unity 카탈로그를 오픈소스로 공개하기로 결정했습니다. 이 카탈로그는 Iceberg, Hudi 및 Delta 데이터 레이크하우스 파일 형식을 지원하여 현대적인 데이터 관리 필요에 대한 포괄적인 솔루션을 제공합니다. 이 오픈소스 코드는 오늘부터 GitHub에서 사용 가능할 것이며, 투명성 및 커뮤니티 기반의 향상을 촉진할 것입니다. 이러한 조치는 고급 데이터 관리 도구에 대한 접근을 민주화할 뿐만 아니라 DataBricks를 오픈소스 데이터 생태계의 선도 업체로 위치시킵니다. DataBricks 웹사이트에서 아직 정보를 찾을 수 없지만, PR Newswire에서 링크를 확인할 수 있습니다.\n\n## Polars v1.0.0 곧 출시 예정\n\nRust로 작성된 고성능 DataFrame 라이브러리인 Polars는 앞으로 몇 주 안에 1.0.0 버전을 출시할 예정입니다. 현재 1.0.0 버전은 여기에서 알파 버전으로 제공됩니다. 다중 코어 프로세서를 활용하여 빠른 데이터 처리를 지원하는 능력으로 알려진 Polars는 대규모 데이터 분석용 Pandas의 매력적인 대안을 제공합니다. 이 도구는 여러 기술 문서에 사용하는 내 선택 도구이며, 제 GitHub 계정에서 강력하게 활용될 것입니다. 이 출시는 다양한 새로운 기능과 성능 향상을 가져와서 Python을 사용하는 데이터 엔지니어들에게 필수적인 도구로서의 입지를 더욱 굳히게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## DataBricks가 Tabular를 인수했습니다\n\n전략적으로 DataBricks가 Iceberg 테이블 형식의 창시자들에의해 설립된 Tabular를 인수했습니다. 이번 인수는 Tabular의 전문지식과 기술을 DataBricks 플랫폼에 통합하여 대용량 데이터 형식을 처리하는 능력을 강화하는 것을 목표로 합니다. 병합은 데이터 저장 및 관리에 혁신을 도모해 사용자들에게 더 견고하고 확장 가능한 솔루션을 제공할 것으로 예상됩니다.\n\n# 데이터 엔지니어링의 미래에 대한 영향\n\n이러한 발표들은 오픈 소스 솔루션, 상호운용성 및 향상된 데이터 관리 능력으로 나아가는 일반적인 추세를 반영합니다. 이러한 발전들이 데이터 엔지니어링의 미래에 미치는 의미는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 향상된 안정성과 신뢰성: DuckDB의 v1.0.0 릴리스에서 안정성에 대한 강조는 다른 데이터베이스 관리 시스템에 선례를 제공합니다. 신뢰성 있고 하위 호환성 있는 시스템은 데이터 무결성과 가용성이 중요한 기업 애플리케이션에서 필수적입니다.\n- 오픈 소스 우위: Snowflake와 DataBricks의 오픈 소스 노력은 커뮤니티 기반 개발과 협업의 중요성을 강조합니다. 오픈 소스 프로젝트는 다른 성공적인 오픈 소스 데이터베이스 및 도구들과 마찬가지로 빠른 혁신과 채택을 이끌어냅니다.\n- 향상된 데이터 상호 운용성: Polaris와 Unity Catalog의 오픈 소스화와 같이 벤더 중립 카탈로그의 도입으로 다양한 시스템 간 데이터 관리 및 쿼리가 더욱 원활해질 것입니다. 이러한 상호 운용성은 다양한 데이터 소스와 형식을 다루는 기관에 중요합니다.\n- 성능 최적화: Polars와 DuckDB와 같은 도구들은 고성능 데이터 처리 라이브러리의 필요성을 강조합니다. 데이터 양이 계속해서 증가함에 따라 효율적인 데이터 처리는 실시간 분석과 의사 결정에 중요할 것입니다.\n- 전략적 인수: DataBricks가 Tabular를 인수한 것은 플랫폼 기능을 향상시키기 위해 전문 지식과 기술을 통합하는 추세를 보여줍니다. 기업이 데이터 관리 솔루션을 강화하려는 노력으로 이러한 전략적 움직임은 계속될 것입니다.\n\n# 결론\n\n저는 오픈 소스의 팬이라서 이러한 발표들이 나를 흥분시킵니다. 안정성, 오픈 소스 협업 및 성능 향상에 초점을 맞추면, 데이터 엔지니어링의 미래는 밝아 보입니다. 이러한 혁신은 기업이 데이터를 더 효과적으로 처리하고 더 나은 통찰과 비즈니스 결과를 이끌어내도록 할 것입니다. 앞으로 나아가면서, 이러한 트렌드를 주시하는 것은 데이터 전문가가 끊임없이 변화하는 데이터 생태계에서 앞서 나가기 위한 중요한 요소가 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-23-TheLatestinDataEngineering_0.png"},"coverImage":"/assets/img/2024-06-23-TheLatestinDataEngineering_0.png","tag":["Tech"],"readingTime":4},{"title":"HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법","description":"","date":"2024-06-23 13:31","slug":"2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs","content":"\n\n현재 인터넷 트래픽의 약 30%는 봇, 스파이더 및 크롤러에 의해 생성됩니다. 이들은 다양한 목적으로 웹을 스캔하는 자동화 프로그램입니다.\n\n이 프로그램 중 일부는 다음과 같은 중요한 인터넷 작업을 수행합니다:\n\n- 검색 엔진 인덱싱\n- 성능 모니터링\n- 인터넷 매핑\n- 선의의 취약점 스캔\n\n해당 주제에서 제가 찾을 수 있는 가장 포괄적인 목록은 클라우드플레어의 목록입니다.\n\n<div class=\"content-ad\"></div>\n\n# 합법적인 또는 조작된 것인가요?\n\n좋은 크롤러 외에도, 다른 많은 봇들은 단순히 자원을 낭비하거나 비패치된 취약점을 악용하려 하거나 웹사이트의 콘텐츠를 훔치려고 시도하는 경우가 많습니다.\n\n좋은 봇과 나쁜 봇을 구분하는 것은 어려운 주제입니다. 몇몇 영리한 봇은 사용자 에이전트 필드를 조정하여 실제로 보이도록 속이려고 합니다. 사용자 에이전트 필드는 브라우저가 웹사이트로 보내는 것이며, 자기 자신을 식별하는 방법입니다.\n\n```js\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:35.0) Gecko/20100101 Firefox/35.0\n```\n\n<div class=\"content-ad\"></div>\n\n그래도 프로그래밍으로 요청을 보낼 때, 어떤 개발자든 해당 요청에 원하는 사용자 에이전트를 설정할 수 있어요. 그래서 HTTP 요청이 필수적인 봇에서 시작되었는지를 확인하는 방법은 사용자 에이전트 값을 살펴보는 것 뿐이에요.\n\n## robots.txt는 어떤가요?\n\n웹사이트 루트에 위치한 robots.txt 파일은 자동화된 요청에 대한 해당 웹사이트의 정책을 나타냅니다. 크롤러(또는 프로그램)가 지시 사항을 존중하고 이행하는 것은 그들에 달려 있어요.\n\n# 원본 확인\n\n<div class=\"content-ad\"></div>\n\n다행히도, 주요 인터넷 업체들은 명확한 확인 지침을 제공하고 최신 IP 목록을 유지하고 있습니다. 이를 통해 누구든지 특정 서비스에서 오는 임의의 요청인지 여부를 확인할 수 있습니다.\n\n지금 당장, 이 정보를 공유하는 기업들 사이에 공통 표준이 없습니다. 이 공통 표준의 부재는 괜찮습니다; 웹에는 더 많은 대화가 필요합니다 — 더 많은 규제가 아닌요.\n\n아래를 읽어보세요.\n## Google\n\n<div class=\"content-ad\"></div>\n\nGoogle은 사전 정의된 URL에서 제공되는 JSON 형식(기계가 읽을 수 있는 형식)으로 봇 IP 범위를 공개합니다. Google은 현재 세 가지 주요 크롤러를 운영 중입니다:\n\n- GoogleBot — Google 검색용 초기 크롤러\n- GoogleBot Special + AdsBot — 광고 및 기타 서비스\n- GoogleBot User Triggered — 사용자 요청에 따른 색인 작업\n\n## Bing\n\nMicrosoft는 검색 결과를 개선하기 위해 BingBot을 사용하며, Google과 동일한 JSON 형식으로 IP 범위를 나열합니다.\n\n<div class=\"content-ad\"></div>\n\n## OpenAI\n\nGPTBot은 OpenAI의 봇으로, 웹사이트 콘텐츠를 다운로드하는 데 사용될 가능성이 높습니다. 이를 통해 ChatGPT와 같은 AI 모델을 훈련할 수 있습니다. IP 범위는 JSON 형식으로 제공됩니다. robots.txt를 사용하여 이들을 차단할 수 있습니다.\n\n## DuckDuckGo\n\nDuckDuckGo는 Google의 대체로서 개인정보 보호에 중점을 둔 검색 엔진입니다. 이 페이지에서 각 개별 봇의 IP를 공개합니다.\n\n<div class=\"content-ad\"></div>\n\n## 메타\n\n메타는 웹사이트에 접근하기 위해 Facebook 크롤러를 사용합니다. IP 범위는 radb.net 레지스트리를 사용하여 공개됩니다.\n\n## Amazon, Apple, Baidu, Sogou, Yahoo, Yandex\n\n이 기업들은 인터넷을 스캔하는 데 사용되는 IP 주소의 고정된 목록이나 자동 업데이트되는 목록을 공개하지 않습니다. 그러나, bot 트래픽이 자신들의 시스템에서 유래되었는지 확인하는 문서화된 방법을 갖고 있습니다. host 명령을 사용하여 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n$ host 17.58.101.179\n179.101.58.17.in-addr.arpa domain name pointer 17-58-101-179.applebot.apple.com.\n\n\n## 인터넷 아카이브\n\n인터넷 아카이브 봇은 웨이백 머신/아카이브 닷오르그 프로젝트를 위한 크롤러입니다. 그들은 웹의 콘텐츠를 역사적인 이유로 저장합니다. 웹사이트는 변화하고 페이지는 매일 생성되고 사라집니다.\n\nIABot은 host 명령을 사용하여 확인할 수 있습니다. robots.txt의 내용을 무시하기 때문에 차단하기 어렵습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## CommonCrawl\n\n커먼크롤(CommonCrawl)은 인터넷 아카이브와 유사한 비영리 기관입니다. 전체 인터넷의 주기적인 스냅샷 또는 데이터셋을 생성하고 이를 공개적으로 제공합니다.\n\n커먼크롤은 해당 주제에 대한 정보를 과도하게 공유하지 않으며, 실제 CCBot를 식별하는 것은 대규모 온디맨드 AWS 인프라에서 실행되므로 더 복잡합니다.\n\n한 가지 방법은 사용자 에이전트와 호스트를 모두 확인하는 것입니다. 이는 완벽한 방법은 아니지만, 모든 EC2 클라우드 인스턴스가 같은 .amazonaws.com 호스트 이름을 공유하기 때문에 복잡합니다. 그러나 두 가지가 일치하면, 요청이 실제 CCBot에서 시작되었을 가능성이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 이 스크립트로 변환하기\n\nGitHub에는 자체 업데이트되는 좋은 봇 IP 목록 및 프로젝트가 많이 있습니다. 주요 단점은 이러한 프로젝트 관리자에게 의존한다는 것입니다. 이러한 프로젝트의 계획 또는 EOL(수익화 종료) 날짜는 알려져 있지 않으며 라이선스도 명확하지 않습니다.\n\n그것을 고려하면 아래 스크립트는 생성자에서 IP 범위에 관한 모든 정보를 다운로드합니다. 그 정보는 직접 제공되는 서비스에서 가져옵니다. 따라서 HTTP 요청 로그 항목의 IP 및 사용자 에이전트를 확인할 수 있습니다.\n\n안타깝게도 이 스니펫은 완전한 Python 패키지로 발전시키기 위해 추가 작업이 필요하므로 현재는 Gist 상태입니다. 호스트 호출로 인해 실시간 사용에 대한 도움 클래스는 충분히 빠르지 않을 것입니다. 50,000개의 로그 항목을 확인하는 데 약 15분이 소요됩니다. 서브프로세스 호출에 대해 교차 플랫폼 작업이 필요할 수 있습니다. IPv6 지원은 없습니다. 가독성을 우선시합니다.\n\n<div class=\"content-ad\"></div>\n\n웹 응용 프로그램 방화벽(WAF)가 실시간으로 이러한 요청을 차단해야 한다면 CloudFlare, RunCloud 등의 검증된 서비스를 선택하세요.\n\n현재 클래스는 과거의 HTTP 서버 로그 항목을 테스트할 수 있습니다. 서버가 받는 건강한 봇/크롤러/스파이더 트래픽의 양을 확인하는 데 사용할 수 있습니다.\n\n# 사용 방법\n\n저는 NGINX 서버의 봇 트래픽을 확인하기 위해 아래 스크립트를 사용했습니다.\n아래의 사용 예는 하위 폴더 내에있는 모든 access.log[.*.gz] 파일을 구문 분석합니다.\n\n<div class=\"content-ad\"></div>\n\n\n# NGINX 로그 파일에서 모든 데이터를 pandas DataFrame으로 로드합니다  \nNGINX 로그 파일에서 모든 데이터를 pandas DataFrame으로로드합니다.  \n\n# tqdm을 사용하여 요청 정보를 확인하고 진행 상황을 보고합니다\ntqdm을 사용하여 요청 정보를 확인하고 진행 상황을 보고합니다. 이 단계는 시간이 걸릴 수 있으므로 주의해주세요.  \n\n# 디스크에 보고서 저장 및 요약 출력  \n디스크에 보고서를 저장하고 요약을 출력합니다.  \n\n이 스크립트는 NGINX 로그 파일에 작동합니다. NGINX는 인그레스 컨트롤러로 가장 인기 있는 선택지이기 때문에 잘 작동합니다.  \n위 코드 조각들은 어떤 데이터 분석 사용 사례 및 다른 인그레스 컨트롤러에 대한 확장이 가능하도록 충분히 일반적입니다.  \n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n사실, 로봇 요청 중에서 4%만 진짜 서비스에서 시작된 것으로 나타났습니다. 즉, 25개 중 1개만이 진짜 요청입니다.\n\n나머지는 단지 대역폭과 자원을 낭비하는 것 뿐입니다.\n\n읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs_0.png","tag":["Tech"],"readingTime":5},{"title":"이렇게 Python 함수 작성 안 하면 PR 거부","description":"","date":"2024-06-23 13:30","slug":"2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest","content":"\n\n\n<img src=\"/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png\" />\n\n이건 나의 직장에서 기술 리드로부터 받았던 에너지였죠. 사실 나도 이 시점에서 그와 동의합니다.\n\n# 우리에게 파이썬 함수를 어떻게 작성하는지 배웠는가\n\n다음은 간단한 매개변수를 사용하는 함수입니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 숫자 목록 num_list가 있습니다.\n- 숫자 num이 있습니다.\n- num_list에 있는 모든 숫자에 num을 더한 새로운 목록을 반환합니다.\n\n```js\ndef add_all(num_list, num):\n    output = []\n    for n in num_list:\n        output.append(n + num)\n    return output\n\nx = add_all([3, 4, 5], 10)\n\nprint(x) # 13, 14, 15\n```\n\n문제 - 첫눈에 알기 어려운 것들:\n\n- 이 함수가 어떤 데이터 유형을 사용하는지\n- 이 함수가 어떤 데이터 유형을 반환하는지\n\n<div class=\"content-ad\"></div>\n\n음, 코드를 읽으면 num_list가 숫자의 목록이고 num은 숫자이며, 함수가 숫자의 목록을 반환한다는 것을 유추할 수 있다는 걸 알 수 있어. 그러나 이건 즉시 알 수 있는 게 아니잖아.\n\n그리고 대규모 제품용 앱에서는 수천 개의 함수가 처리되어야 한다. 정말 그 추가 시간을 들여서 데이터 유형을 이해하고 추론해야 할까?\n\n# 타입 주석 (타입 힌트)이 구해줍니다 \n\n참고 - 우리는 이것을 타입 힌트 또는 타입 주석이라고 부를 수 있어\n\n<div class=\"content-ad\"></div>\n\n그리고 위의 함수에 몇 가지 타입 힌트를 추가해 봅시다.\n\n```python\nfrom typing import List, Union\n\ndef add_all(\n    num_list: List[Union[int, float]],\n    num: Union[int, float]\n) -> List[Union[int, float]]:\n    \"\"\"\n    num_list의 모든 숫자에 num을 추가합니다  \n\n    inputs:\n        num_list: 숫자 리스트\n        num: 숫자\n    \"\"\"\n    output = []\n    for n in num_list:\n        output.append(n + num)\n    return output\n\nx: List[Union[int, float]] = add_all([3, 4, 5], 10)\n\nprint(x) # 13, 14, 15\n```\n\n- Union[int, float]은 int 또는 float 중 하나를 의미합니다.\n- List[Union[int, float]]은 정수 또는 소수의 리스트를 의미합니다.\n\nnum_list: List[Union[int, float]]은 num_list가 숫자 (정수 또는 소수)의 리스트여야 함을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n비슷하게, `num: Union[int, float]`은 num이 정수 또는 부동 소수점 숫자여야 함을 의미합니다.\n\n마지막으로, `- List[Union[int, float]]`은 이 함수가 정수 또는 부동 소수점 숫자들의 리스트를 반환해야 함을 의미합니다.\n\n참고 - 함수의 첫 줄에 우리 함수가 무엇을 하는지 간단히 설명하고 문서화하기 위해 (세 개의 따옴표로 둘러싼 것) 독스트링을 추가합니다.\n\n# 네, 이렇게 함수를 작성해야 합니다. 그렇지 않으면 PR이 거부될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n왜 기술 리드가 우리에게 함수를 이렇게 작성하라고 요청하는지 알려드릴게요:\n\n- 변수의 데이터 유형이 한눈에 알 수 있습니다.\n- 이를 유추할 필요가 없어져 시간을 절약할 수 있습니다.\n- 함수가 반환해야 하는 것을 한눈에 알 수 있습니다.\n- 독스트링을 통해 함수가 하는 일을 코드를 살펴보지 않고도 한눈에 알 수 있습니다. 더 많은 시간을 절약할 수 있죠.\n- 이렇게 함으로써 함수가 장기적으로 유지보수하기에 더 적합해집니다.\n\n# 더 널리 사용되는 타입 힌트들\n\n기본 사항:\n\n<div class=\"content-ad\"></div>\n\n```js\na: int = 5\n\nb: float = 3.14\n\nc: bool = True\n\nd: str = 'apple orange pear'\n```\n\n리스트, 사전, 튜플, 셋:\n\n```js\nfrom typing import List, Dict, Tuple, Set\n\n# 정수 리스트\na: List[int] = [1, 2, 3]  \n\n# 문자열 리스트\nb: List[str] = ['apple', 'orange'] \n\n# 키가 문자열이고 값이 정수인 사전\nc: Dict[str, int] = {'apple':4, 'orange':5}\n\n# 키가 정수이고 값이 부울인 사전\nd: Dict[int, bool] = {1: True, 2: False, 3: True}\n```\n\n변수가 정수 또는 부동 소수점 숫자일 수 있는 경우 Unions을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfrom typing import Union, Dict\n\ndef add10(number: Union[int, float]):\n    # number은 정수 또는 부동소수점이어야 합니다\n    pass\n\ndef test(d: Dict[str, Union[int, float, bool]]):\n    # d는 사전이어야 합니다\n    # d의 키는 모두 문자열이어야 합니다\n    # d의 값은 정수, 부동소수점 또는 부울이어야 합니다\n    pass\n```\n\n대안적인 방법으로 `Union`을 사용하는 대신에 다음과 같이 작성할 수 있습니다:\n\n```js\nfrom typing import Dict\n\ndef add10(number: int | float):\n    # number은 정수 또는 부동소수점이어야 합니다\n    pass\n\ndef test(d: Dict[str, int | float | bool]):\n    # d는 사전이어야 합니다\n    # d의 키는 모두 문자열이어야 합니다\n    # d의 값은 정수, 부동소수점 또는 부울이어야 합니다\n    pass\n```\n\n^ `Union[int, float]` 대신에 `int | float`을 사용하는 대체 방법입니다. 저는 이 방법을 더 우아하게 보이고(그리고 덜 타이핑해야 하기 때문에) 주로 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 옵셔널 변수에 대한 예제입니다:\n\n```python\nfrom typing import Optional\nfrom random import random\n\ndef test() -> Optional[int]:\n    \"\"\"\n    50%의 확률로 1000 반환\n    50%의 확률로 None 반환\n    \"\"\"\n    random_float: float = random()\n\n    if random_float > 0.5:\n        return 1000\n\n    return None\n```\n\n여기서 Optional[int]는 변수가 int 또는 None 중 하나일 수 있음을 나타냅니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n네, 정말이죠. 만약 우리 중 누군가가 타입 주석이나 독스트링을 추가하지 않고 코드를 작성한다면, 우리는 리더들로부터 그것을 추가하라는 의견을 받게 될 거에요.\n\n그것이 나쁜 일은 아니에요, 왜냐하면 코드는 읽기 쉽도록 만들어졌으니까요.\n\n# 만약 크리에이터로서 저를 지원하고 싶다면\n\n- 제 책을 사 주세요! — 101 Things I Never Knew About Python\n- 어디서 찾을 수 있나요: https://payhip.com/b/vywcf\n- 이 이야기에 50번 박수를 보내주세요\n- 여러분의 생각을 나에게 말씀해 주세요\n- 이야기에서 가장 좋아하는 부분을 강조해 주세요\n\n<div class=\"content-ad\"></div>\n\n감사합니다! 이런 작은 조치들이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png"},"coverImage":"/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png","tag":["Tech"],"readingTime":5}],"page":"12","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}