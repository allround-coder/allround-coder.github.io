{"pageProps":{"posts":[{"title":"HMPL  API를 통해 HTML을 가져오는 새로운 템플릿 언어","description":"","date":"2024-06-20 03:41","slug":"2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI","content":"\n\n\n![이미지](/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_0.png)\n\n이 글에서는 HMPL이라고 불리는 새로운 템플릿 언어에 대해 이야기하겠습니다. 이 언어를 사용하면 API에서 HTML을 쉽게 불러올 수 있어 굉장히 많은 불필요한 코드를 줄일 수 있습니다.\n\nhmpl.js의 주요 목표는 작은 요청 구조를 HTML에 통합하여 서버 작업을 간단하게 만드는 것입니다. 이는 php 확장자가 있는 파일에서 php 요청을 통해 서버로부터 받은 응답을 처리하는 방식과 비교될 수 있지만 동시에 javascript를 통해 직접적으로 처리할 수 있는 방법을 제공합니다. 단순히 버튼에서 제목을 가져오는 예를 통해 이 템플릿 언어가 귀하의 작업을 단순화할 수 있는 방법을 이해할 수 있습니다.\n\n이 템플릿 언어를 이용하면 지정된 문자열 템플릿을 반복할 수 있습니다. 코드로 표현하면 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { compile } from \"hmpl-js\";\nconst templateFn = compile(\n   `<div>\n     <request src=\"/api/test\"></request>\n   </div>`\n);\n\nconst wrapper = document.getElementById(\"wrapper\");\nconst obj1 = templateFn();\n\nconst obj2 = templateFn();\n\nwrapper.appendChild(obj1.response);\nwrapper.appendChild(obj2.response);\n```\n\n이 모듈은 최신 JS 도구를 사용하여 서버와 작업할 수 있도록 fetch API에 기반을 둔 것입니다.\n\nfetch API와 상호작용하려면 RequestInit 유형을 기반으로 한 설정 객체도 생성되었습니다. 예시 코드:\n\n```js\nconst elementObj = templateFn({\n  method: \"POST\",\n  mode: \"cors\",\n  cache: \"no-cache\",\n  credentials: \"same-origin\",\n  headers: {\n    \"Content-Type\": \"text/html\",\n  },\n  redirect: \"follow\",\n  get: (prop, value) => {},\n  referrerPolicy: \"no-referrer\",\n  body: JSON.stringify(data),\n  signal: new AbortController().signal,\n  integrity: \"…\",\n  window: null,\n  refferer: \"about:client\",\n});\n```\n\n<div class=\"content-ad\"></div>\n\n템플릿 언어의 구문 자체로 .hmpl 확장자 파일을 사용하여 실용적이고 이해하기 쉬운 프로젝트 파일 구조를 만들고 일반 HTML과 \"모듈화된\" HTML을 분리하는 것이 가능합니다.\n\n![이미지](/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_1.png)\n\n해당 모듈은 매우 작은 크기입니다 (버전 1.0.9). npm에서 100킬로바이트 미만을 차지합니다. 미니파이된 파일 자체도 더욱 가벼워집니다.\n\n![이미지](/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_2.png)\n\n<div class=\"content-ad\"></div>\n\n아래는 작업을 더욱 쉽게 수행할 수 있는 여러 연결 옵션이 있는 모듈입니다:\n\n```js\n<script src=\"https://unpkg.com/hmpl-js/dist/hmpl.min.js\"></script>\n```\n\n또는\n\n```js\n{\n  \"dependencies\": {\n    \"hmpl-js\": \"latest\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n웹팩 구성 파일\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.hmpl$/i,\n        use: [\"hmpl-loader\"],\n      }\n    ]\n  }\n}\n```\n\n모듈에 대한 간단한 프로젝트 예시:\n\n<div class=\"content-ad\"></div>\n\nhttps://github.com/hmpljs/examples\n\n다른 유용한 링크:\n\n- https://hmpljs.github.io\n- https://github.com/hmpljs/hmpl-loader\n- https://github.com/hmpljs/hmpl\n- https://www.youtube.com/@antonmak1\n\n이 모듈에 관심이 있으시다면 댓글에 여러분의 의견을 남겨주시면 멋질 것 같아요 :). 이 기사를 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_0.png"},"coverImage":"/assets/img/2024-06-20-HMPLnewtemplatelanguageforfetchingHTMLfromAPI_0.png","tag":["Tech"],"readingTime":3},{"title":"SwiftUI에서 HTML 렌더링하기","description":"","date":"2024-06-20 03:39","slug":"2024-06-20-RenderHTMLinSwiftUI","content":"\n\n## NSAttributedString, UITextView 및 UIViewRepresentable를 사용하여 SwiftUI에서 HTML 렌더링하기.\n\n![이미지](/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png)\n\nSwiftUI는 멋지지만 여전히 기능이 부족한 것이 많습니다. 몇 년간 UIKit을 사용한 후 익숙해진 기능이죠. 그 중 하나는 NSAttributedString 및 UITextView를 사용하여 간단한 HTML 텍스트를 렌더링할 수 있는 기능입니다.\n\n이 글에서는 SwiftUI를 UIViewRepresentable을 사용하여 UIKit과 연결하고, HTML을 렌더링하는 사용자 정의 SwiftUI View를 만드는 방법을 간단히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n업데이트: 원본 기사 개선 사항\n\n이 기사의 원본 버전에서는 NSAttributedString을 사용하여 HTML을 스타일링하고 렌더링하는 데 특화된 간단한 사용자 정의 SwiftUI 뷰를 만드는 방법에 대해 살펴보았습니다. 이 기사에서는 AttributedText 뷰도 언급되었습니다. 그러나 이로 인해 이상한 동작이 발생했는데, 아직 적절한 해결책을 찾지 못했습니다. 따라서 이 기사의 업데이트된 버전에서는 HTML 뷰를 제거하고 NSAttributedString에 대한 편리한 확장 기능이 몇 가지 추가되었습니다. 나는 이상한 동작에 대한 더 나은 이해를 얻기 위해 Apple 개발자 포럼과 스택 오버플로에 게시했습니다.\n\n## 주요 포인트\n\n- UIViewRepresentable 프로토콜을 사용하여 UIKit 뷰를 SwiftUI 뷰 계층구조에 포함할 수 있습니다.\n- NSAttributedString (UITextView를 통해)의 강력한 기능을 노출할 수 있으며, 현재 SwiftUI 세계에는 동등한 것이 없습니다 (하지만 AttributedString는 좋은 후보일 수 있음).\n- 스타일이 지정된 HTML 형식의 NSAttributedStrings는 UIViewRepresentable에 의해 관리되는 UITextView에 의해 렌더링될 수 있습니다. HTML 형식의 텍스트에서 일부 CSS 스타일 속성을 인라인으로 정의하거나 HTML 형식의 텍스트의 전용 스타일 태그로 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서 사용된 완성된 예제 코드는 GitHub에서 찾을 수 있어요: https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML.\n\n# 커스텀 UIViewRepresentable\n\nSwiftUI가 처음 발표됐을 때는 기존 UIKit 뷰를 SwiftUI 뷰 계층구조에 임베드할 수 있도록 하는 API도 함께 제공되었습니다. 개발자들에게 UIKit에서 SwiftUI로의 전환이 쉬워졌어요.\n\n이러한 API 중 하나는 UIViewRepresentable 프로토콜인데요, SwiftUI의 컨텍스트에서 UIKit 뷰를 관리하는 데 사용돼요. Apple은 이 프로토콜과 다른 SwiftUI와 UIKit을 연결하는 프로토콜을 통해 이를 통한 가능성을 보여주는 멋진 WWDC 비디오를 제공했어요. 적어도 'Integrating SwiftUI'를 확인해보시기를 권해요.\n\n<div class=\"content-ad\"></div>\n\n## AttributedText\n\nNSAttributedString은 텍스트 문자열을 강력하게 관리하는 도구로, 텍스트 문자열의 문자 범위를 스타일링하는 강력한 방법을 제공합니다. 심지어 간단한 HTML에 따라 텍스트를 스타일링할 수도 있습니다.\n\nNSAttributedString을 스타일링된 상태로 초기화하려면 NSAttributedString.init(data:options:documentAttributes:) 이니셜라이저에 .documentType 옵션을 .html로 설정한 HTML 문자열(데이터 형식으로)을 전달하면 됩니다. 그리고 UITextView와 함께 사용하여 앱에서 HTML을 렌더링할 수 있습니다!\n\nUIViewRepresentable 프로토콜을 사용하여 NSAttributedString 및 UITextView의 기능을 SwiftUI에 사용되는 사용자 지정 AttributedText View로 노출시킬 것입니다!\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct AttributedText: UIViewRepresentable {\n    private let attributedString: NSAttributedString\n\n    init(_ attributedString: NSAttributedString) {\n        self.attributedString = attributedString\n    }\n\n    func makeUIView(context: Context) -> UITextView {\n        // SwiftUI이 이 \"View\"를 렌더링하는 첫 번째 시간에 호출됩니다.\n\n        let uiTextView = UITextView()\n\n        // 배경 뷰가 반짝일 수 있도록 투명하게 만듭니다.\n        uiTextView.backgroundColor = .clear\n\n        // 텍스트 시각화만을 위한 것이므로 편집되지 않도록 합니다.\n        uiTextView.isEditable = false\n\n        // UITextView를 가능한 너비에 맞게 유연하게 만들지만, 콘텐츠에 맞는 높이를 요구합니다.\n        // 또한 UITextView가 스크롤되지 않게 하여 UITextView가 텍스트 콘텐츠와 일치하도록 `intrinsicContentSize`를 설정합니다.\n        uiTextView.isScrollEnabled = false\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .vertical)\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .horizontal)\n        uiTextView.setContentCompressionResistancePriority(.required, for: .vertical)\n        uiTextView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n\n        return uiTextView\n    }\n\n    func updateUIView(_ uiTextView: UITextView, context: Context) {\n        // SwiftUI이 이 UIViewRepresentable을 처음 렌더링하는 시간과 상태 변경에 대해 알림을 받을 때마다 호출됩니다. (예: @State 변수를 통해)\n        uiTextView.attributedText = attributedString\n    }\n}\n```\n\nUIViewRepresentable로 위에서 정의한 AttributedText를 사용하여 SwiftUI 앱에서 NSAttributedStrings를 렌더링할 수 있습니다. HTML 형식의 텍스트로 초기화된 NSAttributedStrings를 렌더링하는 것이 주된 목표이므로 NSAttributedString에 대한 편의 생성자를 만듭니다.\n\n```swift\nimport UIKit\n\nextension NSAttributedString {\n    static func html(withBody body: String) -> NSAttributedString {\n        // 앱에서 사용되는 현재 로케이션과 일치하는 HTML `lang` 속성을 매치합니다. (즉, Bundle.main)\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            <!doctype html>\n            <html lang=\"\\(lang)\">\n            <head>\n                <meta charset=\"utf-8\">\n                <style type=\"text/css\">\n                    /*\n                      HTML 형식의 텍스트에 대한 사용자 정의 CSS 스타일 지정\n                      주의: NSAttributedString/UITextView에서 지원하는 CSS 기능은 제한적입니다.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(UIColor.secondaryLabel.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(UIColor.label.hex);\n                    }\n\n                    a {\n                        color: \\(UIColor.systemGreen.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                </style>\n            </head>\n            <body>\n                \\(body)\n            </body>\n            </html>\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// UIColor를 CSS 친화적인 색상 헥스 문자열로 변환\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(&red, green: &green, blue: &blue, alpha: &alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nNSAttributedString은 일부 CSS 기능을 지원합니다 (안타깝게도 어딘가 제대로 문서화되지 않은 기능들이 있습니다), 하지만 인라인 및 별도의 태그 내에서 스타일을 정의하는 것이 가능합니다 (일반적으로 HTML head 태그의 일부로).\n\n## SwiftUI에서 HTML 렌더링하기\n\n그런 다음, 우리는 AttributedText UIViewRepresentable을 사용하여 NSAttributedString 편리한 초기화자를 함께 사용하여 SwiftUI 앱에서 HTML을 렌더링할 수 있습니다 - 심지어 인라인 스타일링도 가능합니다!\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.html(withBody: \"\"\"\n                <h3>This is a H3 header</h3>\n                <p>This is a paragraph</p>\n                <ul>\n                    <li>List item one</li>\n                    <li>List item two</li>\n                </ul>\n                <p>This is a paragraph with a <a href=\"https://developer.apple.com/\">link</a></p>\n                <p style=\"color: blue; text-align: center;\">\n                    This is a paragraph with inline styling\n                </p>\n                \"\"\"))\n                .padding()\n            }\n            .navigationTitle(\"Render HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 보너스: 테마별 HTML 렌더링\n\n만약 앱이 (색상) 테마 개념을 사용하여 앱 전반에 대한 색상 정보 등을 전파한다면, 현재 테마 정보를 기반으로 HTML을 스타일링할 수도 있습니다.\n\n사용자 정의 테마 환경 값과 다른 NSAttributedString 편의 이니셜라이저를 사용하면 다음과 같이 보일 수 있습니다:\n\n사용자 정의 테마 환경 값\n\n<div class=\"content-ad\"></div>\n\n다음은 Markdown 형식으로 테이블 태그를 변경한 코드입니다.\n\n\nimport SwiftUI\n\n// Example of a simple Theme struct.\nstruct Theme {\n    let textPrimary: UIColor\n    let textSecondary: UIColor\n    let textInteractive: UIColor\n}\n\nextension Theme {\n    static let `default` = Theme(\n        textPrimary: .label,\n        textSecondary: .secondaryLabel,\n        textInteractive: .systemGreen\n    )\n}\n\nprivate struct ThemeEnvironmentKey: EnvironmentKey {\n    static var defaultValue: Theme = .default\n}\n\nextension EnvironmentValues {\n    var theme: Theme {\n        get { self[ThemeEnvironmentKey.self] }\n        set { self[ThemeEnvironmentKey.self] = newValue }\n    }\n}\n\n\nNSAttributedString을 위한 편리한 이니셜라이저\n\n\nimport UIKit\n\nextension NSAttributedString {\n    static func themedHtml(withBody body: String, theme: Theme = .default) -> NSAttributedString {\n        // Match the HTML `lang` attribute to current localisation used by the app (aka Bundle.main).\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            <!doctype html>\n            <html lang=\"\\(lang)\">\n            <head>\n                <meta charset=\"utf-8\">\n                <style type=\"text/css\">\n                    /*\n                      Custom CSS styling of HTML formatted text.\n                      Note, only a limited number of CSS features are supported by NSAttributedString/UITextView.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(theme.textSecondary.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(theme.textPrimary.hex);\n                    }\n\n                    a {\n                        color: \\(theme.textInteractive.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                </style>\n            </head>\n            <body>\n                \\(body)\n            </body>\n            </html>\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// MARK: Converting UIColors into CSS friendly color hex string\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(&red, green: &green, blue: &blue, alpha: &alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n\n\nSwiftUI에서 테마가 적용된 HTML 렌더링하기\n\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @Environment(\\.theme) private var theme: Theme\n\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.themedHtml(withBody: \"\"\"\n                <h3>This is a H3 header</h3>\n                <p>This is a paragraph</p>\n                <ul>\n                    <li>List item one</li>\n                    <li>List item two</li>\n                </ul>\n                <p>This is a paragraph with a <a href=\"https://developer.apple.com/\">link</a></p>\n                <p style=\"color: blue; text-align: center;\">\n                    This is a paragraph with inline styling\n                </p>\n                \"\"\", theme: theme))\n                .padding()\n            }\n            .navigationTitle(\"Render Themed HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n## 이게 다야!\n\n쉽죠! SwiftUI가 정말 멋지지만, 때로는 몇 년 동안 사랑해 온 UIKit 뷰와 기능을 임베드할 수 있는 것이 참 좋습니다.\n\n코딩하세요! 🙌\n","ogImage":{"url":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png"},"coverImage":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png","tag":["Tech"],"readingTime":12},{"title":"프런트엔드 웹 개발에서 초보자의 여정","description":"","date":"2024-06-20 03:37","slug":"2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment","content":"\n\n![2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png](/assets/img/2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png)\n\n안녕하세요, 야망 넘치는 웹 개발자 여러분! 프론트엔드 개발 세계에 막 발을 딛으셨거나 기본기를 다듬는 중이라면, 여기서 잘 왔습니다. 지난 주에 '바이트와이즈 프론트엔드 펠로우십'의 일환으로 HTML 기초를 깊이 있게 탐구하고 있는데요. 오늘은 제 경험을 공유하려고 해요. 그동안 얻은 통찰, 조언, 그리고 도움이 된 자료들을 함께 나누어 드리겠습니다.\n\n따라서, 초보자이신 분들이든 프론트엔드 개발에 관심이 있는 분들이든, 제가 지금까지 배운 것을 함께 살펴보도록 합시다.\n\n# 프론트엔드 개발이란?\n\n<div class=\"content-ad\"></div>\n\n집을 짓는다고 상상해보세요. 건축가가 청사진을 설계하고 시공 스탭이 벽돌을 쌓으며, 그리고 인테리어 디자이너가 색상, 질감 및 가구로 비전을 구현하는 과정을 생각해보세요. 디지털 세계에서 프론트엔드 개발은 바로 그 인테리어 디자이너와 같습니다. 이는 사용자가 직접 상호 작용하는 웹 어플리케이션의 일부를 만드는 것으로, HTML, CSS, JavaScript와 같은 언어를 사용하여 정적 디자인을 동적이고 매력적인 인터페이스로 변환하는 작업을 포함합니다.\n\n## HTML: 웹 페이지의 기초\n\nHTML은 웹 페이지의 뼈대인 Hypertext Markup Language의 줄임말입니다. 다른 모든 것이 의존하는 프레임워크로 생각할 수 있습니다. HTML을 사용하여 텍스트, 이미지, 링크 등을 표시하기 위해 태그를 사용하여 웹 페이지의 구조와 내용을 정의합니다. 예를 들어:\n\n- `h1`은 제목을 생성합니다.\n- `p`는 단락을 나타냅니다.\n- `img src=\"image.jpg\"`는 이미지를 삽입합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n    <title>내 첫 번째 웹 페이지</title>\n</head>\n<body>\n    <h1>내 웹 사이트에 오신 것을 환영합니다!</h1>\n    <p>이것은 하나의 문단입니다.</p>\n    <img src=\"welcome-image.jpg\" alt=\"환영 이미지\">\n</body>\n</html>\n```\n\n## CSS: 웹 디자인의 스타일러\n\nHTML은 콘텐츠를 구조화하는 반면, CSS(Cascading Style Sheets)은 그것을 잘 꾸미는 역할을 합니다. CSS에서는 색상, 글꼴, 레이아웃 및 애니메이션을 적용하여 평범한 HTML 문서를 시각적으로 멋진 웹 페이지로 만들어줍니다. CSS를 영화의 의상 부서로 상상해보세요; 모든 장면이 정확히 보이도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n```js\nbody {\n    background-color: lightblue;\n}\n\nh1 {\n    color: navy;\n    margin-left: 20px;\n}\n```\n\n# JavaScript: 상호 작용의 마법사\n\n자바스크립트는 웹 페이지에 생명을 불어넣어주는 마법과 같습니다. 상호 작용, 양식 제출, 애니메이션 등을 가능하게 합니다. 자바스크립트 없이는 웹 페이지가 정적이고 반응하지 않는 상태가 됩니다. 그것은 도시에 전기를 공급하는 것과 같습니다; 갑자기 모든 것이 밝아지고 기능적으로 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시:\n\n```js\ndocument.querySelector('button').addEventListener('click', function() {\n    alert('버튼이 클릭되었습니다!');\n});\n```\n\n# 프론트엔드 개발 해양 항해\n\n프론트엔드 개발 분야에서의 경력은 거대한 바다를 항해하는 것과 같습니다. 여기에 몇 가지 항해 보조 도구가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 기초 학습: HTML, CSS, 그리고 JavaScript부터 시작하세요. W3Schools, Codecademy, Udemy와 같은 다양한 온라인 자원들이 포괄적인 안내서와 자습서를 제공합니다.\n- 꾸준한 연습: 코딩은 반복을 통해 향상되는 기술입니다. 배운 것을 강화하기 위해 작은 프로젝트를 만들어보세요.\n- 커뮤니티 참여: Stack Overflow, GitHub, Reddit와 같은 플랫폼에서 동료 학습자 및 전문가들과 소통하세요. 지식 공유와 조언 요청은 성장을 가속화할 수 있습니다.\n- 호기심 유지: 기술은 빠르게 진화합니다. 경쟁력을 유지하기 위해 새로운 도구, 프레임워크, 최상의 실천법에 대해 계속해서 알아두세요.\n\n# 나의 바이트위즈 펠로우십 모험\n\n## 🗓️ 제 1일: 툴킷 설정하기\n\n코딩에 뛰어들기 전에 올바른 도구와 자원을 설정하는 것이 중요합니다. 첫 날 우리가 한 것은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n## 설정할 계정:\n\n- LinkedIn: 전문가들과 연결하고 성장 과정을 공유하세요.\n- Twitter: 기술 인플루언서를 팔로우하고 여정을 공유하세요.\n- GitHub: 프로젝트를 호스팅하고 다른 사람과 협업하세요.\n- Medium: 학습 경험에 대한 기사를 쓰고 공유하세요.\n- Google Drive: 일일 회의와 프로젝트 파일을 정리하세요.\n\n## 학습 자료:\n\n- 동영상: 프론트엔드 개발자 로드맵 2024 또는 대체 동영상\n- 기사: 초심자 프론트엔드 개발자의 교훈\n\n<div class=\"content-ad\"></div>\n\n# 🗓️ Day 2: 필수 프론트엔드 스킬\n\n강력한 기반을 구축하는 것이 중요합니다. 오늘은 프론트엔드 개발을 올바르게 학습하는 방법에 중점을 두었습니다.\n\n## 학습 자료:\n\n- 비디오: 올바른 방법으로 프론트엔드 개발 학습하기\n- 비디오: 2배 빨리 프론트엔드 개발 배우기\n\n<div class=\"content-ad\"></div>\n\n# 🗓️ 3일차: HTML 기초\n\nHTML (하이퍼텍스트 마크업 언어)는 모든 웹사이트의 기초입니다. 모든 것을 함께 유지하는 뼈대로 생각해보세요.\n\n## 학습 자료:\n\n- 비디오 튜토리얼: HTML 기본 태그\n\n<div class=\"content-ad\"></div>\n\n## 중요 개념:\n\n- 제목: `h1`부터 `h6`까지 사용하여 제목을 정의합니다.\n- 문단: `p` 태그는 문단을 만듭니다.\n- 리스트: 순서가 있는 목록에는 `ol`을, 순서가 없는 목록에는 `ul`을 사용합니다.\n- 링크: `a` 태그는 하이퍼링크를 만듭니다. 예시:\n\n```js\n<a href=\"https://www.bytewise.com\">바이트와이즈 방문하기</a>\n```\n\n- 이미지: `img` 태그는 이미지를 삽입합니다. 예시:\n\n<div class=\"content-ad\"></div>\n\n\n![Description of Image](path/to/image.jpg)\n\n\n# 🗓️ Day 4: HTML Semantic Tags\n\n시맨틱 HTML 태그는 웹 콘텐츠에 의미를 부여하여 콘텐츠를 더 접근 가능하고 유지 보수하기 쉽게 만듭니다.\n\n## 학습 자료:\n\n<div class=\"content-ad\"></div>\n\n- 비디오 자습: HTML 시맨틱 요소\n\n## 주요 개념:\n\n- `header`: 페이지의 헤더 섹션을 정의합니다.\n- `nav`: 내비게이션 링크를 포함합니다.\n- `article`: 글을 나타냅니다.\n- `section`: 문서 내에서 섹션을 정의합니다.\n\n## 예시:\n\n<div class=\"content-ad\"></div>\n\n\n# 🗓️ Day 5: HTML 미디어 태그\n\n미디어 태그를 사용하면 비디오, 오디오 및 기타 멀티미디어 요소를 웹 페이지에 삽입하여 사용자 경험을 향상시킬 수 있습니다.\n\n## 학습 자료:\n\n\n<div class=\"content-ad\"></div>\n\n- 비디오 튜토리얼: HTML 미디어 요소\n\n## 주요 개념:\n\n- 비디오: `video` 태그는 비디오 파일을 임베드합니다. 예시:\n\n```js\n<video controls>\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  브라우저가 비디오 태그를 지원하지 않습니다.\n</video>\n```\n\n<div class=\"content-ad\"></div>\n\n- Audio: `audio` 태그는 오디오 파일을 임베드합니다. 예시:\n\n```js\n<audio controls>\n  <source src=\"sound.mp3\" type=\"audio/mpeg\">\n  //브라우저가 오디오 태그를 지원하지 않습니다.\n</audio>\n```\n\n- iFrame: `iframe` 태그는 외부 콘텐츠를 임베드합니다. 예시:\n\n```js\n<iframe src=\"https://www.example.com\" width=\"600\" height=\"400\"></iframe>\n```\n\n<div class=\"content-ad\"></div>\n\n# 📝 결론: 앞으로의 여정\n\n프론트엔드 개발을 배우는 것은 흥미진진한 모험을 떠나는 것과 같습니다. 매일 새로운 도전과 성장의 기회가 찾아옵니다. 여러분이 여정을 계속할 때 기억해야 할 몇 가지 팁이 있습니다:\n\n- 꾸준한 연습: 코드를 많이 작성할수록 능력이 향상됩니다.\n- 호기심을 유지하라: 늘 새로운 것을 배우고 다양한 자료를 탐험하려고 노력하세요.\n- 커뮤니티 지원을 찾아라: 포럼에 가입하거나 웨비나에 참석하고 다른 개발자와 소통하세요.\n\nHTML, CSS, JavaScript의 기본을 마스터하면 멋진 웹사이트를 만들고 숙련된 프론트엔드 개발자가 될 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사가 도움이 되었다면, 더 많은 웹 개발 팁과 통찰을 얻기 위해 LinkedIn과 Twitter에서 저를 팔로우해 주세요. 아래 댓글에 여러분의 경험과 배운 교훈을 공유해 주시기를 환영합니다.\n\n성공의 열쇠는 끈기와 학습에 대한 사랑입니다.\n\n즐거운 코딩하세요! 😊🌸✨","ogImage":{"url":"/assets/img/2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png"},"coverImage":"/assets/img/2024-06-20-ABeginnersJourneyintoFront-EndWebDevelopment_0.png","tag":["Tech"],"readingTime":6},{"title":"내부 HTML을 사용하지 말아야 하는 이유와 대신 사용할 것","description":"","date":"2024-06-20 03:36","slug":"2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead","content":"\n\n## innerText, textContent, 및 innerHTML\n\n![이미지](/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_0.png)\n\n# 소개\n\n코딩에 입문했고 JavaScript와 HTML의 기본을 알게 되었다면, 이제 DOM을 탐색하기 시작할 준비가 된 것 같네요. JavaScript를 사용하여 HTML 요소를 선택했고, 이제 해당 요소에 콘텐츠를 추가하려고 할 때 innerHTML, textContent, innerText 속성이 모두 도와줄 수 있지만, 어떤 것을 선택해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 HTML에 빈 `li` 요소들로 이루어진 순서 없는 목록이 있다고 가정해 봅시다. 우리는 이러한 요소들에 JavaScript를 사용하여 일반 텍스트 내용을 추가하고 싶습니다.\n\n우리가 `li` 요소들에 부여한 id를 활용하여 JavaScript에서 이러한 요소들에 내용을 추가할 수 있고, 세 속성 중 아무것이나 사용해도 거의 동일하게 작동할 것입니다.\n\n여기서 볼 수 있듯이 어떤 속성을 사용하든 우리의 웹페이지에 텍스트가 항목으로 나타날 것입니다.\n\n![이미지](/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_1.png)\n\n<div class=\"content-ad\"></div>\n\n그래서, 세 개의 속성이 모두 같은 기능을 한다면, 그 목적은 무엇인가요? 각각의 차이와 innerHTML이 해커들에게 취약해지게 하는 방법, 그리고 대신에 사용할 수 있는 것을 알아보려면 계속 읽어보세요.\n\n# 각각의 콘텐츠를 페이지에 렌더하는 방법\n\n이미 존재하는 요소에 일반 텍스트를 추가하는 방법은 위에서 했던 것처럼 상당히 간단하지만, 더 복잡한 코드를 작성하고 있다면 어떨까요. 예를 들어, HTML에 `li` 태그를 입력하지 않고 JavaScript를 사용하여 추가하려고 하는 상황을 생각해보세요. 또 하나의 복잡성을 더해주기 위해, 글을 굵게 표시하기 위해 텍스트 주위에 `strong` 태그를 추가하고 싶다고 가정해 보겠습니다. 이전에 제공했던 \"list\" id를 통해 `ul` 요소를 선택한 후에, HTML 콘텐츠를 추가하고 일반 텍스트를 넣어놓는 것 역시 시작할 수 있습니다. textContent 속성을 사용하여 목록을 만들어 보겠습니다.\n\n이것이 웹 페이지에 표시되는 결과입니다:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_2.png\" />\n\n이 부분은 확실히 제대로 보이지 않아요. 만약 'textContent'를 'innerText'로 바꾼다면 어떻게 될까요?\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_3.png\" />\n\n음... 아무래도 조금 나아졌지만, 여전히 원하는 것과는 다르네요. 아마 'innerText' 대신에 'innerHTML'을 사용하면 우리가 원하는 굵은 목록을 얻을 수 있을 것 같아요.\n\n\n<div class=\"content-ad\"></div>\n\n아래는 표입니다.\n\n| 일자 | 카테고리 | 주제 |\n| ---- | -------- | ---- |\n| 6월 20일 | 웹 개발 | innerHTML의 단점 | \n\n내용이 완벽해 보여요! innerHTML이 여기서 멋지게 작동하고 있지만, 웹 페이지에 문제를 일으킬 수 있는 상당히 중요한 단점이 몇 가지 있습니다.\n\n# innerHTML의 단점\n\n## 사이버 보안 문제\n\n<div class=\"content-ad\"></div>\n\n모든 세 속성(textContent, innerText 및 innerHTML)은 빈 요소에 콘텐츠를 추가하는 것뿐만 아니라 기존 콘텐츠를 대체합니다. innerHTML은 단순한 문자열이 아닌 실제 HTML 코드 조각을 포함하는 콘텐츠를 추가할 수 있기 때문에 보안 위험을 야기할 수 있습니다. 예를 들어 innerHTML을 사용하여 웹페이지에 제출 양식을 만들고 누군가 악성 콘텐츠를 제출하면 본인 뿐만 아니라 웹사이트나 프로젝트의 다른 사용자에게 실제 문제가 발생할 수 있습니다. 이러한 이유로 보안 검토를 받을 예정인 사이트나 프로젝트의 경우, innerHTML 사용은 테스트를 통과하지 못하고 거부당할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_5.png\" />\n\n## 비효율성\n\n또 다른 innerHTML의 단점은 다른 옵션에 비해 느립니다. 예를 들어, 코드에서 이전에 생성한 배열이나 어쩌면 API에서 가져온 수백 개 또는 수천 개의 아이템이 있는 배열에 대해 각 항목에 대해 새 요소를 만들어야 하는 프로젝트를 작업 중이라고 가정해봅시다. innerHTML을 사용하면 이 데이터를 로드하는 데 몇 초가 걸릴 수 있습니다. 오늘날 온라인 사용자에게 속도가 매우 중요한 요소인만큼, 이 몇 초가 빠르게 누적될 수 있습니다. Digital.com의 기사에 따르면 온라인 쇼핑객의 53%가 3초 이상 걸리는 전자상거래 웹사이트를 방문하지 않을 것이라고 합니다 (Leng, 2022). 다행히 JavaScript를 사용해 HTML 요소를 추가할 때 다른 옵션이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 사용 대신할 것\n\n## HTML 추가하기\n\n우리는 innerHTML을 사용하여 한 번에 HTML 요소와 텍스트 문자열을 추가하는 방법을 보았습니다. 또한 이렇게 하는 것의 단점을 살펴보았습니다. 우리의 코드를 안전하고 효율적으로 만드는 좋은 대안은 이러한 작업을 분리하는 것입니다.\n\n위의 그림에서, 우리는 'greetings'라는 배열에 우리의 인사말을 입력했습니다. 그런 다음 이 배열에 대한 'forEach' 루프를 만들었고, 배열의 각 항목에 대해 새로운 li 태그를 만들도록 지시했습니다. 새로운 강조 태그를 만들고, ul 요소를 선택하고, 방금 선택한 ul 요소에 새로 만든 li 태그를 추가하고, 해당 li 태그에 새로 만든 강조 태그를 추가하고, 배열에서 가져온 텍스트 항목을 입력하도록 했습니다. 휴, 많이 보일 수 있지만, 보다 간단하게 쪼개면, 우리는 원하는 HTML 요소를 생성하고, 그 위치를 선택하고, 해당 위치에 추가하고, 텍스트를 추가하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## innerText 대 textContent\n\n만약 HTML을 삽입할 필요가 없는 경우, 콘텐츠를 추가할 요소를 선택하고 innerText 또는 textContent로 텍스트를 입력할 수 있습니다. 일반적으로 messy한 코드를 생성할 수 있는 textContent 대신 innerText를 선택하는 것이 좋습니다. 예를 들어, `li` 태그 아래에 텍스트를 작성하고 세 줄로 나누었다고 가정해 봅시다.\n\n그런 다음 JavaScript에서 innerText와 textContent를 사용하여 해당 텍스트를 콘솔에 출력했습니다.\n\n아래에서 확인할 수 있듯이 innerText는 콘솔에 내용을 표시할 때 페이지에 표시되는 방식과 유사하게 나타내며, textContent는 동일한 콘텐츠를 콘솔에 출력할 때 처음에 HTML에 입력된 방식과 더 유사하게 출력됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_6.png\" />\n\n# 결론\n\n간편성 때문에 innerHTML을 사용하기 유혹받을 수 있지만, 웹 페이지의 로딩을 느리게 만들고 보안 위험을 초래할 수 있으므로 innerHTML을 피하고 요소를 생성하고 텍스트를 추가하는 작업을 분리하는 것이 좋습니다. textContent와 innerText 모두 원하는 텍스트를 안전하게 추가할 수 있지만, innerText는 콘솔에서 내용을 더 명확하게 표시하기 때문에 일반적으로 선호됩니다. innerHTML, textContent 및 innerText 간의 차이를 명확히 해주고 어떤 것을 사용할지 결정하는 데 도움이 되었기를 바랍니다. 즐거운 코딩 되세요!\n\n## 출처\n\n\n<div class=\"content-ad\"></div>\n\n\n[Element.innerHTML.](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)\n\nLeng, Allen. [“1 In 2 Visitors Abandon a Website That Takes More than 6 Seconds to Load.”](https://digital.com/1-in-2-visitors-abandon-a-website-that-takes-more-than-6-seconds-to-load/#:~:text=However%2C%20when%20it%20comes%20to,will%20leave%20after%20one%20second.)\n","ogImage":{"url":"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_0.png"},"coverImage":"/assets/img/2024-06-20-WhyYouShouldntUseinnerHTMLandWhattoUseInstead_0.png","tag":["Tech"],"readingTime":5},{"title":"CSS 레이아웃 및 반응 형성 Flexbox, Grid 및 미디어 쿼리 마스터하기","description":"","date":"2024-06-20 03:34","slug":"2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries","content":"\n\n웹 레이아웃을 잘 구조화하고 반응형으로 만드는 것은 어려울 수 있지만, CSS는 이 작업을 쉽게 만들어 주는 강력한 도구를 제공합니다.\n\n이 포스트에서는 두 가지 필수적인 CSS 레이아웃 방법인 플렉스박스와 그리드를 탐색할 것입니다. 또한, 반응형 디자인을 위한 중요한 개념인 미디어 쿼리에 대해 알아볼 것입니다.\n\n이 글을 끝까지 읽으면, 이러한 도구들을 사용하여 유연하고 반응형 웹 페이지를 만드는 방법에 대해 확실하게 이해하게 될 것입니다.\n\n# 왜 CSS 레이아웃 방법이 중요한 이유\n\n<div class=\"content-ad\"></div>\n\n구체적인 내용에 들어가기 전에 CSS 레이아웃 방법이 왜 중요한지 이해해 봅시다. 전통적인 레이아웃 기술인 플로트(floats) 사용은 종종 복잡하고 유지보수하기 어려운 코드로 이어집니다.\n\n플렉스박스(Flexbox)와 그리드(Grid)는 정렬, 간격 및 반응형 동작과 같은 일반적인 문제를 해결하면서 더 효율적이고 직관적인 레이아웃 설계 방법을 제공합니다.\n\n# Flexbox: 유연한 박스 레이아웃\n\n플렉스박스(Flexbox) 또는 유연한 박스 레이아웃은 하나의 축(수평 또는 수직)을 따라 공간을 분배하도록 디자인되었습니다. 컨테이너 내에서 항목을 정렬하고 공간을 분배하는 것을 쉽게 만들어 줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 플렉스박스를 사용해야 하는 경우:\n\n- 일차원 레이아웃(예: 네비게이션 바, 행이나 열에 아이템 정렬).\n- 컨테이너 내에서 공간을 분배하고 아이템을 정렬해야 할 때.\n\n## 기본 플렉스박스 예시:\n\nHTML:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Flex Box example</title>\n</head>\n\n<body>\n    <div class=\"flex-container\">\n        <div class=\"flex-item\">Item 1</div>\n        <div class=\"flex-item\">Item 2</div>\n        <div class=\"flex-item\">Item 3</div>\n    </div>\n</body>\n\n</html>\n```\n\n## CSS:\n\n```js\n.flex-container {\n  display: flex;\n  justify-content: space-between; /* Distributes space evenly */\n  align-items: center; /* Aligns items vertically centered */\n  padding: 10px;\n  background-color: #f0f0f0;\n  flex-wrap: wrap; /* Wraps items if they don't fit */\n}\n.flex-item {\n  background-color: #007bff;\n  color: white;\n  padding: 20px;\n  margin: 5px;\n  flex: 1 1 200px; /* 1:1:200px grow: shrink: basis*/\n}\n```\n\n## What the code displays\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_0.png\" />\n\n## Flexbox로 해결하는 문제들:\n\n- 컨테이너 내에서 항목을 수평 또는 수직으로 정렬.\n- 항목들 사이에서 공간을 균등하게 분배.\n- 복잡한 계산 없이 다양한 화면 크기에 맞게 레이아웃 조정.\n\n## Flexbox의 제한사항:\n\n<div class=\"content-ad\"></div>\n\n- 하나의 차원적 레이아웃을 위해 디자인되었으며, 따라서 행이나 열 중 하나만 처리하고 동시에 둘 다 처리하지는 않습니다.\n\n# CSS Grid: 이차원 레이아웃\n\nCSS Grid Layout 또는 격자(Grid)는 두 차원 레이아웃을 만들기 위한 강력한 도구입니다. 행과 열을 둘 다 포함하는 복잡한 레이아웃을 디자인할 수 있습니다.\n\n## Grid을 사용해야 하는 경우:\n\n<div class=\"content-ad\"></div>\n\n- 2차원 레이아웃(예: 포토 갤러리, 복잡한 웹 페이지 레이아웃)에 사용됩니다.\n- 행과 열을 모두 정확하게 제어해야 할 때 유용합니다.\n\n## 기본 그리드 예시:\n\nHTML:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CSS Grid Example</title>\n</head>\n\n<body>\n    <div class=\"grid-container\">\n        <div class=\"grid-item\">아이템 1</div>\n        <div class=\"grid-item\">아이템 2</div>\n        <div class=\"grid-item\">아이템 3</div>\n        <div class=\"grid-item\">아이템 4</div>\n        <div class=\"grid-item\">아이템 5</div>\n        <div class=\"grid-item\">아이템 6</div>\n        <div class=\"grid-item\">아이템 7</div>\n        <div class=\"grid-item\">아이템 8</div>\n    </div>\n</body>\n\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\nCSS:\n\n```js\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr); /* 2개의 동일한 너비의 열을 생성합니다 */\n  gap: 10px; /* 항목 사이의 간격을 추가합니다 */\n  padding: 10px;\n  background-color: #f0f0f0;\n}\n.grid-item {\n  background-color: #007bff;\n  color: white;\n  padding: 20px;\n  text-align: center;\n}\n```\n\n## 코드 결과\n\n<img src=\"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 그리드의 문제를 해결하는 부분:\n\n- 행과 열을 활용한 복잡한 레이아웃 생성.\n- 레이아웃 내 항목의 크기와 위치 제어.\n- 광범위한 미디어 쿼리 없이 반응형 디자인을 손쉽게 만들기.\n\n## 그리드의 제한점:\n\n- 간단한 레이아웃에는 부담스러울 수 있으며, 해당 경우 플렉스박스가 더 적합할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 미디어 쿼리를 활용한 반응형 디자인\n\n미디어 쿼리는 반응형 디자인의 중요한 요소로, 화면 너비와 같은 기기 특성에 따라 다른 스타일을 적용할 수 있게 해줍니다.\n\n이를 통해 레이아웃이 다양한 화면 크기에 적응하여 더 나은 사용자 경험을 제공할 수 있습니다.\n\n## 기본적인 미디어 쿼리 예시:\n\n<div class=\"content-ad\"></div>\n\nMarkdown:\n\n\n# Media Query Example\n\n```css\n.responsive-container {\n  display: flex;\n  flex-wrap: wrap; /* Allows items to wrap to the next line */\n  gap: 10px;\n  background-color: #f0f0f0;\n  padding: 10px;\n}\n.responsive-item {\n  flex: 1 1 100%; /* Takes full width on small screens */\n  background-color: #007bff;\n  color: white;\n  padding: 20px;\n  text-align: center;\n}\n```\n\n**Media query for screens wider than 600px:**\n```css\n@media (min-width: 600px) {\n  .responsive-item {\n    flex: 1 1 calc(50% - 20px); /* Takes half the width on larger screens */\n  }\n}\n```\n\n**Media query for screens wider than 900px:**\n```css\n@media (min-width: 900px) {\n  .responsive-item {\n    flex: 1 1 calc(33.33% - 20px); /* Takes a third of the width on even larger screens */\n  }\n}\n```\n\n```html\n<div class=\"responsive-container\">\n  <div class=\"responsive-item\">Item 1</div>\n  <div class=\"responsive-item\">Item 2</div>\n  <div class=\"responsive-item\">Item 3</div>\n  <div class=\"responsive-item\">Item 4</div>\n  <div class=\"responsive-item\">Item 5</div>\n  <div class=\"responsive-item\">Item 6</div>\n  <div class=\"responsive-item\">Item 7</div>\n  <div class=\"responsive-item\">Item 8</div>\n  <div class=\"responsive-item\">Item 9</div>\n  <div class=\"responsive-item\">Item 10</div>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n## 미디어 쿼리가 해결하는 문제:\n\n- 다양한 화면 크기에 레이아웃을 적응시키기.\n- 다양한 장치 (데스크톱, 태블릿, 모바일)에서의 사용 향상.\n- 장치 특성에 따라 조건부로 스타일을 적용하기.\n\n# 결론\n\n플렉스박스와 그리드와 같은 CSS 레이아웃 기법 및 미디어 쿼리를 사용한 반응형 디자인 원칙을 이해하고 숙달하는 것은 현대 웹 개발에 필수적인 기술입니다.\n\n<div class=\"content-ad\"></div>\n\n이 도구들은 유연하고 적응 가능하며 사용자 친화적인 웹 레이아웃을 만드는 과정을 간편화합니다.\n\n## 추가 자료:\n\n- MDN Web Docs: Flexbox\n- MDN Web Docs: CSS Grid\n- MDN Web Docs: 미디어 쿼리\n- CSS Tricks\n\n이 CSS 레이아웃 방법과 미디어 쿼리를 활용하여 아름다운 반응형 웹 디자인을 만들어 보세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_0.png"},"coverImage":"/assets/img/2024-06-20-CSSLayoutandResponsivenessMasteringFlexboxGridandMediaQueries_0.png","tag":["Tech"],"readingTime":6},{"title":"웹소켓, NodeJS를 사용하여 Kafka 앱을 처음부터 만들면서 배운 교훈","description":"","date":"2024-06-20 03:33","slug":"2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o","content":"\n\n예전에 나는 HTML5 앱을 개발하는 일을 했었어요. 새롭게 인가된 WebSocket 표준의 강력함을 보여주는 앱들이었죠. 데이터 스트리밍 데모와 튜토리얼의 공통된 문제는 데이터의 소스입니다. 데이터는 풍부해야 하며(내 발코니의 온도 데이터는 변화가 느리고 따라서 지루합니다) 확인 가능해야 합니다(랜덤한 데이터는 시각화할 수 없습니다). 사람이 만들고 이해하기 쉬운 데이터를 사용하는 것이 종종 좋은 해결책입니다. 이 문제를 해결하기 위해 과거에 제가 개발한 앱 중 하나는 다중 사용자 드로잉 앱이었어요. 이 앱은 한 사용자의 상호작용을 다른 사용자 화면에 반영했죠.\n\n저는 Apache Kafka와 함께 일하기 시작한 이후로 Kafka 백엔드를 가진 이 간단한 데모 앱을 만들고 싶어했어요. 여러 날이 걸릴 것 같아서 미뤄왔었는데, 그리고 시간이 부족하다고 느꼈었죠.\n\n# 데모 앱에 대해\n\n저의 고수준 목표는 Kafka를 Node.js에 연결하고 Node.js가 WebSocket을 통해 브라우저와 대화할 수 있도록 하는 것이에요. 두 개의 별개의 웹 앱을 가지고 싶어요: 드로잉에 사용하는 프로듀서 앱과 다른 기기에서 드로잉을 반영하는 소비자 앱이에요. Kafka 백엔드로는 Confluent Cloud를 사용하고 싶은데, 그 이유는 Confluent에서 일하고 있기 때문일 뿐만 아니라 이와 같은 실험에 적합한 간단하고 정교한 클라우드 환경이기 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n마침내 결정해서 새로운 도전을 해보기로 했어요. 하지만 조금 다르게 해보려고 했어요: 최근에 출시된 ChatGPT-4o가 얼마나 도움이 될지 직접 시험해보고 싶었어요. 이 게시물에서는 ChatGPT와의 상호작용과 여정, 우리가 마주친 오류들, 그리고 어떻게 해결했는지에 대한 소개를 할 거예요. (내가 이 모델을 이미 사람처럼 취급하고 있다는 게 참 재미있다고 생각해.)\n\n# 아키텍처 개요\n\n![Architecture Overview](/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_0.png)\n\nConfluent Cloud에서 실행되는 Kafka 클러스터가 우리 앱의 중심에 있어요. 메시지는 drawing_topic으로 발행하고 소비해요. Kafka 상호작용의 핵심 부분은 프로듀서(왼쪽)와 컨슈머(오른쪽) Node.js 앱에 의해 처리돼요. 마지막으로, 발행해야 하는 데이터(그리기 좌표 및 그림과 관련된 일부 메타데이터)는 각각 브라우저에서 실행되는 HTML5 앱에 의해 생성(왼쪽) 및 렌더링(오른쪽)돼요.\n\n<div class=\"content-ad\"></div>\n\n# ChatGPT가 얼마나 도움이 되었나요?\n\nChatGPT의 성능에 관해 말하자면 (Github의 소스를 참고): 저는 ChatGPT의 성능에 깊은 감명을 받았습니다! 첫 번째 시도로 간단하지만 작동하는 앱을 만들어냈습니다. 문제를 작은 단위로 쪼개고 테스트할 수 있는 단계로 나누어 진행했기 때문에 전체 과정에서 운전자의 자리에 있었습니다. ChatGPT는 두 가지 오류를 범했지만, 제가 지적하자 바로 해결했습니다. 이 연습의 한 부분으로, 모든 프롬프트, 응답, 그리고 코드 조각들을 자세하게 공유하고자 합니다. 이를 통해 우리 빠르게 변화하는 세상에 대한 일부 힌트나 스냅샷이 될 것이라고 생각합니다.\n\n저는 깊은 인상을 받았지만 동시에 걱정도 되고 있습니다. 우리의 이 새로운 세계가 실패할 위기의 상황이 되지 않기를 소망하며요.\n\n# 작동 중인 앱\n\n<div class=\"content-ad\"></div>\n\n여기 앱이 어떻게 동작하는지 보여주는 GIF 파일이 있어요. 왼쪽 브라우저에서 마우스로 그림을 그리고 있어요. 그 아래에 있는 터미널 창에서 Node.js 애플리케이션이 Kafka 토픽에 메시지를 발행하고, 메시지가 스크롤되고 있어요. 오른쪽에는 다른 브라우저에서 메시지를 소비하는 것을 볼 수 있어요. 제 그림을 그리는 영역 아래에는 Chrome 개발자 도구 콘솔에서 소비 앱에 도착한 메시지를 보여줘요.\n\n중요한 점은 두 브라우저가 로컬에서 실행되는 것이지만 (내 컴퓨터에서 실행 중), 메시지가 흐르는 Kafka 클러스터는 클라우드에 위치하고 있다는 것이에요. 이 애플리케이션은 이와 같은 시스템에서 기대할 수 있는 대략적인 지연 시간에 대한 아이디어를 제공해줍니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*6mgRUEq_ou44GxWiaU7FPg.gif\" />\n\n# 목차 — 어떤 식으로든\n\n<div class=\"content-ad\"></div>\n\n우리가 가는 방향에 대한 아이디어를 주기 위해, 여기 ChatGPT에 제공한 모든 프롬프트를 읽을 수 있습니다. 이 글의 목차 같은 역할을 할 수 있어요. GitHub 저장소로 바로 이동하거나 아래 프롬프트를 따라올 수 있습니다.\n\n시작해 보겠습니다...\n\n프롬프트 1\n\nChatGPT의 답변 및 모든 소스 코드를 보려면 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n프롬프트 4\n\nChatGPT의 답변 및 모든 소스 코드를 확인하려면 클릭하세요.\n\n프롬프트 5\n\nChatGPT의 답변 및 모든 소스 코드를 확인하려면 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 다음 단계\n\n이 포스트에서는 앱을 간단히 유지하고 싶었지만, 몇 가지 아이디어가 더 발전할 수 있을 것 같아요:\n\n- UI 개선, CSS로 앱 꾸미기: 현재 UI의 스크린샷을 찍어 모델에게 CSS 개선 제안을 해달라고 요청하세요. 색상, 선 굵기, 지우기, 되돌리기 등 여러 기능을 추가하여 봄.\n- 음성 명령을 포함한 자연어 기능 추가: 그대신 그림을 그리도록 음성 명령에 대한 기능을 추가하세요.\n- 소비자 및 프로듀서 HTML5 앱 병합: 이들을 하나로 결합하여 전체 협업 경험을 제공하는 단일 앱으로 만드세요. 이렇게 하면 모든 클라이언트가 그림을 그리고 다른 클라이언트의 그림을 보는 것이 가능해져서 Google 문서와 유사한 경험을 제공할 수 있어요.\n- 백엔드 아키텍처 간소화: 두 개의 Node.js 앱을 하나의 앱으로 병합하여 코드를 최적화하고 앱을 더 쉽게 관리할 수 있도록 만드세요.\n- Kafka와 영속 메시지 로그를 활용하는 것을 고려하면, 메시지를 되돌려 다시 그림을 그릴 수도 있어요. 각 메시지에 연관된 타임스탬프를 사용하여 그림을 빨리 또는 천천히 그릴 수도 있어요.\n\n<img src=\"/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n모델의 도움을 받아 약 한 시간 만에 완전히 작동하는 프로토 타입 앱을 만들 수 있었습니다. 생산 준비가 된 상태는 아니지만, 보통의 귀찮음과 기술적인 어려움이 대부분 없는 기술을 배우는 놀라운 방법입니다.\n\n나는 목표를 명확히 가지고 이 연습에 임했습니다. 이벤트 주도 방식으로 문제를 해결하는 방법, 클라이언트 및 서버 측에서 사용하려는 기술, 그리고 서로 통신하는 방법에 대해 알고 있었습니다. 게다가, 모델을 안내할 그림 그리기 앱의 예도 있었습니다.\n\n두 번의 경우에 솔루션이 조금 부적절했습니다 (프롬프트 4 및 7). 코드에 문제가 있는 이유에 대해 의아해할 수 있습니다. 이 부분에서는 시간이 지남에 따라 상당한 개선이 예상됩니다. 제 프롬프트가 다소 모호했을 수도 있고, 모델이 제 목표를 완벽하게 이해하지 못했을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이번 연습에서 코드 작성에 집중하지 않았지만, 문제를 마주했을 때 명확한 증상과 오류 메시지를 제공하여 모델의 도움을 효과적으로 활용했습니다. 구글링, StackOverflow 검색 또는 문서 읽기는 필요하지 않았어요 — 간단한 영어 프롬프트만 있으면 돼요.\n\n지식을 나누고 전달하는 데 열정을 가진 사람으로써 나는 항상 YouTube를 지식을 민주화하는 최고의 도구로 보아왔어요. 이 연습은 대형 언어 모델이 많은 이전 가정에 도전하며 이를 다음 수준으로 이끌고 있다는 것을 보여줍니다.\n\n우리는 몇 년 전과는 근본적으로 다른 세상에서 살고 있으며, 나는 그것이 나를 흥분시키고 동시에 걱정도되도록 느끼게 해요.","ogImage":{"url":"/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_0.png"},"coverImage":"/assets/img/2024-06-20-LessonsLearnedfromBuildingaKafkaAppFromScratchUsingWebSocketNodeJSwithChatGPT-4o_0.png","tag":["Tech"],"readingTime":5},{"title":"Pumpi - 유기농 채소 쇼핑몰 20 테마","description":"","date":"2024-06-20 03:32","slug":"2024-06-20-PumpiOrganicVegetablesShopify20Theme","content":"\n\n🔍 Pumpi- Organic Vegetables Shopify 2.0 테마를 확인해보세요! 📁 Shopify CMS 템플릿 라이브러리를 살펴보고 🆓 무료 다운로드를 받아보세요. 함께 만들어 봐요! 🚀\n\nPumpi는 유기농 식품을 위해 특별히 디자인된 테마에요. 유기농 식품은 기존 식품보다 항산화제와 영양소가 더 많을 수 있지만, 아직까지 그 증거는 매우 제한적이에요. 유기농 식품을 섭취하면 인공 화학물질, 호르몬 및 항생제에 저항성이 있는 박테리아에 노출될 위험이 줄어들 수 있어요.\n\nPumpi는 스마트 필터를 갖춘 완벽한 스토어 프론트를 지원해요. 페이지가 로드되길 기다릴 필요 없이 초고속으로 제공될 거에요. 또한 Instant Product Search 시스템을 갖춘 Pumpi는 입력하는 대로 즉시 결과를 찾아주며, 시간을 기다릴 필요가 없어요. Pumpi 테마는 SEO 친화적으로 설계되었으며 HTML 5 표준을 준수해요. 많은 기사나 동일한 페이지에서 로드되는 다양한 제품이 있더라도 가장 빠른 페이지 로드 속도를 제공하도록 설계되었어요.\n\nPumpi는 코드 지식이나 웹마스터 없이도 누구나 쉽게 사용할 수 있어요. 모든 데모는 한 번의 클릭으로 빠르게 가져올 수 있어요. 체험하기 위해 데모를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n테마 기능\n\n- 섹션 드래그 & 드롭 페이지 빌더\n- 전체 Oberlo 호환성\n- 약관 및 동의 사항 카트에 추가\n- 함께 구매하기\n- 업셀 제품\n- 서브 컬렉션 페이지\n- 페이스북 채팅\n- 다이내믹 체크아웃 준비\n- 새로운 룩북\n- 주문제품 알림\n- 360도 제품 뷰\n- 카트에 추가 팝업\n- 고급 변수 스와치\n- Ajax 제품\n- Ajax 검색\n- 소셜 공유\n- 모바일 기기에 최적화\n- 고정 ATC 및 소셜\n- 사이즈 안내 팝업\n- 강력한 필터\n- 인스타그램 샵\n- 팝업 로그인\n- 자동 가격 변경\n- 유연한 내장형 메가 메뉴\n- 퀵뷰 제품 색상\n- 스마트 제품 퀵뷰\n- 고급 계층적 네비게이션\n- 무제한 구글 폰트\n- 사이트 식별\n- 헤더 및 푸터 스타일 옵션\n- 내장형 놀라운 슬라이더\n- 무제한 색상\n- SEO 최적화\n- “New”, “Hot”, “Sale”… 레이블\n- 다국화 지원\n- 놀라운 레이아웃 변화\n- 뉴스레터\n- 반응형 및 레티나 대응\n- 헤더에 드롭다운 장바구니\n- 다양한 스티키 헤더 스타일\n- Ajax 장바구니 & 위시리스트 추가\n- Ajax 페이징 및 Ajax 도구 모음 내장\n- Ajax 그리드 및 목록 보기 컬렉션\n- 제품 보기 페이지에 이전 및 다음 기능\n- 업셀 제품 및 관련 제품 블록용 슬라이더\n- 내장 제품 확대 기능\n- 베스트셀러 제품\n- 맨 위로 버튼\n- 배경 패턴 및 색상 선택기\n- 탭\n- 그리드 / 목록 보기\n- 제품 속성에 대한 \"추가 정보\" 탭\n- 브랜드 로고 슬라이더\n- 내장된 블로그 포스트 슬라이더\n- FontAwesome 아이콘\n- 원 클릭 가져오기\n- 크로스 브라우저 지원\n- 고객 리뷰\n- 연락처\n- 제품 캐러셀\n- HTML5 및 CSS3 및 Sass CSS\n- 소셜 네트워킹\n- 온라인 24/7 지원\n- 상세 문서화\n\n![이미지](/assets/img/2024-06-20-PumpiOrganicVegetablesShopify20Theme_0.png)\n\nEngoTheme님의 Envato Elements에서 제공하는 사진\n\n<div class=\"content-ad\"></div>\n\n면책 조항: 본 글에는 제휴 링크가 포함되어 있습니다. 이는 이 링크를 통해 구매를 하시는 경우 추가 비용 없이 수수료를 받을 수 있음을 의미합니다.","ogImage":{"url":"/assets/img/2024-06-20-PumpiOrganicVegetablesShopify20Theme_0.png"},"coverImage":"/assets/img/2024-06-20-PumpiOrganicVegetablesShopify20Theme_0.png","tag":["Tech"],"readingTime":2},{"title":"앵귤러 애플리케이션에서의 environmentts 파일에 대하여","description":"","date":"2024-06-20 03:30","slug":"2024-06-20-AboutenvironmenttsinyourAngularapplications","content":"\n\n`<img src=\"/assets/img/2024-06-20-AboutenvironmenttsinyourAngularapplications_0.png\" />`\n\nEnvironment.ts는 애플리케이션 설정을 보관하는 일반적인 장소입니다. Angular 애플리케이션의 컴포넌트, 파이프 또는 다른 TypeScript 파일에 설정을 직접 하드코딩하는 대신 환경 파일에 애플리케이션 설정을 저장하면 다양한 애플리케이션 환경에서 다른 설정을 가질 수 있습니다. 또한, 모든 애플리케이션 설정이 한 파일에 집중되어 필요에 따라 쉽게 수정할 수 있습니다.\n\n환경.ts는 Angular 문서에서 잘 문서화되어 있지만 Angular 애플리케이션 구축 및 실행 주제에서 유지됩니다. 따라서 일부 사용자는 환경.ts 파일의 사용법을 모를 수 있습니다.\n\n# 면책 조항\n\n<div class=\"content-ad\"></div>\n\n이 문서는 Angular 공식 문서와 거의 유사합니다. 환경 설정을 더 잘 다루는 방법을 이해할 수 있도록 이 문서에 추가 정보를 포함했습니다. 이 문서는 오래되었을 수 있으니 항상 최신 정보를 참조하려면 공식 Angular 문서를 참고하세요: Angular 애플리케이션 빌드 및 제공.\n\n# 환경 폴더 구조\n\n모든 Angular 프로젝트에 environments 폴더가 있습니다. 이 폴더는 모든 애플리케이션 설정이 환경별로 보관되는 곳입니다. environment.ts는 기본 환경 파일로 프로젝트에서 참조됩니다.\n\n```js\nyourProject/src/environments\n- environment.ts\n- environment.prod.ts\n```\n\n<div class=\"content-ad\"></div>\n\n# environment.ts 파일 사용 방법\n\n여러 개의 파일이 environments 폴더에 있기 때문에 무엇을 가져와야 할지 궁금할 수 있습니다. 애플리케이션 설정을 사용하려면 environment.ts 파일을 가져오기만 하면 됩니다. 아래에서 이유를 설명하겠습니다.\n\n```js\nimport { environment } from './../environments/environment';\n```\n\n아래 스니펫은 app.component.ts가 environment.ts 파일에서 변수를 사용하는 방법을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// app.component.ts\nimport { Component } from '@angular/core';\nimport { environment } from './../environments/environment';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  constructor() {\n    if(environment.production) { // 👈🏻👈🏻👈🏻\n      // 만약 이것이 프로덕션 환경이라면 구현 코드 작성\n    }\n  }\n  title = 'app works!';\n}\n```\n\n# environment.ts 파일의 production 변수\n\n새로운 Angular 애플리케이션을 생성할 때마다 미리 설정된 production 변수를 찾을 수 있습니다.\n\n```js\n// 이 파일은 `fileReplacements` 배열을 사용하여 빌드 중에 대체될 수 있습니다.\n// `ng build --prod`는 `environment.ts`를 `environment.prod.ts`로 대체합니다.\n// 파일 대체 목록은 `angular.json`에서 찾을 수 있습니다.\n\nexport const environment = {\n  production: false // 👈🏻👈🏻👈🏻\n};\n```\n\n<div class=\"content-ad\"></div>\n\n질문: 이 변수를 삭제할 수 있을까요? 답은 아니요입니다. 왜냐하면 이 변수는 main.ts에서 사용되어 있어서 production 변수가 true로 설정된 경우 production 모드를 활성화하는 데 사용됩니다. Production 모드를 활성화하면 Angular은 변경 감지 과정이 어떤 바인딩에 추가 변경 사항이 생기지 않는지 확인하여 응용 프로그램 성능을 향상시킵니다 (일방향 데이터 흐름이라고도 함). 이 enableProdMode 메서드에 대해 자세히 다루지는 않겠습니다. enableProdMode에 대해 더 알고 싶다면 이 기사에서 enableProdMode가 무엇을 하는지 자세히 읽어보시기 바랍니다: https://lukaonik.medium.com/what-is-the-difference-between-production-and-development-mode-in-angular-3eed82b9cf73. 다시 말해서, 응용 프로그램을 디버깅하지 않을 때는 production 변수를 항상 true로 설정해야 합니다.\n\n```js\nimport { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode(); // 👈🏻👈🏻👈🏻\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n```\n\n팁: Angular은 앱이 개발 모드에서 실행 중인지 확인하기 위한 유틸리티 함수를 제공합니다.\n\n```js\nimport { Component, OnInit, isDevMode } from '@angular/core';\n\n@Component({ ... })\nexport class AppComponent implements OnInit {\n  ngOnInit() {\n    if (isDevMode()) { // 👈🏻👈🏻👈🏻\n      console.log('Development!');\n    } else {\n      console.log('Production!');\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# environment.ts 파일에 변수를 추가하고 Angular 애플리케이션에서 이 변수를 사용하세요.\n\n필요에 따라 environment.ts 파일에 하나 이상의 변수를 추가할 수 있습니다. environment.ts에 enableLogging이라는 간단한 변수를 추가해 봅시다:\n\n```js\n// environment.ts\n\n// 이 파일은 `fileReplacements` 배열을 사용하여 빌드 중에 교체될 수 있습니다.\n// `ng build --prod`는 `environment.ts`를 `environment.prod.ts`로 대체합니다.\n// 파일 교체 목록은 `angular.json`에서 찾을 수 있습니다.\n\nexport const environment = {\n  production: false,\n  enableLogging: true\n};\n```\n\n새로 추가된 이 변수를 사용하려면 environment.ts 파일을 import하여 Angular 애플리케이션의 모든 TypeScript 파일에서 사용하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// app.component.ts\n\nimport { Component } from '@angular/core';\nimport { environment } from './../environments/environment'; // 👈🏻👈🏻👈🏻\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  constructor() {\n    if(environment.enableLogging) { // 👈🏻👈🏻👈🏻\n      console.log('Angular app started');\n    }\n  }\n  title = 'app works!';\n}\n```\n\n# 환경별 응용 프로그램 설정 구성\n\n일반적으로 한 애플리케이션 당 여러 환경이 있습니다. Angular 애플리케이션의 설정은 개발자마다 다를 수 있습니다. 그럼에도 불구하고 추가 환경을 구성하려면 개발 및 프로덕션 환경 이외의 환경을 설정해야 합니다.\n\n기본적으로 Angular 애플리케이션에는 environment.ts 및 environment.prod.ts가 있습니다. 저는 개발 환경으로 environment.ts를 사용합니다. 지역에서 Angular 애플리케이션을 개발하기 때문에 명령에 추가 인수를 추가할 필요가 없고, environment.ts가 기본 설정으로 사용됩니다. 반면 프로덕션 환경에서는 ng serve --configuration production과 같은 추가 매개변수를 전달해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n기존 Angular 애플리케이션을 위한 스테이징 환경을 구성해 보겠습니다.\n\n먼저 environments 폴더에 새 파일을 추가해야 합니다. 파일의 네이밍 컨벤션은 environment.`environment_name`.ts 입니다. environment.staging.ts 라는 파일을 다음 내용과 함께 생성해 봅시다:\n\n```js\n// environments/environment.staging.ts\nexport const environment = {\n  production: true // 애플리케이션을 디버깅 중이 아니라면 true\n};\n```\n\n그 다음, environment.ts에 있는 모든 변수는 이 environment.staging.ts에 있어야 합니다. 왜냐하면 environment.staging.ts가 컴파일 시(environment.ts 파일 대체) 필요하기 때문입니다 (ng serve 또는 ng build). 따라서 environment.staging.ts 파일에 누락된 변수가 없어야하며, 그렇지 않으면 컴파일이 실패할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n안전을 위해 environment.ts의 내용을 environment.staging.ts로 복사한 후 environment.staging.ts의 설정을 스테이징 설정으로 수정하세요. 이제 environment.staging.ts를 마친 것입니다.\n\nng build를 위한 angular.json 확장\n\nng build 명령어는 Angular 애플리케이션을 컴파일하는 데 사용됩니다. 스테이징 환경으로 애플리케이션을 컴파일해야 할 때는 ng build --configuration staging이 필요합니다. 이 명령어를 실행하려고 하면 지금처럼 오류 메시지가 나올 것입니다.\n\n이는 angular.json에서 스테이징 구성을 설정하지 않았기 때문입니다. 루트 폴더의 angular.json으로 이동하여 build configurations에서 production 구성을 복사하고 (아래 스니펫에서 production 구성 위치를 확인하십시오), 복사한 구성을 production 구성 바로 아래에 붙여넣으세요. 붙여넣은 구성의 이름을 staging으로 변경하고 파일 교체 경로를 스테이징 환경 파일 경로로 설정하세요. 이제 ng build --configuration staging을 다시 실행하면 성공적으로 빌드할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n만약 주목했다면, configurations 맨 끝에 defaultConfiguration 설정이 있습니다. 이 설정은 ng build를 실행할 때 기본 구성을 설정하는 것입니다. 어떤 구성도 지정하지 않았다면 빌더는 defaultConfiguration에서 구성을 사용합니다. 지금 ng build를 실행하면 기본 구성은 프로덕션 구성이 될 것입니다.\n\n```js\n{\n    [...]\n    \"projects\": {\n      \"your-project-name\": {\n        [...]\n        \"architect\": {\n          \"build\": {\n            [...]\n            \"configurations\": { \n              \"production\": { // 👈🏻👈🏻👈🏻 이 섹션을 복사하세요\n                \"budgets\": [\n                  {\n                    \"type\": \"initial\",\n                    \"maximumWarning\": \"500kb\",\n                    \"maximumError\": \"1mb\"\n                  },\n                  {\n                    \"type\": \"anyComponentStyle\",\n                    \"maximumWarning\": \"2kb\",\n                    \"maximumError\": \"4kb\"\n                  }\n                ],\n                fileReplacements: [\n                  {\n                    replace: 'src/environments/environment.ts',\n                    with: 'src/environments/environment.production.ts',\n                  },\n                ],\n                \"outputHashing\": \"all\"\n              },\n              \"staging\": { // 👈🏻👈🏻👈🏻 여기에 붙여넣고 staging으로 이름을 변경하세요\n                \"budgets\": [\n                  {\n                    \"type\": \"initial\",\n                    \"maximumWarning\": \"500kb\",\n                    \"maximumError\": \"1mb\"\n                  },\n                  {\n                    \"type\": \"anyComponentStyle\",\n                    \"maximumWarning\": \"2kb\",\n                    \"maximumError\": \"4kb\"\n                  }\n                ],\n                fileReplacements: [\n                  {\n                    replace: 'src/environments/environment.ts',\n                    with: 'src/environments/environment.staging.ts', // 환경 파일 경로를 staging 환경 파일 경로로 변경하세요\n                  },\n                ],\n                \"outputHashing\": \"all\"\n              },\n              [...]\n            },\n            \"defaultConfiguration\": \"production\"\n          },\n          [...]\n        }\n      }\n    }\n  }\n```\n\nng serve를 위해 angular.json을 확장하기\n\nng serve는 Angular 애플리케이션을 로컬에서 실행하려는 경우 사용하는 명령어입니다. 이 명령은 애플리케이션을 빌드하고 서비스하며 파일 변경 시 다시 빌드합니다. 이미 ng build를 설정했습니다. ng serve는 빌드 구성을 사용하여 애플리케이션을 빌드하고 제공합니다. 그런 다음 다음 형식의 serve 구성을 serve configurations에 추가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n\"<환경 이름>\": {\n  \"browserTarget\": \"your-project-name:build:<빌드 구성에서의 환경 이름>\"\n},\n```\n\n스테이징 환경에서는 angular.json 파일이 다음과 같이 보일 것입니다.\n\n```js\n{\n    [...]\n    \"projects\": {\n      \"your-project-name\": {\n        [...]\n        \"architect\": {\n          [...]    \n          \"serve\": {\n            \"builder\": \"@angular-devkit/build-angular:dev-server\",\n            \"configurations\": {\n              \"production\": {\n                \"browserTarget\": \"your-project-name:build:production\"\n              },\n              \"staging\": { // 👈🏻👈🏻👈🏻 이 serve 구성을 추가합니다\n                \"browserTarget\": \"your-project-name:build:staging\"\n              },\n              \"development\": {\n                \"browserTarget\": \"your-project-name:build:development\"\n              }\n            },\n            \"defaultConfiguration\": \"development\"\n          },\n          [...]\n        }\n      }\n    }\n  }\n```\n\nng serve --configuration staging 명령을 실행하면 스테이징 설정으로 애플리케이션을 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Angular schematic을 사용하여 환경 추가하기\n\nAngular 애플리케이션에 환경 하나를 추가하면 구성해야 할 설정이 많을 것이라고 생각할 수 있습니다. 그리고 왜 자동으로 추가되지 않는 것인지 의아해할 수도 있습니다. 걱정하지 마세요. Angular CLI(버전 15.1 이상)에는 새로운 schematic이 추가될 예정입니다. 이를 통해 Angular 애플리케이션에 환경을 추가할 수 있습니다. 이 작업은 단순히 다음 명령을 실행하면 됩니다. `ng generate environments`를 실행하면 새로운 환경이 Angular 애플리케이션에 추가됩니다. 이에 대한 자세한 내용은 여기에서 확인할 수 있습니다: [Bring back environment.ts to new projects · Issue #24381 · angular/angular-cli · GitHub](https://github.com/angular/angular-cli/issues/24381)\n\n# 결론\n\nAngular 애플리케이션에 새로운 환경을 구성하는 것은 흥미로운 작업이라고 생각합니다. Angular 팀이 프레임워크를 구현하는 방식을 살펴볼 때마다 항상 뭔가를 배우게 됩니다. 여러분도 새로운 환경을 구성하는 방법을 익히고, 더 쉬운 방법이 제공되는 schematic이 나올 것이라는 것을 알아두시면 좋겠습니다.","ogImage":{"url":"/assets/img/2024-06-20-AboutenvironmenttsinyourAngularapplications_0.png"},"coverImage":"/assets/img/2024-06-20-AboutenvironmenttsinyourAngularapplications_0.png","tag":["Tech"],"readingTime":10},{"title":"스크롤할 때 멋진, 축소 가능한 헤더로 내비게이션을 변환해 보세요 ","description":"","date":"2024-06-20 03:29","slug":"2024-06-20-Transformyournavigationwithasleekshrinkableheaderonscroll","content":"\n\n<img src=\"/assets/img/2024-06-20-Transformyournavigationwithasleekshrinkableheaderonscroll_0.png\" />\n\n웹 디자인에서 스크롤할 때 헤더를 축소하는 것은 사용자 경험을 향상시키는 일반적인 기술입니다. 사용자가 페이지를 아래로 스크롤할수록 내비게이션 바를 더 조밀하게 만들어 화면 공간을 절약하는 동시에 필수적인 내비게이션 링크를 산만하지 않게 보여줍니다. 이 기능을 구현하기 위해서는 HTML로 구조를 만들고 CSS로 스타일을 지정하며 JavaScript로 스크롤 동작을 처리해야 합니다.\n\n이 글에서는 페이지를 스크롤할 때 높이가 자연스럽게 축소되는 슈링크 헤더를 만드는 방법에 대해 살펴보겠습니다. 먼저, 헤더와 페이지 내용을 위한 기본 HTML 구조를 설정합니다. 다음으로, 헤더의 확장 및 축소 상태를 정의하는 CSS로 헤더를 스타일링합니다. 마지막으로, JavaScript를 추가하여 스크롤 이벤트를 감지하고 적절한 클래스를 헤더에 적용하여 축소 효과를 발생시킵니다.\n\n이 튜토리얼을 마치면 웹페이지의 사용성과 미학을 향상시키는 기능적인 슈링크 헤더를 가지게 될 것입니다. 이 안내서는 웹사이트에 세련된 터치를 더하고자 하는 초보자와 경험 있는 개발자 모두에게 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n이 효과를 위한 두 가지 중요한 부분이 있어요.\n\n구조 생성: HTML 섹션에서 사용자가 페이지를 스크롤할 때 네비게이션 바가 줄어드는 효과를 보여주는 기본적인 웹사이트 레이아웃을 설정할 거에요.\n\n디자인 구성: CSS 및 JavaScript 섹션에서 우리는 네비게이션 바를 스타일링하고 JavaScript를 사용하여 사용자가 스크롤할 때 네비게이션 바가 부드럽게 줄어드는 효과를 구현할 거에요.\n\n전체 코드\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<html>\n\n<head>\n <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n <title>\n  페이지 제목\n </title>\n <style>\n  CSS 스타일 내용\n </style>\n\n <script>\n  JavaScript 스크립트 내용\n </script>\n\n</head>\n\n\n<body>\n <!-- 헤더 내비게이션 -->\n <div id=\"navlist\">\n  <a href=\"#default\" id=\"logo\">\n   CODEMAGNET\n  </a>\n\n  <div id=\"navlist-right\">\n   <a href=\"#home\">홈</a>\n   <a href=\"#about\">제품</a>\n   <a href=\"#about\">경력</a>\n   <a href=\"#contact\">문의</a>\n   <a href=\"#about\">회사 소개</a>\n  </div>\n </div>\n\n <!-- 페이지 내용 -->\n <div class=\"content\">\n  <b>\n   열정을 가진 코딩 포털\n  </b>\n  <p>\n   뛰어난 코딩 포털에 오신 것을 환영합니다. 모든 수준의 열정적인 사람들이 모여 배우고 공유하며 성장할 수 있는 곳입니다! 프로그래밍 열정을 키우는 데 필요한 다양한 리소스, 자습서 및 커뮤니티 지원에 몰입해 보세요. #코딩 #코드배우기 🚀💻\n  </p>\n </div>\n</body>\n\n</html>\n```\n\n자세한 내용은 아래 링크를 확인해주세요.\n\nhttps://codemagnet.in/2024/06/18/create-shrink-header-on-scroll-html-css-and-javascript/\n","ogImage":{"url":"/assets/img/2024-06-20-Transformyournavigationwithasleekshrinkableheaderonscroll_0.png"},"coverImage":"/assets/img/2024-06-20-Transformyournavigationwithasleekshrinkableheaderonscroll_0.png","tag":["Tech"],"readingTime":2},{"title":"자바스크립트 HTML 리치 텍스트 편집기","description":"","date":"2024-06-20 03:27","slug":"2024-06-20-JavascriptHTMLRich-TextEditors","content":"\n\n리치 텍스트 편집기 또는 WYSIWYG 편집기를 사용하면 사용자가 스타일이 적용된 텍스트, 이미지, 목록, 코드 블록 등을 입력할 수 있습니다. 만약 여러분이 마크다운으로 작성할 수 없는 사용자를 대상으로 한 웹사이트에서 텍스트/문서 입력을 구축 중이라면 이 접근 방식이 유용할 것입니다.\n\n이 글에서는 모든 현대적인 웹에 쉽게 통합할 수 있는 뛰어난 무료 오픈 소스 WYSIWYG인 Quill로 이러한 편집기를 만드는 방법을 안내해 드릴 것입니다.\n\n# 기본 예제\n\n우리의 프로젝트에 필요한 JavaScript 및 CSS 파일을 포함시켜 시작하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- 스타일시트 포함 -->\n<link href=\"https://cdn.quilljs.com/1.3.6/quill.snow.css\" rel=\"stylesheet\">\n<!-- Quill 라이브러리 포함 -->\n<script src=\"https://cdn.quilljs.com/1.3.6/quill.js\"></script>\n```\n\n또는 저처럼 코드 펜을 사용하는 경우 설정을 클릭하고 위의 Css 및 Js 링크를 추가해주세요.\n\n<img src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png\" />\n\n가장 간단한 형태로 시작해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nMarkdown\n\n```js\nvar quill = new Quill('#editor', {\n    theme: 'snow'\n});\n```\n\n<div class=\"content-ad\"></div>\n\nCSS: 없음\n\n그래, 이 간단한 리치 텍스트 편집기를 얻기 위해 해야 할 일은 이것뿐이에요. 여기서 글꼴 크기를 변경하거나 스타일을 추가/삭제할 수 있습니다.\n\n![리치 텍스트 편집기](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_1.png)\n\neditor라는 id를 설정하고 Quill 편집기를 초기화하는 데 사용하고 있습니다. 그러나 CSS 선택기나 DOM 객체를 전달할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 다음과 같이 classname editor를 전달하면 Quill이 첫 번째 일치하는 요소에 에디터를 생성합니다.\n\n```js\nvar editor = new Quill('.editor');  \n```\n\n또는 DOM 객체를 전달할 수도 있습니다.\n\n```js\nvar container = document.getElementById('editor');\nvar editor = new Quill(container);\n```\n\n<div class=\"content-ad\"></div>\n\n만약 툴바에 폭과 같은 추가 스타일링을 하고 싶다면, 에디터 자체의 스타일을 변경하는 것은 작동하지 않을 것입니다. 다음과 같이 결과물이 나올 것입니다.\n\n![example image](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_2.png)\n\n이를 수행하는 방법은 3가지가 있습니다.\n\nQuill은 툴바를 위한 클래스인 ql-toolbar를 사용하므로 아래와 같이 스타일을 오버라이드할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_3.png)\n\n또는 전체 편집기를 사용자 정의 컨테이너에 임베드하고 컨테이너 너비를 변경할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_4.png)\n\n세 번째 옵션은 new Quill()를 호출하고 편집기를 만들 때 추가 구성을 추가하는 것입니다. 다음 부분에서 이에 대해 자세히 살펴보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n좋아요! 이제 리치 텍스트 편집기가 아닌 스타일이 좀 적은 편집기가 되었네요!\n\n## 사용자 정의\n\nQuill로 더 풍부하게 만들어 보겠습니다.\n\n이 라이브러리는 사용자 정의와 확장을 염두에 두고 설계되었습니다. 우리의 요구에 맞게 커스터마이즈하는 다양한 방법이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- Configuration: 기존 기능을 조정하는 데 사용됩니다\n- Modules: 새로운 기능을 추가하는 데 사용됩니다\n- Themes: 스타일링을 위해 사용됩니다\n\n# 구성\n\n먼저 기존 기능을 어떻게 조정할 수 있는지 살펴보겠습니다.\n\n우리가 위에서 사용한 javascript에서 'theme: ‘snow’'를 추가했다는 점을 유의해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar quill = new Quill('#editor', {\n  theme: 'snow'\n});\n```\n\n이것은 Quill에서 인식하는 옵션 중 하나입니다. 전체 목록을 확인할 수 있고, 저는 발견한 몇 가지를 여러분에게 보여드릴게요.\n\n## 모듈\n\n새 기능을 추가할 때 사용할 키입니다. 곧 자세히 살펴볼 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n이외에도 몇 가지 매우 중요한 미리 만들어진 것들이 있어요.\n\n- 툴바\n\n아래에는 위에서 보여드렸던 기본적인 것이 있어요\n\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n아래에 보이는 내용입니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_6.png)\n\n색상 및 배경에 대해 빈 배열을 가지고 있더라도 여전히 선택할 수 있는 멋진 색 팔레트를 얻을 수 있습니다.\n\n이는 테마가 드롭다운을 위해 기본값을 지정할 수 있기 때문입니다. 위의 예에서 우리는 Snow를 사용하고 있으며, 색상 및 배경 형식에 대해 빈 배열로 설정하면 색상 목록에서 기본값으로 35가지 색상을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n위의 예시에서는 단순히 기존의 어트리뷰터를 선택했습니다. 그러나 여러분은 이를 사용자 정의할 수도 있어요. 예를 들어, 사용자 지정 글꼴을 추가하려면:\n\n```js\nvar FontAttributor = Quill.import('attributors/class/font');\nFontAttributor.whitelist = [\n  'sofia', 'slabo', 'roboto', 'inconsolata', 'ubuntu'\n];\nQuill.register(FontAttributor, true);\n```\n\n```js\n.ql-font-roboto {\n  font-family: 'Roboto', sans-serif;\n}\n```\n\n더 많은 사용자 정의와 제어를 원하신다면, HTML에서 직접 툴바를 만들고 DOM 요소나 셀렉터를 Quill에 전달할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- 툴바 컨테이너 생성 -->\n<div id=\"toolbarContainer\">\n  <!-- 글꼴 크기 드롭다운 추가 -->\n  <select class=\"ql-size\">\n    <option value=\"small\"></option>\n    <!-- 주의: 값이 없어서 기본 값으로 재설정됨 -->\n    <option selected></option>\n    <option value=\"large\"></option>\n    <option value=\"huge\"></option>\n  </select>\n  <!-- 굵게 버튼 추가 -->\n  <button class=\"ql-bold\"></button>\n  <!-- 아래 첨자 및 위첨자 버튼 추가 -->\n  <button class=\"ql-script\" value=\"sub\"></button>\n  <button class=\"ql-script\" value=\"super\"></button>\n</div>\n<div id=\"editor\">\n</div>\n```\n\n```js\nvar options = {\n  modules: {\n    toolbar: {\n      container: '#toolbarContainer',  \n      handlers: {\n        'bold': customBoldHandler\n      }\n    }\n  },\n  theme: 'snow'\n};\n\nvar quill = new Quill('#editor', options);\n```\n\n만약 사용자 정의 컨테이너를 사용한다면, 컨트롤도 직접 설정해야 합니다. 그렇지 않으면 빈 툴바가 나타날 수 있습니다. 아래와 같이 확인하세요.\n\n<img src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_7.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar toolbarHanlderOptions = {\n  handlers: {\n    'link': function(value) {\n      if (value) {\n        var href = prompt('URL을 입력하세요');\n        this.quill.format('link', href);\n      } else {\n        this.quill.format('link', false);\n      }\n    }\n  }\n}\n\nvar options = {\n  modules: {\n    toolbar: toolbarHanlderOptions,\n  },\n  theme: 'snow'\n};\n\nvar quill = new Quill('#editor', options);\n```\n\n우리는 다음을 받게 될 것입니다\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*QpD3jR3s6v4M_nUWwLOFdg.gif\" />\n\n핸들러 함수는 툴바에 바인딩되어 있으므로 this를 사용하면 툴바 인스턴스를 참조하게 됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n위 조정 도구 모양에 대한 자세한 내용은 여기에서 확인할 수 있어요.\n\n- 구문\n\n이 모듈은 구문 강조 효과를 적용하여 코드 블록 포맷을 강화합니다. 코드 블록을 자동으로 감지하고 구문 강조를 적용하기 위해 훌륭한 highlight.js 라이브러리가 사용됩니다.\n\n사용하려면 먼저 마음에 드는 highlight.js 스타일 시트를 추가하고 highlight.js 라이브러리를 포함시키세요.\n\n<div class=\"content-ad\"></div>\n\n만약 제가 사용하고 있는 것처럼 codepan.io를 사용 중이라면, 설정 옵션을 통해이를 추가하는 것이 작동하지 않을 수 있으며 수동으로 HTML에 다음과 같이 추가해야 합니다.\n\n```js\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js\"></script>\n```\n\n그런 다음 툴바 옵션에 코드 블록을 포함시키십시오. 저 위의 예제를 사용 중이라면 이미 포함되어 있어야 합니다.\n\n모듈에 구문 키를 추가하고 구문 모듈을 포함하려면 true로 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar quill = new Quill('#editor', {\n  modules: {\n    syntax: true,              \n    toolbar: [['code-block']]  \n  },\n  theme: 'snow'\n});\n```\n\n아래와 같이 특정 언어 또는 모든 언어로 구성할 수도 있습니다.\n\n```js\n// 선택적으로 hljs 구성\nhljs.configure({   \n    languages: ['javascript', 'ruby', 'python']\n});\n\n// 또는 모든 언어 강조\nhljs.highlightAll();\n```\n\n## placeholder\n\n\n<div class=\"content-ad\"></div>\n\n이 옵션 키는 편집기가 비어 있을 때 표시할 자리 표시자 텍스트를 구성하는 데 사용됩니다.\n\n다음과 같은 옵션을 사용하면\n\n```js\nvar options = {\n  placeholder: '말해보세요!',\n  theme: 'snow'\n};\n\n\nvar quill = new Quill('#editor', options);\n```\n\n다음은 우리가 얻게 될 것입니다!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_8.png\" />\n\n## readOnly\n\n이 값은 에디터를 읽기 전용 모드로 초기화할지 여부를 나타냅니다. 기본값은 false입니다.\n\n사용자가 더 이상 수정할 수 없게 하고 입력한 내용을 확인해야 하는 확인 페이지를 만들고 싶을 때 이 값은 정말 유용합니다. 이 경우 툴바를 false로 설정하고 싶을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar options = {\n  modules: {\n      toolbar: false\n  },\n  readOnly: true,\n  theme: 'snow'\n}\n\nvar quill = new Quill('#editor', options);\n```\n\n## 테마\n\n이 키는 전체 스타일링을 구성하는 데 사용할 키이며 곧 자세히 살펴볼 것입니다.\n\n# 모듈\n\n\n<div class=\"content-ad\"></div>\n\n이전 섹션에서 툴바와 같은 몇 가지 미리 구축된 모듈을 이미 살펴보았습니다. 이 모듈은 확장되어 원본 모듈을 대체하거나 다시 등록할 수도 있습니다.\n\n예를 들어, 이를 통해 클립보드 모듈이 Quill과 외부 애플리케이션 간에 복사, 잘라내기 및 붙여넣기를 어떻게 처리할지 구성할 수 있습니다.\n\n```js\nvar Clipboard = Quill.import('modules/clipboard');\nvar Delta = Quill.import('delta');\n\nclass PlainClipboard extends Clipboard {\n  convert(html = null) {\n    if (typeof html === 'string') {\n      this.container.innerHTML = html;\n    }\n    let text = this.container.innerText;\n    this.container.innerHTML = '';\n    return new Delta().insert(text);\n  }\n}\n\nQuill.register('modules/clipboard', PlainClipboard, true);\n\nvar quill = new Quill('#editor');\n```\n\n그러나 때로는 (사실 대부분의 경우) 기존 모듈을 사용하거나 구성하는 것이 더 쉬울 수 있습니다. 위 예에서 기존 Clipboard의 addMatcher API가 더 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n리치 텍스트 편집기에 대한 API가 무엇인지 궁금하신가요? 조금 더 자세히 설명해 드릴게요. 실제로 이게 Quill의 가장 멋진 부분이라고 생각해요.\n\n# 테마\n\n우리는 이미 여러 차례 이 키를 사용했어요. 사용할 테마 이름입니다. 내장된 옵션은 bubble 또는 snow입니다. 잘못된 값은 기본 최소 테마를 로드합니다.\n\n- bubble: 간단한 툴팁 기반 테마입니다.\n- snow: 깨끗하고 평평한 툴바 테마이며, 위에서 반복적으로 사용한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n테마의 구체적인 스타일시트는 여전히 수동으로 포함해야 합니다. 더 많은 정보 및 추가 사용자 정의를 위해 테마를 확인해보세요!\n\n# API 주도 설계\n\n자바스크립트와 HTML을 사용하여 간단한 리치 텍스트 편집기를 만드는 방법을 보여드렸습니다. 그러나 Quill에서 가장 독특한 요소 중 하나(제 개인적인 의견으로)는 API 주도 설계입니다.\n\n대부분의 리치 텍스트 편집기는 사용자가 작성한 텍스트를 알지 못하며, 내용을 웹 개발자가 보는 렌즈로 보게 됩니다: DOM입니다. 이는 DOM이 불균형 트리로 구성된 노드로 이루어져 있지만 텍스트는 줄, 단어 및 문자로 이루어져 있기 때문에 임피던스 불일치를 초래합니다.\n\n<div class=\"content-ad\"></div>\n\n문자가 측정 단위인 DOM API가 없습니다. 이 제한으로 대부분의 리치 텍스트 에디터는 \"이 범위에 어떤 텍스트가 있는가?\" 또는 \"커서가 굵은 텍스트에 있는가?\" 같은 간단한 질문에 대답할 수 없습니다.\n\n그에 반대로, API 주도 설계를 통해 Quill은 굵은 텍스트인지 확인하려면 `b`나 `strong` 노드 또는 글꼴 두께 스타일 속성을 찾는 DOM 탐색이 필요하지 않습니다.\n\n할 일은 getFormat(5, 1) API를 호출하는 것 뿐입니다. 모든 핵심 API 호출은 임의의 인덱스와 길이로 액세스하거나 수정할 수 있습니다. 그리고 해당 이벤트 API는 직관적인 JSON 형식으로 변경 사항을 보고하며 HTML 구문 분석이나 DOM 트리 비교가 필요하지 않습니다.\n\n그러므로 Quill은 나만의 리치 텍스트 에디터 솔루션을 설계할 때 더 많은 옵션과 자유를 제공하며 더 간단한 해결책으로 이어줍니다!\n\n<div class=\"content-ad\"></div>\n\n그거 오늘은 여기까지야!\n\n리치 텍스트 편집기를 만들어서 부자가 되어보자(아마?)!","ogImage":{"url":"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png"},"coverImage":"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png","tag":["Tech"],"readingTime":10}],"page":"43","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}