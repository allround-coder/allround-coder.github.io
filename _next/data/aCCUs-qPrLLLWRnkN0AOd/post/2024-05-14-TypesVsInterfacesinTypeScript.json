{"pageProps":{"post":{"title":"타입 vs 인터페이스 TypeScript에서","description":"","date":"2024-05-14 15:27","slug":"2024-05-14-TypesVsInterfacesinTypeScript","content":"\n\n\n![TypesVsInterfacesinTypeScript](/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png)\n\nTypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.\n\n오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.\n\n더 이상 미루지 말고 바로 들어가 봅시다.\n\n\n\n\n차이가 무엇인가요?\n\n이 동물 유형 및 인터페이스 정의를 분석해 봅시다:\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\n\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n```\n\n구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.\n\n\n\n이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.\n\n# 확장성\n\n확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.\n\n```js\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n\ninterface Dog extends Animal {\n  breed: string\n}\n\nconst dog: Dog = {\n  species: '포유동물',\n  name: '브루노',\n  breed: '저먼 셰퍼드',\n  age: 5\n}\n```\n\n\n\n개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.\n\n타입은 두 개의 타입을 병합하는 데 Union(`|`) 및 Intersection(`&`) 연산자를 사용하여 속성을 확장할 수도 있습니다.\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\ntype Dog = {\n  breed: string\n} & Animal\n\n// ❌ 작동하지 않음\ninterface Dog {\n  breed \n} & Animal\n```\n\n# 성능\n\n\n\n성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.\n\n이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.\n\nMatt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.\n\n# 인터페이스가 해로울 수 있는 이유\n\n\n\nTypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.\n\n선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.\n\n```js\n// 초기 Dog 인터페이스\ninterface Dog {\n  species: string\n  name: string\n  age: number\n}\n// \"선언 병합\"을 이용해 Dog 인터페이스 보강\ninterface Dog {\n  breed: string\n}\n\n// \"병합된\" 인터페이스로 새로운 \"개\"를 정의해봐\nconst dog: Dog = { name: \"Bruno\", age: 5, breed: \"German Shepherd\", species: \"Mamamal\" }\n```\n\n이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.\n\n그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.\n\n\n\n```js\n인터페이스 Cloner {\n  clone(animal: Animal): Animal;\n}\n인터페이스 Cloner {\n  clone(animal: Sheep): Sheep;\n}\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n\n// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:\n\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.\n\n## 클래스와의 안전하지 않은 병합\n\nTypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\n두 인터페이스의 병합 중에\n\n\n\n```js\n인터페이스 동물 {\n    a: 문자열;\n    b: 문자열;\n}\n\n인터페이스 개는 동물을 확장하며 {\n    c: 문자열;\n}\n\n클래스 개 {\n    constructor() {}\n}\n```\n\n위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.\n\n그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.\n\n```js\n클래스 개 {\n    a: 문자열;\n    b: 문자열;\n    c: 문자열;\n}\n```\n\n\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n| Types do not have this problem, and hence are more straightforward and safe to use as a result.                        |\n|--------------------------------------------------------------------------------------------------------------------------|\n| **Conclusion**                                                                                                          |\n| Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types. |\n| Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.                         |\n\n\n\n인터페이스와 성능 면에서도 타입들은 동일합니다.","ogImage":{"url":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png\" alt=\"TypesVsInterfacesinTypeScript\"></p>\n<p>TypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.</p>\n<p>오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.</p>\n<p>더 이상 미루지 말고 바로 들어가 봅시다.</p>\n<p>차이가 무엇인가요?</p>\n<p>이 동물 유형 및 인터페이스 정의를 분석해 봅시다:</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">Animal</span> = {\n  <span class=\"hljs-attr\">species</span>: string\n  <span class=\"hljs-attr\">name</span>: string\n  <span class=\"hljs-attr\">age</span>: number\n}\n\n\ninterface <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-attr\">species</span>: string\n  <span class=\"hljs-attr\">name</span>: string\n  <span class=\"hljs-attr\">age</span>: number\n}\n</code></pre>\n<p>구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.</p>\n<p>이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.</p>\n<h1>확장성</h1>\n<p>확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-attr\">species</span>: string\n  <span class=\"hljs-attr\">name</span>: string\n  <span class=\"hljs-attr\">age</span>: number\n}\n\ninterface <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-attr\">breed</span>: string\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">dog</span>: <span class=\"hljs-title class_\">Dog</span> = {\n  <span class=\"hljs-attr\">species</span>: <span class=\"hljs-string\">'포유동물'</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'브루노'</span>,\n  <span class=\"hljs-attr\">breed</span>: <span class=\"hljs-string\">'저먼 셰퍼드'</span>,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">5</span>\n}\n</code></pre>\n<p>개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.</p>\n<p>타입은 두 개의 타입을 병합하는 데 Union(<code>|</code>) 및 Intersection(<code>&#x26;</code>) 연산자를 사용하여 속성을 확장할 수도 있습니다.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">Animal</span> = {\n  <span class=\"hljs-attr\">species</span>: string\n  <span class=\"hljs-attr\">name</span>: string\n  <span class=\"hljs-attr\">age</span>: number\n}\n\ntype <span class=\"hljs-title class_\">Dog</span> = {\n  <span class=\"hljs-attr\">breed</span>: string\n} &#x26; <span class=\"hljs-title class_\">Animal</span>\n\n<span class=\"hljs-comment\">// ❌ 작동하지 않음</span>\ninterface <span class=\"hljs-title class_\">Dog</span> {\n  breed \n} &#x26; <span class=\"hljs-title class_\">Animal</span>\n</code></pre>\n<h1>성능</h1>\n<p>성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.</p>\n<p>이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.</p>\n<p>Matt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.</p>\n<h1>인터페이스가 해로울 수 있는 이유</h1>\n<p>TypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.</p>\n<p>선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 초기 Dog 인터페이스</span>\ninterface <span class=\"hljs-title class_\">Dog</span> {\n  <span class=\"hljs-attr\">species</span>: string\n  <span class=\"hljs-attr\">name</span>: string\n  <span class=\"hljs-attr\">age</span>: number\n}\n<span class=\"hljs-comment\">// \"선언 병합\"을 이용해 Dog 인터페이스 보강</span>\ninterface <span class=\"hljs-title class_\">Dog</span> {\n  <span class=\"hljs-attr\">breed</span>: string\n}\n\n<span class=\"hljs-comment\">// \"병합된\" 인터페이스로 새로운 \"개\"를 정의해봐</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">dog</span>: <span class=\"hljs-title class_\">Dog</span> = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Bruno\"</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">breed</span>: <span class=\"hljs-string\">\"German Shepherd\"</span>, <span class=\"hljs-attr\">species</span>: <span class=\"hljs-string\">\"Mamamal\"</span> }\n</code></pre>\n<p>이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.</p>\n<p>그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.</p>\n<pre><code class=\"hljs language-js\">인터페이스 <span class=\"hljs-title class_\">Cloner</span> {\n  <span class=\"hljs-title function_\">clone</span>(<span class=\"hljs-attr\">animal</span>: <span class=\"hljs-title class_\">Animal</span>): <span class=\"hljs-title class_\">Animal</span>;\n}\n인터페이스 <span class=\"hljs-title class_\">Cloner</span> {\n  <span class=\"hljs-title function_\">clone</span>(<span class=\"hljs-attr\">animal</span>: <span class=\"hljs-title class_\">Sheep</span>): <span class=\"hljs-title class_\">Sheep</span>;\n}\n인터페이스 <span class=\"hljs-title class_\">Cloner</span> {\n  <span class=\"hljs-title function_\">clone</span>(<span class=\"hljs-attr\">animal</span>: <span class=\"hljs-title class_\">Dog</span>): <span class=\"hljs-title class_\">Dog</span>;\n  <span class=\"hljs-title function_\">clone</span>(<span class=\"hljs-attr\">animal</span>: <span class=\"hljs-title class_\">Cat</span>): <span class=\"hljs-title class_\">Cat</span>;\n}\n\n<span class=\"hljs-comment\">// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:</span>\n\n인터페이스 <span class=\"hljs-title class_\">Cloner</span> {\n  <span class=\"hljs-title function_\">clone</span>(<span class=\"hljs-attr\">animal</span>: <span class=\"hljs-title class_\">Dog</span>): <span class=\"hljs-title class_\">Dog</span>;\n  <span class=\"hljs-title function_\">clone</span>(<span class=\"hljs-attr\">animal</span>: <span class=\"hljs-title class_\">Cat</span>): <span class=\"hljs-title class_\">Cat</span>;\n  <span class=\"hljs-title function_\">clone</span>(<span class=\"hljs-attr\">animal</span>: <span class=\"hljs-title class_\">Sheep</span>): <span class=\"hljs-title class_\">Sheep</span>;\n  <span class=\"hljs-title function_\">clone</span>(<span class=\"hljs-attr\">animal</span>: <span class=\"hljs-title class_\">Animal</span>): <span class=\"hljs-title class_\">Animal</span>;\n}\n</code></pre>\n<p>각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.</p>\n<h2>클래스와의 안전하지 않은 병합</h2>\n<p>TypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\n두 인터페이스의 병합 중에</p>\n<pre><code class=\"hljs language-js\">인터페이스 동물 {\n    <span class=\"hljs-attr\">a</span>: 문자열;\n    <span class=\"hljs-attr\">b</span>: 문자열;\n}\n\n인터페이스 개는 동물을 확장하며 {\n    <span class=\"hljs-attr\">c</span>: 문자열;\n}\n\n클래스 개 {\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {}\n}\n</code></pre>\n<p>위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.</p>\n<p>그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.</p>\n<pre><code class=\"hljs language-js\">클래스 개 {\n    <span class=\"hljs-attr\">a</span>: 문자열;\n    <span class=\"hljs-attr\">b</span>: 문자열;\n    <span class=\"hljs-attr\">c</span>: 문자열;\n}\n</code></pre>\n<p>테이블 태그를 마크다운 형식으로 변경하십시오.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Types do not have this problem, and hence are more straightforward and safe to use as a result.</th></tr></thead><tbody><tr><td><strong>Conclusion</strong></td></tr><tr><td>Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types.</td></tr><tr><td>Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.</td></tr></tbody></table>\n<p>인터페이스와 성능 면에서도 타입들은 동일합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}