{"pageProps":{"post":{"title":"안드로이드 14 포어그라운드 서비스 가이드","description":"","date":"2024-07-01 20:13","slug":"2024-07-01-GuidetoForegroundServicesonAndroid14","content":"\n\n안녕하세요! 안드로이드 14에는 SDK 버전 34를 타겼다면 포그라운드 서비스와 관련된 중요 변경 사항이 포함되어 있습니다. 이 변경 사항을 적용하려면 어떤 작업을 해야 하는지 살펴보겠습니다.\n\n또한 나타날 수 있는 일반적인 예외 상황과 그들을 어떻게 해결할 수 있는지도 다룰 예정입니다.\n\n이 글의 끝에는 포그라운드 서비스를 올바르게 구현하는 방법을 보여주는 샘플 프로젝트도 찾아보실 수 있습니다.\n\n![Foreground Services on Android 14](/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png)\n\n<div class=\"content-ad\"></div>\n\n## 포그라운드 서비스란 무엇인가요?\n\n포그라운드 서비스는 사용자에게 표시되는 작업이나 작동을 수행하는 서비스로, 사용자가 앱과 직접 상호 작용하지 않을 때에도 실행을 계속할 수 있습니다. 이러한 서비스는 활성 상태임을 사용자에게 인식시키기 위해 시스템 알림을 표시해야 합니다.\n\n포그라운드 서비스를 사용하는 앱의 예시로는 아래와 같은 것들이 있습니다:\n\n- 사용자가 앱을 나갔을 때에도 음악을 재생하는 음악 플레이어 앱(예: Spotify),\n- 폰이 잠겨 있을 때에도 걸음 수를 추적하는 피트니스 앱(예: Google Fit),\n- 운전 방향을 제공하는 네비게이션 앱(예: Google Maps) 등이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 포그라운드 서비스 유형\n\nAndroid 10에서는 `service` 요소 내에 있는 android:foregroundServiceType 속성을 소개했습니다. 이 아이디어는 서비스가 하는 일의 종류를 명시적으로 지정하는 것입니다. 지금까지는 서비스가 위치, 카메라 또는 마이크 권한을 사용하는 경우에만 유형을 지정해야 했습니다.\n\nAndroid 14에서는 포그라운드 서비스 유형을 지정하는 것이 필수적으로 되었습니다. 이는 포그라운드 서비스의 올바른 사용과 기기 제조업체 간의 일관성을 보장하기 위한 조치입니다.\n\n현재 지원되는 유형은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 카메라 (Android 11에서 필수) — 비디오 통화 앱과 같이 백그라운드에서 카메라에 액세스할 때\n- connectedDevice — Bluetooth 피트니스 장치와 상호 작용할 때\n- dataSync — 데이터를 업로드하거나 다운로드할 때, Deprecated될 예정이며 DownloadManager, BackupManager, 또는 WorkManager와 같은 대안을 대신 사용해야 함\n- health (Android 14에서 새롭게 추가) — 운동 추적 앱과 같은 피트니스 앱용\n- 위치 (Android 10에서 필수) — 위치가 필요한 경우, 네비게이션과 같이\n- mediaPlayback — Spotify나 Netflix와 같은 앱과 같이 백그라운드에서 오디오 또는 비디오 재생을 계속할 때\n- mediaProjection — 외부 장치나 화면에 콘텐츠를 투영할 때\n- 마이크 (Android 11에서 필수) — 호출 앱과 같이 백그라운드에서 마이크에 액세스할 때\n- phoneCall — 계속 중인 통화를 할 때\n- remoteMessaging (Android 14에서 새롭게 추가) — 한 기기에서 다른 기기로 문자 메시지를 전송할 때\n- shortService — 중단할 수 없는 중요한 작업을 빠르게 완료해야 할 때, 약 3분 동안만 실행 가능\n- specialUse — 다른 유형이 사용 사례를 수용하지 못할 때\n- systemExempted — 시스템 앱을 위해 예약\n\n백그라운드 서비스 유형 선언\nAndroid 14를 지원하기 위한 첫 번째 단계는 AndroidManifest 파일에서 서비스 선언을 업데이트하고 올바른 포그라운드 서비스 유형을 지정하는 것입니다.\n\n서비스가 여러 유형을 필요로 하는 경우 다음과 같이 | 연산자를 사용하여 결합할 수 있습니다:\n\n```js\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <service\n        android:name=\".MyForegroundService\"\n        android:foregroundServiceType=\"camera|location|microphone\"\n        android:exported=\"false\">\n    </service>\n</manifest>\n```\n\n<div class=\"content-ad\"></div>\n\n만약 매니페스트에서 해당 서비스의 유형을 선언하지 않고 foreground service를 시작하려고 하면 startForeground()를 호출할 때 시스템에서 MissingForegroundServiceTypeException을 throw할 것입니다.\n\n## 특정 foreground service 권한 요청\n\nAndroid 9 (API 28)부터 앱은 앱 매니페스트에서 FOREGROUND_SERVICE 권한을 요청해야 했으며, 이는 시스템에서 자동으로 부여되었습니다.\n\n```js\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/>\n```\n\n<div class=\"content-ad\"></div>\n\nAndroid 14(API 34)부터 앱은 전경 서비스의 유형에 따라 추가 권한을 요청해야 합니다. 따라서, 서비스가 외부 블루투스 장치에 연결되면 FOREGROUND_SERVICE_CONNECTED_DEVICE를 지정해야 합니다. 시스템에서 권한이 자동으로 부여됩니다.\n\n```js\n<uses-permission android:name=\"android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE\"/>\n```\n\n만약 서비스가 여러 유형이 필요하다면, 각 유형마다 해당 권한을 선언해야 합니다.\n\n두 권한 중 하나라도 선언을 잊어버리면, 정확한 이유를 설명하는 SecurityException을 받게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\njava.lang.SecurityException: \n     Permission Denial: startForeground from pid=8589, uid=10623 \n     requires android.permission.FOREGROUND_SERVICE\n\nor\n\njava.lang.SecurityException: \n     Starting FGS with type mediaPlayback targetSDK=34 \n     requires permissions: \n        all of the permissions allOf=true \n        [android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK]\n```\n\n## startForeground() 함수에서 서비스 유형 지정\n\nmanifest에서 foreground service 유형을 선언하는 것 외에도 startForeground() 함수를 호출할 때 이를 명시해야 합니다.\n\n서비스를 foreground에서 실행하려면 서비스 내에서 ServiceCompat.startForeground()를 호출해야 합니다. 보통 onStartCommand()에서 호출됩니다. 이 함수는 서비스, 알림의 ID, 알림 객체, 그리고 서비스가 수행하는 작업을 나타내는 foreground service 유형을 인자로 받습니다.\n\n<div class=\"content-ad\"></div>\n\n안드로이드 이전 버전에서는 foregroundServiceType 인수에 0을 전달하기만 하면 됐었지만, 이제는 매니페스트에 선언된 올바른 타입 또는 타입의 하위 집합을 전달해야 합니다. 사용 사례에 따라 추가된 타입으로 startForeground()를 여러 번 호출하는 것이 가능합니다.\n\n```js\nServiceCompat.startForeground(\n    this,\n    id,\n    notification,\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {\n        ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK\n    } else {\n        0\n    }\n)\n```\n\nforegroundServiceType에 0을 전달하여 startForeground()를 시도하면 예외가 발생합니다:\n\n```js\nandroid.app.InvalidForegroundServiceTypeException: \n  Starting FGS with type none \n  targetSDK=34 has been prohibited\n```\n\n<div class=\"content-ad\"></div>\n\n만약 매니페스트에 선언하지 않은 타입을 전달하면, 이와 유사한 예외를 받게 됩니다:\n\n```js\njava.lang.IllegalArgumentException: \n  foregroundServiceType 0x00000002 is not a subset of \n  foregroundServiceType attribute 0x00000000 in service \n  element of manifest file\n```\n\n```js\nandroid.app.ForegroundServiceDidNotStartInTimeException: \n  Context.startForegroundService() did not then call Service.startForeground()\n```\n\n## 런타임 권한 요청하기\n\n<div class=\"content-ad\"></div>\n\n각 전경 서비스 유형에는 필요한 권한 목록이 있습니다. 전경 서비스를 시작하기 전에 필요한 런타임 권한을 요청하고 승인받아야 합니다. 권한이 승인되지 않은 상태에서 서비스를 시작하려고 하면 해당 서비스에서 예외가 발생합니다.\n\n예를 들어, 앱이 백그라운드에 있을 때도 카메라를 사용해야 하는 서비스라면 android.permission.CAMERA 권한을 요청해야 합니다.\n\n그리고 서비스가 Bluetooth 장치에 연결해야 한다면 다음 중 하나 이상의 조건이 성립해야 합니다.\n\n- 매니페스트에 다음 중 하나 이상의 권한을 선언:\n- CHANGE_NETWORK_STATE\n- CHANGE_WIFI_STATE\n- CHANGE_WIFI_MULTICAST_STATE\n- NFC\n- TRANSMIT_IR\n- 다음 중 하나 이상의 런타임 권한을 요청하고 승인받아야 합니다:\n- BLUETOOTH_CONNECT\n- BLUETOOTH_ADVERTICE\n- BLUETOOTH_SCAN\n- UWB_RANGING\n- UsbManager.requestPermission() 호출하기\n\n<div class=\"content-ad\"></div>\n\n만약 서비스 시작 전 조건을 충족하지 않을 경우, 해당 조건이 충족되지 않았다는 정보를 포함한 예외가 발생합니다. 아래 예시에서는 앱이 필요한 권한을 부여받지 못한 상태입니다.\n\n```js\nStarting FGS with type connectedDevice targetSDK=34 requires permissions: \n- all of the permissions allOf=true \n  - [android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE] \n- any of the permissions allOf=false \n  - [android.permission.BLUETOOTH_ADVERTISE, \n     android.permission.BLUETOOTH_CONNECT, \n     android.permission.BLUETOOTH_SCAN, \n     android.permission.CHANGE_NETWORK_STATE, \n     android.permission.CHANGE_WIFI_STATE, \n     android.permission.CHANGE_WIFI_MULTICAST_STATE, \n     android.permission.NFC, \n     android.permission.TRANSMIT_IR, \n     android.permission.UWB_RANGING, \n     USB Device, \n     USB Accessory]\n```\n\n## 알림이 올바르게 설정되어 있는지 확인해주세요\n\n백그라운드 서비스를 시작할 때, 서비스 실행 기간 동안 사용자에게 보여질 알림을 제공해야 합니다. Android 13에서는 알림을 게시하는 런타임 권한이 도입되었는데, 이에 따라 앱이 이 권한을 요청하고 사용자가 명시적으로 부여해야만 알림이 표시됩니다. 그렇지 않으면 알림이 보이지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n- POST_NOTIFICATIONS 권한을 요청하고 사용자가 수락하면 알림이 정상적으로 표시됩니다.\n\n![이미지](/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_1.png)\n\n- 권한을 요청하고 사용자가 거부하면 알림이 표시되지 않지만 서비스는 의도한 대로 작동합니다. 사용자들은 작업 관리자에서 백그라운드 작업을 수행하는 앱임을 확인할 수 있습니다.\n- 알림 권한을 요청하지 않고도 알림을 게시하려고 하면, 앞의 내용과 동일하게 앱이 작동합니다.\n\n![이미지](/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_2.png)\n\n<div class=\"content-ad\"></div>\n\n## Google Play 콘솔의 사용 사례에 대한 세부 정보 제공\n\nGoogle Play 콘솔에 새 버전의 앱을 업로드하고 Android 14를 대상으로 하며 foreground service 유형을 사용하는 경우, 콘솔에서 사용법에 대한 추가 세부 정보를 제공하라는 메시지가 표시됩니다.\n\nGoogle은 앱이 foreground 서비스를 적절하게 사용하고 있는지 확인하기 위해, App content 페이지 (정책 - 앱 콘텐츠)에서 새로운 선언을 제출해야 합니다.\n\n선언한 각 foreground 서비스 유형에 대해 다음을 수행해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n- 어떤 전경 서비스 유형을 사용하는 앱의 기능을 설명합니다.\n- 시스템에 의해 작업이 지연되거나 중단될 경우 사용자에게 미치는 영향을 설명합니다.\n- 각 전경 서비스 기능을 보여주는 비디오 링크를 포함합니다. 비디오에서는 사용자가 앱에서 기능을 트리거하기 위해 취해야 하는 단계를 보여주어야 합니다.\n- 각 전경 서비스 유형에 대한 구체적인 사용 사례를 선택하십시오. 여기에 나열된 사전 설정된 사용 사례 중 하나를 선택하거나 수동으로 입력할 수 있습니다.\n\n## 삼성 기기를 위한 개선 사항\n\n삼성은 안드로이드 14 이상을 실행하는 갤럭시 기기에서 전경 서비스가 의도대로 작동하도록 한 통합 정책에 관해 Google와 협력했습니다. 이는 삼성이 34%¹의 시장 점유율을 가지고 있고, 이전에는 전경 서비스가 경우에 따라 Pixels와 같은 기기와 비교했을 때 다르게 작동했기 때문에 통합된 안드로이드 플랫폼으로 나아가는 중요한 한 걸음입니다.\n\n<div class=\"content-ad\"></div>\n\n여기 인용문이 있습니다:\n\n# 샘플 앱\n\n안드로이드 14에서 포그라운드 서비스를 만들고 시작하는 방법을 보여주는 간단한 샘플 앱을 준비했습니다. 다음 기능이 포함되어 있습니다:\n\n- 위치를 포그라운드 서비스 형태로 선언하여 포그라운드 서비스 시작\n- 서비스 시작 전에 위치 권한 요청\n- Activity에서 포그라운드 서비스에 바인딩하여 서비스 상태를 표시하고 위치 업데이트 수신\n- 액티비티에서 서비스 중지\n- 포그라운드 서비스 알림을 표시하기 위해 알림 권한 요청\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n안드로이드 14에서는 전경 서비스와 관련된 여러 가지 변경 사항이 있어, 앱이 API 34를 대상으로 설정되도록 만들기 위해 개발자들이 추가 작업을 해야 합니다. 가장 큰 변경 사항은 전경 서비스 유형이 이제 필수 요소가 되었는데, 이는 서비스를 시작하기 전에 모든 요구 사항을 충족해야 한다는 것을 의미합니다.\n\n새로운 변경 사항은 전경 서비스에 대해 더 표준화된 접근 방식을 의미하며 다양한 제조업체로부터 더 나은 지원을 기대할 수 있습니다.\n\n이 안내서가 유용했기를 바라며, 샘플 앱을 검토하고 아래 링크된 추가 자료를 확인하여 더 많은 정보를 얻기를 권장합니다.\n\n<div class=\"content-ad\"></div>\n\n자원:\n\n- https://developer.android.com/develop/background-work/services/foreground-services — foreground 서비스에 대한 공식 문서\n- https://developer.android.com/about/versions/14/changes/fgs-types-required — 모든 foreground 서비스 유형에 대한 요구 사항을 자세히 설명합니다.\n- https://www.droidcon.com/2023/11/15/a-guide-to-using-foreground-services-and-background-work-in-android-14/ — 앨리스 유안(Alice Yuan)이 Droidcon London 23에서 진행한 훌륭한 강연. 안드로이드에서 백그라운드 작업을 위한 Google의 공식 가이드라인과 모범 사례를 다룹니다.\n\n참고 자료:\n\n- [1] https://www.demandsage.com/android-statistics/\n- [2] https://android-developers.googleblog.com/2023/05/improving-consistency-of-background-work-on-android.html","ogImage":{"url":"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png"},"coverImage":"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>안녕하세요! 안드로이드 14에는 SDK 버전 34를 타겼다면 포그라운드 서비스와 관련된 중요 변경 사항이 포함되어 있습니다. 이 변경 사항을 적용하려면 어떤 작업을 해야 하는지 살펴보겠습니다.</p>\n<p>또한 나타날 수 있는 일반적인 예외 상황과 그들을 어떻게 해결할 수 있는지도 다룰 예정입니다.</p>\n<p>이 글의 끝에는 포그라운드 서비스를 올바르게 구현하는 방법을 보여주는 샘플 프로젝트도 찾아보실 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png\" alt=\"Foreground Services on Android 14\"></p>\n<div class=\"content-ad\"></div>\n<h2>포그라운드 서비스란 무엇인가요?</h2>\n<p>포그라운드 서비스는 사용자에게 표시되는 작업이나 작동을 수행하는 서비스로, 사용자가 앱과 직접 상호 작용하지 않을 때에도 실행을 계속할 수 있습니다. 이러한 서비스는 활성 상태임을 사용자에게 인식시키기 위해 시스템 알림을 표시해야 합니다.</p>\n<p>포그라운드 서비스를 사용하는 앱의 예시로는 아래와 같은 것들이 있습니다:</p>\n<ul>\n<li>사용자가 앱을 나갔을 때에도 음악을 재생하는 음악 플레이어 앱(예: Spotify),</li>\n<li>폰이 잠겨 있을 때에도 걸음 수를 추적하는 피트니스 앱(예: Google Fit),</li>\n<li>운전 방향을 제공하는 네비게이션 앱(예: Google Maps) 등이 있습니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<h2>포그라운드 서비스 유형</h2>\n<p>Android 10에서는 <code>service</code> 요소 내에 있는 android:foregroundServiceType 속성을 소개했습니다. 이 아이디어는 서비스가 하는 일의 종류를 명시적으로 지정하는 것입니다. 지금까지는 서비스가 위치, 카메라 또는 마이크 권한을 사용하는 경우에만 유형을 지정해야 했습니다.</p>\n<p>Android 14에서는 포그라운드 서비스 유형을 지정하는 것이 필수적으로 되었습니다. 이는 포그라운드 서비스의 올바른 사용과 기기 제조업체 간의 일관성을 보장하기 위한 조치입니다.</p>\n<p>현재 지원되는 유형은 다음과 같습니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>카메라 (Android 11에서 필수) — 비디오 통화 앱과 같이 백그라운드에서 카메라에 액세스할 때</li>\n<li>connectedDevice — Bluetooth 피트니스 장치와 상호 작용할 때</li>\n<li>dataSync — 데이터를 업로드하거나 다운로드할 때, Deprecated될 예정이며 DownloadManager, BackupManager, 또는 WorkManager와 같은 대안을 대신 사용해야 함</li>\n<li>health (Android 14에서 새롭게 추가) — 운동 추적 앱과 같은 피트니스 앱용</li>\n<li>위치 (Android 10에서 필수) — 위치가 필요한 경우, 네비게이션과 같이</li>\n<li>mediaPlayback — Spotify나 Netflix와 같은 앱과 같이 백그라운드에서 오디오 또는 비디오 재생을 계속할 때</li>\n<li>mediaProjection — 외부 장치나 화면에 콘텐츠를 투영할 때</li>\n<li>마이크 (Android 11에서 필수) — 호출 앱과 같이 백그라운드에서 마이크에 액세스할 때</li>\n<li>phoneCall — 계속 중인 통화를 할 때</li>\n<li>remoteMessaging (Android 14에서 새롭게 추가) — 한 기기에서 다른 기기로 문자 메시지를 전송할 때</li>\n<li>shortService — 중단할 수 없는 중요한 작업을 빠르게 완료해야 할 때, 약 3분 동안만 실행 가능</li>\n<li>specialUse — 다른 유형이 사용 사례를 수용하지 못할 때</li>\n<li>systemExempted — 시스템 앱을 위해 예약</li>\n</ul>\n<p>백그라운드 서비스 유형 선언\nAndroid 14를 지원하기 위한 첫 번째 단계는 AndroidManifest 파일에서 서비스 선언을 업데이트하고 올바른 포그라운드 서비스 유형을 지정하는 것입니다.</p>\n<p>서비스가 여러 유형을 필요로 하는 경우 다음과 같이 | 연산자를 사용하여 결합할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">&#x3C;manifest <span class=\"hljs-attr\">xmlns</span>:android=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span> ...>\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">service</span>\n        <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">\".MyForegroundService\"</span>\n        <span class=\"hljs-attr\">android:foregroundServiceType</span>=<span class=\"hljs-string\">\"camera|location|microphone\"</span>\n        <span class=\"hljs-attr\">android:exported</span>=<span class=\"hljs-string\">\"false\"</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">service</span>></span></span>\n&#x3C;/manifest>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>만약 매니페스트에서 해당 서비스의 유형을 선언하지 않고 foreground service를 시작하려고 하면 startForeground()를 호출할 때 시스템에서 MissingForegroundServiceTypeException을 throw할 것입니다.</p>\n<h2>특정 foreground service 권한 요청</h2>\n<p>Android 9 (API 28)부터 앱은 앱 매니페스트에서 FOREGROUND_SERVICE 권한을 요청해야 했으며, 이는 시스템에서 자동으로 부여되었습니다.</p>\n<pre><code class=\"hljs language-js\">&#x3C;uses-permission <span class=\"hljs-attr\">android</span>:name=<span class=\"hljs-string\">\"android.permission.FOREGROUND_SERVICE\"</span>/>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>Android 14(API 34)부터 앱은 전경 서비스의 유형에 따라 추가 권한을 요청해야 합니다. 따라서, 서비스가 외부 블루투스 장치에 연결되면 FOREGROUND_SERVICE_CONNECTED_DEVICE를 지정해야 합니다. 시스템에서 권한이 자동으로 부여됩니다.</p>\n<pre><code class=\"hljs language-js\">&#x3C;uses-permission <span class=\"hljs-attr\">android</span>:name=<span class=\"hljs-string\">\"android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE\"</span>/>\n</code></pre>\n<p>만약 서비스가 여러 유형이 필요하다면, 각 유형마다 해당 권한을 선언해야 합니다.</p>\n<p>두 권한 중 하나라도 선언을 잊어버리면, 정확한 이유를 설명하는 SecurityException을 받게 됩니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">java.<span class=\"hljs-property\">lang</span>.<span class=\"hljs-property\">SecurityException</span>: \n     <span class=\"hljs-title class_\">Permission</span> <span class=\"hljs-title class_\">Denial</span>: startForeground <span class=\"hljs-keyword\">from</span> pid=<span class=\"hljs-number\">8589</span>, uid=<span class=\"hljs-number\">10623</span> \n     requires android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">FOREGROUND_SERVICE</span>\n\nor\n\njava.<span class=\"hljs-property\">lang</span>.<span class=\"hljs-property\">SecurityException</span>: \n     <span class=\"hljs-title class_\">Starting</span> <span class=\"hljs-variable constant_\">FGS</span> <span class=\"hljs-keyword\">with</span> type mediaPlayback targetSDK=<span class=\"hljs-number\">34</span> \n     requires <span class=\"hljs-attr\">permissions</span>: \n        all <span class=\"hljs-keyword\">of</span> the permissions allOf=<span class=\"hljs-literal\">true</span> \n        [android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">FOREGROUND_SERVICE_MEDIA_PLAYBACK</span>]\n</code></pre>\n<h2>startForeground() 함수에서 서비스 유형 지정</h2>\n<p>manifest에서 foreground service 유형을 선언하는 것 외에도 startForeground() 함수를 호출할 때 이를 명시해야 합니다.</p>\n<p>서비스를 foreground에서 실행하려면 서비스 내에서 ServiceCompat.startForeground()를 호출해야 합니다. 보통 onStartCommand()에서 호출됩니다. 이 함수는 서비스, 알림의 ID, 알림 객체, 그리고 서비스가 수행하는 작업을 나타내는 foreground service 유형을 인자로 받습니다.</p>\n<div class=\"content-ad\"></div>\n<p>안드로이드 이전 버전에서는 foregroundServiceType 인수에 0을 전달하기만 하면 됐었지만, 이제는 매니페스트에 선언된 올바른 타입 또는 타입의 하위 집합을 전달해야 합니다. 사용 사례에 따라 추가된 타입으로 startForeground()를 여러 번 호출하는 것이 가능합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">ServiceCompat</span>.<span class=\"hljs-title function_\">startForeground</span>(\n    <span class=\"hljs-variable language_\">this</span>,\n    id,\n    notification,\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Build</span>.<span class=\"hljs-property\">VERSION</span>.<span class=\"hljs-property\">SDK_INT</span> >= <span class=\"hljs-title class_\">Build</span>.<span class=\"hljs-property\">VERSION_CODES</span>.<span class=\"hljs-property\">R</span>) {\n        <span class=\"hljs-title class_\">ServiceInfo</span>.<span class=\"hljs-property\">FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-number\">0</span>\n    }\n)\n</code></pre>\n<p>foregroundServiceType에 0을 전달하여 startForeground()를 시도하면 예외가 발생합니다:</p>\n<pre><code class=\"hljs language-js\">android.<span class=\"hljs-property\">app</span>.<span class=\"hljs-property\">InvalidForegroundServiceTypeException</span>: \n  <span class=\"hljs-title class_\">Starting</span> <span class=\"hljs-variable constant_\">FGS</span> <span class=\"hljs-keyword\">with</span> type none \n  targetSDK=<span class=\"hljs-number\">34</span> has been prohibited\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>만약 매니페스트에 선언하지 않은 타입을 전달하면, 이와 유사한 예외를 받게 됩니다:</p>\n<pre><code class=\"hljs language-js\">java.<span class=\"hljs-property\">lang</span>.<span class=\"hljs-property\">IllegalArgumentException</span>: \n  foregroundServiceType <span class=\"hljs-number\">0x00000002</span> is not a subset <span class=\"hljs-keyword\">of</span> \n  foregroundServiceType attribute <span class=\"hljs-number\">0x00000000</span> <span class=\"hljs-keyword\">in</span> service \n  element <span class=\"hljs-keyword\">of</span> manifest file\n</code></pre>\n<pre><code class=\"hljs language-js\">android.<span class=\"hljs-property\">app</span>.<span class=\"hljs-property\">ForegroundServiceDidNotStartInTimeException</span>: \n  <span class=\"hljs-title class_\">Context</span>.<span class=\"hljs-title function_\">startForegroundService</span>() did not then call <span class=\"hljs-title class_\">Service</span>.<span class=\"hljs-title function_\">startForeground</span>()\n</code></pre>\n<h2>런타임 권한 요청하기</h2>\n<div class=\"content-ad\"></div>\n<p>각 전경 서비스 유형에는 필요한 권한 목록이 있습니다. 전경 서비스를 시작하기 전에 필요한 런타임 권한을 요청하고 승인받아야 합니다. 권한이 승인되지 않은 상태에서 서비스를 시작하려고 하면 해당 서비스에서 예외가 발생합니다.</p>\n<p>예를 들어, 앱이 백그라운드에 있을 때도 카메라를 사용해야 하는 서비스라면 android.permission.CAMERA 권한을 요청해야 합니다.</p>\n<p>그리고 서비스가 Bluetooth 장치에 연결해야 한다면 다음 중 하나 이상의 조건이 성립해야 합니다.</p>\n<ul>\n<li>매니페스트에 다음 중 하나 이상의 권한을 선언:</li>\n<li>CHANGE_NETWORK_STATE</li>\n<li>CHANGE_WIFI_STATE</li>\n<li>CHANGE_WIFI_MULTICAST_STATE</li>\n<li>NFC</li>\n<li>TRANSMIT_IR</li>\n<li>다음 중 하나 이상의 런타임 권한을 요청하고 승인받아야 합니다:</li>\n<li>BLUETOOTH_CONNECT</li>\n<li>BLUETOOTH_ADVERTICE</li>\n<li>BLUETOOTH_SCAN</li>\n<li>UWB_RANGING</li>\n<li>UsbManager.requestPermission() 호출하기</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>만약 서비스 시작 전 조건을 충족하지 않을 경우, 해당 조건이 충족되지 않았다는 정보를 포함한 예외가 발생합니다. 아래 예시에서는 앱이 필요한 권한을 부여받지 못한 상태입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Starting</span> <span class=\"hljs-variable constant_\">FGS</span> <span class=\"hljs-keyword\">with</span> type connectedDevice targetSDK=<span class=\"hljs-number\">34</span> requires <span class=\"hljs-attr\">permissions</span>: \n- all <span class=\"hljs-keyword\">of</span> the permissions allOf=<span class=\"hljs-literal\">true</span> \n  - [android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">FOREGROUND_SERVICE_CONNECTED_DEVICE</span>] \n- any <span class=\"hljs-keyword\">of</span> the permissions allOf=<span class=\"hljs-literal\">false</span> \n  - [android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">BLUETOOTH_ADVERTISE</span>, \n     android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">BLUETOOTH_CONNECT</span>, \n     android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">BLUETOOTH_SCAN</span>, \n     android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">CHANGE_NETWORK_STATE</span>, \n     android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">CHANGE_WIFI_STATE</span>, \n     android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">CHANGE_WIFI_MULTICAST_STATE</span>, \n     android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">NFC</span>, \n     android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">TRANSMIT_IR</span>, \n     android.<span class=\"hljs-property\">permission</span>.<span class=\"hljs-property\">UWB_RANGING</span>, \n     <span class=\"hljs-variable constant_\">USB</span> <span class=\"hljs-title class_\">Device</span>, \n     <span class=\"hljs-variable constant_\">USB</span> <span class=\"hljs-title class_\">Accessory</span>]\n</code></pre>\n<h2>알림이 올바르게 설정되어 있는지 확인해주세요</h2>\n<p>백그라운드 서비스를 시작할 때, 서비스 실행 기간 동안 사용자에게 보여질 알림을 제공해야 합니다. Android 13에서는 알림을 게시하는 런타임 권한이 도입되었는데, 이에 따라 앱이 이 권한을 요청하고 사용자가 명시적으로 부여해야만 알림이 표시됩니다. 그렇지 않으면 알림이 보이지 않습니다.</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>POST_NOTIFICATIONS 권한을 요청하고 사용자가 수락하면 알림이 정상적으로 표시됩니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_1.png\" alt=\"이미지\"></p>\n<ul>\n<li>권한을 요청하고 사용자가 거부하면 알림이 표시되지 않지만 서비스는 의도한 대로 작동합니다. 사용자들은 작업 관리자에서 백그라운드 작업을 수행하는 앱임을 확인할 수 있습니다.</li>\n<li>알림 권한을 요청하지 않고도 알림을 게시하려고 하면, 앞의 내용과 동일하게 앱이 작동합니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_2.png\" alt=\"이미지\"></p>\n<div class=\"content-ad\"></div>\n<h2>Google Play 콘솔의 사용 사례에 대한 세부 정보 제공</h2>\n<p>Google Play 콘솔에 새 버전의 앱을 업로드하고 Android 14를 대상으로 하며 foreground service 유형을 사용하는 경우, 콘솔에서 사용법에 대한 추가 세부 정보를 제공하라는 메시지가 표시됩니다.</p>\n<p>Google은 앱이 foreground 서비스를 적절하게 사용하고 있는지 확인하기 위해, App content 페이지 (정책 - 앱 콘텐츠)에서 새로운 선언을 제출해야 합니다.</p>\n<p>선언한 각 foreground 서비스 유형에 대해 다음을 수행해야 합니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>어떤 전경 서비스 유형을 사용하는 앱의 기능을 설명합니다.</li>\n<li>시스템에 의해 작업이 지연되거나 중단될 경우 사용자에게 미치는 영향을 설명합니다.</li>\n<li>각 전경 서비스 기능을 보여주는 비디오 링크를 포함합니다. 비디오에서는 사용자가 앱에서 기능을 트리거하기 위해 취해야 하는 단계를 보여주어야 합니다.</li>\n<li>각 전경 서비스 유형에 대한 구체적인 사용 사례를 선택하십시오. 여기에 나열된 사전 설정된 사용 사례 중 하나를 선택하거나 수동으로 입력할 수 있습니다.</li>\n</ul>\n<h2>삼성 기기를 위한 개선 사항</h2>\n<p>삼성은 안드로이드 14 이상을 실행하는 갤럭시 기기에서 전경 서비스가 의도대로 작동하도록 한 통합 정책에 관해 Google와 협력했습니다. 이는 삼성이 34%¹의 시장 점유율을 가지고 있고, 이전에는 전경 서비스가 경우에 따라 Pixels와 같은 기기와 비교했을 때 다르게 작동했기 때문에 통합된 안드로이드 플랫폼으로 나아가는 중요한 한 걸음입니다.</p>\n<div class=\"content-ad\"></div>\n<p>여기 인용문이 있습니다:</p>\n<h1>샘플 앱</h1>\n<p>안드로이드 14에서 포그라운드 서비스를 만들고 시작하는 방법을 보여주는 간단한 샘플 앱을 준비했습니다. 다음 기능이 포함되어 있습니다:</p>\n<ul>\n<li>위치를 포그라운드 서비스 형태로 선언하여 포그라운드 서비스 시작</li>\n<li>서비스 시작 전에 위치 권한 요청</li>\n<li>Activity에서 포그라운드 서비스에 바인딩하여 서비스 상태를 표시하고 위치 업데이트 수신</li>\n<li>액티비티에서 서비스 중지</li>\n<li>포그라운드 서비스 알림을 표시하기 위해 알림 권한 요청</li>\n</ul>\n<div class=\"content-ad\"></div>\n<h1>결론</h1>\n<p>안드로이드 14에서는 전경 서비스와 관련된 여러 가지 변경 사항이 있어, 앱이 API 34를 대상으로 설정되도록 만들기 위해 개발자들이 추가 작업을 해야 합니다. 가장 큰 변경 사항은 전경 서비스 유형이 이제 필수 요소가 되었는데, 이는 서비스를 시작하기 전에 모든 요구 사항을 충족해야 한다는 것을 의미합니다.</p>\n<p>새로운 변경 사항은 전경 서비스에 대해 더 표준화된 접근 방식을 의미하며 다양한 제조업체로부터 더 나은 지원을 기대할 수 있습니다.</p>\n<p>이 안내서가 유용했기를 바라며, 샘플 앱을 검토하고 아래 링크된 추가 자료를 확인하여 더 많은 정보를 얻기를 권장합니다.</p>\n<div class=\"content-ad\"></div>\n<p>자원:</p>\n<ul>\n<li><a href=\"https://developer.android.com/develop/background-work/services/foreground-services\" rel=\"nofollow\" target=\"_blank\">https://developer.android.com/develop/background-work/services/foreground-services</a> — foreground 서비스에 대한 공식 문서</li>\n<li><a href=\"https://developer.android.com/about/versions/14/changes/fgs-types-required\" rel=\"nofollow\" target=\"_blank\">https://developer.android.com/about/versions/14/changes/fgs-types-required</a> — 모든 foreground 서비스 유형에 대한 요구 사항을 자세히 설명합니다.</li>\n<li><a href=\"https://www.droidcon.com/2023/11/15/a-guide-to-using-foreground-services-and-background-work-in-android-14/\" rel=\"nofollow\" target=\"_blank\">https://www.droidcon.com/2023/11/15/a-guide-to-using-foreground-services-and-background-work-in-android-14/</a> — 앨리스 유안(Alice Yuan)이 Droidcon London 23에서 진행한 훌륭한 강연. 안드로이드에서 백그라운드 작업을 위한 Google의 공식 가이드라인과 모범 사례를 다룹니다.</li>\n</ul>\n<p>참고 자료:</p>\n<ul>\n<li>[1] <a href=\"https://www.demandsage.com/android-statistics/\" rel=\"nofollow\" target=\"_blank\">https://www.demandsage.com/android-statistics/</a></li>\n<li>[2] <a href=\"https://android-developers.googleblog.com/2023/05/improving-consistency-of-background-work-on-android.html\" rel=\"nofollow\" target=\"_blank\">https://android-developers.googleblog.com/2023/05/improving-consistency-of-background-work-on-android.html</a></li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}