{"pageProps":{"post":{"title":"NestJS에서 IoC 컨테이너에 접근하기 실용적인 로깅 라이브러리 예제","description":"","date":"2024-06-20 04:34","slug":"2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample","content":"\n\n![2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png](/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png)\n\n안녕하세요! 이 세부적인 자습서에서는 NestJS 프로젝트를 만들고 특정 메타데이터가 지정된 모든 프로바이더 및 컨트롤러의 메서드 호출을 동적으로 탐지하고 기록하는 로깅 라이브러리를 구축할 것입니다. 이 예제는 IoC(Inversion of Control) 컨테이너에 액세스하고 등록된 프로바이더 및 컨트롤러를 조사하며 사용자 정의 데코레이터를 사용하여 동적 동작을 적용하는 방법을 이해하는 데 도움이 될 것입니다.\n\n# IoC 컨테이너란?\n\nNestJS의 IoC 컨테이너는 애플리케이션 구성 요소의 생성, 설정 및 라이프사이클을 관리하여 의존성 주입을 가능하게 합니다. 이는 컨테이너가 필요한 클래스에 자동으로 의존성을 제공하는 의존성 주입을 허용합니다.\n\n<div class=\"content-ad\"></div>\n\n# IoC 컨테이너에 접근하는 이유\n\nIoC 컨테이너에 접근하는 것은 다음과 같은 이유로 매우 중요합니다:\n\n- 살펴보기: 등록된 제공자(Providers) 및 컨트롤러(Controllers)를 모두 검사하기 위해.\n- 동적 동작: 로깅, 모니터링 또는 메타데이터를 기반으로 동작을 수정하는 등 동적 동작을 적용하기 위해.\n- 일반 라이브러리: 다양한 응용프로그램 구성 요소와 동적으로 상호작용해야 하는 라이브러리를 구축하기 위해.\n\n# 단계별 안내\n\n<div class=\"content-ad\"></div>\n\nNestJS 프로젝트를 만들고 동적 로깅 라이브러리를 빌드하는 단계를 함께 진행해 보겠습니다.\n\n## 단계 1: NestJS 프로젝트 설정하기\n\n- NestJS CLI를 설치합니다:\n\n```js\nnpm install -g @nestjs/cli\n```\n\n<div class=\"content-ad\"></div>\n\n2. 새로운 NestJS 프로젝트 만들기:\n\n```js\nnest new logging-library\ncd logging-library\n```\n\n3. 필수 종속성 설치:\n\n```js\nnpm install @nestjs/core @nestjs/common @nestjs-plus/discovery\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 2: LoggerService 생성하기\n\nNestJS 라이프사이클 훅을 사용하여 메서드 호출 로깅을 동적으로 설정하고 지우는 LoggerService를 생성합니다.\n\n- LoggerService 생성하기:\n\n```js\nnest generate service logger\n```\n\n<div class=\"content-ad\"></div>\n\n2. LoggerService를 구현하세요:\n\n```js\n// src/logger/logger.service.ts\nimport { Injectable, OnApplicationBootstrap, OnApplicationShutdown } from '@nestjs/common';\nimport { DiscoveryService, Reflector, MetadataScanner } from '@nestjs/core';\n\n@Injectable()\nexport class LoggerService implements OnApplicationBootstrap, OnApplicationShutdown {\n  // 원본 메소드를 저장하고 종료 시 복원하기 위한 Map\n  private readonly originals: Map<any, any> = new Map();\n\n  constructor(\n    // DiscoveryService는 모든 프로바이더와 컨트롤러를 찾기 위해 사용됩니다.\n    private readonly discoveryService: DiscoveryService,\n    // Reflector는 클래스와 메소드에서 메타데이터를 읽기 위해 사용됩니다.\n    private readonly reflector: Reflector,\n    // MetadataScanner는 클래스 프로토타입을 메소드 이름으로 스캔하기 위해 사용됩니다.\n    private readonly metadataScanner: MetadataScanner\n  ) {}\n\n  // 모든 모듈이 초기화된 후에 실행되는 라이프사이클 훅\n  onApplicationBootstrap() {\n    // 애플리케이션에서 모든 프로바이더(컨트롤러 포함)를 가져옵니다.\n    const providers = this.discoveryService.getProviders();\n    providers.forEach((wrapper) => {\n      // 프로바이더의 인스턴스(실제 객체) 가져오기\n      const { instance } = wrapper;\n      // 프로바이더의 프로토타입(모든 인스턴스에서 공유되는 메소드와 속성) 가져오기\n      const prototype = instance && Object.getPrototypeOf(instance);\n      // 인스턴스나 프로토타입이 없는 경우 건너뜁니다.\n      if (!instance || !prototype) {\n        return;\n      }\n      // 클래스가 @Loggable로 표시되어 있는지 확인합니다.\n      const isLoggable = this.reflector.get('LOGGABLE_KEY', instance.constructor) ?? false;\n      if (!isLoggable) {\n        return;\n      }\n      // 클래스 프로토타입에서 모든 메소드 이름 가져오기\n      const methodKeys = this.metadataScanner.getAllMethodNames(prototype);\n      methodKeys.forEach((methodKey) => {\n        // 이름으로 메소드 가져오기\n        const method = instance[methodKey];\n        // 함수(메소드)인지 확인합니다.\n        if (typeof method === 'function') {\n          // 원본 메소드 저장\n          this.originals.set(method, method.bind(instance));\n          // 원본 메소드를 로깅 래퍼로 대체합니다.\n          instance[methodKey] = (...args: any[]) => {\n            console.log(`Calling ${methodKey} with args:`, args);\n            return this.originals.get(method)(...args);\n          };\n        }\n      });\n    });\n  }\n\n  // 애플리케이션이 종료되기 전에 실행되는 라이프사이클 훅\n  onApplicationShutdown(signal?: string) {\n    // 모든 원본 메소드를 복원합니다.\n    this.originals.forEach((original, method) => {\n      method = original;\n    });\n    // 원본 메소드 Map을 비웁니다.\n    this.originals.clear();\n  }\n}\n```\n\n- Instance: IoC 컨테이너에서 생성된 실제 객체입니다. 이는 응용프로그램에서 상호작용하는 실시간 객체입니다.\n- Prototype: 객체의 청사진입니다. 클래스의 모든 인스턴스간에 공유되는 메소드와 속성이 포함되어 있습니다. 프로토타입을 사용하면 클래스 메소드의 동적 조회 및 수정이 가능합니다.\n\n# 로깅 메소드의 상세 설명\n\n<div class=\"content-ad\"></div>\n\n코드의 일부를 더 깊이 파헤쳐 보겠습니다. 여기서는 로깅 기능을 가진 메소드를 동적으로 래핑하는 부분에 집중해 봅시다:\n\n```js\nmethodKeys.forEach((methodKey) => {\n  // 메소드 이름으로 메소드를 가져옵니다\n  const method = instance[methodKey];\n  // 속성이 함수(메소드)인지 확인합니다\n  if (typeof method === 'function') {\n    // 원본 메소드를 저장합니다\n    this.originals.set(method, method.bind(instance));\n    // 원본 메소드를 로깅 래퍼로 교체합니다\n    instance[methodKey] = (...args: any[]) => {\n      console.log(`${methodKey}를 인수와 함께 호출 중:`, args);\n      return this.originals.get(method)(...args);\n    };\n  }\n});\n```\n\n## 단계별 설명\n\n<div class=\"content-ad\"></div>\n\n```js\nmethodKeys.forEach((methodKey) => {\n```\n\n- methodKeys: 프로바이더의 프로토타입에 있는 모든 메서드 이름의 배열입니다.\n\n2. 이름으로 메서드 가져오기:\n\n```js\nconst method = instance[methodKey];\n```\n\n<div class=\"content-ad\"></div>\n\n- instance[methodKey]: 이름(key)으로 인스턴스의 메서드에 액세스합니다.\n- method: 실제 메서드 함수에 대한 참조를 보유합니다.\n\n3. 속성이 함수인지 확인합니다:\n\n```js\nif (typeof method === 'function') {\n```\n\n- 속성이 실제로 함수이고 다른 유형의 속성(예: 변수)이 아님을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n4. 원본 메소드 저장:\n\n```js\nthis.originals.set(method, method.bind(instance));\n```\n\n- this.originals: 원본 메소드 참조를 저장하는 Map 객체입니다.\n- set(method, method.bind(instance)): 해당 메소드를 인스턴스에 바인딩하여 저장하여 메소드가 호출될 때 올바른 컨텍스트(this)를 유지합니다.\n\n5. 원본 메소드를 로깅 래퍼로 대체하기:\n\n<div class=\"content-ad\"></div>\n\n```js\ninstance[methodKey] = (...args: any[]) => {\n  console.log(`Calling ${methodKey} with args:`, args);\n  return this.originals.get(method)(...args);\n};\n```\n\n- instance[methodKey]: 기존 메소드를 새 함수로 대체합니다.\n- (...args: any[]): '...'는 새 함수를 나타내며:\n- 메소드 호출과 인수를 기록합니다.\n- this.originals에 저장된 참조를 사용하여 원본 메소드를 호출합니다.\n\n# 실제 예시\n\ncreateUser 및 deleteUser 메소드를 갖는 UserService 클래스가 있다고 가정해보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n@Loggable\n@Injectable()\nexport class UserService {\n  createUser(name: string) {\n    console.log(`User ${name} created.`);\n  }\n\n  deleteUser(id: number) {\n    console.log(`User with id ${id} deleted.`);\n  }\n}\n```\n\nLoggerService가 초기화될 때 다음을 합니다:\n\n- UserService 제공자를 탐색합니다.\n- UserService에 @Loggable이 표시되어 있는지 확인합니다.\n- UserService의 각 메서드(예: createUser 및 deleteUser)에 대해\n- 원본 메서드를 저장합니다.\n- 원본 메서드를 호출하기 전에 호출과 매개변수를 기록하는 새 함수로 메서드를 대체합니다\n\n## 단계 3: 사용자 정의 데코레이터 정의하기\n\n\n<div class=\"content-ad\"></div>\n\n클래스 및 메서드에 로깅을 위한 표시를 지정하기 위해 @Loggable 데코레이터를 정의합니다.\n\n데코레이터를 생성하세요:\n\n```js\n// src/logger/loggable.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\n// loggable 메타데이터를 위한 키\nexport const LOGGABLE_KEY = 'LOGGABLE_KEY';\n// 로깅을 위해 클래스를 표시하는 Loggable 데코레이터\nexport const Loggable: ClassDecorator = SetMetadata(LOGGABLE_KEY, true);\n```\n\n## 스텝 4: 사용자 지정 데코레이터 사용하기\n\n<div class=\"content-ad\"></div>\n\n@Service 클래스에서 @Loggable 데코레이터를 사용하여 로깅해야 하는 메서드를 생성하세요.\n\n- 서비스 생성:\n\n```js\nnest generate service user\n```\n\n2. UserService를 구현하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// src/user/user.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Loggable } from '../logger/loggable.decorator';\n\n// UserService 클래스를 로깅하기 위해 표시합니다\n@Loggable\n@Injectable()\nexport class UserService {\n  // 사용자 생성 메서드\n  createUser(name: string) {\n    console.log(`사용자 ${name}이(가) 생성되었습니다.`);\n  }\n\n  // 사용자 삭제 메서드\n  deleteUser(id: number) {\n    console.log(`ID가 ${id}인 사용자가 삭제되었습니다.`);\n  }\n}\n```\n\n3. 로깅을 테스트하기 위해 UserController를 생성합니다:\n\n```bash\nnest generate controller user\n```\n\n4. UserController를 구현합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// src/user/user.controller.ts\nimport { Controller, Post, Body, Delete, Param } from '@nestjs/common';\nimport { UserService } from './user.service';\n\n@Controller('users')\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Post()\n  createUser(@Body('name') name: string) {\n    return this.userService.createUser(name);\n  }\n\n  @Delete(':id')\n  deleteUser(@Param('id') id: number) {\n    return this.userService.deleteUser(id);\n  }\n}\n```\n\n5. Step 5: AppModule에서 LoggerService 통합\n\nLoggerService와 UserController가 응용 프로그램 모듈에 포함되어 있는지 확인하십시오.\n\nAppModule 업데이트:\n\n<div class=\"content-ad\"></div>\n\n```js\n// src/app.module.ts\nimport { Module } from '@nestjs/common';\nimport { DiscoveryModule } from '@nestjs/core';\nimport { LoggerService } from './logger/logger.service';\nimport { UserService } from './user/user.service';\nimport { UserController } from './user/user.controller';\n\n@Module({\n  imports: [DiscoveryModule],\n  providers: [LoggerService, UserService],\n  controllers: [UserController],\n})\nexport class AppModule {\n  // Inject LoggerService to initialize it on application start\n  constructor(private readonly loggerService: LoggerService) {}\n}\n```\n\n## 단계 6: 로깅 테스트\n\ncurl을 사용하여 엔드포인트를 테스트하고 로깅 기능을 확인할 수 있습니다.\n\n- 유저 생성:\n\n<div class=\"content-ad\"></div>\n\n```bash\n# 사용자 추가:\ncurl -X POST http://localhost:3000/users -H \"Content-Type: application/json\" -d '{\"name\": \"John Doe\"}'\n```\n\n2. 사용자 삭제:\n\n```bash\ncurl -X DELETE http://localhost:3000/users/1\n```\n\n# 결과\n\n<div class=\"content-ad\"></div>\n\n```js\ncreateUser을 다음과 같은 args와 함께 호출했습니다: ['John Doe']\n사용자 John Doe가 생성되었습니다.\ndeleteUser을 다음과 같은 args와 함께 호출했습니다: ['1']\nid가 1인 사용자가 삭제되었습니다.\n```\n\n# 요약\n\n이 지침을 따라 NestJS 프로젝트를 생성하고, 특정 메타데이터로 표시된 모든 프로바이더 및 컨트롤러에 대한 메서드 호출을 동적으로 기록하는 로깅 라이브러리를 구축했습니다. 이 튜토리얼은 NestJS의 IoC 컨테이너에 액세스하여 등록된 프로바이더 및 컨트롤러를 검사하고 동적 동작을 적용하는 방법을 보여주었습니다.\n\n사용자 지정 데코레이터와 메타데이터 반사를 활용하여 메서드 호출을 기록하는 유연한 시스템을 구축하여, NestJS의 강력한 IoC 컨테이너를 활용하여 고급 사용 사례에 대처하는 방법을 시연했습니다. 이 접근 방식은 NestJS 애플리케이션의 다른 부분과 동적으로 상호작용해야 하는 다양한 제네릭 및 통합 라이브러리를 구축하기 위해 확장할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png"},"coverImage":"/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png\" alt=\"2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png\"></p>\n<p>안녕하세요! 이 세부적인 자습서에서는 NestJS 프로젝트를 만들고 특정 메타데이터가 지정된 모든 프로바이더 및 컨트롤러의 메서드 호출을 동적으로 탐지하고 기록하는 로깅 라이브러리를 구축할 것입니다. 이 예제는 IoC(Inversion of Control) 컨테이너에 액세스하고 등록된 프로바이더 및 컨트롤러를 조사하며 사용자 정의 데코레이터를 사용하여 동적 동작을 적용하는 방법을 이해하는 데 도움이 될 것입니다.</p>\n<h1>IoC 컨테이너란?</h1>\n<p>NestJS의 IoC 컨테이너는 애플리케이션 구성 요소의 생성, 설정 및 라이프사이클을 관리하여 의존성 주입을 가능하게 합니다. 이는 컨테이너가 필요한 클래스에 자동으로 의존성을 제공하는 의존성 주입을 허용합니다.</p>\n<div class=\"content-ad\"></div>\n<h1>IoC 컨테이너에 접근하는 이유</h1>\n<p>IoC 컨테이너에 접근하는 것은 다음과 같은 이유로 매우 중요합니다:</p>\n<ul>\n<li>살펴보기: 등록된 제공자(Providers) 및 컨트롤러(Controllers)를 모두 검사하기 위해.</li>\n<li>동적 동작: 로깅, 모니터링 또는 메타데이터를 기반으로 동작을 수정하는 등 동적 동작을 적용하기 위해.</li>\n<li>일반 라이브러리: 다양한 응용프로그램 구성 요소와 동적으로 상호작용해야 하는 라이브러리를 구축하기 위해.</li>\n</ul>\n<h1>단계별 안내</h1>\n<div class=\"content-ad\"></div>\n<p>NestJS 프로젝트를 만들고 동적 로깅 라이브러리를 빌드하는 단계를 함께 진행해 보겠습니다.</p>\n<h2>단계 1: NestJS 프로젝트 설정하기</h2>\n<ul>\n<li>NestJS CLI를 설치합니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\">npm install -g @nestjs/cli\n</code></pre>\n<div class=\"content-ad\"></div>\n<ol start=\"2\">\n<li>새로운 NestJS 프로젝트 만들기:</li>\n</ol>\n<pre><code class=\"hljs language-js\">nest <span class=\"hljs-keyword\">new</span> logging-library\ncd logging-library\n</code></pre>\n<ol start=\"3\">\n<li>필수 종속성 설치:</li>\n</ol>\n<pre><code class=\"hljs language-js\">npm install @nestjs/core @nestjs/common @nestjs-plus/discovery\n</code></pre>\n<div class=\"content-ad\"></div>\n<h2>단계 2: LoggerService 생성하기</h2>\n<p>NestJS 라이프사이클 훅을 사용하여 메서드 호출 로깅을 동적으로 설정하고 지우는 LoggerService를 생성합니다.</p>\n<ul>\n<li>LoggerService 생성하기:</li>\n</ul>\n<pre><code class=\"hljs language-js\">nest generate service logger\n</code></pre>\n<div class=\"content-ad\"></div>\n<ol start=\"2\">\n<li>LoggerService를 구현하세요:</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/logger/logger.service.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span>, <span class=\"hljs-title class_\">OnApplicationBootstrap</span>, <span class=\"hljs-title class_\">OnApplicationShutdown</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">DiscoveryService</span>, <span class=\"hljs-title class_\">Reflector</span>, <span class=\"hljs-title class_\">MetadataScanner</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/core'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoggerService</span> implements <span class=\"hljs-title class_\">OnApplicationBootstrap</span>, <span class=\"hljs-title class_\">OnApplicationShutdown</span> {\n  <span class=\"hljs-comment\">// 원본 메소드를 저장하고 종료 시 복원하기 위한 Map</span>\n  private readonly <span class=\"hljs-attr\">originals</span>: <span class=\"hljs-title class_\">Map</span>&#x3C;any, any> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n    <span class=\"hljs-comment\">// DiscoveryService는 모든 프로바이더와 컨트롤러를 찾기 위해 사용됩니다.</span>\n    private readonly discoveryService: DiscoveryService,\n    <span class=\"hljs-comment\">// Reflector는 클래스와 메소드에서 메타데이터를 읽기 위해 사용됩니다.</span>\n    private readonly reflector: Reflector,\n    <span class=\"hljs-comment\">// MetadataScanner는 클래스 프로토타입을 메소드 이름으로 스캔하기 위해 사용됩니다.</span>\n    private readonly metadataScanner: MetadataScanner\n  </span>) {}\n\n  <span class=\"hljs-comment\">// 모든 모듈이 초기화된 후에 실행되는 라이프사이클 훅</span>\n  <span class=\"hljs-title function_\">onApplicationBootstrap</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 애플리케이션에서 모든 프로바이더(컨트롤러 포함)를 가져옵니다.</span>\n    <span class=\"hljs-keyword\">const</span> providers = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">discoveryService</span>.<span class=\"hljs-title function_\">getProviders</span>();\n    providers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">wrapper</span>) =></span> {\n      <span class=\"hljs-comment\">// 프로바이더의 인스턴스(실제 객체) 가져오기</span>\n      <span class=\"hljs-keyword\">const</span> { instance } = wrapper;\n      <span class=\"hljs-comment\">// 프로바이더의 프로토타입(모든 인스턴스에서 공유되는 메소드와 속성) 가져오기</span>\n      <span class=\"hljs-keyword\">const</span> prototype = instance &#x26;&#x26; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(instance);\n      <span class=\"hljs-comment\">// 인스턴스나 프로토타입이 없는 경우 건너뜁니다.</span>\n      <span class=\"hljs-keyword\">if</span> (!instance || !prototype) {\n        <span class=\"hljs-keyword\">return</span>;\n      }\n      <span class=\"hljs-comment\">// 클래스가 @Loggable로 표시되어 있는지 확인합니다.</span>\n      <span class=\"hljs-keyword\">const</span> isLoggable = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reflector</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'LOGGABLE_KEY'</span>, instance.<span class=\"hljs-property\">constructor</span>) ?? <span class=\"hljs-literal\">false</span>;\n      <span class=\"hljs-keyword\">if</span> (!isLoggable) {\n        <span class=\"hljs-keyword\">return</span>;\n      }\n      <span class=\"hljs-comment\">// 클래스 프로토타입에서 모든 메소드 이름 가져오기</span>\n      <span class=\"hljs-keyword\">const</span> methodKeys = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">metadataScanner</span>.<span class=\"hljs-title function_\">getAllMethodNames</span>(prototype);\n      methodKeys.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">methodKey</span>) =></span> {\n        <span class=\"hljs-comment\">// 이름으로 메소드 가져오기</span>\n        <span class=\"hljs-keyword\">const</span> method = instance[methodKey];\n        <span class=\"hljs-comment\">// 함수(메소드)인지 확인합니다.</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> method === <span class=\"hljs-string\">'function'</span>) {\n          <span class=\"hljs-comment\">// 원본 메소드 저장</span>\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">originals</span>.<span class=\"hljs-title function_\">set</span>(method, method.<span class=\"hljs-title function_\">bind</span>(instance));\n          <span class=\"hljs-comment\">// 원본 메소드를 로깅 래퍼로 대체합니다.</span>\n          instance[methodKey] = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args: any[]</span>) =></span> {\n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Calling <span class=\"hljs-subst\">${methodKey}</span> with args:`</span>, args);\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">originals</span>.<span class=\"hljs-title function_\">get</span>(method)(...args);\n          };\n        }\n      });\n    });\n  }\n\n  <span class=\"hljs-comment\">// 애플리케이션이 종료되기 전에 실행되는 라이프사이클 훅</span>\n  <span class=\"hljs-title function_\">onApplicationShutdown</span>(<span class=\"hljs-params\">signal?: string</span>) {\n    <span class=\"hljs-comment\">// 모든 원본 메소드를 복원합니다.</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">originals</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">original, method</span>) =></span> {\n      method = original;\n    });\n    <span class=\"hljs-comment\">// 원본 메소드 Map을 비웁니다.</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">originals</span>.<span class=\"hljs-title function_\">clear</span>();\n  }\n}\n</code></pre>\n<ul>\n<li>Instance: IoC 컨테이너에서 생성된 실제 객체입니다. 이는 응용프로그램에서 상호작용하는 실시간 객체입니다.</li>\n<li>Prototype: 객체의 청사진입니다. 클래스의 모든 인스턴스간에 공유되는 메소드와 속성이 포함되어 있습니다. 프로토타입을 사용하면 클래스 메소드의 동적 조회 및 수정이 가능합니다.</li>\n</ul>\n<h1>로깅 메소드의 상세 설명</h1>\n<div class=\"content-ad\"></div>\n<p>코드의 일부를 더 깊이 파헤쳐 보겠습니다. 여기서는 로깅 기능을 가진 메소드를 동적으로 래핑하는 부분에 집중해 봅시다:</p>\n<pre><code class=\"hljs language-js\">methodKeys.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">methodKey</span>) =></span> {\n  <span class=\"hljs-comment\">// 메소드 이름으로 메소드를 가져옵니다</span>\n  <span class=\"hljs-keyword\">const</span> method = instance[methodKey];\n  <span class=\"hljs-comment\">// 속성이 함수(메소드)인지 확인합니다</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> method === <span class=\"hljs-string\">'function'</span>) {\n    <span class=\"hljs-comment\">// 원본 메소드를 저장합니다</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">originals</span>.<span class=\"hljs-title function_\">set</span>(method, method.<span class=\"hljs-title function_\">bind</span>(instance));\n    <span class=\"hljs-comment\">// 원본 메소드를 로깅 래퍼로 교체합니다</span>\n    instance[methodKey] = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args: any[]</span>) =></span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${methodKey}</span>를 인수와 함께 호출 중:`</span>, args);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">originals</span>.<span class=\"hljs-title function_\">get</span>(method)(...args);\n    };\n  }\n});\n</code></pre>\n<h2>단계별 설명</h2>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">methodKeys.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">methodKey</span>) =></span> {\n</code></pre>\n<ul>\n<li>methodKeys: 프로바이더의 프로토타입에 있는 모든 메서드 이름의 배열입니다.</li>\n</ul>\n<ol start=\"2\">\n<li>이름으로 메서드 가져오기:</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> method = instance[methodKey];\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>instance[methodKey]: 이름(key)으로 인스턴스의 메서드에 액세스합니다.</li>\n<li>method: 실제 메서드 함수에 대한 참조를 보유합니다.</li>\n</ul>\n<ol start=\"3\">\n<li>속성이 함수인지 확인합니다:</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> method === <span class=\"hljs-string\">'function'</span>) {\n</code></pre>\n<ul>\n<li>속성이 실제로 함수이고 다른 유형의 속성(예: 변수)이 아님을 보장합니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<ol start=\"4\">\n<li>원본 메소드 저장:</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">originals</span>.<span class=\"hljs-title function_\">set</span>(method, method.<span class=\"hljs-title function_\">bind</span>(instance));\n</code></pre>\n<ul>\n<li>this.originals: 원본 메소드 참조를 저장하는 Map 객체입니다.</li>\n<li>set(method, method.bind(instance)): 해당 메소드를 인스턴스에 바인딩하여 저장하여 메소드가 호출될 때 올바른 컨텍스트(this)를 유지합니다.</li>\n</ul>\n<ol start=\"5\">\n<li>원본 메소드를 로깅 래퍼로 대체하기:</li>\n</ol>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">instance[methodKey] = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args: any[]</span>) =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Calling <span class=\"hljs-subst\">${methodKey}</span> with args:`</span>, args);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">originals</span>.<span class=\"hljs-title function_\">get</span>(method)(...args);\n};\n</code></pre>\n<ul>\n<li>instance[methodKey]: 기존 메소드를 새 함수로 대체합니다.</li>\n<li>(...args: any[]): '...'는 새 함수를 나타내며:</li>\n<li>메소드 호출과 인수를 기록합니다.</li>\n<li>this.originals에 저장된 참조를 사용하여 원본 메소드를 호출합니다.</li>\n</ul>\n<h1>실제 예시</h1>\n<p>createUser 및 deleteUser 메소드를 갖는 UserService 클래스가 있다고 가정해보겠습니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Loggable</span>\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserService</span> {\n  <span class=\"hljs-title function_\">createUser</span>(<span class=\"hljs-params\">name: string</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`User <span class=\"hljs-subst\">${name}</span> created.`</span>);\n  }\n\n  <span class=\"hljs-title function_\">deleteUser</span>(<span class=\"hljs-params\">id: number</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`User with id <span class=\"hljs-subst\">${id}</span> deleted.`</span>);\n  }\n}\n</code></pre>\n<p>LoggerService가 초기화될 때 다음을 합니다:</p>\n<ul>\n<li>UserService 제공자를 탐색합니다.</li>\n<li>UserService에 @Loggable이 표시되어 있는지 확인합니다.</li>\n<li>UserService의 각 메서드(예: createUser 및 deleteUser)에 대해</li>\n<li>원본 메서드를 저장합니다.</li>\n<li>원본 메서드를 호출하기 전에 호출과 매개변수를 기록하는 새 함수로 메서드를 대체합니다</li>\n</ul>\n<h2>단계 3: 사용자 정의 데코레이터 정의하기</h2>\n<div class=\"content-ad\"></div>\n<p>클래스 및 메서드에 로깅을 위한 표시를 지정하기 위해 @Loggable 데코레이터를 정의합니다.</p>\n<p>데코레이터를 생성하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/logger/loggable.decorator.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">SetMetadata</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n\n<span class=\"hljs-comment\">// loggable 메타데이터를 위한 키</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">LOGGABLE_KEY</span> = <span class=\"hljs-string\">'LOGGABLE_KEY'</span>;\n<span class=\"hljs-comment\">// 로깅을 위해 클래스를 표시하는 Loggable 데코레이터</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Loggable</span>: <span class=\"hljs-title class_\">ClassDecorator</span> = <span class=\"hljs-title class_\">SetMetadata</span>(<span class=\"hljs-variable constant_\">LOGGABLE_KEY</span>, <span class=\"hljs-literal\">true</span>);\n</code></pre>\n<h2>스텝 4: 사용자 지정 데코레이터 사용하기</h2>\n<div class=\"content-ad\"></div>\n<p>@Service 클래스에서 @Loggable 데코레이터를 사용하여 로깅해야 하는 메서드를 생성하세요.</p>\n<ul>\n<li>서비스 생성:</li>\n</ul>\n<pre><code class=\"hljs language-js\">nest generate service user\n</code></pre>\n<ol start=\"2\">\n<li>UserService를 구현하세요.</li>\n</ol>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/user/user.service.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Loggable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../logger/loggable.decorator'</span>;\n\n<span class=\"hljs-comment\">// UserService 클래스를 로깅하기 위해 표시합니다</span>\n@<span class=\"hljs-title class_\">Loggable</span>\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserService</span> {\n  <span class=\"hljs-comment\">// 사용자 생성 메서드</span>\n  <span class=\"hljs-title function_\">createUser</span>(<span class=\"hljs-params\">name: string</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`사용자 <span class=\"hljs-subst\">${name}</span>이(가) 생성되었습니다.`</span>);\n  }\n\n  <span class=\"hljs-comment\">// 사용자 삭제 메서드</span>\n  <span class=\"hljs-title function_\">deleteUser</span>(<span class=\"hljs-params\">id: number</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`ID가 <span class=\"hljs-subst\">${id}</span>인 사용자가 삭제되었습니다.`</span>);\n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li>로깅을 테스트하기 위해 UserController를 생성합니다:</li>\n</ol>\n<pre><code class=\"hljs language-bash\">nest generate controller user\n</code></pre>\n<ol start=\"4\">\n<li>UserController를 구현합니다:</li>\n</ol>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/user/user.controller.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Controller</span>, <span class=\"hljs-title class_\">Post</span>, <span class=\"hljs-title class_\">Body</span>, <span class=\"hljs-title class_\">Delete</span>, <span class=\"hljs-title class_\">Param</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">UserService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./user.service'</span>;\n\n@<span class=\"hljs-title class_\">Controller</span>(<span class=\"hljs-string\">'users'</span>)\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserController</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private readonly userService: UserService</span>) {}\n\n  @<span class=\"hljs-title class_\">Post</span>()\n  <span class=\"hljs-title function_\">createUser</span>(<span class=\"hljs-params\">@Body(<span class=\"hljs-string\">'name'</span>) name: string</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userService</span>.<span class=\"hljs-title function_\">createUser</span>(name);\n  }\n\n  @<span class=\"hljs-title class_\">Delete</span>(<span class=\"hljs-string\">':id'</span>)\n  <span class=\"hljs-title function_\">deleteUser</span>(<span class=\"hljs-params\">@Param(<span class=\"hljs-string\">'id'</span>) id: number</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userService</span>.<span class=\"hljs-title function_\">deleteUser</span>(id);\n  }\n}\n</code></pre>\n<ol start=\"5\">\n<li>Step 5: AppModule에서 LoggerService 통합</li>\n</ol>\n<p>LoggerService와 UserController가 응용 프로그램 모듈에 포함되어 있는지 확인하십시오.</p>\n<p>AppModule 업데이트:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/app.module.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Module</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">DiscoveryModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/core'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">LoggerService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./logger/logger.service'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">UserService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./user/user.service'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">UserController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./user/user.controller'</span>;\n\n@<span class=\"hljs-title class_\">Module</span>({\n  <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">DiscoveryModule</span>],\n  <span class=\"hljs-attr\">providers</span>: [<span class=\"hljs-title class_\">LoggerService</span>, <span class=\"hljs-title class_\">UserService</span>],\n  <span class=\"hljs-attr\">controllers</span>: [<span class=\"hljs-title class_\">UserController</span>],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppModule</span> {\n  <span class=\"hljs-comment\">// Inject LoggerService to initialize it on application start</span>\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private readonly loggerService: LoggerService</span>) {}\n}\n</code></pre>\n<h2>단계 6: 로깅 테스트</h2>\n<p>curl을 사용하여 엔드포인트를 테스트하고 로깅 기능을 확인할 수 있습니다.</p>\n<ul>\n<li>유저 생성:</li>\n</ul>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 사용자 추가:</span>\ncurl -X POST http://localhost:3000/users -H <span class=\"hljs-string\">\"Content-Type: application/json\"</span> -d <span class=\"hljs-string\">'{\"name\": \"John Doe\"}'</span>\n</code></pre>\n<ol start=\"2\">\n<li>사용자 삭제:</li>\n</ol>\n<pre><code class=\"hljs language-bash\">curl -X DELETE http://localhost:3000/users/1\n</code></pre>\n<h1>결과</h1>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">createUser을 다음과 같은 args와 함께 호출했습니다: [<span class=\"hljs-string\">'John Doe'</span>]\n사용자 <span class=\"hljs-title class_\">John</span> <span class=\"hljs-title class_\">Doe</span>가 생성되었습니다.\ndeleteUser을 다음과 같은 args와 함께 호출했습니다: [<span class=\"hljs-string\">'1'</span>]\nid가 <span class=\"hljs-number\">1</span>인 사용자가 삭제되었습니다.\n</code></pre>\n<h1>요약</h1>\n<p>이 지침을 따라 NestJS 프로젝트를 생성하고, 특정 메타데이터로 표시된 모든 프로바이더 및 컨트롤러에 대한 메서드 호출을 동적으로 기록하는 로깅 라이브러리를 구축했습니다. 이 튜토리얼은 NestJS의 IoC 컨테이너에 액세스하여 등록된 프로바이더 및 컨트롤러를 검사하고 동적 동작을 적용하는 방법을 보여주었습니다.</p>\n<p>사용자 지정 데코레이터와 메타데이터 반사를 활용하여 메서드 호출을 기록하는 유연한 시스템을 구축하여, NestJS의 강력한 IoC 컨테이너를 활용하여 고급 사용 사례에 대처하는 방법을 시연했습니다. 이 접근 방식은 NestJS 애플리케이션의 다른 부분과 동적으로 상호작용해야 하는 다양한 제네릭 및 통합 라이브러리를 구축하기 위해 확장할 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}