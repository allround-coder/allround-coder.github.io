{"pageProps":{"posts":[{"title":"리덕스-퍼시스트로 React 앱의 상태 유지하기","description":"","date":"2024-05-12 20:05","slug":"2024-05-12-PersistingStateinYourReactAppwithRedux-Persist","content":"\n\n프런트엔드 개발 세계에서 React는 주요한 역할을 하는 기술로 떠올랐어요. 컴포넌트 기반 아키텍처와 가상 DOM을 통해 사용자 인터페이스를 구축하는 데 강력한 도구로 작용해요. React 애플리케이션의 상태를 관리할 때 Redux는 예측 가능성과 디버깅의 용이성으로 인해 인기 있는 선택지에요. 그렇다면 Redux 상태를 페이지 새로고침이나 앱 재시작에 걸쳐 유지하려면 어떻게 해야 할까요? 이때 \"redux-persist\"가 등장해요.\n\nRedux-persist는 Redux와 완벽하게 통합되어 애플리케이션의 상태를 유지하도록 돕는 라이브러리에요. 이 글에서는 실용적인 코드 조각을 활용해 React 앱에서 redux-persist를 사용하는 방법을 살펴볼 거예요.\n\n# 상태 유지의 필요성\n\nredux-persist에 대해 자세히 알아보기 전에 React 애플리케이션에서 상태 유지가 필요한 이유를 이해하는 것이 중요해요. 대부분의 경우, 애플리케이션의 상태는 메모리에 저장되며 페이지를 새로고침하거나 앱을 닫았다가 다시 열 때 재설정돼요. 일부 애플리케이션에서는 이러한 동작이 수용 가능할 수 있지만, 사용자가 페이지를 떠나거나 새로고침한 후에도 사용자 데이터, 설정 또는 세션 정보를 저장하고 로드해야 하는 경우도 많아요.\n\n\n\n리덕스-퍼시스트는 이 문제에 간편한 해결책을 제공합니다. 이를 통해 Redux 스토어의 상태를 로컬 스토리지나 AsyncStorage(React Native 애플리케이션의 경우)와 같은 영구 저장 매체에 저장한 다음 앱을 로드할 때 해당 상태로 스토어를 재생성할 수 있습니다.\n\n이제 여러분의 리액트 애플리케이션에 이를 구현하는 방법을 살펴보겠습니다.\n\n# 시작하기\n\n먼저, 리액트 프로젝트에 리덕스가 설정되어 있는지 확인하세요. 아직 설정하지 않았다면 Redux를 설치하고 애플리케이션을 위한 스토어를 만들어야 합니다. 이번 시연을 위해 이미 준비된 리덕스 스토어가 있다고 가정하겠습니다.\n\n\n\n다음으로 redux-persist 라이브러리를 설치해야 합니다. npm 또는 yarn을 사용하여 다음과 같이 설치할 수 있습니다:\n\n```js\nnpm install redux-persist\n# 또는\nyarn add redux-persist\n```\n\n이제 redux-persist를 설치했으므로 Redux 스토어와 함께 작동하도록 구성할 수 있습니다.\n\n# 구성\n\n\n\n당신의 Redux 스토어 구성 파일에서 redux-persist로부터 persistReducer를 import하여 상태의 원하는 부분을 지속적으로 저장하도록 구성하세요. 어떤 리듀서와 그 리듀서의 어떤 속성을 지속적으로 저장할지 선택할 수 있습니다.\n\n```js\n// store.js\nimport { createStore } from 'redux';\nimport { persistStore, persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage'; // 사용할 저장 엔진 선택\nimport rootReducer from './reducers'; // 루트 리듀서 import\nconst persistConfig = {\n  key: 'root',\n  storage,\n  // 지속적으로 저장하려는 리듀서 지정\n  whitelist: ['user'], // 이 예시에서는 'user' 리듀서를 지속적으로 저장합니다\n};\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\nexport const store = createStore(persistedReducer);\nexport const persistor = persistStore(store);\n```\n\n이 예시에서는 redux-persist를 사용하여 `user` 리듀서를 지속적으로 저장하도록 구성했지만, 이를 애플리케이션의 요구에 맞게 사용자 정의할 수 있습니다.\n\n# 앱 감싸기\n\n\n\n이제 Redux 스토어를 redux-persist로 구성했으니, redux-persist에서 제공하는 PersistGate 컴포넌트로 앱을 감싸야 합니다. 이 컴포넌트는 영속 상태가 검색되기 전에 앱이 렌더링되도록 보장합니다.\n\n```js\n// index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/integration/react'; // PersistGate 가져오기\nimport { store, persistor } from './store';\nimport App from './App';\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor}>\n      <App />\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n# 사용법\n\nredux-persist가 설정된 상태에서는 React 컴포넌트에서 Redux를 평소처럼 사용할 수 있습니다. persistConfig에서 지정한 모든 상태는 자동으로 지속될 것이며 다시 수분화될 것입니다.\n\n\n\n```js\n// userReducer.js\nconst initialState = {\n  username: '',\n  email: '',\n  // ... other user-related properties\n};\nconst userReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'SET_USERNAME':\n      return {\n        ...state,\n        username: action.payload,\n      };\n    case 'SET_EMAIL':\n      return {\n        ...state,\n        email: action.payload,\n      };\n    // ... other reducer cases\n    default:\n      return state;\n  }\n};\nexport default userReducer;\n```\n\n위 예에서 'user' 리듀서에 대한 모든 변경 사항은 앱이 다시 시작되거나 페이지가 새로고침될 때 자동으로 유지되고 다시로드됩니다.\n\n# 결론\n\nRedux-persist는 React 애플리케이션의 상태 지속성을 제공하여 애플리케이션을 강화하는 강력한 라이브러리입니다. 이는 사용자가 로그인해야 하는 애플리케이션이나 사용자 선호 설정 및 세션 데이터를 저장하려는 애플리케이션에 매우 유용할 수 있습니다.\n```\n\n\n\n이 문서에 설명된 단계를 따라 하면 Redux를 사용하는 React 애플리케이션에 redux-persist를 쉽게 통합할 수 있습니다. 이를 통해 사용자들이 세션 및 페이지 새로고침 간에 데이터 지속성을 즐길 수 있게 되어, 더 견고하고 사용자 친화적인 애플리케이션을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-PersistingStateinYourReactAppwithRedux-Persist_0.png"},"coverImage":"/assets/img/2024-05-12-PersistingStateinYourReactAppwithRedux-Persist_0.png","tag":["Tech"],"readingTime":4},{"title":"NPMRC 파일이란 무엇인가요","description":"","date":"2024-05-12 20:05","slug":"2024-05-12-Whatisanpmrcfile","content":"\n\n.npmrc 파일은 npm(Node Package Manager) 명령행 도구에서 사용되는 구성 파일입니다. 이 파일을 통해 npm이 패키지 및 의존성을 관리하는 방식과 관련된 다양한 설정을 사용자 정의할 수 있습니다. 이 파일은 일반적으로 프로젝트의 루트 디렉토리에 위치하며 다양한 구성 옵션을 포함할 수 있습니다. 아래는 .npmrc 파일에 설정할 수 있는 일반적인 사용 사례 및 구성 옵션입니다:\n\n- 레지스트리 구성: .npmrc 파일을 사용하여 npm이 패키지를 가져올 레지스트리를 지정할 수 있습니다. 예를 들어, 프라이빗 레지스트리나 기본 레지스트리의 미러를 사용하고 싶을 수 있습니다.\n- 스코프 패키지 구성: 스코프 패키지(이름이 @scope/로 시작하는 패키지)를 사용하는 경우 해당 패키지에 특정한 구성 옵션을 설정할 수 있습니다.\n- 인증: .npmrc 파일을 사용하여 프라이빗 레지스트리나 서비스의 인증 토큰 또는 자격 증명을 저장할 수 있습니다.\n- 프록시 구성: 회사 프록시 뒤에서 작업하는 경우 .npmrc 파일에 프록시 관련 옵션을 설정하여 npm이 프록시를 통해 작동하도록 할 수 있습니다.\n- 캐시 제어: .npmrc 파일에 캐시 관련 설정을 지정하여 npm이 패키지를 캐시하는 방식을 제어할 수 있습니다.\n- 글로벌 대 로컬 구성: 글로벌 및 로컬 설정에 대해 서로 다른 .npmrc 파일을 가질 수 있습니다. 글로벌 설정은 시스템의 모든 프로젝트에 적용되고, 로컬 설정은 프로젝트 디렉토리에만 특정합니다.\n- 패키지 설치 동작: npm install을 실행할 때 npm이 패키지를 기본적으로 dependencies 또는 devDependencies로 저장하도록 구성할 수 있습니다. 또한 npm이 패키지를 자동으로 package.json 파일에 저장할지 여부를 제어할 수도 있습니다.\n\n다음은 간단한 .npmrc 파일이 어떻게 보일 수 있는지 예제입니다:\n\n```js\nregistry=https://registry.npmjs.org/\nloglevel=warn\nsave-exact=true\n```\n\n\n\n이 예시에서, 이 파일은 기본 레지스트리를 npm 공개 레지스트리로 설정하고, 로그 레벨을 “warn\"으로 설정하며, npm이 패키지의 정확한 버전을 저장하도록 구성합니다.\n\n.npmrc 파일에 설정한 일부 옵션은 npm을 사용할 때 명령행 인수에 의해 재정의될 수 있습니다. npm 문서에서 설정 옵션의 포괄적인 목록을 찾을 수 있습니다.\n\n.npmrc 파일은 종종 코드와 함께 버전 관리 시스템에 저장되므로 인증 토큰과 같은 중요한 정보를 조심스럽게 다루어야 합니다. 중요한 정보를 관리하기 위해 환경 변수나 다른 안전한 방법을 사용하는 것을 고려해야 합니다.","ogImage":{"url":"/assets/img/2024-05-12-Whatisanpmrcfile_0.png"},"coverImage":"/assets/img/2024-05-12-Whatisanpmrcfile_0.png","tag":["Tech"],"readingTime":2},{"title":"NextJS 인증 플로우  JWT를 쿠키에 저장하기","description":"","date":"2024-05-12 20:04","slug":"2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie","content":"\n\n나는 NextJS 앱 라우터를 프론트엔드로, NestJS를 백엔드로 활용한 사이드 프로젝트에 참여하고 있어. JWT와 쿠키를 사용해서 장기간에 걸쳐 인증 플로우를 구축 중이야. 여기에서는 내가 사용 중인 인증 플로우를 공유할 거야.\n\n# 왜 LocalStorage나 SessionStorage 대신 쿠키를 사용하나요?\n\nLocalStorage/SessionStorage에 저장된 항목은 JavaScript에서 읽을 수 있어 XSS 공격에 취약할 수 있어. 그래서 나는 JavaScript에서 접근할 수 없는 HttpOnly 쿠키를 사용해 액세스 토큰을 저장하기로 결정했어. 즉, 공격자들은 쿠키에서 액세스 토큰을 읽을 수 없다는 뜻이야.\n\n# 인증 플로우\n\n\n\n\n![이미지](/assets/img/2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie_0.png)\n\n![이미지](/assets/img/2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie_1.png)\n\n# 로그인\n\n## NextJS\n\n\n\n로그인 라우트 핸들러를 실행하세요.\n\nLoginButton.tsx\n\n```js\n    const loginRes = await fetch(\"/api/login\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(YOUR_LOGIN_CREDENTIAL),\n    });\n```\n\n## NextJS 라우트 핸들러\n\n\n\n여기가 엑세스 토큰을 설정해야 하는 곳입니다.\n\napp/api/login/route.ts\n\n```js\n...\nexport async function POST(request: NextRequest) {\n  const loginRes = await axios.post(\n    \"MY_BACKEND_URL/api/login\",\n    {...}\n  );\n\n  cookies().set(\"accessToken\", loginRes.data.accessToken, {\n    httpOnly: true,\n    maxAge: 24 * 60 * 60,\n    sameSite: \"strict\"\n  });\n  \n  return NextResponse.json(loginRes.data, { status: 201 });\n}\n```\n\n## Axios\n\n\n\n쿠키가 SameSite=Strict로 설정되어 있으면, 다른 도메인에서 요청이 발생했을 때 서버로 자동으로 전송되지 않습니다. 백엔드로 보낼 때 jwt를 수동으로 쿠키로 설정하고 싶을 수 있습니다. 그렇지 않으면 백엔드는 쿠키가 어디에 있는지 모릅니다. 따라서, Axios 인터셉터를 사용하여 요청 헤더에 쿠키를 첨부합니다.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport const getCookie = async (name: string) => {\n  return cookies().get(name)?.value ?? \"\";\n};\n\ninstance.interceptors.request.use(async function (config) {\n  const accessToken = await getCookie(\"accessToken\");\n  // 인증에서 쿠키를 설정할 수 있습니다\n  // 백엔드에서 accessToken을 읽으려면 어떻게 하고 싶은지에 따라 다릅니다\n  config.headers.Cookie = `accessToken=${accessToken}`;\n  return config;\n});\n```\n\n## NestJS\n\nJWT를 생성하고 API 응답에 포함시켜 반환합니다.\n\n\n\n```js\n...\n@Injectable()\nexport class AuthService {\n  constructor(\n    private jwtService: JwtService,\n  ) {}\n\n  async login(token: string) {\n    try {\n      ...\n      const userPayload = {\n        sub: sub,\n        username: name,\n        email: email,\n        _id: user._id,\n      };\n      const accessToken = await this.jwtService.signAsync(userPayload);\n\n      return { accessToken };\n    } catch (e) {\n      console.log(e);\n    }\n  }\n}\n```\n\n# 로그아웃\n\n## NextJS\n```\n\n\n\n로그아웃 라우트 핸들러를 실행합니다\n\n```js\n  const logout = async () => {\n    await fetch(\"/api/logout\", {\n      method: \"POST\",\n    });\n  };\n```\n\n## NextJS 라우트 핸들러\n\n쿠키를 삭제합니다.\n\n\n\n```js\n...\nimport { cookies } from \"next/headers\";\n\nexport async function POST(request: NextRequest) {\n  cookies().delete(\"accessToken\");\n  return NextResponse.json({ status: 201 });\n}\n```\n\n# 결론\n\n프로젝트에 대한 최종 인증 흐름이 아마 이것은 아닐 것입니다. 여전히 더 나은 구현 방법(예: Refresh Token 흐름 구현 등)을 찾고 있습니다. 읽어 주셔서 감사합니다.\n\n# 간단하게 설명하면 🚀```\n\n\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인해보세요","ogImage":{"url":"/assets/img/2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie_0.png"},"coverImage":"/assets/img/2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie_0.png","tag":["Tech"],"readingTime":4},{"title":"조드 TypeScript를 우선으로 하는 최고의 스키마 유효성 검사 라이브러리","description":"","date":"2024-05-12 20:03","slug":"2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary","content":"\n\n데이터 유효성 검사는 어떤 애플리케이션 개발 과정에서 중요한 측면으로, 들어오는 데이터가 예상 형식과 제약 조건을 준수하는지 확인합니다. TypeScript 세계에서, 개발자들은 종종 untyped 또는 느슨하게 typed된 데이터 원본을 처리할 때 타입 안전성을 유지하는 도전에 직면합니다. 여기 Zod가 나타납니다. TypeScript-first 스키마 유효성 검사 라이브러리로, 이 간극을 원활하게 연결하려고 합니다.\n\n![2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary_0](/assets/img/2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary_0.png)\n\n## Zod란 무엇인가요?\n\nZod는 개발자 친화적인 경험을 제공하도록 설계된 스키마 선언 및 유효성 검사 라이브러리입니다. TypeScript 강력한 유형 시스템을 활용해 스키마 정의에서 정적 유형을 추론하며, 중복된 유형 선언의 필요성을 제거합니다. Zod를 사용하면 한 번의 유효성 검사기를 선언하고 자동으로 해당 TypeScript 유형을 추론할 수 있어, 간단한 유형을 복잡한 데이터 구조로 구성하기가 쉬워집니다.\n\n\n\n## Zod 사용의 장점들\n\n- 타입 안전성: Zod의 기반은 TypeScript의 타입 시스템으로 구축되어 코드베이스 전반에 걸쳐 견고한 타입 안전성을 제공합니다.\n- 간편함: Zod의 간결하고 연결 가능한 인터페이스는 직관적인 스키마 정의를 가능하게 하여 기존 스키마의 구성 및 확장을 용이하게 합니다.\n- 성능: Zod은 가벼우며 의존성이 없어 서버 및 클라이언트 애플리케이션에 모두 적합합니다.\n- 기능적 접근: Zod은 데이터 유효성 검사에 기능적 접근을 채택하여 \"구문 분석, 유효성 검사\" 패러다임을 장려하여 더 예측 가능하고 신뢰할 수 있는 경험을 제공합니다.\n- 확장성: Zod은 풍부한 내장 유효성 검사 세트를 제공하면서 리파인먼트와 변환을 통해 사용자 정의 유효성 로직을 정의할 수 있는 유연성을 제공합니다.\n\n## Zod 사용 시작하기\n\nZod를 설치하는 것은 간단하며 원하는 패키지 매니저를 사용하여 수행할 수 있습니다:\n\n\n\n```js\n# npm을 이용한 설치\nnpm install zod\n\n# yarn을 이용한 설치\nyarn add zod\n```\n\n설치가 완료되면 TypeScript에서 첫 번째 스키마를 정의할 수 있습니다:\n\n```js\nimport { z } from 'zod';\n\n// 간단한 문자열 스키마 정의\nconst mySchema = z.string();\n\n// 데이터 구문 분석\nmySchema.parse('tuna'); // 'tuna' 반환\nmySchema.parse(12); // ZodError가 발생함\n```\n\n이 예제에서는 z.string() 스키마를 만들고 .parse() 메서드를 사용하여 입력 데이터를 유효성 검사합니다. 입력이 문자열이면 반환되고, 그렇지 않으면 ZodError가 발생합니다.\n\n\n\nZod은 기본 데이터 유형(문자열, 숫자, 부울), 객체, 배열, 유니언, 교차 등을 포함한 포괄적인 스키마 유형 세트를 제공합니다. 이러한 스키마를 조합하여 복잡한 데이터 구조를 나타내고 다양한 유효성 검사 및 변환을 적용할 수 있습니다.\n\n## 고급 기능\n\nZod은 데이터 유효성 검사 경험을 향상시키는 다양한 고급 기능을 제공합니다:\n\n- 세분화: 세분화를 사용하여 데이터에 특정 제약 조건을 강제할 사용자 지정 유효성 검사 논리를 정의할 수 있습니다.\n- 변환: 유효성 검사 전후에 데이터에 변환을 적용하여 데이터 조작을 원활하게 할 수 있습니다.\n- 오류 처리: Zod은 자세한 오류 보고 및 사용자 정의 옵션을 제공하여 유효성 검사 오류를 효과적으로 처리하기 쉽게 만듭니다.\n- 함수형 프로그래밍: Zod의 함수형 프로그래밍 기능을 활용하여 스키마를 조합하고 변환하여 더 선언적이고 표현이 풍부한 코딩 스타일을 구현할 수 있습니다.\n- 생태계 지원: Zod은 제3자 라이브러리와 통합이 확장되고 인기있는 프레임워크 및 도구와의 원활한 통합을 가능하게 하는 성장 중인 생태계를 보유하고 있습니다.\n\n\n\n## 결론\n\nZod는 TypeScript 개발자들에게 강력하고 사용자 친화적인 데이터 유효성 검사 솔루션을 찾는 사람들에게 혁신적인 변화를 가져다줍니다. TypeScript의 타입 시스템을 활용하고 풍부한 기능 세트를 제공함으로써, Zod는 복잡한 데이터 구조를 정의하고 유효성을 검사하는 작업을 간단하게 만들어 주며, 타입 안전성과 유지 보수성을 보장합니다. 서버 측 API, 클라이언트 측 애플리케이션 또는 TypeScript 기반 프로젝트를 구축하고 있다면, Zod가 개발 환경을 크게 향상시키고 개발 주기 초기에 데이터 관련 문제를 빨리 찾을 수 있도록 도와줄 것입니다.\n\nZod의 힘을 받아 TypeScript 프로젝트에서 자신감을 키워보세요. 자세한 내용을 알아보고 예제를 살펴보며 더 깊게 파고들기 위해 https://zod.dev의 공식 Zod 문서를 방문해보세요.","ogImage":{"url":"/assets/img/2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary_0.png"},"coverImage":"/assets/img/2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary_0.png","tag":["Tech"],"readingTime":3},{"title":"Amplify 대 Firebase 내 실제 제품과의 대면 비교","description":"","date":"2024-05-12 20:01","slug":"2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct","content":"\n\n## 주요 차이점 및 유사점\n\n![Comparison Image](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_0.png)\n\n지난 1년간 실제 트래픽과 사용자가 있는 2개 제품을 개발했습니다. 하나는 Amplify를 사용하고, 다른 하나는 Firebase를 사용했습니다. 제가 배운 교훈들과 Amplify와 Firebase를 대조한 비교를 공유하려고 합니다.\n\n이 글을 두 부분으로 나눠 작성하겠습니다. 첫 번째 부분에서는 Firebase에 대해, 두 번째 부분에서는 Amplify에 대해 이야기하겠습니다.\n\n\n\n# 왜 Firebase 또는 Amplify를 사용해야 하나요?\n\n간단히 말해서, 나는 경력이 4년인 프론트엔드 엔지니어입니다. 제 경험상 본업급 백엔드에 거의 관여한 적이 없어 백엔드 품질에 대한 최고의 실천 방법에 대한 지식이 적다고 가정해도 좋습니다.\n\n제품 개발에 집중하고 싶으며, 인증, 데이터베이스 CRUD, 자산 저장, 그리고 물론 백엔드 보안을 포함한 백엔드 측면의 품질을 희생하지 않고 가장 빠르게 출시하고자 합니다.\n\nAmplify와 Firebase는 모두 동일한 문제를 해결하는데, 즉 프론트엔드 웹 및 모바일 개발자가 쉽게 앱 또는 게임을 빌드하고 확장할 수 있는 완벽한 솔루션을 제공한다는 점입니다.\n\n\n\n# 파이어베이스를 사용하여 만든 내가 만든 것\n\n세계 각지의 플레이어들이 게임 속에 출시되기를 원하는 모든 노래 위시리스트를 수집하기위해 프로젝트 세카이를 기반으로 한 커뮤니티 페이지를 만들었습니다.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_1.png)\n\n# 내 프로젝트에서 사용한 파이어베이스 기능\n\n\n\n## 인증\n\nFirebase Authentication을 사용하여 사용자 인증 및 권한 부여를 처리했어요. 많은 인증 옵션이 있지만, 이 프로젝트에서는 Google 로그인과 Twitter 로그인을 선택했어요.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_2.png)\n\n## Firestore\n\n\n\nCloud Firestore를 데이터베이스 옵션으로 사용했어요. 이는 MongoDB와 유사한 문서 기반 구조를 가진 NoSQL 데이터베이스입니다. 이 데이터베이스를 사용하여 다음을 처리했어요:\n\n- 내장된 실시간 업데이트로 사용자 투표\n\n![](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_3.png)\n\n- 사용자가 소원 노래를 제출\n\n\n\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_4.png)\n\n- 게임에서 이미 출시된 노래를 관리합니다.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_5.png)\n\n## 저장소\n\n\n\n저는 이미지 배너와 같은 자산 저장을 다루는 간단한 사용 사례를 가지고 있는 Cloud Storage를 사용했어요.\n\n## 보안 규칙\n\n저는 사용자가 특정 데이터에 접근할 수 있도록 조작할 수 있는 보안 규칙을 사용했어요.\n\n## Algolia\n\n\n\nCloud Firestore은 데이터 조작 기능이 훌륭하지만 한 가지 중요한 기능을 수행할 수 없습니다: 전체 텍스트 및 부분 텍스트 검색입니다. 그러나 Firebase는 Algolia 검색과 통합하는 것을 지원하는 우선 순위 옵션을 제공합니다.\n\n# Firebase의 장단점\n\n## 장점\n\n- 생산성 — Firebase는 프론트엔드 엔지니어를 위한 훌륭한 기능을 갖추고 있어 제품을 빨리 출시하고 사용자 트래픽에 따라 자동으로 확장하며 보안을 보장하는 데 큰 도움이 됩니다. Firebase의 내부에는 GCP 자체가 있어 Firebase 프로젝트의 기능을 Google Cloud Platform으로 쉽게 확장할 수 있습니다.\n- 학습 곡선 — Firebase 기능과의 통합이 매우 직관적이기 때문에 학습 곡선이 낮습니다.\n- 인증 — Firebase 인증은 Google, Apple, Facebook, Twitter, Microsoft, GitHub, Yahoo와 같은 제3자 서비스와의 통합을 위한 많은 내장 지원이 있습니다.\n\n\n\n## 단점\n\n어드민 패널이 없음 — Firebase에는 내장된 어드민 패널이 제공되지 않습니다. 사용자들은 Firebase 콘솔 내에서 데이터를 직접 조작할 수 있지만, UI가 기술 지식이 없는 사람들에겐 너무 기술적일 수 있습니다. 이 경우, 별도의 어드민 패널을 만들어야 합니다.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_6.png)\n\n전체 또는 부분 텍스트 검색 미지원 — 부분 또는 전체 텍스트 검색을 수행하는 데 필요한 기능이 내장되어 있지 않기 때문에, Algolia, Elasticsearch, 또는 Typesense와 같은 제3자 서비스와 통합해야 합니다.\n\n\n\n데이터베이스 객체 모델링 - 이 프로젝트를 개발할 때, 저는 여전히 Firebase 버전 8.10.0을 사용하고 있었는데, 클라우드와 코드 간 데이터 유형의 일관성을 유지하는 것이 꽤 어려웠습니다. MongoDB와 같은 데이터베이스는 객체 모델링을 위한 Mongoose와 같은 솔루션이 있지만, Firestore에 대한 유사한 솔루션을 찾지 못했습니다. 이는 때때로 필드 이름에 오타가 있거나, 필드 이름이 아직 정의되지 않아서 생산성과 코드 품질이 떨어지게 만듭니다.\n\n하지만 Firebase의 최신 버전에서는 이 문제를 해결할 수 있는 사용자 정의 객체를 처리하는 기능이 있습니다:\n\n```js\nclass City {\n    constructor (name, state, country ) {\n        this.name = name;\n        this.state = state;\n        this.country = country;\n    }\n    toString() {\n        return this.name + ', ' + this.state + ', ' + this.country;\n    }\n}\n\n// Firestore 데이터 컨버터\nconst cityConverter = {\n    toFirestore: (city) => {\n        return {\n            name: city.name,\n            state: city.state,\n            country: city.country\n            };\n    },\n    fromFirestore: (snapshot, options) => {\n        const data = snapshot.data(options);\n        return new City(data.name, data.state, data.country);\n    }\n};\n```\n\n# Amplify를 활용해 만들어본 것\n\n\n\n코스프레 취미를 위한 전체적인 의상 대여 샵을 만들었어.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_7.png)\n\n# 내 프로젝트에서 사용한 Amplify 기능\n\n- Amazon Cognito — 사용자 인증 및 권한 부여를 처리하기 위해 Amazon Cognito를 사용했어. 다양한 인증 옵션이 있지만, 이 프로젝트에서는 Google 및 Facebook 로그인을 선택했어.\n- Amazon CloudFormation — AWS CloudFormation을 사용하면 인프라를 코드로 처리하여 AWS 및 제3자 리소스를 모델링, 프로비저닝 및 관리할 수 있어. CloudFormation 덕분에 스테이징 및 프로덕션과 같은 브랜치 환경을 쉽게 만들 수 있어.\n- Amazon AppSync — AWS AppSync을 사용하면 서버리스 GraphQL 및 Pub/Sub API를 생성해 어플리케이션 개발을 단순화할 수 있어. 안전하게 데이터 쿼리, 업데이트 또는 게시하는 단일 엔드포인트를 통해 애플리케이션 개발을 단순화할 수 있어.\n- Amazon DynamoDB — Firestore를 사용하는 문서 기반 컨셉에 대해 이전 섹션에서 소개했었어. 다른 쪽으로 DynamoDB는 Redis와 유사한 키-값 스키마를 사용해. 웹사이트의 모든 데이터(사용자 데이터, 제품 데이터, 거래 데이터, 결제 데이터 등)를 처리하기 위해 DynamoDB를 사용했어.\n- Amazon S3 — S3는 어디서든 어떤 양의 데이터든 검색할 수 있는 객체 저장소야. 제품 이미지, 웹사이트 자산, 사용자 자산을 처리하기 위해 Amazon S3를 사용했어.\n- Amazon Pinpoint — Amazon Pinpoint는 대상 멀티채널 통신 도구야. Google Analytics의 AWS 플랫폼용 동등물이야. 웹사이트 관련 추적 및 분석을 처리하기 위해 Amazon Pinpoint를 사용했어.\n- Amazon Lambda — Amazon Lambda는 서버리스, 이벤트 주도형 컴퓨팅 서비스야. 결제 게이트웨이 및 택배 게이트웨이와 같은 제3자 공급업체와의 모든 API 통신을 처리하기 위해 AWS Lambda를 사용했어.\n\n\n\n# Amplify의 장단점\n\n## 장점\n\n- Amplify Studio — 이전 섹션에서 논의된 Firebase 버전과 달리, AWS Amplify에는 Amplify Studio라는 일반 관리 패널이 함께 제공됩니다. Amplify Studio는 데이터 관리, 사용자 관리 및 자산 관리를 처리할 수 있습니다. Amplify Studio의 기능을 보여주는 몇 가지 예시는 다음과 같습니다.\n\n![Amplify Studio](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_8.png)\n\n\n\n- CloudFormation - AWS CloudFormation을 사용하면 환경을 쉽게 복제할 수 있습니다. 특히 스테이징 및 프로덕션 환경을 구축할 때 유용합니다. Firebase와 비교했을 때 이것이 주요 장점 중 하나입니다.\n- 데이터베이스 객체 모델링 - AWS AppSync을 통해 GraphQL 스키마 유형을 사용하여 데이터베이스 스키마를 정의할 수 있습니다. 이것은 '데이터베이스를 코드로' 접근 방식을 만들어 모든 데이터 구성에서 일관성을 보장합니다. 또한 이 스키마를 사용하여 데이터 인가를 구성할 수도 있습니다.\n\n```js\ntype Products @model @auth(rules: [{allow: public}]) {\n  id: ID!\n  available_size: [AvailableSizeEnums!]!\n  day_rent_price: Int!\n  is_active: Boolean!\n  minimum_rent_duration: Int!\n  product_name: String!\n  quantity: Int!\n  weight: Int!\n  s3_path: String!\n  product_image: [String!]!\n  product_description: String!\n}\n```\n\n전체-부분-텍스트 검색 - Amazon은 Amazon OpenSearch로 검색을 처리하는 내장 기능을 제공합니다.\n\n## 단점\n\n\n\n인증 - AWS Cognito는 Firebase와 비교했을 때 소셜 통합 옵션이 적습니다. Amazon, Facebook, Google 및 Apple을 통한 로그인 옵션이 있지만 Auth0와 연동하여 확장할 수 있습니다.\n\n학습 곡선 - AWS Amplify는 Firebase에 비해 UI 엔지니어들에게 이해하기 어려운 학습 곡선을 가지고 있다고 느껴져요. Amplify는 AWS 리소스를 관리하기 위한 구축 블록이자 CLI 가이드 명령어일뿐입니다. 따라서 Amplify가 어떻게 작동하는지 이해하려면 여러 AWS 제품을 이해해야 합니다. 예를 들어, DynamoDB에 새 데이터 필드를 추가하려면 Firestore와 달리 몇 단계를 거쳐야 합니다.\n\n커뮤니티 토론 부족 - 앞서 말한대로 AWS Amplify는 학습 곡선이 높습니다. 그래서 오류, 문제 또는 모르는 것을 만났을 때 Firebase와 비교하여 Stack Overflow나 GitHub의 토론 및 질의응답이 적습니다. 게다가 AWS 개발자 지원을 구독하여 기술적인 질문이 있을 경우 AWS에서 직접 개발자 지원을 받을 수 있습니다.\n\n# 결론\n\n\n\n프론트엔드 엔지니어로서, Amplify와 Firebase는 우리가 직접 제품을 만들 때 백엔드와 관련된 복잡한 문제를 해결할 수 있는 좋은 도구입니다. 어떤 것을 더 선호하는지 물어본다면, 그것은 상황에 따라 다르겠죠.\n\n커뮤니티와 함께 재미있는 것이나 별로 중요하지 않은 제품을 만들고 싶다면 Firebase를 선택할 것입니다. 하지만 본격적인 제품을 만들어 나의 부수입을 올리고 싶다면 Amplify를 선택할 것입니다.\n\n# 자료\n\n- [Amplify 문서](https://docs.amplify.aws/)\n- [Firebase 문서](https://firebase.google.com/docs)","ogImage":{"url":"/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_0.png"},"coverImage":"/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_0.png","tag":["Tech"],"readingTime":7},{"title":"사용자 경험 향상을 위한 사용자 정의 JavaScript 활용하기 Div 바깥에서의 클릭 처리하기","description":"","date":"2024-05-12 20:00","slug":"2024-05-12-TitleLeveragingCustomJavaScripttoEnhanceUserExperienceHandlingClicksOutsideaDiv","content":"\n\n<img src=\"/assets/img/2024-05-12-TitleLeveragingCustomJavaScripttoEnhanceUserExperienceHandlingClicksOutsideaDiv_0.png\" />\n\n현대 웹 개발에서 사용자가 직관적이고 원활한 경험을 할 수 있도록 만들어주는 것이 매우 중요합니다. 개발자들이 자주 마주치는 상황 중 하나는 드롭다운 메뉴, 모달 또는 페이지의 다른 곳을 클릭했을 때 해당 요소가 닫혀야 하는 경우입니다. 이 글에서는 이 요구 사항을 우아하게 처리하기 위한 사용자 정의 JavaScript 솔루션을 알아보겠습니다.\n\n문제 이해하기:\n\n사용자 정의 JavaScript 소개:\n\n\n\n이번 도전에 대처하기 위해 JavaScript에서 클릭이 지정된 요소 외부에서 발생하는지 감지하는 재사용 가능한 사용자 지정 후크(custom hook)를 만들 것입니다. 이 후크는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리인 React를 활용하여 우리의 프론트엔드 코드베이스와 시킬 것입니다.\n\nClickOutsideWrapper.js\n\n```js\n//필요한 종속성을 가져옵니다.\nimport React, { useRef, useEffect } from 'react';\n\n//지정된 요소 외부에서 클릭을 처리하는 사용자 정의 후크\nconst useClickOutside = (handler) => {\n  const ref = useRef();\n\n  //요소 외부 클릭을 처리하는 함수\n  const handleClickOutside = (event) => {\n    if (ref.current && !ref.current.contains(event.target) && typeof handler === 'function') {\n      handler();\n    }\n  };\n\n  useEffect(() => {\n    //마우스 다운 이벤트에 대한 이벤트 리스너 추가\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      //컴포넌트 해제 시 이벤트 리스너 제거\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [handler]); //의존성 배열에 핸들러를 포함\n\n  return ref;\n};\n\n//useClickOutside 후크를 활용하는 래퍼 컴포넌트\nconst ClickOutsideWrapper = ({ children, onClickOutside }) => {\n  const wrapperRef = useClickOutside(onClickOutside);\n  return <div ref={wrapperRef}>{children}</div>;\n};\n\nexport default ClickOutsideWrapper;\n```\n\n구현 탐색:\n\n\n\n- useClickOutside 훅: 이 사용자 정의 훅은 지정된 요소 외부의 클릭을 감지하는 로직을 캡슐화합니다. 콜백 함수 핸들러를 인수로 사용하며, 해당 요소 외부를 클릭할 때 호출됩니다.\n- handleClickOutside 함수: 이 함수는 ref로 참조된 요소 외부에서 클릭이 발생했는지 확인합니다. 그리고 유효한 핸들러 함수가 제공되었고, 클릭이 요소 외부에서 발생했다면 핸들러를 실행합니다.\n- useEffect 훅: 이 훅은 요소 외부의 클릭을 감지하는 이벤트 리스너를 추가하고 제거하는 역할을 담당합니다. 컴포넌트가 언마운트될 때 이벤트 리스너가 제대로 정리되도록 하여 메모리 누수를 예방합니다.\n- ClickOutsideWrapper 컴포넌트: 이 컴포넌트는 해당 요소 외부의 클릭을 감지해야 하는 요소 주위에 래퍼 역할을 합니다. useClickOutside 훅을 활용하고 onClickOutside 콜백 프롭을 전달합니다.\n\n실용적인 사용 사례:\n\n- 드롭다운 메뉴: 사용자가 메뉴 외부를 클릭하면 드롭다운 메뉴를 닫습니다.\n- 모달: 사용자가 모달 외부 요소와 상호 작용할 때 모달을 닫습니다.\n- 컨텍스트 메뉴: 페이지의 다른 곳을 클릭하면 컨텍스트 메뉴를 숨깁니다.\n- 팝오버 및 툴팁: 연관된 요소 외부를 클릭하면 팝오버와 툴팁을 닫습니다.\n\n컴포넌트에서 사용:\n\n\n\n```js\nimport React, { useState } from 'react';\nimport ClickOutsideWrapper from './ClickOutsideWrapper';\n\nconst DropdownMenu = () => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  // Toggle dropdown menu visibility\n  const toggleMenu = () => {\n    setIsOpen(!isOpen);\n  };\n\n  // Close dropdown menu when clicked outside\n  const closeMenu = () => {\n    setIsOpen(false);\n  };\n\n  return (\n    <div className=\"dropdown\">\n      {/* 버튼을 클릭하여 메뉴 표시 여부를 전환합니다. */}\n      <button onClick={toggleMenu}>메뉴 전환</button>\n      \n      {/* 드롭다운 메뉴 */}\n      {isOpen && (\n        <ClickOutsideWrapper onClickOutside={closeMenu}>\n          <div className=\"menu\">\n            <ul>\n              <li>옵션 1</li>\n              <li>옵션 2</li>\n              <li>옵션 3</li>\n            </ul>\n          </div>\n        </ClickOutsideWrapper>\n      )}\n    </div>\n  );\n};\n\nexport default DropdownMenu;\n```\n\n이 예제에서:\n\n- DropdownMenu 컴포넌트를 가지고 있으며 버튼을 렌더링하여 메뉴의 가시성을 토글합니다.\n- 버튼을 클릭하면 isOpen 상태가 토글되고, 이는 메뉴가 표시되는지 여부를 제어합니다.\n- DropdownMenu 컴포넌트 내에서 isOpen 상태를 사용하여 드롭다운 메뉴를 조건부로 렌더링합니다.\n- 드롭다운 메뉴는 ClickOutsideWrapper 컴포넌트로 래핑되어 있으며 onClickOutside 프롭을 가지고 있습니다. 이 프롭은 메뉴 외부를 클릭했을 때 메뉴를 닫는 closeMenu 함수로 설정됩니다.\n- 사용자가 드롭다운 메뉴 외부 요소와 상호 작용할 때 ClickOutsideWrapper 컴포넌트를 사용하여 메뉴가 자동으로 닫히도록 하여 매끄러운 사용자 경험을 제공합니다.```\n\n\n\nNPM 패키지:\n\n패키지 링크: [click-outside-wrapper](https://www.npmjs.com/package/click-outside-wrapper)\n\n결론:\n\n여기서 소개된 것과 같이 사용자 정의 JavaScript 솔루션을 활용함으로써 개발자들은 웹 애플리케이션의 사용성을 향상시킬 수 있습니다. 특정 요소 외부의 클릭을 감지하는 능력은 개발자들이 더 직관적이고 사용자 친화적인 인터페이스를 만들 수 있도록 돕습니다. 드롭다운 메뉴, 모달 또는 기타 상호 작용 요소일지라도 클릭 외부 기능을 구현하면 웹 개발자에게 귀중한 도구가 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-TitleLeveragingCustomJavaScripttoEnhanceUserExperienceHandlingClicksOutsideaDiv_0.png"},"coverImage":"/assets/img/2024-05-12-TitleLeveragingCustomJavaScripttoEnhanceUserExperienceHandlingClicksOutsideaDiv_0.png","tag":["Tech"],"readingTime":4},{"title":"Nextjs에서 와일드카드 서브도메인을 경로로 사용하기","description":"","date":"2024-05-12 19:59","slug":"2024-05-12-UsingwildcardsubdomainsaspathsonNextjs","content":"\n\n가끔씩 App Masters에서는 각 가능한 서브도메인마다 다른 주제(또는 데이터)를 가진 프로젝트를 작업해야 합니다.\n\n![Using wildcard subdomains as paths on Next.js](/assets/img/2024-05-12-UsingwildcardsubdomainsaspathsonNextjs_0.png)\n\nNext.js를 사용하고 있기 때문에 기본적으로 이렇게 하는 것이 가능해 보이지만, 사실 그렇게 간단하지는 않습니다.\n\n클라이언트 측에서는 window.location을 사용하여 쉽게 서브도메인을 알 수 있지만, 서버 측에서는 런타임에만 알 수 있고 빌드 타임에서는 알 수 없기 때문에 정적 렌더링과 Next.js에서 제공했던 기타 최적화 기능을 포기해야 했습니다. 대신 항상 getServerSideProps를 사용하여 요청 내에서 서브도메인을 가져오는 방식으로 사용하게 되었습니다.\n\n\n\n더 이상 그럴 필요 없어요!\n\n이 문제를 해결하기 위한 첫 번째 접근 방식은 각 요청의 헤더를 확인하면서 Next.js 리라이트 기능을 사용하려고 매핑하는 것이었습니다. 작동할 것 같지만 현재는 헤더 값을 경로로 매핑할 수 없고 매개변수만 가능합니다.\n\n다른 해결책은 Next.js 프론트엔드를 제공하는 사용자 지정 노드 서버를 갖는 것인데요, 이 경우 최적화 기능 중 일부를 놓치게 되고 더 많은 코드를 유지 보수해야 합니다.\n\n# 해결책: 미들웨어 사용하기!\n\n\n\nNext 12에서 소개되고 Next 13에서 업데이트된 것은 이제 우리는 미들웨어를 쉽게 사용하여 다음 노드 서버로의 모든 요청을 처리할 수 있으며 요청이 라우터에 도달하기 전에 요청을 변경할 수 있습니다.\n\n그래서 먼저, /src/pages 폴더 내에 [서브도메인]이라는 폴더를 만들고 이 폴더에 모든 페이지를 추가했습니다. 이미 알고 계시겠지만, 페이지 폴더 내의 폴더/파일 이름에 []를 추가하면 해당 이름이 동적인 것으로 만들어집니다.\n\n![이미지](/assets/img/2024-05-12-UsingwildcardsubdomainsaspathsonNextjs_1.png)\n\n그 다음으로, pages 폴더와 동일한 레벨에 src/middleware.ts 파일을 생성하고 코드를 작성하기 시작했습니다.\n\n\n\n```js\n// middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { getValidSubdomain } from '@/utils/subdomain';\n\n// 정규 표현식을 이용하여 공개 파일을 판별합니다\nconst PUBLIC_FILE = /\\.(.*)$/; // 파일\n\nexport async function middleware(req: NextRequest) {\n  // URL을 복제합니다\n  const url = req.nextUrl.clone();\n\n  // 공개 파일은 건너뜁니다\n  if (PUBLIC_FILE.test(url.pathname) || url.pathname.includes('_next')) return;\n\n  const host = req.headers.get('host');\n  const subdomain = getValidSubdomain(host);\n  if (subdomain) {\n    // 서브도메인이 있는 경우 경로를 다시 작성합니다\n    console.log(`>>> Rewriting: ${url.pathname} to /${subdomain}${url.pathname}`);\n    url.pathname = `/${subdomain}${url.pathname}`;\n  }\n\n  return NextResponse.rewrite(url);\n}\n```\n\nmiddleware 함수는 내 모든 요청을 처리하며 유효한 서브도메인이 있는지 확인합니다. 있다면, 수동으로 pathname을 '/subdomain'으로 재작성합니다. 예를 들어, https://baraky.domain.com/edit 요청은 https://baraky.domain.com/baraky/edit 페이지로 접근합니다.\n\ngetValidSubdomain의 코드는 다음과 같습니다:\n\n```js\nexport const getValidSubdomain = (host?: string | null) => {\n  let subdomain: string | null = null;\n  if (!host && typeof window !== 'undefined') {\n    // 클라이언트 측에서는 window를 통해 host를 가져옵니다\n    host = window.location.host;\n  }\n  if (host && host.includes('.')) {\n    const candidate = host.split('.')[0];\n    if (candidate && !candidate.includes('localhost')) {\n      // 유효한 후보\n      subdomain = candidate;\n    }\n  }\n  return subdomain;\n};\n```\n\n\n\n해당 함수에 몇 가지 다른 기능을 추가했어요. 호스트 문자열이 없어도 서브도메인을 가져올 수 있게 했답니다.\n\n이제는 [subdomain] 폴더 내에서 페이지를 변경할 수 있을 거예요. 서브도메인 값은 라우터 내에서 query 매개변수로 사용할 수 있고, 이를 원하는 대로 활용할 수 있어요:\n\n- 각 서브도메인에 대한 관련 데이터를 가져오기\n- 각 서브도메인마다 다른 테마 적용하기\n- 각 서브도메인별로 특정 캐시 사용 및 getStaticProps를 사용한 정적 생성 페이지 생성하기\n\n하지만 기억해 주세요: 와일드카드 서브도메인에 액세스하려면 해당 기능을 제공하는 호스팅 내에서 Next.js 앱을 호스팅해야 합니다.\n\n\n\n# 왜 이게 중요한가요?\n\n서브도메인 대신 서브 라우트로 페이지를 분리하면 각 서브도메인에 대해 getStaticProps를 사용할 수 있습니다. 서로 다른 캐시에서 분리할 수 있으므로 Next.js는 https://something.domain.com과 https://other-thing.domain.com을 구별할 수 있습니다. 그렇지 않으면 두 웹사이트 모두에 대해 같은 정적 렌더링을 반환할 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-UsingwildcardsubdomainsaspathsonNextjs_0.png"},"coverImage":"/assets/img/2024-05-12-UsingwildcardsubdomainsaspathsonNextjs_0.png","tag":["Tech"],"readingTime":4},{"title":"디지털 캠페인의 힘 소셜 미디어가 현대 선거를 형성하는 방법","description":"","date":"2024-05-12 19:58","slug":"2024-05-12-ThePowerofDigitalCampaigningHowSocialMediaIsShapingModernElections","content":"\n\n정치 커뮤니케이션의 끊임없이 변화하는 풍경에서 소셜 미디어는 강력한 힘으로 떠오르며 후보자들이 유권자와 대중 의견을 형성하는 방식을 혁명적으로 변화시키고 있습니다. 페이스북, 트위터, 인스타그램과 같은 플랫폼의 등장은 정치 메시지 전달을 민주화하며 후보자들이 전 세계 수백만 유권자와 직접 소통할 수 있게 해주었습니다. 이 기사는 소셜 미디어가 현대 선거의 역동성에 미치는 혁신적인 영향에 대해 다루며 후보 브랜딩, 유권자 동원, 정치 담론의 보급에 대해 탐구합니다.\n\n![social media image](/assets/img/2024-05-12-ThePowerofDigitalCampaigningHowSocialMediaIsShapingModernElections_0.png)\n\n후보자 이야기 확대:\n\n- 소셜 미디어 플랫폼은 후보자들에게 전례없는 영향력과 시야를 제공하여 그들이 자신의 브랜드를 육성하고 메시지를 유권자에게 직접 전달할 수 있게 합니다.\n- 신중하게 선정된 게시물, 비디오, 라이브 스트림을 통해 후보자들은 캠페인을 개인화하여 개인적인 일화를 공유하고 지지자들과 개인적인 수준에서 소통할 수 있습니다.\n- 소셜 미디어의 상호작용적 성격은 접근성과 신뢰성을 유도하여 후보자들이 전통적인 미디어 관문을 우회하고 실시간으로 유권자들과 연결할 수 있게 합니다.\n\n\n\n지정된 아웃리치와 마이크로 타겼팅:\n\n- 소셜 미디어 광고의 가장 강력한 기능 중 하나는 특정 인구통계를 정밀하게 대상으로 하는 능력입니다.\n- 캠페인은 데이터 분석을 활용하여 나이, 위치, 관심사 등을 기반으로 주요 유권자 세그먼트를 식별하고, 메시지를 다양한 관객들과 공감하게 만들 수 있습니다.\n- 마이크로 타겟팅을 통해 캠페인은 흔들리는 유권자, 미정당자 또는 특정 관심 그룹에 집중함으로써 격렬하게 경합하는 선거에서 저작비를 극대화할 수 있습니다.\n\n디지털 유권자 기반 동원:\n\n- 소셜 미디어 플랫폼은 정치 활동가와 기반 조직 운동을 위한 가상 타운홀, 집결 지점 및 조직 허브로 기능합니다.\n- 캠페인은 소셜 네트워크의 힘을 활용하여 지지자를 동원하고, 자원 봉사 노력을 조정하고, 선거 날 투표율을 증가시킬 수 있습니다.\n- 개인 간 공유와 소셜 인증은 캠페인 메시지의 확산을 촉진하며, 지지자들이 자신이 선택한 후보자나 원인을 옹호하는 대변인이 되도록 격려합니다.\n\n\n\n바이러스성 콘텐츠와 메메틱 전쟁의 영향:\n\n- 메멘토, 바이러스성 동영상 및 사용자 생성 콘텐츠는 디지털 캠페인의 강력한 무기가 되었습니다.\n- 메멘토는 복잡한 정치 문제를 공유 가능하고 쉽게 소화할 수 있는 형식으로 담아내어 소셜 미디어 플랫폼 전체에 불길처럼 퍼져갑니다.\n- 그러나 소셜 미디어의 바이러스성은 오도와 거짓 정보 캠페인이 혼란을 야기하고 선거 과정에서 대중들의 신뢰를 흔드는 도전 과제를 제시합니다.\n\n<img src=\"/assets/img/2024-05-12-ThePowerofDigitalCampaigningHowSocialMediaIsShapingModernElections_1.png\" />\n\n결론: 소셜 미디어는 정치 캠페인이 진행되는 방식을 변형시켰으며, 디지털 민주주의의 새로운 시대를 열었습니다. 후보자 이야기를 확대하고 유권자 기반을 동원하며 공공 토론을 형성하는 것부터 시작해, 현대 선거에서 소셜 미디어의 힘은 널리 알려져 있습니다. 그러나 이러한 힘에는 책임이 수반되며, 이에 따라 이해당사자들은 디지털 캠페인이 제기하는 윤리적 및 규제적 도전 과제에 대처하기 위해 협력해야 하며, 민주적 프로세스의 품위와 공정성을 지키며 차세대를 위해 보호해야 합니다.","ogImage":{"url":"/assets/img/2024-05-12-ThePowerofDigitalCampaigningHowSocialMediaIsShapingModernElections_0.png"},"coverImage":"/assets/img/2024-05-12-ThePowerofDigitalCampaigningHowSocialMediaIsShapingModernElections_0.png","tag":["Tech"],"readingTime":2},{"title":"React 스킬을 향상시키는 방법 Promises","description":"","date":"2024-05-12 19:50","slug":"2024-05-12-LevelUpYourReactSkillswithPromises","content":"\n\n<img src=\"/assets/img/2024-05-12-LevelUpYourReactSkillswithPromises_0.png\" />\n\nReact에서 Promise은 JavaScript의 기능 중 하나로 사용되는 비동기 작업을 처리하는 데 사용됩니다. Promise는 작업이 완료될 때 무엇을 할지 나타내는 객체입니다. 네트워크 요청, 파일 로드 및 데이터베이스 쿼리와 같은 비동기 작업을 처리하는 데 일반적으로 사용됩니다.\n\nReact에서 Promise은 일반적으로 데이터를 가져오거나 수정할 때 사용됩니다. 예를 들어, API 요청을 보내고 응답을 기다릴 때 Promise를 사용하여 데이터를 비동기적으로 가져옵니다.\n\nReact에서 Promise는 비동기 작업의 결과를 처리하고 상태를 업데이트하거나 UI를 업데이트하는 데 사용됩니다. 일반적으로 fetch() 함수를 사용하여 API 요청을 보내고 Promise를 사용하여 응답을 처리합니다.\n\n\n\n예를 들어, React에서 데이터를 가져오기 위해 Promise를 사용하는 간단한 예제가 다음과 같습니다:\n\n```js\nfetch('https://api.example.com/data')\n  .then(response => response.json()) // Promise를 사용하여 응답을 JSON 형식으로 파싱\n  .then(data => {\n    // 파싱된 데이터를 처리하거나 상태를 업데이트하는 작업 수행\n    console.log(data);\n  })\n  .catch(error => {\n    // 에러 처리\n    console.error('데이터를 불러오는 중 오류가 발생했습니다:', error);\n  });\n```\n\n이 예제에서, fetch() 함수를 사용하여 API에서 데이터를 가져옵니다. 이 함수는 Promise를 반환하며, 데이터가 성공적으로 가져와지면 .then() 메서드를 사용하여 응답을 처리합니다. 에러가 발생하면 .catch() 메서드를 사용하여 에러를 처리합니다.\n\n그렇다면 비동기 작업이 필요한 이유는 무엇일까요? 비동기 작업이 필요한 주요 이유는 주로 다음과 같습니다:\n\n\n\n- 성능 개선: 비동기 작업을 사용하여 여러 작업을 동시에 처리함으로써 전체 성능을 향상시킬 수 있습니다. 특히 네트워크 요청이나 파일 로딩과 같은 I/O 작업에서 비동기 작업을 사용하면 응답 대기 시간을 줄일 수 있습니다.\n- 향상된 사용자 경험: 비동기 작업은 사용자 인터페이스를 더 반응적이고 빠르게 만듭니다. 예를 들어 데이터를 비동기적으로 가져와 웹 페이지에 표시할 때 페이지의 로딩 시간이 줄어들어 사용자가 더 빨리 상호 작용할 수 있습니다.\n- 자원 관리: 비동기 작업은 효율적인 자원 관리를 가능하게 합니다. 특히 멀티스레딩을 통해 여러 작업을 동시에 처리하고 자원을 효율적으로 활용할 수 있습니다.\n\n비동기 작업과 비교해 동기 작업은 한 번에 하나의 작업만 처리하고 다른 작업이 완료될 때까지 기다립니다. 동기 작업을 사용하면 성능이 저하되고 사용자 경험이 줄어들 수 있습니다. 왜냐하면 작업이 순차적으로 실행되기 때문입니다. 또한, 동기 작업에서 하나의 작업이 느리게 실행되면 다른 작업이 기다려야 하므로 시스템 전체 효율성이 감소합니다.\n\n동기 작업 예시:\n\n```js\nfunction syncTask() {\n  console.log(\"동기 작업 시작\");\n  console.log(\"동기 작업 진행 중...\");\n  console.log(\"동기 작업 완료\");\n}\n\nconsole.log(\"프로그램 시작\");\nsyncTask();\nconsole.log(\"프로그램 종료\");\n```\n\n\n\n이 코드에서 syncTask() 함수는 동기적으로 실행되며, 해당 함수의 작업이 완료될 때까지 이후의 코드가 진행되지 않습니다. 그래서 출력은 다음과 같습니다:\n\n```js\n프로그램 시작\n동기 작업 시작\n진행 중인 동기 작업...\n동기 작업 완료\n프로그램 종료\n```\n\n비동기 작업 예제:\n\n```js\nfunction asyncTask() {\n  console.log(\"비동기 작업 시작\");\n  setTimeout(() => {\n    console.log(\"비동기 작업 완료\");\n  }, 2000); // 2초 후 완료 메시지 출력\n}\n\nconsole.log(\"프로그램 시작\");\nasyncTask();\nconsole.log(\"프로그램 종료\");\n```\n\n\n\n이 코드에서는 asyncTask() 함수가 비동기적으로 실행되며 setTimeout() 함수를 사용하여 2초 후에 완료 메시지가 출력됩니다. 따라서 출력은 다음과 같습니다:\n\n```js\n프로그램 시작\n비동기 작업 시작\n프로그램 종료\n비동기 작업 완료 // 2초 후에 출력됨\n```\n\n이제 React에서 사용되는 예제를 살펴보겠습니다.\n\nReact에서 비동기 작업을 처리하는 일반적인 방법은 useState 및 useEffect 훅을 사용하여 상태를 관리하고 비동기 작업을 처리하는 함수를 호출하는 것입니다. API에서 데이터를 가져와 화면에 표시하는 시나리오를 고려해 봅시다.\n\n\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nfunction App() {\n  // 상태 초기화\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  // useEffect를 사용하여 컴포넌트가 마운트될 때 데이터를 가져옵니다\n  useEffect(() => {\n    // 비동기 작업 시작\n    fetchData()\n      .then(response => {\n        // 데이터를 가져오는 데 성공하면 상태 업데이트\n        setData(response);\n        setLoading(false);\n      })\n      .catch(error => {\n        // 데이터를 가져오는 데 실패하면 에러 처리\n        console.error('데이터 가져오기 오류:', error);\n        setLoading(false);\n      });\n  }, []); // 컴포넌트가 마운트될 때 useEffect가 한 번만 실행되도록 빈 배열을 전달\n\n  // 데이터를 가져오는 비동기 함수\n  const fetchData = async () => {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    return data;\n  };\n\n  return (\n    <div>\n      <h1>React 비동기 작업 예제</h1>\n      {loading ? (\n        <p>Loading...</p>\n      ) : (\n        <div>\n          <h2>데이터:</h2>\n          <pre>{JSON.stringify(data, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n```\n\n위 코드에서 useEffect 훅을 사용하여 컴포넌트가 마운트될 때 한 번 데이터를 가져오도록 합니다. fetchData 함수를 사용하여 API에서 데이터를 가져옵니다. 데이터를 가져오는 동안 로딩 상태를 true로 설정하여 로딩 메시지를 표시합니다. 데이터 가져오기가 성공하면 데이터 상태를 업데이트합니다. 데이터 가져오기 중에 오류가 발생하면 오류를 적절히 처리합니다.\n\nReact가 비동기 작업을 효과적으로 처리하는 방법입니다.```","ogImage":{"url":"/assets/img/2024-05-12-LevelUpYourReactSkillswithPromises_0.png"},"coverImage":"/assets/img/2024-05-12-LevelUpYourReactSkillswithPromises_0.png","tag":["Tech"],"readingTime":4},{"title":"React를 사용하여 간단한 로그인 및 가입 페이지 만들기","description":"","date":"2024-05-12 19:49","slug":"2024-05-12-BuildingaSimpleLoginandSignupwithReact","content":"\n\n이 블로그 포스트에서는 React를 더 깊게 다루며, 웹 애플리케이션을 위한 기본적인 로그인 및 회원가입 기능을 만드는 방법을 보여드릴 거에요. 이것들은 대부분의 웹 애플리케이션에 필수적인 기능이에요.\n\n시작하기 전에, 이전 블로그 포스트에서 언급된 설정을 완료했는지 확인해 주세요. Node.js를 설치하고 React 프로젝트를 생성하지 않았다면, 이전 포스트의 “시작하기\" 섹션을 참고해 주세요.\n\nReact의 컴포넌트 기반 구조, 상태 관리, 그리고 클라이언트 사이드 라우팅을 활용하여 로그인 및 회원가입 기능을 구현하는 방법을 알아보겠습니다.\n\n## 단계 1.\n\n\n\n프로젝트 설정하기\n터미널이나 명령 프롬프트를 열고 로그인 및 가입 앱을 생성할 디렉토리로 이동하세요. 다음 명령어를 실행하여 새로운 React 프로젝트를 생성합니다.\n\n```js\n$ npx create-react-app login-signup-app\n$ cd login-signup-app\n$ npm start\n```\n\n## 단계 2.\n\n프로젝트 구조\n생성된 React 프로젝트에는 필수 파일과 폴더가 미리 정의된 구조로 포함되어 있습니다. 우리 앱에서 주로 작업할 파일은 src/App.js 및 src/App.css 파일입니다. 또한 로그인 및 가입에 필요한 파일을 만들기 위해 components 폴더를 src에 생성합니다.\n\n\n\n## 단계 3.\n\nsrc/components 폴더에 로그인 및 가입 컴포넌트 만들기 새로운 두 개의 파일을 만드세요:\n\n3-1. Login.js 컴포넌트\n\nLogin.js는 로그인 폼과 인증을 관리합니다. useState 훅을 사용하여 상태 변수인 이메일과 비밀번호를 생성합니다. handleLogin 함수는 폼 제출 시 트리거되며 입력된 이메일과 비밀번호를 기록합니다.\n\n\n\n![이미지](/assets/img/2024-05-12-BuildingaSimpleLoginandSignupwithReact_0.png)\n\n3-2. Signup.js 컴포넌트\n\nSignup.js는 사용자 등록을 위한 Login.js와 유사합니다. useState 훅을 사용하여 상태 변수 이메일, 비밀번호, 확인 비밀번호를 관리합니다. handleSignup 함수는 등록 로직을 처리하며, 폼 제출 시 트리거됩니다.\n\n![이미지](/assets/img/2024-05-12-BuildingaSimpleLoginandSignupwithReact_1.png)\n\n\n\n## 단계 4.\n\nReact Router를 사용하여 클라이언트 사이드 라우팅을 설정하세요.\n\n- React Router 설치하기:\n\n```js\n$ npm install react-router-dom\n```\n\n\n\n이제 src/App.js를 업데이트해주세요\n\n![Building a Simple Login and Signup with React](/assets/img/2024-01-12-BuildingaSimpleLoginandSignupwithReact_2.png)\n\n## 단계 5.\n\n앱 스타일링하기 src/App.css에서 앱을 시각적으로 매력적으로 만들기 위해 기본 스타일을 추가하세요:\n\n\n\n<img src=\"/assets/img/2024-05-12-BuildingaSimpleLoginandSignupwithReact_3.png\" />\n\n## 단계 6.\n\n앱 테스트 변경 사항을 저장하고 개발 서버가 실행 중인지 확인하세요. 웹 브라우저를 열고 http://localhost:3000으로 이동합니다.\n\n<img src=\"/assets/img/2024-05-12-BuildingaSimpleLoginandSignupwithReact_4.png\" />\n\n\n\n![이미지](/assets/img/2024-05-12-BuildingaSimpleLoginandSignupwithReact_5.png)\n\n먼저 로그인 양식을 볼 수 있어야 하며, 네비게이션에서 “가입\" 링크를 클릭하면 회원 가입 양식으로 이동됩니다.\n\n# 결론\n\n이 블로그 포스트에서 React를 사용하여 간단한 로그인 및 회원 가입 기능을 구현하는 방법을 보여주었습니다. React Router를 사용하여 이러한 페이지 간에 쉽게 전환할 수 있습니다. 이 데모는 기본 구현이지만, 데이터 지속성, 유효성 검사 및 현실적인 사용자 인증과 같은 추가 기능을 추가하여 확장할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-BuildingaSimpleLoginandSignupwithReact_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaSimpleLoginandSignupwithReact_0.png","tag":["Tech"],"readingTime":3}],"page":"57","totalPageCount":71,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}