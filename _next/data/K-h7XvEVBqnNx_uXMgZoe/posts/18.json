{"pageProps":{"posts":[{"title":"데이터 과학을 위한 도커의 직관적인 안내","description":"","date":"2024-05-15 02:49","slug":"2024-05-15-AnIntuitiveGuidetoDockerforDataScience","content":"\n\n```md\n![An Intuitive Guide to Docker for Data Science](/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_0.png)\n\n데이터 과학자로 일할 때, 모든 운영 체제에서 실행되고 필요한 종속성이 모두 갖춰진 코드를 작성하고 클라우드에 배포할 수 있어야 합니다. 노력에도 불구하고 작동하지 않을 수 있고 문제가 무엇인지 이해하는 데 시간을 낭비할 수도 있습니다.\n\n이 고통을 피하기 위해 어떤 도구를 사용할 수 있을까요? Docker가 여러분의 문제를 해결해 줄 것입니다. Docker를 사용하면 데이터 과학 프로젝트를 위한 견고한 환경을 손쉽게 얻을 수 있습니다. 미치도록 미쳐버리지 않고요.\n\n이 글에서는 Docker의 주요 개념, 가장 일반적인 명령어, 그리고 Docker화된 머신러닝 애플리케이션의 빠른 예제에 대해 설명하겠습니다. 시작해 봅시다!\n```\n\n\n\n목차:\n\n- Docker란 무엇인가?\n- Docker의 기본 개념\n- 가상 머신 대 컨테이너\n- Docker 설정\n- ML 애플리케이션 도커화\n- Docker 명령어 요약\n- Docker의 한계\n\n## Docker란 무엇인가?\n\nDocker는 매우 인기 있는 가상화 기술로, 개발자가 몇 분 내에 머신러닝 애플리케이션을 신속하게 개발, 실행 및 배포할 수 있도록 합니다.\n\n\n\n표 태그를 Markdown 형식으로 변경할 수 있습니다.\n\nContainers를 통해 응용 프로그램을 빠르고 일관된 방식으로 실행할 수 있는 격리된 환경을 포함할 수 있습니다.\n\n이 플랫폼을 사용하면 인프라와 응용 프로그램을 동시에 관리할 수 있습니다. 또한 코드를 작성하고 배포하는 시간을 줄일 수 있습니다.\n\n## Docker의 기본 개념\n\n![Docker 이미지](/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_1.png)\n\n\n\n더 진행하기 전에, Docker와 관련된 세 가지 개념을 잘 알고 가는 것이 중요합니다:\n\n- Docker File에는 Docker Image를 빌드하는 데 사용되는 지시 사항이 포함되어 있습니다. 운영 체제를 정의하거나 애플리케이션의 종속성을 지정하는 등의 작업이 이루어집니다.\n- Docker Image는 Docker File에서 시작하여 빌드할 때 만들어집니다.\n- Docker Container는 Docker Image를 실행한 후에 얻어집니다. 어디에서든 실행할 수 있는 격리된 독립 환경입니다.\n\n위 그림을 살펴보면 개념을 더 잘 이해할 수 있습니다. Docker File은 케이크 레시피와 유사한 개념이며, 우리가 관심을 갖는 대상의 재료가 정의되어 있습니다. Docker Image는 반죽이고 Docker Container는 우리가 원하는 케이크입니다.\n\n## 가상 머신 대 컨테이너\n\n\n\n\n![Docker Image](/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_2.png)\n\n가상 머신과 컨테이너는 물리적 인프라 내에서 여러 격리된 환경을 실행할 수 있게 해주는 가상화 기술입니다. 둘 다 리소스와 비용을 최적화하기 위해 고안되었지만, 중요한 차이점이 있습니다.\n\n가상 머신 내에는 각각 다른 게스트 운영 체제가 실행됩니다. 그에 비해 컨테이너는 호스트 운영 체제를 공유하여 가상 머신보다 적은 리소스를 사용합니다.\n\n컨테이너는 애플리케이션과 해당 의존성만 캡슐화하기 때문에 매우 휴대성이 뛰어나며 배포 프로세스를 더 쉽고 빠르게 만들어줍니다.\n\n\n\n\n## Docker 설정하기\n\n![Docker Desktop](/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_3.png)\n\nDocker Desktop은 컨테이너화된 응용 프로그램을 빌드하고 공유하며 실행하는 데 필요한 응용 프로그램입니다. Linux, Windows 또는 Mac에 설치할 수 있습니다.\n\nDocker Hub에 이미지를 만들고 푸시하려면 Docker Hub에 계정을 만들어야 합니다. Docker Hub는 Docker 이미지를 찾고 공유할 수 있는 중앙 저장소입니다.\n\n\n\n## ML 애플리케이션 도커화하기\n\n도커의 개념을 익히셨다면, 이제 머신 러닝 애플리케이션을 도커화하는 예제를 보여드릴 시간입니다. 튜토리얼을 쉽게 따라가기 위해 Visual Studio Code를 코드 편집기로 사용하는 것을 권장합니다.\n\n이 미니 프로젝트에서는 캐글(Kaggle)의 Tours and Travels Churn Prediction 데이터셋을 사용할 것입니다. 따라서 여행 회사의 고객이 연령, 연간 서비스 등 여러 변수를 기반으로 이탈할지 여부를 예측하는 작업을 진행하겠습니다.\n\n튜토리얼을 더 잘 따라가기 위해 GitHub 저장소를 확인해보세요.\n\n\n\n\n고객 이탈 예측 데이터셋을 로드합니다.\n```Python\nchurn_df = pd.read_csv('Customertravel.csv')\nX = churn_df.drop(columns=['Target'],axis=1)\ny = churn_df['Target']\n\n# 데이터 분할\nX_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=123)\nX_train, X_val, y_train, y_val = train_test_split(X_train,y_train,test_size=0.2,random_state=123)\ntrain_data = Pool(data=X_train,label=y_train,cat_features=[1,2,4,5])\nval_data = Pool(data=X_val,label=y_val,cat_features=[1,2,4,5])\ntest_data = Pool(data=X_test,label=y_test,cat_features=[1,2,4,5])\n\n# CatBoost 모델 훈련\nmodel = CatBoostClassifier(n_estimators=500,\n                           learning_rate=0.1,\n                           depth=4,\n                           loss_function='Logloss',\n                           random_seed=123,\n                           verbose=True)\nmodel.fit(train_data,eval_set=val_data)\n\n# 예측 생성\ny_train_pred = model.predict(train_data)\ny_val_pred = model.predict(val_data)\ny_test_pred = model.predict(test_data)\n\n# 정밀도와 재현율 계산\ntrain_precision_score = precision_score(y_train, y_train_pred)\ntrain_recall_score = recall_score(y_train, y_train_pred)\nval_precision_score = precision_score(y_val, y_val_pred)\nval_recall_score = recall_score(y_val, y_val_pred)\ntest_precision_score = precision_score(y_test, y_test_pred)\ntest_recall_score = recall_score(y_test, y_test_pred)\n\n# 정밀도와 재현율 출력\nprint(f'Train 정밀도: {train_precision_score}')\nprint(f'Val 정밀도: {val_precision_score}')\nprint(f'Test 정밀도: {test_precision_score}')\nprint(f'Train 재현율: {train_recall_score}')\nprint(f'Val 재현율: {val_recall_score}')\nprint(f'Test 재현율: {test_recall_score}')\n```\n\n\n\n- requirements.txt 파일 생성\n\n저희 애플리케이션을 도커로 쉽게 사용하기 위해 모든 파이썬 의존성이 포함된 requirements.txt 파일이 필요합니다.\n\n라이브러리 pigar을 설치하고 터미널에서 pigar generate 명령을 실행하여 자동으로 생성할 수 있습니다.\n\n다음과 같은 파일을 얻어야 합니다:\n\n\n\n\ncatboost==1.2.5\npandas==2.2.2\nscikit-learn==1.4.2\n\n\n2. Create Dockerfile\n\nAlong with requirements.txt, let's create a file called Dockerfile. This file consists of instructions for building the Docker Image.\n\n```Dockerfile\nFROM python:3.10\n\nWORKDIR /src\n\n# Copy the requirements file and install dependencies\nCOPY train_churn_model.py requirements.txt Customertravel.csv /src/\nRUN pip install --no-cache-dir -r requirements.txt \n\n# Run the script\nCMD [\"python\",\"train_churn_model.py\"]\n```\n\n\n\nFROM 명령은 프로젝트에 사용되는 기본 환경을 지정합니다. 이 경우 Python 3.10이었습니다.\n\n작업 디렉토리를 설정하고 requirements.txt, train_churn_model.py 그리고 Customertravel.csv 파일을 복사한 후 requirements.txt 파일을 복사하면 종속성을 설치할 수 있습니다.\n\n마지막으로 CMD 명령을 사용하여 스크립트를 실행하는 명령을 포함할 수 있습니다.\n\n3. 도커 이미지 빌드\n\n\n\n파일 requirements.txt와 Dockerfile을 생성했다면, 대부분의 작업이 끝났어요. Docker 이미지를 생성하기 위해서는 빌드 명령어를 사용하기만 하면 돼요:\n\n```js\ndocker build -t churn-pred-image .\n```\n\n\"churn-pred-image\"라는 이름으로 Docker 이미지를 생성한 후에는 모든 이미지를 확인해 보세요. 우리가 이미지를 성공적으로 만들었는지 확인하는 것이 중요하니까요.\n\n```js\ndocker images\n```\n\n\n\n다음은 명령어에서 얻은 이미지 목록입니다:\n\n```js\nREPOSITORY         TAG       IMAGE ID       CREATED             SIZE\nchurn-pred-image   latest    f2d735527110   About an hour ago   1.81GB\n```\n\n다른 이미지를 만든 경우 테이블에 더 많은 행이 포함될 것이며, 각각 다른 이미지에 해당합니다.\n\n4. Docker 컨테이너를 빌드하세요.\n\n\n\n드디어, Docker 컨테이너를 만들 준비가 되었습니다. 이미지를 빌드했으므로 이제 컨테이너를 실행하기만 하면 됩니다:\n\n```js\ndocker run -d --name churn-pred-container churn-pred-image\n```\n\n--name 태그에서는 Docker 컨테이너의 이름을 지정하고, 뒤에 이전에 빌드한 Docker 이미지의 이름을 적어주면 됩니다.\n\n이전처럼 flag -a를 사용하여 지금까지 생성된 모든 컨테이너를 표시하려면:\n\n\n\n```js\n도커 ps -a\n```\n\n요 출력입니다:\n\n```js\nCONTAINER ID   IMAGE              COMMAND                  CREATED             STATUS                      PORTS     NAMES\n7865084c8e70   churn-pred-image   \"python train_churn_…\"   약 한 시간 전        Exited (0) 17 minutes ago             churn-pred-container\n```\n\n그게 다야! 머신러닝 애플리케이션을 도커화했어요!\n\n\n\n## 도커 명령어 요약\n\n- 도커 이미지를 빌드하려면 docker build -t `내-이미지-이름`을 사용하세요.\n- 도커 컨테이너를 빌드하려면 docker run -d --name `내-컨테이너-이름` `내-이미지-이름`을 사용하세요.\n- 생성된 이미지 목록을 확인하려면 docker images를 사용하세요.\n- 컨테이너 목록을 보려면 docker ps -a를 사용하세요.\n- 이미지를 제거하려면 docker rmi `내-이미지-id`를 사용하세요.\n- 실행 중인 컨테이너를 중지하려면 docker stop `내-컨테이너-id`를 사용하세요.\n- 중지된 컨테이너를 제거하려면 docker rm `내-컨테이너-id`를 사용하세요.\n\n## 도커의 한계\n\n다른 가상화 기술과 마찬가지로 도커에도 일부 제약이 있습니다. 이는 주요 단점으로서 다음과 같습니다:\n\n\n\n- 도커 파일을 작성하고 이미지를 빌드하며 컨테이너를 관리하는 방법을 처음 접하는 경우에는 시간이 필요할 수 있어요.\n- 컨테이너는 VM보다 가벼우며 더 적은 리소스가 필요하지만, 동일한 운영 체제로 인해 보안 문제가 발생할 수 있어요.\n- 도커는 GPU가 필요하지 않은 응용 프로그램을 위해 초기에 설계되었기 때문에 그래픽 사용자 인터페이스가 필요한 사용 사례에서 어려움을 겪을 수 있어요.\n\n## 마무리\n\n이것은 도커를 시작하는 데 도움이 될 수 있는 입문 가이드였어요.\n\n도커는 데이터 과학 프로젝트에 강력한 도구가 될 수 있어요. 특정 사용 사례에 도커가 적합한 선택인지 고려하기 위해서는 장단점을 고려하는 것이 중요해요.\n\n\n\n만약 주제를 더 자세히 알아보고 싶다면, 기사 끝에 나열된 자료들을 살펴보세요.\n\n기사가 유용했다면 좋겠습니다. 즐거운 하루 되세요!\n\n면책 조항: 이 데이터셋은 CC0 1.0 Universal (CC0)로 라이센스가 부여되어 있습니다.\n\n유용한 자료:\n\n\n\n- 도커 가이드\n- 도커파일 참조\n- 도커 CLI를 위한 기본 명령어","ogImage":{"url":"/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_0.png"},"coverImage":"/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_0.png","tag":["Tech"],"readingTime":8},{"title":"서버 감시 마스터하기 Socketio를 사용하여 온라인 장치 추적하기","description":"","date":"2024-05-15 02:47","slug":"2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio","content":"\n\n<img src=\"/assets/img/2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio_0.png\" />\n\n서버에 연결된 디바이스의 정확한 수를 파악하는 것은 오늘날의 네트워크화된 디지털 환경에서 효율성, 보안 및 전반적인 성능을 유지하는 데 중요합니다. 귀하가 거대한 네트워크 인프라나 소규모 웹 사이트를 담당하고 있든 상관없이 온라인 환경의 동력을 파악하는 것이 모든 차이를 만들 수 있습니다. 다행히도 Socket.io라는 실시간 웹 애플리케이션 엔진을 통해 디지털 풍경에 대한 중요한 정보를 제공받을 수 있습니다. 이 게시물에서는 Socket.io를 사용하여 서버에 연결된 온라인 디바이스를 모니터링하는 방법에 대해 자세히 살펴보며 초보자와 숙련된 개발자 모두에게 포괄적인 설명서를 제공할 것입니다.\n\n서버에 연결된 인터넷 디바이스를 모니터링하기 위해 Socket.io의 기능을 활용하는 첫 번째 단계는 Node.js 프로젝트를 설정하는 것입니다. 다음 간단한 단계를 따라 프로젝트를 시작하세요:\n\n- Node.js 설치: 아직 설치하지 않은 경우 공식 웹 사이트에서 Node.js를 다운로드하고 설치하세요. Node.js에는 프로젝트 의존성 관리에 사용할 npm(Node Package Manager)이 함께 제공됩니다.\n- 프로젝트 디렉토리 생성: 파일 시스템에서 적절한 위치를 선택하고 프로젝트용 새 디렉토리를 만드세요. 명령줄을 사용하여 mkdir 명령 다음에 선택한 디렉토리 이름을 입력하여 이 작업을 수행할 수 있습니다.\n\n\n\n```bash\nmkdir socketio\n```\n\n3. 프로젝트 디렉토리로 이동: cd 명령어를 사용하여 새로 생성한 프로젝트 디렉토리로 이동합니다.\n\n```bash\ncd socketio\n```\n\n4. Node.js 프로젝트 초기화: npm init 명령어를 사용하여 새로운 package.json 파일을 생성합니다. 이 파일은 프로젝트 및 의존성에 대한 메타데이터를 저장하게 됩니다. 프로젝트 이름, 버전, 설명 등의 세부 정보를 입력하도록 프롬프트에 따라 진행하며, 대부분의 경우 기본값을 사용하기 위해 Enter 키를 누를 수 있습니다.```\n\n\n\n\n1. npm으로 초기화하세요.\n   \n   ```js\n   npm init\n   ```\n\n2. 필요한 패키지 설치: 이제 프로젝트에 필요한 패키지를 설치해봅시다. 웹 서버를 만들기 위해 express와 실시간 통신을 위해 socket.io가 필요합니다.\n\n   ```js\n   npm install express socket.io http\n   ```\n\n3. 프로젝트 파일 생성: 주로 index.js와 같이 이름 지어지는 주 서버 파일을 만들고, 서버 설정 및 Socket.io 연결을 처리할 코드를 작성하세요.\n\n\n\n\n```js\nconst express = require(\"express\");\nconst socketIO = require(\"socket.io\");\nconst server = require(\"http\").createServer(app);\nconst PORT = process.env.PORT || 3001;\nconst io = socketIO(server, {\n  cors: {\n    origin: \"*\",\n    methods: \"GET\", \"POST,\"\n  },\n});\nlet userCount = 0;\nio.on(\"connection\", (socket) => {\n  userCount++;\n  io.emit(\"userCount\", userCount);\n\n  socket.on(\"disconnect\", () => {\n    userCount--;\n    io.emit(\"userCount\", userCount);\n  });\n});\nserver.listen(PORT, () => {\n  console.log(\"Server is running on port \" + PORT);\n});\n```\n\n**Node.js 서버 시작하기:** 메인 서버 파일을 node 명령어를 사용하여 실행하여 Node.js 서버를 시작합니다.\n\n```js\nnode index.js\n```\n\n**서버 출력 확인:** 서버가 부팅되면 지정된 포트에서 영역화되고 작동 중임을 나타내는 출력을 확인해야 합니다. 서버가 구성된 방식에 따라, 여기에서는 \"서버가 3001 포트에서 청취 중입니다\" 라는 메시지가 표시됩니다.\n\n\n\n\n소켓 이벤트를 수신하고 실시간으로 연결된 사용자 수를 파악할 수 있어요.\n\n방법 1: 웹페이지에서\n\nHTML 템플릿 생성하기\n\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>실시간 사용자 수</title>\n    <style>\n      body {\n        font-family: Arial, sans-serif;\n        text-align: center;\n        padding-top: 50px;\n      }\n      #userCount {\n        font-size: 48px;\n        font-weight: bold;\n        color: #333;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>연결된 사용자 수</h1>\n    <div id=\"userCount\"></div>\n    <script src=\"https://cdn.socket.io/4.4.1/socket.io.min.js\"></script>\n    <script>\n      const socket = io(\"http://localhost:3001\");\n      socket.on(\"connect\", () => {\n        console.log(\"Socket.IO 서버에 연결되었습니다\");\n      });\n      socket.on(\"userCount\", (count) => {\n        document.getElementById(\"userCount\").textContent = count;\n      });\n    </script>\n  </body>\n</html>\n```\n\n\n\n우리는 이전에 HTML에서 시작한 서버에 연결 중이며, 연결할 때마다 서버는 \"userCount\"라는 이름의 이벤트를 생성하여 해당 서버에 연결된 사용자에 대한 정보를 포함합니다.\n\n방법 2: NodeJs 사용\n\n```js\nconst io = require(\"socket.io-client\");\nconst socket = io(\"http://localhost:3001\");\nsocket.on(\"connect\", () => {\n    console.log(\"Socket.IO 서버에 연결되었습니다\");\n});\nsocket.on(\"userCount\", (count) => {\n    console.log(\"연결된 사용자 수:\", count);\n});\n```\n\n요약하자면, Socket.io와 Node.js는 실시간 사용자 모니터링을 가능하게 함으로 효과적으로 작동합니다. Socket.io를 Node.js 환경에 통합함으로써 개발자는 쉽게 사용자 행동과 서버 성능을 모니터링할 수 있습니다. 이는 예방적인 서버 자원 관리를 가능하게 하여 완벽한 사용자 경험을 보장합니다. Socket.io의 중요한 사용자 연결에 대한 통찰력을 활용함으로써 개발자는 확장 가능하고 반응성 있는 응용프로그램을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio_0.png"},"coverImage":"/assets/img/2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio_0.png","tag":["Tech"],"readingTime":4},{"title":"클라이언트 측 로직 간소화 뷰 모델의 전략적 활용","description":"","date":"2024-05-15 02:45","slug":"2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels","content":"\n\n\n![User View Model](/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png)\n\n애플리케이션은 종종 서버에서 직접 사용 가능한 데이터 표현과는 다른 데이터 표현이 필요합니다. 예를 들어 사용자 객체에는 열거형 역할, 열거형 상태, 이름 등의 속성이 포함될 수 있습니다. 클라이언트 측 뷰에서 이러한 서버 측 모델을 직접 사용하면 종종 UI 로직 전체에 분산된 복잡한 변환을 유발합니다.\n\n이 문제를 해결하기 위해 각 엔티티에 대한 뷰 모델 클래스를 생성하는 것을 주장합니다. 이 캡슐화는 데이터 처리를 간단하게 만들어주며 UI가 필요한 것만 받도록 보장합니다. 다음은 UserVm의 간단한 실제 예시입니다:\n\n```js\nconst rolesMap = fromBeEnum(UserRoleEnum, {\n  VIEWER: '뷰어',\n  ADMIN: '관리자',\n  SIGNER: '서명자',\n  OWNER: '소유자'\n});\n\nexport class UserVm {\n  constructor(dto: User) {\n    this.displayName = dto.name || dto.email;\n    this.isActive = dto.status === UserStatusEnum.ACTIVE;\n    this.isServiceAccount = dto.type === UserTypeEnum.SERVICE_ACCOUNT;\n    this.isViewer = dto.role === UserRoleEnum.VIEWER;\n    this.isOwner = dto.role === UserRoleEnum.OWNER;\n    this.isActiveAdmin = dto.isAdmin && this.isActive;\n    this.typeLabel = dto.isServiceAccount ? '서비스 계정' : '사용자';\n    this.roleLabel = this.userRoleToLabel();\n    this.hasAddQuorum = hasQuorum(dto, 'add');\n    this.hasRemoveQuorum = hasQuorum(dto, 'remove');\n    this.isPendingApproval = this.hasAddQuorum || this.hasRemoveQuorum;\n  }\n  \n  private userRoleToLabel() {\n    return rolesMap[this.dto.role] || '알 수 없음';\n  }\n}\n```\n\n\n\ngetUser 엔드포인트에서 데이터를 받으면 UserVm 클래스를 사용하여 응답에 맞는 새 사용자 뷰 모델을 생성합니다. 이 추상화를 통해 깔끔하고 유지 관리 가능한 코드 구조를 유지할 수 있습니다.\n\n```js\nimport { injectQuery, mapResultData } from '@ngneat/query';\n\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private query = injectQuery();\n  private client = injectApiClient();\n\n  getUser({ vaultId }) {\n    return this.query({\n      queryKey: ['user'],\n      queryFn: () => {\n        return this.client.getAuthenticatedUser({ vaultId })\n      }\n    }).result$.pipe(\n      mapResultData(user => new UserVm())\n    )\n  }\n}\n```\n\n이 원칙은 엔티티 배열을 다룰 때에도 동일하게 적용됩니다. 예를 들어, 응용 프로그램 내에서 거래가 어떻게 처리되는지 살펴보면 — UI 변환을 거치는 중요한 엔티티인 거래에 대해 어떻게 다루는지에 대해 생각해 보세요.\n\n```js\nimport { injectQuery, mapResultData } from '@ngneat/query';\n\n@Injectable({ providedIn: 'root' })\nexport class TransactionsService {\n  private query = injectQuery();\n  private client = injectApiClient();\n\n  getTransactions({ vaultId }) {\n    return this.query({\n      queryKey: ['transactions'],\n      queryFn: () => {\n        return this.client.getTransactions({ vaultId })\n      }\n    }).result$.pipe(\n      mapResultData(res => res.transactions.map(t => new TransactionVm(t)))\n    )\n  }\n}\n```\n\n\n\n# 뷰 모델 사용의 이점\n\n## 명확성과 사용자 정의\n\n백엔드 네이밍 규칙 때문에 머리를 긁는 순간들을 우리 모두 겪어봤죠 😛. 뷰 모델은 속성 이름을 바꿔 더 직관적으로 만들 수 있습니다. DTO 이름이 애매할 때, VM은 DTO를 직접 변경하지 않고 더 구체적인 이름을 사용하는 방법을 제공합니다.\n\n## 스키마 유연성\n\n\n\nVMs(Visual Models)은 백엔드 구조에 영향을 미치지 않고 DTO 스키마를 애플리케이션의 요구에 더 잘 맞게 수정할 수 있는 기회를 제공합니다. 이 유연성은 다양한 사용 케이스에 적응하는 데 중요합니다.\n\n## 중앙화된 수정\n\nDTO에 중요한 변경이 있거나 예기치 못한 수정이 필요한 경우, 조정은 뷰 모델에서만 하면 되며 애플리케이션 전체에 수정을 반영할 필요가 없습니다. 이 중앙화는 버그와 유지보수 부담을 크게 줄여줍니다.\n\n## 캡슐화\n\n\n\n변환 로직을 VM 내부로 캡슐화하면 컴포넌트 전체에서의 파이프, 유틸리티 함수 및 열거형에 대한 의존성이 줄어들어 더 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n\n## 재사용성\n\n한 번 정의된 View Model은 응용 프로그램의 다른 부분 또는 다른 프로젝트에서도 재사용할 수 있습니다. 이러한 재사용성은 개발 시간을 크게 단축하고 오류를 줄일 수 있습니다. 예를 들어, ownerVm을 사용하는 DeviceVm의 시나리오를 살펴보겠습니다:\n\n```js\nexport class DeviceVm {\n  ownerVm: UserVm;\n\n  constructor(device: Device) {\n    // ...device props\n    this.ownerVm = new UserVm(device.owner);\n  }\n}\n```\n\n\n\n이 설정을 사용하면 장치를 처리하는 애플리케이션의 어떤 부분이든 UserVm에서 사용 가능한 풍부한, 사전 처리된 데이터를 자동으로 활용할 수 있습니다.\n\nEntity 간 관련이 있는 복잡한 데이터 구조는 조합된 VM에서 크게 이점을 얻을 수 있습니다. 예를 들어, 여러 장치를 가진 사용자 시나리오는 다음과 같이 보일 수 있습니다:\n\n```js\nexport class UserWithDevicesVm extends UserVm {\n  devices: DeviceVm[];\n\n  constructor(user: User, devices: Device[]) {\n    super(user); // 기본 UserVm 초기화\n    this.devices = devices.map(device => new DeviceVm(device));\n  }\n}\n\n// 서비스에서\nimport { intersectResults$ } from '@ngneat/query';\n\ncombineLatest([\n  this.usersService.getUsers({ vaultId }),\n  this.devicesService.getDevices({ vaultId })\n]).pipe(\n  intersectResults$(([users, devices]) => {\n    const userDevices = devices.filter(...); \n    return users.map(user => new UserWithDevicesVm(user, userDevices));\n  })\n)\n```\n\n# 업데이트용 뷰 모델 복제\n\n\n\n가끔가다 VM을 업데이트해야 할 때가 있습니다. 이런 경우를 위해 원본 DTO를 보존하고 복제 방법을 구현할 수 있습니다:\n\n```js\nexport class DeviceVm {\n  \n  constructor(private dto: Device) {\n    // 장치 속성\n  }\n  \n  clone() {\n    return new DeviceVm(this.dto)\n  }\n}\n```\n\n제 애플리케이션에서는 보통 VM을 직접 업데이트하지 않습니다. 대신 성능 문제가 없는 한, @ngneat/query(내부적으로 tanstack/query를 사용)의 invalidateQueries 함수를 활용합니다. 이 방식은 서버에서 데이터를 다시 가져오고 자동으로 새 VM을 생성하여 사용자 인터페이스를 업데이트합니다.\n\n# 결론\n\n\n\n뷰 모델은 애플리케이션 데이터를 관리하기 위한 강력한 패턴으로 작용합니다. 이들은 클라이언트 측 개발을 단순화할 뿐만 아니라 애플리케이션의 유지 보수성과 확장성을 향상시킵니다. 데이터 처리 및 변환을 전용 클래스로 추상화함으로써, 개발자들은 견고하고 사용자 친화적인 인터페이스를 구축하는 데 집중할 수 있습니다.\n\nAngular 및 JS에 대해 더 알아보려면 Medium 또는 Twitter에서 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png"},"coverImage":"/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png","tag":["Tech"],"readingTime":5},{"title":"API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터","description":"","date":"2024-05-15 02:43","slug":"2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters","content":"\n\n이 글에서는 개발자가 API의 성능을 향상시키기 위해 사용할 수 있는 최적화 시리즈를 탐색해 보겠습니다. API를 디자인할 때 최적의 성능을 확보하는 것이 중요합니다. 그러나 때로는 사용 가능한 도구를 효과적으로 활용하지 못하거나, 충분한 정보가 없어 판단을 내리기 어려울 수 있습니다.\n\n일반적인 시나리오를 살펴보겠습니다: 데이터베이스에서 카테고리 및 해당 카테고리에 속한 제품을 가져오는 과정입니다. 우리는 구현할 수 있는 다양한 최적화 또는 수정 단계를 따라갈 것입니다.\n\n```js\nList<Category> categories = getAllCategory();\n        \ncategories.forEach(category -> {\n    Product product = getProductByCategory(category.getId());\n    productList.add(product);\n});\n```\n\n이 코드 조각은 잘 작동하며 우리가 하려고 하는 작업을 수행합니다. 그런데 더 나은 방법이 있을까요?\n\n\n\n병렬 스트림이 도와드릴게요!!!\n\nJava는 API 성능을 향상시키기 위해 병렬 스트림을 제공하지만 효율적으로 사용하지 않으면 시스템 가속화에 도움이 되지 않을 수 있습니다. 병렬 스트림은 백그라운드 OS 스레드를 활용하여 실행하므로 스레드 컨텍스트 전환의 오버헤드를 고려하면서 효과적으로 사용하는 방법을 이해하는 것이 중요합니다.\n\n배치 처리 소개\n\n한 걸음 더 나아가서 일부 배치 처리를 사용하고 병렬 스트림을 활용하여 더욱 최적화할 수 있습니다.\n\n\n\n```java\nList<Category> categories = getAllCategory();\nList<List<Category>> partitionedCategories = Lists.partition(categories, 50);\n\npartitionedCategories.parallelStream().forEach(categoryBatch -> {\n    categoryBatch.parallelStream().forEach(category -> {\n        Product product = getProductByCategory(category.getId());\n        productList.add(product);\n    });\n});\n```\n\n파티션 함수는 원본 목록을 지정된 배치 크기를 기준으로 일괄로 나눕니다. 예를 들어, 원본 목록에 220개의 요소가 있다면 결과 목록은 크기가 `50, 50, 50, 50, 20`인 5개의 요소로 나눠질 것입니다.\n\n그리고 이제 중첩된 병렬 스트림을 사용하여 요소를 반복할 수 있습니다.\n\n다중 처리를 잘 활용한 것 같은데, 더 개선할 부분이 있을까요?\n\n\n\n데이터베이스 최적화\n\n이제 최적화된 접근법처럼 보이지만, 여전히 DB(데이터베이스)에 N번 접근하고 있습니다. 다만, 여러 스레드를 사용하여 동일한 작업을 수행하고 있을 뿐입니다.\n\n더 좋은 접근 방식은 분할된 목록을 사용하여 WHERE 절을 구성하고 여러 카테고리 ID를 전달하여 단일 데이터베이스 호출을 실행하는 것입니다.\n\n```js\ndb.getCollection('Product').find({'category_id':{$in:['categoryId1','categoryId2']}\n```\n\n\n\n```js\nBson filter = Filters.in(\"categoryId\", \"categoryId1\", \"categoryId2\");\n// 마찬가지로 필터를 사용하여 카테고리 ID를 전달할 수 있습니다.\nList<Category> categories = getAllCategory();\nList<List<Category>> partitionedCategories = Lists.partition(categories, 50);\n\npartitionedCategories.parallelStream().forEach(categoryBatch->{\n    Bson filter = Filters.in(\"categoryId\", categoryBatch);\n    List<Product> productsBatch = getProducts(filter);\n    productList.addAll(productsBatch);\n});\n```\n\nBson 필터를 사용하여 데이터 검색을 구현하면 API에 유연성을 추가할 수 있어서 클라이언트가 쿼리를 자신의 요구에 맞게 조정할 수 있습니다. 이 방식은 API의 사용성을 향상시키고 다양한 시나리오에서 유용하게 사용할 수 있도록 합니다.\n\n지금까지 한 작업을 요약해볼까요!\n\n정말 멋진 개선이군요. 일괄 검색 및 여러 스레드를 활용하면 데이터베이스 호출 수를 줄이고 병렬 처리를 효율적으로 활용하여 성능을 크게 향상시킬 수 있습니다. API의 성능에 상당한 최적화가 되었으므로 성능 상에서 뚜렷한 차이를 느낄 수 있을 겁니다.\n\n\n\n\n이 풀 리퀘스트는 정말 리뷰할 준비가 되어 있어요! 😄🚀","ogImage":{"url":"/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png"},"coverImage":"/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png","tag":["Tech"],"readingTime":3},{"title":"Nextjs 앱에 Stripe 결제 추가하는 방법","description":"","date":"2024-05-14 16:09","slug":"2024-05-14-HowtoaddStripepaymentstoyourNextjsapp","content":"\n\n<img src=\"/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png\" />\n\n와! 내 매체 암호를 찾았어요!\n\n이제, 내 첫 번째 기사에서 Stripe를 Next.js 앱에 통합하는 방법에 대해 이야기하려고 해요.\n\n이 프로젝트에서는 너무 복잡한 것을 만드는 데 주의를 기울이지 않을 거에요. 대신에 우리는 간편한 Next.js 13.4 앱을 개발하여 일회성 Stripe 결제를 가능하게 할 거에요.\n\n\n\n## 설정하기\n\n터미널을 열고 나의 경우에는 Workspace 안에서 다음 명령을 실행해 주세요.\n\n```js\nnpx create-next-app@latest\n```\n\n위 명령을 실행하면 \"create-next-app@13.4.1\"을 설치하라는 메시지가 표시되며 몇 가지 질문이 있을 겁니다.\n\n\n\n- 프로젝트 이름은 무엇인가요? stripe-nextjs\n- TypeScript를 사용하고 싶나요? 네\n- ESLint를 사용하고 싶나요? 네\n- 이 프로젝트에 Tailwind CSS를 사용하고 싶나요? 아니요, 스타일 작업을 하지 않을 예정이기 때문에\n- `src/` 디렉토리를 사용하고 싶나요? 네\n- App Router를 사용하시겠습니까? 네\n- 기본 import 별칭을 사용자 정의하시겠습니까? 아니요\n\n질문에 모두 답했다면, 설치가 시작됩니다!\n\n이제 설치가 완료되었습니다! 이제 실제로 Next.js 앱을 보려면 터미널에서 다음 명령을 실행하세요. Next.js 앱 내부에 있는지 확인하세요.\n\n```js\nyarn run dev\n```\n\n\n\n더 나아가기 전에, Stripe 계정을 생성하고 API 키를 받아봐요.\n\nStripe 계정을 만든 후에, dashboard.stripe.com/test/apikeys로 이동해서 API 키를 받아요.\n\n## 환경 파일 설정하기\n\n루트 디렉토리 안에, .env.local이라는 파일을 만들어주세요.\n\n\n\n.env.local 파일 안에 다음을 추가해주세요:\n\n```js\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=\"\"\nSTRIPE_SECRET_KEY=\"\"\n```\n\n여기서 기억해야 할 중요한 점이 몇 가지 있어요. 먼저, \"\"\"를 Stripe 키로 대체해야 합니다. 둘째로, 두 변수 간의 차이를 이해하는 것이 중요합니다. 하나는 \"NEXT_PUBLIC\"을 포함하고 다른 하나는 포함하지 않습니다. 간단히 말해서, \"NEXT_PUBLIC\"을 사용하여 STRIPE_PUBLISHABLE_KEY를 노출시키는 것은 괜찮지만 시크릿 키는 절대로 클라이언트 측에 노출되어서는 안 됩니다.\n\n알았어요, 이해했어요? 그럼 다음 단계로 넘어갑시다!\n\n\n\n## 필요한 패키지 설치하기\n\n당신의 Next.js 앱 내부에 다음 패키지를 설치해보세요:\n\n```js\n@stripe/react-stripe-js @stripe/stripe-js stripe axios\n```\n\n## 백엔드 작업을 시작해봅시다\n\n\n\n우리 앱 폴더 안에 api라는 새 폴더를 만들어주세요. 이곳에 모든 백엔드 코드가 위치하게 됩니다.\n\napi 폴더 안에 create-payment-intent라는 새 폴더를 만들고, 그 안에 route.ts 라는 파일을 생성해주세요.\n\n![이미지](/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_1.png)\n\n\"create-payment-intent\" 폴더 안에 \"route\"라는 파일을 만드는 이유는 Next.js에 API 요청을 다루고 있다는 것을 알리는 것입니다. 공식 문서에 따르면, route는 라우팅의 가장 기본적인 수준으로, 페이지가 하는 것처럼 레이아웃이나 클라이언트 측 탐색에 영향을주지 않습니다. \"route.ts\" 파일이 \"page.ts\" 파일이 있는 곳에 존재할 수 없다는 점을 명심해야 합니다. 자세한 내용은 문서를 참고하는 것을 강력히 권장합니다.\n\n\n\n여기는 route.ts 파일의 코드입니다:\n\n```js\nimport { NextResponse, NextRequest } from \"next/server\";\nimport Stripe from \"stripe\";\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  typescript: true,\n  apiVersion: \"2022-11-15\",\n});\n\nexport async function POST(req: NextRequest) {\n  const { data } = await req.json();\n  const { amount } = data;\n  try {\n    const paymentIntent = await stripe.paymentIntents.create({\n      amount: Number(amount) * 100,\n      currency: \"USD\",\n    });\n\n    return new NextResponse(paymentIntent.client_secret, { status: 200 });\n  } catch (error: any) {\n    return new NextResponse(error, {\n      status: 400,\n    });\n  }\n}\n```\n\n이것을 자세히 살펴보고 무슨 일이 일어나고 있는지 이해해 봅시다.\n\n첫째로, 우리는 타입과 stripe를 import 합니다:\n\n\n\n```js\nimport { NextResponse, NextRequest } from \"next/server\";\nimport Stripe from \"stripe\";\n```\n\n다음으로 stripe 인스턴스를 만듭니다:\n\n```js\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  typescript: true,\n  apiVersion: \"2022-11-15\",\n});\n```\n\n우리의 Stripe 인스턴스는 env.local 파일에서 Stripe 비밀키가 필요합니다. 더 나아가, 우리는 Stripe 인스턴스에 TypeScript를 활성화하고 인스턴스용 Stripe API 버전을 지정했습니다.\n\n\n\n계속 진행하기 전에 Next.js 13.4에서 API 경로를 다루는 방법에 대해 이야기해 봅시다.\n\n아마 이미 주목했을 것이지만, 함수의 제목이 \"POST\"와 같이 모두 대문자로 되어 있습니다. 이 네이밍 규칙은 Next.js가 실행할 해당 HTTP 메소드를 결정하기 위해 필요합니다. 예를 들어, GET 요청을 수행하려면 함수의 제목을 \"GET\"으로 지정해야 하며, 수행하려는 다른 작업에 대해서도 유사하게 지정해야 합니다.\n\n알겠습니다, 이해했습니다, 좋아요! 계속 진행합시다!\n\n우리 함수 내에서는 요청에서 데이터를 비구조화하는 방식으로 진행합니다. 그 후에는 데이터 객체에서 금액을 더욱 세분화합니다.\n\n\n\n```js\nconst { data } = await req.json();\nconst { amount } = data;\n```\n\n이제 모든 흥미로운 로직이 발생하는 trycatch 블록을 살펴보겠습니다!\n\n파고들어 봅시다.\n\n```js\nconst paymentIntent = await stripe.paymentIntents.create({\n      amount: Number(price) * 100,\n      currency: \"USD\",\n    });\n\n    return new NextResponse(paymentIntent.client_secret, { status: 200 });\n```\n\n\n\n우리의 try 블록 안에서, 결제 인텐트를 생성할 것입니다. 결제 인텐트에 대해 잘 모르신다면 걱정하지 마세요. 거래에 관한 중요한 정보를 담고 있죠. 지원되는 결제 방법, 징수할 금액, 그리고 희망하는 통화를 포함하고 있습니다.\n\n마지막으로, Stripe로부터 얻은 클라이언트 시크릿을 포함한 응답을 반환할 것입니다. 이 단계는 매우 중요합니다. 왜냐하면 우리는 클라이언트 측에서 Stripe가 결제를 확인하는 데 도움을 주기 위해 클라이언트 시크릿을 활용할 것이기 때문이죠.\n\n```js\n    return new NextResponse(error, {\n      status: 400,\n    });\n```\n\n우리의 catch 블록 안에서는 간단히 오류를 포함한 응답을 반환합니다.\n\n\n\n이 시점에서 백엔드 개발은 완료되었습니다. 이제 새로 만든 엔드포인트와 상호 작용할 클라이언트 측으로 이동해 봅시다.\n\n## 프론트엔드\n\n마법을 시작하기 전에 정리해 봅시다!\n\nlayout.tsx 파일에서 global.css를 불러오는 줄을 삭제하세요. 스타일에 대해서는 다루지 않을 거에요.\n\n\n\n앱.tsx 파일에서 `main` 태그 내부의 모든 내용을 삭제하고, Image 컴포넌트 import 구문을 삭제해주세요.\n\n좋아요, 이 시점에서 layout.tsx 파일은 다음과 같아야 합니다:\n\n```js\nimport { Inter } from \"next/font/google\";\n\nconst inter = Inter({ subsets: [\"latin\"] });\n\nexport const metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>{children}</body>\n    </html>\n  );\n}\n```\n\n그리고 app.tsx 파일은 다음과 같아야 합니다:\n\n\n\n```js\nexport default function Home() {\n  return (\n    <></>\n  );\n}\n```\n\n여기 멋진 곳에요, 결제 양식을 설정해 봅시다!\n\n\"src\" 폴더에서 \"components\"라는 새 폴더를 만들어 주세요. \"components\" 폴더 안에 \"PaymentForm\"이라는 또 다른 폴더를 만들어 주세요. \"PaymentForm\" 폴더 안에 \"PaymentForm.tsx\"라는 파일을 만들어 주세요. 거기에 우리의 결제 양식이 위치하고 대부분의 로직이 여기서 실행될 거에요.\n\n시작해 봅시다!\n\n\n\n우리가 컴포넌트 작성을 시작하기 전에, Next.js에게 서버 컴포넌트가 아닌 클라이언트 컴포넌트를 다루고 있다는 것을 알려주어야 해요.\n\nPaymentForm.tsx 파일의 맨 위에 다음을 추가해주세요:\n\n```js\n\"use client\";\n```\n\n그 다음에 다음과 같은 import 문을 추가해주세요:\n\n\n\n```js\nimport { CardElement, useElements, useStripe } from \"@stripe/react-stripe-js\";\nimport axios from \"axios\";\nimport React from \"react\";\n```\n\n이제 빈 컴포넌트를 생성해봅시다:\n\n```js\nexport default function PaymentForm() {\n  return <></>;\n}\n```\n\n지금까지의 파일은 이렇게 보여야 합니다:\n\n\n\n```js\n\"사용자용\";\n\nimport { CardElement, useElements, useStripe } from \"@stripe/react-stripe-js\";\nimport axios from \"axios\";\nimport React from \"react\";\n\nexport default function PaymentForm() {\n  return <></>;\n}\n```\n\n우리 컴포넌트 안에서 처음으로 해야 할 일은 Stripe 훅을 사용하는 것인데, 우리가 사용할 훅은 useStripe와 useElements 입니다.\n\n```js\n  const stripe = useStripe();\n  const elements = useElements();\n```\n\nfrom을 제출할 수 있는 onSubmit이라는 함수를 만들어봅시다.```\n\n\n\n```js\n  const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {}\n```\n\nonSubmit 함수 안에서 e.preventDefault(); 를 사용하여 기본 동작을 막아줍시다.\n\n다음으로, stripe 카드 엘리먼트에 다음 스니펫을 사용하여 접근해야 합니다:\n\n```js\n    const cardElement = elements?.getElement(\"card\");\n```\n\n\n\n지금부터 실제 마법을 시도해 봅시다!\n\ntry-catch 블록을 만들어 봅시다. try 블록 안에는 stripe와 cardElement의 존재 여부를 확인하는 조건문을 만들 것입니다. 둘 중 하나라도 누락된 경우, onSubmit 함수를 효과적으로 중단시키고 더 이상의 작업을 방지하기 위해 null을 반환할 것입니다.\n\ncatch 블록에서는 단순히 error를 console.log 하면 됩니다.\n\n다음은 코드 조각입니다:\n\n\n\n```js\n    try {\n      if (!stripe || !cardElement) return null;\n    } catch (error) {\n      console.log(error);\n    }\n```\n\n안녕하세요 여러분, 지금 좋은 위치에 있어요. 계속 진행하죠.\n\nStripe와 cardElement가 모두 존재하는지 확인한 후에, 이전에 백엔드에서 설정한 API를 사용하여 결제 의도를 생성할 수 있습니다. API에 전달할 데이터는 금액이 포함되며, 저의 경우에는 89로 설정되어 있어요.\n\n```js\n    const { data } = await axios.post(\"/api/create-payment-intent\", {\n        data: { amount: 89 },\n      });\n```\n\n\n\n응답을 clientSecret라는 변수에 할당해보세요.\n\n```js\nconst clientSecret = data;\n```\n\n마지막으로 우리가 해야 할 일은 stripe에서 제공하는 confirmCardPayment 메서드를 사용하여 결제를 확인하는 것입니다. 아래는 예시 코드 조각입니다:\n\n```js\nawait stripe?.confirmCardPayment(clientSecret, {\n  payment_method: { card: cardElement },\n});\n```\n\n\n\n지금까지 onSubmit 함수를 완료했습니다.\n\n우리의 컴포넌트가 stripe에서 제공하는 CardElement 컴포넌트를 사용하는 폼을 반환하도록 만들어보겠습니다.\n\n```js\n    <form onSubmit={onSubmit}>\n      <CardElement />\n      <button type=\"submit\">제출하기</button>\n    </form>\n```\n\n최종 결과:\n\n\n\n```js\n\"사용자 사용\";\n\nimport { CardElement, useElements, useStripe } from \"@stripe/react-stripe-js\";\nimport axios from \"axios\";\nimport React from \"react\";\n\nexport default function PaymentForm() {\n  const stripe = useStripe();\n  const elements = useElements();\n\n  const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    const cardElement = elements?.getElement(\"card\");\n\n    try {\n      if (!stripe || !cardElement) return null;\n      const { data } = await axios.post(\"/api/create-payment-intent\", {\n        data: { amount: 89 },\n      });\n      const clientSecret = data;\n\n      await stripe?.confirmCardPayment(clientSecret, {\n        payment_method: { card: cardElement },\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  return (\n    <form onSubmit={onSubmit}>\n      <CardElement />\n      <button type=\"submit\">제출</button>\n    </form>\n  );\n}\n```\n\n좋은 소식입니다! 우리의 PaymentForm 컴포넌트가 이제 완성되었습니다. 만세! 이제 마지막 단계로 넘어가서, 새롭게 생성된 PaymentForm 컴포넌트를 사용하도록 앱의 app.tsx 파일을 업데이트하는 것을 진행해보겠습니다.\n\nPaymentForm 컴포넌트가 app.tsx 안에서 사용되기 전에, 몇 가지를 import하고 stripe를 로드해야 합니다.\n\n```js\n\"사용자 사용\";\nimport { Elements } from \"@stripe/react-stripe-js\";\nimport { loadStripe } from \"@stripe/stripe-js\";\nimport PaymentForm from \"@/components/PaymentForm/PaymentForm\";\n```\n\n\n\nstripe를 불러와보겠습니다:\n\n```js\nconst stripePromise = loadStripe(\n  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!\n);\n```\n\nstripe를 컴포넌트 외부에서 로드하는 것을 확인해주세요. 그렇지 않으면 stripe가 매번 렌더링되어 원하지 않는 결과가 발생할 수 있습니다.\n\n마지막으로, return 문 안에서 우리에게 제공된 Element 공급자를 활용해봅시다. PaymentForm 컴포넌트를 해당 공급자로 감싸겠습니다. 다음과 같이 보여야 합니다:\n\n\n\n여기 완성된 결과입니다:\n\n```js\n\"use client\";\nimport { Elements } from \"@stripe/react-stripe-js\";\nimport { loadStripe } from \"@stripe/stripe-js\";\nimport PaymentForm from \"@/components/PaymentForm/PaymentForm\";\n// 컴포넌트 렌더링 시에 `Stripe` 객체를 다시 생성하는 것을 피하기 위해\n// `loadStripe`를 컴포넌트 밖에서 호출하는 것을 확인해주세요.\nconst stripePromise = loadStripe(\n  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!\n);\n\nexport default function Home() {\n  return (\n    <Elements stripe={stripePromise}>\n      <PaymentForm />\n    </Elements>\n  );\n}\n```\n\n와! Stripe를 사용하여 결제 폼을 만들었네요. 잘 했어요!\n\n\n\n이 글이 도움이 되었으면 좋겠어요! 앞으로 여기서 더 활발하게 활동할 거에요. 기대돼요 🤔\n\n여기 git 레포지토리 링크에요. 즐겨보세요!","ogImage":{"url":"/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png","tag":["Tech"],"readingTime":10},{"title":"12가지 유용한 JavaScript 면접 팁","description":"","date":"2024-05-14 16:06","slug":"2024-05-14-12UsefulJavaScriptInterviewTips","content":"\n\n제 3 부: 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록\n\n![자바스크립트에 대해 알아야 할 것들](/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png)\n\n이 시리즈의 기사에서는 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록을 정리했습니다. 이는 면접을 볼 때나 매일 개발할 때 큰 자신감을 줄 것입니다.\n\n이전 기사에서는 일반 지식 포인트를 나열했으며 다음 링크를 클릭하여 확인할 수 있습니다.\n\n\n\n# 1. 'Set' 객체는 무엇이며 어떻게 작동하나요?\n\nSet 객체를 사용하면 원시 값이든 객체 참조든 어떠한 유형의 고유한 값도 저장할 수 있습니다.\n\nSet 생성자를 사용하여 Set 인스턴스를 만들 수 있습니다.\n\n```js\nconst set1 = new Set();\nconst set2 = new Set([\"a\",\"b\",\"c\",\"d\",\"d\",\"e\"]);\n```\n\n\n\nSet 인스턴스에 새 값을 추가하려면 add 메서드를 사용할 수 있습니다. add 메서드는 Set 객체를 반환하기 때문에 여러 개의 add 호출을 연결할 수 있습니다. Set 객체에 값이 이미 존재한다면 다시 추가되지 않습니다.\n\n```js\nset2.add(\"f\");\nset2.add(\"g\").add(\"h\").add(\"i\").add(\"j\").add(\"k\").add(\"k\");\n```\n\n특정 값이 Set 인스턴스에 있는지 확인하려면 has 메서드를 사용할 수 있습니다.\n\n```js\nset2.has(\"a\") // true\nset2.has(\"z\") // true\n```\n\n\n\nSet 인스턴스의 길이를 얻기 위해 size 속성을 사용할 수 있어요.\n\n```js\nset2.size // 10을 반환합니다\n```\n\n모든 데이터를 Set에서 제거할 때 clear 메소드를 사용할 수 있어요.\n\n```js\nset2.clear();\n```\n\n\n\n배열에서 중복된 요소를 제거하는 데 Set 객체를 사용할 수 있어요.\n\n```js\nconst numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];\nconst uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]\n```\n\n## 2. 콜백 함수란 무엇인가요?\n\n콜백 함수는 다른 코드의 인자로 전달되어 실행 가능한 코드 조각입니다. 이 함수의 목적은 필요할 때 수신 코드에 의해 편리한 시간에 호출되도록 하는 것입니다.\n\n\n\n자바스크립트에서 함수는 객체의 한 유형입니다. 객체처럼 함수도 다른 함수에게 인수로 전달될 수 있습니다. 따라서 다른 함수의 인수로 전달되는 함수는 콜백 함수라고 합니다.\n\n```js\nconst btnAdd = document.getElementById('btnAdd');\n\nbtnAdd.addEventListener('click', function clickCallback(e) {\n    // 아무 일도 하지 않음\n});\n```\n\n이 예시에서는 id가 btnAdd인 요소의 클릭 이벤트를 기다리고 있습니다. 클릭이 발생하면 clickCallback 함수가 실행됩니다. 콜백 함수는 특정 데이터나 이벤트에 기능을 추가합니다.\n\n배열의 reduce, filter, map 메서드는 매개변수로 콜백 함수를 요구합니다. 콜백의 좋은 비유는 누군가에게 전화를 걸어서, 그들이 받지 않으면 메시지를 남기고 전화 받기를 기대하는 것입니다. 누군가에게 전화를 거는 행위나 메시지를 남기는 것이 이벤트나 데이터이며, 콜백은 나중에 발생할 기대되는 작업입니다.\n\n\n\n# 3. ES6 모듈이란 무엇인가요?\n\n모듈은 코드베이스를 여러 파일로 분할하여 유지 보수성을 향상시키고 모든 코드를 하나의 큰 파일에 모두 가지고 있지 않도록 해줍니다. ES6 이전에는 두 가지 인기있는 모듈 시스템이 있었습니다.\n\n- CommonJS-Node.js\n- AMD (비동기 모듈 정의) - 브라우저\n\n기본적으로 모듈을 사용하는 것은 매우 간단합니다. import는 다른 파일에서 기능이나 여러 기능 또는 값을 검색하는 데 사용되며, export는 파일에서 기능이나 여러 기능 또는 값을 노출하는 데 사용됩니다.\n\n\n\n## 내보내기\n\nES5(CommonJS) 사용\n\n```js\n// ES5(CommonJS)를 사용하여 - helpers.js\nexports.isNull = function(val) {\n  return val === null;\n}\n\nexports.isUndefined = function(val) {\n  return val === undefined;\n}\n\nexports.isNullOrUndefined = function(val) {\n  return exports.isNull(val) || exports.isUndefined(val);\n}\n```\n\nES6 모듈 사용\n\n\n\n```js\n// Using ES6 Modules - helpers.js\nexport function isNull(val){\n  return val === null;\n}\n\nexport function isUndefined(val) {\n  return val === undefined;\n}\nexport function isNullOrUndefined(val) {\n  return isNull(val) || isUndefined(val);\n}\n```\n\n다른 파일에서 함수 가져오기\n\n```js\n//ES5 (CommonJS) - index.js\nconst helpers = require('./helpers.js'); // helpers는 객체임\nconst isNull = helpers.isNull;\nconst isUndefined = helpers.isUndefined;\nconst isNullOrUndefined = helpers.isNullOrUndefined;\n// 또는 환경이 구조 분해를 지원하는 경우\nconst { isNull, isUndefined, isNullOrUndefined } = require('./helpers.js');\n-------------------------------------------------------\n// ES6 Modules - index.js\nimport * as helpers from './helpers.js'; // helpers는 객체임\n// 또는 \nimport { isNull, isUndefined, isNullOrUndefined as isValid } from './helpers.js';\n// \"as\"를 사용하여 명명된 내보내기 이름 변경\n```\n\n파일에서 단일 함수 또는 기본 내보내기 내보내기\n\n\n\nES5 (CommonJS)\n\n```js\n// ES5 (CommonJS) - index.js\nclass Helpers {\n  static isNull(val) {\n    return val === null;\n  }\n\n  static isUndefined(val) {\n    return val === undefined;\n  }\n\n  static isNullOrUndefined(val) {\n    return this.isNull(val) || this.isUndefined(val);\n  }\n}\nmodule.exports = Helpers;\n```\n\nES6 Modules을 사용하는 예시\n\n```js\n// using ES6 Modules - helpers.js\nclass Helpers {\n  static isNull(val) {\n    return val === null;\n  }\n\n  static isUndefined(val) {\n    return val === undefined;\n  }\n\n  static isNullOrUndefined(val) {\n    return this.isNull(val) || this.isUndefined(val);\n  }\n}\nexport default Helpers;\n```\n\n\n\n다른 파일에서 함수를 한 개 가져오기\n\nES5(CommonJS)를 사용하는 방법\n\n```js\n// ES5(CommonJS) - index.js\nconst Helpers = require('./helpers.js');\nconsole.log(Helpers.isNull(null));\n```\n\nES6 모듈 사용법\n\n\n\n```js\nimport Helpers from '.helpers.js'\nconsole.log(Helpers.isNull(null));\n```\n\n## 4. Promise이 무엇인가요?\n\nPromise은 비동기 프로그래밍의 해결책입니다. 구문적으로 Promise은 비동기 작업의 결과를 얻을 수 있는 객체입니다. 개념적으로 일정 기간이 지난 후 결과를 제공할 것을 약속하는 것을 나타냅니다. Promise에는 세 가지 상태가 있습니다: pending(대기 중), fulfilled(이행됨) 및 rejected(거부됨). 상태가 변경되면 변경된 상태가 유지됩니다. Promise 인스턴스를 생성한 후에는 즉시 실행됩니다.\n\n```js\nfs.readFile('somefile.txt', function (e, data) {\n  if (e) {\n    console.log(e);\n  }\n  console.log(data);\n});\n```\n\n\n\n만약 콜백 안에 또 다른 비동기 작업이 있다면, 문제가 생길 수 있어요. 코드가 엉망이 되고 가독성이 떨어질 거예요. 이를 '콜백 지옥'이라고 해요.\n\n```js\n// 콜백 지옥\nfs.readFile('somefile.txt', function (e, data) {\n  //여기에 코드 작성\n  fs.readdir('directory', function (e, files) {\n    //여기에 코드 작성\n    fs.mkdir('directory', function (e) {\n      //여기에 코드 작성\n    })\n  })\n})\n```\n\n이 코드에서 promise를 사용하면 더 읽기 쉽고 이해하기 쉽고 유지보수하기 좋아질 거예요.\n\n```js\npromReadFile('file/path')\n  .then(data => {\n    return promReaddir('directory');\n  })\n  .then(data => {\n    return promMkdir('directory');\n  })\n  .catch(e => {\n    console.log(e);\n  })\n```  \n\n\n\n약속은 세 가지 다른 상태를 가집니다:\n\n- 대기 중(pending): 이니셜 상태로, 충족 또는 거부되기 전의 상태입니다.\n- 충족됨(fulfilled): 작업이 성공적으로 완료된 상태입니다.\n- 거부됨(rejected): 작업이 실패한 상태입니다.\n\n대기 중인 객체는 충족됨/거부됨 상태를 발생시키며, 해당 상태 처리 메소드에 해결된 값/에러 메시지를 전달합니다. 작업이 성공적으로 완료되면, Promise 객체의 then 메소드가 호출됩니다. 그렇지 않으면 catch 메소드가 트리거됩니다. 예를 들면:\n\n```js\nconst myFirstPromise = new Promise((resolve, reject) => {\n    setTimeout(function(){\n        resolve(\"Success!\"); \n    }, 250);\n});\n\nmyFirstPromise.then((data) => {\n    console.log(\"Yay! \" + data);\n}).catch((e) => {...});\n```\n\n\n\n# 5. async/await이란 무엇이며 어떻게 동작합니까?\n\nasync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. 이는 Promises 위에 구축되어 있으며 비동기 코드의 가독성과 간결성을 높여줍니다.\n\nasync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. Promises 및 콜백에 비해 높은 가독성과 간결성을 제공합니다. 그러나 이 기능을 사용하기 전에 Promises의 기본을 배우는 것이 필요합니다. 앞에서 언급한 대로 async/await은 Promises 위에 구축되어 있으므로 여전히 내부적으로 Promises를 사용합니다.\n\n\n\n```js\n기능 callApi() {\n  return fetch(\"url/to/api/endpoint\")\n    .then(resp => resp.json())\n    .then(data => {\n      // \"data\"와 무언가를 처리합니다\n    }).catch(err => {\n      // \"err\"과 무언가를 처리합니다\n    });\n}\n```\n\nasync/await\n\nasync/await에서는 try/catch 구문을 사용하여 예외를 catch합니다.\n\n```js\nasync function callApi() {\n  try {\n    const resp = await fetch(\"url/to/api/endpoint\");\n    const data = await resp.json();\n    // \"data\"와 무언가를 처리합니다\n  } catch (e) {\n    // \"err\"과 무언가를 처리합니다\n  }\n}\n```\n\n\n\n참고: 'async' 키워드를 사용하여 함수를 선언하면 암시적으로 Promise가 반환됩니다.\n\n```js\nconst giveMeOne = async () => 1;\n\ngiveMeOne()\n  .then((num) => {\n    console.log(num); // 1을 출력합니다\n  });\n```\n\n참고: 'await' 키워드는 오직 async 함수 내에서만 사용할 수 있습니다. 어떤 비동기 함수에서도 'await' 키워드를 사용하면 오류가 발생합니다. 'await' 키워드는 Promise가 반환될 때까지 오른쪽 표현식을 기다린 후 다음 코드 줄을 실행합니다.\n\n```js\nconst giveMeOne = async () => 1;\n\nfunction getOne() {\n  try {\n    const num = await giveMeOne();\n    console.log(num);\n  } catch (e) {\n    console.log(e);\n  }\n}\n// Uncaught SyntaxError: await is only valid in async function\nasync function getTwo() {\n  try {\n    const num1 = await giveMeOne(); \n    const num2 = await giveMeOne(); \n    return num1 + num2;\n  } catch (e) {\n    console.log(e);\n  }\n}\nawait getTwo(); // 2\n```\n\n\n\n# 6. 스프레드 연산자와 나머지 연산자의 차이는 무엇인가요?\n\n스프레드 연산자는 세 개의 점 ...으로 나타내며, 배열을 쉼표로 구분된 인수의 시퀀스로 변환할 수 있습니다. 좀 더 간단히 말하면, 큰 요소를 작은 요소로 나누어주는 것과 같습니다. 마치 손바닥 타격이 단단한 물체를 분산시키는 것처럼 말이죠.\n\n나머지 연산자도 세 개의 점 ...로 표시되지만, 스프레드 연산자와 비슷해 보일 수 있지만, 배열과 객체의 해체에 사용됩니다. 어느 정도로는 스프레드 연산자의 반대 역할을 합니다. 스프레드 연산자는 배열을 여러 요소로 '펼치는' 반면, 나머지 연산자는 여러 요소를 '수집'하고 그것들을 한 요소로 '압축'합니다.\n\n```js\nfunction add(a, b) {\n  return a + b;\n};\n\nconst nums = [5, 6];\nconst sum = add(...nums);\nconsole.log(sum);\n```\n\n\n\n이 예에서는 add 함수를 호출할 때 전개 연산자를 사용하여 nums 배열을 확장했습니다. 따라서 매개변수 a의 값은 5이고, 매개변수 b의 값은 6이므로 합계는 11이 됩니다.\n\n```js\nfunction add(...rest) {\n  return rest.reduce((total, current) => total + current);\n};\n\nconsole.log(add(1, 2)); // 3\nconsole.log(add(1, 2, 3, 4, 5)); // 15\n```\n\n이 예에서는 임의의 개수의 매개변수를 수용하고 모두 더한 다음 총합을 반환하는 add 함수가 있습니다.\n\n```js\nconst [first, ...others] = [1, 2, 3, 4, 5];\nconsole.log(first); // 1\nconsole.log(others); // [2, 3, 4, 5]\n```\n\n\n\n여기서는 나머지 배열 값을 추출하여 다른 배열에 넣는 데 rest 연산자를 사용합니다. 첫 번째 항목을 제외하고 나머지 값을 모두 가져올 수 있어요.\n\n# 7. 기본 매개변수란?\n\n기본 매개변수는 JavaScript에서 기본 변수를 정의하는 새로운 방법으로, ES6 또는 ECMAScript 2015에서 사용할 수 있어요.\n\n```js\n//ES5 버전\nfunction add(a, b) {\n  a = a || 0;\n  b = b || 0;\n  return a + b;\n}\n\n//ES6 버전\nfunction add(a = 0, b = 0) {\n  return a + b;\n}\nadd(1); // 1을 반환\n```\n\n\n\n기본 매개변수에서 해체 할당을 사용할 수도 있어요.\n\n```js\nfunction getFirst([first, ...rest] = [0, 1]) {\n  return first;\n}\n\ngetFirst();  // 0\ngetFirst([10,20,30]);  // 10\nfunction getArr({ nums } = { nums: [1, 2, 3, 4] }){\n    return nums;\n}\ngetArr(); // [1, 2, 3, 4]\ngetArr({nums:[5,4,3,2,1]}); // [5,4,3,2,1]\n```\n\n이전에 정의된 매개변수를 나중에 정의된 매개변수보다 먼저 사용할 수도 있어요.\n\n```js\nfunction doSomethingWithValue(value = \"Hello World\", callback = () => { console.log(value) }) {\n  callback();\n}\ndoSomethingWithValue(); //\"Hello World\"\n```\n\n\n\n# 8. 래퍼 객체란 무엇인가요?\n\n이제 JavaScript의 데이터 유형을 검토해봅시다. JavaScript 데이터 유형은 기본 유형과 참조 유형으로 나뉩니다.\n\n기본 유형: Undefined, Null, Boolean, Number, String, Symbol, BigInt\n\n참조 유형: Object, Array, Date, RegExp 등. 간단히 말해, 이들은 객체입니다.\n\n\n\n참조 유형 중에는 프리미티브 유형에는 없는 메소드와 속성이 있습니다. 그러나 종종 다음과 같은 코드를 만날 수 있습니다:\n\n```js\nlet name = \"maxwell\";\n\nconsole.log(typeof name); // \"string\"\nconsole.log(name.toUpperCase()); // \"MAXWELL\"\n```\n\n이름 타입은 문자열이며 프리미티브 유형에 속합니다. 따라서 속성이나 메소드가 없습니다. 그러나 이 예제에서 toUpperCase() 메소드를 호출하는 것은 에러를 발생시키지 않고 문자열의 대문자 값을 반환합니다.\n\n그 이유는 프리미티브 유형의 값이 일시적으로 객체로 변환되거나 강제 변환되기 때문에, 이름 변수의 동작이 객체와 유사합니다. null과 undefined를 제외한 모든 프리미티브 유형에는 String, Number, Boolean, Symbol 및 BigInt의 래퍼 객체가 있습니다. 이 경우, name.toUpperCase()은 '백그라운드에서' 다음과 같이 보입니다:\n\n\n\n```js\nconsole.log(new String(name).toUpperCase()); // \"MAXWELL\"\n```\n\n속성에 접근하거나 메소드를 호출한 후에, 새로 생성된 객체는 즉시 폐기됩니다.\n\n## 9. 암시적 형 변환과 명시적 형 변환의 차이점은 무엇인가요?\n\n암시적 형 변환은 값의 형태를 다른 형태로 자동으로 변환하는 방법으로, 수동 개입 없이 자동으로 처리됩니다.\n\n\n\n아래의 예시를 가정해 봅시다.\n\n```js\nconsole.log(1 + '6'); // 16\nconsole.log(false + true); // 1\nconsole.log(6 * '2'); // 12\n```\n\n첫 번째 `console.log` 문의 결과는 16입니다. 다른 언어에서는 컴파일 오류가 발생할 수 있지만 JavaScript에서는 1이 문자열로 변환되고 그 후 + 연산자와 연결됩니다. 우리는 아무것도 하지 않았습니다. JavaScript가 자동으로 처리해 주었습니다.\n\n두 번째 `console.log` 문의 결과는 1입니다. JavaScript에서 false는 0으로, true는 1로 변환됩니다. 따라서 결과는 1이 됩니다.\n\n\n\n세 번째 console.log 문의 결과는 12입니다. '2'를 숫자로 변환한 다음 6 * 2를 곱하여 12가 되었습니다.\n\n반면에 명시적 타입 강제 변환은 값의 타입을 수동으로 변환해야 하는 경우에 사용하는 방법입니다.\n\n```js\nconsole.log(1 + parseInt('6'));\n```\n\n이 예시에서는 parseInt 함수를 사용하여 '6'를 숫자로 변환한 후 + 연산자를 사용하여 1과 6을 더합니다.\n\n\n\n# 10. NaN이란 무엇인가요? 그리고 값이 NaN인지 확인하는 방법은 무엇인가요?\n\nNaN은 \"숫자가 아님(Not a Number)\"을 의미하며, JavaScript에서 숫자 연산이나 변환 결과로 의미있는 숫자 값을 생성하지 못할 때 발생합니다. 따라서 숫자 연산이나 변환에서 숫자가 아닌 값이 나오면 결과값은 NaN이 됩니다.\n\n```js\nlet a;\n\nconsole.log(parseInt('abc')); // NaN\nconsole.log(parseInt(null)); // NaN\nconsole.log(parseInt(undefined)); // NaN\nconsole.log(parseInt(++a)); // NaN\nconsole.log(parseInt({} * 10)); // NaN\nconsole.log(parseInt('abc' - 2)); // NaN\nconsole.log(parseInt(0 / 0)); // NaN\nconsole.log(parseInt('10a' * 10)); // NaN\n```\n\nJavaScript에는 값이 NaN인지 확인하는 isNaN 메서드가 내장되어 있습니다. 그러나 이 함수는 특이한 동작을 보입니다.\n\n\n\n```js\nconsole.log(isNaN()); // true\nconsole.log(isNaN(undefined)); // true\nconsole.log(isNaN({})); // true\nconsole.log(isNaN(String('a'))); // true\nconsole.log(isNaN(() => { })); // true\n```\n\n모든 이 console.log 문은 값으로 NaN이 아닌 경우에도 true를 반환합니다.\n\nES6에서는 값이 NaN인지를 진정으로 확인하는 Number.isNaN 메서드를 사용하는 것이 좋습니다. 또는 JavaScript에서 NaN은 자신과 일치하지 않는 유일한 값이기 때문에 이 문제를 확인하기 위한 사용자 지정 도우미 함수를 만들 수 있습니다.\n\n```js\nfunction checkIfNaN(value) {\n  return value !== value;\n}\n```\n\n\n\n# 11. 값이 배열인지 어떻게 판단할 수 있을까요?\n\nArray.isArray 메소드를 사용하여 값이 배열인지 확인할 수 있습니다. 배열이 인수로 전달되면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n\n```js\nconsole.log(Array.isArray(5));  // false\nconsole.log(Array.isArray(\"\")); // false\nconsole.log(Array.isArray()); // false\nconsole.log(Array.isArray(null)); // false\nconsole.log(Array.isArray({ length: 5 })); // false\n\nconsole.log(Array.isArray([])); // true\n```\n\n이 방법이 지원되지 않는 환경이라면, 폴리필을 구현할 수도 있습니다.\n\n\n\n```js\nfunction isArray(value){\n return Object.prototype.toString.call(value) === \"[object Array]\"\n}\n```\n\n물론 전통적인 방법도 사용할 수 있어요:\n\n```js\nlet a = []\nif (a instanceof Array) {\n  console.log('is an array')\n} else {\n  console.log('Non-Arrays')\n}\n```\n\n# 12. 객체에 속성이 존재하는지 확인하는 방법은 무엇인가요?\n\n\n\n객체에 특정 속성이 존재하는지 확인하는 세 가지 방법이 있어요.\n\n첫 번째 방법은 in 연산자를 사용하는 것이에요:\n\n```js\nconst o = { \n  \"prop\" : \"rabbit\",\n  \"prop2\" : \"tiger\"\n};\n\nconsole.log(\"prop\" in o); // true\nconsole.log(\"prop1\" in o); // false\n```\n\n두 번째 방법은 hasOwnProperty 메서드를 사용하는 것이에요. hasOwnProperty() 메서드는 객체가 지정된 속성을 직접 속성으로 가지고 있는지 여부를 나타내는 부울 값(true 또는 false)을 반환해줘요.\n\n\n\n```js\r\nconsole.log(o.hasOwnProperty(\"prop2\")); // true\nconsole.log(o.hasOwnProperty(\"prop1\")); // false\r\n```\n\n세 번째 방법은 괄호 표기법 obj['prop']를 사용하는 것입니다. 속성이 존재하면 해당 속성의 값을 반환하고, 그렇지 않으면 undefined를 반환합니다.\n\n```js\r\nconsole.log(o[\"prop\"]); // \"rabbit\"\nconsole.log(o[\"prop1\"]); // undefined\r\n```\n\n더 많은 내용은 PlainEnglish.io에서 확인할 수 있습니다.\n\n\n\n우리의 무료 주간 소식지 구독하세요. Twitter, LinkedIn, YouTube, Discord를 팔로우해보세요.","ogImage":{"url":"/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png"},"coverImage":"/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png","tag":["Tech"],"readingTime":14},{"title":"노드js 클러스터 구현으로 성능 개선하기","description":"","date":"2024-05-14 16:05","slug":"2024-05-14-ImplementingNodejsClusterforImprovedPerformance","content":"\n\n<img src=\"/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png\" />\n\nNode.js는 확장 가능하고 효율적인 서버 측 애플리케이션을 만들기 위한 인기있는 런타임 환경입니다. 멀티 코어 시스템의 잠재력을 최대한 활용하고 Node.js 애플리케이션의 성능을 향상시키기 위해 내장된 클러스터 모듈을 사용하여 클러스터링을 구현할 수 있습니다. 클러스터링은 여러 워커 프로세스를 생성하여 들어오는 요청을 처리하므로 성능이 향상되고 시스템 자원을 더 효율적으로 활용할 수 있습니다.\n\n이 글에서는 Node.js에서 클러스터링의 개념을 탐구하고, 이점을 이해하며, 클러스터링 있는 경우와 없는 경우의 워크스루를 설명하고, 성능 평가를 위해 loadtest 패키지를 사용한 로드 테스트를 소개합니다.\n\n## 클러스터링 이해하기\n\n\n\nNode.js에서의 클러스터링은 여러 워커 프로세스를 만들어들어오는 작업 부하를 공유하는 것을 포함합니다. 각 워커 프로세스는 자체 이벤트 루프에서 실행되며 사용 가능한 CPU 코어를 활용합니다. 마스터 프로세스는 워커 프로세스를 관리하고 들어오는 요청을 분배하며 프로세스 실패를 처리합니다.\n\n## 클러스터링의 장점:\n\n- 성능 향상: 클러스터링을 통해 여러 코어에 걸쳐 요청을 병렬로 처리함으로써 응용 프로그램의 성능과 응답성이 향상됩니다. 이는 특히 여러 CPU 코어를 가진 기기에서 사용 가능한 시스템 자원을 더 잘 활용할 수 있게 합니다.\n- 확장성: 클러스터링은 동시에 발생하는 요청들을 병렬로 처리하여 Node.js 애플리케이션의 확장성을 향상시킵니다. 작업 부하가 증가하면 추가 워커 프로세스가 동적으로 생성되어 부하를 효과적으로 분산시킬 수 있습니다.\n- 내결함성: 워커 프로세스가 충돌하거나 응답이 없어지면 마스터 프로세스가 해당 실패를 감지하고 자동으로 워커 프로세스를 다시 시작할 수 있습니다. 이 내결함성은 프로세스 실패가 발생해도 응용 프로그램이 계속 사용 가능하도록 보장합니다.\n\n## 예시 구현- 클러스터링과 함께:\n\n\n\nNode.js Express 애플리케이션에서 클러스터링을 구현하는 예제를 살펴보겠습니다:\n\n```js\nconst cluster = require('cluster');\nconst os = require('os');\nconst express = require('express');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`마스터 프로세스 ${process.pid}가 실행 중입니다`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`워커 프로세스 ${worker.process.pid}가 종료되었습니다. 다시 시작 중...`);\n    cluster.fork();\n  });\n} else {\n  const app = express();\n\n  // Express 앱을 구성합니다\n  // ...\n\n  const server = app.listen(3000, () => {\n    console.log(`워커 프로세스 ${process.pid}가 3000 포트에서 수신 대기 중입니다`);\n  });\n}\n```\n\n이 예제에서는 마스터 프로세스가 사용 가능한 CPU 코어 수에 기반하여 워커 프로세스를 생성합니다. 각 워커 프로세스는 Express 앱의 인스턴스를 실행하여 병렬 요청 처리를 활성화합니다.\n\n## 클러스터링 없이 구현한 예시:\n\n\n\n비교를 위해 클러스터링 없이 구현한 예제를 보여드립니다:\n\n```js\nconst express = require('express');\n\nconst app = express();\n\n// Express 앱 구성\n// ...\n\nconst server = app.listen(3000, () => {\n  console.log('서버가 3000 포트에서 실행 중입니다');\n});\n```\n\n이 단순화된 예제에서는 클러스터링이 없고, 응용 프로그램은 단일 프로세스에서 실행됩니다.\n\n## 클러스터링과 부하 테스트 비교:\n\n\n\n클러스터링은 병렬 처리를 통해 성능을 향상시키지만, 로드 테스팅은 다양한 작업 부하 아래 응용 프로그램의 성능을 평가합니다. 우리는 로드테스트 패키지를 사용하여 부하를 시뮬레이션하고 성능을 평가하여 이러한 방법을 비교할 수 있습니다.\n\n## 로드 테스팅 구현:\n\n응용 프로그램을 로드 테스트하려면 다음 단계를 따르세요:\n\n단계 1: 프로젝트 디렉토리에서 다음 명령을 실행하여 loadtest 패키지를 설치합니다.\n\n\n\n```js\nnpm install -g loadtest\n```\n\n단계 2: 터미널에서 node app.js를 실행하여 Express 애플리케이션을 시작합니다.\n\n단계 3: 새로운 터미널 창을 열고 다음 명령을 실행하여 애플리케이션을 로드 테스트합니다:\n\n```js\nloadtest -c 10 --rps 100 -n 100 http://localhost:3000\n```\n\n\n\n이 예시에서는 특정 URL에 초당 100개의 요청률을 가진 10개의 동시 사용자를 모의하는 것입니다.\n\n## 관찰 사항\n\n클러스터링 없음: 100개의 요청 중 100개의 오류 발생\n\n![이미지](/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_1.png)\n\n\n\n캐슁터링을 이용한: 0개의 오류/100개의 요청\n\n![이미지](/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_2.png)\n\n응답 시간, 처리량, 그리고 오류와 같은 메트릭을 포함한 부하 테스트 결과를 살펴보세요. 이러한 메트릭은 지정된 부하 하에서 애플리케이션의 성능에 대한 통찰을 제공합니다.\n\n## 결론:\n\n\n\n이 글에서는 Node.js 애플리케이션에서 클러스터링의 이점을 탐색했습니다. 병렬 요청 처리를 통한 성능 향상, 확장성 및 오류 허용성을 통해 성능을 향상시킬 수 있다고 설명했습니다. 별도의 클러스터링을 사용한 예제와 그렇지 않은 예제를 제공하며, 여러 워커 프로세스를 활용하는 장점을 강조했습니다.\n\n게다가, loadtest 패키지를 사용하여 시뮬레이션된 워크로드에서 응용 프로그램의 성능을 평가하는 수단으로서 부하 테스트에 대해 논의했습니다. 부하 테스트는 응답 시간, 처리량 및 오류율을 평가하여 성능 최적화에 도움을 줍니다.\n\nNode.js 애플리케이션에서 클러스터링 및 부하 테스트를 활용함으로써 높은 성능, 확장성 및 고품질 트래픽 상황을 효과적으로 처리할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png","tag":["Tech"],"readingTime":4},{"title":"JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기","description":"","date":"2024-05-14 16:04","slug":"2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps","content":"\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png)\n\n## 프론트엔드 개발\n\n# 텍스트를 음성으로 변환하기\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_1.png)\n\n\n\n## 자바스크립트로 텍스트 음성 변환 앱 만드는 간단한 안내서\n\n안녕하세요! 코딩과 기술을 좋아하는 미디엄 친구 여러분!\n\n미디엄에서 텍스트 음성 변환 기능을 시도해 보신 적이 있나요? 정말 멋진 기능이죠, 그렇죠? 버튼을 누르기만 하면 글을 읽는 대신에 들을 수 있어요. 그렇게 하면 내용을 즐기면서 다른 일을 할 수도 있어요.\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_2.png)\n\n\n\n이 기능 덕분에 새로운 기사 아이디어가 떠올랐어요. 그래서 이 기능이 어떻게 작동하는지 보여주고 여러분께 자신만의 기능을 만드는 방법을 가르쳐주기로 결심했어요.\n\n이 기사에서는 JavaScript와 Web Speech API만을 사용하여 어떻게 재미있는 텍스트 음성 변환 앱을 만들 수 있는지 단계별로 보여드릴 거에요. 끝나면 브라우저에서 어떤 텍스트든 음성으로 변환할 수 있게 되며 음성과 속도를 선택할 수도 있을 거예요.\n\n준비됐나요? 시작해볼까요?\n\n# JavaScript로 텍스트 음성 변환 애플리케이션 만들기\n\n\n\n<img src=\"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_3.png\" />\n\n텍스트 음성 변환 (TTS) 시스템은 일반 언어 텍스트를 음성으로 변환합니다.\n\n이제 JavaScript를 사용하여 간단한 텍스트 음성 변환 애플리케이션을 만들어 보겠습니다. 구체적으로는 Web Speech API의 Speech Synthesis 인터페이스를 사용할 것입니다. 이 인터페이스는 거의 모든 최신 브라우저에서 지원되며 우리의 애플리케이션에 완벽합니다.\n\n시작하기 전에 JavaScript와 HTML의 기본적인 이해와 ES6 기능에 대한 친숙함이 있으면 더 좋을 것입니다.\n\n\n\n## 단계 1: HTML 구조 설정\n\n새 HTML 파일을 만들고 index.html로 저장하세요.\n\n먼저 텍스트를 입력하고 음성 기능을 실행할 수 있는 간단한 사용자 인터페이스를 설정해보겠습니다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>JavaScript 텍스트 음성 변환</title>\n    <style>\n        body {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            font-family: Arial, sans-serif;\n        }\n\n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"container\">\n        <textarea id=\"text\" rows=\"5\" cols=\"30\"></textarea>\n        <button id=\"speak\">음성 변환</button>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n\n</html>\n```\n\n\n\nHTML 코드에서 사용자 입력을 받을 수 있는 텍스트 영역과 텍스트를 음성으로 변환하는 버튼을 추가했고, 다음 단계에서 생성할 'app.js'라는 JavaScript 파일을 링크했습니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_4.png)\n\n## 단계 2: JavaScript 구현하기\n\n이제 기능을 추가해봅시다. HTML 파일과 동일한 디렉토리에 새 JavaScript 파일을 만들어 'app.js'로 이름짓어주세요.\n\n\n\n스피치 합성 API는 window.speechSynthesis 객체를 통해 노출됩니다. 다음은 기본 구현입니다:\n\n```js\nconst textarea = document.getElementById('text');\nconst speakButton = document.getElementById('speak');\n\nspeakButton.addEventListener('click', () => {\n    let text = textarea.value;\n    let utterance = new SpeechSynthesisUtterance(text);\n\n    speechSynthesis.speak(utterance);\n});\n```\n\n이 스크립트는 다음을 수행합니다:\n\n- DOM에서 textarea와 버튼 엘리먼트를 선택합니다.\n- 버튼에 클릭 이벤트 리스너를 추가합니다. 버튼을 클릭하면 이벤트 리스너가:\n- 텍스트 영역의 현재 값 가져옵니다.\n- 텍스트 영역의 값으로 새로운 SpeechSynthesisUtterance 객체를 생성합니다.\n- 이 SpeechSynthesisUtterance를 speechSynthesis.speak 메서드에 전달하여 음성 합성을 시작합니다.\n\n\n\n## 단계 3: 음성 및 발화 속도 사용자화\n\nSpeechSynthesisUtterance 객체를 통해 음성, 음조, 발화 속도 등의 속성을 변경할 수 있습니다. 그러나 이를 구현하는 방법을 살펴보겠습니다.\n\n먼저, 음성 선택 및 발화 속도 제어를 위한 새로운 요소를 추가하기 위해 HTML을 수정해주세요:\n\n```js\n<!-- ...기존 HTML... -->\n<div class=\"container\">\n    <textarea id=\"text\" rows=\"5\" cols=\"30\"></textarea>\n    <select id=\"voices\"></select>\n    <input id=\"rate\" type=\"range\" min=\"0.5\" max=\"2\" value=\"1\" step=\"0.1\" />\n    <button id=\"speak\">말하기</button>\n</div>\n<!-- ...기존 HTML... -->\n```\n\n\n\n그럼 app.js를 다음과 같이 업데이트하세요:\n\n```js\nconst textarea = document.getElementById('text');\nconst speakButton = document.getElementById('speak');\nconst voicesSelect = document.getElementById('voices');\nconst rateInput = document.getElementById('rate');\n\nlet voices = [];\n\nfunction populateVoices() {\n    voices = speechSynthesis.getVoices();\n    voices.forEach((voice, i) => {\n        let option = document.createElement('option');\n        option.value = i;\n        option.textContent = `${voice.name} (${voice.lang})`;\n        voicesSelect.appendChild(option);\n    });\n}\n\nspeechSynthesis.addEventListener('voiceschanged', populateVoices);\n\nspeakButton.addEventListener('click', () => {\n    let text = textarea.value;\n    let utterance = new SpeechSynthesisUtterance(text);\n\n    // 선택한 음성 가져오기\n    let selectedVoiceIndex = voicesSelect.value;\n    utterance.voice = voices[selectedVoiceIndex];\n\n    // 속도 가져오기\n    utterance.rate = rateInput.value;\n\n    speechSynthesis.speak(utterance);\n});\n```\n\n여기서는 모든 사용 가능한 음성으로 select 요소를 채우는 populateVoices 함수를 추가했으며, 'voiceschanged' 이벤트가 트리거될 때 이 함수를 호출합니다. 'voiceschanged' 이벤트는 speechSynthesis.getVoices() 메소드가 반환할 SpeechSynthesisVoice 객체 목록이 변경되었을 때 발생합니다.\n\n음성 합성을 트리거할 때 우리는 선택한 음성과 속도를 DOM에서 가져와서 SpeechSynthesisUtterance 객체에 설정합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_5.png)\n\n이제 위의 사진에 나와 있는 대로 작동하는 텍스트 음성 변환 애플리케이션이 준비되었어요: 텍스트 영역에 원하는 텍스트를 입력하고, 음성을 선택하고 말 속도를 조절한 다음 \"음성 출력\"을 클릭하면 말이 들릴 거예요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:732/1*EImZrlDQ1zrxaKe9FBPPmA.gif)\n\n## 더 알아보기:\n\n\n\n# 마무리\n\n![text-to-speech-app](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_6.png)\n\n그러면 JavaScript와 Web Speech API를 사용하여 몇 분 안에 만든 간단하고 재미있는 텍스트 음성 변환 앱이 준비됐어요!\n\n이것은 사용자들이 콘텐츠를 독특하고 접근성 있게 소비하는 것과 같이 Medium이 하는 대로 당신의 웹 애플리케이션의 사용자 경험을 향상시키는 멋진 방법이 될 수 있어요.\n\n\n\n만약 JavaScript와 웹 개발의 다른 측면을 더 탐구하고 싶다면, 내 다른 기사들을 꼭 확인해보시길 권해드립니다.\n\n텍스트 음성 변환에 대해 이야기할 때, 이제 텍스트 강조 기능을 구현해보는 것이 좋겠네요. \"AWS Polly를 활용한 클라우드 기반 텍스트 음성 변환 및 텍스트 강조 생성 애플리케이션 구축\"에 해당하는 제 기사를 참고해보세요. 이 기사는 클라우드 기술을 통해 진보된, 확장 가능하고 이용하기 쉬운 텍스트 음성 변환 솔루션을 만드는 방법을 안내합니다. 그리고 AWS Polly는 친근하고 쉬운 도구입니다.\n\n반면에 UI 게임을 업그레이드하고 싶다면, “UI 디자인 마스터하기: 최고의 실천 지침 완전 가이드\"를 놓치지 마세요. 이 포괄적인 안내서는 UI 디자인의 힘을 발휘하며, 웹 및 모바일 플랫폼을 위한 직관적이고 사용자 친화적, 매력적인 인터페이스를 만드는 통찰을 제공합니다.\n\n<img src=\"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_7.png\" />\n\n\n\n# 리고처럼 재사용 가능한 구성 요소로 애플리케이션 만들기\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_8.png)\n\nBit의 오픈 소스 도구는 25만 명 이상의 개발자들이 구성 요소로 애플리케이션을 만들 수 있게 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 구성 요소로 변환하고 애플리케이션 간에 공유하세요. 협업이 더 쉬워지고 더 빠르게 개발할 수 있습니다.\n\n\n\n→ 더 많은 정보 알아보기\n\n앱을 구성 요소로 분할하여 앱 개발을 더 쉽게 만들고, 원하는 워크플로에 대해 최상의 경험을 누려보세요:\n\n# → 미크로 프론트엔드\n\n# → 디자인 시스템\n\n\n\n# → 코드 공유 및 재사용\n\n# → 단일 저장소\n\n# Learn more:","ogImage":{"url":"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png","tag":["Tech"],"readingTime":7},{"title":"Jupyter 노트북에 현대적 JavaScript 가져오기","description":"","date":"2024-05-14 16:02","slug":"2024-05-14-BringingModernJavaScripttotheJupyterNotebook","content":"\n\n## Deno 커널은 주피터를 위한 가장 최신 런타임이에요\n\n정말 예상치 못한 소식이죠.\n\nDeno는 TypeScript, JavaScript, npm 및 ES 모듈을 갖추고 있어 주피터에 쉽게 설치할 수 있는 커널을 제공해요.\n\n지금 Deno를 시작하는 더 좋은 때는 없어요. Deno를 설치한 후, deno 주피터 커널 설치를 실행하세요:  \n\n\n\n```js\ndeno jupyter --unstable --install\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*_KUkFmq1lO3H-tx4XJPNew.gif)\n\nDeno는 fetch와 같은 웹 표준을 기본적으로 지원하므로 데이터 로딩이 간단하고 쉽습니다.\n\n![image](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png)\n\n\n\n\n이것은 빠르고 안전한 런타임일뿐만 아니라 즐거운 시간을 보낼 수 있습니다. 타이밍도 훌륭합니다 — 데이터프레임은 줄리아, 파이썬, R 및 러스트만의 전유물이 아닙니다. Polars는 JavaScript용 데이터프레임을 제공합니다.\n\n![이미지1](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_1.png)\n\n놀라운 점은 얼마나 쉽게 D3를 데이터프레임과 함께 사용할 수 있는지입니다.\n\n![이미지2](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_2.png)\n\n\n\n우리는 캔버스에 직접 플롯을 그릴 수 있어요.\n\n![plot1](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_3.png)\n\n또한 SVG를 출력하는 어떤 라이브러리도 사용할 수 있지요.\n\n![plot2](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_4.png)\n\n\n\n이것은 다양한 JavaScript 개발자와 데이터 전문가들이 노트북에서 문서 작성을 할 수 있도록 함을 의미합니다.\n\nJavaScript/TypeScript로 데이터를 탐색하고 시각화하려면 Deno를 확인하고 Jupyter 시작 가이드 문서를 살펴보세요.\n\nRust를 알고 있다면 Deno에서 해킹해보세요. Rust를 몰라도, 나와 같은 경우라도 Deno에서 해킹해보세요. 배울 수 있습니다. Deno 팀은 TypeScript, Jupyter 및 표준의 힘을 깊이 믿는 친절한 사람들로 구성되어 있습니다.\n\n또한 버그를 보고하고, 노트북을 작성하고, Deno 커널을 다른 사람들과 공유함으로써 기여할 수도 있습니다.\n\n\n\n\n![Bringing Modern JavaScript to the Jupyter Notebook](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_5.png)\n\n해피 노트북!\n","ogImage":{"url":"/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png"},"coverImage":"/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png","tag":["Tech"],"readingTime":2},{"title":"디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내","description":"","date":"2024-05-14 15:59","slug":"2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode","content":"\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png)\n\n## 소프트웨어 개발 원칙\n\n# 소개 — JavaScript 디자인 패턴\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_1.png)\n\n\n\n## 디자인 패턴의 본질\n\n안녕하세요 여러분! 저는 시니어 소프트웨어 엔지니어로 활동한 지 오랜 시간이 되었지만, 깔끔하고 확장 가능한 코드를 작성하는 데 있어 단순히 무엇을 만드냐 보다는 코드의 구조가 중요하다는 것을 깨닫게 되었습니다. 여기서 디자인 패턴이 중요한 역할을 한다는 사실을 발견했습니다.\n\n## 디자인 패턴 — 무엇인가요?\n\n디자인 패턴은 소프트웨어 개발 중에 흔히 발생하는 문제에 대한 검증된 해결책으로, 코드 구조를 안내하는 템플릿 역할을 하여 우리가 코드를 구조화하는 데 도움을 줍니다. 디자인 패턴을 사용하면 더 읽기 쉽고 유연하며 유지보수하기 쉬운 코드를 작성하는 것이 쉬워지며, 개발자들이 더 효과적으로 소통할 수 있는 일종의 공통 언어를 제공하기도 합니다.\n\n\n\n## 자바스크립트 디자인 패턴의 힘\n\n자바스크립트는 다양한 프로그래밍 스타일을 지원하여 다재다능하며, 이는 중요한 장점이지만 동시에 언어를 혼란스럽게 만들 수도 있습니다. 그러나 디자인 패턴은 코드를 조직화하고 효율적으로 유지할 수 있는 방법을 제공합니다.\n\n다음 섹션에서는 자바스크립트 디자인 패턴을 더 깊게 탐색하며, 생성, 구조 및 행동 패턴을 탐구하고 각 유형에 대한 실용적인 예제를 제공하며 장단점 및 잠재적인 위험을 논의할 것입니다.\n\n# 자바스크립트 디자인 패턴 유형 탐색\n\n\n\n![image](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_2.png)\n\n## 생성 디자인 패턴: 객체 생성\n\nJavaScript에서 객체는 핵심 기능이며 종종 유사한 특성을 갖는 개체 또는 것들을 나타내는 데 사용됩니다. 이러한 객체의 생성을 조직화하기 위해 생성 디자인 패턴을 사용합니다.\n\n생성 패턴은 객체의 생성, 구성 및 표현 방식과는 독립적인 시스템을 만들어 인스턴스화 프로세스를 추상화하는 데 도움을 줍니다.\n\n\n\n공장 패턴\n\n공장 패턴은 객체를 생성하는 방법을 제공하지만 하위 클래스가 생성될 객체의 유형을 변경할 수 있습니다.\n\n```js\nfunction CarFactory() {\n  this.createCar = function(model) {\n    let car;\n    if (model === '세단') {\n      car = new Sedan();\n    } else if (model === 'SUV') {\n      car = new SUV();\n    }\n    return car;\n  };\n}\n```\n\n싱글톤 패턴\n\n\n\n싱글톤 패턴은 클래스가 여러 객체를 생성하는 것을 제한하며, 특정 동작을 제어해야 할 때 유용합니다.\n\n```js\nlet Singleton = (function () {\n  let instance;\n \n  function createInstance() {\n    return new Object(\"I am the instance\");\n  }\n \n  return {\n    getInstance: function () {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n```\n\n빌더 패턴\n\n빌더 패턴은 클라이언트가 타입과 내용에만 집중해 복잡한 객체를 구축할 수 있도록 하고, 객체를 조립하는 작업을 관리합니다.\n\n\n\n```js\nfunction CarBuilder() {\n  this.car = null;\n\n  this.step1 = function () {\n    this.car = new Car();\n  };\n\n  this.step2 = function () {\n    this.car.addParts();\n  };\n\n  this.get = function () {\n    return this.car;\n  };\n}\n```\n\n## 구조적 디자인 패턴: 코드 모양을 만드는 방법\n\n구조적 패턴은 서로 다른 클래스와 객체를 조직화하여 더 큰 구조를 형성하는 것에 관한 것이며 시스템의 한 부분이 변경될 때 전체 시스템이 함께 바뀌지 않도록 보장합니다.\n\n어댑터 패턴```\n\n\n\n어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스가 함께 작동할 수 있도록 객체 주변에 래핑하고 해당 객체와 상호 작용하는 표준 인터페이스를 노출하는 것을 가능하게 합니다.\n\n```js\nclass OldCalculator {\n  constructor() {\n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          return term1 + term2;\n        case 'sub':\n          return term1 - term2;\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n\nclass NewCalculator {\n  constructor() {\n    this.add = function(term1, term2) {\n      return term1 + term2;\n    };\n    this.sub = function(term1, term2) {\n      return term1 - term2;\n    };\n  }\n}\n\nclass CalculatorAdapter {\n  constructor() {\n    const newCalc = new NewCalculator();\n    \n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          return newCalc.add(term1, term2);\n        case 'sub':\n          return newCalc.sub(term1, term2);\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n```\n\n데코레이터 패턴\n\n데코레이터 패턴은 동일한 클래스의 다른 객체들의 행동에 영향을 미치지 않고 특정 개체에 정적 또는 동적으로 추가할 동작을 설명합니다.\n\n\n\n```js\nfunction Car(name) {\n  this.name = name;\n}\n\nCar.prototype.getName = function () {\n  return this.name;\n};\n\nfunction DecoratedCar(car, color, price) {\n  this.car = car;\n  this.color = color;\n  this.price = price;\n}\n\nDecoratedCar.prototype.getName = function () {\n  return this.car.getName() + ' has color ' + this.color + ' and price ' + this.price;\n};\n```\n\n프록시 패턴\n\n프록시 패턴은 원본 객체에 대한 액세스를 제어하기 위해 대리자 또는 플레이스홀더 객체를 제공합니다.\n\n```js\nfunction NetworkAccess() {\n  this.connect = function () {\n    console.log('네트워크에 연결되었습니다.');\n  };\n}\n\nfunction NetworkProxy() {\n  this.network = new NetworkAccess();\n  this.connect = function () {\n    console.log('네트워크 프록시를 사용합니다.');\n    this.network.connect();\n  };\n}\n```\n\n\n\n## 행동 디자인 패턴: 객체 협업 관리\n\n행동 디자인 패턴은 객체 간 통신에 관심을 가지며, 객체들이 작동하고 책임을 수행하는 방식에 대해 다룹니다. 대부분의 경우 객체 간 통신을 유연하게 처리할 수 있도록 돕습니다.\n\n옵저버 패턴\n\n옵저버 패턴은 객체 간의 일대다 종속성을 정의하여 한 객체의 상태가 변경되면 해당 객체에 의존하는 모든 객체가 자동으로 통지되고 업데이트됩니다.\n\n\n\n```js\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    unsubscribe(observer) {\n        const index = this.observers.indexOf(observer);\n        if (index > -1) {\n            this.observers.splice(index, 1);\n        }\n    }\n\n    notifyAll(data) {\n        for (let i = 0; i < this.observers.length; i++) {\n            this.observers[i].notify(data);\n        }\n    }\n}\n\nclass Observer {\n    notify(data) {\n        console.log(`Observer received: ${data}`);\n    }\n}\n```\n\n전략 패턴\n\n전략 패턴은 클라이언트가 인식하지 못하고 메서드(전략)를 런타임에 다른 메서드로 교체할 수 있게 하는 것을 가능하게 합니다. 이것은 교환 가능한 알고리즘 그룹입니다.\n\n```js\nclass Shipping {\n    setStrategy(strategy) {\n        this.strategy = strategy;\n    }\n\n    calculate(parcel) {\n        return this.strategy.calculate(parcel);\n    }\n}\n\nclass UPS {\n    calculate(parcel) {\n        return `$${parcel.weight * 1.75}`;\n    }\n}\n\nclass FedEx {\n    calculate(parcel) {\n        return `$${parcel.weight * 2.45}`;\n    }\n}\n\nclass USPS {\n    calculate(parcel) {\n        return `$${parcel.weight * 1.25}`;\n    }\n}\n```\n\n\n\n## 커맨드 패턴\n\n커맨드 패턴은 요청의 구체적인 내용을 알지 못한 채로 작업을 객체에 캡슐화하는 기능을 제공합니다.\n\n```js\nclass Switch {\n  execute(command) {\n    command.execute();\n  }\n}\n\nclass TurnOnCommand {\n  constructor(light) {\n    this.light = light;\n  }\n\n  execute() {\n    this.light.turnOn();\n  }\n}\n\nclass Light {\n  turnOn() {\n    console.log('불이 켜졌습니다');\n  }\n\n  turnOff() {\n    console.log('불이 꺼졌습니다');\n  }\n}\n```\n\n다음 섹션에서 이러한 패턴이 실제 JavaScript 애플리케이션에서 어떻게 사용되며 깔끔하고 확장 가능한 코드를 어떻게 이끌어내는지 알아보겠습니다.\n\n\n\n# JavaScript 디자인 패턴의 실제 응용\n\n![Design Patterns](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_3.png)\n\n디자인 패턴은 강력한 도구입니다. 하지만 실제 상황에서 그들의 응용을 통해 우리는 그들의 힘을 진정으로 이해할 수 있고, 이를 보여주기 위해 우리가 논의한 패턴 중 일부가 실제 상황에서 어떻게 활용될 수 있는지 살펴봅시다.\n\n## 사용자 프로필 생성\n\n\n\n사회적 미디어 사이트를 위한 사용자 프로필 시스템을 만드는 작업이 있다고 상상해보세요: Factory 패턴을 사용하면 미리 정의된 템플릿을 사용하여 프로필을 만들어 프로세스를 간소화할 수 있습니다.\n\n```js\nfunction UserFactory() {\n  this.createUser = function(type) {\n    let user;\n\n    if (type === '개인') {\n      user = new PersonalUser();\n    } else if (type === '비즈니스') {\n      user = new BusinessUser();\n    }\n\n    user.type = type;\n    user.say = function() {\n      console.log(this.type + \": 프로필이 생성되었습니다\");\n    }\n    return user;\n  }\n}\n```\n\n## 제3자 API와의 통합\n\n다른 상황에서는 응용 프로그램에 제3자 API를 통합해야 할 필요가 있다고 상상해보세요. 그러나 이 API의 인터페이스가 응용 프로그램의 기존 시스템과 일치하지 않는 경우: Adapter 패턴을 사용하여 기존 코드베이스를 변경하지 않고 API를 응용 프로그램과 호환되도록 만들 수 있습니다.\n\n\n\n```md\n```js\nclass ThirdPartyAPI {\n  constructor() {\n    this.specificRequest = function() {\n      return \"Third-party API response\";\n    };\n  }\n}\n\nclass Adapter {\n  constructor(thirdPartyAPI) {\n    this.request = function() {\n      return thirdPartyAPI.specificRequest();\n    };\n  }\n}\n\n// Using the Adapter\nconst thirdPartyAPI = new ThirdPartyAPI();\nconst adapter = new Adapter(thirdPartyAPI);\nadapter.request();\n```\n\n## 사용자 프로필에 기능 추가하기\n\nDecorator Pattern은 사용자 프로필에 프리미엄 뱃지나 사용자 정의 테마와 같은 새로운 기능을 추가하고 원래의 사용자 객체를 변경하지 않고 싶을 때 적용할 수 있습니다.\n\n```js\nfunction User(name) {\n  this.name = name;\n}\n\nUser.prototype.getName = function () {\n  return this.name;\n};\n\nfunction DecoratedUser(user, badge, theme) {\n  this.user = user;\n  this.badge = badge;\n  this.theme = theme;\n}\n\nDecoratedUser.prototype.getName = function () {\n  return `${this.user.getName()}, Badge: ${this.badge}, Theme: ${this.theme}`;\n};\n```\n\n\n\n## 게시물과 사용자 상호작용\n\n옵저버 패턴은 사용자가 게시물과 상호작용할 수 있는 시스템을 구현해야 할 때 유용합니다. 사용자가 게시물을 좋아하거나 댓글을 달 수 있는 경우, 각 게시물이 주제로 작용하고 다른 사용자가 상호작용을 통지받는 관찰자로 작용할 수 있습니다.\n\n```js\nclass Post {\n  constructor() {\n    this.observers = [];\n  }\n\n  like(user) {\n    this.notifyAll(`게시물이 ${user}님에 의해 좋아요!`);\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  notifyAll(message) {\n    for (let observer of this.observers) {\n      observer.notify(message);\n    }\n  }\n}\n\nclass User {\n  notify(message) {\n    console.log(`사용자에게 알림: ${message}`);\n  }\n}\n```\n\n## 다양한 배송 방법\n\n\n\n이제 전자 상거래 애플리케이션이 다른 배송 방법을 지원해야 하는 경우를 가정해 보겠습니다: 각 배송 방법을 별도의 전략으로 구현할 수 있기 때문에 Strategy Pattern은 이 경우에 완벽합니다.\n\n```js\nclass Shipping {\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(parcel) {\n    return this.strategy.calculate(parcel);\n  }\n}\n\nclass UPS {\n  calculate(parcel) {\n    return `$${parcel.weight * 1.75}`;\n  }\n}\n\nclass FedEx {\n  calculate(parcel) {\n    return `$${parcel.weight * 2.45}`;\n  }\n}\n\nclass USPS {\n  calculate(parcel) {\n    return `$${parcel.weight * 1.25}`;\n  }\n}\n```\n\n## 웹사이트 테마 사용자 정의\n\n사용자가 테마를 사용자 정의할 수 있는 웹사이트가 있다고 상상해보세요. 여러 테마 객체를 만들기 위해 Factory Pattern을 사용하고, 그 테마에 추가 기능을 추가하기 위해 Decorator Pattern을 사용할 수 있습니다.\n\n\n\n```js\n// 팩토리 패턴\nfunction ThemeFactory() {\n  this.createTheme = function(type) {\n    let theme;\n\n    if (type === 'Dark') {\n      theme = new DarkTheme();\n    } else if (type === 'Light') {\n      theme = new LightTheme();\n    }\n\n    theme.type = type;\n    return theme;\n  }\n}\n\n// 데코레이터 패턴\nfunction DecoratedTheme(theme, color) {\n  this.theme = theme;\n  this.color = color;\n}\n\nDecoratedTheme.prototype.getName = function () {\n  return this.theme.getName() + ' in ' + this.color + ' color';\n};\n```\n\n## 할인 이벤트가 적용된 전자 상거래 사이트\n\n전자 상거래 사이트를 상상해보세요. 여러분은 제품에 특별 할인 이벤트를 적용하는 시스템을 구현하려고 합니다. 여기서는 다양한 종류의 특별 할인을 나타내기 위해 전략 패턴을 사용하고 관심 있는 제품에 특별 할인이 적용될 때 고객들에게 알리기 위해 옵서버 패턴을 사용할 수 있습니다.\n\n```js\n// 전략 패턴\nclass SpecialOffer {\n  apply(product) {\n    // abstract method\n  }\n}\n\nclass BlackFridayOffer extends SpecialOffer {\n  apply(product) {\n    product.price *= 0.8;  // 20% 할인\n  }\n}\n\nclass ChristmasOffer extends SpecialOffer {\n  apply(product) {\n    product.price *= 0.85;  // 15% 할인\n  }\n}\n\n// 옵서버 패턴\nclass Product {\n  constructor(price) {\n    this.price = price;\n    this.observers = [];\n  }\n\n  setPrice(price) {\n    this.price = price;\n    this.notifyAll();\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  notifyAll() {\n    for (let observer of this.observers) {\n      observer.notify(this);\n    }\n  }\n}\n\nclass Customer {\n  notify(product) {\n    console.log(`제품 가격이 $${product.price}로 업데이트되었습니다.`);\n  }\n}\n```\n\n\n\n## 성능 모니터링 시스템\n\n알겠어요, 그럼 어떤 응용 프로그램의 다른 모듈의 성능을 모니터링하는 시스템을 구축한다고 생각해봅시다. 이러한 모듈은 Factory Pattern을 사용하여 나타낼 수 있으며 이러한 모듈의 성능을 관찰하고 문제를 보고하려면 Proxy Pattern을 사용할 수 있습니다.\n\n```js\n// Factory Pattern\nfunction ModuleFactory() {\n  this.createModule = function(type) {\n    let module;\n\n    if (type === 'Database') {\n      module = new DatabaseModule();\n    } else if (type === 'Network') {\n      module = new NetworkModule();\n    }\n\n    module.type = type;\n    return module;\n  }\n}\n\n// Proxy Pattern\nclass PerformanceProxy {\n  constructor(module) {\n    this.module = module;\n  }\n\n  monitor() {\n    console.log('성능 모니터링 중...');\n    // 호출을 원래 객체로 위임합니다.\n    this.module.monitor();\n  }\n}\n```\n\n## 채팅 애플리케이션\n\n\n\n매우 흔한 채팅 애플리케이션에서는 ChatRoom 클래스의 인스턴스가 하나만 있는지를 보장하기 위해 싱글톤 패턴을 사용할 수 있으며, 각 사용자는 옵서버가 되어 다른 사용자가 메시지를 보낼 때마다 메시지를 수신할 수 있습니다.\n\n```js\n// 싱글톤 패턴\nlet ChatRoom = (function() {\n  let instance;\n\n  function createInstance() {\n    let object = new Object(\"ChatRoom\");\n    return object;\n  }\n\n  return {\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\n// 옵서버 패턴\nclass User {\n  notify(message) {\n    console.log(`Received message: ${message}`);\n  }\n}\n```\n\n## 온라인 게임 시스템\n\n온라인 게임 시스템과 같은 다른 예시에서는 게임 캐릭터의 다른 유형을 생성하기 위해 팩토리 패턴을 사용할 수 있고, 캐릭터가 맞았을 때 다른 플레이어에게 알리기 위해 옵서버 패턴을 사용할 수 있으며, 캐릭터에 특별 능력을 추가하기 위해 데코레이터 패턴을 사용할 수 있습니다.\n\n\n\n```js\n// Factory Pattern\nfunction CharacterFactory() {\n  this.createCharacter = function(type) {\n    let character;\n\n    if (type === 'Warrior') {\n      character = new Warrior();\n    } else if (type === 'Mage') {\n      character = new Mage();\n    }\n\n    character.type = type;\n    return character;\n  }\n}\n\n// Observer Pattern\nclass Character {\n  hit() {\n    // Notify all observers\n  }\n}\n\n// Decorator Pattern\nfunction EnhancedCharacter(character, ability) {\n  this.character = character;\n  this.ability = ability;\n}\n\nEnhancedCharacter.prototype.useAbility = function() {\n  console.log(`Using ability: ${this.ability}`);\n}\n```\n\nThese examples demonstrate the power of combining different design patterns to create a flexible and scalable solution, but remember: the key is not to force the use of patterns, it’s to identify when a pattern can improve code quality and maintainability.\n\n# Design Patterns를 사용할 때 피해야 할 함정\n\n![Design Patterns](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_4.png)\n\n\n\n\n디자인 패턴은 소프트웨어 개발 프로세스에서 중대한 차이를 만들어낼 수 있지만, 모든 도구와 마찬가지로 신중하게 사용해야 합니다.\n\n다음은 피해야 할 몇 가지 일반적인 함정입니다:\n\n## 디자인 패턴 과용\n\n디자인 패턴은 흔한 문제에 대한 해결책이지만, 모든 소프트웨어 개발 고민의 치료약은 아니기 때문에 필요하지 않은 곳에 사용하면 불필요하게 복잡하고 난해한 코드로 이어질 수 있습니다.\n\n\n\n## 디자인 패턴 오용\n\n각 디자인 패턴은 빛을 발하는 특정 시나리오가 있으며, 그것이 맞지 않는 문맥에서 사용하면 혼란스럽고 유지보수하기 어려운 코드로 이어질 수 있습니다.\n\n## 패턴을 완전히 이해하지 못한 경우\n\n디자인 패턴을 사용하기 전에 그 구조, 목적 및 영향을 완전히 이해하는 것이 중요합니다. 이해하지 못하면 잘못된 구현 및 디버깅하기 어려운 버그로 이어질 수 있습니다.\n\n\n\n## 간단함의 원칙을 무시하다\n\nKISS (Keep It Simple, Stupid) 원칙은 소프트웨어 개발에서 중요한 요소이며 항상 강조하는 편입니다: 때로는 복잡한 디자인 패턴보다 간단한 절차적 해결책이 더 적합할 수 있습니다.\n\n# 요약 및 권장 사항\n\n![](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_5.png)\n\n\n\n본질적으로 디자인 패턴은 반복되는 코딩 문제에 효율적인 해결책을 제공합니다. 그러나 이를 남용하지 않는 것이 중요합니다. 남용하거나 이해없이 적용하면 코드가 불필요하게 복잡해질 수 있습니다.\n\n## 추가 학습\n\n지속적인 학습과 능력 향상을 위해 다양한 디자인 패턴을 실험하고, 강점과 약점을 이해하며 효율적으로 사용할 수 있는 방법을 찾아보세요.\n\n자바스크립트에 더 깊이 파고들고 싶은 분들을 위해, 저의 라이브러리에서 이 글들을 추천합니다: \"JavaScript 오브젝트 구조 분해와 스프레드 구문 활용: Use Case 및 Best Practice\" 그리고 \"JavaScript Promises: 에러 처리와 Best Practice에 대한 깊은 탐구\"\n\n\n\n두 기사 모두 JavaScript의 특정 측면에 대한 실용적인 통찰을 제공하여 디자인 패턴과 같이 개발 작업을 향상시킬 수 있습니다.\n\n항상 여러분의 이야기를 듣는 것에 흥미가 있어요. 댓글에서 여러분의 생각, 경험 또는 질문을 공유해주세요. 우리는 서로서로에서 배우고, 여러분의 통찰은 커뮤니티에 도움이 될 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_6.png)\n\nPlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.\n\n\n\n우리의 무료 주간 뉴스레터를 구독하세요. 트위터, 링크드인, 유튜브, 디스코드에서도 팔로우하세요.","ogImage":{"url":"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png"},"coverImage":"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png","tag":["Tech"],"readingTime":15}],"page":"18","totalPageCount":71,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}