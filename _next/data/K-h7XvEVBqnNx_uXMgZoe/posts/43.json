{"pageProps":{"posts":[{"title":"Nodejs가 더욱 쉬워졌어요 env 파일에 대한 네이티브 지원","description":"","date":"2024-05-12 23:19","slug":"2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles","content":"\n\n\n![Node.js Gets Even Easier Native Support for env Files](/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png)\n\nNode.js 작업을 한다면 환경 변수 사용법에 익숙할 것입니다. 다양한 환경(개발, 테스트, 프로덕션)에서 설정을 관리하거나 민감한 데이터를 저장하는 데 사용되는 것으로 추측됩니다.\n일반적으로.env 파일에서 이러한 변수를 로드하는 전통적인 방법은 이전에 \"dotenv\"와 같은 패키지를 설치해야 했습니다.\n\n하지만 Node.js v20.6.0부터 상황이 바뀌었습니다! 지금은.env 파일이 네이티브로 지원됩니다.\n\n왜 중요한 이유인가요\n\n\n\n- 더 간단한 설정: 더 적은 외부 종속성을 갖는 경량 구조의 프로젝트입니다.\n- 표준화: .env 파일을 사용하는 것이 일반적이며, 네이티브 지원이 있어서 Node.js 코드를 다양한 백그라운드를 갖는 개발자가 이해하기 쉬워집니다.\n- 다양한 구성: 다른 환경 간에 쉽게 전환하기 위해 다른 .env 파일을 활용합니다.\n\n사용 방법\n\n- .env 파일 생성: 프로젝트의 루트 디렉토리에 .env이라는 일반 텍스트 파일을 추가합니다.\n- 변수 설정: KEY=VALUE와 같은 형식으로 변수를 정의합니다. 예를 들어:\nPORT=3000\n- 변수 접근: Node.js 코드에서 이들에 접근하기 위해 process.env를 사용합니다.\n- 기본 위치: Node.js는 프로젝트의 루트에서 .env 파일을 자동으로 찾습니다. 사용자 정의 위치가 필요하다면 앱을 실행할 때 --env-file 플래그를 사용하세요 (예: node app.js --env-file=./config/.env).\n\n단순함을 환영합니다.\n\n\n\n이 작은 변경은 다른 프레임워크에서의 표준 절차와 일치하게 만들어 Node.js 개발 프로세스를 약간 더 쉽게 만들어줍니다. 한 번 시도해 보세요!\n\nNode.js 프로젝트에서 환경 변수의 특정 응용 프로그램에 대해 논의하거나 문의 사항이 있으시면 언제든지 연락해 주세요!\n\n읽어주셔서 감사합니다 😊","ogImage":{"url":"/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png"},"coverImage":"/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png","tag":["Tech"],"readingTime":2},{"title":"DraftJS를 사용한 풍부한 텍스트 편집기","description":"","date":"2024-05-12 23:18","slug":"2024-05-12-RichTextEditorusingDraftJS","content":"\n\n그래도 봐, 요즘에는 보통의 텍스트 영역으로는 충분하지 않아. 요즘에는 가능한 모든 서식을 필요로 해서 고객들이 데이터를 인상적인 형식으로 제시할 수 있게 해야 해.\n\n그런 상황에서 draft.js가 등장해. React 앱용 멋진 텍스트 편집기야. 우리가 어떻게 고객을 위해 텍스트 영역을 흥미롭게 만들었는지 여기에 나와 있어.\n\n```js\nimport { EditorState, ContentState, convertFromHTML } from 'draft-js';\nimport { stateToHTML } from 'draft-js-export-html';\nimport React, { useEffect, useState } from 'react';\nimport { Editor } from 'react-draft-wysiwyg';\nimport 'react-draft-wysiwyg/dist/react-draft-wysiwyg.css';\n\ntype RichTextAreaProps = {\n  name: string;\n  onChange: (value: any) => void;\n  onReset?: () => void;\n  placeholder?: string;\n  reset?: boolean;\n  value: string;\n};\n\nconst RichTextArea: React.FC<RichTextAreaProps> = ({\n  name,\n  onChange,\n  value,\n  placeholder = 'Enter Details',\n  reset,\n  onReset,\n}) => {\n  const [editorState, setEditorState] = useState(EditorState.createEmpty());\n\n  const handleEditorChange = (newEditorState) => {\n    setEditorState(newEditorState);\n\n    const rawContentState = editorState.getCurrentContent();\n    const html = stateToHTML(rawContentState);\n\n    onChange({\n      target: {\n        name,\n        value: html,\n      },\n    });\n  };\n\n  useEffect(() => {\n    const blocksFromHTML = convertFromHTML(value);\n    const contentState = ContentState.createFromBlockArray(blocksFromHTML);\n    setEditorState(EditorState.createWithContent(contentState));\n  }, []);\n\n  useEffect(() => {\n    if (reset) {\n      setEditorState(EditorState.createEmpty());\n\n      const blocksFromHTML = convertFromHTML(value);\n      const contentState = ContentState.createFromBlockArray(blocksFromHTML);\n\n      setEditorState(EditorState.createWithContent(contentState));\n      onReset();\n    }\n  }, [reset]);\n\n  return (\n    <div className=\"w-full bg-white p-2\">\n      <Editor\n        name={name}\n        placeholder={placeholder}\n        editorState={editorState}\n        onEditorStateChange={handleEditorChange}\n        toolbar={{\n          options: ['inline', 'fontSize', 'list', 'textAlign', 'link', 'image'],\n          inline: {\n            options: ['bold', 'italic', 'underline'],\n          },\n          list: {\n            options: ['unordered', 'ordered'],\n          },\n          textAlign: {\n            options: ['left', 'center', 'right'],\n          },\n          link: {\n            defaultTargetOption: '_blank',\n          },\n          image: {\n            defaultSize: {\n              height: 'auto',\n              width: '100%',\n            },\n          },\n        }}\n      />\n    </div>\n  );\n};\n\nexport default RichTextArea;\n```\n\n- Editor는 draft.js에서 제공하는 구성요소야. 그냥 그것을 추가함으로써 기본 툴바가 있는 리치 텍스트 편집기를 얻을 수 있어.\n- 툴바 prop을 사용하면 툴바에 표시하고 싶은 모든 형식을 사용자 정의할 수 있어.\n- editorState는 사용자가 편집기에 입력하는 상태나 내용을 제어하는 것이야.\n- Editor는 사실 formik과 연결돼 있어서 이름과 onChange 호출을 처리해.\n- 기본적으로 편집기는 EditorState 객체를 반환하는데, 이를 의미 있게 만들기 위해 stateToHTML(rawContentState) 호출을 통해 HTML로 변환해야 해.\n- 반대로 백엔드로 전송할 때 HTML로 변환되는 EditorState 객체에서 데이터를 로드할 때 ContentState.createFromBlockArray를 통해 이를 역으로 수행해야 해.\n\n\n\n```js\n<FormControl\n  label=\"피드백\"\n  error={formik.touched.response && formik.errors.response}\n>\n  <RichTextArea\n    name=\"피드백\"\n    value={formik.values.feedback}\n    onChange={formik.handleChange}\n  />\n</FormControl>\n```\n\n이렇게 `RichTextArea` 컴포넌트를 사용합니다. `FormControl`은 실제로 formik 프로바이더를 이 안에 감쌉니다.\n\n<img src=\"/assets/img/2024-05-12-RichTextEditorusingDraftJS_0.png\" />\n\n이렇게 보입니다.\n```\n\n\n\n행복한 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-RichTextEditorusingDraftJS_0.png"},"coverImage":"/assets/img/2024-05-12-RichTextEditorusingDraftJS_0.png","tag":["Tech"],"readingTime":4},{"title":"Webpack 탐험","description":"","date":"2024-05-12 23:16","slug":"2024-05-12-ExploringWebpack","content":"\n\n프론트엔드 개발자들의 삶 속에는 번들러에서 뭔가를 편집해야 하는 시기가 올 때가 있죠. 다행히 아직은 그런 날이 오지 않았지만, 여유 시간이 좀 생겨 이 키워드들을 해결해 보기로 했어요: Webpack — Craco — Bundles — Chunks — Bundle Size — Code Splitting — Dynamic imports.\n\n이 포스트를 통해 웹팩의 기본적인 것을 알아보고, 왜 현대 웹 개발에 중요한지 이해하는 데 도움이 되도록 하겠습니다.\n\n그럼 첫 번째 질문은:\n\n## 웹팩이란 무엇인가요?\n\n\n\n웹팩은 모듈 번들러입니다. 프로젝트의 파일을 하나 이상의 파일(번들)로 번들링합니다. 그런 다음 일부 추가 정리 작업(ES6를 이전 JavaScript로 변환, 최소화/압축, 트리 쉐이킹, 코드 분할, 압축 및 자산 최적화, 그리고 추가 프로덕션 모드별 최적화)을 수행하여 코드를 제품용으로 준비합니다. 요약하면, 웹팩은 개발 코드와 제품 코드 사이의 중간 매개체라고 할 수 있습니다.\n\n![이미지1](/assets/img/2024-05-12-ExploringWebpack_0.png)\n\n웹팩이 하는 또 다른 중요한 작업은 종속성을 해결하고 최종 번들에 포함하는 것입니다. 프론트엔드 프레임워크가 나오기 전의 이야기를 하나 들려드릴게요.\n\n![이미지2](/assets/img/2024-05-12-ExploringWebpack_1.png)\n\n\n\n옛날에는 HTML, CSS, 그리고 자바스크립트만 사용했던 시절, 우리가 HTML 파일을 구조화했던 방법을 기억하나요?\n\n```js\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Document</title>\n    <link rel='stylesheet' href='style.css'>\n</head>\n<body>\n    \n    <script src='script.js'></script>\n</body>\n</html>\n```\n\n만약 프로젝트에 부트스트랩을 추가하고 싶다면 어떻게 할까요?\n\n```js\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n    <meta charset='UTF-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n    <title>Document</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH\" crossorigin=\"anonymous\">\n    <link rel='stylesheet' href='style.css'>\n</head>\n<body>\n    \n    <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz\" crossorigin=\"anonymous\"></script>\n    <script src='script.js'></script>\n</body>\n</html>\n```\n\n\n\n스타일시트와 스크립트가 부트스트랩의 스타일시트와 스크립트 뒤에 위치하는 것을 알아 보았나요? 왜 그렇게 한걸까요?\n\n우리는 스타일시트가 기본 부트스트랩 스타일을 덮어쓰도록 하고 싶었거나, 스크립트의 경우에는 사용자 정의 스크립트가 웹페이지에서 마지막으로 실행되어 이전 스크립트에 덮어쓰거나 사용될 수 있도록 하고, 페이지의 나머지가 완전히 렌더링되었는지 확인하려고 합니다. 그래서 다음과 같이 무언가를 할 때:\n\n```js\ndocument.querySelector('#firstName')\n```\n\n#firstName이 DOM에 존재해야합니다. 부트스트랩 스크립트도 마찬가지입니다. 그래서 스크립트가 페이지 맨 아래에 있고 맨 위에 있지 않은 이유입니다. HTML이 추가되기 전에 자바스크립트를 추가하기를 원합니다.\n\n\n\n여기서 일부 종속성이 발생하고 있어요. 순서가 중요하며 요소는 조작하기 전에 DOM에 존재해야 합니다.\n\n현대 웹 개발에서는 HTML이나 스크립트를 작성하지 않고, HTML 헤드에 Bootstrap 링크를 추가하지 않고, 패키지를 다운로드하고, react-bootstrap과 같은 라이브러리를 사용하여 구성 요소를 파일로 가져옵니다. 맞죠?\n\n여기서 Webpack 마법이 뒤에서 일어나는 첫 번째 신비한 모습을 볼 수 있어요. 다음 코드를 참고하세요:\n\n```js\nimport Container from 'react-bootstrap/Container';\nimport Row from 'react-bootstrap/Row';\nimport Col from 'react-bootstrap/Col';\n\nfunction AutoLayoutExample() {\n  return (\n    <Container>\n      <Row>\n        <Col>1 of 2</Col>\n        <Col>2 of 2</Col>\n      </Row>\n      <Row>\n        <Col>1 of 3</Col>\n        <Col>2 of 3</Col>\n        <Col>3 of 3</Col>\n      </Row>\n    </Container>\n  );\n}\n\nexport default AutoLayoutExample;\n```\n\n\n\n자동 레이아웃 예제 컴포넌트가 올바르게 렌더링되려면 이 파일에는 존재하지 않지만 자동 레이아웃 예제 컴포넌트를 올바르게 렌더링하려면 반드시 있어야 하는 3가지 다른 컴포넌트(Container, Row 및 Col)에 의존합니다. 웹팩은 교통 담당자입니다. 컴포넌트가 사용되기 전에 해당 컴포넌트에 종속된 코드가 존재하는지 확인하여 HTML을 스크립트보다 먼저 배치하는 것과 같은 역할을 합니다.\n\n웹팩은 또한 개발 서버를 실행함으로써 프로젝트 개발을 도와줍니다. 예전에는 코드 변경을 테스트하려면 변경된 파일을 저장하고 새로고침 버튼을 눌러야 했지만, 이제는 그렇지 않습니다. 더 이상 새로고침 버튼을 클릭할 필요가 없습니다. package.json에서 start 스크립트를 실행하면 start 스크립트에 나열된 스크립트가 실행되어 WebpackDevServer의 새 인스턴스가 생성되고 컴파일러와 구성이 전달됩니다. 인스턴스의 리스너 메소드가 호출되어 포트와 호스트 값을 전달합니다. 그런 다음 콘솔을 지우고 \"개발 서버 시작 중...\"이라고 읽습니다. 브라우저는 올바른 개발 URL로 열립니다. 마지막으로 프로세스가 종료될 때 두 개의 리스너가 추가됩니다. 이는 웹 서버를 종료하고 start.js 프로세스를 종료합니다.\n내부적으로 start 스크립트는 다음과 같이 작동합니다:\n\n```\n\"start\": \"webpack-dev-server --mode development --open\"\n```\n\n이는 Webpack에 개발 서버를 시작하고 파일을 실시간으로 제공하고 브라우저를 webpack.config 파일에서 지정한 포트로 엽니다(또는 기본값 8080을 사용합니다). 프로젝트를 최종 배포용으로 빌드하려면 아래와 같이 보일 수 있는 빌드 스크립트를 실행할 것입니다:\n\n\n\n```js\n\"build\": \"webpack --mode production\"\n```\n\n이 스크립트는 기본 Webpack 구성을 사용합니다. 이 구성은 프로젝트 루트에서 src 디렉토리를 찾고 index.js를 엔트리 포인트로 찾습니다. index.js에서 Webpack은 종속성 그래프를 빌드하기 시작합니다. 이전 예제와 유사하게 Container, Row 및 Col이 필요했던 것과 같이 AutoLayoutExample을 올바르게 렌더링하려면 Bootstrap이 AutoLayoutExample을 렌더링하기 전에 있는지 확인해야 합니다.\n\n전형적인 React 앱에는 package.json이나 프로젝트 트리에 webpack.config.js 파일이 없는 것을 알아채셨나요?\n\n이것은 React 팀이 이미 create-react-app을 사용할 때 모든 Webpack 구성을 내부에서 처리하고 있기 때문입니다. 그들은 무작위로 Webpack 구성을 변경하는 개발자들이 전반적인 경험을 저하시킬 수 있는 예상치 못한 동작을 도입할 위험 때문에 Webpack 구성을 무작위로 조정하길 원하지 않습니다.```\n\n\n\n하지만 자신이 무엇을 하고 있는지 알고 있다면 어떻게 해야 할까요? React의 웹팩 config를 재정의하는 데 도움이 되는 도구인 CRACO(Create React App Configuration Override)가 있습니다.\n\n다음은 Craco가 공식 문서에서 자신을 어떻게 정의하는지에 대한 내용입니다:\n\n이 정의 아래에 큰 경고도 있습니다:\n\n따라서 CRACO를 사용하는 것은 React에게 \"나는 안다, 내가 뭘 하고 있는지 안다\"고 말하는 것과 동등합니다.\n\n\n\n제 경우에는 CRACO를 사용하여 빌드를 분석할 계획입니다. 기본 빌드 스크립트를 수정하지 않을 것이고, 학습 목적으로 새로운 스크립트를 추가하여 번들을 조사하는 것을 목표로 할 것입니다. \n\n이제부터 회사에서 사용하는 볼륨이 큰 비공개 레포지토리를 분석할 것입니다. 그 레포지토리는 매우 크기 때문에 번들과 청크에 대해 배우기에 완벽한 대상이라고 생각합니다.\n\n그러나 어떤 도구를 설치하기 전에, 손에 있는 것을 활용해보는 것은 어떨까요? 브라우저를 사용하면 번들을 분석하는 방법을 배우는 데 좋은 시작점이 될 수 있습니다. 그렇다면 번들은 무엇일까요? 청크는 무엇일까요?\n\n## 번들(Bundle):\n\n\n\n## 청크:\n\n애플리케이션이 상당히 큰 경우 큰 번들을 청크로 나누어 게으르게 로드하는 것은 의미가 있습니다. 일반적으로 시간을 크게 단축할 수 있습니다.\n\n번들을 분석하는 것은 브라우저로 제공되는 JavaScript 양을 최적화하는 좋은 첫 번째 단계이며, 이를 통해 페이지 로딩 시간을 향상시키고 직접적으로 더 나은 대규모 내용 그리기 속도(LCP)와 첫 입력 지연(FID)을 얻을 수 있습니다.\n브라우저가 코드를 구문 분석, 분석 및 컴파일하는 데 필요한 시간을 단축함으로써.\n\n다음 예제를 고려해보세요. 앱에서 사용자 페이지로 이동한 경우:\n\n\n\n![Webpack](/assets/img/2024-05-12-ExploringWebpack_2.png)\n\n위의 스크린샷에서는 네트워크 탭에서 이 페이지를로드하기 위해 서버에서 보낸 청크를 볼 수 있습니다. 또한 청크의 크기와 서버에서 브라우저로 이 청크를 보내는 데 필요한 시간도 볼 수 있습니다. 커버리지 탭에는 사용되지 않는 바이트의 크기를 볼 수 있습니다. 또한 개발 모드에서만, 청크 내의 실제 파일을 가리키는 소스 맵을 볼 수 있습니다. 청크 옆의 드롭다운 지시기를 클릭하여 찾을 수 있습니다.\n\n14.chunk.js에는 97.7%의 사용되지 않은 바이트를 가진 useLocalStorage 커스텀 훅이 있는 한 개의 파일이 있습니다. 이는 useLocalStorage의 사용을 다시 확인해야 할 지표일 수 있습니다. 아마도 이 페이지에서는 그것이 필요하지 않을 수도 있습니다.\n\n네트워크 및 커버리지 탭을 사용하면 이미 작은 범위에 대한 분석을 수행할 준비가 되어 있다면 좋은 시작이 될 수 있습니다. 그러나 프로젝트의 전반적인 분석을 원하는 경우, 일부 3rd 파티 도구의 도움이 필요할 수 있습니다.\n\n\n\n우리가 먼저 할 일은 \"craco\"와 \"webpack-bundle-analyzer\"라는 웹팩 프러그인을 설치하는 것입니다. 이러한 패키지들은 새로운 스크립트를 실행할 때 웹팩이 출력하는 번들된 코드를 확인하는 데 도움이 됩니다:\n\n```js\nyarn add @craco/craco webpack-bundle-analyzer progress-bar-webpack-plugin chalk --dev\n```\n\n그런 다음 package.json 파일 아래에 \"analysis\"라는 스크립트를 추가할 수 있습니다.\n\n```js\n \"scripts\": {\n        \"analysis\": \"craco build\",\n        // 다른 스크립트들\n \n}\n```\n\n\n\n우리는 craco.config.js 파일을 만들고 다음 코드를 추가합니다.\n\n```js\nconst chalk = require('chalk');\nconst ProgressBarPlugin = require('progress-bar-webpack-plugin');\nconst BundleAnalyzerPlugin =\n    require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\n\nmodule.exports = {\n    webpack: {\n        plugins: [\n            new BundleAnalyzerPlugin({\n                analyzerMode: 'server',\n            }),\n            new ProgressBarPlugin({\n                format: `${chalk.green('분석 중...')} ${chalk.green(\n                    '[:bar]'\n                )}${chalk.green('[:percent]')}${chalk.green(\n                    '[:elapsed seconds]'\n                )} - :msg`,\n            }),\n        ],\n    },\n};\n```\n\n참고: CommonJS 구문을 사용하였습니다. 왜냐하면 webpack 구성 파일은 Node.js 환경에서 실행되기 때문입니다.\n\n이 파일에서는 BundleAnalyzerPlugin을 사용하여 빌드 후 서버를 열어 Webpack 출력 파일의 크기와 내용을 시각적으로 표시하고, ProgressBarPlugin을 사용하여 빌드 중에 터미널에 진행률 표시줄을 표시하여 빌드가 얼마나 완료되었는지와 실행 시간이 얼마나 되었는지 나타냅니다. 마지막으로 터미널에 색을 추가하기 위해 chalk를 사용하고 있습니다.\n\n\n\n우리의 분석 스크립트를 실행한 결과입니다:\n\n- [ExploringWebpack_3](/assets/img/2024-05-12-ExploringWebpack_3.png)\n- [ExploringWebpack_4](/assets/img/2024-05-12-ExploringWebpack_4.png)\n- [ExploringWebpack_5](/assets/img/2024-05-12-ExploringWebpack_5.png)\n\n\n\n이 것은 무엇인가요?\n\n저희의 최종 번들입니다. 응용 프로그램 코드와 그에 의존하는 어떤 모듈도 모두 포함되어 있습니다. 코드 스플리팅 및 다양한 웹팩 최적화 후 node_modules에서 발생하는 종속성도 포함되어 있습니다. BundleAnalyzerPlugin을 통해 3가지 화면을 제공합니다:\n\n- Stat: 이 화면에서는 최적화가 적용되기 전 번들 내 각 모듈의 원시 크기를 보여줍니다. 프로젝트 내 각 파일/모듈의 크기에 대한 아이디어를 제공합니다.\n- Parsed: 이 화면에서는 웹팩이 해석하고 처리한 후 각 모듈의 크기를 볼 수 있습니다. 일반적으로 트리 쉐이킹, 코드 스플리팅 및 기타 최적화 작업이 포함됩니다. 따라서 이 화면에서 보이는 숫자는 웹팩이 다양한 최적화를 적용한 후의 모듈 크기를 반영합니다.\n- Gzipped: 이 화면에서는 gzip 압축이 적용된 후 각 모듈의 크기를 보여줍니다. Gzip 압축은 네트워크를 통해 전송되는 파일의 크기를 줄이는 데 사용되는 표준 기술입니다. 이 화면의 숫자는 압축 후 각 모듈의 예상 크기를 나타냅니다.\n\n일반적으로 번들 크기에 대해 이야기할 때는 Gzipped 크기를 의미합니다. 그러나 Parsed와 Gzipped 둘 다 중요한 지표입니다. Parsed 크기는 브라우저가 앱을 로드할 때 수행해야 할 작업 양을 이해하는 데 도움을 줍니다. 반면 Gzipped 크기는 앱이 사용자에게 빠르게 다운로드되고 실행을 시작할 수 있는 속도를 알려줍니다.\n\n\n\n우리는 React Lazy Imports에 마법 주석을 추가하여 출력을 향상시킬 수 있어요.\n\nLazy Imports 또는 Lazy Loading:\n\n```js\nimport React from 'react';\n\nconst Users = React.lazy(() =>\n    import(\n        /* webpackChunkName:\"Users\" */ 'users/page의 경로'\n    )\n);\n\n\nreturn (\n<React.Suspense fallback={<div>로딩 중....</div>}>\n  <Users/>\n<React.Suspense>\n)\n```\n\n이 향상된 결과는 엄청난 번들을 향상시키기 위한 좋은 시작점이 될 수 있어요. 내가 상위 여덟 청크로 줄인 후 (번들 크기의 약 2/3을 차지해요😲) Webpack 마법 주석을 lazy import된 routes 컴포넌트에 추가한 후에, EmployeeScoreCard (452 KB) 청크와 Style 청크 (296 KB) 중 두 가장 큰 문제가 되는 청크를 식별할 수 있어요.\n\n\n\n\n![ExploringWebpack_6](/assets/img/2024-05-12-ExploringWebpack_6.png)\n\n번들 크기를 최적화하는 데 일반적으로 사용되는 두 가지 방법은 레이지 로딩과 동적 임포트입니다. 또 더 나아가 EmployeeScoreCard 내부의 일부 구성 요소를 레이지 로딩하여 이 청크를 여러 개의 청크로 분할할 수 있습니다. 결과는 다음과 같습니다:\n\n내부 구성 요소를 레이지 로딩한 후 EmployeeScoreCard는 훨씬 작아졌습니다. 우리가 명시적으로 확인하지 않는 이상 전혀 표시되지 않습니다. 또한 마지막 이미지에서 EmployeeInfoGrid라는 청크를 볼 수 있는데, 이 간단한 개선의 결과에 대해 저도 놀랍습니다. 총 청크 크기가 7.25MB에서 6.83MB로 감소했습니다. 6%의 감소입니다. 🤯\n\n번들을 최적화하는 두 번째 방법은 청크 내부에서 동적 임포트를 사용하는 것입니다. 동적 임포트는 일반적으로 사용자 작업에 따라 조건적으로 로딩됩니다. 다음 코드를 고려해보세요:\n\n\n\n```js\nimport React, { useState } from 'react';\n\nconst Dashboard = () => {\n  const [showUserDetails, setShowUserDetails] = useState(false);\n  const [UserDetails, setUserDetails] = useState(null);\n\n  const handleClick = async () => {\n    if (!UserDetails) {\n      const { default: UserDetailsComponent } = await import('./UserDetails');\n      setUserDetails(UserDetailsComponent);\n    }\n    setShowUserDetails(true);\n  };\n\n  return (\n    <div>\n      <button onClick={handleClick}>세부 정보 보기</button>\n      {showUserDetails && UserDetails && <UserDetails user={/* 사용자 데이터 입력 */} />}\n    </div>\n  );\n};\n\nexport default Dashboard;\n```\n\n여기서는 사용자가 버튼을 클릭한 후 UserDetailsComponent만 가져오기 때문에, UserDetailsComponent를 위한 별도의 청크를 만듭니다.\n\n이러한 기술을 따르면 번들 크기를 크게 줄일 수 있어 다음과 같은 결과를 얻을 수 있습니다:\n\n- 초기 로딩 시간 단축\n- 대역폭 사용 감소\n- 브라우저 캐싱 향상\n- 이탈률 낮춤\n- 사용자 경험 향상\n- SEO 향상```\n\n\n\n하지만 번들 크기를 줄이는 데 가장 중요한 팁은 제 생각에는:\n\n당신이 할 말을 아는 편이에요:\n- \"나한테 바퀴를 재발명하라는 거야?\"\n- \"그 라이브러리가 내 삶을 더 쉽게 만들어줘.\"\n\n내가 당신에게 그것을 설치하지 말라고 금지하는 건 아니에요 😅 그저 자원을 효율적으로 활용해봐요. 터미널 출력이나 웹팩 분석기 출력을 자세히 살펴보면, 모든 그 무명의 청크들이 node_modules 이거나, 아무 로직이 없는 코드거나, 그리고 우리가 지타줘야 하는 추가적인 부담이 있는 거예요.\n\n\n\n나도 누구 다름 없이 도서관을 좋아해요. 하지만 프로젝트에 라이브러리를 설치한다면 다음을 지켜주세요:\n\n- 정기적으로 유지/업그레이드하기\n- 같은 작업을 수행하는 여러 라이브러리를 설치하지 않기\n- 최신 정보 유지하기. 라이브러리는 사용이 중단되고 브라우저는 매일 라이브러리를 대체할 수 있는 기능을 추가합니다.\n\n마지막으로 번들을 분석한 후, 이 라이브러리들이 반드시 필요하다면 더 작은 라이브러리로 대체해보세요. 다음 패키지를 설치하기 전에 https://bundlephobia.com/ 같은 도구가 여러분의 여정에서 큰 도움이 될 수 있습니다.\n\n작은 번들과 버그 없는 하루 되세요!","ogImage":{"url":"/assets/img/2024-05-12-ExploringWebpack_0.png"},"coverImage":"/assets/img/2024-05-12-ExploringWebpack_0.png","tag":["Tech"],"readingTime":11},{"title":"React 초보자를 위한 기본 개념","description":"","date":"2024-05-12 23:15","slug":"2024-05-12-Reactbasicconceptsforbeginner","content":"\n\n글을 쓰는 것은 제가 배운 것을 다시 상기시키는 데 도움이 돼요. 그럼 시작해볼까요!\n\n리액트란? 웹페이지를 렌더링하는 데 도움이 되는 JavaScript 라이브러리\n\n라이브러리인가요, 프레임워크인가요? 라이브러리는 필요할 때마다 즉시 구축하는 데 도움이 되는 일반적인 도구를 제공하고, 프레임워크는 사용자 정의할 수 있는 기본 청사진을 제공합니다. 리액트는 청사진보다는 도구 상자와 같아서 라이브러리에 속합니다.\n\n왜 리액트를 사용해야 하나요? 간결한 코딩 스타일, 쉬운 코드 블록 재사용, 그리고 더 나은 로직 유닛 형성(업무 분리)이 가능합니다.\n\n\n\n```js\n// 단계 정의, 명령형, DOM 스타일\nlet btn = document.querySelector('button');\n\nif (user.isLoggedIn){\n  button.textContent = '계속하기'\n}\nelse {\n  button.textContent = '로그인'\n}\ndocument.body.append(btn);\n```\n\n```js\n// 목표 정의, 선언형, React-Dom 스타일\nlet content;\nif (user.isLoggedIn){\n  content = <button>계속하기</button>\n}\nelse {\n  content = <button>로그인</button>\n}\nreturn content;\n```\n\n리액트의 네 가지 개념: JSX, 컴포넌트, 프롭스, 상태. 이를 분해하여 이해해봅시다.\n\nJSX는 자바스크립트 문법 확장으로 HTML을 자바스크립트 코드에 포함할 수 있게 해줍니다.\n```\n\n\n\n```js\n// Header.jsx에 저장\nexport default function Header() {\n  return (\n    <header>\n      <h1> 이것은 헤더에 속해 있습니다. </h1>\n    </header>\n  )\n}\n```\n\n컴포넌트는 HTML 블록(React 레고)을 반환하는 함수입니다. 일반적으로 이러한 블록을 결합하여 웹페이지를 만듭니다.\n\n```js\nimport Header from './Header.jsx'\n\nexport default function App() {\n  return(\n    <div>\n      <Header />     // 컴포넌트\n    </div>\n  )    \n}\n```\n\nProps는 사용자 정의 컴포넌트에 설정할 수 있는 속성입니다. 데이터가 컴포넌트 간에 흐를 수 있도록 하는 것이 목적입니다.\n```\n\n\n\n```js\nfunction MyComponent(props){\n  console.log(props.name); // appName\n  console.log(props.age); // 777\n}\n\nfunction App(){\n  return (\n    <div>\n      <MyComponent\n        name=\"appName\"\n        age=777\n      />\n    </div>\n  )\n}\n```\n\n상태(State)는 두 가지 역할을 하는 React 후크입니다. 업데이트를 기다리고 웹페이지를 다시 렌더링합니다. 상태 후크가 필요한 이유는 React 컴포넌트가 내부적으로 시작할 때 한 번만 실행되고 나중에 업데이트되면 기본적으로 다시 렌더링되지 않기 때문입니다. 따라서 React에게 특정 정보나 상태가 변경되었음을 알리고 그것을 다시 렌더링하도록 전달할 방법이 필요합니다.\n\n```js\n// .jsx 형식으로 저장\nimport {useState} from \"react\"\n\nconst [getInfo, setInfo] = useState()\n\nfunction handleInfo(newInfo) {\n  setInfo(newInfo)\n}\n\nlet info = <p>기본 정보</p>\nif(getInfo) {\n  info = getInfo\n}\n\nreturn (\n  <CusButton onClick={() => handleInfo(\"CB가 클릭되었습니다\")}> CB </CusButton>\n  <div>\n    {info}\n  </div>\n)\n```\n\n간단히 말하면, React는 주로 웹페이지 렌더링에 초점을 맞춘 자바스크립트 라이브러리입니다. JSX, 컴포넌트, 프롭스(props) 및 상태(State)라는 네 가지 필수 개념이 있습니다. JavaScript 문법 확장을 통해 관련 HTML/CSS/JS를 컴포넌트로 그룹화할 수 있습니다. 컴포넌트는 서로 통신하기 위해 프롭스를 포함하고, 마지막으로 상태(State)는 업데이트 시 컴포넌트를 다시 렌더링할 수 있게 합니다.\n```","ogImage":{"url":"/assets/img/2024-05-12-Reactbasicconceptsforbeginner_0.png"},"coverImage":"/assets/img/2024-05-12-Reactbasicconceptsforbeginner_0.png","tag":["Tech"],"readingTime":3},{"title":"코로나19 이후 의료 분야에서 데이터의 역할","description":"","date":"2024-05-12 23:14","slug":"2024-05-12-TheroleofdatainhealthcareafterCOVID-19","content":"\n\n코로나19 이후 건강 관리에서 데이터의 역할은 계속 발전하며 건강 관리 환경의 다양한 측면을 형성하고 있습니다. 데이터가 중요한 역할을 하는 주요 영역은 다음과 같습니다:\n\n질병 감시 및 모니터링:\n\n데이터 분석은 COVID-19 확산 추적, 핫스팟 식별 및 트렌드 예측에 핵심적인 역할을 해왔습니다. 정부와 건강 기관이 검사 결과, 입원 환자, 이동 패턴 등 다양한 소스에서 얻은 데이터를 활용하여 공중보건 조치와 자원 할당을 위한 의사결정에 어떻게 활용했는지 알아보세요.\n\n![이미지](/assets/img/2024-05-12-TheroleofdatainhealthcareafterCOVID-19_0.png)\n\n\n\n공중보건 개입 및 정책 결정:\n\n데이터 기반 모델링 및 시뮬레이션이 어떻게 코로나바이러스 감염 확산 완화를 위한 공중보건 정책, 사회적 거리두기 조치 및 접종 전략에 영향을 미쳤는지 살펴보세요. 개인 데이터를 공중보건 감시 및 접촉 추적에 사용하는 것의 윤리적 및 개인정보 보호 측면에 대해 논의해보세요.\n\n![이미지](/assets/img/2024-05-12-TheroleofdatainhealthcareafterCOVID-19_1.png)\n\n건강 격차 감소 및 균형성:\n\n\n\n건강 격차에 대한 대응과 건강 평등 증진은 팬데믹 이후 계속해서 중요한 우선 순위 사항입니다. 데이터 기반 이니셔티브는 의료 접근성, 결과 및 건강의 사회적 결정 요인에 대한 격차를 식별하여, 불평등에 기여하는 근본적인 요소를 해결하기 위한 특정 대응책을 가능하게 합니다. 데이터 분석을 통해 의료 이해권자들은 증거 기반 정책과 개입을 개발하여 모든 인구 집단을 위해 격차를 줄이고 건강 평등을 향상시킬 수 있습니다.\n\n요약하면, 데이터는 팬데믹 이후 의료 분야에서 혁신을 이끄는 역할을 지속하고 있으며, 환자 결과를 개선하고 의료 시스템이 미래 도전에 대비할 수 있도록 강화함으로써 건강을 향상시키고 있습니다. 데이터 분석의 능력을 활용하여 의료 이해권자들은 공중 보건 목표를 추진하고 의료 서비스 제공을 최적화하여 궁극적으로 개인과 지역사회의 건강과 복지를 향상시킵니다.","ogImage":{"url":"/assets/img/2024-05-12-TheroleofdatainhealthcareafterCOVID-19_0.png"},"coverImage":"/assets/img/2024-05-12-TheroleofdatainhealthcareafterCOVID-19_0.png","tag":["Tech"],"readingTime":2},{"title":"제목 재사용 가능한 함수가 있을 때 왜 커스텀 훅을 만들어야 할까요","description":"","date":"2024-05-12 23:13","slug":"2024-05-12-Whytocreatecustomhookswhentherearereusablefunctions","content":"\n\n<img src=\"/assets/img/2024-05-12-Whytocreatecustomhookswhentherearereusablefunctions_0.png\" />\n\n함수를 작성할 때 재사용 가능한 함수를 만들 수 있습니다. 함수를 만들어서 내보내고 사용하기만 하면 됩니다. 이 과정은 매우 간단합니다.\n\n```js\nexport const getTemplateName = (id: number, templatesData: ITemplates[]) => {\n  return templatesData?.find((template) => template.id === id)?.name || \"-\";\n};\n```\n\n예를 들어, 위 코드에서는 템플릿 목록에서 템플릿을 검색하고 이름을 반환하는 재사용 가능한 함수를 만들었습니다.\n\n\n\n이 기능은 지금은 괜찮지만, 함수에서 매번 templatesData를 전달하고 싶지 않고 위 함수 내에서 직접 가져오고 싶다면 어떻게 해야 할까요? 제 templatesData는 리덕스 상태에 저장되어 있으며 아래와 같이 수행하려고 합니다:\n\n```js\nexport const getTemplateName = (id: number) => {\n  // 가능할까요?\n  const templatesData = useSelector((state: RootState) => state.templates);\n  return templatesData?.find((template) => template.id === id)?.name || \"-\";\n};\n```\n\n# 위 코드가 작동할까요?\n\n이 질문에 대한 답변을 위해 간단히 훅 규칙을 살펴보고 알아보겠습니다.\n\n\n\n- 훅은 최상위 레벨에서만 호출해 주세요.\n- 훅은 React 함수에서만 호출해 주세요.\n- 훅은 동일한 순서로 사용해 주세요.\n- 훅은 React 컴포넌트에서만 호출해 주세요.\n- 훅은 조건부로 호출하지 마세요.\n\n위 코드는 4번 규칙을 위반하여 아래와 같은 오류가 발생했습니다:\n\n![error](/assets/img/2024-05-12-Whytocreatecustomhookswhentherearereusablefunctions_1.png)\n\n이를 해결하기 위해 커스텀 훅이 구원의 역할을 해줍니다.\n\n\n\n# 해결 방법\n\n이 문제는 아래와 같이 커스텀 훅을 사용하여 해결할 수 있습니다:\n\nReact에서의 커스텀 훅은 JavaScript 함수로, 내장 훅(예: useState, useEffect, useContext 등)이나 다른 커스텀 훅을 활용하여 재사용 가능한 로직을 캡슐화하는 기능입니다.\n\nReact에서 훅으로 인식하도록 하려면 커스텀 훅은 반드시 use로 시작해야 합니다.\n\n\n\n이제 위 코드를 사용 가능하게 만들기 위해 사용자 정의 훅으로 변환해 봅시다.\n\n```js\nexport const useTemplateActions = () => {\n  // 여기서 필요한 훅을 사용하세요\n  const { templatesData } = useSelector((state: RootState) => state.templates);\n\n  const getTemplateName = (id: number) => {\n    return templatesData?.find((template) => template.id === id)?.name || \"-\";\n  };\n\n  return { getTemplateName };\n};\n```\n\n그리고 사용할 때:\n\n```js\nconst myFunction = () => {\n   ...\n   const { getTemplateName } = useTemplateActions(); // 이제 일반 함수처럼 사용하세요\n   ...\n}\n```\n\n\n\n따라서, 재사용 가능한 함수가 단순한 로직만 포함하고 있다면 재사용 함수를 만드는 것은 괜찮지만, 함수가 리액트 훅 또는 기타 사용자 정의 훅을 호출한다면 사용자 정의 훅을 만들어야 합니다.\n\n감사합니다.","ogImage":{"url":"/assets/img/2024-05-12-Whytocreatecustomhookswhentherearereusablefunctions_0.png"},"coverImage":"/assets/img/2024-05-12-Whytocreatecustomhookswhentherearereusablefunctions_0.png","tag":["Tech"],"readingTime":2},{"title":"플러거블 PBC와 비트 하모니에 대해 알아보기","description":"","date":"2024-05-12 23:12","slug":"2024-05-12-PluggablePBCswithBitHarmony","content":"\n\n## 패키지 비즈니스 능력을 표준화하고 통합을 간소화하는 방법\n\n![플러그 가능한 PBC와 비트 하모니](/assets/img/2024-05-12-PluggablePBCswithBitHarmony_0.png)\n\n'패키지 비즈니스 능력' (PBCs), Gartner가 만든 용어로, 비즈니스 모델, 목표 및 언어와 일치하는 소프트웨어의 독립적으로 배포 가능하며 기능적으로 이산적인 단위입니다.\n\nPBC의 도입이 점점 보급화되면서, 구현 및 통합을 숙달하는 조직들은 기술적 발전을 활용하여 지속적인 성장과 성공을 이끌어내기 위해 그 산업의 최전선에 자리한다는 것을 발견하게 될 것입니다.\n\n\n\n이 기사에서는 조직의 패키지 비즈니스 기능을 크게 향상시킬 수 있는 도구 인 Bit Harmony를 탐색할 것입니다.\n\nBit Harmony는 스마트 의존성 주입을 사용하여 PBC(Package Business Capabilities)의 구성을 위한 혁신적인 플랫폼입니다. Bit Harmony를 사용하면 퓨전 팀이 최소한의 오버헤드로 PBC를 구성하고 일관성과 재사용성을 보장하면서 새로운 경험이나 앱을 가속화하여 제공할 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-PluggablePBCswithBitHarmony_1.png)\n\n이 접근 방식의 데모를 보려면 'Apparel Wave' 범위 및 'Blog PBC' 범위를 방문해주세요.\n\n\n\n<img src=\"/assets/img/2024-05-12-PluggablePBCswithBitHarmony_2.png\" />\n\n<img src=\"/assets/img/2024-05-12-PluggablePBCswithBitHarmony_3.png\" />\n\n# 측면\n\n측면은 Harmony 솔루션의 구성 요소입니다. 다른 측면들에 대한 UI 및 백엔드 \"서비스\"를 제공하는 풀 스택 비트 컴포넌트입니다.\n\n\n\n이 기사에서 Aspect는 더 큰 시스템에 플러그인되어 완전한 솔루션, 새로운 애플리케이션을 형성할 수 있는 단일 패키지 비즈니스 기능 (PBC)을 나타냅니다.\n\n![이미지](/assets/img/2024-05-12-PluggablePBCswithBitHarmony_4.png)\n\nAspects는 다른 측면을 확장하기 위해 그들의 '슬롯' API에 등록함으로써 확장됩니다. 이러한 제어 반전으로 인해 퓨전 팀은 측면이 통합을 담당하고 있는 시스템이 아니라는 최소한의 오버헤드로 PBC를 구성할 수 있습니다.\n\n예를 들어, 다음 Harmony 앱은 서퍼용 의류 온라인 쇼핑몰입니다. 해당 온라인 스토어를 담당하는 퓨전 팀은 사이트에 블로그를 추가하기로 결정했습니다. Bit 플랫폼에서 적합한 PBC를 찾은 후, 그들은 이 블로그 PBC를 발견했습니다. 그것을 사용하기로 결정하여, Harmony 애플리케이션에 추가했습니다:\n\n\n\n```js\n/**\n * @coponentId: learnbit.apparel-waves/apparel-waves\n * @filename: apparel-waves.bit-app.ts\n */ \n\n// imports...\nimport { SymphonyPlatformAspect } from '@bitdev/symphony.symphony-platform';\nimport { ApparelWavesPlatformAspect } from '@learnbit/apparel-waves.apparel-waves-platform';\nimport { BlogAspect } from '@learnbit/blog-pbc.blog';\n\nexport const ApparelWaves = HarmonyPlatform.from({\n  name: 'apparel-waves',\n  platform: [\n   /**\n    * ascpects register themsevles to the 'platform' aspect which\n    * is the entry point for this application\n    */\n    SymphonyPlatformAspect,\n    {\n      name: 'Apparel Waves',\n      slogan: 'Making waves in fashion',\n      domain: 'apparel-waves.com',\n    },\n  ],\n  /**\n    * aspects can run in multiple runtime environments. here, aspects \n    * provide functionalitis to the NodeJS services and to the web frontend apps\n   */\n  runtimes: [new BrowserRuntime(), new NodeJSRuntime()],\n\n  aspects: [\n    /* 'apperal waves' aspect extends the system with its \n     * own unique functionalities. this aspect is maintained by \n     * a fusion team that composes the PBCs for their own solution.\n     */\n    ApparelWavesPlatformAspect,\n    /**\n     * the blog (PBC) aspect extends the system with content \n     * management capabilities. it is maintained by the blog PBC team.\n     */\n    [\n      BlogAspect,\n      {\n       /**\n         * the blog aspect also provide a config api for this app to use\n         * in this case, since the the blog uses the Contenful platform,\n         * the fusion team need to provide it with their own Contentful space ID\n         */        \n        spaceId: 'contentful-spaceId',\n      },\n    ],\n  ],\n});\n\nexport default ApparelWaves;\r\n```\n\n<img src=\"/assets/img/2024-05-12-PluggablePBCswithBitHarmony_5.png\" />\n\nBlog PBC (aspect)는 플랫폼에 여러 가지 방법으로 자체적으로 등록됩니다:\n\n- 노드를위한 GraphQL 스키마를 내용 검색을 위한 노드로 확장합니다. 이 작업은 NodeJS 런타임에서 수행됩니다.\n- 시스템의 라우팅을 /blog 경로로 확장합니다. 이 작업은 브라우저 런타임에서 수행됩니다.\n- 헤더에 'Blog' 링크를 /blog로 추가하여 확장합니다. 이 작업은 브라우저 런타임에서 수행됩니다.```\n\n\n\nNodeJS 런타임\n\n```js\n/**\n * @coponentId: learnbit.blog-pbc/blog\n * @filename: blog.node.runtime.ts\n */\n\nexport class BlogNode {\n  constructor(private config: BlogConfig) {}\n\n  async getBlogPosts() {\n    const blogData = new BlogData(this.config);\n    return blogData.getBlogPosts();\n  }\n\n  static dependencies = [SymphonyPlatformAspect];\n\n  static async provider(\n    [symphonyPlatform]: [SymphonyPlatformNode],\n    config: BlogConfig\n  ) {\n    const blog = new BlogNode(config);\n    const gqlSchema = blogGqlSchema(blog);\n\n    symphonyPlatform.registerBackendServer([\n      {\n        gql: gqlSchema,\n      },\n    ]);\n\n    return blog;\n  }\n}\n\nexport default BlogNode;\n```\n\n브라우저 런타임\n\n```js\n/**\n * @coponentId: learnbit.blog-pbc/blog\n * @filename: blog.browser.runtime.ts\n */\n\n\nexport class BlogBrowser {\n  constructor(private config: BlogConfig) {}\n\n  static dependencies = [SymphonyPlatformAspect, HeaderAspect];\n\n  static async provider(\n    [symphonyPlatform, header]: [SymphonyPlatformBrowser, HeaderBrowser],\n    config: BlogConfig\n  ) {\n    const blog = new BlogBrowser(config);\n\n    symphonyPlatform.registerRoute([\n      {\n        path: '/blog',\n        component: () => {\n          return (\n            <ApolloBlogProvider spaceId={config.spaceId}>\n              <BlogLobby />\n            </ApolloBlogProvider>\n          );\n        },\n      },\n    ]);\n\n    header.registerLink([{ label: 'Blog', href: '/blog' }]);\n\n    return blog;\n  }\n}\n\nexport default BlogBrowser;\n```\n\n\n\nPBC(Purchased- Built-Composed)는 기존 솔루션을 구입하여 새 코드로 조합하는 혼합 접근을 장려합니다. 전통적인 \"사거나 만들기\"의 이분법 대신으로써 서로 조화롭게 연결될 수 있는 새로운 코드로 이루어진 솔루션을 구입하여 채택합니다.\n\n블로그 PBC는 Contentful 콘텐츠 관리 시스템을 사용하여 이 권고사항을 적용합니다. 이를 통해 회사의 PBC 생태계 내에서 구입한 서비스에 대한 일관된 \"언어\"를 제공하여 효과적으로 의사소통하고 원활하게 작동할 수 있도록 합니다.\n\n```js\n/**\n * @coponentId: learnbit.blog-pbc/blog\n * @filename: blog-data.ts\n */\n\nimport { ApolloClient, InMemoryCache, HttpLink, gql } from '@apollo/client';\nimport type { BlogConfig } from './blog-config.js';\n\nexport class BlogData {\n  constructor(private readonly config: BlogConfig) {}\n\n  private contentfulClient = new ApolloClient({\n    link: new HttpLink({\n      uri: `https://graphql.contentful.com/content/v1/spaces/${this.config.spaceId}`,\n      headers: {\n        Authorization: `Bearer ${process.env.CONTENTFUL_ACCESS_TOKEN}`,\n      },\n      fetch,\n    }),\n    cache: new InMemoryCache(),\n  });\n\n  getBlogPosts = async () => {\n    const { data } = await this.contentfulClient.query({\n      query: gql`\n        query GetBlogs {\n          pageBlogPostCollection {\n            items {\n              title\n              slug\n              author {\n                name\n              }\n            }\n          }\n        }\n      `,\n    });\n    return data.pageBlogPostCollection.items.map((item) => ({\n      title: item.title,\n      slug: item.slug,\n      author: {\n        name: item.author ? item.author.name : null,\n      },\n    }));\n  };\n}\n```","ogImage":{"url":"/assets/img/2024-05-12-PluggablePBCswithBitHarmony_0.png"},"coverImage":"/assets/img/2024-05-12-PluggablePBCswithBitHarmony_0.png","tag":["Tech"],"readingTime":7},{"title":"useRef 훅 ","description":"","date":"2024-05-12 23:11","slug":"2024-05-12-useRefHook","content":"\n\n<img src=\"/assets/img/2024-05-12-useRefHook_0.png\" />\n\n웹 개발에서 React는 동적 사용자 인터페이스를 구축하는 데 사용되는 주요 라이브러리로 자리 잡았습니다. 각 버전마다 React는 개발 프로세스에 새로운 기능과 개선 사항을 도입하고 개발자들이 더 효율적이고 유지보수 가능한 코드를 생성할 수 있도록 돕습니다.\n\nReact 16.8에서 도입된 useRef 훅은 널리 사용되는 기능 중 하나입니다. 다른 Hooks와 함께 소개된 useRef는 다시 렌더링을 유발하지 않고 렌더링을 거칠 때마다 값이 유지되도록 하는 방법을 제공합니다.\n\n# useRef란 무엇인가요?\n\n\n\n리액트에서 useRef를 간단한 메모지로 생각해보세요. 이것은 웹 페이지에서 일어나는 일들을 추적하는 데 도움이 되며 다른 것들을 망가뜨리지 않게 도와줍니다. 버튼 클릭, 텍스트 상자에 입력 또는 전체 페이지를 새로 고침하지 않고 멋진 애니메이션을 추가하는 데 사용할 수 있어요. 포커스 관리, 애니메이션 및 지속적인 업데이트가 필요하지 않은 정보를 유지하는 데 유용합니다.\n\n\n# 기본 사용법\n\nuseRef를 사용하는 것은 간단합니다. 기본 예제를 살펴보죠:\n\n```js\nimport React, { useRef } from 'react';\nconst MyComponent = () => {\n  const inputRef = useRef(null);\n  const handleFocus = () => {\n    inputRef.current.focus();\n  };\n  return (\n    <div>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={handleFocus}>Focus Input</button>\n    </div>\n  );\n};\n```\n\n\n\n이 예시에서는 useRef 훅을 사용하여 ref를 생성하고 input 요소에 연결합니다. 버튼을 클릭하면 `handleFocus` 함수가 호출되고, `inputRef`를 사용하여 다시 렌더링되지 않고 input 요소에 포커스가 맞춰집니다.\n\n# 이전 값 관리\n\nuseRef의 또 다른 강력한 측면은 렌더링 간 값의 지속성을 유지할 수 있는 능력입니다. 이는 상태 변수나 프롭의 이전 값을 저장하고 액세스해야 할 때 유용합니다.\n\n```js\nimport React, { useRef, useEffect } from 'react';\nconst MyComponent = ({ value }) => {\n const prevValueRef = useRef();\nuseEffect(() => {\n prevValueRef.current = value;\n }, [value]);\nreturn (\n <div>\n <p>현재 값: {value}</p>\n <p>이전 값: {prevValueRef.current}</p>\n </div>\n );\n};\n```\n\n\n\n이 예시에서는 useRef 훅을 사용하여 `value` 프롭의 이전 값 저장합니다. `value` 프롭이 변경될 때마다 useEffect 훅에서 ref 값을 업데이트합니다. 이를 통해 재랜더링을 유발하지 않고 프롭의 이전 값을 액세스할 수 있습니다.\n\n# 주의사항과 모범 사례\n\nuseRef는 강력한 도구지만, 그 한계와 모범 사례를 이해하는 것이 중요합니다:\n\n1. Mutable Values: useRef는 가변 값을 저장할 수 있기 때문에, 특히 useEffect나 useCallback 훅 내에서 이 값을 수정할 때 주의해야 합니다. 값을 직접 변경하는 것은 예상치 못한 동작과 버그를 유발할 수 있습니다.\n\n\n\n### 2. 직접 DOM 조작을 피하세요\nuseRef는 DOM 요소에 직접 접근하고 조작하는 데 일반적으로 사용됩니다. 그러나 가능한 경우 React의 선언적 접근 방식을 사용하는 것이 좋습니다. 직접 DOM 조작은 가급적으로 조심스럽게 사용해야 합니다.\n\n### 3. 메모리 관리\nuseRef 값은 컴포넌트의 수명 주기 전체 동안 유지되므로 메모리 누수를 방지하려면 참조를 정리하는 것이 중요합니다. 이를 위해 정리 함수에서 ref 값을 null로 설정하거나 빈 종속성 배열을 사용하여 useEffect 내에서 useRef 훅을 사용할 수 있습니다.\n\n# 결론\n\n요약하면 useRef 훅은 React의 훅 중요한 요소로, 값 유지와 다시 렌더링을 유발하지 않고 직접 DOM 요소에 액세스하는 방법을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-12-useRefHook_0.png"},"coverImage":"/assets/img/2024-05-12-useRefHook_0.png","tag":["Tech"],"readingTime":3},{"title":"복잡한 형식을 다루는 방법 ReactJS에서의 종합 안내","description":"","date":"2024-05-12 23:10","slug":"2024-05-12-HandlingComplexFormsinReactJSAComprehensiveGuide","content":"\n\n저는 React에서 양식 데이터를 쉽게 처리하는 기술에 대해 공유할 예정이에요.\n\n![ReactJs에서 복잡한 양식 다루기 - 포괄적 가이드](/assets/img/2024-05-12-HandlingComplexFormsinReactJSAComprehensiveGuide_0.png)\n\n저는 React에서 양식 데이터를 쉽게 처리하는 기술에 대해 공유할 예정이에요.\n\n웹 애플리케이션을 구축할 때 양식을 효율적으로 처리하는 것은 중요합니다, 특히 양식이 복잡할 경우에요. 인기 있는 JavaScript 라이브러리인 ReactJS는 여러 입력 유형, 유효성 검사, 동적 양식 필드를 관리하기 위한 강력한 솔루션을 제공합니다. 이 가이드는 React에서 복잡한 양식을 효과적으로 처리하는 데 가장 좋은 방법과 방법론에 대해 안내해 드릴 거에요.\n\n\n\n# 단계 1: 상태 초기화\n\n복잡한 양식을 다룰 때 상태를 올바르게 구조화하는 것이 중요합니다. 각 키가 양식의 필드나 섹션에 해당하는 구조화된 객체를 사용하는 것을 고려해보세요. 예를 들어:\n\n```js\nconst [formData, setFormData] = React.useState({\n  fullName: '',\n  age: null,\n  skills: [],\n  preferences: {},\n  profileImage: null\n});\n```\n\n# 단계 2: 필드에 [name] 속성 추가\n\n\n\n영화 및 가격 필드에 [name] 속성을 추가해주세요.\n\n영화 필드에는 [name] 속성의 값으로 'movie'를 넣어주세요.\n\n가격 필드에는 [name] 속성의 값으로 'price'를 넣어주세요.\n\n```js\n<input name='movie' />\n<input name='price' />\n```\n\n\n\n# 단계 3: 상태를 업데이트하는 함수 생성하기\n\n여러 필드가 있는 양식의 경우, 입력 필드의 name 속성을 활용하여 일반적인 방법으로 변경 사항을 처리하세요:\n\n```js\nconst handleChange = (e) => {\n  const { name, value } = e.target;\n  setFormData(prevState => ({\n    ...prevState,\n    [name]: value\n  }));\n};\n```\n\n## 동적 양식 필드\n\n\n\n동적 섹션 관리를 위해서, 확장 가능한 기술 또는 경험 목록과 같은 데이터를 제어하려면 상태 안에 배열을 유지하고 이 배열을 기반으로 입력을 렌더링하면 됩니다. 아이템을 추가하거나 제거하는 함수를 제공하세요:\n\n```js\nconst handleAddSkill = () => {\n  setFormData(prevState => ({\n    ...prevState,\n    skills: [...prevState.skills, '']\n  }));\n};\n\nconst handleRemoveSkill = index => {\n  setFormData(prevState => ({\n    ...prevState,\n    skills: prevState.skills.filter((_, i) => i !== index)\n  }));\n};\n```\n\n# 단계 4: 제출과 서버 상호작용\n\n비동기 함수를 사용하여 양식 데이터를 서버로 보내는 양식 제출을 처리하세요:\n\n\n\n```js\nconst handlePostData = async (e) => {\n    e.preventDefault();\n    let formD = new FormData();\n\n    // 문자열, 숫자 및 기타 스칼라 값은 직접 추가합니다.\n    formD.append('fullName', formData.fullName);\n    formD.append('age', String(formData.age));  // 숫자를 문자열로 변환하여 FormData에 추가합니다.\n    formD.append('volume', String(formData.volume));\n    formD.append('startDate', formData.startDate);\n\n    // 배열 요소를 개별적으로 추가합니다.\n    formData.skills.forEach(skill => {\n        formD.append('skills', skill.toString());\n    });\n\n    // 객체를 JSON 문자열로 추가합니다.\n    formD.append('preferences', JSON.stringify(formData.preferences));\n\n    // 파일을 직접 추가합니다.\n    if (formData.profileImage instanceof File) {\n        formD.append('profileImage', formData.profileImage, formData.profileImage.name);\n    }\n    if (formData.document instanceof File) {\n        formD.append('document', formData.document, formData.document.name);\n    }\n\n    // fetch API 또는 유사한 방법으로 FormData를 전송합니다.\n    try {\n        const response = await fetch('/your-endpoint', {\n            method: 'POST',\n            body: formD,\n            // FormData에 대해 Content-Type 헤더를 설정하지 마세요. 올바른 경계를 사용하는 'multipart/form-data'를 사용합니다.\n        });\n        const result = await response.json();\n\n        if (!response.ok) {\n            throw new Error(result.message || '문제가 발생했습니다');\n        }\n\n        // 성공 처리\n        console.log('양식이 성공적으로 제출되었습니다:', result);\n        // 필요에 따라 양식을 재설정하거나 이동합니다.\n    } catch (error) {\n        console.error('제출 오류:', error.message);\n    }\n};\n```\n\n양식 필드는 onChange 이벤트를 통해 handleChange 함수를 호출해야 합니다.\n\n```js\n<input name='fullname' onChange={handleChange} />\n<input name='age' onChange={handleChange} />\n```\n\n# React Component 라이브러리:\n```\n\n\n\n리액트 폼 생성은 프레임워크에 새롭다면 압도적으로 느껴질 수 있어요. 상태를 관리하고 입력을 처리하며 입력 데이터를 유효성 검증하는 등의 작업을 해야 해요.\n\n하지만 제3자 라이브러리 덕분에 이러한 작업들을 쉽게 처리할 수 있어요. 이러한 라이브러리들은 폼 생성 과정을 간단하게 도와주는 다양한 기능들을 제공해요. 폼 유효성 검사, 입력 마스킹, 제출 처리, 오류 처리 등의 기능을 포함하고 있어요. 이를 통해 사용자 친화적이면서 기능적인 폼을 간편하게 작성할 수 있어요.\n\n일부 인기 있는 폼 라이브러리로는 다음과 같은 것들이 있어요:\n\n- Formik\n- Redux Form\n- React Hook Form\n- Yup.\n\n\n\n# 결론:\n\n효율적인 웹 애플리케이션을 만들기 위해서는 React.js 폼 처리에 대한 전문 지식이 필수적입니다. 제 3자 라이브러리를 사용하든 React의 내장 기능을 사용하든, 이 매뉴얼에서 설명된 개념과 전략에 익숙해지면 React 앱을 위한 신뢰할 수 있고 사용자 친화적인 폼을 디자인할 수 있습니다.\n\n이 글이 도움이 되었기를 바랍니다!\n\n이메일: mudassar0920@gmail.com","ogImage":{"url":"/assets/img/2024-05-12-HandlingComplexFormsinReactJSAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-12-HandlingComplexFormsinReactJSAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"SaasterKit SaaS 애플리케이션을 위한 완벽한 Nextjs 보일러플레이트 만들기","description":"","date":"2024-05-12 23:09","slug":"2024-05-12-SaasterKitBuildingthePerfectNextjsBoilerplateforSaaSapplications","content":"\n\n가져다달라며 컴퓨터에 뛰어가서 새 프로젝트를 설정하고 칸반 보드에 작업 및 기능을 추가하기 시작하는 순간이 있나요? 하지만 그런 다짐을 하자마자 현실이 닥칩니다. 인증 또는 데이터베이스와 같은 기본 기능을 설정하는 잡일은 당신의 열정을 꺾는 일이 됩니다. 처음에 흥미로웠던 프로젝트 아이디어가 기술적인 일의 번거로운 목록으로 변몽합니다.\n\n아마도 당신은 세계를 혁신할 것이라 약속했던 야심찬 프로젝트들을 그림자로 남긴 GitHub 저장소가 있으실 겁니다. 아니면 데이터베이스 구조를 완벽하게 만들기 위해 끝없는 시간을 보낸 적이 있을지도 모릅니다. 웹 개발의 세계에서는 이러한 필수적이면서도 시간이 많이 소요되는 작업들에 방해받는 일이 너무 흔한 일입니다.\n\n## 이렇게 했어요\n\n시작할 때 인증을 다뤀어야 한다는 것을 알았습니다 — 거의 모든 앱의 척추인 요소거든요. Clerk로 시작했고, 이것이 손쉽고 신뢰할 수 있는 쉬운 안전 인증 솔루션이었다는 것을 깨달았습니다. 클라이언트와 서버 측의 로그인, 가입, 사용자 관리와 같은 기능을 추가했습니다.\n\n\n\n그 다음, Prisma와 Supabase를 사용하여 데이터베이스 통합을 추가했어요. Prisma를 이용하면 ORM (Object-Relational Mapping)이 간편해지는데, 이 도구가 지원하는 다른 데이터베이스와 쉽게 연동할 수 있어서 프로젝트 요구 사항에 유연하고 적응성 있게 대응할 수 있어요. Prisma에 Supabase를 통합하는 것은 당연한 선택이었죠. 무료 티어가 아주 관대해서 MVP(최소 가치 제품)를 구축하고 아이디어를 검증하기에 완벽해요.\n\n그 다음은 사용자 인터페이스였어요. Tailwind CSS를 사용하는 것은 당연한 선택이었는데, 다른 프로젝트에 사용하는 거라서요. 저 수준의 유틸리티 클래스를 사용하면 UI를 빠르게 디자인할 수 있으면서도 마크업이 쉽게 읽히죠. 이 킷을 작업하면서 shadcn을 발견했고, UI를 매력적이고 매혹적으로 만들어주는 빠진 부분을 채워줬어요. 제가 즐겨 사용하는 것은 아니지만요, 복잡하지 않게 디자인을 할 수 있어요.\n\n모든 요소 중에서 랜딩 페이지가 애플리케이션과 사용자 사이의 첫 번째 접점이에요. 그래서 시각적으로 매력적이면서 사용자와 상호작용하는 요소여야 해요. 이 필요를 해결하기 위해 세련되고 사용자 정의 가능한 랜딩 페이지 템플릿도 포함했어요. 또 모듈식으로 디자인되어 있어서 구성 요소를 간단히 이동하거나 제거하거나 추가하여 특정 요구 사항에 맞게 맞출 수 있어요. 브랜드와 제품 비전과 일치시키기 위해요.\n\n랜딩 페이지 다음으로는 대시보드가 나와요. 이는 우리 애플리케이션의 엔진 룸이에요. 일반적으로 상당한 일이죠. 인터페이스를 구성하고 데이터베이스를 연결하고 인증 서비스를 결합하는 게요.\n\n\n\n하지만 SaasterKit을 사용하면 상자에서 바로 기능적인 대시보드 애플리케이션을 얻을 수 있어요! 이 대시보드는 Clerk를 통한 실시간 통합 및 Prisma & Supabase를 통한 데이터베이스 기능을 쇼케이스합니다. 여러 상호작용하는 구성요소와 위젯이 포함되어 있어 애플리케이션의 요구에 맞게 준비돼 있어요. 랜딩 페이지와 마찬가지로 대시보드의 레이아웃과 기능을 완전히 제어할 수 있어요.\n\n웹 개발에서 원어민이 아닌 영어 스피커로서, 애플리케이션에서 다국어 지원의 중요성을 깊이 이해하고 있어요. 이는 글로벌 관중들과 의미 있는 연결을 확립하고 사용자의 접근성 범위를 넓히는 데 중요해요. 저는 다국어화(i18n) 구현을 간편화하는 Next.js용 편리한 라이브러리 next-international을 추가했어요. 이 라이브러리는 언어 감지 및 라우팅을 원활하게 처리할 뿐만 아니라 번들 크기를 작게 유지하기 위해 언어의 지연 로딩도 가능하게 해요.\n\n이메일 처리가 다음 작업이었어요. 그래서 저는 이메일 관련 모든 부분, 트랜잭션 이메일 발송부터 마케팅 캠페인 시작까지 모두 다루는 Resend를 통합했어요.\n\n마지막으로 오류 추적 및 디버깅을 위해 Sentry를 포함했어요. 실시간 오류 추적 기능은 개발 프로세스 전반에 유용해요.\n\n\n\n## 다음 계획 및 도와주실 수 있는 방법\n\n저는 현재 OpenAI와 Lemon Squeezy 같은 고급 도구들을 더 많이 활용하는 것을 탐구하고 있습니다. 더불어 MDX 문서용 보일러플레이트 코드에 대해 작업 중에 있습니다.\n\n오늘, 이 보일러플레이트는 여러분이 자유롭게 사용할 수 있도록 준비되어 있습니다. 목표는 간단합니다 — 기본 설정을 걱정하지 않고 커뮤니티가 멋진 애플리케이션을 구축할 수 있도록 돕는 것입니다.\n\n여기 열린 초대장이 있습니다 — 여러분이 가치를 더해줄 것으로 생각되는 여러분의 즐겨쓰는 도구들을 추천해주세요. 여러분의 기여는 이 보일러플레이트를 더욱 완벽하게 만드는 데 도움이 될 수 있습니다.\n\n\n\n감사합니다! \n\nhttps://saasterkit.vercel.app/","ogImage":{"url":"/assets/img/2024-05-12-SaasterKitBuildingthePerfectNextjsBoilerplateforSaaSapplications_0.png"},"coverImage":"/assets/img/2024-05-12-SaasterKitBuildingthePerfectNextjsBoilerplateforSaaSapplications_0.png","tag":["Tech"],"readingTime":3}],"page":"43","totalPageCount":71,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}