{"pageProps":{"posts":[{"title":"Vercel이 가격 정책을 변경했어요  어떤 차이가 있을까요","description":"","date":"2024-05-12 21:25","slug":"2024-05-12-VercelJustChangeditsPricingHowDoesitCompare","content":"\n\n## 인기 있는 NextJS 프론트엔드 인프라 서비스는 과거 높은 비용에 대한 비판을 받아왔습니다.\n\n![이미지](/assets/img/2024-05-12-VercelJustChangeditsPricingHowDoesitCompare_0.png)\n\nVercel은 NextJS를 위한 회사로, GitHub에서 12만 개 이상의 스타를 받은 제작용 React 애플리케이션에 대한 널리 알려진 무료 및 오픈소스 소프트웨어(FOSS) 프레임워크입니다. 실제로 NextJS는 React 팀이 공식 문서 웹사이트에서 프로젝트를 시작하기 위한 권장 솔루션입니다.\n\nFOSS NextJS 프로젝트 외에도 Vercel은 NextJS 프로젝트를 배포하기 위한 무료 및 유료 인프라 서비스(IaaS) 옵션을 제공합니다. 이 서비스는 프로젝트를 손쉽게 구축하고 실행하는 과정에서 복잡성을 제거하는 많은 기능때문에 많은 개발자들에게 좋아지고 있습니다. AWS EC2와 같은 웹 애플리케이션을 배포하는 보다 기본적인 옵션과 비교했을 때, Vercel은 훨씬 추상화되어 있으며, 몇 번의 클릭으로 NextJS 프로젝트를 배포하고 사용자에게 제공할 수 있습니다.\n\n\n\n그러나 Vercel은 가격 정책에 대해 지속적인 비판을 받아왔습니다. Hobby 및 Pro 티어는 소규모에서 비교적 저렴하지만, 포함된 초기 단위를 모두 사용한 후 가격이 급격히 상승합니다.\n\n# 주요 변경 사항\n\n2024년 6월 25일부터, Vercel은 비용을 더 증분 단위로 분할하여 개발자들이 비용을 더 효율적으로 최적화할 수 있도록 할 것입니다.\n\n## 대역폭\n\n\n\n버셀의 요금 체계에서 주요 고민거리는 과거에 고대로 높았던 대역폭 비용이었습니다. 대역폭은 버셀 서버 간 및 외부로 전송된 데이터 양을 의미합니다. 예를 들어, 랜딩 페이지에 많은 이미지나 다른 정적 파일이 포함되어 있다면, 이 비용이 빠르게 누적될 수 있습니다.\n\n현재 Pro 티어는 한 사용자당 월 $20이며 1TB의 대역폭을 포괄하는데 상당히 관대합니다. 그 이후로는 100GB당 $40 또는 다른 말로 $400/TB입니다.\n\n변경 후에도 Pro 티어의 요금은 한 사용자당 월 $20으로 유지되지만, 대역폭 비용은 다음과 같은 지표와 대부분의 지역에서의 소비 비용으로 분할될 것입니다 (지역별 요금은 여기서 확인하세요: https://vercel.com/docs/pricing#regional-pricing):\n\n- 아웃 바운드 데이터 전송 (버셀에서 사용자로): 1TB 포함, 한계 초과 후 $0.15/GB (또는 $150/TB)\n- 오리진 데이터 전송 (버셀 함수에서 버셀 엣지 네트워크로, 주로 캐시 미스와 API 루트): 월 100GB 포함, 한계 초과 후 $0.06/GB (또는 $60/TB)\n- 엣지 요청 (요청 횟수): 월 10백만 건 포함, 한계 초과 후 $2.00/백만 건\n- 증분형 정적 재생성: 포함 없음, 캐시 읽기당 $0.40백만 건 및 캐시 쓰기당 $4.00백만 건\n\n\n\n또한 100GB 단위로 청구되던 것 대신 이제는 1GB 단위로 청구됩니다. 이는 더 정확하고 독점적으로 더 낮거나 동등한 비용을 제공하게 됩니다 (예: 105GB를 사용한다면 200GB가 아니라 105GB에 대해 청구됩니다).\n\n## 기능\n\n대역폭 가격 변경 외에도, 기능 가격도 변경되었는데, 이것은 주로 엣지 네트워크 캐시 미스와 ISR 렌더링을 수행하고 API 루트를 제공하기 위해 사용됩니다.\n\n현재 Pro 티어에는 1,000 GB-시간의 컴퓨팅 및 100만 회 호출이 포함되어 있으며 추가 사용량에 대한 비용은 GB-시간 당 $0.40입니다.\n\n\n\n변경 사항 후, Pro 티어의 기능 비용은 다음 지표 및 소비 비용으로 분해될 것입니다:\n\n- 호출: 1개월에 1백만 건이 포함되어 있으며, 한계를 넘은 후에는 백만 당 $2.00\n- 컴퓨팅: 1,000GB-시간/월이 포함되어 있으며, 한계를 넘은 후에는 GB-시간 당 $0.18\n\n## 무료 티어\n\nVercel은 공지에서 Hobby/무료 티어에는 변경 사항이 없을 것이라고 밝혔습니다.\n\n\n\n# 평가\n\n이 발표에 관심이 있는 대부분의 사람들이 한 가지 궁금증을 가지고 있습니다. \"이것이 내 프로젝트의 청구서에 어떤 영향을 미칠까?\" Vercel은 기존 프로젝트 비용에 대한 변경 사항에 대해 다음과 같이 말했습니다:\n\n내가 가격을 살펴보면, 현재 프로젝트의 주요 비용 요인이 상당히 줄어들었으므로 일반적으로 이 성명에 동의할 것 같습니다. 그러나 구체적인 응용 프로그램에 따라 상황이 달라질 수 있습니다. 일부 응용 프로그램은 보다 추상적인 메트릭을 최대한 활용하도록 구축되어 있어, 이러한 새로운 세세한 메트릭을 사용하지 못할 수도 있습니다. 지금까지 우리는 기존의 이메일 중 일부를 보고, 고객들로부터 증가와 감소가 모두 나타났고, 때로는 양 방향으로 극심히 발생했다는 것을 알아냈습니다.\n\n예를 들어, 이 사용자는 예상 월 청구서가 $242에서 $188로 22% 감소했다고 보고했습니다:\n\n\n\n한편, 이 사용자는 간단한 $20/월 Pro 월간 요금에서 10배인 $201/월로 예상 청구액이 증가한 것을 발견했습니다.\n\n# 비용 최적화\n\n이 경우 높은 요금이 발생한 가장 가능성이 높은 이유는 ISR의 높은 사용량(희망적으로 최적화 가능)이거나 높은 요청 수(이 프로젝트들이 이전에는 대역폭에 미친 영향이 적었음을 의미)일 것 같습니다. Vercel은 이러한 새로운 지표에 대한 프로젝트 최적화 팁을 몇 가지 제공했는데, 이는 여기에서 확인할 수 있습니다:\n\n- 네트워킹 (데이터 전송 및 엣지 요청): [링크](https://vercel.com/docs/pricing/networking)\n- 함수: [링크](https://vercel.com/docs/pricing/serverless-functions)\n- ISR 데이터 캐시: [링크](https://vercel.com/docs/pricing/data-cache)\n\n\n\n게다가 Vercel은 \"100% 할인 (Fast Origin Transfer 및 Edge Requests)\"을 통해 비용이 증가하는 프로젝트에 대한 최적화 시간을 추가로 3개월 제공하고 있습니다.\n\n가격 변화가 발생하기 전에 새로운 비용에 대한 프로젝트 최적화에 대한 자세한 안내서를 Vercel 및 커뮤니티로부터 더 많이 보고 싶습니다. 이상적으로는 Vercel이 현재 프로젝트를 평가할 수 있는 계산기/비용 추정프로그램을 제공하여 이러한 지표를 최적화하는 프로젝트를 조정한 후 어떤 가격이 될지 확인할 수 있으면 좋겠습니다.\n\n# 대안(가장 저렴한 것부터 가장 비싼 것까지)\n\n## Vercel 대 AWS (OpenNext)\n\n\n\n가장 저렴한 대안은 Vercel의 인프라를 활용하는 것이고, Vercel은 기본적으로 AWS 서버리스 기술을 사용하여 인프라를 구축합니다. Vercel이 제공하는 서버리스 확장성과 동일한 기능을 갖추기 위해 AWS를 NextJS에 활용하는 것은 쉽지 않습니다. 왜냐하면 Vercel은 오픈 소스 NextJS 프로젝트에 포함된 것보다 더 많은 빌드 단계를 추가했기 때문입니다. 그러나 SST의 OpenNext 프로젝트를 사용하면 AWS Lambda, CloudFront 및 기타 AWS 서비스로 배포하여 Vercel의 기능과 유사한 결과를 얻을 수 있습니다.\n\n가격\n\n- 구독 비용: 월 $0\n- 아웃바운드 데이터 전송 (AWS CloudFront에서 사용자로): 1TB/월 포함, 한계 초과 후 가격: $0.085/GB (또는 $85/TB)로 감소 단계적으로 최대 $0.025/GB까지 페타바이트 규모 애플리케이션에 대한\n- 오리진 데이터 전송 (CloudFront에서 AWS Lambda로, 특히 POST, PUT 등에 대해 - 주의: AWS Lambda에서 CloudFront로는 무료): 포함 없음, $0.02/GB\n- 엣지 요청 (CloudFront 요청 수): 10백만 개/월 포함 + 20만 개/월 캐시 미스 포함, 한계 이후 $1.00/백만 요청 + $0.40/백만 캐시 미스 S3 GET 요청\n- 증분 정적 재생성: 포함 사항 없음, 이를 양적으로 측정하는 쉬운 방법은 없으나 여기 아키텍처를 확인해보세요: https://open-next.js.org/inner_workings/architecture\n- 기능 호출: 1백만 개/월 포함, 한계 이후 $0.20/백만\n- 기능 컴퓨트: 888GB-시/월 포함, 한계 이후 $0.06/GB-시\n- 추가 사항: 모든 AWS 비용을 포함하는 것은 어려울 수 있습니다. 특히 Vercel은 많은 기능을 추상화하므로 인증서, 호스팅 영역, WAF 등 애플리케이션 비용에 추가 여유 마진을 고려해야 합니다. 또한 이는 CI/CD, 빌드 프로세스, 캐시 무효화 등을 포함하지 않으므로 배포 비용에 대한 여유 마진도 고려해야 합니다.\n\n제한 사항\n\n\n\n- 앱 라우터 지원이 부족합니다.\n- 개발자 도구가 없습니다.\n- 클라우드 기반 배포 파이프라인/프로세스가 포함되어 있지 않습니다.\n- Git 제공업체와의 통합이 포함되어 있지 않습니다.\n- 배포 미리보기가 지원되지 않습니다.\n- 모니터링이 포함되어 있지 않습니다.\n- WAF 가 포함되어 있지 않습니다.\n\n## Vercel vs Cloudflare Pages + Workers\n\nCloudflare는 매우 널리 사용되는 CDN 및 방화벽으로, NextJS 애플리케이션을 호스팅할 수 있는 옵션이 있습니다.\n\n가격\n\n\n\n- 구독 비용: 월 $5–30(페이지 티어에 따라 다름)\r\n- 아웃바운드 데이터 전송 (AWS CloudFront에서 사용자로): 무료\r\n- 오리진 데이터 전송 (Cloudflare 서비스에서 다른 Cloudflare 서비스로): 무료\r\n- 엣지 요청 (CloudFront의 수): 무료\r\n- 증분 정적 재생성: CloudFlare에서 지원되지 않음\r\n- 함수 호출: 1개월당 100만 회 포함, 한계 초과 시 100만 달러당 $0.15\r\n- 함수 컴퓨트: 월 111GB-시간 포함, 한계 초과 시 GB-시간 당 $0.45\r\n- 데이터 저장(정적 파일 및 ISR 캐시): 월 당 $0.023/GB\n\n제한 사항\n\n- 증분 정적 재생성(ISR) 지원되지 않음\n- 특정 노드 API와의 호환성 문제가 발생할 수 있는 엣지 런타임만 지원\n\n## Vercel vs AWS(Amplify)\n\n\n\nAWS는 Amplify라는 프레임워크를 사용하여 프론트엔드 인프라를 더 간단하게 관리할 수 있는 서비스를 직접 제공합니다. Amplify를 사용하면 NextJS를 간편하게 배포할 수 있습니다.\n\n가격\n\n- 구독 비용: 월 0달러\n- 아웃바운드 데이터 전송 (AWS Amplify에서 사용자로): 포함 안 함, 1GB당 0.15달러(또는 1TB당 150달러)\n- 오리진 데이터 전송 (AWS 서비스에서 다른 AWS 서비스로): 무료\n- 엣지 요청 (요청 횟수): 무료\n- 증분 정적 재생성: 이 지표로 측정되지 않음\n- 함수 호출: 포함 안 함, 임계점 이후 1백만 번당 0.30달러\n- 함수 컴퓨트: 포함 안 함, 임계점 이후 1GB-시간당 0.20달러\n- 데이터 저장 (정적 파일 및 ISR 캐시): 월 1GB당 0.023달러\n- 빌드 및 배포: 분당 0.01달러\n\n제한 사항\n\n\n\n- Edge API routes (Edge middleware 포함)는 지원되지 않습니다\n- On-demand incremental static regeneration (ISR)는 지원되지 않습니다\n- 국제화(i18n) 자동 로캘 탐지는 지원되지 않습니다\n- Next.js streaming은 지원되지 않습니다\n\n## Vercel vs Netlify\n\n마지막으로, Netlify는 NextJS 애플리케이션에 좋은 지원을 제공하는 다른 인기 있는 프론트엔드 인프라 솔루션입니다.\n\n가격\n\n\n\n- Netlify로부터 사용자들로의 아웃바운드 데이터 전송: 1TB 포함, 임계치 이후 $0.55/GB (또는 $550/TB)\n- 오리진 데이터 전송 (Netlify 서비스로부터 다른 Netlify 서비스로): 무료\n- 에지 요청 (요청 횟수): 무료\n- 증분 정적 재생성: 이를 양적으로 측정하기 어려우나 이 링크를 통해 작동 방식을 확인해보세요: [여기를 클릭하여 Netlify 문서 확인](https://docs.netlify.com/frameworks/next-js/runtime-v4/incremental-static-regeneration/)\n- 호출 + 컴퓨팅: 125,000 요청/월 + 100시간 컴퓨팅 포함, 그 후 1,875,000 요청 + 900시간에 대해 $25, 이후 500,000 요청 + 500시간마다 $19/증분\n\n제한사항\n\n- 에지 런타임에 설정된 SSR 페이지는 함수 영역에서 실행됩니다\n- Next.js 구성에서의 리라이트는 public 디렉토리의 정적 파일을 가리킬 수 없습니다\n- 안정성이나 실험적으로 표시된 Next.js 기능은 지원되지 않을 수 있습니다\n- next/image 이미지는 Netlify에서 작동하지 않습니다\n\n# 결론\n\n\n\n벌써 많은 개발자들에게는 Vercel의 요금 체계 변화가 이긴 것 같아요. Vercel을 사용할지 고려하던 많은 사람들에게 오랫동안 골칫거리였어요. 일부 요금 인상 때문에 많은 개발자들이 회의적인데, 적절한 최적화를 통해 그 인상을 크게 느끼지 않을 수도 있어요. 말하고자 하는 바는, 다른 옵션들이 계속해서 NextJS 기능을 지원해오면서, 편의성과 기능 지원 수준에 따라 더 저렴한 옵션을 제공하는 것이 많다는 거예요. Vercel이 여전히 NextJS 앱을 배포하기 위한 가장 편리한 옵션이긴 하지만, 다른 옵션들도 작년이나 최근 두 해 사이에 매력적으로 발전해왔고, 그들의 비용 대비 이득을 고려할 만하다고 생각돼요.","ogImage":{"url":"/assets/img/2024-05-12-VercelJustChangeditsPricingHowDoesitCompare_0.png"},"coverImage":"/assets/img/2024-05-12-VercelJustChangeditsPricingHowDoesitCompare_0.png","tag":["Tech"],"readingTime":7},{"title":"다음 세대 요청 라이브러리 알로바가 주요 업그레이드를 받았습니다 이제 더 사용하기 쉽고 높은 성능을 자랑합니다","description":"","date":"2024-05-12 21:24","slug":"2024-05-12-Thenextgenerationrequestlibraryalovahasreceivedamajorupgrademakingiteasiertouseandhigherinperformance","content":"\n\n<img src=\"/assets/img/2024-05-12-Thenextgenerationrequestlibraryalovahasreceivedamajorupgrademakingiteasiertouseandhigherinperformance_0.png\" />\n\n안녕하세요!\n\n아마도 alova라는 경량 요청 라이브러리를 들어보았을지도 모릅니다. 이 라이브러리는 개발자들의 에너지와 시간을 절약하면서 저렴한 비용으로 복잡한 데이터 요청을 구현하는 데 도와줄 수 있습니다.\n\nalova에 대해 더 알아보고 싶다면 공식 웹사이트를 방문해보세요. 거기에서 더 자세한 문서와 샘플 코드를 찾아볼 수 있어서 이 도구를 더 잘 이해하고 활용하는 데 도움이 될 것입니다.\n\n\n\naloval2.0가 출시된 지 1년이 되었습니다. 이 기간 동안 많은 칭찬을 받았습니다. 물론, 개선을 위한 많은 피드백도 받았고, 이를 통해 alova는 계속 성장하고 발전해왔습니다. alova에 기여해 주신 모든 분들께 감사드리며, 동시에 디자인상의 많은 중복과 결함을 인지하고 있습니다.\n\n이제 더 나은 서비스를 위해 3.0으로 업그레이드할 때입니다. 이 업그레이드의 목적은 주로 다음 목표에 집중합니다:\n\n- alova 구조 조정 및 응용 범위 확대\n- 사용 방법을 간소화하고 불필요한 API를 폐기하며 결함 있는 디자인을 조정\n- 일부 모듈을 재설계하여 성능을 개선\n\n구체적인 3.0 조정을 살펴보기 전에 alova가 무엇을 할 계획인지, 어디로 향하고 있는지 다시 살펴볼까요?\n\n\n\n# 네트워크 요청의 고통 요소들\n\n다수의 사람이 협업하는 기업급 프로젝트에서 클라이언트-서버 상호작용 비용이 비교적 높습니다.\n\n![이미지](/assets/img/2024-05-12-Thenextgenerationrequestlibraryalovahasreceivedamajorupgrademakingiteasiertouseandhigherinperformance_1.png)\n\n- 프론트엔드 및 백엔드 협업 비용이 높음:\n- 백엔드 알림에 따라: API 업데이트는 백엔드로부터 활성 알림이 필요합니다.\n- API 문서 의존: 프론트엔드는 정보를 얻기 위해 API 문서를 참고해야 합니다.\n- API 코드 작성: 프론트엔드는 API 문서에 따라 인터페이스 코드를 수동으로 작성해야 합니다.\n- 응답 데이터 유형 부재: API 응답 데이터에 기본적으로 유형 힌트가 없어 데이터 사용 비용이 증가합니다.\n- 버그 발생률 증가: API 변경으로 프로젝트의 버그 발생률이 증가할 수 있습니다.\n- 복잡한 데이터 상호작용 로직: 프론트엔드 요청이 종종 간단하지 않습니다. 프로젝트의 성능 및 개선에 대비하여 다양한 시나리오에 따라 요청을 보낼 때, 보내지 말아야 할 때, 응답 데이터 처리 방법 등을 고려해야 합니다. 이는 개발 시간 비용 및 코드 유지 보수 비용이 증가하게 됩니다.\n\n\n\n# 해결책\n\n![image](/assets/img/2024-05-12-Thenextgenerationrequestlibraryalovahasreceivedamajorupgrademakingiteasiertouseandhigherinperformance_2.png)\n\n- IDE 플러그인 (vscode/webStorm): 프런트엔드와 백엔드의 협업 문제 해결 (구체적인 해결책은 아래 Feishu 문서에서 확인 가능)\n- 요청 코드와 응답 데이터 유형을 자동으로 생성\n- API 문서를 코드에 내장하여 코드에서 API 인터페이스를 직접 조회 및 삽입 가능\n- 주기적으로 API 정보 업데이트 및 프런트엔드 개발에 알림 제공\n- 인터페이스 업데이트 기록을 유지하여 변경으로 인한 버그 예방\n- 요청 전략: 해당 요청 전략 선택 및 한 줄의 코드로 복잡한 데이터 상호 작용 로직 구현\n\n# alova 목표\n\n\n\n작은 문제를 요청하는 데 시간을 낭비하지 마세요. alova에 맡기세요. 요청 작업 대부분을 처리해 줄 거예요. 필요한 건 사용할 API와 요청을 실행할 전략을 명시하는 것뿐이에요.\n\n# alova@3.0 업데이트 계획\n\n# 릴리스 노트\n\n구체적인 업데이트 내용, 진행 상황, IDE 플러그인 디자인은 alova 제품 백서와 3.0 업데이트 개요에서 확인할 수 있어요.\n\n\n\n- 디스코드 커뮤니티에 가입하여 소통에 참여해보세요\n\n# 핵심 파트너를 찾아요\n\nalovajs는 현재 일정한 타당성 검증을 이룩했습니다. 개발 속도를 높이기 위해 alovajs에 동의하는 두 명의 친구를 핵심 팀에 초대하는 것이 필요합니다 (한 명은 이미 확인됨). 이들은 alovajs의 핵심 업무를 담당하게 됩니다. 이로써 엄청난 혜택을 받을 수도 있습니다. 더 알고 싶은 친구들은 핵심 구성원이 되어보기를 참고하세요.","ogImage":{"url":"/assets/img/2024-05-12-Thenextgenerationrequestlibraryalovahasreceivedamajorupgrademakingiteasiertouseandhigherinperformance_0.png"},"coverImage":"/assets/img/2024-05-12-Thenextgenerationrequestlibraryalovahasreceivedamajorupgrademakingiteasiertouseandhigherinperformance_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기","description":"","date":"2024-05-12 21:21","slug":"2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated","content":"\n\n## 간단한 애니메이션이 앱의 사용자 경험을 얼마나 높일 수 있는지 궁금했던 적이 있나요?\n\n잘 디자인된 애니메이션은 평범한 사용자 상호 작용을 진정으로 기억에 남는 경험으로 변화시킬 수 있습니다.\n\n이 포스트에서는 React Native와 Reanimated 라이브러리를 사용하여 모바일 앱에 맞춘 흥미로운 사용자 정의 '당겨서 새로고침' 애니메이션을 만드는 방법을 배우게 됩니다.\n\n## 그냥 React Native의 RefreshControl을 사용하는 것이 좋지 않을까요?\n\n\n\n리액트 네이티브로 모바일 애플리케이션을 개발할 때, Pull-to-refresh 기능을 구현하는 데 RefreshControl 컴포넌트를 주로 사용합니다.\n\n간단하고 직관적이지만, 꽤 기본적이며 제한된 사용자 정의 기능을 제공합니다. 이로 인해 여러분의 앱이 그저 다른 어떤 앱처럼 보이는 경우가 있을 수 있습니다.\n\n사용자 정의 애니메이션을 생성하면 앱의 모양과 느낌을 자유롭게 조절하여 브랜딩 및 디자인 언어와 완벽하게 일치시킬 수 있습니다. 이로써 앱이 더 독특하고 기억에 남는 사용자 경험을 제공하게 되어 앱이 더욱 독특하고 기억에 남게 만듭니다.\n\n## 왜 Animated가 아닌 Reanimated 라이브러리를 사용해야 하는가?\n\n\n\nReact Native에서 애니메이션에 관한 이야기가 나온다면, 두 가지 주요 라이브러리가 떠오르게 됩니다: 내장된 Animated 라이브러리와 더 고급화된 Reanimated 라이브러리가 있습니다.\n\nReanimated가 선호되는 이유는 몇 가지가 있습니다:\n\n- 성능:\nReanimated는 특히 복잡한 애니메이션에 대해 우수한 성능을 제공합니다. 네이티브 스레드를 활용하여 JavaScript 스레드 대신 작동함으로써 더 효율적으로 작동합니다. 이는 훨씬 부드러운 애니메이션을 가능하게 하며, 이는 원활한 사용자 경험을 위한 중요한 요소입니다.\n- 제스처 기반 애니메이션:\nReanimated는 더 복잡한 애니메이션 처리를 위한 더 나은 API를 제공하며, 제스처와 애니메이션의 더 섬세한 제어와 더 부드러운 통합을 가능케 합니다.\n- 선언적 접근: Animated와 달리, Reanimated는 애니메이션에 더 선언적인 접근 방식을 채용합니다. 이는 애니메이션이 더 복잡해지면서 이해하고 관리하기 쉬워집니다.\n\n# 시작하기\n\n\n\n이 튜토리얼에서는 간단한 앱을 향상시키고자 합니다. 이 앱은 FlatList에서 카드 형태로 표시되는 Dribbble 샷 목록을 보여줍니다. 우리의 목표는 사용자가 목록을 위로 당겼을 때 나타나는 사용자 정의 새로 고침 애니메이션을 추가하는 것입니다.\n\n## 프로젝트 복제 및 설정\n\n로컬 컴퓨터에서 저장소를 클론하고 프로젝트를 설정하기 위해 다음 단계를 따라주세요:\n\n저장소 복제:\n터미널을 열고 다음 명령어로 저장소를 클론하세요:\n\n\n\n```js\ngit clone https://github.com/teefouad/custom-rn-refresh-animation-start.git\n```\n\nVSCode에서 프로젝트 열기:\n이 강좌의 모든 코드는 app/index.tsx에 들어가기 때문에 해당 파일을 열어 다른 파일과 디렉터리를 무시할 수 있습니다.\n다음과 같은 내용이 표시됩니다:\n\n<img src=\"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png\" />\n\n의존성 설치:\n필요한 종속 항목을 설치하려면 npm install 또는 yarn을 실행하세요.```\n\n\n\n프로젝트 실행하기:\nnpm start 또는 yarn start를 실행하여 프로젝트를 시작하세요. 이렇게 하면 Metro 번들러가 초기화되고 앱이 개발 모드로 실행됩니다.\n\n프로젝트가 설정되었으므로, 이제 우리는 흥미로운 부분으로 빠져들 준비가 되었습니다: 우리의 사용자 정의 새로고침 애니메이션 만들기!\n\n# 애니메이션 만들기: 상단 스크롤 감지\n\n사용자 정의 애니메이션을 만드는 첫 번째 단계는 FlatList가 맨 위로 스크롤되었을 때 감지하는 것입니다.\n\n\n\n이를 위해 Reanimated에서 useAnimatedScrollHandler를 사용할 것입니다. 이 훅은 최적화되고 성능이 좋은 방식으로 스크롤 이벤트를 처리할 수 있는 함수를 제공할 것입니다.\n\n1. 먼저, Reanimated에서 훅을 import 해야 합니다:\n\n```js\n/**\n * Dependency imports\n */\n\n import React from 'react';\n import { FlatList, StyleSheet, View, ViewProps } from 'react-native';\n import Animated, { useAnimatedScrollHandler } from 'react-native-reanimated';\n```\n\n2. useAnimatedScrollHandler를 사용하여 스크롤 핸들러를 생성하세요:\n\n\n\n```js\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      console.log(event.contentOffset.y);\n    },\n  });\n\n  return (\n    ...\n```\n\n지금은 리스트 스크롤 위치를 기록하는 것으로 할게요.\n\n3. 리스트에 스크롤 핸들러를 연결해보세요. useAnimatedScrollHandler를 사용하여 만든 스크롤 이벤트 핸들러는 React Native의 FlatList와 호환되지 않을 것이므로 Reanimated에서 제공하는 FlatList로 대체해야 합니다.\n\n```js\nreturn (\n    <View style={styles.root}>\n      <Animated.FlatList\n        ...\n        onScroll={scrollHandler}\n        scrollEventThrottle={16} // 부드러운 성능을 위한 좋은 방법\n      />\n    </View>\n);\n```\n\n\n\nscrollEventThrottle 속성은 스크롤 이벤트가 발생하는 빈도를 제어합니다. 여기서 값이 16이면 스크롤 이벤트를 대략 16밀리초마다 캡처합니다. 이렇게 하면 애니메이션이 부드럽고 반응이 빠릅니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1280/1*6cGVuwIPgf4QnLIC79xN7g.gif)\n\n이제 콘솔에 스크롤 위치를 단순히 기록하는 대신, 이를 공유 값에 저장합시다.\n\n다음과 같이 코드를 업데이트하세요:\n\n\n\n```js\nimport Animated, {\n  useAnimatedScrollHandler,\n  useSharedValue,\n} from 'react-native-reanimated';\n\n...\n\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  const scrollPosition = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      scrollPosition.value = event.contentOffset.y;\n    },\n  });\n  ...\n```\n\n# 단계 2: 팬 제스처 캡처하기\n\n이제 목록이 화면 상단까지 스크롤된 것을 감지할 수 있게 되었으므로, 다음 단계는 사용자가 목록을 더 아래로 끌 때 팬 제스처를 캡처하는 것입니다. 이를 달성하기 위해 FlatList의 부모 View에 PanResponder를 사용할 것입니다.\n\n팬 응답자(pan responder)를 생성하기 위해 React Native에서 PanResponder를 가져오세요:```\n\n\n\n```js\nimport {\n  PanResponder,\n  StyleSheet,\n  View,\n  ViewProps,\n} from 'react-native';\n```\n\n그런 다음 PanResponder의 인스턴스를 저장하고 FlatList의 부모 View에 연결하기 위해 ref를 사용하십시오:\n\n```js\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  ...\n\n  const panResponderRef = React.useRef(\n    PanResponder.create({\n      onMoveShouldSetPanResponder: () => true,\n      onPanResponderMove: (event, gestureState) => {\n        console.log(gestureState.dy);\n      },\n    })\n  );\n\n  return (\n    <View\n      style={styles.root}\n      {...panResponderRef.current.panHandlers}\n    >\n      <Animated.FlatList\n        ...\n```\n\n이 코드를 자세히 살펴보고 각 부분이 하는 일을 이해해보겠습니다:\n\n\n\nPanResponder.create()\n이 함수 호출은 PanResponder 인스턴스를 만들며 터치 동작에 대한 앱의 응답 방법을 설명하는 객체를 받습니다. 그리고 PanResponder는 React Ref에 저장됩니다.\n\nonMoveShouldSetPanResponder: () =` true,\n터치 동작 중 움직임이 있을 때 호출되는 함수입니다. 여기서 true를 반환하면 사용자가 손가락을 움직일 때 Pan Responder가 계속해서 동작을 처리합니다.\n\nonPanResponderMove: (event, gestureState) =` ' ... '\n응답해야 할 제스처가 있으면, 이 함수는 제스처 동작 중 움직임이 발생할 때 실행됩니다.\n\ngestureState는 현재 제스처에 대한 다양한 데이터를 포함하는 객체로, 터치의 위치, 전체 움직임 등을 나타냅니다. 우리는 gestureState.dy에만 관심이 있으며, 이 값은 제스처 시작부터 Y방향으로 얼마나 움직였는지를 나타냅니다. 사용자가 얼마나 아래로 당겼는지를 추적하는 데 사용할 것입니다.\n\n\n\n현재 목록을 스크롤하려고 하면 응답하지 않는 것 같아요. 이것은 우리의 PanResponder가 계속해서 모든 팬 제스처를 캡처하기 때문에 발생합니다. 결과적으로 목록은 팬 제스처가 발생했음을 처리할 수 없죠. 일단 괜찮아요, 나중에 이 문제를 해결할 거예요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1280/1*JeG4IxcnUQdpcaBdWBzMnA.gif\" />\n\n이제 이동 값을 갖게 됐으니, 이 값을 활용해봅시다. 새로운 공유 값(shared value)을 생성하고 이동 값을 저장하는데 사용해요. 이 공유 값은 목록을 애니메이션화하는 데 활용할 수 있어요.\n\n```js\n...\n\nconst pullDownPosition = useSharedValue(0);\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    onMoveShouldSetPanResponder: () => true,\n    onPanResponderMove: (event, gestureState) => {\n      pullDownPosition.value = gestureState.dy;\n    },\n  })\n);\n\n...\n```\n\n\n\n다음 단계는 Reanimated의 useAnimatedStyle 훅을 사용하여 일부 스타일을 생성하고 적용하는 것입니다. 이 훅은 Reanimated에서 제공되며 공유 값이나 다른 반응형 변수에 기반한 동적 스타일을 생성할 수 있게 해줍니다.\n\n참고: 스타일을 목록 자체가 아닌 목록 부모 View에 적용해야 합니다. 또한 React Native의 View가 아닌 Animated.View를 사용해야 합니다.\n\n```js\n...\nimport Animated, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n} from 'react-native-reanimated';\n\n...\n\nconst pullDownStyles = useAnimatedStyle(() => {\n  return {\n    transform: [\n      {\n        translateY: pullDownPosition.value,\n      },\n    ],\n  };\n});\n\nreturn (\n  <Animated.View\n    style={[styles.root, pullDownStyles]}\n    {...panResponderRef.current.panHandlers}\n  >\n    <Animated.FlatList\n      data={data}\n      ...\n```\n\n\n\n저희 코드를 약간 수정하여 사용자가 목록을 아래로 당길 수는 있지만 상단 경계를 넘어서 올릴 수 없도록 해보겠습니다:\n\n```js\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n\n    onPanResponderMove: (event, gestureState) => {\n      pullDownPosition.value = Math.max(gestureState.dy, 0);\n    },\n  })\n);\n...\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*FTJzKVw9pWxBXYxL4Nrf1g.gif\" />\n\n풀다운 애니메이션을 완성하기 위해, 팬 제스처가 해제될 때 pullDownPosition 공유 값을 제로로 재설정해보겠습니다. Reanimated는 공유 값을 애니메이션화할 수 있는 일련의 애니메이션 유틸리티 함수를 제공합니다. 이 경우에는 pullDownPosition 값을 매끄럽게 제로로 애니메이션화하기 위해 withTiming 함수를 사용하겠습니다.\n\n\n\n```js\n...\nimport Animated, {\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n} from 'react-native-reanimated';\n\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: () => {\n      pullDownPosition.value = withTiming(0, { duration: 180 });\n    },\n  })\n);\n```\n\n팬 제스처는 다른 제스처나 작업에 의해 조기에 종료되거나 중단될 수 있습니다. 다양한 상호 작용 시나리오에서 일관된 신뢰할 수 있는 사용자 경험을 보장하기 위해 onPanResponderRelease와 함께 onPanResponderTerminate도 사용합시다:\n\n```js\n...\n\nconst onPanRelease = () => {\n  pullDownPosition.value = withTiming(0, { duration: 180 });\n};\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: onPanRelease,\n    onPanResponderTerminate: onPanRelease,\n  })\n);\n\n...\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1280/1*9K8kEfhq4VnhQPZoe60Pfw.gif\" />\n\n\n\n# 단계 3: 목록의 스크롤 동작 복원하기\n\n간단한 작동하는 풀다운 애니메이션이 있지만, 목록의 정상적인 스크롤 동작이 보존되고 올바르게 작동하는지 확인해야 합니다.\n\nonMoveShouldSetPanResponder로 돌아가서 항상 true를 반환하는 대신 의미있는 것을 반환하도록 하겠습니다. 목록이 맨 위로 스크롤되고 사용자가 목록을 더 아래로 밀어내는 경우에만 풀다운 제스처를 허용할 것입니다. 이는 아래와 같이 해석됩니다:\n\n```js\n...\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    onMoveShouldSetPanResponder: (event, gestureState) =>\n      scrollPosition.value <= 0 && gestureState.dy >= 0,\n    onPanResponderMove: (event, gestureState) => {\n      pullDownPosition.value = Math.max(gestureState.dy, 0);\n    },\n...\n``` \n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1280/1*URAgW2RXvWsWs1YxrTLL6g.gif\" />\n\n잘 했어요! 목록이 이제 제대로 작동하고 풀다운 애니메이션이 의도대로 트리거되어 멋진 일을 해냈어요!\n\n이제 잠시 쉬는 시간이에요. 커피 한 잔을 즐기세요 ☕, 몇 분 휴식을 취한 후에 마지막 단계로 넘어갈게요.\n\n# 마지막 단계: 새로고침 트리거하기\n\n\n\n이제 튜토리얼의 가장 중요한 부분에 도달했어요. 여기서는 실제로 새로 고침 동작을 트리거할 수 있도록 로직을 설정하는 방법을 알아볼 거에요. 현재 사용자들은 목록을 아래로 내릴 수 있지만, 제약을 추가하고 언제 새로 고침을 활성화해야 하는지 정의하고 싶어요.\n\n## 최대 아래로 당기기 거리 설정\n\n지금 사용자들은 화면 아래쪽까지 목록을 아래로 끌어 내릴 수 있어요. 이것은 자연스럽지 않고 직관적이지 않게 느껴지죠. 그래서 우리는 아래로 당기는 거리를 최대 150픽셀로 제한할 거에요.\n\n```js\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderMove: (event, gestureState) => {\n      const maxDistance = 150;\n      pullDownPosition.value = Math.max(Math.min(maxDistance, gestureState.dy), 0);\n    },\n...\n```\n\n\n\n## 새로고침 트리거 지점 결정하기\n\n사용자가 이 150픽셀 범위의 절반 이상으로 당겼을 때, 새로고침 액션이 트리거될 준비가 된 것으로 간주합니다. 이 지점을 넘어서 제스처를 놓으면 새로고침 액션이 시작됩니다.\n\n```js\n...\nconst pullDownPosition = useSharedValue(0);\nconst isReadyToRefresh = useSharedValue(false);\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderMove: (event, gestureState) => {\n      const maxDistance = 150;\n      pullDownPosition.value = Math.max(Math.min(maxDistance, gestureState.dy), 0);\n\n      if (\n        pullDownPosition.value >= maxDistance / 2 &&\n        isReadyToRefresh.value === false\n      ) {\n        isReadyToRefresh.value = true;\n        console.log('새로고침할 준비 완료');\n      }\n\n      if (\n        pullDownPosition.value < maxDistance / 2 &&\n        isReadyToRefresh.value === true\n      ) {\n        isReadyToRefresh.value = false;\n        console.log('릴리스 시 새로고침하지 않음');\n      }\n    },\n...\n```\n\n공유 값 isReadyToRefresh는 목록을 충분히 당겼는지 여부를 나타냅니다. 이제는 제스처 릴리스 처리 논리를 업데이트해봅시다:\n\n\n\n```js\n...\n\nconst onPanRelease = () => {\n  pullDownPosition.value = withTiming(isReadyToRefresh.value ? 75 : 0, {\n    duration: 180,\n  });\n\n  if (isReadyToRefresh.value) {\n    isReadyToRefresh.value = false;\n\n    // 새로고침 실행\n  }\n};\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: onPanRelease,\n    onPanResponderTerminate: onPanRelease,\n  })\n);\n...\n```\n\n새로고침 작업을 트리거하는 메커니즘이 마련되었으니, 제스처(팬 릴리스)의 끝을 처리해봅시다.\n\n## 새로고침 작업 트리거\n\n사용자의 제스처가 끝나고 새로고침 작업 준비가 완료되면, onRefresh 함수를 호출할 것입니다. 이 함수는 하나의 매개변수를 받습니다. 해당 매개변수는 새로고침 작업이 완료된 후 애니메이션을 재설정할 done 함수입니다.```\n\n\n\n```js\n...\n\nconst pullDownPosition = useSharedValue(0);\nconst isReadyToRefresh = useSharedValue(false);\n\nconst onRefresh = (done: () => void) => {\n  console.log('새로 고침 중...');\n\n  setTimeout(() => {\n    console.log('새로 고침 완료!');\n    done();\n  }, 7500);\n};\n\nconst onPanRelease = () => {\n  pullDownPosition.value = withTiming(isReadyToRefresh.value ? 75 : 0, {\n    duration: 180,\n  });\n\n  if (isReadyToRefresh.value) {\n    isReadyToRefresh.value = false;\n\n    // 애니메이션을 재설정하는 함수\n    const onRefreshComplete = () => {\n      pullDownPosition.value = withTiming(0, { duration: 180 });\n    };\n\n    // 새로 고침 작업 실행\n    onRefresh(onRefreshComplete);\n  }\n};\n\n...\n```\n\n`onRefresh` 함수는 setTimeout을 사용하여 새로 고침 프로세스를 시뮬레이션합니다(실제 데이터 가져오기 프로세스의 가상 대체물로). 데이터가 새로 고쳐지면 애니메이션을 재설정하기 위해 `done` 콜백이 호출됩니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1280/1*qtBcIAWfx4fISFDhdmreFw.gif\" />\n\n# 애니메이션 구축하기\n\n\n\n이제 useAnimatedStyle 훅을 사용하여 새로 고침 애니메이션을 활성화할 준비가 되었습니다. 몇 가지 애니메이션 컴포넌트로 UI를 개선하면서 시작해 봅시다.\n\n## 배경 설정\n\n먼저, 애니메이션을 위한 배경을 만들겠습니다. 주요 UI를 View로 감싸고 기본 스타일을 적용하세요:\n\n```js\n...\n\nreturn (\n  <View\n    style={{\n      flex: 1,\n      backgroundColor: '#333',\n    }}\n  >\n    <Animated.View\n      style={[styles.root, pullDownStyles]}\n      {...panResponderRef.current.panHandlers}\n    >\n      <Animated.FlatList\n        ...\n      />\n    </Animated.View>\n  </View>\n);\n\n...\n```\n\n\n\n뷰는 애니메이션을 강조하는 어두운 배경을 제공하는 컨테이너 역할을 합니다.\n\n## 새로 고침 아이콘 통합\n\n다음으로, 회전하는 새로 고침 아이콘을 추가해 봅시다. 이 아이콘을 풀 다운 위치에 따라 확대 및 회전되도록 애니메이션화할 것입니다:\n\n```js\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  ...\n\n  const refreshContainerStyles = useAnimatedStyle(() => {\n    return {\n      height: pullDownPosition.value,\n    };\n  });\n\n  const refreshIconStyles = useAnimatedStyle(() => {\n    const scale = Math.min(1, Math.max(0, pullDownPosition.value / 75));\n\n    return {\n      opacity: Math.max(0, pullDownPosition.value - 25) / 50,\n      transform: [\n        {\n          scale: scale,\n        },\n        {\n          rotate: `${pullDownPosition.value * 3}deg`,\n        },\n      ],\n    };\n  });\n\n  return (\n    [styles.refreshContainer, refreshContainerStyles]}>\n        <Animated.Image\n          source={refreshIcon}\n          style={[styles.refreshIcon, refreshIconStyles]}\n        />\n      </Animated.View>\n\n      ...\n    </View>\n  );\n};\n```\n\n\n\n\n![Loading animation](https://miro.medium.com/v2/resize:fit:1400/1*OVJMKGr9f4IJG3Ou7KTUjA.gif)\n\n이제 '새로 고침 중...'이라는 단어를 단순히 기록하는 대신 상태 값을 사용하여 UI를 업데이트하고 새로 고침이 진행 중임을 나타내겠습니다:\n\n```js\n...\n\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  ...\n\n  const pullDownPosition = useSharedValue(0);\n  const isReadyToRefresh = useSharedValue(false);\n  const [refreshing, setRefreshing] = React.useState(false);\n\n  const onRefresh = (done: () => void) => {\n    setRefreshing(true);\n\n    setTimeout(() => {\n      setRefreshing(false);\n      done();\n    }, 7500);\n  };\n\n  ...\n\n  return (\n    <View\n      pointerEvents={refreshing ? 'none' : 'auto'}\n      style={\n        flex: 1,\n        backgroundColor: '#333',\n      }\n    >\n\n    ...\n```\n\n데이터가 아직로드 중인 동안 원치 않는 pull-down 제스처를 제어하고 방지하려면 pointerEvents 속성을 추가했습니다.\n```  \n\n\n\n## 로고 애니메이션 구현하기\n\n조금 더 재미있게 만들기 위해 애니메이션 로고를 추가해봅시다. 사용한 애니메이션 로고는 원래 Tony Pinkevych가 Dribbble에서 만들었고, 저는 이 데모에 맞게 약간 수정했습니다.\n\n```js\n/**\n * 의존성 가져오기\n */\n\nimport React from 'react';\nimport { Image } from 'expo-image';\n\n...\n\nconst DribbbleShots: React.FC<DribbbleShotsProps & ViewProps> = () => {\n  ...\n\n  return (\n    <View\n      pointerEvents={refreshing ? 'none' : 'auto'}\n      style={\n        flex: 1,\n        backgroundColor: '#333',\n      }\n    >\n      <Animated.View style={[styles.refreshContainer, refreshContainerStyles]}>\n        {refreshing && (\n          <Image\n            source={animatedLogo}\n            style={ width: 280, height: '100%', objectFit: 'cover' }\n          />\n        )}\n\n        <Animated.Image\n          source={refreshIcon}\n          style={[styles.refreshIcon, refreshIconStyles]}\n        />\n      </Animated.View>\n\n    ...\n```\n\n마지막으로, refreshIconStyles를 업데이트하여 새로 고침 아이콘을 애니메이션 로고로 부드럽게 전환해보겠습니다.\n\n\n\n```js\nconst refreshIconStyles = useAnimatedStyle(() => {\n  const scale = Math.min(1, Math.max(0, pullDownPosition.value / 75));\n\n  return {\n    opacity: refreshing\n      ? withDelay(100, withTiming(0, { duration: 20 }))\n      : Math.max(0, pullDownPosition.value - 25) / 50,\n    transform: [\n      {\n        scaleX: refreshing ? withTiming(0.15, { duration: 120 }) : scale,\n      },\n      {\n        scaleY: scale,\n      },\n      {\n        rotate: `${pullDownPosition.value * 3}deg`,\n      },\n    ],\n    backgroundColor: refreshing ? '#fff' : 'transparent',\n  };\n}, [refreshing]);\n```\n\n마지막으로, 데이터를 로드하는 동안 스켈레톤 카드를 보여줄 것입니다:\n\n```js\n...\n\n<Animated.FlatList\n  ...\n  renderItem={({ item, index }) => (\n    <Card\n      loading={refreshing}\n      index={index}\n      image={item.image}\n      title={item.title}\n      likes={item.likes}\n    />\n  )}\n  onScroll={scrollHandler}\n  scrollEventThrottle={16}\n/>\n</Animated.View>\n\n...\n```\n\n이러한 마지막 손짓으로, 새로 고침 애니메이션이 기능적이면서 시각적으로 매력적으로 완성되었습니다.```\n\n\n\n# 활기찬 인상 깊은 애니메이션\n\n이제 창조의 시간입니다. 여기 창의성을 자극하고 다음 앱을 위한 몇 가지 아이디어를 제공할 인상적인 애니메이션의 선별된 목록이 준비되어 있습니다.\n\n![Animation 1](https://miro.medium.com/v2/resize:fit:1400/1*KB2KSwJq06LLyzA2_t-h1w.gif)\n\n![Animation 2](https://miro.medium.com/v2/resize:fit:1400/1*6L8rnyxjfPF-leE0x3Kigg.gif)\n\n\n\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*Fb1kzeeAhQVNEf5TTAZlrg.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*YU3TndEWRtBaNcjXf-JZVg.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*sMa1sfIYa6Zsl8Co0bCsEQ.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*N5X0Kbuz7jHxclWzBv-glw.gif)\n\n\n\n![image1](https://miro.medium.com/v2/resize:fit:1400/1*pZ8ddY3rFUoVBuTWAhRPTg.gif)\n\n![image2](https://miro.medium.com/v2/resize:fit:1400/1*bSPbDYoIz9zz3r2mCftWKw.gif)\n\n![image3](https://miro.medium.com/v2/resize:fit:1400/1*utIKDBZ3o_V_-ctf22CBSA.gif)\n\n![image4](https://miro.medium.com/v2/resize:fit:1400/1*Ti1YIVYL67ZQHWDXNX8ZzA.gif)\n\n\n\n![이미지1](https://miro.medium.com/v2/resize:fit:1400/1*948wumPUB-5spDMTYs0Odg.gif)\n\n![이미지2](https://miro.medium.com/v2/resize:fit:1400/1*V4UtSyfCN9DDpl70IxXSHA.gif)\n\n![이미지3](https://miro.medium.com/v2/resize:fit:1400/1*GA_UPaFN6krQMhRb3lGiqw.gif)\n\n![이미지4](https://miro.medium.com/v2/resize:fit:1400/1*m4aMIvlIMY5WGmyFL8q2gA.gif)\n\n\n\n# 결론\n\n우리의 사용자 정의 새로 고침 애니메이션 자습서가 마무리되었습니다! 아마도 이것이 여러분의 프로젝트에 몇 가지 아이디어를 불러일으켰으면 좋겠네요. 다양한 애니메이션을 실험해보고 해당 앱의 사용자 경험을 어떻게 향상시킬 수 있는지 확인해 보는 것을 권장합니다.\n\n기억하세요, 배우는 가장 좋은 방법은 직접 해보는 것이기 때문에 고유한 새로 고침 애니메이션을 만들어보는 것에 도전해 보세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png","tag":["Tech"],"readingTime":18},{"title":"React JS를 바보들을 위한 React JS","description":"","date":"2024-05-12 21:20","slug":"2024-05-12-ReactjsforStupidsbyStupid","content":"\n\n저희는 HTML, CSS, 그리고 JavaScript (Typescript이면 더 좋지만 필수는 아닙니다!)에 대한 이전 지식이 있을 것으로 기대합니다!\n\n![ReactjsforStupidsbyStupid_0.png](/assets/img/2024-05-12-ReactjsforStupidsbyStupid_0.png)\n\n처음부터 시작하는 것은 참으로 좋지 않은 아이디어일 거에요, 왜냐하면 기억하세요, 당신만이 아니라, 저도 대형 PROCRASTINATOR, 아주 큰 PROCASTINATOR라는 사실을요!\n\n자, 시작해봐요!\n\n\n\n# React는 무엇인가요?\n\n간단히 말해 웹 앱을 디자인하는 데 도움이 되는 도구 모음이에요.\n\n사람들이 이것을 라이브러리라고 말하는 것을 들어봤을 수도 있어요!\n\n## 라이브러리란 무엇인가요?\n\n\n\n도서관 또는 패키지, 패키지는 일반적인 용도로 미리 작성된 코드가 들어있는 파일들의 묶음입니다. (혼란스럽다면 무시하세요!)\n\nmomentJs나 NPM에서 패키지를 사용해 보셨나요 (“npm install `패키지_이름`\")? React도 그와 같습니다. React는 웹 앱이나 사이트에서 사용자가 보는 UI를 구축하는 데 도움이 되는 패키지입니다. NPM을 통해 “npm install react\" 명령어를 사용하여 다운로드 또는 설치할 수 있습니다.\n\n더 복잡한 작업을 처리하려면 “react-router, react-router-dom, react-redux, 등\"과 같은 다른 패키지를 설치해야 할 수도 있습니다. 따라서 오직 REACT만으로 복잡한 웹 앱/사이트를 개발하는 것은 불가능합니다. 이러한 다른 도구들이 필요합니다.\n\nReact를 사용할 때 필요한 몇 가지 도구들은 바벨, 웹팩 또는 모듈 번들러와 같은 것들이 있습니다. 이 도구들은 개발자 경험을 향상시키기 위해 사용될 수 있지만 선택 사항입니다. 개발자들의 삶을 더 나은 것으로 만들기 위해 사용됩니다!\n\n\n\n지금은 작업을 완료하기 위해 설치하는 모든 패키지를 이해할 필요가 없어요. 그냥 기억해주세요. \"리액트만으로는 일이 끝나지 않아요\"라는 걸요. 왜냐하면 그것은 단지 라이브러리일 뿐이거든요.\n\n자, 다음으로 뭘 이해해야 할까요, 정확히 말이죠!\n\n# NPM이 무엇인가요?\n\n하지만 먼저 이해해야 할 것은 노드제이에스(NodeJs)에 대해서입니다.\n\n\n\n## 그래서, NodeJS란 무엇인가요?\n\nNodeJs는 JavaScript를 실행하는 데 사용하는 런타임 또는 간단히 말해 도구입니다.\n\n다른 언어를 사용해 보셨나요? C++이나 Java와 같은 다른 언어를 사용하려면 먼저 Java JDK(Java Development Kit)와 같은 컴파일러를 다운로드하고 설치해야 합니다. 그러나 JavaScript를 사용하려면 별다른 설치가 필요하지 않습니다. 그 이유는 브라우저에서 실행되며, NodeJs가 출시되기 전에는 브라우저가 JavaScript를 해석하는 유일한 도구였기 때문입니다.\n\n따라서, 이제 브라우저 밖에서 JavaScript를 사용하려면 서버 애플리케이션 또는 백엔드 애플리케이션을 구축하는 등의 목적으로 NodeJs를 다운로드해야 합니다.\n\n\n\nJDK가 Java 응용 프로그램을 구축하는 데 도움을 주는 것과 같이, NodeJs는 JavaScript 응용 프로그램을 구축하는 데 도움이 됩니다.\n\n## 이제 NPM은 무엇인가요?\n\n인터넷의 힘을 얻기 위해 PIP(python package installer 또는 manager)나 Dart 언어를 위한 Pub와 같은 패키지 관리자를 사용해본 적이 있을 수 있습니다. 마찬가지로, 우리에게는 NPM 노드 패키지 관리자가 있습니다. 그래서 우리는 \"react\"와 같은 필요한 패키지를 다운로드하고 설치하는 데 사용합니다.\n\nReact와 필요한 패키지를 설치한 후에는 무엇이 올까요?\n\n\n\n이제 코딩 부분이 나오게 되었어요, 설정은 완료되었어요!\n\n이 게시물에서는 이론적인 것들을 배웠고, 다음 게시물에서는 실습을 할 거에요. 그래서 즐겁게 읽었다면 댓글을 남겨주세요. 그래면 제가 미루기를 극복하고 글을 쓰는 데 도움이 될 거예요!\n\n#평화","ogImage":{"url":"/assets/img/2024-05-12-ReactjsforStupidsbyStupid_0.png"},"coverImage":"/assets/img/2024-05-12-ReactjsforStupidsbyStupid_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트에서의 의존성 주입","description":"","date":"2024-05-12 21:18","slug":"2024-05-12-DependencyinjectioninReact","content":"\n\n리액트 컴포넌트에는 비즈니스 로직이 포함되어서는 안 된다고 생각하시나요? 만약 그렇다면 계속 읽어주세요. 아니라면 지금 멈추세요. 이 기사는 다른 사람을 위한 것입니다.\n\n## TL; DR;\n\n리액트 프로젝트에 의존성 주입을 3단계로 추가해보세요:\n\n- 의존성을 넣을 \"컨테이너\"를 만드세요\n- 의존성을 검색하는 hook useInject를 만드세요\n- 컴포넌트에서 해당 훅을 사용하세요\n\n\n\n## 상세 버전\n\n답안이 망설여진다면, 이유에 대해 몇 가지 통찰을 제공해 드리겠습니다:\n\n- React는 사용자 인터페이스를 만들기 위한 라이브러리입니다; 이 정의를 통해 컴포넌트에 비즈니스 로직을 넣지 말아야 한다는 것을 알 수 있습니다.\n- 비즈니스 로직을 포함하는 컴포넌트는 읽기, 유지 관리, 테스트하기 어렵습니다.\n- 컴포넌트에서 비즈니스 로직을 추출하는 것은 재사용 가능한 좋은 아이디어입니다.\n\n그렇다면, 컴포넌트에서 비즈니스 로직을 분리하면 외부 클래스나 함수와 같은 곳에 쓰여져야 합니다. 어떻게 하면 될까요? 의존성 주입을 사용하여!\n\n\n\n## 의존성 주입이란 무엇이며 왜 사용해야 할까요\n\n의존성 주입(Dependency Injection, DI)은 객체 생성을 객체 사용과 분리하는 소프트웨어 디자인 패턴입니다. 실제로, 사용하는 코드 내에서 물건을 만들지 않고, 객체의 인스턴스화는 객체를 만들고 그것을 필요로 하는 구성 요소에 제공하는 외부 개체로 위임됩니다.\n\n의존성 주입은 코드를 더 유연하고 모듈식으로 만들어주며, 쉽게 테스트할 수 있도록 합니다. 강하게 결합된 코드 대신, 모듈식 구성 요소를 제공하여 필요에 따라 코드를 변경하지 않고 쉽게 교체하거나 확장할 수 있습니다.\n\n또한, DI는 코드의 가독성과 유지 보수성을 향상시키는 데 도움을 줍니다. 구성 요소 간의 의존성을 명시적으로 만들어 복잡한 의존성을 관리하는 것을 용이하게 합니다.\n\n\n\n요약하자면, 의존성 주입은 다음과 같은 목적으로 사용됩니다:\n\n- 객체의 생성과 사용을 분리합니다.\n- 코드를 더 유연하고 모듈화되며 쉽게 테스트할 수 있게 만듭니다.\n- 코드의 가독성과 유지보수성을 향상시킵니다.\n\n## React에서 의존성 주입\n\nReact 애플리케이션을 개발해야 한다고 상상해봅시다. 할 일 목록을 관리하는 React 애플리케이션을 만들어보겠습니다. (얼마나 멋져요 😅)\n\n\n\n할 일 목록을 표시하는 컴포넌트가 있습니다.\n컴포넌트가 렌더링될 때 목록을 API에서 로드하고 싶습니다. 그리고 컴포넌트에서 비즈니스 로직을 작성하지 않으려면 API 호출을 수행하는 서비스가 필요합니다. 아래 다이어그램에서 보여지는 것처럼요.\n\n```js\n              Component                  Service                       API\n                  |                          |                          |\n                  |                          |                          |\n                  |    데이터 요청           |                          |\n                  |------------------------->|                          |\n                  |                          |                          |\n                  |                          |  API에서 데이터 검색      |\n                  |                          |------------------------->|\n                  |                          |                          |\n                  |                          |    데이터 처리            |\n                  |                          |<-------------------------|\n                  |                          |                          |\n                  |  데이터 수신             |                          |\n                  |<-------------------------|                          |\n                  |                          |                          |\r\n```\n\n이 순서 다이어그램에서 컴포넌트는 메소드나 함수를 호출하여 서비스에 데이터 요청을 보냅니다. 그런 다음 서비스는 요청을 보내어 외부 API에서 데이터를 검색합니다. 데이터를 받은 후 서비스가 처리하고 컴포넌트로 반환합니다.\n\n다이어그램에서 화살표로 표시되는 이벤트 시퀀스를 볼 수 있습니다. API에서 서비스로의 점선 화살표는 API에서 데이터를 검색하는 것을 나타내며, 서비스에서 컴포넌트로의 실선 화살표는 처리된 데이터를 컴포넌트로 반환하는 것을 나타냅니다.\n\n\n\n구현 수준에서 코드는 이렇게 보일 수 있습니다:\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport TodoService from './TodoService';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n\n  useEffect(() => {\n    async function fetchTodos() {\n      try {\n        const todos = await TodoService.getTodos(); // TodoService를 호출하여 할 일 가져오기\n        setTodos(todos);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    fetchTodos();\n  }, []);\n\n  return (\n    - 목록\n      {todos.map(todo => (\n        - 아이디: {todo.id}, 제목: {todo.title}\n      ))}\n    - \n  );\n}\n\nexport default TodoList;\n```\n\n이 코드에서는 TodoService에서 getTodos 메서드를 호출하는 TodoList 컴포넌트를 정의합니다. useState 훅을 사용하여 서비스에서 반환된 할 일을 추적하고, useEffect 훅을 사용하여 컴포넌트가 마운트될 때 할 일을 가져옵니다.\n\nfetchTodos 함수가 호출될 때 await 키워드를 사용하여 getTodos 메서드가 할 일을 반환할 때까지 기다리며, 할 일이 반환되면 setTodos 함수를 사용하여 todos 상태 변수에 할 일을 설정합니다.\n\n\n\n마침내, map 함수를 사용하여 할 일 목록을 렌더링하고 각 할 일의 제목을 표시합니다. 이것은 간소화된 예제이며 TodoService의 구현은 사용된 API에 따라 달라질 수 있습니다.\n\n## props를 사용한 의존성 주입\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nfunction TodoList({ todoService }) {\n  const [todos, setTodos] = useState([]);\n\n  useEffect(() => {\n    async function fetchTodos() {\n      try {\n        const todos = await todoService.getTodos(); // 주입된 TodoService를 호출하여 할 일을 가져옴\n        setTodos(todos);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    fetchTodos();\n  }, [todoService]);\n\n  return (\n    - 목록\n      {todos.map(todo => (\n        - 고유 키{todo.id}{todo.title}\n      ))}\n    - 목록 종료\n  );\n}\n\nexport default TodoList;\n```\n\n이 업데이트된 코드에서는 TodoService를 TodoList 구성 요소의 prop으로 주입합니다. 구성 요소는 더 이상 TodoService를 직접 가져오지 않고 주입된 서비스를 사용하여 할 일을 가져옵니다.\n\n\n\n컴포넌트가 마운트될 때 fetchTodos 함수는 주입된 todoService를 사용하여 할 일을 검색합니다. 이렇게 함으로써 TodoService의 구현을 손쉽게 교체할 수 있습니다. 다른 서비스 구현체를 TodoList 컴포넌트에 전달하여 TodoService의 특정 구현체를 사용하려면 다음과 같이 서비스를 prop으로 전달합니다:\n\n```js\nimport React from 'react';\nimport TodoService from './TodoService';\nimport TodoList from './TodoList';\n\nfunction App() {\n  return <TodoList todoService={TodoService} />;\n}\n\nexport default App;\n```\n\nTodoService를 TodoList 컴포넌트에 prop으로 전달함으로써 TodoService의 특정 구현체를 사용할 수 있습니다. TodoList 컴포넌트를 수정하지 않고 TodoService의 다른 구현체간 쉽게 전환이 가능해지므로, 보다 모듈식이고 유연한 디자인을 구현할 수 있습니다.\n\n\n\n이 내용은 Component에 대한 테스트를 작성할 때 매우 유용할 수 있습니다.\n\n여기서 우리가 해결해야 할 두 가지 문제가 있습니다:\n\n- 우리는 아직도 의존성 주입을 사용하지 않는 App Component에 TodoService를 가져와야 합니다.\n- Props는 응용 프로그램 전체에서 데이터를 전달하는 효과적인 방법 중 하나일 뿐이며, 중첩 레이어와만 잘 작동합니다.\n\n```js\n              부모 Component\n                         |\n                         SubComponent A로 Prop 전달\n                         |\n                         |-SubComponent A\n                         |\n                         |\n                         SubComponent B로 Prop 전달\n                         |\n                         |\n                         |--SubComponent B\n                         |\n                         |\n                         SubComponent C로 Prop 전달\n                         |\n                         |\n                         |---SubComponent C\n```\n\n\n\n이 다이어그램은 프롭스가 컴포넌트의 계층 구조를 통해 전달되는 방법을 보여줍니다. 컴포넌트가 더 들여쓰여 있을수록 컴포넌트 트리에서 더 깊게 중첩됩니다. 이 중첩을 원치 않아요. 😨\n\n## React Context를 사용한 의존성 주입\n\n다음은 TodoContext를 사용하여 컴포넌트에서 TodoService를 호출하는 React 코드의 예시입니다:\n\n```js\nimport React, { useState, useEffect, useContext } from 'react';\nimport TodoContext from './TodoContext';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n  const todoService = useContext(TodoContext); // TodoContext에서 TodoService를 가져옴\n\n  useEffect(() => {\n    async function fetchTodos() {\n      try {\n        const todos = await todoService.getTodos(); // TodoContext에서 TodoService를 호출하여 todos 가져오기\n        setTodos(todos);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    fetchTodos();\n  }, [todoService]);\n\n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  );\n}\n\nexport default TodoList;\n```\n\n\n\n이 코드에서는 useContext 훅을 사용하여 TodoContext에서 TodoService를 가져옵니다. 그런 다음 가져온 todoService를 사용하여 할 일을 불러옵니다.\n\nuseEffect 훅은 컴포넌트가 마운트될 때 할 일을 불러오는 데 사용됩니다. fetchTodos 함수는 가져온 todoService를 사용하여 할 일을 불러와서 그것들을 할 일 상태 변수에 설정합니다.\n\n이 컴포넌트를 사용하려면 먼저 TodoContext를 생성하고 해당 컴포넌트를 래핑해야 합니다. 다음과 같이:\n\n```js\nimport React from 'react';\nimport TodoContext from './TodoContext';\nimport TodoService from './TodoService';\nimport TodoList from './TodoList';\n\nfunction App() {\n  return (\n    <TodoContext.Provider value={TodoService}>\n      <TodoList />\n    </TodoContext.Provider>\n  );\n}\n\nexport default App;\n```\n\n\n\n이 예제에서는 TodoContext를 생성하고 TodoService를 해당 값으로 전달합니다. 그런 다음 TodoList 컴포넌트를 TodoContext.Provider 컴포넌트로 감싸서 useContext 훅을 사용하여 컨텍스트에서 TodoService를 검색할 수 있도록 합니다.\n\n## 의존성 주입과 제어 역전 컨테이너 (IoC)를 사용한 의존성 주입\n\n이러한 컨텍스트 개념을 사용하여 제어 역전 컨테이너를 이용해 한 발 더 나아갈 수 있습니다.\n\n기다려봐요, 제어 역전 컨테이너 (IoC)란 무엇인가요?\n\n\n\nReact에서 IoC (Inversion of Control) 컨테이너는 여러 컴포넌트와 서비스 사이의 의존성을 관리하는 도구입니다. 이 도구를 사용하면 한 번에 서비스 또는 객체 (의존성)를 정의하고 등록한 다음, 이를 의존하는 다른 컴포넌트에 주입할 수 있습니다. 이를 통해 컴포넌트를 분리하고 응용 프로그램을 모듈식으로 만들고 유지보수하기 쉽게 할 수 있습니다.\n\nReact의 IoC 컨테이너는 대개 모든 의존성으로 사용할 수 있는 모든 객체를 참조하는 중앙 레지스트리를 제공함으로써 작동합니다. 컴포넌트는 직접 생성하는 대신에 이 컨테이너에서 이러한 의존성을 요청할 수 있습니다. 이 접근 방식은 또한 대체 구현으로 의존성을 교체하거나 테스트를 위해 목객체로 대체하기 쉽게 합니다.\n\nReact용 여러 인기있는 IoC 컨테이너로는 InversifyJS, Awilix, BottleJS 등이 있으며, 생성자 주입, 속성 주입, 자동 의존성 해결 등과 같은 다양한 기능을 제공합니다. 일부 IoC 컨테이너는 다른 것보다 더 복잡할 수 있으므로 프로젝트의 요구 사항과 복잡성 수준에 적합한 것을 선택하는 것이 중요합니다.\n\n우리의 경우, 아래와 같이 처음부터 예제를 작성할 것입니다:\n\n\n\n```js\r\nimport React, { createContext, useContext } from 'react';\n\n// 컨테이너를 위한 새로운 컨텍스트를 생성합니다\nconst ContainerContext = createContext();\n\n// 컨테이너를 자식 컴포넌트에 제공하는 컴포넌트를 정의합니다\nconst ContainerProvider = ({ container, children }) => {\n  return <ContainerContext.Provider value={container}>{children}</ContainerContext.Provider>;\n};\n\n// 컴포넌트 내에서 컨테이너에 접근하기 위한 훅을 정의합니다\nconst useContainer = () => {\n  const container = useContext(ContainerContext);\n  if (!container) {\n    throw new Error('컨테이너를 찾을 수 없습니다. 컴포넌트를 ContainerProvider로 감싸는지 확인해주세요.');\n  }\n  return container;\n};\n\n// 컨테이너에서 의존성을 주입하는 훅을 정의합니다\nconst useInject = (identifier) => {\n  const container = useContainer();\n  return container.resolve(identifier);\n};\n\n// 예시 사용법:\nconst MyService = () => {\n  return { foo: 'bar' };\n};\n\nconst MyComponent = () => {\n  const myService = useInject('myService');\n  return <div>{myService.foo}</div>; // 결과: 'bar'\n};\n\nconst container = {\n  registry: {\n    myService: MyService()\n  },\n  resolve(identifier) {\n    if (!this.registry.hasOwnProperty(identifier)) {\n      throw new Error(`식별자 ${identifier}로 식별되는 객체를 컨테이너에서 찾을 수 없습니다`);\n    }\n    return this.registry[identifier];\n  }\n};\n\nconst App = () => {\n  return (\n    <ContainerProvider container={container}>\n      <MyComponent />\n    </ContainerProvider>\n  );\n};\r\n```\n\n이 예제에서는 컨테이너 오브젝트를 prop으로 전달받아 ContainerProvider 컴포넌트를 생성하여 ContainerContext 컨텍스트를 사용하여 자식에게 제공하는 방법을 보여줍니다. 그리고 컴포넌트 내에서 컨테이너를 검색하는 useContainer 훅을 정의합니다.\n\n그런 다음 MyService 객체를 정의하고 컨테이너 오브젝트의 레지스트리 속성에 추가합니다. 또한 컨테이너 오브젝트에 식별자를 입력받아 해당 객체를 검색하는 resolve 메소드를 정의합니다. 이 경우 resolve 메소드는 MyService 객체를 반환합니다.\n\nMyComponent를 ContainerProvider로 감싸고 컨테이너 오브젝트를 prop으로 전달한 후 MyComponent를 렌더하는 App 컴포넌트를 렌더합니다. MyComponent가 렌더되면 컨테이너에서 myService 의존성을 검색하고 화면에 해당하는 foo 속성을 렌더합니다.```\n\n\n\n이 코드에서는 식별자를 매개변수로 전달받는 useInject 훅을 추가합니다. 이 훅은 컨테이너에서 해당 객체를 검색합니다. useInject 훅은 내부적으로 useContainer를 호출하여 컨테이너를 검색하고, 그런 다음 컨테이너에서 resolve 메서드를 호출하여 객체를 검색합니다.\n\n다음으로, useInject 훅을 사용하여 컨테이너에서 myService 의존성을 검색하고 그 foo 속성을 화면에 렌더링하는 MyComponent를 생성합니다.\n\n마지막으로, ContainerProvider로 랩핑된 MyComponent를 렌더링하는 App 컴포넌트를 렌더링합니다. MyComponent가 렌더링되면 useInject 훅을 사용하여 컨테이너에서 myService 의존성을 검색하고 해당 foo 속성을 화면에 렌더링합니다.\n\n요약하면, 의존성 주입은 더 유연하고 모듈식이며 쉽게 테스트할 수 있는 코드를 구현할 수 있는 디자인 패턴입니다. 이는 객체의 생성과 사용을 분리함으로써 컴포넌트 간의 의존성을 명시적으로 만들어 복잡한 의존성을 관리하기 쉽게 해줍니다.\n\n\n\n리액트에서는 종속성 주입을 프롭스로 서비스를 주입하거나 후크를 사용하여 컨테이너를 통해 컴포넌트에 종속성을 제공하여 구현할 수 있습니다. 이 방법을 사용하면 더 깔끔하고 유지보수가 쉬운 코드를 작성할 수 있으며 비즈니스 로직을 재사용하고 종속성을 관리하는 일이 더 쉬워집니다.\n\n이러한 패턴을 따르면 리액트 코드의 가독성, 유지보수성, 테스트 가능성이 향상될 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-DependencyinjectioninReact_0.png)\n\n와우, 마지막까지 왔군요. 이 기사는 실험이었습니다. 아이디어는 저의 것이지만 텍스트, 다이어그램 및 코드는 ChatGpt가 완전히 작성했습니다.","ogImage":{"url":"/assets/img/2024-05-12-DependencyinjectioninReact_0.png"},"coverImage":"/assets/img/2024-05-12-DependencyinjectioninReact_0.png","tag":["Tech"],"readingTime":11},{"title":"리액트 19의 새로운 기능 - 자산 로딩","description":"","date":"2024-05-12 21:17","slug":"2024-05-12-NewFeaturesinReact19AssetLoading","content":"\n\n🚀 리액트 19에서 자산 로딩을 통한 성능 최적화 🌟\n\n![이미지](/assets/img/2024-05-12-NewFeaturesinReact19AssetLoading_0.png)\n\n안녕하세요, 리액트 애호가 여러분! 리액트 19가 어떻게 자산 로딩을 관리하고 애플리케이션의 성능을 향상시키는지 살펴봅시다. 특히 이미지 및 기타 자산 파일에 관련해서 이야기해보겠습니다.\n\n리액트에서의 로딩 경험:\n\n\n\n리액트에서는 이미지와 같은 자산을 다룰 때 로딩 경험을 관리하는 것이 중요합니다. 일반적으로 뷰는 브라우저에서 먼저 렌더링되고, 그 다음으로 스타일 시트, 폰트, 이미지가 로드됩니다. 이는 비스티하지 않은 스타일에서 스타일이 적용된 뷰로 전환되면서 피드백이 발생할 수 있습니다(FOUC).\n\n리액트 19 이전:\n\nFOUC 문제를 완화하기 위해 개발자들은 종종 자산이 준비되었을 때 감지하는 사용자 정의 코드를 추가하여 모든 것이 로드된 후에만 뷰가 표시되도록 보장했습니다. 그러나 이 방식은 복잡하고 번거로울 수 있었습니다.\n\n리액트 19 이후:\n\n\n\n리액트 19에서는 이미지 및 다른 파일이 로드되는 방식에 중요한 개선이 있습니다. 이제 이러한 자산은 사용자가 현재 페이지를 탐험하는 동안 백그라운드에서 로드될 것입니다. 이 향상은 페이지 로드 시간을 개선하고 대기 시간을 크게 줄일 것으로 기대됩니다.\n\n라이프사이클 Suspense 소개:\n\n리액트 19는 자산 로딩을 위한 라이프사이클 Suspense 개념을 소개합니다. 이는 스크립트, 스타일시트 및 폰트를 포함합니다. 이 기능을 통해 React가 콘텐츠가 표시 준비가 된 시점을 결정하여 \"스타일이 적용되지 않은\" 깜박임을 제거합니다.\n\n새로운 자원 로드 API:\n\n\n\n또한, React 19에서는 preload 및 preinit과 같은 새로운 Resource Loading API를 소개하여 자원이 언제로 로드 및 초기화해야 하는지에 대한 더 큰 제어를 제공합니다. 이 수준의 제어는 자산이 필요한 때 정확히 로드되어 성능과 사용자 경험을 최적화합니다.\n\nReact 19에서는 자산을 백그라운드에서 비동기적으로로드함으로써 대기 시간을 최소화하고 사용자가 내용과 상호 작용하는 불편함 없이 이를 보장합니다. 이 최적화는 React 애플리케이션의 성능을 향상시킬뿐만 아니라 사용자에게 더 즐거운 브라우징 경험을 제공합니다.\n\n결론:\n\nReact 19의 자산 로드 및 성능 최적화 개선은 빠르고 반응적이며 즐거운 웹 애플리케이션을 만드는데 중대한 진전을 나타냅니다. 더 많은 업데이트를 기대해 주세요. React로 가능한 영역을 계속해서 확장해 나가요! 👩‍💻👨‍💻\n\n\n\n관련 링크:\n\n- React 19의 새로운 기능\n\n- React 19의 새로운 기능 — React 컴파일러\n\n- React 19의 새로운 기능 — 서버 컴포넌트\n\n\n\n새로운 기능: React 19 — 액션\n\n새로운 기능: React 19 — 웹 컴포넌트\n\n새로운 기능: React 19 — 문서 메타데이터\n\n새로운 기능: React 19 — 새로운 React 훅","ogImage":{"url":"/assets/img/2024-05-12-NewFeaturesinReact19AssetLoading_0.png"},"coverImage":"/assets/img/2024-05-12-NewFeaturesinReact19AssetLoading_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 앱을 애니메이션하는 5가지 방법","description":"","date":"2024-05-12 21:15","slug":"2024-05-12-5WaystoanimateaReactapp","content":"\n\n<img src=\"/assets/img/2024-05-12-5WaystoanimateaReactapp_0.png\" />\n\n리액트 앱에서 애니메이션은 인기 있는 주제입니다. 다양한 종류의 애니메이션을 만드는 많은 방법이 있습니다. 많은 개발자들이 CSS를 사용하여 애니메이션을 만들고 HTML 태그에 클래스를 추가하는 방법을 주로 사용합니다. 이것은 훌륭한 방법이며 사용해야 합니다. 더 복잡한 애니메이션을 만들고 싶다면 GreenSock을 사용해보세요. GreenSock은 가장 강력한 애니메이션 플랫폼 중 하나입니다. 또한, 리액트에서 애니메이션을 만드는 데 사용할 수 있는 많은 라이브러리와 컴포넌트들이 있습니다.\n함께 알아보겠습니다 😎\n\n- CSS 방법\n- React-transition-group — 기본 CSS 애니메이션과 전환을 간단히 구현할 수 있는 추가 컴포넌트입니다.\n- react-animations — React-animations은 animate.css의 모든 애니메이션을 구현합니다. 사용하기 쉽습니다!\n- React Reveal — 이것은 React용 애니메이션 프레임워크입니다.\n- TweenOne — ant.design에서 애니메이션에 사용하는 라이브러리\n\n물론 오픈 소스에는 더 많은 애니메이션 라이브러리와 컴포넌트가 있습니다. 탐험해보고 싶습니다. 그러나 이 글에는 라이브러리가 포함되지 않습니다. 또한, 글의 끝에서 주목할만한 라이브러리 형태로 보너스를 받게 될 것입니다.\n\n\n\n👨‍💻 시작해봐요.\n\n# 1.\nCSS 방법\n\n이 방법은 간단한 애니메이션에 가장 적합한 방법 중 하나에요. 자바스크립트 라이브러리를 가져오는 대신 이 방법을 사용하면 번들 크기가 작아집니다. 그리고 브라우저가 더 적은 자원을 사용하게 됩니다. 이 두 가지 요소는 앱 생산성에 상당한 영향을 미칩니다. 번들 크기와 앱 생산성에 신경을 쓰는 경우 간단한 애니메이션이 있다면 이 방법을 주목해보세요.\n\n이제 CSS를 사용하여 애니메이션을 어떻게 만드는지 보여드릴게요.\n햄버거 메뉴 예제를 살펴볼까요:👇\n\n\n\n![table](https://miro.medium.com/v2/resize:fit:1200/1*cosKxTRdOfM3YrNc_2Ah3g.gif)\n\n이 메뉴는 CSS 속성을 사용하여 쉽게 사용할 수 있으며 html 태그에 className=\"is-nav-open\"을 트리거로 사용합니다. 이 예제를 구현하는 여러 가지 방법이 있습니다. 그 중 하나는 네비게이션 위에 래퍼를 만들고 마진을 변경하는 것입니다. 네비게이션은 너비가 250px인 상수 너비를 가지고 있습니다. 그리고 너비가 같은 마진-왼쪽 또는 translateX 속성을 가진 래퍼가 있습니다. 네비게이션을 표시해야 할 때는 래퍼에 className=\"is-nav-open\"을 추가하고 래퍼를 margin-left/translateX: 0으로 이동해야 합니다.\n\n![image](/assets/img/2024-05-12-5WaystoanimateaReactapp_1.png)\n\n그리고 CSS 스타일:\n\n\n\n![이미지](/assets/img/2024-05-12-5WaystoanimateaReactapp_2.png)\n\n진실을 말하자면, 대부분의 상황에서 이 방법을 사용하는 것이 좋습니다. 몇 줄의 CSS를 작성하고 className을 트리거하는 것이 큰 라이브러리를 가져와 프로젝트에 구현하는 것보다 나은 선택입니다. 사용자들은 브라우저가 앱을 빨리 재생산하면 당신에게 감사할 것입니다.\n\n하지만 가끔 다른 방법을 사용해야 할 때도 있습니다. 다른 방법이 무엇이 있는지 알아보겠습니다. 다음 방법을 살펴보세요.\n\n## 2. ReactTransitionGroup\n\n\n\n이 추가 구성 요소는 ReactJs 커뮤니티에서 개발되었습니다. ReactTransitionGroup는 기본 CSS 애니메이션 및 전환을 손쉽게 구현할 수 있습니다.\n\n개발자들이 이 라이브러리를 다음과 같이 설명했습니다:\n\n어쨌든, 이 추가 구성 요소에 대해 알아야 할 세 가지 사항은 다음과 같습니다:\n\n- React Transition Group은 구성 요소 라이프사이클이 변경될 때 클래스를 변경합니다. 결국, 애니메이션 스타일은 CSS 클래스에 설명해야 합니다.\n- ReactTransitionGroup은 크기가 작습니다. React 애플리케이션용 패키지에 설치해야 하며 번들 크기를 크게 증가시키지 않습니다. 하지만 CDN을 사용할 수 있습니다.\n- ReactTransitionGroup에는 3개의 구성 요소가 있습니다(Transition, CSSTransition 및 TransitionGroup). 애니메이션을 얻으려면 해당 구성 요소를 감싸야 합니다.\n\n\n\n비슷한 애니메이션을 만드는 방법을 알아보겠습니다 👀👇\n\n![animation](https://miro.medium.com/v2/resize:fit:1200/1*AwFrD7KVn0gibJX5iVT5BA.gif)\n\n먼저 react-transition-group에서 CSSTransitionGroup를 import해야 합니다. 그 후 목록을 해당 그룹으로 감싸고 transitionName 속성을 설정해야 합니다. CSSTransitionGroup의 자식 요소가 추가되거나 삭제될 때 애니메이션 스타일이 적용될 것입니다.\n\n![transition](/assets/img/2024-05-12-5WaystoanimateaReactapp_3.png)\n\n\n\n만약 transitionName=\"example\" 프로퍼티를 설정하면, 스타일 시트에 있는 클래스들은 example 이름으로 시작해야 합니다. \n\n![이미지](/assets/img/2024-05-12-5WaystoanimateaReactapp_4.png)\n\nReactTransitionGroup 버전의 기본 사용법을 확인할 수 있어요. 👀\n\n이게 당신이 필요한 모든 것입니다. 물론, 어떤 로직을 추가해야 할 것입니다. 저희는 예제 연락처 목록을 구현하기 위한 두 가지 방법을 설명해야 합니다.\n\n\n\n설명드리겠습니다.\n먼저, handleAdd - 새로운 연락처를 추가하는 함수입니다. 랜덤한 이름을 생성한 후 이를 배열 상태인 state.items에 추가합니다. (랜덤한 이름을 생성할 때 random-name 패키지를 사용합니다)\n\nhandleRemove - state.items 배열에서 인덱스에 해당하는 연락처를 제거하는 함수입니다.\n\n\n![React Animations](/assets/img/2024-05-12-5WaystoanimateaReactapp_5.png)\n\n# 3️. React-animations\n\n\n\nReact-animations — 이 라이브러리는 animate.css를 사용하여 모든 애니메이션을 구축했습니다. 사용하기 쉽고 다양한 애니메이션 컬렉션이 있습니다. React-animation은 Radium, Aphrodite 또는 styled-components와 같이 객체를 사용하여 keyframe 애니메이션을 정의하는 인라인 스타일 라이브러리와 함께 작동합니다. 제가 가장 선호하는 styled-components를 사용하는 것을 선호합니다.\n\n여기서 일부 애니메이션을 볼 수 있습니다: 👀👇\n\n![GIF](https://miro.medium.com/v2/resize:fit:1200/1*2SJH2tItiljweyRgivf9JQ.gif)\n\n당신이 무엇을 생각하고 있는지 알고 있어요 😄\n\n\n\n![이미지](\"https://miro.medium.com/v2/resize:fit:940/1*1VZUa3mn3569l3ePzq3piA.gif\")\n\n이 애니메이션을 보자마자 그것들을 어디에 사용할 수 있을지 깨달았을 것입니다. \n이것이 어떻게 작동하는지 살펴봅시다. 예를 들어, 바운스 애니메이션을 봅시다.\n\n![이미지](\"https://miro.medium.com/v2/resize:fit:1200/1*bkPR-nhoZ5aTw_et9Mt7Ow.gif\")\n\nReact-animations에서 선택한 애니메이션을 import해야 합니다.\n\n\n\n이전에 언급한 대로, 기본 keyframes와 애니메이션 스타일이 적용된 wrapped 컴포넌트를 만든 후 styled-component를 사용하고 있어요.\n\n컴포넌트를 만들면 애니메이션을 적용하기 위해 어떤 HTML이나 컴포넌트를 래핑해야 해요.\n\n\n\n예시:\n\n![image](/assets/img/2024-05-12-5WaystoanimateaReactapp_8.png)\n\n애니메이션이 작동합니다. 이 애니메이션은 기본적이고 매우 간단합니다.\n\n스크롤 시 이 애니메이션을 사용하는 좋은 해결책이 있습니다 — react-animate-on-scroll.\n\n\n\n# 4️. React-reveal\n\nReact Reveal은 React용 애니메이션 프레임워크입니다. 페이드, 뒤집기, 줌, 회전 등의 기본 애니메이션이 있으며 더 많은 고급 애니메이션이 있습니다. 위치, 지연, 거리, 케스케이드 등과 같은 모든 애니메이션을 프롭스로 제어할 수 있습니다. 여기에서 확인할 수 있습니다. 사용자 정의 CSS 효과를 사용할 수도 있습니다. 또한 서버 측 렌더링 및 고차 컴포넌트가 있습니다. 스크롤 시 애니메이션을 사용하는 경우 이 프레임워크를 사용하면 좋습니다. 작동 방식을 살펴보세요.\n\n<img src=\"/assets/img/2024-05-12-5WaystoanimateaReactapp_9.png\" />\n\n스크롤 효과에 대한 이 애니메이션을 살펴보겠습니다.👀👇\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*Xk4c0gzjEu8RCsCyVRPlYg.gif)\n\n우리에게는 전체 화면 페이지와 제목이 내부에 있는 5개의 블록이 있습니다.\n\n![image](/assets/img/2024-05-12-5WaystoanimateaReactapp_10.png)\n\nanimateList 상수를 생성합니다. 이 배열에는 5개의 요소가 포함되어 있습니다. 배열 메서드 map을 사용한 후에는 각 요소를 Fade 구성 요소에 렌더링하여 아이템을 제목에 삽입할 수 있습니다. Const 스타일은 블록과 제목에 대한 간단한 CSS 스타일을 가지고 있습니다. 우리는 Fade 애니메이션으로 위에서 아래로 빛나는 5개의 블록을 가지고 있습니다.\n\n\n\n# 5️. TweenOne 및 애니메이션 Ant Design\n\nAnt Design은 사용하기 쉬운 여러 컴포넌트로 구성된 React UI 라이브러리입니다. 우아한 사용자 인터페이스를 구축하는 데 유용한 컴포넌트입니다. Ant Design은 중국 기업 알리바바에 의해 만들어졌으며 알리바바(물론), 텐센트, 바이두 등 많은 잘 알려진 회사들이 사용하고 있습니다.\n\n아마도 Ant Design에 대해 들어보았을 것입니다. 그래서 우리는 그들의 랜딩 페이지의 애니메이션을 살펴보겠습니다.👇\n\n![Ant Design Animation](https://miro.medium.com/v2/resize:fit:1200/1*_6S4VTzzGwRtebx-ys4htA.gif)\n\n\n\n위에서 보시다시피 많은 애니메이션 요소들이 있어요. 비슷한 애니메이션을 가진 요소들이 많아, 간단한 버전을 보여드리고 싶습니다. 전체 출발하는 지구 모습과 녹색 공, 그리고 배경에는 빨간 정사각형 한 개가 있어요. 우리의 애니메이션은 이렇게 보일 거에요.\n\n![animation](https://miro.medium.com/v2/resize:fit:1200/1*awI1UedVjvAwINK3lwCsyA.gif)\n\n이 애니메이션에서는 TweenOne 컴포넌트를 사용했지만, 애니메이션에 경로를 사용하기 위해 PathPlugin이 필요해요. PathPlugin을 TweenOne.plugins에 추가하면 잘 작동할 거에요.\n\n![path-plugin](/assets/img/2024-05-12-5WaystoanimateaReactapp_11.png)\n\n\n\n다음 단계에서는 기본 애니메이션 매개변수를 설명해 보겠습니다:\n\n- duration - 애니메이션 시간(밀리초 단위),\n- ease - 애니메이션 이징,\n- yoyo - 각 반복마다 앞뒤로 번갈아 가며 재생합니다.\n- repeat - 애니메이션을 반복합니다. 지속적인 프로세스를 위해 -1을 사용해야 합니다.\n- p - 애니메이션을 위한 경로 좌표입니다.\n- easePath - 애니메이션을 위한 이징 경로 좌표입니다.\n\n마지막 두 매개변수에 대해 걱정할 필요는 없습니다. 이것들은 이 SVG에 더 구체적인 매개변수입니다.\n\n다음으로 애니메이션 객체를 만들겠습니다. 이 객체에는 3 종류의 애니메이션이 있습니다:\n\n\n\n- redSquare — 아래에 설명한 루프 파라미터 및 Y 좌표, 지속 시간, 지연이 있습니다.\n- greenBall — x, y를 값 p로 하는 객체 파라미터를 갖는 경로가 있습니다. 지속 시간, 반복 및 ease는 TweenOne.easing.path 함수와 함께 있습니다:\n  - path — easePath 좌표.\n  - lengthPixel — 400 구간으로 나뉜 곡선.\n  - track — 루프 스타일과 rotate 파라미터가 있는 축을 가진 타원.\n\n![이미지](/assets/img/2024-05-12-5WaystoanimateaReactapp_12.png)\n\n이 코드에 대해 걱정할 필요는 없습니다. TweenOne 컴포넌트에 주의를 기울이셔야 합니다. 간단히 기억해 주겠습니다, 이러한 컴포넌트들은 rc-tween-one에서 가져올 것입니다. 기본 속성과 애니메이션 속성이 있는 기본 컴포넌트로 사용됩니다. 이것이 바로 우리의 애니메이션입니다! 각 TweenOne에는 redSquare, track, greenBall과 같은 고유한 애니메이션 규칙이 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*lIUAJ_Cu6PgTrL6MLj1uvA.gif)\n\n\n\n😄 조금 무서워 보이죠. 하지만 실제로 이 줄들에 주의를 기울여야 합니다.\n\n![Animation](/assets/img/2024-05-12-5WaystoanimateaReactapp_13.png)\n\n알아차린 것처럼, 이 방법으로 애니메이션을 생성하는 것은 간단한 방법입니다. 필요한 것은 애니메이션 규칙을 설명하고, 그것을 TweenOne 컴포넌트로 전달하는 것뿐입니다.\n\n## 🏁 결론\n\n\n\n애니메이션을 사용하는 여러 방법이 있습니다. 각각 다른 방법이 필요합니다. 오늘은 여러분의 프로젝트에서 사용할 수있는 몇 가지 결정을 검토했습니다. 당신에게 어울리는 방법을 선택하세요 👨‍💻\n\n🙂 이 기사를 읽기 전 당신의 사이트:\n\n<img src=\"/assets/img/2024-05-12-5WaystoanimateaReactapp_14.png\" />\n\n🤪 이 기사를 읽은 후 당신의 사이트:\n\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*emR9fk9Kt80Dugw5VSNkQA.gif\" />\n\n😄 애니메이션을 현명하게 활용해보세요!\n\n- Sentry를 활용한 React 앱의 오류 추적\n- React JS에서 CSS를 구현하는 9가지 방법\n\n# ❤️ 읽어주셔서 감사합니다\n\n\n\n재미를 내고 계속 배우며 코딩을 계속하세요.\n저를 Medium과 Linkedin에서 팔로우하세요.\n\n# 👏 좋아요, 공유 및 의겢을 남겨주세요.\n\n질문이나 피드백이 있으면 아래 댓글로 알려주세요 👇\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*itETjI1PFdtVKZvp5Qusxw.gif)\n\n\n\n- 리액트를 배우는 길\n- 리액트 배움: 함수형 웹 개발과 리액트 및 리덕스\n- Eloquent JavaScript, 3판: 프로그래밍에 대한 현대적인 소개\n- JavaScript: Definitive Guide: 웹 페이지 활성화(결정적 가이드)\n- 빠르게 배우는 React: 리액트, JSX, 리덕스 및 GraphQL을 이용한 무난한 웹 앱\n- JavaScript: 좋은 부분\n- JavaScript Patterns: 코딩 및 디자인 패턴으로 더 나은 애플리케이션 구축\n\n- react-motion — 애니메이션 문제를 해결하는 스프링\n- react-spring — 스프링 물리학 기반의 리액트 애니메이션 라이브러리\n- ant-motion — Ant Design의 애니메이션 명세 및 구성요소 애니메이션\n- react-move — 리액트를 위한 아름다운, 데이터 기반 애니메이션\n- react-flight — 리액트용 애니메이션 구성물을 구축하는 최고의 방법\n- react-flip-move — FLIP 기법을 사용하여 DOM 변경(예: 목록 재정렬) 사이의 무난한 애니메이션\n- react-burger-menu — CSS 전환 및 SVG 경로 애니메이션을 사용하여 효과 및 스타일 모음을 가진 오프캔버스 사이드바 구성 요소\n- animated — React 및 React Native를 위한 선언적 애니메이션 라이브러리\n- react-tween-state — React 애니메이션\n- react-animations — 인라인 스타일 라이브러리용 애니메이션 모음\n\n- GSAP — 현대 웹을 위한 고품질 애니메이션을 지원하는 초고성능 전문가급 애니메이션 라이브러리\n- Anime.js — Anime.js (/ˈæn.ə.meɪ/)는 간단하지만 강력한 API를 갖춘 경량 JavaScript 애니메이션 라이브러리입니다. CSS 속성, SVG, DOM 속성 및 JavaScript 객체와 함께 작동합니다.\n- Popmotion — 사용자 인터페이스를 위한 감각적인 애니메이션 라이브러리\n- vivus — SVG에 그리기 애니메이션을 만들기 위한 JavaScript 라이브러리\n- svg.js — SVG 조작 및 애니메이션을 위한 경량 라이브러리\n- velocity — jQuery의 $.animate()와 동일한 API를 갖춘 애니메이션 엔진인 Velocity\n- wow — 스크롤할 때 나타나는 애니메이션. 매우 애니메이트.css 친구.\n- dynamic.js — 물리 기반 애니메이션을 생성하기 위한 JavaScript 라이브러리\n- granim.js — 작은 JavaScript 라이브러리를 사용하여 유려하고 상호 작용적인 그래디언트 애니메이션 생성\n- kute.js — 코드 품질과 탁월한 성능을 갖춘 네이티브 JavaScript 애니메이션 엔진인 KUTE.js\n- TweenJs — JavaScript를 위한 간단하지만 강력한 트윈/애니메이션 라이브러리. CreateJS 라이브러리 스위트의 일부.\n- moveTo — 어떠한 종속성도 없는 가벼운 스크롤 애니메이션 JavaScript 라이브러리","ogImage":{"url":"/assets/img/2024-05-12-5WaystoanimateaReactapp_0.png"},"coverImage":"/assets/img/2024-05-12-5WaystoanimateaReactapp_0.png","tag":["Tech"],"readingTime":10},{"title":"DOM 트리의 일부 선택 인터뷰 문제","description":"","date":"2024-05-12 21:13","slug":"2024-05-12-PartialselectionofaDOMtreeAninterviewquestion","content":"\n\n\n![DOM 트리의 일부 선택에 관한 인터뷰 질문](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png)\n\n웹 페이지의 일부를 선택하는 문제는 상당히 실용적이며, 웹 레이아웃과 DOM 트리 간의 변환과 관련이 있어 시각적으로 흥미로운 문제입니다.\n\n이 문제는 웹 페이지의 일부를 선택하고 선택한 요소들을 모두 파악하여 화면에 표시된 순서대로 하나씩 나열하라는 내용입니다.\n\n이 유형의 문제를 해본 적이 없다면, 그 순간에는 압도적일 수 있습니다. 그러므로 이 글에서는 이에 대해 천천히 공부해보려 합니다.\n\n\n\n## 웹 페이지 부분 선택\n\n부분 선택하는 것이 좀 tricky 하죠. 정확히 어떤 것을 말하는 걸까요?\n\n모두가 아시다시피 페이지는 요소(element)로 이루어져 있습니다. 하나의 요소는 시각적인 요소일 수도 있고, 다른 요소들을 그룹화하는 요소일 수도 있습니다. 이것이 바로 DOM 트리라고 합니다.\n\n![DOM 트리의 부분 선택](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_1.png)\n\n\n\n간단히 하기 위해 위의 예시에서는 이진 트리를 사용했습니다. 하지만 실제로는 각 부모 아래 노드가 비어 있거나 하나, 두 개 이상의 요소를 포함할 수 있습니다. 이 질문의 첫 번째 과제는 위 트리를 웹 콘텐츠에 대응시키는 것입니다. 우리는 그렇게하는 일이 드물기 때문에 나무 노드에서 어떤 것이 무엇인지 명확하지 않아집니다. 그래서 웹 용어에 따라 노드에 레이블을 붙여 보겠습니다:\n\n![DOM tree image](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_2.png)\n\nbody 태그에서 시작합니다 (원한다면 html에서 시작할 수도 있어요 :). 그리고 페이지에는 헤더와 본문 두 섹션이 있습니다. 헤더를 예로 들면, 가로로 두 개의 div 태그가 있습니다. 그 중 하나에는 링크 태그로 래핑된 이미지 로고가 있습니다. 이것이 전형적인 헤더입니다. 비슷하게, 본문 섹션을 살펴보면, 하나의 article과 참고 자료 목록이 있습니다. article 안에는 컨텐츠 안에 있는 저자 이름이 들어 있는 중첩된 span이 있습니다. 그래서, 이제 이 웹 페이지의 올바른 정신적 이미지를 가졌으면 좋겠네요.\n\n트리의 위상 구조는 페이지의 레이아웃으로 잘 번역되지 않을 수 있습니다. 이것은 레이아웃이 위에서 아래로 이동하거나 왼쪽에서 오른쪽으로 이동할 수도 있고, CSS가 순서를 뒤집을 수도 있기 때문입니다. 반면에, DOM 트리 노드 표현은 한 가지 패턴으로만 이동할 수 있습니다: 부모로 들어가면 여러 자식을 볼 수 있고, 자식 안에는 자식의 자식을 볼 수 있습니다. 이 두 가지 시스템을 머리 속에서 동시에 운영하는 데 시간이 조금 필요할 수 있습니다.\n\n\n\n질문은 페이지의 일부를 선택하도록 우리에게 요청했습니다. 페이지의 로고에서 마우스를 드래그하여 기사의 작성자 이름에 놓는 것을 원한다고 가정해 봅시다. 먼저 요구 사항에서 생각해 봅시다. 우리가 실제로 무엇을 선택했나요?\n\n우리는 헤더 섹션에서 시작해서 본문 섹션에서 끝났습니다. 그래서 헤더 섹션에서 일부를 선택하고 본문 섹션에서 일부를 선택했습니다. 모두 부분적인 선택이라는 이유는 어떤 것도 완전한 선택을 받지 못했기 때문입니다. 이제 질문은 DOM 표현에서 부분적인 선택이 무엇인지 묻습니다.\n\n다음 강조부분에서 살펴보겠습니다:\n\n![Partial selection of a DOM tree: An interview question](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_3.png)\n\n\n\n아마도 일부 노드에는 시각적인 표현이 없을 것이라고 생각할 수 있습니다. 이 경우, 부모 노드(잎이 아닌)가 선택되지 않을 것이라고 가정한다면 main, article 및 마지막 div 노드를 숨길 수 있습니다. 기본적으로 오직 잎 노드만 표시될 수 있으므로 사용자가 볼 수 있는 것입니다.\n\n어차피, 어떤 변화던 주제가 크게 달라지지 않아야 합니다. 따라서 이 기사에서는 여전히 부모가 먼저 강조된 기본 버전에 대해 이야기합니다. 우리의 변명은 부모 노드(또는 startProcess)에서 시각적 표시가 전달될 수 있기 때문입니다.\n\n## DOM 노드의 트리 순회\n\n질문을 받기 전에 위의 그림을 보았다면, 아마도 어느 정도 여유를 가지고 질문에 대답할 수 있을 것입니다. 나머지는 주로 우리가 알고리즘 코더로서 훈련받은 방법입니다.\n\n\n\n트리 순회에 대해 이야기할 때, 주로 두 가지 패턴이 있습니다: 깊이 우선과 너비 우선입니다. 웹 페이지 표시는 깊이 우선 탐색으로 이루어집니다. 왜냐하면 우리는 body로 들어가고, 그리고 header로 들어가기 때문에 header가 표시되기 전에 main을 표시할 필요가 없습니다.\n\n이것은 한 조각의 내용을 가능한 한 자세히 공개하고 나서 다른 조각의 내용을 표시하려고 합니다. 레이아웃 관점에서 다음(또는 다른) 요소는 일반적으로 형제 노드입니다.\n\n먼저 자식을 다음으로 형제를, 이것이 깊이 우선 탐색입니다. 이것은 재귀 알고리즘을 사용하여 수행할 수 있다는 것을 의미합니다. 이것은 프로그래밍을 다소 쉽게 만들어주며, 스택을 사용할 필요가 없으므로 중첩 함수 호출이면 충분합니다.\n\n다음으로, 중위/전위/후위 순서는 혼동스러울 수 있습니다. 기본적으로 우리의 경우에는 각 요소에 도달한 후에 노드 이름을 표시하고, 그런 다음 자식 요소로 깊숙이 파고들 수 있도록 전위 순서인 경우가 될 수 있습니다: 먼저 이름을 수집하고 나서 자식 요소로 깊숙히 들어갑니다.\n\n\n\n```js\nbody -> header -> div -> p -> em\n-> div -> a -> img(*) -> a\n-> main -> article -> p -> div -> span(*)\n-> ul -> li -> li\n```\n\n위에 전위 순서로 인쇄된 트리 이동 목록이 있습니다. 이 목록에서 img와 span을 확인할 수 있고, 그것이 우리의 대답입니다. 이동할 때 기본적으로 img를 만나면 노드를 기록하기 시작하고 span을 감지할 때까지 마무리할 수 있습니다. 왜냐하면 img와 span 둘 다 질문의 입력이어야 하기 때문입니다. 여기서 마우스 동작(예: onDragStart)이 감지됩니다.\n\n잎 노드에만 초점을 맞추려면 잎이 아닌 노드를 수집하지 않는 것을 건너뛸 수 있으며, 이렇게 할 경우 다음 목록을 얻을 수 있습니다:\n\n```js\np -> em -> img(*) -> a\n-> p -> span(*) -> li -> li\n```\n\n\n\n우리는 다양한 변형이 가능할 거라고 가정할 수 있어요. 예를 들어, 무엇인가의 이유로 형제로 이동하기 전에 부모를 다시 방문해야 하는 경우가 있다면, 기술적으로 부모에게 끝내기 작업을 의존해야 하는 경우일 수도 있어요 (예: endProcess). 심지어  postorder 순회도 할 수 있어요:\n\n```js\np -> em -> div -> img(*) -> a -> a -> div -> header\n-> p -> span(*) -> div -> article\n-> li -> li -> ul -> main -> body\n```\n\n위 목록에서 부모(잎이 아닌 것)를 숨겨서 이전에 얻은 답변을 얻을 수도 있어요. 완성을 위해, 여기에 inorder 순회에 대한 인쇄결과가 있어요:\n\n```js\np -> div -> em -> header\n-> img(*) -> a -> div -> a -> body\n-> p -> article -> span(*) -> div -> main\n-> li -> ul -> li\n```\n\n\n\n어떤 문제에 inorder가 어떻게 도움이 될지 정확히는 모르겠지만, 어쨌든 특별한 용도가 있을지도 몰라요.\n\n따라서 특정 시점에 노드를 처리해야 할 필요가 있다면, 트리를 다른 방식으로 순회할 수도 있어요. 하지만 결국 이는 깊이 우선 탐색이기 때문에 무엇이든지, 올바른 답변에 가까워질 것이에요.\n\n![이미지](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_4.png)\n\n# 결론\n\n\n\n웹 페이지의 일부를 선택하는 것은 이해하기 어려울 수 있지만, 중요한 것은 어떤 노드가 어떤 내용 조각에 매핑되는지 위상적인 방식으로 알아내는 것입니다. 그 후에는 트리 순회 작업의 문제입니다.\n\n# 쉽게 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루어야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png"},"coverImage":"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png","tag":["Tech"],"readingTime":5},{"title":"Nextjs Monorepo 마스터하기 포괄적인 안내","description":"","date":"2024-05-12 21:12","slug":"2024-05-12-MasteringNextjsMonoreposAComprehensiveGuide","content":"\n\n웹 개발의 세계에서 Next.js는 서버 측 렌더링 및 정적 생성 웹 애플리케이션을 구축하기 위한 강력하고 다재다능한 프레임워크로 등장했습니다. 프로젝트가 커지면 여러 패키지와 종속성을 관리하는 것이 어려운 작업이 될 수 있습니다. 이때 모노레포가 필요해집니다. 모노레포(“monolithic repository\"의 줄임말)는 여러 프로젝트, 라이브러리 및 패키지를 수용하는 단일 저장소입니다. 이 글에서는 Next.js와 함께 모노레포를 사용하는 이점을 살펴보고 설정하는 방법에 대한 단계별 가이드를 제공할 것입니다.\n\nNext.js와 함께 모노레포를 사용하는 이유는 다음과 같습니다:\n\n- 간소화된 종속성 관리: 모노레포를 사용하면 모든 프로젝트의 종속성을 한 곳에서 관리할 수 있어 추적하고 업데이트하기 쉬워집니다.\n- 코드 재사용성: 단일 저장소에 여러 프로젝트를 담음으로써 프로젝트 간에 코드를 쉽게 공유하고 재사용할 수 있어 중복 코드의 양을 줄이고 유지보수성을 향상시킬 수 있습니다.\n- 개발 과정 단순화: 모노레포를 사용하면 여러 프로젝트를 동시에 개발하고 테스트할 수 있어 한 프로젝트의 변경이 다른 프로젝트를 깨뜨리지 않도록 보다 쉽게 확인할 수 있습니다.\n- 개선된 협업: 모노레포를 통해 개발자들은 여러 프로젝트에서 작업할 수 있어 여러 저장소 간에 전환할 필요가 없어 협업을 간소화하고 생산성을 향상시킬 수 있습니다.\n\n\n\nNext.js 모노레포 설정하기\nNext.js 모노레포를 설정하려면 Turborepo라는 인기있는 도구를 사용할 것입니다. Turborepo는 JavaScript 및 TypeScript 모노레포용 고성능 빌드 시스템입니다.\n\n단계 1: Turborepo 설치하기\n먼저 시스템에 Node.js와 npm이 설치되어 있는지 확인하세요. 그런 다음 다음 명령을 실행하여 Turborepo를 전역으로 설치하세요:\n\n```js\nnpm install -g turborepo\n```\n\n단계 2: 새 모노레포 만들기\n다음으로, 모노레포를 위한 새 디렉토리를 만들고 해당 디렉토리로 이동하세요:\n\n\n\n```js\nmkdir nextjs-monorepo\ncd nextjs-monorepo\n```\n\n이제 다음 명령어를 실행하여 새 Turborepo를 생성하세요:\n\n```js\nnpx create-turbo@latest\n```\n\n프롬프트에 따라 답변해주세요. Next.js 프리셋을 선택할 수 있습니다.\n\n\n\n**단계 3:** Next.js 앱 만들기\n모노레포를 설정한 후, 이제 모노레포 내에서 새 Next.js 앱을 만들 수 있습니다. 앱 디렉토리로 이동한 다음 다음 명령어를 실행하세요:\n\n```js\ncd apps\nnpx create-next-app@latest my-next-app\n```\n\n`my-next-app`을 앱에 원하는 이름으로 바꿔주세요.\n\n**단계 4:** 모노레포 구성\nTurboRepo는 모노레포의 빌드 및 작업 구성을 정의하기 위해 turbo.json 파일을 사용합니다. turbo.json 파일을 열고 pipeline 섹션을 업데이트하여 Next.js 앱을 포함하도록 설정하세요:\n\n\n\n```json\n{\n  \"pipeline\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\".next/**\"]\n    },\n    \"dev\": {\n      \"cache\": false\n    },\n    \"start\": {},\n    \"lint\": {\n      \"outputs\": []\n    },\n    \"test\": {\n      \"outputs\": []\n    }\n  },\n  \"globalDependencies\": {\n    \"my-next-app\": []\n  }\n}\n```\n\nStep 5: 이제 Next.js 앱을 실행하세요. Next.js 앱이 모노레포에 설정되었으므로 다음 명령어를 사용하여 실행할 수 있습니다:\n\n```json\nnpm run dev --filter=my-next-app\n```\n\nmy-next-app를 여러분의 Next.js 앱의 이름으로 바꿔주세요.\n\n\n\n이 기사에서는 Next.js를 사용한 모노 레포의 장점을 탐색하고, Turborepo를 사용하여 설정하는 방법에 대한 단계별 가이드를 제공했습니다. 모노 레포를 활용하면 의존성 관리를 간소화하고, 코드 재사용성을 향상시키며, 개발을 간소화하고, 팀 간 협업을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-MasteringNextjsMonoreposAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringNextjsMonoreposAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"실시간 알림 React에서 종류 및 구현","description":"","date":"2024-05-12 21:11","slug":"2024-05-12-Real-TimeNotificationsinReactTypesandImplementations","content":"\n\n![Real-Time Notifications in React: Types and Implementations](/assets/img/2024-05-12-Real-TimeNotificationsinReactTypesandImplementations_0.png)\n\n## 소개:\n\n실시간 알림은 웹 애플리케이션에서 사용자 참여를 촉진하고 적시에 업데이트를 제공하는 데 중요한 역할을 합니다. 이 안내서에서는 React 애플리케이션에서 다양한 유형의 실시간 알림과 그 구현을 탐색할 것입니다. Firebase 알림, One Signal 및 SignalR을 비롯한 많은 알림 라이브러리들이 있지만, 지금은 WebSocket, Server-Sent Events (SSE) 및 Push Notifications을 사용할 것입니다.\n\n## 실시간 알림의 유형:\n\n\n\n- WebSocket 통지: WebSocket은 클라이언트와 서버 간의 실시간 데이터 전송을 가능하게 하는 단일 TCP 연결 상에서 전이중(duplex) 통신 채널을 제공하는 통신 프로토콜입니다. 웹소켓 통지는 양방향 통신과 즉각적인 업데이트가 필요한 애플리케이션에 이상적입니다.\n- 서버 보낸 이벤트(SSE): 서버 보낸 이벤트(SSE)는 단일 HTTP 연결 상에서 서버로부터 클라이언트로의 스트리밍 업데이트를 위한 표준입니다. SSE 알림은 단방향적이며, 데이터가 서버에서 클라이언트로 흐릅니다. 서버가 클라이언트로부터 시작되는 요청 없이 업데이트를 푸시해야 하는 애플리케이션에 적합합니다.\n- 푸시 통지: 푸시 통지를 사용하면 웹 애플리케이션이 브라우저에서 열려 있지 않을 때에도 실시간 통지를 사용자에게 전달할 수 있습니다. 푸시 통지는 서버에서 사용자 기기로 서비스 작업자를 통해 전송되어, 시기 적절한 업데이트로 사용자 경험을 원활하게 만들고 사용자에게 다시 관심을 유도합니다.\n\n## React에서 구현:\n\nReact 애플리케이션에서 각 유형의 실시간 통지를 구현하는 방법을 살펴봅시다.\n\n\n\nReact에서 WebSocket 알림을 사용하려면 socket.io-client와 같은 라이브러리를 사용하여 서버와 WebSocket 연결을 설정하고 실시간 업데이트를 수신할 수 있습니다.\n\n```js\nimport React, { useEffect, useState } from 'react';\nimport io from 'socket.io-client';\n\nconst NotificationsComponent = () => {\n  const [notification, setNotification] = useState('');\n  useEffect(() => {\n    const socket = io('http://localhost:5000');\n    socket.on('notification', (data) => {\n      setNotification(data.message);\n    });\n    return () => {\n      socket.disconnect();\n    };\n  }, []);\n  return (\n    <div>\n      <h2>WebSocket 알림:</h2>\n      <p>{notification}</p>\n    </div>\n  );\n};\nexport default NotificationsComponent;\n```\n\n## Server-Sent Events (SSE):\n\nReact는 EventSource API를 통해 Server-Sent Events를 지원합니다. EventSource 객체를 사용하여 서버와 연결을 설정하고 업데이트를 수신할 수 있습니다.\n\n\n\n```js\nimport React, { useEffect, useState } from 'react';\n\nconst NotificationsComponent = () => {\n  const [notification, setNotification] = useState('');\n  useEffect(() => {\n    const eventSource = new EventSource('http://localhost:5000/notifications');\n    eventSource.onmessage = (event) => {\n      setNotification(event.data);\n    };\n    return () => {\n      eventSource.close();\n    };\n  }, []);\n  return (\n    <div>\n      <h2>Server-Sent Events (SSE) Notifications:</h2>\n      <p>{notification}</p>\n    </div>\n  );\n};\nexport default NotificationsComponent;\n```\n\n## 푸시 알림:\n\nReact에서 푸시 알림을 사용하려면 서비스 워커를 구현하여 들어오는 푸시 이벤트를 처리하고 사용자에게 알림을 표시해야 합니다.\n\n```js\n// 서비스 워커 파일 (sw.js)\nself.addEventListener('push', function(event) {\n  const data = event.data.json();\n  const title = '새 알림';\n  const options = {\n    body: data.message,\n    icon: '아이콘/이미지/경로.png',\n  };\n\nevent.waitUntil(\n    self.registration.showNotification(title, options)\n  );\n});\n```\n\n\n\nReact 컴포넌트에서 서비스 워커를 등록하고 푸시 알림을 위해 Notification API를 사용하는 방법을 설명했습니다.\n\n## 결론:\n\n실시간 알림은 웹 애플리케이션 사용자를 정보를 제공하고 참여시키는 데 중요합니다. 이 안내서에서 WebSocket, Server-Sent Events (SSE), 및 푸시 알림 세 가지 유형의 실시간 알림을 탐색하고 React 애플리케이션에서 구현하는 방법을 안내했습니다. 실시간 알림을 통합함으로써 사용자 경험을 향상시키고 적시에 업데이트를 제공하여 React 애플리케이션의 성공에 기여할 수 있습니다. 즐거운 학습과 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-Real-TimeNotificationsinReactTypesandImplementations_0.png"},"coverImage":"/assets/img/2024-05-12-Real-TimeNotificationsinReactTypesandImplementations_0.png","tag":["Tech"],"readingTime":4}],"page":"51","totalPageCount":71,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}