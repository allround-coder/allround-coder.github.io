{"pageProps":{"post":{"title":"JavaScript에서 설명하는 기본적인 OOP 개념","description":"","date":"2024-05-14 14:35","slug":"2024-05-14-BasicOOPConceptsExplainedinJavaScript","content":"\n\n# 소개\n\n객체 지향 프로그래밍은 소프트웨어 개발에서 가장 중요한 프로그래밍 패러다임 중 하나입니다.\n\n그래서 나는 JavaScript의 맥락에서 OOP의 기본 개념을 설명하는 이 기사를 쓰기로 결정했습니다.\n\n![이미지](/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png)\n\n\n\n# 클래스:\n\nOOP(객체 지향 프로그래밍)를 시작할 때 보통 가장 먼저 배우는 개념은 \"클래스\"입니다. 왜냐하면 OOP 패러다임이 시작되는 곳이기도 하고 이 패러다임의 기반이기 때문이죠.\n\n클래스는 나중에 우리가 객체라고 부르게 될 것을 정의하기 시작하는 곳으로, 메서드와 속성과 같은 모든 사용할 수 있는 것들을 클래스 내에서 정의합니다.\n\n자바스크립트의 클래스 예제를 살펴보겠습니다:\n\n\n\n위의 예제에서는 \"Car\"라는 클래스를 정의했습니다. 이 클래스에는 이름, 색상 및 모델과 같은 속성이 있으며, 내부에는 두 개의 메서드가 있습니다. 첫 번째 메서드(getCarName)는 이름 속성을 반환하는 역할을 하고, 두 번째 메서드(getCarDescription)는 차량의 설명을 형식화된 방식으로 반환하는 역할을 합니다.\n\n간단히 설명하자면, OOP에서의 속성은 클래스가 메서드에서 처리할 수 있는 값들이며, 메서드는 함수와 비슷하며 클래스의 속성을 사용하여 다양한 작업, 유효성 검사 또는 요청을 수행할 수 있는 곳입니다.\n\n클래스 개념에 대해 이미 다뤘으니 이제 객체 개념에 대해 이야기해보겠습니다.\n\n# 객체:\n\n\n\nOOP(객체 지향 프로그래밍)에서 객체 개념은 대부분 클래스 개념과 함께 사용됩니다. 왜냐하면 객체는 기본적으로 클래스의 인스턴스이기 때문이죠.\n\n따라서 객체는 우리가 이전에 정의한 속성과 메서드를 사용하는 곳입니다.\n\n이제 객체의 예시를 살펴봅시다:\n\n물론, 객체 예시는 클래스 예시와 거의 비슷하죠?\n\n\n\n이렇게 두 개념이 어떻게 함께 작동하는지 정말 잘 볼 수 있습니다.\n클래스 예제와 달리, 이제는 객체(클래스의 인스턴스)를 정의하고 클래스에 속성이 갖게 될 값을 알려줍니다(정확히 22번째 줄).\n\n그래서 이 객체 내에서 이것이 클래스 안에 있는 속성들의 값입니다:\n\n```js\nthis.name = \"Ferrari\",\nthis.color = \"Red\",\nthis.model = \"Roma\";\n```\n\n객체를 생성한 후, console.log() 메소드 내에서 \"getCarDescription\" 메소드를 호출하고, 다음과 같이 기록됩니다:\n\n\n\n```js\n\"차 설명: 이름: 페라리 - 모델: 로마 - 색상: 빨간색\"\n```\n\n# 정말 간단하죠?\n\n이 두 가지 기본 개념은 가장 중요한 것들 중 하나입니다. 왜냐하면 이 둘을 명확하게 이해하지 못하면 객체 지향 프로그래밍을 배우기 매우 어려워지기 때문이죠. 이 두 요소는 시스템이 정의된 클래스와 객체를 통해 상호 작용할 수 있는지 확인하기 위해 중요한 역할을 하며, 이를 통해 이 시리즈의 다음 장에서 설명될 상속, 캡슐화, 추상화 및 다형성과 같은 객체 지향 프로그래밍의 나머지 개념을 활용할 수 있습니다.```","ogImage":{"url":"/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png","tag":["Tech"],"readingTime":2},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"객체 지향 프로그래밍은 소프트웨어 개발에서 가장 중요한 프로그래밍 패러다임 중 하나입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 나는 JavaScript의 맥락에서 OOP의 기본 개념을 설명하는 이 기사를 쓰기로 결정했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"클래스:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"OOP(객체 지향 프로그래밍)를 시작할 때 보통 가장 먼저 배우는 개념은 \\\"클래스\\\"입니다. 왜냐하면 OOP 패러다임이 시작되는 곳이기도 하고 이 패러다임의 기반이기 때문이죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"클래스는 나중에 우리가 객체라고 부르게 될 것을 정의하기 시작하는 곳으로, 메서드와 속성과 같은 모든 사용할 수 있는 것들을 클래스 내에서 정의합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자바스크립트의 클래스 예제를 살펴보겠습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 예제에서는 \\\"Car\\\"라는 클래스를 정의했습니다. 이 클래스에는 이름, 색상 및 모델과 같은 속성이 있으며, 내부에는 두 개의 메서드가 있습니다. 첫 번째 메서드(getCarName)는 이름 속성을 반환하는 역할을 하고, 두 번째 메서드(getCarDescription)는 차량의 설명을 형식화된 방식으로 반환하는 역할을 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단히 설명하자면, OOP에서의 속성은 클래스가 메서드에서 처리할 수 있는 값들이며, 메서드는 함수와 비슷하며 클래스의 속성을 사용하여 다양한 작업, 유효성 검사 또는 요청을 수행할 수 있는 곳입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"클래스 개념에 대해 이미 다뤘으니 이제 객체 개념에 대해 이야기해보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"객체:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"OOP(객체 지향 프로그래밍)에서 객체 개념은 대부분 클래스 개념과 함께 사용됩니다. 왜냐하면 객체는 기본적으로 클래스의 인스턴스이기 때문이죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서 객체는 우리가 이전에 정의한 속성과 메서드를 사용하는 곳입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 객체의 예시를 살펴봅시다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"물론, 객체 예시는 클래스 예시와 거의 비슷하죠?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이렇게 두 개념이 어떻게 함께 작동하는지 정말 잘 볼 수 있습니다.\\n클래스 예제와 달리, 이제는 객체(클래스의 인스턴스)를 정의하고 클래스에 속성이 갖게 될 값을 알려줍니다(정확히 22번째 줄).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 이 객체 내에서 이것이 클래스 안에 있는 속성들의 값입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"name\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ferrari\\\"\"\n        }), \",\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"color\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Red\\\"\"\n        }), \",\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"model\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Roma\\\"\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"객체를 생성한 후, console.log() 메소드 내에서 \\\"getCarDescription\\\" 메소드를 호출하고, 다음과 같이 기록됩니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"차 설명: 이름: 페라리 - 모델: 로마 - 색상: 빨간색\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"정말 간단하죠?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 두 가지 기본 개념은 가장 중요한 것들 중 하나입니다. 왜냐하면 이 둘을 명확하게 이해하지 못하면 객체 지향 프로그래밍을 배우기 매우 어려워지기 때문이죠. 이 두 요소는 시스템이 정의된 클래스와 객체를 통해 상호 작용할 수 있는지 확인하기 위해 중요한 역할을 하며, 이를 통해 이 시리즈의 다음 장에서 설명될 상속, 캡슐화, 추상화 및 다형성과 같은 객체 지향 프로그래밍의 나머지 개념을 활용할 수 있습니다.```\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}