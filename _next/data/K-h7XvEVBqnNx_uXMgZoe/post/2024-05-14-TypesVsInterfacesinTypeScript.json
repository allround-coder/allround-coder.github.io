{"pageProps":{"post":{"title":"타입 vs 인터페이스 TypeScript에서","description":"","date":"2024-05-14 15:27","slug":"2024-05-14-TypesVsInterfacesinTypeScript","content":"\n\n\n![TypesVsInterfacesinTypeScript](/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png)\n\nTypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.\n\n오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.\n\n더 이상 미루지 말고 바로 들어가 봅시다.\n\n\n\n\n차이가 무엇인가요?\n\n이 동물 유형 및 인터페이스 정의를 분석해 봅시다:\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\n\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n```\n\n구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.\n\n\n\n이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.\n\n# 확장성\n\n확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.\n\n```js\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n\ninterface Dog extends Animal {\n  breed: string\n}\n\nconst dog: Dog = {\n  species: '포유동물',\n  name: '브루노',\n  breed: '저먼 셰퍼드',\n  age: 5\n}\n```\n\n\n\n개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.\n\n타입은 두 개의 타입을 병합하는 데 Union(`|`) 및 Intersection(`&`) 연산자를 사용하여 속성을 확장할 수도 있습니다.\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\ntype Dog = {\n  breed: string\n} & Animal\n\n// ❌ 작동하지 않음\ninterface Dog {\n  breed \n} & Animal\n```\n\n# 성능\n\n\n\n성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.\n\n이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.\n\nMatt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.\n\n# 인터페이스가 해로울 수 있는 이유\n\n\n\nTypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.\n\n선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.\n\n```js\n// 초기 Dog 인터페이스\ninterface Dog {\n  species: string\n  name: string\n  age: number\n}\n// \"선언 병합\"을 이용해 Dog 인터페이스 보강\ninterface Dog {\n  breed: string\n}\n\n// \"병합된\" 인터페이스로 새로운 \"개\"를 정의해봐\nconst dog: Dog = { name: \"Bruno\", age: 5, breed: \"German Shepherd\", species: \"Mamamal\" }\n```\n\n이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.\n\n그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.\n\n\n\n```js\n인터페이스 Cloner {\n  clone(animal: Animal): Animal;\n}\n인터페이스 Cloner {\n  clone(animal: Sheep): Sheep;\n}\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n\n// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:\n\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.\n\n## 클래스와의 안전하지 않은 병합\n\nTypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\n두 인터페이스의 병합 중에\n\n\n\n```js\n인터페이스 동물 {\n    a: 문자열;\n    b: 문자열;\n}\n\n인터페이스 개는 동물을 확장하며 {\n    c: 문자열;\n}\n\n클래스 개 {\n    constructor() {}\n}\n```\n\n위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.\n\n그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.\n\n```js\n클래스 개 {\n    a: 문자열;\n    b: 문자열;\n    c: 문자열;\n}\n```\n\n\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n| Types do not have this problem, and hence are more straightforward and safe to use as a result.                        |\n|--------------------------------------------------------------------------------------------------------------------------|\n| **Conclusion**                                                                                                          |\n| Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types. |\n| Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.                         |\n\n\n\n인터페이스와 성능 면에서도 타입들은 동일합니다.","ogImage":{"url":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h1: \"h1\",\n    h2: \"h2\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png\",\n        alt: \"TypesVsInterfacesinTypeScript\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더 이상 미루지 말고 바로 들어가 봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"차이가 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 동물 유형 및 인터페이스 정의를 분석해 봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"type \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\\n\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"확장성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"interface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": string\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dog\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'포유동물'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'브루노'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'저먼 셰퍼드'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"타입은 두 개의 타입을 병합하는 데 Union(\", _jsx(_components.code, {\n        children: \"|\"\n      }), \") 및 Intersection(\", _jsx(_components.code, {\n        children: \"&\"\n      }), \") 연산자를 사용하여 속성을 확장할 수도 있습니다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"type \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\\ntype \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": string\\n} & \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ❌ 작동하지 않음\"\n        }), \"\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" {\\n  breed \\n} & \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"성능\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Matt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"인터페이스가 해로울 수 있는 이유\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 초기 Dog 인터페이스\"\n        }), \"\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"선언 병합\\\"을 이용해 Dog 인터페이스 보강\"\n        }), \"\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": string\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"병합된\\\" 인터페이스로 새로운 \\\"개\\\"를 정의해봐\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dog\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" = { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Bruno\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"German Shepherd\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Mamamal\\\"\"\n        }), \" }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"인터페이스 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cloner\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \";\\n}\\n인터페이스 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cloner\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sheep\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sheep\"\n        }), \";\\n}\\n인터페이스 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cloner\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cat\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cat\"\n        }), \";\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:\"\n        }), \"\\n\\n인터페이스 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cloner\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cat\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cat\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sheep\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sheep\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"클래스와의 안전하지 않은 병합\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\\n두 인터페이스의 병합 중에\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"인터페이스 동물 {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": 문자열;\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"b\"\n        }), \": 문자열;\\n}\\n\\n인터페이스 개는 동물을 확장하며 {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"c\"\n        }), \": 문자열;\\n}\\n\\n클래스 개 {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"constructor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {}\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"클래스 개 {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": 문자열;\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"b\"\n        }), \": 문자열;\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"c\"\n        }), \": 문자열;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 마크다운 형식으로 변경하십시오.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"| Types do not have this problem, and hence are more straightforward and safe to use as a result.                        |\\n|--------------------------------------------------------------------------------------------------------------------------|\\n| \", _jsx(_components.strong, {\n        children: \"Conclusion\"\n      }), \"                                                                                                          |\\n| Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types. |\\n| Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.                         |\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"인터페이스와 성능 면에서도 타입들은 동일합니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}