{"pageProps":{"post":{"title":"Fetch API CORS 및 no-cors에 대한 궁극의 가이드","description":"","date":"2024-05-14 13:16","slug":"2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors","content":"\n\n\n<img src=\"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png\" />\n\n웹 애플리케이션에서 제3자 API 또는 서버에서 데이터를 가져와야 하는 경우가 있나요? 그렇다면, 요청한 데이터에 액세스하는 데 방해가 되는 Cross-Origin Resource Sharing (CORS) 오류를 만날 수도 있습니다.\n\n이 블로그 포스트에서는 Fetch API에서 CORS 및 No-CORS 모드를 사용하여 이러한 제약을 극복하고 외부 소스에서 데이터를 성공적으로 가져오는 방법을 살펴볼 것입니다.\n\n먼저, CORS가 무엇이며 왜 중요한지 이해해 봅시다.\n\n\n\n\n그러나 웹 애플리케이션에서 제3자 API 또는 서버로 요청을 보내야 할 때는 장애가 될 수도 있습니다.\n\n![image](/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_1.png)\n\nFetch API는 웹 애플리케이션에서 HTTP 요청을 보내는 방법을 제공합니다. Fetch를 사용하면 fetch() 함수의 mode 옵션을 사용하여 요청의 모드를 지정할 수 있습니다.\n\nmode 옵션은 `cors`, `no-cors`, `same-origin`, 또는 `navigate` 중 하나로 설정할 수 있습니다.\n\n\n\n`cors` 모드에서는 브라우저가 요청에 Origin 헤더를 포함하며, 서버가 허용 여부를 나타내는 Access-Control-Allow-Origin 헤더로 응답할 것을 기대합니다.\n\n서버가 적절한 헤더로 응답하면, 브라우저는 요청을 계속 진행하도록 허용하고 응답을 웹 페이지에 제공합니다. 이 모드는 제3자 API나 서버에 요청을 보낼 때 유용합니다.\n\n```js\nfetch('https://example.com/api/data', {\n  mode: 'cors',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    key1: 'value1',\n    key2: 'value2'\n  })\n})\n.then(response => response.json())\n.then(data => console.log(data))\n.catch(error => console.error(error));\n```\n\n`no-cors` 모드에서는 브라우저가 요청에 Origin 헤더를 포함하지 않으며, 서버의 응답이 불투명하게 처리되어 JavaScript 코드로 액세스할 수 없습니다. 이 모드는 서버로부터의 응답이 필요하지 않은 경우, 예를 들어 제3자 애널리틱스 서비스에 요청을 보낼 때 사용됩니다.\n\n\n\n이제 Fetch API에서 CORS 및 No-CORS 모드를 사용하는 방법을 이해했으므로, 언제 사용해야 하는지에 대해 이야기해보겠습니다.","ogImage":{"url":"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png"},"coverImage":"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png","tag":["Tech"],"readingTime":2},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    code: \"code\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"웹 애플리케이션에서 제3자 API 또는 서버에서 데이터를 가져와야 하는 경우가 있나요? 그렇다면, 요청한 데이터에 액세스하는 데 방해가 되는 Cross-Origin Resource Sharing (CORS) 오류를 만날 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 블로그 포스트에서는 Fetch API에서 CORS 및 No-CORS 모드를 사용하여 이러한 제약을 극복하고 외부 소스에서 데이터를 성공적으로 가져오는 방법을 살펴볼 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, CORS가 무엇이며 왜 중요한지 이해해 봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 웹 애플리케이션에서 제3자 API 또는 서버로 요청을 보내야 할 때는 장애가 될 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_1.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Fetch API는 웹 애플리케이션에서 HTTP 요청을 보내는 방법을 제공합니다. Fetch를 사용하면 fetch() 함수의 mode 옵션을 사용하여 요청의 모드를 지정할 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"mode 옵션은 \", _jsx(_components.code, {\n        children: \"cors\"\n      }), \", \", _jsx(_components.code, {\n        children: \"no-cors\"\n      }), \", \", _jsx(_components.code, {\n        children: \"same-origin\"\n      }), \", 또는 \", _jsx(_components.code, {\n        children: \"navigate\"\n      }), \" 중 하나로 설정할 수 있습니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"cors\"\n      }), \" 모드에서는 브라우저가 요청에 Origin 헤더를 포함하며, 서버가 허용 여부를 나타내는 Access-Control-Allow-Origin 헤더로 응답할 것을 기대합니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버가 적절한 헤더로 응답하면, 브라우저는 요청을 계속 진행하도록 허용하고 응답을 웹 페이지에 제공합니다. 이 모드는 제3자 API나 서버에 요청을 보낼 때 유용합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'https://example.com/api/data'\"\n        }), \", {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"mode\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'cors'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"method\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'POST'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"headers\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Content-Type'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'application/json'\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"body\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"JSON\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stringify\"\n        }), \"({\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"key1\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'value1'\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"key2\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'value2'\"\n        }), \"\\n  })\\n})\\n.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"response\"\n          }), \" =>\"]\n        }), \" response.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json\"\n        }), \"())\\n.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"data\"\n          }), \" =>\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(data))\\n.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"catch\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"error\"\n          }), \" =>\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(error));\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"no-cors\"\n      }), \" 모드에서는 브라우저가 요청에 Origin 헤더를 포함하지 않으며, 서버의 응답이 불투명하게 처리되어 JavaScript 코드로 액세스할 수 없습니다. 이 모드는 서버로부터의 응답이 필요하지 않은 경우, 예를 들어 제3자 애널리틱스 서비스에 요청을 보낼 때 사용됩니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 Fetch API에서 CORS 및 No-CORS 모드를 사용하는 방법을 이해했으므로, 언제 사용해야 하는지에 대해 이야기해보겠습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}