{"pageProps":{"post":{"title":"Nodejs가 쇠약하다고 Bun 10이 JavaScript 게임을 바꾼다","description":"","date":"2024-05-14 14:59","slug":"2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame","content":"\n\n![Node.js is Dying, Bun 1.0 is Changing the JavaScript Game](/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png)\n\n그 이전에, 자바스크립트 런타임이 무엇이며 왜 속도에 대해 신경 써야 하는지 설명해야 합니다.\n\n자바스크립트로 이야기를 쓰고 누군가에게 읽어달라고 부탁했다고 상상해보세요. 자바스크립트 런타임은 당신의 이야기를 살아있게 만드는 친근한 서술자 같은 존재입니다! 이것은 당신의 자바스크립트 이야기가 읽히고 연기되는 특별한 환경입니다. 하지만 좀 더 깊게 들어가보죠. 기술적으로, 이 '서술자'는 자바스크립트 엔진과 같은 구성 요소로 구성되어 있습니다. 이 엔진은 런타임의 핵심으로서 코드를 이해하고 실행하는 일을 담당합니다. 이것은 업무를 실행하고 코드가 스스로 걸림돌에 걸리지 않도록 하는 이벤트 루프와 같은 도구와 함께 사용됩니다. 또한 모든 캐릭터(또는 변수)가 각자 공간을 가지는 메모리 힙이 포함되어 있습니다. 씬별로 이야기의 액션이 일어나는 곳을 추적하는 호출 스택도 있습니다.\n\n# Bun 1.0 소개\n\n\n\nBun은 인기 있는 Node JS와 Deno보다 여러 가지 주요 장점을 가지고 있는 새로운 JavaScript 런타임입니다. Bun은 앱을 더 빠르게 만들기 위해 코드에 추가 복잡성을 추가할 필요 없이 설계되었습니다.\n\nNode.js의 대체물로 만들어졌기 때문에 Bun을 사용할 때는 node나 nodemon이 필요하지 않습니다. Bun은 내장된 감시 모드, dotenv, cross-env를 갖추고 있으며 .env 파일을 기본적으로 읽습니다.\n\n또한 Bun은 .js, .ts, .mjs, .jsx, .cjs, .tsx와 같은 다양한 파일을 실행할 수 있기 때문에 이제 프로젝트에 babel, tsc, ts-node 및 tsx를 설치할 필요가 없습니다.\n\nBun은 놀라운 성능을 자랑하는 JavaScript 번들러이며 esbuild 호환 플러그인 API를 제공하므로 esbuild, webpack 및 parcel도 필요하지 않습니다.\n\n\n\nBun은 npm과 yarn보다 빠른 속도가 가장 큰 이점 중 하나입니다. Bun은 npm과 yarn에 있는 익숙한 모든 명령어를 사용할 수 있는 npm 호환 패키지 매니저입니다. 또한 package.json 파일을 읽고 node_modules에 쓰지만 30배 빠르기 때문에 게임 체인저입니다.\n\n기본으로 Jest와 호환되는 테스트 러너를 내장하고 있어 추가 종속성을 설치하지 않고도 단위 테스트를 작성할 수 있습니다.\n\nNode.js의 대체할 수 있는 디자인으로 개발되었기 때문에 path, fs, net과 같은 일반적인 Node.js 모듈과 __dirname, process와 같은 전역 변수를 내장 지원합니다.\n\n# 성능 비교\n\n\n\n우리가 말했듯이 Bun은 Node.js보다 4배 빠르기 때문에 코드가 가벼워지고 실행 시간이 짧아지는데, 사용하기도 간단해요.\n\n```js\n$ bun install \n```\n\n<img src=\"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_1.png\" />\n\n테스트를 실행하는 차이는 더 미친 것 같아요.\n\n\n\n```js\n$ bun test\n```\n\n<img src=\"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_2.png\" />\n\n사용하기 쉽습니다. 다음은 Bun을 사용하여 HTTP 서버를 만드는 예제입니다.\n\n```js\nconst server = Bun.serve({\n  port: 3000,\n  fetch(request) {\n    return new Response(“Bun에 오신 것을 환영합니다!\");\n  },\n});\n\nconsole.log(`localhost:${server.port}에서 서버를 대기 중입니다`);\n```\n\n\n\n# Bun이 Node.JS를 대체해야 할까요?\n\n요약하면, Bun은 자바스크립트 세계에서 새롭고 멋진 장난감 같은 존재입니다. 다음 프로젝트에 무엇을 사용할지 고민 중이라면 Bun을 한 번 시도해보는 것을 권해드립니다. 신뢰성이 있고, Node.js에 없는 멋진 기능들을 갖추고 있으며 빠르기도 합니다.\n\nBun 팀이 다음에 어떤 일을 할지 기대되네요. 그리고 더 자세히 알고 싶다면, [공식 안내서](링크)를 확인해보세요. 필요한 모든 세부 정보가 담겨 있답니다!\n\nBun에 대한 생각은 어떠신가요? Node.js를 대체할 것인가요? 아래 댓글에서 함께 토론해보세요!\n\n\n\n# 친근한 한국어 번역\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가에게 박수를 보내고 팔로우하세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾을 수 있어요. 🚀\n- 무료 주간 뉴스레터에 가입하세요. 🗞️\n- 트위터(X), 링크드인, 유튜브, 디스코드에서 우리를 팔로우하세요.","ogImage":{"url":"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png"},"coverImage":"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png\",\n        alt: \"Node.js is Dying, Bun 1.0 is Changing the JavaScript Game\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그 이전에, 자바스크립트 런타임이 무엇이며 왜 속도에 대해 신경 써야 하는지 설명해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자바스크립트로 이야기를 쓰고 누군가에게 읽어달라고 부탁했다고 상상해보세요. 자바스크립트 런타임은 당신의 이야기를 살아있게 만드는 친근한 서술자 같은 존재입니다! 이것은 당신의 자바스크립트 이야기가 읽히고 연기되는 특별한 환경입니다. 하지만 좀 더 깊게 들어가보죠. 기술적으로, 이 '서술자'는 자바스크립트 엔진과 같은 구성 요소로 구성되어 있습니다. 이 엔진은 런타임의 핵심으로서 코드를 이해하고 실행하는 일을 담당합니다. 이것은 업무를 실행하고 코드가 스스로 걸림돌에 걸리지 않도록 하는 이벤트 루프와 같은 도구와 함께 사용됩니다. 또한 모든 캐릭터(또는 변수)가 각자 공간을 가지는 메모리 힙이 포함되어 있습니다. 씬별로 이야기의 액션이 일어나는 곳을 추적하는 호출 스택도 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Bun 1.0 소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bun은 인기 있는 Node JS와 Deno보다 여러 가지 주요 장점을 가지고 있는 새로운 JavaScript 런타임입니다. Bun은 앱을 더 빠르게 만들기 위해 코드에 추가 복잡성을 추가할 필요 없이 설계되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Node.js의 대체물로 만들어졌기 때문에 Bun을 사용할 때는 node나 nodemon이 필요하지 않습니다. Bun은 내장된 감시 모드, dotenv, cross-env를 갖추고 있으며 .env 파일을 기본적으로 읽습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 Bun은 .js, .ts, .mjs, .jsx, .cjs, .tsx와 같은 다양한 파일을 실행할 수 있기 때문에 이제 프로젝트에 babel, tsc, ts-node 및 tsx를 설치할 필요가 없습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bun은 놀라운 성능을 자랑하는 JavaScript 번들러이며 esbuild 호환 플러그인 API를 제공하므로 esbuild, webpack 및 parcel도 필요하지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bun은 npm과 yarn보다 빠른 속도가 가장 큰 이점 중 하나입니다. Bun은 npm과 yarn에 있는 익숙한 모든 명령어를 사용할 수 있는 npm 호환 패키지 매니저입니다. 또한 package.json 파일을 읽고 node_modules에 쓰지만 30배 빠르기 때문에 게임 체인저입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본으로 Jest와 호환되는 테스트 러너를 내장하고 있어 추가 종속성을 설치하지 않고도 단위 테스트를 작성할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Node.js의 대체할 수 있는 디자인으로 개발되었기 때문에 path, fs, net과 같은 일반적인 Node.js 모듈과 __dirname, process와 같은 전역 변수를 내장 지원합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"성능 비교\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 말했듯이 Bun은 Node.js보다 4배 빠르기 때문에 코드가 가벼워지고 실행 시간이 짧아지는데, 사용하기도 간단해요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"$ bun install \\n\"\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테스트를 실행하는 차이는 더 미친 것 같아요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"$ bun test\\n\"\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_2.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용하기 쉽습니다. 다음은 Bun을 사용하여 HTTP 서버를 만드는 예제입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" server = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Bun\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"serve\"\n        }), \"({\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"port\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3000\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"request\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Response\"\n        }), \"(“\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Bun\"\n        }), \"에 오신 것을 환영합니다!\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\");\\n  },\\n});\\n\\nconsole.log(`localhost:${server.port}에서 서버를 대기 중입니다`);\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Bun이 Node.JS를 대체해야 할까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"요약하면, Bun은 자바스크립트 세계에서 새롭고 멋진 장난감 같은 존재입니다. 다음 프로젝트에 무엇을 사용할지 고민 중이라면 Bun을 한 번 시도해보는 것을 권해드립니다. 신뢰성이 있고, Node.js에 없는 멋진 기능들을 갖추고 있으며 빠르기도 합니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Bun 팀이 다음에 어떤 일을 할지 기대되네요. 그리고 더 자세히 알고 싶다면, \", _jsx(_components.a, {\n        href: \"%EB%A7%81%ED%81%AC\",\n        children: \"공식 안내서\"\n      }), \"를 확인해보세요. 필요한 모든 세부 정보가 담겨 있답니다!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bun에 대한 생각은 어떠신가요? Node.js를 대체할 것인가요? 아래 댓글에서 함께 토론해보세요!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"친근한 한국어 번역\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"작가에게 박수를 보내고 팔로우하세요! 👏\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"PlainEnglish.io에서 더 많은 콘텐츠를 찾을 수 있어요. 🚀\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"무료 주간 뉴스레터에 가입하세요. 🗞️\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"트위터(X), 링크드인, 유튜브, 디스코드에서 우리를 팔로우하세요.\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}