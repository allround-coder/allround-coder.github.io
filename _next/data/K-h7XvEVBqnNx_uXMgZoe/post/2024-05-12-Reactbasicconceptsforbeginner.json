{"pageProps":{"post":{"title":"React 초보자를 위한 기본 개념","description":"","date":"2024-05-12 23:15","slug":"2024-05-12-Reactbasicconceptsforbeginner","content":"\n\n글을 쓰는 것은 제가 배운 것을 다시 상기시키는 데 도움이 돼요. 그럼 시작해볼까요!\n\n리액트란? 웹페이지를 렌더링하는 데 도움이 되는 JavaScript 라이브러리\n\n라이브러리인가요, 프레임워크인가요? 라이브러리는 필요할 때마다 즉시 구축하는 데 도움이 되는 일반적인 도구를 제공하고, 프레임워크는 사용자 정의할 수 있는 기본 청사진을 제공합니다. 리액트는 청사진보다는 도구 상자와 같아서 라이브러리에 속합니다.\n\n왜 리액트를 사용해야 하나요? 간결한 코딩 스타일, 쉬운 코드 블록 재사용, 그리고 더 나은 로직 유닛 형성(업무 분리)이 가능합니다.\n\n\n\n```js\n// 단계 정의, 명령형, DOM 스타일\nlet btn = document.querySelector('button');\n\nif (user.isLoggedIn){\n  button.textContent = '계속하기'\n}\nelse {\n  button.textContent = '로그인'\n}\ndocument.body.append(btn);\n```\n\n```js\n// 목표 정의, 선언형, React-Dom 스타일\nlet content;\nif (user.isLoggedIn){\n  content = <button>계속하기</button>\n}\nelse {\n  content = <button>로그인</button>\n}\nreturn content;\n```\n\n리액트의 네 가지 개념: JSX, 컴포넌트, 프롭스, 상태. 이를 분해하여 이해해봅시다.\n\nJSX는 자바스크립트 문법 확장으로 HTML을 자바스크립트 코드에 포함할 수 있게 해줍니다.\n```\n\n\n\n```js\n// Header.jsx에 저장\nexport default function Header() {\n  return (\n    <header>\n      <h1> 이것은 헤더에 속해 있습니다. </h1>\n    </header>\n  )\n}\n```\n\n컴포넌트는 HTML 블록(React 레고)을 반환하는 함수입니다. 일반적으로 이러한 블록을 결합하여 웹페이지를 만듭니다.\n\n```js\nimport Header from './Header.jsx'\n\nexport default function App() {\n  return(\n    <div>\n      <Header />     // 컴포넌트\n    </div>\n  )    \n}\n```\n\nProps는 사용자 정의 컴포넌트에 설정할 수 있는 속성입니다. 데이터가 컴포넌트 간에 흐를 수 있도록 하는 것이 목적입니다.\n```\n\n\n\n```js\nfunction MyComponent(props){\n  console.log(props.name); // appName\n  console.log(props.age); // 777\n}\n\nfunction App(){\n  return (\n    <div>\n      <MyComponent\n        name=\"appName\"\n        age=777\n      />\n    </div>\n  )\n}\n```\n\n상태(State)는 두 가지 역할을 하는 React 후크입니다. 업데이트를 기다리고 웹페이지를 다시 렌더링합니다. 상태 후크가 필요한 이유는 React 컴포넌트가 내부적으로 시작할 때 한 번만 실행되고 나중에 업데이트되면 기본적으로 다시 렌더링되지 않기 때문입니다. 따라서 React에게 특정 정보나 상태가 변경되었음을 알리고 그것을 다시 렌더링하도록 전달할 방법이 필요합니다.\n\n```js\n// .jsx 형식으로 저장\nimport {useState} from \"react\"\n\nconst [getInfo, setInfo] = useState()\n\nfunction handleInfo(newInfo) {\n  setInfo(newInfo)\n}\n\nlet info = <p>기본 정보</p>\nif(getInfo) {\n  info = getInfo\n}\n\nreturn (\n  <CusButton onClick={() => handleInfo(\"CB가 클릭되었습니다\")}> CB </CusButton>\n  <div>\n    {info}\n  </div>\n)\n```\n\n간단히 말하면, React는 주로 웹페이지 렌더링에 초점을 맞춘 자바스크립트 라이브러리입니다. JSX, 컴포넌트, 프롭스(props) 및 상태(State)라는 네 가지 필수 개념이 있습니다. JavaScript 문법 확장을 통해 관련 HTML/CSS/JS를 컴포넌트로 그룹화할 수 있습니다. 컴포넌트는 서로 통신하기 위해 프롭스를 포함하고, 마지막으로 상태(State)는 업데이트 시 컴포넌트를 다시 렌더링할 수 있게 합니다.\n```","ogImage":{"url":"/assets/img/2024-05-12-Reactbasicconceptsforbeginner_0.png"},"coverImage":"/assets/img/2024-05-12-Reactbasicconceptsforbeginner_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"글을 쓰는 것은 제가 배운 것을 다시 상기시키는 데 도움이 돼요. 그럼 시작해볼까요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트란? 웹페이지를 렌더링하는 데 도움이 되는 JavaScript 라이브러리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라이브러리인가요, 프레임워크인가요? 라이브러리는 필요할 때마다 즉시 구축하는 데 도움이 되는 일반적인 도구를 제공하고, 프레임워크는 사용자 정의할 수 있는 기본 청사진을 제공합니다. 리액트는 청사진보다는 도구 상자와 같아서 라이브러리에 속합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"왜 리액트를 사용해야 하나요? 간결한 코딩 스타일, 쉬운 코드 블록 재사용, 그리고 더 나은 로직 유닛 형성(업무 분리)이 가능합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 단계 정의, 명령형, DOM 스타일\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" btn = \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"document\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"querySelector\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'button'\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (user.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"isLoggedIn\"\n        }), \"){\\n  button.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"textContent\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'계속하기'\"\n        }), \"\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n  button.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"textContent\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'로그인'\"\n        }), \"\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"document\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"body\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(btn);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 목표 정의, 선언형, React-Dom 스타일\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" content;\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (user.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"isLoggedIn\"\n        }), \"){\\n  content = \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \">\"]\n          }), \"계속하기\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \">\"]\n          })]\n        }), \"\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n  content = \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \">\"]\n          }), \"로그인\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \">\"]\n          })]\n        }), \"\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" content;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트의 네 가지 개념: JSX, 컴포넌트, 프롭스, 상태. 이를 분해하여 이해해봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"JSX는 자바스크립트 문법 확장으로 HTML을 자바스크립트 코드에 포함할 수 있게 해줍니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\n\\n\\n```js\\n// Header.jsx에 저장\\nexport default function Header() {\\n  return (\\n    <header>\\n      <h1> 이것은 헤더에 속해 있습니다. </h1>\\n    </header>\\n  )\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컴포넌트는 HTML 블록(React 레고)을 반환하는 함수입니다. 일반적으로 이러한 블록을 결합하여 웹페이지를 만듭니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Header\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./Header.jsx'\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"App\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \"(\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Header\"\n            }), \" />\"]\n          }), \"     // 컴포넌트\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          })]\n        }), \"\\n  )    \\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Props는 사용자 정의 컴포넌트에 설정할 수 있는 속성입니다. 데이터가 컴포넌트 간에 흐를 수 있도록 하는 것이 목적입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\n\\n\\n```js\\nfunction MyComponent(props){\\n  console.log(props.name); // appName\\n  console.log(props.age); // 777\\n}\\n\\nfunction App(){\\n  return (\\n    <div>\\n      <MyComponent\\n        name=\\\"appName\\\"\\n        age=777\\n      />\\n    </div>\\n  )\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상태(State)는 두 가지 역할을 하는 React 후크입니다. 업데이트를 기다리고 웹페이지를 다시 렌더링합니다. 상태 후크가 필요한 이유는 React 컴포넌트가 내부적으로 시작할 때 한 번만 실행되고 나중에 업데이트되면 기본적으로 다시 렌더링되지 않기 때문입니다. 따라서 React에게 특정 정보나 상태가 변경되었음을 알리고 그것을 다시 렌더링하도록 전달할 방법이 필요합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// .jsx 형식으로 저장\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {useState} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"react\\\"\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [getInfo, setInfo] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handleInfo\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"newInfo\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setInfo\"\n        }), \"(newInfo)\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" info = \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          }), \"기본 정보\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \">\"]\n          })]\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \"(getInfo) {\\n  info = getInfo\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n  \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"CusButton\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{()\"\n            }), \" =>\"]\n          }), \" handleInfo(\\\"CB가 클릭되었습니다\\\")}> CB \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"CusButton\"\n            }), \">\"]\n          })]\n        }), \"\\n  \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          }), \"\\n    {info}\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"</\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \">\"]\n          })]\n        }), \"\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단히 말하면, React는 주로 웹페이지 렌더링에 초점을 맞춘 자바스크립트 라이브러리입니다. JSX, 컴포넌트, 프롭스(props) 및 상태(State)라는 네 가지 필수 개념이 있습니다. JavaScript 문법 확장을 통해 관련 HTML/CSS/JS를 컴포넌트로 그룹화할 수 있습니다. 컴포넌트는 서로 통신하기 위해 프롭스를 포함하고, 마지막으로 상태(State)는 업데이트 시 컴포넌트를 다시 렌더링할 수 있게 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {})\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}