{"pageProps":{"post":{"title":"리액트, 리액트 네이티브 및 노드js에서의 암호화","description":"","date":"2024-05-12 21:56","slug":"2024-05-12-EncryptioninReactReactNativeandNodejs","content":"\n\n암호화에 대한 올바른 모듈을 선택해주세요\n\n# 소개\n\n최근 프로젝트에서 만났던 암호화 관련 문제를 공유하고자 합니다. 먼저 사용된 암호화 방법론을 설명하고 어려움에 대해 깊이 있는 이야기로 파헤쳐보겠습니다. 웹 및 모바일 애플리케이션을 개발할 때 고려해야할 중요한 점은 호환성입니다. 기능을 설계하거나 모듈을 선택하거나 솔루션을 고려할 때 전체적인 접근 방식이 있어야 합니다. 모든 플랫폼에서 작동해야 합니다.\n\n# 암호화 아키텍처\n\n\n\n- 프론트엔드(React, React Native)에서 AES 암호화 키 생성하기\n- 백엔드(Node.js)에서 RSA 공개 및 개인 키 생성하기\n- RSA 공개 키를 프론트엔드와 공유하기\n- AES 키를 RSA 공개 키로 암호화하기\n- 보낼 데이터를 AES 키로 암호화하기\n- 암호화된 데이터와 암호화된 AES 키를 백엔드로 보내기\n- 백엔드에서 RSA 개인 키를 사용하여 암호화된 AES 키를 해독하여 AES 키를 검색하기\n- 검색된 AES 키를 사용하여 암호화된 요청 데이터를 해독하기.\n\n백엔드는 비슷한 프로세스를 따라 프론트엔드로 응답을 돌려보낼 것입니다. 키를 생성하고 암호화하는데 사용된 암호화 기술 전체 과정에 대해 설명하지는 않겠습니다. 다른 글에서 다룰 수도 있겠지만, 이제는 문제에 집중해보겠습니다.\n\n![Encryption in React, React Native, and Node.js](/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png)\n\n# 문제\n\n\n\nAES 키를 생성하고 RSA 키를 생성하며 RSA 키를 사용하여 AES 키를 암호화하는 경우, 코어 노드 js 모듈의 일부인 기본 암호화 모듈을 사용할 수 있습니다. React는 내부적으로 노드에 의존성이 있기 때문에 키를 생성하고 암호화하는 데 큰 문제가 없으며 추가 패키지도 필요하지 않습니다. 그러나 React Native의 경우 노드 코어 모듈을 지원하지 않습니다. 따라서 다양한 탐구 끝에 혼자 사용하면 좋지만 암호화를 만들기위해 패키지를 대체하는 것과 관련된 문제가 있는 react-native-rsa-native, crypto-browserify, react-native-fast-crypto, react-native-quick-crypto와 같은 패키지들은 작동하지 않는 것 같습니다.\n\n# 해결책\n\n모든 플랫폼(웹, 모바일 및 백엔드)을 위한 동일한 암호화 기능과 기술을 제공할 수 있는 일반적인 패키지를 검색하는 도중 더욱 신뢰할 수 있고 호환성이 뛰어나며 크기가 작고 인기가 많은 node-forge 패키지를 발견했습니다. 다른 패키지들과 비교했을 때 이 패키지는 모든 암호화 기능, 암호 및 암호화 기술을 갖추고 있어 솔루션을 구현하기 쉽게 만들어 주었습니다.\n\n```js\n// AES 키 생성\n// 클라이언트 측 React 및 React Native\n\nimport forge from 'node-forge';\nexport const generateAesKey = () => {\n  const aesSalt = forge.random.getBytesSync(16);\n  const keyPassPhrase = forge.random.getBytesSync(16);\n  const aesKey = forge.pkcs5.pbkdf2(\n    keyPassPhrase,\n    aesSalt,\n    ENCRYPTION_AES_ENC_KEY_OPTIONS.iterations, // 필요에 따라 사용\n    ENCRYPTION_AES_ENC_KEY_OPTIONS.keySize, // 필요에 따라 사용\n  );\n  return aesKey;\n};\n```\n\n\n\n```js\n// RSA 공개 및 개인 키 생성\n// 서버 측 Node.js\nconst forge = require('node-forge');\nconst rsaKeyPair = forge.pki.rsa.generateKeyPair({ bits: BITS }); // 필요에 따라 사용\nconst publicKeyPem = forge.pki.publicKeyToPem(rsaKeyPair.publicKey);\nconst privateKeyPem = forge.pki.privateKeyToPem(rsaKeyPair.privateKey);\n```\n\n```js\n// RSA 공개 키를 사용하여 AES 키 암호화\n// React 및 React Native\n\nimport forge from 'node-forge';\nexport const encryptAesKey = (receivedpublicKeyPem: string, aesKey: string) => {\n  try {\n    const publicKey = forge.pki.publicKeyFromPem(receivedpublicKeyPem);\n    const encryptedAesKey = publicKey.encrypt(aesKey, 'RSA-OAEP');\n    return forge.util.encode64(encryptedAesKey);\n  } catch (error) {\n    console.error('암호화 오류:', error);\n    throw error;\n  }\n};\n```\n\n```js\n// RSA 개인 키를 사용하여 암호화된 AES 키 복호화\nconst decryptedAesKey = rsaKeyPair.privateKey.decrypt(forge.util.decode64(encryptedAesKey), 'RSA-OAEP');\n```\n\n요청 데이터를 AES 키를 사용하여 암호화하고 백엔드에서 데이터를 복호화하기 위해 제 요구에 따라 다른 모듈을 사용했습니다 (React에는 crypto-js, React Native에는 react-native-crypto-js). 여전히 이 프로세스에 node-forge를 사용할 수 있습니다.\n```\n\n\n\n읽어 주셔서 감사합니다! 👋","ogImage":{"url":"/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png"},"coverImage":"/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"암호화에 대한 올바른 모듈을 선택해주세요\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최근 프로젝트에서 만났던 암호화 관련 문제를 공유하고자 합니다. 먼저 사용된 암호화 방법론을 설명하고 어려움에 대해 깊이 있는 이야기로 파헤쳐보겠습니다. 웹 및 모바일 애플리케이션을 개발할 때 고려해야할 중요한 점은 호환성입니다. 기능을 설계하거나 모듈을 선택하거나 솔루션을 고려할 때 전체적인 접근 방식이 있어야 합니다. 모든 플랫폼에서 작동해야 합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"암호화 아키텍처\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"프론트엔드(React, React Native)에서 AES 암호화 키 생성하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"백엔드(Node.js)에서 RSA 공개 및 개인 키 생성하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"RSA 공개 키를 프론트엔드와 공유하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"AES 키를 RSA 공개 키로 암호화하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"보낼 데이터를 AES 키로 암호화하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"암호화된 데이터와 암호화된 AES 키를 백엔드로 보내기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"백엔드에서 RSA 개인 키를 사용하여 암호화된 AES 키를 해독하여 AES 키를 검색하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"검색된 AES 키를 사용하여 암호화된 요청 데이터를 해독하기.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"백엔드는 비슷한 프로세스를 따라 프론트엔드로 응답을 돌려보낼 것입니다. 키를 생성하고 암호화하는데 사용된 암호화 기술 전체 과정에 대해 설명하지는 않겠습니다. 다른 글에서 다룰 수도 있겠지만, 이제는 문제에 집중해보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png\",\n        alt: \"Encryption in React, React Native, and Node.js\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"문제\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"AES 키를 생성하고 RSA 키를 생성하며 RSA 키를 사용하여 AES 키를 암호화하는 경우, 코어 노드 js 모듈의 일부인 기본 암호화 모듈을 사용할 수 있습니다. React는 내부적으로 노드에 의존성이 있기 때문에 키를 생성하고 암호화하는 데 큰 문제가 없으며 추가 패키지도 필요하지 않습니다. 그러나 React Native의 경우 노드 코어 모듈을 지원하지 않습니다. 따라서 다양한 탐구 끝에 혼자 사용하면 좋지만 암호화를 만들기위해 패키지를 대체하는 것과 관련된 문제가 있는 react-native-rsa-native, crypto-browserify, react-native-fast-crypto, react-native-quick-crypto와 같은 패키지들은 작동하지 않는 것 같습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"해결책\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 플랫폼(웹, 모바일 및 백엔드)을 위한 동일한 암호화 기능과 기술을 제공할 수 있는 일반적인 패키지를 검색하는 도중 더욱 신뢰할 수 있고 호환성이 뛰어나며 크기가 작고 인기가 많은 node-forge 패키지를 발견했습니다. 다른 패키지들과 비교했을 때 이 패키지는 모든 암호화 기능, 암호 및 암호화 기술을 갖추고 있어 솔루션을 구현하기 쉽게 만들어 주었습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// AES 키 생성\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 클라이언트 측 React 및 React Native\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" forge \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'node-forge'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"generateAesKey\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") => {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" aesSalt = forge.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"random\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getBytesSync\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" keyPassPhrase = forge.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"random\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getBytesSync\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" aesKey = forge.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"pkcs5\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"pbkdf2\"\n        }), \"(\\n    keyPassPhrase,\\n    aesSalt,\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ENCRYPTION_AES_ENC_KEY_OPTIONS\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"iterations\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 필요에 따라 사용\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ENCRYPTION_AES_ENC_KEY_OPTIONS\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"keySize\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 필요에 따라 사용\"\n        }), \"\\n  );\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" aesKey;\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// RSA 공개 및 개인 키 생성\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 서버 측 Node.js\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" forge = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"require\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'node-forge'\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" rsaKeyPair = forge.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"pki\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"rsa\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"generateKeyPair\"\n        }), \"({ \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"bits\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BITS\"\n        }), \" }); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 필요에 따라 사용\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" publicKeyPem = forge.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"pki\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"publicKeyToPem\"\n        }), \"(rsaKeyPair.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"publicKey\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" privateKeyPem = forge.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"pki\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"privateKeyToPem\"\n        }), \"(rsaKeyPair.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"privateKey\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// RSA 공개 키를 사용하여 AES 키 암호화\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// React 및 React Native\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" forge \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'node-forge'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"encryptAesKey\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"receivedpublicKeyPem: string, aesKey: string\"\n        }), \") => {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" publicKey = forge.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"pki\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"publicKeyFromPem\"\n        }), \"(receivedpublicKeyPem);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" encryptedAesKey = publicKey.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"encrypt\"\n        }), \"(aesKey, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'RSA-OAEP'\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" forge.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"util\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"encode64\"\n        }), \"(encryptedAesKey);\\n  } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" (error) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'암호화 오류:'\"\n        }), \", error);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \" error;\\n  }\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// RSA 개인 키를 사용하여 암호화된 AES 키 복호화\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" decryptedAesKey = rsaKeyPair.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"privateKey\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"decrypt\"\n        }), \"(forge.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"util\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"decode64\"\n        }), \"(encryptedAesKey), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'RSA-OAEP'\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"요청 데이터를 AES 키를 사용하여 암호화하고 백엔드에서 데이터를 복호화하기 위해 제 요구에 따라 다른 모듈을 사용했습니다 (React에는 crypto-js, React Native에는 react-native-crypto-js). 여전히 이 프로세스에 node-forge를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\n\\n\\n읽어 주셔서 감사합니다! 👋\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}