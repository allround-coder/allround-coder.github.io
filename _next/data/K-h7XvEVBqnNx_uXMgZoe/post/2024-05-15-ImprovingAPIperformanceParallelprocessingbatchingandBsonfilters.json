{"pageProps":{"post":{"title":"API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터","description":"","date":"2024-05-15 02:43","slug":"2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters","content":"\n\n이 글에서는 개발자가 API의 성능을 향상시키기 위해 사용할 수 있는 최적화 시리즈를 탐색해 보겠습니다. API를 디자인할 때 최적의 성능을 확보하는 것이 중요합니다. 그러나 때로는 사용 가능한 도구를 효과적으로 활용하지 못하거나, 충분한 정보가 없어 판단을 내리기 어려울 수 있습니다.\n\n일반적인 시나리오를 살펴보겠습니다: 데이터베이스에서 카테고리 및 해당 카테고리에 속한 제품을 가져오는 과정입니다. 우리는 구현할 수 있는 다양한 최적화 또는 수정 단계를 따라갈 것입니다.\n\n```js\nList<Category> categories = getAllCategory();\n        \ncategories.forEach(category -> {\n    Product product = getProductByCategory(category.getId());\n    productList.add(product);\n});\n```\n\n이 코드 조각은 잘 작동하며 우리가 하려고 하는 작업을 수행합니다. 그런데 더 나은 방법이 있을까요?\n\n\n\n병렬 스트림이 도와드릴게요!!!\n\nJava는 API 성능을 향상시키기 위해 병렬 스트림을 제공하지만 효율적으로 사용하지 않으면 시스템 가속화에 도움이 되지 않을 수 있습니다. 병렬 스트림은 백그라운드 OS 스레드를 활용하여 실행하므로 스레드 컨텍스트 전환의 오버헤드를 고려하면서 효과적으로 사용하는 방법을 이해하는 것이 중요합니다.\n\n배치 처리 소개\n\n한 걸음 더 나아가서 일부 배치 처리를 사용하고 병렬 스트림을 활용하여 더욱 최적화할 수 있습니다.\n\n\n\n```java\nList<Category> categories = getAllCategory();\nList<List<Category>> partitionedCategories = Lists.partition(categories, 50);\n\npartitionedCategories.parallelStream().forEach(categoryBatch -> {\n    categoryBatch.parallelStream().forEach(category -> {\n        Product product = getProductByCategory(category.getId());\n        productList.add(product);\n    });\n});\n```\n\n파티션 함수는 원본 목록을 지정된 배치 크기를 기준으로 일괄로 나눕니다. 예를 들어, 원본 목록에 220개의 요소가 있다면 결과 목록은 크기가 `50, 50, 50, 50, 20`인 5개의 요소로 나눠질 것입니다.\n\n그리고 이제 중첩된 병렬 스트림을 사용하여 요소를 반복할 수 있습니다.\n\n다중 처리를 잘 활용한 것 같은데, 더 개선할 부분이 있을까요?\n\n\n\n데이터베이스 최적화\n\n이제 최적화된 접근법처럼 보이지만, 여전히 DB(데이터베이스)에 N번 접근하고 있습니다. 다만, 여러 스레드를 사용하여 동일한 작업을 수행하고 있을 뿐입니다.\n\n더 좋은 접근 방식은 분할된 목록을 사용하여 WHERE 절을 구성하고 여러 카테고리 ID를 전달하여 단일 데이터베이스 호출을 실행하는 것입니다.\n\n```js\ndb.getCollection('Product').find({'category_id':{$in:['categoryId1','categoryId2']}\n```\n\n\n\n```js\nBson filter = Filters.in(\"categoryId\", \"categoryId1\", \"categoryId2\");\n// 마찬가지로 필터를 사용하여 카테고리 ID를 전달할 수 있습니다.\nList<Category> categories = getAllCategory();\nList<List<Category>> partitionedCategories = Lists.partition(categories, 50);\n\npartitionedCategories.parallelStream().forEach(categoryBatch->{\n    Bson filter = Filters.in(\"categoryId\", categoryBatch);\n    List<Product> productsBatch = getProducts(filter);\n    productList.addAll(productsBatch);\n});\n```\n\nBson 필터를 사용하여 데이터 검색을 구현하면 API에 유연성을 추가할 수 있어서 클라이언트가 쿼리를 자신의 요구에 맞게 조정할 수 있습니다. 이 방식은 API의 사용성을 향상시키고 다양한 시나리오에서 유용하게 사용할 수 있도록 합니다.\n\n지금까지 한 작업을 요약해볼까요!\n\n정말 멋진 개선이군요. 일괄 검색 및 여러 스레드를 활용하면 데이터베이스 호출 수를 줄이고 병렬 처리를 효율적으로 활용하여 성능을 크게 향상시킬 수 있습니다. API의 성능에 상당한 최적화가 되었으므로 성능 상에서 뚜렷한 차이를 느낄 수 있을 겁니다.\n\n\n\n\n이 풀 리퀘스트는 정말 리뷰할 준비가 되어 있어요! 😄🚀","ogImage":{"url":"/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png"},"coverImage":"/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"이 글에서는 개발자가 API의 성능을 향상시키기 위해 사용할 수 있는 최적화 시리즈를 탐색해 보겠습니다. API를 디자인할 때 최적의 성능을 확보하는 것이 중요합니다. 그러나 때로는 사용 가능한 도구를 효과적으로 활용하지 못하거나, 충분한 정보가 없어 판단을 내리기 어려울 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일반적인 시나리오를 살펴보겠습니다: 데이터베이스에서 카테고리 및 해당 카테고리에 속한 제품을 가져오는 과정입니다. 우리는 구현할 수 있는 다양한 최적화 또는 수정 단계를 따라갈 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"List\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Category\"\n        }), \"> categories = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getAllCategory\"\n        }), \"();\\n        \\ncategories.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"forEach\"\n        }), \"(category -> {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \" product = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProductByCategory\"\n        }), \"(category.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getId\"\n        }), \"());\\n    productList.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(product);\\n});\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드 조각은 잘 작동하며 우리가 하려고 하는 작업을 수행합니다. 그런데 더 나은 방법이 있을까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"병렬 스트림이 도와드릴게요!!!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Java는 API 성능을 향상시키기 위해 병렬 스트림을 제공하지만 효율적으로 사용하지 않으면 시스템 가속화에 도움이 되지 않을 수 있습니다. 병렬 스트림은 백그라운드 OS 스레드를 활용하여 실행하므로 스레드 컨텍스트 전환의 오버헤드를 고려하면서 효과적으로 사용하는 방법을 이해하는 것이 중요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"배치 처리 소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한 걸음 더 나아가서 일부 배치 처리를 사용하고 병렬 스트림을 활용하여 더욱 최적화할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [\"List<Category> categories = getAllCategory();\\nList<List<Category>> partitionedCategories = Lists.partition(categories, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50\"\n        }), \");\\n\\npartitionedCategories.parallelStream().forEach(categoryBatch -> {\\n    categoryBatch.parallelStream().forEach(category -> {\\n        \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Product\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"product\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" getProductByCategory(category.getId());\\n        productList.add(product);\\n    });\\n});\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"파티션 함수는 원본 목록을 지정된 배치 크기를 기준으로 일괄로 나눕니다. 예를 들어, 원본 목록에 220개의 요소가 있다면 결과 목록은 크기가 \", _jsx(_components.code, {\n        children: \"50, 50, 50, 50, 20\"\n      }), \"인 5개의 요소로 나눠질 것입니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 이제 중첩된 병렬 스트림을 사용하여 요소를 반복할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다중 처리를 잘 활용한 것 같은데, 더 개선할 부분이 있을까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터베이스 최적화\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 최적화된 접근법처럼 보이지만, 여전히 DB(데이터베이스)에 N번 접근하고 있습니다. 다만, 여러 스레드를 사용하여 동일한 작업을 수행하고 있을 뿐입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더 좋은 접근 방식은 분할된 목록을 사용하여 WHERE 절을 구성하고 여러 카테고리 ID를 전달하여 단일 데이터베이스 호출을 실행하는 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"db.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getCollection\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Product'\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"find\"\n        }), \"({\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'category_id'\"\n        }), \":{\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"$in\"\n        }), \":[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'categoryId1'\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'categoryId2'\"\n        }), \"]}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Bson\"\n        }), \" filter = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Filters\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"in\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"categoryId\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"categoryId1\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"categoryId2\\\"\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 마찬가지로 필터를 사용하여 카테고리 ID를 전달할 수 있습니다.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"List\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Category\"\n        }), \"> categories = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getAllCategory\"\n        }), \"();\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"List\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"List\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Category\"\n        }), \">> partitionedCategories = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Lists\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"partition\"\n        }), \"(categories, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50\"\n        }), \");\\n\\npartitionedCategories.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"parallelStream\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"forEach\"\n        }), \"(categoryBatch->{\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Bson\"\n        }), \" filter = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Filters\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"in\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"categoryId\\\"\"\n        }), \", categoryBatch);\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"List\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \"> productsBatch = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProducts\"\n        }), \"(filter);\\n    productList.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"addAll\"\n        }), \"(productsBatch);\\n});\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bson 필터를 사용하여 데이터 검색을 구현하면 API에 유연성을 추가할 수 있어서 클라이언트가 쿼리를 자신의 요구에 맞게 조정할 수 있습니다. 이 방식은 API의 사용성을 향상시키고 다양한 시나리오에서 유용하게 사용할 수 있도록 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지 한 작업을 요약해볼까요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정말 멋진 개선이군요. 일괄 검색 및 여러 스레드를 활용하면 데이터베이스 호출 수를 줄이고 병렬 처리를 효율적으로 활용하여 성능을 크게 향상시킬 수 있습니다. API의 성능에 상당한 최적화가 되었으므로 성능 상에서 뚜렷한 차이를 느낄 수 있을 겁니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 풀 리퀘스트는 정말 리뷰할 준비가 되어 있어요! 😄🚀\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}