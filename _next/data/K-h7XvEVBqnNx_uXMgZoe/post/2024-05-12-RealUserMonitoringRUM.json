{"pageProps":{"post":{"title":"실제 사용자 모니터링RUM","description":"","date":"2024-05-12 19:00","slug":"2024-05-12-RealUserMonitoringRUM","content":"\n\n애플리케이션의 최종 사용자 경험을 추적하고 측정합니다. 앱 성능 및 API 호출에 소요된 시간을 파악합니다. 웹사이트의 최종 사용자 경험을 향상시키는 데 도움이 되는 실행 가능한 데이터 중심 세부 정보를 제공합니다.\n\n![이미지](/assets/img/2024-05-12-RealUserMonitoringRUM_0.png)\n\n![이미지](/assets/img/2024-05-12-RealUserMonitoringRUM_1.png)\n\n## APM (Application Performance Monitoring/ Real user monitoring tool)—\n\n\n\n웹 애플리케이션 성능에 대한 통찰력을 얻는 데 도움이 되며 다양한 모니터링 기능을 활용합니다.\n\n- 실시간 가시성 - 응답 시간, 페이지 로드 시간, 페이지 조회수, 처리량 등 주요 지표를 추적하여 웹 사이트의 실시간 성능을 간단히 확인할 수 있습니다.\n- 지리별 사용자 경험 - 세계지도상에서 각 나라별로 웹 사이트의 성능을 시각화하여 웹 사이트 성능에 영향을 받고 있는 위치를 빠르게 파악할 수 있습니다. 응답 시간, 오류 횟수, 처리량을 분석하여 사용자가 영향을 받고 있는 지역 확인 가능합니다.\n\n![웹사이트 성능 모니터링](/assets/img/2024-05-12-RealUserMonitoringRUM_2.png)\n\n- 지연 거래 감지 - 웹 사이트의 페이지 조회수와 개별 거래에 대한 오류를 주의 깊게 살펴 잠재적인 문제를 식별할 수 있습니다.\n- 사용자 세션 추적 - 웹 사이트에 연결된 사용자 세션 수를 파악할 수 있습니다. 또한 각 세션의 상태를 파악하여 사용자 세션의 기간과 품질을 결정할 수 있습니다.\n- 스크립트 오류 감지 - 실시간으로 웹 사이트의 성능에 영향을 주는 JS 오류를 식별할 수 있습니다.\n\n\n\n\n![Monitoring solutions such as New Relic come with built-in dashboards. We can also build our own custom dashboards based on the metrics that matters most to us.\nother tools — AppDynamics Browser RUM, Retrace, Datadog](/assets/img/2024-05-12-RealUserMonitoringRUM_3.png)\n\n## How real user monitoring works\n\nReal user monitoring works by injecting code into an application to capture metrics while the application is in use. Client side applications are monitored by injecting Javascript code.\n\n\n\n네이티브 모바일 애플리케이션은 모니터링 라이브러리를 모바일 애플리케이션 패키지에 직접 추가하여 모니터링됩니다.","ogImage":{"url":"/assets/img/2024-05-12-RealUserMonitoringRUM_0.png"},"coverImage":"/assets/img/2024-05-12-RealUserMonitoringRUM_0.png","tag":["Tech"],"readingTime":2},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"애플리케이션의 최종 사용자 경험을 추적하고 측정합니다. 앱 성능 및 API 호출에 소요된 시간을 파악합니다. 웹사이트의 최종 사용자 경험을 향상시키는 데 도움이 되는 실행 가능한 데이터 중심 세부 정보를 제공합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-RealUserMonitoringRUM_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-RealUserMonitoringRUM_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"APM (Application Performance Monitoring/ Real user monitoring tool)—\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"웹 애플리케이션 성능에 대한 통찰력을 얻는 데 도움이 되며 다양한 모니터링 기능을 활용합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"실시간 가시성 - 응답 시간, 페이지 로드 시간, 페이지 조회수, 처리량 등 주요 지표를 추적하여 웹 사이트의 실시간 성능을 간단히 확인할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"지리별 사용자 경험 - 세계지도상에서 각 나라별로 웹 사이트의 성능을 시각화하여 웹 사이트 성능에 영향을 받고 있는 위치를 빠르게 파악할 수 있습니다. 응답 시간, 오류 횟수, 처리량을 분석하여 사용자가 영향을 받고 있는 지역 확인 가능합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-RealUserMonitoringRUM_2.png\",\n        alt: \"웹사이트 성능 모니터링\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"지연 거래 감지 - 웹 사이트의 페이지 조회수와 개별 거래에 대한 오류를 주의 깊게 살펴 잠재적인 문제를 식별할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사용자 세션 추적 - 웹 사이트에 연결된 사용자 세션 수를 파악할 수 있습니다. 또한 각 세션의 상태를 파악하여 사용자 세션의 기간과 품질을 결정할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"스크립트 오류 감지 - 실시간으로 웹 사이트의 성능에 영향을 주는 JS 오류를 식별할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-RealUserMonitoringRUM_3.png\",\n        alt: \"Monitoring solutions such as New Relic come with built-in dashboards. We can also build our own custom dashboards based on the metrics that matters most to us.\\nother tools — AppDynamics Browser RUM, Retrace, Datadog\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"How real user monitoring works\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Real user monitoring works by injecting code into an application to capture metrics while the application is in use. Client side applications are monitored by injecting Javascript code.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"네이티브 모바일 애플리케이션은 모니터링 라이브러리를 모바일 애플리케이션 패키지에 직접 추가하여 모니터링됩니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}