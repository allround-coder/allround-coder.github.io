{"pageProps":{"post":{"title":"피해야 할 5가지 실수 웹 개발자로서","description":"","date":"2024-05-14 12:46","slug":"2024-05-14-AvoidThese5MistakesasaWebDeveloper","content":"\n\n```\n![Avoid These 5 Mistakes as a Web Developer](/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png)\n\n우리는 모두 실수를 합니다. 배우고成長하며、경험을 쌓는 가장 효율적인 방법입니다. 실수를 돌아보고 그로부터 배우면 스스로를 향상시킬 수 있습니다.\n\n대부분의 사람들은 자신의 실수를 돌아보지 않습니다. 그들은 그 실수를 저지르지 않았어야 한다고 자책합니다. 다른 사람이 그들을 비난할 필요는 없습니다; 그들 스스로 힘을 줍니다.\n\n웹 개발자 경력 중에 백엔드 엔지니어가 범하는 십 가지 오류를 나열하겠습니다. 실수를 범하는 데는 현재 위치가 중요하지 않습니다. 우리는 경력 어디서든지 언제든지 실수를 합니다.\n```\n\n\n\n# 실수 #1\n\n기술 부채. 지나친 공학. 종소리가 울리나요? 종종, 개발자들은 사용자가 응용 프로그램을 활용하는 방식을 이해하는 대신 기술적인 측면에 초점을 맞춥니다. 해당 요구 사항에 따라 코드를 작성하지 않습니다. 백엔드 엔지니어가 요구 사항을 기반으로 기술을 사용하면 필요한 노력과 비용을 크게 줄일 수 있습니다.\n\n대부분의 경우, 초보자들이 이 실수에 빠집니다. 분야에 새로 온 사람들은 사용자에게 효율적으로 제공되는 기술을 알지 못하기 때문에 기술적 부담을 줄이는 기술을 사용하지 않는 것입니다. 더 많은 기술과 처리가 필요할 때 응용 프로그램은 최종 사용자에게 느리게 나타납니다.\n\n어떤 분야, 취미 또는 습관에 새로 온 사람들은 프로세스를 지나치게 복잡하게 만들기 쉽습니다. 그러나 경력자들은 더 적은 기술을 사용하여 개발 및 사용자 시간을 절약하면서 노력과 비용을 줄입니다.\n\n\n\n더불어, 기술 부채는 읽기 어려운 코드를 나타냅니다. 다른 엔지니어들이 이해할 수 있는 로직을 작성하는 것이 개발의 첫 번째 규칙입니다. 이는 이러한 산업 표준 기술과 코딩 표준을 사용하거나 변수를 CamalCase 규칙으로 작성하는 것을 의미합니다.\n\n초보자들은 가능한 모든 것을 사용할 때 자부심을 느낍니다. 나중에는 동일한 선택이 응용 프로그램을 느리게 만들 때 머리가 아플 수 있습니다. 이로 인해 시니어들이 코드를 리팩토링해야 하며, 이는 시간 낭비입니다. 코드가 많아질수록 테스트 요구 사항과 버그 발생 확률이 증가합니다. 코드를 적게 작성하세요.\n\n자존심을 한쪽에 두고 필요한 기술만 선택하고 최고의 산업 표준을 준수함으로써 이러한 실수를 피할 수 있습니다. 프론트엔드 프레임워크와 라이브러리를 배울 때 이 실수를 저질렀습니다. 이에 따라 더 많은 코드, 더 많은 버그 및 대규모 리팩토링 비용이 발생했습니다. DRY, KISS 또는 YAGNI 표준을 따르세요.\n\n# 실수 #2\n\n\n\n내가 Udemy에서 React를 배우는 데 돈을 썼어. 그 스킬을 활용해서 모든 애플리케이션을 React로 만들어야겠지? 아니야. 모든 작업에 같은 기술, 라이브러리 또는 프레임워크를 사용하지 말아야 해. 이 프레임워크의 선택은 해결해야 하는 문제에 따라 다르니까.\n\nReact + Vite는 중급 웹 애플리케이션에 적합할 수도 있어. 그러나 성능 중심의 애플리케이션에는 적합하지 않아. 그럴 때는 성능을 향상시키기 위해 SolidJS, NextJS 또는 다른 프레임워크를 선택해야 해.\n\n주어진 작업에 따라 사용하는 기술을 바꿔. 선택한 언어인 JavaScript 같은 기본기는 튼튼히 갖추고 있고, 기술을 바꿔가며 학습해.\n\n하나의 기술에만 고수하지 마. 그것은 학습 능력을 제한하고 애플리케이션이 문제를 겪게 만들어. 나중에 그 기술을 바꿔야 하게 될 텐데, 처음부터 그렇게 할 수 있었을 텐데.\n\n\n\n# 실수 #3\n\n나쁜 의도를 가진 사람들은 데이터베이스를 공격하고 자격 증명을 도용하기 위한 엄청난 기술을 가지고 있습니다. SQL 인젝션은 흔한 기술 중 하나입니다. 그것이 빈번하다면, 사람들은 그럼에도 불구하고 여전히 그에 빠질까요? 네, 그렇습니다!\n\n이것은 시니어들이 데이터베이스를 수정하는 쿼리를 주입하는 것을 방지하는 코드를 작성할 수 있지만, 주니어들은 이 분야의 복잡함을 알지 못할 수 있기 때문입니다.\n\n![이미지](/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_1.png)\n\n\n\n2022년을 기준으로 웹 응용프로그램에서 발생한 전체 취약점 중 33%가 SQL Injection 공격으로 인한 것입니다. 원치 않는 문자열을 표준 쿼리와 연결함으로써 개인들이 DB에 액세스하고 일반적으로 DML 명령을 실행합니다.\n\n이러한 실수를 피하기 위해 일반화된 쿼리를 사용하는 대신 쿼리 내에 구체적으로 필요한 매개변수를 전달하세요. 모든 작업에 대해 표준 쿼리를 만들지 마세요. 그렇게 하면 새벽 2시 30분에 전화를 받을 수도 있습니다. 여러 개의 데이터베이스를 사용하고 모든 과일을 한 바구니에 넣지 마세요.\n\n다양성이 중요합니다. 코드 리뷰를 수행하세요. 특히 실행 중인 쿼리에 대해 연결된 문자열을 검증하세요. 제품 DB를 백업하면서 유지하세요.\n\n# 실수 #4\n\n\n\n미적인 면에 초점을 맞추는 사람이신가요? 사용성보다는 미학에 더 집중하는 것은 일반적인 초보 실수입니다. 초보 개발자는 사용자가 응용 프로그램을 어떻게 활용하는지에 대해 덜 주의를 기울이고 디자인을 지나치게 복잡하게 만들곤 합니다. UI/UX는 테스트 단계까지 아름답게 보일 수 있어요.\n\n사용자들이 귀하는 응용 프로그램을 이용하게 될 때 비즈니스 매출이 감소합니다. 왜냐하면 그 중 95%는 사용하지 못하기 때문이죠. 복잡성 때문이라고 해야겠어요. 사용자들은 간단한 디자인을 선호합니다. 이미 본 적 있는 인터페이스가 원하는 것이죠. 사람들은 습관에 집중합니다. 어떤 작업에도 덜 노력을 기울이고 싶어해요.\n\n사용자들은 새로운 패턴을 배우도록 강요하면 응용 프로그램을 사용하지 않을 거예요. 이전 디자이너 세대에 의해 시작된 특정 패턴에 익숙해진 인간들이 존재합니다. 젊은 사람들은 습관을 변경할 수 있지만, 대부분의 사용자는 그렇지 않을 겁니다.\n\n대중을 대상으로 디자인하고 구축하세요. 기존 표준과 사용자 패턴이나 행동을 활용해 인터페이스를 작성함으로써 이러한 실수를 피해보세요. 사용자가 최소한의 노력으로 제품을 구매할 수 있도록 해주세요. 소셜 미디어는 이러한 실수에 대한 해결책을 제시했습니다. 그것이 중독성이 있는 이유가 있지요. 더 적은 노력, 더 큰 보상.\n\n\n\n# 실수 #5\n\n일단 해결책을 만들고 코드를 작성해 보세요. 나중에 어떻게 될지는 확인해 볼 거에요. 변경 사항은 나중에 하기로 했잖아요? 그렇지 않아요. 처음부터 확장 가능성을 고려하세요. 버그와 오류를 수정하는 데 필요한 리팩토링과 개발 시간은 이상적이지 않아요.\n\n시작부터 문제를 해결하는 데 특정 기술을 선택하고, 가능한 미래 지표에 기반해 확장 가능한지 파악하세요. 예를 들어, 우리가 다양화하기로 결정한 후 React 성능 특정 작업을 사용할 수 있을까요? 아니에요. 그러면 사용해야 할까요? 아니요. 다른 기술을 선택하세요.\n\n대부분의 백엔드 엔지니어는 모든 문제에 같은 기술 세트를 사용해요. 개발자들은 가능한 트래픽과 데이터 거래를 고려하지 않아요. 2013년, 해커들이 Snapchat의 확장 가능성이 없는 코드베이스를 악용하여 수백만 명의 사용자 데이터에 접근했어요. 그런 일이 발생하지 않길 바라지 않겠죠.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png"},"coverImage":"/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    pre: \"pre\",\n    code: \"code\",\n    h1: \"h1\",\n    p: \"p\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"![Avoid These 5 Mistakes as a Web Developer](/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png)\\n\\n우리는 모두 실수를 합니다. 배우고成長하며、경험을 쌓는 가장 효율적인 방법입니다. 실수를 돌아보고 그로부터 배우면 스스로를 향상시킬 수 있습니다.\\n\\n대부분의 사람들은 자신의 실수를 돌아보지 않습니다. 그들은 그 실수를 저지르지 않았어야 한다고 자책합니다. 다른 사람이 그들을 비난할 필요는 없습니다; 그들 스스로 힘을 줍니다.\\n\\n웹 개발자 경력 중에 백엔드 엔지니어가 범하는 십 가지 오류를 나열하겠습니다. 실수를 범하는 데는 현재 위치가 중요하지 않습니다. 우리는 경력 어디서든지 언제든지 실수를 합니다.\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"실수 #1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기술 부채. 지나친 공학. 종소리가 울리나요? 종종, 개발자들은 사용자가 응용 프로그램을 활용하는 방식을 이해하는 대신 기술적인 측면에 초점을 맞춥니다. 해당 요구 사항에 따라 코드를 작성하지 않습니다. 백엔드 엔지니어가 요구 사항을 기반으로 기술을 사용하면 필요한 노력과 비용을 크게 줄일 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"대부분의 경우, 초보자들이 이 실수에 빠집니다. 분야에 새로 온 사람들은 사용자에게 효율적으로 제공되는 기술을 알지 못하기 때문에 기술적 부담을 줄이는 기술을 사용하지 않는 것입니다. 더 많은 기술과 처리가 필요할 때 응용 프로그램은 최종 사용자에게 느리게 나타납니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"어떤 분야, 취미 또는 습관에 새로 온 사람들은 프로세스를 지나치게 복잡하게 만들기 쉽습니다. 그러나 경력자들은 더 적은 기술을 사용하여 개발 및 사용자 시간을 절약하면서 노력과 비용을 줄입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더불어, 기술 부채는 읽기 어려운 코드를 나타냅니다. 다른 엔지니어들이 이해할 수 있는 로직을 작성하는 것이 개발의 첫 번째 규칙입니다. 이는 이러한 산업 표준 기술과 코딩 표준을 사용하거나 변수를 CamalCase 규칙으로 작성하는 것을 의미합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"초보자들은 가능한 모든 것을 사용할 때 자부심을 느낍니다. 나중에는 동일한 선택이 응용 프로그램을 느리게 만들 때 머리가 아플 수 있습니다. 이로 인해 시니어들이 코드를 리팩토링해야 하며, 이는 시간 낭비입니다. 코드가 많아질수록 테스트 요구 사항과 버그 발생 확률이 증가합니다. 코드를 적게 작성하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자존심을 한쪽에 두고 필요한 기술만 선택하고 최고의 산업 표준을 준수함으로써 이러한 실수를 피할 수 있습니다. 프론트엔드 프레임워크와 라이브러리를 배울 때 이 실수를 저질렀습니다. 이에 따라 더 많은 코드, 더 많은 버그 및 대규모 리팩토링 비용이 발생했습니다. DRY, KISS 또는 YAGNI 표준을 따르세요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"실수 #2\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"내가 Udemy에서 React를 배우는 데 돈을 썼어. 그 스킬을 활용해서 모든 애플리케이션을 React로 만들어야겠지? 아니야. 모든 작업에 같은 기술, 라이브러리 또는 프레임워크를 사용하지 말아야 해. 이 프레임워크의 선택은 해결해야 하는 문제에 따라 다르니까.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React + Vite는 중급 웹 애플리케이션에 적합할 수도 있어. 그러나 성능 중심의 애플리케이션에는 적합하지 않아. 그럴 때는 성능을 향상시키기 위해 SolidJS, NextJS 또는 다른 프레임워크를 선택해야 해.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"주어진 작업에 따라 사용하는 기술을 바꿔. 선택한 언어인 JavaScript 같은 기본기는 튼튼히 갖추고 있고, 기술을 바꿔가며 학습해.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하나의 기술에만 고수하지 마. 그것은 학습 능력을 제한하고 애플리케이션이 문제를 겪게 만들어. 나중에 그 기술을 바꿔야 하게 될 텐데, 처음부터 그렇게 할 수 있었을 텐데.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"실수 #3\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"나쁜 의도를 가진 사람들은 데이터베이스를 공격하고 자격 증명을 도용하기 위한 엄청난 기술을 가지고 있습니다. SQL 인젝션은 흔한 기술 중 하나입니다. 그것이 빈번하다면, 사람들은 그럼에도 불구하고 여전히 그에 빠질까요? 네, 그렇습니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 시니어들이 데이터베이스를 수정하는 쿼리를 주입하는 것을 방지하는 코드를 작성할 수 있지만, 주니어들은 이 분야의 복잡함을 알지 못할 수 있기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"2022년을 기준으로 웹 응용프로그램에서 발생한 전체 취약점 중 33%가 SQL Injection 공격으로 인한 것입니다. 원치 않는 문자열을 표준 쿼리와 연결함으로써 개인들이 DB에 액세스하고 일반적으로 DML 명령을 실행합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 실수를 피하기 위해 일반화된 쿼리를 사용하는 대신 쿼리 내에 구체적으로 필요한 매개변수를 전달하세요. 모든 작업에 대해 표준 쿼리를 만들지 마세요. 그렇게 하면 새벽 2시 30분에 전화를 받을 수도 있습니다. 여러 개의 데이터베이스를 사용하고 모든 과일을 한 바구니에 넣지 마세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다양성이 중요합니다. 코드 리뷰를 수행하세요. 특히 실행 중인 쿼리에 대해 연결된 문자열을 검증하세요. 제품 DB를 백업하면서 유지하세요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"실수 #4\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"미적인 면에 초점을 맞추는 사람이신가요? 사용성보다는 미학에 더 집중하는 것은 일반적인 초보 실수입니다. 초보 개발자는 사용자가 응용 프로그램을 어떻게 활용하는지에 대해 덜 주의를 기울이고 디자인을 지나치게 복잡하게 만들곤 합니다. UI/UX는 테스트 단계까지 아름답게 보일 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자들이 귀하는 응용 프로그램을 이용하게 될 때 비즈니스 매출이 감소합니다. 왜냐하면 그 중 95%는 사용하지 못하기 때문이죠. 복잡성 때문이라고 해야겠어요. 사용자들은 간단한 디자인을 선호합니다. 이미 본 적 있는 인터페이스가 원하는 것이죠. 사람들은 습관에 집중합니다. 어떤 작업에도 덜 노력을 기울이고 싶어해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자들은 새로운 패턴을 배우도록 강요하면 응용 프로그램을 사용하지 않을 거예요. 이전 디자이너 세대에 의해 시작된 특정 패턴에 익숙해진 인간들이 존재합니다. 젊은 사람들은 습관을 변경할 수 있지만, 대부분의 사용자는 그렇지 않을 겁니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"대중을 대상으로 디자인하고 구축하세요. 기존 표준과 사용자 패턴이나 행동을 활용해 인터페이스를 작성함으로써 이러한 실수를 피해보세요. 사용자가 최소한의 노력으로 제품을 구매할 수 있도록 해주세요. 소셜 미디어는 이러한 실수에 대한 해결책을 제시했습니다. 그것이 중독성이 있는 이유가 있지요. 더 적은 노력, 더 큰 보상.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"실수 #5\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일단 해결책을 만들고 코드를 작성해 보세요. 나중에 어떻게 될지는 확인해 볼 거에요. 변경 사항은 나중에 하기로 했잖아요? 그렇지 않아요. 처음부터 확장 가능성을 고려하세요. 버그와 오류를 수정하는 데 필요한 리팩토링과 개발 시간은 이상적이지 않아요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"시작부터 문제를 해결하는 데 특정 기술을 선택하고, 가능한 미래 지표에 기반해 확장 가능한지 파악하세요. 예를 들어, 우리가 다양화하기로 결정한 후 React 성능 특정 작업을 사용할 수 있을까요? 아니에요. 그러면 사용해야 할까요? 아니요. 다른 기술을 선택하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"대부분의 백엔드 엔지니어는 모든 문제에 같은 기술 세트를 사용해요. 개발자들은 가능한 트래픽과 데이터 거래를 고려하지 않아요. 2013년, 해커들이 Snapchat의 확장 가능성이 없는 코드베이스를 악용하여 수백만 명의 사용자 데이터에 접근했어요. 그런 일이 발생하지 않길 바라지 않겠죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 마크다운 형식으로 변경해주세요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}