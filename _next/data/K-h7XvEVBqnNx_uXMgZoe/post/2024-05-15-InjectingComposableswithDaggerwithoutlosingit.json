{"pageProps":{"post":{"title":"Dagger를 사용하여 컴포저블을 주입시키되, 그것을 잃지 않는 방법","description":"","date":"2024-05-15 15:54","slug":"2024-05-15-InjectingComposableswithDaggerwithoutlosingit","content":"\n\n\n![Injecting Composables with Dagger without losing it](/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png)\n\nEveryone is using Hilt/Koin or some other fancy DI framework that just works™.\n\nIn this house, we still use plain Dagger2. It’s… not going great.\n\nConsider the predicament of a composable that can only work with certain parameters:\n\n\n\n\n가끔 composable들이 호출자에게 너무 많은 것을 요구하는 경우가 있어요.\n\n이 때는 아마도 이미 너무 깊이 들어간 상황일 것이고, 이를 바꾸려면 다른 10가지 것들을 깨뜨려야 할 수도 있어요.\n\n## 정리\n\n이 게시물의 목표는 독립적인 composable을 만드는 방법을 찾는 것입니다:\n\n\n\n- 자체 Dagger 컴포넌트를 생성합니다.\n- 자신을 주입합니다.\n- 사용자 정의 팩토리로 ViewModel을 빌드합니다.\n- ViewModels 및 Compose에 대한 자세한 정보는 이 미미/블로그를 확인해주세요.\n\n## 요약\n\n## 시작점\n\nDagger2로 활동/프래그먼트를 일반적으로 사용합니다.\n\n\n\n- 자체 Dagger 컴포넌트를 빌드합니다\n- 또는 애플리케이션 컴포넌트에서 일부 의존성을 가져옵니다\n\n그런 다음 의존성을 파라미터로 컴포저블에 아래로 전달할 것입니다 (현재 그대로 또는 함수를 통해):\n\n정보는 CompositionLocals로도 전달할 수 있습니다.\n\n이 방법은 논란의 여지가 있는데, 최소한 이 글에서는 다루지 않겠습니다.\n\n\n\n<img src=\"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_1.png\" />\n\n## 이주\n\nFirstScreen을 독립적으로 만들기 위해서는 주입된 종속성을 별도의 클래스로 분리해야 합니다.\n\n@Stable 주석을 사용하면 생성된 후에 실제로 변경되지 않을 것을 compose 컴파일러에 알릴 수 있습니다.\n\n\n\n## Dagger 구성 요소\n\n## Compose 레이어\n\n이 방법은 처음에는 작동하지만 매번 재구성할 때마다 Dagger 구성 요소가 다시 생성됩니다.\n\n이와 같이 무해한 예제에 대해서는 성능에 거의 영향을 미치지 않을 것입니다. 그러나 보다 복잡한 화면에 대해서는 그렇지 않을 수 있습니다.\n\n\n\n\nLet’s use the classic remember keyword, then:\n\n![image](/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_2.png)\n\n## Should someone actually do this?\n\nThis approach goes against most compose guidelines. Composables should really be pure functions, fast, idempotent, and free of side effects.\n\n\n\n\n하지만 주요 리팩터링이 실현 가능하지 않을 때, 너무 많은 노력을 들이지 않고 작동시킬 수 있어요.\n\n## 잊지말고요 (미안해요😑)\n\n효율성이 중요하다면, 간단히 처리할 수 없을 거에요. Ian Lake가 여기에서 왜 설명하는지 알려줄게요:\n\n위와 같은 경우에는 DI 구성 요소가 다시 생성되어 composable로 주입될 거예요.\n\n\n\n세계의 끝은 아니지만, 특히 무거운 Dagger 구성 요소의 경우에는 약간의 단점이 있습니다.\n\n만약 기억하는 값을 너무 쉽게 잃어버리지 않을까 걱정된다면, 더 고급 스코핑 옵션 2가지가 있습니다:\n\n- **resaca**\n    - sebaslogen에 의해 만들어졌습니다. 정말 좋아요! 👍\n- **Circuit**\n    - Slack에 의해 만들어졌습니다. 더 강력한 기억 형태 이외에도 더 많은 기능들을 제공합니다. 개인적인 경험은 없습니다.\n\n## 그래도요\n\n\n\n조금이나마 도움이 되었기를 바랍니다.\n\n@markasduplicate\n\n나중에 봐요.","ogImage":{"url":"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png"},"coverImage":"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png\",\n        alt: \"Injecting Composables with Dagger without losing it\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Everyone is using Hilt/Koin or some other fancy DI framework that just works™.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this house, we still use plain Dagger2. It’s… not going great.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Consider the predicament of a composable that can only work with certain parameters:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가끔 composable들이 호출자에게 너무 많은 것을 요구하는 경우가 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 때는 아마도 이미 너무 깊이 들어간 상황일 것이고, 이를 바꾸려면 다른 10가지 것들을 깨뜨려야 할 수도 있어요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"정리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 게시물의 목표는 독립적인 composable을 만드는 방법을 찾는 것입니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"자체 Dagger 컴포넌트를 생성합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"자신을 주입합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사용자 정의 팩토리로 ViewModel을 빌드합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ViewModels 및 Compose에 대한 자세한 정보는 이 미미/블로그를 확인해주세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"요약\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"시작점\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Dagger2로 활동/프래그먼트를 일반적으로 사용합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"자체 Dagger 컴포넌트를 빌드합니다\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"또는 애플리케이션 컴포넌트에서 일부 의존성을 가져옵니다\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 의존성을 파라미터로 컴포저블에 아래로 전달할 것입니다 (현재 그대로 또는 함수를 통해):\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정보는 CompositionLocals로도 전달할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법은 논란의 여지가 있는데, 최소한 이 글에서는 다루지 않겠습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_1.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"이주\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"FirstScreen을 독립적으로 만들기 위해서는 주입된 종속성을 별도의 클래스로 분리해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"@Stable 주석을 사용하면 생성된 후에 실제로 변경되지 않을 것을 compose 컴파일러에 알릴 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Dagger 구성 요소\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Compose 레이어\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법은 처음에는 작동하지만 매번 재구성할 때마다 Dagger 구성 요소가 다시 생성됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이와 같이 무해한 예제에 대해서는 성능에 거의 영향을 미치지 않을 것입니다. 그러나 보다 복잡한 화면에 대해서는 그렇지 않을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let’s use the classic remember keyword, then:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_2.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Should someone actually do this?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This approach goes against most compose guidelines. Composables should really be pure functions, fast, idempotent, and free of side effects.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 주요 리팩터링이 실현 가능하지 않을 때, 너무 많은 노력을 들이지 않고 작동시킬 수 있어요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"잊지말고요 (미안해요😑)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"효율성이 중요하다면, 간단히 처리할 수 없을 거에요. Ian Lake가 여기에서 왜 설명하는지 알려줄게요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위와 같은 경우에는 DI 구성 요소가 다시 생성되어 composable로 주입될 거예요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"세계의 끝은 아니지만, 특히 무거운 Dagger 구성 요소의 경우에는 약간의 단점이 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 기억하는 값을 너무 쉽게 잃어버리지 않을까 걱정된다면, 더 고급 스코핑 옵션 2가지가 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"resaca\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"sebaslogen에 의해 만들어졌습니다. 정말 좋아요! 👍\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Circuit\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Slack에 의해 만들어졌습니다. 더 강력한 기억 형태 이외에도 더 많은 기능들을 제공합니다. 개인적인 경험은 없습니다.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"그래도요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"조금이나마 도움이 되었기를 바랍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"@markasduplicate\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"나중에 봐요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}