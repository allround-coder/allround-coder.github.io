{"pageProps":{"posts":[{"title":"React Router의 useParams 훅을 적용하는 실용적인 단계","description":"","date":"2024-05-12 22:03","slug":"2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter","content":"\n\n![이미지](/assets/img/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter_0.png)\n\nuseParams 훅은 React에서 친숙한 사용자 인터페이스를 개발하는 데 필수적입니다. 따라서 React 개발자가 익숙해져야 할 중요한 지식입니다. useParams 훅을 사용하면 전자 상거래 및 블로깅 웹 사이트와 같은 다중 매개변수를 가진 복잡한 React 인터페이스를 개발할 수 있습니다.\n\n이 튜토리얼은 React 애플리케이션에서 useParams 훅을 적용하는 방법에 대한 실용적인 단계와 지식을 제공하는 데 초점을 맞춥니다. 이 튜토리얼에서는 다음 주제를 다룰 것입니다:\n\n1. useParams 훅이란 무엇인가요?\n\n\n\n2. `useParams` 훅을 적용하기 위한 요구 사항\n\n3. `useParams` 훅을 사용하는 장점\n\n4. `useParams` 훅을 적용하는 실제적인 단계\n\n# 전제 조건:\n\n\n\n이것은 React와 React-router의 useParams 훅을 배우고 적용하는 것에 관심 있는 초보자를 위한 친절한 튜토리얼입니다. 이 튜토리얼에서 최대한 많은 도움을 받으려면 몇 가지 기본적인 React와 JavaScript 도구에 익숙해져야 합니다. 이러한 도구로는 다음이 포함됩니다:\n\n- React Routing,\n- Map 함수, 그리고\n- 구조 분해.\n\n또한 HTML 및 CSS에 익숙해져 있어야 합니다. 따라서 이 튜토리얼을 진행하기 전에 위의 개념들을 먼저 익히는 것을 권장합니다.\n\n# useParams 훅이란 무엇인가요?\n\n\n\n`useParams` 훅은 웹사이트의 여러 매개변수를 생성하고 액세스하는 데 사용되는 React 라우터 훅입니다. 본질적으로 `useParams` 훅은 동일한 URL 경로에서 여러 콘텐츠에 액세스할 수 있도록 해줍니다. `useParams` 훅을 통해 각 매개변수에 고유한 식별자를 부여할 수 있습니다. 이 고유한 식별자를 통해 동일한 URL 경로에서 각 매개변수에 액세스하고 렌더링할 수 있습니다.\n\n전자 상거래 및 블로그 앱은 여러 매개변수가 있는 애플리케이션의 예시입니다. `useParams` 훅이 적용되는 다른 예시로는 학습 관리 시스템(LMS) – 즉, 온라인 튜토리얼 사이트, 웹사이트의 검색 버튼, 기사/신문 웹사이트 등이 있습니다.\n\n예를 들어, 블로그 앱에는 여러 블로그가 포함되어 있습니다. 각 블로그에는 고유한 ID가 있어서 각 블로그에 접근할 수 있습니다.\n\n# `useParams` 훅을 적용하는 요구 사항\n\n\n\nReact 앱에서 useParams 훅을 적용하려면 몇 가지 기본 도구와 라이브러리가 필요합니다. 이 섹션에서는 이러한 기본 요구 사항을 살펴볼 것입니다.\n\n## 1. React-router-dom\n\nreact-router-dom은 React 애플리케이션에서 라우팅을 제공하는 외부 React 라이브러리입니다. react-router-dom에는 useParams 훅이 함께 제공됩니다. 따라서 useParams 훅을 적용하려면 react-router-dom을 React 앱에 설치해야 합니다. 아래 섹션에서는 react-router-dom을 설치하는 방법을 안내합니다.\n\n## 2. Component\n\n\n\n컴포넌트는 HTML 요소를 반환하는 JavaScript 코드 집합입니다. React의 컴포넌트는 브라우저에 표시할 내용을 결정합니다.\n\nuseParams 훅을 적용하려면 컴포넌트를 만들고 해당 컴포넌트로 useParams를 가져와야 합니다. 그런 다음 객체 비구조화를 사용하여 useParams 메서드에 변수를 할당하세요. 아래 코드 예시를 참고하세요.\n\n```js\nimport { useParams } from 'react-router-dom';\n\nfunction Blog(){\n  let { blogid } = useParams();\n  return<p>내 고유 ID는 {blogid}입니다.</p>\n}\n```\n\n### 3. Route 태그\n\n\n\nRoute 태그는 브라우저의 URL 경로를 나타냅니다. Route 태그는 두 가지 속성을 받습니다. path 속성과 element 속성이 포함되어 있습니다. path 속성은 URL 경로에 할당됩니다. element 속성은 렌더링할 컴포넌트에 할당됩니다.\n\nuseParams 훅을 적용하려면 path 속성에도 자리 표시자가 포함되어야 합니다. 자리 표시자의 역할은 해당 값을 기반으로 동적 콘텐츠를 반환하는 것입니다. 아래 예제를 참조해보세요.\n\n```js\n<Routes>\n    <Route path='/blog/:blogid' element={<Blog />}></Route>\n</Routes>\n```\n\n다음 사항을 주의하십시오:\n\n\n\n- blogid은 플레이스홀더이며 임의의 이름을 사용할 수 있습니다.\n- 일반적으로 플레이스홀더는 값 이전에 `:`를 포함합니다.\n- 플레이스홀더 이름은 컴포넌트의 useParams 메서드에 할당된 값과 일치해야 합니다.\n- 따라서 URL 경로인 /blog/2는 id 번호가 2인 블로그 콘텐츠를 반환합니다.\n\n# useParams 훅을 사용하는 장점\n\nuseParams 훅을 사용하는 것은 React 개발자와 사용자 양쪽에 많은 이점이 있습니다. useParams 훅을 사용하는 장점 중 일부는 다음과 같습니다.\n\n- 다중 매개변수: useParams 훅은 동적 콘텐츠를 포함하는 여러 매개변수를 만드는 데 사용됩니다. 따라서 응용 프로그램에서 useParams 훅을 사용하면 사용자에게 친숙한 방식으로 다양한 정보를 제공할 수 있습니다.\n- 앱 성능 향상: useParams 훅은 동적 콘텐츠를 동일한 URL 경로에 렌더링합니다. 이는 앱의 성능을 향상시키고로딩 시간을 줄입니다.\n- 쉬운 접근성: useParams 훅은 사용자 친화적인 도구로, 다중 매개변수와 콘텐츠에 쉽게 접근할 수 있습니다.\n- 더 적은 코드: useParams 훅을 사용하면 몇 줄의 코드로 여러 매개변수를 만들 수 있습니다. 결국, 이는 불필요한 반복을 제거하고 작성해야 하는 코드 양을 줄여줍니다.\n\n\n\n# React에서 useParams 훅을 적용하는 실용적인 단계\n\n이 섹션에서는 여러 제품을 표시하는 간단한 전자 상거래 인터페이스를 구축하는 방법을 살펴볼 것입니다. 각 제품은 고유한 ID를 갖고 있어 해당 ID를 통해 액세스할 수 있습니다.\n\n이 섹션은 세 부분으로 나뉘어집니다.\n\n- 첫 번째 부분에서는 React 앱을 만드는 방법을 안내합니다.\n- 두 번째 부분에서는 간단한 전자 상거래 인터페이스를 만드는 방법을 안내합니다.\n- 세 번째 부분에서는 프로젝트에서 useParams 훅을 적용하는 방법을 안내합니다.\n\n\n\n시작해 봅시다.\n\n# 첫 번째 부분 — React 프로젝트 생성\n\n아래 단계는 React 앱을 생성하고 react-router-dom을 설치하는 데 도움이 됩니다.\n\n## 단계 1: React 앱 생성\n\n\n\nReact 앱을 만들려면 아래 지시사항을 따라주세요.\n\n- 터미널을 열고 React 앱을 위한 새 폴더를 만드세요.\n- 새롭게 만든 폴더로 이동한 후 React 앱을 만드세요. 아래 명령어 중 하나를 사용하세요.\n\n```js\nC:\\Users\\Username\\Desktop>mkdir react-app\nC:\\Users\\Username\\Desktop>cd react-folder\nC:\\Users\\Username\\Desktop\\react-folder>npx create-react-app my-app\n```\n\n\n\n```js\nC:\\Users\\Username\\Desktop\\react-folder>npm init react-app my-app\n```\n\n또는\n\n```js\nC:\\Users\\Username\\Desktop\\react-folder>yarn create react-app my-app\n```\n\n다음 사항을 주의하십시오:\n\n\n\n- 리액트 앱을 만들기 전에 시스템에 node.js가 설치되어 있어야 합니다. 시스템에 node.js가 없는 경우 https://node.js.org를 방문하여 설치하세요.\n- react-app과 my-app은 각각 폴더와 리액트 앱의 이름입니다. 이름은 원하는 대로 지정할 수 있습니다.\n\n## 단계 2: React-router-dom 설치\n\n아래 지시 사항은 우리의 리액트 프로젝트에 React-router-dom을 설치하는 방법을 안내합니다.\n\n- 터미널에서 앱 디렉토리로 이동합니다.\n- npm이나 yarn을 사용하여 react-router-dom을 설치하세요.\n\n\n\n아래의 코드 예시를 확인해보세요.\n\n```js\nC:\\Users\\사용자명\\Desktop\\react-folder>cd my-app\nC:\\Users\\사용자명\\Desktop\\react-folder\\my-app>npm install react-router-dom\n```\n\n## 단계 3: 서버 시작\n\n여전히 앱 디렉토리 안에 있는 경우, 아래의 코드와 같이 React 앱 서버를 시작하세요.\n\n\n\n```js\nC:\\Users\\사용자명\\Desktop\\react-folder\\my-app>npm start\n```\n\nYarn 사용자:\n\n```js\nC:\\Users\\사용자명\\Desktop\\react-folder\\my-app>yarn start\n```\n\n참고: React 앱을 만들 때 사용하는 npm 또는 yarn을 사용하여 React 종속성을 설치하고 React 스크립트를 실행하세요. 원하는 방법에 따라 npm이나 yarn을 사용하세요.\n\n\n\n시작 스크립트는 로컬호스트 3000번 포트에서 React 앱 서버를 실행합니다.\n\n# 두 번째 파트 — 간단한 전자 상거래 인터페이스 설정\n\n우리는 React 앱을 성공적으로 생성하고 react-router-dom을 설치했습니다. 이제 간단한 전자 상거래 인터페이스를 만들어볼 수 있습니다.\n\n## 단계 1: index.js 파일 수정\n\n\n\nReact 앱을 선택한 코드 편집기로 열고 아래 지침을 따라 index.js 파일을 수정하십시오.\n\n- src 디렉토리에서 index.js 파일을 엽니다.\n- 객체 비구조화를 사용하여 react-router-dom에서 BrowserRouter를 가져옵니다.\n- App 컴포넌트를 BrowserRouter 태그로 둘러싸는 방식으로 root const를 업데이트합니다.\n\n최종 index.js 파일의 코드는 아래 예시와 같이 보여야 합니다.\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { BrowserRouter } from 'react-router-dom';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>\n);\n```\n\n\n\n## 단계 2: 제품 컴포넌트 만들기\n\n이 컴포넌트는 제품 데이터를 보유할 것입니다. 하지만 제품 컴포넌트를 만들기 전에 먼저 src 디렉토리에 이미지 폴더를 생성하세요. 이미지 폴더에는 사용할 모든 필요한 이미지가 포함되어야 합니다. 그리고 아래 지침을 따라 제품 컴포넌트를 만드세요.\n\n- src 디렉토리에 components 폴더를 생성하세요.\n- components 폴더에 Products.js 파일을 만드세요.\n- Products.js 파일을 열고 Products 변수를 만드세요.\n- Products 변수를 객체 배열에 할당하세요. 각 객체는 고유한 id, 타이틀, 설명, 이미지를 포함해야 합니다.\n- Products 컴포넌트를 내보내세요.\n\n아래 코드 예시를 참고하세요.\n\n\n\n```js\nconst Products = [\n    {\n        id: 1,\n        title: \"제품 이름\",\n        description: \"이것은 id가 1인 상품의 설명입니다. Provident nihil minus qui consequatur non omnis maiores. Eos accusantium minus dolores iure perferendis tempore et consequatur. \",\n        image: require('../images/product-1.png')\n    },\n    {\n        id: 2,\n        title: \"제품 이름\",\n        description: \"이것은 id가 2인 상품의 설명입니다. Provident nihil minus qui consequatur non omnis maiores. Eos accusantium minus dolores iure perferendis tempore et consequatur. \",\n        image: require('../images/product-2.png')\n    },\n    {\n        id: 3,\n        title: \"제품 이름\",\n        description: \"이것은 id가 3인 상품의 설명입니다. Provident nihil minus qui consequatur non omnis maiores. Eos accusantium minus dolores iure perferendis tempore et consequatur. \",\n        image: require('../images/product-3.png')\n    }\n]\n\nexport default Products;\r\n```\n\n## Step 3: 카드 컴포넌트 생성\n\n카드 컴포넌트의 본질은 제품들을 순회하고 조직적인 방식으로 렌더링하는 것입니다. 다음 지침은 카드 컴포넌트를 만드는 방법을 안내합니다.\n\n- components 디렉토리에 Card.js 파일을 생성합니다.\n- Card.js 파일을 열고 Products 컴포넌트를 import합니다.\n- return 메소드를 가진 Card 함수를 생성합니다.\n- 카드 함수 내에 return 메소드 전에 productItems 변수를 생성합니다.\n- productItems 변수를 우리 Products를 순회하는 map 함수에 할당합니다. map 함수는 아래 코드 예시와 같아야 합니다.\n\n\n\n\n```js\nconst productItems = Products.map(store =>{\n    const {id, title, description, image} = store;\n    return(\n      <div key={ id } className=\"card\">\n        <img src={image} alt=\"\"></img>\n        <h3>{title}</h3>\n        <p>{description}</p>\n      </div>\n    )\n})\n```\n\n6. Card 함수의 return 메소드 안에 section 태그를 생성하세요. section 태그 사이에는 중괄호 안에 productItems가 들어가야 합니다.\n\n7. Card 컴포넌트를 export하세요.\n\nCard.js 파일의 최종 코드는 아래의 코드 예시와 같을 것입니다.\n\n\n\n```js\nimport Products from \"./Products\";\n\nfunction Card(){\n\n    const productItems = Products.map(store =>{\n        const {id, title, description, image} = store;\n        return(\n            <div key={ id } className=\"card\">\n                <img src={image} alt=\"\"></img>\n                <h3>{title}</h3>\n                <p>{description}</p>\n            </div>\n        )\n    })\n\n    return (\n        <>\n            <section className=\"card-section\">\n                {productItems}\n            </section>\n        </>\n    );\n};\n\nexport default Card;\n```\n\n## 단계 4: 카드 컴포넌트 스타일링\n\nindex.css 파일에 Card 컴포넌트에 CSS 스타일을 추가하십시오.\n\n참고: Card 컴포넌트 내부의 div 태그와 section 태그에는 className 속성이 포함되어 있습니다. 이 className 속성은 목적에 맞게 CSS 스타일링을 위해 만들어졌습니다.\n\n\n\nsrc 폴더 내의 index.css 파일을 열고 아래 CSS 스타일을 적용하세요.\n\n```js\n.card-section{\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 20px;\n  margin: 40px;\n}\n\n.card{\n  padding: 1.2rem;\n  font-size: 1.2rem;\n  border: 1px solid rgb(104, 101, 101);\n}\n```\n\n## 단계 5: 홈 페이지 만들기\n\n홈 페이지는 앱의 기본 페이지로 사용되며 카드 컴포넌트를 렌더링할 것입니다. 아래 안내 사항을 따라 홈 페이지를 만들어 보세요.\n\n\n\n- src 디렉토리에 페이지 폴더를 생성하세요.\n- 페이지 폴더 안에 Home.js 파일을 만들어주세요.\n- Home.js 파일을 열고 Card 컴포넌트를 import 해주세요.\n- return 메소드를 포함하는 Home 함수를 생성해주세요. return 메소드는 Card 요소를 포함해야 합니다.\n- Home.js 파일을 export 해주세요.\n\n아래 코드를 참조해주세요.\n\n```js\nimport Card from \"../components/Card\"\n\nfunction Home(){\n    return (\n        <>\n            <h1>Home Page</h1>\n            <Card />\n        </>\n    )\n}\n\nexport default Home;\n```\n\n## 단계 6: App.js 파일 수정하기\n\n\n\nApp.js 파일은 브라우저에 무엇을 렌더링할지를 결정하는 루트 컴포넌트입니다. 이 단계에서는 App.js 파일을 수정하여 페이지를 렌더링하겠습니다. 아래 지시사항을 따라 App.js 컴포넌트를 수정해봅시다.\n\n- App.js 파일을 열고 Home 컴포넌트를 import 합니다.\n- App.js 파일의 return 메서드를 아래 코드에서와 같이 Home 엘리먼트를 포함하도록 업데이트합니다.\n\n```js\nimport React from 'react';\nimport './App.css';\nimport Home from './pages/Home';\n\nfunction App() {\n\n  return (\n    <div className=\"App\">\n      <Home />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n모든 파일을 저장하고 브라우저에서 localhost:3000 으로 이동해보세요. 결과는 아래 스크린샷과 같을 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter_1.png\" />\n\n저희 이커머스 인터페이스를 만드는 데 정말 멋진 작업을 했네요. 하지만 아직 해야 할 작업이 많습니다. 예를 들어, 제품 설명은 더 적은 단어로 작성되어야 하며 각 카드에 제품별로 이동할 수 있는 링크가 있어야 합니다. 그래서 useParams 훅을 적용할 것입니다.\n\n# 세 번째 부분 — useParams 훅 적용하기\n\nuseParams 훅을 사용하면 각 제품에 대한 고유 ID를 통해 액세스 권한을 갖는 친숙한 인터페이스를 만들 수 있습니다. useParams 훅은 React-router-dom 패키지와 함께 제공됩니다. 따라서 우리는 이를 적용하기 전에 react-router-dom에서 useParams 훅을 가져와야 합니다. 시작해봅시다.\n\n\n\n## 단계 1: 제품 상세 페이지 만들기\n\n제품 상세 페이지는 각 제품의 고유 ID에 따라 완전한 세부 정보를 포함하고 렌더링할 것입니다. 아래 지침은 제품 상세 페이지를 만드는 데 도움이 됩니다.\n\n- 페이지 폴더에 ProductDetail.js 파일을 만듭니다.\n- ProductDetail.js 파일을 열고 다음 내용을 가져옵니다:\n\n- component 폴더에서 Products 컴포넌트\n- 객체 비구조화를 사용하여 react-router-dom에서 useParams.\n\n\n\n3. return 메소드가 있는 ProductDetail 함수를 생성하세요.\n\n4. ProductDetail 함수 내에서 return 메소드 이전에 useParams 메소드에 `id` 를 할당하세요. 아래 코드 예시를 참고해보세요.\n\n```js\nlet { id } = useParams()\n```\n\n5. product 변수를 생성하고 find 메소드에 할당하세요. 예시:\n\n\n\n```js\nconst product = Products.find(product => String(product.id) === id);\n```\n\n여기서 find 메서드를 사용하여 각 제품의 id를 일치시켜 제품의 다른 세부 정보에 액세스할 수 있습니다.\n\n6. ProductDetails 함수의 return 메서드에서 섹션 태그를 만드세요. 섹션 태그는 중괄호 안에 id에 할당된 키 속성을 포함해야 합니다.\n\n7. 코드 아래처럼 다른 태그를 만드세요.\n\n\n\n8. ProductDetail.js 파일을 내보내기하세요.\n\nProductDetail.js 파일의 최종 코드는 아래 예시 코드와 같이 될 것입니다.\n\n```js\nimport { useParams } from \"react-router-dom\";\nimport Products from \"../components/Products\";\n\nfunction ProductDetail() {\n \n   let { id } = useParams();\n    const product = Products.find(product => String(product.id) === id);\n\n    return (\n        <>\n            <section key={id} className=\"details-section\">\n                <img src={product.image} alt=\"\"></img>\n                <div>\n                    <h3>{product.title}</h3>\n                    <p>{product.description}</p>\n                </div>\n            </section>\n       </>\n    )\n}\n\nexport default ProductDetail;\n```\n\n## 단계 2: productDetail 페이지 스타일링\n\n\n\n\n```css\n.details-section {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: 30px;\n  margin: 90px;\n  font-size: 1.3rem;\n}\n```\n\n## 단계 3: 라우트 생성\n\n라우트는 URL 경로로 콘텐츠에 액세스하는 것을 안내합니다. App.js 파일에 모든 필요한 라우트를 생성할 것입니다. 아래 지침은 라우트를 생성하는 데 도움이 됩니다.\n\n\n\n- App.js 파일을 열고 다음을 가져와주세요:\n  - 페이지 폴더에서 ProductDetail,\n  - react-router-dom에서 Routes 및 Route.\n\n- App.js 함수의 반환 방법을 다음과 같이 업데이트하세요:\n  1. Routes 태그를 만드세요.\n  2. Routes 태그 사이에 두 개의 Route 태그를 생성하세요. Routes와 Route의 차이를 알아두어 혼동하지 않도록 주의하세요.\n  3. 각 Route 태그에는 path와 element 속성이 포함되어야 합니다.\n\n아래 코드 예시를 참고하세요.\n\n```js\nimport React from 'react';\nimport './App.css';\nimport Home from './pages/Home';\nimport ProductDetails from './pages/ProductDetails';\nimport { Route, Routes } from 'react-router-dom';\n\nfunction App() {\n\n  return (\n\n    <div className=\"App\">\n\n      <Routes>\n        <Route path='/' element={<Home />}></Route>\n        <Route path='/product/:id' element={<ProductDetails />}></Route>\n      </Routes>\n\n    </div>\n\n  );\n}\n\nexport default App;\n```\n\n주의할 점:\n\n\n\n- 첫 번째 Route 경로는 `/`에 할당되어 있으며, 기본 URL 경로를 나타냅니다. 기본 URL 경로는 Home 컴포넌트를 표시합니다.\n- 두 번째 Route 경로는 product로 할당되어 있으며, 플레이스홀더 :id를 가지고 있습니다.\n\n## 단계 4: card.js 컴포넌트 수정\n\n아래 지침은 card 컴포넌트를 수정하는 방법을 안내합니다.\n\n- Card.js 파일을 열고 react-router-dom에서 Link를 import합니다.\n- card 컴포넌트의 return 메소드 안에 p 태그 사이에 Link 태그를 삽입합니다. Link 태그는 to 속성을 포함해야 합니다. 아래 코드 예시를 참고하세요.\n\n\n\n```js\n<Link to={`/product/${id}`}>자세히 보기</Link>\n```\n\n우리 `to` 속성의 값은 backtick (` )과 템플릿 리터럴 ( `$''` )을 사용하여 id의 값을 포함합니다. 각 매개변수의 URL 경로에 접근하는 표준 방법입니다.\n\n3. 슬라이스(Slice) 메서드를 사용하여 설명 단어를 줄입니다.\n\n최종 카드 컴포넌트 코드는 아래의 코드 예시와 같이 되어야 합니다.\n\n\n\n```js\nimport { Link } from \"react-router-dom\";\nimport Products from \"./Products\";\n\nconst Card = () => {\n\n   const productItems = Products.map(store =>{\n        const {id, title, description, image} = store;\n        return(\n            <div key={ id } className=\"card\">\n                <img src={image} alt=\"\"></img>\n                <h3>{title}</h3>\n                <p>{description.slice(0, 100)}<Link to={`/product/${id}`}>더 보기</Link></p>\n            </div>\n        )\n    })\n\n    return (\n        <>\n            <section className=\"card-section\">\n                {productItems}\n            </section>\n        </>\n    );\n};\n\nexport default Card;\r\n```\n\n모든 파일을 저장하고 브라우저로 이동하세요. 아래의 gif 이미지는 프로젝트 결과물을 보여줍니다. 이제 각 제품은 고유한 ID를 통해 액세스할 수 있습니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1380/0*_YFGAyjrfYyg-Q7b.gif\" />\n\n# 결론\n\n\n\n이 문서는 useParams 훅에 대한 포괄적인 지식을 제공합니다. useParams 훅은 여러 매개변수가 필요한 React 애플리케이션을 만드는 데 필수적입니다. 따라서 사용자 친화적인 방식으로 각 매개변수에 쉽게 액세스할 수 있습니다.\n\n독서해 주셔서 감사합니다. 이 튜토리얼이 유용하게 활용되기를 바랍니다.\n\n# 추가 자료\n\n- React Router: useParams() 훅 사용법\n- React Router에서 useParams 훅 사용 방법\n\n\n\n감사합니다. 끝까지 읽어주셔서 감사합니다. 저와 이 출판물을 팔로우해 주시기를 고려해 주세요. 전 세계적으로 무료 프로그래밍 교육을 더 democrazing 하고 있는 Stackademic을 방문하여 더 많은 정보를 얻어보세요.","ogImage":{"url":"/assets/img/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter_0.png"},"coverImage":"/assets/img/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter_0.png","tag":["Tech"],"readingTime":15},{"title":"리액트 JS란 무엇인가요 왜 사용하나요","description":"","date":"2024-05-12 22:02","slug":"2024-05-12-WHATISREACTJSWHYWEUSEIT","content":"\n\n![React.js](/assets/img/2024-05-12-WHATISREACTJSWHYWEUSEIT_0.png)\n\n# React.js가 무엇인가요?\n\nReact.js 또는 간단히 React는 Facebook에서 개발한 오픈 소스 JavaScript 라이브러리입니다. 이는 사용자 인터페이스를 구축하는 데 사용되며 특히 단일 페이지 애플리케이션(SPA)의 경우 UI가 매우 동적이고 반응적이어야 할 때 사용됩니다.\n\nReact.js의 핵심은 선언적이고 컴포넌트 기반의 UI 구축 방식을 제공합니다. 이는 개발자가 상태를 관리하는 캡슐화된 컴포넌트를 생성할 수 있으며, 데이터가 변경될 때 React가 효율적으로 업데이트하고 렌더링하는 컴포넌트를 관리할 수 있습니다. React는 가상 DOM(Document Object Model)을 사용하여 렌더링 성능을 최적화하며 필요한 컴포넌트만 업데이트하고 전체 페이지를 다시 렌더링하지 않도록합니다.\n\n\n\n# React.js를 사용해야 하는 이유\n\nReact.js가 개발자들 사이에서 엄청 인기를 얻은 몇 가지 이유가 있어요:\n\n- 컴포넌트 기반 아키텍처: React의 컴포넌트 기반 아키텍처는 재사용성과 모듈성을 장려해요. 개발자들은 작고 독립적인 컴포넌트를 만들고 이를 조합하여 복잡한 UI를 구축할 수 있어서 유지 및 확장이 쉽습니다.\n- 가상 DOM: React는 가상 DOM을 사용하여 UI를 메모리에 나타내어 효율적으로 업데이트하고 렌더링할 수 있어요. 브라우저의 DOM을 직접 조작하는 대신, React는 실제 DOM을 업데이트하는 가장 효율적인 방법을 계산하여 성능을 향상시킵니다.\n- 선언형 구문: React는 선언형 구문을 사용하는데, 개발자들이 현재 애플리케이션 상태에 기반하여 UI가 어떻게 보일지를 설명합니다. 이는 명령형 방식에 비해 코드를 이해하고 추론하기 쉽게 만들어줘요.\n- 일방향 데이터 바인딩: React는 단방향 데이터 흐름을 따르는데, 데이터가 부모에서 자식 컴포넌트로 props를 통해 흐릅니다. 데이터 변경을 추적하고 디버깅하기 쉬워져서 예상치 못한 부작용이 발생할 가능성을 줄입니다.\n- 큰 생태계: React는 핵심 기능을 보완하는 라이브러리, 도구 및 확장 프로그램들이 풍부한 생태계를 가지고 있어요. 이는 Redux와 같은 상태 관리 라이브러리, React Router와 같은 라우팅 솔루션, Jest와 React Testing Library와 같은 테스팅 프레임워크를 포함합니다.\n- 커뮤니티 지원: React에는 지속적인 개발에 기여하는 개발자들의 활성화된 커뮤니티가 있어요. 이들은 포럼, 블로그, 소셜 미디어를 통해 지식을 공유하고 튜토리얼, 코스, 플러그인과 같은 가치 있는 리소스를 만듭니다.\n\n# React.js 역사와 배경\n\n\n\n리액트.js는 처음 Facebook의 소프트웨어 엔지니어인 Jordan Walke에 의해 개발되었고, 2011년 Facebook의 뉴스피드에서 처음으로 배포되었습니다. 이후 2013년에 오픈 소스로 공개되어 Facebook 외부의 개발자들이 라이브러리를 사용하고 기여할 수 있게 되었습니다.\n\n릴리스 이후 리액트.js는 큰 변화를 거쳐 사용자 인터페이스를 구축하는 데 가장 인기 있는 JavaScript 라이브러리 중 하나가 되었습니다. Facebook, Instagram, Netflix, Airbnb 등과 같은 대규모 기업들을 포함해 모든 규모의 기업에서 널리 채택되고 있습니다.\n\n리액트의 성공은 리액트 네이티브(React Native)의 개발로 이어졌습니다. React Native는 React.js 원칙을 활용하여 크로스 플랫폼 모바일 애플리케이션을 개발하기 위한 프레임워크입니다. React Native를 사용하면 JavaScript로 모바일 앱을 작성하면서 네이티브 플랫폼 기능을 활용할 수 있어, 웹 개발 이상으로 React의 영향력을 확장하고 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-WHATISREACTJSWHYWEUSEIT_0.png"},"coverImage":"/assets/img/2024-05-12-WHATISREACTJSWHYWEUSEIT_0.png","tag":["Tech"],"readingTime":2},{"title":"넥스트js 파일 이름 규칙은 ESLint 규칙으로 확인됩니다","description":"","date":"2024-05-12 22:01","slug":"2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules","content":"\n\n<img src=\"/assets/img/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules_0.png\" />\n\n현재 프론트엔드 환경에는 많은 네이밍 규칙이 있어요. 예를 들어, 컴포넌트는 파스칼 케이스로 작성해야 하지만, 훅 관련 파일은 카멜 케이스로 작성해야 하며, 훅 프로세스는 파일 이름의 시작에 use를 붙여야 해요. 예를 들어, useHooks.ts 같은 식이죠. 프론트엔드 환경 뿐만 아니라 여러분의 환경에도 암묵적인 네이밍 규칙이 있을 거라고 확신해요.\n\n여기 네이밍 규칙 예시가 있어요. 여러분은 프로젝트에서 네이밍 규칙을 어떻게 관리하나요?\n\n```js\nsrc\n├ app // app 디렉터리 아래는 케밥 케이스입니다.\n│ ├ layout.tsx\n│ ├ not-found.tsx\n│ ├ page.tsx\n│ └ about\n│   ├ layout.tsx\n│   └ page.tsx\n├ components // components 디렉터리 아래는 파스칼 케이스입니다.\n│ └ Button\n│   ├ Button.tsx\n│   ├ Button.modules.css\n│   └ index.tsx\n└ features\n  └ serach-feature\n    ├ components\n    │ └ SerchField\n    ├ hooks // hooks 디렉터리 아래는 카멜 케이스입니다. 파일 이름에 \"use\"를 추가해주세요.\n    │ └ useSearch.tsx\n    ├ providers // providers 디렉터리 아래는 카멜 케이스입니다. 파일 이름에 \"Provider\"를 추가해주세요.\n    │ └ searchProvider.tsx\n    └ utils\n```\n\n\n\n그래서 ESLint 규칙과 통합하는 아이디어를 생각해냈고, Next.js 프로젝트에 완벽하게 어울리는 eslint-plugin-validate-filename을 만들었어요. 이 아이디어를 공유해주시면 피드백과 이슈를 주시면 감사하겠어요.\n\nVSCode는 이렇게 오류를 표시할 거에요.\n\n![image](/assets/img/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules_1.png)\n\n# 설치\n\n\n\n먼저 필요한 패키지를 설치하세요.\n\n```js\nnpm install --save-dev eslint-plugin-validate-filename\n```\n\n다음으로 ESLint 구성을 추가하세요. 구성 파일에는 .eslintrc 및 .eslint.json이 포함됩니다. validate-filename은 네이밍 규칙을 가지고 있습니다.\n\n```js\n{\n  \"plugins\": [\"validate-filename\"],\n  \"rules\": {\n    \"validate-filename/naming-rules\": [\n      \"error\",\n      {\n        \"rules\": [\n          // 여기에 규칙을 추가하세요\n        ]\n      }\n    ]\n  }\n}\n```\n\n\n\n# 컴포넌트 네이밍 규칙\n\n컴포넌트를 만들 때는 PascalCase를 사용하는 것이 좋습니다. 이 규칙은 컴포넌트와 일반 HTML 요소를 쉽게 구별할 수 있도록 도와줍니다.\n\n케이스에는 camel, pascal, snake, kebab, flat이 있습니다. 대상은 폴더 경로의 이름이어야 합니다. index 이름은 무시됩니다.\n\n```js\n{\n  \"case\": \"pascal\",\n  \"target\": \"**/components/**\"\n}\n```\n\n\n\n여기 유효한 예와 유효하지 않은 예가 있어요.\n\n```js\n/components/App/App.tsx // 유효함\n/components/App/app.tsx // 유효하지 않음\n```\n\n# 앱 라우터 네이밍 규칙\n\nNext.js의 앱 라우터 디렉터리 아래에서는 케밥 케이스로 작성하는 것이 좋습니다. 파일 이름이 고정되어 있고 모두 케밥 케이스이기 때문입니다.\n\n\n\n규칙은 다음과 같습니다.\n\n```js\n{\n  \"case\": \"kebab\",\n  \"target\": \"**/app/**\",\n}\n```\n\n다음은 유효한 예와 유효하지 않은 예시입니다.\n\n```js\n/app/page.tsx // 유효\n/app/not-found.tsx // 유효\n/app/appRoute.tsx // 유효하지 않음\n```\n\n\n\n앱 디렉토리 내에서 특정 파일 이름으로의 사용을 제한하려면 patterns에서 규칙을 설정하여 이를 달성할 수 있습니다.\n\n```js\n{\n  \"case\": \"kebab\",\n  \"target\": \"**/app/**\",\n  \"patterns\": \"^(page|layout|loading|error|not-found|route|template).tsx$\"\n}\n```\n\n# 훅 네이밍 규칙\n\n훅 디렉토리 아래에 파일 이름에 use를 추가하세요. use를 포함하면 해당 파일이 훅 로직을 포함한다는 것을 나타내게 됩니다.\n\n\n\n```js\n{\n  \"case\": \"camel\",\n  \"target\": \"**/hooks/**\",\n  \"patterns\": \"^use\"\n}\n```\n\n위는 유효하고 무효한 예제입니다.\n\n```js\n/hooks/useHooks.ts // 유효\n/hooks/hooks.tsx // 무효\n```\n\nProviders 하위 요소에 대해서도 동일한 규칙을 만들 수 있습니다.\n\n\n\n```js\n{\n  \"case\": \"camel\",\n  \"target\": \"**/providers/**\",\n  \"patterns\": \"^[a-zA-Z]*Provider\"\n}\n```\n\n# 요약\n\n마지막으로, 파일 네이밍 규칙에 대한 ESLint 규칙을 구현하면 프로젝트의 가독성, 유지보수성 및 깨끗함이 향상됩니다. 프론트엔드 개발에서 여러 암시적 네이밍 규칙이 존재하므로 eslint-plugin-validate-filename을 사용하여 규칙을 수립하는 것이 좋습니다.\n\n피드백과 이슈를 제공해 주시면 감사하겠습니다.\n\n\n\n최종 설정\n\n```js\n{\n  \"plugins\": [\"validate-filename\"],\n  \"rules\": {\n    \"validate-filename/naming-rules\": [\n      \"error\",\n      {\n        \"rules\": [\n          {\n            \"case\": \"pascal\",\n            \"target\": \"**/components/**\"\n          },\n          {\n            \"case\": \"kebab\",\n            \"target\": \"**/app/**\",\n            \"patterns\": \"^(page|layout|loading|error|not-found|route|template).tsx$\"\n          },\n          {\n            \"case\": \"camel\",\n            \"target\": \"**/hooks/**\",\n            \"patterns\": \"^use\"\n          },\n          {\n            \"case\": \"camel\",\n            \"target\": \"**/providers/**\",\n            \"patterns\": \"^[a-zA-Z]*Provider\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```","ogImage":{"url":"/assets/img/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules_0.png"},"coverImage":"/assets/img/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules_0.png","tag":["Tech"],"readingTime":4},{"title":"WP Bones 140 출시 완료","description":"","date":"2024-05-12 22:00","slug":"2024-05-12-WPBones140isout","content":"\n\nWP Bones 애호가 여러분, 환영합니다! 최신 버전인 1.4.0이 출시되어 WordPress 개발 환경을 새로운 차원으로 끌어올릴 다양한 흥미로운 기능과 개선 사항이 도입되었습니다. 이 릴리스의 주요 내용을 자세히 살펴보면 WordPress 프로젝트를 구축하고 관리하는 방식을 혁신할 것으로 예상되는 핵심 기능에 대해 알아봅시다.\n\n![이미지](/assets/img/2024-05-12-WPBones140isout_0.png)\n\n## ReactJS 애플리케이션 개발 소개\n\nWP Bones 1.4.0에서 가장 주목할 만한 추가 기능 중 하나는 WordPress 환경 내에서 완전한 ReactJS 애플리케이션을 생성할 수 있는 기능입니다. Material UI 및 React Router Dom과 같은 인기 있는 패키지를 비롯한 다양한 추가 패키지를 지원하여 동적이고 인터랙티브한 웹 애플리케이션을 만들 수 있는 가능성이 이제 끝없이 펼쳐집니다. 경험 많은 React 개발자이든 초보자이든, 이 통합은 프로젝트를 위한 창의적인 가능성의 새로운 영역을 열어줍니다.\n\n\n\n실제로 확인해 보세요\n\n# 향상된 버전 관리\n\n개선된 PHP Bones 버전 명령어로 버전 및 릴리스 관리가 더욱 간단하고 견고해졌습니다. 이 업데이트는 패치 및 사전 릴리스 처리를 최적화하여 작업 흐름을 더욱 원활하게하고 버전 관리 프로세스를 보다 세밀하게 제어할 수 있도록 합니다. 변경사항을 추적하거나 새로운 배포에 대비할 때 이 향상된 기능을 활용하면 개발 주기를 보다 원활하게 만들고 생산성을 높이는 데 큰 도움이 될 것입니다.\n\n문서 자세히 보기\n\n\n\n# 새롭게 갱신된 설명서\n\n이 기능 업그레이드에 추가로, WP Bones 1.4.0은 문서를 크게 개선하여 플랫폼의 기능을 쉽게 활용하고 탐색할 수 있도록 만들었습니다. 새로운 ReactJS 애플리케이션에 대한 섹션은 WordPress 프로젝트에서 React의 힘을 활용하려는 개발자들을 위한 포괄적인 안내서 역할을 합니다. 게다가, 서비스 제공 업체에 대한 개선된 문서는 자세한 통찰과 예제를 제공하여 사용자가 이 핵심 기능을 최대한 활용할 수 있도록 돕습니다.\n\n# 결론\n\nWP Bones 1.4.0의 출시로 WordPress 개발 환경이 영원히 변화했습니다. ReactJS의 통합과 향상된 버전 관리 및 개선된 문서의 결합은 WP Bones를 현대적인 웹 개발을 위한 선도적인 프레임워크로 고착시킵니다. 혁신적인 웹 애플리케이션을 구축하려는 개발자이든 온라인 존재감을 향상시키려는 비즈니스이든, WP Bones 1.4.0은 오늘날의 디지털 생태계에서 성공하기 위해 필요한 도구와 자원을 제공합니다.\n\n\n\n포럼에 참여해주세요\n\nWP Bones 1.4.0으로 업그레이드하고 워드프레스 프로젝트에 대한 가능성의 세계를 열어보세요. 혁신과 다양성이 만나는 곳, WP Bones로 웹 개발의 미래를 받아들이세요.\n\nWP Bones와 함께 워드프레스 개발 여정을 최대로 이용하는 방법에 대한 업데이트, 자습서 및 통찰력을 기대해주세요. 즐거운 코딩하세요!\n\nWP Bones를 읽어주셔서 감사합니다! 새 게시물을 받으려면 무료로 구독하고 제 작업을 지원해주세요.\n\n\n\n구독 완료\n\n한 가지 더...\n\nhttps://twitter.com/wpbonesx/","ogImage":{"url":"/assets/img/2024-05-12-WPBones140isout_0.png"},"coverImage":"/assets/img/2024-05-12-WPBones140isout_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트에서 REST API 인터셉터 사용하기","description":"","date":"2024-05-12 21:59","slug":"2024-05-12-RESTAPIInterceptorsinReact","content":"\n\n![이미지](/assets/img/2024-05-12-RESTAPIInterceptorsinReact_0.png)\n\n리액트는 프론트엔드 자바스크립트 라이브러리로 잘 알려져 있어요. 리액트의 주요 책임은 웹 애플리케이션의 사용자 인터페이스(UI)를 개발하는 것이에요. 애플리케이션의 UI 구성 요소와 상태를 관리할 때, 리액트는 외부 소스나 백엔드 시스템과 상호 작용하기 위해 API(응용 프로그램 프로그래밍 인터페이스)에 의존해요. API는 서버에서 데이터를 가져오는, 사용자 상호 작용에 기반한 UI 업데이트, 인증, 권한 부여, 그리고 데이터 조작과 같은 다양한 기능을 다룰 때 핵심적인 역할을 합니다.\n\n리액트에서의 API 사용 예시:\n\n- 데이터 가져오기: 리액트 컴포넌트들은 데이터베이스나 제3자 서비스와 같은 외부 소스로부터 데이터를 가져오기 위해 API 요청을 합니다.\n- 서버 통신: API는 프론트엔드가 서버와 상호 작용할 수 있는 표준화된 방법을 제공하여, 폼 제출, 데이터 업데이트, 정보 검색 등의 작업을 수행할 때 사용돼요.\n- 상태 관리: API는 리액트 컴포넌트가 서버로부터 상태를 업데이트하거나 검색할 수 있도록 요청을 보낼 수 있게 하여 상태 관리를 용이하게 해줍니다.\n- 인증과 권한 부여: API는 리액트 컴포넌트가 로그인, 등록, 권한 부여 프로세스를 다루기 위해 인증 서버와 통신할 수 있도록 지원해줘요.\n- 제3자 통합: API를 통해 제3자 서비스와 통합하고, 소셜 미디어 공유, 결제 처리, 외부 데이터 소스 접근과 같은 기능들을 사용할 수 있게 됩니다.\n\n\n\n가능한 접근 방법 중에서 리액트 애플리케이션에서 REST API를 소비하는 두 가지 인기있는 방법은 액시오스(Axios) (프로미스 기반 HTTP 클라이언트)와 페치 API(Fetch API) (브라우저에 내장된 웹 API)입니다. 이 글에서는 액시오스와 페치 API에 대한 인터셉터를 어떻게 구현할 수 있는지에 대해 논의해보겠습니다.\n\n인터셉터는 리액트 자체에서 제공하는 기능은 아니지만, 주로 액시오스나 페치 API와 같은 라이브러리와 함께 사용됩니다. 우리는 다음과 같은 이유로 인해 리액트에서 인터셉터가 필요합니다.\n\n- 중앙화된 요청 처리: 개발자가 전역 요청 핸들러를 정의하여 나가는 HTTP 요청을 가로채는 방법을 제공합니다. 이 접근 방식은 헤더 추가, 로깅, 오류 처리를 여러 요청에 일관되게 적용할 때 유용합니다.\n- 전역 오류 처리: 응답 인터셉터를 정의함으로써 개발자는 서버에서의 오류 응답을 가로채고 사용자에게 오류 메시지를 표시하거나 오류 유형에 따라 특정 작업을 수행하는 등 일관된 오류 처리 로직을 구현할 수 있습니다.\n- 요청 변형: 서버로 보내기 전에 요청 구성 또는 페이로드를 수정하는 것을 가능하게 합니다. 이를 통해 인증 토큰 추가, 요청 데이터 변형, 사용자 지정 요청 로직 적용 등의 작업을 수행할 수 있습니다.\n- 응답 변형: 응답이 호출 코드로 전달되기 전에 응답 데이터나 구성을 수정합니다. 이 기능은 응답 데이터 구문 분석, 데이터 구조 정규화, 특정 응답 조건 처리 등과 같은 작업에 유용합니다.\n- 권한 처리: 리액트 애플리케이션 내에서 권한 로직을 관리하는 데 자주 사용됩니다. 나가는 요청을 가로채어 개발자가 인증 토큰이나 자격 증명을 확인하고 이를 요청 헤더에 추가하여 허가된 요청이 서버로 전송되도록 할 수 있습니다.\n\n이 글의 나머지 부분에서는 가장 인기 있는 REST API 메서드인 액시오스와 페치 API에 인터셉터를 구현하는 방법을 살펴보겠습니다.\n\n\n\n## Axios를 위한 인터셉터 구현\n\nAPI 헤더에 API 키를 추가해야 하는 상황이라고 가정해봅시다. 인터셉터를 사용하여 이를 어떻게 처리할 수 있는지 알아봅시다.\n\n이를 위해 axiosRequestInterceptor라는 인터셉터를 만들었는데, 이는 axios API에 API 키를 추가합니다. 이는 일종의 공통 함수이므로 모든 REST 엔드포인트에서 재사용할 수 있습니다.\n\n```js\nimport axios from \"axios\";\n\nexport const axiosRequestInterceptor = (baseEndPoint, apiKey) => {\n  const api = axios.create({\n    baseURL: baseEndPoint, // API의 기본 URL\n  });\n\n  api.interceptors.request.use(\n    (config) => {\n      // 만약 API 키를 사용한다면\n      if (apiKey) {\n        config.headers[\"x-api-key\"] = apiKey;\n      }\n      // 만약 Bearer 토큰을 사용한다면\n      // config.headers.Authorization = `Bearer ${apiKey}`;\n\n      return config;\n    },\n    (error) => {\n      return Promise.reject(error);\n    }\n  );\n\n  return api;\n};\n```\n\n\n\n헤더에 대한 API 키 이외에도 인터셉터를 사용하여 Axios 요청에 대한 타임아웃 및 콘텐츠 유형과 같은 다양한 추가 사항을 할 수 있습니다. \n\n요청 뿐만 아니라 axios.interceptors.response를 사용하여 Rest 엔드포인트의 응답에 대한 인터셉터를 정의할 수도 있습니다. 자세한 내용은 Axios 문서를 참조해주세요.\n\n## Fetch API Intercepters\n\nFetch API에 대한 인터셉터를 구현하는 두 가지 방법이 있습니다.\n\n\n\n- Monkey patching 방법 사용\r\n- fetch-intercept 라이브러리 사용\r\n\r\nMonkey patching 방법을 사용하여 Fetch API 인터셉터 구현하기\r\n\r\nMonkey patching은 프로그래밍에서 사용되는 기술로, 기존 코드나 기능을 수정하는 것을 의미합니다. Fetch API에 대한 인터셉터를 구현할 때 monkey patching은 fetch()와 같은 Fetch API 메서드의 동작을 업데이트하여 인터셉터를 삽입하고 사용자 정의 기능을 추가하는 것을 의미합니다.\r\n\r\n다음은 Monkey patching 방법을 사용하여 엔드포인트에 API 토큰을 헤더에 추가하는 방법을 나타냅니다.\n\n\n\n```js\n익스포트된 상수 fetchAPIRequestInterceptor을 사용하여 Fetch API 인터셉터를 설정합니다. endPoint, apiKey 및 config를 매개변수로 받습니다. \n\nexport const fetchAPIRequestInterceptor  = async (endPoint, apiKey, config) => {\n    const { fetch: originalFetch } = window;\n    window.fetch =  async (...args) => {\n        //setting the api token for the header\n        config.headers = config.headers || {};\n        config.headers[\"x-api-key\"] = apiKey;\n        config.method = 'GET';\n        try {\n            const response = await originalFetch(endPoint, config);\n            return response;\n        } catch (error) {\n            console.error('Error fetching data:', error);\n            throw error;\n        }\n    };  \n}\n\nfetch-intercept npm 라이브러리를 사용한 Fetch API 인터셉터입니다.\n\n먼저, 아래 명령어를 사용하여 npm 라이브러리를 설치해야 합니다.\n\nnpm i fetch-intercept\n\n\n\n인터셉터는 Fetch API 호출을 위해 인터셉터를 등록할 수 있는 register 메서드를 사용하여 정의할 수 있습니다. 이는 request, requestError, response, responseError 콜백을 포함하는 객체를 가지고 있습니다. 여기서 register 메서드는 인터셉터를 등록할 때 사용하는 unregister 메서드를 반환합니다. 필요하지 않을 때 인터셉터를 등록 해제할 수 있습니다. 아래는 인터셉터 구현을 나타냅니다.\n\nimport * as fetchIntercept from 'fetch-intercept';\n\nexport const fetchInterceptRequestInterceptor  = async (endPoint, apiKey) => {\n    const unregister = fetchIntercept.register({\n        request: function (url, config) {\n            config = { ...config };\n            const modifiedUrl = endPoint;\n            config.headers = config.headers || {};\n\n            // API 토큰 설정\n            return [modifiedUrl, config];\n        },\n      \n        requestError: function (error) {\n            return Promise.reject(error);\n        },\n      \n        response: function (response) {\n            return response;\n        },\n      \n        responseError: function (error) {\n            return Promise.reject(error);\n        },\n      }); \n}\n\n## 요약\n\n인터셉터는 응용 프로그램에서 요청이나 응답을 가로채고 필요에 따라 수정할 수 있는 함수 또는 미들웨어입니다. 이를 통해 인증, 로깅 또는 오류 처리와 같은 일반적인 작업을 중앙 처리할 수 있습니다. React 컨텍스트에서는 Axios와 Fetch API 모두를 위해 인터셉터를 정의할 수 있습니다. 본문에서는 Axios 및 Fetch API에 대한 인터셉터를 어떻게 구현하는지 설명합니다.\n\n\n\n내 Git 저장소에서 구현 세부사항을 참조하세요.","ogImage":{"url":"/assets/img/2024-05-12-RESTAPIInterceptorsinReact_0.png"},"coverImage":"/assets/img/2024-05-12-RESTAPIInterceptorsinReact_0.png","tag":["Tech"],"readingTime":6},{"title":"댓글, 모델, 그리고 사용자들- 어머나 개별 사용자를 위한 풀 스택 기능 생성하기","description":"","date":"2024-05-12 21:57","slug":"2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers","content":"\n\n<img src=\"/assets/img/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers_0.png\" />\n\n프론트엔드와 백엔드 프로그래밍에 대해 충분히 배웠다면, 풀스택 애플리케이션을 구축한 후에 할 일은 아마도 다른 사용자가 응용 프로그램에 로그인하고 로그인한 사용자에 맞게 사이트의 특정 세부 정보를 제공할 수 있도록 하는 것일 것입니다. 이제 데이터베이스와 모델에 대한 지식을 활용하여 그 모든 정보를 저장할 데이터베이스(또는 여러 개)를 만들 수 있습니다. 지금, 사용자의 로그인 유효성 검사 및 암호화에 필요한 모든 사항에 대해 다루지는 않겠습니다(그것은 다른 블로그 게시물이 되겠죠), 하지만 사용자가 댓글을 달거나 평가할 수 있도록 허용하는 백엔드 구조 및 해당 구조를 클라이언트 측에서 사용하여 현재 사용자에 대한 특정 정보를 렌더링하는 방법에 대해서 이야기해보려고 합니다.\n\n# 모델\n\n아래에는 우리의 User 클래스에 대한 상당히 기본적인 모델과 Flask/SQLAlchemy를 통해 생성될 데이터베이스 테이블이 있으며, 그 관계들이 포함되어 있습니다.\n\n\n\n```js\nfrom sqlalchemy_serializer를 SerializerMixin에 import합니다.\nSQLAlchemy.ext.associationproxy에서 association_proxy도 import합니다.\n\nconfig에서 db를 import하고 User 클래스를 만듭니다. User 클래스는 db.Model과 SerializerMixin을 상속받습니다.\n아래는 User 클래스의 일부분입니다.\n\n__tablename__ = 'users'\nid = db.Column(db.Integer, primary_key=True)\nusername = db.Column(db.String)\n_password_hash = db.Column(db.String)\n\ngame_statistics = db.relationship('GameStatistics', back_populates='user', cascade='all, delete-orphan')\ngames = association_proxy('game_statistics', 'game')\n\nserialize_rules = ('-game_statistics',)\n\n사용자의 사용자 이름과 비밀번호를 저장하고 다른 데이터베이스와의 관계를 만들어 추가 정보를 보유하려고 합니다. 게임 등급 애플리케이션을 개발하고 사용자가 게임을 \"좋아요\"하거나 게임에 댓글/평가를 남기거나 게임을 위시리스트에 추가할 수 있도록 했으며, 각각의 기능은 특정 게임에 관한 것이어야 합니다. 이 애플리케이션에는 많은 게임이 있기 때문에 사용자와 게임 사이의 다대다 관계를 만들기 위해 사용자당 게임별로 좋아요, 위시리스트, 댓글 및 등급에 관한 모든 정보를 보유할 다른 데이터베이스가 필요합니다.\n\n아래에는 다른 두 클래스 (그리고 이에 따른 Flask와 SQLAlchemy를 통한 테이블)의 간소화된 버전이 있습니다.\n\nclass Game(db.Model, SerializerMixin):\n    __tablename__ = 'games'\n\n    위의 User 클래스와 유사한 형태입니다. 이하 생략.\n\nclass GameStatistics(db.Model, SerializerMixin):\n    __tablename__ = 'gameStatistics'\n\n    위의 User 클래스와 유사한 형태입니다. 이하 생략.\n```\n\n\n\n이제 사용자 정보를 모두 보유한 데이터베이스, 게임에 대한 모든 세부 정보를 보유한 데이터베이스, 이 둘 사이에서 중개 역할을 하는 세 번째 테이블이 있습니다. 외래 키를 사용하여 통계와 게임, 사용자 간의 연관을 볼 수 있습니다. 데이터베이스가 다른 테이블의 열에 연결되어 있는지 알 수 있게 됩니다. 사용자는 많은 게임과 연관을 갖을 수 있고, 게임은 해당 게임에 댓글을 남기거나 즐겨찾기에 추가한 많은 사용자들을 가질 수 있습니다. 이에 대한 데이터를 완전히 새로운 테이블에 보유해야 합니다. 사용자와 게임을 식별하는 새로운 테이블을 생성합니다. 마지막으로 API가 관련 클래스의 모든 세부 정보를 보여줄 수 있도록 SQLAlchemy의 association proxy를 사용하여 관계를 생성합니다.\n\n# 프론트 엔드\n\n이제 스스로 묻고 있을 수 있습니다. \"왜 프론트 엔드로 건너뛰나요? 아직 백엔드 루트를 만들지 않았는데요!\" 맞습니다! 그러나 프론트 엔드에서 필요한 기능이 무엇인지 알 때 백엔드 루트를 만드는 것이 더 쉬울 수 있습니다. 특정 게임에 대한 모든 댓글이 해당 게임 페이지에 나타나게 하려면? 사용자가 지금까지 한 모든 댓글이 프로필 페이지에 나타나야 하나요? 사용자가 즐겨찾기한 것을 어디에서 렌더링하고 있나요? 사용자가 게임을 즐겨찾기했는지 여부는 게임 페이지에 나타나길 원하시나요? 다른 곳? 위시리스트도 어떻게 하나요? 동적으로 렌더링하면서 즐겨찾기한 경우 데이터베이스를 변경하고 싶으실 텐데요?\n\n휴우! 프론트 엔드의 모든 렌더링과 기능을 계획하는 일은 많은 노력이 필요할 수 있지만, API를 위한 백엔드 루트를 만드는 것은 훨씬 간단해집니다. 위에서 나열된 옵션 중 일부만 가져와서 백엔드에 필요한 루트에 대해 이야기해보겠습니다:\n\n\n\n- 게임 상세 페이지에 게임의 모든 코멘트를 나열합니다.\n- 즐겨찾기한 게임을 즐겨찾기 페이지에서 나열합니다.\n- 위시리스트 버튼을 동적으로 렌더링하고 데이터베이스를 변경합니다.\n\n# 코멘트\n\n게임 상세 페이지에서 단일 게임의 코멘트만 렌더링하는 기본적인 방법을 살펴봅시다. 프론트엔드는 다음과 같이 보일 수 있습니다. 프론트 엔드 라우트에서 사용되는 게임 ID에 대해 모든 게임 통계를 얻기 위해 백엔드 URL로 fetch 요청을 수행하고, React State를 응답으로 설정한 다음 해당 상태를 사용하여 목록을 반복하고 각 반환된 게임 통계에 대해 코멘트, 평점, 사용자를 표시하는 Review Card를 만들어야 합니다.\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { useParams, Link } from 'react-router-dom';\nimport GameReviewCard from '../components/GameReviewCard';\n\nfunction GameDetail({ user }) {\n  // URL 파라미터에서 게임 ID를 가져옵니다.\n  const { id } = useParams();\n  // 게임 통계를 저장할 상태\n  const [gameStats, setGameStats] = useState([]);\n\n  useEffect(() => {\n       fetch(back_end_url) //아직 이 변수를 정의하지 않았음을 참고해 주세요. \n      .then((res) => res.json())\n      .then((data) => setGameStats(data))\n      .catch((error) => console.error(error));\n  return (\n    <Box sx={ mt: 2 }>\n            {gameStats.length > 0 ? (\n              gameStats.map((stat) => (\n                <GameReviewCard key={stat.game_stats_id} gameStats={stat} />\n              ))\n            ) : (\n              <Typography>리뷰가 없습니다.</Typography>\n            )}\n          </Box>\n  );\r\n```\n\n\n\n지금, 이 back-end route를 살펴보겠어요. 여러분이 fetch 문에서 `back_end_url`로 넣을 내용은 다음과 같습니다:\n\n```js\nclass GameStatsByGameID(Resource):\n    # 이는 특정 게임에 대한 모든 댓글과 평가를 가져와 개별 게임 페이지에 표시합니다\n    def get(self, game_id): \n        gamestats = [gamestat.to_dict() for gamestat in GameStatistics.query.filter(GameStatistics.game_id == game_id, GameStatistics.comments != None).all()]\n        if gamestats:\n            return make_response(gamestats)\n        else:\n            return make_response({'error': ['아직 리뷰가 없습니다']})\n\napi.add_resource(GameStatsByGameID, '/game-statistic/<int:game_id>')\n```\n\n이 route의 가장 중요한 부분은 우리가 하는 데이터베이스 쿼리입니다. 게임 ID(우리는 front-end route로부터 가져온 것)를 전달하고, 그 ID를 사용하여 전체 게임 통계 데이터베이스를 훑어서 해당 특정 게임과 관련된 모든 인스턴스를 추출합니다. filter 내부의 쿼리의 두 번째 부분은 실제로 존재하는 댓글만 추출하도록 하는 것입니다(기억하세요, 우리는 게임 통계 테이블에 Favorite와 Wishlist와 같은 것들도 저장하지만 페이지의 댓글 섹션에 렌더링되지 않길 원합니다!). 이제 반환된 결과를 사용하여 댓글/리뷰 카드를 렌더링할 수 있습니다! 그리고 front-end에서는 useParams에서 game_id를 가져오기 위해 fetch 요청에서 `back_end_url`을 `/game-statistic/$'id'`로 설정할 수 있어요.\n\n# 즐겨찾기\n\n\n\n즐겨찾기 기능도 비슷한 방식으로 작동하지만, 사용자 ID와 특정 게임 ID가 아닌 사용자 ID와 관련된 게임 통계를 쿼리하는 새로운 백앤드 루트가 필요합니다. 또한 즐겨찾기한 게임 통계만 쿼리 결과로 포함하고 싶습니다. 그래서 우리의 프런트엔드는 다음과 같이 간단하게 보일 수 있습니다:\n\n```js\nimport React, { useState, useEffect, useParams } from 'react';\nimport FavoritesGameCard from '@/components/FavoritesGameCard.jsx';\n\nfunction Favorites({ user }) {\n  const [games, setGames] = useState([]);\n  const [deleteGame, setDeleteGame] = useState(false);\n\n  useEffect(() => {\n    if (user && user.id) {\n      fetch(`http://localhost:8080/favorites/${user.id}`)\n        .then((res) => {\n          if (res.ok) {\n            return res.json();\n          } else {\n            return console.error(\"GET 요청 중에 문제가 발생했습니다\");\n          }\n        })\n        .then((gameData) => {\n          setGames(gameData);\n        });\n    }\n  }, [user, deleteGame]);\n\n  const handleUnfavorite = (gameId) => {\n    setGames(games.filter((game) => game.id !== gameId));\n    setDeleteGame((prev) => !prev);\n  };\n\n  return (\n    <div>\n      {!games ? (\n        <div className=\"no-favorites-message\">\n          <h2>아직 즐겨찾기한 게임이 없습니다</h2>\n        </div>\n      ) : (\n        <>\n          <div className=\"game-cards-container\">\n            {games.map((game) => (\n              <FavoritesGameCard key={game.id} game={game} user={user} handleUnfavorite={handleUnfavorite} />\n            )}\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default Favorites;\n```\n\n새로운 백앤드 루트와 ID를 백앤드로 보내는 새로운 방법을 알 수 있을 것입니다. 우리는 현재 로그인한 사용자를 React 상태에 유지하여 해당 사용자에 대한 정보가 필요한 컴포넌트에 전달할 수 있습니다 (이 경우에는 ID가 필요합니다). 백앤드 루트와 쿼리는 다음과 같이 구성되어 있습니다:\n\n```js\nclass FavoritesByUser(Resource):\n    def get(self, user_id):\n        favorites = [gamestat.game.to_dict() for gamestat in GameStatistics.query.filter(GameStatistics.user_id==user_id, GameStatistics.favorited==True).all()]\n        if favorites:\n            return make_response(favorites)\n        else:\n            return make_response({'error': ['아직 즐겨찾기한 게임이 없습니다']})\n        \napi.add_resource(FavoritesByUser, '/favorites/<int:user_id>')\n```\n\n\n\n알았어요! 이제, 즐겨찾기 및 위시리스트 관련 기능에 대해 더 이야기해보겠어요.\n\n# 위시리스트 버튼\n\n게임을 즐겨찾기 하는 방법은 React State를 활용하는 위시리스트 버튼을 구현하는 것으로 결정했어요. 이 버튼은 부모 컴포넌트로부터 전달된 prop과 이 컴포넌트 자체의 네이티브 state를 활용하여 사용자와 게임에 관련된 게임 통계를 확인하고 이에 맞게 렌더링하는 기능을 제공해요. 부모 컴포넌트로부터 넘어온 gameStatId 상태를 사용하여 데이터베이스로 fetch 요청을 보내 현재 로그인한 사용자의 ID(기억해요, 사용자 정보는 이미 state에 저장되어 있어요)와 현재 보고 있는 게임 상세 페이지의 게임 ID에 해당하는 게임 통계의 인스턴스가 있는지 확인해요. 만약 해당 인스턴스가 있다면 gameStateId를 업데이트하고 해당 상태를 버튼으로 전달해요.\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport Button from '@mui/material/Button'; // Material-UI에서 Button 가져오기\nimport StarIcon from '@mui/icons-material/Star'; // Material-UI에서 즐겨찾기 아이콘 가져오기\nimport StarBorderIcon from '@mui/icons-material/StarBorder'; // Material-UI에서 즐겨찾기 해제 아이콘 가져오기\n\n// gameId와 userId를 prop으로 전달받는 함수형 컴포넌트 WishlistButton 정의\nfunction WishlistButton({ gameId, userId, gameStatId, updateGameStatId}) {\n  \n  // 게임을 위시리스트에 추가했는지 추적하는 상태\n  const [isWishlisted, setIsWishlisted] = useState(false);\n\n  // 게임 통계를 가져오는 useEffect 훅, gameId 또는 userId가 변경될 때 실행\n  useEffect(() => {\n    // 현재 사용자와 게임에 대한 게임 통계 가져오기\n    fetch(`http://localhost:8080/game-statistics/${gameId}/${userId}`)\n      .then((res) => res.json())\n      .then((data) => {\n        // 게임 통계가 있는 경우 상태 업데이트\n        if (data.game_stats_id) {\n          setIsWishlisted(data.wish_listed);\n          updateGameStatId(data.game_stats_id);\n        } else {\n          // 게임 통계가 없는 경우 기본 상태로 설정\n          setIsWishlisted(false);\n          updateGameStatId(null);\n        }\n      });\n  }, [gameId, userId]); // useEffect의 의존성 배열\n\n  // 위시리스트 버튼 클릭 처리 함수\n  const handleWishlist = () => {\n    // 게임 통계 인스턴스가 있는 경우 위시리스트 상태 업데이트\n    if (gameStatId) {\n      fetch(`http://localhost:8080/game-statistics/${gameId}/${userId}`, {\n        method: 'PATCH', // 기존 데이터 업데이트용 PATCH 메소드 사용\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ wish_listed: !isWishlisted }), // 위시리스트 상태 토글\n      })\n        .then((res) => res.json())\n        .then((data) => setIsWishlisted(data.wish_listed)); // 새로운 위시리스트 상태로 상태 업데이트\n    } else {\n      // 게임 통계 인스턴스가 없는 경우 새로운 위시리스트 생성\n      fetch(`http://localhost:8080/game-statistics`, {\n        method: 'POST', // 새 데이터 생성용 POST 메소드 사용\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          user_id: userId,\n          game_id: gameId,\n          wish_listed: true,\n        }),\n      })\n        .then((res) => res.json())\n        .then((data) => {\n          // 새 게임 통계 데이터로 상태 업데이트\n          setIsWishlisted(true);\n          updateGameStatId(data.game_stats_id);\n        });\n    }\n  };\n\n  // 위시리스트 버튼 동적 텍스트 및 아이콘을 기반으로 렌더링\n  return (\n    <div className=\"wishlist-container\">\n      <Button\n        variant=\"contained\"\n        color=\"primary\"\n        startIcon={isWishlisted ? <StarIcon /> : <StarBorderIcon />}\n        onClick={handleWishlist}\n      >\n        {isWishlisted ? '위시리스트에서 제거' : '위시리스트에 추가'}\n      </Button>\n    </div>\n  );\n}\n\nexport default WishlistButton; // 다른 부분에서 사용할 수 있도록 WishlistButton 컴포넌트 내보내기\n```\n\n\n\n만약 해당 인스턴스가 이미 존재한다면(예: 사용자가 이 게임에 댓글을 달았거나 위시리스트에 추가했을 경우), 위시리스트 버튼을 클릭하면 데이터베이스에서 해당 게임 통계를 업데이트하기 위해 서버로 PATCH 요청이 전송됩니다. 아직 인스턴스가 존재하지 않은 경우, POST 요청을 보내고 모든 다른 버튼들(위시리스트 및 댓글 등)의 상태를 업데이트하여 이후 PATCH 요청을 보냅니다. 그런 다음, 확실히 isWishlisted 상태를 사용하여 페이지에서 조건부 렌더링을 수행하여 버튼을 \"위시리스트에서 제거\" 또는 \"위시리스트에 추가\"로 표시하게 됩니다.\n\n사용자와 상호 작용할 때 프론트엔드와 백엔드를 연결하는 몇 가지 방법 중 일부입니다. SerializerMixin 및 직렬화 규칙과 같은 것들을 사용하면 백엔드에서 반환되는 데이터를 더욱 구체적으로 얻을 수 있습니다. 매우 구체적인 라우팅을 만드는 것은 시간이 소모되고 때로는 중복된 느낌을 줄 수 있지만, 데이터베이스에 많은 양의 정보가 저장된 경우 메모리 및 로드 시간을 줄일 수도 있습니다.\n\n좋은 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers_0.png"},"coverImage":"/assets/img/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers_0.png","tag":["Tech"],"readingTime":11},{"title":"리액트, 리액트 네이티브 및 노드js에서의 암호화","description":"","date":"2024-05-12 21:56","slug":"2024-05-12-EncryptioninReactReactNativeandNodejs","content":"\n\n암호화에 대한 올바른 모듈을 선택해주세요\n\n# 소개\n\n최근 프로젝트에서 만났던 암호화 관련 문제를 공유하고자 합니다. 먼저 사용된 암호화 방법론을 설명하고 어려움에 대해 깊이 있는 이야기로 파헤쳐보겠습니다. 웹 및 모바일 애플리케이션을 개발할 때 고려해야할 중요한 점은 호환성입니다. 기능을 설계하거나 모듈을 선택하거나 솔루션을 고려할 때 전체적인 접근 방식이 있어야 합니다. 모든 플랫폼에서 작동해야 합니다.\n\n# 암호화 아키텍처\n\n\n\n- 프론트엔드(React, React Native)에서 AES 암호화 키 생성하기\n- 백엔드(Node.js)에서 RSA 공개 및 개인 키 생성하기\n- RSA 공개 키를 프론트엔드와 공유하기\n- AES 키를 RSA 공개 키로 암호화하기\n- 보낼 데이터를 AES 키로 암호화하기\n- 암호화된 데이터와 암호화된 AES 키를 백엔드로 보내기\n- 백엔드에서 RSA 개인 키를 사용하여 암호화된 AES 키를 해독하여 AES 키를 검색하기\n- 검색된 AES 키를 사용하여 암호화된 요청 데이터를 해독하기.\n\n백엔드는 비슷한 프로세스를 따라 프론트엔드로 응답을 돌려보낼 것입니다. 키를 생성하고 암호화하는데 사용된 암호화 기술 전체 과정에 대해 설명하지는 않겠습니다. 다른 글에서 다룰 수도 있겠지만, 이제는 문제에 집중해보겠습니다.\n\n![Encryption in React, React Native, and Node.js](/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png)\n\n# 문제\n\n\n\nAES 키를 생성하고 RSA 키를 생성하며 RSA 키를 사용하여 AES 키를 암호화하는 경우, 코어 노드 js 모듈의 일부인 기본 암호화 모듈을 사용할 수 있습니다. React는 내부적으로 노드에 의존성이 있기 때문에 키를 생성하고 암호화하는 데 큰 문제가 없으며 추가 패키지도 필요하지 않습니다. 그러나 React Native의 경우 노드 코어 모듈을 지원하지 않습니다. 따라서 다양한 탐구 끝에 혼자 사용하면 좋지만 암호화를 만들기위해 패키지를 대체하는 것과 관련된 문제가 있는 react-native-rsa-native, crypto-browserify, react-native-fast-crypto, react-native-quick-crypto와 같은 패키지들은 작동하지 않는 것 같습니다.\n\n# 해결책\n\n모든 플랫폼(웹, 모바일 및 백엔드)을 위한 동일한 암호화 기능과 기술을 제공할 수 있는 일반적인 패키지를 검색하는 도중 더욱 신뢰할 수 있고 호환성이 뛰어나며 크기가 작고 인기가 많은 node-forge 패키지를 발견했습니다. 다른 패키지들과 비교했을 때 이 패키지는 모든 암호화 기능, 암호 및 암호화 기술을 갖추고 있어 솔루션을 구현하기 쉽게 만들어 주었습니다.\n\n```js\n// AES 키 생성\n// 클라이언트 측 React 및 React Native\n\nimport forge from 'node-forge';\nexport const generateAesKey = () => {\n  const aesSalt = forge.random.getBytesSync(16);\n  const keyPassPhrase = forge.random.getBytesSync(16);\n  const aesKey = forge.pkcs5.pbkdf2(\n    keyPassPhrase,\n    aesSalt,\n    ENCRYPTION_AES_ENC_KEY_OPTIONS.iterations, // 필요에 따라 사용\n    ENCRYPTION_AES_ENC_KEY_OPTIONS.keySize, // 필요에 따라 사용\n  );\n  return aesKey;\n};\n```\n\n\n\n```js\n// RSA 공개 및 개인 키 생성\n// 서버 측 Node.js\nconst forge = require('node-forge');\nconst rsaKeyPair = forge.pki.rsa.generateKeyPair({ bits: BITS }); // 필요에 따라 사용\nconst publicKeyPem = forge.pki.publicKeyToPem(rsaKeyPair.publicKey);\nconst privateKeyPem = forge.pki.privateKeyToPem(rsaKeyPair.privateKey);\n```\n\n```js\n// RSA 공개 키를 사용하여 AES 키 암호화\n// React 및 React Native\n\nimport forge from 'node-forge';\nexport const encryptAesKey = (receivedpublicKeyPem: string, aesKey: string) => {\n  try {\n    const publicKey = forge.pki.publicKeyFromPem(receivedpublicKeyPem);\n    const encryptedAesKey = publicKey.encrypt(aesKey, 'RSA-OAEP');\n    return forge.util.encode64(encryptedAesKey);\n  } catch (error) {\n    console.error('암호화 오류:', error);\n    throw error;\n  }\n};\n```\n\n```js\n// RSA 개인 키를 사용하여 암호화된 AES 키 복호화\nconst decryptedAesKey = rsaKeyPair.privateKey.decrypt(forge.util.decode64(encryptedAesKey), 'RSA-OAEP');\n```\n\n요청 데이터를 AES 키를 사용하여 암호화하고 백엔드에서 데이터를 복호화하기 위해 제 요구에 따라 다른 모듈을 사용했습니다 (React에는 crypto-js, React Native에는 react-native-crypto-js). 여전히 이 프로세스에 node-forge를 사용할 수 있습니다.\n\n\n\n\n읽어 주셔서 감사합니다! 👋","ogImage":{"url":"/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png"},"coverImage":"/assets/img/2024-05-12-EncryptioninReactReactNativeandNodejs_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 애플리케이션 모듈화하기","description":"","date":"2024-05-12 21:53","slug":"2024-05-12-ModularizingReactApplication","content":"\n\n리액트 애플리케이션에서는 뷰 레이어 이상의 것을 사용하는 게 일반적입니다. 라우터, 로컬 저장소, 네트워크 요청, 보안 기능 등이 필요할 수 있습니다. 이러한 문제들을 모두 뷰 컴포넌트나 훅 안에서 처리하려고 하면 혼란을 초래하고 코드를 이해하기 어렵게 만들 수 있습니다.\n\n컴포넌트에 모든 것을 쑤셔 넣기보다는 각각 다른 파일이나 폴더로 관심사를 분리하는 것이 더 좋습니다. 이런 식으로 코드를 구성하면 응용 프로그램을 이해하는 데 필요한 정신적 부담을 줄일 수 있습니다. 한 번에 한 가지에 집중할 수 있어서 유지보수와 새로운 기능 추가가 더 쉬워집니다.\n\n하나의 접근 방법은 뷰-모델-데이터 레이어링 개념을 사용하는 것입니다. 이는 코드를 세 개의 레이어로 분리하는 것을 포함합니다. 뷰 레이어(리액트 컴포넌트), 모델 레이어(비즈니스 로직 및 계산), 데이터 레이어(네트워크 요청, 로컬 저장소 등)로 구분합니다. 이를 통해 응용 프로그램의 각 측면을 독립적으로 생각할 수 있어서 집중력을 높이고 코드를 더 모듈화하고 유지보수하기 쉽게 만들 수 있습니다.\n\n이러한 원칙은 새로운 것이 아니며 웹 시대 이전의 대형 GUI 애플리케이션에서 사용되었습니다. 이러한 확립된 패턴을 리액트 애플리케이션에 적용함으로써 더 조직적이고 관리 가능한 코드베이스를 만들 수 있습니다.\n\n\n\n# React 어플리케이션의 발전\n\nReact 어플리케이션이 성장함에 따라 초기에는 모든 로직을 컴포넌트 내부에 넣을 것입니다. 그러나 코드가 추가될수록 유지보수하기 어려운 혼돈스러운 상황이 될 수 있습니다. 이를 피하려면 확장 가능한 프런트엔드 앱을 구축하기 위해 다음 단계를 따르세요:\n\n1. 간단하게 시작하기: 처음에는 React 컴포넌트 내에 모든 로직이 들어갈 수 있으며, 동적 요소가 포함된 HTML처럼 보일 수 있습니다.\n\n2. 코드 구조화: 앱이 확장됨에 따라 코드를 뷰, 모델 및 데이터와 같은 별도의 레이어로 구성합니다. 이렇게 함으로써 복잡성을 줄이고 유지보수를 쉽게 만듭니다.\n\n\n\n모듈화: 코드를 더 작고 재사용 가능한 모듈로 분할하여 앱 전반에 걸쳐 관리하고 재사용하기 쉽게 합니다.\n\n패턴 수립: 코드 구조, 명명 및 폴더 구성을 위한 명확한 패턴과 규칙을 정하여 일관성과 명확성을 유지합니다.\n\n수립된 패턴 활용: 검증된 디자인 패턴과 업계 모베스트 프랙티스를 활용하여 앱 아키텍처를 이끄는 우량한 방법을 찾아 공통된 함정을 피합니다.\n\n문서화: 코드베이스를 효과적으로 문서화하여 개발자를 안내하고 모든 사람이 앱의 구조와 설계 결정을 이해할 수 있도록 합니다.\n\n\n\n## 단일 구성 요소 애플리케이션\n\n![이미지](/assets/img/2024-05-12-ModularizingReactApplication_0.png)\n\n## 다중 구성 요소 애플리케이션\n\n복잡한 구성 요소를 작은 구성 요소로 분할하는 것은 좋은 아이디어입니다. 이는 최종 HTML의 구조를 반영하며 한 번에 한 부분에 초점을 맞출 수 있게 해줍니다.\n\n\n\n![ModularizingReactApplication_1](/assets/img/2024-05-12-ModularizingReactApplication_1.png)\n\n앱이 커질수록 단순히 UI에 관한 것만이 아닙니다. 네트워크 요청을 처리하고 UI용 데이터를 형태로 변경하며, 서버에 대한 데이터를 수집해야 할 것입니다. 모든 것을 컴포넌트에 넣는 건 이상하게 느껴질 수 있습니다. 사용자가 보는 것뿐만이 아닙니다. 게다가 어떤 컴포넌트는 너무 많은 내부 상태를 유지해야 합니다.\n\n## 훅을 이용한 상태 관리\n\n이러한 논리를 서로 다른 위치에 두는 것이 더 낫습니다. React에서는 이렇게 할 수 있도록 여러분의 훅을 만들 수 있습니다. 훅은 상태를 공유하고 상태가 변경될 때의 로직을 공유하는 데 도움이 됩니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-ModularizingReactApplication_2.png\" />\n\n하나의 컴포넌트를 여러 부분으로 나누었군요. 몇 개의 간단한 디스플레이 전용 컴포넌트와 컴포넌트 상태를 다루는 재사용 가능한 훅이 있습니다.\n\n하지만 때로는 훅 안에 상태를 관리하는 것이 아닌 계산을 하는 로직이 있다면서요.\n\n## 비즈니스 모델이 나타났습니다\n\n\n\n![모듈화된 React 애플리케이션의 이미지](/assets/img/2024-05-12-ModularizingReactApplication_3.png)\n\n이 논리를 다른 곳으로 옮기면 정말 도움이 될 수 있다는 것을 깨달았군요. 이것을 분리함으로써, 논리가 더 집중되고 특정 뷰에 의존하지 않습니다. 따라서 데이터 매핑 및 널 값을 확인하는 간단한 객체를 만들기 시작합니다. 이러한 객체를 더 많이 만들면서 상속 또는 다형성을 사용하면 모든 것이 더 깔끔해집니다. 다른 영역에서 디자인 패턴을 적용하여 프론트엔드 애플리케이션을 더 깨끗하고 조직화된 상태로 만들려고 합니다.\n\n# 계층화된 프론트엔드 애플리케이션\n\n애플리케이션이 성장함에 따라 일부 패턴에 주목할 때가 옵니다. 사용자 인터페이스와 관련이 없고 데이터가 어디에서 왔는지 신경 쓰지 않는 객체들이 있습니다. 이러한 객체들을 다른 계층으로 분리하려고 합니다. 각 계층을 자세히 설명해 드릴게요: 표현(Presentation), 도메인(Domain), 그리고 데이터(Data) 계층입니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-ModularizingReactApplication_4.png\" />\n\n위의 개요를 통해 코드를 구조화하는 방법과 다음 단계를 알 수 있습니다. 하지만 접해 보기 전에 고려해야 할 많은 세부 사항이 있습니다.\n\n다음 섹션에서는 실제 프로젝트의 기능을 안내해 드릴 것입니다. 이를 통해 대규모 프론트엔드 응용 프로그램에 유용한 패턴 및 설계 원칙을 보여 드릴 것입니다.\n\n# 예제 프로젝트\n\n\n\n## 결제 기능 구축\n\n먼저 기본적인 온라인 주문 앱으로 시작해 봅시다. 여기서 고객들은 제품을 선택하고 주문에 추가할 수 있습니다. 그리고 나중에 결제 방법을 선택하여 구매를 완료할 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-ModularizingReactApplication_5.png)\n\n알겠어요. 지금은 결제 컴포넌트에 집중해 봅시다. 결제 방법 옵션들은 서버 측에서 구성되어 있어서, 서로 다른 국가의 고객들은 서로 다른 옵션을 볼 수 있습니다. 예를 들어, Apple Pay는 특정 국가에서만 이용 가능할 수 있습니다. 결제 방법용 라디오 버튼은 백엔드로부터의 데이터에 의해 제어됩니다. 만약 결제 방법이 반환되지 않는다면, 아무것도 보여주지 않고 기본값으로 \"현금 결제\"를 가정할 것입니다.\n\n\n\n테이블 태그를 Markdown 형식으로 변경해 보세요.\n\nSetup your mock server\n\n- Install JSON Server\n\n```js\nnpm install -g json-server\n```\n\n2. Create a Mock Data File payment-methods.json\n\n\n\n```json\n{\n  \"paymentMethods\": [\n    { \"name\": \"신용 카드\" },\n    { \"name\": \"PayPal\" },\n    { \"name\": \"Apple Pay\" }\n  ]\n}\n```\n\n3. JSON Server 시작\n\n```js\njson-server --watch payment-methods.json --port 3001\n```\n\n결제 과정은 건너뛰고 Payment 컴포넌트만 살펴봄으로써 간단하게 유지할 것입니다. 여기에 코드가 어떻게 나올지에 대한 기본적인 예시가 있습니다:\n\n\n\n```js\nsrc/Payment.tsx…\n\n  export const Payment = ({ amount }: { amount: number }) => {\n    const [paymentMethods, setPaymentMethods] = useState<LocalPaymentMethod[]>(\n      []\n    );\n  \n    useEffect(() => {\n      const fetchPaymentMethods = async () => {\n        const url = \"http://localhost:3001/paymentMethods\";\n  \n        const response = await fetch(url);\n        const methods: RemotePaymentMethod[] = await response.json();\n  \n        if (methods.length > 0) {\n          const extended: LocalPaymentMethod[] = methods.map((method) => ({\n            provider: method.name,\n            label: `Pay with ${method.name}`,\n          }));\n          extended.push({ provider: \"cash\", label: \"Pay in cash\" });\n          setPaymentMethods(extended);\n        } else {\n          setPaymentMethods([]);\n        }\n      };\n  \n      fetchPaymentMethods();\n    }, []);\n  \n    return (\n      <div>\n        <h3>Payment</h3>\n        <div>\n          {paymentMethods.map((method) => (\n            <label key={method.provider}>\n              <input\n                type=\"radio\"\n                name=\"payment\"\n                value={method.provider}\n                defaultChecked={method.provider === \"cash\"}\n              />\n              <span>{method.label}</span>\n            </label>\n          ))}\n        </div>\n        <button>${amount}</button>\n      </div>\n    );\n  };\n```\n\n이 코드는 꽤 일반적이며, 초보자를 위한 튜토리얼에서 가져온 것일 것입니다. 그렇게 나쁘지 않지만, 서로 다른 것들을 한 곳에 섞어서 이해하기 어렵게 만들었습니다.\n\n## 초기 구현의 문제점\n\n원래 코드의 문제점은 주로 Payment 컴포넌트가 너무 많은 일을 하고 있다는 것입니다. 다양한 작업을 처리하므로 코드를 이해하기 어렵습니다. 변경을 하려면 네트워크 요청을 시작하는 방법, 컴포넌트용 데이터 형식을 지정하는 방법, 각 결제 방법을 표시하는 방법, 그리고 Payment 컴포넌트 자체의 렌더링 로직을 이해해야 합니다.\n\n\n\n지금은 간단한 예제에서는 큰 문제가 되지는 않아요. 하지만 코드가 커지고 복잡해지면 리팩토링이 필요해질 거에요.\n\n뷰 코드와 비뷰 코드를 서로 다른 위치에 분리하는 것이 좋은 생각이죠. 뷰는 비뷰 로직보다 자주 변경되곤 해요. 이를 분리함으로써 특정 모듈에 집중하여 새로운 기능을 구현하기가 더 쉬워집니다.\n\n## 뷰 코드와 비뷰 코드의 분리\n\n뷰 코드와 비뷰 코드를 분리해봅시다. React에서는 사용자 정의 훅을 사용하여 컴포넌트의 상태를 관리하면서 컴포넌트 자체는 대부분 상태가 없도록 유지할 수 있어요. Extract Function 기법을 사용하여 usePaymentMethods라는 함수를 생성할 거에요. \"use\" 접두사는 React에서 해당 함수가 상태를 처리하는 훅이라는 것을 나타내는 관례입니다.\n\n\n\n표 태그를 마크다운 형식으로 변경하십시오.\n\n\n\n뷰를 더 나눠서 하위 구성 요소를 추출해 보는 건 어때요? 컴포넌트를 순수 함수로 만들면 (입력에 따라 결과가 예측 가능한) 테스트, 이해 및 재사용에 매우 도움이 될 거예요. 기억하세요, 컴포넌트가 작을수록 재사용될 가능성이 높아집니다.\n\n우리는 \"함수 추출\" 기술을 다시 사용할 수 있어요 (React에서는 컴포넌트를 본질적으로 함수로 취급하기 때문에 \"컴포넌트 추출\"이라고 부를 수도 있어요).\n\n```js\nsrc/Payment.tsx…\n\nconst PaymentMethods = ({\n  paymentMethods,\n}: {\n  paymentMethods: LocalPaymentMethod[];\n}) => (\n  <>\n    {paymentMethods.map((method) => (\n      <label key={method.provider}>\n        <input\n          type=\"radio\"\n          name=\"payment\"\n          value={method.provider}\n          defaultChecked={method.provider === \"cash\"}\n        />\n        <span>{method.label}</span>\n      </label>\n    ))}\n  </>\n);\n```\n\nPayment 컴포넌트는 PaymentMethods를 직접 사용할 수 있으므로 다음과 같이 단순화할 수 있답니다.\n\n\n\nsrc/PaymentComponent.tsx…\n\n```js\nexport const Payment = ({ amount }: { amount: number }) => {\n    const { paymentMethods } = usePaymentMethods();\n\n    return (\n      <div>\n        <h3>결제</h3>\n        <PaymentMethods paymentMethods={paymentMethods} />\n        <button>${amount}</button>\n      </div>\n    );\n  };\n```\n\nPaymentMethods는 상태를 가지지 않는 순수 함수(순수 컴포넌트)입니다. 기본적으로 문자열 서식 변환 함수입니다.\n\n## 로직을 캡슐화하기 위한 데이터 모델링\n\n\n\n지금까지 우리가 한 변경 사항은 뷰와 뷰가 아닌 코드를 분리하는 데 초점을 맞춰왔는데, 이것은 좋은 일이죠. 훅은 데이터를 가져오고 형태를 바꾸는 것을 관리하며, Payment와 PaymentMethods 모두 비교적 작고 이해하기 쉬운 형태가 되었어요.\n\n하지만 조금 더 자세히 살펴보면 아직 개선할 부분이 있습니다. 예를 들어, PaymentMethods 컴포넌트에서는 결제 수단이 기본적으로 선택되어야하는지 여부를 결정하는 일부 로직이 있습니다.\n\n```js\nsrc/Payment.tsx…\n\n  const PaymentMethods = ({\n    paymentMethods,\n  }: {\n    paymentMethods: LocalPaymentMethod[];\n  }) => (\n    <>\n      {paymentMethods.map((method) => (\n        <label key={method.provider}>\n          <input\n            type=\"radio\"\n            name=\"payment\"\n            value={method.provider}\n            defaultChecked={method.provider === \"cash\"}\n          />\n          <span>{method.label}</span>\n        </label>\n      ))}\n    </>\n  );\n```\n\n뷰에서 이러한 테스트 문은 로직 누출로 간주될 수 있으며, 시간이 지남에 따라 서로 다른 곳에 흩어져 수정이 더 어려워질 수 있습니다.\n\n\n\n데이터를 가져올 때 데이터 변환에서 논리 누출 가능성이 또 하나 있을 수 있습니다.\n\n```js\n useEffect(() => {\n      const fetchPaymentMethods = async () => {\n        const url = \"https://online-ordering.com/api/payment-methods\";\n  \n        const response = await fetch(url);\n        const methods: RemotePaymentMethod[] = await response.json();\n  \n        if (methods.length > 0) {\n          const extended: LocalPaymentMethod[] = methods.map((method) => ({\n            provider: method.name,\n            label: `Pay with ${method.name}`,\n          }));\n          extended.push({ provider: \"cash\", label: \"Pay in cash\" });\n          setPaymentMethods(extended);\n        } else {\n          setPaymentMethods([]);\n        }\n      };\n  \n      fetchPaymentMethods();\n    }, []);\n```\n\nmethods.map 안의 익명 함수가 변환을 묵묵히 수행합니다. 위의 `method.provider === \"cash\"`와 함께 이 논리는 클래스로 추출할 수 있습니다. 데이터와 동작을 단일 위치로 중앙 집중화한 PaymentMethod 클래스를 만들 수 있습니다.\n\n```js\n// src/PaymentMethod.ts\n\ninterface RemotePaymentMethod {\n  name: string;\n}\n\nexport interface LocalPaymentMethod {\n  provider: string;\n  label: string;\n  isDefaultMethod: boolean;\n}\n\nexport function createPaymentMethod(remotePaymentMethod: RemotePaymentMethod): LocalPaymentMethod {\n  const provider = remotePaymentMethod.name;\n  const label = provider === 'cash' ? `Pay in ${provider}` : `Pay with ${provider}`;\n  const isDefaultMethod = provider === 'cash';\n\n  return { provider, label, isDefaultMethod };\n}\n```  \n\n\n\n이제,\n\n```js\nimport { createPaymentMethod } from './PaymentMethod';\n\nuseEffect(() => {\n  const fetchPaymentMethods = async () => {\n    const url = \"https://online-ordering.com/api/payment-methods\";\n\n    const response = await fetch(url);\n    const methods: RemotePaymentMethod[] = await response.json();\n\n    if (methods.length > 0) {\n      // Memetakan setiap elemen dari methods menjadi objek LocalPaymentMethod\n      const localMethods: LocalPaymentMethod[] = methods.map(createPaymentMethod);\n\n      // Menambahkan metode pembayaran \"cash\" sebagai opsi tambahan\n      localMethods.push({ provider: \"cash\", label: \"Pay in cash\" });\n\n      // Mengatur state paymentMethods dengan array hasil pemetaan\n      setPaymentMethods(localMethods);\n    } else {\n      // Jika tidak ada metode pembayaran yang ditemukan, set state menjadi array kosong\n      setPaymentMethods([]);\n    }\n  };\n\n  fetchPaymentMethods();\n}, []);\n```\n\n이제 Payment 컴포넌트를 작업을 완료하기 위해 함께 작동하는 여러 작은 부분들로 재구성하고 있어요.\n\n![ModularizingReactApplication_6](/assets/img/2024-05-12-ModularizingReactApplication_6.png)\n\n\n\n새로운 구조에는 여러 가지 이점이 있어요:\n\n- 로직 캡슐화: 이 클래스는 모든 결제 방법 관련 로직을 캡슐화하여, 뷰에 내장하는 것보다 테스트와 수정이 더 쉬워졌어요.\n- 순수한 기능성: 추출된 컴포넌트인 PaymentMethods는 도메인 객체 배열에만 의존하는 순수한 기능이에요. 이로 인해 외부 상태와 상호 작용할 필요 없이 쉽게 테스트하고 재사용할 수 있어요.\n- 명확성과 모듈성: 각 부분이 명확하고 독립적으로 탐색할 수 있어요. 이 모듈식 접근법은 새로운 요구 사항이 발생했을 때 코드 수정을 간단하게 만들어줘요.\n\n# 새로운 요구 사항: 자선 단체에 기부하기\n\n새로운 기능인 자선 단체에 소액을 기부할 수 있는 기능을 애플리케이션에 추가하고 있어요. 고객이 주문과 함께 작은 금액을 자선 단체에 기부할 수 있는 옵션을 제공할 거예요. 사용자의 주문 총액이 $19.80이라면, $0.20을 기부할 수 있는 옵션을 제공할 거예요. 동의하면, 해당 버튼에 표시되는 총 금액을 업데이트할 거예요.\n\n\n\n\n![ModularizingReactApplication](/assets/img/2024-05-12-ModularizingReactApplication_7.png)\n\n변경을 하기 전에 현재 코드 구조를 간단히 살펴봅시다. 코드를 구조화해서 각 부분을 폴더로 구분하는 것을 선호합니다. 이렇게 하면 규모가 커져도 쉽게 탐색할 수 있어요.\n\n```js\nsrc\n      ├── App.tsx\n      ├── components\n      │   ├── Payment.tsx\n      │   └── PaymentMethods.tsx\n      ├── hooks\n      │   └── usePaymentMethods.ts\n      ├── models\n      │   └── PaymentMethod.ts\n      └── types.ts\n```\n\n우리 앱에서 App.tsx는 주 진입점으로 작동합니다. 이 파일에는 Payment 컴포넌트가 포함되어 있는데, 이 컴포넌트는 다양한 결제 옵션을 표시하기 위해 PaymentMethods를 활용합니다. usePaymentMethods 훅은 원격 서비스에서 데이터를 가져와 PaymentMethod 객체로 변환합니다. PaymentMethod 객체는 레이블과 기본 옵션 여부를 저장합니다.\n\n\n\n## 내부 상태: 기부에 동의\n\n이 페이지에서 체크박스를 선택한 사용자를 추적하기 위해 Payment에서 이러한 수정 사항을 구현하려면 agreeToDonate라는 부울 상태가 필요합니다.\n\n```js\n // 새로운 기능\n  const [agreeToDonate, setAgreeToDonate] = useState(false);\n\n  const { total, tip } = useMemo(\n    () => ({\n      total: agreeToDonate ? Math.floor(amount + 1) : amount,\n      tip: parseFloat((Math.floor(amount + 1) - amount).toPrecision(10)),\n    }),\n    [amount, agreeToDonate]\n  );\n\n  const handleChange = (event) => {\n    setAgreeToDonate(event.target.checked);\n  };\n```\n\nMath.floor 함수를 사용하여 숫자를 내림하여 사용자가 기부에 동의한 경우 올바른 금액을 얻을 수 있습니다. 내림 처리된 값과 원래 금액 간의 차이는 팁에 할당됩니다.\n\n\n\n뷰 관점에서, JSX에는 간단한 설명과 함께 체크박스가 포함될 것입니다:\n\n```js\nsrc/Payment.tsx…\n\n  return (\n    <div>\n      <h3>Payment</h3>\n      <PaymentMethods options={paymentMethods} />\n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            onChange={handleChange}\n            checked={agreeToDonate}\n          />\n          <p>\n            {agreeToDonate\n              ? \"기부해 주셔서 감사합니다.\"\n              : `나는 자선에 $${tip}을 기부하고 싶어합니다.`}\n          </p>\n        </label>\n      </div>\n      <button>${total}</button>\n    </div>\n  );\n```\n\n이러한 새로운 변경 사항으로 코드가 다시 여러 작업을 처리하기 시작합니다. 뷰 관련 코드와 비뷰 관련 코드가 혼합되지 않도록 주의깊게 관찰하는 것이 중요합니다. 불필요한 혼합이 발견된다면 분리할 수 있는 방법을 고려해보세요.\n\n그러나 이것은 엄격한 규칙은 아닙니다. 작고 일관된 구성 요소의 경우, 모든 것을 깔끔하게 유지하여 전반적인 작동 방식을 이해하기 위해 여러 곳을 찾아다닐 필요가 없도록 해도 괜찮습니다. 그러나 컴포넌트 파일이 이해하기 어렵게 너무 커지지 않도록 주의해야 합니다.\n\n\n\n# 훅을 활용하여 해결책 모색\n\n이 상황에서는 기부 여부에 따라 팁과 총액을 계산할 수 있는 객체가 필요합니다. 사용자가 기부 여부를 변경할 때마다 업데이트된 총액과 팁을 반환해야 합니다. \n\n이 요구 사항을 충족하기 위해 이러한 로직을 캡슐화하는 사용자 정의 훅을 구현하는 것이 이상적입니다. 이 사용자 정의 훅은 사용자의 입력을 기반으로 총액 및 팁 값을 계산하며 깔끔하고 재사용 가능한 솔루션을 제공할 것입니다.\n\n```js\nsrc/hooks/useRoundUp.ts…\n\n  export const useRoundUp = (amount: number) => {\n    const [agreeToDonate, setAgreeToDonate] = useState<boolean>(false);\n  \n    const {total, tip} = useMemo(\n      () => ({\n        total: agreeToDonate ? Math.floor(amount + 1) : amount,\n        tip: parseFloat((Math.floor(amount + 1) - amount).toPrecision(10)),\n      }),\n      [amount, agreeToDonate]\n    );\n  \n    const updateAgreeToDonate = () => {\n      setAgreeToDonate((agreeToDonate) => !agreeToDonate);\n    };\n  \n    return {\n      total,\n      tip,\n      agreeToDonate,\n      updateAgreeToDonate,\n    };\n  };\n```\n\n\n\n그래서 뷰에서는 초기 금액을 전달하여 이 훅을 활용할 것입니다. 이 훅은 모든 필요한 상태를 내부적으로 관리할 것입니다. 사용자가 기부 선호도를 토글할 때마다 updateAgreeToDonate 함수를 사용하여 훅의 값을 수정할 수 있습니다. 그러면 업데이트된 총액과 팁 금액을 반영하기 위해 리렌더링이 트리거됩니다.\n\n```js\nsrc/components/Payment.tsx…\n\n  export const Payment = ({ amount }: { amount: number }) => {\n    const { paymentMethods } = usePaymentMethods();\n  \n    const { total, tip, agreeToDonate, updateAgreeToDonate } = useRoundUp(amount);\n  \n    return (\n      <div>\n        <h3>Payment</h3>\n        <PaymentMethods options={paymentMethods} />\n        <div>\n          <label>\n            <input\n              type=\"checkbox\"\n              onChange={updateAgreeToDonate}\n              checked={agreeToDonate}\n            />\n            <p>{formatCheckboxLabel(agreeToDonate, tip)}</p>\n          </label>\n        </div>\n        <button>${total}</button>\n      </div>\n    );\n  };\n```\n\n메시지 형식 지정 로직을 formatCheckboxLabel과 같은 도우미 함수로 추출하는 것은 실제로 컴포넌트의 코드를 단순화할 것입니다. 이 도우미 함수는 사용자가 기부에 동의했는지 여부에 따라 적절한 메시지를 생성하는 논리를 처리할 수 있습니다.\n\n```js\nconst formatCheckboxLabel = (agreeToDonate: boolean, tip: number) => {\n  return agreeToDonate\n    ? \"기부해 주셔서 감사합니다.\"\n    : `자선 단체에 $${tip} 기부하고 싶습니다.`;\n};\n```\n\n\n\n상태와 로직을 useRoundUp과 같은 사용자 정의 훅에서 관리함으로써 Payment 컴포넌트가 훨씬 간단해지고 렌더링에 집중할 수 있습니다. 역할의 분리로 코드를 이해, 테스트 및 유지 관리하기 쉬워집니다. 또한 기부 확인란을 별도의 컴포넌트로 추출하는 것은 모듈성과 재사용성을 더욱 향상시켜 React 개발에서의 모범 사례를 준수합니다.\n\n```js\nsrc/components/DonationCheckbox.tsx…\n\n  const DonationCheckbox = ({\n    onChange,\n    checked,\n    content,\n  }: DonationCheckboxProps) => {\n    return (\n      <div>\n        <label>\n          <input type=\"checkbox\" onChange={onChange} checked={checked} />\n          <p>{content}</p>\n        </label>\n      </div>\n    );\n  };\n```\n\n또한 Payment에서는 React의 선언적 UI 덕분에 코드를 간단하게 읽을 수 있습니다. 거칠고 단순한 HTML조각처럼요.\n\n```js\nsrc/components/Payment.tsx…\n\n  export const Payment = ({ amount }: { amount: number }) => {\n    const { paymentMethods } = usePaymentMethods();\n  \n    const { total, tip, agreeToDonate, updateAgreeToDonate } = useRoundUp(amount);\n  \n    return (\n      <div>\n        <h3>Payment</h3>\n        <PaymentMethods options={paymentMethods} />\n        <DonationCheckbox\n          onChange={updateAgreeToDonate}\n          checked={agreeToDonate}\n          content={formatCheckboxLabel(agreeToDonate, tip)}\n        />\n        <button>${total}</button>\n      </div>\n    );\n  };\n```\n\n\n\n이제 이 시점에서 우리의 코드 구조는 아래 다이어그램과 같이 보입니다. 각 부분이 자신의 업무에 집중하고 프로세스가 작동하도록 함께 모이는 것에 주목해주세요.\n\n![모듈화된 리액트 애플리케이션 다이어그램](/assets/img/2024-05-12-ModularizingReactApplication_8.png)\n\n# 참고","ogImage":{"url":"/assets/img/2024-05-12-ModularizingReactApplication_0.png"},"coverImage":"/assets/img/2024-05-12-ModularizingReactApplication_0.png","tag":["Tech"],"readingTime":17},{"title":"React 앱을 GitHub 저장소에 연결하기","description":"","date":"2024-05-12 21:52","slug":"2024-05-12-ConnectingaReactApptoaGitHubRepository","content":"\n\n![이미지](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_0.png)\n\n이\n튜토리얼에서는 React 애플리케이션을 GitHub 저장소에 연결하는 방법을 배울 것입니다. 이 연결은 프로젝트에서 변경 사항을 추적하고 다른 사람들과 효과적으로 협업하는 데 중요합니다.\n\n다음은 시작하는 데 도움이 될 수 있는 단계별 가이드입니다:\n\n## 1. React 앱 만들기:\n\n\n\n비주얼 스튜디오 코드 터미널에서 다음 명령을 사용하여 React 애플리케이션을 시작하세요:\n\n```js\nnpx create-react-app my-react-app\n```\n\n앱의 디렉토리로 이동하세요:\n\n```js\ncd my-first-app\n```\n\n\n\n아래는 표의 내용입니다.\n\n| Order Number | Product Name | Quantity |\n|--------------|--------------|----------|\n| 1            | T-shirt      | 2        |\n| 2            | Jeans        | 1        |\n| 3            | Shoes        | 2        |\n\n\n\n한 번 시작하면 브라우저에서 앱이 작동하는 것을 볼 수 있을 거에요.\n\n![이미지](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_2.png)\n\n### 3. GitHub 저장소 설정:\n\n선택한 이름으로 새 GitHub 저장소를 만드세요. 다른 설정은 기본값으로 둬두 돼요.\n\n\n\n\n![Connecting a React App to a GitHub Repository](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_3.png)\n\nOnce created, you'll land on a new page.\n\n![Connecting a React App to a GitHub Repository](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_4.png)\n\nRemember to copy the repository link.\n\n\n\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_5.png\" />\n\n## 4. GitHub 저장소에 React 앱 연결하기:\n\nReact 애플리케이션의 디렉토리에서 새 터미널 탭을 열고 (필요시) 다음을 사용하여 앱 디렉토리로 이동하세요:\n\n```js\ncd my-first-app\n```\n\n\n\n기토 저장소를 초기화하세요\n\n```js\ngit init\n```\n\n아래 명령어를 사용하여 앱을 GitHub 저장소에 연결하세요. `<username>`을 여러분의 GitHub 사용자 이름으로 바꿔주세요:\n\n```js\ngit remote add origin https://github.com/<username>/my-first-app.git\n```\n\n\n\n내 경우에는\n\n```js\ngit remote add origin https://github.com/Brianhulela/my-first-app.git\n```\n\n![이미지](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_6.png)\n\n명령이 실행을 완료하면 다음 명령으로 연결을 확인합니다:\n\n\n\n```js\ngit remote -v\n```\n\n저장소 이름을 확인할 수 있어야 합니다. 저의 경우에는 출력이 다음과 같았습니다:\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_7.png\" />\n\n## 5. 변경 내용 준비 및 푸시:\n\n\n\n다음 명령을 실행하여 변경 내용을 커밋할 준비를 합니다:\n\n```js\ngit add .\ngit commit -m \"첫 번째 git 커밋\"\n```\n\n앱에 변경 사항이 없는 경우 커밋이 \"working tree clean\"을 반환할 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_8.png)\n\n\n\n## 6. 저장소로 푸시하기:\n\n귀하의 앱을 GitHub 저장소로 푸시하려면 다음을 사용하십시오:\n\n```js\ngit push\n```\n\n\"upstream\" 브랜치에 관한 오류가 발생할 수 있습니다. 마스터 브랜치가 아직 업스트림으로 설정되지 않았기 때문입니다. 다음 단계에서 이를 수행하겠습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_9.png\" />\n\n## 7. Upstream Branch 설정하기:\n\n다음 명령어를 사용하여 upstream branch를 설정하여 에러를 해결하세요:\n\n```js\ngit push --set-upstream origin master\n```\n\n\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_10.png\" />\n\n## 7. GitHub에서 확인하기:\n\n마지막으로, React 애플리케이션이 성공적으로 푸시되었는지 확인하기 위해 GitHub 저장소를 확인하세요.\n\n<img src=\"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_11.png\" />\n\n\n\n이 단계를 따라하면 React 앱과 GitHub 저장소 간에 연결을 설정하여 효율적인 버전 관리와 협업이 가능해집니다.\n\n저장소: [https://github.com/Brianhulela/my-first-app](https://github.com/Brianhulela/my-first-app)","ogImage":{"url":"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_0.png"},"coverImage":"/assets/img/2024-05-12-ConnectingaReactApptoaGitHubRepository_0.png","tag":["Tech"],"readingTime":3},{"title":"잔머리 풀기 CORS와 함께하는 Spring Boot, Spring Security","description":"","date":"2024-05-12 21:49","slug":"2024-05-12-WhattheCORSftSpringBootSpringSecurity","content":"\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_0.png\" />\n\n알겠습니다. 어느 날 한 마리로 리소스를 만들고, 읽고, 업데이트하고, 삭제할 수 있는 단일 리소스에 노출된 엔드포인트를 제공하는 간단한 Rest API를 만들려고 했습니다. React를 사용하여 이러한 요청을 제출하는 작은 폼을 만들고 싶었습니다.\n\n주의하세요, 다음 React 폼은 정말 진보적입니다. 이러한 종류의 폼을 만들려면 최소한 닌자 수준의 React 개발자여야합니다.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_1.png\" />\n\n\n\n친구들은 부러워하지 마세요!\n\n그래서 제 Rest API(Spring Boot으로 만든)는 'http://localhost:8080'에서 실행되고, 내 React 앱은 'http://localhost:3000'에서 실행 중이었어요.\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_2.png)\n\n첫 번째 포스트 요청을 보내 리소스를 서버에 만들 준비가 끝났어요. 기다림이 여린 마음으로, 마치 JPL 직원들이 Perseverance 착륙을 기다리던 것처럼요.\n\n\n\n그 다음 콘솔에서 이것을 보았어요\n\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_3.png)\n\n그리고 '개발자 콘솔'의 네트워크 탭으로 들어가서 더 자세히 파헤치려고 했더니, 두 개의 요청이 남아 있는 것을 보았어요\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_4.png)\n\n\n\n리액트 코드에서 fetch api를 사용하여 아래 POST 요청을 보냈습니다.\n\n![POST 요청](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_5.png)\n\n페이지에서 해당 제출 버튼을 누른 후, 두 가지에 대해 혼란스러웠습니다: \n\n- 왜 내 POST가 실패했는지\n- 개발자 콘솔 스크린샷에서 두 개의 요청이 서버 네트워크 탭에 표시되는 이유\n\n\n\nCORS 소개\n\nCORS는 특정 자바스크립트 코드(예: 내 React 코드 - http://localhost:3000)가 서버(내 서버에서 실행 중인 Spring Boot Rest Api - http://localhost:8000)로부터 리소스를 요청할 권한이 있는지 브라우저가 이해하는 방법입니다. 서버에서 허용되지 않으면 브라우저가 CORS 예외를 간단히 발생시킵니다.\n\n콘솔에서 받은 오류 메시지로 이해해 봅시다:\n\n\nfetch에 대한 액세스가 CORS 정책에 의해 차단되었습니다. ‘http://localhost:8080/airports`에서 `http://localhost:3000` 출처로부터: 사전 플라이트 요청에 대한 응답이 액세스 제어 확인을 통과하지 못함: 요청한 리소스에 ‘Access-Control-Allow-Origin’ 헤더가 없습니다. 불투명한 응답이 필요한 경우 요청의 모드를 ‘no-cors’로 설정하여 CORS가 비활성화된 상태로 리소스를 가져올 수 있습니다.\n\n\n\n\n여기 이해해야 할 키포인트는 '오리진(origin)'입니다. '오리진'은 '프로토콜://호스트:포트'의 조합입니다. 따라서 요청은 'http://localhost:3000'이라는 오리진에서 이루어지고 요청은 'http://localhost:8080'으로 보내집니다. 이는 두 개의 다른 오리진 간의 통신을 시도하는 것입니다. 따라서 이러한 경우에는 브라우저가 요청자(http://localhost:3000)가 요청받는이(http://localhost:8080)로부터 리소스를 요청할 수 있는지 확인합니다. 요청자가 허용되지 않을 경우, 요청을 할 때 CORS 에러가 발생합니다.\n\n그런데 왜 네트워크 탭에서 두 개의 요청이 발생하는 것일까요?\n\n주의 깊게 살펴보면, 하나의 요청은 'preflight'로 분류되고 다른 하나(즉, 실제로 POST를 하는 요청)는 스크린샷에서 보듯이 'CORS 에러'로 분류됩니다. 따라서 브라우저들은 먼저 POST 요청을 보내지 않고, 서버에서 허용된 '오리진'이 무엇인지 확인하려고 먼저 시도합니다. 이 확인을 위해 서버로 OPTIONS 요청을 보냅니다. 이는 종종 'preflight' 요청이라고 불립니다.\n\n따라서 이 preflight 요청으로 브라우저가 실제로 무엇을 기대하고 있는지 알아볼까요?\n\n\n\n브라우저는 서버로부터 해당 요청을 수락할 수 있다는 응답 헤더를 받기를 기다리고 있어요.\n\n정확히 어떤 응답 헤더인가요?\n\n\"access-control-allow-origin\" — 여기서 허용된 출처가 명시된 헤더에요. localhost:3000이 헤더에 명시되어 있다면 우리는 업무를 진행할 수 있어요.\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_6.png)\n\n\n\n이렇게 실패한 사전 플라이트 요청을 확인해 봅시다.\n\n요청 방법이 ‘OPTIONS’이고 서버에서 그 요청을 하지 못하게 하는 (403) 것으로 나왔네요. 그리고 나의 응답 헤더에는 ‘Access-Control-Allow-Origin’이라고 언급된 것이 없습니다. 결국, 서버 측에서 \"OPTIONS\" 요청 방법이 정의되지 않았기 때문에 사전 플라이트 요청 자체가 실패했습니다.\n\n![image](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_7.png)\n\n내 컨트롤러에는 기본적인 CRUD 요청 매핑(GET, POST, PUT, DELETE)만 있습니다.\n\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_8.png\" />\n\n이제 원래 질문은 무엇일까요? 사전검사(preflight)가 허용된 출처를 확인하고 \"http://localhost:3000\"을 허용된 출처로 허용하는 방법은 무엇일까요?\n\nSpring Boot은 @CrossOrigin 어노테이션을 통해 간단한 해결책을 제공합니다. 컨트롤러 클래스 상단에 이렇게 간단히 넣어보세요.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_9.png\" />\n\n\n\n이제 Spring Boot 애플리케이션을 다시 시작하고 리소스를 게시해 보았어요.\n\n그러자 성공했어요!\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_10.png)\n\n이제 프리플라이트와 포스트 요청이 모두 '200 - A Ok ;)'로 성공적으로 나갔다는 것을 확인하실 수 있을 거예요.\n\n\n\n자 이제 사전 검사 요청과 응답 헤더를 살펴보겠습니다.\n\n사전 검사의 요청 헤더에서 요청 방법은 ‘OPTIONS’이며 응답 헤더에서는 다음을 알 수 있습니다.\n\n‘Access-Control-Allow-Origin’ : * (이는 어떤 출처에서도 서버로의 요청을 보낼 수 있다는 것을 나타내므로 제 리액트 애플리케이션도 요청을 보낼 수 있는 자격이 있습니다.)\n\n‘Access-Control-Allow-Methods’ : POST (사전 검사는 만들어질 POST가 자격이 있다는 것을 확인했습니다)\n\n\n\n'허용' : GET, HEAD, POST, PUT, DELETE, OPTIONS, PATCH.\n\n서버의 @CrossOrigins 변경 전에 사전 요청(preflight request)이 서버에서 OPTIONS가 허용되지 않았기 때문에 403 상태를 받았습니다. 하지만 이제 서버에서 모든 요청 방법이 허용되는 것을 볼 수 있습니다. 따라서 preflight인 \"OPTIONS\" 요청이 서버에 선언된 엔드포인트가 없더라도 정상적으로 진행됩니다.\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_11.png)\n\n컨트롤러에 @CrossOrigins를 선언하는 것만으로 모든 출처와 방법이 서버에 도달할 수 있는 문을 열게 됩니다. 하지만 실제 응용 프로그램에서는 그런 것을 원하지 않을 것입니다. 따라서 @CrossOrigins의 이러한 속성을 사용하여 서버에서 필터링하고자 하는 출처와 방법을 사용자 정의할 수 있습니다.\n\n\n\n- origins = \"http://localhost:3000\"\n\n(내 React 앱만 요청할 수 있게 해줍니다)\n\n2. methods='RequestMethod.GET,RequestMethod.POST,RequestMethod.PUT,RequestMethod.DELETE'\n\n(어떤 메서드를 요청에서 허용할 지 정의할 수 있습니다)\n\n\n\n다른 것들을 선언하여 헤더를 허용하는 것, 자격 증명을 허용하는지 등을 확인할 수 있습니다. 스스로 살펴보세요!\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_12.png)\n\nPhase II — 스프링 시큐리티를 사용하여 내 요청에 기본 인증 부착\n\n좋아요. 이 자신감을 얻은 후에, 나는 내 REST API에 스프링 시큐리티를 부착해보고 싶었습니다. 요청을 인증하는 방법으로 기본 인증을 허용하려고 했습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_13.png\" />\n\n나는 닌자인 나로써, pom.xml에 Spring Security 스타터 종속성을 추가하고 메이븐 종속성을 업데이트하고 서버를 시작했어. 서버를 다시 시작하면, Spring Security가 응용 프로그램에 '사용자'라는 기본 사용자 이름과 Spring Security가 무작위로 생성하는 해시된 비밀번호로 인증 레이어를 추가해.\n\n이제, 리액트 애플리케이션에서 동일한 포스트 요청을 보냈어.\n\n그리고 다시 한 번, 무서운 CORS 예외가 발생했어.\n\n\n![2024-05-12-WhattheCORSftSpringBootSpringSecurity_14](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_14.png)\n\n네트워크에 들어가서 문제를 더 디버깅했습니다.\n\npost 요청이 하나만 있었고 프리플라이트 요청은 없었습니다. post 요청에 대한 응답에는 'Access-Control-Allow-Origin'이 설정되어 있지 않았습니다. 또한 'WWW-Authenticate:Basic realm=\"Realm\"' 헤더를 확인했습니다.\n\n![2024-05-12-WhattheCORSftSpringBootSpringSecurity_15](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_15.png)\n\n\n\n그래서 기본적으로 스프링 시큐리티를 활성화한 후에는 두 가지 작업을 수행해야 합니다:\n\n- 요청을 보낼 때 클라이언트에서 기본 인증 요청을 보내야 합니다.\n- 서버가 React 애플리케이션이 허용된 출처임을 나타내는 Access-Control-Allow-Origin 플래그를 보내야 합니다.\n\n그런데, 우리가 컨트롤러에 @CrossOrigins를 이미 언급했었죠.\n\n그렇지만, 스프링 시큐리티를 활성화했을 때는 고려되지 않으니 이를 해결할 방법이 필요합니다.\n\n\n\n한 단계씩 해결해 보겠습니다.\n\n- 우리 클라이언트에서 기본 인증 요청을 보냅시다.\n\nFetch를 사용하므로 React에서 POST 호출을 할 때 보내는 매개변수에 다음 헤더 정보를 첨부해야 합니다:\n\n\n\"Authorization\":\"Basic Base64encoded(username:password)\"\n\n\n\n\n제 사용자 이름은 \"user\"이고,\n\n비밀번호는 \"harambe\"입니다.\n\n리액트에서 btoa라는 함수를 사용할 수 있습니다. 사용자 이름과 비밀번호를 이 함수에 전달하면 btoa(user:harambe)처럼 보일 것입니다. btoa 메소드는 base64 인코딩된 문자열을 반환합니다. 그래서 결과물은 다음과 같이 보일 것입니다:\n\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_16.png)\n\n\n\n기본 및 btoa(username:password) 방법 사이에 공백을 유지하는 것을 잊지 마세요. 이것은 인증을 돕게 됩니다.\n\n이제 해당 포스트 호출을 다시 시도해 봅시다.\n\n![이미지](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_17.png)\n\n음, 음, 여기 누가 있나요. 네트워크로 이동하여 사전 휴식 및 포스트 요청을 모두 확인했습니다.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_18.png\" />\n\n패턴은 프로젝트에 spring security를 추가하기 전에 만난 것과 똑같아요. 권한이없는 하나의 사전(OPTIONS) 요청과 별도의 CORS 예외가 있다 fetch POST 호출(실제 호출).\n\n사전 요청과 응답을 살펴보면, 서버에서는 액세스 허용 제어 원점을 반환하지 않았고 OPTIONS 요청에서도 인증을 예상하고 있었어요.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_19.png\" />\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_20.png\" />\n\n저는 주말 절반을 보내며 Spring Security를 구성하여 Cross Origin 요청을 허용하는 방법을 찾았습니다. 이 코드를 발견했어요.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_21.png\" />\n\n이 Rest API를 호스팅하는 주요 Spring 애플리케이션에서 이러한 기본 제공 메서드를 호출하여 Spring Security 구성을 구성하세요.\n\n\n\n여기 메서드가 있어요.\n\n- cors() - 스프링 시큐리티에 CORS를 활성화하라고 알려줍니다. 이제 서버는 오리진을 화이트리스트/필터링할 준비가 되었어요. 그래서 여전히 오리진 목록을 설정할 것입니다.\n- httpBasic() - 클라이언트가 기본 인증 방식을 통해 요청을 인증할 것이라고 스프링 시큐리티에 알려줍니다. 그래서 스프링 시큐리티는 클라이언트에서 보내는 'Authorization': 'Basic #해시'를 읽을 수 있도록 조정되어 있어요. 유효한 인증 정보인 경우, 스프링 시큐리티는 우리를 통과시켜줄 거에요.\n\n코드에서 보이는 나머지 메서드들에 대해서는 다른 블로그 포스트를 계획 중이에요.\n\n지금은 cors()가 활성화된 상태일 뿐, 화이트리스트에 등록할 오리진을 아직 설정해야 해요.\n\n\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_22.png\" />\n\n여기서 컨트롤러를 보면 다음과 같은 설정을 추가했습니다.\n\n- origins = \"http://localhost:3000\" : 내 리액트 코드가 있는 곳입니다.\n- allowCredentials = true: 인증 형식을 사용한다면 중요한 부분입니다.\n\n기본적으로 @CrossOrigin은 모든 요청 방식과 헤더를 허용합니다. 그래서 사전 통지 요청에 문제가 없을 겁니다.\n\n\n\n지금, 다시 그 게시 버튼을 눌러보세요\n\n![이미지1](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_23.png)\n\n![이미지2](/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_24.png)\n\n마침내, 영광의 달콤함.\n\n\n\n이곳에 있는 두 번째 요청은 무시해 주세요. Preflight에서 온 것이 아닙니다. 화면 캡처에서 보는 것처럼, 뭔가를 게시한 후에 'Get'을 수행하는 로직을 작성했습니다.\n\n우리의 설정으로 인해 POST 요청 및 응답 헤더가 어떻게 영향을 받는지 확인해보겠습니다.\n\n<img src=\"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_25.png\" />\n\n'Access-Control-Allow-Credentials' 플래그가 true로 설정되어 있고, 허용된 출처에는 React 애플리케이션 원본이 표시되는 것을 볼 수 있습니다.\n\n\n\n행복한 하루 보내세요!","ogImage":{"url":"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_0.png"},"coverImage":"/assets/img/2024-05-12-WhattheCORSftSpringBootSpringSecurity_0.png","tag":["Tech"],"readingTime":9}],"page":"131","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}